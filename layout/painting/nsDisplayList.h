#
ifndef
NSDISPLAYLIST_H_
#
define
NSDISPLAYLIST_H_
#
include
"
gfxContext
.
h
"
#
include
"
mozilla
/
ArenaAllocator
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Array
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
EnumSet
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
TemplateLib
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsPoint
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nsDisplayListInvalidation
.
h
"
#
include
"
DisplayListClipState
.
h
"
#
include
"
LayerState
.
h
"
#
include
"
FrameMetrics
.
h
"
#
include
"
mozilla
/
EnumeratedArray
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
gfx
/
UserData
.
h
"
#
include
"
mozilla
/
layers
/
LayerAttributes
.
h
"
#
include
"
nsCSSRenderingBorders
.
h
"
#
include
"
nsAutoLayoutPhase
.
h
"
#
include
"
nsDisplayItemTypes
.
h
"
#
include
<
stdint
.
h
>
#
include
"
nsTHashtable
.
h
"
#
include
<
stdlib
.
h
>
#
include
<
algorithm
>
class
gfxContext
;
class
nsIContent
;
class
nsDisplayList
;
class
nsDisplayTableItem
;
class
nsISelection
;
class
nsIScrollableFrame
;
class
nsDisplayLayerEventRegions
;
class
nsDisplayScrollInfoLayer
;
class
nsCaret
;
namespace
mozilla
{
class
FrameLayerBuilder
;
namespace
layers
{
class
Layer
;
class
ImageLayer
;
class
ImageContainer
;
class
StackingContextHelper
;
class
WebRenderCommand
;
class
WebRenderScrollData
;
class
WebRenderLayerScrollData
;
}
namespace
wr
{
class
DisplayListBuilder
;
}
}
typedef
mozilla
:
:
EnumSet
<
mozilla
:
:
gfx
:
:
CompositionOp
>
BlendModeSet
;
#
define
NS_DISPLAY_DECL_NAME
(
n
e
)
\
virtual
const
char
*
Name
(
)
const
override
{
return
n
;
}
\
virtual
DisplayItemType
GetType
(
)
const
override
{
return
DisplayItemType
:
:
e
;
}
\
void
*
operator
new
(
size_t
aSize
\
nsDisplayListBuilder
*
aBuilder
)
{
\
return
aBuilder
-
>
Allocate
(
aSize
DisplayItemType
:
:
e
)
;
\
}
struct
AnimatedGeometryRoot
{
AnimatedGeometryRoot
(
nsIFrame
*
aFrame
AnimatedGeometryRoot
*
aParent
)
:
mFrame
(
aFrame
)
mParentAGR
(
aParent
)
{
}
operator
nsIFrame
*
(
)
{
return
mFrame
;
}
nsIFrame
*
operator
-
>
(
)
const
{
return
mFrame
;
}
void
*
operator
new
(
size_t
aSize
nsDisplayListBuilder
*
aBuilder
)
;
nsIFrame
*
mFrame
;
AnimatedGeometryRoot
*
mParentAGR
;
}
;
namespace
mozilla
{
struct
ActiveScrolledRoot
{
ActiveScrolledRoot
(
const
ActiveScrolledRoot
*
aParent
nsIScrollableFrame
*
aScrollableFrame
)
:
mParent
(
aParent
)
mScrollableFrame
(
aScrollableFrame
)
mDepth
(
mParent
?
mParent
-
>
mDepth
+
1
:
1
)
{
}
static
const
ActiveScrolledRoot
*
PickAncestor
(
const
ActiveScrolledRoot
*
aOne
const
ActiveScrolledRoot
*
aTwo
)
{
MOZ_ASSERT
(
IsAncestor
(
aOne
aTwo
)
|
|
IsAncestor
(
aTwo
aOne
)
)
;
return
Depth
(
aOne
)
<
=
Depth
(
aTwo
)
?
aOne
:
aTwo
;
}
static
const
ActiveScrolledRoot
*
PickDescendant
(
const
ActiveScrolledRoot
*
aOne
const
ActiveScrolledRoot
*
aTwo
)
{
MOZ_ASSERT
(
IsAncestor
(
aOne
aTwo
)
|
|
IsAncestor
(
aTwo
aOne
)
)
;
return
Depth
(
aOne
)
>
=
Depth
(
aTwo
)
?
aOne
:
aTwo
;
}
static
bool
IsAncestor
(
const
ActiveScrolledRoot
*
aAncestor
const
ActiveScrolledRoot
*
aDescendant
)
;
static
nsCString
ToString
(
const
mozilla
:
:
ActiveScrolledRoot
*
aActiveScrolledRoot
)
;
void
IncrementDepth
(
)
{
mDepth
+
+
;
}
const
ActiveScrolledRoot
*
mParent
;
nsIScrollableFrame
*
mScrollableFrame
;
private
:
static
uint32_t
Depth
(
const
ActiveScrolledRoot
*
aActiveScrolledRoot
)
{
return
aActiveScrolledRoot
?
aActiveScrolledRoot
-
>
mDepth
:
0
;
}
uint32_t
mDepth
;
}
;
}
enum
class
nsDisplayListBuilderMode
:
uint8_t
{
PAINTING
EVENT_DELIVERY
PLUGIN_GEOMETRY
FRAME_VISIBILITY
TRANSFORM_COMPUTATION
GENERATE_GLYPH
PAINTING_SELECTION_BACKGROUND
}
;
class
nsDisplayListBuilder
{
typedef
mozilla
:
:
LayoutDeviceIntRect
LayoutDeviceIntRect
;
typedef
mozilla
:
:
LayoutDeviceIntRegion
LayoutDeviceIntRegion
;
class
Preserves3DContext
{
public
:
typedef
mozilla
:
:
gfx
:
:
Matrix4x4
Matrix4x4
;
Preserves3DContext
(
)
:
mAccumulatedRectLevels
(
0
)
{
}
Preserves3DContext
(
const
Preserves3DContext
&
aOther
)
:
mAccumulatedTransform
(
)
mAccumulatedRect
(
)
mAccumulatedRectLevels
(
0
)
mDirtyRect
(
aOther
.
mDirtyRect
)
{
}
Matrix4x4
mAccumulatedTransform
;
nsRect
mAccumulatedRect
;
int
mAccumulatedRectLevels
;
nsRect
mDirtyRect
;
}
;
enum
AGRState
{
AGR_NO
AGR_YES
AGR_MAYBE
}
;
public
:
typedef
mozilla
:
:
FrameLayerBuilder
FrameLayerBuilder
;
typedef
mozilla
:
:
DisplayItemClip
DisplayItemClip
;
typedef
mozilla
:
:
DisplayItemClipChain
DisplayItemClipChain
;
typedef
mozilla
:
:
DisplayListClipState
DisplayListClipState
;
typedef
mozilla
:
:
ActiveScrolledRoot
ActiveScrolledRoot
;
typedef
nsIWidget
:
:
ThemeGeometry
ThemeGeometry
;
typedef
mozilla
:
:
layers
:
:
Layer
Layer
;
typedef
mozilla
:
:
layers
:
:
FrameMetrics
FrameMetrics
;
typedef
mozilla
:
:
layers
:
:
FrameMetrics
:
:
ViewID
ViewID
;
typedef
mozilla
:
:
gfx
:
:
Matrix4x4
Matrix4x4
;
nsDisplayListBuilder
(
nsIFrame
*
aReferenceFrame
nsDisplayListBuilderMode
aMode
bool
aBuildCaret
)
;
~
nsDisplayListBuilder
(
)
;
void
BeginFrame
(
)
;
void
EndFrame
(
)
;
void
AddTemporaryItem
(
nsDisplayItem
*
aItem
)
{
mTemporaryItems
.
AppendElement
(
aItem
)
;
}
void
SetWillComputePluginGeometry
(
bool
aWillComputePluginGeometry
)
{
mWillComputePluginGeometry
=
aWillComputePluginGeometry
;
}
void
SetForPluginGeometry
(
bool
aForPlugin
)
{
if
(
aForPlugin
)
{
NS_ASSERTION
(
mMode
=
=
nsDisplayListBuilderMode
:
:
PAINTING
"
Can
only
switch
from
PAINTING
to
PLUGIN_GEOMETRY
"
)
;
NS_ASSERTION
(
mWillComputePluginGeometry
"
Should
have
signalled
this
in
advance
"
)
;
mMode
=
nsDisplayListBuilderMode
:
:
PLUGIN_GEOMETRY
;
}
else
{
NS_ASSERTION
(
mMode
=
=
nsDisplayListBuilderMode
:
:
PLUGIN_GEOMETRY
"
Can
only
switch
from
PAINTING
to
PLUGIN_GEOMETRY
"
)
;
mMode
=
nsDisplayListBuilderMode
:
:
PAINTING
;
}
}
mozilla
:
:
layers
:
:
LayerManager
*
GetWidgetLayerManager
(
nsView
*
*
aView
=
nullptr
)
;
bool
IsForEventDelivery
(
)
{
return
mMode
=
=
nsDisplayListBuilderMode
:
:
EVENT_DELIVERY
;
}
bool
IsForPluginGeometry
(
)
{
return
mMode
=
=
nsDisplayListBuilderMode
:
:
PLUGIN_GEOMETRY
;
}
bool
IsForPainting
(
)
{
return
mMode
=
=
nsDisplayListBuilderMode
:
:
PAINTING
;
}
bool
IsForFrameVisibility
(
)
{
return
mMode
=
=
nsDisplayListBuilderMode
:
:
FRAME_VISIBILITY
;
}
bool
IsForGenerateGlyphMask
(
)
{
return
mMode
=
=
nsDisplayListBuilderMode
:
:
GENERATE_GLYPH
;
}
bool
IsForPaintingSelectionBG
(
)
{
return
mMode
=
=
nsDisplayListBuilderMode
:
:
PAINTING_SELECTION_BACKGROUND
;
}
bool
WillComputePluginGeometry
(
)
{
return
mWillComputePluginGeometry
;
}
bool
IsBackgroundOnly
(
)
{
NS_ASSERTION
(
mPresShellStates
.
Length
(
)
>
0
"
don
'
t
call
this
if
we
'
re
not
in
a
presshell
"
)
;
return
CurrentPresShellState
(
)
-
>
mIsBackgroundOnly
;
}
bool
IsAtRootOfPseudoStackingContext
(
)
{
return
mIsAtRootOfPseudoStackingContext
;
}
nsISelection
*
GetBoundingSelection
(
)
{
return
mBoundingSelection
;
}
const
nsIFrame
*
FindReferenceFrameFor
(
const
nsIFrame
*
aFrame
nsPoint
*
aOffset
=
nullptr
)
;
nsIFrame
*
RootReferenceFrame
(
)
{
return
mReferenceFrame
;
}
const
nsPoint
ToReferenceFrame
(
const
nsIFrame
*
aFrame
)
{
nsPoint
result
;
FindReferenceFrameFor
(
aFrame
&
result
)
;
return
result
;
}
void
SetIgnoreScrollFrame
(
nsIFrame
*
aFrame
)
{
mIgnoreScrollFrame
=
aFrame
;
}
nsIFrame
*
GetIgnoreScrollFrame
(
)
{
return
mIgnoreScrollFrame
;
}
ViewID
GetCurrentScrollParentId
(
)
const
{
return
mCurrentScrollParentId
;
}
void
ForceLayerForScrollParent
(
)
{
mForceLayerForScrollParent
=
true
;
}
ViewID
GetCurrentScrollbarTarget
(
)
const
{
return
mCurrentScrollbarTarget
;
}
uint32_t
GetCurrentScrollbarFlags
(
)
const
{
return
mCurrentScrollbarFlags
;
}
bool
IsBuildingNonLayerizedScrollbar
(
)
const
{
return
mIsBuildingScrollbar
&
&
!
mCurrentScrollbarWillHaveLayer
;
}
void
SetIncludeAllOutOfFlows
(
)
{
mIncludeAllOutOfFlows
=
true
;
}
bool
GetIncludeAllOutOfFlows
(
)
const
{
return
mIncludeAllOutOfFlows
;
}
void
SetSelectedFramesOnly
(
)
{
mSelectedFramesOnly
=
true
;
}
bool
GetSelectedFramesOnly
(
)
{
return
mSelectedFramesOnly
;
}
bool
GetAccurateVisibleRegions
(
)
{
return
mMode
=
=
nsDisplayListBuilderMode
:
:
PLUGIN_GEOMETRY
;
}
bool
IsBuildingCaret
(
)
{
return
mBuildCaret
;
}
void
IgnorePaintSuppression
(
)
{
mIgnoreSuppression
=
true
;
}
bool
IsIgnoringPaintSuppression
(
)
{
return
mIgnoreSuppression
;
}
void
SetPaintingToWindow
(
bool
aToWindow
)
{
mIsPaintingToWindow
=
aToWindow
;
}
bool
IsPaintingToWindow
(
)
const
{
return
mIsPaintingToWindow
;
}
void
SetDescendIntoSubdocuments
(
bool
aDescend
)
{
mDescendIntoSubdocuments
=
aDescend
;
}
bool
GetDescendIntoSubdocuments
(
)
{
return
mDescendIntoSubdocuments
;
}
const
nsRect
&
GetDirtyRect
(
)
{
return
mDirtyRect
;
}
void
SetDirtyRect
(
const
nsRect
&
aDirtyRect
)
{
mDirtyRect
=
aDirtyRect
;
}
void
IntersectDirtyRect
(
const
nsRect
&
aDirtyRect
)
{
mDirtyRect
.
IntersectRect
(
mDirtyRect
aDirtyRect
)
;
}
const
nsIFrame
*
GetCurrentFrame
(
)
{
return
mCurrentFrame
;
}
const
nsIFrame
*
GetCurrentReferenceFrame
(
)
{
return
mCurrentReferenceFrame
;
}
const
nsPoint
&
GetCurrentFrameOffsetToReferenceFrame
(
)
{
return
mCurrentOffsetToReferenceFrame
;
}
AnimatedGeometryRoot
*
GetCurrentAnimatedGeometryRoot
(
)
{
return
mCurrentAGR
;
}
AnimatedGeometryRoot
*
GetRootAnimatedGeometryRoot
(
)
{
return
&
mRootAGR
;
}
void
RecomputeCurrentAnimatedGeometryRoot
(
)
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
bool
DebugContains
(
void
*
aPtr
)
{
return
mPool
.
DebugContains
(
aPtr
)
;
}
#
endif
bool
AllowMergingAndFlattening
(
)
{
return
mAllowMergingAndFlattening
;
}
void
SetAllowMergingAndFlattening
(
bool
aAllow
)
{
mAllowMergingAndFlattening
=
aAllow
;
}
nsDisplayLayerEventRegions
*
GetLayerEventRegions
(
)
{
return
mLayerEventRegions
;
}
void
SetLayerEventRegions
(
nsDisplayLayerEventRegions
*
aItem
)
{
mLayerEventRegions
=
aItem
;
}
bool
IsBuildingLayerEventRegions
(
)
;
static
bool
LayerEventRegionsEnabled
(
)
;
bool
IsInsidePointerEventsNoneDoc
(
)
{
return
CurrentPresShellState
(
)
-
>
mInsidePointerEventsNoneDoc
;
}
bool
GetAncestorHasApzAwareEventHandler
(
)
{
return
mAncestorHasApzAwareEventHandler
;
}
void
SetAncestorHasApzAwareEventHandler
(
bool
aValue
)
{
mAncestorHasApzAwareEventHandler
=
aValue
;
}
bool
HaveScrollableDisplayPort
(
)
const
{
return
mHaveScrollableDisplayPort
;
}
void
SetHaveScrollableDisplayPort
(
)
{
mHaveScrollableDisplayPort
=
true
;
}
void
ClearHaveScrollableDisplayPort
(
)
{
mHaveScrollableDisplayPort
=
false
;
}
bool
SetIsCompositingCheap
(
bool
aCompositingCheap
)
{
bool
temp
=
mIsCompositingCheap
;
mIsCompositingCheap
=
aCompositingCheap
;
return
temp
;
}
bool
IsCompositingCheap
(
)
const
{
return
mIsCompositingCheap
;
}
void
DisplayCaret
(
nsIFrame
*
aFrame
nsDisplayList
*
aList
)
{
nsIFrame
*
frame
=
GetCaretFrame
(
)
;
if
(
aFrame
=
=
frame
)
{
frame
-
>
DisplayCaret
(
this
aList
)
;
}
}
nsIFrame
*
GetCaretFrame
(
)
{
return
CurrentPresShellState
(
)
-
>
mCaretFrame
;
}
const
nsRect
&
GetCaretRect
(
)
{
return
CurrentPresShellState
(
)
-
>
mCaretRect
;
}
nsCaret
*
GetCaret
(
)
;
void
EnterPresShell
(
nsIFrame
*
aReferenceFrame
bool
aPointerEventsNoneDoc
=
false
)
;
void
ResetMarkedFramesForDisplayList
(
)
;
void
LeavePresShell
(
nsIFrame
*
aReferenceFrame
nsDisplayList
*
aPaintedContents
)
;
bool
IsInTransform
(
)
const
{
return
mInTransform
;
}
void
SetInTransform
(
bool
aInTransform
)
{
mInTransform
=
aInTransform
;
}
bool
IsInSubdocument
(
)
{
return
mPresShellStates
.
Length
(
)
>
1
;
}
bool
IsInChromeDocumentOrPopup
(
)
{
return
mIsInChromePresContext
|
|
mIsBuildingForPopup
;
}
bool
ShouldSyncDecodeImages
(
)
{
return
mSyncDecodeImages
;
}
void
SetSyncDecodeImages
(
bool
aSyncDecodeImages
)
{
mSyncDecodeImages
=
aSyncDecodeImages
;
}
uint32_t
GetBackgroundPaintFlags
(
)
;
void
SubtractFromVisibleRegion
(
nsRegion
*
aVisibleRegion
const
nsRegion
&
aRegion
)
;
void
MarkFramesForDisplayList
(
nsIFrame
*
aDirtyFrame
const
nsFrameList
&
aFrames
)
;
void
MarkPreserve3DFramesForDisplayList
(
nsIFrame
*
aDirtyFrame
)
;
const
nsTArray
<
ThemeGeometry
>
&
GetThemeGeometries
(
)
{
return
mThemeGeometries
;
}
bool
ShouldDescendIntoFrame
(
nsIFrame
*
aFrame
)
const
{
return
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO
)
|
|
GetIncludeAllOutOfFlows
(
)
;
}
void
RegisterThemeGeometry
(
uint8_t
aWidgetType
const
mozilla
:
:
LayoutDeviceIntRect
&
aRect
)
{
if
(
mIsPaintingToWindow
)
{
mThemeGeometries
.
AppendElement
(
ThemeGeometry
(
aWidgetType
aRect
)
)
;
}
}
void
AdjustWindowDraggingRegion
(
nsIFrame
*
aFrame
)
;
LayoutDeviceIntRegion
GetWindowDraggingRegion
(
)
const
;
void
*
Allocate
(
size_t
aSize
DisplayItemType
aType
)
;
void
Destroy
(
DisplayItemType
aType
void
*
aPtr
)
;
ActiveScrolledRoot
*
AllocateActiveScrolledRoot
(
const
ActiveScrolledRoot
*
aParent
nsIScrollableFrame
*
aScrollableFrame
)
;
const
DisplayItemClipChain
*
AllocateDisplayItemClipChain
(
const
DisplayItemClip
&
aClip
const
ActiveScrolledRoot
*
aASR
const
DisplayItemClipChain
*
aParent
)
;
const
DisplayItemClipChain
*
CreateClipChainIntersection
(
const
DisplayItemClipChain
*
aAncestor
const
DisplayItemClipChain
*
aLeafClip1
const
DisplayItemClipChain
*
aLeafClip2
)
;
const
DisplayItemClipChain
*
CopyWholeChain
(
const
DisplayItemClipChain
*
aClipChain
)
;
void
SetActiveScrolledRootForRootScrollframe
(
const
ActiveScrolledRoot
*
aASR
)
{
mActiveScrolledRootForRootScrollframe
=
aASR
;
}
const
ActiveScrolledRoot
*
ActiveScrolledRootForRootScrollframe
(
)
const
{
return
mActiveScrolledRootForRootScrollframe
;
}
static
void
AddAnimationsAndTransitionsToLayer
(
Layer
*
aLayer
nsDisplayListBuilder
*
aBuilder
nsDisplayItem
*
aItem
nsIFrame
*
aFrame
nsCSSPropertyID
aProperty
)
;
nsDisplayItem
*
MergeItems
(
nsTArray
<
nsDisplayItem
*
>
&
aMergedItems
)
;
class
AutoBuildingDisplayList
;
friend
class
AutoBuildingDisplayList
;
class
AutoBuildingDisplayList
{
public
:
AutoBuildingDisplayList
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aForChild
const
nsRect
&
aDirtyRect
bool
aIsRoot
)
:
mBuilder
(
aBuilder
)
mPrevFrame
(
aBuilder
-
>
mCurrentFrame
)
mPrevReferenceFrame
(
aBuilder
-
>
mCurrentReferenceFrame
)
mPrevLayerEventRegions
(
aBuilder
-
>
mLayerEventRegions
)
mPrevOffset
(
aBuilder
-
>
mCurrentOffsetToReferenceFrame
)
mPrevDirtyRect
(
aBuilder
-
>
mDirtyRect
)
mPrevAGR
(
aBuilder
-
>
mCurrentAGR
)
mPrevIsAtRootOfPseudoStackingContext
(
aBuilder
-
>
mIsAtRootOfPseudoStackingContext
)
mPrevAncestorHasApzAwareEventHandler
(
aBuilder
-
>
mAncestorHasApzAwareEventHandler
)
mPrevBuildingInvisibleItems
(
aBuilder
-
>
mBuildingInvisibleItems
)
{
if
(
aForChild
-
>
IsTransformed
(
)
)
{
aBuilder
-
>
mCurrentOffsetToReferenceFrame
=
nsPoint
(
)
;
aBuilder
-
>
mCurrentReferenceFrame
=
aForChild
;
}
else
if
(
aBuilder
-
>
mCurrentFrame
=
=
aForChild
-
>
GetParent
(
)
)
{
aBuilder
-
>
mCurrentOffsetToReferenceFrame
+
=
aForChild
-
>
GetPosition
(
)
;
}
else
{
aBuilder
-
>
mCurrentReferenceFrame
=
aBuilder
-
>
FindReferenceFrameFor
(
aForChild
&
aBuilder
-
>
mCurrentOffsetToReferenceFrame
)
;
}
mCurrentAGRState
=
aBuilder
-
>
IsAnimatedGeometryRoot
(
aForChild
)
;
if
(
aBuilder
-
>
mCurrentFrame
=
=
aForChild
-
>
GetParent
(
)
)
{
if
(
mCurrentAGRState
=
=
AGR_YES
)
{
aBuilder
-
>
mCurrentAGR
=
aBuilder
-
>
WrapAGRForFrame
(
aForChild
aBuilder
-
>
mCurrentAGR
)
;
}
}
else
if
(
aForChild
!
=
aBuilder
-
>
mCurrentFrame
)
{
aBuilder
-
>
mCurrentAGR
=
aBuilder
-
>
FindAnimatedGeometryRootFor
(
aForChild
)
;
}
MOZ_ASSERT
(
nsLayoutUtils
:
:
IsAncestorFrameCrossDoc
(
aBuilder
-
>
RootReferenceFrame
(
)
*
aBuilder
-
>
mCurrentAGR
)
)
;
aBuilder
-
>
mCurrentFrame
=
aForChild
;
aBuilder
-
>
mDirtyRect
=
aDirtyRect
;
aBuilder
-
>
mIsAtRootOfPseudoStackingContext
=
aIsRoot
;
}
void
SetDirtyRect
(
const
nsRect
&
aRect
)
{
mBuilder
-
>
mDirtyRect
=
aRect
;
}
void
SetReferenceFrameAndCurrentOffset
(
const
nsIFrame
*
aFrame
const
nsPoint
&
aOffset
)
{
mBuilder
-
>
mCurrentReferenceFrame
=
aFrame
;
mBuilder
-
>
mCurrentOffsetToReferenceFrame
=
aOffset
;
}
bool
IsAnimatedGeometryRoot
(
)
const
{
return
mCurrentAGRState
=
=
AGR_YES
;
}
bool
MaybeAnimatedGeometryRoot
(
)
const
{
return
mCurrentAGRState
=
=
AGR_MAYBE
;
}
void
RestoreBuildingInvisibleItemsValue
(
)
{
mBuilder
-
>
mBuildingInvisibleItems
=
mPrevBuildingInvisibleItems
;
}
~
AutoBuildingDisplayList
(
)
{
mBuilder
-
>
mCurrentFrame
=
mPrevFrame
;
mBuilder
-
>
mCurrentReferenceFrame
=
mPrevReferenceFrame
;
mBuilder
-
>
mLayerEventRegions
=
mPrevLayerEventRegions
;
mBuilder
-
>
mCurrentOffsetToReferenceFrame
=
mPrevOffset
;
mBuilder
-
>
mDirtyRect
=
mPrevDirtyRect
;
mBuilder
-
>
mCurrentAGR
=
mPrevAGR
;
mBuilder
-
>
mIsAtRootOfPseudoStackingContext
=
mPrevIsAtRootOfPseudoStackingContext
;
mBuilder
-
>
mAncestorHasApzAwareEventHandler
=
mPrevAncestorHasApzAwareEventHandler
;
mBuilder
-
>
mBuildingInvisibleItems
=
mPrevBuildingInvisibleItems
;
}
private
:
nsDisplayListBuilder
*
mBuilder
;
AGRState
mCurrentAGRState
;
const
nsIFrame
*
mPrevFrame
;
const
nsIFrame
*
mPrevReferenceFrame
;
nsDisplayLayerEventRegions
*
mPrevLayerEventRegions
;
nsPoint
mPrevOffset
;
nsRect
mPrevDirtyRect
;
AnimatedGeometryRoot
*
mPrevAGR
;
bool
mPrevIsAtRootOfPseudoStackingContext
;
bool
mPrevAncestorHasApzAwareEventHandler
;
bool
mPrevBuildingInvisibleItems
;
}
;
class
AutoInTransformSetter
;
friend
class
AutoInTransformSetter
;
class
AutoInTransformSetter
{
public
:
AutoInTransformSetter
(
nsDisplayListBuilder
*
aBuilder
bool
aInTransform
)
:
mBuilder
(
aBuilder
)
mOldValue
(
aBuilder
-
>
mInTransform
)
{
aBuilder
-
>
mInTransform
=
aInTransform
;
}
~
AutoInTransformSetter
(
)
{
mBuilder
-
>
mInTransform
=
mOldValue
;
}
private
:
nsDisplayListBuilder
*
mBuilder
;
bool
mOldValue
;
}
;
class
AutoSaveRestorePerspectiveIndex
;
friend
class
AutoSaveRestorePerspectiveIndex
;
class
AutoSaveRestorePerspectiveIndex
{
public
:
AutoSaveRestorePerspectiveIndex
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
:
mBuilder
(
nullptr
)
{
if
(
aFrame
-
>
ChildrenHavePerspective
(
)
)
{
mBuilder
=
aBuilder
;
mCachedItemIndex
=
aBuilder
-
>
mPerspectiveItemIndex
;
aBuilder
-
>
mPerspectiveItemIndex
=
0
;
}
}
~
AutoSaveRestorePerspectiveIndex
(
)
{
if
(
mBuilder
)
{
mBuilder
-
>
mPerspectiveItemIndex
=
mCachedItemIndex
;
}
}
private
:
nsDisplayListBuilder
*
mBuilder
;
uint32_t
mCachedItemIndex
;
}
;
class
AutoCurrentScrollParentIdSetter
;
friend
class
AutoCurrentScrollParentIdSetter
;
class
AutoCurrentScrollParentIdSetter
{
public
:
AutoCurrentScrollParentIdSetter
(
nsDisplayListBuilder
*
aBuilder
ViewID
aScrollId
)
:
mBuilder
(
aBuilder
)
mOldValue
(
aBuilder
-
>
mCurrentScrollParentId
)
mOldForceLayer
(
aBuilder
-
>
mForceLayerForScrollParent
)
{
mCanBeScrollParent
=
(
mOldValue
!
=
aScrollId
)
;
aBuilder
-
>
mCurrentScrollParentId
=
aScrollId
;
aBuilder
-
>
mForceLayerForScrollParent
=
false
;
}
bool
ShouldForceLayerForScrollParent
(
)
const
{
return
mCanBeScrollParent
&
&
mBuilder
-
>
mForceLayerForScrollParent
;
}
;
~
AutoCurrentScrollParentIdSetter
(
)
{
mBuilder
-
>
mCurrentScrollParentId
=
mOldValue
;
if
(
mCanBeScrollParent
)
{
mBuilder
-
>
mForceLayerForScrollParent
=
mOldForceLayer
;
}
else
{
mBuilder
-
>
mForceLayerForScrollParent
|
=
mOldForceLayer
;
}
}
private
:
nsDisplayListBuilder
*
mBuilder
;
ViewID
mOldValue
;
bool
mOldForceLayer
;
bool
mCanBeScrollParent
;
}
;
class
AutoCurrentActiveScrolledRootSetter
;
friend
class
AutoCurrentActiveScrolledRootSetter
;
class
AutoCurrentActiveScrolledRootSetter
{
public
:
explicit
AutoCurrentActiveScrolledRootSetter
(
nsDisplayListBuilder
*
aBuilder
)
:
mBuilder
(
aBuilder
)
mSavedActiveScrolledRoot
(
aBuilder
-
>
mCurrentActiveScrolledRoot
)
mContentClipASR
(
aBuilder
-
>
ClipState
(
)
.
GetContentClipASR
(
)
)
mDescendantsStartIndex
(
aBuilder
-
>
mActiveScrolledRoots
.
Length
(
)
)
mUsed
(
false
)
{
}
~
AutoCurrentActiveScrolledRootSetter
(
)
{
mBuilder
-
>
mCurrentActiveScrolledRoot
=
mSavedActiveScrolledRoot
;
}
void
SetCurrentActiveScrolledRoot
(
const
ActiveScrolledRoot
*
aActiveScrolledRoot
)
{
MOZ_ASSERT
(
!
mUsed
)
;
mBuilder
-
>
mCurrentActiveScrolledRoot
=
aActiveScrolledRoot
;
const
ActiveScrolledRoot
*
finiteBoundsASR
=
ActiveScrolledRoot
:
:
PickDescendant
(
mContentClipASR
aActiveScrolledRoot
)
;
mBuilder
-
>
mCurrentContainerASR
=
ActiveScrolledRoot
:
:
PickAncestor
(
mBuilder
-
>
mCurrentContainerASR
finiteBoundsASR
)
;
mUsed
=
true
;
}
void
EnterScrollFrame
(
nsIScrollableFrame
*
aScrollableFrame
)
{
MOZ_ASSERT
(
!
mUsed
)
;
ActiveScrolledRoot
*
asr
=
mBuilder
-
>
AllocateActiveScrolledRoot
(
mBuilder
-
>
mCurrentActiveScrolledRoot
aScrollableFrame
)
;
mBuilder
-
>
mCurrentActiveScrolledRoot
=
asr
;
mUsed
=
true
;
}
void
InsertScrollFrame
(
nsIScrollableFrame
*
aScrollableFrame
)
;
private
:
nsDisplayListBuilder
*
mBuilder
;
const
ActiveScrolledRoot
*
mSavedActiveScrolledRoot
;
const
ActiveScrolledRoot
*
mContentClipASR
;
size_t
mDescendantsStartIndex
;
bool
mUsed
;
}
;
class
AutoContainerASRTracker
;
friend
class
AutoContainerASRTracker
;
class
AutoContainerASRTracker
{
public
:
explicit
AutoContainerASRTracker
(
nsDisplayListBuilder
*
aBuilder
)
:
mBuilder
(
aBuilder
)
mSavedContainerASR
(
aBuilder
-
>
mCurrentContainerASR
)
{
mBuilder
-
>
mCurrentContainerASR
=
ActiveScrolledRoot
:
:
PickDescendant
(
mBuilder
-
>
ClipState
(
)
.
GetContentClipASR
(
)
mBuilder
-
>
mCurrentActiveScrolledRoot
)
;
}
const
ActiveScrolledRoot
*
GetContainerASR
(
)
{
return
mBuilder
-
>
mCurrentContainerASR
;
}
~
AutoContainerASRTracker
(
)
{
mBuilder
-
>
mCurrentContainerASR
=
ActiveScrolledRoot
:
:
PickAncestor
(
mBuilder
-
>
mCurrentContainerASR
mSavedContainerASR
)
;
}
private
:
nsDisplayListBuilder
*
mBuilder
;
const
ActiveScrolledRoot
*
mSavedContainerASR
;
}
;
class
AutoCurrentScrollbarInfoSetter
;
friend
class
AutoCurrentScrollbarInfoSetter
;
class
AutoCurrentScrollbarInfoSetter
{
public
:
AutoCurrentScrollbarInfoSetter
(
nsDisplayListBuilder
*
aBuilder
ViewID
aScrollTargetID
uint32_t
aScrollbarFlags
bool
aWillHaveLayer
)
:
mBuilder
(
aBuilder
)
{
aBuilder
-
>
mIsBuildingScrollbar
=
true
;
aBuilder
-
>
mCurrentScrollbarTarget
=
aScrollTargetID
;
aBuilder
-
>
mCurrentScrollbarFlags
=
aScrollbarFlags
;
aBuilder
-
>
mCurrentScrollbarWillHaveLayer
=
aWillHaveLayer
;
}
~
AutoCurrentScrollbarInfoSetter
(
)
{
mBuilder
-
>
mIsBuildingScrollbar
=
false
;
mBuilder
-
>
mCurrentScrollbarTarget
=
FrameMetrics
:
:
NULL_SCROLL_ID
;
mBuilder
-
>
mCurrentScrollbarFlags
=
0
;
mBuilder
-
>
mCurrentScrollbarWillHaveLayer
=
false
;
}
private
:
nsDisplayListBuilder
*
mBuilder
;
}
;
class
AutoAccumulateTransform
;
friend
class
AutoAccumulateTransform
;
class
AutoAccumulateTransform
{
public
:
typedef
mozilla
:
:
gfx
:
:
Matrix4x4
Matrix4x4
;
explicit
AutoAccumulateTransform
(
nsDisplayListBuilder
*
aBuilder
)
:
mBuilder
(
aBuilder
)
mSavedTransform
(
aBuilder
-
>
mPreserves3DCtx
.
mAccumulatedTransform
)
{
}
~
AutoAccumulateTransform
(
)
{
mBuilder
-
>
mPreserves3DCtx
.
mAccumulatedTransform
=
mSavedTransform
;
}
void
Accumulate
(
const
Matrix4x4
&
aTransform
)
{
mBuilder
-
>
mPreserves3DCtx
.
mAccumulatedTransform
=
aTransform
*
mBuilder
-
>
mPreserves3DCtx
.
mAccumulatedTransform
;
}
const
Matrix4x4
&
GetCurrentTransform
(
)
{
return
mBuilder
-
>
mPreserves3DCtx
.
mAccumulatedTransform
;
}
void
StartRoot
(
)
{
mBuilder
-
>
mPreserves3DCtx
.
mAccumulatedTransform
=
Matrix4x4
(
)
;
}
private
:
nsDisplayListBuilder
*
mBuilder
;
Matrix4x4
mSavedTransform
;
}
;
class
AutoAccumulateRect
;
friend
class
AutoAccumulateRect
;
class
AutoAccumulateRect
{
public
:
explicit
AutoAccumulateRect
(
nsDisplayListBuilder
*
aBuilder
)
:
mBuilder
(
aBuilder
)
mSavedRect
(
aBuilder
-
>
mPreserves3DCtx
.
mAccumulatedRect
)
{
aBuilder
-
>
mPreserves3DCtx
.
mAccumulatedRect
=
nsRect
(
)
;
aBuilder
-
>
mPreserves3DCtx
.
mAccumulatedRectLevels
+
+
;
}
~
AutoAccumulateRect
(
)
{
mBuilder
-
>
mPreserves3DCtx
.
mAccumulatedRect
=
mSavedRect
;
mBuilder
-
>
mPreserves3DCtx
.
mAccumulatedRectLevels
-
-
;
}
private
:
nsDisplayListBuilder
*
mBuilder
;
nsRect
mSavedRect
;
}
;
void
AccumulateRect
(
const
nsRect
&
aRect
)
{
mPreserves3DCtx
.
mAccumulatedRect
.
UnionRect
(
mPreserves3DCtx
.
mAccumulatedRect
aRect
)
;
}
const
nsRect
&
GetAccumulatedRect
(
)
{
return
mPreserves3DCtx
.
mAccumulatedRect
;
}
int
GetAccumulatedRectLevels
(
)
{
return
mPreserves3DCtx
.
mAccumulatedRectLevels
;
}
nsDisplayTableItem
*
GetCurrentTableItem
(
)
{
return
mCurrentTableItem
;
}
void
SetCurrentTableItem
(
nsDisplayTableItem
*
aTableItem
)
{
mCurrentTableItem
=
aTableItem
;
}
struct
OutOfFlowDisplayData
{
OutOfFlowDisplayData
(
const
DisplayItemClipChain
*
aContainingBlockClipChain
const
DisplayItemClipChain
*
aCombinedClipChain
const
ActiveScrolledRoot
*
aContainingBlockActiveScrolledRoot
const
nsRect
&
aDirtyRect
)
:
mContainingBlockClipChain
(
aContainingBlockClipChain
)
mCombinedClipChain
(
aCombinedClipChain
)
mContainingBlockActiveScrolledRoot
(
aContainingBlockActiveScrolledRoot
)
mDirtyRect
(
aDirtyRect
)
{
}
const
DisplayItemClipChain
*
mContainingBlockClipChain
;
const
DisplayItemClipChain
*
mCombinedClipChain
;
const
ActiveScrolledRoot
*
mContainingBlockActiveScrolledRoot
;
nsRect
mDirtyRect
;
}
;
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
OutOfFlowDisplayDataProperty
OutOfFlowDisplayData
)
static
OutOfFlowDisplayData
*
GetOutOfFlowData
(
nsIFrame
*
aFrame
)
{
return
aFrame
-
>
GetProperty
(
OutOfFlowDisplayDataProperty
(
)
)
;
}
nsPresContext
*
CurrentPresContext
(
)
{
return
CurrentPresShellState
(
)
-
>
mPresShell
-
>
GetPresContext
(
)
;
}
OutOfFlowDisplayData
*
GetCurrentFixedBackgroundDisplayData
(
)
{
auto
&
displayData
=
CurrentPresShellState
(
)
-
>
mFixedBackgroundDisplayData
;
return
displayData
?
displayData
.
ptr
(
)
:
nullptr
;
}
void
AddWindowExcludeGlassRegion
(
const
nsRegion
&
bounds
)
{
mWindowExcludeGlassRegion
.
Or
(
mWindowExcludeGlassRegion
bounds
)
;
}
const
nsRegion
&
GetWindowExcludeGlassRegion
(
)
{
return
mWindowExcludeGlassRegion
;
}
void
AddWindowOpaqueRegion
(
const
nsRegion
&
bounds
)
{
mWindowOpaqueRegion
.
Or
(
mWindowOpaqueRegion
bounds
)
;
}
const
nsRegion
&
GetWindowOpaqueRegion
(
)
{
return
mWindowOpaqueRegion
;
}
void
SetGlassDisplayItem
(
nsDisplayItem
*
aItem
)
{
if
(
mGlassDisplayItem
)
{
NS_WARNING
(
"
Multiple
glass
backgrounds
found
?
"
)
;
}
else
{
mGlassDisplayItem
=
aItem
;
}
}
bool
NeedToForceTransparentSurfaceForItem
(
nsDisplayItem
*
aItem
)
;
void
SetContainsPluginItem
(
)
{
mContainsPluginItem
=
true
;
}
bool
ContainsPluginItem
(
)
{
return
mContainsPluginItem
;
}
void
SetContainsBlendMode
(
bool
aContainsBlendMode
)
{
mContainsBlendMode
=
aContainsBlendMode
;
}
bool
ContainsBlendMode
(
)
const
{
return
mContainsBlendMode
;
}
uint32_t
AllocatePerspectiveItemIndex
(
)
{
return
mPerspectiveItemIndex
+
+
;
}
DisplayListClipState
&
ClipState
(
)
{
return
mClipState
;
}
const
ActiveScrolledRoot
*
CurrentActiveScrolledRoot
(
)
{
return
mCurrentActiveScrolledRoot
;
}
const
ActiveScrolledRoot
*
CurrentAncestorASRStackingContextContents
(
)
{
return
mCurrentContainerASR
;
}
bool
AddToWillChangeBudget
(
nsIFrame
*
aFrame
const
nsSize
&
aSize
)
;
bool
IsInWillChangeBudget
(
nsIFrame
*
aFrame
const
nsSize
&
aSize
)
;
void
EnterSVGEffectsContents
(
nsDisplayList
*
aHoistedItemsStorage
)
;
void
ExitSVGEffectsContents
(
)
;
bool
ShouldBuildScrollInfoItemsForHoisting
(
)
const
{
return
mSVGEffectsBuildingDepth
>
0
;
}
void
AppendNewScrollInfoItemForHoisting
(
nsDisplayScrollInfoLayer
*
aScrollInfoItem
)
;
class
AutoPreserves3DContext
;
friend
class
AutoPreserves3DContext
;
class
AutoPreserves3DContext
{
public
:
explicit
AutoPreserves3DContext
(
nsDisplayListBuilder
*
aBuilder
)
:
mBuilder
(
aBuilder
)
mSavedCtx
(
aBuilder
-
>
mPreserves3DCtx
)
{
}
~
AutoPreserves3DContext
(
)
{
mBuilder
-
>
mPreserves3DCtx
=
mSavedCtx
;
}
private
:
nsDisplayListBuilder
*
mBuilder
;
Preserves3DContext
mSavedCtx
;
}
;
const
nsRect
GetPreserves3DRects
(
)
const
{
return
mPreserves3DCtx
.
mDirtyRect
;
}
void
SavePreserves3DRects
(
)
{
mPreserves3DCtx
.
mDirtyRect
=
mDirtyRect
;
}
bool
IsBuildingInvisibleItems
(
)
const
{
return
mBuildingInvisibleItems
;
}
void
SetBuildingInvisibleItems
(
bool
aBuildingInvisibleItems
)
{
mBuildingInvisibleItems
=
aBuildingInvisibleItems
;
}
AnimatedGeometryRoot
*
AnimatedGeometryRootForASR
(
const
ActiveScrolledRoot
*
aASR
)
;
bool
HitTestShouldStopAtFirstOpaque
(
)
const
{
return
mHitTestShouldStopAtFirstOpaque
;
}
void
SetHitTestShouldStopAtFirstOpaque
(
bool
aHitTestShouldStopAtFirstOpaque
)
{
mHitTestShouldStopAtFirstOpaque
=
aHitTestShouldStopAtFirstOpaque
;
}
private
:
void
MarkOutOfFlowFrameForDisplay
(
nsIFrame
*
aDirtyFrame
nsIFrame
*
aFrame
)
;
AGRState
IsAnimatedGeometryRoot
(
nsIFrame
*
aFrame
nsIFrame
*
*
aParent
=
nullptr
)
;
nsIFrame
*
FindAnimatedGeometryRootFrameFor
(
nsIFrame
*
aFrame
)
;
friend
class
nsDisplayCanvasBackgroundImage
;
friend
class
nsDisplayBackgroundImage
;
friend
class
nsDisplayFixedPosition
;
AnimatedGeometryRoot
*
FindAnimatedGeometryRootFor
(
nsDisplayItem
*
aItem
)
;
friend
class
nsDisplayItem
;
friend
class
nsDisplayOwnLayer
;
AnimatedGeometryRoot
*
FindAnimatedGeometryRootFor
(
nsIFrame
*
aFrame
)
;
AnimatedGeometryRoot
*
WrapAGRForFrame
(
nsIFrame
*
aAnimatedGeometryRoot
AnimatedGeometryRoot
*
aParent
=
nullptr
)
;
nsDataHashtable
<
nsPtrHashKey
<
nsIFrame
>
AnimatedGeometryRoot
*
>
mFrameToAnimatedGeometryRootMap
;
bool
AddToAGRBudget
(
nsIFrame
*
aFrame
)
;
struct
PresShellState
{
nsIPresShell
*
mPresShell
;
#
ifdef
DEBUG
mozilla
:
:
Maybe
<
nsAutoLayoutPhase
>
mAutoLayoutPhase
;
#
endif
nsIFrame
*
mCaretFrame
;
nsRect
mCaretRect
;
mozilla
:
:
Maybe
<
OutOfFlowDisplayData
>
mFixedBackgroundDisplayData
;
uint32_t
mFirstFrameMarkedForDisplay
;
bool
mIsBackgroundOnly
;
bool
mInsidePointerEventsNoneDoc
;
}
;
PresShellState
*
CurrentPresShellState
(
)
{
NS_ASSERTION
(
mPresShellStates
.
Length
(
)
>
0
"
Someone
forgot
to
enter
a
presshell
"
)
;
return
&
mPresShellStates
[
mPresShellStates
.
Length
(
)
-
1
]
;
}
struct
DocumentWillChangeBudget
{
DocumentWillChangeBudget
(
)
:
mBudget
(
0
)
{
}
uint32_t
mBudget
;
}
;
nsIFrame
*
const
mReferenceFrame
;
nsIFrame
*
mIgnoreScrollFrame
;
nsDisplayLayerEventRegions
*
mLayerEventRegions
;
static
const
size_t
kArenaAlignment
=
mozilla
:
:
tl
:
:
Max
<
NS_ALIGNMENT_OF
(
void
*
)
NS_ALIGNMENT_OF
(
double
)
>
:
:
value
;
mozilla
:
:
ArenaAllocator
<
4096
kArenaAlignment
>
mPool
;
nsCOMPtr
<
nsISelection
>
mBoundingSelection
;
AutoTArray
<
PresShellState
8
>
mPresShellStates
;
AutoTArray
<
nsIFrame
*
400
>
mFramesMarkedForDisplay
;
AutoTArray
<
ThemeGeometry
2
>
mThemeGeometries
;
nsDisplayTableItem
*
mCurrentTableItem
;
DisplayListClipState
mClipState
;
const
ActiveScrolledRoot
*
mCurrentActiveScrolledRoot
;
const
ActiveScrolledRoot
*
mCurrentContainerASR
;
const
nsIFrame
*
mCurrentFrame
;
const
nsIFrame
*
mCurrentReferenceFrame
;
nsPoint
mCurrentOffsetToReferenceFrame
;
AnimatedGeometryRoot
*
mCurrentAGR
;
AnimatedGeometryRoot
mRootAGR
;
nsDataHashtable
<
nsPtrHashKey
<
nsPresContext
>
DocumentWillChangeBudget
>
mWillChangeBudget
;
nsTHashtable
<
nsPtrHashKey
<
nsIFrame
>
>
mWillChangeBudgetSet
;
uint32_t
mUsedAGRBudget
;
nsTHashtable
<
nsPtrHashKey
<
nsIFrame
>
>
mAGRBudgetSet
;
nsRect
mDirtyRect
;
nsRegion
mWindowExcludeGlassRegion
;
nsRegion
mWindowOpaqueRegion
;
LayoutDeviceIntRegion
mWindowDraggingRegion
;
LayoutDeviceIntRegion
mWindowNoDraggingRegion
;
nsDisplayItem
*
mGlassDisplayItem
;
nsDisplayList
*
mScrollInfoItemsForHoisting
;
nsTArray
<
ActiveScrolledRoot
*
>
mActiveScrolledRoots
;
AutoTArray
<
DisplayItemClipChain
*
128
>
mClipChainsToDestroy
;
nsTArray
<
nsDisplayItem
*
>
mTemporaryItems
;
const
ActiveScrolledRoot
*
mActiveScrolledRootForRootScrollframe
;
nsDisplayListBuilderMode
mMode
;
ViewID
mCurrentScrollParentId
;
ViewID
mCurrentScrollbarTarget
;
uint32_t
mCurrentScrollbarFlags
;
Preserves3DContext
mPreserves3DCtx
;
uint32_t
mPerspectiveItemIndex
;
int32_t
mSVGEffectsBuildingDepth
;
bool
mContainsBlendMode
;
bool
mIsBuildingScrollbar
;
bool
mCurrentScrollbarWillHaveLayer
;
bool
mBuildCaret
;
bool
mIgnoreSuppression
;
bool
mIsAtRootOfPseudoStackingContext
;
bool
mIncludeAllOutOfFlows
;
bool
mDescendIntoSubdocuments
;
bool
mSelectedFramesOnly
;
bool
mAllowMergingAndFlattening
;
bool
mWillComputePluginGeometry
;
bool
mInTransform
;
bool
mIsInChromePresContext
;
bool
mSyncDecodeImages
;
bool
mIsPaintingToWindow
;
bool
mIsCompositingCheap
;
bool
mContainsPluginItem
;
bool
mAncestorHasApzAwareEventHandler
;
bool
mHaveScrollableDisplayPort
;
bool
mWindowDraggingAllowed
;
bool
mIsBuildingForPopup
;
bool
mForceLayerForScrollParent
;
bool
mAsyncPanZoomEnabled
;
bool
mBuildingInvisibleItems
;
bool
mHitTestShouldStopAtFirstOpaque
;
}
;
class
nsDisplayItem
;
class
nsDisplayList
;
class
nsDisplayItemLink
{
protected
:
nsDisplayItemLink
(
)
:
mAbove
(
nullptr
)
{
}
nsDisplayItemLink
(
const
nsDisplayItemLink
&
)
:
mAbove
(
nullptr
)
{
}
nsDisplayItem
*
mAbove
;
friend
class
nsDisplayList
;
}
;
class
nsDisplayWrapList
;
class
nsDisplayItem
:
public
nsDisplayItemLink
{
public
:
typedef
mozilla
:
:
ContainerLayerParameters
ContainerLayerParameters
;
typedef
mozilla
:
:
DisplayItemClip
DisplayItemClip
;
typedef
mozilla
:
:
DisplayItemClipChain
DisplayItemClipChain
;
typedef
mozilla
:
:
ActiveScrolledRoot
ActiveScrolledRoot
;
typedef
mozilla
:
:
layers
:
:
FrameMetrics
FrameMetrics
;
typedef
mozilla
:
:
layers
:
:
ScrollMetadata
ScrollMetadata
;
typedef
mozilla
:
:
layers
:
:
FrameMetrics
:
:
ViewID
ViewID
;
typedef
mozilla
:
:
layers
:
:
Layer
Layer
;
typedef
mozilla
:
:
layers
:
:
LayerManager
LayerManager
;
typedef
mozilla
:
:
layers
:
:
StackingContextHelper
StackingContextHelper
;
typedef
mozilla
:
:
layers
:
:
WebRenderCommand
WebRenderCommand
;
typedef
mozilla
:
:
layers
:
:
WebRenderParentCommand
WebRenderParentCommand
;
typedef
mozilla
:
:
LayerState
LayerState
;
typedef
mozilla
:
:
image
:
:
imgDrawingParams
imgDrawingParams
;
typedef
mozilla
:
:
image
:
:
DrawResult
DrawResult
;
typedef
class
mozilla
:
:
gfx
:
:
DrawTarget
DrawTarget
;
nsDisplayItem
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
;
nsDisplayItem
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
ActiveScrolledRoot
*
aActiveScrolledRoot
)
;
explicit
nsDisplayItem
(
nsIFrame
*
aFrame
)
:
mFrame
(
aFrame
)
mClipChain
(
nullptr
)
mClip
(
nullptr
)
mActiveScrolledRoot
(
nullptr
)
mReferenceFrame
(
nullptr
)
mAnimatedGeometryRoot
(
nullptr
)
mForceNotVisible
(
false
)
mDisableSubpixelAA
(
false
)
#
ifdef
MOZ_DUMP_PAINTING
mPainted
(
false
)
#
endif
{
}
protected
:
virtual
~
nsDisplayItem
(
)
{
}
public
:
virtual
void
Destroy
(
nsDisplayListBuilder
*
aBuilder
)
{
DisplayItemType
type
=
GetType
(
)
;
this
-
>
~
nsDisplayItem
(
)
;
aBuilder
-
>
Destroy
(
type
this
)
;
}
virtual
const
nsDisplayWrapList
*
AsDisplayWrapList
(
)
const
{
return
nullptr
;
}
virtual
nsDisplayItem
*
Clone
(
nsDisplayListBuilder
*
aBuilder
)
const
{
return
nullptr
;
}
nsDisplayItem
(
const
nsDisplayItem
&
aOther
)
:
mFrame
(
aOther
.
mFrame
)
mClipChain
(
aOther
.
mClipChain
)
mClip
(
aOther
.
mClip
)
mActiveScrolledRoot
(
aOther
.
mActiveScrolledRoot
)
mReferenceFrame
(
aOther
.
mReferenceFrame
)
mAnimatedGeometryRoot
(
aOther
.
mAnimatedGeometryRoot
)
mToReferenceFrame
(
aOther
.
mToReferenceFrame
)
mVisibleRect
(
aOther
.
mVisibleRect
)
mForceNotVisible
(
aOther
.
mForceNotVisible
)
mDisableSubpixelAA
(
aOther
.
mDisableSubpixelAA
)
#
ifdef
MOZ_DUMP_PAINTING
mPainted
(
false
)
#
endif
{
}
struct
HitTestState
{
explicit
HitTestState
(
)
:
mInPreserves3D
(
false
)
{
}
~
HitTestState
(
)
{
NS_ASSERTION
(
mItemBuffer
.
Length
(
)
=
=
0
"
mItemBuffer
should
have
been
cleared
"
)
;
}
bool
mInPreserves3D
;
AutoTArray
<
nsDisplayItem
*
100
>
mItemBuffer
;
}
;
virtual
DisplayItemType
GetType
(
)
const
=
0
;
virtual
uint32_t
GetPerFrameKey
(
)
const
{
return
uint32_t
(
GetType
(
)
)
;
}
virtual
void
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
{
}
inline
nsIFrame
*
Frame
(
)
const
{
return
mFrame
;
}
virtual
int32_t
ZIndex
(
)
const
;
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
{
*
aSnap
=
false
;
return
nsRect
(
ToReferenceFrame
(
)
Frame
(
)
-
>
GetSize
(
)
)
;
}
virtual
nsRegion
GetTightBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
{
*
aSnap
=
false
;
return
nsRegion
(
)
;
}
virtual
bool
IsInvisibleInRect
(
const
nsRect
&
aRect
)
const
{
return
false
;
}
nsRect
GetClippedBounds
(
nsDisplayListBuilder
*
aBuilder
)
const
;
nsRect
GetBorderRect
(
)
const
{
return
nsRect
(
ToReferenceFrame
(
)
Frame
(
)
-
>
GetSize
(
)
)
;
}
nsRect
GetPaddingRect
(
)
const
{
return
Frame
(
)
-
>
GetPaddingRectRelativeToSelf
(
)
+
ToReferenceFrame
(
)
;
}
nsRect
GetContentRect
(
)
const
{
return
Frame
(
)
-
>
GetContentRectRelativeToSelf
(
)
+
ToReferenceFrame
(
)
;
}
virtual
bool
IsInvalid
(
nsRect
&
aRect
)
const
{
bool
result
=
mFrame
?
mFrame
-
>
IsInvalid
(
aRect
)
:
false
;
aRect
+
=
ToReferenceFrame
(
)
;
return
result
;
}
virtual
nsDisplayItemGeometry
*
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
{
return
new
nsDisplayItemGenericGeometry
(
this
aBuilder
)
;
}
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
{
const
nsDisplayItemGenericGeometry
*
geometry
=
static_cast
<
const
nsDisplayItemGenericGeometry
*
>
(
aGeometry
)
;
bool
snap
;
if
(
!
geometry
-
>
mBounds
.
IsEqualInterior
(
GetBounds
(
aBuilder
&
snap
)
)
|
|
!
geometry
-
>
mBorderRect
.
IsEqualInterior
(
GetBorderRect
(
)
)
)
{
aInvalidRegion
-
>
Or
(
GetBounds
(
aBuilder
&
snap
)
geometry
-
>
mBounds
)
;
}
}
void
ComputeInvalidationRegionDifference
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemBoundsGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
{
bool
snap
;
nsRect
bounds
=
GetBounds
(
aBuilder
&
snap
)
;
if
(
!
aGeometry
-
>
mBounds
.
IsEqualInterior
(
bounds
)
)
{
nscoord
radii
[
8
]
;
if
(
aGeometry
-
>
mHasRoundedCorners
|
|
Frame
(
)
-
>
GetBorderRadii
(
radii
)
)
{
aInvalidRegion
-
>
Or
(
aGeometry
-
>
mBounds
bounds
)
;
}
else
{
aInvalidRegion
-
>
Xor
(
aGeometry
-
>
mBounds
bounds
)
;
}
}
}
virtual
void
NotifyRenderingChanged
(
)
const
{
}
virtual
nsRegion
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
{
*
aSnap
=
false
;
return
nsRegion
(
)
;
}
virtual
mozilla
:
:
Maybe
<
nscolor
>
IsUniform
(
nsDisplayListBuilder
*
aBuilder
)
const
{
return
mozilla
:
:
Nothing
(
)
;
}
virtual
bool
ShouldFixToViewport
(
nsDisplayListBuilder
*
aBuilder
)
const
{
return
false
;
}
virtual
bool
ClearsBackground
(
)
const
{
return
false
;
}
static
bool
ForceActiveLayers
(
)
;
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
{
return
mozilla
:
:
LAYER_NONE
;
}
virtual
bool
ShouldBuildLayerEvenIfInvisible
(
nsDisplayListBuilder
*
aBuilder
)
const
{
return
false
;
}
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
}
#
ifdef
MOZ_DUMP_PAINTING
bool
Painted
(
)
const
{
return
mPainted
;
}
void
SetPainted
(
)
{
mPainted
=
true
;
}
#
endif
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
{
return
nullptr
;
}
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
return
false
;
}
virtual
bool
UpdateScrollData
(
mozilla
:
:
layers
:
:
WebRenderScrollData
*
aData
mozilla
:
:
layers
:
:
WebRenderLayerScrollData
*
aLayerData
)
{
return
false
;
}
already_AddRefed
<
Layer
>
BuildDisplayItemLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
;
virtual
bool
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
;
virtual
bool
CanMerge
(
const
nsDisplayItem
*
aItem
)
const
{
return
false
;
}
virtual
void
Merge
(
const
nsDisplayItem
*
aItem
)
{
}
virtual
void
MergeDisplayListFromItem
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItem
*
aItem
)
{
}
virtual
void
GetMergedFrames
(
nsTArray
<
nsIFrame
*
>
*
aFrames
)
const
{
}
virtual
bool
ShouldFlattenAway
(
nsDisplayListBuilder
*
aBuilder
)
{
return
false
;
}
virtual
bool
MustPaintOnContentSide
(
)
const
{
return
false
;
}
virtual
nsDisplayList
*
GetSameCoordinateSystemChildren
(
)
const
{
return
nullptr
;
}
virtual
void
UpdateBounds
(
nsDisplayListBuilder
*
aBuilder
)
{
}
virtual
void
DoUpdateBoundsPreserves3D
(
nsDisplayListBuilder
*
aBuilder
)
{
}
virtual
nsDisplayList
*
GetChildren
(
)
const
{
return
nullptr
;
}
const
nsRect
&
GetVisibleRect
(
)
const
{
return
mVisibleRect
;
}
virtual
const
nsRect
&
GetVisibleRectForChildren
(
)
const
{
return
mVisibleRect
;
}
virtual
void
ApplyOpacity
(
nsDisplayListBuilder
*
aBuilder
float
aOpacity
const
DisplayItemClipChain
*
aClip
)
{
NS_ASSERTION
(
CanApplyOpacity
(
)
"
ApplyOpacity
not
supported
on
this
type
"
)
;
}
virtual
bool
CanApplyOpacity
(
)
const
{
return
false
;
}
bool
ForceNotVisible
(
)
const
{
return
mForceNotVisible
;
}
virtual
const
char
*
Name
(
)
const
=
0
;
virtual
void
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
{
}
nsDisplayItem
*
GetAbove
(
)
{
return
mAbove
;
}
bool
RecomputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
;
const
nsPoint
&
ToReferenceFrame
(
)
const
{
NS_ASSERTION
(
mFrame
"
No
frame
?
"
)
;
return
mToReferenceFrame
;
}
const
nsIFrame
*
ReferenceFrame
(
)
const
{
return
mReferenceFrame
;
}
virtual
const
nsIFrame
*
ReferenceFrameForChildren
(
)
const
{
return
mReferenceFrame
;
}
AnimatedGeometryRoot
*
GetAnimatedGeometryRoot
(
)
const
{
MOZ_ASSERT
(
mAnimatedGeometryRoot
"
Must
have
cached
AGR
before
accessing
it
!
"
)
;
return
mAnimatedGeometryRoot
;
}
virtual
struct
AnimatedGeometryRoot
*
AnimatedGeometryRootForScrollMetadata
(
)
const
{
return
GetAnimatedGeometryRoot
(
)
;
}
virtual
nsRect
GetComponentAlphaBounds
(
nsDisplayListBuilder
*
aBuilder
)
const
{
return
nsRect
(
)
;
}
void
DisableComponentAlpha
(
)
{
mDisableSubpixelAA
=
true
;
}
virtual
bool
CanUseAsyncAnimations
(
nsDisplayListBuilder
*
aBuilder
)
{
return
false
;
}
virtual
bool
SupportsOptimizingToImage
(
)
const
{
return
false
;
}
const
DisplayItemClip
&
GetClip
(
)
const
{
return
mClip
?
*
mClip
:
DisplayItemClip
:
:
NoClip
(
)
;
}
void
IntersectClip
(
nsDisplayListBuilder
*
aBuilder
const
DisplayItemClipChain
*
aOther
)
;
void
SetActiveScrolledRoot
(
const
ActiveScrolledRoot
*
aActiveScrolledRoot
)
{
mActiveScrolledRoot
=
aActiveScrolledRoot
;
}
const
ActiveScrolledRoot
*
GetActiveScrolledRoot
(
)
const
{
return
mActiveScrolledRoot
;
}
virtual
void
SetClipChain
(
const
DisplayItemClipChain
*
aClipChain
)
;
const
DisplayItemClipChain
*
GetClipChain
(
)
const
{
return
mClipChain
;
}
void
FuseClipChainUpTo
(
nsDisplayListBuilder
*
aBuilder
const
ActiveScrolledRoot
*
aASR
)
;
bool
BackfaceIsHidden
(
)
const
{
return
mFrame
-
>
BackfaceIsHidden
(
)
;
}
bool
In3DContextAndBackfaceIsHidden
(
)
const
{
return
Frame
(
)
-
>
In3DContextAndBackfaceIsHidden
(
)
;
}
bool
HasSameTypeAndClip
(
const
nsDisplayItem
*
aOther
)
const
{
return
GetType
(
)
=
=
aOther
-
>
GetType
(
)
&
&
GetClipChain
(
)
=
=
aOther
-
>
GetClipChain
(
)
;
}
bool
HasSameContent
(
const
nsDisplayItem
*
aOther
)
const
{
return
mFrame
-
>
GetContent
(
)
=
=
aOther
-
>
Frame
(
)
-
>
GetContent
(
)
;
}
protected
:
friend
class
nsDisplayList
;
nsDisplayItem
(
)
=
delete
;
typedef
bool
(
*
PrefFunc
)
(
void
)
;
bool
ShouldUseAdvancedLayer
(
LayerManager
*
aManager
PrefFunc
aFunc
)
const
;
bool
CanUseAdvancedLayer
(
LayerManager
*
aManager
)
const
;
nsIFrame
*
mFrame
;
const
DisplayItemClipChain
*
mClipChain
;
const
DisplayItemClip
*
mClip
;
const
ActiveScrolledRoot
*
mActiveScrolledRoot
;
const
nsIFrame
*
mReferenceFrame
;
struct
AnimatedGeometryRoot
*
mAnimatedGeometryRoot
;
nsPoint
mToReferenceFrame
;
nsRect
mVisibleRect
;
bool
mForceNotVisible
;
bool
mDisableSubpixelAA
;
#
ifdef
MOZ_DUMP_PAINTING
bool
mPainted
;
#
endif
}
;
class
nsDisplayList
{
public
:
typedef
mozilla
:
:
ActiveScrolledRoot
ActiveScrolledRoot
;
typedef
mozilla
:
:
layers
:
:
Layer
Layer
;
typedef
mozilla
:
:
layers
:
:
LayerManager
LayerManager
;
typedef
mozilla
:
:
layers
:
:
PaintedLayer
PaintedLayer
;
explicit
nsDisplayList
(
nsDisplayListBuilder
*
aBuilder
)
:
mBuilder
(
aBuilder
)
mIsOpaque
(
false
)
mForceTransparentSurface
(
false
)
{
mTop
=
&
mSentinel
;
mSentinel
.
mAbove
=
nullptr
;
}
~
nsDisplayList
(
)
{
if
(
mSentinel
.
mAbove
)
{
NS_WARNING
(
"
Nonempty
list
left
over
?
"
)
;
}
}
void
AppendToTop
(
nsDisplayItem
*
aItem
)
{
NS_ASSERTION
(
aItem
"
No
item
to
append
!
"
)
;
NS_ASSERTION
(
!
aItem
-
>
mAbove
"
Already
in
a
list
!
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mBuilder
-
>
DebugContains
(
aItem
)
)
;
mTop
-
>
mAbove
=
aItem
;
mTop
=
aItem
;
}
void
AppendNewToTop
(
nsDisplayItem
*
aItem
)
{
if
(
aItem
)
{
AppendToTop
(
aItem
)
;
}
}
void
AppendNewToBottom
(
nsDisplayItem
*
aItem
)
{
if
(
aItem
)
{
AppendToBottom
(
aItem
)
;
}
}
void
AppendToBottom
(
nsDisplayItem
*
aItem
)
{
NS_ASSERTION
(
aItem
"
No
item
to
append
!
"
)
;
NS_ASSERTION
(
!
aItem
-
>
mAbove
"
Already
in
a
list
!
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mBuilder
-
>
DebugContains
(
aItem
)
)
;
aItem
-
>
mAbove
=
mSentinel
.
mAbove
;
mSentinel
.
mAbove
=
aItem
;
if
(
mTop
=
=
&
mSentinel
)
{
mTop
=
aItem
;
}
}
void
AppendToTop
(
nsDisplayList
*
aList
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mBuilder
=
=
aList
-
>
mBuilder
)
;
if
(
aList
-
>
mSentinel
.
mAbove
)
{
mTop
-
>
mAbove
=
aList
-
>
mSentinel
.
mAbove
;
mTop
=
aList
-
>
mTop
;
aList
-
>
mTop
=
&
aList
-
>
mSentinel
;
aList
-
>
mSentinel
.
mAbove
=
nullptr
;
}
}
void
AppendToBottom
(
nsDisplayList
*
aList
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mBuilder
=
=
aList
-
>
mBuilder
)
;
if
(
aList
-
>
mSentinel
.
mAbove
)
{
aList
-
>
mTop
-
>
mAbove
=
mSentinel
.
mAbove
;
mSentinel
.
mAbove
=
aList
-
>
mSentinel
.
mAbove
;
if
(
mTop
=
=
&
mSentinel
)
{
mTop
=
aList
-
>
mTop
;
}
aList
-
>
mTop
=
&
aList
-
>
mSentinel
;
aList
-
>
mSentinel
.
mAbove
=
nullptr
;
}
}
nsDisplayItem
*
RemoveBottom
(
)
;
void
DeleteAll
(
nsDisplayListBuilder
*
aBuilder
)
;
nsDisplayItem
*
GetTop
(
)
const
{
return
mTop
!
=
&
mSentinel
?
static_cast
<
nsDisplayItem
*
>
(
mTop
)
:
nullptr
;
}
nsDisplayItem
*
GetBottom
(
)
const
{
return
mSentinel
.
mAbove
;
}
bool
IsEmpty
(
)
const
{
return
mTop
=
=
&
mSentinel
;
}
uint32_t
Count
(
)
const
;
void
SortByZOrder
(
)
;
void
SortByContentOrder
(
nsIContent
*
aCommonAncestor
)
;
template
<
typename
Item
typename
Comparator
>
void
Sort
(
const
Comparator
&
aComparator
)
{
AutoTArray
<
Item
20
>
items
;
while
(
nsDisplayItem
*
item
=
RemoveBottom
(
)
)
{
items
.
AppendElement
(
Item
(
item
)
)
;
}
std
:
:
stable_sort
(
items
.
begin
(
)
items
.
end
(
)
aComparator
)
;
for
(
Item
&
item
:
items
)
{
AppendToTop
(
item
)
;
}
}
bool
ComputeVisibilityForSublist
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
const
nsRect
&
aListVisibleBounds
)
;
bool
ComputeVisibilityForRoot
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
;
bool
IsOpaque
(
)
const
{
return
mIsOpaque
;
}
bool
NeedsTransparentSurface
(
)
const
{
return
mForceTransparentSurface
;
}
enum
{
PAINT_DEFAULT
=
0
PAINT_USE_WIDGET_LAYERS
=
0x01
PAINT_EXISTING_TRANSACTION
=
0x04
PAINT_NO_COMPOSITE
=
0x08
PAINT_COMPRESSED
=
0x10
}
;
already_AddRefed
<
LayerManager
>
PaintRoot
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
uint32_t
aFlags
)
;
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
)
const
;
nsRect
GetClippedBoundsWithRespectToASR
(
nsDisplayListBuilder
*
aBuilder
const
ActiveScrolledRoot
*
aASR
nsRect
*
aVisibleRect
=
nullptr
)
const
;
void
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
nsDisplayItem
:
:
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
const
;
nsRect
GetVisibleRect
(
)
const
;
void
SetIsOpaque
(
)
{
mIsOpaque
=
true
;
}
void
SetNeedsTransparentSurface
(
)
{
mForceTransparentSurface
=
true
;
}
nsDisplayListBuilder
*
mBuilder
;
private
:
void
*
operator
new
(
size_t
sz
)
CPP_THROW_NEW
;
nsDisplayItemLink
mSentinel
;
nsDisplayItemLink
*
mTop
;
bool
mIsOpaque
;
bool
mForceTransparentSurface
;
}
;
class
nsDisplayListSet
{
public
:
nsDisplayList
*
BorderBackground
(
)
const
{
return
mBorderBackground
;
}
nsDisplayList
*
BlockBorderBackgrounds
(
)
const
{
return
mBlockBorderBackgrounds
;
}
nsDisplayList
*
Floats
(
)
const
{
return
mFloats
;
}
nsDisplayList
*
PositionedDescendants
(
)
const
{
return
mPositioned
;
}
nsDisplayList
*
Outlines
(
)
const
{
return
mOutlines
;
}
nsDisplayList
*
Content
(
)
const
{
return
mContent
;
}
void
DeleteAll
(
nsDisplayListBuilder
*
aBuilder
)
{
BorderBackground
(
)
-
>
DeleteAll
(
aBuilder
)
;
BlockBorderBackgrounds
(
)
-
>
DeleteAll
(
aBuilder
)
;
Floats
(
)
-
>
DeleteAll
(
aBuilder
)
;
PositionedDescendants
(
)
-
>
DeleteAll
(
aBuilder
)
;
Outlines
(
)
-
>
DeleteAll
(
aBuilder
)
;
Content
(
)
-
>
DeleteAll
(
aBuilder
)
;
}
nsDisplayListSet
(
nsDisplayList
*
aBorderBackground
nsDisplayList
*
aBlockBorderBackgrounds
nsDisplayList
*
aFloats
nsDisplayList
*
aContent
nsDisplayList
*
aPositionedDescendants
nsDisplayList
*
aOutlines
)
:
mBorderBackground
(
aBorderBackground
)
mBlockBorderBackgrounds
(
aBlockBorderBackgrounds
)
mFloats
(
aFloats
)
mContent
(
aContent
)
mPositioned
(
aPositionedDescendants
)
mOutlines
(
aOutlines
)
{
}
nsDisplayListSet
(
const
nsDisplayListSet
&
aLists
nsDisplayList
*
aBorderBackground
)
:
mBorderBackground
(
aBorderBackground
)
mBlockBorderBackgrounds
(
aLists
.
BlockBorderBackgrounds
(
)
)
mFloats
(
aLists
.
Floats
(
)
)
mContent
(
aLists
.
Content
(
)
)
mPositioned
(
aLists
.
PositionedDescendants
(
)
)
mOutlines
(
aLists
.
Outlines
(
)
)
{
}
void
MoveTo
(
const
nsDisplayListSet
&
aDestination
)
const
;
private
:
void
*
operator
new
(
size_t
sz
)
CPP_THROW_NEW
;
protected
:
nsDisplayList
*
mBorderBackground
;
nsDisplayList
*
mBlockBorderBackgrounds
;
nsDisplayList
*
mFloats
;
nsDisplayList
*
mContent
;
nsDisplayList
*
mPositioned
;
nsDisplayList
*
mOutlines
;
}
;
struct
nsDisplayListCollection
:
public
nsDisplayListSet
{
explicit
nsDisplayListCollection
(
nsDisplayListBuilder
*
aBuilder
)
:
nsDisplayListSet
(
&
mLists
[
0
]
&
mLists
[
1
]
&
mLists
[
2
]
&
mLists
[
3
]
&
mLists
[
4
]
&
mLists
[
5
]
)
mLists
{
nsDisplayList
(
aBuilder
)
nsDisplayList
(
aBuilder
)
nsDisplayList
(
aBuilder
)
nsDisplayList
(
aBuilder
)
nsDisplayList
(
aBuilder
)
nsDisplayList
(
aBuilder
)
}
{
}
explicit
nsDisplayListCollection
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aBorderBackground
)
:
nsDisplayListSet
(
aBorderBackground
&
mLists
[
1
]
&
mLists
[
2
]
&
mLists
[
3
]
&
mLists
[
4
]
&
mLists
[
5
]
)
mLists
{
nsDisplayList
(
aBuilder
)
nsDisplayList
(
aBuilder
)
nsDisplayList
(
aBuilder
)
nsDisplayList
(
aBuilder
)
nsDisplayList
(
aBuilder
)
nsDisplayList
(
aBuilder
)
}
{
}
void
SortAllByContentOrder
(
nsIContent
*
aCommonAncestor
)
{
for
(
int32_t
i
=
0
;
i
<
6
;
+
+
i
)
{
mLists
[
i
]
.
SortByContentOrder
(
aCommonAncestor
)
;
}
}
private
:
void
*
operator
new
(
size_t
sz
)
CPP_THROW_NEW
;
nsDisplayList
mLists
[
6
]
;
}
;
class
nsDisplayImageContainer
:
public
nsDisplayItem
{
public
:
typedef
mozilla
:
:
LayerIntPoint
LayerIntPoint
;
typedef
mozilla
:
:
LayoutDeviceRect
LayoutDeviceRect
;
typedef
mozilla
:
:
layers
:
:
ImageContainer
ImageContainer
;
typedef
mozilla
:
:
layers
:
:
ImageLayer
ImageLayer
;
nsDisplayImageContainer
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
:
nsDisplayItem
(
aBuilder
aFrame
)
{
}
virtual
bool
CanOptimizeToImageLayer
(
LayerManager
*
aManager
nsDisplayListBuilder
*
aBuilder
)
;
already_AddRefed
<
ImageContainer
>
GetContainer
(
LayerManager
*
aManager
nsDisplayListBuilder
*
aBuilder
)
;
void
ConfigureLayer
(
ImageLayer
*
aLayer
const
ContainerLayerParameters
&
aParameters
)
;
virtual
already_AddRefed
<
imgIContainer
>
GetImage
(
)
=
0
;
virtual
nsRect
GetDestRect
(
)
const
=
0
;
virtual
bool
SupportsOptimizingToImage
(
)
const
override
{
return
true
;
}
}
;
class
nsDisplayGeneric
:
public
nsDisplayItem
{
public
:
typedef
void
(
*
PaintCallback
)
(
nsIFrame
*
aFrame
DrawTarget
*
aDrawTarget
const
nsRect
&
aDirtyRect
nsPoint
aFramePt
)
;
typedef
void
(
*
OldPaintCallback
)
(
nsIFrame
*
aFrame
gfxContext
*
aCtx
const
nsRect
&
aDirtyRect
nsPoint
aFramePt
)
;
nsDisplayGeneric
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
PaintCallback
aPaint
const
char
*
aName
DisplayItemType
aType
)
:
nsDisplayItem
(
aBuilder
aFrame
)
mPaint
(
aPaint
)
mOldPaint
(
nullptr
)
mName
(
aName
)
mType
(
aType
)
{
MOZ_COUNT_CTOR
(
nsDisplayGeneric
)
;
}
nsDisplayGeneric
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
OldPaintCallback
aOldPaint
const
char
*
aName
DisplayItemType
aType
)
:
nsDisplayItem
(
aBuilder
aFrame
)
mPaint
(
nullptr
)
mOldPaint
(
aOldPaint
)
mName
(
aName
)
mType
(
aType
)
{
MOZ_COUNT_CTOR
(
nsDisplayGeneric
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayGeneric
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayGeneric
)
;
}
#
endif
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
{
MOZ_ASSERT
(
!
!
mPaint
!
=
!
!
mOldPaint
)
;
if
(
mPaint
)
{
mPaint
(
mFrame
aCtx
-
>
GetDrawTarget
(
)
mVisibleRect
ToReferenceFrame
(
)
)
;
}
else
{
mOldPaint
(
mFrame
aCtx
mVisibleRect
ToReferenceFrame
(
)
)
;
}
}
virtual
const
char
*
Name
(
)
const
override
{
return
mName
;
}
virtual
DisplayItemType
GetType
(
)
const
override
{
return
mType
;
}
void
*
operator
new
(
size_t
aSize
nsDisplayListBuilder
*
aBuilder
)
{
return
aBuilder
-
>
Allocate
(
aSize
DisplayItemType
:
:
TYPE_GENERIC
)
;
}
virtual
void
Destroy
(
nsDisplayListBuilder
*
aBuilder
)
override
{
this
-
>
~
nsDisplayGeneric
(
)
;
aBuilder
-
>
Destroy
(
DisplayItemType
:
:
TYPE_GENERIC
this
)
;
}
protected
:
PaintCallback
mPaint
;
OldPaintCallback
mOldPaint
;
const
char
*
mName
;
DisplayItemType
mType
;
}
;
#
if
defined
(
MOZ_REFLOW_PERF_DSP
)
&
&
defined
(
MOZ_REFLOW_PERF
)
class
nsDisplayReflowCount
:
public
nsDisplayItem
{
public
:
nsDisplayReflowCount
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
char
*
aFrameName
uint32_t
aColor
=
0
)
:
nsDisplayItem
(
aBuilder
aFrame
)
mFrameName
(
aFrameName
)
mColor
(
aColor
)
{
MOZ_COUNT_CTOR
(
nsDisplayReflowCount
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayReflowCount
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayReflowCount
)
;
}
#
endif
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
{
mFrame
-
>
PresContext
(
)
-
>
PresShell
(
)
-
>
PaintCount
(
mFrameName
aCtx
mFrame
-
>
PresContext
(
)
mFrame
ToReferenceFrame
(
)
mColor
)
;
}
NS_DISPLAY_DECL_NAME
(
"
nsDisplayReflowCount
"
TYPE_REFLOW_COUNT
)
protected
:
const
char
*
mFrameName
;
nscolor
mColor
;
}
;
#
define
DO_GLOBAL_REFLOW_COUNT_DSP
(
_name
)
\
PR_BEGIN_MACRO
\
if
(
!
aBuilder
-
>
IsBackgroundOnly
(
)
&
&
!
aBuilder
-
>
IsForEventDelivery
(
)
&
&
\
PresContext
(
)
-
>
PresShell
(
)
-
>
IsPaintingFrameCounts
(
)
)
{
\
aLists
.
Outlines
(
)
-
>
AppendNewToTop
(
\
new
(
aBuilder
)
nsDisplayReflowCount
(
aBuilder
this
_name
)
)
;
\
}
\
PR_END_MACRO
#
define
DO_GLOBAL_REFLOW_COUNT_DSP_COLOR
(
_name
_color
)
\
PR_BEGIN_MACRO
\
if
(
!
aBuilder
-
>
IsBackgroundOnly
(
)
&
&
!
aBuilder
-
>
IsForEventDelivery
(
)
&
&
\
PresContext
(
)
-
>
PresShell
(
)
-
>
IsPaintingFrameCounts
(
)
)
{
\
aLists
.
Outlines
(
)
-
>
AppendNewToTop
(
\
new
(
aBuilder
)
nsDisplayReflowCount
(
aBuilder
this
_name
_color
)
)
;
\
}
\
PR_END_MACRO
#
define
DECL_DO_GLOBAL_REFLOW_COUNT_DSP
(
_class
_super
)
\
void
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
\
const
nsRect
&
aDirtyRect
\
const
nsDisplayListSet
&
aLists
)
{
\
DO_GLOBAL_REFLOW_COUNT_DSP
(
#
_class
)
;
\
_super
:
:
BuildDisplayList
(
aBuilder
aDirtyRect
aLists
)
;
\
}
#
else
#
define
DO_GLOBAL_REFLOW_COUNT_DSP
(
_name
)
#
define
DO_GLOBAL_REFLOW_COUNT_DSP_COLOR
(
_name
_color
)
#
define
DECL_DO_GLOBAL_REFLOW_COUNT_DSP
(
_class
_super
)
#
endif
class
nsDisplayCaret
:
public
nsDisplayItem
{
public
:
nsDisplayCaret
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aCaretFrame
)
;
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayCaret
(
)
;
#
endif
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
;
NS_DISPLAY_DECL_NAME
(
"
Caret
"
TYPE_CARET
)
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
;
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
protected
:
RefPtr
<
nsCaret
>
mCaret
;
nsRect
mBounds
;
}
;
class
nsDisplayBorder
:
public
nsDisplayItem
{
public
:
nsDisplayBorder
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
;
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayBorder
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayBorder
)
;
}
#
endif
virtual
bool
IsInvisibleInRect
(
const
nsRect
&
aRect
)
const
override
;
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
;
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
;
NS_DISPLAY_DECL_NAME
(
"
Border
"
TYPE_BORDER
)
virtual
nsDisplayItemGeometry
*
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
override
;
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
;
virtual
nsRegion
GetTightBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
{
*
aSnap
=
true
;
return
CalculateBounds
(
*
mFrame
-
>
StyleBorder
(
)
)
;
}
protected
:
void
CreateBorderImageWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResource
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
;
nsRegion
CalculateBounds
(
const
nsStyleBorder
&
aStyleBorder
)
const
;
mozilla
:
:
Array
<
mozilla
:
:
gfx
:
:
Color
4
>
mColors
;
mozilla
:
:
Array
<
mozilla
:
:
LayerCoord
4
>
mWidths
;
mozilla
:
:
Array
<
mozilla
:
:
LayerSize
4
>
mCorners
;
mozilla
:
:
Array
<
uint8_t
4
>
mBorderStyles
;
mozilla
:
:
LayerRect
mRect
;
mozilla
:
:
Maybe
<
nsCSSBorderRenderer
>
mBorderRenderer
;
mozilla
:
:
Maybe
<
nsCSSBorderImageRenderer
>
mBorderImageRenderer
;
nsRect
mBounds
;
}
;
class
nsDisplaySolidColorBase
:
public
nsDisplayItem
{
public
:
nsDisplaySolidColorBase
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nscolor
aColor
)
:
nsDisplayItem
(
aBuilder
aFrame
)
mColor
(
aColor
)
{
}
virtual
nsDisplayItemGeometry
*
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
new
nsDisplaySolidColorGeometry
(
this
aBuilder
mColor
)
;
}
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
{
const
nsDisplaySolidColorGeometry
*
geometry
=
static_cast
<
const
nsDisplaySolidColorGeometry
*
>
(
aGeometry
)
;
if
(
mColor
!
=
geometry
-
>
mColor
)
{
bool
dummy
;
aInvalidRegion
-
>
Or
(
geometry
-
>
mBounds
GetBounds
(
aBuilder
&
dummy
)
)
;
return
;
}
ComputeInvalidationRegionDifference
(
aBuilder
geometry
aInvalidRegion
)
;
}
virtual
nsRegion
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
{
*
aSnap
=
false
;
nsRegion
result
;
if
(
NS_GET_A
(
mColor
)
=
=
255
)
{
result
=
GetBounds
(
aBuilder
aSnap
)
;
}
return
result
;
}
virtual
mozilla
:
:
Maybe
<
nscolor
>
IsUniform
(
nsDisplayListBuilder
*
aBuilder
)
const
override
{
return
mozilla
:
:
Some
(
mColor
)
;
}
protected
:
nscolor
mColor
;
}
;
class
nsDisplaySolidColor
:
public
nsDisplaySolidColorBase
{
public
:
nsDisplaySolidColor
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
nsRect
&
aBounds
nscolor
aColor
)
:
nsDisplaySolidColorBase
(
aBuilder
aFrame
aColor
)
mBounds
(
aBounds
)
{
NS_ASSERTION
(
NS_GET_A
(
aColor
)
>
0
"
Don
'
t
create
invisible
nsDisplaySolidColors
!
"
)
;
MOZ_COUNT_CTOR
(
nsDisplaySolidColor
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplaySolidColor
(
)
{
MOZ_COUNT_DTOR
(
nsDisplaySolidColor
)
;
}
#
endif
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
;
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
;
virtual
void
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
override
;
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
NS_DISPLAY_DECL_NAME
(
"
SolidColor
"
TYPE_SOLID_COLOR
)
private
:
nsRect
mBounds
;
}
;
class
nsDisplaySolidColorRegion
:
public
nsDisplayItem
{
typedef
mozilla
:
:
gfx
:
:
Color
Color
;
public
:
nsDisplaySolidColorRegion
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
nsRegion
&
aRegion
nscolor
aColor
)
:
nsDisplayItem
(
aBuilder
aFrame
)
mRegion
(
aRegion
)
mColor
(
Color
:
:
FromABGR
(
aColor
)
)
{
NS_ASSERTION
(
NS_GET_A
(
aColor
)
>
0
"
Don
'
t
create
invisible
nsDisplaySolidColorRegions
!
"
)
;
MOZ_COUNT_CTOR
(
nsDisplaySolidColorRegion
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplaySolidColorRegion
(
)
{
MOZ_COUNT_DTOR
(
nsDisplaySolidColorRegion
)
;
}
#
endif
virtual
nsDisplayItemGeometry
*
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
new
nsDisplaySolidColorRegionGeometry
(
this
aBuilder
mRegion
mColor
)
;
}
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
{
const
nsDisplaySolidColorRegionGeometry
*
geometry
=
static_cast
<
const
nsDisplaySolidColorRegionGeometry
*
>
(
aGeometry
)
;
if
(
mColor
=
=
geometry
-
>
mColor
)
{
aInvalidRegion
-
>
Xor
(
geometry
-
>
mRegion
mRegion
)
;
}
else
{
aInvalidRegion
-
>
Or
(
geometry
-
>
mRegion
.
GetBounds
(
)
mRegion
.
GetBounds
(
)
)
;
}
}
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
NS_DISPLAY_DECL_NAME
(
"
SolidColorRegion
"
TYPE_SOLID_COLOR_REGION
)
protected
:
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
;
virtual
void
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
override
;
private
:
nsRegion
mRegion
;
Color
mColor
;
}
;
class
nsDisplayBackgroundImage
:
public
nsDisplayImageContainer
{
public
:
typedef
mozilla
:
:
StyleGeometryBox
StyleGeometryBox
;
struct
InitData
{
nsDisplayListBuilder
*
builder
;
nsIFrame
*
frame
;
const
nsStyleBackground
*
backgroundStyle
;
nsCOMPtr
<
imgIContainer
>
image
;
nsRect
backgroundRect
;
nsRect
fillArea
;
nsRect
destArea
;
uint32_t
layer
;
bool
isRasterImage
;
bool
shouldFixToViewport
;
}
;
enum
class
LayerizeFixed
:
uint8_t
{
ALWAYS_LAYERIZE_FIXED_BACKGROUND
DO_NOT_LAYERIZE_FIXED_BACKGROUND_IF_AVOIDING_COMPONENT_ALPHA_LAYERS
}
;
static
InitData
GetInitData
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
uint32_t
aLayer
const
nsRect
&
aBackgroundRect
const
nsStyleBackground
*
aBackgroundStyle
LayerizeFixed
aLayerizeFixed
)
;
explicit
nsDisplayBackgroundImage
(
const
InitData
&
aInitData
)
;
virtual
~
nsDisplayBackgroundImage
(
)
;
static
bool
AppendBackgroundItemsToTop
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
nsRect
&
aBackgroundRect
nsDisplayList
*
aList
bool
aAllowWillPaintBorderOptimization
=
true
nsStyleContext
*
aStyleContext
=
nullptr
const
nsRect
&
aBackgroundOriginRect
=
nsRect
(
)
nsIFrame
*
aSecondaryReferenceFrame
=
nullptr
)
;
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
;
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
virtual
void
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
override
;
virtual
bool
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
override
;
virtual
nsRegion
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
mozilla
:
:
Maybe
<
nscolor
>
IsUniform
(
nsDisplayListBuilder
*
aBuilder
)
const
override
;
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
;
virtual
uint32_t
GetPerFrameKey
(
)
const
override
{
return
(
mLayer
<
<
TYPE_BITS
)
|
nsDisplayItem
:
:
GetPerFrameKey
(
)
;
}
NS_DISPLAY_DECL_NAME
(
"
Background
"
TYPE_BACKGROUND
)
nsRect
GetPositioningArea
(
)
const
;
bool
RenderingMightDependOnPositioningAreaSizeChange
(
)
const
;
virtual
nsDisplayItemGeometry
*
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
new
nsDisplayBackgroundGeometry
(
this
aBuilder
)
;
}
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
;
virtual
bool
CanOptimizeToImageLayer
(
LayerManager
*
aManager
nsDisplayListBuilder
*
aBuilder
)
override
;
virtual
already_AddRefed
<
imgIContainer
>
GetImage
(
)
override
;
virtual
nsRect
GetDestRect
(
)
const
override
;
static
nsRegion
GetInsideClipRegion
(
const
nsDisplayItem
*
aItem
StyleGeometryBox
aClip
const
nsRect
&
aRect
const
nsRect
&
aBackgroundRect
)
;
virtual
bool
ShouldFixToViewport
(
nsDisplayListBuilder
*
aBuilder
)
const
override
{
return
mShouldFixToViewport
;
}
protected
:
typedef
class
mozilla
:
:
layers
:
:
ImageContainer
ImageContainer
;
typedef
class
mozilla
:
:
layers
:
:
ImageLayer
ImageLayer
;
bool
CanBuildWebRenderDisplayItems
(
LayerManager
*
aManager
)
;
bool
TryOptimizeToImageLayer
(
LayerManager
*
aManager
nsDisplayListBuilder
*
aBuilder
)
;
nsRect
GetBoundsInternal
(
nsDisplayListBuilder
*
aBuilder
)
;
void
PaintInternal
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
const
nsRect
&
aBounds
nsRect
*
aClipRect
)
;
virtual
nsIFrame
*
StyleFrame
(
)
{
return
mFrame
;
}
enum
ImageLayerization
{
WHENEVER_POSSIBLE
ONLY_FOR_SCALING
NO_LAYER_NEEDED
}
;
ImageLayerization
ShouldCreateOwnLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
)
;
const
nsStyleBackground
*
mBackgroundStyle
;
nsCOMPtr
<
imgIContainer
>
mImage
;
nsRect
mBackgroundRect
;
nsRect
mFillRect
;
nsRect
mDestRect
;
nsRect
mBounds
;
uint32_t
mLayer
;
bool
mIsRasterImage
;
bool
mShouldFixToViewport
;
uint32_t
mImageFlags
;
}
;
enum
class
TableType
:
uint8_t
{
TABLE
TABLE_COL
TABLE_COL_GROUP
TABLE_ROW
TABLE_ROW_GROUP
TABLE_CELL
TABLE_TYPE_MAX
}
;
enum
class
TableTypeBits
:
uint8_t
{
COUNT
=
3
}
;
static_assert
(
static_cast
<
uint8_t
>
(
TableType
:
:
TABLE_TYPE_MAX
)
<
(
1
<
<
(
static_cast
<
uint8_t
>
(
TableTypeBits
:
:
COUNT
)
+
1
)
)
"
TableType
cannot
fit
with
TableTypeBits
:
:
COUNT
"
)
;
TableType
GetTableTypeFromFrame
(
nsIFrame
*
aFrame
)
;
class
nsDisplayTableBackgroundImage
:
public
nsDisplayBackgroundImage
{
public
:
nsDisplayTableBackgroundImage
(
const
InitData
&
aInitData
nsIFrame
*
aCellFrame
)
;
virtual
uint32_t
GetPerFrameKey
(
)
const
override
{
return
(
static_cast
<
uint8_t
>
(
mTableType
)
<
<
TYPE_BITS
)
|
nsDisplayItem
:
:
GetPerFrameKey
(
)
;
}
virtual
bool
IsInvalid
(
nsRect
&
aRect
)
const
override
;
protected
:
virtual
nsIFrame
*
StyleFrame
(
)
override
{
return
mStyleFrame
;
}
nsIFrame
*
mStyleFrame
;
TableType
mTableType
;
}
;
class
nsDisplayThemedBackground
:
public
nsDisplayItem
{
public
:
nsDisplayThemedBackground
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
nsRect
&
aBackgroundRect
)
;
virtual
~
nsDisplayThemedBackground
(
)
;
virtual
void
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
override
;
virtual
nsRegion
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
mozilla
:
:
Maybe
<
nscolor
>
IsUniform
(
nsDisplayListBuilder
*
aBuilder
)
const
override
;
virtual
bool
MustPaintOnContentSide
(
)
const
override
{
return
true
;
}
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
;
NS_DISPLAY_DECL_NAME
(
"
ThemedBackground
"
TYPE_THEMED_BACKGROUND
)
nsRect
GetPositioningArea
(
)
const
;
bool
IsWindowActive
(
)
const
;
virtual
nsDisplayItemGeometry
*
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
new
nsDisplayThemedBackgroundGeometry
(
this
aBuilder
)
;
}
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
;
virtual
void
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
override
;
protected
:
nsRect
GetBoundsInternal
(
)
;
void
PaintInternal
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
const
nsRect
&
aBounds
nsRect
*
aClipRect
)
;
nsRect
mBackgroundRect
;
nsRect
mBounds
;
nsITheme
:
:
Transparency
mThemeTransparency
;
uint8_t
mAppearance
;
}
;
class
nsDisplayBackgroundColor
:
public
nsDisplayItem
{
typedef
mozilla
:
:
gfx
:
:
Color
Color
;
public
:
nsDisplayBackgroundColor
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
nsRect
&
aBackgroundRect
const
nsStyleBackground
*
aBackgroundStyle
nscolor
aColor
)
:
nsDisplayItem
(
aBuilder
aFrame
)
mBackgroundRect
(
aBackgroundRect
)
mBackgroundStyle
(
aBackgroundStyle
)
mColor
(
Color
:
:
FromABGR
(
aColor
)
)
{
}
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
;
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
;
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
virtual
nsRegion
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
mozilla
:
:
Maybe
<
nscolor
>
IsUniform
(
nsDisplayListBuilder
*
aBuilder
)
const
override
;
virtual
void
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
override
;
virtual
void
ApplyOpacity
(
nsDisplayListBuilder
*
aBuilder
float
aOpacity
const
DisplayItemClipChain
*
aClip
)
override
;
virtual
bool
CanApplyOpacity
(
)
const
override
;
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
{
*
aSnap
=
true
;
return
mBackgroundRect
;
}
virtual
nsDisplayItemGeometry
*
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
new
nsDisplaySolidColorGeometry
(
this
aBuilder
mColor
.
ToABGR
(
)
)
;
}
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
{
const
nsDisplaySolidColorGeometry
*
geometry
=
static_cast
<
const
nsDisplaySolidColorGeometry
*
>
(
aGeometry
)
;
if
(
mColor
.
ToABGR
(
)
!
=
geometry
-
>
mColor
)
{
bool
dummy
;
aInvalidRegion
-
>
Or
(
geometry
-
>
mBounds
GetBounds
(
aBuilder
&
dummy
)
)
;
return
;
}
ComputeInvalidationRegionDifference
(
aBuilder
geometry
aInvalidRegion
)
;
}
NS_DISPLAY_DECL_NAME
(
"
BackgroundColor
"
TYPE_BACKGROUND_COLOR
)
virtual
void
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
override
;
protected
:
const
nsRect
mBackgroundRect
;
const
nsStyleBackground
*
mBackgroundStyle
;
mozilla
:
:
gfx
:
:
Color
mColor
;
}
;
class
nsDisplayTableBackgroundColor
:
public
nsDisplayBackgroundColor
{
public
:
nsDisplayTableBackgroundColor
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
nsRect
&
aBackgroundRect
const
nsStyleBackground
*
aBackgroundStyle
nscolor
aColor
nsIFrame
*
aAncestorFrame
)
:
nsDisplayBackgroundColor
(
aBuilder
aFrame
aBackgroundRect
aBackgroundStyle
aColor
)
mTableType
(
GetTableTypeFromFrame
(
aAncestorFrame
)
)
{
}
virtual
uint32_t
GetPerFrameKey
(
)
const
override
{
return
(
static_cast
<
uint8_t
>
(
mTableType
)
<
<
TYPE_BITS
)
|
nsDisplayItem
:
:
GetPerFrameKey
(
)
;
}
protected
:
TableType
mTableType
;
}
;
class
nsDisplayClearBackground
:
public
nsDisplayItem
{
public
:
nsDisplayClearBackground
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
:
nsDisplayItem
(
aBuilder
aFrame
)
{
}
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
{
*
aSnap
=
true
;
return
nsRect
(
ToReferenceFrame
(
)
Frame
(
)
-
>
GetSize
(
)
)
;
}
virtual
nsRegion
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
{
*
aSnap
=
false
;
return
GetBounds
(
aBuilder
aSnap
)
;
}
virtual
mozilla
:
:
Maybe
<
nscolor
>
IsUniform
(
nsDisplayListBuilder
*
aBuilder
)
const
override
{
return
mozilla
:
:
Some
(
NS_RGBA
(
0
0
0
0
)
)
;
}
virtual
bool
ClearsBackground
(
)
const
override
{
return
true
;
}
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
{
return
mozilla
:
:
LAYER_ACTIVE_FORCE
;
}
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
NS_DISPLAY_DECL_NAME
(
"
ClearBackground
"
TYPE_CLEAR_BACKGROUND
)
}
;
class
nsDisplayBoxShadowOuter
final
:
public
nsDisplayItem
{
public
:
nsDisplayBoxShadowOuter
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
:
nsDisplayItem
(
aBuilder
aFrame
)
mOpacity
(
1
.
0f
)
{
MOZ_COUNT_CTOR
(
nsDisplayBoxShadowOuter
)
;
mBounds
=
GetBoundsInternal
(
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayBoxShadowOuter
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayBoxShadowOuter
)
;
}
#
endif
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
;
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
bool
IsInvisibleInRect
(
const
nsRect
&
aRect
)
const
override
;
virtual
bool
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
override
;
NS_DISPLAY_DECL_NAME
(
"
BoxShadowOuter
"
TYPE_BOX_SHADOW_OUTER
)
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
;
virtual
void
ApplyOpacity
(
nsDisplayListBuilder
*
aBuilder
float
aOpacity
const
DisplayItemClipChain
*
aClip
)
override
{
NS_ASSERTION
(
CanApplyOpacity
(
)
"
ApplyOpacity
should
be
allowed
"
)
;
mOpacity
=
aOpacity
;
IntersectClip
(
aBuilder
aClip
)
;
}
virtual
bool
CanApplyOpacity
(
)
const
override
{
return
true
;
}
virtual
nsDisplayItemGeometry
*
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
new
nsDisplayBoxShadowOuterGeometry
(
this
aBuilder
mOpacity
)
;
}
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
;
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
bool
CanBuildWebRenderDisplayItems
(
)
;
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
nsRect
GetBoundsInternal
(
)
;
private
:
nsRegion
mVisibleRegion
;
nsRect
mBounds
;
float
mOpacity
;
}
;
class
nsDisplayBoxShadowInner
:
public
nsDisplayItem
{
public
:
nsDisplayBoxShadowInner
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
:
nsDisplayItem
(
aBuilder
aFrame
)
{
MOZ_COUNT_CTOR
(
nsDisplayBoxShadowInner
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayBoxShadowInner
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayBoxShadowInner
)
;
}
#
endif
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
;
virtual
bool
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
override
;
NS_DISPLAY_DECL_NAME
(
"
BoxShadowInner
"
TYPE_BOX_SHADOW_INNER
)
virtual
nsDisplayItemGeometry
*
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
new
nsDisplayBoxShadowInnerGeometry
(
this
aBuilder
)
;
}
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
{
const
nsDisplayBoxShadowInnerGeometry
*
geometry
=
static_cast
<
const
nsDisplayBoxShadowInnerGeometry
*
>
(
aGeometry
)
;
if
(
!
geometry
-
>
mPaddingRect
.
IsEqualInterior
(
GetPaddingRect
(
)
)
)
{
bool
snap
;
aInvalidRegion
-
>
Or
(
geometry
-
>
mBounds
GetBounds
(
aBuilder
&
snap
)
)
;
}
}
static
bool
CanCreateWebRenderCommands
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsPoint
aReferencePoint
)
;
static
void
CreateInsetBoxShadowWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
const
StackingContextHelper
&
aSc
nsRegion
&
aVisibleRegion
nsIFrame
*
aFrame
const
nsRect
aBorderRect
)
;
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
;
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
private
:
nsRegion
mVisibleRegion
;
}
;
class
nsDisplayOutline
:
public
nsDisplayItem
{
public
:
nsDisplayOutline
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
:
nsDisplayItem
(
aBuilder
aFrame
)
{
MOZ_COUNT_CTOR
(
nsDisplayOutline
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayOutline
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayOutline
)
;
}
#
endif
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
;
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
virtual
bool
IsInvisibleInRect
(
const
nsRect
&
aRect
)
const
override
;
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
;
NS_DISPLAY_DECL_NAME
(
"
Outline
"
TYPE_OUTLINE
)
mozilla
:
:
Maybe
<
nsCSSBorderRenderer
>
mBorderRenderer
;
}
;
class
nsDisplayEventReceiver
:
public
nsDisplayItem
{
public
:
nsDisplayEventReceiver
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
:
nsDisplayItem
(
aBuilder
aFrame
)
{
MOZ_COUNT_CTOR
(
nsDisplayEventReceiver
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayEventReceiver
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayEventReceiver
)
;
}
#
endif
virtual
void
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
override
;
NS_DISPLAY_DECL_NAME
(
"
EventReceiver
"
TYPE_EVENT_RECEIVER
)
}
;
class
nsDisplayLayerEventRegions
final
:
public
nsDisplayItem
{
public
:
nsDisplayLayerEventRegions
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
:
nsDisplayItem
(
aBuilder
aFrame
)
{
MOZ_COUNT_CTOR
(
nsDisplayLayerEventRegions
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayLayerEventRegions
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayLayerEventRegions
)
;
}
#
endif
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
{
*
aSnap
=
false
;
return
nsRect
(
)
;
}
nsRect
GetHitRegionBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
{
*
aSnap
=
false
;
return
mHitRegion
.
GetBounds
(
)
.
Union
(
mMaybeHitRegion
.
GetBounds
(
)
)
;
}
virtual
void
ApplyOpacity
(
nsDisplayListBuilder
*
aBuilder
float
aOpacity
const
DisplayItemClipChain
*
aClip
)
override
{
NS_ASSERTION
(
CanApplyOpacity
(
)
"
ApplyOpacity
should
be
allowed
"
)
;
}
virtual
bool
CanApplyOpacity
(
)
const
override
{
return
true
;
}
NS_DISPLAY_DECL_NAME
(
"
LayerEventRegions
"
TYPE_LAYER_EVENT_REGIONS
)
void
AddFrame
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
;
void
AddInactiveScrollPort
(
const
nsRect
&
aRect
)
;
bool
IsEmpty
(
)
const
;
int32_t
ZIndex
(
)
const
override
;
void
SetOverrideZIndex
(
int32_t
aZIndex
)
;
const
nsRegion
&
HitRegion
(
)
{
return
mHitRegion
;
}
const
nsRegion
&
MaybeHitRegion
(
)
{
return
mMaybeHitRegion
;
}
const
nsRegion
&
DispatchToContentHitRegion
(
)
{
return
mDispatchToContentHitRegion
;
}
const
nsRegion
&
NoActionRegion
(
)
{
return
mNoActionRegion
;
}
const
nsRegion
&
HorizontalPanRegion
(
)
{
return
mHorizontalPanRegion
;
}
const
nsRegion
&
VerticalPanRegion
(
)
{
return
mVerticalPanRegion
;
}
nsRegion
CombinedTouchActionRegion
(
)
;
virtual
void
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
override
;
private
:
nsRegion
mHitRegion
;
nsRegion
mMaybeHitRegion
;
nsRegion
mDispatchToContentHitRegion
;
nsRegion
mNoActionRegion
;
nsRegion
mHorizontalPanRegion
;
nsRegion
mVerticalPanRegion
;
mozilla
:
:
Maybe
<
int32_t
>
mOverrideZIndex
;
}
;
class
nsDisplayWrapList
:
public
nsDisplayItem
{
public
:
nsDisplayWrapList
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
)
;
nsDisplayWrapList
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
ActiveScrolledRoot
*
aActiveScrolledRoot
)
;
nsDisplayWrapList
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayItem
*
aItem
)
;
nsDisplayWrapList
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
:
nsDisplayItem
(
aBuilder
aFrame
)
mList
(
aBuilder
)
mOverrideZIndex
(
0
)
mHasZIndexOverride
(
false
)
{
MOZ_COUNT_CTOR
(
nsDisplayWrapList
)
;
mBaseVisibleRect
=
mVisibleRect
;
mListPtr
=
&
mList
;
}
nsDisplayWrapList
(
const
nsDisplayWrapList
&
aOther
)
:
nsDisplayItem
(
aOther
)
mList
(
aOther
.
mList
.
mBuilder
)
mListPtr
(
&
mList
)
mMergedFrames
(
aOther
.
mMergedFrames
)
mBounds
(
aOther
.
mBounds
)
mBaseVisibleRect
(
aOther
.
mBaseVisibleRect
)
mOverrideZIndex
(
aOther
.
mOverrideZIndex
)
mHasZIndexOverride
(
aOther
.
mHasZIndexOverride
)
{
MOZ_COUNT_CTOR
(
nsDisplayWrapList
)
;
}
virtual
~
nsDisplayWrapList
(
)
;
virtual
const
nsDisplayWrapList
*
AsDisplayWrapList
(
)
const
override
{
return
this
;
}
virtual
void
Destroy
(
nsDisplayListBuilder
*
aBuilder
)
override
{
mList
.
DeleteAll
(
aBuilder
)
;
nsDisplayItem
:
:
Destroy
(
aBuilder
)
;
}
virtual
void
MergeDisplayListFromItem
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItem
*
aItem
)
override
;
virtual
void
UpdateBounds
(
nsDisplayListBuilder
*
aBuilder
)
override
{
nsRect
visibleRect
;
mBounds
=
mListPtr
-
>
GetClippedBoundsWithRespectToASR
(
aBuilder
mActiveScrolledRoot
&
visibleRect
)
;
mVisibleRect
.
UnionRect
(
mBaseVisibleRect
visibleRect
)
;
}
virtual
void
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
override
;
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
nsRegion
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
mozilla
:
:
Maybe
<
nscolor
>
IsUniform
(
nsDisplayListBuilder
*
aBuilder
)
const
override
;
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
;
virtual
bool
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
override
;
virtual
bool
CanMerge
(
const
nsDisplayItem
*
aItem
)
const
override
{
return
false
;
}
virtual
void
Merge
(
const
nsDisplayItem
*
aItem
)
override
{
MOZ_ASSERT
(
CanMerge
(
aItem
)
)
;
MergeFromTrackingMergedFrames
(
static_cast
<
const
nsDisplayWrapList
*
>
(
aItem
)
)
;
}
virtual
void
GetMergedFrames
(
nsTArray
<
nsIFrame
*
>
*
aFrames
)
const
override
{
aFrames
-
>
AppendElements
(
mMergedFrames
)
;
}
virtual
bool
ShouldFlattenAway
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
true
;
}
virtual
bool
IsInvalid
(
nsRect
&
aRect
)
const
override
{
if
(
mFrame
-
>
IsInvalid
(
aRect
)
&
&
aRect
.
IsEmpty
(
)
)
{
return
true
;
}
nsRect
temp
;
for
(
uint32_t
i
=
0
;
i
<
mMergedFrames
.
Length
(
)
;
i
+
+
)
{
if
(
mMergedFrames
[
i
]
-
>
IsInvalid
(
temp
)
&
&
temp
.
IsEmpty
(
)
)
{
aRect
.
SetEmpty
(
)
;
return
true
;
}
aRect
=
aRect
.
Union
(
temp
)
;
}
aRect
+
=
ToReferenceFrame
(
)
;
return
!
aRect
.
IsEmpty
(
)
;
}
NS_DISPLAY_DECL_NAME
(
"
WrapList
"
TYPE_WRAP_LIST
)
virtual
nsRect
GetComponentAlphaBounds
(
nsDisplayListBuilder
*
aBuilder
)
const
override
;
virtual
nsDisplayList
*
GetSameCoordinateSystemChildren
(
)
const
override
{
NS_ASSERTION
(
mListPtr
-
>
IsEmpty
(
)
|
|
!
ReferenceFrame
(
)
|
|
!
mListPtr
-
>
GetBottom
(
)
-
>
ReferenceFrame
(
)
|
|
mListPtr
-
>
GetBottom
(
)
-
>
ReferenceFrame
(
)
=
=
ReferenceFrame
(
)
"
Children
must
have
same
reference
frame
"
)
;
return
mListPtr
;
}
virtual
nsDisplayList
*
GetChildren
(
)
const
override
{
return
mListPtr
;
}
virtual
int32_t
ZIndex
(
)
const
override
{
return
(
mHasZIndexOverride
)
?
mOverrideZIndex
:
nsDisplayItem
:
:
ZIndex
(
)
;
}
void
SetOverrideZIndex
(
int32_t
aZIndex
)
{
mHasZIndexOverride
=
true
;
mOverrideZIndex
=
aZIndex
;
}
void
SetVisibleRect
(
const
nsRect
&
aRect
)
;
void
SetReferenceFrame
(
const
nsIFrame
*
aFrame
)
;
virtual
nsDisplayWrapList
*
WrapWithClone
(
nsDisplayListBuilder
*
aBuilder
nsDisplayItem
*
aItem
)
{
NS_NOTREACHED
(
"
We
never
returned
nullptr
for
GetUnderlyingFrame
!
"
)
;
return
nullptr
;
}
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
protected
:
nsDisplayWrapList
(
)
=
delete
;
void
MergeFromTrackingMergedFrames
(
const
nsDisplayWrapList
*
aOther
)
{
mBounds
.
UnionRect
(
mBounds
aOther
-
>
mBounds
)
;
mVisibleRect
.
UnionRect
(
mVisibleRect
aOther
-
>
mVisibleRect
)
;
mMergedFrames
.
AppendElement
(
aOther
-
>
mFrame
)
;
mMergedFrames
.
AppendElements
(
aOther
-
>
mMergedFrames
)
;
}
nsDisplayList
mList
;
nsDisplayList
*
mListPtr
;
nsTArray
<
nsIFrame
*
>
mMergedFrames
;
nsRect
mBounds
;
nsRect
mBaseVisibleRect
;
int32_t
mOverrideZIndex
;
bool
mHasZIndexOverride
;
}
;
class
nsDisplayWrapper
{
public
:
virtual
bool
WrapBorderBackground
(
)
{
return
true
;
}
virtual
nsDisplayItem
*
WrapList
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
)
=
0
;
virtual
nsDisplayItem
*
WrapItem
(
nsDisplayListBuilder
*
aBuilder
nsDisplayItem
*
aItem
)
=
0
;
nsresult
WrapLists
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
nsDisplayListSet
&
aIn
const
nsDisplayListSet
&
aOut
)
;
nsresult
WrapListsInPlace
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
nsDisplayListSet
&
aLists
)
;
protected
:
nsDisplayWrapper
(
)
=
default
;
}
;
class
nsDisplayOpacity
:
public
nsDisplayWrapList
{
public
:
nsDisplayOpacity
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
ActiveScrolledRoot
*
aActiveScrolledRoot
bool
aForEventsAndPluginsOnly
)
;
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayOpacity
(
)
;
#
endif
virtual
nsDisplayWrapList
*
Clone
(
nsDisplayListBuilder
*
aBuilder
)
const
override
{
MOZ_COUNT_CTOR
(
nsDisplayOpacity
)
;
return
new
(
aBuilder
)
nsDisplayOpacity
(
*
this
)
;
}
virtual
nsRegion
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
;
virtual
bool
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
override
;
virtual
bool
CanMerge
(
const
nsDisplayItem
*
aItem
)
const
override
{
return
HasSameTypeAndClip
(
aItem
)
&
&
HasSameContent
(
aItem
)
;
}
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
{
}
virtual
bool
IsInvalid
(
nsRect
&
aRect
)
const
override
{
if
(
mForEventsAndPluginsOnly
)
{
return
false
;
}
return
nsDisplayWrapList
:
:
IsInvalid
(
aRect
)
;
}
virtual
void
ApplyOpacity
(
nsDisplayListBuilder
*
aBuilder
float
aOpacity
const
DisplayItemClipChain
*
aClip
)
override
;
virtual
bool
CanApplyOpacity
(
)
const
override
;
virtual
bool
ShouldFlattenAway
(
nsDisplayListBuilder
*
aBuilder
)
override
;
static
bool
NeedsActiveLayer
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
;
NS_DISPLAY_DECL_NAME
(
"
Opacity
"
TYPE_OPACITY
)
virtual
void
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
override
;
bool
CanUseAsyncAnimations
(
nsDisplayListBuilder
*
aBuilder
)
override
;
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
private
:
float
mOpacity
;
bool
mForEventsAndPluginsOnly
;
}
;
class
nsDisplayBlendMode
:
public
nsDisplayWrapList
{
public
:
nsDisplayBlendMode
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
uint8_t
aBlendMode
const
ActiveScrolledRoot
*
aActiveScrolledRoot
uint32_t
aIndex
=
0
)
;
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayBlendMode
(
)
;
#
endif
virtual
nsDisplayWrapList
*
Clone
(
nsDisplayListBuilder
*
aBuilder
)
const
override
{
MOZ_COUNT_CTOR
(
nsDisplayBlendMode
)
;
return
new
(
aBuilder
)
nsDisplayBlendMode
(
*
this
)
;
}
nsRegion
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
{
}
virtual
uint32_t
GetPerFrameKey
(
)
const
override
{
return
(
mIndex
<
<
TYPE_BITS
)
|
nsDisplayItem
:
:
GetPerFrameKey
(
)
;
}
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
;
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
virtual
bool
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
override
;
virtual
bool
CanMerge
(
const
nsDisplayItem
*
aItem
)
const
override
;
virtual
bool
ShouldFlattenAway
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
false
;
}
NS_DISPLAY_DECL_NAME
(
"
BlendMode
"
TYPE_BLEND_MODE
)
private
:
uint8_t
mBlendMode
;
uint32_t
mIndex
;
}
;
class
nsDisplayBlendContainer
:
public
nsDisplayWrapList
{
public
:
static
nsDisplayBlendContainer
*
CreateForMixBlendMode
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
ActiveScrolledRoot
*
aActiveScrolledRoot
)
;
static
nsDisplayBlendContainer
*
CreateForBackgroundBlendMode
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
ActiveScrolledRoot
*
aActiveScrolledRoot
)
;
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayBlendContainer
(
)
;
#
endif
virtual
nsDisplayWrapList
*
Clone
(
nsDisplayListBuilder
*
aBuilder
)
const
override
{
MOZ_COUNT_CTOR
(
nsDisplayBlendContainer
)
;
return
new
(
aBuilder
)
nsDisplayBlendContainer
(
*
this
)
;
}
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
;
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
virtual
bool
CanMerge
(
const
nsDisplayItem
*
aItem
)
const
override
{
return
HasSameTypeAndClip
(
aItem
)
&
&
HasSameContent
(
aItem
)
;
}
virtual
bool
ShouldFlattenAway
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
false
;
}
virtual
uint32_t
GetPerFrameKey
(
)
const
override
{
return
(
mIsForBackground
?
1
<
<
TYPE_BITS
:
0
)
|
nsDisplayItem
:
:
GetPerFrameKey
(
)
;
}
NS_DISPLAY_DECL_NAME
(
"
BlendContainer
"
TYPE_BLEND_CONTAINER
)
private
:
nsDisplayBlendContainer
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
ActiveScrolledRoot
*
aActiveScrolledRoot
bool
aIsForBackground
)
;
bool
mIsForBackground
;
}
;
class
nsDisplayOwnLayer
:
public
nsDisplayWrapList
{
public
:
typedef
mozilla
:
:
layers
:
:
ScrollThumbData
ScrollThumbData
;
enum
{
GENERATE_SUBDOC_INVALIDATIONS
=
0x01
VERTICAL_SCROLLBAR
=
0x02
HORIZONTAL_SCROLLBAR
=
0x04
GENERATE_SCROLLABLE_LAYER
=
0x08
SCROLLBAR_CONTAINER
=
0x10
}
;
nsDisplayOwnLayer
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
ActiveScrolledRoot
*
aActiveScrolledRoot
uint32_t
aFlags
=
0
ViewID
aScrollTarget
=
mozilla
:
:
layers
:
:
FrameMetrics
:
:
NULL_SCROLL_ID
const
ScrollThumbData
&
aThumbData
=
ScrollThumbData
{
}
bool
aForceActive
=
true
)
;
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayOwnLayer
(
)
;
#
endif
nsDisplayOwnLayer
(
const
nsDisplayOwnLayer
&
aOther
)
:
nsDisplayWrapList
(
aOther
)
mFlags
(
aOther
.
mFlags
)
mScrollTarget
(
aOther
.
mFlags
)
mThumbData
(
aOther
.
mThumbData
)
mForceActive
(
aOther
.
mForceActive
)
mWrAnimationId
(
aOther
.
mWrAnimationId
)
{
MOZ_COUNT_CTOR
(
nsDisplayOwnLayer
)
;
}
virtual
bool
ShouldBuildLayerEvenIfInvisible
(
nsDisplayListBuilder
*
aBuilder
)
const
override
;
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
virtual
bool
UpdateScrollData
(
mozilla
:
:
layers
:
:
WebRenderScrollData
*
aData
mozilla
:
:
layers
:
:
WebRenderLayerScrollData
*
aLayerData
)
override
;
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
;
virtual
bool
CanMerge
(
const
nsDisplayItem
*
aItem
)
const
override
{
return
false
;
}
virtual
bool
ShouldFlattenAway
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
false
;
}
uint32_t
GetFlags
(
)
{
return
mFlags
;
}
bool
IsScrollThumbLayer
(
)
const
;
NS_DISPLAY_DECL_NAME
(
"
OwnLayer
"
TYPE_OWN_LAYER
)
protected
:
uint32_t
mFlags
;
ViewID
mScrollTarget
;
ScrollThumbData
mThumbData
;
bool
mForceActive
;
uint64_t
mWrAnimationId
;
}
;
class
nsDisplaySubDocument
:
public
nsDisplayOwnLayer
{
public
:
nsDisplaySubDocument
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
uint32_t
aFlags
)
;
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplaySubDocument
(
)
;
#
endif
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
bool
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
override
;
virtual
bool
ShouldBuildLayerEvenIfInvisible
(
nsDisplayListBuilder
*
aBuilder
)
const
override
;
virtual
nsRegion
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
NS_DISPLAY_DECL_NAME
(
"
SubDocument
"
TYPE_SUBDOCUMENT
)
mozilla
:
:
UniquePtr
<
ScrollMetadata
>
ComputeScrollMetadata
(
Layer
*
aLayer
const
ContainerLayerParameters
&
aContainerParameters
)
;
protected
:
ViewID
mScrollParentId
;
bool
mForceDispatchToContentRegion
;
}
;
class
nsDisplayResolution
:
public
nsDisplaySubDocument
{
public
:
nsDisplayResolution
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
uint32_t
aFlags
)
;
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayResolution
(
)
;
#
endif
virtual
void
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
override
;
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
NS_DISPLAY_DECL_NAME
(
"
Resolution
"
TYPE_RESOLUTION
)
}
;
class
nsDisplayStickyPosition
:
public
nsDisplayOwnLayer
{
public
:
nsDisplayStickyPosition
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
ActiveScrolledRoot
*
aActiveScrolledRoot
)
;
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayStickyPosition
(
)
;
#
endif
void
SetClipChain
(
const
DisplayItemClipChain
*
aClipChain
)
override
;
virtual
nsDisplayWrapList
*
Clone
(
nsDisplayListBuilder
*
aBuilder
)
const
override
{
MOZ_COUNT_CTOR
(
nsDisplayStickyPosition
)
;
return
new
(
aBuilder
)
nsDisplayStickyPosition
(
*
this
)
;
}
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
NS_DISPLAY_DECL_NAME
(
"
StickyPosition
"
TYPE_STICKY_POSITION
)
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
{
return
mozilla
:
:
LAYER_ACTIVE
;
}
virtual
bool
CanMerge
(
const
nsDisplayItem
*
aItem
)
const
override
{
return
HasSameTypeAndClip
(
aItem
)
&
&
mFrame
=
=
aItem
-
>
Frame
(
)
;
}
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
}
;
class
nsDisplayFixedPosition
:
public
nsDisplayOwnLayer
{
public
:
nsDisplayFixedPosition
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
ActiveScrolledRoot
*
aActiveScrolledRoot
)
;
static
nsDisplayFixedPosition
*
CreateForFixedBackground
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayBackgroundImage
*
aImage
uint32_t
aIndex
)
;
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayFixedPosition
(
)
;
#
endif
virtual
nsDisplayWrapList
*
Clone
(
nsDisplayListBuilder
*
aBuilder
)
const
override
{
MOZ_COUNT_CTOR
(
nsDisplayFixedPosition
)
;
return
new
(
aBuilder
)
nsDisplayFixedPosition
(
*
this
)
;
}
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
NS_DISPLAY_DECL_NAME
(
"
FixedPosition
"
TYPE_FIXED_POSITION
)
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
{
return
mozilla
:
:
LAYER_ACTIVE_FORCE
;
}
virtual
bool
CanMerge
(
const
nsDisplayItem
*
aItem
)
const
override
{
return
HasSameTypeAndClip
(
aItem
)
&
&
mFrame
=
=
aItem
-
>
Frame
(
)
;
}
virtual
bool
ShouldFixToViewport
(
nsDisplayListBuilder
*
aBuilder
)
const
override
{
return
mIsFixedBackground
;
}
virtual
uint32_t
GetPerFrameKey
(
)
const
override
{
return
(
mIndex
<
<
TYPE_BITS
)
|
nsDisplayItem
:
:
GetPerFrameKey
(
)
;
}
AnimatedGeometryRoot
*
AnimatedGeometryRootForScrollMetadata
(
)
const
override
{
return
mAnimatedGeometryRootForScrollMetadata
;
}
virtual
bool
UpdateScrollData
(
mozilla
:
:
layers
:
:
WebRenderScrollData
*
aData
mozilla
:
:
layers
:
:
WebRenderLayerScrollData
*
aLayerData
)
override
;
protected
:
nsDisplayFixedPosition
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
uint32_t
aIndex
)
;
void
Init
(
nsDisplayListBuilder
*
aBuilder
)
;
AnimatedGeometryRoot
*
mAnimatedGeometryRootForScrollMetadata
;
uint32_t
mIndex
;
bool
mIsFixedBackground
;
}
;
class
nsDisplayTableFixedPosition
:
public
nsDisplayFixedPosition
{
public
:
static
nsDisplayTableFixedPosition
*
CreateForFixedBackground
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayBackgroundImage
*
aImage
uint32_t
aIndex
nsIFrame
*
aAncestorFrame
)
;
virtual
uint32_t
GetPerFrameKey
(
)
const
override
{
return
(
mIndex
<
<
(
TYPE_BITS
+
static_cast
<
uint8_t
>
(
TableTypeBits
:
:
COUNT
)
)
)
|
(
static_cast
<
uint8_t
>
(
mTableType
)
<
<
TYPE_BITS
)
|
nsDisplayItem
:
:
GetPerFrameKey
(
)
;
}
protected
:
nsDisplayTableFixedPosition
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
uint32_t
aIndex
nsIFrame
*
aAncestorFrame
)
;
TableType
mTableType
;
}
;
class
nsDisplayScrollInfoLayer
:
public
nsDisplayWrapList
{
public
:
nsDisplayScrollInfoLayer
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aScrolledFrame
nsIFrame
*
aScrollFrame
)
;
NS_DISPLAY_DECL_NAME
(
"
ScrollInfoLayer
"
TYPE_SCROLL_INFO_LAYER
)
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayScrollInfoLayer
(
)
;
#
endif
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
virtual
bool
ShouldBuildLayerEvenIfInvisible
(
nsDisplayListBuilder
*
aBuilder
)
const
override
{
return
true
;
}
virtual
nsRegion
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
{
*
aSnap
=
false
;
return
nsRegion
(
)
;
}
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
;
virtual
bool
ShouldFlattenAway
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
false
;
}
virtual
void
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
override
;
mozilla
:
:
UniquePtr
<
ScrollMetadata
>
ComputeScrollMetadata
(
Layer
*
aLayer
const
ContainerLayerParameters
&
aContainerParameters
)
;
virtual
bool
UpdateScrollData
(
mozilla
:
:
layers
:
:
WebRenderScrollData
*
aData
mozilla
:
:
layers
:
:
WebRenderLayerScrollData
*
aLayerData
)
override
;
protected
:
nsIFrame
*
mScrollFrame
;
nsIFrame
*
mScrolledFrame
;
ViewID
mScrollParentId
;
}
;
class
nsDisplayZoom
:
public
nsDisplaySubDocument
{
public
:
nsDisplayZoom
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
int32_t
aAPD
int32_t
aParentAPD
uint32_t
aFlags
=
0
)
;
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayZoom
(
)
;
#
endif
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
void
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
override
;
virtual
bool
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
override
;
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
{
return
mozilla
:
:
LAYER_ACTIVE
;
}
NS_DISPLAY_DECL_NAME
(
"
Zoom
"
TYPE_ZOOM
)
int32_t
GetChildAppUnitsPerDevPixel
(
)
{
return
mAPD
;
}
int32_t
GetParentAppUnitsPerDevPixel
(
)
{
return
mParentAPD
;
}
private
:
int32_t
mAPD
mParentAPD
;
}
;
class
nsDisplaySVGEffects
:
public
nsDisplayWrapList
{
public
:
nsDisplaySVGEffects
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
bool
aHandleOpacity
const
ActiveScrolledRoot
*
aActiveScrolledRoot
)
;
nsDisplaySVGEffects
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
bool
aHandleOpacity
)
;
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplaySVGEffects
(
)
;
#
endif
nsDisplaySVGEffects
(
const
nsDisplaySVGEffects
&
aOther
)
:
nsDisplayWrapList
(
aOther
)
mEffectsBounds
(
aOther
.
mEffectsBounds
)
mHandleOpacity
(
aOther
.
mHandleOpacity
)
{
MOZ_COUNT_CTOR
(
nsDisplaySVGEffects
)
;
}
virtual
nsRegion
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
void
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
override
;
virtual
bool
ShouldFlattenAway
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
false
;
}
gfxRect
BBoxInUserSpace
(
)
const
;
gfxPoint
UserSpaceOffset
(
)
const
;
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
;
protected
:
bool
ValidateSVGFrame
(
)
;
nsRect
mEffectsBounds
;
bool
mHandleOpacity
;
}
;
class
nsDisplayMask
:
public
nsDisplaySVGEffects
{
public
:
typedef
mozilla
:
:
layers
:
:
ImageLayer
ImageLayer
;
nsDisplayMask
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
bool
aHandleOpacity
const
ActiveScrolledRoot
*
aActiveScrolledRoot
)
;
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayMask
(
)
;
#
endif
virtual
nsDisplayWrapList
*
Clone
(
nsDisplayListBuilder
*
aBuilder
)
const
override
{
MOZ_COUNT_CTOR
(
nsDisplayMask
)
;
return
new
(
aBuilder
)
nsDisplayMask
(
*
this
)
;
}
NS_DISPLAY_DECL_NAME
(
"
Mask
"
TYPE_MASK
)
virtual
bool
CanMerge
(
const
nsDisplayItem
*
aItem
)
const
override
;
virtual
void
Merge
(
const
nsDisplayItem
*
aItem
)
override
{
nsDisplayWrapList
:
:
Merge
(
aItem
)
;
const
nsDisplayMask
*
other
=
static_cast
<
const
nsDisplayMask
*
>
(
aItem
)
;
mEffectsBounds
.
UnionRect
(
mEffectsBounds
other
-
>
mEffectsBounds
+
other
-
>
mFrame
-
>
GetOffsetTo
(
mFrame
)
)
;
}
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
;
virtual
bool
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
override
;
virtual
nsDisplayItemGeometry
*
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
new
nsDisplayMaskGeometry
(
this
aBuilder
)
;
}
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
;
#
ifdef
MOZ_DUMP_PAINTING
void
PrintEffects
(
nsACString
&
aTo
)
;
#
endif
void
PaintAsLayer
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
LayerManager
*
aManager
)
;
bool
PaintMask
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aMaskContext
)
;
const
nsTArray
<
nsRect
>
&
GetDestRects
(
)
{
return
mDestRects
;
}
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
private
:
bool
ShouldPaintOnMaskLayer
(
LayerManager
*
aManager
)
;
nsTArray
<
nsRect
>
mDestRects
;
}
;
class
nsDisplayFilter
:
public
nsDisplaySVGEffects
{
public
:
nsDisplayFilter
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
bool
aHandleOpacity
)
;
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayFilter
(
)
;
#
endif
virtual
nsDisplayWrapList
*
Clone
(
nsDisplayListBuilder
*
aBuilder
)
const
override
{
MOZ_COUNT_CTOR
(
nsDisplayFilter
)
;
return
new
(
aBuilder
)
nsDisplayFilter
(
*
this
)
;
}
NS_DISPLAY_DECL_NAME
(
"
Filter
"
TYPE_FILTER
)
virtual
bool
CanMerge
(
const
nsDisplayItem
*
aItem
)
const
override
{
return
HasSameTypeAndClip
(
aItem
)
&
&
HasSameContent
(
aItem
)
;
}
virtual
void
Merge
(
const
nsDisplayItem
*
aItem
)
override
{
nsDisplayWrapList
:
:
Merge
(
aItem
)
;
const
nsDisplayFilter
*
other
=
static_cast
<
const
nsDisplayFilter
*
>
(
aItem
)
;
mEffectsBounds
.
UnionRect
(
mEffectsBounds
other
-
>
mEffectsBounds
+
other
-
>
mFrame
-
>
GetOffsetTo
(
mFrame
)
)
;
}
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
;
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
{
*
aSnap
=
false
;
return
mEffectsBounds
+
ToReferenceFrame
(
)
;
}
virtual
bool
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
override
;
virtual
nsDisplayItemGeometry
*
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
new
nsDisplayFilterGeometry
(
this
aBuilder
)
;
}
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
;
#
ifdef
MOZ_DUMP_PAINTING
void
PrintEffects
(
nsACString
&
aTo
)
;
#
endif
void
PaintAsLayer
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
LayerManager
*
aManager
)
;
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
private
:
nsRect
mEffectsBounds
;
}
;
class
nsDisplayTransform
:
public
nsDisplayItem
{
typedef
mozilla
:
:
gfx
:
:
Matrix4x4
Matrix4x4
;
typedef
mozilla
:
:
gfx
:
:
Point3D
Point3D
;
class
StoreList
:
public
nsDisplayWrapList
{
public
:
StoreList
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
)
:
nsDisplayWrapList
(
aBuilder
aFrame
aList
)
{
}
StoreList
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayItem
*
aItem
)
:
nsDisplayWrapList
(
aBuilder
aFrame
aItem
)
{
}
virtual
~
StoreList
(
)
{
}
virtual
void
Destroy
(
nsDisplayListBuilder
*
aBuilder
)
override
{
mList
.
DeleteAll
(
aBuilder
)
;
}
virtual
void
UpdateBounds
(
nsDisplayListBuilder
*
aBuilder
)
override
{
if
(
!
mFrame
-
>
Extend3DContext
(
)
)
{
nsDisplayWrapList
:
:
UpdateBounds
(
aBuilder
)
;
}
}
virtual
void
DoUpdateBoundsPreserves3D
(
nsDisplayListBuilder
*
aBuilder
)
override
{
for
(
nsDisplayItem
*
i
=
mList
.
GetBottom
(
)
;
i
;
i
=
i
-
>
GetAbove
(
)
)
{
i
-
>
DoUpdateBoundsPreserves3D
(
aBuilder
)
;
}
nsDisplayWrapList
:
:
UpdateBounds
(
aBuilder
)
;
}
}
;
public
:
enum
PrerenderDecision
{
NoPrerender
FullPrerender
PartialPrerender
}
;
typedef
Matrix4x4
(
*
ComputeTransformFunction
)
(
nsIFrame
*
aFrame
float
aAppUnitsPerPixel
)
;
nsDisplayTransform
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
nsRect
&
aChildrenVisibleRect
uint32_t
aIndex
=
0
bool
aAllowAsyncAnimation
=
false
)
;
nsDisplayTransform
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayItem
*
aItem
const
nsRect
&
aChildrenVisibleRect
uint32_t
aIndex
=
0
)
;
nsDisplayTransform
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
nsRect
&
aChildrenVisibleRect
ComputeTransformFunction
aTransformGetter
uint32_t
aIndex
=
0
)
;
nsDisplayTransform
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
nsRect
&
aChildrenVisibleRect
const
Matrix4x4
&
aTransform
uint32_t
aIndex
=
0
)
;
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayTransform
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayTransform
)
;
}
#
endif
virtual
void
Destroy
(
nsDisplayListBuilder
*
aBuilder
)
override
{
mStoredList
.
Destroy
(
aBuilder
)
;
nsDisplayItem
:
:
Destroy
(
aBuilder
)
;
}
NS_DISPLAY_DECL_NAME
(
"
nsDisplayTransform
"
TYPE_TRANSFORM
)
virtual
nsRect
GetComponentAlphaBounds
(
nsDisplayListBuilder
*
aBuilder
)
const
override
{
if
(
mStoredList
.
GetComponentAlphaBounds
(
aBuilder
)
.
IsEmpty
(
)
)
return
nsRect
(
)
;
bool
snap
;
return
GetBounds
(
aBuilder
&
snap
)
;
}
virtual
nsDisplayList
*
GetChildren
(
)
const
override
{
return
mStoredList
.
GetChildren
(
)
;
}
virtual
void
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
override
;
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
nsRegion
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
mozilla
:
:
Maybe
<
nscolor
>
IsUniform
(
nsDisplayListBuilder
*
aBuilder
)
const
override
;
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
;
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
virtual
bool
UpdateScrollData
(
mozilla
:
:
layers
:
:
WebRenderScrollData
*
aData
mozilla
:
:
layers
:
:
WebRenderLayerScrollData
*
aLayerData
)
override
;
virtual
bool
ShouldBuildLayerEvenIfInvisible
(
nsDisplayListBuilder
*
aBuilder
)
const
override
;
virtual
bool
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
override
;
virtual
bool
CanMerge
(
const
nsDisplayItem
*
aItem
)
const
override
{
return
false
;
}
virtual
uint32_t
GetPerFrameKey
(
)
const
override
{
return
(
mIndex
<
<
TYPE_BITS
)
|
nsDisplayItem
:
:
GetPerFrameKey
(
)
;
}
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
{
}
virtual
const
nsIFrame
*
ReferenceFrameForChildren
(
)
const
override
{
if
(
!
mTransformGetter
)
{
return
mFrame
;
}
return
nsDisplayItem
:
:
ReferenceFrameForChildren
(
)
;
}
AnimatedGeometryRoot
*
AnimatedGeometryRootForScrollMetadata
(
)
const
override
{
return
mAnimatedGeometryRootForScrollMetadata
;
}
virtual
const
nsRect
&
GetVisibleRectForChildren
(
)
const
override
{
return
mChildrenVisibleRect
;
}
enum
{
INDEX_MAX
=
UINT32_MAX
>
>
TYPE_BITS
}
;
const
Matrix4x4
&
GetTransform
(
)
const
;
Matrix4x4
GetTransformForRendering
(
)
;
const
Matrix4x4
&
GetAccumulatedPreserved3DTransform
(
nsDisplayListBuilder
*
aBuilder
)
;
float
GetHitDepthAtPoint
(
nsDisplayListBuilder
*
aBuilder
const
nsPoint
&
aPoint
)
;
static
nsRect
TransformRect
(
const
nsRect
&
aUntransformedBounds
const
nsIFrame
*
aFrame
const
nsRect
*
aBoundsOverride
=
nullptr
)
;
static
bool
UntransformRect
(
const
nsRect
&
aTransformedBounds
const
nsRect
&
aChildBounds
const
nsIFrame
*
aFrame
nsRect
*
aOutRect
)
;
bool
UntransformVisibleRect
(
nsDisplayListBuilder
*
aBuilder
nsRect
*
aOutRect
)
const
;
static
Point3D
GetDeltaToTransformOrigin
(
const
nsIFrame
*
aFrame
float
aAppUnitsPerPixel
const
nsRect
*
aBoundsOverride
)
;
static
bool
ComputePerspectiveMatrix
(
const
nsIFrame
*
aFrame
float
aAppUnitsPerPixel
Matrix4x4
&
aOutMatrix
)
;
struct
FrameTransformProperties
{
FrameTransformProperties
(
const
nsIFrame
*
aFrame
float
aAppUnitsPerPixel
const
nsRect
*
aBoundsOverride
)
;
FrameTransformProperties
(
nsCSSValueSharedList
*
aTransformList
const
Point3D
&
aToTransformOrigin
)
:
mFrame
(
nullptr
)
mTransformList
(
aTransformList
)
mToTransformOrigin
(
aToTransformOrigin
)
{
}
const
nsIFrame
*
mFrame
;
RefPtr
<
nsCSSValueSharedList
>
mTransformList
;
const
Point3D
mToTransformOrigin
;
}
;
enum
{
OFFSET_BY_ORIGIN
=
1
<
<
0
INCLUDE_PRESERVE3D_ANCESTORS
=
1
<
<
1
INCLUDE_PERSPECTIVE
=
1
<
<
2
}
;
static
Matrix4x4
GetResultingTransformMatrix
(
const
nsIFrame
*
aFrame
const
nsPoint
&
aOrigin
float
aAppUnitsPerPixel
uint32_t
aFlags
const
nsRect
*
aBoundsOverride
=
nullptr
)
;
static
Matrix4x4
GetResultingTransformMatrix
(
const
FrameTransformProperties
&
aProperties
const
nsPoint
&
aOrigin
float
aAppUnitsPerPixel
uint32_t
aFlags
const
nsRect
*
aBoundsOverride
=
nullptr
)
;
static
PrerenderDecision
ShouldPrerenderTransformedContent
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsRect
*
aDirtyRect
)
;
bool
CanUseAsyncAnimations
(
nsDisplayListBuilder
*
aBuilder
)
override
;
bool
MayBeAnimated
(
nsDisplayListBuilder
*
aBuilder
)
const
;
virtual
void
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
override
;
void
SetNoExtendContext
(
)
{
mNoExtendContext
=
true
;
}
virtual
void
DoUpdateBoundsPreserves3D
(
nsDisplayListBuilder
*
aBuilder
)
override
{
MOZ_ASSERT
(
mFrame
-
>
Combines3DTransformWithAncestors
(
)
|
|
IsTransformSeparator
(
)
)
;
ComputeBounds
(
aBuilder
)
;
}
void
UpdateBoundsFor3D
(
nsDisplayListBuilder
*
aBuilder
)
{
if
(
!
mFrame
-
>
Extend3DContext
(
)
|
|
mFrame
-
>
Combines3DTransformWithAncestors
(
)
|
|
IsTransformSeparator
(
)
)
{
return
;
}
nsDisplayListBuilder
:
:
AutoAccumulateRect
accRect
(
aBuilder
)
;
nsDisplayListBuilder
:
:
AutoAccumulateTransform
accTransform
(
aBuilder
)
;
accTransform
.
StartRoot
(
)
;
ComputeBounds
(
aBuilder
)
;
mBounds
=
aBuilder
-
>
GetAccumulatedRect
(
)
;
mHasBounds
=
true
;
}
bool
IsTransformSeparator
(
)
{
return
mIsTransformSeparator
;
}
bool
IsLeafOf3DContext
(
)
{
return
(
IsTransformSeparator
(
)
|
|
(
!
mFrame
-
>
Extend3DContext
(
)
&
&
mFrame
-
>
Combines3DTransformWithAncestors
(
)
)
)
;
}
bool
IsParticipating3DContext
(
)
{
return
mFrame
-
>
Extend3DContext
(
)
|
|
mFrame
-
>
Combines3DTransformWithAncestors
(
)
;
}
private
:
void
ComputeBounds
(
nsDisplayListBuilder
*
aBuilder
)
;
void
SetReferenceFrameToAncestor
(
nsDisplayListBuilder
*
aBuilder
)
;
void
Init
(
nsDisplayListBuilder
*
aBuilder
)
;
static
Matrix4x4
GetResultingTransformMatrixInternal
(
const
FrameTransformProperties
&
aProperties
const
nsPoint
&
aOrigin
float
aAppUnitsPerPixel
uint32_t
aFlags
const
nsRect
*
aBoundsOverride
)
;
StoreList
mStoredList
;
mutable
Matrix4x4
mTransform
;
Matrix4x4
mTransformPreserves3D
;
ComputeTransformFunction
mTransformGetter
;
AnimatedGeometryRoot
*
mAnimatedGeometryRootForChildren
;
AnimatedGeometryRoot
*
mAnimatedGeometryRootForScrollMetadata
;
nsRect
mChildrenVisibleRect
;
uint32_t
mIndex
;
mutable
nsRect
mBounds
;
mutable
bool
mHasBounds
;
bool
mNoExtendContext
;
bool
mIsTransformSeparator
;
bool
mTransformPreserves3DInited
;
bool
mAllowAsyncAnimation
;
}
;
class
nsDisplayPerspective
:
public
nsDisplayItem
{
typedef
mozilla
:
:
gfx
:
:
Point3D
Point3D
;
public
:
NS_DISPLAY_DECL_NAME
(
"
nsDisplayPerspective
"
TYPE_PERSPECTIVE
)
nsDisplayPerspective
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aTransformFrame
nsIFrame
*
aPerspectiveFrame
nsDisplayList
*
aList
)
;
virtual
uint32_t
GetPerFrameKey
(
)
const
override
{
return
(
mIndex
<
<
TYPE_BITS
)
|
nsDisplayItem
:
:
GetPerFrameKey
(
)
;
}
virtual
void
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
override
{
return
mList
.
HitTest
(
aBuilder
aRect
aState
aOutFrames
)
;
}
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
{
return
mList
.
GetBounds
(
aBuilder
aSnap
)
;
}
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
{
}
virtual
nsRegion
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
{
return
mList
.
GetOpaqueRegion
(
aBuilder
aSnap
)
;
}
virtual
mozilla
:
:
Maybe
<
nscolor
>
IsUniform
(
nsDisplayListBuilder
*
aBuilder
)
const
override
{
return
mList
.
IsUniform
(
aBuilder
)
;
}
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
;
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
virtual
bool
ShouldBuildLayerEvenIfInvisible
(
nsDisplayListBuilder
*
aBuilder
)
const
override
{
if
(
!
mList
.
GetChildren
(
)
-
>
GetTop
(
)
)
{
return
false
;
}
return
mList
.
GetChildren
(
)
-
>
GetTop
(
)
-
>
ShouldBuildLayerEvenIfInvisible
(
aBuilder
)
;
}
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
virtual
bool
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
override
{
mList
.
RecomputeVisibility
(
aBuilder
aVisibleRegion
)
;
return
true
;
}
virtual
nsDisplayList
*
GetSameCoordinateSystemChildren
(
)
const
override
{
return
mList
.
GetChildren
(
)
;
}
virtual
nsDisplayList
*
GetChildren
(
)
const
override
{
return
mList
.
GetChildren
(
)
;
}
virtual
nsRect
GetComponentAlphaBounds
(
nsDisplayListBuilder
*
aBuilder
)
const
override
{
return
mList
.
GetComponentAlphaBounds
(
aBuilder
)
;
}
nsIFrame
*
TransformFrame
(
)
{
return
mTransformFrame
;
}
virtual
int32_t
ZIndex
(
)
const
override
;
virtual
void
DoUpdateBoundsPreserves3D
(
nsDisplayListBuilder
*
aBuilder
)
override
{
if
(
mList
.
GetChildren
(
)
-
>
GetTop
(
)
)
{
static_cast
<
nsDisplayTransform
*
>
(
mList
.
GetChildren
(
)
-
>
GetTop
(
)
)
-
>
DoUpdateBoundsPreserves3D
(
aBuilder
)
;
}
}
virtual
void
Destroy
(
nsDisplayListBuilder
*
aBuilder
)
override
{
mList
.
GetChildren
(
)
-
>
DeleteAll
(
aBuilder
)
;
nsDisplayItem
:
:
Destroy
(
aBuilder
)
;
}
private
:
nsDisplayWrapList
mList
;
nsIFrame
*
mTransformFrame
;
uint32_t
mIndex
;
}
;
class
nsCharClipDisplayItem
:
public
nsDisplayItem
{
public
:
nsCharClipDisplayItem
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
:
nsDisplayItem
(
aBuilder
aFrame
)
mVisIStartEdge
(
0
)
mVisIEndEdge
(
0
)
{
}
explicit
nsCharClipDisplayItem
(
nsIFrame
*
aFrame
)
:
nsDisplayItem
(
aFrame
)
mVisIStartEdge
(
0
)
mVisIEndEdge
(
0
)
{
}
virtual
nsDisplayItemGeometry
*
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
override
;
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
;
struct
ClipEdges
{
ClipEdges
(
const
nsDisplayItem
&
aItem
nscoord
aVisIStartEdge
nscoord
aVisIEndEdge
)
{
nsRect
r
=
aItem
.
Frame
(
)
-
>
GetScrollableOverflowRect
(
)
+
aItem
.
ToReferenceFrame
(
)
;
if
(
aItem
.
Frame
(
)
-
>
GetWritingMode
(
)
.
IsVertical
(
)
)
{
mVisIStart
=
aVisIStartEdge
>
0
?
r
.
y
+
aVisIStartEdge
:
nscoord_MIN
;
mVisIEnd
=
aVisIEndEdge
>
0
?
std
:
:
max
(
r
.
YMost
(
)
-
aVisIEndEdge
mVisIStart
)
:
nscoord_MAX
;
}
else
{
mVisIStart
=
aVisIStartEdge
>
0
?
r
.
x
+
aVisIStartEdge
:
nscoord_MIN
;
mVisIEnd
=
aVisIEndEdge
>
0
?
std
:
:
max
(
r
.
XMost
(
)
-
aVisIEndEdge
mVisIStart
)
:
nscoord_MAX
;
}
}
void
Intersect
(
nscoord
*
aVisIStart
nscoord
*
aVisISize
)
const
{
nscoord
end
=
*
aVisIStart
+
*
aVisISize
;
*
aVisIStart
=
std
:
:
max
(
*
aVisIStart
mVisIStart
)
;
*
aVisISize
=
std
:
:
max
(
std
:
:
min
(
end
mVisIEnd
)
-
*
aVisIStart
0
)
;
}
nscoord
mVisIStart
;
nscoord
mVisIEnd
;
}
;
ClipEdges
Edges
(
)
const
{
return
ClipEdges
(
*
this
mVisIStartEdge
mVisIEndEdge
)
;
}
static
nsCharClipDisplayItem
*
CheckCast
(
nsDisplayItem
*
aItem
)
{
DisplayItemType
t
=
aItem
-
>
GetType
(
)
;
return
(
t
=
=
DisplayItemType
:
:
TYPE_TEXT
)
?
static_cast
<
nsCharClipDisplayItem
*
>
(
aItem
)
:
nullptr
;
}
nscoord
mVisIStartEdge
;
nscoord
mVisIEndEdge
;
mutable
mozilla
:
:
Maybe
<
bool
>
mIsFrameSelected
;
}
;
namespace
mozilla
{
class
PaintTelemetry
{
public
:
enum
class
Metric
{
DisplayList
Layerization
Rasterization
COUNT
}
;
class
AutoRecord
{
public
:
explicit
AutoRecord
(
Metric
aMetric
)
;
~
AutoRecord
(
)
;
TimeStamp
GetStart
(
)
const
{
return
mStart
;
}
private
:
Metric
mMetric
;
mozilla
:
:
TimeStamp
mStart
;
}
;
class
AutoRecordPaint
{
public
:
AutoRecordPaint
(
)
;
~
AutoRecordPaint
(
)
;
private
:
mozilla
:
:
TimeStamp
mStart
;
}
;
private
:
static
uint32_t
sPaintLevel
;
static
uint32_t
sMetricLevel
;
static
mozilla
:
:
EnumeratedArray
<
Metric
Metric
:
:
COUNT
double
>
sMetrics
;
}
;
}
#
endif
