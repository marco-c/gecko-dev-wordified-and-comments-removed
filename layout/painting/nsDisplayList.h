#
ifndef
NSDISPLAYLIST_H_
#
define
NSDISPLAYLIST_H_
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
mozilla
/
ArenaAllocator
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Array
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
EnumSet
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
TemplateLib
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsPoint
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nsDisplayListInvalidation
.
h
"
#
include
"
DisplayItemClipChain
.
h
"
#
include
"
DisplayListClipState
.
h
"
#
include
"
LayerState
.
h
"
#
include
"
FrameMetrics
.
h
"
#
include
"
ImgDrawResult
.
h
"
#
include
"
mozilla
/
EnumeratedArray
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
gfx
/
UserData
.
h
"
#
include
"
mozilla
/
layers
/
LayerAttributes
.
h
"
#
include
"
nsCSSRenderingBorders
.
h
"
#
include
"
nsPresArena
.
h
"
#
include
"
nsAutoLayoutPhase
.
h
"
#
include
"
nsDisplayItemTypes
.
h
"
#
include
<
stdint
.
h
>
#
include
"
nsTHashtable
.
h
"
#
include
<
stdlib
.
h
>
#
include
<
algorithm
>
class
gfxContext
;
class
nsIContent
;
class
nsDisplayList
;
class
nsDisplayTableItem
;
class
nsISelection
;
class
nsIScrollableFrame
;
class
nsSubDocumentFrame
;
class
nsDisplayCompositorHitTestInfo
;
class
nsDisplayLayerEventRegions
;
class
nsDisplayScrollInfoLayer
;
class
nsCaret
;
enum
class
nsDisplayOwnLayerFlags
;
namespace
mozilla
{
class
FrameLayerBuilder
;
namespace
layers
{
class
Layer
;
class
ImageLayer
;
class
ImageContainer
;
class
StackingContextHelper
;
class
WebRenderCommand
;
class
WebRenderScrollData
;
class
WebRenderLayerScrollData
;
}
namespace
wr
{
class
DisplayListBuilder
;
}
}
typedef
mozilla
:
:
EnumSet
<
mozilla
:
:
gfx
:
:
CompositionOp
>
BlendModeSet
;
#
define
NS_DISPLAY_DECL_NAME
(
n
e
)
\
virtual
const
char
*
Name
(
)
const
override
{
return
n
;
}
\
virtual
DisplayItemType
GetType
(
)
const
override
{
return
DisplayItemType
:
:
e
;
}
\
private
:
\
void
*
operator
new
(
size_t
aSize
\
nsDisplayListBuilder
*
aBuilder
)
{
\
return
aBuilder
-
>
Allocate
(
aSize
DisplayItemType
:
:
e
)
;
\
}
\
template
<
typename
T
typename
.
.
.
Args
>
\
friend
T
*
:
:
MakeDisplayItem
(
nsDisplayListBuilder
*
aBuilder
Args
&
&
.
.
.
aArgs
)
;
\
public
:
struct
AnimatedGeometryRoot
{
static
already_AddRefed
<
AnimatedGeometryRoot
>
CreateAGRForFrame
(
nsIFrame
*
aFrame
AnimatedGeometryRoot
*
aParent
bool
aIsAsync
bool
aIsRetained
)
{
RefPtr
<
AnimatedGeometryRoot
>
result
;
if
(
aIsRetained
)
{
result
=
aFrame
-
>
GetProperty
(
AnimatedGeometryRootCache
(
)
)
;
}
if
(
result
)
{
result
-
>
mParentAGR
=
aParent
;
result
-
>
mIsAsync
=
aIsAsync
;
}
else
{
result
=
new
AnimatedGeometryRoot
(
aFrame
aParent
aIsAsync
aIsRetained
)
;
}
return
result
.
forget
(
)
;
}
operator
nsIFrame
*
(
)
{
return
mFrame
;
}
nsIFrame
*
operator
-
>
(
)
const
{
return
mFrame
;
}
AnimatedGeometryRoot
*
GetAsyncAGR
(
)
{
AnimatedGeometryRoot
*
agr
=
this
;
while
(
!
agr
-
>
mIsAsync
&
&
agr
-
>
mParentAGR
)
{
agr
=
agr
-
>
mParentAGR
;
}
return
agr
;
}
NS_INLINE_DECL_REFCOUNTING
(
AnimatedGeometryRoot
)
nsIFrame
*
mFrame
;
RefPtr
<
AnimatedGeometryRoot
>
mParentAGR
;
bool
mIsAsync
;
bool
mIsRetained
;
protected
:
static
void
DetachAGR
(
AnimatedGeometryRoot
*
aAGR
)
{
aAGR
-
>
mFrame
=
nullptr
;
aAGR
-
>
mParentAGR
=
nullptr
;
NS_RELEASE
(
aAGR
)
;
}
NS_DECLARE_FRAME_PROPERTY_WITH_DTOR
(
AnimatedGeometryRootCache
AnimatedGeometryRoot
DetachAGR
)
AnimatedGeometryRoot
(
nsIFrame
*
aFrame
AnimatedGeometryRoot
*
aParent
bool
aIsAsync
bool
aIsRetained
)
:
mFrame
(
aFrame
)
mParentAGR
(
aParent
)
mIsAsync
(
aIsAsync
)
mIsRetained
(
aIsRetained
)
{
MOZ_ASSERT
(
mParentAGR
|
|
mIsAsync
"
The
root
AGR
should
always
be
treated
as
an
async
AGR
.
"
)
;
if
(
mIsRetained
)
{
NS_ADDREF
(
this
)
;
aFrame
-
>
SetProperty
(
AnimatedGeometryRootCache
(
)
this
)
;
}
}
~
AnimatedGeometryRoot
(
)
{
if
(
mFrame
&
&
mIsRetained
)
{
mFrame
-
>
DeleteProperty
(
AnimatedGeometryRootCache
(
)
)
;
}
}
}
;
namespace
mozilla
{
struct
ActiveScrolledRoot
{
static
already_AddRefed
<
ActiveScrolledRoot
>
CreateASRForFrame
(
const
ActiveScrolledRoot
*
aParent
nsIScrollableFrame
*
aScrollableFrame
bool
aIsRetained
)
{
nsIFrame
*
f
=
do_QueryFrame
(
aScrollableFrame
)
;
RefPtr
<
ActiveScrolledRoot
>
asr
;
if
(
aIsRetained
)
{
asr
=
f
-
>
GetProperty
(
ActiveScrolledRootCache
(
)
)
;
}
if
(
!
asr
)
{
asr
=
new
ActiveScrolledRoot
(
)
;
if
(
aIsRetained
)
{
RefPtr
<
ActiveScrolledRoot
>
ref
=
asr
;
f
-
>
SetProperty
(
ActiveScrolledRootCache
(
)
ref
.
forget
(
)
.
take
(
)
)
;
}
}
asr
-
>
mParent
=
aParent
;
asr
-
>
mScrollableFrame
=
aScrollableFrame
;
asr
-
>
mViewId
=
Nothing
(
)
;
asr
-
>
mDepth
=
aParent
?
aParent
-
>
mDepth
+
1
:
1
;
asr
-
>
mRetained
=
aIsRetained
;
return
asr
.
forget
(
)
;
}
static
const
ActiveScrolledRoot
*
PickAncestor
(
const
ActiveScrolledRoot
*
aOne
const
ActiveScrolledRoot
*
aTwo
)
{
MOZ_ASSERT
(
IsAncestor
(
aOne
aTwo
)
|
|
IsAncestor
(
aTwo
aOne
)
)
;
return
Depth
(
aOne
)
<
=
Depth
(
aTwo
)
?
aOne
:
aTwo
;
}
static
const
ActiveScrolledRoot
*
PickDescendant
(
const
ActiveScrolledRoot
*
aOne
const
ActiveScrolledRoot
*
aTwo
)
{
MOZ_ASSERT
(
IsAncestor
(
aOne
aTwo
)
|
|
IsAncestor
(
aTwo
aOne
)
)
;
return
Depth
(
aOne
)
>
=
Depth
(
aTwo
)
?
aOne
:
aTwo
;
}
static
bool
IsAncestor
(
const
ActiveScrolledRoot
*
aAncestor
const
ActiveScrolledRoot
*
aDescendant
)
;
static
nsCString
ToString
(
const
mozilla
:
:
ActiveScrolledRoot
*
aActiveScrolledRoot
)
;
void
IncrementDepth
(
)
{
mDepth
+
+
;
}
mozilla
:
:
layers
:
:
FrameMetrics
:
:
ViewID
GetViewId
(
)
const
{
if
(
!
mViewId
.
isSome
(
)
)
{
nsIContent
*
content
=
mScrollableFrame
-
>
GetScrolledFrame
(
)
-
>
GetContent
(
)
;
mViewId
=
Some
(
nsLayoutUtils
:
:
FindOrCreateIDFor
(
content
)
)
;
}
return
*
mViewId
;
}
RefPtr
<
const
ActiveScrolledRoot
>
mParent
;
nsIScrollableFrame
*
mScrollableFrame
;
NS_INLINE_DECL_REFCOUNTING
(
ActiveScrolledRoot
)
private
:
ActiveScrolledRoot
(
)
{
}
~
ActiveScrolledRoot
(
)
{
if
(
mScrollableFrame
&
&
mRetained
)
{
nsIFrame
*
f
=
do_QueryFrame
(
mScrollableFrame
)
;
f
-
>
DeleteProperty
(
ActiveScrolledRootCache
(
)
)
;
}
}
static
void
DetachASR
(
ActiveScrolledRoot
*
aASR
)
{
aASR
-
>
mParent
=
nullptr
;
aASR
-
>
mScrollableFrame
=
nullptr
;
NS_RELEASE
(
aASR
)
;
}
NS_DECLARE_FRAME_PROPERTY_WITH_DTOR
(
ActiveScrolledRootCache
ActiveScrolledRoot
DetachASR
)
static
uint32_t
Depth
(
const
ActiveScrolledRoot
*
aActiveScrolledRoot
)
{
return
aActiveScrolledRoot
?
aActiveScrolledRoot
-
>
mDepth
:
0
;
}
mutable
Maybe
<
mozilla
:
:
layers
:
:
FrameMetrics
:
:
ViewID
>
mViewId
;
uint32_t
mDepth
;
bool
mRetained
;
}
;
}
enum
class
nsDisplayListBuilderMode
:
uint8_t
{
PAINTING
EVENT_DELIVERY
PLUGIN_GEOMETRY
FRAME_VISIBILITY
TRANSFORM_COMPUTATION
GENERATE_GLYPH
PAINTING_SELECTION_BACKGROUND
}
;
class
nsDisplayListBuilder
{
typedef
mozilla
:
:
LayoutDeviceIntRect
LayoutDeviceIntRect
;
typedef
mozilla
:
:
LayoutDeviceIntRegion
LayoutDeviceIntRegion
;
class
Preserves3DContext
{
public
:
typedef
mozilla
:
:
gfx
:
:
Matrix4x4
Matrix4x4
;
Preserves3DContext
(
)
:
mAccumulatedRectLevels
(
0
)
{
}
Preserves3DContext
(
const
Preserves3DContext
&
aOther
)
:
mAccumulatedTransform
(
)
mAccumulatedRect
(
)
mAccumulatedRectLevels
(
0
)
mVisibleRect
(
aOther
.
mVisibleRect
)
{
}
Matrix4x4
mAccumulatedTransform
;
nsRect
mAccumulatedRect
;
int
mAccumulatedRectLevels
;
nsRect
mVisibleRect
;
}
;
enum
AGRState
{
AGR_NO
AGR_YES
AGR_MAYBE
}
;
public
:
typedef
mozilla
:
:
FrameLayerBuilder
FrameLayerBuilder
;
typedef
mozilla
:
:
DisplayItemClip
DisplayItemClip
;
typedef
mozilla
:
:
DisplayItemClipChain
DisplayItemClipChain
;
typedef
mozilla
:
:
DisplayItemClipChainHasher
DisplayItemClipChainHasher
;
typedef
mozilla
:
:
DisplayItemClipChainEqualer
DisplayItemClipChainEqualer
;
typedef
mozilla
:
:
DisplayListClipState
DisplayListClipState
;
typedef
mozilla
:
:
ActiveScrolledRoot
ActiveScrolledRoot
;
typedef
nsIWidget
:
:
ThemeGeometry
ThemeGeometry
;
typedef
mozilla
:
:
layers
:
:
Layer
Layer
;
typedef
mozilla
:
:
layers
:
:
FrameMetrics
FrameMetrics
;
typedef
mozilla
:
:
layers
:
:
FrameMetrics
:
:
ViewID
ViewID
;
typedef
mozilla
:
:
gfx
:
:
Matrix4x4
Matrix4x4
;
nsDisplayListBuilder
(
nsIFrame
*
aReferenceFrame
nsDisplayListBuilderMode
aMode
bool
aBuildCaret
bool
aRetainingDisplayList
=
false
)
;
~
nsDisplayListBuilder
(
)
;
void
BeginFrame
(
)
;
void
EndFrame
(
)
;
void
AddTemporaryItem
(
nsDisplayItem
*
aItem
)
{
mTemporaryItems
.
AppendElement
(
aItem
)
;
}
void
SetWillComputePluginGeometry
(
bool
aWillComputePluginGeometry
)
{
mWillComputePluginGeometry
=
aWillComputePluginGeometry
;
}
void
SetForPluginGeometry
(
bool
aForPlugin
)
{
if
(
aForPlugin
)
{
NS_ASSERTION
(
mMode
=
=
nsDisplayListBuilderMode
:
:
PAINTING
"
Can
only
switch
from
PAINTING
to
PLUGIN_GEOMETRY
"
)
;
NS_ASSERTION
(
mWillComputePluginGeometry
"
Should
have
signalled
this
in
advance
"
)
;
mMode
=
nsDisplayListBuilderMode
:
:
PLUGIN_GEOMETRY
;
}
else
{
NS_ASSERTION
(
mMode
=
=
nsDisplayListBuilderMode
:
:
PLUGIN_GEOMETRY
"
Can
only
switch
from
PAINTING
to
PLUGIN_GEOMETRY
"
)
;
mMode
=
nsDisplayListBuilderMode
:
:
PAINTING
;
}
}
mozilla
:
:
layers
:
:
LayerManager
*
GetWidgetLayerManager
(
nsView
*
*
aView
=
nullptr
)
;
bool
IsForEventDelivery
(
)
{
return
mMode
=
=
nsDisplayListBuilderMode
:
:
EVENT_DELIVERY
;
}
bool
IsForPluginGeometry
(
)
{
return
mMode
=
=
nsDisplayListBuilderMode
:
:
PLUGIN_GEOMETRY
;
}
bool
IsForPainting
(
)
{
return
mMode
=
=
nsDisplayListBuilderMode
:
:
PAINTING
;
}
bool
IsForFrameVisibility
(
)
{
return
mMode
=
=
nsDisplayListBuilderMode
:
:
FRAME_VISIBILITY
;
}
bool
IsForGenerateGlyphMask
(
)
{
return
mMode
=
=
nsDisplayListBuilderMode
:
:
GENERATE_GLYPH
;
}
bool
IsForPaintingSelectionBG
(
)
{
return
mMode
=
=
nsDisplayListBuilderMode
:
:
PAINTING_SELECTION_BACKGROUND
;
}
bool
BuildCompositorHitTestInfo
(
)
{
return
mBuildCompositorHitTestInfo
;
}
bool
WillComputePluginGeometry
(
)
{
return
mWillComputePluginGeometry
;
}
bool
IsBackgroundOnly
(
)
{
NS_ASSERTION
(
mPresShellStates
.
Length
(
)
>
0
"
don
'
t
call
this
if
we
'
re
not
in
a
presshell
"
)
;
return
CurrentPresShellState
(
)
-
>
mIsBackgroundOnly
;
}
bool
IsAtRootOfPseudoStackingContext
(
)
{
return
mIsAtRootOfPseudoStackingContext
;
}
nsISelection
*
GetBoundingSelection
(
)
{
return
mBoundingSelection
;
}
const
nsIFrame
*
FindReferenceFrameFor
(
const
nsIFrame
*
aFrame
nsPoint
*
aOffset
=
nullptr
)
const
;
nsIFrame
*
RootReferenceFrame
(
)
{
return
mReferenceFrame
;
}
const
nsPoint
ToReferenceFrame
(
const
nsIFrame
*
aFrame
)
const
{
nsPoint
result
;
FindReferenceFrameFor
(
aFrame
&
result
)
;
return
result
;
}
void
SetIgnoreScrollFrame
(
nsIFrame
*
aFrame
)
{
mIgnoreScrollFrame
=
aFrame
;
}
nsIFrame
*
GetIgnoreScrollFrame
(
)
{
return
mIgnoreScrollFrame
;
}
ViewID
GetCurrentScrollParentId
(
)
const
{
return
mCurrentScrollParentId
;
}
void
ForceLayerForScrollParent
(
)
{
mForceLayerForScrollParent
=
true
;
}
ViewID
GetCurrentScrollbarTarget
(
)
const
{
return
mCurrentScrollbarTarget
;
}
nsDisplayOwnLayerFlags
GetCurrentScrollbarFlags
(
)
const
{
return
mCurrentScrollbarFlags
;
}
bool
IsBuildingNonLayerizedScrollbar
(
)
const
{
return
mIsBuildingScrollbar
&
&
!
mCurrentScrollbarWillHaveLayer
;
}
void
SetIncludeAllOutOfFlows
(
)
{
mIncludeAllOutOfFlows
=
true
;
}
bool
GetIncludeAllOutOfFlows
(
)
const
{
return
mIncludeAllOutOfFlows
;
}
void
SetSelectedFramesOnly
(
)
{
mSelectedFramesOnly
=
true
;
}
bool
GetSelectedFramesOnly
(
)
{
return
mSelectedFramesOnly
;
}
bool
GetAccurateVisibleRegions
(
)
{
return
mMode
=
=
nsDisplayListBuilderMode
:
:
PLUGIN_GEOMETRY
;
}
bool
IsBuildingCaret
(
)
const
{
return
mBuildCaret
;
}
bool
IsRetainingDisplayList
(
)
const
{
return
mRetainingDisplayList
;
}
bool
IsPartialUpdate
(
)
const
{
return
mPartialUpdate
;
}
void
SetPartialUpdate
(
bool
aPartial
)
{
mPartialUpdate
=
aPartial
;
}
bool
IsBuilding
(
)
const
{
return
mIsBuilding
;
}
void
SetIsBuilding
(
bool
aIsBuilding
)
{
mIsBuilding
=
aIsBuilding
;
for
(
nsIFrame
*
f
:
mModifiedFramesDuringBuilding
)
{
f
-
>
SetFrameIsModified
(
false
)
;
}
mModifiedFramesDuringBuilding
.
Clear
(
)
;
}
bool
InInvalidSubtree
(
)
const
{
return
mInInvalidSubtree
;
}
void
IgnorePaintSuppression
(
)
{
mIgnoreSuppression
=
true
;
}
bool
IsIgnoringPaintSuppression
(
)
{
return
mIgnoreSuppression
;
}
void
SetPaintingToWindow
(
bool
aToWindow
)
{
mIsPaintingToWindow
=
aToWindow
;
}
bool
IsPaintingToWindow
(
)
const
{
return
mIsPaintingToWindow
;
}
void
SetDescendIntoSubdocuments
(
bool
aDescend
)
{
mDescendIntoSubdocuments
=
aDescend
;
}
bool
GetDescendIntoSubdocuments
(
)
{
return
mDescendIntoSubdocuments
;
}
const
nsRect
&
GetVisibleRect
(
)
{
return
mVisibleRect
;
}
const
nsRect
&
GetDirtyRect
(
)
{
return
mDirtyRect
;
}
void
SetVisibleRect
(
const
nsRect
&
aVisibleRect
)
{
mVisibleRect
=
aVisibleRect
;
}
void
IntersectVisibleRect
(
const
nsRect
&
aVisibleRect
)
{
mVisibleRect
.
IntersectRect
(
mVisibleRect
aVisibleRect
)
;
}
void
SetDirtyRect
(
const
nsRect
&
aDirtyRect
)
{
mDirtyRect
=
aDirtyRect
;
}
void
IntersectDirtyRect
(
const
nsRect
&
aDirtyRect
)
{
mDirtyRect
.
IntersectRect
(
mDirtyRect
aDirtyRect
)
;
}
const
nsIFrame
*
GetCurrentFrame
(
)
{
return
mCurrentFrame
;
}
const
nsIFrame
*
GetCurrentReferenceFrame
(
)
{
return
mCurrentReferenceFrame
;
}
const
nsPoint
&
GetCurrentFrameOffsetToReferenceFrame
(
)
{
return
mCurrentOffsetToReferenceFrame
;
}
AnimatedGeometryRoot
*
GetCurrentAnimatedGeometryRoot
(
)
{
return
mCurrentAGR
;
}
AnimatedGeometryRoot
*
GetRootAnimatedGeometryRoot
(
)
{
return
mRootAGR
;
}
void
RecomputeCurrentAnimatedGeometryRoot
(
)
;
void
Check
(
)
{
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
mPool
.
Check
(
)
;
#
endif
}
bool
AllowMergingAndFlattening
(
)
{
return
mAllowMergingAndFlattening
;
}
void
SetAllowMergingAndFlattening
(
bool
aAllow
)
{
mAllowMergingAndFlattening
=
aAllow
;
}
nsDisplayLayerEventRegions
*
GetLayerEventRegions
(
)
{
return
mLayerEventRegions
;
}
void
SetLayerEventRegions
(
nsDisplayLayerEventRegions
*
aItem
)
{
mLayerEventRegions
=
aItem
;
}
void
SetCompositorHitTestInfo
(
nsDisplayCompositorHitTestInfo
*
aHitTestInfo
)
{
mCompositorHitTestInfo
=
aHitTestInfo
;
}
void
BuildCompositorHitTestInfoIfNeeded
(
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
bool
aBuildNew
)
;
bool
IsBuildingLayerEventRegions
(
)
;
static
bool
LayerEventRegionsEnabled
(
)
;
bool
IsInsidePointerEventsNoneDoc
(
)
{
return
CurrentPresShellState
(
)
-
>
mInsidePointerEventsNoneDoc
;
}
bool
GetAncestorHasApzAwareEventHandler
(
)
const
{
return
mAncestorHasApzAwareEventHandler
;
}
void
SetAncestorHasApzAwareEventHandler
(
bool
aValue
)
{
mAncestorHasApzAwareEventHandler
=
aValue
;
}
bool
HaveScrollableDisplayPort
(
)
const
{
return
mHaveScrollableDisplayPort
;
}
void
SetHaveScrollableDisplayPort
(
)
{
mHaveScrollableDisplayPort
=
true
;
}
void
ClearHaveScrollableDisplayPort
(
)
{
mHaveScrollableDisplayPort
=
false
;
}
bool
SetIsCompositingCheap
(
bool
aCompositingCheap
)
{
bool
temp
=
mIsCompositingCheap
;
mIsCompositingCheap
=
aCompositingCheap
;
return
temp
;
}
bool
IsCompositingCheap
(
)
const
{
return
mIsCompositingCheap
;
}
bool
DisplayCaret
(
nsIFrame
*
aFrame
nsDisplayList
*
aList
)
{
nsIFrame
*
frame
=
GetCaretFrame
(
)
;
if
(
aFrame
=
=
frame
)
{
frame
-
>
DisplayCaret
(
this
aList
)
;
return
true
;
}
return
false
;
}
nsIFrame
*
GetCaretFrame
(
)
{
return
CurrentPresShellState
(
)
-
>
mCaretFrame
;
}
const
nsRect
&
GetCaretRect
(
)
{
return
CurrentPresShellState
(
)
-
>
mCaretRect
;
}
nsCaret
*
GetCaret
(
)
;
void
EnterPresShell
(
nsIFrame
*
aReferenceFrame
bool
aPointerEventsNoneDoc
=
false
)
;
void
ResetMarkedFramesForDisplayList
(
nsIFrame
*
aReferenceFrame
)
;
void
LeavePresShell
(
nsIFrame
*
aReferenceFrame
nsDisplayList
*
aPaintedContents
)
;
void
IncrementPresShellPaintCount
(
nsIPresShell
*
aPresShell
)
;
bool
IsInTransform
(
)
const
{
return
mInTransform
;
}
void
SetInTransform
(
bool
aInTransform
)
{
mInTransform
=
aInTransform
;
}
bool
IsInSubdocument
(
)
{
return
mPresShellStates
.
Length
(
)
>
1
;
}
bool
IsInChromeDocumentOrPopup
(
)
{
return
mIsInChromePresContext
|
|
mIsBuildingForPopup
;
}
bool
ShouldSyncDecodeImages
(
)
{
return
mSyncDecodeImages
;
}
void
SetSyncDecodeImages
(
bool
aSyncDecodeImages
)
{
mSyncDecodeImages
=
aSyncDecodeImages
;
}
void
FreeClipChains
(
)
;
void
FreeTemporaryItems
(
)
;
uint32_t
GetBackgroundPaintFlags
(
)
;
void
SubtractFromVisibleRegion
(
nsRegion
*
aVisibleRegion
const
nsRegion
&
aRegion
)
;
void
MarkFramesForDisplayList
(
nsIFrame
*
aDirtyFrame
const
nsFrameList
&
aFrames
)
;
void
MarkFrameForDisplay
(
nsIFrame
*
aFrame
nsIFrame
*
aStopAtFrame
)
;
void
MarkFrameForDisplayIfVisible
(
nsIFrame
*
aFrame
nsIFrame
*
aStopAtFrame
)
;
void
ClearFixedBackgroundDisplayData
(
)
;
void
MarkPreserve3DFramesForDisplayList
(
nsIFrame
*
aDirtyFrame
)
;
bool
ShouldDescendIntoFrame
(
nsIFrame
*
aFrame
bool
aVisible
)
const
{
return
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO
)
|
|
(
aVisible
&
&
aFrame
-
>
ForceDescendIntoIfVisible
(
)
)
|
|
GetIncludeAllOutOfFlows
(
)
;
}
nsTArray
<
ThemeGeometry
>
GetThemeGeometries
(
)
const
{
nsTArray
<
ThemeGeometry
>
geometries
;
for
(
auto
iter
=
mThemeGeometries
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
geometries
.
AppendElements
(
*
iter
.
Data
(
)
)
;
}
return
geometries
;
}
void
RegisterThemeGeometry
(
uint8_t
aWidgetType
nsDisplayItem
*
aItem
const
mozilla
:
:
LayoutDeviceIntRect
&
aRect
)
{
if
(
!
mIsPaintingToWindow
)
{
return
;
}
nsTArray
<
ThemeGeometry
>
*
geometries
=
mThemeGeometries
.
LookupOrAdd
(
aItem
)
;
geometries
-
>
AppendElement
(
ThemeGeometry
(
aWidgetType
aRect
)
)
;
}
void
UnregisterThemeGeometry
(
nsDisplayItem
*
aItem
)
{
mThemeGeometries
.
Remove
(
aItem
)
;
}
void
AdjustWindowDraggingRegion
(
nsIFrame
*
aFrame
)
;
LayoutDeviceIntRegion
GetWindowDraggingRegion
(
)
const
;
void
RemoveModifiedWindowRegions
(
)
;
void
ClearRetainedWindowRegions
(
)
;
void
*
Allocate
(
size_t
aSize
DisplayItemType
aType
)
;
void
Destroy
(
DisplayItemType
aType
void
*
aPtr
)
;
ActiveScrolledRoot
*
AllocateActiveScrolledRoot
(
const
ActiveScrolledRoot
*
aParent
nsIScrollableFrame
*
aScrollableFrame
)
;
const
DisplayItemClipChain
*
AllocateDisplayItemClipChain
(
const
DisplayItemClip
&
aClip
const
ActiveScrolledRoot
*
aASR
const
DisplayItemClipChain
*
aParent
)
;
const
DisplayItemClipChain
*
CreateClipChainIntersection
(
const
DisplayItemClipChain
*
aAncestor
const
DisplayItemClipChain
*
aLeafClip1
const
DisplayItemClipChain
*
aLeafClip2
)
;
const
DisplayItemClipChain
*
CopyWholeChain
(
const
DisplayItemClipChain
*
aClipChain
)
;
void
SetActiveScrolledRootForRootScrollframe
(
const
ActiveScrolledRoot
*
aASR
)
{
mActiveScrolledRootForRootScrollframe
=
aASR
;
}
const
ActiveScrolledRoot
*
ActiveScrolledRootForRootScrollframe
(
)
const
{
return
mActiveScrolledRootForRootScrollframe
;
}
static
void
AddAnimationsAndTransitionsToLayer
(
Layer
*
aLayer
nsDisplayListBuilder
*
aBuilder
nsDisplayItem
*
aItem
nsIFrame
*
aFrame
nsCSSPropertyID
aProperty
)
;
nsDisplayItem
*
MergeItems
(
nsTArray
<
nsDisplayItem
*
>
&
aMergedItems
)
;
class
AutoBuildingDisplayList
{
public
:
AutoBuildingDisplayList
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aForChild
const
nsRect
&
aVisibleRect
const
nsRect
&
aDirtyRect
bool
aIsRoot
)
:
mBuilder
(
aBuilder
)
mPrevFrame
(
aBuilder
-
>
mCurrentFrame
)
mPrevReferenceFrame
(
aBuilder
-
>
mCurrentReferenceFrame
)
mPrevLayerEventRegions
(
aBuilder
-
>
mLayerEventRegions
)
mPrevCompositorHitTestInfo
(
aBuilder
-
>
mCompositorHitTestInfo
)
mPrevOffset
(
aBuilder
-
>
mCurrentOffsetToReferenceFrame
)
mPrevVisibleRect
(
aBuilder
-
>
mVisibleRect
)
mPrevDirtyRect
(
aBuilder
-
>
mDirtyRect
)
mPrevAGR
(
aBuilder
-
>
mCurrentAGR
)
mPrevIsAtRootOfPseudoStackingContext
(
aBuilder
-
>
mIsAtRootOfPseudoStackingContext
)
mPrevAncestorHasApzAwareEventHandler
(
aBuilder
-
>
mAncestorHasApzAwareEventHandler
)
mPrevBuildingInvisibleItems
(
aBuilder
-
>
mBuildingInvisibleItems
)
mPrevInInvalidSubtree
(
aBuilder
-
>
mInInvalidSubtree
)
{
if
(
aForChild
-
>
IsTransformed
(
)
)
{
aBuilder
-
>
mCurrentOffsetToReferenceFrame
=
nsPoint
(
)
;
aBuilder
-
>
mCurrentReferenceFrame
=
aForChild
;
}
else
if
(
aBuilder
-
>
mCurrentFrame
=
=
aForChild
-
>
GetParent
(
)
)
{
aBuilder
-
>
mCurrentOffsetToReferenceFrame
+
=
aForChild
-
>
GetPosition
(
)
;
}
else
{
aBuilder
-
>
mCurrentReferenceFrame
=
aBuilder
-
>
FindReferenceFrameFor
(
aForChild
&
aBuilder
-
>
mCurrentOffsetToReferenceFrame
)
;
}
bool
isAsync
;
mCurrentAGRState
=
aBuilder
-
>
IsAnimatedGeometryRoot
(
aForChild
isAsync
)
;
if
(
aBuilder
-
>
mCurrentFrame
=
=
aForChild
-
>
GetParent
(
)
)
{
if
(
mCurrentAGRState
=
=
AGR_YES
)
{
aBuilder
-
>
mCurrentAGR
=
aBuilder
-
>
WrapAGRForFrame
(
aForChild
isAsync
aBuilder
-
>
mCurrentAGR
)
;
}
}
else
if
(
aForChild
!
=
aBuilder
-
>
mCurrentFrame
)
{
aBuilder
-
>
mCurrentAGR
=
aBuilder
-
>
FindAnimatedGeometryRootFor
(
aForChild
)
;
}
MOZ_ASSERT
(
nsLayoutUtils
:
:
IsAncestorFrameCrossDoc
(
aBuilder
-
>
RootReferenceFrame
(
)
*
aBuilder
-
>
mCurrentAGR
)
)
;
aBuilder
-
>
mCurrentFrame
=
aForChild
;
aBuilder
-
>
mVisibleRect
=
aVisibleRect
;
aBuilder
-
>
mDirtyRect
=
aDirtyRect
;
aBuilder
-
>
mIsAtRootOfPseudoStackingContext
=
aIsRoot
;
aBuilder
-
>
mInInvalidSubtree
=
aBuilder
-
>
mInInvalidSubtree
|
|
aForChild
-
>
IsFrameModified
(
)
;
}
void
SetReferenceFrameAndCurrentOffset
(
const
nsIFrame
*
aFrame
const
nsPoint
&
aOffset
)
{
mBuilder
-
>
mCurrentReferenceFrame
=
aFrame
;
mBuilder
-
>
mCurrentOffsetToReferenceFrame
=
aOffset
;
}
bool
IsAnimatedGeometryRoot
(
)
const
{
return
mCurrentAGRState
=
=
AGR_YES
;
}
bool
MaybeAnimatedGeometryRoot
(
)
const
{
return
mCurrentAGRState
=
=
AGR_MAYBE
;
}
void
RestoreBuildingInvisibleItemsValue
(
)
{
mBuilder
-
>
mBuildingInvisibleItems
=
mPrevBuildingInvisibleItems
;
}
~
AutoBuildingDisplayList
(
)
{
mBuilder
-
>
mCurrentFrame
=
mPrevFrame
;
mBuilder
-
>
mCurrentReferenceFrame
=
mPrevReferenceFrame
;
mBuilder
-
>
mLayerEventRegions
=
mPrevLayerEventRegions
;
mBuilder
-
>
mCompositorHitTestInfo
=
mPrevCompositorHitTestInfo
;
mBuilder
-
>
mCurrentOffsetToReferenceFrame
=
mPrevOffset
;
mBuilder
-
>
mVisibleRect
=
mPrevVisibleRect
;
mBuilder
-
>
mDirtyRect
=
mPrevDirtyRect
;
mBuilder
-
>
mCurrentAGR
=
mPrevAGR
;
mBuilder
-
>
mIsAtRootOfPseudoStackingContext
=
mPrevIsAtRootOfPseudoStackingContext
;
mBuilder
-
>
mAncestorHasApzAwareEventHandler
=
mPrevAncestorHasApzAwareEventHandler
;
mBuilder
-
>
mBuildingInvisibleItems
=
mPrevBuildingInvisibleItems
;
mBuilder
-
>
mInInvalidSubtree
=
mPrevInInvalidSubtree
;
}
private
:
nsDisplayListBuilder
*
mBuilder
;
AGRState
mCurrentAGRState
;
const
nsIFrame
*
mPrevFrame
;
const
nsIFrame
*
mPrevReferenceFrame
;
nsDisplayLayerEventRegions
*
mPrevLayerEventRegions
;
nsDisplayCompositorHitTestInfo
*
mPrevCompositorHitTestInfo
;
nsPoint
mPrevOffset
;
nsRect
mPrevVisibleRect
;
nsRect
mPrevDirtyRect
;
RefPtr
<
AnimatedGeometryRoot
>
mPrevAGR
;
bool
mPrevIsAtRootOfPseudoStackingContext
;
bool
mPrevAncestorHasApzAwareEventHandler
;
bool
mPrevBuildingInvisibleItems
;
bool
mPrevInInvalidSubtree
;
}
;
class
AutoInTransformSetter
{
public
:
AutoInTransformSetter
(
nsDisplayListBuilder
*
aBuilder
bool
aInTransform
)
:
mBuilder
(
aBuilder
)
mOldValue
(
aBuilder
-
>
mInTransform
)
{
aBuilder
-
>
mInTransform
=
aInTransform
;
}
~
AutoInTransformSetter
(
)
{
mBuilder
-
>
mInTransform
=
mOldValue
;
}
private
:
nsDisplayListBuilder
*
mBuilder
;
bool
mOldValue
;
}
;
class
AutoFilterASRSetter
{
public
:
AutoFilterASRSetter
(
nsDisplayListBuilder
*
aBuilder
bool
aUsingFilter
)
:
mBuilder
(
aBuilder
)
mOldValue
(
aBuilder
-
>
mFilterASR
)
{
if
(
!
aBuilder
-
>
mFilterASR
&
&
aUsingFilter
)
{
aBuilder
-
>
mFilterASR
=
aBuilder
-
>
CurrentActiveScrolledRoot
(
)
;
}
}
~
AutoFilterASRSetter
(
)
{
mBuilder
-
>
mFilterASR
=
mOldValue
;
}
private
:
nsDisplayListBuilder
*
mBuilder
;
const
ActiveScrolledRoot
*
mOldValue
;
}
;
class
AutoSaveRestorePerspectiveIndex
{
public
:
AutoSaveRestorePerspectiveIndex
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
:
mBuilder
(
nullptr
)
{
if
(
aFrame
-
>
ChildrenHavePerspective
(
)
)
{
mBuilder
=
aBuilder
;
mCachedItemIndex
=
aBuilder
-
>
mPerspectiveItemIndex
;
aBuilder
-
>
mPerspectiveItemIndex
=
0
;
}
}
~
AutoSaveRestorePerspectiveIndex
(
)
{
if
(
mBuilder
)
{
mBuilder
-
>
mPerspectiveItemIndex
=
mCachedItemIndex
;
}
}
private
:
nsDisplayListBuilder
*
mBuilder
;
uint32_t
mCachedItemIndex
;
}
;
class
AutoCurrentScrollParentIdSetter
{
public
:
AutoCurrentScrollParentIdSetter
(
nsDisplayListBuilder
*
aBuilder
ViewID
aScrollId
)
:
mBuilder
(
aBuilder
)
mOldValue
(
aBuilder
-
>
mCurrentScrollParentId
)
mOldForceLayer
(
aBuilder
-
>
mForceLayerForScrollParent
)
{
mCanBeScrollParent
=
(
mOldValue
!
=
aScrollId
)
;
aBuilder
-
>
mCurrentScrollParentId
=
aScrollId
;
aBuilder
-
>
mForceLayerForScrollParent
=
false
;
}
bool
ShouldForceLayerForScrollParent
(
)
const
{
return
mCanBeScrollParent
&
&
mBuilder
-
>
mForceLayerForScrollParent
;
}
;
~
AutoCurrentScrollParentIdSetter
(
)
{
mBuilder
-
>
mCurrentScrollParentId
=
mOldValue
;
if
(
mCanBeScrollParent
)
{
mBuilder
-
>
mForceLayerForScrollParent
=
mOldForceLayer
;
}
else
{
mBuilder
-
>
mForceLayerForScrollParent
|
=
mOldForceLayer
;
}
}
private
:
nsDisplayListBuilder
*
mBuilder
;
ViewID
mOldValue
;
bool
mOldForceLayer
;
bool
mCanBeScrollParent
;
}
;
class
AutoCurrentActiveScrolledRootSetter
{
public
:
explicit
AutoCurrentActiveScrolledRootSetter
(
nsDisplayListBuilder
*
aBuilder
)
:
mBuilder
(
aBuilder
)
mSavedActiveScrolledRoot
(
aBuilder
-
>
mCurrentActiveScrolledRoot
)
mContentClipASR
(
aBuilder
-
>
ClipState
(
)
.
GetContentClipASR
(
)
)
mDescendantsStartIndex
(
aBuilder
-
>
mActiveScrolledRoots
.
Length
(
)
)
mUsed
(
false
)
{
}
~
AutoCurrentActiveScrolledRootSetter
(
)
{
mBuilder
-
>
mCurrentActiveScrolledRoot
=
mSavedActiveScrolledRoot
;
}
void
SetCurrentActiveScrolledRoot
(
const
ActiveScrolledRoot
*
aActiveScrolledRoot
)
;
void
EnterScrollFrame
(
nsIScrollableFrame
*
aScrollableFrame
)
{
MOZ_ASSERT
(
!
mUsed
)
;
ActiveScrolledRoot
*
asr
=
mBuilder
-
>
AllocateActiveScrolledRoot
(
mBuilder
-
>
mCurrentActiveScrolledRoot
aScrollableFrame
)
;
mBuilder
-
>
mCurrentActiveScrolledRoot
=
asr
;
mUsed
=
true
;
}
void
InsertScrollFrame
(
nsIScrollableFrame
*
aScrollableFrame
)
;
private
:
nsDisplayListBuilder
*
mBuilder
;
const
ActiveScrolledRoot
*
mSavedActiveScrolledRoot
;
const
ActiveScrolledRoot
*
mContentClipASR
;
size_t
mDescendantsStartIndex
;
bool
mUsed
;
}
;
class
AutoContainerASRTracker
{
public
:
explicit
AutoContainerASRTracker
(
nsDisplayListBuilder
*
aBuilder
)
:
mBuilder
(
aBuilder
)
mSavedContainerASR
(
aBuilder
-
>
mCurrentContainerASR
)
{
mBuilder
-
>
mCurrentContainerASR
=
ActiveScrolledRoot
:
:
PickDescendant
(
mBuilder
-
>
ClipState
(
)
.
GetContentClipASR
(
)
mBuilder
-
>
mCurrentActiveScrolledRoot
)
;
}
const
ActiveScrolledRoot
*
GetContainerASR
(
)
{
return
mBuilder
-
>
mCurrentContainerASR
;
}
~
AutoContainerASRTracker
(
)
{
mBuilder
-
>
mCurrentContainerASR
=
ActiveScrolledRoot
:
:
PickAncestor
(
mBuilder
-
>
mCurrentContainerASR
mSavedContainerASR
)
;
}
private
:
nsDisplayListBuilder
*
mBuilder
;
const
ActiveScrolledRoot
*
mSavedContainerASR
;
}
;
class
AutoCurrentScrollbarInfoSetter
{
public
:
AutoCurrentScrollbarInfoSetter
(
nsDisplayListBuilder
*
aBuilder
ViewID
aScrollTargetID
nsDisplayOwnLayerFlags
aScrollbarFlags
bool
aWillHaveLayer
)
:
mBuilder
(
aBuilder
)
{
aBuilder
-
>
mIsBuildingScrollbar
=
true
;
aBuilder
-
>
mCurrentScrollbarTarget
=
aScrollTargetID
;
aBuilder
-
>
mCurrentScrollbarFlags
=
aScrollbarFlags
;
aBuilder
-
>
mCurrentScrollbarWillHaveLayer
=
aWillHaveLayer
;
}
~
AutoCurrentScrollbarInfoSetter
(
)
{
mBuilder
-
>
mIsBuildingScrollbar
=
false
;
mBuilder
-
>
mCurrentScrollbarTarget
=
FrameMetrics
:
:
NULL_SCROLL_ID
;
mBuilder
-
>
mCurrentScrollbarFlags
=
(
nsDisplayOwnLayerFlags
)
0
;
mBuilder
-
>
mCurrentScrollbarWillHaveLayer
=
false
;
}
private
:
nsDisplayListBuilder
*
mBuilder
;
}
;
class
AutoAccumulateTransform
{
public
:
typedef
mozilla
:
:
gfx
:
:
Matrix4x4
Matrix4x4
;
explicit
AutoAccumulateTransform
(
nsDisplayListBuilder
*
aBuilder
)
:
mBuilder
(
aBuilder
)
mSavedTransform
(
aBuilder
-
>
mPreserves3DCtx
.
mAccumulatedTransform
)
{
}
~
AutoAccumulateTransform
(
)
{
mBuilder
-
>
mPreserves3DCtx
.
mAccumulatedTransform
=
mSavedTransform
;
}
void
Accumulate
(
const
Matrix4x4
&
aTransform
)
{
mBuilder
-
>
mPreserves3DCtx
.
mAccumulatedTransform
=
aTransform
*
mBuilder
-
>
mPreserves3DCtx
.
mAccumulatedTransform
;
}
const
Matrix4x4
&
GetCurrentTransform
(
)
{
return
mBuilder
-
>
mPreserves3DCtx
.
mAccumulatedTransform
;
}
void
StartRoot
(
)
{
mBuilder
-
>
mPreserves3DCtx
.
mAccumulatedTransform
=
Matrix4x4
(
)
;
}
private
:
nsDisplayListBuilder
*
mBuilder
;
Matrix4x4
mSavedTransform
;
}
;
class
AutoAccumulateRect
{
public
:
explicit
AutoAccumulateRect
(
nsDisplayListBuilder
*
aBuilder
)
:
mBuilder
(
aBuilder
)
mSavedRect
(
aBuilder
-
>
mPreserves3DCtx
.
mAccumulatedRect
)
{
aBuilder
-
>
mPreserves3DCtx
.
mAccumulatedRect
=
nsRect
(
)
;
aBuilder
-
>
mPreserves3DCtx
.
mAccumulatedRectLevels
+
+
;
}
~
AutoAccumulateRect
(
)
{
mBuilder
-
>
mPreserves3DCtx
.
mAccumulatedRect
=
mSavedRect
;
mBuilder
-
>
mPreserves3DCtx
.
mAccumulatedRectLevels
-
-
;
}
private
:
nsDisplayListBuilder
*
mBuilder
;
nsRect
mSavedRect
;
}
;
void
AccumulateRect
(
const
nsRect
&
aRect
)
{
mPreserves3DCtx
.
mAccumulatedRect
.
UnionRect
(
mPreserves3DCtx
.
mAccumulatedRect
aRect
)
;
}
const
nsRect
&
GetAccumulatedRect
(
)
{
return
mPreserves3DCtx
.
mAccumulatedRect
;
}
int
GetAccumulatedRectLevels
(
)
{
return
mPreserves3DCtx
.
mAccumulatedRectLevels
;
}
nsDisplayTableItem
*
GetCurrentTableItem
(
)
{
return
mCurrentTableItem
;
}
void
SetCurrentTableItem
(
nsDisplayTableItem
*
aTableItem
)
{
mCurrentTableItem
=
aTableItem
;
}
struct
OutOfFlowDisplayData
{
OutOfFlowDisplayData
(
const
DisplayItemClipChain
*
aContainingBlockClipChain
const
DisplayItemClipChain
*
aCombinedClipChain
const
ActiveScrolledRoot
*
aContainingBlockActiveScrolledRoot
const
nsRect
&
aVisibleRect
const
nsRect
&
aDirtyRect
)
:
mContainingBlockClipChain
(
aContainingBlockClipChain
)
mCombinedClipChain
(
aCombinedClipChain
)
mContainingBlockActiveScrolledRoot
(
aContainingBlockActiveScrolledRoot
)
mVisibleRect
(
aVisibleRect
)
mDirtyRect
(
aDirtyRect
)
{
}
const
DisplayItemClipChain
*
mContainingBlockClipChain
;
const
DisplayItemClipChain
*
mCombinedClipChain
;
const
ActiveScrolledRoot
*
mContainingBlockActiveScrolledRoot
;
nsRect
mVisibleRect
;
nsRect
mDirtyRect
;
static
bool
AnyContentAncestorModified
(
nsIFrame
*
aFrame
nsIFrame
*
aStopAtFrame
=
nullptr
)
{
for
(
nsIFrame
*
f
=
aFrame
;
f
;
f
=
nsLayoutUtils
:
:
GetParentOrPlaceholderForCrossDoc
(
f
)
)
{
if
(
f
-
>
IsFrameModified
(
)
)
{
return
true
;
}
if
(
aStopAtFrame
&
&
f
=
=
aStopAtFrame
)
{
break
;
}
}
return
false
;
}
static
nsRect
ComputeVisibleRectForFrame
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
nsRect
&
aVisibleRect
const
nsRect
&
aDirtyRect
nsRect
*
aOutDirtyRect
)
{
nsRect
visible
=
aVisibleRect
;
nsRect
dirtyRectRelativeToDirtyFrame
=
aDirtyRect
;
if
(
nsLayoutUtils
:
:
IsFixedPosFrameInDisplayPort
(
aFrame
)
&
&
aBuilder
-
>
IsPaintingToWindow
(
)
)
{
nsIPresShell
*
ps
=
aFrame
-
>
PresShell
(
)
;
if
(
ps
-
>
IsScrollPositionClampingScrollPortSizeSet
(
)
)
{
dirtyRectRelativeToDirtyFrame
=
nsRect
(
nsPoint
(
0
0
)
ps
-
>
GetScrollPositionClampingScrollPortSize
(
)
)
;
visible
=
dirtyRectRelativeToDirtyFrame
;
#
ifdef
MOZ_WIDGET_ANDROID
}
else
{
dirtyRectRelativeToDirtyFrame
=
nsRect
(
nsPoint
(
0
0
)
aFrame
-
>
GetParent
(
)
-
>
GetSize
(
)
)
;
visible
=
dirtyRectRelativeToDirtyFrame
;
#
endif
}
}
*
aOutDirtyRect
=
dirtyRectRelativeToDirtyFrame
-
aFrame
-
>
GetPosition
(
)
;
visible
-
=
aFrame
-
>
GetPosition
(
)
;
nsRect
overflowRect
=
aFrame
-
>
GetVisualOverflowRect
(
)
;
if
(
aFrame
-
>
IsTransformed
(
)
&
&
mozilla
:
:
EffectCompositor
:
:
HasAnimationsForCompositor
(
aFrame
eCSSProperty_transform
)
)
{
overflowRect
.
Inflate
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
32
)
)
;
}
visible
.
IntersectRect
(
visible
overflowRect
)
;
aOutDirtyRect
-
>
IntersectRect
(
*
aOutDirtyRect
overflowRect
)
;
if
(
AnyContentAncestorModified
(
aFrame
aFrame
-
>
GetParent
(
)
)
)
{
*
aOutDirtyRect
=
visible
;
}
return
visible
;
}
nsRect
GetVisibleRectForFrame
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsRect
*
aDirtyRect
)
{
return
ComputeVisibleRectForFrame
(
aBuilder
aFrame
mVisibleRect
mDirtyRect
aDirtyRect
)
;
}
}
;
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
OutOfFlowDisplayDataProperty
OutOfFlowDisplayData
)
struct
DisplayListBuildingData
{
RefPtr
<
AnimatedGeometryRoot
>
mModifiedAGR
=
nullptr
;
nsRect
mDirtyRect
;
}
;
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
DisplayListBuildingRect
DisplayListBuildingData
)
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
DisplayListBuildingDisplayPortRect
nsRect
)
static
OutOfFlowDisplayData
*
GetOutOfFlowData
(
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
-
>
GetParent
(
)
)
{
return
nullptr
;
}
return
aFrame
-
>
GetParent
(
)
-
>
GetProperty
(
OutOfFlowDisplayDataProperty
(
)
)
;
}
nsPresContext
*
CurrentPresContext
(
)
{
return
CurrentPresShellState
(
)
-
>
mPresShell
-
>
GetPresContext
(
)
;
}
OutOfFlowDisplayData
*
GetCurrentFixedBackgroundDisplayData
(
)
{
auto
&
displayData
=
CurrentPresShellState
(
)
-
>
mFixedBackgroundDisplayData
;
return
displayData
?
displayData
.
ptr
(
)
:
nullptr
;
}
void
AddWindowExcludeGlassRegion
(
nsIFrame
*
aFrame
const
nsRect
&
aBounds
)
{
mWindowExcludeGlassRegion
.
Add
(
aFrame
aBounds
)
;
}
nsRegion
GetWindowExcludeGlassRegion
(
)
const
{
return
mWindowExcludeGlassRegion
.
ToRegion
(
)
;
}
void
AddWindowOpaqueRegion
(
const
nsRegion
&
bounds
)
{
mWindowOpaqueRegion
.
Or
(
mWindowOpaqueRegion
bounds
)
;
}
const
nsRegion
&
GetWindowOpaqueRegion
(
)
{
return
mWindowOpaqueRegion
;
}
void
ClearWindowOpaqueRegion
(
)
{
mWindowOpaqueRegion
.
SetEmpty
(
)
;
}
void
SetGlassDisplayItem
(
nsDisplayItem
*
aItem
)
{
if
(
mGlassDisplayItem
)
{
NS_WARNING
(
"
Multiple
glass
backgrounds
found
?
"
)
;
}
else
{
mGlassDisplayItem
=
aItem
;
}
}
bool
NeedToForceTransparentSurfaceForItem
(
nsDisplayItem
*
aItem
)
;
void
SetContainsPluginItem
(
)
{
mContainsPluginItem
=
true
;
}
bool
ContainsPluginItem
(
)
{
return
mContainsPluginItem
;
}
void
SetContainsBlendMode
(
bool
aContainsBlendMode
)
{
mContainsBlendMode
=
aContainsBlendMode
;
}
bool
ContainsBlendMode
(
)
const
{
return
mContainsBlendMode
;
}
void
AllocatePerspectiveItemIndex
(
)
{
+
+
mPerspectiveItemIndex
;
}
uint32_t
PerspectiveItemIndex
(
)
const
{
return
mPerspectiveItemIndex
;
}
DisplayListClipState
&
ClipState
(
)
{
return
mClipState
;
}
const
ActiveScrolledRoot
*
CurrentActiveScrolledRoot
(
)
{
return
mCurrentActiveScrolledRoot
;
}
const
ActiveScrolledRoot
*
CurrentAncestorASRStackingContextContents
(
)
{
return
mCurrentContainerASR
;
}
bool
AddToWillChangeBudget
(
nsIFrame
*
aFrame
const
nsSize
&
aSize
)
;
bool
IsInWillChangeBudget
(
nsIFrame
*
aFrame
const
nsSize
&
aSize
)
;
void
ClearWillChangeBudget
(
nsIFrame
*
aFrame
)
;
void
EnterSVGEffectsContents
(
nsDisplayList
*
aHoistedItemsStorage
)
;
void
ExitSVGEffectsContents
(
)
;
bool
ShouldBuildScrollInfoItemsForHoisting
(
)
const
{
return
mSVGEffectsBuildingDepth
>
0
;
}
void
AppendNewScrollInfoItemForHoisting
(
nsDisplayScrollInfoLayer
*
aScrollInfoItem
)
;
class
AutoPreserves3DContext
{
public
:
explicit
AutoPreserves3DContext
(
nsDisplayListBuilder
*
aBuilder
)
:
mBuilder
(
aBuilder
)
mSavedCtx
(
aBuilder
-
>
mPreserves3DCtx
)
{
}
~
AutoPreserves3DContext
(
)
{
mBuilder
-
>
mPreserves3DCtx
=
mSavedCtx
;
}
private
:
nsDisplayListBuilder
*
mBuilder
;
Preserves3DContext
mSavedCtx
;
}
;
const
nsRect
GetPreserves3DRect
(
)
const
{
return
mPreserves3DCtx
.
mVisibleRect
;
}
void
SavePreserves3DRect
(
)
{
mPreserves3DCtx
.
mVisibleRect
=
mVisibleRect
;
}
bool
IsBuildingInvisibleItems
(
)
const
{
return
mBuildingInvisibleItems
;
}
void
SetBuildingInvisibleItems
(
bool
aBuildingInvisibleItems
)
{
mBuildingInvisibleItems
=
aBuildingInvisibleItems
;
}
bool
MarkFrameModifiedDuringBuilding
(
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
-
>
IsFrameModified
(
)
)
{
mModifiedFramesDuringBuilding
.
AppendElement
(
aFrame
)
;
aFrame
-
>
SetFrameIsModified
(
true
)
;
return
true
;
}
return
false
;
}
bool
MarkCurrentFrameModifiedDuringBuilding
(
)
{
if
(
MarkFrameModifiedDuringBuilding
(
const_cast
<
nsIFrame
*
>
(
mCurrentFrame
)
)
)
{
mInInvalidSubtree
=
true
;
return
true
;
}
return
false
;
}
AnimatedGeometryRoot
*
AnimatedGeometryRootForASR
(
const
ActiveScrolledRoot
*
aASR
)
;
bool
HitTestIsForVisibility
(
)
const
{
return
mHitTestIsForVisibility
;
}
void
SetHitTestIsForVisibility
(
bool
aHitTestIsForVisibility
)
{
mHitTestIsForVisibility
=
aHitTestIsForVisibility
;
}
struct
WeakFrameRegion
{
std
:
:
vector
<
WeakFrame
>
mFrames
;
nsTArray
<
pixman_box32_t
>
mRects
;
void
Add
(
nsIFrame
*
aFrame
const
nsRect
&
aRect
)
{
mFrames
.
emplace_back
(
aFrame
)
;
mRects
.
AppendElement
(
nsRegion
:
:
RectToBox
(
aRect
)
)
;
}
void
Add
(
nsIFrame
*
aFrame
const
mozilla
:
:
gfx
:
:
IntRect
&
aRect
)
{
mFrames
.
emplace_back
(
aFrame
)
;
mRects
.
AppendElement
(
nsRegion
:
:
RectToBox
(
aRect
)
)
;
}
void
Clear
(
)
{
mFrames
.
clear
(
)
;
mRects
.
Clear
(
)
;
}
typedef
mozilla
:
:
gfx
:
:
ArrayView
<
pixman_box32_t
>
BoxArrayView
;
nsRegion
ToRegion
(
)
const
{
return
nsRegion
(
BoxArrayView
(
mRects
)
)
;
}
LayoutDeviceIntRegion
ToLayoutDeviceIntRegion
(
)
const
{
return
LayoutDeviceIntRegion
(
BoxArrayView
(
mRects
)
)
;
}
}
;
private
:
bool
MarkOutOfFlowFrameForDisplay
(
nsIFrame
*
aDirtyFrame
nsIFrame
*
aFrame
)
;
AGRState
IsAnimatedGeometryRoot
(
nsIFrame
*
aFrame
bool
&
aIsAsync
nsIFrame
*
*
aParent
=
nullptr
)
;
nsIFrame
*
FindAnimatedGeometryRootFrameFor
(
nsIFrame
*
aFrame
bool
&
aIsAsync
)
;
bool
ShouldBuildCompositorHitTestInfo
(
const
nsIFrame
*
aFrame
const
mozilla
:
:
gfx
:
:
CompositorHitTestInfo
&
aInfo
const
bool
aBuildNew
)
const
;
friend
class
nsDisplayCanvasBackgroundImage
;
friend
class
nsDisplayBackgroundImage
;
friend
class
nsDisplayFixedPosition
;
AnimatedGeometryRoot
*
FindAnimatedGeometryRootFor
(
nsDisplayItem
*
aItem
)
;
friend
class
nsDisplayItem
;
friend
class
nsDisplayOwnLayer
;
friend
struct
RetainedDisplayListBuilder
;
AnimatedGeometryRoot
*
FindAnimatedGeometryRootFor
(
nsIFrame
*
aFrame
)
;
AnimatedGeometryRoot
*
WrapAGRForFrame
(
nsIFrame
*
aAnimatedGeometryRoot
bool
aIsAsync
AnimatedGeometryRoot
*
aParent
=
nullptr
)
;
nsDataHashtable
<
nsPtrHashKey
<
nsIFrame
>
RefPtr
<
AnimatedGeometryRoot
>
>
mFrameToAnimatedGeometryRootMap
;
bool
AddToAGRBudget
(
nsIFrame
*
aFrame
)
;
struct
PresShellState
{
nsIPresShell
*
mPresShell
;
#
ifdef
DEBUG
mozilla
:
:
Maybe
<
nsAutoLayoutPhase
>
mAutoLayoutPhase
;
#
endif
nsIFrame
*
mCaretFrame
;
nsRect
mCaretRect
;
mozilla
:
:
Maybe
<
OutOfFlowDisplayData
>
mFixedBackgroundDisplayData
;
uint32_t
mFirstFrameMarkedForDisplay
;
uint32_t
mFirstFrameWithOOFData
;
bool
mIsBackgroundOnly
;
bool
mInsidePointerEventsNoneDoc
;
}
;
PresShellState
*
CurrentPresShellState
(
)
{
NS_ASSERTION
(
mPresShellStates
.
Length
(
)
>
0
"
Someone
forgot
to
enter
a
presshell
"
)
;
return
&
mPresShellStates
[
mPresShellStates
.
Length
(
)
-
1
]
;
}
struct
DocumentWillChangeBudget
{
DocumentWillChangeBudget
(
)
:
mBudget
(
0
)
{
}
uint32_t
mBudget
;
}
;
struct
FrameWillChangeBudget
{
FrameWillChangeBudget
(
nsIFrame
*
aFrame
uint32_t
aUsage
)
:
mFrame
(
aFrame
)
mUsage
(
aUsage
)
{
}
nsIFrame
*
mFrame
;
uint32_t
mUsage
;
}
;
nsIFrame
*
const
mReferenceFrame
;
nsIFrame
*
mIgnoreScrollFrame
;
nsDisplayLayerEventRegions
*
mLayerEventRegions
;
nsDisplayCompositorHitTestInfo
*
mCompositorHitTestInfo
;
nsPresArena
mPool
;
nsCOMPtr
<
nsISelection
>
mBoundingSelection
;
AutoTArray
<
PresShellState
8
>
mPresShellStates
;
AutoTArray
<
nsIFrame
*
400
>
mFramesMarkedForDisplay
;
AutoTArray
<
nsIFrame
*
40
>
mFramesMarkedForDisplayIfVisible
;
AutoTArray
<
nsIFrame
*
20
>
mFramesWithOOFData
;
nsClassHashtable
<
nsPtrHashKey
<
nsDisplayItem
>
nsTArray
<
ThemeGeometry
>
>
mThemeGeometries
;
nsDisplayTableItem
*
mCurrentTableItem
;
DisplayListClipState
mClipState
;
const
ActiveScrolledRoot
*
mCurrentActiveScrolledRoot
;
const
ActiveScrolledRoot
*
mCurrentContainerASR
;
const
nsIFrame
*
mCurrentFrame
;
const
nsIFrame
*
mCurrentReferenceFrame
;
nsPoint
mCurrentOffsetToReferenceFrame
;
RefPtr
<
AnimatedGeometryRoot
>
mRootAGR
;
RefPtr
<
AnimatedGeometryRoot
>
mCurrentAGR
;
nsDataHashtable
<
nsPtrHashKey
<
nsPresContext
>
DocumentWillChangeBudget
>
mWillChangeBudget
;
nsDataHashtable
<
nsPtrHashKey
<
nsIFrame
>
uint32_t
>
mWillChangeBudgetSet
;
uint32_t
mUsedAGRBudget
;
nsTHashtable
<
nsPtrHashKey
<
nsIFrame
>
>
mAGRBudgetSet
;
nsTArray
<
nsIFrame
*
>
mModifiedFramesDuringBuilding
;
nsRect
mVisibleRect
;
nsRect
mDirtyRect
;
WeakFrameRegion
mWindowExcludeGlassRegion
;
WeakFrameRegion
mRetainedWindowDraggingRegion
;
WeakFrameRegion
mRetainedWindowNoDraggingRegion
;
LayoutDeviceIntRegion
mWindowDraggingRegion
;
LayoutDeviceIntRegion
mWindowNoDraggingRegion
;
nsRegion
mWindowOpaqueRegion
;
nsDisplayItem
*
mGlassDisplayItem
;
nsDisplayList
*
mScrollInfoItemsForHoisting
;
nsTArray
<
RefPtr
<
ActiveScrolledRoot
>
>
mActiveScrolledRoots
;
std
:
:
unordered_set
<
const
DisplayItemClipChain
*
DisplayItemClipChainHasher
DisplayItemClipChainEqualer
>
mClipDeduplicator
;
std
:
:
list
<
DisplayItemClipChain
*
>
mClipChainsToDestroy
;
nsTArray
<
nsDisplayItem
*
>
mTemporaryItems
;
const
ActiveScrolledRoot
*
mActiveScrolledRootForRootScrollframe
;
nsDisplayListBuilderMode
mMode
;
ViewID
mCurrentScrollParentId
;
ViewID
mCurrentScrollbarTarget
;
nsDisplayOwnLayerFlags
mCurrentScrollbarFlags
;
Preserves3DContext
mPreserves3DCtx
;
uint32_t
mPerspectiveItemIndex
;
int32_t
mSVGEffectsBuildingDepth
;
const
ActiveScrolledRoot
*
mFilterASR
;
bool
mContainsBlendMode
;
bool
mIsBuildingScrollbar
;
bool
mCurrentScrollbarWillHaveLayer
;
bool
mBuildCaret
;
bool
mRetainingDisplayList
;
bool
mPartialUpdate
;
bool
mIgnoreSuppression
;
bool
mIsAtRootOfPseudoStackingContext
;
bool
mIncludeAllOutOfFlows
;
bool
mDescendIntoSubdocuments
;
bool
mSelectedFramesOnly
;
bool
mAllowMergingAndFlattening
;
bool
mWillComputePluginGeometry
;
bool
mInTransform
;
bool
mIsInChromePresContext
;
bool
mSyncDecodeImages
;
bool
mIsPaintingToWindow
;
bool
mIsCompositingCheap
;
bool
mContainsPluginItem
;
bool
mAncestorHasApzAwareEventHandler
;
bool
mHaveScrollableDisplayPort
;
bool
mWindowDraggingAllowed
;
bool
mIsBuildingForPopup
;
bool
mForceLayerForScrollParent
;
bool
mAsyncPanZoomEnabled
;
bool
mBuildingInvisibleItems
;
bool
mHitTestIsForVisibility
;
bool
mIsBuilding
;
bool
mInInvalidSubtree
;
bool
mBuildCompositorHitTestInfo
;
bool
mLessEventRegionItems
;
}
;
class
nsDisplayItem
;
class
nsDisplayList
;
class
nsDisplayItemLink
{
protected
:
nsDisplayItemLink
(
)
:
mAbove
(
nullptr
)
{
}
nsDisplayItemLink
(
const
nsDisplayItemLink
&
)
:
mAbove
(
nullptr
)
{
}
nsDisplayItem
*
mAbove
;
friend
class
nsDisplayList
;
}
;
class
nsDisplayWrapList
;
template
<
typename
T
typename
.
.
.
Args
>
MOZ_ALWAYS_INLINE
T
*
MakeDisplayItem
(
nsDisplayListBuilder
*
aBuilder
Args
&
&
.
.
.
aArgs
)
{
return
new
(
aBuilder
)
T
(
aBuilder
mozilla
:
:
Forward
<
Args
>
(
aArgs
)
.
.
.
)
;
}
class
nsDisplayItem
:
public
nsDisplayItemLink
{
public
:
typedef
mozilla
:
:
ContainerLayerParameters
ContainerLayerParameters
;
typedef
mozilla
:
:
DisplayItemClip
DisplayItemClip
;
typedef
mozilla
:
:
DisplayItemClipChain
DisplayItemClipChain
;
typedef
mozilla
:
:
ActiveScrolledRoot
ActiveScrolledRoot
;
typedef
mozilla
:
:
layers
:
:
FrameMetrics
FrameMetrics
;
typedef
mozilla
:
:
layers
:
:
ScrollMetadata
ScrollMetadata
;
typedef
mozilla
:
:
layers
:
:
FrameMetrics
:
:
ViewID
ViewID
;
typedef
mozilla
:
:
layers
:
:
Layer
Layer
;
typedef
mozilla
:
:
layers
:
:
LayerManager
LayerManager
;
typedef
mozilla
:
:
layers
:
:
StackingContextHelper
StackingContextHelper
;
typedef
mozilla
:
:
layers
:
:
WebRenderCommand
WebRenderCommand
;
typedef
mozilla
:
:
layers
:
:
WebRenderParentCommand
WebRenderParentCommand
;
typedef
mozilla
:
:
LayerState
LayerState
;
typedef
mozilla
:
:
image
:
:
imgDrawingParams
imgDrawingParams
;
typedef
mozilla
:
:
image
:
:
ImgDrawResult
ImgDrawResult
;
typedef
class
mozilla
:
:
gfx
:
:
DrawTarget
DrawTarget
;
nsDisplayItem
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
;
nsDisplayItem
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
ActiveScrolledRoot
*
aActiveScrolledRoot
)
;
explicit
nsDisplayItem
(
nsIFrame
*
aFrame
)
:
mFrame
(
aFrame
)
mClipChain
(
nullptr
)
mClip
(
nullptr
)
mActiveScrolledRoot
(
nullptr
)
mReferenceFrame
(
nullptr
)
mAnimatedGeometryRoot
(
nullptr
)
mForceNotVisible
(
false
)
mDisableSubpixelAA
(
false
)
mReusedItem
(
false
)
mBackfaceHidden
(
mFrame
-
>
In3DContextAndBackfaceIsHidden
(
)
)
#
ifdef
MOZ_DUMP_PAINTING
mPainted
(
false
)
#
endif
{
MOZ_COUNT_CTOR
(
nsDisplayItem
)
;
}
protected
:
virtual
~
nsDisplayItem
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayItem
)
;
if
(
mFrame
)
{
mFrame
-
>
RemoveDisplayItem
(
this
)
;
}
}
public
:
virtual
void
Destroy
(
nsDisplayListBuilder
*
aBuilder
)
{
DisplayItemType
type
=
GetType
(
)
;
this
-
>
~
nsDisplayItem
(
)
;
aBuilder
-
>
Destroy
(
type
this
)
;
}
virtual
void
RestoreState
(
)
{
mVisibleRect
=
mState
.
mVisibleRect
;
mClipChain
=
mState
.
mClipChain
;
mClip
=
mState
.
mClip
;
mDisableSubpixelAA
=
false
;
}
virtual
void
RemoveFrame
(
nsIFrame
*
aFrame
)
{
if
(
mFrame
&
&
aFrame
=
=
mFrame
)
{
MOZ_ASSERT
(
!
mFrame
-
>
HasDisplayItem
(
this
)
)
;
mFrame
=
nullptr
;
}
}
virtual
const
nsDisplayWrapList
*
AsDisplayWrapList
(
)
const
{
return
nullptr
;
}
virtual
nsDisplayWrapList
*
AsDisplayWrapList
(
)
{
return
nullptr
;
}
virtual
nsDisplayItem
*
Clone
(
nsDisplayListBuilder
*
aBuilder
)
const
{
return
nullptr
;
}
nsDisplayItem
(
const
nsDisplayItem
&
)
=
delete
;
nsDisplayItem
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItem
&
aOther
)
:
mFrame
(
aOther
.
mFrame
)
mClipChain
(
aOther
.
mClipChain
)
mClip
(
aOther
.
mClip
)
mActiveScrolledRoot
(
aOther
.
mActiveScrolledRoot
)
mReferenceFrame
(
aOther
.
mReferenceFrame
)
mAnimatedGeometryRoot
(
aOther
.
mAnimatedGeometryRoot
)
mToReferenceFrame
(
aOther
.
mToReferenceFrame
)
mVisibleRect
(
aOther
.
mVisibleRect
)
mForceNotVisible
(
aOther
.
mForceNotVisible
)
mDisableSubpixelAA
(
aOther
.
mDisableSubpixelAA
)
mReusedItem
(
false
)
mBackfaceHidden
(
mFrame
-
>
In3DContextAndBackfaceIsHidden
(
)
)
#
ifdef
MOZ_DUMP_PAINTING
mPainted
(
false
)
#
endif
{
MOZ_COUNT_CTOR
(
nsDisplayItem
)
;
}
struct
HitTestState
{
explicit
HitTestState
(
)
:
mInPreserves3D
(
false
)
{
}
~
HitTestState
(
)
{
NS_ASSERTION
(
mItemBuffer
.
Length
(
)
=
=
0
"
mItemBuffer
should
have
been
cleared
"
)
;
}
bool
mInPreserves3D
;
AutoTArray
<
nsDisplayItem
*
100
>
mItemBuffer
;
}
;
virtual
DisplayItemType
GetType
(
)
const
=
0
;
virtual
uint32_t
GetPerFrameKey
(
)
const
{
return
uint32_t
(
GetType
(
)
)
;
}
uint8_t
GetFlags
(
)
{
return
GetDisplayItemFlagsForType
(
GetType
(
)
)
;
}
virtual
void
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
{
}
inline
nsIFrame
*
Frame
(
)
const
{
MOZ_ASSERT
(
mFrame
"
Trying
to
use
display
item
after
deletion
!
"
)
;
return
mFrame
;
}
virtual
nsIFrame
*
FrameForInvalidation
(
)
const
{
return
mFrame
;
}
virtual
bool
HasDeletedFrame
(
)
const
{
return
!
mFrame
;
}
virtual
nsIFrame
*
StyleFrame
(
)
const
{
return
mFrame
;
}
virtual
int32_t
ZIndex
(
)
const
;
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
{
*
aSnap
=
false
;
return
nsRect
(
ToReferenceFrame
(
)
Frame
(
)
-
>
GetSize
(
)
)
;
}
virtual
nsRegion
GetTightBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
{
*
aSnap
=
false
;
return
nsRegion
(
)
;
}
virtual
bool
IsInvisibleInRect
(
const
nsRect
&
aRect
)
const
{
return
false
;
}
nsRect
GetClippedBounds
(
nsDisplayListBuilder
*
aBuilder
)
const
;
nsRect
GetBorderRect
(
)
const
{
return
nsRect
(
ToReferenceFrame
(
)
Frame
(
)
-
>
GetSize
(
)
)
;
}
nsRect
GetPaddingRect
(
)
const
{
return
Frame
(
)
-
>
GetPaddingRectRelativeToSelf
(
)
+
ToReferenceFrame
(
)
;
}
nsRect
GetContentRect
(
)
const
{
return
Frame
(
)
-
>
GetContentRectRelativeToSelf
(
)
+
ToReferenceFrame
(
)
;
}
virtual
bool
IsInvalid
(
nsRect
&
aRect
)
const
{
bool
result
=
mFrame
?
mFrame
-
>
IsInvalid
(
aRect
)
:
false
;
aRect
+
=
ToReferenceFrame
(
)
;
return
result
;
}
virtual
nsDisplayItemGeometry
*
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
{
return
new
nsDisplayItemGenericGeometry
(
this
aBuilder
)
;
}
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
{
const
nsDisplayItemGenericGeometry
*
geometry
=
static_cast
<
const
nsDisplayItemGenericGeometry
*
>
(
aGeometry
)
;
bool
snap
;
if
(
!
geometry
-
>
mBounds
.
IsEqualInterior
(
GetBounds
(
aBuilder
&
snap
)
)
|
|
!
geometry
-
>
mBorderRect
.
IsEqualInterior
(
GetBorderRect
(
)
)
)
{
aInvalidRegion
-
>
Or
(
GetBounds
(
aBuilder
&
snap
)
geometry
-
>
mBounds
)
;
}
}
void
ComputeInvalidationRegionDifference
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemBoundsGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
{
bool
snap
;
nsRect
bounds
=
GetBounds
(
aBuilder
&
snap
)
;
if
(
!
aGeometry
-
>
mBounds
.
IsEqualInterior
(
bounds
)
)
{
nscoord
radii
[
8
]
;
if
(
aGeometry
-
>
mHasRoundedCorners
|
|
Frame
(
)
-
>
GetBorderRadii
(
radii
)
)
{
aInvalidRegion
-
>
Or
(
aGeometry
-
>
mBounds
bounds
)
;
}
else
{
aInvalidRegion
-
>
Xor
(
aGeometry
-
>
mBounds
bounds
)
;
}
}
}
virtual
nsRegion
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
{
*
aSnap
=
false
;
return
nsRegion
(
)
;
}
virtual
mozilla
:
:
Maybe
<
nscolor
>
IsUniform
(
nsDisplayListBuilder
*
aBuilder
)
const
{
return
mozilla
:
:
Nothing
(
)
;
}
virtual
bool
ShouldFixToViewport
(
nsDisplayListBuilder
*
aBuilder
)
const
{
return
false
;
}
virtual
bool
ClearsBackground
(
)
const
{
return
false
;
}
static
bool
ForceActiveLayers
(
)
;
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
{
return
mozilla
:
:
LAYER_NONE
;
}
virtual
bool
ShouldBuildLayerEvenIfInvisible
(
nsDisplayListBuilder
*
aBuilder
)
const
{
return
false
;
}
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
}
#
ifdef
MOZ_DUMP_PAINTING
bool
Painted
(
)
const
{
return
mPainted
;
}
void
SetPainted
(
)
{
mPainted
=
true
;
}
#
endif
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
{
return
nullptr
;
}
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
return
false
;
}
virtual
bool
UpdateScrollData
(
mozilla
:
:
layers
:
:
WebRenderScrollData
*
aData
mozilla
:
:
layers
:
:
WebRenderLayerScrollData
*
aLayerData
)
{
return
false
;
}
already_AddRefed
<
Layer
>
BuildDisplayItemLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
;
virtual
bool
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
;
virtual
bool
CanMerge
(
const
nsDisplayItem
*
aItem
)
const
{
return
false
;
}
virtual
void
Merge
(
const
nsDisplayItem
*
aItem
)
{
}
virtual
void
MergeDisplayListFromItem
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItem
*
aItem
)
{
}
virtual
void
GetMergedFrames
(
nsTArray
<
nsIFrame
*
>
*
aFrames
)
const
{
}
virtual
bool
ShouldFlattenAway
(
nsDisplayListBuilder
*
aBuilder
)
{
return
false
;
}
virtual
bool
MustPaintOnContentSide
(
)
const
{
return
false
;
}
virtual
nsDisplayList
*
GetSameCoordinateSystemChildren
(
)
const
{
return
nullptr
;
}
virtual
void
UpdateBounds
(
nsDisplayListBuilder
*
aBuilder
)
{
}
virtual
void
DoUpdateBoundsPreserves3D
(
nsDisplayListBuilder
*
aBuilder
)
{
}
virtual
nsDisplayList
*
GetChildren
(
)
const
{
return
nullptr
;
}
const
nsRect
&
GetVisibleRect
(
)
const
{
return
mVisibleRect
;
}
void
SetVisibleRect
(
const
nsRect
&
aVisibleRect
bool
aStore
)
{
mVisibleRect
=
aVisibleRect
;
if
(
aStore
)
{
mState
.
mVisibleRect
=
mVisibleRect
;
}
}
virtual
const
nsRect
&
GetVisibleRectForChildren
(
)
const
{
return
mVisibleRect
;
}
virtual
void
ApplyOpacity
(
nsDisplayListBuilder
*
aBuilder
float
aOpacity
const
DisplayItemClipChain
*
aClip
)
{
NS_ASSERTION
(
CanApplyOpacity
(
)
"
ApplyOpacity
not
supported
on
this
type
"
)
;
}
virtual
bool
CanApplyOpacity
(
)
const
{
return
false
;
}
bool
ForceNotVisible
(
)
const
{
return
mForceNotVisible
;
}
virtual
const
char
*
Name
(
)
const
=
0
;
virtual
void
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
{
}
nsDisplayItem
*
GetAbove
(
)
{
return
mAbove
;
}
bool
RecomputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
bool
aUseClipBounds
=
true
)
;
const
nsPoint
&
ToReferenceFrame
(
)
const
{
NS_ASSERTION
(
mFrame
"
No
frame
?
"
)
;
return
mToReferenceFrame
;
}
const
nsIFrame
*
ReferenceFrame
(
)
const
{
return
mReferenceFrame
;
}
virtual
const
nsIFrame
*
ReferenceFrameForChildren
(
)
const
{
return
mReferenceFrame
;
}
AnimatedGeometryRoot
*
GetAnimatedGeometryRoot
(
)
const
{
MOZ_ASSERT
(
mAnimatedGeometryRoot
"
Must
have
cached
AGR
before
accessing
it
!
"
)
;
return
mAnimatedGeometryRoot
;
}
virtual
struct
AnimatedGeometryRoot
*
AnimatedGeometryRootForScrollMetadata
(
)
const
{
return
GetAnimatedGeometryRoot
(
)
;
}
virtual
nsRect
GetComponentAlphaBounds
(
nsDisplayListBuilder
*
aBuilder
)
const
{
return
nsRect
(
)
;
}
void
DisableComponentAlpha
(
)
{
mDisableSubpixelAA
=
true
;
}
bool
IsSubpixelAADisabled
(
)
const
{
return
mDisableSubpixelAA
;
}
virtual
bool
CanUseAsyncAnimations
(
nsDisplayListBuilder
*
aBuilder
)
{
return
false
;
}
virtual
bool
SupportsOptimizingToImage
(
)
const
{
return
false
;
}
const
DisplayItemClip
&
GetClip
(
)
const
{
return
mClip
?
*
mClip
:
DisplayItemClip
:
:
NoClip
(
)
;
}
void
IntersectClip
(
nsDisplayListBuilder
*
aBuilder
const
DisplayItemClipChain
*
aOther
bool
aStore
)
;
virtual
void
SetActiveScrolledRoot
(
const
ActiveScrolledRoot
*
aActiveScrolledRoot
)
{
mActiveScrolledRoot
=
aActiveScrolledRoot
;
}
const
ActiveScrolledRoot
*
GetActiveScrolledRoot
(
)
const
{
return
mActiveScrolledRoot
;
}
virtual
void
SetClipChain
(
const
DisplayItemClipChain
*
aClipChain
bool
aStore
)
;
const
DisplayItemClipChain
*
GetClipChain
(
)
const
{
return
mClipChain
;
}
void
FuseClipChainUpTo
(
nsDisplayListBuilder
*
aBuilder
const
ActiveScrolledRoot
*
aASR
)
;
bool
BackfaceIsHidden
(
)
const
{
return
mFrame
-
>
BackfaceIsHidden
(
)
;
}
bool
In3DContextAndBackfaceIsHidden
(
)
{
return
mBackfaceHidden
;
}
bool
HasSameTypeAndClip
(
const
nsDisplayItem
*
aOther
)
const
{
return
GetType
(
)
=
=
aOther
-
>
GetType
(
)
&
&
GetClipChain
(
)
=
=
aOther
-
>
GetClipChain
(
)
;
}
bool
HasSameContent
(
const
nsDisplayItem
*
aOther
)
const
{
return
mFrame
-
>
GetContent
(
)
=
=
aOther
-
>
Frame
(
)
-
>
GetContent
(
)
;
}
bool
IsReused
(
)
const
{
return
mReusedItem
;
}
void
SetReused
(
bool
aReused
)
{
mReusedItem
=
aReused
;
}
virtual
bool
CanBeReused
(
)
const
{
return
true
;
}
virtual
nsIFrame
*
GetDependentFrame
(
)
{
return
nullptr
;
}
virtual
mozilla
:
:
Maybe
<
nsRect
>
GetClipWithRespectToASR
(
nsDisplayListBuilder
*
aBuilder
const
ActiveScrolledRoot
*
aASR
)
const
;
protected
:
nsDisplayItem
(
)
=
delete
;
typedef
bool
(
*
PrefFunc
)
(
void
)
;
bool
ShouldUseAdvancedLayer
(
LayerManager
*
aManager
PrefFunc
aFunc
)
const
;
bool
CanUseAdvancedLayer
(
LayerManager
*
aManager
)
const
;
nsIFrame
*
mFrame
;
RefPtr
<
const
DisplayItemClipChain
>
mClipChain
;
const
DisplayItemClip
*
mClip
;
RefPtr
<
const
ActiveScrolledRoot
>
mActiveScrolledRoot
;
const
nsIFrame
*
mReferenceFrame
;
RefPtr
<
struct
AnimatedGeometryRoot
>
mAnimatedGeometryRoot
;
nsPoint
mToReferenceFrame
;
nsRect
mVisibleRect
;
bool
mForceNotVisible
;
bool
mDisableSubpixelAA
;
bool
mReusedItem
;
bool
mBackfaceHidden
;
#
ifdef
MOZ_DUMP_PAINTING
bool
mPainted
;
#
endif
struct
{
nsRect
mVisibleRect
;
RefPtr
<
const
DisplayItemClipChain
>
mClipChain
;
const
DisplayItemClip
*
mClip
;
}
mState
;
}
;
class
nsDisplayList
{
public
:
typedef
mozilla
:
:
ActiveScrolledRoot
ActiveScrolledRoot
;
typedef
mozilla
:
:
layers
:
:
Layer
Layer
;
typedef
mozilla
:
:
layers
:
:
LayerManager
LayerManager
;
typedef
mozilla
:
:
layers
:
:
PaintedLayer
PaintedLayer
;
nsDisplayList
(
)
:
mLength
(
0
)
mIsOpaque
(
false
)
mForceTransparentSurface
(
false
)
{
mTop
=
&
mSentinel
;
mSentinel
.
mAbove
=
nullptr
;
}
~
nsDisplayList
(
)
{
if
(
mSentinel
.
mAbove
)
{
NS_WARNING
(
"
Nonempty
list
left
over
?
"
)
;
}
}
void
AppendToTop
(
nsDisplayItem
*
aItem
)
{
MOZ_ASSERT
(
aItem
"
No
item
to
append
!
"
)
;
MOZ_ASSERT
(
!
aItem
-
>
mAbove
"
Already
in
a
list
!
"
)
;
mTop
-
>
mAbove
=
aItem
;
mTop
=
aItem
;
mLength
+
+
;
}
void
AppendToBottom
(
nsDisplayItem
*
aItem
)
{
MOZ_ASSERT
(
aItem
"
No
item
to
append
!
"
)
;
MOZ_ASSERT
(
!
aItem
-
>
mAbove
"
Already
in
a
list
!
"
)
;
aItem
-
>
mAbove
=
mSentinel
.
mAbove
;
mSentinel
.
mAbove
=
aItem
;
if
(
mTop
=
=
&
mSentinel
)
{
mTop
=
aItem
;
}
mLength
+
+
;
}
void
AppendToTop
(
nsDisplayList
*
aList
)
{
if
(
aList
-
>
mSentinel
.
mAbove
)
{
mTop
-
>
mAbove
=
aList
-
>
mSentinel
.
mAbove
;
mTop
=
aList
-
>
mTop
;
aList
-
>
mTop
=
&
aList
-
>
mSentinel
;
aList
-
>
mSentinel
.
mAbove
=
nullptr
;
mLength
+
=
aList
-
>
mLength
;
aList
-
>
mLength
=
0
;
}
}
void
AppendToBottom
(
nsDisplayList
*
aList
)
{
if
(
aList
-
>
mSentinel
.
mAbove
)
{
aList
-
>
mTop
-
>
mAbove
=
mSentinel
.
mAbove
;
mSentinel
.
mAbove
=
aList
-
>
mSentinel
.
mAbove
;
if
(
mTop
=
=
&
mSentinel
)
{
mTop
=
aList
-
>
mTop
;
}
aList
-
>
mTop
=
&
aList
-
>
mSentinel
;
aList
-
>
mSentinel
.
mAbove
=
nullptr
;
mLength
+
=
aList
-
>
mLength
;
aList
-
>
mLength
=
0
;
}
}
nsDisplayItem
*
RemoveBottom
(
)
;
void
DeleteAll
(
nsDisplayListBuilder
*
aBuilder
)
;
nsDisplayItem
*
GetTop
(
)
const
{
return
mTop
!
=
&
mSentinel
?
static_cast
<
nsDisplayItem
*
>
(
mTop
)
:
nullptr
;
}
nsDisplayItem
*
GetBottom
(
)
const
{
return
mSentinel
.
mAbove
;
}
bool
IsEmpty
(
)
const
{
return
mTop
=
=
&
mSentinel
;
}
uint32_t
Count
(
)
const
{
return
mLength
;
}
void
SortByZOrder
(
)
;
void
SortByContentOrder
(
nsIContent
*
aCommonAncestor
)
;
template
<
typename
Item
typename
Comparator
>
void
Sort
(
const
Comparator
&
aComparator
)
{
AutoTArray
<
Item
20
>
items
;
while
(
nsDisplayItem
*
item
=
RemoveBottom
(
)
)
{
items
.
AppendElement
(
Item
(
item
)
)
;
}
std
:
:
stable_sort
(
items
.
begin
(
)
items
.
end
(
)
aComparator
)
;
for
(
Item
&
item
:
items
)
{
AppendToTop
(
item
)
;
}
}
bool
ComputeVisibilityForSublist
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
const
nsRect
&
aListVisibleBounds
)
;
bool
ComputeVisibilityForRoot
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
;
bool
IsOpaque
(
)
const
{
return
mIsOpaque
;
}
bool
NeedsTransparentSurface
(
)
const
{
return
mForceTransparentSurface
;
}
enum
{
PAINT_DEFAULT
=
0
PAINT_USE_WIDGET_LAYERS
=
0x01
PAINT_EXISTING_TRANSACTION
=
0x04
PAINT_NO_COMPOSITE
=
0x08
PAINT_COMPRESSED
=
0x10
PAINT_IDENTICAL_DISPLAY_LIST
=
0x20
}
;
already_AddRefed
<
LayerManager
>
PaintRoot
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
uint32_t
aFlags
)
;
mozilla
:
:
FrameLayerBuilder
*
BuildLayers
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aLayerManager
uint32_t
aFlags
bool
aIsWidgetTransaction
)
;
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
)
const
;
nsRect
GetClippedBoundsWithRespectToASR
(
nsDisplayListBuilder
*
aBuilder
const
ActiveScrolledRoot
*
aASR
nsRect
*
aVisibleRect
=
nullptr
)
const
;
void
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
nsDisplayItem
:
:
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
const
;
nsRect
GetVisibleRect
(
)
const
;
void
SetIsOpaque
(
)
{
mIsOpaque
=
true
;
}
void
SetNeedsTransparentSurface
(
)
{
mForceTransparentSurface
=
true
;
}
void
RestoreState
(
)
{
mIsOpaque
=
false
;
mForceTransparentSurface
=
false
;
}
private
:
nsDisplayItemLink
mSentinel
;
nsDisplayItemLink
*
mTop
;
uint32_t
mLength
;
bool
mIsOpaque
;
bool
mForceTransparentSurface
;
}
;
class
nsDisplayListSet
{
public
:
nsDisplayList
*
BorderBackground
(
)
const
{
return
mBorderBackground
;
}
nsDisplayList
*
BlockBorderBackgrounds
(
)
const
{
return
mBlockBorderBackgrounds
;
}
nsDisplayList
*
Floats
(
)
const
{
return
mFloats
;
}
nsDisplayList
*
PositionedDescendants
(
)
const
{
return
mPositioned
;
}
nsDisplayList
*
Outlines
(
)
const
{
return
mOutlines
;
}
nsDisplayList
*
Content
(
)
const
{
return
mContent
;
}
void
DeleteAll
(
nsDisplayListBuilder
*
aBuilder
)
{
BorderBackground
(
)
-
>
DeleteAll
(
aBuilder
)
;
BlockBorderBackgrounds
(
)
-
>
DeleteAll
(
aBuilder
)
;
Floats
(
)
-
>
DeleteAll
(
aBuilder
)
;
PositionedDescendants
(
)
-
>
DeleteAll
(
aBuilder
)
;
Outlines
(
)
-
>
DeleteAll
(
aBuilder
)
;
Content
(
)
-
>
DeleteAll
(
aBuilder
)
;
}
nsDisplayListSet
(
nsDisplayList
*
aBorderBackground
nsDisplayList
*
aBlockBorderBackgrounds
nsDisplayList
*
aFloats
nsDisplayList
*
aContent
nsDisplayList
*
aPositionedDescendants
nsDisplayList
*
aOutlines
)
:
mBorderBackground
(
aBorderBackground
)
mBlockBorderBackgrounds
(
aBlockBorderBackgrounds
)
mFloats
(
aFloats
)
mContent
(
aContent
)
mPositioned
(
aPositionedDescendants
)
mOutlines
(
aOutlines
)
{
}
nsDisplayListSet
(
const
nsDisplayListSet
&
aLists
nsDisplayList
*
aBorderBackground
)
:
mBorderBackground
(
aBorderBackground
)
mBlockBorderBackgrounds
(
aLists
.
BlockBorderBackgrounds
(
)
)
mFloats
(
aLists
.
Floats
(
)
)
mContent
(
aLists
.
Content
(
)
)
mPositioned
(
aLists
.
PositionedDescendants
(
)
)
mOutlines
(
aLists
.
Outlines
(
)
)
{
}
void
MoveTo
(
const
nsDisplayListSet
&
aDestination
)
const
;
private
:
void
*
operator
new
(
size_t
sz
)
CPP_THROW_NEW
;
protected
:
nsDisplayList
*
mBorderBackground
;
nsDisplayList
*
mBlockBorderBackgrounds
;
nsDisplayList
*
mFloats
;
nsDisplayList
*
mContent
;
nsDisplayList
*
mPositioned
;
nsDisplayList
*
mOutlines
;
}
;
struct
nsDisplayListCollection
:
public
nsDisplayListSet
{
explicit
nsDisplayListCollection
(
nsDisplayListBuilder
*
aBuilder
)
:
nsDisplayListSet
(
&
mLists
[
0
]
&
mLists
[
1
]
&
mLists
[
2
]
&
mLists
[
3
]
&
mLists
[
4
]
&
mLists
[
5
]
)
{
}
explicit
nsDisplayListCollection
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aBorderBackground
)
:
nsDisplayListSet
(
aBorderBackground
&
mLists
[
1
]
&
mLists
[
2
]
&
mLists
[
3
]
&
mLists
[
4
]
&
mLists
[
5
]
)
{
}
void
SortAllByContentOrder
(
nsIContent
*
aCommonAncestor
)
{
for
(
int32_t
i
=
0
;
i
<
6
;
+
+
i
)
{
mLists
[
i
]
.
SortByContentOrder
(
aCommonAncestor
)
;
}
}
private
:
void
*
operator
new
(
size_t
sz
)
CPP_THROW_NEW
;
nsDisplayList
mLists
[
6
]
;
}
;
class
nsDisplayImageContainer
:
public
nsDisplayItem
{
public
:
typedef
mozilla
:
:
LayerIntPoint
LayerIntPoint
;
typedef
mozilla
:
:
LayoutDeviceRect
LayoutDeviceRect
;
typedef
mozilla
:
:
layers
:
:
ImageContainer
ImageContainer
;
typedef
mozilla
:
:
layers
:
:
ImageLayer
ImageLayer
;
nsDisplayImageContainer
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
:
nsDisplayItem
(
aBuilder
aFrame
)
{
}
virtual
bool
CanOptimizeToImageLayer
(
LayerManager
*
aManager
nsDisplayListBuilder
*
aBuilder
)
;
already_AddRefed
<
ImageContainer
>
GetContainer
(
LayerManager
*
aManager
nsDisplayListBuilder
*
aBuilder
)
;
void
ConfigureLayer
(
ImageLayer
*
aLayer
const
ContainerLayerParameters
&
aParameters
)
;
virtual
void
UpdateDrawResult
(
mozilla
:
:
image
:
:
ImgDrawResult
aResult
)
=
0
;
virtual
already_AddRefed
<
imgIContainer
>
GetImage
(
)
=
0
;
virtual
nsRect
GetDestRect
(
)
const
=
0
;
virtual
bool
SupportsOptimizingToImage
(
)
const
override
{
return
true
;
}
}
;
class
nsDisplayGeneric
:
public
nsDisplayItem
{
public
:
typedef
void
(
*
PaintCallback
)
(
nsIFrame
*
aFrame
DrawTarget
*
aDrawTarget
const
nsRect
&
aDirtyRect
nsPoint
aFramePt
)
;
typedef
void
(
*
OldPaintCallback
)
(
nsIFrame
*
aFrame
gfxContext
*
aCtx
const
nsRect
&
aDirtyRect
nsPoint
aFramePt
)
;
nsDisplayGeneric
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
PaintCallback
aPaint
const
char
*
aName
DisplayItemType
aType
)
:
nsDisplayItem
(
aBuilder
aFrame
)
mPaint
(
aPaint
)
mOldPaint
(
nullptr
)
mName
(
aName
)
mType
(
aType
)
{
MOZ_COUNT_CTOR
(
nsDisplayGeneric
)
;
}
nsDisplayGeneric
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
OldPaintCallback
aOldPaint
const
char
*
aName
DisplayItemType
aType
)
:
nsDisplayItem
(
aBuilder
aFrame
)
mPaint
(
nullptr
)
mOldPaint
(
aOldPaint
)
mName
(
aName
)
mType
(
aType
)
{
MOZ_COUNT_CTOR
(
nsDisplayGeneric
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayGeneric
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayGeneric
)
;
}
#
endif
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
{
MOZ_ASSERT
(
!
!
mPaint
!
=
!
!
mOldPaint
)
;
if
(
mPaint
)
{
mPaint
(
mFrame
aCtx
-
>
GetDrawTarget
(
)
mVisibleRect
ToReferenceFrame
(
)
)
;
}
else
{
mOldPaint
(
mFrame
aCtx
mVisibleRect
ToReferenceFrame
(
)
)
;
}
}
virtual
const
char
*
Name
(
)
const
override
{
return
mName
;
}
virtual
DisplayItemType
GetType
(
)
const
override
{
return
mType
;
}
virtual
void
Destroy
(
nsDisplayListBuilder
*
aBuilder
)
override
{
this
-
>
~
nsDisplayGeneric
(
)
;
aBuilder
-
>
Destroy
(
DisplayItemType
:
:
TYPE_GENERIC
this
)
;
}
protected
:
void
*
operator
new
(
size_t
aSize
nsDisplayListBuilder
*
aBuilder
)
{
return
aBuilder
-
>
Allocate
(
aSize
DisplayItemType
:
:
TYPE_GENERIC
)
;
}
template
<
typename
T
typename
.
.
.
Args
>
friend
T
*
MakeDisplayItem
(
nsDisplayListBuilder
*
aBuilder
Args
&
&
.
.
.
aArgs
)
;
PaintCallback
mPaint
;
OldPaintCallback
mOldPaint
;
const
char
*
mName
;
DisplayItemType
mType
;
}
;
#
if
defined
(
MOZ_REFLOW_PERF_DSP
)
&
&
defined
(
MOZ_REFLOW_PERF
)
class
nsDisplayReflowCount
:
public
nsDisplayItem
{
public
:
nsDisplayReflowCount
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
char
*
aFrameName
uint32_t
aColor
=
0
)
:
nsDisplayItem
(
aBuilder
aFrame
)
mFrameName
(
aFrameName
)
mColor
(
aColor
)
{
MOZ_COUNT_CTOR
(
nsDisplayReflowCount
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayReflowCount
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayReflowCount
)
;
}
#
endif
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
{
mFrame
-
>
PresShell
(
)
-
>
PaintCount
(
mFrameName
aCtx
mFrame
-
>
PresContext
(
)
mFrame
ToReferenceFrame
(
)
mColor
)
;
}
NS_DISPLAY_DECL_NAME
(
"
nsDisplayReflowCount
"
TYPE_REFLOW_COUNT
)
protected
:
const
char
*
mFrameName
;
nscolor
mColor
;
}
;
#
define
DO_GLOBAL_REFLOW_COUNT_DSP
(
_name
)
\
PR_BEGIN_MACRO
\
if
(
!
aBuilder
-
>
IsBackgroundOnly
(
)
&
&
!
aBuilder
-
>
IsForEventDelivery
(
)
&
&
\
PresShell
(
)
-
>
IsPaintingFrameCounts
(
)
)
{
\
aLists
.
Outlines
(
)
-
>
AppendToTop
(
\
MakeDisplayItem
<
nsDisplayReflowCount
>
(
aBuilder
this
_name
)
)
;
\
}
\
PR_END_MACRO
#
define
DO_GLOBAL_REFLOW_COUNT_DSP_COLOR
(
_name
_color
)
\
PR_BEGIN_MACRO
\
if
(
!
aBuilder
-
>
IsBackgroundOnly
(
)
&
&
!
aBuilder
-
>
IsForEventDelivery
(
)
&
&
\
PresShell
(
)
-
>
IsPaintingFrameCounts
(
)
)
{
\
aLists
.
Outlines
(
)
-
>
AppendToTop
(
\
MakeDisplayItem
<
nsDisplayReflowCount
>
(
aBuilder
this
_name
_color
)
)
;
\
}
\
PR_END_MACRO
#
define
DECL_DO_GLOBAL_REFLOW_COUNT_DSP
(
_class
_super
)
\
void
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
\
const
nsRect
&
aDirtyRect
\
const
nsDisplayListSet
&
aLists
)
{
\
DO_GLOBAL_REFLOW_COUNT_DSP
(
#
_class
)
;
\
_super
:
:
BuildDisplayList
(
aBuilder
aDirtyRect
aLists
)
;
\
}
#
else
#
define
DO_GLOBAL_REFLOW_COUNT_DSP
(
_name
)
#
define
DO_GLOBAL_REFLOW_COUNT_DSP_COLOR
(
_name
_color
)
#
define
DECL_DO_GLOBAL_REFLOW_COUNT_DSP
(
_class
_super
)
#
endif
class
nsDisplayCaret
:
public
nsDisplayItem
{
public
:
nsDisplayCaret
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aCaretFrame
)
;
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayCaret
(
)
;
#
endif
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
;
NS_DISPLAY_DECL_NAME
(
"
Caret
"
TYPE_CARET
)
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
;
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
protected
:
RefPtr
<
nsCaret
>
mCaret
;
nsRect
mBounds
;
}
;
class
nsDisplayBorder
:
public
nsDisplayItem
{
public
:
nsDisplayBorder
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
;
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayBorder
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayBorder
)
;
}
#
endif
virtual
bool
IsInvisibleInRect
(
const
nsRect
&
aRect
)
const
override
;
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
;
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
;
NS_DISPLAY_DECL_NAME
(
"
Border
"
TYPE_BORDER
)
virtual
nsDisplayItemGeometry
*
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
override
;
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
;
virtual
nsRegion
GetTightBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
{
*
aSnap
=
true
;
return
CalculateBounds
<
nsRegion
>
(
*
mFrame
-
>
StyleBorder
(
)
)
;
}
protected
:
void
CreateBorderImageWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResource
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
;
template
<
typename
T
>
T
CalculateBounds
(
const
nsStyleBorder
&
aStyleBorder
)
const
{
nsRect
borderBounds
(
ToReferenceFrame
(
)
mFrame
-
>
GetSize
(
)
)
;
if
(
aStyleBorder
.
IsBorderImageLoaded
(
)
)
{
borderBounds
.
Inflate
(
aStyleBorder
.
GetImageOutset
(
)
)
;
return
borderBounds
;
}
else
{
nsMargin
border
=
aStyleBorder
.
GetComputedBorder
(
)
;
T
result
;
if
(
border
.
top
>
0
)
{
result
=
nsRect
(
borderBounds
.
X
(
)
borderBounds
.
Y
(
)
borderBounds
.
Width
(
)
border
.
top
)
;
}
if
(
border
.
right
>
0
)
{
result
.
OrWith
(
nsRect
(
borderBounds
.
XMost
(
)
-
border
.
right
borderBounds
.
Y
(
)
border
.
right
borderBounds
.
Height
(
)
)
)
;
}
if
(
border
.
bottom
>
0
)
{
result
.
OrWith
(
nsRect
(
borderBounds
.
X
(
)
borderBounds
.
YMost
(
)
-
border
.
bottom
borderBounds
.
Width
(
)
border
.
bottom
)
)
;
}
if
(
border
.
left
>
0
)
{
result
.
OrWith
(
nsRect
(
borderBounds
.
X
(
)
borderBounds
.
Y
(
)
border
.
left
borderBounds
.
Height
(
)
)
)
;
}
nscoord
radii
[
8
]
;
if
(
mFrame
-
>
GetBorderRadii
(
radii
)
)
{
if
(
border
.
left
>
0
|
|
border
.
top
>
0
)
{
nsSize
cornerSize
(
radii
[
mozilla
:
:
eCornerTopLeftX
]
radii
[
mozilla
:
:
eCornerTopLeftY
]
)
;
result
.
OrWith
(
nsRect
(
borderBounds
.
TopLeft
(
)
cornerSize
)
)
;
}
if
(
border
.
top
>
0
|
|
border
.
right
>
0
)
{
nsSize
cornerSize
(
radii
[
mozilla
:
:
eCornerTopRightX
]
radii
[
mozilla
:
:
eCornerTopRightY
]
)
;
result
.
OrWith
(
nsRect
(
borderBounds
.
TopRight
(
)
-
nsPoint
(
cornerSize
.
width
0
)
cornerSize
)
)
;
}
if
(
border
.
right
>
0
|
|
border
.
bottom
>
0
)
{
nsSize
cornerSize
(
radii
[
mozilla
:
:
eCornerBottomRightX
]
radii
[
mozilla
:
:
eCornerBottomRightY
]
)
;
result
.
OrWith
(
nsRect
(
borderBounds
.
BottomRight
(
)
-
nsPoint
(
cornerSize
.
width
cornerSize
.
height
)
cornerSize
)
)
;
}
if
(
border
.
bottom
>
0
|
|
border
.
left
>
0
)
{
nsSize
cornerSize
(
radii
[
mozilla
:
:
eCornerBottomLeftX
]
radii
[
mozilla
:
:
eCornerBottomLeftY
]
)
;
result
.
OrWith
(
nsRect
(
borderBounds
.
BottomLeft
(
)
-
nsPoint
(
0
cornerSize
.
height
)
cornerSize
)
)
;
}
}
return
result
;
}
}
mozilla
:
:
Array
<
mozilla
:
:
gfx
:
:
Color
4
>
mColors
;
mozilla
:
:
Array
<
mozilla
:
:
LayerCoord
4
>
mWidths
;
mozilla
:
:
Array
<
mozilla
:
:
LayerSize
4
>
mCorners
;
mozilla
:
:
Array
<
uint8_t
4
>
mBorderStyles
;
mozilla
:
:
LayerRect
mRect
;
mozilla
:
:
Maybe
<
nsCSSBorderRenderer
>
mBorderRenderer
;
mozilla
:
:
Maybe
<
nsCSSBorderImageRenderer
>
mBorderImageRenderer
;
nsRect
mBounds
;
bool
mBorderIsEmpty
;
}
;
class
nsDisplaySolidColorBase
:
public
nsDisplayItem
{
public
:
nsDisplaySolidColorBase
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nscolor
aColor
)
:
nsDisplayItem
(
aBuilder
aFrame
)
mColor
(
aColor
)
{
}
virtual
nsDisplayItemGeometry
*
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
new
nsDisplaySolidColorGeometry
(
this
aBuilder
mColor
)
;
}
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
{
const
nsDisplaySolidColorGeometry
*
geometry
=
static_cast
<
const
nsDisplaySolidColorGeometry
*
>
(
aGeometry
)
;
if
(
mColor
!
=
geometry
-
>
mColor
)
{
bool
dummy
;
aInvalidRegion
-
>
Or
(
geometry
-
>
mBounds
GetBounds
(
aBuilder
&
dummy
)
)
;
return
;
}
ComputeInvalidationRegionDifference
(
aBuilder
geometry
aInvalidRegion
)
;
}
virtual
nsRegion
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
{
*
aSnap
=
false
;
nsRegion
result
;
if
(
NS_GET_A
(
mColor
)
=
=
255
)
{
result
=
GetBounds
(
aBuilder
aSnap
)
;
}
return
result
;
}
virtual
mozilla
:
:
Maybe
<
nscolor
>
IsUniform
(
nsDisplayListBuilder
*
aBuilder
)
const
override
{
return
mozilla
:
:
Some
(
mColor
)
;
}
protected
:
nscolor
mColor
;
}
;
class
nsDisplaySolidColor
:
public
nsDisplaySolidColorBase
{
public
:
nsDisplaySolidColor
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
nsRect
&
aBounds
nscolor
aColor
bool
aCanBeReused
=
true
)
:
nsDisplaySolidColorBase
(
aBuilder
aFrame
aColor
)
mBounds
(
aBounds
)
mCanBeReused
(
aCanBeReused
)
{
NS_ASSERTION
(
NS_GET_A
(
aColor
)
>
0
"
Don
'
t
create
invisible
nsDisplaySolidColors
!
"
)
;
MOZ_COUNT_CTOR
(
nsDisplaySolidColor
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplaySolidColor
(
)
{
MOZ_COUNT_DTOR
(
nsDisplaySolidColor
)
;
}
#
endif
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
;
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
;
virtual
void
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
override
;
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
NS_DISPLAY_DECL_NAME
(
"
SolidColor
"
TYPE_SOLID_COLOR
)
virtual
bool
CanBeReused
(
)
const
override
{
return
mCanBeReused
;
}
int32_t
ZIndex
(
)
const
override
{
if
(
mOverrideZIndex
)
{
return
mOverrideZIndex
.
value
(
)
;
}
return
nsDisplaySolidColorBase
:
:
ZIndex
(
)
;
}
void
SetOverrideZIndex
(
int32_t
aZIndex
)
{
mOverrideZIndex
=
mozilla
:
:
Some
(
aZIndex
)
;
}
private
:
nsRect
mBounds
;
bool
mCanBeReused
;
mozilla
:
:
Maybe
<
int32_t
>
mOverrideZIndex
;
}
;
class
nsDisplaySolidColorRegion
:
public
nsDisplayItem
{
typedef
mozilla
:
:
gfx
:
:
Color
Color
;
public
:
nsDisplaySolidColorRegion
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
nsRegion
&
aRegion
nscolor
aColor
)
:
nsDisplayItem
(
aBuilder
aFrame
)
mRegion
(
aRegion
)
mColor
(
Color
:
:
FromABGR
(
aColor
)
)
{
NS_ASSERTION
(
NS_GET_A
(
aColor
)
>
0
"
Don
'
t
create
invisible
nsDisplaySolidColorRegions
!
"
)
;
MOZ_COUNT_CTOR
(
nsDisplaySolidColorRegion
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplaySolidColorRegion
(
)
{
MOZ_COUNT_DTOR
(
nsDisplaySolidColorRegion
)
;
}
#
endif
virtual
nsDisplayItemGeometry
*
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
new
nsDisplaySolidColorRegionGeometry
(
this
aBuilder
mRegion
mColor
)
;
}
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
{
const
nsDisplaySolidColorRegionGeometry
*
geometry
=
static_cast
<
const
nsDisplaySolidColorRegionGeometry
*
>
(
aGeometry
)
;
if
(
mColor
=
=
geometry
-
>
mColor
)
{
aInvalidRegion
-
>
Xor
(
geometry
-
>
mRegion
mRegion
)
;
}
else
{
aInvalidRegion
-
>
Or
(
geometry
-
>
mRegion
.
GetBounds
(
)
mRegion
.
GetBounds
(
)
)
;
}
}
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
NS_DISPLAY_DECL_NAME
(
"
SolidColorRegion
"
TYPE_SOLID_COLOR_REGION
)
protected
:
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
;
virtual
void
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
override
;
private
:
nsRegion
mRegion
;
Color
mColor
;
}
;
class
nsDisplayBackgroundImage
:
public
nsDisplayImageContainer
{
public
:
typedef
mozilla
:
:
StyleGeometryBox
StyleGeometryBox
;
struct
InitData
{
nsDisplayListBuilder
*
builder
;
nsIFrame
*
frame
;
const
nsStyleBackground
*
backgroundStyle
;
nsCOMPtr
<
imgIContainer
>
image
;
nsRect
backgroundRect
;
nsRect
fillArea
;
nsRect
destArea
;
uint32_t
layer
;
bool
isRasterImage
;
bool
shouldFixToViewport
;
}
;
static
InitData
GetInitData
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
uint32_t
aLayer
const
nsRect
&
aBackgroundRect
const
nsStyleBackground
*
aBackgroundStyle
)
;
explicit
nsDisplayBackgroundImage
(
nsDisplayListBuilder
*
aBuilder
const
InitData
&
aInitData
nsIFrame
*
aFrameForBounds
=
nullptr
)
;
virtual
~
nsDisplayBackgroundImage
(
)
;
static
bool
AppendBackgroundItemsToTop
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
nsRect
&
aBackgroundRect
nsDisplayList
*
aList
bool
aAllowWillPaintBorderOptimization
=
true
nsStyleContext
*
aStyleContext
=
nullptr
const
nsRect
&
aBackgroundOriginRect
=
nsRect
(
)
nsIFrame
*
aSecondaryReferenceFrame
=
nullptr
)
;
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
;
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
virtual
void
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
override
;
virtual
bool
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
override
;
virtual
nsRegion
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
mozilla
:
:
Maybe
<
nscolor
>
IsUniform
(
nsDisplayListBuilder
*
aBuilder
)
const
override
;
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
;
virtual
uint32_t
GetPerFrameKey
(
)
const
override
{
return
(
mLayer
<
<
TYPE_BITS
)
|
nsDisplayItem
:
:
GetPerFrameKey
(
)
;
}
NS_DISPLAY_DECL_NAME
(
"
Background
"
TYPE_BACKGROUND
)
nsRect
GetPositioningArea
(
)
const
;
bool
RenderingMightDependOnPositioningAreaSizeChange
(
)
const
;
virtual
nsDisplayItemGeometry
*
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
new
nsDisplayBackgroundGeometry
(
this
aBuilder
)
;
}
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
;
virtual
bool
CanOptimizeToImageLayer
(
LayerManager
*
aManager
nsDisplayListBuilder
*
aBuilder
)
override
;
virtual
already_AddRefed
<
imgIContainer
>
GetImage
(
)
override
;
virtual
nsRect
GetDestRect
(
)
const
override
;
virtual
void
UpdateDrawResult
(
mozilla
:
:
image
:
:
ImgDrawResult
aResult
)
override
{
nsDisplayBackgroundGeometry
:
:
UpdateDrawResult
(
this
aResult
)
;
}
static
nsRegion
GetInsideClipRegion
(
const
nsDisplayItem
*
aItem
StyleGeometryBox
aClip
const
nsRect
&
aRect
const
nsRect
&
aBackgroundRect
)
;
virtual
bool
ShouldFixToViewport
(
nsDisplayListBuilder
*
aBuilder
)
const
override
{
return
mShouldFixToViewport
;
}
virtual
nsIFrame
*
GetDependentFrame
(
)
override
{
return
mDependentFrame
;
}
void
SetDependentFrame
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
{
if
(
!
aBuilder
-
>
IsRetainingDisplayList
(
)
)
{
return
;
}
mDependentFrame
=
aFrame
;
if
(
aFrame
)
{
mDependentFrame
-
>
AddDisplayItem
(
this
)
;
}
}
virtual
void
RemoveFrame
(
nsIFrame
*
aFrame
)
override
{
if
(
aFrame
=
=
mDependentFrame
)
{
mDependentFrame
=
nullptr
;
}
nsDisplayItem
:
:
RemoveFrame
(
aFrame
)
;
}
protected
:
typedef
class
mozilla
:
:
layers
:
:
ImageContainer
ImageContainer
;
typedef
class
mozilla
:
:
layers
:
:
ImageLayer
ImageLayer
;
bool
CanBuildWebRenderDisplayItems
(
LayerManager
*
aManager
)
;
bool
TryOptimizeToImageLayer
(
LayerManager
*
aManager
nsDisplayListBuilder
*
aBuilder
)
;
nsRect
GetBoundsInternal
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrameForBounds
=
nullptr
)
;
void
PaintInternal
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
const
nsRect
&
aBounds
nsRect
*
aClipRect
)
;
enum
ImageLayerization
{
WHENEVER_POSSIBLE
ONLY_FOR_SCALING
NO_LAYER_NEEDED
}
;
ImageLayerization
ShouldCreateOwnLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
)
;
const
nsStyleBackground
*
mBackgroundStyle
;
nsCOMPtr
<
imgIContainer
>
mImage
;
nsIFrame
*
mDependentFrame
;
nsRect
mBackgroundRect
;
nsRect
mFillRect
;
nsRect
mDestRect
;
nsRect
mBounds
;
uint32_t
mLayer
;
bool
mIsRasterImage
;
bool
mShouldFixToViewport
;
uint32_t
mImageFlags
;
}
;
enum
class
TableType
:
uint8_t
{
TABLE
TABLE_COL
TABLE_COL_GROUP
TABLE_ROW
TABLE_ROW_GROUP
TABLE_CELL
TABLE_TYPE_MAX
}
;
enum
class
TableTypeBits
:
uint8_t
{
COUNT
=
3
}
;
static_assert
(
static_cast
<
uint8_t
>
(
TableType
:
:
TABLE_TYPE_MAX
)
<
(
1
<
<
(
static_cast
<
uint8_t
>
(
TableTypeBits
:
:
COUNT
)
+
1
)
)
"
TableType
cannot
fit
with
TableTypeBits
:
:
COUNT
"
)
;
TableType
GetTableTypeFromFrame
(
nsIFrame
*
aFrame
)
;
class
nsDisplayTableBackgroundImage
:
public
nsDisplayBackgroundImage
{
public
:
nsDisplayTableBackgroundImage
(
nsDisplayListBuilder
*
aBuilder
const
InitData
&
aInitData
nsIFrame
*
aCellFrame
)
;
virtual
uint32_t
GetPerFrameKey
(
)
const
override
{
return
(
mLayer
<
<
(
TYPE_BITS
+
static_cast
<
uint8_t
>
(
TableTypeBits
:
:
COUNT
)
)
)
|
(
static_cast
<
uint8_t
>
(
mTableType
)
<
<
TYPE_BITS
)
|
nsDisplayItem
:
:
GetPerFrameKey
(
)
;
}
virtual
bool
IsInvalid
(
nsRect
&
aRect
)
const
override
;
virtual
nsIFrame
*
FrameForInvalidation
(
)
const
override
{
return
mStyleFrame
;
}
NS_DISPLAY_DECL_NAME
(
"
TableBackgroundImage
"
TYPE_TABLE_BACKGROUND_IMAGE
)
protected
:
virtual
nsIFrame
*
StyleFrame
(
)
const
override
{
return
mStyleFrame
;
}
nsIFrame
*
mStyleFrame
;
TableType
mTableType
;
}
;
class
nsDisplayThemedBackground
:
public
nsDisplayItem
{
public
:
nsDisplayThemedBackground
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
nsRect
&
aBackgroundRect
)
;
virtual
~
nsDisplayThemedBackground
(
)
;
void
Init
(
nsDisplayListBuilder
*
aBuilder
)
;
void
Destroy
(
nsDisplayListBuilder
*
aBuilder
)
override
{
aBuilder
-
>
UnregisterThemeGeometry
(
this
)
;
nsDisplayItem
:
:
Destroy
(
aBuilder
)
;
}
virtual
void
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
override
;
virtual
nsRegion
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
mozilla
:
:
Maybe
<
nscolor
>
IsUniform
(
nsDisplayListBuilder
*
aBuilder
)
const
override
;
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
virtual
bool
MustPaintOnContentSide
(
)
const
override
{
return
true
;
}
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
;
NS_DISPLAY_DECL_NAME
(
"
ThemedBackground
"
TYPE_THEMED_BACKGROUND
)
nsRect
GetPositioningArea
(
)
const
;
bool
IsWindowActive
(
)
const
;
virtual
nsDisplayItemGeometry
*
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
new
nsDisplayThemedBackgroundGeometry
(
this
aBuilder
)
;
}
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
;
virtual
void
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
override
;
protected
:
nsRect
GetBoundsInternal
(
)
;
void
PaintInternal
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
const
nsRect
&
aBounds
nsRect
*
aClipRect
)
;
nsRect
mBackgroundRect
;
nsRect
mBounds
;
nsITheme
:
:
Transparency
mThemeTransparency
;
uint8_t
mAppearance
;
}
;
class
nsDisplayTableThemedBackground
:
public
nsDisplayThemedBackground
{
public
:
nsDisplayTableThemedBackground
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
nsRect
&
aBackgroundRect
nsIFrame
*
aAncestorFrame
)
:
nsDisplayThemedBackground
(
aBuilder
aFrame
aBackgroundRect
)
mAncestorFrame
(
aAncestorFrame
)
mTableType
(
GetTableTypeFromFrame
(
aAncestorFrame
)
)
{
}
virtual
uint32_t
GetPerFrameKey
(
)
const
override
{
return
(
static_cast
<
uint8_t
>
(
mTableType
)
<
<
TYPE_BITS
)
|
nsDisplayItem
:
:
GetPerFrameKey
(
)
;
}
virtual
nsIFrame
*
FrameForInvalidation
(
)
const
override
{
return
mAncestorFrame
;
}
NS_DISPLAY_DECL_NAME
(
"
TableThemedBackground
"
TYPE_TABLE_THEMED_BACKGROUND_IMAGE
)
protected
:
virtual
nsIFrame
*
StyleFrame
(
)
const
override
{
return
mAncestorFrame
;
}
nsIFrame
*
mAncestorFrame
;
TableType
mTableType
;
}
;
class
nsDisplayBackgroundColor
:
public
nsDisplayItem
{
typedef
mozilla
:
:
gfx
:
:
Color
Color
;
public
:
nsDisplayBackgroundColor
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
nsRect
&
aBackgroundRect
const
nsStyleBackground
*
aBackgroundStyle
nscolor
aColor
)
:
nsDisplayItem
(
aBuilder
aFrame
)
mBackgroundRect
(
aBackgroundRect
)
mBackgroundStyle
(
aBackgroundStyle
)
mDependentFrame
(
nullptr
)
mColor
(
Color
:
:
FromABGR
(
aColor
)
)
{
mState
.
mColor
=
mColor
;
}
virtual
~
nsDisplayBackgroundColor
(
)
{
if
(
mDependentFrame
)
{
mDependentFrame
-
>
RemoveDisplayItem
(
this
)
;
}
}
virtual
void
RestoreState
(
)
override
{
nsDisplayItem
:
:
RestoreState
(
)
;
mColor
=
mState
.
mColor
;
}
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
;
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
;
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
virtual
nsRegion
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
mozilla
:
:
Maybe
<
nscolor
>
IsUniform
(
nsDisplayListBuilder
*
aBuilder
)
const
override
;
virtual
void
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
override
;
virtual
void
ApplyOpacity
(
nsDisplayListBuilder
*
aBuilder
float
aOpacity
const
DisplayItemClipChain
*
aClip
)
override
;
virtual
bool
CanApplyOpacity
(
)
const
override
;
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
{
*
aSnap
=
true
;
return
mBackgroundRect
;
}
virtual
nsDisplayItemGeometry
*
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
new
nsDisplaySolidColorGeometry
(
this
aBuilder
mColor
.
ToABGR
(
)
)
;
}
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
{
const
nsDisplaySolidColorGeometry
*
geometry
=
static_cast
<
const
nsDisplaySolidColorGeometry
*
>
(
aGeometry
)
;
if
(
mColor
.
ToABGR
(
)
!
=
geometry
-
>
mColor
)
{
bool
dummy
;
aInvalidRegion
-
>
Or
(
geometry
-
>
mBounds
GetBounds
(
aBuilder
&
dummy
)
)
;
return
;
}
ComputeInvalidationRegionDifference
(
aBuilder
geometry
aInvalidRegion
)
;
}
virtual
nsIFrame
*
GetDependentFrame
(
)
override
{
return
mDependentFrame
;
}
void
SetDependentFrame
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
{
if
(
!
aBuilder
-
>
IsRetainingDisplayList
(
)
)
{
return
;
}
mDependentFrame
=
aFrame
;
if
(
aFrame
)
{
mDependentFrame
-
>
AddDisplayItem
(
this
)
;
}
}
virtual
void
RemoveFrame
(
nsIFrame
*
aFrame
)
override
{
if
(
aFrame
=
=
mDependentFrame
)
{
mDependentFrame
=
nullptr
;
}
nsDisplayItem
:
:
RemoveFrame
(
aFrame
)
;
}
NS_DISPLAY_DECL_NAME
(
"
BackgroundColor
"
TYPE_BACKGROUND_COLOR
)
virtual
void
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
override
;
protected
:
const
nsRect
mBackgroundRect
;
const
nsStyleBackground
*
mBackgroundStyle
;
nsIFrame
*
mDependentFrame
;
mozilla
:
:
gfx
:
:
Color
mColor
;
struct
{
mozilla
:
:
gfx
:
:
Color
mColor
;
}
mState
;
}
;
class
nsDisplayTableBackgroundColor
:
public
nsDisplayBackgroundColor
{
public
:
nsDisplayTableBackgroundColor
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
nsRect
&
aBackgroundRect
const
nsStyleBackground
*
aBackgroundStyle
nscolor
aColor
nsIFrame
*
aAncestorFrame
)
:
nsDisplayBackgroundColor
(
aBuilder
aFrame
aBackgroundRect
aBackgroundStyle
aColor
)
mAncestorFrame
(
aAncestorFrame
)
mTableType
(
GetTableTypeFromFrame
(
aAncestorFrame
)
)
{
}
virtual
nsIFrame
*
FrameForInvalidation
(
)
const
override
{
return
mAncestorFrame
;
}
virtual
uint32_t
GetPerFrameKey
(
)
const
override
{
return
(
static_cast
<
uint8_t
>
(
mTableType
)
<
<
TYPE_BITS
)
|
nsDisplayItem
:
:
GetPerFrameKey
(
)
;
}
NS_DISPLAY_DECL_NAME
(
"
TableBackgroundColor
"
TYPE_TABLE_BACKGROUND_COLOR
)
protected
:
nsIFrame
*
mAncestorFrame
;
TableType
mTableType
;
}
;
class
nsDisplayClearBackground
:
public
nsDisplayItem
{
public
:
nsDisplayClearBackground
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
:
nsDisplayItem
(
aBuilder
aFrame
)
{
}
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
{
*
aSnap
=
true
;
return
nsRect
(
ToReferenceFrame
(
)
Frame
(
)
-
>
GetSize
(
)
)
;
}
virtual
nsRegion
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
{
*
aSnap
=
false
;
return
GetBounds
(
aBuilder
aSnap
)
;
}
virtual
mozilla
:
:
Maybe
<
nscolor
>
IsUniform
(
nsDisplayListBuilder
*
aBuilder
)
const
override
{
return
mozilla
:
:
Some
(
NS_RGBA
(
0
0
0
0
)
)
;
}
virtual
bool
ClearsBackground
(
)
const
override
{
return
true
;
}
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
{
return
mozilla
:
:
LAYER_ACTIVE_FORCE
;
}
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
NS_DISPLAY_DECL_NAME
(
"
ClearBackground
"
TYPE_CLEAR_BACKGROUND
)
}
;
class
nsDisplayBoxShadowOuter
final
:
public
nsDisplayItem
{
public
:
nsDisplayBoxShadowOuter
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
:
nsDisplayItem
(
aBuilder
aFrame
)
mOpacity
(
1
.
0f
)
{
MOZ_COUNT_CTOR
(
nsDisplayBoxShadowOuter
)
;
mBounds
=
GetBoundsInternal
(
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayBoxShadowOuter
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayBoxShadowOuter
)
;
}
#
endif
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
;
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
bool
IsInvisibleInRect
(
const
nsRect
&
aRect
)
const
override
;
virtual
bool
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
override
;
NS_DISPLAY_DECL_NAME
(
"
BoxShadowOuter
"
TYPE_BOX_SHADOW_OUTER
)
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
;
virtual
void
ApplyOpacity
(
nsDisplayListBuilder
*
aBuilder
float
aOpacity
const
DisplayItemClipChain
*
aClip
)
override
{
NS_ASSERTION
(
CanApplyOpacity
(
)
"
ApplyOpacity
should
be
allowed
"
)
;
mOpacity
=
aOpacity
;
IntersectClip
(
aBuilder
aClip
false
)
;
}
virtual
bool
CanApplyOpacity
(
)
const
override
{
return
true
;
}
virtual
void
RestoreState
(
)
override
{
nsDisplayItem
:
:
RestoreState
(
)
;
mVisibleRegion
.
SetEmpty
(
)
;
mOpacity
=
1
.
0f
;
}
virtual
nsDisplayItemGeometry
*
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
new
nsDisplayBoxShadowOuterGeometry
(
this
aBuilder
mOpacity
)
;
}
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
bool
CanBuildWebRenderDisplayItems
(
)
;
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
nsRect
GetBoundsInternal
(
)
;
private
:
nsRegion
mVisibleRegion
;
nsRect
mBounds
;
float
mOpacity
;
}
;
class
nsDisplayBoxShadowInner
:
public
nsDisplayItem
{
public
:
nsDisplayBoxShadowInner
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
:
nsDisplayItem
(
aBuilder
aFrame
)
{
MOZ_COUNT_CTOR
(
nsDisplayBoxShadowInner
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayBoxShadowInner
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayBoxShadowInner
)
;
}
#
endif
virtual
void
RestoreState
(
)
override
{
nsDisplayItem
:
:
RestoreState
(
)
;
mVisibleRegion
.
SetEmpty
(
)
;
}
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
;
virtual
bool
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
override
;
NS_DISPLAY_DECL_NAME
(
"
BoxShadowInner
"
TYPE_BOX_SHADOW_INNER
)
virtual
nsDisplayItemGeometry
*
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
new
nsDisplayBoxShadowInnerGeometry
(
this
aBuilder
)
;
}
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
{
const
nsDisplayBoxShadowInnerGeometry
*
geometry
=
static_cast
<
const
nsDisplayBoxShadowInnerGeometry
*
>
(
aGeometry
)
;
if
(
!
geometry
-
>
mPaddingRect
.
IsEqualInterior
(
GetPaddingRect
(
)
)
)
{
bool
snap
;
aInvalidRegion
-
>
Or
(
geometry
-
>
mBounds
GetBounds
(
aBuilder
&
snap
)
)
;
}
}
static
bool
CanCreateWebRenderCommands
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsPoint
aReferencePoint
)
;
static
void
CreateInsetBoxShadowWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
const
StackingContextHelper
&
aSc
nsRegion
&
aVisibleRegion
nsIFrame
*
aFrame
const
nsRect
aBorderRect
)
;
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
private
:
nsRegion
mVisibleRegion
;
}
;
class
nsDisplayOutline
:
public
nsDisplayItem
{
public
:
nsDisplayOutline
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
:
nsDisplayItem
(
aBuilder
aFrame
)
{
MOZ_COUNT_CTOR
(
nsDisplayOutline
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayOutline
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayOutline
)
;
}
#
endif
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
;
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
virtual
bool
IsInvisibleInRect
(
const
nsRect
&
aRect
)
const
override
;
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
;
NS_DISPLAY_DECL_NAME
(
"
Outline
"
TYPE_OUTLINE
)
mozilla
:
:
Maybe
<
nsCSSBorderRenderer
>
mBorderRenderer
;
}
;
class
nsDisplayEventReceiver
:
public
nsDisplayItem
{
public
:
nsDisplayEventReceiver
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
:
nsDisplayItem
(
aBuilder
aFrame
)
{
MOZ_COUNT_CTOR
(
nsDisplayEventReceiver
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayEventReceiver
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayEventReceiver
)
;
}
#
endif
void
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
override
;
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
NS_DISPLAY_DECL_NAME
(
"
EventReceiver
"
TYPE_EVENT_RECEIVER
)
}
;
class
nsDisplayCompositorHitTestInfo
:
public
nsDisplayEventReceiver
{
public
:
nsDisplayCompositorHitTestInfo
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
mozilla
:
:
gfx
:
:
CompositorHitTestInfo
aHitTestInfo
uint32_t
aIndex
=
0
const
mozilla
:
:
Maybe
<
nsRect
>
&
aArea
=
mozilla
:
:
Nothing
(
)
)
;
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayCompositorHitTestInfo
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayCompositorHitTestInfo
)
;
}
#
endif
mozilla
:
:
gfx
:
:
CompositorHitTestInfo
HitTestInfo
(
)
const
{
return
mHitTestInfo
;
}
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
void
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
override
;
uint32_t
GetPerFrameKey
(
)
const
override
;
int32_t
ZIndex
(
)
const
override
;
void
SetOverrideZIndex
(
int32_t
aZIndex
)
;
const
nsRect
&
Area
(
)
const
{
return
mArea
;
}
void
ApplyOpacity
(
nsDisplayListBuilder
*
aBuilder
float
aOpacity
const
DisplayItemClipChain
*
aClip
)
override
{
}
bool
CanApplyOpacity
(
)
const
override
{
return
true
;
}
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
{
*
aSnap
=
false
;
return
nsRect
(
)
;
}
NS_DISPLAY_DECL_NAME
(
"
CompositorHitTestInfo
"
TYPE_COMPOSITOR_HITTEST_INFO
)
private
:
mozilla
:
:
gfx
:
:
CompositorHitTestInfo
mHitTestInfo
;
mozilla
:
:
Maybe
<
mozilla
:
:
layers
:
:
FrameMetrics
:
:
ViewID
>
mScrollTarget
;
nsRect
mArea
;
uint32_t
mIndex
;
mozilla
:
:
Maybe
<
int32_t
>
mOverrideZIndex
;
int32_t
mAppUnitsPerDevPixel
;
}
;
class
nsDisplayLayerEventRegions
final
:
public
nsDisplayItem
{
public
:
nsDisplayLayerEventRegions
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
uint32_t
aIndex
=
0
)
:
nsDisplayItem
(
aBuilder
aFrame
)
mIndex
(
aIndex
)
{
MOZ_COUNT_CTOR
(
nsDisplayLayerEventRegions
)
;
}
virtual
void
Destroy
(
nsDisplayListBuilder
*
aBuilder
)
override
{
if
(
!
aBuilder
-
>
IsRetainingDisplayList
(
)
)
{
nsDisplayItem
:
:
Destroy
(
aBuilder
)
;
return
;
}
RemoveItemFromFrames
(
mHitRegion
)
;
RemoveItemFromFrames
(
mMaybeHitRegion
)
;
RemoveItemFromFrames
(
mDispatchToContentHitRegion
)
;
RemoveItemFromFrames
(
mNoActionRegion
)
;
RemoveItemFromFrames
(
mHorizontalPanRegion
)
;
RemoveItemFromFrames
(
mVerticalPanRegion
)
;
nsDisplayItem
:
:
Destroy
(
aBuilder
)
;
}
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
{
*
aSnap
=
false
;
return
nsRect
(
)
;
}
nsRect
GetHitRegionBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
{
*
aSnap
=
false
;
return
HitRegion
(
)
.
GetBounds
(
)
.
Union
(
MaybeHitRegion
(
)
.
GetBounds
(
)
)
;
}
virtual
void
ApplyOpacity
(
nsDisplayListBuilder
*
aBuilder
float
aOpacity
const
DisplayItemClipChain
*
aClip
)
override
{
NS_ASSERTION
(
CanApplyOpacity
(
)
"
ApplyOpacity
should
be
allowed
"
)
;
}
virtual
bool
CanApplyOpacity
(
)
const
override
{
return
true
;
}
NS_DISPLAY_DECL_NAME
(
"
LayerEventRegions
"
TYPE_LAYER_EVENT_REGIONS
)
void
AddFrame
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
;
void
AddInactiveScrollPort
(
nsIFrame
*
aFrame
const
nsRect
&
aRect
)
;
bool
IsEmpty
(
)
const
;
int32_t
ZIndex
(
)
const
override
;
void
SetOverrideZIndex
(
int32_t
aZIndex
)
;
virtual
uint32_t
GetPerFrameKey
(
)
const
override
{
return
(
mIndex
<
<
TYPE_BITS
)
|
nsDisplayItem
:
:
GetPerFrameKey
(
)
;
}
const
nsRegion
HitRegion
(
)
{
return
nsRegion
(
mozilla
:
:
gfx
:
:
ArrayView
<
pixman_box32_t
>
(
mHitRegion
.
mBoxes
)
)
;
}
const
nsRegion
MaybeHitRegion
(
)
{
nsRegion
result
(
mozilla
:
:
gfx
:
:
ArrayView
<
pixman_box32_t
>
(
mMaybeHitRegion
.
mBoxes
)
)
;
result
.
SimplifyOutward
(
8
)
;
return
result
;
}
const
nsRegion
DispatchToContentHitRegion
(
)
{
nsRegion
result
(
mozilla
:
:
gfx
:
:
ArrayView
<
pixman_box32_t
>
(
mDispatchToContentHitRegion
.
mBoxes
)
)
;
uint32_t
touchActionCount
=
mNoActionRegion
.
mBoxes
.
Length
(
)
+
mHorizontalPanRegion
.
mBoxes
.
Length
(
)
+
mVerticalPanRegion
.
mBoxes
.
Length
(
)
;
if
(
touchActionCount
>
1
)
{
result
.
OrWith
(
NoActionRegion
(
)
)
;
result
.
OrWith
(
HorizontalPanRegion
(
)
)
;
result
.
OrWith
(
VerticalPanRegion
(
)
)
;
}
result
.
SimplifyOutward
(
8
)
;
return
result
;
}
const
nsRegion
NoActionRegion
(
)
{
return
nsRegion
(
mozilla
:
:
gfx
:
:
ArrayView
<
pixman_box32_t
>
(
mNoActionRegion
.
mBoxes
)
)
;
}
const
nsRegion
HorizontalPanRegion
(
)
{
return
nsRegion
(
mozilla
:
:
gfx
:
:
ArrayView
<
pixman_box32_t
>
(
mHorizontalPanRegion
.
mBoxes
)
)
;
}
const
nsRegion
VerticalPanRegion
(
)
{
return
nsRegion
(
mozilla
:
:
gfx
:
:
ArrayView
<
pixman_box32_t
>
(
mVerticalPanRegion
.
mBoxes
)
)
;
}
nsRegion
CombinedTouchActionRegion
(
)
;
virtual
void
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
override
;
struct
FrameRects
{
void
Add
(
nsIFrame
*
aFrame
const
nsRect
&
aRect
)
{
mBoxes
.
AppendElement
(
nsRegion
:
:
RectToBox
(
aRect
)
)
;
mFrames
.
AppendElement
(
aFrame
)
;
}
void
Add
(
nsIFrame
*
aFrame
const
pixman_box32
&
aBox
)
{
mBoxes
.
AppendElement
(
aBox
)
;
mFrames
.
AppendElement
(
aFrame
)
;
}
void
Add
(
const
FrameRects
&
aOther
)
{
mBoxes
.
AppendElements
(
aOther
.
mBoxes
)
;
mFrames
.
AppendElements
(
aOther
.
mFrames
)
;
}
bool
IsEmpty
(
)
const
{
return
mBoxes
.
IsEmpty
(
)
;
}
nsTArray
<
pixman_box32_t
>
mBoxes
;
nsTArray
<
nsIFrame
*
>
mFrames
;
}
;
virtual
void
RemoveFrame
(
nsIFrame
*
aFrame
)
override
;
private
:
virtual
~
nsDisplayLayerEventRegions
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayLayerEventRegions
)
;
}
void
RemoveItemFromFrames
(
FrameRects
&
aFrameRects
)
{
for
(
nsIFrame
*
f
:
aFrameRects
.
mFrames
)
{
if
(
f
!
=
mFrame
)
{
f
-
>
RemoveDisplayItem
(
this
)
;
}
}
}
friend
bool
MergeLayerEventRegions
(
nsDisplayItem
*
nsDisplayItem
*
)
;
FrameRects
mHitRegion
;
FrameRects
mMaybeHitRegion
;
FrameRects
mDispatchToContentHitRegion
;
FrameRects
mNoActionRegion
;
FrameRects
mHorizontalPanRegion
;
FrameRects
mVerticalPanRegion
;
mozilla
:
:
Maybe
<
int32_t
>
mOverrideZIndex
;
uint32_t
mIndex
;
}
;
class
nsDisplayWrapList
:
public
nsDisplayItem
{
public
:
nsDisplayWrapList
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
)
;
nsDisplayWrapList
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
ActiveScrolledRoot
*
aActiveScrolledRoot
bool
aClearClipChain
=
false
)
;
nsDisplayWrapList
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayItem
*
aItem
)
;
nsDisplayWrapList
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
:
nsDisplayItem
(
aBuilder
aFrame
)
mFrameActiveScrolledRoot
(
aBuilder
-
>
CurrentActiveScrolledRoot
(
)
)
mOverrideZIndex
(
0
)
mHasZIndexOverride
(
false
)
{
MOZ_COUNT_CTOR
(
nsDisplayWrapList
)
;
mBaseVisibleRect
=
mVisibleRect
;
mListPtr
=
&
mList
;
}
nsDisplayWrapList
(
const
nsDisplayWrapList
&
aOther
)
=
delete
;
nsDisplayWrapList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayWrapList
&
aOther
)
:
nsDisplayItem
(
aBuilder
aOther
)
mListPtr
(
&
mList
)
mFrameActiveScrolledRoot
(
aOther
.
mFrameActiveScrolledRoot
)
mMergedFrames
(
aOther
.
mMergedFrames
)
mBounds
(
aOther
.
mBounds
)
mBaseVisibleRect
(
aOther
.
mBaseVisibleRect
)
mOverrideZIndex
(
aOther
.
mOverrideZIndex
)
mHasZIndexOverride
(
aOther
.
mHasZIndexOverride
)
mClearingClipChain
(
aOther
.
mClearingClipChain
)
{
MOZ_COUNT_CTOR
(
nsDisplayWrapList
)
;
}
virtual
~
nsDisplayWrapList
(
)
;
virtual
const
nsDisplayWrapList
*
AsDisplayWrapList
(
)
const
override
{
return
this
;
}
virtual
nsDisplayWrapList
*
AsDisplayWrapList
(
)
override
{
return
this
;
}
virtual
void
Destroy
(
nsDisplayListBuilder
*
aBuilder
)
override
{
mList
.
DeleteAll
(
aBuilder
)
;
nsDisplayItem
:
:
Destroy
(
aBuilder
)
;
}
virtual
void
MergeDisplayListFromItem
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItem
*
aItem
)
override
;
virtual
void
UpdateBounds
(
nsDisplayListBuilder
*
aBuilder
)
override
{
if
(
mClearingClipChain
)
{
const
DisplayItemClipChain
*
clip
=
mState
.
mClipChain
;
while
(
clip
&
&
ActiveScrolledRoot
:
:
IsAncestor
(
GetActiveScrolledRoot
(
)
clip
-
>
mASR
)
)
{
clip
=
clip
-
>
mParent
;
}
SetClipChain
(
clip
false
)
;
}
nsRect
visibleRect
;
mBounds
=
mListPtr
-
>
GetClippedBoundsWithRespectToASR
(
aBuilder
mActiveScrolledRoot
&
visibleRect
)
;
mVisibleRect
.
UnionRect
(
mBaseVisibleRect
visibleRect
)
;
mState
.
mVisibleRect
=
mVisibleRect
;
}
virtual
void
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
override
;
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
nsRegion
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
mozilla
:
:
Maybe
<
nscolor
>
IsUniform
(
nsDisplayListBuilder
*
aBuilder
)
const
override
;
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
;
virtual
bool
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
override
;
virtual
bool
CanMerge
(
const
nsDisplayItem
*
aItem
)
const
override
{
return
false
;
}
virtual
void
Merge
(
const
nsDisplayItem
*
aItem
)
override
{
MOZ_ASSERT
(
CanMerge
(
aItem
)
)
;
MergeFromTrackingMergedFrames
(
static_cast
<
const
nsDisplayWrapList
*
>
(
aItem
)
)
;
}
virtual
void
GetMergedFrames
(
nsTArray
<
nsIFrame
*
>
*
aFrames
)
const
override
{
aFrames
-
>
AppendElements
(
mMergedFrames
)
;
}
virtual
bool
ShouldFlattenAway
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
true
;
}
virtual
bool
IsInvalid
(
nsRect
&
aRect
)
const
override
{
if
(
mFrame
-
>
IsInvalid
(
aRect
)
&
&
aRect
.
IsEmpty
(
)
)
{
return
true
;
}
nsRect
temp
;
for
(
uint32_t
i
=
0
;
i
<
mMergedFrames
.
Length
(
)
;
i
+
+
)
{
if
(
mMergedFrames
[
i
]
-
>
IsInvalid
(
temp
)
&
&
temp
.
IsEmpty
(
)
)
{
aRect
.
SetEmpty
(
)
;
return
true
;
}
aRect
=
aRect
.
Union
(
temp
)
;
}
aRect
+
=
ToReferenceFrame
(
)
;
return
!
aRect
.
IsEmpty
(
)
;
}
NS_DISPLAY_DECL_NAME
(
"
WrapList
"
TYPE_WRAP_LIST
)
virtual
nsRect
GetComponentAlphaBounds
(
nsDisplayListBuilder
*
aBuilder
)
const
override
;
virtual
nsDisplayList
*
GetSameCoordinateSystemChildren
(
)
const
override
{
NS_ASSERTION
(
mListPtr
-
>
IsEmpty
(
)
|
|
!
ReferenceFrame
(
)
|
|
!
mListPtr
-
>
GetBottom
(
)
-
>
ReferenceFrame
(
)
|
|
mListPtr
-
>
GetBottom
(
)
-
>
ReferenceFrame
(
)
=
=
ReferenceFrame
(
)
"
Children
must
have
same
reference
frame
"
)
;
return
mListPtr
;
}
virtual
nsDisplayList
*
GetChildren
(
)
const
override
{
return
mListPtr
;
}
virtual
int32_t
ZIndex
(
)
const
override
{
return
(
mHasZIndexOverride
)
?
mOverrideZIndex
:
nsDisplayItem
:
:
ZIndex
(
)
;
}
void
SetOverrideZIndex
(
int32_t
aZIndex
)
{
mHasZIndexOverride
=
true
;
mOverrideZIndex
=
aZIndex
;
}
void
SetReferenceFrame
(
const
nsIFrame
*
aFrame
)
;
virtual
nsDisplayWrapList
*
WrapWithClone
(
nsDisplayListBuilder
*
aBuilder
nsDisplayItem
*
aItem
)
{
NS_NOTREACHED
(
"
We
never
returned
nullptr
for
GetUnderlyingFrame
!
"
)
;
return
nullptr
;
}
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
const
ActiveScrolledRoot
*
GetFrameActiveScrolledRoot
(
)
{
return
mFrameActiveScrolledRoot
;
}
protected
:
nsDisplayWrapList
(
)
=
delete
;
void
MergeFromTrackingMergedFrames
(
const
nsDisplayWrapList
*
aOther
)
{
mBounds
.
UnionRect
(
mBounds
aOther
-
>
mBounds
)
;
mVisibleRect
.
UnionRect
(
mVisibleRect
aOther
-
>
mVisibleRect
)
;
mMergedFrames
.
AppendElement
(
aOther
-
>
mFrame
)
;
mMergedFrames
.
AppendElements
(
aOther
-
>
mMergedFrames
)
;
}
nsDisplayList
mList
;
nsDisplayList
*
mListPtr
;
RefPtr
<
const
ActiveScrolledRoot
>
mFrameActiveScrolledRoot
;
nsTArray
<
nsIFrame
*
>
mMergedFrames
;
nsRect
mBounds
;
nsRect
mBaseVisibleRect
;
int32_t
mOverrideZIndex
;
bool
mHasZIndexOverride
;
bool
mClearingClipChain
=
false
;
}
;
class
nsDisplayWrapper
{
public
:
virtual
bool
WrapBorderBackground
(
)
{
return
true
;
}
virtual
nsDisplayItem
*
WrapList
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
)
=
0
;
virtual
nsDisplayItem
*
WrapItem
(
nsDisplayListBuilder
*
aBuilder
nsDisplayItem
*
aItem
)
=
0
;
nsresult
WrapLists
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
nsDisplayListSet
&
aIn
const
nsDisplayListSet
&
aOut
)
;
nsresult
WrapListsInPlace
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
nsDisplayListSet
&
aLists
)
;
protected
:
nsDisplayWrapper
(
)
=
default
;
}
;
class
nsDisplayOpacity
:
public
nsDisplayWrapList
{
public
:
nsDisplayOpacity
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
ActiveScrolledRoot
*
aActiveScrolledRoot
bool
aForEventsAndPluginsOnly
)
;
nsDisplayOpacity
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayOpacity
&
aOther
)
:
nsDisplayWrapList
(
aBuilder
aOther
)
mOpacity
(
aOther
.
mOpacity
)
mForEventsAndPluginsOnly
(
aOther
.
mForEventsAndPluginsOnly
)
{
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayOpacity
(
)
;
#
endif
virtual
void
RestoreState
(
)
override
{
nsDisplayItem
:
:
RestoreState
(
)
;
mOpacity
=
mState
.
mOpacity
;
}
virtual
nsDisplayWrapList
*
Clone
(
nsDisplayListBuilder
*
aBuilder
)
const
override
{
MOZ_COUNT_CTOR
(
nsDisplayOpacity
)
;
return
MakeDisplayItem
<
nsDisplayOpacity
>
(
aBuilder
*
this
)
;
}
virtual
nsRegion
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
;
virtual
bool
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
override
;
virtual
bool
CanMerge
(
const
nsDisplayItem
*
aItem
)
const
override
{
return
HasSameTypeAndClip
(
aItem
)
&
&
HasSameContent
(
aItem
)
;
}
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
{
}
virtual
bool
IsInvalid
(
nsRect
&
aRect
)
const
override
{
if
(
mForEventsAndPluginsOnly
)
{
return
false
;
}
return
nsDisplayWrapList
:
:
IsInvalid
(
aRect
)
;
}
virtual
void
ApplyOpacity
(
nsDisplayListBuilder
*
aBuilder
float
aOpacity
const
DisplayItemClipChain
*
aClip
)
override
;
virtual
bool
CanApplyOpacity
(
)
const
override
;
virtual
bool
ShouldFlattenAway
(
nsDisplayListBuilder
*
aBuilder
)
override
;
static
bool
NeedsActiveLayer
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
;
NS_DISPLAY_DECL_NAME
(
"
Opacity
"
TYPE_OPACITY
)
virtual
void
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
override
;
bool
CanUseAsyncAnimations
(
nsDisplayListBuilder
*
aBuilder
)
override
;
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
private
:
float
mOpacity
;
bool
mForEventsAndPluginsOnly
;
struct
{
float
mOpacity
;
}
mState
;
}
;
class
nsDisplayBlendMode
:
public
nsDisplayWrapList
{
public
:
nsDisplayBlendMode
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
uint8_t
aBlendMode
const
ActiveScrolledRoot
*
aActiveScrolledRoot
uint32_t
aIndex
=
0
)
;
nsDisplayBlendMode
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayBlendMode
&
aOther
)
:
nsDisplayWrapList
(
aBuilder
aOther
)
mBlendMode
(
aOther
.
mBlendMode
)
mIndex
(
aOther
.
mIndex
)
{
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayBlendMode
(
)
;
#
endif
virtual
nsDisplayWrapList
*
Clone
(
nsDisplayListBuilder
*
aBuilder
)
const
override
{
MOZ_COUNT_CTOR
(
nsDisplayBlendMode
)
;
return
MakeDisplayItem
<
nsDisplayBlendMode
>
(
aBuilder
*
this
)
;
}
nsRegion
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
{
}
virtual
uint32_t
GetPerFrameKey
(
)
const
override
{
return
(
mIndex
<
<
TYPE_BITS
)
|
nsDisplayItem
:
:
GetPerFrameKey
(
)
;
}
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
;
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
virtual
bool
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
override
;
virtual
bool
CanMerge
(
const
nsDisplayItem
*
aItem
)
const
override
;
virtual
bool
ShouldFlattenAway
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
false
;
}
NS_DISPLAY_DECL_NAME
(
"
BlendMode
"
TYPE_BLEND_MODE
)
protected
:
uint8_t
mBlendMode
;
uint32_t
mIndex
;
}
;
class
nsDisplayTableBlendMode
:
public
nsDisplayBlendMode
{
public
:
nsDisplayTableBlendMode
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
uint8_t
aBlendMode
const
ActiveScrolledRoot
*
aActiveScrolledRoot
uint32_t
aIndex
nsIFrame
*
aAncestorFrame
)
:
nsDisplayBlendMode
(
aBuilder
aFrame
aList
aBlendMode
aActiveScrolledRoot
aIndex
)
mAncestorFrame
(
aAncestorFrame
)
mTableType
(
GetTableTypeFromFrame
(
aAncestorFrame
)
)
{
}
nsDisplayTableBlendMode
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayTableBlendMode
&
aOther
)
:
nsDisplayBlendMode
(
aBuilder
aOther
)
mAncestorFrame
(
aOther
.
mAncestorFrame
)
mTableType
(
aOther
.
mTableType
)
{
}
virtual
nsDisplayWrapList
*
Clone
(
nsDisplayListBuilder
*
aBuilder
)
const
override
{
return
MakeDisplayItem
<
nsDisplayTableBlendMode
>
(
aBuilder
*
this
)
;
}
virtual
nsIFrame
*
FrameForInvalidation
(
)
const
override
{
return
mAncestorFrame
;
}
virtual
uint32_t
GetPerFrameKey
(
)
const
override
{
return
(
mIndex
<
<
(
TYPE_BITS
+
static_cast
<
uint8_t
>
(
TableTypeBits
:
:
COUNT
)
)
)
|
(
static_cast
<
uint8_t
>
(
mTableType
)
<
<
TYPE_BITS
)
|
nsDisplayItem
:
:
GetPerFrameKey
(
)
;
}
NS_DISPLAY_DECL_NAME
(
"
TableBlendMode
"
TYPE_TABLE_BLEND_MODE
)
protected
:
nsIFrame
*
mAncestorFrame
;
TableType
mTableType
;
}
;
class
nsDisplayBlendContainer
:
public
nsDisplayWrapList
{
public
:
static
nsDisplayBlendContainer
*
CreateForMixBlendMode
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
ActiveScrolledRoot
*
aActiveScrolledRoot
)
;
static
nsDisplayBlendContainer
*
CreateForBackgroundBlendMode
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
ActiveScrolledRoot
*
aActiveScrolledRoot
)
;
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayBlendContainer
(
)
;
#
endif
virtual
nsDisplayWrapList
*
Clone
(
nsDisplayListBuilder
*
aBuilder
)
const
override
{
MOZ_COUNT_CTOR
(
nsDisplayBlendContainer
)
;
return
MakeDisplayItem
<
nsDisplayBlendContainer
>
(
aBuilder
*
this
)
;
}
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
;
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
virtual
bool
CanMerge
(
const
nsDisplayItem
*
aItem
)
const
override
{
return
HasSameTypeAndClip
(
aItem
)
&
&
HasSameContent
(
aItem
)
&
&
mIsForBackground
=
=
static_cast
<
const
nsDisplayBlendContainer
*
>
(
aItem
)
-
>
mIsForBackground
;
}
virtual
bool
ShouldFlattenAway
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
false
;
}
virtual
uint32_t
GetPerFrameKey
(
)
const
override
{
return
(
mIsForBackground
?
1
<
<
TYPE_BITS
:
0
)
|
nsDisplayItem
:
:
GetPerFrameKey
(
)
;
}
NS_DISPLAY_DECL_NAME
(
"
BlendContainer
"
TYPE_BLEND_CONTAINER
)
protected
:
nsDisplayBlendContainer
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
ActiveScrolledRoot
*
aActiveScrolledRoot
bool
aIsForBackground
)
;
nsDisplayBlendContainer
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayBlendContainer
&
aOther
)
:
nsDisplayWrapList
(
aBuilder
aOther
)
mIsForBackground
(
aOther
.
mIsForBackground
)
{
}
bool
mIsForBackground
;
}
;
class
nsDisplayTableBlendContainer
:
public
nsDisplayBlendContainer
{
public
:
static
nsDisplayTableBlendContainer
*
CreateForBackgroundBlendMode
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
ActiveScrolledRoot
*
aActiveScrolledRoot
nsIFrame
*
aAncestorFrame
)
;
virtual
nsDisplayWrapList
*
Clone
(
nsDisplayListBuilder
*
aBuilder
)
const
override
{
return
MakeDisplayItem
<
nsDisplayTableBlendContainer
>
(
aBuilder
*
this
)
;
}
virtual
nsIFrame
*
FrameForInvalidation
(
)
const
override
{
return
mAncestorFrame
;
}
virtual
uint32_t
GetPerFrameKey
(
)
const
override
{
return
(
static_cast
<
uint8_t
>
(
mTableType
)
<
<
TYPE_BITS
)
|
nsDisplayItem
:
:
GetPerFrameKey
(
)
;
}
NS_DISPLAY_DECL_NAME
(
"
TableBlendContainer
"
TYPE_TABLE_BLEND_CONTAINER
)
protected
:
nsDisplayTableBlendContainer
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
ActiveScrolledRoot
*
aActiveScrolledRoot
bool
aIsForBackground
nsIFrame
*
aAncestorFrame
)
:
nsDisplayBlendContainer
(
aBuilder
aFrame
aList
aActiveScrolledRoot
aIsForBackground
)
mAncestorFrame
(
aAncestorFrame
)
mTableType
(
GetTableTypeFromFrame
(
aAncestorFrame
)
)
{
}
nsDisplayTableBlendContainer
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayTableBlendContainer
&
aOther
)
:
nsDisplayBlendContainer
(
aBuilder
aOther
)
mAncestorFrame
(
aOther
.
mAncestorFrame
)
mTableType
(
aOther
.
mTableType
)
{
}
nsIFrame
*
mAncestorFrame
;
TableType
mTableType
;
}
;
enum
class
nsDisplayOwnLayerFlags
{
eNone
=
0
eGenerateSubdocInvalidations
=
1
<
<
0
eVerticalScrollbar
=
1
<
<
1
eHorizontalScrollbar
=
1
<
<
2
eGenerateScrollableLayer
=
1
<
<
3
eScrollbarContainer
=
1
<
<
4
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
nsDisplayOwnLayerFlags
)
class
nsDisplayOwnLayer
:
public
nsDisplayWrapList
{
public
:
typedef
mozilla
:
:
layers
:
:
ScrollThumbData
ScrollThumbData
;
nsDisplayOwnLayer
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
ActiveScrolledRoot
*
aActiveScrolledRoot
nsDisplayOwnLayerFlags
aFlags
=
nsDisplayOwnLayerFlags
:
:
eNone
ViewID
aScrollTarget
=
mozilla
:
:
layers
:
:
FrameMetrics
:
:
NULL_SCROLL_ID
const
ScrollThumbData
&
aThumbData
=
ScrollThumbData
{
}
bool
aForceActive
=
true
bool
aClearClipChain
=
false
)
;
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayOwnLayer
(
)
;
#
endif
nsDisplayOwnLayer
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayOwnLayer
&
aOther
)
:
nsDisplayWrapList
(
aBuilder
aOther
)
mFlags
(
aOther
.
mFlags
)
mScrollTarget
(
aOther
.
mScrollTarget
)
mThumbData
(
aOther
.
mThumbData
)
mForceActive
(
aOther
.
mForceActive
)
mWrAnimationId
(
aOther
.
mWrAnimationId
)
{
MOZ_COUNT_CTOR
(
nsDisplayOwnLayer
)
;
}
virtual
bool
ShouldBuildLayerEvenIfInvisible
(
nsDisplayListBuilder
*
aBuilder
)
const
override
;
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
virtual
bool
UpdateScrollData
(
mozilla
:
:
layers
:
:
WebRenderScrollData
*
aData
mozilla
:
:
layers
:
:
WebRenderLayerScrollData
*
aLayerData
)
override
;
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
;
virtual
bool
CanMerge
(
const
nsDisplayItem
*
aItem
)
const
override
{
return
false
;
}
virtual
bool
ShouldFlattenAway
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
false
;
}
void
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
override
;
nsDisplayOwnLayerFlags
GetFlags
(
)
{
return
mFlags
;
}
bool
IsScrollThumbLayer
(
)
const
;
NS_DISPLAY_DECL_NAME
(
"
OwnLayer
"
TYPE_OWN_LAYER
)
protected
:
nsDisplayOwnLayerFlags
mFlags
;
ViewID
mScrollTarget
;
ScrollThumbData
mThumbData
;
bool
mForceActive
;
uint64_t
mWrAnimationId
;
}
;
class
nsDisplaySubDocument
:
public
nsDisplayOwnLayer
{
public
:
nsDisplaySubDocument
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsSubDocumentFrame
*
aSubDocFrame
nsDisplayList
*
aList
nsDisplayOwnLayerFlags
aFlags
)
;
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplaySubDocument
(
)
;
#
endif
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
nsSubDocumentFrame
*
SubDocumentFrame
(
)
{
return
mSubDocFrame
;
}
virtual
bool
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
override
;
virtual
bool
ShouldBuildLayerEvenIfInvisible
(
nsDisplayListBuilder
*
aBuilder
)
const
override
;
virtual
bool
ShouldFlattenAway
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
mShouldFlatten
;
}
void
SetShouldFlattenAway
(
bool
aShouldFlatten
)
{
mShouldFlatten
=
aShouldFlatten
;
}
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
{
if
(
mShouldFlatten
)
{
return
mozilla
:
:
LAYER_NONE
;
}
return
nsDisplayOwnLayer
:
:
GetLayerState
(
aBuilder
aManager
aParameters
)
;
}
virtual
nsRegion
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
NS_DISPLAY_DECL_NAME
(
"
SubDocument
"
TYPE_SUBDOCUMENT
)
mozilla
:
:
UniquePtr
<
ScrollMetadata
>
ComputeScrollMetadata
(
LayerManager
*
aLayerManager
const
ContainerLayerParameters
&
aContainerParameters
)
;
protected
:
ViewID
mScrollParentId
;
bool
mForceDispatchToContentRegion
;
bool
mShouldFlatten
;
nsSubDocumentFrame
*
mSubDocFrame
;
}
;
class
nsDisplayResolution
:
public
nsDisplaySubDocument
{
public
:
nsDisplayResolution
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
nsDisplayOwnLayerFlags
aFlags
)
;
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayResolution
(
)
;
#
endif
virtual
void
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
override
;
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
NS_DISPLAY_DECL_NAME
(
"
Resolution
"
TYPE_RESOLUTION
)
}
;
class
nsDisplayStickyPosition
:
public
nsDisplayOwnLayer
{
public
:
nsDisplayStickyPosition
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
ActiveScrolledRoot
*
aActiveScrolledRoot
)
;
nsDisplayStickyPosition
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayStickyPosition
&
aOther
)
:
nsDisplayOwnLayer
(
aBuilder
aOther
)
{
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayStickyPosition
(
)
;
#
endif
void
SetClipChain
(
const
DisplayItemClipChain
*
aClipChain
bool
aStore
)
override
;
virtual
nsDisplayWrapList
*
Clone
(
nsDisplayListBuilder
*
aBuilder
)
const
override
{
MOZ_COUNT_CTOR
(
nsDisplayStickyPosition
)
;
return
MakeDisplayItem
<
nsDisplayStickyPosition
>
(
aBuilder
*
this
)
;
}
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
NS_DISPLAY_DECL_NAME
(
"
StickyPosition
"
TYPE_STICKY_POSITION
)
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
{
return
mozilla
:
:
LAYER_ACTIVE
;
}
virtual
bool
CanMerge
(
const
nsDisplayItem
*
aItem
)
const
override
{
return
HasSameTypeAndClip
(
aItem
)
&
&
mFrame
=
=
aItem
-
>
Frame
(
)
;
}
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
}
;
class
nsDisplayFixedPosition
:
public
nsDisplayOwnLayer
{
public
:
nsDisplayFixedPosition
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
ActiveScrolledRoot
*
aActiveScrolledRoot
)
;
nsDisplayFixedPosition
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayFixedPosition
&
aOther
)
:
nsDisplayOwnLayer
(
aBuilder
aOther
)
mAnimatedGeometryRootForScrollMetadata
(
aOther
.
mAnimatedGeometryRootForScrollMetadata
)
mIndex
(
aOther
.
mIndex
)
mIsFixedBackground
(
aOther
.
mIsFixedBackground
)
{
MOZ_COUNT_CTOR
(
nsDisplayFixedPosition
)
;
}
static
nsDisplayFixedPosition
*
CreateForFixedBackground
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayBackgroundImage
*
aImage
uint32_t
aIndex
)
;
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayFixedPosition
(
)
;
#
endif
virtual
nsDisplayWrapList
*
Clone
(
nsDisplayListBuilder
*
aBuilder
)
const
override
{
return
MakeDisplayItem
<
nsDisplayFixedPosition
>
(
aBuilder
*
this
)
;
}
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
NS_DISPLAY_DECL_NAME
(
"
FixedPosition
"
TYPE_FIXED_POSITION
)
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
{
return
mozilla
:
:
LAYER_ACTIVE_FORCE
;
}
virtual
bool
CanMerge
(
const
nsDisplayItem
*
aItem
)
const
override
{
return
HasSameTypeAndClip
(
aItem
)
&
&
mFrame
=
=
aItem
-
>
Frame
(
)
;
}
virtual
bool
ShouldFixToViewport
(
nsDisplayListBuilder
*
aBuilder
)
const
override
{
return
mIsFixedBackground
;
}
virtual
uint32_t
GetPerFrameKey
(
)
const
override
{
return
(
mIndex
<
<
TYPE_BITS
)
|
nsDisplayItem
:
:
GetPerFrameKey
(
)
;
}
AnimatedGeometryRoot
*
AnimatedGeometryRootForScrollMetadata
(
)
const
override
{
return
mAnimatedGeometryRootForScrollMetadata
;
}
virtual
bool
UpdateScrollData
(
mozilla
:
:
layers
:
:
WebRenderScrollData
*
aData
mozilla
:
:
layers
:
:
WebRenderLayerScrollData
*
aLayerData
)
override
;
protected
:
nsDisplayFixedPosition
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
uint32_t
aIndex
)
;
void
Init
(
nsDisplayListBuilder
*
aBuilder
)
;
RefPtr
<
AnimatedGeometryRoot
>
mAnimatedGeometryRootForScrollMetadata
;
uint32_t
mIndex
;
bool
mIsFixedBackground
;
}
;
class
nsDisplayTableFixedPosition
:
public
nsDisplayFixedPosition
{
public
:
static
nsDisplayTableFixedPosition
*
CreateForFixedBackground
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayBackgroundImage
*
aImage
uint32_t
aIndex
nsIFrame
*
aAncestorFrame
)
;
virtual
nsDisplayWrapList
*
Clone
(
nsDisplayListBuilder
*
aBuilder
)
const
override
{
return
MakeDisplayItem
<
nsDisplayTableFixedPosition
>
(
aBuilder
*
this
)
;
}
virtual
nsIFrame
*
FrameForInvalidation
(
)
const
override
{
return
mAncestorFrame
;
}
virtual
uint32_t
GetPerFrameKey
(
)
const
override
{
return
(
mIndex
<
<
(
TYPE_BITS
+
static_cast
<
uint8_t
>
(
TableTypeBits
:
:
COUNT
)
)
)
|
(
static_cast
<
uint8_t
>
(
mTableType
)
<
<
TYPE_BITS
)
|
nsDisplayItem
:
:
GetPerFrameKey
(
)
;
}
NS_DISPLAY_DECL_NAME
(
"
TableFixedPosition
"
TYPE_TABLE_FIXED_POSITION
)
protected
:
nsDisplayTableFixedPosition
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
uint32_t
aIndex
nsIFrame
*
aAncestorFrame
)
;
nsDisplayTableFixedPosition
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayTableFixedPosition
&
aOther
)
:
nsDisplayFixedPosition
(
aBuilder
aOther
)
mAncestorFrame
(
aOther
.
mAncestorFrame
)
mTableType
(
aOther
.
mTableType
)
{
}
nsIFrame
*
mAncestorFrame
;
TableType
mTableType
;
}
;
class
nsDisplayScrollInfoLayer
:
public
nsDisplayWrapList
{
public
:
nsDisplayScrollInfoLayer
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aScrolledFrame
nsIFrame
*
aScrollFrame
)
;
NS_DISPLAY_DECL_NAME
(
"
ScrollInfoLayer
"
TYPE_SCROLL_INFO_LAYER
)
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayScrollInfoLayer
(
)
;
#
endif
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
virtual
bool
ShouldBuildLayerEvenIfInvisible
(
nsDisplayListBuilder
*
aBuilder
)
const
override
{
return
true
;
}
virtual
nsRegion
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
{
*
aSnap
=
false
;
return
nsRegion
(
)
;
}
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
;
virtual
bool
ShouldFlattenAway
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
false
;
}
virtual
void
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
override
;
mozilla
:
:
UniquePtr
<
ScrollMetadata
>
ComputeScrollMetadata
(
LayerManager
*
aLayerManager
const
ContainerLayerParameters
&
aContainerParameters
)
;
virtual
bool
UpdateScrollData
(
mozilla
:
:
layers
:
:
WebRenderScrollData
*
aData
mozilla
:
:
layers
:
:
WebRenderLayerScrollData
*
aLayerData
)
override
;
protected
:
nsIFrame
*
mScrollFrame
;
nsIFrame
*
mScrolledFrame
;
ViewID
mScrollParentId
;
}
;
class
nsDisplayZoom
:
public
nsDisplaySubDocument
{
public
:
nsDisplayZoom
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
int32_t
aAPD
int32_t
aParentAPD
nsDisplayOwnLayerFlags
aFlags
=
nsDisplayOwnLayerFlags
:
:
eNone
)
;
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayZoom
(
)
;
#
endif
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
void
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
override
;
virtual
bool
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
override
;
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
{
return
mozilla
:
:
LAYER_ACTIVE
;
}
NS_DISPLAY_DECL_NAME
(
"
Zoom
"
TYPE_ZOOM
)
int32_t
GetChildAppUnitsPerDevPixel
(
)
{
return
mAPD
;
}
int32_t
GetParentAppUnitsPerDevPixel
(
)
{
return
mParentAPD
;
}
private
:
int32_t
mAPD
mParentAPD
;
}
;
class
nsDisplaySVGEffects
:
public
nsDisplayWrapList
{
public
:
nsDisplaySVGEffects
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
bool
aHandleOpacity
const
ActiveScrolledRoot
*
aActiveScrolledRoot
bool
aClearClipChain
=
false
)
;
nsDisplaySVGEffects
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
bool
aHandleOpacity
)
;
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplaySVGEffects
(
)
;
#
endif
nsDisplaySVGEffects
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplaySVGEffects
&
aOther
)
:
nsDisplayWrapList
(
aBuilder
aOther
)
mEffectsBounds
(
aOther
.
mEffectsBounds
)
mHandleOpacity
(
aOther
.
mHandleOpacity
)
{
MOZ_COUNT_CTOR
(
nsDisplaySVGEffects
)
;
}
virtual
nsRegion
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
void
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
override
;
virtual
bool
ShouldFlattenAway
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
false
;
}
bool
ShouldHandleOpacity
(
)
{
return
mHandleOpacity
;
}
gfxRect
BBoxInUserSpace
(
)
const
;
gfxPoint
UserSpaceOffset
(
)
const
;
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
;
protected
:
bool
ValidateSVGFrame
(
)
;
nsRect
mEffectsBounds
;
bool
mHandleOpacity
;
}
;
class
nsDisplayMask
:
public
nsDisplaySVGEffects
{
public
:
typedef
mozilla
:
:
layers
:
:
ImageLayer
ImageLayer
;
nsDisplayMask
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
bool
aHandleOpacity
const
ActiveScrolledRoot
*
aActiveScrolledRoot
)
;
nsDisplayMask
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayMask
&
aOther
)
:
nsDisplaySVGEffects
(
aBuilder
aOther
)
mDestRects
(
aOther
.
mDestRects
)
{
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayMask
(
)
;
#
endif
virtual
nsDisplayWrapList
*
Clone
(
nsDisplayListBuilder
*
aBuilder
)
const
override
{
MOZ_COUNT_CTOR
(
nsDisplayMask
)
;
return
MakeDisplayItem
<
nsDisplayMask
>
(
aBuilder
*
this
)
;
}
NS_DISPLAY_DECL_NAME
(
"
Mask
"
TYPE_MASK
)
virtual
bool
CanMerge
(
const
nsDisplayItem
*
aItem
)
const
override
;
virtual
void
Merge
(
const
nsDisplayItem
*
aItem
)
override
{
nsDisplayWrapList
:
:
Merge
(
aItem
)
;
const
nsDisplayMask
*
other
=
static_cast
<
const
nsDisplayMask
*
>
(
aItem
)
;
mEffectsBounds
.
UnionRect
(
mEffectsBounds
other
-
>
mEffectsBounds
+
other
-
>
mFrame
-
>
GetOffsetTo
(
mFrame
)
)
;
}
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
;
virtual
bool
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
override
;
virtual
nsDisplayItemGeometry
*
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
new
nsDisplayMaskGeometry
(
this
aBuilder
)
;
}
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
;
#
ifdef
MOZ_DUMP_PAINTING
void
PrintEffects
(
nsACString
&
aTo
)
;
#
endif
void
PaintAsLayer
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
LayerManager
*
aManager
)
;
bool
PaintMask
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aMaskContext
)
;
const
nsTArray
<
nsRect
>
&
GetDestRects
(
)
{
return
mDestRects
;
}
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
virtual
mozilla
:
:
Maybe
<
nsRect
>
GetClipWithRespectToASR
(
nsDisplayListBuilder
*
aBuilder
const
ActiveScrolledRoot
*
aASR
)
const
override
;
private
:
bool
CanPaintOnMaskLayer
(
LayerManager
*
aManager
)
;
nsTArray
<
nsRect
>
mDestRects
;
}
;
class
nsDisplayFilter
:
public
nsDisplaySVGEffects
{
public
:
nsDisplayFilter
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
bool
aHandleOpacity
)
;
nsDisplayFilter
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayFilter
&
aOther
)
:
nsDisplaySVGEffects
(
aBuilder
aOther
)
mEffectsBounds
(
aOther
.
mEffectsBounds
)
{
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayFilter
(
)
;
#
endif
virtual
nsDisplayWrapList
*
Clone
(
nsDisplayListBuilder
*
aBuilder
)
const
override
{
MOZ_COUNT_CTOR
(
nsDisplayFilter
)
;
return
MakeDisplayItem
<
nsDisplayFilter
>
(
aBuilder
*
this
)
;
}
NS_DISPLAY_DECL_NAME
(
"
Filter
"
TYPE_FILTER
)
virtual
bool
CanMerge
(
const
nsDisplayItem
*
aItem
)
const
override
{
return
HasSameTypeAndClip
(
aItem
)
&
&
HasSameContent
(
aItem
)
;
}
virtual
void
Merge
(
const
nsDisplayItem
*
aItem
)
override
{
nsDisplayWrapList
:
:
Merge
(
aItem
)
;
const
nsDisplayFilter
*
other
=
static_cast
<
const
nsDisplayFilter
*
>
(
aItem
)
;
mEffectsBounds
.
UnionRect
(
mEffectsBounds
other
-
>
mEffectsBounds
+
other
-
>
mFrame
-
>
GetOffsetTo
(
mFrame
)
)
;
}
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
;
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
{
*
aSnap
=
false
;
return
mEffectsBounds
+
ToReferenceFrame
(
)
;
}
virtual
bool
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
override
;
virtual
nsDisplayItemGeometry
*
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
new
nsDisplayFilterGeometry
(
this
aBuilder
)
;
}
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
;
#
ifdef
MOZ_DUMP_PAINTING
void
PrintEffects
(
nsACString
&
aTo
)
;
#
endif
void
PaintAsLayer
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
LayerManager
*
aManager
)
;
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
private
:
nsRect
mEffectsBounds
;
}
;
class
nsDisplayTransform
:
public
nsDisplayItem
{
typedef
mozilla
:
:
gfx
:
:
Matrix4x4
Matrix4x4
;
typedef
mozilla
:
:
gfx
:
:
Matrix4x4Flagged
Matrix4x4Flagged
;
typedef
mozilla
:
:
gfx
:
:
Point3D
Point3D
;
class
StoreList
:
public
nsDisplayWrapList
{
public
:
StoreList
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
)
:
nsDisplayWrapList
(
aBuilder
aFrame
aList
)
{
}
StoreList
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayItem
*
aItem
)
:
nsDisplayWrapList
(
aBuilder
aFrame
aItem
)
{
}
virtual
~
StoreList
(
)
{
}
virtual
void
UpdateBounds
(
nsDisplayListBuilder
*
aBuilder
)
override
{
if
(
!
mFrame
-
>
Extend3DContext
(
)
)
{
nsDisplayWrapList
:
:
UpdateBounds
(
aBuilder
)
;
}
}
void
ForceUpdateBounds
(
nsDisplayListBuilder
*
aBuilder
)
{
nsDisplayWrapList
:
:
UpdateBounds
(
aBuilder
)
;
}
virtual
void
DoUpdateBoundsPreserves3D
(
nsDisplayListBuilder
*
aBuilder
)
override
{
for
(
nsDisplayItem
*
i
=
mList
.
GetBottom
(
)
;
i
;
i
=
i
-
>
GetAbove
(
)
)
{
i
-
>
DoUpdateBoundsPreserves3D
(
aBuilder
)
;
}
nsDisplayWrapList
:
:
UpdateBounds
(
aBuilder
)
;
}
}
;
public
:
enum
PrerenderDecision
{
NoPrerender
FullPrerender
PartialPrerender
}
;
typedef
Matrix4x4
(
*
ComputeTransformFunction
)
(
nsIFrame
*
aFrame
float
aAppUnitsPerPixel
)
;
nsDisplayTransform
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
nsRect
&
aChildrenVisibleRect
uint32_t
aIndex
=
0
bool
aAllowAsyncAnimation
=
false
)
;
nsDisplayTransform
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayItem
*
aItem
const
nsRect
&
aChildrenVisibleRect
uint32_t
aIndex
=
0
)
;
nsDisplayTransform
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
nsRect
&
aChildrenVisibleRect
ComputeTransformFunction
aTransformGetter
uint32_t
aIndex
=
0
)
;
nsDisplayTransform
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
nsRect
&
aChildrenVisibleRect
const
Matrix4x4
&
aTransform
uint32_t
aIndex
=
0
)
;
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayTransform
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayTransform
)
;
}
#
endif
virtual
void
UpdateBounds
(
nsDisplayListBuilder
*
aBuilder
)
override
{
mHasBounds
=
false
;
if
(
IsTransformSeparator
(
)
)
{
mStoredList
.
ForceUpdateBounds
(
aBuilder
)
;
return
;
}
mStoredList
.
UpdateBounds
(
aBuilder
)
;
UpdateBoundsFor3D
(
aBuilder
)
;
}
virtual
void
Destroy
(
nsDisplayListBuilder
*
aBuilder
)
override
{
mStoredList
.
GetChildren
(
)
-
>
DeleteAll
(
aBuilder
)
;
nsDisplayItem
:
:
Destroy
(
aBuilder
)
;
}
NS_DISPLAY_DECL_NAME
(
"
nsDisplayTransform
"
TYPE_TRANSFORM
)
virtual
nsRect
GetComponentAlphaBounds
(
nsDisplayListBuilder
*
aBuilder
)
const
override
{
if
(
mStoredList
.
GetComponentAlphaBounds
(
aBuilder
)
.
IsEmpty
(
)
)
return
nsRect
(
)
;
bool
snap
;
return
GetBounds
(
aBuilder
&
snap
)
;
}
virtual
nsDisplayList
*
GetChildren
(
)
const
override
{
return
mStoredList
.
GetChildren
(
)
;
}
virtual
void
SetActiveScrolledRoot
(
const
ActiveScrolledRoot
*
aActiveScrolledRoot
)
override
{
nsDisplayItem
:
:
SetActiveScrolledRoot
(
aActiveScrolledRoot
)
;
mStoredList
.
SetActiveScrolledRoot
(
aActiveScrolledRoot
)
;
}
virtual
void
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
override
;
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
nsRegion
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
mozilla
:
:
Maybe
<
nscolor
>
IsUniform
(
nsDisplayListBuilder
*
aBuilder
)
const
override
;
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
;
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
virtual
bool
UpdateScrollData
(
mozilla
:
:
layers
:
:
WebRenderScrollData
*
aData
mozilla
:
:
layers
:
:
WebRenderLayerScrollData
*
aLayerData
)
override
;
virtual
bool
ShouldBuildLayerEvenIfInvisible
(
nsDisplayListBuilder
*
aBuilder
)
const
override
;
virtual
bool
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
override
;
virtual
bool
CanMerge
(
const
nsDisplayItem
*
aItem
)
const
override
{
return
false
;
}
virtual
uint32_t
GetPerFrameKey
(
)
const
override
{
return
(
mIndex
<
<
TYPE_BITS
)
|
nsDisplayItem
:
:
GetPerFrameKey
(
)
;
}
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
{
}
virtual
const
nsIFrame
*
ReferenceFrameForChildren
(
)
const
override
{
if
(
!
mTransformGetter
)
{
return
mFrame
;
}
return
nsDisplayItem
:
:
ReferenceFrameForChildren
(
)
;
}
AnimatedGeometryRoot
*
AnimatedGeometryRootForScrollMetadata
(
)
const
override
{
return
mAnimatedGeometryRootForScrollMetadata
;
}
virtual
const
nsRect
&
GetVisibleRectForChildren
(
)
const
override
{
return
mChildrenVisibleRect
;
}
enum
{
INDEX_MAX
=
UINT32_MAX
>
>
TYPE_BITS
}
;
const
Matrix4x4Flagged
&
GetTransform
(
)
const
;
Matrix4x4
GetTransformForRendering
(
mozilla
:
:
LayoutDevicePoint
*
aOutOrigin
=
nullptr
)
;
const
Matrix4x4
&
GetAccumulatedPreserved3DTransform
(
nsDisplayListBuilder
*
aBuilder
)
;
float
GetHitDepthAtPoint
(
nsDisplayListBuilder
*
aBuilder
const
nsPoint
&
aPoint
)
;
static
nsRect
TransformRect
(
const
nsRect
&
aUntransformedBounds
const
nsIFrame
*
aFrame
const
nsRect
*
aBoundsOverride
=
nullptr
)
;
static
bool
UntransformRect
(
const
nsRect
&
aTransformedBounds
const
nsRect
&
aChildBounds
const
nsIFrame
*
aFrame
nsRect
*
aOutRect
)
;
bool
UntransformVisibleRect
(
nsDisplayListBuilder
*
aBuilder
nsRect
*
aOutRect
)
const
;
static
Point3D
GetDeltaToTransformOrigin
(
const
nsIFrame
*
aFrame
float
aAppUnitsPerPixel
const
nsRect
*
aBoundsOverride
)
;
static
bool
ComputePerspectiveMatrix
(
const
nsIFrame
*
aFrame
float
aAppUnitsPerPixel
Matrix4x4
&
aOutMatrix
)
;
struct
FrameTransformProperties
{
FrameTransformProperties
(
const
nsIFrame
*
aFrame
float
aAppUnitsPerPixel
const
nsRect
*
aBoundsOverride
)
;
FrameTransformProperties
(
RefPtr
<
const
nsCSSValueSharedList
>
&
&
aTransformList
const
Point3D
&
aToTransformOrigin
)
:
mFrame
(
nullptr
)
mTransformList
(
mozilla
:
:
Move
(
aTransformList
)
)
mToTransformOrigin
(
aToTransformOrigin
)
{
}
const
nsIFrame
*
mFrame
;
const
RefPtr
<
const
nsCSSValueSharedList
>
mTransformList
;
const
Point3D
mToTransformOrigin
;
}
;
enum
{
OFFSET_BY_ORIGIN
=
1
<
<
0
INCLUDE_PRESERVE3D_ANCESTORS
=
1
<
<
1
INCLUDE_PERSPECTIVE
=
1
<
<
2
}
;
static
Matrix4x4
GetResultingTransformMatrix
(
const
nsIFrame
*
aFrame
const
nsPoint
&
aOrigin
float
aAppUnitsPerPixel
uint32_t
aFlags
const
nsRect
*
aBoundsOverride
=
nullptr
)
;
static
Matrix4x4
GetResultingTransformMatrix
(
const
FrameTransformProperties
&
aProperties
const
nsPoint
&
aOrigin
float
aAppUnitsPerPixel
uint32_t
aFlags
const
nsRect
*
aBoundsOverride
=
nullptr
)
;
static
PrerenderDecision
ShouldPrerenderTransformedContent
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsRect
*
aDirtyRect
)
;
bool
CanUseAsyncAnimations
(
nsDisplayListBuilder
*
aBuilder
)
override
;
bool
MayBeAnimated
(
nsDisplayListBuilder
*
aBuilder
)
const
;
virtual
void
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
override
;
void
SetNoExtendContext
(
)
{
mNoExtendContext
=
true
;
}
virtual
void
DoUpdateBoundsPreserves3D
(
nsDisplayListBuilder
*
aBuilder
)
override
{
MOZ_ASSERT
(
mFrame
-
>
Combines3DTransformWithAncestors
(
)
|
|
IsTransformSeparator
(
)
)
;
ComputeBounds
(
aBuilder
)
;
}
void
UpdateBoundsFor3D
(
nsDisplayListBuilder
*
aBuilder
)
{
if
(
!
mFrame
-
>
Extend3DContext
(
)
|
|
mFrame
-
>
Combines3DTransformWithAncestors
(
)
|
|
IsTransformSeparator
(
)
)
{
return
;
}
nsDisplayListBuilder
:
:
AutoAccumulateRect
accRect
(
aBuilder
)
;
nsDisplayListBuilder
:
:
AutoAccumulateTransform
accTransform
(
aBuilder
)
;
accTransform
.
StartRoot
(
)
;
ComputeBounds
(
aBuilder
)
;
mBounds
=
aBuilder
-
>
GetAccumulatedRect
(
)
;
mHasBounds
=
true
;
}
bool
IsTransformSeparator
(
)
{
return
mIsTransformSeparator
;
}
bool
IsLeafOf3DContext
(
)
{
return
(
IsTransformSeparator
(
)
|
|
(
!
mFrame
-
>
Extend3DContext
(
)
&
&
mFrame
-
>
Combines3DTransformWithAncestors
(
)
)
)
;
}
bool
IsParticipating3DContext
(
)
{
return
mFrame
-
>
Extend3DContext
(
)
|
|
mFrame
-
>
Combines3DTransformWithAncestors
(
)
;
}
private
:
void
ComputeBounds
(
nsDisplayListBuilder
*
aBuilder
)
;
void
SetReferenceFrameToAncestor
(
nsDisplayListBuilder
*
aBuilder
)
;
void
Init
(
nsDisplayListBuilder
*
aBuilder
)
;
static
Matrix4x4
GetResultingTransformMatrixInternal
(
const
FrameTransformProperties
&
aProperties
const
nsPoint
&
aOrigin
float
aAppUnitsPerPixel
uint32_t
aFlags
const
nsRect
*
aBoundsOverride
)
;
StoreList
mStoredList
;
mutable
Matrix4x4Flagged
mTransform
;
Matrix4x4
mTransformPreserves3D
;
ComputeTransformFunction
mTransformGetter
;
RefPtr
<
AnimatedGeometryRoot
>
mAnimatedGeometryRootForChildren
;
RefPtr
<
AnimatedGeometryRoot
>
mAnimatedGeometryRootForScrollMetadata
;
nsRect
mChildrenVisibleRect
;
uint32_t
mIndex
;
mutable
nsRect
mBounds
;
mutable
bool
mHasBounds
;
bool
mNoExtendContext
;
bool
mIsTransformSeparator
;
bool
mTransformPreserves3DInited
;
bool
mAllowAsyncAnimation
;
}
;
class
nsDisplayPerspective
:
public
nsDisplayItem
{
typedef
mozilla
:
:
gfx
:
:
Point3D
Point3D
;
public
:
NS_DISPLAY_DECL_NAME
(
"
nsDisplayPerspective
"
TYPE_PERSPECTIVE
)
nsDisplayPerspective
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aTransformFrame
nsIFrame
*
aPerspectiveFrame
nsDisplayList
*
aList
)
;
~
nsDisplayPerspective
(
)
{
if
(
mTransformFrame
)
{
mTransformFrame
-
>
RemoveDisplayItem
(
this
)
;
}
}
virtual
uint32_t
GetPerFrameKey
(
)
const
override
{
return
(
mIndex
<
<
TYPE_BITS
)
|
nsDisplayItem
:
:
GetPerFrameKey
(
)
;
}
virtual
void
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
override
{
return
mList
.
HitTest
(
aBuilder
aRect
aState
aOutFrames
)
;
}
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
{
return
mList
.
GetBounds
(
aBuilder
aSnap
)
;
}
virtual
void
UpdateBounds
(
nsDisplayListBuilder
*
aBuilder
)
override
{
mList
.
UpdateBounds
(
aBuilder
)
;
}
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
{
}
virtual
nsRegion
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
{
return
mList
.
GetOpaqueRegion
(
aBuilder
aSnap
)
;
}
virtual
mozilla
:
:
Maybe
<
nscolor
>
IsUniform
(
nsDisplayListBuilder
*
aBuilder
)
const
override
{
return
mList
.
IsUniform
(
aBuilder
)
;
}
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
;
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
virtual
bool
ShouldBuildLayerEvenIfInvisible
(
nsDisplayListBuilder
*
aBuilder
)
const
override
{
if
(
!
mList
.
GetChildren
(
)
-
>
GetTop
(
)
)
{
return
false
;
}
return
mList
.
GetChildren
(
)
-
>
GetTop
(
)
-
>
ShouldBuildLayerEvenIfInvisible
(
aBuilder
)
;
}
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
virtual
bool
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
override
{
mList
.
RecomputeVisibility
(
aBuilder
aVisibleRegion
)
;
return
true
;
}
virtual
nsDisplayList
*
GetSameCoordinateSystemChildren
(
)
const
override
{
return
mList
.
GetChildren
(
)
;
}
virtual
nsDisplayList
*
GetChildren
(
)
const
override
{
return
mList
.
GetChildren
(
)
;
}
virtual
void
SetActiveScrolledRoot
(
const
ActiveScrolledRoot
*
aActiveScrolledRoot
)
override
{
nsDisplayItem
:
:
SetActiveScrolledRoot
(
aActiveScrolledRoot
)
;
mList
.
SetActiveScrolledRoot
(
aActiveScrolledRoot
)
;
}
virtual
nsRect
GetComponentAlphaBounds
(
nsDisplayListBuilder
*
aBuilder
)
const
override
{
return
mList
.
GetComponentAlphaBounds
(
aBuilder
)
;
}
nsIFrame
*
TransformFrame
(
)
{
return
mTransformFrame
;
}
virtual
nsIFrame
*
FrameForInvalidation
(
)
const
override
{
return
mTransformFrame
;
}
virtual
int32_t
ZIndex
(
)
const
override
;
virtual
void
DoUpdateBoundsPreserves3D
(
nsDisplayListBuilder
*
aBuilder
)
override
{
if
(
mList
.
GetChildren
(
)
-
>
GetTop
(
)
)
{
static_cast
<
nsDisplayTransform
*
>
(
mList
.
GetChildren
(
)
-
>
GetTop
(
)
)
-
>
DoUpdateBoundsPreserves3D
(
aBuilder
)
;
}
}
virtual
void
Destroy
(
nsDisplayListBuilder
*
aBuilder
)
override
{
mList
.
GetChildren
(
)
-
>
DeleteAll
(
aBuilder
)
;
nsDisplayItem
:
:
Destroy
(
aBuilder
)
;
}
virtual
bool
HasDeletedFrame
(
)
const
override
{
return
!
mTransformFrame
|
|
nsDisplayItem
:
:
HasDeletedFrame
(
)
;
}
virtual
void
RemoveFrame
(
nsIFrame
*
aFrame
)
override
{
if
(
aFrame
=
=
mTransformFrame
)
{
mTransformFrame
=
nullptr
;
}
nsDisplayItem
:
:
RemoveFrame
(
aFrame
)
;
}
private
:
nsDisplayWrapList
mList
;
nsIFrame
*
mTransformFrame
;
uint32_t
mIndex
;
}
;
class
nsCharClipDisplayItem
:
public
nsDisplayItem
{
public
:
nsCharClipDisplayItem
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
:
nsDisplayItem
(
aBuilder
aFrame
)
mVisIStartEdge
(
0
)
mVisIEndEdge
(
0
)
{
}
explicit
nsCharClipDisplayItem
(
nsIFrame
*
aFrame
)
:
nsDisplayItem
(
aFrame
)
mVisIStartEdge
(
0
)
mVisIEndEdge
(
0
)
{
}
virtual
void
RestoreState
(
)
override
{
nsDisplayItem
:
:
RestoreState
(
)
;
mIsFrameSelected
.
reset
(
)
;
}
virtual
nsDisplayItemGeometry
*
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
override
;
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
;
struct
ClipEdges
{
ClipEdges
(
const
nsDisplayItem
&
aItem
nscoord
aVisIStartEdge
nscoord
aVisIEndEdge
)
{
nsRect
r
=
aItem
.
Frame
(
)
-
>
GetScrollableOverflowRect
(
)
+
aItem
.
ToReferenceFrame
(
)
;
if
(
aItem
.
Frame
(
)
-
>
GetWritingMode
(
)
.
IsVertical
(
)
)
{
mVisIStart
=
aVisIStartEdge
>
0
?
r
.
y
+
aVisIStartEdge
:
nscoord_MIN
;
mVisIEnd
=
aVisIEndEdge
>
0
?
std
:
:
max
(
r
.
YMost
(
)
-
aVisIEndEdge
mVisIStart
)
:
nscoord_MAX
;
}
else
{
mVisIStart
=
aVisIStartEdge
>
0
?
r
.
x
+
aVisIStartEdge
:
nscoord_MIN
;
mVisIEnd
=
aVisIEndEdge
>
0
?
std
:
:
max
(
r
.
XMost
(
)
-
aVisIEndEdge
mVisIStart
)
:
nscoord_MAX
;
}
}
void
Intersect
(
nscoord
*
aVisIStart
nscoord
*
aVisISize
)
const
{
nscoord
end
=
*
aVisIStart
+
*
aVisISize
;
*
aVisIStart
=
std
:
:
max
(
*
aVisIStart
mVisIStart
)
;
*
aVisISize
=
std
:
:
max
(
std
:
:
min
(
end
mVisIEnd
)
-
*
aVisIStart
0
)
;
}
nscoord
mVisIStart
;
nscoord
mVisIEnd
;
}
;
ClipEdges
Edges
(
)
const
{
return
ClipEdges
(
*
this
mVisIStartEdge
mVisIEndEdge
)
;
}
static
nsCharClipDisplayItem
*
CheckCast
(
nsDisplayItem
*
aItem
)
{
DisplayItemType
t
=
aItem
-
>
GetType
(
)
;
return
(
t
=
=
DisplayItemType
:
:
TYPE_TEXT
|
|
t
=
=
DisplayItemType
:
:
TYPE_SVG_CHAR_CLIP
)
?
static_cast
<
nsCharClipDisplayItem
*
>
(
aItem
)
:
nullptr
;
}
nscoord
mVisIStartEdge
;
nscoord
mVisIEndEdge
;
mutable
mozilla
:
:
Maybe
<
bool
>
mIsFrameSelected
;
}
;
class
FlattenedDisplayItemIterator
{
public
:
FlattenedDisplayItemIterator
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
)
:
mBuilder
(
aBuilder
)
mNext
(
aList
-
>
GetBottom
(
)
)
{
ResolveFlattening
(
)
;
}
nsDisplayItem
*
GetNext
(
)
{
nsDisplayItem
*
next
=
mNext
;
if
(
next
)
{
mNext
=
mNext
-
>
GetAbove
(
)
;
ResolveFlattening
(
)
;
}
return
next
;
}
nsDisplayItem
*
PeekNext
(
)
{
return
mNext
;
}
private
:
bool
AtEndOfNestedList
(
)
{
return
!
mNext
&
&
mStack
.
Length
(
)
>
0
;
}
bool
ShouldFlattenNextItem
(
)
{
return
mNext
&
&
mNext
-
>
ShouldFlattenAway
(
mBuilder
)
;
}
void
ResolveFlattening
(
)
{
while
(
AtEndOfNestedList
(
)
|
|
ShouldFlattenNextItem
(
)
)
{
if
(
AtEndOfNestedList
(
)
)
{
mNext
=
mStack
.
LastElement
(
)
;
mStack
.
RemoveElementAt
(
mStack
.
Length
(
)
-
1
)
;
mNext
=
mNext
-
>
GetAbove
(
)
;
}
else
{
mStack
.
AppendElement
(
mNext
)
;
nsDisplayList
*
childItems
=
mNext
-
>
GetSameCoordinateSystemChildren
(
)
;
mNext
=
childItems
-
>
GetBottom
(
)
;
}
}
}
nsDisplayListBuilder
*
mBuilder
;
nsDisplayItem
*
mNext
;
AutoTArray
<
nsDisplayItem
*
10
>
mStack
;
}
;
class
nsDisplaySVGWrapper
:
public
nsDisplayWrapList
{
public
:
NS_DISPLAY_DECL_NAME
(
"
SVGWrapper
"
TYPE_SVG_WRAPPER
)
nsDisplaySVGWrapper
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
)
;
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplaySVGWrapper
(
)
;
#
endif
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
;
virtual
bool
ShouldFlattenAway
(
nsDisplayListBuilder
*
aBuilder
)
override
;
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
}
;
namespace
mozilla
{
class
PaintTelemetry
{
public
:
enum
class
Metric
{
DisplayList
Layerization
Rasterization
COUNT
}
;
class
AutoRecord
{
public
:
explicit
AutoRecord
(
Metric
aMetric
)
;
~
AutoRecord
(
)
;
TimeStamp
GetStart
(
)
const
{
return
mStart
;
}
private
:
Metric
mMetric
;
mozilla
:
:
TimeStamp
mStart
;
}
;
class
AutoRecordPaint
{
public
:
AutoRecordPaint
(
)
;
~
AutoRecordPaint
(
)
;
private
:
mozilla
:
:
TimeStamp
mStart
;
}
;
private
:
static
uint32_t
sPaintLevel
;
static
uint32_t
sMetricLevel
;
static
mozilla
:
:
EnumeratedArray
<
Metric
Metric
:
:
COUNT
double
>
sMetrics
;
}
;
}
#
endif
