#
include
"
nsDisplayList
.
h
"
#
include
<
stdint
.
h
>
#
include
<
algorithm
>
#
include
<
limits
>
#
include
"
gfxUtils
.
h
"
#
include
"
mozilla
/
dom
/
TabChild
.
h
"
#
include
"
mozilla
/
dom
/
KeyframeEffectReadOnly
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
layers
/
PLayerTransaction
.
h
"
#
include
"
nsCSSRendering
.
h
"
#
include
"
nsRenderingContext
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nsStyleStructInlines
.
h
"
#
include
"
nsStyleTransformMatrix
.
h
"
#
include
"
gfxMatrix
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
nsSVGIntegrationUtils
.
h
"
#
include
"
nsSVGUtils
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsThemeConstants
.
h
"
#
include
"
BorderConsts
.
h
"
#
include
"
LayerTreeInvalidation
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
BasicLayers
.
h
"
#
include
"
nsBoxFrame
.
h
"
#
include
"
nsSubDocumentFrame
.
h
"
#
include
"
nsSVGEffects
.
h
"
#
include
"
nsSVGElement
.
h
"
#
include
"
nsSVGClipPathFrame
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
ImageLayers
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
nsCanvasFrame
.
h
"
#
include
"
StickyScrollContainer
.
h
"
#
include
"
mozilla
/
AnimationPerformanceWarning
.
h
"
#
include
"
mozilla
/
AnimationUtils
.
h
"
#
include
"
mozilla
/
EffectCompositor
.
h
"
#
include
"
mozilla
/
EffectSet
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
mozilla
/
OperatorNewExtensions
.
h
"
#
include
"
mozilla
/
PendingAnimationTracker
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
StyleAnimationValueInlines
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
ViewportFrame
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
#
include
"
ActiveLayerTracker
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
UnitTransforms
.
h
"
#
include
"
LayersLogging
.
h
"
#
include
"
FrameLayerBuilder
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
GeckoRestyleManager
.
h
"
#
include
"
nsCaret
.
h
"
#
include
"
nsISelection
.
h
"
#
include
"
nsDOMTokenList
.
h
"
#
include
"
mozilla
/
RuleNodeCacheConditions
.
h
"
#
include
"
nsCSSProps
.
h
"
#
include
"
nsPluginFrame
.
h
"
#
include
"
nsSVGMaskFrame
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderLayerManager
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderDisplayItemLayer
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderMessages
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderDisplayItemLayer
.
h
"
#
ifdef
GetCurrentTime
#
undef
GetCurrentTime
#
endif
using
namespace
mozilla
;
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
layout
;
using
namespace
mozilla
:
:
gfx
;
typedef
FrameMetrics
:
:
ViewID
ViewID
;
typedef
nsStyleTransformMatrix
:
:
TransformReferenceBox
TransformReferenceBox
;
#
ifdef
DEBUG
static
bool
SpammyLayoutWarningsEnabled
(
)
{
static
bool
sValue
=
false
;
static
bool
sValueInitialized
=
false
;
if
(
!
sValueInitialized
)
{
Preferences
:
:
GetBool
(
"
layout
.
spammy_warnings
.
enabled
"
&
sValue
)
;
sValueInitialized
=
true
;
}
return
sValue
;
}
#
endif
void
*
AnimatedGeometryRoot
:
:
operator
new
(
size_t
aSize
nsDisplayListBuilder
*
aBuilder
)
{
return
aBuilder
-
>
Allocate
(
aSize
)
;
}
bool
ActiveScrolledRoot
:
:
IsAncestor
(
const
ActiveScrolledRoot
*
aAncestor
const
ActiveScrolledRoot
*
aDescendant
)
{
if
(
!
aAncestor
)
{
return
true
;
}
if
(
Depth
(
aAncestor
)
>
Depth
(
aDescendant
)
)
{
return
false
;
}
const
ActiveScrolledRoot
*
asr
=
aDescendant
;
while
(
asr
)
{
if
(
asr
=
=
aAncestor
)
{
return
true
;
}
asr
=
asr
-
>
mParent
;
}
return
false
;
}
nsCString
ActiveScrolledRoot
:
:
ToString
(
const
ActiveScrolledRoot
*
aActiveScrolledRoot
)
{
nsAutoCString
str
;
for
(
auto
*
asr
=
aActiveScrolledRoot
;
asr
;
asr
=
asr
-
>
mParent
)
{
str
.
AppendPrintf
(
"
<
0x
%
p
>
"
asr
-
>
mScrollableFrame
)
;
if
(
asr
-
>
mParent
)
{
str
.
Append
(
"
"
)
;
}
}
return
str
;
}
static
inline
CSSAngle
MakeCSSAngle
(
const
nsCSSValue
&
aValue
)
{
return
CSSAngle
(
aValue
.
GetAngleValue
(
)
aValue
.
GetUnit
(
)
)
;
}
static
void
AddTransformFunctions
(
const
nsCSSValueList
*
aList
nsStyleContext
*
aContext
nsPresContext
*
aPresContext
TransformReferenceBox
&
aRefBox
InfallibleTArray
<
TransformFunction
>
&
aFunctions
)
{
if
(
aList
-
>
mValue
.
GetUnit
(
)
=
=
eCSSUnit_None
)
{
return
;
}
for
(
const
nsCSSValueList
*
curr
=
aList
;
curr
;
curr
=
curr
-
>
mNext
)
{
const
nsCSSValue
&
currElem
=
curr
-
>
mValue
;
NS_ASSERTION
(
currElem
.
GetUnit
(
)
=
=
eCSSUnit_Function
"
Stream
should
consist
solely
of
functions
!
"
)
;
nsCSSValue
:
:
Array
*
array
=
currElem
.
GetArrayValue
(
)
;
RuleNodeCacheConditions
conditions
;
switch
(
nsStyleTransformMatrix
:
:
TransformFunctionOf
(
array
)
)
{
case
eCSSKeyword_rotatex
:
{
CSSAngle
theta
=
MakeCSSAngle
(
array
-
>
Item
(
1
)
)
;
aFunctions
.
AppendElement
(
RotationX
(
theta
)
)
;
break
;
}
case
eCSSKeyword_rotatey
:
{
CSSAngle
theta
=
MakeCSSAngle
(
array
-
>
Item
(
1
)
)
;
aFunctions
.
AppendElement
(
RotationY
(
theta
)
)
;
break
;
}
case
eCSSKeyword_rotatez
:
{
CSSAngle
theta
=
MakeCSSAngle
(
array
-
>
Item
(
1
)
)
;
aFunctions
.
AppendElement
(
RotationZ
(
theta
)
)
;
break
;
}
case
eCSSKeyword_rotate
:
{
CSSAngle
theta
=
MakeCSSAngle
(
array
-
>
Item
(
1
)
)
;
aFunctions
.
AppendElement
(
Rotation
(
theta
)
)
;
break
;
}
case
eCSSKeyword_rotate3d
:
{
double
x
=
array
-
>
Item
(
1
)
.
GetFloatValue
(
)
;
double
y
=
array
-
>
Item
(
2
)
.
GetFloatValue
(
)
;
double
z
=
array
-
>
Item
(
3
)
.
GetFloatValue
(
)
;
CSSAngle
theta
=
MakeCSSAngle
(
array
-
>
Item
(
4
)
)
;
aFunctions
.
AppendElement
(
Rotation3D
(
x
y
z
theta
)
)
;
break
;
}
case
eCSSKeyword_scalex
:
{
double
x
=
array
-
>
Item
(
1
)
.
GetFloatValue
(
)
;
aFunctions
.
AppendElement
(
Scale
(
x
1
1
)
)
;
break
;
}
case
eCSSKeyword_scaley
:
{
double
y
=
array
-
>
Item
(
1
)
.
GetFloatValue
(
)
;
aFunctions
.
AppendElement
(
Scale
(
1
y
1
)
)
;
break
;
}
case
eCSSKeyword_scalez
:
{
double
z
=
array
-
>
Item
(
1
)
.
GetFloatValue
(
)
;
aFunctions
.
AppendElement
(
Scale
(
1
1
z
)
)
;
break
;
}
case
eCSSKeyword_scale
:
{
double
x
=
array
-
>
Item
(
1
)
.
GetFloatValue
(
)
;
double
y
=
array
-
>
Count
(
)
=
=
2
?
x
:
array
-
>
Item
(
2
)
.
GetFloatValue
(
)
;
aFunctions
.
AppendElement
(
Scale
(
x
y
1
)
)
;
break
;
}
case
eCSSKeyword_scale3d
:
{
double
x
=
array
-
>
Item
(
1
)
.
GetFloatValue
(
)
;
double
y
=
array
-
>
Item
(
2
)
.
GetFloatValue
(
)
;
double
z
=
array
-
>
Item
(
3
)
.
GetFloatValue
(
)
;
aFunctions
.
AppendElement
(
Scale
(
x
y
z
)
)
;
break
;
}
case
eCSSKeyword_translatex
:
{
double
x
=
nsStyleTransformMatrix
:
:
ProcessTranslatePart
(
array
-
>
Item
(
1
)
aContext
aPresContext
conditions
&
aRefBox
&
TransformReferenceBox
:
:
Width
)
;
aFunctions
.
AppendElement
(
Translation
(
x
0
0
)
)
;
break
;
}
case
eCSSKeyword_translatey
:
{
double
y
=
nsStyleTransformMatrix
:
:
ProcessTranslatePart
(
array
-
>
Item
(
1
)
aContext
aPresContext
conditions
&
aRefBox
&
TransformReferenceBox
:
:
Height
)
;
aFunctions
.
AppendElement
(
Translation
(
0
y
0
)
)
;
break
;
}
case
eCSSKeyword_translatez
:
{
double
z
=
nsStyleTransformMatrix
:
:
ProcessTranslatePart
(
array
-
>
Item
(
1
)
aContext
aPresContext
conditions
nullptr
)
;
aFunctions
.
AppendElement
(
Translation
(
0
0
z
)
)
;
break
;
}
case
eCSSKeyword_translate
:
{
double
x
=
nsStyleTransformMatrix
:
:
ProcessTranslatePart
(
array
-
>
Item
(
1
)
aContext
aPresContext
conditions
&
aRefBox
&
TransformReferenceBox
:
:
Width
)
;
double
y
=
0
;
if
(
array
-
>
Count
(
)
=
=
3
)
{
y
=
nsStyleTransformMatrix
:
:
ProcessTranslatePart
(
array
-
>
Item
(
2
)
aContext
aPresContext
conditions
&
aRefBox
&
TransformReferenceBox
:
:
Height
)
;
}
aFunctions
.
AppendElement
(
Translation
(
x
y
0
)
)
;
break
;
}
case
eCSSKeyword_translate3d
:
{
double
x
=
nsStyleTransformMatrix
:
:
ProcessTranslatePart
(
array
-
>
Item
(
1
)
aContext
aPresContext
conditions
&
aRefBox
&
TransformReferenceBox
:
:
Width
)
;
double
y
=
nsStyleTransformMatrix
:
:
ProcessTranslatePart
(
array
-
>
Item
(
2
)
aContext
aPresContext
conditions
&
aRefBox
&
TransformReferenceBox
:
:
Height
)
;
double
z
=
nsStyleTransformMatrix
:
:
ProcessTranslatePart
(
array
-
>
Item
(
3
)
aContext
aPresContext
conditions
nullptr
)
;
aFunctions
.
AppendElement
(
Translation
(
x
y
z
)
)
;
break
;
}
case
eCSSKeyword_skewx
:
{
CSSAngle
x
=
MakeCSSAngle
(
array
-
>
Item
(
1
)
)
;
aFunctions
.
AppendElement
(
SkewX
(
x
)
)
;
break
;
}
case
eCSSKeyword_skewy
:
{
CSSAngle
y
=
MakeCSSAngle
(
array
-
>
Item
(
1
)
)
;
aFunctions
.
AppendElement
(
SkewY
(
y
)
)
;
break
;
}
case
eCSSKeyword_skew
:
{
CSSAngle
x
=
MakeCSSAngle
(
array
-
>
Item
(
1
)
)
;
CSSAngle
y
(
0
.
0f
eCSSUnit_Degree
)
;
if
(
array
-
>
Count
(
)
=
=
3
)
{
y
=
MakeCSSAngle
(
array
-
>
Item
(
2
)
)
;
}
aFunctions
.
AppendElement
(
Skew
(
x
y
)
)
;
break
;
}
case
eCSSKeyword_matrix
:
{
gfx
:
:
Matrix4x4
matrix
;
matrix
.
_11
=
array
-
>
Item
(
1
)
.
GetFloatValue
(
)
;
matrix
.
_12
=
array
-
>
Item
(
2
)
.
GetFloatValue
(
)
;
matrix
.
_13
=
0
;
matrix
.
_14
=
0
;
matrix
.
_21
=
array
-
>
Item
(
3
)
.
GetFloatValue
(
)
;
matrix
.
_22
=
array
-
>
Item
(
4
)
.
GetFloatValue
(
)
;
matrix
.
_23
=
0
;
matrix
.
_24
=
0
;
matrix
.
_31
=
0
;
matrix
.
_32
=
0
;
matrix
.
_33
=
1
;
matrix
.
_34
=
0
;
matrix
.
_41
=
array
-
>
Item
(
5
)
.
GetFloatValue
(
)
;
matrix
.
_42
=
array
-
>
Item
(
6
)
.
GetFloatValue
(
)
;
matrix
.
_43
=
0
;
matrix
.
_44
=
1
;
aFunctions
.
AppendElement
(
TransformMatrix
(
matrix
)
)
;
break
;
}
case
eCSSKeyword_matrix3d
:
{
gfx
:
:
Matrix4x4
matrix
;
matrix
.
_11
=
array
-
>
Item
(
1
)
.
GetFloatValue
(
)
;
matrix
.
_12
=
array
-
>
Item
(
2
)
.
GetFloatValue
(
)
;
matrix
.
_13
=
array
-
>
Item
(
3
)
.
GetFloatValue
(
)
;
matrix
.
_14
=
array
-
>
Item
(
4
)
.
GetFloatValue
(
)
;
matrix
.
_21
=
array
-
>
Item
(
5
)
.
GetFloatValue
(
)
;
matrix
.
_22
=
array
-
>
Item
(
6
)
.
GetFloatValue
(
)
;
matrix
.
_23
=
array
-
>
Item
(
7
)
.
GetFloatValue
(
)
;
matrix
.
_24
=
array
-
>
Item
(
8
)
.
GetFloatValue
(
)
;
matrix
.
_31
=
array
-
>
Item
(
9
)
.
GetFloatValue
(
)
;
matrix
.
_32
=
array
-
>
Item
(
10
)
.
GetFloatValue
(
)
;
matrix
.
_33
=
array
-
>
Item
(
11
)
.
GetFloatValue
(
)
;
matrix
.
_34
=
array
-
>
Item
(
12
)
.
GetFloatValue
(
)
;
matrix
.
_41
=
array
-
>
Item
(
13
)
.
GetFloatValue
(
)
;
matrix
.
_42
=
array
-
>
Item
(
14
)
.
GetFloatValue
(
)
;
matrix
.
_43
=
array
-
>
Item
(
15
)
.
GetFloatValue
(
)
;
matrix
.
_44
=
array
-
>
Item
(
16
)
.
GetFloatValue
(
)
;
aFunctions
.
AppendElement
(
TransformMatrix
(
matrix
)
)
;
break
;
}
case
eCSSKeyword_interpolatematrix
:
{
bool
dummy
;
Matrix4x4
matrix
;
nsStyleTransformMatrix
:
:
ProcessInterpolateMatrix
(
matrix
array
aContext
aPresContext
conditions
aRefBox
&
dummy
)
;
aFunctions
.
AppendElement
(
TransformMatrix
(
matrix
)
)
;
break
;
}
case
eCSSKeyword_accumulatematrix
:
{
bool
dummy
;
Matrix4x4
matrix
;
nsStyleTransformMatrix
:
:
ProcessAccumulateMatrix
(
matrix
array
aContext
aPresContext
conditions
aRefBox
&
dummy
)
;
aFunctions
.
AppendElement
(
TransformMatrix
(
matrix
)
)
;
break
;
}
case
eCSSKeyword_perspective
:
{
aFunctions
.
AppendElement
(
Perspective
(
array
-
>
Item
(
1
)
.
GetFloatValue
(
)
)
)
;
break
;
}
default
:
NS_ERROR
(
"
Function
not
handled
yet
!
"
)
;
}
}
}
static
void
AddTransformFunctions
(
const
nsCSSValueSharedList
*
aList
const
nsIFrame
*
aFrame
TransformReferenceBox
&
aRefBox
layers
:
:
Animatable
&
aAnimatable
)
{
MOZ_ASSERT
(
aList
-
>
mHead
)
;
AddTransformFunctions
(
aList
-
>
mHead
aFrame
-
>
StyleContext
(
)
aFrame
-
>
PresContext
(
)
aRefBox
aAnimatable
.
get_ArrayOfTransformFunction
(
)
)
;
}
static
TimingFunction
ToTimingFunction
(
const
Maybe
<
ComputedTimingFunction
>
&
aCTF
)
{
if
(
aCTF
.
isNothing
(
)
)
{
return
TimingFunction
(
null_t
(
)
)
;
}
if
(
aCTF
-
>
HasSpline
(
)
)
{
const
nsSMILKeySpline
*
spline
=
aCTF
-
>
GetFunction
(
)
;
return
TimingFunction
(
CubicBezierFunction
(
spline
-
>
X1
(
)
spline
-
>
Y1
(
)
spline
-
>
X2
(
)
spline
-
>
Y2
(
)
)
)
;
}
uint32_t
type
=
aCTF
-
>
GetType
(
)
=
=
nsTimingFunction
:
:
Type
:
:
StepStart
?
1
:
2
;
return
TimingFunction
(
StepFunction
(
aCTF
-
>
GetSteps
(
)
type
)
)
;
}
static
void
SetAnimatable
(
nsCSSPropertyID
aProperty
const
AnimationValue
&
aAnimationValue
nsIFrame
*
aFrame
TransformReferenceBox
&
aRefBox
layers
:
:
Animatable
&
aAnimatable
)
{
MOZ_ASSERT
(
aFrame
)
;
if
(
aAnimationValue
.
IsNull
(
)
)
{
aAnimatable
=
null_t
(
)
;
return
;
}
switch
(
aProperty
)
{
case
eCSSProperty_opacity
:
aAnimatable
=
aAnimationValue
.
GetOpacity
(
)
;
break
;
case
eCSSProperty_transform
:
{
aAnimatable
=
InfallibleTArray
<
TransformFunction
>
(
)
;
if
(
aAnimationValue
.
mServo
)
{
RefPtr
<
nsCSSValueSharedList
>
list
;
Servo_AnimationValue_GetTransform
(
aAnimationValue
.
mServo
&
list
)
;
AddTransformFunctions
(
list
aFrame
aRefBox
aAnimatable
)
;
}
else
{
nsCSSValueSharedList
*
list
=
aAnimationValue
.
mGecko
.
GetCSSValueSharedListValue
(
)
;
AddTransformFunctions
(
list
aFrame
aRefBox
aAnimatable
)
;
}
break
;
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unsupported
property
"
)
;
}
}
static
void
AddAnimationForProperty
(
nsIFrame
*
aFrame
const
AnimationProperty
&
aProperty
dom
:
:
Animation
*
aAnimation
Layer
*
aLayer
AnimationData
&
aData
bool
aPending
)
{
MOZ_ASSERT
(
aLayer
-
>
AsContainerLayer
(
)
"
Should
only
animate
ContainerLayer
"
)
;
MOZ_ASSERT
(
aAnimation
-
>
GetEffect
(
)
"
Should
not
be
adding
an
animation
without
an
effect
"
)
;
MOZ_ASSERT
(
!
aAnimation
-
>
GetCurrentOrPendingStartTime
(
)
.
IsNull
(
)
|
|
!
aAnimation
-
>
IsPlaying
(
)
|
|
(
aAnimation
-
>
GetTimeline
(
)
&
&
aAnimation
-
>
GetTimeline
(
)
-
>
TracksWallclockTime
(
)
)
"
If
the
animation
has
an
unresolved
start
time
it
should
either
"
"
be
static
(
so
we
don
'
t
need
a
start
time
)
or
else
have
a
"
"
timeline
capable
of
converting
TimeStamps
(
so
we
can
calculate
"
"
one
later
"
)
;
layers
:
:
Animation
*
animation
=
aPending
?
aLayer
-
>
AddAnimationForNextTransaction
(
)
:
aLayer
-
>
AddAnimation
(
)
;
const
TimingParams
&
timing
=
aAnimation
-
>
GetEffect
(
)
-
>
SpecifiedTiming
(
)
;
if
(
aAnimation
-
>
AsCSSTransition
(
)
&
&
aAnimation
-
>
GetEffect
(
)
&
&
aAnimation
-
>
GetEffect
(
)
-
>
AsTransition
(
)
)
{
aAnimation
-
>
GetEffect
(
)
-
>
AsTransition
(
)
-
>
UpdateStartValueFromReplacedTransition
(
)
;
}
const
ComputedTiming
computedTiming
=
aAnimation
-
>
GetEffect
(
)
-
>
GetComputedTiming
(
)
;
Nullable
<
TimeDuration
>
startTime
=
aAnimation
-
>
GetCurrentOrPendingStartTime
(
)
;
animation
-
>
startTime
(
)
=
startTime
.
IsNull
(
)
|
|
!
aAnimation
-
>
GetTimeline
(
)
?
TimeStamp
(
)
:
aAnimation
-
>
GetTimeline
(
)
-
>
ToTimeStamp
(
startTime
.
Value
(
)
)
;
animation
-
>
holdTime
(
)
=
aAnimation
-
>
GetCurrentTime
(
)
.
Value
(
)
;
animation
-
>
delay
(
)
=
timing
.
mDelay
;
animation
-
>
endDelay
(
)
=
timing
.
mEndDelay
;
animation
-
>
duration
(
)
=
computedTiming
.
mDuration
;
animation
-
>
iterations
(
)
=
computedTiming
.
mIterations
;
animation
-
>
iterationStart
(
)
=
computedTiming
.
mIterationStart
;
animation
-
>
direction
(
)
=
static_cast
<
uint8_t
>
(
timing
.
mDirection
)
;
animation
-
>
fillMode
(
)
=
static_cast
<
uint8_t
>
(
computedTiming
.
mFill
)
;
animation
-
>
property
(
)
=
aProperty
.
mProperty
;
animation
-
>
playbackRate
(
)
=
aAnimation
-
>
PlaybackRate
(
)
;
animation
-
>
data
(
)
=
aData
;
animation
-
>
easingFunction
(
)
=
ToTimingFunction
(
timing
.
mFunction
)
;
animation
-
>
iterationComposite
(
)
=
static_cast
<
uint8_t
>
(
aAnimation
-
>
GetEffect
(
)
-
>
AsKeyframeEffect
(
)
-
>
IterationComposite
(
)
)
;
animation
-
>
isNotPlaying
(
)
=
!
aAnimation
-
>
IsPlaying
(
)
;
TransformReferenceBox
refBox
(
aFrame
)
;
StyleAnimationValue
baseStyle
=
aAnimation
-
>
GetEffect
(
)
-
>
AsKeyframeEffect
(
)
-
>
BaseStyle
(
aProperty
.
mProperty
)
;
if
(
!
baseStyle
.
IsNull
(
)
)
{
SetAnimatable
(
aProperty
.
mProperty
{
baseStyle
nullptr
}
aFrame
refBox
animation
-
>
baseStyle
(
)
)
;
}
else
{
animation
-
>
baseStyle
(
)
=
null_t
(
)
;
}
for
(
uint32_t
segIdx
=
0
;
segIdx
<
aProperty
.
mSegments
.
Length
(
)
;
segIdx
+
+
)
{
const
AnimationPropertySegment
&
segment
=
aProperty
.
mSegments
[
segIdx
]
;
AnimationSegment
*
animSegment
=
animation
-
>
segments
(
)
.
AppendElement
(
)
;
SetAnimatable
(
aProperty
.
mProperty
segment
.
mFromValue
aFrame
refBox
animSegment
-
>
startState
(
)
)
;
SetAnimatable
(
aProperty
.
mProperty
segment
.
mToValue
aFrame
refBox
animSegment
-
>
endState
(
)
)
;
animSegment
-
>
startPortion
(
)
=
segment
.
mFromKey
;
animSegment
-
>
endPortion
(
)
=
segment
.
mToKey
;
animSegment
-
>
startComposite
(
)
=
static_cast
<
uint8_t
>
(
segment
.
mFromComposite
)
;
animSegment
-
>
endComposite
(
)
=
static_cast
<
uint8_t
>
(
segment
.
mToComposite
)
;
animSegment
-
>
sampleFn
(
)
=
ToTimingFunction
(
segment
.
mTimingFunction
)
;
}
}
static
void
AddAnimationsForProperty
(
nsIFrame
*
aFrame
nsCSSPropertyID
aProperty
nsTArray
<
RefPtr
<
dom
:
:
Animation
>
>
&
aAnimations
Layer
*
aLayer
AnimationData
&
aData
bool
aPending
)
{
MOZ_ASSERT
(
nsCSSProps
:
:
PropHasFlags
(
aProperty
CSS_PROPERTY_CAN_ANIMATE_ON_COMPOSITOR
)
"
inconsistent
property
flags
"
)
;
DebugOnly
<
EffectSet
*
>
effects
=
EffectSet
:
:
GetEffectSet
(
aFrame
)
;
MOZ_ASSERT
(
effects
)
;
for
(
size_t
animIdx
=
0
;
animIdx
<
aAnimations
.
Length
(
)
;
animIdx
+
+
)
{
dom
:
:
Animation
*
anim
=
aAnimations
[
animIdx
]
;
if
(
!
anim
-
>
IsRelevant
(
)
)
{
continue
;
}
dom
:
:
KeyframeEffectReadOnly
*
keyframeEffect
=
anim
-
>
GetEffect
(
)
?
anim
-
>
GetEffect
(
)
-
>
AsKeyframeEffect
(
)
:
nullptr
;
MOZ_ASSERT
(
keyframeEffect
"
A
playing
animation
should
have
a
keyframe
effect
"
)
;
const
AnimationProperty
*
property
=
keyframeEffect
-
>
GetEffectiveAnimationOfProperty
(
aProperty
)
;
if
(
!
property
)
{
continue
;
}
MOZ_ASSERT
(
anim
-
>
CascadeLevel
(
)
!
=
EffectCompositor
:
:
CascadeLevel
:
:
Animations
|
|
!
effects
-
>
PropertiesWithImportantRules
(
)
.
HasProperty
(
aProperty
)
"
GetEffectiveAnimationOfProperty
already
tested
the
property
"
"
is
not
overridden
by
!
important
rules
"
)
;
if
(
anim
-
>
PlayState
(
)
=
=
AnimationPlayState
:
:
Pending
&
&
(
anim
-
>
GetTimeline
(
)
&
&
!
anim
-
>
GetTimeline
(
)
-
>
TracksWallclockTime
(
)
)
)
{
continue
;
}
AddAnimationForProperty
(
aFrame
*
property
anim
aLayer
aData
aPending
)
;
keyframeEffect
-
>
SetIsRunningOnCompositor
(
aProperty
true
)
;
}
}
static
bool
GenerateAndPushTextMask
(
nsIFrame
*
aFrame
nsRenderingContext
*
aContext
const
nsRect
&
aFillRect
nsDisplayListBuilder
*
aBuilder
)
{
if
(
aBuilder
-
>
IsForGenerateGlyphMask
(
)
|
|
aBuilder
-
>
IsForPaintingSelectionBG
(
)
)
{
return
false
;
}
gfxContext
*
sourceCtx
=
aContext
-
>
ThebesContext
(
)
;
gfxRect
bounds
=
nsLayoutUtils
:
:
RectToGfxRect
(
aFillRect
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
{
gfxContextMatrixAutoSaveRestore
save
(
sourceCtx
)
;
sourceCtx
-
>
SetMatrix
(
sourceCtx
-
>
CurrentMatrix
(
)
.
Translate
(
bounds
.
TopLeft
(
)
)
)
;
nsLayoutUtils
:
:
PaintFrame
(
aContext
aFrame
nsRect
(
nsPoint
(
0
0
)
aFrame
-
>
GetSize
(
)
)
NS_RGB
(
255
255
255
)
nsDisplayListBuilderMode
:
:
PAINTING_SELECTION_BACKGROUND
)
;
}
IntRect
drawRect
;
{
gfxContextMatrixAutoSaveRestore
matRestore
(
sourceCtx
)
;
sourceCtx
-
>
SetMatrix
(
gfxMatrix
(
)
)
;
gfxRect
clipRect
=
sourceCtx
-
>
GetClipExtents
(
)
;
drawRect
=
RoundedOut
(
ToRect
(
clipRect
)
)
;
}
RefPtr
<
DrawTarget
>
sourceTarget
=
sourceCtx
-
>
GetDrawTarget
(
)
;
RefPtr
<
DrawTarget
>
maskDT
=
sourceTarget
-
>
CreateSimilarDrawTarget
(
drawRect
.
Size
(
)
SurfaceFormat
:
:
A8
)
;
if
(
!
maskDT
|
|
!
maskDT
-
>
IsValid
(
)
)
{
return
false
;
}
RefPtr
<
gfxContext
>
maskCtx
=
gfxContext
:
:
CreatePreservingTransformOrNull
(
maskDT
)
;
MOZ_ASSERT
(
maskCtx
)
;
gfxMatrix
currentMatrix
=
sourceCtx
-
>
CurrentMatrix
(
)
;
maskCtx
-
>
SetMatrix
(
gfxMatrix
:
:
Translation
(
bounds
.
TopLeft
(
)
)
*
currentMatrix
*
gfxMatrix
:
:
Translation
(
-
drawRect
.
TopLeft
(
)
)
)
;
nsRenderingContext
rc
(
maskCtx
)
;
nsLayoutUtils
:
:
PaintFrame
(
&
rc
aFrame
nsRect
(
nsPoint
(
0
0
)
aFrame
-
>
GetSize
(
)
)
NS_RGB
(
255
255
255
)
nsDisplayListBuilderMode
:
:
GENERATE_GLYPH
)
;
Matrix
maskTransform
=
ToMatrix
(
currentMatrix
)
*
Matrix
:
:
Translation
(
-
drawRect
.
x
-
drawRect
.
y
)
;
maskTransform
.
Invert
(
)
;
RefPtr
<
SourceSurface
>
maskSurface
=
maskDT
-
>
Snapshot
(
)
;
sourceCtx
-
>
PushGroupForBlendBack
(
gfxContentType
:
:
COLOR_ALPHA
1
.
0
maskSurface
maskTransform
)
;
return
true
;
}
void
nsDisplayListBuilder
:
:
AddAnimationsAndTransitionsToLayer
(
Layer
*
aLayer
nsDisplayListBuilder
*
aBuilder
nsDisplayItem
*
aItem
nsIFrame
*
aFrame
nsCSSPropertyID
aProperty
)
{
MOZ_ASSERT
(
nsCSSProps
:
:
PropHasFlags
(
aProperty
CSS_PROPERTY_CAN_ANIMATE_ON_COMPOSITOR
)
"
inconsistent
property
flags
"
)
;
MOZ_ASSERT
(
!
aBuilder
=
=
!
aItem
"
should
only
be
called
in
two
configurations
with
both
"
"
aBuilder
and
aItem
or
with
neither
"
)
;
MOZ_ASSERT
(
!
aItem
|
|
aFrame
=
=
aItem
-
>
Frame
(
)
"
frame
mismatch
"
)
;
LayersBackend
backend
=
aLayer
-
>
Manager
(
)
-
>
GetBackendType
(
)
;
if
(
!
(
backend
=
=
layers
:
:
LayersBackend
:
:
LAYERS_CLIENT
|
|
backend
=
=
layers
:
:
LayersBackend
:
:
LAYERS_WR
)
)
{
return
;
}
bool
pending
=
!
aBuilder
;
if
(
pending
)
{
aLayer
-
>
ClearAnimationsForNextTransaction
(
)
;
}
else
{
aLayer
-
>
ClearAnimations
(
)
;
}
uint64_t
animationGeneration
=
GeckoRestyleManager
:
:
GetAnimationGenerationForFrame
(
aFrame
)
;
aLayer
-
>
SetAnimationGeneration
(
animationGeneration
)
;
EffectCompositor
:
:
ClearIsRunningOnCompositor
(
aFrame
aProperty
)
;
nsTArray
<
RefPtr
<
dom
:
:
Animation
>
>
compositorAnimations
=
EffectCompositor
:
:
GetAnimationsForCompositor
(
aFrame
aProperty
)
;
if
(
compositorAnimations
.
IsEmpty
(
)
)
{
return
;
}
if
(
aItem
&
&
!
aItem
-
>
CanUseAsyncAnimations
(
aBuilder
)
)
{
aFrame
-
>
Properties
(
)
.
Set
(
nsIFrame
:
:
RefusedAsyncAnimationProperty
(
)
true
)
;
aFrame
-
>
SchedulePaint
(
)
;
return
;
}
AnimationData
data
;
if
(
aProperty
=
=
eCSSProperty_transform
)
{
TransformReferenceBox
refBox
(
aFrame
)
;
nsRect
bounds
(
0
0
refBox
.
Width
(
)
refBox
.
Height
(
)
)
;
int32_t
devPixelsToAppUnits
=
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
float
scale
=
devPixelsToAppUnits
;
Point3D
offsetToTransformOrigin
=
nsDisplayTransform
:
:
GetDeltaToTransformOrigin
(
aFrame
scale
&
bounds
)
;
nsPoint
origin
;
if
(
aItem
)
{
origin
=
aItem
-
>
ToReferenceFrame
(
)
;
}
else
{
nsIFrame
*
referenceFrame
=
nsLayoutUtils
:
:
GetReferenceFrame
(
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
aFrame
)
)
;
origin
=
aFrame
-
>
GetOffsetToCrossDoc
(
referenceFrame
)
;
}
data
=
TransformData
(
origin
offsetToTransformOrigin
bounds
devPixelsToAppUnits
)
;
}
else
if
(
aProperty
=
=
eCSSProperty_opacity
)
{
data
=
null_t
(
)
;
}
AddAnimationsForProperty
(
aFrame
aProperty
compositorAnimations
aLayer
data
pending
)
;
}
void
nsDisplayListBuilder
:
:
AutoCurrentActiveScrolledRootSetter
:
:
InsertScrollFrame
(
nsIScrollableFrame
*
aScrollableFrame
)
{
MOZ_ASSERT
(
!
mUsed
)
;
size_t
descendantsEndIndex
=
mBuilder
-
>
mActiveScrolledRoots
.
Length
(
)
;
const
ActiveScrolledRoot
*
parentASR
=
mBuilder
-
>
mCurrentActiveScrolledRoot
;
const
ActiveScrolledRoot
*
asr
=
mBuilder
-
>
AllocateActiveScrolledRoot
(
parentASR
aScrollableFrame
)
;
mBuilder
-
>
mCurrentActiveScrolledRoot
=
asr
;
for
(
size_t
i
=
mDescendantsStartIndex
;
i
<
descendantsEndIndex
;
i
+
+
)
{
ActiveScrolledRoot
*
descendantASR
=
mBuilder
-
>
mActiveScrolledRoots
[
i
]
;
if
(
ActiveScrolledRoot
:
:
IsAncestor
(
parentASR
descendantASR
)
)
{
descendantASR
-
>
IncrementDepth
(
)
;
if
(
descendantASR
-
>
mParent
=
=
parentASR
)
{
descendantASR
-
>
mParent
=
asr
;
}
}
}
mUsed
=
true
;
}
nsDisplayListBuilder
:
:
nsDisplayListBuilder
(
nsIFrame
*
aReferenceFrame
nsDisplayListBuilderMode
aMode
bool
aBuildCaret
)
:
mReferenceFrame
(
aReferenceFrame
)
mIgnoreScrollFrame
(
nullptr
)
mLayerEventRegions
(
nullptr
)
mCurrentTableItem
(
nullptr
)
mCurrentActiveScrolledRoot
(
nullptr
)
mCurrentContainerASR
(
nullptr
)
mCurrentFrame
(
aReferenceFrame
)
mCurrentReferenceFrame
(
aReferenceFrame
)
mCurrentAGR
(
&
mRootAGR
)
mRootAGR
(
aReferenceFrame
nullptr
)
mUsedAGRBudget
(
0
)
mDirtyRect
(
-
1
-
1
-
1
-
1
)
mGlassDisplayItem
(
nullptr
)
mScrollInfoItemsForHoisting
(
nullptr
)
mActiveScrolledRootForRootScrollframe
(
nullptr
)
mMode
(
aMode
)
mCurrentScrollParentId
(
FrameMetrics
:
:
NULL_SCROLL_ID
)
mCurrentScrollbarTarget
(
FrameMetrics
:
:
NULL_SCROLL_ID
)
mCurrentScrollbarFlags
(
0
)
mPerspectiveItemIndex
(
0
)
mSVGEffectsBuildingDepth
(
0
)
mContainsBlendMode
(
false
)
mIsBuildingScrollbar
(
false
)
mCurrentScrollbarWillHaveLayer
(
false
)
mBuildCaret
(
aBuildCaret
)
mIgnoreSuppression
(
false
)
mIsAtRootOfPseudoStackingContext
(
false
)
mIncludeAllOutOfFlows
(
false
)
mDescendIntoSubdocuments
(
true
)
mSelectedFramesOnly
(
false
)
mAccurateVisibleRegions
(
false
)
mAllowMergingAndFlattening
(
true
)
mWillComputePluginGeometry
(
false
)
mInTransform
(
false
)
mIsInChromePresContext
(
false
)
mSyncDecodeImages
(
false
)
mIsPaintingToWindow
(
false
)
mIsCompositingCheap
(
false
)
mContainsPluginItem
(
false
)
mAncestorHasApzAwareEventHandler
(
false
)
mHaveScrollableDisplayPort
(
false
)
mWindowDraggingAllowed
(
false
)
mIsBuildingForPopup
(
nsLayoutUtils
:
:
IsPopup
(
aReferenceFrame
)
)
mForceLayerForScrollParent
(
false
)
mAsyncPanZoomEnabled
(
nsLayoutUtils
:
:
AsyncPanZoomEnabled
(
aReferenceFrame
)
)
mBuildingInvisibleItems
(
false
)
mHitTestShouldStopAtFirstOpaque
(
false
)
{
MOZ_COUNT_CTOR
(
nsDisplayListBuilder
)
;
PL_InitArenaPool
(
&
mPool
"
displayListArena
"
4096
std
:
:
max
(
NS_ALIGNMENT_OF
(
void
*
)
NS_ALIGNMENT_OF
(
double
)
)
-
1
)
;
nsPresContext
*
pc
=
aReferenceFrame
-
>
PresContext
(
)
;
nsIPresShell
*
shell
=
pc
-
>
PresShell
(
)
;
if
(
pc
-
>
IsRenderingOnlySelection
(
)
)
{
nsCOMPtr
<
nsISelectionController
>
selcon
(
do_QueryInterface
(
shell
)
)
;
if
(
selcon
)
{
selcon
-
>
GetSelection
(
nsISelectionController
:
:
SELECTION_NORMAL
getter_AddRefs
(
mBoundingSelection
)
)
;
}
}
mFrameToAnimatedGeometryRootMap
.
Put
(
aReferenceFrame
&
mRootAGR
)
;
nsCSSRendering
:
:
BeginFrameTreesLocked
(
)
;
static_assert
(
nsDisplayItem
:
:
TYPE_MAX
<
(
1
<
<
nsDisplayItem
:
:
TYPE_BITS
)
"
Check
nsDisplayItem
:
:
TYPE_MAX
should
not
overflow
"
)
;
}
static
void
MarkFrameForDisplay
(
nsIFrame
*
aFrame
nsIFrame
*
aStopAtFrame
)
{
for
(
nsIFrame
*
f
=
aFrame
;
f
;
f
=
nsLayoutUtils
:
:
GetParentOrPlaceholderFor
(
f
)
)
{
if
(
f
-
>
GetStateBits
(
)
&
NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO
)
return
;
f
-
>
AddStateBits
(
NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO
)
;
if
(
f
=
=
aStopAtFrame
)
{
break
;
}
}
}
bool
nsDisplayListBuilder
:
:
NeedToForceTransparentSurfaceForItem
(
nsDisplayItem
*
aItem
)
{
return
aItem
=
=
mGlassDisplayItem
|
|
aItem
-
>
ClearsBackground
(
)
;
}
AnimatedGeometryRoot
*
nsDisplayListBuilder
:
:
WrapAGRForFrame
(
nsIFrame
*
aAnimatedGeometryRoot
AnimatedGeometryRoot
*
aParent
)
{
MOZ_ASSERT
(
IsAnimatedGeometryRoot
(
aAnimatedGeometryRoot
)
)
;
AnimatedGeometryRoot
*
result
=
nullptr
;
if
(
!
mFrameToAnimatedGeometryRootMap
.
Get
(
aAnimatedGeometryRoot
&
result
)
)
{
MOZ_ASSERT
(
nsLayoutUtils
:
:
IsAncestorFrameCrossDoc
(
RootReferenceFrame
(
)
aAnimatedGeometryRoot
)
)
;
AnimatedGeometryRoot
*
parent
=
aParent
;
if
(
!
parent
)
{
nsIFrame
*
parentFrame
=
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
aAnimatedGeometryRoot
)
;
if
(
parentFrame
)
{
nsIFrame
*
parentAGRFrame
=
FindAnimatedGeometryRootFrameFor
(
parentFrame
)
;
parent
=
WrapAGRForFrame
(
parentAGRFrame
)
;
}
}
result
=
new
(
this
)
AnimatedGeometryRoot
(
aAnimatedGeometryRoot
parent
)
;
mFrameToAnimatedGeometryRootMap
.
Put
(
aAnimatedGeometryRoot
result
)
;
}
MOZ_ASSERT
(
!
aParent
|
|
result
-
>
mParentAGR
=
=
aParent
)
;
return
result
;
}
AnimatedGeometryRoot
*
nsDisplayListBuilder
:
:
AnimatedGeometryRootForASR
(
const
ActiveScrolledRoot
*
aASR
)
{
if
(
!
aASR
)
{
return
GetRootAnimatedGeometryRoot
(
)
;
}
nsIFrame
*
scrolledFrame
=
aASR
-
>
mScrollableFrame
-
>
GetScrolledFrame
(
)
;
return
FindAnimatedGeometryRootFor
(
scrolledFrame
)
;
}
AnimatedGeometryRoot
*
nsDisplayListBuilder
:
:
FindAnimatedGeometryRootFor
(
nsIFrame
*
aFrame
)
{
if
(
!
IsPaintingToWindow
(
)
)
{
return
&
mRootAGR
;
}
if
(
aFrame
=
=
mCurrentFrame
)
{
return
mCurrentAGR
;
}
AnimatedGeometryRoot
*
result
=
nullptr
;
if
(
mFrameToAnimatedGeometryRootMap
.
Get
(
aFrame
&
result
)
)
{
return
result
;
}
nsIFrame
*
agrFrame
=
FindAnimatedGeometryRootFrameFor
(
aFrame
)
;
result
=
WrapAGRForFrame
(
agrFrame
)
;
mFrameToAnimatedGeometryRootMap
.
Put
(
aFrame
result
)
;
return
result
;
}
AnimatedGeometryRoot
*
nsDisplayListBuilder
:
:
FindAnimatedGeometryRootFor
(
nsDisplayItem
*
aItem
)
{
if
(
aItem
-
>
ShouldFixToViewport
(
this
)
)
{
nsIFrame
*
viewportFrame
=
nsLayoutUtils
:
:
GetClosestFrameOfType
(
aItem
-
>
Frame
(
)
nsGkAtoms
:
:
viewportFrame
RootReferenceFrame
(
)
)
;
if
(
viewportFrame
)
{
return
FindAnimatedGeometryRootFor
(
viewportFrame
)
;
}
}
return
FindAnimatedGeometryRootFor
(
aItem
-
>
Frame
(
)
)
;
}
void
nsDisplayListBuilder
:
:
MarkOutOfFlowFrameForDisplay
(
nsIFrame
*
aDirtyFrame
nsIFrame
*
aFrame
const
nsRect
&
aDirtyRect
)
{
nsRect
dirtyRectRelativeToDirtyFrame
=
aDirtyRect
;
if
(
nsLayoutUtils
:
:
IsFixedPosFrameInDisplayPort
(
aFrame
)
&
&
IsPaintingToWindow
(
)
)
{
NS_ASSERTION
(
aDirtyFrame
=
=
aFrame
-
>
GetParent
(
)
"
Dirty
frame
should
be
viewport
frame
"
)
;
nsIPresShell
*
ps
=
aFrame
-
>
PresContext
(
)
-
>
PresShell
(
)
;
dirtyRectRelativeToDirtyFrame
.
MoveTo
(
0
0
)
;
if
(
ps
-
>
IsScrollPositionClampingScrollPortSizeSet
(
)
)
{
dirtyRectRelativeToDirtyFrame
.
SizeTo
(
ps
-
>
GetScrollPositionClampingScrollPortSize
(
)
)
;
}
else
{
dirtyRectRelativeToDirtyFrame
.
SizeTo
(
aDirtyFrame
-
>
GetSize
(
)
)
;
}
}
nsRect
dirty
=
dirtyRectRelativeToDirtyFrame
-
aFrame
-
>
GetOffsetTo
(
aDirtyFrame
)
;
nsRect
overflowRect
=
aFrame
-
>
GetVisualOverflowRect
(
)
;
if
(
aFrame
-
>
IsTransformed
(
)
&
&
EffectCompositor
:
:
HasAnimationsForCompositor
(
aFrame
eCSSProperty_transform
)
)
{
overflowRect
.
Inflate
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
32
)
)
;
}
if
(
!
dirty
.
IntersectRect
(
dirty
overflowRect
)
&
&
!
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO
)
)
{
return
;
}
const
DisplayItemClipChain
*
clipChain
=
CopyWholeChain
(
mClipState
.
GetClipChainForContainingBlockDescendants
(
)
)
;
const
DisplayItemClipChain
*
combinedClipChain
=
mClipState
.
GetCurrentCombinedClipChain
(
this
)
;
const
ActiveScrolledRoot
*
asr
=
mCurrentActiveScrolledRoot
;
OutOfFlowDisplayData
*
data
=
new
OutOfFlowDisplayData
(
clipChain
combinedClipChain
asr
dirty
)
;
aFrame
-
>
Properties
(
)
.
Set
(
nsDisplayListBuilder
:
:
OutOfFlowDisplayDataProperty
(
)
data
)
;
MarkFrameForDisplay
(
aFrame
aDirtyFrame
)
;
}
static
void
UnmarkFrameForDisplay
(
nsIFrame
*
aFrame
)
{
nsPresContext
*
presContext
=
aFrame
-
>
PresContext
(
)
;
presContext
-
>
PropertyTable
(
)
-
>
Delete
(
aFrame
nsDisplayListBuilder
:
:
OutOfFlowDisplayDataProperty
(
)
)
;
for
(
nsIFrame
*
f
=
aFrame
;
f
;
f
=
nsLayoutUtils
:
:
GetParentOrPlaceholderFor
(
f
)
)
{
if
(
!
(
f
-
>
GetStateBits
(
)
&
NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO
)
)
return
;
f
-
>
RemoveStateBits
(
NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO
)
;
}
}
nsDisplayListBuilder
:
:
~
nsDisplayListBuilder
(
)
{
NS_ASSERTION
(
mFramesMarkedForDisplay
.
Length
(
)
=
=
0
"
All
frames
should
have
been
unmarked
"
)
;
NS_ASSERTION
(
mPresShellStates
.
Length
(
)
=
=
0
"
All
presshells
should
have
been
exited
"
)
;
NS_ASSERTION
(
!
mCurrentTableItem
"
No
table
item
should
be
active
"
)
;
nsCSSRendering
:
:
EndFrameTreesLocked
(
)
;
for
(
ActiveScrolledRoot
*
asr
:
mActiveScrolledRoots
)
{
asr
-
>
ActiveScrolledRoot
:
:
~
ActiveScrolledRoot
(
)
;
}
for
(
DisplayItemClipChain
*
c
:
mClipChainsToDestroy
)
{
c
-
>
DisplayItemClipChain
:
:
~
DisplayItemClipChain
(
)
;
}
PL_FinishArenaPool
(
&
mPool
)
;
MOZ_COUNT_DTOR
(
nsDisplayListBuilder
)
;
}
uint32_t
nsDisplayListBuilder
:
:
GetBackgroundPaintFlags
(
)
{
uint32_t
flags
=
0
;
if
(
mSyncDecodeImages
)
{
flags
|
=
nsCSSRendering
:
:
PAINTBG_SYNC_DECODE_IMAGES
;
}
if
(
mIsPaintingToWindow
)
{
flags
|
=
nsCSSRendering
:
:
PAINTBG_TO_WINDOW
;
}
return
flags
;
}
void
nsDisplayListBuilder
:
:
SubtractFromVisibleRegion
(
nsRegion
*
aVisibleRegion
const
nsRegion
&
aRegion
)
{
if
(
aRegion
.
IsEmpty
(
)
)
return
;
nsRegion
tmp
;
tmp
.
Sub
(
*
aVisibleRegion
aRegion
)
;
if
(
GetAccurateVisibleRegions
(
)
|
|
tmp
.
GetNumRects
(
)
<
=
15
|
|
tmp
.
Area
(
)
<
=
aVisibleRegion
-
>
Area
(
)
/
2
)
{
*
aVisibleRegion
=
tmp
;
}
}
nsCaret
*
nsDisplayListBuilder
:
:
GetCaret
(
)
{
RefPtr
<
nsCaret
>
caret
=
CurrentPresShellState
(
)
-
>
mPresShell
-
>
GetCaret
(
)
;
return
caret
;
}
void
nsDisplayListBuilder
:
:
EnterPresShell
(
nsIFrame
*
aReferenceFrame
bool
aPointerEventsNoneDoc
)
{
PresShellState
*
state
=
mPresShellStates
.
AppendElement
(
)
;
state
-
>
mPresShell
=
aReferenceFrame
-
>
PresContext
(
)
-
>
PresShell
(
)
;
state
-
>
mCaretFrame
=
nullptr
;
state
-
>
mFirstFrameMarkedForDisplay
=
mFramesMarkedForDisplay
.
Length
(
)
;
state
-
>
mPresShell
-
>
UpdateCanvasBackground
(
)
;
if
(
mIsPaintingToWindow
)
{
mReferenceFrame
-
>
AddPaintedPresShell
(
state
-
>
mPresShell
)
;
state
-
>
mPresShell
-
>
IncrementPaintCount
(
)
;
}
bool
buildCaret
=
mBuildCaret
;
if
(
mIgnoreSuppression
|
|
!
state
-
>
mPresShell
-
>
IsPaintingSuppressed
(
)
)
{
state
-
>
mIsBackgroundOnly
=
false
;
}
else
{
state
-
>
mIsBackgroundOnly
=
true
;
buildCaret
=
false
;
}
bool
pointerEventsNone
=
aPointerEventsNoneDoc
;
if
(
IsInSubdocument
(
)
)
{
pointerEventsNone
|
=
mPresShellStates
[
mPresShellStates
.
Length
(
)
-
2
]
.
mInsidePointerEventsNoneDoc
;
}
state
-
>
mInsidePointerEventsNoneDoc
=
pointerEventsNone
;
if
(
!
buildCaret
)
return
;
RefPtr
<
nsCaret
>
caret
=
state
-
>
mPresShell
-
>
GetCaret
(
)
;
state
-
>
mCaretFrame
=
caret
-
>
GetPaintGeometry
(
&
state
-
>
mCaretRect
)
;
if
(
state
-
>
mCaretFrame
)
{
mFramesMarkedForDisplay
.
AppendElement
(
state
-
>
mCaretFrame
)
;
MarkFrameForDisplay
(
state
-
>
mCaretFrame
nullptr
)
;
}
nsPresContext
*
pc
=
aReferenceFrame
-
>
PresContext
(
)
;
nsCOMPtr
<
nsIDocShell
>
docShell
=
pc
-
>
GetDocShell
(
)
;
if
(
docShell
)
{
docShell
-
>
GetWindowDraggingAllowed
(
&
mWindowDraggingAllowed
)
;
}
mIsInChromePresContext
=
pc
-
>
IsChrome
(
)
;
}
static
bool
DisplayListIsNonBlank
(
nsDisplayList
*
aList
)
{
for
(
nsDisplayItem
*
i
=
aList
-
>
GetBottom
(
)
;
i
!
=
nullptr
;
i
=
i
-
>
GetAbove
(
)
)
{
switch
(
i
-
>
GetType
(
)
)
{
case
nsDisplayItem
:
:
TYPE_LAYER_EVENT_REGIONS
:
case
nsDisplayItem
:
:
TYPE_CANVAS_BACKGROUND_COLOR
:
case
nsDisplayItem
:
:
TYPE_CANVAS_BACKGROUND_IMAGE
:
continue
;
case
nsDisplayItem
:
:
TYPE_SOLID_COLOR
:
case
nsDisplayItem
:
:
TYPE_BACKGROUND
:
case
nsDisplayItem
:
:
TYPE_BACKGROUND_COLOR
:
if
(
i
-
>
Frame
(
)
-
>
GetType
(
)
=
=
nsGkAtoms
:
:
canvasFrame
)
{
continue
;
}
return
true
;
default
:
return
true
;
}
}
return
false
;
}
void
nsDisplayListBuilder
:
:
LeavePresShell
(
nsIFrame
*
aReferenceFrame
nsDisplayList
*
aPaintedContents
)
{
NS_ASSERTION
(
CurrentPresShellState
(
)
-
>
mPresShell
=
=
aReferenceFrame
-
>
PresContext
(
)
-
>
PresShell
(
)
"
Presshell
mismatch
"
)
;
if
(
mIsPaintingToWindow
)
{
nsPresContext
*
pc
=
aReferenceFrame
-
>
PresContext
(
)
;
if
(
!
pc
-
>
HadNonBlankPaint
(
)
)
{
if
(
!
CurrentPresShellState
(
)
-
>
mIsBackgroundOnly
&
&
DisplayListIsNonBlank
(
aPaintedContents
)
)
{
pc
-
>
NotifyNonBlankPaint
(
)
;
}
}
}
ResetMarkedFramesForDisplayList
(
)
;
mPresShellStates
.
SetLength
(
mPresShellStates
.
Length
(
)
-
1
)
;
if
(
!
mPresShellStates
.
IsEmpty
(
)
)
{
nsPresContext
*
pc
=
CurrentPresContext
(
)
;
nsCOMPtr
<
nsIDocShell
>
docShell
=
pc
-
>
GetDocShell
(
)
;
if
(
docShell
)
{
docShell
-
>
GetWindowDraggingAllowed
(
&
mWindowDraggingAllowed
)
;
}
mIsInChromePresContext
=
pc
-
>
IsChrome
(
)
;
}
}
void
nsDisplayListBuilder
:
:
ResetMarkedFramesForDisplayList
(
)
{
uint32_t
firstFrameForShell
=
CurrentPresShellState
(
)
-
>
mFirstFrameMarkedForDisplay
;
for
(
uint32_t
i
=
firstFrameForShell
;
i
<
mFramesMarkedForDisplay
.
Length
(
)
;
+
+
i
)
{
UnmarkFrameForDisplay
(
mFramesMarkedForDisplay
[
i
]
)
;
}
mFramesMarkedForDisplay
.
SetLength
(
firstFrameForShell
)
;
}
void
nsDisplayListBuilder
:
:
MarkFramesForDisplayList
(
nsIFrame
*
aDirtyFrame
const
nsFrameList
&
aFrames
const
nsRect
&
aDirtyRect
)
{
mFramesMarkedForDisplay
.
SetCapacity
(
mFramesMarkedForDisplay
.
Length
(
)
+
aFrames
.
GetLength
(
)
)
;
for
(
nsIFrame
*
e
:
aFrames
)
{
if
(
!
IsBuildingCaret
(
)
)
{
nsIContent
*
content
=
e
-
>
GetContent
(
)
;
if
(
content
&
&
content
-
>
IsInNativeAnonymousSubtree
(
)
&
&
content
-
>
IsElement
(
)
)
{
auto
classList
=
content
-
>
AsElement
(
)
-
>
ClassList
(
)
;
if
(
classList
-
>
Contains
(
NS_LITERAL_STRING
(
"
moz
-
accessiblecaret
"
)
)
)
{
continue
;
}
}
}
mFramesMarkedForDisplay
.
AppendElement
(
e
)
;
MarkOutOfFlowFrameForDisplay
(
aDirtyFrame
e
aDirtyRect
)
;
}
if
(
!
aDirtyFrame
-
>
GetParent
(
)
)
{
NS_ASSERTION
(
CurrentPresShellState
(
)
-
>
mPresShell
=
=
aDirtyFrame
-
>
PresContext
(
)
-
>
PresShell
(
)
"
Presshell
mismatch
"
)
;
MOZ_ASSERT
(
!
CurrentPresShellState
(
)
-
>
mFixedBackgroundDisplayData
"
already
traversed
this
presshell
'
s
root
frame
?
"
)
;
const
DisplayItemClipChain
*
clipChain
=
CopyWholeChain
(
mClipState
.
GetClipChainForContainingBlockDescendants
(
)
)
;
const
DisplayItemClipChain
*
combinedClipChain
=
mClipState
.
GetCurrentCombinedClipChain
(
this
)
;
const
ActiveScrolledRoot
*
asr
=
mCurrentActiveScrolledRoot
;
CurrentPresShellState
(
)
-
>
mFixedBackgroundDisplayData
.
emplace
(
clipChain
combinedClipChain
asr
aDirtyRect
)
;
}
}
void
nsDisplayListBuilder
:
:
MarkPreserve3DFramesForDisplayList
(
nsIFrame
*
aDirtyFrame
)
{
AutoTArray
<
nsIFrame
:
:
ChildList
4
>
childListArray
;
aDirtyFrame
-
>
GetChildLists
(
&
childListArray
)
;
nsIFrame
:
:
ChildListArrayIterator
lists
(
childListArray
)
;
for
(
;
!
lists
.
IsDone
(
)
;
lists
.
Next
(
)
)
{
nsFrameList
:
:
Enumerator
childFrames
(
lists
.
CurrentList
(
)
)
;
for
(
;
!
childFrames
.
AtEnd
(
)
;
childFrames
.
Next
(
)
)
{
nsIFrame
*
child
=
childFrames
.
get
(
)
;
if
(
child
-
>
Combines3DTransformWithAncestors
(
)
)
{
mFramesMarkedForDisplay
.
AppendElement
(
child
)
;
MarkFrameForDisplay
(
child
aDirtyFrame
)
;
}
}
}
}
void
*
nsDisplayListBuilder
:
:
Allocate
(
size_t
aSize
)
{
void
*
tmp
;
PL_ARENA_ALLOCATE
(
tmp
&
mPool
aSize
)
;
if
(
!
tmp
)
{
NS_ABORT_OOM
(
aSize
)
;
}
return
tmp
;
}
ActiveScrolledRoot
*
nsDisplayListBuilder
:
:
AllocateActiveScrolledRoot
(
const
ActiveScrolledRoot
*
aParent
nsIScrollableFrame
*
aScrollableFrame
)
{
void
*
p
=
Allocate
(
sizeof
(
ActiveScrolledRoot
)
)
;
ActiveScrolledRoot
*
asr
=
new
(
KnownNotNull
p
)
ActiveScrolledRoot
(
aParent
aScrollableFrame
)
;
mActiveScrolledRoots
.
AppendElement
(
asr
)
;
return
asr
;
}
const
DisplayItemClipChain
*
nsDisplayListBuilder
:
:
AllocateDisplayItemClipChain
(
const
DisplayItemClip
&
aClip
const
ActiveScrolledRoot
*
aASR
const
DisplayItemClipChain
*
aParent
)
{
void
*
p
=
Allocate
(
sizeof
(
DisplayItemClipChain
)
)
;
DisplayItemClipChain
*
c
=
new
(
KnownNotNull
p
)
DisplayItemClipChain
{
aClip
aASR
aParent
}
;
mClipChainsToDestroy
.
AppendElement
(
c
)
;
return
c
;
}
struct
ClipChainItem
{
DisplayItemClip
clip
;
const
ActiveScrolledRoot
*
asr
;
}
;
const
DisplayItemClipChain
*
nsDisplayListBuilder
:
:
CreateClipChainIntersection
(
const
DisplayItemClipChain
*
aAncestor
const
DisplayItemClipChain
*
aLeafClip1
const
DisplayItemClipChain
*
aLeafClip2
)
{
AutoTArray
<
ClipChainItem
8
>
intersectedClips
;
const
DisplayItemClipChain
*
clip1
=
aLeafClip1
;
const
DisplayItemClipChain
*
clip2
=
aLeafClip2
;
const
ActiveScrolledRoot
*
asr
=
ActiveScrolledRoot
:
:
PickDescendant
(
clip1
?
clip1
-
>
mASR
:
nullptr
clip2
?
clip2
-
>
mASR
:
nullptr
)
;
while
(
!
aAncestor
|
|
asr
!
=
aAncestor
-
>
mASR
)
{
if
(
clip1
&
&
clip1
-
>
mASR
=
=
asr
)
{
if
(
clip2
&
&
clip2
-
>
mASR
=
=
asr
)
{
DisplayItemClip
intersection
=
clip1
-
>
mClip
;
intersection
.
IntersectWith
(
clip2
-
>
mClip
)
;
intersectedClips
.
AppendElement
(
ClipChainItem
{
intersection
asr
}
)
;
clip2
=
clip2
-
>
mParent
;
}
else
{
intersectedClips
.
AppendElement
(
ClipChainItem
{
clip1
-
>
mClip
asr
}
)
;
}
clip1
=
clip1
-
>
mParent
;
}
else
if
(
clip2
&
&
clip2
-
>
mASR
=
=
asr
)
{
intersectedClips
.
AppendElement
(
ClipChainItem
{
clip2
-
>
mClip
asr
}
)
;
clip2
=
clip2
-
>
mParent
;
}
if
(
!
asr
)
{
MOZ_ASSERT
(
!
aAncestor
"
We
should
have
exited
this
loop
earlier
"
)
;
break
;
}
asr
=
asr
-
>
mParent
;
}
const
DisplayItemClipChain
*
parentSC
=
aAncestor
;
for
(
auto
&
sc
:
Reversed
(
intersectedClips
)
)
{
parentSC
=
AllocateDisplayItemClipChain
(
sc
.
clip
sc
.
asr
parentSC
)
;
}
return
parentSC
;
}
const
DisplayItemClipChain
*
nsDisplayListBuilder
:
:
CopyWholeChain
(
const
DisplayItemClipChain
*
aClipChain
)
{
return
CreateClipChainIntersection
(
nullptr
aClipChain
nullptr
)
;
}
const
nsIFrame
*
nsDisplayListBuilder
:
:
FindReferenceFrameFor
(
const
nsIFrame
*
aFrame
nsPoint
*
aOffset
)
{
if
(
aFrame
=
=
mCurrentFrame
)
{
if
(
aOffset
)
{
*
aOffset
=
mCurrentOffsetToReferenceFrame
;
}
return
mCurrentReferenceFrame
;
}
for
(
const
nsIFrame
*
f
=
aFrame
;
f
;
f
=
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
f
)
)
{
if
(
f
=
=
mReferenceFrame
|
|
f
-
>
IsTransformed
(
)
)
{
if
(
aOffset
)
{
*
aOffset
=
aFrame
-
>
GetOffsetToCrossDoc
(
f
)
;
}
return
f
;
}
}
if
(
aOffset
)
{
*
aOffset
=
aFrame
-
>
GetOffsetToCrossDoc
(
mReferenceFrame
)
;
}
return
mReferenceFrame
;
}
static
bool
IsStickyFrameActive
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsIFrame
*
aParent
)
{
MOZ_ASSERT
(
aFrame
-
>
StyleDisplay
(
)
-
>
mPosition
=
=
NS_STYLE_POSITION_STICKY
)
;
nsIFrame
*
cursor
=
aFrame
;
nsIFrame
*
parent
=
aParent
;
if
(
!
parent
)
{
parent
=
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
aFrame
)
;
}
while
(
parent
-
>
GetType
(
)
!
=
nsGkAtoms
:
:
scrollFrame
)
{
cursor
=
parent
;
if
(
(
parent
=
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
cursor
)
)
=
=
nullptr
)
{
return
false
;
}
}
nsIScrollableFrame
*
sf
=
do_QueryFrame
(
parent
)
;
return
sf
-
>
IsScrollingActive
(
aBuilder
)
&
&
sf
-
>
GetScrolledFrame
(
)
=
=
cursor
;
}
bool
nsDisplayListBuilder
:
:
IsAnimatedGeometryRoot
(
nsIFrame
*
aFrame
nsIFrame
*
*
aParent
)
{
if
(
aFrame
=
=
mReferenceFrame
)
{
return
true
;
}
if
(
!
IsPaintingToWindow
(
)
)
{
if
(
aParent
)
{
*
aParent
=
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
aFrame
)
;
}
return
false
;
}
if
(
nsLayoutUtils
:
:
IsPopup
(
aFrame
)
)
return
true
;
if
(
ActiveLayerTracker
:
:
IsOffsetOrMarginStyleAnimated
(
aFrame
)
)
{
const
bool
inBudget
=
AddToAGRBudget
(
aFrame
)
;
if
(
inBudget
)
{
return
true
;
}
}
if
(
!
aFrame
-
>
GetParent
(
)
&
&
nsLayoutUtils
:
:
ViewportHasDisplayPort
(
aFrame
-
>
PresContext
(
)
)
)
{
return
true
;
}
if
(
aFrame
-
>
IsTransformed
(
)
)
{
return
true
;
}
nsIFrame
*
parent
=
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
aFrame
)
;
if
(
!
parent
)
return
true
;
nsIAtom
*
parentType
=
parent
-
>
GetType
(
)
;
if
(
parentType
=
=
nsGkAtoms
:
:
sliderFrame
&
&
nsLayoutUtils
:
:
IsScrollbarThumbLayerized
(
aFrame
)
)
{
return
true
;
}
if
(
aFrame
-
>
StyleDisplay
(
)
-
>
mPosition
=
=
NS_STYLE_POSITION_STICKY
&
&
IsStickyFrameActive
(
this
aFrame
parent
)
)
{
return
true
;
}
if
(
parentType
=
=
nsGkAtoms
:
:
scrollFrame
|
|
parentType
=
=
nsGkAtoms
:
:
listControlFrame
)
{
nsIScrollableFrame
*
sf
=
do_QueryFrame
(
parent
)
;
if
(
sf
-
>
IsScrollingActive
(
this
)
&
&
sf
-
>
GetScrolledFrame
(
)
=
=
aFrame
)
{
return
true
;
}
}
if
(
nsLayoutUtils
:
:
IsFixedPosFrameInDisplayPort
(
aFrame
)
)
{
return
true
;
}
if
(
aParent
)
{
*
aParent
=
parent
;
}
return
false
;
}
nsIFrame
*
nsDisplayListBuilder
:
:
FindAnimatedGeometryRootFrameFor
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
nsLayoutUtils
:
:
IsAncestorFrameCrossDoc
(
RootReferenceFrame
(
)
aFrame
)
)
;
nsIFrame
*
cursor
=
aFrame
;
while
(
cursor
!
=
RootReferenceFrame
(
)
)
{
nsIFrame
*
next
;
if
(
IsAnimatedGeometryRoot
(
cursor
&
next
)
)
return
cursor
;
cursor
=
next
;
}
return
cursor
;
}
void
nsDisplayListBuilder
:
:
RecomputeCurrentAnimatedGeometryRoot
(
)
{
if
(
*
mCurrentAGR
!
=
mCurrentFrame
&
&
IsAnimatedGeometryRoot
(
const_cast
<
nsIFrame
*
>
(
mCurrentFrame
)
)
)
{
AnimatedGeometryRoot
*
oldAGR
=
mCurrentAGR
;
mCurrentAGR
=
WrapAGRForFrame
(
const_cast
<
nsIFrame
*
>
(
mCurrentFrame
)
mCurrentAGR
)
;
for
(
auto
iter
=
mFrameToAnimatedGeometryRootMap
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
AnimatedGeometryRoot
*
cached
=
iter
.
UserData
(
)
;
if
(
cached
-
>
mParentAGR
=
=
oldAGR
&
&
cached
!
=
mCurrentAGR
)
{
nsIFrame
*
parent
=
FindAnimatedGeometryRootFrameFor
(
*
cached
)
;
MOZ_ASSERT
(
parent
=
=
mCurrentFrame
|
|
parent
=
=
*
oldAGR
)
;
if
(
parent
=
=
mCurrentFrame
)
{
cached
-
>
mParentAGR
=
mCurrentAGR
;
}
}
}
}
}
static
nsRect
ApplyAllClipNonRoundedIntersection
(
const
DisplayItemClipChain
*
aClipChain
const
nsRect
&
aRect
)
{
nsRect
result
=
aRect
;
while
(
aClipChain
)
{
result
=
aClipChain
-
>
mClip
.
ApplyNonRoundedIntersection
(
result
)
;
aClipChain
=
aClipChain
-
>
mParent
;
}
return
result
;
}
void
nsDisplayListBuilder
:
:
AdjustWindowDraggingRegion
(
nsIFrame
*
aFrame
)
{
if
(
!
mWindowDraggingAllowed
|
|
!
IsForPainting
(
)
)
{
return
;
}
const
nsStyleUIReset
*
styleUI
=
aFrame
-
>
StyleUIReset
(
)
;
if
(
styleUI
-
>
mWindowDragging
=
=
StyleWindowDragging
:
:
Default
)
{
return
;
}
LayoutDeviceToLayoutDeviceMatrix4x4
referenceFrameToRootReferenceFrame
;
nsIFrame
*
referenceFrame
=
const_cast
<
nsIFrame
*
>
(
FindReferenceFrameFor
(
aFrame
)
)
;
if
(
IsInTransform
(
)
)
{
referenceFrameToRootReferenceFrame
=
ViewAs
<
LayoutDeviceToLayoutDeviceMatrix4x4
>
(
nsLayoutUtils
:
:
GetTransformToAncestor
(
referenceFrame
mReferenceFrame
)
)
;
Matrix
referenceFrameToRootReferenceFrame2d
;
if
(
!
referenceFrameToRootReferenceFrame
.
Is2D
(
&
referenceFrameToRootReferenceFrame2d
)
|
|
!
referenceFrameToRootReferenceFrame2d
.
IsRectilinear
(
)
)
{
return
;
}
}
else
{
MOZ_ASSERT
(
referenceFrame
=
=
mReferenceFrame
"
referenceFrameToRootReferenceFrame
needs
to
be
adjusted
"
)
;
}
nsRect
borderBox
=
aFrame
-
>
GetRectRelativeToSelf
(
)
.
Intersect
(
mDirtyRect
)
;
borderBox
+
=
ToReferenceFrame
(
aFrame
)
;
const
DisplayItemClipChain
*
clip
=
ClipState
(
)
.
GetCurrentCombinedClipChain
(
this
)
;
borderBox
=
ApplyAllClipNonRoundedIntersection
(
clip
borderBox
)
;
if
(
!
borderBox
.
IsEmpty
(
)
)
{
LayoutDeviceRect
devPixelBorderBox
=
LayoutDevicePixel
:
:
FromAppUnits
(
borderBox
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
LayoutDeviceRect
transformedDevPixelBorderBox
=
TransformBy
(
referenceFrameToRootReferenceFrame
devPixelBorderBox
)
;
transformedDevPixelBorderBox
.
Round
(
)
;
LayoutDeviceIntRect
transformedDevPixelBorderBoxInt
;
if
(
transformedDevPixelBorderBox
.
ToIntRect
(
&
transformedDevPixelBorderBoxInt
)
)
{
if
(
styleUI
-
>
mWindowDragging
=
=
StyleWindowDragging
:
:
Drag
)
{
mWindowDraggingRegion
.
OrWith
(
transformedDevPixelBorderBoxInt
)
;
}
else
{
mWindowNoDraggingRegion
.
OrWith
(
transformedDevPixelBorderBoxInt
)
;
}
}
}
}
LayoutDeviceIntRegion
nsDisplayListBuilder
:
:
GetWindowDraggingRegion
(
)
const
{
LayoutDeviceIntRegion
result
;
result
.
Sub
(
mWindowDraggingRegion
mWindowNoDraggingRegion
)
;
;
return
result
;
}
const
uint32_t
gWillChangeAreaMultiplier
=
3
;
static
uint32_t
GetLayerizationCost
(
const
nsSize
&
aSize
)
{
int
minBudgetCost
=
64
*
64
;
uint32_t
budgetCost
=
std
:
:
max
(
minBudgetCost
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
aSize
.
width
)
*
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
aSize
.
height
)
)
;
return
budgetCost
;
}
bool
nsDisplayListBuilder
:
:
AddToWillChangeBudget
(
nsIFrame
*
aFrame
const
nsSize
&
aSize
)
{
if
(
mWillChangeBudgetSet
.
Contains
(
aFrame
)
)
{
return
true
;
}
nsPresContext
*
key
=
aFrame
-
>
PresContext
(
)
;
if
(
!
mWillChangeBudget
.
Contains
(
key
)
)
{
mWillChangeBudget
.
Put
(
key
DocumentWillChangeBudget
(
)
)
;
}
DocumentWillChangeBudget
budget
;
mWillChangeBudget
.
Get
(
key
&
budget
)
;
nsRect
area
=
aFrame
-
>
PresContext
(
)
-
>
GetVisibleArea
(
)
;
uint32_t
budgetLimit
=
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
area
.
width
)
*
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
area
.
height
)
;
uint32_t
cost
=
GetLayerizationCost
(
aSize
)
;
bool
onBudget
=
(
budget
.
mBudget
+
cost
)
/
gWillChangeAreaMultiplier
<
budgetLimit
;
if
(
onBudget
)
{
budget
.
mBudget
+
=
cost
;
mWillChangeBudget
.
Put
(
key
budget
)
;
mWillChangeBudgetSet
.
PutEntry
(
aFrame
)
;
}
return
onBudget
;
}
bool
nsDisplayListBuilder
:
:
IsInWillChangeBudget
(
nsIFrame
*
aFrame
const
nsSize
&
aSize
)
{
bool
onBudget
=
AddToWillChangeBudget
(
aFrame
aSize
)
;
if
(
!
onBudget
)
{
nsString
usageStr
;
usageStr
.
AppendInt
(
GetLayerizationCost
(
aSize
)
)
;
nsString
multiplierStr
;
multiplierStr
.
AppendInt
(
gWillChangeAreaMultiplier
)
;
nsString
limitStr
;
nsRect
area
=
aFrame
-
>
PresContext
(
)
-
>
GetVisibleArea
(
)
;
uint32_t
budgetLimit
=
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
area
.
width
)
*
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
area
.
height
)
;
limitStr
.
AppendInt
(
budgetLimit
)
;
const
char16_t
*
params
[
]
=
{
multiplierStr
.
get
(
)
limitStr
.
get
(
)
}
;
aFrame
-
>
PresContext
(
)
-
>
Document
(
)
-
>
WarnOnceAbout
(
nsIDocument
:
:
eIgnoringWillChangeOverBudget
false
params
ArrayLength
(
params
)
)
;
}
return
onBudget
;
}
#
ifdef
MOZ_GFX_OPTIMIZE_MOBILE
const
float
gAGRBudgetAreaMultiplier
=
0
.
3
;
#
else
const
float
gAGRBudgetAreaMultiplier
=
3
.
0
;
#
endif
bool
nsDisplayListBuilder
:
:
AddToAGRBudget
(
nsIFrame
*
aFrame
)
{
if
(
mAGRBudgetSet
.
Contains
(
aFrame
)
)
{
return
true
;
}
const
nsPresContext
*
presContext
=
aFrame
-
>
PresContext
(
)
-
>
GetRootPresContext
(
)
;
if
(
!
presContext
)
{
return
false
;
}
const
nsRect
area
=
presContext
-
>
GetVisibleArea
(
)
;
const
uint32_t
budgetLimit
=
gAGRBudgetAreaMultiplier
*
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
area
.
width
)
*
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
area
.
height
)
;
const
uint32_t
cost
=
GetLayerizationCost
(
aFrame
-
>
GetSize
(
)
)
;
const
bool
onBudget
=
mUsedAGRBudget
+
cost
<
budgetLimit
;
if
(
onBudget
)
{
mUsedAGRBudget
+
=
cost
;
mAGRBudgetSet
.
PutEntry
(
aFrame
)
;
}
return
onBudget
;
}
void
nsDisplayListBuilder
:
:
EnterSVGEffectsContents
(
nsDisplayList
*
aHoistedItemsStorage
)
{
MOZ_ASSERT
(
mSVGEffectsBuildingDepth
>
=
0
)
;
MOZ_ASSERT
(
aHoistedItemsStorage
)
;
if
(
mSVGEffectsBuildingDepth
=
=
0
)
{
MOZ_ASSERT
(
!
mScrollInfoItemsForHoisting
)
;
mScrollInfoItemsForHoisting
=
aHoistedItemsStorage
;
}
mSVGEffectsBuildingDepth
+
+
;
}
void
nsDisplayListBuilder
:
:
ExitSVGEffectsContents
(
)
{
mSVGEffectsBuildingDepth
-
-
;
MOZ_ASSERT
(
mSVGEffectsBuildingDepth
>
=
0
)
;
MOZ_ASSERT
(
mScrollInfoItemsForHoisting
)
;
if
(
mSVGEffectsBuildingDepth
=
=
0
)
{
mScrollInfoItemsForHoisting
=
nullptr
;
}
}
void
nsDisplayListBuilder
:
:
AppendNewScrollInfoItemForHoisting
(
nsDisplayScrollInfoLayer
*
aScrollInfoItem
)
{
MOZ_ASSERT
(
ShouldBuildScrollInfoItemsForHoisting
(
)
)
;
MOZ_ASSERT
(
mScrollInfoItemsForHoisting
)
;
mScrollInfoItemsForHoisting
-
>
AppendNewToTop
(
aScrollInfoItem
)
;
}
bool
nsDisplayListBuilder
:
:
IsBuildingLayerEventRegions
(
)
{
if
(
IsPaintingToWindow
(
)
)
{
return
gfxPrefs
:
:
LayoutEventRegionsEnabledDoNotUseDirectly
(
)
|
|
mAsyncPanZoomEnabled
;
}
return
false
;
}
bool
nsDisplayListBuilder
:
:
LayerEventRegionsEnabled
(
)
{
return
gfxPrefs
:
:
LayoutEventRegionsEnabledDoNotUseDirectly
(
)
|
|
gfxPlatform
:
:
AsyncPanZoomEnabled
(
)
;
}
void
nsDisplayListSet
:
:
MoveTo
(
const
nsDisplayListSet
&
aDestination
)
const
{
aDestination
.
BorderBackground
(
)
-
>
AppendToTop
(
BorderBackground
(
)
)
;
aDestination
.
BlockBorderBackgrounds
(
)
-
>
AppendToTop
(
BlockBorderBackgrounds
(
)
)
;
aDestination
.
Floats
(
)
-
>
AppendToTop
(
Floats
(
)
)
;
aDestination
.
Content
(
)
-
>
AppendToTop
(
Content
(
)
)
;
aDestination
.
PositionedDescendants
(
)
-
>
AppendToTop
(
PositionedDescendants
(
)
)
;
aDestination
.
Outlines
(
)
-
>
AppendToTop
(
Outlines
(
)
)
;
}
static
void
MoveListTo
(
nsDisplayList
*
aList
nsTArray
<
nsDisplayItem
*
>
*
aElements
)
{
nsDisplayItem
*
item
;
while
(
(
item
=
aList
-
>
RemoveBottom
(
)
)
!
=
nullptr
)
{
aElements
-
>
AppendElement
(
item
)
;
}
}
nsRect
nsDisplayList
:
:
GetBounds
(
nsDisplayListBuilder
*
aBuilder
)
const
{
nsRect
bounds
;
for
(
nsDisplayItem
*
i
=
GetBottom
(
)
;
i
!
=
nullptr
;
i
=
i
-
>
GetAbove
(
)
)
{
bounds
.
UnionRect
(
bounds
i
-
>
GetClippedBounds
(
aBuilder
)
)
;
}
return
bounds
;
}
nsRect
nsDisplayList
:
:
GetClippedBoundsWithRespectToASR
(
nsDisplayListBuilder
*
aBuilder
const
ActiveScrolledRoot
*
aASR
)
const
{
nsRect
bounds
;
for
(
nsDisplayItem
*
i
=
GetBottom
(
)
;
i
!
=
nullptr
;
i
=
i
-
>
GetAbove
(
)
)
{
nsRect
r
=
i
-
>
GetClippedBounds
(
aBuilder
)
;
if
(
aASR
!
=
i
-
>
GetActiveScrolledRoot
(
)
&
&
!
r
.
IsEmpty
(
)
)
{
const
DisplayItemClip
*
clip
=
DisplayItemClipChain
:
:
ClipForASR
(
i
-
>
GetClipChain
(
)
aASR
)
;
#
ifdef
DEBUG
if
(
!
gfxPrefs
:
:
LayoutUseContainersForRootFrames
(
)
)
{
MOZ_ASSERT
(
clip
"
Need
to
be
clipped
wrt
aASR
.
Do
not
call
this
function
with
an
ASR
that
our
child
items
don
'
t
have
finite
bounds
wrt
.
"
)
;
}
#
endif
if
(
clip
)
{
r
=
clip
-
>
GetClipRect
(
)
;
}
}
bounds
.
UnionRect
(
bounds
r
)
;
}
return
bounds
;
}
nsRect
nsDisplayList
:
:
GetVisibleRect
(
)
const
{
nsRect
result
;
for
(
nsDisplayItem
*
i
=
GetBottom
(
)
;
i
!
=
nullptr
;
i
=
i
-
>
GetAbove
(
)
)
{
result
.
UnionRect
(
result
i
-
>
GetVisibleRect
(
)
)
;
}
return
result
;
}
bool
nsDisplayList
:
:
ComputeVisibilityForRoot
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
{
PROFILER_LABEL
(
"
nsDisplayList
"
"
ComputeVisibilityForRoot
"
js
:
:
ProfileEntry
:
:
Category
:
:
GRAPHICS
)
;
nsRegion
r
;
const
ActiveScrolledRoot
*
rootASR
=
nullptr
;
if
(
gfxPrefs
:
:
LayoutUseContainersForRootFrames
(
)
)
{
rootASR
=
aBuilder
-
>
ActiveScrolledRootForRootScrollframe
(
)
;
}
r
.
And
(
*
aVisibleRegion
GetClippedBoundsWithRespectToASR
(
aBuilder
rootASR
)
)
;
return
ComputeVisibilityForSublist
(
aBuilder
aVisibleRegion
r
.
GetBounds
(
)
)
;
}
static
nsRegion
TreatAsOpaque
(
nsDisplayItem
*
aItem
nsDisplayListBuilder
*
aBuilder
)
{
bool
snap
;
nsRegion
opaque
=
aItem
-
>
GetOpaqueRegion
(
aBuilder
&
snap
)
;
if
(
aBuilder
-
>
IsForPluginGeometry
(
)
&
&
aItem
-
>
GetType
(
)
!
=
nsDisplayItem
:
:
TYPE_LAYER_EVENT_REGIONS
)
{
nsIFrame
*
f
=
aItem
-
>
Frame
(
)
;
if
(
f
-
>
PresContext
(
)
-
>
IsChrome
(
)
&
&
!
aItem
-
>
GetChildren
(
)
&
&
f
-
>
StyleEffects
(
)
-
>
mOpacity
!
=
0
.
0
)
{
opaque
=
aItem
-
>
GetBounds
(
aBuilder
&
snap
)
;
}
}
if
(
opaque
.
IsEmpty
(
)
)
{
return
opaque
;
}
nsRegion
opaqueClipped
;
for
(
auto
iter
=
opaque
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
opaqueClipped
.
Or
(
opaqueClipped
aItem
-
>
GetClip
(
)
.
ApproximateIntersectInward
(
iter
.
Get
(
)
)
)
;
}
return
opaqueClipped
;
}
bool
nsDisplayList
:
:
ComputeVisibilityForSublist
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
const
nsRect
&
aListVisibleBounds
)
{
#
ifdef
DEBUG
nsRegion
r
;
r
.
And
(
*
aVisibleRegion
GetBounds
(
aBuilder
)
)
;
NS_ASSERTION
(
r
.
GetBounds
(
)
.
IsEqualInterior
(
aListVisibleBounds
)
"
bad
aListVisibleBounds
"
)
;
#
endif
bool
anyVisible
=
false
;
AutoTArray
<
nsDisplayItem
*
512
>
elements
;
MoveListTo
(
this
&
elements
)
;
for
(
int32_t
i
=
elements
.
Length
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
nsDisplayItem
*
item
=
elements
[
i
]
;
if
(
item
-
>
mForceNotVisible
&
&
!
item
-
>
GetSameCoordinateSystemChildren
(
)
)
{
NS_ASSERTION
(
item
-
>
mVisibleRect
.
IsEmpty
(
)
"
invisible
items
should
have
empty
vis
rect
"
)
;
}
else
{
nsRect
bounds
=
item
-
>
GetClippedBounds
(
aBuilder
)
;
nsRegion
itemVisible
;
itemVisible
.
And
(
*
aVisibleRegion
bounds
)
;
item
-
>
mVisibleRect
=
itemVisible
.
GetBounds
(
)
;
}
if
(
item
-
>
ComputeVisibility
(
aBuilder
aVisibleRegion
)
)
{
anyVisible
=
true
;
nsRegion
opaque
=
TreatAsOpaque
(
item
aBuilder
)
;
aBuilder
-
>
SubtractFromVisibleRegion
(
aVisibleRegion
opaque
)
;
}
AppendToBottom
(
item
)
;
}
mIsOpaque
=
!
aVisibleRegion
-
>
Intersects
(
aListVisibleBounds
)
;
return
anyVisible
;
}
static
bool
TriggerPendingAnimationsOnSubDocuments
(
nsIDocument
*
aDocument
void
*
aReadyTime
)
{
PendingAnimationTracker
*
tracker
=
aDocument
-
>
GetPendingAnimationTracker
(
)
;
if
(
tracker
)
{
nsIPresShell
*
shell
=
aDocument
-
>
GetShell
(
)
;
if
(
!
shell
|
|
!
shell
-
>
IsPaintingSuppressed
(
)
)
{
const
TimeStamp
&
readyTime
=
*
static_cast
<
TimeStamp
*
>
(
aReadyTime
)
;
tracker
-
>
TriggerPendingAnimationsOnNextTick
(
readyTime
)
;
}
}
aDocument
-
>
EnumerateSubDocuments
(
TriggerPendingAnimationsOnSubDocuments
aReadyTime
)
;
return
true
;
}
static
void
TriggerPendingAnimations
(
nsIDocument
*
aDocument
const
TimeStamp
&
aReadyTime
)
{
MOZ_ASSERT
(
!
aReadyTime
.
IsNull
(
)
"
Animation
ready
time
is
not
set
.
Perhaps
we
'
re
using
a
layer
"
"
manager
that
doesn
'
t
update
it
"
)
;
TriggerPendingAnimationsOnSubDocuments
(
aDocument
const_cast
<
TimeStamp
*
>
(
&
aReadyTime
)
)
;
}
LayerManager
*
nsDisplayListBuilder
:
:
GetWidgetLayerManager
(
nsView
*
*
aView
)
{
nsView
*
view
=
RootReferenceFrame
(
)
-
>
GetView
(
)
;
if
(
aView
)
{
*
aView
=
view
;
}
if
(
RootReferenceFrame
(
)
!
=
nsLayoutUtils
:
:
GetDisplayRootFrame
(
RootReferenceFrame
(
)
)
)
{
return
nullptr
;
}
nsIWidget
*
window
=
RootReferenceFrame
(
)
-
>
GetNearestWidget
(
)
;
if
(
window
)
{
return
window
-
>
GetLayerManager
(
)
;
}
return
nullptr
;
}
already_AddRefed
<
LayerManager
>
nsDisplayList
:
:
PaintRoot
(
nsDisplayListBuilder
*
aBuilder
nsRenderingContext
*
aCtx
uint32_t
aFlags
)
{
PROFILER_LABEL
(
"
nsDisplayList
"
"
PaintRoot
"
js
:
:
ProfileEntry
:
:
Category
:
:
GRAPHICS
)
;
RefPtr
<
LayerManager
>
layerManager
;
bool
widgetTransaction
=
false
;
bool
doBeginTransaction
=
true
;
nsView
*
view
=
nullptr
;
if
(
aFlags
&
PAINT_USE_WIDGET_LAYERS
)
{
layerManager
=
aBuilder
-
>
GetWidgetLayerManager
(
&
view
)
;
if
(
layerManager
)
{
doBeginTransaction
=
!
(
aFlags
&
PAINT_EXISTING_TRANSACTION
)
;
widgetTransaction
=
true
;
}
}
if
(
!
layerManager
)
{
if
(
!
aCtx
)
{
NS_WARNING
(
"
Nowhere
to
paint
into
"
)
;
return
nullptr
;
}
layerManager
=
new
BasicLayerManager
(
BasicLayerManager
:
:
BLM_OFFSCREEN
)
;
}
nsIFrame
*
frame
=
aBuilder
-
>
RootReferenceFrame
(
)
;
nsPresContext
*
presContext
=
frame
-
>
PresContext
(
)
;
nsIPresShell
*
presShell
=
presContext
-
>
PresShell
(
)
;
nsIDocument
*
document
=
presShell
-
>
GetDocument
(
)
;
NotifySubDocInvalidationFunc
computeInvalidFunc
=
presContext
-
>
MayHavePaintEventListenerInSubDocument
(
)
?
nsPresContext
:
:
NotifySubDocInvalidation
:
0
;
UniquePtr
<
LayerProperties
>
props
;
RefPtr
<
ContainerLayer
>
root
;
FrameLayerBuilder
*
oldBuilder
=
layerManager
-
>
GetLayerBuilder
(
)
;
FrameLayerBuilder
*
layerBuilder
=
new
FrameLayerBuilder
(
)
;
layerBuilder
-
>
Init
(
aBuilder
layerManager
)
;
if
(
aFlags
&
PAINT_COMPRESSED
)
{
layerBuilder
-
>
SetLayerTreeCompressionMode
(
)
;
}
{
GeckoProfilerTracingRAII
tracer
(
"
Paint
"
"
LayerBuilding
"
)
;
if
(
doBeginTransaction
)
{
if
(
aCtx
)
{
if
(
!
layerManager
-
>
BeginTransactionWithTarget
(
aCtx
-
>
ThebesContext
(
)
)
)
{
return
nullptr
;
}
}
else
{
if
(
!
layerManager
-
>
BeginTransaction
(
)
)
{
return
nullptr
;
}
}
}
if
(
XRE_IsContentProcess
(
)
&
&
gfxPrefs
:
:
AlwaysPaint
(
)
)
{
FrameLayerBuilder
:
:
InvalidateAllLayers
(
layerManager
)
;
}
if
(
widgetTransaction
)
{
layerBuilder
-
>
DidBeginRetainedLayerTransaction
(
layerManager
)
;
}
bool
computeInvalidRect
=
(
computeInvalidFunc
|
|
(
!
layerManager
-
>
IsCompositingCheap
(
)
&
&
layerManager
-
>
NeedsWidgetInvalidation
(
)
)
)
&
&
widgetTransaction
;
if
(
computeInvalidRect
)
{
props
=
Move
(
LayerProperties
:
:
CloneFrom
(
layerManager
-
>
GetRoot
(
)
)
)
;
}
if
(
Layer
*
rootLayer
=
layerManager
-
>
GetRoot
(
)
)
{
rootLayer
-
>
SetScrollMetadata
(
nsTArray
<
ScrollMetadata
>
(
)
)
;
}
ContainerLayerParameters
containerParameters
(
presShell
-
>
GetResolution
(
)
presShell
-
>
GetResolution
(
)
)
;
{
PaintTelemetry
:
:
AutoRecord
record
(
PaintTelemetry
:
:
Metric
:
:
Layerization
)
;
root
=
layerBuilder
-
>
BuildContainerLayerFor
(
aBuilder
layerManager
frame
nullptr
this
containerParameters
nullptr
)
;
}
if
(
!
root
)
{
layerManager
-
>
SetUserData
(
&
gLayerManagerLayerBuilder
oldBuilder
)
;
return
nullptr
;
}
root
-
>
SetPostScale
(
1
.
0f
/
containerParameters
.
mXScale
1
.
0f
/
containerParameters
.
mYScale
)
;
root
-
>
SetScaleToResolution
(
presShell
-
>
ScaleToResolution
(
)
containerParameters
.
mXScale
)
;
if
(
aBuilder
-
>
IsBuildingLayerEventRegions
(
)
&
&
nsLayoutUtils
:
:
HasDocumentLevelListenersForApzAwareEvents
(
presShell
)
)
{
root
-
>
SetEventRegionsOverride
(
EventRegionsOverride
:
:
ForceDispatchToContent
)
;
}
else
{
root
-
>
SetEventRegionsOverride
(
EventRegionsOverride
:
:
NoOverride
)
;
}
bool
addMetrics
=
gfxPrefs
:
:
LayoutUseContainersForRootFrames
(
)
|
|
(
XRE_IsParentProcess
(
)
&
&
!
presShell
-
>
GetRootScrollFrame
(
)
)
;
bool
ensureMetricsForRootId
=
nsLayoutUtils
:
:
AsyncPanZoomEnabled
(
frame
)
&
&
!
gfxPrefs
:
:
LayoutUseContainersForRootFrames
(
)
&
&
aBuilder
-
>
IsPaintingToWindow
(
)
&
&
!
presContext
-
>
GetParentPresContext
(
)
;
nsIContent
*
content
=
nullptr
;
nsIFrame
*
rootScrollFrame
=
presShell
-
>
GetRootScrollFrame
(
)
;
if
(
rootScrollFrame
)
{
content
=
rootScrollFrame
-
>
GetContent
(
)
;
}
else
{
content
=
document
-
>
GetDocumentElement
(
)
;
}
if
(
ensureMetricsForRootId
&
&
content
)
{
ViewID
scrollId
=
nsLayoutUtils
:
:
FindOrCreateIDFor
(
content
)
;
if
(
nsLayoutUtils
:
:
ContainsMetricsWithId
(
root
scrollId
)
)
{
ensureMetricsForRootId
=
false
;
}
}
if
(
addMetrics
|
|
ensureMetricsForRootId
)
{
bool
isRootContent
=
presContext
-
>
IsRootContentDocument
(
)
;
nsRect
viewport
(
aBuilder
-
>
ToReferenceFrame
(
frame
)
frame
-
>
GetSize
(
)
)
;
root
-
>
SetScrollMetadata
(
nsLayoutUtils
:
:
ComputeScrollMetadata
(
frame
rootScrollFrame
content
aBuilder
-
>
FindReferenceFrameFor
(
frame
)
root
FrameMetrics
:
:
NULL_SCROLL_ID
viewport
Nothing
(
)
isRootContent
containerParameters
)
)
;
}
#
ifdef
DEBUG
bool
usingDisplayport
=
false
;
if
(
nsIFrame
*
rootScrollFrame
=
presShell
-
>
GetRootScrollFrame
(
)
)
{
nsIContent
*
content
=
rootScrollFrame
-
>
GetContent
(
)
;
if
(
content
)
{
usingDisplayport
=
nsLayoutUtils
:
:
HasDisplayPort
(
content
)
;
}
}
if
(
usingDisplayport
&
&
!
(
root
-
>
GetContentFlags
(
)
&
Layer
:
:
CONTENT_OPAQUE
)
&
&
SpammyLayoutWarningsEnabled
(
)
)
{
NS_WARNING
(
"
Transparent
content
with
displayports
can
be
expensive
.
"
)
;
}
#
endif
layerManager
-
>
SetRoot
(
root
)
;
layerBuilder
-
>
WillEndTransaction
(
)
;
}
if
(
widgetTransaction
|
|
(
document
&
&
document
-
>
IsBeingUsedAsImage
(
)
)
)
{
frame
-
>
ClearInvalidationStateBits
(
)
;
}
bool
temp
=
aBuilder
-
>
SetIsCompositingCheap
(
layerManager
-
>
IsCompositingCheap
(
)
)
;
LayerManager
:
:
EndTransactionFlags
flags
=
LayerManager
:
:
END_DEFAULT
;
if
(
layerManager
-
>
NeedsWidgetInvalidation
(
)
)
{
if
(
aFlags
&
PAINT_NO_COMPOSITE
)
{
flags
=
LayerManager
:
:
END_NO_COMPOSITE
;
}
}
else
{
if
(
aBuilder
-
>
WillComputePluginGeometry
(
)
)
{
flags
=
LayerManager
:
:
END_NO_REMOTE_COMPOSITE
;
}
}
nsRootPresContext
*
rootPresContext
=
presContext
-
>
GetRootPresContext
(
)
;
if
(
rootPresContext
&
&
XRE_IsContentProcess
(
)
)
{
if
(
aBuilder
-
>
WillComputePluginGeometry
(
)
)
{
rootPresContext
-
>
ComputePluginGeometryUpdates
(
aBuilder
-
>
RootReferenceFrame
(
)
aBuilder
this
)
;
}
rootPresContext
-
>
CollectPluginGeometryUpdates
(
layerManager
)
;
}
MaybeSetupTransactionIdAllocator
(
layerManager
view
)
;
layerManager
-
>
EndTransaction
(
FrameLayerBuilder
:
:
DrawPaintedLayer
aBuilder
flags
)
;
aBuilder
-
>
SetIsCompositingCheap
(
temp
)
;
layerBuilder
-
>
DidEndTransaction
(
)
;
if
(
document
&
&
widgetTransaction
)
{
TriggerPendingAnimations
(
document
layerManager
-
>
GetAnimationReadyTime
(
)
)
;
}
nsIntRegion
invalid
;
if
(
props
)
{
invalid
=
props
-
>
ComputeDifferences
(
root
computeInvalidFunc
)
;
}
else
if
(
widgetTransaction
)
{
LayerProperties
:
:
ClearInvalidations
(
root
)
;
}
bool
shouldInvalidate
=
layerManager
-
>
NeedsWidgetInvalidation
(
)
;
if
(
view
)
{
if
(
props
)
{
if
(
!
invalid
.
IsEmpty
(
)
)
{
nsIntRect
bounds
=
invalid
.
GetBounds
(
)
;
nsRect
rect
(
presContext
-
>
DevPixelsToAppUnits
(
bounds
.
x
)
presContext
-
>
DevPixelsToAppUnits
(
bounds
.
y
)
presContext
-
>
DevPixelsToAppUnits
(
bounds
.
width
)
presContext
-
>
DevPixelsToAppUnits
(
bounds
.
height
)
)
;
if
(
shouldInvalidate
)
{
view
-
>
GetViewManager
(
)
-
>
InvalidateViewNoSuppression
(
view
rect
)
;
}
presContext
-
>
NotifyInvalidation
(
layerManager
-
>
GetLastTransactionId
(
)
bounds
)
;
}
}
else
if
(
shouldInvalidate
)
{
view
-
>
GetViewManager
(
)
-
>
InvalidateView
(
view
)
;
}
}
layerManager
-
>
SetUserData
(
&
gLayerManagerLayerBuilder
oldBuilder
)
;
return
layerManager
.
forget
(
)
;
}
uint32_t
nsDisplayList
:
:
Count
(
)
const
{
uint32_t
count
=
0
;
for
(
nsDisplayItem
*
i
=
GetBottom
(
)
;
i
;
i
=
i
-
>
GetAbove
(
)
)
{
+
+
count
;
}
return
count
;
}
nsDisplayItem
*
nsDisplayList
:
:
RemoveBottom
(
)
{
nsDisplayItem
*
item
=
mSentinel
.
mAbove
;
if
(
!
item
)
return
nullptr
;
mSentinel
.
mAbove
=
item
-
>
mAbove
;
if
(
item
=
=
mTop
)
{
mTop
=
&
mSentinel
;
}
item
-
>
mAbove
=
nullptr
;
return
item
;
}
void
nsDisplayList
:
:
DeleteAll
(
)
{
nsDisplayItem
*
item
;
while
(
(
item
=
RemoveBottom
(
)
)
!
=
nullptr
)
{
item
-
>
~
nsDisplayItem
(
)
;
}
}
static
bool
GetMouseThrough
(
const
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
-
>
IsXULBoxFrame
(
)
)
return
false
;
const
nsIFrame
*
frame
=
aFrame
;
while
(
frame
)
{
if
(
frame
-
>
GetStateBits
(
)
&
NS_FRAME_MOUSE_THROUGH_ALWAYS
)
{
return
true
;
}
else
if
(
frame
-
>
GetStateBits
(
)
&
NS_FRAME_MOUSE_THROUGH_NEVER
)
{
return
false
;
}
frame
=
nsBox
:
:
GetParentXULBox
(
frame
)
;
}
return
false
;
}
static
bool
IsFrameReceivingPointerEvents
(
nsIFrame
*
aFrame
)
{
return
NS_STYLE_POINTER_EVENTS_NONE
!
=
aFrame
-
>
StyleUserInterface
(
)
-
>
GetEffectivePointerEvents
(
aFrame
)
;
}
struct
FramesWithDepth
{
explicit
FramesWithDepth
(
float
aDepth
)
:
mDepth
(
aDepth
)
{
}
bool
operator
<
(
const
FramesWithDepth
&
aOther
)
const
{
if
(
!
FuzzyEqual
(
mDepth
aOther
.
mDepth
0
.
1f
)
)
{
return
mDepth
>
aOther
.
mDepth
;
}
return
this
<
&
aOther
;
}
bool
operator
=
=
(
const
FramesWithDepth
&
aOther
)
const
{
return
this
=
=
&
aOther
;
}
float
mDepth
;
nsTArray
<
nsIFrame
*
>
mFrames
;
}
;
void
FlushFramesArray
(
nsTArray
<
FramesWithDepth
>
&
aSource
nsTArray
<
nsIFrame
*
>
*
aDest
)
{
if
(
aSource
.
IsEmpty
(
)
)
{
return
;
}
aSource
.
Sort
(
)
;
uint32_t
length
=
aSource
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
length
;
i
+
+
)
{
aDest
-
>
AppendElements
(
Move
(
aSource
[
i
]
.
mFrames
)
)
;
}
aSource
.
Clear
(
)
;
}
void
nsDisplayList
:
:
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
nsDisplayItem
:
:
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
const
{
nsDisplayItem
*
item
;
if
(
aState
-
>
mInPreserves3D
)
{
for
(
item
=
GetBottom
(
)
;
item
;
item
=
item
-
>
GetAbove
(
)
)
{
auto
itemType
=
item
-
>
GetType
(
)
;
if
(
itemType
!
=
nsDisplayItem
:
:
TYPE_TRANSFORM
|
|
!
static_cast
<
nsDisplayTransform
*
>
(
item
)
-
>
IsLeafOf3DContext
(
)
)
{
item
-
>
HitTest
(
aBuilder
aRect
aState
aOutFrames
)
;
}
else
{
aState
-
>
mItemBuffer
.
AppendElement
(
item
)
;
}
}
return
;
}
int32_t
itemBufferStart
=
aState
-
>
mItemBuffer
.
Length
(
)
;
for
(
item
=
GetBottom
(
)
;
item
;
item
=
item
-
>
GetAbove
(
)
)
{
aState
-
>
mItemBuffer
.
AppendElement
(
item
)
;
}
AutoTArray
<
FramesWithDepth
16
>
temp
;
for
(
int32_t
i
=
aState
-
>
mItemBuffer
.
Length
(
)
-
1
;
i
>
=
itemBufferStart
;
-
-
i
)
{
item
=
aState
-
>
mItemBuffer
[
i
]
;
aState
-
>
mItemBuffer
.
SetLength
(
i
)
;
bool
snap
;
nsRect
r
=
item
-
>
GetBounds
(
aBuilder
&
snap
)
.
Intersect
(
aRect
)
;
auto
itemType
=
item
-
>
GetType
(
)
;
bool
same3DContext
=
(
itemType
=
=
nsDisplayItem
:
:
TYPE_TRANSFORM
&
&
static_cast
<
nsDisplayTransform
*
>
(
item
)
-
>
IsParticipating3DContext
(
)
)
|
|
(
itemType
=
=
nsDisplayItem
:
:
TYPE_PERSPECTIVE
&
&
item
-
>
Frame
(
)
-
>
Extend3DContext
(
)
)
;
if
(
same3DContext
&
&
(
itemType
!
=
nsDisplayItem
:
:
TYPE_TRANSFORM
|
|
!
static_cast
<
nsDisplayTransform
*
>
(
item
)
-
>
IsLeafOf3DContext
(
)
)
)
{
if
(
!
item
-
>
GetClip
(
)
.
MayIntersect
(
aRect
)
)
{
continue
;
}
AutoTArray
<
nsIFrame
*
1
>
neverUsed
;
aState
-
>
mInPreserves3D
=
true
;
item
-
>
HitTest
(
aBuilder
aRect
aState
&
neverUsed
)
;
aState
-
>
mInPreserves3D
=
false
;
i
=
aState
-
>
mItemBuffer
.
Length
(
)
;
continue
;
}
if
(
same3DContext
|
|
item
-
>
GetClip
(
)
.
MayIntersect
(
r
)
)
{
AutoTArray
<
nsIFrame
*
16
>
outFrames
;
item
-
>
HitTest
(
aBuilder
aRect
aState
&
outFrames
)
;
nsTArray
<
nsIFrame
*
>
*
writeFrames
=
aOutFrames
;
if
(
item
-
>
GetType
(
)
=
=
nsDisplayItem
:
:
TYPE_TRANSFORM
&
&
static_cast
<
nsDisplayTransform
*
>
(
item
)
-
>
IsLeafOf3DContext
(
)
)
{
if
(
outFrames
.
Length
(
)
)
{
nsDisplayTransform
*
transform
=
static_cast
<
nsDisplayTransform
*
>
(
item
)
;
nsPoint
point
=
aRect
.
TopLeft
(
)
;
if
(
aRect
.
width
!
=
1
|
|
aRect
.
height
!
=
1
)
{
point
=
aRect
.
Center
(
)
;
}
temp
.
AppendElement
(
FramesWithDepth
(
transform
-
>
GetHitDepthAtPoint
(
aBuilder
point
)
)
)
;
writeFrames
=
&
temp
[
temp
.
Length
(
)
-
1
]
.
mFrames
;
}
}
else
{
FlushFramesArray
(
temp
aOutFrames
)
;
}
for
(
uint32_t
j
=
0
;
j
<
outFrames
.
Length
(
)
;
j
+
+
)
{
nsIFrame
*
f
=
outFrames
.
ElementAt
(
j
)
;
if
(
!
GetMouseThrough
(
f
)
&
&
IsFrameReceivingPointerEvents
(
f
)
)
{
writeFrames
-
>
AppendElement
(
f
)
;
}
}
if
(
aBuilder
-
>
HitTestShouldStopAtFirstOpaque
(
)
&
&
item
-
>
GetOpaqueRegion
(
aBuilder
&
snap
)
.
Contains
(
aRect
)
)
{
aState
-
>
mItemBuffer
.
SetLength
(
itemBufferStart
)
;
break
;
}
}
}
FlushFramesArray
(
temp
aOutFrames
)
;
NS_ASSERTION
(
aState
-
>
mItemBuffer
.
Length
(
)
=
=
uint32_t
(
itemBufferStart
)
"
How
did
we
forget
to
pop
some
elements
?
"
)
;
}
static
void
Sort
(
nsDisplayList
*
aList
int32_t
aCount
nsDisplayList
:
:
SortLEQ
aCmp
void
*
aClosure
)
{
if
(
aCount
<
2
)
return
;
nsDisplayList
list1
;
nsDisplayList
list2
;
int
i
;
int32_t
half
=
aCount
/
2
;
bool
sorted
=
true
;
nsDisplayItem
*
prev
=
nullptr
;
for
(
i
=
0
;
i
<
aCount
;
+
+
i
)
{
nsDisplayItem
*
item
=
aList
-
>
RemoveBottom
(
)
;
(
i
<
half
?
&
list1
:
&
list2
)
-
>
AppendToTop
(
item
)
;
if
(
sorted
&
&
prev
&
&
!
aCmp
(
prev
item
aClosure
)
)
{
sorted
=
false
;
}
prev
=
item
;
}
if
(
sorted
)
{
aList
-
>
AppendToTop
(
&
list1
)
;
aList
-
>
AppendToTop
(
&
list2
)
;
return
;
}
Sort
(
&
list1
half
aCmp
aClosure
)
;
Sort
(
&
list2
aCount
-
half
aCmp
aClosure
)
;
for
(
i
=
0
;
i
<
aCount
;
+
+
i
)
{
if
(
list1
.
GetBottom
(
)
&
&
(
!
list2
.
GetBottom
(
)
|
|
aCmp
(
list1
.
GetBottom
(
)
list2
.
GetBottom
(
)
aClosure
)
)
)
{
aList
-
>
AppendToTop
(
list1
.
RemoveBottom
(
)
)
;
}
else
{
aList
-
>
AppendToTop
(
list2
.
RemoveBottom
(
)
)
;
}
}
}
static
nsIContent
*
FindContentInDocument
(
nsDisplayItem
*
aItem
nsIDocument
*
aDoc
)
{
nsIFrame
*
f
=
aItem
-
>
Frame
(
)
;
while
(
f
)
{
nsPresContext
*
pc
=
f
-
>
PresContext
(
)
;
if
(
pc
-
>
Document
(
)
=
=
aDoc
)
{
return
f
-
>
GetContent
(
)
;
}
f
=
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
pc
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
)
;
}
return
nullptr
;
}
static
bool
IsContentLEQ
(
nsDisplayItem
*
aItem1
nsDisplayItem
*
aItem2
void
*
aClosure
)
{
nsIContent
*
commonAncestor
=
static_cast
<
nsIContent
*
>
(
aClosure
)
;
nsIDocument
*
commonAncestorDoc
=
commonAncestor
-
>
OwnerDoc
(
)
;
nsIContent
*
content1
=
FindContentInDocument
(
aItem1
commonAncestorDoc
)
;
nsIContent
*
content2
=
FindContentInDocument
(
aItem2
commonAncestorDoc
)
;
if
(
!
content1
|
|
!
content2
)
{
NS_ERROR
(
"
Document
trees
are
mixed
up
!
"
)
;
return
true
;
}
return
nsLayoutUtils
:
:
CompareTreePosition
(
content1
content2
commonAncestor
)
<
=
0
;
}
static
bool
IsZOrderLEQ
(
nsDisplayItem
*
aItem1
nsDisplayItem
*
aItem2
void
*
aClosure
)
{
return
aItem1
-
>
ZIndex
(
)
<
=
aItem2
-
>
ZIndex
(
)
;
}
void
nsDisplayList
:
:
SortByZOrder
(
)
{
Sort
(
IsZOrderLEQ
nullptr
)
;
}
void
nsDisplayList
:
:
SortByContentOrder
(
nsIContent
*
aCommonAncestor
)
{
Sort
(
IsContentLEQ
aCommonAncestor
)
;
}
void
nsDisplayList
:
:
Sort
(
SortLEQ
aCmp
void
*
aClosure
)
{
:
:
Sort
(
this
Count
(
)
aCmp
aClosure
)
;
}
nsDisplayItem
:
:
nsDisplayItem
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
:
nsDisplayItem
(
aBuilder
aFrame
aBuilder
-
>
CurrentActiveScrolledRoot
(
)
)
{
}
nsDisplayItem
:
:
nsDisplayItem
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
ActiveScrolledRoot
*
aActiveScrolledRoot
)
:
mFrame
(
aFrame
)
mClipChain
(
aBuilder
-
>
ClipState
(
)
.
GetCurrentCombinedClipChain
(
aBuilder
)
)
mClip
(
DisplayItemClipChain
:
:
ClipForASR
(
mClipChain
aActiveScrolledRoot
)
)
mActiveScrolledRoot
(
aActiveScrolledRoot
)
mAnimatedGeometryRoot
(
nullptr
)
mForceNotVisible
(
aBuilder
-
>
IsBuildingInvisibleItems
(
)
)
#
ifdef
MOZ_DUMP_PAINTING
mPainted
(
false
)
#
endif
{
mReferenceFrame
=
aBuilder
-
>
FindReferenceFrameFor
(
aFrame
&
mToReferenceFrame
)
;
mAnimatedGeometryRoot
=
aBuilder
-
>
FindAnimatedGeometryRootFor
(
aFrame
)
;
MOZ_ASSERT
(
nsLayoutUtils
:
:
IsAncestorFrameCrossDoc
(
aBuilder
-
>
RootReferenceFrame
(
)
*
mAnimatedGeometryRoot
)
"
Bad
"
)
;
NS_ASSERTION
(
aBuilder
-
>
GetDirtyRect
(
)
.
width
>
=
0
|
|
!
aBuilder
-
>
IsForPainting
(
)
"
dirty
rect
not
set
"
)
;
mVisibleRect
=
aBuilder
-
>
GetDirtyRect
(
)
+
aBuilder
-
>
GetCurrentFrameOffsetToReferenceFrame
(
)
;
}
bool
nsDisplayItem
:
:
ForceActiveLayers
(
)
{
static
bool
sForce
=
false
;
static
bool
sForceCached
=
false
;
if
(
!
sForceCached
)
{
Preferences
:
:
AddBoolVarCache
(
&
sForce
"
layers
.
force
-
active
"
false
)
;
sForceCached
=
true
;
}
return
sForce
;
}
static
int32_t
ZIndexForFrame
(
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
-
>
IsAbsPosContainingBlock
(
)
&
&
!
aFrame
-
>
IsFlexOrGridItem
(
)
)
return
0
;
const
nsStylePosition
*
position
=
aFrame
-
>
StylePosition
(
)
;
if
(
position
-
>
mZIndex
.
GetUnit
(
)
=
=
eStyleUnit_Integer
)
return
position
-
>
mZIndex
.
GetIntValue
(
)
;
return
0
;
}
int32_t
nsDisplayItem
:
:
ZIndex
(
)
const
{
return
ZIndexForFrame
(
mFrame
)
;
}
bool
nsDisplayItem
:
:
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
{
return
!
mVisibleRect
.
IsEmpty
(
)
&
&
!
IsInvisibleInRect
(
aVisibleRegion
-
>
GetBounds
(
)
)
;
}
bool
nsDisplayItem
:
:
RecomputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
{
if
(
mForceNotVisible
&
&
!
GetSameCoordinateSystemChildren
(
)
)
{
NS_ASSERTION
(
mVisibleRect
.
IsEmpty
(
)
"
invisible
items
without
children
should
have
empty
vis
rect
"
)
;
}
else
{
nsRect
bounds
=
GetClippedBounds
(
aBuilder
)
;
nsRegion
itemVisible
;
itemVisible
.
And
(
*
aVisibleRegion
bounds
)
;
mVisibleRect
=
itemVisible
.
GetBounds
(
)
;
}
if
(
!
ComputeVisibility
(
aBuilder
aVisibleRegion
)
)
{
mVisibleRect
=
nsRect
(
)
;
return
false
;
}
nsRegion
opaque
=
TreatAsOpaque
(
this
aBuilder
)
;
aBuilder
-
>
SubtractFromVisibleRegion
(
aVisibleRegion
opaque
)
;
return
true
;
}
void
nsDisplayItem
:
:
SetClipChain
(
const
DisplayItemClipChain
*
aClipChain
)
{
mClipChain
=
aClipChain
;
mClip
=
DisplayItemClipChain
:
:
ClipForASR
(
aClipChain
mActiveScrolledRoot
)
;
}
void
nsDisplayItem
:
:
FuseClipChainUpTo
(
nsDisplayListBuilder
*
aBuilder
const
ActiveScrolledRoot
*
aASR
)
{
const
DisplayItemClipChain
*
sc
=
mClipChain
;
DisplayItemClip
mergedClip
;
while
(
sc
&
&
ActiveScrolledRoot
:
:
PickDescendant
(
aASR
sc
-
>
mASR
)
=
=
sc
-
>
mASR
)
{
mergedClip
.
IntersectWith
(
sc
-
>
mClip
)
;
sc
=
sc
-
>
mParent
;
}
if
(
mergedClip
.
HasClip
(
)
)
{
mClipChain
=
aBuilder
-
>
AllocateDisplayItemClipChain
(
mergedClip
aASR
sc
)
;
mClip
=
&
mClipChain
-
>
mClip
;
}
else
{
mClipChain
=
nullptr
;
mClip
=
nullptr
;
}
}
static
const
DisplayItemClipChain
*
FindCommonAncestorClipForIntersection
(
const
DisplayItemClipChain
*
aOne
const
DisplayItemClipChain
*
aTwo
)
{
for
(
const
ActiveScrolledRoot
*
asr
=
ActiveScrolledRoot
:
:
PickDescendant
(
aOne
-
>
mASR
aTwo
-
>
mASR
)
;
asr
;
asr
=
asr
-
>
mParent
)
{
if
(
aOne
=
=
aTwo
)
{
return
aOne
;
}
if
(
aOne
-
>
mASR
=
=
asr
)
{
aOne
=
aOne
-
>
mParent
;
}
if
(
aTwo
-
>
mASR
=
=
asr
)
{
aTwo
=
aTwo
-
>
mParent
;
}
if
(
!
aOne
)
{
return
aTwo
;
}
if
(
!
aTwo
)
{
return
aOne
;
}
}
return
nullptr
;
}
void
nsDisplayItem
:
:
IntersectClip
(
nsDisplayListBuilder
*
aBuilder
const
DisplayItemClipChain
*
aOther
)
{
if
(
!
aOther
)
{
return
;
}
const
DisplayItemClipChain
*
ancestorClip
=
mClipChain
?
FindCommonAncestorClipForIntersection
(
mClipChain
aOther
)
:
nullptr
;
SetClipChain
(
aBuilder
-
>
CreateClipChainIntersection
(
ancestorClip
mClipChain
aOther
)
)
;
}
nsRect
nsDisplayItem
:
:
GetClippedBounds
(
nsDisplayListBuilder
*
aBuilder
)
{
bool
snap
;
nsRect
r
=
GetBounds
(
aBuilder
&
snap
)
;
return
GetClip
(
)
.
ApplyNonRoundedIntersection
(
r
)
;
}
already_AddRefed
<
Layer
>
nsDisplayItem
:
:
BuildDisplayItemLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
{
RefPtr
<
DisplayItemLayer
>
layer
=
static_cast
<
DisplayItemLayer
*
>
(
aManager
-
>
GetLayerBuilder
(
)
-
>
GetLeafLayerFor
(
aBuilder
this
)
)
;
if
(
!
layer
)
{
layer
=
aManager
-
>
CreateDisplayItemLayer
(
)
;
if
(
!
layer
)
{
return
nullptr
;
}
}
layer
-
>
SetDisplayItem
(
this
aBuilder
)
;
layer
-
>
SetBaseTransform
(
gfx
:
:
Matrix4x4
:
:
Translation
(
aContainerParameters
.
mOffset
.
x
aContainerParameters
.
mOffset
.
y
0
)
)
;
return
layer
.
forget
(
)
;
}
nsRect
nsDisplaySolidColor
:
:
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
{
*
aSnap
=
true
;
return
mBounds
;
}
void
nsDisplaySolidColor
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
nsRenderingContext
*
aCtx
)
{
int32_t
appUnitsPerDevPixel
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
DrawTarget
*
drawTarget
=
aCtx
-
>
GetDrawTarget
(
)
;
Rect
rect
=
NSRectToSnappedRect
(
mVisibleRect
appUnitsPerDevPixel
*
drawTarget
)
;
drawTarget
-
>
FillRect
(
rect
ColorPattern
(
ToDeviceColor
(
mColor
)
)
)
;
}
void
nsDisplaySolidColor
:
:
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
{
aStream
<
<
"
(
rgba
"
<
<
(
int
)
NS_GET_R
(
mColor
)
<
<
"
"
<
<
(
int
)
NS_GET_G
(
mColor
)
<
<
"
"
<
<
(
int
)
NS_GET_B
(
mColor
)
<
<
"
"
<
<
(
int
)
NS_GET_A
(
mColor
)
<
<
"
)
"
;
}
nsRect
nsDisplaySolidColorRegion
:
:
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
{
*
aSnap
=
true
;
return
mRegion
.
GetBounds
(
)
;
}
void
nsDisplaySolidColorRegion
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
nsRenderingContext
*
aCtx
)
{
int32_t
appUnitsPerDevPixel
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
DrawTarget
*
drawTarget
=
aCtx
-
>
GetDrawTarget
(
)
;
ColorPattern
color
(
mColor
)
;
for
(
auto
iter
=
mRegion
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
Rect
rect
=
NSRectToSnappedRect
(
iter
.
Get
(
)
appUnitsPerDevPixel
*
drawTarget
)
;
drawTarget
-
>
FillRect
(
rect
color
)
;
}
}
void
nsDisplaySolidColorRegion
:
:
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
{
aStream
<
<
"
(
rgba
"
<
<
int
(
mColor
.
r
*
255
)
<
<
"
"
<
<
int
(
mColor
.
g
*
255
)
<
<
"
"
<
<
int
(
mColor
.
b
*
255
)
<
<
"
"
<
<
mColor
.
a
<
<
"
)
"
;
}
static
void
RegisterThemeGeometry
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsITheme
:
:
ThemeGeometryType
aType
)
{
if
(
aBuilder
-
>
IsInChromeDocumentOrPopup
(
)
&
&
!
aBuilder
-
>
IsInTransform
(
)
)
{
nsIFrame
*
displayRoot
=
nsLayoutUtils
:
:
GetDisplayRootFrame
(
aFrame
)
;
nsPoint
offset
=
aBuilder
-
>
IsInSubdocument
(
)
?
aBuilder
-
>
ToReferenceFrame
(
aFrame
)
:
aFrame
-
>
GetOffsetTo
(
displayRoot
)
;
nsRect
borderBox
=
nsRect
(
offset
aFrame
-
>
GetSize
(
)
)
;
aBuilder
-
>
RegisterThemeGeometry
(
aType
LayoutDeviceIntRect
:
:
FromUnknownRect
(
borderBox
.
ToNearestPixels
(
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
)
)
;
}
}
static
Maybe
<
nsRect
>
GetViewportRectRelativeToReferenceFrame
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
{
nsIFrame
*
rootFrame
=
aFrame
-
>
PresContext
(
)
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
;
nsRect
rootRect
=
rootFrame
-
>
GetRectRelativeToSelf
(
)
;
if
(
nsLayoutUtils
:
:
TransformRect
(
rootFrame
aFrame
rootRect
)
=
=
nsLayoutUtils
:
:
TRANSFORM_SUCCEEDED
)
{
return
Some
(
rootRect
+
aBuilder
-
>
ToReferenceFrame
(
aFrame
)
)
;
}
return
Nothing
(
)
;
}
nsDisplayBackgroundImage
:
:
InitData
nsDisplayBackgroundImage
:
:
GetInitData
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
uint32_t
aLayer
const
nsRect
&
aBackgroundRect
const
nsStyleBackground
*
aBackgroundStyle
LayerizeFixed
aLayerizeFixed
)
{
nsPresContext
*
presContext
=
aFrame
-
>
PresContext
(
)
;
uint32_t
flags
=
aBuilder
-
>
GetBackgroundPaintFlags
(
)
;
const
nsStyleImageLayers
:
:
Layer
&
layer
=
aBackgroundStyle
-
>
mImage
.
mLayers
[
aLayer
]
;
bool
isTransformedFixed
;
nsBackgroundLayerState
state
=
nsCSSRendering
:
:
PrepareImageLayer
(
presContext
aFrame
flags
aBackgroundRect
aBackgroundRect
layer
&
isTransformedFixed
)
;
bool
shouldTreatAsFixed
=
layer
.
mAttachment
=
=
NS_STYLE_IMAGELAYER_ATTACHMENT_FIXED
&
&
!
isTransformedFixed
;
bool
shouldFixToViewport
=
shouldTreatAsFixed
&
&
!
layer
.
mImage
.
IsEmpty
(
)
;
if
(
shouldFixToViewport
&
&
aLayerizeFixed
=
=
LayerizeFixed
:
:
DO_NOT_LAYERIZE_FIXED_BACKGROUND_IF_AVOIDING_COMPONENT_ALPHA_LAYERS
&
&
!
nsLayoutUtils
:
:
UsesAsyncScrolling
(
aFrame
)
)
{
RefPtr
<
LayerManager
>
layerManager
=
aBuilder
-
>
GetWidgetLayerManager
(
)
;
if
(
layerManager
&
&
layerManager
-
>
ShouldAvoidComponentAlphaLayers
(
)
)
{
shouldFixToViewport
=
false
;
}
}
bool
isRasterImage
=
state
.
mImageRenderer
.
IsRasterImage
(
)
;
nsCOMPtr
<
imgIContainer
>
image
;
if
(
isRasterImage
)
{
image
=
state
.
mImageRenderer
.
GetImage
(
)
;
}
return
InitData
{
aBuilder
aFrame
aBackgroundStyle
image
aBackgroundRect
state
.
mFillArea
state
.
mDestArea
aLayer
isRasterImage
shouldFixToViewport
}
;
}
nsDisplayBackgroundImage
:
:
nsDisplayBackgroundImage
(
const
InitData
&
aInitData
)
:
nsDisplayImageContainer
(
aInitData
.
builder
aInitData
.
frame
)
mBackgroundStyle
(
aInitData
.
backgroundStyle
)
mImage
(
aInitData
.
image
)
mBackgroundRect
(
aInitData
.
backgroundRect
)
mFillRect
(
aInitData
.
fillArea
)
mDestRect
(
aInitData
.
destArea
)
mLayer
(
aInitData
.
layer
)
mIsRasterImage
(
aInitData
.
isRasterImage
)
mShouldFixToViewport
(
aInitData
.
shouldFixToViewport
)
{
MOZ_COUNT_CTOR
(
nsDisplayBackgroundImage
)
;
mBounds
=
GetBoundsInternal
(
aInitData
.
builder
)
;
if
(
mShouldFixToViewport
)
{
mAnimatedGeometryRoot
=
aInitData
.
builder
-
>
FindAnimatedGeometryRootFor
(
this
)
;
if
(
Maybe
<
nsRect
>
viewportRect
=
GetViewportRectRelativeToReferenceFrame
(
aInitData
.
builder
mFrame
)
)
{
mVisibleRect
=
mBounds
.
Intersect
(
*
viewportRect
)
;
}
}
}
nsDisplayBackgroundImage
:
:
~
nsDisplayBackgroundImage
(
)
{
#
ifdef
NS_BUILD_REFCNT_LOGGING
MOZ_COUNT_DTOR
(
nsDisplayBackgroundImage
)
;
#
endif
}
static
nsStyleContext
*
GetBackgroundStyleContext
(
nsIFrame
*
aFrame
)
{
nsStyleContext
*
sc
;
if
(
!
nsCSSRendering
:
:
FindBackground
(
aFrame
&
sc
)
)
{
if
(
!
aFrame
-
>
StyleDisplay
(
)
-
>
mAppearance
)
{
return
nullptr
;
}
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
!
content
|
|
content
-
>
GetParent
(
)
)
{
return
nullptr
;
}
sc
=
aFrame
-
>
StyleContext
(
)
;
}
return
sc
;
}
void
SetBackgroundClipRegion
(
DisplayListClipState
:
:
AutoSaveRestore
&
aClipState
nsIFrame
*
aFrame
const
nsPoint
&
aToReferenceFrame
const
nsStyleImageLayers
:
:
Layer
&
aLayer
const
nsRect
&
aBackgroundRect
bool
aWillPaintBorder
)
{
nsCSSRendering
:
:
ImageLayerClipState
clip
;
nsCSSRendering
:
:
GetImageLayerClip
(
aLayer
aFrame
*
aFrame
-
>
StyleBorder
(
)
aBackgroundRect
aBackgroundRect
aWillPaintBorder
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
&
clip
)
;
if
(
clip
.
mHasAdditionalBGClipArea
)
{
aClipState
.
ClipContentDescendants
(
clip
.
mAdditionalBGClipArea
clip
.
mBGClipArea
clip
.
mHasRoundedCorners
?
clip
.
mRadii
:
nullptr
)
;
}
else
{
aClipState
.
ClipContentDescendants
(
clip
.
mBGClipArea
clip
.
mHasRoundedCorners
?
clip
.
mRadii
:
nullptr
)
;
}
}
static
bool
SpecialCutoutRegionCase
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
nsRect
&
aBackgroundRect
nsDisplayList
*
aList
nscolor
aColor
)
{
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
!
content
)
{
return
false
;
}
void
*
cutoutRegion
=
content
-
>
GetProperty
(
nsGkAtoms
:
:
cutoutregion
)
;
if
(
!
cutoutRegion
)
{
return
false
;
}
if
(
NS_GET_A
(
aColor
)
=
=
0
)
{
return
true
;
}
nsRegion
region
;
region
.
Sub
(
aBackgroundRect
*
static_cast
<
nsRegion
*
>
(
cutoutRegion
)
)
;
region
.
MoveBy
(
aBuilder
-
>
ToReferenceFrame
(
aFrame
)
)
;
aList
-
>
AppendNewToTop
(
new
(
aBuilder
)
nsDisplaySolidColorRegion
(
aBuilder
aFrame
region
aColor
)
)
;
return
true
;
}
bool
nsDisplayBackgroundImage
:
:
AppendBackgroundItemsToTop
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
nsRect
&
aBackgroundRect
nsDisplayList
*
aList
bool
aAllowWillPaintBorderOptimization
nsStyleContext
*
aStyleContext
)
{
nsStyleContext
*
bgSC
=
aStyleContext
;
const
nsStyleBackground
*
bg
=
nullptr
;
nsRect
bgRect
=
aBackgroundRect
+
aBuilder
-
>
ToReferenceFrame
(
aFrame
)
;
nsPresContext
*
presContext
=
aFrame
-
>
PresContext
(
)
;
bool
isThemed
=
aFrame
-
>
IsThemed
(
)
;
if
(
!
isThemed
)
{
if
(
!
bgSC
)
{
bgSC
=
GetBackgroundStyleContext
(
aFrame
)
;
}
if
(
bgSC
)
{
bg
=
bgSC
-
>
StyleBackground
(
)
;
}
}
bool
drawBackgroundColor
=
false
;
nscolor
color
=
NS_RGBA
(
0
0
0
0
)
;
if
(
!
nsCSSRendering
:
:
IsCanvasFrame
(
aFrame
)
&
&
bg
)
{
bool
drawBackgroundImage
;
color
=
nsCSSRendering
:
:
DetermineBackgroundColor
(
presContext
bgSC
aFrame
drawBackgroundImage
drawBackgroundColor
)
;
}
if
(
SpecialCutoutRegionCase
(
aBuilder
aFrame
aBackgroundRect
aList
color
)
)
{
return
false
;
}
const
nsStyleBorder
*
borderStyle
=
aFrame
-
>
StyleBorder
(
)
;
const
nsStyleEffects
*
effectsStyle
=
aFrame
-
>
StyleEffects
(
)
;
bool
hasInsetShadow
=
effectsStyle
-
>
mBoxShadow
&
&
effectsStyle
-
>
mBoxShadow
-
>
HasShadowWithInset
(
true
)
;
bool
willPaintBorder
=
aAllowWillPaintBorderOptimization
&
&
!
isThemed
&
&
!
hasInsetShadow
&
&
borderStyle
-
>
HasBorder
(
)
;
nsPoint
toRef
=
aBuilder
-
>
ToReferenceFrame
(
aFrame
)
;
nsDisplayList
bgItemList
;
if
(
(
drawBackgroundColor
&
&
color
!
=
NS_RGBA
(
0
0
0
0
)
)
|
|
aBuilder
-
>
IsForEventDelivery
(
)
)
{
DisplayListClipState
:
:
AutoSaveRestore
clipState
(
aBuilder
)
;
if
(
bg
&
&
!
aBuilder
-
>
IsForEventDelivery
(
)
)
{
bool
useWillPaintBorderOptimization
=
willPaintBorder
&
&
nsLayoutUtils
:
:
HasNonZeroCorner
(
borderStyle
-
>
mBorderRadius
)
;
SetBackgroundClipRegion
(
clipState
aFrame
toRef
bg
-
>
BottomLayer
(
)
bgRect
useWillPaintBorderOptimization
)
;
}
bgItemList
.
AppendNewToTop
(
new
(
aBuilder
)
nsDisplayBackgroundColor
(
aBuilder
aFrame
bgRect
bg
drawBackgroundColor
?
color
:
NS_RGBA
(
0
0
0
0
)
)
)
;
}
if
(
isThemed
)
{
nsITheme
*
theme
=
presContext
-
>
GetTheme
(
)
;
if
(
theme
-
>
NeedToClearBackgroundBehindWidget
(
aFrame
aFrame
-
>
StyleDisplay
(
)
-
>
mAppearance
)
&
&
aBuilder
-
>
IsInChromeDocumentOrPopup
(
)
&
&
!
aBuilder
-
>
IsInTransform
(
)
)
{
bgItemList
.
AppendNewToTop
(
new
(
aBuilder
)
nsDisplayClearBackground
(
aBuilder
aFrame
)
)
;
}
nsDisplayThemedBackground
*
bgItem
=
new
(
aBuilder
)
nsDisplayThemedBackground
(
aBuilder
aFrame
bgRect
)
;
bgItemList
.
AppendNewToTop
(
bgItem
)
;
aList
-
>
AppendToTop
(
&
bgItemList
)
;
return
true
;
}
if
(
!
bg
)
{
aList
-
>
AppendToTop
(
&
bgItemList
)
;
return
false
;
}
const
ActiveScrolledRoot
*
asr
=
aBuilder
-
>
CurrentActiveScrolledRoot
(
)
;
bool
needBlendContainer
=
false
;
NS_FOR_VISIBLE_IMAGE_LAYERS_BACK_TO_FRONT
(
i
bg
-
>
mImage
)
{
if
(
bg
-
>
mImage
.
mLayers
[
i
]
.
mImage
.
IsEmpty
(
)
)
{
continue
;
}
if
(
bg
-
>
mImage
.
mLayers
[
i
]
.
mBlendMode
!
=
NS_STYLE_BLEND_NORMAL
)
{
needBlendContainer
=
true
;
}
DisplayListClipState
:
:
AutoSaveRestore
clipState
(
aBuilder
)
;
if
(
!
aBuilder
-
>
IsForEventDelivery
(
)
)
{
const
nsStyleImageLayers
:
:
Layer
&
layer
=
bg
-
>
mImage
.
mLayers
[
i
]
;
SetBackgroundClipRegion
(
clipState
aFrame
toRef
layer
bgRect
willPaintBorder
)
;
}
nsDisplayList
thisItemList
;
nsDisplayBackgroundImage
:
:
InitData
bgData
=
nsDisplayBackgroundImage
:
:
GetInitData
(
aBuilder
aFrame
i
bgRect
bg
LayerizeFixed
:
:
DO_NOT_LAYERIZE_FIXED_BACKGROUND_IF_AVOIDING_COMPONENT_ALPHA_LAYERS
)
;
if
(
bgData
.
shouldFixToViewport
)
{
auto
*
displayData
=
aBuilder
-
>
GetCurrentFixedBackgroundDisplayData
(
)
;
nsDisplayListBuilder
:
:
AutoBuildingDisplayList
buildingDisplayList
(
aBuilder
aFrame
aBuilder
-
>
GetDirtyRect
(
)
false
)
;
nsDisplayListBuilder
:
:
AutoCurrentActiveScrolledRootSetter
asrSetter
(
aBuilder
)
;
if
(
displayData
)
{
asrSetter
.
SetCurrentActiveScrolledRoot
(
displayData
-
>
mContainingBlockActiveScrolledRoot
)
;
if
(
nsLayoutUtils
:
:
UsesAsyncScrolling
(
aFrame
)
)
{
nsIFrame
*
rootFrame
=
aBuilder
-
>
CurrentPresShellState
(
)
-
>
mPresShell
-
>
GetRootFrame
(
)
;
nsRect
dirtyRect
=
displayData
-
>
mDirtyRect
+
aFrame
-
>
GetOffsetTo
(
rootFrame
)
;
buildingDisplayList
.
SetDirtyRect
(
dirtyRect
)
;
}
}
nsDisplayBackgroundImage
*
bgItem
=
nullptr
;
{
DisplayListClipState
:
:
AutoSaveRestore
bgImageClip
(
aBuilder
)
;
bgImageClip
.
Clear
(
)
;
bgItem
=
new
(
aBuilder
)
nsDisplayBackgroundImage
(
bgData
)
;
}
thisItemList
.
AppendNewToTop
(
nsDisplayFixedPosition
:
:
CreateForFixedBackground
(
aBuilder
aFrame
bgItem
i
)
)
;
}
else
{
thisItemList
.
AppendNewToTop
(
new
(
aBuilder
)
nsDisplayBackgroundImage
(
bgData
)
)
;
}
if
(
bg
-
>
mImage
.
mLayers
[
i
]
.
mBlendMode
!
=
NS_STYLE_BLEND_NORMAL
)
{
DisplayListClipState
:
:
AutoSaveRestore
blendClip
(
aBuilder
)
;
blendClip
.
ClearUpToASR
(
asr
)
;
thisItemList
.
AppendNewToTop
(
new
(
aBuilder
)
nsDisplayBlendMode
(
aBuilder
aFrame
&
thisItemList
bg
-
>
mImage
.
mLayers
[
i
]
.
mBlendMode
asr
i
+
1
)
)
;
}
bgItemList
.
AppendToTop
(
&
thisItemList
)
;
}
if
(
needBlendContainer
)
{
DisplayListClipState
:
:
AutoSaveRestore
blendContainerClip
(
aBuilder
)
;
blendContainerClip
.
ClearUpToASR
(
asr
)
;
bgItemList
.
AppendNewToTop
(
nsDisplayBlendContainer
:
:
CreateForBackgroundBlendMode
(
aBuilder
aFrame
&
bgItemList
asr
)
)
;
}
aList
-
>
AppendToTop
(
&
bgItemList
)
;
return
false
;
}
static
bool
RoundedBorderIntersectsRect
(
nsIFrame
*
aFrame
const
nsPoint
&
aFrameToReferenceFrame
const
nsRect
&
aTestRect
)
{
if
(
!
nsRect
(
aFrameToReferenceFrame
aFrame
-
>
GetSize
(
)
)
.
Intersects
(
aTestRect
)
)
return
false
;
nscoord
radii
[
8
]
;
return
!
aFrame
-
>
GetBorderRadii
(
radii
)
|
|
nsLayoutUtils
:
:
RoundedRectIntersectsRect
(
nsRect
(
aFrameToReferenceFrame
aFrame
-
>
GetSize
(
)
)
radii
aTestRect
)
;
}
static
bool
RoundedRectContainsRect
(
const
nsRect
&
aRoundedRect
const
nscoord
aRadii
[
8
]
const
nsRect
&
aContainedRect
)
{
nsRegion
rgn
=
nsLayoutUtils
:
:
RoundedRectIntersectRect
(
aRoundedRect
aRadii
aContainedRect
)
;
return
rgn
.
Contains
(
aContainedRect
)
;
}
bool
nsDisplayBackgroundImage
:
:
CanOptimizeToImageLayer
(
LayerManager
*
aManager
nsDisplayListBuilder
*
aBuilder
)
{
if
(
!
mBackgroundStyle
)
{
return
false
;
}
if
(
!
mDestRect
.
Contains
(
mFillRect
)
)
{
return
false
;
}
const
nsStyleImageLayers
:
:
Layer
&
layer
=
mBackgroundStyle
-
>
mImage
.
mLayers
[
mLayer
]
;
bool
allowPartialImages
=
(
layer
.
mSize
.
mWidthType
=
=
nsStyleImageLayers
:
:
Size
:
:
eContain
|
|
layer
.
mSize
.
mWidthType
=
=
nsStyleImageLayers
:
:
Size
:
:
eCover
)
;
if
(
!
allowPartialImages
&
&
!
mFillRect
.
Contains
(
mDestRect
)
)
{
return
false
;
}
return
nsDisplayImageContainer
:
:
CanOptimizeToImageLayer
(
aManager
aBuilder
)
;
}
nsRect
nsDisplayBackgroundImage
:
:
GetDestRect
(
)
{
return
mDestRect
;
}
already_AddRefed
<
imgIContainer
>
nsDisplayBackgroundImage
:
:
GetImage
(
)
{
nsCOMPtr
<
imgIContainer
>
image
=
mImage
;
return
image
.
forget
(
)
;
}
nsDisplayBackgroundImage
:
:
ImageLayerization
nsDisplayBackgroundImage
:
:
ShouldCreateOwnLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
)
{
if
(
ForceActiveLayers
(
)
)
{
return
WHENEVER_POSSIBLE
;
}
nsIFrame
*
backgroundStyleFrame
=
nsCSSRendering
:
:
FindBackgroundStyleFrame
(
mFrame
)
;
if
(
ActiveLayerTracker
:
:
IsBackgroundPositionAnimated
(
aBuilder
backgroundStyleFrame
)
)
{
return
WHENEVER_POSSIBLE
;
}
if
(
nsLayoutUtils
:
:
AnimatedImageLayersEnabled
(
)
&
&
mBackgroundStyle
)
{
const
nsStyleImageLayers
:
:
Layer
&
layer
=
mBackgroundStyle
-
>
mImage
.
mLayers
[
mLayer
]
;
const
nsStyleImage
*
image
=
&
layer
.
mImage
;
if
(
image
-
>
GetType
(
)
=
=
eStyleImageType_Image
)
{
imgIRequest
*
imgreq
=
image
-
>
GetImageData
(
)
;
nsCOMPtr
<
imgIContainer
>
image
;
if
(
imgreq
&
&
NS_SUCCEEDED
(
imgreq
-
>
GetImage
(
getter_AddRefs
(
image
)
)
)
&
&
image
)
{
bool
animated
=
false
;
if
(
NS_SUCCEEDED
(
image
-
>
GetAnimated
(
&
animated
)
)
&
&
animated
)
{
return
WHENEVER_POSSIBLE
;
}
}
}
}
if
(
nsLayoutUtils
:
:
GPUImageScalingEnabled
(
)
&
&
aManager
-
>
IsCompositingCheap
(
)
)
{
return
ONLY_FOR_SCALING
;
}
return
NO_LAYER_NEEDED
;
}
LayerState
nsDisplayBackgroundImage
:
:
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
{
ImageLayerization
shouldLayerize
=
ShouldCreateOwnLayer
(
aBuilder
aManager
)
;
if
(
shouldLayerize
=
=
NO_LAYER_NEEDED
)
{
return
LAYER_NONE
;
}
if
(
CanOptimizeToImageLayer
(
aManager
aBuilder
)
)
{
if
(
shouldLayerize
=
=
WHENEVER_POSSIBLE
)
{
return
LAYER_ACTIVE
;
}
MOZ_ASSERT
(
shouldLayerize
=
=
ONLY_FOR_SCALING
"
unhandled
ImageLayerization
value
?
"
)
;
MOZ_ASSERT
(
mImage
)
;
int32_t
imageWidth
;
int32_t
imageHeight
;
mImage
-
>
GetWidth
(
&
imageWidth
)
;
mImage
-
>
GetHeight
(
&
imageHeight
)
;
NS_ASSERTION
(
imageWidth
!
=
0
&
&
imageHeight
!
=
0
"
Invalid
image
size
!
"
)
;
int32_t
appUnitsPerDevPixel
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
LayoutDeviceRect
destRect
=
LayoutDeviceRect
:
:
FromAppUnits
(
GetDestRect
(
)
appUnitsPerDevPixel
)
;
const
LayerRect
destLayerRect
=
destRect
*
aParameters
.
Scale
(
)
;
const
gfxSize
scale
=
gfxSize
(
destLayerRect
.
width
/
imageWidth
destLayerRect
.
height
/
imageHeight
)
;
if
(
(
scale
.
width
!
=
1
.
0f
|
|
scale
.
height
!
=
1
.
0f
)
&
&
(
destLayerRect
.
width
*
destLayerRect
.
height
>
=
64
*
64
)
)
{
return
LAYER_ACTIVE
;
}
}
return
LAYER_NONE
;
}
already_AddRefed
<
Layer
>
nsDisplayBackgroundImage
:
:
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
{
RefPtr
<
ImageLayer
>
layer
=
static_cast
<
ImageLayer
*
>
(
aManager
-
>
GetLayerBuilder
(
)
-
>
GetLeafLayerFor
(
aBuilder
this
)
)
;
if
(
!
layer
)
{
layer
=
aManager
-
>
CreateImageLayer
(
)
;
if
(
!
layer
)
return
nullptr
;
}
RefPtr
<
ImageContainer
>
imageContainer
=
GetContainer
(
aManager
aBuilder
)
;
layer
-
>
SetContainer
(
imageContainer
)
;
ConfigureLayer
(
layer
aParameters
)
;
return
layer
.
forget
(
)
;
}
void
nsDisplayBackgroundImage
:
:
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
{
if
(
RoundedBorderIntersectsRect
(
mFrame
ToReferenceFrame
(
)
aRect
)
)
{
aOutFrames
-
>
AppendElement
(
mFrame
)
;
}
}
bool
nsDisplayBackgroundImage
:
:
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
{
if
(
!
nsDisplayItem
:
:
ComputeVisibility
(
aBuilder
aVisibleRegion
)
)
{
return
false
;
}
return
mBackgroundStyle
;
}
nsRegion
nsDisplayBackgroundImage
:
:
GetInsideClipRegion
(
nsDisplayItem
*
aItem
StyleGeometryBox
aClip
const
nsRect
&
aRect
const
nsRect
&
aBackgroundRect
)
{
nsRegion
result
;
if
(
aRect
.
IsEmpty
(
)
)
return
result
;
nsIFrame
*
frame
=
aItem
-
>
Frame
(
)
;
nsRect
clipRect
=
aBackgroundRect
;
if
(
frame
-
>
GetType
(
)
=
=
nsGkAtoms
:
:
canvasFrame
)
{
nsCanvasFrame
*
canvasFrame
=
static_cast
<
nsCanvasFrame
*
>
(
frame
)
;
clipRect
=
canvasFrame
-
>
CanvasArea
(
)
+
aItem
-
>
ToReferenceFrame
(
)
;
}
else
if
(
aClip
=
=
StyleGeometryBox
:
:
Padding
|
|
aClip
=
=
StyleGeometryBox
:
:
Content
)
{
nsMargin
border
=
frame
-
>
GetUsedBorder
(
)
;
if
(
aClip
=
=
StyleGeometryBox
:
:
Content
)
{
border
+
=
frame
-
>
GetUsedPadding
(
)
;
}
border
.
ApplySkipSides
(
frame
-
>
GetSkipSides
(
)
)
;
clipRect
.
Deflate
(
border
)
;
}
return
clipRect
.
Intersect
(
aRect
)
;
}
nsRegion
nsDisplayBackgroundImage
:
:
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
{
nsRegion
result
;
*
aSnap
=
false
;
if
(
!
mBackgroundStyle
)
return
result
;
*
aSnap
=
true
;
if
(
mFrame
-
>
StyleBorder
(
)
-
>
mBoxDecorationBreak
=
=
StyleBoxDecorationBreak
:
:
Clone
|
|
(
!
mFrame
-
>
GetPrevContinuation
(
)
&
&
!
mFrame
-
>
GetNextContinuation
(
)
)
)
{
const
nsStyleImageLayers
:
:
Layer
&
layer
=
mBackgroundStyle
-
>
mImage
.
mLayers
[
mLayer
]
;
if
(
layer
.
mImage
.
IsOpaque
(
)
&
&
layer
.
mBlendMode
=
=
NS_STYLE_BLEND_NORMAL
&
&
layer
.
mRepeat
.
mXRepeat
!
=
NS_STYLE_IMAGELAYER_REPEAT_SPACE
&
&
layer
.
mRepeat
.
mYRepeat
!
=
NS_STYLE_IMAGELAYER_REPEAT_SPACE
&
&
layer
.
mClip
!
=
StyleGeometryBox
:
:
Text
)
{
result
=
GetInsideClipRegion
(
this
layer
.
mClip
mBounds
mBackgroundRect
)
;
}
}
return
result
;
}
Maybe
<
nscolor
>
nsDisplayBackgroundImage
:
:
IsUniform
(
nsDisplayListBuilder
*
aBuilder
)
{
if
(
!
mBackgroundStyle
)
{
return
Some
(
NS_RGBA
(
0
0
0
0
)
)
;
}
return
Nothing
(
)
;
}
nsRect
nsDisplayBackgroundImage
:
:
GetPositioningArea
(
)
{
if
(
!
mBackgroundStyle
)
{
return
nsRect
(
)
;
}
nsIFrame
*
attachedToFrame
;
bool
transformedFixed
;
return
nsCSSRendering
:
:
ComputeImageLayerPositioningArea
(
mFrame
-
>
PresContext
(
)
mFrame
mBackgroundRect
mBackgroundStyle
-
>
mImage
.
mLayers
[
mLayer
]
&
attachedToFrame
&
transformedFixed
)
+
ToReferenceFrame
(
)
;
}
bool
nsDisplayBackgroundImage
:
:
RenderingMightDependOnPositioningAreaSizeChange
(
)
{
if
(
!
mBackgroundStyle
)
return
false
;
nscoord
radii
[
8
]
;
if
(
mFrame
-
>
GetBorderRadii
(
radii
)
)
{
return
true
;
}
const
nsStyleImageLayers
:
:
Layer
&
layer
=
mBackgroundStyle
-
>
mImage
.
mLayers
[
mLayer
]
;
if
(
layer
.
RenderingMightDependOnPositioningAreaSizeChange
(
)
)
{
return
true
;
}
return
false
;
}
static
void
CheckForBorderItem
(
nsDisplayItem
*
aItem
uint32_t
&
aFlags
)
{
nsDisplayItem
*
nextItem
=
aItem
-
>
GetAbove
(
)
;
while
(
nextItem
&
&
nextItem
-
>
GetType
(
)
=
=
nsDisplayItem
:
:
TYPE_BACKGROUND
)
{
nextItem
=
nextItem
-
>
GetAbove
(
)
;
}
if
(
nextItem
&
&
nextItem
-
>
Frame
(
)
=
=
aItem
-
>
Frame
(
)
&
&
nextItem
-
>
GetType
(
)
=
=
nsDisplayItem
:
:
TYPE_BORDER
)
{
aFlags
|
=
nsCSSRendering
:
:
PAINTBG_WILL_PAINT_BORDER
;
}
}
void
nsDisplayBackgroundImage
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
nsRenderingContext
*
aCtx
)
{
PaintInternal
(
aBuilder
aCtx
mVisibleRect
&
mBounds
)
;
}
void
nsDisplayBackgroundImage
:
:
PaintInternal
(
nsDisplayListBuilder
*
aBuilder
nsRenderingContext
*
aCtx
const
nsRect
&
aBounds
nsRect
*
aClipRect
)
{
uint32_t
flags
=
aBuilder
-
>
GetBackgroundPaintFlags
(
)
;
CheckForBorderItem
(
this
flags
)
;
gfxContext
*
ctx
=
aCtx
-
>
ThebesContext
(
)
;
StyleGeometryBox
clip
=
mBackgroundStyle
-
>
mImage
.
mLayers
[
mLayer
]
.
mClip
;
if
(
clip
=
=
StyleGeometryBox
:
:
Text
)
{
if
(
!
GenerateAndPushTextMask
(
mFrame
aCtx
mBackgroundRect
aBuilder
)
)
{
return
;
}
}
nsCSSRendering
:
:
PaintBGParams
params
=
nsCSSRendering
:
:
PaintBGParams
:
:
ForSingleLayer
(
*
mFrame
-
>
PresContext
(
)
*
aCtx
aBounds
mBackgroundRect
mFrame
flags
mLayer
CompositionOp
:
:
OP_OVER
)
;
params
.
bgClipRect
=
aClipRect
;
image
:
:
DrawResult
result
=
nsCSSRendering
:
:
PaintStyleImageLayer
(
params
)
;
if
(
clip
=
=
StyleGeometryBox
:
:
Text
)
{
ctx
-
>
PopGroupAndBlend
(
)
;
}
nsDisplayBackgroundGeometry
:
:
UpdateDrawResult
(
this
result
)
;
}
void
nsDisplayBackgroundImage
:
:
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
{
if
(
!
mBackgroundStyle
)
{
return
;
}
const
nsDisplayBackgroundGeometry
*
geometry
=
static_cast
<
const
nsDisplayBackgroundGeometry
*
>
(
aGeometry
)
;
bool
snap
;
nsRect
bounds
=
GetBounds
(
aBuilder
&
snap
)
;
nsRect
positioningArea
=
GetPositioningArea
(
)
;
if
(
positioningArea
.
TopLeft
(
)
!
=
geometry
-
>
mPositioningArea
.
TopLeft
(
)
|
|
(
positioningArea
.
Size
(
)
!
=
geometry
-
>
mPositioningArea
.
Size
(
)
&
&
RenderingMightDependOnPositioningAreaSizeChange
(
)
)
)
{
aInvalidRegion
-
>
Or
(
bounds
geometry
-
>
mBounds
)
;
if
(
positioningArea
.
Size
(
)
!
=
geometry
-
>
mPositioningArea
.
Size
(
)
)
{
NotifyRenderingChanged
(
)
;
}
return
;
}
if
(
!
mDestRect
.
IsEqualInterior
(
geometry
-
>
mDestRect
)
)
{
aInvalidRegion
-
>
Or
(
bounds
geometry
-
>
mBounds
)
;
NotifyRenderingChanged
(
)
;
return
;
}
if
(
aBuilder
-
>
ShouldSyncDecodeImages
(
)
)
{
const
nsStyleImage
&
image
=
mBackgroundStyle
-
>
mImage
.
mLayers
[
mLayer
]
.
mImage
;
if
(
image
.
GetType
(
)
=
=
eStyleImageType_Image
&
&
geometry
-
>
ShouldInvalidateToSyncDecodeImages
(
)
)
{
aInvalidRegion
-
>
Or
(
*
aInvalidRegion
bounds
)
;
NotifyRenderingChanged
(
)
;
}
}
if
(
!
bounds
.
IsEqualInterior
(
geometry
-
>
mBounds
)
)
{
aInvalidRegion
-
>
Xor
(
bounds
geometry
-
>
mBounds
)
;
NotifyRenderingChanged
(
)
;
}
}
nsRect
nsDisplayBackgroundImage
:
:
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
{
*
aSnap
=
true
;
return
mBounds
;
}
nsRect
nsDisplayBackgroundImage
:
:
GetBoundsInternal
(
nsDisplayListBuilder
*
aBuilder
)
{
nsPresContext
*
presContext
=
mFrame
-
>
PresContext
(
)
;
if
(
!
mBackgroundStyle
)
{
return
nsRect
(
)
;
}
nsRect
clipRect
=
mBackgroundRect
;
if
(
mFrame
-
>
GetType
(
)
=
=
nsGkAtoms
:
:
canvasFrame
)
{
nsCanvasFrame
*
frame
=
static_cast
<
nsCanvasFrame
*
>
(
mFrame
)
;
clipRect
=
frame
-
>
CanvasArea
(
)
+
ToReferenceFrame
(
)
;
}
const
nsStyleImageLayers
:
:
Layer
&
layer
=
mBackgroundStyle
-
>
mImage
.
mLayers
[
mLayer
]
;
return
nsCSSRendering
:
:
GetBackgroundLayerRect
(
presContext
mFrame
mBackgroundRect
clipRect
layer
aBuilder
-
>
GetBackgroundPaintFlags
(
)
)
;
}
uint32_t
nsDisplayBackgroundImage
:
:
GetPerFrameKey
(
)
{
return
(
mLayer
<
<
nsDisplayItem
:
:
TYPE_BITS
)
|
nsDisplayItem
:
:
GetPerFrameKey
(
)
;
}
nsDisplayThemedBackground
:
:
nsDisplayThemedBackground
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
nsRect
&
aBackgroundRect
)
:
nsDisplayItem
(
aBuilder
aFrame
)
mBackgroundRect
(
aBackgroundRect
)
{
MOZ_COUNT_CTOR
(
nsDisplayThemedBackground
)
;
const
nsStyleDisplay
*
disp
=
mFrame
-
>
StyleDisplay
(
)
;
mAppearance
=
disp
-
>
mAppearance
;
mFrame
-
>
IsThemed
(
disp
&
mThemeTransparency
)
;
nsITheme
*
theme
=
mFrame
-
>
PresContext
(
)
-
>
GetTheme
(
)
;
nsITheme
:
:
ThemeGeometryType
type
=
theme
-
>
ThemeGeometryTypeForWidget
(
mFrame
disp
-
>
mAppearance
)
;
if
(
type
!
=
nsITheme
:
:
eThemeGeometryTypeUnknown
)
{
RegisterThemeGeometry
(
aBuilder
aFrame
type
)
;
}
if
(
disp
-
>
mAppearance
=
=
NS_THEME_WIN_BORDERLESS_GLASS
|
|
disp
-
>
mAppearance
=
=
NS_THEME_WIN_GLASS
)
{
aBuilder
-
>
SetGlassDisplayItem
(
this
)
;
}
mBounds
=
GetBoundsInternal
(
)
;
}
nsDisplayThemedBackground
:
:
~
nsDisplayThemedBackground
(
)
{
#
ifdef
NS_BUILD_REFCNT_LOGGING
MOZ_COUNT_DTOR
(
nsDisplayThemedBackground
)
;
#
endif
}
void
nsDisplayThemedBackground
:
:
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
{
aStream
<
<
"
(
themed
appearance
:
"
<
<
(
int
)
mAppearance
<
<
"
)
"
;
}
void
nsDisplayThemedBackground
:
:
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
{
if
(
mBackgroundRect
.
Intersects
(
aRect
)
)
{
aOutFrames
-
>
AppendElement
(
mFrame
)
;
}
}
nsRegion
nsDisplayThemedBackground
:
:
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
{
nsRegion
result
;
*
aSnap
=
false
;
if
(
mThemeTransparency
=
=
nsITheme
:
:
eOpaque
)
{
result
=
mBackgroundRect
;
}
return
result
;
}
Maybe
<
nscolor
>
nsDisplayThemedBackground
:
:
IsUniform
(
nsDisplayListBuilder
*
aBuilder
)
{
if
(
mAppearance
=
=
NS_THEME_WIN_BORDERLESS_GLASS
|
|
mAppearance
=
=
NS_THEME_WIN_GLASS
)
{
return
Some
(
NS_RGBA
(
0
0
0
0
)
)
;
}
return
Nothing
(
)
;
}
bool
nsDisplayThemedBackground
:
:
ProvidesFontSmoothingBackgroundColor
(
nscolor
*
aColor
)
{
nsITheme
*
theme
=
mFrame
-
>
PresContext
(
)
-
>
GetTheme
(
)
;
return
theme
-
>
WidgetProvidesFontSmoothingBackgroundColor
(
mFrame
mAppearance
aColor
)
;
}
nsRect
nsDisplayThemedBackground
:
:
GetPositioningArea
(
)
{
return
mBackgroundRect
;
}
void
nsDisplayThemedBackground
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
nsRenderingContext
*
aCtx
)
{
PaintInternal
(
aBuilder
aCtx
mVisibleRect
nullptr
)
;
}
void
nsDisplayThemedBackground
:
:
PaintInternal
(
nsDisplayListBuilder
*
aBuilder
nsRenderingContext
*
aCtx
const
nsRect
&
aBounds
nsRect
*
aClipRect
)
{
nsPresContext
*
presContext
=
mFrame
-
>
PresContext
(
)
;
nsITheme
*
theme
=
presContext
-
>
GetTheme
(
)
;
nsRect
drawing
(
mBackgroundRect
)
;
theme
-
>
GetWidgetOverflow
(
presContext
-
>
DeviceContext
(
)
mFrame
mAppearance
&
drawing
)
;
drawing
.
IntersectRect
(
drawing
aBounds
)
;
theme
-
>
DrawWidgetBackground
(
aCtx
mFrame
mAppearance
mBackgroundRect
drawing
)
;
}
bool
nsDisplayThemedBackground
:
:
IsWindowActive
(
)
{
EventStates
docState
=
mFrame
-
>
GetContent
(
)
-
>
OwnerDoc
(
)
-
>
GetDocumentState
(
)
;
return
!
docState
.
HasState
(
NS_DOCUMENT_STATE_WINDOW_INACTIVE
)
;
}
void
nsDisplayThemedBackground
:
:
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
{
const
nsDisplayThemedBackgroundGeometry
*
geometry
=
static_cast
<
const
nsDisplayThemedBackgroundGeometry
*
>
(
aGeometry
)
;
bool
snap
;
nsRect
bounds
=
GetBounds
(
aBuilder
&
snap
)
;
nsRect
positioningArea
=
GetPositioningArea
(
)
;
if
(
!
positioningArea
.
IsEqualInterior
(
geometry
-
>
mPositioningArea
)
)
{
aInvalidRegion
-
>
Or
(
bounds
geometry
-
>
mBounds
)
;
return
;
}
if
(
!
bounds
.
IsEqualInterior
(
geometry
-
>
mBounds
)
)
{
aInvalidRegion
-
>
Xor
(
bounds
geometry
-
>
mBounds
)
;
}
nsITheme
*
theme
=
mFrame
-
>
PresContext
(
)
-
>
GetTheme
(
)
;
if
(
theme
-
>
WidgetAppearanceDependsOnWindowFocus
(
mAppearance
)
&
&
IsWindowActive
(
)
!
=
geometry
-
>
mWindowIsActive
)
{
aInvalidRegion
-
>
Or
(
*
aInvalidRegion
bounds
)
;
}
}
nsRect
nsDisplayThemedBackground
:
:
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
{
*
aSnap
=
true
;
return
mBounds
;
}
nsRect
nsDisplayThemedBackground
:
:
GetBoundsInternal
(
)
{
nsPresContext
*
presContext
=
mFrame
-
>
PresContext
(
)
;
nsRect
r
=
mBackgroundRect
-
ToReferenceFrame
(
)
;
presContext
-
>
GetTheme
(
)
-
>
GetWidgetOverflow
(
presContext
-
>
DeviceContext
(
)
mFrame
mFrame
-
>
StyleDisplay
(
)
-
>
mAppearance
&
r
)
;
return
r
+
ToReferenceFrame
(
)
;
}
void
nsDisplayImageContainer
:
:
ConfigureLayer
(
ImageLayer
*
aLayer
const
ContainerLayerParameters
&
aParameters
)
{
aLayer
-
>
SetSamplingFilter
(
nsLayoutUtils
:
:
GetSamplingFilterForFrame
(
mFrame
)
)
;
nsCOMPtr
<
imgIContainer
>
image
=
GetImage
(
)
;
MOZ_ASSERT
(
image
)
;
int32_t
imageWidth
;
int32_t
imageHeight
;
image
-
>
GetWidth
(
&
imageWidth
)
;
image
-
>
GetHeight
(
&
imageHeight
)
;
NS_ASSERTION
(
imageWidth
!
=
0
&
&
imageHeight
!
=
0
"
Invalid
image
size
!
"
)
;
if
(
imageWidth
>
0
&
&
imageHeight
>
0
)
{
nsDisplayBackgroundGeometry
:
:
UpdateDrawResult
(
this
image
:
:
DrawResult
:
:
SUCCESS
)
;
}
MOZ_ASSERT
(
aParameters
.
Offset
(
)
=
=
LayerIntPoint
(
0
0
)
)
;
IntSize
containerSize
=
aLayer
-
>
GetContainer
(
)
?
aLayer
-
>
GetContainer
(
)
-
>
GetCurrentSize
(
)
:
IntSize
(
imageWidth
imageHeight
)
;
const
int32_t
factor
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
const
LayoutDeviceRect
destRect
=
LayoutDeviceRect
:
:
FromAppUnits
(
GetDestRect
(
)
factor
)
;
const
LayoutDevicePoint
p
=
destRect
.
TopLeft
(
)
;
Matrix
transform
=
Matrix
:
:
Translation
(
p
.
x
p
.
y
)
;
transform
.
PreScale
(
destRect
.
width
/
containerSize
.
width
destRect
.
height
/
containerSize
.
height
)
;
aLayer
-
>
SetBaseTransform
(
gfx
:
:
Matrix4x4
:
:
From2D
(
transform
)
)
;
}
already_AddRefed
<
ImageContainer
>
nsDisplayImageContainer
:
:
GetContainer
(
LayerManager
*
aManager
nsDisplayListBuilder
*
aBuilder
)
{
nsCOMPtr
<
imgIContainer
>
image
=
GetImage
(
)
;
if
(
!
image
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Must
call
CanOptimizeToImage
(
)
and
get
true
"
"
before
calling
GetContainer
(
)
"
)
;
return
nullptr
;
}
uint32_t
flags
=
imgIContainer
:
:
FLAG_ASYNC_NOTIFY
;
if
(
aBuilder
-
>
ShouldSyncDecodeImages
(
)
)
{
flags
|
=
imgIContainer
:
:
FLAG_SYNC_DECODE
;
}
return
image
-
>
GetImageContainer
(
aManager
flags
)
;
}
bool
nsDisplayImageContainer
:
:
CanOptimizeToImageLayer
(
LayerManager
*
aManager
nsDisplayListBuilder
*
aBuilder
)
{
uint32_t
flags
=
aBuilder
-
>
ShouldSyncDecodeImages
(
)
?
imgIContainer
:
:
FLAG_SYNC_DECODE
:
imgIContainer
:
:
FLAG_NONE
;
nsCOMPtr
<
imgIContainer
>
image
=
GetImage
(
)
;
if
(
!
image
)
{
return
false
;
}
if
(
!
image
-
>
IsImageContainerAvailable
(
aManager
flags
)
)
{
return
false
;
}
int32_t
imageWidth
;
int32_t
imageHeight
;
image
-
>
GetWidth
(
&
imageWidth
)
;
image
-
>
GetHeight
(
&
imageHeight
)
;
if
(
imageWidth
=
=
0
|
|
imageHeight
=
=
0
)
{
NS_ASSERTION
(
false
"
invalid
image
size
"
)
;
return
false
;
}
const
int32_t
factor
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
const
LayoutDeviceRect
destRect
=
LayoutDeviceRect
:
:
FromAppUnits
(
GetDestRect
(
)
factor
)
;
const
gfxSize
scale
=
gfxSize
(
destRect
.
width
/
imageWidth
destRect
.
height
/
imageHeight
)
;
if
(
scale
.
width
<
0
.
34
|
|
scale
.
height
<
0
.
34
)
{
return
false
;
}
return
true
;
}
void
nsDisplayBackgroundColor
:
:
ApplyOpacity
(
nsDisplayListBuilder
*
aBuilder
float
aOpacity
const
DisplayItemClipChain
*
aClip
)
{
NS_ASSERTION
(
CanApplyOpacity
(
)
"
ApplyOpacity
should
be
allowed
"
)
;
mColor
.
a
=
mColor
.
a
*
aOpacity
;
IntersectClip
(
aBuilder
aClip
)
;
}
bool
nsDisplayBackgroundColor
:
:
CanApplyOpacity
(
)
const
{
return
true
;
}
LayerState
nsDisplayBackgroundColor
:
:
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
{
StyleGeometryBox
clip
=
mBackgroundStyle
-
>
mImage
.
mLayers
[
0
]
.
mClip
;
if
(
!
ForceActiveLayers
(
)
|
|
clip
=
=
StyleGeometryBox
:
:
Text
)
{
return
LAYER_NONE
;
}
return
LAYER_ACTIVE
;
}
already_AddRefed
<
Layer
>
nsDisplayBackgroundColor
:
:
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
{
if
(
mColor
=
=
Color
(
)
)
{
return
nullptr
;
}
RefPtr
<
ColorLayer
>
layer
=
static_cast
<
ColorLayer
*
>
(
aManager
-
>
GetLayerBuilder
(
)
-
>
GetLeafLayerFor
(
aBuilder
this
)
)
;
if
(
!
layer
)
{
layer
=
aManager
-
>
CreateColorLayer
(
)
;
if
(
!
layer
)
return
nullptr
;
}
layer
-
>
SetColor
(
mColor
)
;
int32_t
appUnitsPerDevPixel
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
layer
-
>
SetBounds
(
mBackgroundRect
.
ToNearestPixels
(
appUnitsPerDevPixel
)
)
;
layer
-
>
SetBaseTransform
(
gfx
:
:
Matrix4x4
:
:
Translation
(
aContainerParameters
.
mOffset
.
x
aContainerParameters
.
mOffset
.
y
0
)
)
;
return
layer
.
forget
(
)
;
}
void
nsDisplayBackgroundColor
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
nsRenderingContext
*
aCtx
)
{
if
(
mColor
=
=
Color
(
)
)
{
return
;
}
#
if
0
DrawTarget
&
aDrawTarget
=
*
aCtx
-
>
GetDrawTarget
(
)
;
Rect
rect
=
NSRectToSnappedRect
(
mBackgroundRect
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
aDrawTarget
)
;
ColorPattern
color
(
ToDeviceColor
(
mColor
)
)
;
aDrawTarget
.
FillRect
(
rect
color
)
;
#
else
gfxContext
*
ctx
=
aCtx
-
>
ThebesContext
(
)
;
gfxRect
bounds
=
nsLayoutUtils
:
:
RectToGfxRect
(
mBackgroundRect
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
StyleGeometryBox
clip
=
mBackgroundStyle
-
>
mImage
.
mLayers
[
0
]
.
mClip
;
if
(
clip
=
=
StyleGeometryBox
:
:
Text
)
{
if
(
!
GenerateAndPushTextMask
(
mFrame
aCtx
mBackgroundRect
aBuilder
)
)
{
return
;
}
ctx
-
>
SetColor
(
mColor
)
;
ctx
-
>
Rectangle
(
bounds
true
)
;
ctx
-
>
Fill
(
)
;
ctx
-
>
PopGroupAndBlend
(
)
;
return
;
}
ctx
-
>
SetColor
(
mColor
)
;
ctx
-
>
NewPath
(
)
;
ctx
-
>
Rectangle
(
bounds
true
)
;
ctx
-
>
Fill
(
)
;
#
endif
}
nsRegion
nsDisplayBackgroundColor
:
:
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
{
*
aSnap
=
false
;
if
(
mColor
.
a
!
=
1
)
{
return
nsRegion
(
)
;
}
if
(
!
mBackgroundStyle
)
return
nsRegion
(
)
;
const
nsStyleImageLayers
:
:
Layer
&
bottomLayer
=
mBackgroundStyle
-
>
BottomLayer
(
)
;
if
(
bottomLayer
.
mClip
=
=
StyleGeometryBox
:
:
Text
)
{
return
nsRegion
(
)
;
}
*
aSnap
=
true
;
return
nsDisplayBackgroundImage
:
:
GetInsideClipRegion
(
this
bottomLayer
.
mClip
mBackgroundRect
mBackgroundRect
)
;
}
Maybe
<
nscolor
>
nsDisplayBackgroundColor
:
:
IsUniform
(
nsDisplayListBuilder
*
aBuilder
)
{
return
Some
(
mColor
.
ToABGR
(
)
)
;
}
void
nsDisplayBackgroundColor
:
:
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
{
if
(
!
RoundedBorderIntersectsRect
(
mFrame
ToReferenceFrame
(
)
aRect
)
)
{
return
;
}
aOutFrames
-
>
AppendElement
(
mFrame
)
;
}
void
nsDisplayBackgroundColor
:
:
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
{
aStream
<
<
"
(
rgba
"
<
<
mColor
.
r
<
<
"
"
<
<
mColor
.
g
<
<
"
"
<
<
mColor
.
b
<
<
"
"
<
<
mColor
.
a
<
<
"
)
"
;
}
already_AddRefed
<
Layer
>
nsDisplayClearBackground
:
:
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
{
RefPtr
<
ColorLayer
>
layer
=
static_cast
<
ColorLayer
*
>
(
aManager
-
>
GetLayerBuilder
(
)
-
>
GetLeafLayerFor
(
aBuilder
this
)
)
;
if
(
!
layer
)
{
layer
=
aManager
-
>
CreateColorLayer
(
)
;
if
(
!
layer
)
return
nullptr
;
}
layer
-
>
SetColor
(
Color
(
)
)
;
layer
-
>
SetMixBlendMode
(
gfx
:
:
CompositionOp
:
:
OP_SOURCE
)
;
bool
snap
;
nsRect
bounds
=
GetBounds
(
aBuilder
&
snap
)
;
int32_t
appUnitsPerDevPixel
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
layer
-
>
SetBounds
(
bounds
.
ToNearestPixels
(
appUnitsPerDevPixel
)
)
;
return
layer
.
forget
(
)
;
}
nsRect
nsDisplayOutline
:
:
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
{
*
aSnap
=
false
;
return
mFrame
-
>
GetVisualOverflowRectRelativeToSelf
(
)
+
ToReferenceFrame
(
)
;
}
void
nsDisplayOutline
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
nsRenderingContext
*
aCtx
)
{
nsPoint
offset
=
ToReferenceFrame
(
)
;
nsCSSRendering
:
:
PaintOutline
(
mFrame
-
>
PresContext
(
)
*
aCtx
mFrame
mVisibleRect
nsRect
(
offset
mFrame
-
>
GetSize
(
)
)
mFrame
-
>
StyleContext
(
)
)
;
}
LayerState
nsDisplayOutline
:
:
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
{
if
(
!
gfxPrefs
:
:
LayersAllowOutlineLayers
(
)
)
{
return
LAYER_NONE
;
}
uint8_t
outlineStyle
=
mFrame
-
>
StyleContext
(
)
-
>
StyleOutline
(
)
-
>
mOutlineStyle
;
if
(
outlineStyle
=
=
NS_STYLE_BORDER_STYLE_AUTO
&
&
nsLayoutUtils
:
:
IsOutlineStyleAutoEnabled
(
)
)
{
nsITheme
*
theme
=
mFrame
-
>
PresContext
(
)
-
>
GetTheme
(
)
;
if
(
theme
&
&
theme
-
>
ThemeSupportsWidget
(
mFrame
-
>
PresContext
(
)
mFrame
NS_THEME_FOCUS_OUTLINE
)
)
{
return
LAYER_NONE
;
}
}
nsPoint
offset
=
ToReferenceFrame
(
)
;
Maybe
<
nsCSSBorderRenderer
>
br
=
nsCSSRendering
:
:
CreateBorderRendererForOutline
(
mFrame
-
>
PresContext
(
)
nullptr
mFrame
mVisibleRect
nsRect
(
offset
mFrame
-
>
GetSize
(
)
)
mFrame
-
>
StyleContext
(
)
)
;
if
(
!
br
)
{
return
LAYER_NONE
;
}
mBorderRenderer
=
br
;
return
LAYER_ACTIVE
;
}
already_AddRefed
<
Layer
>
nsDisplayOutline
:
:
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
{
return
BuildDisplayItemLayer
(
aBuilder
aManager
aContainerParameters
)
;
}
void
nsDisplayOutline
:
:
CreateWebRenderCommands
(
nsTArray
<
WebRenderCommand
>
&
aCommands
WebRenderDisplayItemLayer
*
aLayer
)
{
MOZ_ASSERT
(
mBorderRenderer
.
isSome
(
)
)
;
Rect
outlineTransformedRect
=
aLayer
-
>
RelativeToParent
(
mBorderRenderer
-
>
mOuterRect
)
;
nsCSSBorderRenderer
*
br
=
mBorderRenderer
.
ptr
(
)
;
WrBorderSide
side
[
4
]
;
NS_FOR_CSS_SIDES
(
i
)
{
side
[
i
]
=
wr
:
:
ToWrBorderSide
(
br
-
>
mBorderWidths
[
i
]
ToDeviceColor
(
br
-
>
mBorderColors
[
i
]
)
br
-
>
mBorderStyles
[
i
]
)
;
}
WrBorderRadius
borderRadius
=
wr
:
:
ToWrBorderRadius
(
LayerSize
(
br
-
>
mBorderRadii
[
0
]
.
width
br
-
>
mBorderRadii
[
0
]
.
height
)
LayerSize
(
br
-
>
mBorderRadii
[
1
]
.
width
br
-
>
mBorderRadii
[
1
]
.
height
)
LayerSize
(
br
-
>
mBorderRadii
[
3
]
.
width
br
-
>
mBorderRadii
[
3
]
.
height
)
LayerSize
(
br
-
>
mBorderRadii
[
2
]
.
width
br
-
>
mBorderRadii
[
2
]
.
height
)
)
;
aCommands
.
AppendElement
(
OpDPPushBorder
(
wr
:
:
ToWrRect
(
outlineTransformedRect
)
wr
:
:
ToWrRect
(
outlineTransformedRect
)
side
[
0
]
side
[
1
]
side
[
2
]
side
[
3
]
borderRadius
)
)
;
}
bool
nsDisplayOutline
:
:
IsInvisibleInRect
(
const
nsRect
&
aRect
)
{
const
nsStyleOutline
*
outline
=
mFrame
-
>
StyleOutline
(
)
;
nsRect
borderBox
(
ToReferenceFrame
(
)
mFrame
-
>
GetSize
(
)
)
;
if
(
borderBox
.
Contains
(
aRect
)
&
&
!
nsLayoutUtils
:
:
HasNonZeroCorner
(
outline
-
>
mOutlineRadius
)
)
{
if
(
outline
-
>
mOutlineOffset
>
=
0
)
{
return
true
;
}
}
return
false
;
}
void
nsDisplayEventReceiver
:
:
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
{
if
(
!
RoundedBorderIntersectsRect
(
mFrame
ToReferenceFrame
(
)
aRect
)
)
{
return
;
}
aOutFrames
-
>
AppendElement
(
mFrame
)
;
}
void
nsDisplayLayerEventRegions
:
:
AddFrame
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
{
NS_ASSERTION
(
aBuilder
-
>
FindReferenceFrameFor
(
aFrame
)
=
=
aBuilder
-
>
FindReferenceFrameFor
(
mFrame
)
"
Reference
frame
mismatch
"
)
;
if
(
aBuilder
-
>
IsInsidePointerEventsNoneDoc
(
)
)
{
return
;
}
if
(
!
aFrame
-
>
GetParent
(
)
)
{
MOZ_ASSERT
(
aFrame
-
>
GetType
(
)
=
=
nsGkAtoms
:
:
viewportFrame
)
;
return
;
}
uint8_t
pointerEvents
=
aFrame
-
>
StyleUserInterface
(
)
-
>
GetEffectivePointerEvents
(
aFrame
)
;
if
(
pointerEvents
=
=
NS_STYLE_POINTER_EVENTS_NONE
)
{
return
;
}
bool
simpleRegions
=
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_SIMPLE_EVENT_REGIONS
)
;
if
(
!
simpleRegions
)
{
if
(
!
aFrame
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
)
{
return
;
}
}
nsRect
borderBox
;
if
(
nsLayoutUtils
:
:
GetScrollableFrameFor
(
aFrame
)
)
{
borderBox
=
aFrame
-
>
GetScrollableOverflowRect
(
)
;
}
else
{
borderBox
=
nsRect
(
nsPoint
(
0
0
)
aFrame
-
>
GetSize
(
)
)
;
}
borderBox
+
=
aBuilder
-
>
ToReferenceFrame
(
aFrame
)
;
bool
borderBoxHasRoundedCorners
=
false
;
if
(
!
simpleRegions
)
{
if
(
nsLayoutUtils
:
:
HasNonZeroCorner
(
aFrame
-
>
StyleBorder
(
)
-
>
mBorderRadius
)
)
{
borderBoxHasRoundedCorners
=
true
;
}
else
{
aFrame
-
>
AddStateBits
(
NS_FRAME_SIMPLE_EVENT_REGIONS
)
;
}
}
const
DisplayItemClip
*
clip
=
DisplayItemClipChain
:
:
ClipForASR
(
aBuilder
-
>
ClipState
(
)
.
GetCurrentCombinedClipChain
(
aBuilder
)
aBuilder
-
>
CurrentActiveScrolledRoot
(
)
)
;
if
(
clip
)
{
borderBox
=
clip
-
>
ApplyNonRoundedIntersection
(
borderBox
)
;
if
(
clip
-
>
GetRoundedRectCount
(
)
>
0
)
{
borderBoxHasRoundedCorners
=
true
;
}
}
if
(
borderBoxHasRoundedCorners
|
|
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_SVG_LAYOUT
)
)
{
mMaybeHitRegion
.
Or
(
mMaybeHitRegion
borderBox
)
;
}
else
{
mHitRegion
.
Or
(
mHitRegion
borderBox
)
;
}
if
(
aBuilder
-
>
IsBuildingNonLayerizedScrollbar
(
)
|
|
aBuilder
-
>
GetAncestorHasApzAwareEventHandler
(
)
)
{
mDispatchToContentHitRegion
.
Or
(
mDispatchToContentHitRegion
borderBox
)
;
}
else
if
(
aFrame
-
>
GetType
(
)
=
=
nsGkAtoms
:
:
objectFrame
)
{
nsPluginFrame
*
pluginFrame
=
do_QueryFrame
(
aFrame
)
;
if
(
pluginFrame
&
&
pluginFrame
-
>
WantsToHandleWheelEventAsDefaultAction
(
)
)
{
mDispatchToContentHitRegion
.
Or
(
mDispatchToContentHitRegion
borderBox
)
;
}
}
nsIFrame
*
touchActionFrame
=
aFrame
;
nsIScrollableFrame
*
scrollFrame
=
nsLayoutUtils
:
:
GetScrollableFrameFor
(
aFrame
)
;
if
(
scrollFrame
)
{
touchActionFrame
=
do_QueryFrame
(
scrollFrame
)
;
}
uint32_t
touchAction
=
nsLayoutUtils
:
:
GetTouchActionFromFrame
(
touchActionFrame
)
;
if
(
touchAction
!
=
NS_STYLE_TOUCH_ACTION_AUTO
)
{
bool
alreadyHadRegions
=
!
mNoActionRegion
.
IsEmpty
(
)
|
|
!
mHorizontalPanRegion
.
IsEmpty
(
)
|
|
!
mVerticalPanRegion
.
IsEmpty
(
)
;
if
(
touchAction
&
NS_STYLE_TOUCH_ACTION_NONE
)
{
mNoActionRegion
.
OrWith
(
borderBox
)
;
}
else
{
if
(
(
touchAction
&
NS_STYLE_TOUCH_ACTION_PAN_X
)
)
{
mHorizontalPanRegion
.
OrWith
(
borderBox
)
;
}
if
(
(
touchAction
&
NS_STYLE_TOUCH_ACTION_PAN_Y
)
)
{
mVerticalPanRegion
.
OrWith
(
borderBox
)
;
}
}
if
(
alreadyHadRegions
)
{
mDispatchToContentHitRegion
.
OrWith
(
CombinedTouchActionRegion
(
)
)
;
}
}
}
void
nsDisplayLayerEventRegions
:
:
AddInactiveScrollPort
(
const
nsRect
&
aRect
)
{
mHitRegion
.
Or
(
mHitRegion
aRect
)
;
mDispatchToContentHitRegion
.
Or
(
mDispatchToContentHitRegion
aRect
)
;
}
bool
nsDisplayLayerEventRegions
:
:
IsEmpty
(
)
const
{
if
(
mHitRegion
.
IsEmpty
(
)
&
&
mMaybeHitRegion
.
IsEmpty
(
)
)
{
MOZ_ASSERT
(
mDispatchToContentHitRegion
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
mNoActionRegion
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
mHorizontalPanRegion
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
mVerticalPanRegion
.
IsEmpty
(
)
)
;
return
true
;
}
return
false
;
}
nsRegion
nsDisplayLayerEventRegions
:
:
CombinedTouchActionRegion
(
)
{
nsRegion
result
;
result
.
Or
(
mHorizontalPanRegion
mVerticalPanRegion
)
;
result
.
OrWith
(
mNoActionRegion
)
;
return
result
;
}
int32_t
nsDisplayLayerEventRegions
:
:
ZIndex
(
)
const
{
return
mOverrideZIndex
?
*
mOverrideZIndex
:
nsDisplayItem
:
:
ZIndex
(
)
;
}
void
nsDisplayLayerEventRegions
:
:
SetOverrideZIndex
(
int32_t
aZIndex
)
{
mOverrideZIndex
=
Some
(
aZIndex
)
;
}
void
nsDisplayLayerEventRegions
:
:
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
{
if
(
!
mHitRegion
.
IsEmpty
(
)
)
{
AppendToString
(
aStream
mHitRegion
"
(
hitRegion
"
"
)
"
)
;
}
if
(
!
mMaybeHitRegion
.
IsEmpty
(
)
)
{
AppendToString
(
aStream
mMaybeHitRegion
"
(
maybeHitRegion
"
"
)
"
)
;
}
if
(
!
mDispatchToContentHitRegion
.
IsEmpty
(
)
)
{
AppendToString
(
aStream
mDispatchToContentHitRegion
"
(
dispatchToContentRegion
"
"
)
"
)
;
}
if
(
!
mNoActionRegion
.
IsEmpty
(
)
)
{
AppendToString
(
aStream
mNoActionRegion
"
(
noActionRegion
"
"
)
"
)
;
}
if
(
!
mHorizontalPanRegion
.
IsEmpty
(
)
)
{
AppendToString
(
aStream
mHorizontalPanRegion
"
(
horizPanRegion
"
"
)
"
)
;
}
if
(
!
mVerticalPanRegion
.
IsEmpty
(
)
)
{
AppendToString
(
aStream
mVerticalPanRegion
"
(
vertPanRegion
"
"
)
"
)
;
}
}
nsDisplayCaret
:
:
nsDisplayCaret
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aCaretFrame
)
:
nsDisplayItem
(
aBuilder
aCaretFrame
)
mCaret
(
aBuilder
-
>
GetCaret
(
)
)
mBounds
(
aBuilder
-
>
GetCaretRect
(
)
+
ToReferenceFrame
(
)
)
{
MOZ_COUNT_CTOR
(
nsDisplayCaret
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
nsDisplayCaret
:
:
~
nsDisplayCaret
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayCaret
)
;
}
#
endif
nsRect
nsDisplayCaret
:
:
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
{
*
aSnap
=
true
;
return
mBounds
;
}
void
nsDisplayCaret
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
nsRenderingContext
*
aCtx
)
{
mCaret
-
>
PaintCaret
(
*
aCtx
-
>
GetDrawTarget
(
)
mFrame
ToReferenceFrame
(
)
)
;
}
void
nsDisplayCaret
:
:
CreateWebRenderCommands
(
nsTArray
<
WebRenderCommand
>
&
aCommands
WebRenderDisplayItemLayer
*
aLayer
)
{
using
namespace
mozilla
:
:
layers
;
int32_t
contentOffset
;
nsIFrame
*
frame
=
mCaret
-
>
GetFrame
(
&
contentOffset
)
;
if
(
!
frame
)
{
return
;
}
NS_ASSERTION
(
frame
=
=
mFrame
"
We
'
re
referring
different
frame
"
)
;
int32_t
appUnitsPerDevPixel
=
frame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
nsRect
caretRect
;
nsRect
hookRect
;
mCaret
-
>
ComputeCaretRects
(
frame
contentOffset
&
caretRect
&
hookRect
)
;
gfx
:
:
Color
color
=
ToDeviceColor
(
frame
-
>
GetCaretColorAt
(
contentOffset
)
)
;
Rect
devCaretRect
=
NSRectToRect
(
caretRect
+
ToReferenceFrame
(
)
appUnitsPerDevPixel
)
;
Rect
devHookRect
=
NSRectToRect
(
hookRect
+
ToReferenceFrame
(
)
appUnitsPerDevPixel
)
;
Rect
caretTransformedRect
=
aLayer
-
>
RelativeToParent
(
devCaretRect
)
;
Rect
hookTransformedRect
=
aLayer
-
>
RelativeToParent
(
devHookRect
)
;
IntRect
caret
=
RoundedToInt
(
caretTransformedRect
)
;
IntRect
hook
=
RoundedToInt
(
hookTransformedRect
)
;
aCommands
.
AppendElement
(
OpDPPushRect
(
wr
:
:
ToWrRect
(
caret
)
wr
:
:
ToWrRect
(
caret
)
wr
:
:
ToWrColor
(
color
)
)
)
;
if
(
!
devHookRect
.
IsEmpty
(
)
)
{
aCommands
.
AppendElement
(
OpDPPushRect
(
wr
:
:
ToWrRect
(
hook
)
wr
:
:
ToWrRect
(
hook
)
wr
:
:
ToWrColor
(
color
)
)
)
;
}
}
LayerState
nsDisplayCaret
:
:
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
{
if
(
gfxPrefs
:
:
LayersAllowCaretLayers
(
)
)
{
return
LAYER_ACTIVE
;
}
return
LAYER_NONE
;
}
already_AddRefed
<
Layer
>
nsDisplayCaret
:
:
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
{
return
BuildDisplayItemLayer
(
aBuilder
aManager
aContainerParameters
)
;
}
nsDisplayBorder
:
:
nsDisplayBorder
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
:
nsDisplayItem
(
aBuilder
aFrame
)
{
MOZ_COUNT_CTOR
(
nsDisplayBorder
)
;
mBounds
=
CalculateBounds
(
*
mFrame
-
>
StyleBorder
(
)
)
.
GetBounds
(
)
;
}
bool
nsDisplayBorder
:
:
IsInvisibleInRect
(
const
nsRect
&
aRect
)
{
nsRect
paddingRect
=
mFrame
-
>
GetPaddingRect
(
)
-
mFrame
-
>
GetPosition
(
)
+
ToReferenceFrame
(
)
;
const
nsStyleBorder
*
styleBorder
;
if
(
paddingRect
.
Contains
(
aRect
)
&
&
!
(
styleBorder
=
mFrame
-
>
StyleBorder
(
)
)
-
>
IsBorderImageLoaded
(
)
&
&
!
nsLayoutUtils
:
:
HasNonZeroCorner
(
styleBorder
-
>
mBorderRadius
)
)
{
return
true
;
}
return
false
;
}
nsDisplayItemGeometry
*
nsDisplayBorder
:
:
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
{
return
new
nsDisplayBorderGeometry
(
this
aBuilder
)
;
}
void
nsDisplayBorder
:
:
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
{
const
nsDisplayBorderGeometry
*
geometry
=
static_cast
<
const
nsDisplayBorderGeometry
*
>
(
aGeometry
)
;
bool
snap
;
if
(
!
geometry
-
>
mBounds
.
IsEqualInterior
(
GetBounds
(
aBuilder
&
snap
)
)
|
|
!
geometry
-
>
mContentRect
.
IsEqualInterior
(
GetContentRect
(
)
)
)
{
aInvalidRegion
-
>
Or
(
GetBounds
(
aBuilder
&
snap
)
geometry
-
>
mBounds
)
;
}
if
(
aBuilder
-
>
ShouldSyncDecodeImages
(
)
&
&
geometry
-
>
ShouldInvalidateToSyncDecodeImages
(
)
)
{
aInvalidRegion
-
>
Or
(
*
aInvalidRegion
GetBounds
(
aBuilder
&
snap
)
)
;
}
}
LayerState
nsDisplayBorder
:
:
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
{
if
(
!
gfxPrefs
:
:
LayersAllowBorderLayers
(
)
)
{
return
LAYER_NONE
;
}
nsPoint
offset
=
ToReferenceFrame
(
)
;
Maybe
<
nsCSSBorderRenderer
>
br
=
nsCSSRendering
:
:
CreateBorderRenderer
(
mFrame
-
>
PresContext
(
)
nullptr
mFrame
nsRect
(
)
nsRect
(
offset
mFrame
-
>
GetSize
(
)
)
mFrame
-
>
StyleContext
(
)
mFrame
-
>
GetSkipSides
(
)
)
;
if
(
!
br
)
{
return
LAYER_NONE
;
}
LayersBackend
backend
=
aManager
-
>
GetBackendType
(
)
;
if
(
backend
=
=
layers
:
:
LayersBackend
:
:
LAYERS_WR
)
{
bool
hasCompositeColors
;
br
-
>
AllBordersSolid
(
&
hasCompositeColors
)
;
if
(
hasCompositeColors
)
{
return
LAYER_NONE
;
}
NS_FOR_CSS_SIDES
(
i
)
{
mColors
[
i
]
=
ToDeviceColor
(
br
-
>
mBorderColors
[
i
]
)
;
mWidths
[
i
]
=
br
-
>
mBorderWidths
[
i
]
;
mBorderStyles
[
i
]
=
br
-
>
mBorderStyles
[
i
]
;
}
NS_FOR_CSS_FULL_CORNERS
(
corner
)
{
mCorners
[
corner
]
=
LayerSize
(
br
-
>
mBorderRadii
[
corner
]
.
width
br
-
>
mBorderRadii
[
corner
]
.
height
)
;
}
mRect
=
ViewAs
<
LayerPixel
>
(
br
-
>
mOuterRect
)
;
return
LAYER_ACTIVE
;
}
bool
hasCompositeColors
;
if
(
!
br
-
>
AllBordersSolid
(
&
hasCompositeColors
)
|
|
hasCompositeColors
)
{
return
LAYER_NONE
;
}
if
(
!
br
-
>
mNoBorderRadius
)
{
return
LAYER_NONE
;
}
if
(
!
br
-
>
AreBorderSideFinalStylesSame
(
eSideBitsAll
)
|
|
!
br
-
>
AllBordersSameWidth
(
)
)
{
return
LAYER_NONE
;
}
NS_FOR_CSS_SIDES
(
i
)
{
if
(
br
-
>
mBorderStyles
[
i
]
=
=
NS_STYLE_BORDER_STYLE_SOLID
)
{
mColors
[
i
]
=
ToDeviceColor
(
br
-
>
mBorderColors
[
i
]
)
;
mWidths
[
i
]
=
br
-
>
mBorderWidths
[
i
]
;
mBorderStyles
[
i
]
=
br
-
>
mBorderStyles
[
i
]
;
}
else
{
mWidths
[
i
]
=
0
;
}
}
NS_FOR_CSS_FULL_CORNERS
(
corner
)
{
mCorners
[
corner
]
=
LayerSize
(
br
-
>
mBorderRadii
[
corner
]
.
width
br
-
>
mBorderRadii
[
corner
]
.
height
)
;
}
mRect
=
ViewAs
<
LayerPixel
>
(
br
-
>
mOuterRect
)
;
return
LAYER_ACTIVE
;
}
already_AddRefed
<
Layer
>
nsDisplayBorder
:
:
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
{
RefPtr
<
BorderLayer
>
layer
=
static_cast
<
BorderLayer
*
>
(
aManager
-
>
GetLayerBuilder
(
)
-
>
GetLeafLayerFor
(
aBuilder
this
)
)
;
if
(
!
layer
)
{
layer
=
aManager
-
>
CreateBorderLayer
(
)
;
if
(
!
layer
)
return
nullptr
;
}
layer
-
>
SetRect
(
mRect
)
;
layer
-
>
SetCornerRadii
(
mCorners
)
;
layer
-
>
SetColors
(
mColors
)
;
layer
-
>
SetWidths
(
mWidths
)
;
layer
-
>
SetStyles
(
mBorderStyles
)
;
layer
-
>
SetBaseTransform
(
gfx
:
:
Matrix4x4
:
:
Translation
(
aContainerParameters
.
mOffset
.
x
aContainerParameters
.
mOffset
.
y
0
)
)
;
return
layer
.
forget
(
)
;
}
void
nsDisplayBorder
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
nsRenderingContext
*
aCtx
)
{
nsPoint
offset
=
ToReferenceFrame
(
)
;
PaintBorderFlags
flags
=
aBuilder
-
>
ShouldSyncDecodeImages
(
)
?
PaintBorderFlags
:
:
SYNC_DECODE_IMAGES
:
PaintBorderFlags
(
)
;
image
:
:
DrawResult
result
=
nsCSSRendering
:
:
PaintBorder
(
mFrame
-
>
PresContext
(
)
*
aCtx
mFrame
mVisibleRect
nsRect
(
offset
mFrame
-
>
GetSize
(
)
)
mFrame
-
>
StyleContext
(
)
flags
mFrame
-
>
GetSkipSides
(
)
)
;
nsDisplayBorderGeometry
:
:
UpdateDrawResult
(
this
result
)
;
}
nsRect
nsDisplayBorder
:
:
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
{
*
aSnap
=
true
;
return
mBounds
;
}
nsRegion
nsDisplayBorder
:
:
CalculateBounds
(
const
nsStyleBorder
&
aStyleBorder
)
{
nsRect
borderBounds
(
ToReferenceFrame
(
)
mFrame
-
>
GetSize
(
)
)
;
if
(
aStyleBorder
.
IsBorderImageLoaded
(
)
)
{
borderBounds
.
Inflate
(
aStyleBorder
.
GetImageOutset
(
)
)
;
return
borderBounds
;
}
else
{
nsMargin
border
=
aStyleBorder
.
GetComputedBorder
(
)
;
nsRegion
result
;
if
(
border
.
top
>
0
)
{
result
=
nsRect
(
borderBounds
.
X
(
)
borderBounds
.
Y
(
)
borderBounds
.
Width
(
)
border
.
top
)
;
}
if
(
border
.
right
>
0
)
{
result
.
OrWith
(
nsRect
(
borderBounds
.
XMost
(
)
-
border
.
right
borderBounds
.
Y
(
)
border
.
right
borderBounds
.
Height
(
)
)
)
;
}
if
(
border
.
bottom
>
0
)
{
result
.
OrWith
(
nsRect
(
borderBounds
.
X
(
)
borderBounds
.
YMost
(
)
-
border
.
bottom
borderBounds
.
Width
(
)
border
.
bottom
)
)
;
}
if
(
border
.
left
>
0
)
{
result
.
OrWith
(
nsRect
(
borderBounds
.
X
(
)
borderBounds
.
Y
(
)
border
.
left
borderBounds
.
Height
(
)
)
)
;
}
nscoord
radii
[
8
]
;
if
(
mFrame
-
>
GetBorderRadii
(
radii
)
)
{
if
(
border
.
left
>
0
|
|
border
.
top
>
0
)
{
nsSize
cornerSize
(
radii
[
eCornerTopLeftX
]
radii
[
eCornerTopLeftY
]
)
;
result
.
OrWith
(
nsRect
(
borderBounds
.
TopLeft
(
)
cornerSize
)
)
;
}
if
(
border
.
top
>
0
|
|
border
.
right
>
0
)
{
nsSize
cornerSize
(
radii
[
eCornerTopRightX
]
radii
[
eCornerTopRightY
]
)
;
result
.
OrWith
(
nsRect
(
borderBounds
.
TopRight
(
)
-
nsPoint
(
cornerSize
.
width
0
)
cornerSize
)
)
;
}
if
(
border
.
right
>
0
|
|
border
.
bottom
>
0
)
{
nsSize
cornerSize
(
radii
[
eCornerBottomRightX
]
radii
[
eCornerBottomRightY
]
)
;
result
.
OrWith
(
nsRect
(
borderBounds
.
BottomRight
(
)
-
nsPoint
(
cornerSize
.
width
cornerSize
.
height
)
cornerSize
)
)
;
}
if
(
border
.
bottom
>
0
|
|
border
.
left
>
0
)
{
nsSize
cornerSize
(
radii
[
eCornerBottomLeftX
]
radii
[
eCornerBottomLeftY
]
)
;
result
.
OrWith
(
nsRect
(
borderBounds
.
BottomLeft
(
)
-
nsPoint
(
0
cornerSize
.
height
)
cornerSize
)
)
;
}
}
return
result
;
}
}
static
void
ComputeDisjointRectangles
(
const
nsRegion
&
aRegion
nsTArray
<
nsRect
>
*
aRects
)
{
nscoord
accumulationMargin
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
25
)
;
nsRect
accumulated
;
for
(
auto
iter
=
aRegion
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
nsRect
&
r
=
iter
.
Get
(
)
;
if
(
accumulated
.
IsEmpty
(
)
)
{
accumulated
=
r
;
continue
;
}
if
(
accumulated
.
YMost
(
)
>
=
r
.
y
-
accumulationMargin
)
{
accumulated
.
UnionRect
(
accumulated
r
)
;
}
else
{
aRects
-
>
AppendElement
(
accumulated
)
;
accumulated
=
r
;
}
}
if
(
!
accumulated
.
IsEmpty
(
)
)
{
aRects
-
>
AppendElement
(
accumulated
)
;
}
}
void
nsDisplayBoxShadowOuter
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
nsRenderingContext
*
aCtx
)
{
nsPoint
offset
=
ToReferenceFrame
(
)
;
nsRect
borderRect
=
mFrame
-
>
VisualBorderRectRelativeToSelf
(
)
+
offset
;
nsPresContext
*
presContext
=
mFrame
-
>
PresContext
(
)
;
AutoTArray
<
nsRect
10
>
rects
;
ComputeDisjointRectangles
(
mVisibleRegion
&
rects
)
;
PROFILER_LABEL
(
"
nsDisplayBoxShadowOuter
"
"
Paint
"
js
:
:
ProfileEntry
:
:
Category
:
:
GRAPHICS
)
;
for
(
uint32_t
i
=
0
;
i
<
rects
.
Length
(
)
;
+
+
i
)
{
nsCSSRendering
:
:
PaintBoxShadowOuter
(
presContext
*
aCtx
mFrame
borderRect
rects
[
i
]
mOpacity
)
;
}
}
nsRect
nsDisplayBoxShadowOuter
:
:
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
{
*
aSnap
=
false
;
return
mBounds
;
}
nsRect
nsDisplayBoxShadowOuter
:
:
GetBoundsInternal
(
)
{
return
nsLayoutUtils
:
:
GetBoxShadowRectForFrame
(
mFrame
mFrame
-
>
GetSize
(
)
)
+
ToReferenceFrame
(
)
;
}
bool
nsDisplayBoxShadowOuter
:
:
IsInvisibleInRect
(
const
nsRect
&
aRect
)
{
nsPoint
origin
=
ToReferenceFrame
(
)
;
nsRect
frameRect
(
origin
mFrame
-
>
GetSize
(
)
)
;
if
(
!
frameRect
.
Contains
(
aRect
)
)
return
false
;
nscoord
twipsRadii
[
8
]
;
bool
hasBorderRadii
=
mFrame
-
>
GetBorderRadii
(
twipsRadii
)
;
if
(
!
hasBorderRadii
)
return
true
;
return
RoundedRectContainsRect
(
frameRect
twipsRadii
aRect
)
;
}
bool
nsDisplayBoxShadowOuter
:
:
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
{
if
(
!
nsDisplayItem
:
:
ComputeVisibility
(
aBuilder
aVisibleRegion
)
)
{
return
false
;
}
mVisibleRegion
.
And
(
*
aVisibleRegion
mVisibleRect
)
;
return
true
;
}
LayerState
nsDisplayBoxShadowOuter
:
:
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
{
if
(
gfxPrefs
:
:
LayersAllowOuterBoxShadow
(
)
)
{
return
LAYER_ACTIVE
;
}
return
LAYER_NONE
;
}
already_AddRefed
<
Layer
>
nsDisplayBoxShadowOuter
:
:
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
{
return
BuildDisplayItemLayer
(
aBuilder
aManager
aContainerParameters
)
;
}
void
nsDisplayBoxShadowOuter
:
:
CreateWebRenderCommands
(
nsTArray
<
WebRenderCommand
>
&
aCommands
WebRenderDisplayItemLayer
*
aLayer
)
{
int32_t
appUnitsPerDevPixel
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
nsPoint
offset
=
ToReferenceFrame
(
)
;
nsRect
borderRect
=
mFrame
-
>
VisualBorderRectRelativeToSelf
(
)
+
offset
;
AutoTArray
<
nsRect
10
>
rects
;
nsRegion
visible
=
aLayer
-
>
GetVisibleRegion
(
)
.
ToAppUnits
(
appUnitsPerDevPixel
)
;
ComputeDisjointRectangles
(
visible
&
rects
)
;
nsCSSShadowArray
*
shadows
=
mFrame
-
>
StyleEffects
(
)
-
>
mBoxShadow
;
if
(
!
shadows
)
return
;
bool
hasBorderRadius
;
bool
nativeTheme
=
nsCSSRendering
:
:
HasBoxShadowNativeTheme
(
mFrame
hasBorderRadius
)
;
for
(
uint32_t
i
=
0
;
i
<
rects
.
Length
(
)
;
+
+
i
)
{
Rect
clipRect
=
NSRectToRect
(
rects
[
i
]
appUnitsPerDevPixel
)
;
nsCSSShadowArray
*
shadows
=
mFrame
-
>
StyleEffects
(
)
-
>
mBoxShadow
;
for
(
uint32_t
j
=
shadows
-
>
Length
(
)
;
j
>
0
;
j
-
-
)
{
nsCSSShadowItem
*
shadow
=
shadows
-
>
ShadowAt
(
j
-
1
)
;
nsRect
shadowRect
=
nsCSSRendering
:
:
GetShadowRect
(
borderRect
nativeTheme
mFrame
)
;
gfx
:
:
Color
shadowColor
=
nsCSSRendering
:
:
GetShadowColor
(
shadow
mFrame
mOpacity
)
;
shadowRect
.
MoveBy
(
shadow
-
>
mXOffset
shadow
-
>
mYOffset
)
;
Point
shadowOffset
;
shadowOffset
.
x
=
(
shadow
-
>
mXOffset
/
appUnitsPerDevPixel
)
;
shadowOffset
.
y
=
(
shadow
-
>
mYOffset
/
appUnitsPerDevPixel
)
;
Rect
deviceBoxRect
=
NSRectToRect
(
shadowRect
appUnitsPerDevPixel
)
;
deviceBoxRect
=
aLayer
-
>
RelativeToParent
(
deviceBoxRect
)
;
Rect
deviceClipRect
=
aLayer
-
>
RelativeToParent
(
clipRect
+
shadowOffset
)
;
float
blurRadius
=
shadow
-
>
mRadius
/
appUnitsPerDevPixel
;
float
borderRadius
=
0
.
0
;
float
spreadRadius
=
shadow
-
>
mSpread
/
appUnitsPerDevPixel
;
aCommands
.
AppendElement
(
OpDPPushBoxShadow
(
wr
:
:
ToWrRect
(
deviceBoxRect
)
wr
:
:
ToWrRect
(
deviceClipRect
)
wr
:
:
ToWrRect
(
deviceBoxRect
)
wr
:
:
ToWrPoint
(
shadowOffset
)
wr
:
:
ToWrColor
(
shadowColor
)
blurRadius
spreadRadius
borderRadius
WrBoxShadowClipMode
:
:
Outset
)
)
;
}
}
}
void
nsDisplayBoxShadowOuter
:
:
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
{
const
nsDisplayBoxShadowOuterGeometry
*
geometry
=
static_cast
<
const
nsDisplayBoxShadowOuterGeometry
*
>
(
aGeometry
)
;
bool
snap
;
if
(
!
geometry
-
>
mBounds
.
IsEqualInterior
(
GetBounds
(
aBuilder
&
snap
)
)
|
|
!
geometry
-
>
mBorderRect
.
IsEqualInterior
(
GetBorderRect
(
)
)
|
|
mOpacity
!
=
geometry
-
>
mOpacity
)
{
nsRegion
oldShadow
newShadow
;
nscoord
dontCare
[
8
]
;
bool
hasBorderRadius
=
mFrame
-
>
GetBorderRadii
(
dontCare
)
;
if
(
hasBorderRadius
)
{
oldShadow
=
geometry
-
>
mBounds
;
newShadow
=
GetBounds
(
aBuilder
&
snap
)
;
}
else
{
oldShadow
.
Sub
(
geometry
-
>
mBounds
geometry
-
>
mBorderRect
)
;
newShadow
.
Sub
(
GetBounds
(
aBuilder
&
snap
)
GetBorderRect
(
)
)
;
}
aInvalidRegion
-
>
Or
(
oldShadow
newShadow
)
;
}
}
void
nsDisplayBoxShadowInner
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
nsRenderingContext
*
aCtx
)
{
nsPoint
offset
=
ToReferenceFrame
(
)
;
nsRect
borderRect
=
nsRect
(
offset
mFrame
-
>
GetSize
(
)
)
;
nsPresContext
*
presContext
=
mFrame
-
>
PresContext
(
)
;
AutoTArray
<
nsRect
10
>
rects
;
ComputeDisjointRectangles
(
mVisibleRegion
&
rects
)
;
PROFILER_LABEL
(
"
nsDisplayBoxShadowInner
"
"
Paint
"
js
:
:
ProfileEntry
:
:
Category
:
:
GRAPHICS
)
;
DrawTarget
*
drawTarget
=
aCtx
-
>
GetDrawTarget
(
)
;
gfxContext
*
gfx
=
aCtx
-
>
ThebesContext
(
)
;
int32_t
appUnitsPerDevPixel
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
for
(
uint32_t
i
=
0
;
i
<
rects
.
Length
(
)
;
+
+
i
)
{
gfx
-
>
Save
(
)
;
gfx
-
>
Clip
(
NSRectToSnappedRect
(
rects
[
i
]
appUnitsPerDevPixel
*
drawTarget
)
)
;
nsCSSRendering
:
:
PaintBoxShadowInner
(
presContext
*
aCtx
mFrame
borderRect
)
;
gfx
-
>
Restore
(
)
;
}
}
bool
nsDisplayBoxShadowInner
:
:
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
{
if
(
!
nsDisplayItem
:
:
ComputeVisibility
(
aBuilder
aVisibleRegion
)
)
{
return
false
;
}
mVisibleRegion
.
And
(
*
aVisibleRegion
mVisibleRect
)
;
return
true
;
}
nsDisplayWrapList
:
:
nsDisplayWrapList
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
)
:
nsDisplayWrapList
(
aBuilder
aFrame
aList
aBuilder
-
>
CurrentActiveScrolledRoot
(
)
)
{
}
nsDisplayWrapList
:
:
nsDisplayWrapList
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
ActiveScrolledRoot
*
aActiveScrolledRoot
)
:
nsDisplayItem
(
aBuilder
aFrame
aActiveScrolledRoot
)
mOverrideZIndex
(
0
)
mHasZIndexOverride
(
false
)
{
MOZ_COUNT_CTOR
(
nsDisplayWrapList
)
;
mBaseVisibleRect
=
mVisibleRect
;
mList
.
AppendToTop
(
aList
)
;
UpdateBounds
(
aBuilder
)
;
if
(
!
aFrame
|
|
!
aFrame
-
>
IsTransformed
(
)
)
{
return
;
}
nsDisplayItem
*
i
=
mList
.
GetBottom
(
)
;
if
(
i
&
&
(
!
i
-
>
GetAbove
(
)
|
|
i
-
>
GetType
(
)
=
=
TYPE_TRANSFORM
)
&
&
i
-
>
Frame
(
)
=
=
mFrame
)
{
mReferenceFrame
=
i
-
>
ReferenceFrame
(
)
;
mToReferenceFrame
=
i
-
>
ToReferenceFrame
(
)
;
}
mVisibleRect
=
aBuilder
-
>
GetDirtyRect
(
)
+
aBuilder
-
>
GetCurrentFrameOffsetToReferenceFrame
(
)
;
}
nsDisplayWrapList
:
:
nsDisplayWrapList
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayItem
*
aItem
)
:
nsDisplayItem
(
aBuilder
aFrame
)
mOverrideZIndex
(
0
)
mHasZIndexOverride
(
false
)
{
MOZ_COUNT_CTOR
(
nsDisplayWrapList
)
;
mBaseVisibleRect
=
mVisibleRect
;
mList
.
AppendToTop
(
aItem
)
;
UpdateBounds
(
aBuilder
)
;
if
(
!
aFrame
|
|
!
aFrame
-
>
IsTransformed
(
)
)
{
return
;
}
if
(
aItem
-
>
Frame
(
)
=
=
aFrame
)
{
mReferenceFrame
=
aItem
-
>
ReferenceFrame
(
)
;
mToReferenceFrame
=
aItem
-
>
ToReferenceFrame
(
)
;
}
mVisibleRect
=
aBuilder
-
>
GetDirtyRect
(
)
+
aBuilder
-
>
GetCurrentFrameOffsetToReferenceFrame
(
)
;
}
nsDisplayWrapList
:
:
~
nsDisplayWrapList
(
)
{
mList
.
DeleteAll
(
)
;
MOZ_COUNT_DTOR
(
nsDisplayWrapList
)
;
}
void
nsDisplayWrapList
:
:
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
{
mList
.
HitTest
(
aBuilder
aRect
aState
aOutFrames
)
;
}
nsRect
nsDisplayWrapList
:
:
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
{
*
aSnap
=
false
;
return
mBounds
;
}
bool
nsDisplayWrapList
:
:
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
{
nsRegion
visibleRegion
;
visibleRegion
.
And
(
*
aVisibleRegion
mVisibleRect
)
;
nsRegion
originalVisibleRegion
=
visibleRegion
;
bool
retval
=
mList
.
ComputeVisibilityForSublist
(
aBuilder
&
visibleRegion
mVisibleRect
)
;
nsRegion
removed
;
removed
.
Sub
(
originalVisibleRegion
visibleRegion
)
;
aBuilder
-
>
SubtractFromVisibleRegion
(
aVisibleRegion
removed
)
;
return
retval
;
}
nsRegion
nsDisplayWrapList
:
:
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
{
*
aSnap
=
false
;
nsRegion
result
;
if
(
mList
.
IsOpaque
(
)
)
{
result
=
GetBounds
(
aBuilder
aSnap
)
;
}
return
result
;
}
Maybe
<
nscolor
>
nsDisplayWrapList
:
:
IsUniform
(
nsDisplayListBuilder
*
aBuilder
)
{
return
Nothing
(
)
;
}
void
nsDisplayWrapList
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
nsRenderingContext
*
aCtx
)
{
NS_ERROR
(
"
nsDisplayWrapList
should
have
been
flattened
away
for
painting
"
)
;
}
static
LayerState
RequiredLayerStateForChildren
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
const
nsDisplayList
&
aList
AnimatedGeometryRoot
*
aExpectedAnimatedGeometryRootForChildren
)
{
LayerState
result
=
LAYER_INACTIVE
;
for
(
nsDisplayItem
*
i
=
aList
.
GetBottom
(
)
;
i
;
i
=
i
-
>
GetAbove
(
)
)
{
if
(
result
=
=
LAYER_INACTIVE
&
&
i
-
>
GetAnimatedGeometryRoot
(
)
!
=
aExpectedAnimatedGeometryRootForChildren
)
{
result
=
LAYER_ACTIVE
;
}
LayerState
state
=
i
-
>
GetLayerState
(
aBuilder
aManager
aParameters
)
;
if
(
state
=
=
LAYER_ACTIVE
&
&
i
-
>
GetType
(
)
=
=
nsDisplayItem
:
:
TYPE_BLEND_MODE
)
{
state
=
RequiredLayerStateForChildren
(
aBuilder
aManager
aParameters
*
i
-
>
GetSameCoordinateSystemChildren
(
)
i
-
>
GetAnimatedGeometryRoot
(
)
)
;
}
if
(
(
state
=
=
LAYER_ACTIVE
|
|
state
=
=
LAYER_ACTIVE_FORCE
)
&
&
state
>
result
)
{
result
=
state
;
}
if
(
state
=
=
LAYER_ACTIVE_EMPTY
&
&
state
>
result
)
{
result
=
LAYER_ACTIVE_FORCE
;
}
if
(
state
=
=
LAYER_NONE
)
{
nsDisplayList
*
list
=
i
-
>
GetSameCoordinateSystemChildren
(
)
;
if
(
list
)
{
LayerState
childState
=
RequiredLayerStateForChildren
(
aBuilder
aManager
aParameters
*
list
aExpectedAnimatedGeometryRootForChildren
)
;
if
(
childState
>
result
)
{
result
=
childState
;
}
}
}
}
return
result
;
}
nsRect
nsDisplayWrapList
:
:
GetComponentAlphaBounds
(
nsDisplayListBuilder
*
aBuilder
)
{
nsRect
bounds
;
for
(
nsDisplayItem
*
i
=
mList
.
GetBottom
(
)
;
i
;
i
=
i
-
>
GetAbove
(
)
)
{
bounds
.
UnionRect
(
bounds
i
-
>
GetComponentAlphaBounds
(
aBuilder
)
)
;
}
return
bounds
;
}
void
nsDisplayWrapList
:
:
SetVisibleRect
(
const
nsRect
&
aRect
)
{
mVisibleRect
=
aRect
;
}
void
nsDisplayWrapList
:
:
SetReferenceFrame
(
const
nsIFrame
*
aFrame
)
{
mReferenceFrame
=
aFrame
;
mToReferenceFrame
=
mFrame
-
>
GetOffsetToCrossDoc
(
mReferenceFrame
)
;
}
static
nsresult
WrapDisplayList
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
nsDisplayWrapper
*
aWrapper
)
{
if
(
!
aList
-
>
GetTop
(
)
)
return
NS_OK
;
nsDisplayItem
*
item
=
aWrapper
-
>
WrapList
(
aBuilder
aFrame
aList
)
;
if
(
!
item
)
return
NS_ERROR_OUT_OF_MEMORY
;
aList
-
>
AppendToTop
(
item
)
;
return
NS_OK
;
}
static
nsresult
WrapEachDisplayItem
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
nsDisplayWrapper
*
aWrapper
)
{
nsDisplayList
newList
;
nsDisplayItem
*
item
;
while
(
(
item
=
aList
-
>
RemoveBottom
(
)
)
)
{
item
=
aWrapper
-
>
WrapItem
(
aBuilder
item
)
;
if
(
!
item
)
return
NS_ERROR_OUT_OF_MEMORY
;
newList
.
AppendToTop
(
item
)
;
}
aList
-
>
AppendToTop
(
&
newList
)
;
return
NS_OK
;
}
nsresult
nsDisplayWrapper
:
:
WrapLists
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
nsDisplayListSet
&
aIn
const
nsDisplayListSet
&
aOut
)
{
nsresult
rv
=
WrapListsInPlace
(
aBuilder
aFrame
aIn
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
&
aOut
=
=
&
aIn
)
return
NS_OK
;
aOut
.
BorderBackground
(
)
-
>
AppendToTop
(
aIn
.
BorderBackground
(
)
)
;
aOut
.
BlockBorderBackgrounds
(
)
-
>
AppendToTop
(
aIn
.
BlockBorderBackgrounds
(
)
)
;
aOut
.
Floats
(
)
-
>
AppendToTop
(
aIn
.
Floats
(
)
)
;
aOut
.
Content
(
)
-
>
AppendToTop
(
aIn
.
Content
(
)
)
;
aOut
.
PositionedDescendants
(
)
-
>
AppendToTop
(
aIn
.
PositionedDescendants
(
)
)
;
aOut
.
Outlines
(
)
-
>
AppendToTop
(
aIn
.
Outlines
(
)
)
;
return
NS_OK
;
}
nsresult
nsDisplayWrapper
:
:
WrapListsInPlace
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
nsDisplayListSet
&
aLists
)
{
nsresult
rv
;
if
(
WrapBorderBackground
(
)
)
{
rv
=
WrapDisplayList
(
aBuilder
aFrame
aLists
.
BorderBackground
(
)
this
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
WrapDisplayList
(
aBuilder
aFrame
aLists
.
BlockBorderBackgrounds
(
)
this
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
WrapEachDisplayItem
(
aBuilder
aLists
.
Floats
(
)
this
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
WrapDisplayList
(
aBuilder
aFrame
aLists
.
Content
(
)
this
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
WrapEachDisplayItem
(
aBuilder
aLists
.
PositionedDescendants
(
)
this
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
WrapEachDisplayItem
(
aBuilder
aLists
.
Outlines
(
)
this
)
;
}
nsDisplayOpacity
:
:
nsDisplayOpacity
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
ActiveScrolledRoot
*
aActiveScrolledRoot
bool
aForEventsAndPluginsOnly
)
:
nsDisplayWrapList
(
aBuilder
aFrame
aList
aActiveScrolledRoot
)
mOpacity
(
aFrame
-
>
StyleEffects
(
)
-
>
mOpacity
)
mForEventsAndPluginsOnly
(
aForEventsAndPluginsOnly
)
{
MOZ_COUNT_CTOR
(
nsDisplayOpacity
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
nsDisplayOpacity
:
:
~
nsDisplayOpacity
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayOpacity
)
;
}
#
endif
nsRegion
nsDisplayOpacity
:
:
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
{
*
aSnap
=
false
;
return
nsRegion
(
)
;
}
already_AddRefed
<
Layer
>
nsDisplayOpacity
:
:
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
{
ContainerLayerParameters
params
=
aContainerParameters
;
params
.
mForEventsAndPluginsOnly
=
mForEventsAndPluginsOnly
;
RefPtr
<
Layer
>
container
=
aManager
-
>
GetLayerBuilder
(
)
-
>
BuildContainerLayerFor
(
aBuilder
aManager
mFrame
this
&
mList
params
nullptr
FrameLayerBuilder
:
:
CONTAINER_ALLOW_PULL_BACKGROUND_COLOR
)
;
if
(
!
container
)
return
nullptr
;
container
-
>
SetOpacity
(
mOpacity
)
;
nsDisplayListBuilder
:
:
AddAnimationsAndTransitionsToLayer
(
container
aBuilder
this
mFrame
eCSSProperty_opacity
)
;
return
container
.
forget
(
)
;
}
static
bool
IsItemTooSmallForActiveLayer
(
nsIFrame
*
aFrame
)
{
nsIntRect
visibleDevPixels
=
aFrame
-
>
GetVisualOverflowRectRelativeToSelf
(
)
.
ToOutsidePixels
(
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
return
visibleDevPixels
.
Size
(
)
<
nsIntSize
(
gfxPrefs
:
:
LayoutMinActiveLayerSize
(
)
gfxPrefs
:
:
LayoutMinActiveLayerSize
(
)
)
;
}
bool
nsDisplayOpacity
:
:
NeedsActiveLayer
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
{
if
(
EffectCompositor
:
:
HasAnimationsForCompositor
(
aFrame
eCSSProperty_opacity
)
|
|
(
ActiveLayerTracker
:
:
IsStyleAnimated
(
aBuilder
aFrame
eCSSProperty_opacity
)
&
&
!
IsItemTooSmallForActiveLayer
(
aFrame
)
)
)
{
return
true
;
}
return
false
;
}
void
nsDisplayOpacity
:
:
ApplyOpacity
(
nsDisplayListBuilder
*
aBuilder
float
aOpacity
const
DisplayItemClipChain
*
aClip
)
{
NS_ASSERTION
(
CanApplyOpacity
(
)
"
ApplyOpacity
should
be
allowed
"
)
;
mOpacity
=
mOpacity
*
aOpacity
;
IntersectClip
(
aBuilder
aClip
)
;
}
bool
nsDisplayOpacity
:
:
CanApplyOpacity
(
)
const
{
return
true
;
}
bool
nsDisplayOpacity
:
:
ShouldFlattenAway
(
nsDisplayListBuilder
*
aBuilder
)
{
if
(
NeedsActiveLayer
(
aBuilder
mFrame
)
|
|
mOpacity
=
=
0
.
0
)
{
return
false
;
}
nsDisplayItem
*
child
=
mList
.
GetBottom
(
)
;
if
(
!
child
)
{
return
false
;
}
struct
{
nsDisplayItem
*
item
;
nsRect
bounds
;
}
children
[
3
]
;
bool
snap
;
uint32_t
numChildren
=
0
;
for
(
;
numChildren
<
ArrayLength
(
children
)
&
&
child
;
numChildren
+
+
child
=
child
-
>
GetAbove
(
)
)
{
if
(
child
-
>
GetType
(
)
=
=
nsDisplayItem
:
:
TYPE_LAYER_EVENT_REGIONS
)
{
numChildren
-
-
;
continue
;
}
if
(
!
child
-
>
CanApplyOpacity
(
)
)
{
return
false
;
}
children
[
numChildren
]
.
item
=
child
;
children
[
numChildren
]
.
bounds
=
child
-
>
GetBounds
(
aBuilder
&
snap
)
;
}
if
(
child
)
{
return
false
;
}
for
(
uint32_t
i
=
0
;
i
<
numChildren
;
i
+
+
)
{
for
(
uint32_t
j
=
i
+
1
;
j
<
numChildren
;
j
+
+
)
{
if
(
children
[
i
]
.
bounds
.
Intersects
(
children
[
j
]
.
bounds
)
)
{
return
false
;
}
}
}
DisplayItemClipChain
clip
=
{
GetClip
(
)
mActiveScrolledRoot
nullptr
}
;
for
(
uint32_t
i
=
0
;
i
<
numChildren
;
i
+
+
)
{
children
[
i
]
.
item
-
>
ApplyOpacity
(
aBuilder
mOpacity
mClip
?
&
clip
:
nullptr
)
;
}
return
true
;
}
nsDisplayItem
:
:
LayerState
nsDisplayOpacity
:
:
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
{
if
(
mForEventsAndPluginsOnly
)
{
MOZ_ASSERT
(
mOpacity
=
=
0
)
;
return
LAYER_INACTIVE
;
}
if
(
NeedsActiveLayer
(
aBuilder
mFrame
)
)
{
return
LAYER_ACTIVE_FORCE
;
}
return
RequiredLayerStateForChildren
(
aBuilder
aManager
aParameters
mList
GetAnimatedGeometryRoot
(
)
)
;
}
bool
nsDisplayOpacity
:
:
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
{
nsRect
bounds
=
GetClippedBounds
(
aBuilder
)
;
nsRegion
visibleUnderChildren
;
visibleUnderChildren
.
And
(
*
aVisibleRegion
bounds
)
;
return
nsDisplayWrapList
:
:
ComputeVisibility
(
aBuilder
&
visibleUnderChildren
)
;
}
bool
nsDisplayOpacity
:
:
TryMerge
(
nsDisplayItem
*
aItem
)
{
if
(
aItem
-
>
GetType
(
)
!
=
TYPE_OPACITY
)
return
false
;
if
(
aItem
-
>
Frame
(
)
-
>
GetContent
(
)
!
=
mFrame
-
>
GetContent
(
)
)
return
false
;
if
(
aItem
-
>
GetClipChain
(
)
!
=
GetClipChain
(
)
)
return
false
;
MergeFromTrackingMergedFrames
(
static_cast
<
nsDisplayOpacity
*
>
(
aItem
)
)
;
return
true
;
}
void
nsDisplayOpacity
:
:
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
{
aStream
<
<
"
(
opacity
"
<
<
mOpacity
<
<
"
)
"
;
}
nsDisplayBlendMode
:
:
nsDisplayBlendMode
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
uint8_t
aBlendMode
const
ActiveScrolledRoot
*
aActiveScrolledRoot
uint32_t
aIndex
)
:
nsDisplayWrapList
(
aBuilder
aFrame
aList
aActiveScrolledRoot
)
mBlendMode
(
aBlendMode
)
mIndex
(
aIndex
)
{
MOZ_COUNT_CTOR
(
nsDisplayBlendMode
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
nsDisplayBlendMode
:
:
~
nsDisplayBlendMode
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayBlendMode
)
;
}
#
endif
nsRegion
nsDisplayBlendMode
:
:
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
{
*
aSnap
=
false
;
return
nsRegion
(
)
;
}
LayerState
nsDisplayBlendMode
:
:
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
{
return
LAYER_ACTIVE
;
}
already_AddRefed
<
Layer
>
nsDisplayBlendMode
:
:
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
{
ContainerLayerParameters
newContainerParameters
=
aContainerParameters
;
newContainerParameters
.
mDisableSubpixelAntialiasingInDescendants
=
true
;
RefPtr
<
Layer
>
container
=
aManager
-
>
GetLayerBuilder
(
)
-
>
BuildContainerLayerFor
(
aBuilder
aManager
mFrame
this
&
mList
newContainerParameters
nullptr
)
;
if
(
!
container
)
{
return
nullptr
;
}
container
-
>
SetMixBlendMode
(
nsCSSRendering
:
:
GetGFXBlendMode
(
mBlendMode
)
)
;
return
container
.
forget
(
)
;
}
bool
nsDisplayBlendMode
:
:
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
{
nsRect
bounds
=
GetClippedBounds
(
aBuilder
)
;
nsRegion
visibleUnderChildren
;
visibleUnderChildren
.
And
(
*
aVisibleRegion
bounds
)
;
return
nsDisplayWrapList
:
:
ComputeVisibility
(
aBuilder
&
visibleUnderChildren
)
;
}
bool
nsDisplayBlendMode
:
:
TryMerge
(
nsDisplayItem
*
aItem
)
{
if
(
aItem
-
>
GetType
(
)
!
=
TYPE_BLEND_MODE
)
return
false
;
nsDisplayBlendMode
*
item
=
static_cast
<
nsDisplayBlendMode
*
>
(
aItem
)
;
if
(
item
-
>
Frame
(
)
-
>
GetContent
(
)
!
=
mFrame
-
>
GetContent
(
)
)
return
false
;
if
(
item
-
>
mIndex
!
=
0
|
|
mIndex
!
=
0
)
return
false
;
if
(
item
-
>
GetClipChain
(
)
!
=
GetClipChain
(
)
)
return
false
;
MergeFromTrackingMergedFrames
(
item
)
;
return
true
;
}
nsDisplayBlendContainer
*
nsDisplayBlendContainer
:
:
CreateForMixBlendMode
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
ActiveScrolledRoot
*
aActiveScrolledRoot
)
{
return
new
(
aBuilder
)
nsDisplayBlendContainer
(
aBuilder
aFrame
aList
aActiveScrolledRoot
false
)
;
}
nsDisplayBlendContainer
*
nsDisplayBlendContainer
:
:
CreateForBackgroundBlendMode
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
ActiveScrolledRoot
*
aActiveScrolledRoot
)
{
return
new
(
aBuilder
)
nsDisplayBlendContainer
(
aBuilder
aFrame
aList
aActiveScrolledRoot
true
)
;
}
nsDisplayBlendContainer
:
:
nsDisplayBlendContainer
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
ActiveScrolledRoot
*
aActiveScrolledRoot
bool
aIsForBackground
)
:
nsDisplayWrapList
(
aBuilder
aFrame
aList
aActiveScrolledRoot
)
mIsForBackground
(
aIsForBackground
)
{
MOZ_COUNT_CTOR
(
nsDisplayBlendContainer
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
nsDisplayBlendContainer
:
:
~
nsDisplayBlendContainer
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayBlendContainer
)
;
}
#
endif
already_AddRefed
<
Layer
>
nsDisplayBlendContainer
:
:
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
{
ContainerLayerParameters
newContainerParameters
=
aContainerParameters
;
newContainerParameters
.
mDisableSubpixelAntialiasingInDescendants
=
true
;
RefPtr
<
Layer
>
container
=
aManager
-
>
GetLayerBuilder
(
)
-
>
BuildContainerLayerFor
(
aBuilder
aManager
mFrame
this
&
mList
newContainerParameters
nullptr
)
;
if
(
!
container
)
{
return
nullptr
;
}
container
-
>
SetForceIsolatedGroup
(
true
)
;
return
container
.
forget
(
)
;
}
LayerState
nsDisplayBlendContainer
:
:
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
{
return
RequiredLayerStateForChildren
(
aBuilder
aManager
aParameters
mList
GetAnimatedGeometryRoot
(
)
)
;
}
bool
nsDisplayBlendContainer
:
:
TryMerge
(
nsDisplayItem
*
aItem
)
{
if
(
aItem
-
>
GetType
(
)
!
=
TYPE_BLEND_CONTAINER
)
return
false
;
if
(
aItem
-
>
Frame
(
)
-
>
GetContent
(
)
!
=
mFrame
-
>
GetContent
(
)
)
return
false
;
if
(
aItem
-
>
GetClipChain
(
)
!
=
GetClipChain
(
)
)
return
false
;
MergeFromTrackingMergedFrames
(
static_cast
<
nsDisplayBlendContainer
*
>
(
aItem
)
)
;
return
true
;
}
nsDisplayOwnLayer
:
:
nsDisplayOwnLayer
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
ActiveScrolledRoot
*
aActiveScrolledRoot
uint32_t
aFlags
ViewID
aScrollTarget
float
aScrollbarThumbRatio
bool
aForceActive
)
:
nsDisplayWrapList
(
aBuilder
aFrame
aList
aActiveScrolledRoot
)
mFlags
(
aFlags
)
mScrollTarget
(
aScrollTarget
)
mScrollbarThumbRatio
(
aScrollbarThumbRatio
)
mForceActive
(
aForceActive
)
{
MOZ_COUNT_CTOR
(
nsDisplayOwnLayer
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
nsDisplayOwnLayer
:
:
~
nsDisplayOwnLayer
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayOwnLayer
)
;
}
#
endif
LayerState
nsDisplayOwnLayer
:
:
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
{
if
(
mForceActive
)
{
return
mozilla
:
:
LAYER_ACTIVE_FORCE
;
}
return
RequiredLayerStateForChildren
(
aBuilder
aManager
aParameters
mList
mAnimatedGeometryRoot
)
;
}
already_AddRefed
<
Layer
>
nsDisplayOwnLayer
:
:
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
{
RefPtr
<
ContainerLayer
>
layer
=
aManager
-
>
GetLayerBuilder
(
)
-
>
BuildContainerLayerFor
(
aBuilder
aManager
mFrame
this
&
mList
aContainerParameters
nullptr
FrameLayerBuilder
:
:
CONTAINER_ALLOW_PULL_BACKGROUND_COLOR
)
;
if
(
mFlags
&
VERTICAL_SCROLLBAR
)
{
layer
-
>
SetScrollbarData
(
mScrollTarget
ScrollDirection
:
:
VERTICAL
mScrollbarThumbRatio
)
;
}
if
(
mFlags
&
HORIZONTAL_SCROLLBAR
)
{
layer
-
>
SetScrollbarData
(
mScrollTarget
ScrollDirection
:
:
HORIZONTAL
mScrollbarThumbRatio
)
;
}
if
(
mFlags
&
SCROLLBAR_CONTAINER
)
{
layer
-
>
SetIsScrollbarContainer
(
mScrollTarget
)
;
}
if
(
mFlags
&
GENERATE_SUBDOC_INVALIDATIONS
)
{
mFrame
-
>
PresContext
(
)
-
>
SetNotifySubDocInvalidationData
(
layer
)
;
}
return
layer
.
forget
(
)
;
}
nsDisplaySubDocument
:
:
nsDisplaySubDocument
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
uint32_t
aFlags
)
:
nsDisplayOwnLayer
(
aBuilder
aFrame
aList
aBuilder
-
>
CurrentActiveScrolledRoot
(
)
aFlags
)
mScrollParentId
(
aBuilder
-
>
GetCurrentScrollParentId
(
)
)
{
MOZ_COUNT_CTOR
(
nsDisplaySubDocument
)
;
mForceDispatchToContentRegion
=
aBuilder
-
>
IsBuildingLayerEventRegions
(
)
&
&
nsLayoutUtils
:
:
HasDocumentLevelListenersForApzAwareEvents
(
aFrame
-
>
PresContext
(
)
-
>
PresShell
(
)
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
nsDisplaySubDocument
:
:
~
nsDisplaySubDocument
(
)
{
MOZ_COUNT_DTOR
(
nsDisplaySubDocument
)
;
}
#
endif
already_AddRefed
<
Layer
>
nsDisplaySubDocument
:
:
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
{
nsPresContext
*
presContext
=
mFrame
-
>
PresContext
(
)
;
nsIFrame
*
rootScrollFrame
=
presContext
-
>
PresShell
(
)
-
>
GetRootScrollFrame
(
)
;
ContainerLayerParameters
params
=
aContainerParameters
;
if
(
(
mFlags
&
GENERATE_SCROLLABLE_LAYER
)
&
&
rootScrollFrame
-
>
GetContent
(
)
&
&
nsLayoutUtils
:
:
HasCriticalDisplayPort
(
rootScrollFrame
-
>
GetContent
(
)
)
)
{
params
.
mInLowPrecisionDisplayPort
=
true
;
}
RefPtr
<
Layer
>
layer
=
nsDisplayOwnLayer
:
:
BuildLayer
(
aBuilder
aManager
params
)
;
layer
-
>
AsContainerLayer
(
)
-
>
SetEventRegionsOverride
(
mForceDispatchToContentRegion
?
EventRegionsOverride
:
:
ForceDispatchToContent
:
EventRegionsOverride
:
:
NoOverride
)
;
return
layer
.
forget
(
)
;
}
UniquePtr
<
ScrollMetadata
>
nsDisplaySubDocument
:
:
ComputeScrollMetadata
(
Layer
*
aLayer
const
ContainerLayerParameters
&
aContainerParameters
)
{
if
(
!
(
mFlags
&
GENERATE_SCROLLABLE_LAYER
)
)
{
return
UniquePtr
<
ScrollMetadata
>
(
nullptr
)
;
}
nsPresContext
*
presContext
=
mFrame
-
>
PresContext
(
)
;
nsIFrame
*
rootScrollFrame
=
presContext
-
>
PresShell
(
)
-
>
GetRootScrollFrame
(
)
;
bool
isRootContentDocument
=
presContext
-
>
IsRootContentDocument
(
)
;
nsIPresShell
*
presShell
=
presContext
-
>
PresShell
(
)
;
ContainerLayerParameters
params
(
aContainerParameters
.
mXScale
*
presShell
-
>
GetResolution
(
)
aContainerParameters
.
mYScale
*
presShell
-
>
GetResolution
(
)
nsIntPoint
(
)
aContainerParameters
)
;
if
(
(
mFlags
&
GENERATE_SCROLLABLE_LAYER
)
&
&
rootScrollFrame
-
>
GetContent
(
)
&
&
nsLayoutUtils
:
:
HasCriticalDisplayPort
(
rootScrollFrame
-
>
GetContent
(
)
)
)
{
params
.
mInLowPrecisionDisplayPort
=
true
;
}
nsRect
viewport
=
mFrame
-
>
GetRect
(
)
-
mFrame
-
>
GetPosition
(
)
+
mFrame
-
>
GetOffsetToCrossDoc
(
ReferenceFrame
(
)
)
;
return
MakeUnique
<
ScrollMetadata
>
(
nsLayoutUtils
:
:
ComputeScrollMetadata
(
mFrame
rootScrollFrame
rootScrollFrame
-
>
GetContent
(
)
ReferenceFrame
(
)
aLayer
mScrollParentId
viewport
Nothing
(
)
isRootContentDocument
params
)
)
;
}
static
bool
UseDisplayPortForViewport
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
{
return
aBuilder
-
>
IsPaintingToWindow
(
)
&
&
nsLayoutUtils
:
:
ViewportHasDisplayPort
(
aFrame
-
>
PresContext
(
)
)
;
}
nsRect
nsDisplaySubDocument
:
:
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
{
bool
usingDisplayPort
=
UseDisplayPortForViewport
(
aBuilder
mFrame
)
;
if
(
(
mFlags
&
GENERATE_SCROLLABLE_LAYER
)
&
&
usingDisplayPort
)
{
*
aSnap
=
false
;
return
mFrame
-
>
GetRect
(
)
+
aBuilder
-
>
ToReferenceFrame
(
mFrame
)
;
}
return
nsDisplayOwnLayer
:
:
GetBounds
(
aBuilder
aSnap
)
;
}
bool
nsDisplaySubDocument
:
:
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
{
bool
usingDisplayPort
=
UseDisplayPortForViewport
(
aBuilder
mFrame
)
;
if
(
!
(
mFlags
&
GENERATE_SCROLLABLE_LAYER
)
|
|
!
usingDisplayPort
)
{
return
nsDisplayWrapList
:
:
ComputeVisibility
(
aBuilder
aVisibleRegion
)
;
}
nsRect
displayport
;
nsIFrame
*
rootScrollFrame
=
mFrame
-
>
PresContext
(
)
-
>
PresShell
(
)
-
>
GetRootScrollFrame
(
)
;
MOZ_ASSERT
(
rootScrollFrame
)
;
Unused
<
<
nsLayoutUtils
:
:
GetDisplayPort
(
rootScrollFrame
-
>
GetContent
(
)
&
displayport
RelativeTo
:
:
ScrollFrame
)
;
nsRegion
childVisibleRegion
;
childVisibleRegion
=
displayport
+
mFrame
-
>
GetOffsetToCrossDoc
(
ReferenceFrame
(
)
)
;
nsRect
boundedRect
=
childVisibleRegion
.
GetBounds
(
)
.
Intersect
(
mList
.
GetClippedBoundsWithRespectToASR
(
aBuilder
mActiveScrolledRoot
)
)
;
bool
visible
=
mList
.
ComputeVisibilityForSublist
(
aBuilder
&
childVisibleRegion
boundedRect
)
;
if
(
!
nsLayoutUtils
:
:
UsesAsyncScrolling
(
mFrame
)
)
{
bool
snap
;
nsRect
bounds
=
GetBounds
(
aBuilder
&
snap
)
;
nsRegion
removed
;
removed
.
Sub
(
bounds
childVisibleRegion
)
;
aBuilder
-
>
SubtractFromVisibleRegion
(
aVisibleRegion
removed
)
;
}
return
visible
;
}
bool
nsDisplaySubDocument
:
:
ShouldBuildLayerEvenIfInvisible
(
nsDisplayListBuilder
*
aBuilder
)
{
bool
usingDisplayPort
=
UseDisplayPortForViewport
(
aBuilder
mFrame
)
;
if
(
(
mFlags
&
GENERATE_SCROLLABLE_LAYER
)
&
&
usingDisplayPort
)
{
return
true
;
}
return
nsDisplayOwnLayer
:
:
ShouldBuildLayerEvenIfInvisible
(
aBuilder
)
;
}
nsRegion
nsDisplaySubDocument
:
:
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
{
bool
usingDisplayPort
=
UseDisplayPortForViewport
(
aBuilder
mFrame
)
;
if
(
(
mFlags
&
GENERATE_SCROLLABLE_LAYER
)
&
&
usingDisplayPort
)
{
*
aSnap
=
false
;
return
nsRegion
(
)
;
}
return
nsDisplayOwnLayer
:
:
GetOpaqueRegion
(
aBuilder
aSnap
)
;
}
nsDisplayResolution
:
:
nsDisplayResolution
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
uint32_t
aFlags
)
:
nsDisplaySubDocument
(
aBuilder
aFrame
aList
aFlags
)
{
MOZ_COUNT_CTOR
(
nsDisplayResolution
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
nsDisplayResolution
:
:
~
nsDisplayResolution
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayResolution
)
;
}
#
endif
void
nsDisplayResolution
:
:
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
{
nsIPresShell
*
presShell
=
mFrame
-
>
PresContext
(
)
-
>
PresShell
(
)
;
nsRect
rect
=
aRect
.
RemoveResolution
(
presShell
-
>
ScaleToResolution
(
)
?
presShell
-
>
GetResolution
(
)
:
1
.
0f
)
;
mList
.
HitTest
(
aBuilder
rect
aState
aOutFrames
)
;
}
already_AddRefed
<
Layer
>
nsDisplayResolution
:
:
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
{
nsIPresShell
*
presShell
=
mFrame
-
>
PresContext
(
)
-
>
PresShell
(
)
;
ContainerLayerParameters
containerParameters
(
presShell
-
>
GetResolution
(
)
presShell
-
>
GetResolution
(
)
nsIntPoint
(
)
aContainerParameters
)
;
RefPtr
<
Layer
>
layer
=
nsDisplaySubDocument
:
:
BuildLayer
(
aBuilder
aManager
containerParameters
)
;
layer
-
>
SetPostScale
(
1
.
0f
/
presShell
-
>
GetResolution
(
)
1
.
0f
/
presShell
-
>
GetResolution
(
)
)
;
layer
-
>
AsContainerLayer
(
)
-
>
SetScaleToResolution
(
presShell
-
>
ScaleToResolution
(
)
presShell
-
>
GetResolution
(
)
)
;
return
layer
.
forget
(
)
;
}
nsDisplayFixedPosition
:
:
nsDisplayFixedPosition
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
ActiveScrolledRoot
*
aActiveScrolledRoot
)
:
nsDisplayOwnLayer
(
aBuilder
aFrame
aList
aActiveScrolledRoot
)
mIndex
(
0
)
mIsFixedBackground
(
false
)
{
MOZ_COUNT_CTOR
(
nsDisplayFixedPosition
)
;
Init
(
aBuilder
)
;
}
nsDisplayFixedPosition
:
:
nsDisplayFixedPosition
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
uint32_t
aIndex
)
:
nsDisplayOwnLayer
(
aBuilder
aFrame
aList
aBuilder
-
>
CurrentActiveScrolledRoot
(
)
)
mIndex
(
aIndex
)
mIsFixedBackground
(
true
)
{
MOZ_COUNT_CTOR
(
nsDisplayFixedPosition
)
;
Init
(
aBuilder
)
;
}
void
nsDisplayFixedPosition
:
:
Init
(
nsDisplayListBuilder
*
aBuilder
)
{
mAnimatedGeometryRootForScrollMetadata
=
mAnimatedGeometryRoot
;
if
(
ShouldFixToViewport
(
aBuilder
)
)
{
mAnimatedGeometryRoot
=
aBuilder
-
>
FindAnimatedGeometryRootFor
(
this
)
;
}
}
nsDisplayFixedPosition
*
nsDisplayFixedPosition
:
:
CreateForFixedBackground
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayBackgroundImage
*
aImage
uint32_t
aIndex
)
{
nsDisplayList
temp
;
temp
.
AppendToTop
(
aImage
)
;
return
new
(
aBuilder
)
nsDisplayFixedPosition
(
aBuilder
aFrame
&
temp
aIndex
+
1
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
nsDisplayFixedPosition
:
:
~
nsDisplayFixedPosition
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayFixedPosition
)
;
}
#
endif
already_AddRefed
<
Layer
>
nsDisplayFixedPosition
:
:
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
{
RefPtr
<
Layer
>
layer
=
nsDisplayOwnLayer
:
:
BuildLayer
(
aBuilder
aManager
aContainerParameters
)
;
layer
-
>
SetIsFixedPosition
(
true
)
;
nsPresContext
*
presContext
=
mFrame
-
>
PresContext
(
)
;
nsIFrame
*
fixedFrame
=
mIsFixedBackground
?
presContext
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
:
mFrame
;
const
nsIFrame
*
viewportFrame
=
fixedFrame
-
>
GetParent
(
)
;
nsRect
anchorRect
;
if
(
viewportFrame
)
{
if
(
presContext
-
>
PresShell
(
)
-
>
IsScrollPositionClampingScrollPortSizeSet
(
)
)
{
anchorRect
.
SizeTo
(
presContext
-
>
PresShell
(
)
-
>
GetScrollPositionClampingScrollPortSize
(
)
)
;
}
else
{
anchorRect
.
SizeTo
(
viewportFrame
-
>
GetSize
(
)
)
;
}
}
else
{
viewportFrame
=
fixedFrame
;
}
anchorRect
.
MoveTo
(
viewportFrame
-
>
GetOffsetToCrossDoc
(
ReferenceFrame
(
)
)
)
;
nsLayoutUtils
:
:
SetFixedPositionLayerData
(
layer
viewportFrame
anchorRect
fixedFrame
presContext
aContainerParameters
)
;
return
layer
.
forget
(
)
;
}
bool
nsDisplayFixedPosition
:
:
TryMerge
(
nsDisplayItem
*
aItem
)
{
if
(
aItem
-
>
GetType
(
)
!
=
TYPE_FIXED_POSITION
)
return
false
;
nsDisplayFixedPosition
*
other
=
static_cast
<
nsDisplayFixedPosition
*
>
(
aItem
)
;
if
(
other
-
>
mFrame
!
=
mFrame
)
return
false
;
if
(
aItem
-
>
GetClipChain
(
)
!
=
GetClipChain
(
)
)
return
false
;
MergeFromTrackingMergedFrames
(
other
)
;
return
true
;
}
nsDisplayStickyPosition
:
:
nsDisplayStickyPosition
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
ActiveScrolledRoot
*
aActiveScrolledRoot
)
:
nsDisplayOwnLayer
(
aBuilder
aFrame
aList
aActiveScrolledRoot
)
{
MOZ_COUNT_CTOR
(
nsDisplayStickyPosition
)
;
mClip
=
nullptr
;
}
void
nsDisplayStickyPosition
:
:
SetClipChain
(
const
DisplayItemClipChain
*
aClipChain
)
{
mClipChain
=
aClipChain
;
MOZ_ASSERT
(
!
mClip
"
There
should
never
be
a
clip
on
this
item
because
no
clip
moves
with
it
.
"
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
nsDisplayStickyPosition
:
:
~
nsDisplayStickyPosition
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayStickyPosition
)
;
}
#
endif
already_AddRefed
<
Layer
>
nsDisplayStickyPosition
:
:
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
{
RefPtr
<
Layer
>
layer
=
nsDisplayOwnLayer
:
:
BuildLayer
(
aBuilder
aManager
aContainerParameters
)
;
StickyScrollContainer
*
stickyScrollContainer
=
StickyScrollContainer
:
:
GetStickyScrollContainerForFrame
(
mFrame
)
;
if
(
!
stickyScrollContainer
)
{
return
layer
.
forget
(
)
;
}
nsIFrame
*
scrollFrame
=
do_QueryFrame
(
stickyScrollContainer
-
>
ScrollFrame
(
)
)
;
nsPresContext
*
presContext
=
scrollFrame
-
>
PresContext
(
)
;
nsSize
scrollFrameSize
=
scrollFrame
-
>
GetSize
(
)
;
if
(
scrollFrame
=
=
presContext
-
>
PresShell
(
)
-
>
GetRootScrollFrame
(
)
&
&
presContext
-
>
PresShell
(
)
-
>
IsScrollPositionClampingScrollPortSizeSet
(
)
)
{
scrollFrameSize
=
presContext
-
>
PresShell
(
)
-
>
GetScrollPositionClampingScrollPortSize
(
)
;
}
nsLayoutUtils
:
:
SetFixedPositionLayerData
(
layer
scrollFrame
nsRect
(
scrollFrame
-
>
GetOffsetToCrossDoc
(
ReferenceFrame
(
)
)
scrollFrameSize
)
mFrame
presContext
aContainerParameters
)
;
ViewID
scrollId
=
nsLayoutUtils
:
:
FindOrCreateIDFor
(
stickyScrollContainer
-
>
ScrollFrame
(
)
-
>
GetScrolledFrame
(
)
-
>
GetContent
(
)
)
;
float
factor
=
presContext
-
>
AppUnitsPerDevPixel
(
)
;
nsRect
outer
;
nsRect
inner
;
stickyScrollContainer
-
>
GetScrollRanges
(
mFrame
&
outer
&
inner
)
;
LayerRect
stickyOuter
(
NSAppUnitsToFloatPixels
(
outer
.
x
factor
)
*
aContainerParameters
.
mXScale
NSAppUnitsToFloatPixels
(
outer
.
y
factor
)
*
aContainerParameters
.
mYScale
NSAppUnitsToFloatPixels
(
outer
.
width
factor
)
*
aContainerParameters
.
mXScale
NSAppUnitsToFloatPixels
(
outer
.
height
factor
)
*
aContainerParameters
.
mYScale
)
;
LayerRect
stickyInner
(
NSAppUnitsToFloatPixels
(
inner
.
x
factor
)
*
aContainerParameters
.
mXScale
NSAppUnitsToFloatPixels
(
inner
.
y
factor
)
*
aContainerParameters
.
mYScale
NSAppUnitsToFloatPixels
(
inner
.
width
factor
)
*
aContainerParameters
.
mXScale
NSAppUnitsToFloatPixels
(
inner
.
height
factor
)
*
aContainerParameters
.
mYScale
)
;
layer
-
>
SetStickyPositionData
(
scrollId
stickyOuter
stickyInner
)
;
return
layer
.
forget
(
)
;
}
bool
nsDisplayStickyPosition
:
:
TryMerge
(
nsDisplayItem
*
aItem
)
{
if
(
aItem
-
>
GetType
(
)
!
=
TYPE_STICKY_POSITION
)
return
false
;
nsDisplayStickyPosition
*
other
=
static_cast
<
nsDisplayStickyPosition
*
>
(
aItem
)
;
if
(
other
-
>
mFrame
!
=
mFrame
)
return
false
;
if
(
aItem
-
>
GetClipChain
(
)
!
=
GetClipChain
(
)
)
return
false
;
MergeFromTrackingMergedFrames
(
other
)
;
return
true
;
}
nsDisplayScrollInfoLayer
:
:
nsDisplayScrollInfoLayer
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aScrolledFrame
nsIFrame
*
aScrollFrame
)
:
nsDisplayWrapList
(
aBuilder
aScrollFrame
)
mScrollFrame
(
aScrollFrame
)
mScrolledFrame
(
aScrolledFrame
)
mScrollParentId
(
aBuilder
-
>
GetCurrentScrollParentId
(
)
)
{
#
ifdef
NS_BUILD_REFCNT_LOGGING
MOZ_COUNT_CTOR
(
nsDisplayScrollInfoLayer
)
;
#
endif
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
nsDisplayScrollInfoLayer
:
:
~
nsDisplayScrollInfoLayer
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayScrollInfoLayer
)
;
}
#
endif
already_AddRefed
<
Layer
>
nsDisplayScrollInfoLayer
:
:
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
{
ContainerLayerParameters
params
=
aContainerParameters
;
if
(
mScrolledFrame
-
>
GetContent
(
)
&
&
nsLayoutUtils
:
:
HasCriticalDisplayPort
(
mScrolledFrame
-
>
GetContent
(
)
)
)
{
params
.
mInLowPrecisionDisplayPort
=
true
;
}
return
aManager
-
>
GetLayerBuilder
(
)
-
>
BuildContainerLayerFor
(
aBuilder
aManager
mFrame
this
&
mList
params
nullptr
FrameLayerBuilder
:
:
CONTAINER_ALLOW_PULL_BACKGROUND_COLOR
)
;
}
LayerState
nsDisplayScrollInfoLayer
:
:
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
{
return
LAYER_ACTIVE_EMPTY
;
}
UniquePtr
<
ScrollMetadata
>
nsDisplayScrollInfoLayer
:
:
ComputeScrollMetadata
(
Layer
*
aLayer
const
ContainerLayerParameters
&
aContainerParameters
)
{
ContainerLayerParameters
params
=
aContainerParameters
;
if
(
mScrolledFrame
-
>
GetContent
(
)
&
&
nsLayoutUtils
:
:
HasCriticalDisplayPort
(
mScrolledFrame
-
>
GetContent
(
)
)
)
{
params
.
mInLowPrecisionDisplayPort
=
true
;
}
nsRect
viewport
=
mScrollFrame
-
>
GetRect
(
)
-
mScrollFrame
-
>
GetPosition
(
)
+
mScrollFrame
-
>
GetOffsetToCrossDoc
(
ReferenceFrame
(
)
)
;
ScrollMetadata
metadata
=
nsLayoutUtils
:
:
ComputeScrollMetadata
(
mScrolledFrame
mScrollFrame
mScrollFrame
-
>
GetContent
(
)
ReferenceFrame
(
)
aLayer
mScrollParentId
viewport
Nothing
(
)
false
params
)
;
metadata
.
GetMetrics
(
)
.
SetIsScrollInfoLayer
(
true
)
;
return
UniquePtr
<
ScrollMetadata
>
(
new
ScrollMetadata
(
metadata
)
)
;
}
void
nsDisplayScrollInfoLayer
:
:
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
{
aStream
<
<
"
(
scrollframe
"
<
<
mScrollFrame
<
<
"
scrolledFrame
"
<
<
mScrolledFrame
<
<
"
)
"
;
}
nsDisplayZoom
:
:
nsDisplayZoom
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
int32_t
aAPD
int32_t
aParentAPD
uint32_t
aFlags
)
:
nsDisplaySubDocument
(
aBuilder
aFrame
aList
aFlags
)
mAPD
(
aAPD
)
mParentAPD
(
aParentAPD
)
{
MOZ_COUNT_CTOR
(
nsDisplayZoom
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
nsDisplayZoom
:
:
~
nsDisplayZoom
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayZoom
)
;
}
#
endif
nsRect
nsDisplayZoom
:
:
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
{
nsRect
bounds
=
nsDisplaySubDocument
:
:
GetBounds
(
aBuilder
aSnap
)
;
*
aSnap
=
false
;
return
bounds
.
ScaleToOtherAppUnitsRoundOut
(
mAPD
mParentAPD
)
;
}
void
nsDisplayZoom
:
:
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
{
nsRect
rect
;
if
(
aRect
.
width
=
=
1
&
&
aRect
.
height
=
=
1
)
{
rect
.
MoveTo
(
aRect
.
TopLeft
(
)
.
ScaleToOtherAppUnits
(
mParentAPD
mAPD
)
)
;
rect
.
width
=
rect
.
height
=
1
;
}
else
{
rect
=
aRect
.
ScaleToOtherAppUnitsRoundOut
(
mParentAPD
mAPD
)
;
}
mList
.
HitTest
(
aBuilder
rect
aState
aOutFrames
)
;
}
bool
nsDisplayZoom
:
:
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
{
nsRegion
visibleRegion
;
visibleRegion
.
And
(
*
aVisibleRegion
mVisibleRect
)
;
visibleRegion
=
visibleRegion
.
ScaleToOtherAppUnitsRoundOut
(
mParentAPD
mAPD
)
;
nsRegion
originalVisibleRegion
=
visibleRegion
;
nsRect
transformedVisibleRect
=
mVisibleRect
.
ScaleToOtherAppUnitsRoundOut
(
mParentAPD
mAPD
)
;
bool
retval
;
bool
usingDisplayPort
=
UseDisplayPortForViewport
(
aBuilder
mFrame
)
;
if
(
!
(
mFlags
&
GENERATE_SCROLLABLE_LAYER
)
|
|
!
usingDisplayPort
)
{
retval
=
mList
.
ComputeVisibilityForSublist
(
aBuilder
&
visibleRegion
transformedVisibleRect
)
;
}
else
{
retval
=
nsDisplaySubDocument
:
:
ComputeVisibility
(
aBuilder
&
visibleRegion
)
;
}
nsRegion
removed
;
removed
.
Sub
(
originalVisibleRegion
visibleRegion
)
;
removed
=
removed
.
ScaleToOtherAppUnitsRoundIn
(
mAPD
mParentAPD
)
;
aBuilder
-
>
SubtractFromVisibleRegion
(
aVisibleRegion
removed
)
;
return
retval
;
}
#
undef
UNIFIED_CONTINUATIONS
#
undef
DEBUG_HIT
nsDisplayTransform
:
:
nsDisplayTransform
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
nsRect
&
aChildrenVisibleRect
ComputeTransformFunction
aTransformGetter
uint32_t
aIndex
)
:
nsDisplayItem
(
aBuilder
aFrame
)
mStoredList
(
aBuilder
aFrame
aList
)
mTransformGetter
(
aTransformGetter
)
mAnimatedGeometryRootForChildren
(
mAnimatedGeometryRoot
)
mAnimatedGeometryRootForScrollMetadata
(
mAnimatedGeometryRoot
)
mChildrenVisibleRect
(
aChildrenVisibleRect
)
mIndex
(
aIndex
)
mNoExtendContext
(
false
)
mIsTransformSeparator
(
false
)
mTransformPreserves3DInited
(
false
)
mAllowAsyncAnimation
(
false
)
{
MOZ_COUNT_CTOR
(
nsDisplayTransform
)
;
MOZ_ASSERT
(
aFrame
"
Must
have
a
frame
!
"
)
;
Init
(
aBuilder
)
;
}
void
nsDisplayTransform
:
:
SetReferenceFrameToAncestor
(
nsDisplayListBuilder
*
aBuilder
)
{
if
(
mFrame
=
=
aBuilder
-
>
RootReferenceFrame
(
)
)
{
return
;
}
nsIFrame
*
outerFrame
=
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
mFrame
)
;
mReferenceFrame
=
aBuilder
-
>
FindReferenceFrameFor
(
outerFrame
)
;
mToReferenceFrame
=
mFrame
-
>
GetOffsetToCrossDoc
(
mReferenceFrame
)
;
if
(
nsLayoutUtils
:
:
IsFixedPosFrameInDisplayPort
(
mFrame
)
)
{
mAnimatedGeometryRoot
=
mAnimatedGeometryRootForChildren
;
}
else
if
(
mFrame
-
>
StyleDisplay
(
)
-
>
mPosition
=
=
NS_STYLE_POSITION_STICKY
&
&
IsStickyFrameActive
(
aBuilder
mFrame
nullptr
)
)
{
mAnimatedGeometryRoot
=
mAnimatedGeometryRootForChildren
;
}
else
if
(
mAnimatedGeometryRoot
-
>
mParentAGR
)
{
mAnimatedGeometryRootForScrollMetadata
=
mAnimatedGeometryRoot
-
>
mParentAGR
;
if
(
!
MayBeAnimated
(
aBuilder
)
)
{
mAnimatedGeometryRoot
=
mAnimatedGeometryRoot
-
>
mParentAGR
;
}
}
mVisibleRect
=
aBuilder
-
>
GetDirtyRect
(
)
+
mToReferenceFrame
;
}
void
nsDisplayTransform
:
:
Init
(
nsDisplayListBuilder
*
aBuilder
)
{
mHasBounds
=
false
;
mStoredList
.
SetClipChain
(
nullptr
)
;
mStoredList
.
SetVisibleRect
(
mChildrenVisibleRect
)
;
}
nsDisplayTransform
:
:
nsDisplayTransform
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
nsRect
&
aChildrenVisibleRect
uint32_t
aIndex
bool
aAllowAsyncAnimation
)
:
nsDisplayItem
(
aBuilder
aFrame
)
mStoredList
(
aBuilder
aFrame
aList
)
mTransformGetter
(
nullptr
)
mAnimatedGeometryRootForChildren
(
mAnimatedGeometryRoot
)
mAnimatedGeometryRootForScrollMetadata
(
mAnimatedGeometryRoot
)
mChildrenVisibleRect
(
aChildrenVisibleRect
)
mIndex
(
aIndex
)
mNoExtendContext
(
false
)
mIsTransformSeparator
(
false
)
mTransformPreserves3DInited
(
false
)
mAllowAsyncAnimation
(
aAllowAsyncAnimation
)
{
MOZ_COUNT_CTOR
(
nsDisplayTransform
)
;
MOZ_ASSERT
(
aFrame
"
Must
have
a
frame
!
"
)
;
SetReferenceFrameToAncestor
(
aBuilder
)
;
Init
(
aBuilder
)
;
UpdateBoundsFor3D
(
aBuilder
)
;
}
nsDisplayTransform
:
:
nsDisplayTransform
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayItem
*
aItem
const
nsRect
&
aChildrenVisibleRect
uint32_t
aIndex
)
:
nsDisplayItem
(
aBuilder
aFrame
)
mStoredList
(
aBuilder
aFrame
aItem
)
mTransformGetter
(
nullptr
)
mAnimatedGeometryRootForChildren
(
mAnimatedGeometryRoot
)
mAnimatedGeometryRootForScrollMetadata
(
mAnimatedGeometryRoot
)
mChildrenVisibleRect
(
aChildrenVisibleRect
)
mIndex
(
aIndex
)
mNoExtendContext
(
false
)
mIsTransformSeparator
(
false
)
mTransformPreserves3DInited
(
false
)
mAllowAsyncAnimation
(
false
)
{
MOZ_COUNT_CTOR
(
nsDisplayTransform
)
;
MOZ_ASSERT
(
aFrame
"
Must
have
a
frame
!
"
)
;
SetReferenceFrameToAncestor
(
aBuilder
)
;
Init
(
aBuilder
)
;
}
nsDisplayTransform
:
:
nsDisplayTransform
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
nsRect
&
aChildrenVisibleRect
const
Matrix4x4
&
aTransform
uint32_t
aIndex
)
:
nsDisplayItem
(
aBuilder
aFrame
)
mStoredList
(
aBuilder
aFrame
aList
)
mTransform
(
aTransform
)
mTransformGetter
(
nullptr
)
mAnimatedGeometryRootForChildren
(
mAnimatedGeometryRoot
)
mAnimatedGeometryRootForScrollMetadata
(
mAnimatedGeometryRoot
)
mChildrenVisibleRect
(
aChildrenVisibleRect
)
mIndex
(
aIndex
)
mNoExtendContext
(
false
)
mIsTransformSeparator
(
true
)
mTransformPreserves3DInited
(
false
)
mAllowAsyncAnimation
(
false
)
{
MOZ_COUNT_CTOR
(
nsDisplayTransform
)
;
MOZ_ASSERT
(
aFrame
"
Must
have
a
frame
!
"
)
;
Init
(
aBuilder
)
;
UpdateBoundsFor3D
(
aBuilder
)
;
}
Point3D
nsDisplayTransform
:
:
GetDeltaToTransformOrigin
(
const
nsIFrame
*
aFrame
float
aAppUnitsPerPixel
const
nsRect
*
aBoundsOverride
)
{
NS_PRECONDITION
(
aFrame
"
Can
'
t
get
delta
for
a
null
frame
!
"
)
;
NS_PRECONDITION
(
aFrame
-
>
IsTransformed
(
)
|
|
aFrame
-
>
BackfaceIsHidden
(
)
|
|
aFrame
-
>
Combines3DTransformWithAncestors
(
)
"
Shouldn
'
t
get
a
delta
for
an
untransformed
frame
!
"
)
;
if
(
!
aFrame
-
>
IsTransformed
(
)
)
{
return
Point3D
(
)
;
}
const
nsStyleDisplay
*
display
=
aFrame
-
>
StyleDisplay
(
)
;
TransformReferenceBox
refBox
;
if
(
aBoundsOverride
&
&
!
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_SVG_LAYOUT
)
)
{
refBox
.
Init
(
aBoundsOverride
-
>
Size
(
)
)
;
}
else
{
refBox
.
Init
(
aFrame
)
;
}
float
transformOrigin
[
2
]
;
TransformReferenceBox
:
:
DimensionGetter
dimensionGetter
[
]
=
{
&
TransformReferenceBox
:
:
Width
&
TransformReferenceBox
:
:
Height
}
;
TransformReferenceBox
:
:
DimensionGetter
offsetGetter
[
]
=
{
&
TransformReferenceBox
:
:
X
&
TransformReferenceBox
:
:
Y
}
;
for
(
uint8_t
index
=
0
;
index
<
2
;
+
+
index
)
{
const
nsStyleCoord
&
originValue
=
display
-
>
mTransformOrigin
[
index
]
;
if
(
originValue
.
GetUnit
(
)
=
=
eStyleUnit_Calc
)
{
const
nsStyleCoord
:
:
Calc
*
calc
=
originValue
.
GetCalcValue
(
)
;
transformOrigin
[
index
]
=
NSAppUnitsToFloatPixels
(
(
refBox
.
*
dimensionGetter
[
index
]
)
(
)
aAppUnitsPerPixel
)
*
calc
-
>
mPercent
+
NSAppUnitsToFloatPixels
(
calc
-
>
mLength
aAppUnitsPerPixel
)
;
}
else
if
(
originValue
.
GetUnit
(
)
=
=
eStyleUnit_Percent
)
{
transformOrigin
[
index
]
=
NSAppUnitsToFloatPixels
(
(
refBox
.
*
dimensionGetter
[
index
]
)
(
)
aAppUnitsPerPixel
)
*
originValue
.
GetPercentValue
(
)
;
}
else
{
MOZ_ASSERT
(
originValue
.
GetUnit
(
)
=
=
eStyleUnit_Coord
"
unexpected
unit
"
)
;
transformOrigin
[
index
]
=
NSAppUnitsToFloatPixels
(
originValue
.
GetCoordValue
(
)
aAppUnitsPerPixel
)
;
}
if
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_SVG_LAYOUT
)
{
transformOrigin
[
index
]
+
=
NSAppUnitsToFloatPixels
(
(
refBox
.
*
offsetGetter
[
index
]
)
(
)
aAppUnitsPerPixel
)
;
}
}
return
Point3D
(
transformOrigin
[
0
]
transformOrigin
[
1
]
NSAppUnitsToFloatPixels
(
display
-
>
mTransformOrigin
[
2
]
.
GetCoordValue
(
)
aAppUnitsPerPixel
)
)
;
}
bool
nsDisplayTransform
:
:
ComputePerspectiveMatrix
(
const
nsIFrame
*
aFrame
float
aAppUnitsPerPixel
Matrix4x4
&
aOutMatrix
)
{
NS_PRECONDITION
(
aFrame
"
Can
'
t
get
delta
for
a
null
frame
!
"
)
;
NS_PRECONDITION
(
aFrame
-
>
IsTransformed
(
)
|
|
aFrame
-
>
BackfaceIsHidden
(
)
|
|
aFrame
-
>
Combines3DTransformWithAncestors
(
)
"
Shouldn
'
t
get
a
delta
for
an
untransformed
frame
!
"
)
;
NS_PRECONDITION
(
aOutMatrix
.
IsIdentity
(
)
"
Must
have
a
blank
output
matrix
"
)
;
if
(
!
aFrame
-
>
IsTransformed
(
)
)
{
return
false
;
}
nsIFrame
*
cbFrame
=
aFrame
-
>
GetContainingBlock
(
nsIFrame
:
:
SKIP_SCROLLED_FRAME
)
;
if
(
!
cbFrame
)
{
return
false
;
}
const
nsStyleDisplay
*
cbDisplay
=
cbFrame
-
>
StyleDisplay
(
)
;
if
(
cbDisplay
-
>
mChildPerspective
.
GetUnit
(
)
!
=
eStyleUnit_Coord
)
{
return
false
;
}
nscoord
perspective
=
cbDisplay
-
>
mChildPerspective
.
GetCoordValue
(
)
;
if
(
perspective
<
0
)
{
return
true
;
}
TransformReferenceBox
refBox
(
cbFrame
)
;
Point3D
perspectiveOrigin
;
gfx
:
:
Float
*
coords
[
2
]
=
{
&
perspectiveOrigin
.
x
&
perspectiveOrigin
.
y
}
;
TransformReferenceBox
:
:
DimensionGetter
dimensionGetter
[
]
=
{
&
TransformReferenceBox
:
:
Width
&
TransformReferenceBox
:
:
Height
}
;
for
(
uint8_t
index
=
0
;
index
<
2
;
+
+
index
)
{
const
nsStyleCoord
&
coord
=
cbDisplay
-
>
mPerspectiveOrigin
[
index
]
;
if
(
coord
.
GetUnit
(
)
=
=
eStyleUnit_Calc
)
{
const
nsStyleCoord
:
:
Calc
*
calc
=
coord
.
GetCalcValue
(
)
;
*
coords
[
index
]
=
NSAppUnitsToFloatPixels
(
(
refBox
.
*
dimensionGetter
[
index
]
)
(
)
aAppUnitsPerPixel
)
*
calc
-
>
mPercent
+
NSAppUnitsToFloatPixels
(
calc
-
>
mLength
aAppUnitsPerPixel
)
;
}
else
if
(
coord
.
GetUnit
(
)
=
=
eStyleUnit_Percent
)
{
*
coords
[
index
]
=
NSAppUnitsToFloatPixels
(
(
refBox
.
*
dimensionGetter
[
index
]
)
(
)
aAppUnitsPerPixel
)
*
coord
.
GetPercentValue
(
)
;
}
else
{
MOZ_ASSERT
(
coord
.
GetUnit
(
)
=
=
eStyleUnit_Coord
"
unexpected
unit
"
)
;
*
coords
[
index
]
=
NSAppUnitsToFloatPixels
(
coord
.
GetCoordValue
(
)
aAppUnitsPerPixel
)
;
}
}
nsPoint
frameToCbOffset
=
-
aFrame
-
>
GetOffsetTo
(
cbFrame
)
;
Point3D
frameToCbGfxOffset
(
NSAppUnitsToFloatPixels
(
frameToCbOffset
.
x
aAppUnitsPerPixel
)
NSAppUnitsToFloatPixels
(
frameToCbOffset
.
y
aAppUnitsPerPixel
)
0
.
0f
)
;
perspectiveOrigin
+
=
frameToCbGfxOffset
;
Float
perspectivePx
=
std
:
:
max
(
NSAppUnitsToFloatPixels
(
perspective
aAppUnitsPerPixel
)
std
:
:
numeric_limits
<
Float
>
:
:
epsilon
(
)
)
;
aOutMatrix
.
_34
=
-
1
.
0
/
perspectivePx
;
aOutMatrix
.
ChangeBasis
(
perspectiveOrigin
)
;
return
true
;
}
nsDisplayTransform
:
:
FrameTransformProperties
:
:
FrameTransformProperties
(
const
nsIFrame
*
aFrame
float
aAppUnitsPerPixel
const
nsRect
*
aBoundsOverride
)
:
mFrame
(
aFrame
)
mTransformList
(
aFrame
-
>
StyleDisplay
(
)
-
>
mSpecifiedTransform
)
mToTransformOrigin
(
GetDeltaToTransformOrigin
(
aFrame
aAppUnitsPerPixel
aBoundsOverride
)
)
{
}
Matrix4x4
nsDisplayTransform
:
:
GetResultingTransformMatrix
(
const
FrameTransformProperties
&
aProperties
const
nsPoint
&
aOrigin
float
aAppUnitsPerPixel
uint32_t
aFlags
const
nsRect
*
aBoundsOverride
)
{
return
GetResultingTransformMatrixInternal
(
aProperties
aOrigin
aAppUnitsPerPixel
aFlags
aBoundsOverride
)
;
}
Matrix4x4
nsDisplayTransform
:
:
GetResultingTransformMatrix
(
const
nsIFrame
*
aFrame
const
nsPoint
&
aOrigin
float
aAppUnitsPerPixel
uint32_t
aFlags
const
nsRect
*
aBoundsOverride
)
{
FrameTransformProperties
props
(
aFrame
aAppUnitsPerPixel
aBoundsOverride
)
;
return
GetResultingTransformMatrixInternal
(
props
aOrigin
aAppUnitsPerPixel
aFlags
aBoundsOverride
)
;
}
Matrix4x4
nsDisplayTransform
:
:
GetResultingTransformMatrixInternal
(
const
FrameTransformProperties
&
aProperties
const
nsPoint
&
aOrigin
float
aAppUnitsPerPixel
uint32_t
aFlags
const
nsRect
*
aBoundsOverride
)
{
const
nsIFrame
*
frame
=
aProperties
.
mFrame
;
NS_ASSERTION
(
frame
|
|
!
(
aFlags
&
INCLUDE_PERSPECTIVE
)
"
Must
have
a
frame
to
compute
perspective
!
"
)
;
TransformReferenceBox
refBox
;
if
(
aBoundsOverride
&
&
(
!
frame
|
|
!
(
frame
-
>
GetStateBits
(
)
&
NS_FRAME_SVG_LAYOUT
)
)
)
{
refBox
.
Init
(
aBoundsOverride
-
>
Size
(
)
)
;
}
else
{
refBox
.
Init
(
frame
)
;
}
RuleNodeCacheConditions
dummy
;
bool
dummyBool
;
Matrix4x4
result
;
Matrix
svgTransform
parentsChildrenOnlyTransform
;
bool
hasSVGTransforms
=
frame
&
&
frame
-
>
IsSVGTransformed
(
&
svgTransform
&
parentsChildrenOnlyTransform
)
;
if
(
aProperties
.
mTransformList
)
{
result
=
nsStyleTransformMatrix
:
:
ReadTransforms
(
aProperties
.
mTransformList
-
>
mHead
frame
?
frame
-
>
StyleContext
(
)
:
nullptr
frame
?
frame
-
>
PresContext
(
)
:
nullptr
dummy
refBox
aAppUnitsPerPixel
&
dummyBool
)
;
}
else
if
(
hasSVGTransforms
)
{
float
pixelsPerCSSPx
=
frame
-
>
PresContext
(
)
-
>
AppUnitsPerCSSPixel
(
)
/
aAppUnitsPerPixel
;
svgTransform
.
_31
*
=
pixelsPerCSSPx
;
svgTransform
.
_32
*
=
pixelsPerCSSPx
;
result
=
Matrix4x4
:
:
From2D
(
svgTransform
)
;
}
result
.
ChangeBasis
(
aProperties
.
mToTransformOrigin
)
;
bool
parentHasChildrenOnlyTransform
=
hasSVGTransforms
&
&
!
parentsChildrenOnlyTransform
.
IsIdentity
(
)
;
if
(
parentHasChildrenOnlyTransform
)
{
float
pixelsPerCSSPx
=
frame
-
>
PresContext
(
)
-
>
AppUnitsPerCSSPixel
(
)
/
aAppUnitsPerPixel
;
parentsChildrenOnlyTransform
.
_31
*
=
pixelsPerCSSPx
;
parentsChildrenOnlyTransform
.
_32
*
=
pixelsPerCSSPx
;
Point3D
frameOffset
(
NSAppUnitsToFloatPixels
(
-
frame
-
>
GetPosition
(
)
.
x
aAppUnitsPerPixel
)
NSAppUnitsToFloatPixels
(
-
frame
-
>
GetPosition
(
)
.
y
aAppUnitsPerPixel
)
0
)
;
Matrix4x4
parentsChildrenOnlyTransform3D
=
Matrix4x4
:
:
From2D
(
parentsChildrenOnlyTransform
)
.
ChangeBasis
(
frameOffset
)
;
result
*
=
parentsChildrenOnlyTransform3D
;
}
Matrix4x4
perspectiveMatrix
;
bool
hasPerspective
=
aFlags
&
INCLUDE_PERSPECTIVE
;
if
(
hasPerspective
)
{
if
(
ComputePerspectiveMatrix
(
frame
aAppUnitsPerPixel
perspectiveMatrix
)
)
{
result
*
=
perspectiveMatrix
;
}
}
if
(
(
aFlags
&
INCLUDE_PRESERVE3D_ANCESTORS
)
&
&
frame
&
&
frame
-
>
Combines3DTransformWithAncestors
(
)
)
{
NS_ASSERTION
(
frame
-
>
GetParent
(
)
&
&
frame
-
>
GetParent
(
)
-
>
IsTransformed
(
)
&
&
frame
-
>
GetParent
(
)
-
>
Extend3DContext
(
)
"
Preserve3D
mismatch
!
"
)
;
FrameTransformProperties
props
(
frame
-
>
GetParent
(
)
aAppUnitsPerPixel
nullptr
)
;
uint32_t
flags
=
aFlags
&
(
INCLUDE_PRESERVE3D_ANCESTORS
|
INCLUDE_PERSPECTIVE
)
;
if
(
frame
-
>
IsTransformed
(
)
)
{
nsLayoutUtils
:
:
PostTranslate
(
result
frame
-
>
GetPosition
(
)
aAppUnitsPerPixel
!
hasSVGTransforms
)
;
}
Matrix4x4
parent
=
GetResultingTransformMatrixInternal
(
props
nsPoint
(
0
0
)
aAppUnitsPerPixel
flags
nullptr
)
;
result
=
result
*
parent
;
}
if
(
aFlags
&
OFFSET_BY_ORIGIN
)
{
nsLayoutUtils
:
:
PostTranslate
(
result
aOrigin
aAppUnitsPerPixel
!
hasSVGTransforms
)
;
}
return
result
;
}
bool
nsDisplayOpacity
:
:
CanUseAsyncAnimations
(
nsDisplayListBuilder
*
aBuilder
)
{
if
(
ActiveLayerTracker
:
:
IsStyleAnimated
(
aBuilder
mFrame
eCSSProperty_opacity
)
)
{
return
true
;
}
EffectCompositor
:
:
SetPerformanceWarning
(
mFrame
eCSSProperty_opacity
AnimationPerformanceWarning
(
AnimationPerformanceWarning
:
:
Type
:
:
OpacityFrameInactive
)
)
;
return
false
;
}
bool
nsDisplayTransform
:
:
CanUseAsyncAnimations
(
nsDisplayListBuilder
*
aBuilder
)
{
return
mAllowAsyncAnimation
;
}
static
nsRect
ComputePartialPrerenderArea
(
const
nsRect
&
aDirtyRect
const
nsRect
&
aOverflow
const
nsSize
&
aPrerenderSize
)
{
nscoord
xExcess
=
aPrerenderSize
.
width
-
aDirtyRect
.
width
;
nscoord
yExcess
=
aPrerenderSize
.
height
-
aDirtyRect
.
height
;
nsRect
result
=
aDirtyRect
;
result
.
Inflate
(
xExcess
/
2
yExcess
/
2
)
;
return
result
.
MoveInsideAndClamp
(
aOverflow
)
;
}
auto
nsDisplayTransform
:
:
ShouldPrerenderTransformedContent
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsRect
*
aDirtyRect
)
-
>
PrerenderDecision
{
if
(
!
ActiveLayerTracker
:
:
IsStyleMaybeAnimated
(
aFrame
eCSSProperty_transform
)
&
&
!
EffectCompositor
:
:
HasAnimationsForCompositor
(
aFrame
eCSSProperty_transform
)
)
{
EffectCompositor
:
:
SetPerformanceWarning
(
aFrame
eCSSProperty_transform
AnimationPerformanceWarning
(
AnimationPerformanceWarning
:
:
Type
:
:
TransformFrameInactive
)
)
;
return
NoPrerender
;
}
nsRect
overflow
=
aFrame
-
>
GetVisualOverflowRectRelativeToSelf
(
)
;
if
(
aDirtyRect
-
>
Contains
(
overflow
)
)
{
return
FullPrerender
;
}
float
viewportRatioX
=
gfxPrefs
:
:
AnimationPrerenderViewportRatioLimitX
(
)
;
float
viewportRatioY
=
gfxPrefs
:
:
AnimationPrerenderViewportRatioLimitY
(
)
;
uint32_t
absoluteLimitX
=
gfxPrefs
:
:
AnimationPrerenderAbsoluteLimitX
(
)
;
uint32_t
absoluteLimitY
=
gfxPrefs
:
:
AnimationPrerenderAbsoluteLimitY
(
)
;
nsSize
refSize
=
aBuilder
-
>
RootReferenceFrame
(
)
-
>
GetSize
(
)
;
nsSize
relativeLimit
(
nscoord
(
refSize
.
width
*
viewportRatioX
)
nscoord
(
refSize
.
height
*
viewportRatioY
)
)
;
nsSize
absoluteLimit
(
aFrame
-
>
PresContext
(
)
-
>
DevPixelsToAppUnits
(
absoluteLimitX
)
aFrame
-
>
PresContext
(
)
-
>
DevPixelsToAppUnits
(
absoluteLimitY
)
)
;
nsSize
maxSize
=
Min
(
relativeLimit
absoluteLimit
)
;
gfxSize
scale
=
nsLayoutUtils
:
:
GetTransformToAncestorScale
(
aFrame
)
;
nsSize
frameSize
=
nsSize
(
overflow
.
Size
(
)
.
width
*
scale
.
width
overflow
.
Size
(
)
.
height
*
scale
.
height
)
;
if
(
frameSize
<
=
maxSize
)
{
*
aDirtyRect
=
overflow
;
return
FullPrerender
;
}
else
if
(
gfxPrefs
:
:
PartiallyPrerenderAnimatedContent
(
)
)
{
*
aDirtyRect
=
ComputePartialPrerenderArea
(
*
aDirtyRect
overflow
maxSize
)
;
return
PartialPrerender
;
}
EffectCompositor
:
:
SetPerformanceWarning
(
aFrame
eCSSProperty_transform
AnimationPerformanceWarning
(
AnimationPerformanceWarning
:
:
Type
:
:
ContentTooLarge
{
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
frameSize
.
width
)
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
frameSize
.
height
)
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
relativeLimit
.
width
)
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
relativeLimit
.
height
)
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
absoluteLimit
.
width
)
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
absoluteLimit
.
height
)
}
)
)
;
return
NoPrerender
;
}
static
bool
IsFrameVisible
(
nsIFrame
*
aFrame
const
Matrix4x4
&
aMatrix
)
{
if
(
aMatrix
.
IsSingular
(
)
)
{
return
false
;
}
if
(
aFrame
-
>
BackfaceIsHidden
(
)
&
&
aMatrix
.
IsBackfaceVisible
(
)
)
{
return
false
;
}
return
true
;
}
const
Matrix4x4
&
nsDisplayTransform
:
:
GetTransform
(
)
{
if
(
mTransform
.
IsIdentity
(
)
)
{
float
scale
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
Point3D
newOrigin
=
Point3D
(
NSAppUnitsToFloatPixels
(
mToReferenceFrame
.
x
scale
)
NSAppUnitsToFloatPixels
(
mToReferenceFrame
.
y
scale
)
0
.
0f
)
;
if
(
mTransformGetter
)
{
mTransform
=
mTransformGetter
(
mFrame
scale
)
;
mTransform
.
ChangeBasis
(
newOrigin
.
x
newOrigin
.
y
newOrigin
.
z
)
;
}
else
if
(
!
mIsTransformSeparator
)
{
DebugOnly
<
bool
>
isReference
=
mFrame
-
>
IsTransformed
(
)
|
|
mFrame
-
>
Combines3DTransformWithAncestors
(
)
|
|
mFrame
-
>
Extend3DContext
(
)
;
MOZ_ASSERT
(
isReference
)
;
mTransform
=
GetResultingTransformMatrix
(
mFrame
ToReferenceFrame
(
)
scale
INCLUDE_PERSPECTIVE
|
OFFSET_BY_ORIGIN
)
;
}
}
return
mTransform
;
}
Matrix4x4
nsDisplayTransform
:
:
GetTransformForRendering
(
)
{
if
(
!
mFrame
-
>
HasPerspective
(
)
|
|
mTransformGetter
|
|
mIsTransformSeparator
)
{
return
GetTransform
(
)
;
}
MOZ_ASSERT
(
!
mTransformGetter
)
;
float
scale
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
return
GetResultingTransformMatrix
(
mFrame
ToReferenceFrame
(
)
scale
0
)
;
}
const
Matrix4x4
&
nsDisplayTransform
:
:
GetAccumulatedPreserved3DTransform
(
nsDisplayListBuilder
*
aBuilder
)
{
MOZ_ASSERT
(
!
mFrame
-
>
Extend3DContext
(
)
|
|
IsLeafOf3DContext
(
)
)
;
if
(
!
mTransformPreserves3DInited
)
{
mTransformPreserves3DInited
=
true
;
if
(
!
IsLeafOf3DContext
(
)
)
{
mTransformPreserves3D
=
GetTransform
(
)
;
return
mTransformPreserves3D
;
}
const
nsIFrame
*
establisher
;
for
(
establisher
=
mFrame
;
establisher
&
&
establisher
-
>
Combines3DTransformWithAncestors
(
)
;
establisher
=
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
establisher
)
)
{
}
const
nsIFrame
*
establisherReference
=
aBuilder
-
>
FindReferenceFrameFor
(
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
establisher
)
)
;
nsPoint
offset
=
establisher
-
>
GetOffsetToCrossDoc
(
establisherReference
)
;
float
scale
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
uint32_t
flags
=
INCLUDE_PRESERVE3D_ANCESTORS
|
INCLUDE_PERSPECTIVE
|
OFFSET_BY_ORIGIN
;
mTransformPreserves3D
=
GetResultingTransformMatrix
(
mFrame
offset
scale
flags
)
;
}
return
mTransformPreserves3D
;
}
bool
nsDisplayTransform
:
:
ShouldBuildLayerEvenIfInvisible
(
nsDisplayListBuilder
*
aBuilder
)
{
return
MayBeAnimated
(
aBuilder
)
|
|
mFrame
-
>
Combines3DTransformWithAncestors
(
)
;
}
already_AddRefed
<
Layer
>
nsDisplayTransform
:
:
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
{
const
Matrix4x4
&
newTransformMatrix
=
GetTransformForRendering
(
)
;
uint32_t
flags
=
FrameLayerBuilder
:
:
CONTAINER_ALLOW_PULL_BACKGROUND_COLOR
;
RefPtr
<
ContainerLayer
>
container
=
aManager
-
>
GetLayerBuilder
(
)
-
>
BuildContainerLayerFor
(
aBuilder
aManager
mFrame
this
mStoredList
.
GetChildren
(
)
aContainerParameters
&
newTransformMatrix
flags
)
;
if
(
!
container
)
{
return
nullptr
;
}
if
(
mFrame
-
>
Extend3DContext
(
)
&
&
!
mNoExtendContext
)
{
container
-
>
SetContentFlags
(
container
-
>
GetContentFlags
(
)
|
Layer
:
:
CONTENT_EXTEND_3D_CONTEXT
)
;
}
else
{
container
-
>
SetContentFlags
(
container
-
>
GetContentFlags
(
)
&
~
Layer
:
:
CONTENT_EXTEND_3D_CONTEXT
)
;
}
nsDisplayListBuilder
:
:
AddAnimationsAndTransitionsToLayer
(
container
aBuilder
this
mFrame
eCSSProperty_transform
)
;
if
(
mAllowAsyncAnimation
&
&
MayBeAnimated
(
aBuilder
)
)
{
container
-
>
SetUserData
(
nsIFrame
:
:
LayerIsPrerenderedDataKey
(
)
nullptr
)
;
container
-
>
SetContentFlags
(
container
-
>
GetContentFlags
(
)
|
Layer
:
:
CONTENT_MAY_CHANGE_TRANSFORM
)
;
}
else
{
container
-
>
RemoveUserData
(
nsIFrame
:
:
LayerIsPrerenderedDataKey
(
)
)
;
container
-
>
SetContentFlags
(
container
-
>
GetContentFlags
(
)
&
~
Layer
:
:
CONTENT_MAY_CHANGE_TRANSFORM
)
;
}
return
container
.
forget
(
)
;
}
bool
nsDisplayTransform
:
:
MayBeAnimated
(
nsDisplayListBuilder
*
aBuilder
)
{
if
(
EffectCompositor
:
:
HasAnimationsForCompositor
(
mFrame
eCSSProperty_transform
)
|
|
(
ActiveLayerTracker
:
:
IsStyleAnimated
(
aBuilder
mFrame
eCSSProperty_transform
)
&
&
!
IsItemTooSmallForActiveLayer
(
mFrame
)
)
)
{
return
true
;
}
return
false
;
}
nsDisplayItem
:
:
LayerState
nsDisplayTransform
:
:
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
{
if
(
!
GetTransform
(
)
.
Is2D
(
)
|
|
mFrame
-
>
Combines3DTransformWithAncestors
(
)
|
|
mIsTransformSeparator
)
{
return
LAYER_ACTIVE_FORCE
;
}
if
(
MayBeAnimated
(
aBuilder
)
)
{
return
LAYER_ACTIVE_FORCE
;
}
return
RequiredLayerStateForChildren
(
aBuilder
aManager
aParameters
*
mStoredList
.
GetChildren
(
)
mAnimatedGeometryRootForChildren
)
;
}
bool
nsDisplayTransform
:
:
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
{
nsRect
untransformedVisibleRect
;
if
(
!
UntransformVisibleRect
(
aBuilder
&
untransformedVisibleRect
)
)
{
untransformedVisibleRect
=
mFrame
-
>
GetVisualOverflowRectRelativeToSelf
(
)
;
}
nsRegion
untransformedVisible
=
untransformedVisibleRect
;
mStoredList
.
RecomputeVisibility
(
aBuilder
&
untransformedVisible
)
;
return
true
;
}
#
ifdef
DEBUG_HIT
#
include
<
time
.
h
>
#
endif
void
nsDisplayTransform
:
:
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
{
if
(
aState
-
>
mInPreserves3D
)
{
mStoredList
.
HitTest
(
aBuilder
aRect
aState
aOutFrames
)
;
return
;
}
float
factor
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
Matrix4x4
matrix
=
GetAccumulatedPreserved3DTransform
(
aBuilder
)
;
if
(
!
IsFrameVisible
(
mFrame
matrix
)
)
{
return
;
}
matrix
.
Invert
(
)
;
nsRect
resultingRect
;
if
(
aRect
.
width
=
=
1
&
&
aRect
.
height
=
=
1
)
{
Point4D
point
=
matrix
.
ProjectPoint
(
Point
(
NSAppUnitsToFloatPixels
(
aRect
.
x
factor
)
NSAppUnitsToFloatPixels
(
aRect
.
y
factor
)
)
)
;
if
(
!
point
.
HasPositiveWCoord
(
)
)
{
return
;
}
Point
point2d
=
point
.
As2DPoint
(
)
;
resultingRect
=
nsRect
(
NSFloatPixelsToAppUnits
(
float
(
point2d
.
x
)
factor
)
NSFloatPixelsToAppUnits
(
float
(
point2d
.
y
)
factor
)
1
1
)
;
}
else
{
Rect
originalRect
(
NSAppUnitsToFloatPixels
(
aRect
.
x
factor
)
NSAppUnitsToFloatPixels
(
aRect
.
y
factor
)
NSAppUnitsToFloatPixels
(
aRect
.
width
factor
)
NSAppUnitsToFloatPixels
(
aRect
.
height
factor
)
)
;
bool
snap
;
nsRect
childBounds
=
mStoredList
.
GetBounds
(
aBuilder
&
snap
)
;
Rect
childGfxBounds
(
NSAppUnitsToFloatPixels
(
childBounds
.
x
factor
)
NSAppUnitsToFloatPixels
(
childBounds
.
y
factor
)
NSAppUnitsToFloatPixels
(
childBounds
.
width
factor
)
NSAppUnitsToFloatPixels
(
childBounds
.
height
factor
)
)
;
Rect
rect
=
matrix
.
ProjectRectBounds
(
originalRect
childGfxBounds
)
;
resultingRect
=
nsRect
(
NSFloatPixelsToAppUnits
(
float
(
rect
.
X
(
)
)
factor
)
NSFloatPixelsToAppUnits
(
float
(
rect
.
Y
(
)
)
factor
)
NSFloatPixelsToAppUnits
(
float
(
rect
.
Width
(
)
)
factor
)
NSFloatPixelsToAppUnits
(
float
(
rect
.
Height
(
)
)
factor
)
)
;
}
if
(
resultingRect
.
IsEmpty
(
)
)
{
return
;
}
#
ifdef
DEBUG_HIT
printf
(
"
Frame
:
%
p
\
n
"
dynamic_cast
<
void
*
>
(
mFrame
)
)
;
printf
(
"
Untransformed
point
:
(
%
f
%
f
)
\
n
"
resultingRect
.
X
(
)
resultingRect
.
Y
(
)
)
;
uint32_t
originalFrameCount
=
aOutFrames
.
Length
(
)
;
#
endif
mStoredList
.
HitTest
(
aBuilder
resultingRect
aState
aOutFrames
)
;
#
ifdef
DEBUG_HIT
if
(
originalFrameCount
!
=
aOutFrames
.
Length
(
)
)
printf
(
"
Hit
!
Time
:
%
f
first
frame
:
%
p
\
n
"
static_cast
<
double
>
(
clock
(
)
)
dynamic_cast
<
void
*
>
(
aOutFrames
.
ElementAt
(
0
)
)
)
;
printf
(
"
=
=
=
end
of
hit
test
=
=
=
\
n
"
)
;
#
endif
}
float
nsDisplayTransform
:
:
GetHitDepthAtPoint
(
nsDisplayListBuilder
*
aBuilder
const
nsPoint
&
aPoint
)
{
float
factor
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
Matrix4x4
matrix
=
GetAccumulatedPreserved3DTransform
(
aBuilder
)
;
NS_ASSERTION
(
IsFrameVisible
(
mFrame
matrix
)
"
We
can
'
t
have
hit
a
frame
that
isn
'
t
visible
!
"
)
;
Matrix4x4
inverse
=
matrix
;
inverse
.
Invert
(
)
;
Point4D
point
=
inverse
.
ProjectPoint
(
Point
(
NSAppUnitsToFloatPixels
(
aPoint
.
x
factor
)
NSAppUnitsToFloatPixels
(
aPoint
.
y
factor
)
)
)
;
Point
point2d
=
point
.
As2DPoint
(
)
;
Point3D
transformed
=
matrix
.
TransformPoint
(
Point3D
(
point2d
.
x
point2d
.
y
0
)
)
;
return
transformed
.
z
;
}
nsRect
nsDisplayTransform
:
:
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
{
*
aSnap
=
false
;
if
(
mHasBounds
)
{
return
mBounds
;
}
if
(
mFrame
-
>
Extend3DContext
(
)
&
&
!
mIsTransformSeparator
)
{
return
nsRect
(
)
;
}
nsRect
untransformedBounds
=
mStoredList
.
GetBounds
(
aBuilder
aSnap
)
;
float
factor
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
mBounds
=
nsLayoutUtils
:
:
MatrixTransformRect
(
untransformedBounds
GetTransform
(
)
factor
)
;
mHasBounds
=
true
;
return
mBounds
;
}
void
nsDisplayTransform
:
:
ComputeBounds
(
nsDisplayListBuilder
*
aBuilder
)
{
MOZ_ASSERT
(
mFrame
-
>
Extend3DContext
(
)
|
|
IsLeafOf3DContext
(
)
)
;
nsDisplayListBuilder
:
:
AutoAccumulateTransform
accTransform
(
aBuilder
)
;
accTransform
.
Accumulate
(
GetTransform
(
)
)
;
if
(
!
IsLeafOf3DContext
(
)
)
{
mStoredList
.
DoUpdateBoundsPreserves3D
(
aBuilder
)
;
}
bool
snap
;
nsRect
untransformedBounds
=
mStoredList
.
GetBounds
(
aBuilder
&
snap
)
;
float
factor
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
nsRect
rect
=
nsLayoutUtils
:
:
MatrixTransformRect
(
untransformedBounds
accTransform
.
GetCurrentTransform
(
)
factor
)
;
aBuilder
-
>
AccumulateRect
(
rect
)
;
}
nsRegion
nsDisplayTransform
:
:
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
{
*
aSnap
=
false
;
nsRect
untransformedVisible
;
if
(
!
UntransformVisibleRect
(
aBuilder
&
untransformedVisible
)
)
{
return
nsRegion
(
)
;
}
const
Matrix4x4
&
matrix
=
GetTransform
(
)
;
nsRegion
result
;
Matrix
matrix2d
;
bool
tmpSnap
;
if
(
matrix
.
Is2D
(
&
matrix2d
)
&
&
matrix2d
.
PreservesAxisAlignedRectangles
(
)
&
&
mStoredList
.
GetOpaqueRegion
(
aBuilder
&
tmpSnap
)
.
Contains
(
untransformedVisible
)
)
{
result
=
mVisibleRect
.
Intersect
(
GetBounds
(
aBuilder
&
tmpSnap
)
)
;
}
return
result
;
}
Maybe
<
nscolor
>
nsDisplayTransform
:
:
IsUniform
(
nsDisplayListBuilder
*
aBuilder
)
{
nsRect
untransformedVisible
;
if
(
!
UntransformVisibleRect
(
aBuilder
&
untransformedVisible
)
)
{
return
Nothing
(
)
;
}
const
Matrix4x4
&
matrix
=
GetTransform
(
)
;
Matrix
matrix2d
;
if
(
matrix
.
Is2D
(
&
matrix2d
)
&
&
matrix2d
.
PreservesAxisAlignedRectangles
(
)
&
&
mStoredList
.
GetVisibleRect
(
)
.
Contains
(
untransformedVisible
)
)
{
return
mStoredList
.
IsUniform
(
aBuilder
)
;
}
return
Nothing
(
)
;
}
#
ifndef
UNIFIED_CONTINUATIONS
bool
nsDisplayTransform
:
:
TryMerge
(
nsDisplayItem
*
aItem
)
{
return
false
;
}
#
else
bool
nsDisplayTransform
:
:
TryMerge
(
nsDisplayItem
*
aItem
)
{
NS_PRECONDITION
(
aItem
"
Why
did
you
try
merging
with
a
null
item
?
"
)
;
if
(
aItem
-
>
GetType
(
)
!
=
TYPE_TRANSFORM
)
return
false
;
if
(
aItem
-
>
Frame
(
)
-
>
GetContent
(
)
!
=
mFrame
-
>
GetContent
(
)
)
return
false
;
if
(
aItem
-
>
GetClipChain
(
)
!
=
GetClipChain
(
)
)
return
false
;
mStoredList
.
MergeFromTrackingMergedFrames
(
&
static_cast
<
nsDisplayTransform
*
>
(
aItem
)
-
>
mStoredList
)
;
return
true
;
}
#
endif
nsRect
nsDisplayTransform
:
:
TransformRect
(
const
nsRect
&
aUntransformedBounds
const
nsIFrame
*
aFrame
const
nsRect
*
aBoundsOverride
)
{
NS_PRECONDITION
(
aFrame
"
Can
'
t
take
the
transform
based
on
a
null
frame
!
"
)
;
float
factor
=
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
uint32_t
flags
=
INCLUDE_PERSPECTIVE
|
OFFSET_BY_ORIGIN
|
INCLUDE_PRESERVE3D_ANCESTORS
;
return
nsLayoutUtils
:
:
MatrixTransformRect
(
aUntransformedBounds
GetResultingTransformMatrix
(
aFrame
nsPoint
(
0
0
)
factor
flags
aBoundsOverride
)
factor
)
;
}
bool
nsDisplayTransform
:
:
UntransformRect
(
const
nsRect
&
aTransformedBounds
const
nsRect
&
aChildBounds
const
nsIFrame
*
aFrame
nsRect
*
aOutRect
)
{
NS_PRECONDITION
(
aFrame
"
Can
'
t
take
the
transform
based
on
a
null
frame
!
"
)
;
float
factor
=
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
uint32_t
flags
=
INCLUDE_PERSPECTIVE
|
OFFSET_BY_ORIGIN
|
INCLUDE_PRESERVE3D_ANCESTORS
;
Matrix4x4
transform
=
GetResultingTransformMatrix
(
aFrame
nsPoint
(
0
0
)
factor
flags
)
;
if
(
transform
.
IsSingular
(
)
)
{
return
false
;
}
RectDouble
result
(
NSAppUnitsToFloatPixels
(
aTransformedBounds
.
x
factor
)
NSAppUnitsToFloatPixels
(
aTransformedBounds
.
y
factor
)
NSAppUnitsToFloatPixels
(
aTransformedBounds
.
width
factor
)
NSAppUnitsToFloatPixels
(
aTransformedBounds
.
height
factor
)
)
;
RectDouble
childGfxBounds
(
NSAppUnitsToFloatPixels
(
aChildBounds
.
x
factor
)
NSAppUnitsToFloatPixels
(
aChildBounds
.
y
factor
)
NSAppUnitsToFloatPixels
(
aChildBounds
.
width
factor
)
NSAppUnitsToFloatPixels
(
aChildBounds
.
height
factor
)
)
;
result
=
transform
.
Inverse
(
)
.
ProjectRectBounds
(
result
childGfxBounds
)
;
*
aOutRect
=
nsLayoutUtils
:
:
RoundGfxRectToAppRect
(
ThebesRect
(
result
)
factor
)
;
return
true
;
}
bool
nsDisplayTransform
:
:
UntransformVisibleRect
(
nsDisplayListBuilder
*
aBuilder
nsRect
*
aOutRect
)
{
const
Matrix4x4
&
matrix
=
GetTransform
(
)
;
if
(
matrix
.
IsSingular
(
)
)
return
false
;
float
factor
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
RectDouble
result
(
NSAppUnitsToFloatPixels
(
mVisibleRect
.
x
factor
)
NSAppUnitsToFloatPixels
(
mVisibleRect
.
y
factor
)
NSAppUnitsToFloatPixels
(
mVisibleRect
.
width
factor
)
NSAppUnitsToFloatPixels
(
mVisibleRect
.
height
factor
)
)
;
bool
snap
;
nsRect
childBounds
=
mStoredList
.
GetBounds
(
aBuilder
&
snap
)
;
RectDouble
childGfxBounds
(
NSAppUnitsToFloatPixels
(
childBounds
.
x
factor
)
NSAppUnitsToFloatPixels
(
childBounds
.
y
factor
)
NSAppUnitsToFloatPixels
(
childBounds
.
width
factor
)
NSAppUnitsToFloatPixels
(
childBounds
.
height
factor
)
)
;
result
=
matrix
.
Inverse
(
)
.
ProjectRectBounds
(
result
childGfxBounds
)
;
*
aOutRect
=
nsLayoutUtils
:
:
RoundGfxRectToAppRect
(
ThebesRect
(
result
)
factor
)
;
return
true
;
}
void
nsDisplayTransform
:
:
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
{
AppendToString
(
aStream
GetTransform
(
)
)
;
if
(
IsTransformSeparator
(
)
)
{
aStream
<
<
"
transform
-
separator
"
;
}
if
(
IsLeafOf3DContext
(
)
)
{
aStream
<
<
"
3d
-
context
-
leaf
"
;
}
if
(
mFrame
-
>
Extend3DContext
(
)
)
{
aStream
<
<
"
extends
-
3d
-
context
"
;
}
if
(
mFrame
-
>
Combines3DTransformWithAncestors
(
)
)
{
aStream
<
<
"
combines
-
3d
-
with
-
ancestors
"
;
}
}
nsDisplayPerspective
:
:
nsDisplayPerspective
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aTransformFrame
nsIFrame
*
aPerspectiveFrame
nsDisplayList
*
aList
)
:
nsDisplayItem
(
aBuilder
aPerspectiveFrame
)
mList
(
aBuilder
aPerspectiveFrame
aList
)
mTransformFrame
(
aTransformFrame
)
mIndex
(
aBuilder
-
>
AllocatePerspectiveItemIndex
(
)
)
{
MOZ_ASSERT
(
mList
.
GetChildren
(
)
-
>
Count
(
)
=
=
1
)
;
MOZ_ASSERT
(
mList
.
GetChildren
(
)
-
>
GetTop
(
)
-
>
GetType
(
)
=
=
TYPE_TRANSFORM
)
;
}
already_AddRefed
<
Layer
>
nsDisplayPerspective
:
:
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
{
float
appUnitsPerPixel
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
Matrix4x4
perspectiveMatrix
;
DebugOnly
<
bool
>
hasPerspective
=
nsDisplayTransform
:
:
ComputePerspectiveMatrix
(
mTransformFrame
appUnitsPerPixel
perspectiveMatrix
)
;
MOZ_ASSERT
(
hasPerspective
"
Why
did
we
create
nsDisplayPerspective
?
"
)
;
if
(
!
mList
.
GetChildren
(
)
-
>
GetTop
(
)
)
{
return
nullptr
;
}
nsDisplayTransform
*
transform
=
static_cast
<
nsDisplayTransform
*
>
(
mList
.
GetChildren
(
)
-
>
GetTop
(
)
)
;
Point3D
newOrigin
=
Point3D
(
NSAppUnitsToFloatPixels
(
transform
-
>
ToReferenceFrame
(
)
.
x
appUnitsPerPixel
)
NSAppUnitsToFloatPixels
(
transform
-
>
ToReferenceFrame
(
)
.
y
appUnitsPerPixel
)
0
.
0f
)
;
Point3D
roundedOrigin
(
NS_round
(
newOrigin
.
x
)
NS_round
(
newOrigin
.
y
)
0
)
;
perspectiveMatrix
.
PostTranslate
(
roundedOrigin
)
;
RefPtr
<
ContainerLayer
>
container
=
aManager
-
>
GetLayerBuilder
(
)
-
>
BuildContainerLayerFor
(
aBuilder
aManager
mFrame
this
mList
.
GetChildren
(
)
aContainerParameters
&
perspectiveMatrix
0
)
;
if
(
!
container
)
{
return
nullptr
;
}
container
-
>
SetContentFlags
(
container
-
>
GetContentFlags
(
)
|
Layer
:
:
CONTENT_EXTEND_3D_CONTEXT
)
;
container
-
>
SetTransformIsPerspective
(
true
)
;
return
container
.
forget
(
)
;
}
LayerState
nsDisplayPerspective
:
:
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
{
return
LAYER_ACTIVE_FORCE
;
}
int32_t
nsDisplayPerspective
:
:
ZIndex
(
)
const
{
return
ZIndexForFrame
(
mTransformFrame
)
;
}
nsDisplayItemGeometry
*
nsCharClipDisplayItem
:
:
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
{
return
new
nsCharClipGeometry
(
this
aBuilder
)
;
}
void
nsCharClipDisplayItem
:
:
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
{
const
nsCharClipGeometry
*
geometry
=
static_cast
<
const
nsCharClipGeometry
*
>
(
aGeometry
)
;
bool
snap
;
nsRect
newRect
=
geometry
-
>
mBounds
;
nsRect
oldRect
=
GetBounds
(
aBuilder
&
snap
)
;
if
(
mVisIStartEdge
!
=
geometry
-
>
mVisIStartEdge
|
|
mVisIEndEdge
!
=
geometry
-
>
mVisIEndEdge
|
|
!
oldRect
.
IsEqualInterior
(
newRect
)
|
|
!
geometry
-
>
mBorderRect
.
IsEqualInterior
(
GetBorderRect
(
)
)
)
{
aInvalidRegion
-
>
Or
(
oldRect
newRect
)
;
}
}
nsDisplaySVGEffects
:
:
nsDisplaySVGEffects
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
bool
aHandleOpacity
const
ActiveScrolledRoot
*
aActiveScrolledRoot
)
:
nsDisplayWrapList
(
aBuilder
aFrame
aList
aActiveScrolledRoot
)
mEffectsBounds
(
aFrame
-
>
GetVisualOverflowRectRelativeToSelf
(
)
)
mHandleOpacity
(
aHandleOpacity
)
{
MOZ_COUNT_CTOR
(
nsDisplaySVGEffects
)
;
}
nsDisplaySVGEffects
:
:
nsDisplaySVGEffects
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
bool
aHandleOpacity
)
:
nsDisplayWrapList
(
aBuilder
aFrame
aList
)
mEffectsBounds
(
aFrame
-
>
GetVisualOverflowRectRelativeToSelf
(
)
)
mHandleOpacity
(
aHandleOpacity
)
{
MOZ_COUNT_CTOR
(
nsDisplaySVGEffects
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
nsDisplaySVGEffects
:
:
~
nsDisplaySVGEffects
(
)
{
MOZ_COUNT_DTOR
(
nsDisplaySVGEffects
)
;
}
#
endif
nsRegion
nsDisplaySVGEffects
:
:
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
{
*
aSnap
=
false
;
return
nsRegion
(
)
;
}
void
nsDisplaySVGEffects
:
:
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
{
nsPoint
rectCenter
(
aRect
.
x
+
aRect
.
width
/
2
aRect
.
y
+
aRect
.
height
/
2
)
;
if
(
nsSVGIntegrationUtils
:
:
HitTestFrameForEffects
(
mFrame
rectCenter
-
ToReferenceFrame
(
)
)
)
{
mList
.
HitTest
(
aBuilder
aRect
aState
aOutFrames
)
;
}
}
gfxRect
nsDisplaySVGEffects
:
:
BBoxInUserSpace
(
)
const
{
return
nsSVGUtils
:
:
GetBBox
(
mFrame
)
;
}
gfxPoint
nsDisplaySVGEffects
:
:
UserSpaceOffset
(
)
const
{
return
nsSVGUtils
:
:
FrameSpaceInCSSPxToUserSpaceOffset
(
mFrame
)
;
}
void
nsDisplaySVGEffects
:
:
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
{
const
nsDisplaySVGEffectGeometry
*
geometry
=
static_cast
<
const
nsDisplaySVGEffectGeometry
*
>
(
aGeometry
)
;
bool
snap
;
nsRect
bounds
=
GetBounds
(
aBuilder
&
snap
)
;
if
(
geometry
-
>
mFrameOffsetToReferenceFrame
!
=
ToReferenceFrame
(
)
|
|
geometry
-
>
mUserSpaceOffset
!
=
UserSpaceOffset
(
)
|
|
!
geometry
-
>
mBBox
.
IsEqualInterior
(
BBoxInUserSpace
(
)
)
)
{
aInvalidRegion
-
>
Or
(
bounds
geometry
-
>
mBounds
)
;
}
}
bool
nsDisplaySVGEffects
:
:
ValidateSVGFrame
(
)
{
const
nsIContent
*
content
=
mFrame
-
>
GetContent
(
)
;
bool
hasSVGLayout
=
(
mFrame
-
>
GetStateBits
(
)
&
NS_FRAME_SVG_LAYOUT
)
;
if
(
hasSVGLayout
)
{
nsISVGChildFrame
*
svgChildFrame
=
do_QueryFrame
(
mFrame
)
;
if
(
!
svgChildFrame
|
|
!
mFrame
-
>
GetContent
(
)
-
>
IsSVGElement
(
)
)
{
NS_ASSERTION
(
false
"
why
?
"
)
;
return
false
;
}
if
(
!
static_cast
<
const
nsSVGElement
*
>
(
content
)
-
>
HasValidDimensions
(
)
)
{
return
false
;
}
}
return
true
;
}
static
IntRect
ComputeClipExtsInDeviceSpace
(
gfxContext
&
aCtx
)
{
gfxContextMatrixAutoSaveRestore
matRestore
(
&
aCtx
)
;
aCtx
.
SetMatrix
(
gfxMatrix
(
)
)
;
gfxRect
clippedFrameSurfaceRect
=
aCtx
.
GetClipExtents
(
)
;
clippedFrameSurfaceRect
.
RoundOut
(
)
;
IntRect
result
;
ToRect
(
clippedFrameSurfaceRect
)
.
ToIntRect
(
&
result
)
;
return
mozilla
:
:
gfx
:
:
Factory
:
:
CheckSurfaceSize
(
result
.
Size
(
)
)
?
result
:
IntRect
(
)
;
}
typedef
nsSVGIntegrationUtils
:
:
PaintFramesParams
PaintFramesParams
;
static
nsPoint
ComputeOffsetToUserSpace
(
const
PaintFramesParams
&
aParams
)
{
nsIFrame
*
frame
=
aParams
.
frame
;
nsPoint
offsetToBoundingBox
=
aParams
.
builder
-
>
ToReferenceFrame
(
frame
)
-
nsSVGIntegrationUtils
:
:
GetOffsetToBoundingBox
(
frame
)
;
if
(
!
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
)
{
offsetToBoundingBox
=
nsPoint
(
frame
-
>
PresContext
(
)
-
>
RoundAppUnitsToNearestDevPixels
(
offsetToBoundingBox
.
x
)
frame
-
>
PresContext
(
)
-
>
RoundAppUnitsToNearestDevPixels
(
offsetToBoundingBox
.
y
)
)
;
}
gfxPoint
toUserSpaceGfx
=
nsSVGUtils
:
:
FrameSpaceInCSSPxToUserSpaceOffset
(
frame
)
;
nsPoint
toUserSpace
=
nsPoint
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
float
(
toUserSpaceGfx
.
x
)
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
float
(
toUserSpaceGfx
.
y
)
)
)
;
return
(
offsetToBoundingBox
-
toUserSpace
)
;
}
static
void
ComputeMaskGeometry
(
PaintFramesParams
&
aParams
)
{
nsIFrame
*
firstFrame
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
aParams
.
frame
)
;
const
nsStyleSVGReset
*
svgReset
=
firstFrame
-
>
StyleSVGReset
(
)
;
nsSVGEffects
:
:
EffectProperties
effectProperties
=
nsSVGEffects
:
:
GetEffectProperties
(
firstFrame
)
;
nsTArray
<
nsSVGMaskFrame
*
>
maskFrames
=
effectProperties
.
GetMaskFrames
(
)
;
if
(
maskFrames
.
Length
(
)
=
=
0
)
{
return
;
}
gfxContext
&
ctx
=
aParams
.
ctx
;
nsIFrame
*
frame
=
aParams
.
frame
;
nsPoint
offsetToUserSpace
=
ComputeOffsetToUserSpace
(
aParams
)
;
gfxPoint
devPixelOffsetToUserSpace
=
nsLayoutUtils
:
:
PointToGfxPoint
(
offsetToUserSpace
frame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
gfxContextMatrixAutoSaveRestore
matSR
(
&
ctx
)
;
ctx
.
SetMatrix
(
ctx
.
CurrentMatrix
(
)
.
Translate
(
devPixelOffsetToUserSpace
)
)
;
int32_t
appUnitsPerDevPixel
=
frame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
nsRect
userSpaceBorderArea
=
aParams
.
borderArea
-
offsetToUserSpace
;
nsRect
userSpaceDirtyRect
=
aParams
.
dirtyRect
-
offsetToUserSpace
;
gfxRect
maskInUserSpace
;
for
(
size_t
i
=
0
;
i
<
maskFrames
.
Length
(
)
;
i
+
+
)
{
nsSVGMaskFrame
*
maskFrame
=
maskFrames
[
i
]
;
gfxRect
currentMaskSurfaceRect
;
if
(
maskFrame
)
{
currentMaskSurfaceRect
=
maskFrame
-
>
GetMaskArea
(
aParams
.
frame
)
;
}
else
{
nsCSSRendering
:
:
ImageLayerClipState
clipState
;
nsCSSRendering
:
:
GetImageLayerClip
(
svgReset
-
>
mMask
.
mLayers
[
i
]
frame
*
frame
-
>
StyleBorder
(
)
userSpaceBorderArea
userSpaceDirtyRect
false
appUnitsPerDevPixel
&
clipState
)
;
currentMaskSurfaceRect
=
clipState
.
mDirtyRectInDevPx
;
}
maskInUserSpace
=
maskInUserSpace
.
Union
(
currentMaskSurfaceRect
)
;
}
ctx
.
Save
(
)
;
if
(
!
maskInUserSpace
.
IsEmpty
(
)
)
{
ctx
.
Clip
(
maskInUserSpace
)
;
}
IntRect
result
=
ComputeClipExtsInDeviceSpace
(
ctx
)
;
ctx
.
Restore
(
)
;
aParams
.
maskRect
=
result
;
}
nsDisplayMask
:
:
nsDisplayMask
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
bool
aHandleOpacity
const
ActiveScrolledRoot
*
aActiveScrolledRoot
)
:
nsDisplaySVGEffects
(
aBuilder
aFrame
aList
aHandleOpacity
aActiveScrolledRoot
)
{
MOZ_COUNT_CTOR
(
nsDisplayMask
)
;
nsPresContext
*
presContext
=
mFrame
-
>
PresContext
(
)
;
uint32_t
flags
=
aBuilder
-
>
GetBackgroundPaintFlags
(
)
|
nsCSSRendering
:
:
PAINTBG_MASK_IMAGE
;
const
nsStyleSVGReset
*
svgReset
=
aFrame
-
>
StyleSVGReset
(
)
;
NS_FOR_VISIBLE_IMAGE_LAYERS_BACK_TO_FRONT
(
i
svgReset
-
>
mMask
)
{
bool
isTransformedFixed
;
nsBackgroundLayerState
state
=
nsCSSRendering
:
:
PrepareImageLayer
(
presContext
aFrame
flags
mFrame
-
>
GetRectRelativeToSelf
(
)
mFrame
-
>
GetRectRelativeToSelf
(
)
svgReset
-
>
mMask
.
mLayers
[
i
]
&
isTransformedFixed
)
;
mDestRects
.
AppendElement
(
state
.
mDestArea
)
;
}
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
nsDisplayMask
:
:
~
nsDisplayMask
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayMask
)
;
}
#
endif
bool
nsDisplayMask
:
:
TryMerge
(
nsDisplayItem
*
aItem
)
{
if
(
aItem
-
>
GetType
(
)
!
=
TYPE_MASK
)
return
false
;
if
(
aItem
-
>
Frame
(
)
-
>
GetContent
(
)
!
=
mFrame
-
>
GetContent
(
)
)
{
return
false
;
}
if
(
aItem
-
>
GetClipChain
(
)
!
=
GetClipChain
(
)
)
{
return
false
;
}
const
nsStyleSVGReset
*
style
=
mFrame
-
>
StyleSVGReset
(
)
;
if
(
style
-
>
mMask
.
HasLayerWithImage
(
)
)
{
return
false
;
}
nsDisplayMask
*
other
=
static_cast
<
nsDisplayMask
*
>
(
aItem
)
;
MergeFromTrackingMergedFrames
(
other
)
;
mEffectsBounds
.
UnionRect
(
mEffectsBounds
other
-
>
mEffectsBounds
+
other
-
>
mFrame
-
>
GetOffsetTo
(
mFrame
)
)
;
return
true
;
}
already_AddRefed
<
Layer
>
nsDisplayMask
:
:
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
{
if
(
!
ValidateSVGFrame
(
)
)
{
return
nullptr
;
}
if
(
mFrame
-
>
StyleEffects
(
)
-
>
mOpacity
=
=
0
.
0f
&
&
mHandleOpacity
)
{
return
nullptr
;
}
nsIFrame
*
firstFrame
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
mFrame
)
;
nsSVGEffects
:
:
EffectProperties
effectProperties
=
nsSVGEffects
:
:
GetEffectProperties
(
firstFrame
)
;
if
(
effectProperties
.
HasInvalidClipPath
(
)
|
|
effectProperties
.
HasInvalidMask
(
)
)
{
return
nullptr
;
}
RefPtr
<
ContainerLayer
>
container
=
aManager
-
>
GetLayerBuilder
(
)
-
>
BuildContainerLayerFor
(
aBuilder
aManager
mFrame
this
&
mList
aContainerParameters
nullptr
)
;
return
container
.
forget
(
)
;
}
bool
nsDisplayMask
:
:
PaintMask
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aMaskContext
)
{
MOZ_ASSERT
(
aMaskContext
-
>
GetDrawTarget
(
)
-
>
GetFormat
(
)
=
=
SurfaceFormat
:
:
A8
)
;
nsRect
borderArea
=
nsRect
(
ToReferenceFrame
(
)
mFrame
-
>
GetSize
(
)
)
;
nsSVGIntegrationUtils
:
:
PaintFramesParams
params
(
*
aMaskContext
mFrame
mVisibleRect
borderArea
aBuilder
nullptr
mHandleOpacity
)
;
ComputeMaskGeometry
(
params
)
;
image
:
:
DrawResult
result
=
nsSVGIntegrationUtils
:
:
PaintMask
(
params
)
;
nsDisplayMaskGeometry
:
:
UpdateDrawResult
(
this
result
)
;
return
(
result
=
=
image
:
:
DrawResult
:
:
SUCCESS
)
?
true
:
false
;
}
LayerState
nsDisplayMask
:
:
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
{
if
(
ShouldPaintOnMaskLayer
(
aManager
)
)
{
return
RequiredLayerStateForChildren
(
aBuilder
aManager
aParameters
mList
GetAnimatedGeometryRoot
(
)
)
;
}
return
LAYER_SVG_EFFECTS
;
}
bool
nsDisplayMask
:
:
ShouldPaintOnMaskLayer
(
LayerManager
*
aManager
)
{
if
(
!
aManager
-
>
IsCompositingCheap
(
)
)
{
return
false
;
}
nsSVGUtils
:
:
MaskUsage
maskUsage
;
nsSVGUtils
:
:
DetermineMaskUsage
(
mFrame
mHandleOpacity
maskUsage
)
;
if
(
maskUsage
.
shouldApplyClipPath
)
{
return
false
;
}
if
(
!
nsSVGIntegrationUtils
:
:
IsMaskResourceReady
(
mFrame
)
)
{
return
false
;
}
if
(
gfxPrefs
:
:
DrawMaskLayer
(
)
)
{
return
false
;
}
return
true
;
}
bool
nsDisplayMask
:
:
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
{
nsRegion
childrenVisible
(
mVisibleRect
)
;
nsRect
r
=
mVisibleRect
.
Intersect
(
mList
.
GetClippedBoundsWithRespectToASR
(
aBuilder
mActiveScrolledRoot
)
)
;
mList
.
ComputeVisibilityForSublist
(
aBuilder
&
childrenVisible
r
)
;
return
true
;
}
void
nsDisplayMask
:
:
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
{
nsDisplaySVGEffects
:
:
ComputeInvalidationRegion
(
aBuilder
aGeometry
aInvalidRegion
)
;
const
nsDisplayMaskGeometry
*
geometry
=
static_cast
<
const
nsDisplayMaskGeometry
*
>
(
aGeometry
)
;
bool
snap
;
nsRect
bounds
=
GetBounds
(
aBuilder
&
snap
)
;
if
(
mDestRects
.
Length
(
)
!
=
geometry
-
>
mDestRects
.
Length
(
)
)
{
aInvalidRegion
-
>
Or
(
bounds
geometry
-
>
mBounds
)
;
}
else
{
for
(
size_t
i
=
0
;
i
<
mDestRects
.
Length
(
)
;
i
+
+
)
{
if
(
!
mDestRects
[
i
]
.
IsEqualInterior
(
geometry
-
>
mDestRects
[
i
]
)
)
{
aInvalidRegion
-
>
Or
(
bounds
geometry
-
>
mBounds
)
;
break
;
}
}
}
if
(
aBuilder
-
>
ShouldSyncDecodeImages
(
)
&
&
geometry
-
>
ShouldInvalidateToSyncDecodeImages
(
)
)
{
const
nsStyleSVGReset
*
svgReset
=
mFrame
-
>
StyleSVGReset
(
)
;
NS_FOR_VISIBLE_IMAGE_LAYERS_BACK_TO_FRONT
(
i
svgReset
-
>
mMask
)
{
const
nsStyleImage
&
image
=
svgReset
-
>
mMask
.
mLayers
[
i
]
.
mImage
;
if
(
image
.
GetType
(
)
=
=
eStyleImageType_Image
)
{
aInvalidRegion
-
>
Or
(
*
aInvalidRegion
bounds
)
;
break
;
}
}
}
}
void
nsDisplayMask
:
:
PaintAsLayer
(
nsDisplayListBuilder
*
aBuilder
nsRenderingContext
*
aCtx
LayerManager
*
aManager
)
{
MOZ_ASSERT
(
!
ShouldPaintOnMaskLayer
(
aManager
)
)
;
nsRect
borderArea
=
nsRect
(
ToReferenceFrame
(
)
mFrame
-
>
GetSize
(
)
)
;
nsSVGIntegrationUtils
:
:
PaintFramesParams
params
(
*
aCtx
-
>
ThebesContext
(
)
mFrame
mVisibleRect
borderArea
aBuilder
aManager
mHandleOpacity
)
;
gfxContext
*
context
=
aCtx
-
>
ThebesContext
(
)
;
context
-
>
Clip
(
NSRectToSnappedRect
(
mVisibleRect
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
*
aCtx
-
>
GetDrawTarget
(
)
)
)
;
ComputeMaskGeometry
(
params
)
;
image
:
:
DrawResult
result
=
nsSVGIntegrationUtils
:
:
PaintMaskAndClipPath
(
params
)
;
context
-
>
PopClip
(
)
;
nsDisplayMaskGeometry
:
:
UpdateDrawResult
(
this
result
)
;
}
#
ifdef
MOZ_DUMP_PAINTING
void
nsDisplayMask
:
:
PrintEffects
(
nsACString
&
aTo
)
{
nsIFrame
*
firstFrame
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
mFrame
)
;
nsSVGEffects
:
:
EffectProperties
effectProperties
=
nsSVGEffects
:
:
GetEffectProperties
(
firstFrame
)
;
nsSVGClipPathFrame
*
clipPathFrame
=
effectProperties
.
GetClipPathFrame
(
)
;
bool
first
=
true
;
aTo
+
=
"
effects
=
(
"
;
if
(
mFrame
-
>
StyleEffects
(
)
-
>
mOpacity
!
=
1
.
0f
&
&
mHandleOpacity
)
{
first
=
false
;
aTo
+
=
nsPrintfCString
(
"
opacity
(
%
f
)
"
mFrame
-
>
StyleEffects
(
)
-
>
mOpacity
)
;
}
if
(
clipPathFrame
)
{
if
(
!
first
)
{
aTo
+
=
"
"
;
}
aTo
+
=
nsPrintfCString
(
"
clip
(
%
s
)
"
clipPathFrame
-
>
IsTrivial
(
)
?
"
trivial
"
:
"
non
-
trivial
"
)
;
first
=
false
;
}
const
nsStyleSVGReset
*
style
=
mFrame
-
>
StyleSVGReset
(
)
;
if
(
style
-
>
HasClipPath
(
)
&
&
!
clipPathFrame
)
{
if
(
!
first
)
{
aTo
+
=
"
"
;
}
aTo
+
=
"
clip
(
basic
-
shape
)
"
;
first
=
false
;
}
nsTArray
<
nsSVGMaskFrame
*
>
masks
=
effectProperties
.
GetMaskFrames
(
)
;
if
(
!
masks
.
IsEmpty
(
)
&
&
masks
[
0
]
)
{
if
(
!
first
)
{
aTo
+
=
"
"
;
}
aTo
+
=
"
mask
"
;
}
aTo
+
=
"
)
"
;
}
#
endif
nsDisplayFilter
:
:
nsDisplayFilter
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
bool
aHandleOpacity
)
:
nsDisplaySVGEffects
(
aBuilder
aFrame
aList
aHandleOpacity
)
{
MOZ_COUNT_CTOR
(
nsDisplayFilter
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
nsDisplayFilter
:
:
~
nsDisplayFilter
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayFilter
)
;
}
#
endif
already_AddRefed
<
Layer
>
nsDisplayFilter
:
:
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
{
if
(
!
ValidateSVGFrame
(
)
)
{
return
nullptr
;
}
if
(
mFrame
-
>
StyleEffects
(
)
-
>
mOpacity
=
=
0
.
0f
&
&
mHandleOpacity
)
{
return
nullptr
;
}
nsIFrame
*
firstFrame
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
mFrame
)
;
nsSVGEffects
:
:
EffectProperties
effectProperties
=
nsSVGEffects
:
:
GetEffectProperties
(
firstFrame
)
;
if
(
effectProperties
.
HasInvalidFilter
(
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
effectProperties
.
mFilter
&
&
mFrame
-
>
StyleEffects
(
)
-
>
HasFilters
(
)
"
By
getting
here
we
must
have
valid
CSS
filters
.
"
)
;
ContainerLayerParameters
newContainerParameters
=
aContainerParameters
;
newContainerParameters
.
mDisableSubpixelAntialiasingInDescendants
=
true
;
RefPtr
<
ContainerLayer
>
container
=
aManager
-
>
GetLayerBuilder
(
)
-
>
BuildContainerLayerFor
(
aBuilder
aManager
mFrame
this
&
mList
newContainerParameters
nullptr
)
;
return
container
.
forget
(
)
;
}
bool
nsDisplayFilter
:
:
TryMerge
(
nsDisplayItem
*
aItem
)
{
if
(
aItem
-
>
GetType
(
)
!
=
TYPE_FILTER
)
{
return
false
;
}
if
(
aItem
-
>
Frame
(
)
-
>
GetContent
(
)
!
=
mFrame
-
>
GetContent
(
)
)
{
return
false
;
}
if
(
aItem
-
>
GetClipChain
(
)
!
=
GetClipChain
(
)
)
{
return
false
;
}
nsDisplayFilter
*
other
=
static_cast
<
nsDisplayFilter
*
>
(
aItem
)
;
MergeFromTrackingMergedFrames
(
other
)
;
mEffectsBounds
.
UnionRect
(
mEffectsBounds
other
-
>
mEffectsBounds
+
other
-
>
mFrame
-
>
GetOffsetTo
(
mFrame
)
)
;
return
true
;
}
LayerState
nsDisplayFilter
:
:
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
{
return
LAYER_SVG_EFFECTS
;
}
bool
nsDisplayFilter
:
:
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
{
nsPoint
offset
=
ToReferenceFrame
(
)
;
nsRect
dirtyRect
=
nsSVGIntegrationUtils
:
:
GetRequiredSourceForInvalidArea
(
mFrame
mVisibleRect
-
offset
)
+
offset
;
nsRegion
childrenVisible
(
dirtyRect
)
;
nsRect
r
=
dirtyRect
.
Intersect
(
mList
.
GetClippedBoundsWithRespectToASR
(
aBuilder
mActiveScrolledRoot
)
)
;
mList
.
ComputeVisibilityForSublist
(
aBuilder
&
childrenVisible
r
)
;
return
true
;
}
void
nsDisplayFilter
:
:
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
{
nsDisplaySVGEffects
:
:
ComputeInvalidationRegion
(
aBuilder
aGeometry
aInvalidRegion
)
;
const
nsDisplayFilterGeometry
*
geometry
=
static_cast
<
const
nsDisplayFilterGeometry
*
>
(
aGeometry
)
;
if
(
aBuilder
-
>
ShouldSyncDecodeImages
(
)
&
&
geometry
-
>
ShouldInvalidateToSyncDecodeImages
(
)
)
{
bool
snap
;
nsRect
bounds
=
GetBounds
(
aBuilder
&
snap
)
;
aInvalidRegion
-
>
Or
(
*
aInvalidRegion
bounds
)
;
}
}
void
nsDisplayFilter
:
:
PaintAsLayer
(
nsDisplayListBuilder
*
aBuilder
nsRenderingContext
*
aCtx
LayerManager
*
aManager
)
{
nsRect
borderArea
=
nsRect
(
ToReferenceFrame
(
)
mFrame
-
>
GetSize
(
)
)
;
nsSVGIntegrationUtils
:
:
PaintFramesParams
params
(
*
aCtx
-
>
ThebesContext
(
)
mFrame
mVisibleRect
borderArea
aBuilder
aManager
mHandleOpacity
)
;
image
:
:
DrawResult
result
=
nsSVGIntegrationUtils
:
:
PaintFilter
(
params
)
;
nsDisplayFilterGeometry
:
:
UpdateDrawResult
(
this
result
)
;
}
#
ifdef
MOZ_DUMP_PAINTING
void
nsDisplayFilter
:
:
PrintEffects
(
nsACString
&
aTo
)
{
nsIFrame
*
firstFrame
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
mFrame
)
;
nsSVGEffects
:
:
EffectProperties
effectProperties
=
nsSVGEffects
:
:
GetEffectProperties
(
firstFrame
)
;
bool
first
=
true
;
aTo
+
=
"
effects
=
(
"
;
if
(
mFrame
-
>
StyleEffects
(
)
-
>
mOpacity
!
=
1
.
0f
&
&
mHandleOpacity
)
{
first
=
false
;
aTo
+
=
nsPrintfCString
(
"
opacity
(
%
f
)
"
mFrame
-
>
StyleEffects
(
)
-
>
mOpacity
)
;
}
if
(
effectProperties
.
HasValidFilter
(
)
)
{
if
(
!
first
)
{
aTo
+
=
"
"
;
}
aTo
+
=
"
filter
"
;
}
aTo
+
=
"
)
"
;
}
#
endif
namespace
mozilla
{
uint32_t
PaintTelemetry
:
:
sPaintLevel
=
0
;
uint32_t
PaintTelemetry
:
:
sMetricLevel
=
0
;
EnumeratedArray
<
PaintTelemetry
:
:
Metric
PaintTelemetry
:
:
Metric
:
:
COUNT
double
>
PaintTelemetry
:
:
sMetrics
;
PaintTelemetry
:
:
AutoRecordPaint
:
:
AutoRecordPaint
(
)
{
if
(
sPaintLevel
+
+
>
0
)
{
return
;
}
for
(
auto
&
metric
:
sMetrics
)
{
metric
=
0
.
0
;
}
mStart
=
TimeStamp
:
:
Now
(
)
;
}
PaintTelemetry
:
:
AutoRecordPaint
:
:
~
AutoRecordPaint
(
)
{
MOZ_ASSERT
(
sPaintLevel
!
=
0
)
;
if
(
-
-
sPaintLevel
>
0
)
{
return
;
}
if
(
gfxVars
:
:
BrowserTabsRemoteAutostart
(
)
&
&
XRE_IsParentProcess
(
)
)
{
return
;
}
double
totalMs
=
(
TimeStamp
:
:
Now
(
)
-
mStart
)
.
ToMilliseconds
(
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
CONTENT_PAINT_TIME
static_cast
<
uint32_t
>
(
totalMs
)
)
;
if
(
totalMs
<
=
16
.
0
)
{
return
;
}
auto
record
=
[
=
]
(
const
char
*
aKey
double
aDurationMs
)
-
>
void
{
MOZ_ASSERT
(
aDurationMs
<
=
totalMs
)
;
uint32_t
amount
=
static_cast
<
int32_t
>
(
(
aDurationMs
/
totalMs
)
*
100
.
0
)
;
nsDependentCString
key
(
aKey
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
CONTENT_LARGE_PAINT_PHASE_WEIGHT
key
amount
)
;
}
;
double
dlMs
=
sMetrics
[
Metric
:
:
DisplayList
]
;
double
flbMs
=
sMetrics
[
Metric
:
:
Layerization
]
;
double
rMs
=
sMetrics
[
Metric
:
:
Rasterization
]
;
record
(
"
dl
"
dlMs
)
;
record
(
"
flb
"
flbMs
)
;
record
(
"
r
"
rMs
)
;
record
(
"
dl
flb
"
dlMs
+
flbMs
)
;
record
(
"
dl
r
"
dlMs
+
rMs
)
;
record
(
"
flb
r
"
flbMs
+
rMs
)
;
record
(
"
dl
flb
r
"
dlMs
+
flbMs
+
rMs
)
;
}
PaintTelemetry
:
:
AutoRecord
:
:
AutoRecord
(
Metric
aMetric
)
:
mMetric
(
aMetric
)
{
if
(
sMetricLevel
+
+
>
0
)
{
return
;
}
if
(
sPaintLevel
!
=
1
)
{
return
;
}
mStart
=
TimeStamp
:
:
Now
(
)
;
}
PaintTelemetry
:
:
AutoRecord
:
:
~
AutoRecord
(
)
{
MOZ_ASSERT
(
sMetricLevel
!
=
0
)
;
sMetricLevel
-
-
;
if
(
mStart
.
IsNull
(
)
)
{
return
;
}
sMetrics
[
mMetric
]
+
=
(
TimeStamp
:
:
Now
(
)
-
mStart
)
.
ToMilliseconds
(
)
;
}
}
