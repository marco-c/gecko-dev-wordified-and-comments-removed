#
include
"
nsDisplayList
.
h
"
#
include
<
stdint
.
h
>
#
include
<
algorithm
>
#
include
<
limits
>
#
include
"
gfxContext
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
mozilla
/
DisplayPortUtils
.
h
"
#
include
"
mozilla
/
dom
/
BrowserChild
.
h
"
#
include
"
mozilla
/
dom
/
HTMLCanvasElement
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerRegistrar
.
h
"
#
include
"
mozilla
/
dom
/
ServiceWorkerRegistration
.
h
"
#
include
"
mozilla
/
dom
/
SVGElement
.
h
"
#
include
"
mozilla
/
dom
/
TouchEvent
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
ShapeUtils
.
h
"
#
include
"
mozilla
/
StaticPrefs_apz
.
h
"
#
include
"
mozilla
/
StaticPrefs_gfx
.
h
"
#
include
"
mozilla
/
StaticPrefs_layers
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
mozilla
/
StaticPrefs_print
.
h
"
#
include
"
mozilla
/
SVGIntegrationUtils
.
h
"
#
include
"
mozilla
/
SVGUtils
.
h
"
#
include
"
mozilla
/
ViewportUtils
.
h
"
#
include
"
nsCSSRendering
.
h
"
#
include
"
nsCSSRenderingGradients
.
h
"
#
include
"
nsRefreshDriver
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nsStyleStructInlines
.
h
"
#
include
"
nsStyleTransformMatrix
.
h
"
#
include
"
nsTransitionManager
.
h
"
#
include
"
gfxMatrix
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
BorderConsts
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
Layers
.
h
"
#
include
"
nsBoxFrame
.
h
"
#
include
"
nsImageFrame
.
h
"
#
include
"
nsSubDocumentFrame
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
nsCanvasFrame
.
h
"
#
include
"
nsSubDocumentFrame
.
h
"
#
include
"
StickyScrollContainer
.
h
"
#
include
"
mozilla
/
AnimationPerformanceWarning
.
h
"
#
include
"
mozilla
/
AnimationUtils
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
EffectCompositor
.
h
"
#
include
"
mozilla
/
EffectSet
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
HashTable
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
mozilla
/
OperatorNewExtensions
.
h
"
#
include
"
mozilla
/
PendingAnimationTracker
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
ProfilerLabels
.
h
"
#
include
"
mozilla
/
ProfilerMarkers
.
h
"
#
include
"
mozilla
/
StyleAnimationValue
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
mozilla
/
SVGClipPathFrame
.
h
"
#
include
"
mozilla
/
SVGMaskFrame
.
h
"
#
include
"
mozilla
/
SVGObserverUtils
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
ViewportFrame
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
#
include
"
ActiveLayerTracker
.
h
"
#
include
"
nsEscape
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
UnitTransforms
.
h
"
#
include
"
LayerAnimationInfo
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
nsCaret
.
h
"
#
include
"
nsDOMTokenList
.
h
"
#
include
"
nsCSSProps
.
h
"
#
include
"
nsTableCellFrame
.
h
"
#
include
"
nsTableColFrame
.
h
"
#
include
"
nsTextFrame
.
h
"
#
include
"
nsSliderFrame
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
TextDrawTarget
.
h
"
#
include
"
mozilla
/
layers
/
AnimationHelper
.
h
"
#
include
"
mozilla
/
layers
/
CompositorThread
.
h
"
#
include
"
mozilla
/
layers
/
InputAPZContext
.
h
"
#
include
"
mozilla
/
layers
/
RenderRootStateManager
.
h
"
#
include
"
mozilla
/
layers
/
StackingContextHelper
.
h
"
#
include
"
mozilla
/
layers
/
TreeTraversal
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderLayerManager
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderMessages
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderScrollData
.
h
"
namespace
mozilla
{
using
namespace
dom
;
using
namespace
gfx
;
using
namespace
layout
;
using
namespace
layers
;
using
namespace
image
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
void
AssertUniqueItem
(
nsDisplayItem
*
aItem
)
{
for
(
nsDisplayItem
*
i
:
aItem
-
>
Frame
(
)
-
>
DisplayItems
(
)
)
{
if
(
i
!
=
aItem
&
&
!
i
-
>
HasDeletedFrame
(
)
&
&
i
-
>
Frame
(
)
=
=
aItem
-
>
Frame
(
)
&
&
i
-
>
GetPerFrameKey
(
)
=
=
aItem
-
>
GetPerFrameKey
(
)
)
{
if
(
i
-
>
IsPreProcessedItem
(
)
)
{
continue
;
}
MOZ_DIAGNOSTIC_ASSERT
(
false
"
Duplicate
display
item
!
"
)
;
}
}
}
#
endif
bool
ShouldBuildItemForEvents
(
const
DisplayItemType
aType
)
{
return
aType
=
=
DisplayItemType
:
:
TYPE_COMPOSITOR_HITTEST_INFO
|
|
(
GetDisplayItemFlagsForType
(
aType
)
&
TYPE_IS_CONTAINER
)
;
}
static
bool
ItemTypeSupportsHitTesting
(
const
DisplayItemType
aType
)
{
switch
(
aType
)
{
case
DisplayItemType
:
:
TYPE_BACKGROUND
:
case
DisplayItemType
:
:
TYPE_BACKGROUND_COLOR
:
case
DisplayItemType
:
:
TYPE_THEMED_BACKGROUND
:
return
true
;
default
:
return
false
;
}
}
void
InitializeHitTestInfo
(
nsDisplayListBuilder
*
aBuilder
nsPaintedDisplayItem
*
aItem
const
DisplayItemType
aType
)
{
if
(
ItemTypeSupportsHitTesting
(
aType
)
)
{
aItem
-
>
InitializeHitTestInfo
(
aBuilder
)
;
}
}
already_AddRefed
<
ActiveScrolledRoot
>
ActiveScrolledRoot
:
:
CreateASRForFrame
(
const
ActiveScrolledRoot
*
aParent
nsIScrollableFrame
*
aScrollableFrame
bool
aIsRetained
)
{
nsIFrame
*
f
=
do_QueryFrame
(
aScrollableFrame
)
;
RefPtr
<
ActiveScrolledRoot
>
asr
;
if
(
aIsRetained
)
{
asr
=
f
-
>
GetProperty
(
ActiveScrolledRootCache
(
)
)
;
}
if
(
!
asr
)
{
asr
=
new
ActiveScrolledRoot
(
)
;
if
(
aIsRetained
)
{
RefPtr
<
ActiveScrolledRoot
>
ref
=
asr
;
f
-
>
SetProperty
(
ActiveScrolledRootCache
(
)
ref
.
forget
(
)
.
take
(
)
)
;
}
}
asr
-
>
mParent
=
aParent
;
asr
-
>
mScrollableFrame
=
aScrollableFrame
;
asr
-
>
mViewId
=
Nothing
(
)
;
asr
-
>
mDepth
=
aParent
?
aParent
-
>
mDepth
+
1
:
1
;
asr
-
>
mRetained
=
aIsRetained
;
return
asr
.
forget
(
)
;
}
bool
ActiveScrolledRoot
:
:
IsAncestor
(
const
ActiveScrolledRoot
*
aAncestor
const
ActiveScrolledRoot
*
aDescendant
)
{
if
(
!
aAncestor
)
{
return
true
;
}
if
(
Depth
(
aAncestor
)
>
Depth
(
aDescendant
)
)
{
return
false
;
}
const
ActiveScrolledRoot
*
asr
=
aDescendant
;
while
(
asr
)
{
if
(
asr
=
=
aAncestor
)
{
return
true
;
}
asr
=
asr
-
>
mParent
;
}
return
false
;
}
bool
ActiveScrolledRoot
:
:
IsProperAncestor
(
const
ActiveScrolledRoot
*
aAncestor
const
ActiveScrolledRoot
*
aDescendant
)
{
return
aAncestor
!
=
aDescendant
&
&
IsAncestor
(
aAncestor
aDescendant
)
;
}
nsCString
ActiveScrolledRoot
:
:
ToString
(
const
ActiveScrolledRoot
*
aActiveScrolledRoot
)
{
nsAutoCString
str
;
for
(
const
auto
*
asr
=
aActiveScrolledRoot
;
asr
;
asr
=
asr
-
>
mParent
)
{
str
.
AppendPrintf
(
"
<
0x
%
p
>
"
asr
-
>
mScrollableFrame
)
;
if
(
asr
-
>
mParent
)
{
str
.
AppendLiteral
(
"
"
)
;
}
}
return
std
:
:
move
(
str
)
;
}
ScrollableLayerGuid
:
:
ViewID
ActiveScrolledRoot
:
:
ComputeViewId
(
)
const
{
nsIContent
*
content
=
mScrollableFrame
-
>
GetScrolledFrame
(
)
-
>
GetContent
(
)
;
return
nsLayoutUtils
:
:
FindOrCreateIDFor
(
content
)
;
}
ActiveScrolledRoot
:
:
~
ActiveScrolledRoot
(
)
{
if
(
mScrollableFrame
&
&
mRetained
)
{
nsIFrame
*
f
=
do_QueryFrame
(
mScrollableFrame
)
;
f
-
>
RemoveProperty
(
ActiveScrolledRootCache
(
)
)
;
}
}
static
uint64_t
AddAnimationsForWebRender
(
nsDisplayItem
*
aItem
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
const
Maybe
<
LayoutDevicePoint
>
&
aPosition
=
Nothing
(
)
)
{
EffectSet
*
effects
=
EffectSet
:
:
GetEffectSetForFrame
(
aItem
-
>
Frame
(
)
aItem
-
>
GetType
(
)
)
;
if
(
!
effects
|
|
effects
-
>
IsEmpty
(
)
)
{
return
0
;
}
RefPtr
<
WebRenderAnimationData
>
animationData
=
aManager
-
>
CommandBuilder
(
)
.
CreateOrRecycleWebRenderUserData
<
WebRenderAnimationData
>
(
aItem
)
;
AnimationInfo
&
animationInfo
=
animationData
-
>
GetAnimationInfo
(
)
;
animationInfo
.
AddAnimationsForDisplayItem
(
aItem
-
>
Frame
(
)
aDisplayListBuilder
aItem
aItem
-
>
GetType
(
)
aManager
-
>
LayerManager
(
)
aPosition
)
;
animationInfo
.
StartPendingAnimations
(
aManager
-
>
LayerManager
(
)
-
>
GetAnimationReadyTime
(
)
)
;
uint64_t
animationsId
=
animationInfo
.
GetCompositorAnimationsId
(
)
;
if
(
!
animationInfo
.
GetAnimations
(
)
.
IsEmpty
(
)
)
{
OpAddCompositorAnimations
anim
(
CompositorAnimations
(
animationInfo
.
GetAnimations
(
)
animationsId
)
)
;
aManager
-
>
WrBridge
(
)
-
>
AddWebRenderParentCommand
(
anim
)
;
aManager
-
>
AddActiveCompositorAnimationId
(
animationsId
)
;
}
else
if
(
animationsId
)
{
aManager
-
>
AddCompositorAnimationsIdForDiscard
(
animationsId
)
;
animationsId
=
0
;
}
return
animationsId
;
}
static
bool
GenerateAndPushTextMask
(
nsIFrame
*
aFrame
gfxContext
*
aContext
const
nsRect
&
aFillRect
nsDisplayListBuilder
*
aBuilder
)
{
if
(
aBuilder
-
>
IsForGenerateGlyphMask
(
)
)
{
return
false
;
}
SVGObserverUtils
:
:
GetAndObserveBackgroundClip
(
aFrame
)
;
gfxContext
*
sourceCtx
=
aContext
;
LayoutDeviceRect
bounds
=
LayoutDeviceRect
:
:
FromAppUnits
(
aFillRect
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
RefPtr
<
DrawTarget
>
sourceTarget
=
sourceCtx
-
>
GetDrawTarget
(
)
;
RefPtr
<
DrawTarget
>
maskDT
=
sourceTarget
-
>
CreateClippedDrawTarget
(
bounds
.
ToUnknownRect
(
)
SurfaceFormat
:
:
A8
)
;
if
(
!
maskDT
|
|
!
maskDT
-
>
IsValid
(
)
)
{
return
false
;
}
RefPtr
<
gfxContext
>
maskCtx
=
gfxContext
:
:
CreatePreservingTransformOrNull
(
maskDT
)
;
MOZ_ASSERT
(
maskCtx
)
;
maskCtx
-
>
Multiply
(
Matrix
:
:
Translation
(
bounds
.
TopLeft
(
)
.
ToUnknownPoint
(
)
)
)
;
nsLayoutUtils
:
:
PaintFrame
(
maskCtx
aFrame
nsRect
(
nsPoint
(
0
0
)
aFrame
-
>
GetSize
(
)
)
NS_RGB
(
255
255
255
)
nsDisplayListBuilderMode
:
:
GenerateGlyph
)
;
Matrix
currentMatrix
=
sourceCtx
-
>
CurrentMatrix
(
)
;
Matrix
invCurrentMatrix
=
currentMatrix
;
invCurrentMatrix
.
Invert
(
)
;
RefPtr
<
SourceSurface
>
maskSurface
=
maskDT
-
>
Snapshot
(
)
;
sourceCtx
-
>
PushGroupForBlendBack
(
gfxContentType
:
:
COLOR_ALPHA
1
.
0
maskSurface
invCurrentMatrix
)
;
return
true
;
}
nsDisplayWrapList
*
nsDisplayListBuilder
:
:
MergeItems
(
nsTArray
<
nsDisplayWrapList
*
>
&
aItems
)
{
nsDisplayWrapList
*
merged
=
nullptr
;
for
(
nsDisplayWrapList
*
item
:
Reversed
(
aItems
)
)
{
MOZ_ASSERT
(
item
)
;
if
(
!
merged
)
{
merged
=
item
-
>
Clone
(
this
)
;
MOZ_ASSERT
(
merged
)
;
AddTemporaryItem
(
merged
)
;
}
else
{
MOZ_ASSERT
(
merged
-
>
CanMerge
(
item
)
)
;
merged
-
>
Merge
(
item
)
;
}
merged
-
>
MergeDisplayListFromItem
(
this
item
)
;
}
return
merged
;
}
void
nsDisplayListBuilder
:
:
AutoCurrentActiveScrolledRootSetter
:
:
SetCurrentActiveScrolledRoot
(
const
ActiveScrolledRoot
*
aActiveScrolledRoot
)
{
MOZ_ASSERT
(
!
mUsed
)
;
mBuilder
-
>
mCurrentActiveScrolledRoot
=
aActiveScrolledRoot
;
const
ActiveScrolledRoot
*
finiteBoundsASR
=
ActiveScrolledRoot
:
:
PickDescendant
(
mContentClipASR
aActiveScrolledRoot
)
;
mBuilder
-
>
mCurrentContainerASR
=
ActiveScrolledRoot
:
:
PickAncestor
(
mBuilder
-
>
mCurrentContainerASR
finiteBoundsASR
)
;
if
(
mBuilder
-
>
mFilterASR
&
&
ActiveScrolledRoot
:
:
IsAncestor
(
aActiveScrolledRoot
mBuilder
-
>
mFilterASR
)
)
{
for
(
const
ActiveScrolledRoot
*
asr
=
mBuilder
-
>
mFilterASR
;
asr
&
&
asr
!
=
aActiveScrolledRoot
;
asr
=
asr
-
>
mParent
)
{
asr
-
>
mScrollableFrame
-
>
SetHasOutOfFlowContentInsideFilter
(
)
;
}
}
mUsed
=
true
;
}
void
nsDisplayListBuilder
:
:
AutoCurrentActiveScrolledRootSetter
:
:
InsertScrollFrame
(
nsIScrollableFrame
*
aScrollableFrame
)
{
MOZ_ASSERT
(
!
mUsed
)
;
size_t
descendantsEndIndex
=
mBuilder
-
>
mActiveScrolledRoots
.
Length
(
)
;
const
ActiveScrolledRoot
*
parentASR
=
mBuilder
-
>
mCurrentActiveScrolledRoot
;
const
ActiveScrolledRoot
*
asr
=
mBuilder
-
>
AllocateActiveScrolledRoot
(
parentASR
aScrollableFrame
)
;
mBuilder
-
>
mCurrentActiveScrolledRoot
=
asr
;
for
(
size_t
i
=
mDescendantsStartIndex
;
i
<
descendantsEndIndex
;
i
+
+
)
{
ActiveScrolledRoot
*
descendantASR
=
mBuilder
-
>
mActiveScrolledRoots
[
i
]
;
if
(
ActiveScrolledRoot
:
:
IsAncestor
(
parentASR
descendantASR
)
)
{
descendantASR
-
>
IncrementDepth
(
)
;
if
(
descendantASR
-
>
mParent
=
=
parentASR
)
{
descendantASR
-
>
mParent
=
asr
;
}
}
}
mUsed
=
true
;
}
nsDisplayListBuilder
:
:
AutoContainerASRTracker
:
:
AutoContainerASRTracker
(
nsDisplayListBuilder
*
aBuilder
)
:
mBuilder
(
aBuilder
)
mSavedContainerASR
(
aBuilder
-
>
mCurrentContainerASR
)
{
mBuilder
-
>
mCurrentContainerASR
=
mBuilder
-
>
mCurrentActiveScrolledRoot
;
}
nsPresContext
*
nsDisplayListBuilder
:
:
CurrentPresContext
(
)
{
return
CurrentPresShellState
(
)
-
>
mPresShell
-
>
GetPresContext
(
)
;
}
nsRect
nsDisplayListBuilder
:
:
OutOfFlowDisplayData
:
:
ComputeVisibleRectForFrame
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
nsRect
&
aVisibleRect
const
nsRect
&
aDirtyRect
nsRect
*
aOutDirtyRect
)
{
nsRect
visible
=
aVisibleRect
;
nsRect
dirtyRectRelativeToDirtyFrame
=
aDirtyRect
;
bool
inPartialUpdate
=
aBuilder
-
>
IsRetainingDisplayList
(
)
&
&
aBuilder
-
>
IsPartialUpdate
(
)
;
if
(
StaticPrefs
:
:
apz_allow_zooming
(
)
&
&
DisplayPortUtils
:
:
IsFixedPosFrameInDisplayPort
(
aFrame
)
&
&
aBuilder
-
>
IsPaintingToWindow
(
)
&
&
!
inPartialUpdate
)
{
dirtyRectRelativeToDirtyFrame
=
nsRect
(
nsPoint
(
0
0
)
aFrame
-
>
GetParent
(
)
-
>
GetSize
(
)
)
;
PresShell
*
presShell
=
aFrame
-
>
PresShell
(
)
;
if
(
presShell
-
>
IsVisualViewportSizeSet
(
)
)
{
dirtyRectRelativeToDirtyFrame
=
nsRect
(
presShell
-
>
GetVisualViewportOffsetRelativeToLayoutViewport
(
)
presShell
-
>
GetVisualViewportSize
(
)
)
;
if
(
nsIFrame
*
rootScrollFrame
=
presShell
-
>
GetRootScrollFrame
(
)
)
{
nsRect
displayport
;
if
(
DisplayPortUtils
:
:
GetHighResolutionDisplayPort
(
rootScrollFrame
-
>
GetContent
(
)
&
displayport
DisplayPortOptions
(
)
.
With
(
ContentGeometryType
:
:
Fixed
)
)
)
{
dirtyRectRelativeToDirtyFrame
=
displayport
;
}
}
}
visible
=
dirtyRectRelativeToDirtyFrame
;
if
(
StaticPrefs
:
:
apz_test_logging_enabled
(
)
&
&
presShell
-
>
GetDocument
(
)
-
>
IsContentDocument
(
)
)
{
nsLayoutUtils
:
:
LogAdditionalTestData
(
aBuilder
"
fixedPosDisplayport
"
ToString
(
CSSSize
:
:
FromAppUnits
(
visible
)
)
)
;
}
}
*
aOutDirtyRect
=
dirtyRectRelativeToDirtyFrame
-
aFrame
-
>
GetPosition
(
)
;
visible
-
=
aFrame
-
>
GetPosition
(
)
;
nsRect
overflowRect
=
aFrame
-
>
InkOverflowRect
(
)
;
if
(
aFrame
-
>
IsTransformed
(
)
&
&
EffectCompositor
:
:
HasAnimationsForCompositor
(
aFrame
DisplayItemType
:
:
TYPE_TRANSFORM
)
)
{
overflowRect
.
Inflate
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
32
)
)
;
}
visible
.
IntersectRect
(
visible
overflowRect
)
;
aOutDirtyRect
-
>
IntersectRect
(
*
aOutDirtyRect
overflowRect
)
;
return
visible
;
}
nsDisplayListBuilder
:
:
Linkifier
:
:
Linkifier
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
)
:
mList
(
aList
)
{
Element
*
elem
=
Element
:
:
FromNodeOrNull
(
aFrame
-
>
GetContent
(
)
)
;
if
(
!
elem
)
{
return
;
}
auto
maybeGenerateDest
=
[
&
]
(
const
nsAtom
*
aAttr
)
{
nsAutoString
attrValue
;
elem
-
>
GetAttr
(
aAttr
attrValue
)
;
if
(
!
attrValue
.
IsEmpty
(
)
)
{
NS_ConvertUTF16toUTF8
dest
(
attrValue
)
;
if
(
aBuilder
-
>
mDestinations
.
EnsureInserted
(
dest
)
)
{
auto
*
destination
=
MakeDisplayItem
<
nsDisplayDestination
>
(
aBuilder
aFrame
dest
.
get
(
)
aFrame
-
>
GetRect
(
)
.
TopLeft
(
)
)
;
mList
-
>
AppendToTop
(
destination
)
;
}
}
}
;
if
(
StaticPrefs
:
:
print_save_as_pdf_internal_destinations_enabled
(
)
)
{
if
(
elem
-
>
HasID
(
)
)
{
maybeGenerateDest
(
nsGkAtoms
:
:
id
)
;
}
if
(
elem
-
>
HasName
(
)
)
{
maybeGenerateDest
(
nsGkAtoms
:
:
name
)
;
}
}
if
(
!
aBuilder
-
>
mLinkSpec
.
IsEmpty
(
)
)
{
return
;
}
nsCOMPtr
<
nsIURI
>
uri
;
if
(
!
elem
-
>
IsLink
(
getter_AddRefs
(
uri
)
)
)
{
return
;
}
bool
hasRef
eqExRef
;
nsIURI
*
docURI
;
if
(
StaticPrefs
:
:
print_save_as_pdf_internal_destinations_enabled
(
)
&
&
NS_SUCCEEDED
(
uri
-
>
GetHasRef
(
&
hasRef
)
)
&
&
hasRef
&
&
(
docURI
=
aFrame
-
>
PresContext
(
)
-
>
Document
(
)
-
>
GetDocumentURI
(
)
)
&
&
NS_SUCCEEDED
(
uri
-
>
EqualsExceptRef
(
docURI
&
eqExRef
)
)
&
&
eqExRef
)
{
if
(
NS_FAILED
(
uri
-
>
GetRef
(
aBuilder
-
>
mLinkSpec
)
)
|
|
aBuilder
-
>
mLinkSpec
.
IsEmpty
(
)
)
{
return
;
}
NS_UnescapeURL
(
aBuilder
-
>
mLinkSpec
)
;
aBuilder
-
>
mLinkSpec
.
Insert
(
'
#
'
0
)
;
}
else
{
if
(
NS_FAILED
(
uri
-
>
GetSpec
(
aBuilder
-
>
mLinkSpec
)
)
|
|
aBuilder
-
>
mLinkSpec
.
IsEmpty
(
)
)
{
return
;
}
}
mBuilderToReset
=
aBuilder
;
}
void
nsDisplayListBuilder
:
:
Linkifier
:
:
MaybeAppendLink
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
{
if
(
!
aBuilder
-
>
mLinkSpec
.
IsEmpty
(
)
)
{
auto
*
link
=
MakeDisplayItem
<
nsDisplayLink
>
(
aBuilder
aFrame
aBuilder
-
>
mLinkSpec
.
get
(
)
aFrame
-
>
GetRect
(
)
)
;
mList
-
>
AppendToTop
(
link
)
;
}
}
nsDisplayListBuilder
:
:
nsDisplayListBuilder
(
nsIFrame
*
aReferenceFrame
nsDisplayListBuilderMode
aMode
bool
aBuildCaret
bool
aRetainingDisplayList
)
:
mReferenceFrame
(
aReferenceFrame
)
mIgnoreScrollFrame
(
nullptr
)
mCurrentActiveScrolledRoot
(
nullptr
)
mCurrentContainerASR
(
nullptr
)
mCurrentFrame
(
aReferenceFrame
)
mCurrentReferenceFrame
(
aReferenceFrame
)
mBuildingExtraPagesForPageNum
(
0
)
mDirtyRect
(
-
1
-
1
-
1
-
1
)
mGlassDisplayItem
(
nullptr
)
mHasGlassItemDuringPartial
(
false
)
mCaretFrame
(
nullptr
)
mScrollInfoItemsForHoisting
(
nullptr
)
mFirstClipChainToDestroy
(
nullptr
)
mMode
(
aMode
)
mTableBackgroundSet
(
nullptr
)
mCurrentScrollParentId
(
ScrollableLayerGuid
:
:
NULL_SCROLL_ID
)
mCurrentScrollbarTarget
(
ScrollableLayerGuid
:
:
NULL_SCROLL_ID
)
mFilterASR
(
nullptr
)
mContainsBlendMode
(
false
)
mIsBuildingScrollbar
(
false
)
mCurrentScrollbarWillHaveLayer
(
false
)
mBuildCaret
(
aBuildCaret
)
mRetainingDisplayList
(
aRetainingDisplayList
)
mPartialUpdate
(
false
)
mIgnoreSuppression
(
false
)
mIncludeAllOutOfFlows
(
false
)
mDescendIntoSubdocuments
(
true
)
mSelectedFramesOnly
(
false
)
mAllowMergingAndFlattening
(
true
)
mInTransform
(
false
)
mInEventsOnly
(
false
)
mInFilter
(
false
)
mInPageSequence
(
false
)
mIsInChromePresContext
(
false
)
mSyncDecodeImages
(
false
)
mIsPaintingToWindow
(
false
)
mUseHighQualityScaling
(
false
)
mIsPaintingForWebRender
(
false
)
mIsCompositingCheap
(
false
)
mAncestorHasApzAwareEventHandler
(
false
)
mHaveScrollableDisplayPort
(
false
)
mWindowDraggingAllowed
(
false
)
mIsBuildingForPopup
(
nsLayoutUtils
:
:
IsPopup
(
aReferenceFrame
)
)
mForceLayerForScrollParent
(
false
)
mContainsNonMinimalDisplayPort
(
false
)
mAsyncPanZoomEnabled
(
nsLayoutUtils
:
:
AsyncPanZoomEnabled
(
aReferenceFrame
)
)
mBuildingInvisibleItems
(
false
)
mIsBuilding
(
false
)
mInInvalidSubtree
(
false
)
mDisablePartialUpdates
(
false
)
mPartialBuildFailed
(
false
)
mIsInActiveDocShell
(
false
)
mBuildAsyncZoomContainer
(
false
)
mContainsBackdropFilter
(
false
)
mIsRelativeToLayoutViewport
(
false
)
mUseOverlayScrollbars
(
false
)
mAlwaysLayerizeScrollbars
(
false
)
{
MOZ_COUNT_CTOR
(
nsDisplayListBuilder
)
;
mBuildCompositorHitTestInfo
=
mAsyncPanZoomEnabled
&
&
IsForPainting
(
)
;
ShouldRebuildDisplayListDueToPrefChange
(
)
;
mUseOverlayScrollbars
=
(
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
IntID
:
:
UseOverlayScrollbars
)
!
=
0
)
;
mAlwaysLayerizeScrollbars
=
StaticPrefs
:
:
layout_scrollbars_always_layerize_track
(
)
;
static_assert
(
static_cast
<
uint32_t
>
(
DisplayItemType
:
:
TYPE_MAX
)
<
(
1
<
<
TYPE_BITS
)
"
Check
TYPE_MAX
should
not
overflow
"
)
;
}
static
PresShell
*
GetFocusedPresShell
(
)
{
nsPIDOMWindowOuter
*
focusedWnd
=
nsFocusManager
:
:
GetFocusManager
(
)
-
>
GetFocusedWindow
(
)
;
if
(
!
focusedWnd
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIDocShell
>
focusedDocShell
=
focusedWnd
-
>
GetDocShell
(
)
;
if
(
!
focusedDocShell
)
{
return
nullptr
;
}
return
focusedDocShell
-
>
GetPresShell
(
)
;
}
void
nsDisplayListBuilder
:
:
BeginFrame
(
)
{
nsCSSRendering
:
:
BeginFrameTreesLocked
(
)
;
mIsPaintingToWindow
=
false
;
mUseHighQualityScaling
=
false
;
mIgnoreSuppression
=
false
;
mInTransform
=
false
;
mInFilter
=
false
;
mSyncDecodeImages
=
false
;
if
(
!
mBuildCaret
)
{
return
;
}
RefPtr
<
PresShell
>
presShell
=
GetFocusedPresShell
(
)
;
if
(
presShell
)
{
RefPtr
<
nsCaret
>
caret
=
presShell
-
>
GetCaret
(
)
;
mCaretFrame
=
caret
-
>
GetPaintGeometry
(
&
mCaretRect
)
;
if
(
mCaretFrame
&
&
nsLayoutUtils
:
:
GetDisplayRootFrame
(
mCaretFrame
)
!
=
nsLayoutUtils
:
:
GetDisplayRootFrame
(
mReferenceFrame
)
)
{
mCaretFrame
=
nullptr
;
}
}
}
void
nsDisplayListBuilder
:
:
EndFrame
(
)
{
NS_ASSERTION
(
!
mInInvalidSubtree
"
Someone
forgot
to
cleanup
mInInvalidSubtree
!
"
)
;
mActiveScrolledRoots
.
Clear
(
)
;
mEffectsUpdates
.
Clear
(
)
;
FreeClipChains
(
)
;
FreeTemporaryItems
(
)
;
nsCSSRendering
:
:
EndFrameTreesLocked
(
)
;
mCaretFrame
=
nullptr
;
}
void
nsDisplayListBuilder
:
:
MarkFrameForDisplay
(
nsIFrame
*
aFrame
const
nsIFrame
*
aStopAtFrame
)
{
mFramesMarkedForDisplay
.
AppendElement
(
aFrame
)
;
for
(
nsIFrame
*
f
=
aFrame
;
f
;
f
=
nsLayoutUtils
:
:
GetParentOrPlaceholderForCrossDoc
(
f
)
)
{
if
(
f
-
>
HasAnyStateBits
(
NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO
)
)
{
return
;
}
f
-
>
AddStateBits
(
NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO
)
;
if
(
f
=
=
aStopAtFrame
)
{
break
;
}
}
}
void
nsDisplayListBuilder
:
:
AddFrameMarkedForDisplayIfVisible
(
nsIFrame
*
aFrame
)
{
mFramesMarkedForDisplayIfVisible
.
AppendElement
(
aFrame
)
;
}
void
nsDisplayListBuilder
:
:
MarkFrameForDisplayIfVisible
(
nsIFrame
*
aFrame
const
nsIFrame
*
aStopAtFrame
)
{
AddFrameMarkedForDisplayIfVisible
(
aFrame
)
;
for
(
nsIFrame
*
f
=
aFrame
;
f
;
f
=
nsLayoutUtils
:
:
GetDisplayListParent
(
f
)
)
{
if
(
f
-
>
ForceDescendIntoIfVisible
(
)
)
{
return
;
}
f
-
>
SetForceDescendIntoIfVisible
(
true
)
;
if
(
f
=
=
aStopAtFrame
)
{
break
;
}
}
}
void
nsDisplayListBuilder
:
:
SetGlassDisplayItem
(
nsDisplayItem
*
aItem
)
{
if
(
IsPartialUpdate
(
)
)
{
if
(
aItem
-
>
Frame
(
)
-
>
IsDocElementBoxFrame
(
)
)
{
#
ifdef
DEBUG
if
(
mHasGlassItemDuringPartial
)
{
NS_WARNING
(
"
Multiple
glass
backgrounds
found
?
"
)
;
}
else
#
endif
if
(
!
mHasGlassItemDuringPartial
)
{
mHasGlassItemDuringPartial
=
true
;
aItem
-
>
SetIsGlassItem
(
)
;
}
}
return
;
}
if
(
aItem
-
>
Frame
(
)
-
>
IsDocElementBoxFrame
(
)
)
{
#
ifdef
DEBUG
if
(
mGlassDisplayItem
)
{
NS_WARNING
(
"
Multiple
glass
backgrounds
found
?
"
)
;
}
else
#
endif
if
(
!
mGlassDisplayItem
)
{
mGlassDisplayItem
=
aItem
;
mGlassDisplayItem
-
>
SetIsGlassItem
(
)
;
}
}
}
bool
nsDisplayListBuilder
:
:
NeedToForceTransparentSurfaceForItem
(
nsDisplayItem
*
aItem
)
{
return
aItem
=
=
mGlassDisplayItem
;
}
void
nsDisplayListBuilder
:
:
SetIsRelativeToLayoutViewport
(
)
{
mIsRelativeToLayoutViewport
=
true
;
UpdateShouldBuildAsyncZoomContainer
(
)
;
}
void
nsDisplayListBuilder
:
:
UpdateShouldBuildAsyncZoomContainer
(
)
{
const
Document
*
document
=
mReferenceFrame
-
>
PresContext
(
)
-
>
Document
(
)
;
mBuildAsyncZoomContainer
=
!
mIsRelativeToLayoutViewport
&
&
!
document
-
>
Fullscreen
(
)
&
&
nsLayoutUtils
:
:
AllowZoomingForDocument
(
document
)
;
}
bool
nsDisplayListBuilder
:
:
ShouldRebuildDisplayListDueToPrefChange
(
)
{
bool
didBuildAsyncZoomContainer
=
mBuildAsyncZoomContainer
;
UpdateShouldBuildAsyncZoomContainer
(
)
;
bool
hadOverlayScrollbarsLastTime
=
mUseOverlayScrollbars
;
mUseOverlayScrollbars
=
(
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
IntID
:
:
UseOverlayScrollbars
)
!
=
0
)
;
bool
alwaysLayerizedScrollbarsLastTime
=
mAlwaysLayerizeScrollbars
;
mAlwaysLayerizeScrollbars
=
StaticPrefs
:
:
layout_scrollbars_always_layerize_track
(
)
;
if
(
didBuildAsyncZoomContainer
!
=
mBuildAsyncZoomContainer
)
{
return
true
;
}
if
(
hadOverlayScrollbarsLastTime
!
=
mUseOverlayScrollbars
)
{
return
true
;
}
if
(
alwaysLayerizedScrollbarsLastTime
!
=
mAlwaysLayerizeScrollbars
)
{
return
true
;
}
return
false
;
}
void
nsDisplayListBuilder
:
:
AddScrollFrameToNotify
(
nsIScrollableFrame
*
aScrollFrame
)
{
mScrollFramesToNotify
.
insert
(
aScrollFrame
)
;
}
void
nsDisplayListBuilder
:
:
NotifyAndClearScrollFrames
(
)
{
for
(
const
auto
&
it
:
mScrollFramesToNotify
)
{
it
-
>
NotifyApzTransaction
(
)
;
}
mScrollFramesToNotify
.
clear
(
)
;
}
bool
nsDisplayListBuilder
:
:
MarkOutOfFlowFrameForDisplay
(
nsIFrame
*
aDirtyFrame
nsIFrame
*
aFrame
const
nsRect
&
aVisibleRect
const
nsRect
&
aDirtyRect
)
{
MOZ_ASSERT
(
aFrame
-
>
GetParent
(
)
=
=
aDirtyFrame
)
;
nsRect
dirty
;
nsRect
visible
=
OutOfFlowDisplayData
:
:
ComputeVisibleRectForFrame
(
this
aFrame
aVisibleRect
aDirtyRect
&
dirty
)
;
if
(
!
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO
)
&
&
visible
.
IsEmpty
(
)
)
{
return
false
;
}
if
(
!
dirty
.
IsEmpty
(
)
|
|
aFrame
-
>
ForceDescendIntoIfVisible
(
)
)
{
MarkFrameForDisplay
(
aFrame
aDirtyFrame
)
;
}
return
true
;
}
static
void
UnmarkFrameForDisplay
(
nsIFrame
*
aFrame
const
nsIFrame
*
aStopAtFrame
)
{
for
(
nsIFrame
*
f
=
aFrame
;
f
;
f
=
nsLayoutUtils
:
:
GetParentOrPlaceholderForCrossDoc
(
f
)
)
{
if
(
!
f
-
>
HasAnyStateBits
(
NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO
)
)
{
return
;
}
f
-
>
RemoveStateBits
(
NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO
)
;
if
(
f
=
=
aStopAtFrame
)
{
break
;
}
}
}
static
void
UnmarkFrameForDisplayIfVisible
(
nsIFrame
*
aFrame
)
{
for
(
nsIFrame
*
f
=
aFrame
;
f
;
f
=
nsLayoutUtils
:
:
GetDisplayListParent
(
f
)
)
{
if
(
!
f
-
>
ForceDescendIntoIfVisible
(
)
)
{
return
;
}
f
-
>
SetForceDescendIntoIfVisible
(
false
)
;
}
}
nsDisplayListBuilder
:
:
~
nsDisplayListBuilder
(
)
{
NS_ASSERTION
(
mFramesMarkedForDisplay
.
Length
(
)
=
=
0
"
All
frames
should
have
been
unmarked
"
)
;
NS_ASSERTION
(
mFramesWithOOFData
.
Length
(
)
=
=
0
"
All
OOF
data
should
have
been
removed
"
)
;
NS_ASSERTION
(
mPresShellStates
.
Length
(
)
=
=
0
"
All
presshells
should
have
been
exited
"
)
;
DisplayItemClipChain
*
c
=
mFirstClipChainToDestroy
;
while
(
c
)
{
DisplayItemClipChain
*
next
=
c
-
>
mNextClipChainToDestroy
;
c
-
>
DisplayItemClipChain
:
:
~
DisplayItemClipChain
(
)
;
c
=
next
;
}
MOZ_COUNT_DTOR
(
nsDisplayListBuilder
)
;
}
uint32_t
nsDisplayListBuilder
:
:
GetBackgroundPaintFlags
(
)
{
uint32_t
flags
=
0
;
if
(
mSyncDecodeImages
)
{
flags
|
=
nsCSSRendering
:
:
PAINTBG_SYNC_DECODE_IMAGES
;
}
if
(
mIsPaintingToWindow
)
{
flags
|
=
nsCSSRendering
:
:
PAINTBG_TO_WINDOW
;
}
if
(
mUseHighQualityScaling
)
{
flags
|
=
nsCSSRendering
:
:
PAINTBG_HIGH_QUALITY_SCALING
;
}
return
flags
;
}
uint32_t
nsDisplayListBuilder
:
:
GetImageRendererFlags
(
)
const
{
uint32_t
flags
=
0
;
if
(
mSyncDecodeImages
)
{
flags
|
=
nsImageRenderer
:
:
FLAG_SYNC_DECODE_IMAGES
;
}
if
(
mIsPaintingToWindow
)
{
flags
|
=
nsImageRenderer
:
:
FLAG_PAINTING_TO_WINDOW
;
}
if
(
mUseHighQualityScaling
)
{
flags
|
=
nsImageRenderer
:
:
FLAG_HIGH_QUALITY_SCALING
;
}
return
flags
;
}
uint32_t
nsDisplayListBuilder
:
:
GetImageDecodeFlags
(
)
const
{
uint32_t
flags
=
imgIContainer
:
:
FLAG_ASYNC_NOTIFY
;
if
(
mSyncDecodeImages
)
{
flags
|
=
imgIContainer
:
:
FLAG_SYNC_DECODE
;
}
else
{
flags
|
=
imgIContainer
:
:
FLAG_SYNC_DECODE_IF_FAST
;
}
if
(
mIsPaintingToWindow
|
|
mUseHighQualityScaling
)
{
flags
|
=
imgIContainer
:
:
FLAG_HIGH_QUALITY_SCALING
;
}
return
flags
;
}
void
nsDisplayListBuilder
:
:
SubtractFromVisibleRegion
(
nsRegion
*
aVisibleRegion
const
nsRegion
&
aRegion
)
{
if
(
aRegion
.
IsEmpty
(
)
)
{
return
;
}
nsRegion
tmp
;
tmp
.
Sub
(
*
aVisibleRegion
aRegion
)
;
if
(
tmp
.
GetNumRects
(
)
<
=
15
|
|
tmp
.
Area
(
)
<
=
aVisibleRegion
-
>
Area
(
)
/
2
)
{
*
aVisibleRegion
=
tmp
;
}
}
nsCaret
*
nsDisplayListBuilder
:
:
GetCaret
(
)
{
RefPtr
<
nsCaret
>
caret
=
CurrentPresShellState
(
)
-
>
mPresShell
-
>
GetCaret
(
)
;
return
caret
;
}
void
nsDisplayListBuilder
:
:
IncrementPresShellPaintCount
(
PresShell
*
aPresShell
)
{
if
(
mIsPaintingToWindow
)
{
mReferenceFrame
-
>
AddPaintedPresShell
(
aPresShell
)
;
aPresShell
-
>
IncrementPaintCount
(
)
;
}
}
void
nsDisplayListBuilder
:
:
EnterPresShell
(
const
nsIFrame
*
aReferenceFrame
bool
aPointerEventsNoneDoc
)
{
PresShellState
*
state
=
mPresShellStates
.
AppendElement
(
)
;
state
-
>
mPresShell
=
aReferenceFrame
-
>
PresShell
(
)
;
state
-
>
mFirstFrameMarkedForDisplay
=
mFramesMarkedForDisplay
.
Length
(
)
;
state
-
>
mFirstFrameWithOOFData
=
mFramesWithOOFData
.
Length
(
)
;
nsIScrollableFrame
*
sf
=
state
-
>
mPresShell
-
>
GetRootScrollFrameAsScrollable
(
)
;
if
(
sf
&
&
IsInSubdocument
(
)
)
{
nsCanvasFrame
*
canvasFrame
=
do_QueryFrame
(
sf
-
>
GetScrolledFrame
(
)
)
;
if
(
canvasFrame
)
{
MarkFrameForDisplayIfVisible
(
canvasFrame
aReferenceFrame
)
;
}
}
#
ifdef
DEBUG
state
-
>
mAutoLayoutPhase
.
emplace
(
aReferenceFrame
-
>
PresContext
(
)
nsLayoutPhase
:
:
DisplayListBuilding
)
;
#
endif
state
-
>
mPresShell
-
>
UpdateCanvasBackground
(
)
;
bool
buildCaret
=
mBuildCaret
;
if
(
mIgnoreSuppression
|
|
!
state
-
>
mPresShell
-
>
IsPaintingSuppressed
(
)
)
{
state
-
>
mIsBackgroundOnly
=
false
;
}
else
{
state
-
>
mIsBackgroundOnly
=
true
;
buildCaret
=
false
;
}
bool
pointerEventsNone
=
aPointerEventsNoneDoc
;
if
(
IsInSubdocument
(
)
)
{
pointerEventsNone
|
=
mPresShellStates
[
mPresShellStates
.
Length
(
)
-
2
]
.
mInsidePointerEventsNoneDoc
;
}
state
-
>
mInsidePointerEventsNoneDoc
=
pointerEventsNone
;
state
-
>
mPresShellIgnoreScrollFrame
=
state
-
>
mPresShell
-
>
IgnoringViewportScrolling
(
)
?
state
-
>
mPresShell
-
>
GetRootScrollFrame
(
)
:
nullptr
;
nsPresContext
*
pc
=
aReferenceFrame
-
>
PresContext
(
)
;
mIsInChromePresContext
=
pc
-
>
IsChrome
(
)
;
nsIDocShell
*
docShell
=
pc
-
>
GetDocShell
(
)
;
if
(
docShell
)
{
docShell
-
>
GetWindowDraggingAllowed
(
&
mWindowDraggingAllowed
)
;
}
state
-
>
mTouchEventPrefEnabledDoc
=
dom
:
:
TouchEvent
:
:
PrefEnabled
(
docShell
)
;
if
(
!
buildCaret
)
{
return
;
}
if
(
mCaretFrame
&
&
mCaretFrame
-
>
PresShell
(
)
=
=
state
-
>
mPresShell
)
{
MarkFrameForDisplay
(
mCaretFrame
aReferenceFrame
)
;
}
}
static
bool
DisplayListIsNonBlank
(
nsDisplayList
*
aList
)
{
for
(
nsDisplayItem
*
i
:
*
aList
)
{
switch
(
i
-
>
GetType
(
)
)
{
case
DisplayItemType
:
:
TYPE_COMPOSITOR_HITTEST_INFO
:
case
DisplayItemType
:
:
TYPE_CANVAS_BACKGROUND_COLOR
:
case
DisplayItemType
:
:
TYPE_CANVAS_BACKGROUND_IMAGE
:
continue
;
case
DisplayItemType
:
:
TYPE_SOLID_COLOR
:
case
DisplayItemType
:
:
TYPE_BACKGROUND
:
case
DisplayItemType
:
:
TYPE_BACKGROUND_COLOR
:
if
(
i
-
>
Frame
(
)
-
>
IsCanvasFrame
(
)
)
{
continue
;
}
return
true
;
default
:
return
true
;
}
}
return
false
;
}
static
bool
DisplayListIsContentful
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
)
{
for
(
nsDisplayItem
*
i
:
*
aList
)
{
DisplayItemType
type
=
i
-
>
GetType
(
)
;
nsDisplayList
*
children
=
i
-
>
GetChildren
(
)
;
switch
(
type
)
{
case
DisplayItemType
:
:
TYPE_SUBDOCUMENT
:
break
;
default
:
if
(
i
-
>
IsContentful
(
)
)
{
bool
dummy
;
nsRect
bound
=
i
-
>
GetBounds
(
aBuilder
&
dummy
)
;
if
(
!
bound
.
IsEmpty
(
)
)
{
return
true
;
}
}
if
(
children
)
{
if
(
DisplayListIsContentful
(
aBuilder
children
)
)
{
return
true
;
}
}
break
;
}
}
return
false
;
}
void
nsDisplayListBuilder
:
:
LeavePresShell
(
const
nsIFrame
*
aReferenceFrame
nsDisplayList
*
aPaintedContents
)
{
NS_ASSERTION
(
CurrentPresShellState
(
)
-
>
mPresShell
=
=
aReferenceFrame
-
>
PresShell
(
)
"
Presshell
mismatch
"
)
;
if
(
mIsPaintingToWindow
&
&
aPaintedContents
)
{
nsPresContext
*
pc
=
aReferenceFrame
-
>
PresContext
(
)
;
if
(
!
pc
-
>
HadNonBlankPaint
(
)
)
{
if
(
!
CurrentPresShellState
(
)
-
>
mIsBackgroundOnly
&
&
DisplayListIsNonBlank
(
aPaintedContents
)
)
{
pc
-
>
NotifyNonBlankPaint
(
)
;
}
}
nsRootPresContext
*
rootPresContext
=
pc
-
>
GetRootPresContext
(
)
;
if
(
!
pc
-
>
HadContentfulPaint
(
)
&
&
rootPresContext
)
{
if
(
!
CurrentPresShellState
(
)
-
>
mIsBackgroundOnly
)
{
if
(
pc
-
>
HasEverBuiltInvisibleText
(
)
|
|
DisplayListIsContentful
(
this
aPaintedContents
)
)
{
pc
-
>
NotifyContentfulPaint
(
)
;
}
}
}
}
ResetMarkedFramesForDisplayList
(
aReferenceFrame
)
;
mPresShellStates
.
RemoveLastElement
(
)
;
if
(
!
mPresShellStates
.
IsEmpty
(
)
)
{
nsPresContext
*
pc
=
CurrentPresContext
(
)
;
nsIDocShell
*
docShell
=
pc
-
>
GetDocShell
(
)
;
if
(
docShell
)
{
docShell
-
>
GetWindowDraggingAllowed
(
&
mWindowDraggingAllowed
)
;
}
mIsInChromePresContext
=
pc
-
>
IsChrome
(
)
;
}
else
{
for
(
uint32_t
i
=
0
;
i
<
mFramesMarkedForDisplayIfVisible
.
Length
(
)
;
+
+
i
)
{
UnmarkFrameForDisplayIfVisible
(
mFramesMarkedForDisplayIfVisible
[
i
]
)
;
}
mFramesMarkedForDisplayIfVisible
.
SetLength
(
0
)
;
}
}
void
nsDisplayListBuilder
:
:
FreeClipChains
(
)
{
DisplayItemClipChain
*
*
indirect
=
&
mFirstClipChainToDestroy
;
while
(
*
indirect
)
{
if
(
!
(
*
indirect
)
-
>
mRefCount
)
{
DisplayItemClipChain
*
next
=
(
*
indirect
)
-
>
mNextClipChainToDestroy
;
mClipDeduplicator
.
erase
(
*
indirect
)
;
(
*
indirect
)
-
>
DisplayItemClipChain
:
:
~
DisplayItemClipChain
(
)
;
Destroy
(
DisplayListArenaObjectId
:
:
CLIPCHAIN
*
indirect
)
;
*
indirect
=
next
;
}
else
{
indirect
=
&
(
*
indirect
)
-
>
mNextClipChainToDestroy
;
}
}
}
void
nsDisplayListBuilder
:
:
FreeTemporaryItems
(
)
{
for
(
nsDisplayItem
*
i
:
mTemporaryItems
)
{
MOZ_ASSERT
(
i
-
>
Frame
(
)
)
;
i
-
>
RemoveFrame
(
i
-
>
Frame
(
)
)
;
i
-
>
Destroy
(
this
)
;
}
mTemporaryItems
.
Clear
(
)
;
}
void
nsDisplayListBuilder
:
:
ResetMarkedFramesForDisplayList
(
const
nsIFrame
*
aReferenceFrame
)
{
uint32_t
firstFrameForShell
=
CurrentPresShellState
(
)
-
>
mFirstFrameMarkedForDisplay
;
for
(
uint32_t
i
=
firstFrameForShell
;
i
<
mFramesMarkedForDisplay
.
Length
(
)
;
+
+
i
)
{
UnmarkFrameForDisplay
(
mFramesMarkedForDisplay
[
i
]
aReferenceFrame
)
;
}
mFramesMarkedForDisplay
.
SetLength
(
firstFrameForShell
)
;
firstFrameForShell
=
CurrentPresShellState
(
)
-
>
mFirstFrameWithOOFData
;
for
(
uint32_t
i
=
firstFrameForShell
;
i
<
mFramesWithOOFData
.
Length
(
)
;
+
+
i
)
{
mFramesWithOOFData
[
i
]
-
>
RemoveProperty
(
OutOfFlowDisplayDataProperty
(
)
)
;
}
mFramesWithOOFData
.
SetLength
(
firstFrameForShell
)
;
}
void
nsDisplayListBuilder
:
:
ClearFixedBackgroundDisplayData
(
)
{
CurrentPresShellState
(
)
-
>
mFixedBackgroundDisplayData
=
Nothing
(
)
;
}
void
nsDisplayListBuilder
:
:
MarkFramesForDisplayList
(
nsIFrame
*
aDirtyFrame
const
nsFrameList
&
aFrames
)
{
nsRect
visibleRect
=
GetVisibleRect
(
)
;
nsRect
dirtyRect
=
GetDirtyRect
(
)
;
if
(
ViewportFrame
*
viewportFrame
=
do_QueryFrame
(
aDirtyFrame
)
)
{
if
(
IsForEventDelivery
(
)
&
&
ShouldBuildAsyncZoomContainer
(
)
&
&
viewportFrame
-
>
PresContext
(
)
-
>
IsRootContentDocumentCrossProcess
(
)
)
{
if
(
viewportFrame
-
>
PresShell
(
)
-
>
GetRootScrollFrame
(
)
)
{
#
ifdef
DEBUG
for
(
nsIFrame
*
f
:
aFrames
)
{
MOZ_ASSERT
(
ViewportUtils
:
:
IsZoomedContentRoot
(
f
)
)
;
}
#
endif
visibleRect
=
ViewportUtils
:
:
VisualToLayout
(
visibleRect
viewportFrame
-
>
PresShell
(
)
)
;
dirtyRect
=
ViewportUtils
:
:
VisualToLayout
(
dirtyRect
viewportFrame
-
>
PresShell
(
)
)
;
}
#
ifdef
DEBUG
else
{
for
(
nsIFrame
*
f
:
aFrames
)
{
MOZ_ASSERT
(
!
ViewportUtils
:
:
IsZoomedContentRoot
(
f
)
&
&
f
-
>
GetParent
(
)
=
=
aDirtyFrame
&
&
f
-
>
StyleDisplay
(
)
-
>
mPosition
=
=
StylePositionProperty
:
:
Fixed
)
;
}
}
#
endif
}
}
bool
markedFrames
=
false
;
for
(
nsIFrame
*
e
:
aFrames
)
{
if
(
!
IsBuildingCaret
(
)
)
{
nsIContent
*
content
=
e
-
>
GetContent
(
)
;
if
(
content
&
&
content
-
>
IsInNativeAnonymousSubtree
(
)
&
&
content
-
>
IsElement
(
)
)
{
auto
*
classList
=
content
-
>
AsElement
(
)
-
>
ClassList
(
)
;
if
(
classList
-
>
Contains
(
u
"
moz
-
accessiblecaret
"
_ns
)
)
{
continue
;
}
}
}
if
(
MarkOutOfFlowFrameForDisplay
(
aDirtyFrame
e
visibleRect
dirtyRect
)
)
{
markedFrames
=
true
;
}
}
if
(
markedFrames
)
{
const
DisplayItemClipChain
*
clipChain
=
CopyWholeChain
(
mClipState
.
GetClipChainForContainingBlockDescendants
(
)
)
;
const
DisplayItemClipChain
*
combinedClipChain
=
mClipState
.
GetCurrentCombinedClipChain
(
this
)
;
const
ActiveScrolledRoot
*
asr
=
mCurrentActiveScrolledRoot
;
OutOfFlowDisplayData
*
data
=
new
OutOfFlowDisplayData
(
clipChain
combinedClipChain
asr
visibleRect
dirtyRect
)
;
aDirtyFrame
-
>
SetProperty
(
nsDisplayListBuilder
:
:
OutOfFlowDisplayDataProperty
(
)
data
)
;
mFramesWithOOFData
.
AppendElement
(
aDirtyFrame
)
;
}
if
(
!
aDirtyFrame
-
>
GetParent
(
)
)
{
NS_ASSERTION
(
CurrentPresShellState
(
)
-
>
mPresShell
=
=
aDirtyFrame
-
>
PresShell
(
)
"
Presshell
mismatch
"
)
;
MOZ_ASSERT
(
!
CurrentPresShellState
(
)
-
>
mFixedBackgroundDisplayData
"
already
traversed
this
presshell
'
s
root
frame
?
"
)
;
const
DisplayItemClipChain
*
clipChain
=
CopyWholeChain
(
mClipState
.
GetClipChainForContainingBlockDescendants
(
)
)
;
const
DisplayItemClipChain
*
combinedClipChain
=
mClipState
.
GetCurrentCombinedClipChain
(
this
)
;
const
ActiveScrolledRoot
*
asr
=
mCurrentActiveScrolledRoot
;
CurrentPresShellState
(
)
-
>
mFixedBackgroundDisplayData
.
emplace
(
clipChain
combinedClipChain
asr
GetVisibleRect
(
)
GetDirtyRect
(
)
)
;
}
}
void
nsDisplayListBuilder
:
:
MarkPreserve3DFramesForDisplayList
(
nsIFrame
*
aDirtyFrame
)
{
for
(
const
auto
&
childList
:
aDirtyFrame
-
>
ChildLists
(
)
)
{
for
(
nsIFrame
*
child
:
childList
.
mList
)
{
if
(
child
-
>
Combines3DTransformWithAncestors
(
)
)
{
MarkFrameForDisplay
(
child
aDirtyFrame
)
;
}
if
(
child
-
>
IsBlockWrapper
(
)
)
{
MarkPreserve3DFramesForDisplayList
(
child
)
;
}
}
}
}
ActiveScrolledRoot
*
nsDisplayListBuilder
:
:
AllocateActiveScrolledRoot
(
const
ActiveScrolledRoot
*
aParent
nsIScrollableFrame
*
aScrollableFrame
)
{
RefPtr
<
ActiveScrolledRoot
>
asr
=
ActiveScrolledRoot
:
:
CreateASRForFrame
(
aParent
aScrollableFrame
IsRetainingDisplayList
(
)
)
;
mActiveScrolledRoots
.
AppendElement
(
asr
)
;
return
asr
;
}
const
DisplayItemClipChain
*
nsDisplayListBuilder
:
:
AllocateDisplayItemClipChain
(
const
DisplayItemClip
&
aClip
const
ActiveScrolledRoot
*
aASR
const
DisplayItemClipChain
*
aParent
)
{
MOZ_ASSERT
(
!
(
aParent
&
&
aParent
-
>
mOnStack
)
)
;
void
*
p
=
Allocate
(
sizeof
(
DisplayItemClipChain
)
DisplayListArenaObjectId
:
:
CLIPCHAIN
)
;
DisplayItemClipChain
*
c
=
new
(
KnownNotNull
p
)
DisplayItemClipChain
(
aClip
aASR
aParent
mFirstClipChainToDestroy
)
;
#
ifdef
DEBUG
c
-
>
mOnStack
=
false
;
#
endif
auto
result
=
mClipDeduplicator
.
insert
(
c
)
;
if
(
!
result
.
second
)
{
c
-
>
DisplayItemClipChain
:
:
~
DisplayItemClipChain
(
)
;
Destroy
(
DisplayListArenaObjectId
:
:
CLIPCHAIN
c
)
;
return
*
(
result
.
first
)
;
}
mFirstClipChainToDestroy
=
c
;
return
c
;
}
struct
ClipChainItem
{
DisplayItemClip
clip
;
const
ActiveScrolledRoot
*
asr
;
}
;
static
const
DisplayItemClipChain
*
FindCommonAncestorClipForIntersection
(
const
DisplayItemClipChain
*
aOne
const
DisplayItemClipChain
*
aTwo
)
{
for
(
const
ActiveScrolledRoot
*
asr
=
ActiveScrolledRoot
:
:
PickDescendant
(
aOne
-
>
mASR
aTwo
-
>
mASR
)
;
asr
;
asr
=
asr
-
>
mParent
)
{
if
(
aOne
=
=
aTwo
)
{
return
aOne
;
}
if
(
aOne
-
>
mASR
=
=
asr
)
{
aOne
=
aOne
-
>
mParent
;
}
if
(
aTwo
-
>
mASR
=
=
asr
)
{
aTwo
=
aTwo
-
>
mParent
;
}
if
(
!
aOne
)
{
return
aTwo
;
}
if
(
!
aTwo
)
{
return
aOne
;
}
}
return
nullptr
;
}
const
DisplayItemClipChain
*
nsDisplayListBuilder
:
:
CreateClipChainIntersection
(
const
DisplayItemClipChain
*
aAncestor
const
DisplayItemClipChain
*
aLeafClip1
const
DisplayItemClipChain
*
aLeafClip2
)
{
AutoTArray
<
ClipChainItem
8
>
intersectedClips
;
const
DisplayItemClipChain
*
clip1
=
aLeafClip1
;
const
DisplayItemClipChain
*
clip2
=
aLeafClip2
;
const
ActiveScrolledRoot
*
asr
=
ActiveScrolledRoot
:
:
PickDescendant
(
clip1
?
clip1
-
>
mASR
:
nullptr
clip2
?
clip2
-
>
mASR
:
nullptr
)
;
while
(
!
aAncestor
|
|
asr
!
=
aAncestor
-
>
mASR
)
{
if
(
clip1
&
&
clip1
-
>
mASR
=
=
asr
)
{
if
(
clip2
&
&
clip2
-
>
mASR
=
=
asr
)
{
DisplayItemClip
intersection
=
clip1
-
>
mClip
;
intersection
.
IntersectWith
(
clip2
-
>
mClip
)
;
intersectedClips
.
AppendElement
(
ClipChainItem
{
intersection
asr
}
)
;
clip2
=
clip2
-
>
mParent
;
}
else
{
intersectedClips
.
AppendElement
(
ClipChainItem
{
clip1
-
>
mClip
asr
}
)
;
}
clip1
=
clip1
-
>
mParent
;
}
else
if
(
clip2
&
&
clip2
-
>
mASR
=
=
asr
)
{
intersectedClips
.
AppendElement
(
ClipChainItem
{
clip2
-
>
mClip
asr
}
)
;
clip2
=
clip2
-
>
mParent
;
}
if
(
!
asr
)
{
MOZ_ASSERT
(
!
aAncestor
"
We
should
have
exited
this
loop
earlier
"
)
;
break
;
}
asr
=
asr
-
>
mParent
;
}
const
DisplayItemClipChain
*
parentSC
=
aAncestor
;
for
(
auto
&
sc
:
Reversed
(
intersectedClips
)
)
{
parentSC
=
AllocateDisplayItemClipChain
(
sc
.
clip
sc
.
asr
parentSC
)
;
}
return
parentSC
;
}
const
DisplayItemClipChain
*
nsDisplayListBuilder
:
:
CopyWholeChain
(
const
DisplayItemClipChain
*
aClipChain
)
{
return
CreateClipChainIntersection
(
nullptr
aClipChain
nullptr
)
;
}
const
nsIFrame
*
nsDisplayListBuilder
:
:
FindReferenceFrameFor
(
const
nsIFrame
*
aFrame
nsPoint
*
aOffset
)
const
{
auto
MaybeApplyAdditionalOffset
=
[
&
]
(
)
{
if
(
auto
offset
=
AdditionalOffset
(
)
)
{
*
aOffset
+
=
*
offset
;
}
}
;
if
(
aFrame
=
=
mCurrentFrame
)
{
if
(
aOffset
)
{
*
aOffset
=
mCurrentOffsetToReferenceFrame
;
}
return
mCurrentReferenceFrame
;
}
for
(
const
nsIFrame
*
f
=
aFrame
;
f
;
f
=
nsLayoutUtils
:
:
GetCrossDocParentFrameInProcess
(
f
)
)
{
if
(
f
=
=
mReferenceFrame
|
|
f
-
>
IsTransformed
(
)
)
{
if
(
aOffset
)
{
*
aOffset
=
aFrame
-
>
GetOffsetToCrossDoc
(
f
)
;
MaybeApplyAdditionalOffset
(
)
;
}
return
f
;
}
}
if
(
aOffset
)
{
*
aOffset
=
aFrame
-
>
GetOffsetToCrossDoc
(
mReferenceFrame
)
;
}
return
mReferenceFrame
;
}
static
bool
IsStickyFrameActive
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsIFrame
*
aParent
)
{
MOZ_ASSERT
(
aFrame
-
>
StyleDisplay
(
)
-
>
mPosition
=
=
StylePositionProperty
:
:
Sticky
)
;
nsIScrollableFrame
*
sf
=
nsLayoutUtils
:
:
GetNearestScrollableFrame
(
aFrame
-
>
GetParent
(
)
nsLayoutUtils
:
:
SCROLLABLE_SAME_DOC
|
nsLayoutUtils
:
:
SCROLLABLE_INCLUDE_HIDDEN
)
;
if
(
!
sf
)
{
return
false
;
}
return
sf
-
>
IsScrollingActive
(
)
;
}
bool
nsDisplayListBuilder
:
:
IsAnimatedGeometryRoot
(
nsIFrame
*
aFrame
nsIFrame
*
*
aParent
)
{
if
(
aFrame
=
=
mReferenceFrame
)
{
return
true
;
}
if
(
!
IsPaintingToWindow
(
)
)
{
if
(
aParent
)
{
*
aParent
=
nsLayoutUtils
:
:
GetCrossDocParentFrameInProcess
(
aFrame
)
;
}
return
false
;
}
nsIFrame
*
parent
=
nsLayoutUtils
:
:
GetCrossDocParentFrameInProcess
(
aFrame
)
;
if
(
!
parent
)
{
return
true
;
}
*
aParent
=
parent
;
if
(
aFrame
-
>
StyleDisplay
(
)
-
>
mPosition
=
=
StylePositionProperty
:
:
Sticky
&
&
IsStickyFrameActive
(
this
aFrame
parent
)
)
{
return
true
;
}
if
(
aFrame
-
>
IsTransformed
(
)
)
{
if
(
EffectCompositor
:
:
HasAnimationsForCompositor
(
aFrame
DisplayItemType
:
:
TYPE_TRANSFORM
)
)
{
return
true
;
}
}
LayoutFrameType
parentType
=
parent
-
>
Type
(
)
;
if
(
parentType
=
=
LayoutFrameType
:
:
Scroll
|
|
parentType
=
=
LayoutFrameType
:
:
ListControl
)
{
nsIScrollableFrame
*
sf
=
do_QueryFrame
(
parent
)
;
if
(
sf
-
>
GetScrolledFrame
(
)
=
=
aFrame
&
&
sf
-
>
IsScrollingActive
(
)
)
{
MOZ_ASSERT
(
!
aFrame
-
>
IsTransformed
(
)
)
;
return
sf
-
>
IsMaybeAsynchronouslyScrolled
(
)
;
}
}
return
false
;
}
nsIFrame
*
nsDisplayListBuilder
:
:
FindAnimatedGeometryRootFrameFor
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
nsLayoutUtils
:
:
IsAncestorFrameCrossDocInProcess
(
RootReferenceFrame
(
)
aFrame
)
)
;
nsIFrame
*
cursor
=
aFrame
;
while
(
cursor
!
=
RootReferenceFrame
(
)
)
{
nsIFrame
*
next
;
if
(
IsAnimatedGeometryRoot
(
cursor
&
next
)
)
{
return
cursor
;
}
cursor
=
next
;
}
return
cursor
;
}
static
nsRect
ApplyAllClipNonRoundedIntersection
(
const
DisplayItemClipChain
*
aClipChain
const
nsRect
&
aRect
)
{
nsRect
result
=
aRect
;
while
(
aClipChain
)
{
result
=
aClipChain
-
>
mClip
.
ApplyNonRoundedIntersection
(
result
)
;
aClipChain
=
aClipChain
-
>
mParent
;
}
return
result
;
}
void
nsDisplayListBuilder
:
:
AdjustWindowDraggingRegion
(
nsIFrame
*
aFrame
)
{
if
(
!
mWindowDraggingAllowed
|
|
!
IsForPainting
(
)
)
{
return
;
}
const
nsStyleUIReset
*
styleUI
=
aFrame
-
>
StyleUIReset
(
)
;
if
(
styleUI
-
>
mWindowDragging
=
=
StyleWindowDragging
:
:
Default
)
{
return
;
}
LayoutDeviceToLayoutDeviceMatrix4x4
referenceFrameToRootReferenceFrame
;
nsIFrame
*
referenceFrame
=
const_cast
<
nsIFrame
*
>
(
FindReferenceFrameFor
(
aFrame
)
)
;
if
(
IsInTransform
(
)
)
{
referenceFrameToRootReferenceFrame
=
ViewAs
<
LayoutDeviceToLayoutDeviceMatrix4x4
>
(
nsLayoutUtils
:
:
GetTransformToAncestor
(
RelativeTo
{
referenceFrame
}
RelativeTo
{
mReferenceFrame
}
)
.
GetMatrix
(
)
)
;
Matrix
referenceFrameToRootReferenceFrame2d
;
if
(
!
referenceFrameToRootReferenceFrame
.
Is2D
(
&
referenceFrameToRootReferenceFrame2d
)
|
|
!
referenceFrameToRootReferenceFrame2d
.
IsRectilinear
(
)
)
{
return
;
}
}
else
{
MOZ_ASSERT
(
referenceFrame
=
=
mReferenceFrame
"
referenceFrameToRootReferenceFrame
needs
to
be
adjusted
"
)
;
}
nsRect
borderBox
=
aFrame
-
>
GetRectRelativeToSelf
(
)
.
Intersect
(
mVisibleRect
)
;
borderBox
+
=
ToReferenceFrame
(
aFrame
)
;
const
DisplayItemClipChain
*
clip
=
ClipState
(
)
.
GetCurrentCombinedClipChain
(
this
)
;
borderBox
=
ApplyAllClipNonRoundedIntersection
(
clip
borderBox
)
;
if
(
borderBox
.
IsEmpty
(
)
)
{
return
;
}
LayoutDeviceRect
devPixelBorderBox
=
LayoutDevicePixel
:
:
FromAppUnits
(
borderBox
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
LayoutDeviceRect
transformedDevPixelBorderBox
=
TransformBy
(
referenceFrameToRootReferenceFrame
devPixelBorderBox
)
;
transformedDevPixelBorderBox
.
Round
(
)
;
LayoutDeviceIntRect
transformedDevPixelBorderBoxInt
;
if
(
!
transformedDevPixelBorderBox
.
ToIntRect
(
&
transformedDevPixelBorderBoxInt
)
)
{
return
;
}
LayoutDeviceIntRegion
&
region
=
styleUI
-
>
mWindowDragging
=
=
StyleWindowDragging
:
:
Drag
?
mWindowDraggingRegion
:
mWindowNoDraggingRegion
;
if
(
!
IsRetainingDisplayList
(
)
)
{
region
.
OrWith
(
transformedDevPixelBorderBoxInt
)
;
return
;
}
gfx
:
:
IntRect
rect
(
transformedDevPixelBorderBoxInt
.
ToUnknownRect
(
)
)
;
if
(
styleUI
-
>
mWindowDragging
=
=
StyleWindowDragging
:
:
Drag
)
{
mRetainedWindowDraggingRegion
.
Add
(
aFrame
rect
)
;
}
else
{
mRetainedWindowNoDraggingRegion
.
Add
(
aFrame
rect
)
;
}
}
LayoutDeviceIntRegion
nsDisplayListBuilder
:
:
GetWindowDraggingRegion
(
)
const
{
LayoutDeviceIntRegion
result
;
if
(
!
IsRetainingDisplayList
(
)
)
{
result
.
Sub
(
mWindowDraggingRegion
mWindowNoDraggingRegion
)
;
return
result
;
}
LayoutDeviceIntRegion
dragRegion
=
mRetainedWindowDraggingRegion
.
ToLayoutDeviceIntRegion
(
)
;
LayoutDeviceIntRegion
noDragRegion
=
mRetainedWindowNoDraggingRegion
.
ToLayoutDeviceIntRegion
(
)
;
result
.
Sub
(
dragRegion
noDragRegion
)
;
return
result
;
}
void
nsDisplayTransform
:
:
AddSizeOfExcludingThis
(
nsWindowSizes
&
aSizes
)
const
{
nsPaintedDisplayItem
:
:
AddSizeOfExcludingThis
(
aSizes
)
;
aSizes
.
mLayoutRetainedDisplayListSize
+
=
aSizes
.
mState
.
mMallocSizeOf
(
mTransformPreserves3D
.
get
(
)
)
;
}
void
nsDisplayListBuilder
:
:
AddSizeOfExcludingThis
(
nsWindowSizes
&
aSizes
)
const
{
mPool
.
AddSizeOfExcludingThis
(
aSizes
Arena
:
:
ArenaKind
:
:
DisplayList
)
;
size_t
n
=
0
;
MallocSizeOf
mallocSizeOf
=
aSizes
.
mState
.
mMallocSizeOf
;
n
+
=
mDocumentWillChangeBudgets
.
ShallowSizeOfExcludingThis
(
mallocSizeOf
)
;
n
+
=
mFrameWillChangeBudgets
.
ShallowSizeOfExcludingThis
(
mallocSizeOf
)
;
n
+
=
mEffectsUpdates
.
ShallowSizeOfExcludingThis
(
mallocSizeOf
)
;
n
+
=
mWindowExcludeGlassRegion
.
SizeOfExcludingThis
(
mallocSizeOf
)
;
n
+
=
mRetainedWindowDraggingRegion
.
SizeOfExcludingThis
(
mallocSizeOf
)
;
n
+
=
mRetainedWindowNoDraggingRegion
.
SizeOfExcludingThis
(
mallocSizeOf
)
;
n
+
=
mRetainedWindowOpaqueRegion
.
SizeOfExcludingThis
(
mallocSizeOf
)
;
aSizes
.
mLayoutRetainedDisplayListSize
+
=
n
;
}
void
RetainedDisplayList
:
:
AddSizeOfExcludingThis
(
nsWindowSizes
&
aSizes
)
const
{
for
(
nsDisplayItem
*
item
:
*
this
)
{
item
-
>
AddSizeOfExcludingThis
(
aSizes
)
;
if
(
RetainedDisplayList
*
children
=
item
-
>
GetChildren
(
)
)
{
children
-
>
AddSizeOfExcludingThis
(
aSizes
)
;
}
}
size_t
n
=
0
;
n
+
=
mDAG
.
mDirectPredecessorList
.
ShallowSizeOfExcludingThis
(
aSizes
.
mState
.
mMallocSizeOf
)
;
n
+
=
mDAG
.
mNodesInfo
.
ShallowSizeOfExcludingThis
(
aSizes
.
mState
.
mMallocSizeOf
)
;
n
+
=
mOldItems
.
ShallowSizeOfExcludingThis
(
aSizes
.
mState
.
mMallocSizeOf
)
;
aSizes
.
mLayoutRetainedDisplayListSize
+
=
n
;
}
size_t
nsDisplayListBuilder
:
:
WeakFrameRegion
:
:
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
0
;
n
+
=
mFrames
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
for
(
const
auto
&
frame
:
mFrames
)
{
const
UniquePtr
<
WeakFrame
>
&
weakFrame
=
frame
.
mWeakFrame
;
n
+
=
aMallocSizeOf
(
weakFrame
.
get
(
)
)
;
}
n
+
=
mRects
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
return
n
;
}
void
nsDisplayListBuilder
:
:
WeakFrameRegion
:
:
RemoveModifiedFramesAndRects
(
)
{
MOZ_ASSERT
(
mFrames
.
Length
(
)
=
=
mRects
.
Length
(
)
)
;
uint32_t
i
=
0
;
uint32_t
length
=
mFrames
.
Length
(
)
;
while
(
i
<
length
)
{
auto
&
wrapper
=
mFrames
[
i
]
;
if
(
!
wrapper
.
mWeakFrame
-
>
IsAlive
(
)
|
|
AnyContentAncestorModified
(
wrapper
.
mWeakFrame
-
>
GetFrame
(
)
)
)
{
mFrameSet
.
Remove
(
wrapper
.
mFrame
)
;
mFrames
[
i
]
=
std
:
:
move
(
mFrames
[
length
-
1
]
)
;
mRects
[
i
]
=
std
:
:
move
(
mRects
[
length
-
1
]
)
;
length
-
-
;
}
else
{
i
+
+
;
}
}
mFrames
.
TruncateLength
(
length
)
;
mRects
.
TruncateLength
(
length
)
;
}
void
nsDisplayListBuilder
:
:
RemoveModifiedWindowRegions
(
)
{
mRetainedWindowDraggingRegion
.
RemoveModifiedFramesAndRects
(
)
;
mRetainedWindowNoDraggingRegion
.
RemoveModifiedFramesAndRects
(
)
;
mWindowExcludeGlassRegion
.
RemoveModifiedFramesAndRects
(
)
;
mRetainedWindowOpaqueRegion
.
RemoveModifiedFramesAndRects
(
)
;
mHasGlassItemDuringPartial
=
false
;
}
void
nsDisplayListBuilder
:
:
ClearRetainedWindowRegions
(
)
{
mRetainedWindowDraggingRegion
.
Clear
(
)
;
mRetainedWindowNoDraggingRegion
.
Clear
(
)
;
mWindowExcludeGlassRegion
.
Clear
(
)
;
mRetainedWindowOpaqueRegion
.
Clear
(
)
;
mGlassDisplayItem
=
nullptr
;
}
const
uint32_t
gWillChangeAreaMultiplier
=
3
;
static
uint32_t
GetLayerizationCost
(
const
nsSize
&
aSize
)
{
const
int
minBudgetCost
=
64
*
64
;
const
uint32_t
budgetCost
=
std
:
:
max
(
minBudgetCost
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
aSize
.
width
)
*
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
aSize
.
height
)
)
;
return
budgetCost
;
}
bool
nsDisplayListBuilder
:
:
AddToWillChangeBudget
(
nsIFrame
*
aFrame
const
nsSize
&
aSize
)
{
MOZ_ASSERT
(
IsForPainting
(
)
)
;
if
(
aFrame
-
>
MayHaveWillChangeBudget
(
)
)
{
return
true
;
}
const
nsPresContext
*
presContext
=
aFrame
-
>
PresContext
(
)
;
const
nsRect
area
=
presContext
-
>
GetVisibleArea
(
)
;
const
uint32_t
budgetLimit
=
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
area
.
width
)
*
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
area
.
height
)
;
const
uint32_t
cost
=
GetLayerizationCost
(
aSize
)
;
DocumentWillChangeBudget
&
documentBudget
=
mDocumentWillChangeBudgets
.
LookupOrInsert
(
presContext
)
;
const
bool
onBudget
=
(
documentBudget
+
cost
)
/
gWillChangeAreaMultiplier
<
budgetLimit
;
if
(
onBudget
)
{
documentBudget
+
=
cost
;
mFrameWillChangeBudgets
.
InsertOrUpdate
(
aFrame
FrameWillChangeBudget
(
presContext
cost
)
)
;
aFrame
-
>
SetMayHaveWillChangeBudget
(
true
)
;
}
return
onBudget
;
}
bool
nsDisplayListBuilder
:
:
IsInWillChangeBudget
(
nsIFrame
*
aFrame
const
nsSize
&
aSize
)
{
if
(
!
IsForPainting
(
)
)
{
return
false
;
}
const
bool
onBudget
=
AddToWillChangeBudget
(
aFrame
aSize
)
;
if
(
onBudget
)
{
return
true
;
}
auto
*
pc
=
aFrame
-
>
PresContext
(
)
;
auto
*
doc
=
pc
-
>
Document
(
)
;
if
(
!
doc
-
>
HasWarnedAbout
(
Document
:
:
eIgnoringWillChangeOverBudget
)
)
{
AutoTArray
<
nsString
2
>
params
;
params
.
AppendElement
(
)
-
>
AppendInt
(
gWillChangeAreaMultiplier
)
;
nsRect
area
=
pc
-
>
GetVisibleArea
(
)
;
uint32_t
budgetLimit
=
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
area
.
width
)
*
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
area
.
height
)
;
params
.
AppendElement
(
)
-
>
AppendInt
(
budgetLimit
)
;
doc
-
>
WarnOnceAbout
(
Document
:
:
eIgnoringWillChangeOverBudget
false
params
)
;
}
return
false
;
}
void
nsDisplayListBuilder
:
:
ClearWillChangeBudgetStatus
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
IsForPainting
(
)
)
;
if
(
!
aFrame
-
>
MayHaveWillChangeBudget
(
)
)
{
return
;
}
aFrame
-
>
SetMayHaveWillChangeBudget
(
false
)
;
RemoveFromWillChangeBudgets
(
aFrame
)
;
}
void
nsDisplayListBuilder
:
:
RemoveFromWillChangeBudgets
(
const
nsIFrame
*
aFrame
)
{
if
(
auto
entry
=
mFrameWillChangeBudgets
.
Lookup
(
aFrame
)
)
{
const
FrameWillChangeBudget
&
frameBudget
=
entry
.
Data
(
)
;
auto
documentBudget
=
mDocumentWillChangeBudgets
.
Lookup
(
frameBudget
.
mPresContext
)
;
if
(
documentBudget
)
{
*
documentBudget
-
=
frameBudget
.
mUsage
;
}
entry
.
Remove
(
)
;
}
}
void
nsDisplayListBuilder
:
:
ClearWillChangeBudgets
(
)
{
mFrameWillChangeBudgets
.
Clear
(
)
;
mDocumentWillChangeBudgets
.
Clear
(
)
;
}
void
nsDisplayListBuilder
:
:
EnterSVGEffectsContents
(
nsIFrame
*
aEffectsFrame
nsDisplayList
*
aHoistedItemsStorage
)
{
MOZ_ASSERT
(
aHoistedItemsStorage
)
;
if
(
mSVGEffectsFrames
.
IsEmpty
(
)
)
{
MOZ_ASSERT
(
!
mScrollInfoItemsForHoisting
)
;
mScrollInfoItemsForHoisting
=
aHoistedItemsStorage
;
}
mSVGEffectsFrames
.
AppendElement
(
aEffectsFrame
)
;
}
void
nsDisplayListBuilder
:
:
ExitSVGEffectsContents
(
)
{
MOZ_ASSERT
(
!
mSVGEffectsFrames
.
IsEmpty
(
)
)
;
mSVGEffectsFrames
.
RemoveLastElement
(
)
;
MOZ_ASSERT
(
mScrollInfoItemsForHoisting
)
;
if
(
mSVGEffectsFrames
.
IsEmpty
(
)
)
{
mScrollInfoItemsForHoisting
=
nullptr
;
}
}
bool
nsDisplayListBuilder
:
:
ShouldBuildScrollInfoItemsForHoisting
(
)
const
{
for
(
nsIFrame
*
frame
:
mSVGEffectsFrames
)
{
if
(
SVGIntegrationUtils
:
:
UsesSVGEffectsNotSupportedInCompositor
(
frame
)
)
{
return
true
;
}
}
return
false
;
}
void
nsDisplayListBuilder
:
:
AppendNewScrollInfoItemForHoisting
(
nsDisplayScrollInfoLayer
*
aScrollInfoItem
)
{
MOZ_ASSERT
(
ShouldBuildScrollInfoItemsForHoisting
(
)
)
;
MOZ_ASSERT
(
mScrollInfoItemsForHoisting
)
;
mScrollInfoItemsForHoisting
-
>
AppendToTop
(
aScrollInfoItem
)
;
}
void
nsDisplayListBuilder
:
:
BuildCompositorHitTestInfoIfNeeded
(
nsIFrame
*
aFrame
nsDisplayList
*
aList
)
{
MOZ_ASSERT
(
aFrame
)
;
MOZ_ASSERT
(
aList
)
;
if
(
!
BuildCompositorHitTestInfo
(
)
)
{
return
;
}
const
CompositorHitTestInfo
info
=
aFrame
-
>
GetCompositorHitTestInfo
(
this
)
;
if
(
info
!
=
CompositorHitTestInvisibleToHit
)
{
aList
-
>
AppendNewToTop
<
nsDisplayCompositorHitTestInfo
>
(
this
aFrame
)
;
}
}
void
nsDisplayListSet
:
:
MoveTo
(
const
nsDisplayListSet
&
aDestination
)
const
{
aDestination
.
BorderBackground
(
)
-
>
AppendToTop
(
BorderBackground
(
)
)
;
aDestination
.
BlockBorderBackgrounds
(
)
-
>
AppendToTop
(
BlockBorderBackgrounds
(
)
)
;
aDestination
.
Floats
(
)
-
>
AppendToTop
(
Floats
(
)
)
;
aDestination
.
Content
(
)
-
>
AppendToTop
(
Content
(
)
)
;
aDestination
.
PositionedDescendants
(
)
-
>
AppendToTop
(
PositionedDescendants
(
)
)
;
aDestination
.
Outlines
(
)
-
>
AppendToTop
(
Outlines
(
)
)
;
}
nsRect
nsDisplayList
:
:
GetClippedBounds
(
nsDisplayListBuilder
*
aBuilder
)
const
{
nsRect
bounds
;
for
(
nsDisplayItem
*
i
:
*
this
)
{
bounds
.
UnionRect
(
bounds
i
-
>
GetClippedBounds
(
aBuilder
)
)
;
}
return
bounds
;
}
nsRect
nsDisplayList
:
:
GetClippedBoundsWithRespectToASR
(
nsDisplayListBuilder
*
aBuilder
const
ActiveScrolledRoot
*
aASR
nsRect
*
aBuildingRect
)
const
{
nsRect
bounds
;
for
(
nsDisplayItem
*
i
:
*
this
)
{
nsRect
r
=
i
-
>
GetClippedBounds
(
aBuilder
)
;
if
(
aASR
!
=
i
-
>
GetActiveScrolledRoot
(
)
&
&
!
r
.
IsEmpty
(
)
)
{
if
(
Maybe
<
nsRect
>
clip
=
i
-
>
GetClipWithRespectToASR
(
aBuilder
aASR
)
)
{
r
=
clip
.
ref
(
)
;
}
}
if
(
aBuildingRect
)
{
aBuildingRect
-
>
UnionRect
(
*
aBuildingRect
i
-
>
GetBuildingRect
(
)
)
;
}
bounds
.
UnionRect
(
bounds
r
)
;
}
return
bounds
;
}
nsRect
nsDisplayList
:
:
GetBuildingRect
(
)
const
{
nsRect
result
;
for
(
nsDisplayItem
*
i
:
*
this
)
{
result
.
UnionRect
(
result
i
-
>
GetBuildingRect
(
)
)
;
}
return
result
;
}
static
void
TriggerPendingAnimations
(
Document
&
aDoc
const
TimeStamp
&
aReadyTime
)
{
MOZ_ASSERT
(
!
aReadyTime
.
IsNull
(
)
"
Animation
ready
time
is
not
set
.
Perhaps
we
'
re
using
a
layer
"
"
manager
that
doesn
'
t
update
it
"
)
;
if
(
PendingAnimationTracker
*
tracker
=
aDoc
.
GetPendingAnimationTracker
(
)
)
{
PresShell
*
presShell
=
aDoc
.
GetPresShell
(
)
;
if
(
!
presShell
|
|
!
presShell
-
>
IsPaintingSuppressed
(
)
)
{
tracker
-
>
TriggerPendingAnimationsOnNextTick
(
aReadyTime
)
;
}
}
auto
recurse
=
[
&
aReadyTime
]
(
Document
&
aDoc
)
{
TriggerPendingAnimations
(
aDoc
aReadyTime
)
;
return
CallState
:
:
Continue
;
}
;
aDoc
.
EnumerateSubDocuments
(
recurse
)
;
}
WindowRenderer
*
nsDisplayListBuilder
:
:
GetWidgetWindowRenderer
(
nsView
*
*
aView
)
{
if
(
aView
)
{
*
aView
=
RootReferenceFrame
(
)
-
>
GetView
(
)
;
}
if
(
RootReferenceFrame
(
)
!
=
nsLayoutUtils
:
:
GetDisplayRootFrame
(
RootReferenceFrame
(
)
)
)
{
return
nullptr
;
}
nsIWidget
*
window
=
RootReferenceFrame
(
)
-
>
GetNearestWidget
(
)
;
if
(
window
)
{
return
window
-
>
GetWindowRenderer
(
)
;
}
return
nullptr
;
}
WebRenderLayerManager
*
nsDisplayListBuilder
:
:
GetWidgetLayerManager
(
nsView
*
*
aView
)
{
WindowRenderer
*
renderer
=
GetWidgetWindowRenderer
(
)
;
if
(
renderer
)
{
return
renderer
-
>
AsWebRender
(
)
;
}
return
nullptr
;
}
Layer
*
GetLayerForRootMetadata
(
Layer
*
aRootLayer
ScrollableLayerGuid
:
:
ViewID
aRootScrollId
)
{
Layer
*
asyncZoomContainer
=
DepthFirstSearch
<
ForwardIterator
>
(
aRootLayer
[
aRootScrollId
]
(
Layer
*
aLayer
)
{
if
(
auto
id
=
aLayer
-
>
GetAsyncZoomContainerId
(
)
)
{
return
*
id
=
=
aRootScrollId
;
}
return
false
;
}
)
;
return
asyncZoomContainer
?
asyncZoomContainer
:
aRootLayer
;
}
void
nsDisplayList
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
int32_t
aAppUnitsPerDevPixel
)
{
FlattenedDisplayListIterator
iter
(
aBuilder
this
)
;
while
(
iter
.
HasNext
(
)
)
{
nsPaintedDisplayItem
*
item
=
iter
.
GetNextItem
(
)
-
>
AsPaintedDisplayItem
(
)
;
if
(
!
item
)
{
continue
;
}
nsRegion
visible
(
item
-
>
GetClippedBounds
(
aBuilder
)
)
;
visible
.
And
(
visible
item
-
>
GetPaintRect
(
aBuilder
aCtx
)
)
;
if
(
visible
.
IsEmpty
(
)
)
{
continue
;
}
nsRect
buildingRect
=
item
-
>
GetBuildingRect
(
)
;
item
-
>
SetBuildingRect
(
visible
.
GetBounds
(
)
)
;
DisplayItemClip
currentClip
=
item
-
>
GetClip
(
)
;
if
(
currentClip
.
HasClip
(
)
)
{
aCtx
-
>
Save
(
)
;
if
(
currentClip
.
IsRectClippedByRoundedCorner
(
visible
.
GetBounds
(
)
)
)
{
currentClip
.
ApplyTo
(
aCtx
aAppUnitsPerDevPixel
)
;
}
else
{
currentClip
.
ApplyRectTo
(
aCtx
aAppUnitsPerDevPixel
)
;
}
}
aCtx
-
>
NewPath
(
)
;
item
-
>
Paint
(
aBuilder
aCtx
)
;
if
(
currentClip
.
HasClip
(
)
)
{
aCtx
-
>
Restore
(
)
;
}
item
-
>
SetBuildingRect
(
buildingRect
)
;
}
}
void
nsDisplayList
:
:
PaintRoot
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
uint32_t
aFlags
Maybe
<
double
>
aDisplayListBuildTime
)
{
AUTO_PROFILER_LABEL
(
"
nsDisplayList
:
:
PaintRoot
"
GRAPHICS
)
;
RefPtr
<
WebRenderLayerManager
>
layerManager
;
WindowRenderer
*
renderer
=
nullptr
;
bool
widgetTransaction
=
false
;
bool
doBeginTransaction
=
true
;
nsView
*
view
=
nullptr
;
if
(
aFlags
&
PAINT_USE_WIDGET_LAYERS
)
{
renderer
=
aBuilder
-
>
GetWidgetWindowRenderer
(
&
view
)
;
if
(
renderer
)
{
if
(
aCtx
&
&
renderer
-
>
AsFallback
(
)
)
{
MOZ_ASSERT
(
!
(
aFlags
&
PAINT_EXISTING_TRANSACTION
)
)
;
renderer
=
nullptr
;
}
else
{
layerManager
=
renderer
-
>
AsWebRender
(
)
;
doBeginTransaction
=
!
(
aFlags
&
PAINT_EXISTING_TRANSACTION
)
;
widgetTransaction
=
true
;
}
}
}
nsIFrame
*
frame
=
aBuilder
-
>
RootReferenceFrame
(
)
;
nsPresContext
*
presContext
=
frame
-
>
PresContext
(
)
;
PresShell
*
presShell
=
presContext
-
>
PresShell
(
)
;
Document
*
document
=
presShell
-
>
GetDocument
(
)
;
if
(
!
renderer
)
{
if
(
!
aCtx
)
{
NS_WARNING
(
"
Nowhere
to
paint
into
"
)
;
return
;
}
bool
prevIsCompositingCheap
=
aBuilder
-
>
SetIsCompositingCheap
(
false
)
;
Paint
(
aBuilder
aCtx
presContext
-
>
AppUnitsPerDevPixel
(
)
)
;
if
(
document
&
&
document
-
>
IsBeingUsedAsImage
(
)
)
{
frame
-
>
ClearInvalidationStateBits
(
)
;
}
aBuilder
-
>
SetIsCompositingCheap
(
prevIsCompositingCheap
)
;
return
;
}
if
(
renderer
-
>
GetBackendType
(
)
=
=
LayersBackend
:
:
LAYERS_WR
)
{
MOZ_ASSERT
(
layerManager
)
;
if
(
doBeginTransaction
)
{
if
(
aCtx
)
{
if
(
!
layerManager
-
>
BeginTransactionWithTarget
(
aCtx
nsCString
(
)
)
)
{
return
;
}
}
else
{
if
(
!
layerManager
-
>
BeginTransaction
(
nsCString
(
)
)
)
{
return
;
}
}
}
bool
prevIsCompositingCheap
=
aBuilder
-
>
SetIsCompositingCheap
(
true
)
;
layerManager
-
>
SetTransactionIdAllocator
(
presContext
-
>
RefreshDriver
(
)
)
;
bool
sent
=
false
;
if
(
aFlags
&
PAINT_IDENTICAL_DISPLAY_LIST
)
{
sent
=
layerManager
-
>
EndEmptyTransaction
(
)
;
}
if
(
!
sent
)
{
auto
*
wrManager
=
static_cast
<
WebRenderLayerManager
*
>
(
layerManager
.
get
(
)
)
;
nsIDocShell
*
docShell
=
presContext
-
>
GetDocShell
(
)
;
WrFiltersHolder
wrFilters
;
gfx
:
:
Matrix5x4
*
colorMatrix
=
nsDocShell
:
:
Cast
(
docShell
)
-
>
GetColorMatrix
(
)
;
if
(
colorMatrix
)
{
wrFilters
.
filters
.
AppendElement
(
wr
:
:
FilterOp
:
:
ColorMatrix
(
colorMatrix
-
>
components
)
)
;
}
wrManager
-
>
EndTransactionWithoutLayer
(
this
aBuilder
std
:
:
move
(
wrFilters
)
nullptr
aDisplayListBuildTime
.
valueOr
(
0
.
0
)
)
;
}
if
(
widgetTransaction
|
|
(
document
&
&
document
-
>
IsBeingUsedAsImage
(
)
)
)
{
frame
-
>
ClearInvalidationStateBits
(
)
;
}
aBuilder
-
>
SetIsCompositingCheap
(
prevIsCompositingCheap
)
;
if
(
document
&
&
widgetTransaction
)
{
TriggerPendingAnimations
(
*
document
layerManager
-
>
GetAnimationReadyTime
(
)
)
;
}
if
(
presContext
-
>
RefreshDriver
(
)
-
>
HasScheduleFlush
(
)
)
{
presContext
-
>
NotifyInvalidation
(
layerManager
-
>
GetLastTransactionId
(
)
frame
-
>
GetRect
(
)
)
;
}
return
;
}
FallbackRenderer
*
fallback
=
renderer
-
>
AsFallback
(
)
;
MOZ_ASSERT
(
fallback
)
;
if
(
doBeginTransaction
)
{
MOZ_ASSERT
(
!
aCtx
)
;
if
(
!
fallback
-
>
BeginTransaction
(
)
)
{
return
;
}
}
bool
temp
=
aBuilder
-
>
SetIsCompositingCheap
(
renderer
-
>
IsCompositingCheap
(
)
)
;
fallback
-
>
EndTransactionWithList
(
aBuilder
this
presContext
-
>
AppUnitsPerDevPixel
(
)
LayerManager
:
:
END_DEFAULT
)
;
if
(
widgetTransaction
|
|
(
document
&
&
document
-
>
IsBeingUsedAsImage
(
)
)
)
{
frame
-
>
ClearInvalidationStateBits
(
)
;
}
aBuilder
-
>
SetIsCompositingCheap
(
temp
)
;
if
(
document
&
&
widgetTransaction
)
{
TriggerPendingAnimations
(
*
document
renderer
-
>
GetAnimationReadyTime
(
)
)
;
}
}
nsDisplayItem
*
nsDisplayList
:
:
RemoveBottom
(
)
{
nsDisplayItem
*
item
=
mSentinel
.
mAbove
;
if
(
!
item
)
{
return
nullptr
;
}
mSentinel
.
mAbove
=
item
-
>
mAbove
;
if
(
item
=
=
mTop
)
{
mTop
=
&
mSentinel
;
}
item
-
>
mAbove
=
nullptr
;
mLength
-
-
;
return
item
;
}
void
nsDisplayList
:
:
DeleteAll
(
nsDisplayListBuilder
*
aBuilder
)
{
nsDisplayItem
*
item
;
while
(
(
item
=
RemoveBottom
(
)
)
!
=
nullptr
)
{
item
-
>
Destroy
(
aBuilder
)
;
}
}
static
bool
IsFrameReceivingPointerEvents
(
nsIFrame
*
aFrame
)
{
return
StylePointerEvents
:
:
None
!
=
aFrame
-
>
StyleUI
(
)
-
>
GetEffectivePointerEvents
(
aFrame
)
;
}
struct
FramesWithDepth
{
explicit
FramesWithDepth
(
float
aDepth
)
:
mDepth
(
aDepth
)
{
}
bool
operator
<
(
const
FramesWithDepth
&
aOther
)
const
{
if
(
!
FuzzyEqual
(
mDepth
aOther
.
mDepth
0
.
1f
)
)
{
return
mDepth
>
aOther
.
mDepth
;
}
return
this
<
&
aOther
;
}
bool
operator
=
=
(
const
FramesWithDepth
&
aOther
)
const
{
return
this
=
=
&
aOther
;
}
float
mDepth
;
nsTArray
<
nsIFrame
*
>
mFrames
;
}
;
static
void
FlushFramesArray
(
nsTArray
<
FramesWithDepth
>
&
aSource
nsTArray
<
nsIFrame
*
>
*
aDest
)
{
if
(
aSource
.
IsEmpty
(
)
)
{
return
;
}
aSource
.
Sort
(
)
;
uint32_t
length
=
aSource
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
length
;
i
+
+
)
{
aDest
-
>
AppendElements
(
std
:
:
move
(
aSource
[
i
]
.
mFrames
)
)
;
}
aSource
.
Clear
(
)
;
}
void
nsDisplayList
:
:
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
nsDisplayItem
:
:
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
const
{
nsDisplayItem
*
item
;
if
(
aState
-
>
mInPreserves3D
)
{
for
(
nsDisplayItem
*
item
:
*
this
)
{
auto
itemType
=
item
-
>
GetType
(
)
;
if
(
itemType
!
=
DisplayItemType
:
:
TYPE_TRANSFORM
|
|
!
static_cast
<
nsDisplayTransform
*
>
(
item
)
-
>
IsLeafOf3DContext
(
)
)
{
item
-
>
HitTest
(
aBuilder
aRect
aState
aOutFrames
)
;
}
else
{
aState
-
>
mItemBuffer
.
AppendElement
(
item
)
;
}
}
return
;
}
int32_t
itemBufferStart
=
aState
-
>
mItemBuffer
.
Length
(
)
;
for
(
nsDisplayItem
*
item
:
*
this
)
{
aState
-
>
mItemBuffer
.
AppendElement
(
item
)
;
}
AutoTArray
<
FramesWithDepth
16
>
temp
;
for
(
int32_t
i
=
aState
-
>
mItemBuffer
.
Length
(
)
-
1
;
i
>
=
itemBufferStart
;
-
-
i
)
{
item
=
aState
-
>
mItemBuffer
[
i
]
;
aState
-
>
mItemBuffer
.
SetLength
(
i
)
;
bool
snap
;
nsRect
r
=
item
-
>
GetBounds
(
aBuilder
&
snap
)
.
Intersect
(
aRect
)
;
auto
itemType
=
item
-
>
GetType
(
)
;
bool
same3DContext
=
(
itemType
=
=
DisplayItemType
:
:
TYPE_TRANSFORM
&
&
static_cast
<
nsDisplayTransform
*
>
(
item
)
-
>
IsParticipating3DContext
(
)
)
|
|
(
itemType
=
=
DisplayItemType
:
:
TYPE_PERSPECTIVE
&
&
item
-
>
Frame
(
)
-
>
Extend3DContext
(
)
)
;
if
(
same3DContext
&
&
(
itemType
!
=
DisplayItemType
:
:
TYPE_TRANSFORM
|
|
!
static_cast
<
nsDisplayTransform
*
>
(
item
)
-
>
IsLeafOf3DContext
(
)
)
)
{
if
(
!
item
-
>
GetClip
(
)
.
MayIntersect
(
aRect
)
)
{
continue
;
}
AutoTArray
<
nsIFrame
*
1
>
neverUsed
;
aState
-
>
mInPreserves3D
=
true
;
item
-
>
HitTest
(
aBuilder
aRect
aState
&
neverUsed
)
;
aState
-
>
mInPreserves3D
=
false
;
i
=
aState
-
>
mItemBuffer
.
Length
(
)
;
continue
;
}
if
(
same3DContext
|
|
item
-
>
GetClip
(
)
.
MayIntersect
(
r
)
)
{
AutoTArray
<
nsIFrame
*
16
>
outFrames
;
item
-
>
HitTest
(
aBuilder
aRect
aState
&
outFrames
)
;
nsTArray
<
nsIFrame
*
>
*
writeFrames
=
aOutFrames
;
if
(
item
-
>
GetType
(
)
=
=
DisplayItemType
:
:
TYPE_TRANSFORM
&
&
static_cast
<
nsDisplayTransform
*
>
(
item
)
-
>
IsLeafOf3DContext
(
)
)
{
if
(
outFrames
.
Length
(
)
)
{
nsDisplayTransform
*
transform
=
static_cast
<
nsDisplayTransform
*
>
(
item
)
;
nsPoint
point
=
aRect
.
TopLeft
(
)
;
if
(
aRect
.
width
!
=
1
|
|
aRect
.
height
!
=
1
)
{
point
=
aRect
.
Center
(
)
;
}
temp
.
AppendElement
(
FramesWithDepth
(
transform
-
>
GetHitDepthAtPoint
(
aBuilder
point
)
)
)
;
writeFrames
=
&
temp
[
temp
.
Length
(
)
-
1
]
.
mFrames
;
}
}
else
{
FlushFramesArray
(
temp
aOutFrames
)
;
}
for
(
uint32_t
j
=
0
;
j
<
outFrames
.
Length
(
)
;
j
+
+
)
{
nsIFrame
*
f
=
outFrames
.
ElementAt
(
j
)
;
if
(
aBuilder
-
>
HitTestIsForVisibility
(
)
|
|
IsFrameReceivingPointerEvents
(
f
)
)
{
writeFrames
-
>
AppendElement
(
f
)
;
}
}
if
(
aBuilder
-
>
HitTestIsForVisibility
(
)
)
{
aState
-
>
mHitOccludingItem
=
[
&
]
{
if
(
aState
-
>
mHitOccludingItem
)
{
return
true
;
}
if
(
aState
-
>
mCurrentOpacity
=
=
1
.
0f
&
&
item
-
>
GetOpaqueRegion
(
aBuilder
&
snap
)
.
Contains
(
aRect
)
)
{
return
true
;
}
float
threshold
=
aBuilder
-
>
VisibilityThreshold
(
)
;
if
(
threshold
=
=
1
.
0f
)
{
return
false
;
}
float
itemOpacity
=
[
&
]
{
switch
(
item
-
>
GetType
(
)
)
{
case
DisplayItemType
:
:
TYPE_OPACITY
:
return
static_cast
<
nsDisplayOpacity
*
>
(
item
)
-
>
GetOpacity
(
)
;
case
DisplayItemType
:
:
TYPE_BACKGROUND_COLOR
:
return
static_cast
<
nsDisplayBackgroundColor
*
>
(
item
)
-
>
GetOpacity
(
)
;
default
:
return
0
.
0f
;
}
}
(
)
;
return
itemOpacity
*
aState
-
>
mCurrentOpacity
>
=
threshold
;
}
(
)
;
if
(
aState
-
>
mHitOccludingItem
)
{
aState
-
>
mItemBuffer
.
TruncateLength
(
itemBufferStart
)
;
break
;
}
}
}
}
FlushFramesArray
(
temp
aOutFrames
)
;
NS_ASSERTION
(
aState
-
>
mItemBuffer
.
Length
(
)
=
=
uint32_t
(
itemBufferStart
)
"
How
did
we
forget
to
pop
some
elements
?
"
)
;
}
static
nsIContent
*
FindContentInDocument
(
nsDisplayItem
*
aItem
Document
*
aDoc
)
{
nsIFrame
*
f
=
aItem
-
>
Frame
(
)
;
while
(
f
)
{
nsPresContext
*
pc
=
f
-
>
PresContext
(
)
;
if
(
pc
-
>
Document
(
)
=
=
aDoc
)
{
return
f
-
>
GetContent
(
)
;
}
f
=
nsLayoutUtils
:
:
GetCrossDocParentFrameInProcess
(
pc
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
)
;
}
return
nullptr
;
}
struct
ZSortItem
{
nsDisplayItem
*
item
;
int32_t
zIndex
;
explicit
ZSortItem
(
nsDisplayItem
*
aItem
)
:
item
(
aItem
)
zIndex
(
aItem
-
>
ZIndex
(
)
)
{
}
operator
nsDisplayItem
*
(
)
{
return
item
;
}
}
;
struct
ZOrderComparator
{
bool
operator
(
)
(
const
ZSortItem
&
aLeft
const
ZSortItem
&
aRight
)
const
{
return
aLeft
.
zIndex
<
aRight
.
zIndex
;
}
}
;
void
nsDisplayList
:
:
SortByZOrder
(
)
{
Sort
<
ZSortItem
>
(
ZOrderComparator
(
)
)
;
}
struct
ContentComparator
{
nsIContent
*
mCommonAncestor
;
explicit
ContentComparator
(
nsIContent
*
aCommonAncestor
)
:
mCommonAncestor
(
aCommonAncestor
)
{
}
bool
operator
(
)
(
nsDisplayItem
*
aLeft
nsDisplayItem
*
aRight
)
const
{
Document
*
commonAncestorDoc
=
mCommonAncestor
-
>
OwnerDoc
(
)
;
nsIContent
*
content1
=
FindContentInDocument
(
aLeft
commonAncestorDoc
)
;
nsIContent
*
content2
=
FindContentInDocument
(
aRight
commonAncestorDoc
)
;
if
(
!
content1
|
|
!
content2
)
{
NS_ERROR
(
"
Document
trees
are
mixed
up
!
"
)
;
return
true
;
}
return
nsLayoutUtils
:
:
CompareTreePosition
(
content1
content2
mCommonAncestor
)
<
0
;
}
}
;
void
nsDisplayList
:
:
SortByContentOrder
(
nsIContent
*
aCommonAncestor
)
{
Sort
<
nsDisplayItem
*
>
(
ContentComparator
(
aCommonAncestor
)
)
;
}
#
if
!
defined
(
DEBUG
)
&
&
!
defined
(
MOZ_DIAGNOSTIC_ASSERT_ENABLED
)
static_assert
(
sizeof
(
nsDisplayItem
)
<
=
176
"
nsDisplayItem
has
grown
"
)
;
#
endif
nsDisplayItem
:
:
nsDisplayItem
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
:
nsDisplayItem
(
aBuilder
aFrame
aBuilder
-
>
CurrentActiveScrolledRoot
(
)
)
{
}
nsDisplayItem
:
:
nsDisplayItem
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
ActiveScrolledRoot
*
aActiveScrolledRoot
)
:
mFrame
(
aFrame
)
mActiveScrolledRoot
(
aActiveScrolledRoot
)
{
MOZ_COUNT_CTOR
(
nsDisplayItem
)
;
MOZ_ASSERT
(
mFrame
)
;
if
(
aBuilder
-
>
IsRetainingDisplayList
(
)
)
{
mFrame
-
>
AddDisplayItem
(
this
)
;
}
aBuilder
-
>
FindReferenceFrameFor
(
aFrame
&
mToReferenceFrame
)
;
NS_ASSERTION
(
aBuilder
-
>
GetVisibleRect
(
)
.
width
>
=
0
|
|
!
aBuilder
-
>
IsForPainting
(
)
"
visible
rect
not
set
"
)
;
mClipChain
=
aBuilder
-
>
ClipState
(
)
.
GetCurrentCombinedClipChain
(
aBuilder
)
;
nsRect
visible
=
aBuilder
-
>
GetVisibleRect
(
)
+
aBuilder
-
>
GetCurrentFrameOffsetToReferenceFrame
(
)
;
SetBuildingRect
(
visible
)
;
const
nsStyleDisplay
*
disp
=
mFrame
-
>
StyleDisplay
(
)
;
if
(
mFrame
-
>
BackfaceIsHidden
(
disp
)
)
{
mItemFlags
+
=
ItemFlag
:
:
BackfaceHidden
;
}
if
(
mFrame
-
>
Combines3DTransformWithAncestors
(
)
)
{
mItemFlags
+
=
ItemFlag
:
:
Combines3DTransformWithAncestors
;
}
}
void
nsDisplayItem
:
:
SetDeletedFrame
(
)
{
mItemFlags
+
=
ItemFlag
:
:
DeletedFrame
;
}
bool
nsDisplayItem
:
:
HasDeletedFrame
(
)
const
{
bool
retval
=
mItemFlags
.
contains
(
ItemFlag
:
:
DeletedFrame
)
|
|
(
GetType
(
)
=
=
DisplayItemType
:
:
TYPE_REMOTE
&
&
!
static_cast
<
const
nsDisplayRemote
*
>
(
this
)
-
>
GetFrameLoader
(
)
)
;
MOZ_ASSERT
(
retval
|
|
mFrame
)
;
return
retval
;
}
bool
nsDisplayItem
:
:
ForceActiveLayers
(
)
{
return
StaticPrefs
:
:
layers_force_active
(
)
;
}
int32_t
nsDisplayItem
:
:
ZIndex
(
)
const
{
return
mFrame
-
>
ZIndex
(
)
.
valueOr
(
0
)
;
}
void
nsDisplayItem
:
:
SetClipChain
(
const
DisplayItemClipChain
*
aClipChain
bool
aStore
)
{
mClipChain
=
aClipChain
;
}
Maybe
<
nsRect
>
nsDisplayItem
:
:
GetClipWithRespectToASR
(
nsDisplayListBuilder
*
aBuilder
const
ActiveScrolledRoot
*
aASR
)
const
{
if
(
const
DisplayItemClip
*
clip
=
DisplayItemClipChain
:
:
ClipForASR
(
GetClipChain
(
)
aASR
)
)
{
return
Some
(
clip
-
>
GetClipRect
(
)
)
;
}
#
ifdef
DEBUG
MOZ_ASSERT
(
false
"
item
should
have
finite
clip
with
respect
to
aASR
"
)
;
#
endif
return
Nothing
(
)
;
}
const
DisplayItemClip
&
nsDisplayItem
:
:
GetClip
(
)
const
{
const
DisplayItemClip
*
clip
=
DisplayItemClipChain
:
:
ClipForASR
(
mClipChain
mActiveScrolledRoot
)
;
return
clip
?
*
clip
:
DisplayItemClip
:
:
NoClip
(
)
;
}
void
nsDisplayItem
:
:
IntersectClip
(
nsDisplayListBuilder
*
aBuilder
const
DisplayItemClipChain
*
aOther
bool
aStore
)
{
if
(
!
aOther
|
|
mClipChain
=
=
aOther
)
{
return
;
}
const
DisplayItemClipChain
*
ancestorClip
=
mClipChain
?
FindCommonAncestorClipForIntersection
(
mClipChain
aOther
)
:
nullptr
;
SetClipChain
(
aBuilder
-
>
CreateClipChainIntersection
(
ancestorClip
mClipChain
aOther
)
aStore
)
;
}
nsRect
nsDisplayItem
:
:
GetClippedBounds
(
nsDisplayListBuilder
*
aBuilder
)
const
{
bool
snap
;
nsRect
r
=
GetBounds
(
aBuilder
&
snap
)
;
return
GetClip
(
)
.
ApplyNonRoundedIntersection
(
r
)
;
}
nsDisplayContainer
:
:
nsDisplayContainer
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
ActiveScrolledRoot
*
aActiveScrolledRoot
nsDisplayList
*
aList
)
:
nsDisplayItem
(
aBuilder
aFrame
aActiveScrolledRoot
)
{
MOZ_COUNT_CTOR
(
nsDisplayContainer
)
;
mChildren
.
AppendToTop
(
aList
)
;
UpdateBounds
(
aBuilder
)
;
nsDisplayItem
:
:
SetClipChain
(
nullptr
true
)
;
}
nsRect
nsDisplayItem
:
:
GetPaintRect
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
bool
dummy
;
nsRect
result
=
GetBounds
(
aBuilder
&
dummy
)
;
if
(
aCtx
)
{
result
.
IntersectRect
(
result
nsLayoutUtils
:
:
RoundGfxRectToAppRect
(
aCtx
-
>
GetClipExtents
(
)
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
)
;
}
return
result
;
}
bool
nsDisplayContainer
:
:
CreateWebRenderCommands
(
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
aManager
-
>
CommandBuilder
(
)
.
CreateWebRenderCommandsFromDisplayList
(
GetChildren
(
)
this
aDisplayListBuilder
aSc
aBuilder
aResources
)
;
return
true
;
}
nsRect
nsDisplayContainer
:
:
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
{
*
aSnap
=
false
;
return
mBounds
;
}
nsRect
nsDisplayContainer
:
:
GetComponentAlphaBounds
(
nsDisplayListBuilder
*
aBuilder
)
const
{
return
mChildren
.
GetComponentAlphaBounds
(
aBuilder
)
;
}
static
nsRegion
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
const
nsRect
&
aListBounds
)
{
return
aList
-
>
GetOpaqueRegion
(
aBuilder
)
;
}
nsRegion
nsDisplayContainer
:
:
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
{
return
:
:
mozilla
:
:
GetOpaqueRegion
(
aBuilder
GetChildren
(
)
GetBounds
(
aBuilder
aSnap
)
)
;
}
Maybe
<
nsRect
>
nsDisplayContainer
:
:
GetClipWithRespectToASR
(
nsDisplayListBuilder
*
aBuilder
const
ActiveScrolledRoot
*
aASR
)
const
{
if
(
aASR
=
=
mActiveScrolledRoot
)
{
return
Some
(
mBounds
)
;
}
return
Some
(
mChildren
.
GetClippedBoundsWithRespectToASR
(
aBuilder
aASR
)
)
;
}
void
nsDisplayContainer
:
:
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
{
mChildren
.
HitTest
(
aBuilder
aRect
aState
aOutFrames
)
;
}
void
nsDisplayContainer
:
:
UpdateBounds
(
nsDisplayListBuilder
*
aBuilder
)
{
mBounds
=
mChildren
.
GetClippedBoundsWithRespectToASR
(
aBuilder
mActiveScrolledRoot
)
;
}
nsRect
nsDisplaySolidColor
:
:
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
{
*
aSnap
=
true
;
return
mBounds
;
}
void
nsDisplaySolidColor
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
int32_t
appUnitsPerDevPixel
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
DrawTarget
*
drawTarget
=
aCtx
-
>
GetDrawTarget
(
)
;
Rect
rect
=
NSRectToSnappedRect
(
GetPaintRect
(
aBuilder
aCtx
)
appUnitsPerDevPixel
*
drawTarget
)
;
drawTarget
-
>
FillRect
(
rect
ColorPattern
(
ToDeviceColor
(
mColor
)
)
)
;
}
void
nsDisplaySolidColor
:
:
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
{
aStream
<
<
"
(
rgba
"
<
<
(
int
)
NS_GET_R
(
mColor
)
<
<
"
"
<
<
(
int
)
NS_GET_G
(
mColor
)
<
<
"
"
<
<
(
int
)
NS_GET_B
(
mColor
)
<
<
"
"
<
<
(
int
)
NS_GET_A
(
mColor
)
<
<
"
)
"
;
}
bool
nsDisplaySolidColor
:
:
CreateWebRenderCommands
(
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
LayoutDeviceRect
bounds
=
LayoutDeviceRect
:
:
FromAppUnits
(
mBounds
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
wr
:
:
LayoutRect
r
=
wr
:
:
ToLayoutRect
(
bounds
)
;
aBuilder
.
PushRect
(
r
r
!
BackfaceIsHidden
(
)
wr
:
:
ToColorF
(
ToDeviceColor
(
mColor
)
)
)
;
return
true
;
}
nsRect
nsDisplaySolidColorRegion
:
:
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
{
*
aSnap
=
true
;
return
mRegion
.
GetBounds
(
)
;
}
void
nsDisplaySolidColorRegion
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
int32_t
appUnitsPerDevPixel
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
DrawTarget
*
drawTarget
=
aCtx
-
>
GetDrawTarget
(
)
;
ColorPattern
color
(
ToDeviceColor
(
mColor
)
)
;
for
(
auto
iter
=
mRegion
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
Rect
rect
=
NSRectToSnappedRect
(
iter
.
Get
(
)
appUnitsPerDevPixel
*
drawTarget
)
;
drawTarget
-
>
FillRect
(
rect
color
)
;
}
}
void
nsDisplaySolidColorRegion
:
:
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
{
aStream
<
<
"
(
rgba
"
<
<
int
(
mColor
.
r
*
255
)
<
<
"
"
<
<
int
(
mColor
.
g
*
255
)
<
<
"
"
<
<
int
(
mColor
.
b
*
255
)
<
<
"
"
<
<
mColor
.
a
<
<
"
)
"
;
}
bool
nsDisplaySolidColorRegion
:
:
CreateWebRenderCommands
(
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
for
(
auto
iter
=
mRegion
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsRect
rect
=
iter
.
Get
(
)
;
LayoutDeviceRect
layerRects
=
LayoutDeviceRect
:
:
FromAppUnits
(
rect
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
wr
:
:
LayoutRect
r
=
wr
:
:
ToLayoutRect
(
layerRects
)
;
aBuilder
.
PushRect
(
r
r
!
BackfaceIsHidden
(
)
wr
:
:
ToColorF
(
ToDeviceColor
(
mColor
)
)
)
;
}
return
true
;
}
static
void
RegisterThemeGeometry
(
nsDisplayListBuilder
*
aBuilder
nsDisplayItem
*
aItem
nsIFrame
*
aFrame
nsITheme
:
:
ThemeGeometryType
aType
)
{
if
(
aBuilder
-
>
IsInChromeDocumentOrPopup
(
)
)
{
nsIFrame
*
displayRoot
=
nsLayoutUtils
:
:
GetDisplayRootFrame
(
aFrame
)
;
bool
preservesAxisAlignedRectangles
=
false
;
nsRect
borderBox
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
aFrame
aFrame
-
>
GetRectRelativeToSelf
(
)
displayRoot
&
preservesAxisAlignedRectangles
)
;
if
(
preservesAxisAlignedRectangles
)
{
aBuilder
-
>
RegisterThemeGeometry
(
aType
aItem
LayoutDeviceIntRect
:
:
FromUnknownRect
(
borderBox
.
ToNearestPixels
(
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
)
)
;
}
}
}
static
Maybe
<
nsRect
>
GetViewportRectRelativeToReferenceFrame
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
{
nsIFrame
*
rootFrame
=
aFrame
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
;
nsRect
rootRect
=
rootFrame
-
>
GetRectRelativeToSelf
(
)
;
if
(
nsLayoutUtils
:
:
TransformRect
(
rootFrame
aFrame
rootRect
)
=
=
nsLayoutUtils
:
:
TRANSFORM_SUCCEEDED
)
{
return
Some
(
rootRect
+
aBuilder
-
>
ToReferenceFrame
(
aFrame
)
)
;
}
return
Nothing
(
)
;
}
nsDisplayBackgroundImage
:
:
InitData
nsDisplayBackgroundImage
:
:
GetInitData
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
uint16_t
aLayer
const
nsRect
&
aBackgroundRect
ComputedStyle
*
aBackgroundStyle
)
{
nsPresContext
*
presContext
=
aFrame
-
>
PresContext
(
)
;
uint32_t
flags
=
aBuilder
-
>
GetBackgroundPaintFlags
(
)
;
const
nsStyleImageLayers
:
:
Layer
&
layer
=
aBackgroundStyle
-
>
StyleBackground
(
)
-
>
mImage
.
mLayers
[
aLayer
]
;
bool
isTransformedFixed
;
nsBackgroundLayerState
state
=
nsCSSRendering
:
:
PrepareImageLayer
(
presContext
aFrame
flags
aBackgroundRect
aBackgroundRect
layer
&
isTransformedFixed
)
;
bool
shouldTreatAsFixed
=
layer
.
mAttachment
=
=
StyleImageLayerAttachment
:
:
Fixed
&
&
!
isTransformedFixed
;
bool
shouldFixToViewport
=
shouldTreatAsFixed
&
&
!
layer
.
mImage
.
IsNone
(
)
;
bool
isRasterImage
=
state
.
mImageRenderer
.
IsRasterImage
(
)
;
nsCOMPtr
<
imgIContainer
>
image
;
if
(
isRasterImage
)
{
image
=
state
.
mImageRenderer
.
GetImage
(
)
;
}
return
InitData
{
aBuilder
aBackgroundStyle
image
aBackgroundRect
state
.
mFillArea
state
.
mDestArea
aLayer
isRasterImage
shouldFixToViewport
}
;
}
nsDisplayBackgroundImage
:
:
nsDisplayBackgroundImage
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
InitData
&
aInitData
nsIFrame
*
aFrameForBounds
)
:
nsPaintedDisplayItem
(
aBuilder
aFrame
)
mBackgroundStyle
(
aInitData
.
backgroundStyle
)
mImage
(
aInitData
.
image
)
mDependentFrame
(
nullptr
)
mBackgroundRect
(
aInitData
.
backgroundRect
)
mFillRect
(
aInitData
.
fillArea
)
mDestRect
(
aInitData
.
destArea
)
mLayer
(
aInitData
.
layer
)
mIsRasterImage
(
aInitData
.
isRasterImage
)
mShouldFixToViewport
(
aInitData
.
shouldFixToViewport
)
{
MOZ_COUNT_CTOR
(
nsDisplayBackgroundImage
)
;
#
ifdef
DEBUG
if
(
mBackgroundStyle
&
&
mBackgroundStyle
!
=
mFrame
-
>
Style
(
)
)
{
MOZ_ASSERT
(
mFrame
-
>
IsCanvasFrame
(
)
|
|
mFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eTablePart
)
)
;
}
#
endif
mBounds
=
GetBoundsInternal
(
aInitData
.
builder
aFrameForBounds
)
;
if
(
mShouldFixToViewport
)
{
if
(
Maybe
<
nsRect
>
viewportRect
=
GetViewportRectRelativeToReferenceFrame
(
aInitData
.
builder
mFrame
)
)
{
SetBuildingRect
(
mBounds
.
Intersect
(
*
viewportRect
)
)
;
}
}
}
nsDisplayBackgroundImage
:
:
~
nsDisplayBackgroundImage
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayBackgroundImage
)
;
if
(
mDependentFrame
)
{
mDependentFrame
-
>
RemoveDisplayItem
(
this
)
;
}
}
static
nsIFrame
*
GetBackgroundComputedStyleFrame
(
nsIFrame
*
aFrame
)
{
nsIFrame
*
f
;
if
(
!
nsCSSRendering
:
:
FindBackgroundFrame
(
aFrame
&
f
)
)
{
if
(
!
aFrame
-
>
StyleDisplay
(
)
-
>
HasAppearance
(
)
)
{
return
nullptr
;
}
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
!
content
|
|
content
-
>
GetParent
(
)
)
{
return
nullptr
;
}
f
=
aFrame
;
}
return
f
;
}
static
void
SetBackgroundClipRegion
(
DisplayListClipState
:
:
AutoSaveRestore
&
aClipState
nsIFrame
*
aFrame
const
nsStyleImageLayers
:
:
Layer
&
aLayer
const
nsRect
&
aBackgroundRect
bool
aWillPaintBorder
)
{
nsCSSRendering
:
:
ImageLayerClipState
clip
;
nsCSSRendering
:
:
GetImageLayerClip
(
aLayer
aFrame
*
aFrame
-
>
StyleBorder
(
)
aBackgroundRect
aBackgroundRect
aWillPaintBorder
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
&
clip
)
;
if
(
clip
.
mHasAdditionalBGClipArea
)
{
aClipState
.
ClipContentDescendants
(
clip
.
mAdditionalBGClipArea
clip
.
mBGClipArea
clip
.
mHasRoundedCorners
?
clip
.
mRadii
:
nullptr
)
;
}
else
{
aClipState
.
ClipContentDescendants
(
clip
.
mBGClipArea
clip
.
mHasRoundedCorners
?
clip
.
mRadii
:
nullptr
)
;
}
}
static
bool
SpecialCutoutRegionCase
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
nsRect
&
aBackgroundRect
nsDisplayList
*
aList
nscolor
aColor
)
{
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
!
content
)
{
return
false
;
}
void
*
cutoutRegion
=
content
-
>
GetProperty
(
nsGkAtoms
:
:
cutoutregion
)
;
if
(
!
cutoutRegion
)
{
return
false
;
}
if
(
NS_GET_A
(
aColor
)
=
=
0
)
{
return
true
;
}
nsRegion
region
;
region
.
Sub
(
aBackgroundRect
*
static_cast
<
nsRegion
*
>
(
cutoutRegion
)
)
;
region
.
MoveBy
(
aBuilder
-
>
ToReferenceFrame
(
aFrame
)
)
;
aList
-
>
AppendNewToTop
<
nsDisplaySolidColorRegion
>
(
aBuilder
aFrame
region
aColor
)
;
return
true
;
}
enum
class
TableType
:
uint8_t
{
Table
TableCol
TableColGroup
TableRow
TableRowGroup
TableCell
MAX
}
;
enum
class
TableTypeBits
:
uint8_t
{
Count
=
3
}
;
static_assert
(
static_cast
<
uint8_t
>
(
TableType
:
:
MAX
)
<
(
1
<
<
(
static_cast
<
uint8_t
>
(
TableTypeBits
:
:
Count
)
+
1
)
)
"
TableType
cannot
fit
with
TableTypeBits
:
:
Count
"
)
;
TableType
GetTableTypeFromFrame
(
nsIFrame
*
aFrame
)
;
static
uint16_t
CalculateTablePerFrameKey
(
const
uint16_t
aIndex
const
TableType
aType
)
{
const
uint32_t
key
=
(
aIndex
<
<
static_cast
<
uint8_t
>
(
TableTypeBits
:
:
Count
)
)
|
static_cast
<
uint8_t
>
(
aType
)
;
return
static_cast
<
uint16_t
>
(
key
)
;
}
static
nsDisplayBackgroundImage
*
CreateBackgroundImage
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsIFrame
*
aSecondaryFrame
const
nsDisplayBackgroundImage
:
:
InitData
&
aBgData
)
{
const
auto
index
=
aBgData
.
layer
;
if
(
aSecondaryFrame
)
{
const
auto
tableType
=
GetTableTypeFromFrame
(
aFrame
)
;
const
uint16_t
tableItemIndex
=
CalculateTablePerFrameKey
(
index
tableType
)
;
return
MakeDisplayItemWithIndex
<
nsDisplayTableBackgroundImage
>
(
aBuilder
aSecondaryFrame
tableItemIndex
aBgData
aFrame
)
;
}
return
MakeDisplayItemWithIndex
<
nsDisplayBackgroundImage
>
(
aBuilder
aFrame
index
aBgData
)
;
}
static
nsDisplayThemedBackground
*
CreateThemedBackground
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsIFrame
*
aSecondaryFrame
nsRect
&
aBgRect
)
{
if
(
aSecondaryFrame
)
{
const
uint16_t
index
=
static_cast
<
uint16_t
>
(
GetTableTypeFromFrame
(
aFrame
)
)
;
return
MakeDisplayItemWithIndex
<
nsDisplayTableThemedBackground
>
(
aBuilder
aSecondaryFrame
index
aBgRect
aFrame
)
;
}
return
MakeDisplayItem
<
nsDisplayThemedBackground
>
(
aBuilder
aFrame
aBgRect
)
;
}
static
nsDisplayBackgroundColor
*
CreateBackgroundColor
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsIFrame
*
aSecondaryFrame
nsRect
&
aBgRect
ComputedStyle
*
aBgSC
nscolor
aColor
)
{
if
(
aSecondaryFrame
)
{
const
uint16_t
index
=
static_cast
<
uint16_t
>
(
GetTableTypeFromFrame
(
aFrame
)
)
;
return
MakeDisplayItemWithIndex
<
nsDisplayTableBackgroundColor
>
(
aBuilder
aSecondaryFrame
index
aBgRect
aBgSC
aColor
aFrame
)
;
}
return
MakeDisplayItem
<
nsDisplayBackgroundColor
>
(
aBuilder
aFrame
aBgRect
aBgSC
aColor
)
;
}
AppendedBackgroundType
nsDisplayBackgroundImage
:
:
AppendBackgroundItemsToTop
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
nsRect
&
aBackgroundRect
nsDisplayList
*
aList
bool
aAllowWillPaintBorderOptimization
ComputedStyle
*
aComputedStyle
const
nsRect
&
aBackgroundOriginRect
nsIFrame
*
aSecondaryReferenceFrame
Maybe
<
nsDisplayListBuilder
:
:
AutoBuildingDisplayList
>
*
aAutoBuildingDisplayList
)
{
ComputedStyle
*
bgSC
=
aComputedStyle
;
const
nsStyleBackground
*
bg
=
nullptr
;
nsRect
bgRect
=
aBackgroundRect
;
nsRect
bgOriginRect
=
bgRect
;
if
(
!
aBackgroundOriginRect
.
IsEmpty
(
)
)
{
bgOriginRect
=
aBackgroundOriginRect
;
}
nsPresContext
*
presContext
=
aFrame
-
>
PresContext
(
)
;
bool
isThemed
=
aFrame
-
>
IsThemed
(
)
;
nsIFrame
*
dependentFrame
=
nullptr
;
if
(
!
isThemed
)
{
if
(
!
bgSC
)
{
dependentFrame
=
GetBackgroundComputedStyleFrame
(
aFrame
)
;
if
(
dependentFrame
)
{
bgSC
=
dependentFrame
-
>
Style
(
)
;
if
(
dependentFrame
=
=
aFrame
)
{
dependentFrame
=
nullptr
;
}
}
}
if
(
bgSC
)
{
bg
=
bgSC
-
>
StyleBackground
(
)
;
}
}
bool
drawBackgroundColor
=
false
;
bool
drawBackgroundImage
=
aFrame
-
>
IsXULRootFrame
(
)
&
&
aFrame
-
>
ComputeShouldPaintBackground
(
)
.
mImage
;
nscolor
color
=
NS_RGBA
(
0
0
0
0
)
;
if
(
!
nsCSSRendering
:
:
IsCanvasFrame
(
aFrame
)
&
&
bg
)
{
color
=
nsCSSRendering
:
:
DetermineBackgroundColor
(
presContext
bgSC
aFrame
drawBackgroundImage
drawBackgroundColor
)
;
}
if
(
SpecialCutoutRegionCase
(
aBuilder
aFrame
aBackgroundRect
aList
color
)
)
{
return
AppendedBackgroundType
:
:
None
;
}
const
nsStyleBorder
*
borderStyle
=
aFrame
-
>
StyleBorder
(
)
;
const
nsStyleEffects
*
effectsStyle
=
aFrame
-
>
StyleEffects
(
)
;
bool
hasInsetShadow
=
effectsStyle
-
>
HasBoxShadowWithInset
(
true
)
;
bool
willPaintBorder
=
aAllowWillPaintBorderOptimization
&
&
!
isThemed
&
&
!
hasInsetShadow
&
&
borderStyle
-
>
HasBorder
(
)
;
nsDisplayList
bgItemList
;
if
(
(
drawBackgroundColor
&
&
color
!
=
NS_RGBA
(
0
0
0
0
)
)
|
|
aBuilder
-
>
IsForEventDelivery
(
)
|
|
EffectCompositor
:
:
HasAnimationsForCompositor
(
aFrame
DisplayItemType
:
:
TYPE_BACKGROUND_COLOR
)
)
{
if
(
aAutoBuildingDisplayList
&
&
!
*
aAutoBuildingDisplayList
)
{
nsPoint
offset
=
aBuilder
-
>
GetCurrentFrame
(
)
-
>
GetOffsetTo
(
aFrame
)
;
aAutoBuildingDisplayList
-
>
emplace
(
aBuilder
aFrame
aBuilder
-
>
GetVisibleRect
(
)
+
offset
aBuilder
-
>
GetDirtyRect
(
)
+
offset
)
;
}
Maybe
<
DisplayListClipState
:
:
AutoSaveRestore
>
clipState
;
nsRect
bgColorRect
=
bgRect
;
if
(
bg
&
&
!
aBuilder
-
>
IsForEventDelivery
(
)
)
{
bool
useWillPaintBorderOptimization
=
willPaintBorder
&
&
nsLayoutUtils
:
:
HasNonZeroCorner
(
borderStyle
-
>
mBorderRadius
)
;
nsCSSRendering
:
:
ImageLayerClipState
clip
;
nsCSSRendering
:
:
GetImageLayerClip
(
bg
-
>
BottomLayer
(
)
aFrame
*
aFrame
-
>
StyleBorder
(
)
bgRect
bgRect
useWillPaintBorderOptimization
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
&
clip
)
;
bgColorRect
=
bgColorRect
.
Intersect
(
clip
.
mBGClipArea
)
;
if
(
clip
.
mHasAdditionalBGClipArea
)
{
bgColorRect
=
bgColorRect
.
Intersect
(
clip
.
mAdditionalBGClipArea
)
;
}
if
(
clip
.
mHasRoundedCorners
)
{
clipState
.
emplace
(
aBuilder
)
;
clipState
-
>
ClipContentDescendants
(
clip
.
mBGClipArea
clip
.
mRadii
)
;
}
}
nsDisplayBackgroundColor
*
bgItem
=
CreateBackgroundColor
(
aBuilder
aFrame
aSecondaryReferenceFrame
bgColorRect
bgSC
drawBackgroundColor
?
color
:
NS_RGBA
(
0
0
0
0
)
)
;
if
(
bgItem
)
{
bgItem
-
>
SetDependentFrame
(
aBuilder
dependentFrame
)
;
bgItemList
.
AppendToTop
(
bgItem
)
;
}
}
if
(
isThemed
)
{
nsDisplayThemedBackground
*
bgItem
=
CreateThemedBackground
(
aBuilder
aFrame
aSecondaryReferenceFrame
bgRect
)
;
if
(
bgItem
)
{
bgItem
-
>
Init
(
aBuilder
)
;
bgItemList
.
AppendToTop
(
bgItem
)
;
}
if
(
!
bgItemList
.
IsEmpty
(
)
)
{
aList
-
>
AppendToTop
(
&
bgItemList
)
;
return
AppendedBackgroundType
:
:
ThemedBackground
;
}
return
AppendedBackgroundType
:
:
None
;
}
if
(
!
bg
|
|
!
drawBackgroundImage
)
{
if
(
!
bgItemList
.
IsEmpty
(
)
)
{
aList
-
>
AppendToTop
(
&
bgItemList
)
;
return
AppendedBackgroundType
:
:
Background
;
}
return
AppendedBackgroundType
:
:
None
;
}
const
ActiveScrolledRoot
*
asr
=
aBuilder
-
>
CurrentActiveScrolledRoot
(
)
;
bool
needBlendContainer
=
false
;
NS_FOR_VISIBLE_IMAGE_LAYERS_BACK_TO_FRONT
(
i
bg
-
>
mImage
)
{
if
(
bg
-
>
mImage
.
mLayers
[
i
]
.
mImage
.
IsNone
(
)
)
{
continue
;
}
if
(
aAutoBuildingDisplayList
&
&
!
*
aAutoBuildingDisplayList
)
{
nsPoint
offset
=
aBuilder
-
>
GetCurrentFrame
(
)
-
>
GetOffsetTo
(
aFrame
)
;
aAutoBuildingDisplayList
-
>
emplace
(
aBuilder
aFrame
aBuilder
-
>
GetVisibleRect
(
)
+
offset
aBuilder
-
>
GetDirtyRect
(
)
+
offset
)
;
}
if
(
bg
-
>
mImage
.
mLayers
[
i
]
.
mBlendMode
!
=
StyleBlend
:
:
Normal
)
{
needBlendContainer
=
true
;
}
DisplayListClipState
:
:
AutoSaveRestore
clipState
(
aBuilder
)
;
if
(
!
aBuilder
-
>
IsForEventDelivery
(
)
)
{
const
nsStyleImageLayers
:
:
Layer
&
layer
=
bg
-
>
mImage
.
mLayers
[
i
]
;
SetBackgroundClipRegion
(
clipState
aFrame
layer
bgRect
willPaintBorder
)
;
}
nsDisplayList
thisItemList
;
nsDisplayBackgroundImage
:
:
InitData
bgData
=
nsDisplayBackgroundImage
:
:
GetInitData
(
aBuilder
aFrame
i
bgOriginRect
bgSC
)
;
if
(
bgData
.
shouldFixToViewport
)
{
auto
*
displayData
=
aBuilder
-
>
GetCurrentFixedBackgroundDisplayData
(
)
;
nsDisplayListBuilder
:
:
AutoBuildingDisplayList
buildingDisplayList
(
aBuilder
aFrame
aBuilder
-
>
GetVisibleRect
(
)
aBuilder
-
>
GetDirtyRect
(
)
)
;
nsDisplayListBuilder
:
:
AutoCurrentActiveScrolledRootSetter
asrSetter
(
aBuilder
)
;
if
(
displayData
)
{
asrSetter
.
SetCurrentActiveScrolledRoot
(
displayData
-
>
mContainingBlockActiveScrolledRoot
)
;
if
(
nsLayoutUtils
:
:
UsesAsyncScrolling
(
aFrame
)
)
{
nsIFrame
*
rootFrame
=
aBuilder
-
>
CurrentPresShellState
(
)
-
>
mPresShell
-
>
GetRootFrame
(
)
;
nsRect
visibleRect
=
displayData
-
>
mVisibleRect
+
aFrame
-
>
GetOffsetTo
(
rootFrame
)
;
aBuilder
-
>
SetVisibleRect
(
visibleRect
)
;
nsRect
dirtyRect
=
displayData
-
>
mDirtyRect
+
aFrame
-
>
GetOffsetTo
(
rootFrame
)
;
aBuilder
-
>
SetDirtyRect
(
dirtyRect
)
;
}
}
nsDisplayBackgroundImage
*
bgItem
=
nullptr
;
{
DisplayListClipState
:
:
AutoSaveRestore
bgImageClip
(
aBuilder
)
;
bgImageClip
.
Clear
(
)
;
bgItem
=
CreateBackgroundImage
(
aBuilder
aFrame
aSecondaryReferenceFrame
bgData
)
;
}
if
(
bgItem
)
{
bgItem
-
>
SetDependentFrame
(
aBuilder
dependentFrame
)
;
thisItemList
.
AppendToTop
(
nsDisplayFixedPosition
:
:
CreateForFixedBackground
(
aBuilder
aFrame
aSecondaryReferenceFrame
bgItem
i
asr
)
)
;
}
}
else
{
nsDisplayBackgroundImage
*
bgItem
=
CreateBackgroundImage
(
aBuilder
aFrame
aSecondaryReferenceFrame
bgData
)
;
if
(
bgItem
)
{
bgItem
-
>
SetDependentFrame
(
aBuilder
dependentFrame
)
;
thisItemList
.
AppendToTop
(
bgItem
)
;
}
}
if
(
bg
-
>
mImage
.
mLayers
[
i
]
.
mBlendMode
!
=
StyleBlend
:
:
Normal
)
{
DisplayListClipState
:
:
AutoSaveRestore
blendClip
(
aBuilder
)
;
if
(
aSecondaryReferenceFrame
)
{
const
auto
tableType
=
GetTableTypeFromFrame
(
aFrame
)
;
const
uint16_t
index
=
CalculateTablePerFrameKey
(
i
+
1
tableType
)
;
thisItemList
.
AppendNewToTopWithIndex
<
nsDisplayTableBlendMode
>
(
aBuilder
aSecondaryReferenceFrame
index
&
thisItemList
bg
-
>
mImage
.
mLayers
[
i
]
.
mBlendMode
asr
aFrame
true
)
;
}
else
{
thisItemList
.
AppendNewToTopWithIndex
<
nsDisplayBlendMode
>
(
aBuilder
aFrame
i
+
1
&
thisItemList
bg
-
>
mImage
.
mLayers
[
i
]
.
mBlendMode
asr
true
)
;
}
}
bgItemList
.
AppendToTop
(
&
thisItemList
)
;
}
if
(
needBlendContainer
)
{
DisplayListClipState
:
:
AutoSaveRestore
blendContainerClip
(
aBuilder
)
;
bgItemList
.
AppendToTop
(
nsDisplayBlendContainer
:
:
CreateForBackgroundBlendMode
(
aBuilder
aFrame
aSecondaryReferenceFrame
&
bgItemList
asr
)
)
;
}
if
(
!
bgItemList
.
IsEmpty
(
)
)
{
aList
-
>
AppendToTop
(
&
bgItemList
)
;
return
AppendedBackgroundType
:
:
Background
;
}
return
AppendedBackgroundType
:
:
None
;
}
static
bool
RoundedBorderIntersectsRect
(
nsIFrame
*
aFrame
const
nsPoint
&
aFrameToReferenceFrame
const
nsRect
&
aTestRect
)
{
if
(
!
nsRect
(
aFrameToReferenceFrame
aFrame
-
>
GetSize
(
)
)
.
Intersects
(
aTestRect
)
)
{
return
false
;
}
nscoord
radii
[
8
]
;
return
!
aFrame
-
>
GetBorderRadii
(
radii
)
|
|
nsLayoutUtils
:
:
RoundedRectIntersectsRect
(
nsRect
(
aFrameToReferenceFrame
aFrame
-
>
GetSize
(
)
)
radii
aTestRect
)
;
}
static
bool
RoundedRectContainsRect
(
const
nsRect
&
aRoundedRect
const
nscoord
aRadii
[
8
]
const
nsRect
&
aContainedRect
)
{
nsRegion
rgn
=
nsLayoutUtils
:
:
RoundedRectIntersectRect
(
aRoundedRect
aRadii
aContainedRect
)
;
return
rgn
.
Contains
(
aContainedRect
)
;
}
static
void
CheckForBorderItem
(
nsDisplayItem
*
aItem
uint32_t
&
aFlags
)
{
for
(
nsDisplayList
:
:
Iterator
it
(
aItem
)
;
it
.
HasNext
(
)
;
+
+
it
)
{
nsDisplayItem
*
next
=
*
it
;
if
(
next
-
>
GetType
(
)
=
=
DisplayItemType
:
:
TYPE_BACKGROUND
)
{
continue
;
}
if
(
next
-
>
GetType
(
)
=
=
DisplayItemType
:
:
TYPE_BORDER
)
{
aFlags
|
=
nsCSSRendering
:
:
PAINTBG_WILL_PAINT_BORDER
;
}
break
;
}
}
bool
nsDisplayBackgroundImage
:
:
CanBuildWebRenderDisplayItems
(
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aBuilder
)
const
{
return
mBackgroundStyle
-
>
StyleBackground
(
)
-
>
mImage
.
mLayers
[
mLayer
]
.
mClip
!
=
StyleGeometryBox
:
:
Text
&
&
nsCSSRendering
:
:
CanBuildWebRenderDisplayItemsForStyleImageLayer
(
aManager
*
StyleFrame
(
)
-
>
PresContext
(
)
StyleFrame
(
)
mBackgroundStyle
-
>
StyleBackground
(
)
mLayer
aBuilder
-
>
GetBackgroundPaintFlags
(
)
)
;
}
bool
nsDisplayBackgroundImage
:
:
CreateWebRenderCommands
(
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
if
(
!
CanBuildWebRenderDisplayItems
(
aManager
-
>
LayerManager
(
)
aDisplayListBuilder
)
)
{
return
false
;
}
uint32_t
paintFlags
=
aDisplayListBuilder
-
>
GetBackgroundPaintFlags
(
)
;
bool
dummy
;
CheckForBorderItem
(
this
paintFlags
)
;
nsCSSRendering
:
:
PaintBGParams
params
=
nsCSSRendering
:
:
PaintBGParams
:
:
ForSingleLayer
(
*
StyleFrame
(
)
-
>
PresContext
(
)
GetBounds
(
aDisplayListBuilder
&
dummy
)
mBackgroundRect
StyleFrame
(
)
paintFlags
mLayer
CompositionOp
:
:
OP_OVER
aBuilder
.
GetInheritedOpacity
(
)
)
;
params
.
bgClipRect
=
&
mBounds
;
ImgDrawResult
result
=
nsCSSRendering
:
:
BuildWebRenderDisplayItemsForStyleImageLayer
(
params
aBuilder
aResources
aSc
aManager
this
)
;
if
(
result
=
=
ImgDrawResult
:
:
NOT_SUPPORTED
)
{
return
false
;
}
nsDisplayBackgroundGeometry
:
:
UpdateDrawResult
(
this
result
)
;
return
true
;
}
void
nsDisplayBackgroundImage
:
:
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
{
if
(
RoundedBorderIntersectsRect
(
mFrame
ToReferenceFrame
(
)
aRect
)
)
{
aOutFrames
-
>
AppendElement
(
mFrame
)
;
}
}
static
nsRect
GetInsideClipRect
(
const
nsDisplayItem
*
aItem
StyleGeometryBox
aClip
const
nsRect
&
aRect
const
nsRect
&
aBackgroundRect
)
{
if
(
aRect
.
IsEmpty
(
)
)
{
return
{
}
;
}
nsIFrame
*
frame
=
aItem
-
>
Frame
(
)
;
nsRect
clipRect
=
aBackgroundRect
;
if
(
frame
-
>
IsCanvasFrame
(
)
)
{
nsCanvasFrame
*
canvasFrame
=
static_cast
<
nsCanvasFrame
*
>
(
frame
)
;
clipRect
=
canvasFrame
-
>
CanvasArea
(
)
+
aItem
-
>
ToReferenceFrame
(
)
;
}
else
if
(
aClip
=
=
StyleGeometryBox
:
:
PaddingBox
|
|
aClip
=
=
StyleGeometryBox
:
:
ContentBox
)
{
nsMargin
border
=
frame
-
>
GetUsedBorder
(
)
;
if
(
aClip
=
=
StyleGeometryBox
:
:
ContentBox
)
{
border
+
=
frame
-
>
GetUsedPadding
(
)
;
}
border
.
ApplySkipSides
(
frame
-
>
GetSkipSides
(
)
)
;
clipRect
.
Deflate
(
border
)
;
}
return
clipRect
.
Intersect
(
aRect
)
;
}
nsRegion
nsDisplayBackgroundImage
:
:
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
{
nsRegion
result
;
*
aSnap
=
false
;
if
(
!
mBackgroundStyle
)
{
return
result
;
}
*
aSnap
=
true
;
if
(
mFrame
-
>
StyleBorder
(
)
-
>
mBoxDecorationBreak
=
=
StyleBoxDecorationBreak
:
:
Clone
|
|
(
!
mFrame
-
>
GetPrevContinuation
(
)
&
&
!
mFrame
-
>
GetNextContinuation
(
)
)
)
{
const
nsStyleImageLayers
:
:
Layer
&
layer
=
mBackgroundStyle
-
>
StyleBackground
(
)
-
>
mImage
.
mLayers
[
mLayer
]
;
if
(
layer
.
mImage
.
IsOpaque
(
)
&
&
layer
.
mBlendMode
=
=
StyleBlend
:
:
Normal
&
&
layer
.
mRepeat
.
mXRepeat
!
=
StyleImageLayerRepeat
:
:
Space
&
&
layer
.
mRepeat
.
mYRepeat
!
=
StyleImageLayerRepeat
:
:
Space
&
&
layer
.
mClip
!
=
StyleGeometryBox
:
:
Text
)
{
result
=
GetInsideClipRect
(
this
layer
.
mClip
mBounds
mBackgroundRect
)
;
}
}
return
result
;
}
Maybe
<
nscolor
>
nsDisplayBackgroundImage
:
:
IsUniform
(
nsDisplayListBuilder
*
aBuilder
)
const
{
if
(
!
mBackgroundStyle
)
{
return
Some
(
NS_RGBA
(
0
0
0
0
)
)
;
}
return
Nothing
(
)
;
}
nsRect
nsDisplayBackgroundImage
:
:
GetPositioningArea
(
)
const
{
if
(
!
mBackgroundStyle
)
{
return
nsRect
(
)
;
}
nsIFrame
*
attachedToFrame
;
bool
transformedFixed
;
return
nsCSSRendering
:
:
ComputeImageLayerPositioningArea
(
mFrame
-
>
PresContext
(
)
mFrame
mBackgroundRect
mBackgroundStyle
-
>
StyleBackground
(
)
-
>
mImage
.
mLayers
[
mLayer
]
&
attachedToFrame
&
transformedFixed
)
+
ToReferenceFrame
(
)
;
}
bool
nsDisplayBackgroundImage
:
:
RenderingMightDependOnPositioningAreaSizeChange
(
)
const
{
if
(
!
mBackgroundStyle
)
{
return
false
;
}
nscoord
radii
[
8
]
;
if
(
mFrame
-
>
GetBorderRadii
(
radii
)
)
{
return
true
;
}
const
nsStyleImageLayers
:
:
Layer
&
layer
=
mBackgroundStyle
-
>
StyleBackground
(
)
-
>
mImage
.
mLayers
[
mLayer
]
;
return
layer
.
RenderingMightDependOnPositioningAreaSizeChange
(
)
;
}
void
nsDisplayBackgroundImage
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
PaintInternal
(
aBuilder
aCtx
GetPaintRect
(
aBuilder
aCtx
)
&
mBounds
)
;
}
void
nsDisplayBackgroundImage
:
:
PaintInternal
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
const
nsRect
&
aBounds
nsRect
*
aClipRect
)
{
gfxContext
*
ctx
=
aCtx
;
StyleGeometryBox
clip
=
mBackgroundStyle
-
>
StyleBackground
(
)
-
>
mImage
.
mLayers
[
mLayer
]
.
mClip
;
if
(
clip
=
=
StyleGeometryBox
:
:
Text
)
{
if
(
!
GenerateAndPushTextMask
(
StyleFrame
(
)
aCtx
mBackgroundRect
aBuilder
)
)
{
return
;
}
}
nsCSSRendering
:
:
PaintBGParams
params
=
nsCSSRendering
:
:
PaintBGParams
:
:
ForSingleLayer
(
*
StyleFrame
(
)
-
>
PresContext
(
)
aBounds
mBackgroundRect
StyleFrame
(
)
aBuilder
-
>
GetBackgroundPaintFlags
(
)
mLayer
CompositionOp
:
:
OP_OVER
1
.
0f
)
;
params
.
bgClipRect
=
aClipRect
;
ImgDrawResult
result
=
nsCSSRendering
:
:
PaintStyleImageLayer
(
params
*
aCtx
)
;
if
(
clip
=
=
StyleGeometryBox
:
:
Text
)
{
ctx
-
>
PopGroupAndBlend
(
)
;
}
nsDisplayBackgroundGeometry
:
:
UpdateDrawResult
(
this
result
)
;
}
void
nsDisplayBackgroundImage
:
:
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
{
if
(
!
mBackgroundStyle
)
{
return
;
}
const
auto
*
geometry
=
static_cast
<
const
nsDisplayBackgroundGeometry
*
>
(
aGeometry
)
;
bool
snap
;
nsRect
bounds
=
GetBounds
(
aBuilder
&
snap
)
;
nsRect
positioningArea
=
GetPositioningArea
(
)
;
if
(
positioningArea
.
TopLeft
(
)
!
=
geometry
-
>
mPositioningArea
.
TopLeft
(
)
|
|
(
positioningArea
.
Size
(
)
!
=
geometry
-
>
mPositioningArea
.
Size
(
)
&
&
RenderingMightDependOnPositioningAreaSizeChange
(
)
)
)
{
aInvalidRegion
-
>
Or
(
bounds
geometry
-
>
mBounds
)
;
return
;
}
if
(
!
mDestRect
.
IsEqualInterior
(
geometry
-
>
mDestRect
)
)
{
aInvalidRegion
-
>
Or
(
bounds
geometry
-
>
mBounds
)
;
return
;
}
if
(
aBuilder
-
>
ShouldSyncDecodeImages
(
)
)
{
const
auto
&
image
=
mBackgroundStyle
-
>
StyleBackground
(
)
-
>
mImage
.
mLayers
[
mLayer
]
.
mImage
;
if
(
image
.
IsImageRequestType
(
)
&
&
geometry
-
>
ShouldInvalidateToSyncDecodeImages
(
)
)
{
aInvalidRegion
-
>
Or
(
*
aInvalidRegion
bounds
)
;
}
}
if
(
!
bounds
.
IsEqualInterior
(
geometry
-
>
mBounds
)
)
{
aInvalidRegion
-
>
Xor
(
bounds
geometry
-
>
mBounds
)
;
}
}
nsRect
nsDisplayBackgroundImage
:
:
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
{
*
aSnap
=
true
;
return
mBounds
;
}
nsRect
nsDisplayBackgroundImage
:
:
GetBoundsInternal
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrameForBounds
)
{
nsIFrame
*
frame
=
aFrameForBounds
?
aFrameForBounds
:
mFrame
;
nsPresContext
*
presContext
=
frame
-
>
PresContext
(
)
;
if
(
!
mBackgroundStyle
)
{
return
nsRect
(
)
;
}
nsRect
clipRect
=
mBackgroundRect
;
if
(
frame
-
>
IsCanvasFrame
(
)
)
{
nsCanvasFrame
*
canvasFrame
=
static_cast
<
nsCanvasFrame
*
>
(
frame
)
;
clipRect
=
canvasFrame
-
>
CanvasArea
(
)
+
ToReferenceFrame
(
)
;
}
const
nsStyleImageLayers
:
:
Layer
&
layer
=
mBackgroundStyle
-
>
StyleBackground
(
)
-
>
mImage
.
mLayers
[
mLayer
]
;
return
nsCSSRendering
:
:
GetBackgroundLayerRect
(
presContext
frame
mBackgroundRect
clipRect
layer
aBuilder
-
>
GetBackgroundPaintFlags
(
)
)
;
}
nsDisplayTableBackgroundImage
:
:
nsDisplayTableBackgroundImage
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
InitData
&
aData
nsIFrame
*
aCellFrame
)
:
nsDisplayBackgroundImage
(
aBuilder
aFrame
aData
aCellFrame
)
mStyleFrame
(
aCellFrame
)
{
if
(
aBuilder
-
>
IsRetainingDisplayList
(
)
)
{
mStyleFrame
-
>
AddDisplayItem
(
this
)
;
}
}
nsDisplayTableBackgroundImage
:
:
~
nsDisplayTableBackgroundImage
(
)
{
if
(
mStyleFrame
)
{
mStyleFrame
-
>
RemoveDisplayItem
(
this
)
;
}
}
bool
nsDisplayTableBackgroundImage
:
:
IsInvalid
(
nsRect
&
aRect
)
const
{
bool
result
=
mStyleFrame
?
mStyleFrame
-
>
IsInvalid
(
aRect
)
:
false
;
aRect
+
=
ToReferenceFrame
(
)
;
return
result
;
}
nsDisplayThemedBackground
:
:
nsDisplayThemedBackground
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
nsRect
&
aBackgroundRect
)
:
nsPaintedDisplayItem
(
aBuilder
aFrame
)
mBackgroundRect
(
aBackgroundRect
)
{
MOZ_COUNT_CTOR
(
nsDisplayThemedBackground
)
;
}
void
nsDisplayThemedBackground
:
:
Init
(
nsDisplayListBuilder
*
aBuilder
)
{
const
nsStyleDisplay
*
disp
=
StyleFrame
(
)
-
>
StyleDisplay
(
)
;
mAppearance
=
disp
-
>
EffectiveAppearance
(
)
;
StyleFrame
(
)
-
>
IsThemed
(
disp
&
mThemeTransparency
)
;
nsITheme
*
theme
=
StyleFrame
(
)
-
>
PresContext
(
)
-
>
Theme
(
)
;
nsITheme
:
:
ThemeGeometryType
type
=
theme
-
>
ThemeGeometryTypeForWidget
(
StyleFrame
(
)
mAppearance
)
;
if
(
type
!
=
nsITheme
:
:
eThemeGeometryTypeUnknown
)
{
RegisterThemeGeometry
(
aBuilder
this
StyleFrame
(
)
type
)
;
}
if
(
mAppearance
=
=
StyleAppearance
:
:
MozWinBorderlessGlass
|
|
mAppearance
=
=
StyleAppearance
:
:
MozWinGlass
)
{
aBuilder
-
>
SetGlassDisplayItem
(
this
)
;
}
mBounds
=
GetBoundsInternal
(
)
;
}
void
nsDisplayThemedBackground
:
:
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
{
aStream
<
<
"
(
themed
appearance
:
"
<
<
(
int
)
mAppearance
<
<
"
)
"
;
}
void
nsDisplayThemedBackground
:
:
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
{
if
(
mBackgroundRect
.
Intersects
(
aRect
)
)
{
aOutFrames
-
>
AppendElement
(
mFrame
)
;
}
}
nsRegion
nsDisplayThemedBackground
:
:
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
{
nsRegion
result
;
*
aSnap
=
false
;
if
(
mThemeTransparency
=
=
nsITheme
:
:
eOpaque
)
{
*
aSnap
=
true
;
result
=
mBackgroundRect
;
}
return
result
;
}
Maybe
<
nscolor
>
nsDisplayThemedBackground
:
:
IsUniform
(
nsDisplayListBuilder
*
aBuilder
)
const
{
if
(
mAppearance
=
=
StyleAppearance
:
:
MozWinBorderlessGlass
|
|
mAppearance
=
=
StyleAppearance
:
:
MozWinGlass
)
{
return
Some
(
NS_RGBA
(
0
0
0
0
)
)
;
}
return
Nothing
(
)
;
}
nsRect
nsDisplayThemedBackground
:
:
GetPositioningArea
(
)
const
{
return
mBackgroundRect
;
}
void
nsDisplayThemedBackground
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
PaintInternal
(
aBuilder
aCtx
GetPaintRect
(
aBuilder
aCtx
)
nullptr
)
;
}
void
nsDisplayThemedBackground
:
:
PaintInternal
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
const
nsRect
&
aBounds
nsRect
*
aClipRect
)
{
nsPresContext
*
presContext
=
StyleFrame
(
)
-
>
PresContext
(
)
;
nsITheme
*
theme
=
presContext
-
>
Theme
(
)
;
nsRect
drawing
(
mBackgroundRect
)
;
theme
-
>
GetWidgetOverflow
(
presContext
-
>
DeviceContext
(
)
StyleFrame
(
)
mAppearance
&
drawing
)
;
drawing
.
IntersectRect
(
drawing
aBounds
)
;
theme
-
>
DrawWidgetBackground
(
aCtx
StyleFrame
(
)
mAppearance
mBackgroundRect
drawing
)
;
}
bool
nsDisplayThemedBackground
:
:
CreateWebRenderCommands
(
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
nsITheme
*
theme
=
StyleFrame
(
)
-
>
PresContext
(
)
-
>
Theme
(
)
;
return
theme
-
>
CreateWebRenderCommandsForWidget
(
aBuilder
aResources
aSc
aManager
StyleFrame
(
)
mAppearance
mBackgroundRect
)
;
}
bool
nsDisplayThemedBackground
:
:
IsWindowActive
(
)
const
{
EventStates
docState
=
mFrame
-
>
GetContent
(
)
-
>
OwnerDoc
(
)
-
>
GetDocumentState
(
)
;
return
!
docState
.
HasState
(
NS_DOCUMENT_STATE_WINDOW_INACTIVE
)
;
}
void
nsDisplayThemedBackground
:
:
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
{
const
auto
*
geometry
=
static_cast
<
const
nsDisplayThemedBackgroundGeometry
*
>
(
aGeometry
)
;
bool
snap
;
nsRect
bounds
=
GetBounds
(
aBuilder
&
snap
)
;
nsRect
positioningArea
=
GetPositioningArea
(
)
;
if
(
!
positioningArea
.
IsEqualInterior
(
geometry
-
>
mPositioningArea
)
)
{
aInvalidRegion
-
>
Or
(
bounds
geometry
-
>
mBounds
)
;
return
;
}
if
(
!
bounds
.
IsEqualInterior
(
geometry
-
>
mBounds
)
)
{
aInvalidRegion
-
>
Xor
(
bounds
geometry
-
>
mBounds
)
;
}
nsITheme
*
theme
=
StyleFrame
(
)
-
>
PresContext
(
)
-
>
Theme
(
)
;
if
(
theme
-
>
WidgetAppearanceDependsOnWindowFocus
(
mAppearance
)
&
&
IsWindowActive
(
)
!
=
geometry
-
>
mWindowIsActive
)
{
aInvalidRegion
-
>
Or
(
*
aInvalidRegion
bounds
)
;
}
}
nsRect
nsDisplayThemedBackground
:
:
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
{
*
aSnap
=
true
;
return
mBounds
;
}
nsRect
nsDisplayThemedBackground
:
:
GetBoundsInternal
(
)
{
nsPresContext
*
presContext
=
mFrame
-
>
PresContext
(
)
;
nsRect
r
=
mBackgroundRect
-
ToReferenceFrame
(
)
;
presContext
-
>
Theme
(
)
-
>
GetWidgetOverflow
(
presContext
-
>
DeviceContext
(
)
mFrame
mFrame
-
>
StyleDisplay
(
)
-
>
EffectiveAppearance
(
)
&
r
)
;
return
r
+
ToReferenceFrame
(
)
;
}
#
if
defined
(
MOZ_REFLOW_PERF_DSP
)
&
&
defined
(
MOZ_REFLOW_PERF
)
void
nsDisplayReflowCount
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
mFrame
-
>
PresShell
(
)
-
>
PaintCount
(
mFrameName
aCtx
mFrame
-
>
PresContext
(
)
mFrame
ToReferenceFrame
(
)
mColor
)
;
}
#
endif
bool
nsDisplayBackgroundColor
:
:
CanApplyOpacity
(
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aBuilder
)
const
{
return
!
EffectCompositor
:
:
HasAnimationsForCompositor
(
mFrame
DisplayItemType
:
:
TYPE_BACKGROUND_COLOR
)
;
}
bool
nsDisplayBackgroundColor
:
:
CreateWebRenderCommands
(
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
gfx
:
:
sRGBColor
color
=
mColor
;
color
.
a
*
=
aBuilder
.
GetInheritedOpacity
(
)
;
if
(
color
=
=
sRGBColor
(
)
&
&
!
EffectCompositor
:
:
HasAnimationsForCompositor
(
mFrame
DisplayItemType
:
:
TYPE_BACKGROUND_COLOR
)
)
{
return
true
;
}
if
(
HasBackgroundClipText
(
)
)
{
return
false
;
}
uint64_t
animationsId
=
0
;
if
(
GetType
(
)
=
=
DisplayItemType
:
:
TYPE_BACKGROUND_COLOR
)
{
animationsId
=
AddAnimationsForWebRender
(
this
aManager
aDisplayListBuilder
)
;
}
LayoutDeviceRect
bounds
=
LayoutDeviceRect
:
:
FromAppUnits
(
mBackgroundRect
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
wr
:
:
LayoutRect
r
=
wr
:
:
ToLayoutRect
(
bounds
)
;
if
(
animationsId
)
{
wr
:
:
WrAnimationProperty
prop
{
wr
:
:
WrAnimationType
:
:
BackgroundColor
animationsId
}
;
aBuilder
.
PushRectWithAnimation
(
r
r
!
BackfaceIsHidden
(
)
wr
:
:
ToColorF
(
ToDeviceColor
(
color
)
)
&
prop
)
;
}
else
{
aBuilder
.
StartGroup
(
this
)
;
aBuilder
.
PushRect
(
r
r
!
BackfaceIsHidden
(
)
wr
:
:
ToColorF
(
ToDeviceColor
(
color
)
)
)
;
aBuilder
.
FinishGroup
(
)
;
}
return
true
;
}
void
nsDisplayBackgroundColor
:
:
PaintWithClip
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
const
DisplayItemClip
&
aClip
)
{
MOZ_ASSERT
(
!
HasBackgroundClipText
(
)
)
;
if
(
mColor
=
=
sRGBColor
(
)
)
{
return
;
}
nsRect
fillRect
=
mBackgroundRect
;
if
(
aClip
.
HasClip
(
)
)
{
fillRect
.
IntersectRect
(
fillRect
aClip
.
GetClipRect
(
)
)
;
}
DrawTarget
*
dt
=
aCtx
-
>
GetDrawTarget
(
)
;
int32_t
A2D
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
Rect
bounds
=
ToRect
(
nsLayoutUtils
:
:
RectToGfxRect
(
fillRect
A2D
)
)
;
MaybeSnapToDevicePixels
(
bounds
*
dt
)
;
ColorPattern
fill
(
ToDeviceColor
(
mColor
)
)
;
if
(
aClip
.
GetRoundedRectCount
(
)
)
{
MOZ_ASSERT
(
aClip
.
GetRoundedRectCount
(
)
=
=
1
)
;
AutoTArray
<
DisplayItemClip
:
:
RoundedRect
1
>
roundedRect
;
aClip
.
AppendRoundedRects
(
&
roundedRect
)
;
bool
pushedClip
=
false
;
if
(
!
fillRect
.
Contains
(
roundedRect
[
0
]
.
mRect
)
)
{
dt
-
>
PushClipRect
(
bounds
)
;
pushedClip
=
true
;
}
RectCornerRadii
pixelRadii
;
nsCSSRendering
:
:
ComputePixelRadii
(
roundedRect
[
0
]
.
mRadii
A2D
&
pixelRadii
)
;
dt
-
>
FillRoundedRect
(
RoundedRect
(
NSRectToSnappedRect
(
roundedRect
[
0
]
.
mRect
A2D
*
dt
)
pixelRadii
)
fill
)
;
if
(
pushedClip
)
{
dt
-
>
PopClip
(
)
;
}
}
else
{
dt
-
>
FillRect
(
bounds
fill
)
;
}
}
void
nsDisplayBackgroundColor
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
if
(
mColor
=
=
sRGBColor
(
)
)
{
return
;
}
#
if
0
DrawTarget
&
aDrawTarget
=
*
aCtx
-
>
GetDrawTarget
(
)
;
Rect
rect
=
NSRectToSnappedRect
(
mBackgroundRect
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
aDrawTarget
)
;
ColorPattern
color
(
ToDeviceColor
(
mColor
)
)
;
aDrawTarget
.
FillRect
(
rect
color
)
;
#
else
gfxContext
*
ctx
=
aCtx
;
gfxRect
bounds
=
nsLayoutUtils
:
:
RectToGfxRect
(
mBackgroundRect
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
if
(
HasBackgroundClipText
(
)
)
{
if
(
!
GenerateAndPushTextMask
(
mFrame
aCtx
mBackgroundRect
aBuilder
)
)
{
return
;
}
ctx
-
>
SetColor
(
mColor
)
;
ctx
-
>
NewPath
(
)
;
ctx
-
>
SnappedRectangle
(
bounds
)
;
ctx
-
>
Fill
(
)
;
ctx
-
>
PopGroupAndBlend
(
)
;
return
;
}
ctx
-
>
SetColor
(
mColor
)
;
ctx
-
>
NewPath
(
)
;
ctx
-
>
SnappedRectangle
(
bounds
)
;
ctx
-
>
Fill
(
)
;
#
endif
}
nsRegion
nsDisplayBackgroundColor
:
:
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
{
*
aSnap
=
false
;
if
(
mColor
.
a
!
=
1
|
|
EffectCompositor
:
:
HasAnimationsForCompositor
(
mFrame
DisplayItemType
:
:
TYPE_BACKGROUND_COLOR
)
)
{
return
nsRegion
(
)
;
}
if
(
!
mHasStyle
|
|
HasBackgroundClipText
(
)
)
{
return
nsRegion
(
)
;
}
*
aSnap
=
true
;
return
GetInsideClipRect
(
this
mBottomLayerClip
mBackgroundRect
mBackgroundRect
)
;
}
Maybe
<
nscolor
>
nsDisplayBackgroundColor
:
:
IsUniform
(
nsDisplayListBuilder
*
aBuilder
)
const
{
return
Some
(
mColor
.
ToABGR
(
)
)
;
}
void
nsDisplayBackgroundColor
:
:
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
{
if
(
!
RoundedBorderIntersectsRect
(
mFrame
ToReferenceFrame
(
)
aRect
)
)
{
return
;
}
aOutFrames
-
>
AppendElement
(
mFrame
)
;
}
void
nsDisplayBackgroundColor
:
:
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
{
aStream
<
<
"
(
rgba
"
<
<
mColor
.
r
<
<
"
"
<
<
mColor
.
g
<
<
"
"
<
<
mColor
.
b
<
<
"
"
<
<
mColor
.
a
<
<
"
)
"
;
aStream
<
<
"
backgroundRect
"
<
<
mBackgroundRect
;
}
nsRect
nsDisplayOutline
:
:
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
{
*
aSnap
=
false
;
return
mFrame
-
>
InkOverflowRectRelativeToSelf
(
)
+
ToReferenceFrame
(
)
;
}
nsRect
nsDisplayOutline
:
:
GetInnerRect
(
)
const
{
nsRect
*
savedOutlineInnerRect
=
mFrame
-
>
GetProperty
(
nsIFrame
:
:
OutlineInnerRectProperty
(
)
)
;
if
(
savedOutlineInnerRect
)
{
return
*
savedOutlineInnerRect
;
}
NS_ERROR
(
"
we
should
have
saved
a
frame
property
"
)
;
return
nsRect
(
nsPoint
(
)
mFrame
-
>
GetSize
(
)
)
;
}
void
nsDisplayOutline
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
MOZ_ASSERT
(
mFrame
-
>
StyleOutline
(
)
-
>
ShouldPaintOutline
(
)
"
Should
have
not
created
a
nsDisplayOutline
!
"
)
;
nsRect
rect
=
GetInnerRect
(
)
+
ToReferenceFrame
(
)
;
nsPresContext
*
pc
=
mFrame
-
>
PresContext
(
)
;
if
(
IsThemedOutline
(
)
)
{
rect
.
Inflate
(
mFrame
-
>
StyleOutline
(
)
-
>
mOutlineOffset
.
ToAppUnits
(
)
)
;
pc
-
>
Theme
(
)
-
>
DrawWidgetBackground
(
aCtx
mFrame
StyleAppearance
:
:
FocusOutline
rect
GetPaintRect
(
aBuilder
aCtx
)
)
;
return
;
}
nsCSSRendering
:
:
PaintNonThemedOutline
(
pc
*
aCtx
mFrame
GetPaintRect
(
aBuilder
aCtx
)
rect
mFrame
-
>
Style
(
)
)
;
}
bool
nsDisplayOutline
:
:
IsThemedOutline
(
)
const
{
const
auto
&
outlineStyle
=
mFrame
-
>
StyleOutline
(
)
-
>
mOutlineStyle
;
if
(
!
outlineStyle
.
IsAuto
(
)
|
|
!
StaticPrefs
:
:
layout_css_outline_style_auto_enabled
(
)
)
{
return
false
;
}
nsPresContext
*
pc
=
mFrame
-
>
PresContext
(
)
;
nsITheme
*
theme
=
pc
-
>
Theme
(
)
;
return
theme
-
>
ThemeSupportsWidget
(
pc
mFrame
StyleAppearance
:
:
FocusOutline
)
;
}
bool
nsDisplayOutline
:
:
CreateWebRenderCommands
(
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
nsPresContext
*
pc
=
mFrame
-
>
PresContext
(
)
;
nsRect
rect
=
GetInnerRect
(
)
+
ToReferenceFrame
(
)
;
if
(
IsThemedOutline
(
)
)
{
rect
.
Inflate
(
mFrame
-
>
StyleOutline
(
)
-
>
mOutlineOffset
.
ToAppUnits
(
)
)
;
return
pc
-
>
Theme
(
)
-
>
CreateWebRenderCommandsForWidget
(
aBuilder
aResources
aSc
aManager
mFrame
StyleAppearance
:
:
FocusOutline
rect
)
;
}
bool
dummy
;
Maybe
<
nsCSSBorderRenderer
>
borderRenderer
=
nsCSSRendering
:
:
CreateBorderRendererForNonThemedOutline
(
pc
nullptr
mFrame
GetBounds
(
aDisplayListBuilder
&
dummy
)
rect
mFrame
-
>
Style
(
)
)
;
if
(
!
borderRenderer
)
{
return
true
;
}
borderRenderer
-
>
CreateWebRenderCommands
(
this
aBuilder
aResources
aSc
)
;
return
true
;
}
bool
nsDisplayOutline
:
:
HasRadius
(
)
const
{
const
auto
&
radius
=
mFrame
-
>
StyleBorder
(
)
-
>
mBorderRadius
;
return
!
nsLayoutUtils
:
:
HasNonZeroCorner
(
radius
)
;
}
bool
nsDisplayOutline
:
:
IsInvisibleInRect
(
const
nsRect
&
aRect
)
const
{
const
nsStyleOutline
*
outline
=
mFrame
-
>
StyleOutline
(
)
;
nsRect
borderBox
(
ToReferenceFrame
(
)
mFrame
-
>
GetSize
(
)
)
;
if
(
borderBox
.
Contains
(
aRect
)
&
&
!
HasRadius
(
)
&
&
outline
-
>
mOutlineOffset
.
ToCSSPixels
(
)
>
=
0
.
0f
)
{
return
true
;
}
return
false
;
}
void
nsDisplayEventReceiver
:
:
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
{
if
(
!
RoundedBorderIntersectsRect
(
mFrame
ToReferenceFrame
(
)
aRect
)
)
{
return
;
}
aOutFrames
-
>
AppendElement
(
mFrame
)
;
}
bool
nsDisplayCompositorHitTestInfo
:
:
CreateWebRenderCommands
(
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
return
true
;
}
int32_t
nsDisplayCompositorHitTestInfo
:
:
ZIndex
(
)
const
{
return
mOverrideZIndex
?
*
mOverrideZIndex
:
nsDisplayItem
:
:
ZIndex
(
)
;
}
void
nsDisplayCompositorHitTestInfo
:
:
SetOverrideZIndex
(
int32_t
aZIndex
)
{
mOverrideZIndex
=
Some
(
aZIndex
)
;
}
nsDisplayCaret
:
:
nsDisplayCaret
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aCaretFrame
)
:
nsPaintedDisplayItem
(
aBuilder
aCaretFrame
)
mCaret
(
aBuilder
-
>
GetCaret
(
)
)
mBounds
(
aBuilder
-
>
GetCaretRect
(
)
+
ToReferenceFrame
(
)
)
{
MOZ_COUNT_CTOR
(
nsDisplayCaret
)
;
SetBuildingRect
(
mBounds
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
nsDisplayCaret
:
:
~
nsDisplayCaret
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayCaret
)
;
}
#
endif
nsRect
nsDisplayCaret
:
:
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
{
*
aSnap
=
true
;
return
mBounds
;
}
void
nsDisplayCaret
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
mCaret
-
>
PaintCaret
(
*
aCtx
-
>
GetDrawTarget
(
)
mFrame
ToReferenceFrame
(
)
)
;
}
bool
nsDisplayCaret
:
:
CreateWebRenderCommands
(
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
using
namespace
layers
;
nsRect
caretRect
;
nsRect
hookRect
;
nscolor
caretColor
;
nsIFrame
*
frame
=
mCaret
-
>
GetPaintGeometry
(
&
caretRect
&
hookRect
&
caretColor
)
;
MOZ_ASSERT
(
frame
=
=
mFrame
"
We
'
re
referring
different
frame
"
)
;
if
(
!
frame
)
{
return
true
;
}
int32_t
appUnitsPerDevPixel
=
frame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
gfx
:
:
DeviceColor
color
=
ToDeviceColor
(
caretColor
)
;
LayoutDeviceRect
devCaretRect
=
LayoutDeviceRect
:
:
FromAppUnits
(
caretRect
+
ToReferenceFrame
(
)
appUnitsPerDevPixel
)
;
LayoutDeviceRect
devHookRect
=
LayoutDeviceRect
:
:
FromAppUnits
(
hookRect
+
ToReferenceFrame
(
)
appUnitsPerDevPixel
)
;
wr
:
:
LayoutRect
caret
=
wr
:
:
ToLayoutRect
(
devCaretRect
)
;
wr
:
:
LayoutRect
hook
=
wr
:
:
ToLayoutRect
(
devHookRect
)
;
aBuilder
.
PushRect
(
caret
caret
!
BackfaceIsHidden
(
)
wr
:
:
ToColorF
(
color
)
)
;
if
(
!
devHookRect
.
IsEmpty
(
)
)
{
aBuilder
.
PushRect
(
hook
hook
!
BackfaceIsHidden
(
)
wr
:
:
ToColorF
(
color
)
)
;
}
return
true
;
}
nsDisplayBorder
:
:
nsDisplayBorder
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
:
nsPaintedDisplayItem
(
aBuilder
aFrame
)
{
MOZ_COUNT_CTOR
(
nsDisplayBorder
)
;
mBounds
=
CalculateBounds
<
nsRect
>
(
*
mFrame
-
>
StyleBorder
(
)
)
;
}
bool
nsDisplayBorder
:
:
IsInvisibleInRect
(
const
nsRect
&
aRect
)
const
{
nsRect
paddingRect
=
GetPaddingRect
(
)
;
const
nsStyleBorder
*
styleBorder
;
if
(
paddingRect
.
Contains
(
aRect
)
&
&
!
(
styleBorder
=
mFrame
-
>
StyleBorder
(
)
)
-
>
IsBorderImageSizeAvailable
(
)
&
&
!
nsLayoutUtils
:
:
HasNonZeroCorner
(
styleBorder
-
>
mBorderRadius
)
)
{
return
true
;
}
return
false
;
}
nsDisplayItemGeometry
*
nsDisplayBorder
:
:
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
{
return
new
nsDisplayBorderGeometry
(
this
aBuilder
)
;
}
void
nsDisplayBorder
:
:
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
{
const
auto
*
geometry
=
static_cast
<
const
nsDisplayBorderGeometry
*
>
(
aGeometry
)
;
bool
snap
;
if
(
!
geometry
-
>
mBounds
.
IsEqualInterior
(
GetBounds
(
aBuilder
&
snap
)
)
)
{
aInvalidRegion
-
>
Or
(
GetBounds
(
aBuilder
&
snap
)
geometry
-
>
mBounds
)
;
}
if
(
aBuilder
-
>
ShouldSyncDecodeImages
(
)
&
&
geometry
-
>
ShouldInvalidateToSyncDecodeImages
(
)
)
{
aInvalidRegion
-
>
Or
(
*
aInvalidRegion
GetBounds
(
aBuilder
&
snap
)
)
;
}
}
bool
nsDisplayBorder
:
:
CreateWebRenderCommands
(
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
nsRect
rect
=
nsRect
(
ToReferenceFrame
(
)
mFrame
-
>
GetSize
(
)
)
;
ImgDrawResult
drawResult
=
nsCSSRendering
:
:
CreateWebRenderCommandsForBorder
(
this
mFrame
rect
aBuilder
aResources
aSc
aManager
aDisplayListBuilder
)
;
if
(
drawResult
=
=
ImgDrawResult
:
:
NOT_SUPPORTED
)
{
return
false
;
}
nsDisplayBorderGeometry
:
:
UpdateDrawResult
(
this
drawResult
)
;
return
true
;
}
;
void
nsDisplayBorder
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
nsPoint
offset
=
ToReferenceFrame
(
)
;
PaintBorderFlags
flags
=
aBuilder
-
>
ShouldSyncDecodeImages
(
)
?
PaintBorderFlags
:
:
SyncDecodeImages
:
PaintBorderFlags
(
)
;
ImgDrawResult
result
=
nsCSSRendering
:
:
PaintBorder
(
mFrame
-
>
PresContext
(
)
*
aCtx
mFrame
GetPaintRect
(
aBuilder
aCtx
)
nsRect
(
offset
mFrame
-
>
GetSize
(
)
)
mFrame
-
>
Style
(
)
flags
mFrame
-
>
GetSkipSides
(
)
)
;
nsDisplayBorderGeometry
:
:
UpdateDrawResult
(
this
result
)
;
}
nsRect
nsDisplayBorder
:
:
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
{
*
aSnap
=
true
;
return
mBounds
;
}
void
nsDisplayBoxShadowOuter
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
nsPoint
offset
=
ToReferenceFrame
(
)
;
nsRect
borderRect
=
mFrame
-
>
VisualBorderRectRelativeToSelf
(
)
+
offset
;
nsPresContext
*
presContext
=
mFrame
-
>
PresContext
(
)
;
AUTO_PROFILER_LABEL
(
"
nsDisplayBoxShadowOuter
:
:
Paint
"
GRAPHICS
)
;
nsCSSRendering
:
:
PaintBoxShadowOuter
(
presContext
*
aCtx
mFrame
borderRect
GetPaintRect
(
aBuilder
aCtx
)
1
.
0f
)
;
}
nsRect
nsDisplayBoxShadowOuter
:
:
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
{
*
aSnap
=
false
;
return
mBounds
;
}
nsRect
nsDisplayBoxShadowOuter
:
:
GetBoundsInternal
(
)
{
return
nsLayoutUtils
:
:
GetBoxShadowRectForFrame
(
mFrame
mFrame
-
>
GetSize
(
)
)
+
ToReferenceFrame
(
)
;
}
bool
nsDisplayBoxShadowOuter
:
:
IsInvisibleInRect
(
const
nsRect
&
aRect
)
const
{
nsPoint
origin
=
ToReferenceFrame
(
)
;
nsRect
frameRect
(
origin
mFrame
-
>
GetSize
(
)
)
;
if
(
!
frameRect
.
Contains
(
aRect
)
)
{
return
false
;
}
nscoord
twipsRadii
[
8
]
;
bool
hasBorderRadii
=
mFrame
-
>
GetBorderRadii
(
twipsRadii
)
;
if
(
!
hasBorderRadii
)
{
return
true
;
}
return
RoundedRectContainsRect
(
frameRect
twipsRadii
aRect
)
;
}
bool
nsDisplayBoxShadowOuter
:
:
CanBuildWebRenderDisplayItems
(
)
const
{
auto
shadows
=
mFrame
-
>
StyleEffects
(
)
-
>
mBoxShadow
.
AsSpan
(
)
;
if
(
shadows
.
IsEmpty
(
)
)
{
return
false
;
}
bool
hasBorderRadius
;
return
!
nsCSSRendering
:
:
HasBoxShadowNativeTheme
(
mFrame
hasBorderRadius
)
;
}
bool
nsDisplayBoxShadowOuter
:
:
CreateWebRenderCommands
(
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
if
(
!
CanBuildWebRenderDisplayItems
(
)
)
{
return
false
;
}
int32_t
appUnitsPerDevPixel
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
nsPoint
offset
=
ToReferenceFrame
(
)
;
nsRect
borderRect
=
mFrame
-
>
VisualBorderRectRelativeToSelf
(
)
+
offset
;
bool
snap
;
nsRect
bounds
=
GetBounds
(
aDisplayListBuilder
&
snap
)
;
bool
hasBorderRadius
;
bool
nativeTheme
=
nsCSSRendering
:
:
HasBoxShadowNativeTheme
(
mFrame
hasBorderRadius
)
;
nsRect
frameRect
=
nsCSSRendering
:
:
GetShadowRect
(
borderRect
nativeTheme
mFrame
)
;
RectCornerRadii
borderRadii
;
if
(
hasBorderRadius
)
{
hasBorderRadius
=
nsCSSRendering
:
:
GetBorderRadii
(
frameRect
borderRect
mFrame
borderRadii
)
;
}
LayoutDeviceRect
clipRect
=
LayoutDeviceRect
:
:
FromAppUnits
(
bounds
appUnitsPerDevPixel
)
;
auto
shadows
=
mFrame
-
>
StyleEffects
(
)
-
>
mBoxShadow
.
AsSpan
(
)
;
MOZ_ASSERT
(
!
shadows
.
IsEmpty
(
)
)
;
for
(
const
auto
&
shadow
:
Reversed
(
shadows
)
)
{
if
(
shadow
.
inset
)
{
continue
;
}
float
blurRadius
=
float
(
shadow
.
base
.
blur
.
ToAppUnits
(
)
)
/
float
(
appUnitsPerDevPixel
)
;
gfx
:
:
sRGBColor
shadowColor
=
nsCSSRendering
:
:
GetShadowColor
(
shadow
.
base
mFrame
aBuilder
.
GetInheritedOpacity
(
)
)
;
const
nsRect
&
shadowRect
=
frameRect
;
LayoutDevicePoint
shadowOffset
=
LayoutDevicePoint
:
:
FromAppUnits
(
nsPoint
(
shadow
.
base
.
horizontal
.
ToAppUnits
(
)
shadow
.
base
.
vertical
.
ToAppUnits
(
)
)
appUnitsPerDevPixel
)
;
LayoutDeviceRect
deviceBox
=
LayoutDeviceRect
:
:
FromAppUnits
(
shadowRect
appUnitsPerDevPixel
)
;
wr
:
:
LayoutRect
deviceBoxRect
=
wr
:
:
ToLayoutRect
(
deviceBox
)
;
wr
:
:
LayoutRect
deviceClipRect
=
wr
:
:
ToLayoutRect
(
clipRect
)
;
LayoutDeviceSize
zeroSize
;
wr
:
:
BorderRadius
borderRadius
=
wr
:
:
ToBorderRadius
(
zeroSize
zeroSize
zeroSize
zeroSize
)
;
if
(
hasBorderRadius
)
{
borderRadius
=
wr
:
:
ToBorderRadius
(
LayoutDeviceSize
:
:
FromUnknownSize
(
borderRadii
.
TopLeft
(
)
)
LayoutDeviceSize
:
:
FromUnknownSize
(
borderRadii
.
TopRight
(
)
)
LayoutDeviceSize
:
:
FromUnknownSize
(
borderRadii
.
BottomLeft
(
)
)
LayoutDeviceSize
:
:
FromUnknownSize
(
borderRadii
.
BottomRight
(
)
)
)
;
}
float
spreadRadius
=
float
(
shadow
.
spread
.
ToAppUnits
(
)
)
/
float
(
appUnitsPerDevPixel
)
;
aBuilder
.
PushBoxShadow
(
deviceBoxRect
deviceClipRect
!
BackfaceIsHidden
(
)
deviceBoxRect
wr
:
:
ToLayoutVector2D
(
shadowOffset
)
wr
:
:
ToColorF
(
ToDeviceColor
(
shadowColor
)
)
blurRadius
spreadRadius
borderRadius
wr
:
:
BoxShadowClipMode
:
:
Outset
)
;
}
return
true
;
}
void
nsDisplayBoxShadowOuter
:
:
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
{
const
auto
*
geometry
=
static_cast
<
const
nsDisplayItemGenericGeometry
*
>
(
aGeometry
)
;
bool
snap
;
if
(
!
geometry
-
>
mBounds
.
IsEqualInterior
(
GetBounds
(
aBuilder
&
snap
)
)
|
|
!
geometry
-
>
mBorderRect
.
IsEqualInterior
(
GetBorderRect
(
)
)
)
{
nsRegion
oldShadow
newShadow
;
nscoord
dontCare
[
8
]
;
bool
hasBorderRadius
=
mFrame
-
>
GetBorderRadii
(
dontCare
)
;
if
(
hasBorderRadius
)
{
oldShadow
=
geometry
-
>
mBounds
;
newShadow
=
GetBounds
(
aBuilder
&
snap
)
;
}
else
{
oldShadow
.
Sub
(
geometry
-
>
mBounds
geometry
-
>
mBorderRect
)
;
newShadow
.
Sub
(
GetBounds
(
aBuilder
&
snap
)
GetBorderRect
(
)
)
;
}
aInvalidRegion
-
>
Or
(
oldShadow
newShadow
)
;
}
}
void
nsDisplayBoxShadowInner
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
nsPoint
offset
=
ToReferenceFrame
(
)
;
nsRect
borderRect
=
nsRect
(
offset
mFrame
-
>
GetSize
(
)
)
;
nsPresContext
*
presContext
=
mFrame
-
>
PresContext
(
)
;
AUTO_PROFILER_LABEL
(
"
nsDisplayBoxShadowInner
:
:
Paint
"
GRAPHICS
)
;
nsCSSRendering
:
:
PaintBoxShadowInner
(
presContext
*
aCtx
mFrame
borderRect
)
;
}
bool
nsDisplayBoxShadowInner
:
:
CanCreateWebRenderCommands
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
nsPoint
&
aReferenceOffset
)
{
auto
shadows
=
aFrame
-
>
StyleEffects
(
)
-
>
mBoxShadow
.
AsSpan
(
)
;
if
(
shadows
.
IsEmpty
(
)
)
{
return
true
;
}
bool
hasBorderRadius
;
bool
nativeTheme
=
nsCSSRendering
:
:
HasBoxShadowNativeTheme
(
aFrame
hasBorderRadius
)
;
return
!
nativeTheme
;
}
void
nsDisplayBoxShadowInner
:
:
CreateInsetBoxShadowWebRenderCommands
(
wr
:
:
DisplayListBuilder
&
aBuilder
const
StackingContextHelper
&
aSc
nsRect
&
aVisibleRect
nsIFrame
*
aFrame
const
nsRect
&
aBorderRect
)
{
if
(
!
nsCSSRendering
:
:
ShouldPaintBoxShadowInner
(
aFrame
)
)
{
return
;
}
int32_t
appUnitsPerDevPixel
=
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
auto
shadows
=
aFrame
-
>
StyleEffects
(
)
-
>
mBoxShadow
.
AsSpan
(
)
;
LayoutDeviceRect
clipRect
=
LayoutDeviceRect
:
:
FromAppUnits
(
aVisibleRect
appUnitsPerDevPixel
)
;
for
(
const
auto
&
shadow
:
Reversed
(
shadows
)
)
{
if
(
!
shadow
.
inset
)
{
continue
;
}
nsRect
shadowRect
=
nsCSSRendering
:
:
GetBoxShadowInnerPaddingRect
(
aFrame
aBorderRect
)
;
RectCornerRadii
innerRadii
;
nsCSSRendering
:
:
GetShadowInnerRadii
(
aFrame
aBorderRect
innerRadii
)
;
LayoutDeviceRect
deviceBoxRect
=
LayoutDeviceRect
:
:
FromAppUnits
(
shadowRect
appUnitsPerDevPixel
)
;
wr
:
:
LayoutRect
deviceClipRect
=
wr
:
:
ToLayoutRect
(
clipRect
)
;
sRGBColor
shadowColor
=
nsCSSRendering
:
:
GetShadowColor
(
shadow
.
base
aFrame
1
.
0
)
;
LayoutDevicePoint
shadowOffset
=
LayoutDevicePoint
:
:
FromAppUnits
(
nsPoint
(
shadow
.
base
.
horizontal
.
ToAppUnits
(
)
shadow
.
base
.
vertical
.
ToAppUnits
(
)
)
appUnitsPerDevPixel
)
;
float
blurRadius
=
float
(
shadow
.
base
.
blur
.
ToAppUnits
(
)
)
/
float
(
appUnitsPerDevPixel
)
;
wr
:
:
BorderRadius
borderRadius
=
wr
:
:
ToBorderRadius
(
LayoutDeviceSize
:
:
FromUnknownSize
(
innerRadii
.
TopLeft
(
)
)
LayoutDeviceSize
:
:
FromUnknownSize
(
innerRadii
.
TopRight
(
)
)
LayoutDeviceSize
:
:
FromUnknownSize
(
innerRadii
.
BottomLeft
(
)
)
LayoutDeviceSize
:
:
FromUnknownSize
(
innerRadii
.
BottomRight
(
)
)
)
;
float
spreadRadius
=
float
(
shadow
.
spread
.
ToAppUnits
(
)
)
/
float
(
appUnitsPerDevPixel
)
;
aBuilder
.
PushBoxShadow
(
wr
:
:
ToLayoutRect
(
deviceBoxRect
)
deviceClipRect
!
aFrame
-
>
BackfaceIsHidden
(
)
wr
:
:
ToLayoutRect
(
deviceBoxRect
)
wr
:
:
ToLayoutVector2D
(
shadowOffset
)
wr
:
:
ToColorF
(
ToDeviceColor
(
shadowColor
)
)
blurRadius
spreadRadius
borderRadius
wr
:
:
BoxShadowClipMode
:
:
Inset
)
;
}
}
bool
nsDisplayBoxShadowInner
:
:
CreateWebRenderCommands
(
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
if
(
!
CanCreateWebRenderCommands
(
aDisplayListBuilder
mFrame
ToReferenceFrame
(
)
)
)
{
return
false
;
}
bool
snap
;
nsRect
visible
=
GetBounds
(
aDisplayListBuilder
&
snap
)
;
nsPoint
offset
=
ToReferenceFrame
(
)
;
nsRect
borderRect
=
nsRect
(
offset
mFrame
-
>
GetSize
(
)
)
;
nsDisplayBoxShadowInner
:
:
CreateInsetBoxShadowWebRenderCommands
(
aBuilder
aSc
visible
mFrame
borderRect
)
;
return
true
;
}
nsDisplayWrapList
:
:
nsDisplayWrapList
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
)
:
nsDisplayWrapList
(
aBuilder
aFrame
aList
aBuilder
-
>
CurrentActiveScrolledRoot
(
)
false
)
{
}
nsDisplayWrapList
:
:
nsDisplayWrapList
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
ActiveScrolledRoot
*
aActiveScrolledRoot
bool
aClearClipChain
)
:
nsPaintedDisplayItem
(
aBuilder
aFrame
aActiveScrolledRoot
)
mFrameActiveScrolledRoot
(
aBuilder
-
>
CurrentActiveScrolledRoot
(
)
)
mOverrideZIndex
(
0
)
mHasZIndexOverride
(
false
)
mClearingClipChain
(
aClearClipChain
)
{
MOZ_COUNT_CTOR
(
nsDisplayWrapList
)
;
mBaseBuildingRect
=
GetBuildingRect
(
)
;
mListPtr
=
&
mList
;
mListPtr
-
>
AppendToTop
(
aList
)
;
mOriginalClipChain
=
mClipChain
;
nsDisplayWrapList
:
:
UpdateBounds
(
aBuilder
)
;
}
nsDisplayWrapList
:
:
nsDisplayWrapList
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayItem
*
aItem
)
:
nsPaintedDisplayItem
(
aBuilder
aFrame
aBuilder
-
>
CurrentActiveScrolledRoot
(
)
)
mOverrideZIndex
(
0
)
mHasZIndexOverride
(
false
)
{
MOZ_COUNT_CTOR
(
nsDisplayWrapList
)
;
mBaseBuildingRect
=
GetBuildingRect
(
)
;
mListPtr
=
&
mList
;
mListPtr
-
>
AppendToTop
(
aItem
)
;
mOriginalClipChain
=
mClipChain
;
nsDisplayWrapList
:
:
UpdateBounds
(
aBuilder
)
;
if
(
!
aFrame
|
|
!
aFrame
-
>
IsTransformed
(
)
)
{
return
;
}
if
(
aItem
-
>
Frame
(
)
=
=
aFrame
)
{
mToReferenceFrame
=
aItem
-
>
ToReferenceFrame
(
)
;
}
nsRect
visible
=
aBuilder
-
>
GetVisibleRect
(
)
+
aBuilder
-
>
GetCurrentFrameOffsetToReferenceFrame
(
)
;
SetBuildingRect
(
visible
)
;
}
nsDisplayWrapList
:
:
~
nsDisplayWrapList
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayWrapList
)
;
}
void
nsDisplayWrapList
:
:
MergeDisplayListFromItem
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayWrapList
*
aItem
)
{
const
nsDisplayWrapList
*
wrappedItem
=
aItem
-
>
AsDisplayWrapList
(
)
;
MOZ_ASSERT
(
wrappedItem
)
;
nsDisplayWrapList
*
wrapper
=
new
(
aBuilder
)
nsDisplayWrapper
(
aBuilder
*
wrappedItem
)
;
wrapper
-
>
SetType
(
nsDisplayWrapper
:
:
ItemType
(
)
)
;
MOZ_ASSERT
(
wrapper
)
;
wrapper
-
>
mListPtr
=
wrappedItem
-
>
mListPtr
;
mListPtr
-
>
AppendToBottom
(
wrapper
)
;
}
void
nsDisplayWrapList
:
:
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
{
mListPtr
-
>
HitTest
(
aBuilder
aRect
aState
aOutFrames
)
;
}
nsRect
nsDisplayWrapList
:
:
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
{
*
aSnap
=
false
;
return
mBounds
;
}
nsRegion
nsDisplayWrapList
:
:
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
{
*
aSnap
=
false
;
bool
snap
;
return
:
:
mozilla
:
:
GetOpaqueRegion
(
aBuilder
GetChildren
(
)
GetBounds
(
aBuilder
&
snap
)
)
;
}
Maybe
<
nscolor
>
nsDisplayWrapList
:
:
IsUniform
(
nsDisplayListBuilder
*
aBuilder
)
const
{
return
Nothing
(
)
;
}
void
nsDisplayWrapper
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
NS_ERROR
(
"
nsDisplayWrapper
should
have
been
flattened
away
for
painting
"
)
;
}
nsRect
nsDisplayWrapList
:
:
GetComponentAlphaBounds
(
nsDisplayListBuilder
*
aBuilder
)
const
{
return
mListPtr
-
>
GetComponentAlphaBounds
(
aBuilder
)
;
}
bool
nsDisplayWrapList
:
:
CreateWebRenderCommands
(
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
aManager
-
>
CommandBuilder
(
)
.
CreateWebRenderCommandsFromDisplayList
(
GetChildren
(
)
this
aDisplayListBuilder
aSc
aBuilder
aResources
)
;
return
true
;
}
static
nsresult
WrapDisplayList
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
nsDisplayItemWrapper
*
aWrapper
)
{
if
(
!
aList
-
>
GetTop
(
)
)
{
return
NS_OK
;
}
nsDisplayItem
*
item
=
aWrapper
-
>
WrapList
(
aBuilder
aFrame
aList
)
;
if
(
!
item
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
aList
-
>
AppendToTop
(
item
)
;
return
NS_OK
;
}
static
nsresult
WrapEachDisplayItem
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
nsDisplayItemWrapper
*
aWrapper
)
{
nsDisplayList
newList
;
nsDisplayItem
*
item
;
while
(
(
item
=
aList
-
>
RemoveBottom
(
)
)
)
{
item
=
aWrapper
-
>
WrapItem
(
aBuilder
item
)
;
if
(
!
item
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
newList
.
AppendToTop
(
item
)
;
}
aList
-
>
AppendToTop
(
&
newList
)
;
return
NS_OK
;
}
nsresult
nsDisplayItemWrapper
:
:
WrapLists
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
nsDisplayListSet
&
aIn
const
nsDisplayListSet
&
aOut
)
{
nsresult
rv
=
WrapListsInPlace
(
aBuilder
aFrame
aIn
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
&
aOut
=
=
&
aIn
)
{
return
NS_OK
;
}
aOut
.
BorderBackground
(
)
-
>
AppendToTop
(
aIn
.
BorderBackground
(
)
)
;
aOut
.
BlockBorderBackgrounds
(
)
-
>
AppendToTop
(
aIn
.
BlockBorderBackgrounds
(
)
)
;
aOut
.
Floats
(
)
-
>
AppendToTop
(
aIn
.
Floats
(
)
)
;
aOut
.
Content
(
)
-
>
AppendToTop
(
aIn
.
Content
(
)
)
;
aOut
.
PositionedDescendants
(
)
-
>
AppendToTop
(
aIn
.
PositionedDescendants
(
)
)
;
aOut
.
Outlines
(
)
-
>
AppendToTop
(
aIn
.
Outlines
(
)
)
;
return
NS_OK
;
}
nsresult
nsDisplayItemWrapper
:
:
WrapListsInPlace
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
nsDisplayListSet
&
aLists
)
{
nsresult
rv
;
if
(
WrapBorderBackground
(
)
)
{
rv
=
WrapDisplayList
(
aBuilder
aFrame
aLists
.
BorderBackground
(
)
this
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
rv
=
WrapDisplayList
(
aBuilder
aFrame
aLists
.
BlockBorderBackgrounds
(
)
this
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
WrapEachDisplayItem
(
aBuilder
aLists
.
Floats
(
)
this
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
WrapDisplayList
(
aBuilder
aFrame
aLists
.
Content
(
)
this
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
WrapEachDisplayItem
(
aBuilder
aLists
.
PositionedDescendants
(
)
this
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
WrapEachDisplayItem
(
aBuilder
aLists
.
Outlines
(
)
this
)
;
}
nsDisplayOpacity
:
:
nsDisplayOpacity
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
ActiveScrolledRoot
*
aActiveScrolledRoot
bool
aForEventsOnly
bool
aNeedsActiveLayer
)
:
nsDisplayWrapList
(
aBuilder
aFrame
aList
aActiveScrolledRoot
true
)
mOpacity
(
aFrame
-
>
StyleEffects
(
)
-
>
mOpacity
)
mForEventsOnly
(
aForEventsOnly
)
mNeedsActiveLayer
(
aNeedsActiveLayer
)
mChildOpacityState
(
ChildOpacityState
:
:
Unknown
)
{
MOZ_COUNT_CTOR
(
nsDisplayOpacity
)
;
}
void
nsDisplayOpacity
:
:
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
nsDisplayItem
:
:
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
{
AutoRestore
<
float
>
opacity
(
aState
-
>
mCurrentOpacity
)
;
aState
-
>
mCurrentOpacity
*
=
mOpacity
;
if
(
aBuilder
-
>
HitTestIsForVisibility
(
)
&
&
mOpacity
=
=
0
.
0f
)
{
return
;
}
nsDisplayWrapList
:
:
HitTest
(
aBuilder
aRect
aState
aOutFrames
)
;
}
nsRegion
nsDisplayOpacity
:
:
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
{
*
aSnap
=
false
;
return
nsRegion
(
)
;
}
void
nsDisplayOpacity
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
if
(
GetOpacity
(
)
=
=
0
.
0f
)
{
return
;
}
if
(
GetOpacity
(
)
=
=
1
.
0f
)
{
GetChildren
(
)
-
>
Paint
(
aBuilder
aCtx
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
return
;
}
aCtx
-
>
GetDrawTarget
(
)
-
>
PushLayer
(
false
GetOpacity
(
)
nullptr
gfx
:
:
Matrix
(
)
)
;
GetChildren
(
)
-
>
Paint
(
aBuilder
aCtx
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
aCtx
-
>
GetDrawTarget
(
)
-
>
PopLayer
(
)
;
}
static
bool
IsItemTooSmallForActiveLayer
(
nsIFrame
*
aFrame
)
{
nsIntRect
visibleDevPixels
=
aFrame
-
>
InkOverflowRectRelativeToSelf
(
)
.
ToOutsidePixels
(
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
return
visibleDevPixels
.
Size
(
)
<
nsIntSize
(
StaticPrefs
:
:
layout_min_active_layer_size
(
)
StaticPrefs
:
:
layout_min_active_layer_size
(
)
)
;
}
bool
nsDisplayOpacity
:
:
NeedsActiveLayer
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
bool
aEnforceMinimumSize
)
{
return
EffectCompositor
:
:
HasAnimationsForCompositor
(
aFrame
DisplayItemType
:
:
TYPE_OPACITY
)
|
|
(
ActiveLayerTracker
:
:
IsStyleAnimated
(
aBuilder
aFrame
nsCSSPropertyIDSet
:
:
OpacityProperties
(
)
)
&
&
!
(
aEnforceMinimumSize
&
&
IsItemTooSmallForActiveLayer
(
aFrame
)
)
)
;
}
bool
nsDisplayOpacity
:
:
CanApplyOpacity
(
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aBuilder
)
const
{
return
!
EffectCompositor
:
:
HasAnimationsForCompositor
(
mFrame
DisplayItemType
:
:
TYPE_OPACITY
)
;
}
static
const
size_t
kOpacityMaxChildCount
=
3
;
static
const
size_t
kOpacityMaxListSize
=
kOpacityMaxChildCount
*
2
;
static
bool
CollectItemsWithOpacity
(
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
nsTArray
<
nsPaintedDisplayItem
*
>
&
aArray
)
{
if
(
aList
-
>
Count
(
)
>
kOpacityMaxListSize
)
{
return
false
;
}
for
(
nsDisplayItem
*
i
:
*
aList
)
{
const
DisplayItemType
type
=
i
-
>
GetType
(
)
;
if
(
type
=
=
DisplayItemType
:
:
TYPE_COMPOSITOR_HITTEST_INFO
)
{
continue
;
}
if
(
type
=
=
DisplayItemType
:
:
TYPE_WRAP_LIST
|
|
type
=
=
DisplayItemType
:
:
TYPE_CONTAINER
)
{
if
(
!
CollectItemsWithOpacity
(
aManager
aBuilder
i
-
>
GetChildren
(
)
aArray
)
)
{
return
false
;
}
continue
;
}
if
(
aArray
.
Length
(
)
=
=
kOpacityMaxChildCount
)
{
return
false
;
}
auto
*
item
=
i
-
>
AsPaintedDisplayItem
(
)
;
if
(
!
item
|
|
!
item
-
>
CanApplyOpacity
(
aManager
aBuilder
)
)
{
return
false
;
}
aArray
.
AppendElement
(
item
)
;
}
return
true
;
}
bool
nsDisplayOpacity
:
:
CanApplyToChildren
(
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aBuilder
)
{
if
(
mChildOpacityState
=
=
ChildOpacityState
:
:
Deferred
)
{
return
false
;
}
AutoTArray
<
nsPaintedDisplayItem
*
kOpacityMaxChildCount
>
items
;
if
(
!
CollectItemsWithOpacity
(
aManager
aBuilder
&
mList
items
)
)
{
mChildOpacityState
=
ChildOpacityState
:
:
Deferred
;
return
false
;
}
struct
{
nsPaintedDisplayItem
*
item
{
}
;
nsRect
bounds
;
}
children
[
kOpacityMaxChildCount
]
;
bool
snap
;
size_t
childCount
=
0
;
for
(
nsPaintedDisplayItem
*
item
:
items
)
{
children
[
childCount
]
.
item
=
item
;
children
[
childCount
]
.
bounds
=
item
-
>
GetBounds
(
aBuilder
&
snap
)
;
childCount
+
+
;
}
for
(
size_t
i
=
0
;
i
<
childCount
;
i
+
+
)
{
for
(
size_t
j
=
i
+
1
;
j
<
childCount
;
j
+
+
)
{
if
(
children
[
i
]
.
bounds
.
Intersects
(
children
[
j
]
.
bounds
)
)
{
mChildOpacityState
=
ChildOpacityState
:
:
Deferred
;
return
false
;
}
}
}
mChildOpacityState
=
ChildOpacityState
:
:
Applied
;
return
true
;
}
bool
nsDisplayOpacity
:
:
ApplyToMask
(
)
{
if
(
mList
.
Count
(
)
!
=
1
)
{
return
false
;
}
nsDisplayItem
*
item
=
mList
.
GetBottom
(
)
;
if
(
item
-
>
Frame
(
)
!
=
mFrame
)
{
return
false
;
}
const
DisplayItemType
type
=
item
-
>
GetType
(
)
;
if
(
type
=
=
DisplayItemType
:
:
TYPE_MASK
)
{
return
true
;
}
return
false
;
}
bool
nsDisplayOpacity
:
:
CanApplyOpacityToChildren
(
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aBuilder
float
aInheritedOpacity
)
{
if
(
mFrame
-
>
GetPrevContinuation
(
)
|
|
mFrame
-
>
GetNextContinuation
(
)
|
|
mFrame
-
>
HasAnyStateBits
(
NS_FRAME_PART_OF_IBSPLIT
)
)
{
return
false
;
}
if
(
mNeedsActiveLayer
|
|
mOpacity
=
=
0
.
0
)
{
return
false
;
}
if
(
mList
.
IsEmpty
(
)
)
{
return
false
;
}
if
(
aInheritedOpacity
=
=
1
.
0f
&
&
ApplyToMask
(
)
)
{
MOZ_ASSERT
(
SVGIntegrationUtils
:
:
UsingEffectsForFrame
(
mFrame
)
)
;
mChildOpacityState
=
ChildOpacityState
:
:
Applied
;
return
true
;
}
return
CanApplyToChildren
(
aManager
aBuilder
)
;
}
void
nsDisplayOpacity
:
:
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
{
const
auto
*
geometry
=
static_cast
<
const
nsDisplayOpacityGeometry
*
>
(
aGeometry
)
;
bool
snap
;
if
(
mOpacity
!
=
geometry
-
>
mOpacity
)
{
aInvalidRegion
-
>
Or
(
GetBounds
(
aBuilder
&
snap
)
geometry
-
>
mBounds
)
;
}
}
void
nsDisplayOpacity
:
:
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
{
aStream
<
<
"
(
opacity
"
<
<
mOpacity
<
<
"
mChildOpacityState
:
"
;
switch
(
mChildOpacityState
)
{
case
ChildOpacityState
:
:
Unknown
:
aStream
<
<
"
Unknown
"
;
break
;
case
ChildOpacityState
:
:
Applied
:
aStream
<
<
"
Applied
"
;
break
;
case
ChildOpacityState
:
:
Deferred
:
aStream
<
<
"
Deferred
"
;
break
;
default
:
break
;
}
aStream
<
<
"
)
"
;
}
bool
nsDisplayOpacity
:
:
CreateWebRenderCommands
(
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
MOZ_ASSERT
(
mChildOpacityState
!
=
ChildOpacityState
:
:
Applied
)
;
float
oldOpacity
=
aBuilder
.
GetInheritedOpacity
(
)
;
aBuilder
.
SetInheritedOpacity
(
1
.
0f
)
;
float
opacity
=
mOpacity
*
oldOpacity
;
float
*
opacityForSC
=
&
opacity
;
uint64_t
animationsId
=
AddAnimationsForWebRender
(
this
aManager
aDisplayListBuilder
)
;
wr
:
:
WrAnimationProperty
prop
{
wr
:
:
WrAnimationType
:
:
Opacity
animationsId
}
;
wr
:
:
StackingContextParams
params
;
params
.
animation
=
animationsId
?
&
prop
:
nullptr
;
params
.
opacity
=
opacityForSC
;
params
.
clip
=
wr
:
:
WrStackingContextClip
:
:
ClipChain
(
aBuilder
.
CurrentClipChainId
(
)
)
;
StackingContextHelper
sc
(
aSc
GetActiveScrolledRoot
(
)
mFrame
this
aBuilder
params
)
;
aManager
-
>
CommandBuilder
(
)
.
CreateWebRenderCommandsFromDisplayList
(
&
mList
this
aDisplayListBuilder
sc
aBuilder
aResources
)
;
aBuilder
.
SetInheritedOpacity
(
oldOpacity
)
;
return
true
;
}
nsDisplayBlendMode
:
:
nsDisplayBlendMode
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
StyleBlend
aBlendMode
const
ActiveScrolledRoot
*
aActiveScrolledRoot
const
bool
aIsForBackground
)
:
nsDisplayWrapList
(
aBuilder
aFrame
aList
aActiveScrolledRoot
true
)
mBlendMode
(
aBlendMode
)
mIsForBackground
(
aIsForBackground
)
{
MOZ_COUNT_CTOR
(
nsDisplayBlendMode
)
;
}
nsRegion
nsDisplayBlendMode
:
:
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
{
*
aSnap
=
false
;
return
nsRegion
(
)
;
}
bool
nsDisplayBlendMode
:
:
CreateWebRenderCommands
(
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
wr
:
:
StackingContextParams
params
;
params
.
mix_blend_mode
=
wr
:
:
ToMixBlendMode
(
nsCSSRendering
:
:
GetGFXBlendMode
(
mBlendMode
)
)
;
params
.
clip
=
wr
:
:
WrStackingContextClip
:
:
ClipChain
(
aBuilder
.
CurrentClipChainId
(
)
)
;
StackingContextHelper
sc
(
aSc
GetActiveScrolledRoot
(
)
mFrame
this
aBuilder
params
)
;
return
nsDisplayWrapList
:
:
CreateWebRenderCommands
(
aBuilder
aResources
sc
aManager
aDisplayListBuilder
)
;
}
void
nsDisplayBlendMode
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
DrawTarget
*
dt
=
aCtx
-
>
GetDrawTarget
(
)
;
int32_t
appUnitsPerDevPixel
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
Rect
rect
=
NSRectToRect
(
GetPaintRect
(
aBuilder
aCtx
)
appUnitsPerDevPixel
)
;
rect
.
RoundOut
(
)
;
RefPtr
<
DrawTarget
>
temp
=
dt
-
>
CreateClippedDrawTarget
(
rect
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
!
temp
)
{
return
;
}
RefPtr
<
gfxContext
>
ctx
=
gfxContext
:
:
CreatePreservingTransformOrNull
(
temp
)
;
GetChildren
(
)
-
>
Paint
(
aBuilder
ctx
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
temp
-
>
Flush
(
)
;
RefPtr
<
SourceSurface
>
surface
=
temp
-
>
Snapshot
(
)
;
gfxContextMatrixAutoSaveRestore
saveMatrix
(
aCtx
)
;
dt
-
>
SetTransform
(
Matrix
(
)
)
;
dt
-
>
DrawSurface
(
surface
Rect
(
surface
-
>
GetRect
(
)
)
Rect
(
surface
-
>
GetRect
(
)
)
DrawSurfaceOptions
(
)
DrawOptions
(
1
.
0f
nsCSSRendering
:
:
GetGFXBlendMode
(
mBlendMode
)
)
)
;
}
gfx
:
:
CompositionOp
nsDisplayBlendMode
:
:
BlendMode
(
)
{
return
nsCSSRendering
:
:
GetGFXBlendMode
(
mBlendMode
)
;
}
bool
nsDisplayBlendMode
:
:
CanMerge
(
const
nsDisplayItem
*
aItem
)
const
{
if
(
!
HasDifferentFrame
(
aItem
)
|
|
!
HasSameTypeAndClip
(
aItem
)
|
|
!
HasSameContent
(
aItem
)
)
{
return
false
;
}
const
auto
*
item
=
static_cast
<
const
nsDisplayBlendMode
*
>
(
aItem
)
;
if
(
mIsForBackground
|
|
item
-
>
mIsForBackground
)
{
return
false
;
}
return
true
;
}
nsDisplayBlendContainer
*
nsDisplayBlendContainer
:
:
CreateForMixBlendMode
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
ActiveScrolledRoot
*
aActiveScrolledRoot
)
{
return
MakeDisplayItem
<
nsDisplayBlendContainer
>
(
aBuilder
aFrame
aList
aActiveScrolledRoot
false
)
;
}
nsDisplayBlendContainer
*
nsDisplayBlendContainer
:
:
CreateForBackgroundBlendMode
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsIFrame
*
aSecondaryFrame
nsDisplayList
*
aList
const
ActiveScrolledRoot
*
aActiveScrolledRoot
)
{
if
(
aSecondaryFrame
)
{
auto
type
=
GetTableTypeFromFrame
(
aFrame
)
;
auto
index
=
static_cast
<
uint16_t
>
(
type
)
;
return
MakeDisplayItemWithIndex
<
nsDisplayTableBlendContainer
>
(
aBuilder
aSecondaryFrame
index
aList
aActiveScrolledRoot
true
aFrame
)
;
}
return
MakeDisplayItemWithIndex
<
nsDisplayBlendContainer
>
(
aBuilder
aFrame
1
aList
aActiveScrolledRoot
true
)
;
}
nsDisplayBlendContainer
:
:
nsDisplayBlendContainer
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
ActiveScrolledRoot
*
aActiveScrolledRoot
bool
aIsForBackground
)
:
nsDisplayWrapList
(
aBuilder
aFrame
aList
aActiveScrolledRoot
true
)
mIsForBackground
(
aIsForBackground
)
{
MOZ_COUNT_CTOR
(
nsDisplayBlendContainer
)
;
}
void
nsDisplayBlendContainer
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
aCtx
-
>
GetDrawTarget
(
)
-
>
PushLayer
(
false
1
.
0
nullptr
gfx
:
:
Matrix
(
)
)
;
GetChildren
(
)
-
>
Paint
(
aBuilder
aCtx
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
aCtx
-
>
GetDrawTarget
(
)
-
>
PopLayer
(
)
;
}
bool
nsDisplayBlendContainer
:
:
CreateWebRenderCommands
(
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
wr
:
:
StackingContextParams
params
;
params
.
flags
|
=
wr
:
:
StackingContextFlags
:
:
IS_BLEND_CONTAINER
;
params
.
clip
=
wr
:
:
WrStackingContextClip
:
:
ClipChain
(
aBuilder
.
CurrentClipChainId
(
)
)
;
StackingContextHelper
sc
(
aSc
GetActiveScrolledRoot
(
)
mFrame
this
aBuilder
params
)
;
return
nsDisplayWrapList
:
:
CreateWebRenderCommands
(
aBuilder
aResources
sc
aManager
aDisplayListBuilder
)
;
}
nsDisplayOwnLayer
:
:
nsDisplayOwnLayer
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
ActiveScrolledRoot
*
aActiveScrolledRoot
nsDisplayOwnLayerFlags
aFlags
const
ScrollbarData
&
aScrollbarData
bool
aForceActive
bool
aClearClipChain
)
:
nsDisplayWrapList
(
aBuilder
aFrame
aList
aActiveScrolledRoot
aClearClipChain
)
mFlags
(
aFlags
)
mScrollbarData
(
aScrollbarData
)
mForceActive
(
aForceActive
)
mWrAnimationId
(
0
)
{
MOZ_COUNT_CTOR
(
nsDisplayOwnLayer
)
;
}
bool
nsDisplayOwnLayer
:
:
IsScrollThumbLayer
(
)
const
{
return
mScrollbarData
.
mScrollbarLayerType
=
=
ScrollbarLayerType
:
:
Thumb
;
}
bool
nsDisplayOwnLayer
:
:
IsScrollbarContainer
(
)
const
{
return
mScrollbarData
.
mScrollbarLayerType
=
=
ScrollbarLayerType
:
:
Container
;
}
bool
nsDisplayOwnLayer
:
:
IsRootScrollbarContainer
(
)
const
{
if
(
!
IsScrollbarContainer
(
)
)
{
return
false
;
}
return
mFrame
-
>
PresContext
(
)
-
>
IsRootContentDocumentCrossProcess
(
)
&
&
mScrollbarData
.
mTargetViewId
=
=
nsLayoutUtils
:
:
ScrollIdForRootScrollFrame
(
mFrame
-
>
PresContext
(
)
)
;
}
bool
nsDisplayOwnLayer
:
:
IsZoomingLayer
(
)
const
{
return
GetType
(
)
=
=
DisplayItemType
:
:
TYPE_ASYNC_ZOOM
;
}
bool
nsDisplayOwnLayer
:
:
IsFixedPositionLayer
(
)
const
{
return
GetType
(
)
=
=
DisplayItemType
:
:
TYPE_FIXED_POSITION
;
}
bool
nsDisplayOwnLayer
:
:
IsStickyPositionLayer
(
)
const
{
return
GetType
(
)
=
=
DisplayItemType
:
:
TYPE_STICKY_POSITION
;
}
bool
nsDisplayOwnLayer
:
:
HasDynamicToolbar
(
)
const
{
if
(
!
mFrame
-
>
PresContext
(
)
-
>
IsRootContentDocumentCrossProcess
(
)
)
{
return
false
;
}
return
mFrame
-
>
PresContext
(
)
-
>
HasDynamicToolbar
(
)
|
|
StaticPrefs
:
:
apz_fixed_margin_override_enabled
(
)
;
}
bool
nsDisplayOwnLayer
:
:
CreateWebRenderCommands
(
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
Maybe
<
wr
:
:
WrAnimationProperty
>
prop
;
bool
needsProp
=
aManager
-
>
LayerManager
(
)
-
>
AsyncPanZoomEnabled
(
)
&
&
(
IsScrollThumbLayer
(
)
|
|
IsZoomingLayer
(
)
|
|
(
IsFixedPositionLayer
(
)
&
&
HasDynamicToolbar
(
)
)
|
|
(
IsStickyPositionLayer
(
)
&
&
HasDynamicToolbar
(
)
)
|
|
(
IsRootScrollbarContainer
(
)
&
&
HasDynamicToolbar
(
)
)
)
;
if
(
needsProp
)
{
RefPtr
<
WebRenderAPZAnimationData
>
animationData
=
aManager
-
>
CommandBuilder
(
)
.
CreateOrRecycleWebRenderUserData
<
WebRenderAPZAnimationData
>
(
this
)
;
mWrAnimationId
=
animationData
-
>
GetAnimationId
(
)
;
prop
.
emplace
(
)
;
prop
-
>
id
=
mWrAnimationId
;
prop
-
>
key
=
wr
:
:
SpatialKey
(
uint64_t
(
mFrame
)
GetPerFrameKey
(
)
wr
:
:
SpatialKeyKind
:
:
APZ
)
;
prop
-
>
effect_type
=
wr
:
:
WrAnimationType
:
:
Transform
;
}
wr
:
:
StackingContextParams
params
;
params
.
animation
=
prop
.
ptrOr
(
nullptr
)
;
params
.
clip
=
wr
:
:
WrStackingContextClip
:
:
ClipChain
(
aBuilder
.
CurrentClipChainId
(
)
)
;
if
(
IsScrollbarContainer
(
)
)
{
params
.
prim_flags
|
=
wr
:
:
PrimitiveFlags
:
:
IS_SCROLLBAR_CONTAINER
;
}
if
(
IsScrollThumbLayer
(
)
)
{
params
.
prim_flags
|
=
wr
:
:
PrimitiveFlags
:
:
IS_SCROLLBAR_THUMB
;
}
if
(
IsZoomingLayer
(
)
|
|
(
(
IsFixedPositionLayer
(
)
&
&
HasDynamicToolbar
(
)
)
|
|
(
IsStickyPositionLayer
(
)
&
&
HasDynamicToolbar
(
)
)
|
|
(
IsRootScrollbarContainer
(
)
&
&
HasDynamicToolbar
(
)
)
)
)
{
params
.
is_2d_scale_translation
=
true
;
params
.
should_snap
=
true
;
}
StackingContextHelper
sc
(
aSc
GetActiveScrolledRoot
(
)
mFrame
this
aBuilder
params
)
;
nsDisplayWrapList
:
:
CreateWebRenderCommands
(
aBuilder
aResources
sc
aManager
aDisplayListBuilder
)
;
return
true
;
}
bool
nsDisplayOwnLayer
:
:
UpdateScrollData
(
WebRenderScrollData
*
aData
WebRenderLayerScrollData
*
aLayerData
)
{
bool
isRelevantToApz
=
(
IsScrollThumbLayer
(
)
|
|
IsScrollbarContainer
(
)
|
|
IsZoomingLayer
(
)
|
|
(
IsFixedPositionLayer
(
)
&
&
HasDynamicToolbar
(
)
)
|
|
(
IsStickyPositionLayer
(
)
&
&
HasDynamicToolbar
(
)
)
)
;
if
(
!
isRelevantToApz
)
{
return
false
;
}
if
(
!
aLayerData
)
{
return
true
;
}
if
(
IsZoomingLayer
(
)
)
{
aLayerData
-
>
SetZoomAnimationId
(
mWrAnimationId
)
;
return
true
;
}
if
(
IsFixedPositionLayer
(
)
&
&
HasDynamicToolbar
(
)
)
{
aLayerData
-
>
SetFixedPositionAnimationId
(
mWrAnimationId
)
;
return
true
;
}
if
(
IsStickyPositionLayer
(
)
&
&
HasDynamicToolbar
(
)
)
{
aLayerData
-
>
SetStickyPositionAnimationId
(
mWrAnimationId
)
;
return
true
;
}
MOZ_ASSERT
(
IsScrollbarContainer
(
)
|
|
IsScrollThumbLayer
(
)
)
;
aLayerData
-
>
SetScrollbarData
(
mScrollbarData
)
;
if
(
IsRootScrollbarContainer
(
)
&
&
HasDynamicToolbar
(
)
)
{
aLayerData
-
>
SetScrollbarAnimationId
(
mWrAnimationId
)
;
return
true
;
}
if
(
IsScrollThumbLayer
(
)
)
{
aLayerData
-
>
SetScrollbarAnimationId
(
mWrAnimationId
)
;
LayoutDeviceRect
bounds
=
LayoutDeviceIntRect
:
:
FromAppUnits
(
mBounds
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
LayerIntRect
layerBounds
=
RoundedOut
(
bounds
*
LayoutDeviceToLayerScale
(
1
.
0f
)
)
;
aLayerData
-
>
SetVisibleRegion
(
LayerIntRegion
(
layerBounds
)
)
;
}
return
true
;
}
void
nsDisplayOwnLayer
:
:
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
{
aStream
<
<
nsPrintfCString
(
"
(
flags
0x
%
x
)
(
scrolltarget
%
"
PRIu64
"
)
"
(
int
)
mFlags
mScrollbarData
.
mTargetViewId
)
.
get
(
)
;
}
nsDisplaySubDocument
:
:
nsDisplaySubDocument
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsSubDocumentFrame
*
aSubDocFrame
nsDisplayList
*
aList
nsDisplayOwnLayerFlags
aFlags
)
:
nsDisplayOwnLayer
(
aBuilder
aFrame
aList
aBuilder
-
>
CurrentActiveScrolledRoot
(
)
aFlags
)
mScrollParentId
(
aBuilder
-
>
GetCurrentScrollParentId
(
)
)
mShouldFlatten
(
false
)
mSubDocFrame
(
aSubDocFrame
)
{
MOZ_COUNT_CTOR
(
nsDisplaySubDocument
)
;
if
(
mSubDocFrame
&
&
mSubDocFrame
!
=
mFrame
)
{
mSubDocFrame
-
>
AddDisplayItem
(
this
)
;
}
}
nsDisplaySubDocument
:
:
~
nsDisplaySubDocument
(
)
{
MOZ_COUNT_DTOR
(
nsDisplaySubDocument
)
;
if
(
mSubDocFrame
)
{
mSubDocFrame
-
>
RemoveDisplayItem
(
this
)
;
}
}
nsIFrame
*
nsDisplaySubDocument
:
:
FrameForInvalidation
(
)
const
{
return
mSubDocFrame
?
mSubDocFrame
:
mFrame
;
}
void
nsDisplaySubDocument
:
:
RemoveFrame
(
nsIFrame
*
aFrame
)
{
if
(
aFrame
=
=
mSubDocFrame
)
{
mSubDocFrame
=
nullptr
;
SetDeletedFrame
(
)
;
}
nsDisplayOwnLayer
:
:
RemoveFrame
(
aFrame
)
;
}
void
nsDisplaySubDocument
:
:
Disown
(
)
{
if
(
mFrame
)
{
mFrame
-
>
RemoveDisplayItem
(
this
)
;
RemoveFrame
(
mFrame
)
;
}
if
(
mSubDocFrame
)
{
mSubDocFrame
-
>
RemoveDisplayItem
(
this
)
;
RemoveFrame
(
mSubDocFrame
)
;
}
}
static
bool
UseDisplayPortForViewport
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
{
return
aBuilder
-
>
IsPaintingToWindow
(
)
&
&
DisplayPortUtils
:
:
ViewportHasDisplayPort
(
aFrame
-
>
PresContext
(
)
)
;
}
nsRect
nsDisplaySubDocument
:
:
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
{
bool
usingDisplayPort
=
UseDisplayPortForViewport
(
aBuilder
mFrame
)
;
if
(
(
mFlags
&
nsDisplayOwnLayerFlags
:
:
GenerateScrollableLayer
)
&
&
usingDisplayPort
)
{
*
aSnap
=
false
;
return
mFrame
-
>
GetRect
(
)
+
aBuilder
-
>
ToReferenceFrame
(
mFrame
)
;
}
return
nsDisplayOwnLayer
:
:
GetBounds
(
aBuilder
aSnap
)
;
}
nsRegion
nsDisplaySubDocument
:
:
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
{
bool
usingDisplayPort
=
UseDisplayPortForViewport
(
aBuilder
mFrame
)
;
if
(
(
mFlags
&
nsDisplayOwnLayerFlags
:
:
GenerateScrollableLayer
)
&
&
usingDisplayPort
)
{
*
aSnap
=
false
;
return
nsRegion
(
)
;
}
return
nsDisplayOwnLayer
:
:
GetOpaqueRegion
(
aBuilder
aSnap
)
;
}
nsDisplayFixedPosition
*
nsDisplayFixedPosition
:
:
CreateForFixedBackground
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsIFrame
*
aSecondaryFrame
nsDisplayBackgroundImage
*
aImage
const
uint16_t
aIndex
const
ActiveScrolledRoot
*
aScrollTargetASR
)
{
nsDisplayList
temp
;
temp
.
AppendToTop
(
aImage
)
;
if
(
aSecondaryFrame
)
{
auto
tableType
=
GetTableTypeFromFrame
(
aFrame
)
;
const
uint16_t
index
=
CalculateTablePerFrameKey
(
aIndex
+
1
tableType
)
;
return
MakeDisplayItemWithIndex
<
nsDisplayTableFixedPosition
>
(
aBuilder
aSecondaryFrame
index
&
temp
aFrame
aScrollTargetASR
)
;
}
return
MakeDisplayItemWithIndex
<
nsDisplayFixedPosition
>
(
aBuilder
aFrame
aIndex
+
1
&
temp
aScrollTargetASR
)
;
}
nsDisplayFixedPosition
:
:
nsDisplayFixedPosition
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
ActiveScrolledRoot
*
aActiveScrolledRoot
const
ActiveScrolledRoot
*
aScrollTargetASR
)
:
nsDisplayOwnLayer
(
aBuilder
aFrame
aList
aActiveScrolledRoot
)
mScrollTargetASR
(
aScrollTargetASR
)
mIsFixedBackground
(
false
)
{
MOZ_COUNT_CTOR
(
nsDisplayFixedPosition
)
;
}
nsDisplayFixedPosition
:
:
nsDisplayFixedPosition
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
ActiveScrolledRoot
*
aScrollTargetASR
)
:
nsDisplayOwnLayer
(
aBuilder
aFrame
aList
aBuilder
-
>
CurrentActiveScrolledRoot
(
)
)
mScrollTargetASR
(
aScrollTargetASR
)
mIsFixedBackground
(
true
)
{
MOZ_COUNT_CTOR
(
nsDisplayFixedPosition
)
;
}
ScrollableLayerGuid
:
:
ViewID
nsDisplayFixedPosition
:
:
GetScrollTargetId
(
)
{
if
(
mScrollTargetASR
&
&
(
mIsFixedBackground
|
|
!
nsLayoutUtils
:
:
IsReallyFixedPos
(
mFrame
)
)
)
{
return
mScrollTargetASR
-
>
GetViewId
(
)
;
}
return
nsLayoutUtils
:
:
ScrollIdForRootScrollFrame
(
mFrame
-
>
PresContext
(
)
)
;
}
bool
nsDisplayFixedPosition
:
:
CreateWebRenderCommands
(
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
SideBits
sides
=
SideBits
:
:
eNone
;
if
(
!
mIsFixedBackground
)
{
sides
=
nsLayoutUtils
:
:
GetSideBitsForFixedPositionContent
(
mFrame
)
;
}
wr
:
:
DisplayListBuilder
:
:
FixedPosScrollTargetTracker
tracker
(
aBuilder
GetActiveScrolledRoot
(
)
GetScrollTargetId
(
)
sides
)
;
return
nsDisplayOwnLayer
:
:
CreateWebRenderCommands
(
aBuilder
aResources
aSc
aManager
aDisplayListBuilder
)
;
}
bool
nsDisplayFixedPosition
:
:
UpdateScrollData
(
WebRenderScrollData
*
aData
WebRenderLayerScrollData
*
aLayerData
)
{
if
(
aLayerData
)
{
if
(
!
mIsFixedBackground
)
{
aLayerData
-
>
SetFixedPositionSides
(
nsLayoutUtils
:
:
GetSideBitsForFixedPositionContent
(
mFrame
)
)
;
}
aLayerData
-
>
SetFixedPositionScrollContainerId
(
GetScrollTargetId
(
)
)
;
}
nsDisplayOwnLayer
:
:
UpdateScrollData
(
aData
aLayerData
)
;
return
true
;
}
void
nsDisplayFixedPosition
:
:
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
{
aStream
<
<
nsPrintfCString
(
"
(
containerASR
%
s
)
(
scrolltarget
%
"
PRIu64
"
)
"
ActiveScrolledRoot
:
:
ToString
(
mScrollTargetASR
)
.
get
(
)
GetScrollTargetId
(
)
)
.
get
(
)
;
}
TableType
GetTableTypeFromFrame
(
nsIFrame
*
aFrame
)
{
if
(
aFrame
-
>
IsTableFrame
(
)
)
{
return
TableType
:
:
Table
;
}
if
(
aFrame
-
>
IsTableColFrame
(
)
)
{
return
TableType
:
:
TableCol
;
}
if
(
aFrame
-
>
IsTableColGroupFrame
(
)
)
{
return
TableType
:
:
TableColGroup
;
}
if
(
aFrame
-
>
IsTableRowFrame
(
)
)
{
return
TableType
:
:
TableRow
;
}
if
(
aFrame
-
>
IsTableRowGroupFrame
(
)
)
{
return
TableType
:
:
TableRowGroup
;
}
if
(
aFrame
-
>
IsTableCellFrame
(
)
)
{
return
TableType
:
:
TableCell
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
frame
.
"
)
;
return
TableType
:
:
Table
;
}
nsDisplayTableFixedPosition
:
:
nsDisplayTableFixedPosition
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
nsIFrame
*
aAncestorFrame
const
ActiveScrolledRoot
*
aScrollTargetASR
)
:
nsDisplayFixedPosition
(
aBuilder
aFrame
aList
aScrollTargetASR
)
mAncestorFrame
(
aAncestorFrame
)
{
if
(
aBuilder
-
>
IsRetainingDisplayList
(
)
)
{
mAncestorFrame
-
>
AddDisplayItem
(
this
)
;
}
}
nsDisplayStickyPosition
:
:
nsDisplayStickyPosition
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
ActiveScrolledRoot
*
aActiveScrolledRoot
const
ActiveScrolledRoot
*
aContainerASR
bool
aClippedToDisplayPort
)
:
nsDisplayOwnLayer
(
aBuilder
aFrame
aList
aActiveScrolledRoot
)
mContainerASR
(
aContainerASR
)
mClippedToDisplayPort
(
aClippedToDisplayPort
)
{
MOZ_COUNT_CTOR
(
nsDisplayStickyPosition
)
;
}
static
nscoord
DistanceToRange
(
nscoord
min
nscoord
max
)
{
MOZ_ASSERT
(
min
<
=
max
)
;
if
(
max
<
0
)
{
return
max
;
}
if
(
min
>
0
)
{
return
min
;
}
MOZ_ASSERT
(
min
<
=
0
&
&
max
>
=
0
)
;
return
0
;
}
static
nscoord
PositivePart
(
nscoord
min
nscoord
max
)
{
MOZ_ASSERT
(
min
<
=
max
)
;
if
(
min
>
=
0
)
{
return
max
-
min
;
}
if
(
max
>
0
)
{
return
max
;
}
return
0
;
}
static
nscoord
NegativePart
(
nscoord
min
nscoord
max
)
{
MOZ_ASSERT
(
min
<
=
max
)
;
if
(
max
<
=
0
)
{
return
max
-
min
;
}
if
(
min
<
0
)
{
return
0
-
min
;
}
return
0
;
}
StickyScrollContainer
*
nsDisplayStickyPosition
:
:
GetStickyScrollContainer
(
)
{
StickyScrollContainer
*
stickyScrollContainer
=
StickyScrollContainer
:
:
GetStickyScrollContainerForFrame
(
mFrame
)
;
if
(
stickyScrollContainer
)
{
if
(
!
stickyScrollContainer
-
>
ScrollFrame
(
)
-
>
IsMaybeAsynchronouslyScrolled
(
)
)
{
stickyScrollContainer
=
nullptr
;
}
}
return
stickyScrollContainer
;
}
bool
nsDisplayStickyPosition
:
:
CreateWebRenderCommands
(
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
StickyScrollContainer
*
stickyScrollContainer
=
GetStickyScrollContainer
(
)
;
Maybe
<
wr
:
:
SpaceAndClipChainHelper
>
saccHelper
;
if
(
stickyScrollContainer
)
{
float
auPerDevPixel
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
bool
snap
;
nsRect
itemBounds
=
GetBounds
(
aDisplayListBuilder
&
snap
)
;
Maybe
<
float
>
topMargin
;
Maybe
<
float
>
rightMargin
;
Maybe
<
float
>
bottomMargin
;
Maybe
<
float
>
leftMargin
;
wr
:
:
StickyOffsetBounds
vBounds
=
{
0
.
0
0
.
0
}
;
wr
:
:
StickyOffsetBounds
hBounds
=
{
0
.
0
0
.
0
}
;
nsPoint
appliedOffset
;
nsRectAbsolute
outer
;
nsRectAbsolute
inner
;
stickyScrollContainer
-
>
GetScrollRanges
(
mFrame
&
outer
&
inner
)
;
nsIFrame
*
scrollFrame
=
do_QueryFrame
(
stickyScrollContainer
-
>
ScrollFrame
(
)
)
;
nsPoint
offset
=
scrollFrame
-
>
GetOffsetToCrossDoc
(
Frame
(
)
)
+
ToReferenceFrame
(
)
;
nsRect
scrollPort
=
stickyScrollContainer
-
>
ScrollFrame
(
)
-
>
GetScrollPortRect
(
)
;
scrollPort
+
=
offset
;
if
(
outer
.
YMost
(
)
!
=
inner
.
YMost
(
)
)
{
nscoord
distance
=
DistanceToRange
(
inner
.
YMost
(
)
outer
.
YMost
(
)
)
;
if
(
distance
>
0
)
{
distance
-
=
PositivePart
(
outer
.
Y
(
)
inner
.
Y
(
)
)
;
}
topMargin
=
Some
(
NSAppUnitsToFloatPixels
(
itemBounds
.
y
-
scrollPort
.
y
-
distance
auPerDevPixel
)
)
;
vBounds
.
max
=
NSAppUnitsToFloatPixels
(
outer
.
YMost
(
)
-
inner
.
YMost
(
)
auPerDevPixel
)
;
if
(
inner
.
YMost
(
)
<
0
)
{
appliedOffset
.
y
=
std
:
:
min
(
0
outer
.
YMost
(
)
)
-
inner
.
YMost
(
)
;
MOZ_ASSERT
(
appliedOffset
.
y
>
0
)
;
}
}
if
(
outer
.
Y
(
)
!
=
inner
.
Y
(
)
)
{
nscoord
distance
=
DistanceToRange
(
outer
.
Y
(
)
inner
.
Y
(
)
)
;
if
(
distance
<
0
)
{
distance
+
=
NegativePart
(
inner
.
YMost
(
)
outer
.
YMost
(
)
)
;
}
bottomMargin
=
Some
(
NSAppUnitsToFloatPixels
(
scrollPort
.
YMost
(
)
-
itemBounds
.
YMost
(
)
+
distance
auPerDevPixel
)
)
;
vBounds
.
min
=
NSAppUnitsToFloatPixels
(
outer
.
Y
(
)
-
inner
.
Y
(
)
auPerDevPixel
)
;
if
(
appliedOffset
.
y
=
=
0
&
&
inner
.
Y
(
)
>
0
)
{
appliedOffset
.
y
=
std
:
:
max
(
0
outer
.
Y
(
)
)
-
inner
.
Y
(
)
;
MOZ_ASSERT
(
appliedOffset
.
y
<
0
)
;
}
}
if
(
outer
.
XMost
(
)
!
=
inner
.
XMost
(
)
)
{
nscoord
distance
=
DistanceToRange
(
inner
.
XMost
(
)
outer
.
XMost
(
)
)
;
if
(
distance
>
0
)
{
distance
-
=
PositivePart
(
outer
.
X
(
)
inner
.
X
(
)
)
;
}
leftMargin
=
Some
(
NSAppUnitsToFloatPixels
(
itemBounds
.
x
-
scrollPort
.
x
-
distance
auPerDevPixel
)
)
;
hBounds
.
max
=
NSAppUnitsToFloatPixels
(
outer
.
XMost
(
)
-
inner
.
XMost
(
)
auPerDevPixel
)
;
if
(
inner
.
XMost
(
)
<
0
)
{
appliedOffset
.
x
=
std
:
:
min
(
0
outer
.
XMost
(
)
)
-
inner
.
XMost
(
)
;
MOZ_ASSERT
(
appliedOffset
.
x
>
0
)
;
}
}
if
(
outer
.
X
(
)
!
=
inner
.
X
(
)
)
{
nscoord
distance
=
DistanceToRange
(
outer
.
X
(
)
inner
.
X
(
)
)
;
if
(
distance
<
0
)
{
distance
+
=
NegativePart
(
inner
.
XMost
(
)
outer
.
XMost
(
)
)
;
}
rightMargin
=
Some
(
NSAppUnitsToFloatPixels
(
scrollPort
.
XMost
(
)
-
itemBounds
.
XMost
(
)
+
distance
auPerDevPixel
)
)
;
hBounds
.
min
=
NSAppUnitsToFloatPixels
(
outer
.
X
(
)
-
inner
.
X
(
)
auPerDevPixel
)
;
if
(
appliedOffset
.
x
=
=
0
&
&
inner
.
X
(
)
>
0
)
{
appliedOffset
.
x
=
std
:
:
max
(
0
outer
.
X
(
)
)
-
inner
.
X
(
)
;
MOZ_ASSERT
(
appliedOffset
.
x
<
0
)
;
}
}
LayoutDeviceRect
bounds
=
LayoutDeviceRect
:
:
FromAppUnits
(
itemBounds
auPerDevPixel
)
;
wr
:
:
LayoutVector2D
applied
=
{
NSAppUnitsToFloatPixels
(
appliedOffset
.
x
auPerDevPixel
)
NSAppUnitsToFloatPixels
(
appliedOffset
.
y
auPerDevPixel
)
}
;
wr
:
:
WrSpatialId
spatialId
=
aBuilder
.
DefineStickyFrame
(
wr
:
:
ToLayoutRect
(
bounds
)
topMargin
.
ptrOr
(
nullptr
)
rightMargin
.
ptrOr
(
nullptr
)
bottomMargin
.
ptrOr
(
nullptr
)
leftMargin
.
ptrOr
(
nullptr
)
vBounds
hBounds
applied
wr
:
:
SpatialKey
(
uint64_t
(
mFrame
)
GetPerFrameKey
(
)
wr
:
:
SpatialKeyKind
:
:
Sticky
)
)
;
saccHelper
.
emplace
(
aBuilder
spatialId
)
;
aManager
-
>
CommandBuilder
(
)
.
PushOverrideForASR
(
mContainerASR
spatialId
)
;
}
{
wr
:
:
StackingContextParams
params
;
params
.
clip
=
wr
:
:
WrStackingContextClip
:
:
ClipChain
(
aBuilder
.
CurrentClipChainId
(
)
)
;
StackingContextHelper
sc
(
aSc
GetActiveScrolledRoot
(
)
mFrame
this
aBuilder
params
)
;
nsDisplayOwnLayer
:
:
CreateWebRenderCommands
(
aBuilder
aResources
sc
aManager
aDisplayListBuilder
)
;
}
if
(
stickyScrollContainer
)
{
aManager
-
>
CommandBuilder
(
)
.
PopOverrideForASR
(
mContainerASR
)
;
}
return
true
;
}
void
nsDisplayStickyPosition
:
:
CalculateLayerScrollRanges
(
StickyScrollContainer
*
aStickyScrollContainer
float
aAppUnitsPerDevPixel
float
aScaleX
float
aScaleY
LayerRectAbsolute
&
aStickyOuter
LayerRectAbsolute
&
aStickyInner
)
{
nsRectAbsolute
outer
;
nsRectAbsolute
inner
;
aStickyScrollContainer
-
>
GetScrollRanges
(
mFrame
&
outer
&
inner
)
;
aStickyOuter
.
SetBox
(
NSAppUnitsToFloatPixels
(
outer
.
X
(
)
aAppUnitsPerDevPixel
)
*
aScaleX
NSAppUnitsToFloatPixels
(
outer
.
Y
(
)
aAppUnitsPerDevPixel
)
*
aScaleY
NSAppUnitsToFloatPixels
(
outer
.
XMost
(
)
aAppUnitsPerDevPixel
)
*
aScaleX
NSAppUnitsToFloatPixels
(
outer
.
YMost
(
)
aAppUnitsPerDevPixel
)
*
aScaleY
)
;
aStickyInner
.
SetBox
(
NSAppUnitsToFloatPixels
(
inner
.
X
(
)
aAppUnitsPerDevPixel
)
*
aScaleX
NSAppUnitsToFloatPixels
(
inner
.
Y
(
)
aAppUnitsPerDevPixel
)
*
aScaleY
NSAppUnitsToFloatPixels
(
inner
.
XMost
(
)
aAppUnitsPerDevPixel
)
*
aScaleX
NSAppUnitsToFloatPixels
(
inner
.
YMost
(
)
aAppUnitsPerDevPixel
)
*
aScaleY
)
;
}
bool
nsDisplayStickyPosition
:
:
UpdateScrollData
(
WebRenderScrollData
*
aData
WebRenderLayerScrollData
*
aLayerData
)
{
bool
hasDynamicToolbar
=
HasDynamicToolbar
(
)
;
if
(
aLayerData
&
&
hasDynamicToolbar
)
{
StickyScrollContainer
*
stickyScrollContainer
=
GetStickyScrollContainer
(
)
;
if
(
stickyScrollContainer
)
{
float
auPerDevPixel
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
float
cumulativeResolution
=
mFrame
-
>
PresShell
(
)
-
>
GetCumulativeResolution
(
)
;
LayerRectAbsolute
stickyOuter
;
LayerRectAbsolute
stickyInner
;
CalculateLayerScrollRanges
(
stickyScrollContainer
auPerDevPixel
cumulativeResolution
cumulativeResolution
stickyOuter
stickyInner
)
;
aLayerData
-
>
SetStickyScrollRangeOuter
(
stickyOuter
)
;
aLayerData
-
>
SetStickyScrollRangeInner
(
stickyInner
)
;
SideBits
sides
=
nsLayoutUtils
:
:
GetSideBitsForFixedPositionContent
(
mFrame
)
;
aLayerData
-
>
SetFixedPositionSides
(
sides
)
;
ScrollableLayerGuid
:
:
ViewID
scrollId
=
nsLayoutUtils
:
:
FindOrCreateIDFor
(
stickyScrollContainer
-
>
ScrollFrame
(
)
-
>
GetScrolledFrame
(
)
-
>
GetContent
(
)
)
;
aLayerData
-
>
SetStickyPositionScrollContainerId
(
scrollId
)
;
}
}
bool
ret
=
hasDynamicToolbar
;
ret
|
=
nsDisplayOwnLayer
:
:
UpdateScrollData
(
aData
aLayerData
)
;
return
ret
;
}
nsDisplayScrollInfoLayer
:
:
nsDisplayScrollInfoLayer
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aScrolledFrame
nsIFrame
*
aScrollFrame
const
CompositorHitTestInfo
&
aHitInfo
const
nsRect
&
aHitArea
)
:
nsDisplayWrapList
(
aBuilder
aScrollFrame
)
mScrollFrame
(
aScrollFrame
)
mScrolledFrame
(
aScrolledFrame
)
mScrollParentId
(
aBuilder
-
>
GetCurrentScrollParentId
(
)
)
mHitInfo
(
aHitInfo
)
mHitArea
(
aHitArea
)
{
#
ifdef
NS_BUILD_REFCNT_LOGGING
MOZ_COUNT_CTOR
(
nsDisplayScrollInfoLayer
)
;
#
endif
}
UniquePtr
<
ScrollMetadata
>
nsDisplayScrollInfoLayer
:
:
ComputeScrollMetadata
(
nsDisplayListBuilder
*
aBuilder
WebRenderLayerManager
*
aLayerManager
)
{
ScrollMetadata
metadata
=
nsLayoutUtils
:
:
ComputeScrollMetadata
(
mScrolledFrame
mScrollFrame
mScrollFrame
-
>
GetContent
(
)
Frame
(
)
ToReferenceFrame
(
)
aLayerManager
mScrollParentId
mScrollFrame
-
>
GetSize
(
)
false
)
;
metadata
.
GetMetrics
(
)
.
SetIsScrollInfoLayer
(
true
)
;
nsIScrollableFrame
*
scrollableFrame
=
mScrollFrame
-
>
GetScrollTargetFrame
(
)
;
if
(
scrollableFrame
)
{
aBuilder
-
>
AddScrollFrameToNotify
(
scrollableFrame
)
;
}
return
UniquePtr
<
ScrollMetadata
>
(
new
ScrollMetadata
(
metadata
)
)
;
}
bool
nsDisplayScrollInfoLayer
:
:
UpdateScrollData
(
WebRenderScrollData
*
aData
WebRenderLayerScrollData
*
aLayerData
)
{
if
(
aLayerData
)
{
UniquePtr
<
ScrollMetadata
>
metadata
=
ComputeScrollMetadata
(
aData
-
>
GetBuilder
(
)
aData
-
>
GetManager
(
)
)
;
MOZ_ASSERT
(
aData
)
;
MOZ_ASSERT
(
metadata
)
;
aLayerData
-
>
AppendScrollMetadata
(
*
aData
*
metadata
)
;
}
return
true
;
}
bool
nsDisplayScrollInfoLayer
:
:
CreateWebRenderCommands
(
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
ScrollableLayerGuid
:
:
ViewID
scrollId
=
nsLayoutUtils
:
:
FindOrCreateIDFor
(
mScrollFrame
-
>
GetContent
(
)
)
;
const
LayoutDeviceRect
devRect
=
LayoutDeviceRect
:
:
FromAppUnits
(
mHitArea
mScrollFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
const
wr
:
:
LayoutRect
rect
=
wr
:
:
ToLayoutRect
(
devRect
)
;
aBuilder
.
PushHitTest
(
rect
rect
!
BackfaceIsHidden
(
)
scrollId
mHitInfo
SideBits
:
:
eNone
)
;
return
true
;
}
void
nsDisplayScrollInfoLayer
:
:
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
{
aStream
<
<
"
(
scrollframe
"
<
<
mScrollFrame
<
<
"
scrolledFrame
"
<
<
mScrolledFrame
<
<
"
)
"
;
}
nsDisplayZoom
:
:
nsDisplayZoom
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsSubDocumentFrame
*
aSubDocFrame
nsDisplayList
*
aList
int32_t
aAPD
int32_t
aParentAPD
nsDisplayOwnLayerFlags
aFlags
)
:
nsDisplaySubDocument
(
aBuilder
aFrame
aSubDocFrame
aList
aFlags
)
mAPD
(
aAPD
)
mParentAPD
(
aParentAPD
)
{
MOZ_COUNT_CTOR
(
nsDisplayZoom
)
;
}
nsRect
nsDisplayZoom
:
:
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
{
nsRect
bounds
=
nsDisplaySubDocument
:
:
GetBounds
(
aBuilder
aSnap
)
;
*
aSnap
=
false
;
return
bounds
.
ScaleToOtherAppUnitsRoundOut
(
mAPD
mParentAPD
)
;
}
void
nsDisplayZoom
:
:
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
{
nsRect
rect
;
if
(
aRect
.
width
=
=
1
&
&
aRect
.
height
=
=
1
)
{
rect
.
MoveTo
(
aRect
.
TopLeft
(
)
.
ScaleToOtherAppUnits
(
mParentAPD
mAPD
)
)
;
rect
.
width
=
rect
.
height
=
1
;
}
else
{
rect
=
aRect
.
ScaleToOtherAppUnitsRoundOut
(
mParentAPD
mAPD
)
;
}
mList
.
HitTest
(
aBuilder
rect
aState
aOutFrames
)
;
}
nsDisplayAsyncZoom
:
:
nsDisplayAsyncZoom
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
ActiveScrolledRoot
*
aActiveScrolledRoot
FrameMetrics
:
:
ViewID
aViewID
)
:
nsDisplayOwnLayer
(
aBuilder
aFrame
aList
aActiveScrolledRoot
)
mViewID
(
aViewID
)
{
MOZ_COUNT_CTOR
(
nsDisplayAsyncZoom
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
nsDisplayAsyncZoom
:
:
~
nsDisplayAsyncZoom
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayAsyncZoom
)
;
}
#
endif
void
nsDisplayAsyncZoom
:
:
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
{
#
ifdef
DEBUG
nsIScrollableFrame
*
scrollFrame
=
do_QueryFrame
(
mFrame
)
;
MOZ_ASSERT
(
scrollFrame
&
&
ViewportUtils
:
:
IsZoomedContentRoot
(
scrollFrame
-
>
GetScrolledFrame
(
)
)
)
;
#
endif
nsRect
rect
=
ViewportUtils
:
:
VisualToLayout
(
aRect
mFrame
-
>
PresShell
(
)
)
;
mList
.
HitTest
(
aBuilder
rect
aState
aOutFrames
)
;
}
bool
nsDisplayAsyncZoom
:
:
UpdateScrollData
(
WebRenderScrollData
*
aData
WebRenderLayerScrollData
*
aLayerData
)
{
bool
ret
=
nsDisplayOwnLayer
:
:
UpdateScrollData
(
aData
aLayerData
)
;
MOZ_ASSERT
(
ret
)
;
if
(
aLayerData
)
{
aLayerData
-
>
SetAsyncZoomContainerId
(
mViewID
)
;
}
return
ret
;
}
#
ifndef
DEBUG
static_assert
(
sizeof
(
nsDisplayTransform
)
<
=
512
"
nsDisplayTransform
has
grown
"
)
;
#
endif
nsDisplayTransform
:
:
nsDisplayTransform
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
nsRect
&
aChildrenBuildingRect
)
:
nsPaintedDisplayItem
(
aBuilder
aFrame
)
mTransform
(
Some
(
Matrix4x4
(
)
)
)
mChildrenBuildingRect
(
aChildrenBuildingRect
)
mPrerenderDecision
(
PrerenderDecision
:
:
No
)
mIsTransformSeparator
(
true
)
mHasTransformGetter
(
false
)
{
MOZ_COUNT_CTOR
(
nsDisplayTransform
)
;
MOZ_ASSERT
(
aFrame
"
Must
have
a
frame
!
"
)
;
Init
(
aBuilder
aList
)
;
}
nsDisplayTransform
:
:
nsDisplayTransform
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
nsRect
&
aChildrenBuildingRect
PrerenderDecision
aPrerenderDecision
)
:
nsPaintedDisplayItem
(
aBuilder
aFrame
)
mChildrenBuildingRect
(
aChildrenBuildingRect
)
mPrerenderDecision
(
aPrerenderDecision
)
mIsTransformSeparator
(
false
)
mHasTransformGetter
(
false
)
{
MOZ_COUNT_CTOR
(
nsDisplayTransform
)
;
MOZ_ASSERT
(
aFrame
"
Must
have
a
frame
!
"
)
;
SetReferenceFrameToAncestor
(
aBuilder
)
;
Init
(
aBuilder
aList
)
;
}
nsDisplayTransform
:
:
nsDisplayTransform
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
nsRect
&
aChildrenBuildingRect
decltype
(
WithTransformGetter
)
)
:
nsPaintedDisplayItem
(
aBuilder
aFrame
)
mChildrenBuildingRect
(
aChildrenBuildingRect
)
mPrerenderDecision
(
PrerenderDecision
:
:
No
)
mIsTransformSeparator
(
false
)
mHasTransformGetter
(
true
)
{
MOZ_COUNT_CTOR
(
nsDisplayTransform
)
;
MOZ_ASSERT
(
aFrame
"
Must
have
a
frame
!
"
)
;
MOZ_ASSERT
(
aFrame
-
>
GetTransformGetter
(
)
)
;
Init
(
aBuilder
aList
)
;
}
void
nsDisplayTransform
:
:
SetReferenceFrameToAncestor
(
nsDisplayListBuilder
*
aBuilder
)
{
if
(
mFrame
=
=
aBuilder
-
>
RootReferenceFrame
(
)
)
{
return
;
}
nsIFrame
*
outerFrame
=
nsLayoutUtils
:
:
GetCrossDocParentFrameInProcess
(
mFrame
)
;
const
nsIFrame
*
referenceFrame
=
aBuilder
-
>
FindReferenceFrameFor
(
outerFrame
)
;
mToReferenceFrame
=
mFrame
-
>
GetOffsetToCrossDoc
(
referenceFrame
)
;
}
void
nsDisplayTransform
:
:
Init
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aChildren
)
{
mChildren
.
AppendToTop
(
aChildren
)
;
UpdateBounds
(
aBuilder
)
;
}
bool
nsDisplayTransform
:
:
ShouldFlattenAway
(
nsDisplayListBuilder
*
aBuilder
)
{
return
false
;
}
Point3D
nsDisplayTransform
:
:
GetDeltaToTransformOrigin
(
const
nsIFrame
*
aFrame
TransformReferenceBox
&
aRefBox
float
aAppUnitsPerPixel
)
{
MOZ_ASSERT
(
aFrame
"
Can
'
t
get
delta
for
a
null
frame
!
"
)
;
MOZ_ASSERT
(
aFrame
-
>
IsTransformed
(
)
|
|
aFrame
-
>
BackfaceIsHidden
(
)
|
|
aFrame
-
>
Combines3DTransformWithAncestors
(
)
"
Shouldn
'
t
get
a
delta
for
an
untransformed
frame
!
"
)
;
if
(
!
aFrame
-
>
IsTransformed
(
)
)
{
return
Point3D
(
)
;
}
const
nsStyleDisplay
*
display
=
aFrame
-
>
StyleDisplay
(
)
;
const
StyleTransformOrigin
&
transformOrigin
=
display
-
>
mTransformOrigin
;
CSSPoint
origin
=
nsStyleTransformMatrix
:
:
Convert2DPosition
(
transformOrigin
.
horizontal
transformOrigin
.
vertical
aRefBox
)
;
if
(
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_SVG_LAYOUT
)
)
{
origin
.
x
+
=
CSSPixel
:
:
FromAppUnits
(
aRefBox
.
X
(
)
)
;
origin
.
y
+
=
CSSPixel
:
:
FromAppUnits
(
aRefBox
.
Y
(
)
)
;
}
float
scale
=
AppUnitsPerCSSPixel
(
)
/
float
(
aAppUnitsPerPixel
)
;
float
z
=
transformOrigin
.
depth
.
_0
;
return
Point3D
(
origin
.
x
*
scale
origin
.
y
*
scale
z
*
scale
)
;
}
bool
nsDisplayTransform
:
:
ComputePerspectiveMatrix
(
const
nsIFrame
*
aFrame
float
aAppUnitsPerPixel
Matrix4x4
&
aOutMatrix
)
{
MOZ_ASSERT
(
aFrame
"
Can
'
t
get
delta
for
a
null
frame
!
"
)
;
MOZ_ASSERT
(
aFrame
-
>
IsTransformed
(
)
|
|
aFrame
-
>
BackfaceIsHidden
(
)
|
|
aFrame
-
>
Combines3DTransformWithAncestors
(
)
"
Shouldn
'
t
get
a
delta
for
an
untransformed
frame
!
"
)
;
MOZ_ASSERT
(
aOutMatrix
.
IsIdentity
(
)
"
Must
have
a
blank
output
matrix
"
)
;
if
(
!
aFrame
-
>
IsTransformed
(
)
)
{
return
false
;
}
nsIFrame
*
perspectiveFrame
=
aFrame
-
>
GetClosestFlattenedTreeAncestorPrimaryFrame
(
)
;
if
(
!
perspectiveFrame
)
{
return
false
;
}
const
nsStyleDisplay
*
perspectiveDisplay
=
perspectiveFrame
-
>
StyleDisplay
(
)
;
if
(
perspectiveDisplay
-
>
mChildPerspective
.
IsNone
(
)
)
{
return
false
;
}
MOZ_ASSERT
(
perspectiveDisplay
-
>
mChildPerspective
.
IsLength
(
)
)
;
float
perspective
=
perspectiveDisplay
-
>
mChildPerspective
.
length
.
_0
.
ToCSSPixels
(
)
;
perspective
=
std
:
:
max
(
1
.
0f
perspective
)
;
if
(
perspective
<
std
:
:
numeric_limits
<
Float
>
:
:
epsilon
(
)
)
{
return
true
;
}
TransformReferenceBox
refBox
(
perspectiveFrame
)
;
Point
perspectiveOrigin
=
nsStyleTransformMatrix
:
:
Convert2DPosition
(
perspectiveDisplay
-
>
mPerspectiveOrigin
.
horizontal
perspectiveDisplay
-
>
mPerspectiveOrigin
.
vertical
refBox
aAppUnitsPerPixel
)
;
nsPoint
frameToPerspectiveOffset
=
-
aFrame
-
>
GetOffsetTo
(
perspectiveFrame
)
;
Point
frameToPerspectiveGfxOffset
(
NSAppUnitsToFloatPixels
(
frameToPerspectiveOffset
.
x
aAppUnitsPerPixel
)
NSAppUnitsToFloatPixels
(
frameToPerspectiveOffset
.
y
aAppUnitsPerPixel
)
)
;
perspectiveOrigin
+
=
frameToPerspectiveGfxOffset
;
aOutMatrix
.
_34
=
-
1
.
0
/
NSAppUnitsToFloatPixels
(
CSSPixel
:
:
ToAppUnits
(
perspective
)
aAppUnitsPerPixel
)
;
aOutMatrix
.
ChangeBasis
(
Point3D
(
perspectiveOrigin
.
x
perspectiveOrigin
.
y
0
)
)
;
return
true
;
}
nsDisplayTransform
:
:
FrameTransformProperties
:
:
FrameTransformProperties
(
const
nsIFrame
*
aFrame
TransformReferenceBox
&
aRefBox
float
aAppUnitsPerPixel
)
:
mFrame
(
aFrame
)
mTranslate
(
aFrame
-
>
StyleDisplay
(
)
-
>
mTranslate
)
mRotate
(
aFrame
-
>
StyleDisplay
(
)
-
>
mRotate
)
mScale
(
aFrame
-
>
StyleDisplay
(
)
-
>
mScale
)
mTransform
(
aFrame
-
>
StyleDisplay
(
)
-
>
mTransform
)
mMotion
(
MotionPathUtils
:
:
ResolveMotionPath
(
aFrame
aRefBox
)
)
mToTransformOrigin
(
GetDeltaToTransformOrigin
(
aFrame
aRefBox
aAppUnitsPerPixel
)
)
{
}
Matrix4x4
nsDisplayTransform
:
:
GetResultingTransformMatrix
(
const
FrameTransformProperties
&
aProperties
TransformReferenceBox
&
aRefBox
float
aAppUnitsPerPixel
)
{
return
GetResultingTransformMatrixInternal
(
aProperties
aRefBox
nsPoint
(
)
aAppUnitsPerPixel
0
)
;
}
Matrix4x4
nsDisplayTransform
:
:
GetResultingTransformMatrix
(
const
nsIFrame
*
aFrame
const
nsPoint
&
aOrigin
float
aAppUnitsPerPixel
uint32_t
aFlags
)
{
TransformReferenceBox
refBox
(
aFrame
)
;
FrameTransformProperties
props
(
aFrame
refBox
aAppUnitsPerPixel
)
;
return
GetResultingTransformMatrixInternal
(
props
refBox
aOrigin
aAppUnitsPerPixel
aFlags
)
;
}
Matrix4x4
nsDisplayTransform
:
:
GetResultingTransformMatrixInternal
(
const
FrameTransformProperties
&
aProperties
TransformReferenceBox
&
aRefBox
const
nsPoint
&
aOrigin
float
aAppUnitsPerPixel
uint32_t
aFlags
)
{
const
nsIFrame
*
frame
=
aProperties
.
mFrame
;
NS_ASSERTION
(
frame
|
|
!
(
aFlags
&
INCLUDE_PERSPECTIVE
)
"
Must
have
a
frame
to
compute
perspective
!
"
)
;
Matrix4x4
result
;
Matrix
svgTransform
parentsChildrenOnlyTransform
;
const
bool
hasSVGTransforms
=
frame
&
&
frame
-
>
HasAnyStateBits
(
NS_FRAME_MAY_BE_TRANSFORMED
)
&
&
frame
-
>
IsSVGTransformed
(
&
svgTransform
&
parentsChildrenOnlyTransform
)
;
bool
shouldRound
=
nsLayoutUtils
:
:
ShouldSnapToGrid
(
frame
)
;
if
(
aProperties
.
HasTransform
(
)
)
{
result
=
nsStyleTransformMatrix
:
:
ReadTransforms
(
aProperties
.
mTranslate
aProperties
.
mRotate
aProperties
.
mScale
aProperties
.
mMotion
aProperties
.
mTransform
aRefBox
aAppUnitsPerPixel
)
;
}
else
if
(
hasSVGTransforms
)
{
float
pixelsPerCSSPx
=
AppUnitsPerCSSPixel
(
)
/
aAppUnitsPerPixel
;
svgTransform
.
_31
*
=
pixelsPerCSSPx
;
svgTransform
.
_32
*
=
pixelsPerCSSPx
;
result
=
Matrix4x4
:
:
From2D
(
svgTransform
)
;
}
result
.
ChangeBasis
(
aProperties
.
mToTransformOrigin
)
;
const
bool
parentHasChildrenOnlyTransform
=
hasSVGTransforms
&
&
!
parentsChildrenOnlyTransform
.
IsIdentity
(
)
;
if
(
parentHasChildrenOnlyTransform
)
{
float
pixelsPerCSSPx
=
AppUnitsPerCSSPixel
(
)
/
aAppUnitsPerPixel
;
parentsChildrenOnlyTransform
.
_31
*
=
pixelsPerCSSPx
;
parentsChildrenOnlyTransform
.
_32
*
=
pixelsPerCSSPx
;
Point3D
frameOffset
(
NSAppUnitsToFloatPixels
(
-
frame
-
>
GetPosition
(
)
.
x
aAppUnitsPerPixel
)
NSAppUnitsToFloatPixels
(
-
frame
-
>
GetPosition
(
)
.
y
aAppUnitsPerPixel
)
0
)
;
Matrix4x4
parentsChildrenOnlyTransform3D
=
Matrix4x4
:
:
From2D
(
parentsChildrenOnlyTransform
)
.
ChangeBasis
(
frameOffset
)
;
result
*
=
parentsChildrenOnlyTransform3D
;
}
Matrix4x4
perspectiveMatrix
;
bool
hasPerspective
=
aFlags
&
INCLUDE_PERSPECTIVE
;
if
(
hasPerspective
)
{
if
(
ComputePerspectiveMatrix
(
frame
aAppUnitsPerPixel
perspectiveMatrix
)
)
{
result
*
=
perspectiveMatrix
;
}
}
if
(
(
aFlags
&
INCLUDE_PRESERVE3D_ANCESTORS
)
&
&
frame
&
&
frame
-
>
Combines3DTransformWithAncestors
(
)
)
{
nsIFrame
*
parentFrame
=
frame
-
>
GetClosestFlattenedTreeAncestorPrimaryFrame
(
)
;
NS_ASSERTION
(
parentFrame
&
&
parentFrame
-
>
IsTransformed
(
)
&
&
parentFrame
-
>
Extend3DContext
(
)
"
Preserve3D
mismatch
!
"
)
;
TransformReferenceBox
refBox
(
parentFrame
)
;
FrameTransformProperties
props
(
parentFrame
refBox
aAppUnitsPerPixel
)
;
uint32_t
flags
=
aFlags
&
(
INCLUDE_PRESERVE3D_ANCESTORS
|
INCLUDE_PERSPECTIVE
)
;
if
(
frame
-
>
IsTransformed
(
)
)
{
nsLayoutUtils
:
:
PostTranslate
(
result
frame
-
>
GetPosition
(
)
aAppUnitsPerPixel
shouldRound
)
;
}
Matrix4x4
parent
=
GetResultingTransformMatrixInternal
(
props
refBox
nsPoint
(
0
0
)
aAppUnitsPerPixel
flags
)
;
result
=
result
*
parent
;
}
if
(
aFlags
&
OFFSET_BY_ORIGIN
)
{
nsLayoutUtils
:
:
PostTranslate
(
result
aOrigin
aAppUnitsPerPixel
shouldRound
)
;
}
return
result
;
}
bool
nsDisplayOpacity
:
:
CanUseAsyncAnimations
(
nsDisplayListBuilder
*
aBuilder
)
{
static
constexpr
nsCSSPropertyIDSet
opacitySet
=
nsCSSPropertyIDSet
:
:
OpacityProperties
(
)
;
if
(
ActiveLayerTracker
:
:
IsStyleAnimated
(
aBuilder
mFrame
opacitySet
)
)
{
return
true
;
}
EffectCompositor
:
:
SetPerformanceWarning
(
mFrame
opacitySet
AnimationPerformanceWarning
(
AnimationPerformanceWarning
:
:
Type
:
:
OpacityFrameInactive
)
)
;
return
false
;
}
bool
nsDisplayTransform
:
:
CanUseAsyncAnimations
(
nsDisplayListBuilder
*
aBuilder
)
{
return
mPrerenderDecision
!
=
PrerenderDecision
:
:
No
;
}
bool
nsDisplayBackgroundColor
:
:
CanUseAsyncAnimations
(
nsDisplayListBuilder
*
aBuilder
)
{
return
StaticPrefs
:
:
gfx_omta_background_color
(
)
;
}
static
bool
IsInStickyPositionedSubtree
(
const
nsIFrame
*
aFrame
)
{
for
(
const
nsIFrame
*
frame
=
aFrame
;
frame
;
frame
=
nsLayoutUtils
:
:
GetCrossDocParentFrameInProcess
(
frame
)
)
{
if
(
frame
-
>
IsStickyPositioned
(
)
)
{
return
true
;
}
}
return
false
;
}
static
bool
ShouldUsePartialPrerender
(
const
nsIFrame
*
aFrame
)
{
return
StaticPrefs
:
:
layout_animation_prerender_partial
(
)
&
&
!
IsInStickyPositionedSubtree
(
aFrame
)
;
}
auto
nsDisplayTransform
:
:
ShouldPrerenderTransformedContent
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsRect
*
aDirtyRect
)
-
>
PrerenderInfo
{
PrerenderInfo
result
;
if
(
(
aFrame
-
>
Extend3DContext
(
)
|
|
aFrame
-
>
Combines3DTransformWithAncestors
(
)
)
&
&
!
aBuilder
-
>
GetPreserves3DAllowAsyncAnimation
(
)
)
{
return
result
;
}
static
constexpr
nsCSSPropertyIDSet
transformSet
=
nsCSSPropertyIDSet
:
:
TransformLikeProperties
(
)
;
if
(
!
ActiveLayerTracker
:
:
IsTransformMaybeAnimated
(
aFrame
)
&
&
!
EffectCompositor
:
:
HasAnimationsForCompositor
(
aFrame
DisplayItemType
:
:
TYPE_TRANSFORM
)
)
{
EffectCompositor
:
:
SetPerformanceWarning
(
aFrame
transformSet
AnimationPerformanceWarning
(
AnimationPerformanceWarning
:
:
Type
:
:
TransformFrameInactive
)
)
;
result
.
mHasAnimations
=
false
;
return
result
;
}
for
(
nsIFrame
*
container
=
nsLayoutUtils
:
:
GetCrossDocParentFrameInProcess
(
aFrame
)
;
container
;
container
=
nsLayoutUtils
:
:
GetCrossDocParentFrameInProcess
(
container
)
)
{
const
nsStyleSVGReset
*
svgReset
=
container
-
>
StyleSVGReset
(
)
;
if
(
svgReset
-
>
HasMask
(
)
|
|
svgReset
-
>
HasClipPath
(
)
)
{
return
result
;
}
}
nsRect
overflow
=
aFrame
-
>
InkOverflowRectRelativeToSelf
(
)
;
nsRect
untransformedDirtyRect
=
*
aDirtyRect
;
UntransformRect
(
*
aDirtyRect
overflow
aFrame
&
untransformedDirtyRect
)
;
if
(
untransformedDirtyRect
.
Contains
(
overflow
)
)
{
*
aDirtyRect
=
untransformedDirtyRect
;
result
.
mDecision
=
PrerenderDecision
:
:
Full
;
return
result
;
}
float
viewportRatio
=
StaticPrefs
:
:
layout_animation_prerender_viewport_ratio_limit
(
)
;
uint32_t
absoluteLimitX
=
StaticPrefs
:
:
layout_animation_prerender_absolute_limit_x
(
)
;
uint32_t
absoluteLimitY
=
StaticPrefs
:
:
layout_animation_prerender_absolute_limit_y
(
)
;
nsSize
refSize
=
aBuilder
-
>
RootReferenceFrame
(
)
-
>
GetSize
(
)
;
float
resolution
=
aFrame
-
>
PresShell
(
)
-
>
GetCumulativeResolution
(
)
;
if
(
resolution
<
1
.
0f
)
{
refSize
.
SizeTo
(
NSCoordSaturatingNonnegativeMultiply
(
refSize
.
width
1
.
0f
/
resolution
)
NSCoordSaturatingNonnegativeMultiply
(
refSize
.
height
1
.
0f
/
resolution
)
)
;
}
nscoord
maxLength
=
std
:
:
max
(
nscoord
(
refSize
.
width
*
viewportRatio
)
nscoord
(
refSize
.
height
*
viewportRatio
)
)
;
nsSize
relativeLimit
(
maxLength
maxLength
)
;
nsSize
absoluteLimit
(
aFrame
-
>
PresContext
(
)
-
>
DevPixelsToAppUnits
(
absoluteLimitX
)
aFrame
-
>
PresContext
(
)
-
>
DevPixelsToAppUnits
(
absoluteLimitY
)
)
;
nsSize
maxSize
=
Min
(
relativeLimit
absoluteLimit
)
;
const
auto
transform
=
nsLayoutUtils
:
:
GetTransformToAncestor
(
RelativeTo
{
aFrame
}
RelativeTo
{
nsLayoutUtils
:
:
GetDisplayRootFrame
(
aFrame
)
}
)
;
const
gfxRect
transformedBounds
=
transform
.
TransformAndClipBounds
(
gfxRect
(
overflow
.
x
overflow
.
y
overflow
.
width
overflow
.
height
)
gfxRect
:
:
MaxIntRect
(
)
)
;
const
nsSize
frameSize
=
nsSize
(
transformedBounds
.
width
transformedBounds
.
height
)
;
uint64_t
maxLimitArea
=
uint64_t
(
maxSize
.
width
)
*
maxSize
.
height
;
uint64_t
frameArea
=
uint64_t
(
frameSize
.
width
)
*
frameSize
.
height
;
if
(
frameArea
<
=
maxLimitArea
&
&
frameSize
<
=
absoluteLimit
)
{
*
aDirtyRect
=
overflow
;
result
.
mDecision
=
PrerenderDecision
:
:
Full
;
return
result
;
}
if
(
ShouldUsePartialPrerender
(
aFrame
)
)
{
*
aDirtyRect
=
nsLayoutUtils
:
:
ComputePartialPrerenderArea
(
aFrame
untransformedDirtyRect
overflow
maxSize
)
;
result
.
mDecision
=
PrerenderDecision
:
:
Partial
;
return
result
;
}
if
(
frameArea
>
maxLimitArea
)
{
uint64_t
appUnitsPerPixel
=
AppUnitsPerCSSPixel
(
)
;
EffectCompositor
:
:
SetPerformanceWarning
(
aFrame
transformSet
AnimationPerformanceWarning
(
AnimationPerformanceWarning
:
:
Type
:
:
ContentTooLargeArea
{
int
(
frameArea
/
(
appUnitsPerPixel
*
appUnitsPerPixel
)
)
int
(
maxLimitArea
/
(
appUnitsPerPixel
*
appUnitsPerPixel
)
)
}
)
)
;
}
else
{
EffectCompositor
:
:
SetPerformanceWarning
(
aFrame
transformSet
AnimationPerformanceWarning
(
AnimationPerformanceWarning
:
:
Type
:
:
ContentTooLarge
{
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
frameSize
.
width
)
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
frameSize
.
height
)
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
relativeLimit
.
width
)
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
relativeLimit
.
height
)
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
absoluteLimit
.
width
)
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
absoluteLimit
.
height
)
}
)
)
;
}
return
result
;
}
static
bool
IsFrameVisible
(
nsIFrame
*
aFrame
const
Matrix4x4
&
aMatrix
)
{
if
(
aMatrix
.
IsSingular
(
)
)
{
return
false
;
}
if
(
aFrame
-
>
BackfaceIsHidden
(
)
&
&
aMatrix
.
IsBackfaceVisible
(
)
)
{
return
false
;
}
return
true
;
}
const
Matrix4x4Flagged
&
nsDisplayTransform
:
:
GetTransform
(
)
const
{
if
(
mTransform
)
{
return
*
mTransform
;
}
float
scale
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
if
(
mHasTransformGetter
)
{
mTransform
.
emplace
(
(
mFrame
-
>
GetTransformGetter
(
)
)
(
mFrame
scale
)
)
;
Point3D
newOrigin
=
Point3D
(
NSAppUnitsToFloatPixels
(
mToReferenceFrame
.
x
scale
)
NSAppUnitsToFloatPixels
(
mToReferenceFrame
.
y
scale
)
0
.
0f
)
;
mTransform
-
>
ChangeBasis
(
newOrigin
.
x
newOrigin
.
y
newOrigin
.
z
)
;
}
else
if
(
!
mIsTransformSeparator
)
{
DebugOnly
<
bool
>
isReference
=
mFrame
-
>
IsTransformed
(
)
|
|
mFrame
-
>
Combines3DTransformWithAncestors
(
)
|
|
mFrame
-
>
Extend3DContext
(
)
;
MOZ_ASSERT
(
isReference
)
;
mTransform
.
emplace
(
GetResultingTransformMatrix
(
mFrame
ToReferenceFrame
(
)
scale
INCLUDE_PERSPECTIVE
|
OFFSET_BY_ORIGIN
)
)
;
}
else
{
mTransform
.
emplace
(
)
;
}
return
*
mTransform
;
}
const
Matrix4x4Flagged
&
nsDisplayTransform
:
:
GetInverseTransform
(
)
const
{
if
(
mInverseTransform
)
{
return
*
mInverseTransform
;
}
MOZ_ASSERT
(
!
GetTransform
(
)
.
IsSingular
(
)
)
;
mInverseTransform
.
emplace
(
GetTransform
(
)
.
Inverse
(
)
)
;
return
*
mInverseTransform
;
}
Matrix4x4
nsDisplayTransform
:
:
GetTransformForRendering
(
LayoutDevicePoint
*
aOutOrigin
)
const
{
if
(
!
mFrame
-
>
HasPerspective
(
)
|
|
mHasTransformGetter
|
|
mIsTransformSeparator
)
{
if
(
!
mHasTransformGetter
&
&
!
mIsTransformSeparator
&
&
aOutOrigin
)
{
float
scale
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
*
aOutOrigin
=
LayoutDevicePoint
:
:
FromAppUnits
(
ToReferenceFrame
(
)
scale
)
;
if
(
nsLayoutUtils
:
:
ShouldSnapToGrid
(
mFrame
)
)
{
aOutOrigin
-
>
Round
(
)
;
}
return
GetResultingTransformMatrix
(
mFrame
nsPoint
(
0
0
)
scale
INCLUDE_PERSPECTIVE
)
;
}
return
GetTransform
(
)
.
GetMatrix
(
)
;
}
MOZ_ASSERT
(
!
mHasTransformGetter
)
;
float
scale
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
return
GetResultingTransformMatrix
(
mFrame
ToReferenceFrame
(
)
scale
0
)
;
}
const
Matrix4x4
&
nsDisplayTransform
:
:
GetAccumulatedPreserved3DTransform
(
nsDisplayListBuilder
*
aBuilder
)
{
MOZ_ASSERT
(
!
mFrame
-
>
Extend3DContext
(
)
|
|
IsLeafOf3DContext
(
)
)
;
if
(
!
IsLeafOf3DContext
(
)
)
{
return
GetTransform
(
)
.
GetMatrix
(
)
;
}
if
(
!
mTransformPreserves3D
)
{
const
nsIFrame
*
establisher
;
for
(
establisher
=
mFrame
;
establisher
&
&
establisher
-
>
Combines3DTransformWithAncestors
(
)
;
establisher
=
establisher
-
>
GetClosestFlattenedTreeAncestorPrimaryFrame
(
)
)
{
}
const
nsIFrame
*
establisherReference
=
aBuilder
-
>
FindReferenceFrameFor
(
nsLayoutUtils
:
:
GetCrossDocParentFrameInProcess
(
establisher
)
)
;
nsPoint
offset
=
establisher
-
>
GetOffsetToCrossDoc
(
establisherReference
)
;
float
scale
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
uint32_t
flags
=
INCLUDE_PRESERVE3D_ANCESTORS
|
INCLUDE_PERSPECTIVE
|
OFFSET_BY_ORIGIN
;
mTransformPreserves3D
=
MakeUnique
<
Matrix4x4
>
(
GetResultingTransformMatrix
(
mFrame
offset
scale
flags
)
)
;
}
return
*
mTransformPreserves3D
;
}
bool
nsDisplayTransform
:
:
CreateWebRenderCommands
(
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
LayoutDevicePoint
position
;
Matrix4x4
newTransformMatrix
=
GetTransformForRendering
(
&
position
)
;
gfx
:
:
Matrix4x4
*
transformForSC
=
&
newTransformMatrix
;
if
(
newTransformMatrix
.
IsIdentity
(
)
)
{
transformForSC
=
nullptr
;
if
(
nsLayoutUtils
:
:
ShouldSnapToGrid
(
mFrame
)
)
{
position
.
Round
(
)
;
}
}
auto
key
=
wr
:
:
SpatialKey
(
uint64_t
(
mFrame
)
GetPerFrameKey
(
)
wr
:
:
SpatialKeyKind
:
:
Transform
)
;
uint64_t
animationsId
=
mIsTransformSeparator
?
0
:
AddAnimationsForWebRender
(
this
aManager
aDisplayListBuilder
IsPartialPrerender
(
)
?
Some
(
position
)
:
Nothing
(
)
)
;
wr
:
:
WrAnimationProperty
prop
{
wr
:
:
WrAnimationType
:
:
Transform
animationsId
key
}
;
nsDisplayTransform
*
deferredTransformItem
=
nullptr
;
if
(
!
mFrame
-
>
ChildrenHavePerspective
(
)
)
{
deferredTransformItem
=
this
;
}
bool
animated
=
!
mIsTransformSeparator
&
&
ActiveLayerTracker
:
:
IsTransformMaybeAnimated
(
Frame
(
)
)
;
wr
:
:
StackingContextParams
params
;
params
.
mBoundTransform
=
&
newTransformMatrix
;
params
.
animation
=
animationsId
?
&
prop
:
nullptr
;
wr
:
:
WrTransformInfo
transform_info
;
if
(
transformForSC
)
{
transform_info
.
transform
=
wr
:
:
ToLayoutTransform
(
newTransformMatrix
)
;
transform_info
.
key
=
key
;
params
.
mTransformPtr
=
&
transform_info
;
}
else
{
params
.
mTransformPtr
=
nullptr
;
}
params
.
prim_flags
=
!
BackfaceIsHidden
(
)
?
wr
:
:
PrimitiveFlags
:
:
IS_BACKFACE_VISIBLE
:
wr
:
:
PrimitiveFlags
{
0
}
;
params
.
mDeferredTransformItem
=
deferredTransformItem
;
params
.
mAnimated
=
animated
;
params
.
mRasterizeLocally
=
animated
&
&
Frame
(
)
-
>
HasAnimationOfTransform
(
)
;
params
.
SetPreserve3D
(
mFrame
-
>
Extend3DContext
(
)
&
&
!
mIsTransformSeparator
)
;
params
.
clip
=
wr
:
:
WrStackingContextClip
:
:
ClipChain
(
aBuilder
.
CurrentClipChainId
(
)
)
;
LayoutDeviceSize
boundsSize
=
LayoutDeviceSize
:
:
FromAppUnits
(
mChildBounds
.
Size
(
)
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
StackingContextHelper
sc
(
aSc
GetActiveScrolledRoot
(
)
mFrame
this
aBuilder
params
LayoutDeviceRect
(
position
boundsSize
)
)
;
aManager
-
>
CommandBuilder
(
)
.
CreateWebRenderCommandsFromDisplayList
(
GetChildren
(
)
this
aDisplayListBuilder
sc
aBuilder
aResources
)
;
return
true
;
}
bool
nsDisplayTransform
:
:
UpdateScrollData
(
WebRenderScrollData
*
aData
WebRenderLayerScrollData
*
aLayerData
)
{
if
(
!
mFrame
-
>
ChildrenHavePerspective
(
)
)
{
return
false
;
}
if
(
aLayerData
)
{
aLayerData
-
>
SetTransform
(
GetTransform
(
)
.
GetMatrix
(
)
)
;
aLayerData
-
>
SetTransformIsPerspective
(
true
)
;
}
return
true
;
}
bool
nsDisplayTransform
:
:
ShouldSkipTransform
(
nsDisplayListBuilder
*
aBuilder
)
const
{
return
(
aBuilder
-
>
RootReferenceFrame
(
)
=
=
mFrame
)
&
&
aBuilder
-
>
IsForGenerateGlyphMask
(
)
;
}
void
nsDisplayTransform
:
:
Collect3DTransformLeaves
(
nsDisplayListBuilder
*
aBuilder
nsTArray
<
nsDisplayTransform
*
>
&
aLeaves
)
{
if
(
!
IsParticipating3DContext
(
)
|
|
IsLeafOf3DContext
(
)
)
{
aLeaves
.
AppendElement
(
this
)
;
return
;
}
FlattenedDisplayListIterator
iter
(
aBuilder
&
mChildren
)
;
while
(
nsDisplayItem
*
item
=
iter
.
GetNextItem
(
)
)
{
if
(
item
-
>
GetType
(
)
=
=
DisplayItemType
:
:
TYPE_PERSPECTIVE
)
{
auto
*
perspective
=
static_cast
<
nsDisplayPerspective
*
>
(
item
)
;
if
(
!
perspective
-
>
GetChildren
(
)
-
>
GetTop
(
)
)
{
continue
;
}
item
=
perspective
-
>
GetChildren
(
)
-
>
GetTop
(
)
;
}
if
(
item
-
>
GetType
(
)
!
=
DisplayItemType
:
:
TYPE_TRANSFORM
)
{
gfxCriticalError
(
)
<
<
"
Invalid
child
item
within
3D
transform
of
type
:
"
<
<
item
-
>
Name
(
)
;
continue
;
}
static_cast
<
nsDisplayTransform
*
>
(
item
)
-
>
Collect3DTransformLeaves
(
aBuilder
aLeaves
)
;
}
}
static
RefPtr
<
gfx
:
:
Path
>
BuildPathFromPolygon
(
const
RefPtr
<
DrawTarget
>
&
aDT
const
gfx
:
:
Polygon
&
aPolygon
)
{
MOZ_ASSERT
(
!
aPolygon
.
IsEmpty
(
)
)
;
RefPtr
<
PathBuilder
>
pathBuilder
=
aDT
-
>
CreatePathBuilder
(
)
;
const
nsTArray
<
Point4D
>
&
points
=
aPolygon
.
GetPoints
(
)
;
pathBuilder
-
>
MoveTo
(
points
[
0
]
.
As2DPoint
(
)
)
;
for
(
size_t
i
=
1
;
i
<
points
.
Length
(
)
;
+
+
i
)
{
pathBuilder
-
>
LineTo
(
points
[
i
]
.
As2DPoint
(
)
)
;
}
pathBuilder
-
>
Close
(
)
;
return
pathBuilder
-
>
Finish
(
)
;
}
void
nsDisplayTransform
:
:
CollectSorted3DTransformLeaves
(
nsDisplayListBuilder
*
aBuilder
nsTArray
<
TransformPolygon
>
&
aLeaves
)
{
std
:
:
list
<
TransformPolygon
>
inputLayers
;
nsTArray
<
nsDisplayTransform
*
>
leaves
;
Collect3DTransformLeaves
(
aBuilder
leaves
)
;
for
(
nsDisplayTransform
*
item
:
leaves
)
{
auto
bounds
=
LayoutDeviceRect
:
:
FromAppUnits
(
item
-
>
mChildBounds
item
-
>
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
Matrix4x4
transform
=
item
-
>
GetAccumulatedPreserved3DTransform
(
aBuilder
)
;
if
(
!
IsFrameVisible
(
item
-
>
mFrame
transform
)
)
{
continue
;
}
gfx
:
:
Polygon
polygon
=
gfx
:
:
Polygon
:
:
FromRect
(
gfx
:
:
Rect
(
bounds
.
ToUnknownRect
(
)
)
)
;
polygon
.
TransformToScreenSpace
(
transform
)
;
if
(
polygon
.
GetPoints
(
)
.
Length
(
)
>
=
3
)
{
inputLayers
.
push_back
(
TransformPolygon
(
item
std
:
:
move
(
polygon
)
)
)
;
}
}
if
(
inputLayers
.
empty
(
)
)
{
return
;
}
BSPTree
<
nsDisplayTransform
>
tree
(
inputLayers
)
;
nsTArray
<
TransformPolygon
>
orderedLayers
(
tree
.
GetDrawOrder
(
)
)
;
for
(
TransformPolygon
&
polygon
:
orderedLayers
)
{
Matrix4x4
inverse
=
polygon
.
data
-
>
GetAccumulatedPreserved3DTransform
(
aBuilder
)
.
Inverse
(
)
;
MOZ_ASSERT
(
polygon
.
geometry
)
;
polygon
.
geometry
-
>
TransformToLayerSpace
(
inverse
)
;
}
aLeaves
=
std
:
:
move
(
orderedLayers
)
;
}
void
nsDisplayTransform
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
Paint
(
aBuilder
aCtx
Nothing
(
)
)
;
}
void
nsDisplayTransform
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
const
Maybe
<
gfx
:
:
Polygon
>
&
aPolygon
)
{
if
(
IsParticipating3DContext
(
)
&
&
!
IsLeafOf3DContext
(
)
)
{
MOZ_ASSERT
(
!
aPolygon
)
;
nsTArray
<
TransformPolygon
>
leaves
;
CollectSorted3DTransformLeaves
(
aBuilder
leaves
)
;
for
(
TransformPolygon
&
item
:
leaves
)
{
item
.
data
-
>
Paint
(
aBuilder
aCtx
item
.
geometry
)
;
}
return
;
}
gfxContextMatrixAutoSaveRestore
saveMatrix
(
aCtx
)
;
Matrix4x4
trans
=
ShouldSkipTransform
(
aBuilder
)
?
Matrix4x4
(
)
:
GetAccumulatedPreserved3DTransform
(
aBuilder
)
;
if
(
!
IsFrameVisible
(
mFrame
trans
)
)
{
return
;
}
Matrix
trans2d
;
if
(
trans
.
CanDraw2D
(
&
trans2d
)
)
{
aCtx
-
>
Multiply
(
ThebesMatrix
(
trans2d
)
)
;
if
(
aPolygon
)
{
RefPtr
<
gfx
:
:
Path
>
path
=
BuildPathFromPolygon
(
aCtx
-
>
GetDrawTarget
(
)
*
aPolygon
)
;
aCtx
-
>
GetDrawTarget
(
)
-
>
PushClip
(
path
)
;
}
GetChildren
(
)
-
>
Paint
(
aBuilder
aCtx
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
if
(
aPolygon
)
{
aCtx
-
>
GetDrawTarget
(
)
-
>
PopClip
(
)
;
}
return
;
}
auto
pixelBounds
=
LayoutDeviceRect
:
:
FromAppUnitsToOutside
(
mChildBounds
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
RefPtr
<
DrawTarget
>
untransformedDT
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
CreateOffscreenContentDrawTarget
(
IntSize
(
pixelBounds
.
Width
(
)
pixelBounds
.
Height
(
)
)
SurfaceFormat
:
:
B8G8R8A8
true
)
;
if
(
!
untransformedDT
|
|
!
untransformedDT
-
>
IsValid
(
)
)
{
return
;
}
untransformedDT
-
>
SetTransform
(
Matrix
:
:
Translation
(
-
Point
(
pixelBounds
.
X
(
)
pixelBounds
.
Y
(
)
)
)
)
;
RefPtr
<
gfxContext
>
groupTarget
=
gfxContext
:
:
CreatePreservingTransformOrNull
(
untransformedDT
)
;
if
(
aPolygon
)
{
RefPtr
<
gfx
:
:
Path
>
path
=
BuildPathFromPolygon
(
aCtx
-
>
GetDrawTarget
(
)
*
aPolygon
)
;
aCtx
-
>
GetDrawTarget
(
)
-
>
PushClip
(
path
)
;
}
GetChildren
(
)
-
>
Paint
(
aBuilder
groupTarget
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
if
(
aPolygon
)
{
aCtx
-
>
GetDrawTarget
(
)
-
>
PopClip
(
)
;
}
RefPtr
<
SourceSurface
>
untransformedSurf
=
untransformedDT
-
>
Snapshot
(
)
;
trans
.
PreTranslate
(
pixelBounds
.
X
(
)
pixelBounds
.
Y
(
)
0
)
;
aCtx
-
>
GetDrawTarget
(
)
-
>
Draw3DTransformedSurface
(
untransformedSurf
trans
)
;
}
bool
nsDisplayTransform
:
:
MayBeAnimated
(
nsDisplayListBuilder
*
aBuilder
bool
aEnforceMinimumSize
)
const
{
return
EffectCompositor
:
:
HasAnimationsForCompositor
(
mFrame
DisplayItemType
:
:
TYPE_TRANSFORM
)
|
|
(
ActiveLayerTracker
:
:
IsTransformAnimated
(
aBuilder
mFrame
)
&
&
!
(
aEnforceMinimumSize
&
&
IsItemTooSmallForActiveLayer
(
mFrame
)
)
)
;
}
nsRect
nsDisplayTransform
:
:
TransformUntransformedBounds
(
nsDisplayListBuilder
*
aBuilder
const
Matrix4x4Flagged
&
aMatrix
)
const
{
bool
snap
;
const
nsRect
untransformedBounds
=
GetUntransformedBounds
(
aBuilder
&
snap
)
;
const
float
factor
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
return
nsLayoutUtils
:
:
MatrixTransformRect
(
untransformedBounds
aMatrix
factor
)
;
}
nsRect
nsDisplayTransform
:
:
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
{
*
aSnap
=
false
;
return
mBounds
;
}
void
nsDisplayTransform
:
:
ComputeBounds
(
nsDisplayListBuilder
*
aBuilder
)
{
MOZ_ASSERT
(
mFrame
-
>
Extend3DContext
(
)
|
|
IsLeafOf3DContext
(
)
)
;
nsDisplayListBuilder
:
:
AutoAccumulateTransform
accTransform
(
aBuilder
)
;
accTransform
.
Accumulate
(
GetTransform
(
)
.
GetMatrix
(
)
)
;
if
(
!
IsLeafOf3DContext
(
)
)
{
for
(
nsDisplayItem
*
i
:
*
GetChildren
(
)
)
{
i
-
>
DoUpdateBoundsPreserves3D
(
aBuilder
)
;
}
}
const
nsRect
rect
=
TransformUntransformedBounds
(
aBuilder
accTransform
.
GetCurrentTransform
(
)
)
;
aBuilder
-
>
AccumulateRect
(
rect
)
;
}
void
nsDisplayTransform
:
:
DoUpdateBoundsPreserves3D
(
nsDisplayListBuilder
*
aBuilder
)
{
MOZ_ASSERT
(
mFrame
-
>
Combines3DTransformWithAncestors
(
)
|
|
IsTransformSeparator
(
)
)
;
ComputeBounds
(
aBuilder
)
;
}
void
nsDisplayTransform
:
:
UpdateBounds
(
nsDisplayListBuilder
*
aBuilder
)
{
UpdateUntransformedBounds
(
aBuilder
)
;
if
(
IsTransformSeparator
(
)
)
{
MOZ_ASSERT
(
GetTransform
(
)
.
IsIdentity
(
)
)
;
mBounds
=
mChildBounds
;
return
;
}
if
(
mFrame
-
>
Extend3DContext
(
)
)
{
if
(
!
Combines3DTransformWithAncestors
(
)
)
{
UpdateBoundsFor3D
(
aBuilder
)
;
}
else
{
mBounds
=
nsRect
(
)
;
}
return
;
}
MOZ_ASSERT
(
!
mFrame
-
>
Extend3DContext
(
)
)
;
mBounds
=
TransformUntransformedBounds
(
aBuilder
GetTransform
(
)
)
;
}
void
nsDisplayTransform
:
:
UpdateBoundsFor3D
(
nsDisplayListBuilder
*
aBuilder
)
{
MOZ_ASSERT
(
mFrame
-
>
Extend3DContext
(
)
&
&
!
mFrame
-
>
Combines3DTransformWithAncestors
(
)
&
&
!
IsTransformSeparator
(
)
)
;
nsDisplayListBuilder
:
:
AutoAccumulateRect
accRect
(
aBuilder
)
;
nsDisplayListBuilder
:
:
AutoAccumulateTransform
accTransform
(
aBuilder
)
;
accTransform
.
StartRoot
(
)
;
ComputeBounds
(
aBuilder
)
;
mBounds
=
aBuilder
-
>
GetAccumulatedRect
(
)
;
}
void
nsDisplayTransform
:
:
UpdateUntransformedBounds
(
nsDisplayListBuilder
*
aBuilder
)
{
mChildBounds
=
GetChildren
(
)
-
>
GetClippedBoundsWithRespectToASR
(
aBuilder
mActiveScrolledRoot
)
;
}
#
ifdef
DEBUG_HIT
#
include
<
time
.
h
>
#
endif
void
nsDisplayTransform
:
:
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
{
if
(
aState
-
>
mInPreserves3D
)
{
GetChildren
(
)
-
>
HitTest
(
aBuilder
aRect
aState
aOutFrames
)
;
return
;
}
float
factor
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
Matrix4x4
matrix
=
GetAccumulatedPreserved3DTransform
(
aBuilder
)
;
if
(
!
IsFrameVisible
(
mFrame
matrix
)
)
{
return
;
}
matrix
.
Invert
(
)
;
nsRect
resultingRect
;
if
(
aRect
.
width
=
=
1
&
&
aRect
.
height
=
=
1
)
{
Point4D
point
=
matrix
.
ProjectPoint
(
Point
(
NSAppUnitsToFloatPixels
(
aRect
.
x
factor
)
NSAppUnitsToFloatPixels
(
aRect
.
y
factor
)
)
)
;
if
(
!
point
.
HasPositiveWCoord
(
)
)
{
return
;
}
Point
point2d
=
point
.
As2DPoint
(
)
;
resultingRect
=
nsRect
(
NSFloatPixelsToAppUnits
(
float
(
point2d
.
x
)
factor
)
NSFloatPixelsToAppUnits
(
float
(
point2d
.
y
)
factor
)
1
1
)
;
}
else
{
Rect
originalRect
(
NSAppUnitsToFloatPixels
(
aRect
.
x
factor
)
NSAppUnitsToFloatPixels
(
aRect
.
y
factor
)
NSAppUnitsToFloatPixels
(
aRect
.
width
factor
)
NSAppUnitsToFloatPixels
(
aRect
.
height
factor
)
)
;
bool
snap
;
nsRect
childBounds
=
GetUntransformedBounds
(
aBuilder
&
snap
)
;
Rect
childGfxBounds
(
NSAppUnitsToFloatPixels
(
childBounds
.
x
factor
)
NSAppUnitsToFloatPixels
(
childBounds
.
y
factor
)
NSAppUnitsToFloatPixels
(
childBounds
.
width
factor
)
NSAppUnitsToFloatPixels
(
childBounds
.
height
factor
)
)
;
Rect
rect
=
matrix
.
ProjectRectBounds
(
originalRect
childGfxBounds
)
;
resultingRect
=
nsRect
(
NSFloatPixelsToAppUnits
(
float
(
rect
.
X
(
)
)
factor
)
NSFloatPixelsToAppUnits
(
float
(
rect
.
Y
(
)
)
factor
)
NSFloatPixelsToAppUnits
(
float
(
rect
.
Width
(
)
)
factor
)
NSFloatPixelsToAppUnits
(
float
(
rect
.
Height
(
)
)
factor
)
)
;
}
if
(
resultingRect
.
IsEmpty
(
)
)
{
return
;
}
#
ifdef
DEBUG_HIT
printf
(
"
Frame
:
%
p
\
n
"
dynamic_cast
<
void
*
>
(
mFrame
)
)
;
printf
(
"
Untransformed
point
:
(
%
f
%
f
)
\
n
"
resultingRect
.
X
(
)
resultingRect
.
Y
(
)
)
;
uint32_t
originalFrameCount
=
aOutFrames
.
Length
(
)
;
#
endif
GetChildren
(
)
-
>
HitTest
(
aBuilder
resultingRect
aState
aOutFrames
)
;
#
ifdef
DEBUG_HIT
if
(
originalFrameCount
!
=
aOutFrames
.
Length
(
)
)
printf
(
"
Hit
!
Time
:
%
f
first
frame
:
%
p
\
n
"
static_cast
<
double
>
(
clock
(
)
)
dynamic_cast
<
void
*
>
(
aOutFrames
.
ElementAt
(
0
)
)
)
;
printf
(
"
=
=
=
end
of
hit
test
=
=
=
\
n
"
)
;
#
endif
}
float
nsDisplayTransform
:
:
GetHitDepthAtPoint
(
nsDisplayListBuilder
*
aBuilder
const
nsPoint
&
aPoint
)
{
float
factor
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
Matrix4x4
matrix
=
GetAccumulatedPreserved3DTransform
(
aBuilder
)
;
NS_ASSERTION
(
IsFrameVisible
(
mFrame
matrix
)
"
We
can
'
t
have
hit
a
frame
that
isn
'
t
visible
!
"
)
;
Matrix4x4
inverse
=
matrix
;
inverse
.
Invert
(
)
;
Point4D
point
=
inverse
.
ProjectPoint
(
Point
(
NSAppUnitsToFloatPixels
(
aPoint
.
x
factor
)
NSAppUnitsToFloatPixels
(
aPoint
.
y
factor
)
)
)
;
Point
point2d
=
point
.
As2DPoint
(
)
;
Point3D
transformed
=
matrix
.
TransformPoint
(
Point3D
(
point2d
.
x
point2d
.
y
0
)
)
;
return
transformed
.
z
;
}
nsRegion
nsDisplayTransform
:
:
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
{
*
aSnap
=
false
;
nsRect
untransformedVisible
;
if
(
!
UntransformBuildingRect
(
aBuilder
&
untransformedVisible
)
)
{
return
nsRegion
(
)
;
}
const
Matrix4x4Flagged
&
matrix
=
GetTransform
(
)
;
Matrix
matrix2d
;
if
(
!
matrix
.
Is2D
(
&
matrix2d
)
|
|
!
matrix2d
.
PreservesAxisAlignedRectangles
(
)
)
{
return
nsRegion
(
)
;
}
nsRegion
result
;
bool
tmpSnap
;
const
nsRect
bounds
=
GetUntransformedBounds
(
aBuilder
&
tmpSnap
)
;
const
nsRegion
opaque
=
:
:
mozilla
:
:
GetOpaqueRegion
(
aBuilder
GetChildren
(
)
bounds
)
;
if
(
opaque
.
Contains
(
untransformedVisible
)
)
{
result
=
GetBuildingRect
(
)
.
Intersect
(
GetBounds
(
aBuilder
&
tmpSnap
)
)
;
}
return
result
;
}
nsRect
nsDisplayTransform
:
:
GetComponentAlphaBounds
(
nsDisplayListBuilder
*
aBuilder
)
const
{
if
(
GetChildren
(
)
-
>
GetComponentAlphaBounds
(
aBuilder
)
.
IsEmpty
(
)
)
{
return
nsRect
(
)
;
}
bool
snap
;
return
GetBounds
(
aBuilder
&
snap
)
;
}
nsRect
nsDisplayTransform
:
:
TransformRect
(
const
nsRect
&
aUntransformedBounds
const
nsIFrame
*
aFrame
TransformReferenceBox
&
aRefBox
)
{
MOZ_ASSERT
(
aFrame
"
Can
'
t
take
the
transform
based
on
a
null
frame
!
"
)
;
float
factor
=
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
uint32_t
flags
=
INCLUDE_PERSPECTIVE
|
OFFSET_BY_ORIGIN
|
INCLUDE_PRESERVE3D_ANCESTORS
;
FrameTransformProperties
props
(
aFrame
aRefBox
factor
)
;
return
nsLayoutUtils
:
:
MatrixTransformRect
(
aUntransformedBounds
GetResultingTransformMatrixInternal
(
props
aRefBox
nsPoint
(
0
0
)
factor
flags
)
factor
)
;
}
bool
nsDisplayTransform
:
:
UntransformRect
(
const
nsRect
&
aTransformedBounds
const
nsRect
&
aChildBounds
const
nsIFrame
*
aFrame
nsRect
*
aOutRect
)
{
MOZ_ASSERT
(
aFrame
"
Can
'
t
take
the
transform
based
on
a
null
frame
!
"
)
;
float
factor
=
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
uint32_t
flags
=
INCLUDE_PERSPECTIVE
|
OFFSET_BY_ORIGIN
|
INCLUDE_PRESERVE3D_ANCESTORS
;
Matrix4x4
transform
=
GetResultingTransformMatrix
(
aFrame
nsPoint
(
0
0
)
factor
flags
)
;
if
(
transform
.
IsSingular
(
)
)
{
return
false
;
}
RectDouble
result
(
NSAppUnitsToFloatPixels
(
aTransformedBounds
.
x
factor
)
NSAppUnitsToFloatPixels
(
aTransformedBounds
.
y
factor
)
NSAppUnitsToFloatPixels
(
aTransformedBounds
.
width
factor
)
NSAppUnitsToFloatPixels
(
aTransformedBounds
.
height
factor
)
)
;
RectDouble
childGfxBounds
(
NSAppUnitsToFloatPixels
(
aChildBounds
.
x
factor
)
NSAppUnitsToFloatPixels
(
aChildBounds
.
y
factor
)
NSAppUnitsToFloatPixels
(
aChildBounds
.
width
factor
)
NSAppUnitsToFloatPixels
(
aChildBounds
.
height
factor
)
)
;
result
=
transform
.
Inverse
(
)
.
ProjectRectBounds
(
result
childGfxBounds
)
;
*
aOutRect
=
nsLayoutUtils
:
:
RoundGfxRectToAppRect
(
ThebesRect
(
result
)
factor
)
;
return
true
;
}
bool
nsDisplayTransform
:
:
UntransformRect
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
nsRect
*
aOutRect
)
const
{
if
(
GetTransform
(
)
.
IsSingular
(
)
)
{
return
false
;
}
float
factor
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
RectDouble
result
(
NSAppUnitsToFloatPixels
(
aRect
.
x
factor
)
NSAppUnitsToFloatPixels
(
aRect
.
y
factor
)
NSAppUnitsToFloatPixels
(
aRect
.
width
factor
)
NSAppUnitsToFloatPixels
(
aRect
.
height
factor
)
)
;
bool
snap
;
nsRect
childBounds
=
GetUntransformedBounds
(
aBuilder
&
snap
)
;
RectDouble
childGfxBounds
(
NSAppUnitsToFloatPixels
(
childBounds
.
x
factor
)
NSAppUnitsToFloatPixels
(
childBounds
.
y
factor
)
NSAppUnitsToFloatPixels
(
childBounds
.
width
factor
)
NSAppUnitsToFloatPixels
(
childBounds
.
height
factor
)
)
;
result
=
GetInverseTransform
(
)
.
ProjectRectBounds
(
result
childGfxBounds
)
;
*
aOutRect
=
nsLayoutUtils
:
:
RoundGfxRectToAppRect
(
ThebesRect
(
result
)
factor
)
;
return
true
;
}
void
nsDisplayTransform
:
:
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
{
aStream
<
<
GetTransform
(
)
.
GetMatrix
(
)
;
if
(
IsTransformSeparator
(
)
)
{
aStream
<
<
"
transform
-
separator
"
;
}
if
(
IsLeafOf3DContext
(
)
)
{
aStream
<
<
"
3d
-
context
-
leaf
"
;
}
if
(
mFrame
-
>
Extend3DContext
(
)
)
{
aStream
<
<
"
extends
-
3d
-
context
"
;
}
if
(
mFrame
-
>
Combines3DTransformWithAncestors
(
)
)
{
aStream
<
<
"
combines
-
3d
-
with
-
ancestors
"
;
}
aStream
<
<
"
prerender
(
"
;
switch
(
mPrerenderDecision
)
{
case
PrerenderDecision
:
:
No
:
aStream
<
<
"
no
"
;
break
;
case
PrerenderDecision
:
:
Partial
:
aStream
<
<
"
partial
"
;
break
;
case
PrerenderDecision
:
:
Full
:
aStream
<
<
"
full
"
;
break
;
}
aStream
<
<
"
)
"
;
aStream
<
<
"
childrenBuildingRect
"
<
<
mChildrenBuildingRect
;
}
nsDisplayPerspective
:
:
nsDisplayPerspective
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
)
:
nsPaintedDisplayItem
(
aBuilder
aFrame
)
{
mList
.
AppendToTop
(
aList
)
;
MOZ_ASSERT
(
mList
.
Count
(
)
=
=
1
)
;
MOZ_ASSERT
(
mList
.
GetTop
(
)
-
>
GetType
(
)
=
=
DisplayItemType
:
:
TYPE_TRANSFORM
)
;
}
void
nsDisplayPerspective
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
GetChildren
(
)
-
>
Paint
(
aBuilder
aCtx
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
}
nsRegion
nsDisplayPerspective
:
:
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
{
if
(
!
GetChildren
(
)
-
>
GetTop
(
)
)
{
*
aSnap
=
false
;
return
nsRegion
(
)
;
}
return
GetChildren
(
)
-
>
GetTop
(
)
-
>
GetOpaqueRegion
(
aBuilder
aSnap
)
;
}
bool
nsDisplayPerspective
:
:
CreateWebRenderCommands
(
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
float
appUnitsPerPixel
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
Matrix4x4
perspectiveMatrix
;
DebugOnly
<
bool
>
hasPerspective
=
nsDisplayTransform
:
:
ComputePerspectiveMatrix
(
mFrame
appUnitsPerPixel
perspectiveMatrix
)
;
MOZ_ASSERT
(
hasPerspective
"
Why
did
we
create
nsDisplayPerspective
?
"
)
;
if
(
!
GetChildren
(
)
-
>
GetTop
(
)
)
{
return
false
;
}
nsDisplayTransform
*
transform
=
static_cast
<
nsDisplayTransform
*
>
(
GetChildren
(
)
-
>
GetTop
(
)
)
;
Point3D
newOrigin
=
Point3D
(
NSAppUnitsToFloatPixels
(
transform
-
>
ToReferenceFrame
(
)
.
x
appUnitsPerPixel
)
NSAppUnitsToFloatPixels
(
transform
-
>
ToReferenceFrame
(
)
.
y
appUnitsPerPixel
)
0
.
0f
)
;
Point3D
roundedOrigin
(
NS_round
(
newOrigin
.
x
)
NS_round
(
newOrigin
.
y
)
0
)
;
perspectiveMatrix
.
PostTranslate
(
roundedOrigin
)
;
nsIFrame
*
perspectiveFrame
=
mFrame
-
>
GetClosestFlattenedTreeAncestorPrimaryFrame
(
)
;
bool
preserve3D
=
mFrame
-
>
Extend3DContext
(
)
|
|
perspectiveFrame
-
>
Extend3DContext
(
)
;
wr
:
:
StackingContextParams
params
;
wr
:
:
WrTransformInfo
transform_info
;
transform_info
.
transform
=
wr
:
:
ToLayoutTransform
(
perspectiveMatrix
)
;
transform_info
.
key
=
wr
:
:
SpatialKey
(
uint64_t
(
mFrame
)
GetPerFrameKey
(
)
wr
:
:
SpatialKeyKind
:
:
Perspective
)
;
params
.
mTransformPtr
=
&
transform_info
;
params
.
reference_frame_kind
=
wr
:
:
WrReferenceFrameKind
:
:
Perspective
;
params
.
prim_flags
=
!
BackfaceIsHidden
(
)
?
wr
:
:
PrimitiveFlags
:
:
IS_BACKFACE_VISIBLE
:
wr
:
:
PrimitiveFlags
{
0
}
;
params
.
SetPreserve3D
(
preserve3D
)
;
params
.
clip
=
wr
:
:
WrStackingContextClip
:
:
ClipChain
(
aBuilder
.
CurrentClipChainId
(
)
)
;
Maybe
<
uint64_t
>
scrollingRelativeTo
;
for
(
const
auto
*
asr
=
GetActiveScrolledRoot
(
)
;
asr
;
asr
=
asr
-
>
mParent
)
{
if
(
nsLayoutUtils
:
:
IsAncestorFrameCrossDocInProcess
(
asr
-
>
mScrollableFrame
-
>
GetScrolledFrame
(
)
perspectiveFrame
)
)
{
scrollingRelativeTo
.
emplace
(
asr
-
>
GetViewId
(
)
)
;
break
;
}
}
params
.
scrolling_relative_to
=
scrollingRelativeTo
.
ptrOr
(
nullptr
)
;
StackingContextHelper
sc
(
aSc
GetActiveScrolledRoot
(
)
mFrame
this
aBuilder
params
)
;
aManager
-
>
CommandBuilder
(
)
.
CreateWebRenderCommandsFromDisplayList
(
GetChildren
(
)
this
aDisplayListBuilder
sc
aBuilder
aResources
)
;
return
true
;
}
nsDisplayText
:
:
nsDisplayText
(
nsDisplayListBuilder
*
aBuilder
nsTextFrame
*
aFrame
)
:
nsPaintedDisplayItem
(
aBuilder
aFrame
)
mVisIStartEdge
(
0
)
mVisIEndEdge
(
0
)
{
MOZ_COUNT_CTOR
(
nsDisplayText
)
;
mBounds
=
mFrame
-
>
InkOverflowRectRelativeToSelf
(
)
+
ToReferenceFrame
(
)
;
mBounds
.
Inflate
(
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
mVisibleRect
=
aBuilder
-
>
GetVisibleRect
(
)
+
aBuilder
-
>
GetCurrentFrameOffsetToReferenceFrame
(
)
;
}
bool
nsDisplayText
:
:
CanApplyOpacity
(
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aBuilder
)
const
{
auto
*
f
=
static_cast
<
nsTextFrame
*
>
(
mFrame
)
;
if
(
f
-
>
IsSelected
(
)
)
{
return
false
;
}
const
nsStyleText
*
textStyle
=
f
-
>
StyleText
(
)
;
if
(
textStyle
-
>
HasTextShadow
(
)
)
{
return
false
;
}
nsTextFrame
:
:
TextDecorations
decorations
;
f
-
>
GetTextDecorations
(
f
-
>
PresContext
(
)
nsTextFrame
:
:
eResolvedColors
decorations
)
;
return
!
decorations
.
HasDecorationLines
(
)
;
}
void
nsDisplayText
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
AUTO_PROFILER_LABEL
(
"
nsDisplayText
:
:
Paint
"
GRAPHICS
)
;
RenderToContext
(
aCtx
aBuilder
GetPaintRect
(
aBuilder
aCtx
)
)
;
}
bool
nsDisplayText
:
:
CreateWebRenderCommands
(
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
auto
*
f
=
static_cast
<
nsTextFrame
*
>
(
mFrame
)
;
auto
appUnitsPerDevPixel
=
f
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
nsRect
bounds
=
f
-
>
WebRenderBounds
(
)
+
ToReferenceFrame
(
)
;
bounds
.
Inflate
(
appUnitsPerDevPixel
)
;
if
(
bounds
.
IsEmpty
(
)
)
{
return
true
;
}
constexpr
float
kWebRenderFontSizeLimit
=
320
.
0
;
f
-
>
EnsureTextRun
(
nsTextFrame
:
:
eInflated
)
;
gfxTextRun
*
textRun
=
f
-
>
GetTextRun
(
nsTextFrame
:
:
eInflated
)
;
if
(
textRun
&
&
textRun
-
>
GetFontGroup
(
)
-
>
GetStyle
(
)
-
>
size
>
kWebRenderFontSizeLimit
)
{
return
false
;
}
gfx
:
:
Point
deviceOffset
=
LayoutDevicePoint
:
:
FromAppUnits
(
bounds
.
TopLeft
(
)
appUnitsPerDevPixel
)
.
ToUnknownPoint
(
)
;
if
(
!
(
f
-
>
IsSelected
(
)
|
|
f
-
>
StyleText
(
)
-
>
HasTextShadow
(
)
)
)
{
nsRect
visible
=
mVisibleRect
;
visible
.
Inflate
(
3
*
appUnitsPerDevPixel
)
;
bounds
=
bounds
.
Intersect
(
visible
)
;
}
RefPtr
<
gfxContext
>
textDrawer
=
aBuilder
.
GetTextContext
(
aResources
aSc
aManager
this
bounds
deviceOffset
)
;
aBuilder
.
StartGroup
(
this
)
;
RenderToContext
(
textDrawer
aDisplayListBuilder
mVisibleRect
aBuilder
.
GetInheritedOpacity
(
)
true
)
;
const
bool
result
=
textDrawer
-
>
GetTextDrawer
(
)
-
>
Finish
(
)
;
if
(
result
)
{
aBuilder
.
FinishGroup
(
)
;
}
else
{
aBuilder
.
CancelGroup
(
true
)
;
}
return
result
;
}
void
nsDisplayText
:
:
RenderToContext
(
gfxContext
*
aCtx
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aVisibleRect
float
aOpacity
bool
aIsRecording
)
{
nsTextFrame
*
f
=
static_cast
<
nsTextFrame
*
>
(
mFrame
)
;
auto
A2D
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
LayoutDeviceRect
extraVisible
=
LayoutDeviceRect
:
:
FromAppUnits
(
aVisibleRect
A2D
)
;
extraVisible
.
Inflate
(
1
)
;
gfxRect
pixelVisible
(
extraVisible
.
x
extraVisible
.
y
extraVisible
.
width
extraVisible
.
height
)
;
pixelVisible
.
Inflate
(
2
)
;
pixelVisible
.
RoundOut
(
)
;
bool
willClip
=
!
aBuilder
-
>
IsForGenerateGlyphMask
(
)
&
&
!
aIsRecording
;
if
(
willClip
)
{
aCtx
-
>
NewPath
(
)
;
aCtx
-
>
Rectangle
(
pixelVisible
)
;
aCtx
-
>
Clip
(
)
;
}
NS_ASSERTION
(
mVisIStartEdge
>
=
0
"
illegal
start
edge
"
)
;
NS_ASSERTION
(
mVisIEndEdge
>
=
0
"
illegal
end
edge
"
)
;
gfxContextMatrixAutoSaveRestore
matrixSR
;
nsPoint
framePt
=
ToReferenceFrame
(
)
;
if
(
f
-
>
Style
(
)
-
>
IsTextCombined
(
)
)
{
float
scaleFactor
=
nsTextFrame
:
:
GetTextCombineScaleFactor
(
f
)
;
if
(
scaleFactor
!
=
1
.
0f
)
{
if
(
auto
*
textDrawer
=
aCtx
-
>
GetTextDrawer
(
)
)
{
textDrawer
-
>
FoundUnsupportedFeature
(
)
;
return
;
}
matrixSR
.
SetContext
(
aCtx
)
;
gfxPoint
pt
=
nsLayoutUtils
:
:
PointToGfxPoint
(
framePt
A2D
)
;
gfxMatrix
mat
=
aCtx
-
>
CurrentMatrixDouble
(
)
.
PreTranslate
(
pt
)
.
PreScale
(
scaleFactor
1
.
0
)
.
PreTranslate
(
-
pt
)
;
aCtx
-
>
SetMatrixDouble
(
mat
)
;
}
}
nsTextFrame
:
:
PaintTextParams
params
(
aCtx
)
;
params
.
framePt
=
gfx
:
:
Point
(
framePt
.
x
framePt
.
y
)
;
params
.
dirtyRect
=
extraVisible
;
if
(
aBuilder
-
>
IsForGenerateGlyphMask
(
)
)
{
params
.
state
=
nsTextFrame
:
:
PaintTextParams
:
:
GenerateTextMask
;
}
else
{
params
.
state
=
nsTextFrame
:
:
PaintTextParams
:
:
PaintText
;
}
f
-
>
PaintText
(
params
mVisIStartEdge
mVisIEndEdge
ToReferenceFrame
(
)
f
-
>
IsSelected
(
)
aOpacity
)
;
if
(
willClip
)
{
aCtx
-
>
PopClip
(
)
;
}
}
class
nsDisplayTextGeometry
:
public
nsDisplayItemGenericGeometry
{
public
:
nsDisplayTextGeometry
(
nsDisplayText
*
aItem
nsDisplayListBuilder
*
aBuilder
)
:
nsDisplayItemGenericGeometry
(
aItem
aBuilder
)
mVisIStartEdge
(
aItem
-
>
VisIStartEdge
(
)
)
mVisIEndEdge
(
aItem
-
>
VisIEndEdge
(
)
)
{
nsTextFrame
*
f
=
static_cast
<
nsTextFrame
*
>
(
aItem
-
>
Frame
(
)
)
;
f
-
>
GetTextDecorations
(
f
-
>
PresContext
(
)
nsTextFrame
:
:
eResolvedColors
mDecorations
)
;
}
nsTextFrame
:
:
TextDecorations
mDecorations
;
nscoord
mVisIStartEdge
;
nscoord
mVisIEndEdge
;
}
;
nsDisplayItemGeometry
*
nsDisplayText
:
:
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
{
return
new
nsDisplayTextGeometry
(
this
aBuilder
)
;
}
void
nsDisplayText
:
:
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
{
const
nsDisplayTextGeometry
*
geometry
=
static_cast
<
const
nsDisplayTextGeometry
*
>
(
aGeometry
)
;
nsTextFrame
*
f
=
static_cast
<
nsTextFrame
*
>
(
mFrame
)
;
nsTextFrame
:
:
TextDecorations
decorations
;
f
-
>
GetTextDecorations
(
f
-
>
PresContext
(
)
nsTextFrame
:
:
eResolvedColors
decorations
)
;
bool
snap
;
const
nsRect
&
newRect
=
geometry
-
>
mBounds
;
nsRect
oldRect
=
GetBounds
(
aBuilder
&
snap
)
;
if
(
decorations
!
=
geometry
-
>
mDecorations
|
|
mVisIStartEdge
!
=
geometry
-
>
mVisIStartEdge
|
|
mVisIEndEdge
!
=
geometry
-
>
mVisIEndEdge
|
|
!
oldRect
.
IsEqualInterior
(
newRect
)
|
|
!
geometry
-
>
mBorderRect
.
IsEqualInterior
(
GetBorderRect
(
)
)
)
{
aInvalidRegion
-
>
Or
(
oldRect
newRect
)
;
}
}
void
nsDisplayText
:
:
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
{
#
ifdef
DEBUG
aStream
<
<
"
(
\
"
"
;
nsTextFrame
*
f
=
static_cast
<
nsTextFrame
*
>
(
mFrame
)
;
nsCString
buf
;
int32_t
totalContentLength
;
f
-
>
ToCString
(
buf
&
totalContentLength
)
;
aStream
<
<
buf
.
get
(
)
<
<
"
\
"
)
"
;
#
endif
}
nsDisplayEffectsBase
:
:
nsDisplayEffectsBase
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
ActiveScrolledRoot
*
aActiveScrolledRoot
bool
aClearClipChain
)
:
nsDisplayWrapList
(
aBuilder
aFrame
aList
aActiveScrolledRoot
aClearClipChain
)
{
MOZ_COUNT_CTOR
(
nsDisplayEffectsBase
)
;
}
nsDisplayEffectsBase
:
:
nsDisplayEffectsBase
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
)
:
nsDisplayWrapList
(
aBuilder
aFrame
aList
)
{
MOZ_COUNT_CTOR
(
nsDisplayEffectsBase
)
;
}
nsRegion
nsDisplayEffectsBase
:
:
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
{
*
aSnap
=
false
;
return
nsRegion
(
)
;
}
void
nsDisplayEffectsBase
:
:
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
{
nsPoint
rectCenter
(
aRect
.
x
+
aRect
.
width
/
2
aRect
.
y
+
aRect
.
height
/
2
)
;
if
(
SVGIntegrationUtils
:
:
HitTestFrameForEffects
(
mFrame
rectCenter
-
ToReferenceFrame
(
)
)
)
{
mList
.
HitTest
(
aBuilder
aRect
aState
aOutFrames
)
;
}
}
gfxRect
nsDisplayEffectsBase
:
:
BBoxInUserSpace
(
)
const
{
return
SVGUtils
:
:
GetBBox
(
mFrame
)
;
}
gfxPoint
nsDisplayEffectsBase
:
:
UserSpaceOffset
(
)
const
{
return
SVGUtils
:
:
FrameSpaceInCSSPxToUserSpaceOffset
(
mFrame
)
;
}
void
nsDisplayEffectsBase
:
:
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
{
const
auto
*
geometry
=
static_cast
<
const
nsDisplaySVGEffectGeometry
*
>
(
aGeometry
)
;
bool
snap
;
nsRect
bounds
=
GetBounds
(
aBuilder
&
snap
)
;
if
(
geometry
-
>
mFrameOffsetToReferenceFrame
!
=
ToReferenceFrame
(
)
|
|
geometry
-
>
mUserSpaceOffset
!
=
UserSpaceOffset
(
)
|
|
!
geometry
-
>
mBBox
.
IsEqualInterior
(
BBoxInUserSpace
(
)
)
)
{
aInvalidRegion
-
>
Or
(
bounds
geometry
-
>
mBounds
)
;
}
}
bool
nsDisplayEffectsBase
:
:
ValidateSVGFrame
(
)
{
const
nsIContent
*
content
=
mFrame
-
>
GetContent
(
)
;
bool
hasSVGLayout
=
mFrame
-
>
HasAnyStateBits
(
NS_FRAME_SVG_LAYOUT
)
;
if
(
hasSVGLayout
)
{
ISVGDisplayableFrame
*
svgFrame
=
do_QueryFrame
(
mFrame
)
;
if
(
!
svgFrame
|
|
!
mFrame
-
>
GetContent
(
)
-
>
IsSVGElement
(
)
)
{
NS_ASSERTION
(
false
"
why
?
"
)
;
return
false
;
}
if
(
!
static_cast
<
const
SVGElement
*
>
(
content
)
-
>
HasValidDimensions
(
)
)
{
return
false
;
}
}
return
true
;
}
using
PaintFramesParams
=
SVGIntegrationUtils
:
:
PaintFramesParams
;
static
void
ComputeMaskGeometry
(
PaintFramesParams
&
aParams
)
{
nsIFrame
*
firstFrame
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
aParams
.
frame
)
;
const
nsStyleSVGReset
*
svgReset
=
firstFrame
-
>
StyleSVGReset
(
)
;
nsTArray
<
SVGMaskFrame
*
>
maskFrames
;
SVGObserverUtils
:
:
GetAndObserveMasks
(
firstFrame
&
maskFrames
)
;
if
(
maskFrames
.
Length
(
)
=
=
0
)
{
return
;
}
gfxContext
&
ctx
=
aParams
.
ctx
;
nsIFrame
*
frame
=
aParams
.
frame
;
nsPoint
offsetToUserSpace
=
nsLayoutUtils
:
:
ComputeOffsetToUserSpace
(
aParams
.
builder
aParams
.
frame
)
;
gfxPoint
devPixelOffsetToUserSpace
=
nsLayoutUtils
:
:
PointToGfxPoint
(
offsetToUserSpace
frame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
gfxContextMatrixAutoSaveRestore
matSR
(
&
ctx
)
;
ctx
.
SetMatrixDouble
(
ctx
.
CurrentMatrixDouble
(
)
.
PreTranslate
(
devPixelOffsetToUserSpace
)
)
;
int32_t
appUnitsPerDevPixel
=
frame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
nsRect
userSpaceBorderArea
=
aParams
.
borderArea
-
offsetToUserSpace
;
nsRect
userSpaceDirtyRect
=
aParams
.
dirtyRect
-
offsetToUserSpace
;
gfxRect
maskInUserSpace
;
for
(
size_t
i
=
0
;
i
<
maskFrames
.
Length
(
)
;
i
+
+
)
{
SVGMaskFrame
*
maskFrame
=
maskFrames
[
i
]
;
gfxRect
currentMaskSurfaceRect
;
if
(
maskFrame
)
{
currentMaskSurfaceRect
=
maskFrame
-
>
GetMaskArea
(
aParams
.
frame
)
;
}
else
{
nsCSSRendering
:
:
ImageLayerClipState
clipState
;
nsCSSRendering
:
:
GetImageLayerClip
(
svgReset
-
>
mMask
.
mLayers
[
i
]
frame
*
frame
-
>
StyleBorder
(
)
userSpaceBorderArea
userSpaceDirtyRect
false
appUnitsPerDevPixel
&
clipState
)
;
currentMaskSurfaceRect
=
clipState
.
mDirtyRectInDevPx
;
}
maskInUserSpace
=
maskInUserSpace
.
Union
(
currentMaskSurfaceRect
)
;
}
if
(
!
maskInUserSpace
.
IsEmpty
(
)
)
{
aParams
.
maskRect
=
Some
(
ToRect
(
maskInUserSpace
)
)
;
}
else
{
aParams
.
maskRect
=
Nothing
(
)
;
}
}
nsDisplayMasksAndClipPaths
:
:
nsDisplayMasksAndClipPaths
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
ActiveScrolledRoot
*
aActiveScrolledRoot
)
:
nsDisplayEffectsBase
(
aBuilder
aFrame
aList
aActiveScrolledRoot
true
)
{
MOZ_COUNT_CTOR
(
nsDisplayMasksAndClipPaths
)
;
nsPresContext
*
presContext
=
mFrame
-
>
PresContext
(
)
;
uint32_t
flags
=
aBuilder
-
>
GetBackgroundPaintFlags
(
)
|
nsCSSRendering
:
:
PAINTBG_MASK_IMAGE
;
const
nsStyleSVGReset
*
svgReset
=
aFrame
-
>
StyleSVGReset
(
)
;
NS_FOR_VISIBLE_IMAGE_LAYERS_BACK_TO_FRONT
(
i
svgReset
-
>
mMask
)
{
const
auto
&
layer
=
svgReset
-
>
mMask
.
mLayers
[
i
]
;
if
(
!
layer
.
mImage
.
IsResolved
(
)
)
{
continue
;
}
const
nsRect
&
borderArea
=
mFrame
-
>
GetRectRelativeToSelf
(
)
;
bool
isTransformedFixed
=
false
;
nsBackgroundLayerState
state
=
nsCSSRendering
:
:
PrepareImageLayer
(
presContext
aFrame
flags
borderArea
borderArea
layer
&
isTransformedFixed
)
;
mDestRects
.
AppendElement
(
state
.
mDestArea
)
;
}
}
static
bool
CanMergeDisplayMaskFrame
(
nsIFrame
*
aFrame
)
{
if
(
aFrame
-
>
StyleBorder
(
)
-
>
mBoxDecorationBreak
=
=
StyleBoxDecorationBreak
:
:
Clone
)
{
return
false
;
}
if
(
aFrame
-
>
StyleSVGReset
(
)
-
>
HasMask
(
)
)
{
return
false
;
}
return
true
;
}
bool
nsDisplayMasksAndClipPaths
:
:
CanMerge
(
const
nsDisplayItem
*
aItem
)
const
{
if
(
!
HasDifferentFrame
(
aItem
)
|
|
!
HasSameTypeAndClip
(
aItem
)
|
|
!
HasSameContent
(
aItem
)
)
{
return
false
;
}
return
CanMergeDisplayMaskFrame
(
mFrame
)
&
&
CanMergeDisplayMaskFrame
(
aItem
-
>
Frame
(
)
)
;
}
bool
nsDisplayMasksAndClipPaths
:
:
IsValidMask
(
)
{
if
(
!
ValidateSVGFrame
(
)
)
{
return
false
;
}
nsIFrame
*
firstFrame
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
mFrame
)
;
return
!
(
SVGObserverUtils
:
:
GetAndObserveClipPath
(
firstFrame
nullptr
)
=
=
SVGObserverUtils
:
:
eHasRefsSomeInvalid
|
|
SVGObserverUtils
:
:
GetAndObserveMasks
(
firstFrame
nullptr
)
=
=
SVGObserverUtils
:
:
eHasRefsSomeInvalid
)
;
}
bool
nsDisplayMasksAndClipPaths
:
:
PaintMask
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aMaskContext
bool
aHandleOpacity
bool
*
aMaskPainted
)
{
MOZ_ASSERT
(
aMaskContext
-
>
GetDrawTarget
(
)
-
>
GetFormat
(
)
=
=
SurfaceFormat
:
:
A8
)
;
imgDrawingParams
imgParams
(
aBuilder
-
>
GetImageDecodeFlags
(
)
)
;
nsRect
borderArea
=
nsRect
(
ToReferenceFrame
(
)
mFrame
-
>
GetSize
(
)
)
;
SVGIntegrationUtils
:
:
PaintFramesParams
params
(
*
aMaskContext
mFrame
mBounds
borderArea
aBuilder
aHandleOpacity
imgParams
)
;
ComputeMaskGeometry
(
params
)
;
bool
maskIsComplete
=
false
;
bool
painted
=
SVGIntegrationUtils
:
:
PaintMask
(
params
maskIsComplete
)
;
if
(
aMaskPainted
)
{
*
aMaskPainted
=
painted
;
}
nsDisplayMasksAndClipPathsGeometry
:
:
UpdateDrawResult
(
this
imgParams
.
result
)
;
return
maskIsComplete
&
&
(
imgParams
.
result
=
=
ImgDrawResult
:
:
SUCCESS
|
|
imgParams
.
result
=
=
ImgDrawResult
:
:
SUCCESS_NOT_COMPLETE
|
|
imgParams
.
result
=
=
ImgDrawResult
:
:
WRONG_SIZE
)
;
}
void
nsDisplayMasksAndClipPaths
:
:
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
{
nsDisplayEffectsBase
:
:
ComputeInvalidationRegion
(
aBuilder
aGeometry
aInvalidRegion
)
;
const
auto
*
geometry
=
static_cast
<
const
nsDisplayMasksAndClipPathsGeometry
*
>
(
aGeometry
)
;
bool
snap
;
nsRect
bounds
=
GetBounds
(
aBuilder
&
snap
)
;
if
(
mDestRects
.
Length
(
)
!
=
geometry
-
>
mDestRects
.
Length
(
)
)
{
aInvalidRegion
-
>
Or
(
bounds
geometry
-
>
mBounds
)
;
}
else
{
for
(
size_t
i
=
0
;
i
<
mDestRects
.
Length
(
)
;
i
+
+
)
{
if
(
!
mDestRects
[
i
]
.
IsEqualInterior
(
geometry
-
>
mDestRects
[
i
]
)
)
{
aInvalidRegion
-
>
Or
(
bounds
geometry
-
>
mBounds
)
;
break
;
}
}
}
if
(
aBuilder
-
>
ShouldSyncDecodeImages
(
)
&
&
geometry
-
>
ShouldInvalidateToSyncDecodeImages
(
)
)
{
const
nsStyleSVGReset
*
svgReset
=
mFrame
-
>
StyleSVGReset
(
)
;
NS_FOR_VISIBLE_IMAGE_LAYERS_BACK_TO_FRONT
(
i
svgReset
-
>
mMask
)
{
const
auto
&
image
=
svgReset
-
>
mMask
.
mLayers
[
i
]
.
mImage
;
if
(
image
.
IsImageRequestType
(
)
)
{
aInvalidRegion
-
>
Or
(
*
aInvalidRegion
bounds
)
;
break
;
}
}
}
}
void
nsDisplayMasksAndClipPaths
:
:
PaintWithContentsPaintCallback
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
const
std
:
:
function
<
void
(
)
>
&
aPaintChildren
)
{
gfxContext
*
context
=
aCtx
;
Rect
bounds
=
NSRectToRect
(
GetPaintRect
(
aBuilder
aCtx
)
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
bounds
.
RoundOut
(
)
;
context
-
>
Clip
(
bounds
)
;
imgDrawingParams
imgParams
(
aBuilder
-
>
GetImageDecodeFlags
(
)
)
;
nsRect
borderArea
=
nsRect
(
ToReferenceFrame
(
)
mFrame
-
>
GetSize
(
)
)
;
SVGIntegrationUtils
:
:
PaintFramesParams
params
(
*
aCtx
mFrame
GetPaintRect
(
aBuilder
aCtx
)
borderArea
aBuilder
false
imgParams
)
;
ComputeMaskGeometry
(
params
)
;
SVGIntegrationUtils
:
:
PaintMaskAndClipPath
(
params
aPaintChildren
)
;
context
-
>
PopClip
(
)
;
nsDisplayMasksAndClipPathsGeometry
:
:
UpdateDrawResult
(
this
imgParams
.
result
)
;
}
void
nsDisplayMasksAndClipPaths
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
if
(
!
IsValidMask
(
)
)
{
return
;
}
PaintWithContentsPaintCallback
(
aBuilder
aCtx
[
&
]
{
GetChildren
(
)
-
>
Paint
(
aBuilder
aCtx
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
}
)
;
}
static
Maybe
<
wr
:
:
WrClipId
>
CreateSimpleClipRegion
(
const
nsDisplayMasksAndClipPaths
&
aDisplayItem
wr
:
:
DisplayListBuilder
&
aBuilder
)
{
nsIFrame
*
frame
=
aDisplayItem
.
Frame
(
)
;
const
auto
*
style
=
frame
-
>
StyleSVGReset
(
)
;
MOZ_ASSERT
(
style
-
>
HasClipPath
(
)
|
|
style
-
>
HasMask
(
)
)
;
if
(
!
SVGIntegrationUtils
:
:
UsingSimpleClipPathForFrame
(
frame
)
)
{
return
Nothing
(
)
;
}
const
auto
&
clipPath
=
style
-
>
mClipPath
;
const
auto
&
shape
=
*
clipPath
.
AsShape
(
)
.
_0
;
auto
appUnitsPerDevPixel
=
frame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
const
nsRect
refBox
=
nsLayoutUtils
:
:
ComputeGeometryBox
(
frame
clipPath
.
AsShape
(
)
.
_1
)
;
wr
:
:
WrClipId
clipId
{
}
;
switch
(
shape
.
tag
)
{
case
StyleBasicShape
:
:
Tag
:
:
Inset
:
{
const
nsRect
insetRect
=
ShapeUtils
:
:
ComputeInsetRect
(
shape
refBox
)
+
aDisplayItem
.
ToReferenceFrame
(
)
;
nscoord
radii
[
8
]
=
{
0
}
;
if
(
ShapeUtils
:
:
ComputeInsetRadii
(
shape
refBox
radii
)
)
{
clipId
=
aBuilder
.
DefineRoundedRectClip
(
Nothing
(
)
wr
:
:
ToComplexClipRegion
(
insetRect
radii
appUnitsPerDevPixel
)
)
;
}
else
{
clipId
=
aBuilder
.
DefineRectClip
(
Nothing
(
)
wr
:
:
ToLayoutRect
(
LayoutDeviceRect
:
:
FromAppUnits
(
insetRect
appUnitsPerDevPixel
)
)
)
;
}
break
;
}
case
StyleBasicShape
:
:
Tag
:
:
Ellipse
:
case
StyleBasicShape
:
:
Tag
:
:
Circle
:
{
nsPoint
center
=
ShapeUtils
:
:
ComputeCircleOrEllipseCenter
(
shape
refBox
)
;
nsSize
radii
;
if
(
shape
.
IsEllipse
(
)
)
{
radii
=
ShapeUtils
:
:
ComputeEllipseRadii
(
shape
center
refBox
)
;
}
else
{
nscoord
radius
=
ShapeUtils
:
:
ComputeCircleRadius
(
shape
center
refBox
)
;
radii
=
{
radius
radius
}
;
}
nsRect
ellipseRect
(
aDisplayItem
.
ToReferenceFrame
(
)
+
center
-
nsPoint
(
radii
.
width
radii
.
height
)
radii
*
2
)
;
nscoord
ellipseRadii
[
8
]
;
for
(
const
auto
corner
:
AllPhysicalHalfCorners
(
)
)
{
ellipseRadii
[
corner
]
=
HalfCornerIsX
(
corner
)
?
radii
.
width
:
radii
.
height
;
}
clipId
=
aBuilder
.
DefineRoundedRectClip
(
Nothing
(
)
wr
:
:
ToComplexClipRegion
(
ellipseRect
ellipseRadii
appUnitsPerDevPixel
)
)
;
break
;
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unhandled
shape
id
?
"
)
;
return
Nothing
(
)
;
}
return
Some
(
clipId
)
;
}
static
void
FillPolygonDataForDisplayItem
(
const
nsDisplayMasksAndClipPaths
&
aDisplayItem
nsTArray
<
wr
:
:
LayoutPoint
>
&
aPoints
wr
:
:
FillRule
&
aFillRule
)
{
nsIFrame
*
frame
=
aDisplayItem
.
Frame
(
)
;
const
auto
*
style
=
frame
-
>
StyleSVGReset
(
)
;
bool
isPolygon
=
style
-
>
HasClipPath
(
)
&
&
style
-
>
mClipPath
.
IsShape
(
)
&
&
style
-
>
mClipPath
.
AsShape
(
)
.
_0
-
>
IsPolygon
(
)
;
if
(
!
isPolygon
)
{
return
;
}
const
auto
&
clipPath
=
style
-
>
mClipPath
;
const
auto
&
shape
=
*
clipPath
.
AsShape
(
)
.
_0
;
const
nsRect
refBox
=
nsLayoutUtils
:
:
ComputeGeometryBox
(
frame
clipPath
.
AsShape
(
)
.
_1
)
;
nsTArray
<
nsPoint
>
vertices
=
ShapeUtils
:
:
ComputePolygonVertices
(
shape
refBox
)
;
if
(
vertices
.
Length
(
)
>
wr
:
:
POLYGON_CLIP_VERTEX_MAX
)
{
return
;
}
auto
appUnitsPerDevPixel
=
frame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
for
(
size_t
i
=
0
;
i
<
vertices
.
Length
(
)
;
+
+
i
)
{
wr
:
:
LayoutPoint
point
=
wr
:
:
ToLayoutPoint
(
LayoutDevicePoint
:
:
FromAppUnits
(
vertices
[
i
]
appUnitsPerDevPixel
)
)
;
aPoints
.
AppendElement
(
point
)
;
}
aFillRule
=
(
shape
.
AsPolygon
(
)
.
fill
=
=
StyleFillRule
:
:
Nonzero
)
?
wr
:
:
FillRule
:
:
Nonzero
:
wr
:
:
FillRule
:
:
Evenodd
;
}
static
Maybe
<
wr
:
:
WrClipId
>
CreateWRClipPathAndMasks
(
nsDisplayMasksAndClipPaths
*
aDisplayItem
const
LayoutDeviceRect
&
aBounds
wr
:
:
IpcResourceUpdateQueue
&
aResources
wr
:
:
DisplayListBuilder
&
aBuilder
const
StackingContextHelper
&
aSc
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
if
(
auto
clip
=
CreateSimpleClipRegion
(
*
aDisplayItem
aBuilder
)
)
{
return
clip
;
}
Maybe
<
wr
:
:
ImageMask
>
mask
=
aManager
-
>
CommandBuilder
(
)
.
BuildWrMaskImage
(
aDisplayItem
aBuilder
aResources
aSc
aDisplayListBuilder
aBounds
)
;
if
(
!
mask
)
{
return
Nothing
(
)
;
}
nsTArray
<
wr
:
:
LayoutPoint
>
points
;
wr
:
:
FillRule
fillRule
=
wr
:
:
FillRule
:
:
Nonzero
;
FillPolygonDataForDisplayItem
(
*
aDisplayItem
points
fillRule
)
;
wr
:
:
WrClipId
clipId
=
aBuilder
.
DefineImageMaskClip
(
mask
.
ref
(
)
points
fillRule
)
;
return
Some
(
clipId
)
;
}
bool
nsDisplayMasksAndClipPaths
:
:
CreateWebRenderCommands
(
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
bool
snap
;
auto
appUnitsPerDevPixel
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
nsRect
displayBounds
=
GetBounds
(
aDisplayListBuilder
&
snap
)
;
LayoutDeviceRect
bounds
=
LayoutDeviceRect
:
:
FromAppUnits
(
displayBounds
appUnitsPerDevPixel
)
;
Maybe
<
wr
:
:
WrClipId
>
clip
=
CreateWRClipPathAndMasks
(
this
bounds
aResources
aBuilder
aSc
aManager
aDisplayListBuilder
)
;
float
oldOpacity
=
aBuilder
.
GetInheritedOpacity
(
)
;
Maybe
<
StackingContextHelper
>
layer
;
const
StackingContextHelper
*
sc
=
&
aSc
;
if
(
clip
)
{
bounds
.
MoveTo
(
0
0
)
;
Maybe
<
float
>
opacity
=
(
SVGIntegrationUtils
:
:
UsingSimpleClipPathForFrame
(
mFrame
)
&
&
aBuilder
.
GetInheritedOpacity
(
)
!
=
1
.
0f
)
?
Some
(
aBuilder
.
GetInheritedOpacity
(
)
)
:
Nothing
(
)
;
wr
:
:
StackingContextParams
params
;
params
.
clip
=
wr
:
:
WrStackingContextClip
:
:
ClipId
(
*
clip
)
;
params
.
opacity
=
opacity
.
ptrOr
(
nullptr
)
;
layer
.
emplace
(
aSc
GetActiveScrolledRoot
(
)
mFrame
this
aBuilder
params
bounds
)
;
sc
=
layer
.
ptr
(
)
;
}
aBuilder
.
SetInheritedOpacity
(
1
.
0f
)
;
nsDisplayEffectsBase
:
:
CreateWebRenderCommands
(
aBuilder
aResources
*
sc
aManager
aDisplayListBuilder
)
;
aBuilder
.
SetInheritedOpacity
(
oldOpacity
)
;
return
true
;
}
Maybe
<
nsRect
>
nsDisplayMasksAndClipPaths
:
:
GetClipWithRespectToASR
(
nsDisplayListBuilder
*
aBuilder
const
ActiveScrolledRoot
*
aASR
)
const
{
if
(
const
DisplayItemClip
*
clip
=
DisplayItemClipChain
:
:
ClipForASR
(
GetClipChain
(
)
aASR
)
)
{
return
Some
(
clip
-
>
GetClipRect
(
)
)
;
}
nsDisplayList
*
childList
=
GetSameCoordinateSystemChildren
(
)
;
if
(
childList
)
{
return
Some
(
childList
-
>
GetClippedBoundsWithRespectToASR
(
aBuilder
aASR
)
)
;
}
#
ifdef
DEBUG
MOZ_ASSERT
(
false
"
item
should
have
finite
clip
with
respect
to
aASR
"
)
;
#
endif
return
Nothing
(
)
;
}
#
ifdef
MOZ_DUMP_PAINTING
void
nsDisplayMasksAndClipPaths
:
:
PrintEffects
(
nsACString
&
aTo
)
{
nsIFrame
*
firstFrame
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
mFrame
)
;
bool
first
=
true
;
aTo
+
=
"
effects
=
(
"
;
SVGClipPathFrame
*
clipPathFrame
;
SVGObserverUtils
:
:
GetAndObserveClipPath
(
firstFrame
&
clipPathFrame
)
;
if
(
clipPathFrame
)
{
if
(
!
first
)
{
aTo
+
=
"
"
;
}
aTo
+
=
nsPrintfCString
(
"
clip
(
%
s
)
"
clipPathFrame
-
>
IsTrivial
(
)
?
"
trivial
"
:
"
non
-
trivial
"
)
;
first
=
false
;
}
else
if
(
mFrame
-
>
StyleSVGReset
(
)
-
>
HasClipPath
(
)
)
{
if
(
!
first
)
{
aTo
+
=
"
"
;
}
aTo
+
=
"
clip
(
basic
-
shape
)
"
;
first
=
false
;
}
nsTArray
<
SVGMaskFrame
*
>
masks
;
SVGObserverUtils
:
:
GetAndObserveMasks
(
firstFrame
&
masks
)
;
if
(
!
masks
.
IsEmpty
(
)
&
&
masks
[
0
]
)
{
if
(
!
first
)
{
aTo
+
=
"
"
;
}
aTo
+
=
"
mask
"
;
}
aTo
+
=
"
)
"
;
}
#
endif
void
nsDisplayBackdropRootContainer
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
aCtx
-
>
GetDrawTarget
(
)
-
>
PushLayer
(
false
1
.
0
nullptr
gfx
:
:
Matrix
(
)
)
;
GetChildren
(
)
-
>
Paint
(
aBuilder
aCtx
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
aCtx
-
>
GetDrawTarget
(
)
-
>
PopLayer
(
)
;
}
bool
nsDisplayBackdropRootContainer
:
:
CreateWebRenderCommands
(
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
wr
:
:
StackingContextParams
params
;
params
.
flags
|
=
wr
:
:
StackingContextFlags
:
:
IS_BACKDROP_ROOT
;
params
.
clip
=
wr
:
:
WrStackingContextClip
:
:
ClipChain
(
aBuilder
.
CurrentClipChainId
(
)
)
;
StackingContextHelper
sc
(
aSc
GetActiveScrolledRoot
(
)
mFrame
this
aBuilder
params
)
;
nsDisplayWrapList
:
:
CreateWebRenderCommands
(
aBuilder
aResources
sc
aManager
aDisplayListBuilder
)
;
return
true
;
}
bool
nsDisplayBackdropFilters
:
:
CanCreateWebRenderCommands
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
{
return
SVGIntegrationUtils
:
:
CanCreateWebRenderFiltersForFrame
(
aFrame
)
;
}
bool
nsDisplayBackdropFilters
:
:
CreateWebRenderCommands
(
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
WrFiltersHolder
wrFilters
;
Maybe
<
nsRect
>
filterClip
;
auto
filterChain
=
mFrame
-
>
StyleEffects
(
)
-
>
mBackdropFilters
.
AsSpan
(
)
;
if
(
!
SVGIntegrationUtils
:
:
CreateWebRenderCSSFilters
(
filterChain
mFrame
wrFilters
)
&
&
!
SVGIntegrationUtils
:
:
BuildWebRenderFilters
(
mFrame
filterChain
wrFilters
filterClip
)
)
{
return
false
;
}
nsCSSRendering
:
:
ImageLayerClipState
clip
;
nsCSSRendering
:
:
GetImageLayerClip
(
mFrame
-
>
StyleBackground
(
)
-
>
BottomLayer
(
)
mFrame
*
mFrame
-
>
StyleBorder
(
)
mBackdropRect
mBackdropRect
false
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
&
clip
)
;
LayoutDeviceRect
bounds
=
LayoutDeviceRect
:
:
FromAppUnits
(
mBackdropRect
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
wr
:
:
ComplexClipRegion
region
=
wr
:
:
ToComplexClipRegion
(
clip
.
mBGClipArea
clip
.
mRadii
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
aBuilder
.
PushBackdropFilter
(
wr
:
:
ToLayoutRect
(
bounds
)
region
wrFilters
.
filters
wrFilters
.
filter_datas
!
BackfaceIsHidden
(
)
)
;
wr
:
:
StackingContextParams
params
;
params
.
clip
=
wr
:
:
WrStackingContextClip
:
:
ClipChain
(
aBuilder
.
CurrentClipChainId
(
)
)
;
StackingContextHelper
sc
(
aSc
GetActiveScrolledRoot
(
)
mFrame
this
aBuilder
params
)
;
nsDisplayWrapList
:
:
CreateWebRenderCommands
(
aBuilder
aResources
sc
aManager
aDisplayListBuilder
)
;
return
true
;
}
void
nsDisplayBackdropFilters
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
GetChildren
(
)
-
>
Paint
(
aBuilder
aCtx
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
}
nsDisplayFilters
:
:
nsDisplayFilters
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
)
:
nsDisplayEffectsBase
(
aBuilder
aFrame
aList
)
mEffectsBounds
(
aFrame
-
>
InkOverflowRectRelativeToSelf
(
)
)
{
MOZ_COUNT_CTOR
(
nsDisplayFilters
)
;
mVisibleRect
=
aBuilder
-
>
GetVisibleRect
(
)
+
aBuilder
-
>
GetCurrentFrameOffsetToReferenceFrame
(
)
;
}
void
nsDisplayFilters
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
PaintWithContentsPaintCallback
(
aBuilder
aCtx
[
&
]
(
gfxContext
*
aContext
)
{
GetChildren
(
)
-
>
Paint
(
aBuilder
aContext
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
}
)
;
}
void
nsDisplayFilters
:
:
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
{
nsDisplayEffectsBase
:
:
ComputeInvalidationRegion
(
aBuilder
aGeometry
aInvalidRegion
)
;
const
auto
*
geometry
=
static_cast
<
const
nsDisplayFiltersGeometry
*
>
(
aGeometry
)
;
if
(
aBuilder
-
>
ShouldSyncDecodeImages
(
)
&
&
geometry
-
>
ShouldInvalidateToSyncDecodeImages
(
)
)
{
bool
snap
;
nsRect
bounds
=
GetBounds
(
aBuilder
&
snap
)
;
aInvalidRegion
-
>
Or
(
*
aInvalidRegion
bounds
)
;
}
}
void
nsDisplayFilters
:
:
PaintWithContentsPaintCallback
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
const
std
:
:
function
<
void
(
gfxContext
*
aContext
)
>
&
aPaintChildren
)
{
imgDrawingParams
imgParams
(
aBuilder
-
>
GetImageDecodeFlags
(
)
)
;
nsRect
borderArea
=
nsRect
(
ToReferenceFrame
(
)
mFrame
-
>
GetSize
(
)
)
;
SVGIntegrationUtils
:
:
PaintFramesParams
params
(
*
aCtx
mFrame
mVisibleRect
borderArea
aBuilder
false
imgParams
)
;
gfxPoint
userSpaceToFrameSpaceOffset
=
SVGIntegrationUtils
:
:
GetOffsetToUserSpaceInDevPx
(
mFrame
params
)
;
SVGIntegrationUtils
:
:
PaintFilter
(
params
[
&
]
(
gfxContext
&
aContext
nsIFrame
*
aTarget
const
gfxMatrix
&
aTransform
const
nsIntRect
*
aDirtyRect
imgDrawingParams
&
aImgParams
)
{
gfxContextMatrixAutoSaveRestore
autoSR
(
&
aContext
)
;
aContext
.
SetMatrixDouble
(
aContext
.
CurrentMatrixDouble
(
)
.
PreTranslate
(
-
userSpaceToFrameSpaceOffset
)
)
;
aPaintChildren
(
&
aContext
)
;
}
)
;
nsDisplayFiltersGeometry
:
:
UpdateDrawResult
(
this
imgParams
.
result
)
;
}
bool
nsDisplayFilters
:
:
CanCreateWebRenderCommands
(
)
const
{
return
SVGIntegrationUtils
:
:
CanCreateWebRenderFiltersForFrame
(
mFrame
)
;
}
bool
nsDisplayFilters
:
:
CreateWebRenderCommands
(
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
float
auPerDevPixel
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
WrFiltersHolder
wrFilters
;
Maybe
<
nsRect
>
filterClip
;
auto
filterChain
=
mFrame
-
>
StyleEffects
(
)
-
>
mFilters
.
AsSpan
(
)
;
if
(
!
SVGIntegrationUtils
:
:
CreateWebRenderCSSFilters
(
filterChain
mFrame
wrFilters
)
&
&
!
SVGIntegrationUtils
:
:
BuildWebRenderFilters
(
mFrame
filterChain
wrFilters
filterClip
)
)
{
return
false
;
}
wr
:
:
WrStackingContextClip
clip
{
}
;
if
(
filterClip
)
{
auto
devPxRect
=
LayoutDeviceRect
:
:
FromAppUnits
(
filterClip
.
value
(
)
+
ToReferenceFrame
(
)
auPerDevPixel
)
;
wr
:
:
WrClipId
clipId
=
aBuilder
.
DefineRectClip
(
Nothing
(
)
wr
:
:
ToLayoutRect
(
devPxRect
)
)
;
clip
=
wr
:
:
WrStackingContextClip
:
:
ClipId
(
clipId
)
;
}
else
{
clip
=
wr
:
:
WrStackingContextClip
:
:
ClipChain
(
aBuilder
.
CurrentClipChainId
(
)
)
;
}
float
opacity
=
aBuilder
.
GetInheritedOpacity
(
)
;
aBuilder
.
SetInheritedOpacity
(
1
.
0f
)
;
wr
:
:
StackingContextParams
params
;
params
.
mFilters
=
std
:
:
move
(
wrFilters
.
filters
)
;
params
.
mFilterDatas
=
std
:
:
move
(
wrFilters
.
filter_datas
)
;
params
.
opacity
=
opacity
!
=
1
.
0f
?
&
opacity
:
nullptr
;
params
.
clip
=
clip
;
StackingContextHelper
sc
(
aSc
GetActiveScrolledRoot
(
)
mFrame
this
aBuilder
params
)
;
nsDisplayEffectsBase
:
:
CreateWebRenderCommands
(
aBuilder
aResources
sc
aManager
aDisplayListBuilder
)
;
aBuilder
.
SetInheritedOpacity
(
opacity
)
;
return
true
;
}
#
ifdef
MOZ_DUMP_PAINTING
void
nsDisplayFilters
:
:
PrintEffects
(
nsACString
&
aTo
)
{
nsIFrame
*
firstFrame
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
mFrame
)
;
bool
first
=
true
;
aTo
+
=
"
effects
=
(
"
;
if
(
SVGObserverUtils
:
:
GetAndObserveFilters
(
firstFrame
nullptr
)
!
=
SVGObserverUtils
:
:
eHasRefsSomeInvalid
)
{
if
(
!
first
)
{
aTo
+
=
"
"
;
}
aTo
+
=
"
filter
"
;
}
aTo
+
=
"
)
"
;
}
#
endif
nsDisplaySVGWrapper
:
:
nsDisplaySVGWrapper
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
)
:
nsDisplayWrapList
(
aBuilder
aFrame
aList
)
{
MOZ_COUNT_CTOR
(
nsDisplaySVGWrapper
)
;
}
bool
nsDisplaySVGWrapper
:
:
ShouldFlattenAway
(
nsDisplayListBuilder
*
aBuilder
)
{
return
!
aBuilder
-
>
GetWidgetLayerManager
(
)
;
}
bool
nsDisplaySVGWrapper
:
:
CreateWebRenderCommands
(
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
return
nsDisplayWrapList
:
:
CreateWebRenderCommands
(
aBuilder
aResources
aSc
aManager
aDisplayListBuilder
)
;
}
nsDisplayForeignObject
:
:
nsDisplayForeignObject
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
)
:
nsDisplayWrapList
(
aBuilder
aFrame
aList
)
{
MOZ_COUNT_CTOR
(
nsDisplayForeignObject
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
nsDisplayForeignObject
:
:
~
nsDisplayForeignObject
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayForeignObject
)
;
}
#
endif
bool
nsDisplayForeignObject
:
:
ShouldFlattenAway
(
nsDisplayListBuilder
*
aBuilder
)
{
return
!
aBuilder
-
>
GetWidgetLayerManager
(
)
;
}
bool
nsDisplayForeignObject
:
:
CreateWebRenderCommands
(
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
AutoRestore
<
bool
>
restoreDoGrouping
(
aManager
-
>
CommandBuilder
(
)
.
mDoGrouping
)
;
aManager
-
>
CommandBuilder
(
)
.
mDoGrouping
=
false
;
return
nsDisplayWrapList
:
:
CreateWebRenderCommands
(
aBuilder
aResources
aSc
aManager
aDisplayListBuilder
)
;
}
void
nsDisplayLink
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
auto
appPerDev
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
aCtx
-
>
GetDrawTarget
(
)
-
>
Link
(
mLinkSpec
.
get
(
)
NSRectToRect
(
GetPaintRect
(
aBuilder
aCtx
)
appPerDev
)
)
;
}
void
nsDisplayDestination
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
auto
appPerDev
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
aCtx
-
>
GetDrawTarget
(
)
-
>
Destination
(
mDestinationName
.
get
(
)
NSPointToPoint
(
GetPaintRect
(
aBuilder
aCtx
)
.
TopLeft
(
)
appPerDev
)
)
;
}
void
nsDisplayListCollection
:
:
SerializeWithCorrectZOrder
(
nsDisplayList
*
aOutResultList
nsIContent
*
aContent
)
{
PositionedDescendants
(
)
-
>
SortByZOrder
(
)
;
aOutResultList
-
>
AppendToTop
(
BorderBackground
(
)
)
;
for
(
;
;
)
{
nsDisplayItem
*
item
=
PositionedDescendants
(
)
-
>
GetBottom
(
)
;
if
(
item
&
&
item
-
>
ZIndex
(
)
<
0
)
{
PositionedDescendants
(
)
-
>
RemoveBottom
(
)
;
aOutResultList
-
>
AppendToTop
(
item
)
;
continue
;
}
break
;
}
aOutResultList
-
>
AppendToTop
(
BlockBorderBackgrounds
(
)
)
;
aOutResultList
-
>
AppendToTop
(
Floats
(
)
)
;
aOutResultList
-
>
AppendToTop
(
Content
(
)
)
;
if
(
aContent
)
{
Outlines
(
)
-
>
SortByContentOrder
(
aContent
)
;
}
aOutResultList
-
>
AppendToTop
(
Outlines
(
)
)
;
aOutResultList
-
>
AppendToTop
(
PositionedDescendants
(
)
)
;
}
uint32_t
PaintTelemetry
:
:
sPaintLevel
=
0
;
PaintTelemetry
:
:
AutoRecordPaint
:
:
AutoRecordPaint
(
)
{
if
(
sPaintLevel
+
+
>
0
)
{
return
;
}
mStart
=
TimeStamp
:
:
Now
(
)
;
}
PaintTelemetry
:
:
AutoRecordPaint
:
:
~
AutoRecordPaint
(
)
{
MOZ_ASSERT
(
sPaintLevel
!
=
0
)
;
if
(
-
-
sPaintLevel
>
0
)
{
return
;
}
if
(
gfxVars
:
:
BrowserTabsRemoteAutostart
(
)
&
&
XRE_IsParentProcess
(
)
)
{
return
;
}
double
totalMs
=
(
TimeStamp
:
:
Now
(
)
-
mStart
)
.
ToMilliseconds
(
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
CONTENT_PAINT_TIME
static_cast
<
uint32_t
>
(
totalMs
)
)
;
}
static
nsIFrame
*
GetSelfOrPlaceholderFor
(
nsIFrame
*
aFrame
)
{
if
(
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_IS_PUSHED_FLOAT
)
)
{
return
aFrame
;
}
if
(
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
&
&
!
aFrame
-
>
GetPrevInFlow
(
)
)
{
return
aFrame
-
>
GetPlaceholderFrame
(
)
;
}
return
aFrame
;
}
static
nsIFrame
*
GetAncestorFor
(
nsIFrame
*
aFrame
)
{
nsIFrame
*
f
=
GetSelfOrPlaceholderFor
(
aFrame
)
;
MOZ_ASSERT
(
f
)
;
return
nsLayoutUtils
:
:
GetCrossDocParentFrameInProcess
(
f
)
;
}
nsDisplayListBuilder
:
:
AutoBuildingDisplayList
:
:
AutoBuildingDisplayList
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aForChild
const
nsRect
&
aVisibleRect
const
nsRect
&
aDirtyRect
const
bool
aIsTransformed
)
:
mBuilder
(
aBuilder
)
mPrevFrame
(
aBuilder
-
>
mCurrentFrame
)
mPrevReferenceFrame
(
aBuilder
-
>
mCurrentReferenceFrame
)
mPrevOffset
(
aBuilder
-
>
mCurrentOffsetToReferenceFrame
)
mPrevAdditionalOffset
(
aBuilder
-
>
mAdditionalOffset
)
mPrevVisibleRect
(
aBuilder
-
>
mVisibleRect
)
mPrevDirtyRect
(
aBuilder
-
>
mDirtyRect
)
mPrevCompositorHitTestInfo
(
aBuilder
-
>
mCompositorHitTestInfo
)
mPrevAncestorHasApzAwareEventHandler
(
aBuilder
-
>
mAncestorHasApzAwareEventHandler
)
mPrevBuildingInvisibleItems
(
aBuilder
-
>
mBuildingInvisibleItems
)
mPrevInInvalidSubtree
(
aBuilder
-
>
mInInvalidSubtree
)
{
if
(
aIsTransformed
)
{
aBuilder
-
>
mCurrentOffsetToReferenceFrame
=
aBuilder
-
>
AdditionalOffset
(
)
.
refOr
(
nsPoint
(
)
)
;
aBuilder
-
>
mCurrentReferenceFrame
=
aForChild
;
}
else
if
(
aBuilder
-
>
mCurrentFrame
=
=
aForChild
-
>
GetParent
(
)
)
{
aBuilder
-
>
mCurrentOffsetToReferenceFrame
+
=
aForChild
-
>
GetPosition
(
)
;
}
else
{
aBuilder
-
>
mCurrentReferenceFrame
=
aBuilder
-
>
FindReferenceFrameFor
(
aForChild
&
aBuilder
-
>
mCurrentOffsetToReferenceFrame
)
;
}
if
(
aForChild
=
=
mPrevFrame
|
|
GetAncestorFor
(
aForChild
)
=
=
mPrevFrame
)
{
aBuilder
-
>
mInInvalidSubtree
=
aBuilder
-
>
mInInvalidSubtree
|
|
aForChild
-
>
IsFrameModified
(
)
;
}
else
{
aBuilder
-
>
mInInvalidSubtree
=
AnyContentAncestorModified
(
aForChild
)
;
}
aBuilder
-
>
mCurrentFrame
=
aForChild
;
aBuilder
-
>
mVisibleRect
=
aVisibleRect
;
aBuilder
-
>
mDirtyRect
=
aBuilder
-
>
mInInvalidSubtree
?
aVisibleRect
:
aDirtyRect
;
}
}
