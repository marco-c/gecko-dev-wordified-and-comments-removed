#
include
"
RetainedDisplayListBuilder
.
h
"
#
include
"
DisplayListChecker
.
h
"
#
include
"
nsPlaceholderFrame
.
h
"
#
include
"
nsSubDocumentFrame
.
h
"
#
include
"
nsViewManager
.
h
"
using
namespace
mozilla
;
void
MarkFramesWithItemsAndImagesModified
(
nsDisplayList
*
aList
)
{
for
(
nsDisplayItem
*
i
=
aList
-
>
GetBottom
(
)
;
i
!
=
nullptr
;
i
=
i
-
>
GetAbove
(
)
)
{
if
(
!
i
-
>
HasDeletedFrame
(
)
&
&
i
-
>
CanBeReused
(
)
&
&
!
i
-
>
Frame
(
)
-
>
IsFrameModified
(
)
)
{
DisplayItemData
*
data
=
FrameLayerBuilder
:
:
GetOldDataFor
(
i
)
;
bool
invalidate
=
false
;
if
(
data
&
&
data
-
>
GetGeometry
(
)
)
{
invalidate
=
data
-
>
GetGeometry
(
)
-
>
InvalidateForSyncDecodeImages
(
)
;
}
else
if
(
!
(
i
-
>
GetFlags
(
)
&
TYPE_RENDERS_NO_IMAGES
)
)
{
invalidate
=
true
;
}
if
(
invalidate
)
{
i
-
>
FrameForInvalidation
(
)
-
>
MarkNeedsDisplayItemRebuild
(
)
;
if
(
i
-
>
GetDependentFrame
(
)
)
{
i
-
>
GetDependentFrame
(
)
-
>
MarkNeedsDisplayItemRebuild
(
)
;
}
}
}
if
(
i
-
>
GetChildren
(
)
)
{
MarkFramesWithItemsAndImagesModified
(
i
-
>
GetChildren
(
)
)
;
}
}
}
bool
IsAnyAncestorModified
(
nsIFrame
*
aFrame
)
{
nsIFrame
*
f
=
aFrame
;
while
(
f
)
{
if
(
f
-
>
IsFrameModified
(
)
)
{
return
true
;
}
f
=
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
f
)
;
}
return
false
;
}
static
AnimatedGeometryRoot
*
SelectAGRForFrame
(
nsIFrame
*
aFrame
AnimatedGeometryRoot
*
aParentAGR
)
{
if
(
!
aFrame
-
>
IsStackingContext
(
)
)
{
return
aParentAGR
;
}
if
(
!
aFrame
-
>
HasOverrideDirtyRegion
(
)
)
{
return
nullptr
;
}
nsDisplayListBuilder
:
:
DisplayListBuildingData
*
data
=
aFrame
-
>
GetProperty
(
nsDisplayListBuilder
:
:
DisplayListBuildingRect
(
)
)
;
return
data
&
&
data
-
>
mModifiedAGR
?
data
-
>
mModifiedAGR
.
get
(
)
:
nullptr
;
}
bool
RetainedDisplayListBuilder
:
:
PreProcessDisplayList
(
nsDisplayList
*
aList
AnimatedGeometryRoot
*
aAGR
)
{
bool
modified
=
false
;
nsDisplayList
saved
;
while
(
nsDisplayItem
*
i
=
aList
-
>
RemoveBottom
(
)
)
{
if
(
i
-
>
HasDeletedFrame
(
)
|
|
!
i
-
>
CanBeReused
(
)
)
{
i
-
>
Destroy
(
&
mBuilder
)
;
modified
=
true
;
continue
;
}
nsIFrame
*
f
=
i
-
>
Frame
(
)
;
if
(
i
-
>
GetChildren
(
)
)
{
if
(
PreProcessDisplayList
(
i
-
>
GetChildren
(
)
SelectAGRForFrame
(
f
aAGR
)
)
)
{
modified
=
true
;
}
}
if
(
aAGR
&
&
i
-
>
GetAnimatedGeometryRoot
(
)
-
>
GetAsyncAGR
(
)
!
=
aAGR
)
{
mBuilder
.
MarkFrameForDisplayIfVisible
(
f
mBuilder
.
RootReferenceFrame
(
)
)
;
modified
=
true
;
}
i
-
>
RestoreState
(
)
;
saved
.
AppendToTop
(
i
)
;
}
aList
-
>
AppendToTop
(
&
saved
)
;
aList
-
>
RestoreState
(
)
;
return
modified
;
}
bool
IsSameItem
(
nsDisplayItem
*
aFirst
nsDisplayItem
*
aSecond
)
{
return
aFirst
-
>
Frame
(
)
=
=
aSecond
-
>
Frame
(
)
&
&
aFirst
-
>
GetPerFrameKey
(
)
=
=
aSecond
-
>
GetPerFrameKey
(
)
;
}
struct
DisplayItemKey
{
bool
operator
=
=
(
const
DisplayItemKey
&
aOther
)
const
{
return
mFrame
=
=
aOther
.
mFrame
&
&
mPerFrameKey
=
=
aOther
.
mPerFrameKey
;
}
nsIFrame
*
mFrame
;
uint32_t
mPerFrameKey
;
}
;
class
DisplayItemHashEntry
:
public
PLDHashEntryHdr
{
public
:
typedef
DisplayItemKey
KeyType
;
typedef
const
DisplayItemKey
*
KeyTypePointer
;
explicit
DisplayItemHashEntry
(
KeyTypePointer
aKey
)
:
mKey
(
*
aKey
)
{
}
explicit
DisplayItemHashEntry
(
const
DisplayItemHashEntry
&
aCopy
)
=
default
;
~
DisplayItemHashEntry
(
)
=
default
;
KeyType
GetKey
(
)
const
{
return
mKey
;
}
bool
KeyEquals
(
KeyTypePointer
aKey
)
const
{
return
mKey
=
=
*
aKey
;
}
static
KeyTypePointer
KeyToPointer
(
KeyType
&
aKey
)
{
return
&
aKey
;
}
static
PLDHashNumber
HashKey
(
KeyTypePointer
aKey
)
{
if
(
!
aKey
)
return
0
;
return
mozilla
:
:
HashGeneric
(
aKey
-
>
mFrame
aKey
-
>
mPerFrameKey
)
;
}
enum
{
ALLOW_MEMMOVE
=
true
}
;
DisplayItemKey
mKey
;
}
;
template
<
typename
T
>
void
SwapAndRemove
(
nsTArray
<
T
>
&
aArray
uint32_t
aIndex
)
{
if
(
aIndex
!
=
(
aArray
.
Length
(
)
-
1
)
)
{
T
last
=
aArray
.
LastElement
(
)
;
aArray
.
LastElement
(
)
=
aArray
[
aIndex
]
;
aArray
[
aIndex
]
=
last
;
}
aArray
.
RemoveElementAt
(
aArray
.
Length
(
)
-
1
)
;
}
static
bool
MergeFrameRects
(
nsDisplayLayerEventRegions
*
aOldItem
nsDisplayLayerEventRegions
*
aNewItem
nsDisplayLayerEventRegions
:
:
FrameRects
nsDisplayLayerEventRegions
:
:
*
aRectList
nsTArray
<
nsIFrame
*
>
&
aAddedFrames
)
{
bool
modified
=
false
;
nsDisplayLayerEventRegions
:
:
FrameRects
&
oldRects
=
aOldItem
-
>
*
aRectList
;
uint32_t
i
=
0
;
while
(
i
<
oldRects
.
mFrames
.
Length
(
)
)
{
nsIFrame
*
f
=
oldRects
.
mFrames
[
i
]
;
if
(
IsAnyAncestorModified
(
f
)
)
{
MOZ_ASSERT
(
f
!
=
aOldItem
-
>
Frame
(
)
)
;
f
-
>
RemoveDisplayItem
(
aOldItem
)
;
SwapAndRemove
(
oldRects
.
mFrames
i
)
;
SwapAndRemove
(
oldRects
.
mBoxes
i
)
;
modified
=
true
;
}
else
{
i
+
+
;
}
}
if
(
!
aNewItem
)
{
return
modified
;
}
nsDisplayItem
*
destItem
=
aOldItem
;
nsDisplayLayerEventRegions
:
:
FrameRects
*
destRects
=
&
(
aOldItem
-
>
*
aRectList
)
;
nsDisplayLayerEventRegions
:
:
FrameRects
*
srcRects
=
&
(
aNewItem
-
>
*
aRectList
)
;
for
(
uint32_t
i
=
0
;
i
<
srcRects
-
>
mFrames
.
Length
(
)
;
i
+
+
)
{
nsIFrame
*
f
=
srcRects
-
>
mFrames
[
i
]
;
if
(
!
f
-
>
HasDisplayItem
(
destItem
)
)
{
destRects
-
>
Add
(
f
srcRects
-
>
mBoxes
[
i
]
)
;
aAddedFrames
.
AppendElement
(
f
)
;
MOZ_ASSERT
(
f
!
=
aOldItem
-
>
Frame
(
)
)
;
modified
=
true
;
}
}
return
modified
;
}
bool
MergeLayerEventRegions
(
nsDisplayItem
*
aOldItem
nsDisplayItem
*
aNewItem
)
{
nsDisplayLayerEventRegions
*
oldItem
=
static_cast
<
nsDisplayLayerEventRegions
*
>
(
aOldItem
)
;
nsDisplayLayerEventRegions
*
newItem
=
static_cast
<
nsDisplayLayerEventRegions
*
>
(
aNewItem
)
;
nsTArray
<
nsIFrame
*
>
addedFrames
;
bool
modified
=
false
;
modified
|
=
MergeFrameRects
(
oldItem
newItem
&
nsDisplayLayerEventRegions
:
:
mHitRegion
addedFrames
)
;
modified
|
=
MergeFrameRects
(
oldItem
newItem
&
nsDisplayLayerEventRegions
:
:
mMaybeHitRegion
addedFrames
)
;
modified
|
=
MergeFrameRects
(
oldItem
newItem
&
nsDisplayLayerEventRegions
:
:
mDispatchToContentHitRegion
addedFrames
)
;
modified
|
=
MergeFrameRects
(
oldItem
newItem
&
nsDisplayLayerEventRegions
:
:
mNoActionRegion
addedFrames
)
;
modified
|
=
MergeFrameRects
(
oldItem
newItem
&
nsDisplayLayerEventRegions
:
:
mHorizontalPanRegion
addedFrames
)
;
modified
|
=
MergeFrameRects
(
oldItem
newItem
&
nsDisplayLayerEventRegions
:
:
mVerticalPanRegion
addedFrames
)
;
for
(
nsIFrame
*
f
:
addedFrames
)
{
if
(
!
f
-
>
HasDisplayItem
(
aOldItem
)
)
{
f
-
>
AddDisplayItem
(
aOldItem
)
;
}
}
return
modified
;
}
void
RetainedDisplayListBuilder
:
:
IncrementSubDocPresShellPaintCount
(
nsDisplayItem
*
aItem
)
{
MOZ_ASSERT
(
aItem
-
>
GetType
(
)
=
=
DisplayItemType
:
:
TYPE_SUBDOCUMENT
)
;
nsSubDocumentFrame
*
subDocFrame
=
static_cast
<
nsDisplaySubDocument
*
>
(
aItem
)
-
>
SubDocumentFrame
(
)
;
MOZ_ASSERT
(
subDocFrame
)
;
nsIPresShell
*
presShell
=
subDocFrame
-
>
GetSubdocumentPresShellForPainting
(
0
)
;
MOZ_ASSERT
(
presShell
)
;
mBuilder
.
IncrementPresShellPaintCount
(
presShell
)
;
}
void
UpdateASR
(
nsDisplayItem
*
aItem
Maybe
<
const
ActiveScrolledRoot
*
>
&
aContainerASR
)
{
if
(
!
aContainerASR
)
{
return
;
}
nsDisplayWrapList
*
wrapList
=
aItem
-
>
AsDisplayWrapList
(
)
;
if
(
!
wrapList
)
{
aItem
-
>
SetActiveScrolledRoot
(
aContainerASR
.
value
(
)
)
;
return
;
}
wrapList
-
>
SetActiveScrolledRoot
(
ActiveScrolledRoot
:
:
PickAncestor
(
wrapList
-
>
GetFrameActiveScrolledRoot
(
)
aContainerASR
.
value
(
)
)
)
;
}
bool
RetainedDisplayListBuilder
:
:
MergeDisplayLists
(
nsDisplayList
*
aNewList
nsDisplayList
*
aOldList
nsDisplayList
*
aOutList
Maybe
<
const
ActiveScrolledRoot
*
>
&
aOutContainerASR
)
{
bool
modified
=
false
;
nsDisplayList
merged
;
const
auto
UseItem
=
[
&
]
(
nsDisplayItem
*
aItem
)
{
const
ActiveScrolledRoot
*
itemClipASR
=
aItem
-
>
GetClipChain
(
)
?
aItem
-
>
GetClipChain
(
)
-
>
mASR
:
nullptr
;
const
ActiveScrolledRoot
*
finiteBoundsASR
=
ActiveScrolledRoot
:
:
PickDescendant
(
itemClipASR
aItem
-
>
GetActiveScrolledRoot
(
)
)
;
if
(
!
aOutContainerASR
)
{
aOutContainerASR
=
Some
(
finiteBoundsASR
)
;
}
else
{
aOutContainerASR
=
Some
(
ActiveScrolledRoot
:
:
PickAncestor
(
aOutContainerASR
.
value
(
)
finiteBoundsASR
)
)
;
}
merged
.
AppendToTop
(
aItem
)
;
}
;
const
auto
ReuseItem
=
[
&
]
(
nsDisplayItem
*
aItem
)
{
UseItem
(
aItem
)
;
aItem
-
>
SetReused
(
true
)
;
if
(
aItem
-
>
GetType
(
)
=
=
DisplayItemType
:
:
TYPE_SUBDOCUMENT
)
{
IncrementSubDocPresShellPaintCount
(
aItem
)
;
}
}
;
const
bool
newListIsEmpty
=
aNewList
-
>
IsEmpty
(
)
;
if
(
!
newListIsEmpty
)
{
nsDataHashtable
<
DisplayItemHashEntry
nsDisplayItem
*
>
oldListLookup
(
aOldList
-
>
Count
(
)
)
;
for
(
nsDisplayItem
*
i
=
aOldList
-
>
GetBottom
(
)
;
i
!
=
nullptr
;
i
=
i
-
>
GetAbove
(
)
)
{
i
-
>
SetReused
(
false
)
;
oldListLookup
.
Put
(
{
i
-
>
Frame
(
)
i
-
>
GetPerFrameKey
(
)
}
i
)
;
}
nsDataHashtable
<
DisplayItemHashEntry
nsDisplayItem
*
>
newListLookup
(
aNewList
-
>
Count
(
)
)
;
for
(
nsDisplayItem
*
i
=
aNewList
-
>
GetBottom
(
)
;
i
!
=
nullptr
;
i
=
i
-
>
GetAbove
(
)
)
{
#
ifdef
DEBUG
if
(
newListLookup
.
Get
(
{
i
-
>
Frame
(
)
i
-
>
GetPerFrameKey
(
)
}
nullptr
)
)
{
MOZ_CRASH_UNSAFE_PRINTF
(
"
Duplicate
display
items
detected
!
:
%
s
(
0x
%
p
)
type
=
%
d
key
=
%
d
"
i
-
>
Name
(
)
i
-
>
Frame
(
)
static_cast
<
int
>
(
i
-
>
GetType
(
)
)
i
-
>
GetPerFrameKey
(
)
)
;
}
#
endif
newListLookup
.
Put
(
{
i
-
>
Frame
(
)
i
-
>
GetPerFrameKey
(
)
}
i
)
;
}
while
(
nsDisplayItem
*
newItem
=
aNewList
-
>
RemoveBottom
(
)
)
{
if
(
nsDisplayItem
*
oldItem
=
oldListLookup
.
Get
(
{
newItem
-
>
Frame
(
)
newItem
-
>
GetPerFrameKey
(
)
}
)
)
{
nsDisplayItem
*
old
=
nullptr
;
while
(
(
old
=
aOldList
-
>
GetBottom
(
)
)
&
&
old
!
=
oldItem
)
{
if
(
IsAnyAncestorModified
(
old
-
>
FrameForInvalidation
(
)
)
)
{
oldListLookup
.
Remove
(
{
old
-
>
Frame
(
)
old
-
>
GetPerFrameKey
(
)
}
)
;
aOldList
-
>
RemoveBottom
(
)
;
old
-
>
Destroy
(
&
mBuilder
)
;
modified
=
true
;
}
else
if
(
newListLookup
.
Get
(
{
old
-
>
Frame
(
)
old
-
>
GetPerFrameKey
(
)
}
)
)
{
modified
=
true
;
break
;
}
else
{
if
(
old
-
>
GetChildren
(
)
)
{
nsDisplayList
empty
;
Maybe
<
const
ActiveScrolledRoot
*
>
containerASRForChildren
;
if
(
MergeDisplayLists
(
&
empty
old
-
>
GetChildren
(
)
old
-
>
GetChildren
(
)
containerASRForChildren
)
)
{
modified
=
true
;
}
UpdateASR
(
old
containerASRForChildren
)
;
old
-
>
UpdateBounds
(
&
mBuilder
)
;
}
aOldList
-
>
RemoveBottom
(
)
;
ReuseItem
(
old
)
;
}
}
bool
destroy
=
false
;
if
(
old
=
=
oldItem
)
{
aOldList
-
>
RemoveBottom
(
)
;
destroy
=
true
;
}
else
{
oldItem
-
>
SetReused
(
true
)
;
}
if
(
destroy
&
&
oldItem
-
>
GetType
(
)
=
=
DisplayItemType
:
:
TYPE_LAYER_EVENT_REGIONS
&
&
!
IsAnyAncestorModified
(
oldItem
-
>
FrameForInvalidation
(
)
)
)
{
if
(
MergeLayerEventRegions
(
oldItem
newItem
)
)
{
modified
=
true
;
}
ReuseItem
(
oldItem
)
;
newItem
-
>
Destroy
(
&
mBuilder
)
;
}
else
{
if
(
IsAnyAncestorModified
(
oldItem
-
>
FrameForInvalidation
(
)
)
)
{
modified
=
true
;
}
else
if
(
oldItem
-
>
GetChildren
(
)
)
{
MOZ_ASSERT
(
newItem
-
>
GetChildren
(
)
)
;
Maybe
<
const
ActiveScrolledRoot
*
>
containerASRForChildren
;
if
(
MergeDisplayLists
(
newItem
-
>
GetChildren
(
)
oldItem
-
>
GetChildren
(
)
newItem
-
>
GetChildren
(
)
containerASRForChildren
)
)
{
modified
=
true
;
}
UpdateASR
(
newItem
containerASRForChildren
)
;
newItem
-
>
UpdateBounds
(
&
mBuilder
)
;
}
if
(
destroy
)
{
oldItem
-
>
Destroy
(
&
mBuilder
)
;
}
UseItem
(
newItem
)
;
}
}
else
{
modified
=
true
;
UseItem
(
newItem
)
;
}
}
}
while
(
nsDisplayItem
*
old
=
aOldList
-
>
RemoveBottom
(
)
)
{
if
(
!
IsAnyAncestorModified
(
old
-
>
FrameForInvalidation
(
)
)
&
&
(
!
old
-
>
IsReused
(
)
|
|
newListIsEmpty
)
)
{
if
(
old
-
>
GetChildren
(
)
)
{
nsDisplayList
empty
;
Maybe
<
const
ActiveScrolledRoot
*
>
containerASRForChildren
;
if
(
MergeDisplayLists
(
&
empty
old
-
>
GetChildren
(
)
old
-
>
GetChildren
(
)
containerASRForChildren
)
)
{
modified
=
true
;
}
UpdateASR
(
old
containerASRForChildren
)
;
old
-
>
UpdateBounds
(
&
mBuilder
)
;
}
if
(
old
-
>
GetType
(
)
=
=
DisplayItemType
:
:
TYPE_LAYER_EVENT_REGIONS
)
{
if
(
MergeLayerEventRegions
(
old
nullptr
)
)
{
modified
=
true
;
}
}
ReuseItem
(
old
)
;
}
else
{
old
-
>
Destroy
(
&
mBuilder
)
;
modified
=
true
;
}
}
aOutList
-
>
AppendToTop
(
&
merged
)
;
return
modified
;
}
static
void
TakeAndAddModifiedAndFramesWithPropsFromRootFrame
(
nsTArray
<
nsIFrame
*
>
*
aModifiedFrames
nsTArray
<
nsIFrame
*
>
*
aFramesWithProps
nsIFrame
*
aRootFrame
)
{
MOZ_ASSERT
(
aRootFrame
)
;
nsTArray
<
nsIFrame
*
>
*
frames
=
aRootFrame
-
>
GetProperty
(
nsIFrame
:
:
ModifiedFrameList
(
)
)
;
if
(
frames
)
{
for
(
nsIFrame
*
f
:
*
frames
)
{
if
(
f
)
{
aModifiedFrames
-
>
AppendElement
(
f
)
;
}
}
frames
-
>
Clear
(
)
;
}
frames
=
aRootFrame
-
>
GetProperty
(
nsIFrame
:
:
OverriddenDirtyRectFrameList
(
)
)
;
if
(
frames
)
{
for
(
nsIFrame
*
f
:
*
frames
)
{
if
(
f
)
{
aFramesWithProps
-
>
AppendElement
(
f
)
;
}
}
frames
-
>
Clear
(
)
;
}
}
struct
CbData
{
nsDisplayListBuilder
*
builder
;
nsTArray
<
nsIFrame
*
>
*
modifiedFrames
;
nsTArray
<
nsIFrame
*
>
*
framesWithProps
;
}
;
static
nsIFrame
*
GetRootFrameForPainting
(
nsDisplayListBuilder
*
aBuilder
nsIDocument
*
aDocument
)
{
nsIPresShell
*
presShell
=
aDocument
-
>
GetShell
(
)
;
if
(
!
presShell
)
{
return
nullptr
;
}
nsView
*
rootView
=
presShell
-
>
GetViewManager
(
)
-
>
GetRootView
(
)
;
if
(
!
rootView
)
{
return
nullptr
;
}
nsView
*
innerView
=
rootView
-
>
GetParent
(
)
;
if
(
!
innerView
)
{
return
nullptr
;
}
nsView
*
subDocView
=
innerView
-
>
GetParent
(
)
;
if
(
!
subDocView
)
{
return
nullptr
;
}
nsIFrame
*
subDocFrame
=
subDocView
-
>
GetFrame
(
)
;
if
(
!
subDocFrame
)
{
return
nullptr
;
}
nsSubDocumentFrame
*
subdocumentFrame
=
do_QueryFrame
(
subDocFrame
)
;
MOZ_ASSERT
(
subdocumentFrame
)
;
presShell
=
subdocumentFrame
-
>
GetSubdocumentPresShellForPainting
(
aBuilder
-
>
IsIgnoringPaintSuppression
(
)
?
nsSubDocumentFrame
:
:
IGNORE_PAINT_SUPPRESSION
:
0
)
;
return
presShell
?
presShell
-
>
GetRootFrame
(
)
:
nullptr
;
}
static
bool
SubDocEnumCb
(
nsIDocument
*
aDocument
void
*
aData
)
{
MOZ_ASSERT
(
aDocument
)
;
MOZ_ASSERT
(
aData
)
;
CbData
*
data
=
static_cast
<
CbData
*
>
(
aData
)
;
nsIFrame
*
rootFrame
=
GetRootFrameForPainting
(
data
-
>
builder
aDocument
)
;
if
(
rootFrame
)
{
TakeAndAddModifiedAndFramesWithPropsFromRootFrame
(
data
-
>
modifiedFrames
data
-
>
framesWithProps
rootFrame
)
;
nsIDocument
*
innerDoc
=
rootFrame
-
>
PresShell
(
)
-
>
GetDocument
(
)
;
if
(
innerDoc
)
{
innerDoc
-
>
EnumerateSubDocuments
(
SubDocEnumCb
aData
)
;
}
}
return
true
;
}
static
void
GetModifiedAndFramesWithProps
(
nsDisplayListBuilder
*
aBuilder
nsTArray
<
nsIFrame
*
>
*
aOutModifiedFrames
nsTArray
<
nsIFrame
*
>
*
aOutFramesWithProps
)
{
MOZ_ASSERT
(
aBuilder
-
>
RootReferenceFrame
(
)
)
;
TakeAndAddModifiedAndFramesWithPropsFromRootFrame
(
aOutModifiedFrames
aOutFramesWithProps
aBuilder
-
>
RootReferenceFrame
(
)
)
;
nsIDocument
*
rootdoc
=
aBuilder
-
>
RootReferenceFrame
(
)
-
>
PresContext
(
)
-
>
Document
(
)
;
if
(
rootdoc
)
{
CbData
data
=
{
aBuilder
aOutModifiedFrames
aOutFramesWithProps
}
;
rootdoc
-
>
EnumerateSubDocuments
(
SubDocEnumCb
&
data
)
;
}
}
#
if
CRR_DEBUG
#
define
CRR_LOG
(
.
.
.
)
printf_stderr
(
__VA_ARGS__
)
#
else
#
define
CRR_LOG
(
.
.
.
)
#
endif
static
nsIFrame
*
HandlePreserve3D
(
nsIFrame
*
aFrame
nsRect
&
aOverflow
)
{
nsIFrame
*
last
=
aFrame
;
while
(
aFrame
-
>
Extend3DContext
(
)
|
|
aFrame
-
>
Combines3DTransformWithAncestors
(
)
)
{
last
=
aFrame
;
aFrame
=
aFrame
-
>
GetParent
(
)
;
}
if
(
last
!
=
aFrame
)
{
aOverflow
=
last
-
>
GetVisualOverflowRectRelativeToParent
(
)
;
CRR_LOG
(
"
HandlePreserve3D
(
)
Updated
overflow
rect
to
:
%
d
%
d
%
d
%
d
\
n
"
aOverflow
.
x
aOverflow
.
y
aOverflow
.
width
aOverflow
.
height
)
;
}
return
aFrame
;
}
static
void
ProcessFrame
(
nsIFrame
*
aFrame
nsDisplayListBuilder
&
aBuilder
AnimatedGeometryRoot
*
*
aAGR
nsRect
&
aOverflow
nsIFrame
*
aStopAtFrame
nsTArray
<
nsIFrame
*
>
&
aOutFramesWithProps
const
bool
aStopAtStackingContext
)
{
nsIFrame
*
currentFrame
=
aFrame
;
while
(
currentFrame
!
=
aStopAtFrame
)
{
CRR_LOG
(
"
currentFrame
:
%
p
(
placeholder
=
%
d
)
aOverflow
:
%
d
%
d
%
d
%
d
\
n
"
currentFrame
!
aStopAtStackingContext
aOverflow
.
x
aOverflow
.
y
aOverflow
.
width
aOverflow
.
height
)
;
currentFrame
=
HandlePreserve3D
(
currentFrame
aOverflow
)
;
nsIFrame
*
placeholder
=
currentFrame
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
?
currentFrame
-
>
GetPlaceholderFrame
(
)
:
nullptr
;
if
(
placeholder
)
{
nsRect
placeholderOverflow
=
aOverflow
+
currentFrame
-
>
GetOffsetTo
(
placeholder
)
;
CRR_LOG
(
"
Processing
placeholder
%
p
for
OOF
frame
%
p
\
n
"
placeholder
currentFrame
)
;
CRR_LOG
(
"
OOF
frame
draw
area
:
%
d
%
d
%
d
%
d
\
n
"
placeholderOverflow
.
x
placeholderOverflow
.
y
placeholderOverflow
.
width
placeholderOverflow
.
height
)
;
AnimatedGeometryRoot
*
dummyAGR
=
nullptr
;
nsIFrame
*
ancestor
=
nsLayoutUtils
:
:
FindNearestCommonAncestorFrame
(
currentFrame
-
>
GetParent
(
)
placeholder
-
>
GetParent
(
)
)
;
ProcessFrame
(
placeholder
aBuilder
&
dummyAGR
placeholderOverflow
ancestor
aOutFramesWithProps
false
)
;
}
aOverflow
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
currentFrame
aOverflow
aStopAtFrame
nullptr
nullptr
true
&
currentFrame
)
;
MOZ_ASSERT
(
currentFrame
)
;
aOverflow
.
IntersectRect
(
aOverflow
currentFrame
-
>
GetVisualOverflowRectRelativeToSelf
(
)
)
;
if
(
aOverflow
.
IsEmpty
(
)
)
{
break
;
}
if
(
nsLayoutUtils
:
:
FrameHasDisplayPort
(
currentFrame
)
)
{
CRR_LOG
(
"
Frame
belongs
to
displayport
frame
%
p
\
n
"
currentFrame
)
;
nsIScrollableFrame
*
sf
=
do_QueryFrame
(
currentFrame
)
;
MOZ_ASSERT
(
sf
)
;
nsRect
displayPort
;
DebugOnly
<
bool
>
hasDisplayPort
=
nsLayoutUtils
:
:
GetDisplayPort
(
currentFrame
-
>
GetContent
(
)
&
displayPort
RelativeTo
:
:
ScrollPort
)
;
MOZ_ASSERT
(
hasDisplayPort
)
;
nsRect
r
=
aOverflow
-
sf
-
>
GetScrollPortRect
(
)
.
TopLeft
(
)
;
r
.
IntersectRect
(
r
displayPort
)
;
if
(
!
r
.
IsEmpty
(
)
)
{
nsRect
*
rect
=
currentFrame
-
>
GetProperty
(
nsDisplayListBuilder
:
:
DisplayListBuildingDisplayPortRect
(
)
)
;
if
(
!
rect
)
{
rect
=
new
nsRect
(
)
;
currentFrame
-
>
SetProperty
(
nsDisplayListBuilder
:
:
DisplayListBuildingDisplayPortRect
(
)
rect
)
;
currentFrame
-
>
SetHasOverrideDirtyRegion
(
true
)
;
aOutFramesWithProps
.
AppendElement
(
currentFrame
)
;
}
rect
-
>
UnionRect
(
*
rect
r
)
;
CRR_LOG
(
"
Adding
area
to
displayport
draw
area
:
%
d
%
d
%
d
%
d
\
n
"
r
.
x
r
.
y
r
.
width
r
.
height
)
;
aOverflow
=
sf
-
>
GetScrollPortRect
(
)
;
}
else
{
aOverflow
.
SetEmpty
(
)
;
break
;
}
}
if
(
currentFrame
-
>
IsStackingContext
(
)
)
{
CRR_LOG
(
"
Frame
belongs
to
stacking
context
frame
%
p
\
n
"
currentFrame
)
;
if
(
currentFrame
=
=
aBuilder
.
RootReferenceFrame
(
)
|
|
!
currentFrame
-
>
HasDisplayItems
(
)
)
{
continue
;
}
aBuilder
.
MarkFrameForDisplayIfVisible
(
currentFrame
aBuilder
.
RootReferenceFrame
(
)
)
;
nsDisplayListBuilder
:
:
DisplayListBuildingData
*
data
=
currentFrame
-
>
GetProperty
(
nsDisplayListBuilder
:
:
DisplayListBuildingRect
(
)
)
;
if
(
!
data
)
{
data
=
new
nsDisplayListBuilder
:
:
DisplayListBuildingData
(
)
;
currentFrame
-
>
SetProperty
(
nsDisplayListBuilder
:
:
DisplayListBuildingRect
(
)
data
)
;
currentFrame
-
>
SetHasOverrideDirtyRegion
(
true
)
;
aOutFramesWithProps
.
AppendElement
(
currentFrame
)
;
}
CRR_LOG
(
"
Adding
area
to
stacking
context
draw
area
:
%
d
%
d
%
d
%
d
\
n
"
aOverflow
.
x
aOverflow
.
y
aOverflow
.
width
aOverflow
.
height
)
;
data
-
>
mDirtyRect
.
UnionRect
(
data
-
>
mDirtyRect
aOverflow
)
;
if
(
!
aStopAtStackingContext
)
{
continue
;
}
if
(
!
data
-
>
mModifiedAGR
)
{
data
-
>
mModifiedAGR
=
*
aAGR
;
}
else
if
(
data
-
>
mModifiedAGR
!
=
*
aAGR
)
{
data
-
>
mDirtyRect
=
currentFrame
-
>
GetVisualOverflowRectRelativeToSelf
(
)
;
CRR_LOG
(
"
Found
multiple
modified
AGRs
within
this
stacking
context
giving
up
\
n
"
)
;
}
aOverflow
.
SetEmpty
(
)
;
*
aAGR
=
nullptr
;
break
;
}
}
}
bool
RetainedDisplayListBuilder
:
:
ComputeRebuildRegion
(
nsTArray
<
nsIFrame
*
>
&
aModifiedFrames
nsRect
*
aOutDirty
AnimatedGeometryRoot
*
*
aOutModifiedAGR
nsTArray
<
nsIFrame
*
>
&
aOutFramesWithProps
)
{
CRR_LOG
(
"
Computing
rebuild
regions
for
%
zu
frames
:
\
n
"
aModifiedFrames
.
Length
(
)
)
;
for
(
nsIFrame
*
f
:
aModifiedFrames
)
{
MOZ_ASSERT
(
f
)
;
if
(
f
-
>
HasOverrideDirtyRegion
(
)
)
{
aOutFramesWithProps
.
AppendElement
(
f
)
;
}
if
(
f
-
>
HasAnyStateBits
(
NS_FRAME_IN_POPUP
)
)
{
continue
;
}
AnimatedGeometryRoot
*
agr
=
mBuilder
.
FindAnimatedGeometryRootFor
(
f
)
-
>
GetAsyncAGR
(
)
;
CRR_LOG
(
"
Processing
frame
%
p
with
agr
%
p
\
n
"
f
agr
-
>
mFrame
)
;
nsRect
overflow
=
f
-
>
GetVisualOverflowRectRelativeToSelf
(
)
;
if
(
f
=
=
mBuilder
.
GetCaretFrame
(
)
)
{
overflow
.
UnionRect
(
overflow
mBuilder
.
GetCaretRect
(
)
)
;
}
ProcessFrame
(
f
mBuilder
&
agr
overflow
mBuilder
.
RootReferenceFrame
(
)
aOutFramesWithProps
true
)
;
if
(
!
overflow
.
IsEmpty
(
)
)
{
aOutDirty
-
>
UnionRect
(
*
aOutDirty
overflow
)
;
CRR_LOG
(
"
Adding
area
to
root
draw
area
:
%
d
%
d
%
d
%
d
\
n
"
overflow
.
x
overflow
.
y
overflow
.
width
overflow
.
height
)
;
if
(
!
*
aOutModifiedAGR
)
{
CRR_LOG
(
"
Setting
%
p
as
root
stacking
context
AGR
\
n
"
agr
)
;
*
aOutModifiedAGR
=
agr
;
}
else
if
(
agr
&
&
*
aOutModifiedAGR
!
=
agr
)
{
CRR_LOG
(
"
Found
multiple
AGRs
in
root
stacking
context
giving
up
\
n
"
)
;
return
false
;
}
}
}
return
true
;
}
static
bool
ShouldBuildPartial
(
nsTArray
<
nsIFrame
*
>
&
aModifiedFrames
)
{
if
(
aModifiedFrames
.
Length
(
)
>
gfxPrefs
:
:
LayoutRebuildFrameLimit
(
)
)
{
return
false
;
}
for
(
nsIFrame
*
f
:
aModifiedFrames
)
{
MOZ_ASSERT
(
f
)
;
const
LayoutFrameType
type
=
f
-
>
Type
(
)
;
if
(
type
=
=
LayoutFrameType
:
:
Viewport
|
|
type
=
=
LayoutFrameType
:
:
PageContent
|
|
type
=
=
LayoutFrameType
:
:
Canvas
|
|
type
=
=
LayoutFrameType
:
:
Scrollbar
)
{
return
false
;
}
}
return
true
;
}
static
void
ClearFrameProps
(
nsTArray
<
nsIFrame
*
>
&
aFrames
)
{
for
(
nsIFrame
*
f
:
aFrames
)
{
if
(
f
-
>
HasOverrideDirtyRegion
(
)
)
{
f
-
>
SetHasOverrideDirtyRegion
(
false
)
;
f
-
>
DeleteProperty
(
nsDisplayListBuilder
:
:
DisplayListBuildingRect
(
)
)
;
f
-
>
DeleteProperty
(
nsDisplayListBuilder
:
:
DisplayListBuildingDisplayPortRect
(
)
)
;
}
f
-
>
SetFrameIsModified
(
false
)
;
}
}
class
AutoClearFramePropsArray
{
public
:
AutoClearFramePropsArray
(
)
=
default
;
~
AutoClearFramePropsArray
(
)
{
ClearFrameProps
(
mFrames
)
;
}
nsTArray
<
nsIFrame
*
>
&
Frames
(
)
{
return
mFrames
;
}
bool
IsEmpty
(
)
const
{
return
mFrames
.
IsEmpty
(
)
;
}
private
:
nsTArray
<
nsIFrame
*
>
mFrames
;
}
;
void
RetainedDisplayListBuilder
:
:
ClearFramesWithProps
(
)
{
AutoClearFramePropsArray
modifiedFrames
;
AutoClearFramePropsArray
framesWithProps
;
GetModifiedAndFramesWithProps
(
&
mBuilder
&
modifiedFrames
.
Frames
(
)
&
framesWithProps
.
Frames
(
)
)
;
}
auto
RetainedDisplayListBuilder
:
:
AttemptPartialUpdate
(
nscolor
aBackstop
mozilla
:
:
DisplayListChecker
*
aChecker
)
-
>
PartialUpdateResult
{
mBuilder
.
RemoveModifiedWindowRegions
(
)
;
mBuilder
.
ClearWindowOpaqueRegion
(
)
;
if
(
mBuilder
.
ShouldSyncDecodeImages
(
)
)
{
MarkFramesWithItemsAndImagesModified
(
&
mList
)
;
}
mBuilder
.
EnterPresShell
(
mBuilder
.
RootReferenceFrame
(
)
)
;
AutoClearFramePropsArray
modifiedFrames
;
AutoClearFramePropsArray
framesWithProps
;
GetModifiedAndFramesWithProps
(
&
mBuilder
&
modifiedFrames
.
Frames
(
)
&
framesWithProps
.
Frames
(
)
)
;
const
bool
shouldBuildPartial
=
!
mList
.
IsEmpty
(
)
&
&
ShouldBuildPartial
(
modifiedFrames
.
Frames
(
)
)
;
if
(
mPreviousCaret
!
=
mBuilder
.
GetCaretFrame
(
)
)
{
if
(
mPreviousCaret
)
{
if
(
mBuilder
.
MarkFrameModifiedDuringBuilding
(
mPreviousCaret
)
)
{
modifiedFrames
.
Frames
(
)
.
AppendElement
(
mPreviousCaret
)
;
}
}
if
(
mBuilder
.
GetCaretFrame
(
)
)
{
if
(
mBuilder
.
MarkFrameModifiedDuringBuilding
(
mBuilder
.
GetCaretFrame
(
)
)
)
{
modifiedFrames
.
Frames
(
)
.
AppendElement
(
mBuilder
.
GetCaretFrame
(
)
)
;
}
}
mPreviousCaret
=
mBuilder
.
GetCaretFrame
(
)
;
}
nsRect
modifiedDirty
;
AnimatedGeometryRoot
*
modifiedAGR
=
nullptr
;
if
(
!
shouldBuildPartial
|
|
!
ComputeRebuildRegion
(
modifiedFrames
.
Frames
(
)
&
modifiedDirty
&
modifiedAGR
framesWithProps
.
Frames
(
)
)
)
{
mBuilder
.
LeavePresShell
(
mBuilder
.
RootReferenceFrame
(
)
&
mList
)
;
return
PartialUpdateResult
:
:
Failed
;
}
modifiedDirty
.
IntersectRect
(
modifiedDirty
mBuilder
.
RootReferenceFrame
(
)
-
>
GetVisualOverflowRectRelativeToSelf
(
)
)
;
PartialUpdateResult
result
=
PartialUpdateResult
:
:
NoChange
;
if
(
PreProcessDisplayList
(
&
mList
modifiedAGR
)
|
|
!
modifiedDirty
.
IsEmpty
(
)
|
|
!
framesWithProps
.
IsEmpty
(
)
)
{
result
=
PartialUpdateResult
:
:
Updated
;
}
nsDisplayList
modifiedDL
;
if
(
!
modifiedDirty
.
IsEmpty
(
)
|
|
!
framesWithProps
.
IsEmpty
(
)
)
{
mBuilder
.
SetDirtyRect
(
modifiedDirty
)
;
mBuilder
.
SetPartialUpdate
(
true
)
;
mBuilder
.
RootReferenceFrame
(
)
-
>
BuildDisplayListForStackingContext
(
&
mBuilder
&
modifiedDL
)
;
nsLayoutUtils
:
:
AddExtraBackgroundItems
(
mBuilder
modifiedDL
mBuilder
.
RootReferenceFrame
(
)
nsRect
(
nsPoint
(
0
0
)
mBuilder
.
RootReferenceFrame
(
)
-
>
GetSize
(
)
)
mBuilder
.
RootReferenceFrame
(
)
-
>
GetVisualOverflowRectRelativeToSelf
(
)
aBackstop
)
;
mBuilder
.
SetPartialUpdate
(
false
)
;
}
else
{
}
if
(
aChecker
)
{
aChecker
-
>
Set
(
&
modifiedDL
"
TM
"
)
;
}
Maybe
<
const
ActiveScrolledRoot
*
>
dummy
;
if
(
MergeDisplayLists
(
&
modifiedDL
&
mList
&
mList
dummy
)
)
{
result
=
PartialUpdateResult
:
:
Updated
;
}
mBuilder
.
LeavePresShell
(
mBuilder
.
RootReferenceFrame
(
)
&
mList
)
;
return
result
;
}
