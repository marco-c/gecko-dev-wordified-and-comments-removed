#
include
"
RetainedDisplayListBuilder
.
h
"
#
include
"
nsSubDocumentFrame
.
h
"
using
namespace
mozilla
;
void
MarkFramesWithItemsAndImagesModified
(
nsDisplayList
*
aList
)
{
for
(
nsDisplayItem
*
i
=
aList
-
>
GetBottom
(
)
;
i
!
=
nullptr
;
i
=
i
-
>
GetAbove
(
)
)
{
if
(
!
i
-
>
HasDeletedFrame
(
)
&
&
i
-
>
CanBeReused
(
)
&
&
!
i
-
>
Frame
(
)
-
>
IsFrameModified
(
)
)
{
DisplayItemData
*
data
=
FrameLayerBuilder
:
:
GetOldDataFor
(
i
)
;
bool
invalidate
=
false
;
if
(
data
&
&
data
-
>
GetGeometry
(
)
)
{
invalidate
=
data
-
>
GetGeometry
(
)
-
>
InvalidateForSyncDecodeImages
(
)
;
}
else
if
(
!
(
i
-
>
GetFlags
(
)
&
TYPE_RENDERS_NO_IMAGES
)
)
{
invalidate
=
true
;
}
if
(
invalidate
)
{
i
-
>
FrameForInvalidation
(
)
-
>
MarkNeedsDisplayItemRebuild
(
)
;
if
(
i
-
>
GetDependentFrame
(
)
)
{
i
-
>
GetDependentFrame
(
)
-
>
MarkNeedsDisplayItemRebuild
(
)
;
}
}
}
if
(
i
-
>
GetChildren
(
)
)
{
MarkFramesWithItemsAndImagesModified
(
i
-
>
GetChildren
(
)
)
;
}
}
}
bool
IsAnyAncestorModified
(
nsIFrame
*
aFrame
)
{
nsIFrame
*
f
=
aFrame
;
while
(
f
)
{
if
(
f
-
>
IsFrameModified
(
)
)
{
return
true
;
}
f
=
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
f
)
;
}
return
false
;
}
void
RetainedDisplayListBuilder
:
:
PreProcessDisplayList
(
nsDisplayList
*
aList
AnimatedGeometryRoot
*
aAGR
)
{
nsDisplayList
saved
(
&
mBuilder
)
;
while
(
nsDisplayItem
*
i
=
aList
-
>
RemoveBottom
(
)
)
{
if
(
i
-
>
HasDeletedFrame
(
)
|
|
!
i
-
>
CanBeReused
(
)
)
{
i
-
>
Destroy
(
&
mBuilder
)
;
continue
;
}
nsIFrame
*
f
=
i
-
>
Frame
(
)
;
if
(
i
-
>
GetChildren
(
)
)
{
AnimatedGeometryRoot
*
childAGR
=
aAGR
;
if
(
f
-
>
IsStackingContext
(
)
)
{
if
(
f
-
>
HasOverrideDirtyRegion
(
)
)
{
nsDisplayListBuilder
:
:
DisplayListBuildingData
*
data
=
f
-
>
GetProperty
(
nsDisplayListBuilder
:
:
DisplayListBuildingRect
(
)
)
;
if
(
data
)
{
childAGR
=
data
-
>
mModifiedAGR
;
}
}
else
{
childAGR
=
nullptr
;
}
}
PreProcessDisplayList
(
i
-
>
GetChildren
(
)
childAGR
)
;
}
if
(
aAGR
&
&
i
-
>
GetAnimatedGeometryRoot
(
)
-
>
GetAsyncAGR
(
)
!
=
aAGR
)
{
mBuilder
.
MarkFrameForDisplayIfVisible
(
f
mBuilder
.
RootReferenceFrame
(
)
)
;
}
i
-
>
RestoreState
(
)
;
saved
.
AppendToTop
(
i
)
;
}
aList
-
>
AppendToTop
(
&
saved
)
;
aList
-
>
RestoreState
(
)
;
}
bool
IsSameItem
(
nsDisplayItem
*
aFirst
nsDisplayItem
*
aSecond
)
{
return
aFirst
-
>
Frame
(
)
=
=
aSecond
-
>
Frame
(
)
&
&
aFirst
-
>
GetPerFrameKey
(
)
=
=
aSecond
-
>
GetPerFrameKey
(
)
;
}
struct
DisplayItemKey
{
bool
operator
=
=
(
const
DisplayItemKey
&
aOther
)
const
{
return
mFrame
=
=
aOther
.
mFrame
&
&
mPerFrameKey
=
=
aOther
.
mPerFrameKey
;
}
nsIFrame
*
mFrame
;
uint32_t
mPerFrameKey
;
}
;
class
DisplayItemHashEntry
:
public
PLDHashEntryHdr
{
public
:
typedef
DisplayItemKey
KeyType
;
typedef
const
DisplayItemKey
*
KeyTypePointer
;
explicit
DisplayItemHashEntry
(
KeyTypePointer
aKey
)
:
mKey
(
*
aKey
)
{
}
explicit
DisplayItemHashEntry
(
const
DisplayItemHashEntry
&
aCopy
)
=
default
;
~
DisplayItemHashEntry
(
)
=
default
;
KeyType
GetKey
(
)
const
{
return
mKey
;
}
bool
KeyEquals
(
KeyTypePointer
aKey
)
const
{
return
mKey
=
=
*
aKey
;
}
static
KeyTypePointer
KeyToPointer
(
KeyType
&
aKey
)
{
return
&
aKey
;
}
static
PLDHashNumber
HashKey
(
KeyTypePointer
aKey
)
{
if
(
!
aKey
)
return
0
;
return
mozilla
:
:
HashGeneric
(
aKey
-
>
mFrame
aKey
-
>
mPerFrameKey
)
;
}
enum
{
ALLOW_MEMMOVE
=
true
}
;
DisplayItemKey
mKey
;
}
;
template
<
typename
T
>
void
SwapAndRemove
(
nsTArray
<
T
>
&
aArray
uint32_t
aIndex
)
{
if
(
aIndex
!
=
(
aArray
.
Length
(
)
-
1
)
)
{
T
last
=
aArray
.
LastElement
(
)
;
aArray
.
LastElement
(
)
=
aArray
[
aIndex
]
;
aArray
[
aIndex
]
=
last
;
}
aArray
.
RemoveElementAt
(
aArray
.
Length
(
)
-
1
)
;
}
static
void
MergeFrameRects
(
nsDisplayLayerEventRegions
*
aOldItem
nsDisplayLayerEventRegions
*
aNewItem
nsDisplayLayerEventRegions
:
:
FrameRects
nsDisplayLayerEventRegions
:
:
*
aRectList
nsTArray
<
nsIFrame
*
>
&
aAddedFrames
)
{
nsDisplayLayerEventRegions
:
:
FrameRects
&
oldRects
=
aOldItem
-
>
*
aRectList
;
uint32_t
i
=
0
;
while
(
i
<
oldRects
.
mFrames
.
Length
(
)
)
{
nsIFrame
*
f
=
oldRects
.
mFrames
[
i
]
;
if
(
IsAnyAncestorModified
(
f
)
)
{
MOZ_ASSERT
(
f
!
=
aOldItem
-
>
Frame
(
)
)
;
f
-
>
RemoveDisplayItem
(
aOldItem
)
;
SwapAndRemove
(
oldRects
.
mFrames
i
)
;
SwapAndRemove
(
oldRects
.
mBoxes
i
)
;
}
else
{
i
+
+
;
}
}
if
(
!
aNewItem
)
{
return
;
}
nsDisplayItem
*
destItem
=
aOldItem
;
nsDisplayLayerEventRegions
:
:
FrameRects
*
destRects
=
&
(
aOldItem
-
>
*
aRectList
)
;
nsDisplayLayerEventRegions
:
:
FrameRects
*
srcRects
=
&
(
aNewItem
-
>
*
aRectList
)
;
for
(
uint32_t
i
=
0
;
i
<
srcRects
-
>
mFrames
.
Length
(
)
;
i
+
+
)
{
nsIFrame
*
f
=
srcRects
-
>
mFrames
[
i
]
;
if
(
!
f
-
>
HasDisplayItem
(
destItem
)
)
{
destRects
-
>
Add
(
f
srcRects
-
>
mBoxes
[
i
]
)
;
aAddedFrames
.
AppendElement
(
f
)
;
MOZ_ASSERT
(
f
!
=
aOldItem
-
>
Frame
(
)
)
;
}
}
}
void
MergeLayerEventRegions
(
nsDisplayItem
*
aOldItem
nsDisplayItem
*
aNewItem
)
{
nsDisplayLayerEventRegions
*
oldItem
=
static_cast
<
nsDisplayLayerEventRegions
*
>
(
aOldItem
)
;
nsDisplayLayerEventRegions
*
newItem
=
static_cast
<
nsDisplayLayerEventRegions
*
>
(
aNewItem
)
;
nsTArray
<
nsIFrame
*
>
addedFrames
;
MergeFrameRects
(
oldItem
newItem
&
nsDisplayLayerEventRegions
:
:
mHitRegion
addedFrames
)
;
MergeFrameRects
(
oldItem
newItem
&
nsDisplayLayerEventRegions
:
:
mMaybeHitRegion
addedFrames
)
;
MergeFrameRects
(
oldItem
newItem
&
nsDisplayLayerEventRegions
:
:
mDispatchToContentHitRegion
addedFrames
)
;
MergeFrameRects
(
oldItem
newItem
&
nsDisplayLayerEventRegions
:
:
mNoActionRegion
addedFrames
)
;
MergeFrameRects
(
oldItem
newItem
&
nsDisplayLayerEventRegions
:
:
mHorizontalPanRegion
addedFrames
)
;
MergeFrameRects
(
oldItem
newItem
&
nsDisplayLayerEventRegions
:
:
mVerticalPanRegion
addedFrames
)
;
for
(
nsIFrame
*
f
:
addedFrames
)
{
if
(
!
f
-
>
HasDisplayItem
(
aOldItem
)
)
{
f
-
>
AddDisplayItem
(
aOldItem
)
;
}
}
}
void
RetainedDisplayListBuilder
:
:
IncrementSubDocPresShellPaintCount
(
nsDisplayItem
*
aItem
)
{
MOZ_ASSERT
(
aItem
-
>
GetType
(
)
=
=
DisplayItemType
:
:
TYPE_SUBDOCUMENT
)
;
nsSubDocumentFrame
*
subDocFrame
=
static_cast
<
nsDisplaySubDocument
*
>
(
aItem
)
-
>
SubDocumentFrame
(
)
;
MOZ_ASSERT
(
subDocFrame
)
;
nsIPresShell
*
presShell
=
subDocFrame
-
>
GetSubdocumentPresShellForPainting
(
0
)
;
MOZ_ASSERT
(
presShell
)
;
mBuilder
.
IncrementPresShellPaintCount
(
presShell
)
;
}
void
RetainedDisplayListBuilder
:
:
MergeDisplayLists
(
nsDisplayList
*
aNewList
nsDisplayList
*
aOldList
nsDisplayList
*
aOutList
)
{
nsDisplayList
merged
(
&
mBuilder
)
;
const
auto
ReuseItem
=
[
&
]
(
nsDisplayItem
*
aItem
)
{
merged
.
AppendToTop
(
aItem
)
;
aItem
-
>
SetReused
(
true
)
;
if
(
aItem
-
>
GetType
(
)
=
=
DisplayItemType
:
:
TYPE_SUBDOCUMENT
)
{
IncrementSubDocPresShellPaintCount
(
aItem
)
;
}
}
;
nsDataHashtable
<
DisplayItemHashEntry
nsDisplayItem
*
>
oldListLookup
(
aOldList
-
>
Count
(
)
)
;
for
(
nsDisplayItem
*
i
=
aOldList
-
>
GetBottom
(
)
;
i
!
=
nullptr
;
i
=
i
-
>
GetAbove
(
)
)
{
i
-
>
SetReused
(
false
)
;
if
(
!
aNewList
-
>
IsEmpty
(
)
)
{
oldListLookup
.
Put
(
{
i
-
>
Frame
(
)
i
-
>
GetPerFrameKey
(
)
}
i
)
;
}
}
#
ifdef
DEBUG
nsDataHashtable
<
DisplayItemHashEntry
nsDisplayItem
*
>
newListLookup
(
aNewList
-
>
Count
(
)
)
;
for
(
nsDisplayItem
*
i
=
aNewList
-
>
GetBottom
(
)
;
i
!
=
nullptr
;
i
=
i
-
>
GetAbove
(
)
)
{
if
(
newListLookup
.
Get
(
{
i
-
>
Frame
(
)
i
-
>
GetPerFrameKey
(
)
}
nullptr
)
)
{
MOZ_CRASH_UNSAFE_PRINTF
(
"
Duplicate
display
items
detected
!
:
%
s
(
0x
%
p
)
type
=
%
d
key
=
%
d
"
i
-
>
Name
(
)
i
-
>
Frame
(
)
static_cast
<
int
>
(
i
-
>
GetType
(
)
)
i
-
>
GetPerFrameKey
(
)
)
;
}
newListLookup
.
Put
(
{
i
-
>
Frame
(
)
i
-
>
GetPerFrameKey
(
)
}
i
)
;
}
#
endif
while
(
nsDisplayItem
*
newItem
=
aNewList
-
>
RemoveBottom
(
)
)
{
if
(
nsDisplayItem
*
oldItem
=
oldListLookup
.
Get
(
{
newItem
-
>
Frame
(
)
newItem
-
>
GetPerFrameKey
(
)
}
)
)
{
if
(
oldItem
-
>
IsReused
(
)
)
{
if
(
oldItem
-
>
GetChildren
(
)
)
{
MOZ_ASSERT
(
newItem
-
>
GetChildren
(
)
)
;
MergeDisplayLists
(
newItem
-
>
GetChildren
(
)
oldItem
-
>
GetChildren
(
)
oldItem
-
>
GetChildren
(
)
)
;
oldItem
-
>
UpdateBounds
(
&
mBuilder
)
;
}
if
(
oldItem
-
>
GetType
(
)
=
=
DisplayItemType
:
:
TYPE_LAYER_EVENT_REGIONS
)
{
MergeLayerEventRegions
(
oldItem
newItem
)
;
}
newItem
-
>
Destroy
(
&
mBuilder
)
;
}
else
{
nsDisplayItem
*
old
=
nullptr
;
while
(
(
old
=
aOldList
-
>
RemoveBottom
(
)
)
&
&
!
IsSameItem
(
newItem
old
)
)
{
if
(
!
IsAnyAncestorModified
(
old
-
>
FrameForInvalidation
(
)
)
)
{
if
(
old
-
>
GetChildren
(
)
)
{
nsDisplayList
empty
(
&
mBuilder
)
;
MergeDisplayLists
(
&
empty
old
-
>
GetChildren
(
)
old
-
>
GetChildren
(
)
)
;
old
-
>
UpdateBounds
(
&
mBuilder
)
;
}
ReuseItem
(
old
)
;
}
else
{
oldListLookup
.
Remove
(
{
old
-
>
Frame
(
)
old
-
>
GetPerFrameKey
(
)
}
)
;
old
-
>
Destroy
(
&
mBuilder
)
;
}
}
MOZ_ASSERT
(
old
&
&
IsSameItem
(
newItem
old
)
)
;
MOZ_ASSERT
(
old
=
=
oldItem
)
;
if
(
old
-
>
GetType
(
)
=
=
DisplayItemType
:
:
TYPE_LAYER_EVENT_REGIONS
&
&
!
IsAnyAncestorModified
(
old
-
>
FrameForInvalidation
(
)
)
)
{
MergeLayerEventRegions
(
old
newItem
)
;
ReuseItem
(
old
)
;
newItem
-
>
Destroy
(
&
mBuilder
)
;
}
else
{
if
(
!
IsAnyAncestorModified
(
old
-
>
FrameForInvalidation
(
)
)
&
&
old
-
>
GetChildren
(
)
)
{
MOZ_ASSERT
(
newItem
-
>
GetChildren
(
)
)
;
MergeDisplayLists
(
newItem
-
>
GetChildren
(
)
old
-
>
GetChildren
(
)
newItem
-
>
GetChildren
(
)
)
;
newItem
-
>
UpdateBounds
(
&
mBuilder
)
;
}
old
-
>
Destroy
(
&
mBuilder
)
;
merged
.
AppendToTop
(
newItem
)
;
}
}
}
else
{
merged
.
AppendToTop
(
newItem
)
;
}
}
while
(
nsDisplayItem
*
old
=
aOldList
-
>
RemoveBottom
(
)
)
{
if
(
!
IsAnyAncestorModified
(
old
-
>
FrameForInvalidation
(
)
)
)
{
ReuseItem
(
old
)
;
if
(
old
-
>
GetChildren
(
)
)
{
nsDisplayList
empty
(
&
mBuilder
)
;
MergeDisplayLists
(
&
empty
old
-
>
GetChildren
(
)
old
-
>
GetChildren
(
)
)
;
old
-
>
UpdateBounds
(
&
mBuilder
)
;
}
if
(
old
-
>
GetType
(
)
=
=
DisplayItemType
:
:
TYPE_LAYER_EVENT_REGIONS
)
{
MergeLayerEventRegions
(
old
nullptr
)
;
}
}
else
{
old
-
>
Destroy
(
&
mBuilder
)
;
}
}
aOutList
-
>
AppendToTop
(
&
merged
)
;
}
static
void
TakeAndAddModifiedFramesFromRootFrame
(
nsTArray
<
nsIFrame
*
>
&
aFrames
nsIFrame
*
aRootFrame
)
{
MOZ_ASSERT
(
aRootFrame
)
;
std
:
:
vector
<
WeakFrame
>
*
frames
=
aRootFrame
-
>
GetProperty
(
nsIFrame
:
:
ModifiedFrameList
(
)
)
;
if
(
!
frames
)
{
return
;
}
for
(
WeakFrame
&
frame
:
*
frames
)
{
nsIFrame
*
f
=
frame
.
GetFrame
(
)
;
if
(
f
)
{
aFrames
.
AppendElement
(
f
)
;
}
}
frames
-
>
clear
(
)
;
}
static
bool
SubDocEnumCb
(
nsIDocument
*
aDocument
void
*
aData
)
{
MOZ_ASSERT
(
aDocument
)
;
MOZ_ASSERT
(
aData
)
;
nsTArray
<
nsIFrame
*
>
*
modifiedFrames
=
static_cast
<
nsTArray
<
nsIFrame
*
>
*
>
(
aData
)
;
nsIPresShell
*
presShell
=
aDocument
-
>
GetShell
(
)
;
nsIFrame
*
rootFrame
=
presShell
?
presShell
-
>
GetRootFrame
(
)
:
nullptr
;
if
(
rootFrame
)
{
TakeAndAddModifiedFramesFromRootFrame
(
*
modifiedFrames
rootFrame
)
;
}
aDocument
-
>
EnumerateSubDocuments
(
SubDocEnumCb
aData
)
;
return
true
;
}
static
nsTArray
<
nsIFrame
*
>
GetModifiedFrames
(
nsIFrame
*
aDisplayRootFrame
)
{
MOZ_ASSERT
(
aDisplayRootFrame
)
;
nsTArray
<
nsIFrame
*
>
modifiedFrames
;
TakeAndAddModifiedFramesFromRootFrame
(
modifiedFrames
aDisplayRootFrame
)
;
nsIDocument
*
rootdoc
=
aDisplayRootFrame
-
>
PresContext
(
)
-
>
Document
(
)
;
if
(
rootdoc
)
{
rootdoc
-
>
EnumerateSubDocuments
(
SubDocEnumCb
&
modifiedFrames
)
;
}
return
modifiedFrames
;
}
#
if
CRR_DEBUG
#
define
CRR_LOG
(
.
.
.
)
printf_stderr
(
__VA_ARGS__
)
#
else
#
define
CRR_LOG
(
.
.
.
)
#
endif
bool
RetainedDisplayListBuilder
:
:
ComputeRebuildRegion
(
nsTArray
<
nsIFrame
*
>
&
aModifiedFrames
nsRect
*
aOutDirty
AnimatedGeometryRoot
*
*
aOutModifiedAGR
nsTArray
<
nsIFrame
*
>
*
aOutFramesWithProps
)
{
CRR_LOG
(
"
Computing
rebuild
regions
for
%
d
frames
:
\
n
"
aModifiedFrames
.
size
(
)
)
;
for
(
nsIFrame
*
f
:
aModifiedFrames
)
{
MOZ_ASSERT
(
f
)
;
if
(
f
-
>
HasOverrideDirtyRegion
(
)
)
{
aOutFramesWithProps
-
>
AppendElement
(
f
)
;
}
AnimatedGeometryRoot
*
agr
=
mBuilder
.
FindAnimatedGeometryRootFor
(
f
)
-
>
GetAsyncAGR
(
)
;
CRR_LOG
(
"
Processing
frame
%
p
with
agr
%
p
\
n
"
f
agr
-
>
mFrame
)
;
nsRect
overflow
=
f
-
>
GetVisualOverflowRectRelativeToSelf
(
)
;
nsIFrame
*
currentFrame
=
f
;
while
(
currentFrame
!
=
mBuilder
.
RootReferenceFrame
(
)
)
{
overflow
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
currentFrame
overflow
mBuilder
.
RootReferenceFrame
(
)
nullptr
nullptr
true
&
currentFrame
)
;
MOZ_ASSERT
(
currentFrame
)
;
if
(
nsLayoutUtils
:
:
FrameHasDisplayPort
(
currentFrame
)
)
{
CRR_LOG
(
"
Frame
belongs
to
displayport
frame
%
p
\
n
"
currentFrame
)
;
nsIScrollableFrame
*
sf
=
do_QueryFrame
(
currentFrame
)
;
MOZ_ASSERT
(
sf
)
;
nsRect
displayPort
;
DebugOnly
<
bool
>
hasDisplayPort
=
nsLayoutUtils
:
:
GetDisplayPort
(
currentFrame
-
>
GetContent
(
)
&
displayPort
RelativeTo
:
:
ScrollPort
)
;
MOZ_ASSERT
(
hasDisplayPort
)
;
nsRect
r
=
overflow
-
sf
-
>
GetScrollPortRect
(
)
.
TopLeft
(
)
;
r
.
IntersectRect
(
r
displayPort
)
;
if
(
!
r
.
IsEmpty
(
)
)
{
nsRect
*
rect
=
currentFrame
-
>
GetProperty
(
nsDisplayListBuilder
:
:
DisplayListBuildingDisplayPortRect
(
)
)
;
if
(
!
rect
)
{
rect
=
new
nsRect
(
)
;
currentFrame
-
>
SetProperty
(
nsDisplayListBuilder
:
:
DisplayListBuildingDisplayPortRect
(
)
rect
)
;
currentFrame
-
>
SetHasOverrideDirtyRegion
(
true
)
;
}
rect
-
>
UnionRect
(
*
rect
r
)
;
aOutFramesWithProps
-
>
AppendElement
(
currentFrame
)
;
CRR_LOG
(
"
Adding
area
to
displayport
draw
area
:
%
d
%
d
%
d
%
d
\
n
"
r
.
x
r
.
y
r
.
width
r
.
height
)
;
overflow
=
sf
-
>
GetScrollPortRect
(
)
;
}
else
{
overflow
.
SetEmpty
(
)
;
break
;
}
}
if
(
currentFrame
-
>
IsStackingContext
(
)
)
{
CRR_LOG
(
"
Frame
belongs
to
stacking
context
frame
%
p
\
n
"
currentFrame
)
;
if
(
currentFrame
!
=
mBuilder
.
RootReferenceFrame
(
)
&
&
currentFrame
-
>
HasDisplayItems
(
)
)
{
mBuilder
.
MarkFrameForDisplayIfVisible
(
currentFrame
mBuilder
.
RootReferenceFrame
(
)
)
;
nsDisplayListBuilder
:
:
DisplayListBuildingData
*
data
=
currentFrame
-
>
GetProperty
(
nsDisplayListBuilder
:
:
DisplayListBuildingRect
(
)
)
;
if
(
!
data
)
{
data
=
new
nsDisplayListBuilder
:
:
DisplayListBuildingData
;
currentFrame
-
>
SetProperty
(
nsDisplayListBuilder
:
:
DisplayListBuildingRect
(
)
data
)
;
currentFrame
-
>
SetHasOverrideDirtyRegion
(
true
)
;
aOutFramesWithProps
-
>
AppendElement
(
currentFrame
)
;
}
data
-
>
mDirtyRect
.
UnionRect
(
data
-
>
mDirtyRect
overflow
)
;
CRR_LOG
(
"
Adding
area
to
stacking
context
draw
area
:
%
d
%
d
%
d
%
d
\
n
"
overflow
.
x
overflow
.
y
overflow
.
width
overflow
.
height
)
;
if
(
!
data
-
>
mModifiedAGR
)
{
data
-
>
mModifiedAGR
=
agr
;
}
else
if
(
data
-
>
mModifiedAGR
!
=
agr
)
{
data
-
>
mDirtyRect
=
currentFrame
-
>
GetVisualOverflowRectRelativeToSelf
(
)
;
CRR_LOG
(
"
Found
multiple
modified
AGRs
within
this
stacking
context
giving
up
\
n
"
)
;
}
agr
=
nullptr
;
overflow
.
SetEmpty
(
)
;
break
;
}
}
}
aOutDirty
-
>
UnionRect
(
*
aOutDirty
overflow
)
;
CRR_LOG
(
"
Adding
area
to
root
draw
area
:
%
d
%
d
%
d
%
d
\
n
"
overflow
.
x
overflow
.
y
overflow
.
width
overflow
.
height
)
;
if
(
!
*
aOutModifiedAGR
)
{
*
aOutModifiedAGR
=
agr
;
}
else
if
(
agr
&
&
*
aOutModifiedAGR
!
=
agr
)
{
CRR_LOG
(
"
Found
multiple
AGRs
in
root
stacking
context
giving
up
\
n
"
)
;
return
false
;
}
}
return
true
;
}
static
bool
ShouldBuildPartial
(
nsTArray
<
nsIFrame
*
>
&
aModifiedFrames
)
{
if
(
aModifiedFrames
.
Length
(
)
>
gfxPrefs
:
:
LayoutRebuildFrameLimit
(
)
)
{
return
false
;
}
for
(
nsIFrame
*
f
:
aModifiedFrames
)
{
MOZ_ASSERT
(
f
)
;
const
LayoutFrameType
type
=
f
-
>
Type
(
)
;
if
(
type
=
=
LayoutFrameType
:
:
Viewport
|
|
type
=
=
LayoutFrameType
:
:
PageContent
|
|
type
=
=
LayoutFrameType
:
:
Canvas
|
|
type
=
=
LayoutFrameType
:
:
Scrollbar
)
{
return
false
;
}
}
return
true
;
}
bool
RetainedDisplayListBuilder
:
:
AttemptPartialUpdate
(
nscolor
aBackstop
)
{
mBuilder
.
RemoveModifiedWindowDraggingRegion
(
)
;
if
(
mBuilder
.
ShouldSyncDecodeImages
(
)
)
{
MarkFramesWithItemsAndImagesModified
(
&
mList
)
;
}
mBuilder
.
EnterPresShell
(
mBuilder
.
RootReferenceFrame
(
)
)
;
nsTArray
<
nsIFrame
*
>
modifiedFrames
=
GetModifiedFrames
(
mBuilder
.
RootReferenceFrame
(
)
)
;
const
bool
shouldBuildPartial
=
ShouldBuildPartial
(
modifiedFrames
)
;
if
(
mPreviousCaret
!
=
mBuilder
.
GetCaretFrame
(
)
)
{
if
(
mPreviousCaret
)
{
if
(
mBuilder
.
MarkFrameModifiedDuringBuilding
(
mPreviousCaret
)
)
{
modifiedFrames
.
AppendElement
(
mPreviousCaret
)
;
}
}
if
(
mBuilder
.
GetCaretFrame
(
)
)
{
if
(
mBuilder
.
MarkFrameModifiedDuringBuilding
(
mBuilder
.
GetCaretFrame
(
)
)
)
{
modifiedFrames
.
AppendElement
(
mBuilder
.
GetCaretFrame
(
)
)
;
}
}
mPreviousCaret
=
mBuilder
.
GetCaretFrame
(
)
;
}
nsRect
modifiedDirty
;
AnimatedGeometryRoot
*
modifiedAGR
=
nullptr
;
nsTArray
<
nsIFrame
*
>
framesWithProps
;
bool
merged
=
false
;
if
(
shouldBuildPartial
&
&
!
mList
.
IsEmpty
(
)
&
&
ComputeRebuildRegion
(
modifiedFrames
&
modifiedDirty
&
modifiedAGR
&
framesWithProps
)
)
{
modifiedDirty
.
IntersectRect
(
modifiedDirty
mBuilder
.
RootReferenceFrame
(
)
-
>
GetVisualOverflowRectRelativeToSelf
(
)
)
;
PreProcessDisplayList
(
&
mList
modifiedAGR
)
;
nsDisplayList
modifiedDL
(
&
mBuilder
)
;
if
(
!
modifiedDirty
.
IsEmpty
(
)
|
|
!
framesWithProps
.
IsEmpty
(
)
)
{
mBuilder
.
SetDirtyRect
(
modifiedDirty
)
;
mBuilder
.
SetPartialUpdate
(
true
)
;
mBuilder
.
RootReferenceFrame
(
)
-
>
BuildDisplayListForStackingContext
(
&
mBuilder
&
modifiedDL
)
;
nsLayoutUtils
:
:
AddExtraBackgroundItems
(
mBuilder
modifiedDL
mBuilder
.
RootReferenceFrame
(
)
nsRect
(
nsPoint
(
0
0
)
mBuilder
.
RootReferenceFrame
(
)
-
>
GetSize
(
)
)
mBuilder
.
RootReferenceFrame
(
)
-
>
GetVisualOverflowRectRelativeToSelf
(
)
aBackstop
)
;
mBuilder
.
SetPartialUpdate
(
false
)
;
}
else
{
}
MergeDisplayLists
(
&
modifiedDL
&
mList
&
mList
)
;
merged
=
true
;
}
mBuilder
.
LeavePresShell
(
mBuilder
.
RootReferenceFrame
(
)
&
mList
)
;
for
(
nsIFrame
*
f
:
modifiedFrames
)
{
if
(
f
)
{
f
-
>
SetFrameIsModified
(
false
)
;
}
}
for
(
nsIFrame
*
f
:
framesWithProps
)
{
f
-
>
SetHasOverrideDirtyRegion
(
false
)
;
f
-
>
DeleteProperty
(
nsDisplayListBuilder
:
:
DisplayListBuildingRect
(
)
)
;
f
-
>
DeleteProperty
(
nsDisplayListBuilder
:
:
DisplayListBuildingDisplayPortRect
(
)
)
;
}
return
merged
;
}
