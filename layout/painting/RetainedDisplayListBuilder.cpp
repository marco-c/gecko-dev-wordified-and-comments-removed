#
include
"
RetainedDisplayListBuilder
.
h
"
#
include
"
DisplayListChecker
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
nsPlaceholderFrame
.
h
"
#
include
"
nsSubDocumentFrame
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsCanvasFrame
.
h
"
using
namespace
mozilla
;
static
void
MarkFramesWithItemsAndImagesModified
(
nsDisplayList
*
aList
)
{
for
(
nsDisplayItem
*
i
=
aList
-
>
GetBottom
(
)
;
i
!
=
nullptr
;
i
=
i
-
>
GetAbove
(
)
)
{
if
(
!
i
-
>
HasDeletedFrame
(
)
&
&
i
-
>
CanBeReused
(
)
&
&
!
i
-
>
Frame
(
)
-
>
IsFrameModified
(
)
)
{
DisplayItemData
*
data
=
FrameLayerBuilder
:
:
GetOldDataFor
(
i
)
;
bool
invalidate
=
false
;
if
(
data
&
&
data
-
>
GetGeometry
(
)
)
{
invalidate
=
data
-
>
GetGeometry
(
)
-
>
InvalidateForSyncDecodeImages
(
)
;
}
else
if
(
!
(
i
-
>
GetFlags
(
)
&
TYPE_RENDERS_NO_IMAGES
)
)
{
invalidate
=
true
;
}
if
(
invalidate
)
{
i
-
>
FrameForInvalidation
(
)
-
>
MarkNeedsDisplayItemRebuild
(
)
;
if
(
i
-
>
GetDependentFrame
(
)
)
{
i
-
>
GetDependentFrame
(
)
-
>
MarkNeedsDisplayItemRebuild
(
)
;
}
}
}
if
(
i
-
>
GetChildren
(
)
)
{
MarkFramesWithItemsAndImagesModified
(
i
-
>
GetChildren
(
)
)
;
}
}
}
static
AnimatedGeometryRoot
*
SelectAGRForFrame
(
nsIFrame
*
aFrame
AnimatedGeometryRoot
*
aParentAGR
)
{
if
(
!
aFrame
-
>
IsStackingContext
(
)
|
|
!
aFrame
-
>
IsFixedPosContainingBlock
(
)
)
{
return
aParentAGR
;
}
if
(
!
aFrame
-
>
HasOverrideDirtyRegion
(
)
)
{
return
nullptr
;
}
nsDisplayListBuilder
:
:
DisplayListBuildingData
*
data
=
aFrame
-
>
GetProperty
(
nsDisplayListBuilder
:
:
DisplayListBuildingRect
(
)
)
;
return
data
&
&
data
-
>
mModifiedAGR
?
data
-
>
mModifiedAGR
.
get
(
)
:
nullptr
;
}
bool
RetainedDisplayListBuilder
:
:
PreProcessDisplayList
(
RetainedDisplayList
*
aList
AnimatedGeometryRoot
*
aAGR
uint32_t
aCallerKey
uint32_t
aNestingDepth
)
{
static
const
uint32_t
kMaxEdgeRatio
=
5
;
bool
initializeDAG
=
!
aList
-
>
mDAG
.
Length
(
)
;
if
(
!
initializeDAG
&
&
aList
-
>
mDAG
.
mDirectPredecessorList
.
Length
(
)
>
(
aList
-
>
mDAG
.
mNodesInfo
.
Length
(
)
*
kMaxEdgeRatio
)
)
{
return
false
;
}
nsDisplayList
saved
;
aList
-
>
mOldItems
.
SetCapacity
(
aList
-
>
Count
(
)
)
;
MOZ_ASSERT
(
aList
-
>
mOldItems
.
IsEmpty
(
)
)
;
while
(
nsDisplayItem
*
item
=
aList
-
>
RemoveBottom
(
)
)
{
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
item
-
>
mMergedItem
=
false
;
item
-
>
mPreProcessedItem
=
true
;
#
endif
if
(
item
-
>
HasDeletedFrame
(
)
|
|
!
item
-
>
CanBeReused
(
)
)
{
size_t
i
=
aList
-
>
mOldItems
.
Length
(
)
;
aList
-
>
mOldItems
.
AppendElement
(
OldItemInfo
(
nullptr
)
)
;
item
-
>
Destroy
(
&
mBuilder
)
;
if
(
initializeDAG
)
{
if
(
i
=
=
0
)
{
aList
-
>
mDAG
.
AddNode
(
Span
<
const
MergedListIndex
>
(
)
)
;
}
else
{
MergedListIndex
previous
(
i
-
1
)
;
aList
-
>
mDAG
.
AddNode
(
Span
<
const
MergedListIndex
>
(
&
previous
1
)
)
;
}
}
continue
;
}
size_t
i
=
aList
-
>
mOldItems
.
Length
(
)
;
aList
-
>
mOldItems
.
AppendElement
(
OldItemInfo
(
item
)
)
;
item
-
>
SetOldListIndex
(
aList
OldListIndex
(
i
)
aCallerKey
aNestingDepth
)
;
if
(
initializeDAG
)
{
if
(
i
=
=
0
)
{
aList
-
>
mDAG
.
AddNode
(
Span
<
const
MergedListIndex
>
(
)
)
;
}
else
{
MergedListIndex
previous
(
i
-
1
)
;
aList
-
>
mDAG
.
AddNode
(
Span
<
const
MergedListIndex
>
(
&
previous
1
)
)
;
}
}
nsIFrame
*
f
=
item
-
>
Frame
(
)
;
if
(
item
-
>
GetChildren
(
)
)
{
if
(
!
PreProcessDisplayList
(
item
-
>
GetChildren
(
)
SelectAGRForFrame
(
f
aAGR
)
item
-
>
GetPerFrameKey
(
)
aNestingDepth
+
1
)
)
{
return
false
;
}
}
if
(
aAGR
&
&
item
-
>
GetAnimatedGeometryRoot
(
)
-
>
GetAsyncAGR
(
)
!
=
aAGR
)
{
mBuilder
.
MarkFrameForDisplayIfVisible
(
f
mBuilder
.
RootReferenceFrame
(
)
)
;
}
item
-
>
RestoreState
(
)
;
}
MOZ_ASSERT
(
aList
-
>
mOldItems
.
Length
(
)
=
=
aList
-
>
mDAG
.
Length
(
)
)
;
aList
-
>
RestoreState
(
)
;
return
true
;
}
void
RetainedDisplayListBuilder
:
:
IncrementSubDocPresShellPaintCount
(
nsDisplayItem
*
aItem
)
{
MOZ_ASSERT
(
aItem
-
>
GetType
(
)
=
=
DisplayItemType
:
:
TYPE_SUBDOCUMENT
)
;
nsSubDocumentFrame
*
subDocFrame
=
static_cast
<
nsDisplaySubDocument
*
>
(
aItem
)
-
>
SubDocumentFrame
(
)
;
MOZ_ASSERT
(
subDocFrame
)
;
nsIPresShell
*
presShell
=
subDocFrame
-
>
GetSubdocumentPresShellForPainting
(
0
)
;
MOZ_ASSERT
(
presShell
)
;
mBuilder
.
IncrementPresShellPaintCount
(
presShell
)
;
}
static
bool
AnyContentAncestorModified
(
nsIFrame
*
aFrame
nsIFrame
*
aStopAtFrame
=
nullptr
)
{
for
(
nsIFrame
*
f
=
aFrame
;
f
;
f
=
nsLayoutUtils
:
:
GetParentOrPlaceholderForCrossDoc
(
f
)
)
{
if
(
f
-
>
IsFrameModified
(
)
)
{
return
true
;
}
if
(
aStopAtFrame
&
&
f
=
=
aStopAtFrame
)
{
break
;
}
}
return
false
;
}
static
void
UpdateASR
(
nsDisplayItem
*
aItem
Maybe
<
const
ActiveScrolledRoot
*
>
&
aContainerASR
)
{
if
(
!
aContainerASR
)
{
return
;
}
nsDisplayWrapList
*
wrapList
=
aItem
-
>
AsDisplayWrapList
(
)
;
if
(
!
wrapList
)
{
aItem
-
>
SetActiveScrolledRoot
(
aContainerASR
.
value
(
)
)
;
return
;
}
wrapList
-
>
SetActiveScrolledRoot
(
ActiveScrolledRoot
:
:
PickAncestor
(
wrapList
-
>
GetFrameActiveScrolledRoot
(
)
aContainerASR
.
value
(
)
)
)
;
}
void
OldItemInfo
:
:
AddedMatchToMergedList
(
RetainedDisplayListBuilder
*
aBuilder
MergedListIndex
aIndex
)
{
mItem
-
>
Destroy
(
aBuilder
-
>
Builder
(
)
)
;
AddedToMergedList
(
aIndex
)
;
}
void
OldItemInfo
:
:
Discard
(
RetainedDisplayListBuilder
*
aBuilder
nsTArray
<
MergedListIndex
>
&
&
aDirectPredecessors
)
{
MOZ_ASSERT
(
!
IsUsed
(
)
)
;
mUsed
=
mDiscarded
=
true
;
mDirectPredecessors
=
std
:
:
move
(
aDirectPredecessors
)
;
if
(
mItem
)
{
mItem
-
>
Destroy
(
aBuilder
-
>
Builder
(
)
)
;
}
mItem
=
nullptr
;
}
bool
OldItemInfo
:
:
IsChanged
(
)
{
return
!
mItem
|
|
mItem
-
>
HasDeletedFrame
(
)
|
|
!
mItem
-
>
CanBeReused
(
)
;
}
class
MergeState
{
public
:
MergeState
(
RetainedDisplayListBuilder
*
aBuilder
RetainedDisplayList
&
aOldList
uint32_t
aOuterKey
)
:
mBuilder
(
aBuilder
)
mOldList
(
&
aOldList
)
mOldItems
(
std
:
:
move
(
aOldList
.
mOldItems
)
)
mOldDAG
(
std
:
:
move
(
*
reinterpret_cast
<
DirectedAcyclicGraph
<
OldListUnits
>
*
>
(
&
aOldList
.
mDAG
)
)
)
mOuterKey
(
aOuterKey
)
mResultIsModified
(
false
)
{
mMergedDAG
.
EnsureCapacityFor
(
mOldDAG
)
;
}
MergedListIndex
ProcessItemFromNewList
(
nsDisplayItem
*
aNewItem
const
Maybe
<
MergedListIndex
>
&
aPreviousItem
)
{
OldListIndex
oldIndex
;
if
(
!
HasModifiedFrame
(
aNewItem
)
&
&
HasMatchingItemInOldList
(
aNewItem
&
oldIndex
)
)
{
nsDisplayItem
*
oldItem
=
mOldItems
[
oldIndex
.
val
]
.
mItem
;
MOZ_DIAGNOSTIC_ASSERT
(
oldItem
-
>
GetPerFrameKey
(
)
=
=
aNewItem
-
>
GetPerFrameKey
(
)
&
&
oldItem
-
>
Frame
(
)
=
=
aNewItem
-
>
Frame
(
)
)
;
if
(
!
mOldItems
[
oldIndex
.
val
]
.
IsChanged
(
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mOldItems
[
oldIndex
.
val
]
.
IsUsed
(
)
)
;
if
(
aNewItem
-
>
GetChildren
(
)
)
{
Maybe
<
const
ActiveScrolledRoot
*
>
containerASRForChildren
;
if
(
mBuilder
-
>
MergeDisplayLists
(
aNewItem
-
>
GetChildren
(
)
oldItem
-
>
GetChildren
(
)
aNewItem
-
>
GetChildren
(
)
containerASRForChildren
aNewItem
-
>
GetPerFrameKey
(
)
)
)
{
mResultIsModified
=
true
;
}
UpdateASR
(
aNewItem
containerASRForChildren
)
;
aNewItem
-
>
UpdateBounds
(
mBuilder
-
>
Builder
(
)
)
;
}
AutoTArray
<
MergedListIndex
2
>
directPredecessors
=
ProcessPredecessorsOfOldNode
(
oldIndex
)
;
MergedListIndex
newIndex
=
AddNewNode
(
aNewItem
Some
(
oldIndex
)
directPredecessors
aPreviousItem
)
;
mOldItems
[
oldIndex
.
val
]
.
AddedMatchToMergedList
(
mBuilder
newIndex
)
;
return
newIndex
;
}
}
mResultIsModified
=
true
;
return
AddNewNode
(
aNewItem
Nothing
(
)
Span
<
MergedListIndex
>
(
)
aPreviousItem
)
;
}
RetainedDisplayList
Finalize
(
)
{
for
(
size_t
i
=
0
;
i
<
mOldDAG
.
Length
(
)
;
i
+
+
)
{
if
(
mOldItems
[
i
]
.
IsUsed
(
)
)
{
continue
;
}
AutoTArray
<
MergedListIndex
2
>
directPredecessors
=
ResolveNodeIndexesOldToMerged
(
mOldDAG
.
GetDirectPredecessors
(
OldListIndex
(
i
)
)
)
;
ProcessOldNode
(
OldListIndex
(
i
)
std
:
:
move
(
directPredecessors
)
)
;
}
RetainedDisplayList
result
;
result
.
AppendToTop
(
&
mMergedItems
)
;
result
.
mDAG
=
std
:
:
move
(
mMergedDAG
)
;
return
result
;
}
bool
HasMatchingItemInOldList
(
nsDisplayItem
*
aItem
OldListIndex
*
aOutIndex
)
{
nsIFrame
:
:
DisplayItemArray
*
items
=
aItem
-
>
Frame
(
)
-
>
GetProperty
(
nsIFrame
:
:
DisplayItems
(
)
)
;
for
(
nsDisplayItem
*
i
:
*
items
)
{
if
(
i
!
=
aItem
&
&
i
-
>
Frame
(
)
=
=
aItem
-
>
Frame
(
)
&
&
i
-
>
GetPerFrameKey
(
)
=
=
aItem
-
>
GetPerFrameKey
(
)
)
{
if
(
i
-
>
GetOldListIndex
(
mOldList
mOuterKey
aOutIndex
)
)
{
return
true
;
}
}
}
return
false
;
}
bool
HasModifiedFrame
(
nsDisplayItem
*
aItem
)
{
return
AnyContentAncestorModified
(
aItem
-
>
FrameForInvalidation
(
)
)
;
}
void
UpdateContainerASR
(
nsDisplayItem
*
aItem
)
{
const
ActiveScrolledRoot
*
itemClipASR
=
aItem
-
>
GetClipChain
(
)
?
aItem
-
>
GetClipChain
(
)
-
>
mASR
:
nullptr
;
const
ActiveScrolledRoot
*
finiteBoundsASR
=
ActiveScrolledRoot
:
:
PickDescendant
(
itemClipASR
aItem
-
>
GetActiveScrolledRoot
(
)
)
;
if
(
!
mContainerASR
)
{
mContainerASR
=
Some
(
finiteBoundsASR
)
;
}
else
{
mContainerASR
=
Some
(
ActiveScrolledRoot
:
:
PickAncestor
(
mContainerASR
.
value
(
)
finiteBoundsASR
)
)
;
}
}
MergedListIndex
AddNewNode
(
nsDisplayItem
*
aItem
const
Maybe
<
OldListIndex
>
&
aOldIndex
Span
<
const
MergedListIndex
>
aDirectPredecessors
const
Maybe
<
MergedListIndex
>
&
aExtraDirectPredecessor
)
{
UpdateContainerASR
(
aItem
)
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
nsIFrame
:
:
DisplayItemArray
*
items
=
aItem
-
>
Frame
(
)
-
>
GetProperty
(
nsIFrame
:
:
DisplayItems
(
)
)
;
for
(
nsDisplayItem
*
i
:
*
items
)
{
if
(
i
-
>
Frame
(
)
=
=
aItem
-
>
Frame
(
)
&
&
i
-
>
GetPerFrameKey
(
)
=
=
aItem
-
>
GetPerFrameKey
(
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
i
-
>
mMergedItem
)
;
}
}
aItem
-
>
mMergedItem
=
true
;
aItem
-
>
mPreProcessedItem
=
false
;
#
endif
mMergedItems
.
AppendToTop
(
aItem
)
;
MergedListIndex
newIndex
=
mMergedDAG
.
AddNode
(
aDirectPredecessors
aExtraDirectPredecessor
)
;
return
newIndex
;
}
void
ProcessOldNode
(
OldListIndex
aNode
nsTArray
<
MergedListIndex
>
&
&
aDirectPredecessors
)
{
nsDisplayItem
*
item
=
mOldItems
[
aNode
.
val
]
.
mItem
;
if
(
mOldItems
[
aNode
.
val
]
.
IsChanged
(
)
|
|
HasModifiedFrame
(
item
)
)
{
mOldItems
[
aNode
.
val
]
.
Discard
(
mBuilder
std
:
:
move
(
aDirectPredecessors
)
)
;
mResultIsModified
=
true
;
}
else
{
if
(
item
-
>
GetChildren
(
)
)
{
Maybe
<
const
ActiveScrolledRoot
*
>
containerASRForChildren
;
nsDisplayList
empty
;
if
(
mBuilder
-
>
MergeDisplayLists
(
&
empty
item
-
>
GetChildren
(
)
item
-
>
GetChildren
(
)
containerASRForChildren
item
-
>
GetPerFrameKey
(
)
)
)
{
mResultIsModified
=
true
;
}
UpdateASR
(
item
containerASRForChildren
)
;
item
-
>
UpdateBounds
(
mBuilder
-
>
Builder
(
)
)
;
}
if
(
item
-
>
GetType
(
)
=
=
DisplayItemType
:
:
TYPE_SUBDOCUMENT
)
{
mBuilder
-
>
IncrementSubDocPresShellPaintCount
(
item
)
;
}
item
-
>
SetReused
(
true
)
;
mOldItems
[
aNode
.
val
]
.
AddedToMergedList
(
AddNewNode
(
item
Some
(
aNode
)
aDirectPredecessors
Nothing
(
)
)
)
;
}
}
struct
PredecessorStackItem
{
PredecessorStackItem
(
OldListIndex
aNode
Span
<
OldListIndex
>
aPredecessors
)
:
mNode
(
aNode
)
mDirectPredecessors
(
aPredecessors
)
mCurrentPredecessorIndex
(
0
)
{
}
bool
IsFinished
(
)
{
return
mCurrentPredecessorIndex
=
=
mDirectPredecessors
.
Length
(
)
;
}
OldListIndex
GetAndIncrementCurrentPredecessor
(
)
{
return
mDirectPredecessors
[
mCurrentPredecessorIndex
+
+
]
;
}
OldListIndex
mNode
;
Span
<
OldListIndex
>
mDirectPredecessors
;
size_t
mCurrentPredecessorIndex
;
}
;
AutoTArray
<
MergedListIndex
2
>
ProcessPredecessorsOfOldNode
(
OldListIndex
aNode
)
{
AutoTArray
<
PredecessorStackItem
256
>
mStack
;
mStack
.
AppendElement
(
PredecessorStackItem
(
aNode
mOldDAG
.
GetDirectPredecessors
(
aNode
)
)
)
;
while
(
true
)
{
if
(
mStack
.
LastElement
(
)
.
IsFinished
(
)
)
{
PredecessorStackItem
item
=
mStack
.
PopLastElement
(
)
;
AutoTArray
<
MergedListIndex
2
>
result
=
ResolveNodeIndexesOldToMerged
(
item
.
mDirectPredecessors
)
;
if
(
mStack
.
IsEmpty
(
)
)
{
return
result
;
}
else
{
ProcessOldNode
(
item
.
mNode
std
:
:
move
(
result
)
)
;
}
}
else
{
OldListIndex
currentIndex
=
mStack
.
LastElement
(
)
.
GetAndIncrementCurrentPredecessor
(
)
;
if
(
!
mOldItems
[
currentIndex
.
val
]
.
IsUsed
(
)
)
{
mStack
.
AppendElement
(
PredecessorStackItem
(
currentIndex
mOldDAG
.
GetDirectPredecessors
(
currentIndex
)
)
)
;
}
}
}
}
AutoTArray
<
MergedListIndex
2
>
ResolveNodeIndexesOldToMerged
(
Span
<
OldListIndex
>
aDirectPredecessors
)
{
AutoTArray
<
MergedListIndex
2
>
result
;
result
.
SetCapacity
(
aDirectPredecessors
.
Length
(
)
)
;
for
(
OldListIndex
index
:
aDirectPredecessors
)
{
OldItemInfo
&
oldItem
=
mOldItems
[
index
.
val
]
;
if
(
oldItem
.
IsDiscarded
(
)
)
{
for
(
MergedListIndex
inner
:
oldItem
.
mDirectPredecessors
)
{
if
(
!
result
.
Contains
(
inner
)
)
{
result
.
AppendElement
(
inner
)
;
}
}
}
else
{
result
.
AppendElement
(
oldItem
.
mIndex
)
;
}
}
return
result
;
}
RetainedDisplayListBuilder
*
mBuilder
;
RetainedDisplayList
*
mOldList
;
Maybe
<
const
ActiveScrolledRoot
*
>
mContainerASR
;
nsTArray
<
OldItemInfo
>
mOldItems
;
DirectedAcyclicGraph
<
OldListUnits
>
mOldDAG
;
nsDisplayList
mMergedItems
;
DirectedAcyclicGraph
<
MergedListUnits
>
mMergedDAG
;
uint32_t
mOuterKey
;
bool
mResultIsModified
;
}
;
bool
RetainedDisplayListBuilder
:
:
MergeDisplayLists
(
nsDisplayList
*
aNewList
RetainedDisplayList
*
aOldList
RetainedDisplayList
*
aOutList
mozilla
:
:
Maybe
<
const
mozilla
:
:
ActiveScrolledRoot
*
>
&
aOutContainerASR
uint32_t
aOuterKey
)
{
MergeState
merge
(
this
*
aOldList
aOuterKey
)
;
Maybe
<
MergedListIndex
>
previousItemIndex
;
while
(
nsDisplayItem
*
item
=
aNewList
-
>
RemoveBottom
(
)
)
{
previousItemIndex
=
Some
(
merge
.
ProcessItemFromNewList
(
item
previousItemIndex
)
)
;
}
*
aOutList
=
merge
.
Finalize
(
)
;
aOutContainerASR
=
merge
.
mContainerASR
;
return
merge
.
mResultIsModified
;
}
static
void
TakeAndAddModifiedAndFramesWithPropsFromRootFrame
(
nsTArray
<
nsIFrame
*
>
*
aModifiedFrames
nsTArray
<
nsIFrame
*
>
*
aFramesWithProps
nsIFrame
*
aRootFrame
)
{
MOZ_ASSERT
(
aRootFrame
)
;
nsTArray
<
nsIFrame
*
>
*
frames
=
aRootFrame
-
>
GetProperty
(
nsIFrame
:
:
ModifiedFrameList
(
)
)
;
if
(
frames
)
{
for
(
nsIFrame
*
f
:
*
frames
)
{
if
(
f
)
{
aModifiedFrames
-
>
AppendElement
(
f
)
;
}
}
frames
-
>
Clear
(
)
;
}
frames
=
aRootFrame
-
>
GetProperty
(
nsIFrame
:
:
OverriddenDirtyRectFrameList
(
)
)
;
if
(
frames
)
{
for
(
nsIFrame
*
f
:
*
frames
)
{
if
(
f
)
{
aFramesWithProps
-
>
AppendElement
(
f
)
;
}
}
frames
-
>
Clear
(
)
;
}
}
struct
CbData
{
nsDisplayListBuilder
*
builder
;
nsTArray
<
nsIFrame
*
>
*
modifiedFrames
;
nsTArray
<
nsIFrame
*
>
*
framesWithProps
;
}
;
static
nsIFrame
*
GetRootFrameForPainting
(
nsDisplayListBuilder
*
aBuilder
nsIDocument
*
aDocument
)
{
nsIPresShell
*
presShell
=
aDocument
-
>
GetShell
(
)
;
if
(
!
presShell
)
{
return
nullptr
;
}
nsView
*
rootView
=
presShell
-
>
GetViewManager
(
)
-
>
GetRootView
(
)
;
if
(
!
rootView
)
{
return
nullptr
;
}
nsView
*
innerView
=
rootView
-
>
GetParent
(
)
;
if
(
!
innerView
)
{
return
nullptr
;
}
nsView
*
subDocView
=
innerView
-
>
GetParent
(
)
;
if
(
!
subDocView
)
{
return
nullptr
;
}
nsIFrame
*
subDocFrame
=
subDocView
-
>
GetFrame
(
)
;
if
(
!
subDocFrame
)
{
return
nullptr
;
}
nsSubDocumentFrame
*
subdocumentFrame
=
do_QueryFrame
(
subDocFrame
)
;
MOZ_ASSERT
(
subdocumentFrame
)
;
presShell
=
subdocumentFrame
-
>
GetSubdocumentPresShellForPainting
(
aBuilder
-
>
IsIgnoringPaintSuppression
(
)
?
nsSubDocumentFrame
:
:
IGNORE_PAINT_SUPPRESSION
:
0
)
;
return
presShell
?
presShell
-
>
GetRootFrame
(
)
:
nullptr
;
}
static
bool
SubDocEnumCb
(
nsIDocument
*
aDocument
void
*
aData
)
{
MOZ_ASSERT
(
aDocument
)
;
MOZ_ASSERT
(
aData
)
;
CbData
*
data
=
static_cast
<
CbData
*
>
(
aData
)
;
nsIFrame
*
rootFrame
=
GetRootFrameForPainting
(
data
-
>
builder
aDocument
)
;
if
(
rootFrame
)
{
TakeAndAddModifiedAndFramesWithPropsFromRootFrame
(
data
-
>
modifiedFrames
data
-
>
framesWithProps
rootFrame
)
;
nsIDocument
*
innerDoc
=
rootFrame
-
>
PresShell
(
)
-
>
GetDocument
(
)
;
if
(
innerDoc
)
{
innerDoc
-
>
EnumerateSubDocuments
(
SubDocEnumCb
aData
)
;
}
}
return
true
;
}
static
void
GetModifiedAndFramesWithProps
(
nsDisplayListBuilder
*
aBuilder
nsTArray
<
nsIFrame
*
>
*
aOutModifiedFrames
nsTArray
<
nsIFrame
*
>
*
aOutFramesWithProps
)
{
MOZ_ASSERT
(
aBuilder
-
>
RootReferenceFrame
(
)
)
;
TakeAndAddModifiedAndFramesWithPropsFromRootFrame
(
aOutModifiedFrames
aOutFramesWithProps
aBuilder
-
>
RootReferenceFrame
(
)
)
;
nsIDocument
*
rootdoc
=
aBuilder
-
>
RootReferenceFrame
(
)
-
>
PresContext
(
)
-
>
Document
(
)
;
if
(
rootdoc
)
{
CbData
data
=
{
aBuilder
aOutModifiedFrames
aOutFramesWithProps
}
;
rootdoc
-
>
EnumerateSubDocuments
(
SubDocEnumCb
&
data
)
;
}
}
#
if
CRR_DEBUG
#
define
CRR_LOG
(
.
.
.
)
printf_stderr
(
__VA_ARGS__
)
#
else
#
define
CRR_LOG
(
.
.
.
)
#
endif
static
nsDisplayItem
*
GetFirstDisplayItemWithChildren
(
nsIFrame
*
aFrame
)
{
nsIFrame
:
:
DisplayItemArray
*
items
=
aFrame
-
>
GetProperty
(
nsIFrame
:
:
DisplayItems
(
)
)
;
if
(
!
items
)
{
return
nullptr
;
}
for
(
nsDisplayItem
*
i
:
*
items
)
{
if
(
i
-
>
GetChildren
(
)
)
{
return
i
;
}
}
return
nullptr
;
}
static
bool
IsInPreserve3DContext
(
const
nsIFrame
*
aFrame
)
{
return
aFrame
-
>
Extend3DContext
(
)
|
|
aFrame
-
>
Combines3DTransformWithAncestors
(
)
;
}
static
bool
ProcessFrameInternal
(
nsIFrame
*
aFrame
nsDisplayListBuilder
&
aBuilder
AnimatedGeometryRoot
*
*
aAGR
nsRect
&
aOverflow
nsIFrame
*
aStopAtFrame
nsTArray
<
nsIFrame
*
>
&
aOutFramesWithProps
const
bool
aStopAtStackingContext
)
{
nsIFrame
*
currentFrame
=
aFrame
;
while
(
currentFrame
!
=
aStopAtFrame
)
{
CRR_LOG
(
"
currentFrame
:
%
p
(
placeholder
=
%
d
)
aOverflow
:
%
d
%
d
%
d
%
d
\
n
"
currentFrame
!
aStopAtStackingContext
aOverflow
.
x
aOverflow
.
y
aOverflow
.
width
aOverflow
.
height
)
;
nsIFrame
*
placeholder
=
currentFrame
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
?
currentFrame
-
>
GetPlaceholderFrame
(
)
:
nullptr
;
if
(
placeholder
)
{
nsRect
placeholderOverflow
=
aOverflow
+
currentFrame
-
>
GetOffsetTo
(
placeholder
)
;
CRR_LOG
(
"
Processing
placeholder
%
p
for
OOF
frame
%
p
\
n
"
placeholder
currentFrame
)
;
CRR_LOG
(
"
OOF
frame
draw
area
:
%
d
%
d
%
d
%
d
\
n
"
placeholderOverflow
.
x
placeholderOverflow
.
y
placeholderOverflow
.
width
placeholderOverflow
.
height
)
;
AnimatedGeometryRoot
*
dummyAGR
=
nullptr
;
nsIFrame
*
ancestor
=
nsLayoutUtils
:
:
FindNearestCommonAncestorFrame
(
currentFrame
-
>
GetParent
(
)
placeholder
-
>
GetParent
(
)
)
;
if
(
!
ProcessFrameInternal
(
placeholder
aBuilder
&
dummyAGR
placeholderOverflow
ancestor
aOutFramesWithProps
false
)
)
{
return
false
;
}
}
aOverflow
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
currentFrame
aOverflow
aStopAtFrame
nullptr
nullptr
true
&
currentFrame
)
;
if
(
IsInPreserve3DContext
(
currentFrame
)
)
{
return
false
;
}
MOZ_ASSERT
(
currentFrame
)
;
if
(
nsLayoutUtils
:
:
FrameHasDisplayPort
(
currentFrame
)
)
{
CRR_LOG
(
"
Frame
belongs
to
displayport
frame
%
p
\
n
"
currentFrame
)
;
nsIScrollableFrame
*
sf
=
do_QueryFrame
(
currentFrame
)
;
MOZ_ASSERT
(
sf
)
;
nsRect
displayPort
;
DebugOnly
<
bool
>
hasDisplayPort
=
nsLayoutUtils
:
:
GetDisplayPort
(
currentFrame
-
>
GetContent
(
)
&
displayPort
RelativeTo
:
:
ScrollPort
)
;
MOZ_ASSERT
(
hasDisplayPort
)
;
nsRect
r
=
aOverflow
-
sf
-
>
GetScrollPortRect
(
)
.
TopLeft
(
)
;
r
.
IntersectRect
(
r
displayPort
)
;
if
(
!
r
.
IsEmpty
(
)
)
{
nsRect
*
rect
=
currentFrame
-
>
GetProperty
(
nsDisplayListBuilder
:
:
DisplayListBuildingDisplayPortRect
(
)
)
;
if
(
!
rect
)
{
rect
=
new
nsRect
(
)
;
currentFrame
-
>
SetProperty
(
nsDisplayListBuilder
:
:
DisplayListBuildingDisplayPortRect
(
)
rect
)
;
currentFrame
-
>
SetHasOverrideDirtyRegion
(
true
)
;
aOutFramesWithProps
.
AppendElement
(
currentFrame
)
;
}
rect
-
>
UnionRect
(
*
rect
r
)
;
CRR_LOG
(
"
Adding
area
to
displayport
draw
area
:
%
d
%
d
%
d
%
d
\
n
"
r
.
x
r
.
y
r
.
width
r
.
height
)
;
aOverflow
=
sf
-
>
GetScrollPortRect
(
)
;
}
else
{
aOverflow
.
SetEmpty
(
)
;
}
}
else
{
aOverflow
.
IntersectRect
(
aOverflow
currentFrame
-
>
GetVisualOverflowRectRelativeToSelf
(
)
)
;
}
if
(
aOverflow
.
IsEmpty
(
)
)
{
break
;
}
if
(
currentFrame
!
=
aBuilder
.
RootReferenceFrame
(
)
&
&
currentFrame
-
>
IsStackingContext
(
)
&
&
currentFrame
-
>
IsFixedPosContainingBlock
(
)
)
{
CRR_LOG
(
"
Frame
belongs
to
stacking
context
frame
%
p
\
n
"
currentFrame
)
;
nsDisplayItem
*
wrapperItem
=
GetFirstDisplayItemWithChildren
(
currentFrame
)
;
if
(
!
wrapperItem
)
{
continue
;
}
nsDisplayListBuilder
:
:
DisplayListBuildingData
*
data
=
currentFrame
-
>
GetProperty
(
nsDisplayListBuilder
:
:
DisplayListBuildingRect
(
)
)
;
if
(
!
data
)
{
data
=
new
nsDisplayListBuilder
:
:
DisplayListBuildingData
(
)
;
currentFrame
-
>
SetProperty
(
nsDisplayListBuilder
:
:
DisplayListBuildingRect
(
)
data
)
;
currentFrame
-
>
SetHasOverrideDirtyRegion
(
true
)
;
aOutFramesWithProps
.
AppendElement
(
currentFrame
)
;
}
CRR_LOG
(
"
Adding
area
to
stacking
context
draw
area
:
%
d
%
d
%
d
%
d
\
n
"
aOverflow
.
x
aOverflow
.
y
aOverflow
.
width
aOverflow
.
height
)
;
data
-
>
mDirtyRect
.
UnionRect
(
data
-
>
mDirtyRect
aOverflow
)
;
if
(
!
aStopAtStackingContext
)
{
continue
;
}
nsRect
previousVisible
=
wrapperItem
-
>
GetBuildingRectForChildren
(
)
;
if
(
wrapperItem
-
>
ReferenceFrameForChildren
(
)
=
=
wrapperItem
-
>
ReferenceFrame
(
)
)
{
previousVisible
-
=
wrapperItem
-
>
ToReferenceFrame
(
)
;
}
else
{
MOZ_ASSERT
(
wrapperItem
-
>
ReferenceFrameForChildren
(
)
=
=
wrapperItem
-
>
Frame
(
)
)
;
}
if
(
!
previousVisible
.
Contains
(
aOverflow
)
)
{
continue
;
}
if
(
!
data
-
>
mModifiedAGR
)
{
data
-
>
mModifiedAGR
=
*
aAGR
;
}
else
if
(
data
-
>
mModifiedAGR
!
=
*
aAGR
)
{
data
-
>
mDirtyRect
=
currentFrame
-
>
GetVisualOverflowRectRelativeToSelf
(
)
;
CRR_LOG
(
"
Found
multiple
modified
AGRs
within
this
stacking
context
giving
up
\
n
"
)
;
}
aOverflow
.
SetEmpty
(
)
;
*
aAGR
=
nullptr
;
break
;
}
}
return
true
;
}
bool
RetainedDisplayListBuilder
:
:
ProcessFrame
(
nsIFrame
*
aFrame
nsDisplayListBuilder
&
aBuilder
nsIFrame
*
aStopAtFrame
nsTArray
<
nsIFrame
*
>
&
aOutFramesWithProps
const
bool
aStopAtStackingContext
nsRect
*
aOutDirty
AnimatedGeometryRoot
*
*
aOutModifiedAGR
)
{
if
(
aFrame
-
>
HasOverrideDirtyRegion
(
)
)
{
aOutFramesWithProps
.
AppendElement
(
aFrame
)
;
}
if
(
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_IN_POPUP
)
)
{
return
true
;
}
AnimatedGeometryRoot
*
agr
=
aBuilder
.
FindAnimatedGeometryRootFor
(
aFrame
)
-
>
GetAsyncAGR
(
)
;
CRR_LOG
(
"
Processing
frame
%
p
with
agr
%
p
\
n
"
aFrame
agr
-
>
mFrame
)
;
nsRect
overflow
=
aFrame
-
>
GetVisualOverflowRectRelativeToSelf
(
)
;
if
(
aFrame
=
=
aBuilder
.
GetCaretFrame
(
)
)
{
overflow
.
UnionRect
(
overflow
aBuilder
.
GetCaretRect
(
)
)
;
}
if
(
!
ProcessFrameInternal
(
aFrame
aBuilder
&
agr
overflow
aStopAtFrame
aOutFramesWithProps
aStopAtStackingContext
)
)
{
return
false
;
}
if
(
!
overflow
.
IsEmpty
(
)
)
{
aOutDirty
-
>
UnionRect
(
*
aOutDirty
overflow
)
;
CRR_LOG
(
"
Adding
area
to
root
draw
area
:
%
d
%
d
%
d
%
d
\
n
"
overflow
.
x
overflow
.
y
overflow
.
width
overflow
.
height
)
;
if
(
!
*
aOutModifiedAGR
)
{
CRR_LOG
(
"
Setting
%
p
as
root
stacking
context
AGR
\
n
"
agr
)
;
*
aOutModifiedAGR
=
agr
;
}
else
if
(
agr
&
&
*
aOutModifiedAGR
!
=
agr
)
{
CRR_LOG
(
"
Found
multiple
AGRs
in
root
stacking
context
giving
up
\
n
"
)
;
return
false
;
}
}
return
true
;
}
static
void
AddFramesForContainingBlock
(
nsIFrame
*
aBlock
const
nsFrameList
&
aFrames
nsTArray
<
nsIFrame
*
>
&
aExtraFrames
)
{
for
(
nsIFrame
*
f
:
aFrames
)
{
if
(
!
f
-
>
IsFrameModified
(
)
&
&
AnyContentAncestorModified
(
f
aBlock
)
)
{
CRR_LOG
(
"
Adding
invalid
OOF
%
p
\
n
"
f
)
;
aExtraFrames
.
AppendElement
(
f
)
;
}
}
}
void
FindContainingBlocks
(
nsIFrame
*
aFrame
nsTArray
<
nsIFrame
*
>
&
aExtraFrames
)
{
for
(
nsIFrame
*
f
=
aFrame
;
f
;
f
=
nsLayoutUtils
:
:
GetParentOrPlaceholderForCrossDoc
(
f
)
)
{
if
(
f
-
>
ForceDescendIntoIfVisible
(
)
)
return
;
f
-
>
SetForceDescendIntoIfVisible
(
true
)
;
CRR_LOG
(
"
Considering
OOFs
for
%
p
\
n
"
f
)
;
AddFramesForContainingBlock
(
f
f
-
>
GetChildList
(
nsIFrame
:
:
kFloatList
)
aExtraFrames
)
;
AddFramesForContainingBlock
(
f
f
-
>
GetChildList
(
f
-
>
GetAbsoluteListID
(
)
)
aExtraFrames
)
;
}
}
bool
RetainedDisplayListBuilder
:
:
ComputeRebuildRegion
(
nsTArray
<
nsIFrame
*
>
&
aModifiedFrames
nsRect
*
aOutDirty
AnimatedGeometryRoot
*
*
aOutModifiedAGR
nsTArray
<
nsIFrame
*
>
&
aOutFramesWithProps
)
{
CRR_LOG
(
"
Computing
rebuild
regions
for
%
zu
frames
:
\
n
"
aModifiedFrames
.
Length
(
)
)
;
nsTArray
<
nsIFrame
*
>
extraFrames
;
for
(
nsIFrame
*
f
:
aModifiedFrames
)
{
MOZ_ASSERT
(
f
)
;
mBuilder
.
AddFrameMarkedForDisplayIfVisible
(
f
)
;
FindContainingBlocks
(
f
extraFrames
)
;
if
(
!
ProcessFrame
(
f
mBuilder
mBuilder
.
RootReferenceFrame
(
)
aOutFramesWithProps
true
aOutDirty
aOutModifiedAGR
)
)
{
return
false
;
}
}
for
(
nsIFrame
*
f
:
extraFrames
)
{
mBuilder
.
MarkFrameModifiedDuringBuilding
(
f
)
;
if
(
!
ProcessFrame
(
f
mBuilder
mBuilder
.
RootReferenceFrame
(
)
aOutFramesWithProps
true
aOutDirty
aOutModifiedAGR
)
)
{
return
false
;
}
}
return
true
;
}
static
bool
ShouldBuildPartial
(
nsTArray
<
nsIFrame
*
>
&
aModifiedFrames
)
{
if
(
aModifiedFrames
.
Length
(
)
>
gfxPrefs
:
:
LayoutRebuildFrameLimit
(
)
)
{
return
false
;
}
for
(
nsIFrame
*
f
:
aModifiedFrames
)
{
MOZ_ASSERT
(
f
)
;
const
LayoutFrameType
type
=
f
-
>
Type
(
)
;
if
(
type
=
=
LayoutFrameType
:
:
Viewport
|
|
type
=
=
LayoutFrameType
:
:
PageContent
|
|
type
=
=
LayoutFrameType
:
:
Canvas
|
|
type
=
=
LayoutFrameType
:
:
Scrollbar
)
{
return
false
;
}
}
return
true
;
}
static
void
ClearFrameProps
(
nsTArray
<
nsIFrame
*
>
&
aFrames
)
{
for
(
nsIFrame
*
f
:
aFrames
)
{
if
(
f
-
>
HasOverrideDirtyRegion
(
)
)
{
f
-
>
SetHasOverrideDirtyRegion
(
false
)
;
f
-
>
DeleteProperty
(
nsDisplayListBuilder
:
:
DisplayListBuildingRect
(
)
)
;
f
-
>
DeleteProperty
(
nsDisplayListBuilder
:
:
DisplayListBuildingDisplayPortRect
(
)
)
;
}
f
-
>
SetFrameIsModified
(
false
)
;
}
}
class
AutoClearFramePropsArray
{
public
:
AutoClearFramePropsArray
(
)
=
default
;
~
AutoClearFramePropsArray
(
)
{
ClearFrameProps
(
mFrames
)
;
}
nsTArray
<
nsIFrame
*
>
&
Frames
(
)
{
return
mFrames
;
}
bool
IsEmpty
(
)
const
{
return
mFrames
.
IsEmpty
(
)
;
}
private
:
nsTArray
<
nsIFrame
*
>
mFrames
;
}
;
void
RetainedDisplayListBuilder
:
:
ClearFramesWithProps
(
)
{
AutoClearFramePropsArray
modifiedFrames
;
AutoClearFramePropsArray
framesWithProps
;
GetModifiedAndFramesWithProps
(
&
mBuilder
&
modifiedFrames
.
Frames
(
)
&
framesWithProps
.
Frames
(
)
)
;
}
auto
RetainedDisplayListBuilder
:
:
AttemptPartialUpdate
(
nscolor
aBackstop
mozilla
:
:
DisplayListChecker
*
aChecker
)
-
>
PartialUpdateResult
{
mBuilder
.
RemoveModifiedWindowRegions
(
)
;
mBuilder
.
ClearWindowOpaqueRegion
(
)
;
if
(
mBuilder
.
ShouldSyncDecodeImages
(
)
)
{
MarkFramesWithItemsAndImagesModified
(
&
mList
)
;
}
mBuilder
.
EnterPresShell
(
mBuilder
.
RootReferenceFrame
(
)
)
;
AutoClearFramePropsArray
modifiedFrames
;
AutoClearFramePropsArray
framesWithProps
;
GetModifiedAndFramesWithProps
(
&
mBuilder
&
modifiedFrames
.
Frames
(
)
&
framesWithProps
.
Frames
(
)
)
;
bool
shouldBuildPartial
=
!
mList
.
IsEmpty
(
)
&
&
ShouldBuildPartial
(
modifiedFrames
.
Frames
(
)
)
;
if
(
mBuilder
.
DisablePartialUpdates
(
)
)
{
shouldBuildPartial
=
false
;
mBuilder
.
SetDisablePartialUpdates
(
false
)
;
}
if
(
mPreviousCaret
!
=
mBuilder
.
GetCaretFrame
(
)
)
{
if
(
mPreviousCaret
)
{
if
(
mBuilder
.
MarkFrameModifiedDuringBuilding
(
mPreviousCaret
)
)
{
modifiedFrames
.
Frames
(
)
.
AppendElement
(
mPreviousCaret
)
;
}
}
if
(
mBuilder
.
GetCaretFrame
(
)
)
{
if
(
mBuilder
.
MarkFrameModifiedDuringBuilding
(
mBuilder
.
GetCaretFrame
(
)
)
)
{
modifiedFrames
.
Frames
(
)
.
AppendElement
(
mBuilder
.
GetCaretFrame
(
)
)
;
}
}
mPreviousCaret
=
mBuilder
.
GetCaretFrame
(
)
;
}
nsRect
modifiedDirty
;
AnimatedGeometryRoot
*
modifiedAGR
=
nullptr
;
if
(
!
shouldBuildPartial
|
|
!
ComputeRebuildRegion
(
modifiedFrames
.
Frames
(
)
&
modifiedDirty
&
modifiedAGR
framesWithProps
.
Frames
(
)
)
|
|
!
PreProcessDisplayList
(
&
mList
modifiedAGR
)
)
{
mBuilder
.
LeavePresShell
(
mBuilder
.
RootReferenceFrame
(
)
List
(
)
)
;
mList
.
DeleteAll
(
&
mBuilder
)
;
return
PartialUpdateResult
:
:
Failed
;
}
nsIScrollableFrame
*
sf
=
mBuilder
.
RootReferenceFrame
(
)
-
>
PresShell
(
)
-
>
GetRootScrollFrameAsScrollable
(
)
;
if
(
sf
)
{
nsCanvasFrame
*
canvasFrame
=
do_QueryFrame
(
sf
-
>
GetScrolledFrame
(
)
)
;
if
(
canvasFrame
)
{
mBuilder
.
MarkFrameForDisplayIfVisible
(
canvasFrame
mBuilder
.
RootReferenceFrame
(
)
)
;
}
}
modifiedDirty
.
IntersectRect
(
modifiedDirty
mBuilder
.
RootReferenceFrame
(
)
-
>
GetVisualOverflowRectRelativeToSelf
(
)
)
;
PartialUpdateResult
result
=
PartialUpdateResult
:
:
NoChange
;
if
(
!
modifiedDirty
.
IsEmpty
(
)
|
|
!
framesWithProps
.
IsEmpty
(
)
)
{
result
=
PartialUpdateResult
:
:
Updated
;
}
mBuilder
.
SetDirtyRect
(
modifiedDirty
)
;
mBuilder
.
SetPartialUpdate
(
true
)
;
nsDisplayList
modifiedDL
;
mBuilder
.
RootReferenceFrame
(
)
-
>
BuildDisplayListForStackingContext
(
&
mBuilder
&
modifiedDL
)
;
if
(
!
modifiedDL
.
IsEmpty
(
)
)
{
nsLayoutUtils
:
:
AddExtraBackgroundItems
(
mBuilder
modifiedDL
mBuilder
.
RootReferenceFrame
(
)
nsRect
(
nsPoint
(
0
0
)
mBuilder
.
RootReferenceFrame
(
)
-
>
GetSize
(
)
)
mBuilder
.
RootReferenceFrame
(
)
-
>
GetVisualOverflowRectRelativeToSelf
(
)
aBackstop
)
;
}
mBuilder
.
SetPartialUpdate
(
false
)
;
if
(
mBuilder
.
PartialBuildFailed
(
)
)
{
mBuilder
.
SetPartialBuildFailed
(
false
)
;
mBuilder
.
LeavePresShell
(
mBuilder
.
RootReferenceFrame
(
)
List
(
)
)
;
mList
.
DeleteAll
(
&
mBuilder
)
;
modifiedDL
.
DeleteAll
(
&
mBuilder
)
;
return
PartialUpdateResult
:
:
Failed
;
}
if
(
aChecker
)
{
aChecker
-
>
Set
(
&
modifiedDL
"
TM
"
)
;
}
Maybe
<
const
ActiveScrolledRoot
*
>
dummy
;
if
(
MergeDisplayLists
(
&
modifiedDL
&
mList
&
mList
dummy
)
)
{
result
=
PartialUpdateResult
:
:
Updated
;
}
mBuilder
.
LeavePresShell
(
mBuilder
.
RootReferenceFrame
(
)
List
(
)
)
;
return
result
;
}
