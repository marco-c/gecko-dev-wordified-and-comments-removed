#
include
"
WindowRenderer
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
mozilla
/
dom
/
Animation
.
h
"
#
include
"
mozilla
/
dom
/
AnimationEffect
.
h
"
#
include
"
mozilla
/
EffectSet
.
h
"
#
include
"
mozilla
/
layers
/
PersistentBufferProvider
.
h
"
#
include
"
nsDisplayList
.
h
"
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
layers
;
namespace
mozilla
{
uint32_t
FrameRecorder
:
:
StartFrameTimeRecording
(
int32_t
aBufferSize
)
{
if
(
mRecording
.
mIsPaused
)
{
mRecording
.
mIsPaused
=
false
;
if
(
!
mRecording
.
mIntervals
.
Length
(
)
)
{
mRecording
.
mIntervals
.
SetLength
(
aBufferSize
)
;
}
mRecording
.
mLastFrameTime
=
TimeStamp
:
:
Now
(
)
;
mRecording
.
mCurrentRunStartIndex
=
mRecording
.
mNextIndex
;
}
mRecording
.
mLatestStartIndex
=
mRecording
.
mNextIndex
;
return
mRecording
.
mNextIndex
;
}
void
FrameRecorder
:
:
RecordFrame
(
)
{
if
(
!
mRecording
.
mIsPaused
)
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
uint32_t
i
=
mRecording
.
mNextIndex
%
mRecording
.
mIntervals
.
Length
(
)
;
mRecording
.
mIntervals
[
i
]
=
static_cast
<
float
>
(
(
now
-
mRecording
.
mLastFrameTime
)
.
ToMilliseconds
(
)
)
;
mRecording
.
mNextIndex
+
+
;
mRecording
.
mLastFrameTime
=
now
;
if
(
mRecording
.
mNextIndex
>
(
mRecording
.
mLatestStartIndex
+
mRecording
.
mIntervals
.
Length
(
)
)
)
{
mRecording
.
mIsPaused
=
true
;
}
}
}
void
FrameRecorder
:
:
StopFrameTimeRecording
(
uint32_t
aStartIndex
nsTArray
<
float
>
&
aFrameIntervals
)
{
uint32_t
bufferSize
=
mRecording
.
mIntervals
.
Length
(
)
;
uint32_t
length
=
mRecording
.
mNextIndex
-
aStartIndex
;
if
(
mRecording
.
mIsPaused
|
|
length
>
bufferSize
|
|
aStartIndex
<
mRecording
.
mCurrentRunStartIndex
)
{
length
=
0
;
}
if
(
!
length
)
{
aFrameIntervals
.
Clear
(
)
;
return
;
}
aFrameIntervals
.
SetLength
(
length
)
;
uint32_t
cyclicPos
=
aStartIndex
%
bufferSize
;
for
(
uint32_t
i
=
0
;
i
<
length
;
i
+
+
cyclicPos
+
+
)
{
if
(
cyclicPos
=
=
bufferSize
)
{
cyclicPos
=
0
;
}
aFrameIntervals
[
i
]
=
mRecording
.
mIntervals
[
cyclicPos
]
;
}
}
already_AddRefed
<
PersistentBufferProvider
>
WindowRenderer
:
:
CreatePersistentBufferProvider
(
const
mozilla
:
:
gfx
:
:
IntSize
&
aSize
mozilla
:
:
gfx
:
:
SurfaceFormat
aFormat
)
{
RefPtr
<
PersistentBufferProviderBasic
>
bufferProvider
;
if
(
!
gfxPlatform
:
:
UseRemoteCanvas
(
)
|
|
!
gfxPlatform
:
:
IsBackendAccelerated
(
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetPreferredCanvasBackend
(
)
)
)
{
bufferProvider
=
PersistentBufferProviderBasic
:
:
Create
(
aSize
aFormat
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetPreferredCanvasBackend
(
)
)
;
}
if
(
!
bufferProvider
)
{
bufferProvider
=
PersistentBufferProviderBasic
:
:
Create
(
aSize
aFormat
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetFallbackCanvasBackend
(
)
)
;
}
return
bufferProvider
.
forget
(
)
;
}
void
WindowRenderer
:
:
AddPartialPrerenderedAnimation
(
uint64_t
aCompositorAnimationId
dom
:
:
Animation
*
aAnimation
)
{
mPartialPrerenderedAnimations
.
InsertOrUpdate
(
aCompositorAnimationId
RefPtr
{
aAnimation
}
)
;
aAnimation
-
>
SetPartialPrerendered
(
aCompositorAnimationId
)
;
}
void
WindowRenderer
:
:
RemovePartialPrerenderedAnimation
(
uint64_t
aCompositorAnimationId
dom
:
:
Animation
*
aAnimation
)
{
MOZ_ASSERT
(
aAnimation
)
;
#
ifdef
DEBUG
RefPtr
<
dom
:
:
Animation
>
animation
;
if
(
mPartialPrerenderedAnimations
.
Remove
(
aCompositorAnimationId
getter_AddRefs
(
animation
)
)
&
&
aAnimation
-
>
GetEffect
(
)
&
&
aAnimation
-
>
GetEffect
(
)
-
>
AsKeyframeEffect
(
)
&
&
animation
-
>
GetEffect
(
)
&
&
animation
-
>
GetEffect
(
)
-
>
AsKeyframeEffect
(
)
)
{
MOZ_ASSERT
(
EffectSet
:
:
GetEffectSetForEffect
(
aAnimation
-
>
GetEffect
(
)
-
>
AsKeyframeEffect
(
)
)
=
=
EffectSet
:
:
GetEffectSetForEffect
(
animation
-
>
GetEffect
(
)
-
>
AsKeyframeEffect
(
)
)
)
;
}
#
else
mPartialPrerenderedAnimations
.
Remove
(
aCompositorAnimationId
)
;
#
endif
aAnimation
-
>
ResetPartialPrerendered
(
)
;
}
void
WindowRenderer
:
:
UpdatePartialPrerenderedAnimations
(
const
nsTArray
<
uint64_t
>
&
aJankedAnimations
)
{
for
(
uint64_t
id
:
aJankedAnimations
)
{
RefPtr
<
dom
:
:
Animation
>
animation
;
if
(
mPartialPrerenderedAnimations
.
Remove
(
id
getter_AddRefs
(
animation
)
)
)
{
animation
-
>
UpdatePartialPrerendered
(
)
;
}
}
}
void
FallbackRenderer
:
:
SetTarget
(
gfxContext
*
aTarget
layers
:
:
BufferMode
aDoubleBuffering
)
{
mTarget
=
aTarget
;
mBufferMode
=
aDoubleBuffering
;
}
bool
FallbackRenderer
:
:
BeginTransaction
(
const
nsCString
&
aURL
)
{
if
(
!
mTarget
)
{
return
false
;
}
return
true
;
}
void
FallbackRenderer
:
:
EndTransactionWithColor
(
const
nsIntRect
&
aRect
const
gfx
:
:
DeviceColor
&
aColor
)
{
mTarget
-
>
GetDrawTarget
(
)
-
>
FillRect
(
Rect
(
aRect
)
ColorPattern
(
aColor
)
)
;
mAnimationReadyTime
=
TimeStamp
:
:
Now
(
)
;
}
void
FallbackRenderer
:
:
EndTransactionWithList
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
int32_t
aAppUnitsPerDevPixel
EndTransactionFlags
aFlags
)
{
if
(
aFlags
&
EndTransactionFlags
:
:
END_NO_COMPOSITE
)
{
return
;
}
DrawTarget
*
dt
=
mTarget
-
>
GetDrawTarget
(
)
;
BackendType
backend
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetContentBackendFor
(
LayersBackend
:
:
LAYERS_NONE
)
;
RefPtr
<
DrawTarget
>
dest
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
CreateDrawTargetForBackend
(
backend
dt
-
>
GetSize
(
)
dt
-
>
GetFormat
(
)
)
;
RefPtr
<
gfxContext
>
ctx
=
gfxContext
:
:
CreatePreservingTransformOrNull
(
dest
)
;
nsRegion
opaque
=
aList
-
>
GetOpaqueRegion
(
aBuilder
)
;
if
(
opaque
.
Contains
(
aList
-
>
GetComponentAlphaBounds
(
aBuilder
)
)
)
{
dest
-
>
SetPermitSubpixelAA
(
true
)
;
}
aList
-
>
Paint
(
aBuilder
ctx
aAppUnitsPerDevPixel
)
;
RefPtr
<
SourceSurface
>
snapshot
=
dest
-
>
Snapshot
(
)
;
dt
-
>
DrawSurface
(
snapshot
Rect
(
dest
-
>
GetRect
(
)
)
Rect
(
dest
-
>
GetRect
(
)
)
DrawSurfaceOptions
(
)
DrawOptions
(
1
.
0f
CompositionOp
:
:
OP_SOURCE
)
)
;
mAnimationReadyTime
=
TimeStamp
:
:
Now
(
)
;
}
}
