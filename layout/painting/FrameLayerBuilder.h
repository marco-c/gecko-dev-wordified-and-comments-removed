#
ifndef
FRAMELAYERBUILDER_H_
#
define
FRAMELAYERBUILDER_H_
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsCSSPropertyIDSet
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
DisplayItemClip
.
h
"
#
include
"
mozilla
/
gfx
/
MatrixFwd
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
LayerState
.
h
"
#
include
"
Layers
.
h
"
#
include
"
LayerUserData
.
h
"
#
include
"
nsDisplayItemTypes
.
h
"
#
include
"
TransformClipNode
.
h
"
class
nsDisplayListBuilder
;
class
nsDisplayList
;
class
nsDisplayItem
;
class
nsPaintedDisplayItem
;
class
gfxContext
;
class
nsDisplayItemGeometry
;
class
nsDisplayMasksAndClipPaths
;
namespace
mozilla
{
struct
ActiveScrolledRoot
;
struct
DisplayItemClipChain
;
namespace
layers
{
class
ContainerLayer
;
class
LayerManager
;
class
BasicLayerManager
;
class
PaintedLayer
;
class
ImageLayer
;
struct
LayerProperties
;
}
class
FrameLayerBuilder
;
class
LayerManagerData
;
class
PaintedLayerData
;
class
ContainerState
;
class
PaintedDisplayItemLayerUserData
;
enum
class
DisplayItemEntryType
:
uint8_t
{
Item
PushOpacity
PushOpacityWithBg
PopOpacity
PushTransform
PopTransform
HitTestInfo
}
;
class
DisplayItemData
final
{
public
:
friend
class
FrameLayerBuilder
;
friend
class
ContainerState
;
uint32_t
GetDisplayItemKey
(
)
{
return
mDisplayItemKey
;
}
layers
:
:
Layer
*
GetLayer
(
)
const
{
return
mLayer
;
}
nsDisplayItemGeometry
*
GetGeometry
(
)
const
{
return
mGeometry
.
get
(
)
;
}
const
DisplayItemClip
&
GetClip
(
)
const
{
return
mClip
;
}
void
Invalidate
(
)
{
mIsInvalid
=
true
;
}
void
ClearAnimationCompositorState
(
)
;
void
SetItem
(
nsPaintedDisplayItem
*
aItem
)
{
mItem
=
aItem
;
}
nsPaintedDisplayItem
*
GetItem
(
)
const
{
return
mItem
;
}
nsIFrame
*
FirstFrame
(
)
const
{
return
mFrameList
[
0
]
;
}
layers
:
:
BasicLayerManager
*
InactiveManager
(
)
const
{
return
mInactiveManager
;
}
bool
HasMergedFrames
(
)
const
{
return
mFrameList
.
Length
(
)
>
1
;
}
static
DisplayItemData
*
AssertDisplayItemData
(
DisplayItemData
*
aData
)
;
void
*
operator
new
(
size_t
sz
nsPresContext
*
aPresContext
)
{
return
aPresContext
-
>
PresShell
(
)
-
>
AllocateByObjectID
(
eArenaObjectID_DisplayItemData
sz
)
;
}
nsrefcnt
AddRef
(
)
{
if
(
mRefCnt
=
=
UINT32_MAX
)
{
NS_WARNING
(
"
refcount
overflow
leaking
object
"
)
;
return
mRefCnt
;
}
+
+
mRefCnt
;
NS_LOG_ADDREF
(
this
mRefCnt
"
DisplayItemData
"
sizeof
(
DisplayItemData
)
)
;
return
mRefCnt
;
}
nsrefcnt
Release
(
)
{
if
(
mRefCnt
=
=
UINT32_MAX
)
{
NS_WARNING
(
"
refcount
overflow
leaking
object
"
)
;
return
mRefCnt
;
}
-
-
mRefCnt
;
NS_LOG_RELEASE
(
this
mRefCnt
"
DisplayItemData
"
)
;
if
(
mRefCnt
=
=
0
)
{
Destroy
(
)
;
return
0
;
}
return
mRefCnt
;
}
RefPtr
<
TransformClipNode
>
mTransform
;
RefPtr
<
TransformClipNode
>
mOldTransform
;
private
:
DisplayItemData
(
LayerManagerData
*
aParent
uint32_t
aKey
layers
:
:
Layer
*
aLayer
nsIFrame
*
aFrame
=
nullptr
)
;
~
DisplayItemData
(
)
;
void
Destroy
(
)
{
RefPtr
<
nsPresContext
>
presContext
=
mFrameList
[
0
]
-
>
PresContext
(
)
;
this
-
>
~
DisplayItemData
(
)
;
presContext
-
>
PresShell
(
)
-
>
FreeByObjectID
(
eArenaObjectID_DisplayItemData
this
)
;
}
void
AddFrame
(
nsIFrame
*
aFrame
)
;
void
RemoveFrame
(
nsIFrame
*
aFrame
)
;
const
nsRegion
&
GetChangedFrameInvalidations
(
)
;
void
BeginUpdate
(
layers
:
:
Layer
*
aLayer
LayerState
aState
bool
aFirstUpdate
nsPaintedDisplayItem
*
aItem
=
nullptr
)
;
void
BeginUpdate
(
layers
:
:
Layer
*
aLayer
LayerState
aState
nsPaintedDisplayItem
*
aItem
bool
aIsReused
bool
aIsMerged
)
;
void
EndUpdate
(
nsAutoPtr
<
nsDisplayItemGeometry
>
aGeometry
)
;
void
EndUpdate
(
)
;
uint32_t
mRefCnt
;
LayerManagerData
*
mParent
;
RefPtr
<
layers
:
:
Layer
>
mLayer
;
RefPtr
<
layers
:
:
Layer
>
mOptLayer
;
RefPtr
<
layers
:
:
BasicLayerManager
>
mInactiveManager
;
AutoTArray
<
nsIFrame
*
1
>
mFrameList
;
nsAutoPtr
<
nsDisplayItemGeometry
>
mGeometry
;
DisplayItemClip
mClip
;
uint32_t
mDisplayItemKey
;
LayerState
mLayerState
;
nsPaintedDisplayItem
*
mItem
;
nsRegion
mChangedFrameInvalidations
;
bool
mUsed
;
bool
mIsInvalid
;
bool
mReusedItem
;
}
;
class
RefCountedRegion
{
private
:
~
RefCountedRegion
(
)
=
default
;
public
:
NS_INLINE_DECL_REFCOUNTING
(
RefCountedRegion
)
RefCountedRegion
(
)
:
mIsInfinite
(
false
)
{
}
nsRegion
mRegion
;
bool
mIsInfinite
;
}
;
struct
InactiveLayerData
{
RefPtr
<
layers
:
:
BasicLayerManager
>
mLayerManager
;
FrameLayerBuilder
*
mLayerBuilder
;
RefPtr
<
layers
:
:
Layer
>
mLayer
;
UniquePtr
<
layers
:
:
LayerProperties
>
mProps
;
~
InactiveLayerData
(
)
;
}
;
struct
AssignedDisplayItem
{
AssignedDisplayItem
(
nsPaintedDisplayItem
*
aItem
LayerState
aLayerState
DisplayItemData
*
aData
const
nsRect
&
aContentRect
DisplayItemEntryType
aType
const
bool
aHasOpacity
const
RefPtr
<
TransformClipNode
>
&
aTransform
const
bool
aIsMerged
)
;
AssignedDisplayItem
(
AssignedDisplayItem
&
&
aRhs
)
=
default
;
bool
HasOpacity
(
)
const
{
return
mHasOpacity
;
}
bool
HasTransform
(
)
const
{
return
mTransform
;
}
nsPaintedDisplayItem
*
mItem
;
DisplayItemData
*
mDisplayItemData
;
UniquePtr
<
InactiveLayerData
>
mInactiveLayerData
;
RefPtr
<
TransformClipNode
>
mTransform
;
nsRect
mContentRect
;
LayerState
mLayerState
;
DisplayItemEntryType
mType
;
bool
mReused
;
bool
mMerged
;
bool
mHasOpacity
;
bool
mHasPaintRect
;
}
;
struct
ContainerLayerParameters
{
ContainerLayerParameters
(
)
:
mXScale
(
1
)
mYScale
(
1
)
mLayerContentsVisibleRect
(
nullptr
)
mBackgroundColor
(
NS_RGBA
(
0
0
0
0
)
)
mScrollMetadataASR
(
nullptr
)
mCompositorASR
(
nullptr
)
mInTransformedSubtree
(
false
)
mInActiveTransformedSubtree
(
false
)
mDisableSubpixelAntialiasingInDescendants
(
false
)
mLayerCreationHint
(
layers
:
:
LayerManager
:
:
NONE
)
{
}
ContainerLayerParameters
(
float
aXScale
float
aYScale
)
:
mXScale
(
aXScale
)
mYScale
(
aYScale
)
mLayerContentsVisibleRect
(
nullptr
)
mBackgroundColor
(
NS_RGBA
(
0
0
0
0
)
)
mScrollMetadataASR
(
nullptr
)
mCompositorASR
(
nullptr
)
mInTransformedSubtree
(
false
)
mInActiveTransformedSubtree
(
false
)
mDisableSubpixelAntialiasingInDescendants
(
false
)
mLayerCreationHint
(
layers
:
:
LayerManager
:
:
NONE
)
{
}
ContainerLayerParameters
(
float
aXScale
float
aYScale
const
nsIntPoint
&
aOffset
const
ContainerLayerParameters
&
aParent
)
:
mXScale
(
aXScale
)
mYScale
(
aYScale
)
mLayerContentsVisibleRect
(
nullptr
)
mOffset
(
aOffset
)
mBackgroundColor
(
aParent
.
mBackgroundColor
)
mScrollMetadataASR
(
aParent
.
mScrollMetadataASR
)
mCompositorASR
(
aParent
.
mCompositorASR
)
mInTransformedSubtree
(
aParent
.
mInTransformedSubtree
)
mInActiveTransformedSubtree
(
aParent
.
mInActiveTransformedSubtree
)
mDisableSubpixelAntialiasingInDescendants
(
aParent
.
mDisableSubpixelAntialiasingInDescendants
)
mLayerCreationHint
(
aParent
.
mLayerCreationHint
)
{
}
float
mXScale
mYScale
;
LayoutDeviceToLayerScale2D
Scale
(
)
const
{
return
LayoutDeviceToLayerScale2D
(
mXScale
mYScale
)
;
}
nsIntRect
*
mLayerContentsVisibleRect
;
nsIntPoint
mOffset
;
LayerIntPoint
Offset
(
)
const
{
return
LayerIntPoint
:
:
FromUnknownPoint
(
mOffset
)
;
}
nscolor
mBackgroundColor
;
const
ActiveScrolledRoot
*
mScrollMetadataASR
;
const
ActiveScrolledRoot
*
mCompositorASR
;
bool
mInTransformedSubtree
;
bool
mInActiveTransformedSubtree
;
bool
mDisableSubpixelAntialiasingInDescendants
;
layers
:
:
LayerManager
:
:
PaintedLayerCreationHint
mLayerCreationHint
;
bool
AllowResidualTranslation
(
)
{
return
mInTransformedSubtree
&
&
!
mInActiveTransformedSubtree
;
}
}
;
class
FrameLayerBuilder
:
public
layers
:
:
LayerUserData
{
public
:
typedef
layers
:
:
ContainerLayer
ContainerLayer
;
typedef
layers
:
:
Layer
Layer
;
typedef
layers
:
:
PaintedLayer
PaintedLayer
;
typedef
layers
:
:
ImageLayer
ImageLayer
;
typedef
layers
:
:
LayerManager
LayerManager
;
typedef
layers
:
:
BasicLayerManager
BasicLayerManager
;
typedef
layers
:
:
EventRegions
EventRegions
;
FrameLayerBuilder
(
)
;
~
FrameLayerBuilder
(
)
override
;
static
gfx
:
:
Size
ChooseScale
(
nsIFrame
*
aContainerFrame
nsDisplayItem
*
aContainerItem
const
nsRect
&
aVisibleRect
float
aXScale
float
aYScale
const
gfx
:
:
Matrix
&
aTransform2d
bool
aCanDraw2D
)
;
static
void
Shutdown
(
)
;
void
Init
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
PaintedLayerData
*
aLayerData
=
nullptr
bool
aIsInactiveLayerManager
=
false
const
DisplayItemClip
*
aInactiveLayerClip
=
nullptr
)
;
void
DidBeginRetainedLayerTransaction
(
LayerManager
*
aManager
)
;
void
WillEndTransaction
(
)
;
void
DidEndTransaction
(
)
;
enum
{
CONTAINER_ALLOW_PULL_BACKGROUND_COLOR
=
0x01
}
;
already_AddRefed
<
ContainerLayer
>
BuildContainerLayerFor
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
nsIFrame
*
aContainerFrame
nsDisplayItem
*
aContainerItem
nsDisplayList
*
aChildren
const
ContainerLayerParameters
&
aContainerParameters
const
gfx
:
:
Matrix4x4
*
aTransform
uint32_t
aFlags
=
0
)
;
Layer
*
GetLeafLayerFor
(
nsDisplayListBuilder
*
aBuilder
nsDisplayItem
*
aItem
)
;
static
void
InvalidateAllLayers
(
LayerManager
*
aManager
)
;
static
void
InvalidateAllLayersForFrame
(
nsIFrame
*
aFrame
)
;
static
Layer
*
GetDedicatedLayer
(
nsIFrame
*
aFrame
DisplayItemType
aDisplayItemType
)
;
using
AnimationGenerationCallback
=
std
:
:
function
<
bool
(
const
Maybe
<
uint64_t
>
&
aGeneration
DisplayItemType
aDisplayItemType
)
>
;
static
void
EnumerateGenerationForDedicatedLayers
(
const
nsIFrame
*
aFrame
const
AnimationGenerationCallback
&
aCallback
)
;
static
void
DrawPaintedLayer
(
PaintedLayer
*
aLayer
gfxContext
*
aContext
const
nsIntRegion
&
aRegionToDraw
const
nsIntRegion
&
aDirtyRegion
mozilla
:
:
layers
:
:
DrawRegionClip
aClip
const
nsIntRegion
&
aRegionToInvalidate
void
*
aCallbackData
)
;
static
void
DumpRetainedLayerTree
(
LayerManager
*
aManager
std
:
:
stringstream
&
aStream
bool
aDumpHtml
=
false
)
;
static
nsDisplayItemGeometry
*
GetMostRecentGeometry
(
nsDisplayItem
*
aItem
)
;
void
AddPaintedDisplayItem
(
PaintedLayerData
*
aLayerData
AssignedDisplayItem
&
aAssignedDisplayItem
Layer
*
aLayer
)
;
Layer
*
GetOldLayerFor
(
nsDisplayItem
*
aItem
nsDisplayItemGeometry
*
*
aOldGeometry
=
nullptr
DisplayItemClip
*
*
aOldClip
=
nullptr
)
;
static
DisplayItemData
*
GetOldDataFor
(
nsDisplayItem
*
aItem
)
;
template
<
class
T
>
static
T
*
GetDebugSingleOldLayerForFrame
(
nsIFrame
*
aFrame
)
{
SmallPointerArray
<
DisplayItemData
>
&
array
=
aFrame
-
>
DisplayItemData
(
)
;
Layer
*
layer
=
nullptr
;
for
(
DisplayItemData
*
data
:
array
)
{
DisplayItemData
:
:
AssertDisplayItemData
(
data
)
;
if
(
data
-
>
mLayer
-
>
GetType
(
)
!
=
T
:
:
Type
(
)
)
{
continue
;
}
if
(
layer
&
&
layer
!
=
data
-
>
mLayer
)
{
return
nullptr
;
}
layer
=
data
-
>
mLayer
;
}
if
(
!
layer
)
{
return
nullptr
;
}
return
static_cast
<
T
*
>
(
layer
)
;
}
static
void
DestroyDisplayItemDataFor
(
nsIFrame
*
aFrame
)
;
LayerManager
*
GetRetainingLayerManager
(
)
{
return
mRetainingManager
;
}
static
bool
HasRetainedDataFor
(
nsIFrame
*
aFrame
uint32_t
aDisplayItemKey
)
;
typedef
void
(
*
DisplayItemDataCallback
)
(
nsIFrame
*
aFrame
DisplayItemData
*
aItem
)
;
nsIntPoint
GetLastPaintOffset
(
PaintedLayer
*
aLayer
)
;
static
gfxSize
GetPaintedLayerScaleForFrame
(
nsIFrame
*
aFrame
)
;
static
void
RemoveFrameFromLayerManager
(
const
nsIFrame
*
aFrame
SmallPointerArray
<
DisplayItemData
>
&
aArray
)
;
DisplayItemData
*
GetOldLayerForFrame
(
nsIFrame
*
aFrame
uint32_t
aDisplayItemKey
DisplayItemData
*
aOldData
=
nullptr
LayerManager
*
aOldLayerManager
=
nullptr
)
;
DisplayItemData
*
StoreDataForFrame
(
nsPaintedDisplayItem
*
aItem
Layer
*
aLayer
LayerState
aState
DisplayItemData
*
aData
)
;
void
StoreDataForFrame
(
nsIFrame
*
aFrame
uint32_t
aDisplayItemKey
Layer
*
aLayer
LayerState
aState
)
;
protected
:
friend
class
LayerManagerData
;
static
void
FlashPaint
(
gfxContext
*
aContext
)
;
DisplayItemData
*
GetDisplayItemData
(
nsIFrame
*
aFrame
uint32_t
aKey
)
;
static
DisplayItemData
*
GetDisplayItemDataForManager
(
nsPaintedDisplayItem
*
aItem
LayerManager
*
aManager
)
;
static
void
RecomputeVisibilityForItems
(
std
:
:
vector
<
AssignedDisplayItem
>
&
aItems
nsDisplayListBuilder
*
aBuilder
const
nsIntRegion
&
aRegionToDraw
nsRect
&
aPreviousRectToDraw
const
nsIntPoint
&
aOffset
int32_t
aAppUnitsPerDevPixel
float
aXScale
float
aYScale
)
;
void
PaintItems
(
std
:
:
vector
<
AssignedDisplayItem
>
&
aItems
const
nsIntRect
&
aRect
gfxContext
*
aContext
nsDisplayListBuilder
*
aBuilder
nsPresContext
*
aPresContext
const
nsIntPoint
&
aOffset
float
aXScale
float
aYScale
)
;
public
:
void
AddPaintedLayerItemsEntry
(
PaintedDisplayItemLayerUserData
*
aData
)
;
PaintedLayerData
*
GetContainingPaintedLayerData
(
)
{
return
mContainingPaintedLayer
;
}
const
DisplayItemClip
*
GetInactiveLayerClip
(
)
const
{
return
mInactiveLayerClip
;
}
void
SetInactiveLayerClip
(
const
DisplayItemClip
*
aClip
)
{
mInactiveLayerClip
=
aClip
;
}
bool
IsBuildingRetainedLayers
(
)
{
return
!
mIsInactiveLayerManager
&
&
mRetainingManager
;
}
void
SetLayerTreeCompressionMode
(
)
{
mInLayerTreeCompressionMode
=
true
;
}
bool
CheckInLayerTreeCompressionMode
(
)
;
void
ComputeGeometryChangeForItem
(
DisplayItemData
*
aData
)
;
protected
:
LayerManager
*
mRetainingManager
;
RefPtr
<
nsRootPresContext
>
mRootPresContext
;
nsDisplayListBuilder
*
mDisplayListBuilder
;
AutoTArray
<
RefPtr
<
PaintedDisplayItemLayerUserData
>
5
>
mPaintedLayerItems
;
PaintedLayerData
*
mContainingPaintedLayer
;
const
DisplayItemClip
*
mInactiveLayerClip
;
bool
mInvalidateAllLayers
;
bool
mInLayerTreeCompressionMode
;
bool
mIsInactiveLayerManager
;
}
;
}
#
endif
