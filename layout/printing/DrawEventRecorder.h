#
ifndef
mozilla_layout_printing_DrawEventRecorder_h
#
define
mozilla_layout_printing_DrawEventRecorder_h
#
include
<
memory
>
#
include
"
mozilla
/
gfx
/
DrawEventRecorder
.
h
"
#
include
"
mozilla
/
gfx
/
RecordingTypes
.
h
"
#
include
"
prio
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
{
namespace
layout
{
class
PRFileDescStream
final
:
public
mozilla
:
:
gfx
:
:
EventStream
{
static
const
size_t
kBufferSize
=
1024
;
public
:
PRFileDescStream
(
)
:
mFd
(
nullptr
)
mBuffer
(
nullptr
)
mBufferPos
(
0
)
mGood
(
true
)
{
}
PRFileDescStream
(
const
PRFileDescStream
&
other
)
=
delete
;
~
PRFileDescStream
(
)
{
Close
(
)
;
}
void
OpenFD
(
PRFileDesc
*
aFd
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
IsOpen
(
)
)
;
mFd
=
aFd
;
mGood
=
!
!
mFd
;
mBuffer
.
reset
(
new
uint8_t
[
kBufferSize
]
)
;
mBufferPos
=
0
;
}
void
Close
(
)
{
if
(
IsOpen
(
)
)
{
Flush
(
)
;
PR_Close
(
mFd
)
;
mFd
=
nullptr
;
mBuffer
.
reset
(
)
;
mBufferPos
=
0
;
}
}
bool
IsOpen
(
)
{
return
mFd
!
=
nullptr
;
}
void
Flush
(
)
{
if
(
IsOpen
(
)
&
&
mBufferPos
>
0
)
{
PRInt32
length
=
PR_Write
(
mFd
static_cast
<
const
void
*
>
(
mBuffer
.
get
(
)
)
mBufferPos
)
;
mGood
=
length
>
=
0
&
&
static_cast
<
size_t
>
(
length
)
=
=
mBufferPos
;
mBufferPos
=
0
;
}
}
void
Seek
(
PRInt64
aOffset
PRSeekWhence
aWhence
)
{
Flush
(
)
;
PRInt64
pos
=
PR_Seek64
(
mFd
aOffset
aWhence
)
;
mGood
=
pos
!
=
-
1
;
}
void
write
(
const
char
*
aData
size_t
aSize
)
override
{
if
(
!
good
(
)
)
{
return
;
}
if
(
IsOpen
(
)
)
{
if
(
aSize
>
kBufferSize
)
{
Flush
(
)
;
PRInt32
length
=
PR_Write
(
mFd
static_cast
<
const
void
*
>
(
aData
)
aSize
)
;
mGood
=
length
>
=
0
&
&
static_cast
<
size_t
>
(
length
)
=
=
aSize
;
}
else
if
(
aSize
>
AvailableBufferSpace
(
)
)
{
size_t
length
=
AvailableBufferSpace
(
)
;
WriteToBuffer
(
aData
length
)
;
Flush
(
)
;
WriteToBuffer
(
aData
+
length
aSize
-
length
)
;
}
else
{
WriteToBuffer
(
aData
aSize
)
;
}
}
}
void
read
(
char
*
aOut
size_t
aSize
)
override
{
if
(
!
good
(
)
)
{
return
;
}
Flush
(
)
;
PRInt32
res
=
PR_Read
(
mFd
static_cast
<
void
*
>
(
aOut
)
aSize
)
;
mGood
=
res
>
=
0
&
&
(
static_cast
<
size_t
>
(
res
)
=
=
aSize
)
;
}
bool
good
(
)
final
{
return
mGood
;
}
void
SetIsBad
(
)
final
{
mGood
=
false
;
}
private
:
size_t
AvailableBufferSpace
(
)
{
return
kBufferSize
-
mBufferPos
;
}
void
WriteToBuffer
(
const
char
*
aData
size_t
aSize
)
{
MOZ_ASSERT
(
aSize
<
=
AvailableBufferSpace
(
)
)
;
memcpy
(
mBuffer
.
get
(
)
+
mBufferPos
aData
aSize
)
;
mBufferPos
+
=
aSize
;
}
PRFileDesc
*
mFd
;
std
:
:
unique_ptr
<
uint8_t
[
]
>
mBuffer
;
size_t
mBufferPos
;
bool
mGood
;
}
;
class
DrawEventRecorderPRFileDesc
final
:
public
gfx
:
:
DrawEventRecorderPrivate
{
public
:
MOZ_DECLARE_REFCOUNTED_VIRTUAL_TYPENAME
(
DrawEventRecorderPRFileDesc
override
)
explicit
DrawEventRecorderPRFileDesc
(
)
=
default
;
~
DrawEventRecorderPRFileDesc
(
)
;
void
RecordEvent
(
const
gfx
:
:
RecordedEvent
&
aEvent
)
override
;
bool
IsOpen
(
)
;
void
OpenFD
(
PRFileDesc
*
aFd
)
;
void
Close
(
)
;
void
AddDependentSurface
(
uint64_t
aDependencyId
)
override
;
nsTArray
<
uint64_t
>
&
&
TakeDependentSurfaces
(
)
;
private
:
void
Flush
(
)
override
;
PRFileDescStream
mOutputStream
;
nsTArray
<
uint64_t
>
mDependentSurfaces
;
}
;
}
}
#
endif
