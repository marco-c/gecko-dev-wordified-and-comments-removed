#
ifndef
nsImageBoxFrame_h___
#
define
nsImageBoxFrame_h___
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
nsLeafBoxFrame
.
h
"
#
include
"
imgILoader
.
h
"
#
include
"
imgIRequest
.
h
"
#
include
"
imgIContainer
.
h
"
class
imgRequestProxy
;
class
nsImageBoxFrame
;
class
nsDisplayXULImage
;
class
nsImageBoxListener
final
:
public
imgINotificationObserver
{
public
:
explicit
nsImageBoxListener
(
nsImageBoxFrame
*
frame
)
;
NS_DECL_ISUPPORTS
NS_DECL_IMGINOTIFICATIONOBSERVER
void
ClearFrame
(
)
{
mFrame
=
nullptr
;
}
private
:
virtual
~
nsImageBoxListener
(
)
;
nsImageBoxFrame
*
mFrame
;
}
;
class
nsImageBoxFrame
final
:
public
nsLeafBoxFrame
{
public
:
typedef
mozilla
:
:
image
:
:
ImgDrawResult
ImgDrawResult
;
typedef
mozilla
:
:
layers
:
:
ImageContainer
ImageContainer
;
typedef
mozilla
:
:
layers
:
:
LayerManager
LayerManager
;
friend
class
nsDisplayXULImage
;
NS_DECL_FRAMEARENA_HELPERS
(
nsImageBoxFrame
)
virtual
nsSize
GetXULPrefSize
(
nsBoxLayoutState
&
aBoxLayoutState
)
override
;
virtual
nsSize
GetXULMinSize
(
nsBoxLayoutState
&
aBoxLayoutState
)
override
;
virtual
nscoord
GetXULBoxAscent
(
nsBoxLayoutState
&
aBoxLayoutState
)
override
;
virtual
void
MarkIntrinsicISizesDirty
(
)
override
;
nsresult
Notify
(
imgIRequest
*
aRequest
int32_t
aType
const
nsIntRect
*
aData
)
;
friend
nsIFrame
*
NS_NewImageBoxFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
virtual
void
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
asPrevInFlow
)
override
;
virtual
nsresult
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
override
;
virtual
void
DidSetComputedStyle
(
ComputedStyle
*
aOldComputedStyle
)
override
;
virtual
void
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
override
;
#
ifdef
DEBUG_FRAME_DUMP
virtual
nsresult
GetFrameName
(
nsAString
&
aResult
)
const
override
;
#
endif
void
UpdateImage
(
)
;
void
UpdateLoadFlags
(
)
;
virtual
void
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
override
;
virtual
~
nsImageBoxFrame
(
)
;
already_AddRefed
<
imgIContainer
>
GetImageContainerForPainting
(
const
nsPoint
&
aPt
ImgDrawResult
&
aDrawResult
Maybe
<
nsPoint
>
&
aAnchorPoint
nsRect
&
aDest
)
;
ImgDrawResult
PaintImage
(
gfxContext
&
aRenderingContext
const
nsRect
&
aDirtyRect
nsPoint
aPt
uint32_t
aFlags
)
;
ImgDrawResult
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
mozilla
:
:
layers
:
:
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
RenderRootStateManager
*
aManager
nsDisplayItem
*
aItem
nsPoint
aPt
uint32_t
aFlags
)
;
bool
CanOptimizeToImageLayer
(
)
;
nsRect
GetDestRect
(
const
nsPoint
&
aOffset
Maybe
<
nsPoint
>
&
aAnchorPoint
)
;
protected
:
explicit
nsImageBoxFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
;
virtual
void
GetImageSize
(
)
;
private
:
nsresult
OnSizeAvailable
(
imgIRequest
*
aRequest
imgIContainer
*
aImage
)
;
nsresult
OnDecodeComplete
(
imgIRequest
*
aRequest
)
;
nsresult
OnLoadComplete
(
imgIRequest
*
aRequest
nsresult
aStatus
)
;
nsresult
OnImageIsAnimated
(
imgIRequest
*
aRequest
)
;
nsresult
OnFrameUpdate
(
imgIRequest
*
aRequest
)
;
nsRect
mSubRect
;
nsSize
mIntrinsicSize
;
nsSize
mImageSize
;
RefPtr
<
imgRequestProxy
>
mImageRequest
;
nsCOMPtr
<
imgINotificationObserver
>
mListener
;
int32_t
mLoadFlags
;
bool
mRequestRegistered
;
bool
mUseSrcAttr
;
bool
mSuppressStyleCheck
;
}
;
class
nsDisplayXULImage
final
:
public
nsDisplayImageContainer
{
public
:
nsDisplayXULImage
(
nsDisplayListBuilder
*
aBuilder
nsImageBoxFrame
*
aFrame
)
:
nsDisplayImageContainer
(
aBuilder
aFrame
)
{
MOZ_COUNT_CTOR
(
nsDisplayXULImage
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayXULImage
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayXULImage
)
;
}
#
endif
virtual
bool
CanOptimizeToImageLayer
(
LayerManager
*
aManager
nsDisplayListBuilder
*
aBuilder
)
override
;
virtual
already_AddRefed
<
imgIContainer
>
GetImage
(
)
override
;
virtual
nsRect
GetDestRect
(
)
const
override
;
virtual
void
UpdateDrawResult
(
mozilla
:
:
image
:
:
ImgDrawResult
aResult
)
override
{
nsDisplayItemGenericImageGeometry
:
:
UpdateDrawResult
(
this
aResult
)
;
}
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
{
*
aSnap
=
true
;
return
nsRect
(
ToReferenceFrame
(
)
Frame
(
)
-
>
GetSize
(
)
)
;
}
virtual
nsDisplayItemGeometry
*
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
override
;
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
;
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
;
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
NS_DISPLAY_DECL_NAME
(
"
XULImage
"
TYPE_XUL_IMAGE
)
}
;
#
endif
