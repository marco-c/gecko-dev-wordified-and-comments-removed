#
include
"
nsSliderFrame
.
h
"
#
include
"
mozilla
/
ComputedStyle
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsHTMLParts
.
h
"
#
include
"
nsCSSRendering
.
h
"
#
include
"
nsScrollbarButtonFrame
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsIScrollbarMediator
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsScrollbarFrame
.
h
"
#
include
"
nsRepeatService
.
h
"
#
include
"
nsBoxLayoutState
.
h
"
#
include
"
nsSprocketLayout
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsDeviceContext
.
h
"
#
include
"
nsRefreshDriver
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
DisplayPortUtils
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
SVGIntegrationUtils
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
layers
/
APZCCallbackHelper
.
h
"
#
include
"
mozilla
/
layers
/
AsyncDragMetrics
.
h
"
#
include
"
mozilla
/
layers
/
InputAPZContext
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderLayerManager
.
h
"
#
include
<
algorithm
>
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
using
mozilla
:
:
dom
:
:
Document
;
using
mozilla
:
:
dom
:
:
Event
;
using
mozilla
:
:
layers
:
:
AsyncDragMetrics
;
using
mozilla
:
:
layers
:
:
InputAPZContext
;
using
mozilla
:
:
layers
:
:
ScrollbarData
;
using
mozilla
:
:
layers
:
:
ScrollDirection
;
bool
nsSliderFrame
:
:
gMiddlePref
=
false
;
int32_t
nsSliderFrame
:
:
gSnapMultiplier
;
#
undef
DEBUG_SLIDER
static
already_AddRefed
<
nsIContent
>
GetContentOfBox
(
nsIFrame
*
aBox
)
{
nsCOMPtr
<
nsIContent
>
content
=
aBox
-
>
GetContent
(
)
;
return
content
.
forget
(
)
;
}
nsIFrame
*
NS_NewSliderFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsSliderFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsSliderFrame
)
NS_QUERYFRAME_HEAD
(
nsSliderFrame
)
NS_QUERYFRAME_ENTRY
(
nsSliderFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsBoxFrame
)
nsSliderFrame
:
:
nsSliderFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
:
nsBoxFrame
(
aStyle
aPresContext
kClassID
)
mRatio
(
0
.
0f
)
mDragStart
(
0
)
mThumbStart
(
0
)
mCurPos
(
0
)
mChange
(
0
)
mDragFinished
(
true
)
mUserChanged
(
false
)
mScrollingWithAPZ
(
false
)
mSuppressionActive
(
false
)
{
}
nsSliderFrame
:
:
~
nsSliderFrame
(
)
{
if
(
mSuppressionActive
)
{
if
(
mozilla
:
:
PresShell
*
presShell
=
PresShell
(
)
)
{
presShell
-
>
SuppressDisplayport
(
false
)
;
}
}
}
void
nsSliderFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
nsBoxFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
static
bool
gotPrefs
=
false
;
if
(
!
gotPrefs
)
{
gotPrefs
=
true
;
gMiddlePref
=
Preferences
:
:
GetBool
(
"
middlemouse
.
scrollbarPosition
"
)
;
gSnapMultiplier
=
Preferences
:
:
GetInt
(
"
slider
.
snapMultiplier
"
)
;
}
mCurPos
=
GetCurrentPosition
(
aContent
)
;
}
void
nsSliderFrame
:
:
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
{
nsBoxFrame
:
:
RemoveFrame
(
aListID
aOldFrame
)
;
if
(
mFrames
.
IsEmpty
(
)
)
RemoveListener
(
)
;
}
void
nsSliderFrame
:
:
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
const
nsLineList
:
:
iterator
*
aPrevFrameLine
nsFrameList
&
aFrameList
)
{
bool
wasEmpty
=
mFrames
.
IsEmpty
(
)
;
nsBoxFrame
:
:
InsertFrames
(
aListID
aPrevFrame
aPrevFrameLine
aFrameList
)
;
if
(
wasEmpty
)
AddListener
(
)
;
}
void
nsSliderFrame
:
:
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
{
bool
wasEmpty
=
mFrames
.
IsEmpty
(
)
;
nsBoxFrame
:
:
AppendFrames
(
aListID
aFrameList
)
;
if
(
wasEmpty
)
AddListener
(
)
;
}
int32_t
nsSliderFrame
:
:
GetCurrentPosition
(
nsIContent
*
content
)
{
return
GetIntegerAttribute
(
content
nsGkAtoms
:
:
curpos
0
)
;
}
int32_t
nsSliderFrame
:
:
GetMinPosition
(
nsIContent
*
content
)
{
return
GetIntegerAttribute
(
content
nsGkAtoms
:
:
minpos
0
)
;
}
int32_t
nsSliderFrame
:
:
GetMaxPosition
(
nsIContent
*
content
)
{
return
GetIntegerAttribute
(
content
nsGkAtoms
:
:
maxpos
100
)
;
}
int32_t
nsSliderFrame
:
:
GetIncrement
(
nsIContent
*
content
)
{
return
GetIntegerAttribute
(
content
nsGkAtoms
:
:
increment
1
)
;
}
int32_t
nsSliderFrame
:
:
GetPageIncrement
(
nsIContent
*
content
)
{
return
GetIntegerAttribute
(
content
nsGkAtoms
:
:
pageincrement
10
)
;
}
int32_t
nsSliderFrame
:
:
GetIntegerAttribute
(
nsIContent
*
content
nsAtom
*
atom
int32_t
defaultValue
)
{
nsAutoString
value
;
if
(
content
-
>
IsElement
(
)
)
{
content
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
atom
value
)
;
}
if
(
!
value
.
IsEmpty
(
)
)
{
nsresult
error
;
defaultValue
=
value
.
ToInteger
(
&
error
)
;
}
return
defaultValue
;
}
nsresult
nsSliderFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
nsresult
rv
=
nsBoxFrame
:
:
AttributeChanged
(
aNameSpaceID
aAttribute
aModType
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
curpos
)
{
CurrentPositionChanged
(
)
;
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
minpos
|
|
aAttribute
=
=
nsGkAtoms
:
:
maxpos
)
{
nsIFrame
*
scrollbarBox
=
GetScrollbar
(
)
;
nsCOMPtr
<
nsIContent
>
scrollbar
=
GetContentOfBox
(
scrollbarBox
)
;
int32_t
current
=
GetCurrentPosition
(
scrollbar
)
;
int32_t
min
=
GetMinPosition
(
scrollbar
)
;
int32_t
max
=
GetMaxPosition
(
scrollbar
)
;
if
(
current
<
min
|
|
current
>
max
)
{
int32_t
direction
=
0
;
if
(
current
<
min
|
|
max
<
min
)
{
current
=
min
;
direction
=
-
1
;
}
else
if
(
current
>
max
)
{
current
=
max
;
direction
=
1
;
}
nsScrollbarFrame
*
scrollbarFrame
=
do_QueryFrame
(
scrollbarBox
)
;
if
(
scrollbarFrame
)
{
nsIScrollbarMediator
*
mediator
=
scrollbarFrame
-
>
GetScrollbarMediator
(
)
;
scrollbarFrame
-
>
SetIncrementToWhole
(
direction
)
;
if
(
mediator
)
{
mediator
-
>
ScrollByWhole
(
scrollbarFrame
direction
nsIScrollbarMediator
:
:
ENABLE_SNAP
)
;
}
}
nsContentUtils
:
:
AddScriptRunner
(
new
nsSetAttrRunnable
(
scrollbar
-
>
AsElement
(
)
nsGkAtoms
:
:
curpos
current
)
)
;
}
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
minpos
|
|
aAttribute
=
=
nsGkAtoms
:
:
maxpos
|
|
aAttribute
=
=
nsGkAtoms
:
:
pageincrement
|
|
aAttribute
=
=
nsGkAtoms
:
:
increment
)
{
PresShell
(
)
-
>
FrameNeedsReflow
(
this
IntrinsicDirty
:
:
StyleChange
NS_FRAME_IS_DIRTY
)
;
}
return
rv
;
}
class
nsDisplaySliderMarks
final
:
public
nsPaintedDisplayItem
{
public
:
nsDisplaySliderMarks
(
nsDisplayListBuilder
*
aBuilder
nsSliderFrame
*
aFrame
)
:
nsPaintedDisplayItem
(
aBuilder
aFrame
)
{
MOZ_COUNT_CTOR
(
nsDisplaySliderMarks
)
;
}
MOZ_COUNTED_DTOR_OVERRIDE
(
nsDisplaySliderMarks
)
NS_DISPLAY_DECL_NAME
(
"
SliderMarks
"
TYPE_SLIDER_MARKS
)
void
PaintMarks
(
nsDisplayListBuilder
*
aDisplayListBuilder
wr
:
:
DisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
;
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
{
*
aSnap
=
false
;
return
mFrame
-
>
InkOverflowRectRelativeToSelf
(
)
+
ToReferenceFrame
(
)
;
}
bool
CreateWebRenderCommands
(
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
;
}
;
void
nsDisplaySliderMarks
:
:
PaintMarks
(
nsDisplayListBuilder
*
aDisplayListBuilder
wr
:
:
DisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
DrawTarget
*
drawTarget
=
nullptr
;
if
(
aCtx
)
{
drawTarget
=
aCtx
-
>
GetDrawTarget
(
)
;
}
else
{
MOZ_ASSERT
(
aBuilder
)
;
}
Document
*
doc
=
mFrame
-
>
GetContent
(
)
-
>
GetUncomposedDoc
(
)
;
if
(
!
doc
)
{
return
;
}
nsGlobalWindowInner
*
window
=
nsGlobalWindowInner
:
:
Cast
(
doc
-
>
GetInnerWindow
(
)
)
;
if
(
!
window
)
{
return
;
}
nsSliderFrame
*
sliderFrame
=
static_cast
<
nsSliderFrame
*
>
(
mFrame
)
;
nsIFrame
*
scrollbarBox
=
sliderFrame
-
>
GetScrollbar
(
)
;
nsCOMPtr
<
nsIContent
>
scrollbar
=
GetContentOfBox
(
scrollbarBox
)
;
int32_t
minPos
=
sliderFrame
-
>
GetMinPosition
(
scrollbar
)
;
int32_t
maxPos
=
sliderFrame
-
>
GetMaxPosition
(
scrollbar
)
;
nscolor
highlightColor
=
LookAndFeel
:
:
Color
(
LookAndFeel
:
:
ColorID
:
:
TextHighlightBackground
mFrame
)
;
DeviceColor
fillColor
=
ToDeviceColor
(
highlightColor
)
;
fillColor
.
a
=
0
.
3
;
int32_t
appUnitsPerDevPixel
=
sliderFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
nsRect
sliderRect
=
sliderFrame
-
>
GetRect
(
)
;
nsPoint
refPoint
=
aDisplayListBuilder
-
>
ToReferenceFrame
(
mFrame
)
;
float
increasePixels
=
sliderFrame
-
>
PresContext
(
)
-
>
DeviceContext
(
)
-
>
GetDesktopToDeviceScale
(
)
.
scale
;
nsTArray
<
uint32_t
>
&
marks
=
window
-
>
GetScrollMarks
(
)
;
for
(
uint32_t
m
=
0
;
m
<
marks
.
Length
(
)
;
m
+
+
)
{
uint32_t
markValue
=
marks
[
m
]
;
if
(
markValue
>
(
uint32_t
)
maxPos
)
{
markValue
=
maxPos
;
}
if
(
markValue
<
(
uint32_t
)
minPos
)
{
markValue
=
minPos
;
}
nsRect
markRect
(
refPoint
nsSize
(
sliderRect
.
width
0
)
)
;
markRect
.
y
+
=
(
nscoord
)
(
(
double
)
markValue
/
(
maxPos
-
minPos
)
*
sliderRect
.
height
)
;
if
(
drawTarget
)
{
Rect
devPixelRect
=
NSRectToSnappedRect
(
markRect
appUnitsPerDevPixel
*
drawTarget
)
;
devPixelRect
.
Inflate
(
0
increasePixels
)
;
drawTarget
-
>
FillRect
(
devPixelRect
ColorPattern
(
fillColor
)
)
;
}
else
{
LayoutDeviceIntRect
dRect
=
LayoutDeviceIntRect
:
:
FromAppUnitsToNearest
(
markRect
appUnitsPerDevPixel
)
;
dRect
.
Inflate
(
0
increasePixels
)
;
wr
:
:
LayoutRect
layoutRect
=
wr
:
:
ToLayoutRect
(
dRect
)
;
aBuilder
-
>
PushRect
(
layoutRect
layoutRect
BackfaceIsHidden
(
)
wr
:
:
ToColorF
(
fillColor
)
)
;
}
}
}
bool
nsDisplaySliderMarks
:
:
CreateWebRenderCommands
(
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
PaintMarks
(
aDisplayListBuilder
&
aBuilder
nullptr
)
;
return
true
;
}
void
nsDisplaySliderMarks
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
PaintMarks
(
aBuilder
nullptr
aCtx
)
;
}
void
nsSliderFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
if
(
aBuilder
-
>
IsForEventDelivery
(
)
&
&
isDraggingThumb
(
)
)
{
aLists
.
Outlines
(
)
-
>
AppendNewToTop
<
nsDisplayEventReceiver
>
(
aBuilder
this
)
;
return
;
}
nsBoxFrame
:
:
BuildDisplayList
(
aBuilder
aLists
)
;
if
(
!
aBuilder
-
>
IsForEventDelivery
(
)
)
{
nsIFrame
*
scrollbarBox
=
GetScrollbar
(
)
;
if
(
scrollbarBox
&
&
!
IsXULHorizontal
(
)
)
{
if
(
nsIScrollableFrame
*
scrollFrame
=
do_QueryFrame
(
scrollbarBox
-
>
GetParent
(
)
)
)
{
if
(
scrollFrame
-
>
IsRootScrollFrameOfDocument
(
)
)
{
Document
*
doc
=
mContent
-
>
GetUncomposedDoc
(
)
;
if
(
doc
)
{
nsGlobalWindowInner
*
window
=
nsGlobalWindowInner
:
:
Cast
(
doc
-
>
GetInnerWindow
(
)
)
;
if
(
window
&
&
window
-
>
GetScrollMarks
(
)
.
Length
(
)
>
0
)
{
aLists
.
Content
(
)
-
>
AppendNewToTop
<
nsDisplaySliderMarks
>
(
aBuilder
this
)
;
}
}
}
}
}
}
}
static
bool
UsesCustomScrollbarMediator
(
nsIFrame
*
scrollbarBox
)
{
if
(
nsScrollbarFrame
*
scrollbarFrame
=
do_QueryFrame
(
scrollbarBox
)
)
{
if
(
nsIScrollbarMediator
*
mediator
=
scrollbarFrame
-
>
GetScrollbarMediator
(
)
)
{
nsIScrollableFrame
*
scrollFrame
=
do_QueryFrame
(
mediator
)
;
if
(
!
scrollFrame
)
{
return
true
;
}
}
}
return
false
;
}
void
nsSliderFrame
:
:
BuildDisplayListForChildren
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
nsIFrame
*
thumb
=
nsIFrame
:
:
GetChildXULBox
(
this
)
;
if
(
thumb
)
{
nsRect
thumbRect
(
thumb
-
>
GetRect
(
)
)
;
nsMargin
m
;
thumb
-
>
GetXULMargin
(
m
)
;
thumbRect
.
Inflate
(
m
)
;
nsRect
sliderTrack
;
GetXULClientRect
(
sliderTrack
)
;
if
(
sliderTrack
.
width
<
thumbRect
.
width
|
|
sliderTrack
.
height
<
thumbRect
.
height
)
return
;
const
mozilla
:
:
layers
:
:
ScrollableLayerGuid
:
:
ViewID
scrollTargetId
=
aBuilder
-
>
GetCurrentScrollbarTarget
(
)
;
const
bool
thumbGetsLayer
=
(
scrollTargetId
!
=
layers
:
:
ScrollableLayerGuid
:
:
NULL_SCROLL_ID
)
;
if
(
thumbGetsLayer
)
{
const
Maybe
<
ScrollDirection
>
scrollDirection
=
aBuilder
-
>
GetCurrentScrollbarDirection
(
)
;
MOZ_ASSERT
(
scrollDirection
.
isSome
(
)
)
;
const
bool
isHorizontal
=
*
scrollDirection
=
=
ScrollDirection
:
:
eHorizontal
;
const
float
appUnitsPerCss
=
float
(
AppUnitsPerCSSPixel
(
)
)
;
const
CSSCoord
thumbLength
=
NSAppUnitsToFloatPixels
(
isHorizontal
?
thumbRect
.
width
:
thumbRect
.
height
appUnitsPerCss
)
;
nsIFrame
*
scrollbarBox
=
GetScrollbar
(
)
;
bool
isAsyncDraggable
=
!
UsesCustomScrollbarMediator
(
scrollbarBox
)
;
nsPoint
scrollPortOrigin
;
if
(
nsIScrollableFrame
*
scrollFrame
=
do_QueryFrame
(
scrollbarBox
-
>
GetParent
(
)
)
)
{
scrollPortOrigin
=
scrollFrame
-
>
GetScrollPortRect
(
)
.
TopLeft
(
)
;
}
else
{
isAsyncDraggable
=
false
;
}
sliderTrack
=
sliderTrack
+
GetRect
(
)
.
TopLeft
(
)
+
scrollbarBox
-
>
GetPosition
(
)
-
scrollPortOrigin
;
const
CSSCoord
sliderTrackStart
=
NSAppUnitsToFloatPixels
(
isHorizontal
?
sliderTrack
.
x
:
sliderTrack
.
y
appUnitsPerCss
)
;
const
CSSCoord
sliderTrackLength
=
NSAppUnitsToFloatPixels
(
isHorizontal
?
sliderTrack
.
width
:
sliderTrack
.
height
appUnitsPerCss
)
;
const
CSSCoord
thumbStart
=
NSAppUnitsToFloatPixels
(
isHorizontal
?
thumbRect
.
x
:
thumbRect
.
y
appUnitsPerCss
)
;
const
nsRect
overflow
=
thumb
-
>
InkOverflowRectRelativeToParent
(
)
;
nsSize
refSize
=
aBuilder
-
>
RootReferenceFrame
(
)
-
>
GetSize
(
)
;
nsRect
dirty
=
aBuilder
-
>
GetVisibleRect
(
)
.
Intersect
(
thumbRect
)
;
dirty
=
nsLayoutUtils
:
:
ComputePartialPrerenderArea
(
thumb
aBuilder
-
>
GetVisibleRect
(
)
overflow
refSize
)
;
nsDisplayListBuilder
:
:
AutoBuildingDisplayList
buildingDisplayList
(
aBuilder
this
dirty
dirty
)
;
DisplayListClipState
:
:
AutoSaveRestore
thumbClipState
(
aBuilder
)
;
thumbClipState
.
ClipContainingBlockDescendants
(
GetRectRelativeToSelf
(
)
+
aBuilder
-
>
ToReferenceFrame
(
this
)
)
;
DisplayListClipState
:
:
AutoSaveRestore
thumbContentsClipState
(
aBuilder
)
;
thumbContentsClipState
.
Clear
(
)
;
nsDisplayListBuilder
:
:
AutoContainerASRTracker
contASRTracker
(
aBuilder
)
;
nsDisplayListCollection
tempLists
(
aBuilder
)
;
nsBoxFrame
:
:
BuildDisplayListForChildren
(
aBuilder
tempLists
)
;
nsDisplayList
masterList
;
masterList
.
AppendToTop
(
tempLists
.
BorderBackground
(
)
)
;
masterList
.
AppendToTop
(
tempLists
.
BlockBorderBackgrounds
(
)
)
;
masterList
.
AppendToTop
(
tempLists
.
Floats
(
)
)
;
masterList
.
AppendToTop
(
tempLists
.
Content
(
)
)
;
masterList
.
AppendToTop
(
tempLists
.
PositionedDescendants
(
)
)
;
masterList
.
AppendToTop
(
tempLists
.
Outlines
(
)
)
;
thumbContentsClipState
.
Restore
(
)
;
const
ActiveScrolledRoot
*
ownLayerASR
=
contASRTracker
.
GetContainerASR
(
)
;
aLists
.
Content
(
)
-
>
AppendNewToTopWithIndex
<
nsDisplayOwnLayer
>
(
aBuilder
this
nsDisplayOwnLayer
:
:
OwnLayerForScrollThumb
&
masterList
ownLayerASR
nsDisplayOwnLayerFlags
:
:
None
ScrollbarData
:
:
CreateForThumb
(
*
scrollDirection
GetThumbRatio
(
)
thumbStart
thumbLength
isAsyncDraggable
sliderTrackStart
sliderTrackLength
scrollTargetId
)
true
false
)
;
return
;
}
}
nsBoxFrame
:
:
BuildDisplayListForChildren
(
aBuilder
aLists
)
;
}
NS_IMETHODIMP
nsSliderFrame
:
:
DoXULLayout
(
nsBoxLayoutState
&
aState
)
{
nsIFrame
*
thumbBox
=
nsIFrame
:
:
GetChildXULBox
(
this
)
;
if
(
!
thumbBox
)
{
SyncXULLayout
(
aState
)
;
return
NS_OK
;
}
EnsureOrient
(
)
;
nsRect
clientRect
;
GetXULClientRect
(
clientRect
)
;
nsIFrame
*
scrollbarBox
=
GetScrollbar
(
)
;
nsCOMPtr
<
nsIContent
>
scrollbar
=
GetContentOfBox
(
scrollbarBox
)
;
nsSize
thumbSize
=
thumbBox
-
>
GetXULPrefSize
(
aState
)
;
if
(
IsXULHorizontal
(
)
)
thumbSize
.
height
=
clientRect
.
height
;
else
thumbSize
.
width
=
clientRect
.
width
;
int32_t
curPos
=
GetCurrentPosition
(
scrollbar
)
;
int32_t
minPos
=
GetMinPosition
(
scrollbar
)
;
int32_t
maxPos
=
GetMaxPosition
(
scrollbar
)
;
int32_t
pageIncrement
=
GetPageIncrement
(
scrollbar
)
;
maxPos
=
std
:
:
max
(
minPos
maxPos
)
;
curPos
=
clamped
(
curPos
minPos
maxPos
)
;
nscoord
&
availableLength
=
IsXULHorizontal
(
)
?
clientRect
.
width
:
clientRect
.
height
;
nscoord
&
thumbLength
=
IsXULHorizontal
(
)
?
thumbSize
.
width
:
thumbSize
.
height
;
if
(
(
pageIncrement
+
maxPos
-
minPos
)
>
0
&
&
thumbBox
-
>
GetXULFlex
(
)
>
0
)
{
float
ratio
=
float
(
pageIncrement
)
/
float
(
maxPos
-
minPos
+
pageIncrement
)
;
thumbLength
=
std
:
:
max
(
thumbLength
NSToCoordRound
(
availableLength
*
ratio
)
)
;
}
nsPresContext
*
presContext
=
PresContext
(
)
;
thumbLength
=
presContext
-
>
DevPixelsToAppUnits
(
presContext
-
>
AppUnitsToDevPixels
(
thumbLength
)
)
;
mRatio
=
(
minPos
!
=
maxPos
)
?
float
(
availableLength
-
thumbLength
)
/
float
(
maxPos
-
minPos
)
:
1
;
bool
reverse
=
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
dir
nsGkAtoms
:
:
reverse
eCaseMatters
)
;
nscoord
pos
=
reverse
?
(
maxPos
-
curPos
)
:
(
curPos
-
minPos
)
;
nsRect
thumbRect
(
clientRect
.
x
clientRect
.
y
thumbSize
.
width
thumbSize
.
height
)
;
int32_t
&
thumbPos
=
(
IsXULHorizontal
(
)
?
thumbRect
.
x
:
thumbRect
.
y
)
;
thumbPos
+
=
NSToCoordRound
(
pos
*
mRatio
)
;
nsRect
oldThumbRect
(
thumbBox
-
>
GetRect
(
)
)
;
LayoutChildAt
(
aState
thumbBox
thumbRect
)
;
SyncXULLayout
(
aState
)
;
if
(
!
oldThumbRect
.
IsEqualInterior
(
thumbRect
)
)
XULRedraw
(
aState
)
;
return
NS_OK
;
}
nsresult
nsSliderFrame
:
:
HandleEvent
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
{
NS_ENSURE_ARG_POINTER
(
aEventStatus
)
;
if
(
mAPZDragInitiated
&
&
*
mAPZDragInitiated
=
=
InputAPZContext
:
:
GetInputBlockId
(
)
&
&
aEvent
-
>
mMessage
=
=
eMouseDown
)
{
mAPZDragInitiated
=
Nothing
(
)
;
DragThumb
(
true
)
;
mScrollingWithAPZ
=
true
;
return
NS_OK
;
}
if
(
!
mContent
-
>
IsInNativeAnonymousSubtree
(
)
&
&
nsEventStatus_eConsumeNoDefault
=
=
*
aEventStatus
)
{
return
NS_OK
;
}
if
(
!
mDragFinished
&
&
!
isDraggingThumb
(
)
)
{
StopDrag
(
)
;
return
NS_OK
;
}
nsIFrame
*
scrollbarBox
=
GetScrollbar
(
)
;
nsCOMPtr
<
nsIContent
>
scrollbar
;
scrollbar
=
GetContentOfBox
(
scrollbarBox
)
;
bool
isHorizontal
=
IsXULHorizontal
(
)
;
if
(
isDraggingThumb
(
)
)
{
switch
(
aEvent
-
>
mMessage
)
{
case
eTouchMove
:
case
eMouseMove
:
{
if
(
mScrollingWithAPZ
)
{
break
;
}
nsPoint
eventPoint
;
if
(
!
GetEventPoint
(
aEvent
eventPoint
)
)
{
break
;
}
if
(
mChange
)
{
#
ifndef
MOZ_WIDGET_GTK
mDestinationPoint
=
eventPoint
;
StopRepeat
(
)
;
StartRepeat
(
)
;
#
endif
break
;
}
nscoord
pos
=
isHorizontal
?
eventPoint
.
x
:
eventPoint
.
y
;
nsIFrame
*
thumbFrame
=
mFrames
.
FirstChild
(
)
;
if
(
!
thumbFrame
)
{
return
NS_OK
;
}
pos
-
=
mDragStart
;
bool
isMouseOutsideThumb
=
false
;
if
(
gSnapMultiplier
)
{
nsSize
thumbSize
=
thumbFrame
-
>
GetSize
(
)
;
if
(
isHorizontal
)
{
if
(
eventPoint
.
y
<
-
gSnapMultiplier
*
thumbSize
.
height
|
|
eventPoint
.
y
>
thumbSize
.
height
+
gSnapMultiplier
*
thumbSize
.
height
)
isMouseOutsideThumb
=
true
;
}
else
{
if
(
eventPoint
.
x
<
-
gSnapMultiplier
*
thumbSize
.
width
|
|
eventPoint
.
x
>
thumbSize
.
width
+
gSnapMultiplier
*
thumbSize
.
width
)
isMouseOutsideThumb
=
true
;
}
}
if
(
aEvent
-
>
mClass
=
=
eTouchEventClass
)
{
*
aEventStatus
=
nsEventStatus_eConsumeNoDefault
;
}
if
(
isMouseOutsideThumb
)
{
SetCurrentThumbPosition
(
scrollbar
mThumbStart
false
false
)
;
return
NS_OK
;
}
SetCurrentThumbPosition
(
scrollbar
pos
false
true
)
;
}
break
;
case
eTouchEnd
:
case
eMouseUp
:
if
(
ShouldScrollForEvent
(
aEvent
)
)
{
StopDrag
(
)
;
return
nsIFrame
:
:
HandleEvent
(
aPresContext
aEvent
aEventStatus
)
;
}
break
;
default
:
break
;
}
return
NS_OK
;
}
if
(
ShouldScrollToClickForEvent
(
aEvent
)
)
{
nsPoint
eventPoint
;
if
(
!
GetEventPoint
(
aEvent
eventPoint
)
)
{
return
NS_OK
;
}
nscoord
pos
=
isHorizontal
?
eventPoint
.
x
:
eventPoint
.
y
;
nsIFrame
*
thumbFrame
=
mFrames
.
FirstChild
(
)
;
if
(
!
thumbFrame
)
{
return
NS_OK
;
}
nsSize
thumbSize
=
thumbFrame
-
>
GetSize
(
)
;
nscoord
thumbLength
=
isHorizontal
?
thumbSize
.
width
:
thumbSize
.
height
;
AutoWeakFrame
weakFrame
(
this
)
;
SetCurrentThumbPosition
(
scrollbar
pos
-
thumbLength
/
2
false
false
)
;
NS_ENSURE_TRUE
(
weakFrame
.
IsAlive
(
)
NS_OK
)
;
DragThumb
(
true
)
;
#
ifdef
MOZ_WIDGET_GTK
RefPtr
<
dom
:
:
Element
>
thumb
=
thumbFrame
-
>
GetContent
(
)
-
>
AsElement
(
)
;
thumb
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
active
u
"
true
"
_ns
true
)
;
#
endif
if
(
aEvent
-
>
mClass
=
=
eTouchEventClass
)
{
*
aEventStatus
=
nsEventStatus_eConsumeNoDefault
;
}
if
(
isHorizontal
)
mThumbStart
=
thumbFrame
-
>
GetPosition
(
)
.
x
;
else
mThumbStart
=
thumbFrame
-
>
GetPosition
(
)
.
y
;
mDragStart
=
pos
-
mThumbStart
;
}
#
ifdef
MOZ_WIDGET_GTK
else
if
(
ShouldScrollForEvent
(
aEvent
)
&
&
aEvent
-
>
mClass
=
=
eMouseEventClass
&
&
aEvent
-
>
AsMouseEvent
(
)
-
>
mButton
=
=
MouseButton
:
:
eSecondary
)
{
if
(
aEvent
-
>
mMessage
=
=
eMouseDown
)
{
HandlePress
(
aPresContext
aEvent
aEventStatus
)
;
}
else
if
(
aEvent
-
>
mMessage
=
=
eMouseUp
)
{
HandleRelease
(
aPresContext
aEvent
aEventStatus
)
;
}
return
NS_OK
;
}
#
endif
if
(
aEvent
-
>
mMessage
=
=
eMouseOut
&
&
mChange
)
HandleRelease
(
aPresContext
aEvent
aEventStatus
)
;
return
nsIFrame
:
:
HandleEvent
(
aPresContext
aEvent
aEventStatus
)
;
}
bool
nsSliderFrame
:
:
GetScrollToClick
(
)
{
if
(
GetScrollbar
(
)
!
=
this
)
{
return
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
IntID
:
:
ScrollToClick
false
)
;
}
if
(
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
movetoclick
nsGkAtoms
:
:
_true
eCaseMatters
)
)
{
return
true
;
}
if
(
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
movetoclick
nsGkAtoms
:
:
_false
eCaseMatters
)
)
{
return
false
;
}
#
ifdef
XP_MACOSX
return
true
;
#
else
return
false
;
#
endif
}
nsIFrame
*
nsSliderFrame
:
:
GetScrollbar
(
)
{
nsIFrame
*
scrollbar
;
nsScrollbarButtonFrame
:
:
GetParentWithTag
(
nsGkAtoms
:
:
scrollbar
this
scrollbar
)
;
if
(
scrollbar
=
=
nullptr
)
return
this
;
return
scrollbar
-
>
IsXULBoxFrame
(
)
?
scrollbar
:
this
;
}
void
nsSliderFrame
:
:
PageUpDown
(
nscoord
change
)
{
nsIFrame
*
scrollbarBox
=
GetScrollbar
(
)
;
nsCOMPtr
<
nsIContent
>
scrollbar
;
scrollbar
=
GetContentOfBox
(
scrollbarBox
)
;
nscoord
pageIncrement
=
GetPageIncrement
(
scrollbar
)
;
int32_t
curpos
=
GetCurrentPosition
(
scrollbar
)
;
int32_t
minpos
=
GetMinPosition
(
scrollbar
)
;
int32_t
maxpos
=
GetMaxPosition
(
scrollbar
)
;
int32_t
newpos
=
curpos
+
change
*
pageIncrement
;
if
(
newpos
<
minpos
|
|
maxpos
<
minpos
)
newpos
=
minpos
;
else
if
(
newpos
>
maxpos
)
newpos
=
maxpos
;
SetCurrentPositionInternal
(
scrollbar
newpos
true
)
;
}
void
nsSliderFrame
:
:
CurrentPositionChanged
(
)
{
nsIFrame
*
scrollbarBox
=
GetScrollbar
(
)
;
nsCOMPtr
<
nsIContent
>
scrollbar
=
GetContentOfBox
(
scrollbarBox
)
;
int32_t
curPos
=
GetCurrentPosition
(
scrollbar
)
;
if
(
mCurPos
=
=
curPos
)
return
;
int32_t
minPos
=
GetMinPosition
(
scrollbar
)
;
int32_t
maxPos
=
GetMaxPosition
(
scrollbar
)
;
maxPos
=
std
:
:
max
(
minPos
maxPos
)
;
curPos
=
clamped
(
curPos
minPos
maxPos
)
;
nsIFrame
*
thumbFrame
=
mFrames
.
FirstChild
(
)
;
if
(
!
thumbFrame
)
return
;
nsRect
thumbRect
=
thumbFrame
-
>
GetRect
(
)
;
nsRect
clientRect
;
GetXULClientRect
(
clientRect
)
;
nsRect
newThumbRect
(
thumbRect
)
;
bool
reverse
=
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
dir
nsGkAtoms
:
:
reverse
eCaseMatters
)
;
nscoord
pos
=
reverse
?
(
maxPos
-
curPos
)
:
(
curPos
-
minPos
)
;
if
(
IsXULHorizontal
(
)
)
newThumbRect
.
x
=
clientRect
.
x
+
NSToCoordRound
(
pos
*
mRatio
)
;
else
newThumbRect
.
y
=
clientRect
.
y
+
NSToCoordRound
(
pos
*
mRatio
)
;
nscoord
appUnitsPerPixel
=
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
nsPoint
snappedThumbLocation
=
ToAppUnits
(
newThumbRect
.
TopLeft
(
)
.
ToNearestPixels
(
appUnitsPerPixel
)
appUnitsPerPixel
)
;
if
(
IsXULHorizontal
(
)
)
{
newThumbRect
.
x
=
snappedThumbLocation
.
x
;
}
else
{
newThumbRect
.
y
=
snappedThumbLocation
.
y
;
}
thumbFrame
-
>
SetRect
(
newThumbRect
)
;
nsScrollbarFrame
*
scrollbarFrame
=
do_QueryFrame
(
scrollbarBox
)
;
nsIScrollbarMediator
*
mediator
=
scrollbarFrame
?
scrollbarFrame
-
>
GetScrollbarMediator
(
)
:
nullptr
;
if
(
!
mediator
|
|
!
mediator
-
>
ShouldSuppressScrollbarRepaints
(
)
)
{
SchedulePaint
(
)
;
}
mCurPos
=
curPos
;
}
static
void
UpdateAttribute
(
dom
:
:
Element
*
aScrollbar
nscoord
aNewPos
bool
aNotify
bool
aIsSmooth
)
{
nsAutoString
str
;
str
.
AppendInt
(
aNewPos
)
;
if
(
aIsSmooth
)
{
aScrollbar
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
smooth
u
"
true
"
_ns
false
)
;
}
aScrollbar
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
curpos
str
aNotify
)
;
if
(
aIsSmooth
)
{
aScrollbar
-
>
UnsetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
smooth
false
)
;
}
}
void
nsSliderFrame
:
:
SetCurrentThumbPosition
(
nsIContent
*
aScrollbar
nscoord
aNewThumbPos
bool
aIsSmooth
bool
aMaySnap
)
{
nsRect
crect
;
GetXULClientRect
(
crect
)
;
nscoord
offset
=
IsXULHorizontal
(
)
?
crect
.
x
:
crect
.
y
;
int32_t
newPos
=
NSToIntRound
(
(
aNewThumbPos
-
offset
)
/
mRatio
)
;
if
(
aMaySnap
&
&
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
snap
nsGkAtoms
:
:
_true
eCaseMatters
)
)
{
int32_t
increment
=
GetIncrement
(
aScrollbar
)
;
newPos
=
NSToIntRound
(
newPos
/
float
(
increment
)
)
*
increment
;
}
SetCurrentPosition
(
aScrollbar
newPos
aIsSmooth
)
;
}
void
nsSliderFrame
:
:
SetCurrentPosition
(
nsIContent
*
aScrollbar
int32_t
aNewPos
bool
aIsSmooth
)
{
int32_t
minpos
=
GetMinPosition
(
aScrollbar
)
;
int32_t
maxpos
=
GetMaxPosition
(
aScrollbar
)
;
if
(
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
dir
nsGkAtoms
:
:
reverse
eCaseMatters
)
)
aNewPos
=
maxpos
-
aNewPos
;
else
aNewPos
+
=
minpos
;
if
(
aNewPos
<
minpos
|
|
maxpos
<
minpos
)
aNewPos
=
minpos
;
else
if
(
aNewPos
>
maxpos
)
aNewPos
=
maxpos
;
SetCurrentPositionInternal
(
aScrollbar
aNewPos
aIsSmooth
)
;
}
void
nsSliderFrame
:
:
SetCurrentPositionInternal
(
nsIContent
*
aScrollbar
int32_t
aNewPos
bool
aIsSmooth
)
{
nsCOMPtr
<
nsIContent
>
scrollbar
=
aScrollbar
;
nsIFrame
*
scrollbarBox
=
GetScrollbar
(
)
;
AutoWeakFrame
weakFrame
(
this
)
;
mUserChanged
=
true
;
nsScrollbarFrame
*
scrollbarFrame
=
do_QueryFrame
(
scrollbarBox
)
;
if
(
scrollbarFrame
)
{
nsIScrollbarMediator
*
mediator
=
scrollbarFrame
-
>
GetScrollbarMediator
(
)
;
if
(
mediator
)
{
nscoord
oldPos
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
GetCurrentPosition
(
scrollbar
)
)
;
nscoord
newPos
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
aNewPos
)
;
mediator
-
>
ThumbMoved
(
scrollbarFrame
oldPos
newPos
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
;
}
UpdateAttribute
(
scrollbar
-
>
AsElement
(
)
aNewPos
false
aIsSmooth
)
;
CurrentPositionChanged
(
)
;
mUserChanged
=
false
;
return
;
}
}
UpdateAttribute
(
scrollbar
-
>
AsElement
(
)
aNewPos
true
aIsSmooth
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
;
}
mUserChanged
=
false
;
#
ifdef
DEBUG_SLIDER
printf
(
"
Current
Pos
=
%
d
\
n
"
aNewPos
)
;
#
endif
}
void
nsSliderFrame
:
:
SetInitialChildList
(
ChildListID
aListID
nsFrameList
&
aChildList
)
{
nsBoxFrame
:
:
SetInitialChildList
(
aListID
aChildList
)
;
if
(
aListID
=
=
kPrincipalList
)
{
AddListener
(
)
;
}
}
nsresult
nsSliderMediator
:
:
HandleEvent
(
dom
:
:
Event
*
aEvent
)
{
if
(
mSlider
&
&
!
mSlider
-
>
isDraggingThumb
(
)
)
return
mSlider
-
>
StartDrag
(
aEvent
)
;
return
NS_OK
;
}
static
bool
ScrollFrameWillBuildScrollInfoLayer
(
nsIFrame
*
aScrollFrame
)
{
nsIFrame
*
current
=
aScrollFrame
;
while
(
current
)
{
if
(
SVGIntegrationUtils
:
:
UsesSVGEffectsNotSupportedInCompositor
(
current
)
)
{
return
true
;
}
current
=
nsLayoutUtils
:
:
GetParentOrPlaceholderForCrossDoc
(
current
)
;
}
return
false
;
}
nsIScrollableFrame
*
nsSliderFrame
:
:
GetScrollFrame
(
)
{
nsIFrame
*
scrollbarBox
=
GetScrollbar
(
)
;
if
(
!
scrollbarBox
)
{
return
nullptr
;
}
nsContainerFrame
*
scrollFrame
=
scrollbarBox
-
>
GetParent
(
)
;
if
(
!
scrollFrame
)
{
return
nullptr
;
}
nsIScrollableFrame
*
scrollFrameAsScrollable
=
do_QueryFrame
(
scrollFrame
)
;
return
scrollFrameAsScrollable
;
}
void
nsSliderFrame
:
:
StartAPZDrag
(
WidgetGUIEvent
*
aEvent
)
{
if
(
!
aEvent
-
>
mFlags
.
mHandledByAPZ
)
{
return
;
}
if
(
!
gfxPlatform
:
:
GetPlatform
(
)
-
>
SupportsApzDragInput
(
)
)
{
return
;
}
nsIFrame
*
scrollbarBox
=
GetScrollbar
(
)
;
nsContainerFrame
*
scrollFrame
=
scrollbarBox
-
>
GetParent
(
)
;
if
(
!
scrollFrame
)
{
return
;
}
nsIContent
*
scrollableContent
=
scrollFrame
-
>
GetContent
(
)
;
if
(
!
scrollableContent
)
{
return
;
}
if
(
ScrollFrameWillBuildScrollInfoLayer
(
scrollFrame
)
)
{
return
;
}
if
(
UsesCustomScrollbarMediator
(
scrollbarBox
)
)
{
return
;
}
bool
isHorizontal
=
IsXULHorizontal
(
)
;
mozilla
:
:
layers
:
:
ScrollableLayerGuid
:
:
ViewID
scrollTargetId
;
bool
hasID
=
nsLayoutUtils
:
:
FindIDFor
(
scrollableContent
&
scrollTargetId
)
;
bool
hasAPZView
=
hasID
&
&
(
scrollTargetId
!
=
layers
:
:
ScrollableLayerGuid
:
:
NULL_SCROLL_ID
)
;
if
(
!
hasAPZView
)
{
return
;
}
if
(
!
DisplayPortUtils
:
:
HasNonMinimalDisplayPort
(
scrollableContent
)
)
{
return
;
}
mozilla
:
:
PresShell
*
presShell
=
PresShell
(
)
;
uint64_t
inputblockId
=
InputAPZContext
:
:
GetInputBlockId
(
)
;
uint32_t
presShellId
=
presShell
-
>
GetPresShellId
(
)
;
AsyncDragMetrics
dragMetrics
(
scrollTargetId
presShellId
inputblockId
NSAppUnitsToFloatPixels
(
mDragStart
float
(
AppUnitsPerCSSPixel
(
)
)
)
isHorizontal
?
ScrollDirection
:
:
eHorizontal
:
ScrollDirection
:
:
eVertical
)
;
mScrollingWithAPZ
=
true
;
bool
waitForRefresh
=
InputAPZContext
:
:
HavePendingLayerization
(
)
;
nsIWidget
*
widget
=
this
-
>
GetNearestWidget
(
)
;
if
(
waitForRefresh
)
{
waitForRefresh
=
false
;
if
(
nsPresContext
*
presContext
=
presShell
-
>
GetPresContext
(
)
)
{
waitForRefresh
=
presContext
-
>
RegisterManagedPostRefreshObserver
(
new
ManagedPostRefreshObserver
(
presShell
[
widget
=
RefPtr
<
nsIWidget
>
(
widget
)
dragMetrics
]
(
bool
aWasCanceled
)
{
if
(
!
aWasCanceled
)
{
widget
-
>
StartAsyncScrollbarDrag
(
dragMetrics
)
;
}
return
ManagedPostRefreshObserver
:
:
Unregister
:
:
Yes
;
}
)
)
;
}
}
if
(
!
waitForRefresh
)
{
widget
-
>
StartAsyncScrollbarDrag
(
dragMetrics
)
;
}
}
nsresult
nsSliderFrame
:
:
StartDrag
(
Event
*
aEvent
)
{
#
ifdef
DEBUG_SLIDER
printf
(
"
Begin
dragging
\
n
"
)
;
#
endif
if
(
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
disabled
nsGkAtoms
:
:
_true
eCaseMatters
)
)
return
NS_OK
;
WidgetGUIEvent
*
event
=
aEvent
-
>
WidgetEventPtr
(
)
-
>
AsGUIEvent
(
)
;
if
(
!
ShouldScrollForEvent
(
event
)
)
{
return
NS_OK
;
}
nsPoint
pt
;
if
(
!
GetEventPoint
(
event
pt
)
)
{
return
NS_OK
;
}
bool
isHorizontal
=
IsXULHorizontal
(
)
;
nscoord
pos
=
isHorizontal
?
pt
.
x
:
pt
.
y
;
nsCOMPtr
<
nsIContent
>
scrollbar
;
nscoord
newpos
=
pos
;
bool
scrollToClick
=
ShouldScrollToClickForEvent
(
event
)
;
if
(
scrollToClick
)
{
nsIFrame
*
thumbFrame
=
mFrames
.
FirstChild
(
)
;
if
(
!
thumbFrame
)
{
return
NS_OK
;
}
nsSize
thumbSize
=
thumbFrame
-
>
GetSize
(
)
;
nscoord
thumbLength
=
isHorizontal
?
thumbSize
.
width
:
thumbSize
.
height
;
newpos
-
=
(
thumbLength
/
2
)
;
nsIFrame
*
scrollbarBox
=
GetScrollbar
(
)
;
scrollbar
=
GetContentOfBox
(
scrollbarBox
)
;
}
DragThumb
(
true
)
;
if
(
scrollToClick
)
{
SetCurrentThumbPosition
(
scrollbar
newpos
false
false
)
;
}
nsIFrame
*
thumbFrame
=
mFrames
.
FirstChild
(
)
;
if
(
!
thumbFrame
)
{
return
NS_OK
;
}
#
ifdef
MOZ_WIDGET_GTK
RefPtr
<
dom
:
:
Element
>
thumb
=
thumbFrame
-
>
GetContent
(
)
-
>
AsElement
(
)
;
thumb
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
active
u
"
true
"
_ns
true
)
;
#
endif
if
(
isHorizontal
)
mThumbStart
=
thumbFrame
-
>
GetPosition
(
)
.
x
;
else
mThumbStart
=
thumbFrame
-
>
GetPosition
(
)
.
y
;
mDragStart
=
pos
-
mThumbStart
;
mScrollingWithAPZ
=
false
;
StartAPZDrag
(
event
)
;
#
ifdef
DEBUG_SLIDER
printf
(
"
Pressed
mDragStart
=
%
d
\
n
"
mDragStart
)
;
#
endif
if
(
!
mScrollingWithAPZ
)
{
SuppressDisplayport
(
)
;
}
return
NS_OK
;
}
nsresult
nsSliderFrame
:
:
StopDrag
(
)
{
AddListener
(
)
;
DragThumb
(
false
)
;
mScrollingWithAPZ
=
false
;
UnsuppressDisplayport
(
)
;
#
ifdef
MOZ_WIDGET_GTK
nsIFrame
*
thumbFrame
=
mFrames
.
FirstChild
(
)
;
if
(
thumbFrame
)
{
RefPtr
<
dom
:
:
Element
>
thumb
=
thumbFrame
-
>
GetContent
(
)
-
>
AsElement
(
)
;
thumb
-
>
UnsetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
active
true
)
;
}
#
endif
if
(
mChange
)
{
StopRepeat
(
)
;
mChange
=
0
;
}
return
NS_OK
;
}
void
nsSliderFrame
:
:
DragThumb
(
bool
aGrabMouseEvents
)
{
mDragFinished
=
!
aGrabMouseEvents
;
if
(
aGrabMouseEvents
)
{
PresShell
:
:
SetCapturingContent
(
GetContent
(
)
CaptureFlags
:
:
IgnoreAllowedState
)
;
}
else
{
PresShell
:
:
ReleaseCapturingContent
(
)
;
}
}
bool
nsSliderFrame
:
:
isDraggingThumb
(
)
const
{
return
PresShell
:
:
GetCapturingContent
(
)
=
=
GetContent
(
)
;
}
void
nsSliderFrame
:
:
AddListener
(
)
{
if
(
!
mMediator
)
{
mMediator
=
new
nsSliderMediator
(
this
)
;
}
nsIFrame
*
thumbFrame
=
mFrames
.
FirstChild
(
)
;
if
(
!
thumbFrame
)
{
return
;
}
thumbFrame
-
>
GetContent
(
)
-
>
AddSystemEventListener
(
u
"
mousedown
"
_ns
mMediator
false
false
)
;
thumbFrame
-
>
GetContent
(
)
-
>
AddSystemEventListener
(
u
"
touchstart
"
_ns
mMediator
false
false
)
;
}
void
nsSliderFrame
:
:
RemoveListener
(
)
{
NS_ASSERTION
(
mMediator
"
No
listener
was
ever
added
!
!
"
)
;
nsIFrame
*
thumbFrame
=
mFrames
.
FirstChild
(
)
;
if
(
!
thumbFrame
)
return
;
thumbFrame
-
>
GetContent
(
)
-
>
RemoveSystemEventListener
(
u
"
mousedown
"
_ns
mMediator
false
)
;
thumbFrame
-
>
GetContent
(
)
-
>
RemoveSystemEventListener
(
u
"
touchstart
"
_ns
mMediator
false
)
;
}
bool
nsSliderFrame
:
:
ShouldScrollForEvent
(
WidgetGUIEvent
*
aEvent
)
{
switch
(
aEvent
-
>
mMessage
)
{
case
eTouchStart
:
case
eTouchEnd
:
return
true
;
case
eMouseDown
:
case
eMouseUp
:
{
uint16_t
button
=
aEvent
-
>
AsMouseEvent
(
)
-
>
mButton
;
#
ifdef
MOZ_WIDGET_GTK
return
(
button
=
=
MouseButton
:
:
ePrimary
)
|
|
(
button
=
=
MouseButton
:
:
eSecondary
&
&
GetScrollToClick
(
)
)
|
|
(
button
=
=
MouseButton
:
:
eMiddle
&
&
gMiddlePref
&
&
!
GetScrollToClick
(
)
)
;
#
else
return
(
button
=
=
MouseButton
:
:
ePrimary
)
|
|
(
button
=
=
MouseButton
:
:
eMiddle
&
&
gMiddlePref
)
;
#
endif
}
default
:
return
false
;
}
}
bool
nsSliderFrame
:
:
ShouldScrollToClickForEvent
(
WidgetGUIEvent
*
aEvent
)
{
if
(
!
ShouldScrollForEvent
(
aEvent
)
)
{
return
false
;
}
if
(
aEvent
-
>
mMessage
!
=
eMouseDown
&
&
aEvent
-
>
mMessage
!
=
eTouchStart
)
{
return
false
;
}
#
if
defined
(
XP_MACOSX
)
|
|
defined
(
MOZ_WIDGET_GTK
)
if
(
IsEventOverThumb
(
aEvent
)
)
{
return
false
;
}
#
endif
if
(
aEvent
-
>
mMessage
=
=
eTouchStart
)
{
return
GetScrollToClick
(
)
;
}
WidgetMouseEvent
*
mouseEvent
=
aEvent
-
>
AsMouseEvent
(
)
;
if
(
mouseEvent
-
>
mButton
=
=
MouseButton
:
:
ePrimary
)
{
#
ifdef
XP_MACOSX
bool
invertPref
=
mouseEvent
-
>
IsAlt
(
)
;
#
else
bool
invertPref
=
mouseEvent
-
>
IsShift
(
)
;
#
endif
return
GetScrollToClick
(
)
!
=
invertPref
;
}
#
ifdef
MOZ_WIDGET_GTK
if
(
mouseEvent
-
>
mButton
=
=
MouseButton
:
:
eSecondary
)
{
return
!
GetScrollToClick
(
)
;
}
#
endif
return
true
;
}
bool
nsSliderFrame
:
:
IsEventOverThumb
(
WidgetGUIEvent
*
aEvent
)
{
nsIFrame
*
thumbFrame
=
mFrames
.
FirstChild
(
)
;
if
(
!
thumbFrame
)
{
return
false
;
}
nsPoint
eventPoint
;
if
(
!
GetEventPoint
(
aEvent
eventPoint
)
)
{
return
false
;
}
nsRect
thumbRect
=
thumbFrame
-
>
GetRect
(
)
;
#
if
defined
(
MOZ_WIDGET_GTK
)
return
eventPoint
.
x
>
=
thumbRect
.
x
&
&
eventPoint
.
x
<
thumbRect
.
XMost
(
)
&
&
eventPoint
.
y
>
=
thumbRect
.
y
&
&
eventPoint
.
y
<
thumbRect
.
YMost
(
)
;
#
else
bool
isHorizontal
=
IsXULHorizontal
(
)
;
nscoord
eventPos
=
isHorizontal
?
eventPoint
.
x
:
eventPoint
.
y
;
nscoord
thumbStart
=
isHorizontal
?
thumbRect
.
x
:
thumbRect
.
y
;
nscoord
thumbEnd
=
isHorizontal
?
thumbRect
.
XMost
(
)
:
thumbRect
.
YMost
(
)
;
return
eventPos
>
=
thumbStart
&
&
eventPos
<
thumbEnd
;
#
endif
}
NS_IMETHODIMP
nsSliderFrame
:
:
HandlePress
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
{
if
(
!
ShouldScrollForEvent
(
aEvent
)
|
|
ShouldScrollToClickForEvent
(
aEvent
)
)
{
return
NS_OK
;
}
if
(
IsEventOverThumb
(
aEvent
)
)
{
return
NS_OK
;
}
nsIFrame
*
thumbFrame
=
mFrames
.
FirstChild
(
)
;
if
(
!
thumbFrame
)
return
NS_OK
;
if
(
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
disabled
nsGkAtoms
:
:
_true
eCaseMatters
)
)
return
NS_OK
;
nsRect
thumbRect
=
thumbFrame
-
>
GetRect
(
)
;
nscoord
change
=
1
;
nsPoint
eventPoint
;
if
(
!
GetEventPoint
(
aEvent
eventPoint
)
)
{
return
NS_OK
;
}
if
(
IsXULHorizontal
(
)
?
eventPoint
.
x
<
thumbRect
.
x
:
eventPoint
.
y
<
thumbRect
.
y
)
change
=
-
1
;
mChange
=
change
;
DragThumb
(
true
)
;
#
ifdef
MOZ_WIDGET_GTK
nsRect
clientRect
;
GetXULClientRect
(
clientRect
)
;
if
(
change
>
0
)
{
mDestinationPoint
=
nsPoint
(
clientRect
.
width
clientRect
.
height
)
;
}
else
{
mDestinationPoint
=
nsPoint
(
0
0
)
;
}
#
else
mDestinationPoint
=
eventPoint
;
#
endif
StartRepeat
(
)
;
PageScroll
(
change
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSliderFrame
:
:
HandleRelease
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
{
StopRepeat
(
)
;
nsIFrame
*
scrollbar
=
GetScrollbar
(
)
;
nsScrollbarFrame
*
sb
=
do_QueryFrame
(
scrollbar
)
;
if
(
sb
)
{
nsIScrollbarMediator
*
m
=
sb
-
>
GetScrollbarMediator
(
)
;
if
(
m
)
{
m
-
>
ScrollbarReleased
(
sb
)
;
}
}
return
NS_OK
;
}
void
nsSliderFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
{
if
(
mMediator
)
{
mMediator
-
>
SetSlider
(
nullptr
)
;
mMediator
=
nullptr
;
}
StopRepeat
(
)
;
nsBoxFrame
:
:
DestroyFrom
(
aDestructRoot
aPostDestroyData
)
;
}
nsSize
nsSliderFrame
:
:
GetXULPrefSize
(
nsBoxLayoutState
&
aState
)
{
EnsureOrient
(
)
;
return
nsBoxFrame
:
:
GetXULPrefSize
(
aState
)
;
}
nsSize
nsSliderFrame
:
:
GetXULMinSize
(
nsBoxLayoutState
&
aState
)
{
EnsureOrient
(
)
;
return
nsIFrame
:
:
GetUncachedXULMinSize
(
aState
)
;
}
nsSize
nsSliderFrame
:
:
GetXULMaxSize
(
nsBoxLayoutState
&
aState
)
{
EnsureOrient
(
)
;
return
nsBoxFrame
:
:
GetXULMaxSize
(
aState
)
;
}
void
nsSliderFrame
:
:
EnsureOrient
(
)
{
nsIFrame
*
scrollbarBox
=
GetScrollbar
(
)
;
bool
isHorizontal
=
scrollbarBox
-
>
HasAnyStateBits
(
NS_STATE_IS_HORIZONTAL
)
;
if
(
isHorizontal
)
AddStateBits
(
NS_STATE_IS_HORIZONTAL
)
;
else
RemoveStateBits
(
NS_STATE_IS_HORIZONTAL
)
;
}
void
nsSliderFrame
:
:
Notify
(
void
)
{
bool
stop
=
false
;
nsIFrame
*
thumbFrame
=
mFrames
.
FirstChild
(
)
;
if
(
!
thumbFrame
)
{
StopRepeat
(
)
;
return
;
}
nsRect
thumbRect
=
thumbFrame
-
>
GetRect
(
)
;
bool
isHorizontal
=
IsXULHorizontal
(
)
;
if
(
isHorizontal
)
{
if
(
mChange
<
0
)
{
if
(
thumbRect
.
x
<
mDestinationPoint
.
x
)
stop
=
true
;
}
else
{
if
(
thumbRect
.
x
+
thumbRect
.
width
>
mDestinationPoint
.
x
)
stop
=
true
;
}
}
else
{
if
(
mChange
<
0
)
{
if
(
thumbRect
.
y
<
mDestinationPoint
.
y
)
stop
=
true
;
}
else
{
if
(
thumbRect
.
y
+
thumbRect
.
height
>
mDestinationPoint
.
y
)
stop
=
true
;
}
}
if
(
stop
)
{
StopRepeat
(
)
;
}
else
{
PageScroll
(
mChange
)
;
}
}
void
nsSliderFrame
:
:
PageScroll
(
nscoord
aChange
)
{
if
(
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
dir
nsGkAtoms
:
:
reverse
eCaseMatters
)
)
{
aChange
=
-
aChange
;
}
nsIFrame
*
scrollbar
=
GetScrollbar
(
)
;
nsScrollbarFrame
*
sb
=
do_QueryFrame
(
scrollbar
)
;
if
(
sb
)
{
nsIScrollbarMediator
*
m
=
sb
-
>
GetScrollbarMediator
(
)
;
sb
-
>
SetIncrementToPage
(
aChange
)
;
if
(
m
)
{
m
-
>
ScrollByPage
(
sb
aChange
nsIScrollbarMediator
:
:
ENABLE_SNAP
)
;
return
;
}
}
PageUpDown
(
aChange
)
;
}
float
nsSliderFrame
:
:
GetThumbRatio
(
)
const
{
return
mRatio
/
mozilla
:
:
AppUnitsPerCSSPixel
(
)
;
}
void
nsSliderFrame
:
:
AsyncScrollbarDragInitiated
(
uint64_t
aDragBlockId
)
{
mAPZDragInitiated
=
Some
(
aDragBlockId
)
;
}
void
nsSliderFrame
:
:
AsyncScrollbarDragRejected
(
)
{
mScrollingWithAPZ
=
false
;
if
(
isDraggingThumb
(
)
)
{
SuppressDisplayport
(
)
;
}
}
void
nsSliderFrame
:
:
SuppressDisplayport
(
)
{
if
(
!
mSuppressionActive
)
{
PresShell
(
)
-
>
SuppressDisplayport
(
true
)
;
mSuppressionActive
=
true
;
}
}
void
nsSliderFrame
:
:
UnsuppressDisplayport
(
)
{
if
(
mSuppressionActive
)
{
PresShell
(
)
-
>
SuppressDisplayport
(
false
)
;
mSuppressionActive
=
false
;
}
}
bool
nsSliderFrame
:
:
OnlySystemGroupDispatch
(
EventMessage
aMessage
)
const
{
return
(
aMessage
=
=
eMouseMove
|
|
aMessage
=
=
ePointerMove
)
&
&
isDraggingThumb
(
)
&
&
GetContent
(
)
-
>
IsInNativeAnonymousSubtree
(
)
;
}
NS_IMPL_ISUPPORTS
(
nsSliderMediator
nsIDOMEventListener
)
