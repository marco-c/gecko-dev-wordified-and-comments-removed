#
include
"
nsSliderFrame
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
mozilla
/
ComputedStyle
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsHTMLParts
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsCSSRendering
.
h
"
#
include
"
nsScrollbarButtonFrame
.
h
"
#
include
"
nsISliderListener
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsIScrollbarMediator
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsScrollbarFrame
.
h
"
#
include
"
nsRepeatService
.
h
"
#
include
"
nsBoxLayoutState
.
h
"
#
include
"
nsSprocketLayout
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsRefreshDriver
.
h
"
#
include
"
nsSVGIntegrationUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
layers
/
APZCCallbackHelper
.
h
"
#
include
"
mozilla
/
layers
/
AsyncDragMetrics
.
h
"
#
include
"
mozilla
/
layers
/
InputAPZContext
.
h
"
#
include
<
algorithm
>
using
namespace
mozilla
;
using
mozilla
:
:
layers
:
:
APZCCallbackHelper
;
using
mozilla
:
:
layers
:
:
AsyncDragMetrics
;
using
mozilla
:
:
layers
:
:
InputAPZContext
;
using
mozilla
:
:
layers
:
:
ScrollDirection
;
using
mozilla
:
:
layers
:
:
ScrollbarData
;
bool
nsSliderFrame
:
:
gMiddlePref
=
false
;
int32_t
nsSliderFrame
:
:
gSnapMultiplier
;
#
undef
DEBUG_SLIDER
static
already_AddRefed
<
nsIContent
>
GetContentOfBox
(
nsIFrame
*
aBox
)
{
nsCOMPtr
<
nsIContent
>
content
=
aBox
-
>
GetContent
(
)
;
return
content
.
forget
(
)
;
}
nsIFrame
*
NS_NewSliderFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsSliderFrame
(
aStyle
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsSliderFrame
)
NS_QUERYFRAME_HEAD
(
nsSliderFrame
)
NS_QUERYFRAME_ENTRY
(
nsSliderFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsBoxFrame
)
nsSliderFrame
:
:
nsSliderFrame
(
ComputedStyle
*
aStyle
)
:
nsBoxFrame
(
aStyle
kClassID
)
mRatio
(
0
.
0f
)
mDragStart
(
0
)
mThumbStart
(
0
)
mCurPos
(
0
)
mChange
(
0
)
mDragFinished
(
true
)
mUserChanged
(
false
)
mScrollingWithAPZ
(
false
)
mSuppressionActive
(
false
)
{
}
nsSliderFrame
:
:
~
nsSliderFrame
(
)
{
if
(
mSuppressionActive
)
{
APZCCallbackHelper
:
:
SuppressDisplayport
(
false
PresContext
(
)
?
PresShell
(
)
:
nullptr
)
;
}
}
void
nsSliderFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
nsBoxFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
static
bool
gotPrefs
=
false
;
if
(
!
gotPrefs
)
{
gotPrefs
=
true
;
gMiddlePref
=
Preferences
:
:
GetBool
(
"
middlemouse
.
scrollbarPosition
"
)
;
gSnapMultiplier
=
Preferences
:
:
GetInt
(
"
slider
.
snapMultiplier
"
)
;
}
mCurPos
=
GetCurrentPosition
(
aContent
)
;
}
void
nsSliderFrame
:
:
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
{
nsBoxFrame
:
:
RemoveFrame
(
aListID
aOldFrame
)
;
if
(
mFrames
.
IsEmpty
(
)
)
RemoveListener
(
)
;
}
void
nsSliderFrame
:
:
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
aFrameList
)
{
bool
wasEmpty
=
mFrames
.
IsEmpty
(
)
;
nsBoxFrame
:
:
InsertFrames
(
aListID
aPrevFrame
aFrameList
)
;
if
(
wasEmpty
)
AddListener
(
)
;
}
void
nsSliderFrame
:
:
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
{
bool
wasEmpty
=
mFrames
.
IsEmpty
(
)
;
nsBoxFrame
:
:
AppendFrames
(
aListID
aFrameList
)
;
if
(
wasEmpty
)
AddListener
(
)
;
}
int32_t
nsSliderFrame
:
:
GetCurrentPosition
(
nsIContent
*
content
)
{
return
GetIntegerAttribute
(
content
nsGkAtoms
:
:
curpos
0
)
;
}
int32_t
nsSliderFrame
:
:
GetMinPosition
(
nsIContent
*
content
)
{
return
GetIntegerAttribute
(
content
nsGkAtoms
:
:
minpos
0
)
;
}
int32_t
nsSliderFrame
:
:
GetMaxPosition
(
nsIContent
*
content
)
{
return
GetIntegerAttribute
(
content
nsGkAtoms
:
:
maxpos
100
)
;
}
int32_t
nsSliderFrame
:
:
GetIncrement
(
nsIContent
*
content
)
{
return
GetIntegerAttribute
(
content
nsGkAtoms
:
:
increment
1
)
;
}
int32_t
nsSliderFrame
:
:
GetPageIncrement
(
nsIContent
*
content
)
{
return
GetIntegerAttribute
(
content
nsGkAtoms
:
:
pageincrement
10
)
;
}
int32_t
nsSliderFrame
:
:
GetIntegerAttribute
(
nsIContent
*
content
nsAtom
*
atom
int32_t
defaultValue
)
{
nsAutoString
value
;
if
(
content
-
>
IsElement
(
)
)
{
content
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
atom
value
)
;
}
if
(
!
value
.
IsEmpty
(
)
)
{
nsresult
error
;
defaultValue
=
value
.
ToInteger
(
&
error
)
;
}
return
defaultValue
;
}
class
nsValueChangedRunnable
:
public
Runnable
{
public
:
nsValueChangedRunnable
(
nsISliderListener
*
aListener
nsAtom
*
aWhich
int32_t
aValue
bool
aUserChanged
)
:
mozilla
:
:
Runnable
(
"
nsValueChangedRunnable
"
)
mListener
(
aListener
)
mWhich
(
aWhich
)
mValue
(
aValue
)
mUserChanged
(
aUserChanged
)
{
}
NS_IMETHOD
Run
(
)
override
{
return
mListener
-
>
ValueChanged
(
nsDependentAtomString
(
mWhich
)
mValue
mUserChanged
)
;
}
nsCOMPtr
<
nsISliderListener
>
mListener
;
RefPtr
<
nsAtom
>
mWhich
;
int32_t
mValue
;
bool
mUserChanged
;
}
;
class
nsDragStateChangedRunnable
:
public
Runnable
{
public
:
nsDragStateChangedRunnable
(
nsISliderListener
*
aListener
bool
aDragBeginning
)
:
mozilla
:
:
Runnable
(
"
nsDragStateChangedRunnable
"
)
mListener
(
aListener
)
mDragBeginning
(
aDragBeginning
)
{
}
NS_IMETHOD
Run
(
)
override
{
return
mListener
-
>
DragStateChanged
(
mDragBeginning
)
;
}
nsCOMPtr
<
nsISliderListener
>
mListener
;
bool
mDragBeginning
;
}
;
nsresult
nsSliderFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
nsresult
rv
=
nsBoxFrame
:
:
AttributeChanged
(
aNameSpaceID
aAttribute
aModType
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
curpos
)
{
CurrentPositionChanged
(
)
;
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
minpos
|
|
aAttribute
=
=
nsGkAtoms
:
:
maxpos
)
{
nsIFrame
*
scrollbarBox
=
GetScrollbar
(
)
;
nsCOMPtr
<
nsIContent
>
scrollbar
=
GetContentOfBox
(
scrollbarBox
)
;
int32_t
current
=
GetCurrentPosition
(
scrollbar
)
;
int32_t
min
=
GetMinPosition
(
scrollbar
)
;
int32_t
max
=
GetMaxPosition
(
scrollbar
)
;
nsIFrame
*
parent
=
GetParent
(
)
;
if
(
parent
)
{
nsCOMPtr
<
nsISliderListener
>
sliderListener
=
do_QueryInterface
(
parent
-
>
GetContent
(
)
)
;
if
(
sliderListener
)
{
nsContentUtils
:
:
AddScriptRunner
(
new
nsValueChangedRunnable
(
sliderListener
aAttribute
aAttribute
=
=
nsGkAtoms
:
:
minpos
?
min
:
max
false
)
)
;
}
}
if
(
current
<
min
|
|
current
>
max
)
{
int32_t
direction
=
0
;
if
(
current
<
min
|
|
max
<
min
)
{
current
=
min
;
direction
=
-
1
;
}
else
if
(
current
>
max
)
{
current
=
max
;
direction
=
1
;
}
nsScrollbarFrame
*
scrollbarFrame
=
do_QueryFrame
(
scrollbarBox
)
;
if
(
scrollbarFrame
)
{
nsIScrollbarMediator
*
mediator
=
scrollbarFrame
-
>
GetScrollbarMediator
(
)
;
scrollbarFrame
-
>
SetIncrementToWhole
(
direction
)
;
if
(
mediator
)
{
mediator
-
>
ScrollByWhole
(
scrollbarFrame
direction
nsIScrollbarMediator
:
:
ENABLE_SNAP
)
;
}
}
nsContentUtils
:
:
AddScriptRunner
(
new
nsSetAttrRunnable
(
scrollbar
-
>
AsElement
(
)
nsGkAtoms
:
:
curpos
current
)
)
;
}
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
minpos
|
|
aAttribute
=
=
nsGkAtoms
:
:
maxpos
|
|
aAttribute
=
=
nsGkAtoms
:
:
pageincrement
|
|
aAttribute
=
=
nsGkAtoms
:
:
increment
)
{
PresShell
(
)
-
>
FrameNeedsReflow
(
this
nsIPresShell
:
:
eStyleChange
NS_FRAME_IS_DIRTY
)
;
}
return
rv
;
}
void
nsSliderFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
if
(
aBuilder
-
>
IsForEventDelivery
(
)
&
&
isDraggingThumb
(
)
)
{
aLists
.
Outlines
(
)
-
>
AppendToTop
(
MakeDisplayItem
<
nsDisplayEventReceiver
>
(
aBuilder
this
)
)
;
return
;
}
nsBoxFrame
:
:
BuildDisplayList
(
aBuilder
aLists
)
;
}
static
bool
UsesCustomScrollbarMediator
(
nsIFrame
*
scrollbarBox
)
{
if
(
nsScrollbarFrame
*
scrollbarFrame
=
do_QueryFrame
(
scrollbarBox
)
)
{
if
(
nsIScrollbarMediator
*
mediator
=
scrollbarFrame
-
>
GetScrollbarMediator
(
)
)
{
nsIScrollableFrame
*
scrollFrame
=
do_QueryFrame
(
mediator
)
;
if
(
!
scrollFrame
)
{
return
true
;
}
}
}
return
false
;
}
void
nsSliderFrame
:
:
BuildDisplayListForChildren
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
nsIFrame
*
thumb
=
nsBox
:
:
GetChildXULBox
(
this
)
;
if
(
thumb
)
{
nsRect
thumbRect
(
thumb
-
>
GetRect
(
)
)
;
nsMargin
m
;
thumb
-
>
GetXULMargin
(
m
)
;
thumbRect
.
Inflate
(
m
)
;
nsRect
sliderTrack
;
GetXULClientRect
(
sliderTrack
)
;
if
(
sliderTrack
.
width
<
thumbRect
.
width
|
|
sliderTrack
.
height
<
thumbRect
.
height
)
return
;
nsDisplayOwnLayerFlags
flags
=
aBuilder
-
>
GetCurrentScrollbarFlags
(
)
;
mozilla
:
:
layers
:
:
FrameMetrics
:
:
ViewID
scrollTargetId
=
aBuilder
-
>
GetCurrentScrollbarTarget
(
)
;
bool
thumbGetsLayer
=
(
scrollTargetId
!
=
layers
:
:
FrameMetrics
:
:
NULL_SCROLL_ID
)
;
if
(
thumbGetsLayer
)
{
MOZ_ASSERT
(
(
flags
&
nsDisplayOwnLayerFlags
:
:
eHorizontalScrollbar
)
|
|
(
flags
&
nsDisplayOwnLayerFlags
:
:
eVerticalScrollbar
)
)
;
bool
isHorizontal
=
bool
(
flags
&
nsDisplayOwnLayerFlags
:
:
eHorizontalScrollbar
)
;
ScrollDirection
scrollDirection
=
isHorizontal
?
ScrollDirection
:
:
eHorizontal
:
ScrollDirection
:
:
eVertical
;
const
float
appUnitsPerCss
=
float
(
AppUnitsPerCSSPixel
(
)
)
;
CSSCoord
thumbLength
=
NSAppUnitsToFloatPixels
(
isHorizontal
?
thumbRect
.
width
:
thumbRect
.
height
appUnitsPerCss
)
;
nsIFrame
*
scrollbarBox
=
GetScrollbar
(
)
;
bool
isAsyncDraggable
=
!
UsesCustomScrollbarMediator
(
scrollbarBox
)
;
nsPoint
scrollPortOrigin
;
if
(
nsIScrollableFrame
*
scrollFrame
=
do_QueryFrame
(
scrollbarBox
-
>
GetParent
(
)
)
)
{
scrollPortOrigin
=
scrollFrame
-
>
GetScrollPortRect
(
)
.
TopLeft
(
)
;
}
else
{
isAsyncDraggable
=
false
;
}
sliderTrack
=
sliderTrack
+
GetRect
(
)
.
TopLeft
(
)
+
scrollbarBox
-
>
GetPosition
(
)
-
scrollPortOrigin
;
CSSCoord
sliderTrackStart
=
NSAppUnitsToFloatPixels
(
isHorizontal
?
sliderTrack
.
x
:
sliderTrack
.
y
appUnitsPerCss
)
;
CSSCoord
sliderTrackLength
=
NSAppUnitsToFloatPixels
(
isHorizontal
?
sliderTrack
.
width
:
sliderTrack
.
height
appUnitsPerCss
)
;
CSSCoord
thumbStart
=
NSAppUnitsToFloatPixels
(
isHorizontal
?
thumbRect
.
x
:
thumbRect
.
y
appUnitsPerCss
)
;
nsRect
overflow
=
thumb
-
>
GetVisualOverflowRectRelativeToParent
(
)
;
nsSize
refSize
=
aBuilder
-
>
RootReferenceFrame
(
)
-
>
GetSize
(
)
;
gfxSize
scale
=
nsLayoutUtils
:
:
GetTransformToAncestorScale
(
thumb
)
;
if
(
scale
.
width
!
=
0
&
&
scale
.
height
!
=
0
)
{
refSize
.
width
/
=
scale
.
width
;
refSize
.
height
/
=
scale
.
height
;
}
nsRect
dirty
=
aBuilder
-
>
GetVisibleRect
(
)
.
Intersect
(
thumbRect
)
;
dirty
=
nsLayoutUtils
:
:
ComputePartialPrerenderArea
(
aBuilder
-
>
GetVisibleRect
(
)
overflow
refSize
)
;
nsDisplayListBuilder
:
:
AutoBuildingDisplayList
buildingDisplayList
(
aBuilder
this
dirty
dirty
false
)
;
DisplayListClipState
:
:
AutoSaveRestore
thumbClipState
(
aBuilder
)
;
thumbClipState
.
ClipContainingBlockDescendants
(
GetRectRelativeToSelf
(
)
+
aBuilder
-
>
ToReferenceFrame
(
this
)
)
;
DisplayListClipState
:
:
AutoSaveRestore
thumbContentsClipState
(
aBuilder
)
;
thumbContentsClipState
.
Clear
(
)
;
nsDisplayListBuilder
:
:
AutoContainerASRTracker
contASRTracker
(
aBuilder
)
;
nsDisplayListCollection
tempLists
(
aBuilder
)
;
nsBoxFrame
:
:
BuildDisplayListForChildren
(
aBuilder
tempLists
)
;
nsDisplayList
masterList
;
masterList
.
AppendToTop
(
tempLists
.
BorderBackground
(
)
)
;
masterList
.
AppendToTop
(
tempLists
.
BlockBorderBackgrounds
(
)
)
;
masterList
.
AppendToTop
(
tempLists
.
Floats
(
)
)
;
masterList
.
AppendToTop
(
tempLists
.
Content
(
)
)
;
masterList
.
AppendToTop
(
tempLists
.
PositionedDescendants
(
)
)
;
masterList
.
AppendToTop
(
tempLists
.
Outlines
(
)
)
;
thumbContentsClipState
.
Restore
(
)
;
const
ActiveScrolledRoot
*
ownLayerASR
=
contASRTracker
.
GetContainerASR
(
)
;
aLists
.
Content
(
)
-
>
AppendToTop
(
MakeDisplayItem
<
nsDisplayOwnLayer
>
(
aBuilder
this
&
masterList
ownLayerASR
flags
ScrollbarData
{
scrollDirection
layers
:
:
ScrollbarLayerType
:
:
Thumb
GetThumbRatio
(
)
thumbStart
thumbLength
isAsyncDraggable
sliderTrackStart
sliderTrackLength
scrollTargetId
}
)
)
;
return
;
}
}
nsBoxFrame
:
:
BuildDisplayListForChildren
(
aBuilder
aLists
)
;
}
NS_IMETHODIMP
nsSliderFrame
:
:
DoXULLayout
(
nsBoxLayoutState
&
aState
)
{
nsIFrame
*
thumbBox
=
nsBox
:
:
GetChildXULBox
(
this
)
;
if
(
!
thumbBox
)
{
SyncLayout
(
aState
)
;
return
NS_OK
;
}
EnsureOrient
(
)
;
#
ifdef
DEBUG_LAYOUT
if
(
mState
&
NS_STATE_DEBUG_WAS_SET
)
{
if
(
mState
&
NS_STATE_SET_TO_DEBUG
)
SetXULDebug
(
aState
true
)
;
else
SetXULDebug
(
aState
false
)
;
}
#
endif
nsRect
clientRect
;
GetXULClientRect
(
clientRect
)
;
nsIFrame
*
scrollbarBox
=
GetScrollbar
(
)
;
nsCOMPtr
<
nsIContent
>
scrollbar
=
GetContentOfBox
(
scrollbarBox
)
;
nsSize
thumbSize
=
thumbBox
-
>
GetXULPrefSize
(
aState
)
;
if
(
IsXULHorizontal
(
)
)
thumbSize
.
height
=
clientRect
.
height
;
else
thumbSize
.
width
=
clientRect
.
width
;
int32_t
curPos
=
GetCurrentPosition
(
scrollbar
)
;
int32_t
minPos
=
GetMinPosition
(
scrollbar
)
;
int32_t
maxPos
=
GetMaxPosition
(
scrollbar
)
;
int32_t
pageIncrement
=
GetPageIncrement
(
scrollbar
)
;
maxPos
=
std
:
:
max
(
minPos
maxPos
)
;
curPos
=
clamped
(
curPos
minPos
maxPos
)
;
nscoord
&
availableLength
=
IsXULHorizontal
(
)
?
clientRect
.
width
:
clientRect
.
height
;
nscoord
&
thumbLength
=
IsXULHorizontal
(
)
?
thumbSize
.
width
:
thumbSize
.
height
;
if
(
(
pageIncrement
+
maxPos
-
minPos
)
>
0
&
&
thumbBox
-
>
GetXULFlex
(
)
>
0
)
{
float
ratio
=
float
(
pageIncrement
)
/
float
(
maxPos
-
minPos
+
pageIncrement
)
;
thumbLength
=
std
:
:
max
(
thumbLength
NSToCoordRound
(
availableLength
*
ratio
)
)
;
}
nsPresContext
*
presContext
=
PresContext
(
)
;
thumbLength
=
presContext
-
>
DevPixelsToAppUnits
(
presContext
-
>
AppUnitsToDevPixels
(
thumbLength
)
)
;
mRatio
=
(
minPos
!
=
maxPos
)
?
float
(
availableLength
-
thumbLength
)
/
float
(
maxPos
-
minPos
)
:
1
;
bool
reverse
=
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
dir
nsGkAtoms
:
:
reverse
eCaseMatters
)
;
nscoord
pos
=
reverse
?
(
maxPos
-
curPos
)
:
(
curPos
-
minPos
)
;
nsRect
thumbRect
(
clientRect
.
x
clientRect
.
y
thumbSize
.
width
thumbSize
.
height
)
;
int32_t
&
thumbPos
=
(
IsXULHorizontal
(
)
?
thumbRect
.
x
:
thumbRect
.
y
)
;
thumbPos
+
=
NSToCoordRound
(
pos
*
mRatio
)
;
nsRect
oldThumbRect
(
thumbBox
-
>
GetRect
(
)
)
;
LayoutChildAt
(
aState
thumbBox
thumbRect
)
;
SyncLayout
(
aState
)
;
if
(
!
oldThumbRect
.
IsEqualInterior
(
thumbRect
)
)
XULRedraw
(
aState
)
;
return
NS_OK
;
}
nsresult
nsSliderFrame
:
:
HandleEvent
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
{
NS_ENSURE_ARG_POINTER
(
aEventStatus
)
;
if
(
!
mContent
-
>
IsInNativeAnonymousSubtree
(
)
&
&
nsEventStatus_eConsumeNoDefault
=
=
*
aEventStatus
)
{
return
NS_OK
;
}
if
(
!
mDragFinished
&
&
!
isDraggingThumb
(
)
)
{
StopDrag
(
)
;
return
NS_OK
;
}
nsIFrame
*
scrollbarBox
=
GetScrollbar
(
)
;
nsCOMPtr
<
nsIContent
>
scrollbar
;
scrollbar
=
GetContentOfBox
(
scrollbarBox
)
;
bool
isHorizontal
=
IsXULHorizontal
(
)
;
if
(
isDraggingThumb
(
)
)
{
switch
(
aEvent
-
>
mMessage
)
{
case
eTouchMove
:
case
eMouseMove
:
{
if
(
mScrollingWithAPZ
)
{
break
;
}
nsPoint
eventPoint
;
if
(
!
GetEventPoint
(
aEvent
eventPoint
)
)
{
break
;
}
if
(
mChange
)
{
#
ifndef
MOZ_WIDGET_GTK
mDestinationPoint
=
eventPoint
;
StopRepeat
(
)
;
StartRepeat
(
)
;
#
endif
break
;
}
nscoord
pos
=
isHorizontal
?
eventPoint
.
x
:
eventPoint
.
y
;
nsIFrame
*
thumbFrame
=
mFrames
.
FirstChild
(
)
;
if
(
!
thumbFrame
)
{
return
NS_OK
;
}
pos
-
=
mDragStart
;
bool
isMouseOutsideThumb
=
false
;
if
(
gSnapMultiplier
)
{
nsSize
thumbSize
=
thumbFrame
-
>
GetSize
(
)
;
if
(
isHorizontal
)
{
if
(
eventPoint
.
y
<
-
gSnapMultiplier
*
thumbSize
.
height
|
|
eventPoint
.
y
>
thumbSize
.
height
+
gSnapMultiplier
*
thumbSize
.
height
)
isMouseOutsideThumb
=
true
;
}
else
{
if
(
eventPoint
.
x
<
-
gSnapMultiplier
*
thumbSize
.
width
|
|
eventPoint
.
x
>
thumbSize
.
width
+
gSnapMultiplier
*
thumbSize
.
width
)
isMouseOutsideThumb
=
true
;
}
}
if
(
aEvent
-
>
mClass
=
=
eTouchEventClass
)
{
*
aEventStatus
=
nsEventStatus_eConsumeNoDefault
;
}
if
(
isMouseOutsideThumb
)
{
SetCurrentThumbPosition
(
scrollbar
mThumbStart
false
false
)
;
return
NS_OK
;
}
SetCurrentThumbPosition
(
scrollbar
pos
false
true
)
;
}
break
;
case
eTouchEnd
:
case
eMouseUp
:
if
(
ShouldScrollForEvent
(
aEvent
)
)
{
StopDrag
(
)
;
return
nsFrame
:
:
HandleEvent
(
aPresContext
aEvent
aEventStatus
)
;
}
break
;
default
:
break
;
}
return
NS_OK
;
}
else
if
(
ShouldScrollToClickForEvent
(
aEvent
)
)
{
nsPoint
eventPoint
;
if
(
!
GetEventPoint
(
aEvent
eventPoint
)
)
{
return
NS_OK
;
}
nscoord
pos
=
isHorizontal
?
eventPoint
.
x
:
eventPoint
.
y
;
nsIFrame
*
thumbFrame
=
mFrames
.
FirstChild
(
)
;
if
(
!
thumbFrame
)
{
return
NS_OK
;
}
nsSize
thumbSize
=
thumbFrame
-
>
GetSize
(
)
;
nscoord
thumbLength
=
isHorizontal
?
thumbSize
.
width
:
thumbSize
.
height
;
AutoWeakFrame
weakFrame
(
this
)
;
SetCurrentThumbPosition
(
scrollbar
pos
-
thumbLength
/
2
false
false
)
;
NS_ENSURE_TRUE
(
weakFrame
.
IsAlive
(
)
NS_OK
)
;
DragThumb
(
true
)
;
#
ifdef
MOZ_WIDGET_GTK
RefPtr
<
Element
>
thumb
=
thumbFrame
-
>
GetContent
(
)
-
>
AsElement
(
)
;
thumb
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
active
NS_LITERAL_STRING
(
"
true
"
)
true
)
;
#
endif
if
(
aEvent
-
>
mClass
=
=
eTouchEventClass
)
{
*
aEventStatus
=
nsEventStatus_eConsumeNoDefault
;
}
if
(
isHorizontal
)
mThumbStart
=
thumbFrame
-
>
GetPosition
(
)
.
x
;
else
mThumbStart
=
thumbFrame
-
>
GetPosition
(
)
.
y
;
mDragStart
=
pos
-
mThumbStart
;
}
#
ifdef
MOZ_WIDGET_GTK
else
if
(
ShouldScrollForEvent
(
aEvent
)
&
&
aEvent
-
>
mClass
=
=
eMouseEventClass
&
&
aEvent
-
>
AsMouseEvent
(
)
-
>
button
=
=
WidgetMouseEvent
:
:
eRightButton
)
{
if
(
aEvent
-
>
mMessage
=
=
eMouseDown
)
{
HandlePress
(
aPresContext
aEvent
aEventStatus
)
;
}
else
if
(
aEvent
-
>
mMessage
=
=
eMouseUp
)
{
HandleRelease
(
aPresContext
aEvent
aEventStatus
)
;
}
return
NS_OK
;
}
#
endif
if
(
aEvent
-
>
mMessage
=
=
eMouseOut
&
&
mChange
)
HandleRelease
(
aPresContext
aEvent
aEventStatus
)
;
return
nsFrame
:
:
HandleEvent
(
aPresContext
aEvent
aEventStatus
)
;
}
bool
nsSliderFrame
:
:
GetScrollToClick
(
)
{
if
(
GetScrollbar
(
)
!
=
this
)
{
return
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
eIntID_ScrollToClick
false
)
;
}
if
(
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
movetoclick
nsGkAtoms
:
:
_true
eCaseMatters
)
)
{
return
true
;
}
if
(
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
movetoclick
nsGkAtoms
:
:
_false
eCaseMatters
)
)
{
return
false
;
}
#
ifdef
XP_MACOSX
return
true
;
#
else
return
false
;
#
endif
}
nsIFrame
*
nsSliderFrame
:
:
GetScrollbar
(
)
{
nsIFrame
*
scrollbar
;
nsScrollbarButtonFrame
:
:
GetParentWithTag
(
nsGkAtoms
:
:
scrollbar
this
scrollbar
)
;
if
(
scrollbar
=
=
nullptr
)
return
this
;
return
scrollbar
-
>
IsXULBoxFrame
(
)
?
scrollbar
:
this
;
}
void
nsSliderFrame
:
:
PageUpDown
(
nscoord
change
)
{
nsIFrame
*
scrollbarBox
=
GetScrollbar
(
)
;
nsCOMPtr
<
nsIContent
>
scrollbar
;
scrollbar
=
GetContentOfBox
(
scrollbarBox
)
;
nscoord
pageIncrement
=
GetPageIncrement
(
scrollbar
)
;
int32_t
curpos
=
GetCurrentPosition
(
scrollbar
)
;
int32_t
minpos
=
GetMinPosition
(
scrollbar
)
;
int32_t
maxpos
=
GetMaxPosition
(
scrollbar
)
;
int32_t
newpos
=
curpos
+
change
*
pageIncrement
;
if
(
newpos
<
minpos
|
|
maxpos
<
minpos
)
newpos
=
minpos
;
else
if
(
newpos
>
maxpos
)
newpos
=
maxpos
;
SetCurrentPositionInternal
(
scrollbar
newpos
true
)
;
}
void
nsSliderFrame
:
:
CurrentPositionChanged
(
)
{
nsIFrame
*
scrollbarBox
=
GetScrollbar
(
)
;
nsCOMPtr
<
nsIContent
>
scrollbar
=
GetContentOfBox
(
scrollbarBox
)
;
int32_t
curPos
=
GetCurrentPosition
(
scrollbar
)
;
if
(
mCurPos
=
=
curPos
)
return
;
int32_t
minPos
=
GetMinPosition
(
scrollbar
)
;
int32_t
maxPos
=
GetMaxPosition
(
scrollbar
)
;
maxPos
=
std
:
:
max
(
minPos
maxPos
)
;
curPos
=
clamped
(
curPos
minPos
maxPos
)
;
nsIFrame
*
thumbFrame
=
mFrames
.
FirstChild
(
)
;
if
(
!
thumbFrame
)
return
;
nsRect
thumbRect
=
thumbFrame
-
>
GetRect
(
)
;
nsRect
clientRect
;
GetXULClientRect
(
clientRect
)
;
nsRect
newThumbRect
(
thumbRect
)
;
bool
reverse
=
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
dir
nsGkAtoms
:
:
reverse
eCaseMatters
)
;
nscoord
pos
=
reverse
?
(
maxPos
-
curPos
)
:
(
curPos
-
minPos
)
;
if
(
IsXULHorizontal
(
)
)
newThumbRect
.
x
=
clientRect
.
x
+
NSToCoordRound
(
pos
*
mRatio
)
;
else
newThumbRect
.
y
=
clientRect
.
y
+
NSToCoordRound
(
pos
*
mRatio
)
;
nscoord
appUnitsPerPixel
=
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
nsPoint
snappedThumbLocation
=
ToAppUnits
(
newThumbRect
.
TopLeft
(
)
.
ToNearestPixels
(
appUnitsPerPixel
)
appUnitsPerPixel
)
;
if
(
IsXULHorizontal
(
)
)
{
newThumbRect
.
x
=
snappedThumbLocation
.
x
;
}
else
{
newThumbRect
.
y
=
snappedThumbLocation
.
y
;
}
thumbFrame
-
>
SetRect
(
newThumbRect
)
;
nsScrollbarFrame
*
scrollbarFrame
=
do_QueryFrame
(
scrollbarBox
)
;
nsIScrollbarMediator
*
mediator
=
scrollbarFrame
?
scrollbarFrame
-
>
GetScrollbarMediator
(
)
:
nullptr
;
if
(
!
mediator
|
|
!
mediator
-
>
ShouldSuppressScrollbarRepaints
(
)
)
{
SchedulePaint
(
)
;
}
mCurPos
=
curPos
;
nsIFrame
*
parent
=
GetParent
(
)
;
if
(
parent
)
{
nsCOMPtr
<
nsISliderListener
>
sliderListener
=
do_QueryInterface
(
parent
-
>
GetContent
(
)
)
;
if
(
sliderListener
)
{
nsContentUtils
:
:
AddScriptRunner
(
new
nsValueChangedRunnable
(
sliderListener
nsGkAtoms
:
:
curpos
mCurPos
mUserChanged
)
)
;
}
}
}
static
void
UpdateAttribute
(
Element
*
aScrollbar
nscoord
aNewPos
bool
aNotify
bool
aIsSmooth
)
{
nsAutoString
str
;
str
.
AppendInt
(
aNewPos
)
;
if
(
aIsSmooth
)
{
aScrollbar
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
smooth
NS_LITERAL_STRING
(
"
true
"
)
false
)
;
}
aScrollbar
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
curpos
str
aNotify
)
;
if
(
aIsSmooth
)
{
aScrollbar
-
>
UnsetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
smooth
false
)
;
}
}
void
nsSliderFrame
:
:
SetCurrentThumbPosition
(
nsIContent
*
aScrollbar
nscoord
aNewThumbPos
bool
aIsSmooth
bool
aMaySnap
)
{
nsRect
crect
;
GetXULClientRect
(
crect
)
;
nscoord
offset
=
IsXULHorizontal
(
)
?
crect
.
x
:
crect
.
y
;
int32_t
newPos
=
NSToIntRound
(
(
aNewThumbPos
-
offset
)
/
mRatio
)
;
if
(
aMaySnap
&
&
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
snap
nsGkAtoms
:
:
_true
eCaseMatters
)
)
{
int32_t
increment
=
GetIncrement
(
aScrollbar
)
;
newPos
=
NSToIntRound
(
newPos
/
float
(
increment
)
)
*
increment
;
}
SetCurrentPosition
(
aScrollbar
newPos
aIsSmooth
)
;
}
void
nsSliderFrame
:
:
SetCurrentPosition
(
nsIContent
*
aScrollbar
int32_t
aNewPos
bool
aIsSmooth
)
{
int32_t
minpos
=
GetMinPosition
(
aScrollbar
)
;
int32_t
maxpos
=
GetMaxPosition
(
aScrollbar
)
;
if
(
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
dir
nsGkAtoms
:
:
reverse
eCaseMatters
)
)
aNewPos
=
maxpos
-
aNewPos
;
else
aNewPos
+
=
minpos
;
if
(
aNewPos
<
minpos
|
|
maxpos
<
minpos
)
aNewPos
=
minpos
;
else
if
(
aNewPos
>
maxpos
)
aNewPos
=
maxpos
;
SetCurrentPositionInternal
(
aScrollbar
aNewPos
aIsSmooth
)
;
}
void
nsSliderFrame
:
:
SetCurrentPositionInternal
(
nsIContent
*
aScrollbar
int32_t
aNewPos
bool
aIsSmooth
)
{
nsCOMPtr
<
nsIContent
>
scrollbar
=
aScrollbar
;
nsIFrame
*
scrollbarBox
=
GetScrollbar
(
)
;
AutoWeakFrame
weakFrame
(
this
)
;
mUserChanged
=
true
;
nsScrollbarFrame
*
scrollbarFrame
=
do_QueryFrame
(
scrollbarBox
)
;
if
(
scrollbarFrame
)
{
nsIScrollbarMediator
*
mediator
=
scrollbarFrame
-
>
GetScrollbarMediator
(
)
;
if
(
mediator
)
{
nscoord
oldPos
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
GetCurrentPosition
(
scrollbar
)
)
;
nscoord
newPos
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
aNewPos
)
;
mediator
-
>
ThumbMoved
(
scrollbarFrame
oldPos
newPos
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
;
}
UpdateAttribute
(
scrollbar
-
>
AsElement
(
)
aNewPos
false
aIsSmooth
)
;
CurrentPositionChanged
(
)
;
mUserChanged
=
false
;
return
;
}
}
UpdateAttribute
(
scrollbar
-
>
AsElement
(
)
aNewPos
true
aIsSmooth
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
;
}
mUserChanged
=
false
;
#
ifdef
DEBUG_SLIDER
printf
(
"
Current
Pos
=
%
d
\
n
"
aNewPos
)
;
#
endif
}
void
nsSliderFrame
:
:
SetInitialChildList
(
ChildListID
aListID
nsFrameList
&
aChildList
)
{
nsBoxFrame
:
:
SetInitialChildList
(
aListID
aChildList
)
;
if
(
aListID
=
=
kPrincipalList
)
{
AddListener
(
)
;
}
}
nsresult
nsSliderMediator
:
:
HandleEvent
(
dom
:
:
Event
*
aEvent
)
{
if
(
mSlider
&
&
!
mSlider
-
>
isDraggingThumb
(
)
)
return
mSlider
-
>
StartDrag
(
aEvent
)
;
return
NS_OK
;
}
class
AsyncScrollbarDragStarter
:
public
nsAPostRefreshObserver
{
public
:
AsyncScrollbarDragStarter
(
nsIPresShell
*
aPresShell
nsIWidget
*
aWidget
const
AsyncDragMetrics
&
aDragMetrics
)
:
mPresShell
(
aPresShell
)
mWidget
(
aWidget
)
mDragMetrics
(
aDragMetrics
)
{
}
virtual
~
AsyncScrollbarDragStarter
(
)
{
}
void
DidRefresh
(
)
override
{
if
(
!
mPresShell
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Post
-
refresh
observer
fired
again
after
failed
attempt
at
unregistering
it
"
)
;
return
;
}
mWidget
-
>
StartAsyncScrollbarDrag
(
mDragMetrics
)
;
if
(
!
mPresShell
-
>
RemovePostRefreshObserver
(
this
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unable
to
unregister
post
-
refresh
observer
!
Leaking
it
instead
of
leaving
garbage
registered
"
)
;
mPresShell
=
nullptr
;
mWidget
=
nullptr
;
return
;
}
delete
this
;
}
private
:
RefPtr
<
nsIPresShell
>
mPresShell
;
RefPtr
<
nsIWidget
>
mWidget
;
AsyncDragMetrics
mDragMetrics
;
}
;
static
bool
UsesSVGEffects
(
nsIFrame
*
aFrame
)
{
return
aFrame
-
>
StyleEffects
(
)
-
>
HasFilters
(
)
|
|
nsSVGIntegrationUtils
:
:
UsingMaskOrClipPathForFrame
(
aFrame
)
;
}
static
bool
ScrollFrameWillBuildScrollInfoLayer
(
nsIFrame
*
aScrollFrame
)
{
nsIFrame
*
current
=
aScrollFrame
;
while
(
current
)
{
if
(
UsesSVGEffects
(
current
)
)
{
return
true
;
}
current
=
nsLayoutUtils
:
:
GetParentOrPlaceholderForCrossDoc
(
current
)
;
}
return
false
;
}
nsIScrollableFrame
*
nsSliderFrame
:
:
GetScrollFrame
(
)
{
nsIFrame
*
scrollbarBox
=
GetScrollbar
(
)
;
if
(
!
scrollbarBox
)
{
return
nullptr
;
}
nsContainerFrame
*
scrollFrame
=
scrollbarBox
-
>
GetParent
(
)
;
if
(
!
scrollFrame
)
{
return
nullptr
;
}
nsIScrollableFrame
*
scrollFrameAsScrollable
=
do_QueryFrame
(
scrollFrame
)
;
return
scrollFrameAsScrollable
;
}
void
nsSliderFrame
:
:
StartAPZDrag
(
WidgetGUIEvent
*
aEvent
)
{
if
(
!
aEvent
-
>
mFlags
.
mHandledByAPZ
)
{
return
;
}
if
(
!
gfxPlatform
:
:
GetPlatform
(
)
-
>
SupportsApzDragInput
(
)
)
{
return
;
}
nsIFrame
*
scrollbarBox
=
GetScrollbar
(
)
;
nsContainerFrame
*
scrollFrame
=
scrollbarBox
-
>
GetParent
(
)
;
if
(
!
scrollFrame
)
{
return
;
}
nsIContent
*
scrollableContent
=
scrollFrame
-
>
GetContent
(
)
;
if
(
!
scrollableContent
)
{
return
;
}
if
(
ScrollFrameWillBuildScrollInfoLayer
(
scrollFrame
)
)
{
return
;
}
if
(
UsesCustomScrollbarMediator
(
scrollbarBox
)
)
{
return
;
}
bool
isHorizontal
=
IsXULHorizontal
(
)
;
mozilla
:
:
layers
:
:
FrameMetrics
:
:
ViewID
scrollTargetId
;
bool
hasID
=
nsLayoutUtils
:
:
FindIDFor
(
scrollableContent
&
scrollTargetId
)
;
bool
hasAPZView
=
hasID
&
&
(
scrollTargetId
!
=
layers
:
:
FrameMetrics
:
:
NULL_SCROLL_ID
)
;
if
(
!
hasAPZView
)
{
return
;
}
nsCOMPtr
<
nsIContent
>
scrollbar
=
GetContentOfBox
(
scrollbarBox
)
;
nsIPresShell
*
shell
=
PresShell
(
)
;
uint64_t
inputblockId
=
InputAPZContext
:
:
GetInputBlockId
(
)
;
uint32_t
presShellId
=
shell
-
>
GetPresShellId
(
)
;
AsyncDragMetrics
dragMetrics
(
scrollTargetId
presShellId
inputblockId
NSAppUnitsToFloatPixels
(
mDragStart
float
(
AppUnitsPerCSSPixel
(
)
)
)
isHorizontal
?
ScrollDirection
:
:
eHorizontal
:
ScrollDirection
:
:
eVertical
)
;
if
(
!
nsLayoutUtils
:
:
HasDisplayPort
(
scrollableContent
)
)
{
return
;
}
mScrollingWithAPZ
=
true
;
bool
waitForRefresh
=
InputAPZContext
:
:
HavePendingLayerization
(
)
;
nsIWidget
*
widget
=
this
-
>
GetNearestWidget
(
)
;
if
(
waitForRefresh
)
{
waitForRefresh
=
shell
-
>
AddPostRefreshObserver
(
new
AsyncScrollbarDragStarter
(
shell
widget
dragMetrics
)
)
;
}
if
(
!
waitForRefresh
)
{
widget
-
>
StartAsyncScrollbarDrag
(
dragMetrics
)
;
}
}
nsresult
nsSliderFrame
:
:
StartDrag
(
nsIDOMEvent
*
aEvent
)
{
#
ifdef
DEBUG_SLIDER
printf
(
"
Begin
dragging
\
n
"
)
;
#
endif
if
(
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
disabled
nsGkAtoms
:
:
_true
eCaseMatters
)
)
return
NS_OK
;
WidgetGUIEvent
*
event
=
aEvent
-
>
WidgetEventPtr
(
)
-
>
AsGUIEvent
(
)
;
if
(
!
ShouldScrollForEvent
(
event
)
)
{
return
NS_OK
;
}
nsPoint
pt
;
if
(
!
GetEventPoint
(
event
pt
)
)
{
return
NS_OK
;
}
bool
isHorizontal
=
IsXULHorizontal
(
)
;
nscoord
pos
=
isHorizontal
?
pt
.
x
:
pt
.
y
;
nsCOMPtr
<
nsIContent
>
scrollbar
;
nscoord
newpos
=
pos
;
bool
scrollToClick
=
ShouldScrollToClickForEvent
(
event
)
;
if
(
scrollToClick
)
{
nsIFrame
*
thumbFrame
=
mFrames
.
FirstChild
(
)
;
if
(
!
thumbFrame
)
{
return
NS_OK
;
}
nsSize
thumbSize
=
thumbFrame
-
>
GetSize
(
)
;
nscoord
thumbLength
=
isHorizontal
?
thumbSize
.
width
:
thumbSize
.
height
;
newpos
-
=
(
thumbLength
/
2
)
;
nsIFrame
*
scrollbarBox
=
GetScrollbar
(
)
;
scrollbar
=
GetContentOfBox
(
scrollbarBox
)
;
}
DragThumb
(
true
)
;
if
(
scrollToClick
)
{
SetCurrentThumbPosition
(
scrollbar
newpos
false
false
)
;
}
nsIFrame
*
thumbFrame
=
mFrames
.
FirstChild
(
)
;
if
(
!
thumbFrame
)
{
return
NS_OK
;
}
#
ifdef
MOZ_WIDGET_GTK
RefPtr
<
Element
>
thumb
=
thumbFrame
-
>
GetContent
(
)
-
>
AsElement
(
)
;
thumb
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
active
NS_LITERAL_STRING
(
"
true
"
)
true
)
;
#
endif
if
(
isHorizontal
)
mThumbStart
=
thumbFrame
-
>
GetPosition
(
)
.
x
;
else
mThumbStart
=
thumbFrame
-
>
GetPosition
(
)
.
y
;
mDragStart
=
pos
-
mThumbStart
;
mScrollingWithAPZ
=
false
;
StartAPZDrag
(
event
)
;
#
ifdef
DEBUG_SLIDER
printf
(
"
Pressed
mDragStart
=
%
d
\
n
"
mDragStart
)
;
#
endif
if
(
!
mScrollingWithAPZ
)
{
SuppressDisplayport
(
)
;
}
return
NS_OK
;
}
nsresult
nsSliderFrame
:
:
StopDrag
(
)
{
AddListener
(
)
;
DragThumb
(
false
)
;
mScrollingWithAPZ
=
false
;
UnsuppressDisplayport
(
)
;
#
ifdef
MOZ_WIDGET_GTK
nsIFrame
*
thumbFrame
=
mFrames
.
FirstChild
(
)
;
if
(
thumbFrame
)
{
RefPtr
<
Element
>
thumb
=
thumbFrame
-
>
GetContent
(
)
-
>
AsElement
(
)
;
thumb
-
>
UnsetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
active
true
)
;
}
#
endif
if
(
mChange
)
{
StopRepeat
(
)
;
mChange
=
0
;
}
return
NS_OK
;
}
void
nsSliderFrame
:
:
DragThumb
(
bool
aGrabMouseEvents
)
{
mDragFinished
=
!
aGrabMouseEvents
;
nsIFrame
*
parent
=
GetParent
(
)
;
if
(
parent
)
{
nsCOMPtr
<
nsISliderListener
>
sliderListener
=
do_QueryInterface
(
parent
-
>
GetContent
(
)
)
;
if
(
sliderListener
)
{
nsContentUtils
:
:
AddScriptRunner
(
new
nsDragStateChangedRunnable
(
sliderListener
aGrabMouseEvents
)
)
;
}
}
nsIPresShell
:
:
SetCapturingContent
(
aGrabMouseEvents
?
GetContent
(
)
:
nullptr
aGrabMouseEvents
?
CAPTURE_IGNOREALLOWED
:
0
)
;
}
bool
nsSliderFrame
:
:
isDraggingThumb
(
)
{
return
(
nsIPresShell
:
:
GetCapturingContent
(
)
=
=
GetContent
(
)
)
;
}
void
nsSliderFrame
:
:
AddListener
(
)
{
if
(
!
mMediator
)
{
mMediator
=
new
nsSliderMediator
(
this
)
;
}
nsIFrame
*
thumbFrame
=
mFrames
.
FirstChild
(
)
;
if
(
!
thumbFrame
)
{
return
;
}
thumbFrame
-
>
GetContent
(
)
-
>
AddSystemEventListener
(
NS_LITERAL_STRING
(
"
mousedown
"
)
mMediator
false
false
)
;
thumbFrame
-
>
GetContent
(
)
-
>
AddSystemEventListener
(
NS_LITERAL_STRING
(
"
touchstart
"
)
mMediator
false
false
)
;
}
void
nsSliderFrame
:
:
RemoveListener
(
)
{
NS_ASSERTION
(
mMediator
"
No
listener
was
ever
added
!
!
"
)
;
nsIFrame
*
thumbFrame
=
mFrames
.
FirstChild
(
)
;
if
(
!
thumbFrame
)
return
;
thumbFrame
-
>
GetContent
(
)
-
>
RemoveSystemEventListener
(
NS_LITERAL_STRING
(
"
mousedown
"
)
mMediator
false
)
;
}
bool
nsSliderFrame
:
:
ShouldScrollForEvent
(
WidgetGUIEvent
*
aEvent
)
{
switch
(
aEvent
-
>
mMessage
)
{
case
eTouchStart
:
case
eTouchEnd
:
return
true
;
case
eMouseDown
:
case
eMouseUp
:
{
uint16_t
button
=
aEvent
-
>
AsMouseEvent
(
)
-
>
button
;
#
ifdef
MOZ_WIDGET_GTK
return
(
button
=
=
WidgetMouseEvent
:
:
eLeftButton
)
|
|
(
button
=
=
WidgetMouseEvent
:
:
eRightButton
&
&
GetScrollToClick
(
)
)
|
|
(
button
=
=
WidgetMouseEvent
:
:
eMiddleButton
&
&
gMiddlePref
&
&
!
GetScrollToClick
(
)
)
;
#
else
return
(
button
=
=
WidgetMouseEvent
:
:
eLeftButton
)
|
|
(
button
=
=
WidgetMouseEvent
:
:
eMiddleButton
&
&
gMiddlePref
)
;
#
endif
}
default
:
return
false
;
}
}
bool
nsSliderFrame
:
:
ShouldScrollToClickForEvent
(
WidgetGUIEvent
*
aEvent
)
{
if
(
!
ShouldScrollForEvent
(
aEvent
)
)
{
return
false
;
}
if
(
aEvent
-
>
mMessage
!
=
eMouseDown
&
&
aEvent
-
>
mMessage
!
=
eTouchStart
)
{
return
false
;
}
#
if
defined
(
XP_MACOSX
)
|
|
defined
(
MOZ_WIDGET_GTK
)
if
(
IsEventOverThumb
(
aEvent
)
)
{
return
false
;
}
#
endif
if
(
aEvent
-
>
mMessage
=
=
eTouchStart
)
{
return
GetScrollToClick
(
)
;
}
WidgetMouseEvent
*
mouseEvent
=
aEvent
-
>
AsMouseEvent
(
)
;
if
(
mouseEvent
-
>
button
=
=
WidgetMouseEvent
:
:
eLeftButton
)
{
#
ifdef
XP_MACOSX
bool
invertPref
=
mouseEvent
-
>
IsAlt
(
)
;
#
else
bool
invertPref
=
mouseEvent
-
>
IsShift
(
)
;
#
endif
return
GetScrollToClick
(
)
!
=
invertPref
;
}
#
ifdef
MOZ_WIDGET_GTK
if
(
mouseEvent
-
>
button
=
=
WidgetMouseEvent
:
:
eRightButton
)
{
return
!
GetScrollToClick
(
)
;
}
#
endif
return
true
;
}
bool
nsSliderFrame
:
:
IsEventOverThumb
(
WidgetGUIEvent
*
aEvent
)
{
nsIFrame
*
thumbFrame
=
mFrames
.
FirstChild
(
)
;
if
(
!
thumbFrame
)
{
return
false
;
}
nsPoint
eventPoint
;
if
(
!
GetEventPoint
(
aEvent
eventPoint
)
)
{
return
false
;
}
nsRect
thumbRect
=
thumbFrame
-
>
GetRect
(
)
;
#
if
defined
(
MOZ_WIDGET_GTK
)
return
eventPoint
.
x
>
=
thumbRect
.
x
&
&
eventPoint
.
x
<
thumbRect
.
XMost
(
)
&
&
eventPoint
.
y
>
=
thumbRect
.
y
&
&
eventPoint
.
y
<
thumbRect
.
YMost
(
)
;
#
else
bool
isHorizontal
=
IsXULHorizontal
(
)
;
nscoord
eventPos
=
isHorizontal
?
eventPoint
.
x
:
eventPoint
.
y
;
nscoord
thumbStart
=
isHorizontal
?
thumbRect
.
x
:
thumbRect
.
y
;
nscoord
thumbEnd
=
isHorizontal
?
thumbRect
.
XMost
(
)
:
thumbRect
.
YMost
(
)
;
return
eventPos
>
=
thumbStart
&
&
eventPos
<
thumbEnd
;
#
endif
}
NS_IMETHODIMP
nsSliderFrame
:
:
HandlePress
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
{
if
(
!
ShouldScrollForEvent
(
aEvent
)
|
|
ShouldScrollToClickForEvent
(
aEvent
)
)
{
return
NS_OK
;
}
if
(
IsEventOverThumb
(
aEvent
)
)
{
return
NS_OK
;
}
nsIFrame
*
thumbFrame
=
mFrames
.
FirstChild
(
)
;
if
(
!
thumbFrame
)
return
NS_OK
;
if
(
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
disabled
nsGkAtoms
:
:
_true
eCaseMatters
)
)
return
NS_OK
;
nsRect
thumbRect
=
thumbFrame
-
>
GetRect
(
)
;
nscoord
change
=
1
;
nsPoint
eventPoint
;
if
(
!
GetEventPoint
(
aEvent
eventPoint
)
)
{
return
NS_OK
;
}
if
(
IsXULHorizontal
(
)
?
eventPoint
.
x
<
thumbRect
.
x
:
eventPoint
.
y
<
thumbRect
.
y
)
change
=
-
1
;
mChange
=
change
;
DragThumb
(
true
)
;
#
ifdef
MOZ_WIDGET_GTK
nsRect
clientRect
;
GetXULClientRect
(
clientRect
)
;
if
(
change
>
0
)
{
mDestinationPoint
=
nsPoint
(
clientRect
.
width
clientRect
.
height
)
;
}
else
{
mDestinationPoint
=
nsPoint
(
0
0
)
;
}
#
else
mDestinationPoint
=
eventPoint
;
#
endif
StartRepeat
(
)
;
PageScroll
(
change
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSliderFrame
:
:
HandleRelease
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
{
StopRepeat
(
)
;
nsIFrame
*
scrollbar
=
GetScrollbar
(
)
;
nsScrollbarFrame
*
sb
=
do_QueryFrame
(
scrollbar
)
;
if
(
sb
)
{
nsIScrollbarMediator
*
m
=
sb
-
>
GetScrollbarMediator
(
)
;
if
(
m
)
{
m
-
>
ScrollbarReleased
(
sb
)
;
}
}
return
NS_OK
;
}
void
nsSliderFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
{
if
(
mMediator
)
{
mMediator
-
>
SetSlider
(
nullptr
)
;
mMediator
=
nullptr
;
}
StopRepeat
(
)
;
nsBoxFrame
:
:
DestroyFrom
(
aDestructRoot
aPostDestroyData
)
;
}
nsSize
nsSliderFrame
:
:
GetXULPrefSize
(
nsBoxLayoutState
&
aState
)
{
EnsureOrient
(
)
;
return
nsBoxFrame
:
:
GetXULPrefSize
(
aState
)
;
}
nsSize
nsSliderFrame
:
:
GetXULMinSize
(
nsBoxLayoutState
&
aState
)
{
EnsureOrient
(
)
;
return
nsBox
:
:
GetXULMinSize
(
aState
)
;
}
nsSize
nsSliderFrame
:
:
GetXULMaxSize
(
nsBoxLayoutState
&
aState
)
{
EnsureOrient
(
)
;
return
nsBoxFrame
:
:
GetXULMaxSize
(
aState
)
;
}
void
nsSliderFrame
:
:
EnsureOrient
(
)
{
nsIFrame
*
scrollbarBox
=
GetScrollbar
(
)
;
bool
isHorizontal
=
(
scrollbarBox
-
>
GetStateBits
(
)
&
NS_STATE_IS_HORIZONTAL
)
!
=
0
;
if
(
isHorizontal
)
AddStateBits
(
NS_STATE_IS_HORIZONTAL
)
;
else
RemoveStateBits
(
NS_STATE_IS_HORIZONTAL
)
;
}
void
nsSliderFrame
:
:
Notify
(
void
)
{
bool
stop
=
false
;
nsIFrame
*
thumbFrame
=
mFrames
.
FirstChild
(
)
;
if
(
!
thumbFrame
)
{
StopRepeat
(
)
;
return
;
}
nsRect
thumbRect
=
thumbFrame
-
>
GetRect
(
)
;
bool
isHorizontal
=
IsXULHorizontal
(
)
;
if
(
isHorizontal
)
{
if
(
mChange
<
0
)
{
if
(
thumbRect
.
x
<
mDestinationPoint
.
x
)
stop
=
true
;
}
else
{
if
(
thumbRect
.
x
+
thumbRect
.
width
>
mDestinationPoint
.
x
)
stop
=
true
;
}
}
else
{
if
(
mChange
<
0
)
{
if
(
thumbRect
.
y
<
mDestinationPoint
.
y
)
stop
=
true
;
}
else
{
if
(
thumbRect
.
y
+
thumbRect
.
height
>
mDestinationPoint
.
y
)
stop
=
true
;
}
}
if
(
stop
)
{
StopRepeat
(
)
;
}
else
{
PageScroll
(
mChange
)
;
}
}
void
nsSliderFrame
:
:
PageScroll
(
nscoord
aChange
)
{
if
(
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
dir
nsGkAtoms
:
:
reverse
eCaseMatters
)
)
{
aChange
=
-
aChange
;
}
nsIFrame
*
scrollbar
=
GetScrollbar
(
)
;
nsScrollbarFrame
*
sb
=
do_QueryFrame
(
scrollbar
)
;
if
(
sb
)
{
nsIScrollbarMediator
*
m
=
sb
-
>
GetScrollbarMediator
(
)
;
sb
-
>
SetIncrementToPage
(
aChange
)
;
if
(
m
)
{
m
-
>
ScrollByPage
(
sb
aChange
nsIScrollbarMediator
:
:
ENABLE_SNAP
)
;
return
;
}
}
PageUpDown
(
aChange
)
;
}
float
nsSliderFrame
:
:
GetThumbRatio
(
)
const
{
return
mRatio
/
mozilla
:
:
AppUnitsPerCSSPixel
(
)
;
}
void
nsSliderFrame
:
:
AsyncScrollbarDragRejected
(
)
{
mScrollingWithAPZ
=
false
;
if
(
isDraggingThumb
(
)
)
{
SuppressDisplayport
(
)
;
}
}
void
nsSliderFrame
:
:
SuppressDisplayport
(
)
{
if
(
!
mSuppressionActive
)
{
MOZ_ASSERT
(
PresShell
(
)
)
;
APZCCallbackHelper
:
:
SuppressDisplayport
(
true
PresShell
(
)
)
;
mSuppressionActive
=
true
;
}
}
void
nsSliderFrame
:
:
UnsuppressDisplayport
(
)
{
if
(
mSuppressionActive
)
{
MOZ_ASSERT
(
PresShell
(
)
)
;
APZCCallbackHelper
:
:
SuppressDisplayport
(
false
PresShell
(
)
)
;
mSuppressionActive
=
false
;
}
}
bool
nsSliderFrame
:
:
OnlySystemGroupDispatch
(
EventMessage
aMessage
)
const
{
return
aMessage
=
=
eMouseMove
&
&
GetContent
(
)
-
>
IsInNativeAnonymousSubtree
(
)
;
}
NS_IMPL_ISUPPORTS
(
nsSliderMediator
nsIDOMEventListener
)
