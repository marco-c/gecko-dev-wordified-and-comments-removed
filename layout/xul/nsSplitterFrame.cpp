#
include
"
LayoutConstants
.
h
"
#
include
"
SimpleXULLeafFrame
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
mozilla
/
ReflowInput
.
h
"
#
include
"
nsSplitterFrame
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsXULElement
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsScrollbarButtonFrame
.
h
"
#
include
"
nsIDOMEventListener
.
h
"
#
include
"
nsICSSDeclaration
.
h
"
#
include
"
nsFrameList
.
h
"
#
include
"
nsHTMLParts
.
h
"
#
include
"
mozilla
/
ComputedStyle
.
h
"
#
include
"
mozilla
/
CSSOrderAwareFrameIterator
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsFlexContainerFrame
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
MouseEvent
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsStyledElement
.
h
"
using
namespace
mozilla
;
using
mozilla
:
:
dom
:
:
Element
;
using
mozilla
:
:
dom
:
:
Event
;
class
nsSplitterInfo
{
public
:
nscoord
min
;
nscoord
max
;
nscoord
current
;
nscoord
pref
;
nscoord
changed
;
nsCOMPtr
<
nsIContent
>
childElem
;
}
;
enum
class
ResizeType
{
Closest
Farthest
Flex
Grow
Sibling
None
}
;
static
ResizeType
ResizeTypeFromAttribute
(
const
Element
&
aElement
nsAtom
*
aAttribute
)
{
static
Element
:
:
AttrValuesArray
strings
[
]
=
{
nsGkAtoms
:
:
farthest
nsGkAtoms
:
:
flex
nsGkAtoms
:
:
grow
nsGkAtoms
:
:
sibling
nsGkAtoms
:
:
none
nullptr
}
;
switch
(
aElement
.
FindAttrValueIn
(
kNameSpaceID_None
aAttribute
strings
eCaseMatters
)
)
{
case
0
:
return
ResizeType
:
:
Farthest
;
case
1
:
return
ResizeType
:
:
Flex
;
case
2
:
if
(
aAttribute
=
=
nsGkAtoms
:
:
resizeafter
)
{
return
ResizeType
:
:
Grow
;
}
break
;
case
3
:
return
ResizeType
:
:
Sibling
;
case
4
:
return
ResizeType
:
:
None
;
default
:
break
;
}
return
ResizeType
:
:
Closest
;
}
class
nsSplitterFrameInner
final
:
public
nsIDOMEventListener
{
protected
:
virtual
~
nsSplitterFrameInner
(
)
;
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSIDOMEVENTLISTENER
explicit
nsSplitterFrameInner
(
nsSplitterFrame
*
aSplitter
)
:
mOuter
(
aSplitter
)
{
}
void
Disconnect
(
)
{
mOuter
=
nullptr
;
}
nsresult
MouseDown
(
Event
*
aMouseEvent
)
;
nsresult
MouseUp
(
Event
*
aMouseEvent
)
;
nsresult
MouseMove
(
Event
*
aMouseEvent
)
;
void
MouseDrag
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
)
;
void
MouseUp
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
)
;
void
AdjustChildren
(
nsPresContext
*
aPresContext
)
;
void
AdjustChildren
(
nsPresContext
*
aPresContext
nsTArray
<
nsSplitterInfo
>
&
aChildInfos
bool
aIsHorizontal
)
;
void
AddRemoveSpace
(
nscoord
aDiff
nsTArray
<
nsSplitterInfo
>
&
aChildInfos
int32_t
&
aSpaceLeft
)
;
void
ResizeChildTo
(
nscoord
&
aDiff
)
;
void
UpdateState
(
)
;
void
AddListener
(
)
;
void
RemoveListener
(
)
;
enum
class
State
{
Open
CollapsedBefore
CollapsedAfter
Dragging
}
;
enum
CollapseDirection
{
Before
After
}
;
ResizeType
GetResizeBefore
(
)
;
ResizeType
GetResizeAfter
(
)
;
State
GetState
(
)
;
bool
SupportsCollapseDirection
(
CollapseDirection
aDirection
)
;
void
EnsureOrient
(
)
;
void
SetPreferredSize
(
nsIFrame
*
aChildBox
bool
aIsHorizontal
nscoord
aSize
)
;
nsSplitterFrame
*
mOuter
;
bool
mDidDrag
=
false
;
nscoord
mDragStart
=
0
;
nsIFrame
*
mParentBox
=
nullptr
;
bool
mPressed
=
false
;
nsTArray
<
nsSplitterInfo
>
mChildInfosBefore
;
nsTArray
<
nsSplitterInfo
>
mChildInfosAfter
;
State
mState
=
State
:
:
Open
;
nscoord
mSplitterPos
=
0
;
bool
mDragging
=
false
;
const
Element
*
SplitterElement
(
)
const
{
return
mOuter
-
>
GetContent
(
)
-
>
AsElement
(
)
;
}
}
;
NS_IMPL_ISUPPORTS
(
nsSplitterFrameInner
nsIDOMEventListener
)
ResizeType
nsSplitterFrameInner
:
:
GetResizeBefore
(
)
{
return
ResizeTypeFromAttribute
(
*
SplitterElement
(
)
nsGkAtoms
:
:
resizebefore
)
;
}
ResizeType
nsSplitterFrameInner
:
:
GetResizeAfter
(
)
{
return
ResizeTypeFromAttribute
(
*
SplitterElement
(
)
nsGkAtoms
:
:
resizeafter
)
;
}
nsSplitterFrameInner
:
:
~
nsSplitterFrameInner
(
)
=
default
;
nsSplitterFrameInner
:
:
State
nsSplitterFrameInner
:
:
GetState
(
)
{
static
Element
:
:
AttrValuesArray
strings
[
]
=
{
nsGkAtoms
:
:
dragging
nsGkAtoms
:
:
collapsed
nullptr
}
;
static
Element
:
:
AttrValuesArray
strings_substate
[
]
=
{
nsGkAtoms
:
:
before
nsGkAtoms
:
:
after
nullptr
}
;
switch
(
SplitterElement
(
)
-
>
FindAttrValueIn
(
kNameSpaceID_None
nsGkAtoms
:
:
state
strings
eCaseMatters
)
)
{
case
0
:
return
State
:
:
Dragging
;
case
1
:
switch
(
SplitterElement
(
)
-
>
FindAttrValueIn
(
kNameSpaceID_None
nsGkAtoms
:
:
substate
strings_substate
eCaseMatters
)
)
{
case
0
:
return
State
:
:
CollapsedBefore
;
case
1
:
return
State
:
:
CollapsedAfter
;
default
:
if
(
SupportsCollapseDirection
(
After
)
)
{
return
State
:
:
CollapsedAfter
;
}
return
State
:
:
CollapsedBefore
;
}
}
return
State
:
:
Open
;
}
nsIFrame
*
NS_NewSplitterFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsSplitterFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsSplitterFrame
)
nsSplitterFrame
:
:
nsSplitterFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
:
SimpleXULLeafFrame
(
aStyle
aPresContext
kClassID
)
{
}
void
nsSplitterFrame
:
:
Destroy
(
DestroyContext
&
aContext
)
{
if
(
mInner
)
{
mInner
-
>
RemoveListener
(
)
;
mInner
-
>
Disconnect
(
)
;
mInner
=
nullptr
;
}
SimpleXULLeafFrame
:
:
Destroy
(
aContext
)
;
}
nsresult
nsSplitterFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
nsresult
rv
=
SimpleXULLeafFrame
:
:
AttributeChanged
(
aNameSpaceID
aAttribute
aModType
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
state
)
{
mInner
-
>
UpdateState
(
)
;
}
return
rv
;
}
void
nsSplitterFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
MOZ_ASSERT
(
!
mInner
)
;
mInner
=
new
nsSplitterFrameInner
(
this
)
;
SimpleXULLeafFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
mInner
-
>
AddListener
(
)
;
mInner
-
>
mParentBox
=
nullptr
;
}
static
bool
IsValidParentBox
(
nsIFrame
*
aFrame
)
{
return
aFrame
-
>
IsFlexContainerFrame
(
)
;
}
static
nsIFrame
*
GetValidParentBox
(
nsIFrame
*
aChild
)
{
return
aChild
-
>
GetParent
(
)
&
&
IsValidParentBox
(
aChild
-
>
GetParent
(
)
)
?
aChild
-
>
GetParent
(
)
:
nullptr
;
}
void
nsSplitterFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
if
(
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
)
{
mInner
-
>
mParentBox
=
GetValidParentBox
(
this
)
;
mInner
-
>
UpdateState
(
)
;
}
return
SimpleXULLeafFrame
:
:
Reflow
(
aPresContext
aDesiredSize
aReflowInput
aStatus
)
;
}
static
bool
SplitterIsHorizontal
(
const
nsIFrame
*
aParentBox
)
{
MOZ_ASSERT
(
aParentBox
-
>
IsFlexContainerFrame
(
)
)
;
const
FlexboxAxisInfo
info
(
aParentBox
)
;
return
!
info
.
mIsRowOriented
;
}
NS_IMETHODIMP
nsSplitterFrame
:
:
HandlePress
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
{
return
NS_OK
;
}
NS_IMETHODIMP
nsSplitterFrame
:
:
HandleMultiplePress
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
bool
aControlHeld
)
{
return
NS_OK
;
}
NS_IMETHODIMP
nsSplitterFrame
:
:
HandleDrag
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
{
return
NS_OK
;
}
NS_IMETHODIMP
nsSplitterFrame
:
:
HandleRelease
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
{
return
NS_OK
;
}
void
nsSplitterFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
SimpleXULLeafFrame
:
:
BuildDisplayList
(
aBuilder
aLists
)
;
if
(
mInner
-
>
mDragging
&
&
aBuilder
-
>
IsForEventDelivery
(
)
)
{
aLists
.
Outlines
(
)
-
>
AppendNewToTop
<
nsDisplayEventReceiver
>
(
aBuilder
this
)
;
return
;
}
}
nsresult
nsSplitterFrame
:
:
HandleEvent
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
{
NS_ENSURE_ARG_POINTER
(
aEventStatus
)
;
if
(
nsEventStatus_eConsumeNoDefault
=
=
*
aEventStatus
)
{
return
NS_OK
;
}
AutoWeakFrame
weakFrame
(
this
)
;
RefPtr
<
nsSplitterFrameInner
>
inner
(
mInner
)
;
switch
(
aEvent
-
>
mMessage
)
{
case
eMouseMove
:
inner
-
>
MouseDrag
(
aPresContext
aEvent
)
;
break
;
case
eMouseUp
:
if
(
aEvent
-
>
AsMouseEvent
(
)
-
>
mButton
=
=
MouseButton
:
:
ePrimary
)
{
inner
-
>
MouseUp
(
aPresContext
aEvent
)
;
}
break
;
default
:
break
;
}
NS_ENSURE_STATE
(
weakFrame
.
IsAlive
(
)
)
;
return
SimpleXULLeafFrame
:
:
HandleEvent
(
aPresContext
aEvent
aEventStatus
)
;
}
void
nsSplitterFrameInner
:
:
MouseUp
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
)
{
if
(
mDragging
&
&
mOuter
)
{
AdjustChildren
(
aPresContext
)
;
AddListener
(
)
;
PresShell
:
:
ReleaseCapturingContent
(
)
;
mDragging
=
false
;
State
newState
=
GetState
(
)
;
if
(
newState
=
=
State
:
:
Dragging
)
{
mOuter
-
>
mContent
-
>
AsElement
(
)
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
state
u
"
"
_ns
true
)
;
}
mPressed
=
false
;
if
(
mDidDrag
)
{
RefPtr
<
nsXULElement
>
element
=
nsXULElement
:
:
FromNode
(
mOuter
-
>
GetContent
(
)
)
;
element
-
>
DoCommand
(
)
;
}
}
mChildInfosBefore
.
Clear
(
)
;
mChildInfosAfter
.
Clear
(
)
;
}
void
nsSplitterFrameInner
:
:
MouseDrag
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
)
{
if
(
!
mDragging
|
|
!
mOuter
)
{
return
;
}
const
bool
isHorizontal
=
!
mOuter
-
>
IsHorizontal
(
)
;
nsPoint
pt
=
nsLayoutUtils
:
:
GetEventCoordinatesRelativeTo
(
aEvent
RelativeTo
{
mParentBox
}
)
;
nscoord
pos
=
isHorizontal
?
pt
.
x
:
pt
.
y
;
pos
-
=
mDragStart
;
for
(
auto
&
info
:
mChildInfosBefore
)
{
info
.
changed
=
info
.
current
;
}
for
(
auto
&
info
:
mChildInfosAfter
)
{
info
.
changed
=
info
.
current
;
}
nscoord
oldPos
=
pos
;
ResizeChildTo
(
pos
)
;
State
currentState
=
GetState
(
)
;
bool
supportsBefore
=
SupportsCollapseDirection
(
Before
)
;
bool
supportsAfter
=
SupportsCollapseDirection
(
After
)
;
const
bool
isRTL
=
mOuter
-
>
StyleVisibility
(
)
-
>
mDirection
=
=
StyleDirection
:
:
Rtl
;
bool
pastEnd
=
oldPos
>
0
&
&
oldPos
>
pos
;
bool
pastBegin
=
oldPos
<
0
&
&
oldPos
<
pos
;
if
(
isRTL
)
{
std
:
:
swap
(
pastEnd
pastBegin
)
;
}
const
bool
isCollapsedBefore
=
pastBegin
&
&
supportsBefore
;
const
bool
isCollapsedAfter
=
pastEnd
&
&
supportsAfter
;
if
(
isCollapsedBefore
|
|
isCollapsedAfter
)
{
if
(
currentState
=
=
State
:
:
Dragging
)
{
if
(
pastEnd
)
{
if
(
supportsAfter
)
{
RefPtr
<
Element
>
outer
=
mOuter
-
>
mContent
-
>
AsElement
(
)
;
outer
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
substate
u
"
after
"
_ns
true
)
;
outer
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
state
u
"
collapsed
"
_ns
true
)
;
}
}
else
if
(
pastBegin
)
{
if
(
supportsBefore
)
{
RefPtr
<
Element
>
outer
=
mOuter
-
>
mContent
-
>
AsElement
(
)
;
outer
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
substate
u
"
before
"
_ns
true
)
;
outer
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
state
u
"
collapsed
"
_ns
true
)
;
}
}
}
}
else
{
if
(
currentState
!
=
State
:
:
Dragging
)
{
mOuter
-
>
mContent
-
>
AsElement
(
)
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
state
u
"
dragging
"
_ns
true
)
;
}
AdjustChildren
(
aPresContext
)
;
}
mDidDrag
=
true
;
}
void
nsSplitterFrameInner
:
:
AddListener
(
)
{
mOuter
-
>
GetContent
(
)
-
>
AddEventListener
(
u
"
mouseup
"
_ns
this
false
false
)
;
mOuter
-
>
GetContent
(
)
-
>
AddEventListener
(
u
"
mousedown
"
_ns
this
false
false
)
;
mOuter
-
>
GetContent
(
)
-
>
AddEventListener
(
u
"
mousemove
"
_ns
this
false
false
)
;
mOuter
-
>
GetContent
(
)
-
>
AddEventListener
(
u
"
mouseout
"
_ns
this
false
false
)
;
}
void
nsSplitterFrameInner
:
:
RemoveListener
(
)
{
NS_ENSURE_TRUE_VOID
(
mOuter
)
;
mOuter
-
>
GetContent
(
)
-
>
RemoveEventListener
(
u
"
mouseup
"
_ns
this
false
)
;
mOuter
-
>
GetContent
(
)
-
>
RemoveEventListener
(
u
"
mousedown
"
_ns
this
false
)
;
mOuter
-
>
GetContent
(
)
-
>
RemoveEventListener
(
u
"
mousemove
"
_ns
this
false
)
;
mOuter
-
>
GetContent
(
)
-
>
RemoveEventListener
(
u
"
mouseout
"
_ns
this
false
)
;
}
nsresult
nsSplitterFrameInner
:
:
HandleEvent
(
dom
:
:
Event
*
aEvent
)
{
nsAutoString
eventType
;
aEvent
-
>
GetType
(
eventType
)
;
if
(
eventType
.
EqualsLiteral
(
"
mouseup
"
)
)
return
MouseUp
(
aEvent
)
;
if
(
eventType
.
EqualsLiteral
(
"
mousedown
"
)
)
return
MouseDown
(
aEvent
)
;
if
(
eventType
.
EqualsLiteral
(
"
mousemove
"
)
|
|
eventType
.
EqualsLiteral
(
"
mouseout
"
)
)
return
MouseMove
(
aEvent
)
;
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
eventType
"
)
;
return
NS_OK
;
}
nsresult
nsSplitterFrameInner
:
:
MouseUp
(
Event
*
aMouseEvent
)
{
NS_ENSURE_TRUE
(
mOuter
NS_OK
)
;
mPressed
=
false
;
PresShell
:
:
ReleaseCapturingContent
(
)
;
return
NS_OK
;
}
template
<
typename
LengthLike
>
static
nscoord
ToLengthWithFallback
(
const
LengthLike
&
aLengthLike
nscoord
aFallback
)
{
if
(
aLengthLike
.
ConvertsToLength
(
)
)
{
return
aLengthLike
.
ToLength
(
)
;
}
return
aFallback
;
}
template
<
typename
LengthLike
>
static
nsSize
ToLengthWithFallback
(
const
LengthLike
&
aWidth
const
LengthLike
&
aHeight
nscoord
aFallback
=
0
)
{
return
{
ToLengthWithFallback
(
aWidth
aFallback
)
ToLengthWithFallback
(
aHeight
aFallback
)
}
;
}
static
void
ApplyMargin
(
nsSize
&
aSize
const
nsMargin
&
aMargin
)
{
if
(
aSize
.
width
!
=
NS_UNCONSTRAINEDSIZE
)
{
aSize
.
width
+
=
aMargin
.
LeftRight
(
)
;
}
if
(
aSize
.
height
!
=
NS_UNCONSTRAINEDSIZE
)
{
aSize
.
height
+
=
aMargin
.
TopBottom
(
)
;
}
}
nsresult
nsSplitterFrameInner
:
:
MouseDown
(
Event
*
aMouseEvent
)
{
NS_ENSURE_TRUE
(
mOuter
NS_OK
)
;
dom
:
:
MouseEvent
*
mouseEvent
=
aMouseEvent
-
>
AsMouseEvent
(
)
;
if
(
!
mouseEvent
)
{
return
NS_OK
;
}
if
(
mouseEvent
-
>
Button
(
)
!
=
0
)
{
return
NS_OK
;
}
if
(
SplitterElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
disabled
nsGkAtoms
:
:
_true
eCaseMatters
)
)
return
NS_OK
;
mParentBox
=
GetValidParentBox
(
mOuter
)
;
if
(
!
mParentBox
)
{
return
NS_OK
;
}
mDidDrag
=
false
;
EnsureOrient
(
)
;
const
bool
isHorizontal
=
!
mOuter
-
>
IsHorizontal
(
)
;
const
nsIContent
*
outerContent
=
mOuter
-
>
GetContent
(
)
;
const
ResizeType
resizeBefore
=
GetResizeBefore
(
)
;
const
ResizeType
resizeAfter
=
GetResizeAfter
(
)
;
const
int32_t
childCount
=
mParentBox
-
>
PrincipalChildList
(
)
.
GetLength
(
)
;
mChildInfosBefore
.
Clear
(
)
;
mChildInfosAfter
.
Clear
(
)
;
int32_t
count
=
0
;
bool
foundOuter
=
false
;
CSSOrderAwareFrameIterator
iter
(
mParentBox
FrameChildListID
:
:
Principal
CSSOrderAwareFrameIterator
:
:
ChildFilter
:
:
IncludeAll
CSSOrderAwareFrameIterator
:
:
OrderState
:
:
Unknown
CSSOrderAwareFrameIterator
:
:
OrderingProperty
:
:
Order
)
;
for
(
;
!
iter
.
AtEnd
(
)
;
iter
.
Next
(
)
)
{
nsIFrame
*
childBox
=
iter
.
get
(
)
;
if
(
childBox
=
=
mOuter
)
{
foundOuter
=
true
;
if
(
!
count
)
{
return
NS_OK
;
}
if
(
count
=
=
childCount
-
1
&
&
resizeAfter
!
=
ResizeType
:
:
Grow
)
{
return
NS_OK
;
}
}
count
+
+
;
nsIContent
*
content
=
childBox
-
>
GetContent
(
)
;
const
nscoord
flex
=
childBox
-
>
StyleXUL
(
)
-
>
mBoxFlex
;
const
bool
isBefore
=
!
foundOuter
;
const
bool
isResizable
=
[
&
]
{
if
(
auto
*
element
=
nsXULElement
:
:
FromNode
(
content
)
)
{
if
(
element
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
nsGkAtoms
:
:
splitter
)
{
return
false
;
}
if
(
element
-
>
GetXULBoolAttr
(
nsGkAtoms
:
:
fixed
)
|
|
element
-
>
GetXULBoolAttr
(
nsGkAtoms
:
:
hidden
)
)
{
return
false
;
}
}
if
(
resizeBefore
=
=
ResizeType
:
:
Sibling
&
&
content
-
>
GetNextElementSibling
(
)
=
=
outerContent
)
{
return
true
;
}
if
(
resizeAfter
=
=
ResizeType
:
:
Sibling
&
&
content
-
>
GetPreviousElementSibling
(
)
=
=
outerContent
)
{
return
true
;
}
const
ResizeType
resizeType
=
isBefore
?
resizeBefore
:
resizeAfter
;
switch
(
resizeType
)
{
case
ResizeType
:
:
Grow
:
case
ResizeType
:
:
None
:
case
ResizeType
:
:
Sibling
:
return
false
;
case
ResizeType
:
:
Flex
:
return
flex
>
0
;
case
ResizeType
:
:
Closest
:
case
ResizeType
:
:
Farthest
:
break
;
}
return
true
;
}
(
)
;
if
(
!
isResizable
)
{
continue
;
}
nsSize
curSize
=
childBox
-
>
GetSize
(
)
;
const
auto
&
pos
=
*
childBox
-
>
StylePosition
(
)
;
nsSize
minSize
=
ToLengthWithFallback
(
pos
.
mMinWidth
pos
.
mMinHeight
)
;
nsSize
maxSize
=
ToLengthWithFallback
(
pos
.
mMaxWidth
pos
.
mMaxHeight
NS_UNCONSTRAINEDSIZE
)
;
nsSize
prefSize
(
ToLengthWithFallback
(
pos
.
mWidth
curSize
.
width
)
ToLengthWithFallback
(
pos
.
mHeight
curSize
.
height
)
)
;
maxSize
.
width
=
std
:
:
max
(
maxSize
.
width
minSize
.
width
)
;
maxSize
.
height
=
std
:
:
max
(
maxSize
.
height
minSize
.
height
)
;
prefSize
.
width
=
CSSMinMax
(
prefSize
.
width
minSize
.
width
maxSize
.
width
)
;
prefSize
.
height
=
CSSMinMax
(
prefSize
.
height
minSize
.
height
maxSize
.
height
)
;
nsMargin
m
;
childBox
-
>
StyleMargin
(
)
-
>
GetMargin
(
m
)
;
ApplyMargin
(
curSize
m
)
;
ApplyMargin
(
minSize
m
)
;
ApplyMargin
(
maxSize
m
)
;
ApplyMargin
(
prefSize
m
)
;
auto
&
list
=
isBefore
?
mChildInfosBefore
:
mChildInfosAfter
;
nsSplitterInfo
&
info
=
*
list
.
AppendElement
(
)
;
info
.
childElem
=
content
;
info
.
min
=
isHorizontal
?
minSize
.
width
:
minSize
.
height
;
info
.
max
=
isHorizontal
?
maxSize
.
width
:
maxSize
.
height
;
info
.
pref
=
isHorizontal
?
prefSize
.
width
:
prefSize
.
height
;
info
.
current
=
info
.
changed
=
isHorizontal
?
curSize
.
width
:
curSize
.
height
;
}
if
(
!
foundOuter
)
{
return
NS_OK
;
}
mPressed
=
true
;
const
bool
reverseDirection
=
[
&
]
{
MOZ_ASSERT
(
mParentBox
-
>
IsFlexContainerFrame
(
)
)
;
const
FlexboxAxisInfo
info
(
mParentBox
)
;
if
(
!
info
.
mIsRowOriented
)
{
return
info
.
mIsMainAxisReversed
;
}
const
bool
rtl
=
mParentBox
-
>
StyleVisibility
(
)
-
>
mDirection
=
=
StyleDirection
:
:
Rtl
;
return
info
.
mIsMainAxisReversed
!
=
rtl
;
}
(
)
;
if
(
reverseDirection
)
{
mChildInfosBefore
.
Reverse
(
)
;
mChildInfosAfter
.
Reverse
(
)
;
std
:
:
swap
(
mChildInfosBefore
mChildInfosAfter
)
;
}
if
(
resizeBefore
!
=
ResizeType
:
:
Farthest
)
{
mChildInfosBefore
.
Reverse
(
)
;
}
if
(
resizeAfter
=
=
ResizeType
:
:
Farthest
)
{
mChildInfosAfter
.
Reverse
(
)
;
}
int32_t
c
;
nsPoint
pt
=
nsLayoutUtils
:
:
GetDOMEventCoordinatesRelativeTo
(
mouseEvent
mParentBox
)
;
if
(
isHorizontal
)
{
c
=
pt
.
x
;
mSplitterPos
=
mOuter
-
>
mRect
.
x
;
}
else
{
c
=
pt
.
y
;
mSplitterPos
=
mOuter
-
>
mRect
.
y
;
}
mDragStart
=
c
;
PresShell
:
:
SetCapturingContent
(
mOuter
-
>
GetContent
(
)
CaptureFlags
:
:
IgnoreAllowedState
)
;
return
NS_OK
;
}
nsresult
nsSplitterFrameInner
:
:
MouseMove
(
Event
*
aMouseEvent
)
{
NS_ENSURE_TRUE
(
mOuter
NS_OK
)
;
if
(
!
mPressed
)
{
return
NS_OK
;
}
if
(
mDragging
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIDOMEventListener
>
kungfuDeathGrip
(
this
)
;
mOuter
-
>
mContent
-
>
AsElement
(
)
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
state
u
"
dragging
"
_ns
true
)
;
RemoveListener
(
)
;
mDragging
=
true
;
return
NS_OK
;
}
bool
nsSplitterFrameInner
:
:
SupportsCollapseDirection
(
nsSplitterFrameInner
:
:
CollapseDirection
aDirection
)
{
static
Element
:
:
AttrValuesArray
strings
[
]
=
{
nsGkAtoms
:
:
before
nsGkAtoms
:
:
after
nsGkAtoms
:
:
both
nullptr
}
;
switch
(
SplitterElement
(
)
-
>
FindAttrValueIn
(
kNameSpaceID_None
nsGkAtoms
:
:
collapse
strings
eCaseMatters
)
)
{
case
0
:
return
(
aDirection
=
=
Before
)
;
case
1
:
return
(
aDirection
=
=
After
)
;
case
2
:
return
true
;
}
return
false
;
}
static
nsIFrame
*
SlowOrderAwareSibling
(
nsIFrame
*
aBox
bool
aNext
)
{
nsIFrame
*
parent
=
aBox
-
>
GetParent
(
)
;
if
(
!
parent
)
{
return
nullptr
;
}
CSSOrderAwareFrameIterator
iter
(
parent
FrameChildListID
:
:
Principal
CSSOrderAwareFrameIterator
:
:
ChildFilter
:
:
IncludeAll
CSSOrderAwareFrameIterator
:
:
OrderState
:
:
Unknown
CSSOrderAwareFrameIterator
:
:
OrderingProperty
:
:
Order
)
;
nsIFrame
*
prevSibling
=
nullptr
;
for
(
;
!
iter
.
AtEnd
(
)
;
iter
.
Next
(
)
)
{
nsIFrame
*
current
=
iter
.
get
(
)
;
if
(
!
aNext
&
&
current
=
=
aBox
)
{
return
prevSibling
;
}
if
(
aNext
&
&
prevSibling
=
=
aBox
)
{
return
current
;
}
prevSibling
=
current
;
}
return
nullptr
;
}
void
nsSplitterFrameInner
:
:
UpdateState
(
)
{
State
newState
=
GetState
(
)
;
if
(
newState
=
=
mState
)
{
return
;
}
if
(
(
SupportsCollapseDirection
(
Before
)
|
|
SupportsCollapseDirection
(
After
)
)
&
&
IsValidParentBox
(
mOuter
-
>
GetParent
(
)
)
)
{
const
bool
prev
=
newState
=
=
State
:
:
CollapsedBefore
|
|
mState
=
=
State
:
:
CollapsedBefore
;
nsIFrame
*
splitterSibling
=
SlowOrderAwareSibling
(
mOuter
!
prev
)
;
if
(
splitterSibling
)
{
nsCOMPtr
<
nsIContent
>
sibling
=
splitterSibling
-
>
GetContent
(
)
;
if
(
sibling
&
&
sibling
-
>
IsElement
(
)
)
{
if
(
mState
=
=
State
:
:
CollapsedBefore
|
|
mState
=
=
State
:
:
CollapsedAfter
)
{
nsContentUtils
:
:
AddScriptRunner
(
new
nsUnsetAttrRunnable
(
sibling
-
>
AsElement
(
)
nsGkAtoms
:
:
collapsed
)
)
;
}
else
if
(
(
mState
=
=
State
:
:
Open
|
|
mState
=
=
State
:
:
Dragging
)
&
&
(
newState
=
=
State
:
:
CollapsedBefore
|
|
newState
=
=
State
:
:
CollapsedAfter
)
)
{
nsContentUtils
:
:
AddScriptRunner
(
new
nsSetAttrRunnable
(
sibling
-
>
AsElement
(
)
nsGkAtoms
:
:
collapsed
u
"
true
"
_ns
)
)
;
}
}
}
}
mState
=
newState
;
}
void
nsSplitterFrameInner
:
:
EnsureOrient
(
)
{
mOuter
-
>
mIsHorizontal
=
SplitterIsHorizontal
(
mParentBox
)
;
}
void
nsSplitterFrameInner
:
:
AdjustChildren
(
nsPresContext
*
aPresContext
)
{
EnsureOrient
(
)
;
const
bool
isHorizontal
=
!
mOuter
-
>
IsHorizontal
(
)
;
AdjustChildren
(
aPresContext
mChildInfosBefore
isHorizontal
)
;
AdjustChildren
(
aPresContext
mChildInfosAfter
isHorizontal
)
;
}
static
nsIFrame
*
GetChildBoxForContent
(
nsIFrame
*
aParentBox
nsIContent
*
aContent
)
{
for
(
nsIFrame
*
f
:
aParentBox
-
>
PrincipalChildList
(
)
)
{
if
(
f
-
>
GetContent
(
)
=
=
aContent
)
{
return
f
;
}
}
return
nullptr
;
}
void
nsSplitterFrameInner
:
:
AdjustChildren
(
nsPresContext
*
aPresContext
nsTArray
<
nsSplitterInfo
>
&
aChildInfos
bool
aIsHorizontal
)
{
for
(
auto
&
info
:
aChildInfos
)
{
nscoord
newPref
=
info
.
pref
+
(
info
.
changed
-
info
.
current
)
;
if
(
nsIFrame
*
childBox
=
GetChildBoxForContent
(
mParentBox
info
.
childElem
)
)
{
SetPreferredSize
(
childBox
aIsHorizontal
newPref
)
;
}
}
}
void
nsSplitterFrameInner
:
:
SetPreferredSize
(
nsIFrame
*
aChildBox
bool
aIsHorizontal
nscoord
aSize
)
{
nsMargin
margin
;
aChildBox
-
>
StyleMargin
(
)
-
>
GetMargin
(
margin
)
;
if
(
aIsHorizontal
)
{
aSize
-
=
(
margin
.
left
+
margin
.
right
)
;
}
else
{
aSize
-
=
(
margin
.
top
+
margin
.
bottom
)
;
}
RefPtr
element
=
nsStyledElement
:
:
FromNode
(
aChildBox
-
>
GetContent
(
)
)
;
if
(
!
element
)
{
return
;
}
int32_t
pixels
=
aSize
/
AppUnitsPerCSSPixel
(
)
;
nsAutoString
attrValue
;
attrValue
.
AppendInt
(
pixels
)
;
element
-
>
SetAttr
(
aIsHorizontal
?
nsGkAtoms
:
:
width
:
nsGkAtoms
:
:
height
attrValue
IgnoreErrors
(
)
)
;
nsCOMPtr
<
nsICSSDeclaration
>
decl
=
element
-
>
Style
(
)
;
nsAutoCString
cssValue
;
cssValue
.
AppendInt
(
pixels
)
;
cssValue
.
AppendLiteral
(
"
px
"
)
;
decl
-
>
SetProperty
(
aIsHorizontal
?
"
width
"
_ns
:
"
height
"
_ns
cssValue
"
"
_ns
IgnoreErrors
(
)
)
;
}
void
nsSplitterFrameInner
:
:
AddRemoveSpace
(
nscoord
aDiff
nsTArray
<
nsSplitterInfo
>
&
aChildInfos
int32_t
&
aSpaceLeft
)
{
aSpaceLeft
=
0
;
for
(
auto
&
info
:
aChildInfos
)
{
nscoord
min
=
info
.
min
;
nscoord
max
=
info
.
max
;
nscoord
&
c
=
info
.
changed
;
if
(
c
+
aDiff
<
min
)
{
aDiff
+
=
(
c
-
min
)
;
c
=
min
;
}
else
if
(
c
+
aDiff
>
max
)
{
aDiff
-
=
(
max
-
c
)
;
c
=
max
;
}
else
{
c
+
=
aDiff
;
aDiff
=
0
;
}
if
(
aDiff
=
=
0
)
{
break
;
}
}
aSpaceLeft
=
aDiff
;
}
void
nsSplitterFrameInner
:
:
ResizeChildTo
(
nscoord
&
aDiff
)
{
nscoord
spaceLeft
=
0
;
if
(
!
mChildInfosBefore
.
IsEmpty
(
)
)
{
AddRemoveSpace
(
aDiff
mChildInfosBefore
spaceLeft
)
;
aDiff
-
=
spaceLeft
;
}
AddRemoveSpace
(
-
aDiff
mChildInfosAfter
spaceLeft
)
;
if
(
spaceLeft
!
=
0
&
&
!
mChildInfosAfter
.
IsEmpty
(
)
)
{
aDiff
+
=
spaceLeft
;
AddRemoveSpace
(
spaceLeft
mChildInfosBefore
spaceLeft
)
;
}
}
