#
include
"
nsTreeStyleCache
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
nsPresContextInlines
.
h
"
using
namespace
mozilla
;
nsTreeStyleCache
:
:
Transition
:
:
Transition
(
DFAState
aState
nsAtom
*
aSymbol
)
:
mState
(
aState
)
mInputSymbol
(
aSymbol
)
{
}
bool
nsTreeStyleCache
:
:
Transition
:
:
operator
=
=
(
const
Transition
&
aOther
)
const
{
return
aOther
.
mState
=
=
mState
&
&
aOther
.
mInputSymbol
=
=
mInputSymbol
;
}
uint32_t
nsTreeStyleCache
:
:
Transition
:
:
Hash
(
)
const
{
uint32_t
hb
=
mState
<
<
16
;
uint32_t
lb
=
(
NS_PTR_TO_UINT32
(
mInputSymbol
.
get
(
)
)
<
<
16
)
>
>
16
;
return
hb
+
lb
;
}
ComputedStyle
*
nsTreeStyleCache
:
:
GetComputedStyle
(
nsPresContext
*
aPresContext
nsIContent
*
aContent
ComputedStyle
*
aStyle
nsCSSAnonBoxPseudoStaticAtom
*
aPseudoElement
const
AtomArray
&
aInputWord
)
{
MOZ_ASSERT
(
nsCSSAnonBoxes
:
:
IsTreePseudoElement
(
aPseudoElement
)
)
;
uint32_t
count
=
aInputWord
.
Length
(
)
;
if
(
!
mTransitionTable
)
{
mTransitionTable
=
MakeUnique
<
TransitionTable
>
(
)
;
}
Transition
transition
(
0
aPseudoElement
)
;
DFAState
currState
=
mTransitionTable
-
>
Get
(
transition
)
;
if
(
!
currState
)
{
currState
=
mNextState
;
mNextState
+
+
;
mTransitionTable
-
>
InsertOrUpdate
(
transition
currState
)
;
}
for
(
uint32_t
i
=
0
;
i
<
count
;
i
+
+
)
{
Transition
transition
(
currState
aInputWord
[
i
]
)
;
currState
=
mTransitionTable
-
>
Get
(
transition
)
;
if
(
!
currState
)
{
currState
=
mNextState
;
mNextState
+
+
;
mTransitionTable
-
>
InsertOrUpdate
(
transition
currState
)
;
}
}
ComputedStyle
*
result
=
nullptr
;
if
(
mCache
)
{
result
=
mCache
-
>
GetWeak
(
currState
)
;
}
if
(
!
result
)
{
RefPtr
<
ComputedStyle
>
newResult
=
aPresContext
-
>
StyleSet
(
)
-
>
ResolveXULTreePseudoStyle
(
aContent
-
>
AsElement
(
)
aPseudoElement
aStyle
aInputWord
)
;
newResult
-
>
StartImageLoads
(
*
aPresContext
-
>
Document
(
)
)
;
MOZ_ASSERT
(
newResult
-
>
GetPseudoType
(
)
=
=
PseudoStyleType
:
:
XULTree
)
;
MOZ_ASSERT
(
!
newResult
-
>
IsAnonBox
(
)
)
;
MOZ_ASSERT
(
!
newResult
-
>
IsPseudoElement
(
)
)
;
if
(
!
mCache
)
{
mCache
=
MakeUnique
<
ComputedStyleCache
>
(
)
;
}
result
=
newResult
.
get
(
)
;
mCache
-
>
InsertOrUpdate
(
currState
std
:
:
move
(
newResult
)
)
;
}
return
result
;
}
