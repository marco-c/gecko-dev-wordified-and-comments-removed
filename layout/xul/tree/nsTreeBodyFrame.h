#
ifndef
nsTreeBodyFrame_h
#
define
nsTreeBodyFrame_h
#
include
"
mozilla
/
AtomArray
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
nsLeafBoxFrame
.
h
"
#
include
"
nsITreeView
.
h
"
#
include
"
nsIScrollbarMediator
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsIReflowCallback
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTreeStyleCache
.
h
"
#
include
"
nsTreeColumns
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
imgIRequest
.
h
"
#
include
"
imgINotificationObserver
.
h
"
#
include
"
nsScrollbarFrame
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
class
nsFontMetrics
;
class
nsOverflowChecker
;
class
nsTreeImageListener
;
namespace
mozilla
{
namespace
layout
{
class
ScrollbarActivity
;
}
}
struct
nsTreeImageCacheEntry
{
nsTreeImageCacheEntry
(
)
{
}
nsTreeImageCacheEntry
(
imgIRequest
*
aRequest
imgINotificationObserver
*
aListener
)
:
request
(
aRequest
)
listener
(
aListener
)
{
}
nsCOMPtr
<
imgIRequest
>
request
;
nsCOMPtr
<
imgINotificationObserver
>
listener
;
}
;
class
nsTreeBodyFrame
final
:
public
nsLeafBoxFrame
public
nsIScrollbarMediator
public
nsIReflowCallback
{
typedef
mozilla
:
:
layout
:
:
ScrollbarActivity
ScrollbarActivity
;
typedef
mozilla
:
:
image
:
:
ImgDrawResult
ImgDrawResult
;
public
:
explicit
nsTreeBodyFrame
(
ComputedStyle
*
aStyle
)
;
~
nsTreeBodyFrame
(
)
;
NS_DECL_QUERYFRAME
NS_DECL_FRAMEARENA_HELPERS
(
nsTreeBodyFrame
)
nsresult
OnImageIsAnimated
(
imgIRequest
*
aRequest
)
;
already_AddRefed
<
nsTreeColumns
>
Columns
(
)
const
{
RefPtr
<
nsTreeColumns
>
cols
=
mColumns
;
return
cols
.
forget
(
)
;
}
already_AddRefed
<
nsITreeView
>
GetExistingView
(
)
const
{
nsCOMPtr
<
nsITreeView
>
view
=
mView
;
return
view
.
forget
(
)
;
}
nsresult
GetView
(
nsITreeView
*
*
aView
)
;
nsresult
SetView
(
nsITreeView
*
aView
)
;
bool
GetFocused
(
)
const
{
return
mFocused
;
}
nsresult
SetFocused
(
bool
aFocused
)
;
nsresult
GetTreeBody
(
mozilla
:
:
dom
:
:
Element
*
*
aElement
)
;
int32_t
RowHeight
(
)
const
;
int32_t
RowWidth
(
)
;
int32_t
GetHorizontalPosition
(
)
const
;
nsresult
GetSelectionRegion
(
nsIScriptableRegion
*
*
aRegion
)
;
int32_t
FirstVisibleRow
(
)
const
{
return
mTopRowIndex
;
}
int32_t
LastVisibleRow
(
)
const
{
return
mTopRowIndex
+
mPageLength
;
}
int32_t
PageLength
(
)
const
{
return
mPageLength
;
}
nsresult
EnsureRowIsVisible
(
int32_t
aRow
)
;
nsresult
EnsureCellIsVisible
(
int32_t
aRow
nsTreeColumn
*
aCol
)
;
void
ScrollToRow
(
int32_t
aRow
)
;
void
ScrollByLines
(
int32_t
aNumLines
)
;
void
ScrollByPages
(
int32_t
aNumPages
)
;
nsresult
Invalidate
(
)
;
nsresult
InvalidateColumn
(
nsTreeColumn
*
aCol
)
;
nsresult
InvalidateRow
(
int32_t
aRow
)
;
nsresult
InvalidateCell
(
int32_t
aRow
nsTreeColumn
*
aCol
)
;
nsresult
InvalidateRange
(
int32_t
aStart
int32_t
aEnd
)
;
int32_t
GetRowAt
(
int32_t
aX
int32_t
aY
)
;
nsresult
GetCellAt
(
int32_t
aX
int32_t
aY
int32_t
*
aRow
nsTreeColumn
*
*
aCol
nsACString
&
aChildElt
)
;
nsresult
GetCoordsForCellItem
(
int32_t
aRow
nsTreeColumn
*
aCol
const
nsACString
&
aElt
int32_t
*
aX
int32_t
*
aY
int32_t
*
aWidth
int32_t
*
aHeight
)
;
nsresult
IsCellCropped
(
int32_t
aRow
nsTreeColumn
*
aCol
bool
*
aResult
)
;
nsresult
RowCountChanged
(
int32_t
aIndex
int32_t
aCount
)
;
nsresult
BeginUpdateBatch
(
)
;
nsresult
EndUpdateBatch
(
)
;
nsresult
ClearStyleAndImageCaches
(
)
;
void
RemoveImageCacheEntry
(
int32_t
aRowIndex
nsTreeColumn
*
aCol
)
;
void
CancelImageRequests
(
)
;
void
ManageReflowCallback
(
const
nsRect
&
aRect
nscoord
aHorzWidth
)
;
virtual
nsSize
GetXULMinSize
(
nsBoxLayoutState
&
aBoxLayoutState
)
override
;
virtual
void
SetXULBounds
(
nsBoxLayoutState
&
aBoxLayoutState
const
nsRect
&
aRect
bool
aRemoveOverflowArea
=
false
)
override
;
virtual
bool
ReflowFinished
(
)
override
;
virtual
void
ReflowCallbackCanceled
(
)
override
;
virtual
void
ScrollByPage
(
nsScrollbarFrame
*
aScrollbar
int32_t
aDirection
nsIScrollbarMediator
:
:
ScrollSnapMode
aSnap
=
nsIScrollbarMediator
:
:
DISABLE_SNAP
)
override
;
virtual
void
ScrollByWhole
(
nsScrollbarFrame
*
aScrollbar
int32_t
aDirection
nsIScrollbarMediator
:
:
ScrollSnapMode
aSnap
=
nsIScrollbarMediator
:
:
DISABLE_SNAP
)
override
;
virtual
void
ScrollByLine
(
nsScrollbarFrame
*
aScrollbar
int32_t
aDirection
nsIScrollbarMediator
:
:
ScrollSnapMode
aSnap
=
nsIScrollbarMediator
:
:
DISABLE_SNAP
)
override
;
virtual
void
RepeatButtonScroll
(
nsScrollbarFrame
*
aScrollbar
)
override
;
virtual
void
ThumbMoved
(
nsScrollbarFrame
*
aScrollbar
nscoord
aOldPos
nscoord
aNewPos
)
override
;
virtual
void
ScrollbarReleased
(
nsScrollbarFrame
*
aScrollbar
)
override
{
}
virtual
void
VisibilityChanged
(
bool
aVisible
)
override
{
Invalidate
(
)
;
}
virtual
nsIFrame
*
GetScrollbarBox
(
bool
aVertical
)
override
{
ScrollParts
parts
=
GetScrollParts
(
)
;
return
aVertical
?
parts
.
mVScrollbar
:
parts
.
mHScrollbar
;
}
virtual
void
ScrollbarActivityStarted
(
)
const
override
;
virtual
void
ScrollbarActivityStopped
(
)
const
override
;
virtual
bool
IsScrollbarOnRight
(
)
const
override
{
return
(
StyleVisibility
(
)
-
>
mDirection
=
=
NS_STYLE_DIRECTION_LTR
)
;
}
virtual
bool
ShouldSuppressScrollbarRepaints
(
)
const
override
{
return
false
;
}
virtual
void
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
override
;
virtual
void
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
override
;
virtual
nsresult
GetCursor
(
const
nsPoint
&
aPoint
nsIFrame
:
:
Cursor
&
aCursor
)
override
;
virtual
nsresult
HandleEvent
(
nsPresContext
*
aPresContext
mozilla
:
:
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
override
;
virtual
void
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
override
;
virtual
void
DidSetComputedStyle
(
ComputedStyle
*
aOldComputedStyle
)
override
;
friend
nsIFrame
*
NS_NewTreeBodyFrame
(
nsIPresShell
*
aPresShell
)
;
friend
class
nsTreeColumn
;
struct
ScrollParts
{
nsScrollbarFrame
*
mVScrollbar
;
RefPtr
<
Element
>
mVScrollbarContent
;
nsScrollbarFrame
*
mHScrollbar
;
RefPtr
<
Element
>
mHScrollbarContent
;
nsIFrame
*
mColumnsFrame
;
nsIScrollableFrame
*
mColumnsScrollFrame
;
}
;
ImgDrawResult
PaintTreeBody
(
gfxContext
&
aRenderingContext
const
nsRect
&
aDirtyRect
nsPoint
aPt
nsDisplayListBuilder
*
aBuilder
)
;
nsITreeBoxObject
*
GetTreeBoxObject
(
)
const
{
return
mTreeBoxObject
;
}
mozilla
:
:
dom
:
:
Element
*
GetBaseElement
(
)
;
bool
GetVerticalOverflow
(
)
const
{
return
mVerticalOverflow
;
}
bool
GetHorizontalOverflow
(
)
const
{
return
mHorizontalOverflow
;
}
const
mozilla
:
:
AtomArray
&
GetPropertyArrayForCurrentDrawingItem
(
)
{
return
mScratchArray
;
}
protected
:
friend
class
nsOverflowChecker
;
ImgDrawResult
PaintColumn
(
nsTreeColumn
*
aColumn
const
nsRect
&
aColumnRect
nsPresContext
*
aPresContext
gfxContext
&
aRenderingContext
const
nsRect
&
aDirtyRect
)
;
ImgDrawResult
PaintRow
(
int32_t
aRowIndex
const
nsRect
&
aRowRect
nsPresContext
*
aPresContext
gfxContext
&
aRenderingContext
const
nsRect
&
aDirtyRect
nsPoint
aPt
nsDisplayListBuilder
*
aBuilder
)
;
ImgDrawResult
PaintSeparator
(
int32_t
aRowIndex
const
nsRect
&
aSeparatorRect
nsPresContext
*
aPresContext
gfxContext
&
aRenderingContext
const
nsRect
&
aDirtyRect
)
;
ImgDrawResult
PaintCell
(
int32_t
aRowIndex
nsTreeColumn
*
aColumn
const
nsRect
&
aCellRect
nsPresContext
*
aPresContext
gfxContext
&
aRenderingContext
const
nsRect
&
aDirtyRect
nscoord
&
aCurrX
nsPoint
aPt
nsDisplayListBuilder
*
aBuilder
)
;
ImgDrawResult
PaintTwisty
(
int32_t
aRowIndex
nsTreeColumn
*
aColumn
const
nsRect
&
aTwistyRect
nsPresContext
*
aPresContext
gfxContext
&
aRenderingContext
const
nsRect
&
aDirtyRect
nscoord
&
aRemainingWidth
nscoord
&
aCurrX
)
;
ImgDrawResult
PaintImage
(
int32_t
aRowIndex
nsTreeColumn
*
aColumn
const
nsRect
&
aImageRect
nsPresContext
*
aPresContext
gfxContext
&
aRenderingContext
const
nsRect
&
aDirtyRect
nscoord
&
aRemainingWidth
nscoord
&
aCurrX
nsDisplayListBuilder
*
aBuilder
)
;
ImgDrawResult
PaintText
(
int32_t
aRowIndex
nsTreeColumn
*
aColumn
const
nsRect
&
aTextRect
nsPresContext
*
aPresContext
gfxContext
&
aRenderingContext
const
nsRect
&
aDirtyRect
nscoord
&
aCurrX
)
;
ImgDrawResult
PaintCheckbox
(
int32_t
aRowIndex
nsTreeColumn
*
aColumn
const
nsRect
&
aCheckboxRect
nsPresContext
*
aPresContext
gfxContext
&
aRenderingContext
const
nsRect
&
aDirtyRect
)
;
ImgDrawResult
PaintDropFeedback
(
const
nsRect
&
aDropFeedbackRect
nsPresContext
*
aPresContext
gfxContext
&
aRenderingContext
const
nsRect
&
aDirtyRect
nsPoint
aPt
)
;
ImgDrawResult
PaintBackgroundLayer
(
ComputedStyle
*
aComputedStyle
nsPresContext
*
aPresContext
gfxContext
&
aRenderingContext
const
nsRect
&
aRect
const
nsRect
&
aDirtyRect
)
;
int32_t
GetRowAtInternal
(
nscoord
aX
nscoord
aY
)
;
void
CheckTextForBidi
(
nsAutoString
&
aText
)
;
void
AdjustForCellText
(
nsAutoString
&
aText
int32_t
aRowIndex
nsTreeColumn
*
aColumn
gfxContext
&
aRenderingContext
nsFontMetrics
&
aFontMetrics
nsRect
&
aTextRect
)
;
nsICSSAnonBoxPseudo
*
GetItemWithinCellAt
(
nscoord
aX
const
nsRect
&
aCellRect
int32_t
aRowIndex
nsTreeColumn
*
aColumn
)
;
void
GetCellAt
(
nscoord
aX
nscoord
aY
int32_t
*
aRow
nsTreeColumn
*
*
aCol
nsICSSAnonBoxPseudo
*
*
aChildElt
)
;
nsITheme
*
GetTwistyRect
(
int32_t
aRowIndex
nsTreeColumn
*
aColumn
nsRect
&
aImageRect
nsRect
&
aTwistyRect
nsPresContext
*
aPresContext
ComputedStyle
*
aTwistyContext
)
;
nsresult
GetImage
(
int32_t
aRowIndex
nsTreeColumn
*
aCol
bool
aUseContext
ComputedStyle
*
aComputedStyle
bool
&
aAllowImageRegions
imgIContainer
*
*
aResult
)
;
nsRect
GetImageSize
(
int32_t
aRowIndex
nsTreeColumn
*
aCol
bool
aUseContext
ComputedStyle
*
aComputedStyle
)
;
nsSize
GetImageDestSize
(
ComputedStyle
*
aComputedStyle
bool
useImageRegion
imgIContainer
*
image
)
;
nsRect
GetImageSourceRect
(
ComputedStyle
*
aComputedStyle
bool
useImageRegion
imgIContainer
*
image
)
;
int32_t
GetRowHeight
(
)
;
int32_t
GetIndentation
(
)
;
void
CalcInnerBox
(
)
;
nscoord
CalcHorzWidth
(
const
ScrollParts
&
aParts
)
;
ComputedStyle
*
GetPseudoComputedStyle
(
nsICSSAnonBoxPseudo
*
aPseudoElement
)
;
ScrollParts
GetScrollParts
(
)
;
void
UpdateScrollbars
(
const
ScrollParts
&
aParts
)
;
void
InvalidateScrollbars
(
const
ScrollParts
&
aParts
AutoWeakFrame
&
aWeakColumnsFrame
)
;
void
CheckOverflow
(
const
ScrollParts
&
aParts
)
;
bool
FullScrollbarsUpdate
(
bool
aNeedsFullInvalidation
)
;
void
PrefillPropertyArray
(
int32_t
aRowIndex
nsTreeColumn
*
aCol
)
;
nsresult
ScrollInternal
(
const
ScrollParts
&
aParts
int32_t
aRow
)
;
nsresult
ScrollToRowInternal
(
const
ScrollParts
&
aParts
int32_t
aRow
)
;
nsresult
ScrollHorzInternal
(
const
ScrollParts
&
aParts
int32_t
aPosition
)
;
nsresult
EnsureRowIsVisibleInternal
(
const
ScrollParts
&
aParts
int32_t
aRow
)
;
nsPoint
AdjustClientCoordsToBoxCoordSpace
(
int32_t
aX
int32_t
aY
)
;
void
EnsureBoxObject
(
)
;
void
EnsureView
(
)
;
nsresult
GetCellWidth
(
int32_t
aRow
nsTreeColumn
*
aCol
gfxContext
*
aRenderingContext
nscoord
&
aDesiredSize
nscoord
&
aCurrentSize
)
;
nscoord
CalcMaxRowWidth
(
)
;
bool
OffsetForHorzScroll
(
nsRect
&
rect
bool
clip
)
;
bool
CanAutoScroll
(
int32_t
aRowIndex
)
;
void
ComputeDropPosition
(
mozilla
:
:
WidgetGUIEvent
*
aEvent
int32_t
*
aRow
int16_t
*
aOrient
int16_t
*
aScrollLines
)
;
void
InvalidateDropFeedback
(
int32_t
aRow
int16_t
aOrientation
)
{
InvalidateRow
(
aRow
)
;
if
(
aOrientation
!
=
nsITreeView
:
:
DROP_ON
)
InvalidateRow
(
aRow
+
aOrientation
)
;
}
public
:
void
RemoveTreeImageListener
(
nsTreeImageListener
*
aListener
)
;
protected
:
nsresult
CreateTimer
(
const
mozilla
:
:
LookAndFeel
:
:
IntID
aID
nsTimerCallbackFunc
aFunc
int32_t
aType
nsITimer
*
*
aTimer
const
char
*
aName
)
;
static
void
OpenCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
;
static
void
CloseCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
;
static
void
LazyScrollCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
;
static
void
ScrollCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
;
class
ScrollEvent
:
public
mozilla
:
:
Runnable
{
public
:
NS_DECL_NSIRUNNABLE
explicit
ScrollEvent
(
nsTreeBodyFrame
*
aInner
)
:
mozilla
:
:
Runnable
(
"
nsTreeBodyFrame
:
:
ScrollEvent
"
)
mInner
(
aInner
)
{
}
void
Revoke
(
)
{
mInner
=
nullptr
;
}
private
:
nsTreeBodyFrame
*
mInner
;
}
;
void
PostScrollEvent
(
)
;
void
FireScrollEvent
(
)
;
void
DetachImageListeners
(
)
;
#
ifdef
ACCESSIBILITY
void
FireRowCountChangedEvent
(
int32_t
aIndex
int32_t
aCount
)
;
void
FireInvalidateEvent
(
int32_t
aStartRow
int32_t
aEndRow
nsTreeColumn
*
aStartCol
nsTreeColumn
*
aEndCol
)
;
#
endif
protected
:
class
Slots
{
public
:
Slots
(
)
:
mDropAllowed
(
false
)
mIsDragging
(
false
)
mDropRow
(
-
1
)
mDropOrient
(
-
1
)
mScrollLines
(
0
)
mDragAction
(
0
)
{
}
~
Slots
(
)
{
if
(
mTimer
)
mTimer
-
>
Cancel
(
)
;
}
friend
class
nsTreeBodyFrame
;
protected
:
bool
mDropAllowed
;
bool
mIsDragging
;
int32_t
mDropRow
;
int16_t
mDropOrient
;
int16_t
mScrollLines
;
uint32_t
mDragAction
;
nsCOMPtr
<
nsITimer
>
mTimer
;
nsTArray
<
int32_t
>
mArray
;
}
;
Slots
*
mSlots
;
nsRevocableEventPtr
<
ScrollEvent
>
mScrollEvent
;
RefPtr
<
ScrollbarActivity
>
mScrollbarActivity
;
nsCOMPtr
<
nsITreeBoxObject
>
mTreeBoxObject
;
RefPtr
<
nsTreeColumns
>
mColumns
;
nsCOMPtr
<
nsITreeView
>
mView
;
nsTreeStyleCache
mStyleCache
;
nsDataHashtable
<
nsStringHashKey
nsTreeImageCacheEntry
>
mImageCache
;
mozilla
:
:
AtomArray
mScratchArray
;
int32_t
mTopRowIndex
;
int32_t
mPageLength
;
nscoord
mHorzPosition
;
nscoord
mOriginalHorzWidth
;
nscoord
mHorzWidth
;
nscoord
mAdjustWidth
;
nsRect
mInnerBox
;
int32_t
mRowHeight
;
int32_t
mIndentation
;
nscoord
mStringWidth
;
int32_t
mUpdateBatchNest
;
int32_t
mRowCount
;
int32_t
mMouseOverRow
;
bool
mFocused
;
bool
mHasFixedRowCount
;
bool
mVerticalOverflow
;
bool
mHorizontalOverflow
;
bool
mReflowCallbackPosted
;
bool
mCheckingOverflow
;
nsTHashtable
<
nsPtrHashKey
<
nsTreeImageListener
>
>
mCreatedListeners
;
}
;
#
endif
