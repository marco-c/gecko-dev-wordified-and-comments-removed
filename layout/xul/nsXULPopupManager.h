#
ifndef
nsXULPopupManager_h__
#
define
nsXULPopupManager_h__
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
widget
/
InitData
.
h
"
#
include
"
nsHashtablesFwd
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIRollupListener
.
h
"
#
include
"
nsIDOMEventListener
.
h
"
#
include
"
nsPoint
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsIReflowCallback
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
widget
/
NativeMenu
.
h
"
#
include
"
Units
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
ifdef
KeyPress
#
undef
KeyPress
#
endif
class
nsContainerFrame
;
class
nsMenuPopupFrame
;
class
nsMenuBarFrame
;
class
nsIDocShellTreeItem
;
class
nsPIDOMWindowOuter
;
class
nsRefreshDriver
;
namespace
mozilla
{
class
PresShell
;
namespace
dom
{
class
Event
;
class
KeyboardEvent
;
class
UIEvent
;
class
XULButtonElement
;
}
}
enum
nsPopupState
{
ePopupClosed
ePopupShowing
ePopupPositioning
ePopupOpening
ePopupVisible
ePopupShown
ePopupHiding
ePopupInvisible
}
;
enum
CloseMenuMode
{
CloseMenuMode_Auto
CloseMenuMode_None
CloseMenuMode_Single
}
;
enum
nsNavigationDirection
{
eNavigationDirection_Last
eNavigationDirection_First
eNavigationDirection_Start
eNavigationDirection_Before
eNavigationDirection_End
eNavigationDirection_After
}
;
enum
nsIgnoreKeys
{
eIgnoreKeys_False
eIgnoreKeys_True
eIgnoreKeys_Shortcuts
}
;
enum
class
HidePopupOption
:
uint8_t
{
HideChain
DeselectMenu
Async
IsRollup
}
;
using
HidePopupOptions
=
mozilla
:
:
EnumSet
<
HidePopupOption
>
;
#
define
NS_DIRECTION_IS_INLINE
(
dir
)
\
(
dir
=
=
eNavigationDirection_Start
|
|
dir
=
=
eNavigationDirection_End
)
#
define
NS_DIRECTION_IS_BLOCK
(
dir
)
\
(
dir
=
=
eNavigationDirection_Before
|
|
dir
=
=
eNavigationDirection_After
)
#
define
NS_DIRECTION_IS_BLOCK_TO_EDGE
(
dir
)
\
(
dir
=
=
eNavigationDirection_First
|
|
dir
=
=
eNavigationDirection_Last
)
static_assert
(
static_cast
<
uint8_t
>
(
mozilla
:
:
StyleDirection
:
:
Ltr
)
=
=
0
&
&
static_cast
<
uint8_t
>
(
mozilla
:
:
StyleDirection
:
:
Rtl
)
=
=
1
"
Left
to
Right
should
be
0
and
Right
to
Left
should
be
1
"
)
;
extern
const
nsNavigationDirection
DirectionFromKeyCodeTable
[
2
]
[
6
]
;
#
define
NS_DIRECTION_FROM_KEY_CODE
(
frame
keycode
)
\
(
DirectionFromKeyCodeTable
[
static_cast
<
uint8_t
>
(
\
(
frame
)
-
>
StyleVisibility
(
)
-
>
mDirection
)
]
[
(
\
keycode
)
-
mozilla
:
:
dom
:
:
KeyboardEvent_Binding
:
:
DOM_VK_END
]
)
struct
PendingPopup
{
PendingPopup
(
nsIContent
*
aPopup
mozilla
:
:
dom
:
:
Event
*
aEvent
)
;
const
RefPtr
<
nsIContent
>
mPopup
;
const
RefPtr
<
mozilla
:
:
dom
:
:
Event
>
mEvent
;
mozilla
:
:
LayoutDeviceIntPoint
mMousePoint
;
mozilla
:
:
Modifiers
mModifiers
;
already_AddRefed
<
nsIContent
>
GetTriggerContent
(
)
const
;
void
InitMousePoint
(
)
;
void
SetMousePoint
(
mozilla
:
:
LayoutDeviceIntPoint
aMousePoint
)
{
mMousePoint
=
aMousePoint
;
}
uint16_t
MouseInputSource
(
)
const
;
}
;
class
nsMenuChainItem
{
using
PopupType
=
mozilla
:
:
widget
:
:
PopupType
;
nsMenuPopupFrame
*
mFrame
;
PopupType
mPopupType
;
bool
mNoAutoHide
;
bool
mIsContext
;
bool
mOnMenuBar
;
nsIgnoreKeys
mIgnoreKeys
;
bool
mFollowAnchor
;
nsRect
mCurrentRect
;
mozilla
:
:
UniquePtr
<
nsMenuChainItem
>
mParent
;
nsMenuChainItem
*
mChild
=
nullptr
;
public
:
nsMenuChainItem
(
nsMenuPopupFrame
*
aFrame
bool
aNoAutoHide
bool
aIsContext
PopupType
aPopupType
)
:
mFrame
(
aFrame
)
mPopupType
(
aPopupType
)
mNoAutoHide
(
aNoAutoHide
)
mIsContext
(
aIsContext
)
mOnMenuBar
(
false
)
mIgnoreKeys
(
eIgnoreKeys_False
)
mFollowAnchor
(
false
)
{
NS_ASSERTION
(
aFrame
"
null
frame
passed
to
nsMenuChainItem
constructor
"
)
;
MOZ_COUNT_CTOR
(
nsMenuChainItem
)
;
}
MOZ_COUNTED_DTOR
(
nsMenuChainItem
)
nsIContent
*
Content
(
)
;
nsMenuPopupFrame
*
Frame
(
)
{
return
mFrame
;
}
PopupType
GetPopupType
(
)
{
return
mPopupType
;
}
bool
IsNoAutoHide
(
)
{
return
mNoAutoHide
;
}
void
SetNoAutoHide
(
bool
aNoAutoHide
)
{
mNoAutoHide
=
aNoAutoHide
;
}
bool
IsMenu
(
)
{
return
mPopupType
=
=
PopupType
:
:
Menu
;
}
bool
IsContextMenu
(
)
{
return
mIsContext
;
}
nsIgnoreKeys
IgnoreKeys
(
)
{
return
mIgnoreKeys
;
}
void
SetIgnoreKeys
(
nsIgnoreKeys
aIgnoreKeys
)
{
mIgnoreKeys
=
aIgnoreKeys
;
}
bool
IsOnMenuBar
(
)
{
return
mOnMenuBar
;
}
void
SetOnMenuBar
(
bool
aOnMenuBar
)
{
mOnMenuBar
=
aOnMenuBar
;
}
nsMenuChainItem
*
GetParent
(
)
{
return
mParent
.
get
(
)
;
}
nsMenuChainItem
*
GetChild
(
)
{
return
mChild
;
}
bool
FollowsAnchor
(
)
{
return
mFollowAnchor
;
}
void
UpdateFollowAnchor
(
)
;
void
CheckForAnchorChange
(
)
;
void
SetParent
(
mozilla
:
:
UniquePtr
<
nsMenuChainItem
>
aParent
)
;
mozilla
:
:
UniquePtr
<
nsMenuChainItem
>
Detach
(
)
;
}
;
class
nsXULPopupHidingEvent
:
public
mozilla
:
:
Runnable
{
using
PopupType
=
mozilla
:
:
widget
:
:
PopupType
;
public
:
nsXULPopupHidingEvent
(
nsIContent
*
aPopup
nsIContent
*
aNextPopup
nsIContent
*
aLastPopup
PopupType
aPopupType
HidePopupOptions
aOptions
)
:
mozilla
:
:
Runnable
(
"
nsXULPopupHidingEvent
"
)
mPopup
(
aPopup
)
mNextPopup
(
aNextPopup
)
mLastPopup
(
aLastPopup
)
mPopupType
(
aPopupType
)
mOptions
(
aOptions
)
{
NS_ASSERTION
(
aPopup
"
null
popup
supplied
to
nsXULPopupHidingEvent
constructor
"
)
;
}
NS_IMETHOD
Run
(
)
override
;
private
:
nsCOMPtr
<
nsIContent
>
mPopup
;
nsCOMPtr
<
nsIContent
>
mNextPopup
;
nsCOMPtr
<
nsIContent
>
mLastPopup
;
PopupType
mPopupType
;
HidePopupOptions
mOptions
;
}
;
class
nsXULPopupPositionedEvent
:
public
mozilla
:
:
Runnable
{
public
:
explicit
nsXULPopupPositionedEvent
(
nsIContent
*
aPopup
)
:
mozilla
:
:
Runnable
(
"
nsXULPopupPositionedEvent
"
)
mPopup
(
aPopup
)
{
MOZ_ASSERT
(
aPopup
)
;
}
NS_IMETHOD
Run
(
)
override
;
static
bool
DispatchIfNeeded
(
nsIContent
*
aPopup
)
;
private
:
const
nsCOMPtr
<
nsIContent
>
mPopup
;
}
;
class
nsXULMenuCommandEvent
:
public
mozilla
:
:
Runnable
{
public
:
nsXULMenuCommandEvent
(
mozilla
:
:
dom
:
:
Element
*
aMenu
bool
aIsTrusted
mozilla
:
:
Modifiers
aModifiers
bool
aUserInput
bool
aFlipChecked
int16_t
aButton
)
:
mozilla
:
:
Runnable
(
"
nsXULMenuCommandEvent
"
)
mMenu
(
aMenu
)
mModifiers
(
aModifiers
)
mButton
(
aButton
)
mIsTrusted
(
aIsTrusted
)
mUserInput
(
aUserInput
)
mFlipChecked
(
aFlipChecked
)
mCloseMenuMode
(
CloseMenuMode_Auto
)
{
NS_ASSERTION
(
aMenu
"
null
menu
supplied
to
nsXULMenuCommandEvent
constructor
"
)
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
NS_IMETHOD
Run
(
)
override
;
void
SetCloseMenuMode
(
CloseMenuMode
aCloseMenuMode
)
{
mCloseMenuMode
=
aCloseMenuMode
;
}
private
:
RefPtr
<
mozilla
:
:
dom
:
:
Element
>
mMenu
;
mozilla
:
:
Modifiers
mModifiers
;
int16_t
mButton
;
bool
mIsTrusted
;
bool
mUserInput
;
bool
mFlipChecked
;
CloseMenuMode
mCloseMenuMode
;
}
;
class
nsXULPopupManager
final
:
public
nsIDOMEventListener
public
nsIRollupListener
public
nsIObserver
public
mozilla
:
:
widget
:
:
NativeMenu
:
:
Observer
{
public
:
friend
class
nsXULPopupHidingEvent
;
friend
class
nsXULPopupPositionedEvent
;
friend
class
nsXULMenuCommandEvent
;
friend
class
TransitionEnder
;
using
PopupType
=
mozilla
:
:
widget
:
:
PopupType
;
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
NS_DECL_NSIDOMEVENTLISTENER
MOZ_CAN_RUN_SCRIPT_BOUNDARY
bool
Rollup
(
const
RollupOptions
&
nsIContent
*
*
aLastRolledUp
=
nullptr
)
override
;
bool
ShouldRollupOnMouseWheelEvent
(
)
override
;
bool
ShouldConsumeOnMouseWheelEvent
(
)
override
;
bool
ShouldRollupOnMouseActivate
(
)
override
;
uint32_t
GetSubmenuWidgetChain
(
nsTArray
<
nsIWidget
*
>
*
aWidgetChain
)
override
;
nsIWidget
*
GetRollupWidget
(
)
override
;
bool
RollupNativeMenu
(
)
override
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
bool
RollupTooltips
(
)
;
enum
class
RollupKind
{
Tooltip
Menu
}
;
MOZ_CAN_RUN_SCRIPT
bool
RollupInternal
(
RollupKind
const
RollupOptions
&
nsIContent
*
*
aLastRolledUp
)
;
void
OnNativeMenuOpened
(
)
override
;
void
OnNativeMenuClosed
(
)
override
;
void
OnNativeSubMenuWillOpen
(
mozilla
:
:
dom
:
:
Element
*
aPopupElement
)
override
;
void
OnNativeSubMenuDidOpen
(
mozilla
:
:
dom
:
:
Element
*
aPopupElement
)
override
;
void
OnNativeSubMenuClosed
(
mozilla
:
:
dom
:
:
Element
*
aPopupElement
)
override
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
OnNativeMenuWillActivateItem
(
mozilla
:
:
dom
:
:
Element
*
aMenuItemElement
)
override
;
static
nsXULPopupManager
*
sInstance
;
static
nsresult
Init
(
)
;
static
void
Shutdown
(
)
;
static
nsXULPopupManager
*
GetInstance
(
)
;
void
AdjustPopupsOnWindowChange
(
nsPIDOMWindowOuter
*
aWindow
)
;
void
AdjustPopupsOnWindowChange
(
mozilla
:
:
PresShell
*
aPresShell
)
;
void
SetActiveMenuBar
(
nsMenuBarFrame
*
aMenuBar
bool
aActivate
)
;
struct
MayShowMenuResult
{
const
bool
mIsNative
=
false
;
mozilla
:
:
dom
:
:
XULButtonElement
*
const
mMenuButton
=
nullptr
;
nsMenuPopupFrame
*
const
mMenuPopupFrame
=
nullptr
;
explicit
operator
bool
(
)
const
{
MOZ_ASSERT
(
!
!
mMenuButton
=
=
!
!
mMenuPopupFrame
)
;
return
mIsNative
|
|
mMenuButton
;
}
}
;
MayShowMenuResult
MayShowMenu
(
nsIContent
*
aMenu
)
;
void
ShowMenu
(
nsIContent
*
aMenu
bool
aSelectFirstItem
)
;
void
ShowPopup
(
nsIContent
*
aPopup
nsIContent
*
aAnchorContent
const
nsAString
&
aPosition
int32_t
aXPos
int32_t
aYPos
bool
aIsContextMenu
bool
aAttributesOverride
bool
aSelectFirstItem
mozilla
:
:
dom
:
:
Event
*
aTriggerEvent
)
;
void
ShowPopupAtScreen
(
nsIContent
*
aPopup
int32_t
aXPos
int32_t
aYPos
bool
aIsContextMenu
mozilla
:
:
dom
:
:
Event
*
aTriggerEvent
)
;
void
ShowPopupAtScreenRect
(
nsIContent
*
aPopup
const
nsAString
&
aPosition
const
nsIntRect
&
aRect
bool
aIsContextMenu
bool
aAttributesOverride
mozilla
:
:
dom
:
:
Event
*
aTriggerEvent
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
bool
ShowPopupAsNativeMenu
(
nsIContent
*
aPopup
int32_t
aXPos
int32_t
aYPos
bool
aIsContextMenu
mozilla
:
:
dom
:
:
Event
*
aTriggerEvent
)
;
void
ShowTooltipAtScreen
(
nsIContent
*
aPopup
nsIContent
*
aTriggerContent
const
mozilla
:
:
LayoutDeviceIntPoint
&
)
;
void
HidePopup
(
nsIContent
*
aPopup
HidePopupOptions
nsIContent
*
aLastPopup
=
nullptr
)
;
void
HideMenu
(
nsIContent
*
aMenu
)
;
void
HidePopupAfterDelay
(
nsMenuPopupFrame
*
aPopup
int32_t
aDelay
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
HidePopupsInDocShell
(
nsIDocShellTreeItem
*
aDocShellToHide
)
;
void
UpdatePopupPositions
(
nsRefreshDriver
*
aRefreshDriver
)
;
void
UpdateFollowAnchor
(
nsMenuPopupFrame
*
aPopup
)
;
MOZ_CAN_RUN_SCRIPT
void
ExecuteMenu
(
nsIContent
*
aMenu
nsXULMenuCommandEvent
*
aEvent
)
;
bool
ActivateNativeMenuItem
(
nsIContent
*
aItem
mozilla
:
:
Modifiers
aModifiers
int16_t
aButton
mozilla
:
:
ErrorResult
&
aRv
)
;
bool
IsPopupOpen
(
nsIContent
*
aPopup
)
;
nsIFrame
*
GetTopPopup
(
PopupType
aType
)
;
nsIContent
*
GetTopActiveMenuItemContent
(
)
;
void
GetVisiblePopups
(
nsTArray
<
nsIFrame
*
>
&
aPopups
)
;
already_AddRefed
<
nsINode
>
GetLastTriggerPopupNode
(
mozilla
:
:
dom
:
:
Document
*
aDocument
)
{
return
GetLastTriggerNode
(
aDocument
false
)
;
}
already_AddRefed
<
nsINode
>
GetLastTriggerTooltipNode
(
mozilla
:
:
dom
:
:
Document
*
aDocument
)
{
return
GetLastTriggerNode
(
aDocument
true
)
;
}
bool
MayShowPopup
(
nsMenuPopupFrame
*
aFrame
)
;
void
PopupMoved
(
nsIFrame
*
aFrame
const
mozilla
:
:
LayoutDeviceIntPoint
&
aPoint
bool
aByMoveToRect
)
;
void
PopupResized
(
nsIFrame
*
aFrame
const
mozilla
:
:
LayoutDeviceIntSize
&
aSize
)
;
MOZ_CAN_RUN_SCRIPT
void
PopupDestroyed
(
nsMenuPopupFrame
*
aFrame
)
;
bool
HasContextMenu
(
nsMenuPopupFrame
*
aPopup
)
;
void
UpdateMenuItems
(
nsIContent
*
aPopup
)
;
void
KillMenuTimer
(
)
;
void
CancelMenuTimer
(
nsMenuPopupFrame
*
)
;
MOZ_CAN_RUN_SCRIPT
bool
HandleShortcutNavigation
(
mozilla
:
:
dom
:
:
KeyboardEvent
&
aKeyEvent
nsMenuPopupFrame
*
aFrame
)
;
MOZ_CAN_RUN_SCRIPT
bool
HandleKeyboardNavigation
(
uint32_t
aKeyCode
)
;
MOZ_CAN_RUN_SCRIPT
bool
HandleKeyboardNavigationInPopup
(
nsMenuPopupFrame
*
aFrame
nsNavigationDirection
aDir
)
{
return
HandleKeyboardNavigationInPopup
(
nullptr
aFrame
aDir
)
;
}
MOZ_CAN_RUN_SCRIPT
bool
HandleKeyboardEventWithKeyCode
(
mozilla
:
:
dom
:
:
KeyboardEvent
*
aKeyEvent
nsMenuChainItem
*
aTopVisibleMenuItem
)
;
nsresult
UpdateIgnoreKeys
(
bool
aIgnoreKeys
)
;
nsPopupState
GetPopupState
(
mozilla
:
:
dom
:
:
Element
*
aPopupElement
)
;
mozilla
:
:
dom
:
:
Event
*
GetOpeningPopupEvent
(
)
const
{
return
mPendingPopup
-
>
mEvent
.
get
(
)
;
}
MOZ_CAN_RUN_SCRIPT
nsresult
KeyUp
(
mozilla
:
:
dom
:
:
KeyboardEvent
*
aKeyEvent
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
KeyDown
(
mozilla
:
:
dom
:
:
KeyboardEvent
*
aKeyEvent
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
KeyPress
(
mozilla
:
:
dom
:
:
KeyboardEvent
*
aKeyEvent
)
;
protected
:
nsXULPopupManager
(
)
;
~
nsXULPopupManager
(
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsMenuPopupFrame
*
GetPopupFrameForContent
(
nsIContent
*
aContent
bool
aShouldFlush
)
;
nsMenuChainItem
*
GetRollupItem
(
RollupKind
)
;
nsMenuChainItem
*
GetTopVisibleMenu
(
)
{
return
GetRollupItem
(
RollupKind
:
:
Menu
)
;
}
void
RemoveMenuChainItem
(
nsMenuChainItem
*
)
;
MOZ_CAN_RUN_SCRIPT
void
HidePopupsInList
(
const
nsTArray
<
nsMenuPopupFrame
*
>
&
aFrames
)
;
MOZ_CAN_RUN_SCRIPT
void
HideOpenMenusBeforeExecutingMenu
(
CloseMenuMode
aMode
)
;
MOZ_CAN_RUN_SCRIPT
void
ShowPopupCallback
(
nsIContent
*
aPopup
nsMenuPopupFrame
*
aPopupFrame
bool
aIsContextMenu
bool
aSelectFirstItem
)
;
MOZ_CAN_RUN_SCRIPT
void
HidePopupCallback
(
nsIContent
*
aPopup
nsMenuPopupFrame
*
aPopupFrame
nsIContent
*
aNextPopup
nsIContent
*
aLastPopup
PopupType
aPopupType
HidePopupOptions
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
BeginShowingPopup
(
const
PendingPopup
&
aPendingPopup
bool
aIsContextMenu
bool
aSelectFirstItem
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
FirePopupHidingEvent
(
nsIContent
*
aPopup
nsIContent
*
aNextPopup
nsIContent
*
aLastPopup
nsPresContext
*
aPresContext
PopupType
aPopupType
HidePopupOptions
aOptions
)
;
MOZ_CAN_RUN_SCRIPT
bool
HandleKeyboardNavigationInPopup
(
nsMenuChainItem
*
aItem
nsNavigationDirection
aDir
)
{
return
HandleKeyboardNavigationInPopup
(
aItem
aItem
-
>
Frame
(
)
aDir
)
;
}
private
:
MOZ_CAN_RUN_SCRIPT
bool
HandleKeyboardNavigationInPopup
(
nsMenuChainItem
*
aItem
nsMenuPopupFrame
*
aFrame
nsNavigationDirection
aDir
)
;
protected
:
already_AddRefed
<
nsINode
>
GetLastTriggerNode
(
mozilla
:
:
dom
:
:
Document
*
aDocument
bool
aIsTooltip
)
;
MOZ_CAN_RUN_SCRIPT
nsEventStatus
FirePopupShowingEvent
(
const
PendingPopup
&
aPendingPopup
nsPresContext
*
aPresContext
)
;
void
SetCaptureState
(
nsIContent
*
aOldPopup
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
UpdateKeyboardListeners
(
)
;
bool
IsChildOfDocShell
(
mozilla
:
:
dom
:
:
Document
*
aDoc
nsIDocShellTreeItem
*
aExpected
)
;
nsMenuChainItem
*
FindPopup
(
nsIContent
*
aPopup
)
const
;
nsCOMPtr
<
mozilla
:
:
dom
:
:
EventTarget
>
mKeyListener
;
nsCOMPtr
<
nsIWidget
>
mWidget
;
nsMenuBarFrame
*
mActiveMenuBar
;
mozilla
:
:
UniquePtr
<
nsMenuChainItem
>
mPopups
;
nsCOMPtr
<
nsITimer
>
mCloseTimer
;
nsMenuPopupFrame
*
mTimerMenu
=
nullptr
;
const
PendingPopup
*
mPendingPopup
;
RefPtr
<
mozilla
:
:
widget
:
:
NativeMenu
>
mNativeMenu
;
mozilla
:
:
Maybe
<
CloseMenuMode
>
mNativeMenuActivatedItemCloseMenuMode
;
nsTHashMap
<
RefPtr
<
mozilla
:
:
dom
:
:
Element
>
nsPopupState
>
mNativeMenuSubmenuStates
;
}
;
#
endif
