#
include
"
nsBoxFrame
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
nsBoxLayoutState
.
h
"
#
include
"
mozilla
/
dom
/
Touch
.
h
"
#
include
"
mozilla
/
Move
.
h
"
#
include
"
nsStyleContext
.
h
"
#
include
"
nsPlaceholderFrame
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsHTMLParts
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsView
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsCSSRendering
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsBoxLayout
.
h
"
#
include
"
nsSprocketLayout
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsWidgetsCID
.
h
"
#
include
"
nsCSSAnonBoxes
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsIDOMElement
.
h
"
#
include
"
nsITheme
.
h
"
#
include
"
nsTransform2D
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
nsIDOMEvent
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
nsThemeConstants
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsSliderFrame
.
h
"
#
include
<
algorithm
>
#
include
"
nsIURI
.
h
"
#
include
"
mozilla
/
TouchEvents
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
gfx
;
#
define
DEBUG_SPRING_SIZE
8
#
define
DEBUG_BORDER_SIZE
2
#
define
COIL_SIZE
8
#
ifdef
DEBUG_rods
#
endif
#
ifdef
DEBUG_LAYOUT
bool
nsBoxFrame
:
:
gDebug
=
false
;
nsIFrame
*
nsBoxFrame
:
:
mDebugChild
=
nullptr
;
#
endif
nsIFrame
*
NS_NewBoxFrame
(
nsIPresShell
*
aPresShell
nsStyleContext
*
aContext
bool
aIsRoot
nsBoxLayout
*
aLayoutManager
)
{
return
new
(
aPresShell
)
nsBoxFrame
(
aContext
nsBoxFrame
:
:
kClassID
aIsRoot
aLayoutManager
)
;
}
nsIFrame
*
NS_NewBoxFrame
(
nsIPresShell
*
aPresShell
nsStyleContext
*
aContext
)
{
return
new
(
aPresShell
)
nsBoxFrame
(
aContext
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsBoxFrame
)
#
ifdef
DEBUG
NS_QUERYFRAME_HEAD
(
nsBoxFrame
)
NS_QUERYFRAME_ENTRY
(
nsBoxFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsContainerFrame
)
#
endif
nsBoxFrame
:
:
nsBoxFrame
(
nsStyleContext
*
aContext
ClassID
aID
bool
aIsRoot
nsBoxLayout
*
aLayoutManager
)
:
nsContainerFrame
(
aContext
aID
)
mFlex
(
0
)
mAscent
(
0
)
{
AddStateBits
(
NS_STATE_IS_HORIZONTAL
|
NS_STATE_AUTO_STRETCH
)
;
if
(
aIsRoot
)
AddStateBits
(
NS_STATE_IS_ROOT
)
;
mValign
=
vAlign_Top
;
mHalign
=
hAlign_Left
;
nsCOMPtr
<
nsBoxLayout
>
layout
=
aLayoutManager
;
if
(
layout
=
=
nullptr
)
{
NS_NewSprocketLayout
(
layout
)
;
}
SetXULLayoutManager
(
layout
)
;
}
nsBoxFrame
:
:
~
nsBoxFrame
(
)
{
}
void
nsBoxFrame
:
:
SetInitialChildList
(
ChildListID
aListID
nsFrameList
&
aChildList
)
{
nsContainerFrame
:
:
SetInitialChildList
(
aListID
aChildList
)
;
if
(
aListID
=
=
kPrincipalList
)
{
nsBoxLayoutState
state
(
PresContext
(
)
)
;
CheckBoxOrder
(
)
;
if
(
mLayoutManager
)
mLayoutManager
-
>
ChildrenSet
(
this
state
mFrames
.
FirstChild
(
)
)
;
}
}
void
nsBoxFrame
:
:
DidSetStyleContext
(
nsStyleContext
*
aOldStyleContext
)
{
nsContainerFrame
:
:
DidSetStyleContext
(
aOldStyleContext
)
;
CacheAttributes
(
)
;
}
void
nsBoxFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
nsContainerFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
if
(
GetStateBits
(
)
&
NS_FRAME_FONT_INFLATION_CONTAINER
)
{
AddStateBits
(
NS_FRAME_FONT_INFLATION_FLOW_ROOT
)
;
}
MarkIntrinsicISizesDirty
(
)
;
CacheAttributes
(
)
;
#
ifdef
DEBUG_LAYOUT
if
(
mState
&
NS_STATE_IS_ROOT
)
{
GetDebugPref
(
)
;
}
#
endif
UpdateMouseThrough
(
)
;
RegUnregAccessKey
(
true
)
;
}
void
nsBoxFrame
:
:
UpdateMouseThrough
(
)
{
static
Element
:
:
AttrValuesArray
strings
[
]
=
{
&
nsGkAtoms
:
:
never
&
nsGkAtoms
:
:
always
nullptr
}
;
switch
(
mContent
-
>
AsElement
(
)
-
>
FindAttrValueIn
(
kNameSpaceID_None
nsGkAtoms
:
:
mousethrough
strings
eCaseMatters
)
)
{
case
0
:
AddStateBits
(
NS_FRAME_MOUSE_THROUGH_NEVER
)
;
break
;
case
1
:
AddStateBits
(
NS_FRAME_MOUSE_THROUGH_ALWAYS
)
;
break
;
case
2
:
{
RemoveStateBits
(
NS_FRAME_MOUSE_THROUGH_ALWAYS
)
;
RemoveStateBits
(
NS_FRAME_MOUSE_THROUGH_NEVER
)
;
break
;
}
}
}
void
nsBoxFrame
:
:
CacheAttributes
(
)
{
mValign
=
vAlign_Top
;
mHalign
=
hAlign_Left
;
bool
orient
=
false
;
GetInitialOrientation
(
orient
)
;
if
(
orient
)
AddStateBits
(
NS_STATE_IS_HORIZONTAL
)
;
else
RemoveStateBits
(
NS_STATE_IS_HORIZONTAL
)
;
bool
normal
=
true
;
GetInitialDirection
(
normal
)
;
if
(
normal
)
AddStateBits
(
NS_STATE_IS_DIRECTION_NORMAL
)
;
else
RemoveStateBits
(
NS_STATE_IS_DIRECTION_NORMAL
)
;
GetInitialVAlignment
(
mValign
)
;
GetInitialHAlignment
(
mHalign
)
;
bool
equalSize
=
false
;
GetInitialEqualSize
(
equalSize
)
;
if
(
equalSize
)
AddStateBits
(
NS_STATE_EQUAL_SIZE
)
;
else
RemoveStateBits
(
NS_STATE_EQUAL_SIZE
)
;
bool
autostretch
=
!
!
(
mState
&
NS_STATE_AUTO_STRETCH
)
;
GetInitialAutoStretch
(
autostretch
)
;
if
(
autostretch
)
AddStateBits
(
NS_STATE_AUTO_STRETCH
)
;
else
RemoveStateBits
(
NS_STATE_AUTO_STRETCH
)
;
#
ifdef
DEBUG_LAYOUT
bool
debug
=
mState
&
NS_STATE_SET_TO_DEBUG
;
bool
debugSet
=
GetInitialDebug
(
debug
)
;
if
(
debugSet
)
{
AddStateBits
(
NS_STATE_DEBUG_WAS_SET
)
;
if
(
debug
)
AddStateBits
(
NS_STATE_SET_TO_DEBUG
)
;
else
RemoveStateBits
(
NS_STATE_SET_TO_DEBUG
)
;
}
else
{
RemoveStateBits
(
NS_STATE_DEBUG_WAS_SET
)
;
}
#
endif
}
#
ifdef
DEBUG_LAYOUT
bool
nsBoxFrame
:
:
GetInitialDebug
(
bool
&
aDebug
)
{
if
(
!
GetContent
(
)
|
|
!
GetContent
(
)
-
>
IsElement
(
)
)
return
false
;
static
Element
:
:
AttrValuesArray
strings
[
]
=
{
&
nsGkAtoms
:
:
_false
&
nsGkAtoms
:
:
_true
nullptr
}
;
int32_t
index
=
GetContent
(
)
-
>
FindAttrValueIn
(
kNameSpaceID_None
nsGkAtoms
:
:
debug
strings
eCaseMatters
)
;
if
(
index
>
=
0
)
{
aDebug
=
index
=
=
1
;
return
true
;
}
return
false
;
}
#
endif
bool
nsBoxFrame
:
:
GetInitialHAlignment
(
nsBoxFrame
:
:
Halignment
&
aHalign
)
{
if
(
!
GetContent
(
)
|
|
!
GetContent
(
)
-
>
IsElement
(
)
)
return
false
;
Element
*
element
=
GetContent
(
)
-
>
AsElement
(
)
;
static
Element
:
:
AttrValuesArray
alignStrings
[
]
=
{
&
nsGkAtoms
:
:
left
&
nsGkAtoms
:
:
right
nullptr
}
;
static
const
Halignment
alignValues
[
]
=
{
hAlign_Left
hAlign_Right
}
;
int32_t
index
=
element
-
>
FindAttrValueIn
(
kNameSpaceID_None
nsGkAtoms
:
:
align
alignStrings
eCaseMatters
)
;
if
(
index
>
=
0
)
{
aHalign
=
alignValues
[
index
]
;
return
true
;
}
nsAtom
*
attrName
=
IsXULHorizontal
(
)
?
nsGkAtoms
:
:
pack
:
nsGkAtoms
:
:
align
;
static
Element
:
:
AttrValuesArray
strings
[
]
=
{
&
nsGkAtoms
:
:
_empty
&
nsGkAtoms
:
:
start
&
nsGkAtoms
:
:
center
&
nsGkAtoms
:
:
end
nullptr
}
;
static
const
Halignment
values
[
]
=
{
hAlign_Left
hAlign_Left
hAlign_Center
hAlign_Right
}
;
index
=
element
-
>
FindAttrValueIn
(
kNameSpaceID_None
attrName
strings
eCaseMatters
)
;
if
(
index
=
=
Element
:
:
ATTR_VALUE_NO_MATCH
)
{
return
false
;
}
if
(
index
>
0
)
{
aHalign
=
values
[
index
]
;
return
true
;
}
const
nsStyleXUL
*
boxInfo
=
StyleXUL
(
)
;
if
(
IsXULHorizontal
(
)
)
{
switch
(
boxInfo
-
>
mBoxPack
)
{
case
StyleBoxPack
:
:
Start
:
aHalign
=
nsBoxFrame
:
:
hAlign_Left
;
return
true
;
case
StyleBoxPack
:
:
Center
:
aHalign
=
nsBoxFrame
:
:
hAlign_Center
;
return
true
;
case
StyleBoxPack
:
:
End
:
aHalign
=
nsBoxFrame
:
:
hAlign_Right
;
return
true
;
default
:
return
false
;
}
}
else
{
switch
(
boxInfo
-
>
mBoxAlign
)
{
case
StyleBoxAlign
:
:
Start
:
aHalign
=
nsBoxFrame
:
:
hAlign_Left
;
return
true
;
case
StyleBoxAlign
:
:
Center
:
aHalign
=
nsBoxFrame
:
:
hAlign_Center
;
return
true
;
case
StyleBoxAlign
:
:
End
:
aHalign
=
nsBoxFrame
:
:
hAlign_Right
;
return
true
;
default
:
return
false
;
}
}
return
false
;
}
bool
nsBoxFrame
:
:
GetInitialVAlignment
(
nsBoxFrame
:
:
Valignment
&
aValign
)
{
if
(
!
GetContent
(
)
|
|
!
GetContent
(
)
-
>
IsElement
(
)
)
return
false
;
Element
*
element
=
GetContent
(
)
-
>
AsElement
(
)
;
static
Element
:
:
AttrValuesArray
valignStrings
[
]
=
{
&
nsGkAtoms
:
:
top
&
nsGkAtoms
:
:
baseline
&
nsGkAtoms
:
:
middle
&
nsGkAtoms
:
:
bottom
nullptr
}
;
static
const
Valignment
valignValues
[
]
=
{
vAlign_Top
vAlign_BaseLine
vAlign_Middle
vAlign_Bottom
}
;
int32_t
index
=
element
-
>
FindAttrValueIn
(
kNameSpaceID_None
nsGkAtoms
:
:
valign
valignStrings
eCaseMatters
)
;
if
(
index
>
=
0
)
{
aValign
=
valignValues
[
index
]
;
return
true
;
}
nsAtom
*
attrName
=
IsXULHorizontal
(
)
?
nsGkAtoms
:
:
align
:
nsGkAtoms
:
:
pack
;
static
Element
:
:
AttrValuesArray
strings
[
]
=
{
&
nsGkAtoms
:
:
_empty
&
nsGkAtoms
:
:
start
&
nsGkAtoms
:
:
center
&
nsGkAtoms
:
:
baseline
&
nsGkAtoms
:
:
end
nullptr
}
;
static
const
Valignment
values
[
]
=
{
vAlign_Top
vAlign_Top
vAlign_Middle
vAlign_BaseLine
vAlign_Bottom
}
;
index
=
element
-
>
FindAttrValueIn
(
kNameSpaceID_None
attrName
strings
eCaseMatters
)
;
if
(
index
=
=
Element
:
:
ATTR_VALUE_NO_MATCH
)
{
return
false
;
}
if
(
index
>
0
)
{
aValign
=
values
[
index
]
;
return
true
;
}
const
nsStyleXUL
*
boxInfo
=
StyleXUL
(
)
;
if
(
IsXULHorizontal
(
)
)
{
switch
(
boxInfo
-
>
mBoxAlign
)
{
case
StyleBoxAlign
:
:
Start
:
aValign
=
nsBoxFrame
:
:
vAlign_Top
;
return
true
;
case
StyleBoxAlign
:
:
Center
:
aValign
=
nsBoxFrame
:
:
vAlign_Middle
;
return
true
;
case
StyleBoxAlign
:
:
Baseline
:
aValign
=
nsBoxFrame
:
:
vAlign_BaseLine
;
return
true
;
case
StyleBoxAlign
:
:
End
:
aValign
=
nsBoxFrame
:
:
vAlign_Bottom
;
return
true
;
default
:
return
false
;
}
}
else
{
switch
(
boxInfo
-
>
mBoxPack
)
{
case
StyleBoxPack
:
:
Start
:
aValign
=
nsBoxFrame
:
:
vAlign_Top
;
return
true
;
case
StyleBoxPack
:
:
Center
:
aValign
=
nsBoxFrame
:
:
vAlign_Middle
;
return
true
;
case
StyleBoxPack
:
:
End
:
aValign
=
nsBoxFrame
:
:
vAlign_Bottom
;
return
true
;
default
:
return
false
;
}
}
return
false
;
}
void
nsBoxFrame
:
:
GetInitialOrientation
(
bool
&
aIsHorizontal
)
{
if
(
!
GetContent
(
)
)
return
;
const
nsStyleXUL
*
boxInfo
=
StyleXUL
(
)
;
if
(
boxInfo
-
>
mBoxOrient
=
=
StyleBoxOrient
:
:
Horizontal
)
{
aIsHorizontal
=
true
;
}
else
{
aIsHorizontal
=
false
;
}
if
(
!
GetContent
(
)
-
>
IsElement
(
)
)
return
;
static
Element
:
:
AttrValuesArray
strings
[
]
=
{
&
nsGkAtoms
:
:
vertical
&
nsGkAtoms
:
:
horizontal
nullptr
}
;
int32_t
index
=
GetContent
(
)
-
>
AsElement
(
)
-
>
FindAttrValueIn
(
kNameSpaceID_None
nsGkAtoms
:
:
orient
strings
eCaseMatters
)
;
if
(
index
>
=
0
)
{
aIsHorizontal
=
index
=
=
1
;
}
}
void
nsBoxFrame
:
:
GetInitialDirection
(
bool
&
aIsNormal
)
{
if
(
!
GetContent
(
)
)
return
;
if
(
IsXULHorizontal
(
)
)
{
aIsNormal
=
(
StyleVisibility
(
)
-
>
mDirection
=
=
NS_STYLE_DIRECTION_LTR
)
;
}
else
aIsNormal
=
true
;
const
nsStyleXUL
*
boxInfo
=
StyleXUL
(
)
;
if
(
boxInfo
-
>
mBoxDirection
=
=
StyleBoxDirection
:
:
Reverse
)
{
aIsNormal
=
!
aIsNormal
;
}
if
(
!
GetContent
(
)
-
>
IsElement
(
)
)
{
return
;
}
Element
*
element
=
GetContent
(
)
-
>
AsElement
(
)
;
if
(
IsXULHorizontal
(
)
)
{
static
Element
:
:
AttrValuesArray
strings
[
]
=
{
&
nsGkAtoms
:
:
reverse
&
nsGkAtoms
:
:
ltr
&
nsGkAtoms
:
:
rtl
nullptr
}
;
int32_t
index
=
element
-
>
FindAttrValueIn
(
kNameSpaceID_None
nsGkAtoms
:
:
dir
strings
eCaseMatters
)
;
if
(
index
>
=
0
)
{
bool
values
[
]
=
{
!
aIsNormal
true
false
}
;
aIsNormal
=
values
[
index
]
;
}
}
else
if
(
element
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
dir
nsGkAtoms
:
:
reverse
eCaseMatters
)
)
{
aIsNormal
=
!
aIsNormal
;
}
}
bool
nsBoxFrame
:
:
GetInitialEqualSize
(
bool
&
aEqualSize
)
{
if
(
!
GetContent
(
)
|
|
!
GetContent
(
)
-
>
IsElement
(
)
)
return
false
;
if
(
GetContent
(
)
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
equalsize
nsGkAtoms
:
:
always
eCaseMatters
)
)
{
aEqualSize
=
true
;
return
true
;
}
return
false
;
}
bool
nsBoxFrame
:
:
GetInitialAutoStretch
(
bool
&
aStretch
)
{
if
(
!
GetContent
(
)
)
return
false
;
if
(
GetContent
(
)
-
>
IsElement
(
)
)
{
static
Element
:
:
AttrValuesArray
strings
[
]
=
{
&
nsGkAtoms
:
:
_empty
&
nsGkAtoms
:
:
stretch
nullptr
}
;
int32_t
index
=
GetContent
(
)
-
>
AsElement
(
)
-
>
FindAttrValueIn
(
kNameSpaceID_None
nsGkAtoms
:
:
align
strings
eCaseMatters
)
;
if
(
index
!
=
Element
:
:
ATTR_MISSING
&
&
index
!
=
0
)
{
aStretch
=
index
=
=
1
;
return
true
;
}
}
const
nsStyleXUL
*
boxInfo
=
StyleXUL
(
)
;
aStretch
=
(
boxInfo
-
>
mBoxAlign
=
=
StyleBoxAlign
:
:
Stretch
)
;
return
true
;
}
void
nsBoxFrame
:
:
DidReflow
(
nsPresContext
*
aPresContext
const
ReflowInput
*
aReflowInput
)
{
nsFrameState
preserveBits
=
mState
&
(
NS_FRAME_IS_DIRTY
|
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
nsFrame
:
:
DidReflow
(
aPresContext
aReflowInput
)
;
AddStateBits
(
preserveBits
)
;
}
bool
nsBoxFrame
:
:
HonorPrintBackgroundSettings
(
)
{
return
!
mContent
-
>
IsInNativeAnonymousSubtree
(
)
&
&
nsContainerFrame
:
:
HonorPrintBackgroundSettings
(
)
;
}
#
ifdef
DO_NOISY_REFLOW
static
int
myCounter
=
0
;
static
void
printSize
(
char
*
aDesc
nscoord
aSize
)
{
printf
(
"
%
s
:
"
aDesc
)
;
if
(
aSize
=
=
NS_UNCONSTRAINEDSIZE
)
{
printf
(
"
UC
"
)
;
}
else
{
printf
(
"
%
d
"
aSize
)
;
}
}
#
endif
nscoord
nsBoxFrame
:
:
GetMinISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
result
;
DISPLAY_MIN_WIDTH
(
this
result
)
;
nsBoxLayoutState
state
(
PresContext
(
)
aRenderingContext
)
;
nsSize
minSize
=
GetXULMinSize
(
state
)
;
nsMargin
bp
;
GetXULBorderAndPadding
(
bp
)
;
result
=
minSize
.
width
-
bp
.
LeftRight
(
)
;
result
=
std
:
:
max
(
result
0
)
;
return
result
;
}
nscoord
nsBoxFrame
:
:
GetPrefISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
result
;
DISPLAY_PREF_WIDTH
(
this
result
)
;
nsBoxLayoutState
state
(
PresContext
(
)
aRenderingContext
)
;
nsSize
prefSize
=
GetXULPrefSize
(
state
)
;
nsMargin
bp
;
GetXULBorderAndPadding
(
bp
)
;
result
=
prefSize
.
width
-
bp
.
LeftRight
(
)
;
result
=
std
:
:
max
(
result
0
)
;
return
result
;
}
void
nsBoxFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsBoxFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aDesiredSize
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
NS_ASSERTION
(
aReflowInput
.
ComputedWidth
(
)
>
=
0
&
&
aReflowInput
.
ComputedHeight
(
)
>
=
0
"
Computed
Size
<
0
"
)
;
#
ifdef
DO_NOISY_REFLOW
printf
(
"
\
n
-
-
-
-
-
-
-
-
-
-
-
-
-
Starting
BoxFrame
Reflow
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
\
n
"
)
;
printf
(
"
%
p
*
*
nsBF
:
:
Reflow
%
d
"
this
myCounter
+
+
)
;
printSize
(
"
AW
"
aReflowInput
.
AvailableWidth
(
)
)
;
printSize
(
"
AH
"
aReflowInput
.
AvailableHeight
(
)
)
;
printSize
(
"
CW
"
aReflowInput
.
ComputedWidth
(
)
)
;
printSize
(
"
CH
"
aReflowInput
.
ComputedHeight
(
)
)
;
printf
(
"
*
\
n
"
)
;
#
endif
nsBoxLayoutState
state
(
aPresContext
aReflowInput
.
mRenderingContext
&
aReflowInput
aReflowInput
.
mReflowDepth
)
;
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
LogicalSize
computedSize
(
wm
aReflowInput
.
ComputedISize
(
)
aReflowInput
.
ComputedBSize
(
)
)
;
LogicalMargin
m
=
aReflowInput
.
ComputedLogicalBorderPadding
(
)
;
LogicalSize
prefSize
(
wm
)
;
NS_ASSERTION
(
computedSize
.
ISize
(
wm
)
!
=
NS_INTRINSICSIZE
"
computed
inline
size
should
always
be
computed
"
)
;
if
(
computedSize
.
BSize
(
wm
)
=
=
NS_INTRINSICSIZE
)
{
nsSize
physicalPrefSize
=
GetXULPrefSize
(
state
)
;
nsSize
minSize
=
GetXULMinSize
(
state
)
;
nsSize
maxSize
=
GetXULMaxSize
(
state
)
;
physicalPrefSize
=
BoundsCheck
(
minSize
physicalPrefSize
maxSize
)
;
prefSize
=
LogicalSize
(
wm
physicalPrefSize
)
;
}
computedSize
.
ISize
(
wm
)
+
=
m
.
IStart
(
wm
)
+
m
.
IEnd
(
wm
)
;
if
(
aReflowInput
.
ComputedBSize
(
)
=
=
NS_INTRINSICSIZE
)
{
computedSize
.
BSize
(
wm
)
=
prefSize
.
BSize
(
wm
)
;
nscoord
blockDirBorderPadding
=
aReflowInput
.
ComputedLogicalBorderPadding
(
)
.
BStartEnd
(
wm
)
;
nscoord
contentBSize
=
computedSize
.
BSize
(
wm
)
-
blockDirBorderPadding
;
computedSize
.
BSize
(
wm
)
=
aReflowInput
.
ApplyMinMaxHeight
(
contentBSize
)
+
blockDirBorderPadding
;
}
else
{
computedSize
.
BSize
(
wm
)
+
=
m
.
BStart
(
wm
)
+
m
.
BEnd
(
wm
)
;
}
nsSize
physicalSize
=
computedSize
.
GetPhysicalSize
(
wm
)
;
nsRect
r
(
mRect
.
x
mRect
.
y
physicalSize
.
width
physicalSize
.
height
)
;
SetXULBounds
(
state
r
)
;
XULLayout
(
state
)
;
LogicalSize
boxSize
=
GetLogicalSize
(
wm
)
;
nscoord
ascent
=
boxSize
.
BSize
(
wm
)
;
if
(
!
(
mState
&
NS_STATE_IS_ROOT
)
)
{
ascent
=
GetXULBoxAscent
(
state
)
;
}
aDesiredSize
.
SetSize
(
wm
boxSize
)
;
aDesiredSize
.
SetBlockStartAscent
(
ascent
)
;
aDesiredSize
.
mOverflowAreas
=
GetOverflowAreas
(
)
;
#
ifdef
DO_NOISY_REFLOW
{
printf
(
"
%
p
*
*
nsBF
(
done
)
W
:
%
d
H
:
%
d
"
this
aDesiredSize
.
Width
(
)
aDesiredSize
.
Height
(
)
)
;
if
(
maxElementSize
)
{
printf
(
"
MW
:
%
d
\
n
"
*
maxElementWidth
)
;
}
else
{
printf
(
"
MW
:
?
\
n
"
)
;
}
}
#
endif
ReflowAbsoluteFrames
(
aPresContext
aDesiredSize
aReflowInput
aStatus
)
;
NS_FRAME_SET_TRUNCATION
(
aStatus
aReflowInput
aDesiredSize
)
;
}
nsSize
nsBoxFrame
:
:
GetXULPrefSize
(
nsBoxLayoutState
&
aBoxLayoutState
)
{
NS_ASSERTION
(
aBoxLayoutState
.
GetRenderingContext
(
)
"
must
have
rendering
context
"
)
;
nsSize
size
(
0
0
)
;
DISPLAY_PREF_SIZE
(
this
size
)
;
if
(
!
DoesNeedRecalc
(
mPrefSize
)
)
{
return
mPrefSize
;
}
#
ifdef
DEBUG_LAYOUT
PropagateDebug
(
aBoxLayoutState
)
;
#
endif
if
(
IsXULCollapsed
(
)
)
return
size
;
bool
widthSet
heightSet
;
if
(
!
nsIFrame
:
:
AddXULPrefSize
(
this
size
widthSet
heightSet
)
)
{
if
(
mLayoutManager
)
{
nsSize
layoutSize
=
mLayoutManager
-
>
GetXULPrefSize
(
this
aBoxLayoutState
)
;
if
(
!
widthSet
)
size
.
width
=
layoutSize
.
width
;
if
(
!
heightSet
)
size
.
height
=
layoutSize
.
height
;
}
else
{
size
=
nsBox
:
:
GetXULPrefSize
(
aBoxLayoutState
)
;
}
}
nsSize
minSize
=
GetXULMinSize
(
aBoxLayoutState
)
;
nsSize
maxSize
=
GetXULMaxSize
(
aBoxLayoutState
)
;
mPrefSize
=
BoundsCheck
(
minSize
size
maxSize
)
;
return
mPrefSize
;
}
nscoord
nsBoxFrame
:
:
GetXULBoxAscent
(
nsBoxLayoutState
&
aBoxLayoutState
)
{
if
(
!
DoesNeedRecalc
(
mAscent
)
)
return
mAscent
;
#
ifdef
DEBUG_LAYOUT
PropagateDebug
(
aBoxLayoutState
)
;
#
endif
if
(
IsXULCollapsed
(
)
)
return
0
;
if
(
mLayoutManager
)
mAscent
=
mLayoutManager
-
>
GetAscent
(
this
aBoxLayoutState
)
;
else
mAscent
=
nsBox
:
:
GetXULBoxAscent
(
aBoxLayoutState
)
;
return
mAscent
;
}
nsSize
nsBoxFrame
:
:
GetXULMinSize
(
nsBoxLayoutState
&
aBoxLayoutState
)
{
NS_ASSERTION
(
aBoxLayoutState
.
GetRenderingContext
(
)
"
must
have
rendering
context
"
)
;
nsSize
size
(
0
0
)
;
DISPLAY_MIN_SIZE
(
this
size
)
;
if
(
!
DoesNeedRecalc
(
mMinSize
)
)
{
return
mMinSize
;
}
#
ifdef
DEBUG_LAYOUT
PropagateDebug
(
aBoxLayoutState
)
;
#
endif
if
(
IsXULCollapsed
(
)
)
return
size
;
bool
widthSet
heightSet
;
if
(
!
nsIFrame
:
:
AddXULMinSize
(
aBoxLayoutState
this
size
widthSet
heightSet
)
)
{
if
(
mLayoutManager
)
{
nsSize
layoutSize
=
mLayoutManager
-
>
GetXULMinSize
(
this
aBoxLayoutState
)
;
if
(
!
widthSet
)
size
.
width
=
layoutSize
.
width
;
if
(
!
heightSet
)
size
.
height
=
layoutSize
.
height
;
}
else
{
size
=
nsBox
:
:
GetXULMinSize
(
aBoxLayoutState
)
;
}
}
mMinSize
=
size
;
return
size
;
}
nsSize
nsBoxFrame
:
:
GetXULMaxSize
(
nsBoxLayoutState
&
aBoxLayoutState
)
{
NS_ASSERTION
(
aBoxLayoutState
.
GetRenderingContext
(
)
"
must
have
rendering
context
"
)
;
nsSize
size
(
NS_INTRINSICSIZE
NS_INTRINSICSIZE
)
;
DISPLAY_MAX_SIZE
(
this
size
)
;
if
(
!
DoesNeedRecalc
(
mMaxSize
)
)
{
return
mMaxSize
;
}
#
ifdef
DEBUG_LAYOUT
PropagateDebug
(
aBoxLayoutState
)
;
#
endif
if
(
IsXULCollapsed
(
)
)
return
size
;
bool
widthSet
heightSet
;
if
(
!
nsIFrame
:
:
AddXULMaxSize
(
this
size
widthSet
heightSet
)
)
{
if
(
mLayoutManager
)
{
nsSize
layoutSize
=
mLayoutManager
-
>
GetXULMaxSize
(
this
aBoxLayoutState
)
;
if
(
!
widthSet
)
size
.
width
=
layoutSize
.
width
;
if
(
!
heightSet
)
size
.
height
=
layoutSize
.
height
;
}
else
{
size
=
nsBox
:
:
GetXULMaxSize
(
aBoxLayoutState
)
;
}
}
mMaxSize
=
size
;
return
size
;
}
nscoord
nsBoxFrame
:
:
GetXULFlex
(
)
{
if
(
!
DoesNeedRecalc
(
mFlex
)
)
return
mFlex
;
mFlex
=
nsBox
:
:
GetXULFlex
(
)
;
return
mFlex
;
}
NS_IMETHODIMP
nsBoxFrame
:
:
DoXULLayout
(
nsBoxLayoutState
&
aState
)
{
uint32_t
oldFlags
=
aState
.
LayoutFlags
(
)
;
aState
.
SetLayoutFlags
(
0
)
;
nsresult
rv
=
NS_OK
;
if
(
mLayoutManager
)
{
CoordNeedsRecalc
(
mAscent
)
;
rv
=
mLayoutManager
-
>
XULLayout
(
this
aState
)
;
}
aState
.
SetLayoutFlags
(
oldFlags
)
;
if
(
HasAbsolutelyPositionedChildren
(
)
)
{
WritingMode
wm
=
GetWritingMode
(
)
;
ReflowInput
reflowInput
(
aState
.
PresContext
(
)
this
aState
.
GetRenderingContext
(
)
LogicalSize
(
wm
GetLogicalSize
(
)
.
ISize
(
wm
)
NS_UNCONSTRAINEDSIZE
)
)
;
ReflowOutput
desiredSize
(
reflowInput
)
;
desiredSize
.
Width
(
)
=
mRect
.
width
;
desiredSize
.
Height
(
)
=
mRect
.
height
;
nscoord
ascent
=
mRect
.
height
;
if
(
!
(
mState
&
NS_STATE_IS_ROOT
)
)
{
ascent
=
GetXULBoxAscent
(
aState
)
;
}
desiredSize
.
SetBlockStartAscent
(
ascent
)
;
desiredSize
.
mOverflowAreas
=
GetOverflowAreas
(
)
;
AddStateBits
(
NS_FRAME_IN_REFLOW
)
;
nsReflowStatus
reflowStatus
;
ReflowAbsoluteFrames
(
aState
.
PresContext
(
)
desiredSize
reflowInput
reflowStatus
)
;
RemoveStateBits
(
NS_FRAME_IN_REFLOW
)
;
}
return
rv
;
}
void
nsBoxFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
{
RegUnregAccessKey
(
false
)
;
SetXULLayoutManager
(
nullptr
)
;
nsContainerFrame
:
:
DestroyFrom
(
aDestructRoot
aPostDestroyData
)
;
}
#
ifdef
DEBUG_LAYOUT
nsresult
nsBoxFrame
:
:
SetXULDebug
(
nsBoxLayoutState
&
aState
bool
aDebug
)
{
bool
debugSet
=
mState
&
NS_STATE_CURRENTLY_IN_DEBUG
;
bool
debugChanged
=
(
!
aDebug
&
&
debugSet
)
|
|
(
aDebug
&
&
!
debugSet
)
;
if
(
debugChanged
)
{
if
(
aDebug
)
{
AddStateBits
(
NS_STATE_CURRENTLY_IN_DEBUG
)
;
}
else
{
RemoveStateBits
(
NS_STATE_CURRENTLY_IN_DEBUG
)
;
}
SetDebugOnChildList
(
aState
mFirstChild
aDebug
)
;
MarkIntrinsicISizesDirty
(
)
;
}
return
NS_OK
;
}
#
endif
void
nsBoxFrame
:
:
MarkIntrinsicISizesDirty
(
)
{
SizeNeedsRecalc
(
mPrefSize
)
;
SizeNeedsRecalc
(
mMinSize
)
;
SizeNeedsRecalc
(
mMaxSize
)
;
CoordNeedsRecalc
(
mFlex
)
;
CoordNeedsRecalc
(
mAscent
)
;
if
(
mLayoutManager
)
{
nsBoxLayoutState
state
(
PresContext
(
)
)
;
mLayoutManager
-
>
IntrinsicISizesDirty
(
this
state
)
;
}
}
void
nsBoxFrame
:
:
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
{
NS_PRECONDITION
(
aListID
=
=
kPrincipalList
"
We
don
'
t
support
out
-
of
-
flow
kids
"
)
;
nsPresContext
*
presContext
=
PresContext
(
)
;
nsBoxLayoutState
state
(
presContext
)
;
mFrames
.
RemoveFrame
(
aOldFrame
)
;
if
(
mLayoutManager
)
mLayoutManager
-
>
ChildrenRemoved
(
this
state
aOldFrame
)
;
aOldFrame
-
>
Destroy
(
)
;
PresShell
(
)
-
>
FrameNeedsReflow
(
this
nsIPresShell
:
:
eTreeChange
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
}
void
nsBoxFrame
:
:
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
aFrameList
)
{
NS_ASSERTION
(
!
aPrevFrame
|
|
aPrevFrame
-
>
GetParent
(
)
=
=
this
"
inserting
after
sibling
frame
with
different
parent
"
)
;
NS_ASSERTION
(
!
aPrevFrame
|
|
mFrames
.
ContainsFrame
(
aPrevFrame
)
"
inserting
after
sibling
frame
not
in
our
child
list
"
)
;
NS_PRECONDITION
(
aListID
=
=
kPrincipalList
"
We
don
'
t
support
out
-
of
-
flow
kids
"
)
;
nsBoxLayoutState
state
(
PresContext
(
)
)
;
const
nsFrameList
:
:
Slice
&
newFrames
=
mFrames
.
InsertFrames
(
this
aPrevFrame
aFrameList
)
;
if
(
mLayoutManager
)
mLayoutManager
-
>
ChildrenInserted
(
this
state
aPrevFrame
newFrames
)
;
CheckBoxOrder
(
)
;
#
ifdef
DEBUG_LAYOUT
if
(
mState
&
NS_STATE_CURRENTLY_IN_DEBUG
)
SetDebugOnChildList
(
state
mFrames
.
FirstChild
(
)
true
)
;
#
endif
PresShell
(
)
-
>
FrameNeedsReflow
(
this
nsIPresShell
:
:
eTreeChange
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
}
void
nsBoxFrame
:
:
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
{
NS_PRECONDITION
(
aListID
=
=
kPrincipalList
"
We
don
'
t
support
out
-
of
-
flow
kids
"
)
;
nsBoxLayoutState
state
(
PresContext
(
)
)
;
const
nsFrameList
:
:
Slice
&
newFrames
=
mFrames
.
AppendFrames
(
this
aFrameList
)
;
if
(
mLayoutManager
)
mLayoutManager
-
>
ChildrenAppended
(
this
state
newFrames
)
;
CheckBoxOrder
(
)
;
#
ifdef
DEBUG_LAYOUT
if
(
mState
&
NS_STATE_CURRENTLY_IN_DEBUG
)
SetDebugOnChildList
(
state
mFrames
.
FirstChild
(
)
true
)
;
#
endif
if
(
!
(
GetStateBits
(
)
&
NS_FRAME_FIRST_REFLOW
)
)
{
PresShell
(
)
-
>
FrameNeedsReflow
(
this
nsIPresShell
:
:
eTreeChange
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
}
}
nsContainerFrame
*
nsBoxFrame
:
:
GetContentInsertionFrame
(
)
{
if
(
GetStateBits
(
)
&
NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK
)
return
PrincipalChildList
(
)
.
FirstChild
(
)
-
>
GetContentInsertionFrame
(
)
;
return
nsContainerFrame
:
:
GetContentInsertionFrame
(
)
;
}
nsresult
nsBoxFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
nsresult
rv
=
nsContainerFrame
:
:
AttributeChanged
(
aNameSpaceID
aAttribute
aModType
)
;
if
(
mContent
-
>
IsAnyOfXULElements
(
nsGkAtoms
:
:
window
nsGkAtoms
:
:
page
nsGkAtoms
:
:
dialog
nsGkAtoms
:
:
wizard
)
&
&
(
nsGkAtoms
:
:
width
=
=
aAttribute
|
|
nsGkAtoms
:
:
height
=
=
aAttribute
|
|
nsGkAtoms
:
:
screenX
=
=
aAttribute
|
|
nsGkAtoms
:
:
screenY
=
=
aAttribute
|
|
nsGkAtoms
:
:
sizemode
=
=
aAttribute
)
)
{
return
rv
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
width
|
|
aAttribute
=
=
nsGkAtoms
:
:
height
|
|
aAttribute
=
=
nsGkAtoms
:
:
align
|
|
aAttribute
=
=
nsGkAtoms
:
:
valign
|
|
aAttribute
=
=
nsGkAtoms
:
:
left
|
|
aAttribute
=
=
nsGkAtoms
:
:
top
|
|
aAttribute
=
=
nsGkAtoms
:
:
right
|
|
aAttribute
=
=
nsGkAtoms
:
:
bottom
|
|
aAttribute
=
=
nsGkAtoms
:
:
start
|
|
aAttribute
=
=
nsGkAtoms
:
:
end
|
|
aAttribute
=
=
nsGkAtoms
:
:
minwidth
|
|
aAttribute
=
=
nsGkAtoms
:
:
maxwidth
|
|
aAttribute
=
=
nsGkAtoms
:
:
minheight
|
|
aAttribute
=
=
nsGkAtoms
:
:
maxheight
|
|
aAttribute
=
=
nsGkAtoms
:
:
flex
|
|
aAttribute
=
=
nsGkAtoms
:
:
orient
|
|
aAttribute
=
=
nsGkAtoms
:
:
pack
|
|
aAttribute
=
=
nsGkAtoms
:
:
dir
|
|
aAttribute
=
=
nsGkAtoms
:
:
mousethrough
|
|
aAttribute
=
=
nsGkAtoms
:
:
equalsize
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
align
|
|
aAttribute
=
=
nsGkAtoms
:
:
valign
|
|
aAttribute
=
=
nsGkAtoms
:
:
orient
|
|
aAttribute
=
=
nsGkAtoms
:
:
pack
|
|
#
ifdef
DEBUG_LAYOUT
aAttribute
=
=
nsGkAtoms
:
:
debug
|
|
#
endif
aAttribute
=
=
nsGkAtoms
:
:
dir
)
{
mValign
=
nsBoxFrame
:
:
vAlign_Top
;
mHalign
=
nsBoxFrame
:
:
hAlign_Left
;
bool
orient
=
true
;
GetInitialOrientation
(
orient
)
;
if
(
orient
)
AddStateBits
(
NS_STATE_IS_HORIZONTAL
)
;
else
RemoveStateBits
(
NS_STATE_IS_HORIZONTAL
)
;
bool
normal
=
true
;
GetInitialDirection
(
normal
)
;
if
(
normal
)
AddStateBits
(
NS_STATE_IS_DIRECTION_NORMAL
)
;
else
RemoveStateBits
(
NS_STATE_IS_DIRECTION_NORMAL
)
;
GetInitialVAlignment
(
mValign
)
;
GetInitialHAlignment
(
mHalign
)
;
bool
equalSize
=
false
;
GetInitialEqualSize
(
equalSize
)
;
if
(
equalSize
)
AddStateBits
(
NS_STATE_EQUAL_SIZE
)
;
else
RemoveStateBits
(
NS_STATE_EQUAL_SIZE
)
;
#
ifdef
DEBUG_LAYOUT
bool
debug
=
mState
&
NS_STATE_SET_TO_DEBUG
;
bool
debugSet
=
GetInitialDebug
(
debug
)
;
if
(
debugSet
)
{
AddStateBits
(
NS_STATE_DEBUG_WAS_SET
)
;
if
(
debug
)
AddStateBits
(
NS_STATE_SET_TO_DEBUG
)
;
else
RemoveStateBits
(
NS_STATE_SET_TO_DEBUG
)
;
}
else
{
RemoveStateBits
(
NS_STATE_DEBUG_WAS_SET
)
;
}
#
endif
bool
autostretch
=
!
!
(
mState
&
NS_STATE_AUTO_STRETCH
)
;
GetInitialAutoStretch
(
autostretch
)
;
if
(
autostretch
)
AddStateBits
(
NS_STATE_AUTO_STRETCH
)
;
else
RemoveStateBits
(
NS_STATE_AUTO_STRETCH
)
;
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
left
|
|
aAttribute
=
=
nsGkAtoms
:
:
top
|
|
aAttribute
=
=
nsGkAtoms
:
:
right
|
|
aAttribute
=
=
nsGkAtoms
:
:
bottom
|
|
aAttribute
=
=
nsGkAtoms
:
:
start
|
|
aAttribute
=
=
nsGkAtoms
:
:
end
)
{
RemoveStateBits
(
NS_STATE_STACK_NOT_POSITIONED
)
;
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
mousethrough
)
{
UpdateMouseThrough
(
)
;
}
PresShell
(
)
-
>
FrameNeedsReflow
(
this
nsIPresShell
:
:
eStyleChange
NS_FRAME_IS_DIRTY
)
;
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
ordinal
)
{
nsIFrame
*
parent
=
GetParentXULBox
(
this
)
;
if
(
parent
&
&
!
(
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
&
&
StyleDisplay
(
)
-
>
mDisplay
!
=
mozilla
:
:
StyleDisplay
:
:
MozPopup
)
{
parent
-
>
XULRelayoutChildAtOrdinal
(
this
)
;
PresShell
(
)
-
>
FrameNeedsReflow
(
parent
nsIPresShell
:
:
eStyleChange
NS_FRAME_IS_DIRTY
)
;
}
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
accesskey
)
{
RegUnregAccessKey
(
true
)
;
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
rows
&
&
mContent
-
>
IsXULElement
(
nsGkAtoms
:
:
tree
)
)
{
PresShell
(
)
-
>
FrameNeedsReflow
(
this
nsIPresShell
:
:
eStyleChange
NS_FRAME_IS_DIRTY
)
;
}
return
rv
;
}
#
ifdef
DEBUG_LAYOUT
void
nsBoxFrame
:
:
GetDebugPref
(
)
{
gDebug
=
Preferences
:
:
GetBool
(
"
xul
.
debug
.
box
"
)
;
}
class
nsDisplayXULDebug
:
public
nsDisplayItem
{
public
:
nsDisplayXULDebug
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
:
nsDisplayItem
(
aBuilder
aFrame
)
{
MOZ_COUNT_CTOR
(
nsDisplayXULDebug
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayXULDebug
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayXULDebug
)
;
}
#
endif
virtual
void
HitTest
(
nsDisplayListBuilder
*
aBuilder
nsRect
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
{
nsPoint
rectCenter
(
aRect
.
x
+
aRect
.
width
/
2
aRect
.
y
+
aRect
.
height
/
2
)
;
static_cast
<
nsBoxFrame
*
>
(
mFrame
)
-
>
DisplayDebugInfoFor
(
this
rectCenter
-
ToReferenceFrame
(
)
)
;
aOutFrames
-
>
AppendElement
(
this
)
;
}
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
;
NS_DISPLAY_DECL_NAME
(
"
XULDebug
"
TYPE_XUL_DEBUG
)
}
;
void
nsDisplayXULDebug
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
static_cast
<
nsBoxFrame
*
>
(
mFrame
)
-
>
PaintXULDebugOverlay
(
*
aCtx
-
>
GetDrawTarget
(
)
ToReferenceFrame
(
)
)
;
}
static
void
PaintXULDebugBackground
(
nsIFrame
*
aFrame
DrawTarget
*
aDrawTarget
const
nsRect
&
aDirtyRect
nsPoint
aPt
)
{
static_cast
<
nsBoxFrame
*
>
(
aFrame
)
-
>
PaintXULDebugBackground
(
aDrawTarget
aPt
)
;
}
#
endif
void
nsBoxFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
bool
forceLayer
=
false
;
if
(
GetContent
(
)
-
>
IsXULElement
(
)
)
{
if
(
GetContent
(
)
-
>
AsElement
(
)
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
layer
)
)
{
forceLayer
=
true
;
}
const
nsStyleDisplay
*
styles
=
StyleDisplay
(
)
;
if
(
styles
&
&
styles
-
>
mAppearance
=
=
NS_THEME_WIN_EXCLUDE_GLASS
)
{
aBuilder
-
>
AddWindowExcludeGlassRegion
(
this
nsRect
(
aBuilder
-
>
ToReferenceFrame
(
this
)
GetSize
(
)
)
)
;
}
}
nsDisplayListCollection
tempLists
(
aBuilder
)
;
const
nsDisplayListSet
&
destination
=
forceLayer
?
tempLists
:
aLists
;
DisplayBorderBackgroundOutline
(
aBuilder
destination
)
;
#
ifdef
DEBUG_LAYOUT
if
(
mState
&
NS_STATE_CURRENTLY_IN_DEBUG
)
{
destination
.
BorderBackground
(
)
-
>
AppendToTop
(
MakeDisplayItem
<
nsDisplayGeneric
>
(
aBuilder
this
PaintXULDebugBackground
"
XULDebugBackground
"
)
)
;
destination
.
Outlines
(
)
-
>
AppendToTop
(
MakeDisplayItem
<
nsDisplayXULDebug
>
(
aBuilder
this
)
)
;
}
#
endif
Maybe
<
nsDisplayListBuilder
:
:
AutoContainerASRTracker
>
contASRTracker
;
if
(
forceLayer
)
{
contASRTracker
.
emplace
(
aBuilder
)
;
}
BuildDisplayListForChildren
(
aBuilder
destination
)
;
DisplaySelectionOverlay
(
aBuilder
destination
.
Content
(
)
)
;
if
(
forceLayer
)
{
nsDisplayList
masterList
;
masterList
.
AppendToTop
(
tempLists
.
BorderBackground
(
)
)
;
masterList
.
AppendToTop
(
tempLists
.
BlockBorderBackgrounds
(
)
)
;
masterList
.
AppendToTop
(
tempLists
.
Floats
(
)
)
;
masterList
.
AppendToTop
(
tempLists
.
Content
(
)
)
;
masterList
.
AppendToTop
(
tempLists
.
PositionedDescendants
(
)
)
;
masterList
.
AppendToTop
(
tempLists
.
Outlines
(
)
)
;
const
ActiveScrolledRoot
*
ownLayerASR
=
contASRTracker
-
>
GetContainerASR
(
)
;
DisplayListClipState
:
:
AutoSaveRestore
ownLayerClipState
(
aBuilder
)
;
aLists
.
Content
(
)
-
>
AppendToTop
(
MakeDisplayItem
<
nsDisplayOwnLayer
>
(
aBuilder
this
&
masterList
ownLayerASR
nsDisplayOwnLayerFlags
:
:
eNone
mozilla
:
:
layers
:
:
FrameMetrics
:
:
NULL_SCROLL_ID
mozilla
:
:
layers
:
:
ScrollThumbData
{
}
true
true
)
)
;
}
}
void
nsBoxFrame
:
:
BuildDisplayListForChildren
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
nsIFrame
*
kid
=
mFrames
.
FirstChild
(
)
;
nsDisplayListSet
set
(
aLists
aLists
.
BlockBorderBackgrounds
(
)
)
;
while
(
kid
)
{
BuildDisplayListForChild
(
aBuilder
kid
set
)
;
kid
=
kid
-
>
GetNextSibling
(
)
;
}
}
#
ifdef
DEBUG_LAYOUT
void
nsBoxFrame
:
:
PaintXULDebugBackground
(
DrawTarget
*
aDrawTarget
nsPoint
aPt
)
{
nsMargin
border
;
GetXULBorder
(
border
)
;
nsMargin
debugBorder
;
nsMargin
debugMargin
;
nsMargin
debugPadding
;
bool
isHorizontal
=
IsXULHorizontal
(
)
;
GetDebugBorder
(
debugBorder
)
;
PixelMarginToTwips
(
debugBorder
)
;
GetDebugMargin
(
debugMargin
)
;
PixelMarginToTwips
(
debugMargin
)
;
GetDebugPadding
(
debugPadding
)
;
PixelMarginToTwips
(
debugPadding
)
;
nsRect
inner
(
mRect
)
;
inner
.
MoveTo
(
aPt
)
;
inner
.
Deflate
(
debugMargin
)
;
inner
.
Deflate
(
border
)
;
int32_t
appUnitsPerDevPixel
=
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
ColorPattern
color
(
ToDeviceColor
(
isHorizontal
?
Color
(
0
.
f
0
.
f
1
.
f
1
.
f
)
:
Color
(
1
.
f
0
.
f
0
.
f
1
.
f
)
)
)
;
nsRect
r
(
inner
)
;
r
.
width
=
debugBorder
.
left
;
aDrawTarget
-
>
FillRect
(
NSRectToRect
(
r
appUnitsPerDevPixel
)
color
)
;
r
=
inner
;
r
.
height
=
debugBorder
.
top
;
aDrawTarget
-
>
FillRect
(
NSRectToRect
(
r
appUnitsPerDevPixel
)
color
)
;
r
=
inner
;
r
.
x
=
r
.
x
+
r
.
width
-
debugBorder
.
right
;
r
.
width
=
debugBorder
.
right
;
aDrawTarget
-
>
FillRect
(
NSRectToRect
(
r
appUnitsPerDevPixel
)
color
)
;
r
=
inner
;
r
.
y
=
r
.
y
+
r
.
height
-
debugBorder
.
bottom
;
r
.
height
=
debugBorder
.
bottom
;
aDrawTarget
-
>
FillRect
(
NSRectToRect
(
r
appUnitsPerDevPixel
)
color
)
;
if
(
NS_SUBTREE_DIRTY
(
this
)
)
{
nsRect
dirty
(
inner
)
;
ColorPattern
green
(
ToDeviceColor
(
Color
(
0
.
f
1
.
f
0
.
f
1
.
f
)
)
)
;
aDrawTarget
-
>
StrokeRect
(
NSRectToRect
(
dirty
appUnitsPerDevPixel
)
green
)
;
}
}
void
nsBoxFrame
:
:
PaintXULDebugOverlay
(
DrawTarget
&
aDrawTarget
nsPoint
aPt
)
{
nsMargin
border
;
GetXULBorder
(
border
)
;
nsMargin
debugMargin
;
GetDebugMargin
(
debugMargin
)
;
PixelMarginToTwips
(
debugMargin
)
;
nsRect
inner
(
mRect
)
;
inner
.
MoveTo
(
aPt
)
;
inner
.
Deflate
(
debugMargin
)
;
inner
.
Deflate
(
border
)
;
nscoord
onePixel
=
GetPresContext
(
)
-
>
IntScaledPixelsToTwips
(
1
)
;
kid
=
nsBox
:
:
GetChildXULBox
(
this
)
;
while
(
nullptr
!
=
kid
)
{
bool
isHorizontal
=
IsXULHorizontal
(
)
;
nscoord
x
y
borderSize
spacerSize
;
nsRect
cr
(
kid
-
>
mRect
)
;
nsMargin
margin
;
kid
-
>
GetXULMargin
(
margin
)
;
cr
.
Inflate
(
margin
)
;
if
(
isHorizontal
)
{
cr
.
y
=
inner
.
y
;
x
=
cr
.
x
;
y
=
cr
.
y
+
onePixel
;
spacerSize
=
debugBorder
.
top
-
onePixel
*
4
;
}
else
{
cr
.
x
=
inner
.
x
;
x
=
cr
.
y
;
y
=
cr
.
x
+
onePixel
;
spacerSize
=
debugBorder
.
left
-
onePixel
*
4
;
}
nscoord
flex
=
kid
-
>
GetXULFlex
(
)
;
if
(
!
kid
-
>
IsXULCollapsed
(
)
)
{
if
(
isHorizontal
)
borderSize
=
cr
.
width
;
else
borderSize
=
cr
.
height
;
DrawSpacer
(
GetPresContext
(
)
aDrawTarget
isHorizontal
flex
x
y
borderSize
spacerSize
)
;
}
kid
=
GetNextXULBox
(
kid
)
;
}
}
#
endif
#
ifdef
DEBUG_LAYOUT
void
nsBoxFrame
:
:
GetBoxName
(
nsAutoString
&
aName
)
{
GetFrameName
(
aName
)
;
}
#
endif
#
ifdef
DEBUG_FRAME_DUMP
nsresult
nsBoxFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
NS_LITERAL_STRING
(
"
Box
"
)
aResult
)
;
}
#
endif
#
ifdef
DEBUG_LAYOUT
nsresult
nsBoxFrame
:
:
GetXULDebug
(
bool
&
aDebug
)
{
aDebug
=
(
mState
&
NS_STATE_CURRENTLY_IN_DEBUG
)
;
return
NS_OK
;
}
#
endif
#
ifdef
DEBUG_LAYOUT
void
nsBoxFrame
:
:
DrawLine
(
DrawTarget
&
aDrawTarget
bool
aHorizontal
nscoord
x1
nscoord
y1
nscoord
x2
nscoord
y2
)
{
nsPoint
p1
(
x1
y1
)
;
nsPoint
p2
(
x2
y2
)
;
if
(
!
aHorizontal
)
{
Swap
(
p1
.
x
p1
.
y
)
;
Swap
(
p2
.
x
p2
.
y
)
;
}
ColorPattern
white
(
ToDeviceColor
(
Color
(
1
.
f
1
.
f
1
.
f
1
.
f
)
)
)
;
StrokeLineWithSnapping
(
p1
p2
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
aDrawTarget
color
)
;
}
void
nsBoxFrame
:
:
FillRect
(
DrawTarget
&
aDrawTarget
bool
aHorizontal
nscoord
x
nscoord
y
nscoord
width
nscoord
height
)
{
Rect
rect
=
NSRectToSnappedRect
(
aHorizontal
?
nsRect
(
x
y
width
height
)
:
nsRect
(
y
x
height
width
)
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
aDrawTarget
)
;
ColorPattern
white
(
ToDeviceColor
(
Color
(
1
.
f
1
.
f
1
.
f
1
.
f
)
)
)
;
aDrawTarget
.
FillRect
(
rect
white
)
;
}
void
nsBoxFrame
:
:
DrawSpacer
(
nsPresContext
*
aPresContext
DrawTarget
&
aDrawTarget
bool
aHorizontal
int32_t
flex
nscoord
x
nscoord
y
nscoord
size
nscoord
spacerSize
)
{
nscoord
onePixel
=
aPresContext
-
>
IntScaledPixelsToTwips
(
1
)
;
int
distance
=
0
;
int
center
=
0
;
int
offset
=
0
;
int
coilSize
=
COIL_SIZE
*
onePixel
;
int
halfSpacer
=
spacerSize
/
2
;
distance
=
size
;
center
=
y
+
halfSpacer
;
offset
=
x
;
int
coils
=
distance
/
coilSize
;
int
halfCoilSize
=
coilSize
/
2
;
if
(
flex
=
=
0
)
{
DrawLine
(
aDrawTarget
aHorizontal
x
y
+
spacerSize
/
2
x
+
size
y
+
spacerSize
/
2
)
;
}
else
{
for
(
int
i
=
0
;
i
<
coils
;
i
+
+
)
{
DrawLine
(
aDrawTarget
aHorizontal
offset
center
+
halfSpacer
offset
+
halfCoilSize
center
-
halfSpacer
)
;
DrawLine
(
aDrawTarget
aHorizontal
offset
+
halfCoilSize
center
-
halfSpacer
offset
+
coilSize
center
+
halfSpacer
)
;
offset
+
=
coilSize
;
}
}
FillRect
(
aDrawTarget
aHorizontal
x
+
size
-
spacerSize
/
2
y
spacerSize
/
2
spacerSize
)
;
FillRect
(
aDrawTarget
aHorizontal
x
y
spacerSize
/
2
spacerSize
)
;
}
void
nsBoxFrame
:
:
GetDebugBorder
(
nsMargin
&
aInset
)
{
aInset
.
SizeTo
(
2
2
2
2
)
;
if
(
IsXULHorizontal
(
)
)
aInset
.
top
=
10
;
else
aInset
.
left
=
10
;
}
void
nsBoxFrame
:
:
GetDebugMargin
(
nsMargin
&
aInset
)
{
aInset
.
SizeTo
(
2
2
2
2
)
;
}
void
nsBoxFrame
:
:
GetDebugPadding
(
nsMargin
&
aPadding
)
{
aPadding
.
SizeTo
(
2
2
2
2
)
;
}
void
nsBoxFrame
:
:
PixelMarginToTwips
(
nsMargin
&
aMarginPixels
)
{
nscoord
onePixel
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
1
)
;
aMarginPixels
.
left
*
=
onePixel
;
aMarginPixels
.
right
*
=
onePixel
;
aMarginPixels
.
top
*
=
onePixel
;
aMarginPixels
.
bottom
*
=
onePixel
;
}
void
nsBoxFrame
:
:
GetValue
(
nsPresContext
*
aPresContext
const
nsSize
&
a
const
nsSize
&
b
char
*
ch
)
{
float
p2t
=
aPresContext
-
>
ScaledPixelsToTwips
(
)
;
char
width
[
100
]
;
char
height
[
100
]
;
if
(
a
.
width
=
=
NS_INTRINSICSIZE
)
sprintf
(
width
"
%
s
"
"
INF
"
)
;
else
sprintf
(
width
"
%
d
"
nscoord
(
a
.
width
)
)
;
if
(
a
.
height
=
=
NS_INTRINSICSIZE
)
sprintf
(
height
"
%
s
"
"
INF
"
)
;
else
sprintf
(
height
"
%
d
"
nscoord
(
a
.
height
)
)
;
sprintf
(
ch
"
(
%
s
%
s
%
s
%
s
)
"
width
(
b
.
width
!
=
NS_INTRINSICSIZE
?
"
[
SET
]
"
:
"
"
)
height
(
b
.
height
!
=
NS_INTRINSICSIZE
?
"
[
SET
]
"
:
"
"
)
)
;
}
void
nsBoxFrame
:
:
GetValue
(
nsPresContext
*
aPresContext
int32_t
a
int32_t
b
char
*
ch
)
{
if
(
a
=
=
NS_INTRINSICSIZE
)
sprintf
(
ch
"
%
d
[
SET
]
"
b
)
;
else
sprintf
(
ch
"
%
d
"
a
)
;
}
nsresult
nsBoxFrame
:
:
DisplayDebugInfoFor
(
nsIFrame
*
aBox
nsPoint
&
aPoint
)
{
nsBoxLayoutState
state
(
GetPresContext
(
)
)
;
nscoord
x
=
aPoint
.
x
;
nscoord
y
=
aPoint
.
y
;
nsRect
insideBorder
(
aBox
-
>
mRect
)
;
insideBorder
.
MoveTo
(
0
0
)
:
nsMargin
border
(
0
0
0
0
)
;
aBox
-
>
GetXULBorderAndPadding
(
border
)
;
insideBorder
.
Deflate
(
border
)
;
bool
isHorizontal
=
IsXULHorizontal
(
)
;
if
(
!
insideBorder
.
Contains
(
nsPoint
(
x
y
)
)
)
return
NS_ERROR_FAILURE
;
int
count
=
0
;
nsIFrame
*
child
=
nsBox
:
:
GetChildXULBox
(
aBox
)
;
nsMargin
m
;
nsMargin
m2
;
GetDebugBorder
(
m
)
;
PixelMarginToTwips
(
m
)
;
GetDebugMargin
(
m2
)
;
PixelMarginToTwips
(
m2
)
;
m
+
=
m2
;
if
(
(
isHorizontal
&
&
y
<
insideBorder
.
y
+
m
.
top
)
|
|
(
!
isHorizontal
&
&
x
<
insideBorder
.
x
+
m
.
left
)
)
{
while
(
child
)
{
const
nsRect
&
r
=
child
-
>
mRect
;
if
(
(
isHorizontal
&
&
x
>
=
r
.
x
&
&
x
<
r
.
x
+
r
.
width
)
|
|
(
!
isHorizontal
&
&
y
>
=
r
.
y
&
&
y
<
r
.
y
+
r
.
height
)
)
{
aCursor
=
NS_STYLE_CURSOR_POINTER
;
if
(
mDebugChild
=
=
child
)
return
NS_OK
;
if
(
aBox
-
>
GetContent
(
)
)
{
printf
(
"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
\
n
"
)
;
XULDumpBox
(
stdout
)
;
printf
(
"
\
n
"
)
;
}
if
(
child
-
>
GetContent
(
)
)
{
printf
(
"
child
#
%
d
:
"
count
)
;
child
-
>
XULDumpBox
(
stdout
)
;
printf
(
"
\
n
"
)
;
}
mDebugChild
=
child
;
nsSize
prefSizeCSS
(
NS_INTRINSICSIZE
NS_INTRINSICSIZE
)
;
nsSize
minSizeCSS
(
NS_INTRINSICSIZE
NS_INTRINSICSIZE
)
;
nsSize
maxSizeCSS
(
NS_INTRINSICSIZE
NS_INTRINSICSIZE
)
;
nscoord
flexCSS
=
NS_INTRINSICSIZE
;
bool
widthSet
heightSet
;
nsIFrame
:
:
AddXULPrefSize
(
child
prefSizeCSS
widthSet
heightSet
)
;
nsIFrame
:
:
AddXULMinSize
(
state
child
minSizeCSS
widthSet
heightSet
)
;
nsIFrame
:
:
AddXULMaxSize
(
child
maxSizeCSS
widthSet
heightSet
)
;
nsIFrame
:
:
AddXULFlex
(
child
flexCSS
)
;
nsSize
prefSize
=
child
-
>
GetXULPrefSize
(
state
)
;
nsSize
minSize
=
child
-
>
GetXULMinSize
(
state
)
;
nsSize
maxSize
=
child
-
>
GetXULMaxSize
(
state
)
;
nscoord
flexSize
=
child
-
>
GetXULFlex
(
)
;
nscoord
ascentSize
=
child
-
>
GetXULBoxAscent
(
state
)
;
char
min
[
100
]
;
char
pref
[
100
]
;
char
max
[
100
]
;
char
calc
[
100
]
;
char
flex
[
100
]
;
char
ascent
[
100
]
;
nsSize
actualSize
;
GetFrameSizeWithMargin
(
child
actualSize
)
;
nsSize
actualSizeCSS
(
NS_INTRINSICSIZE
NS_INTRINSICSIZE
)
;
GetValue
(
aPresContext
minSize
minSizeCSS
min
)
;
GetValue
(
aPresContext
prefSize
prefSizeCSS
pref
)
;
GetValue
(
aPresContext
maxSize
maxSizeCSS
max
)
;
GetValue
(
aPresContext
actualSize
actualSizeCSS
calc
)
;
GetValue
(
aPresContext
flexSize
flexCSS
flex
)
;
GetValue
(
aPresContext
ascentSize
NS_INTRINSICSIZE
ascent
)
;
printf
(
"
min
%
s
pref
%
s
max
%
s
actual
%
s
flex
=
%
s
ascent
=
%
s
\
n
\
n
"
min
pref
max
calc
flex
ascent
)
;
return
NS_OK
;
}
child
=
GetNextXULBox
(
child
)
;
count
+
+
;
}
}
else
{
}
mDebugChild
=
nullptr
;
return
NS_OK
;
}
void
nsBoxFrame
:
:
SetDebugOnChildList
(
nsBoxLayoutState
&
aState
nsIFrame
*
aChild
bool
aDebug
)
{
nsIFrame
*
child
=
nsBox
:
:
GetChildXULBox
(
this
)
;
while
(
child
)
{
child
-
>
SetXULDebug
(
aState
aDebug
)
;
child
=
GetNextXULBox
(
child
)
;
}
}
nsresult
nsBoxFrame
:
:
GetFrameSizeWithMargin
(
nsIFrame
*
aBox
nsSize
&
aSize
)
{
nsRect
rect
(
aBox
-
>
GetRect
(
)
)
;
nsMargin
margin
(
0
0
0
0
)
;
aBox
-
>
GetXULMargin
(
margin
)
;
rect
.
Inflate
(
margin
)
;
aSize
.
width
=
rect
.
width
;
aSize
.
height
=
rect
.
height
;
return
NS_OK
;
}
#
endif
void
nsBoxFrame
:
:
RegUnregAccessKey
(
bool
aDoReg
)
{
MOZ_ASSERT
(
mContent
)
;
if
(
!
mContent
-
>
IsAnyOfXULElements
(
nsGkAtoms
:
:
button
nsGkAtoms
:
:
toolbarbutton
nsGkAtoms
:
:
checkbox
nsGkAtoms
:
:
textbox
nsGkAtoms
:
:
tab
nsGkAtoms
:
:
radio
)
)
{
return
;
}
nsAutoString
accessKey
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
accesskey
accessKey
)
;
if
(
accessKey
.
IsEmpty
(
)
)
return
;
EventStateManager
*
esm
=
PresContext
(
)
-
>
EventStateManager
(
)
;
uint32_t
key
=
accessKey
.
First
(
)
;
if
(
aDoReg
)
esm
-
>
RegisterAccessKey
(
mContent
-
>
AsElement
(
)
key
)
;
else
esm
-
>
UnregisterAccessKey
(
mContent
-
>
AsElement
(
)
key
)
;
}
bool
nsBoxFrame
:
:
SupportsOrdinalsInChildren
(
)
{
return
true
;
}
void
nsBoxFrame
:
:
AppendDirectlyOwnedAnonBoxes
(
nsTArray
<
OwnedAnonBox
>
&
aResult
)
{
if
(
GetStateBits
(
)
&
NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK
)
{
aResult
.
AppendElement
(
OwnedAnonBox
(
PrincipalChildList
(
)
.
FirstChild
(
)
)
)
;
}
}
bool
IsBoxOrdinalLEQ
(
nsIFrame
*
aFrame1
nsIFrame
*
aFrame2
)
{
nsIFrame
*
aRealFrame1
=
nsPlaceholderFrame
:
:
GetRealFrameFor
(
aFrame1
)
;
nsIFrame
*
aRealFrame2
=
nsPlaceholderFrame
:
:
GetRealFrameFor
(
aFrame2
)
;
return
aRealFrame1
-
>
GetXULOrdinal
(
)
<
=
aRealFrame2
-
>
GetXULOrdinal
(
)
;
}
void
nsBoxFrame
:
:
CheckBoxOrder
(
)
{
if
(
SupportsOrdinalsInChildren
(
)
&
&
!
nsIFrame
:
:
IsFrameListSorted
<
IsBoxOrdinalLEQ
>
(
mFrames
)
)
{
nsIFrame
:
:
SortFrameList
<
IsBoxOrdinalLEQ
>
(
mFrames
)
;
}
}
nsresult
nsBoxFrame
:
:
LayoutChildAt
(
nsBoxLayoutState
&
aState
nsIFrame
*
aBox
const
nsRect
&
aRect
)
{
nsRect
oldRect
(
aBox
-
>
GetRect
(
)
)
;
aBox
-
>
SetXULBounds
(
aState
aRect
)
;
bool
layout
=
NS_SUBTREE_DIRTY
(
aBox
)
;
if
(
layout
|
|
(
oldRect
.
width
!
=
aRect
.
width
|
|
oldRect
.
height
!
=
aRect
.
height
)
)
{
return
aBox
-
>
XULLayout
(
aState
)
;
}
return
NS_OK
;
}
nsresult
nsBoxFrame
:
:
XULRelayoutChildAtOrdinal
(
nsIFrame
*
aChild
)
{
if
(
!
SupportsOrdinalsInChildren
(
)
)
return
NS_OK
;
uint32_t
ord
=
aChild
-
>
GetXULOrdinal
(
)
;
nsIFrame
*
child
=
mFrames
.
FirstChild
(
)
;
nsIFrame
*
newPrevSib
=
nullptr
;
while
(
child
)
{
if
(
ord
<
child
-
>
GetXULOrdinal
(
)
)
{
break
;
}
if
(
child
!
=
aChild
)
{
newPrevSib
=
child
;
}
child
=
GetNextXULBox
(
child
)
;
}
if
(
aChild
-
>
GetPrevSibling
(
)
=
=
newPrevSib
)
{
return
NS_OK
;
}
mFrames
.
RemoveFrame
(
aChild
)
;
mFrames
.
InsertFrame
(
nullptr
newPrevSib
aChild
)
;
return
NS_OK
;
}
class
nsDisplayXULEventRedirector
final
:
public
nsDisplayWrapList
{
public
:
nsDisplayXULEventRedirector
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayItem
*
aItem
nsIFrame
*
aTargetFrame
)
:
nsDisplayWrapList
(
aBuilder
aFrame
aItem
)
mTargetFrame
(
aTargetFrame
)
{
}
nsDisplayXULEventRedirector
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
nsIFrame
*
aTargetFrame
)
:
nsDisplayWrapList
(
aBuilder
aFrame
aList
)
mTargetFrame
(
aTargetFrame
)
{
}
virtual
void
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
override
;
virtual
bool
ShouldFlattenAway
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
false
;
}
NS_DISPLAY_DECL_NAME
(
"
XULEventRedirector
"
TYPE_XUL_EVENT_REDIRECTOR
)
private
:
nsIFrame
*
mTargetFrame
;
}
;
void
nsDisplayXULEventRedirector
:
:
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
{
nsTArray
<
nsIFrame
*
>
outFrames
;
mList
.
HitTest
(
aBuilder
aRect
aState
&
outFrames
)
;
bool
topMostAdded
=
false
;
uint32_t
localLength
=
outFrames
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
localLength
;
i
+
+
)
{
for
(
nsIContent
*
content
=
outFrames
.
ElementAt
(
i
)
-
>
GetContent
(
)
;
content
&
&
content
!
=
mTargetFrame
-
>
GetContent
(
)
;
content
=
content
-
>
GetParent
(
)
)
{
if
(
!
content
-
>
IsElement
(
)
|
|
!
content
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
allowevents
nsGkAtoms
:
:
_true
eCaseMatters
)
)
{
continue
;
}
aOutFrames
-
>
AppendElement
(
outFrames
.
ElementAt
(
i
)
)
;
topMostAdded
=
true
;
}
if
(
!
topMostAdded
)
{
topMostAdded
=
true
;
aOutFrames
-
>
AppendElement
(
mTargetFrame
)
;
}
}
}
class
nsXULEventRedirectorWrapper
final
:
public
nsDisplayWrapper
{
public
:
explicit
nsXULEventRedirectorWrapper
(
nsIFrame
*
aTargetFrame
)
:
mTargetFrame
(
aTargetFrame
)
{
}
virtual
nsDisplayItem
*
WrapList
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
)
override
{
return
MakeDisplayItem
<
nsDisplayXULEventRedirector
>
(
aBuilder
aFrame
aList
mTargetFrame
)
;
}
virtual
nsDisplayItem
*
WrapItem
(
nsDisplayListBuilder
*
aBuilder
nsDisplayItem
*
aItem
)
override
{
return
MakeDisplayItem
<
nsDisplayXULEventRedirector
>
(
aBuilder
aItem
-
>
Frame
(
)
aItem
mTargetFrame
)
;
}
private
:
nsIFrame
*
mTargetFrame
;
}
;
void
nsBoxFrame
:
:
WrapListsInRedirector
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aIn
const
nsDisplayListSet
&
aOut
)
{
nsXULEventRedirectorWrapper
wrapper
(
this
)
;
wrapper
.
WrapLists
(
aBuilder
this
aIn
aOut
)
;
}
bool
nsBoxFrame
:
:
GetEventPoint
(
WidgetGUIEvent
*
aEvent
nsPoint
&
aPoint
)
{
LayoutDeviceIntPoint
refPoint
;
bool
res
=
GetEventPoint
(
aEvent
refPoint
)
;
aPoint
=
nsLayoutUtils
:
:
GetEventCoordinatesRelativeTo
(
aEvent
refPoint
this
)
;
return
res
;
}
bool
nsBoxFrame
:
:
GetEventPoint
(
WidgetGUIEvent
*
aEvent
LayoutDeviceIntPoint
&
aPoint
)
{
NS_ENSURE_TRUE
(
aEvent
false
)
;
WidgetTouchEvent
*
touchEvent
=
aEvent
-
>
AsTouchEvent
(
)
;
if
(
touchEvent
)
{
if
(
touchEvent
-
>
mTouches
.
Length
(
)
!
=
1
)
{
return
false
;
}
dom
:
:
Touch
*
touch
=
touchEvent
-
>
mTouches
.
SafeElementAt
(
0
)
;
if
(
!
touch
)
{
return
false
;
}
aPoint
=
touch
-
>
mRefPoint
;
}
else
{
aPoint
=
aEvent
-
>
mRefPoint
;
}
return
true
;
}
