#
include
"
nsMenuPopupFrame
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
mozilla
/
ComputedStyle
.
h
"
#
include
"
nsCSSRendering
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsWidgetsCID
.
h
"
#
include
"
nsMenuFrame
.
h
"
#
include
"
nsMenuBarFrame
.
h
"
#
include
"
nsPopupSetFrame
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsFrameManager
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsIComponentManager
.
h
"
#
include
"
nsBoxLayoutState
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsIPopupContainer
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
nsPIWindowRoot
.
h
"
#
include
"
nsIReflowCallback
.
h
"
#
include
"
nsBindingManager
.
h
"
#
include
"
nsIDocShellTreeOwner
.
h
"
#
include
"
nsIBaseWindow
.
h
"
#
include
"
nsISound
.
h
"
#
include
"
nsIScreenManager
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsTransitionManager
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsIDOMXULSelectCntrlItemEl
.
h
"
#
include
"
mozilla
/
AnimationUtils
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
KeyboardEvent
.
h
"
#
include
"
mozilla
/
dom
/
KeyboardEventBinding
.
h
"
#
include
<
algorithm
>
#
ifdef
MOZ_WAYLAND
#
include
<
gdk
/
gdk
.
h
>
#
include
<
gdk
/
gdkx
.
h
>
#
include
<
gdk
/
gdkwayland
.
h
>
#
endif
using
namespace
mozilla
;
using
mozilla
:
:
dom
:
:
Document
;
using
mozilla
:
:
dom
:
:
Event
;
using
mozilla
:
:
dom
:
:
KeyboardEvent
;
int8_t
nsMenuPopupFrame
:
:
sDefaultLevelIsTop
=
-
1
;
DOMTimeStamp
nsMenuPopupFrame
:
:
sLastKeyTime
=
0
;
uint32_t
nsMenuPopupFrame
:
:
sTimeoutOfIncrementalSearch
=
1000
;
const
char
kPrefIncrementalSearchTimeout
[
]
=
"
ui
.
menu
.
incremental_search
.
timeout
"
;
nsIFrame
*
NS_NewMenuPopupFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsMenuPopupFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsMenuPopupFrame
)
NS_QUERYFRAME_HEAD
(
nsMenuPopupFrame
)
NS_QUERYFRAME_ENTRY
(
nsMenuPopupFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsBoxFrame
)
nsMenuPopupFrame
:
:
nsMenuPopupFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
:
nsBoxFrame
(
aStyle
aPresContext
kClassID
)
mCurrentMenu
(
nullptr
)
mView
(
nullptr
)
mPrefSize
(
-
1
-
1
)
mXPos
(
0
)
mYPos
(
0
)
mAlignmentOffset
(
0
)
mLastClientOffset
(
0
0
)
mPopupType
(
ePopupTypePanel
)
mPopupState
(
ePopupClosed
)
mPopupAlignment
(
POPUPALIGNMENT_NONE
)
mPopupAnchor
(
POPUPALIGNMENT_NONE
)
mPosition
(
POPUPPOSITION_UNKNOWN
)
mFlip
(
FlipType_Default
)
mIsOpenChanged
(
false
)
mIsContextMenu
(
false
)
mAdjustOffsetForContextMenu
(
false
)
mGeneratedChildren
(
false
)
mMenuCanOverlapOSBar
(
false
)
mShouldAutoPosition
(
true
)
mInContentShell
(
true
)
mIsMenuLocked
(
false
)
mMouseTransparent
(
false
)
mIsOffset
(
false
)
mHFlip
(
false
)
mVFlip
(
false
)
mPositionedOffset
(
0
)
mAnchorType
(
MenuPopupAnchorType_Node
)
{
if
(
sDefaultLevelIsTop
>
=
0
)
return
;
sDefaultLevelIsTop
=
Preferences
:
:
GetBool
(
"
ui
.
panel
.
default_level_parent
"
false
)
;
Preferences
:
:
AddUintVarCache
(
&
sTimeoutOfIncrementalSearch
kPrefIncrementalSearchTimeout
1000
)
;
}
void
nsMenuPopupFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
nsBoxFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
mMenuCanOverlapOSBar
=
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
eIntID_MenusCanOverlapOSBar
)
!
=
0
;
CreatePopupView
(
)
;
nsView
*
ourView
=
GetView
(
)
;
nsViewManager
*
viewManager
=
ourView
-
>
GetViewManager
(
)
;
viewManager
-
>
SetViewFloating
(
ourView
true
)
;
mPopupType
=
ePopupTypePanel
;
if
(
aContent
-
>
IsAnyOfXULElements
(
nsGkAtoms
:
:
menupopup
nsGkAtoms
:
:
popup
)
)
{
mPopupType
=
ePopupTypeMenu
;
}
else
if
(
aContent
-
>
IsXULElement
(
nsGkAtoms
:
:
tooltip
)
)
{
mPopupType
=
ePopupTypeTooltip
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
dsti
=
PresContext
(
)
-
>
GetDocShell
(
)
;
if
(
dsti
&
&
dsti
-
>
ItemType
(
)
=
=
nsIDocShellTreeItem
:
:
typeChrome
)
{
mInContentShell
=
false
;
}
if
(
aContent
-
>
NodePrincipal
(
)
-
>
IsSystemPrincipal
(
)
)
{
if
(
aContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
incontentshell
nsGkAtoms
:
:
_true
eCaseMatters
)
)
{
mInContentShell
=
true
;
}
else
if
(
aContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
incontentshell
nsGkAtoms
:
:
_false
eCaseMatters
)
)
{
mInContentShell
=
false
;
}
}
if
(
!
IsLeaf
(
)
&
&
!
ourView
-
>
HasWidget
(
)
)
{
CreateWidgetForView
(
ourView
)
;
}
if
(
aContent
-
>
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
tooltip
kNameSpaceID_XUL
)
&
&
aContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
_default
nsGkAtoms
:
:
_true
eIgnoreCase
)
)
{
nsIPopupContainer
*
popupContainer
=
nsIPopupContainer
:
:
GetPopupContainer
(
PresContext
(
)
-
>
GetPresShell
(
)
)
;
if
(
popupContainer
)
{
popupContainer
-
>
SetDefaultTooltip
(
aContent
-
>
AsElement
(
)
)
;
}
}
AddStateBits
(
NS_FRAME_IN_POPUP
)
;
}
bool
nsMenuPopupFrame
:
:
HasRemoteContent
(
)
const
{
return
(
!
mInContentShell
&
&
mPopupType
=
=
ePopupTypePanel
&
&
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
remote
nsGkAtoms
:
:
_true
eIgnoreCase
)
)
;
}
bool
nsMenuPopupFrame
:
:
IsNoAutoHide
(
)
const
{
return
(
!
mInContentShell
&
&
mPopupType
=
=
ePopupTypePanel
&
&
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
noautohide
nsGkAtoms
:
:
_true
eIgnoreCase
)
)
;
}
nsPopupLevel
nsMenuPopupFrame
:
:
PopupLevel
(
bool
aIsNoAutoHide
)
const
{
if
(
mPopupType
!
=
ePopupTypePanel
)
return
ePopupLevelTop
;
static
Element
:
:
AttrValuesArray
strings
[
]
=
{
nsGkAtoms
:
:
top
nsGkAtoms
:
:
parent
nsGkAtoms
:
:
floating
nullptr
}
;
switch
(
mContent
-
>
AsElement
(
)
-
>
FindAttrValueIn
(
kNameSpaceID_None
nsGkAtoms
:
:
level
strings
eCaseMatters
)
)
{
case
0
:
return
ePopupLevelTop
;
case
1
:
return
ePopupLevelParent
;
case
2
:
return
ePopupLevelFloating
;
}
if
(
mContent
-
>
AsElement
(
)
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
titlebar
)
)
return
ePopupLevelFloating
;
if
(
aIsNoAutoHide
)
return
ePopupLevelParent
;
return
sDefaultLevelIsTop
?
ePopupLevelTop
:
ePopupLevelParent
;
}
void
nsMenuPopupFrame
:
:
EnsureWidget
(
bool
aRecreate
)
{
nsView
*
ourView
=
GetView
(
)
;
if
(
aRecreate
)
{
ourView
-
>
DestroyWidget
(
)
;
}
if
(
!
ourView
-
>
HasWidget
(
)
)
{
NS_ASSERTION
(
!
mGeneratedChildren
&
&
!
PrincipalChildList
(
)
.
FirstChild
(
)
"
Creating
widget
for
MenuPopupFrame
with
children
"
)
;
CreateWidgetForView
(
ourView
)
;
}
}
nsresult
nsMenuPopupFrame
:
:
CreateWidgetForView
(
nsView
*
aView
)
{
nsWidgetInitData
widgetData
;
widgetData
.
mWindowType
=
eWindowType_popup
;
widgetData
.
mBorderStyle
=
eBorderStyle_default
;
widgetData
.
clipSiblings
=
true
;
widgetData
.
mPopupHint
=
mPopupType
;
widgetData
.
mNoAutoHide
=
IsNoAutoHide
(
)
;
if
(
!
mInContentShell
)
{
if
(
mPopupType
=
=
ePopupTypePanel
&
&
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
type
nsGkAtoms
:
:
drag
eIgnoreCase
)
)
{
widgetData
.
mIsDragPopup
=
true
;
}
mMouseTransparent
=
GetStateBits
(
)
&
NS_FRAME_MOUSE_THROUGH_ALWAYS
;
widgetData
.
mMouseTransparent
=
mMouseTransparent
;
}
nsAutoString
title
;
if
(
widgetData
.
mNoAutoHide
)
{
if
(
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
titlebar
nsGkAtoms
:
:
normal
eCaseMatters
)
)
{
widgetData
.
mBorderStyle
=
eBorderStyle_title
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
label
title
)
;
if
(
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
close
nsGkAtoms
:
:
_true
eCaseMatters
)
)
{
widgetData
.
mBorderStyle
=
static_cast
<
enum
nsBorderStyle
>
(
widgetData
.
mBorderStyle
|
eBorderStyle_close
)
;
}
}
}
bool
remote
=
HasRemoteContent
(
)
;
nsTransparencyMode
mode
=
nsLayoutUtils
:
:
GetFrameTransparency
(
this
this
)
;
nsIContent
*
parentContent
=
GetContent
(
)
-
>
GetParent
(
)
;
nsAtom
*
tag
=
nullptr
;
if
(
parentContent
&
&
parentContent
-
>
IsXULElement
(
)
)
tag
=
parentContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
widgetData
.
mHasRemoteContent
=
remote
;
widgetData
.
mSupportTranslucency
=
mode
=
=
eTransparencyTransparent
;
widgetData
.
mDropShadow
=
!
(
mode
=
=
eTransparencyTransparent
|
|
tag
=
=
nsGkAtoms
:
:
menulist
)
;
widgetData
.
mPopupLevel
=
PopupLevel
(
widgetData
.
mNoAutoHide
)
;
nsCOMPtr
<
nsIWidget
>
parentWidget
;
if
(
widgetData
.
mPopupLevel
!
=
ePopupLevelTop
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
dsti
=
PresContext
(
)
-
>
GetDocShell
(
)
;
if
(
!
dsti
)
return
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsIDocShellTreeOwner
>
treeOwner
;
dsti
-
>
GetTreeOwner
(
getter_AddRefs
(
treeOwner
)
)
;
if
(
!
treeOwner
)
return
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsIBaseWindow
>
baseWindow
(
do_QueryInterface
(
treeOwner
)
)
;
if
(
baseWindow
)
baseWindow
-
>
GetMainWidget
(
getter_AddRefs
(
parentWidget
)
)
;
}
nsresult
rv
=
aView
-
>
CreateWidgetForPopup
(
&
widgetData
parentWidget
true
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsIWidget
*
widget
=
aView
-
>
GetWidget
(
)
;
widget
-
>
SetTransparencyMode
(
mode
)
;
widget
-
>
SetWindowShadowStyle
(
GetShadowStyle
(
)
)
;
if
(
!
title
.
IsEmpty
(
)
)
{
widget
-
>
SetTitle
(
title
)
;
}
return
NS_OK
;
}
uint8_t
nsMenuPopupFrame
:
:
GetShadowStyle
(
)
{
uint8_t
shadow
=
StyleUIReset
(
)
-
>
mWindowShadow
;
if
(
shadow
!
=
NS_STYLE_WINDOW_SHADOW_DEFAULT
)
return
shadow
;
switch
(
StyleDisplay
(
)
-
>
mAppearance
)
{
case
StyleAppearance
:
:
Tooltip
:
return
NS_STYLE_WINDOW_SHADOW_TOOLTIP
;
case
StyleAppearance
:
:
Menupopup
:
return
NS_STYLE_WINDOW_SHADOW_MENU
;
default
:
return
NS_STYLE_WINDOW_SHADOW_DEFAULT
;
}
}
NS_IMETHODIMP
nsXULPopupShownEvent
:
:
Run
(
)
{
nsMenuPopupFrame
*
popup
=
do_QueryFrame
(
mPopup
-
>
GetPrimaryFrame
(
)
)
;
if
(
popup
&
&
popup
-
>
IsOpen
(
)
)
{
popup
-
>
SetPopupState
(
ePopupShown
)
;
}
WidgetMouseEvent
event
(
true
eXULPopupShown
nullptr
WidgetMouseEvent
:
:
eReal
)
;
return
EventDispatcher
:
:
Dispatch
(
mPopup
mPresContext
&
event
)
;
}
NS_IMETHODIMP
nsXULPopupShownEvent
:
:
HandleEvent
(
Event
*
aEvent
)
{
nsMenuPopupFrame
*
popup
=
do_QueryFrame
(
mPopup
-
>
GetPrimaryFrame
(
)
)
;
if
(
mPopup
!
=
aEvent
-
>
GetTarget
(
)
)
{
return
NS_OK
;
}
if
(
popup
)
{
RefPtr
<
nsXULPopupShownEvent
>
event
=
this
;
if
(
popup
-
>
ClearPopupShownDispatcher
(
)
)
{
return
Run
(
)
;
}
}
CancelListener
(
)
;
return
NS_OK
;
}
void
nsXULPopupShownEvent
:
:
CancelListener
(
)
{
mPopup
-
>
RemoveSystemEventListener
(
NS_LITERAL_STRING
(
"
transitionend
"
)
this
false
)
;
}
NS_IMPL_ISUPPORTS_INHERITED
(
nsXULPopupShownEvent
Runnable
nsIDOMEventListener
)
;
bool
nsMenuPopupFrame
:
:
IsLeafDynamic
(
)
const
{
if
(
mGeneratedChildren
)
return
false
;
if
(
mPopupType
!
=
ePopupTypeMenu
)
{
return
!
mContent
-
>
AsElement
(
)
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
type
)
;
}
nsIContent
*
parentContent
=
mContent
-
>
GetParent
(
)
;
if
(
!
parentContent
)
{
return
false
;
}
if
(
parentContent
-
>
IsXULElement
(
nsGkAtoms
:
:
menulist
)
)
{
Element
*
parent
=
parentContent
-
>
AsElement
(
)
;
if
(
!
parent
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
sizetopopup
)
)
{
return
false
;
}
nsAutoString
sizedToPopup
;
parent
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
sizetopopup
sizedToPopup
)
;
return
sizedToPopup
.
EqualsLiteral
(
"
none
"
)
;
}
return
(
!
parentContent
-
>
IsElement
(
)
|
|
!
parentContent
-
>
AsElement
(
)
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
sizetopopup
)
)
;
}
void
nsMenuPopupFrame
:
:
UpdateWidgetProperties
(
)
{
if
(
nsIWidget
*
widget
=
GetWidget
(
)
)
{
widget
-
>
SetWindowOpacity
(
StyleUIReset
(
)
-
>
mWindowOpacity
)
;
widget
-
>
SetWindowTransform
(
ComputeWidgetTransform
(
)
)
;
}
}
void
nsMenuPopupFrame
:
:
LayoutPopup
(
nsBoxLayoutState
&
aState
nsIFrame
*
aParentMenu
nsIFrame
*
aAnchor
bool
aSizedToPopup
)
{
if
(
IsLeaf
(
)
)
{
return
;
}
SchedulePaint
(
)
;
bool
shouldPosition
=
true
;
bool
isOpen
=
IsOpen
(
)
;
if
(
!
isOpen
)
{
shouldPosition
=
(
mPopupState
=
=
ePopupShowing
|
|
mPopupState
=
=
ePopupPositioning
)
;
if
(
!
shouldPosition
&
&
!
aSizedToPopup
)
{
RemoveStateBits
(
NS_FRAME_FIRST_REFLOW
)
;
return
;
}
}
if
(
mIsOpenChanged
&
&
!
IsMenuList
(
)
)
{
nsIScrollableFrame
*
scrollframe
=
do_QueryFrame
(
nsBox
:
:
GetChildXULBox
(
this
)
)
;
if
(
scrollframe
)
{
AutoWeakFrame
weakFrame
(
this
)
;
scrollframe
-
>
ScrollTo
(
nsPoint
(
0
0
)
ScrollMode
:
:
Instant
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
;
}
}
}
nsSize
prefSize
=
GetXULPrefSize
(
aState
)
;
nsSize
minSize
=
GetXULMinSize
(
aState
)
;
nsSize
maxSize
=
GetXULMaxSize
(
aState
)
;
if
(
aSizedToPopup
)
{
prefSize
.
width
=
aParentMenu
-
>
GetRect
(
)
.
width
;
}
prefSize
=
BoundsCheck
(
minSize
prefSize
maxSize
)
;
bool
sizeChanged
=
(
mPrefSize
!
=
prefSize
)
;
if
(
sizeChanged
)
{
SetXULBounds
(
aState
nsRect
(
0
0
prefSize
.
width
prefSize
.
height
)
false
)
;
mPrefSize
=
prefSize
;
}
bool
needCallback
=
false
;
if
(
shouldPosition
)
{
SetPopupPosition
(
aAnchor
false
aSizedToPopup
mPopupState
=
=
ePopupPositioning
)
;
needCallback
=
true
;
}
nsRect
bounds
(
GetRect
(
)
)
;
XULLayout
(
aState
)
;
bool
rePosition
=
shouldPosition
&
&
(
mPosition
=
=
POPUPPOSITION_SELECTION
)
;
if
(
!
aParentMenu
)
{
nsSize
newsize
=
GetSize
(
)
;
if
(
newsize
.
width
>
bounds
.
width
|
|
newsize
.
height
>
bounds
.
height
)
{
mPrefSize
=
newsize
;
if
(
isOpen
)
{
rePosition
=
true
;
needCallback
=
true
;
}
}
}
if
(
rePosition
)
{
SetPopupPosition
(
aAnchor
false
aSizedToPopup
false
)
;
}
nsPresContext
*
pc
=
PresContext
(
)
;
nsView
*
view
=
GetView
(
)
;
if
(
sizeChanged
)
{
nsIWidget
*
widget
=
view
-
>
GetWidget
(
)
;
if
(
widget
)
{
SetSizeConstraints
(
pc
widget
minSize
maxSize
)
;
}
}
if
(
isOpen
)
{
nsViewManager
*
viewManager
=
view
-
>
GetViewManager
(
)
;
nsRect
rect
=
GetRect
(
)
;
rect
.
x
=
rect
.
y
=
0
;
rect
.
SizeTo
(
BoundsCheck
(
minSize
rect
.
Size
(
)
maxSize
)
)
;
viewManager
-
>
ResizeView
(
view
rect
)
;
if
(
mPopupState
=
=
ePopupOpening
)
{
mPopupState
=
ePopupVisible
;
}
viewManager
-
>
SetViewVisibility
(
view
nsViewVisibility_kShow
)
;
SyncFrameViewProperties
(
view
)
;
}
bool
openChanged
=
mIsOpenChanged
;
if
(
openChanged
)
{
mIsOpenChanged
=
false
;
if
(
IsMenuList
(
)
&
&
mCurrentMenu
)
{
EnsureMenuItemIsVisible
(
mCurrentMenu
)
;
}
if
(
StaticPrefs
:
:
xul_panel_animations_enabled
(
)
&
&
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
animate
nsGkAtoms
:
:
open
eCaseMatters
)
&
&
AnimationUtils
:
:
HasCurrentTransitions
(
mContent
-
>
AsElement
(
)
PseudoStyleType
:
:
NotPseudo
)
)
{
mPopupShownDispatcher
=
new
nsXULPopupShownEvent
(
mContent
pc
)
;
mContent
-
>
AddSystemEventListener
(
NS_LITERAL_STRING
(
"
transitionend
"
)
mPopupShownDispatcher
false
false
)
;
return
;
}
nsCOMPtr
<
nsIRunnable
>
event
=
new
nsXULPopupShownEvent
(
GetContent
(
)
pc
)
;
mContent
-
>
OwnerDoc
(
)
-
>
Dispatch
(
TaskCategory
:
:
Other
event
.
forget
(
)
)
;
}
if
(
needCallback
&
&
!
mReflowCallbackData
.
mPosted
)
{
pc
-
>
PresShell
(
)
-
>
PostReflowCallback
(
this
)
;
mReflowCallbackData
.
MarkPosted
(
aAnchor
aSizedToPopup
openChanged
)
;
}
}
bool
nsMenuPopupFrame
:
:
ReflowFinished
(
)
{
SetPopupPosition
(
mReflowCallbackData
.
mAnchor
false
mReflowCallbackData
.
mSizedToPopup
true
)
;
mReflowCallbackData
.
Clear
(
)
;
return
false
;
}
void
nsMenuPopupFrame
:
:
ReflowCallbackCanceled
(
)
{
mReflowCallbackData
.
Clear
(
)
;
}
bool
nsMenuPopupFrame
:
:
IsMenuList
(
)
{
nsIFrame
*
parentMenu
=
GetParent
(
)
;
return
(
parentMenu
&
&
parentMenu
-
>
GetContent
(
)
&
&
parentMenu
-
>
GetContent
(
)
-
>
IsXULElement
(
nsGkAtoms
:
:
menulist
)
)
;
}
nsIContent
*
nsMenuPopupFrame
:
:
GetTriggerContent
(
nsMenuPopupFrame
*
aMenuPopupFrame
)
{
while
(
aMenuPopupFrame
)
{
if
(
aMenuPopupFrame
-
>
mTriggerContent
)
return
aMenuPopupFrame
-
>
mTriggerContent
;
nsMenuFrame
*
menuFrame
=
do_QueryFrame
(
aMenuPopupFrame
-
>
GetParent
(
)
)
;
if
(
!
menuFrame
)
break
;
nsMenuParent
*
parentPopup
=
menuFrame
-
>
GetMenuParent
(
)
;
if
(
!
parentPopup
|
|
!
parentPopup
-
>
IsMenu
(
)
)
break
;
aMenuPopupFrame
=
static_cast
<
nsMenuPopupFrame
*
>
(
parentPopup
)
;
}
return
nullptr
;
}
void
nsMenuPopupFrame
:
:
InitPositionFromAnchorAlign
(
const
nsAString
&
aAnchor
const
nsAString
&
aAlign
)
{
mTriggerContent
=
nullptr
;
if
(
aAnchor
.
EqualsLiteral
(
"
topleft
"
)
)
mPopupAnchor
=
POPUPALIGNMENT_TOPLEFT
;
else
if
(
aAnchor
.
EqualsLiteral
(
"
topright
"
)
)
mPopupAnchor
=
POPUPALIGNMENT_TOPRIGHT
;
else
if
(
aAnchor
.
EqualsLiteral
(
"
bottomleft
"
)
)
mPopupAnchor
=
POPUPALIGNMENT_BOTTOMLEFT
;
else
if
(
aAnchor
.
EqualsLiteral
(
"
bottomright
"
)
)
mPopupAnchor
=
POPUPALIGNMENT_BOTTOMRIGHT
;
else
if
(
aAnchor
.
EqualsLiteral
(
"
leftcenter
"
)
)
mPopupAnchor
=
POPUPALIGNMENT_LEFTCENTER
;
else
if
(
aAnchor
.
EqualsLiteral
(
"
rightcenter
"
)
)
mPopupAnchor
=
POPUPALIGNMENT_RIGHTCENTER
;
else
if
(
aAnchor
.
EqualsLiteral
(
"
topcenter
"
)
)
mPopupAnchor
=
POPUPALIGNMENT_TOPCENTER
;
else
if
(
aAnchor
.
EqualsLiteral
(
"
bottomcenter
"
)
)
mPopupAnchor
=
POPUPALIGNMENT_BOTTOMCENTER
;
else
mPopupAnchor
=
POPUPALIGNMENT_NONE
;
if
(
aAlign
.
EqualsLiteral
(
"
topleft
"
)
)
mPopupAlignment
=
POPUPALIGNMENT_TOPLEFT
;
else
if
(
aAlign
.
EqualsLiteral
(
"
topright
"
)
)
mPopupAlignment
=
POPUPALIGNMENT_TOPRIGHT
;
else
if
(
aAlign
.
EqualsLiteral
(
"
bottomleft
"
)
)
mPopupAlignment
=
POPUPALIGNMENT_BOTTOMLEFT
;
else
if
(
aAlign
.
EqualsLiteral
(
"
bottomright
"
)
)
mPopupAlignment
=
POPUPALIGNMENT_BOTTOMRIGHT
;
else
mPopupAlignment
=
POPUPALIGNMENT_NONE
;
mPosition
=
POPUPPOSITION_UNKNOWN
;
}
void
nsMenuPopupFrame
:
:
InitializePopup
(
nsIContent
*
aAnchorContent
nsIContent
*
aTriggerContent
const
nsAString
&
aPosition
int32_t
aXPos
int32_t
aYPos
MenuPopupAnchorType
aAnchorType
bool
aAttributesOverride
)
{
EnsureWidget
(
)
;
mPopupState
=
ePopupShowing
;
mAnchorContent
=
aAnchorContent
;
mTriggerContent
=
aTriggerContent
;
mXPos
=
aXPos
;
mYPos
=
aYPos
;
mAdjustOffsetForContextMenu
=
false
;
mVFlip
=
false
;
mHFlip
=
false
;
mAlignmentOffset
=
0
;
mPositionedOffset
=
0
;
mAnchorType
=
aAnchorType
;
if
(
aAnchorContent
|
|
aAnchorType
=
=
MenuPopupAnchorType_Rect
)
{
nsAutoString
anchor
align
position
flip
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
popupanchor
anchor
)
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
popupalign
align
)
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
position
position
)
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
flip
flip
)
;
if
(
aAttributesOverride
)
{
if
(
anchor
.
IsEmpty
(
)
&
&
align
.
IsEmpty
(
)
&
&
position
.
IsEmpty
(
)
)
position
.
Assign
(
aPosition
)
;
else
mXPos
=
mYPos
=
0
;
}
else
if
(
!
aPosition
.
IsEmpty
(
)
)
{
position
.
Assign
(
aPosition
)
;
}
if
(
flip
.
EqualsLiteral
(
"
none
"
)
)
{
mFlip
=
FlipType_None
;
}
else
if
(
flip
.
EqualsLiteral
(
"
both
"
)
)
{
mFlip
=
FlipType_Both
;
}
else
if
(
flip
.
EqualsLiteral
(
"
slide
"
)
)
{
mFlip
=
FlipType_Slide
;
}
position
.
CompressWhitespace
(
)
;
int32_t
spaceIdx
=
position
.
FindChar
(
'
'
)
;
if
(
spaceIdx
>
=
0
)
{
InitPositionFromAnchorAlign
(
Substring
(
position
0
spaceIdx
)
Substring
(
position
spaceIdx
+
1
)
)
;
}
else
if
(
position
.
EqualsLiteral
(
"
before_start
"
)
)
{
mPopupAnchor
=
POPUPALIGNMENT_TOPLEFT
;
mPopupAlignment
=
POPUPALIGNMENT_BOTTOMLEFT
;
mPosition
=
POPUPPOSITION_BEFORESTART
;
}
else
if
(
position
.
EqualsLiteral
(
"
before_end
"
)
)
{
mPopupAnchor
=
POPUPALIGNMENT_TOPRIGHT
;
mPopupAlignment
=
POPUPALIGNMENT_BOTTOMRIGHT
;
mPosition
=
POPUPPOSITION_BEFOREEND
;
}
else
if
(
position
.
EqualsLiteral
(
"
after_start
"
)
)
{
mPopupAnchor
=
POPUPALIGNMENT_BOTTOMLEFT
;
mPopupAlignment
=
POPUPALIGNMENT_TOPLEFT
;
mPosition
=
POPUPPOSITION_AFTERSTART
;
}
else
if
(
position
.
EqualsLiteral
(
"
after_end
"
)
)
{
mPopupAnchor
=
POPUPALIGNMENT_BOTTOMRIGHT
;
mPopupAlignment
=
POPUPALIGNMENT_TOPRIGHT
;
mPosition
=
POPUPPOSITION_AFTEREND
;
}
else
if
(
position
.
EqualsLiteral
(
"
start_before
"
)
)
{
mPopupAnchor
=
POPUPALIGNMENT_TOPLEFT
;
mPopupAlignment
=
POPUPALIGNMENT_TOPRIGHT
;
mPosition
=
POPUPPOSITION_STARTBEFORE
;
}
else
if
(
position
.
EqualsLiteral
(
"
start_after
"
)
)
{
mPopupAnchor
=
POPUPALIGNMENT_BOTTOMLEFT
;
mPopupAlignment
=
POPUPALIGNMENT_BOTTOMRIGHT
;
mPosition
=
POPUPPOSITION_STARTAFTER
;
}
else
if
(
position
.
EqualsLiteral
(
"
end_before
"
)
)
{
mPopupAnchor
=
POPUPALIGNMENT_TOPRIGHT
;
mPopupAlignment
=
POPUPALIGNMENT_TOPLEFT
;
mPosition
=
POPUPPOSITION_ENDBEFORE
;
}
else
if
(
position
.
EqualsLiteral
(
"
end_after
"
)
)
{
mPopupAnchor
=
POPUPALIGNMENT_BOTTOMRIGHT
;
mPopupAlignment
=
POPUPALIGNMENT_BOTTOMLEFT
;
mPosition
=
POPUPPOSITION_ENDAFTER
;
}
else
if
(
position
.
EqualsLiteral
(
"
overlap
"
)
)
{
mPopupAnchor
=
POPUPALIGNMENT_TOPLEFT
;
mPopupAlignment
=
POPUPALIGNMENT_TOPLEFT
;
mPosition
=
POPUPPOSITION_OVERLAP
;
}
else
if
(
position
.
EqualsLiteral
(
"
after_pointer
"
)
)
{
mPopupAnchor
=
POPUPALIGNMENT_TOPLEFT
;
mPopupAlignment
=
POPUPALIGNMENT_TOPLEFT
;
mPosition
=
POPUPPOSITION_AFTERPOINTER
;
mYPos
+
=
21
;
}
else
if
(
position
.
EqualsLiteral
(
"
selection
"
)
)
{
mPopupAnchor
=
POPUPALIGNMENT_BOTTOMLEFT
;
mPopupAlignment
=
POPUPALIGNMENT_TOPLEFT
;
mPosition
=
POPUPPOSITION_SELECTION
;
}
else
{
InitPositionFromAnchorAlign
(
anchor
align
)
;
}
}
mScreenRect
=
nsIntRect
(
-
1
-
1
0
0
)
;
if
(
aAttributesOverride
)
{
nsAutoString
left
top
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
left
left
)
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
top
top
)
;
nsresult
err
;
if
(
!
left
.
IsEmpty
(
)
)
{
int32_t
x
=
left
.
ToInteger
(
&
err
)
;
if
(
NS_SUCCEEDED
(
err
)
)
mScreenRect
.
x
=
x
;
}
if
(
!
top
.
IsEmpty
(
)
)
{
int32_t
y
=
top
.
ToInteger
(
&
err
)
;
if
(
NS_SUCCEEDED
(
err
)
)
mScreenRect
.
y
=
y
;
}
}
}
void
nsMenuPopupFrame
:
:
InitializePopupAtScreen
(
nsIContent
*
aTriggerContent
int32_t
aXPos
int32_t
aYPos
bool
aIsContextMenu
)
{
EnsureWidget
(
)
;
mPopupState
=
ePopupShowing
;
mAnchorContent
=
nullptr
;
mTriggerContent
=
aTriggerContent
;
mScreenRect
=
nsIntRect
(
aXPos
aYPos
0
0
)
;
mXPos
=
0
;
mYPos
=
0
;
mFlip
=
FlipType_Default
;
mPopupAnchor
=
POPUPALIGNMENT_NONE
;
mPopupAlignment
=
POPUPALIGNMENT_NONE
;
mPosition
=
POPUPPOSITION_UNKNOWN
;
mIsContextMenu
=
aIsContextMenu
;
mAdjustOffsetForContextMenu
=
aIsContextMenu
;
mAnchorType
=
MenuPopupAnchorType_Point
;
mPositionedOffset
=
0
;
}
void
nsMenuPopupFrame
:
:
InitializePopupAtRect
(
nsIContent
*
aTriggerContent
const
nsAString
&
aPosition
const
nsIntRect
&
aRect
bool
aAttributesOverride
)
{
InitializePopup
(
nullptr
aTriggerContent
aPosition
0
0
MenuPopupAnchorType_Rect
aAttributesOverride
)
;
mScreenRect
=
aRect
;
}
void
nsMenuPopupFrame
:
:
ShowPopup
(
bool
aIsContextMenu
)
{
mIsContextMenu
=
aIsContextMenu
;
InvalidateFrameSubtree
(
)
;
if
(
mPopupState
=
=
ePopupShowing
|
|
mPopupState
=
=
ePopupPositioning
)
{
mPopupState
=
ePopupOpening
;
mIsOpenChanged
=
true
;
if
(
mPopupType
=
=
ePopupTypeMenu
)
{
EventStateManager
*
activeESM
=
static_cast
<
EventStateManager
*
>
(
EventStateManager
:
:
GetActiveEventStateManager
(
)
)
;
if
(
activeESM
)
{
EventStateManager
:
:
ClearGlobalActiveContent
(
activeESM
)
;
}
PresShell
:
:
ReleaseCapturingContent
(
)
;
}
nsMenuFrame
*
menuFrame
=
do_QueryFrame
(
GetParent
(
)
)
;
if
(
menuFrame
)
{
AutoWeakFrame
weakFrame
(
this
)
;
menuFrame
-
>
PopupOpened
(
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
return
;
}
PresShell
(
)
-
>
FrameNeedsReflow
(
this
IntrinsicDirty
:
:
TreeChange
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
if
(
mPopupType
=
=
ePopupTypeMenu
)
{
nsCOMPtr
<
nsISound
>
sound
(
do_CreateInstance
(
"
mozilla
.
org
/
sound
;
1
"
)
)
;
if
(
sound
)
sound
-
>
PlayEventSound
(
nsISound
:
:
EVENT_MENU_POPUP
)
;
}
}
mShouldAutoPosition
=
true
;
}
void
nsMenuPopupFrame
:
:
HidePopup
(
bool
aDeselectMenu
nsPopupState
aNewState
)
{
NS_ASSERTION
(
aNewState
=
=
ePopupClosed
|
|
aNewState
=
=
ePopupInvisible
"
popup
being
set
to
unexpected
state
"
)
;
ClearPopupShownDispatcher
(
)
;
if
(
mPopupState
=
=
ePopupClosed
|
|
mPopupState
=
=
ePopupShowing
|
|
mPopupState
=
=
ePopupPositioning
)
return
;
if
(
aNewState
=
=
ePopupClosed
)
{
if
(
mTriggerContent
)
{
Document
*
doc
=
mContent
-
>
GetUncomposedDoc
(
)
;
if
(
doc
)
{
if
(
nsPIDOMWindowOuter
*
win
=
doc
-
>
GetWindow
(
)
)
{
nsCOMPtr
<
nsPIWindowRoot
>
root
=
win
-
>
GetTopWindowRoot
(
)
;
if
(
root
)
{
root
-
>
SetPopupNode
(
nullptr
)
;
}
}
}
}
mTriggerContent
=
nullptr
;
mAnchorContent
=
nullptr
;
}
if
(
mPopupState
=
=
ePopupInvisible
)
{
if
(
aNewState
=
=
ePopupClosed
)
mPopupState
=
ePopupClosed
;
return
;
}
mPopupState
=
aNewState
;
if
(
IsMenu
(
)
)
SetCurrentMenuItem
(
nullptr
)
;
mIncrementalString
.
Truncate
(
)
;
LockMenuUntilClosed
(
false
)
;
mIsOpenChanged
=
false
;
mCurrentMenu
=
nullptr
;
mHFlip
=
mVFlip
=
false
;
nsView
*
view
=
GetView
(
)
;
nsViewManager
*
viewManager
=
view
-
>
GetViewManager
(
)
;
viewManager
-
>
SetViewVisibility
(
view
nsViewVisibility_kHide
)
;
FireDOMEvent
(
NS_LITERAL_STRING
(
"
DOMMenuInactive
"
)
mContent
)
;
NS_ASSERTION
(
mContent
-
>
IsElement
(
)
"
How
do
we
have
a
non
-
element
?
"
)
;
EventStates
state
=
mContent
-
>
AsElement
(
)
-
>
State
(
)
;
if
(
state
.
HasState
(
NS_EVENT_STATE_HOVER
)
)
{
EventStateManager
*
esm
=
PresContext
(
)
-
>
EventStateManager
(
)
;
esm
-
>
SetContentState
(
nullptr
NS_EVENT_STATE_HOVER
)
;
}
nsMenuFrame
*
menuFrame
=
do_QueryFrame
(
GetParent
(
)
)
;
if
(
menuFrame
)
{
menuFrame
-
>
PopupClosed
(
aDeselectMenu
)
;
}
}
uint32_t
nsMenuPopupFrame
:
:
GetXULLayoutFlags
(
)
{
return
NS_FRAME_NO_SIZE_VIEW
|
NS_FRAME_NO_MOVE_VIEW
|
NS_FRAME_NO_VISIBILITY
;
}
nsView
*
nsMenuPopupFrame
:
:
GetRootViewForPopup
(
nsIFrame
*
aStartFrame
)
{
nsView
*
view
=
aStartFrame
-
>
GetClosestView
(
)
;
NS_ASSERTION
(
view
"
frame
must
have
a
closest
view
!
"
)
;
while
(
view
)
{
nsIWidget
*
widget
=
view
-
>
GetWidget
(
)
;
if
(
widget
&
&
widget
-
>
WindowType
(
)
=
=
eWindowType_popup
)
{
return
view
;
}
nsView
*
temp
=
view
-
>
GetParent
(
)
;
if
(
!
temp
)
{
return
view
;
}
view
=
temp
;
}
return
nullptr
;
}
nsPoint
nsMenuPopupFrame
:
:
AdjustPositionForAnchorAlign
(
nsRect
&
anchorRect
FlipStyle
&
aHFlip
FlipStyle
&
aVFlip
)
{
int8_t
popupAnchor
(
mPopupAnchor
)
;
int8_t
popupAlign
(
mPopupAlignment
)
;
if
(
IsDirectionRTL
(
)
)
{
if
(
popupAnchor
<
=
POPUPALIGNMENT_LEFTCENTER
)
{
popupAnchor
=
-
popupAnchor
;
}
popupAlign
=
-
popupAlign
;
}
nsRect
originalAnchorRect
(
anchorRect
)
;
nsPoint
pnt
;
switch
(
popupAnchor
)
{
case
POPUPALIGNMENT_LEFTCENTER
:
pnt
=
nsPoint
(
anchorRect
.
x
anchorRect
.
y
+
anchorRect
.
height
/
2
)
;
anchorRect
.
y
=
pnt
.
y
;
anchorRect
.
height
=
0
;
break
;
case
POPUPALIGNMENT_RIGHTCENTER
:
pnt
=
nsPoint
(
anchorRect
.
XMost
(
)
anchorRect
.
y
+
anchorRect
.
height
/
2
)
;
anchorRect
.
y
=
pnt
.
y
;
anchorRect
.
height
=
0
;
break
;
case
POPUPALIGNMENT_TOPCENTER
:
pnt
=
nsPoint
(
anchorRect
.
x
+
anchorRect
.
width
/
2
anchorRect
.
y
)
;
anchorRect
.
x
=
pnt
.
x
;
anchorRect
.
width
=
0
;
break
;
case
POPUPALIGNMENT_BOTTOMCENTER
:
pnt
=
nsPoint
(
anchorRect
.
x
+
anchorRect
.
width
/
2
anchorRect
.
YMost
(
)
)
;
anchorRect
.
x
=
pnt
.
x
;
anchorRect
.
width
=
0
;
break
;
case
POPUPALIGNMENT_TOPRIGHT
:
pnt
=
anchorRect
.
TopRight
(
)
;
break
;
case
POPUPALIGNMENT_BOTTOMLEFT
:
pnt
=
anchorRect
.
BottomLeft
(
)
;
break
;
case
POPUPALIGNMENT_BOTTOMRIGHT
:
pnt
=
anchorRect
.
BottomRight
(
)
;
break
;
case
POPUPALIGNMENT_TOPLEFT
:
default
:
pnt
=
anchorRect
.
TopLeft
(
)
;
break
;
}
nsMargin
margin
(
0
0
0
0
)
;
StyleMargin
(
)
-
>
GetMargin
(
margin
)
;
switch
(
popupAlign
)
{
case
POPUPALIGNMENT_TOPRIGHT
:
pnt
.
MoveBy
(
-
mRect
.
width
-
margin
.
right
margin
.
top
)
;
break
;
case
POPUPALIGNMENT_BOTTOMLEFT
:
pnt
.
MoveBy
(
margin
.
left
-
mRect
.
height
-
margin
.
bottom
)
;
break
;
case
POPUPALIGNMENT_BOTTOMRIGHT
:
pnt
.
MoveBy
(
-
mRect
.
width
-
margin
.
right
-
mRect
.
height
-
margin
.
bottom
)
;
break
;
case
POPUPALIGNMENT_TOPLEFT
:
default
:
pnt
.
MoveBy
(
margin
.
left
margin
.
top
)
;
break
;
}
if
(
mPosition
=
=
POPUPPOSITION_SELECTION
)
{
MOZ_ASSERT
(
popupAnchor
=
=
POPUPALIGNMENT_BOTTOMLEFT
|
|
popupAnchor
=
=
POPUPALIGNMENT_BOTTOMRIGHT
)
;
MOZ_ASSERT
(
popupAlign
=
=
POPUPALIGNMENT_TOPLEFT
|
|
popupAlign
=
=
POPUPALIGNMENT_TOPRIGHT
)
;
if
(
mIsOpenChanged
|
|
mReflowCallbackData
.
mIsOpenChanged
)
{
nsIFrame
*
selectedItemFrame
=
GetSelectedItemForAlignment
(
)
;
if
(
selectedItemFrame
)
{
int32_t
scrolly
=
0
;
nsIScrollableFrame
*
scrollframe
=
GetScrollFrame
(
this
)
;
if
(
scrollframe
)
{
scrolly
=
scrollframe
-
>
GetScrollPosition
(
)
.
y
;
}
mPositionedOffset
=
originalAnchorRect
.
height
+
selectedItemFrame
-
>
GetRect
(
)
.
y
-
scrolly
;
}
}
pnt
.
y
-
=
mPositionedOffset
;
}
switch
(
popupAnchor
)
{
case
POPUPALIGNMENT_LEFTCENTER
:
case
POPUPALIGNMENT_RIGHTCENTER
:
aHFlip
=
FlipStyle_Outside
;
aVFlip
=
FlipStyle_Inside
;
break
;
case
POPUPALIGNMENT_TOPCENTER
:
case
POPUPALIGNMENT_BOTTOMCENTER
:
aHFlip
=
FlipStyle_Inside
;
aVFlip
=
FlipStyle_Outside
;
break
;
default
:
{
FlipStyle
anchorEdge
=
mFlip
=
=
FlipType_Both
?
FlipStyle_Inside
:
FlipStyle_None
;
aHFlip
=
(
popupAnchor
=
=
-
popupAlign
)
?
FlipStyle_Outside
:
anchorEdge
;
if
(
(
(
popupAnchor
>
0
)
=
=
(
popupAlign
>
0
)
)
|
|
(
popupAnchor
=
=
POPUPALIGNMENT_TOPLEFT
&
&
popupAlign
=
=
POPUPALIGNMENT_TOPLEFT
)
)
aVFlip
=
FlipStyle_Outside
;
else
aVFlip
=
anchorEdge
;
break
;
}
}
return
pnt
;
}
nsIFrame
*
nsMenuPopupFrame
:
:
GetSelectedItemForAlignment
(
)
{
nsCOMPtr
<
nsIDOMXULSelectControlElement
>
select
;
if
(
mAnchorContent
)
{
select
=
mAnchorContent
-
>
AsElement
(
)
-
>
AsXULSelectControl
(
)
;
}
if
(
!
select
)
{
select
=
mContent
-
>
GetParent
(
)
-
>
AsElement
(
)
-
>
AsXULSelectControl
(
)
;
if
(
!
select
)
{
return
nullptr
;
}
}
nsCOMPtr
<
Element
>
selectedElement
;
select
-
>
GetSelectedItem
(
getter_AddRefs
(
selectedElement
)
)
;
return
selectedElement
?
selectedElement
-
>
GetPrimaryFrame
(
)
:
nullptr
;
}
nscoord
nsMenuPopupFrame
:
:
SlideOrResize
(
nscoord
&
aScreenPoint
nscoord
aSize
nscoord
aScreenBegin
nscoord
aScreenEnd
nscoord
*
aOffset
)
{
nscoord
newPos
=
std
:
:
max
(
aScreenBegin
std
:
:
min
(
aScreenEnd
-
aSize
aScreenPoint
)
)
;
*
aOffset
=
newPos
-
aScreenPoint
;
aScreenPoint
=
newPos
;
return
std
:
:
min
(
aSize
aScreenEnd
-
aScreenPoint
)
;
}
nscoord
nsMenuPopupFrame
:
:
FlipOrResize
(
nscoord
&
aScreenPoint
nscoord
aSize
nscoord
aScreenBegin
nscoord
aScreenEnd
nscoord
aAnchorBegin
nscoord
aAnchorEnd
nscoord
aMarginBegin
nscoord
aMarginEnd
nscoord
aOffsetForContextMenu
FlipStyle
aFlip
bool
aEndAligned
bool
*
aFlipSide
)
{
*
aFlipSide
=
false
;
nscoord
popupSize
=
aSize
;
if
(
aScreenPoint
<
aScreenBegin
)
{
if
(
aFlip
)
{
nscoord
startpos
=
aFlip
=
=
FlipStyle_Outside
?
aAnchorBegin
:
aAnchorEnd
;
nscoord
endpos
=
aFlip
=
=
FlipStyle_Outside
?
aAnchorEnd
:
aAnchorBegin
;
if
(
startpos
-
aScreenBegin
>
=
aScreenEnd
-
endpos
)
{
aScreenPoint
=
aScreenBegin
;
popupSize
=
startpos
-
aScreenPoint
-
aMarginEnd
;
*
aFlipSide
=
!
aEndAligned
;
}
else
{
nscoord
newScreenPoint
=
endpos
+
aMarginEnd
;
if
(
newScreenPoint
!
=
aScreenPoint
)
{
*
aFlipSide
=
aEndAligned
;
aScreenPoint
=
newScreenPoint
;
if
(
aScreenPoint
+
aSize
>
aScreenEnd
)
{
popupSize
=
aScreenEnd
-
aScreenPoint
;
}
}
}
}
else
{
aScreenPoint
=
aScreenBegin
;
}
}
else
if
(
aScreenPoint
+
aSize
>
aScreenEnd
)
{
if
(
aFlip
)
{
nscoord
startpos
=
aFlip
=
=
FlipStyle_Outside
?
aAnchorBegin
:
aAnchorEnd
;
nscoord
endpos
=
aFlip
=
=
FlipStyle_Outside
?
aAnchorEnd
:
aAnchorBegin
;
if
(
aScreenEnd
-
endpos
>
=
startpos
-
aScreenBegin
)
{
*
aFlipSide
=
aEndAligned
;
if
(
mIsContextMenu
)
{
aScreenPoint
=
aScreenEnd
-
aSize
;
}
else
{
aScreenPoint
=
endpos
+
aMarginBegin
;
popupSize
=
aScreenEnd
-
aScreenPoint
;
}
}
else
{
nscoord
newScreenPoint
=
startpos
-
aSize
-
aMarginBegin
-
std
:
:
max
(
aOffsetForContextMenu
0
)
;
if
(
newScreenPoint
!
=
aScreenPoint
)
{
*
aFlipSide
=
!
aEndAligned
;
aScreenPoint
=
newScreenPoint
;
if
(
aScreenPoint
<
aScreenBegin
)
{
aScreenPoint
=
aScreenBegin
;
if
(
!
mIsContextMenu
)
{
popupSize
=
startpos
-
aScreenPoint
-
aMarginBegin
;
}
}
}
}
}
else
{
aScreenPoint
=
aScreenEnd
-
aSize
;
}
}
if
(
aScreenPoint
<
aScreenBegin
)
{
aScreenPoint
=
aScreenBegin
;
}
if
(
aScreenPoint
>
aScreenEnd
)
{
aScreenPoint
=
aScreenEnd
-
aSize
;
}
if
(
popupSize
<
=
0
|
|
aSize
<
popupSize
)
{
popupSize
=
aSize
;
}
return
std
:
:
min
(
popupSize
aScreenEnd
-
aScreenPoint
)
;
}
nsRect
nsMenuPopupFrame
:
:
ComputeAnchorRect
(
nsPresContext
*
aRootPresContext
nsIFrame
*
aAnchorFrame
)
{
nsIFrame
*
rootFrame
=
aRootPresContext
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
;
nsRect
anchorRect
=
aAnchorFrame
-
>
GetRectRelativeToSelf
(
)
;
anchorRect
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
aAnchorFrame
anchorRect
rootFrame
)
;
anchorRect
.
MoveBy
(
rootFrame
-
>
GetScreenRectInAppUnits
(
)
.
TopLeft
(
)
)
;
return
anchorRect
.
ScaleToOtherAppUnitsRoundOut
(
aRootPresContext
-
>
AppUnitsPerDevPixel
(
)
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
}
nsresult
nsMenuPopupFrame
:
:
SetPopupPosition
(
nsIFrame
*
aAnchorFrame
bool
aIsMove
bool
aSizedToPopup
bool
aNotify
)
{
if
(
!
mShouldAutoPosition
)
return
NS_OK
;
if
(
aIsMove
&
&
(
mPrefSize
.
width
=
=
-
1
|
|
mPrefSize
.
height
=
=
-
1
)
)
{
return
NS_OK
;
}
nsPresContext
*
presContext
=
PresContext
(
)
;
nsIFrame
*
rootFrame
=
presContext
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
;
NS_ASSERTION
(
rootFrame
-
>
GetView
(
)
&
&
GetView
(
)
&
&
rootFrame
-
>
GetView
(
)
=
=
GetView
(
)
-
>
GetParent
(
)
"
rootFrame
'
s
view
is
not
our
view
'
s
parent
?
?
?
"
)
;
nsRect
anchorRect
;
int32_t
parentWidth
=
0
;
bool
anchored
=
IsAnchored
(
)
;
if
(
anchored
|
|
aSizedToPopup
)
{
nsPresContext
*
rootPresContext
=
presContext
-
>
GetRootPresContext
(
)
;
if
(
!
rootPresContext
)
{
return
NS_OK
;
}
if
(
mAnchorType
=
=
MenuPopupAnchorType_Rect
)
{
anchorRect
=
ToAppUnits
(
mScreenRect
AppUnitsPerCSSPixel
(
)
)
;
}
else
{
if
(
!
aAnchorFrame
)
{
if
(
mAnchorContent
)
{
aAnchorFrame
=
mAnchorContent
-
>
GetPrimaryFrame
(
)
;
}
if
(
!
aAnchorFrame
)
{
aAnchorFrame
=
rootFrame
;
if
(
!
aAnchorFrame
)
return
NS_OK
;
}
}
anchorRect
=
ComputeAnchorRect
(
rootPresContext
aAnchorFrame
)
;
}
parentWidth
=
anchorRect
.
width
;
}
NS_ASSERTION
(
mPrefSize
.
width
>
=
0
|
|
mPrefSize
.
height
>
=
0
"
preferred
size
of
popup
not
set
"
)
;
mRect
.
width
=
aSizedToPopup
?
parentWidth
:
mPrefSize
.
width
;
mRect
.
height
=
mPrefSize
.
height
;
if
(
mAnchorType
=
=
MenuPopupAnchorType_Rect
&
&
parentWidth
<
mPrefSize
.
width
)
{
mRect
.
width
=
mPrefSize
.
width
;
}
nsPoint
screenPoint
;
FlipStyle
hFlip
=
FlipStyle_None
vFlip
=
FlipStyle_None
;
nsMargin
margin
(
0
0
0
0
)
;
StyleMargin
(
)
-
>
GetMargin
(
margin
)
;
nsRect
rootScreenRect
=
rootFrame
-
>
GetScreenRectInAppUnits
(
)
;
nsDeviceContext
*
devContext
=
presContext
-
>
DeviceContext
(
)
;
nsPoint
offsetForContextMenu
;
bool
isNoAutoHide
=
IsNoAutoHide
(
)
;
nsPopupLevel
popupLevel
=
PopupLevel
(
isNoAutoHide
)
;
if
(
anchored
)
{
if
(
mAnchorContent
|
|
mAnchorType
=
=
MenuPopupAnchorType_Rect
)
{
screenPoint
=
AdjustPositionForAnchorAlign
(
anchorRect
hFlip
vFlip
)
;
}
else
{
anchorRect
=
rootScreenRect
;
screenPoint
=
anchorRect
.
TopLeft
(
)
+
nsPoint
(
margin
.
left
margin
.
top
)
;
}
nscoord
anchorXOffset
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
mXPos
)
;
if
(
IsDirectionRTL
(
)
)
{
screenPoint
.
x
-
=
anchorXOffset
;
anchorRect
.
x
-
=
anchorXOffset
;
}
else
{
screenPoint
.
x
+
=
anchorXOffset
;
anchorRect
.
x
+
=
anchorXOffset
;
}
nscoord
anchorYOffset
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
mYPos
)
;
screenPoint
.
y
+
=
anchorYOffset
;
anchorRect
.
y
+
=
anchorYOffset
;
if
(
isNoAutoHide
&
&
(
popupLevel
!
=
ePopupLevelParent
|
|
mAnchorType
=
=
MenuPopupAnchorType_Rect
)
)
{
mAnchorType
=
MenuPopupAnchorType_Point
;
mScreenRect
.
x
=
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
screenPoint
.
x
-
margin
.
left
)
;
mScreenRect
.
y
=
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
screenPoint
.
y
-
margin
.
top
)
;
}
}
else
{
int32_t
factor
=
devContext
-
>
AppUnitsPerDevPixelAtUnitFullZoom
(
)
;
if
(
mAdjustOffsetForContextMenu
)
{
nsPoint
offsetForContextMenuDev
;
offsetForContextMenuDev
.
x
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
eIntID_ContextMenuOffsetHorizontal
)
)
/
factor
;
offsetForContextMenuDev
.
y
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
eIntID_ContextMenuOffsetVertical
)
)
/
factor
;
offsetForContextMenu
.
x
=
presContext
-
>
DevPixelsToAppUnits
(
offsetForContextMenuDev
.
x
)
;
offsetForContextMenu
.
y
=
presContext
-
>
DevPixelsToAppUnits
(
offsetForContextMenuDev
.
y
)
;
}
screenPoint
.
x
=
presContext
-
>
DevPixelsToAppUnits
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
mScreenRect
.
x
)
/
factor
)
;
screenPoint
.
y
=
presContext
-
>
DevPixelsToAppUnits
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
mScreenRect
.
y
)
/
factor
)
;
anchorRect
=
nsRect
(
screenPoint
nsSize
(
0
0
)
)
;
screenPoint
.
MoveBy
(
margin
.
left
+
offsetForContextMenu
.
x
margin
.
top
+
offsetForContextMenu
.
y
)
;
#
ifdef
XP_MACOSX
if
(
mPopupType
=
=
ePopupTypeTooltip
)
{
vFlip
=
FlipStyle_Outside
;
}
else
{
hFlip
=
FlipStyle_Outside
;
}
#
else
vFlip
=
FlipStyle_Outside
;
#
endif
}
nscoord
oldAlignmentOffset
=
mAlignmentOffset
;
bool
inWayland
=
false
;
#
ifdef
MOZ_WAYLAND
inWayland
=
!
GDK_IS_X11_DISPLAY
(
gdk_display_get_default
(
)
)
;
#
endif
if
(
!
inWayland
&
&
(
mInContentShell
|
|
(
mFlip
!
=
FlipType_None
&
&
(
!
aIsMove
|
|
mIsOffset
|
|
mPopupType
!
=
ePopupTypePanel
)
)
)
)
{
int32_t
appPerDev
=
presContext
-
>
AppUnitsPerDevPixel
(
)
;
LayoutDeviceIntRect
anchorRectDevPix
=
LayoutDeviceIntRect
:
:
FromAppUnitsToNearest
(
anchorRect
appPerDev
)
;
LayoutDeviceIntRect
rootScreenRectDevPix
=
LayoutDeviceIntRect
:
:
FromAppUnitsToNearest
(
rootScreenRect
appPerDev
)
;
LayoutDeviceIntRect
screenRectDevPix
=
GetConstraintRect
(
anchorRectDevPix
rootScreenRectDevPix
popupLevel
)
;
nsRect
screenRect
=
LayoutDeviceIntRect
:
:
ToAppUnits
(
screenRectDevPix
appPerDev
)
;
anchorRect
=
anchorRect
.
Intersect
(
screenRect
)
;
if
(
mRect
.
width
>
screenRect
.
width
)
mRect
.
width
=
screenRect
.
width
;
if
(
mRect
.
height
>
screenRect
.
height
)
mRect
.
height
=
screenRect
.
height
;
bool
slideHorizontal
=
false
slideVertical
=
false
;
if
(
mFlip
=
=
FlipType_Slide
)
{
int8_t
position
=
GetAlignmentPosition
(
)
;
slideHorizontal
=
position
>
=
POPUPPOSITION_BEFORESTART
&
&
position
<
=
POPUPPOSITION_AFTEREND
;
slideVertical
=
position
>
=
POPUPPOSITION_STARTBEFORE
&
&
position
<
=
POPUPPOSITION_ENDAFTER
;
}
bool
endAligned
=
IsDirectionRTL
(
)
?
mPopupAlignment
=
=
POPUPALIGNMENT_TOPLEFT
|
|
mPopupAlignment
=
=
POPUPALIGNMENT_BOTTOMLEFT
:
mPopupAlignment
=
=
POPUPALIGNMENT_TOPRIGHT
|
|
mPopupAlignment
=
=
POPUPALIGNMENT_BOTTOMRIGHT
;
nscoord
preOffsetScreenPoint
=
screenPoint
.
x
;
if
(
slideHorizontal
)
{
mRect
.
width
=
SlideOrResize
(
screenPoint
.
x
mRect
.
width
screenRect
.
x
screenRect
.
XMost
(
)
&
mAlignmentOffset
)
;
}
else
{
mRect
.
width
=
FlipOrResize
(
screenPoint
.
x
mRect
.
width
screenRect
.
x
screenRect
.
XMost
(
)
anchorRect
.
x
anchorRect
.
XMost
(
)
margin
.
left
margin
.
right
offsetForContextMenu
.
x
hFlip
endAligned
&
mHFlip
)
;
}
mIsOffset
=
preOffsetScreenPoint
!
=
screenPoint
.
x
;
endAligned
=
mPopupAlignment
=
=
POPUPALIGNMENT_BOTTOMLEFT
|
|
mPopupAlignment
=
=
POPUPALIGNMENT_BOTTOMRIGHT
;
preOffsetScreenPoint
=
screenPoint
.
y
;
if
(
slideVertical
)
{
mRect
.
height
=
SlideOrResize
(
screenPoint
.
y
mRect
.
height
screenRect
.
y
screenRect
.
YMost
(
)
&
mAlignmentOffset
)
;
}
else
{
mRect
.
height
=
FlipOrResize
(
screenPoint
.
y
mRect
.
height
screenRect
.
y
screenRect
.
YMost
(
)
anchorRect
.
y
anchorRect
.
YMost
(
)
margin
.
top
margin
.
bottom
offsetForContextMenu
.
y
vFlip
endAligned
&
mVFlip
)
;
}
mIsOffset
=
mIsOffset
|
|
(
preOffsetScreenPoint
!
=
screenPoint
.
y
)
;
NS_ASSERTION
(
screenPoint
.
x
>
=
screenRect
.
x
&
&
screenPoint
.
y
>
=
screenRect
.
y
&
&
screenPoint
.
x
+
mRect
.
width
<
=
screenRect
.
XMost
(
)
&
&
screenPoint
.
y
+
mRect
.
height
<
=
screenRect
.
YMost
(
)
"
Popup
is
offscreen
"
)
;
}
screenPoint
.
x
=
presContext
-
>
RoundAppUnitsToNearestDevPixels
(
screenPoint
.
x
)
;
screenPoint
.
y
=
presContext
-
>
RoundAppUnitsToNearestDevPixels
(
screenPoint
.
y
)
;
nsPoint
viewPoint
=
screenPoint
-
rootScreenRect
.
TopLeft
(
)
;
nsView
*
view
=
GetView
(
)
;
NS_ASSERTION
(
view
"
popup
with
no
view
"
)
;
nsIWidget
*
widget
=
view
-
>
GetWidget
(
)
;
if
(
mPopupType
=
=
ePopupTypePanel
&
&
widget
)
{
mLastClientOffset
=
widget
-
>
GetClientOffset
(
)
;
viewPoint
.
x
+
=
presContext
-
>
DevPixelsToAppUnits
(
mLastClientOffset
.
x
)
;
viewPoint
.
y
+
=
presContext
-
>
DevPixelsToAppUnits
(
mLastClientOffset
.
y
)
;
}
presContext
-
>
GetPresShell
(
)
-
>
GetViewManager
(
)
-
>
MoveViewTo
(
view
viewPoint
.
x
viewPoint
.
y
)
;
nsBoxFrame
:
:
SetPosition
(
viewPoint
-
GetParent
(
)
-
>
GetOffsetTo
(
rootFrame
)
)
;
if
(
aSizedToPopup
)
{
nsBoxLayoutState
state
(
PresContext
(
)
)
;
SetXULBounds
(
state
mRect
)
;
}
nsIntRect
newRect
(
screenPoint
.
x
screenPoint
.
y
mRect
.
width
mRect
.
height
)
;
if
(
mPopupState
=
=
ePopupPositioning
|
|
(
mPopupState
=
=
ePopupShown
&
&
!
newRect
.
IsEqualEdges
(
mUsedScreenRect
)
)
|
|
(
mPopupState
=
=
ePopupShown
&
&
oldAlignmentOffset
!
=
mAlignmentOffset
)
)
{
mUsedScreenRect
=
newRect
;
if
(
aNotify
)
{
nsXULPopupPositionedEvent
:
:
DispatchIfNeeded
(
mContent
false
false
)
;
}
}
return
NS_OK
;
}
void
nsMenuPopupFrame
:
:
GenerateFrames
(
)
{
const
bool
generateFrames
=
IsLeaf
(
)
;
MOZ_ASSERT_IF
(
generateFrames
!
mGeneratedChildren
)
;
mGeneratedChildren
=
true
;
if
(
generateFrames
)
{
MOZ_ASSERT
(
PrincipalChildList
(
)
.
IsEmpty
(
)
)
;
RefPtr
<
mozilla
:
:
PresShell
>
presShell
=
PresContext
(
)
-
>
PresShell
(
)
;
presShell
-
>
FrameConstructor
(
)
-
>
GenerateChildFrames
(
this
)
;
}
}
nsMenuFrame
*
nsMenuPopupFrame
:
:
GetCurrentMenuItem
(
)
{
return
mCurrentMenu
;
}
LayoutDeviceIntRect
nsMenuPopupFrame
:
:
GetConstraintRect
(
const
LayoutDeviceIntRect
&
aAnchorRect
const
LayoutDeviceIntRect
&
aRootScreenRect
nsPopupLevel
aPopupLevel
)
{
LayoutDeviceIntRect
screenRectPixels
;
nsCOMPtr
<
nsIScreen
>
screen
;
nsCOMPtr
<
nsIScreenManager
>
sm
(
do_GetService
(
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
)
)
;
if
(
sm
)
{
DesktopToLayoutDeviceScale
scale
=
PresContext
(
)
-
>
DeviceContext
(
)
-
>
GetDesktopToDeviceScale
(
)
;
DesktopRect
rect
=
(
mInContentShell
?
aRootScreenRect
:
aAnchorRect
)
/
scale
;
int32_t
width
=
std
:
:
max
(
1
NSToIntRound
(
rect
.
width
)
)
;
int32_t
height
=
std
:
:
max
(
1
NSToIntRound
(
rect
.
height
)
)
;
sm
-
>
ScreenForRect
(
rect
.
x
rect
.
y
width
height
getter_AddRefs
(
screen
)
)
;
if
(
screen
)
{
bool
dontOverlapOSBar
=
aPopupLevel
!
=
ePopupLevelTop
;
if
(
!
dontOverlapOSBar
&
&
mMenuCanOverlapOSBar
&
&
!
mInContentShell
)
screen
-
>
GetRect
(
&
screenRectPixels
.
x
&
screenRectPixels
.
y
&
screenRectPixels
.
width
&
screenRectPixels
.
height
)
;
else
screen
-
>
GetAvailRect
(
&
screenRectPixels
.
x
&
screenRectPixels
.
y
&
screenRectPixels
.
width
&
screenRectPixels
.
height
)
;
}
}
if
(
mInContentShell
)
{
screenRectPixels
.
IntersectRect
(
screenRectPixels
aRootScreenRect
)
;
}
else
if
(
!
mOverrideConstraintRect
.
IsEmpty
(
)
)
{
LayoutDeviceIntRect
overrideConstrainRect
=
LayoutDeviceIntRect
:
:
FromAppUnitsToNearest
(
mOverrideConstraintRect
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
screenRectPixels
.
IntersectRect
(
screenRectPixels
overrideConstrainRect
)
;
screenRectPixels
.
x
=
overrideConstrainRect
.
x
;
screenRectPixels
.
width
=
overrideConstrainRect
.
width
;
}
return
screenRectPixels
;
}
void
nsMenuPopupFrame
:
:
CanAdjustEdges
(
Side
aHorizontalSide
Side
aVerticalSide
LayoutDeviceIntPoint
&
aChange
)
{
int8_t
popupAlign
(
mPopupAlignment
)
;
if
(
IsDirectionRTL
(
)
)
{
popupAlign
=
-
popupAlign
;
}
if
(
aHorizontalSide
=
=
(
mHFlip
?
eSideRight
:
eSideLeft
)
)
{
if
(
popupAlign
=
=
POPUPALIGNMENT_TOPLEFT
|
|
popupAlign
=
=
POPUPALIGNMENT_BOTTOMLEFT
)
{
aChange
.
x
=
0
;
}
}
else
if
(
aHorizontalSide
=
=
(
mHFlip
?
eSideLeft
:
eSideRight
)
)
{
if
(
popupAlign
=
=
POPUPALIGNMENT_TOPRIGHT
|
|
popupAlign
=
=
POPUPALIGNMENT_BOTTOMRIGHT
)
{
aChange
.
x
=
0
;
}
}
if
(
aVerticalSide
=
=
(
mVFlip
?
eSideBottom
:
eSideTop
)
)
{
if
(
popupAlign
=
=
POPUPALIGNMENT_TOPLEFT
|
|
popupAlign
=
=
POPUPALIGNMENT_TOPRIGHT
)
{
aChange
.
y
=
0
;
}
}
else
if
(
aVerticalSide
=
=
(
mVFlip
?
eSideTop
:
eSideBottom
)
)
{
if
(
popupAlign
=
=
POPUPALIGNMENT_BOTTOMLEFT
|
|
popupAlign
=
=
POPUPALIGNMENT_BOTTOMRIGHT
)
{
aChange
.
y
=
0
;
}
}
}
ConsumeOutsideClicksResult
nsMenuPopupFrame
:
:
ConsumeOutsideClicks
(
)
{
if
(
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
consumeoutsideclicks
nsGkAtoms
:
:
_true
eCaseMatters
)
)
{
return
ConsumeOutsideClicks_True
;
}
if
(
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
consumeoutsideclicks
nsGkAtoms
:
:
_false
eCaseMatters
)
)
{
return
ConsumeOutsideClicks_ParentOnly
;
}
if
(
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
consumeoutsideclicks
nsGkAtoms
:
:
never
eCaseMatters
)
)
{
return
ConsumeOutsideClicks_Never
;
}
nsCOMPtr
<
nsIContent
>
parentContent
=
mContent
-
>
GetParent
(
)
;
if
(
parentContent
)
{
dom
:
:
NodeInfo
*
ni
=
parentContent
-
>
NodeInfo
(
)
;
if
(
ni
-
>
Equals
(
nsGkAtoms
:
:
menulist
kNameSpaceID_XUL
)
)
{
return
ConsumeOutsideClicks_True
;
}
#
if
defined
(
XP_WIN
)
if
(
ni
-
>
Equals
(
nsGkAtoms
:
:
menu
kNameSpaceID_XUL
)
|
|
ni
-
>
Equals
(
nsGkAtoms
:
:
popupset
kNameSpaceID_XUL
)
|
|
(
(
ni
-
>
Equals
(
nsGkAtoms
:
:
button
kNameSpaceID_XUL
)
|
|
ni
-
>
Equals
(
nsGkAtoms
:
:
toolbarbutton
kNameSpaceID_XUL
)
)
&
&
parentContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
type
nsGkAtoms
:
:
menu
eCaseMatters
)
)
)
{
return
ConsumeOutsideClicks_Never
;
}
#
endif
if
(
ni
-
>
Equals
(
nsGkAtoms
:
:
textbox
kNameSpaceID_XUL
)
)
{
if
(
parentContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
type
nsGkAtoms
:
:
autocomplete
eCaseMatters
)
)
{
return
ConsumeOutsideClicks_Never
;
}
}
}
return
ConsumeOutsideClicks_True
;
}
nsIScrollableFrame
*
nsMenuPopupFrame
:
:
GetScrollFrame
(
nsIFrame
*
aStart
)
{
if
(
!
aStart
)
return
nullptr
;
nsIFrame
*
currFrame
=
aStart
;
do
{
nsIScrollableFrame
*
sf
=
do_QueryFrame
(
currFrame
)
;
if
(
sf
)
return
sf
;
currFrame
=
currFrame
-
>
GetNextSibling
(
)
;
}
while
(
currFrame
)
;
currFrame
=
aStart
;
do
{
nsIFrame
*
childFrame
=
currFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
nsIScrollableFrame
*
sf
=
GetScrollFrame
(
childFrame
)
;
if
(
sf
)
return
sf
;
currFrame
=
currFrame
-
>
GetNextSibling
(
)
;
}
while
(
currFrame
)
;
return
nullptr
;
}
void
nsMenuPopupFrame
:
:
EnsureMenuItemIsVisible
(
nsMenuFrame
*
aMenuItem
)
{
if
(
aMenuItem
)
{
aMenuItem
-
>
PresShell
(
)
-
>
ScrollFrameRectIntoView
(
aMenuItem
nsRect
(
nsPoint
(
0
0
)
aMenuItem
-
>
GetRect
(
)
.
Size
(
)
)
ScrollAxis
(
)
ScrollAxis
(
)
ScrollFlags
:
:
ScrollOverflowHidden
|
ScrollFlags
:
:
ScrollFirstAncestorOnly
|
ScrollFlags
:
:
IgnoreMarginAndPadding
)
;
}
}
void
nsMenuPopupFrame
:
:
ChangeByPage
(
bool
aIsUp
)
{
if
(
!
IsMenuList
(
)
)
{
return
;
}
nsMenuFrame
*
newMenu
=
nullptr
;
nsIFrame
*
currentMenu
=
mCurrentMenu
;
if
(
!
currentMenu
)
{
newMenu
=
nsXULPopupManager
:
:
GetNextMenuItem
(
this
nullptr
true
false
)
;
if
(
!
aIsUp
)
{
currentMenu
=
newMenu
;
}
}
if
(
currentMenu
)
{
nscoord
scrollHeight
=
mRect
.
height
;
nsIScrollableFrame
*
scrollframe
=
GetScrollFrame
(
this
)
;
if
(
scrollframe
)
{
scrollHeight
=
scrollframe
-
>
GetScrollPortRect
(
)
.
height
;
}
nscoord
targetPosition
=
aIsUp
?
currentMenu
-
>
GetRect
(
)
.
YMost
(
)
-
scrollHeight
:
currentMenu
-
>
GetRect
(
)
.
y
+
scrollHeight
;
bool
lastWasValid
=
false
;
while
(
currentMenu
)
{
nsMenuFrame
*
menuFrame
=
do_QueryFrame
(
currentMenu
)
;
if
(
menuFrame
&
&
nsXULPopupManager
:
:
IsValidMenuItem
(
menuFrame
-
>
GetContent
(
)
true
)
)
{
if
(
(
!
aIsUp
&
&
currentMenu
-
>
GetRect
(
)
.
YMost
(
)
>
targetPosition
)
|
|
(
aIsUp
&
&
currentMenu
-
>
GetRect
(
)
.
y
<
targetPosition
)
)
{
if
(
!
lastWasValid
)
{
newMenu
=
menuFrame
;
}
break
;
}
lastWasValid
=
true
;
newMenu
=
menuFrame
;
}
else
{
lastWasValid
=
false
;
}
currentMenu
=
aIsUp
?
currentMenu
-
>
GetPrevSibling
(
)
:
currentMenu
-
>
GetNextSibling
(
)
;
}
}
if
(
newMenu
)
{
ChangeMenuItem
(
newMenu
false
true
)
;
}
}
NS_IMETHODIMP
nsMenuPopupFrame
:
:
SetCurrentMenuItem
(
nsMenuFrame
*
aMenuItem
)
{
if
(
mCurrentMenu
=
=
aMenuItem
)
return
NS_OK
;
if
(
mCurrentMenu
)
{
mCurrentMenu
-
>
SelectMenu
(
false
)
;
}
if
(
aMenuItem
)
{
EnsureMenuItemIsVisible
(
aMenuItem
)
;
aMenuItem
-
>
SelectMenu
(
true
)
;
}
mCurrentMenu
=
aMenuItem
;
return
NS_OK
;
}
void
nsMenuPopupFrame
:
:
CurrentMenuIsBeingDestroyed
(
)
{
mCurrentMenu
=
nullptr
;
}
NS_IMETHODIMP
nsMenuPopupFrame
:
:
ChangeMenuItem
(
nsMenuFrame
*
aMenuItem
bool
aSelectFirstItem
bool
aFromKey
)
{
if
(
mCurrentMenu
=
=
aMenuItem
)
return
NS_OK
;
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
!
mIsContextMenu
&
&
pm
&
&
pm
-
>
HasContextMenu
(
this
)
)
return
NS_OK
;
if
(
mCurrentMenu
)
{
mCurrentMenu
-
>
SelectMenu
(
false
)
;
nsMenuPopupFrame
*
popup
=
mCurrentMenu
-
>
GetPopup
(
)
;
if
(
popup
)
{
if
(
mCurrentMenu
-
>
IsOpen
(
)
)
{
if
(
pm
)
pm
-
>
HidePopupAfterDelay
(
popup
)
;
}
}
}
if
(
aMenuItem
)
{
EnsureMenuItemIsVisible
(
aMenuItem
)
;
aMenuItem
-
>
SelectMenu
(
true
)
;
#
ifdef
XP_WIN
if
(
aFromKey
&
&
IsOpen
(
)
&
&
IsMenuList
(
)
)
{
nsContentUtils
:
:
DispatchXULCommand
(
aMenuItem
-
>
GetContent
(
)
true
nullptr
PresShell
(
)
false
false
false
false
)
;
}
#
endif
}
mCurrentMenu
=
aMenuItem
;
return
NS_OK
;
}
nsMenuFrame
*
nsMenuPopupFrame
:
:
Enter
(
WidgetGUIEvent
*
aEvent
)
{
mIncrementalString
.
Truncate
(
)
;
if
(
mCurrentMenu
)
return
mCurrentMenu
-
>
Enter
(
aEvent
)
;
return
nullptr
;
}
nsMenuFrame
*
nsMenuPopupFrame
:
:
FindMenuWithShortcut
(
KeyboardEvent
*
aKeyEvent
bool
&
doAction
)
{
uint32_t
charCode
=
aKeyEvent
-
>
CharCode
(
)
;
uint32_t
keyCode
=
aKeyEvent
-
>
KeyCode
(
)
;
doAction
=
false
;
nsContainerFrame
*
immediateParent
=
nsXULPopupManager
:
:
ImmediateParentFrame
(
this
)
;
uint32_t
matchCount
=
0
matchShortcutCount
=
0
;
bool
foundActive
=
false
;
nsMenuFrame
*
frameBefore
=
nullptr
;
nsMenuFrame
*
frameAfter
=
nullptr
;
nsMenuFrame
*
frameShortcut
=
nullptr
;
nsIContent
*
parentContent
=
mContent
-
>
GetParent
(
)
;
bool
isMenu
=
parentContent
&
&
!
parentContent
-
>
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
menulist
kNameSpaceID_XUL
)
;
DOMTimeStamp
keyTime
=
aKeyEvent
-
>
TimeStamp
(
)
;
if
(
charCode
=
=
0
)
{
if
(
keyCode
=
=
dom
:
:
KeyboardEvent_Binding
:
:
DOM_VK_BACK_SPACE
)
{
if
(
!
isMenu
&
&
!
mIncrementalString
.
IsEmpty
(
)
)
{
mIncrementalString
.
SetLength
(
mIncrementalString
.
Length
(
)
-
1
)
;
return
nullptr
;
}
else
{
#
ifdef
XP_WIN
nsCOMPtr
<
nsISound
>
soundInterface
=
do_CreateInstance
(
"
mozilla
.
org
/
sound
;
1
"
)
;
if
(
soundInterface
)
soundInterface
-
>
Beep
(
)
;
#
endif
}
}
return
nullptr
;
}
else
{
char16_t
uniChar
=
ToLowerCase
(
static_cast
<
char16_t
>
(
charCode
)
)
;
if
(
isMenu
)
{
mIncrementalString
=
uniChar
;
}
else
if
(
IsWithinIncrementalTime
(
keyTime
)
)
{
mIncrementalString
.
Append
(
uniChar
)
;
}
else
{
mIncrementalString
=
uniChar
;
}
}
nsAutoString
incrementalString
(
mIncrementalString
)
;
uint32_t
charIndex
=
1
stringLength
=
incrementalString
.
Length
(
)
;
while
(
charIndex
<
stringLength
&
&
incrementalString
[
charIndex
]
=
=
incrementalString
[
charIndex
-
1
]
)
{
charIndex
+
+
;
}
if
(
charIndex
=
=
stringLength
)
{
incrementalString
.
Truncate
(
1
)
;
stringLength
=
1
;
}
sLastKeyTime
=
keyTime
;
nsIFrame
*
firstMenuItem
=
nsXULPopupManager
:
:
GetNextMenuItem
(
immediateParent
nullptr
true
false
)
;
nsIFrame
*
currFrame
=
firstMenuItem
;
int32_t
menuAccessKey
=
-
1
;
nsMenuBarListener
:
:
GetMenuAccessKey
(
&
menuAccessKey
)
;
while
(
currFrame
)
{
nsIContent
*
current
=
currFrame
-
>
GetContent
(
)
;
nsAutoString
textKey
;
bool
isShortcut
=
false
;
if
(
current
-
>
IsElement
(
)
)
{
if
(
menuAccessKey
>
=
0
)
{
current
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
accesskey
textKey
)
;
}
isShortcut
=
!
textKey
.
IsEmpty
(
)
;
if
(
textKey
.
IsEmpty
(
)
)
{
current
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
label
textKey
)
;
if
(
textKey
.
IsEmpty
(
)
)
current
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
value
textKey
)
;
}
}
if
(
StringBeginsWith
(
textKey
incrementalString
nsCaseInsensitiveStringComparator
(
)
)
)
{
nsMenuFrame
*
menu
=
do_QueryFrame
(
currFrame
)
;
if
(
menu
)
{
matchCount
+
+
;
if
(
isShortcut
)
{
matchShortcutCount
+
+
;
frameShortcut
=
menu
;
}
if
(
!
foundActive
)
{
if
(
!
frameBefore
)
frameBefore
=
menu
;
}
else
{
if
(
!
frameAfter
)
frameAfter
=
menu
;
}
}
else
return
nullptr
;
}
if
(
current
-
>
IsElement
(
)
&
&
current
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
menuactive
nsGkAtoms
:
:
_true
eCaseMatters
)
)
{
foundActive
=
true
;
if
(
stringLength
>
1
)
{
if
(
currFrame
=
=
frameBefore
)
return
frameBefore
;
}
}
nsMenuFrame
*
menu
=
do_QueryFrame
(
currFrame
)
;
currFrame
=
nsXULPopupManager
:
:
GetNextMenuItem
(
immediateParent
menu
true
true
)
;
if
(
currFrame
=
=
firstMenuItem
)
break
;
}
doAction
=
(
isMenu
&
&
(
matchCount
=
=
1
|
|
matchShortcutCount
=
=
1
)
)
;
if
(
matchShortcutCount
=
=
1
)
return
frameShortcut
;
if
(
frameAfter
)
return
frameAfter
;
else
if
(
frameBefore
)
return
frameBefore
;
mIncrementalString
.
SetLength
(
mIncrementalString
.
Length
(
)
-
1
)
;
#
ifdef
XP_WIN
if
(
isMenu
)
{
nsCOMPtr
<
nsISound
>
soundInterface
=
do_CreateInstance
(
"
mozilla
.
org
/
sound
;
1
"
)
;
if
(
soundInterface
)
soundInterface
-
>
Beep
(
)
;
}
#
endif
return
nullptr
;
}
void
nsMenuPopupFrame
:
:
LockMenuUntilClosed
(
bool
aLock
)
{
mIsMenuLocked
=
aLock
;
nsMenuFrame
*
menu
=
do_QueryFrame
(
GetParent
(
)
)
;
if
(
menu
)
{
nsMenuParent
*
parentParent
=
menu
-
>
GetMenuParent
(
)
;
if
(
parentParent
)
{
parentParent
-
>
LockMenuUntilClosed
(
aLock
)
;
}
}
}
nsIWidget
*
nsMenuPopupFrame
:
:
GetWidget
(
)
{
nsView
*
view
=
GetRootViewForPopup
(
this
)
;
if
(
!
view
)
return
nullptr
;
return
view
-
>
GetWidget
(
)
;
}
nsresult
nsMenuPopupFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
nsresult
rv
=
nsBoxFrame
:
:
AttributeChanged
(
aNameSpaceID
aAttribute
aModType
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
left
|
|
aAttribute
=
=
nsGkAtoms
:
:
top
)
MoveToAttributePosition
(
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
remote
)
{
EnsureWidget
(
true
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
followanchor
)
{
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
pm
)
{
pm
-
>
UpdateFollowAnchor
(
this
)
;
}
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
label
)
{
nsView
*
view
=
GetView
(
)
;
if
(
view
)
{
nsIWidget
*
widget
=
view
-
>
GetWidget
(
)
;
if
(
widget
)
{
nsAutoString
title
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
label
title
)
;
if
(
!
title
.
IsEmpty
(
)
)
{
widget
-
>
SetTitle
(
title
)
;
}
}
}
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
ignorekeys
)
{
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
pm
)
{
nsAutoString
ignorekeys
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
ignorekeys
ignorekeys
)
;
pm
-
>
UpdateIgnoreKeys
(
ignorekeys
.
EqualsLiteral
(
"
true
"
)
)
;
}
}
return
rv
;
}
void
nsMenuPopupFrame
:
:
MoveToAttributePosition
(
)
{
nsAutoString
left
top
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
left
left
)
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
top
top
)
;
nsresult
err1
err2
;
mozilla
:
:
CSSIntPoint
pos
(
left
.
ToInteger
(
&
err1
)
top
.
ToInteger
(
&
err2
)
)
;
if
(
NS_SUCCEEDED
(
err1
)
&
&
NS_SUCCEEDED
(
err2
)
)
MoveTo
(
pos
false
)
;
}
void
nsMenuPopupFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
{
if
(
mReflowCallbackData
.
mPosted
)
{
PresShell
(
)
-
>
CancelReflowCallback
(
this
)
;
mReflowCallbackData
.
Clear
(
)
;
}
nsMenuFrame
*
menu
=
do_QueryFrame
(
GetParent
(
)
)
;
if
(
menu
)
{
nsContentUtils
:
:
AddScriptRunner
(
new
nsUnsetAttrRunnable
(
menu
-
>
GetContent
(
)
-
>
AsElement
(
)
nsGkAtoms
:
:
open
)
)
;
}
ClearPopupShownDispatcher
(
)
;
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
pm
)
pm
-
>
PopupDestroyed
(
this
)
;
nsIPopupContainer
*
popupContainer
=
nsIPopupContainer
:
:
GetPopupContainer
(
PresContext
(
)
-
>
GetPresShell
(
)
)
;
if
(
popupContainer
&
&
popupContainer
-
>
GetDefaultTooltip
(
)
=
=
mContent
)
{
popupContainer
-
>
SetDefaultTooltip
(
nullptr
)
;
}
nsBoxFrame
:
:
DestroyFrom
(
aDestructRoot
aPostDestroyData
)
;
}
void
nsMenuPopupFrame
:
:
MoveTo
(
const
CSSIntPoint
&
aPos
bool
aUpdateAttrs
)
{
nsIWidget
*
widget
=
GetWidget
(
)
;
if
(
(
mScreenRect
.
x
=
=
aPos
.
x
&
&
mScreenRect
.
y
=
=
aPos
.
y
)
&
&
(
!
widget
|
|
widget
-
>
GetClientOffset
(
)
=
=
mLastClientOffset
)
)
{
return
;
}
nsMargin
margin
(
0
0
0
0
)
;
StyleMargin
(
)
-
>
GetMargin
(
margin
)
;
if
(
mAdjustOffsetForContextMenu
)
{
margin
.
left
+
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
eIntID_ContextMenuOffsetHorizontal
)
)
;
margin
.
top
+
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
eIntID_ContextMenuOffsetVertical
)
)
;
}
mAnchorType
=
MenuPopupAnchorType_Point
;
mScreenRect
.
x
=
aPos
.
x
-
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
margin
.
left
)
;
mScreenRect
.
y
=
aPos
.
y
-
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
margin
.
top
)
;
SetPopupPosition
(
nullptr
true
false
true
)
;
RefPtr
<
Element
>
popup
=
mContent
-
>
AsElement
(
)
;
if
(
aUpdateAttrs
&
&
(
popup
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
left
)
|
|
popup
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
top
)
)
)
{
nsAutoString
left
top
;
left
.
AppendInt
(
aPos
.
x
)
;
top
.
AppendInt
(
aPos
.
y
)
;
popup
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
left
left
false
)
;
popup
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
top
top
false
)
;
}
}
void
nsMenuPopupFrame
:
:
MoveToAnchor
(
nsIContent
*
aAnchorContent
const
nsAString
&
aPosition
int32_t
aXPos
int32_t
aYPos
bool
aAttributesOverride
)
{
NS_ASSERTION
(
IsVisible
(
)
"
popup
must
be
visible
to
move
it
"
)
;
nsPopupState
oldstate
=
mPopupState
;
InitializePopup
(
aAnchorContent
mTriggerContent
aPosition
aXPos
aYPos
MenuPopupAnchorType_Node
aAttributesOverride
)
;
mPopupState
=
oldstate
;
SetPopupPosition
(
nullptr
false
false
true
)
;
}
bool
nsMenuPopupFrame
:
:
GetAutoPosition
(
)
{
return
mShouldAutoPosition
;
}
void
nsMenuPopupFrame
:
:
SetAutoPosition
(
bool
aShouldAutoPosition
)
{
mShouldAutoPosition
=
aShouldAutoPosition
;
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
pm
)
{
pm
-
>
UpdateFollowAnchor
(
this
)
;
}
}
int8_t
nsMenuPopupFrame
:
:
GetAlignmentPosition
(
)
const
{
if
(
mPosition
=
=
POPUPPOSITION_OVERLAP
|
|
mPosition
=
=
POPUPPOSITION_AFTERPOINTER
|
|
mPosition
=
=
POPUPPOSITION_SELECTION
)
return
mPosition
;
int8_t
position
=
mPosition
;
if
(
position
=
=
POPUPPOSITION_UNKNOWN
)
{
switch
(
mPopupAnchor
)
{
case
POPUPALIGNMENT_BOTTOMCENTER
:
position
=
mPopupAlignment
=
=
POPUPALIGNMENT_TOPRIGHT
?
POPUPPOSITION_AFTEREND
:
POPUPPOSITION_AFTERSTART
;
break
;
case
POPUPALIGNMENT_TOPCENTER
:
position
=
mPopupAlignment
=
=
POPUPALIGNMENT_BOTTOMRIGHT
?
POPUPPOSITION_BEFOREEND
:
POPUPPOSITION_BEFORESTART
;
break
;
case
POPUPALIGNMENT_LEFTCENTER
:
position
=
mPopupAlignment
=
=
POPUPALIGNMENT_BOTTOMRIGHT
?
POPUPPOSITION_STARTAFTER
:
POPUPPOSITION_STARTBEFORE
;
break
;
case
POPUPALIGNMENT_RIGHTCENTER
:
position
=
mPopupAlignment
=
=
POPUPALIGNMENT_BOTTOMLEFT
?
POPUPPOSITION_ENDAFTER
:
POPUPPOSITION_ENDBEFORE
;
break
;
default
:
break
;
}
}
if
(
mHFlip
)
{
position
=
POPUPPOSITION_HFLIP
(
position
)
;
}
if
(
mVFlip
)
{
position
=
POPUPPOSITION_VFLIP
(
position
)
;
}
return
position
;
}
void
nsMenuPopupFrame
:
:
CreatePopupView
(
)
{
if
(
HasView
(
)
)
{
return
;
}
nsViewManager
*
viewManager
=
PresContext
(
)
-
>
GetPresShell
(
)
-
>
GetViewManager
(
)
;
NS_ASSERTION
(
nullptr
!
=
viewManager
"
null
view
manager
"
)
;
nsView
*
parentView
=
viewManager
-
>
GetRootView
(
)
;
nsViewVisibility
visibility
=
nsViewVisibility_kHide
;
int32_t
zIndex
=
INT32_MAX
;
bool
autoZIndex
=
false
;
NS_ASSERTION
(
parentView
"
no
parent
view
"
)
;
nsView
*
view
=
viewManager
-
>
CreateView
(
GetRect
(
)
parentView
visibility
)
;
viewManager
-
>
SetViewZIndex
(
view
autoZIndex
zIndex
)
;
viewManager
-
>
InsertChild
(
parentView
view
nullptr
true
)
;
SetView
(
view
)
;
NS_FRAME_LOG
(
NS_FRAME_TRACE_CALLS
(
"
nsMenuPopupFrame
:
:
CreatePopupView
:
frame
=
%
p
view
=
%
p
"
this
view
)
)
;
}
bool
nsMenuPopupFrame
:
:
ShouldFollowAnchor
(
)
{
if
(
!
mShouldAutoPosition
|
|
mAnchorType
!
=
MenuPopupAnchorType_Node
|
|
!
mAnchorContent
)
{
return
false
;
}
if
(
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
followanchor
nsGkAtoms
:
:
_true
eCaseMatters
)
)
{
return
true
;
}
if
(
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
followanchor
nsGkAtoms
:
:
_false
eCaseMatters
)
)
{
return
false
;
}
return
(
mPopupType
=
=
ePopupTypePanel
&
&
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
type
nsGkAtoms
:
:
arrow
eCaseMatters
)
)
;
}
bool
nsMenuPopupFrame
:
:
ShouldFollowAnchor
(
nsRect
&
aRect
)
{
if
(
!
ShouldFollowAnchor
(
)
)
{
return
false
;
}
nsIFrame
*
anchorFrame
=
mAnchorContent
-
>
GetPrimaryFrame
(
)
;
if
(
anchorFrame
)
{
nsPresContext
*
rootPresContext
=
PresContext
(
)
-
>
GetRootPresContext
(
)
;
if
(
rootPresContext
)
{
aRect
=
ComputeAnchorRect
(
rootPresContext
anchorFrame
)
;
}
}
return
true
;
}
void
nsMenuPopupFrame
:
:
CheckForAnchorChange
(
nsRect
&
aRect
)
{
if
(
!
IsVisible
(
)
|
|
!
ShouldFollowAnchor
(
)
)
{
return
;
}
bool
shouldHide
=
false
;
nsPresContext
*
rootPresContext
=
PresContext
(
)
-
>
GetRootPresContext
(
)
;
nsIFrame
*
anchor
=
mAnchorContent
-
>
GetPrimaryFrame
(
)
;
if
(
!
anchor
|
|
!
rootPresContext
)
{
shouldHide
=
true
;
}
else
if
(
!
anchor
-
>
IsVisibleConsideringAncestors
(
VISIBILITY_CROSS_CHROME_CONTENT_BOUNDARY
)
)
{
shouldHide
=
true
;
}
else
{
nsIFrame
*
frame
=
anchor
;
while
(
frame
)
{
nsMenuPopupFrame
*
popup
=
do_QueryFrame
(
frame
)
;
if
(
popup
&
&
popup
-
>
PopupState
(
)
!
=
ePopupShown
)
{
shouldHide
=
true
;
break
;
}
frame
=
frame
-
>
GetParent
(
)
;
}
}
if
(
shouldHide
)
{
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
pm
)
{
pm
-
>
HidePopup
(
mContent
false
true
true
false
)
;
}
return
;
}
nsRect
anchorRect
=
ComputeAnchorRect
(
rootPresContext
anchor
)
;
if
(
!
anchorRect
.
IsEqualEdges
(
aRect
)
)
{
aRect
=
anchorRect
;
SetPopupPosition
(
nullptr
true
false
true
)
;
}
}
nsIWidget
*
nsMenuPopupFrame
:
:
GetParentMenuWidget
(
)
{
nsMenuFrame
*
menuFrame
=
do_QueryFrame
(
GetParent
(
)
)
;
if
(
menuFrame
)
{
nsMenuParent
*
parentPopup
=
menuFrame
-
>
GetMenuParent
(
)
;
if
(
parentPopup
&
&
parentPopup
-
>
IsMenu
(
)
)
{
return
static_cast
<
nsMenuPopupFrame
*
>
(
parentPopup
)
-
>
GetWidget
(
)
;
}
}
return
nullptr
;
}
