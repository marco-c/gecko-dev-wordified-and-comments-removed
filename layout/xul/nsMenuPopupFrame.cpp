#
include
"
nsMenuPopupFrame
.
h
"
#
include
"
XULButtonElement
.
h
"
#
include
"
XULPopupElement
.
h
"
#
include
"
mozilla
/
dom
/
XULPopupElement
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
mozilla
/
ComputedStyle
.
h
"
#
include
"
nsCSSRendering
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsWidgetsCID
.
h
"
#
include
"
nsMenuBarFrame
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsFrameManager
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsBoxLayoutState
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsIPopupContainer
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
nsPIWindowRoot
.
h
"
#
include
"
nsIReflowCallback
.
h
"
#
include
"
nsIDocShellTreeOwner
.
h
"
#
include
"
nsIBaseWindow
.
h
"
#
include
"
nsISound
.
h
"
#
include
"
nsIScreenManager
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsStyleStructInlines
.
h
"
#
include
"
nsTransitionManager
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsIDOMXULSelectCntrlEl
.
h
"
#
include
"
mozilla
/
AnimationUtils
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
dom
/
BrowserParent
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
KeyboardEvent
.
h
"
#
include
"
mozilla
/
dom
/
KeyboardEventBinding
.
h
"
#
include
<
algorithm
>
#
include
"
X11UndefineNone
.
h
"
#
include
"
nsXULPopupManager
.
h
"
using
namespace
mozilla
;
using
mozilla
:
:
dom
:
:
Document
;
using
mozilla
:
:
dom
:
:
Element
;
using
mozilla
:
:
dom
:
:
Event
;
using
mozilla
:
:
dom
:
:
XULButtonElement
;
int8_t
nsMenuPopupFrame
:
:
sDefaultLevelIsTop
=
-
1
;
TimeStamp
nsMenuPopupFrame
:
:
sLastKeyTime
;
#
ifdef
MOZ_WAYLAND
#
include
"
mozilla
/
WidgetUtilsGtk
.
h
"
#
define
IS_WAYLAND_DISPLAY
(
)
mozilla
:
:
widget
:
:
GdkIsWaylandDisplay
(
)
extern
mozilla
:
:
LazyLogModule
gWidgetPopupLog
;
#
define
LOG_WAYLAND
(
.
.
.
)
\
MOZ_LOG
(
gWidgetPopupLog
mozilla
:
:
LogLevel
:
:
Debug
(
__VA_ARGS__
)
)
#
else
#
define
IS_WAYLAND_DISPLAY
(
)
false
#
define
LOG_WAYLAND
(
.
.
.
)
#
endif
nsIFrame
*
NS_NewMenuPopupFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsMenuPopupFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsMenuPopupFrame
)
NS_QUERYFRAME_HEAD
(
nsMenuPopupFrame
)
NS_QUERYFRAME_ENTRY
(
nsMenuPopupFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsBoxFrame
)
nsMenuPopupFrame
:
:
nsMenuPopupFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
:
nsBoxFrame
(
aStyle
aPresContext
kClassID
)
mView
(
nullptr
)
mPrefSize
(
-
1
-
1
)
mXPos
(
0
)
mYPos
(
0
)
mAlignmentOffset
(
0
)
mLastClientOffset
(
0
0
)
mPopupType
(
ePopupTypePanel
)
mPopupState
(
ePopupClosed
)
mPopupAlignment
(
POPUPALIGNMENT_NONE
)
mPopupAnchor
(
POPUPALIGNMENT_NONE
)
mPosition
(
POPUPPOSITION_UNKNOWN
)
mFlip
(
FlipType_Default
)
mIsOpenChanged
(
false
)
mMenuCanOverlapOSBar
(
false
)
mInContentShell
(
true
)
mIsOffset
(
false
)
mHFlip
(
false
)
mVFlip
(
false
)
mPositionedOffset
(
0
)
mAnchorType
(
MenuPopupAnchorType_Node
)
{
if
(
sDefaultLevelIsTop
>
=
0
)
return
;
sDefaultLevelIsTop
=
Preferences
:
:
GetBool
(
"
ui
.
panel
.
default_level_parent
"
false
)
;
}
nsMenuPopupFrame
:
:
~
nsMenuPopupFrame
(
)
=
default
;
static
bool
IsMouseTransparent
(
const
ComputedStyle
&
aStyle
)
{
return
aStyle
.
PointerEvents
(
)
=
=
StylePointerEvents
:
:
None
;
}
static
nsIWidget
:
:
InputRegion
ComputeInputRegion
(
const
ComputedStyle
&
aStyle
const
nsPresContext
&
aPc
)
{
return
{
IsMouseTransparent
(
aStyle
)
(
aStyle
.
StyleUIReset
(
)
-
>
mMozWindowInputRegionMargin
.
ToCSSPixels
(
)
*
aPc
.
CSSToDevPixelScale
(
)
)
.
Truncated
(
)
}
;
}
bool
nsMenuPopupFrame
:
:
ShouldCreateWidgetUpfront
(
)
const
{
if
(
mPopupType
!
=
ePopupTypeMenu
)
{
return
mContent
-
>
AsElement
(
)
-
>
HasAttr
(
nsGkAtoms
:
:
type
)
;
}
return
ShouldExpandToInflowParentOrAnchor
(
)
;
}
void
nsMenuPopupFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
nsBoxFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
mMenuCanOverlapOSBar
=
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
IntID
:
:
MenusCanOverlapOSBar
)
!
=
0
;
CreatePopupView
(
)
;
nsView
*
ourView
=
GetView
(
)
;
nsViewManager
*
viewManager
=
ourView
-
>
GetViewManager
(
)
;
viewManager
-
>
SetViewFloating
(
ourView
true
)
;
mPopupType
=
ePopupTypePanel
;
if
(
aContent
-
>
IsAnyOfXULElements
(
nsGkAtoms
:
:
menupopup
nsGkAtoms
:
:
popup
)
)
{
mPopupType
=
ePopupTypeMenu
;
}
else
if
(
aContent
-
>
IsXULElement
(
nsGkAtoms
:
:
tooltip
)
)
{
mPopupType
=
ePopupTypeTooltip
;
}
if
(
PresContext
(
)
-
>
IsChrome
(
)
)
{
mInContentShell
=
false
;
}
if
(
aContent
-
>
NodePrincipal
(
)
-
>
IsSystemPrincipal
(
)
)
{
if
(
aContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
incontentshell
nsGkAtoms
:
:
_true
eCaseMatters
)
)
{
mInContentShell
=
true
;
}
else
if
(
aContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
incontentshell
nsGkAtoms
:
:
_false
eCaseMatters
)
)
{
mInContentShell
=
false
;
}
}
if
(
!
ourView
-
>
HasWidget
(
)
&
&
ShouldCreateWidgetUpfront
(
)
)
{
CreateWidgetForView
(
ourView
)
;
}
AddStateBits
(
NS_FRAME_IN_POPUP
)
;
}
bool
nsMenuPopupFrame
:
:
HasRemoteContent
(
)
const
{
return
(
!
mInContentShell
&
&
mPopupType
=
=
ePopupTypePanel
&
&
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
remote
nsGkAtoms
:
:
_true
eIgnoreCase
)
)
;
}
bool
nsMenuPopupFrame
:
:
IsNoAutoHide
(
)
const
{
return
(
!
mInContentShell
&
&
mPopupType
=
=
ePopupTypePanel
&
&
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
noautohide
nsGkAtoms
:
:
_true
eIgnoreCase
)
)
;
}
nsPopupLevel
nsMenuPopupFrame
:
:
PopupLevel
(
bool
aIsNoAutoHide
)
const
{
if
(
mPopupType
!
=
ePopupTypePanel
)
return
ePopupLevelTop
;
static
Element
:
:
AttrValuesArray
strings
[
]
=
{
nsGkAtoms
:
:
top
nsGkAtoms
:
:
parent
nsGkAtoms
:
:
floating
nullptr
}
;
switch
(
mContent
-
>
AsElement
(
)
-
>
FindAttrValueIn
(
kNameSpaceID_None
nsGkAtoms
:
:
level
strings
eCaseMatters
)
)
{
case
0
:
return
ePopupLevelTop
;
case
1
:
return
ePopupLevelParent
;
case
2
:
return
ePopupLevelFloating
;
}
if
(
mContent
-
>
AsElement
(
)
-
>
HasAttr
(
nsGkAtoms
:
:
titlebar
)
)
return
ePopupLevelFloating
;
if
(
aIsNoAutoHide
)
return
ePopupLevelParent
;
return
sDefaultLevelIsTop
?
ePopupLevelTop
:
ePopupLevelParent
;
}
void
nsMenuPopupFrame
:
:
PrepareWidget
(
bool
aRecreate
)
{
nsView
*
ourView
=
GetView
(
)
;
if
(
aRecreate
)
{
if
(
auto
*
widget
=
GetWidget
(
)
)
{
widget
-
>
ClearCachedWebrenderResources
(
)
;
}
ourView
-
>
DestroyWidget
(
)
;
}
if
(
!
ourView
-
>
HasWidget
(
)
)
{
CreateWidgetForView
(
ourView
)
;
}
if
(
nsIWidget
*
widget
=
GetWidget
(
)
)
{
widget
-
>
SetColorScheme
(
Some
(
LookAndFeel
:
:
ColorSchemeForFrame
(
this
)
)
)
;
}
}
nsresult
nsMenuPopupFrame
:
:
CreateWidgetForView
(
nsView
*
aView
)
{
nsWidgetInitData
widgetData
;
widgetData
.
mWindowType
=
eWindowType_popup
;
widgetData
.
mBorderStyle
=
eBorderStyle_default
;
widgetData
.
mForMenupopupFrame
=
true
;
widgetData
.
mClipSiblings
=
true
;
widgetData
.
mPopupHint
=
mPopupType
;
widgetData
.
mNoAutoHide
=
IsNoAutoHide
(
)
;
if
(
!
mInContentShell
)
{
if
(
mPopupType
=
=
ePopupTypePanel
&
&
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
type
nsGkAtoms
:
:
drag
eIgnoreCase
)
)
{
widgetData
.
mIsDragPopup
=
true
;
}
}
nsAutoString
title
;
if
(
widgetData
.
mNoAutoHide
)
{
if
(
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
titlebar
nsGkAtoms
:
:
normal
eCaseMatters
)
)
{
widgetData
.
mBorderStyle
=
eBorderStyle_title
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
label
title
)
;
if
(
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
close
nsGkAtoms
:
:
_true
eCaseMatters
)
)
{
widgetData
.
mBorderStyle
=
static_cast
<
enum
nsBorderStyle
>
(
widgetData
.
mBorderStyle
|
eBorderStyle_close
)
;
}
}
}
bool
remote
=
HasRemoteContent
(
)
;
nsTransparencyMode
mode
=
nsLayoutUtils
:
:
GetFrameTransparency
(
this
this
)
;
widgetData
.
mHasRemoteContent
=
remote
;
widgetData
.
mSupportTranslucency
=
mode
=
=
eTransparencyTransparent
;
widgetData
.
mPopupLevel
=
PopupLevel
(
widgetData
.
mNoAutoHide
)
;
nsCOMPtr
<
nsIWidget
>
parentWidget
;
if
(
widgetData
.
mPopupLevel
!
=
ePopupLevelTop
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
dsti
=
PresContext
(
)
-
>
GetDocShell
(
)
;
if
(
!
dsti
)
return
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsIDocShellTreeOwner
>
treeOwner
;
dsti
-
>
GetTreeOwner
(
getter_AddRefs
(
treeOwner
)
)
;
if
(
!
treeOwner
)
return
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsIBaseWindow
>
baseWindow
(
do_QueryInterface
(
treeOwner
)
)
;
if
(
baseWindow
)
baseWindow
-
>
GetMainWidget
(
getter_AddRefs
(
parentWidget
)
)
;
}
nsresult
rv
=
aView
-
>
CreateWidgetForPopup
(
&
widgetData
parentWidget
true
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
nsIWidget
*
widget
=
aView
-
>
GetWidget
(
)
;
widget
-
>
SetTransparencyMode
(
mode
)
;
widget
-
>
SetInputRegion
(
ComputeInputRegion
(
*
Style
(
)
*
PresContext
(
)
)
)
;
widget
-
>
SetWindowShadowStyle
(
GetShadowStyle
(
)
)
;
widget
-
>
SetWindowOpacity
(
StyleUIReset
(
)
-
>
mWindowOpacity
)
;
widget
-
>
SetWindowTransform
(
ComputeWidgetTransform
(
)
)
;
if
(
!
title
.
IsEmpty
(
)
)
{
widget
-
>
SetTitle
(
title
)
;
}
return
NS_OK
;
}
bool
nsMenuPopupFrame
:
:
IsMouseTransparent
(
)
const
{
return
:
:
IsMouseTransparent
(
*
Style
(
)
)
;
}
StyleWindowShadow
nsMenuPopupFrame
:
:
GetShadowStyle
(
)
{
StyleWindowShadow
shadow
=
StyleUIReset
(
)
-
>
mWindowShadow
;
if
(
shadow
!
=
StyleWindowShadow
:
:
Default
)
return
shadow
;
switch
(
StyleDisplay
(
)
-
>
EffectiveAppearance
(
)
)
{
case
StyleAppearance
:
:
Tooltip
:
return
StyleWindowShadow
:
:
Tooltip
;
case
StyleAppearance
:
:
Menupopup
:
return
StyleWindowShadow
:
:
Menu
;
default
:
return
StyleWindowShadow
:
:
Default
;
}
}
void
nsMenuPopupFrame
:
:
SetPopupState
(
nsPopupState
aState
)
{
mPopupState
=
aState
;
if
(
aState
=
=
ePopupShown
&
&
IS_WAYLAND_DISPLAY
(
)
)
{
if
(
nsIWidget
*
widget
=
GetWidget
(
)
)
{
widget
-
>
SetInputRegion
(
ComputeInputRegion
(
*
Style
(
)
*
PresContext
(
)
)
)
;
}
}
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
NS_IMETHODIMP
nsXULPopupShownEvent
:
:
Run
(
)
{
nsMenuPopupFrame
*
popup
=
do_QueryFrame
(
mPopup
-
>
GetPrimaryFrame
(
)
)
;
if
(
popup
&
&
popup
-
>
IsOpen
(
)
)
{
popup
-
>
SetPopupState
(
ePopupShown
)
;
}
if
(
!
mPopup
-
>
IsXULElement
(
nsGkAtoms
:
:
tooltip
)
)
{
nsCOMPtr
<
nsIObserverService
>
obsService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obsService
)
{
obsService
-
>
NotifyObservers
(
mPopup
"
popup
-
shown
"
nullptr
)
;
}
}
WidgetMouseEvent
event
(
true
eXULPopupShown
nullptr
WidgetMouseEvent
:
:
eReal
)
;
return
EventDispatcher
:
:
Dispatch
(
mPopup
mPresContext
&
event
)
;
}
NS_IMETHODIMP
nsXULPopupShownEvent
:
:
HandleEvent
(
Event
*
aEvent
)
{
nsMenuPopupFrame
*
popup
=
do_QueryFrame
(
mPopup
-
>
GetPrimaryFrame
(
)
)
;
if
(
mPopup
!
=
aEvent
-
>
GetTarget
(
)
)
{
return
NS_OK
;
}
if
(
popup
)
{
RefPtr
<
nsXULPopupShownEvent
>
event
=
this
;
if
(
popup
-
>
ClearPopupShownDispatcher
(
)
)
{
return
Run
(
)
;
}
}
CancelListener
(
)
;
return
NS_OK
;
}
void
nsXULPopupShownEvent
:
:
CancelListener
(
)
{
mPopup
-
>
RemoveSystemEventListener
(
u
"
transitionend
"
_ns
this
false
)
;
}
NS_IMPL_ISUPPORTS_INHERITED
(
nsXULPopupShownEvent
Runnable
nsIDOMEventListener
)
;
void
nsMenuPopupFrame
:
:
DidSetComputedStyle
(
ComputedStyle
*
aOldStyle
)
{
nsBoxFrame
:
:
DidSetComputedStyle
(
aOldStyle
)
;
if
(
!
aOldStyle
)
{
return
;
}
auto
&
newUI
=
*
StyleUIReset
(
)
;
auto
&
oldUI
=
*
aOldStyle
-
>
StyleUIReset
(
)
;
if
(
newUI
.
mWindowOpacity
!
=
oldUI
.
mWindowOpacity
)
{
if
(
nsIWidget
*
widget
=
GetWidget
(
)
)
{
widget
-
>
SetWindowOpacity
(
newUI
.
mWindowOpacity
)
;
}
}
if
(
newUI
.
mMozWindowTransform
!
=
oldUI
.
mMozWindowTransform
)
{
if
(
nsIWidget
*
widget
=
GetWidget
(
)
)
{
widget
-
>
SetWindowTransform
(
ComputeWidgetTransform
(
)
)
;
}
}
auto
oldRegion
=
ComputeInputRegion
(
*
aOldStyle
*
PresContext
(
)
)
;
auto
newRegion
=
ComputeInputRegion
(
*
Style
(
)
*
PresContext
(
)
)
;
if
(
oldRegion
.
mFullyTransparent
!
=
newRegion
.
mFullyTransparent
|
|
oldRegion
.
mMargin
!
=
newRegion
.
mMargin
)
{
if
(
nsIWidget
*
widget
=
GetWidget
(
)
)
{
widget
-
>
SetInputRegion
(
newRegion
)
;
}
}
}
void
nsMenuPopupFrame
:
:
ConstrainSizeForWayland
(
nsSize
&
aSize
)
const
{
#
ifdef
MOZ_WAYLAND
if
(
!
IS_WAYLAND_DISPLAY
(
)
)
{
return
;
}
int32_t
appPerCSS
=
AppUnitsPerCSSPixel
(
)
;
if
(
aSize
.
width
%
appPerCSS
>
0
)
{
aSize
.
width
+
=
appPerCSS
;
}
if
(
aSize
.
height
%
appPerCSS
>
0
)
{
aSize
.
height
+
=
appPerCSS
;
}
nsIWidget
*
widget
=
GetWidget
(
)
;
if
(
!
widget
)
{
return
;
}
const
nsSize
waylandSize
=
LayoutDeviceIntRect
:
:
ToAppUnits
(
widget
-
>
GetMoveToRectPopupSize
(
)
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
if
(
waylandSize
.
width
>
0
&
&
aSize
.
width
>
waylandSize
.
width
)
{
LOG_WAYLAND
(
"
Wayland
constraint
width
[
%
p
]
:
%
d
to
%
d
"
widget
aSize
.
width
waylandSize
.
width
)
;
aSize
.
width
=
waylandSize
.
width
;
}
if
(
waylandSize
.
height
>
0
&
&
aSize
.
height
>
waylandSize
.
height
)
{
LOG_WAYLAND
(
"
Wayland
constraint
height
[
%
p
]
:
%
d
to
%
d
"
widget
aSize
.
height
waylandSize
.
height
)
;
aSize
.
height
=
waylandSize
.
height
;
}
#
endif
}
void
nsMenuPopupFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsMenuPopupFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aDesiredSize
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
nsBoxLayoutState
state
(
aPresContext
aReflowInput
.
mRenderingContext
&
aReflowInput
aReflowInput
.
mReflowDepth
)
;
LayoutPopup
(
state
)
;
const
auto
wm
=
GetWritingMode
(
)
;
LogicalSize
boxSize
=
GetLogicalSize
(
wm
)
;
aDesiredSize
.
SetSize
(
wm
boxSize
)
;
aDesiredSize
.
SetBlockStartAscent
(
boxSize
.
BSize
(
wm
)
)
;
aDesiredSize
.
SetOverflowAreasToDesiredBounds
(
)
;
FinishAndStoreOverflow
(
&
aDesiredSize
aReflowInput
.
mStyleDisplay
)
;
}
void
nsMenuPopupFrame
:
:
EnsureActiveMenuListItemIsVisible
(
)
{
if
(
!
IsMenuList
(
)
|
|
!
IsOpen
(
)
)
{
return
;
}
nsIFrame
*
frame
=
GetCurrentMenuItemFrame
(
)
;
if
(
!
frame
)
{
return
;
}
RefPtr
<
mozilla
:
:
PresShell
>
presShell
=
PresShell
(
)
;
presShell
-
>
ScrollFrameIntoView
(
frame
Nothing
(
)
ScrollAxis
(
)
ScrollAxis
(
)
ScrollFlags
:
:
ScrollOverflowHidden
|
ScrollFlags
:
:
ScrollFirstAncestorOnly
)
;
}
void
nsMenuPopupFrame
:
:
LayoutPopup
(
nsBoxLayoutState
&
aState
)
{
if
(
IsNativeMenu
(
)
)
{
return
;
}
SchedulePaint
(
)
;
bool
shouldPosition
=
[
&
]
{
if
(
!
IsAnchored
(
)
)
{
return
true
;
}
if
(
ShouldFollowAnchor
(
)
)
{
return
true
;
}
return
mPopupState
!
=
ePopupShown
|
|
mUsedScreenRect
.
IsEmpty
(
)
;
}
(
)
;
bool
isOpen
=
IsOpen
(
)
;
if
(
!
isOpen
)
{
shouldPosition
=
mPopupState
=
=
ePopupShowing
|
|
mPopupState
=
=
ePopupPositioning
;
const
bool
needsLayout
=
shouldPosition
|
|
IsMenuList
(
)
;
if
(
!
needsLayout
)
{
RemoveStateBits
(
NS_FRAME_FIRST_REFLOW
)
;
return
;
}
}
if
(
mIsOpenChanged
&
&
!
IsMenuList
(
)
)
{
nsIScrollableFrame
*
scrollframe
=
do_QueryFrame
(
nsIFrame
:
:
GetChildXULBox
(
this
)
)
;
if
(
scrollframe
)
{
AutoWeakFrame
weakFrame
(
this
)
;
scrollframe
-
>
ScrollTo
(
nsPoint
(
0
0
)
ScrollMode
:
:
Instant
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
;
}
}
}
nsSize
prefSize
=
GetXULPrefSize
(
aState
)
;
nsSize
minSize
=
GetXULMinSize
(
aState
)
;
nsSize
maxSize
=
GetXULMaxSize
(
aState
)
;
if
(
ShouldExpandToInflowParentOrAnchor
(
)
)
{
if
(
nsIScrollableFrame
*
sf
=
GetScrollFrame
(
this
)
)
{
prefSize
.
width
+
=
sf
-
>
GetDesiredScrollbarSizes
(
&
aState
)
.
LeftRight
(
)
;
}
nscoord
menuListOrAnchorWidth
=
0
;
if
(
nsIFrame
*
menuList
=
GetInFlowParent
(
)
)
{
menuListOrAnchorWidth
=
menuList
-
>
GetRect
(
)
.
width
;
}
if
(
mAnchorType
=
=
MenuPopupAnchorType_Rect
)
{
menuListOrAnchorWidth
=
std
:
:
max
(
menuListOrAnchorWidth
mScreenRect
.
width
)
;
}
menuListOrAnchorWidth
+
=
2
*
StyleUIReset
(
)
-
>
mMozWindowInputRegionMargin
.
ToAppUnits
(
)
;
prefSize
.
width
=
std
:
:
max
(
prefSize
.
width
menuListOrAnchorWidth
)
;
}
prefSize
=
XULBoundsCheck
(
minSize
prefSize
maxSize
)
;
ConstrainSizeForWayland
(
prefSize
)
;
const
bool
sizeChanged
=
mPrefSize
!
=
prefSize
;
if
(
sizeChanged
)
{
shouldPosition
=
true
;
SetXULBounds
(
aState
nsRect
(
nsPoint
(
)
prefSize
)
false
)
;
mPrefSize
=
prefSize
;
}
bool
needCallback
=
false
;
if
(
shouldPosition
)
{
SetPopupPosition
(
false
)
;
needCallback
=
true
;
}
const
nsSize
preLayoutSize
=
GetSize
(
)
;
XULLayout
(
aState
)
;
bool
rePosition
=
shouldPosition
&
&
(
mPosition
=
=
POPUPPOSITION_SELECTION
)
;
const
nsSize
postLayoutSize
=
GetSize
(
)
;
if
(
postLayoutSize
.
width
>
preLayoutSize
.
width
|
|
postLayoutSize
.
height
>
preLayoutSize
.
height
)
{
mPrefSize
=
postLayoutSize
;
if
(
isOpen
)
{
rePosition
=
true
;
needCallback
=
true
;
}
}
if
(
rePosition
)
{
SetPopupPosition
(
false
)
;
}
nsPresContext
*
pc
=
PresContext
(
)
;
nsView
*
view
=
GetView
(
)
;
if
(
sizeChanged
)
{
nsIWidget
*
widget
=
view
-
>
GetWidget
(
)
;
if
(
widget
)
{
SetSizeConstraints
(
pc
widget
minSize
maxSize
)
;
}
}
if
(
isOpen
)
{
nsViewManager
*
viewManager
=
view
-
>
GetViewManager
(
)
;
nsRect
rect
=
GetRect
(
)
;
rect
.
x
=
rect
.
y
=
0
;
rect
.
SizeTo
(
XULBoundsCheck
(
minSize
rect
.
Size
(
)
maxSize
)
)
;
viewManager
-
>
ResizeView
(
view
rect
)
;
if
(
mPopupState
=
=
ePopupOpening
)
{
mPopupState
=
ePopupVisible
;
}
viewManager
-
>
SetViewVisibility
(
view
nsViewVisibility_kShow
)
;
SyncFrameViewProperties
(
view
)
;
}
bool
openChanged
=
mIsOpenChanged
;
if
(
openChanged
)
{
mIsOpenChanged
=
false
;
EnsureActiveMenuListItemIsVisible
(
)
;
if
(
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
IntID
:
:
PanelAnimations
)
&
&
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
animate
nsGkAtoms
:
:
open
eCaseMatters
)
&
&
AnimationUtils
:
:
HasCurrentTransitions
(
mContent
-
>
AsElement
(
)
PseudoStyleType
:
:
NotPseudo
)
)
{
mPopupShownDispatcher
=
new
nsXULPopupShownEvent
(
mContent
pc
)
;
mContent
-
>
AddSystemEventListener
(
u
"
transitionend
"
_ns
mPopupShownDispatcher
false
false
)
;
return
;
}
nsCOMPtr
<
nsIRunnable
>
event
=
new
nsXULPopupShownEvent
(
GetContent
(
)
pc
)
;
mContent
-
>
OwnerDoc
(
)
-
>
Dispatch
(
TaskCategory
:
:
Other
event
.
forget
(
)
)
;
}
if
(
needCallback
&
&
!
mReflowCallbackData
.
mPosted
)
{
pc
-
>
PresShell
(
)
-
>
PostReflowCallback
(
this
)
;
mReflowCallbackData
.
MarkPosted
(
openChanged
)
;
}
}
bool
nsMenuPopupFrame
:
:
ReflowFinished
(
)
{
SetPopupPosition
(
false
)
;
mReflowCallbackData
.
Clear
(
)
;
return
false
;
}
void
nsMenuPopupFrame
:
:
ReflowCallbackCanceled
(
)
{
mReflowCallbackData
.
Clear
(
)
;
}
bool
nsMenuPopupFrame
:
:
IsMenuList
(
)
const
{
return
PopupElement
(
)
.
IsInMenuList
(
)
;
}
bool
nsMenuPopupFrame
:
:
ShouldExpandToInflowParentOrAnchor
(
)
const
{
return
IsMenuList
(
)
&
&
!
mContent
-
>
GetParent
(
)
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
sizetopopup
nsGkAtoms
:
:
none
eCaseMatters
)
;
}
nsIContent
*
nsMenuPopupFrame
:
:
GetTriggerContent
(
nsMenuPopupFrame
*
aMenuPopupFrame
)
{
while
(
aMenuPopupFrame
)
{
if
(
aMenuPopupFrame
-
>
mTriggerContent
)
{
return
aMenuPopupFrame
-
>
mTriggerContent
;
}
auto
*
button
=
XULButtonElement
:
:
FromNodeOrNull
(
aMenuPopupFrame
-
>
GetContent
(
)
-
>
GetParent
(
)
)
;
if
(
!
button
|
|
!
button
-
>
IsMenu
(
)
)
{
break
;
}
auto
*
popup
=
button
-
>
GetContainingPopupElement
(
)
;
if
(
!
popup
)
{
break
;
}
aMenuPopupFrame
=
do_QueryFrame
(
popup
-
>
GetPrimaryFrame
(
)
)
;
}
return
nullptr
;
}
void
nsMenuPopupFrame
:
:
InitPositionFromAnchorAlign
(
const
nsAString
&
aAnchor
const
nsAString
&
aAlign
)
{
mTriggerContent
=
nullptr
;
if
(
aAnchor
.
EqualsLiteral
(
"
topleft
"
)
)
mPopupAnchor
=
POPUPALIGNMENT_TOPLEFT
;
else
if
(
aAnchor
.
EqualsLiteral
(
"
topright
"
)
)
mPopupAnchor
=
POPUPALIGNMENT_TOPRIGHT
;
else
if
(
aAnchor
.
EqualsLiteral
(
"
bottomleft
"
)
)
mPopupAnchor
=
POPUPALIGNMENT_BOTTOMLEFT
;
else
if
(
aAnchor
.
EqualsLiteral
(
"
bottomright
"
)
)
mPopupAnchor
=
POPUPALIGNMENT_BOTTOMRIGHT
;
else
if
(
aAnchor
.
EqualsLiteral
(
"
leftcenter
"
)
)
mPopupAnchor
=
POPUPALIGNMENT_LEFTCENTER
;
else
if
(
aAnchor
.
EqualsLiteral
(
"
rightcenter
"
)
)
mPopupAnchor
=
POPUPALIGNMENT_RIGHTCENTER
;
else
if
(
aAnchor
.
EqualsLiteral
(
"
topcenter
"
)
)
mPopupAnchor
=
POPUPALIGNMENT_TOPCENTER
;
else
if
(
aAnchor
.
EqualsLiteral
(
"
bottomcenter
"
)
)
mPopupAnchor
=
POPUPALIGNMENT_BOTTOMCENTER
;
else
mPopupAnchor
=
POPUPALIGNMENT_NONE
;
if
(
aAlign
.
EqualsLiteral
(
"
topleft
"
)
)
mPopupAlignment
=
POPUPALIGNMENT_TOPLEFT
;
else
if
(
aAlign
.
EqualsLiteral
(
"
topright
"
)
)
mPopupAlignment
=
POPUPALIGNMENT_TOPRIGHT
;
else
if
(
aAlign
.
EqualsLiteral
(
"
bottomleft
"
)
)
mPopupAlignment
=
POPUPALIGNMENT_BOTTOMLEFT
;
else
if
(
aAlign
.
EqualsLiteral
(
"
bottomright
"
)
)
mPopupAlignment
=
POPUPALIGNMENT_BOTTOMRIGHT
;
else
mPopupAlignment
=
POPUPALIGNMENT_NONE
;
mPosition
=
POPUPPOSITION_UNKNOWN
;
}
void
nsMenuPopupFrame
:
:
InitializePopup
(
nsIContent
*
aAnchorContent
nsIContent
*
aTriggerContent
const
nsAString
&
aPosition
int32_t
aXPos
int32_t
aYPos
MenuPopupAnchorType
aAnchorType
bool
aAttributesOverride
)
{
auto
*
widget
=
GetWidget
(
)
;
bool
recreateWidget
=
widget
&
&
widget
-
>
NeedsRecreateToReshow
(
)
;
PrepareWidget
(
recreateWidget
)
;
mPopupState
=
ePopupShowing
;
mAnchorContent
=
aAnchorContent
;
mTriggerContent
=
aTriggerContent
;
mXPos
=
aXPos
;
mYPos
=
aYPos
;
mIsNativeMenu
=
false
;
mIsTopLevelContextMenu
=
false
;
mVFlip
=
false
;
mHFlip
=
false
;
mAlignmentOffset
=
0
;
mPositionedOffset
=
0
;
mPositionedByMoveToRect
=
false
;
mAnchorType
=
aAnchorType
;
if
(
aAnchorContent
|
|
aAnchorType
=
=
MenuPopupAnchorType_Rect
)
{
nsAutoString
anchor
align
position
flip
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
popupanchor
anchor
)
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
popupalign
align
)
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
position
position
)
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
flip
flip
)
;
if
(
aAttributesOverride
)
{
if
(
anchor
.
IsEmpty
(
)
&
&
align
.
IsEmpty
(
)
&
&
position
.
IsEmpty
(
)
)
position
.
Assign
(
aPosition
)
;
else
mXPos
=
mYPos
=
0
;
}
else
if
(
!
aPosition
.
IsEmpty
(
)
)
{
position
.
Assign
(
aPosition
)
;
}
if
(
flip
.
EqualsLiteral
(
"
none
"
)
)
{
mFlip
=
FlipType_None
;
}
else
if
(
flip
.
EqualsLiteral
(
"
both
"
)
)
{
mFlip
=
FlipType_Both
;
}
else
if
(
flip
.
EqualsLiteral
(
"
slide
"
)
)
{
mFlip
=
FlipType_Slide
;
}
position
.
CompressWhitespace
(
)
;
int32_t
spaceIdx
=
position
.
FindChar
(
'
'
)
;
if
(
spaceIdx
>
=
0
)
{
InitPositionFromAnchorAlign
(
Substring
(
position
0
spaceIdx
)
Substring
(
position
spaceIdx
+
1
)
)
;
}
else
if
(
position
.
EqualsLiteral
(
"
before_start
"
)
)
{
mPopupAnchor
=
POPUPALIGNMENT_TOPLEFT
;
mPopupAlignment
=
POPUPALIGNMENT_BOTTOMLEFT
;
mPosition
=
POPUPPOSITION_BEFORESTART
;
}
else
if
(
position
.
EqualsLiteral
(
"
before_end
"
)
)
{
mPopupAnchor
=
POPUPALIGNMENT_TOPRIGHT
;
mPopupAlignment
=
POPUPALIGNMENT_BOTTOMRIGHT
;
mPosition
=
POPUPPOSITION_BEFOREEND
;
}
else
if
(
position
.
EqualsLiteral
(
"
after_start
"
)
)
{
mPopupAnchor
=
POPUPALIGNMENT_BOTTOMLEFT
;
mPopupAlignment
=
POPUPALIGNMENT_TOPLEFT
;
mPosition
=
POPUPPOSITION_AFTERSTART
;
}
else
if
(
position
.
EqualsLiteral
(
"
after_end
"
)
)
{
mPopupAnchor
=
POPUPALIGNMENT_BOTTOMRIGHT
;
mPopupAlignment
=
POPUPALIGNMENT_TOPRIGHT
;
mPosition
=
POPUPPOSITION_AFTEREND
;
}
else
if
(
position
.
EqualsLiteral
(
"
start_before
"
)
)
{
mPopupAnchor
=
POPUPALIGNMENT_TOPLEFT
;
mPopupAlignment
=
POPUPALIGNMENT_TOPRIGHT
;
mPosition
=
POPUPPOSITION_STARTBEFORE
;
}
else
if
(
position
.
EqualsLiteral
(
"
start_after
"
)
)
{
mPopupAnchor
=
POPUPALIGNMENT_BOTTOMLEFT
;
mPopupAlignment
=
POPUPALIGNMENT_BOTTOMRIGHT
;
mPosition
=
POPUPPOSITION_STARTAFTER
;
}
else
if
(
position
.
EqualsLiteral
(
"
end_before
"
)
)
{
mPopupAnchor
=
POPUPALIGNMENT_TOPRIGHT
;
mPopupAlignment
=
POPUPALIGNMENT_TOPLEFT
;
mPosition
=
POPUPPOSITION_ENDBEFORE
;
}
else
if
(
position
.
EqualsLiteral
(
"
end_after
"
)
)
{
mPopupAnchor
=
POPUPALIGNMENT_BOTTOMRIGHT
;
mPopupAlignment
=
POPUPALIGNMENT_BOTTOMLEFT
;
mPosition
=
POPUPPOSITION_ENDAFTER
;
}
else
if
(
position
.
EqualsLiteral
(
"
overlap
"
)
)
{
mPopupAnchor
=
POPUPALIGNMENT_TOPLEFT
;
mPopupAlignment
=
POPUPALIGNMENT_TOPLEFT
;
mPosition
=
POPUPPOSITION_OVERLAP
;
}
else
if
(
position
.
EqualsLiteral
(
"
after_pointer
"
)
)
{
mPopupAnchor
=
POPUPALIGNMENT_TOPLEFT
;
mPopupAlignment
=
POPUPALIGNMENT_TOPLEFT
;
mPosition
=
POPUPPOSITION_AFTERPOINTER
;
mYPos
+
=
21
;
}
else
if
(
position
.
EqualsLiteral
(
"
selection
"
)
)
{
mPopupAnchor
=
POPUPALIGNMENT_BOTTOMLEFT
;
mPopupAlignment
=
POPUPALIGNMENT_TOPLEFT
;
mPosition
=
POPUPPOSITION_SELECTION
;
}
else
{
InitPositionFromAnchorAlign
(
anchor
align
)
;
}
}
mScreenRect
=
nsRect
(
-
AppUnitsPerCSSPixel
(
)
-
AppUnitsPerCSSPixel
(
)
0
0
)
;
if
(
aAttributesOverride
)
{
nsAutoString
left
top
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
left
left
)
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
top
top
)
;
nsresult
err
;
if
(
!
left
.
IsEmpty
(
)
)
{
int32_t
x
=
left
.
ToInteger
(
&
err
)
;
if
(
NS_SUCCEEDED
(
err
)
)
{
mScreenRect
.
x
=
CSSPixel
:
:
ToAppUnits
(
x
)
;
}
}
if
(
!
top
.
IsEmpty
(
)
)
{
int32_t
y
=
top
.
ToInteger
(
&
err
)
;
if
(
NS_SUCCEEDED
(
err
)
)
{
mScreenRect
.
y
=
CSSPixel
:
:
ToAppUnits
(
y
)
;
}
}
}
}
void
nsMenuPopupFrame
:
:
InitializePopupAtScreen
(
nsIContent
*
aTriggerContent
int32_t
aXPos
int32_t
aYPos
bool
aIsContextMenu
)
{
auto
*
widget
=
GetWidget
(
)
;
bool
recreateWidget
=
widget
&
&
widget
-
>
NeedsRecreateToReshow
(
)
;
PrepareWidget
(
recreateWidget
)
;
mPopupState
=
ePopupShowing
;
mAnchorContent
=
nullptr
;
mTriggerContent
=
aTriggerContent
;
mScreenRect
=
nsRect
(
CSSPixel
:
:
ToAppUnits
(
aXPos
)
CSSPixel
:
:
ToAppUnits
(
aYPos
)
0
0
)
;
mXPos
=
0
;
mYPos
=
0
;
mFlip
=
FlipType_Default
;
mPopupAnchor
=
POPUPALIGNMENT_NONE
;
mPopupAlignment
=
POPUPALIGNMENT_NONE
;
mPosition
=
POPUPPOSITION_UNKNOWN
;
mIsContextMenu
=
aIsContextMenu
;
mIsTopLevelContextMenu
=
aIsContextMenu
;
mIsNativeMenu
=
false
;
mAnchorType
=
MenuPopupAnchorType_Point
;
mPositionedOffset
=
0
;
mPositionedByMoveToRect
=
false
;
}
void
nsMenuPopupFrame
:
:
InitializePopupAsNativeContextMenu
(
nsIContent
*
aTriggerContent
int32_t
aXPos
int32_t
aYPos
)
{
mTriggerContent
=
aTriggerContent
;
mPopupState
=
ePopupShowing
;
mAnchorContent
=
nullptr
;
mScreenRect
=
nsRect
(
CSSPixel
:
:
ToAppUnits
(
aXPos
)
CSSPixel
:
:
ToAppUnits
(
aYPos
)
0
0
)
;
mXPos
=
0
;
mYPos
=
0
;
mFlip
=
FlipType_Default
;
mPopupAnchor
=
POPUPALIGNMENT_NONE
;
mPopupAlignment
=
POPUPALIGNMENT_NONE
;
mPosition
=
POPUPPOSITION_UNKNOWN
;
mIsContextMenu
=
true
;
mIsTopLevelContextMenu
=
true
;
mIsNativeMenu
=
true
;
mAnchorType
=
MenuPopupAnchorType_Point
;
mPositionedOffset
=
0
;
mPositionedByMoveToRect
=
false
;
}
void
nsMenuPopupFrame
:
:
InitializePopupAtRect
(
nsIContent
*
aTriggerContent
const
nsAString
&
aPosition
const
nsIntRect
&
aRect
bool
aAttributesOverride
)
{
InitializePopup
(
nullptr
aTriggerContent
aPosition
0
0
MenuPopupAnchorType_Rect
aAttributesOverride
)
;
mScreenRect
=
ToAppUnits
(
aRect
AppUnitsPerCSSPixel
(
)
)
;
}
void
nsMenuPopupFrame
:
:
ShowPopup
(
bool
aIsContextMenu
)
{
mIsContextMenu
=
aIsContextMenu
;
InvalidateFrameSubtree
(
)
;
if
(
mPopupState
=
=
ePopupShowing
|
|
mPopupState
=
=
ePopupPositioning
)
{
mPopupState
=
ePopupOpening
;
mIsOpenChanged
=
true
;
if
(
mPopupType
=
=
ePopupTypeMenu
)
{
EventStateManager
*
activeESM
=
static_cast
<
EventStateManager
*
>
(
EventStateManager
:
:
GetActiveEventStateManager
(
)
)
;
if
(
activeESM
)
{
EventStateManager
:
:
ClearGlobalActiveContent
(
activeESM
)
;
}
PresShell
:
:
ReleaseCapturingContent
(
)
;
}
if
(
RefPtr
menu
=
PopupElement
(
)
.
GetContainingMenu
(
)
)
{
menu
-
>
PopupOpened
(
)
;
}
PresShell
(
)
-
>
FrameNeedsReflow
(
this
IntrinsicDirty
:
:
FrameAndAncestors
NS_FRAME_IS_DIRTY
)
;
if
(
mPopupType
=
=
ePopupTypeMenu
)
{
nsCOMPtr
<
nsISound
>
sound
(
do_GetService
(
"
mozilla
.
org
/
sound
;
1
"
)
)
;
if
(
sound
)
sound
-
>
PlayEventSound
(
nsISound
:
:
EVENT_MENU_POPUP
)
;
}
}
}
void
nsMenuPopupFrame
:
:
ClearTriggerContentIncludingDocument
(
)
{
if
(
mTriggerContent
)
{
Document
*
doc
=
mContent
-
>
GetUncomposedDoc
(
)
;
if
(
doc
)
{
if
(
nsPIDOMWindowOuter
*
win
=
doc
-
>
GetWindow
(
)
)
{
nsCOMPtr
<
nsPIWindowRoot
>
root
=
win
-
>
GetTopWindowRoot
(
)
;
if
(
root
)
{
root
-
>
SetPopupNode
(
nullptr
)
;
}
}
}
}
mTriggerContent
=
nullptr
;
}
void
nsMenuPopupFrame
:
:
HidePopup
(
bool
aDeselectMenu
nsPopupState
aNewState
bool
aFromFrameDestruction
)
{
NS_ASSERTION
(
aNewState
=
=
ePopupClosed
|
|
aNewState
=
=
ePopupInvisible
"
popup
being
set
to
unexpected
state
"
)
;
ClearPopupShownDispatcher
(
)
;
if
(
mPopupState
=
=
ePopupClosed
|
|
mPopupState
=
=
ePopupShowing
|
|
mPopupState
=
=
ePopupPositioning
)
{
return
;
}
if
(
aNewState
=
=
ePopupClosed
)
{
ClearTriggerContentIncludingDocument
(
)
;
mAnchorContent
=
nullptr
;
}
if
(
mPopupState
=
=
ePopupInvisible
)
{
if
(
aNewState
=
=
ePopupClosed
)
{
mPopupState
=
ePopupClosed
;
}
return
;
}
mPopupState
=
aNewState
;
mIncrementalString
.
Truncate
(
)
;
mIsOpenChanged
=
false
;
mHFlip
=
mVFlip
=
false
;
if
(
auto
*
widget
=
GetWidget
(
)
)
{
widget
-
>
ClearWebrenderAnimationResources
(
)
;
}
nsView
*
view
=
GetView
(
)
;
nsViewManager
*
viewManager
=
view
-
>
GetViewManager
(
)
;
viewManager
-
>
SetViewVisibility
(
view
nsViewVisibility_kHide
)
;
RefPtr
popup
=
&
PopupElement
(
)
;
if
(
!
aFromFrameDestruction
&
&
popup
-
>
State
(
)
.
HasState
(
dom
:
:
ElementState
:
:
HOVER
)
)
{
EventStateManager
*
esm
=
PresContext
(
)
-
>
EventStateManager
(
)
;
esm
-
>
SetContentState
(
nullptr
dom
:
:
ElementState
:
:
HOVER
)
;
}
popup
-
>
PopupClosed
(
aDeselectMenu
)
;
}
nsIFrame
:
:
ReflowChildFlags
nsMenuPopupFrame
:
:
GetXULLayoutFlags
(
)
{
return
ReflowChildFlags
:
:
NoSizeView
|
ReflowChildFlags
:
:
NoMoveView
;
}
nsPoint
nsMenuPopupFrame
:
:
AdjustPositionForAnchorAlign
(
nsRect
&
anchorRect
FlipStyle
&
aHFlip
FlipStyle
&
aVFlip
)
{
int8_t
popupAnchor
(
mPopupAnchor
)
;
int8_t
popupAlign
(
mPopupAlignment
)
;
if
(
IsDirectionRTL
(
)
)
{
if
(
popupAnchor
<
=
POPUPALIGNMENT_LEFTCENTER
)
{
popupAnchor
=
-
popupAnchor
;
}
popupAlign
=
-
popupAlign
;
}
nsRect
originalAnchorRect
(
anchorRect
)
;
nsPoint
pnt
;
switch
(
popupAnchor
)
{
case
POPUPALIGNMENT_LEFTCENTER
:
pnt
=
nsPoint
(
anchorRect
.
x
anchorRect
.
y
+
anchorRect
.
height
/
2
)
;
anchorRect
.
y
=
pnt
.
y
;
anchorRect
.
height
=
0
;
break
;
case
POPUPALIGNMENT_RIGHTCENTER
:
pnt
=
nsPoint
(
anchorRect
.
XMost
(
)
anchorRect
.
y
+
anchorRect
.
height
/
2
)
;
anchorRect
.
y
=
pnt
.
y
;
anchorRect
.
height
=
0
;
break
;
case
POPUPALIGNMENT_TOPCENTER
:
pnt
=
nsPoint
(
anchorRect
.
x
+
anchorRect
.
width
/
2
anchorRect
.
y
)
;
anchorRect
.
x
=
pnt
.
x
;
anchorRect
.
width
=
0
;
break
;
case
POPUPALIGNMENT_BOTTOMCENTER
:
pnt
=
nsPoint
(
anchorRect
.
x
+
anchorRect
.
width
/
2
anchorRect
.
YMost
(
)
)
;
anchorRect
.
x
=
pnt
.
x
;
anchorRect
.
width
=
0
;
break
;
case
POPUPALIGNMENT_TOPRIGHT
:
pnt
=
anchorRect
.
TopRight
(
)
;
break
;
case
POPUPALIGNMENT_BOTTOMLEFT
:
pnt
=
anchorRect
.
BottomLeft
(
)
;
break
;
case
POPUPALIGNMENT_BOTTOMRIGHT
:
pnt
=
anchorRect
.
BottomRight
(
)
;
break
;
case
POPUPALIGNMENT_TOPLEFT
:
default
:
pnt
=
anchorRect
.
TopLeft
(
)
;
break
;
}
nsMargin
margin
=
GetMargin
(
)
;
switch
(
popupAlign
)
{
case
POPUPALIGNMENT_TOPRIGHT
:
pnt
.
MoveBy
(
-
mRect
.
width
-
margin
.
right
margin
.
top
)
;
break
;
case
POPUPALIGNMENT_BOTTOMLEFT
:
pnt
.
MoveBy
(
margin
.
left
-
mRect
.
height
-
margin
.
bottom
)
;
break
;
case
POPUPALIGNMENT_BOTTOMRIGHT
:
pnt
.
MoveBy
(
-
mRect
.
width
-
margin
.
right
-
mRect
.
height
-
margin
.
bottom
)
;
break
;
case
POPUPALIGNMENT_TOPLEFT
:
default
:
pnt
.
MoveBy
(
margin
.
left
margin
.
top
)
;
break
;
}
if
(
mPosition
=
=
POPUPPOSITION_SELECTION
)
{
MOZ_ASSERT
(
popupAnchor
=
=
POPUPALIGNMENT_BOTTOMLEFT
|
|
popupAnchor
=
=
POPUPALIGNMENT_BOTTOMRIGHT
)
;
MOZ_ASSERT
(
popupAlign
=
=
POPUPALIGNMENT_TOPLEFT
|
|
popupAlign
=
=
POPUPALIGNMENT_TOPRIGHT
)
;
if
(
mIsOpenChanged
|
|
mReflowCallbackData
.
mIsOpenChanged
)
{
if
(
nsIFrame
*
selectedItemFrame
=
GetSelectedItemForAlignment
(
)
)
{
mPositionedOffset
=
originalAnchorRect
.
height
+
selectedItemFrame
-
>
GetOffsetTo
(
this
)
.
y
;
}
}
pnt
.
y
-
=
mPositionedOffset
;
}
switch
(
popupAnchor
)
{
case
POPUPALIGNMENT_LEFTCENTER
:
case
POPUPALIGNMENT_RIGHTCENTER
:
aHFlip
=
FlipStyle_Outside
;
aVFlip
=
FlipStyle_Inside
;
break
;
case
POPUPALIGNMENT_TOPCENTER
:
case
POPUPALIGNMENT_BOTTOMCENTER
:
aHFlip
=
FlipStyle_Inside
;
aVFlip
=
FlipStyle_Outside
;
break
;
default
:
{
FlipStyle
anchorEdge
=
mFlip
=
=
FlipType_Both
?
FlipStyle_Inside
:
FlipStyle_None
;
aHFlip
=
(
popupAnchor
=
=
-
popupAlign
)
?
FlipStyle_Outside
:
anchorEdge
;
if
(
(
(
popupAnchor
>
0
)
=
=
(
popupAlign
>
0
)
)
|
|
(
popupAnchor
=
=
POPUPALIGNMENT_TOPLEFT
&
&
popupAlign
=
=
POPUPALIGNMENT_TOPLEFT
)
)
aVFlip
=
FlipStyle_Outside
;
else
aVFlip
=
anchorEdge
;
break
;
}
}
return
pnt
;
}
nsIFrame
*
nsMenuPopupFrame
:
:
GetSelectedItemForAlignment
(
)
{
nsCOMPtr
<
nsIDOMXULSelectControlElement
>
select
;
if
(
mAnchorContent
)
{
select
=
mAnchorContent
-
>
AsElement
(
)
-
>
AsXULSelectControl
(
)
;
}
if
(
!
select
)
{
select
=
mContent
-
>
GetParent
(
)
-
>
AsElement
(
)
-
>
AsXULSelectControl
(
)
;
if
(
!
select
)
{
return
nullptr
;
}
}
nsCOMPtr
<
Element
>
selectedElement
;
select
-
>
GetSelectedItem
(
getter_AddRefs
(
selectedElement
)
)
;
return
selectedElement
?
selectedElement
-
>
GetPrimaryFrame
(
)
:
nullptr
;
}
nscoord
nsMenuPopupFrame
:
:
SlideOrResize
(
nscoord
&
aScreenPoint
nscoord
aSize
nscoord
aScreenBegin
nscoord
aScreenEnd
nscoord
*
aOffset
)
{
nscoord
newPos
=
std
:
:
max
(
aScreenBegin
std
:
:
min
(
aScreenEnd
-
aSize
aScreenPoint
)
)
;
*
aOffset
=
newPos
-
aScreenPoint
;
aScreenPoint
=
newPos
;
return
std
:
:
min
(
aSize
aScreenEnd
-
aScreenPoint
)
;
}
nscoord
nsMenuPopupFrame
:
:
FlipOrResize
(
nscoord
&
aScreenPoint
nscoord
aSize
nscoord
aScreenBegin
nscoord
aScreenEnd
nscoord
aAnchorBegin
nscoord
aAnchorEnd
nscoord
aMarginBegin
nscoord
aMarginEnd
FlipStyle
aFlip
bool
aEndAligned
bool
*
aFlipSide
)
{
*
aFlipSide
=
false
;
nscoord
popupSize
=
aSize
;
if
(
aScreenPoint
<
aScreenBegin
)
{
if
(
aFlip
)
{
nscoord
startpos
=
aFlip
=
=
FlipStyle_Outside
?
aAnchorBegin
:
aAnchorEnd
;
nscoord
endpos
=
aFlip
=
=
FlipStyle_Outside
?
aAnchorEnd
:
aAnchorBegin
;
if
(
startpos
-
aScreenBegin
>
=
aScreenEnd
-
endpos
)
{
aScreenPoint
=
aScreenBegin
;
popupSize
=
startpos
-
aScreenPoint
-
aMarginEnd
;
*
aFlipSide
=
!
aEndAligned
;
}
else
{
nscoord
newScreenPoint
=
endpos
+
aMarginEnd
;
if
(
newScreenPoint
!
=
aScreenPoint
)
{
*
aFlipSide
=
aEndAligned
;
aScreenPoint
=
newScreenPoint
;
if
(
aScreenPoint
+
aSize
>
aScreenEnd
)
{
popupSize
=
aScreenEnd
-
aScreenPoint
;
}
}
}
}
else
{
aScreenPoint
=
aScreenBegin
;
}
}
else
if
(
aScreenPoint
+
aSize
>
aScreenEnd
)
{
if
(
aFlip
)
{
nscoord
startpos
=
aFlip
=
=
FlipStyle_Outside
?
aAnchorBegin
:
aAnchorEnd
;
nscoord
endpos
=
aFlip
=
=
FlipStyle_Outside
?
aAnchorEnd
:
aAnchorBegin
;
if
(
aScreenEnd
-
endpos
>
=
startpos
-
aScreenBegin
)
{
*
aFlipSide
=
aEndAligned
;
if
(
mIsContextMenu
)
{
aScreenPoint
=
aScreenEnd
-
aSize
;
}
else
{
aScreenPoint
=
endpos
+
aMarginBegin
;
popupSize
=
aScreenEnd
-
aScreenPoint
;
}
}
else
{
nscoord
newScreenPoint
=
startpos
-
aSize
-
aMarginBegin
;
if
(
newScreenPoint
!
=
aScreenPoint
)
{
*
aFlipSide
=
!
aEndAligned
;
aScreenPoint
=
newScreenPoint
;
if
(
aScreenPoint
<
aScreenBegin
)
{
aScreenPoint
=
aScreenBegin
;
if
(
!
mIsContextMenu
)
{
popupSize
=
startpos
-
aScreenPoint
-
aMarginBegin
;
}
}
}
}
}
else
{
aScreenPoint
=
aScreenEnd
-
aSize
;
}
}
if
(
aScreenPoint
<
aScreenBegin
)
{
aScreenPoint
=
aScreenBegin
;
}
if
(
aScreenPoint
>
aScreenEnd
)
{
aScreenPoint
=
aScreenEnd
-
aSize
;
}
if
(
popupSize
<
=
0
|
|
aSize
<
popupSize
)
{
popupSize
=
aSize
;
}
return
std
:
:
min
(
popupSize
aScreenEnd
-
aScreenPoint
)
;
}
nsRect
nsMenuPopupFrame
:
:
ComputeAnchorRect
(
nsPresContext
*
aRootPresContext
nsIFrame
*
aAnchorFrame
)
{
nsIFrame
*
rootFrame
=
aRootPresContext
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
;
nsRect
anchorRect
=
aAnchorFrame
-
>
GetRectRelativeToSelf
(
)
;
anchorRect
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
aAnchorFrame
anchorRect
rootFrame
)
;
anchorRect
.
MoveBy
(
rootFrame
-
>
GetScreenRectInAppUnits
(
)
.
TopLeft
(
)
)
;
return
anchorRect
.
ScaleToOtherAppUnitsRoundOut
(
aRootPresContext
-
>
AppUnitsPerDevPixel
(
)
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
}
static
nsIFrame
*
MaybeDelegatedAnchorFrame
(
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
)
{
return
nullptr
;
}
if
(
auto
*
element
=
Element
:
:
FromNodeOrNull
(
aFrame
-
>
GetContent
(
)
)
)
{
if
(
element
-
>
HasAttr
(
nsGkAtoms
:
:
delegatesanchor
)
)
{
for
(
nsIFrame
*
f
:
aFrame
-
>
PrincipalChildList
(
)
)
{
if
(
!
f
-
>
IsPlaceholderFrame
(
)
)
{
return
f
;
}
}
}
}
return
aFrame
;
}
nsresult
nsMenuPopupFrame
:
:
SetPopupPosition
(
bool
aIsMove
)
{
if
(
aIsMove
&
&
(
mPrefSize
.
width
=
=
-
1
|
|
mPrefSize
.
height
=
=
-
1
)
)
{
return
NS_OK
;
}
nsPresContext
*
presContext
=
PresContext
(
)
;
nsIFrame
*
rootFrame
=
presContext
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
;
NS_ASSERTION
(
rootFrame
-
>
GetView
(
)
&
&
GetView
(
)
&
&
rootFrame
-
>
GetView
(
)
=
=
GetView
(
)
-
>
GetParent
(
)
"
rootFrame
'
s
view
is
not
our
view
'
s
parent
?
?
?
"
)
;
nsRect
anchorRect
;
bool
anchored
=
IsAnchored
(
)
;
if
(
anchored
)
{
nsPresContext
*
rootPresContext
=
presContext
-
>
GetRootPresContext
(
)
;
if
(
!
rootPresContext
)
{
return
NS_OK
;
}
if
(
mAnchorType
=
=
MenuPopupAnchorType_Rect
)
{
anchorRect
=
mScreenRect
;
}
else
{
nsIFrame
*
anchorFrame
=
GetAnchorFrame
(
)
;
if
(
!
anchorFrame
)
{
anchorFrame
=
rootFrame
;
if
(
!
anchorFrame
)
{
return
NS_OK
;
}
}
anchorRect
=
ComputeAnchorRect
(
rootPresContext
anchorFrame
)
;
}
}
{
NS_ASSERTION
(
mPrefSize
.
width
>
=
0
|
|
mPrefSize
.
height
>
=
0
"
preferred
size
of
popup
not
set
"
)
;
mRect
.
SizeTo
(
mPrefSize
)
;
}
nsPoint
screenPoint
;
FlipStyle
hFlip
=
FlipStyle_None
vFlip
=
FlipStyle_None
;
const
nsMargin
margin
=
GetMargin
(
)
;
nsRect
rootScreenRect
=
rootFrame
-
>
GetScreenRectInAppUnits
(
)
;
bool
isNoAutoHide
=
IsNoAutoHide
(
)
;
nsPopupLevel
popupLevel
=
PopupLevel
(
isNoAutoHide
)
;
if
(
anchored
)
{
if
(
mAnchorContent
|
|
mAnchorType
=
=
MenuPopupAnchorType_Rect
)
{
if
(
!
mPositionedByMoveToRect
)
{
mUntransformedAnchorRect
=
anchorRect
;
}
screenPoint
=
AdjustPositionForAnchorAlign
(
anchorRect
hFlip
vFlip
)
;
}
else
{
anchorRect
=
rootScreenRect
;
if
(
!
mPositionedByMoveToRect
)
{
mUntransformedAnchorRect
=
anchorRect
;
}
screenPoint
=
anchorRect
.
TopLeft
(
)
+
nsPoint
(
margin
.
left
margin
.
top
)
;
}
nscoord
anchorXOffset
=
CSSPixel
:
:
ToAppUnits
(
mXPos
)
;
if
(
IsDirectionRTL
(
)
)
{
screenPoint
.
x
-
=
anchorXOffset
;
anchorRect
.
x
-
=
anchorXOffset
;
}
else
{
screenPoint
.
x
+
=
anchorXOffset
;
anchorRect
.
x
+
=
anchorXOffset
;
}
nscoord
anchorYOffset
=
CSSPixel
:
:
ToAppUnits
(
mYPos
)
;
screenPoint
.
y
+
=
anchorYOffset
;
anchorRect
.
y
+
=
anchorYOffset
;
if
(
isNoAutoHide
&
&
(
popupLevel
!
=
ePopupLevelParent
|
|
mAnchorType
=
=
MenuPopupAnchorType_Rect
)
)
{
mAnchorType
=
MenuPopupAnchorType_Point
;
mScreenRect
.
x
=
screenPoint
.
x
-
margin
.
left
;
mScreenRect
.
y
=
screenPoint
.
y
-
margin
.
top
;
}
}
else
{
screenPoint
=
mScreenRect
.
TopLeft
(
)
;
anchorRect
=
nsRect
(
screenPoint
nsSize
(
)
)
;
if
(
!
mPositionedByMoveToRect
)
{
mUntransformedAnchorRect
=
anchorRect
;
}
if
(
mIsContextMenu
&
&
IsDirectionRTL
(
)
)
{
screenPoint
.
x
-
=
mRect
.
Width
(
)
;
screenPoint
.
MoveBy
(
-
margin
.
right
margin
.
top
)
;
}
else
{
screenPoint
.
MoveBy
(
margin
.
left
margin
.
top
)
;
}
#
ifdef
XP_MACOSX
if
(
mPopupType
=
=
ePopupTypeTooltip
)
{
vFlip
=
FlipStyle_Outside
;
}
else
{
hFlip
=
FlipStyle_Outside
;
}
#
else
vFlip
=
FlipStyle_Outside
;
#
endif
}
nscoord
oldAlignmentOffset
=
mAlignmentOffset
;
if
(
!
IS_WAYLAND_DISPLAY
(
)
&
&
(
mInContentShell
|
|
(
mFlip
!
=
FlipType_None
&
&
(
!
aIsMove
|
|
mIsOffset
|
|
mPopupType
!
=
ePopupTypePanel
)
)
)
)
{
const
nsRect
screenRect
=
[
&
]
{
int32_t
appPerDev
=
presContext
-
>
AppUnitsPerDevPixel
(
)
;
auto
anchorRectDevPix
=
LayoutDeviceIntRect
:
:
FromAppUnitsToNearest
(
anchorRect
appPerDev
)
;
auto
rootScreenRectDevPix
=
LayoutDeviceIntRect
:
:
FromAppUnitsToNearest
(
rootScreenRect
appPerDev
)
;
auto
screenRectDevPix
=
GetConstraintRect
(
anchorRectDevPix
rootScreenRectDevPix
popupLevel
)
;
nsRect
sr
=
LayoutDeviceIntRect
:
:
ToAppUnits
(
screenRectDevPix
appPerDev
)
;
const
nscoord
inputMargin
=
StyleUIReset
(
)
-
>
mMozWindowInputRegionMargin
.
ToAppUnits
(
)
;
sr
.
Inflate
(
inputMargin
)
;
return
sr
;
}
(
)
;
anchorRect
=
anchorRect
.
Intersect
(
screenRect
)
;
if
(
mRect
.
width
>
screenRect
.
width
)
{
mRect
.
width
=
screenRect
.
width
;
}
if
(
mRect
.
height
>
screenRect
.
height
)
{
mRect
.
height
=
screenRect
.
height
;
}
bool
slideHorizontal
=
false
slideVertical
=
false
;
if
(
mFlip
=
=
FlipType_Slide
)
{
int8_t
position
=
GetAlignmentPosition
(
)
;
slideHorizontal
=
position
>
=
POPUPPOSITION_BEFORESTART
&
&
position
<
=
POPUPPOSITION_AFTEREND
;
slideVertical
=
position
>
=
POPUPPOSITION_STARTBEFORE
&
&
position
<
=
POPUPPOSITION_ENDAFTER
;
}
const
nsPoint
preOffsetScreenPoint
=
screenPoint
;
if
(
slideHorizontal
)
{
mRect
.
width
=
SlideOrResize
(
screenPoint
.
x
mRect
.
width
screenRect
.
x
screenRect
.
XMost
(
)
&
mAlignmentOffset
)
;
}
else
{
bool
endAligned
=
IsDirectionRTL
(
)
?
mPopupAlignment
=
=
POPUPALIGNMENT_TOPLEFT
|
|
mPopupAlignment
=
=
POPUPALIGNMENT_BOTTOMLEFT
:
mPopupAlignment
=
=
POPUPALIGNMENT_TOPRIGHT
|
|
mPopupAlignment
=
=
POPUPALIGNMENT_BOTTOMRIGHT
;
mRect
.
width
=
FlipOrResize
(
screenPoint
.
x
mRect
.
width
screenRect
.
x
screenRect
.
XMost
(
)
anchorRect
.
x
anchorRect
.
XMost
(
)
margin
.
left
margin
.
right
hFlip
endAligned
&
mHFlip
)
;
}
if
(
slideVertical
)
{
mRect
.
height
=
SlideOrResize
(
screenPoint
.
y
mRect
.
height
screenRect
.
y
screenRect
.
YMost
(
)
&
mAlignmentOffset
)
;
}
else
{
bool
endAligned
=
mPopupAlignment
=
=
POPUPALIGNMENT_BOTTOMLEFT
|
|
mPopupAlignment
=
=
POPUPALIGNMENT_BOTTOMRIGHT
;
mRect
.
height
=
FlipOrResize
(
screenPoint
.
y
mRect
.
height
screenRect
.
y
screenRect
.
YMost
(
)
anchorRect
.
y
anchorRect
.
YMost
(
)
margin
.
top
margin
.
bottom
vFlip
endAligned
&
mVFlip
)
;
}
mIsOffset
=
preOffsetScreenPoint
!
=
screenPoint
;
NS_ASSERTION
(
screenPoint
.
x
>
=
screenRect
.
x
"
Popup
is
offscreen
(
x
start
)
"
)
;
NS_ASSERTION
(
screenPoint
.
y
>
=
screenRect
.
y
"
Popup
is
offscreen
(
y
start
)
"
)
;
NS_ASSERTION
(
screenPoint
.
x
+
mRect
.
width
<
=
screenRect
.
XMost
(
)
"
Popup
is
offscreen
(
x
end
)
"
)
;
NS_ASSERTION
(
screenPoint
.
y
+
mRect
.
height
<
=
screenRect
.
YMost
(
)
"
Popup
is
offscreen
(
y
end
)
"
)
;
}
screenPoint
.
x
=
presContext
-
>
RoundAppUnitsToNearestDevPixels
(
screenPoint
.
x
)
;
screenPoint
.
y
=
presContext
-
>
RoundAppUnitsToNearestDevPixels
(
screenPoint
.
y
)
;
nsPoint
viewPoint
=
screenPoint
-
rootScreenRect
.
TopLeft
(
)
;
nsView
*
view
=
GetView
(
)
;
NS_ASSERTION
(
view
"
popup
with
no
view
"
)
;
nsIWidget
*
widget
=
view
-
>
GetWidget
(
)
;
if
(
mPopupType
=
=
ePopupTypePanel
&
&
widget
)
{
mLastClientOffset
=
widget
-
>
GetClientOffset
(
)
;
viewPoint
.
x
+
=
presContext
-
>
DevPixelsToAppUnits
(
mLastClientOffset
.
x
)
;
viewPoint
.
y
+
=
presContext
-
>
DevPixelsToAppUnits
(
mLastClientOffset
.
y
)
;
}
presContext
-
>
GetPresShell
(
)
-
>
GetViewManager
(
)
-
>
MoveViewTo
(
view
viewPoint
.
x
viewPoint
.
y
)
;
nsBoxFrame
:
:
SetPosition
(
viewPoint
-
GetParent
(
)
-
>
GetOffsetTo
(
rootFrame
)
)
;
nsIntRect
newRect
(
screenPoint
.
x
screenPoint
.
y
mRect
.
width
mRect
.
height
)
;
if
(
mPopupState
=
=
ePopupPositioning
|
|
(
mPopupState
=
=
ePopupShown
&
&
!
newRect
.
IsEqualEdges
(
mUsedScreenRect
)
)
|
|
(
mPopupState
=
=
ePopupShown
&
&
oldAlignmentOffset
!
=
mAlignmentOffset
)
)
{
mUsedScreenRect
=
newRect
;
if
(
!
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
&
&
!
mPendingPositionedEvent
)
{
mPendingPositionedEvent
=
nsXULPopupPositionedEvent
:
:
DispatchIfNeeded
(
mContent
)
;
}
}
WidgetPositionOrSizeDidChange
(
)
;
return
NS_OK
;
}
void
nsMenuPopupFrame
:
:
WidgetPositionOrSizeDidChange
(
)
{
if
(
!
HasRemoteContent
(
)
)
{
return
;
}
for
(
nsIContent
*
content
=
mContent
-
>
GetFirstChild
(
)
;
content
;
content
=
content
-
>
GetNextNode
(
mContent
)
)
{
if
(
content
-
>
IsXULElement
(
nsGkAtoms
:
:
browser
)
&
&
content
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
remote
nsGkAtoms
:
:
_true
eIgnoreCase
)
)
{
if
(
auto
*
browserParent
=
dom
:
:
BrowserParent
:
:
GetFrom
(
content
)
)
{
browserParent
-
>
NotifyPositionUpdatedForContentsInPopup
(
)
;
}
}
}
}
LayoutDeviceIntRect
nsMenuPopupFrame
:
:
GetConstraintRect
(
const
LayoutDeviceIntRect
&
aAnchorRect
const
LayoutDeviceIntRect
&
aRootScreenRect
nsPopupLevel
aPopupLevel
)
{
LayoutDeviceIntRect
screenRectPixels
;
MOZ_ASSERT
(
!
IS_WAYLAND_DISPLAY
(
)
"
GetConstraintRect
does
not
work
on
Wayland
"
)
;
nsCOMPtr
<
nsIScreen
>
screen
;
nsCOMPtr
<
nsIScreenManager
>
sm
(
do_GetService
(
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
)
)
;
if
(
sm
)
{
DesktopToLayoutDeviceScale
scale
=
PresContext
(
)
-
>
DeviceContext
(
)
-
>
GetDesktopToDeviceScale
(
)
;
DesktopRect
rect
=
(
mInContentShell
?
aRootScreenRect
:
aAnchorRect
)
/
scale
;
int32_t
width
=
std
:
:
max
(
1
NSToIntRound
(
rect
.
width
)
)
;
int32_t
height
=
std
:
:
max
(
1
NSToIntRound
(
rect
.
height
)
)
;
sm
-
>
ScreenForRect
(
rect
.
x
rect
.
y
width
height
getter_AddRefs
(
screen
)
)
;
if
(
screen
)
{
bool
dontOverlapOSBar
=
aPopupLevel
!
=
ePopupLevelTop
;
if
(
!
dontOverlapOSBar
&
&
mMenuCanOverlapOSBar
&
&
!
mInContentShell
)
screen
-
>
GetRect
(
&
screenRectPixels
.
x
&
screenRectPixels
.
y
&
screenRectPixels
.
width
&
screenRectPixels
.
height
)
;
else
screen
-
>
GetAvailRect
(
&
screenRectPixels
.
x
&
screenRectPixels
.
y
&
screenRectPixels
.
width
&
screenRectPixels
.
height
)
;
}
}
if
(
mInContentShell
)
{
screenRectPixels
.
IntersectRect
(
screenRectPixels
aRootScreenRect
)
;
}
else
if
(
!
mOverrideConstraintRect
.
IsEmpty
(
)
)
{
LayoutDeviceIntRect
overrideConstrainRect
=
LayoutDeviceIntRect
:
:
FromAppUnitsToNearest
(
mOverrideConstraintRect
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
screenRectPixels
.
IntersectRect
(
screenRectPixels
overrideConstrainRect
)
;
screenRectPixels
.
x
=
overrideConstrainRect
.
x
;
screenRectPixels
.
width
=
overrideConstrainRect
.
width
;
}
return
screenRectPixels
;
}
void
nsMenuPopupFrame
:
:
CanAdjustEdges
(
Side
aHorizontalSide
Side
aVerticalSide
LayoutDeviceIntPoint
&
aChange
)
{
int8_t
popupAlign
(
mPopupAlignment
)
;
if
(
IsDirectionRTL
(
)
)
{
popupAlign
=
-
popupAlign
;
}
if
(
aHorizontalSide
=
=
(
mHFlip
?
eSideRight
:
eSideLeft
)
)
{
if
(
popupAlign
=
=
POPUPALIGNMENT_TOPLEFT
|
|
popupAlign
=
=
POPUPALIGNMENT_BOTTOMLEFT
)
{
aChange
.
x
=
0
;
}
}
else
if
(
aHorizontalSide
=
=
(
mHFlip
?
eSideLeft
:
eSideRight
)
)
{
if
(
popupAlign
=
=
POPUPALIGNMENT_TOPRIGHT
|
|
popupAlign
=
=
POPUPALIGNMENT_BOTTOMRIGHT
)
{
aChange
.
x
=
0
;
}
}
if
(
aVerticalSide
=
=
(
mVFlip
?
eSideBottom
:
eSideTop
)
)
{
if
(
popupAlign
=
=
POPUPALIGNMENT_TOPLEFT
|
|
popupAlign
=
=
POPUPALIGNMENT_TOPRIGHT
)
{
aChange
.
y
=
0
;
}
}
else
if
(
aVerticalSide
=
=
(
mVFlip
?
eSideTop
:
eSideBottom
)
)
{
if
(
popupAlign
=
=
POPUPALIGNMENT_BOTTOMLEFT
|
|
popupAlign
=
=
POPUPALIGNMENT_BOTTOMRIGHT
)
{
aChange
.
y
=
0
;
}
}
}
ConsumeOutsideClicksResult
nsMenuPopupFrame
:
:
ConsumeOutsideClicks
(
)
{
if
(
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
consumeoutsideclicks
nsGkAtoms
:
:
_true
eCaseMatters
)
)
{
return
ConsumeOutsideClicks_True
;
}
if
(
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
consumeoutsideclicks
nsGkAtoms
:
:
_false
eCaseMatters
)
)
{
return
ConsumeOutsideClicks_ParentOnly
;
}
if
(
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
consumeoutsideclicks
nsGkAtoms
:
:
never
eCaseMatters
)
)
{
return
ConsumeOutsideClicks_Never
;
}
nsCOMPtr
<
nsIContent
>
parentContent
=
mContent
-
>
GetParent
(
)
;
if
(
parentContent
)
{
dom
:
:
NodeInfo
*
ni
=
parentContent
-
>
NodeInfo
(
)
;
if
(
ni
-
>
Equals
(
nsGkAtoms
:
:
menulist
kNameSpaceID_XUL
)
)
{
return
ConsumeOutsideClicks_True
;
}
#
if
defined
(
XP_WIN
)
if
(
ni
-
>
Equals
(
nsGkAtoms
:
:
menu
kNameSpaceID_XUL
)
|
|
ni
-
>
Equals
(
nsGkAtoms
:
:
popupset
kNameSpaceID_XUL
)
|
|
(
(
ni
-
>
Equals
(
nsGkAtoms
:
:
button
kNameSpaceID_XUL
)
|
|
ni
-
>
Equals
(
nsGkAtoms
:
:
toolbarbutton
kNameSpaceID_XUL
)
)
&
&
parentContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
type
nsGkAtoms
:
:
menu
eCaseMatters
)
)
)
{
return
ConsumeOutsideClicks_Never
;
}
#
endif
}
return
ConsumeOutsideClicks_True
;
}
nsIScrollableFrame
*
nsMenuPopupFrame
:
:
GetScrollFrame
(
nsIFrame
*
aStart
)
{
if
(
!
aStart
)
return
nullptr
;
nsIFrame
*
currFrame
=
aStart
;
do
{
nsIScrollableFrame
*
sf
=
do_QueryFrame
(
currFrame
)
;
if
(
sf
)
return
sf
;
currFrame
=
currFrame
-
>
GetNextSibling
(
)
;
}
while
(
currFrame
)
;
currFrame
=
aStart
;
do
{
nsIFrame
*
childFrame
=
currFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
nsIScrollableFrame
*
sf
=
GetScrollFrame
(
childFrame
)
;
if
(
sf
)
return
sf
;
currFrame
=
currFrame
-
>
GetNextSibling
(
)
;
}
while
(
currFrame
)
;
return
nullptr
;
}
void
nsMenuPopupFrame
:
:
ChangeByPage
(
bool
aIsUp
)
{
if
(
!
IsMenuList
(
)
)
{
return
;
}
nsIScrollableFrame
*
scrollframe
=
GetScrollFrame
(
this
)
;
RefPtr
popup
=
&
PopupElement
(
)
;
XULButtonElement
*
currentMenu
=
popup
-
>
GetActiveMenuChild
(
)
;
XULButtonElement
*
newMenu
=
nullptr
;
if
(
!
currentMenu
)
{
newMenu
=
popup
-
>
GetFirstMenuItem
(
)
;
if
(
!
aIsUp
)
{
currentMenu
=
newMenu
;
}
}
if
(
currentMenu
&
&
currentMenu
-
>
GetPrimaryFrame
(
)
)
{
const
nscoord
scrollHeight
=
scrollframe
?
scrollframe
-
>
GetScrollPortRect
(
)
.
height
:
mRect
.
height
;
const
nsRect
currentRect
=
currentMenu
-
>
GetPrimaryFrame
(
)
-
>
GetRect
(
)
;
const
XULButtonElement
*
startMenu
=
currentMenu
;
const
nscoord
targetPos
=
aIsUp
?
currentRect
.
YMost
(
)
-
scrollHeight
:
currentRect
.
y
+
scrollHeight
;
for
(
;
currentMenu
;
currentMenu
=
aIsUp
?
popup
-
>
GetPrevMenuItemFrom
(
*
currentMenu
)
:
popup
-
>
GetNextMenuItemFrom
(
*
currentMenu
)
)
{
if
(
!
currentMenu
-
>
GetPrimaryFrame
(
)
)
{
continue
;
}
const
nsRect
curRect
=
currentMenu
-
>
GetPrimaryFrame
(
)
-
>
GetRect
(
)
;
const
nscoord
curPos
=
aIsUp
?
curRect
.
y
:
curRect
.
YMost
(
)
;
if
(
aIsUp
?
(
curPos
<
targetPos
)
:
(
curPos
>
targetPos
)
)
{
if
(
!
newMenu
|
|
newMenu
=
=
startMenu
)
{
newMenu
=
currentMenu
;
}
break
;
}
newMenu
=
currentMenu
;
}
}
if
(
RefPtr
newMenuRef
=
newMenu
)
{
popup
-
>
SetActiveMenuChild
(
newMenuRef
)
;
}
}
dom
:
:
XULPopupElement
&
nsMenuPopupFrame
:
:
PopupElement
(
)
const
{
auto
*
popup
=
dom
:
:
XULPopupElement
:
:
FromNode
(
GetContent
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
popup
)
;
return
*
popup
;
}
XULButtonElement
*
nsMenuPopupFrame
:
:
GetCurrentMenuItem
(
)
const
{
return
PopupElement
(
)
.
GetActiveMenuChild
(
)
;
}
nsIFrame
*
nsMenuPopupFrame
:
:
GetCurrentMenuItemFrame
(
)
const
{
auto
*
child
=
GetCurrentMenuItem
(
)
;
return
child
?
child
-
>
GetPrimaryFrame
(
)
:
nullptr
;
}
void
nsMenuPopupFrame
:
:
HandleEnterKeyPress
(
WidgetEvent
&
aEvent
)
{
mIncrementalString
.
Truncate
(
)
;
if
(
RefPtr
menu
=
GetCurrentMenuItem
(
)
)
{
menu
-
>
HandleEnterKeyPress
(
aEvent
)
;
}
}
XULButtonElement
*
nsMenuPopupFrame
:
:
FindMenuWithShortcut
(
mozilla
:
:
dom
:
:
KeyboardEvent
&
aKeyEvent
bool
&
aDoAction
)
{
uint32_t
charCode
=
aKeyEvent
.
CharCode
(
)
;
uint32_t
keyCode
=
aKeyEvent
.
KeyCode
(
)
;
aDoAction
=
false
;
const
bool
isMenu
=
!
IsMenuList
(
)
;
TimeStamp
keyTime
=
aKeyEvent
.
WidgetEventPtr
(
)
-
>
mTimeStamp
;
if
(
charCode
=
=
0
)
{
if
(
keyCode
=
=
dom
:
:
KeyboardEvent_Binding
:
:
DOM_VK_BACK_SPACE
)
{
if
(
!
isMenu
&
&
!
mIncrementalString
.
IsEmpty
(
)
)
{
mIncrementalString
.
SetLength
(
mIncrementalString
.
Length
(
)
-
1
)
;
return
nullptr
;
}
#
ifdef
XP_WIN
if
(
nsCOMPtr
<
nsISound
>
sound
=
do_GetService
(
"
mozilla
.
org
/
sound
;
1
"
)
)
{
sound
-
>
Beep
(
)
;
}
#
endif
}
return
nullptr
;
}
char16_t
uniChar
=
ToLowerCase
(
static_cast
<
char16_t
>
(
charCode
)
)
;
if
(
isMenu
)
{
mIncrementalString
=
uniChar
;
}
else
if
(
IsWithinIncrementalTime
(
keyTime
)
)
{
mIncrementalString
.
Append
(
uniChar
)
;
}
else
{
mIncrementalString
=
uniChar
;
}
nsAutoString
incrementalString
(
mIncrementalString
)
;
uint32_t
charIndex
=
1
stringLength
=
incrementalString
.
Length
(
)
;
while
(
charIndex
<
stringLength
&
&
incrementalString
[
charIndex
]
=
=
incrementalString
[
charIndex
-
1
]
)
{
charIndex
+
+
;
}
if
(
charIndex
=
=
stringLength
)
{
incrementalString
.
Truncate
(
1
)
;
stringLength
=
1
;
}
sLastKeyTime
=
keyTime
;
auto
*
item
=
PopupElement
(
)
.
FindMenuWithShortcut
(
incrementalString
aDoAction
)
;
if
(
item
)
{
return
item
;
}
mIncrementalString
.
SetLength
(
mIncrementalString
.
Length
(
)
-
1
)
;
#
ifdef
XP_WIN
if
(
isMenu
)
{
if
(
nsCOMPtr
<
nsISound
>
sound
=
do_GetService
(
"
mozilla
.
org
/
sound
;
1
"
)
)
{
sound
-
>
Beep
(
)
;
}
}
#
endif
return
nullptr
;
}
nsIWidget
*
nsMenuPopupFrame
:
:
GetWidget
(
)
const
{
return
mView
?
mView
-
>
GetWidget
(
)
:
nullptr
;
}
nsresult
nsMenuPopupFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
nsresult
rv
=
nsBoxFrame
:
:
AttributeChanged
(
aNameSpaceID
aAttribute
aModType
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
left
|
|
aAttribute
=
=
nsGkAtoms
:
:
top
)
{
MoveToAttributePosition
(
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
remote
)
{
PrepareWidget
(
true
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
followanchor
)
{
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
pm
)
{
pm
-
>
UpdateFollowAnchor
(
this
)
;
}
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
label
)
{
nsView
*
view
=
GetView
(
)
;
if
(
view
)
{
nsIWidget
*
widget
=
view
-
>
GetWidget
(
)
;
if
(
widget
)
{
nsAutoString
title
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
label
title
)
;
if
(
!
title
.
IsEmpty
(
)
)
{
widget
-
>
SetTitle
(
title
)
;
}
}
}
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
ignorekeys
)
{
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
pm
)
{
nsAutoString
ignorekeys
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
ignorekeys
ignorekeys
)
;
pm
-
>
UpdateIgnoreKeys
(
ignorekeys
.
EqualsLiteral
(
"
true
"
)
)
;
}
}
return
rv
;
}
void
nsMenuPopupFrame
:
:
MoveToAttributePosition
(
)
{
nsAutoString
left
top
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
left
left
)
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
top
top
)
;
nsresult
err1
err2
;
mozilla
:
:
CSSIntPoint
pos
(
left
.
ToInteger
(
&
err1
)
top
.
ToInteger
(
&
err2
)
)
;
if
(
NS_SUCCEEDED
(
err1
)
&
&
NS_SUCCEEDED
(
err2
)
)
MoveTo
(
pos
false
)
;
PresShell
(
)
-
>
FrameNeedsReflow
(
this
IntrinsicDirty
:
:
FrameAncestorsAndDescendants
NS_FRAME_IS_DIRTY
)
;
}
void
nsMenuPopupFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
{
if
(
mReflowCallbackData
.
mPosted
)
{
PresShell
(
)
-
>
CancelReflowCallback
(
this
)
;
mReflowCallbackData
.
Clear
(
)
;
}
HidePopup
(
false
ePopupClosed
true
)
;
if
(
RefPtr
<
nsXULPopupManager
>
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
)
{
pm
-
>
PopupDestroyed
(
this
)
;
}
nsBoxFrame
:
:
DestroyFrom
(
aDestructRoot
aPostDestroyData
)
;
}
nsMargin
nsMenuPopupFrame
:
:
GetMargin
(
)
const
{
nsMargin
margin
;
StyleMargin
(
)
-
>
GetMargin
(
margin
)
;
if
(
mIsTopLevelContextMenu
)
{
const
CSSIntPoint
offset
(
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
IntID
:
:
ContextMenuOffsetHorizontal
)
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
IntID
:
:
ContextMenuOffsetVertical
)
)
;
auto
auOffset
=
CSSIntPoint
:
:
ToAppUnits
(
offset
)
;
margin
.
top
+
=
auOffset
.
y
;
margin
.
bottom
+
=
auOffset
.
y
;
margin
.
left
+
=
auOffset
.
x
;
margin
.
right
+
=
auOffset
.
x
;
}
return
margin
;
}
void
nsMenuPopupFrame
:
:
MoveTo
(
const
CSSPoint
&
aPos
bool
aUpdateAttrs
bool
aByMoveToRect
)
{
nsIWidget
*
widget
=
GetWidget
(
)
;
nsPoint
appUnitsPos
=
CSSPixel
:
:
ToAppUnits
(
aPos
)
;
{
nsMargin
margin
=
GetMargin
(
)
;
if
(
mIsContextMenu
&
&
IsDirectionRTL
(
)
)
{
appUnitsPos
.
x
+
=
margin
.
right
+
mRect
.
Width
(
)
;
}
else
{
appUnitsPos
.
x
-
=
margin
.
left
;
}
appUnitsPos
.
y
-
=
margin
.
top
;
}
if
(
(
mScreenRect
.
x
=
=
appUnitsPos
.
x
&
&
mScreenRect
.
y
=
=
appUnitsPos
.
y
)
&
&
(
!
widget
|
|
widget
-
>
GetClientOffset
(
)
=
=
mLastClientOffset
)
)
{
return
;
}
mPositionedByMoveToRect
=
aByMoveToRect
;
mScreenRect
.
MoveTo
(
appUnitsPos
)
;
if
(
mAnchorType
=
=
MenuPopupAnchorType_Rect
)
{
mScreenRect
.
height
=
0
;
}
else
{
mAnchorType
=
MenuPopupAnchorType_Point
;
}
SetPopupPosition
(
true
)
;
RefPtr
<
Element
>
popup
=
mContent
-
>
AsElement
(
)
;
if
(
aUpdateAttrs
&
&
(
popup
-
>
HasAttr
(
nsGkAtoms
:
:
left
)
|
|
popup
-
>
HasAttr
(
nsGkAtoms
:
:
top
)
)
)
{
nsAutoString
left
top
;
left
.
AppendInt
(
RoundedToInt
(
aPos
)
.
x
)
;
top
.
AppendInt
(
RoundedToInt
(
aPos
)
.
y
)
;
popup
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
left
left
false
)
;
popup
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
top
top
false
)
;
}
}
void
nsMenuPopupFrame
:
:
MoveToAnchor
(
nsIContent
*
aAnchorContent
const
nsAString
&
aPosition
int32_t
aXPos
int32_t
aYPos
bool
aAttributesOverride
)
{
NS_ASSERTION
(
IsVisible
(
)
"
popup
must
be
visible
to
move
it
"
)
;
nsPopupState
oldstate
=
mPopupState
;
InitializePopup
(
aAnchorContent
mTriggerContent
aPosition
aXPos
aYPos
MenuPopupAnchorType_Node
aAttributesOverride
)
;
mPopupState
=
oldstate
;
SetPopupPosition
(
false
)
;
}
int8_t
nsMenuPopupFrame
:
:
GetAlignmentPosition
(
)
const
{
if
(
mPosition
=
=
POPUPPOSITION_OVERLAP
|
|
mPosition
=
=
POPUPPOSITION_AFTERPOINTER
|
|
mPosition
=
=
POPUPPOSITION_SELECTION
)
{
return
mPosition
;
}
int8_t
position
=
mPosition
;
if
(
position
=
=
POPUPPOSITION_UNKNOWN
)
{
switch
(
mPopupAnchor
)
{
case
POPUPALIGNMENT_BOTTOMRIGHT
:
case
POPUPALIGNMENT_BOTTOMLEFT
:
case
POPUPALIGNMENT_BOTTOMCENTER
:
position
=
mPopupAlignment
=
=
POPUPALIGNMENT_TOPRIGHT
?
POPUPPOSITION_AFTEREND
:
POPUPPOSITION_AFTERSTART
;
break
;
case
POPUPALIGNMENT_TOPRIGHT
:
case
POPUPALIGNMENT_TOPLEFT
:
case
POPUPALIGNMENT_TOPCENTER
:
position
=
mPopupAlignment
=
=
POPUPALIGNMENT_BOTTOMRIGHT
?
POPUPPOSITION_BEFOREEND
:
POPUPPOSITION_BEFORESTART
;
break
;
case
POPUPALIGNMENT_LEFTCENTER
:
position
=
mPopupAlignment
=
=
POPUPALIGNMENT_BOTTOMRIGHT
?
POPUPPOSITION_STARTAFTER
:
POPUPPOSITION_STARTBEFORE
;
break
;
case
POPUPALIGNMENT_RIGHTCENTER
:
position
=
mPopupAlignment
=
=
POPUPALIGNMENT_BOTTOMLEFT
?
POPUPPOSITION_ENDAFTER
:
POPUPPOSITION_ENDBEFORE
;
break
;
default
:
break
;
}
}
if
(
mHFlip
)
{
position
=
POPUPPOSITION_HFLIP
(
position
)
;
}
if
(
mVFlip
)
{
position
=
POPUPPOSITION_VFLIP
(
position
)
;
}
return
position
;
}
void
nsMenuPopupFrame
:
:
CreatePopupView
(
)
{
if
(
HasView
(
)
)
{
return
;
}
nsViewManager
*
viewManager
=
PresContext
(
)
-
>
GetPresShell
(
)
-
>
GetViewManager
(
)
;
NS_ASSERTION
(
nullptr
!
=
viewManager
"
null
view
manager
"
)
;
nsView
*
parentView
=
viewManager
-
>
GetRootView
(
)
;
nsViewVisibility
visibility
=
nsViewVisibility_kHide
;
NS_ASSERTION
(
parentView
"
no
parent
view
"
)
;
nsView
*
view
=
viewManager
-
>
CreateView
(
GetRect
(
)
parentView
visibility
)
;
auto
zIndex
=
ZIndex
(
)
;
viewManager
-
>
SetViewZIndex
(
view
zIndex
.
isNothing
(
)
zIndex
.
valueOr
(
0
)
)
;
viewManager
-
>
InsertChild
(
parentView
view
nullptr
true
)
;
SetView
(
view
)
;
NS_FRAME_LOG
(
NS_FRAME_TRACE_CALLS
(
"
nsMenuPopupFrame
:
:
CreatePopupView
:
frame
=
%
p
view
=
%
p
"
this
view
)
)
;
}
bool
nsMenuPopupFrame
:
:
ShouldFollowAnchor
(
)
{
if
(
mAnchorType
!
=
MenuPopupAnchorType_Node
|
|
!
mAnchorContent
)
{
return
false
;
}
if
(
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
followanchor
nsGkAtoms
:
:
_true
eCaseMatters
)
)
{
return
true
;
}
if
(
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
followanchor
nsGkAtoms
:
:
_false
eCaseMatters
)
)
{
return
false
;
}
return
(
mPopupType
=
=
ePopupTypePanel
&
&
mContent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
type
nsGkAtoms
:
:
arrow
eCaseMatters
)
)
;
}
bool
nsMenuPopupFrame
:
:
ShouldFollowAnchor
(
nsRect
&
aRect
)
{
if
(
!
ShouldFollowAnchor
(
)
)
{
return
false
;
}
if
(
nsIFrame
*
anchorFrame
=
GetAnchorFrame
(
)
)
{
if
(
nsPresContext
*
rootPresContext
=
PresContext
(
)
-
>
GetRootPresContext
(
)
)
{
aRect
=
ComputeAnchorRect
(
rootPresContext
anchorFrame
)
;
}
}
return
true
;
}
bool
nsMenuPopupFrame
:
:
IsDirectionRTL
(
)
const
{
const
nsIFrame
*
anchor
=
GetAnchorFrame
(
)
;
const
nsIFrame
*
f
=
anchor
?
anchor
:
this
;
return
f
-
>
StyleVisibility
(
)
-
>
mDirection
=
=
StyleDirection
:
:
Rtl
;
}
nsIFrame
*
nsMenuPopupFrame
:
:
GetAnchorFrame
(
)
const
{
nsIContent
*
anchor
=
mAnchorContent
;
if
(
!
anchor
)
{
return
nullptr
;
}
return
MaybeDelegatedAnchorFrame
(
anchor
-
>
GetPrimaryFrame
(
)
)
;
}
void
nsMenuPopupFrame
:
:
CheckForAnchorChange
(
nsRect
&
aRect
)
{
if
(
!
IsVisible
(
)
|
|
!
ShouldFollowAnchor
(
)
)
{
return
;
}
bool
shouldHide
=
false
;
nsPresContext
*
rootPresContext
=
PresContext
(
)
-
>
GetRootPresContext
(
)
;
nsIFrame
*
anchor
=
GetAnchorFrame
(
)
;
if
(
!
anchor
|
|
!
rootPresContext
)
{
shouldHide
=
true
;
}
else
if
(
!
anchor
-
>
IsVisibleConsideringAncestors
(
VISIBILITY_CROSS_CHROME_CONTENT_BOUNDARY
)
)
{
shouldHide
=
true
;
}
else
{
nsIFrame
*
frame
=
anchor
;
while
(
frame
)
{
nsMenuPopupFrame
*
popup
=
do_QueryFrame
(
frame
)
;
if
(
popup
&
&
popup
-
>
PopupState
(
)
!
=
ePopupShown
)
{
shouldHide
=
true
;
break
;
}
frame
=
frame
-
>
GetParent
(
)
;
}
}
if
(
shouldHide
)
{
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
pm
)
{
pm
-
>
HidePopup
(
mContent
{
HidePopupOption
:
:
DeselectMenu
HidePopupOption
:
:
Async
}
)
;
}
return
;
}
nsRect
anchorRect
=
ComputeAnchorRect
(
rootPresContext
anchor
)
;
if
(
!
anchorRect
.
IsEqualEdges
(
aRect
)
)
{
aRect
=
anchorRect
;
SetPopupPosition
(
true
)
;
}
}
