#
include
"
gfxContext
.
h
"
#
include
"
nsImageBoxFrame
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsStyleContext
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsStyleUtil
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsBoxLayoutState
.
h
"
#
include
"
nsHTMLParts
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsLeafFrame
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsImageMap
.
h
"
#
include
"
nsILinkHandler
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
nsILoadGroup
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsCSSRendering
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
"
nsTransform2D
.
h
"
#
include
"
nsITheme
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
ImageLayers
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
SVGImageContext
.
h
"
#
include
"
Units
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderLayerManager
.
h
"
#
if
defined
(
XP_WIN
)
#
undef
LoadImage
#
endif
#
define
ONLOAD_CALLED_TOO_EARLY
1
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
image
;
using
namespace
mozilla
:
:
layers
;
class
nsImageBoxFrameEvent
:
public
Runnable
{
public
:
nsImageBoxFrameEvent
(
nsIContent
*
content
EventMessage
message
)
:
mozilla
:
:
Runnable
(
"
nsImageBoxFrameEvent
"
)
mContent
(
content
)
mMessage
(
message
)
{
}
NS_IMETHOD
Run
(
)
override
;
private
:
nsCOMPtr
<
nsIContent
>
mContent
;
EventMessage
mMessage
;
}
;
NS_IMETHODIMP
nsImageBoxFrameEvent
:
:
Run
(
)
{
nsIPresShell
*
pres_shell
=
mContent
-
>
OwnerDoc
(
)
-
>
GetShell
(
)
;
if
(
!
pres_shell
)
{
return
NS_OK
;
}
RefPtr
<
nsPresContext
>
pres_context
=
pres_shell
-
>
GetPresContext
(
)
;
if
(
!
pres_context
)
{
return
NS_OK
;
}
nsEventStatus
status
=
nsEventStatus_eIgnore
;
WidgetEvent
event
(
true
mMessage
)
;
event
.
mFlags
.
mBubbles
=
false
;
EventDispatcher
:
:
Dispatch
(
mContent
pres_context
&
event
nullptr
&
status
)
;
return
NS_OK
;
}
void
FireImageDOMEvent
(
nsIContent
*
aContent
EventMessage
aMessage
)
{
NS_ASSERTION
(
aMessage
=
=
eLoad
|
|
aMessage
=
=
eLoadError
"
invalid
message
"
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
new
nsImageBoxFrameEvent
(
aContent
aMessage
)
;
nsresult
rv
=
aContent
-
>
OwnerDoc
(
)
-
>
Dispatch
(
TaskCategory
:
:
Other
event
.
forget
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
NS_WARNING
(
"
failed
to
dispatch
image
event
"
)
;
}
}
nsIFrame
*
NS_NewImageBoxFrame
(
nsIPresShell
*
aPresShell
nsStyleContext
*
aContext
)
{
return
new
(
aPresShell
)
nsImageBoxFrame
(
aContext
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsImageBoxFrame
)
nsresult
nsImageBoxFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
nsresult
rv
=
nsLeafBoxFrame
:
:
AttributeChanged
(
aNameSpaceID
aAttribute
aModType
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
src
)
{
UpdateImage
(
)
;
PresShell
(
)
-
>
FrameNeedsReflow
(
this
nsIPresShell
:
:
eStyleChange
NS_FRAME_IS_DIRTY
)
;
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
validate
)
UpdateLoadFlags
(
)
;
return
rv
;
}
nsImageBoxFrame
:
:
nsImageBoxFrame
(
nsStyleContext
*
aContext
)
:
nsLeafBoxFrame
(
aContext
kClassID
)
mIntrinsicSize
(
0
0
)
mLoadFlags
(
nsIRequest
:
:
LOAD_NORMAL
)
mRequestRegistered
(
false
)
mUseSrcAttr
(
false
)
mSuppressStyleCheck
(
false
)
{
MarkIntrinsicISizesDirty
(
)
;
}
nsImageBoxFrame
:
:
~
nsImageBoxFrame
(
)
{
}
void
nsImageBoxFrame
:
:
MarkIntrinsicISizesDirty
(
)
{
SizeNeedsRecalc
(
mImageSize
)
;
nsLeafBoxFrame
:
:
MarkIntrinsicISizesDirty
(
)
;
}
void
nsImageBoxFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
{
if
(
mImageRequest
)
{
nsLayoutUtils
:
:
DeregisterImageRequest
(
PresContext
(
)
mImageRequest
&
mRequestRegistered
)
;
mImageRequest
-
>
CancelAndForgetObserver
(
NS_ERROR_FAILURE
)
;
}
if
(
mListener
)
reinterpret_cast
<
nsImageBoxListener
*
>
(
mListener
.
get
(
)
)
-
>
SetFrame
(
nullptr
)
;
nsLeafBoxFrame
:
:
DestroyFrom
(
aDestructRoot
aPostDestroyData
)
;
}
void
nsImageBoxFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
if
(
!
mListener
)
{
RefPtr
<
nsImageBoxListener
>
listener
=
new
nsImageBoxListener
(
)
;
listener
-
>
SetFrame
(
this
)
;
mListener
=
listener
.
forget
(
)
;
}
mSuppressStyleCheck
=
true
;
nsLeafBoxFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
mSuppressStyleCheck
=
false
;
UpdateLoadFlags
(
)
;
UpdateImage
(
)
;
}
void
nsImageBoxFrame
:
:
UpdateImage
(
)
{
nsPresContext
*
presContext
=
PresContext
(
)
;
RefPtr
<
imgRequestProxy
>
oldImageRequest
=
mImageRequest
;
if
(
mImageRequest
)
{
nsLayoutUtils
:
:
DeregisterImageRequest
(
presContext
mImageRequest
&
mRequestRegistered
)
;
mImageRequest
-
>
CancelAndForgetObserver
(
NS_ERROR_FAILURE
)
;
mImageRequest
=
nullptr
;
}
nsAutoString
src
;
mContent
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
src
src
)
;
mUseSrcAttr
=
!
src
.
IsEmpty
(
)
;
if
(
mUseSrcAttr
)
{
nsIDocument
*
doc
=
mContent
-
>
GetComposedDoc
(
)
;
if
(
doc
)
{
nsContentPolicyType
contentPolicyType
;
nsCOMPtr
<
nsIPrincipal
>
triggeringPrincipal
;
uint64_t
requestContextID
=
0
;
nsContentUtils
:
:
GetContentPolicyTypeForUIImageLoading
(
mContent
getter_AddRefs
(
triggeringPrincipal
)
contentPolicyType
&
requestContextID
)
;
nsCOMPtr
<
nsIURI
>
baseURI
=
mContent
-
>
GetBaseURI
(
)
;
nsCOMPtr
<
nsIURI
>
uri
;
nsContentUtils
:
:
NewURIWithDocumentCharset
(
getter_AddRefs
(
uri
)
src
doc
baseURI
)
;
if
(
uri
)
{
nsresult
rv
=
nsContentUtils
:
:
LoadImage
(
uri
mContent
doc
triggeringPrincipal
requestContextID
doc
-
>
GetDocumentURI
(
)
doc
-
>
GetReferrerPolicy
(
)
mListener
mLoadFlags
EmptyString
(
)
getter_AddRefs
(
mImageRequest
)
contentPolicyType
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
mImageRequest
)
{
nsLayoutUtils
:
:
RegisterImageRequestIfAnimated
(
presContext
mImageRequest
&
mRequestRegistered
)
;
}
}
}
}
else
{
uint8_t
appearance
=
StyleDisplay
(
)
-
>
mAppearance
;
if
(
!
(
appearance
&
&
nsBox
:
:
gTheme
&
&
nsBox
:
:
gTheme
-
>
ThemeSupportsWidget
(
nullptr
this
appearance
)
)
)
{
imgRequestProxy
*
styleRequest
=
StyleList
(
)
-
>
GetListStyleImage
(
)
;
if
(
styleRequest
)
{
styleRequest
-
>
SyncClone
(
mListener
mContent
-
>
GetComposedDoc
(
)
getter_AddRefs
(
mImageRequest
)
)
;
}
}
}
if
(
!
mImageRequest
)
{
mIntrinsicSize
.
SizeTo
(
0
0
)
;
}
else
{
mImageRequest
-
>
StartDecoding
(
imgIContainer
:
:
FLAG_NONE
)
;
mImageRequest
-
>
LockImage
(
)
;
}
if
(
oldImageRequest
)
{
oldImageRequest
-
>
UnlockImage
(
)
;
}
}
void
nsImageBoxFrame
:
:
UpdateLoadFlags
(
)
{
static
nsIContent
:
:
AttrValuesArray
strings
[
]
=
{
&
nsGkAtoms
:
:
always
&
nsGkAtoms
:
:
never
nullptr
}
;
switch
(
mContent
-
>
FindAttrValueIn
(
kNameSpaceID_None
nsGkAtoms
:
:
validate
strings
eCaseMatters
)
)
{
case
0
:
mLoadFlags
=
nsIRequest
:
:
VALIDATE_ALWAYS
;
break
;
case
1
:
mLoadFlags
=
nsIRequest
:
:
VALIDATE_NEVER
|
nsIRequest
:
:
LOAD_FROM_CACHE
;
break
;
default
:
mLoadFlags
=
nsIRequest
:
:
LOAD_NORMAL
;
break
;
}
}
void
nsImageBoxFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
nsLeafBoxFrame
:
:
BuildDisplayList
(
aBuilder
aLists
)
;
if
(
(
0
=
=
mRect
.
width
)
|
|
(
0
=
=
mRect
.
height
)
)
{
return
;
}
if
(
!
IsVisibleForPainting
(
aBuilder
)
)
return
;
uint32_t
clipFlags
=
nsStyleUtil
:
:
ObjectPropsMightCauseOverflow
(
StylePosition
(
)
)
?
0
:
DisplayListClipState
:
:
ASSUME_DRAWING_RESTRICTED_TO_CONTENT_RECT
;
DisplayListClipState
:
:
AutoClipContainingBlockDescendantsToContentBox
clip
(
aBuilder
this
clipFlags
)
;
nsDisplayList
list
;
list
.
AppendNewToTop
(
new
(
aBuilder
)
nsDisplayXULImage
(
aBuilder
this
)
)
;
CreateOwnLayerIfNeeded
(
aBuilder
&
list
)
;
aLists
.
Content
(
)
-
>
AppendToTop
(
&
list
)
;
}
already_AddRefed
<
imgIContainer
>
nsImageBoxFrame
:
:
GetImageContainerForPainting
(
const
nsPoint
&
aPt
DrawResult
&
aDrawResult
Maybe
<
nsPoint
>
&
aAnchorPoint
nsRect
&
aDest
)
{
if
(
!
mImageRequest
)
{
aDrawResult
=
DrawResult
:
:
SUCCESS
;
return
nullptr
;
}
uint32_t
imgStatus
;
if
(
!
NS_SUCCEEDED
(
mImageRequest
-
>
GetImageStatus
(
&
imgStatus
)
)
|
|
!
(
imgStatus
&
imgIRequest
:
:
STATUS_SIZE_AVAILABLE
)
)
{
aDrawResult
=
DrawResult
:
:
NOT_READY
;
return
nullptr
;
}
nsCOMPtr
<
imgIContainer
>
imgCon
;
mImageRequest
-
>
GetImage
(
getter_AddRefs
(
imgCon
)
)
;
if
(
!
imgCon
)
{
aDrawResult
=
DrawResult
:
:
NOT_READY
;
return
nullptr
;
}
aDest
=
GetDestRect
(
aPt
aAnchorPoint
)
;
aDrawResult
=
DrawResult
:
:
SUCCESS
;
return
imgCon
.
forget
(
)
;
}
DrawResult
nsImageBoxFrame
:
:
PaintImage
(
gfxContext
&
aRenderingContext
const
nsRect
&
aDirtyRect
nsPoint
aPt
uint32_t
aFlags
)
{
DrawResult
result
;
Maybe
<
nsPoint
>
anchorPoint
;
nsRect
dest
;
nsCOMPtr
<
imgIContainer
>
imgCon
=
GetImageContainerForPainting
(
aPt
result
anchorPoint
dest
)
;
if
(
!
imgCon
)
{
return
result
;
}
nsRect
dirty
;
if
(
!
dirty
.
IntersectRect
(
aDirtyRect
dest
)
)
{
return
DrawResult
:
:
TEMPORARY_ERROR
;
}
bool
hasSubRect
=
!
mUseSrcAttr
&
&
(
mSubRect
.
width
>
0
|
|
mSubRect
.
height
>
0
)
;
Maybe
<
SVGImageContext
>
svgContext
;
SVGImageContext
:
:
MaybeStoreContextPaint
(
svgContext
this
imgCon
)
;
return
nsLayoutUtils
:
:
DrawSingleImage
(
aRenderingContext
PresContext
(
)
imgCon
nsLayoutUtils
:
:
GetSamplingFilterForFrame
(
this
)
dest
dirty
svgContext
aFlags
anchorPoint
.
ptrOr
(
nullptr
)
hasSubRect
?
&
mSubRect
:
nullptr
)
;
}
DrawResult
nsImageBoxFrame
:
:
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayItem
*
aItem
nsPoint
aPt
uint32_t
aFlags
)
{
DrawResult
result
;
Maybe
<
nsPoint
>
anchorPoint
;
nsRect
dest
;
nsCOMPtr
<
imgIContainer
>
imgCon
=
GetImageContainerForPainting
(
aPt
result
anchorPoint
dest
)
;
if
(
!
imgCon
)
{
return
result
;
}
uint32_t
containerFlags
=
imgIContainer
:
:
FLAG_ASYNC_NOTIFY
;
if
(
aFlags
&
nsImageRenderer
:
:
FLAG_PAINTING_TO_WINDOW
)
{
containerFlags
|
=
imgIContainer
:
:
FLAG_HIGH_QUALITY_SCALING
;
}
if
(
aFlags
&
nsImageRenderer
:
:
FLAG_SYNC_DECODE_IMAGES
)
{
containerFlags
|
=
imgIContainer
:
:
FLAG_SYNC_DECODE
;
}
const
int32_t
appUnitsPerDevPixel
=
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
LayoutDeviceRect
fillRect
=
LayoutDeviceRect
:
:
FromAppUnits
(
dest
appUnitsPerDevPixel
)
;
Maybe
<
SVGImageContext
>
svgContext
;
gfx
:
:
IntSize
decodeSize
=
nsLayoutUtils
:
:
ComputeImageContainerDrawingParameters
(
imgCon
aItem
-
>
Frame
(
)
fillRect
aSc
containerFlags
svgContext
)
;
RefPtr
<
layers
:
:
ImageContainer
>
container
=
imgCon
-
>
GetImageContainerAtSize
(
aManager
decodeSize
svgContext
containerFlags
)
;
if
(
!
container
)
{
NS_WARNING
(
"
Failed
to
get
image
container
"
)
;
return
DrawResult
:
:
NOT_READY
;
}
gfx
:
:
IntSize
size
;
Maybe
<
wr
:
:
ImageKey
>
key
=
aManager
-
>
CommandBuilder
(
)
.
CreateImageKey
(
aItem
container
aBuilder
aResources
aSc
size
Nothing
(
)
)
;
if
(
key
.
isNothing
(
)
)
{
return
DrawResult
:
:
BAD_IMAGE
;
}
wr
:
:
LayoutRect
fill
=
aSc
.
ToRelativeLayoutRect
(
fillRect
)
;
LayoutDeviceSize
gapSize
(
0
0
)
;
SamplingFilter
sampleFilter
=
nsLayoutUtils
:
:
GetSamplingFilterForFrame
(
aItem
-
>
Frame
(
)
)
;
aBuilder
.
PushImage
(
fill
fill
!
BackfaceIsHidden
(
)
wr
:
:
ToLayoutSize
(
fillRect
.
Size
(
)
)
wr
:
:
ToLayoutSize
(
gapSize
)
wr
:
:
ToImageRendering
(
sampleFilter
)
key
.
value
(
)
)
;
return
DrawResult
:
:
SUCCESS
;
}
nsRect
nsImageBoxFrame
:
:
GetDestRect
(
const
nsPoint
&
aOffset
Maybe
<
nsPoint
>
&
aAnchorPoint
)
{
nsCOMPtr
<
imgIContainer
>
imgCon
;
mImageRequest
-
>
GetImage
(
getter_AddRefs
(
imgCon
)
)
;
MOZ_ASSERT
(
imgCon
)
;
nsRect
clientRect
;
GetXULClientRect
(
clientRect
)
;
clientRect
+
=
aOffset
;
nsRect
dest
;
if
(
!
mUseSrcAttr
)
{
dest
=
clientRect
;
}
else
{
IntrinsicSize
intrinsicSize
;
nsSize
intrinsicRatio
;
if
(
mIntrinsicSize
.
width
>
0
&
&
mIntrinsicSize
.
height
>
0
)
{
intrinsicSize
.
width
.
SetCoordValue
(
mIntrinsicSize
.
width
)
;
intrinsicSize
.
height
.
SetCoordValue
(
mIntrinsicSize
.
height
)
;
intrinsicRatio
=
mIntrinsicSize
;
}
else
{
imgCon
-
>
GetIntrinsicRatio
(
&
intrinsicRatio
)
;
}
aAnchorPoint
.
emplace
(
)
;
dest
=
nsLayoutUtils
:
:
ComputeObjectDestRect
(
clientRect
intrinsicSize
intrinsicRatio
StylePosition
(
)
aAnchorPoint
.
ptr
(
)
)
;
}
return
dest
;
}
void
nsDisplayXULImage
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
uint32_t
flags
=
imgIContainer
:
:
FLAG_SYNC_DECODE_IF_FAST
;
if
(
aBuilder
-
>
ShouldSyncDecodeImages
(
)
)
flags
|
=
imgIContainer
:
:
FLAG_SYNC_DECODE
;
if
(
aBuilder
-
>
IsPaintingToWindow
(
)
)
flags
|
=
imgIContainer
:
:
FLAG_HIGH_QUALITY_SCALING
;
DrawResult
result
=
static_cast
<
nsImageBoxFrame
*
>
(
mFrame
)
-
>
PaintImage
(
*
aCtx
mVisibleRect
ToReferenceFrame
(
)
flags
)
;
nsDisplayItemGenericImageGeometry
:
:
UpdateDrawResult
(
this
result
)
;
}
LayerState
nsDisplayXULImage
:
:
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
{
if
(
ShouldUseAdvancedLayer
(
aManager
gfxPrefs
:
:
LayersAllowImageLayers
)
&
&
CanOptimizeToImageLayer
(
aManager
aBuilder
)
)
{
return
LAYER_ACTIVE
;
}
return
LAYER_NONE
;
}
already_AddRefed
<
Layer
>
nsDisplayXULImage
:
:
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
{
return
BuildDisplayItemLayer
(
aBuilder
aManager
aContainerParameters
)
;
}
bool
nsDisplayXULImage
:
:
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
nsImageBoxFrame
*
imageFrame
=
static_cast
<
nsImageBoxFrame
*
>
(
mFrame
)
;
if
(
!
imageFrame
-
>
CanOptimizeToImageLayer
(
)
)
{
return
false
;
}
if
(
!
imageFrame
-
>
mImageRequest
)
{
return
false
;
}
uint32_t
flags
=
imgIContainer
:
:
FLAG_SYNC_DECODE_IF_FAST
;
if
(
aDisplayListBuilder
-
>
ShouldSyncDecodeImages
(
)
)
{
flags
|
=
imgIContainer
:
:
FLAG_SYNC_DECODE
;
}
if
(
aDisplayListBuilder
-
>
IsPaintingToWindow
(
)
)
{
flags
|
=
imgIContainer
:
:
FLAG_HIGH_QUALITY_SCALING
;
}
DrawResult
result
=
imageFrame
-
>
CreateWebRenderCommands
(
aBuilder
aResources
aSc
aManager
this
ToReferenceFrame
(
)
flags
)
;
nsDisplayItemGenericImageGeometry
:
:
UpdateDrawResult
(
this
result
)
;
return
true
;
}
nsDisplayItemGeometry
*
nsDisplayXULImage
:
:
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
{
return
new
nsDisplayItemGenericImageGeometry
(
this
aBuilder
)
;
}
void
nsDisplayXULImage
:
:
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
{
auto
boxFrame
=
static_cast
<
nsImageBoxFrame
*
>
(
mFrame
)
;
auto
geometry
=
static_cast
<
const
nsDisplayItemGenericImageGeometry
*
>
(
aGeometry
)
;
if
(
aBuilder
-
>
ShouldSyncDecodeImages
(
)
&
&
boxFrame
-
>
mImageRequest
&
&
geometry
-
>
ShouldInvalidateToSyncDecodeImages
(
)
)
{
bool
snap
;
aInvalidRegion
-
>
Or
(
*
aInvalidRegion
GetBounds
(
aBuilder
&
snap
)
)
;
}
nsDisplayImageContainer
:
:
ComputeInvalidationRegion
(
aBuilder
aGeometry
aInvalidRegion
)
;
}
bool
nsDisplayXULImage
:
:
CanOptimizeToImageLayer
(
LayerManager
*
aManager
nsDisplayListBuilder
*
aBuilder
)
{
nsImageBoxFrame
*
imageFrame
=
static_cast
<
nsImageBoxFrame
*
>
(
mFrame
)
;
if
(
!
imageFrame
-
>
CanOptimizeToImageLayer
(
)
)
{
return
false
;
}
return
nsDisplayImageContainer
:
:
CanOptimizeToImageLayer
(
aManager
aBuilder
)
;
}
already_AddRefed
<
imgIContainer
>
nsDisplayXULImage
:
:
GetImage
(
)
{
nsImageBoxFrame
*
imageFrame
=
static_cast
<
nsImageBoxFrame
*
>
(
mFrame
)
;
if
(
!
imageFrame
-
>
mImageRequest
)
{
return
nullptr
;
}
nsCOMPtr
<
imgIContainer
>
imgCon
;
imageFrame
-
>
mImageRequest
-
>
GetImage
(
getter_AddRefs
(
imgCon
)
)
;
return
imgCon
.
forget
(
)
;
}
nsRect
nsDisplayXULImage
:
:
GetDestRect
(
)
const
{
Maybe
<
nsPoint
>
anchorPoint
;
return
static_cast
<
nsImageBoxFrame
*
>
(
mFrame
)
-
>
GetDestRect
(
ToReferenceFrame
(
)
anchorPoint
)
;
}
bool
nsImageBoxFrame
:
:
CanOptimizeToImageLayer
(
)
{
bool
hasSubRect
=
!
mUseSrcAttr
&
&
(
mSubRect
.
width
>
0
|
|
mSubRect
.
height
>
0
)
;
if
(
hasSubRect
)
{
return
false
;
}
return
true
;
}
void
nsImageBoxFrame
:
:
DidSetStyleContext
(
nsStyleContext
*
aOldStyleContext
)
{
nsLeafBoxFrame
:
:
DidSetStyleContext
(
aOldStyleContext
)
;
const
nsStyleList
*
myList
=
StyleList
(
)
;
mSubRect
=
myList
-
>
mImageRegion
;
if
(
mUseSrcAttr
|
|
mSuppressStyleCheck
)
return
;
const
nsStyleDisplay
*
disp
=
StyleDisplay
(
)
;
if
(
disp
-
>
mAppearance
&
&
nsBox
:
:
gTheme
&
&
nsBox
:
:
gTheme
-
>
ThemeSupportsWidget
(
nullptr
this
disp
-
>
mAppearance
)
)
return
;
nsCOMPtr
<
nsIURI
>
oldURI
newURI
;
if
(
mImageRequest
)
mImageRequest
-
>
GetURI
(
getter_AddRefs
(
oldURI
)
)
;
if
(
myList
-
>
GetListStyleImage
(
)
)
myList
-
>
GetListStyleImage
(
)
-
>
GetURI
(
getter_AddRefs
(
newURI
)
)
;
bool
equal
;
if
(
newURI
=
=
oldURI
|
|
(
newURI
&
&
oldURI
&
&
NS_SUCCEEDED
(
newURI
-
>
Equals
(
oldURI
&
equal
)
)
&
&
equal
)
)
return
;
UpdateImage
(
)
;
}
void
nsImageBoxFrame
:
:
GetImageSize
(
)
{
if
(
mIntrinsicSize
.
width
>
0
&
&
mIntrinsicSize
.
height
>
0
)
{
mImageSize
.
width
=
mIntrinsicSize
.
width
;
mImageSize
.
height
=
mIntrinsicSize
.
height
;
}
else
{
mImageSize
.
width
=
0
;
mImageSize
.
height
=
0
;
}
}
nsSize
nsImageBoxFrame
:
:
GetXULPrefSize
(
nsBoxLayoutState
&
aState
)
{
nsSize
size
(
0
0
)
;
DISPLAY_PREF_SIZE
(
this
size
)
;
if
(
DoesNeedRecalc
(
mImageSize
)
)
GetImageSize
(
)
;
if
(
!
mUseSrcAttr
&
&
(
mSubRect
.
width
>
0
|
|
mSubRect
.
height
>
0
)
)
size
=
mSubRect
.
Size
(
)
;
else
size
=
mImageSize
;
nsSize
intrinsicSize
=
size
;
nsMargin
borderPadding
(
0
0
0
0
)
;
GetXULBorderAndPadding
(
borderPadding
)
;
size
.
width
+
=
borderPadding
.
LeftRight
(
)
;
size
.
height
+
=
borderPadding
.
TopBottom
(
)
;
bool
widthSet
heightSet
;
nsIFrame
:
:
AddXULPrefSize
(
this
size
widthSet
heightSet
)
;
NS_ASSERTION
(
size
.
width
!
=
NS_INTRINSICSIZE
&
&
size
.
height
!
=
NS_INTRINSICSIZE
"
non
-
intrinsic
size
expected
"
)
;
nsSize
minSize
=
GetXULMinSize
(
aState
)
;
nsSize
maxSize
=
GetXULMaxSize
(
aState
)
;
if
(
!
widthSet
&
&
!
heightSet
)
{
if
(
minSize
.
width
!
=
NS_INTRINSICSIZE
)
minSize
.
width
-
=
borderPadding
.
LeftRight
(
)
;
if
(
minSize
.
height
!
=
NS_INTRINSICSIZE
)
minSize
.
height
-
=
borderPadding
.
TopBottom
(
)
;
if
(
maxSize
.
width
!
=
NS_INTRINSICSIZE
)
maxSize
.
width
-
=
borderPadding
.
LeftRight
(
)
;
if
(
maxSize
.
height
!
=
NS_INTRINSICSIZE
)
maxSize
.
height
-
=
borderPadding
.
TopBottom
(
)
;
size
=
nsLayoutUtils
:
:
ComputeAutoSizeWithIntrinsicDimensions
(
minSize
.
width
minSize
.
height
maxSize
.
width
maxSize
.
height
intrinsicSize
.
width
intrinsicSize
.
height
)
;
NS_ASSERTION
(
size
.
width
!
=
NS_INTRINSICSIZE
&
&
size
.
height
!
=
NS_INTRINSICSIZE
"
non
-
intrinsic
size
expected
"
)
;
size
.
width
+
=
borderPadding
.
LeftRight
(
)
;
size
.
height
+
=
borderPadding
.
TopBottom
(
)
;
return
size
;
}
if
(
!
widthSet
)
{
if
(
intrinsicSize
.
height
>
0
)
{
nscoord
height
=
size
.
height
-
borderPadding
.
TopBottom
(
)
;
size
.
width
=
nscoord
(
int64_t
(
height
)
*
int64_t
(
intrinsicSize
.
width
)
/
int64_t
(
intrinsicSize
.
height
)
)
;
}
else
{
size
.
width
=
intrinsicSize
.
width
;
}
size
.
width
+
=
borderPadding
.
LeftRight
(
)
;
}
else
if
(
!
heightSet
)
{
if
(
intrinsicSize
.
width
>
0
)
{
nscoord
width
=
size
.
width
-
borderPadding
.
LeftRight
(
)
;
size
.
height
=
nscoord
(
int64_t
(
width
)
*
int64_t
(
intrinsicSize
.
height
)
/
int64_t
(
intrinsicSize
.
width
)
)
;
}
else
{
size
.
height
=
intrinsicSize
.
height
;
}
size
.
height
+
=
borderPadding
.
TopBottom
(
)
;
}
return
BoundsCheck
(
minSize
size
maxSize
)
;
}
nsSize
nsImageBoxFrame
:
:
GetXULMinSize
(
nsBoxLayoutState
&
aState
)
{
nsSize
size
(
0
0
)
;
DISPLAY_MIN_SIZE
(
this
size
)
;
AddBorderAndPadding
(
size
)
;
bool
widthSet
heightSet
;
nsIFrame
:
:
AddXULMinSize
(
aState
this
size
widthSet
heightSet
)
;
return
size
;
}
nscoord
nsImageBoxFrame
:
:
GetXULBoxAscent
(
nsBoxLayoutState
&
aState
)
{
return
GetXULPrefSize
(
aState
)
.
height
;
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
nsImageBoxFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
NS_LITERAL_STRING
(
"
ImageBox
"
)
aResult
)
;
}
#
endif
nsresult
nsImageBoxFrame
:
:
Notify
(
imgIRequest
*
aRequest
int32_t
aType
const
nsIntRect
*
aData
)
{
if
(
aType
=
=
imgINotificationObserver
:
:
SIZE_AVAILABLE
)
{
nsCOMPtr
<
imgIContainer
>
image
;
aRequest
-
>
GetImage
(
getter_AddRefs
(
image
)
)
;
return
OnSizeAvailable
(
aRequest
image
)
;
}
if
(
aType
=
=
imgINotificationObserver
:
:
DECODE_COMPLETE
)
{
return
OnDecodeComplete
(
aRequest
)
;
}
if
(
aType
=
=
imgINotificationObserver
:
:
LOAD_COMPLETE
)
{
uint32_t
imgStatus
;
aRequest
-
>
GetImageStatus
(
&
imgStatus
)
;
nsresult
status
=
imgStatus
&
imgIRequest
:
:
STATUS_ERROR
?
NS_ERROR_FAILURE
:
NS_OK
;
return
OnLoadComplete
(
aRequest
status
)
;
}
if
(
aType
=
=
imgINotificationObserver
:
:
IS_ANIMATED
)
{
return
OnImageIsAnimated
(
aRequest
)
;
}
if
(
aType
=
=
imgINotificationObserver
:
:
FRAME_UPDATE
)
{
return
OnFrameUpdate
(
aRequest
)
;
}
return
NS_OK
;
}
nsresult
nsImageBoxFrame
:
:
OnSizeAvailable
(
imgIRequest
*
aRequest
imgIContainer
*
aImage
)
{
NS_ENSURE_ARG_POINTER
(
aImage
)
;
aRequest
-
>
IncrementAnimationConsumers
(
)
;
nscoord
w
h
;
aImage
-
>
GetWidth
(
&
w
)
;
aImage
-
>
GetHeight
(
&
h
)
;
mIntrinsicSize
.
SizeTo
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
w
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
h
)
)
;
if
(
!
(
GetStateBits
(
)
&
NS_FRAME_FIRST_REFLOW
)
)
{
PresShell
(
)
-
>
FrameNeedsReflow
(
this
nsIPresShell
:
:
eStyleChange
NS_FRAME_IS_DIRTY
)
;
}
return
NS_OK
;
}
nsresult
nsImageBoxFrame
:
:
OnDecodeComplete
(
imgIRequest
*
aRequest
)
{
nsBoxLayoutState
state
(
PresContext
(
)
)
;
this
-
>
XULRedraw
(
state
)
;
return
NS_OK
;
}
nsresult
nsImageBoxFrame
:
:
OnLoadComplete
(
imgIRequest
*
aRequest
nsresult
aStatus
)
{
if
(
NS_SUCCEEDED
(
aStatus
)
)
{
FireImageDOMEvent
(
mContent
eLoad
)
;
}
else
{
mIntrinsicSize
.
SizeTo
(
0
0
)
;
PresShell
(
)
-
>
FrameNeedsReflow
(
this
nsIPresShell
:
:
eStyleChange
NS_FRAME_IS_DIRTY
)
;
FireImageDOMEvent
(
mContent
eLoadError
)
;
}
return
NS_OK
;
}
nsresult
nsImageBoxFrame
:
:
OnImageIsAnimated
(
imgIRequest
*
aRequest
)
{
nsLayoutUtils
:
:
RegisterImageRequest
(
PresContext
(
)
aRequest
&
mRequestRegistered
)
;
return
NS_OK
;
}
nsresult
nsImageBoxFrame
:
:
OnFrameUpdate
(
imgIRequest
*
aRequest
)
{
if
(
(
0
=
=
mRect
.
width
)
|
|
(
0
=
=
mRect
.
height
)
)
{
return
NS_OK
;
}
InvalidateLayer
(
DisplayItemType
:
:
TYPE_XUL_IMAGE
)
;
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
nsImageBoxListener
imgINotificationObserver
)
nsImageBoxListener
:
:
nsImageBoxListener
(
)
{
}
nsImageBoxListener
:
:
~
nsImageBoxListener
(
)
{
}
NS_IMETHODIMP
nsImageBoxListener
:
:
Notify
(
imgIRequest
*
request
int32_t
aType
const
nsIntRect
*
aData
)
{
if
(
!
mFrame
)
return
NS_OK
;
return
mFrame
-
>
Notify
(
request
aType
aData
)
;
}
