#
include
"
nsImageBoxFrame
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsRenderingContext
.
h
"
#
include
"
nsStyleContext
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsStyleUtil
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsBoxLayoutState
.
h
"
#
include
"
nsHTMLParts
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsLeafFrame
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsImageMap
.
h
"
#
include
"
nsILinkHandler
.
h
"
#
include
"
nsIURL
.
h
"
#
include
"
nsILoadGroup
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
prprf
.
h
"
#
include
"
nsCSSRendering
.
h
"
#
include
"
nsIDOMHTMLImageElement
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
"
nsIDOMHTMLMapElement
.
h
"
#
include
"
nsTransform2D
.
h
"
#
include
"
nsITheme
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
ImageLayers
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsSerializationHelper
.
h
"
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
define
ONLOAD_CALLED_TOO_EARLY
1
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
image
;
using
namespace
mozilla
:
:
layers
;
class
nsImageBoxFrameEvent
:
public
Runnable
{
public
:
nsImageBoxFrameEvent
(
nsIContent
*
content
EventMessage
message
)
:
mContent
(
content
)
mMessage
(
message
)
{
}
NS_IMETHOD
Run
(
)
override
;
private
:
nsCOMPtr
<
nsIContent
>
mContent
;
EventMessage
mMessage
;
}
;
NS_IMETHODIMP
nsImageBoxFrameEvent
:
:
Run
(
)
{
nsIPresShell
*
pres_shell
=
mContent
-
>
OwnerDoc
(
)
-
>
GetShell
(
)
;
if
(
!
pres_shell
)
{
return
NS_OK
;
}
RefPtr
<
nsPresContext
>
pres_context
=
pres_shell
-
>
GetPresContext
(
)
;
if
(
!
pres_context
)
{
return
NS_OK
;
}
nsEventStatus
status
=
nsEventStatus_eIgnore
;
WidgetEvent
event
(
true
mMessage
)
;
event
.
mFlags
.
mBubbles
=
false
;
EventDispatcher
:
:
Dispatch
(
mContent
pres_context
&
event
nullptr
&
status
)
;
return
NS_OK
;
}
void
FireImageDOMEvent
(
nsIContent
*
aContent
EventMessage
aMessage
)
{
NS_ASSERTION
(
aMessage
=
=
eLoad
|
|
aMessage
=
=
eLoadError
"
invalid
message
"
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
new
nsImageBoxFrameEvent
(
aContent
aMessage
)
;
if
(
NS_FAILED
(
NS_DispatchToCurrentThread
(
event
)
)
)
NS_WARNING
(
"
failed
to
dispatch
image
event
"
)
;
}
nsIFrame
*
NS_NewImageBoxFrame
(
nsIPresShell
*
aPresShell
nsStyleContext
*
aContext
)
{
return
new
(
aPresShell
)
nsImageBoxFrame
(
aContext
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsImageBoxFrame
)
nsresult
nsImageBoxFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsIAtom
*
aAttribute
int32_t
aModType
)
{
nsresult
rv
=
nsLeafBoxFrame
:
:
AttributeChanged
(
aNameSpaceID
aAttribute
aModType
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
src
)
{
UpdateImage
(
)
;
PresContext
(
)
-
>
PresShell
(
)
-
>
FrameNeedsReflow
(
this
nsIPresShell
:
:
eStyleChange
NS_FRAME_IS_DIRTY
)
;
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
validate
)
UpdateLoadFlags
(
)
;
return
rv
;
}
nsImageBoxFrame
:
:
nsImageBoxFrame
(
nsStyleContext
*
aContext
)
:
nsLeafBoxFrame
(
aContext
)
mIntrinsicSize
(
0
0
)
mLoadFlags
(
nsIRequest
:
:
LOAD_NORMAL
)
mRequestRegistered
(
false
)
mUseSrcAttr
(
false
)
mSuppressStyleCheck
(
false
)
{
MarkIntrinsicISizesDirty
(
)
;
}
nsImageBoxFrame
:
:
~
nsImageBoxFrame
(
)
{
}
void
nsImageBoxFrame
:
:
MarkIntrinsicISizesDirty
(
)
{
SizeNeedsRecalc
(
mImageSize
)
;
nsLeafBoxFrame
:
:
MarkIntrinsicISizesDirty
(
)
;
}
void
nsImageBoxFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestructRoot
)
{
if
(
mImageRequest
)
{
nsLayoutUtils
:
:
DeregisterImageRequest
(
PresContext
(
)
mImageRequest
&
mRequestRegistered
)
;
mImageRequest
-
>
CancelAndForgetObserver
(
NS_ERROR_FAILURE
)
;
}
if
(
mListener
)
reinterpret_cast
<
nsImageBoxListener
*
>
(
mListener
.
get
(
)
)
-
>
SetFrame
(
nullptr
)
;
nsLeafBoxFrame
:
:
DestroyFrom
(
aDestructRoot
)
;
}
void
nsImageBoxFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
if
(
!
mListener
)
{
RefPtr
<
nsImageBoxListener
>
listener
=
new
nsImageBoxListener
(
)
;
listener
-
>
SetFrame
(
this
)
;
mListener
=
listener
.
forget
(
)
;
}
mSuppressStyleCheck
=
true
;
nsLeafBoxFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
mSuppressStyleCheck
=
false
;
UpdateLoadFlags
(
)
;
UpdateImage
(
)
;
}
void
nsImageBoxFrame
:
:
UpdateImage
(
)
{
nsPresContext
*
presContext
=
PresContext
(
)
;
RefPtr
<
imgRequestProxy
>
oldImageRequest
=
mImageRequest
;
if
(
mImageRequest
)
{
nsLayoutUtils
:
:
DeregisterImageRequest
(
presContext
mImageRequest
&
mRequestRegistered
)
;
mImageRequest
-
>
CancelAndForgetObserver
(
NS_ERROR_FAILURE
)
;
mImageRequest
=
nullptr
;
}
nsAutoString
src
;
mContent
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
src
src
)
;
mUseSrcAttr
=
!
src
.
IsEmpty
(
)
;
if
(
mUseSrcAttr
)
{
nsIDocument
*
doc
=
mContent
-
>
GetComposedDoc
(
)
;
if
(
doc
)
{
nsContentPolicyType
contentPolicyType
=
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE
;
nsCOMPtr
<
nsIPrincipal
>
loadingPrincipal
=
mContent
-
>
NodePrincipal
(
)
;
nsAutoString
imageLoadingPrincipal
;
mContent
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
loadingprincipal
imageLoadingPrincipal
)
;
if
(
!
imageLoadingPrincipal
.
IsEmpty
(
)
)
{
nsCOMPtr
<
nsISupports
>
serializedPrincipal
;
NS_DeserializeObject
(
NS_ConvertUTF16toUTF8
(
imageLoadingPrincipal
)
getter_AddRefs
(
serializedPrincipal
)
)
;
loadingPrincipal
=
do_QueryInterface
(
serializedPrincipal
)
;
if
(
loadingPrincipal
)
{
contentPolicyType
=
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE_FAVICON
;
}
else
{
loadingPrincipal
=
mContent
-
>
NodePrincipal
(
)
;
}
}
nsCOMPtr
<
nsIURI
>
baseURI
=
mContent
-
>
GetBaseURI
(
)
;
nsCOMPtr
<
nsIURI
>
uri
;
nsContentUtils
:
:
NewURIWithDocumentCharset
(
getter_AddRefs
(
uri
)
src
doc
baseURI
)
;
if
(
uri
)
{
nsresult
rv
=
nsContentUtils
:
:
LoadImage
(
uri
mContent
doc
loadingPrincipal
doc
-
>
GetDocumentURI
(
)
doc
-
>
GetReferrerPolicy
(
)
mListener
mLoadFlags
EmptyString
(
)
getter_AddRefs
(
mImageRequest
)
contentPolicyType
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
mImageRequest
)
{
nsLayoutUtils
:
:
RegisterImageRequestIfAnimated
(
presContext
mImageRequest
&
mRequestRegistered
)
;
}
}
}
}
else
{
uint8_t
appearance
=
StyleDisplay
(
)
-
>
mAppearance
;
if
(
!
(
appearance
&
&
nsBox
:
:
gTheme
&
&
nsBox
:
:
gTheme
-
>
ThemeSupportsWidget
(
nullptr
this
appearance
)
)
)
{
imgRequestProxy
*
styleRequest
=
StyleList
(
)
-
>
GetListStyleImage
(
)
;
if
(
styleRequest
)
{
styleRequest
-
>
Clone
(
mListener
getter_AddRefs
(
mImageRequest
)
)
;
}
}
}
if
(
!
mImageRequest
)
{
mIntrinsicSize
.
SizeTo
(
0
0
)
;
}
else
{
mImageRequest
-
>
StartDecoding
(
)
;
mImageRequest
-
>
LockImage
(
)
;
}
if
(
oldImageRequest
)
{
oldImageRequest
-
>
UnlockImage
(
)
;
}
}
void
nsImageBoxFrame
:
:
UpdateLoadFlags
(
)
{
static
nsIContent
:
:
AttrValuesArray
strings
[
]
=
{
&
nsGkAtoms
:
:
always
&
nsGkAtoms
:
:
never
nullptr
}
;
switch
(
mContent
-
>
FindAttrValueIn
(
kNameSpaceID_None
nsGkAtoms
:
:
validate
strings
eCaseMatters
)
)
{
case
0
:
mLoadFlags
=
nsIRequest
:
:
VALIDATE_ALWAYS
;
break
;
case
1
:
mLoadFlags
=
nsIRequest
:
:
VALIDATE_NEVER
|
nsIRequest
:
:
LOAD_FROM_CACHE
;
break
;
default
:
mLoadFlags
=
nsIRequest
:
:
LOAD_NORMAL
;
break
;
}
}
void
nsImageBoxFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aDirtyRect
const
nsDisplayListSet
&
aLists
)
{
nsLeafBoxFrame
:
:
BuildDisplayList
(
aBuilder
aDirtyRect
aLists
)
;
if
(
(
0
=
=
mRect
.
width
)
|
|
(
0
=
=
mRect
.
height
)
)
{
return
;
}
if
(
!
IsVisibleForPainting
(
aBuilder
)
)
return
;
uint32_t
clipFlags
=
nsStyleUtil
:
:
ObjectPropsMightCauseOverflow
(
StylePosition
(
)
)
?
0
:
DisplayListClipState
:
:
ASSUME_DRAWING_RESTRICTED_TO_CONTENT_RECT
;
DisplayListClipState
:
:
AutoClipContainingBlockDescendantsToContentBox
clip
(
aBuilder
this
clipFlags
)
;
nsDisplayList
list
;
list
.
AppendNewToTop
(
new
(
aBuilder
)
nsDisplayXULImage
(
aBuilder
this
)
)
;
CreateOwnLayerIfNeeded
(
aBuilder
&
list
)
;
aLists
.
Content
(
)
-
>
AppendToTop
(
&
list
)
;
}
DrawResult
nsImageBoxFrame
:
:
PaintImage
(
nsRenderingContext
&
aRenderingContext
const
nsRect
&
aDirtyRect
nsPoint
aPt
uint32_t
aFlags
)
{
nsRect
constraintRect
;
GetXULClientRect
(
constraintRect
)
;
constraintRect
+
=
aPt
;
if
(
!
mImageRequest
)
{
return
DrawResult
:
:
SUCCESS
;
}
nsRect
dirty
;
if
(
!
dirty
.
IntersectRect
(
aDirtyRect
constraintRect
)
)
{
return
DrawResult
:
:
TEMPORARY_ERROR
;
}
uint32_t
imgStatus
;
if
(
!
NS_SUCCEEDED
(
mImageRequest
-
>
GetImageStatus
(
&
imgStatus
)
)
|
|
!
(
imgStatus
&
imgIRequest
:
:
STATUS_SIZE_AVAILABLE
)
)
{
return
DrawResult
:
:
NOT_READY
;
}
nsCOMPtr
<
imgIContainer
>
imgCon
;
mImageRequest
-
>
GetImage
(
getter_AddRefs
(
imgCon
)
)
;
if
(
!
imgCon
)
{
return
DrawResult
:
:
NOT_READY
;
}
bool
hasSubRect
=
!
mUseSrcAttr
&
&
(
mSubRect
.
width
>
0
|
|
mSubRect
.
height
>
0
)
;
Maybe
<
nsPoint
>
anchorPoint
;
nsRect
dest
;
if
(
!
mUseSrcAttr
)
{
dest
=
constraintRect
;
}
else
{
IntrinsicSize
intrinsicSize
;
nsSize
intrinsicRatio
;
if
(
mIntrinsicSize
.
width
>
0
&
&
mIntrinsicSize
.
height
>
0
)
{
intrinsicSize
.
width
.
SetCoordValue
(
mIntrinsicSize
.
width
)
;
intrinsicSize
.
height
.
SetCoordValue
(
mIntrinsicSize
.
height
)
;
intrinsicRatio
=
mIntrinsicSize
;
}
else
{
imgCon
-
>
GetIntrinsicRatio
(
&
intrinsicRatio
)
;
}
anchorPoint
.
emplace
(
)
;
dest
=
nsLayoutUtils
:
:
ComputeObjectDestRect
(
constraintRect
intrinsicSize
intrinsicRatio
StylePosition
(
)
anchorPoint
.
ptr
(
)
)
;
}
return
nsLayoutUtils
:
:
DrawSingleImage
(
*
aRenderingContext
.
ThebesContext
(
)
PresContext
(
)
imgCon
nsLayoutUtils
:
:
GetSamplingFilterForFrame
(
this
)
dest
dirty
nullptr
aFlags
anchorPoint
.
ptrOr
(
nullptr
)
hasSubRect
?
&
mSubRect
:
nullptr
)
;
}
void
nsDisplayXULImage
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
nsRenderingContext
*
aCtx
)
{
uint32_t
flags
=
imgIContainer
:
:
FLAG_NONE
;
if
(
aBuilder
-
>
ShouldSyncDecodeImages
(
)
)
flags
|
=
imgIContainer
:
:
FLAG_SYNC_DECODE
;
if
(
aBuilder
-
>
IsPaintingToWindow
(
)
)
flags
|
=
imgIContainer
:
:
FLAG_HIGH_QUALITY_SCALING
;
DrawResult
result
=
static_cast
<
nsImageBoxFrame
*
>
(
mFrame
)
-
>
PaintImage
(
*
aCtx
mVisibleRect
ToReferenceFrame
(
)
flags
)
;
nsDisplayItemGenericImageGeometry
:
:
UpdateDrawResult
(
this
result
)
;
}
nsDisplayItemGeometry
*
nsDisplayXULImage
:
:
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
{
return
new
nsDisplayItemGenericImageGeometry
(
this
aBuilder
)
;
}
void
nsDisplayXULImage
:
:
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
{
auto
boxFrame
=
static_cast
<
nsImageBoxFrame
*
>
(
mFrame
)
;
auto
geometry
=
static_cast
<
const
nsDisplayItemGenericImageGeometry
*
>
(
aGeometry
)
;
if
(
aBuilder
-
>
ShouldSyncDecodeImages
(
)
&
&
boxFrame
-
>
mImageRequest
&
&
geometry
-
>
ShouldInvalidateToSyncDecodeImages
(
)
)
{
bool
snap
;
aInvalidRegion
-
>
Or
(
*
aInvalidRegion
GetBounds
(
aBuilder
&
snap
)
)
;
}
nsDisplayImageContainer
:
:
ComputeInvalidationRegion
(
aBuilder
aGeometry
aInvalidRegion
)
;
}
bool
nsDisplayXULImage
:
:
CanOptimizeToImageLayer
(
LayerManager
*
aManager
nsDisplayListBuilder
*
aBuilder
)
{
nsImageBoxFrame
*
imageFrame
=
static_cast
<
nsImageBoxFrame
*
>
(
mFrame
)
;
if
(
!
imageFrame
-
>
CanOptimizeToImageLayer
(
)
)
{
return
false
;
}
return
nsDisplayImageContainer
:
:
CanOptimizeToImageLayer
(
aManager
aBuilder
)
;
}
already_AddRefed
<
imgIContainer
>
nsDisplayXULImage
:
:
GetImage
(
)
{
nsImageBoxFrame
*
imageFrame
=
static_cast
<
nsImageBoxFrame
*
>
(
mFrame
)
;
if
(
!
imageFrame
-
>
mImageRequest
)
{
return
nullptr
;
}
nsCOMPtr
<
imgIContainer
>
imgCon
;
imageFrame
-
>
mImageRequest
-
>
GetImage
(
getter_AddRefs
(
imgCon
)
)
;
return
imgCon
.
forget
(
)
;
}
nsRect
nsDisplayXULImage
:
:
GetDestRect
(
)
{
nsImageBoxFrame
*
imageFrame
=
static_cast
<
nsImageBoxFrame
*
>
(
mFrame
)
;
nsRect
clientRect
;
imageFrame
-
>
GetXULClientRect
(
clientRect
)
;
return
clientRect
+
ToReferenceFrame
(
)
;
}
bool
nsImageBoxFrame
:
:
CanOptimizeToImageLayer
(
)
{
bool
hasSubRect
=
!
mUseSrcAttr
&
&
(
mSubRect
.
width
>
0
|
|
mSubRect
.
height
>
0
)
;
if
(
hasSubRect
)
{
return
false
;
}
return
true
;
}
void
nsImageBoxFrame
:
:
DidSetStyleContext
(
nsStyleContext
*
aOldStyleContext
)
{
nsLeafBoxFrame
:
:
DidSetStyleContext
(
aOldStyleContext
)
;
const
nsStyleList
*
myList
=
StyleList
(
)
;
mSubRect
=
myList
-
>
mImageRegion
;
if
(
mUseSrcAttr
|
|
mSuppressStyleCheck
)
return
;
const
nsStyleDisplay
*
disp
=
StyleDisplay
(
)
;
if
(
disp
-
>
mAppearance
&
&
nsBox
:
:
gTheme
&
&
nsBox
:
:
gTheme
-
>
ThemeSupportsWidget
(
nullptr
this
disp
-
>
mAppearance
)
)
return
;
nsCOMPtr
<
nsIURI
>
oldURI
newURI
;
if
(
mImageRequest
)
mImageRequest
-
>
GetURI
(
getter_AddRefs
(
oldURI
)
)
;
if
(
myList
-
>
GetListStyleImage
(
)
)
myList
-
>
GetListStyleImage
(
)
-
>
GetURI
(
getter_AddRefs
(
newURI
)
)
;
bool
equal
;
if
(
newURI
=
=
oldURI
|
|
(
newURI
&
&
oldURI
&
&
NS_SUCCEEDED
(
newURI
-
>
Equals
(
oldURI
&
equal
)
)
&
&
equal
)
)
return
;
UpdateImage
(
)
;
}
void
nsImageBoxFrame
:
:
GetImageSize
(
)
{
if
(
mIntrinsicSize
.
width
>
0
&
&
mIntrinsicSize
.
height
>
0
)
{
mImageSize
.
width
=
mIntrinsicSize
.
width
;
mImageSize
.
height
=
mIntrinsicSize
.
height
;
}
else
{
mImageSize
.
width
=
0
;
mImageSize
.
height
=
0
;
}
}
nsSize
nsImageBoxFrame
:
:
GetXULPrefSize
(
nsBoxLayoutState
&
aState
)
{
nsSize
size
(
0
0
)
;
DISPLAY_PREF_SIZE
(
this
size
)
;
if
(
DoesNeedRecalc
(
mImageSize
)
)
GetImageSize
(
)
;
if
(
!
mUseSrcAttr
&
&
(
mSubRect
.
width
>
0
|
|
mSubRect
.
height
>
0
)
)
size
=
mSubRect
.
Size
(
)
;
else
size
=
mImageSize
;
nsSize
intrinsicSize
=
size
;
nsMargin
borderPadding
(
0
0
0
0
)
;
GetXULBorderAndPadding
(
borderPadding
)
;
size
.
width
+
=
borderPadding
.
LeftRight
(
)
;
size
.
height
+
=
borderPadding
.
TopBottom
(
)
;
bool
widthSet
heightSet
;
nsIFrame
:
:
AddXULPrefSize
(
this
size
widthSet
heightSet
)
;
NS_ASSERTION
(
size
.
width
!
=
NS_INTRINSICSIZE
&
&
size
.
height
!
=
NS_INTRINSICSIZE
"
non
-
intrinsic
size
expected
"
)
;
nsSize
minSize
=
GetXULMinSize
(
aState
)
;
nsSize
maxSize
=
GetXULMaxSize
(
aState
)
;
if
(
!
widthSet
&
&
!
heightSet
)
{
if
(
minSize
.
width
!
=
NS_INTRINSICSIZE
)
minSize
.
width
-
=
borderPadding
.
LeftRight
(
)
;
if
(
minSize
.
height
!
=
NS_INTRINSICSIZE
)
minSize
.
height
-
=
borderPadding
.
TopBottom
(
)
;
if
(
maxSize
.
width
!
=
NS_INTRINSICSIZE
)
maxSize
.
width
-
=
borderPadding
.
LeftRight
(
)
;
if
(
maxSize
.
height
!
=
NS_INTRINSICSIZE
)
maxSize
.
height
-
=
borderPadding
.
TopBottom
(
)
;
size
=
nsLayoutUtils
:
:
ComputeAutoSizeWithIntrinsicDimensions
(
minSize
.
width
minSize
.
height
maxSize
.
width
maxSize
.
height
intrinsicSize
.
width
intrinsicSize
.
height
)
;
NS_ASSERTION
(
size
.
width
!
=
NS_INTRINSICSIZE
&
&
size
.
height
!
=
NS_INTRINSICSIZE
"
non
-
intrinsic
size
expected
"
)
;
size
.
width
+
=
borderPadding
.
LeftRight
(
)
;
size
.
height
+
=
borderPadding
.
TopBottom
(
)
;
return
size
;
}
if
(
!
widthSet
)
{
if
(
intrinsicSize
.
height
>
0
)
{
nscoord
height
=
size
.
height
-
borderPadding
.
TopBottom
(
)
;
size
.
width
=
nscoord
(
int64_t
(
height
)
*
int64_t
(
intrinsicSize
.
width
)
/
int64_t
(
intrinsicSize
.
height
)
)
;
}
else
{
size
.
width
=
intrinsicSize
.
width
;
}
size
.
width
+
=
borderPadding
.
LeftRight
(
)
;
}
else
if
(
!
heightSet
)
{
if
(
intrinsicSize
.
width
>
0
)
{
nscoord
width
=
size
.
width
-
borderPadding
.
LeftRight
(
)
;
size
.
height
=
nscoord
(
int64_t
(
width
)
*
int64_t
(
intrinsicSize
.
height
)
/
int64_t
(
intrinsicSize
.
width
)
)
;
}
else
{
size
.
height
=
intrinsicSize
.
height
;
}
size
.
height
+
=
borderPadding
.
TopBottom
(
)
;
}
return
BoundsCheck
(
minSize
size
maxSize
)
;
}
nsSize
nsImageBoxFrame
:
:
GetXULMinSize
(
nsBoxLayoutState
&
aState
)
{
nsSize
size
(
0
0
)
;
DISPLAY_MIN_SIZE
(
this
size
)
;
AddBorderAndPadding
(
size
)
;
bool
widthSet
heightSet
;
nsIFrame
:
:
AddXULMinSize
(
aState
this
size
widthSet
heightSet
)
;
return
size
;
}
nscoord
nsImageBoxFrame
:
:
GetXULBoxAscent
(
nsBoxLayoutState
&
aState
)
{
return
GetXULPrefSize
(
aState
)
.
height
;
}
nsIAtom
*
nsImageBoxFrame
:
:
GetType
(
)
const
{
return
nsGkAtoms
:
:
imageBoxFrame
;
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
nsImageBoxFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
NS_LITERAL_STRING
(
"
ImageBox
"
)
aResult
)
;
}
#
endif
nsresult
nsImageBoxFrame
:
:
Notify
(
imgIRequest
*
aRequest
int32_t
aType
const
nsIntRect
*
aData
)
{
if
(
aType
=
=
imgINotificationObserver
:
:
SIZE_AVAILABLE
)
{
nsCOMPtr
<
imgIContainer
>
image
;
aRequest
-
>
GetImage
(
getter_AddRefs
(
image
)
)
;
return
OnSizeAvailable
(
aRequest
image
)
;
}
if
(
aType
=
=
imgINotificationObserver
:
:
DECODE_COMPLETE
)
{
return
OnDecodeComplete
(
aRequest
)
;
}
if
(
aType
=
=
imgINotificationObserver
:
:
LOAD_COMPLETE
)
{
uint32_t
imgStatus
;
aRequest
-
>
GetImageStatus
(
&
imgStatus
)
;
nsresult
status
=
imgStatus
&
imgIRequest
:
:
STATUS_ERROR
?
NS_ERROR_FAILURE
:
NS_OK
;
return
OnLoadComplete
(
aRequest
status
)
;
}
if
(
aType
=
=
imgINotificationObserver
:
:
IS_ANIMATED
)
{
return
OnImageIsAnimated
(
aRequest
)
;
}
if
(
aType
=
=
imgINotificationObserver
:
:
FRAME_UPDATE
)
{
return
OnFrameUpdate
(
aRequest
)
;
}
return
NS_OK
;
}
nsresult
nsImageBoxFrame
:
:
OnSizeAvailable
(
imgIRequest
*
aRequest
imgIContainer
*
aImage
)
{
NS_ENSURE_ARG_POINTER
(
aImage
)
;
aRequest
-
>
IncrementAnimationConsumers
(
)
;
nscoord
w
h
;
aImage
-
>
GetWidth
(
&
w
)
;
aImage
-
>
GetHeight
(
&
h
)
;
mIntrinsicSize
.
SizeTo
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
w
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
h
)
)
;
if
(
!
(
GetStateBits
(
)
&
NS_FRAME_FIRST_REFLOW
)
)
{
PresContext
(
)
-
>
PresShell
(
)
-
>
FrameNeedsReflow
(
this
nsIPresShell
:
:
eStyleChange
NS_FRAME_IS_DIRTY
)
;
}
return
NS_OK
;
}
nsresult
nsImageBoxFrame
:
:
OnDecodeComplete
(
imgIRequest
*
aRequest
)
{
nsBoxLayoutState
state
(
PresContext
(
)
)
;
this
-
>
XULRedraw
(
state
)
;
return
NS_OK
;
}
nsresult
nsImageBoxFrame
:
:
OnLoadComplete
(
imgIRequest
*
aRequest
nsresult
aStatus
)
{
if
(
NS_SUCCEEDED
(
aStatus
)
)
{
FireImageDOMEvent
(
mContent
eLoad
)
;
}
else
{
mIntrinsicSize
.
SizeTo
(
0
0
)
;
PresContext
(
)
-
>
PresShell
(
)
-
>
FrameNeedsReflow
(
this
nsIPresShell
:
:
eStyleChange
NS_FRAME_IS_DIRTY
)
;
FireImageDOMEvent
(
mContent
eLoadError
)
;
}
return
NS_OK
;
}
nsresult
nsImageBoxFrame
:
:
OnImageIsAnimated
(
imgIRequest
*
aRequest
)
{
nsLayoutUtils
:
:
RegisterImageRequest
(
PresContext
(
)
aRequest
&
mRequestRegistered
)
;
return
NS_OK
;
}
nsresult
nsImageBoxFrame
:
:
OnFrameUpdate
(
imgIRequest
*
aRequest
)
{
if
(
(
0
=
=
mRect
.
width
)
|
|
(
0
=
=
mRect
.
height
)
)
{
return
NS_OK
;
}
InvalidateLayer
(
nsDisplayItem
:
:
TYPE_XUL_IMAGE
)
;
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
nsImageBoxListener
imgINotificationObserver
imgIOnloadBlocker
)
nsImageBoxListener
:
:
nsImageBoxListener
(
)
{
}
nsImageBoxListener
:
:
~
nsImageBoxListener
(
)
{
}
NS_IMETHODIMP
nsImageBoxListener
:
:
Notify
(
imgIRequest
*
request
int32_t
aType
const
nsIntRect
*
aData
)
{
if
(
!
mFrame
)
return
NS_OK
;
return
mFrame
-
>
Notify
(
request
aType
aData
)
;
}
NS_IMETHODIMP
nsImageBoxListener
:
:
BlockOnload
(
imgIRequest
*
aRequest
)
{
if
(
mFrame
&
&
mFrame
-
>
GetContent
(
)
&
&
mFrame
-
>
GetContent
(
)
-
>
GetUncomposedDoc
(
)
)
{
mFrame
-
>
GetContent
(
)
-
>
GetUncomposedDoc
(
)
-
>
BlockOnload
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsImageBoxListener
:
:
UnblockOnload
(
imgIRequest
*
aRequest
)
{
if
(
mFrame
&
&
mFrame
-
>
GetContent
(
)
&
&
mFrame
-
>
GetContent
(
)
-
>
GetUncomposedDoc
(
)
)
{
mFrame
-
>
GetContent
(
)
-
>
GetUncomposedDoc
(
)
-
>
UnblockOnload
(
false
)
;
}
return
NS_OK
;
}
