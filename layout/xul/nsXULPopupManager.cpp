#
include
"
XULButtonElement
.
h
"
#
include
"
XULMenuParentElement
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
FlushType
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsISound
.
h
"
#
include
"
nsXULPopupManager
.
h
"
#
include
"
nsMenuPopupFrame
.
h
"
#
include
"
nsMenuBarFrame
.
h
"
#
include
"
nsMenuBarListener
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsXULElement
.
h
"
#
include
"
nsIDOMXULCommandDispatcher
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsIBaseWindow
.
h
"
#
include
"
nsCaret
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsPIWindowRoot
.
h
"
#
include
"
nsFrameManager
.
h
"
#
include
"
nsPresContextInlines
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
mozilla
/
AnimationUtils
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
HTMLSlotElement
.
h
"
#
include
"
mozilla
/
dom
/
KeyboardEvent
.
h
"
#
include
"
mozilla
/
dom
/
KeyboardEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
MouseEvent
.
h
"
#
include
"
mozilla
/
dom
/
UIEvent
.
h
"
#
include
"
mozilla
/
dom
/
UserActivation
.
h
"
#
include
"
mozilla
/
dom
/
PopupPositionedEvent
.
h
"
#
include
"
mozilla
/
dom
/
PopupPositionedEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
XULCommandEvent
.
h
"
#
include
"
mozilla
/
dom
/
XULMenuElement
.
h
"
#
include
"
mozilla
/
dom
/
XULPopupElement
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
Services
.
h
"
#
include
"
mozilla
/
StaticPrefs_ui
.
h
"
#
include
"
mozilla
/
widget
/
nsAutoRollup
.
h
"
#
include
"
mozilla
/
widget
/
NativeMenuSupport
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
mozilla
:
:
widget
:
:
NativeMenu
;
static_assert
(
KeyboardEvent_Binding
:
:
DOM_VK_HOME
=
=
KeyboardEvent_Binding
:
:
DOM_VK_END
+
1
&
&
KeyboardEvent_Binding
:
:
DOM_VK_LEFT
=
=
KeyboardEvent_Binding
:
:
DOM_VK_END
+
2
&
&
KeyboardEvent_Binding
:
:
DOM_VK_UP
=
=
KeyboardEvent_Binding
:
:
DOM_VK_END
+
3
&
&
KeyboardEvent_Binding
:
:
DOM_VK_RIGHT
=
=
KeyboardEvent_Binding
:
:
DOM_VK_END
+
4
&
&
KeyboardEvent_Binding
:
:
DOM_VK_DOWN
=
=
KeyboardEvent_Binding
:
:
DOM_VK_END
+
5
"
nsXULPopupManager
assumes
some
keyCode
values
are
consecutive
"
)
;
const
nsNavigationDirection
DirectionFromKeyCodeTable
[
2
]
[
6
]
=
{
{
eNavigationDirection_Last
eNavigationDirection_First
eNavigationDirection_Start
eNavigationDirection_Before
eNavigationDirection_End
eNavigationDirection_After
}
{
eNavigationDirection_Last
eNavigationDirection_First
eNavigationDirection_End
eNavigationDirection_Before
eNavigationDirection_Start
eNavigationDirection_After
}
}
;
nsXULPopupManager
*
nsXULPopupManager
:
:
sInstance
=
nullptr
;
PendingPopup
:
:
PendingPopup
(
nsIContent
*
aPopup
mozilla
:
:
dom
:
:
Event
*
aEvent
)
:
mPopup
(
aPopup
)
mEvent
(
aEvent
)
mModifiers
(
0
)
{
InitMousePoint
(
)
;
}
void
PendingPopup
:
:
InitMousePoint
(
)
{
if
(
!
mEvent
)
{
return
;
}
WidgetEvent
*
event
=
mEvent
-
>
WidgetEventPtr
(
)
;
WidgetInputEvent
*
inputEvent
=
event
-
>
AsInputEvent
(
)
;
if
(
inputEvent
)
{
mModifiers
=
inputEvent
-
>
mModifiers
;
}
Document
*
doc
=
mPopup
-
>
GetUncomposedDoc
(
)
;
if
(
!
doc
)
{
return
;
}
PresShell
*
presShell
=
doc
-
>
GetPresShell
(
)
;
nsPresContext
*
presContext
;
if
(
presShell
&
&
(
presContext
=
presShell
-
>
GetPresContext
(
)
)
)
{
nsPresContext
*
rootDocPresContext
=
presContext
-
>
GetRootPresContext
(
)
;
if
(
!
rootDocPresContext
)
{
return
;
}
nsIFrame
*
rootDocumentRootFrame
=
rootDocPresContext
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
;
if
(
(
event
-
>
mClass
=
=
eMouseEventClass
|
|
event
-
>
mClass
=
=
eMouseScrollEventClass
|
|
event
-
>
mClass
=
=
eWheelEventClass
)
&
&
!
event
-
>
AsGUIEvent
(
)
-
>
mWidget
)
{
MouseEvent
*
mouseEvent
=
mEvent
-
>
AsMouseEvent
(
)
;
nsIntPoint
clientPt
(
mouseEvent
-
>
ClientX
(
)
mouseEvent
-
>
ClientY
(
)
)
;
nsPoint
thisDocToRootDocOffset
=
presShell
-
>
GetRootFrame
(
)
-
>
GetOffsetToCrossDoc
(
rootDocumentRootFrame
)
;
mMousePoint
.
x
=
presContext
-
>
AppUnitsToDevPixels
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
clientPt
.
x
)
+
thisDocToRootDocOffset
.
x
)
;
mMousePoint
.
y
=
presContext
-
>
AppUnitsToDevPixels
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
clientPt
.
y
)
+
thisDocToRootDocOffset
.
y
)
;
}
else
if
(
rootDocumentRootFrame
)
{
nsPoint
pnt
=
nsLayoutUtils
:
:
GetEventCoordinatesRelativeTo
(
event
RelativeTo
{
rootDocumentRootFrame
}
)
;
mMousePoint
=
LayoutDeviceIntPoint
(
rootDocPresContext
-
>
AppUnitsToDevPixels
(
pnt
.
x
)
rootDocPresContext
-
>
AppUnitsToDevPixels
(
pnt
.
y
)
)
;
}
}
}
already_AddRefed
<
nsIContent
>
PendingPopup
:
:
GetTriggerContent
(
)
const
{
nsCOMPtr
<
nsIContent
>
target
=
do_QueryInterface
(
mEvent
?
mEvent
-
>
GetTarget
(
)
:
nullptr
)
;
return
target
.
forget
(
)
;
}
uint16_t
PendingPopup
:
:
MouseInputSource
(
)
const
{
if
(
mEvent
)
{
mozilla
:
:
WidgetMouseEventBase
*
mouseEvent
=
mEvent
-
>
WidgetEventPtr
(
)
-
>
AsMouseEventBase
(
)
;
if
(
mouseEvent
)
{
return
mouseEvent
-
>
mInputSource
;
}
RefPtr
<
XULCommandEvent
>
commandEvent
=
mEvent
-
>
AsXULCommandEvent
(
)
;
if
(
commandEvent
)
{
return
commandEvent
-
>
InputSource
(
)
;
}
}
return
MouseEvent_Binding
:
:
MOZ_SOURCE_UNKNOWN
;
}
nsIContent
*
nsMenuChainItem
:
:
Content
(
)
{
return
mFrame
-
>
GetContent
(
)
;
}
void
nsMenuChainItem
:
:
SetParent
(
UniquePtr
<
nsMenuChainItem
>
aParent
)
{
MOZ_ASSERT_IF
(
aParent
!
aParent
-
>
mChild
)
;
auto
oldParent
=
Detach
(
)
;
mParent
=
std
:
:
move
(
aParent
)
;
if
(
mParent
)
{
mParent
-
>
mChild
=
this
;
}
}
UniquePtr
<
nsMenuChainItem
>
nsMenuChainItem
:
:
Detach
(
)
{
if
(
mParent
)
{
MOZ_ASSERT
(
mParent
-
>
mChild
=
=
this
"
Unexpected
-
parent
'
s
child
not
set
to
this
"
)
;
mParent
-
>
mChild
=
nullptr
;
}
return
std
:
:
move
(
mParent
)
;
}
void
nsXULPopupManager
:
:
RemoveMenuChainItem
(
nsMenuChainItem
*
aItem
)
{
auto
parent
=
aItem
-
>
Detach
(
)
;
if
(
auto
*
child
=
aItem
-
>
GetChild
(
)
)
{
MOZ_ASSERT
(
aItem
!
=
mPopups
"
Unexpected
-
popup
with
child
at
end
of
chain
"
)
;
child
-
>
SetParent
(
std
:
:
move
(
parent
)
)
;
}
else
{
MOZ_ASSERT
(
aItem
=
=
mPopups
"
Unexpected
-
popup
with
no
child
not
at
end
of
chain
"
)
;
mPopups
=
std
:
:
move
(
parent
)
;
}
}
void
nsMenuChainItem
:
:
UpdateFollowAnchor
(
)
{
mFollowAnchor
=
mFrame
-
>
ShouldFollowAnchor
(
mCurrentRect
)
;
}
void
nsMenuChainItem
:
:
CheckForAnchorChange
(
)
{
if
(
mFollowAnchor
)
{
mFrame
-
>
CheckForAnchorChange
(
mCurrentRect
)
;
}
}
NS_IMPL_ISUPPORTS
(
nsXULPopupManager
nsIDOMEventListener
nsIObserver
)
nsXULPopupManager
:
:
nsXULPopupManager
(
)
:
mActiveMenuBar
(
nullptr
)
mPopups
(
nullptr
)
mPendingPopup
(
nullptr
)
{
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
AddObserver
(
this
"
xpcom
-
shutdown
"
false
)
;
}
}
nsXULPopupManager
:
:
~
nsXULPopupManager
(
)
{
NS_ASSERTION
(
!
mPopups
"
XUL
popups
still
open
"
)
;
if
(
mNativeMenu
)
{
mNativeMenu
-
>
RemoveObserver
(
this
)
;
}
}
nsresult
nsXULPopupManager
:
:
Init
(
)
{
sInstance
=
new
nsXULPopupManager
(
)
;
NS_ENSURE_TRUE
(
sInstance
NS_ERROR_OUT_OF_MEMORY
)
;
NS_ADDREF
(
sInstance
)
;
return
NS_OK
;
}
void
nsXULPopupManager
:
:
Shutdown
(
)
{
NS_IF_RELEASE
(
sInstance
)
;
}
NS_IMETHODIMP
nsXULPopupManager
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
!
nsCRT
:
:
strcmp
(
aTopic
"
xpcom
-
shutdown
"
)
)
{
if
(
mKeyListener
)
{
mKeyListener
-
>
RemoveEventListener
(
u
"
keypress
"
_ns
this
true
)
;
mKeyListener
-
>
RemoveEventListener
(
u
"
keydown
"
_ns
this
true
)
;
mKeyListener
-
>
RemoveEventListener
(
u
"
keyup
"
_ns
this
true
)
;
mKeyListener
=
nullptr
;
}
nsCOMPtr
<
nsIObserverService
>
obs
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
obs
)
{
obs
-
>
RemoveObserver
(
this
"
xpcom
-
shutdown
"
)
;
}
}
return
NS_OK
;
}
nsXULPopupManager
*
nsXULPopupManager
:
:
GetInstance
(
)
{
MOZ_ASSERT
(
sInstance
)
;
return
sInstance
;
}
bool
nsXULPopupManager
:
:
RollupTooltips
(
)
{
return
RollupInternal
(
RollupKind
:
:
Tooltip
{
}
nullptr
)
;
}
bool
nsXULPopupManager
:
:
Rollup
(
const
RollupOptions
&
aOptions
nsIContent
*
*
aLastRolledUp
)
{
return
RollupInternal
(
RollupKind
:
:
Menu
aOptions
aLastRolledUp
)
;
}
bool
nsXULPopupManager
:
:
RollupNativeMenu
(
)
{
if
(
mNativeMenu
)
{
RefPtr
<
NativeMenu
>
menu
=
mNativeMenu
;
return
menu
-
>
Close
(
)
;
}
return
false
;
}
bool
nsXULPopupManager
:
:
RollupInternal
(
RollupKind
aKind
const
RollupOptions
&
aOptions
nsIContent
*
*
aLastRolledUp
)
{
if
(
aLastRolledUp
)
{
*
aLastRolledUp
=
nullptr
;
}
if
(
StaticPrefs
:
:
ui_popup_disable_autohide
(
)
)
{
if
(
mWidget
)
{
mWidget
-
>
CaptureRollupEvents
(
false
)
;
}
return
false
;
}
nsMenuChainItem
*
item
=
GetRollupItem
(
aKind
)
;
if
(
!
item
)
{
return
false
;
}
if
(
aLastRolledUp
)
{
nsMenuChainItem
*
first
=
item
;
while
(
first
-
>
GetParent
(
)
)
{
nsMenuChainItem
*
parent
=
first
-
>
GetParent
(
)
;
if
(
first
-
>
Frame
(
)
-
>
GetPopupType
(
)
!
=
parent
-
>
Frame
(
)
-
>
GetPopupType
(
)
|
|
first
-
>
IsContextMenu
(
)
!
=
parent
-
>
IsContextMenu
(
)
)
{
break
;
}
first
=
parent
;
}
*
aLastRolledUp
=
first
-
>
Content
(
)
;
}
ConsumeOutsideClicksResult
consumeResult
=
item
-
>
Frame
(
)
-
>
ConsumeOutsideClicks
(
)
;
bool
consume
=
consumeResult
=
=
ConsumeOutsideClicks_True
;
bool
rollup
=
true
;
bool
noRollupOnAnchor
=
(
!
consume
&
&
aOptions
.
mPoint
&
&
item
-
>
Frame
(
)
-
>
GetContent
(
)
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
norolluponanchor
nsGkAtoms
:
:
_true
eCaseMatters
)
)
;
if
(
(
consumeResult
=
=
ConsumeOutsideClicks_ParentOnly
|
|
noRollupOnAnchor
)
&
&
aOptions
.
mPoint
)
{
nsMenuPopupFrame
*
popupFrame
=
item
-
>
Frame
(
)
;
CSSIntRect
anchorRect
=
[
&
]
{
if
(
popupFrame
-
>
IsAnchored
(
)
)
{
auto
r
=
popupFrame
-
>
GetScreenAnchorRect
(
)
;
if
(
r
.
x
!
=
-
1
&
&
r
.
y
!
=
-
1
)
{
return
r
;
}
}
auto
*
anchor
=
Element
:
:
FromNodeOrNull
(
popupFrame
-
>
GetAnchor
(
)
)
;
if
(
!
anchor
)
{
return
CSSIntRect
(
)
;
}
nsAutoString
consumeAnchor
;
anchor
-
>
GetAttr
(
nsGkAtoms
:
:
consumeanchor
consumeAnchor
)
;
if
(
!
consumeAnchor
.
IsEmpty
(
)
)
{
if
(
Element
*
newAnchor
=
anchor
-
>
OwnerDoc
(
)
-
>
GetElementById
(
consumeAnchor
)
)
{
anchor
=
newAnchor
;
}
}
nsIFrame
*
f
=
anchor
-
>
GetPrimaryFrame
(
)
;
if
(
!
f
)
{
return
CSSIntRect
(
)
;
}
return
f
-
>
GetScreenRect
(
)
;
}
(
)
;
nsPresContext
*
presContext
=
item
-
>
Frame
(
)
-
>
PresContext
(
)
;
CSSIntPoint
posCSSPixels
=
presContext
-
>
DevPixelsToIntCSSPixels
(
*
aOptions
.
mPoint
)
;
if
(
anchorRect
.
Contains
(
posCSSPixels
)
)
{
if
(
consumeResult
=
=
ConsumeOutsideClicks_ParentOnly
)
{
consume
=
true
;
}
if
(
noRollupOnAnchor
)
{
rollup
=
false
;
}
}
}
if
(
!
rollup
)
{
return
false
;
}
nsIContent
*
lastPopup
=
nullptr
;
uint32_t
count
=
aOptions
.
mCount
;
if
(
count
&
&
count
!
=
UINT32_MAX
)
{
nsMenuChainItem
*
last
=
item
;
while
(
-
-
count
&
&
last
-
>
GetParent
(
)
)
{
last
=
last
-
>
GetParent
(
)
;
}
if
(
last
)
{
lastPopup
=
last
-
>
Content
(
)
;
}
}
nsPresContext
*
presContext
=
item
-
>
Frame
(
)
-
>
PresContext
(
)
;
RefPtr
<
nsViewManager
>
viewManager
=
presContext
-
>
PresShell
(
)
-
>
GetViewManager
(
)
;
HidePopupOptions
options
{
HidePopupOption
:
:
HideChain
HidePopupOption
:
:
DeselectMenu
HidePopupOption
:
:
IsRollup
}
;
if
(
aOptions
.
mAllowAnimations
=
=
AllowAnimations
:
:
No
)
{
options
+
=
HidePopupOption
:
:
DisableAnimations
;
}
HidePopup
(
item
-
>
Content
(
)
options
lastPopup
)
;
if
(
aOptions
.
mFlush
=
=
FlushViews
:
:
Yes
)
{
viewManager
-
>
UpdateWidgetGeometry
(
)
;
}
return
consume
;
}
bool
nsXULPopupManager
:
:
ShouldRollupOnMouseWheelEvent
(
)
{
nsMenuChainItem
*
item
=
GetTopVisibleMenu
(
)
;
if
(
!
item
)
{
return
false
;
}
nsIContent
*
content
=
item
-
>
Frame
(
)
-
>
GetContent
(
)
;
if
(
!
content
|
|
!
content
-
>
IsElement
(
)
)
return
false
;
Element
*
element
=
content
-
>
AsElement
(
)
;
if
(
element
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
rolluponmousewheel
nsGkAtoms
:
:
_true
eCaseMatters
)
)
return
true
;
if
(
element
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
rolluponmousewheel
nsGkAtoms
:
:
_false
eCaseMatters
)
)
return
false
;
nsAutoString
value
;
element
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
type
value
)
;
return
StringBeginsWith
(
value
u
"
autocomplete
"
_ns
)
;
}
bool
nsXULPopupManager
:
:
ShouldConsumeOnMouseWheelEvent
(
)
{
nsMenuChainItem
*
item
=
GetTopVisibleMenu
(
)
;
if
(
!
item
)
{
return
false
;
}
nsMenuPopupFrame
*
frame
=
item
-
>
Frame
(
)
;
if
(
frame
-
>
GetPopupType
(
)
!
=
PopupType
:
:
Panel
)
return
true
;
return
!
frame
-
>
GetContent
(
)
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
type
nsGkAtoms
:
:
arrow
eCaseMatters
)
;
}
bool
nsXULPopupManager
:
:
ShouldRollupOnMouseActivate
(
)
{
return
false
;
}
uint32_t
nsXULPopupManager
:
:
GetSubmenuWidgetChain
(
nsTArray
<
nsIWidget
*
>
*
aWidgetChain
)
{
uint32_t
count
=
0
sameTypeCount
=
0
;
NS_ASSERTION
(
aWidgetChain
"
null
parameter
"
)
;
nsMenuChainItem
*
item
=
GetTopVisibleMenu
(
)
;
while
(
item
)
{
nsMenuChainItem
*
parent
=
item
-
>
GetParent
(
)
;
if
(
!
item
-
>
IsNoAutoHide
(
)
)
{
nsCOMPtr
<
nsIWidget
>
widget
=
item
-
>
Frame
(
)
-
>
GetWidget
(
)
;
NS_ASSERTION
(
widget
"
open
popup
has
no
widget
"
)
;
if
(
widget
)
{
aWidgetChain
-
>
AppendElement
(
widget
.
get
(
)
)
;
if
(
!
sameTypeCount
)
{
count
+
+
;
if
(
!
parent
|
|
item
-
>
Frame
(
)
-
>
GetPopupType
(
)
!
=
parent
-
>
Frame
(
)
-
>
GetPopupType
(
)
|
|
item
-
>
IsContextMenu
(
)
!
=
parent
-
>
IsContextMenu
(
)
)
{
sameTypeCount
=
count
;
}
}
}
}
item
=
parent
;
}
return
sameTypeCount
;
}
nsIWidget
*
nsXULPopupManager
:
:
GetRollupWidget
(
)
{
nsMenuChainItem
*
item
=
GetTopVisibleMenu
(
)
;
return
item
?
item
-
>
Frame
(
)
-
>
GetWidget
(
)
:
nullptr
;
}
void
nsXULPopupManager
:
:
AdjustPopupsOnWindowChange
(
nsPIDOMWindowOuter
*
aWindow
)
{
nsTArray
<
nsMenuPopupFrame
*
>
list
;
for
(
nsMenuChainItem
*
item
=
mPopups
.
get
(
)
;
item
;
item
=
item
-
>
GetParent
(
)
)
{
if
(
!
item
-
>
IsNoAutoHide
(
)
)
{
continue
;
}
nsMenuPopupFrame
*
frame
=
item
-
>
Frame
(
)
;
nsIContent
*
popup
=
frame
-
>
GetContent
(
)
;
if
(
!
popup
)
{
continue
;
}
Document
*
document
=
popup
-
>
GetUncomposedDoc
(
)
;
if
(
!
document
)
{
continue
;
}
nsPIDOMWindowOuter
*
window
=
document
-
>
GetWindow
(
)
;
if
(
!
window
)
{
continue
;
}
window
=
window
-
>
GetPrivateRoot
(
)
;
if
(
window
=
=
aWindow
)
{
list
.
AppendElement
(
frame
)
;
}
}
for
(
int32_t
l
=
list
.
Length
(
)
-
1
;
l
>
=
0
;
l
-
-
)
{
list
[
l
]
-
>
SetPopupPosition
(
true
)
;
}
}
void
nsXULPopupManager
:
:
AdjustPopupsOnWindowChange
(
PresShell
*
aPresShell
)
{
if
(
aPresShell
-
>
GetDocument
(
)
)
{
AdjustPopupsOnWindowChange
(
aPresShell
-
>
GetDocument
(
)
-
>
GetWindow
(
)
)
;
}
}
static
nsMenuPopupFrame
*
GetPopupToMoveOrResize
(
nsIFrame
*
aFrame
)
{
nsMenuPopupFrame
*
menuPopupFrame
=
do_QueryFrame
(
aFrame
)
;
if
(
!
menuPopupFrame
)
return
nullptr
;
if
(
!
menuPopupFrame
-
>
IsVisible
(
)
)
return
nullptr
;
nsIWidget
*
widget
=
menuPopupFrame
-
>
GetWidget
(
)
;
if
(
widget
&
&
!
widget
-
>
IsVisible
(
)
)
return
nullptr
;
return
menuPopupFrame
;
}
void
nsXULPopupManager
:
:
PopupMoved
(
nsIFrame
*
aFrame
const
LayoutDeviceIntPoint
&
aPoint
bool
aByMoveToRect
)
{
nsMenuPopupFrame
*
menuPopupFrame
=
GetPopupToMoveOrResize
(
aFrame
)
;
if
(
!
menuPopupFrame
)
{
return
;
}
nsView
*
view
=
menuPopupFrame
-
>
GetView
(
)
;
if
(
!
view
)
{
return
;
}
menuPopupFrame
-
>
WidgetPositionOrSizeDidChange
(
)
;
LayoutDeviceIntRect
curDevBounds
=
view
-
>
RecalcWidgetBounds
(
)
;
nsIWidget
*
widget
=
menuPopupFrame
-
>
GetWidget
(
)
;
if
(
curDevBounds
.
TopLeft
(
)
=
=
aPoint
&
&
(
!
widget
|
|
widget
-
>
GetClientOffset
(
)
=
=
menuPopupFrame
-
>
GetLastClientOffset
(
)
)
)
{
return
;
}
if
(
menuPopupFrame
-
>
IsAnchored
(
)
&
&
menuPopupFrame
-
>
GetPopupLevel
(
)
=
=
widget
:
:
PopupLevel
:
:
Parent
&
&
!
aByMoveToRect
)
{
menuPopupFrame
-
>
SetPopupPosition
(
true
)
;
}
else
{
CSSPoint
cssPos
=
aPoint
/
menuPopupFrame
-
>
PresContext
(
)
-
>
CSSToDevPixelScale
(
)
;
menuPopupFrame
-
>
MoveTo
(
cssPos
false
aByMoveToRect
)
;
}
}
void
nsXULPopupManager
:
:
PopupResized
(
nsIFrame
*
aFrame
const
LayoutDeviceIntSize
&
aSize
)
{
nsMenuPopupFrame
*
menuPopupFrame
=
GetPopupToMoveOrResize
(
aFrame
)
;
if
(
!
menuPopupFrame
)
{
return
;
}
menuPopupFrame
-
>
WidgetPositionOrSizeDidChange
(
)
;
nsView
*
view
=
menuPopupFrame
-
>
GetView
(
)
;
if
(
!
view
)
{
return
;
}
const
LayoutDeviceIntRect
curDevBounds
=
view
-
>
RecalcWidgetBounds
(
)
;
if
(
curDevBounds
.
Size
(
)
=
=
aSize
)
{
return
;
}
Element
*
popup
=
menuPopupFrame
-
>
GetContent
(
)
-
>
AsElement
(
)
;
if
(
!
popup
-
>
HasAttr
(
nsGkAtoms
:
:
width
)
|
|
!
popup
-
>
HasAttr
(
nsGkAtoms
:
:
height
)
)
{
return
;
}
nsPresContext
*
presContext
=
menuPopupFrame
-
>
PresContext
(
)
;
CSSIntSize
newCSS
(
presContext
-
>
DevPixelsToIntCSSPixels
(
aSize
.
width
)
presContext
-
>
DevPixelsToIntCSSPixels
(
aSize
.
height
)
)
;
nsAutoString
width
height
;
width
.
AppendInt
(
newCSS
.
width
)
;
height
.
AppendInt
(
newCSS
.
height
)
;
popup
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
width
width
false
)
;
popup
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
height
height
true
)
;
}
nsMenuPopupFrame
*
nsXULPopupManager
:
:
GetPopupFrameForContent
(
nsIContent
*
aContent
bool
aShouldFlush
)
{
if
(
aShouldFlush
)
{
Document
*
document
=
aContent
-
>
GetUncomposedDoc
(
)
;
if
(
document
)
{
if
(
RefPtr
<
PresShell
>
presShell
=
document
-
>
GetPresShell
(
)
)
{
presShell
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
}
}
}
return
do_QueryFrame
(
aContent
-
>
GetPrimaryFrame
(
)
)
;
}
nsMenuChainItem
*
nsXULPopupManager
:
:
GetRollupItem
(
RollupKind
aKind
)
{
for
(
nsMenuChainItem
*
item
=
mPopups
.
get
(
)
;
item
;
item
=
item
-
>
GetParent
(
)
)
{
if
(
item
-
>
Frame
(
)
-
>
PopupState
(
)
=
=
ePopupInvisible
)
{
continue
;
}
MOZ_ASSERT_IF
(
item
-
>
Frame
(
)
-
>
GetPopupType
(
)
=
=
PopupType
:
:
Tooltip
item
-
>
IsNoAutoHide
(
)
)
;
const
bool
valid
=
aKind
=
=
RollupKind
:
:
Tooltip
?
item
-
>
Frame
(
)
-
>
GetPopupType
(
)
=
=
PopupType
:
:
Tooltip
:
!
item
-
>
IsNoAutoHide
(
)
;
if
(
valid
)
{
return
item
;
}
}
return
nullptr
;
}
void
nsXULPopupManager
:
:
SetActiveMenuBar
(
nsMenuBarFrame
*
aMenuBar
bool
aActivate
)
{
if
(
aActivate
)
{
mActiveMenuBar
=
aMenuBar
;
}
else
if
(
mActiveMenuBar
=
=
aMenuBar
)
{
mActiveMenuBar
=
nullptr
;
}
UpdateKeyboardListeners
(
)
;
}
static
CloseMenuMode
GetCloseMenuMode
(
nsIContent
*
aMenu
)
{
if
(
!
aMenu
-
>
IsElement
(
)
)
{
return
CloseMenuMode_Auto
;
}
static
Element
:
:
AttrValuesArray
strings
[
]
=
{
nsGkAtoms
:
:
none
nsGkAtoms
:
:
single
nullptr
}
;
switch
(
aMenu
-
>
AsElement
(
)
-
>
FindAttrValueIn
(
kNameSpaceID_None
nsGkAtoms
:
:
closemenu
strings
eCaseMatters
)
)
{
case
0
:
return
CloseMenuMode_None
;
case
1
:
return
CloseMenuMode_Single
;
default
:
return
CloseMenuMode_Auto
;
}
}
auto
nsXULPopupManager
:
:
MayShowMenu
(
nsIContent
*
aMenu
)
-
>
MayShowMenuResult
{
if
(
mNativeMenu
&
&
aMenu
-
>
IsElement
(
)
&
&
mNativeMenu
-
>
Element
(
)
-
>
Contains
(
aMenu
)
)
{
return
{
true
}
;
}
auto
*
menu
=
XULButtonElement
:
:
FromNode
(
aMenu
)
;
if
(
!
menu
)
{
return
{
}
;
}
nsMenuPopupFrame
*
popupFrame
=
menu
-
>
GetMenuPopup
(
FlushType
:
:
None
)
;
if
(
!
popupFrame
|
|
!
MayShowPopup
(
popupFrame
)
)
{
return
{
}
;
}
return
{
false
menu
popupFrame
}
;
}
void
nsXULPopupManager
:
:
ShowMenu
(
nsIContent
*
aMenu
bool
aSelectFirstItem
)
{
auto
mayShowResult
=
MayShowMenu
(
aMenu
)
;
if
(
NS_WARN_IF
(
!
mayShowResult
)
)
{
return
;
}
if
(
mayShowResult
.
mIsNative
)
{
mNativeMenu
-
>
OpenSubmenu
(
aMenu
-
>
AsElement
(
)
)
;
return
;
}
nsMenuPopupFrame
*
popupFrame
=
mayShowResult
.
mMenuPopupFrame
;
const
bool
onMenuBar
=
mayShowResult
.
mMenuButton
-
>
IsOnMenuBar
(
)
;
const
bool
onmenu
=
mayShowResult
.
mMenuButton
-
>
IsOnMenu
(
)
;
const
bool
parentIsContextMenu
=
mayShowResult
.
mMenuButton
-
>
IsOnContextMenu
(
)
;
nsAutoString
position
;
#
ifdef
XP_MACOSX
if
(
aMenu
-
>
IsXULElement
(
nsGkAtoms
:
:
menulist
)
)
{
position
.
AssignLiteral
(
"
selection
"
)
;
}
else
#
endif
if
(
onMenuBar
|
|
!
onmenu
)
position
.
AssignLiteral
(
"
after_start
"
)
;
else
position
.
AssignLiteral
(
"
end_before
"
)
;
popupFrame
-
>
InitializePopup
(
aMenu
nullptr
position
0
0
MenuPopupAnchorType_Node
true
)
;
PendingPopup
pendingPopup
(
popupFrame
-
>
GetContent
(
)
nullptr
)
;
BeginShowingPopup
(
pendingPopup
parentIsContextMenu
aSelectFirstItem
)
;
}
void
nsXULPopupManager
:
:
ShowPopup
(
nsIContent
*
aPopup
nsIContent
*
aAnchorContent
const
nsAString
&
aPosition
int32_t
aXPos
int32_t
aYPos
bool
aIsContextMenu
bool
aAttributesOverride
bool
aSelectFirstItem
Event
*
aTriggerEvent
)
{
nsMenuPopupFrame
*
popupFrame
=
GetPopupFrameForContent
(
aPopup
true
)
;
if
(
!
popupFrame
|
|
!
MayShowPopup
(
popupFrame
)
)
{
return
;
}
PendingPopup
pendingPopup
(
aPopup
aTriggerEvent
)
;
nsCOMPtr
<
nsIContent
>
triggerContent
=
pendingPopup
.
GetTriggerContent
(
)
;
popupFrame
-
>
InitializePopup
(
aAnchorContent
triggerContent
aPosition
aXPos
aYPos
MenuPopupAnchorType_Node
aAttributesOverride
)
;
BeginShowingPopup
(
pendingPopup
aIsContextMenu
aSelectFirstItem
)
;
}
static
bool
ShouldUseNativeContextMenus
(
)
{
#
ifdef
HAS_NATIVE_MENU_SUPPORT
return
mozilla
:
:
widget
:
:
NativeMenuSupport
:
:
ShouldUseNativeContextMenus
(
)
;
#
else
return
false
;
#
endif
}
void
nsXULPopupManager
:
:
ShowPopupAtScreen
(
nsIContent
*
aPopup
int32_t
aXPos
int32_t
aYPos
bool
aIsContextMenu
Event
*
aTriggerEvent
)
{
if
(
aIsContextMenu
&
&
ShouldUseNativeContextMenus
(
)
&
&
ShowPopupAsNativeMenu
(
aPopup
aXPos
aYPos
aIsContextMenu
aTriggerEvent
)
)
{
return
;
}
nsMenuPopupFrame
*
popupFrame
=
GetPopupFrameForContent
(
aPopup
true
)
;
if
(
!
popupFrame
|
|
!
MayShowPopup
(
popupFrame
)
)
return
;
PendingPopup
pendingPopup
(
aPopup
aTriggerEvent
)
;
nsCOMPtr
<
nsIContent
>
triggerContent
=
pendingPopup
.
GetTriggerContent
(
)
;
popupFrame
-
>
InitializePopupAtScreen
(
triggerContent
aXPos
aYPos
aIsContextMenu
)
;
BeginShowingPopup
(
pendingPopup
aIsContextMenu
false
)
;
}
bool
nsXULPopupManager
:
:
ShowPopupAsNativeMenu
(
nsIContent
*
aPopup
int32_t
aXPos
int32_t
aYPos
bool
aIsContextMenu
Event
*
aTriggerEvent
)
{
if
(
mNativeMenu
)
{
NS_WARNING
(
"
Native
menu
still
open
when
trying
to
open
another
"
)
;
RefPtr
<
NativeMenu
>
menu
=
mNativeMenu
;
(
void
)
menu
-
>
Close
(
)
;
menu
-
>
RemoveObserver
(
this
)
;
mNativeMenu
=
nullptr
;
}
RefPtr
<
NativeMenu
>
menu
;
#
ifdef
HAS_NATIVE_MENU_SUPPORT
if
(
aPopup
-
>
IsElement
(
)
)
{
menu
=
mozilla
:
:
widget
:
:
NativeMenuSupport
:
:
CreateNativeContextMenu
(
aPopup
-
>
AsElement
(
)
)
;
}
#
endif
if
(
!
menu
)
{
return
false
;
}
nsMenuPopupFrame
*
popupFrame
=
GetPopupFrameForContent
(
aPopup
true
)
;
if
(
!
popupFrame
)
{
return
true
;
}
aPopup
-
>
AsElement
(
)
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
aria_hidden
u
"
true
"
_ns
true
)
;
PendingPopup
pendingPopup
(
aPopup
aTriggerEvent
)
;
nsCOMPtr
<
nsIContent
>
triggerContent
=
pendingPopup
.
GetTriggerContent
(
)
;
popupFrame
-
>
InitializePopupAsNativeContextMenu
(
triggerContent
aXPos
aYPos
)
;
RefPtr
<
nsPresContext
>
presContext
=
popupFrame
-
>
PresContext
(
)
;
nsEventStatus
status
=
FirePopupShowingEvent
(
pendingPopup
presContext
)
;
if
(
status
=
=
nsEventStatus_eConsumeNoDefault
)
{
if
(
nsMenuPopupFrame
*
popupFrame
=
GetPopupFrameForContent
(
aPopup
true
)
)
{
popupFrame
-
>
SetPopupState
(
ePopupClosed
)
;
popupFrame
-
>
ClearTriggerContent
(
)
;
}
return
true
;
}
mNativeMenu
=
menu
;
mNativeMenu
-
>
AddObserver
(
this
)
;
mNativeMenu
-
>
ShowAsContextMenu
(
presContext
CSSIntPoint
(
aXPos
aYPos
)
)
;
EventStateManager
*
activeESM
=
static_cast
<
EventStateManager
*
>
(
EventStateManager
:
:
GetActiveEventStateManager
(
)
)
;
if
(
activeESM
)
{
EventStateManager
:
:
ClearGlobalActiveContent
(
activeESM
)
;
activeESM
-
>
StopTrackingDragGesture
(
true
)
;
}
PresShell
:
:
ReleaseCapturingContent
(
)
;
return
true
;
}
void
nsXULPopupManager
:
:
OnNativeMenuOpened
(
)
{
if
(
!
mNativeMenu
)
{
return
;
}
RefPtr
<
nsXULPopupManager
>
kungFuDeathGrip
(
this
)
;
nsCOMPtr
<
nsIContent
>
popup
=
mNativeMenu
-
>
Element
(
)
;
nsMenuPopupFrame
*
popupFrame
=
GetPopupFrameForContent
(
popup
true
)
;
if
(
popupFrame
)
{
popupFrame
-
>
SetPopupState
(
ePopupShown
)
;
}
}
void
nsXULPopupManager
:
:
OnNativeMenuClosed
(
)
{
if
(
!
mNativeMenu
)
{
return
;
}
RefPtr
<
nsXULPopupManager
>
kungFuDeathGrip
(
this
)
;
bool
shouldHideChain
=
mNativeMenuActivatedItemCloseMenuMode
=
=
Some
(
CloseMenuMode_Auto
)
;
nsCOMPtr
<
nsIContent
>
popup
=
mNativeMenu
-
>
Element
(
)
;
nsMenuPopupFrame
*
popupFrame
=
GetPopupFrameForContent
(
popup
true
)
;
if
(
popupFrame
)
{
popupFrame
-
>
ClearTriggerContentIncludingDocument
(
)
;
popupFrame
-
>
SetPopupState
(
ePopupClosed
)
;
}
mNativeMenu
-
>
RemoveObserver
(
this
)
;
mNativeMenu
=
nullptr
;
mNativeMenuActivatedItemCloseMenuMode
=
Nothing
(
)
;
mNativeMenuSubmenuStates
.
Clear
(
)
;
popup
-
>
AsElement
(
)
-
>
UnsetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
aria_hidden
true
)
;
if
(
shouldHideChain
&
&
mPopups
&
&
mPopups
-
>
GetPopupType
(
)
=
=
PopupType
:
:
Menu
)
{
HidePopup
(
mPopups
-
>
Content
(
)
{
HidePopupOption
:
:
HideChain
}
)
;
}
}
void
nsXULPopupManager
:
:
OnNativeSubMenuWillOpen
(
mozilla
:
:
dom
:
:
Element
*
aPopupElement
)
{
mNativeMenuSubmenuStates
.
InsertOrUpdate
(
aPopupElement
ePopupShowing
)
;
}
void
nsXULPopupManager
:
:
OnNativeSubMenuDidOpen
(
mozilla
:
:
dom
:
:
Element
*
aPopupElement
)
{
mNativeMenuSubmenuStates
.
InsertOrUpdate
(
aPopupElement
ePopupShown
)
;
}
void
nsXULPopupManager
:
:
OnNativeSubMenuClosed
(
mozilla
:
:
dom
:
:
Element
*
aPopupElement
)
{
mNativeMenuSubmenuStates
.
Remove
(
aPopupElement
)
;
}
void
nsXULPopupManager
:
:
OnNativeMenuWillActivateItem
(
mozilla
:
:
dom
:
:
Element
*
aMenuItemElement
)
{
if
(
!
mNativeMenu
)
{
return
;
}
CloseMenuMode
cmm
=
GetCloseMenuMode
(
aMenuItemElement
)
;
mNativeMenuActivatedItemCloseMenuMode
=
Some
(
cmm
)
;
if
(
cmm
=
=
CloseMenuMode_Auto
)
{
HideOpenMenusBeforeExecutingMenu
(
CloseMenuMode_Auto
)
;
}
}
void
nsXULPopupManager
:
:
ShowPopupAtScreenRect
(
nsIContent
*
aPopup
const
nsAString
&
aPosition
const
nsIntRect
&
aRect
bool
aIsContextMenu
bool
aAttributesOverride
Event
*
aTriggerEvent
)
{
nsMenuPopupFrame
*
popupFrame
=
GetPopupFrameForContent
(
aPopup
true
)
;
if
(
!
popupFrame
|
|
!
MayShowPopup
(
popupFrame
)
)
return
;
PendingPopup
pendingPopup
(
aPopup
aTriggerEvent
)
;
nsCOMPtr
<
nsIContent
>
triggerContent
=
pendingPopup
.
GetTriggerContent
(
)
;
popupFrame
-
>
InitializePopupAtRect
(
triggerContent
aPosition
aRect
aAttributesOverride
)
;
BeginShowingPopup
(
pendingPopup
aIsContextMenu
false
)
;
}
void
nsXULPopupManager
:
:
ShowTooltipAtScreen
(
nsIContent
*
aPopup
nsIContent
*
aTriggerContent
const
LayoutDeviceIntPoint
&
aScreenPoint
)
{
nsMenuPopupFrame
*
popupFrame
=
GetPopupFrameForContent
(
aPopup
true
)
;
if
(
!
popupFrame
|
|
!
MayShowPopup
(
popupFrame
)
)
{
return
;
}
PendingPopup
pendingPopup
(
aPopup
nullptr
)
;
nsPresContext
*
pc
=
popupFrame
-
>
PresContext
(
)
;
pendingPopup
.
SetMousePoint
(
[
&
]
{
if
(
nsPresContext
*
rootPresContext
=
pc
-
>
GetRootPresContext
(
)
)
{
if
(
nsCOMPtr
<
nsIWidget
>
rootWidget
=
rootPresContext
-
>
GetRootWidget
(
)
)
{
return
aScreenPoint
-
rootWidget
-
>
WidgetToScreenOffset
(
)
;
}
}
return
aScreenPoint
;
}
(
)
)
;
auto
screenCSSPoint
=
CSSIntPoint
:
:
Round
(
aScreenPoint
/
pc
-
>
CSSToDevPixelScale
(
)
)
;
popupFrame
-
>
InitializePopupAtScreen
(
aTriggerContent
screenCSSPoint
.
x
screenCSSPoint
.
y
false
)
;
BeginShowingPopup
(
pendingPopup
false
false
)
;
}
static
void
CheckCaretDrawingState
(
)
{
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
fm
)
{
nsCOMPtr
<
mozIDOMWindowProxy
>
window
;
fm
-
>
GetFocusedWindow
(
getter_AddRefs
(
window
)
)
;
if
(
!
window
)
return
;
auto
*
piWindow
=
nsPIDOMWindowOuter
:
:
From
(
window
)
;
MOZ_ASSERT
(
piWindow
)
;
nsCOMPtr
<
Document
>
focusedDoc
=
piWindow
-
>
GetDoc
(
)
;
if
(
!
focusedDoc
)
return
;
PresShell
*
presShell
=
focusedDoc
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
;
}
RefPtr
<
nsCaret
>
caret
=
presShell
-
>
GetCaret
(
)
;
if
(
!
caret
)
return
;
caret
-
>
SchedulePaint
(
)
;
}
}
void
nsXULPopupManager
:
:
ShowPopupCallback
(
nsIContent
*
aPopup
nsMenuPopupFrame
*
aPopupFrame
bool
aIsContextMenu
bool
aSelectFirstItem
)
{
PopupType
popupType
=
aPopupFrame
-
>
GetPopupType
(
)
;
const
bool
isMenu
=
popupType
=
=
PopupType
:
:
Menu
;
bool
isNoAutoHide
=
aPopupFrame
-
>
IsNoAutoHide
(
)
|
|
popupType
=
=
PopupType
:
:
Tooltip
;
auto
item
=
MakeUnique
<
nsMenuChainItem
>
(
aPopupFrame
isNoAutoHide
aIsContextMenu
popupType
)
;
nsAutoString
ignorekeys
;
if
(
aPopup
-
>
IsElement
(
)
)
{
aPopup
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
ignorekeys
ignorekeys
)
;
}
if
(
ignorekeys
.
EqualsLiteral
(
"
true
"
)
)
{
item
-
>
SetIgnoreKeys
(
eIgnoreKeys_True
)
;
}
else
if
(
ignorekeys
.
EqualsLiteral
(
"
shortcuts
"
)
)
{
item
-
>
SetIgnoreKeys
(
eIgnoreKeys_Shortcuts
)
;
}
if
(
isMenu
)
{
if
(
auto
*
menu
=
aPopupFrame
-
>
PopupElement
(
)
.
GetContainingMenu
(
)
)
{
item
-
>
SetOnMenuBar
(
menu
-
>
IsOnMenuBar
(
)
)
;
}
}
AutoWeakFrame
weakFrame
(
aPopupFrame
)
;
aPopupFrame
-
>
ShowPopup
(
aIsContextMenu
)
;
NS_ENSURE_TRUE_VOID
(
weakFrame
.
IsAlive
(
)
)
;
item
-
>
UpdateFollowAnchor
(
)
;
nsIContent
*
oldmenu
=
nullptr
;
if
(
mPopups
)
{
oldmenu
=
mPopups
-
>
Content
(
)
;
}
item
-
>
SetParent
(
std
:
:
move
(
mPopups
)
)
;
mPopups
=
std
:
:
move
(
item
)
;
SetCaptureState
(
oldmenu
)
;
NS_ENSURE_TRUE_VOID
(
weakFrame
.
IsAlive
(
)
)
;
RefPtr
popup
=
&
aPopupFrame
-
>
PopupElement
(
)
;
popup
-
>
PopupOpened
(
aSelectFirstItem
)
;
if
(
isMenu
)
{
UpdateMenuItems
(
aPopup
)
;
}
CheckCaretDrawingState
(
)
;
}
nsMenuChainItem
*
nsXULPopupManager
:
:
FindPopup
(
nsIContent
*
aPopup
)
const
{
for
(
nsMenuChainItem
*
item
=
mPopups
.
get
(
)
;
item
;
item
=
item
-
>
GetParent
(
)
)
{
if
(
item
-
>
Frame
(
)
-
>
GetContent
(
)
=
=
aPopup
)
{
return
item
;
}
}
return
nullptr
;
}
void
nsXULPopupManager
:
:
HidePopup
(
nsIContent
*
aPopup
HidePopupOptions
aOptions
nsIContent
*
aLastPopup
)
{
if
(
mNativeMenu
&
&
mNativeMenu
-
>
Element
(
)
=
=
aPopup
)
{
RefPtr
<
NativeMenu
>
menu
=
mNativeMenu
;
(
void
)
menu
-
>
Close
(
)
;
return
;
}
nsMenuPopupFrame
*
popupFrame
=
do_QueryFrame
(
aPopup
-
>
GetPrimaryFrame
(
)
)
;
if
(
!
popupFrame
)
{
return
;
}
nsMenuChainItem
*
foundPopup
=
FindPopup
(
aPopup
)
;
nsCOMPtr
<
nsIContent
>
popupToHide
nextPopup
lastPopup
;
if
(
foundPopup
)
{
if
(
foundPopup
-
>
IsNoAutoHide
(
)
)
{
popupToHide
=
aPopup
;
aOptions
-
=
HidePopupOption
:
:
DeselectMenu
;
}
else
{
nsMenuChainItem
*
topMenu
=
foundPopup
;
if
(
foundPopup
-
>
IsMenu
(
)
)
{
nsMenuChainItem
*
child
=
foundPopup
-
>
GetChild
(
)
;
while
(
child
&
&
child
-
>
IsMenu
(
)
)
{
topMenu
=
child
;
child
=
child
-
>
GetChild
(
)
;
}
}
popupToHide
=
topMenu
-
>
Content
(
)
;
popupFrame
=
topMenu
-
>
Frame
(
)
;
const
bool
hideChain
=
aOptions
.
contains
(
HidePopupOption
:
:
HideChain
)
;
nsMenuChainItem
*
parent
=
topMenu
-
>
GetParent
(
)
;
if
(
parent
&
&
(
hideChain
|
|
topMenu
!
=
foundPopup
)
)
{
while
(
parent
&
&
parent
-
>
IsNoAutoHide
(
)
)
{
parent
=
parent
-
>
GetParent
(
)
;
}
if
(
parent
)
{
nextPopup
=
parent
-
>
Content
(
)
;
}
}
lastPopup
=
aLastPopup
?
aLastPopup
:
(
hideChain
?
nullptr
:
aPopup
)
;
}
}
else
if
(
popupFrame
-
>
PopupState
(
)
=
=
ePopupPositioning
)
{
popupToHide
=
aPopup
;
}
if
(
!
popupToHide
)
{
return
;
}
nsPopupState
state
=
popupFrame
-
>
PopupState
(
)
;
if
(
state
=
=
ePopupHiding
)
{
return
;
}
if
(
state
!
=
ePopupInvisible
)
{
popupFrame
-
>
SetPopupState
(
ePopupHiding
)
;
}
if
(
aOptions
.
contains
(
HidePopupOption
:
:
Async
)
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
new
nsXULPopupHidingEvent
(
popupToHide
nextPopup
lastPopup
popupFrame
-
>
GetPopupType
(
)
aOptions
)
;
aPopup
-
>
OwnerDoc
(
)
-
>
Dispatch
(
TaskCategory
:
:
Other
event
.
forget
(
)
)
;
}
else
{
RefPtr
<
nsPresContext
>
presContext
=
popupFrame
-
>
PresContext
(
)
;
FirePopupHidingEvent
(
popupToHide
nextPopup
lastPopup
presContext
popupFrame
-
>
GetPopupType
(
)
aOptions
)
;
}
}
void
nsXULPopupManager
:
:
HideMenu
(
nsIContent
*
aMenu
)
{
if
(
mNativeMenu
&
&
aMenu
-
>
IsElement
(
)
&
&
mNativeMenu
-
>
Element
(
)
-
>
Contains
(
aMenu
)
)
{
mNativeMenu
-
>
CloseSubmenu
(
aMenu
-
>
AsElement
(
)
)
;
return
;
}
auto
*
button
=
XULButtonElement
:
:
FromNode
(
aMenu
)
;
if
(
!
button
|
|
!
button
-
>
IsMenu
(
)
)
{
return
;
}
auto
*
popup
=
button
-
>
GetMenuPopupContent
(
)
;
if
(
!
popup
)
{
return
;
}
HidePopup
(
popup
{
HidePopupOption
:
:
DeselectMenu
}
)
;
}
class
TransitionEnder
final
:
public
nsIDOMEventListener
{
private
:
MOZ_KNOWN_LIVE
RefPtr
<
nsIContent
>
mContent
;
protected
:
virtual
~
TransitionEnder
(
)
=
default
;
public
:
HidePopupOptions
mOptions
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
TransitionEnder
)
TransitionEnder
(
nsIContent
*
aContent
HidePopupOptions
aOptions
)
:
mContent
(
aContent
)
mOptions
(
aOptions
)
{
}
MOZ_CAN_RUN_SCRIPT
NS_IMETHOD
HandleEvent
(
Event
*
aEvent
)
override
{
mContent
-
>
RemoveSystemEventListener
(
u
"
transitionend
"
_ns
this
false
)
;
nsMenuPopupFrame
*
popupFrame
=
do_QueryFrame
(
mContent
-
>
GetPrimaryFrame
(
)
)
;
if
(
!
popupFrame
)
{
return
NS_OK
;
}
if
(
RefPtr
<
nsXULPopupManager
>
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
)
{
pm
-
>
HidePopupCallback
(
mContent
popupFrame
nullptr
nullptr
popupFrame
-
>
GetPopupType
(
)
mOptions
)
;
}
return
NS_OK
;
}
}
;
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
TransitionEnder
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
TransitionEnder
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
TransitionEnder
)
NS_INTERFACE_MAP_ENTRY
(
nsIDOMEventListener
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION
(
TransitionEnder
mContent
)
;
void
nsXULPopupManager
:
:
HidePopupCallback
(
nsIContent
*
aPopup
nsMenuPopupFrame
*
aPopupFrame
nsIContent
*
aNextPopup
nsIContent
*
aLastPopup
PopupType
aPopupType
HidePopupOptions
aOptions
)
{
if
(
mCloseTimer
&
&
mTimerMenu
=
=
aPopupFrame
)
{
mCloseTimer
-
>
Cancel
(
)
;
mCloseTimer
=
nullptr
;
mTimerMenu
=
nullptr
;
}
for
(
nsMenuChainItem
*
item
=
mPopups
.
get
(
)
;
item
;
item
=
item
-
>
GetParent
(
)
)
{
if
(
item
-
>
Content
(
)
=
=
aPopup
)
{
RemoveMenuChainItem
(
item
)
;
SetCaptureState
(
aPopup
)
;
break
;
}
}
AutoWeakFrame
weakFrame
(
aPopupFrame
)
;
aPopupFrame
-
>
HidePopup
(
aOptions
.
contains
(
HidePopupOption
:
:
DeselectMenu
)
ePopupClosed
)
;
NS_ENSURE_TRUE_VOID
(
weakFrame
.
IsAlive
(
)
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
WidgetMouseEvent
event
(
true
eXULPopupHidden
nullptr
WidgetMouseEvent
:
:
eReal
)
;
RefPtr
<
nsPresContext
>
presContext
=
aPopupFrame
-
>
PresContext
(
)
;
EventDispatcher
:
:
Dispatch
(
aPopup
presContext
&
event
nullptr
&
status
)
;
NS_ENSURE_TRUE_VOID
(
weakFrame
.
IsAlive
(
)
)
;
UpdatePopupPositions
(
presContext
-
>
RefreshDriver
(
)
)
;
if
(
aNextPopup
&
&
aPopup
!
=
aLastPopup
)
{
nsMenuChainItem
*
foundMenu
=
FindPopup
(
aNextPopup
)
;
if
(
foundMenu
&
&
(
aLastPopup
|
|
aPopupType
=
=
foundMenu
-
>
GetPopupType
(
)
)
)
{
nsCOMPtr
<
nsIContent
>
popupToHide
=
foundMenu
-
>
Content
(
)
;
nsMenuChainItem
*
parent
=
foundMenu
-
>
GetParent
(
)
;
nsCOMPtr
<
nsIContent
>
nextPopup
;
if
(
parent
&
&
popupToHide
!
=
aLastPopup
)
nextPopup
=
parent
-
>
Content
(
)
;
nsMenuPopupFrame
*
popupFrame
=
foundMenu
-
>
Frame
(
)
;
nsPopupState
state
=
popupFrame
-
>
PopupState
(
)
;
if
(
state
=
=
ePopupHiding
)
return
;
if
(
state
!
=
ePopupInvisible
)
popupFrame
-
>
SetPopupState
(
ePopupHiding
)
;
RefPtr
<
nsPresContext
>
presContext
=
popupFrame
-
>
PresContext
(
)
;
FirePopupHidingEvent
(
popupToHide
nextPopup
aLastPopup
presContext
foundMenu
-
>
GetPopupType
(
)
aOptions
)
;
}
}
}
void
nsXULPopupManager
:
:
HidePopupAfterDelay
(
nsMenuPopupFrame
*
aPopup
int32_t
aDelay
)
{
KillMenuTimer
(
)
;
nsIEventTarget
*
target
=
aPopup
-
>
PopupElement
(
)
.
OwnerDoc
(
)
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
;
NS_NewTimerWithFuncCallback
(
getter_AddRefs
(
mCloseTimer
)
[
]
(
nsITimer
*
aTimer
void
*
aClosure
)
{
if
(
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
)
{
pm
-
>
KillMenuTimer
(
)
;
}
}
nullptr
aDelay
nsITimer
:
:
TYPE_ONE_SHOT
"
KillMenuTimer
"
target
)
;
mTimerMenu
=
aPopup
;
}
void
nsXULPopupManager
:
:
HidePopupsInList
(
const
nsTArray
<
nsMenuPopupFrame
*
>
&
aFrames
)
{
nsTArray
<
WeakFrame
>
weakPopups
(
aFrames
.
Length
(
)
)
;
uint32_t
f
;
for
(
f
=
0
;
f
<
aFrames
.
Length
(
)
;
f
+
+
)
{
WeakFrame
*
wframe
=
weakPopups
.
AppendElement
(
)
;
if
(
wframe
)
*
wframe
=
aFrames
[
f
]
;
}
for
(
f
=
0
;
f
<
weakPopups
.
Length
(
)
;
f
+
+
)
{
if
(
weakPopups
[
f
]
.
IsAlive
(
)
)
{
auto
*
frame
=
static_cast
<
nsMenuPopupFrame
*
>
(
weakPopups
[
f
]
.
GetFrame
(
)
)
;
frame
-
>
HidePopup
(
true
ePopupInvisible
)
;
}
}
SetCaptureState
(
nullptr
)
;
}
bool
nsXULPopupManager
:
:
IsChildOfDocShell
(
Document
*
aDoc
nsIDocShellTreeItem
*
aExpected
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
docShellItem
(
aDoc
-
>
GetDocShell
(
)
)
;
while
(
docShellItem
)
{
if
(
docShellItem
=
=
aExpected
)
return
true
;
nsCOMPtr
<
nsIDocShellTreeItem
>
parent
;
docShellItem
-
>
GetInProcessParent
(
getter_AddRefs
(
parent
)
)
;
docShellItem
=
parent
;
}
return
false
;
}
void
nsXULPopupManager
:
:
HidePopupsInDocShell
(
nsIDocShellTreeItem
*
aDocShellToHide
)
{
nsTArray
<
nsMenuPopupFrame
*
>
popupsToHide
;
nsMenuChainItem
*
item
=
mPopups
.
get
(
)
;
while
(
item
)
{
nsMenuChainItem
*
parent
=
item
-
>
GetParent
(
)
;
if
(
item
-
>
Frame
(
)
-
>
PopupState
(
)
!
=
ePopupInvisible
&
&
IsChildOfDocShell
(
item
-
>
Content
(
)
-
>
OwnerDoc
(
)
aDocShellToHide
)
)
{
nsMenuPopupFrame
*
frame
=
item
-
>
Frame
(
)
;
RemoveMenuChainItem
(
item
)
;
popupsToHide
.
AppendElement
(
frame
)
;
}
item
=
parent
;
}
HidePopupsInList
(
popupsToHide
)
;
}
void
nsXULPopupManager
:
:
UpdatePopupPositions
(
nsRefreshDriver
*
aRefreshDriver
)
{
for
(
nsMenuChainItem
*
item
=
mPopups
.
get
(
)
;
item
;
item
=
item
-
>
GetParent
(
)
)
{
if
(
item
-
>
Frame
(
)
-
>
PresContext
(
)
-
>
RefreshDriver
(
)
=
=
aRefreshDriver
)
{
item
-
>
CheckForAnchorChange
(
)
;
}
}
}
void
nsXULPopupManager
:
:
UpdateFollowAnchor
(
nsMenuPopupFrame
*
aPopup
)
{
for
(
nsMenuChainItem
*
item
=
mPopups
.
get
(
)
;
item
;
item
=
item
-
>
GetParent
(
)
)
{
if
(
item
-
>
Frame
(
)
=
=
aPopup
)
{
item
-
>
UpdateFollowAnchor
(
)
;
break
;
}
}
}
void
nsXULPopupManager
:
:
HideOpenMenusBeforeExecutingMenu
(
CloseMenuMode
aMode
)
{
if
(
aMode
=
=
CloseMenuMode_None
)
{
return
;
}
nsTArray
<
nsMenuPopupFrame
*
>
popupsToHide
;
nsMenuChainItem
*
item
=
GetTopVisibleMenu
(
)
;
while
(
item
)
{
if
(
!
item
-
>
IsMenu
(
)
)
{
break
;
}
nsMenuChainItem
*
next
=
item
-
>
GetParent
(
)
;
popupsToHide
.
AppendElement
(
item
-
>
Frame
(
)
)
;
if
(
aMode
=
=
CloseMenuMode_Single
)
{
break
;
}
item
=
next
;
}
HidePopupsInList
(
popupsToHide
)
;
}
void
nsXULPopupManager
:
:
ExecuteMenu
(
nsIContent
*
aMenu
nsXULMenuCommandEvent
*
aEvent
)
{
CloseMenuMode
cmm
=
GetCloseMenuMode
(
aMenu
)
;
HideOpenMenusBeforeExecutingMenu
(
cmm
)
;
aEvent
-
>
SetCloseMenuMode
(
cmm
)
;
nsCOMPtr
<
nsIRunnable
>
event
=
aEvent
;
aMenu
-
>
OwnerDoc
(
)
-
>
Dispatch
(
TaskCategory
:
:
Other
event
.
forget
(
)
)
;
}
bool
nsXULPopupManager
:
:
ActivateNativeMenuItem
(
nsIContent
*
aItem
mozilla
:
:
Modifiers
aModifiers
int16_t
aButton
mozilla
:
:
ErrorResult
&
aRv
)
{
if
(
mNativeMenu
&
&
aItem
-
>
IsElement
(
)
&
&
mNativeMenu
-
>
Element
(
)
-
>
Contains
(
aItem
)
)
{
mNativeMenu
-
>
ActivateItem
(
aItem
-
>
AsElement
(
)
aModifiers
aButton
aRv
)
;
return
true
;
}
return
false
;
}
nsEventStatus
nsXULPopupManager
:
:
FirePopupShowingEvent
(
const
PendingPopup
&
aPendingPopup
nsPresContext
*
aPresContext
)
{
AutoRestore
<
const
PendingPopup
*
>
restorePendingPopup
(
mPendingPopup
)
;
mPendingPopup
=
&
aPendingPopup
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
WidgetMouseEvent
event
(
true
eXULPopupShowing
nullptr
WidgetMouseEvent
:
:
eReal
)
;
nsPresContext
*
rootPresContext
=
aPresContext
-
>
GetRootPresContext
(
)
;
if
(
rootPresContext
)
{
event
.
mWidget
=
rootPresContext
-
>
PresShell
(
)
-
>
GetViewManager
(
)
-
>
GetRootWidget
(
)
;
}
else
{
event
.
mWidget
=
nullptr
;
}
event
.
mInputSource
=
aPendingPopup
.
MouseInputSource
(
)
;
event
.
mRefPoint
=
aPendingPopup
.
mMousePoint
;
event
.
mModifiers
=
aPendingPopup
.
mModifiers
;
RefPtr
<
nsIContent
>
popup
=
aPendingPopup
.
mPopup
;
EventDispatcher
:
:
Dispatch
(
popup
aPresContext
&
event
nullptr
&
status
)
;
return
status
;
}
void
nsXULPopupManager
:
:
BeginShowingPopup
(
const
PendingPopup
&
aPendingPopup
bool
aIsContextMenu
bool
aSelectFirstItem
)
{
RefPtr
<
nsIContent
>
popup
=
aPendingPopup
.
mPopup
;
nsMenuPopupFrame
*
popupFrame
=
do_QueryFrame
(
popup
-
>
GetPrimaryFrame
(
)
)
;
if
(
NS_WARN_IF
(
!
popupFrame
)
)
{
return
;
}
RefPtr
<
nsPresContext
>
presContext
=
popupFrame
-
>
PresContext
(
)
;
RefPtr
<
PresShell
>
presShell
=
presContext
-
>
PresShell
(
)
;
presShell
-
>
FrameNeedsReflow
(
popupFrame
IntrinsicDirty
:
:
FrameAndAncestors
NS_FRAME_IS_DIRTY
)
;
PopupType
popupType
=
popupFrame
-
>
GetPopupType
(
)
;
nsEventStatus
status
=
FirePopupShowingEvent
(
aPendingPopup
presContext
)
;
if
(
popupType
=
=
PopupType
:
:
Panel
&
&
!
popup
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
noautofocus
nsGkAtoms
:
:
_true
eCaseMatters
)
)
{
if
(
RefPtr
<
nsFocusManager
>
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
)
{
Document
*
doc
=
popup
-
>
GetUncomposedDoc
(
)
;
RefPtr
<
Element
>
currentFocus
=
fm
-
>
GetFocusedElement
(
)
;
if
(
doc
&
&
currentFocus
&
&
!
nsContentUtils
:
:
ContentIsCrossDocDescendantOf
(
currentFocus
popup
)
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
outerWindow
=
doc
-
>
GetWindow
(
)
;
fm
-
>
ClearFocus
(
outerWindow
)
;
}
}
}
popup
-
>
OwnerDoc
(
)
-
>
FlushPendingNotifications
(
FlushType
:
:
Frames
)
;
popupFrame
=
do_QueryFrame
(
popup
-
>
GetPrimaryFrame
(
)
)
;
if
(
!
popupFrame
)
{
return
;
}
if
(
popupFrame
-
>
PopupState
(
)
=
=
ePopupClosed
|
|
status
=
=
nsEventStatus_eConsumeNoDefault
)
{
popupFrame
-
>
SetPopupState
(
ePopupClosed
)
;
popupFrame
-
>
ClearTriggerContent
(
)
;
return
;
}
if
(
popup
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
type
nsGkAtoms
:
:
arrow
eCaseMatters
)
)
{
popupFrame
-
>
ShowWithPositionedEvent
(
)
;
presShell
-
>
FrameNeedsReflow
(
popupFrame
IntrinsicDirty
:
:
FrameAndAncestors
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
}
else
{
ShowPopupCallback
(
popup
popupFrame
aIsContextMenu
aSelectFirstItem
)
;
}
}
void
nsXULPopupManager
:
:
FirePopupHidingEvent
(
nsIContent
*
aPopup
nsIContent
*
aNextPopup
nsIContent
*
aLastPopup
nsPresContext
*
aPresContext
PopupType
aPopupType
HidePopupOptions
aOptions
)
{
nsCOMPtr
<
nsIContent
>
popup
=
aPopup
;
RefPtr
<
PresShell
>
presShell
=
aPresContext
-
>
PresShell
(
)
;
Unused
<
<
presShell
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
WidgetMouseEvent
event
(
true
eXULPopupHiding
nullptr
WidgetMouseEvent
:
:
eReal
)
;
EventDispatcher
:
:
Dispatch
(
aPopup
aPresContext
&
event
nullptr
&
status
)
;
if
(
aPopupType
=
=
PopupType
:
:
Panel
&
&
(
!
aPopup
-
>
IsElement
(
)
|
|
!
aPopup
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
noautofocus
nsGkAtoms
:
:
_true
eCaseMatters
)
)
)
{
if
(
RefPtr
<
nsFocusManager
>
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
)
{
Document
*
doc
=
aPopup
-
>
GetUncomposedDoc
(
)
;
RefPtr
<
Element
>
currentFocus
=
fm
-
>
GetFocusedElement
(
)
;
if
(
doc
&
&
currentFocus
&
&
nsContentUtils
:
:
ContentIsCrossDocDescendantOf
(
currentFocus
aPopup
)
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
outerWindow
=
doc
-
>
GetWindow
(
)
;
fm
-
>
ClearFocus
(
outerWindow
)
;
}
}
}
aPopup
-
>
OwnerDoc
(
)
-
>
FlushPendingNotifications
(
FlushType
:
:
Frames
)
;
nsMenuPopupFrame
*
popupFrame
=
do_QueryFrame
(
aPopup
-
>
GetPrimaryFrame
(
)
)
;
if
(
!
popupFrame
)
{
return
;
}
if
(
status
=
=
nsEventStatus_eConsumeNoDefault
&
&
!
popupFrame
-
>
IsInContentShell
(
)
)
{
popupFrame
-
>
SetPopupState
(
ePopupShown
)
;
return
;
}
const
bool
shouldAnimate
=
[
&
]
{
if
(
!
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
IntID
:
:
PanelAnimations
)
)
{
return
false
;
}
if
(
aOptions
.
contains
(
HidePopupOption
:
:
DisableAnimations
)
)
{
return
false
;
}
if
(
aNextPopup
)
{
return
false
;
}
nsAutoString
animate
;
if
(
!
aPopup
-
>
IsElement
(
)
|
|
!
aPopup
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
animate
animate
)
)
{
return
false
;
}
if
(
animate
.
EqualsLiteral
(
"
false
"
)
)
{
return
false
;
}
if
(
animate
.
EqualsLiteral
(
"
cancel
"
)
&
&
!
aOptions
.
contains
(
HidePopupOption
:
:
IsRollup
)
)
{
return
false
;
}
return
true
;
}
(
)
;
if
(
shouldAnimate
&
&
AnimationUtils
:
:
HasCurrentTransitions
(
aPopup
-
>
AsElement
(
)
PseudoStyleType
:
:
NotPseudo
)
)
{
RefPtr
<
TransitionEnder
>
ender
=
new
TransitionEnder
(
aPopup
aOptions
)
;
aPopup
-
>
AddSystemEventListener
(
u
"
transitionend
"
_ns
ender
false
false
)
;
return
;
}
HidePopupCallback
(
aPopup
popupFrame
aNextPopup
aLastPopup
aPopupType
aOptions
)
;
}
bool
nsXULPopupManager
:
:
IsPopupOpen
(
nsIContent
*
aPopup
)
{
if
(
mNativeMenu
&
&
mNativeMenu
-
>
Element
(
)
=
=
aPopup
)
{
return
true
;
}
if
(
nsMenuChainItem
*
item
=
FindPopup
(
aPopup
)
)
{
NS_ASSERTION
(
item
-
>
Frame
(
)
-
>
IsOpen
(
)
|
|
item
-
>
Frame
(
)
-
>
PopupState
(
)
=
=
ePopupHiding
|
|
item
-
>
Frame
(
)
-
>
PopupState
(
)
=
=
ePopupInvisible
"
popup
in
open
list
not
actually
open
"
)
;
Unused
<
<
item
;
return
true
;
}
return
false
;
}
nsIFrame
*
nsXULPopupManager
:
:
GetTopPopup
(
PopupType
aType
)
{
for
(
nsMenuChainItem
*
item
=
mPopups
.
get
(
)
;
item
;
item
=
item
-
>
GetParent
(
)
)
{
if
(
item
-
>
Frame
(
)
-
>
IsVisible
(
)
&
&
(
item
-
>
GetPopupType
(
)
=
=
aType
|
|
aType
=
=
PopupType
:
:
Any
)
)
{
return
item
-
>
Frame
(
)
;
}
}
return
nullptr
;
}
nsIContent
*
nsXULPopupManager
:
:
GetTopActiveMenuItemContent
(
)
{
for
(
nsMenuChainItem
*
item
=
mPopups
.
get
(
)
;
item
;
item
=
item
-
>
GetParent
(
)
)
{
if
(
!
item
-
>
Frame
(
)
-
>
IsVisible
(
)
)
{
continue
;
}
if
(
auto
*
content
=
item
-
>
Frame
(
)
-
>
PopupElement
(
)
.
GetActiveMenuChild
(
)
)
{
return
content
;
}
}
return
nullptr
;
}
void
nsXULPopupManager
:
:
GetVisiblePopups
(
nsTArray
<
nsIFrame
*
>
&
aPopups
)
{
aPopups
.
Clear
(
)
;
for
(
nsMenuChainItem
*
item
=
mPopups
.
get
(
)
;
item
;
item
=
item
-
>
GetParent
(
)
)
{
if
(
item
-
>
Frame
(
)
-
>
IsVisible
(
)
&
&
!
item
-
>
Frame
(
)
-
>
IsMouseTransparent
(
)
)
{
aPopups
.
AppendElement
(
item
-
>
Frame
(
)
)
;
}
}
}
already_AddRefed
<
nsINode
>
nsXULPopupManager
:
:
GetLastTriggerNode
(
Document
*
aDocument
bool
aIsTooltip
)
{
if
(
!
aDocument
)
return
nullptr
;
RefPtr
<
nsINode
>
node
;
RefPtr
<
nsIContent
>
openingPopup
=
mPendingPopup
?
mPendingPopup
-
>
mPopup
:
nullptr
;
if
(
openingPopup
&
&
openingPopup
-
>
GetUncomposedDoc
(
)
=
=
aDocument
&
&
aIsTooltip
=
=
openingPopup
-
>
IsXULElement
(
nsGkAtoms
:
:
tooltip
)
)
{
node
=
nsMenuPopupFrame
:
:
GetTriggerContent
(
GetPopupFrameForContent
(
openingPopup
false
)
)
;
}
else
if
(
mNativeMenu
&
&
!
aIsTooltip
)
{
RefPtr
<
dom
:
:
Element
>
popup
=
mNativeMenu
-
>
Element
(
)
;
if
(
popup
-
>
GetUncomposedDoc
(
)
=
=
aDocument
)
{
nsMenuPopupFrame
*
popupFrame
=
GetPopupFrameForContent
(
popup
false
)
;
node
=
nsMenuPopupFrame
:
:
GetTriggerContent
(
popupFrame
)
;
}
}
else
{
for
(
nsMenuChainItem
*
item
=
mPopups
.
get
(
)
;
item
;
item
=
item
-
>
GetParent
(
)
)
{
if
(
(
item
-
>
GetPopupType
(
)
=
=
PopupType
:
:
Tooltip
)
=
=
aIsTooltip
&
&
item
-
>
Content
(
)
-
>
GetUncomposedDoc
(
)
=
=
aDocument
)
{
node
=
nsMenuPopupFrame
:
:
GetTriggerContent
(
item
-
>
Frame
(
)
)
;
if
(
node
)
{
break
;
}
}
}
}
return
node
.
forget
(
)
;
}
bool
nsXULPopupManager
:
:
MayShowPopup
(
nsMenuPopupFrame
*
aPopup
)
{
NS_ASSERTION
(
!
aPopup
-
>
IsOpen
(
)
|
|
IsPopupOpen
(
aPopup
-
>
GetContent
(
)
)
"
popup
frame
state
doesn
'
t
match
XULPopupManager
open
state
"
)
;
nsPopupState
state
=
aPopup
-
>
PopupState
(
)
;
NS_ASSERTION
(
IsPopupOpen
(
aPopup
-
>
GetContent
(
)
)
|
|
state
=
=
ePopupClosed
|
|
state
=
=
ePopupShowing
|
|
state
=
=
ePopupPositioning
|
|
state
=
=
ePopupInvisible
"
popup
not
in
XULPopupManager
open
list
is
open
"
)
;
if
(
state
!
=
ePopupClosed
&
&
state
!
=
ePopupInvisible
)
return
false
;
if
(
IsPopupOpen
(
aPopup
-
>
GetContent
(
)
)
)
{
NS_WARNING
(
"
Refusing
to
show
duplicate
popup
"
)
;
return
false
;
}
if
(
mozilla
:
:
widget
:
:
nsAutoRollup
:
:
GetLastRollup
(
)
=
=
aPopup
-
>
GetContent
(
)
)
{
return
false
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
=
aPopup
-
>
PresContext
(
)
-
>
GetDocShell
(
)
;
nsCOMPtr
<
nsIBaseWindow
>
baseWin
=
do_QueryInterface
(
docShell
)
;
if
(
!
baseWin
)
{
return
false
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
root
;
docShell
-
>
GetInProcessRootTreeItem
(
getter_AddRefs
(
root
)
)
;
if
(
!
root
)
{
return
false
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
rootWin
=
root
-
>
GetWindow
(
)
;
MOZ_RELEASE_ASSERT
(
XRE_IsParentProcess
(
)
"
Cannot
have
XUL
in
content
process
showing
popups
.
"
)
;
if
(
docShell
-
>
ItemType
(
)
!
=
nsIDocShellTreeItem
:
:
typeChrome
)
{
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
!
fm
|
|
!
rootWin
)
{
return
false
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
activeWindow
=
fm
-
>
GetActiveWindow
(
)
;
if
(
activeWindow
!
=
rootWin
)
{
return
false
;
}
bool
visible
;
baseWin
-
>
GetVisibility
(
&
visible
)
;
if
(
!
visible
)
{
return
false
;
}
}
nsCOMPtr
<
nsIWidget
>
mainWidget
;
baseWin
-
>
GetMainWidget
(
getter_AddRefs
(
mainWidget
)
)
;
if
(
mainWidget
&
&
mainWidget
-
>
SizeMode
(
)
=
=
nsSizeMode_Minimized
)
{
return
false
;
}
#
ifdef
XP_MACOSX
if
(
rootWin
)
{
auto
globalWin
=
nsGlobalWindowOuter
:
:
Cast
(
rootWin
.
get
(
)
)
;
if
(
globalWin
-
>
IsInModalState
(
)
)
{
return
false
;
}
}
#
endif
if
(
auto
*
menu
=
aPopup
-
>
PopupElement
(
)
.
GetContainingMenu
(
)
)
{
if
(
auto
*
parent
=
XULPopupElement
:
:
FromNodeOrNull
(
menu
-
>
GetMenuParent
(
)
)
)
{
nsMenuPopupFrame
*
f
=
do_QueryFrame
(
parent
-
>
GetPrimaryFrame
(
)
)
;
if
(
f
&
&
!
f
-
>
IsOpen
(
)
)
{
return
false
;
}
}
}
return
true
;
}
void
nsXULPopupManager
:
:
PopupDestroyed
(
nsMenuPopupFrame
*
aPopup
)
{
CancelMenuTimer
(
aPopup
)
;
nsMenuChainItem
*
item
=
FindPopup
(
aPopup
-
>
GetContent
(
)
)
;
if
(
!
item
)
{
return
;
}
nsTArray
<
nsMenuPopupFrame
*
>
popupsToHide
;
if
(
!
item
-
>
IsNoAutoHide
(
)
&
&
item
-
>
Frame
(
)
-
>
PopupState
(
)
!
=
ePopupInvisible
)
{
for
(
auto
*
child
=
item
-
>
GetChild
(
)
;
child
;
child
=
child
-
>
GetChild
(
)
)
{
if
(
nsLayoutUtils
:
:
IsProperAncestorFrame
(
item
-
>
Frame
(
)
child
-
>
Frame
(
)
)
)
{
popupsToHide
.
AppendElement
(
child
-
>
Frame
(
)
)
;
}
else
{
HidePopup
(
child
-
>
Content
(
)
{
HidePopupOption
:
:
Async
}
)
;
break
;
}
}
}
RemoveMenuChainItem
(
item
)
;
HidePopupsInList
(
popupsToHide
)
;
}
bool
nsXULPopupManager
:
:
HasContextMenu
(
nsMenuPopupFrame
*
aPopup
)
{
nsMenuChainItem
*
item
=
GetTopVisibleMenu
(
)
;
while
(
item
&
&
item
-
>
Frame
(
)
!
=
aPopup
)
{
if
(
item
-
>
IsContextMenu
(
)
)
return
true
;
item
=
item
-
>
GetParent
(
)
;
}
return
false
;
}
void
nsXULPopupManager
:
:
SetCaptureState
(
nsIContent
*
aOldPopup
)
{
nsMenuChainItem
*
item
=
GetTopVisibleMenu
(
)
;
if
(
item
&
&
aOldPopup
=
=
item
-
>
Content
(
)
)
return
;
if
(
mWidget
)
{
mWidget
-
>
CaptureRollupEvents
(
false
)
;
mWidget
=
nullptr
;
}
if
(
item
)
{
nsMenuPopupFrame
*
popup
=
item
-
>
Frame
(
)
;
mWidget
=
popup
-
>
GetWidget
(
)
;
if
(
mWidget
)
{
mWidget
-
>
CaptureRollupEvents
(
true
)
;
}
}
UpdateKeyboardListeners
(
)
;
}
void
nsXULPopupManager
:
:
UpdateKeyboardListeners
(
)
{
nsCOMPtr
<
EventTarget
>
newTarget
;
bool
isForMenu
=
false
;
nsMenuChainItem
*
item
=
GetTopVisibleMenu
(
)
;
if
(
item
)
{
if
(
item
-
>
IgnoreKeys
(
)
!
=
eIgnoreKeys_True
)
{
newTarget
=
item
-
>
Content
(
)
-
>
GetComposedDoc
(
)
;
}
isForMenu
=
item
-
>
GetPopupType
(
)
=
=
PopupType
:
:
Menu
;
}
else
if
(
mActiveMenuBar
)
{
newTarget
=
mActiveMenuBar
-
>
GetContent
(
)
-
>
GetComposedDoc
(
)
;
isForMenu
=
true
;
}
if
(
mKeyListener
!
=
newTarget
)
{
OwningNonNull
<
nsXULPopupManager
>
kungFuDeathGrip
(
*
this
)
;
if
(
mKeyListener
)
{
mKeyListener
-
>
RemoveEventListener
(
u
"
keypress
"
_ns
this
true
)
;
mKeyListener
-
>
RemoveEventListener
(
u
"
keydown
"
_ns
this
true
)
;
mKeyListener
-
>
RemoveEventListener
(
u
"
keyup
"
_ns
this
true
)
;
mKeyListener
=
nullptr
;
nsContentUtils
:
:
NotifyInstalledMenuKeyboardListener
(
false
)
;
}
if
(
newTarget
)
{
newTarget
-
>
AddEventListener
(
u
"
keypress
"
_ns
this
true
)
;
newTarget
-
>
AddEventListener
(
u
"
keydown
"
_ns
this
true
)
;
newTarget
-
>
AddEventListener
(
u
"
keyup
"
_ns
this
true
)
;
nsContentUtils
:
:
NotifyInstalledMenuKeyboardListener
(
isForMenu
)
;
mKeyListener
=
newTarget
;
}
}
}
void
nsXULPopupManager
:
:
UpdateMenuItems
(
nsIContent
*
aPopup
)
{
nsCOMPtr
<
Document
>
document
=
aPopup
-
>
GetUncomposedDoc
(
)
;
if
(
!
document
)
{
return
;
}
nsCOMPtr
<
nsIDOMXULCommandDispatcher
>
commandDispatcher
=
document
-
>
GetCommandDispatcher
(
)
;
if
(
commandDispatcher
)
{
commandDispatcher
-
>
Unlock
(
)
;
}
for
(
nsCOMPtr
<
nsIContent
>
grandChild
=
aPopup
-
>
GetFirstChild
(
)
;
grandChild
;
grandChild
=
grandChild
-
>
GetNextSibling
(
)
)
{
if
(
grandChild
-
>
IsXULElement
(
nsGkAtoms
:
:
menugroup
)
)
{
if
(
grandChild
-
>
GetChildCount
(
)
=
=
0
)
{
continue
;
}
grandChild
=
grandChild
-
>
GetFirstChild
(
)
;
}
if
(
grandChild
-
>
IsXULElement
(
nsGkAtoms
:
:
menuitem
)
)
{
Element
*
grandChildElement
=
grandChild
-
>
AsElement
(
)
;
nsAutoString
command
;
grandChildElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
command
command
)
;
if
(
!
command
.
IsEmpty
(
)
)
{
RefPtr
<
dom
:
:
Element
>
commandElement
=
document
-
>
GetElementById
(
command
)
;
if
(
commandElement
)
{
nsAutoString
commandValue
;
if
(
commandElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
disabled
commandValue
)
)
grandChildElement
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
disabled
commandValue
true
)
;
else
grandChildElement
-
>
UnsetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
disabled
true
)
;
if
(
commandElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
label
commandValue
)
)
grandChildElement
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
label
commandValue
true
)
;
if
(
commandElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
accesskey
commandValue
)
)
grandChildElement
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
accesskey
commandValue
true
)
;
if
(
commandElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
checked
commandValue
)
)
grandChildElement
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
checked
commandValue
true
)
;
if
(
commandElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
hidden
commandValue
)
)
grandChildElement
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
hidden
commandValue
true
)
;
}
}
}
if
(
!
grandChild
-
>
GetNextSibling
(
)
&
&
grandChild
-
>
GetParent
(
)
-
>
IsXULElement
(
nsGkAtoms
:
:
menugroup
)
)
{
grandChild
=
grandChild
-
>
GetParent
(
)
;
}
}
}
void
nsXULPopupManager
:
:
KillMenuTimer
(
)
{
if
(
mCloseTimer
&
&
mTimerMenu
)
{
mCloseTimer
-
>
Cancel
(
)
;
mCloseTimer
=
nullptr
;
if
(
mTimerMenu
-
>
IsOpen
(
)
)
{
HidePopup
(
mTimerMenu
-
>
GetContent
(
)
{
HidePopupOption
:
:
Async
}
)
;
}
}
mTimerMenu
=
nullptr
;
}
void
nsXULPopupManager
:
:
CancelMenuTimer
(
nsMenuPopupFrame
*
aMenu
)
{
if
(
mCloseTimer
&
&
mTimerMenu
=
=
aMenu
)
{
mCloseTimer
-
>
Cancel
(
)
;
mCloseTimer
=
nullptr
;
mTimerMenu
=
nullptr
;
}
}
bool
nsXULPopupManager
:
:
HandleShortcutNavigation
(
KeyboardEvent
&
aKeyEvent
nsMenuPopupFrame
*
aFrame
)
{
#
ifdef
XP_WIN
WidgetInputEvent
*
evt
=
aKeyEvent
.
WidgetEventPtr
(
)
-
>
AsInputEvent
(
)
;
if
(
evt
&
&
evt
-
>
IsAccel
(
)
)
{
return
false
;
}
#
endif
if
(
!
aFrame
)
{
if
(
nsMenuChainItem
*
item
=
GetTopVisibleMenu
(
)
)
{
aFrame
=
item
-
>
Frame
(
)
;
}
}
if
(
aFrame
)
{
bool
action
=
false
;
RefPtr
result
=
aFrame
-
>
FindMenuWithShortcut
(
aKeyEvent
action
)
;
if
(
!
result
)
{
return
false
;
}
RefPtr
popup
=
&
aFrame
-
>
PopupElement
(
)
;
popup
-
>
SetActiveMenuChild
(
result
XULMenuParentElement
:
:
ByKey
:
:
Yes
)
;
if
(
action
)
{
WidgetEvent
*
evt
=
aKeyEvent
.
WidgetEventPtr
(
)
;
result
-
>
HandleEnterKeyPress
(
*
evt
)
;
}
return
true
;
}
if
(
mActiveMenuBar
)
{
RefPtr
menubar
=
&
mActiveMenuBar
-
>
MenubarElement
(
)
;
if
(
RefPtr
result
=
menubar
-
>
FindMenuWithShortcut
(
aKeyEvent
)
)
{
result
-
>
OpenMenuPopup
(
true
)
;
return
true
;
}
#
ifdef
XP_WIN
if
(
nsCOMPtr
<
nsISound
>
sound
=
do_GetService
(
"
mozilla
.
org
/
sound
;
1
"
)
)
{
sound
-
>
Beep
(
)
;
}
mActiveMenuBar
-
>
SetActive
(
false
)
;
#
endif
}
return
false
;
}
bool
nsXULPopupManager
:
:
HandleKeyboardNavigation
(
uint32_t
aKeyCode
)
{
if
(
nsMenuChainItem
*
nextitem
=
GetTopVisibleMenu
(
)
)
{
nextitem
-
>
Content
(
)
-
>
OwnerDoc
(
)
-
>
FlushPendingNotifications
(
FlushType
:
:
Frames
)
;
}
nsMenuChainItem
*
item
=
nullptr
;
nsMenuChainItem
*
nextitem
=
GetTopVisibleMenu
(
)
;
while
(
nextitem
)
{
item
=
nextitem
;
nextitem
=
item
-
>
GetParent
(
)
;
if
(
!
nextitem
)
{
break
;
}
if
(
!
nextitem
-
>
IsMenu
(
)
)
{
break
;
}
XULPopupElement
&
expectedParent
=
nextitem
-
>
Frame
(
)
-
>
PopupElement
(
)
;
auto
*
menu
=
item
-
>
Frame
(
)
-
>
PopupElement
(
)
.
GetContainingMenu
(
)
;
if
(
!
menu
|
|
menu
-
>
GetMenuParent
(
)
!
=
&
expectedParent
)
{
break
;
}
}
nsIFrame
*
itemFrame
;
if
(
item
)
{
itemFrame
=
item
-
>
Frame
(
)
;
}
else
if
(
mActiveMenuBar
)
{
itemFrame
=
mActiveMenuBar
;
}
else
{
return
false
;
}
nsNavigationDirection
theDirection
;
NS_ASSERTION
(
aKeyCode
>
=
KeyboardEvent_Binding
:
:
DOM_VK_END
&
&
aKeyCode
<
=
KeyboardEvent_Binding
:
:
DOM_VK_DOWN
"
Illegal
key
code
"
)
;
theDirection
=
NS_DIRECTION_FROM_KEY_CODE
(
itemFrame
aKeyCode
)
;
bool
selectFirstItem
=
true
;
#
ifdef
MOZ_WIDGET_GTK
{
XULButtonElement
*
currentItem
=
nullptr
;
if
(
item
&
&
mActiveMenuBar
&
&
NS_DIRECTION_IS_INLINE
(
theDirection
)
)
{
currentItem
=
item
-
>
Frame
(
)
-
>
PopupElement
(
)
.
GetActiveMenuChild
(
)
;
if
(
!
currentItem
)
{
item
=
nullptr
;
}
}
selectFirstItem
=
!
!
currentItem
;
}
#
endif
if
(
item
&
&
HandleKeyboardNavigationInPopup
(
item
theDirection
)
)
{
return
true
;
}
if
(
!
mActiveMenuBar
)
{
return
false
;
}
RefPtr
menubar
=
XULMenuParentElement
:
:
FromNode
(
mActiveMenuBar
-
>
GetContent
(
)
)
;
if
(
NS_DIRECTION_IS_INLINE
(
theDirection
)
)
{
RefPtr
prevActiveItem
=
menubar
-
>
GetActiveMenuChild
(
)
;
const
bool
open
=
prevActiveItem
&
&
prevActiveItem
-
>
IsMenuPopupOpen
(
)
;
RefPtr
nextItem
=
theDirection
=
=
eNavigationDirection_End
?
menubar
-
>
GetNextMenuItem
(
)
:
menubar
-
>
GetPrevMenuItem
(
)
;
menubar
-
>
SetActiveMenuChild
(
nextItem
XULMenuParentElement
:
:
ByKey
:
:
Yes
)
;
if
(
open
&
&
nextItem
)
{
nextItem
-
>
OpenMenuPopup
(
selectFirstItem
)
;
}
return
true
;
}
if
(
NS_DIRECTION_IS_BLOCK
(
theDirection
)
)
{
if
(
RefPtr
currentMenu
=
menubar
-
>
GetActiveMenuChild
(
)
)
{
ShowMenu
(
currentMenu
selectFirstItem
)
;
}
return
true
;
}
return
false
;
}
bool
nsXULPopupManager
:
:
HandleKeyboardNavigationInPopup
(
nsMenuChainItem
*
item
nsMenuPopupFrame
*
aFrame
nsNavigationDirection
aDir
)
{
NS_ASSERTION
(
aFrame
"
aFrame
is
null
"
)
;
NS_ASSERTION
(
!
item
|
|
item
-
>
Frame
(
)
=
=
aFrame
"
aFrame
is
expected
to
be
equal
to
item
-
>
Frame
(
)
"
)
;
using
Wrap
=
XULMenuParentElement
:
:
Wrap
;
RefPtr
<
XULPopupElement
>
menu
=
&
aFrame
-
>
PopupElement
(
)
;
aFrame
-
>
ClearIncrementalString
(
)
;
RefPtr
currentItem
=
aFrame
-
>
GetCurrentMenuItem
(
)
;
if
(
!
currentItem
&
&
NS_DIRECTION_IS_INLINE
(
aDir
)
)
{
if
(
aDir
=
=
eNavigationDirection_End
)
{
if
(
RefPtr
nextItem
=
menu
-
>
GetNextMenuItem
(
Wrap
:
:
No
)
)
{
menu
-
>
SetActiveMenuChild
(
nextItem
XULMenuParentElement
:
:
ByKey
:
:
Yes
)
;
return
true
;
}
}
return
false
;
}
const
bool
isContainer
=
currentItem
&
&
!
currentItem
-
>
IsMenuItem
(
)
;
const
bool
isOpen
=
currentItem
&
&
currentItem
-
>
IsMenuPopupOpen
(
)
;
if
(
isOpen
)
{
nsMenuChainItem
*
child
=
item
?
item
-
>
GetChild
(
)
:
nullptr
;
if
(
child
&
&
HandleKeyboardNavigationInPopup
(
child
aDir
)
)
{
return
true
;
}
}
else
if
(
aDir
=
=
eNavigationDirection_End
&
&
isContainer
&
&
!
currentItem
-
>
IsDisabled
(
)
)
{
currentItem
-
>
OpenMenuPopup
(
true
)
;
return
true
;
}
if
(
NS_DIRECTION_IS_BLOCK
(
aDir
)
|
|
NS_DIRECTION_IS_BLOCK_TO_EDGE
(
aDir
)
)
{
RefPtr
<
XULButtonElement
>
nextItem
=
nullptr
;
if
(
aDir
=
=
eNavigationDirection_Before
|
|
aDir
=
=
eNavigationDirection_After
)
{
auto
wrap
=
#
ifdef
XP_WIN
aFrame
-
>
IsMenuList
(
)
?
Wrap
:
:
No
:
Wrap
:
:
Yes
;
#
elif
defined
XP_MACOSX
Wrap
:
:
No
;
#
else
Wrap
:
:
Yes
;
#
endif
if
(
aDir
=
=
eNavigationDirection_Before
)
{
nextItem
=
menu
-
>
GetPrevMenuItem
(
wrap
)
;
}
else
{
nextItem
=
menu
-
>
GetNextMenuItem
(
wrap
)
;
}
}
else
if
(
aDir
=
=
eNavigationDirection_First
)
{
nextItem
=
menu
-
>
GetFirstMenuItem
(
)
;
}
else
{
nextItem
=
menu
-
>
GetLastMenuItem
(
)
;
}
if
(
nextItem
)
{
menu
-
>
SetActiveMenuChild
(
nextItem
XULMenuParentElement
:
:
ByKey
:
:
Yes
)
;
return
true
;
}
}
else
if
(
currentItem
&
&
isOpen
&
&
aDir
=
=
eNavigationDirection_Start
)
{
if
(
nsMenuPopupFrame
*
popupFrame
=
currentItem
-
>
GetMenuPopup
(
FlushType
:
:
None
)
)
{
HidePopup
(
popupFrame
-
>
GetContent
(
)
{
}
)
;
}
return
true
;
}
return
false
;
}
bool
nsXULPopupManager
:
:
HandleKeyboardEventWithKeyCode
(
KeyboardEvent
*
aKeyEvent
nsMenuChainItem
*
aTopVisibleMenuItem
)
{
uint32_t
keyCode
=
aKeyEvent
-
>
KeyCode
(
)
;
if
(
aTopVisibleMenuItem
&
&
aTopVisibleMenuItem
-
>
GetPopupType
(
)
!
=
PopupType
:
:
Menu
)
{
if
(
keyCode
=
=
KeyboardEvent_Binding
:
:
DOM_VK_ESCAPE
)
{
HidePopup
(
aTopVisibleMenuItem
-
>
Content
(
)
{
HidePopupOption
:
:
IsRollup
}
)
;
aKeyEvent
-
>
StopPropagation
(
)
;
aKeyEvent
-
>
StopCrossProcessForwarding
(
)
;
aKeyEvent
-
>
PreventDefault
(
)
;
}
return
true
;
}
bool
consume
=
(
aTopVisibleMenuItem
|
|
mActiveMenuBar
)
;
switch
(
keyCode
)
{
case
KeyboardEvent_Binding
:
:
DOM_VK_UP
:
case
KeyboardEvent_Binding
:
:
DOM_VK_DOWN
:
#
ifndef
XP_MACOSX
if
(
aKeyEvent
-
>
AltKey
(
)
&
&
aTopVisibleMenuItem
&
&
aTopVisibleMenuItem
-
>
Frame
(
)
-
>
IsMenuList
(
)
)
{
Rollup
(
{
}
)
;
break
;
}
[
[
fallthrough
]
]
;
#
endif
case
KeyboardEvent_Binding
:
:
DOM_VK_LEFT
:
case
KeyboardEvent_Binding
:
:
DOM_VK_RIGHT
:
case
KeyboardEvent_Binding
:
:
DOM_VK_HOME
:
case
KeyboardEvent_Binding
:
:
DOM_VK_END
:
HandleKeyboardNavigation
(
keyCode
)
;
break
;
case
KeyboardEvent_Binding
:
:
DOM_VK_PAGE_DOWN
:
case
KeyboardEvent_Binding
:
:
DOM_VK_PAGE_UP
:
if
(
aTopVisibleMenuItem
)
{
aTopVisibleMenuItem
-
>
Frame
(
)
-
>
ChangeByPage
(
keyCode
=
=
KeyboardEvent_Binding
:
:
DOM_VK_PAGE_UP
)
;
}
break
;
case
KeyboardEvent_Binding
:
:
DOM_VK_ESCAPE
:
if
(
aTopVisibleMenuItem
)
{
HidePopup
(
aTopVisibleMenuItem
-
>
Content
(
)
{
HidePopupOption
:
:
IsRollup
}
)
;
}
else
if
(
mActiveMenuBar
)
{
mActiveMenuBar
-
>
MenuClosed
(
)
;
}
break
;
case
KeyboardEvent_Binding
:
:
DOM_VK_TAB
:
#
ifndef
XP_MACOSX
case
KeyboardEvent_Binding
:
:
DOM_VK_F10
:
#
endif
if
(
aTopVisibleMenuItem
&
&
!
aTopVisibleMenuItem
-
>
Frame
(
)
-
>
PopupElement
(
)
.
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
activateontab
nsGkAtoms
:
:
_true
eCaseMatters
)
)
{
Rollup
(
{
}
)
;
break
;
}
else
if
(
mActiveMenuBar
)
{
mActiveMenuBar
-
>
MenuClosed
(
)
;
break
;
}
[
[
fallthrough
]
]
;
case
KeyboardEvent_Binding
:
:
DOM_VK_RETURN
:
{
WidgetEvent
*
event
=
aKeyEvent
-
>
WidgetEventPtr
(
)
;
if
(
aTopVisibleMenuItem
)
{
aTopVisibleMenuItem
-
>
Frame
(
)
-
>
HandleEnterKeyPress
(
*
event
)
;
}
else
if
(
mActiveMenuBar
)
{
mActiveMenuBar
-
>
HandleEnterKeyPress
(
*
event
)
;
}
break
;
}
default
:
return
false
;
}
if
(
consume
)
{
aKeyEvent
-
>
StopPropagation
(
)
;
aKeyEvent
-
>
StopCrossProcessForwarding
(
)
;
aKeyEvent
-
>
PreventDefault
(
)
;
}
return
true
;
}
nsresult
nsXULPopupManager
:
:
HandleEvent
(
Event
*
aEvent
)
{
RefPtr
<
KeyboardEvent
>
keyEvent
=
aEvent
-
>
AsKeyboardEvent
(
)
;
NS_ENSURE_TRUE
(
keyEvent
NS_ERROR_UNEXPECTED
)
;
if
(
!
keyEvent
-
>
IsTrusted
(
)
)
{
return
NS_OK
;
}
nsAutoString
eventType
;
keyEvent
-
>
GetType
(
eventType
)
;
if
(
eventType
.
EqualsLiteral
(
"
keyup
"
)
)
{
return
KeyUp
(
keyEvent
)
;
}
if
(
eventType
.
EqualsLiteral
(
"
keydown
"
)
)
{
return
KeyDown
(
keyEvent
)
;
}
if
(
eventType
.
EqualsLiteral
(
"
keypress
"
)
)
{
return
KeyPress
(
keyEvent
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
eventType
"
)
;
return
NS_OK
;
}
nsresult
nsXULPopupManager
:
:
UpdateIgnoreKeys
(
bool
aIgnoreKeys
)
{
nsMenuChainItem
*
item
=
GetTopVisibleMenu
(
)
;
if
(
item
)
{
item
-
>
SetIgnoreKeys
(
aIgnoreKeys
?
eIgnoreKeys_True
:
eIgnoreKeys_Shortcuts
)
;
}
UpdateKeyboardListeners
(
)
;
return
NS_OK
;
}
nsPopupState
nsXULPopupManager
:
:
GetPopupState
(
mozilla
:
:
dom
:
:
Element
*
aPopupElement
)
{
if
(
mNativeMenu
&
&
mNativeMenu
-
>
Element
(
)
-
>
Contains
(
aPopupElement
)
)
{
if
(
aPopupElement
!
=
mNativeMenu
-
>
Element
(
)
)
{
return
mNativeMenuSubmenuStates
.
MaybeGet
(
aPopupElement
)
.
valueOr
(
ePopupClosed
)
;
}
}
nsMenuPopupFrame
*
menuPopupFrame
=
do_QueryFrame
(
aPopupElement
-
>
GetPrimaryFrame
(
)
)
;
if
(
menuPopupFrame
)
{
return
menuPopupFrame
-
>
PopupState
(
)
;
}
return
ePopupClosed
;
}
nsresult
nsXULPopupManager
:
:
KeyUp
(
KeyboardEvent
*
aKeyEvent
)
{
if
(
!
mActiveMenuBar
)
{
nsMenuChainItem
*
item
=
GetTopVisibleMenu
(
)
;
if
(
!
item
|
|
item
-
>
GetPopupType
(
)
!
=
PopupType
:
:
Menu
)
return
NS_OK
;
if
(
item
-
>
IgnoreKeys
(
)
=
=
eIgnoreKeys_Shortcuts
)
{
aKeyEvent
-
>
StopCrossProcessForwarding
(
)
;
return
NS_OK
;
}
}
aKeyEvent
-
>
StopPropagation
(
)
;
aKeyEvent
-
>
StopCrossProcessForwarding
(
)
;
aKeyEvent
-
>
PreventDefault
(
)
;
return
NS_OK
;
}
nsresult
nsXULPopupManager
:
:
KeyDown
(
KeyboardEvent
*
aKeyEvent
)
{
nsMenuChainItem
*
item
=
GetTopVisibleMenu
(
)
;
if
(
item
&
&
item
-
>
Frame
(
)
-
>
PopupElement
(
)
.
IsLocked
(
)
)
{
return
NS_OK
;
}
if
(
HandleKeyboardEventWithKeyCode
(
aKeyEvent
item
)
)
{
return
NS_OK
;
}
if
(
!
mActiveMenuBar
&
&
(
!
item
|
|
item
-
>
GetPopupType
(
)
!
=
PopupType
:
:
Menu
)
)
return
NS_OK
;
if
(
!
item
|
|
item
-
>
IgnoreKeys
(
)
!
=
eIgnoreKeys_Shortcuts
)
{
aKeyEvent
-
>
StopPropagation
(
)
;
}
int32_t
menuAccessKey
=
nsMenuBarListener
:
:
GetMenuAccessKey
(
)
;
if
(
menuAccessKey
)
{
uint32_t
theChar
=
aKeyEvent
-
>
KeyCode
(
)
;
if
(
theChar
=
=
(
uint32_t
)
menuAccessKey
)
{
bool
ctrl
=
(
menuAccessKey
!
=
KeyboardEvent_Binding
:
:
DOM_VK_CONTROL
&
&
aKeyEvent
-
>
CtrlKey
(
)
)
;
bool
alt
=
(
menuAccessKey
!
=
KeyboardEvent_Binding
:
:
DOM_VK_ALT
&
&
aKeyEvent
-
>
AltKey
(
)
)
;
bool
shift
=
(
menuAccessKey
!
=
KeyboardEvent_Binding
:
:
DOM_VK_SHIFT
&
&
aKeyEvent
-
>
ShiftKey
(
)
)
;
bool
meta
=
(
menuAccessKey
!
=
KeyboardEvent_Binding
:
:
DOM_VK_META
&
&
aKeyEvent
-
>
MetaKey
(
)
)
;
if
(
!
(
ctrl
|
|
alt
|
|
shift
|
|
meta
)
)
{
nsMenuChainItem
*
item
=
GetTopVisibleMenu
(
)
;
if
(
item
&
&
!
item
-
>
Frame
(
)
-
>
IsMenuList
(
)
)
{
Rollup
(
{
}
)
;
}
else
if
(
mActiveMenuBar
)
{
mActiveMenuBar
-
>
MenuClosed
(
)
;
}
item
=
nullptr
;
}
aKeyEvent
-
>
StopPropagation
(
)
;
aKeyEvent
-
>
PreventDefault
(
)
;
}
}
aKeyEvent
-
>
StopCrossProcessForwarding
(
)
;
return
NS_OK
;
}
nsresult
nsXULPopupManager
:
:
KeyPress
(
KeyboardEvent
*
aKeyEvent
)
{
nsMenuChainItem
*
item
=
GetTopVisibleMenu
(
)
;
if
(
item
&
&
(
item
-
>
Frame
(
)
-
>
PopupElement
(
)
.
IsLocked
(
)
|
|
item
-
>
GetPopupType
(
)
!
=
PopupType
:
:
Menu
)
)
{
return
NS_OK
;
}
bool
consume
=
(
item
|
|
mActiveMenuBar
)
;
WidgetInputEvent
*
evt
=
aKeyEvent
-
>
WidgetEventPtr
(
)
-
>
AsInputEvent
(
)
;
bool
isAccel
=
evt
&
&
evt
-
>
IsAccel
(
)
;
if
(
item
&
&
item
-
>
IgnoreKeys
(
)
=
=
eIgnoreKeys_Shortcuts
&
&
isAccel
)
{
consume
=
false
;
}
HandleShortcutNavigation
(
*
aKeyEvent
nullptr
)
;
aKeyEvent
-
>
StopCrossProcessForwarding
(
)
;
if
(
consume
)
{
aKeyEvent
-
>
StopPropagation
(
)
;
aKeyEvent
-
>
PreventDefault
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsXULPopupHidingEvent
:
:
Run
(
)
{
RefPtr
<
nsXULPopupManager
>
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
Document
*
document
=
mPopup
-
>
GetUncomposedDoc
(
)
;
if
(
pm
&
&
document
)
{
if
(
RefPtr
<
nsPresContext
>
presContext
=
document
-
>
GetPresContext
(
)
)
{
nsCOMPtr
<
nsIContent
>
popup
=
mPopup
;
nsCOMPtr
<
nsIContent
>
nextPopup
=
mNextPopup
;
nsCOMPtr
<
nsIContent
>
lastPopup
=
mLastPopup
;
pm
-
>
FirePopupHidingEvent
(
popup
nextPopup
lastPopup
presContext
mPopupType
mOptions
)
;
}
}
return
NS_OK
;
}
bool
nsXULPopupPositionedEvent
:
:
DispatchIfNeeded
(
nsIContent
*
aPopup
)
{
if
(
aPopup
-
>
IsElement
(
)
&
&
aPopup
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
type
nsGkAtoms
:
:
arrow
eCaseMatters
)
)
{
nsCOMPtr
<
nsIRunnable
>
event
=
new
nsXULPopupPositionedEvent
(
aPopup
)
;
aPopup
-
>
OwnerDoc
(
)
-
>
Dispatch
(
TaskCategory
:
:
Other
event
.
forget
(
)
)
;
return
true
;
}
return
false
;
}
static
void
AlignmentPositionToString
(
nsMenuPopupFrame
*
aFrame
nsAString
&
aString
)
{
aString
.
Truncate
(
)
;
int8_t
position
=
aFrame
-
>
GetAlignmentPosition
(
)
;
switch
(
position
)
{
case
POPUPPOSITION_AFTERSTART
:
return
aString
.
AssignLiteral
(
"
after_start
"
)
;
case
POPUPPOSITION_AFTEREND
:
return
aString
.
AssignLiteral
(
"
after_end
"
)
;
case
POPUPPOSITION_BEFORESTART
:
return
aString
.
AssignLiteral
(
"
before_start
"
)
;
case
POPUPPOSITION_BEFOREEND
:
return
aString
.
AssignLiteral
(
"
before_end
"
)
;
case
POPUPPOSITION_STARTBEFORE
:
return
aString
.
AssignLiteral
(
"
start_before
"
)
;
case
POPUPPOSITION_ENDBEFORE
:
return
aString
.
AssignLiteral
(
"
end_before
"
)
;
case
POPUPPOSITION_STARTAFTER
:
return
aString
.
AssignLiteral
(
"
start_after
"
)
;
case
POPUPPOSITION_ENDAFTER
:
return
aString
.
AssignLiteral
(
"
end_after
"
)
;
case
POPUPPOSITION_OVERLAP
:
return
aString
.
AssignLiteral
(
"
overlap
"
)
;
case
POPUPPOSITION_AFTERPOINTER
:
return
aString
.
AssignLiteral
(
"
after_pointer
"
)
;
case
POPUPPOSITION_SELECTION
:
return
aString
.
AssignLiteral
(
"
selection
"
)
;
default
:
break
;
}
}
NS_IMETHODIMP
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsXULPopupPositionedEvent
:
:
Run
(
)
{
RefPtr
<
nsXULPopupManager
>
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
!
pm
)
{
return
NS_OK
;
}
nsMenuPopupFrame
*
popupFrame
=
do_QueryFrame
(
mPopup
-
>
GetPrimaryFrame
(
)
)
;
if
(
!
popupFrame
)
{
return
NS_OK
;
}
popupFrame
-
>
WillDispatchPopupPositioned
(
)
;
nsPopupState
state
=
popupFrame
-
>
PopupState
(
)
;
if
(
state
!
=
ePopupPositioning
&
&
state
!
=
ePopupShown
)
{
return
NS_OK
;
}
int32_t
popupOffset
=
nsPoint
(
popupFrame
-
>
GetAlignmentOffset
(
)
0
)
.
ToNearestPixels
(
AppUnitsPerCSSPixel
(
)
)
.
x
;
PopupPositionedEventInit
init
;
init
.
mComposed
=
true
;
init
.
mIsAnchored
=
popupFrame
-
>
IsAnchored
(
)
;
init
.
mAlignmentOffset
=
popupOffset
;
AlignmentPositionToString
(
popupFrame
init
.
mAlignmentPosition
)
;
RefPtr
<
PopupPositionedEvent
>
event
=
PopupPositionedEvent
:
:
Constructor
(
mPopup
u
"
popuppositioned
"
_ns
init
)
;
event
-
>
SetTrusted
(
true
)
;
mPopup
-
>
DispatchEvent
(
*
event
)
;
popupFrame
=
do_QueryFrame
(
mPopup
-
>
GetPrimaryFrame
(
)
)
;
if
(
popupFrame
&
&
popupFrame
-
>
PopupState
(
)
=
=
ePopupPositioning
)
{
pm
-
>
ShowPopupCallback
(
mPopup
popupFrame
false
false
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsXULMenuCommandEvent
:
:
Run
(
)
{
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
!
pm
)
{
return
NS_OK
;
}
RefPtr
menu
=
XULButtonElement
:
:
FromNode
(
mMenu
)
;
MOZ_ASSERT
(
menu
)
;
if
(
mFlipChecked
)
{
if
(
menu
-
>
GetXULBoolAttr
(
nsGkAtoms
:
:
checked
)
)
{
menu
-
>
UnsetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
checked
true
)
;
}
else
{
menu
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
checked
u
"
true
"
_ns
true
)
;
}
}
RefPtr
<
nsPresContext
>
presContext
=
menu
-
>
OwnerDoc
(
)
-
>
GetPresContext
(
)
;
RefPtr
<
PresShell
>
presShell
=
presContext
?
presContext
-
>
PresShell
(
)
:
nullptr
;
RefPtr
<
nsViewManager
>
kungFuDeathGrip
=
presShell
?
presShell
-
>
GetViewManager
(
)
:
nullptr
;
Unused
<
<
kungFuDeathGrip
;
if
(
mCloseMenuMode
!
=
CloseMenuMode_None
)
{
if
(
RefPtr
parent
=
menu
-
>
GetMenuParent
(
)
)
{
if
(
parent
-
>
GetActiveMenuChild
(
)
=
=
menu
)
{
parent
-
>
SetActiveMenuChild
(
nullptr
)
;
}
}
}
AutoHandlingUserInputStatePusher
userInpStatePusher
(
mUserInput
)
;
nsContentUtils
:
:
DispatchXULCommand
(
menu
mIsTrusted
nullptr
presShell
mModifiers
&
MODIFIER_CONTROL
mModifiers
&
MODIFIER_ALT
mModifiers
&
MODIFIER_SHIFT
mModifiers
&
MODIFIER_META
0
mButton
)
;
if
(
mCloseMenuMode
!
=
CloseMenuMode_None
)
{
if
(
RefPtr
popup
=
menu
-
>
GetContainingPopupElement
(
)
)
{
HidePopupOptions
options
{
HidePopupOption
:
:
DeselectMenu
}
;
if
(
mCloseMenuMode
=
=
CloseMenuMode_Auto
)
{
options
+
=
HidePopupOption
:
:
HideChain
;
}
pm
-
>
HidePopup
(
popup
options
)
;
}
}
return
NS_OK
;
}
