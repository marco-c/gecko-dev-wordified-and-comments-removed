#
include
"
nsMenuBarListener
.
h
"
#
include
"
nsMenuBarFrame
.
h
"
#
include
"
nsMenuPopupFrame
.
h
"
#
include
"
nsIDOMEvent
.
h
"
#
include
"
nsPIWindowRoot
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsWidgetsCID
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIDOMNode
.
h
"
#
include
"
nsIDOMElement
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
dom
/
KeyboardEvent
.
h
"
using
namespace
mozilla
;
using
mozilla
:
:
dom
:
:
KeyboardEvent
;
NS_IMPL_ISUPPORTS
(
nsMenuBarListener
nsIDOMEventListener
)
int32_t
nsMenuBarListener
:
:
mAccessKey
=
-
1
;
Modifiers
nsMenuBarListener
:
:
mAccessKeyMask
=
0
;
bool
nsMenuBarListener
:
:
mAccessKeyFocuses
=
false
;
nsMenuBarListener
:
:
nsMenuBarListener
(
nsMenuBarFrame
*
aMenuBarFrame
nsIContent
*
aMenuBarContent
)
:
mMenuBarFrame
(
aMenuBarFrame
)
mEventTarget
(
aMenuBarContent
?
aMenuBarContent
-
>
GetComposedDoc
(
)
:
nullptr
)
mTopWindowEventTarget
(
nullptr
)
mAccessKeyDown
(
false
)
mAccessKeyDownCanceled
(
false
)
{
MOZ_ASSERT
(
mEventTarget
)
;
mEventTarget
-
>
AddSystemEventListener
(
NS_LITERAL_STRING
(
"
keypress
"
)
this
false
)
;
mEventTarget
-
>
AddSystemEventListener
(
NS_LITERAL_STRING
(
"
keydown
"
)
this
false
)
;
mEventTarget
-
>
AddSystemEventListener
(
NS_LITERAL_STRING
(
"
keyup
"
)
this
false
)
;
mEventTarget
-
>
AddSystemEventListener
(
NS_LITERAL_STRING
(
"
mozaccesskeynotfound
"
)
this
false
)
;
mEventTarget
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
keydown
"
)
this
true
)
;
mEventTarget
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
mousedown
"
)
this
true
)
;
mEventTarget
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
mousedown
"
)
this
false
)
;
mEventTarget
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
blur
"
)
this
true
)
;
mEventTarget
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
MozDOMFullscreen
:
Entered
"
)
this
false
)
;
RefPtr
<
EventTarget
>
topWindowEventTarget
=
nsContentUtils
:
:
GetWindowRoot
(
aMenuBarContent
-
>
GetComposedDoc
(
)
)
;
mTopWindowEventTarget
=
topWindowEventTarget
.
get
(
)
;
mTopWindowEventTarget
-
>
AddSystemEventListener
(
NS_LITERAL_STRING
(
"
deactivate
"
)
this
true
)
;
}
nsMenuBarListener
:
:
~
nsMenuBarListener
(
)
{
MOZ_ASSERT
(
!
mEventTarget
"
OnDestroyMenuBarFrame
(
)
should
'
ve
alreay
been
called
"
)
;
}
void
nsMenuBarListener
:
:
OnDestroyMenuBarFrame
(
)
{
mEventTarget
-
>
RemoveSystemEventListener
(
NS_LITERAL_STRING
(
"
keypress
"
)
this
false
)
;
mEventTarget
-
>
RemoveSystemEventListener
(
NS_LITERAL_STRING
(
"
keydown
"
)
this
false
)
;
mEventTarget
-
>
RemoveSystemEventListener
(
NS_LITERAL_STRING
(
"
keyup
"
)
this
false
)
;
mEventTarget
-
>
RemoveSystemEventListener
(
NS_LITERAL_STRING
(
"
mozaccesskeynotfound
"
)
this
false
)
;
mEventTarget
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
keydown
"
)
this
true
)
;
mEventTarget
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
mousedown
"
)
this
true
)
;
mEventTarget
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
mousedown
"
)
this
false
)
;
mEventTarget
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
blur
"
)
this
true
)
;
mEventTarget
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
MozDOMFullscreen
:
Entered
"
)
this
false
)
;
mTopWindowEventTarget
-
>
RemoveSystemEventListener
(
NS_LITERAL_STRING
(
"
deactivate
"
)
this
true
)
;
mMenuBarFrame
=
nullptr
;
mEventTarget
=
nullptr
;
mTopWindowEventTarget
=
nullptr
;
}
void
nsMenuBarListener
:
:
InitializeStatics
(
)
{
Preferences
:
:
AddBoolVarCache
(
&
mAccessKeyFocuses
"
ui
.
key
.
menuAccessKeyFocuses
"
)
;
}
nsresult
nsMenuBarListener
:
:
GetMenuAccessKey
(
int32_t
*
aAccessKey
)
{
if
(
!
aAccessKey
)
return
NS_ERROR_INVALID_POINTER
;
InitAccessKey
(
)
;
*
aAccessKey
=
mAccessKey
;
return
NS_OK
;
}
void
nsMenuBarListener
:
:
InitAccessKey
(
)
{
if
(
mAccessKey
>
=
0
)
return
;
#
ifdef
XP_MACOSX
mAccessKey
=
0
;
mAccessKeyMask
=
0
;
#
else
mAccessKey
=
nsIDOMKeyEvent
:
:
DOM_VK_ALT
;
mAccessKeyMask
=
MODIFIER_ALT
;
#
endif
mAccessKey
=
Preferences
:
:
GetInt
(
"
ui
.
key
.
menuAccessKey
"
mAccessKey
)
;
if
(
mAccessKey
=
=
nsIDOMKeyEvent
:
:
DOM_VK_SHIFT
)
mAccessKeyMask
=
MODIFIER_SHIFT
;
else
if
(
mAccessKey
=
=
nsIDOMKeyEvent
:
:
DOM_VK_CONTROL
)
mAccessKeyMask
=
MODIFIER_CONTROL
;
else
if
(
mAccessKey
=
=
nsIDOMKeyEvent
:
:
DOM_VK_ALT
)
mAccessKeyMask
=
MODIFIER_ALT
;
else
if
(
mAccessKey
=
=
nsIDOMKeyEvent
:
:
DOM_VK_META
)
mAccessKeyMask
=
MODIFIER_META
;
else
if
(
mAccessKey
=
=
nsIDOMKeyEvent
:
:
DOM_VK_WIN
)
mAccessKeyMask
=
MODIFIER_OS
;
}
void
nsMenuBarListener
:
:
ToggleMenuActiveState
(
)
{
nsMenuFrame
*
closemenu
=
mMenuBarFrame
-
>
ToggleMenuActiveState
(
)
;
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
pm
&
&
closemenu
)
{
nsMenuPopupFrame
*
popupFrame
=
closemenu
-
>
GetPopup
(
)
;
if
(
popupFrame
)
pm
-
>
HidePopup
(
popupFrame
-
>
GetContent
(
)
false
false
true
false
)
;
}
}
nsresult
nsMenuBarListener
:
:
KeyUp
(
nsIDOMEvent
*
aKeyEvent
)
{
RefPtr
<
KeyboardEvent
>
keyEvent
=
aKeyEvent
-
>
InternalDOMEvent
(
)
-
>
AsKeyboardEvent
(
)
;
if
(
!
keyEvent
)
{
return
NS_OK
;
}
InitAccessKey
(
)
;
if
(
!
keyEvent
-
>
IsTrusted
(
)
)
{
return
NS_OK
;
}
if
(
mAccessKey
&
&
mAccessKeyFocuses
)
{
bool
defaultPrevented
=
keyEvent
-
>
DefaultPrevented
(
)
;
uint32_t
theChar
=
keyEvent
-
>
KeyCode
(
)
;
if
(
!
defaultPrevented
&
&
mAccessKeyDown
&
&
!
mAccessKeyDownCanceled
&
&
(
int32_t
)
theChar
=
=
mAccessKey
)
{
bool
toggleMenuActiveState
=
true
;
if
(
!
mMenuBarFrame
-
>
IsActive
(
)
)
{
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
pm
)
{
pm
-
>
Rollup
(
0
false
nullptr
nullptr
)
;
}
toggleMenuActiveState
=
!
Destroyed
(
)
&
&
!
mMenuBarFrame
-
>
IsActive
(
)
;
}
if
(
toggleMenuActiveState
)
{
if
(
!
mMenuBarFrame
-
>
IsActive
(
)
)
{
mMenuBarFrame
-
>
SetActiveByKeyboard
(
)
;
}
ToggleMenuActiveState
(
)
;
}
}
mAccessKeyDown
=
false
;
mAccessKeyDownCanceled
=
false
;
bool
active
=
!
Destroyed
(
)
&
&
mMenuBarFrame
-
>
IsActive
(
)
;
if
(
active
)
{
keyEvent
-
>
StopPropagation
(
)
;
keyEvent
-
>
PreventDefault
(
)
;
return
NS_OK
;
}
}
return
NS_OK
;
}
nsresult
nsMenuBarListener
:
:
KeyPress
(
nsIDOMEvent
*
aKeyEvent
)
{
if
(
aKeyEvent
)
{
bool
eventHandled
=
false
;
aKeyEvent
-
>
GetDefaultPrevented
(
&
eventHandled
)
;
if
(
eventHandled
)
{
return
NS_OK
;
}
}
bool
trustedEvent
=
false
;
if
(
aKeyEvent
)
{
aKeyEvent
-
>
GetIsTrusted
(
&
trustedEvent
)
;
}
if
(
!
trustedEvent
)
{
return
NS_OK
;
}
InitAccessKey
(
)
;
if
(
mAccessKey
)
{
WidgetKeyboardEvent
*
nativeKeyEvent
=
aKeyEvent
-
>
WidgetEventPtr
(
)
-
>
AsKeyboardEvent
(
)
;
if
(
!
nativeKeyEvent
)
{
return
NS_OK
;
}
RefPtr
<
KeyboardEvent
>
keyEvent
=
aKeyEvent
-
>
InternalDOMEvent
(
)
-
>
AsKeyboardEvent
(
)
;
uint32_t
keyCode
=
keyEvent
-
>
KeyCode
(
)
;
if
(
keyCode
!
=
(
uint32_t
)
mAccessKey
)
{
mAccessKeyDownCanceled
=
true
;
}
#
ifndef
XP_MACOSX
if
(
nativeKeyEvent
-
>
mMessage
=
=
eKeyPress
&
&
keyCode
=
=
NS_VK_F10
)
{
if
(
(
GetModifiersForAccessKey
(
keyEvent
)
&
~
MODIFIER_CONTROL
)
=
=
0
)
{
if
(
nativeKeyEvent
-
>
WillBeSentToRemoteProcess
(
)
)
{
nativeKeyEvent
-
>
StopImmediatePropagation
(
)
;
nativeKeyEvent
-
>
MarkAsWaitingReplyFromRemoteProcess
(
)
;
return
NS_OK
;
}
mMenuBarFrame
-
>
SetActiveByKeyboard
(
)
;
ToggleMenuActiveState
(
)
;
if
(
mMenuBarFrame
-
>
IsActive
(
)
)
{
#
ifdef
MOZ_WIDGET_GTK
mMenuBarFrame
-
>
GetCurrentMenuItem
(
)
-
>
OpenMenu
(
false
)
;
#
endif
aKeyEvent
-
>
StopPropagation
(
)
;
aKeyEvent
-
>
PreventDefault
(
)
;
}
}
return
NS_OK
;
}
#
endif
nsMenuFrame
*
menuFrameForKey
=
GetMenuForKeyEvent
(
keyEvent
false
)
;
if
(
!
menuFrameForKey
)
{
return
NS_OK
;
}
if
(
nativeKeyEvent
-
>
WillBeSentToRemoteProcess
(
)
)
{
nativeKeyEvent
-
>
StopImmediatePropagation
(
)
;
nativeKeyEvent
-
>
MarkAsWaitingReplyFromRemoteProcess
(
)
;
return
NS_OK
;
}
mMenuBarFrame
-
>
SetActiveByKeyboard
(
)
;
mMenuBarFrame
-
>
SetActive
(
true
)
;
menuFrameForKey
-
>
OpenMenu
(
true
)
;
mAccessKeyDown
=
mAccessKeyDownCanceled
=
false
;
aKeyEvent
-
>
StopPropagation
(
)
;
aKeyEvent
-
>
PreventDefault
(
)
;
}
return
NS_OK
;
}
bool
nsMenuBarListener
:
:
IsAccessKeyPressed
(
KeyboardEvent
*
aKeyEvent
)
{
InitAccessKey
(
)
;
uint32_t
modifiers
=
GetModifiersForAccessKey
(
aKeyEvent
)
;
return
(
mAccessKeyMask
!
=
MODIFIER_SHIFT
&
&
(
modifiers
&
mAccessKeyMask
)
&
&
(
modifiers
&
~
(
mAccessKeyMask
|
MODIFIER_SHIFT
)
)
=
=
0
)
;
}
Modifiers
nsMenuBarListener
:
:
GetModifiersForAccessKey
(
KeyboardEvent
*
aKeyEvent
)
{
WidgetInputEvent
*
inputEvent
=
aKeyEvent
-
>
WidgetEventPtr
(
)
-
>
AsInputEvent
(
)
;
MOZ_ASSERT
(
inputEvent
)
;
static
const
Modifiers
kPossibleModifiersForAccessKey
=
(
MODIFIER_SHIFT
|
MODIFIER_CONTROL
|
MODIFIER_ALT
|
MODIFIER_META
|
MODIFIER_OS
)
;
return
(
inputEvent
-
>
mModifiers
&
kPossibleModifiersForAccessKey
)
;
}
nsMenuFrame
*
nsMenuBarListener
:
:
GetMenuForKeyEvent
(
KeyboardEvent
*
aKeyEvent
bool
aPeek
)
{
if
(
!
IsAccessKeyPressed
(
aKeyEvent
)
)
{
return
nullptr
;
}
uint32_t
charCode
=
aKeyEvent
-
>
CharCode
(
)
;
bool
hasAccessKeyCandidates
=
charCode
!
=
0
;
if
(
!
hasAccessKeyCandidates
)
{
WidgetKeyboardEvent
*
nativeKeyEvent
=
aKeyEvent
-
>
WidgetEventPtr
(
)
-
>
AsKeyboardEvent
(
)
;
AutoTArray
<
uint32_t
10
>
keys
;
nativeKeyEvent
-
>
GetAccessKeyCandidates
(
keys
)
;
hasAccessKeyCandidates
=
!
keys
.
IsEmpty
(
)
;
}
if
(
hasAccessKeyCandidates
)
{
return
mMenuBarFrame
-
>
FindMenuWithShortcut
(
aKeyEvent
aPeek
)
;
}
return
nullptr
;
}
void
nsMenuBarListener
:
:
ReserveKeyIfNeeded
(
nsIDOMEvent
*
aKeyEvent
)
{
WidgetKeyboardEvent
*
nativeKeyEvent
=
aKeyEvent
-
>
WidgetEventPtr
(
)
-
>
AsKeyboardEvent
(
)
;
if
(
nsContentUtils
:
:
ShouldBlockReservedKeys
(
nativeKeyEvent
)
)
{
nativeKeyEvent
-
>
MarkAsReservedByChrome
(
)
;
}
}
nsresult
nsMenuBarListener
:
:
KeyDown
(
nsIDOMEvent
*
aKeyEvent
)
{
InitAccessKey
(
)
;
bool
trustedEvent
=
false
;
if
(
aKeyEvent
)
{
aKeyEvent
-
>
GetIsTrusted
(
&
trustedEvent
)
;
}
if
(
!
trustedEvent
)
{
return
NS_OK
;
}
RefPtr
<
KeyboardEvent
>
keyEvent
=
aKeyEvent
-
>
InternalDOMEvent
(
)
-
>
AsKeyboardEvent
(
)
;
if
(
!
keyEvent
)
{
return
NS_OK
;
}
uint32_t
theChar
=
keyEvent
-
>
KeyCode
(
)
;
uint16_t
eventPhase
=
keyEvent
-
>
EventPhase
(
)
;
bool
capturing
=
(
eventPhase
=
=
nsIDOMEvent
:
:
CAPTURING_PHASE
)
;
#
ifndef
XP_MACOSX
if
(
capturing
&
&
!
mAccessKeyDown
&
&
theChar
=
=
NS_VK_F10
&
&
(
GetModifiersForAccessKey
(
keyEvent
)
&
~
MODIFIER_CONTROL
)
=
=
0
)
{
ReserveKeyIfNeeded
(
aKeyEvent
)
;
}
#
endif
if
(
mAccessKey
&
&
mAccessKeyFocuses
)
{
bool
defaultPrevented
=
false
;
aKeyEvent
-
>
GetDefaultPrevented
(
&
defaultPrevented
)
;
bool
isAccessKeyDownEvent
=
(
(
theChar
=
=
(
uint32_t
)
mAccessKey
)
&
&
(
GetModifiersForAccessKey
(
keyEvent
)
&
~
mAccessKeyMask
)
=
=
0
)
;
if
(
!
capturing
&
&
!
mAccessKeyDown
)
{
if
(
!
isAccessKeyDownEvent
)
{
return
NS_OK
;
}
mAccessKeyDown
=
true
;
mAccessKeyDownCanceled
=
defaultPrevented
;
return
NS_OK
;
}
if
(
mAccessKeyDownCanceled
|
|
defaultPrevented
)
{
return
NS_OK
;
}
mAccessKeyDownCanceled
=
!
isAccessKeyDownEvent
;
}
if
(
capturing
&
&
mAccessKey
)
{
nsMenuFrame
*
menuFrameForKey
=
GetMenuForKeyEvent
(
keyEvent
true
)
;
if
(
menuFrameForKey
)
{
ReserveKeyIfNeeded
(
aKeyEvent
)
;
}
}
return
NS_OK
;
}
nsresult
nsMenuBarListener
:
:
Blur
(
nsIDOMEvent
*
aEvent
)
{
if
(
!
mMenuBarFrame
-
>
IsMenuOpen
(
)
&
&
mMenuBarFrame
-
>
IsActive
(
)
)
{
ToggleMenuActiveState
(
)
;
mAccessKeyDown
=
false
;
mAccessKeyDownCanceled
=
false
;
}
return
NS_OK
;
}
nsresult
nsMenuBarListener
:
:
OnWindowDeactivated
(
nsIDOMEvent
*
aEvent
)
{
mAccessKeyDown
=
false
;
mAccessKeyDownCanceled
=
false
;
return
NS_OK
;
}
nsresult
nsMenuBarListener
:
:
MouseDown
(
nsIDOMEvent
*
aMouseEvent
)
{
if
(
mAccessKeyDown
)
{
mAccessKeyDownCanceled
=
true
;
}
uint16_t
phase
=
0
;
nsresult
rv
=
aMouseEvent
-
>
GetEventPhase
(
&
phase
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
phase
=
=
nsIDOMEvent
:
:
CAPTURING_PHASE
)
{
return
NS_OK
;
}
if
(
!
mMenuBarFrame
-
>
IsMenuOpen
(
)
&
&
mMenuBarFrame
-
>
IsActive
(
)
)
ToggleMenuActiveState
(
)
;
return
NS_OK
;
}
nsresult
nsMenuBarListener
:
:
Fullscreen
(
nsIDOMEvent
*
aEvent
)
{
if
(
mMenuBarFrame
-
>
IsActive
(
)
)
{
ToggleMenuActiveState
(
)
;
}
return
NS_OK
;
}
nsresult
nsMenuBarListener
:
:
HandleEvent
(
nsIDOMEvent
*
aEvent
)
{
if
(
!
mMenuBarFrame
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
)
{
return
NS_OK
;
}
nsAutoString
eventType
;
aEvent
-
>
GetType
(
eventType
)
;
if
(
eventType
.
EqualsLiteral
(
"
keyup
"
)
)
{
return
KeyUp
(
aEvent
)
;
}
if
(
eventType
.
EqualsLiteral
(
"
keydown
"
)
)
{
return
KeyDown
(
aEvent
)
;
}
if
(
eventType
.
EqualsLiteral
(
"
keypress
"
)
)
{
return
KeyPress
(
aEvent
)
;
}
if
(
eventType
.
EqualsLiteral
(
"
mozaccesskeynotfound
"
)
)
{
return
KeyPress
(
aEvent
)
;
}
if
(
eventType
.
EqualsLiteral
(
"
blur
"
)
)
{
return
Blur
(
aEvent
)
;
}
if
(
eventType
.
EqualsLiteral
(
"
deactivate
"
)
)
{
return
OnWindowDeactivated
(
aEvent
)
;
}
if
(
eventType
.
EqualsLiteral
(
"
mousedown
"
)
)
{
return
MouseDown
(
aEvent
)
;
}
if
(
eventType
.
EqualsLiteral
(
"
MozDOMFullscreen
:
Entered
"
)
)
{
return
Fullscreen
(
aEvent
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
eventType
"
)
;
return
NS_OK
;
}
