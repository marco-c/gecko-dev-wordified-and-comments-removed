#
ifndef
nsMenuPopupFrame_h__
#
define
nsMenuPopupFrame_h__
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
StaticPrefs_ui
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIDOMEventListener
.
h
"
#
include
"
nsXULPopupManager
.
h
"
#
include
"
nsBlockFrame
.
h
"
#
include
"
Units
.
h
"
class
nsIWidget
;
namespace
mozilla
{
class
PresShell
;
enum
class
WindowShadow
:
uint8_t
;
namespace
dom
{
class
KeyboardEvent
;
class
XULButtonElement
;
class
XULPopupElement
;
}
namespace
widget
{
enum
class
PopupLevel
:
uint8_t
;
}
}
enum
ConsumeOutsideClicksResult
{
ConsumeOutsideClicks_ParentOnly
=
0
ConsumeOutsideClicks_True
=
1
ConsumeOutsideClicks_Never
=
2
}
;
enum
FlipStyle
{
FlipStyle_None
=
0
FlipStyle_Outside
=
1
FlipStyle_Inside
=
2
}
;
enum
FlipType
{
FlipType_Default
=
0
FlipType_None
=
1
FlipType_Both
=
2
FlipType_Slide
=
3
}
;
enum
class
MenuPopupAnchorType
:
uint8_t
{
Node
=
0
Point
=
1
Rect
=
2
}
;
#
define
POPUPALIGNMENT_NONE
0
#
define
POPUPALIGNMENT_TOPLEFT
1
#
define
POPUPALIGNMENT_TOPRIGHT
-
1
#
define
POPUPALIGNMENT_BOTTOMLEFT
2
#
define
POPUPALIGNMENT_BOTTOMRIGHT
-
2
#
define
POPUPALIGNMENT_LEFTCENTER
16
#
define
POPUPALIGNMENT_RIGHTCENTER
-
16
#
define
POPUPALIGNMENT_TOPCENTER
17
#
define
POPUPALIGNMENT_BOTTOMCENTER
18
#
define
POPUPPOSITION_UNKNOWN
-
1
#
define
POPUPPOSITION_BEFORESTART
0
#
define
POPUPPOSITION_BEFOREEND
1
#
define
POPUPPOSITION_AFTERSTART
2
#
define
POPUPPOSITION_AFTEREND
3
#
define
POPUPPOSITION_STARTBEFORE
4
#
define
POPUPPOSITION_ENDBEFORE
5
#
define
POPUPPOSITION_STARTAFTER
6
#
define
POPUPPOSITION_ENDAFTER
7
#
define
POPUPPOSITION_OVERLAP
8
#
define
POPUPPOSITION_AFTERPOINTER
9
#
define
POPUPPOSITION_SELECTION
10
#
define
POPUPPOSITION_HFLIP
(
v
)
(
v
^
1
)
#
define
POPUPPOSITION_VFLIP
(
v
)
(
v
^
2
)
nsIFrame
*
NS_NewMenuPopupFrame
(
mozilla
:
:
PresShell
*
aPresShell
mozilla
:
:
ComputedStyle
*
aStyle
)
;
class
nsView
;
class
nsMenuPopupFrame
;
class
nsXULPopupShownEvent
final
:
public
mozilla
:
:
Runnable
public
nsIDOMEventListener
{
public
:
nsXULPopupShownEvent
(
nsIContent
*
aPopup
nsPresContext
*
aPresContext
)
:
mozilla
:
:
Runnable
(
"
nsXULPopupShownEvent
"
)
mPopup
(
aPopup
)
mPresContext
(
aPresContext
)
{
}
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSIRUNNABLE
NS_DECL_NSIDOMEVENTLISTENER
void
CancelListener
(
)
;
protected
:
virtual
~
nsXULPopupShownEvent
(
)
=
default
;
private
:
const
nsCOMPtr
<
nsIContent
>
mPopup
;
const
RefPtr
<
nsPresContext
>
mPresContext
;
}
;
class
nsMenuPopupFrame
final
:
public
nsBlockFrame
{
using
PopupLevel
=
mozilla
:
:
widget
:
:
PopupLevel
;
using
PopupType
=
mozilla
:
:
widget
:
:
PopupType
;
public
:
NS_DECL_QUERYFRAME
NS_DECL_FRAMEARENA_HELPERS
(
nsMenuPopupFrame
)
explicit
nsMenuPopupFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
;
~
nsMenuPopupFrame
(
)
;
nsPopupState
PopupState
(
)
const
{
return
mPopupState
;
}
void
SetPopupState
(
nsPopupState
)
;
ConsumeOutsideClicksResult
ConsumeOutsideClicks
(
)
;
mozilla
:
:
dom
:
:
XULPopupElement
&
PopupElement
(
)
const
;
nscoord
IntrinsicISize
(
gfxContext
*
aContext
mozilla
:
:
IntrinsicISizeType
aType
)
override
;
void
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
override
;
nsIWidget
*
GetWidget
(
)
const
;
enum
class
WidgetStyle
:
uint8_t
{
ColorScheme
InputRegion
Opacity
Shadow
Transform
}
;
using
WidgetStyleFlags
=
mozilla
:
:
EnumSet
<
WidgetStyle
>
;
static
constexpr
WidgetStyleFlags
AllWidgetStyleFlags
(
)
{
return
{
WidgetStyle
:
:
ColorScheme
WidgetStyle
:
:
InputRegion
WidgetStyle
:
:
Opacity
WidgetStyle
:
:
Shadow
WidgetStyle
:
:
Transform
}
;
}
void
PropagateStyleToWidget
(
WidgetStyleFlags
=
AllWidgetStyleFlags
(
)
)
const
;
void
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
override
;
nsresult
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
override
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
Destroy
(
DestroyContext
&
)
override
;
bool
HasRemoteContent
(
)
const
;
bool
ShouldCreateWidgetUpfront
(
)
const
;
bool
ShouldExpandToInflowParentOrAnchor
(
)
const
;
bool
IsNoAutoHide
(
)
const
;
PopupLevel
GetPopupLevel
(
)
const
{
return
GetPopupLevel
(
IsNoAutoHide
(
)
)
;
}
void
PrepareWidget
(
bool
aRecreate
=
false
)
;
MOZ_CAN_RUN_SCRIPT
void
EnsureActiveMenuListItemIsVisible
(
)
;
nsresult
CreateWidgetForView
(
nsView
*
aView
)
;
mozilla
:
:
WindowShadow
GetShadowStyle
(
)
const
;
void
DidSetComputedStyle
(
ComputedStyle
*
aOldStyle
)
override
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
LayoutPopup
(
nsPresContext
*
ReflowOutput
&
const
ReflowInput
&
nsReflowStatus
&
)
;
void
SetPopupPosition
(
bool
aIsMove
)
;
MOZ_CAN_RUN_SCRIPT
void
HandleEnterKeyPress
(
mozilla
:
:
WidgetEvent
&
)
;
mozilla
:
:
dom
:
:
XULButtonElement
*
FindMenuWithShortcut
(
mozilla
:
:
dom
:
:
KeyboardEvent
&
aKeyEvent
bool
&
aDoAction
)
;
mozilla
:
:
dom
:
:
XULButtonElement
*
GetCurrentMenuItem
(
)
const
;
nsIFrame
*
GetCurrentMenuItemFrame
(
)
const
;
PopupType
GetPopupType
(
)
const
{
return
mPopupType
;
}
bool
IsContextMenu
(
)
const
{
return
mIsContextMenu
;
}
bool
IsOpen
(
)
const
{
return
mPopupState
=
=
ePopupOpening
|
|
mPopupState
=
=
ePopupVisible
|
|
mPopupState
=
=
ePopupShown
;
}
bool
IsVisible
(
)
{
return
mPopupState
=
=
ePopupVisible
|
|
mPopupState
=
=
ePopupShown
;
}
bool
IsVisibleOrShowing
(
)
{
return
IsOpen
(
)
|
|
mPopupState
=
=
ePopupPositioning
|
|
mPopupState
=
=
ePopupShowing
;
}
bool
IsNativeMenu
(
)
const
{
return
mIsNativeMenu
;
}
bool
IsMouseTransparent
(
)
const
;
bool
IsMenuList
(
)
const
;
bool
IsDragSource
(
)
const
{
return
mIsDragSource
;
}
void
SetIsDragSource
(
bool
aIsDragSource
)
{
mIsDragSource
=
aIsDragSource
;
}
static
nsIContent
*
GetTriggerContent
(
nsMenuPopupFrame
*
aMenuPopupFrame
)
;
void
ClearTriggerContent
(
)
{
mTriggerContent
=
nullptr
;
}
void
ClearTriggerContentIncludingDocument
(
)
;
bool
IsInContentShell
(
)
const
{
return
mInContentShell
;
}
void
InitializePopup
(
nsIContent
*
aAnchorContent
nsIContent
*
aTriggerContent
const
nsAString
&
aPosition
int32_t
aXPos
int32_t
aYPos
MenuPopupAnchorType
aAnchorType
bool
aAttributesOverride
)
;
void
InitializePopupAtRect
(
nsIContent
*
aTriggerContent
const
nsAString
&
aPosition
const
nsIntRect
&
aRect
bool
aAttributesOverride
)
;
void
InitializePopupAtScreen
(
nsIContent
*
aTriggerContent
int32_t
aXPos
int32_t
aYPos
bool
aIsContextMenu
)
;
void
InitializePopupAsNativeContextMenu
(
nsIContent
*
aTriggerContent
int32_t
aXPos
int32_t
aYPos
)
;
void
ShowPopup
(
bool
aIsContextMenu
)
;
MOZ_CAN_RUN_SCRIPT
void
HidePopup
(
bool
aDeselectMenu
nsPopupState
aNewState
bool
aFromFrameDestruction
=
false
)
;
void
ClearIncrementalString
(
)
{
mIncrementalString
.
Truncate
(
)
;
}
static
bool
IsWithinIncrementalTime
(
mozilla
:
:
TimeStamp
time
)
{
return
!
sLastKeyTime
.
IsNull
(
)
&
&
(
(
time
-
sLastKeyTime
)
.
ToMilliseconds
(
)
<
=
mozilla
:
:
StaticPrefs
:
:
ui_menu_incremental_search_timeout
(
)
)
;
}
#
ifdef
DEBUG_FRAME_DUMP
virtual
nsresult
GetFrameName
(
nsAString
&
aResult
)
const
override
{
return
MakeFrameName
(
u
"
MenuPopup
"
_ns
aResult
)
;
}
#
endif
MOZ_CAN_RUN_SCRIPT
void
ChangeByPage
(
bool
aIsUp
)
;
void
MoveTo
(
const
mozilla
:
:
CSSPoint
&
aPos
bool
aUpdateAttrs
bool
aByMoveToRect
=
false
)
;
void
MoveToAnchor
(
nsIContent
*
aAnchorContent
const
nsAString
&
aPosition
int32_t
aXPos
int32_t
aYPos
bool
aAttributesOverride
)
;
mozilla
:
:
ScrollContainerFrame
*
GetScrollContainerFrame
(
)
const
;
void
SetOverrideConstraintRect
(
const
mozilla
:
:
CSSIntRect
&
aRect
)
{
mOverrideConstraintRect
=
mozilla
:
:
CSSIntRect
:
:
ToAppUnits
(
aRect
)
;
}
bool
IsConstrainedByLayout
(
)
const
{
return
mConstrainedByLayout
;
}
struct
Rects
{
nsRect
mAnchorRect
;
nsRect
mUntransformedAnchorRect
;
nsRect
mUsedRect
;
nscoord
mAlignmentOffset
=
0
;
bool
mHFlip
=
false
;
bool
mVFlip
=
false
;
bool
mConstrainedByLayout
=
false
;
mozilla
:
:
LayoutDeviceIntPoint
mClientOffset
;
nsPoint
mViewPoint
;
}
;
Rects
GetRects
(
const
nsSize
&
aPrefSize
)
const
;
Maybe
<
nsRect
>
GetConstraintRect
(
const
nsRect
&
aAnchorRect
const
nsRect
&
aRootScreenRect
PopupLevel
)
const
;
void
PerformMove
(
const
Rects
&
)
;
bool
IsAnchored
(
)
const
{
return
mAnchorType
!
=
MenuPopupAnchorType
:
:
Point
;
}
nsIContent
*
GetAnchor
(
)
const
{
return
mAnchorContent
;
}
mozilla
:
:
CSSIntRect
GetScreenAnchorRect
(
)
const
{
return
mozilla
:
:
CSSRect
:
:
FromAppUnitsRounded
(
mScreenRect
)
;
}
mozilla
:
:
LayoutDeviceIntPoint
GetLastClientOffset
(
)
const
{
return
mLastClientOffset
;
}
int8_t
GetAlignmentPosition
(
)
const
;
nscoord
GetAlignmentOffset
(
)
const
{
return
mAlignmentOffset
;
}
bool
ClearPopupShownDispatcher
(
)
{
if
(
mPopupShownDispatcher
)
{
mPopupShownDispatcher
-
>
CancelListener
(
)
;
mPopupShownDispatcher
=
nullptr
;
return
true
;
}
return
false
;
}
void
ShowWithPositionedEvent
(
)
{
mPopupState
=
ePopupPositioning
;
}
void
CheckForAnchorChange
(
nsRect
&
aRect
)
;
void
WillDispatchPopupPositioned
(
)
{
mPendingPositionedEvent
=
false
;
}
protected
:
PopupLevel
GetPopupLevel
(
bool
aIsNoAutoHide
)
const
;
void
InitPositionFromAnchorAlign
(
const
nsAString
&
aAnchor
const
nsAString
&
aAlign
)
;
nsPoint
AdjustPositionForAnchorAlign
(
nsRect
&
aAnchorRect
const
nsSize
&
aPrefSize
FlipStyle
&
aHFlip
FlipStyle
&
aVFlip
)
const
;
nsIFrame
*
GetSelectedItemForAlignment
(
)
const
;
nscoord
FlipOrResize
(
nscoord
&
aScreenPoint
nscoord
aSize
nscoord
aScreenBegin
nscoord
aScreenEnd
nscoord
aAnchorBegin
nscoord
aAnchorEnd
nscoord
aMarginBegin
nscoord
aMarginEnd
FlipStyle
aFlip
bool
aIsOnEnd
bool
*
aFlipSide
)
const
;
nscoord
SlideOrResize
(
nscoord
&
aScreenPoint
nscoord
aSize
nscoord
aScreenBegin
nscoord
aScreenEnd
nscoord
*
aOffset
)
const
;
nsRect
ComputeAnchorRect
(
nsPresContext
*
aRootPresContext
nsIFrame
*
aAnchorFrame
)
const
;
void
MoveToAttributePosition
(
)
;
void
CreatePopupView
(
)
;
nsView
*
GetViewInternal
(
)
const
override
{
return
mView
;
}
void
SetViewInternal
(
nsView
*
aView
)
override
{
mView
=
aView
;
}
bool
ShouldFollowAnchor
(
)
const
;
nsIFrame
*
GetAnchorFrame
(
)
const
;
public
:
bool
IsDirectionRTL
(
)
const
;
bool
ShouldFollowAnchor
(
nsRect
&
aRect
)
;
nsIWidget
*
GetParentMenuWidget
(
)
;
nsMargin
GetMargin
(
)
const
;
const
nsRect
&
GetUntransformedAnchorRect
(
)
const
{
return
mUntransformedAnchorRect
;
}
int
GetPopupAlignment
(
)
const
{
return
mPopupAlignment
;
}
int
GetPopupAnchor
(
)
const
{
return
mPopupAnchor
;
}
FlipType
GetFlipType
(
)
const
{
return
mFlip
;
}
void
WidgetPositionOrSizeDidChange
(
)
;
protected
:
nsString
mIncrementalString
;
nsCOMPtr
<
nsIContent
>
mAnchorContent
;
nsCOMPtr
<
nsIContent
>
mTriggerContent
;
nsView
*
mView
=
nullptr
;
RefPtr
<
nsXULPopupShownEvent
>
mPopupShownDispatcher
;
nsRect
mUsedScreenRect
;
nsSize
mPrefSize
{
-
1
-
1
}
;
nsPoint
mExtraMargin
;
nsRect
mScreenRect
;
nsRect
mUntransformedAnchorRect
;
nscoord
mAlignmentOffset
=
0
;
mozilla
:
:
LayoutDeviceIntPoint
mLastClientOffset
;
PopupType
mPopupType
=
PopupType
:
:
Panel
;
nsPopupState
mPopupState
=
ePopupClosed
;
int8_t
mPopupAlignment
=
POPUPALIGNMENT_NONE
;
int8_t
mPopupAnchor
=
POPUPALIGNMENT_NONE
;
int8_t
mPosition
=
POPUPPOSITION_UNKNOWN
;
FlipType
mFlip
=
FlipType_Default
;
bool
mPositionedByMoveToRect
=
false
;
bool
mIsOpenChanged
=
false
;
bool
mIsContextMenu
=
false
;
bool
mIsTopLevelContextMenu
=
false
;
bool
mInContentShell
=
true
;
bool
mHFlip
=
false
;
bool
mVFlip
=
false
;
bool
mConstrainedByLayout
=
false
;
bool
mIsNativeMenu
=
false
;
bool
mPendingPositionedEvent
=
false
;
bool
mIsDragSource
=
false
;
mutable
nscoord
mPositionedOffset
=
0
;
MenuPopupAnchorType
mAnchorType
=
MenuPopupAnchorType
:
:
Node
;
nsRect
mOverrideConstraintRect
;
static
int8_t
sDefaultLevelIsTop
;
static
mozilla
:
:
TimeStamp
sLastKeyTime
;
}
;
#
endif
