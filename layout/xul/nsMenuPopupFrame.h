#
ifndef
nsMenuPopupFrame_h__
#
define
nsMenuPopupFrame_h__
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
mozilla
/
StaticPrefs_ui
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsMenuFrame
.
h
"
#
include
"
nsBoxFrame
.
h
"
#
include
"
nsMenuParent
.
h
"
#
include
"
Units
.
h
"
class
nsIWidget
;
namespace
mozilla
{
class
PresShell
;
namespace
dom
{
class
KeyboardEvent
;
}
}
enum
ConsumeOutsideClicksResult
{
ConsumeOutsideClicks_ParentOnly
=
0
ConsumeOutsideClicks_True
=
1
ConsumeOutsideClicks_Never
=
2
}
;
enum
FlipStyle
{
FlipStyle_None
=
0
FlipStyle_Outside
=
1
FlipStyle_Inside
=
2
}
;
enum
FlipType
{
FlipType_Default
=
0
FlipType_None
=
1
FlipType_Both
=
2
FlipType_Slide
=
3
}
;
enum
MenuPopupAnchorType
{
MenuPopupAnchorType_Node
=
0
MenuPopupAnchorType_Point
=
1
MenuPopupAnchorType_Rect
=
2
}
;
#
define
POPUPALIGNMENT_NONE
0
#
define
POPUPALIGNMENT_TOPLEFT
1
#
define
POPUPALIGNMENT_TOPRIGHT
-
1
#
define
POPUPALIGNMENT_BOTTOMLEFT
2
#
define
POPUPALIGNMENT_BOTTOMRIGHT
-
2
#
define
POPUPALIGNMENT_LEFTCENTER
16
#
define
POPUPALIGNMENT_RIGHTCENTER
-
16
#
define
POPUPALIGNMENT_TOPCENTER
17
#
define
POPUPALIGNMENT_BOTTOMCENTER
18
#
define
POPUPPOSITION_UNKNOWN
-
1
#
define
POPUPPOSITION_BEFORESTART
0
#
define
POPUPPOSITION_BEFOREEND
1
#
define
POPUPPOSITION_AFTERSTART
2
#
define
POPUPPOSITION_AFTEREND
3
#
define
POPUPPOSITION_STARTBEFORE
4
#
define
POPUPPOSITION_ENDBEFORE
5
#
define
POPUPPOSITION_STARTAFTER
6
#
define
POPUPPOSITION_ENDAFTER
7
#
define
POPUPPOSITION_OVERLAP
8
#
define
POPUPPOSITION_AFTERPOINTER
9
#
define
POPUPPOSITION_SELECTION
10
#
define
POPUPPOSITION_HFLIP
(
v
)
(
v
^
1
)
#
define
POPUPPOSITION_VFLIP
(
v
)
(
v
^
2
)
nsIFrame
*
NS_NewMenuPopupFrame
(
mozilla
:
:
PresShell
*
aPresShell
mozilla
:
:
ComputedStyle
*
aStyle
)
;
class
nsView
;
class
nsMenuPopupFrame
;
class
nsXULPopupShownEvent
final
:
public
mozilla
:
:
Runnable
public
nsIDOMEventListener
{
public
:
nsXULPopupShownEvent
(
nsIContent
*
aPopup
nsPresContext
*
aPresContext
)
:
mozilla
:
:
Runnable
(
"
nsXULPopupShownEvent
"
)
mPopup
(
aPopup
)
mPresContext
(
aPresContext
)
{
}
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_NSIRUNNABLE
NS_DECL_NSIDOMEVENTLISTENER
void
CancelListener
(
)
;
protected
:
virtual
~
nsXULPopupShownEvent
(
)
=
default
;
private
:
const
nsCOMPtr
<
nsIContent
>
mPopup
;
const
RefPtr
<
nsPresContext
>
mPresContext
;
}
;
class
nsMenuPopupFrame
final
:
public
nsBoxFrame
public
nsMenuParent
public
nsIReflowCallback
{
public
:
NS_DECL_QUERYFRAME
NS_DECL_FRAMEARENA_HELPERS
(
nsMenuPopupFrame
)
explicit
nsMenuPopupFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
;
~
nsMenuPopupFrame
(
)
;
virtual
nsMenuFrame
*
GetCurrentMenuItem
(
)
override
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
NS_IMETHOD
SetCurrentMenuItem
(
nsMenuFrame
*
aMenuItem
)
override
;
virtual
void
CurrentMenuIsBeingDestroyed
(
)
override
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
NS_IMETHOD
ChangeMenuItem
(
nsMenuFrame
*
aMenuItem
bool
aSelectFirstItem
bool
aFromKey
)
override
;
nsPopupState
PopupState
(
)
{
return
mPopupState
;
}
void
SetPopupState
(
nsPopupState
)
;
NS_IMETHOD
SetActive
(
bool
aActiveFlag
)
override
{
return
NS_OK
;
}
virtual
bool
IsActive
(
)
override
{
return
false
;
}
virtual
bool
IsMenuBar
(
)
override
{
return
false
;
}
ConsumeOutsideClicksResult
ConsumeOutsideClicks
(
)
;
bool
IsContextMenu
(
)
override
{
return
mIsContextMenu
;
}
bool
MenuClosed
(
)
override
{
return
true
;
}
void
LockMenuUntilClosed
(
bool
aLock
)
override
;
bool
IsMenuLocked
(
)
override
{
return
mIsMenuLocked
;
}
nsIWidget
*
GetWidget
(
)
const
;
virtual
void
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
override
;
virtual
nsresult
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
override
;
virtual
void
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
override
;
bool
HasRemoteContent
(
)
const
;
bool
ShouldCreateWidgetUpfront
(
)
const
;
bool
IsNoAutoHide
(
)
const
;
nsPopupLevel
PopupLevel
(
)
const
{
return
PopupLevel
(
IsNoAutoHide
(
)
)
;
}
void
EnsureWidget
(
bool
aRecreate
=
false
)
;
nsresult
CreateWidgetForView
(
nsView
*
aView
)
;
mozilla
:
:
StyleWindowShadow
GetShadowStyle
(
)
;
void
DidSetComputedStyle
(
ComputedStyle
*
aOldStyle
)
override
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
LayoutPopup
(
nsBoxLayoutState
&
aState
nsIFrame
*
aParentMenu
bool
aSizedToPopup
)
;
nsresult
SetPopupPosition
(
nsIFrame
*
aAnchorFrame
bool
aIsMove
bool
aSizedToPopup
)
;
nsMenuFrame
*
Enter
(
mozilla
:
:
WidgetGUIEvent
*
aEvent
)
;
nsPopupType
PopupType
(
)
const
{
return
mPopupType
;
}
bool
IsMenu
(
)
override
{
return
mPopupType
=
=
ePopupTypeMenu
;
}
bool
IsOpen
(
)
override
{
return
mPopupState
=
=
ePopupOpening
|
|
mPopupState
=
=
ePopupVisible
|
|
mPopupState
=
=
ePopupShown
;
}
bool
IsVisible
(
)
{
return
mPopupState
=
=
ePopupVisible
|
|
mPopupState
=
=
ePopupShown
;
}
bool
IsVisibleOrShowing
(
)
{
return
IsOpen
(
)
|
|
mPopupState
=
=
ePopupPositioning
|
|
mPopupState
=
=
ePopupShowing
;
}
bool
IsNativeMenu
(
)
const
{
return
mIsNativeMenu
;
}
bool
IsMouseTransparent
(
)
const
;
bool
IsMenuList
(
)
;
static
nsIContent
*
GetTriggerContent
(
nsMenuPopupFrame
*
aMenuPopupFrame
)
;
void
ClearTriggerContent
(
)
{
mTriggerContent
=
nullptr
;
}
void
ClearTriggerContentIncludingDocument
(
)
;
bool
IsInContentShell
(
)
{
return
mInContentShell
;
}
void
InitializePopup
(
nsIContent
*
aAnchorContent
nsIContent
*
aTriggerContent
const
nsAString
&
aPosition
int32_t
aXPos
int32_t
aYPos
MenuPopupAnchorType
aAnchorType
bool
aAttributesOverride
)
;
void
InitializePopupAtRect
(
nsIContent
*
aTriggerContent
const
nsAString
&
aPosition
const
nsIntRect
&
aRect
bool
aAttributesOverride
)
;
void
InitializePopupAtScreen
(
nsIContent
*
aTriggerContent
int32_t
aXPos
int32_t
aYPos
bool
aIsContextMenu
)
;
void
InitializePopupAsNativeContextMenu
(
nsIContent
*
aTriggerContent
int32_t
aXPos
int32_t
aYPos
)
;
void
ShowPopup
(
bool
aIsContextMenu
)
;
void
HidePopup
(
bool
aDeselectMenu
nsPopupState
aNewState
)
;
nsMenuFrame
*
FindMenuWithShortcut
(
mozilla
:
:
dom
:
:
KeyboardEvent
*
aKeyEvent
bool
&
doAction
)
;
void
ClearIncrementalString
(
)
{
mIncrementalString
.
Truncate
(
)
;
}
static
bool
IsWithinIncrementalTime
(
DOMTimeStamp
time
)
{
return
time
-
sLastKeyTime
<
=
mozilla
:
:
StaticPrefs
:
:
ui_menu_incremental_search_timeout
(
)
;
}
#
ifdef
DEBUG_FRAME_DUMP
virtual
nsresult
GetFrameName
(
nsAString
&
aResult
)
const
override
{
return
MakeFrameName
(
u
"
MenuPopup
"
_ns
aResult
)
;
}
#
endif
MOZ_CAN_RUN_SCRIPT
void
EnsureMenuItemIsVisible
(
nsMenuFrame
*
aMenuFrame
)
;
void
ChangeByPage
(
bool
aIsUp
)
;
void
MoveTo
(
const
mozilla
:
:
CSSPoint
&
aPos
bool
aUpdateAttrs
bool
aByMoveToRect
=
false
)
;
void
MoveToAnchor
(
nsIContent
*
aAnchorContent
const
nsAString
&
aPosition
int32_t
aXPos
int32_t
aYPos
bool
aAttributesOverride
)
;
bool
GetAutoPosition
(
)
;
void
SetAutoPosition
(
bool
aShouldAutoPosition
)
;
nsIScrollableFrame
*
GetScrollFrame
(
nsIFrame
*
aStart
)
;
void
SetOverrideConstraintRect
(
mozilla
:
:
LayoutDeviceIntRect
aRect
)
{
mOverrideConstraintRect
=
ToAppUnits
(
aRect
mozilla
:
:
AppUnitsPerCSSPixel
(
)
)
;
}
mozilla
:
:
LayoutDeviceIntRect
GetConstraintRect
(
const
mozilla
:
:
LayoutDeviceIntRect
&
aAnchorRect
const
mozilla
:
:
LayoutDeviceIntRect
&
aRootScreenRect
nsPopupLevel
aPopupLevel
)
;
void
CanAdjustEdges
(
mozilla
:
:
Side
aHorizontalSide
mozilla
:
:
Side
aVerticalSide
mozilla
:
:
LayoutDeviceIntPoint
&
aChange
)
;
bool
IsAnchored
(
)
const
{
return
mAnchorType
!
=
MenuPopupAnchorType_Point
;
}
nsIContent
*
GetAnchor
(
)
const
{
return
mAnchorContent
;
}
mozilla
:
:
CSSIntRect
GetScreenAnchorRect
(
)
const
{
return
mozilla
:
:
CSSRect
:
:
FromAppUnitsRounded
(
mScreenRect
)
;
}
mozilla
:
:
LayoutDeviceIntPoint
GetLastClientOffset
(
)
const
{
return
mLastClientOffset
;
}
int8_t
GetAlignmentPosition
(
)
const
;
nscoord
GetAlignmentOffset
(
)
const
{
return
mAlignmentOffset
;
}
bool
ClearPopupShownDispatcher
(
)
{
if
(
mPopupShownDispatcher
)
{
mPopupShownDispatcher
-
>
CancelListener
(
)
;
mPopupShownDispatcher
=
nullptr
;
return
true
;
}
return
false
;
}
void
ShowWithPositionedEvent
(
)
{
mPopupState
=
ePopupPositioning
;
mShouldAutoPosition
=
true
;
}
void
CheckForAnchorChange
(
nsRect
&
aRect
)
;
void
WillDispatchPopupPositioned
(
)
{
mPendingPositionedEvent
=
false
;
}
virtual
bool
ReflowFinished
(
)
override
;
virtual
void
ReflowCallbackCanceled
(
)
override
;
protected
:
nsPopupLevel
PopupLevel
(
bool
aIsNoAutoHide
)
const
;
void
ConstrainSizeForWayland
(
nsSize
&
)
const
;
ReflowChildFlags
GetXULLayoutFlags
(
)
override
;
void
InitPositionFromAnchorAlign
(
const
nsAString
&
aAnchor
const
nsAString
&
aAlign
)
;
nsPoint
AdjustPositionForAnchorAlign
(
nsRect
&
anchorRect
FlipStyle
&
aHFlip
FlipStyle
&
aVFlip
)
;
nsIFrame
*
GetSelectedItemForAlignment
(
)
;
nscoord
FlipOrResize
(
nscoord
&
aScreenPoint
nscoord
aSize
nscoord
aScreenBegin
nscoord
aScreenEnd
nscoord
aAnchorBegin
nscoord
aAnchorEnd
nscoord
aMarginBegin
nscoord
aMarginEnd
FlipStyle
aFlip
bool
aIsOnEnd
bool
*
aFlipSide
)
;
nscoord
SlideOrResize
(
nscoord
&
aScreenPoint
nscoord
aSize
nscoord
aScreenBegin
nscoord
aScreenEnd
nscoord
*
aOffset
)
;
nsRect
ComputeAnchorRect
(
nsPresContext
*
aRootPresContext
nsIFrame
*
aAnchorFrame
)
;
void
MoveToAttributePosition
(
)
;
void
CreatePopupView
(
)
;
nsView
*
GetViewInternal
(
)
const
override
{
return
mView
;
}
void
SetViewInternal
(
nsView
*
aView
)
override
{
mView
=
aView
;
}
bool
ShouldFollowAnchor
(
)
;
public
:
bool
IsDirectionRTL
(
)
const
{
return
mAnchorContent
&
&
mAnchorContent
-
>
GetPrimaryFrame
(
)
?
mAnchorContent
-
>
GetPrimaryFrame
(
)
-
>
StyleVisibility
(
)
-
>
mDirection
=
=
mozilla
:
:
StyleDirection
:
:
Rtl
:
StyleVisibility
(
)
-
>
mDirection
=
=
mozilla
:
:
StyleDirection
:
:
Rtl
;
}
bool
ShouldFollowAnchor
(
nsRect
&
aRect
)
;
nsIWidget
*
GetParentMenuWidget
(
)
;
nsMargin
GetMargin
(
)
const
;
const
nsRect
&
GetUntransformedAnchorRect
(
)
const
{
return
mUntransformedAnchorRect
;
}
int
GetPopupAlignment
(
)
const
{
return
mPopupAlignment
;
}
int
GetPopupAnchor
(
)
const
{
return
mPopupAnchor
;
}
FlipType
GetFlipType
(
)
const
{
return
mFlip
;
}
void
WidgetPositionOrSizeDidChange
(
)
;
protected
:
nsString
mIncrementalString
;
nsCOMPtr
<
nsIContent
>
mAnchorContent
;
nsCOMPtr
<
nsIContent
>
mTriggerContent
;
nsMenuFrame
*
mCurrentMenu
;
nsView
*
mView
;
RefPtr
<
nsXULPopupShownEvent
>
mPopupShownDispatcher
;
nsIntRect
mUsedScreenRect
;
nsSize
mPrefSize
;
int32_t
mXPos
;
int32_t
mYPos
;
nsRect
mScreenRect
;
nsRect
mUntransformedAnchorRect
;
bool
mPositionedByMoveToRect
=
false
;
bool
mSizedToPopup
=
false
;
nscoord
mAlignmentOffset
;
mozilla
:
:
LayoutDeviceIntPoint
mLastClientOffset
;
nsPopupType
mPopupType
;
nsPopupState
mPopupState
;
int8_t
mPopupAlignment
;
int8_t
mPopupAnchor
;
int8_t
mPosition
;
FlipType
mFlip
;
struct
ReflowCallbackData
{
ReflowCallbackData
(
)
:
mPosted
(
false
)
mAnchor
(
nullptr
)
mIsOpenChanged
(
false
)
{
}
void
MarkPosted
(
nsIFrame
*
aAnchor
bool
aIsOpenChanged
)
{
mPosted
=
true
;
mAnchor
=
aAnchor
;
mIsOpenChanged
=
aIsOpenChanged
;
}
void
Clear
(
)
{
mPosted
=
false
;
mAnchor
=
nullptr
;
mIsOpenChanged
=
false
;
}
bool
mPosted
;
nsIFrame
*
mAnchor
;
bool
mIsOpenChanged
;
}
;
ReflowCallbackData
mReflowCallbackData
;
bool
mIsOpenChanged
;
bool
mIsContextMenu
=
false
;
bool
mIsTopLevelContextMenu
=
false
;
bool
mMenuCanOverlapOSBar
;
bool
mShouldAutoPosition
;
bool
mInContentShell
;
bool
mIsMenuLocked
;
bool
mIsOffset
;
bool
mHFlip
;
bool
mVFlip
;
bool
mIsNativeMenu
=
false
;
bool
mPendingPositionedEvent
=
false
;
nscoord
mPositionedOffset
;
MenuPopupAnchorType
mAnchorType
;
nsRect
mOverrideConstraintRect
;
static
int8_t
sDefaultLevelIsTop
;
static
DOMTimeStamp
sLastKeyTime
;
}
;
#
endif
