#
include
"
nsScrollbarFrame
.
h
"
#
include
"
nsSliderFrame
.
h
"
#
include
"
nsScrollbarButtonFrame
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsIScrollbarMediator
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
nsThemeConstants
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
mozilla
/
dom
/
MutationEventBinding
.
h
"
using
namespace
mozilla
;
nsIFrame
*
NS_NewScrollbarFrame
(
nsIPresShell
*
aPresShell
nsStyleContext
*
aContext
)
{
return
new
(
aPresShell
)
nsScrollbarFrame
(
aContext
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsScrollbarFrame
)
NS_QUERYFRAME_HEAD
(
nsScrollbarFrame
)
NS_QUERYFRAME_ENTRY
(
nsScrollbarFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsBoxFrame
)
void
nsScrollbarFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
nsBoxFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
AddStateBits
(
NS_FRAME_REFLOW_ROOT
)
;
}
void
nsScrollbarFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
nsBoxFrame
:
:
Reflow
(
aPresContext
aDesiredSize
aReflowInput
aStatus
)
;
if
(
aReflowInput
.
AvailableWidth
(
)
=
=
0
)
{
aDesiredSize
.
Width
(
)
=
0
;
}
if
(
aReflowInput
.
AvailableHeight
(
)
=
=
0
)
{
aDesiredSize
.
Height
(
)
=
0
;
}
}
nsresult
nsScrollbarFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
nsresult
rv
=
nsBoxFrame
:
:
AttributeChanged
(
aNameSpaceID
aAttribute
aModType
)
;
if
(
aAttribute
!
=
nsGkAtoms
:
:
curpos
)
return
rv
;
nsIScrollableFrame
*
scrollable
=
do_QueryFrame
(
GetParent
(
)
)
;
if
(
!
scrollable
)
return
rv
;
nsCOMPtr
<
nsIContent
>
content
(
mContent
)
;
scrollable
-
>
CurPosAttributeChanged
(
content
)
;
return
rv
;
}
NS_IMETHODIMP
nsScrollbarFrame
:
:
HandlePress
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
{
return
NS_OK
;
}
NS_IMETHODIMP
nsScrollbarFrame
:
:
HandleMultiplePress
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
bool
aControlHeld
)
{
return
NS_OK
;
}
NS_IMETHODIMP
nsScrollbarFrame
:
:
HandleDrag
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
{
return
NS_OK
;
}
NS_IMETHODIMP
nsScrollbarFrame
:
:
HandleRelease
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
{
return
NS_OK
;
}
void
nsScrollbarFrame
:
:
SetScrollbarMediatorContent
(
nsIContent
*
aMediator
)
{
mScrollbarMediator
=
aMediator
;
}
nsIScrollbarMediator
*
nsScrollbarFrame
:
:
GetScrollbarMediator
(
)
{
if
(
!
mScrollbarMediator
)
{
return
nullptr
;
}
nsIFrame
*
f
=
mScrollbarMediator
-
>
GetPrimaryFrame
(
)
;
nsIScrollableFrame
*
scrollFrame
=
do_QueryFrame
(
f
)
;
nsIScrollbarMediator
*
sbm
;
if
(
scrollFrame
)
{
nsIFrame
*
scrolledFrame
=
scrollFrame
-
>
GetScrolledFrame
(
)
;
sbm
=
do_QueryFrame
(
scrolledFrame
)
;
if
(
sbm
)
{
return
sbm
;
}
}
sbm
=
do_QueryFrame
(
f
)
;
if
(
f
&
&
!
sbm
)
{
f
=
f
-
>
PresShell
(
)
-
>
GetRootScrollFrame
(
)
;
if
(
f
&
&
f
-
>
GetContent
(
)
=
=
mScrollbarMediator
)
{
return
do_QueryFrame
(
f
)
;
}
}
return
sbm
;
}
nsresult
nsScrollbarFrame
:
:
GetXULMargin
(
nsMargin
&
aMargin
)
{
nsresult
rv
=
NS_ERROR_FAILURE
;
aMargin
.
SizeTo
(
0
0
0
0
)
;
if
(
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
eIntID_UseOverlayScrollbars
)
!
=
0
)
{
nsPresContext
*
presContext
=
PresContext
(
)
;
nsITheme
*
theme
=
presContext
-
>
GetTheme
(
)
;
if
(
theme
&
&
theme
-
>
ThemeSupportsWidget
(
presContext
this
NS_THEME_SCROLLBAR
)
)
{
LayoutDeviceIntSize
size
;
bool
isOverridable
;
theme
-
>
GetMinimumWidgetSize
(
presContext
this
NS_THEME_SCROLLBAR
&
size
&
isOverridable
)
;
if
(
IsXULHorizontal
(
)
)
{
aMargin
.
top
=
-
presContext
-
>
DevPixelsToAppUnits
(
size
.
height
)
;
}
else
{
aMargin
.
left
=
-
presContext
-
>
DevPixelsToAppUnits
(
size
.
width
)
;
}
rv
=
NS_OK
;
}
}
if
(
NS_FAILED
(
rv
)
)
{
rv
=
nsBox
:
:
GetXULMargin
(
aMargin
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
IsXULHorizontal
(
)
)
{
nsIScrollbarMediator
*
scrollFrame
=
GetScrollbarMediator
(
)
;
if
(
scrollFrame
&
&
!
scrollFrame
-
>
IsScrollbarOnRight
(
)
)
{
Swap
(
aMargin
.
left
aMargin
.
right
)
;
}
}
return
rv
;
}
void
nsScrollbarFrame
:
:
SetIncrementToLine
(
int32_t
aDirection
)
{
nsIContent
*
content
=
GetContent
(
)
;
mSmoothScroll
=
true
;
mIncrement
=
aDirection
*
nsSliderFrame
:
:
GetIncrement
(
content
)
;
}
void
nsScrollbarFrame
:
:
SetIncrementToPage
(
int32_t
aDirection
)
{
nsIContent
*
content
=
GetContent
(
)
;
mSmoothScroll
=
true
;
mIncrement
=
aDirection
*
nsSliderFrame
:
:
GetPageIncrement
(
content
)
;
}
void
nsScrollbarFrame
:
:
SetIncrementToWhole
(
int32_t
aDirection
)
{
nsIContent
*
content
=
GetContent
(
)
;
if
(
aDirection
=
=
-
1
)
mIncrement
=
-
nsSliderFrame
:
:
GetCurrentPosition
(
content
)
;
else
mIncrement
=
nsSliderFrame
:
:
GetMaxPosition
(
content
)
-
nsSliderFrame
:
:
GetCurrentPosition
(
content
)
;
mSmoothScroll
=
false
;
}
int32_t
nsScrollbarFrame
:
:
MoveToNewPosition
(
)
{
RefPtr
<
Element
>
content
=
GetContent
(
)
-
>
AsElement
(
)
;
int32_t
curpos
=
nsSliderFrame
:
:
GetCurrentPosition
(
content
)
;
int32_t
maxpos
=
nsSliderFrame
:
:
GetMaxPosition
(
content
)
;
if
(
mIncrement
)
{
curpos
+
=
mIncrement
;
}
if
(
curpos
<
0
)
{
curpos
=
0
;
}
else
if
(
curpos
>
maxpos
)
{
curpos
=
maxpos
;
}
nsAutoString
curposStr
;
curposStr
.
AppendInt
(
curpos
)
;
AutoWeakFrame
weakFrame
(
this
)
;
if
(
mSmoothScroll
)
{
content
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
smooth
NS_LITERAL_STRING
(
"
true
"
)
false
)
;
}
content
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
curpos
curposStr
false
)
;
AttributeChanged
(
kNameSpaceID_None
nsGkAtoms
:
:
curpos
dom
:
:
MutationEventBinding
:
:
MODIFICATION
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
curpos
;
}
nsIFrame
:
:
ChildListIterator
childLists
(
this
)
;
for
(
;
!
childLists
.
IsDone
(
)
;
childLists
.
Next
(
)
)
{
nsFrameList
:
:
Enumerator
childFrames
(
childLists
.
CurrentList
(
)
)
;
for
(
;
!
childFrames
.
AtEnd
(
)
;
childFrames
.
Next
(
)
)
{
nsIFrame
*
f
=
childFrames
.
get
(
)
;
nsSliderFrame
*
sliderFrame
=
do_QueryFrame
(
f
)
;
if
(
sliderFrame
)
{
sliderFrame
-
>
AttributeChanged
(
kNameSpaceID_None
nsGkAtoms
:
:
curpos
dom
:
:
MutationEventBinding
:
:
MODIFICATION
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
curpos
;
}
}
}
}
content
-
>
UnsetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
smooth
false
)
;
return
curpos
;
}
