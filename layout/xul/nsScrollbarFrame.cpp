#
include
"
nsScrollbarFrame
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
ScrollContainerFrame
.
h
"
#
include
"
mozilla
/
StaticPrefs_apz
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
MutationEventBinding
.
h
"
#
include
"
nsContentCreatorFunctions
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIScrollbarMediator
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsScrollbarButtonFrame
.
h
"
#
include
"
nsSliderFrame
.
h
"
#
include
"
nsStyleConsts
.
h
"
using
namespace
mozilla
;
using
mozilla
:
:
dom
:
:
Element
;
nsIFrame
*
NS_NewScrollbarFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsScrollbarFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsScrollbarFrame
)
NS_QUERYFRAME_HEAD
(
nsScrollbarFrame
)
NS_QUERYFRAME_ENTRY
(
nsScrollbarFrame
)
NS_QUERYFRAME_ENTRY
(
nsIAnonymousContentCreator
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsContainerFrame
)
void
nsScrollbarFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
nsContainerFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
AddStateBits
(
NS_FRAME_REFLOW_ROOT
)
;
}
nsScrollbarFrame
*
nsScrollbarFrame
:
:
GetOppositeScrollbar
(
)
const
{
ScrollContainerFrame
*
sc
=
do_QueryFrame
(
GetParent
(
)
)
;
if
(
!
sc
)
{
return
nullptr
;
}
auto
*
vScrollbar
=
sc
-
>
GetScrollbarBox
(
true
)
;
if
(
vScrollbar
=
=
this
)
{
return
sc
-
>
GetScrollbarBox
(
false
)
;
}
MOZ_ASSERT
(
sc
-
>
GetScrollbarBox
(
false
)
=
=
this
"
Which
scrollbar
are
we
?
"
)
;
return
vScrollbar
;
}
void
nsScrollbarFrame
:
:
InvalidateForHoverChange
(
bool
aIsNowHovered
)
{
InvalidateFrameSubtree
(
)
;
if
(
!
aIsNowHovered
)
{
return
;
}
mHasBeenHovered
=
true
;
if
(
auto
*
opposite
=
GetOppositeScrollbar
(
)
;
opposite
&
&
opposite
-
>
mHasBeenHovered
)
{
opposite
-
>
mHasBeenHovered
=
false
;
opposite
-
>
InvalidateFrameSubtree
(
)
;
}
}
void
nsScrollbarFrame
:
:
ActivityChanged
(
bool
aIsNowActive
)
{
if
(
ScrollContainerFrame
*
sc
=
do_QueryFrame
(
GetParent
(
)
)
)
{
if
(
aIsNowActive
)
{
sc
-
>
ScrollbarActivityStarted
(
)
;
}
else
{
sc
-
>
ScrollbarActivityStopped
(
)
;
}
}
}
void
nsScrollbarFrame
:
:
ElementStateChanged
(
dom
:
:
ElementState
aStates
)
{
if
(
aStates
.
HasState
(
dom
:
:
ElementState
:
:
HOVER
)
)
{
const
bool
hovered
=
mContent
-
>
AsElement
(
)
-
>
State
(
)
.
HasState
(
dom
:
:
ElementState
:
:
HOVER
)
;
InvalidateForHoverChange
(
hovered
)
;
ActivityChanged
(
hovered
)
;
}
}
void
nsScrollbarFrame
:
:
WillBecomeActive
(
)
{
mHasBeenHovered
=
false
;
}
void
nsScrollbarFrame
:
:
Destroy
(
DestroyContext
&
aContext
)
{
aContext
.
AddAnonymousContent
(
mUpTopButton
.
forget
(
)
)
;
aContext
.
AddAnonymousContent
(
mDownTopButton
.
forget
(
)
)
;
aContext
.
AddAnonymousContent
(
mSlider
.
forget
(
)
)
;
aContext
.
AddAnonymousContent
(
mUpBottomButton
.
forget
(
)
)
;
aContext
.
AddAnonymousContent
(
mDownBottomButton
.
forget
(
)
)
;
nsContainerFrame
:
:
Destroy
(
aContext
)
;
}
void
nsScrollbarFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
const
bool
horizontal
=
IsHorizontal
(
)
;
const
auto
wm
=
GetWritingMode
(
)
;
const
auto
minSize
=
aReflowInput
.
ComputedMinSize
(
)
;
aDesiredSize
.
ISize
(
wm
)
=
aReflowInput
.
ComputedISize
(
)
;
aDesiredSize
.
BSize
(
wm
)
=
[
&
]
{
if
(
aReflowInput
.
ComputedBSize
(
)
!
=
NS_UNCONSTRAINEDSIZE
)
{
return
aReflowInput
.
ComputedBSize
(
)
;
}
if
(
!
aReflowInput
.
mParentReflowInput
)
{
return
GetLogicalSize
(
wm
)
.
BSize
(
wm
)
;
}
return
minSize
.
BSize
(
wm
)
;
}
(
)
;
const
nsSize
containerSize
=
aDesiredSize
.
PhysicalSize
(
)
;
const
LogicalSize
totalAvailSize
=
aDesiredSize
.
Size
(
wm
)
;
LogicalPoint
nextKidPos
(
wm
)
;
MOZ_ASSERT
(
!
wm
.
IsVertical
(
)
)
;
const
bool
movesInInlineDirection
=
horizontal
;
for
(
nsIFrame
*
kid
:
mFrames
)
{
MOZ_ASSERT
(
!
kid
-
>
GetWritingMode
(
)
.
IsOrthogonalTo
(
wm
)
"
We
don
'
t
expect
orthogonal
scrollbar
parts
"
)
;
const
bool
isSlider
=
kid
-
>
GetContent
(
)
=
=
mSlider
;
LogicalSize
availSize
=
totalAvailSize
;
{
const
int32_t
factor
=
isSlider
?
2
:
1
;
if
(
movesInInlineDirection
)
{
availSize
.
ISize
(
wm
)
=
std
:
:
max
(
0
totalAvailSize
.
ISize
(
wm
)
-
nextKidPos
.
I
(
wm
)
*
factor
)
;
}
else
{
availSize
.
BSize
(
wm
)
=
std
:
:
max
(
0
totalAvailSize
.
BSize
(
wm
)
-
nextKidPos
.
B
(
wm
)
*
factor
)
;
}
}
ReflowInput
kidRI
(
aPresContext
aReflowInput
kid
availSize
)
;
if
(
isSlider
)
{
kidRI
.
SetComputedISize
(
availSize
.
ISize
(
wm
)
)
;
kidRI
.
SetComputedBSize
(
availSize
.
BSize
(
wm
)
)
;
}
else
if
(
movesInInlineDirection
)
{
kidRI
.
SetComputedBSize
(
availSize
.
BSize
(
wm
)
)
;
}
else
{
kidRI
.
SetComputedISize
(
availSize
.
ISize
(
wm
)
)
;
}
ReflowOutput
kidDesiredSize
(
wm
)
;
nsReflowStatus
status
;
const
auto
flags
=
ReflowChildFlags
:
:
Default
;
ReflowChild
(
kid
aPresContext
kidDesiredSize
kidRI
wm
nextKidPos
containerSize
flags
status
)
;
FinishReflowChild
(
kid
aPresContext
kidDesiredSize
&
kidRI
wm
nextKidPos
containerSize
flags
)
;
if
(
movesInInlineDirection
)
{
nextKidPos
.
I
(
wm
)
+
=
kidDesiredSize
.
ISize
(
wm
)
;
}
else
{
nextKidPos
.
B
(
wm
)
+
=
kidDesiredSize
.
BSize
(
wm
)
;
}
}
aDesiredSize
.
SetOverflowAreasToDesiredBounds
(
)
;
}
nsresult
nsScrollbarFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
nsresult
rv
=
nsContainerFrame
:
:
AttributeChanged
(
aNameSpaceID
aAttribute
aModType
)
;
UpdateChildrenAttributeValue
(
aAttribute
true
)
;
if
(
aAttribute
!
=
nsGkAtoms
:
:
curpos
)
{
return
rv
;
}
ScrollContainerFrame
*
scrollContainerFrame
=
do_QueryFrame
(
GetParent
(
)
)
;
if
(
!
scrollContainerFrame
)
{
return
rv
;
}
nsCOMPtr
<
nsIContent
>
content
(
mContent
)
;
scrollContainerFrame
-
>
CurPosAttributeChanged
(
content
)
;
return
rv
;
}
NS_IMETHODIMP
nsScrollbarFrame
:
:
HandlePress
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
{
return
NS_OK
;
}
NS_IMETHODIMP
nsScrollbarFrame
:
:
HandleMultiplePress
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
bool
aControlHeld
)
{
return
NS_OK
;
}
NS_IMETHODIMP
nsScrollbarFrame
:
:
HandleDrag
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
{
return
NS_OK
;
}
NS_IMETHODIMP
nsScrollbarFrame
:
:
HandleRelease
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
{
return
NS_OK
;
}
void
nsScrollbarFrame
:
:
SetScrollbarMediatorContent
(
nsIContent
*
aMediator
)
{
mScrollbarMediator
=
aMediator
;
}
nsIScrollbarMediator
*
nsScrollbarFrame
:
:
GetScrollbarMediator
(
)
{
if
(
!
mScrollbarMediator
)
{
return
nullptr
;
}
nsIFrame
*
f
=
mScrollbarMediator
-
>
GetPrimaryFrame
(
)
;
ScrollContainerFrame
*
scrollContainerFrame
=
do_QueryFrame
(
f
)
;
nsIScrollbarMediator
*
sbm
;
if
(
scrollContainerFrame
)
{
nsIFrame
*
scrolledFrame
=
scrollContainerFrame
-
>
GetScrolledFrame
(
)
;
sbm
=
do_QueryFrame
(
scrolledFrame
)
;
if
(
sbm
)
{
return
sbm
;
}
}
sbm
=
do_QueryFrame
(
f
)
;
if
(
f
&
&
!
sbm
)
{
f
=
f
-
>
PresShell
(
)
-
>
GetRootScrollContainerFrame
(
)
;
if
(
f
&
&
f
-
>
GetContent
(
)
=
=
mScrollbarMediator
)
{
return
do_QueryFrame
(
f
)
;
}
}
return
sbm
;
}
bool
nsScrollbarFrame
:
:
IsHorizontal
(
)
const
{
auto
appearance
=
StyleDisplay
(
)
-
>
EffectiveAppearance
(
)
;
MOZ_ASSERT
(
appearance
=
=
StyleAppearance
:
:
ScrollbarHorizontal
|
|
appearance
=
=
StyleAppearance
:
:
ScrollbarVertical
)
;
return
appearance
=
=
StyleAppearance
:
:
ScrollbarHorizontal
;
}
nsSize
nsScrollbarFrame
:
:
ScrollbarMinSize
(
)
const
{
nsPresContext
*
pc
=
PresContext
(
)
;
const
LayoutDeviceIntSize
widget
=
pc
-
>
Theme
(
)
-
>
GetMinimumWidgetSize
(
pc
const_cast
<
nsScrollbarFrame
*
>
(
this
)
StyleDisplay
(
)
-
>
EffectiveAppearance
(
)
)
;
return
LayoutDeviceIntSize
:
:
ToAppUnits
(
widget
pc
-
>
AppUnitsPerDevPixel
(
)
)
;
}
StyleScrollbarWidth
nsScrollbarFrame
:
:
ScrollbarWidth
(
)
const
{
return
nsLayoutUtils
:
:
StyleForScrollbar
(
this
)
-
>
StyleUIReset
(
)
-
>
ScrollbarWidth
(
)
;
}
nscoord
nsScrollbarFrame
:
:
ScrollbarTrackSize
(
)
const
{
nsPresContext
*
pc
=
PresContext
(
)
;
auto
overlay
=
pc
-
>
UseOverlayScrollbars
(
)
?
nsITheme
:
:
Overlay
:
:
Yes
:
nsITheme
:
:
Overlay
:
:
No
;
return
LayoutDevicePixel
:
:
ToAppUnits
(
pc
-
>
Theme
(
)
-
>
GetScrollbarSize
(
pc
ScrollbarWidth
(
)
overlay
)
pc
-
>
AppUnitsPerDevPixel
(
)
)
;
}
void
nsScrollbarFrame
:
:
MoveToNewPosition
(
)
{
nsIScrollbarMediator
*
m
=
GetScrollbarMediator
(
)
;
if
(
!
m
)
{
return
;
}
m
-
>
ScrollByUnit
(
this
ScrollMode
:
:
Smooth
mButtonScrollDirection
mButtonScrollUnit
ScrollSnapFlags
:
:
IntendedDirection
)
;
}
static
already_AddRefed
<
Element
>
MakeScrollbarButton
(
dom
:
:
NodeInfo
*
aNodeInfo
bool
aVertical
bool
aBottom
bool
aDown
AnonymousContentKey
&
aKey
)
{
MOZ_ASSERT
(
aNodeInfo
)
;
MOZ_ASSERT
(
aNodeInfo
-
>
Equals
(
nsGkAtoms
:
:
scrollbarbutton
nullptr
kNameSpaceID_XUL
)
)
;
static
constexpr
nsLiteralString
kSbattrValues
[
2
]
[
2
]
=
{
{
u
"
scrollbar
-
up
-
top
"
_ns
u
"
scrollbar
-
up
-
bottom
"
_ns
}
{
u
"
scrollbar
-
down
-
top
"
_ns
u
"
scrollbar
-
down
-
bottom
"
_ns
}
}
;
static
constexpr
nsLiteralString
kTypeValues
[
2
]
=
{
u
"
decrement
"
_ns
u
"
increment
"
_ns
}
;
aKey
=
AnonymousContentKey
:
:
Type_ScrollbarButton
;
if
(
aVertical
)
{
aKey
|
=
AnonymousContentKey
:
:
Flag_Vertical
;
}
if
(
aBottom
)
{
aKey
|
=
AnonymousContentKey
:
:
Flag_ScrollbarButton_Bottom
;
}
if
(
aDown
)
{
aKey
|
=
AnonymousContentKey
:
:
Flag_ScrollbarButton_Down
;
}
RefPtr
<
Element
>
e
;
NS_TrustedNewXULElement
(
getter_AddRefs
(
e
)
do_AddRef
(
aNodeInfo
)
)
;
e
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
sbattr
kSbattrValues
[
aDown
]
[
aBottom
]
false
)
;
e
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
type
kTypeValues
[
aDown
]
false
)
;
return
e
.
forget
(
)
;
}
nsresult
nsScrollbarFrame
:
:
CreateAnonymousContent
(
nsTArray
<
ContentInfo
>
&
aElements
)
{
nsNodeInfoManager
*
nodeInfoManager
=
mContent
-
>
NodeInfo
(
)
-
>
NodeInfoManager
(
)
;
Element
*
el
=
GetContent
(
)
-
>
AsElement
(
)
;
if
(
el
-
>
HasChildren
(
)
)
{
return
NS_OK
;
}
nsAutoString
orient
;
el
-
>
GetAttr
(
nsGkAtoms
:
:
orient
orient
)
;
bool
vertical
=
orient
.
EqualsLiteral
(
"
vertical
"
)
;
RefPtr
<
dom
:
:
NodeInfo
>
sbbNodeInfo
=
nodeInfoManager
-
>
GetNodeInfo
(
nsGkAtoms
:
:
scrollbarbutton
nullptr
kNameSpaceID_XUL
nsINode
:
:
ELEMENT_NODE
)
;
bool
createButtons
=
PresContext
(
)
-
>
Theme
(
)
-
>
ThemeSupportsScrollbarButtons
(
)
;
if
(
createButtons
)
{
AnonymousContentKey
key
;
mUpTopButton
=
MakeScrollbarButton
(
sbbNodeInfo
vertical
false
false
key
)
;
aElements
.
AppendElement
(
ContentInfo
(
mUpTopButton
key
)
)
;
}
if
(
createButtons
)
{
AnonymousContentKey
key
;
mDownTopButton
=
MakeScrollbarButton
(
sbbNodeInfo
vertical
false
true
key
)
;
aElements
.
AppendElement
(
ContentInfo
(
mDownTopButton
key
)
)
;
}
{
AnonymousContentKey
key
=
AnonymousContentKey
:
:
Type_Slider
;
if
(
vertical
)
{
key
|
=
AnonymousContentKey
:
:
Flag_Vertical
;
}
NS_TrustedNewXULElement
(
getter_AddRefs
(
mSlider
)
nodeInfoManager
-
>
GetNodeInfo
(
nsGkAtoms
:
:
slider
nullptr
kNameSpaceID_XUL
nsINode
:
:
ELEMENT_NODE
)
)
;
mSlider
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
orient
orient
false
)
;
aElements
.
AppendElement
(
ContentInfo
(
mSlider
key
)
)
;
NS_TrustedNewXULElement
(
getter_AddRefs
(
mThumb
)
nodeInfoManager
-
>
GetNodeInfo
(
nsGkAtoms
:
:
thumb
nullptr
kNameSpaceID_XUL
nsINode
:
:
ELEMENT_NODE
)
)
;
mThumb
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
orient
orient
false
)
;
mSlider
-
>
AppendChildTo
(
mThumb
false
IgnoreErrors
(
)
)
;
}
if
(
createButtons
)
{
AnonymousContentKey
key
;
mUpBottomButton
=
MakeScrollbarButton
(
sbbNodeInfo
vertical
true
false
key
)
;
aElements
.
AppendElement
(
ContentInfo
(
mUpBottomButton
key
)
)
;
}
if
(
createButtons
)
{
AnonymousContentKey
key
;
mDownBottomButton
=
MakeScrollbarButton
(
sbbNodeInfo
vertical
true
true
key
)
;
aElements
.
AppendElement
(
ContentInfo
(
mDownBottomButton
key
)
)
;
}
if
(
GetContent
(
)
-
>
GetParent
(
)
&
&
GetContent
(
)
-
>
GetParent
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
select
)
)
{
for
(
auto
&
info
:
aElements
)
{
info
.
mKey
=
AnonymousContentKey
:
:
None
;
}
}
UpdateChildrenAttributeValue
(
nsGkAtoms
:
:
curpos
false
)
;
UpdateChildrenAttributeValue
(
nsGkAtoms
:
:
maxpos
false
)
;
UpdateChildrenAttributeValue
(
nsGkAtoms
:
:
disabled
false
)
;
UpdateChildrenAttributeValue
(
nsGkAtoms
:
:
pageincrement
false
)
;
return
NS_OK
;
}
void
nsScrollbarFrame
:
:
UpdateChildrenAttributeValue
(
nsAtom
*
aAttribute
bool
aNotify
)
{
Element
*
el
=
GetContent
(
)
-
>
AsElement
(
)
;
nsAutoString
value
;
el
-
>
GetAttr
(
aAttribute
value
)
;
if
(
!
el
-
>
HasAttr
(
aAttribute
)
)
{
if
(
mUpTopButton
)
{
mUpTopButton
-
>
UnsetAttr
(
kNameSpaceID_None
aAttribute
aNotify
)
;
}
if
(
mDownTopButton
)
{
mDownTopButton
-
>
UnsetAttr
(
kNameSpaceID_None
aAttribute
aNotify
)
;
}
if
(
mSlider
)
{
mSlider
-
>
UnsetAttr
(
kNameSpaceID_None
aAttribute
aNotify
)
;
}
if
(
mUpBottomButton
)
{
mUpBottomButton
-
>
UnsetAttr
(
kNameSpaceID_None
aAttribute
aNotify
)
;
}
if
(
mDownBottomButton
)
{
mDownBottomButton
-
>
UnsetAttr
(
kNameSpaceID_None
aAttribute
aNotify
)
;
}
return
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
curpos
|
|
aAttribute
=
=
nsGkAtoms
:
:
maxpos
)
{
if
(
mUpTopButton
)
{
mUpTopButton
-
>
SetAttr
(
kNameSpaceID_None
aAttribute
value
aNotify
)
;
}
if
(
mDownTopButton
)
{
mDownTopButton
-
>
SetAttr
(
kNameSpaceID_None
aAttribute
value
aNotify
)
;
}
if
(
mSlider
)
{
mSlider
-
>
SetAttr
(
kNameSpaceID_None
aAttribute
value
aNotify
)
;
}
if
(
mUpBottomButton
)
{
mUpBottomButton
-
>
SetAttr
(
kNameSpaceID_None
aAttribute
value
aNotify
)
;
}
if
(
mDownBottomButton
)
{
mDownBottomButton
-
>
SetAttr
(
kNameSpaceID_None
aAttribute
value
aNotify
)
;
}
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
disabled
)
{
if
(
mUpTopButton
)
{
mUpTopButton
-
>
SetAttr
(
kNameSpaceID_None
aAttribute
value
aNotify
)
;
}
if
(
mDownTopButton
)
{
mDownTopButton
-
>
SetAttr
(
kNameSpaceID_None
aAttribute
value
aNotify
)
;
}
if
(
mSlider
)
{
mSlider
-
>
SetAttr
(
kNameSpaceID_None
aAttribute
value
aNotify
)
;
}
if
(
mUpBottomButton
)
{
mUpBottomButton
-
>
SetAttr
(
kNameSpaceID_None
aAttribute
value
aNotify
)
;
}
if
(
mDownBottomButton
)
{
mDownBottomButton
-
>
SetAttr
(
kNameSpaceID_None
aAttribute
value
aNotify
)
;
}
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
pageincrement
)
{
if
(
mSlider
)
{
mSlider
-
>
SetAttr
(
kNameSpaceID_None
aAttribute
value
aNotify
)
;
}
}
}
void
nsScrollbarFrame
:
:
AppendAnonymousContentTo
(
nsTArray
<
nsIContent
*
>
&
aElements
uint32_t
aFilter
)
{
if
(
mUpTopButton
)
{
aElements
.
AppendElement
(
mUpTopButton
)
;
}
if
(
mDownTopButton
)
{
aElements
.
AppendElement
(
mDownTopButton
)
;
}
if
(
mSlider
)
{
aElements
.
AppendElement
(
mSlider
)
;
}
if
(
mUpBottomButton
)
{
aElements
.
AppendElement
(
mUpBottomButton
)
;
}
if
(
mDownBottomButton
)
{
aElements
.
AppendElement
(
mDownBottomButton
)
;
}
}
