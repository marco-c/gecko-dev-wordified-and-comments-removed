#
ifndef
nsMathMLContainerFrame_h___
#
define
nsMathMLContainerFrame_h___
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsBlockFrame
.
h
"
#
include
"
nsInlineFrame
.
h
"
#
include
"
nsMathMLOperators
.
h
"
#
include
"
nsMathMLFrame
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
define
STRETCH_CONSIDER_ACTUAL_SIZE
0x00000001
/
/
just
use
our
current
size
#
define
STRETCH_CONSIDER_EMBELLISHMENTS
\
0x00000002
/
/
size
calculations
include
embellishments
class
nsMathMLContainerFrame
:
public
nsContainerFrame
public
nsMathMLFrame
{
friend
class
nsMathMLmfencedFrame
;
public
:
nsMathMLContainerFrame
(
ComputedStyle
*
aStyle
ClassID
aID
)
:
nsContainerFrame
(
aStyle
aID
)
mIntrinsicWidth
(
NS_INTRINSIC_WIDTH_UNKNOWN
)
mBlockStartAscent
(
0
)
{
}
NS_DECL_QUERYFRAME_TARGET
(
nsMathMLContainerFrame
)
NS_DECL_QUERYFRAME
NS_DECL_ABSTRACT_FRAME
(
nsMathMLContainerFrame
)
NS_IMETHOD
Stretch
(
DrawTarget
*
aDrawTarget
nsStretchDirection
aStretchDirection
nsBoundingMetrics
&
aContainerSize
ReflowOutput
&
aDesiredStretchSize
)
override
;
NS_IMETHOD
UpdatePresentationDataFromChildAt
(
int32_t
aFirstIndex
int32_t
aLastIndex
uint32_t
aFlagsValues
uint32_t
aFlagsToUpdate
)
override
{
PropagatePresentationDataFromChildAt
(
this
aFirstIndex
aLastIndex
aFlagsValues
aFlagsToUpdate
)
;
return
NS_OK
;
}
virtual
bool
IsFrameOfType
(
uint32_t
aFlags
)
const
override
{
if
(
aFlags
&
(
eLineParticipant
|
eSupportsContainLayoutAndPaint
)
)
{
return
false
;
}
return
nsContainerFrame
:
:
IsFrameOfType
(
aFlags
&
~
(
eMathML
|
eExcludesIgnorableWhitespace
)
)
;
}
virtual
void
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
override
;
virtual
void
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
aFrameList
)
override
;
virtual
void
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
override
;
virtual
nscoord
GetMinISize
(
gfxContext
*
aRenderingContext
)
override
;
virtual
nscoord
GetPrefISize
(
gfxContext
*
aRenderingContext
)
override
;
virtual
void
GetIntrinsicISizeMetrics
(
gfxContext
*
aRenderingContext
ReflowOutput
&
aDesiredSize
)
;
virtual
void
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
override
;
virtual
void
DidReflow
(
nsPresContext
*
aPresContext
const
ReflowInput
*
aReflowInput
)
override
{
mPresentationData
.
flags
&
=
~
NS_MATHML_STRETCH_DONE
;
return
nsContainerFrame
:
:
DidReflow
(
aPresContext
aReflowInput
)
;
}
virtual
void
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
override
;
virtual
bool
ComputeCustomOverflow
(
nsOverflowAreas
&
aOverflowAreas
)
override
;
virtual
void
MarkIntrinsicISizesDirty
(
)
override
;
virtual
nsresult
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
override
;
nscoord
MirrorIfRTL
(
nscoord
aParentWidth
nscoord
aChildWidth
nscoord
aChildLeading
)
{
return
(
StyleVisibility
(
)
-
>
mDirection
?
aParentWidth
-
aChildWidth
-
aChildLeading
:
aChildLeading
)
;
}
protected
:
virtual
nsresult
Place
(
DrawTarget
*
aDrawTarget
bool
aPlaceOrigin
ReflowOutput
&
aDesiredSize
)
;
virtual
nsresult
MeasureForWidth
(
DrawTarget
*
aDrawTarget
ReflowOutput
&
aDesiredSize
)
;
virtual
nsresult
ChildListChanged
(
int32_t
aModType
)
;
void
GetPreferredStretchSize
(
DrawTarget
*
aDrawTarget
uint32_t
aOptions
nsStretchDirection
aStretchDirection
nsBoundingMetrics
&
aPreferredStretchSize
)
;
nsresult
TransmitAutomaticDataForMrowLikeElement
(
)
;
public
:
nsresult
ReflowError
(
DrawTarget
*
aDrawTarget
ReflowOutput
&
aDesiredSize
)
;
nsresult
ReportParseError
(
const
char16_t
*
aAttribute
const
char16_t
*
aValue
)
;
nsresult
ReportChildCountError
(
)
;
nsresult
ReportInvalidChildError
(
nsAtom
*
aChildTag
)
;
nsresult
ReportErrorToConsole
(
const
char
*
aErrorMsgId
const
char16_t
*
*
aParams
=
nullptr
uint32_t
aParamCount
=
0
)
;
void
ReflowChild
(
nsIFrame
*
aKidFrame
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
;
protected
:
virtual
nscoord
FixInterFrameSpacing
(
ReflowOutput
&
aDesiredSize
)
;
virtual
nsresult
FinalizeReflow
(
DrawTarget
*
aDrawTarget
ReflowOutput
&
aDesiredSize
)
;
static
void
SaveReflowAndBoundingMetricsFor
(
nsIFrame
*
aFrame
const
ReflowOutput
&
aReflowOutput
const
nsBoundingMetrics
&
aBoundingMetrics
)
;
static
void
GetReflowAndBoundingMetricsFor
(
nsIFrame
*
aFrame
ReflowOutput
&
aReflowOutput
nsBoundingMetrics
&
aBoundingMetrics
eMathMLFrameType
*
aMathMLFrameType
=
nullptr
)
;
void
ClearSavedChildMetrics
(
)
;
static
void
PropagatePresentationDataFor
(
nsIFrame
*
aFrame
uint32_t
aFlagsValues
uint32_t
aFlagsToUpdate
)
;
public
:
static
void
PropagatePresentationDataFromChildAt
(
nsIFrame
*
aParentFrame
int32_t
aFirstChildIndex
int32_t
aLastChildIndex
uint32_t
aFlagsValues
uint32_t
aFlagsToUpdate
)
;
static
void
PropagateFrameFlagFor
(
nsIFrame
*
aFrame
nsFrameState
aFlags
)
;
static
void
RebuildAutomaticDataForChildren
(
nsIFrame
*
aParentFrame
)
;
static
nsresult
ReLayoutChildren
(
nsIFrame
*
aParentFrame
)
;
protected
:
void
PositionRowChildFrames
(
nscoord
aOffsetX
nscoord
aBaseline
)
;
void
GatherAndStoreOverflow
(
ReflowOutput
*
aMetrics
)
;
static
void
DidReflowChildren
(
nsIFrame
*
aFirst
nsIFrame
*
aStop
=
nullptr
)
;
void
UpdateIntrinsicWidth
(
gfxContext
*
aRenderingContext
)
;
nscoord
mIntrinsicWidth
;
nscoord
mBlockStartAscent
;
private
:
class
RowChildFrameIterator
;
friend
class
RowChildFrameIterator
;
}
;
class
nsMathMLmathBlockFrame
final
:
public
nsBlockFrame
{
public
:
NS_DECL_QUERYFRAME
NS_DECL_FRAMEARENA_HELPERS
(
nsMathMLmathBlockFrame
)
friend
nsContainerFrame
*
NS_NewMathMLmathBlockFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
virtual
void
SetInitialChildList
(
ChildListID
aListID
nsFrameList
&
aChildList
)
override
{
MOZ_ASSERT
(
aListID
=
=
kPrincipalList
|
|
aListID
=
=
kBackdropList
"
unexpected
frame
list
"
)
;
nsBlockFrame
:
:
SetInitialChildList
(
aListID
aChildList
)
;
if
(
aListID
=
=
kPrincipalList
)
{
nsMathMLContainerFrame
:
:
RebuildAutomaticDataForChildren
(
this
)
;
}
}
virtual
void
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
override
{
NS_ASSERTION
(
aListID
=
=
kPrincipalList
|
|
aListID
=
=
kNoReflowPrincipalList
"
unexpected
frame
list
"
)
;
nsBlockFrame
:
:
AppendFrames
(
aListID
aFrameList
)
;
if
(
MOZ_LIKELY
(
aListID
=
=
kPrincipalList
)
)
nsMathMLContainerFrame
:
:
ReLayoutChildren
(
this
)
;
}
virtual
void
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
aFrameList
)
override
{
NS_ASSERTION
(
aListID
=
=
kPrincipalList
|
|
aListID
=
=
kNoReflowPrincipalList
"
unexpected
frame
list
"
)
;
nsBlockFrame
:
:
InsertFrames
(
aListID
aPrevFrame
aFrameList
)
;
if
(
MOZ_LIKELY
(
aListID
=
=
kPrincipalList
)
)
nsMathMLContainerFrame
:
:
ReLayoutChildren
(
this
)
;
}
virtual
void
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
override
{
NS_ASSERTION
(
aListID
=
=
kPrincipalList
|
|
aListID
=
=
kNoReflowPrincipalList
"
unexpected
frame
list
"
)
;
nsBlockFrame
:
:
RemoveFrame
(
aListID
aOldFrame
)
;
if
(
MOZ_LIKELY
(
aListID
=
=
kPrincipalList
)
)
nsMathMLContainerFrame
:
:
ReLayoutChildren
(
this
)
;
}
virtual
bool
IsFrameOfType
(
uint32_t
aFlags
)
const
override
{
return
nsBlockFrame
:
:
IsFrameOfType
(
aFlags
&
~
(
nsIFrame
:
:
eMathML
|
nsIFrame
:
:
eExcludesIgnorableWhitespace
)
)
;
}
bool
IsMrowLike
(
)
{
return
mFrames
.
FirstChild
(
)
!
=
mFrames
.
LastChild
(
)
|
|
!
mFrames
.
FirstChild
(
)
;
}
protected
:
explicit
nsMathMLmathBlockFrame
(
ComputedStyle
*
aStyle
)
:
nsBlockFrame
(
aStyle
kClassID
)
{
}
virtual
~
nsMathMLmathBlockFrame
(
)
{
}
}
;
class
nsMathMLmathInlineFrame
final
:
public
nsInlineFrame
public
nsMathMLFrame
{
public
:
NS_DECL_QUERYFRAME
NS_DECL_FRAMEARENA_HELPERS
(
nsMathMLmathInlineFrame
)
friend
nsContainerFrame
*
NS_NewMathMLmathInlineFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
virtual
void
SetInitialChildList
(
ChildListID
aListID
nsFrameList
&
aChildList
)
override
{
NS_ASSERTION
(
aListID
=
=
kPrincipalList
"
unexpected
frame
list
"
)
;
nsInlineFrame
:
:
SetInitialChildList
(
aListID
aChildList
)
;
nsMathMLContainerFrame
:
:
RebuildAutomaticDataForChildren
(
this
)
;
}
virtual
void
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
override
{
NS_ASSERTION
(
aListID
=
=
kPrincipalList
|
|
aListID
=
=
kNoReflowPrincipalList
"
unexpected
frame
list
"
)
;
nsInlineFrame
:
:
AppendFrames
(
aListID
aFrameList
)
;
if
(
MOZ_LIKELY
(
aListID
=
=
kPrincipalList
)
)
nsMathMLContainerFrame
:
:
ReLayoutChildren
(
this
)
;
}
virtual
void
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
aFrameList
)
override
{
NS_ASSERTION
(
aListID
=
=
kPrincipalList
|
|
aListID
=
=
kNoReflowPrincipalList
"
unexpected
frame
list
"
)
;
nsInlineFrame
:
:
InsertFrames
(
aListID
aPrevFrame
aFrameList
)
;
if
(
MOZ_LIKELY
(
aListID
=
=
kPrincipalList
)
)
nsMathMLContainerFrame
:
:
ReLayoutChildren
(
this
)
;
}
virtual
void
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
override
{
NS_ASSERTION
(
aListID
=
=
kPrincipalList
|
|
aListID
=
=
kNoReflowPrincipalList
"
unexpected
frame
list
"
)
;
nsInlineFrame
:
:
RemoveFrame
(
aListID
aOldFrame
)
;
if
(
MOZ_LIKELY
(
aListID
=
=
kPrincipalList
)
)
nsMathMLContainerFrame
:
:
ReLayoutChildren
(
this
)
;
}
virtual
bool
IsFrameOfType
(
uint32_t
aFlags
)
const
override
{
return
nsInlineFrame
:
:
IsFrameOfType
(
aFlags
&
~
(
nsIFrame
:
:
eMathML
|
nsIFrame
:
:
eExcludesIgnorableWhitespace
)
)
;
}
bool
IsMrowLike
(
)
override
{
return
mFrames
.
FirstChild
(
)
!
=
mFrames
.
LastChild
(
)
|
|
!
mFrames
.
FirstChild
(
)
;
}
protected
:
explicit
nsMathMLmathInlineFrame
(
ComputedStyle
*
aStyle
)
:
nsInlineFrame
(
aStyle
kClassID
)
{
}
virtual
~
nsMathMLmathInlineFrame
(
)
{
}
}
;
#
endif
