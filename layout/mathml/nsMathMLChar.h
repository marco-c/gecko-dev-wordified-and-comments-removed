#
ifndef
nsMathMLChar_h___
#
define
nsMathMLChar_h___
#
include
"
gfxTextRun
.
h
"
#
include
"
nsBoundingMetrics
.
h
"
#
include
"
nsColor
.
h
"
#
include
"
nsMathMLOperators
.
h
"
#
include
"
nsPoint
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsString
.
h
"
class
gfxContext
;
class
nsGlyphTable
;
class
nsIFrame
;
class
nsPresContext
;
struct
nsBoundingMetrics
;
struct
nsFont
;
namespace
mozilla
{
class
nsDisplayListBuilder
;
class
nsDisplayListSet
;
class
ComputedStyle
;
}
enum
{
NS_STRETCH_NONE
=
0x00
NS_STRETCH_VARIABLE_MASK
=
0x0F
NS_STRETCH_NORMAL
=
0x01
NS_STRETCH_NEARER
=
0x02
NS_STRETCH_SMALLER
=
0x04
NS_STRETCH_LARGER
=
0x08
NS_STRETCH_LARGEOP
=
0x10
NS_STRETCH_MAXWIDTH
=
0x20
}
;
struct
nsGlyphCode
{
union
{
char16_t
code
[
2
]
;
uint32_t
glyphID
;
}
;
bool
isGlyphID
=
true
;
int32_t
Length
(
)
const
{
return
(
isGlyphID
|
|
code
[
1
]
=
=
char16_t
(
'
\
0
'
)
?
1
:
2
)
;
}
bool
Exists
(
)
const
{
return
isGlyphID
?
glyphID
!
=
0
:
code
[
0
]
!
=
0
;
}
bool
operator
=
=
(
const
nsGlyphCode
&
other
)
const
{
return
(
other
.
isGlyphID
=
=
isGlyphID
&
&
(
isGlyphID
?
other
.
glyphID
=
=
glyphID
:
(
other
.
code
[
0
]
=
=
code
[
0
]
&
&
other
.
code
[
1
]
=
=
code
[
1
]
)
)
)
;
}
bool
operator
!
=
(
const
nsGlyphCode
&
)
const
=
default
;
}
;
class
nsMathMLChar
{
public
:
typedef
gfxTextRun
:
:
Range
Range
;
typedef
mozilla
:
:
gfx
:
:
DrawTarget
DrawTarget
;
nsMathMLChar
(
)
:
mDirection
(
NS_STRETCH_DIRECTION_DEFAULT
)
{
MOZ_COUNT_CTOR
(
nsMathMLChar
)
;
mComputedStyle
=
nullptr
;
mUnscaledAscent
=
0
;
mScaleX
=
mScaleY
=
1
.
0
;
mDrawingMethod
=
DrawingMethod
:
:
Normal
;
mMirroringMethod
=
MirroringMethod
:
:
None
;
}
~
nsMathMLChar
(
)
;
void
Display
(
mozilla
:
:
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aForFrame
const
mozilla
:
:
nsDisplayListSet
&
aLists
uint32_t
aIndex
const
nsRect
*
aSelectedRect
=
nullptr
)
;
void
PaintForeground
(
nsIFrame
*
aForFrame
gfxContext
&
aRenderingContext
nsPoint
aPt
bool
aIsSelected
)
;
nsresult
Stretch
(
nsIFrame
*
aForFrame
DrawTarget
*
aDrawTarget
float
aFontSizeInflation
nsStretchDirection
aStretchDirection
const
nsBoundingMetrics
&
aContainerSize
nsBoundingMetrics
&
aDesiredStretchSize
uint32_t
aStretchHint
bool
aRTL
)
;
void
SetData
(
nsString
&
aData
)
;
void
GetData
(
nsString
&
aData
)
{
aData
=
mData
;
}
int32_t
Length
(
)
{
return
mData
.
Length
(
)
;
}
nsStretchDirection
GetStretchDirection
(
)
{
return
mDirection
;
}
const
char16_t
*
get
(
)
{
return
mData
.
get
(
)
;
}
void
GetRect
(
nsRect
&
aRect
)
{
aRect
=
mRect
;
}
void
SetRect
(
const
nsRect
&
aRect
)
{
mRect
=
aRect
;
}
nscoord
GetMaxWidth
(
nsIFrame
*
aForFrame
DrawTarget
*
aDrawTarget
float
aFontSizeInflation
uint32_t
aStretchHint
=
NS_STRETCH_NORMAL
)
;
void
GetBoundingMetrics
(
nsBoundingMetrics
&
aBoundingMetrics
)
{
aBoundingMetrics
=
mBoundingMetrics
;
}
void
SetBoundingMetrics
(
nsBoundingMetrics
&
aBoundingMetrics
)
{
mBoundingMetrics
=
aBoundingMetrics
;
}
mozilla
:
:
ComputedStyle
*
GetComputedStyle
(
)
const
;
void
SetComputedStyle
(
mozilla
:
:
ComputedStyle
*
aComputedStyle
)
;
protected
:
friend
class
nsGlyphTable
;
friend
class
nsPropertiesTable
;
friend
class
nsOpenTypeTable
;
nsString
mData
;
private
:
nsRect
mRect
;
nsStretchDirection
mDirection
;
nsBoundingMetrics
mBoundingMetrics
;
RefPtr
<
mozilla
:
:
ComputedStyle
>
mComputedStyle
;
RefPtr
<
gfxTextRun
>
mGlyphs
[
4
]
;
nsBoundingMetrics
mBmData
[
4
]
;
nscoord
mUnscaledAscent
;
float
mScaleX
mScaleY
;
enum
class
DrawingMethod
{
Normal
Variant
Parts
}
;
DrawingMethod
mDrawingMethod
;
enum
class
MirroringMethod
:
uint8_t
{
None
Character
Glyph
ScaleFallback
}
;
MirroringMethod
mMirroringMethod
;
class
StretchEnumContext
;
friend
class
StretchEnumContext
;
bool
SetFontFamily
(
nsPresContext
*
aPresContext
const
nsGlyphTable
*
aGlyphTable
const
nsGlyphCode
&
aGlyphCode
const
mozilla
:
:
StyleFontFamilyList
&
aDefaultFamily
nsFont
&
aFont
RefPtr
<
gfxFontGroup
>
*
aFontGroup
)
;
nsresult
StretchInternal
(
nsIFrame
*
aForFrame
DrawTarget
*
aDrawTarget
float
aFontSizeInflation
nsStretchDirection
&
aStretchDirection
const
nsBoundingMetrics
&
aContainerSize
nsBoundingMetrics
&
aDesiredStretchSize
uint32_t
aStretchHint
float
aMaxSize
=
NS_MATHML_OPERATOR_SIZE_INFINITY
bool
aMaxSizeIsAbsolute
=
false
)
;
nsresult
PaintVertically
(
nsPresContext
*
aPresContext
gfxContext
*
aThebesContext
nsRect
&
aRect
nscolor
aColor
)
;
nsresult
PaintHorizontally
(
nsPresContext
*
aPresContext
gfxContext
*
aThebesContext
nsRect
&
aRect
nscolor
aColor
)
;
void
ApplyTransforms
(
gfxContext
*
aThebesContext
int32_t
aAppUnitsPerGfxUnit
nsRect
&
r
)
;
}
;
#
endif
