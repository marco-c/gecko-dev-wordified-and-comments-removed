#
include
"
nsMathMLmpaddedFrame
.
h
"
#
include
"
mozilla
/
dom
/
MathMLElement
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
TextUtils
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
<
algorithm
>
using
namespace
mozilla
;
#
define
NS_MATHML_SIGN_INVALID
-
1
/
/
if
the
attribute
is
not
there
#
define
NS_MATHML_SIGN_UNSPECIFIED
0
#
define
NS_MATHML_SIGN_MINUS
1
#
define
NS_MATHML_SIGN_PLUS
2
#
define
NS_MATHML_PSEUDO_UNIT_UNSPECIFIED
0
#
define
NS_MATHML_PSEUDO_UNIT_ITSELF
1
/
/
special
#
define
NS_MATHML_PSEUDO_UNIT_WIDTH
2
#
define
NS_MATHML_PSEUDO_UNIT_HEIGHT
3
#
define
NS_MATHML_PSEUDO_UNIT_DEPTH
4
#
define
NS_MATHML_PSEUDO_UNIT_NAMEDSPACE
5
nsIFrame
*
NS_NewMathMLmpaddedFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsMathMLmpaddedFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsMathMLmpaddedFrame
)
nsMathMLmpaddedFrame
:
:
~
nsMathMLmpaddedFrame
(
)
=
default
;
NS_IMETHODIMP
nsMathMLmpaddedFrame
:
:
InheritAutomaticData
(
nsIFrame
*
aParent
)
{
nsMathMLContainerFrame
:
:
InheritAutomaticData
(
aParent
)
;
mPresentationData
.
flags
|
=
NS_MATHML_STRETCH_ALL_CHILDREN_VERTICALLY
;
return
NS_OK
;
}
void
nsMathMLmpaddedFrame
:
:
ProcessAttributes
(
)
{
nsAutoString
value
;
mWidthSign
=
NS_MATHML_SIGN_INVALID
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
width
value
)
;
if
(
!
value
.
IsEmpty
(
)
)
{
if
(
!
ParseAttribute
(
value
mWidthSign
mWidth
mWidthPseudoUnit
)
)
{
ReportParseError
(
nsGkAtoms
:
:
width
-
>
GetUTF16String
(
)
value
.
get
(
)
)
;
}
}
mHeightSign
=
NS_MATHML_SIGN_INVALID
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
height
value
)
;
if
(
!
value
.
IsEmpty
(
)
)
{
if
(
!
ParseAttribute
(
value
mHeightSign
mHeight
mHeightPseudoUnit
)
)
{
ReportParseError
(
nsGkAtoms
:
:
height
-
>
GetUTF16String
(
)
value
.
get
(
)
)
;
}
}
mDepthSign
=
NS_MATHML_SIGN_INVALID
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
depth_
value
)
;
if
(
!
value
.
IsEmpty
(
)
)
{
if
(
!
ParseAttribute
(
value
mDepthSign
mDepth
mDepthPseudoUnit
)
)
{
ReportParseError
(
nsGkAtoms
:
:
depth_
-
>
GetUTF16String
(
)
value
.
get
(
)
)
;
}
}
mLeadingSpaceSign
=
NS_MATHML_SIGN_INVALID
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
lspace_
value
)
;
if
(
!
value
.
IsEmpty
(
)
)
{
if
(
!
ParseAttribute
(
value
mLeadingSpaceSign
mLeadingSpace
mLeadingSpacePseudoUnit
)
)
{
ReportParseError
(
nsGkAtoms
:
:
lspace_
-
>
GetUTF16String
(
)
value
.
get
(
)
)
;
}
}
mVerticalOffsetSign
=
NS_MATHML_SIGN_INVALID
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
voffset_
value
)
;
if
(
!
value
.
IsEmpty
(
)
)
{
if
(
!
ParseAttribute
(
value
mVerticalOffsetSign
mVerticalOffset
mVerticalOffsetPseudoUnit
)
)
{
ReportParseError
(
nsGkAtoms
:
:
voffset_
-
>
GetUTF16String
(
)
value
.
get
(
)
)
;
}
}
}
bool
nsMathMLmpaddedFrame
:
:
ParseAttribute
(
nsString
&
aString
int32_t
&
aSign
nsCSSValue
&
aCSSValue
int32_t
&
aPseudoUnit
)
{
aCSSValue
.
Reset
(
)
;
aSign
=
NS_MATHML_SIGN_INVALID
;
aPseudoUnit
=
NS_MATHML_PSEUDO_UNIT_UNSPECIFIED
;
aString
.
CompressWhitespace
(
)
;
int32_t
stringLength
=
aString
.
Length
(
)
;
if
(
!
stringLength
)
return
false
;
nsAutoString
number
unit
;
int32_t
i
=
0
;
if
(
aString
[
0
]
=
=
'
+
'
)
{
aSign
=
NS_MATHML_SIGN_PLUS
;
i
+
+
;
}
else
if
(
aString
[
0
]
=
=
'
-
'
)
{
aSign
=
NS_MATHML_SIGN_MINUS
;
i
+
+
;
}
else
aSign
=
NS_MATHML_SIGN_UNSPECIFIED
;
bool
gotDot
=
false
gotPercent
=
false
;
for
(
;
i
<
stringLength
;
i
+
+
)
{
char16_t
c
=
aString
[
i
]
;
if
(
gotDot
&
&
c
=
=
'
.
'
)
{
aSign
=
NS_MATHML_SIGN_INVALID
;
return
false
;
}
if
(
c
=
=
'
.
'
)
gotDot
=
true
;
else
if
(
!
IsAsciiDigit
(
c
)
)
{
break
;
}
number
.
Append
(
c
)
;
}
if
(
number
.
IsEmpty
(
)
)
{
aSign
=
NS_MATHML_SIGN_INVALID
;
return
false
;
}
nsresult
errorCode
;
float
floatValue
=
number
.
ToFloat
(
&
errorCode
)
;
if
(
NS_FAILED
(
errorCode
)
)
{
aSign
=
NS_MATHML_SIGN_INVALID
;
return
false
;
}
if
(
i
<
stringLength
&
&
aString
[
i
]
=
=
'
%
'
)
{
i
+
+
;
gotPercent
=
true
;
}
aString
.
Right
(
unit
stringLength
-
i
)
;
if
(
unit
.
IsEmpty
(
)
)
{
if
(
gotPercent
)
{
aCSSValue
.
SetPercentValue
(
floatValue
/
100
.
0f
)
;
aPseudoUnit
=
NS_MATHML_PSEUDO_UNIT_ITSELF
;
return
true
;
}
else
{
if
(
!
floatValue
)
{
aCSSValue
.
SetFloatValue
(
floatValue
eCSSUnit_Number
)
;
aPseudoUnit
=
NS_MATHML_PSEUDO_UNIT_ITSELF
;
return
true
;
}
}
}
else
if
(
unit
.
EqualsLiteral
(
"
width
"
)
)
aPseudoUnit
=
NS_MATHML_PSEUDO_UNIT_WIDTH
;
else
if
(
unit
.
EqualsLiteral
(
"
height
"
)
)
aPseudoUnit
=
NS_MATHML_PSEUDO_UNIT_HEIGHT
;
else
if
(
unit
.
EqualsLiteral
(
"
depth
"
)
)
aPseudoUnit
=
NS_MATHML_PSEUDO_UNIT_DEPTH
;
else
if
(
!
gotPercent
)
{
if
(
dom
:
:
MathMLElement
:
:
ParseNamedSpaceValue
(
unit
aCSSValue
dom
:
:
MathMLElement
:
:
PARSE_ALLOW_NEGATIVE
*
mContent
-
>
OwnerDoc
(
)
)
)
{
floatValue
*
=
aCSSValue
.
GetFloatValue
(
)
;
aCSSValue
.
SetFloatValue
(
floatValue
eCSSUnit_EM
)
;
aPseudoUnit
=
NS_MATHML_PSEUDO_UNIT_NAMEDSPACE
;
return
true
;
}
number
.
Append
(
unit
)
;
if
(
dom
:
:
MathMLElement
:
:
ParseNumericValue
(
number
aCSSValue
dom
:
:
MathMLElement
:
:
PARSE_SUPPRESS_WARNINGS
nullptr
)
)
return
true
;
}
if
(
aPseudoUnit
!
=
NS_MATHML_PSEUDO_UNIT_UNSPECIFIED
)
{
if
(
gotPercent
)
aCSSValue
.
SetPercentValue
(
floatValue
/
100
.
0f
)
;
else
aCSSValue
.
SetFloatValue
(
floatValue
eCSSUnit_Number
)
;
return
true
;
}
#
ifdef
DEBUG
printf
(
"
mpadded
:
attribute
with
bad
numeric
value
:
%
s
\
n
"
NS_LossyConvertUTF16toASCII
(
aString
)
.
get
(
)
)
;
#
endif
aSign
=
NS_MATHML_SIGN_INVALID
;
return
false
;
}
void
nsMathMLmpaddedFrame
:
:
UpdateValue
(
int32_t
aSign
int32_t
aPseudoUnit
const
nsCSSValue
&
aCSSValue
const
ReflowOutput
&
aDesiredSize
nscoord
&
aValueToUpdate
float
aFontSizeInflation
)
const
{
nsCSSUnit
unit
=
aCSSValue
.
GetUnit
(
)
;
if
(
NS_MATHML_SIGN_INVALID
!
=
aSign
&
&
eCSSUnit_Null
!
=
unit
)
{
nscoord
scaler
=
0
amount
=
0
;
if
(
eCSSUnit_Percent
=
=
unit
|
|
eCSSUnit_Number
=
=
unit
)
{
switch
(
aPseudoUnit
)
{
case
NS_MATHML_PSEUDO_UNIT_WIDTH
:
scaler
=
aDesiredSize
.
Width
(
)
;
break
;
case
NS_MATHML_PSEUDO_UNIT_HEIGHT
:
scaler
=
aDesiredSize
.
BlockStartAscent
(
)
;
break
;
case
NS_MATHML_PSEUDO_UNIT_DEPTH
:
scaler
=
aDesiredSize
.
Height
(
)
-
aDesiredSize
.
BlockStartAscent
(
)
;
break
;
default
:
NS_ERROR
(
"
Unexpected
Pseudo
Unit
"
)
;
return
;
}
}
if
(
eCSSUnit_Number
=
=
unit
)
amount
=
NSToCoordRound
(
float
(
scaler
)
*
aCSSValue
.
GetFloatValue
(
)
)
;
else
if
(
eCSSUnit_Percent
=
=
unit
)
amount
=
NSToCoordRound
(
float
(
scaler
)
*
aCSSValue
.
GetPercentValue
(
)
)
;
else
amount
=
CalcLength
(
PresContext
(
)
mComputedStyle
aCSSValue
aFontSizeInflation
)
;
if
(
NS_MATHML_SIGN_PLUS
=
=
aSign
)
aValueToUpdate
+
=
amount
;
else
if
(
NS_MATHML_SIGN_MINUS
=
=
aSign
)
aValueToUpdate
-
=
amount
;
else
aValueToUpdate
=
amount
;
}
}
void
nsMathMLmpaddedFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
ProcessAttributes
(
)
;
nsMathMLContainerFrame
:
:
Reflow
(
aPresContext
aDesiredSize
aReflowInput
aStatus
)
;
}
nsresult
nsMathMLmpaddedFrame
:
:
Place
(
DrawTarget
*
aDrawTarget
const
PlaceFlags
&
aFlags
ReflowOutput
&
aDesiredSize
)
{
PlaceFlags
flags
=
aFlags
+
PlaceFlag
:
:
MeasureOnly
+
PlaceFlag
:
:
IgnoreBorderPadding
;
nsresult
rv
=
nsMathMLContainerFrame
:
:
Place
(
aDrawTarget
flags
aDesiredSize
)
;
if
(
NS_FAILED
(
rv
)
)
{
DidReflowChildren
(
PrincipalChildList
(
)
.
FirstChild
(
)
)
;
return
rv
;
}
nscoord
height
=
aDesiredSize
.
BlockStartAscent
(
)
;
nscoord
depth
=
aDesiredSize
.
Height
(
)
-
aDesiredSize
.
BlockStartAscent
(
)
;
nscoord
lspace
=
0
;
nscoord
width
=
aDesiredSize
.
Width
(
)
;
nscoord
voffset
=
0
;
int32_t
pseudoUnit
;
nscoord
initialWidth
=
width
;
float
fontSizeInflation
=
nsLayoutUtils
:
:
FontSizeInflationFor
(
this
)
;
pseudoUnit
=
(
mWidthPseudoUnit
=
=
NS_MATHML_PSEUDO_UNIT_ITSELF
)
?
NS_MATHML_PSEUDO_UNIT_WIDTH
:
mWidthPseudoUnit
;
UpdateValue
(
mWidthSign
pseudoUnit
mWidth
aDesiredSize
width
fontSizeInflation
)
;
width
=
std
:
:
max
(
0
width
)
;
pseudoUnit
=
(
mHeightPseudoUnit
=
=
NS_MATHML_PSEUDO_UNIT_ITSELF
)
?
NS_MATHML_PSEUDO_UNIT_HEIGHT
:
mHeightPseudoUnit
;
UpdateValue
(
mHeightSign
pseudoUnit
mHeight
aDesiredSize
height
fontSizeInflation
)
;
height
=
std
:
:
max
(
0
height
)
;
pseudoUnit
=
(
mDepthPseudoUnit
=
=
NS_MATHML_PSEUDO_UNIT_ITSELF
)
?
NS_MATHML_PSEUDO_UNIT_DEPTH
:
mDepthPseudoUnit
;
UpdateValue
(
mDepthSign
pseudoUnit
mDepth
aDesiredSize
depth
fontSizeInflation
)
;
depth
=
std
:
:
max
(
0
depth
)
;
if
(
mLeadingSpacePseudoUnit
!
=
NS_MATHML_PSEUDO_UNIT_ITSELF
)
{
pseudoUnit
=
mLeadingSpacePseudoUnit
;
UpdateValue
(
mLeadingSpaceSign
pseudoUnit
mLeadingSpace
aDesiredSize
lspace
fontSizeInflation
)
;
}
if
(
mVerticalOffsetPseudoUnit
!
=
NS_MATHML_PSEUDO_UNIT_ITSELF
)
{
pseudoUnit
=
mVerticalOffsetPseudoUnit
;
UpdateValue
(
mVerticalOffsetSign
pseudoUnit
mVerticalOffset
aDesiredSize
voffset
fontSizeInflation
)
;
}
const
bool
isRTL
=
StyleVisibility
(
)
-
>
mDirection
=
=
StyleDirection
:
:
Rtl
;
if
(
(
isRTL
?
mWidthSign
:
mLeadingSpaceSign
)
!
=
NS_MATHML_SIGN_INVALID
)
{
mBoundingMetrics
.
leftBearing
=
0
;
}
if
(
(
isRTL
?
mLeadingSpaceSign
:
mWidthSign
)
!
=
NS_MATHML_SIGN_INVALID
)
{
mBoundingMetrics
.
width
=
width
;
mBoundingMetrics
.
rightBearing
=
mBoundingMetrics
.
width
;
}
nscoord
dx
=
(
isRTL
?
width
-
initialWidth
-
lspace
:
lspace
)
;
aDesiredSize
.
SetBlockStartAscent
(
height
)
;
aDesiredSize
.
Width
(
)
=
mBoundingMetrics
.
width
;
aDesiredSize
.
Height
(
)
=
depth
+
aDesiredSize
.
BlockStartAscent
(
)
;
mBoundingMetrics
.
ascent
=
height
;
mBoundingMetrics
.
descent
=
depth
;
aDesiredSize
.
mBoundingMetrics
=
mBoundingMetrics
;
auto
borderPadding
=
GetBorderPaddingForPlace
(
aFlags
)
;
InflateReflowAndBoundingMetrics
(
borderPadding
aDesiredSize
mBoundingMetrics
)
;
dx
+
=
borderPadding
.
left
;
mReference
.
x
=
0
;
mReference
.
y
=
aDesiredSize
.
BlockStartAscent
(
)
;
if
(
!
aFlags
.
contains
(
PlaceFlag
:
:
MeasureOnly
)
)
{
PositionRowChildFrames
(
dx
aDesiredSize
.
BlockStartAscent
(
)
-
voffset
)
;
}
return
NS_OK
;
}
nsresult
nsMathMLmpaddedFrame
:
:
MeasureForWidth
(
DrawTarget
*
aDrawTarget
ReflowOutput
&
aDesiredSize
)
{
ProcessAttributes
(
)
;
PlaceFlags
flags
(
PlaceFlag
:
:
IntrinsicSize
PlaceFlag
:
:
MeasureOnly
)
;
return
Place
(
aDrawTarget
flags
aDesiredSize
)
;
}
