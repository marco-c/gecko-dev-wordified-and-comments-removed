#
include
"
nsMathMLTokenFrame
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsTextFrame
.
h
"
#
include
"
gfxContext
.
h
"
#
include
<
algorithm
>
using
namespace
mozilla
;
nsIFrame
*
NS_NewMathMLTokenFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsMathMLTokenFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsMathMLTokenFrame
)
nsMathMLTokenFrame
:
:
~
nsMathMLTokenFrame
(
)
=
default
;
NS_IMETHODIMP
nsMathMLTokenFrame
:
:
InheritAutomaticData
(
nsIFrame
*
aParent
)
{
nsMathMLContainerFrame
:
:
InheritAutomaticData
(
aParent
)
;
return
NS_OK
;
}
eMathMLFrameType
nsMathMLTokenFrame
:
:
GetMathMLFrameType
(
)
{
if
(
!
mContent
-
>
IsMathMLElement
(
nsGkAtoms
:
:
mi_
)
)
{
return
eMathMLFrameType_Ordinary
;
}
StyleMathVariant
mathVariant
=
StyleFont
(
)
-
>
mMathVariant
;
if
(
(
mathVariant
=
=
StyleMathVariant
:
:
None
&
&
(
StyleFont
(
)
-
>
mFont
.
style
.
IsItalic
(
)
|
|
HasAnyStateBits
(
NS_FRAME_IS_IN_SINGLE_CHAR_MI
)
)
)
|
|
mathVariant
=
=
StyleMathVariant
:
:
Italic
|
|
mathVariant
=
=
StyleMathVariant
:
:
BoldItalic
|
|
mathVariant
=
=
StyleMathVariant
:
:
SansSerifItalic
|
|
mathVariant
=
=
StyleMathVariant
:
:
SansSerifBoldItalic
)
{
return
eMathMLFrameType_ItalicIdentifier
;
}
return
eMathMLFrameType_UprightIdentifier
;
}
void
nsMathMLTokenFrame
:
:
MarkTextFramesAsTokenMathML
(
)
{
nsIFrame
*
child
=
nullptr
;
uint32_t
childCount
=
0
;
for
(
nsIFrame
*
childFrame
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
childFrame
;
childFrame
=
childFrame
-
>
GetNextSibling
(
)
)
{
for
(
nsIFrame
*
childFrame2
=
childFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
childFrame2
;
childFrame2
=
childFrame2
-
>
GetNextSibling
(
)
)
{
if
(
childFrame2
-
>
IsTextFrame
(
)
)
{
childFrame2
-
>
AddStateBits
(
TEXT_IS_IN_TOKEN_MATHML
)
;
child
=
childFrame2
;
childCount
+
+
;
}
}
}
if
(
mContent
-
>
IsMathMLElement
(
nsGkAtoms
:
:
mi_
)
&
&
childCount
=
=
1
)
{
nsAutoString
data
;
nsContentUtils
:
:
GetNodeTextContent
(
mContent
false
data
)
;
data
.
CompressWhitespace
(
)
;
int32_t
length
=
data
.
Length
(
)
;
bool
isSingleCharacter
=
length
=
=
1
|
|
(
length
=
=
2
&
&
NS_IS_HIGH_SURROGATE
(
data
[
0
]
)
)
;
if
(
isSingleCharacter
)
{
child
-
>
AddStateBits
(
NS_FRAME_IS_IN_SINGLE_CHAR_MI
)
;
AddStateBits
(
NS_FRAME_IS_IN_SINGLE_CHAR_MI
)
;
}
}
}
void
nsMathMLTokenFrame
:
:
SetInitialChildList
(
ChildListID
aListID
nsFrameList
&
&
aChildList
)
{
nsMathMLContainerFrame
:
:
SetInitialChildList
(
aListID
std
:
:
move
(
aChildList
)
)
;
MarkTextFramesAsTokenMathML
(
)
;
}
void
nsMathMLTokenFrame
:
:
AppendFrames
(
ChildListID
aListID
nsFrameList
&
&
aChildList
)
{
nsMathMLContainerFrame
:
:
AppendFrames
(
aListID
std
:
:
move
(
aChildList
)
)
;
MarkTextFramesAsTokenMathML
(
)
;
}
void
nsMathMLTokenFrame
:
:
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
const
nsLineList
:
:
iterator
*
aPrevFrameLine
nsFrameList
&
&
aChildList
)
{
nsMathMLContainerFrame
:
:
InsertFrames
(
aListID
aPrevFrame
aPrevFrameLine
std
:
:
move
(
aChildList
)
)
;
MarkTextFramesAsTokenMathML
(
)
;
}
void
nsMathMLTokenFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
aDesiredSize
.
ClearSize
(
)
;
aDesiredSize
.
SetBlockStartAscent
(
0
)
;
aDesiredSize
.
mBoundingMetrics
=
nsBoundingMetrics
(
)
;
for
(
nsIFrame
*
childFrame
:
PrincipalChildList
(
)
)
{
ReflowOutput
childDesiredSize
(
aReflowInput
.
GetWritingMode
(
)
)
;
WritingMode
wm
=
childFrame
-
>
GetWritingMode
(
)
;
LogicalSize
availSize
=
aReflowInput
.
ComputedSize
(
wm
)
;
availSize
.
BSize
(
wm
)
=
NS_UNCONSTRAINEDSIZE
;
ReflowInput
childReflowInput
(
aPresContext
aReflowInput
childFrame
availSize
)
;
nsReflowStatus
childStatus
;
ReflowChild
(
childFrame
aPresContext
childDesiredSize
childReflowInput
childStatus
)
;
NS_ASSERTION
(
childStatus
.
IsComplete
(
)
"
We
gave
the
child
unconstrained
available
block
-
size
so
its
"
"
status
should
be
complete
!
"
)
;
SaveReflowAndBoundingMetricsFor
(
childFrame
childDesiredSize
childDesiredSize
.
mBoundingMetrics
)
;
}
FinalizeReflow
(
aReflowInput
.
mRenderingContext
-
>
GetDrawTarget
(
)
aDesiredSize
)
;
aStatus
.
Reset
(
)
;
}
nsresult
nsMathMLTokenFrame
:
:
Place
(
DrawTarget
*
aDrawTarget
const
PlaceFlags
&
aFlags
ReflowOutput
&
aDesiredSize
)
{
mBoundingMetrics
=
nsBoundingMetrics
(
)
;
for
(
nsIFrame
*
childFrame
:
PrincipalChildList
(
)
)
{
ReflowOutput
childSize
(
aDesiredSize
.
GetWritingMode
(
)
)
;
nsBoundingMetrics
bmChild
;
GetReflowAndBoundingMetricsFor
(
childFrame
childSize
bmChild
nullptr
)
;
auto
childMargin
=
GetMarginForPlace
(
aFlags
childFrame
)
;
bmChild
.
ascent
+
=
childMargin
.
top
;
bmChild
.
descent
+
=
childMargin
.
bottom
;
bmChild
.
rightBearing
+
=
childMargin
.
LeftRight
(
)
;
bmChild
.
width
+
=
childMargin
.
LeftRight
(
)
;
mBoundingMetrics
+
=
bmChild
;
}
RefPtr
<
nsFontMetrics
>
fm
=
nsLayoutUtils
:
:
GetInflatedFontMetricsForFrame
(
this
)
;
nscoord
ascent
=
fm
-
>
MaxAscent
(
)
;
nscoord
descent
=
fm
-
>
MaxDescent
(
)
;
aDesiredSize
.
mBoundingMetrics
=
mBoundingMetrics
;
aDesiredSize
.
Width
(
)
=
mBoundingMetrics
.
width
;
aDesiredSize
.
SetBlockStartAscent
(
std
:
:
max
(
mBoundingMetrics
.
ascent
ascent
)
)
;
aDesiredSize
.
Height
(
)
=
aDesiredSize
.
BlockStartAscent
(
)
+
std
:
:
max
(
mBoundingMetrics
.
descent
descent
)
;
auto
sizes
=
GetWidthAndHeightForPlaceAdjustment
(
aFlags
)
;
auto
shiftX
=
ApplyAdjustmentForWidthAndHeight
(
aFlags
sizes
aDesiredSize
mBoundingMetrics
)
;
auto
borderPadding
=
GetBorderPaddingForPlace
(
aFlags
)
;
InflateReflowAndBoundingMetrics
(
borderPadding
aDesiredSize
mBoundingMetrics
)
;
if
(
!
aFlags
.
contains
(
PlaceFlag
:
:
MeasureOnly
)
)
{
nscoord
dx
=
borderPadding
.
left
;
dx
+
=
shiftX
;
for
(
nsIFrame
*
childFrame
:
PrincipalChildList
(
)
)
{
ReflowOutput
childSize
(
aDesiredSize
.
GetWritingMode
(
)
)
;
GetReflowAndBoundingMetricsFor
(
childFrame
childSize
childSize
.
mBoundingMetrics
)
;
auto
childMargin
=
GetMarginForPlace
(
aFlags
childFrame
)
;
nscoord
dy
=
childSize
.
Height
(
)
=
=
0
?
0
:
aDesiredSize
.
BlockStartAscent
(
)
-
childSize
.
BlockStartAscent
(
)
+
childMargin
.
top
;
FinishReflowChild
(
childFrame
PresContext
(
)
childSize
nullptr
dx
dy
ReflowChildFlags
:
:
Default
)
;
dx
+
=
childSize
.
Width
(
)
;
}
}
SetReference
(
nsPoint
(
0
aDesiredSize
.
BlockStartAscent
(
)
)
)
;
return
NS_OK
;
}
