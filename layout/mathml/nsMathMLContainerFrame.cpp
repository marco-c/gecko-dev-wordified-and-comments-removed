#
include
"
nsMathMLContainerFrame
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsStyleContext
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsRenderingContext
.
h
"
#
include
"
nsIDOMMutationEvent
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsIReflowCallback
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsMathMLElement
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
NS_QUERYFRAME_HEAD
(
nsMathMLContainerFrame
)
NS_QUERYFRAME_ENTRY
(
nsIMathMLFrame
)
NS_QUERYFRAME_ENTRY
(
nsMathMLContainerFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsContainerFrame
)
nsresult
nsMathMLContainerFrame
:
:
ReflowError
(
DrawTarget
*
aDrawTarget
ReflowOutput
&
aDesiredSize
)
{
mEmbellishData
.
flags
=
0
;
mPresentationData
.
flags
=
NS_MATHML_ERROR
;
RefPtr
<
nsFontMetrics
>
fm
=
nsLayoutUtils
:
:
GetInflatedFontMetricsForFrame
(
this
)
;
nsAutoString
errorMsg
;
errorMsg
.
AssignLiteral
(
"
invalid
-
markup
"
)
;
mBoundingMetrics
=
nsLayoutUtils
:
:
AppUnitBoundsOfString
(
errorMsg
.
get
(
)
errorMsg
.
Length
(
)
*
fm
aDrawTarget
)
;
WritingMode
wm
=
aDesiredSize
.
GetWritingMode
(
)
;
aDesiredSize
.
SetBlockStartAscent
(
fm
-
>
MaxAscent
(
)
)
;
nscoord
descent
=
fm
-
>
MaxDescent
(
)
;
aDesiredSize
.
BSize
(
wm
)
=
aDesiredSize
.
BlockStartAscent
(
)
+
descent
;
aDesiredSize
.
ISize
(
wm
)
=
mBoundingMetrics
.
width
;
aDesiredSize
.
mBoundingMetrics
=
mBoundingMetrics
;
return
NS_OK
;
}
class
nsDisplayMathMLError
:
public
nsDisplayItem
{
public
:
nsDisplayMathMLError
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
:
nsDisplayItem
(
aBuilder
aFrame
)
{
MOZ_COUNT_CTOR
(
nsDisplayMathMLError
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayMathMLError
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayMathMLError
)
;
}
#
endif
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
nsRenderingContext
*
aCtx
)
override
;
NS_DISPLAY_DECL_NAME
(
"
MathMLError
"
TYPE_MATHML_ERROR
)
}
;
void
nsDisplayMathMLError
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
nsRenderingContext
*
aCtx
)
{
RefPtr
<
nsFontMetrics
>
fm
=
nsLayoutUtils
:
:
GetFontMetricsForFrame
(
mFrame
1
.
0f
)
;
nsPoint
pt
=
ToReferenceFrame
(
)
;
int32_t
appUnitsPerDevPixel
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
DrawTarget
*
drawTarget
=
aCtx
-
>
GetDrawTarget
(
)
;
Rect
rect
=
NSRectToSnappedRect
(
nsRect
(
pt
mFrame
-
>
GetSize
(
)
)
appUnitsPerDevPixel
*
drawTarget
)
;
ColorPattern
red
(
ToDeviceColor
(
Color
(
1
.
f
0
.
f
0
.
f
1
.
f
)
)
)
;
drawTarget
-
>
FillRect
(
rect
red
)
;
aCtx
-
>
ThebesContext
(
)
-
>
SetColor
(
Color
(
1
.
f
1
.
f
1
.
f
)
)
;
nscoord
ascent
=
fm
-
>
MaxAscent
(
)
;
NS_NAMED_LITERAL_STRING
(
errorMsg
"
invalid
-
markup
"
)
;
nsLayoutUtils
:
:
DrawUniDirString
(
errorMsg
.
get
(
)
uint32_t
(
errorMsg
.
Length
(
)
)
nsPoint
(
pt
.
x
pt
.
y
+
ascent
)
*
fm
*
aCtx
)
;
}
static
bool
IsForeignChild
(
const
nsIFrame
*
aFrame
)
{
return
!
(
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eMathML
)
)
|
|
aFrame
-
>
GetType
(
)
=
=
nsGkAtoms
:
:
blockFrame
;
}
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
HTMLReflowOutputProperty
ReflowOutput
)
void
nsMathMLContainerFrame
:
:
SaveReflowAndBoundingMetricsFor
(
nsIFrame
*
aFrame
const
ReflowOutput
&
aReflowOutput
const
nsBoundingMetrics
&
aBoundingMetrics
)
{
ReflowOutput
*
metrics
=
new
ReflowOutput
(
aReflowOutput
)
;
metrics
-
>
mBoundingMetrics
=
aBoundingMetrics
;
aFrame
-
>
Properties
(
)
.
Set
(
HTMLReflowOutputProperty
(
)
metrics
)
;
}
void
nsMathMLContainerFrame
:
:
GetReflowAndBoundingMetricsFor
(
nsIFrame
*
aFrame
ReflowOutput
&
aReflowOutput
nsBoundingMetrics
&
aBoundingMetrics
eMathMLFrameType
*
aMathMLFrameType
)
{
NS_PRECONDITION
(
aFrame
"
null
arg
"
)
;
ReflowOutput
*
metrics
=
aFrame
-
>
Properties
(
)
.
Get
(
HTMLReflowOutputProperty
(
)
)
;
NS_ASSERTION
(
metrics
"
Didn
'
t
SaveReflowAndBoundingMetricsFor
frame
!
"
)
;
if
(
metrics
)
{
aReflowOutput
=
*
metrics
;
aBoundingMetrics
=
metrics
-
>
mBoundingMetrics
;
}
if
(
aMathMLFrameType
)
{
if
(
!
IsForeignChild
(
aFrame
)
)
{
nsIMathMLFrame
*
mathMLFrame
=
do_QueryFrame
(
aFrame
)
;
if
(
mathMLFrame
)
{
*
aMathMLFrameType
=
mathMLFrame
-
>
GetMathMLFrameType
(
)
;
return
;
}
}
*
aMathMLFrameType
=
eMathMLFrameType_UNKNOWN
;
}
}
void
nsMathMLContainerFrame
:
:
ClearSavedChildMetrics
(
)
{
nsIFrame
*
childFrame
=
mFrames
.
FirstChild
(
)
;
FramePropertyTable
*
props
=
PresContext
(
)
-
>
PropertyTable
(
)
;
while
(
childFrame
)
{
props
-
>
Delete
(
childFrame
HTMLReflowOutputProperty
(
)
)
;
childFrame
=
childFrame
-
>
GetNextSibling
(
)
;
}
}
void
nsMathMLContainerFrame
:
:
GetPreferredStretchSize
(
DrawTarget
*
aDrawTarget
uint32_t
aOptions
nsStretchDirection
aStretchDirection
nsBoundingMetrics
&
aPreferredStretchSize
)
{
if
(
aOptions
&
STRETCH_CONSIDER_ACTUAL_SIZE
)
{
aPreferredStretchSize
=
mBoundingMetrics
;
}
else
if
(
aOptions
&
STRETCH_CONSIDER_EMBELLISHMENTS
)
{
ReflowOutput
metrics
(
GetWritingMode
(
)
)
;
Place
(
aDrawTarget
false
metrics
)
;
aPreferredStretchSize
=
metrics
.
mBoundingMetrics
;
}
else
{
bool
stretchAll
=
aStretchDirection
=
=
NS_STRETCH_DIRECTION_VERTICAL
?
NS_MATHML_WILL_STRETCH_ALL_CHILDREN_VERTICALLY
(
mPresentationData
.
flags
)
:
NS_MATHML_WILL_STRETCH_ALL_CHILDREN_HORIZONTALLY
(
mPresentationData
.
flags
)
;
NS_ASSERTION
(
aStretchDirection
=
=
NS_STRETCH_DIRECTION_HORIZONTAL
|
|
aStretchDirection
=
=
NS_STRETCH_DIRECTION_VERTICAL
"
You
must
specify
a
direction
in
which
to
stretch
"
)
;
NS_ASSERTION
(
NS_MATHML_IS_EMBELLISH_OPERATOR
(
mEmbellishData
.
flags
)
|
|
stretchAll
"
invalid
call
to
GetPreferredStretchSize
"
)
;
bool
firstTime
=
true
;
nsBoundingMetrics
bm
bmChild
;
nsIFrame
*
childFrame
=
stretchAll
?
PrincipalChildList
(
)
.
FirstChild
(
)
:
mPresentationData
.
baseFrame
;
while
(
childFrame
)
{
nsIMathMLFrame
*
mathMLFrame
=
do_QueryFrame
(
childFrame
)
;
if
(
mathMLFrame
)
{
nsEmbellishData
embellishData
;
nsPresentationData
presentationData
;
mathMLFrame
-
>
GetEmbellishData
(
embellishData
)
;
mathMLFrame
-
>
GetPresentationData
(
presentationData
)
;
if
(
NS_MATHML_IS_EMBELLISH_OPERATOR
(
embellishData
.
flags
)
&
&
embellishData
.
direction
=
=
aStretchDirection
&
&
presentationData
.
baseFrame
)
{
nsIMathMLFrame
*
mathMLchildFrame
=
do_QueryFrame
(
presentationData
.
baseFrame
)
;
if
(
mathMLchildFrame
)
{
mathMLFrame
=
mathMLchildFrame
;
}
}
mathMLFrame
-
>
GetBoundingMetrics
(
bmChild
)
;
}
else
{
ReflowOutput
unused
(
GetWritingMode
(
)
)
;
GetReflowAndBoundingMetricsFor
(
childFrame
unused
bmChild
)
;
}
if
(
firstTime
)
{
firstTime
=
false
;
bm
=
bmChild
;
if
(
!
stretchAll
)
{
break
;
}
}
else
{
if
(
aStretchDirection
=
=
NS_STRETCH_DIRECTION_HORIZONTAL
)
{
bm
.
descent
+
=
bmChild
.
ascent
+
bmChild
.
descent
;
if
(
bmChild
.
width
=
=
0
)
{
bmChild
.
rightBearing
-
=
bmChild
.
leftBearing
;
bmChild
.
leftBearing
=
0
;
}
if
(
bm
.
leftBearing
>
bmChild
.
leftBearing
)
bm
.
leftBearing
=
bmChild
.
leftBearing
;
if
(
bm
.
rightBearing
<
bmChild
.
rightBearing
)
bm
.
rightBearing
=
bmChild
.
rightBearing
;
}
else
if
(
aStretchDirection
=
=
NS_STRETCH_DIRECTION_VERTICAL
)
{
bm
+
=
bmChild
;
}
else
{
NS_ERROR
(
"
unexpected
case
in
GetPreferredStretchSize
"
)
;
break
;
}
}
childFrame
=
childFrame
-
>
GetNextSibling
(
)
;
}
aPreferredStretchSize
=
bm
;
}
}
NS_IMETHODIMP
nsMathMLContainerFrame
:
:
Stretch
(
DrawTarget
*
aDrawTarget
nsStretchDirection
aStretchDirection
nsBoundingMetrics
&
aContainerSize
ReflowOutput
&
aDesiredStretchSize
)
{
if
(
NS_MATHML_IS_EMBELLISH_OPERATOR
(
mEmbellishData
.
flags
)
)
{
if
(
NS_MATHML_STRETCH_WAS_DONE
(
mPresentationData
.
flags
)
)
{
NS_WARNING
(
"
it
is
wrong
to
fire
stretch
more
than
once
on
a
frame
"
)
;
return
NS_OK
;
}
mPresentationData
.
flags
|
=
NS_MATHML_STRETCH_DONE
;
if
(
NS_MATHML_HAS_ERROR
(
mPresentationData
.
flags
)
)
{
NS_WARNING
(
"
it
is
wrong
to
fire
stretch
on
a
erroneous
frame
"
)
;
return
NS_OK
;
}
nsIFrame
*
baseFrame
=
mPresentationData
.
baseFrame
;
if
(
baseFrame
)
{
nsIMathMLFrame
*
mathMLFrame
=
do_QueryFrame
(
baseFrame
)
;
NS_ASSERTION
(
mathMLFrame
"
Something
is
wrong
somewhere
"
)
;
if
(
mathMLFrame
)
{
ReflowOutput
childSize
(
aDesiredStretchSize
)
;
GetReflowAndBoundingMetricsFor
(
baseFrame
childSize
childSize
.
mBoundingMetrics
)
;
nsBoundingMetrics
containerSize
=
aContainerSize
;
if
(
aStretchDirection
!
=
mEmbellishData
.
direction
&
&
mEmbellishData
.
direction
!
=
NS_STRETCH_DIRECTION_UNSUPPORTED
)
{
NS_ASSERTION
(
mEmbellishData
.
direction
!
=
NS_STRETCH_DIRECTION_DEFAULT
"
Stretches
may
have
a
default
direction
operators
can
not
.
"
)
;
if
(
mEmbellishData
.
direction
=
=
NS_STRETCH_DIRECTION_VERTICAL
?
NS_MATHML_WILL_STRETCH_ALL_CHILDREN_VERTICALLY
(
mPresentationData
.
flags
)
:
NS_MATHML_WILL_STRETCH_ALL_CHILDREN_HORIZONTALLY
(
mPresentationData
.
flags
)
)
{
GetPreferredStretchSize
(
aDrawTarget
0
mEmbellishData
.
direction
containerSize
)
;
aStretchDirection
=
mEmbellishData
.
direction
;
}
else
{
containerSize
=
childSize
.
mBoundingMetrics
;
}
}
mathMLFrame
-
>
Stretch
(
aDrawTarget
aStretchDirection
containerSize
childSize
)
;
SaveReflowAndBoundingMetricsFor
(
baseFrame
childSize
childSize
.
mBoundingMetrics
)
;
if
(
NS_MATHML_WILL_STRETCH_ALL_CHILDREN_VERTICALLY
(
mPresentationData
.
flags
)
|
|
NS_MATHML_WILL_STRETCH_ALL_CHILDREN_HORIZONTALLY
(
mPresentationData
.
flags
)
)
{
nsStretchDirection
stretchDir
=
NS_MATHML_WILL_STRETCH_ALL_CHILDREN_VERTICALLY
(
mPresentationData
.
flags
)
?
NS_STRETCH_DIRECTION_VERTICAL
:
NS_STRETCH_DIRECTION_HORIZONTAL
;
GetPreferredStretchSize
(
aDrawTarget
STRETCH_CONSIDER_EMBELLISHMENTS
stretchDir
containerSize
)
;
nsIFrame
*
childFrame
=
mFrames
.
FirstChild
(
)
;
while
(
childFrame
)
{
if
(
childFrame
!
=
mPresentationData
.
baseFrame
)
{
mathMLFrame
=
do_QueryFrame
(
childFrame
)
;
if
(
mathMLFrame
)
{
GetReflowAndBoundingMetricsFor
(
childFrame
childSize
childSize
.
mBoundingMetrics
)
;
mathMLFrame
-
>
Stretch
(
aDrawTarget
stretchDir
containerSize
childSize
)
;
SaveReflowAndBoundingMetricsFor
(
childFrame
childSize
childSize
.
mBoundingMetrics
)
;
}
}
childFrame
=
childFrame
-
>
GetNextSibling
(
)
;
}
}
nsresult
rv
=
Place
(
aDrawTarget
true
aDesiredStretchSize
)
;
if
(
NS_MATHML_HAS_ERROR
(
mPresentationData
.
flags
)
|
|
NS_FAILED
(
rv
)
)
{
DidReflowChildren
(
mFrames
.
FirstChild
(
)
)
;
}
nsEmbellishData
parentData
;
GetEmbellishDataFrom
(
GetParent
(
)
parentData
)
;
if
(
parentData
.
coreFrame
!
=
mEmbellishData
.
coreFrame
)
{
nsEmbellishData
coreData
;
GetEmbellishDataFrom
(
mEmbellishData
.
coreFrame
coreData
)
;
mBoundingMetrics
.
width
+
=
coreData
.
leadingSpace
+
coreData
.
trailingSpace
;
aDesiredStretchSize
.
Width
(
)
=
mBoundingMetrics
.
width
;
aDesiredStretchSize
.
mBoundingMetrics
.
width
=
mBoundingMetrics
.
width
;
nscoord
dx
=
(
StyleVisibility
(
)
-
>
mDirection
?
coreData
.
trailingSpace
:
coreData
.
leadingSpace
)
;
if
(
dx
!
=
0
)
{
mBoundingMetrics
.
leftBearing
+
=
dx
;
mBoundingMetrics
.
rightBearing
+
=
dx
;
aDesiredStretchSize
.
mBoundingMetrics
.
leftBearing
+
=
dx
;
aDesiredStretchSize
.
mBoundingMetrics
.
rightBearing
+
=
dx
;
nsIFrame
*
childFrame
=
mFrames
.
FirstChild
(
)
;
while
(
childFrame
)
{
childFrame
-
>
SetPosition
(
childFrame
-
>
GetPosition
(
)
+
nsPoint
(
dx
0
)
)
;
childFrame
=
childFrame
-
>
GetNextSibling
(
)
;
}
}
}
ClearSavedChildMetrics
(
)
;
GatherAndStoreOverflow
(
&
aDesiredStretchSize
)
;
}
}
}
return
NS_OK
;
}
nsresult
nsMathMLContainerFrame
:
:
FinalizeReflow
(
DrawTarget
*
aDrawTarget
ReflowOutput
&
aDesiredSize
)
{
bool
placeOrigin
=
!
NS_MATHML_IS_EMBELLISH_OPERATOR
(
mEmbellishData
.
flags
)
|
|
(
mEmbellishData
.
coreFrame
!
=
this
&
&
!
mPresentationData
.
baseFrame
&
&
mEmbellishData
.
direction
=
=
NS_STRETCH_DIRECTION_UNSUPPORTED
)
;
nsresult
rv
=
Place
(
aDrawTarget
placeOrigin
aDesiredSize
)
;
if
(
NS_MATHML_HAS_ERROR
(
mPresentationData
.
flags
)
|
|
NS_FAILED
(
rv
)
)
{
GatherAndStoreOverflow
(
&
aDesiredSize
)
;
DidReflowChildren
(
PrincipalChildList
(
)
.
FirstChild
(
)
)
;
return
rv
;
}
bool
parentWillFireStretch
=
false
;
if
(
!
placeOrigin
)
{
nsIMathMLFrame
*
mathMLFrame
=
do_QueryFrame
(
GetParent
(
)
)
;
if
(
mathMLFrame
)
{
nsEmbellishData
embellishData
;
nsPresentationData
presentationData
;
mathMLFrame
-
>
GetEmbellishData
(
embellishData
)
;
mathMLFrame
-
>
GetPresentationData
(
presentationData
)
;
if
(
NS_MATHML_WILL_STRETCH_ALL_CHILDREN_VERTICALLY
(
presentationData
.
flags
)
|
|
NS_MATHML_WILL_STRETCH_ALL_CHILDREN_HORIZONTALLY
(
presentationData
.
flags
)
|
|
(
NS_MATHML_IS_EMBELLISH_OPERATOR
(
embellishData
.
flags
)
&
&
presentationData
.
baseFrame
=
=
this
)
)
{
parentWillFireStretch
=
true
;
}
}
if
(
!
parentWillFireStretch
)
{
bool
stretchAll
=
NS_MATHML_WILL_STRETCH_ALL_CHILDREN_HORIZONTALLY
(
mPresentationData
.
flags
)
;
nsStretchDirection
stretchDir
;
if
(
mEmbellishData
.
coreFrame
=
=
this
|
|
(
mEmbellishData
.
direction
=
=
NS_STRETCH_DIRECTION_HORIZONTAL
&
&
stretchAll
)
|
|
mEmbellishData
.
direction
=
=
NS_STRETCH_DIRECTION_UNSUPPORTED
)
{
stretchDir
=
mEmbellishData
.
direction
;
}
else
{
stretchDir
=
NS_STRETCH_DIRECTION_DEFAULT
;
}
nsBoundingMetrics
defaultSize
=
aDesiredSize
.
mBoundingMetrics
;
Stretch
(
aDrawTarget
stretchDir
defaultSize
aDesiredSize
)
;
#
ifdef
DEBUG
{
for
(
nsIFrame
*
childFrame
:
PrincipalChildList
(
)
)
{
NS_ASSERTION
(
!
(
childFrame
-
>
GetStateBits
(
)
&
NS_FRAME_IN_REFLOW
)
"
DidReflow
(
)
was
never
called
"
)
;
}
}
#
endif
}
}
aDesiredSize
.
mBoundingMetrics
=
mBoundingMetrics
;
FixInterFrameSpacing
(
aDesiredSize
)
;
if
(
!
parentWillFireStretch
)
{
ClearSavedChildMetrics
(
)
;
GatherAndStoreOverflow
(
&
aDesiredSize
)
;
}
return
NS_OK
;
}
void
nsMathMLContainerFrame
:
:
PropagatePresentationDataFor
(
nsIFrame
*
aFrame
uint32_t
aFlagsValues
uint32_t
aFlagsToUpdate
)
{
if
(
!
aFrame
|
|
!
aFlagsToUpdate
)
return
;
nsIMathMLFrame
*
mathMLFrame
=
do_QueryFrame
(
aFrame
)
;
if
(
mathMLFrame
)
{
mathMLFrame
-
>
UpdatePresentationData
(
aFlagsValues
aFlagsToUpdate
)
;
mathMLFrame
-
>
UpdatePresentationDataFromChildAt
(
0
-
1
aFlagsValues
aFlagsToUpdate
)
;
}
else
{
for
(
nsIFrame
*
childFrame
:
aFrame
-
>
PrincipalChildList
(
)
)
{
PropagatePresentationDataFor
(
childFrame
aFlagsValues
aFlagsToUpdate
)
;
}
}
}
void
nsMathMLContainerFrame
:
:
PropagatePresentationDataFromChildAt
(
nsIFrame
*
aParentFrame
int32_t
aFirstChildIndex
int32_t
aLastChildIndex
uint32_t
aFlagsValues
uint32_t
aFlagsToUpdate
)
{
if
(
!
aParentFrame
|
|
!
aFlagsToUpdate
)
return
;
int32_t
index
=
0
;
for
(
nsIFrame
*
childFrame
:
aParentFrame
-
>
PrincipalChildList
(
)
)
{
if
(
(
index
>
=
aFirstChildIndex
)
&
&
(
(
aLastChildIndex
<
=
0
)
|
|
(
(
aLastChildIndex
>
0
)
&
&
(
index
<
=
aLastChildIndex
)
)
)
)
{
PropagatePresentationDataFor
(
childFrame
aFlagsValues
aFlagsToUpdate
)
;
}
index
+
+
;
}
}
void
nsMathMLContainerFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aDirtyRect
const
nsDisplayListSet
&
aLists
)
{
if
(
NS_MATHML_HAS_ERROR
(
mPresentationData
.
flags
)
)
{
if
(
!
IsVisibleForPainting
(
aBuilder
)
)
return
;
aLists
.
Content
(
)
-
>
AppendNewToTop
(
new
(
aBuilder
)
nsDisplayMathMLError
(
aBuilder
this
)
)
;
return
;
}
DisplayBorderBackgroundOutline
(
aBuilder
aLists
)
;
BuildDisplayListForNonBlockChildren
(
aBuilder
aDirtyRect
aLists
DISPLAY_CHILD_INLINE
)
;
#
if
defined
(
DEBUG
)
&
&
defined
(
SHOW_BOUNDING_BOX
)
DisplayBoundingMetrics
(
aBuilder
this
mReference
mBoundingMetrics
aLists
)
;
#
endif
}
void
nsMathMLContainerFrame
:
:
RebuildAutomaticDataForChildren
(
nsIFrame
*
aParentFrame
)
{
for
(
nsIFrame
*
childFrame
:
aParentFrame
-
>
PrincipalChildList
(
)
)
{
nsIMathMLFrame
*
childMathMLFrame
=
do_QueryFrame
(
childFrame
)
;
if
(
childMathMLFrame
)
{
childMathMLFrame
-
>
InheritAutomaticData
(
aParentFrame
)
;
}
RebuildAutomaticDataForChildren
(
childFrame
)
;
}
nsIMathMLFrame
*
mathMLFrame
=
do_QueryFrame
(
aParentFrame
)
;
if
(
mathMLFrame
)
{
mathMLFrame
-
>
TransmitAutomaticData
(
)
;
}
}
nsresult
nsMathMLContainerFrame
:
:
ReLayoutChildren
(
nsIFrame
*
aParentFrame
)
{
if
(
!
aParentFrame
)
return
NS_OK
;
nsIFrame
*
frame
=
aParentFrame
;
while
(
1
)
{
nsIFrame
*
parent
=
frame
-
>
GetParent
(
)
;
if
(
!
parent
|
|
!
parent
-
>
GetContent
(
)
)
break
;
nsIMathMLFrame
*
mathMLFrame
=
do_QueryFrame
(
frame
)
;
if
(
mathMLFrame
)
break
;
nsIContent
*
content
=
frame
-
>
GetContent
(
)
;
NS_ASSERTION
(
content
"
dangling
frame
without
a
content
node
"
)
;
if
(
!
content
)
break
;
if
(
content
-
>
IsMathMLElement
(
nsGkAtoms
:
:
math
)
)
break
;
frame
=
parent
;
}
RebuildAutomaticDataForChildren
(
frame
)
;
nsIFrame
*
parent
=
frame
-
>
GetParent
(
)
;
NS_ASSERTION
(
parent
"
No
parent
to
pass
the
reflow
request
up
to
"
)
;
if
(
!
parent
)
return
NS_OK
;
frame
-
>
PresContext
(
)
-
>
PresShell
(
)
-
>
FrameNeedsReflow
(
frame
nsIPresShell
:
:
eStyleChange
NS_FRAME_IS_DIRTY
)
;
return
NS_OK
;
}
nsresult
nsMathMLContainerFrame
:
:
ChildListChanged
(
int32_t
aModType
)
{
nsIFrame
*
frame
=
this
;
if
(
mEmbellishData
.
coreFrame
)
{
nsIFrame
*
parent
=
GetParent
(
)
;
nsEmbellishData
embellishData
;
for
(
;
parent
;
frame
=
parent
parent
=
parent
-
>
GetParent
(
)
)
{
GetEmbellishDataFrom
(
parent
embellishData
)
;
if
(
embellishData
.
coreFrame
!
=
mEmbellishData
.
coreFrame
)
break
;
}
}
return
ReLayoutChildren
(
frame
)
;
}
void
nsMathMLContainerFrame
:
:
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
{
MOZ_ASSERT
(
aListID
=
=
kPrincipalList
)
;
mFrames
.
AppendFrames
(
this
aFrameList
)
;
ChildListChanged
(
nsIDOMMutationEvent
:
:
ADDITION
)
;
}
void
nsMathMLContainerFrame
:
:
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
aFrameList
)
{
MOZ_ASSERT
(
aListID
=
=
kPrincipalList
)
;
mFrames
.
InsertFrames
(
this
aPrevFrame
aFrameList
)
;
ChildListChanged
(
nsIDOMMutationEvent
:
:
ADDITION
)
;
}
void
nsMathMLContainerFrame
:
:
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
{
MOZ_ASSERT
(
aListID
=
=
kPrincipalList
)
;
mFrames
.
DestroyFrame
(
aOldFrame
)
;
ChildListChanged
(
nsIDOMMutationEvent
:
:
REMOVAL
)
;
}
nsresult
nsMathMLContainerFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsIAtom
*
aAttribute
int32_t
aModType
)
{
PresContext
(
)
-
>
PresShell
(
)
-
>
FrameNeedsReflow
(
this
nsIPresShell
:
:
eStyleChange
NS_FRAME_IS_DIRTY
)
;
return
NS_OK
;
}
void
nsMathMLContainerFrame
:
:
GatherAndStoreOverflow
(
ReflowOutput
*
aMetrics
)
{
mBlockStartAscent
=
aMetrics
-
>
BlockStartAscent
(
)
;
aMetrics
-
>
SetOverflowAreasToDesiredBounds
(
)
;
ComputeCustomOverflow
(
aMetrics
-
>
mOverflowAreas
)
;
UnionChildOverflow
(
aMetrics
-
>
mOverflowAreas
)
;
FinishAndStoreOverflow
(
aMetrics
)
;
}
bool
nsMathMLContainerFrame
:
:
ComputeCustomOverflow
(
nsOverflowAreas
&
aOverflowAreas
)
{
nsRect
boundingBox
(
mBoundingMetrics
.
leftBearing
mBlockStartAscent
-
mBoundingMetrics
.
ascent
mBoundingMetrics
.
rightBearing
-
mBoundingMetrics
.
leftBearing
mBoundingMetrics
.
ascent
+
mBoundingMetrics
.
descent
)
;
aOverflowAreas
.
UnionAllWith
(
boundingBox
)
;
return
nsContainerFrame
:
:
ComputeCustomOverflow
(
aOverflowAreas
)
;
}
void
nsMathMLContainerFrame
:
:
ReflowChild
(
nsIFrame
*
aChildFrame
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
#
ifdef
DEBUG
nsInlineFrame
*
inlineFrame
=
do_QueryFrame
(
aChildFrame
)
;
NS_ASSERTION
(
!
inlineFrame
"
Inline
frames
should
be
wrapped
in
blocks
"
)
;
#
endif
nsContainerFrame
:
:
ReflowChild
(
aChildFrame
aPresContext
aDesiredSize
aReflowInput
0
0
NS_FRAME_NO_MOVE_FRAME
aStatus
)
;
if
(
aDesiredSize
.
BlockStartAscent
(
)
=
=
ReflowOutput
:
:
ASK_FOR_BASELINE
)
{
nscoord
ascent
;
WritingMode
wm
=
aDesiredSize
.
GetWritingMode
(
)
;
if
(
!
nsLayoutUtils
:
:
GetLastLineBaseline
(
wm
aChildFrame
&
ascent
)
)
{
aDesiredSize
.
SetBlockStartAscent
(
aDesiredSize
.
BSize
(
wm
)
)
;
}
else
{
aDesiredSize
.
SetBlockStartAscent
(
ascent
)
;
}
}
if
(
IsForeignChild
(
aChildFrame
)
)
{
nsRect
r
=
aChildFrame
-
>
ComputeTightBounds
(
aReflowInput
.
mRenderingContext
-
>
GetDrawTarget
(
)
)
;
aDesiredSize
.
mBoundingMetrics
.
leftBearing
=
r
.
x
;
aDesiredSize
.
mBoundingMetrics
.
rightBearing
=
r
.
XMost
(
)
;
aDesiredSize
.
mBoundingMetrics
.
ascent
=
aDesiredSize
.
BlockStartAscent
(
)
-
r
.
y
;
aDesiredSize
.
mBoundingMetrics
.
descent
=
r
.
YMost
(
)
-
aDesiredSize
.
BlockStartAscent
(
)
;
aDesiredSize
.
mBoundingMetrics
.
width
=
aDesiredSize
.
Width
(
)
;
}
}
void
nsMathMLContainerFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
mPresentationData
.
flags
&
=
~
NS_MATHML_ERROR
;
aDesiredSize
.
Width
(
)
=
aDesiredSize
.
Height
(
)
=
0
;
aDesiredSize
.
SetBlockStartAscent
(
0
)
;
aDesiredSize
.
mBoundingMetrics
=
nsBoundingMetrics
(
)
;
nsReflowStatus
childStatus
;
nsIFrame
*
childFrame
=
mFrames
.
FirstChild
(
)
;
while
(
childFrame
)
{
ReflowOutput
childDesiredSize
(
aReflowInput
aDesiredSize
.
mFlags
)
;
WritingMode
wm
=
childFrame
-
>
GetWritingMode
(
)
;
LogicalSize
availSize
=
aReflowInput
.
ComputedSize
(
wm
)
;
availSize
.
BSize
(
wm
)
=
NS_UNCONSTRAINEDSIZE
;
ReflowInput
childReflowInput
(
aPresContext
aReflowInput
childFrame
availSize
)
;
ReflowChild
(
childFrame
aPresContext
childDesiredSize
childReflowInput
childStatus
)
;
SaveReflowAndBoundingMetricsFor
(
childFrame
childDesiredSize
childDesiredSize
.
mBoundingMetrics
)
;
childFrame
=
childFrame
-
>
GetNextSibling
(
)
;
}
DrawTarget
*
drawTarget
=
aReflowInput
.
mRenderingContext
-
>
GetDrawTarget
(
)
;
if
(
!
NS_MATHML_IS_EMBELLISH_OPERATOR
(
mEmbellishData
.
flags
)
&
&
(
NS_MATHML_WILL_STRETCH_ALL_CHILDREN_VERTICALLY
(
mPresentationData
.
flags
)
|
|
NS_MATHML_WILL_STRETCH_ALL_CHILDREN_HORIZONTALLY
(
mPresentationData
.
flags
)
)
)
{
nsStretchDirection
stretchDir
=
NS_MATHML_WILL_STRETCH_ALL_CHILDREN_VERTICALLY
(
mPresentationData
.
flags
)
?
NS_STRETCH_DIRECTION_VERTICAL
:
NS_STRETCH_DIRECTION_HORIZONTAL
;
nsBoundingMetrics
containerSize
;
GetPreferredStretchSize
(
drawTarget
0
stretchDir
containerSize
)
;
childFrame
=
mFrames
.
FirstChild
(
)
;
while
(
childFrame
)
{
nsIMathMLFrame
*
mathMLFrame
=
do_QueryFrame
(
childFrame
)
;
if
(
mathMLFrame
)
{
ReflowOutput
childDesiredSize
(
aReflowInput
)
;
GetReflowAndBoundingMetricsFor
(
childFrame
childDesiredSize
childDesiredSize
.
mBoundingMetrics
)
;
mathMLFrame
-
>
Stretch
(
drawTarget
stretchDir
containerSize
childDesiredSize
)
;
SaveReflowAndBoundingMetricsFor
(
childFrame
childDesiredSize
childDesiredSize
.
mBoundingMetrics
)
;
}
childFrame
=
childFrame
-
>
GetNextSibling
(
)
;
}
}
FinalizeReflow
(
drawTarget
aDesiredSize
)
;
aStatus
=
NS_FRAME_COMPLETE
;
NS_FRAME_SET_TRUNCATION
(
aStatus
aReflowInput
aDesiredSize
)
;
}
static
nscoord
AddInterFrameSpacingToSize
(
ReflowOutput
&
aDesiredSize
nsMathMLContainerFrame
*
aFrame
)
;
void
nsMathMLContainerFrame
:
:
MarkIntrinsicISizesDirty
(
)
{
mIntrinsicWidth
=
NS_INTRINSIC_WIDTH_UNKNOWN
;
nsContainerFrame
:
:
MarkIntrinsicISizesDirty
(
)
;
}
void
nsMathMLContainerFrame
:
:
UpdateIntrinsicWidth
(
nsRenderingContext
*
aRenderingContext
)
{
if
(
mIntrinsicWidth
=
=
NS_INTRINSIC_WIDTH_UNKNOWN
)
{
ReflowOutput
desiredSize
(
GetWritingMode
(
)
)
;
GetIntrinsicISizeMetrics
(
aRenderingContext
desiredSize
)
;
AddInterFrameSpacingToSize
(
desiredSize
this
)
;
mIntrinsicWidth
=
desiredSize
.
ISize
(
GetWritingMode
(
)
)
;
}
}
nscoord
nsMathMLContainerFrame
:
:
GetMinISize
(
nsRenderingContext
*
aRenderingContext
)
{
nscoord
result
;
DISPLAY_MIN_WIDTH
(
this
result
)
;
UpdateIntrinsicWidth
(
aRenderingContext
)
;
result
=
mIntrinsicWidth
;
return
result
;
}
nscoord
nsMathMLContainerFrame
:
:
GetPrefISize
(
nsRenderingContext
*
aRenderingContext
)
{
nscoord
result
;
DISPLAY_PREF_WIDTH
(
this
result
)
;
UpdateIntrinsicWidth
(
aRenderingContext
)
;
result
=
mIntrinsicWidth
;
return
result
;
}
void
nsMathMLContainerFrame
:
:
GetIntrinsicISizeMetrics
(
nsRenderingContext
*
aRenderingContext
ReflowOutput
&
aDesiredSize
)
{
nsIFrame
*
childFrame
=
mFrames
.
FirstChild
(
)
;
while
(
childFrame
)
{
ReflowOutput
childDesiredSize
(
GetWritingMode
(
)
)
;
nsMathMLContainerFrame
*
containerFrame
=
do_QueryFrame
(
childFrame
)
;
if
(
containerFrame
)
{
containerFrame
-
>
GetIntrinsicISizeMetrics
(
aRenderingContext
childDesiredSize
)
;
}
else
{
nscoord
width
=
nsLayoutUtils
:
:
IntrinsicForContainer
(
aRenderingContext
childFrame
nsLayoutUtils
:
:
PREF_ISIZE
)
;
childDesiredSize
.
Width
(
)
=
width
;
childDesiredSize
.
mBoundingMetrics
.
width
=
width
;
childDesiredSize
.
mBoundingMetrics
.
leftBearing
=
0
;
childDesiredSize
.
mBoundingMetrics
.
rightBearing
=
width
;
nscoord
x
xMost
;
if
(
NS_SUCCEEDED
(
childFrame
-
>
GetPrefWidthTightBounds
(
aRenderingContext
&
x
&
xMost
)
)
)
{
childDesiredSize
.
mBoundingMetrics
.
leftBearing
=
x
;
childDesiredSize
.
mBoundingMetrics
.
rightBearing
=
xMost
;
}
}
SaveReflowAndBoundingMetricsFor
(
childFrame
childDesiredSize
childDesiredSize
.
mBoundingMetrics
)
;
childFrame
=
childFrame
-
>
GetNextSibling
(
)
;
}
nsresult
rv
=
MeasureForWidth
(
aRenderingContext
-
>
GetDrawTarget
(
)
aDesiredSize
)
;
if
(
NS_FAILED
(
rv
)
)
{
ReflowError
(
aRenderingContext
-
>
GetDrawTarget
(
)
aDesiredSize
)
;
}
ClearSavedChildMetrics
(
)
;
}
nsresult
nsMathMLContainerFrame
:
:
MeasureForWidth
(
DrawTarget
*
aDrawTarget
ReflowOutput
&
aDesiredSize
)
{
return
Place
(
aDrawTarget
false
aDesiredSize
)
;
}
static
int32_t
kInterFrameSpacingTable
[
eMathMLFrameType_COUNT
]
[
eMathMLFrameType_COUNT
]
=
{
{
0x00
0x00
0x00
0x01
0x01
0x00
0x00
}
{
0x00
0x00
0x00
0x00
0x00
0x00
0x00
}
{
0x00
0x00
0x00
0x00
0x00
0x00
0x00
}
{
0x01
0x00
0x00
0x01
0x01
0x01
0x01
}
{
0x01
0x00
0x00
0x01
0x01
0x01
0x01
}
{
0x00
0x00
0x00
0x01
0x01
0x00
0x01
}
{
0x00
0x00
0x00
0x01
0x01
0x01
0x00
}
}
;
#
define
GET_INTERSPACE
(
scriptlevel_
frametype1_
frametype2_
space_
)
\
if
(
frametype1_
=
=
eMathMLFrameType_UNKNOWN
|
|
\
frametype2_
=
=
eMathMLFrameType_UNKNOWN
)
\
space_
=
0
;
\
else
{
\
space_
=
kInterFrameSpacingTable
[
frametype1_
]
[
frametype2_
]
;
\
space_
=
(
scriptlevel_
>
0
&
&
(
space_
&
0xF0
)
)
\
?
0
/
*
spacing
is
disabled
*
/
\
:
space_
&
0x0F
;
\
}
\
static
nscoord
GetInterFrameSpacing
(
int32_t
aScriptLevel
eMathMLFrameType
aFirstFrameType
eMathMLFrameType
aSecondFrameType
eMathMLFrameType
*
aFromFrameType
int32_t
*
aCarrySpace
)
{
eMathMLFrameType
firstType
=
aFirstFrameType
;
eMathMLFrameType
secondType
=
aSecondFrameType
;
int32_t
space
;
GET_INTERSPACE
(
aScriptLevel
firstType
secondType
space
)
;
if
(
secondType
=
=
eMathMLFrameType_OperatorInvisible
)
{
if
(
*
aFromFrameType
=
=
eMathMLFrameType_UNKNOWN
)
{
*
aFromFrameType
=
firstType
;
*
aCarrySpace
=
space
;
}
space
=
0
;
}
else
if
(
*
aFromFrameType
!
=
eMathMLFrameType_UNKNOWN
)
{
firstType
=
*
aFromFrameType
;
if
(
firstType
=
=
eMathMLFrameType_UprightIdentifier
)
{
firstType
=
eMathMLFrameType_OperatorUserDefined
;
}
else
if
(
secondType
=
=
eMathMLFrameType_UprightIdentifier
)
{
secondType
=
eMathMLFrameType_OperatorUserDefined
;
}
GET_INTERSPACE
(
aScriptLevel
firstType
secondType
space
)
;
if
(
secondType
!
=
eMathMLFrameType_OperatorOrdinary
&
&
space
<
*
aCarrySpace
)
space
=
*
aCarrySpace
;
*
aFromFrameType
=
eMathMLFrameType_UNKNOWN
;
*
aCarrySpace
=
0
;
}
return
space
;
}
static
nscoord
GetThinSpace
(
const
nsStyleFont
*
aStyleFont
)
{
return
NSToCoordRound
(
float
(
aStyleFont
-
>
mFont
.
size
)
*
float
(
3
)
/
float
(
18
)
)
;
}
class
nsMathMLContainerFrame
:
:
RowChildFrameIterator
{
public
:
explicit
RowChildFrameIterator
(
nsMathMLContainerFrame
*
aParentFrame
)
:
mParentFrame
(
aParentFrame
)
mReflowOutput
(
aParentFrame
-
>
GetWritingMode
(
)
)
mX
(
0
)
mCarrySpace
(
0
)
mFromFrameType
(
eMathMLFrameType_UNKNOWN
)
mRTL
(
aParentFrame
-
>
StyleVisibility
(
)
-
>
mDirection
)
{
if
(
!
mRTL
)
{
mChildFrame
=
aParentFrame
-
>
mFrames
.
FirstChild
(
)
;
}
else
{
mChildFrame
=
aParentFrame
-
>
mFrames
.
LastChild
(
)
;
}
if
(
!
mChildFrame
)
return
;
InitMetricsForChild
(
)
;
}
RowChildFrameIterator
&
operator
+
+
(
)
{
mX
+
=
mReflowOutput
.
mBoundingMetrics
.
width
+
mItalicCorrection
;
if
(
!
mRTL
)
{
mChildFrame
=
mChildFrame
-
>
GetNextSibling
(
)
;
}
else
{
mChildFrame
=
mChildFrame
-
>
GetPrevSibling
(
)
;
}
if
(
!
mChildFrame
)
return
*
this
;
eMathMLFrameType
prevFrameType
=
mChildFrameType
;
InitMetricsForChild
(
)
;
const
nsStyleFont
*
font
=
mParentFrame
-
>
StyleFont
(
)
;
nscoord
space
=
GetInterFrameSpacing
(
font
-
>
mScriptLevel
prevFrameType
mChildFrameType
&
mFromFrameType
&
mCarrySpace
)
;
mX
+
=
space
*
GetThinSpace
(
font
)
;
return
*
this
;
}
nsIFrame
*
Frame
(
)
const
{
return
mChildFrame
;
}
nscoord
X
(
)
const
{
return
mX
;
}
const
ReflowOutput
&
GetReflowOutput
(
)
const
{
return
mReflowOutput
;
}
nscoord
Ascent
(
)
const
{
return
mReflowOutput
.
BlockStartAscent
(
)
;
}
nscoord
Descent
(
)
const
{
return
mReflowOutput
.
Height
(
)
-
mReflowOutput
.
BlockStartAscent
(
)
;
}
const
nsBoundingMetrics
&
BoundingMetrics
(
)
const
{
return
mReflowOutput
.
mBoundingMetrics
;
}
private
:
const
nsMathMLContainerFrame
*
mParentFrame
;
nsIFrame
*
mChildFrame
;
ReflowOutput
mReflowOutput
;
nscoord
mX
;
nscoord
mItalicCorrection
;
eMathMLFrameType
mChildFrameType
;
int32_t
mCarrySpace
;
eMathMLFrameType
mFromFrameType
;
bool
mRTL
;
void
InitMetricsForChild
(
)
{
GetReflowAndBoundingMetricsFor
(
mChildFrame
mReflowOutput
mReflowOutput
.
mBoundingMetrics
&
mChildFrameType
)
;
nscoord
leftCorrection
rightCorrection
;
GetItalicCorrection
(
mReflowOutput
.
mBoundingMetrics
leftCorrection
rightCorrection
)
;
if
(
!
mChildFrame
-
>
GetPrevSibling
(
)
&
&
mParentFrame
-
>
GetContent
(
)
-
>
IsMathMLElement
(
nsGkAtoms
:
:
msqrt_
)
)
{
if
(
!
mRTL
)
{
leftCorrection
=
0
;
}
else
{
rightCorrection
=
0
;
}
}
mX
+
=
leftCorrection
;
mItalicCorrection
=
rightCorrection
;
}
}
;
nsresult
nsMathMLContainerFrame
:
:
Place
(
DrawTarget
*
aDrawTarget
bool
aPlaceOrigin
ReflowOutput
&
aDesiredSize
)
{
mBoundingMetrics
=
nsBoundingMetrics
(
)
;
RowChildFrameIterator
child
(
this
)
;
nscoord
ascent
=
0
descent
=
0
;
while
(
child
.
Frame
(
)
)
{
if
(
descent
<
child
.
Descent
(
)
)
descent
=
child
.
Descent
(
)
;
if
(
ascent
<
child
.
Ascent
(
)
)
ascent
=
child
.
Ascent
(
)
;
mBoundingMetrics
.
width
=
child
.
X
(
)
;
mBoundingMetrics
+
=
child
.
BoundingMetrics
(
)
;
+
+
child
;
}
mBoundingMetrics
.
width
=
child
.
X
(
)
;
aDesiredSize
.
Width
(
)
=
std
:
:
max
(
0
mBoundingMetrics
.
width
)
;
aDesiredSize
.
Height
(
)
=
ascent
+
descent
;
aDesiredSize
.
SetBlockStartAscent
(
ascent
)
;
aDesiredSize
.
mBoundingMetrics
=
mBoundingMetrics
;
mReference
.
x
=
0
;
mReference
.
y
=
aDesiredSize
.
BlockStartAscent
(
)
;
if
(
aPlaceOrigin
)
{
PositionRowChildFrames
(
0
aDesiredSize
.
BlockStartAscent
(
)
)
;
}
return
NS_OK
;
}
void
nsMathMLContainerFrame
:
:
PositionRowChildFrames
(
nscoord
aOffsetX
nscoord
aBaseline
)
{
RowChildFrameIterator
child
(
this
)
;
while
(
child
.
Frame
(
)
)
{
nscoord
dx
=
aOffsetX
+
child
.
X
(
)
;
nscoord
dy
=
aBaseline
-
child
.
Ascent
(
)
;
FinishReflowChild
(
child
.
Frame
(
)
PresContext
(
)
child
.
GetReflowOutput
(
)
nullptr
dx
dy
0
)
;
+
+
child
;
}
}
class
ForceReflow
:
public
nsIReflowCallback
{
public
:
virtual
bool
ReflowFinished
(
)
override
{
return
true
;
}
virtual
void
ReflowCallbackCanceled
(
)
override
{
}
}
;
static
ForceReflow
gForceReflow
;
void
nsMathMLContainerFrame
:
:
SetIncrementScriptLevel
(
int32_t
aChildIndex
bool
aIncrement
)
{
nsIFrame
*
child
=
PrincipalChildList
(
)
.
FrameAt
(
aChildIndex
)
;
if
(
!
child
)
return
;
nsIContent
*
content
=
child
-
>
GetContent
(
)
;
if
(
!
content
-
>
IsMathMLElement
(
)
)
return
;
nsMathMLElement
*
element
=
static_cast
<
nsMathMLElement
*
>
(
content
)
;
if
(
element
-
>
GetIncrementScriptLevel
(
)
=
=
aIncrement
)
return
;
element
-
>
SetIncrementScriptLevel
(
aIncrement
true
)
;
PresContext
(
)
-
>
PresShell
(
)
-
>
PostReflowCallback
(
&
gForceReflow
)
;
}
static
nscoord
GetInterFrameSpacingFor
(
int32_t
aScriptLevel
nsIFrame
*
aParentFrame
nsIFrame
*
aChildFrame
)
{
nsIFrame
*
childFrame
=
aParentFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
!
childFrame
|
|
aChildFrame
=
=
childFrame
)
return
0
;
int32_t
carrySpace
=
0
;
eMathMLFrameType
fromFrameType
=
eMathMLFrameType_UNKNOWN
;
eMathMLFrameType
prevFrameType
=
eMathMLFrameType_UNKNOWN
;
eMathMLFrameType
childFrameType
=
nsMathMLFrame
:
:
GetMathMLFrameTypeFor
(
childFrame
)
;
childFrame
=
childFrame
-
>
GetNextSibling
(
)
;
while
(
childFrame
)
{
prevFrameType
=
childFrameType
;
childFrameType
=
nsMathMLFrame
:
:
GetMathMLFrameTypeFor
(
childFrame
)
;
nscoord
space
=
GetInterFrameSpacing
(
aScriptLevel
prevFrameType
childFrameType
&
fromFrameType
&
carrySpace
)
;
if
(
aChildFrame
=
=
childFrame
)
{
nsStyleContext
*
parentContext
=
aParentFrame
-
>
StyleContext
(
)
;
nscoord
thinSpace
=
GetThinSpace
(
parentContext
-
>
StyleFont
(
)
)
;
return
space
*
thinSpace
;
}
childFrame
=
childFrame
-
>
GetNextSibling
(
)
;
}
NS_NOTREACHED
(
"
child
not
in
the
childlist
of
its
parent
"
)
;
return
0
;
}
static
nscoord
AddInterFrameSpacingToSize
(
ReflowOutput
&
aDesiredSize
nsMathMLContainerFrame
*
aFrame
)
{
nscoord
gap
=
0
;
nsIFrame
*
parent
=
aFrame
-
>
GetParent
(
)
;
nsIContent
*
parentContent
=
parent
-
>
GetContent
(
)
;
if
(
MOZ_UNLIKELY
(
!
parentContent
)
)
{
return
0
;
}
if
(
parentContent
-
>
IsAnyOfMathMLElements
(
nsGkAtoms
:
:
math
nsGkAtoms
:
:
mtd_
)
)
{
gap
=
GetInterFrameSpacingFor
(
aFrame
-
>
StyleFont
(
)
-
>
mScriptLevel
parent
aFrame
)
;
nscoord
leftCorrection
=
0
italicCorrection
=
0
;
aFrame
-
>
GetItalicCorrection
(
aDesiredSize
.
mBoundingMetrics
leftCorrection
italicCorrection
)
;
gap
+
=
leftCorrection
;
if
(
gap
)
{
aDesiredSize
.
mBoundingMetrics
.
leftBearing
+
=
gap
;
aDesiredSize
.
mBoundingMetrics
.
rightBearing
+
=
gap
;
aDesiredSize
.
mBoundingMetrics
.
width
+
=
gap
;
aDesiredSize
.
Width
(
)
+
=
gap
;
}
aDesiredSize
.
mBoundingMetrics
.
width
+
=
italicCorrection
;
aDesiredSize
.
Width
(
)
+
=
italicCorrection
;
}
return
gap
;
}
nscoord
nsMathMLContainerFrame
:
:
FixInterFrameSpacing
(
ReflowOutput
&
aDesiredSize
)
{
nscoord
gap
=
0
;
gap
=
AddInterFrameSpacingToSize
(
aDesiredSize
this
)
;
if
(
gap
)
{
nsIFrame
*
childFrame
=
mFrames
.
FirstChild
(
)
;
while
(
childFrame
)
{
childFrame
-
>
SetPosition
(
childFrame
-
>
GetPosition
(
)
+
nsPoint
(
gap
0
)
)
;
childFrame
=
childFrame
-
>
GetNextSibling
(
)
;
}
}
return
gap
;
}
void
nsMathMLContainerFrame
:
:
DidReflowChildren
(
nsIFrame
*
aFirst
nsIFrame
*
aStop
)
{
if
(
MOZ_UNLIKELY
(
!
aFirst
)
)
return
;
for
(
nsIFrame
*
frame
=
aFirst
;
frame
!
=
aStop
;
frame
=
frame
-
>
GetNextSibling
(
)
)
{
NS_ASSERTION
(
frame
"
aStop
isn
'
t
a
sibling
"
)
;
if
(
frame
-
>
GetStateBits
(
)
&
NS_FRAME_IN_REFLOW
)
{
nsIFrame
*
grandchild
=
frame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
grandchild
)
DidReflowChildren
(
grandchild
nullptr
)
;
frame
-
>
DidReflow
(
frame
-
>
PresContext
(
)
nullptr
nsDidReflowStatus
:
:
FINISHED
)
;
}
}
}
nsresult
nsMathMLContainerFrame
:
:
TransmitAutomaticDataForMrowLikeElement
(
)
{
nsIFrame
*
childFrame
*
baseFrame
;
bool
embellishedOpFound
=
false
;
nsEmbellishData
embellishData
;
for
(
childFrame
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
childFrame
;
childFrame
=
childFrame
-
>
GetNextSibling
(
)
)
{
nsIMathMLFrame
*
mathMLFrame
=
do_QueryFrame
(
childFrame
)
;
if
(
!
mathMLFrame
)
break
;
if
(
!
mathMLFrame
-
>
IsSpaceLike
(
)
)
{
if
(
embellishedOpFound
)
break
;
baseFrame
=
childFrame
;
GetEmbellishDataFrom
(
baseFrame
embellishData
)
;
if
(
!
NS_MATHML_IS_EMBELLISH_OPERATOR
(
embellishData
.
flags
)
)
break
;
embellishedOpFound
=
true
;
}
}
if
(
!
childFrame
)
{
if
(
!
embellishedOpFound
)
{
mPresentationData
.
flags
|
=
NS_MATHML_SPACE_LIKE
;
}
else
{
mPresentationData
.
baseFrame
=
baseFrame
;
mEmbellishData
=
embellishData
;
}
}
if
(
childFrame
|
|
!
embellishedOpFound
)
{
mPresentationData
.
baseFrame
=
nullptr
;
mEmbellishData
.
flags
=
0
;
mEmbellishData
.
coreFrame
=
nullptr
;
mEmbellishData
.
direction
=
NS_STRETCH_DIRECTION_UNSUPPORTED
;
mEmbellishData
.
leadingSpace
=
0
;
mEmbellishData
.
trailingSpace
=
0
;
}
if
(
childFrame
|
|
embellishedOpFound
)
{
mPresentationData
.
flags
&
=
~
NS_MATHML_SPACE_LIKE
;
}
return
NS_OK
;
}
void
nsMathMLContainerFrame
:
:
PropagateFrameFlagFor
(
nsIFrame
*
aFrame
nsFrameState
aFlags
)
{
if
(
!
aFrame
|
|
!
aFlags
)
return
;
aFrame
-
>
AddStateBits
(
aFlags
)
;
for
(
nsIFrame
*
childFrame
:
aFrame
-
>
PrincipalChildList
(
)
)
{
PropagateFrameFlagFor
(
childFrame
aFlags
)
;
}
}
nsresult
nsMathMLContainerFrame
:
:
ReportErrorToConsole
(
const
char
*
errorMsgId
const
char16_t
*
*
aParams
uint32_t
aParamCount
)
{
return
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
errorFlag
NS_LITERAL_CSTRING
(
"
Layout
:
MathML
"
)
mContent
-
>
OwnerDoc
(
)
nsContentUtils
:
:
eMATHML_PROPERTIES
errorMsgId
aParams
aParamCount
)
;
}
nsresult
nsMathMLContainerFrame
:
:
ReportParseError
(
const
char16_t
*
aAttribute
const
char16_t
*
aValue
)
{
const
char16_t
*
argv
[
]
=
{
aValue
aAttribute
mContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
-
>
GetUTF16String
(
)
}
;
return
ReportErrorToConsole
(
"
AttributeParsingError
"
argv
3
)
;
}
nsresult
nsMathMLContainerFrame
:
:
ReportChildCountError
(
)
{
const
char16_t
*
arg
=
mContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
-
>
GetUTF16String
(
)
;
return
ReportErrorToConsole
(
"
ChildCountIncorrect
"
&
arg
1
)
;
}
nsresult
nsMathMLContainerFrame
:
:
ReportInvalidChildError
(
nsIAtom
*
aChildTag
)
{
const
char16_t
*
argv
[
]
=
{
aChildTag
-
>
GetUTF16String
(
)
mContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
-
>
GetUTF16String
(
)
}
;
return
ReportErrorToConsole
(
"
InvalidChild
"
argv
2
)
;
}
nsContainerFrame
*
NS_NewMathMLmathBlockFrame
(
nsIPresShell
*
aPresShell
nsStyleContext
*
aContext
nsFrameState
aFlags
)
{
nsMathMLmathBlockFrame
*
it
=
new
(
aPresShell
)
nsMathMLmathBlockFrame
(
aContext
)
;
it
-
>
SetFlags
(
aFlags
)
;
return
it
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsMathMLmathBlockFrame
)
NS_QUERYFRAME_HEAD
(
nsMathMLmathBlockFrame
)
NS_QUERYFRAME_ENTRY
(
nsMathMLmathBlockFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsBlockFrame
)
nsContainerFrame
*
NS_NewMathMLmathInlineFrame
(
nsIPresShell
*
aPresShell
nsStyleContext
*
aContext
)
{
return
new
(
aPresShell
)
nsMathMLmathInlineFrame
(
aContext
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsMathMLmathInlineFrame
)
NS_QUERYFRAME_HEAD
(
nsMathMLmathInlineFrame
)
NS_QUERYFRAME_ENTRY
(
nsIMathMLFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsInlineFrame
)
