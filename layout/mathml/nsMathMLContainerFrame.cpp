#
include
"
nsMathMLContainerFrame
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
dom
/
MutationEventBinding
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
mozilla
/
dom
/
MathMLElement
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
NS_QUERYFRAME_HEAD
(
nsMathMLContainerFrame
)
NS_QUERYFRAME_ENTRY
(
nsIMathMLFrame
)
NS_QUERYFRAME_ENTRY
(
nsMathMLContainerFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsContainerFrame
)
static
bool
IsForeignChild
(
const
nsIFrame
*
aFrame
)
{
return
!
aFrame
-
>
IsMathMLFrame
(
)
|
|
aFrame
-
>
IsBlockFrame
(
)
;
}
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
HTMLReflowOutputProperty
ReflowOutput
)
void
nsMathMLContainerFrame
:
:
SaveReflowAndBoundingMetricsFor
(
nsIFrame
*
aFrame
const
ReflowOutput
&
aReflowOutput
const
nsBoundingMetrics
&
aBoundingMetrics
)
{
ReflowOutput
*
reflowOutput
=
new
ReflowOutput
(
aReflowOutput
)
;
reflowOutput
-
>
mBoundingMetrics
=
aBoundingMetrics
;
aFrame
-
>
SetProperty
(
HTMLReflowOutputProperty
(
)
reflowOutput
)
;
}
void
nsMathMLContainerFrame
:
:
GetReflowAndBoundingMetricsFor
(
nsIFrame
*
aFrame
ReflowOutput
&
aReflowOutput
nsBoundingMetrics
&
aBoundingMetrics
eMathMLFrameType
*
aMathMLFrameType
)
{
MOZ_ASSERT
(
aFrame
"
null
arg
"
)
;
ReflowOutput
*
reflowOutput
=
aFrame
-
>
GetProperty
(
HTMLReflowOutputProperty
(
)
)
;
NS_ASSERTION
(
reflowOutput
"
Didn
'
t
SaveReflowAndBoundingMetricsFor
frame
!
"
)
;
if
(
reflowOutput
)
{
aReflowOutput
=
*
reflowOutput
;
aBoundingMetrics
=
reflowOutput
-
>
mBoundingMetrics
;
}
if
(
aMathMLFrameType
)
{
if
(
!
IsForeignChild
(
aFrame
)
)
{
nsIMathMLFrame
*
mathMLFrame
=
do_QueryFrame
(
aFrame
)
;
if
(
mathMLFrame
)
{
*
aMathMLFrameType
=
mathMLFrame
-
>
GetMathMLFrameType
(
)
;
return
;
}
}
*
aMathMLFrameType
=
eMathMLFrameType_UNKNOWN
;
}
}
void
nsMathMLContainerFrame
:
:
ClearSavedChildMetrics
(
)
{
nsIFrame
*
childFrame
=
mFrames
.
FirstChild
(
)
;
while
(
childFrame
)
{
childFrame
-
>
RemoveProperty
(
HTMLReflowOutputProperty
(
)
)
;
childFrame
=
childFrame
-
>
GetNextSibling
(
)
;
}
}
nsMargin
nsMathMLContainerFrame
:
:
GetBorderPaddingForPlace
(
const
PlaceFlags
&
aFlags
)
{
if
(
aFlags
.
contains
(
PlaceFlag
:
:
IgnoreBorderPadding
)
)
{
return
nsMargin
(
)
;
}
if
(
aFlags
.
contains
(
PlaceFlag
:
:
IntrinsicSize
)
)
{
return
nsMargin
(
0
IntrinsicISizeOffsets
(
)
.
BorderPadding
(
)
0
0
)
;
}
return
GetUsedBorderAndPadding
(
)
;
}
nsMargin
nsMathMLContainerFrame
:
:
GetMarginForPlace
(
const
PlaceFlags
&
aFlags
nsIFrame
*
aChild
)
{
if
(
aFlags
.
contains
(
PlaceFlag
:
:
IntrinsicSize
)
)
{
return
nsMargin
(
0
aChild
-
>
IntrinsicISizeOffsets
(
)
.
margin
0
0
)
;
}
return
aChild
-
>
GetUsedMargin
(
)
;
}
void
nsMathMLContainerFrame
:
:
InflateReflowAndBoundingMetrics
(
const
nsMargin
&
aBorderPadding
ReflowOutput
&
aReflowOutput
nsBoundingMetrics
&
aBoundingMetrics
)
{
aBoundingMetrics
.
rightBearing
+
=
aBorderPadding
.
LeftRight
(
)
;
aBoundingMetrics
.
width
+
=
aBorderPadding
.
LeftRight
(
)
;
aReflowOutput
.
mBoundingMetrics
=
aBoundingMetrics
;
aReflowOutput
.
Width
(
)
+
=
aBorderPadding
.
LeftRight
(
)
;
aReflowOutput
.
SetBlockStartAscent
(
aReflowOutput
.
BlockStartAscent
(
)
+
aBorderPadding
.
top
)
;
aReflowOutput
.
Height
(
)
+
=
aBorderPadding
.
TopBottom
(
)
;
}
nsMathMLContainerFrame
:
:
WidthAndHeightForPlaceAdjustment
nsMathMLContainerFrame
:
:
GetWidthAndHeightForPlaceAdjustment
(
const
PlaceFlags
&
aFlags
)
{
WidthAndHeightForPlaceAdjustment
sizes
;
if
(
aFlags
.
contains
(
PlaceFlag
:
:
DoNotAdjustForWidthAndHeight
)
)
{
return
sizes
;
}
const
nsStylePosition
*
stylePos
=
StylePosition
(
)
;
const
auto
&
width
=
stylePos
-
>
mWidth
;
if
(
width
.
ConvertsToLength
(
)
)
{
sizes
.
width
=
Some
(
width
.
ToLength
(
)
)
;
}
if
(
!
aFlags
.
contains
(
PlaceFlag
:
:
IntrinsicSize
)
)
{
const
auto
&
height
=
stylePos
-
>
mHeight
;
if
(
height
.
ConvertsToLength
(
)
)
{
sizes
.
height
=
Some
(
height
.
ToLength
(
)
)
;
}
}
return
sizes
;
}
nscoord
nsMathMLContainerFrame
:
:
ApplyAdjustmentForWidthAndHeight
(
const
PlaceFlags
&
aFlags
const
WidthAndHeightForPlaceAdjustment
&
aSizes
ReflowOutput
&
aReflowOutput
nsBoundingMetrics
&
aBoundingMetrics
)
{
nscoord
shiftX
=
0
;
if
(
aSizes
.
width
)
{
MOZ_ASSERT
(
!
aFlags
.
contains
(
PlaceFlag
:
:
DoNotAdjustForWidthAndHeight
)
)
;
auto
width
=
*
aSizes
.
width
;
auto
oldWidth
=
aReflowOutput
.
Width
(
)
;
if
(
IsMathContentBoxHorizontallyCentered
(
)
)
{
shiftX
=
(
width
-
oldWidth
)
/
2
;
}
else
if
(
StyleVisibility
(
)
-
>
mDirection
=
=
StyleDirection
:
:
Rtl
)
{
shiftX
=
width
-
oldWidth
;
}
aBoundingMetrics
.
leftBearing
=
0
;
aBoundingMetrics
.
rightBearing
=
width
;
aBoundingMetrics
.
width
=
width
;
aReflowOutput
.
mBoundingMetrics
=
aBoundingMetrics
;
aReflowOutput
.
Width
(
)
=
width
;
}
if
(
aSizes
.
height
)
{
MOZ_ASSERT
(
!
aFlags
.
contains
(
PlaceFlag
:
:
DoNotAdjustForWidthAndHeight
)
)
;
MOZ_ASSERT
(
!
aFlags
.
contains
(
PlaceFlag
:
:
IntrinsicSize
)
)
;
auto
height
=
*
aSizes
.
height
;
aReflowOutput
.
Height
(
)
=
height
;
}
return
shiftX
;
}
void
nsMathMLContainerFrame
:
:
GetPreferredStretchSize
(
DrawTarget
*
aDrawTarget
uint32_t
aOptions
nsStretchDirection
aStretchDirection
nsBoundingMetrics
&
aPreferredStretchSize
)
{
if
(
aOptions
&
STRETCH_CONSIDER_ACTUAL_SIZE
)
{
aPreferredStretchSize
=
mBoundingMetrics
;
}
else
if
(
aOptions
&
STRETCH_CONSIDER_EMBELLISHMENTS
)
{
ReflowOutput
reflowOutput
(
GetWritingMode
(
)
)
;
PlaceFlags
flags
(
PlaceFlag
:
:
MeasureOnly
PlaceFlag
:
:
IgnoreBorderPadding
)
;
Place
(
aDrawTarget
flags
reflowOutput
)
;
aPreferredStretchSize
=
reflowOutput
.
mBoundingMetrics
;
}
else
{
bool
stretchAll
=
aStretchDirection
=
=
NS_STRETCH_DIRECTION_VERTICAL
?
NS_MATHML_WILL_STRETCH_ALL_CHILDREN_VERTICALLY
(
mPresentationData
.
flags
)
:
NS_MATHML_WILL_STRETCH_ALL_CHILDREN_HORIZONTALLY
(
mPresentationData
.
flags
)
;
NS_ASSERTION
(
aStretchDirection
=
=
NS_STRETCH_DIRECTION_HORIZONTAL
|
|
aStretchDirection
=
=
NS_STRETCH_DIRECTION_VERTICAL
"
You
must
specify
a
direction
in
which
to
stretch
"
)
;
NS_ASSERTION
(
NS_MATHML_IS_EMBELLISH_OPERATOR
(
mEmbellishData
.
flags
)
|
|
stretchAll
"
invalid
call
to
GetPreferredStretchSize
"
)
;
bool
firstTime
=
true
;
nsBoundingMetrics
bm
bmChild
;
nsIFrame
*
childFrame
=
stretchAll
?
PrincipalChildList
(
)
.
FirstChild
(
)
:
mPresentationData
.
baseFrame
;
while
(
childFrame
)
{
nsIMathMLFrame
*
mathMLFrame
=
do_QueryFrame
(
childFrame
)
;
if
(
mathMLFrame
)
{
nsEmbellishData
embellishData
;
nsPresentationData
presentationData
;
mathMLFrame
-
>
GetEmbellishData
(
embellishData
)
;
mathMLFrame
-
>
GetPresentationData
(
presentationData
)
;
if
(
NS_MATHML_IS_EMBELLISH_OPERATOR
(
embellishData
.
flags
)
&
&
embellishData
.
direction
=
=
aStretchDirection
&
&
presentationData
.
baseFrame
)
{
nsIMathMLFrame
*
mathMLchildFrame
=
do_QueryFrame
(
presentationData
.
baseFrame
)
;
if
(
mathMLchildFrame
)
{
mathMLFrame
=
mathMLchildFrame
;
}
}
mathMLFrame
-
>
GetBoundingMetrics
(
bmChild
)
;
}
else
{
ReflowOutput
unused
(
GetWritingMode
(
)
)
;
GetReflowAndBoundingMetricsFor
(
childFrame
unused
bmChild
)
;
}
if
(
firstTime
)
{
firstTime
=
false
;
bm
=
bmChild
;
if
(
!
stretchAll
)
{
break
;
}
}
else
{
if
(
aStretchDirection
=
=
NS_STRETCH_DIRECTION_HORIZONTAL
)
{
bm
.
descent
+
=
bmChild
.
ascent
+
bmChild
.
descent
;
if
(
bmChild
.
width
=
=
0
)
{
bmChild
.
rightBearing
-
=
bmChild
.
leftBearing
;
bmChild
.
leftBearing
=
0
;
}
if
(
bm
.
leftBearing
>
bmChild
.
leftBearing
)
bm
.
leftBearing
=
bmChild
.
leftBearing
;
if
(
bm
.
rightBearing
<
bmChild
.
rightBearing
)
bm
.
rightBearing
=
bmChild
.
rightBearing
;
}
else
if
(
aStretchDirection
=
=
NS_STRETCH_DIRECTION_VERTICAL
)
{
bm
+
=
bmChild
;
}
else
{
NS_ERROR
(
"
unexpected
case
in
GetPreferredStretchSize
"
)
;
break
;
}
}
childFrame
=
childFrame
-
>
GetNextSibling
(
)
;
}
aPreferredStretchSize
=
bm
;
}
}
NS_IMETHODIMP
nsMathMLContainerFrame
:
:
Stretch
(
DrawTarget
*
aDrawTarget
nsStretchDirection
aStretchDirection
nsBoundingMetrics
&
aContainerSize
ReflowOutput
&
aDesiredStretchSize
)
{
if
(
NS_MATHML_IS_EMBELLISH_OPERATOR
(
mEmbellishData
.
flags
)
)
{
if
(
NS_MATHML_STRETCH_WAS_DONE
(
mPresentationData
.
flags
)
)
{
NS_WARNING
(
"
it
is
wrong
to
fire
stretch
more
than
once
on
a
frame
"
)
;
return
NS_OK
;
}
mPresentationData
.
flags
|
=
NS_MATHML_STRETCH_DONE
;
nsIFrame
*
baseFrame
=
mPresentationData
.
baseFrame
;
if
(
baseFrame
)
{
nsIMathMLFrame
*
mathMLFrame
=
do_QueryFrame
(
baseFrame
)
;
NS_ASSERTION
(
mathMLFrame
"
Something
is
wrong
somewhere
"
)
;
if
(
mathMLFrame
)
{
ReflowOutput
childSize
(
aDesiredStretchSize
)
;
GetReflowAndBoundingMetricsFor
(
baseFrame
childSize
childSize
.
mBoundingMetrics
)
;
nsBoundingMetrics
containerSize
=
aContainerSize
;
if
(
aStretchDirection
!
=
mEmbellishData
.
direction
&
&
mEmbellishData
.
direction
!
=
NS_STRETCH_DIRECTION_UNSUPPORTED
)
{
NS_ASSERTION
(
mEmbellishData
.
direction
!
=
NS_STRETCH_DIRECTION_DEFAULT
"
Stretches
may
have
a
default
direction
operators
can
not
.
"
)
;
if
(
mEmbellishData
.
direction
=
=
NS_STRETCH_DIRECTION_VERTICAL
?
NS_MATHML_WILL_STRETCH_ALL_CHILDREN_VERTICALLY
(
mPresentationData
.
flags
)
:
NS_MATHML_WILL_STRETCH_ALL_CHILDREN_HORIZONTALLY
(
mPresentationData
.
flags
)
)
{
GetPreferredStretchSize
(
aDrawTarget
0
mEmbellishData
.
direction
containerSize
)
;
aStretchDirection
=
mEmbellishData
.
direction
;
}
else
{
containerSize
=
childSize
.
mBoundingMetrics
;
}
}
mathMLFrame
-
>
Stretch
(
aDrawTarget
aStretchDirection
containerSize
childSize
)
;
SaveReflowAndBoundingMetricsFor
(
baseFrame
childSize
childSize
.
mBoundingMetrics
)
;
if
(
NS_MATHML_WILL_STRETCH_ALL_CHILDREN_VERTICALLY
(
mPresentationData
.
flags
)
|
|
NS_MATHML_WILL_STRETCH_ALL_CHILDREN_HORIZONTALLY
(
mPresentationData
.
flags
)
)
{
nsStretchDirection
stretchDir
=
NS_MATHML_WILL_STRETCH_ALL_CHILDREN_VERTICALLY
(
mPresentationData
.
flags
)
?
NS_STRETCH_DIRECTION_VERTICAL
:
NS_STRETCH_DIRECTION_HORIZONTAL
;
GetPreferredStretchSize
(
aDrawTarget
STRETCH_CONSIDER_EMBELLISHMENTS
stretchDir
containerSize
)
;
nsIFrame
*
childFrame
=
mFrames
.
FirstChild
(
)
;
while
(
childFrame
)
{
if
(
childFrame
!
=
mPresentationData
.
baseFrame
)
{
mathMLFrame
=
do_QueryFrame
(
childFrame
)
;
if
(
mathMLFrame
)
{
GetReflowAndBoundingMetricsFor
(
childFrame
childSize
childSize
.
mBoundingMetrics
)
;
mathMLFrame
-
>
Stretch
(
aDrawTarget
stretchDir
containerSize
childSize
)
;
SaveReflowAndBoundingMetricsFor
(
childFrame
childSize
childSize
.
mBoundingMetrics
)
;
}
}
childFrame
=
childFrame
-
>
GetNextSibling
(
)
;
}
}
PlaceFlags
flags
;
nsresult
rv
=
Place
(
aDrawTarget
flags
aDesiredStretchSize
)
;
if
(
NS_FAILED
(
rv
)
)
{
DidReflowChildren
(
mFrames
.
FirstChild
(
)
)
;
}
nsEmbellishData
parentData
;
GetEmbellishDataFrom
(
GetParent
(
)
parentData
)
;
if
(
parentData
.
coreFrame
!
=
mEmbellishData
.
coreFrame
)
{
nsEmbellishData
coreData
;
GetEmbellishDataFrom
(
mEmbellishData
.
coreFrame
coreData
)
;
mBoundingMetrics
.
width
+
=
coreData
.
leadingSpace
+
coreData
.
trailingSpace
;
aDesiredStretchSize
.
Width
(
)
=
mBoundingMetrics
.
width
;
aDesiredStretchSize
.
mBoundingMetrics
.
width
=
mBoundingMetrics
.
width
;
nscoord
dx
=
StyleVisibility
(
)
-
>
mDirection
=
=
StyleDirection
:
:
Rtl
?
coreData
.
trailingSpace
:
coreData
.
leadingSpace
;
if
(
dx
!
=
0
)
{
mBoundingMetrics
.
leftBearing
+
=
dx
;
mBoundingMetrics
.
rightBearing
+
=
dx
;
aDesiredStretchSize
.
mBoundingMetrics
.
leftBearing
+
=
dx
;
aDesiredStretchSize
.
mBoundingMetrics
.
rightBearing
+
=
dx
;
nsIFrame
*
childFrame
=
mFrames
.
FirstChild
(
)
;
while
(
childFrame
)
{
childFrame
-
>
SetPosition
(
childFrame
-
>
GetPosition
(
)
+
nsPoint
(
dx
0
)
)
;
childFrame
=
childFrame
-
>
GetNextSibling
(
)
;
}
}
}
ClearSavedChildMetrics
(
)
;
GatherAndStoreOverflow
(
&
aDesiredStretchSize
)
;
}
}
}
return
NS_OK
;
}
nsresult
nsMathMLContainerFrame
:
:
FinalizeReflow
(
DrawTarget
*
aDrawTarget
ReflowOutput
&
aDesiredSize
)
{
bool
placeOrigin
=
!
NS_MATHML_IS_EMBELLISH_OPERATOR
(
mEmbellishData
.
flags
)
|
|
(
mEmbellishData
.
coreFrame
!
=
this
&
&
!
mPresentationData
.
baseFrame
&
&
mEmbellishData
.
direction
=
=
NS_STRETCH_DIRECTION_UNSUPPORTED
)
;
PlaceFlags
flags
;
if
(
!
placeOrigin
)
{
flags
+
=
PlaceFlag
:
:
MeasureOnly
;
}
nsresult
rv
=
Place
(
aDrawTarget
flags
aDesiredSize
)
;
if
(
NS_FAILED
(
rv
)
)
{
GatherAndStoreOverflow
(
&
aDesiredSize
)
;
DidReflowChildren
(
PrincipalChildList
(
)
.
FirstChild
(
)
)
;
return
rv
;
}
bool
parentWillFireStretch
=
false
;
if
(
!
placeOrigin
)
{
nsIMathMLFrame
*
mathMLFrame
=
do_QueryFrame
(
GetParent
(
)
)
;
if
(
mathMLFrame
)
{
nsEmbellishData
embellishData
;
nsPresentationData
presentationData
;
mathMLFrame
-
>
GetEmbellishData
(
embellishData
)
;
mathMLFrame
-
>
GetPresentationData
(
presentationData
)
;
if
(
NS_MATHML_WILL_STRETCH_ALL_CHILDREN_VERTICALLY
(
presentationData
.
flags
)
|
|
NS_MATHML_WILL_STRETCH_ALL_CHILDREN_HORIZONTALLY
(
presentationData
.
flags
)
|
|
(
NS_MATHML_IS_EMBELLISH_OPERATOR
(
embellishData
.
flags
)
&
&
presentationData
.
baseFrame
=
=
this
)
)
{
parentWillFireStretch
=
true
;
}
}
if
(
!
parentWillFireStretch
)
{
bool
stretchAll
=
NS_MATHML_WILL_STRETCH_ALL_CHILDREN_HORIZONTALLY
(
mPresentationData
.
flags
)
;
nsStretchDirection
stretchDir
;
if
(
mEmbellishData
.
coreFrame
=
=
this
|
|
(
mEmbellishData
.
direction
=
=
NS_STRETCH_DIRECTION_HORIZONTAL
&
&
stretchAll
)
|
|
mEmbellishData
.
direction
=
=
NS_STRETCH_DIRECTION_UNSUPPORTED
)
{
stretchDir
=
mEmbellishData
.
direction
;
}
else
{
stretchDir
=
NS_STRETCH_DIRECTION_DEFAULT
;
}
nsBoundingMetrics
defaultSize
=
aDesiredSize
.
mBoundingMetrics
;
Stretch
(
aDrawTarget
stretchDir
defaultSize
aDesiredSize
)
;
#
ifdef
DEBUG
{
for
(
nsIFrame
*
childFrame
:
PrincipalChildList
(
)
)
{
NS_ASSERTION
(
!
childFrame
-
>
HasAnyStateBits
(
NS_FRAME_IN_REFLOW
)
"
DidReflow
(
)
was
never
called
"
)
;
}
}
#
endif
}
}
aDesiredSize
.
mBoundingMetrics
=
mBoundingMetrics
;
FixInterFrameSpacing
(
aDesiredSize
)
;
if
(
!
parentWillFireStretch
)
{
ClearSavedChildMetrics
(
)
;
GatherAndStoreOverflow
(
&
aDesiredSize
)
;
}
return
NS_OK
;
}
void
nsMathMLContainerFrame
:
:
PropagatePresentationDataFor
(
nsIFrame
*
aFrame
uint32_t
aFlagsValues
uint32_t
aFlagsToUpdate
)
{
if
(
!
aFrame
|
|
!
aFlagsToUpdate
)
return
;
nsIMathMLFrame
*
mathMLFrame
=
do_QueryFrame
(
aFrame
)
;
if
(
mathMLFrame
)
{
mathMLFrame
-
>
UpdatePresentationData
(
aFlagsValues
aFlagsToUpdate
)
;
mathMLFrame
-
>
UpdatePresentationDataFromChildAt
(
0
-
1
aFlagsValues
aFlagsToUpdate
)
;
}
else
{
for
(
nsIFrame
*
childFrame
:
aFrame
-
>
PrincipalChildList
(
)
)
{
PropagatePresentationDataFor
(
childFrame
aFlagsValues
aFlagsToUpdate
)
;
}
}
}
void
nsMathMLContainerFrame
:
:
PropagatePresentationDataFromChildAt
(
nsIFrame
*
aParentFrame
int32_t
aFirstChildIndex
int32_t
aLastChildIndex
uint32_t
aFlagsValues
uint32_t
aFlagsToUpdate
)
{
if
(
!
aParentFrame
|
|
!
aFlagsToUpdate
)
return
;
int32_t
index
=
0
;
for
(
nsIFrame
*
childFrame
:
aParentFrame
-
>
PrincipalChildList
(
)
)
{
if
(
(
index
>
=
aFirstChildIndex
)
&
&
(
(
aLastChildIndex
<
=
0
)
|
|
(
(
aLastChildIndex
>
0
)
&
&
(
index
<
=
aLastChildIndex
)
)
)
)
{
PropagatePresentationDataFor
(
childFrame
aFlagsValues
aFlagsToUpdate
)
;
}
index
+
+
;
}
}
void
nsMathMLContainerFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
BuildDisplayListForInline
(
aBuilder
aLists
)
;
}
void
nsMathMLContainerFrame
:
:
RebuildAutomaticDataForChildren
(
nsIFrame
*
aParentFrame
)
{
for
(
nsIFrame
*
childFrame
:
aParentFrame
-
>
PrincipalChildList
(
)
)
{
nsIMathMLFrame
*
childMathMLFrame
=
do_QueryFrame
(
childFrame
)
;
if
(
childMathMLFrame
)
{
childMathMLFrame
-
>
InheritAutomaticData
(
aParentFrame
)
;
}
RebuildAutomaticDataForChildren
(
childFrame
)
;
}
nsIMathMLFrame
*
mathMLFrame
=
do_QueryFrame
(
aParentFrame
)
;
if
(
mathMLFrame
)
{
mathMLFrame
-
>
TransmitAutomaticData
(
)
;
}
}
nsresult
nsMathMLContainerFrame
:
:
ReLayoutChildren
(
nsIFrame
*
aParentFrame
)
{
if
(
!
aParentFrame
)
return
NS_OK
;
nsIFrame
*
frame
=
aParentFrame
;
while
(
1
)
{
nsIFrame
*
parent
=
frame
-
>
GetParent
(
)
;
if
(
!
parent
|
|
!
parent
-
>
GetContent
(
)
)
break
;
nsIMathMLFrame
*
mathMLFrame
=
do_QueryFrame
(
frame
)
;
if
(
mathMLFrame
)
break
;
nsIContent
*
content
=
frame
-
>
GetContent
(
)
;
NS_ASSERTION
(
content
"
dangling
frame
without
a
content
node
"
)
;
if
(
!
content
)
break
;
if
(
content
-
>
IsMathMLElement
(
nsGkAtoms
:
:
math
)
)
break
;
frame
=
parent
;
}
RebuildAutomaticDataForChildren
(
frame
)
;
nsIFrame
*
parent
=
frame
-
>
GetParent
(
)
;
NS_ASSERTION
(
parent
"
No
parent
to
pass
the
reflow
request
up
to
"
)
;
if
(
!
parent
)
return
NS_OK
;
frame
-
>
PresShell
(
)
-
>
FrameNeedsReflow
(
frame
IntrinsicDirty
:
:
FrameAncestorsAndDescendants
NS_FRAME_IS_DIRTY
)
;
return
NS_OK
;
}
nsresult
nsMathMLContainerFrame
:
:
ChildListChanged
(
int32_t
aModType
)
{
nsIFrame
*
frame
=
this
;
if
(
mEmbellishData
.
coreFrame
)
{
nsIFrame
*
parent
=
GetParent
(
)
;
nsEmbellishData
embellishData
;
for
(
;
parent
;
frame
=
parent
parent
=
parent
-
>
GetParent
(
)
)
{
GetEmbellishDataFrom
(
parent
embellishData
)
;
if
(
embellishData
.
coreFrame
!
=
mEmbellishData
.
coreFrame
)
break
;
}
}
return
ReLayoutChildren
(
frame
)
;
}
void
nsMathMLContainerFrame
:
:
AppendFrames
(
ChildListID
aListID
nsFrameList
&
&
aFrameList
)
{
MOZ_ASSERT
(
aListID
=
=
FrameChildListID
:
:
Principal
)
;
mFrames
.
AppendFrames
(
this
std
:
:
move
(
aFrameList
)
)
;
ChildListChanged
(
dom
:
:
MutationEvent_Binding
:
:
ADDITION
)
;
}
void
nsMathMLContainerFrame
:
:
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
const
nsLineList
:
:
iterator
*
aPrevFrameLine
nsFrameList
&
&
aFrameList
)
{
MOZ_ASSERT
(
aListID
=
=
FrameChildListID
:
:
Principal
)
;
mFrames
.
InsertFrames
(
this
aPrevFrame
std
:
:
move
(
aFrameList
)
)
;
ChildListChanged
(
dom
:
:
MutationEvent_Binding
:
:
ADDITION
)
;
}
void
nsMathMLContainerFrame
:
:
RemoveFrame
(
DestroyContext
&
aContext
ChildListID
aListID
nsIFrame
*
aOldFrame
)
{
MOZ_ASSERT
(
aListID
=
=
FrameChildListID
:
:
Principal
)
;
mFrames
.
DestroyFrame
(
aContext
aOldFrame
)
;
ChildListChanged
(
dom
:
:
MutationEvent_Binding
:
:
REMOVAL
)
;
}
void
nsMathMLContainerFrame
:
:
GatherAndStoreOverflow
(
ReflowOutput
*
aMetrics
)
{
mBlockStartAscent
=
aMetrics
-
>
BlockStartAscent
(
)
;
aMetrics
-
>
SetOverflowAreasToDesiredBounds
(
)
;
ComputeCustomOverflow
(
aMetrics
-
>
mOverflowAreas
)
;
UnionChildOverflow
(
aMetrics
-
>
mOverflowAreas
)
;
FinishAndStoreOverflow
(
aMetrics
)
;
}
bool
nsMathMLContainerFrame
:
:
ComputeCustomOverflow
(
OverflowAreas
&
aOverflowAreas
)
{
nsRect
boundingBox
(
mBoundingMetrics
.
leftBearing
mBlockStartAscent
-
mBoundingMetrics
.
ascent
mBoundingMetrics
.
rightBearing
-
mBoundingMetrics
.
leftBearing
mBoundingMetrics
.
ascent
+
mBoundingMetrics
.
descent
)
;
aOverflowAreas
.
UnionAllWith
(
boundingBox
)
;
return
nsContainerFrame
:
:
ComputeCustomOverflow
(
aOverflowAreas
)
;
}
void
nsMathMLContainerFrame
:
:
ReflowChild
(
nsIFrame
*
aChildFrame
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
#
ifdef
DEBUG
nsInlineFrame
*
inlineFrame
=
do_QueryFrame
(
aChildFrame
)
;
NS_ASSERTION
(
!
inlineFrame
"
Inline
frames
should
be
wrapped
in
blocks
"
)
;
#
endif
nsContainerFrame
:
:
ReflowChild
(
aChildFrame
aPresContext
aDesiredSize
aReflowInput
0
0
ReflowChildFlags
:
:
NoMoveFrame
aStatus
)
;
if
(
aDesiredSize
.
BlockStartAscent
(
)
=
=
ReflowOutput
:
:
ASK_FOR_BASELINE
)
{
nscoord
ascent
;
WritingMode
wm
=
aDesiredSize
.
GetWritingMode
(
)
;
if
(
!
nsLayoutUtils
:
:
GetLastLineBaseline
(
wm
aChildFrame
&
ascent
)
)
{
aDesiredSize
.
SetBlockStartAscent
(
aDesiredSize
.
BSize
(
wm
)
)
;
}
else
{
aDesiredSize
.
SetBlockStartAscent
(
ascent
)
;
}
}
if
(
IsForeignChild
(
aChildFrame
)
)
{
nsRect
r
=
aChildFrame
-
>
ComputeTightBounds
(
aReflowInput
.
mRenderingContext
-
>
GetDrawTarget
(
)
)
;
aDesiredSize
.
mBoundingMetrics
.
leftBearing
=
r
.
x
;
aDesiredSize
.
mBoundingMetrics
.
rightBearing
=
r
.
XMost
(
)
;
aDesiredSize
.
mBoundingMetrics
.
ascent
=
aDesiredSize
.
BlockStartAscent
(
)
-
r
.
y
;
aDesiredSize
.
mBoundingMetrics
.
descent
=
r
.
YMost
(
)
-
aDesiredSize
.
BlockStartAscent
(
)
;
aDesiredSize
.
mBoundingMetrics
.
width
=
aDesiredSize
.
Width
(
)
;
}
}
void
nsMathMLContainerFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
if
(
IsHiddenByContentVisibilityOfInFlowParentForLayout
(
)
)
{
return
;
}
MarkInReflow
(
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
aDesiredSize
.
Width
(
)
=
aDesiredSize
.
Height
(
)
=
0
;
aDesiredSize
.
SetBlockStartAscent
(
0
)
;
aDesiredSize
.
mBoundingMetrics
=
nsBoundingMetrics
(
)
;
nsReflowStatus
childStatus
;
nsIFrame
*
childFrame
=
mFrames
.
FirstChild
(
)
;
while
(
childFrame
)
{
ReflowOutput
childDesiredSize
(
aReflowInput
)
;
WritingMode
wm
=
childFrame
-
>
GetWritingMode
(
)
;
LogicalSize
availSize
=
aReflowInput
.
ComputedSize
(
wm
)
;
availSize
.
BSize
(
wm
)
=
NS_UNCONSTRAINEDSIZE
;
ReflowInput
childReflowInput
(
aPresContext
aReflowInput
childFrame
availSize
)
;
ReflowChild
(
childFrame
aPresContext
childDesiredSize
childReflowInput
childStatus
)
;
SaveReflowAndBoundingMetricsFor
(
childFrame
childDesiredSize
childDesiredSize
.
mBoundingMetrics
)
;
childFrame
=
childFrame
-
>
GetNextSibling
(
)
;
}
DrawTarget
*
drawTarget
=
aReflowInput
.
mRenderingContext
-
>
GetDrawTarget
(
)
;
if
(
!
NS_MATHML_IS_EMBELLISH_OPERATOR
(
mEmbellishData
.
flags
)
&
&
(
NS_MATHML_WILL_STRETCH_ALL_CHILDREN_VERTICALLY
(
mPresentationData
.
flags
)
|
|
NS_MATHML_WILL_STRETCH_ALL_CHILDREN_HORIZONTALLY
(
mPresentationData
.
flags
)
)
)
{
nsStretchDirection
stretchDir
=
NS_MATHML_WILL_STRETCH_ALL_CHILDREN_VERTICALLY
(
mPresentationData
.
flags
)
?
NS_STRETCH_DIRECTION_VERTICAL
:
NS_STRETCH_DIRECTION_HORIZONTAL
;
nsBoundingMetrics
containerSize
;
GetPreferredStretchSize
(
drawTarget
0
stretchDir
containerSize
)
;
childFrame
=
mFrames
.
FirstChild
(
)
;
while
(
childFrame
)
{
nsIMathMLFrame
*
mathMLFrame
=
do_QueryFrame
(
childFrame
)
;
if
(
mathMLFrame
)
{
ReflowOutput
childDesiredSize
(
aReflowInput
)
;
GetReflowAndBoundingMetricsFor
(
childFrame
childDesiredSize
childDesiredSize
.
mBoundingMetrics
)
;
mathMLFrame
-
>
Stretch
(
drawTarget
stretchDir
containerSize
childDesiredSize
)
;
SaveReflowAndBoundingMetricsFor
(
childFrame
childDesiredSize
childDesiredSize
.
mBoundingMetrics
)
;
}
childFrame
=
childFrame
-
>
GetNextSibling
(
)
;
}
}
FinalizeReflow
(
drawTarget
aDesiredSize
)
;
}
static
nscoord
AddInterFrameSpacingToSize
(
ReflowOutput
&
aDesiredSize
nsMathMLContainerFrame
*
aFrame
)
;
void
nsMathMLContainerFrame
:
:
MarkIntrinsicISizesDirty
(
)
{
mIntrinsicISize
=
NS_INTRINSIC_ISIZE_UNKNOWN
;
nsContainerFrame
:
:
MarkIntrinsicISizesDirty
(
)
;
}
void
nsMathMLContainerFrame
:
:
UpdateIntrinsicISize
(
gfxContext
*
aRenderingContext
)
{
if
(
mIntrinsicISize
=
=
NS_INTRINSIC_ISIZE_UNKNOWN
)
{
ReflowOutput
desiredSize
(
GetWritingMode
(
)
)
;
GetIntrinsicISizeMetrics
(
aRenderingContext
desiredSize
)
;
AddInterFrameSpacingToSize
(
desiredSize
this
)
;
mIntrinsicISize
=
desiredSize
.
ISize
(
GetWritingMode
(
)
)
-
IntrinsicISizeOffsets
(
)
.
BorderPadding
(
)
;
}
}
nscoord
nsMathMLContainerFrame
:
:
IntrinsicISize
(
const
IntrinsicSizeInput
&
aInput
IntrinsicISizeType
aType
)
{
UpdateIntrinsicISize
(
aInput
.
mContext
)
;
return
mIntrinsicISize
;
}
void
nsMathMLContainerFrame
:
:
GetIntrinsicISizeMetrics
(
gfxContext
*
aRenderingContext
ReflowOutput
&
aDesiredSize
)
{
nsIFrame
*
childFrame
=
mFrames
.
FirstChild
(
)
;
while
(
childFrame
)
{
ReflowOutput
childDesiredSize
(
GetWritingMode
(
)
)
;
nsMathMLContainerFrame
*
containerFrame
=
do_QueryFrame
(
childFrame
)
;
if
(
containerFrame
)
{
containerFrame
-
>
GetIntrinsicISizeMetrics
(
aRenderingContext
childDesiredSize
)
;
}
else
{
nscoord
width
=
nsLayoutUtils
:
:
IntrinsicForContainer
(
aRenderingContext
childFrame
IntrinsicISizeType
:
:
PrefISize
)
;
childDesiredSize
.
Width
(
)
=
width
;
childDesiredSize
.
mBoundingMetrics
.
width
=
width
;
childDesiredSize
.
mBoundingMetrics
.
leftBearing
=
0
;
childDesiredSize
.
mBoundingMetrics
.
rightBearing
=
width
;
nscoord
x
xMost
;
if
(
NS_SUCCEEDED
(
childFrame
-
>
GetPrefWidthTightBounds
(
aRenderingContext
&
x
&
xMost
)
)
)
{
childDesiredSize
.
mBoundingMetrics
.
leftBearing
=
x
;
childDesiredSize
.
mBoundingMetrics
.
rightBearing
=
xMost
;
}
}
SaveReflowAndBoundingMetricsFor
(
childFrame
childDesiredSize
childDesiredSize
.
mBoundingMetrics
)
;
childFrame
=
childFrame
-
>
GetNextSibling
(
)
;
}
PlaceFlags
flags
(
PlaceFlag
:
:
IntrinsicSize
PlaceFlag
:
:
MeasureOnly
)
;
nsresult
rv
=
Place
(
aRenderingContext
-
>
GetDrawTarget
(
)
flags
aDesiredSize
)
;
if
(
NS_FAILED
(
rv
)
)
{
PlaceAsMrow
(
aRenderingContext
-
>
GetDrawTarget
(
)
flags
aDesiredSize
)
;
}
ClearSavedChildMetrics
(
)
;
}
static
int32_t
kInterFrameSpacingTable
[
eMathMLFrameType_COUNT
]
[
eMathMLFrameType_COUNT
]
=
{
{
0x00
0x00
0x00
0x01
0x01
0x00
0x00
}
{
0x00
0x00
0x00
0x00
0x00
0x00
0x00
}
{
0x00
0x00
0x00
0x00
0x00
0x00
0x00
}
{
0x01
0x00
0x00
0x01
0x01
0x01
0x01
}
{
0x01
0x00
0x00
0x01
0x01
0x01
0x01
}
{
0x00
0x00
0x00
0x01
0x01
0x00
0x01
}
{
0x00
0x00
0x00
0x01
0x01
0x01
0x00
}
}
;
#
define
GET_INTERSPACE
(
scriptlevel_
frametype1_
frametype2_
space_
)
\
if
(
frametype1_
=
=
eMathMLFrameType_UNKNOWN
|
|
\
frametype2_
=
=
eMathMLFrameType_UNKNOWN
)
\
space_
=
0
;
\
else
{
\
space_
=
kInterFrameSpacingTable
[
frametype1_
]
[
frametype2_
]
;
\
space_
=
(
scriptlevel_
>
0
&
&
(
space_
&
0xF0
)
)
\
?
0
/
*
spacing
is
disabled
*
/
\
:
space_
&
0x0F
;
\
}
static
nscoord
GetInterFrameSpacing
(
int32_t
aScriptLevel
eMathMLFrameType
aFirstFrameType
eMathMLFrameType
aSecondFrameType
eMathMLFrameType
*
aFromFrameType
int32_t
*
aCarrySpace
)
{
eMathMLFrameType
firstType
=
aFirstFrameType
;
eMathMLFrameType
secondType
=
aSecondFrameType
;
int32_t
space
;
GET_INTERSPACE
(
aScriptLevel
firstType
secondType
space
)
;
if
(
secondType
=
=
eMathMLFrameType_OperatorInvisible
)
{
if
(
*
aFromFrameType
=
=
eMathMLFrameType_UNKNOWN
)
{
*
aFromFrameType
=
firstType
;
*
aCarrySpace
=
space
;
}
space
=
0
;
}
else
if
(
*
aFromFrameType
!
=
eMathMLFrameType_UNKNOWN
)
{
firstType
=
*
aFromFrameType
;
if
(
firstType
=
=
eMathMLFrameType_UprightIdentifier
)
{
firstType
=
eMathMLFrameType_OperatorUserDefined
;
}
else
if
(
secondType
=
=
eMathMLFrameType_UprightIdentifier
)
{
secondType
=
eMathMLFrameType_OperatorUserDefined
;
}
GET_INTERSPACE
(
aScriptLevel
firstType
secondType
space
)
;
if
(
secondType
!
=
eMathMLFrameType_OperatorOrdinary
&
&
space
<
*
aCarrySpace
)
space
=
*
aCarrySpace
;
*
aFromFrameType
=
eMathMLFrameType_UNKNOWN
;
*
aCarrySpace
=
0
;
}
return
space
;
}
static
nscoord
GetThinSpace
(
const
nsStyleFont
*
aStyleFont
)
{
return
aStyleFont
-
>
mFont
.
size
.
ScaledBy
(
3
.
0f
/
18
.
0f
)
.
ToAppUnits
(
)
;
}
class
nsMathMLContainerFrame
:
:
RowChildFrameIterator
{
public
:
explicit
RowChildFrameIterator
(
nsMathMLContainerFrame
*
aParentFrame
const
PlaceFlags
&
aFlags
)
:
mParentFrame
(
aParentFrame
)
mReflowOutput
(
aParentFrame
-
>
GetWritingMode
(
)
)
mX
(
0
)
mFlags
(
aFlags
)
mChildFrameType
(
eMathMLFrameType_UNKNOWN
)
mCarrySpace
(
0
)
mFromFrameType
(
eMathMLFrameType_UNKNOWN
)
mRTL
(
aParentFrame
-
>
StyleVisibility
(
)
-
>
mDirection
=
=
StyleDirection
:
:
Rtl
)
{
if
(
!
mRTL
)
{
mChildFrame
=
aParentFrame
-
>
mFrames
.
FirstChild
(
)
;
}
else
{
mChildFrame
=
aParentFrame
-
>
mFrames
.
LastChild
(
)
;
}
if
(
!
mChildFrame
)
return
;
InitMetricsForChild
(
)
;
}
RowChildFrameIterator
&
operator
+
+
(
)
{
mX
+
=
mReflowOutput
.
mBoundingMetrics
.
width
+
mItalicCorrection
;
mX
+
=
mMargin
.
LeftRight
(
)
;
if
(
!
mRTL
)
{
mChildFrame
=
mChildFrame
-
>
GetNextSibling
(
)
;
}
else
{
mChildFrame
=
mChildFrame
-
>
GetPrevSibling
(
)
;
}
if
(
!
mChildFrame
)
return
*
this
;
eMathMLFrameType
prevFrameType
=
mChildFrameType
;
InitMetricsForChild
(
)
;
const
nsStyleFont
*
font
=
mParentFrame
-
>
StyleFont
(
)
;
nscoord
space
=
GetInterFrameSpacing
(
font
-
>
mMathDepth
prevFrameType
mChildFrameType
&
mFromFrameType
&
mCarrySpace
)
;
mX
+
=
space
*
GetThinSpace
(
font
)
;
return
*
this
;
}
nsIFrame
*
Frame
(
)
const
{
return
mChildFrame
;
}
nscoord
X
(
)
const
{
return
mX
;
}
const
ReflowOutput
&
GetReflowOutput
(
)
const
{
return
mReflowOutput
;
}
nscoord
Ascent
(
)
const
{
return
mReflowOutput
.
BlockStartAscent
(
)
;
}
nscoord
Descent
(
)
const
{
return
mReflowOutput
.
Height
(
)
-
mReflowOutput
.
BlockStartAscent
(
)
;
}
const
nsMargin
&
Margin
(
)
const
{
return
mMargin
;
}
const
nsBoundingMetrics
&
BoundingMetrics
(
)
const
{
return
mReflowOutput
.
mBoundingMetrics
;
}
private
:
const
nsMathMLContainerFrame
*
mParentFrame
;
nsIFrame
*
mChildFrame
;
ReflowOutput
mReflowOutput
;
nscoord
mX
;
const
PlaceFlags
mFlags
;
nsMargin
mMargin
;
nscoord
mItalicCorrection
;
eMathMLFrameType
mChildFrameType
;
int32_t
mCarrySpace
;
eMathMLFrameType
mFromFrameType
;
bool
mRTL
;
void
InitMetricsForChild
(
)
{
GetReflowAndBoundingMetricsFor
(
mChildFrame
mReflowOutput
mReflowOutput
.
mBoundingMetrics
&
mChildFrameType
)
;
mMargin
=
GetMarginForPlace
(
mFlags
mChildFrame
)
;
nscoord
leftCorrection
rightCorrection
;
GetItalicCorrection
(
mReflowOutput
.
mBoundingMetrics
leftCorrection
rightCorrection
)
;
if
(
!
mChildFrame
-
>
GetPrevSibling
(
)
&
&
mParentFrame
-
>
GetContent
(
)
-
>
IsMathMLElement
(
nsGkAtoms
:
:
msqrt_
)
)
{
if
(
!
mRTL
)
{
leftCorrection
=
0
;
}
else
{
rightCorrection
=
0
;
}
}
mX
+
=
leftCorrection
;
mItalicCorrection
=
rightCorrection
;
}
}
;
nsresult
nsMathMLContainerFrame
:
:
Place
(
DrawTarget
*
aDrawTarget
const
PlaceFlags
&
aFlags
ReflowOutput
&
aDesiredSize
)
{
mBoundingMetrics
=
nsBoundingMetrics
(
)
;
RowChildFrameIterator
child
(
this
aFlags
)
;
nscoord
ascent
=
0
descent
=
0
;
while
(
child
.
Frame
(
)
)
{
nscoord
topMargin
=
child
.
Margin
(
)
.
top
;
nscoord
bottomMargin
=
child
.
Margin
(
)
.
bottom
;
ascent
=
std
:
:
max
(
ascent
child
.
Ascent
(
)
+
topMargin
)
;
descent
=
std
:
:
max
(
descent
child
.
Descent
(
)
+
bottomMargin
)
;
mBoundingMetrics
.
width
=
child
.
X
(
)
;
nsBoundingMetrics
childBm
=
child
.
BoundingMetrics
(
)
;
childBm
.
ascent
+
=
topMargin
;
childBm
.
descent
+
=
bottomMargin
;
childBm
.
rightBearing
+
=
child
.
Margin
(
)
.
LeftRight
(
)
;
childBm
.
width
+
=
child
.
Margin
(
)
.
LeftRight
(
)
;
mBoundingMetrics
+
=
childBm
;
+
+
child
;
}
mBoundingMetrics
.
width
=
child
.
X
(
)
;
aDesiredSize
.
Width
(
)
=
std
:
:
max
(
0
mBoundingMetrics
.
width
)
;
aDesiredSize
.
Height
(
)
=
ascent
+
descent
;
aDesiredSize
.
SetBlockStartAscent
(
ascent
)
;
aDesiredSize
.
mBoundingMetrics
=
mBoundingMetrics
;
auto
sizes
=
GetWidthAndHeightForPlaceAdjustment
(
aFlags
)
;
nscoord
shiftX
=
ApplyAdjustmentForWidthAndHeight
(
aFlags
sizes
aDesiredSize
mBoundingMetrics
)
;
auto
borderPadding
=
GetBorderPaddingForPlace
(
aFlags
)
;
InflateReflowAndBoundingMetrics
(
borderPadding
aDesiredSize
mBoundingMetrics
)
;
shiftX
+
=
borderPadding
.
left
;
mReference
.
x
=
0
;
mReference
.
y
=
aDesiredSize
.
BlockStartAscent
(
)
;
if
(
!
aFlags
.
contains
(
PlaceFlag
:
:
MeasureOnly
)
)
{
PositionRowChildFrames
(
shiftX
aDesiredSize
.
BlockStartAscent
(
)
)
;
}
return
NS_OK
;
}
nsresult
nsMathMLContainerFrame
:
:
PlaceAsMrow
(
DrawTarget
*
aDrawTarget
const
PlaceFlags
&
aFlags
ReflowOutput
&
aDesiredSize
)
{
return
nsMathMLContainerFrame
:
:
Place
(
aDrawTarget
aFlags
aDesiredSize
)
;
}
void
nsMathMLContainerFrame
:
:
PositionRowChildFrames
(
nscoord
aOffsetX
nscoord
aBaseline
)
{
PlaceFlags
flags
;
RowChildFrameIterator
child
(
this
flags
)
;
while
(
child
.
Frame
(
)
)
{
nscoord
dx
=
aOffsetX
+
child
.
X
(
)
+
child
.
Margin
(
)
.
left
;
nscoord
dy
=
aBaseline
-
child
.
Ascent
(
)
;
FinishReflowChild
(
child
.
Frame
(
)
PresContext
(
)
child
.
GetReflowOutput
(
)
nullptr
dx
dy
ReflowChildFlags
:
:
Default
)
;
+
+
child
;
}
}
static
nscoord
GetInterFrameSpacingFor
(
int32_t
aScriptLevel
nsIFrame
*
aParentFrame
nsIFrame
*
aChildFrame
)
{
nsIFrame
*
childFrame
=
aParentFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
!
childFrame
|
|
aChildFrame
=
=
childFrame
)
return
0
;
int32_t
carrySpace
=
0
;
eMathMLFrameType
fromFrameType
=
eMathMLFrameType_UNKNOWN
;
eMathMLFrameType
prevFrameType
=
eMathMLFrameType_UNKNOWN
;
eMathMLFrameType
childFrameType
=
nsMathMLFrame
:
:
GetMathMLFrameTypeFor
(
childFrame
)
;
childFrame
=
childFrame
-
>
GetNextSibling
(
)
;
while
(
childFrame
)
{
prevFrameType
=
childFrameType
;
childFrameType
=
nsMathMLFrame
:
:
GetMathMLFrameTypeFor
(
childFrame
)
;
nscoord
space
=
GetInterFrameSpacing
(
aScriptLevel
prevFrameType
childFrameType
&
fromFrameType
&
carrySpace
)
;
if
(
aChildFrame
=
=
childFrame
)
{
ComputedStyle
*
parentContext
=
aParentFrame
-
>
Style
(
)
;
nscoord
thinSpace
=
GetThinSpace
(
parentContext
-
>
StyleFont
(
)
)
;
return
space
*
thinSpace
;
}
childFrame
=
childFrame
-
>
GetNextSibling
(
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
child
not
in
the
childlist
of
its
parent
"
)
;
return
0
;
}
static
nscoord
AddInterFrameSpacingToSize
(
ReflowOutput
&
aDesiredSize
nsMathMLContainerFrame
*
aFrame
)
{
nscoord
gap
=
0
;
nsIFrame
*
parent
=
aFrame
-
>
GetParent
(
)
;
nsIContent
*
parentContent
=
parent
-
>
GetContent
(
)
;
if
(
MOZ_UNLIKELY
(
!
parentContent
)
)
{
return
0
;
}
if
(
parentContent
-
>
IsAnyOfMathMLElements
(
nsGkAtoms
:
:
math
nsGkAtoms
:
:
mtd_
)
)
{
gap
=
GetInterFrameSpacingFor
(
aFrame
-
>
StyleFont
(
)
-
>
mMathDepth
parent
aFrame
)
;
nscoord
leftCorrection
=
0
italicCorrection
=
0
;
nsMathMLContainerFrame
:
:
GetItalicCorrection
(
aDesiredSize
.
mBoundingMetrics
leftCorrection
italicCorrection
)
;
gap
+
=
leftCorrection
;
if
(
gap
)
{
aDesiredSize
.
mBoundingMetrics
.
leftBearing
+
=
gap
;
aDesiredSize
.
mBoundingMetrics
.
rightBearing
+
=
gap
;
aDesiredSize
.
mBoundingMetrics
.
width
+
=
gap
;
aDesiredSize
.
Width
(
)
+
=
gap
;
}
aDesiredSize
.
mBoundingMetrics
.
width
+
=
italicCorrection
;
aDesiredSize
.
Width
(
)
+
=
italicCorrection
;
}
return
gap
;
}
nscoord
nsMathMLContainerFrame
:
:
FixInterFrameSpacing
(
ReflowOutput
&
aDesiredSize
)
{
nscoord
gap
=
0
;
gap
=
AddInterFrameSpacingToSize
(
aDesiredSize
this
)
;
if
(
gap
)
{
nsIFrame
*
childFrame
=
mFrames
.
FirstChild
(
)
;
while
(
childFrame
)
{
childFrame
-
>
SetPosition
(
childFrame
-
>
GetPosition
(
)
+
nsPoint
(
gap
0
)
)
;
childFrame
=
childFrame
-
>
GetNextSibling
(
)
;
}
}
return
gap
;
}
void
nsMathMLContainerFrame
:
:
DidReflowChildren
(
nsIFrame
*
aFirst
nsIFrame
*
aStop
)
{
if
(
MOZ_UNLIKELY
(
!
aFirst
)
)
return
;
for
(
nsIFrame
*
frame
=
aFirst
;
frame
!
=
aStop
;
frame
=
frame
-
>
GetNextSibling
(
)
)
{
NS_ASSERTION
(
frame
"
aStop
isn
'
t
a
sibling
"
)
;
if
(
frame
-
>
HasAnyStateBits
(
NS_FRAME_IN_REFLOW
)
)
{
nsIFrame
*
grandchild
=
frame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
grandchild
)
DidReflowChildren
(
grandchild
nullptr
)
;
frame
-
>
DidReflow
(
frame
-
>
PresContext
(
)
nullptr
)
;
}
}
}
nsresult
nsMathMLContainerFrame
:
:
TransmitAutomaticDataForMrowLikeElement
(
)
{
nsIFrame
*
childFrame
*
baseFrame
;
bool
embellishedOpFound
=
false
;
nsEmbellishData
embellishData
;
for
(
childFrame
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
childFrame
;
childFrame
=
childFrame
-
>
GetNextSibling
(
)
)
{
nsIMathMLFrame
*
mathMLFrame
=
do_QueryFrame
(
childFrame
)
;
if
(
!
mathMLFrame
)
break
;
if
(
!
mathMLFrame
-
>
IsSpaceLike
(
)
)
{
if
(
embellishedOpFound
)
break
;
baseFrame
=
childFrame
;
GetEmbellishDataFrom
(
baseFrame
embellishData
)
;
if
(
!
NS_MATHML_IS_EMBELLISH_OPERATOR
(
embellishData
.
flags
)
)
break
;
embellishedOpFound
=
true
;
}
}
if
(
!
childFrame
)
{
if
(
!
embellishedOpFound
)
{
mPresentationData
.
flags
|
=
NS_MATHML_SPACE_LIKE
;
}
else
{
mPresentationData
.
baseFrame
=
baseFrame
;
mEmbellishData
=
embellishData
;
}
}
if
(
childFrame
|
|
!
embellishedOpFound
)
{
mPresentationData
.
baseFrame
=
nullptr
;
mEmbellishData
.
flags
=
0
;
mEmbellishData
.
coreFrame
=
nullptr
;
mEmbellishData
.
direction
=
NS_STRETCH_DIRECTION_UNSUPPORTED
;
mEmbellishData
.
leadingSpace
=
0
;
mEmbellishData
.
trailingSpace
=
0
;
}
if
(
childFrame
|
|
embellishedOpFound
)
{
mPresentationData
.
flags
&
=
~
NS_MATHML_SPACE_LIKE
;
}
return
NS_OK
;
}
void
nsMathMLContainerFrame
:
:
PropagateFrameFlagFor
(
nsIFrame
*
aFrame
nsFrameState
aFlags
)
{
if
(
!
aFrame
|
|
!
aFlags
)
return
;
aFrame
-
>
AddStateBits
(
aFlags
)
;
for
(
nsIFrame
*
childFrame
:
aFrame
-
>
PrincipalChildList
(
)
)
{
PropagateFrameFlagFor
(
childFrame
aFlags
)
;
}
}
nsresult
nsMathMLContainerFrame
:
:
ReportErrorToConsole
(
const
char
*
errorMsgId
const
nsTArray
<
nsString
>
&
aParams
)
{
return
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
errorFlag
"
Layout
:
MathML
"
_ns
mContent
-
>
OwnerDoc
(
)
nsContentUtils
:
:
eMATHML_PROPERTIES
errorMsgId
aParams
)
;
}
nsresult
nsMathMLContainerFrame
:
:
ReportParseError
(
const
char16_t
*
aAttribute
const
char16_t
*
aValue
)
{
AutoTArray
<
nsString
3
>
argv
;
argv
.
AppendElement
(
aValue
)
;
argv
.
AppendElement
(
aAttribute
)
;
argv
.
AppendElement
(
nsDependentAtomString
(
mContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
)
;
return
ReportErrorToConsole
(
"
AttributeParsingError
"
argv
)
;
}
nsresult
nsMathMLContainerFrame
:
:
ReportChildCountError
(
)
{
AutoTArray
<
nsString
1
>
arg
=
{
nsDependentAtomString
(
mContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
}
;
return
ReportErrorToConsole
(
"
ChildCountIncorrect
"
arg
)
;
}
nsresult
nsMathMLContainerFrame
:
:
ReportInvalidChildError
(
nsAtom
*
aChildTag
)
{
AutoTArray
<
nsString
2
>
argv
=
{
nsDependentAtomString
(
aChildTag
)
nsDependentAtomString
(
mContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
}
;
return
ReportErrorToConsole
(
"
InvalidChild
"
argv
)
;
}
nsContainerFrame
*
NS_NewMathMLmathBlockFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
auto
newFrame
=
new
(
aPresShell
)
nsMathMLmathBlockFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
return
newFrame
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsMathMLmathBlockFrame
)
NS_QUERYFRAME_HEAD
(
nsMathMLmathBlockFrame
)
NS_QUERYFRAME_ENTRY
(
nsMathMLmathBlockFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsBlockFrame
)
nsContainerFrame
*
NS_NewMathMLmathInlineFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsMathMLmathInlineFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsMathMLmathInlineFrame
)
NS_QUERYFRAME_HEAD
(
nsMathMLmathInlineFrame
)
NS_QUERYFRAME_ENTRY
(
nsIMathMLFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsInlineFrame
)
