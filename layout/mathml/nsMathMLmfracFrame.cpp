#
include
"
nsMathMLmfracFrame
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
StaticPrefs_mathml
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
MathMLElement
.
h
"
#
include
<
algorithm
>
#
include
"
gfxMathTable
.
h
"
#
include
"
gfxTextRun
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
nsIFrame
*
NS_NewMathMLmfracFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsMathMLmfracFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsMathMLmfracFrame
)
nsMathMLmfracFrame
:
:
~
nsMathMLmfracFrame
(
)
=
default
;
eMathMLFrameType
nsMathMLmfracFrame
:
:
GetMathMLFrameType
(
)
{
return
eMathMLFrameType_Inner
;
}
uint8_t
nsMathMLmfracFrame
:
:
ScriptIncrement
(
nsIFrame
*
aFrame
)
{
if
(
StyleFont
(
)
-
>
mMathStyle
=
=
NS_STYLE_MATH_STYLE_COMPACT
&
&
aFrame
&
&
(
mFrames
.
FirstChild
(
)
=
=
aFrame
|
|
mFrames
.
LastChild
(
)
=
=
aFrame
)
)
{
return
1
;
}
return
0
;
}
NS_IMETHODIMP
nsMathMLmfracFrame
:
:
TransmitAutomaticData
(
)
{
UpdatePresentationDataFromChildAt
(
1
1
NS_MATHML_COMPRESSED
NS_MATHML_COMPRESSED
)
;
if
(
StyleFont
(
)
-
>
mMathStyle
=
=
NS_STYLE_MATH_STYLE_COMPACT
)
{
PropagateFrameFlagFor
(
mFrames
.
FirstChild
(
)
NS_FRAME_MATHML_SCRIPT_DESCENDANT
)
;
PropagateFrameFlagFor
(
mFrames
.
LastChild
(
)
NS_FRAME_MATHML_SCRIPT_DESCENDANT
)
;
}
GetEmbellishDataFrom
(
mFrames
.
FirstChild
(
)
mEmbellishData
)
;
if
(
NS_MATHML_IS_EMBELLISH_OPERATOR
(
mEmbellishData
.
flags
)
)
{
mEmbellishData
.
direction
=
NS_STRETCH_DIRECTION_UNSUPPORTED
;
}
return
NS_OK
;
}
nscoord
nsMathMLmfracFrame
:
:
CalcLineThickness
(
nsPresContext
*
aPresContext
ComputedStyle
*
aComputedStyle
nsString
&
aThicknessAttribute
nscoord
onePixel
nscoord
aDefaultRuleThickness
float
aFontSizeInflation
)
{
nscoord
defaultThickness
=
aDefaultRuleThickness
;
nscoord
lineThickness
=
aDefaultRuleThickness
;
nscoord
minimumThickness
=
onePixel
;
if
(
!
aThicknessAttribute
.
IsEmpty
(
)
)
{
lineThickness
=
defaultThickness
;
ParseNumericValue
(
aThicknessAttribute
&
lineThickness
dom
:
:
MathMLElement
:
:
PARSE_ALLOW_UNITLESS
aPresContext
aComputedStyle
aFontSizeInflation
)
;
}
if
(
lineThickness
&
&
lineThickness
<
minimumThickness
)
lineThickness
=
minimumThickness
;
return
lineThickness
;
}
void
nsMathMLmfracFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
nsMathMLContainerFrame
:
:
BuildDisplayList
(
aBuilder
aLists
)
;
DisplayBar
(
aBuilder
this
mLineRect
aLists
)
;
}
nsresult
nsMathMLmfracFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
if
(
nsGkAtoms
:
:
linethickness_
=
=
aAttribute
)
{
InvalidateFrame
(
)
;
}
return
nsMathMLContainerFrame
:
:
AttributeChanged
(
aNameSpaceID
aAttribute
aModType
)
;
}
nsresult
nsMathMLmfracFrame
:
:
MeasureForWidth
(
DrawTarget
*
aDrawTarget
ReflowOutput
&
aDesiredSize
)
{
return
PlaceInternal
(
aDrawTarget
false
aDesiredSize
true
)
;
}
nscoord
nsMathMLmfracFrame
:
:
FixInterFrameSpacing
(
ReflowOutput
&
aDesiredSize
)
{
nscoord
gap
=
nsMathMLContainerFrame
:
:
FixInterFrameSpacing
(
aDesiredSize
)
;
if
(
!
gap
)
return
0
;
mLineRect
.
MoveBy
(
gap
0
)
;
return
gap
;
}
nsresult
nsMathMLmfracFrame
:
:
Place
(
DrawTarget
*
aDrawTarget
bool
aPlaceOrigin
ReflowOutput
&
aDesiredSize
)
{
return
PlaceInternal
(
aDrawTarget
aPlaceOrigin
aDesiredSize
false
)
;
}
nsresult
nsMathMLmfracFrame
:
:
PlaceInternal
(
DrawTarget
*
aDrawTarget
bool
aPlaceOrigin
ReflowOutput
&
aDesiredSize
bool
aWidthOnly
)
{
nsBoundingMetrics
bmNum
bmDen
;
ReflowOutput
sizeNum
(
aDesiredSize
.
GetWritingMode
(
)
)
;
ReflowOutput
sizeDen
(
aDesiredSize
.
GetWritingMode
(
)
)
;
nsIFrame
*
frameDen
=
nullptr
;
nsIFrame
*
frameNum
=
mFrames
.
FirstChild
(
)
;
if
(
frameNum
)
frameDen
=
frameNum
-
>
GetNextSibling
(
)
;
if
(
!
frameNum
|
|
!
frameDen
|
|
frameDen
-
>
GetNextSibling
(
)
)
{
if
(
aPlaceOrigin
)
{
ReportChildCountError
(
)
;
}
return
ReflowError
(
aDrawTarget
aDesiredSize
)
;
}
GetReflowAndBoundingMetricsFor
(
frameNum
sizeNum
bmNum
)
;
GetReflowAndBoundingMetricsFor
(
frameDen
sizeDen
bmDen
)
;
nsPresContext
*
presContext
=
PresContext
(
)
;
nscoord
onePixel
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
1
)
;
float
fontSizeInflation
=
nsLayoutUtils
:
:
FontSizeInflationFor
(
this
)
;
RefPtr
<
nsFontMetrics
>
fm
=
nsLayoutUtils
:
:
GetFontMetricsForFrame
(
this
fontSizeInflation
)
;
nscoord
defaultRuleThickness
axisHeight
;
nscoord
oneDevPixel
=
fm
-
>
AppUnitsPerDevPixel
(
)
;
RefPtr
<
gfxFont
>
mathFont
=
fm
-
>
GetThebesFontGroup
(
)
-
>
GetFirstMathFont
(
)
;
if
(
mathFont
)
{
defaultRuleThickness
=
mathFont
-
>
MathTable
(
)
-
>
Constant
(
gfxMathTable
:
:
FractionRuleThickness
oneDevPixel
)
;
}
else
{
GetRuleThickness
(
aDrawTarget
fm
defaultRuleThickness
)
;
}
GetAxisHeight
(
aDrawTarget
fm
axisHeight
)
;
bool
outermostEmbellished
=
false
;
if
(
mEmbellishData
.
coreFrame
)
{
nsEmbellishData
parentData
;
GetEmbellishDataFrom
(
GetParent
(
)
parentData
)
;
outermostEmbellished
=
parentData
.
coreFrame
!
=
mEmbellishData
.
coreFrame
;
}
nsAutoString
value
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
linethickness_
value
)
;
mLineThickness
=
CalcLineThickness
(
presContext
mComputedStyle
value
onePixel
defaultRuleThickness
fontSizeInflation
)
;
bool
displayStyle
=
StyleFont
(
)
-
>
mMathStyle
=
=
NS_STYLE_MATH_STYLE_NORMAL
;
mLineRect
.
height
=
mLineThickness
;
nscoord
leftSpace
=
onePixel
;
nscoord
rightSpace
=
onePixel
;
if
(
outermostEmbellished
)
{
const
bool
isRTL
=
StyleVisibility
(
)
-
>
mDirection
=
=
StyleDirection
:
:
Rtl
;
nsEmbellishData
coreData
;
GetEmbellishDataFrom
(
mEmbellishData
.
coreFrame
coreData
)
;
leftSpace
+
=
isRTL
?
coreData
.
trailingSpace
:
coreData
.
leadingSpace
;
rightSpace
+
=
isRTL
?
coreData
.
leadingSpace
:
coreData
.
trailingSpace
;
}
nscoord
actualRuleThickness
=
mLineThickness
;
nscoord
numShift
=
0
;
nscoord
denShift
=
0
;
nscoord
numShift1
numShift2
numShift3
;
nscoord
denShift1
denShift2
;
GetNumeratorShifts
(
fm
numShift1
numShift2
numShift3
)
;
GetDenominatorShifts
(
fm
denShift1
denShift2
)
;
if
(
0
=
=
actualRuleThickness
)
{
numShift
=
displayStyle
?
numShift1
:
numShift3
;
denShift
=
displayStyle
?
denShift1
:
denShift2
;
if
(
mathFont
)
{
numShift
=
mathFont
-
>
MathTable
(
)
-
>
Constant
(
displayStyle
?
gfxMathTable
:
:
StackTopDisplayStyleShiftUp
:
gfxMathTable
:
:
StackTopShiftUp
oneDevPixel
)
;
denShift
=
mathFont
-
>
MathTable
(
)
-
>
Constant
(
displayStyle
?
gfxMathTable
:
:
StackBottomDisplayStyleShiftDown
:
gfxMathTable
:
:
StackBottomShiftDown
oneDevPixel
)
;
}
}
else
{
numShift
=
displayStyle
?
numShift1
:
numShift2
;
denShift
=
displayStyle
?
denShift1
:
denShift2
;
if
(
mathFont
)
{
numShift
=
mathFont
-
>
MathTable
(
)
-
>
Constant
(
displayStyle
?
gfxMathTable
:
:
FractionNumeratorDisplayStyleShiftUp
:
gfxMathTable
:
:
FractionNumeratorShiftUp
oneDevPixel
)
;
denShift
=
mathFont
-
>
MathTable
(
)
-
>
Constant
(
displayStyle
?
gfxMathTable
:
:
FractionDenominatorDisplayStyleShiftDown
:
gfxMathTable
:
:
FractionDenominatorShiftDown
oneDevPixel
)
;
}
}
if
(
0
=
=
actualRuleThickness
)
{
nscoord
minClearance
=
displayStyle
?
7
*
defaultRuleThickness
:
3
*
defaultRuleThickness
;
if
(
mathFont
)
{
minClearance
=
mathFont
-
>
MathTable
(
)
-
>
Constant
(
displayStyle
?
gfxMathTable
:
:
StackDisplayStyleGapMin
:
gfxMathTable
:
:
StackGapMin
oneDevPixel
)
;
}
nscoord
actualClearance
=
(
numShift
-
bmNum
.
descent
)
-
(
bmDen
.
ascent
-
denShift
)
;
if
(
actualClearance
<
minClearance
)
{
nscoord
halfGap
=
(
minClearance
-
actualClearance
)
/
2
;
numShift
+
=
halfGap
;
denShift
+
=
halfGap
;
}
}
else
{
nscoord
minClearanceNum
=
displayStyle
?
3
*
defaultRuleThickness
:
defaultRuleThickness
+
onePixel
;
nscoord
minClearanceDen
=
minClearanceNum
;
if
(
mathFont
)
{
minClearanceNum
=
mathFont
-
>
MathTable
(
)
-
>
Constant
(
displayStyle
?
gfxMathTable
:
:
FractionNumDisplayStyleGapMin
:
gfxMathTable
:
:
FractionNumeratorGapMin
oneDevPixel
)
;
minClearanceDen
=
mathFont
-
>
MathTable
(
)
-
>
Constant
(
displayStyle
?
gfxMathTable
:
:
FractionDenomDisplayStyleGapMin
:
gfxMathTable
:
:
FractionDenominatorGapMin
oneDevPixel
)
;
}
nscoord
actualClearanceNum
=
(
numShift
-
bmNum
.
descent
)
-
(
axisHeight
+
actualRuleThickness
/
2
)
;
if
(
actualClearanceNum
<
minClearanceNum
)
{
numShift
+
=
(
minClearanceNum
-
actualClearanceNum
)
;
}
nscoord
actualClearanceDen
=
(
axisHeight
-
actualRuleThickness
/
2
)
-
(
bmDen
.
ascent
-
denShift
)
;
if
(
actualClearanceDen
<
minClearanceDen
)
{
denShift
+
=
(
minClearanceDen
-
actualClearanceDen
)
;
}
}
nscoord
width
=
std
:
:
max
(
bmNum
.
width
bmDen
.
width
)
;
nscoord
dxNum
=
leftSpace
+
(
width
-
sizeNum
.
Width
(
)
)
/
2
;
nscoord
dxDen
=
leftSpace
+
(
width
-
sizeDen
.
Width
(
)
)
/
2
;
width
+
=
leftSpace
+
rightSpace
;
mBoundingMetrics
.
rightBearing
=
std
:
:
max
(
dxNum
+
bmNum
.
rightBearing
dxDen
+
bmDen
.
rightBearing
)
;
if
(
mBoundingMetrics
.
rightBearing
<
width
-
rightSpace
)
mBoundingMetrics
.
rightBearing
=
width
-
rightSpace
;
mBoundingMetrics
.
leftBearing
=
std
:
:
min
(
dxNum
+
bmNum
.
leftBearing
dxDen
+
bmDen
.
leftBearing
)
;
if
(
mBoundingMetrics
.
leftBearing
>
leftSpace
)
mBoundingMetrics
.
leftBearing
=
leftSpace
;
mBoundingMetrics
.
ascent
=
bmNum
.
ascent
+
numShift
;
mBoundingMetrics
.
descent
=
bmDen
.
descent
+
denShift
;
mBoundingMetrics
.
width
=
width
;
aDesiredSize
.
SetBlockStartAscent
(
sizeNum
.
BlockStartAscent
(
)
+
numShift
)
;
aDesiredSize
.
Height
(
)
=
aDesiredSize
.
BlockStartAscent
(
)
+
sizeDen
.
Height
(
)
-
sizeDen
.
BlockStartAscent
(
)
+
denShift
;
aDesiredSize
.
Width
(
)
=
mBoundingMetrics
.
width
;
aDesiredSize
.
mBoundingMetrics
=
mBoundingMetrics
;
mReference
.
x
=
0
;
mReference
.
y
=
aDesiredSize
.
BlockStartAscent
(
)
;
if
(
aPlaceOrigin
)
{
nscoord
dy
;
dy
=
0
;
FinishReflowChild
(
frameNum
presContext
sizeNum
nullptr
dxNum
dy
ReflowChildFlags
:
:
Default
)
;
dy
=
aDesiredSize
.
Height
(
)
-
sizeDen
.
Height
(
)
;
FinishReflowChild
(
frameDen
presContext
sizeDen
nullptr
dxDen
dy
ReflowChildFlags
:
:
Default
)
;
dy
=
aDesiredSize
.
BlockStartAscent
(
)
-
(
axisHeight
+
actualRuleThickness
/
2
)
;
mLineRect
.
SetRect
(
leftSpace
dy
width
-
(
leftSpace
+
rightSpace
)
actualRuleThickness
)
;
}
return
NS_OK
;
}
