#
include
"
nsMathMLSelectedFrame
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
ReflowOutput
.
h
"
#
include
"
mozilla
/
WritingModes
.
h
"
#
include
"
nsCoord
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsFontMetrics
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsStringFwd
.
h
"
using
namespace
mozilla
;
nsMathMLSelectedFrame
:
:
~
nsMathMLSelectedFrame
(
)
=
default
;
NS_IMETHODIMP
nsMathMLSelectedFrame
:
:
TransmitAutomaticData
(
)
{
nsIMathMLFrame
*
mathMLFrame
=
do_QueryFrame
(
mSelectedFrame
)
;
if
(
mathMLFrame
&
&
mathMLFrame
-
>
IsSpaceLike
(
)
)
{
mPresentationData
.
flags
|
=
NS_MATHML_SPACE_LIKE
;
}
else
{
mPresentationData
.
flags
&
=
~
NS_MATHML_SPACE_LIKE
;
}
mPresentationData
.
baseFrame
=
mSelectedFrame
;
GetEmbellishDataFrom
(
mSelectedFrame
mEmbellishData
)
;
return
NS_OK
;
}
nsresult
nsMathMLSelectedFrame
:
:
ChildListChanged
(
int32_t
aModType
)
{
GetSelectedFrame
(
)
;
return
nsMathMLContainerFrame
:
:
ChildListChanged
(
aModType
)
;
}
void
nsMathMLSelectedFrame
:
:
SetInitialChildList
(
ChildListID
aListID
nsFrameList
&
&
aChildList
)
{
nsMathMLContainerFrame
:
:
SetInitialChildList
(
aListID
std
:
:
move
(
aChildList
)
)
;
GetSelectedFrame
(
)
;
}
void
nsMathMLSelectedFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
if
(
NS_MATHML_HAS_ERROR
(
mPresentationData
.
flags
)
)
{
nsMathMLContainerFrame
:
:
BuildDisplayList
(
aBuilder
aLists
)
;
return
;
}
DisplayBorderBackgroundOutline
(
aBuilder
aLists
)
;
nsIFrame
*
childFrame
=
GetSelectedFrame
(
)
;
if
(
childFrame
)
{
nsDisplayListSet
set
(
aLists
aLists
.
Content
(
)
)
;
BuildDisplayListForChild
(
aBuilder
childFrame
set
)
;
}
#
if
defined
(
DEBUG
)
&
&
defined
(
SHOW_BOUNDING_BOX
)
DisplayBoundingMetrics
(
aBuilder
this
mReference
mBoundingMetrics
aLists
)
;
#
endif
}
nsIFrame
:
:
SizeComputationResult
nsMathMLSelectedFrame
:
:
ComputeSize
(
gfxContext
*
aRenderingContext
WritingMode
aWM
const
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
LogicalSize
&
aMargin
const
LogicalSize
&
aBorderPadding
const
StyleSizeOverrides
&
aSizeOverrides
ComputeSizeFlags
aFlags
)
{
nsIFrame
*
childFrame
=
GetSelectedFrame
(
)
;
if
(
childFrame
)
{
const
nscoord
availableISize
=
aAvailableISize
-
aBorderPadding
.
ISize
(
aWM
)
-
aMargin
.
ISize
(
aWM
)
;
const
LogicalSize
cbSize
=
aCBSize
-
aBorderPadding
-
aMargin
;
SizeComputationInput
offsetState
(
childFrame
aRenderingContext
aWM
availableISize
)
;
const
auto
bpSize
=
offsetState
.
ComputedLogicalBorderPadding
(
aWM
)
.
Size
(
aWM
)
;
auto
size
=
childFrame
-
>
ComputeSize
(
aRenderingContext
aWM
cbSize
availableISize
offsetState
.
ComputedLogicalMargin
(
aWM
)
.
Size
(
aWM
)
bpSize
aSizeOverrides
aFlags
)
;
return
{
size
.
mLogicalSize
+
bpSize
size
.
mAspectRatioUsage
}
;
}
return
{
LogicalSize
(
aWM
)
AspectRatioUsage
:
:
None
}
;
}
nsresult
nsMathMLSelectedFrame
:
:
ReflowError
(
DrawTarget
*
aDrawTarget
ReflowOutput
&
aDesiredSize
)
{
mEmbellishData
.
flags
=
0
;
mPresentationData
.
flags
=
NS_MATHML_ERROR
;
RefPtr
<
nsFontMetrics
>
fm
=
nsLayoutUtils
:
:
GetInflatedFontMetricsForFrame
(
this
)
;
nsAutoString
errorMsg
;
errorMsg
.
AssignLiteral
(
"
invalid
-
markup
"
)
;
mBoundingMetrics
=
nsLayoutUtils
:
:
AppUnitBoundsOfString
(
errorMsg
.
get
(
)
errorMsg
.
Length
(
)
*
fm
aDrawTarget
)
;
WritingMode
wm
=
aDesiredSize
.
GetWritingMode
(
)
;
aDesiredSize
.
SetBlockStartAscent
(
fm
-
>
MaxAscent
(
)
)
;
nscoord
descent
=
fm
-
>
MaxDescent
(
)
;
aDesiredSize
.
BSize
(
wm
)
=
aDesiredSize
.
BlockStartAscent
(
)
+
descent
;
aDesiredSize
.
ISize
(
wm
)
=
mBoundingMetrics
.
width
;
aDesiredSize
.
mBoundingMetrics
=
mBoundingMetrics
;
return
NS_OK
;
}
void
nsMathMLSelectedFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
mPresentationData
.
flags
&
=
~
NS_MATHML_ERROR
;
aDesiredSize
.
ClearSize
(
)
;
aDesiredSize
.
SetBlockStartAscent
(
0
)
;
mBoundingMetrics
=
nsBoundingMetrics
(
)
;
nsIFrame
*
childFrame
=
GetSelectedFrame
(
)
;
if
(
childFrame
)
{
WritingMode
wm
=
childFrame
-
>
GetWritingMode
(
)
;
LogicalSize
availSize
=
aReflowInput
.
ComputedSize
(
wm
)
;
availSize
.
BSize
(
wm
)
=
NS_UNCONSTRAINEDSIZE
;
ReflowInput
childReflowInput
(
aPresContext
aReflowInput
childFrame
availSize
)
;
ReflowChild
(
childFrame
aPresContext
aDesiredSize
childReflowInput
aStatus
)
;
SaveReflowAndBoundingMetricsFor
(
childFrame
aDesiredSize
aDesiredSize
.
mBoundingMetrics
)
;
mBoundingMetrics
=
aDesiredSize
.
mBoundingMetrics
;
}
FinalizeReflow
(
aReflowInput
.
mRenderingContext
-
>
GetDrawTarget
(
)
aDesiredSize
)
;
}
nsresult
nsMathMLSelectedFrame
:
:
Place
(
DrawTarget
*
aDrawTarget
bool
aPlaceOrigin
ReflowOutput
&
aDesiredSize
)
{
nsIFrame
*
childFrame
=
GetSelectedFrame
(
)
;
if
(
mInvalidMarkup
)
{
return
ReflowError
(
aDrawTarget
aDesiredSize
)
;
}
aDesiredSize
.
ClearSize
(
)
;
aDesiredSize
.
SetBlockStartAscent
(
0
)
;
mBoundingMetrics
=
nsBoundingMetrics
(
)
;
if
(
childFrame
)
{
GetReflowAndBoundingMetricsFor
(
childFrame
aDesiredSize
mBoundingMetrics
)
;
if
(
aPlaceOrigin
)
{
FinishReflowChild
(
childFrame
PresContext
(
)
aDesiredSize
nullptr
0
0
ReflowChildFlags
:
:
Default
)
;
}
mReference
.
x
=
0
;
mReference
.
y
=
aDesiredSize
.
BlockStartAscent
(
)
;
}
aDesiredSize
.
mBoundingMetrics
=
mBoundingMetrics
;
return
NS_OK
;
}
