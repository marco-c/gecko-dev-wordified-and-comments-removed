const
XHTML_NS
=
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
;
const
DEBUG_CONTRACTID
=
"
mozilla
.
org
/
xpcom
/
debug
;
1
"
;
const
PRINTSETTINGS_CONTRACTID
=
"
mozilla
.
org
/
gfx
/
printsettings
-
service
;
1
"
;
const
ENVIRONMENT_CONTRACTID
=
"
mozilla
.
org
/
process
/
environment
;
1
"
;
const
NS_OBSERVER_SERVICE_CONTRACTID
=
"
mozilla
.
org
/
observer
-
service
;
1
"
;
const
NS_GFXINFO_CONTRACTID
=
"
mozilla
.
org
/
gfx
/
info
;
1
"
;
const
IO_SERVICE_CONTRACTID
=
"
mozilla
.
org
/
network
/
io
-
service
;
1
"
const
BLANK_URL_FOR_CLEARING
=
"
data
:
text
/
html
;
charset
=
UTF
-
8
%
3C
%
21
%
2D
%
2DCLEAR
%
2D
%
2D
%
3E
"
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Timer
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
reftest
/
AsyncSpellCheckTestHelper
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
ChromeUtils
.
import
(
"
resource
:
/
/
gre
/
modules
/
CustomElementsListener
.
jsm
"
null
)
;
var
gBrowserIsRemote
;
var
gIsWebRenderEnabled
;
var
gHaveCanvasSnapshot
=
false
;
var
gExplicitPendingPaintCount
=
0
;
var
gExplicitPendingPaintsCompleteHook
;
var
gCurrentURL
;
var
gCurrentURLRecordResults
;
var
gCurrentURLTargetType
;
var
gCurrentTestType
;
var
gTimeoutHook
=
null
;
var
gFailureTimeout
=
null
;
var
gFailureReason
;
var
gAssertionCount
=
0
;
var
gDebug
;
var
gVerbose
=
false
;
var
gCurrentTestStartTime
;
var
gClearingForAssertionCheck
=
false
;
const
TYPE_LOAD
=
'
load
'
;
const
TYPE_SCRIPT
=
'
script
'
;
const
TYPE_PRINT
=
'
print
'
;
const
URL_TARGET_TYPE_TEST
=
0
;
const
URL_TARGET_TYPE_REFERENCE
=
1
;
function
webNavigation
(
)
{
return
docShell
.
QueryInterface
(
Ci
.
nsIWebNavigation
)
;
}
function
webProgress
(
)
{
return
docShell
.
QueryInterface
(
Ci
.
nsIInterfaceRequestor
)
.
getInterface
(
Ci
.
nsIWebProgress
)
;
}
function
windowUtilsForWindow
(
w
)
{
return
w
.
windowUtils
;
}
function
windowUtils
(
)
{
return
windowUtilsForWindow
(
content
)
;
}
function
IDForEventTarget
(
event
)
{
try
{
return
"
'
"
+
event
.
target
.
getAttribute
(
'
id
'
)
+
"
'
"
;
}
catch
(
ex
)
{
return
"
<
unknown
>
"
;
}
}
function
PaintWaitListener
(
event
)
{
LogInfo
(
"
MozPaintWait
received
for
ID
"
+
IDForEventTarget
(
event
)
)
;
gExplicitPendingPaintCount
+
+
;
}
function
PaintWaitFinishedListener
(
event
)
{
LogInfo
(
"
MozPaintWaitFinished
received
for
ID
"
+
IDForEventTarget
(
event
)
)
;
gExplicitPendingPaintCount
-
-
;
if
(
gExplicitPendingPaintCount
<
0
)
{
LogWarning
(
"
Underrun
in
gExplicitPendingPaintCount
\
n
"
)
;
gExplicitPendingPaintCount
=
0
;
}
if
(
gExplicitPendingPaintCount
=
=
0
&
&
gExplicitPendingPaintsCompleteHook
)
{
gExplicitPendingPaintsCompleteHook
(
)
;
}
}
var
progressListener
=
{
onStateChange
(
webprogress
request
flags
status
)
{
let
uri
;
try
{
request
.
QueryInterface
(
Ci
.
nsIChannel
)
;
uri
=
request
.
originalURI
.
spec
;
}
catch
(
ex
)
{
return
;
}
const
WPL
=
Ci
.
nsIWebProgressListener
;
const
endFlags
=
WPL
.
STATE_STOP
|
WPL
.
STATE_IS_WINDOW
|
WPL
.
STATE_IS_NETWORK
;
if
(
(
flags
&
endFlags
)
=
=
endFlags
)
{
OnDocumentLoad
(
uri
)
;
}
}
QueryInterface
:
ChromeUtils
.
generateQI
(
[
Ci
.
nsIWebProgressListener
Ci
.
nsISupportsWeakReference
]
)
}
;
function
OnInitialLoad
(
)
{
removeEventListener
(
"
load
"
OnInitialLoad
true
)
;
gDebug
=
Cc
[
DEBUG_CONTRACTID
]
.
getService
(
Ci
.
nsIDebug2
)
;
if
(
gDebug
.
isDebugBuild
)
{
gAssertionCount
=
gDebug
.
assertionCount
;
}
var
env
=
Cc
[
ENVIRONMENT_CONTRACTID
]
.
getService
(
Ci
.
nsIEnvironment
)
;
gVerbose
=
!
!
env
.
get
(
"
MOZ_REFTEST_VERBOSE
"
)
;
RegisterMessageListeners
(
)
;
var
initInfo
=
SendContentReady
(
)
;
gBrowserIsRemote
=
initInfo
.
remote
;
webProgress
(
)
.
addProgressListener
(
progressListener
Ci
.
nsIWebProgress
.
NOTIFY_STATE_WINDOW
)
;
addEventListener
(
"
MozPaintWait
"
PaintWaitListener
true
)
;
addEventListener
(
"
MozPaintWaitFinished
"
PaintWaitFinishedListener
true
)
;
LogInfo
(
"
Using
browser
remote
=
"
+
gBrowserIsRemote
+
"
\
n
"
)
;
}
function
SetFailureTimeout
(
cb
timeout
uri
)
{
var
targetTime
=
Date
.
now
(
)
+
timeout
;
var
wrapper
=
function
(
)
{
let
remainingMs
=
targetTime
-
Date
.
now
(
)
;
if
(
remainingMs
>
0
)
{
SetFailureTimeout
(
cb
remainingMs
)
;
}
else
{
cb
(
)
;
}
}
gFailureReason
=
"
timed
out
after
"
+
timeout
+
"
ms
waiting
for
'
load
'
event
for
"
+
uri
;
gFailureTimeout
=
setTimeout
(
wrapper
timeout
)
;
}
function
StartTestURI
(
type
uri
uriTargetType
timeout
)
{
windowUtils
(
)
.
runNextCollectorTimer
(
)
;
if
(
gExplicitPendingPaintCount
!
=
0
)
{
LogWarning
(
"
Resetting
gExplicitPendingPaintCount
to
zero
(
currently
"
+
gExplicitPendingPaintCount
+
"
\
n
"
)
;
gExplicitPendingPaintCount
=
0
;
}
gCurrentTestType
=
type
;
gCurrentURL
=
uri
;
gCurrentURLTargetType
=
uriTargetType
;
gCurrentURLRecordResults
=
0
;
gCurrentTestStartTime
=
Date
.
now
(
)
;
if
(
gFailureTimeout
!
=
null
)
{
SendException
(
"
program
error
managing
timeouts
\
n
"
)
;
}
SetFailureTimeout
(
LoadFailed
timeout
uri
)
;
LoadURI
(
gCurrentURL
)
;
}
function
setupTextZoom
(
contentRootElement
)
{
if
(
!
contentRootElement
|
|
!
contentRootElement
.
hasAttribute
(
'
reftest
-
text
-
zoom
'
)
)
return
;
docShell
.
browsingContext
.
textZoom
=
contentRootElement
.
getAttribute
(
'
reftest
-
text
-
zoom
'
)
;
}
function
setupFullZoom
(
contentRootElement
)
{
if
(
!
contentRootElement
|
|
!
contentRootElement
.
hasAttribute
(
'
reftest
-
zoom
'
)
)
return
;
docShell
.
browsingContext
.
fullZoom
=
contentRootElement
.
getAttribute
(
'
reftest
-
zoom
'
)
;
}
function
resetZoomAndTextZoom
(
)
{
docShell
.
browsingContext
.
fullZoom
=
1
.
0
;
docShell
.
browsingContext
.
textZoom
=
1
.
0
;
}
function
doPrintMode
(
contentRootElement
)
{
if
(
contentRootElement
&
&
contentRootElement
.
hasAttribute
(
'
class
'
)
)
{
var
classList
=
contentRootElement
.
getAttribute
(
'
class
'
)
.
split
(
/
\
s
+
/
)
;
if
(
classList
.
includes
(
"
reftest
-
print
"
)
)
{
SendException
(
"
reftest
-
print
is
obsolete
use
reftest
-
paged
instead
"
)
;
return
;
}
return
classList
.
includes
(
"
reftest
-
paged
"
)
;
}
}
function
setupPrintMode
(
)
{
var
PSSVC
=
Cc
[
PRINTSETTINGS_CONTRACTID
]
.
getService
(
Ci
.
nsIPrintSettingsService
)
;
var
ps
=
PSSVC
.
newPrintSettings
;
ps
.
paperWidth
=
5
;
ps
.
paperHeight
=
3
;
ps
.
unwriteableMarginTop
=
0
;
ps
.
unwriteableMarginLeft
=
0
;
ps
.
unwriteableMarginBottom
=
0
;
ps
.
unwriteableMarginRight
=
0
;
ps
.
headerStrLeft
=
"
"
;
ps
.
headerStrCenter
=
"
"
;
ps
.
headerStrRight
=
"
"
;
ps
.
footerStrLeft
=
"
"
;
ps
.
footerStrCenter
=
"
"
;
ps
.
footerStrRight
=
"
"
;
docShell
.
contentViewer
.
setPageModeForTesting
(
true
ps
)
;
}
function
printToPdf
(
callback
)
{
let
currentDoc
=
content
.
document
;
let
isPrintSelection
=
false
;
let
printRange
=
'
'
;
if
(
currentDoc
)
{
let
contentRootElement
=
currentDoc
.
documentElement
;
printRange
=
contentRootElement
.
getAttribute
(
"
reftest
-
print
-
range
"
)
|
|
'
'
;
}
if
(
printRange
)
{
if
(
printRange
=
=
=
'
selection
'
)
{
isPrintSelection
=
true
;
}
else
if
(
!
/
^
[
1
-
9
]
\
d
*
-
[
1
-
9
]
\
d
*
/
.
test
(
printRange
)
)
{
SendException
(
"
invalid
value
for
reftest
-
print
-
range
"
)
;
return
;
}
}
let
fileName
=
reftest
-
print
-
{
Date
.
now
(
)
}
-
;
content
.
crypto
.
getRandomValues
(
new
Uint8Array
(
4
)
)
.
forEach
(
x
=
>
fileName
+
=
x
.
toString
(
16
)
)
;
fileName
+
=
"
.
pdf
"
let
file
=
Services
.
dirsvc
.
get
(
"
TmpD
"
Ci
.
nsIFile
)
;
file
.
append
(
fileName
)
;
let
PSSVC
=
Cc
[
PRINTSETTINGS_CONTRACTID
]
.
getService
(
Ci
.
nsIPrintSettingsService
)
;
let
ps
=
PSSVC
.
newPrintSettings
;
ps
.
printSilent
=
true
;
ps
.
showPrintProgress
=
false
;
ps
.
printBGImages
=
true
;
ps
.
printBGColors
=
true
;
ps
.
printToFile
=
true
;
ps
.
toFileName
=
file
.
path
;
ps
.
outputFormat
=
Ci
.
nsIPrintSettings
.
kOutputFormatPDF
;
if
(
isPrintSelection
)
{
ps
.
printRange
=
Ci
.
nsIPrintSettings
.
kRangeSelection
;
}
else
if
(
printRange
)
{
ps
.
printRange
=
Ci
.
nsIPrintSettings
.
kRangeSpecifiedPageRange
;
let
range
=
printRange
.
split
(
'
-
'
)
;
ps
.
startPageRange
=
+
range
[
0
]
|
|
1
;
ps
.
endPageRange
=
+
range
[
1
]
|
|
1
;
}
let
webBrowserPrint
=
content
.
getInterface
(
Ci
.
nsIWebBrowserPrint
)
;
webBrowserPrint
.
print
(
ps
{
onStateChange
:
function
(
webProgress
request
stateFlags
status
)
{
if
(
stateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_STOP
&
&
stateFlags
&
Ci
.
nsIWebProgressListener
.
STATE_IS_NETWORK
)
{
callback
(
status
file
.
path
)
;
}
}
onProgressChange
:
function
(
)
{
}
onLocationChange
:
function
(
)
{
}
onStatusChange
:
function
(
)
{
}
onSecurityChange
:
function
(
)
{
}
onContentBlockingEvent
:
function
(
)
{
}
}
)
;
}
function
attrOrDefault
(
element
attr
def
)
{
return
element
.
hasAttribute
(
attr
)
?
Number
(
element
.
getAttribute
(
attr
)
)
:
def
;
}
function
setupViewport
(
contentRootElement
)
{
if
(
!
contentRootElement
)
{
return
;
}
var
sw
=
attrOrDefault
(
contentRootElement
"
reftest
-
scrollport
-
w
"
0
)
;
var
sh
=
attrOrDefault
(
contentRootElement
"
reftest
-
scrollport
-
h
"
0
)
;
if
(
sw
!
=
=
0
|
|
sh
!
=
=
0
)
{
LogInfo
(
"
Setting
viewport
to
<
w
=
"
+
sw
+
"
h
=
"
+
sh
+
"
>
"
)
;
windowUtils
(
)
.
setVisualViewportSize
(
sw
sh
)
;
}
var
res
=
attrOrDefault
(
contentRootElement
"
reftest
-
resolution
"
1
)
;
if
(
res
!
=
=
1
)
{
LogInfo
(
"
Setting
resolution
to
"
+
res
)
;
windowUtils
(
)
.
setResolutionAndScaleTo
(
res
)
;
}
}
function
setupDisplayport
(
contentRootElement
)
{
if
(
!
contentRootElement
)
{
return
;
}
function
setupDisplayportForElement
(
element
winUtils
)
{
var
dpw
=
attrOrDefault
(
element
"
reftest
-
displayport
-
w
"
0
)
;
var
dph
=
attrOrDefault
(
element
"
reftest
-
displayport
-
h
"
0
)
;
var
dpx
=
attrOrDefault
(
element
"
reftest
-
displayport
-
x
"
0
)
;
var
dpy
=
attrOrDefault
(
element
"
reftest
-
displayport
-
y
"
0
)
;
if
(
dpw
!
=
=
0
|
|
dph
!
=
=
0
|
|
dpx
!
=
0
|
|
dpy
!
=
0
)
{
LogInfo
(
"
Setting
displayport
to
<
x
=
"
+
dpx
+
"
y
=
"
+
dpy
+
"
w
=
"
+
dpw
+
"
h
=
"
+
dph
+
"
>
"
)
;
winUtils
.
setDisplayPortForElement
(
dpx
dpy
dpw
dph
element
1
)
;
}
}
function
setupDisplayportForElementSubtree
(
element
winUtils
)
{
setupDisplayportForElement
(
element
winUtils
)
;
for
(
var
c
=
element
.
firstElementChild
;
c
;
c
=
c
.
nextElementSibling
)
{
setupDisplayportForElementSubtree
(
c
winUtils
)
;
}
if
(
element
.
contentDocument
)
{
LogInfo
(
"
Descending
into
subdocument
"
)
;
setupDisplayportForElementSubtree
(
element
.
contentDocument
.
documentElement
windowUtilsForWindow
(
element
.
contentWindow
)
)
;
}
}
if
(
contentRootElement
.
hasAttribute
(
"
reftest
-
async
-
scroll
"
)
)
{
setupDisplayportForElementSubtree
(
contentRootElement
windowUtils
(
)
)
;
}
else
{
setupDisplayportForElement
(
contentRootElement
windowUtils
(
)
)
;
}
}
function
setupAsyncScrollOffsets
(
options
)
{
var
currentDoc
=
content
.
document
;
var
contentRootElement
=
currentDoc
?
currentDoc
.
documentElement
:
null
;
if
(
!
contentRootElement
)
{
return
false
;
}
function
setupAsyncScrollOffsetsForElement
(
element
winUtils
)
{
var
sx
=
attrOrDefault
(
element
"
reftest
-
async
-
scroll
-
x
"
0
)
;
var
sy
=
attrOrDefault
(
element
"
reftest
-
async
-
scroll
-
y
"
0
)
;
if
(
sx
!
=
0
|
|
sy
!
=
0
)
{
try
{
winUtils
.
setAsyncScrollOffset
(
element
sx
sy
)
;
return
true
;
}
catch
(
e
)
{
if
(
!
options
.
allowFailure
)
{
throw
e
;
}
}
}
return
false
;
}
function
setupAsyncScrollOffsetsForElementSubtree
(
element
winUtils
)
{
var
updatedAny
=
setupAsyncScrollOffsetsForElement
(
element
winUtils
)
;
for
(
var
c
=
element
.
firstElementChild
;
c
;
c
=
c
.
nextElementSibling
)
{
if
(
setupAsyncScrollOffsetsForElementSubtree
(
c
winUtils
)
)
{
updatedAny
=
true
;
}
}
if
(
element
.
contentDocument
)
{
LogInfo
(
"
Descending
into
subdocument
(
async
offsets
)
"
)
;
if
(
setupAsyncScrollOffsetsForElementSubtree
(
element
.
contentDocument
.
documentElement
windowUtilsForWindow
(
element
.
contentWindow
)
)
)
{
updatedAny
=
true
;
}
}
return
updatedAny
;
}
var
asyncScroll
=
contentRootElement
.
hasAttribute
(
"
reftest
-
async
-
scroll
"
)
;
if
(
asyncScroll
)
{
return
setupAsyncScrollOffsetsForElementSubtree
(
contentRootElement
windowUtils
(
)
)
;
}
return
false
;
}
function
setupAsyncZoom
(
options
)
{
var
currentDoc
=
content
.
document
;
var
contentRootElement
=
currentDoc
?
currentDoc
.
documentElement
:
null
;
if
(
!
contentRootElement
|
|
!
contentRootElement
.
hasAttribute
(
'
reftest
-
async
-
zoom
'
)
)
return
false
;
var
zoom
=
attrOrDefault
(
contentRootElement
"
reftest
-
async
-
zoom
"
1
)
;
if
(
zoom
!
=
1
)
{
try
{
windowUtils
(
)
.
setAsyncZoom
(
contentRootElement
zoom
)
;
return
true
;
}
catch
(
e
)
{
if
(
!
options
.
allowFailure
)
{
throw
e
;
}
}
}
return
false
;
}
function
resetDisplayportAndViewport
(
)
{
}
function
shouldWaitForExplicitPaintWaiters
(
)
{
return
gExplicitPendingPaintCount
>
0
;
}
function
shouldWaitForPendingPaints
(
)
{
return
gHaveCanvasSnapshot
&
&
windowUtils
(
)
.
isMozAfterPaintPending
;
}
function
shouldWaitForReftestWaitRemoval
(
contentRootElement
)
{
return
contentRootElement
&
&
contentRootElement
.
hasAttribute
(
'
class
'
)
&
&
contentRootElement
.
getAttribute
(
'
class
'
)
.
split
(
/
\
s
+
/
)
.
includes
(
"
reftest
-
wait
"
)
;
}
function
shouldSnapshotWholePage
(
contentRootElement
)
{
return
contentRootElement
&
&
contentRootElement
.
hasAttribute
(
'
class
'
)
&
&
contentRootElement
.
getAttribute
(
'
class
'
)
.
split
(
/
\
s
+
/
)
.
includes
(
"
reftest
-
snapshot
-
all
"
)
;
}
function
getNoPaintElements
(
contentRootElement
)
{
return
contentRootElement
.
getElementsByClassName
(
'
reftest
-
no
-
paint
'
)
;
}
function
getNoDisplayListElements
(
contentRootElement
)
{
return
contentRootElement
.
getElementsByClassName
(
'
reftest
-
no
-
display
-
list
'
)
;
}
function
getDisplayListElements
(
contentRootElement
)
{
return
contentRootElement
.
getElementsByClassName
(
'
reftest
-
display
-
list
'
)
;
}
function
getOpaqueLayerElements
(
contentRootElement
)
{
return
contentRootElement
.
getElementsByClassName
(
'
reftest
-
opaque
-
layer
'
)
;
}
function
getAssignedLayerMap
(
contentRootElement
)
{
var
layerNameToElementsMap
=
{
}
;
var
elements
=
contentRootElement
.
querySelectorAll
(
'
[
reftest
-
assigned
-
layer
]
'
)
;
for
(
var
i
=
0
;
i
<
elements
.
length
;
+
+
i
)
{
var
element
=
elements
[
i
]
;
var
layerName
=
element
.
getAttribute
(
'
reftest
-
assigned
-
layer
'
)
;
if
(
!
(
layerName
in
layerNameToElementsMap
)
)
{
layerNameToElementsMap
[
layerName
]
=
[
]
;
}
layerNameToElementsMap
[
layerName
]
.
push
(
element
)
;
}
return
layerNameToElementsMap
;
}
const
FlushMode
=
{
ALL
:
0
IGNORE_THROTTLED_ANIMATIONS
:
1
}
;
const
STATE_WAITING_TO_FIRE_INVALIDATE_EVENT
=
0
;
const
STATE_WAITING_FOR_REFTEST_WAIT_REMOVAL
=
1
;
const
STATE_WAITING_FOR_SPELL_CHECKS
=
2
;
const
STATE_WAITING_FOR_APZ_FLUSH
=
3
;
const
STATE_WAITING_TO_FINISH
=
4
;
const
STATE_COMPLETED
=
5
;
function
FlushRendering
(
aFlushMode
)
{
let
browsingContext
=
content
.
docShell
.
browsingContext
;
let
ignoreThrottledAnimations
=
(
aFlushMode
=
=
=
FlushMode
.
IGNORE_THROTTLED_ANIMATIONS
)
;
let
promise
=
content
.
windowGlobalChild
.
getActor
(
"
ReftestFission
"
)
.
sendQuery
(
"
FlushRendering
"
{
browsingContext
ignoreThrottledAnimations
}
)
;
return
promise
.
then
(
function
(
result
)
{
for
(
let
errorString
of
result
.
errorStrings
)
{
LogError
(
errorString
)
;
}
for
(
let
warningString
of
result
.
warningStrings
)
{
LogWarning
(
warningString
)
;
}
for
(
let
infoString
of
result
.
infoStrings
)
{
LogInfo
(
infoString
)
;
}
}
function
(
reason
)
{
LogInfo
(
"
FlushRendering
sendQuery
to
parent
rejected
:
"
+
reason
)
;
}
)
;
}
function
WaitForTestEnd
(
contentRootElement
inPrintMode
spellCheckedElements
forURL
)
{
function
CheckForLivenessOfContentRootElement
(
)
{
if
(
contentRootElement
&
&
Cu
.
isDeadWrapper
(
contentRootElement
)
)
{
contentRootElement
=
null
;
}
}
var
setTimeoutCallMakeProgressWhenComplete
=
false
;
var
operationInProgress
=
false
;
function
OperationInProgress
(
)
{
if
(
operationInProgress
!
=
false
)
{
LogWarning
(
"
Nesting
atomic
operations
?
"
)
;
}
operationInProgress
=
true
;
}
function
OperationCompleted
(
)
{
if
(
operationInProgress
!
=
true
)
{
LogWarning
(
"
Mismatched
OperationInProgress
/
OperationCompleted
calls
?
"
)
;
}
operationInProgress
=
false
;
if
(
setTimeoutCallMakeProgressWhenComplete
)
{
setTimeoutCallMakeProgressWhenComplete
=
false
;
setTimeout
(
CallMakeProgress
0
)
;
}
}
function
AssertNoOperationInProgress
(
)
{
if
(
operationInProgress
)
{
LogWarning
(
"
AssertNoOperationInProgress
but
operationInProgress
"
)
;
}
}
var
updateCanvasPending
=
false
;
var
updateCanvasRects
=
[
]
;
var
stopAfterPaintReceived
=
false
;
var
currentDoc
=
content
.
document
;
var
state
=
STATE_WAITING_TO_FIRE_INVALIDATE_EVENT
;
var
setTimeoutMakeProgressPending
=
false
;
function
CallSetTimeoutMakeProgress
(
)
{
if
(
setTimeoutMakeProgressPending
)
{
return
;
}
setTimeoutMakeProgressPending
=
true
;
setTimeout
(
CallMakeProgress
0
)
;
}
function
CallMakeProgress
(
)
{
if
(
operationInProgress
)
{
setTimeoutCallMakeProgressWhenComplete
=
true
;
return
;
}
setTimeoutMakeProgressPending
=
false
;
MakeProgress
(
)
;
}
var
waitingForAnAfterPaint
=
false
;
function
HandlePendingTasksAfterMakeProgress
(
)
{
AssertNoOperationInProgress
(
)
;
if
(
(
state
=
=
STATE_WAITING_TO_FIRE_INVALIDATE_EVENT
|
|
state
=
=
STATE_WAITING_TO_FINISH
)
&
&
shouldWaitForPendingPaints
(
)
)
{
LogInfo
(
"
HandlePendingTasksAfterMakeProgress
waiting
for
a
MozAfterPaint
"
)
;
waitingForAnAfterPaint
=
true
;
OperationInProgress
(
)
;
return
;
}
if
(
updateCanvasPending
)
{
LogInfo
(
"
HandlePendingTasksAfterMakeProgress
updating
canvas
"
)
;
updateCanvasPending
=
false
;
let
rects
=
updateCanvasRects
;
updateCanvasRects
=
[
]
;
OperationInProgress
(
)
;
CheckForLivenessOfContentRootElement
(
)
;
let
promise
=
SendUpdateCanvasForEvent
(
forURL
rects
contentRootElement
)
;
promise
.
then
(
function
(
)
{
OperationCompleted
(
)
;
CallSetTimeoutMakeProgress
(
)
;
}
)
;
}
}
function
Contains
(
rectA
rectB
)
{
return
(
rectA
.
left
<
=
rectB
.
left
&
&
rectB
.
right
<
=
rectA
.
right
&
&
rectA
.
top
<
=
rectB
.
top
&
&
rectB
.
bottom
<
=
rectA
.
bottom
)
;
}
function
ContainedIn
(
rectList
rect
)
{
for
(
let
i
=
0
;
i
<
rectList
.
length
;
+
+
i
)
{
if
(
Contains
(
rectList
[
i
]
rect
)
)
{
return
true
;
}
}
return
false
;
}
function
AfterPaintListener
(
event
)
{
LogInfo
(
"
AfterPaintListener
in
"
+
event
.
target
.
document
.
location
.
href
)
;
if
(
event
.
target
.
document
!
=
currentDoc
)
{
return
;
}
updateCanvasPending
=
true
;
for
(
let
r
of
event
.
clientRects
)
{
if
(
ContainedIn
(
updateCanvasRects
r
)
)
{
continue
;
}
updateCanvasRects
.
push
(
{
left
:
r
.
left
top
:
r
.
top
right
:
r
.
right
bottom
:
r
.
bottom
}
)
;
}
if
(
waitingForAnAfterPaint
)
{
waitingForAnAfterPaint
=
false
;
OperationCompleted
(
)
;
}
if
(
!
operationInProgress
)
{
HandlePendingTasksAfterMakeProgress
(
)
;
}
}
function
FromChildAfterPaintListener
(
event
)
{
LogInfo
(
"
FromChildAfterPaintListener
from
"
+
event
.
detail
.
originalTargetUri
)
;
updateCanvasPending
=
true
;
for
(
let
r
of
event
.
detail
.
rects
)
{
if
(
ContainedIn
(
updateCanvasRects
r
)
)
{
continue
;
}
updateCanvasRects
.
push
(
{
left
:
r
.
left
top
:
r
.
top
right
:
r
.
right
bottom
:
r
.
bottom
}
)
;
}
if
(
!
operationInProgress
)
{
HandlePendingTasksAfterMakeProgress
(
)
;
}
}
function
AttrModifiedListener
(
)
{
LogInfo
(
"
AttrModifiedListener
fired
"
)
;
CallSetTimeoutMakeProgress
(
)
;
}
function
ExplicitPaintsCompleteListener
(
)
{
LogInfo
(
"
ExplicitPaintsCompleteListener
fired
"
)
;
CallSetTimeoutMakeProgress
(
)
;
}
function
RemoveListeners
(
)
{
removeEventListener
(
"
MozAfterPaint
"
AfterPaintListener
false
)
;
removeEventListener
(
"
Reftest
:
MozAfterPaintFromChild
"
FromChildAfterPaintListener
false
)
;
CheckForLivenessOfContentRootElement
(
)
;
if
(
contentRootElement
)
{
contentRootElement
.
removeEventListener
(
"
DOMAttrModified
"
AttrModifiedListener
)
;
}
gExplicitPendingPaintsCompleteHook
=
null
;
gTimeoutHook
=
null
;
state
=
STATE_COMPLETED
;
}
function
MakeProgress
(
)
{
if
(
state
>
=
STATE_COMPLETED
)
{
LogInfo
(
"
MakeProgress
:
STATE_COMPLETED
"
)
;
return
;
}
LogInfo
(
"
MakeProgress
"
)
;
OperationInProgress
(
)
;
let
promise
=
Promise
.
resolve
(
undefined
)
;
if
(
state
!
=
STATE_WAITING_TO_FINISH
)
{
flushMode
=
(
state
=
=
=
STATE_WAITING_TO_FIRE_INVALIDATE_EVENT
)
?
FlushMode
.
IGNORE_THROTTLED_ANIMATIONS
:
FlushMode
.
ALL
;
promise
=
FlushRendering
(
flushMode
)
;
}
promise
.
then
(
function
(
)
{
OperationCompleted
(
)
;
MakeProgress2
(
)
;
if
(
!
operationInProgress
)
{
HandlePendingTasksAfterMakeProgress
(
)
;
}
}
)
;
}
function
MakeProgress2
(
)
{
switch
(
state
)
{
case
STATE_WAITING_TO_FIRE_INVALIDATE_EVENT
:
{
LogInfo
(
"
MakeProgress
:
STATE_WAITING_TO_FIRE_INVALIDATE_EVENT
"
)
;
if
(
shouldWaitForExplicitPaintWaiters
(
)
|
|
shouldWaitForPendingPaints
(
)
|
|
updateCanvasPending
)
{
gFailureReason
=
"
timed
out
waiting
for
pending
paint
count
to
reach
zero
"
;
if
(
shouldWaitForExplicitPaintWaiters
(
)
)
{
gFailureReason
+
=
"
(
waiting
for
MozPaintWaitFinished
)
"
;
LogInfo
(
"
MakeProgress
:
waiting
for
MozPaintWaitFinished
"
)
;
}
if
(
shouldWaitForPendingPaints
(
)
)
{
gFailureReason
+
=
"
(
waiting
for
MozAfterPaint
)
"
;
LogInfo
(
"
MakeProgress
:
waiting
for
MozAfterPaint
"
)
;
}
if
(
updateCanvasPending
)
{
gFailureReason
+
=
"
(
waiting
for
updateCanvasPending
)
"
;
LogInfo
(
"
MakeProgress
:
waiting
for
updateCanvasPending
"
)
;
}
return
;
}
state
=
STATE_WAITING_FOR_REFTEST_WAIT_REMOVAL
;
CheckForLivenessOfContentRootElement
(
)
;
var
hasReftestWait
=
shouldWaitForReftestWaitRemoval
(
contentRootElement
)
;
LogInfo
(
"
MakeProgress
:
dispatching
MozReftestInvalidate
"
)
;
if
(
contentRootElement
)
{
var
elements
=
getNoPaintElements
(
contentRootElement
)
;
for
(
var
i
=
0
;
i
<
elements
.
length
;
+
+
i
)
{
windowUtils
(
)
.
checkAndClearPaintedState
(
elements
[
i
]
)
;
}
elements
=
getNoDisplayListElements
(
contentRootElement
)
;
for
(
var
i
=
0
;
i
<
elements
.
length
;
+
+
i
)
{
windowUtils
(
)
.
checkAndClearDisplayListState
(
elements
[
i
]
)
;
}
elements
=
getDisplayListElements
(
contentRootElement
)
;
for
(
var
i
=
0
;
i
<
elements
.
length
;
+
+
i
)
{
windowUtils
(
)
.
checkAndClearDisplayListState
(
elements
[
i
]
)
;
}
var
notification
=
content
.
document
.
createEvent
(
"
Events
"
)
;
notification
.
initEvent
(
"
MozReftestInvalidate
"
true
false
)
;
contentRootElement
.
dispatchEvent
(
notification
)
;
}
if
(
!
inPrintMode
&
&
doPrintMode
(
contentRootElement
)
)
{
LogInfo
(
"
MakeProgress
:
setting
up
print
mode
"
)
;
setupPrintMode
(
)
;
}
if
(
hasReftestWait
&
&
!
shouldWaitForReftestWaitRemoval
(
contentRootElement
)
)
{
OperationInProgress
(
)
;
let
promise
=
FlushRendering
(
FlushMode
.
ALL
)
;
promise
.
then
(
function
(
)
{
OperationCompleted
(
)
;
if
(
!
updateCanvasPending
&
&
!
shouldWaitForPendingPaints
(
)
&
&
!
shouldWaitForExplicitPaintWaiters
(
)
)
{
LogWarning
(
"
MozInvalidateEvent
didn
'
t
invalidate
"
)
;
}
MakeProgress
(
)
;
}
)
;
return
;
}
MakeProgress
(
)
;
return
;
}
case
STATE_WAITING_FOR_REFTEST_WAIT_REMOVAL
:
LogInfo
(
"
MakeProgress
:
STATE_WAITING_FOR_REFTEST_WAIT_REMOVAL
"
)
;
CheckForLivenessOfContentRootElement
(
)
;
if
(
shouldWaitForReftestWaitRemoval
(
contentRootElement
)
)
{
gFailureReason
=
"
timed
out
waiting
for
reftest
-
wait
to
be
removed
"
;
LogInfo
(
"
MakeProgress
:
waiting
for
reftest
-
wait
to
be
removed
"
)
;
return
;
}
state
=
STATE_WAITING_FOR_SPELL_CHECKS
;
MakeProgress
(
)
;
return
;
case
STATE_WAITING_FOR_SPELL_CHECKS
:
LogInfo
(
"
MakeProgress
:
STATE_WAITING_FOR_SPELL_CHECKS
"
)
;
if
(
numPendingSpellChecks
)
{
gFailureReason
=
"
timed
out
waiting
for
spell
checks
to
end
"
;
LogInfo
(
"
MakeProgress
:
waiting
for
spell
checks
to
end
"
)
;
return
;
}
state
=
STATE_WAITING_FOR_APZ_FLUSH
;
LogInfo
(
"
MakeProgress
:
STATE_WAITING_FOR_APZ_FLUSH
"
)
;
gFailureReason
=
"
timed
out
waiting
for
APZ
flush
to
complete
"
;
var
os
=
Cc
[
NS_OBSERVER_SERVICE_CONTRACTID
]
.
getService
(
Ci
.
nsIObserverService
)
;
var
flushWaiter
=
function
(
aSubject
aTopic
aData
)
{
if
(
aTopic
)
LogInfo
(
"
MakeProgress
:
apz
-
repaints
-
flushed
fired
"
)
;
os
.
removeObserver
(
flushWaiter
"
apz
-
repaints
-
flushed
"
)
;
state
=
STATE_WAITING_TO_FINISH
;
if
(
operationInProgress
)
{
CallSetTimeoutMakeProgress
(
)
;
}
else
{
MakeProgress
(
)
;
}
}
;
os
.
addObserver
(
flushWaiter
"
apz
-
repaints
-
flushed
"
)
;
var
willSnapshot
=
IsSnapshottableTestType
(
)
;
CheckForLivenessOfContentRootElement
(
)
;
var
noFlush
=
!
(
contentRootElement
&
&
contentRootElement
.
classList
.
contains
(
"
reftest
-
no
-
flush
"
)
)
;
if
(
noFlush
&
&
willSnapshot
&
&
windowUtils
(
)
.
flushApzRepaints
(
)
)
{
LogInfo
(
"
MakeProgress
:
done
requesting
APZ
flush
"
)
;
}
else
{
LogInfo
(
"
MakeProgress
:
APZ
flush
not
required
"
)
;
flushWaiter
(
null
null
null
)
;
}
return
;
case
STATE_WAITING_FOR_APZ_FLUSH
:
LogInfo
(
"
MakeProgress
:
STATE_WAITING_FOR_APZ_FLUSH
"
)
;
return
;
case
STATE_WAITING_TO_FINISH
:
LogInfo
(
"
MakeProgress
:
STATE_WAITING_TO_FINISH
"
)
;
if
(
shouldWaitForExplicitPaintWaiters
(
)
|
|
shouldWaitForPendingPaints
(
)
|
|
updateCanvasPending
)
{
gFailureReason
=
"
timed
out
waiting
for
pending
paint
count
to
"
+
"
reach
zero
(
after
reftest
-
wait
removed
and
switch
to
print
mode
)
"
;
if
(
shouldWaitForExplicitPaintWaiters
(
)
)
{
gFailureReason
+
=
"
(
waiting
for
MozPaintWaitFinished
)
"
;
LogInfo
(
"
MakeProgress
:
waiting
for
MozPaintWaitFinished
"
)
;
}
if
(
shouldWaitForPendingPaints
(
)
)
{
gFailureReason
+
=
"
(
waiting
for
MozAfterPaint
)
"
;
LogInfo
(
"
MakeProgress
:
waiting
for
MozAfterPaint
"
)
;
}
if
(
updateCanvasPending
)
{
gFailureReason
+
=
"
(
waiting
for
updateCanvasPending
)
"
;
LogInfo
(
"
MakeProgress
:
waiting
for
updateCanvasPending
"
)
;
}
return
;
}
CheckForLivenessOfContentRootElement
(
)
;
if
(
contentRootElement
)
{
var
elements
=
getNoPaintElements
(
contentRootElement
)
;
for
(
var
i
=
0
;
i
<
elements
.
length
;
+
+
i
)
{
if
(
windowUtils
(
)
.
checkAndClearPaintedState
(
elements
[
i
]
)
)
{
SendFailedNoPaint
(
)
;
}
}
if
(
gBrowserIsRemote
)
{
elements
=
getNoDisplayListElements
(
contentRootElement
)
;
for
(
var
i
=
0
;
i
<
elements
.
length
;
+
+
i
)
{
if
(
windowUtils
(
)
.
checkAndClearDisplayListState
(
elements
[
i
]
)
)
{
SendFailedNoDisplayList
(
)
;
}
}
elements
=
getDisplayListElements
(
contentRootElement
)
;
for
(
var
i
=
0
;
i
<
elements
.
length
;
+
+
i
)
{
if
(
!
windowUtils
(
)
.
checkAndClearDisplayListState
(
elements
[
i
]
)
)
{
SendFailedDisplayList
(
)
;
}
}
}
CheckLayerAssertions
(
contentRootElement
)
;
}
if
(
!
IsSnapshottableTestType
(
)
)
{
LogInfo
(
"
MakeProgress
:
Doing
sync
flush
to
compositor
"
)
;
gFailureReason
=
"
timed
out
while
waiting
for
sync
compositor
flush
"
windowUtils
(
)
.
syncFlushCompositor
(
)
;
}
LogInfo
(
"
MakeProgress
:
Completed
"
)
;
state
=
STATE_COMPLETED
;
gFailureReason
=
"
timed
out
while
taking
snapshot
(
bug
in
harness
?
)
"
;
RemoveListeners
(
)
;
CheckForLivenessOfContentRootElement
(
)
;
CheckForProcessCrashExpectation
(
contentRootElement
)
;
setTimeout
(
RecordResult
0
forURL
)
;
return
;
}
}
LogInfo
(
"
WaitForTestEnd
:
Adding
listeners
"
)
;
addEventListener
(
"
MozAfterPaint
"
AfterPaintListener
false
)
;
addEventListener
(
"
Reftest
:
MozAfterPaintFromChild
"
FromChildAfterPaintListener
false
)
;
CheckForLivenessOfContentRootElement
(
)
;
if
(
contentRootElement
)
{
contentRootElement
.
addEventListener
(
"
DOMAttrModified
"
AttrModifiedListener
)
;
}
gExplicitPendingPaintsCompleteHook
=
ExplicitPaintsCompleteListener
;
gTimeoutHook
=
RemoveListeners
;
var
numPendingSpellChecks
=
spellCheckedElements
.
length
;
function
decNumPendingSpellChecks
(
)
{
-
-
numPendingSpellChecks
;
if
(
operationInProgress
)
{
CallSetTimeoutMakeProgress
(
)
;
}
else
{
MakeProgress
(
)
;
}
}
for
(
let
editable
of
spellCheckedElements
)
{
try
{
onSpellCheck
(
editable
decNumPendingSpellChecks
)
;
}
catch
(
err
)
{
setTimeout
(
decNumPendingSpellChecks
0
)
;
}
}
OperationInProgress
(
)
;
let
promise
=
SendInitCanvasWithSnapshot
(
forURL
)
;
promise
.
then
(
function
(
)
{
OperationCompleted
(
)
;
MakeProgress
(
)
;
}
)
;
}
function
OnDocumentLoad
(
uri
)
{
if
(
gClearingForAssertionCheck
)
{
if
(
uri
=
=
BLANK_URL_FOR_CLEARING
)
{
DoAssertionCheck
(
)
;
return
;
}
LogInfo
(
"
Retry
loading
a
blank
page
"
)
;
setTimeout
(
LoadURI
0
BLANK_URL_FOR_CLEARING
)
;
return
;
}
if
(
uri
!
=
gCurrentURL
)
{
LogInfo
(
"
OnDocumentLoad
fired
for
previous
document
"
)
;
return
;
}
var
currentDoc
=
content
&
&
content
.
document
;
var
querySelector
=
'
*
[
class
~
=
"
spell
-
checked
"
]
'
+
'
textarea
:
not
(
[
spellcheck
=
"
false
"
]
)
'
+
'
input
[
spellcheck
]
:
-
moz
-
any
(
[
spellcheck
=
"
"
]
[
spellcheck
=
"
true
"
]
)
'
+
'
*
[
contenteditable
]
:
-
moz
-
any
(
[
contenteditable
=
"
"
]
[
contenteditable
=
"
true
"
]
)
'
;
var
spellCheckedElements
=
currentDoc
?
currentDoc
.
querySelectorAll
(
querySelector
)
:
[
]
;
var
contentRootElement
=
currentDoc
?
currentDoc
.
documentElement
:
null
;
currentDoc
=
null
;
setupFullZoom
(
contentRootElement
)
;
setupTextZoom
(
contentRootElement
)
;
setupViewport
(
contentRootElement
)
;
setupDisplayport
(
contentRootElement
)
;
var
inPrintMode
=
false
;
async
function
AfterOnLoadScripts
(
)
{
var
contentRootElement
=
content
.
document
?
content
.
document
.
documentElement
:
null
;
var
paintWaiterFinished
=
false
;
gExplicitPendingPaintsCompleteHook
=
function
(
)
{
LogInfo
(
"
PaintWaiters
finished
while
we
were
sending
initial
snapshop
in
AfterOnLoadScripts
"
)
;
paintWaiterFinished
=
true
;
}
await
FlushRendering
(
FlushMode
.
ALL
)
;
let
painted
=
await
SendInitCanvasWithSnapshot
(
uri
)
;
gExplicitPendingPaintsCompleteHook
=
null
;
if
(
contentRootElement
&
&
Cu
.
isDeadWrapper
(
contentRootElement
)
)
{
contentRootElement
=
null
;
}
if
(
paintWaiterFinished
|
|
shouldWaitForExplicitPaintWaiters
(
)
|
|
(
!
inPrintMode
&
&
doPrintMode
(
contentRootElement
)
)
|
|
!
painted
)
{
LogInfo
(
"
AfterOnLoadScripts
belatedly
entering
WaitForTestEnd
"
)
;
WaitForTestEnd
(
contentRootElement
inPrintMode
[
]
uri
)
;
}
else
{
CheckLayerAssertions
(
contentRootElement
)
;
CheckForProcessCrashExpectation
(
contentRootElement
)
;
RecordResult
(
uri
)
;
}
}
if
(
shouldWaitForReftestWaitRemoval
(
contentRootElement
)
|
|
shouldWaitForExplicitPaintWaiters
(
)
|
|
spellCheckedElements
.
length
)
{
gFailureReason
=
"
timed
out
waiting
for
test
to
complete
(
trying
to
get
into
WaitForTestEnd
)
"
;
LogInfo
(
"
OnDocumentLoad
triggering
WaitForTestEnd
"
)
;
setTimeout
(
function
(
)
{
WaitForTestEnd
(
contentRootElement
inPrintMode
spellCheckedElements
uri
)
;
}
0
)
;
}
else
{
if
(
doPrintMode
(
contentRootElement
)
)
{
LogInfo
(
"
OnDocumentLoad
setting
up
print
mode
"
)
;
setupPrintMode
(
)
;
inPrintMode
=
true
;
}
gFailureReason
=
"
timed
out
waiting
for
test
to
complete
(
waiting
for
onload
scripts
to
complete
)
"
;
LogInfo
(
"
OnDocumentLoad
triggering
AfterOnLoadScripts
"
)
;
setTimeout
(
function
(
)
{
setTimeout
(
AfterOnLoadScripts
0
)
;
}
0
)
;
}
}
function
CheckLayerAssertions
(
contentRootElement
)
{
if
(
!
contentRootElement
)
{
return
;
}
if
(
gIsWebRenderEnabled
)
{
return
;
}
var
opaqueLayerElements
=
getOpaqueLayerElements
(
contentRootElement
)
;
for
(
var
i
=
0
;
i
<
opaqueLayerElements
.
length
;
+
+
i
)
{
var
elem
=
opaqueLayerElements
[
i
]
;
try
{
if
(
!
windowUtils
(
)
.
isPartOfOpaqueLayer
(
elem
)
)
{
SendFailedOpaqueLayer
(
elementDescription
(
elem
)
+
'
is
not
part
of
an
opaque
layer
'
)
;
}
}
catch
(
e
)
{
SendFailedOpaqueLayer
(
'
got
an
exception
while
checking
whether
'
+
elementDescription
(
elem
)
+
'
is
part
of
an
opaque
layer
'
)
;
}
}
var
layerNameToElementsMap
=
getAssignedLayerMap
(
contentRootElement
)
;
var
oneOfEach
=
[
]
;
for
(
var
layerName
in
layerNameToElementsMap
)
{
try
{
var
elements
=
layerNameToElementsMap
[
layerName
]
;
oneOfEach
.
push
(
elements
[
0
]
)
;
var
numberOfLayers
=
windowUtils
(
)
.
numberOfAssignedPaintedLayers
(
elements
)
;
if
(
numberOfLayers
!
=
=
1
)
{
SendFailedAssignedLayer
(
'
these
elements
are
assigned
to
'
+
numberOfLayers
+
'
different
layers
instead
of
sharing
just
one
layer
:
'
+
elements
.
map
(
elementDescription
)
.
join
(
'
'
)
)
;
}
}
catch
(
e
)
{
SendFailedAssignedLayer
(
'
got
an
exception
while
checking
whether
these
elements
share
a
layer
:
'
+
elements
.
map
(
elementDescription
)
.
join
(
'
'
)
)
;
}
}
if
(
oneOfEach
.
length
>
0
)
{
try
{
var
numberOfLayers
=
windowUtils
(
)
.
numberOfAssignedPaintedLayers
(
oneOfEach
)
;
if
(
numberOfLayers
!
=
=
oneOfEach
.
length
)
{
SendFailedAssignedLayer
(
'
these
elements
are
assigned
to
'
+
numberOfLayers
+
'
different
layers
instead
of
having
none
in
common
(
expected
'
+
oneOfEach
.
length
+
'
different
layers
)
:
'
+
oneOfEach
.
map
(
elementDescription
)
.
join
(
'
'
)
)
;
}
}
catch
(
e
)
{
SendFailedAssignedLayer
(
'
got
an
exception
while
checking
whether
these
elements
are
assigned
to
different
layers
:
'
+
oneOfEach
.
map
(
elementDescription
)
.
join
(
'
'
)
)
;
}
}
}
function
CheckForProcessCrashExpectation
(
contentRootElement
)
{
if
(
contentRootElement
&
&
contentRootElement
.
hasAttribute
(
'
class
'
)
&
&
contentRootElement
.
getAttribute
(
'
class
'
)
.
split
(
/
\
s
+
/
)
.
includes
(
"
reftest
-
expect
-
process
-
crash
"
)
)
{
SendExpectProcessCrash
(
)
;
}
}
function
RecordResult
(
forURL
)
{
if
(
forURL
!
=
gCurrentURL
)
{
LogInfo
(
"
RecordResult
fired
for
previous
document
"
)
;
return
;
}
if
(
gCurrentURLRecordResults
>
0
)
{
LogInfo
(
"
RecordResult
fired
extra
times
"
)
;
FinishTestItem
(
)
;
return
;
}
gCurrentURLRecordResults
+
+
;
LogInfo
(
"
RecordResult
fired
"
)
;
var
currentTestRunTime
=
Date
.
now
(
)
-
gCurrentTestStartTime
;
clearTimeout
(
gFailureTimeout
)
;
gFailureReason
=
null
;
gFailureTimeout
=
null
;
gCurrentURL
=
null
;
gCurrentURLTargetType
=
undefined
;
if
(
gCurrentTestType
=
=
TYPE_PRINT
)
{
printToPdf
(
function
(
status
fileName
)
{
SendPrintResult
(
currentTestRunTime
status
fileName
)
;
FinishTestItem
(
)
;
}
)
;
return
;
}
if
(
gCurrentTestType
=
=
TYPE_SCRIPT
)
{
var
error
=
'
'
;
var
testwindow
=
content
;
if
(
testwindow
.
wrappedJSObject
)
testwindow
=
testwindow
.
wrappedJSObject
;
var
testcases
;
if
(
!
testwindow
.
getTestCases
|
|
typeof
testwindow
.
getTestCases
!
=
"
function
"
)
{
error
=
"
test
must
provide
a
function
getTestCases
(
)
.
(
SCRIPT
)
\
n
"
;
}
else
if
(
!
(
testcases
=
testwindow
.
getTestCases
(
)
)
)
{
error
=
"
test
'
s
getTestCases
(
)
must
return
an
Array
-
like
Object
.
(
SCRIPT
)
\
n
"
;
}
else
if
(
testcases
.
length
=
=
0
)
{
}
var
results
=
[
]
;
if
(
!
error
)
{
for
(
var
i
=
0
;
i
<
testcases
.
length
;
+
+
i
)
{
var
test
=
testcases
[
i
]
;
results
.
push
(
{
passed
:
test
.
testPassed
(
)
description
:
test
.
testDescription
(
)
}
)
;
}
}
SendScriptResults
(
currentTestRunTime
error
results
)
;
FinishTestItem
(
)
;
return
;
}
var
changedAsyncScrollZoom
=
false
;
if
(
setupAsyncScrollOffsets
(
{
allowFailure
:
true
}
)
)
{
changedAsyncScrollZoom
=
true
;
}
if
(
setupAsyncZoom
(
{
allowFailure
:
true
}
)
)
{
changedAsyncScrollZoom
=
true
;
}
if
(
changedAsyncScrollZoom
&
&
!
gBrowserIsRemote
)
{
sendAsyncMessage
(
"
reftest
:
UpdateWholeCanvasForInvalidation
"
)
;
}
SendTestDone
(
currentTestRunTime
)
;
FinishTestItem
(
)
;
}
function
LoadFailed
(
)
{
if
(
gTimeoutHook
)
{
gTimeoutHook
(
)
;
}
gFailureTimeout
=
null
;
SendFailedLoad
(
gFailureReason
)
;
}
function
FinishTestItem
(
)
{
gHaveCanvasSnapshot
=
false
;
}
function
DoAssertionCheck
(
)
{
gClearingForAssertionCheck
=
false
;
var
numAsserts
=
0
;
if
(
gDebug
.
isDebugBuild
)
{
var
newAssertionCount
=
gDebug
.
assertionCount
;
numAsserts
=
newAssertionCount
-
gAssertionCount
;
gAssertionCount
=
newAssertionCount
;
}
SendAssertionCount
(
numAsserts
)
;
}
function
LoadURI
(
uri
)
{
let
loadURIOptions
=
{
triggeringPrincipal
:
Services
.
scriptSecurityManager
.
getSystemPrincipal
(
)
}
;
webNavigation
(
)
.
loadURI
(
uri
loadURIOptions
)
;
}
function
LogError
(
str
)
{
if
(
gVerbose
)
{
sendSyncMessage
(
"
reftest
:
Log
"
{
type
:
"
error
"
msg
:
str
}
)
;
}
else
{
sendAsyncMessage
(
"
reftest
:
Log
"
{
type
:
"
error
"
msg
:
str
}
)
;
}
}
function
LogWarning
(
str
)
{
if
(
gVerbose
)
{
sendSyncMessage
(
"
reftest
:
Log
"
{
type
:
"
warning
"
msg
:
str
}
)
;
}
else
{
sendAsyncMessage
(
"
reftest
:
Log
"
{
type
:
"
warning
"
msg
:
str
}
)
;
}
}
function
LogInfo
(
str
)
{
if
(
gVerbose
)
{
sendSyncMessage
(
"
reftest
:
Log
"
{
type
:
"
info
"
msg
:
str
}
)
;
}
else
{
sendAsyncMessage
(
"
reftest
:
Log
"
{
type
:
"
info
"
msg
:
str
}
)
;
}
}
function
IsSnapshottableTestType
(
)
{
return
!
(
gCurrentTestType
=
=
TYPE_SCRIPT
|
|
gCurrentTestType
=
=
TYPE_LOAD
|
|
gCurrentTestType
=
=
TYPE_PRINT
)
;
}
const
SYNC_DEFAULT
=
0x0
;
const
SYNC_ALLOW_DISABLE
=
0x1
;
function
SynchronizeForSnapshot
(
flags
)
{
if
(
!
IsSnapshottableTestType
(
)
)
{
return
Promise
.
resolve
(
undefined
)
;
}
if
(
flags
&
SYNC_ALLOW_DISABLE
)
{
var
docElt
=
content
.
document
.
documentElement
;
if
(
docElt
&
&
(
docElt
.
hasAttribute
(
"
reftest
-
no
-
sync
-
layers
"
)
|
|
docElt
.
classList
.
contains
(
"
reftest
-
no
-
flush
"
)
)
)
{
LogInfo
(
"
Test
file
chose
to
skip
SynchronizeForSnapshot
"
)
;
return
Promise
.
resolve
(
undefined
)
;
}
}
let
browsingContext
=
content
.
docShell
.
browsingContext
;
let
promise
=
content
.
windowGlobalChild
.
getActor
(
"
ReftestFission
"
)
.
sendQuery
(
"
UpdateLayerTree
"
{
browsingContext
}
)
;
return
promise
.
then
(
function
(
result
)
{
for
(
let
errorString
of
result
.
errorStrings
)
{
LogError
(
errorString
)
;
}
for
(
let
infoString
of
result
.
infoStrings
)
{
LogInfo
(
infoString
)
;
}
setupAsyncScrollOffsets
(
{
allowFailure
:
false
}
)
;
setupAsyncZoom
(
{
allowFailure
:
false
}
)
;
}
function
(
reason
)
{
LogInfo
(
"
UpdateLayerTree
sendQuery
to
parent
rejected
:
"
+
reason
)
;
setupAsyncScrollOffsets
(
{
allowFailure
:
false
}
)
;
setupAsyncZoom
(
{
allowFailure
:
false
}
)
;
}
)
;
}
function
RegisterMessageListeners
(
)
{
addMessageListener
(
"
reftest
:
Clear
"
function
(
m
)
{
RecvClear
(
)
}
)
;
addMessageListener
(
"
reftest
:
LoadScriptTest
"
function
(
m
)
{
RecvLoadScriptTest
(
m
.
json
.
uri
m
.
json
.
timeout
)
;
}
)
;
addMessageListener
(
"
reftest
:
LoadPrintTest
"
function
(
m
)
{
RecvLoadPrintTest
(
m
.
json
.
uri
m
.
json
.
timeout
)
;
}
)
;
addMessageListener
(
"
reftest
:
LoadTest
"
function
(
m
)
{
RecvLoadTest
(
m
.
json
.
type
m
.
json
.
uri
m
.
json
.
uriTargetType
m
.
json
.
timeout
)
;
}
)
;
addMessageListener
(
"
reftest
:
ResetRenderingState
"
function
(
m
)
{
RecvResetRenderingState
(
)
;
}
)
;
}
function
RecvClear
(
)
{
gClearingForAssertionCheck
=
true
;
LoadURI
(
BLANK_URL_FOR_CLEARING
)
;
}
function
RecvLoadTest
(
type
uri
uriTargetType
timeout
)
{
StartTestURI
(
type
uri
uriTargetType
timeout
)
;
}
function
RecvLoadScriptTest
(
uri
timeout
)
{
StartTestURI
(
TYPE_SCRIPT
uri
URL_TARGET_TYPE_TEST
timeout
)
;
}
function
RecvLoadPrintTest
(
uri
timeout
)
{
StartTestURI
(
TYPE_PRINT
uri
URL_TARGET_TYPE_TEST
timeout
)
;
}
function
RecvResetRenderingState
(
)
{
resetZoomAndTextZoom
(
)
;
resetDisplayportAndViewport
(
)
;
}
function
SendAssertionCount
(
numAssertions
)
{
sendAsyncMessage
(
"
reftest
:
AssertionCount
"
{
count
:
numAssertions
}
)
;
}
function
SendContentReady
(
)
{
let
gfxInfo
=
(
NS_GFXINFO_CONTRACTID
in
Cc
)
&
&
Cc
[
NS_GFXINFO_CONTRACTID
]
.
getService
(
Ci
.
nsIGfxInfo
)
;
let
info
=
gfxInfo
.
getInfo
(
)
;
try
{
gIsWebRenderEnabled
=
gfxInfo
.
WebRenderEnabled
;
}
catch
(
e
)
{
gIsWebRenderEnabled
=
false
;
}
try
{
info
.
D2DEnabled
=
gfxInfo
.
D2DEnabled
;
info
.
DWriteEnabled
=
gfxInfo
.
DWriteEnabled
;
}
catch
(
e
)
{
info
.
D2DEnabled
=
false
;
info
.
DWriteEnabled
=
false
;
}
return
sendSyncMessage
(
"
reftest
:
ContentReady
"
{
'
gfx
'
:
info
}
)
[
0
]
;
}
function
SendException
(
what
)
{
sendAsyncMessage
(
"
reftest
:
Exception
"
{
what
:
what
}
)
;
}
function
SendFailedLoad
(
why
)
{
sendAsyncMessage
(
"
reftest
:
FailedLoad
"
{
why
:
why
}
)
;
}
function
SendFailedNoPaint
(
)
{
sendAsyncMessage
(
"
reftest
:
FailedNoPaint
"
)
;
}
function
SendFailedNoDisplayList
(
)
{
sendAsyncMessage
(
"
reftest
:
FailedNoDisplayList
"
)
;
}
function
SendFailedDisplayList
(
)
{
sendAsyncMessage
(
"
reftest
:
FailedDisplayList
"
)
;
}
function
SendFailedOpaqueLayer
(
why
)
{
sendAsyncMessage
(
"
reftest
:
FailedOpaqueLayer
"
{
why
:
why
}
)
;
}
function
SendFailedAssignedLayer
(
why
)
{
sendAsyncMessage
(
"
reftest
:
FailedAssignedLayer
"
{
why
:
why
}
)
;
}
function
SendInitCanvasWithSnapshot
(
forURL
)
{
if
(
forURL
!
=
gCurrentURL
)
{
LogInfo
(
"
SendInitCanvasWithSnapshot
called
for
previous
document
"
)
;
return
Promise
.
resolve
(
true
)
;
}
if
(
gBrowserIsRemote
)
{
let
promise
=
SynchronizeForSnapshot
(
SYNC_DEFAULT
)
;
return
promise
.
then
(
function
(
)
{
let
ret
=
sendSyncMessage
(
"
reftest
:
InitCanvasWithSnapshot
"
)
[
0
]
;
gHaveCanvasSnapshot
=
ret
.
painted
;
return
ret
.
painted
;
}
)
;
}
let
ret
=
sendSyncMessage
(
"
reftest
:
InitCanvasWithSnapshot
"
)
[
0
]
;
gHaveCanvasSnapshot
=
ret
.
painted
;
return
Promise
.
resolve
(
ret
.
painted
)
;
}
function
SendScriptResults
(
runtimeMs
error
results
)
{
sendAsyncMessage
(
"
reftest
:
ScriptResults
"
{
runtimeMs
:
runtimeMs
error
:
error
results
:
results
}
)
;
}
function
SendPrintResult
(
runtimeMs
status
fileName
)
{
sendAsyncMessage
(
"
reftest
:
PrintResult
"
{
runtimeMs
:
runtimeMs
status
:
status
fileName
:
fileName
}
)
;
}
function
SendExpectProcessCrash
(
runtimeMs
)
{
sendAsyncMessage
(
"
reftest
:
ExpectProcessCrash
"
)
;
}
function
SendTestDone
(
runtimeMs
)
{
sendAsyncMessage
(
"
reftest
:
TestDone
"
{
runtimeMs
:
runtimeMs
}
)
;
}
function
roundTo
(
x
fraction
)
{
return
Math
.
round
(
x
/
fraction
)
*
fraction
;
}
function
elementDescription
(
element
)
{
return
'
<
'
+
element
.
localName
+
[
]
.
slice
.
call
(
element
.
attributes
)
.
map
(
(
attr
)
=
>
{
attr
.
nodeName
}
=
"
{
attr
.
value
}
"
)
.
join
(
'
'
)
+
'
>
'
;
}
function
SendUpdateCanvasForEvent
(
forURL
rectList
contentRootElement
)
{
if
(
forURL
!
=
gCurrentURL
)
{
LogInfo
(
"
SendUpdateCanvasForEvent
called
for
previous
document
"
)
;
return
Promise
.
resolve
(
undefined
)
;
}
var
win
=
content
;
var
scale
=
docShell
.
browsingContext
.
fullZoom
;
var
rects
=
[
]
;
if
(
shouldSnapshotWholePage
(
contentRootElement
)
)
{
if
(
!
gBrowserIsRemote
)
{
sendSyncMessage
(
"
reftest
:
UpdateWholeCanvasForInvalidation
"
)
;
}
else
{
let
promise
=
SynchronizeForSnapshot
(
SYNC_ALLOW_DISABLE
)
;
return
promise
.
then
(
function
(
)
{
sendAsyncMessage
(
"
reftest
:
UpdateWholeCanvasForInvalidation
"
)
;
}
)
;
}
return
Promise
.
resolve
(
undefined
)
;
}
var
message
;
if
(
gIsWebRenderEnabled
&
&
!
windowUtils
(
)
.
isMozAfterPaintPending
)
{
LogInfo
(
"
Webrender
enabled
sending
update
whole
canvas
for
invalidation
"
)
;
message
=
"
reftest
:
UpdateWholeCanvasForInvalidation
"
;
}
else
{
LogInfo
(
"
SendUpdateCanvasForEvent
with
"
+
rectList
.
length
+
"
rects
"
)
;
for
(
var
i
=
0
;
i
<
rectList
.
length
;
+
+
i
)
{
var
r
=
rectList
[
i
]
;
var
left
=
Math
.
floor
(
roundTo
(
r
.
left
*
scale
0
.
001
)
)
;
var
top
=
Math
.
floor
(
roundTo
(
r
.
top
*
scale
0
.
001
)
)
;
var
right
=
Math
.
ceil
(
roundTo
(
r
.
right
*
scale
0
.
001
)
)
;
var
bottom
=
Math
.
ceil
(
roundTo
(
r
.
bottom
*
scale
0
.
001
)
)
;
LogInfo
(
"
Rect
:
"
+
left
+
"
"
+
top
+
"
"
+
right
+
"
"
+
bottom
)
;
rects
.
push
(
{
left
:
left
top
:
top
right
:
right
bottom
:
bottom
}
)
;
}
message
=
"
reftest
:
UpdateCanvasForInvalidation
"
;
}
if
(
!
gBrowserIsRemote
)
{
sendSyncMessage
(
message
{
rects
:
rects
}
)
;
}
else
{
let
promise
=
SynchronizeForSnapshot
(
SYNC_ALLOW_DISABLE
)
;
return
promise
.
then
(
function
(
)
{
sendAsyncMessage
(
message
{
rects
:
rects
}
)
;
}
)
;
}
return
Promise
.
resolve
(
undefined
)
;
}
if
(
content
.
document
.
readyState
=
=
"
complete
"
)
{
OnInitialLoad
(
)
;
}
else
{
addEventListener
(
"
load
"
OnInitialLoad
true
)
;
}
