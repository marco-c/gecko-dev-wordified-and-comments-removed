var
EXPORTED_SYMBOLS
=
[
"
ReftestFissionParent
"
]
;
class
ReftestFissionParent
extends
JSWindowActorParent
{
tellChildrenToFlushRendering
(
browsingContext
ignoreThrottledAnimations
)
{
let
promises
=
[
]
;
this
.
tellChildrenToFlushRenderingRecursive
(
browsingContext
ignoreThrottledAnimations
promises
)
;
return
Promise
.
allSettled
(
promises
)
;
}
tellChildrenToFlushRenderingRecursive
(
browsingContext
ignoreThrottledAnimations
promises
)
{
let
cwg
=
browsingContext
.
currentWindowGlobal
;
if
(
cwg
&
&
cwg
.
isProcessRoot
)
{
let
a
=
cwg
.
getActor
(
"
ReftestFission
"
)
;
if
(
a
)
{
let
responsePromise
=
a
.
sendQuery
(
"
FlushRendering
"
{
ignoreThrottledAnimations
}
)
;
promises
.
push
(
responsePromise
)
;
}
}
for
(
let
context
of
browsingContext
.
children
)
{
this
.
tellChildrenToFlushRenderingRecursive
(
context
ignoreThrottledAnimations
promises
)
;
}
}
getNearestProcessRootProperDescendants
(
browsingContext
)
{
let
result
=
[
]
;
for
(
let
context
of
browsingContext
.
children
)
{
this
.
getNearestProcessRootProperDescendantsRecursive
(
context
result
)
;
}
return
result
;
}
getNearestProcessRootProperDescendantsRecursive
(
browsingContext
result
)
{
let
cwg
=
browsingContext
.
currentWindowGlobal
;
if
(
cwg
&
&
cwg
.
isProcessRoot
)
{
result
.
push
(
browsingContext
)
;
return
;
}
for
(
let
context
of
browsingContext
.
children
)
{
this
.
getNearestProcessRootProperDescendantsRecursive
(
context
result
)
;
}
}
async
tellChildrenToUpdateLayerTree
(
browsingContext
)
{
let
errorStrings
=
[
]
;
let
infoStrings
=
[
]
;
let
cwg
=
browsingContext
.
currentWindowGlobal
;
if
(
!
cwg
|
|
!
cwg
.
isProcessRoot
)
{
if
(
cwg
)
{
errorStrings
.
push
(
"
tellChildrenToUpdateLayerTree
called
on
a
non
process
root
?
"
)
;
}
return
{
errorStrings
infoStrings
}
;
}
let
actor
=
cwg
.
getActor
(
"
ReftestFission
"
)
;
if
(
!
actor
)
{
return
{
errorStrings
infoStrings
}
;
}
try
{
let
result
=
await
actor
.
sendQuery
(
"
UpdateLayerTree
"
)
;
errorStrings
.
push
(
.
.
.
result
.
errorStrings
)
;
}
catch
(
e
)
{
infoStrings
.
push
(
"
tellChildrenToUpdateLayerTree
UpdateLayerTree
msg
to
child
rejected
:
"
+
e
)
;
}
let
descendants
=
actor
.
getNearestProcessRootProperDescendants
(
browsingContext
)
;
for
(
let
context
of
descendants
)
{
let
cwg2
=
context
.
currentWindowGlobal
;
if
(
cwg2
)
{
if
(
!
cwg2
.
isProcessRoot
)
{
errorStrings
.
push
(
"
getNearestProcessRootProperDescendants
returned
a
non
process
root
?
"
)
;
}
let
actor2
=
cwg2
.
getActor
(
"
ReftestFission
"
)
;
if
(
actor2
)
{
try
{
await
actor2
.
sendQuery
(
"
EmptyMessage
"
)
;
}
catch
(
e
)
{
infoStrings
.
push
(
"
tellChildrenToUpdateLayerTree
EmptyMessage
msg
to
child
rejected
:
"
+
e
)
;
}
try
{
let
result2
=
await
actor2
.
tellChildrenToUpdateLayerTree
(
context
)
;
errorStrings
.
push
(
.
.
.
result2
.
errorStrings
)
;
infoStrings
.
push
(
.
.
.
result2
.
infoStrings
)
;
}
catch
(
e
)
{
errorStrings
.
push
(
"
tellChildrenToUpdateLayerTree
recursive
tellChildrenToUpdateLayerTree
call
rejected
:
"
+
e
)
;
}
}
}
}
return
{
errorStrings
infoStrings
}
;
}
receiveMessage
(
msg
)
{
switch
(
msg
.
name
)
{
case
"
FlushRendering
"
:
{
let
promise
=
this
.
tellChildrenToFlushRendering
(
msg
.
data
.
browsingContext
msg
.
data
.
ignoreThrottledAnimations
)
;
return
promise
.
then
(
function
(
results
)
{
let
errorStrings
=
[
]
;
let
warningStrings
=
[
]
;
let
infoStrings
=
[
]
;
for
(
let
r
of
results
)
{
if
(
r
.
status
!
=
"
fulfilled
"
)
{
if
(
r
.
status
=
=
"
pending
"
)
{
errorStrings
.
push
(
"
FlushRendering
sendQuery
to
child
promise
still
pending
?
"
)
;
}
else
{
infoStrings
.
push
(
"
FlushRendering
sendQuery
to
child
promise
rejected
:
"
+
r
.
reason
)
;
}
continue
;
}
errorStrings
.
concat
(
r
.
value
.
errorStrings
)
;
warningStrings
.
concat
(
r
.
value
.
warningStrings
)
;
infoStrings
.
concat
(
r
.
value
.
infoStrings
)
;
}
return
{
errorStrings
warningStrings
infoStrings
}
;
}
)
;
}
case
"
UpdateLayerTree
"
:
{
return
this
.
tellChildrenToUpdateLayerTree
(
msg
.
data
.
browsingContext
)
;
}
}
}
}
