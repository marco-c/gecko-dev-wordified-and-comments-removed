"
use
strict
"
;
var
EXPORTED_SYMBOLS
=
[
"
ReadTopManifest
"
"
CreateUrls
"
]
;
Cu
.
import
(
"
chrome
:
/
/
reftest
/
content
/
globals
.
jsm
"
this
)
;
Cu
.
import
(
"
chrome
:
/
/
reftest
/
content
/
reftest
.
jsm
"
this
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
Services
.
jsm
"
)
;
Cu
.
import
(
"
resource
:
/
/
gre
/
modules
/
NetUtil
.
jsm
"
)
;
const
NS_SCRIPTSECURITYMANAGER_CONTRACTID
=
"
mozilla
.
org
/
scriptsecuritymanager
;
1
"
;
const
NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX
=
"
mozilla
.
org
/
network
/
protocol
;
1
?
name
=
"
;
const
NS_XREAPPINFO_CONTRACTID
=
"
mozilla
.
org
/
xre
/
app
-
info
;
1
"
;
const
RE_PROTOCOL
=
/
^
\
w
+
:
/
;
const
RE_PREF_ITEM
=
/
^
(
|
test
-
|
ref
-
)
pref
\
(
(
.
+
?
)
(
.
*
)
\
)
/
;
function
ReadTopManifest
(
aFileURL
aFilter
)
{
var
url
=
g
.
ioService
.
newURI
(
aFileURL
)
;
if
(
!
url
)
throw
"
Expected
a
file
or
http
URL
for
the
manifest
.
"
;
g
.
manifestsLoaded
=
{
}
;
ReadManifest
(
url
aFilter
)
;
}
function
ReadManifest
(
aURL
aFilter
)
{
if
(
g
.
manifestsLoaded
.
hasOwnProperty
(
aURL
.
spec
)
)
{
if
(
g
.
manifestsLoaded
[
aURL
.
spec
]
=
=
=
null
)
return
;
else
aFilter
=
[
aFilter
[
0
]
aFilter
[
1
]
true
]
;
}
g
.
manifestsLoaded
[
aURL
.
spec
]
=
aFilter
[
1
]
;
var
secMan
=
Cc
[
NS_SCRIPTSECURITYMANAGER_CONTRACTID
]
.
getService
(
Ci
.
nsIScriptSecurityManager
)
;
var
listURL
=
aURL
;
var
channel
=
NetUtil
.
newChannel
(
{
uri
:
aURL
loadUsingSystemPrincipal
:
true
}
)
;
var
inputStream
=
channel
.
open2
(
)
;
if
(
channel
instanceof
Ci
.
nsIHttpChannel
&
&
channel
.
responseStatus
!
=
200
)
{
g
.
logger
.
error
(
"
HTTP
ERROR
:
"
+
channel
.
responseStatus
)
;
}
var
streamBuf
=
getStreamContent
(
inputStream
)
;
inputStream
.
close
(
)
;
var
lines
=
streamBuf
.
split
(
/
\
n
|
\
r
|
\
r
\
n
/
)
;
var
sandbox
=
BuildConditionSandbox
(
aURL
)
;
var
lineNo
=
0
;
var
urlprefix
=
"
"
;
var
defaultTestPrefSettings
=
[
]
defaultRefPrefSettings
=
[
]
;
if
(
g
.
compareRetainedDisplayLists
)
{
AddRetainedDisplayListTestPrefs
(
sandbox
defaultTestPrefSettings
defaultRefPrefSettings
)
;
}
for
(
var
str
of
lines
)
{
+
+
lineNo
;
if
(
str
.
charAt
(
0
)
=
=
"
#
"
)
continue
;
var
i
=
str
.
search
(
/
\
s
+
#
/
)
;
if
(
i
>
=
0
)
str
=
str
.
substring
(
0
i
)
;
str
=
str
.
replace
(
/
^
\
s
*
/
'
'
)
.
replace
(
/
\
s
*
/
'
'
)
;
if
(
!
str
|
|
str
=
=
"
"
)
continue
;
var
items
=
str
.
split
(
/
\
s
+
/
)
;
if
(
items
[
0
]
=
=
"
url
-
prefix
"
)
{
if
(
items
.
length
!
=
2
)
throw
"
url
-
prefix
requires
one
url
in
manifest
file
"
+
aURL
.
spec
+
"
line
"
+
lineNo
;
urlprefix
=
items
[
1
]
;
continue
;
}
if
(
items
[
0
]
=
=
"
default
-
preferences
"
)
{
var
m
;
var
item
;
defaultTestPrefSettings
=
[
]
;
defaultRefPrefSettings
=
[
]
;
items
.
shift
(
)
;
while
(
(
item
=
items
.
shift
(
)
)
)
{
if
(
!
(
m
=
item
.
match
(
RE_PREF_ITEM
)
)
)
{
throw
"
Unexpected
item
in
default
-
preferences
list
in
manifest
file
"
+
aURL
.
spec
+
"
line
"
+
lineNo
;
}
if
(
!
AddPrefSettings
(
m
[
1
]
m
[
2
]
m
[
3
]
sandbox
defaultTestPrefSettings
defaultRefPrefSettings
)
)
{
throw
"
Error
in
pref
value
in
manifest
file
"
+
aURL
.
spec
+
"
line
"
+
lineNo
;
}
}
if
(
g
.
compareRetainedDisplayLists
)
{
AddRetainedDisplayListTestPrefs
(
sandbox
defaultTestPrefSettings
defaultRefPrefSettings
)
;
}
continue
;
}
var
expected_status
=
EXPECTED_PASS
;
var
allow_silent_fail
=
false
;
var
minAsserts
=
0
;
var
maxAsserts
=
0
;
var
needs_focus
=
false
;
var
slow
=
false
;
var
testPrefSettings
=
defaultTestPrefSettings
.
concat
(
)
;
var
refPrefSettings
=
defaultRefPrefSettings
.
concat
(
)
;
var
fuzzy_delta
=
{
min
:
0
max
:
2
}
;
var
fuzzy_pixels
=
{
min
:
0
max
:
1
}
;
var
chaosMode
=
false
;
var
nonSkipUsed
=
false
;
while
(
items
[
0
]
.
match
(
/
^
(
fails
|
needs
-
focus
|
random
|
skip
|
asserts
|
slow
|
require
-
or
|
silentfail
|
pref
|
test
-
pref
|
ref
-
pref
|
fuzzy
|
chaos
-
mode
)
/
)
)
{
var
item
=
items
.
shift
(
)
;
var
stat
;
var
cond
;
var
m
=
item
.
match
(
/
^
(
fails
|
random
|
skip
|
silentfail
)
-
if
(
\
(
.
*
\
)
)
/
)
;
if
(
m
)
{
stat
=
m
[
1
]
;
cond
=
Cu
.
evalInSandbox
(
m
[
2
]
sandbox
)
;
}
else
if
(
item
.
match
(
/
^
(
fails
|
random
|
skip
)
/
)
)
{
stat
=
item
;
cond
=
true
;
}
else
if
(
item
=
=
"
needs
-
focus
"
)
{
needs_focus
=
true
;
cond
=
false
;
}
else
if
(
(
m
=
item
.
match
(
/
^
asserts
\
(
(
\
d
+
)
(
-
\
d
+
)
?
\
)
/
)
)
)
{
cond
=
false
;
minAsserts
=
Number
(
m
[
1
]
)
;
maxAsserts
=
(
m
[
2
]
=
=
undefined
)
?
minAsserts
:
Number
(
m
[
2
]
.
substring
(
1
)
)
;
}
else
if
(
(
m
=
item
.
match
(
/
^
asserts
-
if
\
(
(
.
*
?
)
(
\
d
+
)
(
-
\
d
+
)
?
\
)
/
)
)
)
{
cond
=
false
;
if
(
Cu
.
evalInSandbox
(
"
(
"
+
m
[
1
]
+
"
)
"
sandbox
)
)
{
minAsserts
=
Number
(
m
[
2
]
)
;
maxAsserts
=
(
m
[
3
]
=
=
undefined
)
?
minAsserts
:
Number
(
m
[
3
]
.
substring
(
1
)
)
;
}
}
else
if
(
item
=
=
"
slow
"
)
{
cond
=
false
;
slow
=
true
;
}
else
if
(
(
m
=
item
.
match
(
/
^
require
-
or
\
(
(
.
*
?
)
\
)
/
)
)
)
{
var
args
=
m
[
1
]
.
split
(
/
/
)
;
if
(
args
.
length
!
=
2
)
{
throw
"
Error
in
manifest
file
"
+
aURL
.
spec
+
"
line
"
+
lineNo
+
"
:
wrong
number
of
args
to
require
-
or
"
;
}
var
[
precondition_str
fallback_action
]
=
args
;
var
preconditions
=
precondition_str
.
split
(
/
&
&
/
)
;
cond
=
false
;
for
(
var
precondition
of
preconditions
)
{
if
(
precondition
=
=
=
"
debugMode
"
)
{
stat
=
fallback_action
;
cond
=
true
;
break
;
}
else
if
(
precondition
=
=
=
"
true
"
)
{
}
else
{
stat
=
fallback_action
;
cond
=
true
;
break
;
}
}
}
else
if
(
(
m
=
item
.
match
(
/
^
slow
-
if
\
(
(
.
*
?
)
\
)
/
)
)
)
{
cond
=
false
;
if
(
Cu
.
evalInSandbox
(
"
(
"
+
m
[
1
]
+
"
)
"
sandbox
)
)
slow
=
true
;
}
else
if
(
item
=
=
"
silentfail
"
)
{
cond
=
false
;
allow_silent_fail
=
true
;
}
else
if
(
(
m
=
item
.
match
(
RE_PREF_ITEM
)
)
)
{
cond
=
false
;
if
(
!
AddPrefSettings
(
m
[
1
]
m
[
2
]
m
[
3
]
sandbox
testPrefSettings
refPrefSettings
)
)
{
throw
"
Error
in
pref
value
in
manifest
file
"
+
aURL
.
spec
+
"
line
"
+
lineNo
;
}
}
else
if
(
(
m
=
item
.
match
(
/
^
fuzzy
\
(
(
\
d
+
)
(
-
\
d
+
)
?
(
\
d
+
)
(
-
\
d
+
)
?
\
)
/
)
)
)
{
cond
=
false
;
expected_status
=
EXPECTED_FUZZY
;
fuzzy_delta
=
ExtractRange
(
m
1
)
;
fuzzy_pixels
=
ExtractRange
(
m
3
)
;
}
else
if
(
(
m
=
item
.
match
(
/
^
fuzzy
-
if
\
(
(
.
*
?
)
(
\
d
+
)
(
-
\
d
+
)
?
(
\
d
+
)
(
-
\
d
+
)
?
\
)
/
)
)
)
{
cond
=
false
;
if
(
Cu
.
evalInSandbox
(
"
(
"
+
m
[
1
]
+
"
)
"
sandbox
)
)
{
expected_status
=
EXPECTED_FUZZY
;
fuzzy_delta
=
ExtractRange
(
m
2
)
;
fuzzy_pixels
=
ExtractRange
(
m
4
)
;
}
}
else
if
(
item
=
=
"
chaos
-
mode
"
)
{
cond
=
false
;
chaosMode
=
true
;
}
else
{
throw
"
Error
in
manifest
file
"
+
aURL
.
spec
+
"
line
"
+
lineNo
+
"
:
unexpected
item
"
+
item
;
}
if
(
stat
!
=
"
skip
"
)
{
nonSkipUsed
=
true
;
}
if
(
cond
)
{
if
(
stat
=
=
"
fails
"
)
{
expected_status
=
EXPECTED_FAIL
;
}
else
if
(
stat
=
=
"
random
"
)
{
expected_status
=
EXPECTED_RANDOM
;
}
else
if
(
stat
=
=
"
skip
"
)
{
expected_status
=
EXPECTED_DEATH
;
}
else
if
(
stat
=
=
"
silentfail
"
)
{
allow_silent_fail
=
true
;
}
}
}
if
(
minAsserts
>
maxAsserts
)
{
throw
"
Bad
range
in
manifest
file
"
+
aURL
.
spec
+
"
line
"
+
lineNo
;
}
var
runHttp
=
false
;
var
httpDepth
;
if
(
items
[
0
]
=
=
"
HTTP
"
)
{
runHttp
=
(
aURL
.
scheme
=
=
"
file
"
)
;
httpDepth
=
0
;
items
.
shift
(
)
;
}
else
if
(
items
[
0
]
.
match
(
/
HTTP
\
(
\
.
\
.
(
\
/
\
.
\
.
)
*
\
)
/
)
)
{
runHttp
=
(
aURL
.
scheme
=
=
"
file
"
)
;
httpDepth
=
(
items
[
0
]
.
length
-
5
)
/
3
;
items
.
shift
(
)
;
}
if
(
urlprefix
&
&
items
[
0
]
!
=
"
include
"
)
{
if
(
items
.
length
>
1
&
&
!
items
[
1
]
.
match
(
RE_PROTOCOL
)
)
{
items
[
1
]
=
urlprefix
+
items
[
1
]
;
}
if
(
items
.
length
>
2
&
&
!
items
[
2
]
.
match
(
RE_PROTOCOL
)
)
{
items
[
2
]
=
urlprefix
+
items
[
2
]
;
}
}
var
principal
=
secMan
.
createCodebasePrincipal
(
aURL
{
}
)
;
if
(
items
[
0
]
=
=
"
include
"
)
{
if
(
items
.
length
!
=
2
)
throw
"
Error
in
manifest
file
"
+
aURL
.
spec
+
"
line
"
+
lineNo
+
"
:
incorrect
number
of
arguments
to
include
"
;
if
(
runHttp
)
throw
"
Error
in
manifest
file
"
+
aURL
.
spec
+
"
line
"
+
lineNo
+
"
:
use
of
include
with
http
"
;
if
(
nonSkipUsed
)
{
throw
"
Error
in
manifest
file
"
+
aURL
.
spec
+
"
line
"
+
lineNo
+
"
:
include
statement
with
annotation
other
than
'
skip
'
or
'
skip
-
if
'
"
;
}
else
if
(
expected_status
=
=
EXPECTED_DEATH
)
{
g
.
logger
.
info
(
"
Skipping
included
manifest
at
"
+
aURL
.
spec
+
"
line
"
+
lineNo
+
"
due
to
matching
skip
condition
"
)
;
}
else
{
if
(
expected_status
!
=
EXPECTED_PASS
)
{
throw
"
Error
in
manifest
file
parsing
code
:
we
should
never
get
expected_status
=
"
+
expected_status
+
"
when
nonSkipUsed
=
false
(
from
"
+
aURL
.
spec
+
"
line
"
+
lineNo
+
"
)
"
;
}
var
incURI
=
g
.
ioService
.
newURI
(
items
[
1
]
null
listURL
)
;
secMan
.
checkLoadURIWithPrincipal
(
principal
incURI
Ci
.
nsIScriptSecurityManager
.
DISALLOW_SCRIPT
)
;
ReadManifest
(
incURI
aFilter
)
;
}
}
else
if
(
items
[
0
]
=
=
TYPE_LOAD
|
|
items
[
0
]
=
=
TYPE_SCRIPT
)
{
if
(
items
.
length
!
=
2
)
throw
"
Error
in
manifest
file
"
+
aURL
.
spec
+
"
line
"
+
lineNo
+
"
:
incorrect
number
of
arguments
to
"
+
items
[
0
]
;
if
(
items
[
0
]
=
=
TYPE_LOAD
&
&
expected_status
!
=
EXPECTED_PASS
&
&
expected_status
!
=
EXPECTED_DEATH
)
throw
"
Error
in
manifest
file
"
+
aURL
.
spec
+
"
line
"
+
lineNo
+
"
:
incorrect
known
failure
type
for
load
test
"
;
AddTestItem
(
{
type
:
TYPE_LOAD
expected
:
expected_status
manifest
:
aURL
.
spec
allowSilentFail
:
allow_silent_fail
minAsserts
:
minAsserts
maxAsserts
:
maxAsserts
needsFocus
:
needs_focus
slow
:
slow
prefSettings1
:
testPrefSettings
prefSettings2
:
refPrefSettings
fuzzyMinDelta
:
fuzzy_delta
.
min
fuzzyMaxDelta
:
fuzzy_delta
.
max
fuzzyMinPixels
:
fuzzy_pixels
.
min
fuzzyMaxPixels
:
fuzzy_pixels
.
max
runHttp
:
runHttp
httpDepth
:
httpDepth
url1
:
items
[
1
]
url2
:
null
chaosMode
:
chaosMode
}
aFilter
)
;
}
else
if
(
items
[
0
]
=
=
TYPE_REFTEST_EQUAL
|
|
items
[
0
]
=
=
TYPE_REFTEST_NOTEQUAL
|
|
items
[
0
]
=
=
TYPE_PRINT
)
{
if
(
items
.
length
!
=
3
)
throw
"
Error
in
manifest
file
"
+
aURL
.
spec
+
"
line
"
+
lineNo
+
"
:
incorrect
number
of
arguments
to
"
+
items
[
0
]
;
if
(
items
[
0
]
=
=
TYPE_REFTEST_NOTEQUAL
&
&
expected_status
=
=
EXPECTED_FUZZY
&
&
(
fuzzy_delta
.
min
>
0
|
|
fuzzy_pixels
.
min
>
0
)
)
{
throw
"
Error
in
manifest
file
"
+
aURL
.
spec
+
"
line
"
+
lineNo
+
"
:
minimum
fuzz
must
be
zero
for
tests
of
type
"
+
items
[
0
]
;
}
var
type
=
items
[
0
]
;
if
(
g
.
compareRetainedDisplayLists
)
{
type
=
TYPE_REFTEST_EQUAL
;
minAsserts
*
=
2
;
maxAsserts
*
=
2
;
if
(
expected_status
=
=
=
EXPECTED_FAIL
|
|
expected_status
=
=
=
EXPECTED_RANDOM
)
{
expected_status
=
EXPECTED_DEATH
;
}
}
AddTestItem
(
{
type
:
type
expected
:
expected_status
manifest
:
aURL
.
spec
allowSilentFail
:
allow_silent_fail
minAsserts
:
minAsserts
maxAsserts
:
maxAsserts
needsFocus
:
needs_focus
slow
:
slow
prefSettings1
:
testPrefSettings
prefSettings2
:
refPrefSettings
fuzzyMinDelta
:
fuzzy_delta
.
min
fuzzyMaxDelta
:
fuzzy_delta
.
max
fuzzyMinPixels
:
fuzzy_pixels
.
min
fuzzyMaxPixels
:
fuzzy_pixels
.
max
runHttp
:
runHttp
httpDepth
:
httpDepth
url1
:
items
[
1
]
url2
:
items
[
2
]
chaosMode
:
chaosMode
}
aFilter
)
;
}
else
{
throw
"
Error
in
manifest
file
"
+
aURL
.
spec
+
"
line
"
+
lineNo
+
"
:
unknown
test
type
"
+
items
[
0
]
;
}
}
}
function
getStreamContent
(
inputStream
)
{
var
streamBuf
=
"
"
;
var
sis
=
Cc
[
"
mozilla
.
org
/
scriptableinputstream
;
1
"
]
.
createInstance
(
Ci
.
nsIScriptableInputStream
)
;
sis
.
init
(
inputStream
)
;
var
available
;
while
(
(
available
=
sis
.
available
(
)
)
!
=
0
)
{
streamBuf
+
=
sis
.
read
(
available
)
;
}
return
streamBuf
;
}
function
BuildConditionSandbox
(
aURL
)
{
var
sandbox
=
new
Cu
.
Sandbox
(
aURL
.
spec
)
;
var
xr
=
Cc
[
NS_XREAPPINFO_CONTRACTID
]
.
getService
(
Ci
.
nsIXULRuntime
)
;
var
appInfo
=
Cc
[
NS_XREAPPINFO_CONTRACTID
]
.
getService
(
Ci
.
nsIXULAppInfo
)
;
sandbox
.
isDebugBuild
=
g
.
debug
.
isDebugBuild
;
var
prefs
=
Cc
[
"
mozilla
.
org
/
preferences
-
service
;
1
"
]
.
getService
(
Ci
.
nsIPrefBranch
)
;
var
env
=
Cc
[
"
mozilla
.
org
/
process
/
environment
;
1
"
]
.
getService
(
Ci
.
nsIEnvironment
)
;
sandbox
.
xulRuntime
=
Cu
.
cloneInto
(
{
widgetToolkit
:
xr
.
widgetToolkit
OS
:
xr
.
OS
XPCOMABI
:
xr
.
XPCOMABI
}
sandbox
)
;
var
testRect
=
g
.
browser
.
getBoundingClientRect
(
)
;
sandbox
.
smallScreen
=
false
;
if
(
g
.
containingWindow
.
innerWidth
<
800
|
|
g
.
containingWindow
.
innerHeight
<
1000
)
{
sandbox
.
smallScreen
=
true
;
}
var
gfxInfo
=
(
NS_GFXINFO_CONTRACTID
in
Cc
)
&
&
Cc
[
NS_GFXINFO_CONTRACTID
]
.
getService
(
Ci
.
nsIGfxInfo
)
;
let
readGfxInfo
=
function
(
obj
key
)
{
if
(
g
.
contentGfxInfo
&
&
(
key
in
g
.
contentGfxInfo
)
)
{
return
g
.
contentGfxInfo
[
key
]
;
}
return
obj
[
key
]
;
}
try
{
sandbox
.
d2d
=
readGfxInfo
(
gfxInfo
"
D2DEnabled
"
)
;
sandbox
.
dwrite
=
readGfxInfo
(
gfxInfo
"
DWriteEnabled
"
)
;
}
catch
(
e
)
{
sandbox
.
d2d
=
false
;
sandbox
.
dwrite
=
false
;
}
var
info
=
gfxInfo
.
getInfo
(
)
;
var
canvasBackend
=
readGfxInfo
(
info
"
AzureCanvasBackend
"
)
;
var
contentBackend
=
readGfxInfo
(
info
"
AzureContentBackend
"
)
;
var
canvasAccelerated
=
readGfxInfo
(
info
"
AzureCanvasAccelerated
"
)
;
sandbox
.
gpuProcess
=
gfxInfo
.
usingGPUProcess
;
sandbox
.
azureCairo
=
canvasBackend
=
=
"
cairo
"
;
sandbox
.
azureSkia
=
canvasBackend
=
=
"
skia
"
;
sandbox
.
skiaContent
=
contentBackend
=
=
"
skia
"
;
sandbox
.
azureSkiaGL
=
canvasAccelerated
;
sandbox
.
contentSameGfxBackendAsCanvas
=
contentBackend
=
=
canvasBackend
|
|
(
contentBackend
=
=
"
none
"
&
&
canvasBackend
=
=
"
cairo
"
)
;
sandbox
.
layersGPUAccelerated
=
g
.
windowUtils
.
layerManagerType
!
=
"
Basic
"
;
sandbox
.
d3d11
=
g
.
windowUtils
.
layerManagerType
=
=
"
Direct3D
11
"
;
sandbox
.
d3d9
=
g
.
windowUtils
.
layerManagerType
=
=
"
Direct3D
9
"
;
sandbox
.
layersOpenGL
=
g
.
windowUtils
.
layerManagerType
=
=
"
OpenGL
"
;
sandbox
.
webrender
=
g
.
windowUtils
.
layerManagerType
=
=
"
WebRender
"
;
sandbox
.
layersOMTC
=
g
.
windowUtils
.
layerManagerRemote
=
=
true
;
sandbox
.
advancedLayers
=
g
.
windowUtils
.
usingAdvancedLayers
=
=
true
;
sandbox
.
layerChecksEnabled
=
!
sandbox
.
webrender
;
sandbox
.
retainedDisplayList
=
prefs
.
getBoolPref
(
"
layout
.
display
-
list
.
retain
"
)
;
sandbox
.
Android
=
xr
.
OS
=
=
"
Android
"
;
sandbox
.
cocoaWidget
=
xr
.
widgetToolkit
=
=
"
cocoa
"
;
sandbox
.
gtkWidget
=
xr
.
widgetToolkit
=
=
"
gtk3
"
;
sandbox
.
qtWidget
=
xr
.
widgetToolkit
=
=
"
qt
"
;
sandbox
.
winWidget
=
xr
.
widgetToolkit
=
=
"
windows
"
;
sandbox
.
transparentScrollbars
=
xr
.
widgetToolkit
=
=
"
gtk3
"
;
if
(
sandbox
.
Android
)
{
var
sysInfo
=
Cc
[
"
mozilla
.
org
/
system
-
info
;
1
"
]
.
getService
(
Ci
.
nsIPropertyBag2
)
;
sandbox
.
AndroidVersion
=
sysInfo
.
getPropertyAsInt32
(
"
version
"
)
;
}
#
if
MOZ_ASAN
sandbox
.
AddressSanitizer
=
true
;
#
else
sandbox
.
AddressSanitizer
=
false
;
#
endif
#
if
MOZ_WEBRTC
sandbox
.
webrtc
=
true
;
#
else
sandbox
.
webrtc
=
false
;
#
endif
let
retainedDisplayListsEnabled
=
prefs
.
getBoolPref
(
"
layout
.
display
-
list
.
retain
"
false
)
;
sandbox
.
retainedDisplayLists
=
retainedDisplayListsEnabled
&
&
!
g
.
compareRetainedDisplayLists
;
sandbox
.
compareRetainedDisplayLists
=
g
.
compareRetainedDisplayLists
;
sandbox
.
skiaPdf
=
false
;
#
ifdef
RELEASE_OR_BETA
sandbox
.
release_or_beta
=
true
;
#
else
sandbox
.
release_or_beta
=
false
;
#
endif
var
hh
=
Cc
[
NS_NETWORK_PROTOCOL_CONTRACTID_PREFIX
+
"
http
"
]
.
getService
(
Ci
.
nsIHttpProtocolHandler
)
;
var
httpProps
=
[
"
userAgent
"
"
appName
"
"
appVersion
"
"
vendor
"
"
vendorSub
"
"
product
"
"
productSub
"
"
platform
"
"
oscpu
"
"
language
"
"
misc
"
]
;
sandbox
.
http
=
new
sandbox
.
Object
(
)
;
httpProps
.
forEach
(
(
x
)
=
>
sandbox
.
http
[
x
]
=
hh
[
x
]
)
;
var
osxmatch
=
/
Mac
OS
X
(
\
d
+
)
.
(
\
d
+
)
/
.
exec
(
hh
.
oscpu
)
;
sandbox
.
OSX
=
osxmatch
?
parseInt
(
osxmatch
[
1
]
)
*
100
+
parseInt
(
osxmatch
[
2
]
)
:
undefined
;
sandbox
.
haveTestPlugin
=
!
sandbox
.
Android
&
&
!
!
getTestPlugin
(
"
Test
Plug
-
in
"
)
;
sandbox
.
windowsDefaultTheme
=
g
.
containingWindow
.
matchMedia
(
"
(
-
moz
-
windows
-
default
-
theme
)
"
)
.
matches
;
try
{
sandbox
.
nativeThemePref
=
!
prefs
.
getBoolPref
(
"
mozilla
.
widget
.
disable
-
native
-
theme
"
)
;
}
catch
(
e
)
{
sandbox
.
nativeThemePref
=
true
;
}
sandbox
.
gpuProcessForceEnabled
=
prefs
.
getBoolPref
(
"
layers
.
gpu
-
process
.
force
-
enabled
"
false
)
;
sandbox
.
prefs
=
Cu
.
cloneInto
(
{
getBoolPref
:
function
(
p
)
{
return
prefs
.
getBoolPref
(
p
)
;
}
getIntPref
:
function
(
p
)
{
return
prefs
.
getIntPref
(
p
)
;
}
}
sandbox
{
cloneFunctions
:
true
}
)
;
sandbox
.
browserIsRemote
=
g
.
browserIsRemote
;
try
{
sandbox
.
asyncPan
=
g
.
containingWindow
.
document
.
docShell
.
asyncPanZoomEnabled
;
}
catch
(
e
)
{
sandbox
.
asyncPan
=
false
;
}
sandbox
.
usesRepeatResampling
=
sandbox
.
d2d
;
sandbox
.
verify
=
prefs
.
getBoolPref
(
"
reftest
.
verify
"
false
)
;
if
(
!
g
.
dumpedConditionSandbox
)
{
g
.
logger
.
info
(
"
Dumping
JSON
representation
of
sandbox
"
)
;
g
.
logger
.
info
(
JSON
.
stringify
(
Cu
.
waiveXrays
(
sandbox
)
)
)
;
g
.
dumpedConditionSandbox
=
true
;
}
return
sandbox
;
}
function
AddRetainedDisplayListTestPrefs
(
aSandbox
aTestPrefSettings
aRefPrefSettings
)
{
AddPrefSettings
(
"
test
-
"
"
layout
.
display
-
list
.
retain
"
"
true
"
aSandbox
aTestPrefSettings
aRefPrefSettings
)
;
AddPrefSettings
(
"
ref
-
"
"
layout
.
display
-
list
.
retain
"
"
false
"
aSandbox
aTestPrefSettings
aRefPrefSettings
)
;
}
function
AddPrefSettings
(
aWhere
aPrefName
aPrefValExpression
aSandbox
aTestPrefSettings
aRefPrefSettings
)
{
var
prefVal
=
Cu
.
evalInSandbox
(
"
(
"
+
aPrefValExpression
+
"
)
"
aSandbox
)
;
var
prefType
;
var
valType
=
typeof
(
prefVal
)
;
if
(
valType
=
=
"
boolean
"
)
{
prefType
=
PREF_BOOLEAN
;
}
else
if
(
valType
=
=
"
string
"
)
{
prefType
=
PREF_STRING
;
}
else
if
(
valType
=
=
"
number
"
&
&
(
parseInt
(
prefVal
)
=
=
prefVal
)
)
{
prefType
=
PREF_INTEGER
;
}
else
{
return
false
;
}
var
setting
=
{
name
:
aPrefName
type
:
prefType
value
:
prefVal
}
;
if
(
g
.
compareRetainedDisplayLists
&
&
aPrefName
!
=
"
layout
.
display
-
list
.
retain
"
)
{
if
(
aWhere
!
=
"
ref
-
"
)
{
aTestPrefSettings
.
push
(
setting
)
;
aRefPrefSettings
.
push
(
setting
)
;
}
}
else
{
if
(
aWhere
!
=
"
ref
-
"
)
{
aTestPrefSettings
.
push
(
setting
)
;
}
if
(
aWhere
!
=
"
test
-
"
)
{
aRefPrefSettings
.
push
(
setting
)
;
}
}
return
true
;
}
function
ExtractRange
(
matches
startIndex
defaultMin
=
0
)
{
if
(
matches
[
startIndex
+
1
]
=
=
=
undefined
)
{
return
{
min
:
defaultMin
max
:
Number
(
matches
[
startIndex
]
)
}
;
}
return
{
min
:
Number
(
matches
[
startIndex
]
)
max
:
Number
(
matches
[
startIndex
+
1
]
.
substring
(
1
)
)
}
;
}
function
ServeTestBase
(
aURL
depth
)
{
var
listURL
=
aURL
.
QueryInterface
(
Ci
.
nsIFileURL
)
;
var
directory
=
listURL
.
file
.
parent
;
var
dirPath
=
"
/
"
;
while
(
depth
>
0
)
{
dirPath
=
"
/
"
+
directory
.
leafName
+
dirPath
;
directory
=
directory
.
parent
;
-
-
depth
;
}
g
.
count
+
+
;
var
path
=
"
/
"
+
Date
.
now
(
)
+
"
/
"
+
g
.
count
;
g
.
server
.
registerDirectory
(
path
+
"
/
"
directory
)
;
var
secMan
=
Cc
[
NS_SCRIPTSECURITYMANAGER_CONTRACTID
]
.
getService
(
Ci
.
nsIScriptSecurityManager
)
;
var
testbase
=
g
.
ioService
.
newURI
(
"
http
:
/
/
localhost
:
"
+
g
.
httpServerPort
+
path
+
dirPath
)
;
Services
.
perms
.
add
(
testbase
"
allowXULXBL
"
Services
.
perms
.
ALLOW_ACTION
)
;
return
testbase
;
}
function
CreateUrls
(
test
)
{
let
secMan
=
Cc
[
NS_SCRIPTSECURITYMANAGER_CONTRACTID
]
.
getService
(
Ci
.
nsIScriptSecurityManager
)
;
let
manifestURL
=
g
.
ioService
.
newURI
(
test
.
manifest
)
;
let
principal
=
secMan
.
createCodebasePrincipal
(
manifestURL
{
}
)
;
let
testbase
=
manifestURL
;
if
(
test
.
runHttp
)
testbase
=
ServeTestBase
(
manifestURL
test
.
httpDepth
)
function
FileToURI
(
file
)
{
if
(
file
=
=
=
null
)
return
file
;
var
testURI
=
g
.
ioService
.
newURI
(
file
null
testbase
)
;
secMan
.
checkLoadURIWithPrincipal
(
principal
testURI
Ci
.
nsIScriptSecurityManager
.
DISALLOW_SCRIPT
)
;
return
testURI
;
}
let
files
=
[
test
.
url1
test
.
url2
]
;
[
test
.
url1
test
.
url2
]
=
files
.
map
(
FileToURI
)
;
return
test
;
}
function
AddTestItem
(
aTest
aFilter
)
{
if
(
!
aFilter
)
aFilter
=
[
null
[
]
false
]
;
var
{
url1
url2
}
=
CreateUrls
(
Object
.
assign
(
{
}
aTest
)
)
;
var
globalFilter
=
aFilter
[
0
]
;
var
manifestFilter
=
aFilter
[
1
]
;
var
invertManifest
=
aFilter
[
2
]
;
if
(
globalFilter
&
&
!
globalFilter
.
test
(
url1
.
spec
)
)
return
;
if
(
manifestFilter
&
&
!
(
invertManifest
^
manifestFilter
.
test
(
url1
.
spec
)
)
)
return
;
if
(
g
.
focusFilterMode
=
=
FOCUS_FILTER_NEEDS_FOCUS_TESTS
&
&
!
aTest
.
needsFocus
)
return
;
if
(
g
.
focusFilterMode
=
=
FOCUS_FILTER_NON_NEEDS_FOCUS_TESTS
&
&
aTest
.
needsFocus
)
return
;
if
(
url2
!
=
=
null
)
aTest
.
identifier
=
[
url1
.
spec
aTest
.
type
url2
.
spec
]
;
else
aTest
.
identifier
=
url1
.
spec
;
g
.
urls
.
push
(
aTest
)
;
}
