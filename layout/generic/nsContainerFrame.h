#
ifndef
nsContainerFrame_h___
#
define
nsContainerFrame_h___
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
nsSplittableFrame
.
h
"
#
include
"
nsFrameList
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
define
NS_FRAME_NO_MOVE_VIEW
0x0001
#
define
NS_FRAME_NO_MOVE_FRAME
(
0x0002
|
NS_FRAME_NO_MOVE_VIEW
)
#
define
NS_FRAME_NO_SIZE_VIEW
0x0004
#
define
NS_FRAME_NO_VISIBILITY
0x0008
#
define
NS_FRAME_NO_DELETE_NEXT_IN_FLOW_CHILD
0x0010
class
nsOverflowContinuationTracker
;
#
ifdef
DEBUG
#
define
CRAZY_COORD
(
10000000
*
60
)
#
define
CRAZY_SIZE
(
_x
)
(
(
(
_x
)
<
-
CRAZY_COORD
)
|
|
(
(
_x
)
>
CRAZY_COORD
)
)
#
endif
class
nsContainerFrame
:
public
nsSplittableFrame
{
public
:
NS_DECL_ABSTRACT_FRAME
(
nsContainerFrame
)
NS_DECL_QUERYFRAME_TARGET
(
nsContainerFrame
)
NS_DECL_QUERYFRAME
virtual
void
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
override
;
virtual
nsContainerFrame
*
GetContentInsertionFrame
(
)
override
{
return
this
;
}
virtual
const
nsFrameList
&
GetChildList
(
ChildListID
aList
)
const
override
;
virtual
void
GetChildLists
(
nsTArray
<
ChildList
>
*
aLists
)
const
override
;
virtual
void
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
override
;
virtual
void
ChildIsDirty
(
nsIFrame
*
aChild
)
override
;
virtual
FrameSearchResult
PeekOffsetNoAmount
(
bool
aForward
int32_t
*
aOffset
)
override
;
virtual
FrameSearchResult
PeekOffsetCharacter
(
bool
aForward
int32_t
*
aOffset
PeekOffsetCharacterOptions
aOptions
=
PeekOffsetCharacterOptions
(
)
)
override
;
virtual
nsresult
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
override
;
#
ifdef
DEBUG_FRAME_DUMP
void
List
(
FILE
*
out
=
stderr
const
char
*
aPrefix
=
"
"
uint32_t
aFlags
=
0
)
const
override
;
#
endif
virtual
void
SetInitialChildList
(
ChildListID
aListID
nsFrameList
&
aChildList
)
;
virtual
void
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
;
virtual
void
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
aFrameList
)
;
virtual
void
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
;
nsIFrame
*
CreateNextInFlow
(
nsIFrame
*
aFrame
)
;
virtual
void
DeleteNextInFlowChild
(
nsIFrame
*
aNextInFlow
bool
aDeletingEmptyFrames
)
;
static
void
PositionFrameView
(
nsIFrame
*
aKidFrame
)
;
static
nsresult
ReparentFrameView
(
nsIFrame
*
aChildFrame
nsIFrame
*
aOldParentFrame
nsIFrame
*
aNewParentFrame
)
;
static
nsresult
ReparentFrameViewList
(
const
nsFrameList
&
aChildFrameList
nsIFrame
*
aOldParentFrame
nsIFrame
*
aNewParentFrame
)
;
static
void
SyncFrameViewAfterReflow
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
nsView
*
aView
const
nsRect
&
aVisualOverflowArea
uint32_t
aFlags
=
0
)
;
enum
{
SET_ASYNC
=
0x01
}
;
static
void
SyncWindowProperties
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
nsView
*
aView
gfxContext
*
aRC
uint32_t
aFlags
)
;
static
void
SetSizeConstraints
(
nsPresContext
*
aPresContext
nsIWidget
*
aWidget
const
nsSize
&
aMinSize
const
nsSize
&
aMaxSize
)
;
void
DoInlineIntrinsicISize
(
gfxContext
*
aRenderingContext
InlineIntrinsicISizeData
*
aData
nsLayoutUtils
:
:
IntrinsicISizeType
aType
)
;
virtual
mozilla
:
:
LogicalSize
ComputeAutoSize
(
gfxContext
*
aRenderingContext
mozilla
:
:
WritingMode
aWM
const
mozilla
:
:
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
mozilla
:
:
LogicalSize
&
aMargin
const
mozilla
:
:
LogicalSize
&
aBorder
const
mozilla
:
:
LogicalSize
&
aPadding
ComputeSizeFlags
aFlags
)
override
;
void
ReflowChild
(
nsIFrame
*
aChildFrame
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
const
mozilla
:
:
WritingMode
&
aWM
const
mozilla
:
:
LogicalPoint
&
aPos
const
nsSize
&
aContainerSize
uint32_t
aFlags
nsReflowStatus
&
aStatus
nsOverflowContinuationTracker
*
aTracker
=
nullptr
)
;
static
void
FinishReflowChild
(
nsIFrame
*
aKidFrame
nsPresContext
*
aPresContext
const
ReflowOutput
&
aDesiredSize
const
ReflowInput
*
aReflowInput
const
mozilla
:
:
WritingMode
&
aWM
const
mozilla
:
:
LogicalPoint
&
aPos
const
nsSize
&
aContainerSize
uint32_t
aFlags
)
;
void
ReflowChild
(
nsIFrame
*
aKidFrame
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nscoord
aX
nscoord
aY
uint32_t
aFlags
nsReflowStatus
&
aStatus
nsOverflowContinuationTracker
*
aTracker
=
nullptr
)
;
static
void
FinishReflowChild
(
nsIFrame
*
aKidFrame
nsPresContext
*
aPresContext
const
ReflowOutput
&
aDesiredSize
const
ReflowInput
*
aReflowInput
nscoord
aX
nscoord
aY
uint32_t
aFlags
)
;
static
void
PositionChildViews
(
nsIFrame
*
aFrame
)
;
friend
class
nsOverflowContinuationTracker
;
typedef
void
(
*
ChildFrameMerger
)
(
nsFrameList
&
aDest
nsFrameList
&
aSrc
nsContainerFrame
*
aParent
)
;
static
inline
void
DefaultChildFrameMerge
(
nsFrameList
&
aDest
nsFrameList
&
aSrc
nsContainerFrame
*
aParent
)
{
aDest
.
AppendFrames
(
nullptr
aSrc
)
;
}
void
ReflowOverflowContainerChildren
(
nsPresContext
*
aPresContext
const
ReflowInput
&
aReflowInput
nsOverflowAreas
&
aOverflowRects
uint32_t
aFlags
nsReflowStatus
&
aStatus
ChildFrameMerger
aMergeFunc
=
DefaultChildFrameMerge
)
;
virtual
bool
DrainSelfOverflowList
(
)
override
;
nsFrameList
*
DrainExcessOverflowContainersList
(
ChildFrameMerger
aMergeFunc
=
DefaultChildFrameMerge
)
;
virtual
nsresult
StealFrame
(
nsIFrame
*
aChild
)
;
nsFrameList
StealFramesAfter
(
nsIFrame
*
aChild
)
;
void
DisplayOverflowContainers
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
;
virtual
void
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
override
;
static
void
PlaceFrameView
(
nsIFrame
*
aFrame
)
{
if
(
aFrame
-
>
HasView
(
)
)
nsContainerFrame
:
:
PositionFrameView
(
aFrame
)
;
else
nsContainerFrame
:
:
PositionChildViews
(
aFrame
)
;
}
static
bool
FrameStartsCounterScope
(
nsIFrame
*
aFrame
)
;
bool
RenumberList
(
)
;
bool
RenumberFrameAndDescendants
(
int32_t
*
aOrdinal
int32_t
aDepth
int32_t
aIncrement
bool
aForCounting
)
override
;
virtual
bool
RenumberChildFrames
(
int32_t
*
aOrdinal
int32_t
aDepth
int32_t
aIncrement
bool
aForCounting
)
;
virtual
uint16_t
CSSAlignmentForAbsPosChild
(
const
ReflowInput
&
aChildRI
mozilla
:
:
LogicalAxis
aLogicalAxis
)
const
;
#
define
NS_DECLARE_FRAME_PROPERTY_FRAMELIST
(
prop
)
\
NS_DECLARE_FRAME_PROPERTY_WITH_DTOR_NEVER_CALLED
(
prop
nsFrameList
)
typedef
PropertyDescriptor
<
nsFrameList
>
FrameListPropertyDescriptor
;
NS_DECLARE_FRAME_PROPERTY_FRAMELIST
(
OverflowProperty
)
NS_DECLARE_FRAME_PROPERTY_FRAMELIST
(
OverflowContainersProperty
)
NS_DECLARE_FRAME_PROPERTY_FRAMELIST
(
ExcessOverflowContainersProperty
)
NS_DECLARE_FRAME_PROPERTY_FRAMELIST
(
BackdropProperty
)
NS_DECLARE_FRAME_PROPERTY_WITHOUT_DTOR
(
FirstLetterProperty
nsIFrame
)
void
SetHasFirstLetterChild
(
)
{
mHasFirstLetterChild
=
true
;
}
void
ClearHasFirstLetterChild
(
)
{
mHasFirstLetterChild
=
false
;
}
#
ifdef
DEBUG
NS_DECLARE_FRAME_PROPERTY_SMALL_VALUE
(
DebugReflowingWithInfiniteISize
bool
)
bool
IsCrazySizeAssertSuppressed
(
)
const
{
return
GetProperty
(
DebugReflowingWithInfiniteISize
(
)
)
;
}
#
endif
protected
:
nsContainerFrame
(
ComputedStyle
*
aStyle
ClassID
aID
)
:
nsSplittableFrame
(
aStyle
aID
)
{
}
~
nsContainerFrame
(
)
;
void
DestroyAbsoluteFrames
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
;
bool
MaybeStealOverflowContainerFrame
(
nsIFrame
*
aChild
)
;
void
BuildDisplayListForNonBlockChildren
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
uint32_t
aFlags
=
0
)
;
void
BuildDisplayListForInline
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
DisplayBorderBackgroundOutline
(
aBuilder
aLists
)
;
BuildDisplayListForNonBlockChildren
(
aBuilder
aLists
DISPLAY_CHILD_INLINE
)
;
}
inline
nsFrameList
*
GetOverflowFrames
(
)
const
;
inline
nsFrameList
*
StealOverflowFrames
(
)
;
void
SetOverflowFrames
(
const
nsFrameList
&
aOverflowFrames
)
;
inline
void
DestroyOverflowList
(
)
;
bool
MoveOverflowToChildList
(
)
;
bool
MoveInlineOverflowToChildList
(
nsIFrame
*
aLineContainer
)
;
void
PushChildrenToOverflow
(
nsIFrame
*
aFromChild
nsIFrame
*
aPrevSibling
)
;
void
PushChildren
(
nsIFrame
*
aFromChild
nsIFrame
*
aPrevSibling
)
;
static
void
ReparentFloatsForInlineChild
(
nsIFrame
*
aOurBlock
nsIFrame
*
aFrame
bool
aReparentSiblings
)
;
struct
ContinuationTraversingState
{
nsContainerFrame
*
mNextInFlow
;
explicit
ContinuationTraversingState
(
nsContainerFrame
*
aFrame
)
:
mNextInFlow
(
static_cast
<
nsContainerFrame
*
>
(
aFrame
-
>
GetNextInFlow
(
)
)
)
{
}
}
;
nsIFrame
*
GetNextInFlowChild
(
ContinuationTraversingState
&
aState
bool
*
aIsInOverflow
=
nullptr
)
;
nsIFrame
*
PullNextInFlowChild
(
ContinuationTraversingState
&
aState
)
;
nsFrameList
*
GetPropTableFrames
(
FrameListPropertyDescriptor
aProperty
)
const
;
nsFrameList
*
RemovePropTableFrames
(
FrameListPropertyDescriptor
aProperty
)
;
void
SetPropTableFrames
(
nsFrameList
*
aFrameList
FrameListPropertyDescriptor
aProperty
)
;
void
SafelyDestroyFrameListProp
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
nsIPresShell
*
aPresShell
FrameListPropertyDescriptor
aProp
)
;
bool
ResolvedOrientationIsVertical
(
)
;
nsFrameList
mFrames
;
}
;
#
define
IS_TRUE_OVERFLOW_CONTAINER
(
frame
)
\
(
(
frame
-
>
GetStateBits
(
)
&
NS_FRAME_IS_OVERFLOW_CONTAINER
)
\
&
&
!
(
(
frame
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
&
&
\
frame
-
>
IsAbsolutelyPositioned
(
)
)
)
class
nsOverflowContinuationTracker
{
public
:
nsOverflowContinuationTracker
(
nsContainerFrame
*
aFrame
bool
aWalkOOFFrames
bool
aSkipOverflowContainerChildren
=
true
)
;
nsresult
Insert
(
nsIFrame
*
aOverflowCont
nsReflowStatus
&
aReflowStatus
)
;
class
MOZ_RAII
AutoFinish
{
public
:
AutoFinish
(
nsOverflowContinuationTracker
*
aTracker
nsIFrame
*
aChild
)
:
mTracker
(
aTracker
)
mChild
(
aChild
)
{
if
(
mTracker
)
mTracker
-
>
BeginFinish
(
mChild
)
;
}
~
AutoFinish
(
)
{
if
(
mTracker
)
mTracker
-
>
EndFinish
(
mChild
)
;
}
private
:
nsOverflowContinuationTracker
*
mTracker
;
nsIFrame
*
mChild
;
}
;
void
Skip
(
nsIFrame
*
aChild
nsReflowStatus
&
aReflowStatus
)
{
MOZ_ASSERT
(
aChild
"
null
ptr
"
)
;
if
(
aChild
=
=
mSentry
)
{
StepForward
(
)
;
if
(
aReflowStatus
.
IsComplete
(
)
)
{
aReflowStatus
.
SetOverflowIncomplete
(
)
;
}
}
}
private
:
void
BeginFinish
(
nsIFrame
*
aChild
)
;
void
EndFinish
(
nsIFrame
*
aChild
)
;
void
SetupOverflowContList
(
)
;
void
SetUpListWalker
(
)
;
void
StepForward
(
)
;
nsFrameList
*
mOverflowContList
;
nsIFrame
*
mPrevOverflowCont
;
nsIFrame
*
mSentry
;
nsContainerFrame
*
mParent
;
bool
mSkipOverflowContainerChildren
;
bool
mWalkOOFFrames
;
}
;
inline
nsFrameList
*
nsContainerFrame
:
:
GetOverflowFrames
(
)
const
{
nsFrameList
*
list
=
GetProperty
(
OverflowProperty
(
)
)
;
NS_ASSERTION
(
!
list
|
|
!
list
-
>
IsEmpty
(
)
"
Unexpected
empty
overflow
list
"
)
;
return
list
;
}
inline
nsFrameList
*
nsContainerFrame
:
:
StealOverflowFrames
(
)
{
nsFrameList
*
list
=
RemoveProperty
(
OverflowProperty
(
)
)
;
NS_ASSERTION
(
!
list
|
|
!
list
-
>
IsEmpty
(
)
"
Unexpected
empty
overflow
list
"
)
;
return
list
;
}
inline
void
nsContainerFrame
:
:
DestroyOverflowList
(
)
{
nsFrameList
*
list
=
RemovePropTableFrames
(
OverflowProperty
(
)
)
;
MOZ_ASSERT
(
list
&
&
list
-
>
IsEmpty
(
)
)
;
list
-
>
Delete
(
PresShell
(
)
)
;
}
#
endif
