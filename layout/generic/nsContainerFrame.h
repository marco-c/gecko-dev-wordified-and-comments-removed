#
ifndef
nsContainerFrame_h___
#
define
nsContainerFrame_h___
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
nsSplittableFrame
.
h
"
#
include
"
nsFrameList
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsLineBox
.
h
"
class
nsOverflowContinuationTracker
;
namespace
mozilla
{
class
PresShell
;
}
#
ifdef
DEBUG
#
define
CRAZY_COORD
(
10000000
*
60
)
#
define
CRAZY_SIZE
(
_x
)
(
(
(
_x
)
<
-
CRAZY_COORD
)
|
|
(
(
_x
)
>
CRAZY_COORD
)
)
#
endif
class
nsContainerFrame
:
public
nsSplittableFrame
{
public
:
NS_DECL_ABSTRACT_FRAME
(
nsContainerFrame
)
NS_DECL_QUERYFRAME_TARGET
(
nsContainerFrame
)
NS_DECL_QUERYFRAME
virtual
void
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
override
;
virtual
nsContainerFrame
*
GetContentInsertionFrame
(
)
override
{
return
this
;
}
virtual
const
nsFrameList
&
GetChildList
(
ChildListID
aList
)
const
override
;
virtual
void
GetChildLists
(
nsTArray
<
ChildList
>
*
aLists
)
const
override
;
virtual
void
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
override
;
virtual
void
ChildIsDirty
(
nsIFrame
*
aChild
)
override
;
virtual
FrameSearchResult
PeekOffsetNoAmount
(
bool
aForward
int32_t
*
aOffset
)
override
;
virtual
FrameSearchResult
PeekOffsetCharacter
(
bool
aForward
int32_t
*
aOffset
PeekOffsetCharacterOptions
aOptions
=
PeekOffsetCharacterOptions
(
)
)
override
;
#
ifdef
DEBUG_FRAME_DUMP
void
List
(
FILE
*
out
=
stderr
const
char
*
aPrefix
=
"
"
ListFlags
aFlags
=
ListFlags
(
)
)
const
override
;
void
ListWithMatchedRules
(
FILE
*
out
=
stderr
const
char
*
aPrefix
=
"
"
)
const
override
;
void
ListChildLists
(
FILE
*
aOut
const
char
*
aPrefix
ListFlags
aFlags
ChildListIDs
aSkippedListIDs
)
const
;
virtual
void
ExtraContainerFrameInfo
(
nsACString
&
aTo
)
const
;
#
endif
virtual
void
SetInitialChildList
(
ChildListID
aListID
nsFrameList
&
aChildList
)
;
virtual
void
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
;
virtual
void
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
const
nsLineList
:
:
iterator
*
aPrevFrameLine
nsFrameList
&
aFrameList
)
;
virtual
void
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
;
nsIFrame
*
CreateNextInFlow
(
nsIFrame
*
aFrame
)
;
virtual
void
DeleteNextInFlowChild
(
nsIFrame
*
aNextInFlow
bool
aDeletingEmptyFrames
)
;
static
void
PositionFrameView
(
nsIFrame
*
aKidFrame
)
;
static
nsresult
ReparentFrameView
(
nsIFrame
*
aChildFrame
nsIFrame
*
aOldParentFrame
nsIFrame
*
aNewParentFrame
)
;
static
void
ReparentFrameViewList
(
const
nsFrameList
&
aChildFrameList
nsIFrame
*
aOldParentFrame
nsIFrame
*
aNewParentFrame
)
;
static
void
ReparentFrame
(
nsIFrame
*
aFrame
nsContainerFrame
*
aOldParent
nsContainerFrame
*
aNewParent
)
;
static
void
ReparentFrames
(
nsFrameList
&
aFrameList
nsContainerFrame
*
aOldParent
nsContainerFrame
*
aNewParent
)
;
static
void
SyncFrameViewAfterReflow
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
nsView
*
aView
const
nsRect
&
aInkOverflowArea
ReflowChildFlags
aFlags
=
ReflowChildFlags
:
:
Default
)
;
enum
{
SET_ASYNC
=
0x01
}
;
static
void
SyncWindowProperties
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
nsView
*
aView
gfxContext
*
aRC
uint32_t
aFlags
)
;
static
void
SetSizeConstraints
(
nsPresContext
*
aPresContext
nsIWidget
*
aWidget
const
nsSize
&
aMinSize
const
nsSize
&
aMaxSize
)
;
void
DoInlineIntrinsicISize
(
gfxContext
*
aRenderingContext
InlineIntrinsicISizeData
*
aData
nsLayoutUtils
:
:
IntrinsicISizeType
aType
)
;
virtual
mozilla
:
:
LogicalSize
ComputeAutoSize
(
gfxContext
*
aRenderingContext
mozilla
:
:
WritingMode
aWM
const
mozilla
:
:
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
mozilla
:
:
LogicalSize
&
aMargin
const
mozilla
:
:
LogicalSize
&
aBorder
const
mozilla
:
:
LogicalSize
&
aPadding
ComputeSizeFlags
aFlags
)
override
;
void
ReflowChild
(
nsIFrame
*
aKidFrame
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
const
mozilla
:
:
WritingMode
&
aWM
const
mozilla
:
:
LogicalPoint
&
aPos
const
nsSize
&
aContainerSize
ReflowChildFlags
aFlags
nsReflowStatus
&
aStatus
nsOverflowContinuationTracker
*
aTracker
=
nullptr
)
;
static
void
FinishReflowChild
(
nsIFrame
*
aKidFrame
nsPresContext
*
aPresContext
const
ReflowOutput
&
aDesiredSize
const
ReflowInput
*
aReflowInput
const
mozilla
:
:
WritingMode
&
aWM
const
mozilla
:
:
LogicalPoint
&
aPos
const
nsSize
&
aContainerSize
ReflowChildFlags
aFlags
)
;
void
ReflowChild
(
nsIFrame
*
aKidFrame
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nscoord
aX
nscoord
aY
ReflowChildFlags
aFlags
nsReflowStatus
&
aStatus
nsOverflowContinuationTracker
*
aTracker
=
nullptr
)
;
static
void
FinishReflowChild
(
nsIFrame
*
aKidFrame
nsPresContext
*
aPresContext
const
ReflowOutput
&
aDesiredSize
const
ReflowInput
*
aReflowInput
nscoord
aX
nscoord
aY
ReflowChildFlags
aFlags
)
;
static
void
PositionChildViews
(
nsIFrame
*
aFrame
)
;
friend
class
nsOverflowContinuationTracker
;
typedef
void
(
*
ChildFrameMerger
)
(
nsFrameList
&
aDest
nsFrameList
&
aSrc
nsContainerFrame
*
aParent
)
;
static
inline
void
DefaultChildFrameMerge
(
nsFrameList
&
aDest
nsFrameList
&
aSrc
nsContainerFrame
*
aParent
)
{
aDest
.
AppendFrames
(
nullptr
aSrc
)
;
}
void
ReflowOverflowContainerChildren
(
nsPresContext
*
aPresContext
const
ReflowInput
&
aReflowInput
nsOverflowAreas
&
aOverflowRects
ReflowChildFlags
aFlags
nsReflowStatus
&
aStatus
ChildFrameMerger
aMergeFunc
=
DefaultChildFrameMerge
)
;
virtual
bool
DrainSelfOverflowList
(
)
override
;
nsFrameList
*
DrainExcessOverflowContainersList
(
ChildFrameMerger
aMergeFunc
=
DefaultChildFrameMerge
)
;
virtual
nsresult
StealFrame
(
nsIFrame
*
aChild
)
;
nsFrameList
StealFramesAfter
(
nsIFrame
*
aChild
)
;
void
DisplayOverflowContainers
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
;
virtual
void
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
override
;
static
void
PlaceFrameView
(
nsIFrame
*
aFrame
)
{
if
(
aFrame
-
>
HasView
(
)
)
nsContainerFrame
:
:
PositionFrameView
(
aFrame
)
;
else
nsContainerFrame
:
:
PositionChildViews
(
aFrame
)
;
}
virtual
mozilla
:
:
StyleAlignFlags
CSSAlignmentForAbsPosChild
(
const
ReflowInput
&
aChildRI
mozilla
:
:
LogicalAxis
aLogicalAxis
)
const
;
#
define
NS_DECLARE_FRAME_PROPERTY_FRAMELIST
(
prop
)
\
NS_DECLARE_FRAME_PROPERTY_WITH_DTOR_NEVER_CALLED
(
prop
nsFrameList
)
typedef
PropertyDescriptor
<
nsFrameList
>
FrameListPropertyDescriptor
;
NS_DECLARE_FRAME_PROPERTY_FRAMELIST
(
OverflowProperty
)
NS_DECLARE_FRAME_PROPERTY_FRAMELIST
(
OverflowContainersProperty
)
NS_DECLARE_FRAME_PROPERTY_FRAMELIST
(
ExcessOverflowContainersProperty
)
NS_DECLARE_FRAME_PROPERTY_FRAMELIST
(
BackdropProperty
)
NS_DECLARE_FRAME_PROPERTY_WITHOUT_DTOR
(
FirstLetterProperty
nsIFrame
)
void
SetHasFirstLetterChild
(
)
{
mHasFirstLetterChild
=
true
;
}
void
ClearHasFirstLetterChild
(
)
{
mHasFirstLetterChild
=
false
;
}
#
ifdef
DEBUG
NS_DECLARE_FRAME_PROPERTY_SMALL_VALUE
(
DebugReflowingWithInfiniteISize
bool
)
bool
IsCrazySizeAssertSuppressed
(
)
const
{
return
GetProperty
(
DebugReflowingWithInfiniteISize
(
)
)
;
}
#
endif
void
ConsiderChildOverflow
(
nsOverflowAreas
&
aOverflowAreas
nsIFrame
*
aChildFrame
)
;
protected
:
nsContainerFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
ClassID
aID
)
:
nsSplittableFrame
(
aStyle
aPresContext
aID
)
{
}
~
nsContainerFrame
(
)
;
void
DestroyAbsoluteFrames
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
;
bool
MaybeStealOverflowContainerFrame
(
nsIFrame
*
aChild
)
;
void
BuildDisplayListForNonBlockChildren
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
DisplayChildFlags
aFlags
=
{
}
)
;
void
BuildDisplayListForInline
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
DisplayBorderBackgroundOutline
(
aBuilder
aLists
)
;
BuildDisplayListForNonBlockChildren
(
aBuilder
aLists
DisplayChildFlag
:
:
Inline
)
;
}
[
[
nodiscard
]
]
nsFrameList
*
GetOverflowFrames
(
)
const
{
nsFrameList
*
list
=
GetProperty
(
OverflowProperty
(
)
)
;
NS_ASSERTION
(
!
list
|
|
!
list
-
>
IsEmpty
(
)
"
Unexpected
empty
overflow
list
"
)
;
return
list
;
}
[
[
nodiscard
]
]
nsFrameList
*
GetOverflowContainers
(
)
const
{
nsFrameList
*
list
=
GetProperty
(
OverflowContainersProperty
(
)
)
;
NS_ASSERTION
(
!
list
|
|
!
list
-
>
IsEmpty
(
)
"
Unexpected
empty
overflow
containers
list
"
)
;
return
list
;
}
[
[
nodiscard
]
]
nsFrameList
*
GetExcessOverflowContainers
(
)
const
{
nsFrameList
*
list
=
GetProperty
(
ExcessOverflowContainersProperty
(
)
)
;
NS_ASSERTION
(
!
list
|
|
!
list
-
>
IsEmpty
(
)
"
Unexpected
empty
overflow
containers
list
"
)
;
return
list
;
}
[
[
nodiscard
]
]
nsFrameList
*
StealOverflowFrames
(
)
{
nsFrameList
*
list
=
TakeProperty
(
OverflowProperty
(
)
)
;
NS_ASSERTION
(
!
list
|
|
!
list
-
>
IsEmpty
(
)
"
Unexpected
empty
overflow
list
"
)
;
return
list
;
}
[
[
nodiscard
]
]
nsFrameList
*
StealOverflowContainers
(
)
{
nsFrameList
*
list
=
TakeProperty
(
OverflowContainersProperty
(
)
)
;
NS_ASSERTION
(
!
list
|
|
!
list
-
>
IsEmpty
(
)
"
Unexpected
empty
overflow
list
"
)
;
return
list
;
}
[
[
nodiscard
]
]
nsFrameList
*
StealExcessOverflowContainers
(
)
{
nsFrameList
*
list
=
TakeProperty
(
ExcessOverflowContainersProperty
(
)
)
;
NS_ASSERTION
(
!
list
|
|
!
list
-
>
IsEmpty
(
)
"
Unexpected
empty
overflow
list
"
)
;
return
list
;
}
nsFrameList
*
SetOverflowFrames
(
nsFrameList
&
&
aOverflowFrames
)
{
MOZ_ASSERT
(
aOverflowFrames
.
NotEmpty
(
)
"
Shouldn
'
t
be
called
"
)
;
auto
*
list
=
new
(
PresShell
(
)
)
nsFrameList
(
std
:
:
move
(
aOverflowFrames
)
)
;
SetProperty
(
OverflowProperty
(
)
list
)
;
return
list
;
}
nsFrameList
*
SetOverflowContainers
(
nsFrameList
&
&
aOverflowContainers
)
{
MOZ_ASSERT
(
aOverflowContainers
.
NotEmpty
(
)
"
Shouldn
'
t
set
an
empty
list
!
"
)
;
MOZ_ASSERT
(
!
GetProperty
(
OverflowContainersProperty
(
)
)
"
Shouldn
'
t
override
existing
list
!
"
)
;
MOZ_ASSERT
(
IsFrameOfType
(
nsIFrame
:
:
eCanContainOverflowContainers
)
"
This
type
of
frame
can
'
t
have
overflow
containers
!
"
)
;
auto
*
list
=
new
(
PresShell
(
)
)
nsFrameList
(
std
:
:
move
(
aOverflowContainers
)
)
;
SetProperty
(
OverflowContainersProperty
(
)
list
)
;
return
list
;
}
nsFrameList
*
SetExcessOverflowContainers
(
nsFrameList
&
&
aExcessOverflowContainers
)
{
MOZ_ASSERT
(
aExcessOverflowContainers
.
NotEmpty
(
)
"
Shouldn
'
t
set
an
empty
list
!
"
)
;
MOZ_ASSERT
(
!
GetProperty
(
ExcessOverflowContainersProperty
(
)
)
"
Shouldn
'
t
override
existing
list
!
"
)
;
MOZ_ASSERT
(
IsFrameOfType
(
nsIFrame
:
:
eCanContainOverflowContainers
)
"
This
type
of
frame
can
'
t
have
overflow
containers
!
"
)
;
auto
*
list
=
new
(
PresShell
(
)
)
nsFrameList
(
std
:
:
move
(
aExcessOverflowContainers
)
)
;
SetProperty
(
ExcessOverflowContainersProperty
(
)
list
)
;
return
list
;
}
void
DestroyOverflowList
(
)
{
nsFrameList
*
list
=
RemovePropTableFrames
(
OverflowProperty
(
)
)
;
MOZ_ASSERT
(
list
&
&
list
-
>
IsEmpty
(
)
)
;
list
-
>
Delete
(
PresShell
(
)
)
;
}
void
DestroyOverflowContainers
(
)
{
nsFrameList
*
list
=
TakeProperty
(
OverflowContainersProperty
(
)
)
;
MOZ_ASSERT
(
list
&
&
list
-
>
IsEmpty
(
)
)
;
list
-
>
Delete
(
PresShell
(
)
)
;
}
void
DestroyExcessOverflowContainers
(
)
{
nsFrameList
*
list
=
TakeProperty
(
ExcessOverflowContainersProperty
(
)
)
;
MOZ_ASSERT
(
list
&
&
list
-
>
IsEmpty
(
)
)
;
list
-
>
Delete
(
PresShell
(
)
)
;
}
bool
MoveOverflowToChildList
(
)
;
void
MergeSortedOverflow
(
nsFrameList
&
aList
)
;
void
MergeSortedExcessOverflowContainers
(
nsFrameList
&
aList
)
;
static
void
MergeSortedFrameLists
(
nsFrameList
&
aDest
nsFrameList
&
aSrc
nsIContent
*
aCommonAncestor
)
;
static
inline
void
MergeSortedFrameListsFor
(
nsFrameList
&
aDest
nsFrameList
&
aSrc
nsContainerFrame
*
aParent
)
{
MergeSortedFrameLists
(
aDest
aSrc
aParent
-
>
GetContent
(
)
)
;
}
bool
MoveInlineOverflowToChildList
(
nsIFrame
*
aLineContainer
)
;
void
PushChildrenToOverflow
(
nsIFrame
*
aFromChild
nsIFrame
*
aPrevSibling
)
;
void
PushChildren
(
nsIFrame
*
aFromChild
nsIFrame
*
aPrevSibling
)
;
using
FrameHashtable
=
nsTHashtable
<
nsPtrHashKey
<
nsIFrame
>
>
;
bool
PushIncompleteChildren
(
const
FrameHashtable
&
aPushedItems
const
FrameHashtable
&
aIncompleteItems
const
FrameHashtable
&
aOverflowIncompleteItems
)
;
void
NormalizeChildLists
(
)
;
void
NoteNewChildren
(
ChildListID
aListID
const
nsFrameList
&
aFrameList
)
;
bool
DrainAndMergeSelfOverflowList
(
)
;
static
nsIFrame
*
GetFirstNonAnonBoxInSubtree
(
nsIFrame
*
aFrame
)
;
static
void
ReparentFloatsForInlineChild
(
nsIFrame
*
aOurBlock
nsIFrame
*
aFrame
bool
aReparentSiblings
)
;
struct
ContinuationTraversingState
{
nsContainerFrame
*
mNextInFlow
;
explicit
ContinuationTraversingState
(
nsContainerFrame
*
aFrame
)
:
mNextInFlow
(
static_cast
<
nsContainerFrame
*
>
(
aFrame
-
>
GetNextInFlow
(
)
)
)
{
}
}
;
nsIFrame
*
GetNextInFlowChild
(
ContinuationTraversingState
&
aState
bool
*
aIsInOverflow
=
nullptr
)
;
nsIFrame
*
PullNextInFlowChild
(
ContinuationTraversingState
&
aState
)
;
nsFrameList
*
GetPropTableFrames
(
FrameListPropertyDescriptor
aProperty
)
const
;
[
[
nodiscard
]
]
nsFrameList
*
RemovePropTableFrames
(
FrameListPropertyDescriptor
aProperty
)
;
void
SafelyDestroyFrameListProp
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
mozilla
:
:
PresShell
*
aPresShell
FrameListPropertyDescriptor
aProp
)
;
bool
ResolvedOrientationIsVertical
(
)
;
mozilla
:
:
LogicalSize
ComputeSizeWithIntrinsicDimensions
(
gfxContext
*
aRenderingContext
mozilla
:
:
WritingMode
aWM
const
mozilla
:
:
IntrinsicSize
&
aIntrinsicSize
const
mozilla
:
:
AspectRatio
&
aIntrinsicRatio
const
mozilla
:
:
LogicalSize
&
aCBSize
const
mozilla
:
:
LogicalSize
&
aMargin
const
mozilla
:
:
LogicalSize
&
aBorder
const
mozilla
:
:
LogicalSize
&
aPadding
ComputeSizeFlags
aFlags
)
;
nsRect
ComputeSimpleTightBounds
(
mozilla
:
:
gfx
:
:
DrawTarget
*
aDrawTarget
)
const
;
void
PushDirtyBitToAbsoluteFrames
(
)
;
bool
IsFrameTreeTooDeep
(
const
ReflowInput
&
aReflowInput
ReflowOutput
&
aMetrics
nsReflowStatus
&
aStatus
)
;
bool
ShouldAvoidBreakInside
(
const
ReflowInput
&
aReflowInput
)
const
;
void
DisplaySelectionOverlay
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
uint16_t
aContentType
=
nsISelectionDisplay
:
:
DISPLAY_FRAMES
)
;
#
ifdef
DEBUG
void
SanityCheckChildListsBeforeReflow
(
)
const
;
void
SetDidPushItemsBitIfNeeded
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
;
bool
mDidPushItemsBitMayLie
{
false
}
;
#
endif
nsFrameList
mFrames
;
}
;
#
define
IS_TRUE_OVERFLOW_CONTAINER
(
frame
)
\
(
(
frame
)
-
>
HasAnyStateBits
(
NS_FRAME_IS_OVERFLOW_CONTAINER
)
&
&
\
!
(
(
frame
)
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
&
&
\
(
frame
)
-
>
IsAbsolutelyPositioned
(
)
)
)
class
nsOverflowContinuationTracker
{
public
:
nsOverflowContinuationTracker
(
nsContainerFrame
*
aFrame
bool
aWalkOOFFrames
bool
aSkipOverflowContainerChildren
=
true
)
;
nsresult
Insert
(
nsIFrame
*
aOverflowCont
nsReflowStatus
&
aReflowStatus
)
;
class
MOZ_RAII
AutoFinish
{
public
:
AutoFinish
(
nsOverflowContinuationTracker
*
aTracker
nsIFrame
*
aChild
)
:
mTracker
(
aTracker
)
mChild
(
aChild
)
{
if
(
mTracker
)
mTracker
-
>
BeginFinish
(
mChild
)
;
}
~
AutoFinish
(
)
{
if
(
mTracker
)
mTracker
-
>
EndFinish
(
mChild
)
;
}
private
:
nsOverflowContinuationTracker
*
mTracker
;
nsIFrame
*
mChild
;
}
;
void
Skip
(
nsIFrame
*
aChild
nsReflowStatus
&
aReflowStatus
)
{
MOZ_ASSERT
(
aChild
"
null
ptr
"
)
;
if
(
aChild
=
=
mSentry
)
{
StepForward
(
)
;
if
(
aReflowStatus
.
IsComplete
(
)
)
{
aReflowStatus
.
SetOverflowIncomplete
(
)
;
}
}
}
private
:
void
BeginFinish
(
nsIFrame
*
aChild
)
;
void
EndFinish
(
nsIFrame
*
aChild
)
;
void
SetupOverflowContList
(
)
;
void
SetUpListWalker
(
)
;
void
StepForward
(
)
;
nsFrameList
*
mOverflowContList
;
nsIFrame
*
mPrevOverflowCont
;
nsIFrame
*
mSentry
;
nsContainerFrame
*
mParent
;
bool
mSkipOverflowContainerChildren
;
bool
mWalkOOFFrames
;
}
;
#
ifdef
DEBUG
struct
DR_cookie
{
DR_cookie
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
const
mozilla
:
:
ReflowInput
&
aReflowInput
mozilla
:
:
ReflowOutput
&
aMetrics
nsReflowStatus
&
aStatus
)
;
~
DR_cookie
(
)
;
void
Change
(
)
const
;
nsPresContext
*
mPresContext
;
nsIFrame
*
mFrame
;
const
mozilla
:
:
ReflowInput
&
mReflowInput
;
mozilla
:
:
ReflowOutput
&
mMetrics
;
nsReflowStatus
&
mStatus
;
void
*
mValue
;
}
;
struct
DR_layout_cookie
{
explicit
DR_layout_cookie
(
nsIFrame
*
aFrame
)
;
~
DR_layout_cookie
(
)
;
nsIFrame
*
mFrame
;
void
*
mValue
;
}
;
struct
DR_intrinsic_inline_size_cookie
{
DR_intrinsic_inline_size_cookie
(
nsIFrame
*
aFrame
const
char
*
aType
nscoord
&
aResult
)
;
~
DR_intrinsic_inline_size_cookie
(
)
;
nsIFrame
*
mFrame
;
const
char
*
mType
;
nscoord
&
mResult
;
void
*
mValue
;
}
;
struct
DR_intrinsic_size_cookie
{
DR_intrinsic_size_cookie
(
nsIFrame
*
aFrame
const
char
*
aType
nsSize
&
aResult
)
;
~
DR_intrinsic_size_cookie
(
)
;
nsIFrame
*
mFrame
;
const
char
*
mType
;
nsSize
&
mResult
;
void
*
mValue
;
}
;
struct
DR_init_constraints_cookie
{
DR_init_constraints_cookie
(
nsIFrame
*
aFrame
mozilla
:
:
ReflowInput
*
aState
nscoord
aCBWidth
nscoord
aCBHeight
const
nsMargin
*
aMargin
const
nsMargin
*
aPadding
)
;
~
DR_init_constraints_cookie
(
)
;
nsIFrame
*
mFrame
;
mozilla
:
:
ReflowInput
*
mState
;
void
*
mValue
;
}
;
struct
DR_init_offsets_cookie
{
DR_init_offsets_cookie
(
nsIFrame
*
aFrame
mozilla
:
:
SizeComputationInput
*
aState
nscoord
aPercentBasis
mozilla
:
:
WritingMode
aCBWritingMode
const
nsMargin
*
aMargin
const
nsMargin
*
aPadding
)
;
~
DR_init_offsets_cookie
(
)
;
nsIFrame
*
mFrame
;
mozilla
:
:
SizeComputationInput
*
mState
;
void
*
mValue
;
}
;
struct
DR_init_type_cookie
{
DR_init_type_cookie
(
nsIFrame
*
aFrame
mozilla
:
:
ReflowInput
*
aState
)
;
~
DR_init_type_cookie
(
)
;
nsIFrame
*
mFrame
;
mozilla
:
:
ReflowInput
*
mState
;
void
*
mValue
;
}
;
#
define
DISPLAY_REFLOW
(
dr_pres_context
dr_frame
dr_rf_state
\
dr_rf_metrics
dr_rf_status
)
\
DR_cookie
dr_cookie
(
dr_pres_context
dr_frame
dr_rf_state
dr_rf_metrics
\
dr_rf_status
)
;
#
define
DISPLAY_REFLOW_CHANGE
(
)
dr_cookie
.
Change
(
)
;
#
define
DISPLAY_LAYOUT
(
dr_frame
)
DR_layout_cookie
dr_cookie
(
dr_frame
)
;
#
define
DISPLAY_MIN_INLINE_SIZE
(
dr_frame
dr_result
)
\
DR_intrinsic_inline_size_cookie
dr_cookie
(
dr_frame
"
Min
"
dr_result
)
#
define
DISPLAY_PREF_INLINE_SIZE
(
dr_frame
dr_result
)
\
DR_intrinsic_inline_size_cookie
dr_cookie
(
dr_frame
"
Pref
"
dr_result
)
#
define
DISPLAY_PREF_SIZE
(
dr_frame
dr_result
)
\
DR_intrinsic_size_cookie
dr_cookie
(
dr_frame
"
Pref
"
dr_result
)
#
define
DISPLAY_MIN_SIZE
(
dr_frame
dr_result
)
\
DR_intrinsic_size_cookie
dr_cookie
(
dr_frame
"
Min
"
dr_result
)
#
define
DISPLAY_MAX_SIZE
(
dr_frame
dr_result
)
\
DR_intrinsic_size_cookie
dr_cookie
(
dr_frame
"
Max
"
dr_result
)
#
define
DISPLAY_INIT_CONSTRAINTS
(
dr_frame
dr_state
dr_cbw
dr_cbh
dr_bdr
\
dr_pad
)
\
DR_init_constraints_cookie
dr_cookie
(
dr_frame
dr_state
dr_cbw
dr_cbh
\
dr_bdr
dr_pad
)
#
define
DISPLAY_INIT_OFFSETS
(
dr_frame
dr_state
dr_pb
dr_cbwm
dr_bdr
\
dr_pad
)
\
DR_init_offsets_cookie
dr_cookie
(
dr_frame
dr_state
dr_pb
dr_cbwm
\
dr_bdr
dr_pad
)
#
define
DISPLAY_INIT_TYPE
(
dr_frame
dr_result
)
\
DR_init_type_cookie
dr_cookie
(
dr_frame
dr_result
)
#
else
#
define
DISPLAY_REFLOW
(
dr_pres_context
dr_frame
dr_rf_state
\
dr_rf_metrics
dr_rf_status
)
#
define
DISPLAY_REFLOW_CHANGE
(
)
#
define
DISPLAY_LAYOUT
(
dr_frame
)
PR_BEGIN_MACRO
PR_END_MACRO
#
define
DISPLAY_MIN_INLINE_SIZE
(
dr_frame
dr_result
)
\
PR_BEGIN_MACRO
PR_END_MACRO
#
define
DISPLAY_PREF_INLINE_SIZE
(
dr_frame
dr_result
)
\
PR_BEGIN_MACRO
PR_END_MACRO
#
define
DISPLAY_PREF_SIZE
(
dr_frame
dr_result
)
PR_BEGIN_MACRO
PR_END_MACRO
#
define
DISPLAY_MIN_SIZE
(
dr_frame
dr_result
)
PR_BEGIN_MACRO
PR_END_MACRO
#
define
DISPLAY_MAX_SIZE
(
dr_frame
dr_result
)
PR_BEGIN_MACRO
PR_END_MACRO
#
define
DISPLAY_INIT_CONSTRAINTS
(
dr_frame
dr_state
dr_cbw
dr_cbh
dr_bdr
\
dr_pad
)
\
PR_BEGIN_MACRO
PR_END_MACRO
#
define
DISPLAY_INIT_OFFSETS
(
dr_frame
dr_state
dr_pb
dr_cbwm
dr_bdr
\
dr_pad
)
\
PR_BEGIN_MACRO
PR_END_MACRO
#
define
DISPLAY_INIT_TYPE
(
dr_frame
dr_result
)
PR_BEGIN_MACRO
PR_END_MACRO
#
endif
#
endif
