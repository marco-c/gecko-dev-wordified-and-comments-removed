#
ifndef
nsImageFrame_h___
#
define
nsImageFrame_h___
#
include
"
nsAtomicContainerFrame
.
h
"
#
include
"
nsIIOService
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
imgINotificationObserver
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
nsIReflowCallback
.
h
"
#
include
"
nsTObserverArray
.
h
"
class
nsFontMetrics
;
class
nsImageMap
;
class
nsIURI
;
class
nsILoadGroup
;
class
nsDisplayImage
;
class
nsPresContext
;
class
nsImageFrame
;
class
nsTransform2D
;
class
nsImageLoadingContent
;
namespace
mozilla
{
class
PresShell
;
namespace
layers
{
class
ImageContainer
;
class
ImageLayer
;
class
LayerManager
;
}
}
class
nsImageListener
final
:
public
imgINotificationObserver
{
protected
:
virtual
~
nsImageListener
(
)
;
public
:
explicit
nsImageListener
(
nsImageFrame
*
aFrame
)
;
NS_DECL_ISUPPORTS
NS_DECL_IMGINOTIFICATIONOBSERVER
void
SetFrame
(
nsImageFrame
*
frame
)
{
mFrame
=
frame
;
}
private
:
nsImageFrame
*
mFrame
;
}
;
class
nsImageFrame
:
public
nsAtomicContainerFrame
public
nsIReflowCallback
{
public
:
template
<
typename
T
>
using
Maybe
=
mozilla
:
:
Maybe
<
T
>
;
using
Nothing
=
mozilla
:
:
Nothing
;
using
Visibility
=
mozilla
:
:
Visibility
;
typedef
mozilla
:
:
image
:
:
ImgDrawResult
ImgDrawResult
;
typedef
mozilla
:
:
layers
:
:
ImageContainer
ImageContainer
;
typedef
mozilla
:
:
layers
:
:
ImageLayer
ImageLayer
;
typedef
mozilla
:
:
layers
:
:
LayerManager
LayerManager
;
NS_DECL_FRAMEARENA_HELPERS
(
nsImageFrame
)
NS_DECL_QUERYFRAME
virtual
void
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
override
;
virtual
void
DidSetComputedStyle
(
ComputedStyle
*
aOldComputedStyle
)
override
;
virtual
void
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
override
;
virtual
void
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
override
;
virtual
nscoord
GetMinISize
(
gfxContext
*
aRenderingContext
)
override
;
virtual
nscoord
GetPrefISize
(
gfxContext
*
aRenderingContext
)
override
;
virtual
mozilla
:
:
IntrinsicSize
GetIntrinsicSize
(
)
override
;
virtual
nsSize
GetIntrinsicRatio
(
)
override
;
virtual
void
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
override
;
virtual
nsresult
GetContentForEvent
(
mozilla
:
:
WidgetEvent
*
aEvent
nsIContent
*
*
aContent
)
override
;
virtual
nsresult
HandleEvent
(
nsPresContext
*
aPresContext
mozilla
:
:
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
override
;
virtual
nsresult
GetCursor
(
const
nsPoint
&
aPoint
nsIFrame
:
:
Cursor
&
aCursor
)
override
;
virtual
nsresult
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
override
;
void
OnVisibilityChange
(
Visibility
aNewVisibility
const
Maybe
<
OnNonvisible
>
&
aNonvisibleAction
=
Nothing
(
)
)
override
;
void
ResponsiveContentDensityChanged
(
)
;
void
SetupForContentURLRequest
(
)
;
bool
ShouldShowBrokenImageIcon
(
)
const
;
#
ifdef
ACCESSIBILITY
virtual
mozilla
:
:
a11y
:
:
AccType
AccessibleType
(
)
override
;
#
endif
virtual
bool
IsFrameOfType
(
uint32_t
aFlags
)
const
override
{
return
nsAtomicContainerFrame
:
:
IsFrameOfType
(
aFlags
&
~
(
nsIFrame
:
:
eReplaced
|
nsIFrame
:
:
eReplacedSizing
)
)
;
}
#
ifdef
DEBUG_FRAME_DUMP
virtual
nsresult
GetFrameName
(
nsAString
&
aResult
)
const
override
;
void
List
(
FILE
*
out
=
stderr
const
char
*
aPrefix
=
"
"
uint32_t
aFlags
=
0
)
const
override
;
#
endif
virtual
LogicalSides
GetLogicalSkipSides
(
const
ReflowInput
*
aReflowInput
=
nullptr
)
const
override
;
nsresult
GetIntrinsicImageSize
(
nsSize
&
aSize
)
;
static
void
ReleaseGlobals
(
)
{
if
(
gIconLoad
)
{
gIconLoad
-
>
Shutdown
(
)
;
gIconLoad
=
nullptr
;
}
NS_IF_RELEASE
(
sIOService
)
;
}
already_AddRefed
<
imgIRequest
>
GetCurrentRequest
(
)
const
;
nsresult
Notify
(
imgIRequest
*
aRequest
int32_t
aType
const
nsIntRect
*
aData
)
;
static
bool
ShouldCreateImageFrameFor
(
const
mozilla
:
:
dom
:
:
Element
&
aElement
ComputedStyle
&
aStyle
)
;
ImgDrawResult
DisplayAltFeedback
(
gfxContext
&
aRenderingContext
const
nsRect
&
aDirtyRect
nsPoint
aPt
uint32_t
aFlags
)
;
ImgDrawResult
DisplayAltFeedbackWithoutLayer
(
nsDisplayItem
*
aItem
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
mozilla
:
:
layers
:
:
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
nsPoint
aPt
uint32_t
aFlags
)
;
nsRect
GetInnerArea
(
)
const
;
mozilla
:
:
dom
:
:
Element
*
GetMapElement
(
)
const
;
bool
HasImageMap
(
)
const
{
return
mImageMap
|
|
GetMapElement
(
)
;
}
nsImageMap
*
GetImageMap
(
)
;
nsImageMap
*
GetExistingImageMap
(
)
const
{
return
mImageMap
;
}
virtual
void
AddInlineMinISize
(
gfxContext
*
aRenderingContext
InlineMinISizeData
*
aData
)
override
;
void
DisconnectMap
(
)
;
virtual
bool
ReflowFinished
(
)
override
;
virtual
void
ReflowCallbackCanceled
(
)
override
;
enum
class
Kind
:
uint8_t
{
ImageElement
ContentProperty
ContentPropertyAtIndex
}
;
nsImageFrame
*
CreateContinuingFrame
(
nsIPresShell
*
ComputedStyle
*
)
const
;
private
:
friend
nsIFrame
*
NS_NewImageFrame
(
nsIPresShell
*
ComputedStyle
*
)
;
friend
nsIFrame
*
NS_NewImageFrameForContentProperty
(
nsIPresShell
*
ComputedStyle
*
)
;
friend
nsIFrame
*
NS_NewImageFrameForGeneratedContentIndex
(
nsIPresShell
*
ComputedStyle
*
)
;
nsImageFrame
(
ComputedStyle
*
aStyle
Kind
aKind
)
:
nsImageFrame
(
aStyle
kClassID
aKind
)
{
}
nsImageFrame
(
ComputedStyle
*
ClassID
Kind
)
;
protected
:
nsImageFrame
(
ComputedStyle
*
aStyle
ClassID
aID
)
:
nsImageFrame
(
aStyle
aID
Kind
:
:
ImageElement
)
{
}
virtual
~
nsImageFrame
(
)
;
void
EnsureIntrinsicSizeAndRatio
(
)
;
bool
GotInitialReflow
(
)
const
{
return
!
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
;
}
virtual
mozilla
:
:
LogicalSize
ComputeSize
(
gfxContext
*
aRenderingContext
mozilla
:
:
WritingMode
aWritingMode
const
mozilla
:
:
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
mozilla
:
:
LogicalSize
&
aMargin
const
mozilla
:
:
LogicalSize
&
aBorder
const
mozilla
:
:
LogicalSize
&
aPadding
ComputeSizeFlags
aFlags
)
override
;
bool
IsServerImageMap
(
)
;
void
TranslateEventCoords
(
const
nsPoint
&
aPoint
nsIntPoint
&
aResult
)
;
bool
GetAnchorHREFTargetAndNode
(
nsIURI
*
*
aHref
nsString
&
aTarget
nsIContent
*
*
aNode
)
;
nscoord
MeasureString
(
const
char16_t
*
aString
int32_t
aLength
nscoord
aMaxWidth
uint32_t
&
aMaxFit
gfxContext
&
aContext
nsFontMetrics
&
aFontMetrics
)
;
void
DisplayAltText
(
nsPresContext
*
aPresContext
gfxContext
&
aRenderingContext
const
nsString
&
aAltText
const
nsRect
&
aRect
)
;
ImgDrawResult
PaintImage
(
gfxContext
&
aRenderingContext
nsPoint
aPt
const
nsRect
&
aDirtyRect
imgIContainer
*
aImage
uint32_t
aFlags
)
;
void
MaybeDecodeForPredictedSize
(
)
;
protected
:
friend
class
nsImageListener
;
friend
class
nsImageLoadingContent
;
friend
class
mozilla
:
:
PresShell
;
nsresult
OnSizeAvailable
(
imgIRequest
*
aRequest
imgIContainer
*
aImage
)
;
nsresult
OnFrameUpdate
(
imgIRequest
*
aRequest
const
nsIntRect
*
aRect
)
;
nsresult
OnLoadComplete
(
imgIRequest
*
aRequest
nsresult
aStatus
)
;
void
NotifyNewCurrentRequest
(
imgIRequest
*
aRequest
nsresult
aStatus
)
;
void
SetForceSyncDecoding
(
bool
aForce
)
{
mForceSyncDecoding
=
aForce
;
}
nsRect
PredictedDestRect
(
const
nsRect
&
aFrameContentBox
)
;
private
:
inline
void
SpecToURI
(
const
nsAString
&
aSpec
nsIIOService
*
aIOService
nsIURI
*
*
aURI
)
;
inline
void
GetLoadGroup
(
nsPresContext
*
aPresContext
nsILoadGroup
*
*
aLoadGroup
)
;
nscoord
GetContinuationOffset
(
)
const
;
void
GetDocumentCharacterSet
(
nsACString
&
aCharset
)
const
;
bool
ShouldDisplaySelection
(
)
;
bool
UpdateIntrinsicSize
(
imgIContainer
*
aImage
)
;
bool
UpdateIntrinsicRatio
(
imgIContainer
*
aImage
)
;
bool
GetSourceToDestTransform
(
nsTransform2D
&
aTransform
)
;
bool
IsPendingLoad
(
imgIRequest
*
aRequest
)
const
;
nsRect
SourceRectToDest
(
const
nsIntRect
&
aRect
)
;
void
InvalidateSelf
(
const
nsIntRect
*
aLayerInvalidRect
const
nsRect
*
aFrameInvalidRect
)
;
RefPtr
<
nsImageMap
>
mImageMap
;
RefPtr
<
nsImageListener
>
mListener
;
RefPtr
<
imgRequestProxy
>
mContentURLRequest
;
nsCOMPtr
<
imgIContainer
>
mImage
;
nsCOMPtr
<
imgIContainer
>
mPrevImage
;
nsSize
mComputedSize
;
mozilla
:
:
IntrinsicSize
mIntrinsicSize
;
nsSize
mIntrinsicRatio
;
const
Kind
mKind
;
bool
mContentURLRequestRegistered
;
bool
mDisplayingIcon
;
bool
mFirstFrameComplete
;
bool
mReflowCallbackPosted
;
bool
mForceSyncDecoding
;
static
nsIIOService
*
sIOService
;
nsresult
LoadIcons
(
nsPresContext
*
aPresContext
)
;
nsresult
LoadIcon
(
const
nsAString
&
aSpec
nsPresContext
*
aPresContext
imgRequestProxy
*
*
aRequest
)
;
class
IconLoad
final
:
public
nsIObserver
public
imgINotificationObserver
{
public
:
IconLoad
(
)
;
void
Shutdown
(
)
;
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
NS_DECL_IMGINOTIFICATIONOBSERVER
void
AddIconObserver
(
nsImageFrame
*
frame
)
{
MOZ_ASSERT
(
!
mIconObservers
.
Contains
(
frame
)
"
Observer
shouldn
'
t
aleady
be
in
array
"
)
;
mIconObservers
.
AppendElement
(
frame
)
;
}
void
RemoveIconObserver
(
nsImageFrame
*
frame
)
{
mozilla
:
:
DebugOnly
<
bool
>
didRemove
=
mIconObservers
.
RemoveElement
(
frame
)
;
MOZ_ASSERT
(
didRemove
"
Observer
not
in
array
"
)
;
}
private
:
~
IconLoad
(
)
{
}
void
GetPrefs
(
)
;
nsTObserverArray
<
nsImageFrame
*
>
mIconObservers
;
public
:
RefPtr
<
imgRequestProxy
>
mLoadingImage
;
RefPtr
<
imgRequestProxy
>
mBrokenImage
;
bool
mPrefForceInlineAltText
;
bool
mPrefShowPlaceholders
;
bool
mPrefShowLoadingPlaceholder
;
}
;
public
:
static
mozilla
:
:
StaticRefPtr
<
IconLoad
>
gIconLoad
;
friend
class
nsDisplayImage
;
}
;
class
nsDisplayImage
final
:
public
nsDisplayImageContainer
{
public
:
typedef
mozilla
:
:
layers
:
:
LayerManager
LayerManager
;
nsDisplayImage
(
nsDisplayListBuilder
*
aBuilder
nsImageFrame
*
aFrame
imgIContainer
*
aImage
imgIContainer
*
aPrevImage
)
:
nsDisplayImageContainer
(
aBuilder
aFrame
)
mImage
(
aImage
)
mPrevImage
(
aPrevImage
)
{
MOZ_COUNT_CTOR
(
nsDisplayImage
)
;
}
virtual
~
nsDisplayImage
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayImage
)
;
}
virtual
nsDisplayItemGeometry
*
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
override
;
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
;
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
;
virtual
already_AddRefed
<
imgIContainer
>
GetImage
(
)
override
;
virtual
nsRect
GetDestRect
(
)
const
override
;
virtual
void
UpdateDrawResult
(
mozilla
:
:
image
:
:
ImgDrawResult
aResult
)
override
{
nsDisplayItemGenericImageGeometry
:
:
UpdateDrawResult
(
this
aResult
)
;
}
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
;
nsRect
GetBounds
(
bool
*
aSnap
)
const
{
*
aSnap
=
true
;
nsImageFrame
*
imageFrame
=
static_cast
<
nsImageFrame
*
>
(
mFrame
)
;
return
imageFrame
-
>
GetInnerArea
(
)
+
ToReferenceFrame
(
)
;
}
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
{
return
GetBounds
(
aSnap
)
;
}
virtual
nsRegion
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
;
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
NS_DISPLAY_DECL_NAME
(
"
Image
"
TYPE_IMAGE
)
private
:
nsCOMPtr
<
imgIContainer
>
mImage
;
nsCOMPtr
<
imgIContainer
>
mPrevImage
;
}
;
#
endif
