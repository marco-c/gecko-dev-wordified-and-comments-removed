#
ifndef
nsImageFrame_h___
#
define
nsImageFrame_h___
#
include
"
nsAtomicContainerFrame
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
imgINotificationObserver
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
nsIReflowCallback
.
h
"
#
include
"
nsTObserverArray
.
h
"
class
nsFontMetrics
;
class
nsImageMap
;
class
nsIURI
;
class
nsILoadGroup
;
class
nsPresContext
;
class
nsImageFrame
;
class
nsTransform2D
;
class
nsImageLoadingContent
;
namespace
mozilla
{
class
nsDisplayImage
;
class
PresShell
;
namespace
layers
{
class
ImageContainer
;
class
LayerManager
;
}
}
class
nsImageListener
final
:
public
imgINotificationObserver
{
protected
:
virtual
~
nsImageListener
(
)
;
public
:
explicit
nsImageListener
(
nsImageFrame
*
aFrame
)
;
NS_DECL_ISUPPORTS
NS_DECL_IMGINOTIFICATIONOBSERVER
void
SetFrame
(
nsImageFrame
*
frame
)
{
mFrame
=
frame
;
}
private
:
nsImageFrame
*
mFrame
;
}
;
class
nsImageFrame
:
public
nsAtomicContainerFrame
public
nsIReflowCallback
{
public
:
template
<
typename
T
>
using
Maybe
=
mozilla
:
:
Maybe
<
T
>
;
using
Nothing
=
mozilla
:
:
Nothing
;
using
Visibility
=
mozilla
:
:
Visibility
;
typedef
mozilla
:
:
image
:
:
ImgDrawResult
ImgDrawResult
;
typedef
mozilla
:
:
layers
:
:
ImageContainer
ImageContainer
;
typedef
mozilla
:
:
layers
:
:
LayerManager
LayerManager
;
NS_DECL_FRAMEARENA_HELPERS
(
nsImageFrame
)
NS_DECL_QUERYFRAME
void
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
)
override
;
void
DidSetComputedStyle
(
ComputedStyle
*
aOldStyle
)
final
;
void
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
override
;
void
BuildDisplayList
(
nsDisplayListBuilder
*
const
nsDisplayListSet
&
)
final
;
nscoord
GetMinISize
(
gfxContext
*
aRenderingContext
)
final
;
nscoord
GetPrefISize
(
gfxContext
*
aRenderingContext
)
final
;
mozilla
:
:
IntrinsicSize
GetIntrinsicSize
(
)
final
{
return
mIntrinsicSize
;
}
mozilla
:
:
AspectRatio
GetIntrinsicRatio
(
)
const
final
{
return
mIntrinsicRatio
;
}
void
Reflow
(
nsPresContext
*
ReflowOutput
&
const
ReflowInput
&
nsReflowStatus
&
)
override
;
bool
IsLeafDynamic
(
)
const
override
;
nsresult
GetContentForEvent
(
const
mozilla
:
:
WidgetEvent
*
nsIContent
*
*
aContent
)
final
;
nsresult
HandleEvent
(
nsPresContext
*
mozilla
:
:
WidgetGUIEvent
*
nsEventStatus
*
)
override
;
mozilla
:
:
Maybe
<
Cursor
>
GetCursor
(
const
nsPoint
&
)
override
;
nsresult
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
final
;
void
OnVisibilityChange
(
Visibility
aNewVisibility
const
Maybe
<
OnNonvisible
>
&
aNonvisibleAction
=
Nothing
(
)
)
final
;
void
ResponsiveContentDensityChanged
(
)
;
void
SetupForContentURLRequest
(
)
;
bool
ShouldShowBrokenImageIcon
(
)
const
;
bool
IsForElement
(
)
const
{
return
mKind
=
=
Kind
:
:
ImageElement
;
}
const
mozilla
:
:
StyleImage
*
GetImageFromStyle
(
)
const
;
#
ifdef
ACCESSIBILITY
mozilla
:
:
a11y
:
:
AccType
AccessibleType
(
)
override
;
#
endif
bool
IsFrameOfType
(
uint32_t
aFlags
)
const
final
{
return
nsAtomicContainerFrame
:
:
IsFrameOfType
(
aFlags
&
~
(
nsIFrame
:
:
eReplaced
|
nsIFrame
:
:
eReplacedSizing
)
)
;
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
GetFrameName
(
nsAString
&
aResult
)
const
override
;
void
List
(
FILE
*
out
=
stderr
const
char
*
aPrefix
=
"
"
ListFlags
aFlags
=
ListFlags
(
)
)
const
final
;
#
endif
LogicalSides
GetLogicalSkipSides
(
)
const
final
;
static
void
ReleaseGlobals
(
)
{
if
(
gIconLoad
)
{
gIconLoad
-
>
Shutdown
(
)
;
gIconLoad
=
nullptr
;
}
}
nsresult
RestartAnimation
(
)
;
nsresult
StopAnimation
(
)
;
already_AddRefed
<
imgIRequest
>
GetCurrentRequest
(
)
const
;
void
Notify
(
imgIRequest
*
int32_t
aType
const
nsIntRect
*
aData
)
;
static
bool
ShouldCreateImageFrameForContent
(
const
mozilla
:
:
dom
:
:
Element
&
const
ComputedStyle
&
)
;
static
bool
ShouldCreateImageFrameFor
(
const
mozilla
:
:
dom
:
:
Element
&
const
ComputedStyle
&
)
;
ImgDrawResult
DisplayAltFeedback
(
gfxContext
&
aRenderingContext
const
nsRect
&
aDirtyRect
nsPoint
aPt
uint32_t
aFlags
)
;
ImgDrawResult
DisplayAltFeedbackWithoutLayer
(
nsDisplayItem
*
mozilla
:
:
wr
:
:
DisplayListBuilder
&
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
const
mozilla
:
:
layers
:
:
StackingContextHelper
&
mozilla
:
:
layers
:
:
RenderRootStateManager
*
nsDisplayListBuilder
*
nsPoint
aPt
uint32_t
aFlags
)
;
mozilla
:
:
dom
:
:
Element
*
GetMapElement
(
)
const
;
bool
HasImageMap
(
)
const
{
return
mImageMap
|
|
GetMapElement
(
)
;
}
nsImageMap
*
GetImageMap
(
)
;
nsImageMap
*
GetExistingImageMap
(
)
const
{
return
mImageMap
;
}
void
AddInlineMinISize
(
gfxContext
*
aRenderingContext
InlineMinISizeData
*
aData
)
final
;
void
DisconnectMap
(
)
;
bool
ReflowFinished
(
)
final
;
void
ReflowCallbackCanceled
(
)
final
;
enum
class
Kind
:
uint8_t
{
ImageElement
ContentProperty
ContentPropertyAtIndex
ListStyleImage
}
;
nsImageFrame
*
CreateContinuingFrame
(
mozilla
:
:
PresShell
*
ComputedStyle
*
)
const
;
private
:
friend
nsIFrame
*
NS_NewImageFrame
(
mozilla
:
:
PresShell
*
ComputedStyle
*
)
;
friend
nsIFrame
*
NS_NewImageFrameForContentProperty
(
mozilla
:
:
PresShell
*
ComputedStyle
*
)
;
friend
nsIFrame
*
NS_NewImageFrameForGeneratedContentIndex
(
mozilla
:
:
PresShell
*
ComputedStyle
*
)
;
friend
nsIFrame
*
NS_NewImageFrameForListStyleImage
(
mozilla
:
:
PresShell
*
ComputedStyle
*
)
;
nsImageFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
Kind
aKind
)
:
nsImageFrame
(
aStyle
aPresContext
kClassID
aKind
)
{
}
nsImageFrame
(
ComputedStyle
*
nsPresContext
*
aPresContext
ClassID
Kind
)
;
void
ReflowChildren
(
nsPresContext
*
const
ReflowInput
&
const
mozilla
:
:
LogicalSize
&
aImageSize
)
;
protected
:
nsImageFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
ClassID
aID
)
:
nsImageFrame
(
aStyle
aPresContext
aID
Kind
:
:
ImageElement
)
{
}
~
nsImageFrame
(
)
override
;
void
EnsureIntrinsicSizeAndRatio
(
)
;
bool
GotInitialReflow
(
)
const
{
return
!
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
;
}
SizeComputationResult
ComputeSize
(
gfxContext
*
aRenderingContext
mozilla
:
:
WritingMode
aWM
const
mozilla
:
:
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
mozilla
:
:
LogicalSize
&
aMargin
const
mozilla
:
:
LogicalSize
&
aBorderPadding
const
mozilla
:
:
StyleSizeOverrides
&
aSizeOverrides
mozilla
:
:
ComputeSizeFlags
aFlags
)
final
;
bool
IsServerImageMap
(
)
;
mozilla
:
:
CSSIntPoint
TranslateEventCoords
(
const
nsPoint
&
aPoint
)
;
bool
GetAnchorHREFTargetAndNode
(
nsIURI
*
*
aHref
nsString
&
aTarget
nsIContent
*
*
aNode
)
;
nscoord
MeasureString
(
const
char16_t
*
aString
int32_t
aLength
nscoord
aMaxWidth
uint32_t
&
aMaxFit
gfxContext
&
aContext
nsFontMetrics
&
aFontMetrics
)
;
void
DisplayAltText
(
nsPresContext
*
aPresContext
gfxContext
&
aRenderingContext
const
nsString
&
aAltText
const
nsRect
&
aRect
)
;
ImgDrawResult
PaintImage
(
gfxContext
&
aRenderingContext
nsPoint
aPt
const
nsRect
&
aDirtyRect
imgIContainer
*
aImage
uint32_t
aFlags
)
;
void
MaybeDecodeForPredictedSize
(
)
;
bool
IsForMarkerPseudo
(
)
const
;
protected
:
friend
class
nsImageListener
;
friend
class
nsImageLoadingContent
;
friend
class
mozilla
:
:
PresShell
;
void
OnSizeAvailable
(
imgIRequest
*
aRequest
imgIContainer
*
aImage
)
;
void
OnFrameUpdate
(
imgIRequest
*
aRequest
const
nsIntRect
*
aRect
)
;
void
OnLoadComplete
(
imgIRequest
*
aRequest
nsresult
aStatus
)
;
void
NotifyNewCurrentRequest
(
imgIRequest
*
aRequest
nsresult
aStatus
)
;
void
SetForceSyncDecoding
(
bool
aForce
)
{
mForceSyncDecoding
=
aForce
;
}
nsRect
PredictedDestRect
(
const
nsRect
&
aFrameContentBox
)
;
private
:
void
MaybeRecordContentUrlOnImageTelemetry
(
)
;
inline
void
SpecToURI
(
const
nsAString
&
aSpec
nsIURI
*
*
aURI
)
;
inline
void
GetLoadGroup
(
nsPresContext
*
aPresContext
nsILoadGroup
*
*
aLoadGroup
)
;
nscoord
GetContinuationOffset
(
)
const
;
void
GetDocumentCharacterSet
(
nsACString
&
aCharset
)
const
;
bool
ShouldDisplaySelection
(
)
;
bool
ShouldUseMappedAspectRatio
(
)
const
;
bool
UpdateIntrinsicSize
(
)
;
bool
UpdateIntrinsicRatio
(
)
;
bool
GetSourceToDestTransform
(
nsTransform2D
&
aTransform
)
;
bool
IsPendingLoad
(
imgIRequest
*
)
const
;
void
UpdateImage
(
imgIRequest
*
imgIContainer
*
)
;
nsRect
SourceRectToDest
(
const
nsIntRect
&
aRect
)
;
void
InvalidateSelf
(
const
nsIntRect
*
aLayerInvalidRect
const
nsRect
*
aFrameInvalidRect
)
;
RefPtr
<
nsImageMap
>
mImageMap
;
RefPtr
<
nsImageListener
>
mListener
;
RefPtr
<
imgRequestProxy
>
mContentURLRequest
;
nsCOMPtr
<
imgIContainer
>
mImage
;
nsCOMPtr
<
imgIContainer
>
mPrevImage
;
nsSize
mComputedSize
;
mozilla
:
:
IntrinsicSize
mIntrinsicSize
;
mozilla
:
:
AspectRatio
mIntrinsicRatio
;
const
Kind
mKind
;
bool
mContentURLRequestRegistered
;
bool
mDisplayingIcon
;
bool
mFirstFrameComplete
;
bool
mReflowCallbackPosted
;
bool
mForceSyncDecoding
;
nsresult
LoadIcons
(
nsPresContext
*
aPresContext
)
;
nsresult
LoadIcon
(
const
nsAString
&
aSpec
nsPresContext
*
aPresContext
imgRequestProxy
*
*
aRequest
)
;
class
IconLoad
final
:
public
nsIObserver
public
imgINotificationObserver
{
public
:
IconLoad
(
)
;
void
Shutdown
(
)
;
NS_DECL_ISUPPORTS
NS_DECL_NSIOBSERVER
NS_DECL_IMGINOTIFICATIONOBSERVER
void
AddIconObserver
(
nsImageFrame
*
frame
)
{
MOZ_ASSERT
(
!
mIconObservers
.
Contains
(
frame
)
"
Observer
shouldn
'
t
aleady
be
in
array
"
)
;
mIconObservers
.
AppendElement
(
frame
)
;
}
void
RemoveIconObserver
(
nsImageFrame
*
frame
)
{
mozilla
:
:
DebugOnly
<
bool
>
didRemove
=
mIconObservers
.
RemoveElement
(
frame
)
;
MOZ_ASSERT
(
didRemove
"
Observer
not
in
array
"
)
;
}
private
:
~
IconLoad
(
)
=
default
;
void
GetPrefs
(
)
;
nsTObserverArray
<
nsImageFrame
*
>
mIconObservers
;
public
:
RefPtr
<
imgRequestProxy
>
mLoadingImage
;
RefPtr
<
imgRequestProxy
>
mBrokenImage
;
bool
mPrefForceInlineAltText
;
bool
mPrefShowPlaceholders
;
bool
mPrefShowLoadingPlaceholder
;
}
;
public
:
static
mozilla
:
:
StaticRefPtr
<
IconLoad
>
gIconLoad
;
friend
class
mozilla
:
:
nsDisplayImage
;
friend
class
nsDisplayGradient
;
}
;
namespace
mozilla
{
class
nsDisplayImage
final
:
public
nsPaintedDisplayItem
{
public
:
typedef
mozilla
:
:
layers
:
:
LayerManager
LayerManager
;
nsDisplayImage
(
nsDisplayListBuilder
*
aBuilder
nsImageFrame
*
aFrame
imgIContainer
*
aImage
imgIContainer
*
aPrevImage
)
:
nsPaintedDisplayItem
(
aBuilder
aFrame
)
mImage
(
aImage
)
mPrevImage
(
aPrevImage
)
{
MOZ_COUNT_CTOR
(
nsDisplayImage
)
;
}
~
nsDisplayImage
(
)
final
{
MOZ_COUNT_DTOR
(
nsDisplayImage
)
;
}
void
Paint
(
nsDisplayListBuilder
*
gfxContext
*
aCtx
)
final
;
nsRect
GetDestRect
(
)
const
;
nsRect
GetBounds
(
bool
*
aSnap
)
const
{
*
aSnap
=
true
;
return
Frame
(
)
-
>
GetContentRectRelativeToSelf
(
)
+
ToReferenceFrame
(
)
;
}
nsRect
GetBounds
(
nsDisplayListBuilder
*
bool
*
aSnap
)
const
final
{
return
GetBounds
(
aSnap
)
;
}
nsRegion
GetOpaqueRegion
(
nsDisplayListBuilder
*
bool
*
aSnap
)
const
final
;
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
const
StackingContextHelper
&
mozilla
:
:
layers
:
:
RenderRootStateManager
*
nsDisplayListBuilder
*
)
final
;
NS_DISPLAY_DECL_NAME
(
"
Image
"
TYPE_IMAGE
)
private
:
nsCOMPtr
<
imgIContainer
>
mImage
;
nsCOMPtr
<
imgIContainer
>
mPrevImage
;
}
;
}
#
endif
