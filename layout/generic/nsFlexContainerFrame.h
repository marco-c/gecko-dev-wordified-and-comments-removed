#
ifndef
nsFlexContainerFrame_h___
#
define
nsFlexContainerFrame_h___
#
include
"
nsContainerFrame
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
dom
/
FlexBinding
.
h
"
namespace
mozilla
{
template
<
class
T
>
class
LinkedList
;
class
LogicalPoint
;
class
PresShell
;
}
nsContainerFrame
*
NS_NewFlexContainerFrame
(
mozilla
:
:
PresShell
*
aPresShell
mozilla
:
:
ComputedStyle
*
aStyle
)
;
struct
ComputedFlexItemInfo
{
nsCOMPtr
<
nsINode
>
mNode
;
nsRect
mFrameRect
;
nscoord
mMainBaseSize
;
nscoord
mMainDeltaSize
;
nscoord
mMainMinSize
;
nscoord
mMainMaxSize
;
nscoord
mCrossMinSize
;
nscoord
mCrossMaxSize
;
mozilla
:
:
dom
:
:
FlexItemClampState
mClampState
;
}
;
struct
ComputedFlexLineInfo
{
nsTArray
<
ComputedFlexItemInfo
>
mItems
;
nscoord
mCrossStart
;
nscoord
mCrossSize
;
nscoord
mFirstBaselineOffset
;
nscoord
mLastBaselineOffset
;
mozilla
:
:
dom
:
:
FlexLineGrowthState
mGrowthState
;
}
;
struct
ComputedFlexContainerInfo
{
nsTArray
<
ComputedFlexLineInfo
>
mLines
;
mozilla
:
:
dom
:
:
FlexPhysicalDirection
mMainAxisDirection
;
mozilla
:
:
dom
:
:
FlexPhysicalDirection
mCrossAxisDirection
;
}
;
class
nsFlexContainerFrame
final
:
public
nsContainerFrame
{
public
:
NS_DECL_FRAMEARENA_HELPERS
(
nsFlexContainerFrame
)
NS_DECL_QUERYFRAME
friend
nsContainerFrame
*
NS_NewFlexContainerFrame
(
mozilla
:
:
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
class
FlexItem
;
class
FlexLine
;
class
FlexboxAxisTracker
;
struct
StrutInfo
;
class
CachedMeasuringReflowResult
;
void
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
override
;
void
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
override
;
void
MarkIntrinsicISizesDirty
(
)
override
;
void
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
override
;
nscoord
GetMinISize
(
gfxContext
*
aRenderingContext
)
override
;
nscoord
GetPrefISize
(
gfxContext
*
aRenderingContext
)
override
;
#
ifdef
DEBUG_FRAME_DUMP
nsresult
GetFrameName
(
nsAString
&
aResult
)
const
override
;
#
endif
nscoord
GetLogicalBaseline
(
mozilla
:
:
WritingMode
aWM
)
const
override
;
bool
GetVerticalAlignBaseline
(
mozilla
:
:
WritingMode
aWM
nscoord
*
aBaseline
)
const
override
{
return
GetNaturalBaselineBOffset
(
aWM
BaselineSharingGroup
:
:
First
aBaseline
)
;
}
bool
GetNaturalBaselineBOffset
(
mozilla
:
:
WritingMode
aWM
BaselineSharingGroup
aBaselineGroup
nscoord
*
aBaseline
)
const
override
{
if
(
HasAnyStateBits
(
NS_STATE_FLEX_SYNTHESIZE_BASELINE
)
)
{
return
false
;
}
*
aBaseline
=
aBaselineGroup
=
=
BaselineSharingGroup
:
:
First
?
mBaselineFromLastReflow
:
mLastBaselineFromLastReflow
;
return
true
;
}
uint32_t
GetLineClampValue
(
)
const
;
uint16_t
CSSAlignmentForAbsPosChild
(
const
ReflowInput
&
aChildRI
mozilla
:
:
LogicalAxis
aLogicalAxis
)
const
override
;
static
void
CalculatePackingSpace
(
uint32_t
aNumThingsToPack
uint8_t
aAlignVal
nscoord
*
aFirstSubjectOffset
uint32_t
*
aNumPackingSpacesRemaining
nscoord
*
aPackingSpaceRemaining
)
;
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
FlexContainerInfo
ComputedFlexContainerInfo
)
const
ComputedFlexContainerInfo
*
GetFlexContainerInfo
(
)
{
const
ComputedFlexContainerInfo
*
info
=
GetProperty
(
FlexContainerInfo
(
)
)
;
NS_WARNING_ASSERTION
(
info
"
Property
generation
wasn
'
t
requested
.
"
"
This
is
a
known
issue
in
Print
Preview
.
"
"
See
Bug
1157012
.
"
)
;
return
info
;
}
void
CreateOrClearFlexContainerInfo
(
)
;
static
void
CreateFlexLineAndFlexItemInfo
(
ComputedFlexContainerInfo
&
aContainerInfo
const
mozilla
:
:
LinkedList
<
FlexLine
>
&
aLines
)
;
static
void
ComputeFlexDirections
(
ComputedFlexContainerInfo
&
aContainerInfo
const
FlexboxAxisTracker
&
aAxisTracker
)
;
static
void
UpdateFlexLineAndItemInfo
(
ComputedFlexContainerInfo
&
aContainerInfo
const
mozilla
:
:
LinkedList
<
FlexLine
>
&
aLines
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
static
nsFlexContainerFrame
*
GetFlexFrameWithComputedInfo
(
nsIFrame
*
aFrame
)
;
static
bool
IsItemInlineAxisMainAxis
(
nsIFrame
*
aFrame
)
;
static
bool
IsUsedFlexBasisContent
(
const
StyleFlexBasis
&
aFlexBasis
const
StyleSize
&
aMainSize
)
;
static
void
MarkCachedFlexMeasurementsDirty
(
nsIFrame
*
aItemFrame
)
;
protected
:
explicit
nsFlexContainerFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
:
nsContainerFrame
(
aStyle
aPresContext
kClassID
)
{
}
virtual
~
nsFlexContainerFrame
(
)
;
void
DoFlexLayout
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
nscoord
aContentBoxMainSize
nscoord
aAvailableBSizeForContent
nsTArray
<
StrutInfo
>
&
aStruts
const
FlexboxAxisTracker
&
aAxisTracker
nscoord
aMainGapSize
nscoord
aCrossGapSize
bool
aHasLineClampEllipsis
)
;
template
<
bool
IsLessThanOrEqual
(
nsIFrame
*
nsIFrame
*
)
>
bool
SortChildrenIfNeeded
(
)
;
#
ifdef
DEBUG
void
SanityCheckAnonymousFlexItems
(
)
const
;
#
endif
mozilla
:
:
UniquePtr
<
FlexItem
>
GenerateFlexItemForChild
(
nsPresContext
*
aPresContext
nsIFrame
*
aChildFrame
const
ReflowInput
&
aParentReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
bool
aHasLineClampEllipsis
)
;
const
CachedMeasuringReflowResult
&
MeasureAscentAndBSizeForFlexItem
(
FlexItem
&
aItem
nsPresContext
*
aPresContext
ReflowInput
&
aChildReflowInput
)
;
nscoord
MeasureFlexItemContentBSize
(
nsPresContext
*
aPresContext
FlexItem
&
aFlexItem
bool
aForceBResizeForMeasuringReflow
bool
aHasLineClampEllipsis
const
ReflowInput
&
aParentReflowInput
)
;
void
ResolveAutoFlexBasisAndMinSize
(
nsPresContext
*
aPresContext
FlexItem
&
aFlexItem
const
ReflowInput
&
aItemReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
bool
aHasLineClampEllipsis
)
;
bool
ShouldUseMozBoxCollapseBehavior
(
const
nsStyleDisplay
*
aFlexStyleDisp
)
;
void
GenerateFlexLines
(
nsPresContext
*
aPresContext
const
ReflowInput
&
aReflowInput
nscoord
aContentBoxMainSize
nscoord
aAvailableBSizeForContent
const
nsTArray
<
StrutInfo
>
&
aStruts
const
FlexboxAxisTracker
&
aAxisTracker
nscoord
aMainGapSize
bool
aHasLineClampEllipsis
nsTArray
<
nsIFrame
*
>
&
aPlaceholders
mozilla
:
:
LinkedList
<
FlexLine
>
&
aLines
)
;
nscoord
GetMainSizeFromReflowInput
(
const
ReflowInput
&
aReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
)
;
nscoord
ComputeCrossSize
(
const
ReflowInput
&
aReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
nscoord
aSumLineCrossSizes
nscoord
aAvailableBSizeForContent
bool
*
aIsDefinite
nsReflowStatus
&
aStatus
)
;
void
SizeItemInCrossAxis
(
nsPresContext
*
aPresContext
ReflowInput
&
aChildReflowInput
FlexItem
&
aItem
)
;
void
MoveFlexItemToFinalPosition
(
const
ReflowInput
&
aReflowInput
const
FlexItem
&
aItem
mozilla
:
:
LogicalPoint
&
aFramePos
const
nsSize
&
aContainerSize
)
;
void
ReflowFlexItem
(
nsPresContext
*
aPresContext
const
FlexboxAxisTracker
&
aAxisTracker
const
ReflowInput
&
aReflowInput
const
FlexItem
&
aItem
mozilla
:
:
LogicalPoint
&
aFramePos
const
nsSize
&
aContainerSize
bool
aHasLineClampEllipsis
)
;
void
ReflowPlaceholders
(
nsPresContext
*
aPresContext
const
ReflowInput
&
aReflowInput
nsTArray
<
nsIFrame
*
>
&
aPlaceholders
const
mozilla
:
:
LogicalPoint
&
aContentBoxOrigin
const
nsSize
&
aContainerSize
)
;
nscoord
IntrinsicISize
(
gfxContext
*
aRenderingContext
nsLayoutUtils
:
:
IntrinsicISizeType
aType
)
;
nscoord
mCachedMinISize
=
NS_INTRINSIC_ISIZE_UNKNOWN
;
nscoord
mCachedPrefISize
=
NS_INTRINSIC_ISIZE_UNKNOWN
;
nscoord
mBaselineFromLastReflow
=
NS_INTRINSIC_ISIZE_UNKNOWN
;
nscoord
mLastBaselineFromLastReflow
=
NS_INTRINSIC_ISIZE_UNKNOWN
;
}
;
#
endif
