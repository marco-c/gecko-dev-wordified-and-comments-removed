#
ifndef
nsFlexContainerFrame_h___
#
define
nsFlexContainerFrame_h___
#
include
<
tuple
>
#
include
"
mozilla
/
dom
/
FlexBinding
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsContainerFrame
.
h
"
namespace
mozilla
{
class
LogicalPoint
;
class
PresShell
;
}
nsContainerFrame
*
NS_NewFlexContainerFrame
(
mozilla
:
:
PresShell
*
aPresShell
mozilla
:
:
ComputedStyle
*
aStyle
)
;
struct
ComputedFlexItemInfo
{
nsCOMPtr
<
nsINode
>
mNode
;
nsRect
mFrameRect
;
nscoord
mMainBaseSize
;
nscoord
mMainDeltaSize
;
nscoord
mMainMinSize
;
nscoord
mMainMaxSize
;
nscoord
mCrossMinSize
;
nscoord
mCrossMaxSize
;
mozilla
:
:
dom
:
:
FlexItemClampState
mClampState
;
}
;
struct
ComputedFlexLineInfo
{
nsTArray
<
ComputedFlexItemInfo
>
mItems
;
nscoord
mCrossStart
;
nscoord
mCrossSize
;
nscoord
mFirstBaselineOffset
;
nscoord
mLastBaselineOffset
;
mozilla
:
:
dom
:
:
FlexLineGrowthState
mGrowthState
;
}
;
struct
ComputedFlexContainerInfo
{
nsTArray
<
ComputedFlexLineInfo
>
mLines
;
mozilla
:
:
dom
:
:
FlexPhysicalDirection
mMainAxisDirection
;
mozilla
:
:
dom
:
:
FlexPhysicalDirection
mCrossAxisDirection
;
}
;
class
MOZ_STACK_CLASS
FlexboxAxisInfo
final
{
public
:
explicit
FlexboxAxisInfo
(
const
nsIFrame
*
aFlexContainer
)
;
bool
mIsRowOriented
=
true
;
bool
mIsMainAxisReversed
=
false
;
bool
mIsCrossAxisReversed
=
false
;
private
:
void
InitAxesFromLegacyProps
(
const
nsIFrame
*
aFlexContainer
)
;
void
InitAxesFromModernProps
(
const
nsIFrame
*
aFlexContainer
)
;
}
;
class
nsFlexContainerFrame
final
:
public
nsContainerFrame
{
public
:
NS_DECL_FRAMEARENA_HELPERS
(
nsFlexContainerFrame
)
NS_DECL_QUERYFRAME
friend
nsContainerFrame
*
NS_NewFlexContainerFrame
(
mozilla
:
:
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
class
FlexItem
;
class
FlexLine
;
class
FlexboxAxisTracker
;
struct
StrutInfo
;
class
CachedBAxisMeasurement
;
class
CachedFlexItemData
;
struct
SharedFlexData
;
class
FlexItemIterator
;
void
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
override
;
bool
IsFrameOfType
(
uint32_t
aFlags
)
const
override
{
return
nsContainerFrame
:
:
IsFrameOfType
(
aFlags
&
~
(
nsIFrame
:
:
eCanContainOverflowContainers
)
)
;
}
void
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
override
;
void
MarkIntrinsicISizesDirty
(
)
override
;
void
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aReflowOutput
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
override
;
nscoord
GetMinISize
(
gfxContext
*
aRenderingContext
)
override
;
nscoord
GetPrefISize
(
gfxContext
*
aRenderingContext
)
override
;
#
ifdef
DEBUG_FRAME_DUMP
nsresult
GetFrameName
(
nsAString
&
aResult
)
const
override
;
#
endif
nscoord
GetLogicalBaseline
(
mozilla
:
:
WritingMode
aWM
)
const
override
;
bool
GetVerticalAlignBaseline
(
mozilla
:
:
WritingMode
aWM
nscoord
*
aBaseline
)
const
override
{
return
GetNaturalBaselineBOffset
(
aWM
BaselineSharingGroup
:
:
First
aBaseline
)
;
}
bool
GetNaturalBaselineBOffset
(
mozilla
:
:
WritingMode
aWM
BaselineSharingGroup
aBaselineGroup
nscoord
*
aBaseline
)
const
override
{
if
(
HasAnyStateBits
(
NS_STATE_FLEX_SYNTHESIZE_BASELINE
)
)
{
return
false
;
}
*
aBaseline
=
aBaselineGroup
=
=
BaselineSharingGroup
:
:
First
?
mBaselineFromLastReflow
:
mLastBaselineFromLastReflow
;
return
true
;
}
uint32_t
GetLineClampValue
(
)
const
;
bool
DrainSelfOverflowList
(
)
override
;
void
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
override
;
void
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
const
nsLineList
:
:
iterator
*
aPrevFrameLine
nsFrameList
&
aFrameList
)
override
;
void
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
override
;
mozilla
:
:
StyleAlignFlags
CSSAlignmentForAbsPosChild
(
const
ReflowInput
&
aChildRI
mozilla
:
:
LogicalAxis
aLogicalAxis
)
const
override
;
static
void
CalculatePackingSpace
(
uint32_t
aNumThingsToPack
const
mozilla
:
:
StyleContentDistribution
&
aAlignVal
nscoord
*
aFirstSubjectOffset
uint32_t
*
aNumPackingSpacesRemaining
nscoord
*
aPackingSpaceRemaining
)
;
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
FlexContainerInfo
ComputedFlexContainerInfo
)
const
ComputedFlexContainerInfo
*
GetFlexContainerInfo
(
)
{
const
ComputedFlexContainerInfo
*
info
=
GetProperty
(
FlexContainerInfo
(
)
)
;
NS_WARNING_ASSERTION
(
info
"
Property
generation
wasn
'
t
requested
.
"
"
This
is
a
known
issue
in
Print
Preview
.
"
"
See
Bug
1157012
.
"
)
;
return
info
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
static
nsFlexContainerFrame
*
GetFlexFrameWithComputedInfo
(
nsIFrame
*
aFrame
)
;
static
bool
IsItemInlineAxisMainAxis
(
nsIFrame
*
aFrame
)
;
static
bool
IsUsedFlexBasisContent
(
const
StyleFlexBasis
&
aFlexBasis
const
StyleSize
&
aMainSize
)
;
static
void
MarkCachedFlexMeasurementsDirty
(
nsIFrame
*
aItemFrame
)
;
protected
:
explicit
nsFlexContainerFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
:
nsContainerFrame
(
aStyle
aPresContext
kClassID
)
{
}
virtual
~
nsFlexContainerFrame
(
)
;
void
DoFlexLayout
(
const
ReflowInput
&
aReflowInput
nscoord
&
aContentBoxMainSize
nscoord
&
aContentBoxCrossSize
nscoord
&
aFlexContainerAscent
nsTArray
<
FlexLine
>
&
aLines
nsTArray
<
StrutInfo
>
&
aStruts
nsTArray
<
nsIFrame
*
>
&
aPlaceholders
const
FlexboxAxisTracker
&
aAxisTracker
nscoord
aMainGapSize
nscoord
aCrossGapSize
bool
aHasLineClampEllipsis
ComputedFlexContainerInfo
*
const
aContainerInfo
)
;
ComputedFlexContainerInfo
*
CreateOrClearFlexContainerInfo
(
)
;
static
void
CreateFlexLineAndFlexItemInfo
(
ComputedFlexContainerInfo
&
aContainerInfo
const
nsTArray
<
FlexLine
>
&
aLines
)
;
static
void
ComputeFlexDirections
(
ComputedFlexContainerInfo
&
aContainerInfo
const
FlexboxAxisTracker
&
aAxisTracker
)
;
static
void
UpdateFlexLineAndItemInfo
(
ComputedFlexContainerInfo
&
aContainerInfo
const
nsTArray
<
FlexLine
>
&
aLines
)
;
#
ifdef
DEBUG
void
SanityCheckAnonymousFlexItems
(
)
const
;
#
endif
FlexItem
*
GenerateFlexItemForChild
(
FlexLine
&
aLine
nsIFrame
*
aChildFrame
const
ReflowInput
&
aParentReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
bool
aHasLineClampEllipsis
)
;
const
CachedBAxisMeasurement
&
MeasureAscentAndBSizeForFlexItem
(
FlexItem
&
aItem
ReflowInput
&
aChildReflowInput
)
;
nscoord
MeasureFlexItemContentBSize
(
FlexItem
&
aFlexItem
bool
aForceBResizeForMeasuringReflow
bool
aHasLineClampEllipsis
const
ReflowInput
&
aParentReflowInput
)
;
void
ResolveAutoFlexBasisAndMinSize
(
FlexItem
&
aFlexItem
const
ReflowInput
&
aItemReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
bool
aHasLineClampEllipsis
)
;
bool
ShouldUseMozBoxCollapseBehavior
(
const
nsStyleDisplay
*
aFlexStyleDisp
)
;
void
GenerateFlexLines
(
const
ReflowInput
&
aReflowInput
nscoord
aContentBoxMainSize
const
nsTArray
<
StrutInfo
>
&
aStruts
const
FlexboxAxisTracker
&
aAxisTracker
nscoord
aMainGapSize
bool
aHasLineClampEllipsis
nsTArray
<
nsIFrame
*
>
&
aPlaceholders
nsTArray
<
FlexLine
>
&
aLines
)
;
void
GenerateFlexLines
(
const
SharedFlexData
&
aData
nsTArray
<
FlexLine
>
&
aLines
)
;
nscoord
GetMainSizeFromReflowInput
(
const
ReflowInput
&
aReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
)
;
nscoord
ComputeMainSize
(
const
ReflowInput
&
aReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
nscoord
aTentativeMainSize
nsTArray
<
FlexLine
>
&
aLines
)
const
;
nscoord
ComputeCrossSize
(
const
ReflowInput
&
aReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
nscoord
aSumLineCrossSizes
bool
*
aIsDefinite
)
const
;
mozilla
:
:
LogicalSize
ComputeAvailableSizeForItems
(
const
ReflowInput
&
aReflowInput
const
mozilla
:
:
LogicalMargin
&
aBorderPadding
)
const
;
void
SizeItemInCrossAxis
(
ReflowInput
&
aChildReflowInput
FlexItem
&
aItem
)
;
void
PopulateReflowOutput
(
ReflowOutput
&
aReflowOutput
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
const
mozilla
:
:
LogicalSize
&
aContentBoxSize
const
mozilla
:
:
LogicalMargin
&
aBorderPadding
const
nscoord
aConsumedBSize
const
bool
aMayNeedNextInFlow
const
nscoord
aMaxBlockEndEdgeOfChildren
const
bool
aAnyChildIncomplete
nscoord
aFlexContainerAscent
nsTArray
<
FlexLine
>
&
aLines
const
FlexboxAxisTracker
&
aAxisTracker
)
;
std
:
:
tuple
<
nscoord
bool
>
ReflowChildren
(
const
ReflowInput
&
aReflowInput
const
nscoord
aContentBoxMainSize
const
nscoord
aContentBoxCrossSize
const
mozilla
:
:
LogicalSize
&
aAvailableSizeForItems
const
mozilla
:
:
LogicalMargin
&
aBorderPadding
const
nscoord
aSumOfPrevInFlowsChildrenBlockSize
nscoord
&
aFlexContainerAscent
nsTArray
<
FlexLine
>
&
aLines
nsTArray
<
nsIFrame
*
>
&
aPlaceholders
const
FlexboxAxisTracker
&
aAxisTracker
bool
aHasLineClampEllipsis
)
;
void
MoveFlexItemToFinalPosition
(
const
ReflowInput
&
aReflowInput
const
FlexItem
&
aItem
mozilla
:
:
LogicalPoint
&
aFramePos
const
nsSize
&
aContainerSize
)
;
nsReflowStatus
ReflowFlexItem
(
const
FlexboxAxisTracker
&
aAxisTracker
const
ReflowInput
&
aReflowInput
const
FlexItem
&
aItem
mozilla
:
:
LogicalPoint
&
aFramePos
const
mozilla
:
:
LogicalSize
&
aAvailableSize
const
nsSize
&
aContainerSize
bool
aHasLineClampEllipsis
)
;
void
ReflowPlaceholders
(
const
ReflowInput
&
aReflowInput
nsTArray
<
nsIFrame
*
>
&
aPlaceholders
const
mozilla
:
:
LogicalPoint
&
aContentBoxOrigin
const
nsSize
&
aContainerSize
)
;
nscoord
IntrinsicISize
(
gfxContext
*
aRenderingContext
nsLayoutUtils
:
:
IntrinsicISizeType
aType
)
;
nscoord
mCachedMinISize
=
NS_INTRINSIC_ISIZE_UNKNOWN
;
nscoord
mCachedPrefISize
=
NS_INTRINSIC_ISIZE_UNKNOWN
;
nscoord
mBaselineFromLastReflow
=
NS_INTRINSIC_ISIZE_UNKNOWN
;
nscoord
mLastBaselineFromLastReflow
=
NS_INTRINSIC_ISIZE_UNKNOWN
;
}
;
#
endif
