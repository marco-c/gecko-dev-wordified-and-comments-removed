#
ifndef
nsFlexContainerFrame_h___
#
define
nsFlexContainerFrame_h___
#
include
"
nsContainerFrame
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
namespace
mozilla
{
template
<
class
T
>
class
LinkedList
;
class
LogicalPoint
;
}
nsContainerFrame
*
NS_NewFlexContainerFrame
(
nsIPresShell
*
aPresShell
nsStyleContext
*
aContext
)
;
struct
ComputedFlexItemInfo
{
nsCOMPtr
<
nsINode
>
mNode
;
nscoord
mMainBaseSize
;
nscoord
mMainDeltaSize
;
nscoord
mMainMinSize
;
nscoord
mMainMaxSize
;
nscoord
mCrossMinSize
;
nscoord
mCrossMaxSize
;
}
;
struct
ComputedFlexLineInfo
{
nsTArray
<
ComputedFlexItemInfo
>
mItems
;
nscoord
mCrossStart
;
nscoord
mCrossSize
;
nscoord
mFirstBaselineOffset
;
nscoord
mLastBaselineOffset
;
enum
GrowthState
{
UNCHANGED
SHRINKING
GROWING
}
mGrowthState
;
}
;
struct
ComputedFlexContainerInfo
{
nsTArray
<
ComputedFlexLineInfo
>
mLines
;
}
;
class
nsFlexContainerFrame
final
:
public
nsContainerFrame
{
public
:
NS_DECL_FRAMEARENA_HELPERS
(
nsFlexContainerFrame
)
NS_DECL_QUERYFRAME
friend
nsContainerFrame
*
NS_NewFlexContainerFrame
(
nsIPresShell
*
aPresShell
nsStyleContext
*
aContext
)
;
class
FlexItem
;
class
FlexLine
;
class
FlexboxAxisTracker
;
struct
StrutInfo
;
class
CachedMeasuringReflowResult
;
void
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
override
;
void
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
override
;
void
MarkIntrinsicISizesDirty
(
)
override
;
void
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
override
;
nscoord
GetMinISize
(
gfxContext
*
aRenderingContext
)
override
;
nscoord
GetPrefISize
(
gfxContext
*
aRenderingContext
)
override
;
#
ifdef
DEBUG_FRAME_DUMP
nsresult
GetFrameName
(
nsAString
&
aResult
)
const
override
;
#
endif
nscoord
GetLogicalBaseline
(
mozilla
:
:
WritingMode
aWM
)
const
override
;
bool
GetVerticalAlignBaseline
(
mozilla
:
:
WritingMode
aWM
nscoord
*
aBaseline
)
const
override
{
return
GetNaturalBaselineBOffset
(
aWM
BaselineSharingGroup
:
:
eFirst
aBaseline
)
;
}
bool
GetNaturalBaselineBOffset
(
mozilla
:
:
WritingMode
aWM
BaselineSharingGroup
aBaselineGroup
nscoord
*
aBaseline
)
const
override
{
if
(
HasAnyStateBits
(
NS_STATE_FLEX_SYNTHESIZE_BASELINE
)
)
{
return
false
;
}
*
aBaseline
=
aBaselineGroup
=
=
BaselineSharingGroup
:
:
eFirst
?
mBaselineFromLastReflow
:
mLastBaselineFromLastReflow
;
return
true
;
}
uint16_t
CSSAlignmentForAbsPosChild
(
const
ReflowInput
&
aChildRI
mozilla
:
:
LogicalAxis
aLogicalAxis
)
const
override
;
bool
IsHorizontal
(
)
;
static
void
CalculatePackingSpace
(
uint32_t
aNumThingsToPack
uint8_t
aAlignVal
nscoord
*
aFirstSubjectOffset
uint32_t
*
aNumPackingSpacesRemaining
nscoord
*
aPackingSpaceRemaining
)
;
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
FlexContainerInfo
ComputedFlexContainerInfo
)
const
ComputedFlexContainerInfo
*
GetFlexContainerInfo
(
)
{
const
ComputedFlexContainerInfo
*
info
=
GetProperty
(
FlexContainerInfo
(
)
)
;
MOZ_ASSERT
(
info
"
Property
generation
wasn
'
t
requested
.
"
)
;
return
info
;
}
static
nsFlexContainerFrame
*
GetFlexFrameWithComputedInfo
(
nsIFrame
*
aFrame
)
;
protected
:
explicit
nsFlexContainerFrame
(
nsStyleContext
*
aContext
)
:
nsContainerFrame
(
aContext
kClassID
)
mBaselineFromLastReflow
(
NS_INTRINSIC_WIDTH_UNKNOWN
)
mLastBaselineFromLastReflow
(
NS_INTRINSIC_WIDTH_UNKNOWN
)
{
}
virtual
~
nsFlexContainerFrame
(
)
;
void
DoFlexLayout
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
nscoord
aContentBoxMainSize
nscoord
aAvailableBSizeForContent
nsTArray
<
StrutInfo
>
&
aStruts
const
FlexboxAxisTracker
&
aAxisTracker
)
;
template
<
bool
IsLessThanOrEqual
(
nsIFrame
*
nsIFrame
*
)
>
bool
SortChildrenIfNeeded
(
)
;
#
ifdef
DEBUG
void
SanityCheckAnonymousFlexItems
(
)
const
;
#
endif
mozilla
:
:
UniquePtr
<
FlexItem
>
GenerateFlexItemForChild
(
nsPresContext
*
aPresContext
nsIFrame
*
aChildFrame
const
ReflowInput
&
aParentReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
)
;
const
CachedMeasuringReflowResult
&
MeasureAscentAndBSizeForFlexItem
(
FlexItem
&
aItem
nsPresContext
*
aPresContext
ReflowInput
&
aChildReflowInput
)
;
nscoord
MeasureFlexItemContentBSize
(
nsPresContext
*
aPresContext
FlexItem
&
aFlexItem
bool
aForceBResizeForMeasuringReflow
const
ReflowInput
&
aParentReflowInput
)
;
void
ResolveAutoFlexBasisAndMinSize
(
nsPresContext
*
aPresContext
FlexItem
&
aFlexItem
const
ReflowInput
&
aItemReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
)
;
bool
ShouldUseMozBoxCollapseBehavior
(
const
nsStyleDisplay
*
aFlexStyleDisp
)
;
void
GenerateFlexLines
(
nsPresContext
*
aPresContext
const
ReflowInput
&
aReflowInput
nscoord
aContentBoxMainSize
nscoord
aAvailableBSizeForContent
const
nsTArray
<
StrutInfo
>
&
aStruts
const
FlexboxAxisTracker
&
aAxisTracker
nsTArray
<
nsIFrame
*
>
&
aPlaceholders
mozilla
:
:
LinkedList
<
FlexLine
>
&
aLines
)
;
nscoord
GetMainSizeFromReflowInput
(
const
ReflowInput
&
aReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
)
;
nscoord
ComputeCrossSize
(
const
ReflowInput
&
aReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
nscoord
aSumLineCrossSizes
nscoord
aAvailableBSizeForContent
bool
*
aIsDefinite
nsReflowStatus
&
aStatus
)
;
void
SizeItemInCrossAxis
(
nsPresContext
*
aPresContext
const
FlexboxAxisTracker
&
aAxisTracker
ReflowInput
&
aChildReflowInput
FlexItem
&
aItem
)
;
void
MoveFlexItemToFinalPosition
(
const
ReflowInput
&
aReflowInput
const
FlexItem
&
aItem
mozilla
:
:
LogicalPoint
&
aFramePos
const
nsSize
&
aContainerSize
)
;
void
ReflowFlexItem
(
nsPresContext
*
aPresContext
const
FlexboxAxisTracker
&
aAxisTracker
const
ReflowInput
&
aReflowInput
const
FlexItem
&
aItem
mozilla
:
:
LogicalPoint
&
aFramePos
const
nsSize
&
aContainerSize
)
;
void
ReflowPlaceholders
(
nsPresContext
*
aPresContext
const
ReflowInput
&
aReflowInput
nsTArray
<
nsIFrame
*
>
&
aPlaceholders
const
mozilla
:
:
LogicalPoint
&
aContentBoxOrigin
const
nsSize
&
aContainerSize
)
;
nscoord
mBaselineFromLastReflow
;
nscoord
mLastBaselineFromLastReflow
;
}
;
#
endif
