#
ifndef
mozilla_ReflowInput_h
#
define
mozilla_ReflowInput_h
#
include
"
nsMargin
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
EnumSet
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
WritingModes
.
h
"
#
include
"
LayoutConstants
.
h
"
#
include
"
ReflowOutput
.
h
"
#
include
<
algorithm
>
class
gfxContext
;
class
nsFloatManager
;
struct
nsHypotheticalPosition
;
class
nsIPercentBSizeObserver
;
class
nsLineLayout
;
class
nsPlaceholderFrame
;
class
nsPresContext
;
class
nsReflowStatus
;
namespace
mozilla
{
enum
class
LayoutFrameType
:
uint8_t
;
}
template
<
class
NumericType
>
NumericType
NS_CSS_MINMAX
(
NumericType
aValue
NumericType
aMinValue
NumericType
aMaxValue
)
{
NumericType
result
=
aValue
;
if
(
aMaxValue
<
result
)
result
=
aMaxValue
;
if
(
aMinValue
>
result
)
result
=
aMinValue
;
return
result
;
}
typedef
uint32_t
nsCSSFrameType
;
#
define
NS_CSS_FRAME_TYPE_UNKNOWN
0
#
define
NS_CSS_FRAME_TYPE_INLINE
1
#
define
NS_CSS_FRAME_TYPE_BLOCK
2
/
*
block
-
level
in
normal
flow
*
/
#
define
NS_CSS_FRAME_TYPE_FLOATING
3
#
define
NS_CSS_FRAME_TYPE_ABSOLUTE
4
#
define
NS_CSS_FRAME_TYPE_INTERNAL_TABLE
\
5
/
*
row
group
frame
row
frame
cell
frame
.
.
.
*
/
#
define
NS_CSS_FRAME_TYPE_REPLACED
0x08000
#
define
NS_CSS_FRAME_TYPE_REPLACED_CONTAINS_BLOCK
0x10000
#
define
NS_FRAME_IS_REPLACED_NOBLOCK
(
_ft
)
\
(
NS_CSS_FRAME_TYPE_REPLACED
=
=
(
(
_ft
)
&
NS_CSS_FRAME_TYPE_REPLACED
)
)
#
define
NS_FRAME_IS_REPLACED
(
_ft
)
\
(
NS_FRAME_IS_REPLACED_NOBLOCK
(
_ft
)
|
|
\
NS_FRAME_IS_REPLACED_CONTAINS_BLOCK
(
_ft
)
)
#
define
NS_FRAME_REPLACED
(
_ft
)
(
NS_CSS_FRAME_TYPE_REPLACED
|
(
_ft
)
)
#
define
NS_FRAME_IS_REPLACED_CONTAINS_BLOCK
(
_ft
)
\
(
NS_CSS_FRAME_TYPE_REPLACED_CONTAINS_BLOCK
=
=
\
(
(
_ft
)
&
NS_CSS_FRAME_TYPE_REPLACED_CONTAINS_BLOCK
)
)
#
define
NS_FRAME_REPLACED_CONTAINS_BLOCK
(
_ft
)
\
(
NS_CSS_FRAME_TYPE_REPLACED_CONTAINS_BLOCK
|
(
_ft
)
)
#
define
NS_FRAME_GET_TYPE
(
_ft
)
\
(
(
_ft
)
&
\
~
(
NS_CSS_FRAME_TYPE_REPLACED
|
NS_CSS_FRAME_TYPE_REPLACED_CONTAINS_BLOCK
)
)
namespace
mozilla
{
struct
SizeComputationInput
{
public
:
typedef
mozilla
:
:
WritingMode
WritingMode
;
typedef
mozilla
:
:
LogicalMargin
LogicalMargin
;
nsIFrame
*
mFrame
;
gfxContext
*
mRenderingContext
;
const
nsMargin
&
ComputedPhysicalMargin
(
)
const
{
return
mComputedMargin
;
}
const
nsMargin
&
ComputedPhysicalBorderPadding
(
)
const
{
return
mComputedBorderPadding
;
}
const
nsMargin
&
ComputedPhysicalPadding
(
)
const
{
return
mComputedPadding
;
}
nsMargin
&
ComputedPhysicalMargin
(
)
{
return
mComputedMargin
;
}
nsMargin
&
ComputedPhysicalBorderPadding
(
)
{
return
mComputedBorderPadding
;
}
nsMargin
&
ComputedPhysicalPadding
(
)
{
return
mComputedPadding
;
}
LogicalMargin
ComputedLogicalMargin
(
)
const
{
return
LogicalMargin
(
mWritingMode
mComputedMargin
)
;
}
LogicalMargin
ComputedLogicalBorderPadding
(
)
const
{
return
LogicalMargin
(
mWritingMode
mComputedBorderPadding
)
;
}
LogicalMargin
ComputedLogicalPadding
(
)
const
{
return
LogicalMargin
(
mWritingMode
mComputedPadding
)
;
}
void
SetComputedLogicalMargin
(
mozilla
:
:
WritingMode
aWM
const
LogicalMargin
&
aMargin
)
{
mComputedMargin
=
aMargin
.
GetPhysicalMargin
(
aWM
)
;
}
void
SetComputedLogicalMargin
(
const
LogicalMargin
&
aMargin
)
{
SetComputedLogicalMargin
(
mWritingMode
aMargin
)
;
}
void
SetComputedLogicalBorderPadding
(
mozilla
:
:
WritingMode
aWM
const
LogicalMargin
&
aMargin
)
{
mComputedBorderPadding
=
aMargin
.
GetPhysicalMargin
(
aWM
)
;
}
void
SetComputedLogicalBorderPadding
(
const
LogicalMargin
&
aMargin
)
{
SetComputedLogicalBorderPadding
(
mWritingMode
aMargin
)
;
}
void
SetComputedLogicalPadding
(
mozilla
:
:
WritingMode
aWM
const
LogicalMargin
&
aMargin
)
{
mComputedPadding
=
aMargin
.
GetPhysicalMargin
(
aWM
)
;
}
void
SetComputedLogicalPadding
(
const
LogicalMargin
&
aMargin
)
{
SetComputedLogicalPadding
(
mWritingMode
aMargin
)
;
}
WritingMode
GetWritingMode
(
)
const
{
return
mWritingMode
;
}
protected
:
WritingMode
mWritingMode
;
nsMargin
mComputedMargin
;
nsMargin
mComputedBorderPadding
;
nsMargin
mComputedPadding
;
public
:
SizeComputationInput
(
nsIFrame
*
aFrame
gfxContext
*
aRenderingContext
)
;
SizeComputationInput
(
nsIFrame
*
aFrame
gfxContext
*
aRenderingContext
mozilla
:
:
WritingMode
aContainingBlockWritingMode
nscoord
aContainingBlockISize
)
;
#
ifdef
DEBUG
static
void
*
DisplayInitOffsetsEnter
(
nsIFrame
*
aFrame
SizeComputationInput
*
aState
nscoord
aPercentBasis
WritingMode
aCBWritingMode
const
nsMargin
*
aBorder
const
nsMargin
*
aPadding
)
;
static
void
DisplayInitOffsetsExit
(
nsIFrame
*
aFrame
SizeComputationInput
*
aState
void
*
aValue
)
;
#
endif
private
:
bool
ComputeMargin
(
mozilla
:
:
WritingMode
aWM
nscoord
aPercentBasis
)
;
bool
ComputePadding
(
mozilla
:
:
WritingMode
aWM
nscoord
aPercentBasis
mozilla
:
:
LayoutFrameType
aFrameType
)
;
protected
:
void
InitOffsets
(
mozilla
:
:
WritingMode
aWM
nscoord
aPercentBasis
mozilla
:
:
LayoutFrameType
aFrameType
mozilla
:
:
ComputeSizeFlags
aFlags
=
{
}
const
nsMargin
*
aBorder
=
nullptr
const
nsMargin
*
aPadding
=
nullptr
const
nsStyleDisplay
*
aDisplay
=
nullptr
)
;
template
<
typename
SizeOrMaxSize
>
inline
nscoord
ComputeISizeValue
(
nscoord
aContainingBlockISize
nscoord
aContentEdgeToBoxSizing
nscoord
aBoxSizingToMarginEdge
const
SizeOrMaxSize
&
)
const
;
template
<
typename
SizeOrMaxSize
>
inline
nscoord
ComputeISizeValue
(
nscoord
aContainingBlockISize
mozilla
:
:
StyleBoxSizing
aBoxSizing
const
SizeOrMaxSize
&
)
const
;
nscoord
ComputeBSizeValue
(
nscoord
aContainingBlockBSize
mozilla
:
:
StyleBoxSizing
aBoxSizing
const
mozilla
:
:
LengthPercentage
&
aCoord
)
const
;
}
;
struct
ReflowInput
:
public
SizeComputationInput
{
const
ReflowInput
*
mParentReflowInput
=
nullptr
;
nsFloatManager
*
mFloatManager
=
nullptr
;
nsLineLayout
*
mLineLayout
=
nullptr
;
const
ReflowInput
*
mCBReflowInput
=
nullptr
;
nsCSSFrameType
mFrameType
=
NS_CSS_FRAME_TYPE_UNKNOWN
;
nscoord
mBlockDelta
=
0
;
nscoord
mOrthogonalLimit
=
NS_UNCONSTRAINEDSIZE
;
nscoord
AvailableWidth
(
)
const
{
return
mAvailableWidth
;
}
nscoord
AvailableHeight
(
)
const
{
return
mAvailableHeight
;
}
nscoord
ComputedWidth
(
)
const
{
return
mComputedWidth
;
}
nscoord
ComputedHeight
(
)
const
{
return
mComputedHeight
;
}
nscoord
ComputedMinWidth
(
)
const
{
return
mComputedMinWidth
;
}
nscoord
ComputedMaxWidth
(
)
const
{
return
mComputedMaxWidth
;
}
nscoord
ComputedMinHeight
(
)
const
{
return
mComputedMinHeight
;
}
nscoord
ComputedMaxHeight
(
)
const
{
return
mComputedMaxHeight
;
}
nscoord
&
AvailableWidth
(
)
{
return
mAvailableWidth
;
}
nscoord
&
AvailableHeight
(
)
{
return
mAvailableHeight
;
}
nscoord
&
ComputedWidth
(
)
{
return
mComputedWidth
;
}
nscoord
&
ComputedHeight
(
)
{
return
mComputedHeight
;
}
nscoord
&
ComputedMinWidth
(
)
{
return
mComputedMinWidth
;
}
nscoord
&
ComputedMaxWidth
(
)
{
return
mComputedMaxWidth
;
}
nscoord
&
ComputedMinHeight
(
)
{
return
mComputedMinHeight
;
}
nscoord
&
ComputedMaxHeight
(
)
{
return
mComputedMaxHeight
;
}
nscoord
AvailableISize
(
)
const
{
return
mWritingMode
.
IsVertical
(
)
?
mAvailableHeight
:
mAvailableWidth
;
}
nscoord
AvailableBSize
(
)
const
{
return
mWritingMode
.
IsVertical
(
)
?
mAvailableWidth
:
mAvailableHeight
;
}
nscoord
ComputedISize
(
)
const
{
return
mWritingMode
.
IsVertical
(
)
?
mComputedHeight
:
mComputedWidth
;
}
nscoord
ComputedBSize
(
)
const
{
return
mWritingMode
.
IsVertical
(
)
?
mComputedWidth
:
mComputedHeight
;
}
nscoord
ComputedMinISize
(
)
const
{
return
mWritingMode
.
IsVertical
(
)
?
mComputedMinHeight
:
mComputedMinWidth
;
}
nscoord
ComputedMaxISize
(
)
const
{
return
mWritingMode
.
IsVertical
(
)
?
mComputedMaxHeight
:
mComputedMaxWidth
;
}
nscoord
ComputedMinBSize
(
)
const
{
return
mWritingMode
.
IsVertical
(
)
?
mComputedMinWidth
:
mComputedMinHeight
;
}
nscoord
ComputedMaxBSize
(
)
const
{
return
mWritingMode
.
IsVertical
(
)
?
mComputedMaxWidth
:
mComputedMaxHeight
;
}
nscoord
&
AvailableISize
(
)
{
return
mWritingMode
.
IsVertical
(
)
?
mAvailableHeight
:
mAvailableWidth
;
}
nscoord
&
AvailableBSize
(
)
{
return
mWritingMode
.
IsVertical
(
)
?
mAvailableWidth
:
mAvailableHeight
;
}
nscoord
&
ComputedISize
(
)
{
return
mWritingMode
.
IsVertical
(
)
?
mComputedHeight
:
mComputedWidth
;
}
nscoord
&
ComputedBSize
(
)
{
return
mWritingMode
.
IsVertical
(
)
?
mComputedWidth
:
mComputedHeight
;
}
nscoord
&
ComputedMinISize
(
)
{
return
mWritingMode
.
IsVertical
(
)
?
mComputedMinHeight
:
mComputedMinWidth
;
}
nscoord
&
ComputedMaxISize
(
)
{
return
mWritingMode
.
IsVertical
(
)
?
mComputedMaxHeight
:
mComputedMaxWidth
;
}
nscoord
&
ComputedMinBSize
(
)
{
return
mWritingMode
.
IsVertical
(
)
?
mComputedMinWidth
:
mComputedMinHeight
;
}
nscoord
&
ComputedMaxBSize
(
)
{
return
mWritingMode
.
IsVertical
(
)
?
mComputedMaxWidth
:
mComputedMaxHeight
;
}
mozilla
:
:
LogicalSize
AvailableSize
(
)
const
{
return
mozilla
:
:
LogicalSize
(
mWritingMode
AvailableISize
(
)
AvailableBSize
(
)
)
;
}
mozilla
:
:
LogicalSize
ComputedSize
(
)
const
{
return
mozilla
:
:
LogicalSize
(
mWritingMode
ComputedISize
(
)
ComputedBSize
(
)
)
;
}
mozilla
:
:
LogicalSize
ComputedMinSize
(
)
const
{
return
mozilla
:
:
LogicalSize
(
mWritingMode
ComputedMinISize
(
)
ComputedMinBSize
(
)
)
;
}
mozilla
:
:
LogicalSize
ComputedMaxSize
(
)
const
{
return
mozilla
:
:
LogicalSize
(
mWritingMode
ComputedMaxISize
(
)
ComputedMaxBSize
(
)
)
;
}
mozilla
:
:
LogicalSize
AvailableSize
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
AvailableSize
(
)
.
ConvertTo
(
aWM
mWritingMode
)
;
}
mozilla
:
:
LogicalSize
ComputedSize
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
ComputedSize
(
)
.
ConvertTo
(
aWM
mWritingMode
)
;
}
mozilla
:
:
LogicalSize
ComputedMinSize
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
ComputedMinSize
(
)
.
ConvertTo
(
aWM
mWritingMode
)
;
}
mozilla
:
:
LogicalSize
ComputedMaxSize
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
ComputedMaxSize
(
)
.
ConvertTo
(
aWM
mWritingMode
)
;
}
mozilla
:
:
LogicalSize
ComputedSizeWithPadding
(
)
const
{
mozilla
:
:
WritingMode
wm
=
GetWritingMode
(
)
;
return
mozilla
:
:
LogicalSize
(
wm
ComputedISize
(
)
+
ComputedLogicalPadding
(
)
.
IStartEnd
(
wm
)
ComputedBSize
(
)
+
ComputedLogicalPadding
(
)
.
BStartEnd
(
wm
)
)
;
}
mozilla
:
:
LogicalSize
ComputedSizeWithPadding
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
ComputedSizeWithPadding
(
)
.
ConvertTo
(
aWM
GetWritingMode
(
)
)
;
}
mozilla
:
:
LogicalSize
ComputedSizeWithBorderPadding
(
)
const
{
mozilla
:
:
WritingMode
wm
=
GetWritingMode
(
)
;
return
mozilla
:
:
LogicalSize
(
wm
ComputedISize
(
)
+
ComputedLogicalBorderPadding
(
)
.
IStartEnd
(
wm
)
ComputedBSize
(
)
+
ComputedLogicalBorderPadding
(
)
.
BStartEnd
(
wm
)
)
;
}
mozilla
:
:
LogicalSize
ComputedSizeWithBorderPadding
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
ComputedSizeWithBorderPadding
(
)
.
ConvertTo
(
aWM
GetWritingMode
(
)
)
;
}
mozilla
:
:
LogicalSize
ComputedSizeWithMarginBorderPadding
(
)
const
{
mozilla
:
:
WritingMode
wm
=
GetWritingMode
(
)
;
return
mozilla
:
:
LogicalSize
(
wm
ComputedISize
(
)
+
ComputedLogicalMargin
(
)
.
IStartEnd
(
wm
)
+
ComputedLogicalBorderPadding
(
)
.
IStartEnd
(
wm
)
ComputedBSize
(
)
+
ComputedLogicalMargin
(
)
.
BStartEnd
(
wm
)
+
ComputedLogicalBorderPadding
(
)
.
BStartEnd
(
wm
)
)
;
}
mozilla
:
:
LogicalSize
ComputedSizeWithMarginBorderPadding
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
ComputedSizeWithMarginBorderPadding
(
)
.
ConvertTo
(
aWM
GetWritingMode
(
)
)
;
}
nsSize
ComputedPhysicalSize
(
)
const
{
return
nsSize
(
ComputedWidth
(
)
ComputedHeight
(
)
)
;
}
const
nsMargin
&
ComputedPhysicalOffsets
(
)
const
{
return
mComputedOffsets
;
}
nsMargin
&
ComputedPhysicalOffsets
(
)
{
return
mComputedOffsets
;
}
const
LogicalMargin
ComputedLogicalOffsets
(
)
const
{
return
LogicalMargin
(
mWritingMode
mComputedOffsets
)
;
}
void
SetComputedLogicalOffsets
(
const
LogicalMargin
&
aOffsets
)
{
mComputedOffsets
=
aOffsets
.
GetPhysicalMargin
(
mWritingMode
)
;
}
nsSize
ComputedSizeAsContainerIfConstrained
(
)
const
{
const
nscoord
wd
=
ComputedWidth
(
)
;
const
nscoord
ht
=
ComputedHeight
(
)
;
return
nsSize
(
wd
=
=
NS_UNCONSTRAINEDSIZE
?
0
:
wd
+
ComputedPhysicalBorderPadding
(
)
.
LeftRight
(
)
ht
=
=
NS_UNCONSTRAINEDSIZE
?
0
:
ht
+
ComputedPhysicalBorderPadding
(
)
.
TopBottom
(
)
)
;
}
bool
ComputedBSizeIsSetByAspectRatio
(
)
const
{
return
mFlags
.
mBSizeIsSetByAspectRatio
;
}
private
:
nscoord
mAvailableWidth
=
0
;
nscoord
mAvailableHeight
=
0
;
MOZ_INIT_OUTSIDE_CTOR
nscoord
mComputedWidth
;
MOZ_INIT_OUTSIDE_CTOR
nscoord
mComputedHeight
;
nsMargin
mComputedOffsets
;
MOZ_INIT_OUTSIDE_CTOR
nscoord
mComputedMinWidth
mComputedMaxWidth
;
MOZ_INIT_OUTSIDE_CTOR
nscoord
mComputedMinHeight
mComputedMaxHeight
;
public
:
LogicalSize
mContainingBlockSize
=
LogicalSize
(
mWritingMode
)
;
const
nsStyleDisplay
*
mStyleDisplay
=
nullptr
;
const
nsStyleVisibility
*
mStyleVisibility
=
nullptr
;
const
nsStylePosition
*
mStylePosition
=
nullptr
;
const
nsStyleBorder
*
mStyleBorder
=
nullptr
;
const
nsStyleMargin
*
mStyleMargin
=
nullptr
;
const
nsStylePadding
*
mStylePadding
=
nullptr
;
const
nsStyleText
*
mStyleText
=
nullptr
;
bool
IsFloating
(
)
const
;
mozilla
:
:
StyleDisplay
GetDisplay
(
)
const
;
nsIPercentBSizeObserver
*
mPercentBSizeObserver
=
nullptr
;
nsIFrame
*
*
mDiscoveredClearance
=
nullptr
;
struct
Flags
{
Flags
(
)
{
memset
(
this
0
sizeof
(
*
this
)
)
;
}
bool
mSpecialBSizeReflow
:
1
;
bool
mNextInFlowUntouched
:
1
;
bool
mIsTopOfPage
:
1
;
bool
mAssumingHScrollbar
:
1
;
bool
mAssumingVScrollbar
:
1
;
bool
mIsIResize
:
1
;
bool
mIsBResize
:
1
;
bool
mIsBResizeForPercentages
:
1
;
bool
mTableIsSplittable
:
1
;
bool
mHeightDependsOnAncestorCell
:
1
;
bool
mIsColumnBalancing
:
1
;
bool
mColumnSetWrapperHasNoBSizeLeft
:
1
;
bool
mIsFlexContainerMeasuringBSize
:
1
;
bool
mTreatBSizeAsIndefinite
:
1
;
bool
mDummyParentReflowInput
:
1
;
bool
mMustReflowPlaceholders
:
1
;
bool
mStaticPosIsCBOrigin
:
1
;
bool
mIOffsetsNeedCSSAlign
:
1
;
bool
mBOffsetsNeedCSSAlign
:
1
;
bool
mInsideLineClamp
:
1
;
bool
mApplyLineClamp
:
1
;
bool
mMovedBlockFragments
:
1
;
bool
mBSizeIsSetByAspectRatio
:
1
;
}
;
Flags
mFlags
;
mozilla
:
:
ComputeSizeFlags
mComputeSizeFlags
;
int16_t
mReflowDepth
=
0
;
bool
IsHResize
(
)
const
{
return
mWritingMode
.
IsVertical
(
)
?
mFlags
.
mIsBResize
:
mFlags
.
mIsIResize
;
}
bool
IsVResize
(
)
const
{
return
mWritingMode
.
IsVertical
(
)
?
mFlags
.
mIsIResize
:
mFlags
.
mIsBResize
;
}
bool
IsIResize
(
)
const
{
return
mFlags
.
mIsIResize
;
}
bool
IsBResize
(
)
const
{
return
mFlags
.
mIsBResize
;
}
bool
IsBResizeForWM
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
aWM
.
IsOrthogonalTo
(
mWritingMode
)
?
mFlags
.
mIsIResize
:
mFlags
.
mIsBResize
;
}
bool
IsBResizeForPercentagesForWM
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
!
aWM
.
IsOrthogonalTo
(
mWritingMode
)
?
mFlags
.
mIsBResizeForPercentages
:
IsIResize
(
)
;
}
void
SetHResize
(
bool
aValue
)
{
if
(
mWritingMode
.
IsVertical
(
)
)
{
mFlags
.
mIsBResize
=
aValue
;
}
else
{
mFlags
.
mIsIResize
=
aValue
;
}
}
void
SetVResize
(
bool
aValue
)
{
if
(
mWritingMode
.
IsVertical
(
)
)
{
mFlags
.
mIsIResize
=
aValue
;
}
else
{
mFlags
.
mIsBResize
=
aValue
;
}
}
void
SetIResize
(
bool
aValue
)
{
mFlags
.
mIsIResize
=
aValue
;
}
void
SetBResize
(
bool
aValue
)
{
mFlags
.
mIsBResize
=
aValue
;
}
enum
class
InitFlag
:
uint8_t
{
DummyParentReflowInput
CallerWillInit
StaticPosIsCBOrigin
}
;
using
InitFlags
=
mozilla
:
:
EnumSet
<
InitFlag
>
;
ReflowInput
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
gfxContext
*
aRenderingContext
const
mozilla
:
:
LogicalSize
&
aAvailableSpace
InitFlags
aFlags
=
{
}
)
;
ReflowInput
(
nsPresContext
*
aPresContext
const
ReflowInput
&
aParentReflowInput
nsIFrame
*
aFrame
const
mozilla
:
:
LogicalSize
&
aAvailableSpace
const
mozilla
:
:
Maybe
<
mozilla
:
:
LogicalSize
>
&
aContainingBlockSize
=
mozilla
:
:
Nothing
(
)
InitFlags
aFlags
=
{
}
mozilla
:
:
ComputeSizeFlags
aComputeSizeFlags
=
{
}
)
;
void
Init
(
nsPresContext
*
aPresContext
const
mozilla
:
:
Maybe
<
mozilla
:
:
LogicalSize
>
&
aContainingBlockSize
=
mozilla
:
:
Nothing
(
)
const
nsMargin
*
aBorder
=
nullptr
const
nsMargin
*
aPadding
=
nullptr
)
;
nscoord
GetContainingBlockContentISize
(
mozilla
:
:
WritingMode
aWritingMode
)
const
;
nscoord
CalcLineHeight
(
)
const
;
static
nscoord
CalcLineHeight
(
nsIContent
*
aContent
ComputedStyle
*
aComputedStyle
nsPresContext
*
aPresContext
nscoord
aBlockBSize
float
aFontSizeInflation
)
;
mozilla
:
:
LogicalSize
ComputeContainingBlockRectangle
(
nsPresContext
*
aPresContext
const
ReflowInput
*
aContainingBlockRI
)
const
;
nscoord
ApplyMinMaxWidth
(
nscoord
aWidth
)
const
{
if
(
NS_UNCONSTRAINEDSIZE
!
=
ComputedMaxWidth
(
)
)
{
aWidth
=
std
:
:
min
(
aWidth
ComputedMaxWidth
(
)
)
;
}
return
std
:
:
max
(
aWidth
ComputedMinWidth
(
)
)
;
}
nscoord
ApplyMinMaxISize
(
nscoord
aISize
)
const
{
if
(
NS_UNCONSTRAINEDSIZE
!
=
ComputedMaxISize
(
)
)
{
aISize
=
std
:
:
min
(
aISize
ComputedMaxISize
(
)
)
;
}
return
std
:
:
max
(
aISize
ComputedMinISize
(
)
)
;
}
nscoord
ApplyMinMaxHeight
(
nscoord
aHeight
nscoord
aConsumed
=
0
)
const
{
aHeight
+
=
aConsumed
;
if
(
NS_UNCONSTRAINEDSIZE
!
=
ComputedMaxHeight
(
)
)
{
aHeight
=
std
:
:
min
(
aHeight
ComputedMaxHeight
(
)
)
;
}
if
(
NS_UNCONSTRAINEDSIZE
!
=
ComputedMinHeight
(
)
)
{
aHeight
=
std
:
:
max
(
aHeight
ComputedMinHeight
(
)
)
;
}
return
aHeight
-
aConsumed
;
}
nscoord
ApplyMinMaxBSize
(
nscoord
aBSize
nscoord
aConsumed
=
0
)
const
{
aBSize
+
=
aConsumed
;
if
(
NS_UNCONSTRAINEDSIZE
!
=
ComputedMaxBSize
(
)
)
{
aBSize
=
std
:
:
min
(
aBSize
ComputedMaxBSize
(
)
)
;
}
if
(
NS_UNCONSTRAINEDSIZE
!
=
ComputedMinBSize
(
)
)
{
aBSize
=
std
:
:
max
(
aBSize
ComputedMinBSize
(
)
)
;
}
return
aBSize
-
aConsumed
;
}
bool
ShouldReflowAllKids
(
)
const
;
void
SetComputedWidth
(
nscoord
aComputedWidth
)
;
void
SetComputedHeight
(
nscoord
aComputedHeight
)
;
void
SetComputedISize
(
nscoord
aComputedISize
)
{
if
(
mWritingMode
.
IsVertical
(
)
)
{
SetComputedHeight
(
aComputedISize
)
;
}
else
{
SetComputedWidth
(
aComputedISize
)
;
}
}
void
SetComputedBSize
(
nscoord
aComputedBSize
)
{
if
(
mWritingMode
.
IsVertical
(
)
)
{
SetComputedWidth
(
aComputedBSize
)
;
}
else
{
SetComputedHeight
(
aComputedBSize
)
;
}
}
void
SetComputedBSizeWithoutResettingResizeFlags
(
nscoord
aComputedBSize
)
{
ComputedBSize
(
)
=
aComputedBSize
;
}
void
SetTruncated
(
const
ReflowOutput
&
aMetrics
nsReflowStatus
*
aStatus
)
const
;
bool
WillReflowAgainForClearance
(
)
const
{
return
mDiscoveredClearance
&
&
*
mDiscoveredClearance
;
}
static
void
ComputeRelativeOffsets
(
mozilla
:
:
WritingMode
aWM
nsIFrame
*
aFrame
const
mozilla
:
:
LogicalSize
&
aCBSize
nsMargin
&
aComputedOffsets
)
;
static
void
ApplyRelativePositioning
(
nsIFrame
*
aFrame
const
nsMargin
&
aComputedOffsets
nsPoint
*
aPosition
)
;
void
ApplyRelativePositioning
(
nsPoint
*
aPosition
)
const
{
ApplyRelativePositioning
(
mFrame
ComputedPhysicalOffsets
(
)
aPosition
)
;
}
static
void
ApplyRelativePositioning
(
nsIFrame
*
aFrame
mozilla
:
:
WritingMode
aWritingMode
const
mozilla
:
:
LogicalMargin
&
aComputedOffsets
mozilla
:
:
LogicalPoint
*
aPosition
const
nsSize
&
aContainerSize
)
;
void
ApplyRelativePositioning
(
mozilla
:
:
LogicalPoint
*
aPosition
const
nsSize
&
aContainerSize
)
const
{
ApplyRelativePositioning
(
mFrame
mWritingMode
ComputedLogicalOffsets
(
)
aPosition
aContainerSize
)
;
}
#
ifdef
DEBUG
static
void
*
DisplayInitConstraintsEnter
(
nsIFrame
*
aFrame
ReflowInput
*
aState
nscoord
aCBISize
nscoord
aCBBSize
const
nsMargin
*
aBorder
const
nsMargin
*
aPadding
)
;
static
void
DisplayInitConstraintsExit
(
nsIFrame
*
aFrame
ReflowInput
*
aState
void
*
aValue
)
;
static
void
*
DisplayInitFrameTypeEnter
(
nsIFrame
*
aFrame
ReflowInput
*
aState
)
;
static
void
DisplayInitFrameTypeExit
(
nsIFrame
*
aFrame
ReflowInput
*
aState
void
*
aValue
)
;
#
endif
protected
:
void
InitFrameType
(
LayoutFrameType
aFrameType
)
;
void
InitCBReflowInput
(
)
;
void
InitResizeFlags
(
nsPresContext
*
aPresContext
mozilla
:
:
LayoutFrameType
aFrameType
)
;
void
InitDynamicReflowRoot
(
)
;
void
InitConstraints
(
nsPresContext
*
aPresContext
const
mozilla
:
:
Maybe
<
mozilla
:
:
LogicalSize
>
&
aContainingBlockSize
const
nsMargin
*
aBorder
const
nsMargin
*
aPadding
mozilla
:
:
LayoutFrameType
aFrameType
)
;
nsIFrame
*
GetHypotheticalBoxContainer
(
nsIFrame
*
aFrame
nscoord
&
aCBIStartEdge
mozilla
:
:
LogicalSize
&
aCBSize
)
const
;
void
CalculateHypotheticalPosition
(
nsPresContext
*
aPresContext
nsPlaceholderFrame
*
aPlaceholderFrame
const
ReflowInput
*
aCBReflowInput
nsHypotheticalPosition
&
aHypotheticalPos
mozilla
:
:
LayoutFrameType
aFrameType
)
const
;
void
InitAbsoluteConstraints
(
nsPresContext
*
aPresContext
const
ReflowInput
*
aCBReflowInput
const
mozilla
:
:
LogicalSize
&
aContainingBlockSize
mozilla
:
:
LayoutFrameType
aFrameType
)
;
void
ComputeMinMaxValues
(
const
mozilla
:
:
LogicalSize
&
aContainingBlockSize
)
;
void
CalculateBorderPaddingMargin
(
mozilla
:
:
LogicalAxis
aAxis
nscoord
aContainingBlockSize
nscoord
*
aInsideBoxSizing
nscoord
*
aOutsideBoxSizing
)
const
;
void
CalculateBlockSideMargins
(
LayoutFrameType
aFrameType
)
;
}
;
}
#
endif
