#
ifndef
mozilla_ReflowInput_h
#
define
mozilla_ReflowInput_h
#
include
"
nsMargin
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
EnumSet
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
WritingModes
.
h
"
#
include
"
LayoutConstants
.
h
"
#
include
"
ReflowOutput
.
h
"
#
include
<
algorithm
>
class
gfxContext
;
class
nsFloatManager
;
struct
nsHypotheticalPosition
;
class
nsIPercentBSizeObserver
;
class
nsLineLayout
;
class
nsPlaceholderFrame
;
class
nsPresContext
;
class
nsReflowStatus
;
namespace
mozilla
{
enum
class
LayoutFrameType
:
uint8_t
;
}
template
<
class
NumericType
>
NumericType
NS_CSS_MINMAX
(
NumericType
aValue
NumericType
aMinValue
NumericType
aMaxValue
)
{
NumericType
result
=
aValue
;
if
(
aMaxValue
<
result
)
result
=
aMaxValue
;
if
(
aMinValue
>
result
)
result
=
aMinValue
;
return
result
;
}
namespace
mozilla
{
struct
SizeComputationInput
{
public
:
nsIFrame
*
mFrame
;
gfxContext
*
mRenderingContext
;
nsMargin
ComputedPhysicalMargin
(
)
const
{
return
mComputedMargin
.
GetPhysicalMargin
(
mWritingMode
)
;
}
nsMargin
ComputedPhysicalBorderPadding
(
)
const
{
return
mComputedBorderPadding
.
GetPhysicalMargin
(
mWritingMode
)
;
}
nsMargin
ComputedPhysicalPadding
(
)
const
{
return
mComputedPadding
.
GetPhysicalMargin
(
mWritingMode
)
;
}
mozilla
:
:
LogicalMargin
ComputedLogicalMargin
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
mComputedMargin
.
ConvertTo
(
aWM
mWritingMode
)
;
}
mozilla
:
:
LogicalMargin
ComputedLogicalBorderPadding
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
mComputedBorderPadding
.
ConvertTo
(
aWM
mWritingMode
)
;
}
mozilla
:
:
LogicalMargin
ComputedLogicalPadding
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
mComputedPadding
.
ConvertTo
(
aWM
mWritingMode
)
;
}
void
SetComputedLogicalMargin
(
mozilla
:
:
WritingMode
aWM
const
mozilla
:
:
LogicalMargin
&
aMargin
)
{
mComputedMargin
=
aMargin
.
ConvertTo
(
mWritingMode
aWM
)
;
}
void
SetComputedLogicalBorderPadding
(
mozilla
:
:
WritingMode
aWM
const
mozilla
:
:
LogicalMargin
&
aBorderPadding
)
{
mComputedBorderPadding
=
aBorderPadding
.
ConvertTo
(
mWritingMode
aWM
)
;
}
void
SetComputedLogicalPadding
(
mozilla
:
:
WritingMode
aWM
const
mozilla
:
:
LogicalMargin
&
aPadding
)
{
mComputedPadding
=
aPadding
.
ConvertTo
(
mWritingMode
aWM
)
;
}
mozilla
:
:
WritingMode
GetWritingMode
(
)
const
{
return
mWritingMode
;
}
protected
:
mozilla
:
:
WritingMode
mWritingMode
;
mozilla
:
:
LogicalMargin
mComputedMargin
;
mozilla
:
:
LogicalMargin
mComputedBorderPadding
;
mozilla
:
:
LogicalMargin
mComputedPadding
;
public
:
SizeComputationInput
(
nsIFrame
*
aFrame
gfxContext
*
aRenderingContext
)
;
SizeComputationInput
(
nsIFrame
*
aFrame
gfxContext
*
aRenderingContext
mozilla
:
:
WritingMode
aContainingBlockWritingMode
nscoord
aContainingBlockISize
)
;
#
ifdef
DEBUG
static
void
*
DisplayInitOffsetsEnter
(
nsIFrame
*
aFrame
SizeComputationInput
*
aState
nscoord
aPercentBasis
mozilla
:
:
WritingMode
aCBWritingMode
const
nsMargin
*
aBorder
const
nsMargin
*
aPadding
)
;
static
void
DisplayInitOffsetsExit
(
nsIFrame
*
aFrame
SizeComputationInput
*
aState
void
*
aValue
)
;
#
endif
private
:
bool
ComputeMargin
(
mozilla
:
:
WritingMode
aCBWM
nscoord
aPercentBasis
)
;
bool
ComputePadding
(
mozilla
:
:
WritingMode
aCBWM
nscoord
aPercentBasis
mozilla
:
:
LayoutFrameType
aFrameType
)
;
protected
:
void
InitOffsets
(
mozilla
:
:
WritingMode
aCBWM
nscoord
aPercentBasis
mozilla
:
:
LayoutFrameType
aFrameType
mozilla
:
:
ComputeSizeFlags
aFlags
=
{
}
const
mozilla
:
:
Maybe
<
mozilla
:
:
LogicalMargin
>
&
aBorder
=
mozilla
:
:
Nothing
(
)
const
mozilla
:
:
Maybe
<
mozilla
:
:
LogicalMargin
>
&
aPadding
=
mozilla
:
:
Nothing
(
)
const
nsStyleDisplay
*
aDisplay
=
nullptr
)
;
template
<
typename
SizeOrMaxSize
>
inline
nscoord
ComputeISizeValue
(
const
WritingMode
aWM
const
LogicalSize
&
aContainingBlockSize
const
LogicalSize
&
aContentEdgeToBoxSizing
nscoord
aBoxSizingToMarginEdge
const
SizeOrMaxSize
&
)
const
;
template
<
typename
SizeOrMaxSize
>
inline
nscoord
ComputeISizeValue
(
const
LogicalSize
&
aContainingBlockSize
mozilla
:
:
StyleBoxSizing
aBoxSizing
const
SizeOrMaxSize
&
)
const
;
nscoord
ComputeBSizeValue
(
nscoord
aContainingBlockBSize
mozilla
:
:
StyleBoxSizing
aBoxSizing
const
mozilla
:
:
LengthPercentage
&
aCoord
)
const
;
}
;
struct
ReflowInput
:
public
SizeComputationInput
{
const
ReflowInput
*
mParentReflowInput
=
nullptr
;
nsFloatManager
*
mFloatManager
=
nullptr
;
nsLineLayout
*
mLineLayout
=
nullptr
;
const
ReflowInput
*
mCBReflowInput
=
nullptr
;
nscoord
mBlockDelta
=
0
;
nscoord
mOrthogonalLimit
=
NS_UNCONSTRAINEDSIZE
;
nscoord
AvailableWidth
(
)
const
{
return
mAvailableSize
.
Width
(
mWritingMode
)
;
}
nscoord
AvailableHeight
(
)
const
{
return
mAvailableSize
.
Height
(
mWritingMode
)
;
}
nscoord
ComputedWidth
(
)
const
{
return
mComputedSize
.
Width
(
mWritingMode
)
;
}
nscoord
ComputedHeight
(
)
const
{
return
mComputedSize
.
Height
(
mWritingMode
)
;
}
nscoord
ComputedMinWidth
(
)
const
{
return
mComputedMinSize
.
Width
(
mWritingMode
)
;
}
nscoord
ComputedMaxWidth
(
)
const
{
return
mComputedMaxSize
.
Width
(
mWritingMode
)
;
}
nscoord
ComputedMinHeight
(
)
const
{
return
mComputedMinSize
.
Height
(
mWritingMode
)
;
}
nscoord
ComputedMaxHeight
(
)
const
{
return
mComputedMaxSize
.
Height
(
mWritingMode
)
;
}
nscoord
AvailableISize
(
)
const
{
return
mAvailableSize
.
ISize
(
mWritingMode
)
;
}
nscoord
AvailableBSize
(
)
const
{
return
mAvailableSize
.
BSize
(
mWritingMode
)
;
}
nscoord
ComputedISize
(
)
const
{
return
mComputedSize
.
ISize
(
mWritingMode
)
;
}
nscoord
ComputedBSize
(
)
const
{
return
mComputedSize
.
BSize
(
mWritingMode
)
;
}
nscoord
ComputedMinISize
(
)
const
{
return
mComputedMinSize
.
ISize
(
mWritingMode
)
;
}
nscoord
ComputedMaxISize
(
)
const
{
return
mComputedMaxSize
.
ISize
(
mWritingMode
)
;
}
nscoord
ComputedMinBSize
(
)
const
{
return
mComputedMinSize
.
BSize
(
mWritingMode
)
;
}
nscoord
ComputedMaxBSize
(
)
const
{
return
mComputedMaxSize
.
BSize
(
mWritingMode
)
;
}
nscoord
&
AvailableISize
(
)
{
return
mAvailableSize
.
ISize
(
mWritingMode
)
;
}
nscoord
&
AvailableBSize
(
)
{
return
mAvailableSize
.
BSize
(
mWritingMode
)
;
}
nscoord
&
ComputedISize
(
)
{
return
mComputedSize
.
ISize
(
mWritingMode
)
;
}
nscoord
&
ComputedBSize
(
)
{
return
mComputedSize
.
BSize
(
mWritingMode
)
;
}
nscoord
&
ComputedMinISize
(
)
{
return
mComputedMinSize
.
ISize
(
mWritingMode
)
;
}
nscoord
&
ComputedMaxISize
(
)
{
return
mComputedMaxSize
.
ISize
(
mWritingMode
)
;
}
nscoord
&
ComputedMinBSize
(
)
{
return
mComputedMinSize
.
BSize
(
mWritingMode
)
;
}
nscoord
&
ComputedMaxBSize
(
)
{
return
mComputedMaxSize
.
BSize
(
mWritingMode
)
;
}
mozilla
:
:
LogicalSize
AvailableSize
(
)
const
{
return
mAvailableSize
;
}
mozilla
:
:
LogicalSize
ComputedSize
(
)
const
{
return
mComputedSize
;
}
mozilla
:
:
LogicalSize
ComputedMinSize
(
)
const
{
return
mComputedMinSize
;
}
mozilla
:
:
LogicalSize
ComputedMaxSize
(
)
const
{
return
mComputedMaxSize
;
}
mozilla
:
:
LogicalSize
AvailableSize
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
AvailableSize
(
)
.
ConvertTo
(
aWM
mWritingMode
)
;
}
mozilla
:
:
LogicalSize
ComputedSize
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
ComputedSize
(
)
.
ConvertTo
(
aWM
mWritingMode
)
;
}
mozilla
:
:
LogicalSize
ComputedMinSize
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
ComputedMinSize
(
)
.
ConvertTo
(
aWM
mWritingMode
)
;
}
mozilla
:
:
LogicalSize
ComputedMaxSize
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
ComputedMaxSize
(
)
.
ConvertTo
(
aWM
mWritingMode
)
;
}
mozilla
:
:
LogicalSize
ComputedSizeWithPadding
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
ComputedSize
(
aWM
)
+
ComputedLogicalPadding
(
aWM
)
.
Size
(
aWM
)
;
}
mozilla
:
:
LogicalSize
ComputedSizeWithBorderPadding
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
ComputedSize
(
aWM
)
+
ComputedLogicalBorderPadding
(
aWM
)
.
Size
(
aWM
)
;
}
mozilla
:
:
LogicalSize
ComputedSizeWithMarginBorderPadding
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
ComputedSizeWithBorderPadding
(
aWM
)
+
ComputedLogicalMargin
(
aWM
)
.
Size
(
aWM
)
;
}
nsSize
ComputedPhysicalSize
(
)
const
{
return
nsSize
(
ComputedWidth
(
)
ComputedHeight
(
)
)
;
}
nsMargin
ComputedPhysicalOffsets
(
)
const
{
return
mComputedOffsets
.
GetPhysicalMargin
(
mWritingMode
)
;
}
LogicalMargin
ComputedLogicalOffsets
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
mComputedOffsets
.
ConvertTo
(
aWM
mWritingMode
)
;
}
void
SetComputedLogicalOffsets
(
mozilla
:
:
WritingMode
aWM
const
LogicalMargin
&
aOffsets
)
{
mComputedOffsets
=
aOffsets
.
ConvertTo
(
mWritingMode
aWM
)
;
}
nsSize
ComputedSizeAsContainerIfConstrained
(
)
const
{
const
nscoord
wd
=
ComputedWidth
(
)
;
const
nscoord
ht
=
ComputedHeight
(
)
;
return
nsSize
(
wd
=
=
NS_UNCONSTRAINEDSIZE
?
0
:
wd
+
ComputedPhysicalBorderPadding
(
)
.
LeftRight
(
)
ht
=
=
NS_UNCONSTRAINEDSIZE
?
0
:
ht
+
ComputedPhysicalBorderPadding
(
)
.
TopBottom
(
)
)
;
}
LogicalSize
mContainingBlockSize
{
mWritingMode
}
;
const
nsStyleDisplay
*
mStyleDisplay
=
nullptr
;
const
nsStyleVisibility
*
mStyleVisibility
=
nullptr
;
const
nsStylePosition
*
mStylePosition
=
nullptr
;
const
nsStyleBorder
*
mStyleBorder
=
nullptr
;
const
nsStyleMargin
*
mStyleMargin
=
nullptr
;
const
nsStylePadding
*
mStylePadding
=
nullptr
;
const
nsStyleText
*
mStyleText
=
nullptr
;
bool
IsFloating
(
)
const
;
nsIPercentBSizeObserver
*
mPercentBSizeObserver
=
nullptr
;
nsIFrame
*
*
mDiscoveredClearance
=
nullptr
;
struct
Flags
{
Flags
(
)
{
memset
(
this
0
sizeof
(
*
this
)
)
;
}
bool
mIsReplaced
:
1
;
bool
mSpecialBSizeReflow
:
1
;
bool
mNextInFlowUntouched
:
1
;
bool
mIsTopOfPage
:
1
;
bool
mAssumingHScrollbar
:
1
;
bool
mAssumingVScrollbar
:
1
;
bool
mIsIResize
:
1
;
bool
mIsBResize
:
1
;
bool
mIsBResizeForPercentages
:
1
;
bool
mTableIsSplittable
:
1
;
bool
mHeightDependsOnAncestorCell
:
1
;
bool
mIsColumnBalancing
:
1
;
bool
mColumnSetWrapperHasNoBSizeLeft
:
1
;
bool
mIsFlexContainerMeasuringBSize
:
1
;
bool
mTreatBSizeAsIndefinite
:
1
;
bool
mDummyParentReflowInput
:
1
;
bool
mMustReflowPlaceholders
:
1
;
bool
mStaticPosIsCBOrigin
:
1
;
bool
mIOffsetsNeedCSSAlign
:
1
;
bool
mBOffsetsNeedCSSAlign
:
1
;
bool
mInsideLineClamp
:
1
;
bool
mApplyLineClamp
:
1
;
bool
mMovedBlockFragments
:
1
;
bool
mIsBSizeSetByAspectRatio
:
1
;
}
;
Flags
mFlags
;
mozilla
:
:
ComputeSizeFlags
mComputeSizeFlags
;
int16_t
mReflowDepth
=
0
;
bool
IsHResize
(
)
const
{
return
mWritingMode
.
IsVertical
(
)
?
mFlags
.
mIsBResize
:
mFlags
.
mIsIResize
;
}
bool
IsVResize
(
)
const
{
return
mWritingMode
.
IsVertical
(
)
?
mFlags
.
mIsIResize
:
mFlags
.
mIsBResize
;
}
bool
IsIResize
(
)
const
{
return
mFlags
.
mIsIResize
;
}
bool
IsBResize
(
)
const
{
return
mFlags
.
mIsBResize
;
}
bool
IsBResizeForWM
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
aWM
.
IsOrthogonalTo
(
mWritingMode
)
?
mFlags
.
mIsIResize
:
mFlags
.
mIsBResize
;
}
bool
IsBResizeForPercentagesForWM
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
!
aWM
.
IsOrthogonalTo
(
mWritingMode
)
?
mFlags
.
mIsBResizeForPercentages
:
IsIResize
(
)
;
}
void
SetHResize
(
bool
aValue
)
{
if
(
mWritingMode
.
IsVertical
(
)
)
{
mFlags
.
mIsBResize
=
aValue
;
}
else
{
mFlags
.
mIsIResize
=
aValue
;
}
}
void
SetVResize
(
bool
aValue
)
{
if
(
mWritingMode
.
IsVertical
(
)
)
{
mFlags
.
mIsIResize
=
aValue
;
}
else
{
mFlags
.
mIsBResize
=
aValue
;
}
}
void
SetIResize
(
bool
aValue
)
{
mFlags
.
mIsIResize
=
aValue
;
}
void
SetBResize
(
bool
aValue
)
{
mFlags
.
mIsBResize
=
aValue
;
}
enum
class
InitFlag
:
uint8_t
{
DummyParentReflowInput
CallerWillInit
StaticPosIsCBOrigin
}
;
using
InitFlags
=
mozilla
:
:
EnumSet
<
InitFlag
>
;
ReflowInput
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
gfxContext
*
aRenderingContext
const
mozilla
:
:
LogicalSize
&
aAvailableSpace
InitFlags
aFlags
=
{
}
)
;
ReflowInput
(
nsPresContext
*
aPresContext
const
ReflowInput
&
aParentReflowInput
nsIFrame
*
aFrame
const
mozilla
:
:
LogicalSize
&
aAvailableSpace
const
mozilla
:
:
Maybe
<
mozilla
:
:
LogicalSize
>
&
aContainingBlockSize
=
mozilla
:
:
Nothing
(
)
InitFlags
aFlags
=
{
}
mozilla
:
:
ComputeSizeFlags
aComputeSizeFlags
=
{
}
)
;
void
Init
(
nsPresContext
*
aPresContext
const
mozilla
:
:
Maybe
<
mozilla
:
:
LogicalSize
>
&
aContainingBlockSize
=
mozilla
:
:
Nothing
(
)
const
mozilla
:
:
Maybe
<
mozilla
:
:
LogicalMargin
>
&
aBorder
=
mozilla
:
:
Nothing
(
)
const
mozilla
:
:
Maybe
<
mozilla
:
:
LogicalMargin
>
&
aPadding
=
mozilla
:
:
Nothing
(
)
)
;
nscoord
GetContainingBlockContentISize
(
mozilla
:
:
WritingMode
aWritingMode
)
const
;
nscoord
CalcLineHeight
(
)
const
;
static
nscoord
CalcLineHeight
(
nsIContent
*
aContent
ComputedStyle
*
aComputedStyle
nsPresContext
*
aPresContext
nscoord
aBlockBSize
float
aFontSizeInflation
)
;
mozilla
:
:
LogicalSize
ComputeContainingBlockRectangle
(
nsPresContext
*
aPresContext
const
ReflowInput
*
aContainingBlockRI
)
const
;
nscoord
ApplyMinMaxWidth
(
nscoord
aWidth
)
const
{
if
(
NS_UNCONSTRAINEDSIZE
!
=
ComputedMaxWidth
(
)
)
{
aWidth
=
std
:
:
min
(
aWidth
ComputedMaxWidth
(
)
)
;
}
return
std
:
:
max
(
aWidth
ComputedMinWidth
(
)
)
;
}
nscoord
ApplyMinMaxISize
(
nscoord
aISize
)
const
{
if
(
NS_UNCONSTRAINEDSIZE
!
=
ComputedMaxISize
(
)
)
{
aISize
=
std
:
:
min
(
aISize
ComputedMaxISize
(
)
)
;
}
return
std
:
:
max
(
aISize
ComputedMinISize
(
)
)
;
}
nscoord
ApplyMinMaxHeight
(
nscoord
aHeight
nscoord
aConsumed
=
0
)
const
{
aHeight
+
=
aConsumed
;
if
(
NS_UNCONSTRAINEDSIZE
!
=
ComputedMaxHeight
(
)
)
{
aHeight
=
std
:
:
min
(
aHeight
ComputedMaxHeight
(
)
)
;
}
if
(
NS_UNCONSTRAINEDSIZE
!
=
ComputedMinHeight
(
)
)
{
aHeight
=
std
:
:
max
(
aHeight
ComputedMinHeight
(
)
)
;
}
return
aHeight
-
aConsumed
;
}
nscoord
ApplyMinMaxBSize
(
nscoord
aBSize
nscoord
aConsumed
=
0
)
const
{
aBSize
+
=
aConsumed
;
if
(
NS_UNCONSTRAINEDSIZE
!
=
ComputedMaxBSize
(
)
)
{
aBSize
=
std
:
:
min
(
aBSize
ComputedMaxBSize
(
)
)
;
}
if
(
NS_UNCONSTRAINEDSIZE
!
=
ComputedMinBSize
(
)
)
{
aBSize
=
std
:
:
max
(
aBSize
ComputedMinBSize
(
)
)
;
}
return
aBSize
-
aConsumed
;
}
bool
ShouldReflowAllKids
(
)
const
;
void
SetComputedWidth
(
nscoord
aComputedWidth
)
{
if
(
mWritingMode
.
IsVertical
(
)
)
{
SetComputedBSize
(
aComputedWidth
)
;
}
else
{
SetComputedISize
(
aComputedWidth
)
;
}
}
void
SetComputedHeight
(
nscoord
aComputedHeight
)
{
if
(
mWritingMode
.
IsVertical
(
)
)
{
SetComputedISize
(
aComputedHeight
)
;
}
else
{
SetComputedBSize
(
aComputedHeight
)
;
}
}
void
SetComputedISize
(
nscoord
aComputedISize
)
;
void
SetComputedBSize
(
nscoord
aComputedBSize
)
;
void
SetComputedBSizeWithoutResettingResizeFlags
(
nscoord
aComputedBSize
)
{
MOZ_ASSERT
(
aComputedBSize
>
=
0
"
Invalid
computed
block
-
size
!
"
)
;
ComputedBSize
(
)
=
aComputedBSize
;
}
void
SetTruncated
(
const
ReflowOutput
&
aMetrics
nsReflowStatus
*
aStatus
)
const
;
bool
WillReflowAgainForClearance
(
)
const
{
return
mDiscoveredClearance
&
&
*
mDiscoveredClearance
;
}
static
mozilla
:
:
LogicalMargin
ComputeRelativeOffsets
(
mozilla
:
:
WritingMode
aWM
nsIFrame
*
aFrame
const
mozilla
:
:
LogicalSize
&
aCBSize
)
;
static
void
ApplyRelativePositioning
(
nsIFrame
*
aFrame
const
nsMargin
&
aComputedOffsets
nsPoint
*
aPosition
)
;
void
ApplyRelativePositioning
(
nsPoint
*
aPosition
)
const
{
ApplyRelativePositioning
(
mFrame
ComputedPhysicalOffsets
(
)
aPosition
)
;
}
static
void
ApplyRelativePositioning
(
nsIFrame
*
aFrame
mozilla
:
:
WritingMode
aWritingMode
const
mozilla
:
:
LogicalMargin
&
aComputedOffsets
mozilla
:
:
LogicalPoint
*
aPosition
const
nsSize
&
aContainerSize
)
;
void
ApplyRelativePositioning
(
mozilla
:
:
LogicalPoint
*
aPosition
const
nsSize
&
aContainerSize
)
const
{
ApplyRelativePositioning
(
mFrame
mWritingMode
ComputedLogicalOffsets
(
mWritingMode
)
aPosition
aContainerSize
)
;
}
#
ifdef
DEBUG
static
void
*
DisplayInitConstraintsEnter
(
nsIFrame
*
aFrame
ReflowInput
*
aState
nscoord
aCBISize
nscoord
aCBBSize
const
nsMargin
*
aBorder
const
nsMargin
*
aPadding
)
;
static
void
DisplayInitConstraintsExit
(
nsIFrame
*
aFrame
ReflowInput
*
aState
void
*
aValue
)
;
static
void
*
DisplayInitFrameTypeEnter
(
nsIFrame
*
aFrame
ReflowInput
*
aState
)
;
static
void
DisplayInitFrameTypeExit
(
nsIFrame
*
aFrame
ReflowInput
*
aState
void
*
aValue
)
;
#
endif
protected
:
void
InitCBReflowInput
(
)
;
void
InitResizeFlags
(
nsPresContext
*
aPresContext
mozilla
:
:
LayoutFrameType
aFrameType
)
;
void
InitDynamicReflowRoot
(
)
;
void
InitConstraints
(
nsPresContext
*
aPresContext
const
mozilla
:
:
Maybe
<
mozilla
:
:
LogicalSize
>
&
aContainingBlockSize
const
mozilla
:
:
Maybe
<
mozilla
:
:
LogicalMargin
>
&
aBorder
const
mozilla
:
:
Maybe
<
mozilla
:
:
LogicalMargin
>
&
aPadding
mozilla
:
:
LayoutFrameType
aFrameType
)
;
nsIFrame
*
GetHypotheticalBoxContainer
(
nsIFrame
*
aFrame
nscoord
&
aCBIStartEdge
mozilla
:
:
LogicalSize
&
aCBSize
)
const
;
void
CalculateHypotheticalPosition
(
nsPresContext
*
aPresContext
nsPlaceholderFrame
*
aPlaceholderFrame
const
ReflowInput
*
aCBReflowInput
nsHypotheticalPosition
&
aHypotheticalPos
mozilla
:
:
LayoutFrameType
aFrameType
)
const
;
bool
IsInlineSizeComputableByBlockSizeAndAspectRatio
(
nscoord
aBlockSize
)
const
;
LogicalSize
CalculateAbsoluteSizeWithResolvedAutoBlockSize
(
nscoord
aAutoBSize
bool
aNeedsComputeInlineSizeByAspectRatio
const
LogicalSize
&
aTentativeComputedSize
)
;
void
InitAbsoluteConstraints
(
nsPresContext
*
aPresContext
const
ReflowInput
*
aCBReflowInput
const
mozilla
:
:
LogicalSize
&
aContainingBlockSize
mozilla
:
:
LayoutFrameType
aFrameType
)
;
void
ComputeMinMaxValues
(
const
mozilla
:
:
LogicalSize
&
aCBSize
)
;
void
CalculateBorderPaddingMargin
(
mozilla
:
:
LogicalAxis
aAxis
nscoord
aContainingBlockSize
nscoord
*
aInsideBoxSizing
nscoord
*
aOutsideBoxSizing
)
const
;
void
CalculateBlockSideMargins
(
LayoutFrameType
aFrameType
)
;
bool
IsInternalTableFrame
(
)
const
;
private
:
mozilla
:
:
LogicalSize
mAvailableSize
{
mWritingMode
}
;
mozilla
:
:
LogicalSize
mComputedSize
{
mWritingMode
}
;
mozilla
:
:
LogicalMargin
mComputedOffsets
{
mWritingMode
}
;
mozilla
:
:
LogicalSize
mComputedMinSize
{
mWritingMode
}
;
mozilla
:
:
LogicalSize
mComputedMaxSize
{
mWritingMode
NS_UNCONSTRAINEDSIZE
NS_UNCONSTRAINEDSIZE
}
;
}
;
}
#
endif
