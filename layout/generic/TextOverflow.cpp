#
include
"
TextOverflow
.
h
"
#
include
<
algorithm
>
#
include
"
gfxContext
.
h
"
#
include
"
nsBlockFrame
.
h
"
#
include
"
nsCaret
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCSSAnonBoxes
.
h
"
#
include
"
nsFontMetrics
.
h
"
#
include
"
nsGfxScrollFrame
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsTextFrame
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
TextDrawTarget
.
h
"
using
mozilla
:
:
layout
:
:
TextDrawTarget
;
namespace
mozilla
{
namespace
css
{
class
LazyReferenceRenderingDrawTargetGetterFromFrame
final
:
public
gfxFontGroup
:
:
LazyReferenceDrawTargetGetter
{
public
:
typedef
mozilla
:
:
gfx
:
:
DrawTarget
DrawTarget
;
explicit
LazyReferenceRenderingDrawTargetGetterFromFrame
(
nsIFrame
*
aFrame
)
:
mFrame
(
aFrame
)
{
}
virtual
already_AddRefed
<
DrawTarget
>
GetRefDrawTarget
(
)
override
{
RefPtr
<
gfxContext
>
ctx
=
mFrame
-
>
PresShell
(
)
-
>
CreateReferenceRenderingContext
(
)
;
RefPtr
<
DrawTarget
>
dt
=
ctx
-
>
GetDrawTarget
(
)
;
return
dt
.
forget
(
)
;
}
private
:
nsIFrame
*
mFrame
;
}
;
static
gfxTextRun
*
GetEllipsisTextRun
(
nsIFrame
*
aFrame
)
{
RefPtr
<
nsFontMetrics
>
fm
=
nsLayoutUtils
:
:
GetInflatedFontMetricsForFrame
(
aFrame
)
;
LazyReferenceRenderingDrawTargetGetterFromFrame
lazyRefDrawTargetGetter
(
aFrame
)
;
return
fm
-
>
GetThebesFontGroup
(
)
-
>
GetEllipsisTextRun
(
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
nsLayoutUtils
:
:
GetTextRunOrientFlagsForStyle
(
aFrame
-
>
Style
(
)
)
lazyRefDrawTargetGetter
)
;
}
static
nsIFrame
*
GetSelfOrNearestBlock
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
)
;
return
aFrame
-
>
IsBlockFrameOrSubclass
(
)
?
aFrame
:
nsLayoutUtils
:
:
FindNearestBlockAncestor
(
aFrame
)
;
}
static
bool
IsAtomicElement
(
nsIFrame
*
aFrame
LayoutFrameType
aFrameType
)
{
MOZ_ASSERT
(
!
aFrame
-
>
IsBlockFrameOrSubclass
(
)
|
|
!
aFrame
-
>
IsBlockOutside
(
)
"
unexpected
block
frame
"
)
;
MOZ_ASSERT
(
aFrameType
!
=
LayoutFrameType
:
:
Placeholder
"
unexpected
placeholder
frame
"
)
;
return
!
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eLineParticipant
)
;
}
static
bool
IsFullyClipped
(
nsTextFrame
*
aFrame
nscoord
aLeft
nscoord
aRight
nscoord
*
aSnappedLeft
nscoord
*
aSnappedRight
)
{
*
aSnappedLeft
=
aLeft
;
*
aSnappedRight
=
aRight
;
if
(
aLeft
<
=
0
&
&
aRight
<
=
0
)
{
return
false
;
}
return
!
aFrame
-
>
MeasureCharClippedText
(
aLeft
aRight
aSnappedLeft
aSnappedRight
)
;
}
static
bool
IsInlineAxisOverflowVisible
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
&
&
aFrame
-
>
IsBlockFrameOrSubclass
(
)
"
expected
a
block
frame
"
)
;
nsIFrame
*
f
=
aFrame
;
while
(
f
&
&
f
-
>
Style
(
)
-
>
IsAnonBox
(
)
&
&
!
f
-
>
IsScrollFrame
(
)
)
{
f
=
f
-
>
GetParent
(
)
;
}
if
(
!
f
)
{
return
true
;
}
auto
overflow
=
aFrame
-
>
GetWritingMode
(
)
.
IsVertical
(
)
?
f
-
>
StyleDisplay
(
)
-
>
mOverflowY
:
f
-
>
StyleDisplay
(
)
-
>
mOverflowX
;
return
overflow
=
=
StyleOverflow
:
:
Visible
;
}
static
void
ClipMarker
(
const
nsRect
&
aContentArea
const
nsRect
&
aMarkerRect
DisplayListClipState
:
:
AutoSaveRestore
&
aClipState
)
{
nscoord
rightOverflow
=
aMarkerRect
.
XMost
(
)
-
aContentArea
.
XMost
(
)
;
nsRect
markerRect
=
aMarkerRect
;
if
(
rightOverflow
>
0
)
{
markerRect
.
width
-
=
rightOverflow
;
aClipState
.
ClipContentDescendants
(
markerRect
)
;
}
else
{
nscoord
leftOverflow
=
aContentArea
.
x
-
aMarkerRect
.
x
;
if
(
leftOverflow
>
0
)
{
markerRect
.
width
-
=
leftOverflow
;
markerRect
.
x
+
=
leftOverflow
;
aClipState
.
ClipContentDescendants
(
markerRect
)
;
}
}
}
static
void
InflateIStart
(
WritingMode
aWM
LogicalRect
*
aRect
nscoord
aDelta
)
{
nscoord
iend
=
aRect
-
>
IEnd
(
aWM
)
;
aRect
-
>
IStart
(
aWM
)
-
=
aDelta
;
aRect
-
>
ISize
(
aWM
)
=
std
:
:
max
(
iend
-
aRect
-
>
IStart
(
aWM
)
0
)
;
}
static
void
InflateIEnd
(
WritingMode
aWM
LogicalRect
*
aRect
nscoord
aDelta
)
{
aRect
-
>
ISize
(
aWM
)
=
std
:
:
max
(
aRect
-
>
ISize
(
aWM
)
+
aDelta
0
)
;
}
static
bool
IsFrameDescendantOfAny
(
nsIFrame
*
aChild
const
TextOverflow
:
:
FrameHashtable
&
aSetOfFrames
nsIFrame
*
aCommonAncestor
)
{
for
(
nsIFrame
*
f
=
aChild
;
f
&
&
f
!
=
aCommonAncestor
;
f
=
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
f
)
)
{
if
(
aSetOfFrames
.
GetEntry
(
f
)
)
{
return
true
;
}
}
return
false
;
}
class
nsDisplayTextOverflowMarker
final
:
public
nsPaintedDisplayItem
{
public
:
nsDisplayTextOverflowMarker
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
nsRect
&
aRect
nscoord
aAscent
const
StyleTextOverflowSide
&
aStyle
uint32_t
aLineNumber
uint16_t
aIndex
)
:
nsPaintedDisplayItem
(
aBuilder
aFrame
)
mRect
(
aRect
)
mStyle
(
aStyle
)
mAscent
(
aAscent
)
mIndex
(
(
aLineNumber
<
<
1
)
+
aIndex
)
{
MOZ_COUNT_CTOR
(
nsDisplayTextOverflowMarker
)
;
}
static
uint16_t
CalculatePerFrameIndex
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
nsRect
&
aRect
nscoord
aAscent
const
StyleTextOverflowSide
&
aStyle
uint32_t
aLineNumber
uint16_t
aIndex
)
{
return
(
aLineNumber
<
<
1
)
+
aIndex
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayTextOverflowMarker
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayTextOverflowMarker
)
;
}
#
endif
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
{
*
aSnap
=
false
;
nsRect
shadowRect
=
nsLayoutUtils
:
:
GetTextShadowRectsUnion
(
mRect
mFrame
)
;
return
mRect
.
Union
(
shadowRect
)
;
}
virtual
nsRect
GetComponentAlphaBounds
(
nsDisplayListBuilder
*
aBuilder
)
const
override
{
if
(
gfxPlatform
:
:
GetPlatform
(
)
-
>
RespectsFontStyleSmoothing
(
)
)
{
if
(
mFrame
-
>
StyleFont
(
)
-
>
mFont
.
smoothing
=
=
NS_FONT_SMOOTHING_GRAYSCALE
)
{
return
nsRect
(
)
;
}
}
bool
snap
;
return
GetBounds
(
aBuilder
&
snap
)
;
}
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
;
void
PaintTextToContext
(
gfxContext
*
aCtx
nsPoint
aOffsetFromRect
)
;
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
layers
:
:
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
NS_DISPLAY_DECL_NAME
(
"
TextOverflow
"
TYPE_TEXT_OVERFLOW
)
private
:
nsRect
mRect
;
const
StyleTextOverflowSide
mStyle
;
nscoord
mAscent
;
uint16_t
mIndex
;
}
;
static
void
PaintTextShadowCallback
(
gfxContext
*
aCtx
nsPoint
aShadowOffset
const
nscolor
&
aShadowColor
void
*
aData
)
{
reinterpret_cast
<
nsDisplayTextOverflowMarker
*
>
(
aData
)
-
>
PaintTextToContext
(
aCtx
aShadowOffset
)
;
}
void
nsDisplayTextOverflowMarker
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
DrawTargetAutoDisableSubpixelAntialiasing
disable
(
aCtx
-
>
GetDrawTarget
(
)
IsSubpixelAADisabled
(
)
)
;
nscolor
foregroundColor
=
nsLayoutUtils
:
:
GetColor
(
mFrame
&
nsStyleText
:
:
mWebkitTextFillColor
)
;
nsLayoutUtils
:
:
PaintTextShadow
(
mFrame
aCtx
mRect
GetPaintRect
(
)
foregroundColor
PaintTextShadowCallback
(
void
*
)
this
)
;
aCtx
-
>
SetColor
(
gfx
:
:
Color
:
:
FromABGR
(
foregroundColor
)
)
;
PaintTextToContext
(
aCtx
nsPoint
(
0
0
)
)
;
}
void
nsDisplayTextOverflowMarker
:
:
PaintTextToContext
(
gfxContext
*
aCtx
nsPoint
aOffsetFromRect
)
{
WritingMode
wm
=
mFrame
-
>
GetWritingMode
(
)
;
nsPoint
pt
(
mRect
.
x
mRect
.
y
)
;
if
(
wm
.
IsVertical
(
)
)
{
if
(
wm
.
IsVerticalLR
(
)
)
{
pt
.
x
=
NSToCoordFloor
(
nsLayoutUtils
:
:
GetSnappedBaselineX
(
mFrame
aCtx
pt
.
x
mAscent
)
)
;
}
else
{
pt
.
x
=
NSToCoordFloor
(
nsLayoutUtils
:
:
GetSnappedBaselineX
(
mFrame
aCtx
pt
.
x
+
mRect
.
width
-
mAscent
)
)
;
}
}
else
{
pt
.
y
=
NSToCoordFloor
(
nsLayoutUtils
:
:
GetSnappedBaselineY
(
mFrame
aCtx
pt
.
y
mAscent
)
)
;
}
pt
+
=
aOffsetFromRect
;
if
(
mStyle
.
IsEllipsis
(
)
)
{
gfxTextRun
*
textRun
=
GetEllipsisTextRun
(
mFrame
)
;
if
(
textRun
)
{
NS_ASSERTION
(
!
textRun
-
>
IsRightToLeft
(
)
"
Ellipsis
textruns
should
always
be
LTR
!
"
)
;
gfx
:
:
Point
gfxPt
(
pt
.
x
pt
.
y
)
;
textRun
-
>
Draw
(
gfxTextRun
:
:
Range
(
textRun
)
gfxPt
gfxTextRun
:
:
DrawParams
(
aCtx
)
)
;
}
}
else
{
RefPtr
<
nsFontMetrics
>
fm
=
nsLayoutUtils
:
:
GetInflatedFontMetricsForFrame
(
mFrame
)
;
NS_ConvertUTF8toUTF16
str16
{
mStyle
.
AsString
(
)
.
AsString
(
)
}
;
nsLayoutUtils
:
:
DrawString
(
mFrame
*
fm
aCtx
str16
.
get
(
)
str16
.
Length
(
)
pt
)
;
}
}
bool
nsDisplayTextOverflowMarker
:
:
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
layers
:
:
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
bool
snap
;
nsRect
bounds
=
GetBounds
(
aDisplayListBuilder
&
snap
)
;
if
(
bounds
.
IsEmpty
(
)
)
{
return
true
;
}
RefPtr
<
TextDrawTarget
>
textDrawer
=
new
TextDrawTarget
(
aBuilder
aResources
aSc
aManager
this
bounds
)
;
RefPtr
<
gfxContext
>
captureCtx
=
gfxContext
:
:
CreateOrNull
(
textDrawer
)
;
Paint
(
aDisplayListBuilder
captureCtx
)
;
textDrawer
-
>
TerminateShadows
(
)
;
return
textDrawer
-
>
Finish
(
)
;
}
TextOverflow
:
:
TextOverflow
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aBlockFrame
)
:
mContentArea
(
aBlockFrame
-
>
GetWritingMode
(
)
aBlockFrame
-
>
GetContentRectRelativeToSelf
(
)
aBlockFrame
-
>
GetSize
(
)
)
mBuilder
(
aBuilder
)
mBlock
(
aBlockFrame
)
mScrollableFrame
(
nsLayoutUtils
:
:
GetScrollableFrameFor
(
aBlockFrame
)
)
mBlockSize
(
aBlockFrame
-
>
GetSize
(
)
)
mBlockWM
(
aBlockFrame
-
>
GetWritingMode
(
)
)
mAdjustForPixelSnapping
(
false
)
{
#
ifdef
MOZ_XUL
if
(
!
mScrollableFrame
)
{
auto
pseudoType
=
aBlockFrame
-
>
Style
(
)
-
>
GetPseudoType
(
)
;
if
(
pseudoType
=
=
PseudoStyleType
:
:
mozXULAnonymousBlock
)
{
mScrollableFrame
=
nsLayoutUtils
:
:
GetScrollableFrameFor
(
aBlockFrame
-
>
GetParent
(
)
)
;
mAdjustForPixelSnapping
=
mBlockWM
.
IsBidiRTL
(
)
;
}
}
#
endif
mCanHaveInlineAxisScrollbar
=
false
;
if
(
mScrollableFrame
)
{
auto
scrollbarStyle
=
mBlockWM
.
IsVertical
(
)
?
mScrollableFrame
-
>
GetScrollStyles
(
)
.
mVertical
:
mScrollableFrame
-
>
GetScrollStyles
(
)
.
mHorizontal
;
mCanHaveInlineAxisScrollbar
=
scrollbarStyle
!
=
StyleOverflow
:
:
Hidden
;
if
(
!
mAdjustForPixelSnapping
)
{
mAdjustForPixelSnapping
=
mCanHaveInlineAxisScrollbar
;
}
const
nsSize
nullContainerSize
;
mContentArea
.
MoveBy
(
mBlockWM
LogicalPoint
(
mBlockWM
mScrollableFrame
-
>
GetScrollPosition
(
)
nullContainerSize
)
)
;
}
uint8_t
direction
=
aBlockFrame
-
>
StyleVisibility
(
)
-
>
mDirection
;
const
nsStyleTextReset
*
style
=
aBlockFrame
-
>
StyleTextReset
(
)
;
const
auto
&
textOverflow
=
style
-
>
mTextOverflow
;
bool
shouldToggleDirection
=
textOverflow
.
sides_are_logical
&
&
(
direction
=
=
NS_STYLE_DIRECTION_RTL
)
;
const
auto
&
leftSide
=
shouldToggleDirection
?
textOverflow
.
second
:
textOverflow
.
first
;
const
auto
&
rightSide
=
shouldToggleDirection
?
textOverflow
.
first
:
textOverflow
.
second
;
if
(
mBlockWM
.
IsBidiLTR
(
)
)
{
mIStart
.
Init
(
leftSide
)
;
mIEnd
.
Init
(
rightSide
)
;
}
else
{
mIStart
.
Init
(
rightSide
)
;
mIEnd
.
Init
(
leftSide
)
;
}
}
Maybe
<
TextOverflow
>
TextOverflow
:
:
WillProcessLines
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aBlockFrame
)
{
if
(
aBuilder
-
>
IsForEventDelivery
(
)
|
|
aBuilder
-
>
IsForFrameVisibility
(
)
|
|
!
CanHaveOverflowMarkers
(
aBlockFrame
)
)
{
return
Nothing
(
)
;
}
nsIScrollableFrame
*
scrollableFrame
=
nsLayoutUtils
:
:
GetScrollableFrameFor
(
aBlockFrame
)
;
if
(
scrollableFrame
&
&
scrollableFrame
-
>
IsTransformingByAPZ
(
)
)
{
return
Nothing
(
)
;
}
return
Some
(
TextOverflow
(
aBuilder
aBlockFrame
)
)
;
}
void
TextOverflow
:
:
ExamineFrameSubtree
(
nsIFrame
*
aFrame
const
LogicalRect
&
aContentArea
const
LogicalRect
&
aInsideMarkersArea
FrameHashtable
*
aFramesToHide
AlignmentEdges
*
aAlignmentEdges
bool
*
aFoundVisibleTextOrAtomic
InnerClipEdges
*
aClippedMarkerEdges
)
{
const
LayoutFrameType
frameType
=
aFrame
-
>
Type
(
)
;
if
(
frameType
=
=
LayoutFrameType
:
:
Br
|
|
frameType
=
=
LayoutFrameType
:
:
Placeholder
)
{
return
;
}
const
bool
isAtomic
=
IsAtomicElement
(
aFrame
frameType
)
;
if
(
aFrame
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
)
{
LogicalRect
childRect
=
GetLogicalScrollableOverflowRectRelativeToBlock
(
aFrame
)
;
bool
overflowIStart
=
childRect
.
IStart
(
mBlockWM
)
<
aContentArea
.
IStart
(
mBlockWM
)
;
bool
overflowIEnd
=
childRect
.
IEnd
(
mBlockWM
)
>
aContentArea
.
IEnd
(
mBlockWM
)
;
if
(
overflowIStart
)
{
mIStart
.
mHasOverflow
=
true
;
}
if
(
overflowIEnd
)
{
mIEnd
.
mHasOverflow
=
true
;
}
if
(
isAtomic
&
&
(
(
mIStart
.
mActive
&
&
overflowIStart
)
|
|
(
mIEnd
.
mActive
&
&
overflowIEnd
)
)
)
{
aFramesToHide
-
>
PutEntry
(
aFrame
)
;
}
else
if
(
isAtomic
|
|
frameType
=
=
LayoutFrameType
:
:
Text
)
{
AnalyzeMarkerEdges
(
aFrame
frameType
aInsideMarkersArea
aFramesToHide
aAlignmentEdges
aFoundVisibleTextOrAtomic
aClippedMarkerEdges
)
;
}
}
if
(
isAtomic
)
{
return
;
}
for
(
nsIFrame
*
child
:
aFrame
-
>
PrincipalChildList
(
)
)
{
ExamineFrameSubtree
(
child
aContentArea
aInsideMarkersArea
aFramesToHide
aAlignmentEdges
aFoundVisibleTextOrAtomic
aClippedMarkerEdges
)
;
}
}
void
TextOverflow
:
:
AnalyzeMarkerEdges
(
nsIFrame
*
aFrame
LayoutFrameType
aFrameType
const
LogicalRect
&
aInsideMarkersArea
FrameHashtable
*
aFramesToHide
AlignmentEdges
*
aAlignmentEdges
bool
*
aFoundVisibleTextOrAtomic
InnerClipEdges
*
aClippedMarkerEdges
)
{
MOZ_ASSERT
(
aFrameType
=
=
LayoutFrameType
:
:
Text
|
|
IsAtomicElement
(
aFrame
aFrameType
)
)
;
LogicalRect
borderRect
(
mBlockWM
nsRect
(
aFrame
-
>
GetOffsetTo
(
mBlock
)
aFrame
-
>
GetSize
(
)
)
mBlockSize
)
;
nscoord
istartOverlap
=
std
:
:
max
(
aInsideMarkersArea
.
IStart
(
mBlockWM
)
-
borderRect
.
IStart
(
mBlockWM
)
0
)
;
nscoord
iendOverlap
=
std
:
:
max
(
borderRect
.
IEnd
(
mBlockWM
)
-
aInsideMarkersArea
.
IEnd
(
mBlockWM
)
0
)
;
bool
insideIStartEdge
=
aInsideMarkersArea
.
IStart
(
mBlockWM
)
<
=
borderRect
.
IEnd
(
mBlockWM
)
;
bool
insideIEndEdge
=
borderRect
.
IStart
(
mBlockWM
)
<
=
aInsideMarkersArea
.
IEnd
(
mBlockWM
)
;
if
(
istartOverlap
>
0
)
{
aClippedMarkerEdges
-
>
AccumulateIStart
(
mBlockWM
borderRect
)
;
if
(
!
mIStart
.
mActive
)
{
istartOverlap
=
0
;
}
}
if
(
iendOverlap
>
0
)
{
aClippedMarkerEdges
-
>
AccumulateIEnd
(
mBlockWM
borderRect
)
;
if
(
!
mIEnd
.
mActive
)
{
iendOverlap
=
0
;
}
}
if
(
(
istartOverlap
>
0
&
&
insideIStartEdge
)
|
|
(
iendOverlap
>
0
&
&
insideIEndEdge
)
)
{
if
(
aFrameType
=
=
LayoutFrameType
:
:
Text
)
{
auto
textFrame
=
static_cast
<
nsTextFrame
*
>
(
aFrame
)
;
if
(
(
aInsideMarkersArea
.
IStart
(
mBlockWM
)
<
aInsideMarkersArea
.
IEnd
(
mBlockWM
)
)
&
&
textFrame
-
>
HasNonSuppressedText
(
)
)
{
nscoord
snappedIStart
snappedIEnd
;
bool
isFullyClipped
=
mBlockWM
.
IsBidiLTR
(
)
?
IsFullyClipped
(
textFrame
istartOverlap
iendOverlap
&
snappedIStart
&
snappedIEnd
)
:
IsFullyClipped
(
textFrame
iendOverlap
istartOverlap
&
snappedIEnd
&
snappedIStart
)
;
if
(
!
isFullyClipped
)
{
LogicalRect
snappedRect
=
borderRect
;
if
(
istartOverlap
>
0
)
{
snappedRect
.
IStart
(
mBlockWM
)
+
=
snappedIStart
;
snappedRect
.
ISize
(
mBlockWM
)
-
=
snappedIStart
;
}
if
(
iendOverlap
>
0
)
{
snappedRect
.
ISize
(
mBlockWM
)
-
=
snappedIEnd
;
}
aAlignmentEdges
-
>
AccumulateInner
(
mBlockWM
snappedRect
)
;
*
aFoundVisibleTextOrAtomic
=
true
;
}
}
}
else
{
aFramesToHide
-
>
PutEntry
(
aFrame
)
;
}
}
else
if
(
!
insideIStartEdge
|
|
!
insideIEndEdge
)
{
if
(
!
insideIStartEdge
)
{
aAlignmentEdges
-
>
AccumulateOuter
(
mBlockWM
borderRect
)
;
}
if
(
IsAtomicElement
(
aFrame
aFrameType
)
)
{
aFramesToHide
-
>
PutEntry
(
aFrame
)
;
}
}
else
{
aAlignmentEdges
-
>
AccumulateInner
(
mBlockWM
borderRect
)
;
if
(
aFrameType
=
=
LayoutFrameType
:
:
Text
)
{
auto
textFrame
=
static_cast
<
nsTextFrame
*
>
(
aFrame
)
;
if
(
textFrame
-
>
HasNonSuppressedText
(
)
)
{
*
aFoundVisibleTextOrAtomic
=
true
;
}
}
else
{
*
aFoundVisibleTextOrAtomic
=
true
;
}
}
}
LogicalRect
TextOverflow
:
:
ExamineLineFrames
(
nsLineBox
*
aLine
FrameHashtable
*
aFramesToHide
AlignmentEdges
*
aAlignmentEdges
)
{
bool
suppressIStart
=
mIStart
.
IsSuppressed
(
)
;
bool
suppressIEnd
=
mIEnd
.
IsSuppressed
(
)
;
if
(
mCanHaveInlineAxisScrollbar
)
{
LogicalPoint
pos
(
mBlockWM
mScrollableFrame
-
>
GetScrollPosition
(
)
mBlockSize
)
;
LogicalRect
scrollRange
(
mBlockWM
mScrollableFrame
-
>
GetScrollRange
(
)
mBlockSize
)
;
if
(
pos
.
I
(
mBlockWM
)
<
=
scrollRange
.
IStart
(
mBlockWM
)
)
{
suppressIStart
=
true
;
}
if
(
pos
.
I
(
mBlockWM
)
>
=
scrollRange
.
IEnd
(
mBlockWM
)
)
{
if
(
!
mIEnd
.
mHasBlockEllipsis
)
{
suppressIEnd
=
true
;
}
}
}
LogicalRect
contentArea
=
mContentArea
;
bool
snapStart
=
true
snapEnd
=
true
;
nscoord
startEdge
endEdge
;
if
(
aLine
-
>
GetFloatEdges
(
&
startEdge
&
endEdge
)
)
{
nscoord
delta
=
endEdge
-
contentArea
.
IEnd
(
mBlockWM
)
;
if
(
delta
<
0
)
{
nscoord
newSize
=
contentArea
.
ISize
(
mBlockWM
)
+
delta
;
contentArea
.
ISize
(
mBlockWM
)
=
std
:
:
max
(
nscoord
(
0
)
newSize
)
;
snapEnd
=
false
;
}
delta
=
startEdge
-
contentArea
.
IStart
(
mBlockWM
)
;
if
(
delta
>
0
)
{
contentArea
.
IStart
(
mBlockWM
)
=
startEdge
;
nscoord
newSize
=
contentArea
.
ISize
(
mBlockWM
)
-
delta
;
contentArea
.
ISize
(
mBlockWM
)
=
std
:
:
max
(
nscoord
(
0
)
newSize
)
;
snapStart
=
false
;
}
}
LogicalRect
nonSnappedContentArea
=
contentArea
;
if
(
mAdjustForPixelSnapping
)
{
const
nscoord
scrollAdjust
=
mBlock
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
if
(
snapStart
)
{
InflateIStart
(
mBlockWM
&
contentArea
scrollAdjust
)
;
}
if
(
snapEnd
)
{
InflateIEnd
(
mBlockWM
&
contentArea
scrollAdjust
)
;
}
}
LogicalRect
lineRect
(
mBlockWM
aLine
-
>
GetScrollableOverflowArea
(
)
mBlockSize
)
;
const
bool
istartWantsMarker
=
!
suppressIStart
&
&
lineRect
.
IStart
(
mBlockWM
)
<
contentArea
.
IStart
(
mBlockWM
)
;
const
bool
iendWantsTextOverflowMarker
=
!
suppressIEnd
&
&
lineRect
.
IEnd
(
mBlockWM
)
>
contentArea
.
IEnd
(
mBlockWM
)
;
const
bool
iendWantsBlockEllipsisMarker
=
!
suppressIEnd
&
&
mIEnd
.
mHasBlockEllipsis
;
const
bool
iendWantsMarker
=
iendWantsTextOverflowMarker
|
|
iendWantsBlockEllipsisMarker
;
if
(
!
istartWantsMarker
&
&
!
iendWantsMarker
)
{
return
nonSnappedContentArea
;
}
int
pass
=
0
;
bool
retryEmptyLine
=
true
;
bool
guessIStart
=
istartWantsMarker
;
bool
guessIEnd
=
iendWantsMarker
;
mIStart
.
mActive
=
istartWantsMarker
;
mIEnd
.
mActive
=
iendWantsMarker
;
mIStart
.
mEdgeAligned
=
mCanHaveInlineAxisScrollbar
&
&
istartWantsMarker
;
mIEnd
.
mEdgeAligned
=
mCanHaveInlineAxisScrollbar
&
&
iendWantsTextOverflowMarker
;
bool
clippedIStartMarker
=
false
;
bool
clippedIEndMarker
=
false
;
do
{
if
(
guessIStart
)
{
mIStart
.
SetupString
(
mBlock
)
;
}
if
(
guessIEnd
)
{
mIEnd
.
SetupString
(
mBlock
)
;
}
nscoord
istartMarkerISize
=
mIStart
.
mActive
?
mIStart
.
mISize
:
0
;
nscoord
iendMarkerISize
=
mIEnd
.
mActive
?
mIEnd
.
mISize
:
0
;
if
(
istartMarkerISize
&
&
iendMarkerISize
&
&
istartMarkerISize
+
iendMarkerISize
>
contentArea
.
ISize
(
mBlockWM
)
)
{
istartMarkerISize
=
0
;
}
LogicalRect
insideMarkersArea
=
nonSnappedContentArea
;
if
(
guessIStart
)
{
InflateIStart
(
mBlockWM
&
insideMarkersArea
-
istartMarkerISize
)
;
}
if
(
guessIEnd
)
{
InflateIEnd
(
mBlockWM
&
insideMarkersArea
-
iendMarkerISize
)
;
}
bool
foundVisibleTextOrAtomic
=
false
;
int32_t
n
=
aLine
-
>
GetChildCount
(
)
;
nsIFrame
*
child
=
aLine
-
>
mFirstChild
;
InnerClipEdges
clippedMarkerEdges
;
for
(
;
n
-
-
>
0
;
child
=
child
-
>
GetNextSibling
(
)
)
{
ExamineFrameSubtree
(
child
contentArea
insideMarkersArea
aFramesToHide
aAlignmentEdges
&
foundVisibleTextOrAtomic
&
clippedMarkerEdges
)
;
}
if
(
!
foundVisibleTextOrAtomic
&
&
retryEmptyLine
)
{
aAlignmentEdges
-
>
mAssignedInner
=
false
;
aAlignmentEdges
-
>
mIEndOuter
=
0
;
aFramesToHide
-
>
Clear
(
)
;
pass
=
-
1
;
if
(
mIStart
.
IsNeeded
(
)
&
&
mIStart
.
mActive
&
&
!
clippedIStartMarker
)
{
if
(
clippedMarkerEdges
.
mAssignedIStart
&
&
clippedMarkerEdges
.
mIStart
>
nonSnappedContentArea
.
IStart
(
mBlockWM
)
)
{
mIStart
.
mISize
=
clippedMarkerEdges
.
mIStart
-
nonSnappedContentArea
.
IStart
(
mBlockWM
)
;
NS_ASSERTION
(
mIStart
.
mISize
<
mIStart
.
mIntrinsicISize
"
clipping
a
marker
should
make
it
strictly
smaller
"
)
;
clippedIStartMarker
=
true
;
}
else
{
mIStart
.
mActive
=
guessIStart
=
false
;
}
continue
;
}
if
(
mIEnd
.
IsNeeded
(
)
&
&
mIEnd
.
mActive
&
&
!
clippedIEndMarker
)
{
if
(
clippedMarkerEdges
.
mAssignedIEnd
&
&
nonSnappedContentArea
.
IEnd
(
mBlockWM
)
>
clippedMarkerEdges
.
mIEnd
)
{
mIEnd
.
mISize
=
nonSnappedContentArea
.
IEnd
(
mBlockWM
)
-
clippedMarkerEdges
.
mIEnd
;
NS_ASSERTION
(
mIEnd
.
mISize
<
mIEnd
.
mIntrinsicISize
"
clipping
a
marker
should
make
it
strictly
smaller
"
)
;
clippedIEndMarker
=
true
;
}
else
{
mIEnd
.
mActive
=
guessIEnd
=
false
;
}
continue
;
}
retryEmptyLine
=
false
;
mIStart
.
mISize
=
mIStart
.
mIntrinsicISize
;
mIStart
.
mActive
=
guessIStart
=
istartWantsMarker
;
mIEnd
.
mISize
=
mIEnd
.
mIntrinsicISize
;
mIEnd
.
mActive
=
guessIEnd
=
iendWantsMarker
;
if
(
mIEnd
.
IsNeeded
(
)
&
&
mIEnd
.
mActive
&
&
mIEnd
.
mHasBlockEllipsis
)
{
NS_ASSERTION
(
nonSnappedContentArea
.
IStart
(
mBlockWM
)
>
aAlignmentEdges
-
>
mIEndOuter
"
Expected
the
alignment
edge
for
the
out
of
view
content
"
"
to
be
before
the
start
of
the
content
area
"
)
;
mIEnd
.
mISize
=
std
:
:
max
(
mIEnd
.
mIntrinsicISize
-
(
nonSnappedContentArea
.
IStart
(
mBlockWM
)
-
aAlignmentEdges
-
>
mIEndOuter
)
0
)
;
}
continue
;
}
if
(
guessIStart
=
=
(
mIStart
.
mActive
&
&
mIStart
.
IsNeeded
(
)
)
&
&
guessIEnd
=
=
(
mIEnd
.
mActive
&
&
mIEnd
.
IsNeeded
(
)
)
)
{
break
;
}
else
{
guessIStart
=
mIStart
.
mActive
&
&
mIStart
.
IsNeeded
(
)
;
guessIEnd
=
mIEnd
.
mActive
&
&
mIEnd
.
IsNeeded
(
)
;
mIStart
.
Reset
(
)
;
mIEnd
.
Reset
(
)
;
aFramesToHide
-
>
Clear
(
)
;
}
NS_ASSERTION
(
pass
=
=
0
"
2nd
pass
should
never
guess
wrong
"
)
;
}
while
(
+
+
pass
!
=
2
)
;
if
(
!
istartWantsMarker
|
|
!
mIStart
.
mActive
)
{
mIStart
.
Reset
(
)
;
}
if
(
!
iendWantsMarker
|
|
!
mIEnd
.
mActive
)
{
mIEnd
.
Reset
(
)
;
}
return
nonSnappedContentArea
;
}
void
TextOverflow
:
:
ProcessLine
(
const
nsDisplayListSet
&
aLists
nsLineBox
*
aLine
uint32_t
aLineNumber
)
{
if
(
mIStart
.
mStyle
-
>
IsClip
(
)
&
&
mIEnd
.
mStyle
-
>
IsClip
(
)
&
&
!
aLine
-
>
HasLineClampEllipsis
(
)
)
{
return
;
}
mIStart
.
Reset
(
)
;
mIStart
.
mActive
=
!
mIStart
.
mStyle
-
>
IsClip
(
)
;
mIEnd
.
Reset
(
)
;
mIEnd
.
mHasBlockEllipsis
=
aLine
-
>
HasLineClampEllipsis
(
)
;
mIEnd
.
mActive
=
!
mIEnd
.
mStyle
-
>
IsClip
(
)
|
|
aLine
-
>
HasLineClampEllipsis
(
)
;
FrameHashtable
framesToHide
(
64
)
;
AlignmentEdges
alignmentEdges
;
const
LogicalRect
contentArea
=
ExamineLineFrames
(
aLine
&
framesToHide
&
alignmentEdges
)
;
bool
needIStart
=
mIStart
.
IsNeeded
(
)
;
bool
needIEnd
=
mIEnd
.
IsNeeded
(
)
;
if
(
!
needIStart
&
&
!
needIEnd
)
{
return
;
}
NS_ASSERTION
(
!
mIStart
.
IsSuppressed
(
)
|
|
!
needIStart
"
left
marker
when
not
needed
"
)
;
NS_ASSERTION
(
!
mIEnd
.
IsSuppressed
(
)
|
|
!
needIEnd
"
right
marker
when
not
needed
"
)
;
if
(
needIStart
&
&
needIEnd
&
&
mIStart
.
mISize
+
mIEnd
.
mISize
>
contentArea
.
ISize
(
mBlockWM
)
)
{
needIStart
=
false
;
}
LogicalRect
insideMarkersArea
=
contentArea
;
if
(
needIStart
)
{
InflateIStart
(
mBlockWM
&
insideMarkersArea
-
mIStart
.
mISize
)
;
}
if
(
needIEnd
)
{
InflateIEnd
(
mBlockWM
&
insideMarkersArea
-
mIEnd
.
mISize
)
;
}
if
(
alignmentEdges
.
mAssignedInner
)
{
if
(
mIStart
.
mEdgeAligned
)
{
alignmentEdges
.
mIStart
=
insideMarkersArea
.
IStart
(
mBlockWM
)
;
}
if
(
mIEnd
.
mEdgeAligned
)
{
alignmentEdges
.
mIEnd
=
insideMarkersArea
.
IEnd
(
mBlockWM
)
;
}
LogicalRect
alignmentRect
(
mBlockWM
alignmentEdges
.
mIStart
insideMarkersArea
.
BStart
(
mBlockWM
)
alignmentEdges
.
ISize
(
)
1
)
;
insideMarkersArea
.
IntersectRect
(
insideMarkersArea
alignmentRect
)
;
}
else
{
if
(
mIEnd
.
mHasBlockEllipsis
)
{
insideMarkersArea
=
LogicalRect
(
mBlockWM
alignmentEdges
.
mIEndOuter
insideMarkersArea
.
BStart
(
mBlockWM
)
0
1
)
;
}
}
nsDisplayList
*
lists
[
]
=
{
aLists
.
Content
(
)
aLists
.
PositionedDescendants
(
)
}
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
lists
)
;
+
+
i
)
{
PruneDisplayListContents
(
lists
[
i
]
framesToHide
insideMarkersArea
)
;
}
CreateMarkers
(
aLine
needIStart
needIEnd
insideMarkersArea
contentArea
aLineNumber
)
;
}
void
TextOverflow
:
:
PruneDisplayListContents
(
nsDisplayList
*
aList
const
FrameHashtable
&
aFramesToHide
const
LogicalRect
&
aInsideMarkersArea
)
{
nsDisplayList
saved
;
nsDisplayItem
*
item
;
while
(
(
item
=
aList
-
>
RemoveBottom
(
)
)
)
{
nsIFrame
*
itemFrame
=
item
-
>
Frame
(
)
;
if
(
IsFrameDescendantOfAny
(
itemFrame
aFramesToHide
mBlock
)
)
{
item
-
>
Destroy
(
mBuilder
)
;
continue
;
}
nsDisplayList
*
wrapper
=
item
-
>
GetSameCoordinateSystemChildren
(
)
;
if
(
wrapper
)
{
if
(
!
itemFrame
|
|
GetSelfOrNearestBlock
(
itemFrame
)
=
=
mBlock
)
{
PruneDisplayListContents
(
wrapper
aFramesToHide
aInsideMarkersArea
)
;
}
}
nsDisplayText
*
textItem
=
itemFrame
?
nsDisplayText
:
:
CheckCast
(
item
)
:
nullptr
;
if
(
textItem
&
&
GetSelfOrNearestBlock
(
itemFrame
)
=
=
mBlock
)
{
LogicalRect
rect
=
GetLogicalScrollableOverflowRectRelativeToBlock
(
itemFrame
)
;
if
(
mIStart
.
IsNeeded
(
)
)
{
nscoord
istart
=
aInsideMarkersArea
.
IStart
(
mBlockWM
)
-
rect
.
IStart
(
mBlockWM
)
;
if
(
istart
>
0
)
{
(
mBlockWM
.
IsBidiLTR
(
)
?
textItem
-
>
VisIStartEdge
(
)
:
textItem
-
>
VisIEndEdge
(
)
)
=
istart
;
}
}
if
(
mIEnd
.
IsNeeded
(
)
)
{
nscoord
iend
=
rect
.
IEnd
(
mBlockWM
)
-
aInsideMarkersArea
.
IEnd
(
mBlockWM
)
;
if
(
iend
>
0
)
{
(
mBlockWM
.
IsBidiLTR
(
)
?
textItem
-
>
VisIEndEdge
(
)
:
textItem
-
>
VisIStartEdge
(
)
)
=
iend
;
}
}
}
saved
.
AppendToTop
(
item
)
;
}
aList
-
>
AppendToTop
(
&
saved
)
;
}
bool
TextOverflow
:
:
HasClippedTextOverflow
(
nsIFrame
*
aBlockFrame
)
{
const
nsStyleTextReset
*
style
=
aBlockFrame
-
>
StyleTextReset
(
)
;
return
style
-
>
mTextOverflow
.
first
.
IsClip
(
)
&
&
style
-
>
mTextOverflow
.
second
.
IsClip
(
)
;
}
bool
TextOverflow
:
:
HasBlockEllipsis
(
nsIFrame
*
aBlockFrame
)
{
nsBlockFrame
*
f
=
do_QueryFrame
(
aBlockFrame
)
;
return
f
&
&
f
-
>
HasAnyStateBits
(
NS_BLOCK_HAS_LINE_CLAMP_ELLIPSIS
)
;
}
bool
TextOverflow
:
:
CanHaveOverflowMarkers
(
nsIFrame
*
aBlockFrame
)
{
if
(
aBlockFrame
-
>
HasAnyStateBits
(
NS_BLOCK_HAS_LINE_CLAMP_ELLIPSIS
)
)
{
return
true
;
}
if
(
HasClippedTextOverflow
(
aBlockFrame
)
|
|
IsInlineAxisOverflowVisible
(
aBlockFrame
)
)
{
return
false
;
}
if
(
aBlockFrame
-
>
IsComboboxControlFrame
(
)
)
{
return
false
;
}
RefPtr
<
nsCaret
>
caret
=
aBlockFrame
-
>
PresShell
(
)
-
>
GetCaret
(
)
;
if
(
caret
&
&
caret
-
>
IsVisible
(
)
)
{
RefPtr
<
dom
:
:
Selection
>
domSelection
=
caret
-
>
GetSelection
(
)
;
if
(
domSelection
)
{
nsCOMPtr
<
nsIContent
>
content
=
nsIContent
:
:
FromNodeOrNull
(
domSelection
-
>
GetFocusNode
(
)
)
;
if
(
content
&
&
content
-
>
IsInclusiveDescendantOf
(
aBlockFrame
-
>
GetContent
(
)
)
)
{
return
false
;
}
}
}
return
true
;
}
void
TextOverflow
:
:
CreateMarkers
(
const
nsLineBox
*
aLine
bool
aCreateIStart
bool
aCreateIEnd
const
LogicalRect
&
aInsideMarkersArea
const
LogicalRect
&
aContentArea
uint32_t
aLineNumber
)
{
if
(
aCreateIStart
)
{
DisplayListClipState
:
:
AutoSaveRestore
clipState
(
mBuilder
)
;
LogicalRect
markerLogicalRect
(
mBlockWM
aInsideMarkersArea
.
IStart
(
mBlockWM
)
-
mIStart
.
mIntrinsicISize
aLine
-
>
BStart
(
)
mIStart
.
mIntrinsicISize
aLine
-
>
BSize
(
)
)
;
nsPoint
offset
=
mBuilder
-
>
ToReferenceFrame
(
mBlock
)
;
nsRect
markerRect
=
markerLogicalRect
.
GetPhysicalRect
(
mBlockWM
mBlockSize
)
+
offset
;
ClipMarker
(
aContentArea
.
GetPhysicalRect
(
mBlockWM
mBlockSize
)
+
offset
markerRect
clipState
)
;
mMarkerList
.
AppendNewToTop
<
nsDisplayTextOverflowMarker
>
(
mBuilder
mBlock
markerRect
aLine
-
>
GetLogicalAscent
(
)
*
mIStart
.
mStyle
aLineNumber
0
)
;
}
if
(
aCreateIEnd
)
{
DisplayListClipState
:
:
AutoSaveRestore
clipState
(
mBuilder
)
;
LogicalRect
markerLogicalRect
(
mBlockWM
aInsideMarkersArea
.
IEnd
(
mBlockWM
)
aLine
-
>
BStart
(
)
mIEnd
.
mIntrinsicISize
aLine
-
>
BSize
(
)
)
;
nsPoint
offset
=
mBuilder
-
>
ToReferenceFrame
(
mBlock
)
;
nsRect
markerRect
=
markerLogicalRect
.
GetPhysicalRect
(
mBlockWM
mBlockSize
)
+
offset
;
ClipMarker
(
aContentArea
.
GetPhysicalRect
(
mBlockWM
mBlockSize
)
+
offset
markerRect
clipState
)
;
mMarkerList
.
AppendNewToTop
<
nsDisplayTextOverflowMarker
>
(
mBuilder
mBlock
markerRect
aLine
-
>
GetLogicalAscent
(
)
mIEnd
.
mHasBlockEllipsis
?
StyleTextOverflowSide
:
:
Ellipsis
(
)
:
*
mIEnd
.
mStyle
aLineNumber
1
)
;
}
}
void
TextOverflow
:
:
Marker
:
:
SetupString
(
nsIFrame
*
aFrame
)
{
if
(
mInitialized
)
{
return
;
}
if
(
HasBlockEllipsis
(
aFrame
)
|
|
mStyle
-
>
IsEllipsis
(
)
)
{
gfxTextRun
*
textRun
=
GetEllipsisTextRun
(
aFrame
)
;
if
(
textRun
)
{
mISize
=
textRun
-
>
GetAdvanceWidth
(
)
;
}
else
{
mISize
=
0
;
}
}
else
{
RefPtr
<
gfxContext
>
rc
=
aFrame
-
>
PresShell
(
)
-
>
CreateReferenceRenderingContext
(
)
;
RefPtr
<
nsFontMetrics
>
fm
=
nsLayoutUtils
:
:
GetInflatedFontMetricsForFrame
(
aFrame
)
;
mISize
=
nsLayoutUtils
:
:
AppUnitWidthOfStringBidi
(
NS_ConvertUTF8toUTF16
(
mStyle
-
>
AsString
(
)
.
AsString
(
)
)
aFrame
*
fm
*
rc
)
;
}
mIntrinsicISize
=
mISize
;
mInitialized
=
true
;
}
}
}
