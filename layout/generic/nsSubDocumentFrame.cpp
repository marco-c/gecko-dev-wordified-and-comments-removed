#
include
"
nsSubDocumentFrame
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
HTMLFrameElement
.
h
"
#
include
"
mozilla
/
dom
/
ImageDocument
.
h
"
#
include
"
mozilla
/
dom
/
BrowserParent
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsGenericHTMLFrameElement
.
h
"
#
include
"
nsAttrValueInlines
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIContentViewer
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsView
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsStyleStruct
.
h
"
#
include
"
nsStyleStructInlines
.
h
"
#
include
"
nsFrameSetFrame
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsIObjectLoadingContent
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
RetainedDisplayListBuilder
.
h
"
#
include
"
nsObjectLoadingContent
.
h
"
#
include
"
Layers
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderUserData
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderScrollData
.
h
"
#
include
"
mozilla
/
layers
/
RenderRootStateManager
.
h
"
#
include
"
mozilla
/
layers
/
StackingContextHelper
.
h
"
#
include
"
mozilla
/
ProfilerLabels
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
layers
;
static
Document
*
GetDocumentFromView
(
nsView
*
aView
)
{
MOZ_ASSERT
(
aView
"
null
view
"
)
;
nsViewManager
*
vm
=
aView
-
>
GetViewManager
(
)
;
PresShell
*
presShell
=
vm
?
vm
-
>
GetPresShell
(
)
:
nullptr
;
return
presShell
?
presShell
-
>
GetDocument
(
)
:
nullptr
;
}
nsSubDocumentFrame
:
:
nsSubDocumentFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
:
nsAtomicContainerFrame
(
aStyle
aPresContext
kClassID
)
mOuterView
(
nullptr
)
mInnerView
(
nullptr
)
mIsInline
(
false
)
mPostedReflowCallback
(
false
)
mDidCreateDoc
(
false
)
mCallingShow
(
false
)
mIsInObjectOrEmbed
(
false
)
{
}
#
ifdef
ACCESSIBILITY
a11y
:
:
AccType
nsSubDocumentFrame
:
:
AccessibleType
(
)
{
return
a11y
:
:
eOuterDocType
;
}
#
endif
NS_QUERYFRAME_HEAD
(
nsSubDocumentFrame
)
NS_QUERYFRAME_ENTRY
(
nsSubDocumentFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsAtomicContainerFrame
)
class
AsyncFrameInit
:
public
Runnable
{
public
:
explicit
AsyncFrameInit
(
nsIFrame
*
aFrame
)
:
mozilla
:
:
Runnable
(
"
AsyncFrameInit
"
)
mFrame
(
aFrame
)
{
}
NS_IMETHOD
Run
(
)
override
{
AUTO_PROFILER_LABEL
(
"
AsyncFrameInit
:
:
Run
"
OTHER
)
;
if
(
mFrame
.
IsAlive
(
)
)
{
static_cast
<
nsSubDocumentFrame
*
>
(
mFrame
.
GetFrame
(
)
)
-
>
ShowViewer
(
)
;
}
return
NS_OK
;
}
private
:
WeakFrame
mFrame
;
}
;
static
void
InsertViewsInReverseOrder
(
nsView
*
aSibling
nsView
*
aParent
)
;
static
void
EndSwapDocShellsForViews
(
nsView
*
aView
)
;
void
nsSubDocumentFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
MOZ_ASSERT
(
aContent
)
;
mIsInline
=
!
aContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
frame
)
;
nsAtomicContainerFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
CreateView
(
)
;
EnsureInnerView
(
)
;
aContent
-
>
SetPrimaryFrame
(
this
)
;
RefPtr
<
nsFrameLoader
>
frameloader
=
FrameLoader
(
)
;
if
(
frameloader
)
{
nsCOMPtr
<
Document
>
oldContainerDoc
;
nsIFrame
*
detachedFrame
=
frameloader
-
>
GetDetachedSubdocFrame
(
getter_AddRefs
(
oldContainerDoc
)
)
;
frameloader
-
>
SetDetachedSubdocFrame
(
nullptr
nullptr
)
;
MOZ_ASSERT
(
oldContainerDoc
|
|
!
detachedFrame
)
;
if
(
oldContainerDoc
)
{
nsView
*
detachedView
=
detachedFrame
?
detachedFrame
-
>
GetView
(
)
:
nullptr
;
if
(
detachedView
&
&
oldContainerDoc
=
=
aContent
-
>
OwnerDoc
(
)
)
{
:
:
InsertViewsInReverseOrder
(
detachedView
mInnerView
)
;
:
:
EndSwapDocShellsForViews
(
mInnerView
-
>
GetFirstChild
(
)
)
;
}
else
{
frameloader
-
>
Hide
(
)
;
}
}
if
(
RefPtr
<
BrowsingContext
>
bc
=
frameloader
-
>
GetExtantBrowsingContext
(
)
)
{
mIsInObjectOrEmbed
=
bc
-
>
IsEmbedderTypeObjectOrEmbed
(
)
;
}
}
MaybeUpdateRemoteStyle
(
)
;
PropagateIsUnderHiddenEmbedderElementToSubView
(
PresShell
(
)
-
>
IsUnderHiddenEmbedderElement
(
)
|
|
!
StyleVisibility
(
)
-
>
IsVisible
(
)
)
;
nsContentUtils
:
:
AddScriptRunner
(
new
AsyncFrameInit
(
this
)
)
;
}
void
nsSubDocumentFrame
:
:
PropagateIsUnderHiddenEmbedderElementToSubView
(
bool
aIsUnderHiddenEmbedderElement
)
{
if
(
mFrameLoader
&
&
mFrameLoader
-
>
IsRemoteFrame
(
)
)
{
mFrameLoader
-
>
SendIsUnderHiddenEmbedderElement
(
aIsUnderHiddenEmbedderElement
)
;
return
;
}
if
(
!
mInnerView
)
{
return
;
}
nsView
*
subdocView
=
mInnerView
-
>
GetFirstChild
(
)
;
while
(
subdocView
)
{
if
(
mozilla
:
:
PresShell
*
presShell
=
subdocView
-
>
GetPresShell
(
)
)
{
presShell
-
>
SetIsUnderHiddenEmbedderElement
(
aIsUnderHiddenEmbedderElement
)
;
}
subdocView
=
subdocView
-
>
GetNextSibling
(
)
;
}
}
void
nsSubDocumentFrame
:
:
ShowViewer
(
)
{
if
(
mCallingShow
)
{
return
;
}
RefPtr
<
nsFrameLoader
>
frameloader
=
FrameLoader
(
)
;
if
(
!
frameloader
|
|
frameloader
-
>
IsDead
(
)
)
{
return
;
}
if
(
!
frameloader
-
>
IsRemoteFrame
(
)
&
&
!
PresContext
(
)
-
>
IsDynamic
(
)
)
{
(
void
)
EnsureInnerView
(
)
;
}
else
{
AutoWeakFrame
weakThis
(
this
)
;
mCallingShow
=
true
;
bool
didCreateDoc
=
frameloader
-
>
Show
(
this
)
;
if
(
!
weakThis
.
IsAlive
(
)
)
{
return
;
}
mCallingShow
=
false
;
mDidCreateDoc
=
didCreateDoc
;
if
(
!
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
)
{
frameloader
-
>
UpdatePositionAndSize
(
this
)
;
}
MaybeUpdateEmbedderColorScheme
(
)
;
if
(
!
weakThis
.
IsAlive
(
)
)
{
return
;
}
InvalidateFrame
(
)
;
}
}
nsIFrame
*
nsSubDocumentFrame
:
:
GetSubdocumentRootFrame
(
)
{
if
(
!
mInnerView
)
return
nullptr
;
nsView
*
subdocView
=
mInnerView
-
>
GetFirstChild
(
)
;
return
subdocView
?
subdocView
-
>
GetFrame
(
)
:
nullptr
;
}
mozilla
:
:
PresShell
*
nsSubDocumentFrame
:
:
GetSubdocumentPresShellForPainting
(
uint32_t
aFlags
)
{
if
(
!
mInnerView
)
return
nullptr
;
nsView
*
subdocView
=
mInnerView
-
>
GetFirstChild
(
)
;
if
(
!
subdocView
)
return
nullptr
;
mozilla
:
:
PresShell
*
presShell
=
nullptr
;
nsIFrame
*
subdocRootFrame
=
subdocView
-
>
GetFrame
(
)
;
if
(
subdocRootFrame
)
{
presShell
=
subdocRootFrame
-
>
PresShell
(
)
;
}
if
(
!
presShell
|
|
(
presShell
-
>
IsPaintingSuppressed
(
)
&
&
!
(
aFlags
&
IGNORE_PAINT_SUPPRESSION
)
)
)
{
nsView
*
nextView
=
subdocView
-
>
GetNextSibling
(
)
;
nsIFrame
*
frame
=
nullptr
;
if
(
nextView
)
{
frame
=
nextView
-
>
GetFrame
(
)
;
}
if
(
frame
)
{
mozilla
:
:
PresShell
*
presShellForNextView
=
frame
-
>
PresShell
(
)
;
if
(
!
presShell
|
|
(
presShellForNextView
&
&
!
presShellForNextView
-
>
IsPaintingSuppressed
(
)
&
&
StaticPrefs
:
:
layout_show_previous_page
(
)
)
)
{
subdocView
=
nextView
;
subdocRootFrame
=
frame
;
presShell
=
presShellForNextView
;
}
}
if
(
!
presShell
)
{
if
(
!
mFrameLoader
)
return
nullptr
;
nsIDocShell
*
docShell
=
mFrameLoader
-
>
GetDocShell
(
IgnoreErrors
(
)
)
;
if
(
!
docShell
)
return
nullptr
;
presShell
=
docShell
-
>
GetPresShell
(
)
;
}
}
return
presShell
;
}
nsRect
nsSubDocumentFrame
:
:
GetDestRect
(
)
{
nsRect
rect
=
GetContent
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
frame
)
?
GetRectRelativeToSelf
(
)
:
GetContentRectRelativeToSelf
(
)
;
return
nsLayoutUtils
:
:
ComputeObjectDestRect
(
rect
GetIntrinsicSize
(
)
GetIntrinsicRatio
(
)
StylePosition
(
)
)
;
}
ScreenIntSize
nsSubDocumentFrame
:
:
GetSubdocumentSize
(
)
{
if
(
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
)
{
if
(
RefPtr
<
nsFrameLoader
>
frameloader
=
FrameLoader
(
)
)
{
nsCOMPtr
<
Document
>
oldContainerDoc
;
nsIFrame
*
detachedFrame
=
frameloader
-
>
GetDetachedSubdocFrame
(
getter_AddRefs
(
oldContainerDoc
)
)
;
if
(
nsView
*
view
=
detachedFrame
?
detachedFrame
-
>
GetView
(
)
:
nullptr
)
{
nsSize
size
=
view
-
>
GetBounds
(
)
.
Size
(
)
;
nsPresContext
*
presContext
=
detachedFrame
-
>
PresContext
(
)
;
return
ScreenIntSize
(
presContext
-
>
AppUnitsToDevPixels
(
size
.
width
)
presContext
-
>
AppUnitsToDevPixels
(
size
.
height
)
)
;
}
}
return
ScreenIntSize
(
10
10
)
;
}
nsSize
docSizeAppUnits
=
GetDestRect
(
)
.
Size
(
)
;
nsPresContext
*
pc
=
PresContext
(
)
;
return
ScreenIntSize
(
pc
-
>
AppUnitsToDevPixels
(
docSizeAppUnits
.
width
)
pc
-
>
AppUnitsToDevPixels
(
docSizeAppUnits
.
height
)
)
;
}
static
void
WrapBackgroundColorInOwnLayer
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
)
{
for
(
nsDisplayItem
*
item
:
aList
-
>
TakeItems
(
)
)
{
if
(
item
-
>
GetType
(
)
=
=
DisplayItemType
:
:
TYPE_BACKGROUND_COLOR
)
{
nsDisplayList
tmpList
(
aBuilder
)
;
tmpList
.
AppendToTop
(
item
)
;
item
=
MakeDisplayItemWithIndex
<
nsDisplayOwnLayer
>
(
aBuilder
aFrame
nsDisplayOwnLayer
:
:
OwnLayerForSubdoc
&
tmpList
aBuilder
-
>
CurrentActiveScrolledRoot
(
)
nsDisplayOwnLayerFlags
:
:
None
ScrollbarData
{
}
true
false
)
;
}
aList
-
>
AppendToTop
(
item
)
;
}
}
void
nsSubDocumentFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
if
(
!
IsVisibleForPainting
(
)
)
{
return
;
}
nsFrameLoader
*
frameLoader
=
FrameLoader
(
)
;
bool
isRemoteFrame
=
frameLoader
&
&
frameLoader
-
>
IsRemoteFrame
(
)
;
const
bool
pointerEventsNone
=
Style
(
)
-
>
PointerEvents
(
)
=
=
StylePointerEvents
:
:
None
;
if
(
!
aBuilder
-
>
IsForEventDelivery
(
)
|
|
!
pointerEventsNone
)
{
nsDisplayListCollection
decorations
(
aBuilder
)
;
DisplayBorderBackgroundOutline
(
aBuilder
decorations
)
;
if
(
isRemoteFrame
)
{
WrapBackgroundColorInOwnLayer
(
aBuilder
this
decorations
.
BorderBackground
(
)
)
;
}
decorations
.
MoveTo
(
aLists
)
;
}
if
(
aBuilder
-
>
IsForEventDelivery
(
)
&
&
pointerEventsNone
)
{
return
;
}
if
(
IsContentHidden
(
)
)
{
return
;
}
bool
needToDescend
=
aBuilder
-
>
GetDescendIntoSubdocuments
(
)
;
if
(
!
mInnerView
|
|
!
needToDescend
)
{
return
;
}
if
(
isRemoteFrame
)
{
DisplayListClipState
:
:
AutoSaveRestore
clipState
(
aBuilder
)
;
clipState
.
ClipContainingBlockDescendantsToContentBox
(
aBuilder
this
)
;
aLists
.
Content
(
)
-
>
AppendNewToTop
<
nsDisplayRemote
>
(
aBuilder
this
)
;
return
;
}
RefPtr
<
mozilla
:
:
PresShell
>
presShell
=
GetSubdocumentPresShellForPainting
(
aBuilder
-
>
IsIgnoringPaintSuppression
(
)
?
IGNORE_PAINT_SUPPRESSION
:
0
)
;
if
(
!
presShell
)
{
return
;
}
if
(
aBuilder
-
>
IsInFilter
(
)
)
{
Document
*
outerDoc
=
PresShell
(
)
-
>
GetDocument
(
)
;
Document
*
innerDoc
=
presShell
-
>
GetDocument
(
)
;
if
(
outerDoc
&
&
innerDoc
)
{
if
(
!
outerDoc
-
>
NodePrincipal
(
)
-
>
Equals
(
innerDoc
-
>
NodePrincipal
(
)
)
)
{
outerDoc
-
>
SetUseCounter
(
eUseCounter_custom_FilteredCrossOriginIFrame
)
;
}
}
}
nsIFrame
*
subdocRootFrame
=
presShell
-
>
GetRootFrame
(
)
;
nsPresContext
*
presContext
=
presShell
-
>
GetPresContext
(
)
;
int32_t
parentAPD
=
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
int32_t
subdocAPD
=
presContext
-
>
AppUnitsPerDevPixel
(
)
;
nsRect
visible
;
nsRect
dirty
;
bool
ignoreViewportScrolling
=
false
;
if
(
subdocRootFrame
)
{
visible
=
aBuilder
-
>
GetVisibleRect
(
)
+
GetOffsetToCrossDoc
(
subdocRootFrame
)
;
dirty
=
aBuilder
-
>
GetDirtyRect
(
)
+
GetOffsetToCrossDoc
(
subdocRootFrame
)
;
visible
=
visible
.
ScaleToOtherAppUnitsRoundOut
(
parentAPD
subdocAPD
)
;
dirty
=
dirty
.
ScaleToOtherAppUnitsRoundOut
(
parentAPD
subdocAPD
)
;
if
(
nsIScrollableFrame
*
rootScrollableFrame
=
presShell
-
>
GetRootScrollFrameAsScrollable
(
)
)
{
nsRect
copyOfDirty
=
dirty
;
nsRect
copyOfVisible
=
visible
;
rootScrollableFrame
-
>
DecideScrollableLayer
(
aBuilder
&
copyOfVisible
&
copyOfDirty
true
)
;
ignoreViewportScrolling
=
presShell
-
>
IgnoringViewportScrolling
(
)
;
}
aBuilder
-
>
EnterPresShell
(
subdocRootFrame
pointerEventsNone
)
;
aBuilder
-
>
IncrementPresShellPaintCount
(
presShell
)
;
}
else
{
visible
=
aBuilder
-
>
GetVisibleRect
(
)
;
dirty
=
aBuilder
-
>
GetDirtyRect
(
)
;
}
DisplayListClipState
:
:
AutoSaveRestore
clipState
(
aBuilder
)
;
clipState
.
ClipContainingBlockDescendantsToContentBox
(
aBuilder
this
)
;
nsIScrollableFrame
*
sf
=
presShell
-
>
GetRootScrollFrameAsScrollable
(
)
;
bool
constructZoomItem
=
subdocRootFrame
&
&
parentAPD
!
=
subdocAPD
;
bool
needsOwnLayer
=
false
;
if
(
constructZoomItem
|
|
presContext
-
>
IsRootContentDocumentCrossProcess
(
)
|
|
(
sf
&
&
sf
-
>
IsScrollingActive
(
)
)
)
{
needsOwnLayer
=
true
;
}
nsDisplayList
childItems
(
aBuilder
)
;
{
DisplayListClipState
:
:
AutoSaveRestore
nestedClipState
(
aBuilder
)
;
if
(
needsOwnLayer
)
{
nestedClipState
.
Clear
(
)
;
}
nsIFrame
*
frame
=
subdocRootFrame
?
subdocRootFrame
:
this
;
nsDisplayListBuilder
:
:
AutoBuildingDisplayList
building
(
aBuilder
frame
visible
dirty
)
;
if
(
subdocRootFrame
)
{
nsIFrame
*
rootScrollFrame
=
presShell
-
>
GetRootScrollFrame
(
)
;
nsDisplayListBuilder
:
:
AutoCurrentScrollParentIdSetter
idSetter
(
aBuilder
ignoreViewportScrolling
&
&
rootScrollFrame
&
&
rootScrollFrame
-
>
GetContent
(
)
?
nsLayoutUtils
:
:
FindOrCreateIDFor
(
rootScrollFrame
-
>
GetContent
(
)
)
:
aBuilder
-
>
GetCurrentScrollParentId
(
)
)
;
bool
hasDocumentLevelListenersForApzAwareEvents
=
gfxPlatform
:
:
AsyncPanZoomEnabled
(
)
&
&
nsLayoutUtils
:
:
HasDocumentLevelListenersForApzAwareEvents
(
presShell
)
;
aBuilder
-
>
SetAncestorHasApzAwareEventHandler
(
hasDocumentLevelListenersForApzAwareEvents
)
;
subdocRootFrame
-
>
BuildDisplayListForStackingContext
(
aBuilder
&
childItems
)
;
}
if
(
!
aBuilder
-
>
IsForEventDelivery
(
)
)
{
nsRect
bounds
=
GetContentRectRelativeToSelf
(
)
+
aBuilder
-
>
ToReferenceFrame
(
this
)
;
if
(
subdocRootFrame
)
{
bounds
=
bounds
.
ScaleToOtherAppUnitsRoundOut
(
parentAPD
subdocAPD
)
;
}
if
(
nsLayoutUtils
:
:
NeedsPrintPreviewBackground
(
presContext
)
)
{
presShell
-
>
AddPrintPreviewBackgroundItem
(
aBuilder
&
childItems
frame
bounds
)
;
}
else
{
presShell
-
>
AddCanvasBackgroundColorItem
(
aBuilder
&
childItems
frame
bounds
NS_RGBA
(
0
0
0
0
)
AddCanvasBackgroundColorFlags
:
:
ForceDraw
)
;
}
}
}
if
(
subdocRootFrame
)
{
aBuilder
-
>
LeavePresShell
(
subdocRootFrame
&
childItems
)
;
}
nsDisplayOwnLayerFlags
flags
=
nsDisplayOwnLayerFlags
:
:
GenerateSubdocInvalidations
;
if
(
constructZoomItem
)
{
nsDisplayOwnLayerFlags
zoomFlags
=
flags
;
if
(
ignoreViewportScrolling
)
{
zoomFlags
|
=
nsDisplayOwnLayerFlags
:
:
GenerateScrollableLayer
;
}
childItems
.
AppendNewToTop
<
nsDisplayZoom
>
(
aBuilder
subdocRootFrame
this
&
childItems
subdocAPD
parentAPD
zoomFlags
)
;
needsOwnLayer
=
false
;
}
if
(
ignoreViewportScrolling
)
{
flags
|
=
nsDisplayOwnLayerFlags
:
:
GenerateScrollableLayer
;
}
nsDisplaySubDocument
*
layerItem
=
MakeDisplayItem
<
nsDisplaySubDocument
>
(
aBuilder
subdocRootFrame
?
subdocRootFrame
:
this
this
&
childItems
flags
)
;
if
(
layerItem
)
{
childItems
.
AppendToTop
(
layerItem
)
;
layerItem
-
>
SetShouldFlattenAway
(
!
needsOwnLayer
)
;
}
if
(
aBuilder
-
>
IsForFrameVisibility
(
)
)
{
presShell
-
>
RebuildApproximateFrameVisibilityDisplayList
(
childItems
)
;
childItems
.
DeleteAll
(
aBuilder
)
;
}
else
{
aLists
.
Content
(
)
-
>
AppendToTop
(
&
childItems
)
;
}
}
#
ifdef
DEBUG_FRAME_DUMP
void
nsSubDocumentFrame
:
:
List
(
FILE
*
out
const
char
*
aPrefix
ListFlags
aFlags
)
const
{
nsCString
str
;
ListGeneric
(
str
aPrefix
aFlags
)
;
fprintf_stderr
(
out
"
%
s
\
n
"
str
.
get
(
)
)
;
if
(
aFlags
.
contains
(
ListFlag
:
:
TraverseSubdocumentFrames
)
)
{
nsSubDocumentFrame
*
f
=
const_cast
<
nsSubDocumentFrame
*
>
(
this
)
;
nsIFrame
*
subdocRootFrame
=
f
-
>
GetSubdocumentRootFrame
(
)
;
if
(
subdocRootFrame
)
{
nsCString
pfx
(
aPrefix
)
;
pfx
+
=
"
"
;
subdocRootFrame
-
>
List
(
out
pfx
.
get
(
)
aFlags
)
;
}
}
}
nsresult
nsSubDocumentFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
u
"
FrameOuter
"
_ns
aResult
)
;
}
#
endif
nscoord
nsSubDocumentFrame
:
:
GetMinISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
result
;
DISPLAY_MIN_INLINE_SIZE
(
this
result
)
;
nsCOMPtr
<
nsIObjectLoadingContent
>
iolc
=
do_QueryInterface
(
mContent
)
;
auto
olc
=
static_cast
<
nsObjectLoadingContent
*
>
(
iolc
.
get
(
)
)
;
if
(
olc
&
&
olc
-
>
GetSubdocumentIntrinsicSize
(
)
)
{
result
=
0
;
}
else
{
result
=
GetIntrinsicISize
(
)
;
}
return
result
;
}
nscoord
nsSubDocumentFrame
:
:
GetPrefISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
result
;
DISPLAY_PREF_INLINE_SIZE
(
this
result
)
;
result
=
GetIntrinsicISize
(
)
;
return
result
;
}
IntrinsicSize
nsSubDocumentFrame
:
:
GetIntrinsicSize
(
)
{
const
auto
containAxes
=
StyleDisplay
(
)
-
>
GetContainSizeAxes
(
)
;
if
(
containAxes
.
IsBoth
(
)
)
{
return
containAxes
.
ContainIntrinsicSize
(
IntrinsicSize
(
0
0
)
*
this
)
;
}
if
(
nsCOMPtr
<
nsIObjectLoadingContent
>
iolc
=
do_QueryInterface
(
mContent
)
)
{
auto
olc
=
static_cast
<
nsObjectLoadingContent
*
>
(
iolc
.
get
(
)
)
;
if
(
auto
size
=
olc
-
>
GetSubdocumentIntrinsicSize
(
)
)
{
return
containAxes
.
ContainIntrinsicSize
(
*
size
*
this
)
;
}
}
if
(
!
IsInline
(
)
)
{
return
{
}
;
}
if
(
mContent
-
>
IsXULElement
(
)
)
{
return
{
}
;
}
return
containAxes
.
ContainIntrinsicSize
(
IntrinsicSize
(
kFallbackIntrinsicSize
)
*
this
)
;
}
AspectRatio
nsSubDocumentFrame
:
:
GetIntrinsicRatio
(
)
const
{
if
(
nsCOMPtr
<
nsIObjectLoadingContent
>
iolc
=
do_QueryInterface
(
mContent
)
)
{
auto
olc
=
static_cast
<
nsObjectLoadingContent
*
>
(
iolc
.
get
(
)
)
;
auto
ratio
=
olc
-
>
GetSubdocumentIntrinsicRatio
(
)
;
if
(
ratio
&
&
*
ratio
)
{
return
*
ratio
;
}
}
return
nsAtomicContainerFrame
:
:
GetIntrinsicRatio
(
)
;
}
LogicalSize
nsSubDocumentFrame
:
:
ComputeAutoSize
(
gfxContext
*
aRenderingContext
WritingMode
aWM
const
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
LogicalSize
&
aMargin
const
LogicalSize
&
aBorderPadding
const
StyleSizeOverrides
&
aSizeOverrides
ComputeSizeFlags
aFlags
)
{
if
(
!
IsInline
(
)
)
{
return
nsIFrame
:
:
ComputeAutoSize
(
aRenderingContext
aWM
aCBSize
aAvailableISize
aMargin
aBorderPadding
aSizeOverrides
aFlags
)
;
}
const
WritingMode
wm
=
GetWritingMode
(
)
;
LogicalSize
result
(
wm
GetIntrinsicISize
(
)
GetIntrinsicBSize
(
)
)
;
return
result
.
ConvertTo
(
aWM
wm
)
;
}
nsIFrame
:
:
SizeComputationResult
nsSubDocumentFrame
:
:
ComputeSize
(
gfxContext
*
aRenderingContext
WritingMode
aWM
const
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
LogicalSize
&
aMargin
const
LogicalSize
&
aBorderPadding
const
StyleSizeOverrides
&
aSizeOverrides
ComputeSizeFlags
aFlags
)
{
return
{
ComputeSizeWithIntrinsicDimensions
(
aRenderingContext
aWM
GetIntrinsicSize
(
)
GetAspectRatio
(
)
aCBSize
aMargin
aBorderPadding
aSizeOverrides
aFlags
)
AspectRatioUsage
:
:
None
}
;
}
void
nsSubDocumentFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsSubDocumentFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aDesiredSize
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
NS_FRAME_TRACE
(
NS_FRAME_TRACE_CALLS
(
"
enter
nsSubDocumentFrame
:
:
Reflow
:
maxSize
=
%
d
%
d
"
aReflowInput
.
AvailableWidth
(
)
aReflowInput
.
AvailableHeight
(
)
)
)
;
NS_ASSERTION
(
aReflowInput
.
ComputedWidth
(
)
!
=
NS_UNCONSTRAINEDSIZE
"
Shouldn
'
t
have
unconstrained
stuff
here
"
"
thanks
to
the
rules
of
reflow
"
)
;
NS_ASSERTION
(
NS_UNCONSTRAINEDSIZE
!
=
aReflowInput
.
ComputedHeight
(
)
"
Shouldn
'
t
have
unconstrained
stuff
here
"
"
thanks
to
ComputeAutoSize
"
)
;
NS_ASSERTION
(
mContent
-
>
GetPrimaryFrame
(
)
=
=
this
"
Shouldn
'
t
happen
"
)
;
const
auto
wm
=
aReflowInput
.
GetWritingMode
(
)
;
aDesiredSize
.
SetSize
(
wm
aReflowInput
.
ComputedSizeWithBorderPadding
(
wm
)
)
;
nsPoint
offset
=
nsPoint
(
aReflowInput
.
ComputedPhysicalBorderPadding
(
)
.
left
aReflowInput
.
ComputedPhysicalBorderPadding
(
)
.
top
)
;
if
(
mInnerView
)
{
const
nsMargin
&
bp
=
aReflowInput
.
ComputedPhysicalBorderPadding
(
)
;
nsSize
innerSize
(
aDesiredSize
.
Width
(
)
-
bp
.
LeftRight
(
)
aDesiredSize
.
Height
(
)
-
bp
.
TopBottom
(
)
)
;
nsRect
destRect
=
nsLayoutUtils
:
:
ComputeObjectDestRect
(
nsRect
(
offset
innerSize
)
GetIntrinsicSize
(
)
GetIntrinsicRatio
(
)
StylePosition
(
)
)
;
nsViewManager
*
vm
=
mInnerView
-
>
GetViewManager
(
)
;
vm
-
>
MoveViewTo
(
mInnerView
destRect
.
x
destRect
.
y
)
;
vm
-
>
ResizeView
(
mInnerView
nsRect
(
nsPoint
(
0
0
)
destRect
.
Size
(
)
)
true
)
;
}
aDesiredSize
.
SetOverflowAreasToDesiredBounds
(
)
;
FinishAndStoreOverflow
(
&
aDesiredSize
)
;
if
(
!
aPresContext
-
>
IsRootPaginatedDocument
(
)
&
&
!
mPostedReflowCallback
)
{
PresShell
(
)
-
>
PostReflowCallback
(
this
)
;
mPostedReflowCallback
=
true
;
}
NS_FRAME_TRACE
(
NS_FRAME_TRACE_CALLS
(
"
exit
nsSubDocumentFrame
:
:
Reflow
:
size
=
%
d
%
d
status
=
%
s
"
aDesiredSize
.
Width
(
)
aDesiredSize
.
Height
(
)
ToString
(
aStatus
)
.
c_str
(
)
)
)
;
}
bool
nsSubDocumentFrame
:
:
ReflowFinished
(
)
{
RefPtr
<
nsFrameLoader
>
frameloader
=
FrameLoader
(
)
;
if
(
frameloader
)
{
AutoWeakFrame
weakFrame
(
this
)
;
frameloader
-
>
UpdatePositionAndSize
(
this
)
;
if
(
weakFrame
.
IsAlive
(
)
)
{
mPostedReflowCallback
=
false
;
}
}
else
{
mPostedReflowCallback
=
false
;
}
return
false
;
}
void
nsSubDocumentFrame
:
:
ReflowCallbackCanceled
(
)
{
mPostedReflowCallback
=
false
;
}
nsresult
nsSubDocumentFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
if
(
aNameSpaceID
!
=
kNameSpaceID_None
)
{
return
NS_OK
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
noresize
)
{
if
(
mContent
-
>
GetParent
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
frameset
)
)
{
nsIFrame
*
parentFrame
=
GetParent
(
)
;
if
(
parentFrame
)
{
nsHTMLFramesetFrame
*
framesetFrame
=
do_QueryFrame
(
parentFrame
)
;
if
(
framesetFrame
)
{
framesetFrame
-
>
RecalculateBorderResize
(
)
;
}
}
}
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
marginwidth
|
|
aAttribute
=
=
nsGkAtoms
:
:
marginheight
)
{
if
(
RefPtr
<
nsFrameLoader
>
frameloader
=
FrameLoader
(
)
)
{
frameloader
-
>
MarginsChanged
(
)
;
}
}
return
NS_OK
;
}
void
nsSubDocumentFrame
:
:
MaybeUpdateEmbedderColorScheme
(
)
{
nsFrameLoader
*
fl
=
mFrameLoader
.
get
(
)
;
if
(
!
fl
)
{
return
;
}
BrowsingContext
*
bc
=
fl
-
>
GetExtantBrowsingContext
(
)
;
if
(
!
bc
)
{
return
;
}
auto
usedColorScheme
=
LookAndFeel
:
:
ColorSchemeForFrame
(
this
)
;
bool
needUpdate
=
[
&
]
{
switch
(
bc
-
>
GetEmbedderColorScheme
(
)
)
{
case
PrefersColorSchemeOverride
:
:
Light
:
return
usedColorScheme
!
=
ColorScheme
:
:
Light
;
case
PrefersColorSchemeOverride
:
:
Dark
:
return
usedColorScheme
!
=
ColorScheme
:
:
Dark
;
case
PrefersColorSchemeOverride
:
:
None
:
case
PrefersColorSchemeOverride
:
:
EndGuard_
:
break
;
}
return
true
;
}
(
)
;
if
(
!
needUpdate
)
{
return
;
}
auto
value
=
usedColorScheme
=
=
ColorScheme
:
:
Dark
?
PrefersColorSchemeOverride
:
:
Dark
:
PrefersColorSchemeOverride
:
:
Light
;
Unused
<
<
bc
-
>
SetEmbedderColorScheme
(
value
)
;
}
void
nsSubDocumentFrame
:
:
MaybeUpdateRemoteStyle
(
ComputedStyle
*
aOldComputedStyle
)
{
if
(
!
mIsInObjectOrEmbed
)
{
return
;
}
if
(
aOldComputedStyle
&
&
aOldComputedStyle
-
>
StyleVisibility
(
)
-
>
mImageRendering
=
=
Style
(
)
-
>
StyleVisibility
(
)
-
>
mImageRendering
)
{
return
;
}
if
(
!
mFrameLoader
)
{
return
;
}
if
(
mFrameLoader
-
>
IsRemoteFrame
(
)
)
{
mFrameLoader
-
>
UpdateRemoteStyle
(
Style
(
)
-
>
StyleVisibility
(
)
-
>
mImageRendering
)
;
return
;
}
BrowsingContext
*
context
=
mFrameLoader
-
>
GetExtantBrowsingContext
(
)
;
if
(
!
context
)
{
return
;
}
Document
*
document
=
context
-
>
GetDocument
(
)
;
if
(
!
document
)
{
return
;
}
if
(
document
-
>
IsImageDocument
(
)
)
{
document
-
>
AsImageDocument
(
)
-
>
UpdateRemoteStyle
(
Style
(
)
-
>
StyleVisibility
(
)
-
>
mImageRendering
)
;
}
}
void
nsSubDocumentFrame
:
:
DidSetComputedStyle
(
ComputedStyle
*
aOldComputedStyle
)
{
nsAtomicContainerFrame
:
:
DidSetComputedStyle
(
aOldComputedStyle
)
;
MaybeUpdateEmbedderColorScheme
(
)
;
MaybeUpdateRemoteStyle
(
aOldComputedStyle
)
;
if
(
PresShell
(
)
-
>
IsUnderHiddenEmbedderElement
(
)
)
{
return
;
}
const
bool
isVisible
=
StyleVisibility
(
)
-
>
IsVisible
(
)
;
if
(
!
aOldComputedStyle
|
|
isVisible
!
=
aOldComputedStyle
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
)
{
PropagateIsUnderHiddenEmbedderElementToSubView
(
!
isVisible
)
;
}
}
nsIFrame
*
NS_NewSubDocumentFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsSubDocumentFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsSubDocumentFrame
)
class
nsHideViewer
:
public
Runnable
{
public
:
nsHideViewer
(
nsIContent
*
aFrameElement
nsFrameLoader
*
aFrameLoader
PresShell
*
aPresShell
bool
aHideViewerIfFrameless
)
:
mozilla
:
:
Runnable
(
"
nsHideViewer
"
)
mFrameElement
(
aFrameElement
)
mFrameLoader
(
aFrameLoader
)
mPresShell
(
aPresShell
)
mHideViewerIfFrameless
(
aHideViewerIfFrameless
)
{
NS_ASSERTION
(
mFrameElement
"
Must
have
a
frame
element
"
)
;
NS_ASSERTION
(
mFrameLoader
"
Must
have
a
frame
loader
"
)
;
NS_ASSERTION
(
mPresShell
"
Must
have
a
presshell
"
)
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
NS_IMETHOD
Run
(
)
override
{
if
(
!
mPresShell
-
>
IsDestroying
(
)
&
&
mFrameElement
-
>
IsInComposedDoc
(
)
)
{
MOZ_KnownLive
(
mPresShell
)
-
>
FlushPendingNotifications
(
FlushType
:
:
Frames
)
;
}
mFrameLoader
-
>
SetDetachedSubdocFrame
(
nullptr
nullptr
)
;
nsSubDocumentFrame
*
frame
=
do_QueryFrame
(
mFrameElement
-
>
GetPrimaryFrame
(
)
)
;
if
(
(
!
frame
&
&
mHideViewerIfFrameless
)
|
|
mPresShell
-
>
IsDestroying
(
)
)
{
mFrameLoader
-
>
Hide
(
)
;
}
return
NS_OK
;
}
private
:
nsCOMPtr
<
nsIContent
>
mFrameElement
;
RefPtr
<
nsFrameLoader
>
mFrameLoader
;
RefPtr
<
PresShell
>
mPresShell
;
bool
mHideViewerIfFrameless
;
}
;
static
nsView
*
BeginSwapDocShellsForViews
(
nsView
*
aSibling
)
;
void
nsSubDocumentFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
{
PropagateIsUnderHiddenEmbedderElementToSubView
(
true
)
;
if
(
mPostedReflowCallback
)
{
PresShell
(
)
-
>
CancelReflowCallback
(
this
)
;
mPostedReflowCallback
=
false
;
}
RefPtr
<
nsFrameLoader
>
frameloader
=
FrameLoader
(
)
;
if
(
frameloader
)
{
ClearDisplayItems
(
)
;
nsView
*
detachedViews
=
:
:
BeginSwapDocShellsForViews
(
mInnerView
-
>
GetFirstChild
(
)
)
;
if
(
detachedViews
&
&
detachedViews
-
>
GetFrame
(
)
)
{
frameloader
-
>
SetDetachedSubdocFrame
(
detachedViews
-
>
GetFrame
(
)
mContent
-
>
OwnerDoc
(
)
)
;
nsContentUtils
:
:
AddScriptRunner
(
new
nsHideViewer
(
mContent
frameloader
PresShell
(
)
(
mDidCreateDoc
|
|
mCallingShow
)
)
)
;
}
else
{
frameloader
-
>
SetDetachedSubdocFrame
(
nullptr
nullptr
)
;
if
(
mDidCreateDoc
|
|
mCallingShow
)
{
frameloader
-
>
Hide
(
)
;
}
}
}
nsAtomicContainerFrame
:
:
DestroyFrom
(
aDestructRoot
aPostDestroyData
)
;
}
nsFrameLoader
*
nsSubDocumentFrame
:
:
FrameLoader
(
)
const
{
if
(
mFrameLoader
)
{
return
mFrameLoader
;
}
if
(
RefPtr
<
nsFrameLoaderOwner
>
loaderOwner
=
do_QueryObject
(
GetContent
(
)
)
)
{
mFrameLoader
=
loaderOwner
-
>
GetFrameLoader
(
)
;
}
return
mFrameLoader
;
}
auto
nsSubDocumentFrame
:
:
GetRemotePaintData
(
)
const
-
>
RemoteFramePaintData
{
if
(
mRetainedRemoteFrame
)
{
return
*
mRetainedRemoteFrame
;
}
RemoteFramePaintData
data
;
nsFrameLoader
*
fl
=
FrameLoader
(
)
;
if
(
!
fl
)
{
return
data
;
}
auto
*
rb
=
fl
-
>
GetRemoteBrowser
(
)
;
if
(
!
rb
)
{
return
data
;
}
data
.
mLayersId
=
rb
-
>
GetLayersId
(
)
;
data
.
mTabId
=
rb
-
>
GetTabId
(
)
;
return
data
;
}
void
nsSubDocumentFrame
:
:
ResetFrameLoader
(
RetainPaintData
aRetain
)
{
if
(
aRetain
=
=
RetainPaintData
:
:
Yes
&
&
mFrameLoader
)
{
mRetainedRemoteFrame
=
Some
(
GetRemotePaintData
(
)
)
;
}
else
{
mRetainedRemoteFrame
.
reset
(
)
;
}
mFrameLoader
=
nullptr
;
ClearDisplayItems
(
)
;
nsContentUtils
:
:
AddScriptRunner
(
new
AsyncFrameInit
(
this
)
)
;
}
void
nsSubDocumentFrame
:
:
ClearRetainedPaintData
(
)
{
mRetainedRemoteFrame
.
reset
(
)
;
ClearDisplayItems
(
)
;
InvalidateFrameSubtree
(
)
;
}
nsIDocShell
*
nsSubDocumentFrame
:
:
GetDocShell
(
)
const
{
if
(
NS_WARN_IF
(
!
FrameLoader
(
)
)
)
{
return
nullptr
;
}
return
mFrameLoader
-
>
GetDocShell
(
IgnoreErrors
(
)
)
;
}
static
void
DestroyDisplayItemDataForFrames
(
nsIFrame
*
aFrame
)
{
WebRenderUserDataTable
*
userDataTable
=
aFrame
-
>
TakeProperty
(
WebRenderUserDataProperty
:
:
Key
(
)
)
;
if
(
userDataTable
)
{
for
(
const
auto
&
data
:
userDataTable
-
>
Values
(
)
)
{
data
-
>
RemoveFromTable
(
)
;
}
delete
userDataTable
;
}
for
(
const
auto
&
childList
:
aFrame
-
>
ChildLists
(
)
)
{
for
(
nsIFrame
*
child
:
childList
.
mList
)
{
DestroyDisplayItemDataForFrames
(
child
)
;
}
}
}
static
CallState
BeginSwapDocShellsForDocument
(
Document
&
aDocument
)
{
if
(
PresShell
*
presShell
=
aDocument
.
GetPresShell
(
)
)
{
presShell
-
>
SetNeverPainting
(
true
)
;
if
(
nsIFrame
*
rootFrame
=
presShell
-
>
GetRootFrame
(
)
)
{
:
:
DestroyDisplayItemDataForFrames
(
rootFrame
)
;
}
}
aDocument
.
EnumerateSubDocuments
(
BeginSwapDocShellsForDocument
)
;
return
CallState
:
:
Continue
;
}
static
nsView
*
BeginSwapDocShellsForViews
(
nsView
*
aSibling
)
{
nsView
*
removedViews
=
nullptr
;
while
(
aSibling
)
{
if
(
Document
*
doc
=
:
:
GetDocumentFromView
(
aSibling
)
)
{
:
:
BeginSwapDocShellsForDocument
(
*
doc
)
;
}
nsView
*
next
=
aSibling
-
>
GetNextSibling
(
)
;
aSibling
-
>
GetViewManager
(
)
-
>
RemoveChild
(
aSibling
)
;
aSibling
-
>
SetNextSibling
(
removedViews
)
;
removedViews
=
aSibling
;
aSibling
=
next
;
}
return
removedViews
;
}
static
void
InsertViewsInReverseOrder
(
nsView
*
aSibling
nsView
*
aParent
)
{
MOZ_ASSERT
(
aParent
"
null
view
"
)
;
MOZ_ASSERT
(
!
aParent
-
>
GetFirstChild
(
)
"
inserting
into
non
-
empty
list
"
)
;
nsViewManager
*
vm
=
aParent
-
>
GetViewManager
(
)
;
while
(
aSibling
)
{
nsView
*
next
=
aSibling
-
>
GetNextSibling
(
)
;
aSibling
-
>
SetNextSibling
(
nullptr
)
;
vm
-
>
InsertChild
(
aParent
aSibling
nullptr
true
)
;
aSibling
=
next
;
}
}
nsresult
nsSubDocumentFrame
:
:
BeginSwapDocShells
(
nsIFrame
*
aOther
)
{
if
(
!
aOther
|
|
!
aOther
-
>
IsSubDocumentFrame
(
)
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
nsSubDocumentFrame
*
other
=
static_cast
<
nsSubDocumentFrame
*
>
(
aOther
)
;
if
(
!
mFrameLoader
|
|
!
mDidCreateDoc
|
|
mCallingShow
|
|
!
other
-
>
mFrameLoader
|
|
!
other
-
>
mDidCreateDoc
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
ClearDisplayItems
(
)
;
other
-
>
ClearDisplayItems
(
)
;
if
(
mInnerView
&
&
other
-
>
mInnerView
)
{
nsView
*
ourSubdocViews
=
mInnerView
-
>
GetFirstChild
(
)
;
nsView
*
ourRemovedViews
=
:
:
BeginSwapDocShellsForViews
(
ourSubdocViews
)
;
nsView
*
otherSubdocViews
=
other
-
>
mInnerView
-
>
GetFirstChild
(
)
;
nsView
*
otherRemovedViews
=
:
:
BeginSwapDocShellsForViews
(
otherSubdocViews
)
;
:
:
InsertViewsInReverseOrder
(
ourRemovedViews
other
-
>
mInnerView
)
;
:
:
InsertViewsInReverseOrder
(
otherRemovedViews
mInnerView
)
;
}
mFrameLoader
.
swap
(
other
-
>
mFrameLoader
)
;
return
NS_OK
;
}
static
CallState
EndSwapDocShellsForDocument
(
Document
&
aDocument
)
{
if
(
nsCOMPtr
<
nsIDocShell
>
ds
=
aDocument
.
GetDocShell
(
)
)
{
nsCOMPtr
<
nsIContentViewer
>
cv
;
ds
-
>
GetContentViewer
(
getter_AddRefs
(
cv
)
)
;
while
(
cv
)
{
RefPtr
<
nsPresContext
>
pc
=
cv
-
>
GetPresContext
(
)
;
if
(
pc
&
&
pc
-
>
GetPresShell
(
)
)
{
pc
-
>
GetPresShell
(
)
-
>
SetNeverPainting
(
ds
-
>
IsInvisible
(
)
)
;
}
nsDeviceContext
*
dc
=
pc
?
pc
-
>
DeviceContext
(
)
:
nullptr
;
if
(
dc
)
{
nsView
*
v
=
cv
-
>
FindContainerView
(
)
;
dc
-
>
Init
(
v
?
v
-
>
GetNearestWidget
(
nullptr
)
:
nullptr
)
;
}
cv
=
cv
-
>
GetPreviousViewer
(
)
;
}
}
aDocument
.
EnumerateSubDocuments
(
EndSwapDocShellsForDocument
)
;
return
CallState
:
:
Continue
;
}
static
void
EndSwapDocShellsForViews
(
nsView
*
aSibling
)
{
for
(
;
aSibling
;
aSibling
=
aSibling
-
>
GetNextSibling
(
)
)
{
if
(
Document
*
doc
=
:
:
GetDocumentFromView
(
aSibling
)
)
{
:
:
EndSwapDocShellsForDocument
(
*
doc
)
;
}
nsIFrame
*
frame
=
aSibling
-
>
GetFrame
(
)
;
if
(
frame
)
{
nsIFrame
*
parent
=
nsLayoutUtils
:
:
GetCrossDocParentFrameInProcess
(
frame
)
;
if
(
parent
-
>
HasAnyStateBits
(
NS_FRAME_IN_POPUP
)
)
{
nsIFrame
:
:
AddInPopupStateBitToDescendants
(
frame
)
;
}
else
{
nsIFrame
:
:
RemoveInPopupStateBitFromDescendants
(
frame
)
;
}
if
(
frame
-
>
HasInvalidFrameInSubtree
(
)
)
{
while
(
parent
&
&
!
parent
-
>
HasAnyStateBits
(
NS_FRAME_DESCENDANT_NEEDS_PAINT
|
NS_FRAME_IS_NONDISPLAY
)
)
{
parent
-
>
AddStateBits
(
NS_FRAME_DESCENDANT_NEEDS_PAINT
)
;
parent
=
nsLayoutUtils
:
:
GetCrossDocParentFrameInProcess
(
parent
)
;
}
}
}
}
}
void
nsSubDocumentFrame
:
:
EndSwapDocShells
(
nsIFrame
*
aOther
)
{
nsSubDocumentFrame
*
other
=
static_cast
<
nsSubDocumentFrame
*
>
(
aOther
)
;
AutoWeakFrame
weakThis
(
this
)
;
AutoWeakFrame
weakOther
(
aOther
)
;
if
(
mInnerView
)
{
:
:
EndSwapDocShellsForViews
(
mInnerView
-
>
GetFirstChild
(
)
)
;
}
if
(
other
-
>
mInnerView
)
{
:
:
EndSwapDocShellsForViews
(
other
-
>
mInnerView
-
>
GetFirstChild
(
)
)
;
}
if
(
weakThis
.
IsAlive
(
)
)
{
PresShell
(
)
-
>
FrameNeedsReflow
(
this
IntrinsicDirty
:
:
TreeChange
NS_FRAME_IS_DIRTY
)
;
InvalidateFrameSubtree
(
)
;
PropagateIsUnderHiddenEmbedderElementToSubView
(
PresShell
(
)
-
>
IsUnderHiddenEmbedderElement
(
)
|
|
!
StyleVisibility
(
)
-
>
IsVisible
(
)
)
;
}
if
(
weakOther
.
IsAlive
(
)
)
{
other
-
>
PresShell
(
)
-
>
FrameNeedsReflow
(
other
IntrinsicDirty
:
:
TreeChange
NS_FRAME_IS_DIRTY
)
;
other
-
>
InvalidateFrameSubtree
(
)
;
other
-
>
PropagateIsUnderHiddenEmbedderElementToSubView
(
other
-
>
PresShell
(
)
-
>
IsUnderHiddenEmbedderElement
(
)
|
|
!
other
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
)
;
}
}
void
nsSubDocumentFrame
:
:
ClearDisplayItems
(
)
{
if
(
auto
*
builder
=
nsLayoutUtils
:
:
GetRetainedDisplayListBuilder
(
this
)
)
{
DL_LOGD
(
"
nsSubDocumentFrame
:
:
ClearDisplayItems
(
)
%
p
"
this
)
;
builder
-
>
ClearRetainedData
(
)
;
}
}
nsView
*
nsSubDocumentFrame
:
:
EnsureInnerView
(
)
{
if
(
mInnerView
)
{
return
mInnerView
;
}
nsView
*
outerView
=
GetView
(
)
;
NS_ASSERTION
(
outerView
"
Must
have
an
outer
view
already
"
)
;
nsRect
viewBounds
(
0
0
0
0
)
;
nsViewManager
*
viewMan
=
outerView
-
>
GetViewManager
(
)
;
nsView
*
innerView
=
viewMan
-
>
CreateView
(
viewBounds
outerView
)
;
if
(
!
innerView
)
{
NS_ERROR
(
"
Could
not
create
inner
view
"
)
;
return
nullptr
;
}
mInnerView
=
innerView
;
viewMan
-
>
InsertChild
(
outerView
innerView
nullptr
true
)
;
return
mInnerView
;
}
nsPoint
nsSubDocumentFrame
:
:
GetExtraOffset
(
)
const
{
MOZ_ASSERT
(
mInnerView
)
;
return
mInnerView
-
>
GetPosition
(
)
;
}
void
nsSubDocumentFrame
:
:
SubdocumentIntrinsicSizeOrRatioChanged
(
)
{
const
nsStylePosition
*
pos
=
StylePosition
(
)
;
bool
dependsOnIntrinsics
=
!
pos
-
>
mWidth
.
ConvertsToLength
(
)
|
|
!
pos
-
>
mHeight
.
ConvertsToLength
(
)
;
if
(
dependsOnIntrinsics
|
|
pos
-
>
mObjectFit
!
=
StyleObjectFit
:
:
Fill
)
{
auto
dirtyHint
=
dependsOnIntrinsics
?
IntrinsicDirty
:
:
StyleChange
:
IntrinsicDirty
:
:
Resize
;
PresShell
(
)
-
>
FrameNeedsReflow
(
this
dirtyHint
NS_FRAME_IS_DIRTY
)
;
InvalidateFrame
(
)
;
}
}
nsDisplayRemote
:
:
nsDisplayRemote
(
nsDisplayListBuilder
*
aBuilder
nsSubDocumentFrame
*
aFrame
)
:
nsPaintedDisplayItem
(
aBuilder
aFrame
)
mEventRegionsOverride
(
EventRegionsOverride
:
:
NoOverride
)
{
const
bool
frameIsPointerEventsNone
=
aFrame
-
>
Style
(
)
-
>
PointerEvents
(
)
=
=
StylePointerEvents
:
:
None
;
if
(
aBuilder
-
>
IsInsidePointerEventsNoneDoc
(
)
|
|
frameIsPointerEventsNone
)
{
mEventRegionsOverride
|
=
EventRegionsOverride
:
:
ForceEmptyHitRegion
;
}
if
(
nsLayoutUtils
:
:
HasDocumentLevelListenersForApzAwareEvents
(
aFrame
-
>
PresShell
(
)
)
)
{
mEventRegionsOverride
|
=
EventRegionsOverride
:
:
ForceDispatchToContent
;
}
mPaintData
=
aFrame
-
>
GetRemotePaintData
(
)
;
}
namespace
mozilla
{
void
nsDisplayRemote
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
nsPresContext
*
pc
=
mFrame
-
>
PresContext
(
)
;
nsFrameLoader
*
fl
=
GetFrameLoader
(
)
;
if
(
pc
-
>
GetPrintSettings
(
)
&
&
fl
-
>
IsRemoteFrame
(
)
)
{
fl
-
>
UpdatePositionAndSize
(
static_cast
<
nsSubDocumentFrame
*
>
(
mFrame
)
)
;
}
DrawTarget
*
target
=
aCtx
-
>
GetDrawTarget
(
)
;
if
(
!
target
-
>
IsRecording
(
)
|
|
mPaintData
.
mTabId
=
=
0
)
{
NS_WARNING
(
"
Remote
iframe
not
rendered
"
)
;
return
;
}
const
int32_t
appUnitsPerDevPixel
=
pc
-
>
AppUnitsPerDevPixel
(
)
;
gfxContextMatrixAutoSaveRestore
saveMatrix
(
aCtx
)
;
gfxFloat
targetAuPerDev
=
gfxFloat
(
AppUnitsPerCSSPixel
(
)
)
/
aCtx
-
>
GetCrossProcessPaintScale
(
)
;
gfxFloat
scale
=
targetAuPerDev
/
appUnitsPerDevPixel
;
aCtx
-
>
Multiply
(
gfxMatrix
:
:
Scaling
(
scale
scale
)
)
;
Rect
destRect
=
NSRectToSnappedRect
(
GetContentRect
(
)
targetAuPerDev
*
target
)
;
target
-
>
DrawDependentSurface
(
mPaintData
.
mTabId
destRect
)
;
}
bool
nsDisplayRemote
:
:
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
if
(
!
mPaintData
.
mLayersId
.
IsValid
(
)
)
{
return
true
;
}
nsPresContext
*
pc
=
mFrame
-
>
PresContext
(
)
;
nsFrameLoader
*
fl
=
GetFrameLoader
(
)
;
auto
*
subDocFrame
=
static_cast
<
nsSubDocumentFrame
*
>
(
mFrame
)
;
nsRect
destRect
=
subDocFrame
-
>
GetDestRect
(
)
;
if
(
RefPtr
<
RemoteBrowser
>
remoteBrowser
=
fl
-
>
GetRemoteBrowser
(
)
)
{
if
(
pc
-
>
GetPrintSettings
(
)
)
{
fl
-
>
UpdatePositionAndSize
(
subDocFrame
)
;
}
nsRect
visibleRect
=
GetBuildingRect
(
)
-
ToReferenceFrame
(
)
;
visibleRect
.
IntersectRect
(
visibleRect
destRect
)
;
visibleRect
-
=
destRect
.
TopLeft
(
)
;
MatrixScales
scale
=
aSc
.
GetInheritedScale
(
)
;
ParentLayerToScreenScale2D
transformToAncestorScale
=
ParentLayerToParentLayerScale
(
pc
-
>
GetPresShell
(
)
?
pc
-
>
GetPresShell
(
)
-
>
GetCumulativeResolution
(
)
:
1
.
f
)
*
nsLayoutUtils
:
:
GetTransformToAncestorScaleCrossProcessForFrameMetrics
(
mFrame
)
;
aDisplayListBuilder
-
>
AddEffectUpdate
(
remoteBrowser
EffectsInfo
:
:
VisibleWithinRect
(
visibleRect
scale
transformToAncestorScale
)
)
;
RefPtr
<
WebRenderRemoteData
>
userData
=
aManager
-
>
CommandBuilder
(
)
.
CreateOrRecycleWebRenderUserData
<
WebRenderRemoteData
>
(
this
nullptr
)
;
userData
-
>
SetRemoteBrowser
(
remoteBrowser
)
;
}
nscoord
auPerDevPixel
=
pc
-
>
AppUnitsPerDevPixel
(
)
;
nsPoint
layerOffset
=
aDisplayListBuilder
-
>
ToReferenceFrame
(
mFrame
)
+
destRect
.
TopLeft
(
)
;
mOffset
=
LayoutDevicePoint
:
:
FromAppUnits
(
layerOffset
auPerDevPixel
)
;
destRect
.
MoveTo
(
0
0
)
;
auto
rect
=
LayoutDeviceRect
:
:
FromAppUnits
(
destRect
auPerDevPixel
)
;
rect
+
=
mOffset
;
aBuilder
.
PushIFrame
(
mozilla
:
:
wr
:
:
ToLayoutRect
(
rect
)
!
BackfaceIsHidden
(
)
mozilla
:
:
wr
:
:
AsPipelineId
(
mPaintData
.
mLayersId
)
true
)
;
return
true
;
}
bool
nsDisplayRemote
:
:
UpdateScrollData
(
mozilla
:
:
layers
:
:
WebRenderScrollData
*
aData
mozilla
:
:
layers
:
:
WebRenderLayerScrollData
*
aLayerData
)
{
if
(
!
mPaintData
.
mLayersId
.
IsValid
(
)
)
{
return
true
;
}
if
(
aLayerData
)
{
aLayerData
-
>
SetReferentId
(
mPaintData
.
mLayersId
)
;
nsPresContext
*
inProcessRootContext
=
mFrame
-
>
PresContext
(
)
-
>
GetInProcessRootContentDocumentPresContext
(
)
;
if
(
inProcessRootContext
&
&
inProcessRootContext
-
>
IsRootContentDocumentCrossProcess
(
)
)
{
float
resolution
=
inProcessRootContext
-
>
PresShell
(
)
-
>
GetResolution
(
)
;
aLayerData
-
>
SetResolution
(
resolution
)
;
}
auto
size
=
static_cast
<
nsSubDocumentFrame
*
>
(
mFrame
)
-
>
GetSubdocumentSize
(
)
;
Matrix4x4
m
=
Matrix4x4
:
:
Translation
(
mOffset
.
x
mOffset
.
y
0
.
0
)
;
aLayerData
-
>
SetTransform
(
m
)
;
aLayerData
-
>
SetEventRegionsOverride
(
mEventRegionsOverride
)
;
aLayerData
-
>
SetRemoteDocumentSize
(
LayerIntSize
(
size
.
width
size
.
height
)
)
;
}
return
true
;
}
nsFrameLoader
*
nsDisplayRemote
:
:
GetFrameLoader
(
)
const
{
return
static_cast
<
nsSubDocumentFrame
*
>
(
mFrame
)
-
>
FrameLoader
(
)
;
}
}
