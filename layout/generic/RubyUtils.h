#
ifndef
mozilla_RubyUtils_h_
#
define
mozilla_RubyUtils_h_
#
include
"
nsCSSAnonBoxes
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsTArray
.
h
"
#
define
RTC_ARRAY_SIZE
1
class
nsRubyFrame
;
class
nsRubyBaseFrame
;
class
nsRubyTextFrame
;
class
nsRubyContentFrame
;
class
nsRubyBaseContainerFrame
;
class
nsRubyTextContainerFrame
;
namespace
mozilla
{
class
RubyUtils
{
public
:
static
inline
bool
IsRubyContentBox
(
LayoutFrameType
aFrameType
)
{
return
aFrameType
=
=
mozilla
:
:
LayoutFrameType
:
:
RubyBase
|
|
aFrameType
=
=
mozilla
:
:
LayoutFrameType
:
:
RubyText
;
}
static
inline
bool
IsRubyContainerBox
(
LayoutFrameType
aFrameType
)
{
return
aFrameType
=
=
mozilla
:
:
LayoutFrameType
:
:
RubyBaseContainer
|
|
aFrameType
=
=
mozilla
:
:
LayoutFrameType
:
:
RubyTextContainer
;
}
static
inline
bool
IsRubyBox
(
LayoutFrameType
aFrameType
)
{
return
aFrameType
=
=
mozilla
:
:
LayoutFrameType
:
:
Ruby
|
|
IsRubyContentBox
(
aFrameType
)
|
|
IsRubyContainerBox
(
aFrameType
)
;
}
static
inline
bool
IsExpandableRubyBox
(
nsIFrame
*
aFrame
)
{
mozilla
:
:
LayoutFrameType
type
=
aFrame
-
>
Type
(
)
;
return
IsRubyContentBox
(
type
)
|
|
IsRubyContainerBox
(
type
)
;
}
static
inline
bool
IsRubyPseudo
(
PseudoStyleType
aPseudo
)
{
return
aPseudo
=
=
PseudoStyleType
:
:
ruby
|
|
aPseudo
=
=
PseudoStyleType
:
:
rubyBase
|
|
aPseudo
=
=
PseudoStyleType
:
:
rubyText
|
|
aPseudo
=
=
PseudoStyleType
:
:
rubyBaseContainer
|
|
aPseudo
=
=
PseudoStyleType
:
:
rubyTextContainer
;
}
static
void
SetReservedISize
(
nsIFrame
*
aFrame
nscoord
aISize
)
;
static
void
ClearReservedISize
(
nsIFrame
*
aFrame
)
;
static
nscoord
GetReservedISize
(
nsIFrame
*
aFrame
)
;
}
;
class
MOZ_RAII
AutoRubyTextContainerArray
final
:
public
AutoTArray
<
nsRubyTextContainerFrame
*
RTC_ARRAY_SIZE
>
{
public
:
explicit
AutoRubyTextContainerArray
(
nsRubyBaseContainerFrame
*
aBaseContainer
)
;
}
;
class
MOZ_STACK_CLASS
RubySegmentEnumerator
{
public
:
explicit
RubySegmentEnumerator
(
nsRubyFrame
*
aRubyFrame
)
;
void
Next
(
)
;
bool
AtEnd
(
)
const
{
return
!
mBaseContainer
;
}
nsRubyBaseContainerFrame
*
GetBaseContainer
(
)
const
{
return
mBaseContainer
;
}
private
:
nsRubyBaseContainerFrame
*
mBaseContainer
;
}
;
struct
MOZ_STACK_CLASS
RubyColumn
{
nsRubyBaseFrame
*
mBaseFrame
;
AutoTArray
<
nsRubyTextFrame
*
RTC_ARRAY_SIZE
>
mTextFrames
;
bool
mIsIntraLevelWhitespace
;
RubyColumn
(
)
:
mBaseFrame
(
nullptr
)
mIsIntraLevelWhitespace
(
false
)
{
}
class
MOZ_STACK_CLASS
Iterator
{
public
:
nsIFrame
*
operator
*
(
)
const
;
Iterator
&
operator
+
+
(
)
{
+
+
mIndex
;
SkipUntilExistingFrame
(
)
;
return
*
this
;
}
Iterator
operator
+
+
(
int
)
{
auto
ret
=
*
this
;
+
+
*
this
;
return
ret
;
}
friend
bool
operator
=
=
(
const
Iterator
&
aIter1
const
Iterator
&
aIter2
)
{
MOZ_ASSERT
(
&
aIter1
.
mColumn
=
=
&
aIter2
.
mColumn
"
Should
only
compare
iterators
of
the
same
ruby
column
"
)
;
return
aIter1
.
mIndex
=
=
aIter2
.
mIndex
;
}
friend
bool
operator
!
=
(
const
Iterator
&
aIter1
const
Iterator
&
aIter2
)
{
return
!
(
aIter1
=
=
aIter2
)
;
}
private
:
Iterator
(
const
RubyColumn
&
aColumn
int32_t
aIndex
)
:
mColumn
(
aColumn
)
mIndex
(
aIndex
)
{
MOZ_ASSERT
(
aIndex
=
=
-
1
|
|
(
aIndex
>
=
0
&
&
aIndex
<
=
int32_t
(
aColumn
.
mTextFrames
.
Length
(
)
)
)
)
;
SkipUntilExistingFrame
(
)
;
}
friend
struct
RubyColumn
;
void
SkipUntilExistingFrame
(
)
;
const
RubyColumn
&
mColumn
;
int32_t
mIndex
=
-
1
;
}
;
Iterator
begin
(
)
const
{
return
Iterator
(
*
this
-
1
)
;
}
Iterator
end
(
)
const
{
return
Iterator
(
*
this
mTextFrames
.
Length
(
)
)
;
}
Iterator
cbegin
(
)
const
{
return
begin
(
)
;
}
Iterator
cend
(
)
const
{
return
end
(
)
;
}
}
;
class
MOZ_STACK_CLASS
RubyColumnEnumerator
{
public
:
RubyColumnEnumerator
(
nsRubyBaseContainerFrame
*
aRBCFrame
const
AutoRubyTextContainerArray
&
aRTCFrames
)
;
void
Next
(
)
;
bool
AtEnd
(
)
const
;
uint32_t
GetLevelCount
(
)
const
{
return
mFrames
.
Length
(
)
;
}
nsRubyContentFrame
*
GetFrameAtLevel
(
uint32_t
aIndex
)
const
;
void
GetColumn
(
RubyColumn
&
aColumn
)
const
;
private
:
AutoTArray
<
nsRubyContentFrame
*
RTC_ARRAY_SIZE
+
1
>
mFrames
;
bool
mAtIntraLevelWhitespace
;
}
;
struct
RubyBlockLeadings
{
nscoord
mStart
=
0
;
nscoord
mEnd
=
0
;
void
Reset
(
)
{
mStart
=
mEnd
=
0
;
}
void
Update
(
nscoord
aStart
nscoord
aEnd
)
{
mStart
=
std
:
:
max
(
mStart
aStart
)
;
mEnd
=
std
:
:
max
(
mEnd
aEnd
)
;
}
void
Update
(
const
RubyBlockLeadings
&
aOther
)
{
Update
(
aOther
.
mStart
aOther
.
mEnd
)
;
}
}
;
}
#
endif
