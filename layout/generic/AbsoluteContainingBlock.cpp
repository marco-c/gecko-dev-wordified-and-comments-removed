#
include
"
mozilla
/
AbsoluteContainingBlock
.
h
"
#
include
"
AnchorPositioningUtils
.
h
"
#
include
"
fmt
/
format
.
h
"
#
include
"
mozilla
/
CSSAlignUtils
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
ReflowInput
.
h
"
#
include
"
mozilla
/
ScrollContainerFrame
.
h
"
#
include
"
mozilla
/
ViewportFrame
.
h
"
#
include
"
mozilla
/
dom
/
ViewTransition
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsGridContainerFrame
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsPlaceholderFrame
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsPresContextInlines
.
h
"
#
ifdef
DEBUG
#
include
"
nsBlockFrame
.
h
"
#
endif
using
namespace
mozilla
;
void
AbsoluteContainingBlock
:
:
SetInitialChildList
(
nsIFrame
*
aDelegatingFrame
FrameChildListID
aListID
nsFrameList
&
&
aChildList
)
{
MOZ_ASSERT
(
mChildListID
=
=
aListID
"
unexpected
child
list
name
"
)
;
#
ifdef
DEBUG
nsIFrame
:
:
VerifyDirtyBitSet
(
aChildList
)
;
for
(
nsIFrame
*
f
:
aChildList
)
{
MOZ_ASSERT
(
f
-
>
GetParent
(
)
=
=
aDelegatingFrame
"
Unexpected
parent
"
)
;
}
#
endif
mAbsoluteFrames
=
std
:
:
move
(
aChildList
)
;
}
void
AbsoluteContainingBlock
:
:
AppendFrames
(
nsIFrame
*
aDelegatingFrame
FrameChildListID
aListID
nsFrameList
&
&
aFrameList
)
{
NS_ASSERTION
(
mChildListID
=
=
aListID
"
unexpected
child
list
"
)
;
#
ifdef
DEBUG
nsIFrame
:
:
VerifyDirtyBitSet
(
aFrameList
)
;
#
endif
mAbsoluteFrames
.
AppendFrames
(
nullptr
std
:
:
move
(
aFrameList
)
)
;
aDelegatingFrame
-
>
PresShell
(
)
-
>
FrameNeedsReflow
(
aDelegatingFrame
IntrinsicDirty
:
:
None
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
}
void
AbsoluteContainingBlock
:
:
InsertFrames
(
nsIFrame
*
aDelegatingFrame
FrameChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
&
aFrameList
)
{
NS_ASSERTION
(
mChildListID
=
=
aListID
"
unexpected
child
list
"
)
;
NS_ASSERTION
(
!
aPrevFrame
|
|
aPrevFrame
-
>
GetParent
(
)
=
=
aDelegatingFrame
"
inserting
after
sibling
frame
with
different
parent
"
)
;
#
ifdef
DEBUG
nsIFrame
:
:
VerifyDirtyBitSet
(
aFrameList
)
;
#
endif
mAbsoluteFrames
.
InsertFrames
(
nullptr
aPrevFrame
std
:
:
move
(
aFrameList
)
)
;
aDelegatingFrame
-
>
PresShell
(
)
-
>
FrameNeedsReflow
(
aDelegatingFrame
IntrinsicDirty
:
:
None
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
}
void
AbsoluteContainingBlock
:
:
RemoveFrame
(
FrameDestroyContext
&
aContext
FrameChildListID
aListID
nsIFrame
*
aOldFrame
)
{
NS_ASSERTION
(
mChildListID
=
=
aListID
"
unexpected
child
list
"
)
;
if
(
!
aOldFrame
-
>
PresContext
(
)
-
>
FragmentainerAwarePositioningEnabled
(
)
)
{
if
(
nsIFrame
*
nif
=
aOldFrame
-
>
GetNextInFlow
(
)
)
{
nif
-
>
GetParent
(
)
-
>
DeleteNextInFlowChild
(
aContext
nif
false
)
;
}
mAbsoluteFrames
.
DestroyFrame
(
aContext
aOldFrame
)
;
return
;
}
AutoTArray
<
nsIFrame
*
8
>
delFrames
;
for
(
nsIFrame
*
f
=
aOldFrame
;
f
;
f
=
f
-
>
GetNextInFlow
(
)
)
{
delFrames
.
AppendElement
(
f
)
;
}
for
(
nsIFrame
*
delFrame
:
Reversed
(
delFrames
)
)
{
delFrame
-
>
GetParent
(
)
-
>
GetAbsoluteContainingBlock
(
)
-
>
StealFrame
(
delFrame
)
;
delFrame
-
>
Destroy
(
aContext
)
;
}
}
nsFrameList
AbsoluteContainingBlock
:
:
StealPushedChildList
(
)
{
return
std
:
:
move
(
mPushedAbsoluteFrames
)
;
}
bool
AbsoluteContainingBlock
:
:
PrepareAbsoluteFrames
(
nsContainerFrame
*
aDelegatingFrame
)
{
if
(
!
aDelegatingFrame
-
>
PresContext
(
)
-
>
FragmentainerAwarePositioningEnabled
(
)
)
{
return
HasAbsoluteFrames
(
)
;
}
if
(
const
nsIFrame
*
prevInFlow
=
aDelegatingFrame
-
>
GetPrevInFlow
(
)
)
{
AbsoluteContainingBlock
*
prevAbsCB
=
prevInFlow
-
>
GetAbsoluteContainingBlock
(
)
;
MOZ_ASSERT
(
prevAbsCB
"
If
this
delegating
frame
has
an
absCB
its
prev
-
in
-
flow
must
"
"
have
one
too
!
"
)
;
nsFrameList
pushedFrames
=
prevAbsCB
-
>
StealPushedChildList
(
)
;
if
(
pushedFrames
.
NotEmpty
(
)
)
{
mAbsoluteFrames
.
InsertFrames
(
aDelegatingFrame
nullptr
std
:
:
move
(
pushedFrames
)
)
;
}
}
nsIFrame
*
child
=
mPushedAbsoluteFrames
.
FirstChild
(
)
;
while
(
child
)
{
nsIFrame
*
next
=
child
-
>
GetNextInFlow
(
)
;
if
(
!
child
-
>
GetPrevInFlow
(
)
|
|
child
-
>
GetPrevInFlow
(
)
-
>
GetParent
(
)
!
=
aDelegatingFrame
)
{
mPushedAbsoluteFrames
.
RemoveFrame
(
child
)
;
mAbsoluteFrames
.
AppendFrame
(
nullptr
child
)
;
}
child
=
next
;
}
return
HasAbsoluteFrames
(
)
;
}
void
AbsoluteContainingBlock
:
:
StealFrame
(
nsIFrame
*
aFrame
)
{
const
DebugOnly
<
bool
>
frameRemoved
=
mAbsoluteFrames
.
StartRemoveFrame
(
aFrame
)
|
|
mPushedAbsoluteFrames
.
ContinueRemoveFrame
(
aFrame
)
;
MOZ_ASSERT
(
frameRemoved
"
Failed
to
find
aFrame
from
our
child
lists
!
"
)
;
}
static
void
MaybeMarkAncestorsAsHavingDescendantDependentOnItsStaticPos
(
nsIFrame
*
aFrame
nsIFrame
*
aContainingBlockFrame
)
{
MOZ_ASSERT
(
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
)
;
if
(
!
aFrame
-
>
StylePosition
(
)
-
>
NeedsHypotheticalPositionIfAbsPos
(
)
)
{
return
;
}
if
(
aFrame
-
>
GetPrevContinuation
(
)
)
{
return
;
}
auto
*
placeholder
=
aFrame
-
>
GetPlaceholderFrame
(
)
;
MOZ_ASSERT
(
placeholder
)
;
if
(
!
placeholder
-
>
HasAnyStateBits
(
PLACEHOLDER_FOR_FIXEDPOS
)
)
{
return
;
}
for
(
nsIFrame
*
ancestor
=
placeholder
-
>
GetParent
(
)
;
ancestor
;
ancestor
=
ancestor
-
>
GetParent
(
)
)
{
do
{
if
(
ancestor
-
>
DescendantMayDependOnItsStaticPosition
(
)
)
{
return
;
}
if
(
aFrame
=
=
aContainingBlockFrame
)
{
return
;
}
ancestor
-
>
SetDescendantMayDependOnItsStaticPosition
(
true
)
;
nsIFrame
*
prev
=
ancestor
-
>
GetPrevContinuation
(
)
;
if
(
!
prev
)
{
break
;
}
ancestor
=
prev
;
}
while
(
true
)
;
}
}
static
bool
IsSnapshotContainingBlock
(
const
nsIFrame
*
aFrame
)
{
return
aFrame
-
>
Style
(
)
-
>
GetPseudoType
(
)
=
=
PseudoStyleType
:
:
mozSnapshotContainingBlock
;
}
static
PhysicalAxes
CheckEarlyCompensatingForScroll
(
const
nsIFrame
*
aKidFrame
)
{
if
(
!
aKidFrame
-
>
StylePosition
(
)
-
>
mPositionArea
.
IsNone
(
)
)
{
return
PhysicalAxes
{
PhysicalAxis
:
:
Horizontal
PhysicalAxis
:
:
Vertical
}
;
}
return
PhysicalAxes
{
}
;
}
static
AnchorPosResolutionCache
PopulateAnchorResolutionCache
(
const
nsIFrame
*
aKidFrame
AnchorPosReferenceData
*
aData
)
{
MOZ_ASSERT
(
aKidFrame
-
>
HasAnchorPosReference
(
)
)
;
AnchorPosResolutionCache
result
{
aData
{
}
}
;
const
auto
defaultAnchorInfo
=
AnchorPositioningUtils
:
:
ResolveAnchorPosRect
(
aKidFrame
aKidFrame
-
>
GetParent
(
)
nullptr
false
&
result
)
;
if
(
defaultAnchorInfo
)
{
aData
-
>
AdjustCompensatingForScroll
(
CheckEarlyCompensatingForScroll
(
aKidFrame
)
)
;
}
return
result
;
}
void
AbsoluteContainingBlock
:
:
Reflow
(
nsContainerFrame
*
aDelegatingFrame
nsPresContext
*
aPresContext
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aReflowStatus
const
nsRect
&
aContainingBlock
AbsPosReflowFlags
aFlags
OverflowAreas
*
aOverflowAreas
)
{
const
auto
scrollableContainingBlock
=
[
&
]
(
)
-
>
nsRect
{
switch
(
aDelegatingFrame
-
>
Style
(
)
-
>
GetPseudoType
(
)
)
{
case
PseudoStyleType
:
:
scrolledContent
:
case
PseudoStyleType
:
:
scrolledCanvas
:
{
ScrollContainerFrame
*
sf
=
do_QueryFrame
(
aDelegatingFrame
-
>
GetParent
(
)
)
;
return
sf
-
>
GetUnsnappedScrolledRectInternal
(
aOverflowAreas
-
>
ScrollableOverflow
(
)
aContainingBlock
.
Size
(
)
)
;
}
default
:
break
;
}
return
aContainingBlock
;
}
(
)
;
nsReflowStatus
reflowStatus
;
const
bool
reflowAll
=
aReflowInput
.
ShouldReflowAllKids
(
)
;
const
bool
cbWidthChanged
=
aFlags
.
contains
(
AbsPosReflowFlag
:
:
CBWidthChanged
)
;
const
bool
cbHeightChanged
=
aFlags
.
contains
(
AbsPosReflowFlag
:
:
CBHeightChanged
)
;
nsOverflowContinuationTracker
tracker
(
aDelegatingFrame
true
)
;
for
(
nsIFrame
*
kidFrame
:
mAbsoluteFrames
)
{
Maybe
<
AnchorPosResolutionCache
>
anchorPosResolutionCache
;
if
(
kidFrame
-
>
HasAnchorPosReference
(
)
)
{
auto
*
referenceData
=
kidFrame
-
>
SetOrUpdateDeletableProperty
(
nsIFrame
:
:
AnchorPosReferences
(
)
)
;
anchorPosResolutionCache
=
Some
(
PopulateAnchorResolutionCache
(
kidFrame
referenceData
)
)
;
}
else
{
kidFrame
-
>
RemoveProperty
(
nsIFrame
:
:
AnchorPosReferences
(
)
)
;
}
bool
kidNeedsReflow
=
reflowAll
|
|
kidFrame
-
>
IsSubtreeDirty
(
)
|
|
FrameDependsOnContainer
(
kidFrame
cbWidthChanged
cbHeightChanged
anchorPosResolutionCache
.
ptrOr
(
nullptr
)
)
;
if
(
kidFrame
-
>
IsSubtreeDirty
(
)
)
{
MaybeMarkAncestorsAsHavingDescendantDependentOnItsStaticPos
(
kidFrame
aDelegatingFrame
)
;
}
const
nscoord
availBSize
=
aReflowInput
.
AvailableBSize
(
)
;
const
WritingMode
containerWM
=
aReflowInput
.
GetWritingMode
(
)
;
if
(
!
kidNeedsReflow
&
&
availBSize
!
=
NS_UNCONSTRAINEDSIZE
)
{
WritingMode
kidWM
=
kidFrame
-
>
GetWritingMode
(
)
;
if
(
containerWM
.
GetBlockDir
(
)
!
=
kidWM
.
GetBlockDir
(
)
)
{
kidNeedsReflow
=
true
;
}
else
{
nscoord
kidBEnd
=
kidFrame
-
>
GetLogicalRect
(
aContainingBlock
.
Size
(
)
)
.
BEnd
(
kidWM
)
;
nscoord
kidOverflowBEnd
=
LogicalRect
(
containerWM
kidFrame
-
>
ScrollableOverflowRectRelativeToSelf
(
)
+
kidFrame
-
>
GetPosition
(
)
aContainingBlock
.
Size
(
)
)
.
BEnd
(
containerWM
)
;
NS_ASSERTION
(
kidOverflowBEnd
>
=
kidBEnd
"
overflow
area
should
be
at
least
as
large
as
frame
rect
"
)
;
if
(
kidOverflowBEnd
>
availBSize
|
|
(
kidBEnd
<
availBSize
&
&
kidFrame
-
>
GetNextInFlow
(
)
)
)
{
kidNeedsReflow
=
true
;
}
}
}
if
(
kidNeedsReflow
&
&
!
aPresContext
-
>
HasPendingInterrupt
(
)
)
{
nsReflowStatus
kidStatus
;
ReflowAbsoluteFrame
(
aDelegatingFrame
aPresContext
aReflowInput
aContainingBlock
scrollableContainingBlock
aFlags
kidFrame
kidStatus
aOverflowAreas
anchorPosResolutionCache
.
ptrOr
(
nullptr
)
)
;
MOZ_ASSERT
(
!
kidStatus
.
IsInlineBreakBefore
(
)
"
ShouldAvoidBreakInside
should
prevent
this
from
happening
"
)
;
nsIFrame
*
nextFrame
=
kidFrame
-
>
GetNextInFlow
(
)
;
if
(
aPresContext
-
>
FragmentainerAwarePositioningEnabled
(
)
)
{
if
(
!
kidStatus
.
IsFullyComplete
(
)
)
{
if
(
!
nextFrame
)
{
nextFrame
=
aPresContext
-
>
PresShell
(
)
-
>
FrameConstructor
(
)
-
>
CreateContinuingFrame
(
kidFrame
aDelegatingFrame
)
;
nextFrame
-
>
AddStateBits
(
NS_FRAME_IS_PUSHED_OUT_OF_FLOW
)
;
mPushedAbsoluteFrames
.
AppendFrame
(
nullptr
nextFrame
)
;
}
else
if
(
nextFrame
-
>
GetParent
(
)
!
=
aDelegatingFrame
-
>
GetNextInFlow
(
)
)
{
nextFrame
-
>
GetParent
(
)
-
>
GetAbsoluteContainingBlock
(
)
-
>
StealFrame
(
nextFrame
)
;
mPushedAbsoluteFrames
.
AppendFrame
(
nullptr
nextFrame
)
;
}
reflowStatus
.
MergeCompletionStatusFrom
(
kidStatus
)
;
}
else
if
(
nextFrame
)
{
FrameDestroyContext
context
(
aPresContext
-
>
PresShell
(
)
)
;
nextFrame
-
>
GetParent
(
)
-
>
GetAbsoluteContainingBlock
(
)
-
>
RemoveFrame
(
context
FrameChildListID
:
:
Absolute
nextFrame
)
;
}
}
else
{
if
(
!
kidStatus
.
IsFullyComplete
(
)
&
&
aDelegatingFrame
-
>
CanContainOverflowContainers
(
)
)
{
if
(
!
nextFrame
)
{
nextFrame
=
aPresContext
-
>
PresShell
(
)
-
>
FrameConstructor
(
)
-
>
CreateContinuingFrame
(
kidFrame
aDelegatingFrame
)
;
}
tracker
.
Insert
(
nextFrame
kidStatus
)
;
reflowStatus
.
MergeCompletionStatusFrom
(
kidStatus
)
;
}
else
if
(
nextFrame
)
{
nsOverflowContinuationTracker
:
:
AutoFinish
fini
(
&
tracker
kidFrame
)
;
FrameDestroyContext
context
(
aPresContext
-
>
PresShell
(
)
)
;
nextFrame
-
>
GetParent
(
)
-
>
DeleteNextInFlowChild
(
context
nextFrame
true
)
;
}
}
}
else
{
if
(
aOverflowAreas
)
{
if
(
!
aPresContext
-
>
FragmentainerAwarePositioningEnabled
(
)
)
{
tracker
.
Skip
(
kidFrame
reflowStatus
)
;
}
aDelegatingFrame
-
>
ConsiderChildOverflow
(
*
aOverflowAreas
kidFrame
)
;
}
}
if
(
kidNeedsReflow
&
&
aPresContext
-
>
CheckForInterrupt
(
aDelegatingFrame
)
)
{
if
(
aDelegatingFrame
-
>
HasAnyStateBits
(
NS_FRAME_IS_DIRTY
)
)
{
kidFrame
-
>
MarkSubtreeDirty
(
)
;
}
else
{
kidFrame
-
>
AddStateBits
(
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
}
}
}
if
(
reflowStatus
.
IsIncomplete
(
)
)
{
reflowStatus
.
SetOverflowIncomplete
(
)
;
reflowStatus
.
SetNextInFlowNeedsReflow
(
)
;
}
aReflowStatus
.
MergeCompletionStatusFrom
(
reflowStatus
)
;
}
static
inline
bool
IsFixedPaddingSize
(
const
LengthPercentage
&
aCoord
)
{
return
aCoord
.
ConvertsToLength
(
)
;
}
static
inline
bool
IsFixedMarginSize
(
const
AnchorResolvedMargin
&
aCoord
)
{
return
aCoord
-
>
ConvertsToLength
(
)
;
}
static
inline
bool
IsFixedOffset
(
const
AnchorResolvedInset
&
aInset
)
{
return
aInset
-
>
ConvertsToLength
(
)
;
}
bool
AbsoluteContainingBlock
:
:
FrameDependsOnContainer
(
nsIFrame
*
f
bool
aCBWidthChanged
bool
aCBHeightChanged
AnchorPosResolutionCache
*
aAnchorPosResolutionCache
)
{
const
nsStylePosition
*
pos
=
f
-
>
StylePosition
(
)
;
if
(
pos
-
>
NeedsHypotheticalPositionIfAbsPos
(
)
)
{
return
true
;
}
if
(
!
aCBWidthChanged
&
&
!
aCBHeightChanged
)
{
return
false
;
}
const
nsStylePadding
*
padding
=
f
-
>
StylePadding
(
)
;
const
nsStyleMargin
*
margin
=
f
-
>
StyleMargin
(
)
;
WritingMode
wm
=
f
-
>
GetWritingMode
(
)
;
const
auto
anchorResolutionParams
=
AnchorPosResolutionParams
:
:
From
(
f
aAnchorPosResolutionCache
)
;
if
(
wm
.
IsVertical
(
)
?
aCBHeightChanged
:
aCBWidthChanged
)
{
if
(
nsStylePosition
:
:
ISizeDependsOnContainer
(
pos
-
>
ISize
(
wm
anchorResolutionParams
)
)
|
|
nsStylePosition
:
:
MinISizeDependsOnContainer
(
pos
-
>
MinISize
(
wm
anchorResolutionParams
)
)
|
|
nsStylePosition
:
:
MaxISizeDependsOnContainer
(
pos
-
>
MaxISize
(
wm
anchorResolutionParams
)
)
|
|
!
IsFixedPaddingSize
(
padding
-
>
mPadding
.
GetIStart
(
wm
)
)
|
|
!
IsFixedPaddingSize
(
padding
-
>
mPadding
.
GetIEnd
(
wm
)
)
)
{
return
true
;
}
if
(
!
IsFixedMarginSize
(
margin
-
>
GetMargin
(
LogicalSide
:
:
IStart
wm
anchorResolutionParams
)
)
|
|
!
IsFixedMarginSize
(
margin
-
>
GetMargin
(
LogicalSide
:
:
IEnd
wm
anchorResolutionParams
)
)
)
{
return
true
;
}
}
if
(
wm
.
IsVertical
(
)
?
aCBWidthChanged
:
aCBHeightChanged
)
{
const
auto
bSize
=
pos
-
>
BSize
(
wm
anchorResolutionParams
)
;
const
auto
anchorOffsetResolutionParams
=
AnchorPosOffsetResolutionParams
:
:
UseCBFrameSize
(
anchorResolutionParams
)
;
if
(
(
nsStylePosition
:
:
BSizeDependsOnContainer
(
bSize
)
&
&
!
(
bSize
-
>
IsAuto
(
)
&
&
pos
-
>
GetAnchorResolvedInset
(
LogicalSide
:
:
BEnd
wm
anchorOffsetResolutionParams
)
-
>
IsAuto
(
)
&
&
!
pos
-
>
GetAnchorResolvedInset
(
LogicalSide
:
:
BStart
wm
anchorOffsetResolutionParams
)
-
>
IsAuto
(
)
)
)
|
|
nsStylePosition
:
:
MinBSizeDependsOnContainer
(
pos
-
>
MinBSize
(
wm
anchorResolutionParams
)
)
|
|
nsStylePosition
:
:
MaxBSizeDependsOnContainer
(
pos
-
>
MaxBSize
(
wm
anchorResolutionParams
)
)
|
|
!
IsFixedPaddingSize
(
padding
-
>
mPadding
.
GetBStart
(
wm
)
)
|
|
!
IsFixedPaddingSize
(
padding
-
>
mPadding
.
GetBEnd
(
wm
)
)
)
{
return
true
;
}
if
(
!
IsFixedMarginSize
(
margin
-
>
GetMargin
(
LogicalSide
:
:
BStart
wm
anchorResolutionParams
)
)
|
|
!
IsFixedMarginSize
(
margin
-
>
GetMargin
(
LogicalSide
:
:
BEnd
wm
anchorResolutionParams
)
)
)
{
return
true
;
}
}
if
(
aCBWidthChanged
)
{
const
auto
anchorOffsetResolutionParams
=
AnchorPosOffsetResolutionParams
:
:
UseCBFrameSize
(
anchorResolutionParams
)
;
if
(
!
IsFixedOffset
(
pos
-
>
GetAnchorResolvedInset
(
eSideLeft
anchorOffsetResolutionParams
)
)
)
{
return
true
;
}
if
(
(
wm
.
GetInlineDir
(
)
=
=
WritingMode
:
:
InlineDir
:
:
RTL
|
|
wm
.
GetBlockDir
(
)
=
=
WritingMode
:
:
BlockDir
:
:
RL
)
&
&
!
pos
-
>
GetAnchorResolvedInset
(
eSideRight
anchorOffsetResolutionParams
)
-
>
IsAuto
(
)
)
{
return
true
;
}
}
if
(
aCBHeightChanged
)
{
const
auto
anchorOffsetResolutionParams
=
AnchorPosOffsetResolutionParams
:
:
UseCBFrameSize
(
anchorResolutionParams
)
;
if
(
!
IsFixedOffset
(
pos
-
>
GetAnchorResolvedInset
(
eSideTop
anchorOffsetResolutionParams
)
)
)
{
return
true
;
}
if
(
wm
.
GetInlineDir
(
)
=
=
WritingMode
:
:
InlineDir
:
:
BTT
&
&
!
pos
-
>
GetAnchorResolvedInset
(
eSideBottom
anchorOffsetResolutionParams
)
-
>
IsAuto
(
)
)
{
return
true
;
}
}
return
false
;
}
void
AbsoluteContainingBlock
:
:
DestroyFrames
(
DestroyContext
&
aContext
)
{
mAbsoluteFrames
.
DestroyFrames
(
aContext
)
;
mPushedAbsoluteFrames
.
DestroyFrames
(
aContext
)
;
}
void
AbsoluteContainingBlock
:
:
MarkSizeDependentFramesDirty
(
)
{
DoMarkFramesDirty
(
false
)
;
}
void
AbsoluteContainingBlock
:
:
MarkAllFramesDirty
(
)
{
DoMarkFramesDirty
(
true
)
;
}
void
AbsoluteContainingBlock
:
:
DoMarkFramesDirty
(
bool
aMarkAllDirty
)
{
for
(
nsIFrame
*
kidFrame
:
mAbsoluteFrames
)
{
if
(
aMarkAllDirty
)
{
kidFrame
-
>
MarkSubtreeDirty
(
)
;
}
else
if
(
FrameDependsOnContainer
(
kidFrame
true
true
)
)
{
kidFrame
-
>
AddStateBits
(
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
}
}
}
static
nsContainerFrame
*
GetPlaceholderContainer
(
nsIFrame
*
aPositionedFrame
)
{
nsIFrame
*
placeholder
=
aPositionedFrame
-
>
GetPlaceholderFrame
(
)
;
return
placeholder
?
placeholder
-
>
GetParent
(
)
:
nullptr
;
}
struct
NonAutoAlignParams
{
nscoord
mCurrentStartInset
;
nscoord
mCurrentEndInset
;
NonAutoAlignParams
(
nscoord
aStartInset
nscoord
aEndInset
)
:
mCurrentStartInset
(
aStartInset
)
mCurrentEndInset
(
aEndInset
)
{
}
}
;
static
nscoord
OffsetToAlignedStaticPos
(
const
ReflowInput
&
aKidReflowInput
const
LogicalSize
&
aKidSizeInAbsPosCBWM
const
LogicalSize
&
aAbsPosCBSize
const
nsContainerFrame
*
aPlaceholderContainer
WritingMode
aAbsPosCBWM
LogicalAxis
aAbsPosCBAxis
Maybe
<
NonAutoAlignParams
>
aNonAutoAlignParams
const
StylePositionArea
&
aPositionArea
)
{
if
(
!
aPlaceholderContainer
)
{
NS_ERROR
(
"
Missing
placeholder
-
container
when
computing
a
"
"
CSS
Box
Alignment
static
position
"
)
;
return
0
;
}
WritingMode
pcWM
=
aPlaceholderContainer
-
>
GetWritingMode
(
)
;
LogicalSize
absPosCBSizeInPCWM
=
aAbsPosCBSize
.
ConvertTo
(
pcWM
aAbsPosCBWM
)
;
const
LogicalAxis
pcAxis
=
aAbsPosCBWM
.
ConvertAxisTo
(
aAbsPosCBAxis
pcWM
)
;
const
LogicalSize
alignAreaSize
=
[
&
]
(
)
{
if
(
!
aNonAutoAlignParams
)
{
const
bool
placeholderContainerIsContainingBlock
=
aPlaceholderContainer
=
=
aKidReflowInput
.
mCBReflowInput
-
>
mFrame
;
LayoutFrameType
parentType
=
aPlaceholderContainer
-
>
Type
(
)
;
LogicalSize
alignAreaSize
(
pcWM
)
;
if
(
parentType
=
=
LayoutFrameType
:
:
FlexContainer
)
{
if
(
placeholderContainerIsContainingBlock
)
{
alignAreaSize
=
aAbsPosCBSize
.
ConvertTo
(
pcWM
aAbsPosCBWM
)
;
alignAreaSize
-
=
aPlaceholderContainer
-
>
GetLogicalUsedPadding
(
pcWM
)
.
Size
(
pcWM
)
;
}
else
{
alignAreaSize
=
aPlaceholderContainer
-
>
GetLogicalSize
(
pcWM
)
;
LogicalMargin
pcBorderPadding
=
aPlaceholderContainer
-
>
GetLogicalUsedBorderAndPadding
(
pcWM
)
;
alignAreaSize
-
=
pcBorderPadding
.
Size
(
pcWM
)
;
}
return
alignAreaSize
;
}
if
(
parentType
=
=
LayoutFrameType
:
:
GridContainer
)
{
if
(
placeholderContainerIsContainingBlock
)
{
alignAreaSize
=
aAbsPosCBSize
.
ConvertTo
(
pcWM
aAbsPosCBWM
)
;
}
else
{
alignAreaSize
=
aPlaceholderContainer
-
>
GetLogicalSize
(
pcWM
)
;
LogicalMargin
pcBorderPadding
=
aPlaceholderContainer
-
>
GetLogicalUsedBorderAndPadding
(
pcWM
)
;
alignAreaSize
-
=
pcBorderPadding
.
Size
(
pcWM
)
;
}
return
alignAreaSize
;
}
}
return
aAbsPosCBSize
.
ConvertTo
(
pcWM
aAbsPosCBWM
)
;
}
(
)
;
const
nscoord
existingOffset
=
aNonAutoAlignParams
?
aNonAutoAlignParams
-
>
mCurrentStartInset
+
aNonAutoAlignParams
-
>
mCurrentEndInset
:
0
;
const
nscoord
alignAreaSizeInAxis
=
(
(
pcAxis
=
=
LogicalAxis
:
:
Inline
)
?
alignAreaSize
.
ISize
(
pcWM
)
:
alignAreaSize
.
BSize
(
pcWM
)
)
-
existingOffset
;
using
AlignJustifyFlag
=
CSSAlignUtils
:
:
AlignJustifyFlag
;
CSSAlignUtils
:
:
AlignJustifyFlags
flags
(
AlignJustifyFlag
:
:
IgnoreAutoMargins
)
;
StyleAlignFlags
alignConst
=
aNonAutoAlignParams
?
aPlaceholderContainer
-
>
CSSAlignmentForAbsPosChildWithinContainingBlock
(
aKidReflowInput
pcAxis
aPositionArea
absPosCBSizeInPCWM
)
:
aPlaceholderContainer
-
>
CSSAlignmentForAbsPosChild
(
aKidReflowInput
pcAxis
)
;
const
auto
safetyBits
=
alignConst
&
(
StyleAlignFlags
:
:
SAFE
|
StyleAlignFlags
:
:
UNSAFE
)
;
alignConst
&
=
~
StyleAlignFlags
:
:
FLAG_BITS
;
if
(
safetyBits
&
StyleAlignFlags
:
:
SAFE
)
{
flags
+
=
AlignJustifyFlag
:
:
OverflowSafe
;
}
WritingMode
kidWM
=
aKidReflowInput
.
GetWritingMode
(
)
;
if
(
pcWM
.
ParallelAxisStartsOnSameSide
(
pcAxis
kidWM
)
)
{
flags
+
=
AlignJustifyFlag
:
:
SameSide
;
}
if
(
aNonAutoAlignParams
)
{
flags
+
=
AlignJustifyFlag
:
:
AligningMarginBox
;
}
const
nscoord
baselineAdjust
=
nscoord
(
0
)
;
LogicalSize
kidSizeInOwnWM
=
aKidSizeInAbsPosCBWM
.
ConvertTo
(
kidWM
aAbsPosCBWM
)
;
const
LogicalAxis
kidAxis
=
aAbsPosCBWM
.
ConvertAxisTo
(
aAbsPosCBAxis
kidWM
)
;
Maybe
<
CSSAlignUtils
:
:
AnchorAlignInfo
>
anchorAlignInfo
;
if
(
alignConst
=
=
StyleAlignFlags
:
:
ANCHOR_CENTER
&
&
aKidReflowInput
.
mAnchorPosResolutionCache
)
{
auto
*
referenceData
=
aKidReflowInput
.
mAnchorPosResolutionCache
-
>
mReferenceData
;
if
(
referenceData
)
{
const
auto
*
cachedData
=
referenceData
-
>
Lookup
(
referenceData
-
>
mDefaultAnchorName
)
;
if
(
cachedData
&
&
*
cachedData
)
{
referenceData
-
>
AdjustCompensatingForScroll
(
aAbsPosCBWM
.
PhysicalAxis
(
aAbsPosCBAxis
)
)
;
const
auto
&
data
=
cachedData
-
>
ref
(
)
;
if
(
data
.
mOffsetData
)
{
const
nsSize
containerSize
=
aAbsPosCBSize
.
GetPhysicalSize
(
aAbsPosCBWM
)
;
const
nsRect
anchorRect
(
data
.
mOffsetData
-
>
mOrigin
data
.
mSize
)
;
const
LogicalRect
logicalAnchorRect
{
aAbsPosCBWM
anchorRect
containerSize
}
;
const
auto
axisInAbsPosCBWM
=
kidWM
.
ConvertAxisTo
(
kidAxis
aAbsPosCBWM
)
;
const
auto
anchorStart
=
logicalAnchorRect
.
Start
(
axisInAbsPosCBWM
aAbsPosCBWM
)
;
const
auto
anchorSize
=
logicalAnchorRect
.
Size
(
axisInAbsPosCBWM
aAbsPosCBWM
)
;
anchorAlignInfo
=
Some
(
CSSAlignUtils
:
:
AnchorAlignInfo
{
anchorStart
anchorSize
}
)
;
if
(
aNonAutoAlignParams
)
{
anchorAlignInfo
-
>
mAnchorStart
-
=
aNonAutoAlignParams
-
>
mCurrentStartInset
;
}
}
}
}
}
nscoord
offset
=
CSSAlignUtils
:
:
AlignJustifySelf
(
alignConst
kidAxis
flags
baselineAdjust
alignAreaSizeInAxis
aKidReflowInput
kidSizeInOwnWM
anchorAlignInfo
)
;
if
(
(
!
aNonAutoAlignParams
|
|
(
safetyBits
&
StyleAlignFlags
:
:
SAFE
)
)
&
&
alignConst
=
=
StyleAlignFlags
:
:
ANCHOR_CENTER
)
{
const
auto
cbSize
=
aAbsPosCBSize
.
Size
(
aAbsPosCBAxis
aAbsPosCBWM
)
;
const
auto
kidSize
=
aKidSizeInAbsPosCBWM
.
Size
(
aAbsPosCBAxis
aAbsPosCBWM
)
;
if
(
aNonAutoAlignParams
)
{
const
nscoord
currentStartInset
=
aNonAutoAlignParams
-
>
mCurrentStartInset
;
const
nscoord
finalStart
=
currentStartInset
+
offset
;
const
nscoord
clampedStart
=
CSSMinMax
(
finalStart
nscoord
(
0
)
cbSize
-
kidSize
)
;
offset
=
clampedStart
-
currentStartInset
;
}
else
{
offset
=
CSSMinMax
(
offset
nscoord
(
0
)
cbSize
-
kidSize
)
;
}
}
const
auto
rawAlignConst
=
(
pcAxis
=
=
LogicalAxis
:
:
Inline
)
?
aKidReflowInput
.
mStylePosition
-
>
mJustifySelf
.
_0
:
aKidReflowInput
.
mStylePosition
-
>
mAlignSelf
.
_0
;
if
(
aNonAutoAlignParams
&
&
!
safetyBits
&
&
rawAlignConst
!
=
StyleAlignFlags
:
:
AUTO
)
{
const
auto
cbSize
=
aAbsPosCBSize
.
Size
(
aAbsPosCBAxis
aAbsPosCBWM
)
;
const
auto
imcbStart
=
aNonAutoAlignParams
-
>
mCurrentStartInset
;
const
auto
imcbEnd
=
cbSize
-
aNonAutoAlignParams
-
>
mCurrentEndInset
;
const
auto
kidSize
=
aKidSizeInAbsPosCBWM
.
Size
(
aAbsPosCBAxis
aAbsPosCBWM
)
;
const
auto
kidStart
=
aNonAutoAlignParams
-
>
mCurrentStartInset
+
offset
;
const
auto
kidEnd
=
kidStart
+
kidSize
;
const
auto
overflowLimitRectStart
=
std
:
:
min
(
0
imcbStart
)
;
const
auto
overflowLimitRectEnd
=
std
:
:
max
(
cbSize
imcbEnd
)
;
if
(
kidStart
>
=
imcbStart
&
&
kidEnd
<
=
imcbEnd
)
{
}
else
if
(
kidSize
<
=
overflowLimitRectEnd
-
overflowLimitRectStart
)
{
if
(
kidStart
<
=
imcbStart
&
&
kidEnd
>
=
imcbEnd
)
{
if
(
kidStart
<
overflowLimitRectStart
)
{
offset
+
=
overflowLimitRectStart
-
kidStart
;
}
else
if
(
kidEnd
>
overflowLimitRectEnd
)
{
offset
-
=
kidEnd
-
overflowLimitRectEnd
;
}
}
else
if
(
kidEnd
<
imcbEnd
&
&
kidStart
<
imcbStart
)
{
offset
+
=
std
:
:
min
(
imcbStart
-
kidStart
imcbEnd
-
kidEnd
)
;
}
else
if
(
kidStart
>
imcbStart
&
&
kidEnd
>
imcbEnd
)
{
offset
-
=
std
:
:
min
(
kidEnd
-
imcbEnd
kidStart
-
imcbStart
)
;
}
}
else
{
offset
=
-
aNonAutoAlignParams
-
>
mCurrentStartInset
+
overflowLimitRectStart
;
}
}
if
(
!
pcWM
.
ParallelAxisStartsOnSameSide
(
pcAxis
aAbsPosCBWM
)
)
{
return
-
offset
;
}
return
offset
;
}
void
AbsoluteContainingBlock
:
:
ResolveSizeDependentOffsets
(
ReflowInput
&
aKidReflowInput
const
LogicalSize
&
aCBSize
const
LogicalSize
&
aKidSize
const
LogicalMargin
&
aMargin
const
StylePositionArea
&
aResolvedPositionArea
LogicalMargin
&
aOffsets
)
{
WritingMode
outerWM
=
aKidReflowInput
.
mParentReflowInput
-
>
GetWritingMode
(
)
;
if
(
(
NS_AUTOOFFSET
=
=
aOffsets
.
IStart
(
outerWM
)
)
|
|
(
NS_AUTOOFFSET
=
=
aOffsets
.
BStart
(
outerWM
)
)
|
|
aKidReflowInput
.
mFlags
.
mIOffsetsNeedCSSAlign
|
|
aKidReflowInput
.
mFlags
.
mBOffsetsNeedCSSAlign
)
{
nsContainerFrame
*
placeholderContainer
=
nullptr
;
if
(
NS_AUTOOFFSET
=
=
aOffsets
.
IStart
(
outerWM
)
)
{
NS_ASSERTION
(
NS_AUTOOFFSET
!
=
aOffsets
.
IEnd
(
outerWM
)
"
Can
'
t
solve
for
both
start
and
end
"
)
;
aOffsets
.
IStart
(
outerWM
)
=
aCBSize
.
ISize
(
outerWM
)
-
aOffsets
.
IEnd
(
outerWM
)
-
aMargin
.
IStartEnd
(
outerWM
)
-
aKidSize
.
ISize
(
outerWM
)
;
}
else
if
(
aKidReflowInput
.
mFlags
.
mIOffsetsNeedCSSAlign
)
{
placeholderContainer
=
GetPlaceholderContainer
(
aKidReflowInput
.
mFrame
)
;
nscoord
offset
=
OffsetToAlignedStaticPos
(
aKidReflowInput
aKidSize
aCBSize
placeholderContainer
outerWM
LogicalAxis
:
:
Inline
Nothing
{
}
aResolvedPositionArea
)
;
aOffsets
.
IStart
(
outerWM
)
+
=
offset
;
aOffsets
.
IEnd
(
outerWM
)
=
aCBSize
.
ISize
(
outerWM
)
-
(
aOffsets
.
IStart
(
outerWM
)
+
aKidSize
.
ISize
(
outerWM
)
)
;
}
if
(
NS_AUTOOFFSET
=
=
aOffsets
.
BStart
(
outerWM
)
)
{
aOffsets
.
BStart
(
outerWM
)
=
aCBSize
.
BSize
(
outerWM
)
-
aOffsets
.
BEnd
(
outerWM
)
-
aMargin
.
BStartEnd
(
outerWM
)
-
aKidSize
.
BSize
(
outerWM
)
;
}
else
if
(
aKidReflowInput
.
mFlags
.
mBOffsetsNeedCSSAlign
)
{
if
(
!
placeholderContainer
)
{
placeholderContainer
=
GetPlaceholderContainer
(
aKidReflowInput
.
mFrame
)
;
}
nscoord
offset
=
OffsetToAlignedStaticPos
(
aKidReflowInput
aKidSize
aCBSize
placeholderContainer
outerWM
LogicalAxis
:
:
Block
Nothing
{
}
aResolvedPositionArea
)
;
aOffsets
.
BStart
(
outerWM
)
+
=
offset
;
aOffsets
.
BEnd
(
outerWM
)
=
aCBSize
.
BSize
(
outerWM
)
-
(
aOffsets
.
BStart
(
outerWM
)
+
aKidSize
.
BSize
(
outerWM
)
)
;
}
aKidReflowInput
.
SetComputedLogicalOffsets
(
outerWM
aOffsets
)
;
}
}
void
AbsoluteContainingBlock
:
:
ResolveAutoMarginsAfterLayout
(
ReflowInput
&
aKidReflowInput
const
LogicalSize
&
aCBSize
const
LogicalSize
&
aKidSize
LogicalMargin
&
aMargin
const
LogicalMargin
&
aOffsets
)
{
WritingMode
outerWM
=
aKidReflowInput
.
mParentReflowInput
-
>
GetWritingMode
(
)
;
const
auto
&
styleMargin
=
aKidReflowInput
.
mStyleMargin
;
const
auto
anchorResolutionParams
=
AnchorPosResolutionParams
:
:
From
(
&
aKidReflowInput
)
;
auto
ResolveMarginsInAxis
=
[
&
]
(
LogicalAxis
aAxis
)
{
const
auto
startSide
=
MakeLogicalSide
(
aAxis
LogicalEdge
:
:
Start
)
;
const
auto
endSide
=
MakeLogicalSide
(
aAxis
LogicalEdge
:
:
End
)
;
const
bool
autoOffset
=
aOffsets
.
Side
(
startSide
outerWM
)
=
=
NS_AUTOOFFSET
|
|
aOffsets
.
Side
(
endSide
outerWM
)
=
=
NS_AUTOOFFSET
;
nscoord
availMarginSpace
;
if
(
autoOffset
)
{
availMarginSpace
=
0
;
}
else
{
const
nscoord
stretchFitSize
=
std
:
:
max
(
0
aCBSize
.
Size
(
aAxis
outerWM
)
-
aOffsets
.
StartEnd
(
aAxis
outerWM
)
-
aMargin
.
StartEnd
(
aAxis
outerWM
)
)
;
availMarginSpace
=
stretchFitSize
-
aKidSize
.
Size
(
aAxis
outerWM
)
;
}
const
bool
startSideMarginIsAuto
=
styleMargin
-
>
GetMargin
(
startSide
outerWM
anchorResolutionParams
)
-
>
IsAuto
(
)
;
const
bool
endSideMarginIsAuto
=
styleMargin
-
>
GetMargin
(
endSide
outerWM
anchorResolutionParams
)
-
>
IsAuto
(
)
;
if
(
aAxis
=
=
LogicalAxis
:
:
Inline
)
{
ReflowInput
:
:
ComputeAbsPosInlineAutoMargin
(
availMarginSpace
outerWM
startSideMarginIsAuto
endSideMarginIsAuto
aMargin
)
;
}
else
{
ReflowInput
:
:
ComputeAbsPosBlockAutoMargin
(
availMarginSpace
outerWM
startSideMarginIsAuto
endSideMarginIsAuto
aMargin
)
;
}
}
;
ResolveMarginsInAxis
(
LogicalAxis
:
:
Inline
)
;
ResolveMarginsInAxis
(
LogicalAxis
:
:
Block
)
;
aKidReflowInput
.
SetComputedLogicalMargin
(
outerWM
aMargin
)
;
nsMargin
*
propValue
=
aKidReflowInput
.
mFrame
-
>
GetProperty
(
nsIFrame
:
:
UsedMarginProperty
(
)
)
;
MOZ_ASSERT_IF
(
styleMargin
-
>
HasInlineAxisAuto
(
outerWM
anchorResolutionParams
)
|
|
styleMargin
-
>
HasBlockAxisAuto
(
outerWM
anchorResolutionParams
)
propValue
)
;
if
(
propValue
)
{
*
propValue
=
aMargin
.
GetPhysicalMargin
(
outerWM
)
;
}
}
struct
None
{
}
;
using
OldCacheState
=
Variant
<
None
AnchorPosResolutionCache
:
:
PositionTryBackup
AnchorPosResolutionCache
:
:
PositionTryFullBackup
>
;
struct
MOZ_STACK_CLASS
MOZ_RAII
AutoFallbackStyleSetter
{
AutoFallbackStyleSetter
(
nsIFrame
*
aFrame
ComputedStyle
*
aFallbackStyle
AnchorPosResolutionCache
*
aCache
bool
aIsFirstTry
)
:
mFrame
(
aFrame
)
mCache
{
aCache
}
mOldCacheState
{
None
{
}
}
{
if
(
aFallbackStyle
)
{
mOldStyle
=
aFrame
-
>
SetComputedStyleWithoutNotification
(
aFallbackStyle
)
;
}
if
(
!
aIsFirstTry
&
&
aCache
)
{
if
(
mOldStyle
&
&
mOldStyle
-
>
StylePosition
(
)
-
>
mPositionAnchor
!
=
aFrame
-
>
StylePosition
(
)
-
>
mPositionAnchor
)
{
mOldCacheState
=
OldCacheState
{
aCache
-
>
TryPositionWithDifferentDefaultAnchor
(
)
}
;
*
aCache
=
PopulateAnchorResolutionCache
(
aFrame
aCache
-
>
mReferenceData
)
;
}
else
{
mOldCacheState
=
OldCacheState
{
aCache
-
>
TryPositionWithSameDefaultAnchor
(
)
}
;
if
(
aCache
-
>
mDefaultAnchorCache
.
mAnchor
)
{
aCache
-
>
mReferenceData
-
>
AdjustCompensatingForScroll
(
CheckEarlyCompensatingForScroll
(
aFrame
)
)
;
}
}
}
}
~
AutoFallbackStyleSetter
(
)
{
if
(
mOldStyle
)
{
mFrame
-
>
SetComputedStyleWithoutNotification
(
std
:
:
move
(
mOldStyle
)
)
;
}
std
:
:
move
(
mOldCacheState
)
.
match
(
[
]
(
None
&
&
)
{
}
[
&
]
(
AnchorPosResolutionCache
:
:
PositionTryBackup
&
&
aBackup
)
{
mCache
-
>
UndoTryPositionWithSameDefaultAnchor
(
std
:
:
move
(
aBackup
)
)
;
}
[
&
]
(
AnchorPosResolutionCache
:
:
PositionTryFullBackup
&
&
aBackup
)
{
mCache
-
>
UndoTryPositionWithDifferentDefaultAnchor
(
std
:
:
move
(
aBackup
)
)
;
}
)
;
}
void
CommitCurrentFallback
(
)
{
mOldCacheState
=
OldCacheState
{
None
{
}
}
;
nsMargin
margin
;
if
(
mOldStyle
&
&
!
mOldStyle
-
>
StyleMargin
(
)
-
>
MarginEquals
(
*
mFrame
-
>
StyleMargin
(
)
)
&
&
mFrame
-
>
StyleMargin
(
)
-
>
GetMargin
(
margin
)
)
{
mFrame
-
>
SetOrUpdateDeletableProperty
(
nsIFrame
:
:
UsedMarginProperty
(
)
margin
)
;
}
}
private
:
nsIFrame
*
const
mFrame
;
RefPtr
<
ComputedStyle
>
mOldStyle
;
AnchorPosResolutionCache
*
const
mCache
;
OldCacheState
mOldCacheState
;
}
;
struct
AnchorShiftInfo
{
nsPoint
mOffset
;
StylePositionArea
mResolvedArea
;
}
;
struct
ContainingBlockRect
{
Maybe
<
AnchorShiftInfo
>
mAnchorShiftInfo
;
nsRect
mMaybeScrollableRect
;
nsRect
mFinalRect
;
explicit
ContainingBlockRect
(
const
nsRect
&
aRect
)
:
mMaybeScrollableRect
{
aRect
}
mFinalRect
{
aRect
}
{
}
ContainingBlockRect
(
const
nsPoint
&
aOffset
const
StylePositionArea
&
aResolvedArea
const
nsRect
&
aMaybeScrollableRect
const
nsRect
&
aFinalRect
)
:
mAnchorShiftInfo
{
Some
(
AnchorShiftInfo
{
aOffset
aResolvedArea
}
)
}
mMaybeScrollableRect
{
aMaybeScrollableRect
}
mFinalRect
{
aFinalRect
}
{
}
StylePositionArea
ResolvedPositionArea
(
)
const
{
return
mAnchorShiftInfo
.
map
(
[
]
(
const
AnchorShiftInfo
&
aInfo
)
{
return
aInfo
.
mResolvedArea
;
}
)
.
valueOr
(
StylePositionArea
{
}
)
;
}
}
;
static
SideBits
GetScrollCompensatedSidesFor
(
const
StylePositionArea
&
aPositionArea
)
{
SideBits
sides
{
SideBits
:
:
eNone
}
;
if
(
aPositionArea
.
first
=
=
StylePositionAreaKeyword
:
:
Left
|
|
aPositionArea
.
first
=
=
StylePositionAreaKeyword
:
:
SpanLeft
)
{
sides
|
=
SideBits
:
:
eRight
;
}
else
if
(
aPositionArea
.
first
=
=
StylePositionAreaKeyword
:
:
Right
|
|
aPositionArea
.
first
=
=
StylePositionAreaKeyword
:
:
SpanRight
)
{
sides
|
=
SideBits
:
:
eLeft
;
}
else
if
(
aPositionArea
.
first
=
=
StylePositionAreaKeyword
:
:
Center
)
{
sides
|
=
SideBits
:
:
eLeftRight
;
}
if
(
aPositionArea
.
second
=
=
StylePositionAreaKeyword
:
:
Top
|
|
aPositionArea
.
second
=
=
StylePositionAreaKeyword
:
:
SpanTop
)
{
sides
|
=
SideBits
:
:
eBottom
;
}
else
if
(
aPositionArea
.
second
=
=
StylePositionAreaKeyword
:
:
Bottom
|
|
aPositionArea
.
second
=
=
StylePositionAreaKeyword
:
:
SpanBottom
)
{
sides
|
=
SideBits
:
:
eTop
;
}
else
if
(
aPositionArea
.
first
=
=
StylePositionAreaKeyword
:
:
Center
)
{
sides
|
=
SideBits
:
:
eTopBottom
;
}
return
sides
;
}
void
AbsoluteContainingBlock
:
:
ReflowAbsoluteFrame
(
nsContainerFrame
*
aDelegatingFrame
nsPresContext
*
aPresContext
const
ReflowInput
&
aReflowInput
const
nsRect
&
aOriginalContainingBlockRect
const
nsRect
&
aOriginalScrollableContainingBlockRect
AbsPosReflowFlags
aFlags
nsIFrame
*
aKidFrame
nsReflowStatus
&
aStatus
OverflowAreas
*
aOverflowAreas
AnchorPosResolutionCache
*
aAnchorPosResolutionCache
)
{
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
#
ifdef
DEBUG
if
(
nsBlockFrame
:
:
gNoisyReflow
)
{
nsIFrame
:
:
IndentBy
(
stdout
nsBlockFrame
:
:
gNoiseIndent
)
;
fmt
:
:
println
(
FMT_STRING
(
"
abspos
{
}
:
begin
reflow
:
availSize
=
{
}
orig
cbRect
=
{
}
"
)
aKidFrame
-
>
ListTag
(
)
ToString
(
aReflowInput
.
AvailableSize
(
)
)
ToString
(
aOriginalContainingBlockRect
)
)
;
}
AutoNoisyIndenter
indent
(
nsBlockFrame
:
:
gNoisy
)
;
#
endif
const
bool
isGrid
=
aFlags
.
contains
(
AbsPosReflowFlag
:
:
IsGridContainerCB
)
;
auto
fallbacks
=
aKidFrame
-
>
StylePosition
(
)
-
>
mPositionTryFallbacks
.
_0
.
AsSpan
(
)
;
Maybe
<
uint32_t
>
currentFallbackIndex
;
const
StylePositionTryFallbacksItem
*
currentFallback
=
nullptr
;
RefPtr
<
ComputedStyle
>
currentFallbackStyle
;
RefPtr
<
ComputedStyle
>
firstTryStyle
;
Maybe
<
uint32_t
>
firstTryIndex
;
auto
SeekFallbackTo
=
[
&
]
(
Maybe
<
uint32_t
>
aIndex
)
-
>
bool
{
if
(
!
aIndex
)
{
currentFallbackIndex
=
Nothing
(
)
;
currentFallback
=
nullptr
;
currentFallbackStyle
=
nullptr
;
return
true
;
}
uint32_t
index
=
*
aIndex
;
if
(
index
>
=
fallbacks
.
Length
(
)
)
{
return
false
;
}
const
StylePositionTryFallbacksItem
*
nextFallback
;
RefPtr
<
ComputedStyle
>
nextFallbackStyle
;
while
(
true
)
{
nextFallback
=
&
fallbacks
[
index
]
;
nextFallbackStyle
=
aPresContext
-
>
StyleSet
(
)
-
>
ResolvePositionTry
(
*
aKidFrame
-
>
GetContent
(
)
-
>
AsElement
(
)
*
aKidFrame
-
>
Style
(
)
*
nextFallback
)
;
if
(
nextFallbackStyle
)
{
break
;
}
index
+
+
;
if
(
index
>
=
fallbacks
.
Length
(
)
)
{
return
false
;
}
}
currentFallbackIndex
=
Some
(
index
)
;
currentFallback
=
nextFallback
;
currentFallbackStyle
=
std
:
:
move
(
nextFallbackStyle
)
;
return
true
;
}
;
auto
TryAdvanceFallback
=
[
&
]
(
)
-
>
bool
{
if
(
fallbacks
.
IsEmpty
(
)
)
{
return
false
;
}
if
(
firstTryIndex
&
&
currentFallbackIndex
=
=
firstTryIndex
)
{
return
SeekFallbackTo
(
Nothing
(
)
)
;
}
uint32_t
nextFallbackIndex
=
currentFallbackIndex
?
*
currentFallbackIndex
+
1
:
0
;
if
(
firstTryIndex
&
&
nextFallbackIndex
=
=
*
firstTryIndex
)
{
+
+
nextFallbackIndex
;
}
return
SeekFallbackTo
(
Some
(
nextFallbackIndex
)
)
;
}
;
Maybe
<
nsPoint
>
firstTryNormalPosition
;
if
(
auto
*
lastSuccessfulPosition
=
aKidFrame
-
>
GetProperty
(
nsIFrame
:
:
LastSuccessfulPositionFallback
(
)
)
)
{
if
(
SeekFallbackTo
(
Some
(
lastSuccessfulPosition
-
>
mIndex
)
)
)
{
firstTryIndex
=
Some
(
lastSuccessfulPosition
-
>
mIndex
)
;
firstTryStyle
=
currentFallbackStyle
;
}
else
{
aKidFrame
-
>
RemoveProperty
(
nsIFrame
:
:
LastSuccessfulPositionFallback
(
)
)
;
}
}
bool
isOverflowingCB
=
true
;
do
{
AutoFallbackStyleSetter
fallback
(
aKidFrame
currentFallbackStyle
aAnchorPosResolutionCache
firstTryIndex
=
=
currentFallbackIndex
)
;
auto
cb
=
[
&
]
(
)
{
nsRect
containingBlock
=
aOriginalContainingBlockRect
;
const
auto
defaultAnchorInfo
=
[
&
]
(
)
-
>
Maybe
<
AnchorPosInfo
>
{
if
(
!
aAnchorPosResolutionCache
)
{
return
Nothing
{
}
;
}
return
AnchorPositioningUtils
:
:
ResolveAnchorPosRect
(
aKidFrame
aDelegatingFrame
nullptr
false
aAnchorPosResolutionCache
)
;
}
(
)
;
if
(
defaultAnchorInfo
)
{
containingBlock
=
aOriginalScrollableContainingBlockRect
;
}
if
(
isGrid
)
{
const
auto
border
=
aDelegatingFrame
-
>
GetUsedBorder
(
)
;
const
nsPoint
borderShift
{
border
.
left
border
.
top
}
;
containingBlock
=
nsGridContainerFrame
:
:
GridItemCB
(
aKidFrame
)
+
borderShift
;
if
(
!
defaultAnchorInfo
)
{
return
ContainingBlockRect
{
containingBlock
}
;
}
}
if
(
defaultAnchorInfo
)
{
auto
positionArea
=
aKidFrame
-
>
StylePosition
(
)
-
>
mPositionArea
;
if
(
!
positionArea
.
IsNone
(
)
)
{
const
auto
offset
=
AnchorPositioningUtils
:
:
GetScrollOffsetFor
(
aAnchorPosResolutionCache
-
>
mReferenceData
-
>
CompensatingForScrollAxes
(
)
aKidFrame
aAnchorPosResolutionCache
-
>
mDefaultAnchorCache
)
;
const
auto
scrolledAnchorRect
=
defaultAnchorInfo
-
>
mRect
-
offset
;
StylePositionArea
resolvedPositionArea
{
}
;
const
auto
scrolledAnchorCb
=
AnchorPositioningUtils
:
:
AdjustAbsoluteContainingBlockRectForPositionArea
(
scrolledAnchorRect
+
aOriginalContainingBlockRect
.
TopLeft
(
)
containingBlock
aKidFrame
-
>
GetWritingMode
(
)
aDelegatingFrame
-
>
GetWritingMode
(
)
positionArea
&
resolvedPositionArea
)
;
aAnchorPosResolutionCache
-
>
mReferenceData
-
>
mScrollCompensatedSides
=
GetScrollCompensatedSidesFor
(
resolvedPositionArea
)
;
return
ContainingBlockRect
{
offset
resolvedPositionArea
aOriginalScrollableContainingBlockRect
scrolledAnchorCb
+
offset
}
;
}
return
ContainingBlockRect
{
containingBlock
}
;
}
if
(
ViewportFrame
*
viewport
=
do_QueryFrame
(
aDelegatingFrame
)
)
{
if
(
!
IsSnapshotContainingBlock
(
aKidFrame
)
)
{
return
ContainingBlockRect
{
viewport
-
>
GetContainingBlockAdjustedForScrollbars
(
aReflowInput
)
}
;
}
return
ContainingBlockRect
{
dom
:
:
ViewTransition
:
:
SnapshotContainingBlockRect
(
viewport
-
>
PresContext
(
)
)
}
;
}
return
ContainingBlockRect
{
containingBlock
}
;
}
(
)
;
if
(
aAnchorPosResolutionCache
)
{
const
auto
&
originalCb
=
cb
.
mMaybeScrollableRect
;
aAnchorPosResolutionCache
-
>
mReferenceData
-
>
mOriginalContainingBlockRect
=
originalCb
;
aAnchorPosResolutionCache
-
>
mReferenceData
-
>
mAdjustedContainingBlock
=
cb
.
mFinalRect
;
}
const
WritingMode
outerWM
=
aReflowInput
.
GetWritingMode
(
)
;
const
WritingMode
wm
=
aKidFrame
-
>
GetWritingMode
(
)
;
const
LogicalSize
cbSize
(
outerWM
cb
.
mFinalRect
.
Size
(
)
)
;
ReflowInput
:
:
InitFlags
initFlags
;
const
bool
staticPosIsCBOrigin
=
[
&
]
{
if
(
aFlags
.
contains
(
AbsPosReflowFlag
:
:
IsGridContainerCB
)
)
{
nsIFrame
*
placeholder
=
aKidFrame
-
>
GetPlaceholderFrame
(
)
;
if
(
placeholder
&
&
placeholder
-
>
GetParent
(
)
=
=
aDelegatingFrame
)
{
return
true
;
}
}
if
(
aKidFrame
-
>
IsMenuPopupFrame
(
)
)
{
return
true
;
}
return
false
;
}
(
)
;
if
(
staticPosIsCBOrigin
)
{
initFlags
+
=
ReflowInput
:
:
InitFlag
:
:
StaticPosIsCBOrigin
;
}
const
bool
kidFrameMaySplit
=
aReflowInput
.
AvailableBSize
(
)
!
=
NS_UNCONSTRAINEDSIZE
&
&
aFlags
.
contains
(
AbsPosReflowFlag
:
:
AllowFragmentation
)
&
&
!
aDelegatingFrame
-
>
IsInlineFrame
(
)
&
&
!
aKidFrame
-
>
IsColumnSetWrapperFrame
(
)
&
&
(
aKidFrame
-
>
GetLogicalRect
(
cb
.
mFinalRect
.
Size
(
)
)
.
BStart
(
wm
)
<
=
aReflowInput
.
AvailableBSize
(
)
)
;
const
LogicalMargin
border
=
aDelegatingFrame
-
>
GetLogicalUsedBorder
(
outerWM
)
.
ApplySkipSides
(
aDelegatingFrame
-
>
PreReflowBlockLevelLogicalSkipSides
(
)
)
;
const
nsIFrame
*
kidPrevInFlow
=
aKidFrame
-
>
GetPrevInFlow
(
)
;
nscoord
availBSize
;
if
(
kidFrameMaySplit
)
{
availBSize
=
aReflowInput
.
AvailableBSize
(
)
;
if
(
!
kidPrevInFlow
)
{
availBSize
-
=
border
.
BStart
(
outerWM
)
;
}
}
else
{
availBSize
=
NS_UNCONSTRAINEDSIZE
;
}
const
LogicalSize
availSize
(
outerWM
cbSize
.
ISize
(
outerWM
)
availBSize
)
;
ReflowInput
kidReflowInput
(
aPresContext
aReflowInput
aKidFrame
availSize
.
ConvertTo
(
wm
outerWM
)
Some
(
cbSize
.
ConvertTo
(
wm
outerWM
)
)
initFlags
{
}
{
}
aAnchorPosResolutionCache
)
;
if
(
!
kidPrevInFlow
)
{
nscoord
kidAvailBSize
=
kidReflowInput
.
AvailableBSize
(
)
;
if
(
kidAvailBSize
!
=
NS_UNCONSTRAINEDSIZE
)
{
kidAvailBSize
-
=
kidReflowInput
.
ComputedLogicalMargin
(
wm
)
.
BStart
(
wm
)
;
const
nscoord
kidOffsetBStart
=
kidReflowInput
.
ComputedLogicalOffsets
(
wm
)
.
BStart
(
wm
)
;
if
(
kidOffsetBStart
!
=
NS_AUTOOFFSET
)
{
kidAvailBSize
-
=
kidOffsetBStart
;
}
kidReflowInput
.
SetAvailableBSize
(
kidAvailBSize
)
;
}
}
ReflowOutput
kidDesiredSize
(
kidReflowInput
)
;
aKidFrame
-
>
Reflow
(
aPresContext
kidDesiredSize
kidReflowInput
aStatus
)
;
nsMargin
insets
;
if
(
aKidFrame
-
>
IsMenuPopupFrame
(
)
)
{
}
else
if
(
kidPrevInFlow
)
{
const
nsSize
cbBorderBoxSize
=
(
cbSize
+
border
.
Size
(
outerWM
)
)
.
GetPhysicalSize
(
outerWM
)
;
const
LogicalPoint
kidPos
(
outerWM
kidPrevInFlow
-
>
IStart
(
outerWM
cbBorderBoxSize
)
0
)
;
const
LogicalSize
kidSize
=
kidDesiredSize
.
Size
(
outerWM
)
;
const
LogicalRect
kidRect
(
outerWM
kidPos
kidSize
)
;
aKidFrame
-
>
SetRect
(
outerWM
kidRect
cbBorderBoxSize
)
;
}
else
{
const
LogicalSize
kidSize
=
kidDesiredSize
.
Size
(
outerWM
)
;
LogicalMargin
offsets
=
kidReflowInput
.
ComputedLogicalOffsets
(
outerWM
)
;
LogicalMargin
margin
=
kidReflowInput
.
ComputedLogicalMargin
(
outerWM
)
;
if
(
kidReflowInput
.
mFlags
.
mIOffsetsNeedCSSAlign
)
{
margin
.
IStart
(
outerWM
)
=
margin
.
IEnd
(
outerWM
)
=
0
;
}
if
(
kidReflowInput
.
mFlags
.
mBOffsetsNeedCSSAlign
)
{
margin
.
BStart
(
outerWM
)
=
margin
.
BEnd
(
outerWM
)
=
0
;
}
ResolveSizeDependentOffsets
(
kidReflowInput
cbSize
kidSize
margin
cb
.
ResolvedPositionArea
(
)
offsets
)
;
ResolveAutoMarginsAfterLayout
(
kidReflowInput
cbSize
kidSize
margin
offsets
)
;
const
auto
*
stylePos
=
aKidFrame
-
>
StylePosition
(
)
;
const
auto
anchorResolutionParams
=
AnchorPosOffsetResolutionParams
:
:
ExplicitCBFrameSize
(
AnchorPosResolutionParams
:
:
From
(
aKidFrame
aAnchorPosResolutionCache
)
&
cbSize
)
;
const
bool
iStartInsetAuto
=
stylePos
-
>
GetAnchorResolvedInset
(
LogicalSide
:
:
IStart
outerWM
anchorResolutionParams
)
-
>
IsAuto
(
)
;
const
bool
iEndInsetAuto
=
stylePos
-
>
GetAnchorResolvedInset
(
LogicalSide
:
:
IEnd
outerWM
anchorResolutionParams
)
-
>
IsAuto
(
)
;
const
bool
iInsetAuto
=
iStartInsetAuto
|
|
iEndInsetAuto
;
const
bool
bStartInsetAuto
=
stylePos
-
>
GetAnchorResolvedInset
(
LogicalSide
:
:
BStart
outerWM
anchorResolutionParams
)
-
>
IsAuto
(
)
;
const
bool
bEndInsetAuto
=
stylePos
-
>
GetAnchorResolvedInset
(
LogicalSide
:
:
BEnd
outerWM
anchorResolutionParams
)
-
>
IsAuto
(
)
;
const
bool
bInsetAuto
=
bStartInsetAuto
|
|
bEndInsetAuto
;
const
LogicalSize
kidMarginBox
{
outerWM
margin
.
IStartEnd
(
outerWM
)
+
kidSize
.
ISize
(
outerWM
)
margin
.
BStartEnd
(
outerWM
)
+
kidSize
.
BSize
(
outerWM
)
}
;
const
auto
*
placeholderContainer
=
GetPlaceholderContainer
(
kidReflowInput
.
mFrame
)
;
insets
=
[
&
]
(
)
{
auto
result
=
offsets
;
if
(
iStartInsetAuto
&
&
!
iEndInsetAuto
)
{
result
.
IStart
(
outerWM
)
=
0
;
}
else
if
(
iInsetAuto
)
{
result
.
IEnd
(
outerWM
)
=
0
;
}
if
(
bStartInsetAuto
&
&
!
bEndInsetAuto
)
{
result
.
BStart
(
outerWM
)
=
0
;
}
else
if
(
bInsetAuto
)
{
result
.
BEnd
(
outerWM
)
=
0
;
}
return
result
.
GetPhysicalMargin
(
outerWM
)
;
}
(
)
;
if
(
aAnchorPosResolutionCache
)
{
aAnchorPosResolutionCache
-
>
mReferenceData
-
>
mInsets
=
insets
;
}
if
(
!
iInsetAuto
)
{
MOZ_ASSERT
(
!
kidReflowInput
.
mFlags
.
mIOffsetsNeedCSSAlign
"
Non
-
auto
inline
inset
but
requires
CSS
alignment
for
static
"
"
position
?
"
)
;
auto
alignOffset
=
OffsetToAlignedStaticPos
(
kidReflowInput
kidMarginBox
cbSize
placeholderContainer
outerWM
LogicalAxis
:
:
Inline
Some
(
NonAutoAlignParams
{
offsets
.
IStart
(
outerWM
)
offsets
.
IEnd
(
outerWM
)
}
)
cb
.
ResolvedPositionArea
(
)
)
;
offsets
.
IStart
(
outerWM
)
+
=
alignOffset
;
offsets
.
IEnd
(
outerWM
)
=
cbSize
.
ISize
(
outerWM
)
-
(
offsets
.
IStart
(
outerWM
)
+
kidMarginBox
.
ISize
(
outerWM
)
)
;
}
if
(
!
bInsetAuto
)
{
MOZ_ASSERT
(
!
kidReflowInput
.
mFlags
.
mBOffsetsNeedCSSAlign
"
Non
-
auto
block
inset
but
requires
CSS
alignment
for
static
"
"
position
?
"
)
;
auto
alignOffset
=
OffsetToAlignedStaticPos
(
kidReflowInput
kidMarginBox
cbSize
placeholderContainer
outerWM
LogicalAxis
:
:
Block
Some
(
NonAutoAlignParams
{
offsets
.
BStart
(
outerWM
)
offsets
.
BEnd
(
outerWM
)
}
)
cb
.
ResolvedPositionArea
(
)
)
;
offsets
.
BStart
(
outerWM
)
+
=
alignOffset
;
offsets
.
BEnd
(
outerWM
)
=
cbSize
.
BSize
(
outerWM
)
-
(
offsets
.
BStart
(
outerWM
)
+
kidMarginBox
.
BSize
(
outerWM
)
)
;
}
LogicalRect
rect
(
outerWM
offsets
.
StartOffset
(
outerWM
)
+
margin
.
StartOffset
(
outerWM
)
kidSize
)
;
nsRect
r
=
rect
.
GetPhysicalRect
(
outerWM
cbSize
.
GetPhysicalSize
(
outerWM
)
)
;
r
+
=
cb
.
mFinalRect
.
TopLeft
(
)
;
aKidFrame
-
>
SetRect
(
r
)
;
}
aKidFrame
-
>
DidReflow
(
aPresContext
&
kidReflowInput
)
;
[
&
]
(
)
{
if
(
!
aAnchorPosResolutionCache
)
{
return
;
}
auto
*
referenceData
=
aAnchorPosResolutionCache
-
>
mReferenceData
;
if
(
referenceData
-
>
CompensatingForScrollAxes
(
)
.
isEmpty
(
)
)
{
return
;
}
const
auto
offset
=
[
&
]
(
)
{
if
(
cb
.
mAnchorShiftInfo
)
{
return
cb
.
mAnchorShiftInfo
-
>
mOffset
;
}
return
AnchorPositioningUtils
:
:
GetScrollOffsetFor
(
referenceData
-
>
CompensatingForScrollAxes
(
)
aKidFrame
aAnchorPosResolutionCache
-
>
mDefaultAnchorCache
)
;
}
(
)
;
const
auto
position
=
aKidFrame
-
>
GetPosition
(
)
;
if
(
!
firstTryNormalPosition
)
{
firstTryNormalPosition
=
Some
(
position
)
;
}
aKidFrame
-
>
SetProperty
(
nsIFrame
:
:
NormalPositionProperty
(
)
position
)
;
if
(
offset
!
=
nsPoint
{
}
)
{
aKidFrame
-
>
SetPosition
(
position
-
offset
)
;
aKidFrame
-
>
UpdateOverflow
(
)
;
}
aAnchorPosResolutionCache
-
>
mReferenceData
-
>
mDefaultScrollShift
=
offset
;
}
(
)
;
const
auto
FitsInContainingBlock
=
[
&
]
(
)
{
if
(
aAnchorPosResolutionCache
)
{
return
AnchorPositioningUtils
:
:
FitsInContainingBlock
(
aKidFrame
*
aAnchorPosResolutionCache
-
>
mReferenceData
)
;
}
auto
imcbSize
=
cb
.
mFinalRect
.
Size
(
)
;
imcbSize
-
=
nsSize
{
insets
.
LeftRight
(
)
insets
.
TopBottom
(
)
}
;
return
aKidFrame
-
>
GetMarginRectRelativeToSelf
(
)
.
Size
(
)
<
=
imcbSize
;
}
;
const
auto
fits
=
aStatus
.
IsComplete
(
)
&
&
FitsInContainingBlock
(
)
;
if
(
fallbacks
.
IsEmpty
(
)
|
|
fits
)
{
isOverflowingCB
=
!
fits
;
fallback
.
CommitCurrentFallback
(
)
;
if
(
currentFallbackIndex
=
=
Nothing
(
)
)
{
aKidFrame
-
>
RemoveProperty
(
nsIFrame
:
:
LastSuccessfulPositionFallback
(
)
)
;
}
break
;
}
if
(
!
TryAdvanceFallback
(
)
)
{
break
;
}
aKidFrame
-
>
AddStateBits
(
NS_FRAME_IS_DIRTY
)
;
aStatus
.
Reset
(
)
;
}
while
(
true
)
;
[
&
]
(
)
{
if
(
!
isOverflowingCB
|
|
!
aAnchorPosResolutionCache
|
|
!
firstTryNormalPosition
)
{
return
;
}
currentFallbackIndex
=
firstTryIndex
;
currentFallbackStyle
=
firstTryStyle
;
const
auto
normalPosition
=
*
firstTryNormalPosition
;
const
auto
oldNormalPosition
=
aKidFrame
-
>
GetNormalPosition
(
)
;
if
(
normalPosition
!
=
oldNormalPosition
)
{
aKidFrame
-
>
SetProperty
(
nsIFrame
:
:
NormalPositionProperty
(
)
normalPosition
)
;
}
const
auto
position
=
normalPosition
-
aAnchorPosResolutionCache
-
>
mReferenceData
-
>
mDefaultScrollShift
;
const
auto
oldPosition
=
aKidFrame
-
>
GetPosition
(
)
;
if
(
position
=
=
oldPosition
)
{
return
;
}
aKidFrame
-
>
SetPosition
(
position
)
;
aKidFrame
-
>
UpdateOverflow
(
)
;
}
(
)
;
if
(
currentFallbackIndex
)
{
aKidFrame
-
>
SetOrUpdateDeletableProperty
(
nsIFrame
:
:
LastSuccessfulPositionFallback
(
)
LastSuccessfulPositionData
{
currentFallbackStyle
*
currentFallbackIndex
isOverflowingCB
}
)
;
}
#
ifdef
DEBUG
if
(
nsBlockFrame
:
:
gNoisyReflow
)
{
nsIFrame
:
:
IndentBy
(
stdout
nsBlockFrame
:
:
gNoiseIndent
-
1
)
;
fmt
:
:
println
(
FMT_STRING
(
"
abspos
{
}
:
rect
{
}
"
)
aKidFrame
-
>
ListTag
(
)
.
get
(
)
ToString
(
aKidFrame
-
>
GetRect
(
)
)
)
;
}
#
endif
if
(
!
aAnchorPosResolutionCache
)
{
aKidFrame
-
>
AddOrRemoveStateBits
(
NS_FRAME_POSITION_VISIBILITY_HIDDEN
isOverflowingCB
&
&
aKidFrame
-
>
StylePosition
(
)
-
>
mPositionVisibility
&
StylePositionVisibility
:
:
NO_OVERFLOW
)
;
}
if
(
aOverflowAreas
)
{
aOverflowAreas
-
>
UnionWith
(
aKidFrame
-
>
GetOverflowAreasRelativeToParent
(
)
)
;
}
}
