#
include
"
nsPageContentFrame
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsPageSequenceFrame
.
h
"
using
namespace
mozilla
;
nsPageContentFrame
*
NS_NewPageContentFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsPageContentFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsPageContentFrame
)
void
nsPageContentFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aReflowOutput
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsPageContentFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aReflowOutput
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
MOZ_ASSERT
(
mPD
"
Need
a
pointer
to
nsSharedPageData
before
reflow
starts
"
)
;
if
(
GetPrevInFlow
(
)
&
&
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
)
{
nsresult
rv
=
aPresContext
-
>
PresShell
(
)
-
>
FrameConstructor
(
)
-
>
ReplicateFixedFrames
(
this
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
}
nsSize
maxSize
(
aReflowInput
.
ComputedWidth
(
)
aReflowInput
.
ComputedHeight
(
)
)
;
SetSize
(
maxSize
)
;
if
(
mFrames
.
NotEmpty
(
)
)
{
nsIFrame
*
frame
=
mFrames
.
FirstChild
(
)
;
WritingMode
wm
=
frame
-
>
GetWritingMode
(
)
;
LogicalSize
logicalSize
(
wm
maxSize
)
;
ReflowInput
kidReflowInput
(
aPresContext
aReflowInput
frame
logicalSize
)
;
kidReflowInput
.
SetComputedBSize
(
logicalSize
.
BSize
(
wm
)
)
;
ReflowChild
(
frame
aPresContext
aReflowOutput
kidReflowInput
0
0
ReflowChildFlags
:
:
Default
aStatus
)
;
nsMargin
padding
(
0
0
0
0
)
;
kidReflowInput
.
mStylePadding
-
>
GetPadding
(
padding
)
;
if
(
frame
-
>
HasOverflowAreas
(
)
)
{
nscoord
xmost
=
aReflowOutput
.
ScrollableOverflow
(
)
.
XMost
(
)
;
if
(
xmost
>
aReflowOutput
.
Width
(
)
)
{
nscoord
widthToFit
=
xmost
+
padding
.
right
+
kidReflowInput
.
mStyleBorder
-
>
GetComputedBorderWidth
(
eSideRight
)
;
float
ratio
=
float
(
maxSize
.
width
)
/
widthToFit
;
NS_ASSERTION
(
ratio
>
=
0
.
0
&
&
ratio
<
1
.
0
"
invalid
shrink
-
to
-
fit
ratio
"
)
;
mPD
-
>
mShrinkToFitRatio
=
std
:
:
min
(
mPD
-
>
mShrinkToFitRatio
ratio
)
;
}
if
(
nsContentUtils
:
:
IsPDFJS
(
PresContext
(
)
-
>
Document
(
)
-
>
GetPrincipal
(
)
)
)
{
nscoord
ymost
=
aReflowOutput
.
ScrollableOverflow
(
)
.
YMost
(
)
;
if
(
ymost
>
aReflowOutput
.
Height
(
)
)
{
nscoord
heightToFit
=
ymost
+
padding
.
bottom
+
kidReflowInput
.
mStyleBorder
-
>
GetComputedBorderWidth
(
eSideBottom
)
;
float
ratio
=
float
(
maxSize
.
height
)
/
heightToFit
;
MOZ_ASSERT
(
ratio
>
=
0
.
0
&
&
ratio
<
1
.
0
)
;
mPD
-
>
mShrinkToFitRatio
=
std
:
:
min
(
mPD
-
>
mShrinkToFitRatio
ratio
)
;
}
}
}
FinishReflowChild
(
frame
aPresContext
aReflowOutput
&
kidReflowInput
0
0
ReflowChildFlags
:
:
Default
)
;
NS_ASSERTION
(
aPresContext
-
>
IsDynamic
(
)
|
|
!
aStatus
.
IsFullyComplete
(
)
|
|
!
frame
-
>
GetNextInFlow
(
)
"
bad
child
flow
list
"
)
;
}
nsReflowStatus
fixedStatus
;
ReflowAbsoluteFrames
(
aPresContext
aReflowOutput
aReflowInput
fixedStatus
)
;
NS_ASSERTION
(
fixedStatus
.
IsComplete
(
)
"
fixed
frames
can
be
truncated
but
not
incomplete
"
)
;
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
aReflowOutput
.
ISize
(
wm
)
=
aReflowInput
.
ComputedISize
(
)
;
if
(
aReflowInput
.
ComputedBSize
(
)
!
=
NS_UNCONSTRAINEDSIZE
)
{
aReflowOutput
.
BSize
(
wm
)
=
aReflowInput
.
ComputedBSize
(
)
;
}
FinishAndStoreOverflow
(
&
aReflowOutput
)
;
if
(
StaticPrefs
:
:
layout_display_list_improve_fragmentation
(
)
&
&
mFrames
.
NotEmpty
(
)
)
{
auto
*
previous
=
static_cast
<
nsPageContentFrame
*
>
(
GetPrevContinuation
(
)
)
;
const
nscoord
previousPageOverflow
=
previous
?
previous
-
>
mRemainingOverflow
:
0
;
const
nsSize
containerSize
(
aReflowInput
.
AvailableWidth
(
)
aReflowInput
.
AvailableHeight
(
)
)
;
const
nscoord
pageBSize
=
GetLogicalRect
(
containerSize
)
.
BSize
(
wm
)
;
const
nscoord
overflowBSize
=
LogicalRect
(
wm
ScrollableOverflowRect
(
)
GetSize
(
)
)
.
BEnd
(
wm
)
;
const
nscoord
currentPageOverflow
=
overflowBSize
-
pageBSize
;
nscoord
remainingOverflow
=
std
:
:
max
(
currentPageOverflow
previousPageOverflow
-
pageBSize
)
;
if
(
aStatus
.
IsFullyComplete
(
)
&
&
remainingOverflow
>
0
)
{
aStatus
.
SetOverflowIncomplete
(
)
;
}
mRemainingOverflow
=
std
:
:
max
(
remainingOverflow
0
)
;
}
NS_FRAME_SET_TRUNCATION
(
aStatus
aReflowInput
aReflowOutput
)
;
}
void
nsPageContentFrame
:
:
AppendDirectlyOwnedAnonBoxes
(
nsTArray
<
OwnedAnonBox
>
&
aResult
)
{
MOZ_ASSERT
(
mFrames
.
FirstChild
(
)
"
pageContentFrame
must
have
a
canvasFrame
child
"
)
;
aResult
.
AppendElement
(
mFrames
.
FirstChild
(
)
)
;
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
nsPageContentFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
u
"
PageContent
"
_ns
aResult
)
;
}
#
endif
