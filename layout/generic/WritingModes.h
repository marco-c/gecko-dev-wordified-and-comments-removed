#
ifndef
WritingModes_h_
#
define
WritingModes_h_
#
include
"
mozilla
/
ComputedStyle
.
h
"
#
include
"
mozilla
/
ComputedStyleInlines
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsBidiUtils
.
h
"
#
define
CHECK_WRITING_MODE
(
param
)
\
NS_ASSERTION
(
param
.
IgnoreSideways
(
)
=
=
GetWritingMode
(
)
.
IgnoreSideways
(
)
\
"
writing
-
mode
mismatch
"
)
namespace
mozilla
{
namespace
widget
{
struct
IMENotification
;
}
enum
PhysicalAxis
{
eAxisVertical
=
0x0
eAxisHorizontal
=
0x1
}
;
inline
LogicalAxis
GetOrthogonalAxis
(
LogicalAxis
aAxis
)
{
return
aAxis
=
=
eLogicalAxisBlock
?
eLogicalAxisInline
:
eLogicalAxisBlock
;
}
inline
bool
IsInline
(
LogicalSide
aSide
)
{
return
aSide
&
0x2
;
}
inline
bool
IsBlock
(
LogicalSide
aSide
)
{
return
!
IsInline
(
aSide
)
;
}
inline
bool
IsEnd
(
LogicalSide
aSide
)
{
return
aSide
&
0x1
;
}
inline
bool
IsStart
(
LogicalSide
aSide
)
{
return
!
IsEnd
(
aSide
)
;
}
inline
LogicalAxis
GetAxis
(
LogicalSide
aSide
)
{
return
IsInline
(
aSide
)
?
eLogicalAxisInline
:
eLogicalAxisBlock
;
}
inline
LogicalEdge
GetEdge
(
LogicalSide
aSide
)
{
return
IsEnd
(
aSide
)
?
eLogicalEdgeEnd
:
eLogicalEdgeStart
;
}
inline
LogicalEdge
GetOppositeEdge
(
LogicalEdge
aEdge
)
{
return
LogicalEdge
(
1
-
aEdge
)
;
}
inline
LogicalSide
MakeLogicalSide
(
LogicalAxis
aAxis
LogicalEdge
aEdge
)
{
return
LogicalSide
(
(
aAxis
<
<
1
)
|
aEdge
)
;
}
inline
LogicalSide
GetOppositeSide
(
LogicalSide
aSide
)
{
return
MakeLogicalSide
(
GetAxis
(
aSide
)
GetOppositeEdge
(
GetEdge
(
aSide
)
)
)
;
}
enum
LogicalSideBits
{
eLogicalSideBitsNone
=
0
eLogicalSideBitsBStart
=
1
<
<
eLogicalSideBStart
eLogicalSideBitsBEnd
=
1
<
<
eLogicalSideBEnd
eLogicalSideBitsIEnd
=
1
<
<
eLogicalSideIEnd
eLogicalSideBitsIStart
=
1
<
<
eLogicalSideIStart
eLogicalSideBitsBBoth
=
eLogicalSideBitsBStart
|
eLogicalSideBitsBEnd
eLogicalSideBitsIBoth
=
eLogicalSideBitsIStart
|
eLogicalSideBitsIEnd
eLogicalSideBitsAll
=
eLogicalSideBitsBBoth
|
eLogicalSideBitsIBoth
}
;
enum
LineRelativeDir
{
eLineRelativeDirOver
=
eLogicalSideBStart
eLineRelativeDirUnder
=
eLogicalSideBEnd
eLineRelativeDirLeft
=
eLogicalSideIStart
eLineRelativeDirRight
=
eLogicalSideIEnd
}
;
struct
LogicalSides
final
{
LogicalSides
(
)
:
mBits
(
0
)
{
}
explicit
LogicalSides
(
LogicalSideBits
aSideBits
)
{
MOZ_ASSERT
(
(
aSideBits
&
~
eLogicalSideBitsAll
)
=
=
0
"
illegal
side
bits
"
)
;
mBits
=
aSideBits
;
}
bool
IsEmpty
(
)
const
{
return
mBits
=
=
0
;
}
bool
BStart
(
)
const
{
return
mBits
&
eLogicalSideBitsBStart
;
}
bool
BEnd
(
)
const
{
return
mBits
&
eLogicalSideBitsBEnd
;
}
bool
IStart
(
)
const
{
return
mBits
&
eLogicalSideBitsIStart
;
}
bool
IEnd
(
)
const
{
return
mBits
&
eLogicalSideBitsIEnd
;
}
bool
Contains
(
LogicalSideBits
aSideBits
)
const
{
MOZ_ASSERT
(
(
aSideBits
&
~
eLogicalSideBitsAll
)
=
=
0
"
illegal
side
bits
"
)
;
return
(
mBits
&
aSideBits
)
=
=
aSideBits
;
}
LogicalSides
operator
|
(
LogicalSides
aOther
)
const
{
return
LogicalSides
(
LogicalSideBits
(
mBits
|
aOther
.
mBits
)
)
;
}
LogicalSides
operator
|
(
LogicalSideBits
aSideBits
)
const
{
return
*
this
|
LogicalSides
(
aSideBits
)
;
}
LogicalSides
&
operator
|
=
(
LogicalSides
aOther
)
{
mBits
|
=
aOther
.
mBits
;
return
*
this
;
}
LogicalSides
&
operator
|
=
(
LogicalSideBits
aSideBits
)
{
return
*
this
|
=
LogicalSides
(
aSideBits
)
;
}
bool
operator
=
=
(
LogicalSides
aOther
)
const
{
return
mBits
=
=
aOther
.
mBits
;
}
bool
operator
!
=
(
LogicalSides
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
private
:
uint8_t
mBits
;
}
;
class
WritingMode
{
public
:
enum
InlineDir
{
eInlineLTR
=
0x00
eInlineRTL
=
0x02
eInlineTTB
=
0x01
eInlineBTT
=
0x03
}
;
enum
BlockDir
{
eBlockTB
=
0x00
eBlockRL
=
0x01
eBlockLR
=
0x05
}
;
enum
BidiDir
{
eBidiLTR
=
0x00
eBidiRTL
=
0x10
}
;
enum
{
eUnknownWritingMode
=
0xff
}
;
InlineDir
GetInlineDir
(
)
const
{
return
InlineDir
(
mWritingMode
&
eInlineMask
)
;
}
BlockDir
GetBlockDir
(
)
const
{
return
BlockDir
(
mWritingMode
&
eBlockMask
)
;
}
BidiDir
GetBidiDir
(
)
const
{
return
BidiDir
(
mWritingMode
&
eBidiMask
)
;
}
bool
IsInlineReversed
(
)
const
{
return
!
!
(
mWritingMode
&
eInlineFlowMask
)
;
}
bool
IsBidiLTR
(
)
const
{
return
eBidiLTR
=
=
GetBidiDir
(
)
;
}
bool
IsVerticalLR
(
)
const
{
return
eBlockLR
=
=
GetBlockDir
(
)
;
}
bool
IsVerticalRL
(
)
const
{
return
eBlockRL
=
=
GetBlockDir
(
)
;
}
bool
IsVertical
(
)
const
{
return
!
!
(
mWritingMode
&
eOrientationMask
)
;
}
bool
IsLineInverted
(
)
const
{
return
!
!
(
mWritingMode
&
eLineOrientMask
)
;
}
int
FlowRelativeToLineRelativeFactor
(
)
const
{
return
IsLineInverted
(
)
?
-
1
:
1
;
}
bool
IsSideways
(
)
const
{
return
!
!
(
mWritingMode
&
eSidewaysMask
)
;
}
#
ifdef
DEBUG
WritingMode
IgnoreSideways
(
)
const
{
return
WritingMode
(
mWritingMode
&
~
eSidewaysMask
)
;
}
#
endif
bool
IsCentralBaseline
(
)
const
{
return
IsVertical
(
)
&
&
!
IsSideways
(
)
;
}
bool
IsAlphabeticalBaseline
(
)
const
{
return
!
IsCentralBaseline
(
)
;
}
static
mozilla
:
:
PhysicalAxis
PhysicalAxisForLogicalAxis
(
uint8_t
aWritingModeValue
LogicalAxis
aAxis
)
{
static_assert
(
NS_STYLE_WRITING_MODE_HORIZONTAL_TB
=
=
0
&
&
NS_STYLE_WRITING_MODE_VERTICAL_RL
=
=
1
&
&
NS_STYLE_WRITING_MODE_VERTICAL_LR
=
=
3
&
&
eLogicalAxisBlock
=
=
0
&
&
eLogicalAxisInline
=
=
1
&
&
eAxisVertical
=
=
0
&
&
eAxisHorizontal
=
=
1
"
unexpected
writing
-
mode
logical
axis
or
physical
axis
"
"
constant
values
"
)
;
return
mozilla
:
:
PhysicalAxis
(
(
aWritingModeValue
^
aAxis
)
&
0x1
)
;
}
mozilla
:
:
PhysicalAxis
PhysicalAxis
(
LogicalAxis
aAxis
)
const
{
int
wm
=
mWritingMode
&
eOrientationMask
;
return
PhysicalAxisForLogicalAxis
(
wm
aAxis
)
;
}
static
mozilla
:
:
Side
PhysicalSideForBlockAxis
(
uint8_t
aWritingModeValue
LogicalEdge
aEdge
)
{
static
const
mozilla
:
:
Side
kLogicalBlockSides
[
]
[
2
]
=
{
{
eSideTop
eSideBottom
}
{
eSideRight
eSideLeft
}
{
eSideBottom
eSideTop
}
{
eSideLeft
eSideRight
}
}
;
aWritingModeValue
&
=
~
NS_STYLE_WRITING_MODE_SIDEWAYS_MASK
;
NS_ASSERTION
(
aWritingModeValue
<
4
"
invalid
aWritingModeValue
value
"
)
;
return
kLogicalBlockSides
[
aWritingModeValue
]
[
aEdge
]
;
}
mozilla
:
:
Side
PhysicalSideForInlineAxis
(
LogicalEdge
aEdge
)
const
{
static
const
mozilla
:
:
Side
kLogicalInlineSides
[
]
[
2
]
=
{
{
eSideLeft
eSideRight
}
{
eSideTop
eSideBottom
}
{
eSideRight
eSideLeft
}
{
eSideBottom
eSideTop
}
{
eSideRight
eSideLeft
}
{
eSideTop
eSideBottom
}
{
eSideLeft
eSideRight
}
{
eSideBottom
eSideTop
}
{
eSideLeft
eSideRight
}
{
eSideTop
eSideBottom
}
{
eSideRight
eSideLeft
}
{
eSideBottom
eSideTop
}
{
eSideLeft
eSideRight
}
{
eSideTop
eSideBottom
}
{
eSideRight
eSideLeft
}
{
eSideBottom
eSideTop
}
}
;
static_assert
(
eOrientationMask
=
=
0x01
&
&
eInlineFlowMask
=
=
0x02
&
&
eBlockFlowMask
=
=
0x04
&
&
eLineOrientMask
=
=
0x08
"
unexpected
mask
values
"
)
;
int
index
=
mWritingMode
&
0x0F
;
return
kLogicalInlineSides
[
index
]
[
aEdge
]
;
}
mozilla
:
:
Side
PhysicalSide
(
LogicalSide
aSide
)
const
{
if
(
IsBlock
(
aSide
)
)
{
static_assert
(
eOrientationMask
=
=
0x01
&
&
eBlockFlowMask
=
=
0x04
"
unexpected
mask
values
"
)
;
int
wm
=
(
(
mWritingMode
&
eBlockFlowMask
)
>
>
1
)
|
(
mWritingMode
&
eOrientationMask
)
;
return
PhysicalSideForBlockAxis
(
wm
GetEdge
(
aSide
)
)
;
}
return
PhysicalSideForInlineAxis
(
GetEdge
(
aSide
)
)
;
}
LogicalSide
LogicalSideForPhysicalSide
(
mozilla
:
:
Side
aSide
)
const
{
static
const
LogicalSide
kPhysicalToLogicalSides
[
]
[
4
]
=
{
{
eLogicalSideBStart
eLogicalSideIEnd
eLogicalSideBEnd
eLogicalSideIStart
}
{
eLogicalSideIStart
eLogicalSideBStart
eLogicalSideIEnd
eLogicalSideBEnd
}
{
eLogicalSideBStart
eLogicalSideIStart
eLogicalSideBEnd
eLogicalSideIEnd
}
{
eLogicalSideIEnd
eLogicalSideBStart
eLogicalSideIStart
eLogicalSideBEnd
}
{
eLogicalSideBEnd
eLogicalSideIStart
eLogicalSideBStart
eLogicalSideIEnd
}
{
eLogicalSideIStart
eLogicalSideBEnd
eLogicalSideIEnd
eLogicalSideBStart
}
{
eLogicalSideBEnd
eLogicalSideIEnd
eLogicalSideBStart
eLogicalSideIStart
}
{
eLogicalSideIEnd
eLogicalSideBEnd
eLogicalSideIStart
eLogicalSideBStart
}
{
eLogicalSideBStart
eLogicalSideIEnd
eLogicalSideBEnd
eLogicalSideIStart
}
{
eLogicalSideIStart
eLogicalSideBStart
eLogicalSideIEnd
eLogicalSideBEnd
}
{
eLogicalSideBStart
eLogicalSideIStart
eLogicalSideBEnd
eLogicalSideIEnd
}
{
eLogicalSideIEnd
eLogicalSideBStart
eLogicalSideIStart
eLogicalSideBEnd
}
{
eLogicalSideBEnd
eLogicalSideIEnd
eLogicalSideBStart
eLogicalSideIStart
}
{
eLogicalSideIStart
eLogicalSideBEnd
eLogicalSideIEnd
eLogicalSideBStart
}
{
eLogicalSideBEnd
eLogicalSideIStart
eLogicalSideBStart
eLogicalSideIEnd
}
{
eLogicalSideIEnd
eLogicalSideBEnd
eLogicalSideIStart
eLogicalSideBStart
}
}
;
static_assert
(
eOrientationMask
=
=
0x01
&
&
eInlineFlowMask
=
=
0x02
&
&
eBlockFlowMask
=
=
0x04
&
&
eLineOrientMask
=
=
0x08
"
unexpected
mask
values
"
)
;
int
index
=
mWritingMode
&
0x0F
;
return
kPhysicalToLogicalSides
[
index
]
[
aSide
]
;
}
LogicalSide
LogicalSideForLineRelativeDir
(
LineRelativeDir
aDir
)
const
{
auto
side
=
static_cast
<
LogicalSide
>
(
aDir
)
;
if
(
IsInline
(
side
)
)
{
return
IsBidiLTR
(
)
?
side
:
GetOppositeSide
(
side
)
;
}
return
!
IsLineInverted
(
)
?
side
:
GetOppositeSide
(
side
)
;
}
WritingMode
(
)
:
mWritingMode
(
0
)
{
}
explicit
WritingMode
(
ComputedStyle
*
aComputedStyle
)
{
NS_ASSERTION
(
aComputedStyle
"
we
need
an
ComputedStyle
here
"
)
;
InitFromStyleVisibility
(
aComputedStyle
-
>
StyleVisibility
(
)
)
;
}
explicit
WritingMode
(
const
nsStyleVisibility
*
aStyleVisibility
)
{
NS_ASSERTION
(
aStyleVisibility
"
we
need
an
nsStyleVisibility
here
"
)
;
InitFromStyleVisibility
(
aStyleVisibility
)
;
}
private
:
void
InitFromStyleVisibility
(
const
nsStyleVisibility
*
aStyleVisibility
)
{
switch
(
aStyleVisibility
-
>
mWritingMode
)
{
case
NS_STYLE_WRITING_MODE_HORIZONTAL_TB
:
mWritingMode
=
0
;
break
;
case
NS_STYLE_WRITING_MODE_VERTICAL_LR
:
{
mWritingMode
=
eBlockFlowMask
|
eLineOrientMask
|
eOrientationMask
;
uint8_t
textOrientation
=
aStyleVisibility
-
>
mTextOrientation
;
if
(
textOrientation
=
=
NS_STYLE_TEXT_ORIENTATION_SIDEWAYS
)
{
mWritingMode
|
=
eSidewaysMask
;
}
break
;
}
case
NS_STYLE_WRITING_MODE_VERTICAL_RL
:
{
mWritingMode
=
eOrientationMask
;
uint8_t
textOrientation
=
aStyleVisibility
-
>
mTextOrientation
;
if
(
textOrientation
=
=
NS_STYLE_TEXT_ORIENTATION_SIDEWAYS
)
{
mWritingMode
|
=
eSidewaysMask
;
}
break
;
}
case
NS_STYLE_WRITING_MODE_SIDEWAYS_LR
:
mWritingMode
=
eBlockFlowMask
|
eInlineFlowMask
|
eOrientationMask
|
eSidewaysMask
;
break
;
case
NS_STYLE_WRITING_MODE_SIDEWAYS_RL
:
mWritingMode
=
eOrientationMask
|
eSidewaysMask
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unknown
writing
mode
!
"
)
;
mWritingMode
=
0
;
break
;
}
if
(
NS_STYLE_DIRECTION_RTL
=
=
aStyleVisibility
-
>
mDirection
)
{
mWritingMode
^
=
eInlineFlowMask
|
eBidiMask
;
}
}
public
:
void
SetDirectionFromBidiLevel
(
uint8_t
level
)
{
if
(
IS_LEVEL_RTL
(
level
)
=
=
IsBidiLTR
(
)
)
{
mWritingMode
^
=
eBidiMask
|
eInlineFlowMask
;
}
}
bool
operator
=
=
(
const
WritingMode
&
aOther
)
const
{
return
mWritingMode
=
=
aOther
.
mWritingMode
;
}
bool
operator
!
=
(
const
WritingMode
&
aOther
)
const
{
return
mWritingMode
!
=
aOther
.
mWritingMode
;
}
bool
IsOrthogonalTo
(
const
WritingMode
&
aOther
)
const
{
return
IsVertical
(
)
!
=
aOther
.
IsVertical
(
)
;
}
bool
ParallelAxisStartsOnSameSide
(
LogicalAxis
aLogicalAxis
const
WritingMode
&
aOther
)
const
{
mozilla
:
:
Side
myStartSide
=
this
-
>
PhysicalSide
(
MakeLogicalSide
(
aLogicalAxis
eLogicalEdgeStart
)
)
;
LogicalAxis
otherWMAxis
=
aOther
.
IsOrthogonalTo
(
*
this
)
?
GetOrthogonalAxis
(
aLogicalAxis
)
:
aLogicalAxis
;
mozilla
:
:
Side
otherWMStartSide
=
aOther
.
PhysicalSide
(
MakeLogicalSide
(
otherWMAxis
eLogicalEdgeStart
)
)
;
NS_ASSERTION
(
myStartSide
%
2
=
=
otherWMStartSide
%
2
"
Should
end
up
with
sides
in
the
same
physical
axis
"
)
;
return
myStartSide
=
=
otherWMStartSide
;
}
uint8_t
GetBits
(
)
const
{
return
mWritingMode
;
}
const
char
*
DebugString
(
)
const
{
return
IsVertical
(
)
?
IsVerticalLR
(
)
?
IsBidiLTR
(
)
?
IsSideways
(
)
?
"
sw
-
lr
-
ltr
"
:
"
v
-
lr
-
ltr
"
:
IsSideways
(
)
?
"
sw
-
lr
-
rtl
"
:
"
v
-
lr
-
rtl
"
:
IsBidiLTR
(
)
?
IsSideways
(
)
?
"
sw
-
rl
-
ltr
"
:
"
v
-
rl
-
ltr
"
:
IsSideways
(
)
?
"
sw
-
rl
-
rtl
"
:
"
v
-
rl
-
rtl
"
:
IsBidiLTR
(
)
?
"
h
-
ltr
"
:
"
h
-
rtl
"
;
}
private
:
friend
class
LogicalPoint
;
friend
class
LogicalSize
;
friend
class
LogicalMargin
;
friend
class
LogicalRect
;
friend
struct
IPC
:
:
ParamTraits
<
WritingMode
>
;
friend
struct
widget
:
:
IMENotification
;
static
inline
WritingMode
Unknown
(
)
{
return
WritingMode
(
eUnknownWritingMode
)
;
}
explicit
WritingMode
(
uint8_t
aValue
)
:
mWritingMode
(
aValue
)
{
}
uint8_t
mWritingMode
;
enum
Masks
{
eOrientationMask
=
0x01
eInlineFlowMask
=
0x02
eBlockFlowMask
=
0x04
eLineOrientMask
=
0x08
eBidiMask
=
0x10
eSidewaysMask
=
0x20
eInlineMask
=
0x03
eBlockMask
=
0x05
}
;
}
;
class
LogicalPoint
{
public
:
explicit
LogicalPoint
(
WritingMode
aWritingMode
)
:
#
ifdef
DEBUG
mWritingMode
(
aWritingMode
)
#
endif
mPoint
(
0
0
)
{
}
LogicalPoint
(
WritingMode
aWritingMode
nscoord
aI
nscoord
aB
)
:
#
ifdef
DEBUG
mWritingMode
(
aWritingMode
)
#
endif
mPoint
(
aI
aB
)
{
}
LogicalPoint
(
WritingMode
aWritingMode
const
nsPoint
&
aPoint
const
nsSize
&
aContainerSize
)
#
ifdef
DEBUG
:
mWritingMode
(
aWritingMode
)
#
endif
{
if
(
aWritingMode
.
IsVertical
(
)
)
{
I
(
)
=
aWritingMode
.
IsInlineReversed
(
)
?
aContainerSize
.
height
-
aPoint
.
y
:
aPoint
.
y
;
B
(
)
=
aWritingMode
.
IsVerticalLR
(
)
?
aPoint
.
x
:
aContainerSize
.
width
-
aPoint
.
x
;
}
else
{
I
(
)
=
aWritingMode
.
IsInlineReversed
(
)
?
aContainerSize
.
width
-
aPoint
.
x
:
aPoint
.
x
;
B
(
)
=
aPoint
.
y
;
}
}
nscoord
I
(
WritingMode
aWritingMode
)
const
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
mPoint
.
x
;
}
nscoord
B
(
WritingMode
aWritingMode
)
const
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
mPoint
.
y
;
}
nscoord
LineRelative
(
WritingMode
aWritingMode
const
nsSize
&
aContainerSize
)
const
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
if
(
aWritingMode
.
IsBidiLTR
(
)
)
{
return
I
(
)
;
}
return
(
aWritingMode
.
IsVertical
(
)
?
aContainerSize
.
height
:
aContainerSize
.
width
)
-
I
(
)
;
}
nscoord
&
I
(
WritingMode
aWritingMode
)
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
mPoint
.
x
;
}
nscoord
&
B
(
WritingMode
aWritingMode
)
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
mPoint
.
y
;
}
nsPoint
GetPhysicalPoint
(
WritingMode
aWritingMode
const
nsSize
&
aContainerSize
)
const
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
if
(
aWritingMode
.
IsVertical
(
)
)
{
return
nsPoint
(
aWritingMode
.
IsVerticalLR
(
)
?
B
(
)
:
aContainerSize
.
width
-
B
(
)
aWritingMode
.
IsInlineReversed
(
)
?
aContainerSize
.
height
-
I
(
)
:
I
(
)
)
;
}
else
{
return
nsPoint
(
aWritingMode
.
IsInlineReversed
(
)
?
aContainerSize
.
width
-
I
(
)
:
I
(
)
B
(
)
)
;
}
}
LogicalPoint
ConvertTo
(
WritingMode
aToMode
WritingMode
aFromMode
const
nsSize
&
aContainerSize
)
const
{
CHECK_WRITING_MODE
(
aFromMode
)
;
return
aToMode
=
=
aFromMode
?
*
this
:
LogicalPoint
(
aToMode
GetPhysicalPoint
(
aFromMode
aContainerSize
)
aContainerSize
)
;
}
bool
operator
=
=
(
const
LogicalPoint
&
aOther
)
const
{
CHECK_WRITING_MODE
(
aOther
.
GetWritingMode
(
)
)
;
return
mPoint
=
=
aOther
.
mPoint
;
}
bool
operator
!
=
(
const
LogicalPoint
&
aOther
)
const
{
CHECK_WRITING_MODE
(
aOther
.
GetWritingMode
(
)
)
;
return
mPoint
!
=
aOther
.
mPoint
;
}
LogicalPoint
operator
+
(
const
LogicalPoint
&
aOther
)
const
{
CHECK_WRITING_MODE
(
aOther
.
GetWritingMode
(
)
)
;
return
LogicalPoint
(
GetWritingMode
(
)
mPoint
.
x
+
aOther
.
mPoint
.
x
mPoint
.
y
+
aOther
.
mPoint
.
y
)
;
}
LogicalPoint
&
operator
+
=
(
const
LogicalPoint
&
aOther
)
{
CHECK_WRITING_MODE
(
aOther
.
GetWritingMode
(
)
)
;
I
(
)
+
=
aOther
.
I
(
)
;
B
(
)
+
=
aOther
.
B
(
)
;
return
*
this
;
}
LogicalPoint
operator
-
(
const
LogicalPoint
&
aOther
)
const
{
CHECK_WRITING_MODE
(
aOther
.
GetWritingMode
(
)
)
;
return
LogicalPoint
(
GetWritingMode
(
)
mPoint
.
x
-
aOther
.
mPoint
.
x
mPoint
.
y
-
aOther
.
mPoint
.
y
)
;
}
LogicalPoint
&
operator
-
=
(
const
LogicalPoint
&
aOther
)
{
CHECK_WRITING_MODE
(
aOther
.
GetWritingMode
(
)
)
;
I
(
)
-
=
aOther
.
I
(
)
;
B
(
)
-
=
aOther
.
B
(
)
;
return
*
this
;
}
private
:
friend
class
LogicalRect
;
#
ifdef
DEBUG
WritingMode
GetWritingMode
(
)
const
{
return
mWritingMode
;
}
#
else
WritingMode
GetWritingMode
(
)
const
{
return
WritingMode
:
:
Unknown
(
)
;
}
#
endif
LogicalPoint
(
)
=
delete
;
nscoord
I
(
)
const
{
return
mPoint
.
x
;
}
nscoord
B
(
)
const
{
return
mPoint
.
y
;
}
nscoord
&
I
(
)
{
return
mPoint
.
x
;
}
nscoord
&
B
(
)
{
return
mPoint
.
y
;
}
#
ifdef
DEBUG
WritingMode
mWritingMode
;
#
endif
nsPoint
mPoint
;
}
;
class
LogicalSize
{
public
:
explicit
LogicalSize
(
WritingMode
aWritingMode
)
:
#
ifdef
DEBUG
mWritingMode
(
aWritingMode
)
#
endif
mSize
(
0
0
)
{
}
LogicalSize
(
WritingMode
aWritingMode
nscoord
aISize
nscoord
aBSize
)
:
#
ifdef
DEBUG
mWritingMode
(
aWritingMode
)
#
endif
mSize
(
aISize
aBSize
)
{
}
LogicalSize
(
WritingMode
aWritingMode
const
nsSize
&
aPhysicalSize
)
#
ifdef
DEBUG
:
mWritingMode
(
aWritingMode
)
#
endif
{
if
(
aWritingMode
.
IsVertical
(
)
)
{
ISize
(
)
=
aPhysicalSize
.
height
;
BSize
(
)
=
aPhysicalSize
.
width
;
}
else
{
ISize
(
)
=
aPhysicalSize
.
width
;
BSize
(
)
=
aPhysicalSize
.
height
;
}
}
void
SizeTo
(
WritingMode
aWritingMode
nscoord
aISize
nscoord
aBSize
)
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
mSize
.
SizeTo
(
aISize
aBSize
)
;
}
nscoord
ISize
(
WritingMode
aWritingMode
)
const
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
mSize
.
width
;
}
nscoord
BSize
(
WritingMode
aWritingMode
)
const
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
mSize
.
height
;
}
nscoord
Size
(
LogicalAxis
aAxis
WritingMode
aWM
)
const
{
return
aAxis
=
=
eLogicalAxisInline
?
ISize
(
aWM
)
:
BSize
(
aWM
)
;
}
nscoord
Width
(
WritingMode
aWritingMode
)
const
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
aWritingMode
.
IsVertical
(
)
?
BSize
(
)
:
ISize
(
)
;
}
nscoord
Height
(
WritingMode
aWritingMode
)
const
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
aWritingMode
.
IsVertical
(
)
?
ISize
(
)
:
BSize
(
)
;
}
nscoord
&
ISize
(
WritingMode
aWritingMode
)
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
mSize
.
width
;
}
nscoord
&
BSize
(
WritingMode
aWritingMode
)
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
mSize
.
height
;
}
nscoord
&
Size
(
LogicalAxis
aAxis
WritingMode
aWM
)
{
return
aAxis
=
=
eLogicalAxisInline
?
ISize
(
aWM
)
:
BSize
(
aWM
)
;
}
nsSize
GetPhysicalSize
(
WritingMode
aWritingMode
)
const
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
aWritingMode
.
IsVertical
(
)
?
nsSize
(
BSize
(
)
ISize
(
)
)
:
nsSize
(
ISize
(
)
BSize
(
)
)
;
}
LogicalSize
ConvertTo
(
WritingMode
aToMode
WritingMode
aFromMode
)
const
{
#
ifdef
DEBUG
CHECK_WRITING_MODE
(
aFromMode
)
;
return
aToMode
=
=
aFromMode
?
*
this
:
LogicalSize
(
aToMode
GetPhysicalSize
(
aFromMode
)
)
;
#
else
return
(
aToMode
=
=
aFromMode
|
|
!
aToMode
.
IsOrthogonalTo
(
aFromMode
)
)
?
*
this
:
LogicalSize
(
aToMode
BSize
(
)
ISize
(
)
)
;
#
endif
}
bool
IsAllZero
(
)
const
{
return
ISize
(
)
=
=
0
&
&
BSize
(
)
=
=
0
;
}
bool
operator
=
=
(
const
LogicalSize
&
aOther
)
const
{
CHECK_WRITING_MODE
(
aOther
.
GetWritingMode
(
)
)
;
return
mSize
=
=
aOther
.
mSize
;
}
bool
operator
!
=
(
const
LogicalSize
&
aOther
)
const
{
CHECK_WRITING_MODE
(
aOther
.
GetWritingMode
(
)
)
;
return
mSize
!
=
aOther
.
mSize
;
}
LogicalSize
operator
+
(
const
LogicalSize
&
aOther
)
const
{
CHECK_WRITING_MODE
(
aOther
.
GetWritingMode
(
)
)
;
return
LogicalSize
(
GetWritingMode
(
)
ISize
(
)
+
aOther
.
ISize
(
)
BSize
(
)
+
aOther
.
BSize
(
)
)
;
}
LogicalSize
&
operator
+
=
(
const
LogicalSize
&
aOther
)
{
CHECK_WRITING_MODE
(
aOther
.
GetWritingMode
(
)
)
;
ISize
(
)
+
=
aOther
.
ISize
(
)
;
BSize
(
)
+
=
aOther
.
BSize
(
)
;
return
*
this
;
}
LogicalSize
operator
-
(
const
LogicalSize
&
aOther
)
const
{
CHECK_WRITING_MODE
(
aOther
.
GetWritingMode
(
)
)
;
return
LogicalSize
(
GetWritingMode
(
)
ISize
(
)
-
aOther
.
ISize
(
)
BSize
(
)
-
aOther
.
BSize
(
)
)
;
}
LogicalSize
&
operator
-
=
(
const
LogicalSize
&
aOther
)
{
CHECK_WRITING_MODE
(
aOther
.
GetWritingMode
(
)
)
;
ISize
(
)
-
=
aOther
.
ISize
(
)
;
BSize
(
)
-
=
aOther
.
BSize
(
)
;
return
*
this
;
}
private
:
friend
class
LogicalRect
;
LogicalSize
(
)
=
delete
;
#
ifdef
DEBUG
WritingMode
GetWritingMode
(
)
const
{
return
mWritingMode
;
}
#
else
WritingMode
GetWritingMode
(
)
const
{
return
WritingMode
:
:
Unknown
(
)
;
}
#
endif
nscoord
ISize
(
)
const
{
return
mSize
.
width
;
}
nscoord
BSize
(
)
const
{
return
mSize
.
height
;
}
nscoord
&
ISize
(
)
{
return
mSize
.
width
;
}
nscoord
&
BSize
(
)
{
return
mSize
.
height
;
}
#
ifdef
DEBUG
WritingMode
mWritingMode
;
#
endif
nsSize
mSize
;
}
;
class
LogicalMargin
{
public
:
explicit
LogicalMargin
(
WritingMode
aWritingMode
)
:
#
ifdef
DEBUG
mWritingMode
(
aWritingMode
)
#
endif
mMargin
(
0
0
0
0
)
{
}
LogicalMargin
(
WritingMode
aWritingMode
nscoord
aBStart
nscoord
aIEnd
nscoord
aBEnd
nscoord
aIStart
)
:
#
ifdef
DEBUG
mWritingMode
(
aWritingMode
)
#
endif
mMargin
(
aBStart
aIEnd
aBEnd
aIStart
)
{
}
LogicalMargin
(
WritingMode
aWritingMode
const
nsMargin
&
aPhysicalMargin
)
#
ifdef
DEBUG
:
mWritingMode
(
aWritingMode
)
#
endif
{
if
(
aWritingMode
.
IsVertical
(
)
)
{
if
(
aWritingMode
.
IsVerticalLR
(
)
)
{
mMargin
.
top
=
aPhysicalMargin
.
left
;
mMargin
.
bottom
=
aPhysicalMargin
.
right
;
}
else
{
mMargin
.
top
=
aPhysicalMargin
.
right
;
mMargin
.
bottom
=
aPhysicalMargin
.
left
;
}
if
(
aWritingMode
.
IsInlineReversed
(
)
)
{
mMargin
.
left
=
aPhysicalMargin
.
bottom
;
mMargin
.
right
=
aPhysicalMargin
.
top
;
}
else
{
mMargin
.
left
=
aPhysicalMargin
.
top
;
mMargin
.
right
=
aPhysicalMargin
.
bottom
;
}
}
else
{
mMargin
.
top
=
aPhysicalMargin
.
top
;
mMargin
.
bottom
=
aPhysicalMargin
.
bottom
;
if
(
aWritingMode
.
IsInlineReversed
(
)
)
{
mMargin
.
left
=
aPhysicalMargin
.
right
;
mMargin
.
right
=
aPhysicalMargin
.
left
;
}
else
{
mMargin
.
left
=
aPhysicalMargin
.
left
;
mMargin
.
right
=
aPhysicalMargin
.
right
;
}
}
}
nscoord
IStart
(
WritingMode
aWritingMode
)
const
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
mMargin
.
left
;
}
nscoord
IEnd
(
WritingMode
aWritingMode
)
const
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
mMargin
.
right
;
}
nscoord
BStart
(
WritingMode
aWritingMode
)
const
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
mMargin
.
top
;
}
nscoord
BEnd
(
WritingMode
aWritingMode
)
const
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
mMargin
.
bottom
;
}
nscoord
Start
(
LogicalAxis
aAxis
WritingMode
aWM
)
const
{
return
aAxis
=
=
eLogicalAxisInline
?
IStart
(
aWM
)
:
BStart
(
aWM
)
;
}
nscoord
End
(
LogicalAxis
aAxis
WritingMode
aWM
)
const
{
return
aAxis
=
=
eLogicalAxisInline
?
IEnd
(
aWM
)
:
BEnd
(
aWM
)
;
}
nscoord
&
IStart
(
WritingMode
aWritingMode
)
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
mMargin
.
left
;
}
nscoord
&
IEnd
(
WritingMode
aWritingMode
)
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
mMargin
.
right
;
}
nscoord
&
BStart
(
WritingMode
aWritingMode
)
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
mMargin
.
top
;
}
nscoord
&
BEnd
(
WritingMode
aWritingMode
)
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
mMargin
.
bottom
;
}
nscoord
&
Start
(
LogicalAxis
aAxis
WritingMode
aWM
)
{
return
aAxis
=
=
eLogicalAxisInline
?
IStart
(
aWM
)
:
BStart
(
aWM
)
;
}
nscoord
&
End
(
LogicalAxis
aAxis
WritingMode
aWM
)
{
return
aAxis
=
=
eLogicalAxisInline
?
IEnd
(
aWM
)
:
BEnd
(
aWM
)
;
}
nscoord
IStartEnd
(
WritingMode
aWritingMode
)
const
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
mMargin
.
LeftRight
(
)
;
}
nscoord
BStartEnd
(
WritingMode
aWritingMode
)
const
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
mMargin
.
TopBottom
(
)
;
}
nscoord
StartEnd
(
LogicalAxis
aAxis
WritingMode
aWM
)
const
{
return
aAxis
=
=
eLogicalAxisInline
?
IStartEnd
(
aWM
)
:
BStartEnd
(
aWM
)
;
}
nscoord
LineLeft
(
WritingMode
aWritingMode
)
const
{
return
aWritingMode
.
IsBidiLTR
(
)
?
IStart
(
aWritingMode
)
:
IEnd
(
aWritingMode
)
;
}
nscoord
LineRight
(
WritingMode
aWritingMode
)
const
{
return
aWritingMode
.
IsBidiLTR
(
)
?
IEnd
(
aWritingMode
)
:
IStart
(
aWritingMode
)
;
}
LogicalSize
Size
(
WritingMode
aWritingMode
)
const
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
LogicalSize
(
aWritingMode
IStartEnd
(
)
BStartEnd
(
)
)
;
}
nscoord
Top
(
WritingMode
aWritingMode
)
const
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
aWritingMode
.
IsVertical
(
)
?
(
aWritingMode
.
IsInlineReversed
(
)
?
IEnd
(
)
:
IStart
(
)
)
:
BStart
(
)
;
}
nscoord
Bottom
(
WritingMode
aWritingMode
)
const
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
aWritingMode
.
IsVertical
(
)
?
(
aWritingMode
.
IsInlineReversed
(
)
?
IStart
(
)
:
IEnd
(
)
)
:
BEnd
(
)
;
}
nscoord
Left
(
WritingMode
aWritingMode
)
const
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
aWritingMode
.
IsVertical
(
)
?
(
aWritingMode
.
IsVerticalLR
(
)
?
BStart
(
)
:
BEnd
(
)
)
:
(
aWritingMode
.
IsInlineReversed
(
)
?
IEnd
(
)
:
IStart
(
)
)
;
}
nscoord
Right
(
WritingMode
aWritingMode
)
const
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
aWritingMode
.
IsVertical
(
)
?
(
aWritingMode
.
IsVerticalLR
(
)
?
BEnd
(
)
:
BStart
(
)
)
:
(
aWritingMode
.
IsInlineReversed
(
)
?
IStart
(
)
:
IEnd
(
)
)
;
}
nscoord
LeftRight
(
WritingMode
aWritingMode
)
const
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
aWritingMode
.
IsVertical
(
)
?
BStartEnd
(
)
:
IStartEnd
(
)
;
}
nscoord
TopBottom
(
WritingMode
aWritingMode
)
const
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
aWritingMode
.
IsVertical
(
)
?
IStartEnd
(
)
:
BStartEnd
(
)
;
}
void
SizeTo
(
WritingMode
aWritingMode
nscoord
aBStart
nscoord
aIEnd
nscoord
aBEnd
nscoord
aIStart
)
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
mMargin
.
SizeTo
(
aBStart
aIEnd
aBEnd
aIStart
)
;
}
nsMargin
GetPhysicalMargin
(
WritingMode
aWritingMode
)
const
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
aWritingMode
.
IsVertical
(
)
?
(
aWritingMode
.
IsVerticalLR
(
)
?
(
aWritingMode
.
IsInlineReversed
(
)
?
nsMargin
(
IEnd
(
)
BEnd
(
)
IStart
(
)
BStart
(
)
)
:
nsMargin
(
IStart
(
)
BEnd
(
)
IEnd
(
)
BStart
(
)
)
)
:
(
aWritingMode
.
IsInlineReversed
(
)
?
nsMargin
(
IEnd
(
)
BStart
(
)
IStart
(
)
BEnd
(
)
)
:
nsMargin
(
IStart
(
)
BStart
(
)
IEnd
(
)
BEnd
(
)
)
)
)
:
(
aWritingMode
.
IsInlineReversed
(
)
?
nsMargin
(
BStart
(
)
IStart
(
)
BEnd
(
)
IEnd
(
)
)
:
nsMargin
(
BStart
(
)
IEnd
(
)
BEnd
(
)
IStart
(
)
)
)
;
}
LogicalMargin
ConvertTo
(
WritingMode
aToMode
WritingMode
aFromMode
)
const
{
CHECK_WRITING_MODE
(
aFromMode
)
;
return
aToMode
=
=
aFromMode
?
*
this
:
LogicalMargin
(
aToMode
GetPhysicalMargin
(
aFromMode
)
)
;
}
void
ApplySkipSides
(
LogicalSides
aSkipSides
)
{
if
(
aSkipSides
.
BStart
(
)
)
{
BStart
(
)
=
0
;
}
if
(
aSkipSides
.
BEnd
(
)
)
{
BEnd
(
)
=
0
;
}
if
(
aSkipSides
.
IStart
(
)
)
{
IStart
(
)
=
0
;
}
if
(
aSkipSides
.
IEnd
(
)
)
{
IEnd
(
)
=
0
;
}
}
bool
IsAllZero
(
)
const
{
return
(
mMargin
.
left
=
=
0
&
&
mMargin
.
top
=
=
0
&
&
mMargin
.
right
=
=
0
&
&
mMargin
.
bottom
=
=
0
)
;
}
LogicalMargin
operator
+
(
const
LogicalMargin
&
aMargin
)
const
{
CHECK_WRITING_MODE
(
aMargin
.
GetWritingMode
(
)
)
;
return
LogicalMargin
(
GetWritingMode
(
)
BStart
(
)
+
aMargin
.
BStart
(
)
IEnd
(
)
+
aMargin
.
IEnd
(
)
BEnd
(
)
+
aMargin
.
BEnd
(
)
IStart
(
)
+
aMargin
.
IStart
(
)
)
;
}
LogicalMargin
operator
+
=
(
const
LogicalMargin
&
aMargin
)
{
CHECK_WRITING_MODE
(
aMargin
.
GetWritingMode
(
)
)
;
mMargin
+
=
aMargin
.
mMargin
;
return
*
this
;
}
LogicalMargin
operator
-
(
const
LogicalMargin
&
aMargin
)
const
{
CHECK_WRITING_MODE
(
aMargin
.
GetWritingMode
(
)
)
;
return
LogicalMargin
(
GetWritingMode
(
)
BStart
(
)
-
aMargin
.
BStart
(
)
IEnd
(
)
-
aMargin
.
IEnd
(
)
BEnd
(
)
-
aMargin
.
BEnd
(
)
IStart
(
)
-
aMargin
.
IStart
(
)
)
;
}
private
:
friend
class
LogicalRect
;
LogicalMargin
(
)
=
delete
;
#
ifdef
DEBUG
WritingMode
GetWritingMode
(
)
const
{
return
mWritingMode
;
}
#
else
WritingMode
GetWritingMode
(
)
const
{
return
WritingMode
:
:
Unknown
(
)
;
}
#
endif
nscoord
IStart
(
)
const
{
return
mMargin
.
left
;
}
nscoord
IEnd
(
)
const
{
return
mMargin
.
right
;
}
nscoord
BStart
(
)
const
{
return
mMargin
.
top
;
}
nscoord
BEnd
(
)
const
{
return
mMargin
.
bottom
;
}
nscoord
&
IStart
(
)
{
return
mMargin
.
left
;
}
nscoord
&
IEnd
(
)
{
return
mMargin
.
right
;
}
nscoord
&
BStart
(
)
{
return
mMargin
.
top
;
}
nscoord
&
BEnd
(
)
{
return
mMargin
.
bottom
;
}
nscoord
IStartEnd
(
)
const
{
return
mMargin
.
LeftRight
(
)
;
}
nscoord
BStartEnd
(
)
const
{
return
mMargin
.
TopBottom
(
)
;
}
#
ifdef
DEBUG
WritingMode
mWritingMode
;
#
endif
nsMargin
mMargin
;
}
;
class
LogicalRect
{
public
:
explicit
LogicalRect
(
WritingMode
aWritingMode
)
:
#
ifdef
DEBUG
mWritingMode
(
aWritingMode
)
#
endif
mIStart
(
0
)
mBStart
(
0
)
mISize
(
0
)
mBSize
(
0
)
{
}
LogicalRect
(
WritingMode
aWritingMode
nscoord
aIStart
nscoord
aBStart
nscoord
aISize
nscoord
aBSize
)
:
#
ifdef
DEBUG
mWritingMode
(
aWritingMode
)
#
endif
mIStart
(
aIStart
)
mBStart
(
aBStart
)
mISize
(
aISize
)
mBSize
(
aBSize
)
{
}
LogicalRect
(
WritingMode
aWritingMode
const
LogicalPoint
&
aOrigin
const
LogicalSize
&
aSize
)
:
#
ifdef
DEBUG
mWritingMode
(
aWritingMode
)
#
endif
mIStart
(
aOrigin
.
mPoint
.
x
)
mBStart
(
aOrigin
.
mPoint
.
y
)
mISize
(
aSize
.
mSize
.
width
)
mBSize
(
aSize
.
mSize
.
height
)
{
CHECK_WRITING_MODE
(
aOrigin
.
GetWritingMode
(
)
)
;
CHECK_WRITING_MODE
(
aSize
.
GetWritingMode
(
)
)
;
}
LogicalRect
(
WritingMode
aWritingMode
const
nsRect
&
aRect
const
nsSize
&
aContainerSize
)
#
ifdef
DEBUG
:
mWritingMode
(
aWritingMode
)
#
endif
{
if
(
aWritingMode
.
IsVertical
(
)
)
{
mBStart
=
aWritingMode
.
IsVerticalLR
(
)
?
aRect
.
X
(
)
:
aContainerSize
.
width
-
aRect
.
XMost
(
)
;
mIStart
=
aWritingMode
.
IsInlineReversed
(
)
?
aContainerSize
.
height
-
aRect
.
YMost
(
)
:
aRect
.
Y
(
)
;
mBSize
=
aRect
.
Width
(
)
;
mISize
=
aRect
.
Height
(
)
;
}
else
{
mIStart
=
aWritingMode
.
IsInlineReversed
(
)
?
aContainerSize
.
width
-
aRect
.
XMost
(
)
:
aRect
.
X
(
)
;
mBStart
=
aRect
.
Y
(
)
;
mISize
=
aRect
.
Width
(
)
;
mBSize
=
aRect
.
Height
(
)
;
}
}
nscoord
IStart
(
WritingMode
aWritingMode
)
const
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
mIStart
;
}
nscoord
IEnd
(
WritingMode
aWritingMode
)
const
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
mIStart
+
mISize
;
}
nscoord
ISize
(
WritingMode
aWritingMode
)
const
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
mISize
;
}
nscoord
BStart
(
WritingMode
aWritingMode
)
const
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
mBStart
;
}
nscoord
BEnd
(
WritingMode
aWritingMode
)
const
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
mBStart
+
mBSize
;
}
nscoord
BSize
(
WritingMode
aWritingMode
)
const
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
mBSize
;
}
nscoord
&
IStart
(
WritingMode
aWritingMode
)
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
mIStart
;
}
nscoord
&
ISize
(
WritingMode
aWritingMode
)
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
mISize
;
}
nscoord
&
BStart
(
WritingMode
aWritingMode
)
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
mBStart
;
}
nscoord
&
BSize
(
WritingMode
aWritingMode
)
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
mBSize
;
}
nscoord
LineLeft
(
WritingMode
aWritingMode
const
nsSize
&
aContainerSize
)
const
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
if
(
aWritingMode
.
IsBidiLTR
(
)
)
{
return
IStart
(
)
;
}
nscoord
containerISize
=
aWritingMode
.
IsVertical
(
)
?
aContainerSize
.
height
:
aContainerSize
.
width
;
return
containerISize
-
IEnd
(
)
;
}
nscoord
LineRight
(
WritingMode
aWritingMode
const
nsSize
&
aContainerSize
)
const
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
if
(
aWritingMode
.
IsBidiLTR
(
)
)
{
return
IEnd
(
)
;
}
nscoord
containerISize
=
aWritingMode
.
IsVertical
(
)
?
aContainerSize
.
height
:
aContainerSize
.
width
;
return
containerISize
-
IStart
(
)
;
}
nscoord
X
(
WritingMode
aWritingMode
nscoord
aContainerWidth
)
const
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
if
(
aWritingMode
.
IsVertical
(
)
)
{
return
aWritingMode
.
IsVerticalLR
(
)
?
mBStart
:
aContainerWidth
-
BEnd
(
)
;
}
else
{
return
aWritingMode
.
IsInlineReversed
(
)
?
aContainerWidth
-
IEnd
(
)
:
mIStart
;
}
}
nscoord
Y
(
WritingMode
aWritingMode
nscoord
aContainerHeight
)
const
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
if
(
aWritingMode
.
IsVertical
(
)
)
{
return
aWritingMode
.
IsInlineReversed
(
)
?
aContainerHeight
-
IEnd
(
)
:
mIStart
;
}
else
{
return
mBStart
;
}
}
nscoord
Width
(
WritingMode
aWritingMode
)
const
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
aWritingMode
.
IsVertical
(
)
?
mBSize
:
mISize
;
}
nscoord
Height
(
WritingMode
aWritingMode
)
const
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
aWritingMode
.
IsVertical
(
)
?
mISize
:
mBSize
;
}
nscoord
XMost
(
WritingMode
aWritingMode
nscoord
aContainerWidth
)
const
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
if
(
aWritingMode
.
IsVertical
(
)
)
{
return
aWritingMode
.
IsVerticalLR
(
)
?
BEnd
(
)
:
aContainerWidth
-
mBStart
;
}
else
{
return
aWritingMode
.
IsInlineReversed
(
)
?
aContainerWidth
-
mIStart
:
IEnd
(
)
;
}
}
nscoord
YMost
(
WritingMode
aWritingMode
nscoord
aContainerHeight
)
const
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
if
(
aWritingMode
.
IsVertical
(
)
)
{
return
aWritingMode
.
IsInlineReversed
(
)
?
aContainerHeight
-
mIStart
:
IEnd
(
)
;
}
else
{
return
mBStart
;
}
}
bool
IsEmpty
(
)
const
{
return
mISize
<
=
0
|
|
mBSize
<
=
0
;
}
bool
IsAllZero
(
)
const
{
return
(
mIStart
=
=
0
&
&
mBStart
=
=
0
&
&
mISize
=
=
0
&
&
mBSize
=
=
0
)
;
}
bool
IsZeroSize
(
)
const
{
return
(
mISize
=
=
0
&
&
mBSize
=
=
0
)
;
}
void
SetEmpty
(
)
{
mISize
=
mBSize
=
0
;
}
bool
IsEqualEdges
(
const
LogicalRect
aOther
)
const
{
CHECK_WRITING_MODE
(
aOther
.
GetWritingMode
(
)
)
;
bool
result
=
mIStart
=
=
aOther
.
mIStart
&
&
mBStart
=
=
aOther
.
mBStart
&
&
mISize
=
=
aOther
.
mISize
&
&
mBSize
=
=
aOther
.
mBSize
;
MOZ_ASSERT
(
result
=
=
nsRect
(
mIStart
mBStart
mISize
mBSize
)
.
IsEqualEdges
(
nsRect
(
aOther
.
mIStart
aOther
.
mBStart
aOther
.
mISize
aOther
.
mBSize
)
)
)
;
return
result
;
}
LogicalPoint
Origin
(
WritingMode
aWritingMode
)
const
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
LogicalPoint
(
aWritingMode
IStart
(
)
BStart
(
)
)
;
}
void
SetOrigin
(
WritingMode
aWritingMode
const
LogicalPoint
&
aPoint
)
{
IStart
(
aWritingMode
)
=
aPoint
.
I
(
aWritingMode
)
;
BStart
(
aWritingMode
)
=
aPoint
.
B
(
aWritingMode
)
;
}
LogicalSize
Size
(
WritingMode
aWritingMode
)
const
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
return
LogicalSize
(
aWritingMode
ISize
(
)
BSize
(
)
)
;
}
LogicalRect
operator
+
(
const
LogicalPoint
&
aPoint
)
const
{
CHECK_WRITING_MODE
(
aPoint
.
GetWritingMode
(
)
)
;
return
LogicalRect
(
GetWritingMode
(
)
IStart
(
)
+
aPoint
.
I
(
)
BStart
(
)
+
aPoint
.
B
(
)
ISize
(
)
BSize
(
)
)
;
}
LogicalRect
&
operator
+
=
(
const
LogicalPoint
&
aPoint
)
{
CHECK_WRITING_MODE
(
aPoint
.
GetWritingMode
(
)
)
;
mIStart
+
=
aPoint
.
mPoint
.
x
;
mBStart
+
=
aPoint
.
mPoint
.
y
;
return
*
this
;
}
LogicalRect
operator
-
(
const
LogicalPoint
&
aPoint
)
const
{
CHECK_WRITING_MODE
(
aPoint
.
GetWritingMode
(
)
)
;
return
LogicalRect
(
GetWritingMode
(
)
IStart
(
)
-
aPoint
.
I
(
)
BStart
(
)
-
aPoint
.
B
(
)
ISize
(
)
BSize
(
)
)
;
}
LogicalRect
&
operator
-
=
(
const
LogicalPoint
&
aPoint
)
{
CHECK_WRITING_MODE
(
aPoint
.
GetWritingMode
(
)
)
;
mIStart
-
=
aPoint
.
mPoint
.
x
;
mBStart
-
=
aPoint
.
mPoint
.
y
;
return
*
this
;
}
void
MoveBy
(
WritingMode
aWritingMode
const
LogicalPoint
&
aDelta
)
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
CHECK_WRITING_MODE
(
aDelta
.
GetWritingMode
(
)
)
;
IStart
(
)
+
=
aDelta
.
I
(
)
;
BStart
(
)
+
=
aDelta
.
B
(
)
;
}
void
Inflate
(
nscoord
aD
)
{
#
ifdef
DEBUG
nsRect
rectDebug
(
mIStart
mBStart
mISize
mBSize
)
;
rectDebug
.
Inflate
(
aD
)
;
#
endif
mIStart
-
=
aD
;
mBStart
-
=
aD
;
mISize
+
=
2
*
aD
;
mBSize
+
=
2
*
aD
;
MOZ_ASSERT
(
rectDebug
.
IsEqualEdges
(
nsRect
(
mIStart
mBStart
mISize
mBSize
)
)
)
;
}
void
Inflate
(
nscoord
aDI
nscoord
aDB
)
{
#
ifdef
DEBUG
nsRect
rectDebug
(
mIStart
mBStart
mISize
mBSize
)
;
rectDebug
.
Inflate
(
aDI
aDB
)
;
#
endif
mIStart
-
=
aDI
;
mBStart
-
=
aDB
;
mISize
+
=
2
*
aDI
;
mBSize
+
=
2
*
aDB
;
MOZ_ASSERT
(
rectDebug
.
IsEqualEdges
(
nsRect
(
mIStart
mBStart
mISize
mBSize
)
)
)
;
}
void
Inflate
(
WritingMode
aWritingMode
const
LogicalMargin
&
aMargin
)
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
CHECK_WRITING_MODE
(
aMargin
.
GetWritingMode
(
)
)
;
#
ifdef
DEBUG
nsRect
rectDebug
(
mIStart
mBStart
mISize
mBSize
)
;
rectDebug
.
Inflate
(
aMargin
.
mMargin
)
;
#
endif
mIStart
-
=
aMargin
.
mMargin
.
left
;
mBStart
-
=
aMargin
.
mMargin
.
top
;
mISize
+
=
aMargin
.
mMargin
.
LeftRight
(
)
;
mBSize
+
=
aMargin
.
mMargin
.
TopBottom
(
)
;
MOZ_ASSERT
(
rectDebug
.
IsEqualEdges
(
nsRect
(
mIStart
mBStart
mISize
mBSize
)
)
)
;
}
void
Deflate
(
nscoord
aD
)
{
#
ifdef
DEBUG
nsRect
rectDebug
(
mIStart
mBStart
mISize
mBSize
)
;
rectDebug
.
Deflate
(
aD
)
;
#
endif
mIStart
+
=
aD
;
mBStart
+
=
aD
;
mISize
=
std
:
:
max
(
0
mISize
-
2
*
aD
)
;
mBSize
=
std
:
:
max
(
0
mBSize
-
2
*
aD
)
;
MOZ_ASSERT
(
rectDebug
.
IsEqualEdges
(
nsRect
(
mIStart
mBStart
mISize
mBSize
)
)
)
;
}
void
Deflate
(
nscoord
aDI
nscoord
aDB
)
{
#
ifdef
DEBUG
nsRect
rectDebug
(
mIStart
mBStart
mISize
mBSize
)
;
rectDebug
.
Deflate
(
aDI
aDB
)
;
#
endif
mIStart
+
=
aDI
;
mBStart
+
=
aDB
;
mISize
=
std
:
:
max
(
0
mISize
-
2
*
aDI
)
;
mBSize
=
std
:
:
max
(
0
mBSize
-
2
*
aDB
)
;
MOZ_ASSERT
(
rectDebug
.
IsEqualEdges
(
nsRect
(
mIStart
mBStart
mISize
mBSize
)
)
)
;
}
void
Deflate
(
WritingMode
aWritingMode
const
LogicalMargin
&
aMargin
)
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
CHECK_WRITING_MODE
(
aMargin
.
GetWritingMode
(
)
)
;
#
ifdef
DEBUG
nsRect
rectDebug
(
mIStart
mBStart
mISize
mBSize
)
;
rectDebug
.
Deflate
(
aMargin
.
mMargin
)
;
#
endif
mIStart
+
=
aMargin
.
mMargin
.
left
;
mBStart
+
=
aMargin
.
mMargin
.
top
;
mISize
=
std
:
:
max
(
0
mISize
-
aMargin
.
mMargin
.
LeftRight
(
)
)
;
mBSize
=
std
:
:
max
(
0
mBSize
-
aMargin
.
mMargin
.
TopBottom
(
)
)
;
MOZ_ASSERT
(
rectDebug
.
IsEqualEdges
(
nsRect
(
mIStart
mBStart
mISize
mBSize
)
)
)
;
}
nsRect
GetPhysicalRect
(
WritingMode
aWritingMode
const
nsSize
&
aContainerSize
)
const
{
CHECK_WRITING_MODE
(
aWritingMode
)
;
if
(
aWritingMode
.
IsVertical
(
)
)
{
return
nsRect
(
aWritingMode
.
IsVerticalLR
(
)
?
BStart
(
)
:
aContainerSize
.
width
-
BEnd
(
)
aWritingMode
.
IsInlineReversed
(
)
?
aContainerSize
.
height
-
IEnd
(
)
:
IStart
(
)
BSize
(
)
ISize
(
)
)
;
}
else
{
return
nsRect
(
aWritingMode
.
IsInlineReversed
(
)
?
aContainerSize
.
width
-
IEnd
(
)
:
IStart
(
)
BStart
(
)
ISize
(
)
BSize
(
)
)
;
}
}
LogicalRect
ConvertTo
(
WritingMode
aToMode
WritingMode
aFromMode
const
nsSize
&
aContainerSize
)
const
{
CHECK_WRITING_MODE
(
aFromMode
)
;
return
aToMode
=
=
aFromMode
?
*
this
:
LogicalRect
(
aToMode
GetPhysicalRect
(
aFromMode
aContainerSize
)
aContainerSize
)
;
}
bool
IntersectRect
(
const
LogicalRect
&
aRect1
const
LogicalRect
&
aRect2
)
{
CHECK_WRITING_MODE
(
aRect1
.
mWritingMode
)
;
CHECK_WRITING_MODE
(
aRect2
.
mWritingMode
)
;
#
ifdef
DEBUG
nsRect
rectDebug
;
rectDebug
.
IntersectRect
(
nsRect
(
aRect1
.
mIStart
aRect1
.
mBStart
aRect1
.
mISize
aRect1
.
mBSize
)
nsRect
(
aRect2
.
mIStart
aRect2
.
mBStart
aRect2
.
mISize
aRect2
.
mBSize
)
)
;
#
endif
nscoord
iEnd
=
std
:
:
min
(
aRect1
.
IEnd
(
)
aRect2
.
IEnd
(
)
)
;
mIStart
=
std
:
:
max
(
aRect1
.
mIStart
aRect2
.
mIStart
)
;
mISize
=
iEnd
-
mIStart
;
nscoord
bEnd
=
std
:
:
min
(
aRect1
.
BEnd
(
)
aRect2
.
BEnd
(
)
)
;
mBStart
=
std
:
:
max
(
aRect1
.
mBStart
aRect2
.
mBStart
)
;
mBSize
=
bEnd
-
mBStart
;
if
(
mISize
<
0
|
|
mBSize
<
0
)
{
mISize
=
0
;
mBSize
=
0
;
}
MOZ_ASSERT
(
(
rectDebug
.
IsEmpty
(
)
&
&
(
mISize
=
=
0
|
|
mBSize
=
=
0
)
)
|
|
rectDebug
.
IsEqualEdges
(
nsRect
(
mIStart
mBStart
mISize
mBSize
)
)
)
;
return
mISize
>
0
&
&
mBSize
>
0
;
}
private
:
LogicalRect
(
)
=
delete
;
#
ifdef
DEBUG
WritingMode
GetWritingMode
(
)
const
{
return
mWritingMode
;
}
#
else
WritingMode
GetWritingMode
(
)
const
{
return
WritingMode
:
:
Unknown
(
)
;
}
#
endif
nscoord
IStart
(
)
const
{
return
mIStart
;
}
nscoord
IEnd
(
)
const
{
return
mIStart
+
mISize
;
}
nscoord
ISize
(
)
const
{
return
mISize
;
}
nscoord
BStart
(
)
const
{
return
mBStart
;
}
nscoord
BEnd
(
)
const
{
return
mBStart
+
mBSize
;
}
nscoord
BSize
(
)
const
{
return
mBSize
;
}
nscoord
&
IStart
(
)
{
return
mIStart
;
}
nscoord
&
ISize
(
)
{
return
mISize
;
}
nscoord
&
BStart
(
)
{
return
mBStart
;
}
nscoord
&
BSize
(
)
{
return
mBSize
;
}
#
ifdef
DEBUG
WritingMode
mWritingMode
;
#
endif
nscoord
mIStart
;
nscoord
mBStart
;
nscoord
mISize
;
nscoord
mBSize
;
}
;
}
inline
nsStyleUnit
nsStyleSides
:
:
GetUnit
(
mozilla
:
:
WritingMode
aWM
mozilla
:
:
LogicalSide
aSide
)
const
{
return
GetUnit
(
aWM
.
PhysicalSide
(
aSide
)
)
;
}
inline
nsStyleUnit
nsStyleSides
:
:
GetIStartUnit
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
GetUnit
(
aWM
mozilla
:
:
eLogicalSideIStart
)
;
}
inline
nsStyleUnit
nsStyleSides
:
:
GetBStartUnit
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
GetUnit
(
aWM
mozilla
:
:
eLogicalSideBStart
)
;
}
inline
nsStyleUnit
nsStyleSides
:
:
GetIEndUnit
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
GetUnit
(
aWM
mozilla
:
:
eLogicalSideIEnd
)
;
}
inline
nsStyleUnit
nsStyleSides
:
:
GetBEndUnit
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
GetUnit
(
aWM
mozilla
:
:
eLogicalSideBEnd
)
;
}
inline
bool
nsStyleSides
:
:
HasBlockAxisAuto
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
GetBStartUnit
(
aWM
)
=
=
eStyleUnit_Auto
|
|
GetBEndUnit
(
aWM
)
=
=
eStyleUnit_Auto
;
}
inline
bool
nsStyleSides
:
:
HasInlineAxisAuto
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
GetIStartUnit
(
aWM
)
=
=
eStyleUnit_Auto
|
|
GetIEndUnit
(
aWM
)
=
=
eStyleUnit_Auto
;
}
inline
nsStyleCoord
nsStyleSides
:
:
Get
(
mozilla
:
:
WritingMode
aWM
mozilla
:
:
LogicalSide
aSide
)
const
{
return
Get
(
aWM
.
PhysicalSide
(
aSide
)
)
;
}
inline
nsStyleCoord
nsStyleSides
:
:
GetIStart
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
Get
(
aWM
mozilla
:
:
eLogicalSideIStart
)
;
}
inline
nsStyleCoord
nsStyleSides
:
:
GetBStart
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
Get
(
aWM
mozilla
:
:
eLogicalSideBStart
)
;
}
inline
nsStyleCoord
nsStyleSides
:
:
GetIEnd
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
Get
(
aWM
mozilla
:
:
eLogicalSideIEnd
)
;
}
inline
nsStyleCoord
nsStyleSides
:
:
GetBEnd
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
Get
(
aWM
mozilla
:
:
eLogicalSideBEnd
)
;
}
inline
nsStyleCoord
&
nsStylePosition
:
:
ISize
(
mozilla
:
:
WritingMode
aWM
)
{
return
aWM
.
IsVertical
(
)
?
mHeight
:
mWidth
;
}
inline
nsStyleCoord
&
nsStylePosition
:
:
MinISize
(
mozilla
:
:
WritingMode
aWM
)
{
return
aWM
.
IsVertical
(
)
?
mMinHeight
:
mMinWidth
;
}
inline
nsStyleCoord
&
nsStylePosition
:
:
MaxISize
(
mozilla
:
:
WritingMode
aWM
)
{
return
aWM
.
IsVertical
(
)
?
mMaxHeight
:
mMaxWidth
;
}
inline
nsStyleCoord
&
nsStylePosition
:
:
BSize
(
mozilla
:
:
WritingMode
aWM
)
{
return
aWM
.
IsVertical
(
)
?
mWidth
:
mHeight
;
}
inline
nsStyleCoord
&
nsStylePosition
:
:
MinBSize
(
mozilla
:
:
WritingMode
aWM
)
{
return
aWM
.
IsVertical
(
)
?
mMinWidth
:
mMinHeight
;
}
inline
nsStyleCoord
&
nsStylePosition
:
:
MaxBSize
(
mozilla
:
:
WritingMode
aWM
)
{
return
aWM
.
IsVertical
(
)
?
mMaxWidth
:
mMaxHeight
;
}
inline
const
nsStyleCoord
&
nsStylePosition
:
:
ISize
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
aWM
.
IsVertical
(
)
?
mHeight
:
mWidth
;
}
inline
const
nsStyleCoord
&
nsStylePosition
:
:
MinISize
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
aWM
.
IsVertical
(
)
?
mMinHeight
:
mMinWidth
;
}
inline
const
nsStyleCoord
&
nsStylePosition
:
:
MaxISize
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
aWM
.
IsVertical
(
)
?
mMaxHeight
:
mMaxWidth
;
}
inline
const
nsStyleCoord
&
nsStylePosition
:
:
BSize
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
aWM
.
IsVertical
(
)
?
mWidth
:
mHeight
;
}
inline
const
nsStyleCoord
&
nsStylePosition
:
:
MinBSize
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
aWM
.
IsVertical
(
)
?
mMinWidth
:
mMinHeight
;
}
inline
const
nsStyleCoord
&
nsStylePosition
:
:
MaxBSize
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
aWM
.
IsVertical
(
)
?
mMaxWidth
:
mMaxHeight
;
}
inline
bool
nsStylePosition
:
:
ISizeDependsOnContainer
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
aWM
.
IsVertical
(
)
?
HeightDependsOnContainer
(
)
:
WidthDependsOnContainer
(
)
;
}
inline
bool
nsStylePosition
:
:
MinISizeDependsOnContainer
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
aWM
.
IsVertical
(
)
?
MinHeightDependsOnContainer
(
)
:
MinWidthDependsOnContainer
(
)
;
}
inline
bool
nsStylePosition
:
:
MaxISizeDependsOnContainer
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
aWM
.
IsVertical
(
)
?
MaxHeightDependsOnContainer
(
)
:
MaxWidthDependsOnContainer
(
)
;
}
inline
bool
nsStylePosition
:
:
BSizeDependsOnContainer
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
aWM
.
IsVertical
(
)
?
WidthDependsOnContainer
(
)
:
HeightDependsOnContainer
(
)
;
}
inline
bool
nsStylePosition
:
:
MinBSizeDependsOnContainer
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
aWM
.
IsVertical
(
)
?
MinWidthDependsOnContainer
(
)
:
MinHeightDependsOnContainer
(
)
;
}
inline
bool
nsStylePosition
:
:
MaxBSizeDependsOnContainer
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
aWM
.
IsVertical
(
)
?
MaxWidthDependsOnContainer
(
)
:
MaxHeightDependsOnContainer
(
)
;
}
inline
mozilla
:
:
StyleClear
nsStyleDisplay
:
:
PhysicalBreakType
(
mozilla
:
:
WritingMode
aWM
)
const
{
using
StyleClear
=
mozilla
:
:
StyleClear
;
if
(
mBreakType
=
=
StyleClear
:
:
InlineStart
)
{
return
aWM
.
IsBidiLTR
(
)
?
StyleClear
:
:
Left
:
StyleClear
:
:
Right
;
}
if
(
mBreakType
=
=
StyleClear
:
:
InlineEnd
)
{
return
aWM
.
IsBidiLTR
(
)
?
StyleClear
:
:
Right
:
StyleClear
:
:
Left
;
}
return
mBreakType
;
}
inline
bool
nsStyleMargin
:
:
HasBlockAxisAuto
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
mMargin
.
HasBlockAxisAuto
(
aWM
)
;
}
inline
bool
nsStyleMargin
:
:
HasInlineAxisAuto
(
mozilla
:
:
WritingMode
aWM
)
const
{
return
mMargin
.
HasInlineAxisAuto
(
aWM
)
;
}
#
endif
