#
ifndef
nsAbsoluteContainingBlock_h___
#
define
nsAbsoluteContainingBlock_h___
#
include
"
mozilla
/
TypedEnumBits
.
h
"
#
include
"
nsFrameList
.
h
"
#
include
"
nsIFrame
.
h
"
class
nsContainerFrame
;
class
nsPresContext
;
class
nsAbsoluteContainingBlock
{
using
ReflowInput
=
mozilla
:
:
ReflowInput
;
public
:
explicit
nsAbsoluteContainingBlock
(
mozilla
:
:
FrameChildListID
aChildListID
)
#
ifdef
DEBUG
:
mChildListID
(
aChildListID
)
#
endif
{
MOZ_ASSERT
(
mChildListID
=
=
mozilla
:
:
FrameChildListID
:
:
Absolute
|
|
mChildListID
=
=
mozilla
:
:
FrameChildListID
:
:
Fixed
"
should
either
represent
position
:
fixed
or
absolute
content
"
)
;
}
const
nsFrameList
&
GetChildList
(
)
const
{
return
mAbsoluteFrames
;
}
void
AppendChildList
(
nsTArray
<
mozilla
:
:
FrameChildList
>
*
aLists
mozilla
:
:
FrameChildListID
aListID
)
const
{
NS_ASSERTION
(
aListID
=
=
mChildListID
"
wrong
list
ID
"
)
;
GetChildList
(
)
.
AppendIfNonempty
(
aLists
aListID
)
;
}
void
SetInitialChildList
(
nsIFrame
*
aDelegatingFrame
mozilla
:
:
FrameChildListID
aListID
nsFrameList
&
&
aChildList
)
;
void
AppendFrames
(
nsIFrame
*
aDelegatingFrame
mozilla
:
:
FrameChildListID
aListID
nsFrameList
&
&
aFrameList
)
;
void
InsertFrames
(
nsIFrame
*
aDelegatingFrame
mozilla
:
:
FrameChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
&
aFrameList
)
;
void
RemoveFrame
(
mozilla
:
:
FrameDestroyContext
&
mozilla
:
:
FrameChildListID
nsIFrame
*
)
;
enum
class
AbsPosReflowFlags
{
ConstrainHeight
=
0x1
CBWidthChanged
=
0x2
CBHeightChanged
=
0x4
CBWidthAndHeightChanged
=
CBWidthChanged
|
CBHeightChanged
IsGridContainerCB
=
0x8
}
;
void
Reflow
(
nsContainerFrame
*
aDelegatingFrame
nsPresContext
*
aPresContext
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aReflowStatus
const
nsRect
&
aContainingBlock
AbsPosReflowFlags
aFlags
mozilla
:
:
OverflowAreas
*
aOverflowAreas
)
;
using
DestroyContext
=
nsIFrame
:
:
DestroyContext
;
void
DestroyFrames
(
DestroyContext
&
)
;
bool
HasAbsoluteFrames
(
)
const
{
return
mAbsoluteFrames
.
NotEmpty
(
)
;
}
void
MarkSizeDependentFramesDirty
(
)
;
void
MarkAllFramesDirty
(
)
;
protected
:
bool
FrameDependsOnContainer
(
nsIFrame
*
aFrame
bool
aCBWidthChanged
bool
aCBHeightChanged
AnchorPosReferencedAnchors
*
aReferencedAnchors
=
nullptr
)
;
void
ResolveSizeDependentOffsets
(
nsPresContext
*
aPresContext
ReflowInput
&
aKidReflowInput
const
mozilla
:
:
LogicalSize
&
aKidSize
const
mozilla
:
:
LogicalMargin
&
aMargin
mozilla
:
:
LogicalMargin
*
aOffsets
mozilla
:
:
LogicalSize
*
aLogicalCBSize
)
;
void
ResolveAutoMarginsAfterLayout
(
ReflowInput
&
aKidReflowInput
const
mozilla
:
:
LogicalSize
*
aLogicalCBSize
const
mozilla
:
:
LogicalSize
&
aKidSize
mozilla
:
:
LogicalMargin
&
aMargin
mozilla
:
:
LogicalMargin
&
aOffsets
)
;
void
ReflowAbsoluteFrame
(
nsIFrame
*
aDelegatingFrame
nsPresContext
*
aPresContext
const
ReflowInput
&
aReflowInput
const
nsRect
&
aContainingBlockRect
AbsPosReflowFlags
aFlags
nsIFrame
*
aKidFrame
nsReflowStatus
&
aStatus
mozilla
:
:
OverflowAreas
*
aOverflowAreas
AnchorPosReferencedAnchors
*
aReferencedAnchors
=
nullptr
)
;
void
DoMarkFramesDirty
(
bool
aMarkAllDirty
)
;
protected
:
nsFrameList
mAbsoluteFrames
;
#
ifdef
DEBUG
mozilla
:
:
FrameChildListID
const
mChildListID
;
#
endif
}
;
namespace
mozilla
{
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
nsAbsoluteContainingBlock
:
:
AbsPosReflowFlags
)
}
#
endif
