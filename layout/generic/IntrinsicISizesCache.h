#
ifndef
mozilla_IntrinsicISizesCache_h
#
define
mozilla_IntrinsicISizesCache_h
#
include
"
nsIFrame
.
h
"
namespace
mozilla
{
struct
IntrinsicISizesCache
final
{
IntrinsicISizesCache
(
)
{
new
(
&
mInline
)
InlineCache
(
)
;
MOZ_ASSERT
(
IsInline
(
)
)
;
}
~
IntrinsicISizesCache
(
)
{
delete
GetOutOfLine
(
)
;
}
template
<
typename
Compute
>
nscoord
GetOrSet
(
nsIFrame
&
aFrame
IntrinsicISizeType
aType
const
IntrinsicSizeInput
&
aInput
Compute
aCompute
)
{
bool
dependentOnPercentBSize
=
aFrame
.
HasAnyStateBits
(
NS_FRAME_DESCENDANT_INTRINSIC_ISIZE_DEPENDS_ON_BSIZE
)
;
nscoord
value
=
Get
(
dependentOnPercentBSize
aType
aInput
)
;
if
(
value
!
=
kNotFound
)
{
return
value
;
}
value
=
aCompute
(
)
;
dependentOnPercentBSize
=
aFrame
.
HasAnyStateBits
(
NS_FRAME_DESCENDANT_INTRINSIC_ISIZE_DEPENDS_ON_BSIZE
)
;
Set
(
dependentOnPercentBSize
aType
aInput
value
)
;
return
value
;
}
void
Clear
(
)
{
if
(
auto
*
ool
=
GetOutOfLine
(
)
)
{
ool
-
>
mCacheWithPercentageBasis
.
Clear
(
)
;
ool
-
>
mCacheWithoutPercentageBasis
.
Clear
(
)
;
ool
-
>
mLastPercentageBasis
.
reset
(
)
;
}
else
{
mInline
.
Clear
(
)
;
}
}
private
:
static
constexpr
nscoord
kNotFound
=
nscoord_MAX
;
nscoord
Get
(
bool
aDependentOnPercentBSize
IntrinsicISizeType
aType
const
IntrinsicSizeInput
&
aInput
)
const
{
if
(
!
aDependentOnPercentBSize
|
|
!
aInput
.
HasSomePercentageBasisForChildren
(
)
)
{
if
(
auto
*
ool
=
GetOutOfLine
(
)
)
{
return
ool
-
>
mCacheWithoutPercentageBasis
.
Get
(
aType
)
;
}
return
mInline
.
Get
(
aType
)
;
}
if
(
auto
*
ool
=
GetOutOfLine
(
)
)
{
if
(
ool
-
>
mLastPercentageBasis
=
=
aInput
.
mPercentageBasisForChildren
)
{
return
ool
-
>
mCacheWithPercentageBasis
.
Get
(
aType
)
;
}
}
return
kNotFound
;
}
void
Set
(
bool
aDependentOnPercentBSize
IntrinsicISizeType
aType
const
IntrinsicSizeInput
&
aInput
nscoord
aValue
)
{
aValue
=
std
:
:
max
(
aValue
0
)
;
const
bool
usePercentAwareCache
=
aDependentOnPercentBSize
&
&
aInput
.
HasSomePercentageBasisForChildren
(
)
;
if
(
usePercentAwareCache
)
{
auto
*
ool
=
EnsureOutOfLine
(
)
;
ool
-
>
mLastPercentageBasis
=
aInput
.
mPercentageBasisForChildren
;
ool
-
>
mCacheWithPercentageBasis
.
Set
(
aType
aValue
)
;
}
else
if
(
auto
*
ool
=
GetOutOfLine
(
)
)
{
ool
-
>
mCacheWithoutPercentageBasis
.
Set
(
aType
aValue
)
;
}
else
{
mInline
.
Set
(
aType
aValue
)
;
MOZ_DIAGNOSTIC_ASSERT
(
IsInline
(
)
)
;
}
}
struct
InlineCache
{
nscoord
mCachedMinISize
=
kNotFound
;
nscoord
mCachedPrefISize
=
kNotFound
;
nscoord
Get
(
IntrinsicISizeType
aType
)
const
{
return
aType
=
=
IntrinsicISizeType
:
:
MinISize
?
mCachedMinISize
:
mCachedPrefISize
;
}
void
Set
(
IntrinsicISizeType
aType
nscoord
aValue
)
{
MOZ_ASSERT
(
aValue
>
=
0
)
;
if
(
aType
=
=
IntrinsicISizeType
:
:
MinISize
)
{
mCachedMinISize
=
aValue
;
}
else
{
mCachedPrefISize
=
aValue
;
}
}
void
Clear
(
)
{
*
this
=
{
}
;
}
}
;
struct
OutOfLineCache
{
InlineCache
mCacheWithoutPercentageBasis
;
InlineCache
mCacheWithPercentageBasis
;
Maybe
<
LogicalSize
>
mLastPercentageBasis
;
}
;
union
{
InlineCache
mInline
;
uintptr_t
mOutOfLine
=
0
;
}
;
static
constexpr
uintptr_t
kHighBit
=
uintptr_t
(
1
)
<
<
(
sizeof
(
void
*
)
*
CHAR_BIT
-
1
)
;
bool
IsOutOfLine
(
)
const
{
return
mOutOfLine
&
kHighBit
;
}
bool
IsInline
(
)
const
{
return
!
IsOutOfLine
(
)
;
}
OutOfLineCache
*
EnsureOutOfLine
(
)
{
if
(
auto
*
ool
=
GetOutOfLine
(
)
)
{
return
ool
;
}
auto
inlineCache
=
mInline
;
auto
*
ool
=
new
OutOfLineCache
(
)
;
ool
-
>
mCacheWithoutPercentageBasis
=
inlineCache
;
MOZ_ASSERT
(
(
reinterpret_cast
<
uintptr_t
>
(
ool
)
&
kHighBit
)
=
=
0
)
;
mOutOfLine
=
reinterpret_cast
<
uintptr_t
>
(
ool
)
|
kHighBit
;
return
ool
;
}
OutOfLineCache
*
GetOutOfLine
(
)
const
{
return
IsOutOfLine
(
)
?
reinterpret_cast
<
OutOfLineCache
*
>
(
mOutOfLine
&
~
kHighBit
)
:
nullptr
;
}
}
;
}
#
endif
