#
ifndef
FrameChildList_h_
#
define
FrameChildList_h_
#
include
"
mozilla
/
EnumSet
.
h
"
#
include
"
nsFrameList
.
h
"
#
include
"
nsTArray
.
h
"
class
nsIFrame
;
namespace
mozilla
{
namespace
layout
{
#
ifdef
DEBUG_FRAME_DUMP
extern
const
char
*
ChildListName
(
FrameChildListID
aListID
)
;
#
endif
using
FrameChildListIDs
=
EnumSet
<
FrameChildListID
>
;
class
FrameChildList
{
public
:
FrameChildList
(
const
nsFrameList
&
aList
FrameChildListID
aID
)
:
mList
(
aList
)
mID
(
aID
)
{
}
nsFrameList
mList
;
FrameChildListID
mID
;
}
;
class
MOZ_STACK_CLASS
FrameChildListArrayIterator
{
public
:
explicit
FrameChildListArrayIterator
(
const
nsTArray
<
FrameChildList
>
&
aLists
)
:
mLists
(
aLists
)
mCurrentIndex
(
0
)
{
}
bool
IsDone
(
)
const
{
return
mCurrentIndex
>
=
mLists
.
Length
(
)
;
}
FrameChildListID
CurrentID
(
)
const
{
NS_ASSERTION
(
!
IsDone
(
)
"
CurrentID
(
)
:
iterator
at
end
"
)
;
return
mLists
[
mCurrentIndex
]
.
mID
;
}
const
nsFrameList
&
CurrentList
(
)
const
{
NS_ASSERTION
(
!
IsDone
(
)
"
CurrentList
(
)
:
iterator
at
end
"
)
;
return
mLists
[
mCurrentIndex
]
.
mList
;
}
void
Next
(
)
{
NS_ASSERTION
(
!
IsDone
(
)
"
Next
(
)
:
iterator
at
end
"
)
;
+
+
mCurrentIndex
;
}
protected
:
const
nsTArray
<
FrameChildList
>
&
mLists
;
uint32_t
mCurrentIndex
;
}
;
class
MOZ_STACK_CLASS
FrameChildListIterator
:
public
FrameChildListArrayIterator
{
public
:
explicit
FrameChildListIterator
(
const
nsIFrame
*
aFrame
)
;
protected
:
AutoTArray
<
FrameChildList
4
>
mLists
;
}
;
}
}
inline
void
nsFrameList
:
:
AppendIfNonempty
(
nsTArray
<
mozilla
:
:
layout
:
:
FrameChildList
>
*
aLists
mozilla
:
:
layout
:
:
FrameChildListID
aListID
)
const
{
if
(
NotEmpty
(
)
)
{
aLists
-
>
AppendElement
(
mozilla
:
:
layout
:
:
FrameChildList
(
*
this
aListID
)
)
;
}
}
#
endif
