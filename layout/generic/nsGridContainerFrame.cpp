#
include
"
nsGridContainerFrame
.
h
"
#
include
<
algorithm
>
#
include
<
limits
>
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
nsAbsoluteContainingBlock
.
h
"
#
include
"
nsAlgorithm
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsCSSAnonBoxes
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsRenderingContext
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsRuleNode
.
h
"
#
include
"
nsStyleContext
.
h
"
using
namespace
mozilla
;
typedef
nsGridContainerFrame
:
:
TrackSize
TrackSize
;
const
uint32_t
nsGridContainerFrame
:
:
kTranslatedMaxLine
=
uint32_t
(
nsStyleGridLine
:
:
kMaxLine
-
nsStyleGridLine
:
:
kMinLine
-
1
)
;
const
uint32_t
nsGridContainerFrame
:
:
kAutoLine
=
kTranslatedMaxLine
+
3457U
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
TrackSize
:
:
StateBits
)
class
nsGridContainerFrame
:
:
GridItemCSSOrderIterator
{
public
:
enum
OrderState
{
eUnknownOrder
eKnownOrdered
eKnownUnordered
}
;
enum
ChildFilter
{
eSkipPlaceholders
eIncludeAll
}
;
GridItemCSSOrderIterator
(
nsIFrame
*
aGridContainer
nsIFrame
:
:
ChildListID
aListID
ChildFilter
aFilter
=
eSkipPlaceholders
OrderState
aState
=
eUnknownOrder
)
:
mChildren
(
aGridContainer
-
>
GetChildList
(
aListID
)
)
mArrayIndex
(
0
)
mGridItemIndex
(
0
)
mSkipPlaceholders
(
aFilter
=
=
eSkipPlaceholders
)
#
ifdef
DEBUG
mGridContainer
(
aGridContainer
)
mListID
(
aListID
)
#
endif
{
size_t
count
=
0
;
bool
isOrdered
=
aState
!
=
eKnownUnordered
;
if
(
aState
=
=
eUnknownOrder
)
{
auto
maxOrder
=
std
:
:
numeric_limits
<
int32_t
>
:
:
min
(
)
;
for
(
nsFrameList
:
:
Enumerator
e
(
mChildren
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
)
{
+
+
count
;
int32_t
order
=
e
.
get
(
)
-
>
StylePosition
(
)
-
>
mOrder
;
if
(
order
<
maxOrder
)
{
isOrdered
=
false
;
break
;
}
maxOrder
=
order
;
}
}
if
(
isOrdered
)
{
mEnumerator
.
emplace
(
mChildren
)
;
}
else
{
count
*
=
2
;
mArray
.
emplace
(
count
)
;
for
(
nsFrameList
:
:
Enumerator
e
(
mChildren
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
)
{
mArray
-
>
AppendElement
(
e
.
get
(
)
)
;
}
std
:
:
stable_sort
(
mArray
-
>
begin
(
)
mArray
-
>
end
(
)
IsCSSOrderLessThan
)
;
}
if
(
mSkipPlaceholders
)
{
SkipPlaceholders
(
)
;
}
}
nsIFrame
*
operator
*
(
)
const
{
MOZ_ASSERT
(
!
AtEnd
(
)
)
;
if
(
mEnumerator
)
{
return
mEnumerator
-
>
get
(
)
;
}
return
(
*
mArray
)
[
mArrayIndex
]
;
}
size_t
GridItemIndex
(
)
const
{
MOZ_ASSERT
(
!
AtEnd
(
)
)
;
MOZ_ASSERT
(
(
*
*
this
)
-
>
GetType
(
)
!
=
nsGkAtoms
:
:
placeholderFrame
"
MUST
not
call
this
when
at
a
placeholder
"
)
;
return
mGridItemIndex
;
}
void
SkipPlaceholders
(
)
{
if
(
mEnumerator
)
{
for
(
;
!
mEnumerator
-
>
AtEnd
(
)
;
mEnumerator
-
>
Next
(
)
)
{
nsIFrame
*
child
=
mEnumerator
-
>
get
(
)
;
if
(
child
-
>
GetType
(
)
!
=
nsGkAtoms
:
:
placeholderFrame
)
{
return
;
}
}
}
else
{
for
(
;
mArrayIndex
<
mArray
-
>
Length
(
)
;
+
+
mArrayIndex
)
{
nsIFrame
*
child
=
(
*
mArray
)
[
mArrayIndex
]
;
if
(
child
-
>
GetType
(
)
!
=
nsGkAtoms
:
:
placeholderFrame
)
{
return
;
}
}
}
}
bool
AtEnd
(
)
const
{
MOZ_ASSERT
(
mEnumerator
|
|
mArrayIndex
<
=
mArray
-
>
Length
(
)
)
;
return
mEnumerator
?
mEnumerator
-
>
AtEnd
(
)
:
mArrayIndex
>
=
mArray
-
>
Length
(
)
;
}
void
Next
(
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
!
AtEnd
(
)
)
;
nsFrameList
list
=
mGridContainer
-
>
GetChildList
(
mListID
)
;
MOZ_ASSERT
(
list
.
FirstChild
(
)
=
=
mChildren
.
FirstChild
(
)
&
&
list
.
LastChild
(
)
=
=
mChildren
.
LastChild
(
)
"
the
list
of
child
frames
must
not
change
while
iterating
!
"
)
;
#
endif
if
(
mSkipPlaceholders
|
|
(
*
*
this
)
-
>
GetType
(
)
!
=
nsGkAtoms
:
:
placeholderFrame
)
{
+
+
mGridItemIndex
;
}
if
(
mEnumerator
)
{
mEnumerator
-
>
Next
(
)
;
}
else
{
+
+
mArrayIndex
;
}
if
(
mSkipPlaceholders
)
{
SkipPlaceholders
(
)
;
}
}
void
Reset
(
ChildFilter
aFilter
=
eSkipPlaceholders
)
{
if
(
mEnumerator
)
{
mEnumerator
.
reset
(
)
;
mEnumerator
.
emplace
(
mChildren
)
;
}
else
{
mArrayIndex
=
0
;
}
mGridItemIndex
=
0
;
mSkipPlaceholders
=
aFilter
=
=
eSkipPlaceholders
;
if
(
mSkipPlaceholders
)
{
SkipPlaceholders
(
)
;
}
}
bool
ItemsAreAlreadyInOrder
(
)
const
{
return
mEnumerator
.
isSome
(
)
;
}
private
:
static
bool
IsCSSOrderLessThan
(
nsIFrame
*
const
&
a
nsIFrame
*
const
&
b
)
{
return
a
-
>
StylePosition
(
)
-
>
mOrder
<
b
-
>
StylePosition
(
)
-
>
mOrder
;
}
nsFrameList
mChildren
;
Maybe
<
nsFrameList
:
:
Enumerator
>
mEnumerator
;
Maybe
<
nsTArray
<
nsIFrame
*
>
>
mArray
;
size_t
mArrayIndex
;
size_t
mGridItemIndex
;
bool
mSkipPlaceholders
;
#
ifdef
DEBUG
nsIFrame
*
mGridContainer
;
nsIFrame
:
:
ChildListID
mListID
;
#
endif
}
;
struct
MOZ_STACK_CLASS
nsGridContainerFrame
:
:
TrackSizingFunctions
{
const
nsStyleCoord
&
MinSizingFor
(
uint32_t
aTrackIndex
)
const
{
if
(
MOZ_UNLIKELY
(
aTrackIndex
<
mExplicitGridOffset
)
)
{
return
mAutoMinSizing
;
}
uint32_t
index
=
aTrackIndex
-
mExplicitGridOffset
;
return
index
<
mMinSizingFunctions
.
Length
(
)
?
mMinSizingFunctions
[
index
]
:
mAutoMinSizing
;
}
const
nsStyleCoord
&
MaxSizingFor
(
uint32_t
aTrackIndex
)
const
{
if
(
MOZ_UNLIKELY
(
aTrackIndex
<
mExplicitGridOffset
)
)
{
return
mAutoMaxSizing
;
}
uint32_t
index
=
aTrackIndex
-
mExplicitGridOffset
;
return
index
<
mMaxSizingFunctions
.
Length
(
)
?
mMaxSizingFunctions
[
index
]
:
mAutoMaxSizing
;
}
const
nsTArray
<
nsStyleCoord
>
&
mMinSizingFunctions
;
const
nsTArray
<
nsStyleCoord
>
&
mMaxSizingFunctions
;
const
nsStyleCoord
&
mAutoMinSizing
;
const
nsStyleCoord
&
mAutoMaxSizing
;
uint32_t
mExplicitGridOffset
;
}
;
struct
MOZ_STACK_CLASS
nsGridContainerFrame
:
:
Tracks
{
explicit
Tracks
(
Dimension
aDimension
)
:
mDimension
(
aDimension
)
{
}
void
Initialize
(
const
TrackSizingFunctions
&
aFunctions
nscoord
aPercentageBasis
)
;
bool
HasIntrinsicButNoFlexSizingInRange
(
const
LineRange
&
aRange
IntrinsicISizeType
aConstraint
TrackSize
:
:
StateBits
*
aState
)
const
;
void
ResolveIntrinsicSize
(
GridReflowState
&
aState
nsTArray
<
GridItemInfo
>
&
aGridItems
const
TrackSizingFunctions
&
aFunctions
LineRange
GridArea
:
:
*
aRange
nscoord
aPercentageBasis
IntrinsicISizeType
aConstraint
)
;
bool
ResolveIntrinsicSizeStep1
(
GridReflowState
&
aState
const
TrackSizingFunctions
&
aFunctions
nscoord
aPercentageBasis
IntrinsicISizeType
aConstraint
const
LineRange
&
aRange
nsIFrame
*
aGridItem
)
;
static
nscoord
CollectGrowable
(
nscoord
aAvailableSpace
const
nsTArray
<
TrackSize
>
&
aPlan
const
LineRange
&
aRange
TrackSize
:
:
StateBits
aSelector
nsTArray
<
uint32_t
>
&
aGrowableTracks
)
{
MOZ_ASSERT
(
aAvailableSpace
>
0
"
why
call
me
?
"
)
;
nscoord
space
=
aAvailableSpace
;
const
uint32_t
start
=
aRange
.
mStart
;
const
uint32_t
end
=
aRange
.
mEnd
;
for
(
uint32_t
i
=
start
;
i
<
end
;
+
+
i
)
{
const
TrackSize
&
sz
=
aPlan
[
i
]
;
MOZ_ASSERT
(
!
sz
.
IsFrozen
(
)
)
;
space
-
=
sz
.
mBase
;
if
(
space
<
=
0
)
{
return
0
;
}
if
(
sz
.
mState
&
aSelector
)
{
aGrowableTracks
.
AppendElement
(
i
)
;
}
}
return
space
;
}
void
SetupGrowthPlan
(
nsTArray
<
TrackSize
>
&
aPlan
const
nsTArray
<
uint32_t
>
&
aTracks
)
const
{
for
(
uint32_t
track
:
aTracks
)
{
aPlan
[
track
]
=
mSizes
[
track
]
;
}
}
void
CopyPlanToBase
(
const
nsTArray
<
TrackSize
>
&
aPlan
const
nsTArray
<
uint32_t
>
&
aTracks
)
{
for
(
uint32_t
track
:
aTracks
)
{
MOZ_ASSERT
(
mSizes
[
track
]
.
mBase
<
=
aPlan
[
track
]
.
mBase
)
;
mSizes
[
track
]
.
mBase
=
aPlan
[
track
]
.
mBase
;
}
}
void
CopyPlanToLimit
(
const
nsTArray
<
TrackSize
>
&
aPlan
const
nsTArray
<
uint32_t
>
&
aTracks
)
{
for
(
uint32_t
track
:
aTracks
)
{
MOZ_ASSERT
(
mSizes
[
track
]
.
mLimit
=
=
NS_UNCONSTRAINEDSIZE
|
|
mSizes
[
track
]
.
mLimit
<
=
aPlan
[
track
]
.
mBase
)
;
mSizes
[
track
]
.
mLimit
=
aPlan
[
track
]
.
mBase
;
}
}
nscoord
GrowTracksToLimit
(
nscoord
aAvailableSpace
nsTArray
<
TrackSize
>
&
aPlan
const
nsTArray
<
uint32_t
>
&
aGrowableTracks
)
const
{
MOZ_ASSERT
(
aAvailableSpace
>
0
&
&
aGrowableTracks
.
Length
(
)
>
0
)
;
nscoord
space
=
aAvailableSpace
;
uint32_t
numGrowable
=
aGrowableTracks
.
Length
(
)
;
while
(
true
)
{
nscoord
spacePerTrack
=
std
:
:
max
<
nscoord
>
(
space
/
numGrowable
1
)
;
for
(
uint32_t
track
:
aGrowableTracks
)
{
TrackSize
&
sz
=
aPlan
[
track
]
;
if
(
sz
.
IsFrozen
(
)
)
{
continue
;
}
nscoord
newBase
=
sz
.
mBase
+
spacePerTrack
;
if
(
newBase
>
sz
.
mLimit
)
{
nscoord
consumed
=
sz
.
mLimit
-
sz
.
mBase
;
if
(
consumed
>
0
)
{
space
-
=
consumed
;
sz
.
mBase
=
sz
.
mLimit
;
}
sz
.
mState
|
=
TrackSize
:
:
eFrozen
;
if
(
-
-
numGrowable
=
=
0
)
{
return
space
;
}
}
else
{
sz
.
mBase
=
newBase
;
space
-
=
spacePerTrack
;
}
MOZ_ASSERT
(
space
>
=
0
)
;
if
(
space
=
=
0
)
{
return
0
;
}
}
}
MOZ_ASSERT_UNREACHABLE
(
"
we
don
'
t
exit
the
loop
above
except
by
return
"
)
;
return
0
;
}
uint32_t
MarkExcludedTracks
(
nsTArray
<
TrackSize
>
&
aPlan
uint32_t
aNumGrowable
const
nsTArray
<
uint32_t
>
&
aGrowableTracks
TrackSize
:
:
StateBits
aMinSizingSelector
TrackSize
:
:
StateBits
aMaxSizingSelector
TrackSize
:
:
StateBits
aSkipFlag
)
const
{
bool
foundOneSelected
=
false
;
bool
foundOneGrowable
=
false
;
uint32_t
numGrowable
=
aNumGrowable
;
for
(
uint32_t
track
:
aGrowableTracks
)
{
TrackSize
&
sz
=
aPlan
[
track
]
;
const
auto
state
=
sz
.
mState
;
if
(
state
&
aMinSizingSelector
)
{
foundOneSelected
=
true
;
if
(
state
&
aMaxSizingSelector
)
{
foundOneGrowable
=
true
;
continue
;
}
sz
.
mState
|
=
aSkipFlag
;
MOZ_ASSERT
(
numGrowable
!
=
0
)
;
-
-
numGrowable
;
}
}
if
(
foundOneSelected
&
&
!
foundOneGrowable
)
{
for
(
uint32_t
track
:
aGrowableTracks
)
{
aPlan
[
track
]
.
mState
&
=
~
aSkipFlag
;
}
numGrowable
=
aNumGrowable
;
}
return
numGrowable
;
}
void
GrowSelectedTracksUnlimited
(
nscoord
aAvailableSpace
nsTArray
<
TrackSize
>
&
aPlan
const
nsTArray
<
uint32_t
>
&
aGrowableTracks
TrackSize
:
:
StateBits
aSelector
)
const
{
MOZ_ASSERT
(
aAvailableSpace
>
0
&
&
aGrowableTracks
.
Length
(
)
>
0
)
;
uint32_t
numGrowable
=
aGrowableTracks
.
Length
(
)
;
if
(
aSelector
)
{
DebugOnly
<
TrackSize
:
:
StateBits
>
withoutFlexMin
=
TrackSize
:
:
StateBits
(
aSelector
&
~
TrackSize
:
:
eFlexMinSizing
)
;
MOZ_ASSERT
(
withoutFlexMin
=
=
TrackSize
:
:
eIntrinsicMinSizing
|
|
withoutFlexMin
=
=
TrackSize
:
:
eMinOrMaxContentMinSizing
|
|
withoutFlexMin
=
=
TrackSize
:
:
eMaxContentMinSizing
)
;
numGrowable
=
MarkExcludedTracks
(
aPlan
numGrowable
aGrowableTracks
TrackSize
:
:
eMaxContentMinSizing
TrackSize
:
:
eMaxContentMaxSizing
TrackSize
:
:
eSkipGrowUnlimited1
)
;
auto
minOrAutoSelector
=
aSelector
&
~
TrackSize
:
:
eMaxContentMinSizing
;
if
(
minOrAutoSelector
)
{
numGrowable
=
MarkExcludedTracks
(
aPlan
numGrowable
aGrowableTracks
minOrAutoSelector
TrackSize
:
:
eIntrinsicMaxSizing
TrackSize
:
:
eSkipGrowUnlimited2
)
;
}
}
nscoord
space
=
aAvailableSpace
;
while
(
true
)
{
nscoord
spacePerTrack
=
std
:
:
max
<
nscoord
>
(
space
/
numGrowable
1
)
;
for
(
uint32_t
track
:
aGrowableTracks
)
{
TrackSize
&
sz
=
aPlan
[
track
]
;
if
(
sz
.
mState
&
TrackSize
:
:
eSkipGrowUnlimited
)
{
continue
;
}
sz
.
mBase
+
=
spacePerTrack
;
space
-
=
spacePerTrack
;
MOZ_ASSERT
(
space
>
=
0
)
;
if
(
space
=
=
0
)
{
return
;
}
}
}
MOZ_ASSERT_UNREACHABLE
(
"
we
don
'
t
exit
the
loop
above
except
by
return
"
)
;
}
void
DistributeToTrackBases
(
nscoord
aAvailableSpace
nsTArray
<
TrackSize
>
&
aPlan
nsTArray
<
uint32_t
>
&
aGrowableTracks
TrackSize
:
:
StateBits
aSelector
)
{
SetupGrowthPlan
(
aPlan
aGrowableTracks
)
;
nscoord
space
=
GrowTracksToLimit
(
aAvailableSpace
aPlan
aGrowableTracks
)
;
if
(
space
>
0
)
{
GrowSelectedTracksUnlimited
(
space
aPlan
aGrowableTracks
aSelector
)
;
}
CopyPlanToBase
(
aPlan
aGrowableTracks
)
;
}
void
DistributeToTrackLimits
(
nscoord
aAvailableSpace
nsTArray
<
TrackSize
>
&
aPlan
nsTArray
<
uint32_t
>
&
aGrowableTracks
)
{
nscoord
space
=
GrowTracksToLimit
(
aAvailableSpace
aPlan
aGrowableTracks
)
;
if
(
space
>
0
)
{
GrowSelectedTracksUnlimited
(
aAvailableSpace
aPlan
aGrowableTracks
TrackSize
:
:
StateBits
(
0
)
)
;
}
CopyPlanToLimit
(
aPlan
aGrowableTracks
)
;
}
void
DistributeFreeSpace
(
nscoord
aAvailableSize
)
{
const
uint32_t
numTracks
=
mSizes
.
Length
(
)
;
if
(
MOZ_UNLIKELY
(
numTracks
=
=
0
|
|
aAvailableSize
<
=
0
)
)
{
return
;
}
if
(
aAvailableSize
=
=
NS_UNCONSTRAINEDSIZE
)
{
for
(
TrackSize
&
sz
:
mSizes
)
{
sz
.
mBase
=
sz
.
mLimit
;
}
}
else
{
nscoord
space
=
aAvailableSize
;
uint32_t
numGrowable
=
numTracks
;
for
(
const
TrackSize
&
sz
:
mSizes
)
{
space
-
=
sz
.
mBase
;
MOZ_ASSERT
(
sz
.
mBase
<
=
sz
.
mLimit
)
;
if
(
sz
.
mBase
=
=
sz
.
mLimit
)
{
-
-
numGrowable
;
}
}
while
(
space
>
0
&
&
numGrowable
)
{
nscoord
spacePerTrack
=
std
:
:
max
<
nscoord
>
(
space
/
numGrowable
1
)
;
for
(
uint32_t
i
=
0
;
i
<
numTracks
&
&
space
>
0
;
+
+
i
)
{
TrackSize
&
sz
=
mSizes
[
i
]
;
if
(
sz
.
mBase
=
=
sz
.
mLimit
)
{
continue
;
}
nscoord
newBase
=
sz
.
mBase
+
spacePerTrack
;
if
(
newBase
>
=
sz
.
mLimit
)
{
space
-
=
sz
.
mLimit
-
sz
.
mBase
;
sz
.
mBase
=
sz
.
mLimit
;
-
-
numGrowable
;
}
else
{
space
-
=
spacePerTrack
;
sz
.
mBase
=
newBase
;
}
}
}
}
}
float
FindFrUnitSize
(
const
LineRange
&
aRange
const
nsTArray
<
uint32_t
>
&
aFlexTracks
const
TrackSizingFunctions
&
aFunctions
nscoord
aSpaceToFill
)
const
;
float
FindUsedFlexFraction
(
GridReflowState
&
aState
nsTArray
<
GridItemInfo
>
&
aGridItems
const
nsTArray
<
uint32_t
>
&
aFlexTracks
const
TrackSizingFunctions
&
aFunctions
nscoord
aAvailableSize
)
const
;
void
StretchFlexibleTracks
(
GridReflowState
&
aState
nsTArray
<
GridItemInfo
>
&
aGridItems
const
TrackSizingFunctions
&
aFunctions
nscoord
aAvailableSize
)
;
#
ifdef
DEBUG
void
Dump
(
)
const
{
for
(
uint32_t
i
=
0
len
=
mSizes
.
Length
(
)
;
i
<
len
;
+
+
i
)
{
printf
(
"
%
d
:
"
i
)
;
mSizes
[
i
]
.
Dump
(
)
;
printf
(
"
\
n
"
)
;
}
}
#
endif
nsAutoTArray
<
TrackSize
32
>
mSizes
;
Dimension
mDimension
;
}
;
struct
MOZ_STACK_CLASS
nsGridContainerFrame
:
:
GridReflowState
{
GridReflowState
(
nsGridContainerFrame
*
aFrame
const
nsHTMLReflowState
&
aRS
)
:
GridReflowState
(
aFrame
*
aRS
.
rendContext
&
aRS
aRS
.
mStylePosition
aRS
.
GetWritingMode
(
)
)
{
}
GridReflowState
(
nsGridContainerFrame
*
aFrame
nsRenderingContext
&
aRC
)
:
GridReflowState
(
aFrame
aRC
nullptr
aFrame
-
>
StylePosition
(
)
aFrame
-
>
GetWritingMode
(
)
)
{
}
GridItemCSSOrderIterator
mIter
;
const
nsStylePosition
*
const
mGridStyle
;
Tracks
mCols
;
Tracks
mRows
;
TrackSizingFunctions
mColFunctions
;
TrackSizingFunctions
mRowFunctions
;
const
nsHTMLReflowState
*
mReflowState
;
nsRenderingContext
&
mRenderingContext
;
const
WritingMode
mWM
;
private
:
GridReflowState
(
nsGridContainerFrame
*
aFrame
nsRenderingContext
&
aRenderingContext
const
nsHTMLReflowState
*
aReflowState
const
nsStylePosition
*
aGridStyle
const
WritingMode
&
aWM
)
:
mIter
(
aFrame
kPrincipalList
)
mGridStyle
(
aGridStyle
)
mCols
(
eColDimension
)
mRows
(
eRowDimension
)
mColFunctions
(
{
mGridStyle
-
>
mGridTemplateColumns
.
mMinTrackSizingFunctions
mGridStyle
-
>
mGridTemplateColumns
.
mMaxTrackSizingFunctions
mGridStyle
-
>
mGridAutoColumnsMin
mGridStyle
-
>
mGridAutoColumnsMax
}
)
mRowFunctions
(
{
mGridStyle
-
>
mGridTemplateRows
.
mMinTrackSizingFunctions
mGridStyle
-
>
mGridTemplateRows
.
mMaxTrackSizingFunctions
mGridStyle
-
>
mGridAutoRowsMin
mGridStyle
-
>
mGridAutoRowsMax
}
)
mReflowState
(
aReflowState
)
mRenderingContext
(
aRenderingContext
)
mWM
(
aWM
)
{
}
}
;
static
bool
IsMinContent
(
const
nsStyleCoord
&
aCoord
)
{
return
aCoord
.
GetUnit
(
)
=
=
eStyleUnit_Enumerated
&
&
aCoord
.
GetIntValue
(
)
=
=
NS_STYLE_GRID_TRACK_BREADTH_MIN_CONTENT
;
}
static
uint32_t
FindLine
(
const
nsString
&
aName
int32_t
*
aNth
uint32_t
aFromIndex
uint32_t
aImplicitLine
const
nsTArray
<
nsTArray
<
nsString
>
>
&
aNameList
)
{
MOZ_ASSERT
(
aNth
&
&
*
aNth
>
0
)
;
int32_t
nth
=
*
aNth
;
const
uint32_t
len
=
aNameList
.
Length
(
)
;
uint32_t
line
;
uint32_t
i
=
aFromIndex
;
for
(
;
i
<
len
;
i
=
line
)
{
line
=
i
+
1
;
if
(
line
=
=
aImplicitLine
|
|
aNameList
[
i
]
.
Contains
(
aName
)
)
{
if
(
-
-
nth
=
=
0
)
{
return
line
;
}
}
}
if
(
aImplicitLine
>
i
)
{
if
(
-
-
nth
=
=
0
)
{
return
aImplicitLine
;
}
}
MOZ_ASSERT
(
nth
>
0
"
should
have
returned
a
valid
line
above
already
"
)
;
*
aNth
=
nth
;
return
0
;
}
static
uint32_t
RFindLine
(
const
nsString
&
aName
int32_t
*
aNth
uint32_t
aFromIndex
uint32_t
aImplicitLine
const
nsTArray
<
nsTArray
<
nsString
>
>
&
aNameList
)
{
MOZ_ASSERT
(
aNth
&
&
*
aNth
>
0
)
;
int32_t
nth
=
*
aNth
;
const
uint32_t
len
=
aNameList
.
Length
(
)
;
if
(
aImplicitLine
>
len
&
&
aImplicitLine
<
aFromIndex
)
{
if
(
-
-
nth
=
=
0
)
{
return
aImplicitLine
;
}
}
uint32_t
i
=
aFromIndex
=
=
0
?
len
:
std
:
:
min
(
aFromIndex
len
)
;
for
(
;
i
;
-
-
i
)
{
if
(
i
=
=
aImplicitLine
|
|
aNameList
[
i
-
1
]
.
Contains
(
aName
)
)
{
if
(
-
-
nth
=
=
0
)
{
return
i
;
}
}
}
MOZ_ASSERT
(
nth
>
0
"
should
have
returned
a
valid
line
above
already
"
)
;
*
aNth
=
nth
;
return
0
;
}
static
uint32_t
FindNamedLine
(
const
nsString
&
aName
int32_t
*
aNth
uint32_t
aFromIndex
uint32_t
aImplicitLine
const
nsTArray
<
nsTArray
<
nsString
>
>
&
aNameList
)
{
MOZ_ASSERT
(
aNth
&
&
*
aNth
!
=
0
)
;
if
(
*
aNth
>
0
)
{
return
:
:
FindLine
(
aName
aNth
aFromIndex
aImplicitLine
aNameList
)
;
}
int32_t
nth
=
-
*
aNth
;
int32_t
line
=
:
:
RFindLine
(
aName
&
nth
aFromIndex
aImplicitLine
aNameList
)
;
*
aNth
=
-
nth
;
return
line
;
}
static
const
css
:
:
GridNamedArea
*
FindNamedArea
(
const
nsSubstring
&
aName
const
nsStylePosition
*
aStyle
)
{
if
(
!
aStyle
-
>
mGridTemplateAreas
)
{
return
nullptr
;
}
const
nsTArray
<
css
:
:
GridNamedArea
>
&
areas
=
aStyle
-
>
mGridTemplateAreas
-
>
mNamedAreas
;
size_t
len
=
areas
.
Length
(
)
;
for
(
size_t
i
=
0
;
i
<
len
;
+
+
i
)
{
const
css
:
:
GridNamedArea
&
area
=
areas
[
i
]
;
if
(
area
.
mName
=
=
aName
)
{
return
&
area
;
}
}
return
nullptr
;
}
static
bool
IsNameWithSuffix
(
const
nsString
&
aString
const
nsString
&
aSuffix
uint32_t
*
aIndex
)
{
if
(
StringEndsWith
(
aString
aSuffix
)
)
{
*
aIndex
=
aString
.
Length
(
)
-
aSuffix
.
Length
(
)
;
return
*
aIndex
!
=
0
;
}
return
false
;
}
static
bool
IsNameWithEndSuffix
(
const
nsString
&
aString
uint32_t
*
aIndex
)
{
return
IsNameWithSuffix
(
aString
NS_LITERAL_STRING
(
"
-
end
"
)
aIndex
)
;
}
static
bool
IsNameWithStartSuffix
(
const
nsString
&
aString
uint32_t
*
aIndex
)
{
return
IsNameWithSuffix
(
aString
NS_LITERAL_STRING
(
"
-
start
"
)
aIndex
)
;
}
static
nscoord
GridLinePosition
(
uint32_t
aLine
const
nsTArray
<
TrackSize
>
&
aTrackSizes
)
{
const
uint32_t
endIndex
=
aLine
;
MOZ_ASSERT
(
endIndex
<
=
aTrackSizes
.
Length
(
)
"
aTrackSizes
is
too
small
"
)
;
nscoord
pos
=
0
;
for
(
uint32_t
i
=
0
;
i
<
endIndex
;
+
+
i
)
{
pos
+
=
aTrackSizes
[
i
]
.
mBase
;
}
return
pos
;
}
static
uint32_t
GetDisplayFlagsForGridItem
(
nsIFrame
*
aFrame
)
{
const
nsStylePosition
*
pos
=
aFrame
-
>
StylePosition
(
)
;
if
(
pos
-
>
mZIndex
.
GetUnit
(
)
=
=
eStyleUnit_Integer
)
{
return
nsIFrame
:
:
DISPLAY_CHILD_FORCE_STACKING_CONTEXT
;
}
return
nsIFrame
:
:
DISPLAY_CHILD_FORCE_PSEUDO_STACKING_CONTEXT
;
}
NS_QUERYFRAME_HEAD
(
nsGridContainerFrame
)
NS_QUERYFRAME_ENTRY
(
nsGridContainerFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsContainerFrame
)
NS_IMPL_FRAMEARENA_HELPERS
(
nsGridContainerFrame
)
nsContainerFrame
*
NS_NewGridContainerFrame
(
nsIPresShell
*
aPresShell
nsStyleContext
*
aContext
)
{
return
new
(
aPresShell
)
nsGridContainerFrame
(
aContext
)
;
}
const
nsRect
&
nsGridContainerFrame
:
:
GridItemCB
(
nsIFrame
*
aChild
)
{
MOZ_ASSERT
(
(
aChild
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
&
&
aChild
-
>
IsAbsolutelyPositioned
(
)
)
;
nsRect
*
cb
=
static_cast
<
nsRect
*
>
(
aChild
-
>
Properties
(
)
.
Get
(
GridItemContainingBlockRect
(
)
)
)
;
MOZ_ASSERT
(
cb
"
this
method
must
only
be
called
on
grid
items
and
the
grid
"
"
container
should
'
ve
reflowed
this
item
by
now
and
set
up
cb
"
)
;
return
*
cb
;
}
void
nsGridContainerFrame
:
:
AddImplicitNamedAreas
(
const
nsTArray
<
nsTArray
<
nsString
>
>
&
aLineNameLists
)
{
const
uint32_t
len
=
std
:
:
min
(
aLineNameLists
.
Length
(
)
size_t
(
nsStyleGridLine
:
:
kMaxLine
)
)
;
nsTHashtable
<
nsStringHashKey
>
currentStarts
;
ImplicitNamedAreas
*
areas
=
GetImplicitNamedAreas
(
)
;
for
(
uint32_t
i
=
0
;
i
<
len
;
+
+
i
)
{
const
nsTArray
<
nsString
>
&
names
(
aLineNameLists
[
i
]
)
;
const
uint32_t
jLen
=
names
.
Length
(
)
;
for
(
uint32_t
j
=
0
;
j
<
jLen
;
+
+
j
)
{
const
nsString
&
name
=
names
[
j
]
;
uint32_t
index
;
if
(
:
:
IsNameWithStartSuffix
(
name
&
index
)
)
{
currentStarts
.
PutEntry
(
nsDependentSubstring
(
name
0
index
)
)
;
}
else
if
(
:
:
IsNameWithEndSuffix
(
name
&
index
)
)
{
nsDependentSubstring
area
(
name
0
index
)
;
if
(
currentStarts
.
Contains
(
area
)
)
{
if
(
!
areas
)
{
areas
=
new
ImplicitNamedAreas
;
Properties
(
)
.
Set
(
ImplicitNamedAreasProperty
(
)
areas
)
;
}
areas
-
>
PutEntry
(
area
)
;
}
}
}
}
}
void
nsGridContainerFrame
:
:
InitImplicitNamedAreas
(
const
nsStylePosition
*
aStyle
)
{
ImplicitNamedAreas
*
areas
=
GetImplicitNamedAreas
(
)
;
if
(
areas
)
{
areas
-
>
Clear
(
)
;
}
AddImplicitNamedAreas
(
aStyle
-
>
mGridTemplateColumns
.
mLineNameLists
)
;
AddImplicitNamedAreas
(
aStyle
-
>
mGridTemplateRows
.
mLineNameLists
)
;
if
(
areas
&
&
areas
-
>
Count
(
)
=
=
0
)
{
Properties
(
)
.
Delete
(
ImplicitNamedAreasProperty
(
)
)
;
}
}
int32_t
nsGridContainerFrame
:
:
ResolveLine
(
const
nsStyleGridLine
&
aLine
int32_t
aNth
uint32_t
aFromIndex
const
nsTArray
<
nsTArray
<
nsString
>
>
&
aLineNameList
uint32_t
GridNamedArea
:
:
*
aAreaStart
uint32_t
GridNamedArea
:
:
*
aAreaEnd
uint32_t
aExplicitGridEnd
LineRangeSide
aSide
const
nsStylePosition
*
aStyle
)
{
MOZ_ASSERT
(
!
aLine
.
IsAuto
(
)
)
;
int32_t
line
=
0
;
if
(
aLine
.
mLineName
.
IsEmpty
(
)
)
{
MOZ_ASSERT
(
aNth
!
=
0
"
css
-
grid
9
.
2
:
<
integer
>
must
not
be
zero
.
"
)
;
line
=
int32_t
(
aFromIndex
)
+
aNth
;
}
else
{
if
(
aNth
=
=
0
)
{
aNth
=
1
;
}
bool
isNameOnly
=
!
aLine
.
mHasSpan
&
&
aLine
.
mInteger
=
=
0
;
if
(
isNameOnly
)
{
const
GridNamedArea
*
area
=
:
:
FindNamedArea
(
aLine
.
mLineName
aStyle
)
;
if
(
area
|
|
HasImplicitNamedArea
(
aLine
.
mLineName
)
)
{
uint32_t
implicitLine
=
0
;
nsAutoString
lineName
(
aLine
.
mLineName
)
;
if
(
aSide
=
=
eLineRangeSideStart
)
{
lineName
.
AppendLiteral
(
"
-
start
"
)
;
implicitLine
=
area
?
area
-
>
*
aAreaStart
:
0
;
}
else
{
lineName
.
AppendLiteral
(
"
-
end
"
)
;
implicitLine
=
area
?
area
-
>
*
aAreaEnd
:
0
;
}
line
=
:
:
FindNamedLine
(
lineName
&
aNth
aFromIndex
implicitLine
aLineNameList
)
;
}
}
if
(
line
=
=
0
)
{
uint32_t
implicitLine
=
0
;
uint32_t
index
;
auto
GridNamedArea
:
:
*
areaEdge
=
aAreaStart
;
bool
found
=
:
:
IsNameWithStartSuffix
(
aLine
.
mLineName
&
index
)
;
if
(
!
found
)
{
found
=
:
:
IsNameWithEndSuffix
(
aLine
.
mLineName
&
index
)
;
areaEdge
=
aAreaEnd
;
}
if
(
found
)
{
const
GridNamedArea
*
area
=
:
:
FindNamedArea
(
nsDependentSubstring
(
aLine
.
mLineName
0
index
)
aStyle
)
;
if
(
area
)
{
implicitLine
=
area
-
>
*
areaEdge
;
}
}
line
=
:
:
FindNamedLine
(
aLine
.
mLineName
&
aNth
aFromIndex
implicitLine
aLineNameList
)
;
}
if
(
line
=
=
0
)
{
MOZ_ASSERT
(
aNth
!
=
0
"
we
found
all
N
named
lines
but
'
line
'
is
zero
!
"
)
;
int32_t
edgeLine
;
if
(
aLine
.
mHasSpan
)
{
edgeLine
=
aSide
=
=
eLineRangeSideStart
?
1
:
aExplicitGridEnd
;
}
else
{
edgeLine
=
aNth
<
0
?
1
:
aExplicitGridEnd
;
}
line
=
edgeLine
+
aNth
;
}
}
return
clamped
(
line
nsStyleGridLine
:
:
kMinLine
nsStyleGridLine
:
:
kMaxLine
)
;
}
nsGridContainerFrame
:
:
LinePair
nsGridContainerFrame
:
:
ResolveLineRangeHelper
(
const
nsStyleGridLine
&
aStart
const
nsStyleGridLine
&
aEnd
const
nsTArray
<
nsTArray
<
nsString
>
>
&
aLineNameList
uint32_t
GridNamedArea
:
:
*
aAreaStart
uint32_t
GridNamedArea
:
:
*
aAreaEnd
uint32_t
aExplicitGridEnd
const
nsStylePosition
*
aStyle
)
{
MOZ_ASSERT
(
int32_t
(
nsGridContainerFrame
:
:
kAutoLine
)
>
nsStyleGridLine
:
:
kMaxLine
)
;
if
(
aStart
.
mHasSpan
)
{
if
(
aEnd
.
mHasSpan
|
|
aEnd
.
IsAuto
(
)
)
{
if
(
aStart
.
mLineName
.
IsEmpty
(
)
)
{
return
LinePair
(
kAutoLine
aStart
.
mInteger
)
;
}
return
LinePair
(
kAutoLine
1
)
;
}
auto
end
=
ResolveLine
(
aEnd
aEnd
.
mInteger
0
aLineNameList
aAreaStart
aAreaEnd
aExplicitGridEnd
eLineRangeSideEnd
aStyle
)
;
int32_t
span
=
aStart
.
mInteger
=
=
0
?
1
:
aStart
.
mInteger
;
if
(
end
<
=
1
)
{
int32_t
start
=
std
:
:
max
(
end
-
span
nsStyleGridLine
:
:
kMinLine
)
;
return
LinePair
(
start
end
)
;
}
auto
start
=
ResolveLine
(
aStart
-
span
end
aLineNameList
aAreaStart
aAreaEnd
aExplicitGridEnd
eLineRangeSideStart
aStyle
)
;
return
LinePair
(
start
end
)
;
}
int32_t
start
=
kAutoLine
;
if
(
aStart
.
IsAuto
(
)
)
{
if
(
aEnd
.
IsAuto
(
)
)
{
return
LinePair
(
start
1
)
;
}
if
(
aEnd
.
mHasSpan
)
{
if
(
aEnd
.
mLineName
.
IsEmpty
(
)
)
{
MOZ_ASSERT
(
aEnd
.
mInteger
!
=
0
)
;
return
LinePair
(
start
aEnd
.
mInteger
)
;
}
return
LinePair
(
start
1
)
;
}
}
else
{
start
=
ResolveLine
(
aStart
aStart
.
mInteger
0
aLineNameList
aAreaStart
aAreaEnd
aExplicitGridEnd
eLineRangeSideStart
aStyle
)
;
if
(
aEnd
.
IsAuto
(
)
)
{
return
LinePair
(
start
start
)
;
}
}
uint32_t
from
=
0
;
int32_t
nth
=
aEnd
.
mInteger
=
=
0
?
1
:
aEnd
.
mInteger
;
if
(
aEnd
.
mHasSpan
)
{
if
(
MOZ_UNLIKELY
(
start
<
0
)
)
{
if
(
aEnd
.
mLineName
.
IsEmpty
(
)
)
{
return
LinePair
(
start
start
+
nth
)
;
}
}
else
{
if
(
start
>
=
int32_t
(
aExplicitGridEnd
)
)
{
return
LinePair
(
start
std
:
:
min
(
start
+
nth
nsStyleGridLine
:
:
kMaxLine
)
)
;
}
from
=
start
;
}
}
auto
end
=
ResolveLine
(
aEnd
nth
from
aLineNameList
aAreaStart
aAreaEnd
aExplicitGridEnd
eLineRangeSideEnd
aStyle
)
;
if
(
start
=
=
int32_t
(
kAutoLine
)
)
{
start
=
std
:
:
max
(
nsStyleGridLine
:
:
kMinLine
end
-
1
)
;
}
return
LinePair
(
start
end
)
;
}
nsGridContainerFrame
:
:
LineRange
nsGridContainerFrame
:
:
ResolveLineRange
(
const
nsStyleGridLine
&
aStart
const
nsStyleGridLine
&
aEnd
const
nsTArray
<
nsTArray
<
nsString
>
>
&
aLineNameList
uint32_t
GridNamedArea
:
:
*
aAreaStart
uint32_t
GridNamedArea
:
:
*
aAreaEnd
uint32_t
aExplicitGridEnd
const
nsStylePosition
*
aStyle
)
{
LinePair
r
=
ResolveLineRangeHelper
(
aStart
aEnd
aLineNameList
aAreaStart
aAreaEnd
aExplicitGridEnd
aStyle
)
;
MOZ_ASSERT
(
r
.
second
!
=
int32_t
(
kAutoLine
)
)
;
if
(
r
.
first
=
=
int32_t
(
kAutoLine
)
)
{
r
.
second
=
std
:
:
min
(
r
.
second
nsStyleGridLine
:
:
kMaxLine
-
1
)
;
}
else
if
(
r
.
second
<
=
r
.
first
)
{
if
(
MOZ_UNLIKELY
(
r
.
first
=
=
nsStyleGridLine
:
:
kMaxLine
)
)
{
r
.
first
=
nsStyleGridLine
:
:
kMaxLine
-
1
;
}
r
.
second
=
r
.
first
+
1
;
}
return
LineRange
(
r
.
first
r
.
second
)
;
}
nsGridContainerFrame
:
:
GridArea
nsGridContainerFrame
:
:
PlaceDefinite
(
nsIFrame
*
aChild
const
nsStylePosition
*
aStyle
)
{
const
nsStylePosition
*
itemStyle
=
aChild
-
>
StylePosition
(
)
;
return
GridArea
(
ResolveLineRange
(
itemStyle
-
>
mGridColumnStart
itemStyle
-
>
mGridColumnEnd
aStyle
-
>
mGridTemplateColumns
.
mLineNameLists
&
GridNamedArea
:
:
mColumnStart
&
GridNamedArea
:
:
mColumnEnd
mExplicitGridColEnd
aStyle
)
ResolveLineRange
(
itemStyle
-
>
mGridRowStart
itemStyle
-
>
mGridRowEnd
aStyle
-
>
mGridTemplateRows
.
mLineNameLists
&
GridNamedArea
:
:
mRowStart
&
GridNamedArea
:
:
mRowEnd
mExplicitGridRowEnd
aStyle
)
)
;
}
nsGridContainerFrame
:
:
LineRange
nsGridContainerFrame
:
:
ResolveAbsPosLineRange
(
const
nsStyleGridLine
&
aStart
const
nsStyleGridLine
&
aEnd
const
nsTArray
<
nsTArray
<
nsString
>
>
&
aLineNameList
uint32_t
GridNamedArea
:
:
*
aAreaStart
uint32_t
GridNamedArea
:
:
*
aAreaEnd
uint32_t
aExplicitGridEnd
int32_t
aGridStart
int32_t
aGridEnd
const
nsStylePosition
*
aStyle
)
{
if
(
aStart
.
IsAuto
(
)
)
{
if
(
aEnd
.
IsAuto
(
)
)
{
return
LineRange
(
kAutoLine
kAutoLine
)
;
}
int32_t
end
=
ResolveLine
(
aEnd
aEnd
.
mInteger
0
aLineNameList
aAreaStart
aAreaEnd
aExplicitGridEnd
eLineRangeSideEnd
aStyle
)
;
if
(
aEnd
.
mHasSpan
)
{
+
+
end
;
}
end
=
AutoIfOutside
(
end
aGridStart
aGridEnd
)
;
return
LineRange
(
kAutoLine
end
)
;
}
if
(
aEnd
.
IsAuto
(
)
)
{
int32_t
start
=
ResolveLine
(
aStart
aStart
.
mInteger
0
aLineNameList
aAreaStart
aAreaEnd
aExplicitGridEnd
eLineRangeSideStart
aStyle
)
;
if
(
aStart
.
mHasSpan
)
{
start
=
std
:
:
max
(
aGridEnd
-
start
aGridStart
)
;
}
start
=
AutoIfOutside
(
start
aGridStart
aGridEnd
)
;
return
LineRange
(
start
kAutoLine
)
;
}
LineRange
r
=
ResolveLineRange
(
aStart
aEnd
aLineNameList
aAreaStart
aAreaEnd
aExplicitGridEnd
aStyle
)
;
if
(
r
.
IsAuto
(
)
)
{
MOZ_ASSERT
(
aStart
.
mHasSpan
&
&
aEnd
.
mHasSpan
"
span
/
span
is
the
only
case
"
"
leading
to
IsAuto
here
-
-
we
dealt
with
the
other
cases
above
"
)
;
return
LineRange
(
kAutoLine
kAutoLine
)
;
}
return
LineRange
(
AutoIfOutside
(
r
.
mUntranslatedStart
aGridStart
aGridEnd
)
AutoIfOutside
(
r
.
mUntranslatedEnd
aGridStart
aGridEnd
)
)
;
}
uint32_t
nsGridContainerFrame
:
:
FindAutoCol
(
uint32_t
aStartCol
uint32_t
aLockedRow
const
GridArea
*
aArea
)
const
{
const
uint32_t
extent
=
aArea
-
>
mCols
.
Extent
(
)
;
const
uint32_t
iStart
=
aLockedRow
;
const
uint32_t
iEnd
=
iStart
+
aArea
-
>
mRows
.
Extent
(
)
;
uint32_t
candidate
=
aStartCol
;
for
(
uint32_t
i
=
iStart
;
i
<
iEnd
;
)
{
if
(
i
>
=
mCellMap
.
mCells
.
Length
(
)
)
{
break
;
}
const
nsTArray
<
CellMap
:
:
Cell
>
&
cellsInRow
=
mCellMap
.
mCells
[
i
]
;
const
uint32_t
len
=
cellsInRow
.
Length
(
)
;
const
uint32_t
lastCandidate
=
candidate
;
for
(
uint32_t
j
=
candidate
gap
=
0
;
j
<
len
&
&
gap
<
extent
;
+
+
j
)
{
+
+
gap
;
if
(
cellsInRow
[
j
]
.
mIsOccupied
)
{
do
{
+
+
j
;
}
while
(
j
<
len
&
&
cellsInRow
[
j
]
.
mIsOccupied
)
;
candidate
=
j
;
gap
=
0
;
}
}
if
(
lastCandidate
<
candidate
&
&
i
!
=
iStart
)
{
i
=
iStart
;
}
else
{
+
+
i
;
}
}
return
candidate
;
}
nsGridContainerFrame
:
:
GridArea
nsGridContainerFrame
:
:
PlaceAbsPos
(
nsIFrame
*
aChild
const
nsStylePosition
*
aStyle
)
{
const
nsStylePosition
*
itemStyle
=
aChild
-
>
StylePosition
(
)
;
int32_t
gridColStart
=
1
-
mExplicitGridOffsetCol
;
int32_t
gridRowStart
=
1
-
mExplicitGridOffsetRow
;
return
GridArea
(
ResolveAbsPosLineRange
(
itemStyle
-
>
mGridColumnStart
itemStyle
-
>
mGridColumnEnd
aStyle
-
>
mGridTemplateColumns
.
mLineNameLists
&
GridNamedArea
:
:
mColumnStart
&
GridNamedArea
:
:
mColumnEnd
mExplicitGridColEnd
gridColStart
mGridColEnd
aStyle
)
ResolveAbsPosLineRange
(
itemStyle
-
>
mGridRowStart
itemStyle
-
>
mGridRowEnd
aStyle
-
>
mGridTemplateRows
.
mLineNameLists
&
GridNamedArea
:
:
mRowStart
&
GridNamedArea
:
:
mRowEnd
mExplicitGridRowEnd
gridRowStart
mGridRowEnd
aStyle
)
)
;
}
void
nsGridContainerFrame
:
:
PlaceAutoCol
(
uint32_t
aStartCol
GridArea
*
aArea
)
const
{
MOZ_ASSERT
(
aArea
-
>
mRows
.
IsDefinite
(
)
&
&
aArea
-
>
mCols
.
IsAuto
(
)
)
;
uint32_t
col
=
FindAutoCol
(
aStartCol
aArea
-
>
mRows
.
mStart
aArea
)
;
aArea
-
>
mCols
.
ResolveAutoPosition
(
col
)
;
MOZ_ASSERT
(
aArea
-
>
IsDefinite
(
)
)
;
}
uint32_t
nsGridContainerFrame
:
:
FindAutoRow
(
uint32_t
aLockedCol
uint32_t
aStartRow
const
GridArea
*
aArea
)
const
{
const
uint32_t
extent
=
aArea
-
>
mRows
.
Extent
(
)
;
const
uint32_t
jStart
=
aLockedCol
;
const
uint32_t
jEnd
=
jStart
+
aArea
-
>
mCols
.
Extent
(
)
;
const
uint32_t
iEnd
=
mCellMap
.
mCells
.
Length
(
)
;
uint32_t
candidate
=
aStartRow
;
for
(
uint32_t
i
=
candidate
gap
=
0
;
i
<
iEnd
&
&
gap
<
extent
;
+
+
i
)
{
+
+
gap
;
const
nsTArray
<
CellMap
:
:
Cell
>
&
cellsInRow
=
mCellMap
.
mCells
[
i
]
;
const
uint32_t
clampedJEnd
=
std
:
:
min
<
uint32_t
>
(
jEnd
cellsInRow
.
Length
(
)
)
;
for
(
uint32_t
j
=
jStart
;
j
<
clampedJEnd
;
+
+
j
)
{
if
(
cellsInRow
[
j
]
.
mIsOccupied
)
{
candidate
=
i
+
1
;
gap
=
0
;
break
;
}
}
}
return
candidate
;
}
void
nsGridContainerFrame
:
:
PlaceAutoRow
(
uint32_t
aStartRow
GridArea
*
aArea
)
const
{
MOZ_ASSERT
(
aArea
-
>
mCols
.
IsDefinite
(
)
&
&
aArea
-
>
mRows
.
IsAuto
(
)
)
;
uint32_t
row
=
FindAutoRow
(
aArea
-
>
mCols
.
mStart
aStartRow
aArea
)
;
aArea
-
>
mRows
.
ResolveAutoPosition
(
row
)
;
MOZ_ASSERT
(
aArea
-
>
IsDefinite
(
)
)
;
}
void
nsGridContainerFrame
:
:
PlaceAutoAutoInRowOrder
(
uint32_t
aStartCol
uint32_t
aStartRow
GridArea
*
aArea
)
const
{
MOZ_ASSERT
(
aArea
-
>
mCols
.
IsAuto
(
)
&
&
aArea
-
>
mRows
.
IsAuto
(
)
)
;
const
uint32_t
colExtent
=
aArea
-
>
mCols
.
Extent
(
)
;
const
uint32_t
gridRowEnd
=
mGridRowEnd
;
const
uint32_t
gridColEnd
=
mGridColEnd
;
uint32_t
col
=
aStartCol
;
uint32_t
row
=
aStartRow
;
for
(
;
row
<
gridRowEnd
;
+
+
row
)
{
col
=
FindAutoCol
(
col
row
aArea
)
;
if
(
col
+
colExtent
<
=
gridColEnd
)
{
break
;
}
col
=
0
;
}
MOZ_ASSERT
(
row
<
gridRowEnd
|
|
col
=
=
0
"
expected
column
0
for
placing
in
a
new
row
"
)
;
aArea
-
>
mCols
.
ResolveAutoPosition
(
col
)
;
aArea
-
>
mRows
.
ResolveAutoPosition
(
row
)
;
MOZ_ASSERT
(
aArea
-
>
IsDefinite
(
)
)
;
}
void
nsGridContainerFrame
:
:
PlaceAutoAutoInColOrder
(
uint32_t
aStartCol
uint32_t
aStartRow
GridArea
*
aArea
)
const
{
MOZ_ASSERT
(
aArea
-
>
mCols
.
IsAuto
(
)
&
&
aArea
-
>
mRows
.
IsAuto
(
)
)
;
const
uint32_t
rowExtent
=
aArea
-
>
mRows
.
Extent
(
)
;
const
uint32_t
gridRowEnd
=
mGridRowEnd
;
const
uint32_t
gridColEnd
=
mGridColEnd
;
uint32_t
col
=
aStartCol
;
uint32_t
row
=
aStartRow
;
for
(
;
col
<
gridColEnd
;
+
+
col
)
{
row
=
FindAutoRow
(
col
row
aArea
)
;
if
(
row
+
rowExtent
<
=
gridRowEnd
)
{
break
;
}
row
=
0
;
}
MOZ_ASSERT
(
col
<
gridColEnd
|
|
row
=
=
0
"
expected
row
0
for
placing
in
a
new
column
"
)
;
aArea
-
>
mCols
.
ResolveAutoPosition
(
col
)
;
aArea
-
>
mRows
.
ResolveAutoPosition
(
row
)
;
MOZ_ASSERT
(
aArea
-
>
IsDefinite
(
)
)
;
}
void
nsGridContainerFrame
:
:
InitializeGridBounds
(
const
nsStylePosition
*
aStyle
)
{
uint32_t
colEnd
=
aStyle
-
>
mGridTemplateColumns
.
mLineNameLists
.
Length
(
)
;
uint32_t
rowEnd
=
aStyle
-
>
mGridTemplateRows
.
mLineNameLists
.
Length
(
)
;
auto
areas
=
aStyle
-
>
mGridTemplateAreas
.
get
(
)
;
mExplicitGridColEnd
=
std
:
:
max
(
colEnd
areas
?
areas
-
>
mNColumns
+
1
:
1
)
;
mExplicitGridRowEnd
=
std
:
:
max
(
rowEnd
areas
?
areas
-
>
NRows
(
)
+
1
:
1
)
;
mExplicitGridColEnd
=
std
:
:
min
(
mExplicitGridColEnd
uint32_t
(
nsStyleGridLine
:
:
kMaxLine
)
)
;
mExplicitGridRowEnd
=
std
:
:
min
(
mExplicitGridRowEnd
uint32_t
(
nsStyleGridLine
:
:
kMaxLine
)
)
;
mGridColEnd
=
mExplicitGridColEnd
;
mGridRowEnd
=
mExplicitGridRowEnd
;
}
void
nsGridContainerFrame
:
:
PlaceGridItems
(
GridReflowState
&
aState
)
{
const
nsStylePosition
*
const
gridStyle
=
aState
.
mGridStyle
;
mCellMap
.
ClearOccupied
(
)
;
InitializeGridBounds
(
gridStyle
)
;
int32_t
minCol
=
1
;
int32_t
minRow
=
1
;
mGridItems
.
ClearAndRetainStorage
(
)
;
for
(
;
!
aState
.
mIter
.
AtEnd
(
)
;
aState
.
mIter
.
Next
(
)
)
{
nsIFrame
*
child
=
*
aState
.
mIter
;
GridItemInfo
*
info
=
mGridItems
.
AppendElement
(
GridItemInfo
(
PlaceDefinite
(
child
gridStyle
)
)
)
;
#
ifdef
DEBUG
MOZ_ASSERT
(
aState
.
mIter
.
GridItemIndex
(
)
=
=
mGridItems
.
Length
(
)
-
1
"
GridItemIndex
(
)
is
broken
"
)
;
info
-
>
mFrame
=
child
;
#
endif
GridArea
&
area
=
info
-
>
mArea
;
if
(
area
.
mCols
.
IsDefinite
(
)
)
{
minCol
=
std
:
:
min
(
minCol
area
.
mCols
.
mUntranslatedStart
)
;
}
if
(
area
.
mRows
.
IsDefinite
(
)
)
{
minRow
=
std
:
:
min
(
minRow
area
.
mRows
.
mUntranslatedStart
)
;
}
}
mExplicitGridOffsetCol
=
1
-
minCol
;
mExplicitGridOffsetRow
=
1
-
minRow
;
aState
.
mColFunctions
.
mExplicitGridOffset
=
mExplicitGridOffsetCol
;
aState
.
mRowFunctions
.
mExplicitGridOffset
=
mExplicitGridOffsetRow
;
const
int32_t
offsetToColZero
=
int32_t
(
mExplicitGridOffsetCol
)
-
1
;
const
int32_t
offsetToRowZero
=
int32_t
(
mExplicitGridOffsetRow
)
-
1
;
mGridColEnd
+
=
offsetToColZero
;
mGridRowEnd
+
=
offsetToRowZero
;
aState
.
mIter
.
Reset
(
)
;
for
(
;
!
aState
.
mIter
.
AtEnd
(
)
;
aState
.
mIter
.
Next
(
)
)
{
GridArea
&
area
=
mGridItems
[
aState
.
mIter
.
GridItemIndex
(
)
]
.
mArea
;
if
(
area
.
mCols
.
IsDefinite
(
)
)
{
area
.
mCols
.
mStart
=
area
.
mCols
.
mUntranslatedStart
+
offsetToColZero
;
area
.
mCols
.
mEnd
=
area
.
mCols
.
mUntranslatedEnd
+
offsetToColZero
;
}
if
(
area
.
mRows
.
IsDefinite
(
)
)
{
area
.
mRows
.
mStart
=
area
.
mRows
.
mUntranslatedStart
+
offsetToRowZero
;
area
.
mRows
.
mEnd
=
area
.
mRows
.
mUntranslatedEnd
+
offsetToRowZero
;
}
if
(
area
.
IsDefinite
(
)
)
{
mCellMap
.
Fill
(
area
)
;
InflateGridFor
(
area
)
;
}
}
auto
flowStyle
=
gridStyle
-
>
mGridAutoFlow
;
const
bool
isRowOrder
=
(
flowStyle
&
NS_STYLE_GRID_AUTO_FLOW_ROW
)
;
const
bool
isSparse
=
!
(
flowStyle
&
NS_STYLE_GRID_AUTO_FLOW_DENSE
)
;
{
Maybe
<
nsDataHashtable
<
nsUint32HashKey
uint32_t
>
>
cursors
;
if
(
isSparse
)
{
cursors
.
emplace
(
)
;
}
auto
placeAutoMinorFunc
=
isRowOrder
?
&
nsGridContainerFrame
:
:
PlaceAutoCol
:
&
nsGridContainerFrame
:
:
PlaceAutoRow
;
aState
.
mIter
.
Reset
(
)
;
for
(
;
!
aState
.
mIter
.
AtEnd
(
)
;
aState
.
mIter
.
Next
(
)
)
{
GridArea
&
area
=
mGridItems
[
aState
.
mIter
.
GridItemIndex
(
)
]
.
mArea
;
LineRange
&
major
=
isRowOrder
?
area
.
mRows
:
area
.
mCols
;
LineRange
&
minor
=
isRowOrder
?
area
.
mCols
:
area
.
mRows
;
if
(
major
.
IsDefinite
(
)
&
&
minor
.
IsAuto
(
)
)
{
uint32_t
cursor
=
0
;
if
(
isSparse
)
{
cursors
-
>
Get
(
major
.
mStart
&
cursor
)
;
}
(
this
-
>
*
placeAutoMinorFunc
)
(
cursor
&
area
)
;
mCellMap
.
Fill
(
area
)
;
if
(
isSparse
)
{
cursors
-
>
Put
(
major
.
mStart
minor
.
mEnd
)
;
}
}
InflateGridFor
(
area
)
;
}
}
uint32_t
cursorMajor
=
0
;
uint32_t
cursorMinor
=
0
;
auto
placeAutoMajorFunc
=
isRowOrder
?
&
nsGridContainerFrame
:
:
PlaceAutoRow
:
&
nsGridContainerFrame
:
:
PlaceAutoCol
;
aState
.
mIter
.
Reset
(
)
;
for
(
;
!
aState
.
mIter
.
AtEnd
(
)
;
aState
.
mIter
.
Next
(
)
)
{
GridArea
&
area
=
mGridItems
[
aState
.
mIter
.
GridItemIndex
(
)
]
.
mArea
;
MOZ_ASSERT
(
*
aState
.
mIter
=
=
mGridItems
[
aState
.
mIter
.
GridItemIndex
(
)
]
.
mFrame
"
iterator
out
of
sync
with
mGridItems
"
)
;
LineRange
&
major
=
isRowOrder
?
area
.
mRows
:
area
.
mCols
;
LineRange
&
minor
=
isRowOrder
?
area
.
mCols
:
area
.
mRows
;
if
(
major
.
IsAuto
(
)
)
{
if
(
minor
.
IsDefinite
(
)
)
{
if
(
isSparse
)
{
if
(
minor
.
mStart
<
cursorMinor
)
{
+
+
cursorMajor
;
}
cursorMinor
=
minor
.
mStart
;
}
(
this
-
>
*
placeAutoMajorFunc
)
(
cursorMajor
&
area
)
;
if
(
isSparse
)
{
cursorMajor
=
major
.
mStart
;
}
}
else
{
if
(
isRowOrder
)
{
PlaceAutoAutoInRowOrder
(
cursorMinor
cursorMajor
&
area
)
;
}
else
{
PlaceAutoAutoInColOrder
(
cursorMajor
cursorMinor
&
area
)
;
}
if
(
isSparse
)
{
cursorMajor
=
major
.
mStart
;
cursorMinor
=
minor
.
mEnd
;
#
ifdef
DEBUG
uint32_t
gridMajorEnd
=
isRowOrder
?
mGridRowEnd
:
mGridColEnd
;
uint32_t
gridMinorEnd
=
isRowOrder
?
mGridColEnd
:
mGridRowEnd
;
MOZ_ASSERT
(
cursorMajor
<
=
gridMajorEnd
"
we
shouldn
'
t
need
to
place
items
further
than
1
track
"
"
past
the
current
end
of
the
grid
in
major
dimension
"
)
;
MOZ_ASSERT
(
cursorMinor
<
=
gridMinorEnd
"
we
shouldn
'
t
add
implicit
minor
tracks
for
auto
/
auto
"
)
;
#
endif
}
}
mCellMap
.
Fill
(
area
)
;
InflateGridFor
(
area
)
;
}
}
if
(
IsAbsoluteContainer
(
)
)
{
nsFrameList
children
(
GetChildList
(
GetAbsoluteListID
(
)
)
)
;
const
int32_t
offsetToColZero
=
int32_t
(
mExplicitGridOffsetCol
)
-
1
;
const
int32_t
offsetToRowZero
=
int32_t
(
mExplicitGridOffsetRow
)
-
1
;
AutoRestore
<
uint32_t
>
save1
(
mGridColEnd
)
;
AutoRestore
<
uint32_t
>
save2
(
mGridRowEnd
)
;
mGridColEnd
-
=
offsetToColZero
;
mGridRowEnd
-
=
offsetToRowZero
;
mAbsPosItems
.
ClearAndRetainStorage
(
)
;
size_t
i
=
0
;
for
(
nsFrameList
:
:
Enumerator
e
(
children
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
+
+
i
)
{
nsIFrame
*
child
=
e
.
get
(
)
;
GridItemInfo
*
info
=
mAbsPosItems
.
AppendElement
(
GridItemInfo
(
PlaceAbsPos
(
child
gridStyle
)
)
)
;
#
ifdef
DEBUG
info
-
>
mFrame
=
child
;
#
endif
GridArea
&
area
=
info
-
>
mArea
;
if
(
area
.
mCols
.
mUntranslatedStart
!
=
int32_t
(
kAutoLine
)
)
{
area
.
mCols
.
mStart
=
area
.
mCols
.
mUntranslatedStart
+
offsetToColZero
;
}
if
(
area
.
mCols
.
mUntranslatedEnd
!
=
int32_t
(
kAutoLine
)
)
{
area
.
mCols
.
mEnd
=
area
.
mCols
.
mUntranslatedEnd
+
offsetToColZero
;
}
if
(
area
.
mRows
.
mUntranslatedStart
!
=
int32_t
(
kAutoLine
)
)
{
area
.
mRows
.
mStart
=
area
.
mRows
.
mUntranslatedStart
+
offsetToRowZero
;
}
if
(
area
.
mRows
.
mUntranslatedEnd
!
=
int32_t
(
kAutoLine
)
)
{
area
.
mRows
.
mEnd
=
area
.
mRows
.
mUntranslatedEnd
+
offsetToRowZero
;
}
}
}
}
void
nsGridContainerFrame
:
:
TrackSize
:
:
Initialize
(
nscoord
aPercentageBasis
const
nsStyleCoord
&
aMinCoord
const
nsStyleCoord
&
aMaxCoord
)
{
MOZ_ASSERT
(
mBase
=
=
0
&
&
mLimit
=
=
0
&
&
mState
=
=
0
"
track
size
data
is
expected
to
be
initialized
to
zero
"
)
;
switch
(
aMinCoord
.
GetUnit
(
)
)
{
case
eStyleUnit_Auto
:
mState
=
eAutoMinSizing
;
break
;
case
eStyleUnit_Enumerated
:
mState
=
IsMinContent
(
aMinCoord
)
?
eMinContentMinSizing
:
eMaxContentMinSizing
;
break
;
case
eStyleUnit_FlexFraction
:
mState
=
eFlexMinSizing
;
break
;
default
:
mBase
=
nsRuleNode
:
:
ComputeCoordPercentCalc
(
aMinCoord
aPercentageBasis
)
;
}
switch
(
aMaxCoord
.
GetUnit
(
)
)
{
case
eStyleUnit_Auto
:
mState
|
=
eAutoMaxSizing
;
mLimit
=
NS_UNCONSTRAINEDSIZE
;
break
;
case
eStyleUnit_Enumerated
:
mState
|
=
IsMinContent
(
aMaxCoord
)
?
eMinContentMaxSizing
:
eMaxContentMaxSizing
;
mLimit
=
NS_UNCONSTRAINEDSIZE
;
break
;
case
eStyleUnit_FlexFraction
:
mState
|
=
eFlexMaxSizing
;
mLimit
=
mBase
;
break
;
default
:
mLimit
=
nsRuleNode
:
:
ComputeCoordPercentCalc
(
aMaxCoord
aPercentageBasis
)
;
if
(
mLimit
<
mBase
)
{
mLimit
=
mBase
;
}
}
}
void
nsGridContainerFrame
:
:
Tracks
:
:
Initialize
(
const
TrackSizingFunctions
&
aFunctions
nscoord
aPercentageBasis
)
{
const
uint32_t
explicitGridOffset
=
aFunctions
.
mExplicitGridOffset
;
MOZ_ASSERT
(
mSizes
.
Length
(
)
>
=
explicitGridOffset
+
aFunctions
.
mMinSizingFunctions
.
Length
(
)
)
;
MOZ_ASSERT
(
aFunctions
.
mMinSizingFunctions
.
Length
(
)
=
=
aFunctions
.
mMaxSizingFunctions
.
Length
(
)
)
;
uint32_t
i
=
0
;
for
(
;
i
<
explicitGridOffset
;
+
+
i
)
{
mSizes
[
i
]
.
Initialize
(
aPercentageBasis
aFunctions
.
mAutoMinSizing
aFunctions
.
mAutoMaxSizing
)
;
}
uint32_t
j
=
0
;
for
(
uint32_t
len
=
aFunctions
.
mMinSizingFunctions
.
Length
(
)
;
j
<
len
;
+
+
j
)
{
mSizes
[
i
+
j
]
.
Initialize
(
aPercentageBasis
aFunctions
.
mMinSizingFunctions
[
j
]
aFunctions
.
mMaxSizingFunctions
[
j
]
)
;
}
i
+
=
j
;
for
(
;
i
<
mSizes
.
Length
(
)
;
+
+
i
)
{
mSizes
[
i
]
.
Initialize
(
aPercentageBasis
aFunctions
.
mAutoMinSizing
aFunctions
.
mAutoMaxSizing
)
;
}
}
static
nscoord
MinSize
(
nsIFrame
*
aChild
nsRenderingContext
*
aRC
WritingMode
aCBWM
nsGridContainerFrame
:
:
Dimension
aDimension
nsLayoutUtils
:
:
IntrinsicISizeType
aConstraint
)
{
PhysicalAxis
axis
(
(
(
aDimension
=
=
nsGridContainerFrame
:
:
eColDimension
)
=
=
aCBWM
.
IsVertical
(
)
)
?
eAxisVertical
:
eAxisHorizontal
)
;
return
nsLayoutUtils
:
:
MinSizeContributionForAxis
(
axis
aRC
aChild
aConstraint
)
;
}
static
nscoord
ContentContribution
(
nsIFrame
*
aChild
const
nsHTMLReflowState
*
aReflowState
nsRenderingContext
*
aRC
WritingMode
aCBWM
nsGridContainerFrame
:
:
Dimension
aDimension
nsLayoutUtils
:
:
IntrinsicISizeType
aConstraint
)
{
PhysicalAxis
axis
(
(
(
aDimension
=
=
nsGridContainerFrame
:
:
eColDimension
)
=
=
aCBWM
.
IsVertical
(
)
)
?
eAxisVertical
:
eAxisHorizontal
)
;
nscoord
size
=
nsLayoutUtils
:
:
IntrinsicForAxis
(
axis
aRC
aChild
aConstraint
nsLayoutUtils
:
:
BAIL_IF_REFLOW_NEEDED
)
;
if
(
size
=
=
NS_INTRINSIC_WIDTH_UNKNOWN
)
{
WritingMode
wm
=
aChild
-
>
GetWritingMode
(
)
;
nsContainerFrame
*
parent
=
aChild
-
>
GetParent
(
)
;
nsPresContext
*
pc
=
aChild
-
>
PresContext
(
)
;
Maybe
<
nsHTMLReflowState
>
dummyParentState
;
const
nsHTMLReflowState
*
rs
=
aReflowState
;
if
(
!
aReflowState
)
{
MOZ_ASSERT
(
!
parent
-
>
HasAnyStateBits
(
NS_FRAME_IN_REFLOW
)
)
;
dummyParentState
.
emplace
(
pc
parent
aRC
LogicalSize
(
parent
-
>
GetWritingMode
(
)
0
NS_UNCONSTRAINEDSIZE
)
nsHTMLReflowState
:
:
DUMMY_PARENT_REFLOW_STATE
)
;
rs
=
dummyParentState
.
ptr
(
)
;
}
#
ifdef
DEBUG
parent
-
>
Properties
(
)
.
Set
(
nsContainerFrame
:
:
DebugReflowingWithInfiniteISize
(
)
parent
)
;
#
endif
LogicalSize
availableSize
(
wm
INFINITE_ISIZE_COORD
NS_UNCONSTRAINEDSIZE
)
;
nsHTMLReflowState
childRS
(
pc
*
rs
aChild
availableSize
)
;
nsHTMLReflowMetrics
childSize
(
childRS
)
;
nsReflowStatus
childStatus
;
const
uint32_t
flags
=
NS_FRAME_NO_MOVE_FRAME
|
NS_FRAME_NO_SIZE_VIEW
;
parent
-
>
ReflowChild
(
aChild
pc
childSize
childRS
wm
LogicalPoint
(
wm
)
nsSize
(
)
flags
childStatus
)
;
parent
-
>
FinishReflowChild
(
aChild
pc
childSize
&
childRS
wm
LogicalPoint
(
wm
)
nsSize
(
)
flags
)
;
size
=
childSize
.
BSize
(
wm
)
;
nsIFrame
:
:
IntrinsicISizeOffsetData
offsets
=
aChild
-
>
IntrinsicBSizeOffsets
(
)
;
size
+
=
offsets
.
hMargin
;
size
=
nsLayoutUtils
:
:
AddPercents
(
aConstraint
size
offsets
.
hPctMargin
)
;
#
ifdef
DEBUG
parent
-
>
Properties
(
)
.
Delete
(
nsContainerFrame
:
:
DebugReflowingWithInfiniteISize
(
)
)
;
#
endif
}
return
std
:
:
max
(
size
0
)
;
}
static
nscoord
MinContentContribution
(
nsIFrame
*
aChild
const
nsHTMLReflowState
*
aRS
nsRenderingContext
*
aRC
WritingMode
aCBWM
nsGridContainerFrame
:
:
Dimension
aDimension
)
{
return
ContentContribution
(
aChild
aRS
aRC
aCBWM
aDimension
nsLayoutUtils
:
:
MIN_ISIZE
)
;
}
static
nscoord
MaxContentContribution
(
nsIFrame
*
aChild
const
nsHTMLReflowState
*
aRS
nsRenderingContext
*
aRC
WritingMode
aCBWM
nsGridContainerFrame
:
:
Dimension
aDimension
)
{
return
ContentContribution
(
aChild
aRS
aRC
aCBWM
aDimension
nsLayoutUtils
:
:
PREF_ISIZE
)
;
}
void
nsGridContainerFrame
:
:
CalculateTrackSizes
(
GridReflowState
&
aState
const
LogicalSize
&
aContentBox
IntrinsicISizeType
aConstraint
)
{
aState
.
mCols
.
mSizes
.
SetLength
(
mGridColEnd
)
;
PodZero
(
aState
.
mCols
.
mSizes
.
Elements
(
)
aState
.
mCols
.
mSizes
.
Length
(
)
)
;
const
WritingMode
&
wm
=
aState
.
mWM
;
nscoord
colPercentageBasis
=
aContentBox
.
ISize
(
wm
)
;
auto
&
colFunctions
=
aState
.
mColFunctions
;
aState
.
mCols
.
Initialize
(
colFunctions
colPercentageBasis
)
;
aState
.
mCols
.
ResolveIntrinsicSize
(
aState
mGridItems
colFunctions
&
GridArea
:
:
mCols
colPercentageBasis
aConstraint
)
;
if
(
aConstraint
!
=
nsLayoutUtils
:
:
MIN_ISIZE
)
{
nscoord
size
=
aContentBox
.
ISize
(
wm
)
;
aState
.
mCols
.
DistributeFreeSpace
(
size
)
;
aState
.
mCols
.
StretchFlexibleTracks
(
aState
mGridItems
colFunctions
size
)
;
}
aState
.
mRows
.
mSizes
.
SetLength
(
mGridRowEnd
)
;
PodZero
(
aState
.
mRows
.
mSizes
.
Elements
(
)
aState
.
mRows
.
mSizes
.
Length
(
)
)
;
nscoord
rowPercentageBasis
=
aContentBox
.
BSize
(
wm
)
;
if
(
rowPercentageBasis
=
=
NS_AUTOHEIGHT
)
{
rowPercentageBasis
=
0
;
}
auto
&
rowFunctions
=
aState
.
mRowFunctions
;
aState
.
mRows
.
Initialize
(
rowFunctions
rowPercentageBasis
)
;
aState
.
mIter
.
Reset
(
)
;
aState
.
mRows
.
ResolveIntrinsicSize
(
aState
mGridItems
rowFunctions
&
GridArea
:
:
mRows
rowPercentageBasis
aConstraint
)
;
if
(
aConstraint
!
=
nsLayoutUtils
:
:
MIN_ISIZE
)
{
nscoord
size
=
aContentBox
.
BSize
(
wm
)
;
aState
.
mRows
.
DistributeFreeSpace
(
size
)
;
aState
.
mRows
.
StretchFlexibleTracks
(
aState
mGridItems
rowFunctions
size
)
;
}
}
bool
nsGridContainerFrame
:
:
Tracks
:
:
HasIntrinsicButNoFlexSizingInRange
(
const
LineRange
&
aRange
IntrinsicISizeType
aConstraint
TrackSize
:
:
StateBits
*
aState
)
const
{
MOZ_ASSERT
(
!
aRange
.
IsAuto
(
)
"
must
have
a
definite
range
"
)
;
const
uint32_t
start
=
aRange
.
mStart
;
const
uint32_t
end
=
aRange
.
mEnd
;
const
TrackSize
:
:
StateBits
selector
=
TrackSize
:
:
eIntrinsicMinSizing
|
TrackSize
:
:
eIntrinsicMaxSizing
|
(
aConstraint
=
=
nsLayoutUtils
:
:
MIN_ISIZE
?
TrackSize
:
:
eFlexMinSizing
:
TrackSize
:
:
StateBits
(
0
)
)
;
bool
foundIntrinsic
=
false
;
for
(
uint32_t
i
=
start
;
i
<
end
;
+
+
i
)
{
TrackSize
:
:
StateBits
state
=
mSizes
[
i
]
.
mState
;
*
aState
|
=
state
;
if
(
state
&
TrackSize
:
:
eFlexMaxSizing
)
{
return
false
;
}
if
(
state
&
selector
)
{
foundIntrinsic
=
true
;
}
}
return
foundIntrinsic
;
}
bool
nsGridContainerFrame
:
:
Tracks
:
:
ResolveIntrinsicSizeStep1
(
GridReflowState
&
aState
const
TrackSizingFunctions
&
aFunctions
nscoord
aPercentageBasis
IntrinsicISizeType
aConstraint
const
LineRange
&
aRange
nsIFrame
*
aGridItem
)
{
Maybe
<
nscoord
>
minContentContribution
;
Maybe
<
nscoord
>
maxContentContribution
;
TrackSize
&
sz
=
mSizes
[
aRange
.
mStart
]
;
WritingMode
wm
=
aState
.
mWM
;
const
nsHTMLReflowState
*
rs
=
aState
.
mReflowState
;
nsRenderingContext
*
rc
=
&
aState
.
mRenderingContext
;
if
(
sz
.
mState
&
TrackSize
:
:
eAutoMinSizing
)
{
nscoord
s
=
MinSize
(
aGridItem
rc
wm
mDimension
aConstraint
)
;
sz
.
mBase
=
std
:
:
max
(
sz
.
mBase
s
)
;
}
else
if
(
(
sz
.
mState
&
TrackSize
:
:
eMinContentMinSizing
)
|
|
(
aConstraint
=
=
nsLayoutUtils
:
:
MIN_ISIZE
&
&
(
sz
.
mState
&
TrackSize
:
:
eFlexMinSizing
)
)
)
{
nscoord
s
=
MinContentContribution
(
aGridItem
rs
rc
wm
mDimension
)
;
minContentContribution
.
emplace
(
s
)
;
sz
.
mBase
=
std
:
:
max
(
sz
.
mBase
minContentContribution
.
value
(
)
)
;
}
else
if
(
sz
.
mState
&
TrackSize
:
:
eMaxContentMinSizing
)
{
nscoord
s
=
MaxContentContribution
(
aGridItem
rs
rc
wm
mDimension
)
;
maxContentContribution
.
emplace
(
s
)
;
sz
.
mBase
=
std
:
:
max
(
sz
.
mBase
maxContentContribution
.
value
(
)
)
;
}
if
(
sz
.
mState
&
TrackSize
:
:
eMinContentMaxSizing
)
{
if
(
minContentContribution
.
isNothing
(
)
)
{
nscoord
s
=
MinContentContribution
(
aGridItem
rs
rc
wm
mDimension
)
;
minContentContribution
.
emplace
(
s
)
;
}
if
(
sz
.
mLimit
=
=
NS_UNCONSTRAINEDSIZE
)
{
sz
.
mLimit
=
minContentContribution
.
value
(
)
;
}
else
{
sz
.
mLimit
=
std
:
:
max
(
sz
.
mLimit
minContentContribution
.
value
(
)
)
;
}
}
else
if
(
sz
.
mState
&
(
TrackSize
:
:
eAutoMaxSizing
|
TrackSize
:
:
eMaxContentMaxSizing
)
)
{
if
(
maxContentContribution
.
isNothing
(
)
)
{
nscoord
s
=
MaxContentContribution
(
aGridItem
rs
rc
wm
mDimension
)
;
maxContentContribution
.
emplace
(
s
)
;
}
if
(
sz
.
mLimit
=
=
NS_UNCONSTRAINEDSIZE
)
{
sz
.
mLimit
=
maxContentContribution
.
value
(
)
;
}
else
{
sz
.
mLimit
=
std
:
:
max
(
sz
.
mLimit
maxContentContribution
.
value
(
)
)
;
}
}
if
(
sz
.
mLimit
<
sz
.
mBase
)
{
sz
.
mLimit
=
sz
.
mBase
;
}
return
sz
.
mState
&
TrackSize
:
:
eFlexMaxSizing
;
}
void
nsGridContainerFrame
:
:
Tracks
:
:
ResolveIntrinsicSize
(
GridReflowState
&
aState
nsTArray
<
GridItemInfo
>
&
aGridItems
const
TrackSizingFunctions
&
aFunctions
LineRange
GridArea
:
:
*
aRange
nscoord
aPercentageBasis
IntrinsicISizeType
aConstraint
)
{
struct
Step2ItemData
{
uint32_t
mSpan
;
TrackSize
:
:
StateBits
mState
;
LineRange
mLineRange
;
nscoord
mMinSize
;
nscoord
mMinContentContribution
;
nscoord
mMaxContentContribution
;
nsIFrame
*
mFrame
;
static
bool
IsSpanLessThan
(
const
Step2ItemData
&
a
const
Step2ItemData
&
b
)
{
return
a
.
mSpan
<
b
.
mSpan
;
}
}
;
nsAutoTArray
<
TrackSize
:
:
StateBits
16
>
stateBitsPerSpan
;
nsTArray
<
Step2ItemData
>
step2Items
;
GridItemCSSOrderIterator
&
iter
=
aState
.
mIter
;
nsRenderingContext
*
rc
=
&
aState
.
mRenderingContext
;
WritingMode
wm
=
aState
.
mWM
;
uint32_t
maxSpan
=
0
;
const
TrackSize
:
:
StateBits
flexMin
=
aConstraint
=
=
nsLayoutUtils
:
:
MIN_ISIZE
?
TrackSize
:
:
eFlexMinSizing
:
TrackSize
:
:
StateBits
(
0
)
;
for
(
;
!
iter
.
AtEnd
(
)
;
iter
.
Next
(
)
)
{
nsIFrame
*
child
=
*
iter
;
const
GridArea
&
area
=
aGridItems
[
iter
.
GridItemIndex
(
)
]
.
mArea
;
const
LineRange
&
lineRange
=
area
.
*
aRange
;
uint32_t
span
=
lineRange
.
Extent
(
)
;
if
(
span
=
=
1
)
{
aGridItems
[
iter
.
GridItemIndex
(
)
]
.
mIsFlexing
[
mDimension
]
=
ResolveIntrinsicSizeStep1
(
aState
aFunctions
aPercentageBasis
aConstraint
lineRange
child
)
;
}
else
{
TrackSize
:
:
StateBits
state
=
TrackSize
:
:
StateBits
(
0
)
;
if
(
HasIntrinsicButNoFlexSizingInRange
(
lineRange
aConstraint
&
state
)
)
{
maxSpan
=
std
:
:
max
(
maxSpan
span
)
;
if
(
span
>
=
stateBitsPerSpan
.
Length
(
)
)
{
uint32_t
len
=
2
*
span
;
stateBitsPerSpan
.
SetCapacity
(
len
)
;
for
(
uint32_t
i
=
stateBitsPerSpan
.
Length
(
)
;
i
<
len
;
+
+
i
)
{
stateBitsPerSpan
.
AppendElement
(
TrackSize
:
:
StateBits
(
0
)
)
;
}
}
stateBitsPerSpan
[
span
]
|
=
state
;
nscoord
minSize
=
0
;
if
(
state
&
(
flexMin
|
TrackSize
:
:
eIntrinsicMinSizing
)
)
{
minSize
=
MinSize
(
child
rc
wm
mDimension
aConstraint
)
;
}
nscoord
minContent
=
0
;
if
(
state
&
(
flexMin
|
TrackSize
:
:
eMinOrMaxContentMinSizing
|
TrackSize
:
:
eIntrinsicMaxSizing
)
)
{
minContent
=
MinContentContribution
(
child
aState
.
mReflowState
rc
wm
mDimension
)
;
}
nscoord
maxContent
=
0
;
if
(
state
&
(
TrackSize
:
:
eMaxContentMinSizing
|
TrackSize
:
:
eAutoOrMaxContentMaxSizing
)
)
{
maxContent
=
MaxContentContribution
(
child
aState
.
mReflowState
rc
wm
mDimension
)
;
}
step2Items
.
AppendElement
(
Step2ItemData
(
{
span
state
lineRange
minSize
minContent
maxContent
child
}
)
)
;
}
else
{
aGridItems
[
iter
.
GridItemIndex
(
)
]
.
mIsFlexing
[
mDimension
]
=
!
!
(
state
&
TrackSize
:
:
eFlexMaxSizing
)
;
}
}
}
if
(
maxSpan
)
{
std
:
:
stable_sort
(
step2Items
.
begin
(
)
step2Items
.
end
(
)
Step2ItemData
:
:
IsSpanLessThan
)
;
nsTArray
<
uint32_t
>
tracks
(
maxSpan
)
;
nsTArray
<
TrackSize
>
plan
(
mSizes
.
Length
(
)
)
;
plan
.
SetLength
(
mSizes
.
Length
(
)
)
;
for
(
uint32_t
i
=
0
len
=
step2Items
.
Length
(
)
;
i
<
len
;
)
{
const
uint32_t
spanGroupStartIndex
=
i
;
uint32_t
spanGroupEndIndex
=
len
;
const
uint32_t
span
=
step2Items
[
i
]
.
mSpan
;
for
(
+
+
i
;
i
<
len
;
+
+
i
)
{
if
(
step2Items
[
i
]
.
mSpan
!
=
span
)
{
spanGroupEndIndex
=
i
;
break
;
}
}
bool
updatedBase
=
false
;
TrackSize
:
:
StateBits
selector
(
flexMin
|
TrackSize
:
:
eIntrinsicMinSizing
)
;
if
(
stateBitsPerSpan
[
span
]
&
selector
)
{
for
(
i
=
spanGroupStartIndex
;
i
<
spanGroupEndIndex
;
+
+
i
)
{
Step2ItemData
&
item
=
step2Items
[
i
]
;
if
(
!
(
item
.
mState
&
selector
)
)
{
continue
;
}
nscoord
space
=
item
.
mMinSize
;
if
(
space
<
=
0
)
{
continue
;
}
tracks
.
ClearAndRetainStorage
(
)
;
space
=
CollectGrowable
(
space
mSizes
item
.
mLineRange
selector
tracks
)
;
if
(
space
>
0
)
{
DistributeToTrackBases
(
space
plan
tracks
selector
)
;
updatedBase
=
true
;
}
}
}
selector
=
flexMin
|
TrackSize
:
:
eMinOrMaxContentMinSizing
;
if
(
stateBitsPerSpan
[
span
]
&
selector
)
{
for
(
i
=
spanGroupStartIndex
;
i
<
spanGroupEndIndex
;
+
+
i
)
{
Step2ItemData
&
item
=
step2Items
[
i
]
;
if
(
!
(
item
.
mState
&
selector
)
)
{
continue
;
}
nscoord
space
=
item
.
mMinContentContribution
;
if
(
space
<
=
0
)
{
continue
;
}
tracks
.
ClearAndRetainStorage
(
)
;
space
=
CollectGrowable
(
space
mSizes
item
.
mLineRange
selector
tracks
)
;
if
(
space
>
0
)
{
DistributeToTrackBases
(
space
plan
tracks
selector
)
;
updatedBase
=
true
;
}
}
}
if
(
stateBitsPerSpan
[
span
]
&
TrackSize
:
:
eMaxContentMinSizing
)
{
for
(
i
=
spanGroupStartIndex
;
i
<
spanGroupEndIndex
;
+
+
i
)
{
Step2ItemData
&
item
=
step2Items
[
i
]
;
if
(
!
(
item
.
mState
&
TrackSize
:
:
eMaxContentMinSizing
)
)
{
continue
;
}
nscoord
space
=
item
.
mMaxContentContribution
;
if
(
space
<
=
0
)
{
continue
;
}
tracks
.
ClearAndRetainStorage
(
)
;
space
=
CollectGrowable
(
space
mSizes
item
.
mLineRange
TrackSize
:
:
eMaxContentMinSizing
tracks
)
;
if
(
space
>
0
)
{
DistributeToTrackBases
(
space
plan
tracks
TrackSize
:
:
eMaxContentMinSizing
)
;
updatedBase
=
true
;
}
}
}
if
(
updatedBase
)
{
for
(
TrackSize
&
sz
:
mSizes
)
{
if
(
sz
.
mBase
>
sz
.
mLimit
)
{
sz
.
mLimit
=
sz
.
mBase
;
}
}
}
if
(
stateBitsPerSpan
[
span
]
&
TrackSize
:
:
eIntrinsicMaxSizing
)
{
plan
=
mSizes
;
for
(
TrackSize
&
sz
:
plan
)
{
if
(
sz
.
mLimit
=
=
NS_UNCONSTRAINEDSIZE
)
{
}
else
{
sz
.
mBase
=
sz
.
mLimit
;
}
}
for
(
i
=
spanGroupStartIndex
;
i
<
spanGroupEndIndex
;
+
+
i
)
{
Step2ItemData
&
item
=
step2Items
[
i
]
;
if
(
!
(
item
.
mState
&
TrackSize
:
:
eIntrinsicMaxSizing
)
)
{
continue
;
}
nscoord
space
=
item
.
mMinContentContribution
;
if
(
space
<
=
0
)
{
continue
;
}
tracks
.
ClearAndRetainStorage
(
)
;
space
=
CollectGrowable
(
space
plan
item
.
mLineRange
TrackSize
:
:
eIntrinsicMaxSizing
tracks
)
;
if
(
space
>
0
)
{
DistributeToTrackLimits
(
space
plan
tracks
)
;
}
}
for
(
size_t
j
=
0
len
=
mSizes
.
Length
(
)
;
j
<
len
;
+
+
j
)
{
TrackSize
&
sz
=
plan
[
j
]
;
sz
.
mState
&
=
~
(
TrackSize
:
:
eFrozen
|
TrackSize
:
:
eSkipGrowUnlimited
)
;
if
(
sz
.
mLimit
!
=
NS_UNCONSTRAINEDSIZE
)
{
sz
.
mLimit
=
sz
.
mBase
;
}
}
if
(
stateBitsPerSpan
[
span
]
&
TrackSize
:
:
eAutoOrMaxContentMaxSizing
)
{
for
(
i
=
spanGroupStartIndex
;
i
<
spanGroupEndIndex
;
+
+
i
)
{
Step2ItemData
&
item
=
step2Items
[
i
]
;
if
(
!
(
item
.
mState
&
TrackSize
:
:
eAutoOrMaxContentMaxSizing
)
)
{
continue
;
}
nscoord
space
=
item
.
mMaxContentContribution
;
if
(
space
<
=
0
)
{
continue
;
}
tracks
.
ClearAndRetainStorage
(
)
;
space
=
CollectGrowable
(
space
plan
item
.
mLineRange
TrackSize
:
:
eAutoOrMaxContentMaxSizing
tracks
)
;
if
(
space
>
0
)
{
DistributeToTrackLimits
(
space
plan
tracks
)
;
}
}
}
}
}
}
for
(
TrackSize
&
sz
:
mSizes
)
{
if
(
sz
.
mLimit
=
=
NS_UNCONSTRAINEDSIZE
)
{
sz
.
mLimit
=
sz
.
mBase
;
}
}
}
float
nsGridContainerFrame
:
:
Tracks
:
:
FindFrUnitSize
(
const
LineRange
&
aRange
const
nsTArray
<
uint32_t
>
&
aFlexTracks
const
TrackSizingFunctions
&
aFunctions
nscoord
aSpaceToFill
)
const
{
MOZ_ASSERT
(
aSpaceToFill
>
0
&
&
!
aFlexTracks
.
IsEmpty
(
)
)
;
float
flexFactorSum
=
0
.
0f
;
nscoord
leftOverSpace
=
aSpaceToFill
;
for
(
uint32_t
i
=
aRange
.
mStart
end
=
aRange
.
mEnd
;
i
<
end
;
+
+
i
)
{
const
TrackSize
&
sz
=
mSizes
[
i
]
;
if
(
sz
.
mState
&
TrackSize
:
:
eFlexMaxSizing
)
{
flexFactorSum
+
=
aFunctions
.
MaxSizingFor
(
i
)
.
GetFlexFractionValue
(
)
;
}
else
{
leftOverSpace
-
=
sz
.
mBase
;
if
(
leftOverSpace
<
=
0
)
{
return
0
.
0f
;
}
}
}
bool
restart
;
float
hypotheticalFrSize
;
nsTArray
<
uint32_t
>
flexTracks
(
aFlexTracks
)
;
uint32_t
numFlexTracks
=
flexTracks
.
Length
(
)
;
do
{
restart
=
false
;
hypotheticalFrSize
=
leftOverSpace
/
std
:
:
max
(
flexFactorSum
1
.
0f
)
;
for
(
uint32_t
i
=
0
len
=
flexTracks
.
Length
(
)
;
i
<
len
;
+
+
i
)
{
uint32_t
track
=
flexTracks
[
i
]
;
if
(
track
=
=
kAutoLine
)
{
continue
;
}
float
flexFactor
=
aFunctions
.
MaxSizingFor
(
track
)
.
GetFlexFractionValue
(
)
;
const
nscoord
base
=
mSizes
[
track
]
.
mBase
;
if
(
flexFactor
*
hypotheticalFrSize
<
base
)
{
flexTracks
[
i
]
=
kAutoLine
;
flexFactorSum
-
=
flexFactor
;
leftOverSpace
-
=
base
;
-
-
numFlexTracks
;
if
(
numFlexTracks
=
=
0
|
|
leftOverSpace
<
=
0
)
{
return
0
.
0f
;
}
restart
=
true
;
}
}
}
while
(
restart
)
;
return
hypotheticalFrSize
;
}
float
nsGridContainerFrame
:
:
Tracks
:
:
FindUsedFlexFraction
(
GridReflowState
&
aState
nsTArray
<
GridItemInfo
>
&
aGridItems
const
nsTArray
<
uint32_t
>
&
aFlexTracks
const
TrackSizingFunctions
&
aFunctions
nscoord
aAvailableSize
)
const
{
if
(
aAvailableSize
!
=
NS_UNCONSTRAINEDSIZE
)
{
const
TranslatedLineRange
range
(
0
mSizes
.
Length
(
)
)
;
return
FindFrUnitSize
(
range
aFlexTracks
aFunctions
aAvailableSize
)
;
}
float
fr
=
0
.
0f
;
for
(
uint32_t
track
:
aFlexTracks
)
{
float
flexFactor
=
aFunctions
.
MaxSizingFor
(
track
)
.
GetFlexFractionValue
(
)
;
if
(
flexFactor
>
0
.
0f
)
{
fr
=
std
:
:
max
(
fr
mSizes
[
track
]
.
mBase
/
flexFactor
)
;
}
}
WritingMode
wm
=
aState
.
mWM
;
nsRenderingContext
*
rc
=
&
aState
.
mRenderingContext
;
const
nsHTMLReflowState
*
rs
=
aState
.
mReflowState
;
GridItemCSSOrderIterator
&
iter
=
aState
.
mIter
;
iter
.
Reset
(
)
;
for
(
;
!
iter
.
AtEnd
(
)
;
iter
.
Next
(
)
)
{
const
GridItemInfo
&
item
=
aGridItems
[
iter
.
GridItemIndex
(
)
]
;
if
(
item
.
mIsFlexing
[
mDimension
]
)
{
nscoord
spaceToFill
=
MaxContentContribution
(
*
iter
rs
rc
wm
mDimension
)
;
if
(
spaceToFill
<
=
0
)
{
continue
;
}
const
LineRange
&
range
=
mDimension
=
=
eColDimension
?
item
.
mArea
.
mCols
:
item
.
mArea
.
mRows
;
nsTArray
<
uint32_t
>
itemFlexTracks
;
for
(
uint32_t
i
=
range
.
mStart
end
=
range
.
mEnd
;
i
<
end
;
+
+
i
)
{
if
(
mSizes
[
i
]
.
mState
&
TrackSize
:
:
eFlexMaxSizing
)
{
itemFlexTracks
.
AppendElement
(
i
)
;
}
}
float
itemFr
=
FindFrUnitSize
(
range
itemFlexTracks
aFunctions
spaceToFill
)
;
fr
=
std
:
:
max
(
fr
itemFr
)
;
}
}
return
fr
;
}
void
nsGridContainerFrame
:
:
Tracks
:
:
StretchFlexibleTracks
(
GridReflowState
&
aState
nsTArray
<
GridItemInfo
>
&
aGridItems
const
TrackSizingFunctions
&
aFunctions
nscoord
aAvailableSize
)
{
if
(
aAvailableSize
<
=
0
)
{
return
;
}
nsTArray
<
uint32_t
>
flexTracks
(
mSizes
.
Length
(
)
)
;
for
(
uint32_t
i
=
0
len
=
mSizes
.
Length
(
)
;
i
<
len
;
+
+
i
)
{
if
(
mSizes
[
i
]
.
mState
&
TrackSize
:
:
eFlexMaxSizing
)
{
flexTracks
.
AppendElement
(
i
)
;
}
}
if
(
flexTracks
.
IsEmpty
(
)
)
{
return
;
}
float
fr
=
FindUsedFlexFraction
(
aState
aGridItems
flexTracks
aFunctions
aAvailableSize
)
;
if
(
fr
!
=
0
.
0f
)
{
for
(
uint32_t
i
:
flexTracks
)
{
float
flexFactor
=
aFunctions
.
MaxSizingFor
(
i
)
.
GetFlexFractionValue
(
)
;
nscoord
flexLength
=
NSToCoordRound
(
flexFactor
*
fr
)
;
nscoord
&
base
=
mSizes
[
i
]
.
mBase
;
if
(
flexLength
>
base
)
{
base
=
flexLength
;
}
}
}
}
void
nsGridContainerFrame
:
:
LineRange
:
:
ToPositionAndLength
(
const
nsTArray
<
TrackSize
>
&
aTrackSizes
nscoord
*
aPos
nscoord
*
aLength
)
const
{
MOZ_ASSERT
(
mStart
!
=
kAutoLine
&
&
mEnd
!
=
kAutoLine
"
expected
a
definite
LineRange
"
)
;
nscoord
pos
=
0
;
const
uint32_t
start
=
mStart
;
uint32_t
i
=
0
;
for
(
;
i
<
start
;
+
+
i
)
{
pos
+
=
aTrackSizes
[
i
]
.
mBase
;
}
*
aPos
=
pos
;
nscoord
length
=
0
;
const
uint32_t
end
=
mEnd
;
MOZ_ASSERT
(
end
<
=
aTrackSizes
.
Length
(
)
"
aTrackSizes
isn
'
t
large
enough
"
)
;
for
(
;
i
<
end
;
+
+
i
)
{
length
+
=
aTrackSizes
[
i
]
.
mBase
;
}
*
aLength
=
length
;
}
void
nsGridContainerFrame
:
:
LineRange
:
:
ToPositionAndLengthForAbsPos
(
const
nsTArray
<
TrackSize
>
&
aTrackSizes
nscoord
aGridOrigin
nscoord
*
aPos
nscoord
*
aLength
)
const
{
if
(
mEnd
=
=
kAutoLine
)
{
if
(
mStart
=
=
kAutoLine
)
{
}
else
{
const
nscoord
endPos
=
*
aPos
+
*
aLength
;
nscoord
startPos
=
:
:
GridLinePosition
(
mStart
aTrackSizes
)
;
*
aPos
=
aGridOrigin
+
startPos
;
*
aLength
=
std
:
:
max
(
endPos
-
*
aPos
0
)
;
}
}
else
{
if
(
mStart
=
=
kAutoLine
)
{
nscoord
endPos
=
:
:
GridLinePosition
(
mEnd
aTrackSizes
)
;
*
aLength
=
std
:
:
max
(
aGridOrigin
+
endPos
0
)
;
}
else
{
nscoord
pos
;
ToPositionAndLength
(
aTrackSizes
&
pos
aLength
)
;
*
aPos
=
aGridOrigin
+
pos
;
}
}
}
LogicalRect
nsGridContainerFrame
:
:
ContainingBlockFor
(
const
GridReflowState
&
aState
const
GridArea
&
aArea
)
const
{
nscoord
i
b
iSize
bSize
;
MOZ_ASSERT
(
aArea
.
mCols
.
Extent
(
)
>
0
"
grid
items
cover
at
least
one
track
"
)
;
MOZ_ASSERT
(
aArea
.
mRows
.
Extent
(
)
>
0
"
grid
items
cover
at
least
one
track
"
)
;
aArea
.
mCols
.
ToPositionAndLength
(
aState
.
mCols
.
mSizes
&
i
&
iSize
)
;
aArea
.
mRows
.
ToPositionAndLength
(
aState
.
mRows
.
mSizes
&
b
&
bSize
)
;
return
LogicalRect
(
aState
.
mWM
i
b
iSize
bSize
)
;
}
LogicalRect
nsGridContainerFrame
:
:
ContainingBlockForAbsPos
(
const
GridReflowState
&
aState
const
GridArea
&
aArea
const
LogicalPoint
&
aGridOrigin
const
LogicalRect
&
aGridCB
)
const
{
const
WritingMode
&
wm
=
aState
.
mWM
;
nscoord
i
=
aGridCB
.
IStart
(
wm
)
;
nscoord
b
=
aGridCB
.
BStart
(
wm
)
;
nscoord
iSize
=
aGridCB
.
ISize
(
wm
)
;
nscoord
bSize
=
aGridCB
.
BSize
(
wm
)
;
aArea
.
mCols
.
ToPositionAndLengthForAbsPos
(
aState
.
mCols
.
mSizes
aGridOrigin
.
I
(
wm
)
&
i
&
iSize
)
;
aArea
.
mRows
.
ToPositionAndLengthForAbsPos
(
aState
.
mRows
.
mSizes
aGridOrigin
.
B
(
wm
)
&
b
&
bSize
)
;
return
LogicalRect
(
wm
i
b
iSize
bSize
)
;
}
void
nsGridContainerFrame
:
:
ReflowChildren
(
GridReflowState
&
aState
const
LogicalRect
&
aContentArea
nsHTMLReflowMetrics
&
aDesiredSize
nsReflowStatus
&
aStatus
)
{
MOZ_ASSERT
(
aState
.
mReflowState
)
;
WritingMode
wm
=
aState
.
mReflowState
-
>
GetWritingMode
(
)
;
const
LogicalPoint
gridOrigin
(
aContentArea
.
Origin
(
wm
)
)
;
const
nsSize
containerSize
=
(
aContentArea
.
Size
(
wm
)
+
aState
.
mReflowState
-
>
ComputedLogicalBorderPadding
(
)
.
Size
(
wm
)
)
.
GetPhysicalSize
(
wm
)
;
nsPresContext
*
pc
=
PresContext
(
)
;
for
(
;
!
aState
.
mIter
.
AtEnd
(
)
;
aState
.
mIter
.
Next
(
)
)
{
nsIFrame
*
child
=
*
aState
.
mIter
;
const
bool
isGridItem
=
child
-
>
GetType
(
)
!
=
nsGkAtoms
:
:
placeholderFrame
;
LogicalRect
cb
(
wm
)
;
if
(
MOZ_LIKELY
(
isGridItem
)
)
{
MOZ_ASSERT
(
mGridItems
[
aState
.
mIter
.
GridItemIndex
(
)
]
.
mFrame
=
=
child
"
iterator
out
of
sync
with
mGridItems
"
)
;
GridArea
&
area
=
mGridItems
[
aState
.
mIter
.
GridItemIndex
(
)
]
.
mArea
;
MOZ_ASSERT
(
area
.
IsDefinite
(
)
)
;
cb
=
ContainingBlockFor
(
aState
area
)
;
cb
+
=
gridOrigin
;
}
else
{
cb
=
aContentArea
;
}
WritingMode
childWM
=
child
-
>
GetWritingMode
(
)
;
LogicalSize
childCBSize
=
cb
.
Size
(
wm
)
.
ConvertTo
(
childWM
wm
)
;
nsHTMLReflowState
childRS
(
pc
*
aState
.
mReflowState
child
childCBSize
)
;
const
LogicalMargin
margin
=
childRS
.
ComputedLogicalMargin
(
)
;
if
(
childRS
.
ComputedBSize
(
)
=
=
NS_AUTOHEIGHT
&
&
MOZ_LIKELY
(
isGridItem
)
)
{
LogicalMargin
bp
=
childRS
.
ComputedLogicalBorderPadding
(
)
;
bp
.
ApplySkipSides
(
child
-
>
GetLogicalSkipSides
(
)
)
;
nscoord
bSize
=
childCBSize
.
BSize
(
childWM
)
-
bp
.
BStartEnd
(
childWM
)
-
margin
.
BStartEnd
(
childWM
)
;
childRS
.
SetComputedBSize
(
std
:
:
max
(
bSize
0
)
)
;
}
nsHTMLReflowMetrics
childSize
(
childRS
)
;
nsReflowStatus
childStatus
;
const
nsSize
dummyContainerSize
;
ReflowChild
(
child
pc
childSize
childRS
childWM
LogicalPoint
(
childWM
)
dummyContainerSize
0
childStatus
)
;
LogicalPoint
childPos
=
cb
.
Origin
(
wm
)
.
ConvertTo
(
childWM
wm
containerSize
-
childSize
.
PhysicalSize
(
)
-
margin
.
Size
(
childWM
)
.
GetPhysicalSize
(
childWM
)
)
;
childPos
.
I
(
childWM
)
+
=
margin
.
IStart
(
childWM
)
;
childPos
.
B
(
childWM
)
+
=
margin
.
BStart
(
childWM
)
;
childRS
.
ApplyRelativePositioning
(
&
childPos
containerSize
)
;
FinishReflowChild
(
child
pc
childSize
&
childRS
childWM
childPos
containerSize
0
)
;
ConsiderChildOverflow
(
aDesiredSize
.
mOverflowAreas
child
)
;
}
if
(
IsAbsoluteContainer
(
)
)
{
nsFrameList
children
(
GetChildList
(
GetAbsoluteListID
(
)
)
)
;
if
(
!
children
.
IsEmpty
(
)
)
{
LogicalMargin
pad
(
aState
.
mReflowState
-
>
ComputedLogicalPadding
(
)
)
;
pad
.
ApplySkipSides
(
GetLogicalSkipSides
(
aState
.
mReflowState
)
)
;
const
LogicalPoint
gridOrigin
(
wm
pad
.
IStart
(
wm
)
pad
.
BStart
(
wm
)
)
;
const
LogicalRect
gridCB
(
wm
0
0
aContentArea
.
ISize
(
wm
)
+
pad
.
IStartEnd
(
wm
)
aContentArea
.
BSize
(
wm
)
+
pad
.
BStartEnd
(
wm
)
)
;
size_t
i
=
0
;
for
(
nsFrameList
:
:
Enumerator
e
(
children
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
+
+
i
)
{
nsIFrame
*
child
=
e
.
get
(
)
;
MOZ_ASSERT
(
i
<
mAbsPosItems
.
Length
(
)
)
;
MOZ_ASSERT
(
mAbsPosItems
[
i
]
.
mFrame
=
=
child
)
;
GridArea
&
area
=
mAbsPosItems
[
i
]
.
mArea
;
LogicalRect
itemCB
=
ContainingBlockForAbsPos
(
aState
area
gridOrigin
gridCB
)
;
nsRect
*
cb
=
static_cast
<
nsRect
*
>
(
child
-
>
Properties
(
)
.
Get
(
GridItemContainingBlockRect
(
)
)
)
;
if
(
!
cb
)
{
cb
=
new
nsRect
;
child
-
>
Properties
(
)
.
Set
(
GridItemContainingBlockRect
(
)
cb
)
;
}
*
cb
=
itemCB
.
GetPhysicalRect
(
wm
containerSize
)
;
}
nsRect
dummyRect
(
0
0
VERY_LIKELY_A_GRID_CONTAINER
0
)
;
GetAbsoluteContainingBlock
(
)
-
>
Reflow
(
this
pc
*
aState
.
mReflowState
aStatus
dummyRect
true
true
true
&
aDesiredSize
.
mOverflowAreas
)
;
}
}
}
void
nsGridContainerFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
nsHTMLReflowMetrics
&
aDesiredSize
const
nsHTMLReflowState
&
aReflowState
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsGridContainerFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowState
aDesiredSize
aStatus
)
;
if
(
IsFrameTreeTooDeep
(
aReflowState
aDesiredSize
aStatus
)
)
{
return
;
}
#
ifdef
DEBUG
SanityCheckAnonymousGridItems
(
)
;
#
endif
LogicalMargin
bp
=
aReflowState
.
ComputedLogicalBorderPadding
(
)
;
bp
.
ApplySkipSides
(
GetLogicalSkipSides
(
)
)
;
const
nsStylePosition
*
stylePos
=
aReflowState
.
mStylePosition
;
InitImplicitNamedAreas
(
stylePos
)
;
GridReflowState
gridReflowState
(
this
aReflowState
)
;
mIsNormalFlowInCSSOrder
=
gridReflowState
.
mIter
.
ItemsAreAlreadyInOrder
(
)
;
PlaceGridItems
(
gridReflowState
)
;
const
nscoord
computedBSize
=
aReflowState
.
ComputedBSize
(
)
;
const
nscoord
computedISize
=
aReflowState
.
ComputedISize
(
)
;
const
WritingMode
&
wm
=
gridReflowState
.
mWM
;
gridReflowState
.
mIter
.
Reset
(
)
;
CalculateTrackSizes
(
gridReflowState
LogicalSize
(
wm
computedISize
computedBSize
)
nsLayoutUtils
:
:
PREF_ISIZE
)
;
nscoord
bSize
=
0
;
if
(
computedBSize
=
=
NS_AUTOHEIGHT
)
{
for
(
uint32_t
i
=
0
;
i
<
mGridRowEnd
;
+
+
i
)
{
bSize
+
=
gridReflowState
.
mRows
.
mSizes
[
i
]
.
mBase
;
}
}
else
{
bSize
=
computedBSize
;
}
bSize
=
std
:
:
max
(
bSize
-
GetConsumedBSize
(
)
0
)
;
LogicalSize
desiredSize
(
wm
computedISize
+
bp
.
IStartEnd
(
wm
)
bSize
+
bp
.
BStartEnd
(
wm
)
)
;
aDesiredSize
.
SetSize
(
wm
desiredSize
)
;
aDesiredSize
.
SetOverflowAreasToDesiredBounds
(
)
;
LogicalRect
contentArea
(
wm
bp
.
IStart
(
wm
)
bp
.
BStart
(
wm
)
computedISize
bSize
)
;
gridReflowState
.
mIter
.
Reset
(
GridItemCSSOrderIterator
:
:
eIncludeAll
)
;
ReflowChildren
(
gridReflowState
contentArea
aDesiredSize
aStatus
)
;
FinishAndStoreOverflow
(
&
aDesiredSize
)
;
aStatus
=
NS_FRAME_COMPLETE
;
NS_FRAME_SET_TRUNCATION
(
aStatus
aReflowState
aDesiredSize
)
;
}
nsIAtom
*
nsGridContainerFrame
:
:
GetType
(
)
const
{
return
nsGkAtoms
:
:
gridContainerFrame
;
}
void
nsGridContainerFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aDirtyRect
const
nsDisplayListSet
&
aLists
)
{
DisplayBorderBackgroundOutline
(
aBuilder
aLists
)
;
nsDisplayList
positionedDescendants
;
nsDisplayListSet
childLists
(
aLists
.
BlockBorderBackgrounds
(
)
aLists
.
BlockBorderBackgrounds
(
)
aLists
.
Floats
(
)
aLists
.
Content
(
)
&
positionedDescendants
aLists
.
Outlines
(
)
)
;
typedef
GridItemCSSOrderIterator
:
:
OrderState
OrderState
;
OrderState
order
=
mIsNormalFlowInCSSOrder
?
OrderState
:
:
eKnownOrdered
:
OrderState
:
:
eKnownUnordered
;
GridItemCSSOrderIterator
iter
(
this
kPrincipalList
GridItemCSSOrderIterator
:
:
eIncludeAll
order
)
;
for
(
;
!
iter
.
AtEnd
(
)
;
iter
.
Next
(
)
)
{
nsIFrame
*
child
=
*
iter
;
BuildDisplayListForChild
(
aBuilder
child
aDirtyRect
childLists
:
:
GetDisplayFlagsForGridItem
(
child
)
)
;
}
positionedDescendants
.
SortByCSSOrder
(
aBuilder
)
;
aLists
.
PositionedDescendants
(
)
-
>
AppendToTop
(
&
positionedDescendants
)
;
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
nsGridContainerFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
NS_LITERAL_STRING
(
"
GridContainer
"
)
aResult
)
;
}
#
endif
void
nsGridContainerFrame
:
:
CellMap
:
:
Fill
(
const
GridArea
&
aGridArea
)
{
MOZ_ASSERT
(
aGridArea
.
IsDefinite
(
)
)
;
MOZ_ASSERT
(
aGridArea
.
mRows
.
mStart
<
aGridArea
.
mRows
.
mEnd
)
;
MOZ_ASSERT
(
aGridArea
.
mCols
.
mStart
<
aGridArea
.
mCols
.
mEnd
)
;
const
auto
numRows
=
aGridArea
.
mRows
.
mEnd
;
const
auto
numCols
=
aGridArea
.
mCols
.
mEnd
;
mCells
.
EnsureLengthAtLeast
(
numRows
)
;
for
(
auto
i
=
aGridArea
.
mRows
.
mStart
;
i
<
numRows
;
+
+
i
)
{
nsTArray
<
Cell
>
&
cellsInRow
=
mCells
[
i
]
;
cellsInRow
.
EnsureLengthAtLeast
(
numCols
)
;
for
(
auto
j
=
aGridArea
.
mCols
.
mStart
;
j
<
numCols
;
+
+
j
)
{
cellsInRow
[
j
]
.
mIsOccupied
=
true
;
}
}
}
void
nsGridContainerFrame
:
:
CellMap
:
:
ClearOccupied
(
)
{
const
size_t
numRows
=
mCells
.
Length
(
)
;
for
(
size_t
i
=
0
;
i
<
numRows
;
+
+
i
)
{
nsTArray
<
Cell
>
&
cellsInRow
=
mCells
[
i
]
;
const
size_t
numCols
=
cellsInRow
.
Length
(
)
;
for
(
size_t
j
=
0
;
j
<
numCols
;
+
+
j
)
{
cellsInRow
[
j
]
.
mIsOccupied
=
false
;
}
}
}
#
ifdef
DEBUG
void
nsGridContainerFrame
:
:
CellMap
:
:
Dump
(
)
const
{
const
size_t
numRows
=
mCells
.
Length
(
)
;
for
(
size_t
i
=
0
;
i
<
numRows
;
+
+
i
)
{
const
nsTArray
<
Cell
>
&
cellsInRow
=
mCells
[
i
]
;
const
size_t
numCols
=
cellsInRow
.
Length
(
)
;
printf
(
"
%
lu
:
\
t
"
(
unsigned
long
)
i
+
1
)
;
for
(
size_t
j
=
0
;
j
<
numCols
;
+
+
j
)
{
printf
(
cellsInRow
[
j
]
.
mIsOccupied
?
"
X
"
:
"
.
"
)
;
}
printf
(
"
\
n
"
)
;
}
}
static
bool
FrameWantsToBeInAnonymousGridItem
(
nsIFrame
*
aFrame
)
{
return
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eLineParticipant
)
;
}
void
nsGridContainerFrame
:
:
SanityCheckAnonymousGridItems
(
)
const
{
ChildListIDs
noCheckLists
=
kAbsoluteList
|
kFixedList
;
ChildListIDs
checkLists
=
kPrincipalList
|
kOverflowList
;
for
(
nsIFrame
:
:
ChildListIterator
childLists
(
this
)
;
!
childLists
.
IsDone
(
)
;
childLists
.
Next
(
)
)
{
if
(
!
checkLists
.
Contains
(
childLists
.
CurrentID
(
)
)
)
{
MOZ_ASSERT
(
noCheckLists
.
Contains
(
childLists
.
CurrentID
(
)
)
"
unexpected
non
-
empty
child
list
"
)
;
continue
;
}
bool
prevChildWasAnonGridItem
=
false
;
nsFrameList
children
=
childLists
.
CurrentList
(
)
;
for
(
nsFrameList
:
:
Enumerator
e
(
children
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
)
{
nsIFrame
*
child
=
e
.
get
(
)
;
MOZ_ASSERT
(
!
FrameWantsToBeInAnonymousGridItem
(
child
)
"
frame
wants
to
be
inside
an
anonymous
grid
item
"
"
but
it
isn
'
t
"
)
;
if
(
child
-
>
StyleContext
(
)
-
>
GetPseudo
(
)
=
=
nsCSSAnonBoxes
:
:
anonymousGridItem
)
{
MOZ_ASSERT
(
!
prevChildWasAnonGridItem
"
two
anon
grid
items
in
a
row
"
)
;
nsIFrame
*
firstWrappedChild
=
child
-
>
GetFirstPrincipalChild
(
)
;
MOZ_ASSERT
(
firstWrappedChild
"
anonymous
grid
item
is
empty
(
shouldn
'
t
happen
)
"
)
;
prevChildWasAnonGridItem
=
true
;
}
else
{
prevChildWasAnonGridItem
=
false
;
}
}
}
}
void
nsGridContainerFrame
:
:
TrackSize
:
:
Dump
(
)
const
{
printf
(
"
mBase
=
%
d
mLimit
=
%
d
"
mBase
mLimit
)
;
printf
(
"
min
:
"
)
;
if
(
mState
&
eAutoMinSizing
)
{
printf
(
"
auto
"
)
;
}
else
if
(
mState
&
eMinContentMinSizing
)
{
printf
(
"
min
-
content
"
)
;
}
else
if
(
mState
&
eMaxContentMinSizing
)
{
printf
(
"
max
-
content
"
)
;
}
else
if
(
mState
&
eFlexMinSizing
)
{
printf
(
"
flex
"
)
;
}
printf
(
"
max
:
"
)
;
if
(
mState
&
eAutoMaxSizing
)
{
printf
(
"
auto
"
)
;
}
else
if
(
mState
&
eMinContentMaxSizing
)
{
printf
(
"
min
-
content
"
)
;
}
else
if
(
mState
&
eMaxContentMaxSizing
)
{
printf
(
"
max
-
content
"
)
;
}
else
if
(
mState
&
eFlexMaxSizing
)
{
printf
(
"
flex
"
)
;
}
if
(
mState
&
eFrozen
)
{
printf
(
"
frozen
"
)
;
}
}
#
endif
