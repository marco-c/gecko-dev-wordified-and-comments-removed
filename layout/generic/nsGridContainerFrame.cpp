#
include
"
nsGridContainerFrame
.
h
"
#
include
<
functional
>
#
include
<
limits
>
#
include
<
stdlib
.
h
>
#
include
"
gfxContext
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
ComputedStyle
.
h
"
#
include
"
mozilla
/
CSSAlignUtils
.
h
"
#
include
"
mozilla
/
CSSOrderAwareFrameIterator
.
h
"
#
include
"
mozilla
/
dom
/
GridBinding
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
mozilla
/
Poison
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
nsAbsoluteContainingBlock
.
h
"
#
include
"
nsAlgorithm
.
h
"
#
include
"
nsCSSAnonBoxes
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsFieldSetFrame
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsTableWrapperFrame
.
h
"
using
namespace
mozilla
;
typedef
nsAbsoluteContainingBlock
:
:
AbsPosReflowFlags
AbsPosReflowFlags
;
typedef
nsGridContainerFrame
:
:
TrackSize
TrackSize
;
typedef
nsTHashtable
<
nsPtrHashKey
<
nsIFrame
>
>
FrameHashtable
;
typedef
mozilla
:
:
CSSAlignUtils
:
:
AlignJustifyFlags
AlignJustifyFlags
;
typedef
nsLayoutUtils
:
:
IntrinsicISizeType
IntrinsicISizeType
;
static
const
int32_t
kMaxLine
=
StyleMAX_GRID_LINE
;
static
const
int32_t
kMinLine
=
StyleMIN_GRID_LINE
;
static
const
uint32_t
kTranslatedMaxLine
=
uint32_t
(
kMaxLine
-
kMinLine
)
;
static
const
uint32_t
kAutoLine
=
kTranslatedMaxLine
+
3457U
;
static
const
nsFrameState
kIsSubgridBits
=
(
NS_STATE_GRID_IS_COL_SUBGRID
|
NS_STATE_GRID_IS_ROW_SUBGRID
)
;
enum
class
SizingConstraint
{
MinContent
MaxContent
NoConstraint
}
;
static
void
ReparentFrame
(
nsIFrame
*
aFrame
nsContainerFrame
*
aOldParent
nsContainerFrame
*
aNewParent
)
{
NS_ASSERTION
(
aOldParent
=
=
aFrame
-
>
GetParent
(
)
"
Parent
not
consistent
with
expectations
"
)
;
aFrame
-
>
SetParent
(
aNewParent
)
;
nsContainerFrame
:
:
ReparentFrameView
(
aFrame
aOldParent
aNewParent
)
;
}
static
void
ReparentFrames
(
nsFrameList
&
aFrameList
nsContainerFrame
*
aOldParent
nsContainerFrame
*
aNewParent
)
{
for
(
auto
f
:
aFrameList
)
{
ReparentFrame
(
f
aOldParent
aNewParent
)
;
}
}
static
nscoord
ClampToCSSMaxBSize
(
nscoord
aSize
const
ReflowInput
*
aReflowInput
)
{
auto
maxSize
=
aReflowInput
-
>
ComputedMaxBSize
(
)
;
if
(
MOZ_UNLIKELY
(
maxSize
!
=
NS_UNCONSTRAINEDSIZE
)
)
{
MOZ_ASSERT
(
aReflowInput
-
>
ComputedMinBSize
(
)
<
=
maxSize
)
;
aSize
=
std
:
:
min
(
aSize
maxSize
)
;
}
return
aSize
;
}
static
nscoord
ClampToCSSMaxBSize
(
nscoord
aSize
const
ReflowInput
*
aReflowInput
nsReflowStatus
*
aStatus
)
{
auto
maxSize
=
aReflowInput
-
>
ComputedMaxBSize
(
)
;
if
(
MOZ_UNLIKELY
(
maxSize
!
=
NS_UNCONSTRAINEDSIZE
)
)
{
MOZ_ASSERT
(
aReflowInput
-
>
ComputedMinBSize
(
)
<
=
maxSize
)
;
if
(
aSize
<
maxSize
)
{
aStatus
-
>
SetIncomplete
(
)
;
}
else
{
aSize
=
maxSize
;
}
}
else
{
aStatus
-
>
SetIncomplete
(
)
;
}
return
aSize
;
}
template
<
typename
Size
>
static
bool
IsPercentOfIndefiniteSize
(
const
Size
&
aCoord
nscoord
aPercentBasis
)
{
return
aPercentBasis
=
=
NS_UNCONSTRAINEDSIZE
&
&
aCoord
.
HasPercent
(
)
;
}
static
nscoord
ResolveToDefiniteSize
(
const
nsStyleCoord
&
aCoord
nscoord
aPercentBasis
)
{
MOZ_ASSERT
(
aCoord
.
IsCoordPercentCalcUnit
(
)
)
;
if
(
:
:
IsPercentOfIndefiniteSize
(
aCoord
aPercentBasis
)
)
{
return
nscoord
(
0
)
;
}
return
std
:
:
max
(
nscoord
(
0
)
aCoord
.
ComputeCoordPercentCalc
(
aPercentBasis
)
)
;
}
static
nscoord
SynthesizeBaselineFromBorderBox
(
BaselineSharingGroup
aGroup
WritingMode
aWM
nscoord
aBorderBoxSize
)
{
if
(
aGroup
=
=
BaselineSharingGroup
:
:
First
)
{
return
aWM
.
IsAlphabeticalBaseline
(
)
?
aBorderBoxSize
:
aBorderBoxSize
/
2
;
}
MOZ_ASSERT
(
aGroup
=
=
BaselineSharingGroup
:
:
Last
)
;
return
aWM
.
IsAlphabeticalBaseline
(
)
?
0
:
(
aBorderBoxSize
/
2
)
+
(
aBorderBoxSize
%
2
)
;
}
struct
RepeatTrackSizingInput
{
explicit
RepeatTrackSizingInput
(
WritingMode
aWM
)
:
mMin
(
aWM
0
0
)
mSize
(
aWM
NS_UNCONSTRAINEDSIZE
NS_UNCONSTRAINEDSIZE
)
mMax
(
aWM
NS_UNCONSTRAINEDSIZE
NS_UNCONSTRAINEDSIZE
)
{
}
RepeatTrackSizingInput
(
const
LogicalSize
&
aMin
const
LogicalSize
&
aSize
const
LogicalSize
&
aMax
)
:
mMin
(
aMin
)
mSize
(
aSize
)
mMax
(
aMax
)
{
}
void
SetDefiniteSizes
(
LogicalAxis
aAxis
WritingMode
aWM
const
StyleSize
&
aMinCoord
const
StyleSize
&
aSizeCoord
const
StyleMaxSize
&
aMaxCoord
)
{
nscoord
&
min
=
mMin
.
Size
(
aAxis
aWM
)
;
nscoord
&
size
=
mSize
.
Size
(
aAxis
aWM
)
;
nscoord
&
max
=
mMax
.
Size
(
aAxis
aWM
)
;
if
(
aMinCoord
.
ConvertsToLength
(
)
)
{
min
=
aMinCoord
.
ToLength
(
)
;
}
if
(
aMaxCoord
.
ConvertsToLength
(
)
)
{
max
=
std
:
:
max
(
min
aMaxCoord
.
ToLength
(
)
)
;
}
if
(
aSizeCoord
.
ConvertsToLength
(
)
)
{
size
=
Clamp
(
aSizeCoord
.
ToLength
(
)
min
max
)
;
}
}
LogicalSize
mMin
;
LogicalSize
mSize
;
LogicalSize
mMax
;
}
;
enum
class
GridLineSide
{
BeforeGridGap
AfterGridGap
}
;
struct
nsGridContainerFrame
:
:
TrackSize
{
enum
StateBits
:
uint16_t
{
eAutoMinSizing
=
0x1
eMinContentMinSizing
=
0x2
eMaxContentMinSizing
=
0x4
eMinOrMaxContentMinSizing
=
eMinContentMinSizing
|
eMaxContentMinSizing
eIntrinsicMinSizing
=
eMinOrMaxContentMinSizing
|
eAutoMinSizing
eModified
=
0x8
eAutoMaxSizing
=
0x10
eMinContentMaxSizing
=
0x20
eMaxContentMaxSizing
=
0x40
eAutoOrMaxContentMaxSizing
=
eAutoMaxSizing
|
eMaxContentMaxSizing
eIntrinsicMaxSizing
=
eAutoOrMaxContentMaxSizing
|
eMinContentMaxSizing
eFlexMaxSizing
=
0x80
eFrozen
=
0x100
eSkipGrowUnlimited1
=
0x200
eSkipGrowUnlimited2
=
0x400
eSkipGrowUnlimited
=
eSkipGrowUnlimited1
|
eSkipGrowUnlimited2
eBreakBefore
=
0x800
eFitContent
=
0x1000
eInfinitelyGrowable
=
0x2000
}
;
StateBits
Initialize
(
nscoord
aPercentageBasis
const
nsStyleCoord
&
aMinCoord
const
nsStyleCoord
&
aMaxCoord
)
;
bool
IsFrozen
(
)
const
{
return
mState
&
eFrozen
;
}
#
ifdef
DEBUG
void
Dump
(
)
const
;
#
endif
static
bool
IsMinContent
(
const
nsStyleCoord
&
aCoord
)
{
return
aCoord
.
GetUnit
(
)
=
=
eStyleUnit_Enumerated
&
&
aCoord
.
GetEnumValue
<
StyleGridTrackBreadth
>
(
)
=
=
StyleGridTrackBreadth
:
:
MinContent
;
}
static
bool
IsDefiniteMaxSizing
(
StateBits
aStateBits
)
{
return
(
aStateBits
&
(
eIntrinsicMaxSizing
|
eFlexMaxSizing
)
)
=
=
0
;
}
nscoord
mBase
;
nscoord
mLimit
;
nscoord
mPosition
;
PerBaseline
<
nscoord
>
mBaselineSubtreeSize
;
StateBits
mState
;
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
TrackSize
:
:
StateBits
)
namespace
mozilla
{
template
<
>
struct
IsPod
<
nsGridContainerFrame
:
:
TrackSize
>
:
TrueType
{
}
;
}
TrackSize
:
:
StateBits
nsGridContainerFrame
:
:
TrackSize
:
:
Initialize
(
nscoord
aPercentageBasis
const
nsStyleCoord
&
aMinCoord
const
nsStyleCoord
&
aMaxCoord
)
{
MOZ_ASSERT
(
mBase
=
=
0
&
&
mLimit
=
=
0
&
&
mState
=
=
0
"
track
size
data
is
expected
to
be
initialized
to
zero
"
)
;
auto
minSizeUnit
=
aMinCoord
.
GetUnit
(
)
;
auto
maxSizeUnit
=
aMaxCoord
.
GetUnit
(
)
;
if
(
minSizeUnit
=
=
eStyleUnit_None
)
{
mState
=
eFitContent
;
minSizeUnit
=
eStyleUnit_Auto
;
maxSizeUnit
=
eStyleUnit_Enumerated
;
}
if
(
:
:
IsPercentOfIndefiniteSize
(
aMinCoord
aPercentageBasis
)
)
{
minSizeUnit
=
eStyleUnit_Auto
;
}
if
(
:
:
IsPercentOfIndefiniteSize
(
aMaxCoord
aPercentageBasis
)
)
{
maxSizeUnit
=
eStyleUnit_Auto
;
}
switch
(
minSizeUnit
)
{
case
eStyleUnit_Auto
:
mState
|
=
eAutoMinSizing
;
break
;
case
eStyleUnit_Enumerated
:
mState
|
=
IsMinContent
(
aMinCoord
)
?
eMinContentMinSizing
:
eMaxContentMinSizing
;
break
;
default
:
MOZ_ASSERT
(
minSizeUnit
!
=
eStyleUnit_FlexFraction
"
<
flex
>
min
-
sizing
is
invalid
as
a
track
size
"
)
;
mBase
=
:
:
ResolveToDefiniteSize
(
aMinCoord
aPercentageBasis
)
;
}
switch
(
maxSizeUnit
)
{
case
eStyleUnit_Auto
:
mState
|
=
eAutoMaxSizing
;
mLimit
=
NS_UNCONSTRAINEDSIZE
;
break
;
case
eStyleUnit_Enumerated
:
mState
|
=
IsMinContent
(
aMaxCoord
)
?
eMinContentMaxSizing
:
eMaxContentMaxSizing
;
mLimit
=
NS_UNCONSTRAINEDSIZE
;
break
;
case
eStyleUnit_FlexFraction
:
mState
|
=
eFlexMaxSizing
;
mLimit
=
mBase
;
break
;
default
:
mLimit
=
:
:
ResolveToDefiniteSize
(
aMaxCoord
aPercentageBasis
)
;
if
(
mLimit
<
mBase
)
{
mLimit
=
mBase
;
}
}
mBaselineSubtreeSize
[
BaselineSharingGroup
:
:
First
]
=
nscoord
(
0
)
;
mBaselineSubtreeSize
[
BaselineSharingGroup
:
:
Last
]
=
nscoord
(
0
)
;
return
mState
;
}
static
bool
IsPrevContinuationOf
(
nsIFrame
*
aFrame1
nsIFrame
*
aFrame2
)
{
nsIFrame
*
prev
=
aFrame2
;
while
(
(
prev
=
prev
-
>
GetPrevContinuation
(
)
)
)
{
if
(
prev
=
=
aFrame1
)
{
return
true
;
}
}
return
false
;
}
static
void
MergeSortedFrameLists
(
nsFrameList
&
aDest
nsFrameList
&
aSrc
nsIContent
*
aCommonAncestor
)
{
nsIFrame
*
dest
=
aDest
.
FirstChild
(
)
;
for
(
nsIFrame
*
src
=
aSrc
.
FirstChild
(
)
;
src
;
)
{
if
(
!
dest
)
{
aDest
.
AppendFrames
(
nullptr
aSrc
)
;
break
;
}
nsIContent
*
srcContent
=
src
-
>
GetContent
(
)
;
nsIContent
*
destContent
=
dest
-
>
GetContent
(
)
;
int32_t
result
=
nsLayoutUtils
:
:
CompareTreePosition
(
srcContent
destContent
aCommonAncestor
)
;
if
(
MOZ_UNLIKELY
(
result
=
=
0
)
)
{
if
(
MOZ_UNLIKELY
(
srcContent
-
>
IsGeneratedContentContainerForBefore
(
)
)
)
{
if
(
MOZ_LIKELY
(
!
destContent
-
>
IsGeneratedContentContainerForBefore
(
)
)
|
|
:
:
IsPrevContinuationOf
(
src
dest
)
)
{
result
=
-
1
;
}
}
else
if
(
MOZ_UNLIKELY
(
srcContent
-
>
IsGeneratedContentContainerForAfter
(
)
)
)
{
if
(
MOZ_UNLIKELY
(
destContent
-
>
IsGeneratedContentContainerForAfter
(
)
)
&
&
:
:
IsPrevContinuationOf
(
src
dest
)
)
{
result
=
-
1
;
}
}
else
if
(
:
:
IsPrevContinuationOf
(
src
dest
)
)
{
result
=
-
1
;
}
}
if
(
result
<
0
)
{
nsIFrame
*
next
=
src
-
>
GetNextSibling
(
)
;
aSrc
.
RemoveFrame
(
src
)
;
aDest
.
InsertFrame
(
nullptr
dest
-
>
GetPrevSibling
(
)
src
)
;
src
=
next
;
}
else
{
dest
=
dest
-
>
GetNextSibling
(
)
;
}
}
MOZ_ASSERT
(
aSrc
.
IsEmpty
(
)
)
;
}
static
void
MergeSortedFrameListsFor
(
nsFrameList
&
aDest
nsFrameList
&
aSrc
nsContainerFrame
*
aParent
)
{
MergeSortedFrameLists
(
aDest
aSrc
aParent
-
>
GetContent
(
)
)
;
}
struct
nsGridContainerFrame
:
:
LineRange
{
LineRange
(
int32_t
aStart
int32_t
aEnd
)
:
mUntranslatedStart
(
aStart
)
mUntranslatedEnd
(
aEnd
)
{
#
ifdef
DEBUG
if
(
!
IsAutoAuto
(
)
)
{
if
(
IsAuto
(
)
)
{
MOZ_ASSERT
(
aEnd
>
=
kMinLine
&
&
aEnd
<
=
kMaxLine
"
invalid
span
"
)
;
}
else
{
MOZ_ASSERT
(
aStart
>
=
kMinLine
&
&
aStart
<
=
kMaxLine
"
invalid
start
line
"
)
;
MOZ_ASSERT
(
aEnd
=
=
int32_t
(
kAutoLine
)
|
|
(
aEnd
>
=
kMinLine
&
&
aEnd
<
=
kMaxLine
)
"
invalid
end
line
"
)
;
}
}
#
endif
}
bool
IsAutoAuto
(
)
const
{
return
mStart
=
=
kAutoLine
&
&
mEnd
=
=
kAutoLine
;
}
bool
IsAuto
(
)
const
{
return
mStart
=
=
kAutoLine
;
}
bool
IsDefinite
(
)
const
{
return
mStart
!
=
kAutoLine
;
}
uint32_t
Extent
(
)
const
{
MOZ_ASSERT
(
mEnd
!
=
kAutoLine
"
Extent
is
undefined
for
abs
.
pos
.
'
auto
'
"
)
;
if
(
IsAuto
(
)
)
{
MOZ_ASSERT
(
mEnd
>
=
1
&
&
mEnd
<
uint32_t
(
kMaxLine
)
"
invalid
span
"
)
;
return
mEnd
;
}
return
mEnd
-
mStart
;
}
auto
Range
(
)
const
{
return
IntegerRange
<
uint32_t
>
(
mStart
mEnd
)
;
}
void
ResolveAutoPosition
(
uint32_t
aStart
uint32_t
aClampMaxLine
)
{
MOZ_ASSERT
(
IsAuto
(
)
"
Why
call
me
?
"
)
;
mStart
=
aStart
;
mEnd
+
=
aStart
;
if
(
MOZ_UNLIKELY
(
mStart
>
=
aClampMaxLine
)
)
{
mEnd
=
aClampMaxLine
;
mStart
=
mEnd
-
1
;
}
else
if
(
MOZ_UNLIKELY
(
mEnd
>
aClampMaxLine
)
)
{
mEnd
=
aClampMaxLine
;
}
}
void
AdjustForRemovedTracks
(
const
nsTArray
<
uint32_t
>
&
aNumRemovedTracks
)
{
MOZ_ASSERT
(
mStart
!
=
kAutoLine
"
invalid
resolved
line
for
a
grid
item
"
)
;
MOZ_ASSERT
(
mEnd
!
=
kAutoLine
"
invalid
resolved
line
for
a
grid
item
"
)
;
uint32_t
numRemovedTracks
=
aNumRemovedTracks
[
mStart
]
;
MOZ_ASSERT
(
numRemovedTracks
=
=
aNumRemovedTracks
[
mEnd
]
"
tracks
that
a
grid
item
spans
can
'
t
be
removed
"
)
;
mStart
-
=
numRemovedTracks
;
mEnd
-
=
numRemovedTracks
;
}
void
AdjustAbsPosForRemovedTracks
(
const
nsTArray
<
uint32_t
>
&
aNumRemovedTracks
)
{
if
(
mStart
!
=
kAutoLine
)
{
mStart
-
=
aNumRemovedTracks
[
mStart
]
;
}
if
(
mEnd
!
=
kAutoLine
)
{
MOZ_ASSERT
(
mStart
=
=
kAutoLine
|
|
mEnd
>
mStart
"
invalid
line
range
"
)
;
mEnd
-
=
aNumRemovedTracks
[
mEnd
]
;
}
}
uint32_t
HypotheticalEnd
(
)
const
{
return
mEnd
;
}
void
ToPositionAndLength
(
const
nsTArray
<
TrackSize
>
&
aTrackSizes
nscoord
*
aPos
nscoord
*
aLength
)
const
;
nscoord
ToLength
(
const
nsTArray
<
TrackSize
>
&
aTrackSizes
)
const
;
void
ToPositionAndLengthForAbsPos
(
const
Tracks
&
aTracks
nscoord
aGridOrigin
nscoord
*
aPos
nscoord
*
aLength
)
const
;
void
Translate
(
int32_t
aOffset
)
{
MOZ_ASSERT
(
IsDefinite
(
)
)
;
mStart
+
=
aOffset
;
mEnd
+
=
aOffset
;
}
void
ReverseDirection
(
uint32_t
aGridEnd
)
{
MOZ_ASSERT
(
IsDefinite
(
)
)
;
MOZ_ASSERT
(
aGridEnd
>
=
mEnd
)
;
uint32_t
newStart
=
aGridEnd
-
mEnd
;
mEnd
=
aGridEnd
-
mStart
;
mStart
=
newStart
;
}
union
{
uint32_t
mStart
;
int32_t
mUntranslatedStart
;
}
;
union
{
uint32_t
mEnd
;
int32_t
mUntranslatedEnd
;
}
;
protected
:
LineRange
(
)
:
mStart
(
0
)
mEnd
(
0
)
{
}
}
;
struct
nsGridContainerFrame
:
:
TranslatedLineRange
:
public
LineRange
{
TranslatedLineRange
(
uint32_t
aStart
uint32_t
aEnd
)
{
MOZ_ASSERT
(
aStart
<
aEnd
&
&
aEnd
<
=
kTranslatedMaxLine
)
;
mStart
=
aStart
;
mEnd
=
aEnd
;
}
}
;
struct
nsGridContainerFrame
:
:
GridArea
{
GridArea
(
const
LineRange
&
aCols
const
LineRange
&
aRows
)
:
mCols
(
aCols
)
mRows
(
aRows
)
{
}
bool
IsDefinite
(
)
const
{
return
mCols
.
IsDefinite
(
)
&
&
mRows
.
IsDefinite
(
)
;
}
LineRange
&
LineRangeForAxis
(
LogicalAxis
aAxis
)
{
return
aAxis
=
=
eLogicalAxisInline
?
mCols
:
mRows
;
}
const
LineRange
&
LineRangeForAxis
(
LogicalAxis
aAxis
)
const
{
return
aAxis
=
=
eLogicalAxisInline
?
mCols
:
mRows
;
}
LineRange
mCols
;
LineRange
mRows
;
}
;
struct
nsGridContainerFrame
:
:
GridItemInfo
{
enum
StateBits
:
uint16_t
{
eIsFlexing
=
0x1
eFirstBaseline
=
0x2
eLastBaseline
=
0x4
eIsBaselineAligned
=
eFirstBaseline
|
eLastBaseline
eSelfBaseline
=
0x8
eContentBaseline
=
0x10
eAllBaselineBits
=
eIsBaselineAligned
|
eSelfBaseline
|
eContentBaseline
eApplyAutoMinSize
=
0x20
eClampMarginBoxMinSize
=
0x40
eIsSubgrid
=
0x80
eStartEdge
=
0x100
eEndEdge
=
0x200
eEdgeBits
=
eStartEdge
|
eEndEdge
}
;
explicit
GridItemInfo
(
nsIFrame
*
aFrame
const
GridArea
&
aArea
)
:
mFrame
(
aFrame
)
mArea
(
aArea
)
{
mState
[
eLogicalAxisBlock
]
=
StateBits
(
0
)
;
mState
[
eLogicalAxisInline
]
=
StateBits
(
0
)
;
nsGridContainerFrame
*
gridFrame
=
GetGridContainerFrame
(
mFrame
)
;
if
(
gridFrame
)
{
auto
parentWM
=
aFrame
-
>
GetParent
(
)
-
>
GetWritingMode
(
)
;
bool
isOrthogonal
=
parentWM
.
IsOrthogonalTo
(
gridFrame
-
>
GetWritingMode
(
)
)
;
if
(
gridFrame
-
>
IsColSubgrid
(
)
)
{
mState
[
isOrthogonal
?
eLogicalAxisBlock
:
eLogicalAxisInline
]
=
StateBits
:
:
eIsSubgrid
;
}
if
(
gridFrame
-
>
IsRowSubgrid
(
)
)
{
mState
[
isOrthogonal
?
eLogicalAxisInline
:
eLogicalAxisBlock
]
=
StateBits
:
:
eIsSubgrid
;
}
}
mBaselineOffset
[
eLogicalAxisBlock
]
=
nscoord
(
0
)
;
mBaselineOffset
[
eLogicalAxisInline
]
=
nscoord
(
0
)
;
}
GridItemInfo
Transpose
(
)
const
{
GridItemInfo
info
(
mFrame
GridArea
(
mArea
.
mRows
mArea
.
mCols
)
)
;
info
.
mState
[
0
]
=
mState
[
1
]
;
info
.
mState
[
1
]
=
mState
[
0
]
;
info
.
mBaselineOffset
[
0
]
=
mBaselineOffset
[
1
]
;
info
.
mBaselineOffset
[
1
]
=
mBaselineOffset
[
0
]
;
return
info
;
}
inline
void
ReverseDirection
(
LogicalAxis
aAxis
uint32_t
aGridEnd
)
;
bool
IsSubgrid
(
LogicalAxis
aAxis
)
const
{
return
mState
[
aAxis
]
&
StateBits
:
:
eIsSubgrid
;
}
bool
IsSubgrid
(
)
const
{
return
IsSubgrid
(
eLogicalAxisInline
)
|
|
IsSubgrid
(
eLogicalAxisBlock
)
;
}
nsGridContainerFrame
*
SubgridFrame
(
)
const
{
MOZ_ASSERT
(
IsSubgrid
(
)
)
;
nsGridContainerFrame
*
gridFrame
=
GetGridContainerFrame
(
mFrame
)
;
MOZ_ASSERT
(
gridFrame
&
&
gridFrame
-
>
IsSubgrid
(
)
)
;
return
gridFrame
;
}
uint8_t
GetSelfBaseline
(
uint8_t
aAlign
LogicalAxis
aAxis
nscoord
*
aBaselineOffset
)
const
{
MOZ_ASSERT
(
aAlign
=
=
NS_STYLE_ALIGN_BASELINE
|
|
aAlign
=
=
NS_STYLE_ALIGN_LAST_BASELINE
)
;
if
(
!
(
mState
[
aAxis
]
&
eSelfBaseline
)
)
{
return
aAlign
=
=
NS_STYLE_ALIGN_BASELINE
?
NS_STYLE_ALIGN_SELF_START
:
NS_STYLE_ALIGN_SELF_END
;
}
*
aBaselineOffset
=
mBaselineOffset
[
aAxis
]
;
return
aAlign
;
}
bool
ShouldApplyAutoMinSize
(
WritingMode
aContainerWM
LogicalAxis
aContainerAxis
nscoord
aPercentageBasis
)
const
{
const
bool
isInlineAxis
=
aContainerAxis
=
=
eLogicalAxisInline
;
const
auto
*
pos
=
mFrame
-
>
IsTableWrapperFrame
(
)
?
mFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
-
>
StylePosition
(
)
:
mFrame
-
>
StylePosition
(
)
;
const
auto
&
size
=
isInlineAxis
?
pos
-
>
ISize
(
aContainerWM
)
:
pos
-
>
BSize
(
aContainerWM
)
;
bool
isAuto
=
size
.
IsAuto
(
)
|
|
(
isInlineAxis
=
=
aContainerWM
.
IsOrthogonalTo
(
mFrame
-
>
GetWritingMode
(
)
)
&
&
size
.
IsExtremumLength
(
)
)
;
if
(
!
isAuto
&
&
!
:
:
IsPercentOfIndefiniteSize
(
size
aPercentageBasis
)
)
{
return
false
;
}
const
auto
&
minSize
=
isInlineAxis
?
pos
-
>
MinISize
(
aContainerWM
)
:
pos
-
>
MinBSize
(
aContainerWM
)
;
isAuto
=
minSize
.
IsAuto
(
)
|
|
(
isInlineAxis
=
=
aContainerWM
.
IsOrthogonalTo
(
mFrame
-
>
GetWritingMode
(
)
)
&
&
minSize
.
IsExtremumLength
(
)
)
;
return
isAuto
&
&
mFrame
-
>
StyleDisplay
(
)
-
>
mOverflowX
=
=
StyleOverflow
:
:
Visible
;
}
#
ifdef
DEBUG
void
Dump
(
)
const
;
#
endif
static
bool
IsStartRowLessThan
(
const
GridItemInfo
*
a
const
GridItemInfo
*
b
)
{
return
a
-
>
mArea
.
mRows
.
mStart
<
b
-
>
mArea
.
mRows
.
mStart
;
}
nsIFrame
*
const
mFrame
;
GridArea
mArea
;
mutable
nscoord
mBaselineOffset
[
2
]
;
mutable
StateBits
mState
[
2
]
;
static_assert
(
mozilla
:
:
eLogicalAxisBlock
=
=
0
"
unexpected
index
value
"
)
;
static_assert
(
mozilla
:
:
eLogicalAxisInline
=
=
1
"
unexpected
index
value
"
)
;
}
;
using
GridItemInfo
=
nsGridContainerFrame
:
:
GridItemInfo
;
using
ItemState
=
GridItemInfo
:
:
StateBits
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
ItemState
)
void
GridItemInfo
:
:
ReverseDirection
(
LogicalAxis
aAxis
uint32_t
aGridEnd
)
{
mArea
.
LineRangeForAxis
(
aAxis
)
.
ReverseDirection
(
aGridEnd
)
;
ItemState
&
state
=
mState
[
aAxis
]
;
ItemState
newState
=
state
&
~
ItemState
:
:
eEdgeBits
;
if
(
state
&
ItemState
:
:
eStartEdge
)
{
newState
|
=
ItemState
:
:
eEndEdge
;
}
if
(
state
&
ItemState
:
:
eEndEdge
)
{
newState
|
=
ItemState
:
:
eStartEdge
;
}
state
=
newState
;
}
struct
nsGridContainerFrame
:
:
Subgrid
{
Subgrid
(
const
GridArea
&
aArea
bool
aIsOrthogonal
WritingMode
aCBWM
)
:
mArea
(
aArea
)
mGridColEnd
(
0
)
mGridRowEnd
(
0
)
mMarginBorderPadding
(
aCBWM
)
mIsOrthogonal
(
aIsOrthogonal
)
{
}
const
LineRange
&
SubgridCols
(
)
const
{
return
mIsOrthogonal
?
mArea
.
mRows
:
mArea
.
mCols
;
}
const
LineRange
&
SubgridRows
(
)
const
{
return
mIsOrthogonal
?
mArea
.
mCols
:
mArea
.
mRows
;
}
nsTArray
<
GridItemInfo
>
mGridItems
;
nsTArray
<
GridItemInfo
>
mAbsPosItems
;
GridArea
mArea
;
uint32_t
mGridColEnd
;
uint32_t
mGridRowEnd
;
LogicalMargin
mMarginBorderPadding
;
bool
mIsOrthogonal
;
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
Prop
Subgrid
)
}
;
using
Subgrid
=
nsGridContainerFrame
:
:
Subgrid
;
struct
nsGridContainerFrame
:
:
UsedTrackSizes
{
UsedTrackSizes
(
)
:
mCanResolveLineRangeSize
{
false
false
}
{
}
void
ResolveTrackSizesForAxis
(
nsGridContainerFrame
*
aFrame
LogicalAxis
aAxis
gfxContext
&
aRC
)
;
void
ResolveSubgridTrackSizesForAxis
(
nsGridContainerFrame
*
aFrame
LogicalAxis
aAxis
Subgrid
*
aSubgrid
gfxContext
&
aRC
nscoord
aContentBoxSize
)
;
PerLogicalAxis
<
nsTArray
<
TrackSize
>
>
mSizes
;
PerLogicalAxis
<
bool
>
mCanResolveLineRangeSize
;
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
Prop
UsedTrackSizes
)
}
;
using
UsedTrackSizes
=
nsGridContainerFrame
:
:
UsedTrackSizes
;
#
ifdef
DEBUG
void
nsGridContainerFrame
:
:
GridItemInfo
:
:
Dump
(
)
const
{
auto
Dump1
=
[
this
]
(
const
char
*
aMsg
LogicalAxis
aAxis
)
{
auto
state
=
mState
[
aAxis
]
;
if
(
!
state
)
{
return
;
}
printf
(
"
%
s
"
aMsg
)
;
if
(
state
&
ItemState
:
:
eEdgeBits
)
{
printf
(
"
subgrid
-
adjacent
-
edges
(
"
)
;
if
(
state
&
ItemState
:
:
eStartEdge
)
{
printf
(
"
start
"
)
;
}
if
(
state
&
ItemState
:
:
eEndEdge
)
{
printf
(
"
end
"
)
;
}
printf
(
"
)
"
)
;
}
if
(
state
&
ItemState
:
:
eIsSubgrid
)
{
printf
(
"
subgrid
"
)
;
}
if
(
state
&
ItemState
:
:
eIsFlexing
)
{
printf
(
"
flexing
"
)
;
}
if
(
state
&
ItemState
:
:
eApplyAutoMinSize
)
{
printf
(
"
auto
-
min
-
size
"
)
;
}
if
(
state
&
ItemState
:
:
eClampMarginBoxMinSize
)
{
printf
(
"
clamp
"
)
;
}
if
(
state
&
ItemState
:
:
eFirstBaseline
)
{
printf
(
"
first
baseline
%
s
-
alignment
"
(
state
&
ItemState
:
:
eSelfBaseline
)
?
"
self
"
:
"
content
"
)
;
}
if
(
state
&
ItemState
:
:
eLastBaseline
)
{
printf
(
"
last
baseline
%
s
-
alignment
"
(
state
&
ItemState
:
:
eSelfBaseline
)
?
"
self
"
:
"
content
"
)
;
}
if
(
state
&
ItemState
:
:
eIsBaselineAligned
)
{
printf
(
"
%
.
2fpx
"
NSAppUnitsToFloatPixels
(
mBaselineOffset
[
aAxis
]
AppUnitsPerCSSPixel
(
)
)
)
;
}
printf
(
"
\
n
"
)
;
}
;
printf
(
"
grid
-
row
:
%
d
%
d
\
n
"
mArea
.
mRows
.
mStart
mArea
.
mRows
.
mEnd
)
;
Dump1
(
"
grid
block
-
axis
:
"
eLogicalAxisBlock
)
;
printf
(
"
grid
-
column
:
%
d
%
d
\
n
"
mArea
.
mCols
.
mStart
mArea
.
mCols
.
mEnd
)
;
Dump1
(
"
grid
inline
-
axis
:
"
eLogicalAxisInline
)
;
}
#
endif
class
MOZ_STACK_CLASS
nsGridContainerFrame
:
:
LineNameMap
{
public
:
LineNameMap
(
const
nsStylePosition
*
aStylePosition
const
ImplicitNamedAreas
*
aImplicitNamedAreas
const
nsStyleGridTemplate
&
aGridTemplate
uint32_t
aNumRepeatTracks
int32_t
aClampMinLine
int32_t
aClampMaxLine
const
LineNameMap
*
aParentLineNameMap
const
LineRange
*
aRange
bool
aIsSameDirection
)
:
mClampMinLine
(
aClampMinLine
)
mClampMaxLine
(
aClampMaxLine
)
mStylePosition
(
aStylePosition
)
mAreas
(
aImplicitNamedAreas
)
mLineNameLists
(
aGridTemplate
.
mLineNameLists
)
mRepeatAutoLineNameListBefore
(
aGridTemplate
.
mRepeatAutoLineNameListBefore
)
mRepeatAutoLineNameListAfter
(
aGridTemplate
.
mRepeatAutoLineNameListAfter
)
mRepeatAutoStart
(
aGridTemplate
.
HasRepeatAuto
(
)
?
aGridTemplate
.
mRepeatAutoIndex
:
0
)
mRepeatAutoEnd
(
mRepeatAutoStart
+
aNumRepeatTracks
)
mRepeatEndDelta
(
aGridTemplate
.
HasRepeatAuto
(
)
?
int32_t
(
aNumRepeatTracks
)
-
1
:
0
)
mTemplateLinesEnd
(
mLineNameLists
.
Length
(
)
+
mRepeatEndDelta
)
mParentLineNameMap
(
aParentLineNameMap
)
mRange
(
aRange
)
mIsSameDirection
(
aIsSameDirection
)
mHasRepeatAuto
(
aGridTemplate
.
HasRepeatAuto
(
)
)
{
MOZ_ASSERT
(
mHasRepeatAuto
|
|
aNumRepeatTracks
=
=
0
)
;
MOZ_ASSERT
(
mRepeatAutoStart
<
=
mLineNameLists
.
Length
(
)
)
;
MOZ_ASSERT
(
!
mHasRepeatAuto
|
|
mLineNameLists
.
Length
(
)
>
=
2
)
;
}
uint32_t
FindNamedLine
(
nsAtom
*
aName
int32_t
*
aNth
uint32_t
aFromIndex
const
nsTArray
<
uint32_t
>
&
aImplicitLines
)
const
{
MOZ_ASSERT
(
aName
)
;
MOZ_ASSERT
(
!
aName
-
>
IsEmpty
(
)
)
;
MOZ_ASSERT
(
aNth
&
&
*
aNth
!
=
0
)
;
if
(
*
aNth
>
0
)
{
return
FindLine
(
aName
aNth
aFromIndex
aImplicitLines
)
;
}
int32_t
nth
=
-
*
aNth
;
int32_t
line
=
RFindLine
(
aName
&
nth
aFromIndex
aImplicitLines
)
;
*
aNth
=
-
nth
;
return
line
;
}
void
FindNamedAreas
(
nsAtom
*
aName
LogicalSide
aSide
nsTArray
<
uint32_t
>
&
aImplicitLines
)
const
{
bool
sameDirectionAsThis
=
true
;
uint32_t
min
=
!
mParentLineNameMap
?
1
:
mClampMinLine
;
uint32_t
max
=
mClampMaxLine
;
for
(
auto
*
map
=
this
;
true
;
)
{
uint32_t
line
=
map
-
>
FindNamedArea
(
aName
aSide
min
max
)
;
if
(
line
>
0
)
{
if
(
MOZ_LIKELY
(
sameDirectionAsThis
)
)
{
line
-
=
min
-
1
;
}
else
{
line
=
max
-
line
+
1
;
}
aImplicitLines
.
AppendElement
(
line
)
;
}
auto
*
parent
=
map
-
>
mParentLineNameMap
;
if
(
!
parent
)
{
if
(
MOZ_UNLIKELY
(
aImplicitLines
.
Length
(
)
>
1
)
)
{
aImplicitLines
.
Sort
(
)
;
for
(
size_t
i
=
0
;
i
<
aImplicitLines
.
Length
(
)
;
+
+
i
)
{
uint32_t
prev
=
aImplicitLines
[
i
]
;
auto
j
=
i
+
1
;
const
auto
start
=
j
;
while
(
j
<
aImplicitLines
.
Length
(
)
&
&
aImplicitLines
[
j
]
=
=
prev
)
{
+
+
j
;
}
if
(
j
!
=
start
)
{
aImplicitLines
.
RemoveElementsAt
(
start
j
-
start
)
;
}
}
}
return
;
}
if
(
MOZ_UNLIKELY
(
!
map
-
>
mIsSameDirection
)
)
{
aSide
=
GetOppositeSide
(
aSide
)
;
sameDirectionAsThis
=
!
sameDirectionAsThis
;
}
min
=
map
-
>
TranslateToParentMap
(
min
)
;
max
=
map
-
>
TranslateToParentMap
(
max
)
;
if
(
min
>
max
)
{
MOZ_ASSERT
(
!
map
-
>
mIsSameDirection
)
;
mozilla
:
:
Swap
(
min
max
)
;
}
map
=
parent
;
}
}
bool
HasImplicitNamedArea
(
nsAtom
*
aName
)
const
{
const
auto
*
map
=
this
;
do
{
if
(
map
-
>
mAreas
&
&
map
-
>
mAreas
-
>
has
(
aName
)
)
{
return
true
;
}
map
=
map
-
>
mParentLineNameMap
;
}
while
(
map
)
;
return
false
;
}
const
int32_t
mClampMinLine
;
const
int32_t
mClampMaxLine
;
private
:
bool
IsSubgridded
(
)
const
{
return
mParentLineNameMap
!
=
nullptr
;
}
uint32_t
FindLine
(
nsAtom
*
aName
int32_t
*
aNth
uint32_t
aFromIndex
const
nsTArray
<
uint32_t
>
&
aImplicitLines
)
const
{
MOZ_ASSERT
(
aNth
&
&
*
aNth
>
0
)
;
int32_t
nth
=
*
aNth
;
const
uint32_t
end
=
IsSubgridded
(
)
?
mClampMaxLine
:
mTemplateLinesEnd
;
uint32_t
line
;
uint32_t
i
=
aFromIndex
;
for
(
;
i
<
end
;
i
=
line
)
{
line
=
i
+
1
;
if
(
Contains
(
i
aName
)
|
|
aImplicitLines
.
Contains
(
line
)
)
{
if
(
-
-
nth
=
=
0
)
{
return
line
;
}
}
}
for
(
auto
implicitLine
:
aImplicitLines
)
{
if
(
implicitLine
>
i
)
{
if
(
-
-
nth
=
=
0
)
{
return
implicitLine
;
}
}
}
MOZ_ASSERT
(
nth
>
0
"
should
have
returned
a
valid
line
above
already
"
)
;
*
aNth
=
nth
;
return
0
;
}
uint32_t
RFindLine
(
nsAtom
*
aName
int32_t
*
aNth
uint32_t
aFromIndex
const
nsTArray
<
uint32_t
>
&
aImplicitLines
)
const
{
MOZ_ASSERT
(
aNth
&
&
*
aNth
>
0
)
;
if
(
MOZ_UNLIKELY
(
aFromIndex
=
=
0
)
)
{
return
0
;
}
-
-
aFromIndex
;
int32_t
nth
=
*
aNth
;
const
uint32_t
end
=
IsSubgridded
(
)
?
mClampMaxLine
:
mTemplateLinesEnd
;
for
(
auto
implicitLine
:
Reversed
(
aImplicitLines
)
)
{
if
(
implicitLine
<
=
end
)
{
break
;
}
if
(
implicitLine
<
aFromIndex
)
{
if
(
-
-
nth
=
=
0
)
{
return
implicitLine
;
}
}
}
for
(
uint32_t
i
=
std
:
:
min
(
aFromIndex
end
)
;
i
;
-
-
i
)
{
if
(
Contains
(
i
-
1
aName
)
|
|
aImplicitLines
.
Contains
(
i
)
)
{
if
(
-
-
nth
=
=
0
)
{
return
i
;
}
}
}
MOZ_ASSERT
(
nth
>
0
"
should
have
returned
a
valid
line
above
already
"
)
;
*
aNth
=
nth
;
return
0
;
}
bool
Contains
(
uint32_t
aIndex
nsAtom
*
aName
)
const
{
const
auto
*
map
=
this
;
while
(
true
)
{
if
(
aIndex
<
map
-
>
mTemplateLinesEnd
&
&
map
-
>
HasNameAt
(
aIndex
aName
)
)
{
return
true
;
}
auto
*
parent
=
map
-
>
mParentLineNameMap
;
if
(
!
parent
)
{
return
false
;
}
uint32_t
line
=
map
-
>
TranslateToParentMap
(
aIndex
+
1
)
;
MOZ_ASSERT
(
line
>
=
1
"
expected
a
1
-
based
line
number
"
)
;
aIndex
=
line
-
1
;
map
=
parent
;
}
MOZ_ASSERT_UNREACHABLE
(
"
we
always
return
from
inside
the
loop
above
"
)
;
}
bool
HasNameAt
(
uint32_t
aIndex
nsAtom
*
aName
)
const
{
if
(
!
mHasRepeatAuto
)
{
return
mLineNameLists
[
aIndex
]
.
Contains
(
aName
)
;
}
if
(
aIndex
<
mRepeatAutoEnd
&
&
aIndex
>
=
mRepeatAutoStart
&
&
mRepeatAutoLineNameListBefore
.
Contains
(
aName
)
)
{
return
true
;
}
if
(
aIndex
<
=
mRepeatAutoEnd
&
&
aIndex
>
mRepeatAutoStart
&
&
mRepeatAutoLineNameListAfter
.
Contains
(
aName
)
)
{
return
true
;
}
if
(
aIndex
<
=
mRepeatAutoStart
)
{
return
mLineNameLists
[
aIndex
]
.
Contains
(
aName
)
|
|
(
aIndex
=
=
mRepeatAutoEnd
&
&
mLineNameLists
[
aIndex
+
1
]
.
Contains
(
aName
)
)
;
}
return
aIndex
>
=
mRepeatAutoEnd
&
&
mLineNameLists
[
aIndex
-
mRepeatEndDelta
]
.
Contains
(
aName
)
;
}
uint32_t
TranslateToParentMap
(
uint32_t
aLine
)
const
{
if
(
MOZ_LIKELY
(
mIsSameDirection
)
)
{
return
aLine
+
mRange
-
>
mStart
;
}
MOZ_ASSERT
(
mRange
-
>
mEnd
+
1
>
=
aLine
)
;
return
mRange
-
>
mEnd
-
(
aLine
-
1
)
+
1
;
}
uint32_t
FindNamedArea
(
nsAtom
*
aName
LogicalSide
aSide
int32_t
aMin
int32_t
aMax
)
const
{
if
(
const
NamedArea
*
area
=
FindNamedArea
(
aName
)
)
{
int32_t
start
=
IsBlock
(
aSide
)
?
area
-
>
rows
.
start
:
area
-
>
columns
.
start
;
int32_t
end
=
IsBlock
(
aSide
)
?
area
-
>
rows
.
end
:
area
-
>
columns
.
end
;
if
(
IsStart
(
aSide
)
)
{
if
(
start
>
=
aMin
)
{
if
(
start
<
=
aMax
)
{
return
start
;
}
}
else
if
(
end
>
=
aMin
)
{
return
aMin
;
}
}
else
{
if
(
end
<
=
aMax
)
{
if
(
end
>
=
aMin
)
{
return
end
;
}
}
else
if
(
start
<
=
aMax
)
{
return
aMax
;
}
}
}
return
0
;
}
const
NamedArea
*
FindNamedArea
(
nsAtom
*
aName
)
const
{
if
(
mStylePosition
-
>
mGridTemplateAreas
.
IsNone
(
)
)
{
return
nullptr
;
}
const
auto
areas
=
mStylePosition
-
>
mGridTemplateAreas
.
AsAreas
(
)
;
for
(
const
NamedArea
&
area
:
areas
-
>
areas
.
AsSpan
(
)
)
{
if
(
area
.
name
.
AsAtom
(
)
=
=
aName
)
{
return
&
area
;
}
}
return
nullptr
;
}
const
nsStylePosition
*
mStylePosition
;
const
ImplicitNamedAreas
*
mAreas
;
const
nsTArray
<
nsTArray
<
RefPtr
<
nsAtom
>
>
>
&
mLineNameLists
;
const
nsTArray
<
RefPtr
<
nsAtom
>
>
&
mRepeatAutoLineNameListBefore
;
const
nsTArray
<
RefPtr
<
nsAtom
>
>
&
mRepeatAutoLineNameListAfter
;
const
uint32_t
mRepeatAutoStart
;
const
uint32_t
mRepeatAutoEnd
;
const
int32_t
mRepeatEndDelta
;
const
uint32_t
mTemplateLinesEnd
;
const
LineNameMap
*
mParentLineNameMap
;
const
LineRange
*
mRange
;
const
bool
mIsSameDirection
;
const
bool
mHasRepeatAuto
;
}
;
struct
nsGridContainerFrame
:
:
TrackSizingFunctions
{
TrackSizingFunctions
(
const
nsTArray
<
nsStyleCoord
>
&
aMinSizingFunctions
const
nsTArray
<
nsStyleCoord
>
&
aMaxSizingFunctions
const
nsStyleCoord
&
aAutoMinSizing
const
nsStyleCoord
&
aAutoMaxSizing
bool
aHasRepeatAuto
int32_t
aRepeatAutoIndex
)
:
mMinSizingFunctions
(
aMinSizingFunctions
)
mMaxSizingFunctions
(
aMaxSizingFunctions
)
mAutoMinSizing
(
aAutoMinSizing
)
mAutoMaxSizing
(
aAutoMaxSizing
)
mExplicitGridOffset
(
0
)
mRepeatAutoStart
(
aHasRepeatAuto
?
aRepeatAutoIndex
:
0
)
mRepeatAutoEnd
(
mRepeatAutoStart
)
mRepeatEndDelta
(
0
)
mHasRepeatAuto
(
aHasRepeatAuto
)
{
MOZ_ASSERT
(
mMinSizingFunctions
.
Length
(
)
=
=
mMaxSizingFunctions
.
Length
(
)
)
;
MOZ_ASSERT
(
!
mHasRepeatAuto
|
|
(
mMinSizingFunctions
.
Length
(
)
>
=
1
&
&
mRepeatAutoStart
<
mMinSizingFunctions
.
Length
(
)
)
)
;
}
TrackSizingFunctions
(
const
nsStyleGridTemplate
&
aGridTemplate
const
nsStyleCoord
&
aAutoMinSizing
const
nsStyleCoord
&
aAutoMaxSizing
)
:
TrackSizingFunctions
(
aGridTemplate
.
mMinTrackSizingFunctions
aGridTemplate
.
mMaxTrackSizingFunctions
aAutoMinSizing
aAutoMaxSizing
!
aGridTemplate
.
mIsSubgrid
&
&
aGridTemplate
.
HasRepeatAuto
(
)
aGridTemplate
.
mRepeatAutoIndex
)
{
}
uint32_t
InitRepeatTracks
(
const
NonNegativeLengthPercentageOrNormal
&
aGridGap
nscoord
aMinSize
nscoord
aSize
nscoord
aMaxSize
)
{
uint32_t
repeatTracks
=
CalculateRepeatFillCount
(
aGridGap
aMinSize
aSize
aMaxSize
)
;
SetNumRepeatTracks
(
repeatTracks
)
;
mRemovedRepeatTracks
.
SetLength
(
repeatTracks
)
;
for
(
auto
&
track
:
mRemovedRepeatTracks
)
{
track
=
false
;
}
return
repeatTracks
;
}
uint32_t
CalculateRepeatFillCount
(
const
NonNegativeLengthPercentageOrNormal
&
aGridGap
nscoord
aMinSize
nscoord
aSize
nscoord
aMaxSize
)
const
{
if
(
!
mHasRepeatAuto
)
{
return
0
;
}
const
uint32_t
numTracks
=
mMinSizingFunctions
.
Length
(
)
;
MOZ_ASSERT
(
numTracks
>
=
1
"
expected
at
least
the
repeat
(
)
track
"
)
;
nscoord
maxFill
=
aSize
!
=
NS_UNCONSTRAINEDSIZE
?
aSize
:
aMaxSize
;
if
(
maxFill
=
=
NS_UNCONSTRAINEDSIZE
&
&
aMinSize
=
=
0
)
{
return
1
;
}
nscoord
repeatTrackSize
=
0
;
nscoord
sum
=
0
;
const
nscoord
percentBasis
=
aSize
;
for
(
uint32_t
i
=
0
;
i
<
numTracks
;
+
+
i
)
{
const
auto
&
maxCoord
=
mMaxSizingFunctions
[
i
]
;
const
auto
*
coord
=
&
maxCoord
;
if
(
!
coord
-
>
IsCoordPercentCalcUnit
(
)
)
{
coord
=
&
mMinSizingFunctions
[
i
]
;
if
(
!
coord
-
>
IsCoordPercentCalcUnit
(
)
)
{
return
1
;
}
}
nscoord
trackSize
=
:
:
ResolveToDefiniteSize
(
*
coord
percentBasis
)
;
if
(
i
=
=
mRepeatAutoStart
)
{
if
(
trackSize
<
AppUnitsPerCSSPixel
(
)
)
{
trackSize
=
AppUnitsPerCSSPixel
(
)
;
}
repeatTrackSize
=
trackSize
;
}
sum
+
=
trackSize
;
}
nscoord
gridGap
=
nsLayoutUtils
:
:
ResolveGapToLength
(
aGridGap
aSize
)
;
if
(
numTracks
>
1
)
{
sum
+
=
gridGap
*
(
numTracks
-
1
)
;
}
nscoord
available
=
maxFill
!
=
NS_UNCONSTRAINEDSIZE
?
maxFill
:
aMinSize
;
nscoord
spaceToFill
=
available
-
sum
;
if
(
spaceToFill
<
=
0
)
{
return
1
;
}
div_t
q
=
div
(
spaceToFill
repeatTrackSize
+
gridGap
)
;
uint32_t
numRepeatTracks
=
q
.
quot
+
1
;
if
(
q
.
rem
!
=
0
&
&
maxFill
=
=
NS_UNCONSTRAINEDSIZE
)
{
+
+
numRepeatTracks
;
}
const
uint32_t
maxRepeatTracks
=
kMaxLine
-
numTracks
;
return
std
:
:
min
(
numRepeatTracks
maxRepeatTracks
)
;
}
uint32_t
ComputeExplicitGridEnd
(
uint32_t
aGridTemplateAreasEnd
)
{
uint32_t
end
=
NumExplicitTracks
(
)
+
1
;
end
=
std
:
:
max
(
end
aGridTemplateAreasEnd
)
;
end
=
std
:
:
min
(
end
uint32_t
(
kMaxLine
)
)
;
return
end
;
}
const
nsStyleCoord
&
MinSizingFor
(
uint32_t
aTrackIndex
)
const
{
if
(
MOZ_UNLIKELY
(
aTrackIndex
<
mExplicitGridOffset
)
)
{
return
mAutoMinSizing
;
}
uint32_t
index
=
aTrackIndex
-
mExplicitGridOffset
;
if
(
index
>
=
mRepeatAutoStart
)
{
if
(
index
<
mRepeatAutoEnd
)
{
return
mMinSizingFunctions
[
mRepeatAutoStart
]
;
}
index
-
=
mRepeatEndDelta
;
}
return
index
<
mMinSizingFunctions
.
Length
(
)
?
mMinSizingFunctions
[
index
]
:
mAutoMinSizing
;
}
const
nsStyleCoord
&
MaxSizingFor
(
uint32_t
aTrackIndex
)
const
{
if
(
MOZ_UNLIKELY
(
aTrackIndex
<
mExplicitGridOffset
)
)
{
return
mAutoMaxSizing
;
}
uint32_t
index
=
aTrackIndex
-
mExplicitGridOffset
;
if
(
index
>
=
mRepeatAutoStart
)
{
if
(
index
<
mRepeatAutoEnd
)
{
return
mMaxSizingFunctions
[
mRepeatAutoStart
]
;
}
index
-
=
mRepeatEndDelta
;
}
return
index
<
mMaxSizingFunctions
.
Length
(
)
?
mMaxSizingFunctions
[
index
]
:
mAutoMaxSizing
;
}
uint32_t
NumExplicitTracks
(
)
const
{
return
mMinSizingFunctions
.
Length
(
)
+
mRepeatEndDelta
;
}
uint32_t
NumRepeatTracks
(
)
const
{
return
mRepeatAutoEnd
-
mRepeatAutoStart
;
}
void
SetNumRepeatTracks
(
uint32_t
aNumRepeatTracks
)
{
MOZ_ASSERT
(
mHasRepeatAuto
|
|
aNumRepeatTracks
=
=
0
)
;
mRepeatAutoEnd
=
mRepeatAutoStart
+
aNumRepeatTracks
;
mRepeatEndDelta
=
mHasRepeatAuto
?
int32_t
(
aNumRepeatTracks
)
-
1
:
0
;
}
const
nsTArray
<
nsStyleCoord
>
&
mMinSizingFunctions
;
const
nsTArray
<
nsStyleCoord
>
&
mMaxSizingFunctions
;
const
nsStyleCoord
&
mAutoMinSizing
;
const
nsStyleCoord
&
mAutoMaxSizing
;
uint32_t
mExplicitGridOffset
;
const
uint32_t
mRepeatAutoStart
;
uint32_t
mRepeatAutoEnd
;
int32_t
mRepeatEndDelta
;
const
bool
mHasRepeatAuto
;
nsTArray
<
bool
>
mRemovedRepeatTracks
;
}
;
struct
MOZ_STACK_CLASS
nsGridContainerFrame
:
:
SubgridFallbackTrackSizingFunctions
{
SubgridFallbackTrackSizingFunctions
(
nsGridContainerFrame
*
aSubgridFrame
const
Subgrid
*
aSubgrid
nsGridContainerFrame
*
aParentGridContainer
LogicalAxis
aParentAxis
)
{
MOZ_ASSERT
(
aSubgrid
)
;
MOZ_ASSERT
(
aSubgridFrame
-
>
IsSubgrid
(
aSubgrid
-
>
mIsOrthogonal
?
GetOrthogonalAxis
(
aParentAxis
)
:
aParentAxis
)
)
;
nsGridContainerFrame
*
parent
=
aParentGridContainer
;
auto
parentAxis
=
aParentAxis
;
LineRange
range
=
aSubgrid
-
>
mArea
.
LineRangeForAxis
(
parentAxis
)
;
while
(
parent
-
>
IsSubgrid
(
parentAxis
)
)
{
const
auto
*
parentSubgrid
=
parent
-
>
GetProperty
(
Subgrid
:
:
Prop
(
)
)
;
auto
*
grandParent
=
parent
-
>
ParentGridContainerForSubgrid
(
)
;
auto
grandParentWM
=
grandParent
-
>
GetWritingMode
(
)
;
bool
isSameDirInAxis
=
parent
-
>
GetWritingMode
(
)
.
ParallelAxisStartsOnSameSide
(
parentAxis
grandParentWM
)
;
if
(
MOZ_UNLIKELY
(
!
isSameDirInAxis
)
)
{
auto
end
=
parentAxis
=
=
eLogicalAxisBlock
?
parentSubgrid
-
>
mGridRowEnd
:
parentSubgrid
-
>
mGridColEnd
;
range
.
ReverseDirection
(
end
)
;
}
auto
grandParentAxis
=
parentSubgrid
-
>
mIsOrthogonal
?
GetOrthogonalAxis
(
parentAxis
)
:
parentAxis
;
const
auto
&
parentRange
=
parentSubgrid
-
>
mArea
.
LineRangeForAxis
(
grandParentAxis
)
;
range
.
Translate
(
parentRange
.
mStart
)
;
parentAxis
=
grandParentAxis
;
parent
=
grandParent
;
}
const
auto
*
pos
=
parent
-
>
StylePosition
(
)
;
const
auto
isInlineAxis
=
parentAxis
=
=
eLogicalAxisInline
;
const
auto
&
szf
=
isInlineAxis
?
pos
-
>
GridTemplateColumns
(
)
:
pos
-
>
GridTemplateRows
(
)
;
const
auto
&
minAuto
=
isInlineAxis
?
pos
-
>
mGridAutoColumnsMin
:
pos
-
>
mGridAutoRowsMin
;
const
auto
&
maxAuto
=
isInlineAxis
?
pos
-
>
mGridAutoColumnsMax
:
pos
-
>
mGridAutoRowsMax
;
TrackSizingFunctions
tsf
(
szf
minAuto
maxAuto
)
;
for
(
auto
i
:
range
.
Range
(
)
)
{
mMinSizingFunctions
.
AppendElement
(
tsf
.
MinSizingFor
(
i
)
)
;
mMaxSizingFunctions
.
AppendElement
(
tsf
.
MaxSizingFor
(
i
)
)
;
}
mAutoMinSizing
=
&
minAuto
;
mAutoMaxSizing
=
&
maxAuto
;
}
nsTArray
<
nsStyleCoord
>
mMinSizingFunctions
;
nsTArray
<
nsStyleCoord
>
mMaxSizingFunctions
;
const
nsStyleCoord
*
mAutoMinSizing
;
const
nsStyleCoord
*
mAutoMaxSizing
;
uint32_t
mRepeatAutoIndex
=
0
;
bool
mHasRepeatAuto
=
false
;
}
;
struct
nsGridContainerFrame
:
:
Tracks
{
explicit
Tracks
(
LogicalAxis
aAxis
)
:
mContentBoxSize
(
NS_UNCONSTRAINEDSIZE
)
mGridGap
(
NS_UNCONSTRAINEDSIZE
)
mStateUnion
(
TrackSize
:
:
StateBits
(
0
)
)
mAxis
(
aAxis
)
mCanResolveLineRangeSize
(
false
)
{
mBaselineSubtreeAlign
[
BaselineSharingGroup
:
:
First
]
=
NS_STYLE_ALIGN_AUTO
;
mBaselineSubtreeAlign
[
BaselineSharingGroup
:
:
Last
]
=
NS_STYLE_ALIGN_AUTO
;
mBaseline
[
BaselineSharingGroup
:
:
First
]
=
NS_INTRINSIC_ISIZE_UNKNOWN
;
mBaseline
[
BaselineSharingGroup
:
:
Last
]
=
NS_INTRINSIC_ISIZE_UNKNOWN
;
}
void
Initialize
(
const
TrackSizingFunctions
&
aFunctions
const
NonNegativeLengthPercentageOrNormal
&
aGridGap
uint32_t
aNumTracks
nscoord
aContentBoxSize
)
;
TrackSize
:
:
StateBits
StateBitsForRange
(
const
LineRange
&
aRange
)
const
;
struct
ItemBaselineData
{
uint32_t
mBaselineTrack
;
nscoord
mBaseline
;
nscoord
mSize
;
GridItemInfo
*
mGridItem
;
static
bool
IsBaselineTrackLessThan
(
const
ItemBaselineData
&
a
const
ItemBaselineData
&
b
)
{
return
a
.
mBaselineTrack
<
b
.
mBaselineTrack
;
}
}
;
void
CalculateItemBaselines
(
nsTArray
<
ItemBaselineData
>
&
aBaselineItems
BaselineSharingGroup
aBaselineGroup
)
;
void
InitializeItemBaselines
(
GridReflowInput
&
aState
nsTArray
<
GridItemInfo
>
&
aGridItems
)
;
void
AlignBaselineSubtree
(
const
GridItemInfo
&
aGridItem
)
const
;
enum
class
TrackSizingPhase
{
IntrinsicMinimums
ContentBasedMinimums
MaxContentMinimums
IntrinsicMaximums
MaxContentMaximums
}
;
struct
Step2ItemData
final
{
uint32_t
mSpan
;
TrackSize
:
:
StateBits
mState
;
LineRange
mLineRange
;
nscoord
mMinSize
;
nscoord
mMinContentContribution
;
nscoord
mMaxContentContribution
;
nsIFrame
*
mFrame
;
static
bool
IsSpanLessThan
(
const
Step2ItemData
&
a
const
Step2ItemData
&
b
)
{
return
a
.
mSpan
<
b
.
mSpan
;
}
template
<
TrackSizingPhase
phase
>
nscoord
SizeContributionForPhase
(
)
const
{
switch
(
phase
)
{
case
TrackSizingPhase
:
:
IntrinsicMinimums
:
case
TrackSizingPhase
:
:
IntrinsicMaximums
:
return
mMinSize
;
case
TrackSizingPhase
:
:
ContentBasedMinimums
:
return
mMinContentContribution
;
case
TrackSizingPhase
:
:
MaxContentMinimums
:
case
TrackSizingPhase
:
:
MaxContentMaximums
:
return
mMaxContentContribution
;
}
MOZ_MAKE_COMPILER_ASSUME_IS_UNREACHABLE
(
"
Unexpected
phase
"
)
;
}
}
;
using
FitContentClamper
=
std
:
:
function
<
bool
(
uint32_t
aTrack
nscoord
aMinSize
nscoord
*
aSize
)
>
;
template
<
TrackSizingPhase
phase
>
bool
GrowSizeForSpanningItems
(
nsTArray
<
Step2ItemData
>
:
:
iterator
aIter
const
nsTArray
<
Step2ItemData
>
:
:
iterator
aEnd
nsTArray
<
uint32_t
>
&
aTracks
nsTArray
<
TrackSize
>
&
aPlan
nsTArray
<
TrackSize
>
&
aItemPlan
TrackSize
:
:
StateBits
aSelector
const
FitContentClamper
&
aClamper
=
nullptr
bool
aNeedInfinitelyGrowableFlag
=
false
)
;
void
ResolveIntrinsicSize
(
GridReflowInput
&
aState
nsTArray
<
GridItemInfo
>
&
aGridItems
const
TrackSizingFunctions
&
aFunctions
LineRange
GridArea
:
:
*
aRange
nscoord
aPercentageBasis
SizingConstraint
aConstraint
)
;
bool
ResolveIntrinsicSizeStep1
(
GridReflowInput
&
aState
const
TrackSizingFunctions
&
aFunctions
nscoord
aPercentageBasis
SizingConstraint
aConstraint
const
LineRange
&
aRange
const
GridItemInfo
&
aGridItem
)
;
template
<
TrackSizingPhase
phase
>
static
nscoord
StartSizeInDistribution
(
const
TrackSize
&
aSize
)
{
switch
(
phase
)
{
case
TrackSizingPhase
:
:
IntrinsicMinimums
:
case
TrackSizingPhase
:
:
ContentBasedMinimums
:
case
TrackSizingPhase
:
:
MaxContentMinimums
:
return
aSize
.
mBase
;
case
TrackSizingPhase
:
:
IntrinsicMaximums
:
case
TrackSizingPhase
:
:
MaxContentMaximums
:
if
(
aSize
.
mLimit
=
=
NS_UNCONSTRAINEDSIZE
)
{
return
aSize
.
mBase
;
}
return
aSize
.
mLimit
;
}
MOZ_MAKE_COMPILER_ASSUME_IS_UNREACHABLE
(
"
Unexpected
phase
"
)
;
}
template
<
TrackSizingPhase
phase
>
nscoord
CollectGrowable
(
nscoord
aAvailableSpace
const
LineRange
&
aRange
TrackSize
:
:
StateBits
aSelector
nsTArray
<
uint32_t
>
&
aGrowableTracks
)
const
{
MOZ_ASSERT
(
aAvailableSpace
>
0
"
why
call
me
?
"
)
;
nscoord
space
=
aAvailableSpace
-
mGridGap
*
(
aRange
.
Extent
(
)
-
1
)
;
for
(
auto
i
:
aRange
.
Range
(
)
)
{
const
TrackSize
&
sz
=
mSizes
[
i
]
;
space
-
=
StartSizeInDistribution
<
phase
>
(
sz
)
;
if
(
space
<
=
0
)
{
return
0
;
}
if
(
sz
.
mState
&
aSelector
)
{
aGrowableTracks
.
AppendElement
(
i
)
;
}
}
return
aGrowableTracks
.
IsEmpty
(
)
?
0
:
space
;
}
template
<
TrackSizingPhase
phase
>
void
InitializeItemPlan
(
nsTArray
<
TrackSize
>
&
aItemPlan
const
nsTArray
<
uint32_t
>
&
aTracks
)
const
{
for
(
uint32_t
track
:
aTracks
)
{
auto
&
plan
=
aItemPlan
[
track
]
;
const
TrackSize
&
sz
=
mSizes
[
track
]
;
plan
.
mBase
=
StartSizeInDistribution
<
phase
>
(
sz
)
;
bool
unlimited
=
sz
.
mState
&
TrackSize
:
:
eInfinitelyGrowable
;
plan
.
mLimit
=
unlimited
?
NS_UNCONSTRAINEDSIZE
:
sz
.
mLimit
;
plan
.
mState
=
sz
.
mState
;
}
}
template
<
TrackSizingPhase
phase
>
void
InitializePlan
(
nsTArray
<
TrackSize
>
&
aPlan
)
const
{
for
(
size_t
i
=
0
len
=
aPlan
.
Length
(
)
;
i
<
len
;
+
+
i
)
{
auto
&
plan
=
aPlan
[
i
]
;
const
auto
&
sz
=
mSizes
[
i
]
;
plan
.
mBase
=
StartSizeInDistribution
<
phase
>
(
sz
)
;
MOZ_ASSERT
(
phase
=
=
TrackSizingPhase
:
:
MaxContentMaximums
|
|
!
(
sz
.
mState
&
TrackSize
:
:
eInfinitelyGrowable
)
"
forgot
to
reset
the
eInfinitelyGrowable
bit
?
"
)
;
plan
.
mState
=
sz
.
mState
;
}
}
template
<
TrackSizingPhase
phase
>
void
CopyPlanToSize
(
const
nsTArray
<
TrackSize
>
&
aPlan
bool
aNeedInfinitelyGrowableFlag
=
false
)
{
for
(
size_t
i
=
0
len
=
mSizes
.
Length
(
)
;
i
<
len
;
+
+
i
)
{
const
auto
&
plan
=
aPlan
[
i
]
;
MOZ_ASSERT
(
plan
.
mBase
>
=
0
)
;
auto
&
sz
=
mSizes
[
i
]
;
switch
(
phase
)
{
case
TrackSizingPhase
:
:
IntrinsicMinimums
:
case
TrackSizingPhase
:
:
ContentBasedMinimums
:
case
TrackSizingPhase
:
:
MaxContentMinimums
:
sz
.
mBase
=
plan
.
mBase
;
break
;
case
TrackSizingPhase
:
:
IntrinsicMaximums
:
if
(
plan
.
mState
&
TrackSize
:
:
eModified
)
{
if
(
sz
.
mLimit
=
=
NS_UNCONSTRAINEDSIZE
&
&
aNeedInfinitelyGrowableFlag
)
{
sz
.
mState
|
=
TrackSize
:
:
eInfinitelyGrowable
;
}
sz
.
mLimit
=
plan
.
mBase
;
}
break
;
case
TrackSizingPhase
:
:
MaxContentMaximums
:
if
(
plan
.
mState
&
TrackSize
:
:
eModified
)
{
sz
.
mLimit
=
plan
.
mBase
;
}
sz
.
mState
&
=
~
TrackSize
:
:
eInfinitelyGrowable
;
break
;
}
}
}
nscoord
GrowTracksToLimit
(
nscoord
aAvailableSpace
nsTArray
<
TrackSize
>
&
aPlan
const
nsTArray
<
uint32_t
>
&
aGrowableTracks
const
FitContentClamper
&
aFitContentClamper
)
const
{
MOZ_ASSERT
(
aAvailableSpace
>
0
&
&
aGrowableTracks
.
Length
(
)
>
0
)
;
nscoord
space
=
aAvailableSpace
;
uint32_t
numGrowable
=
aGrowableTracks
.
Length
(
)
;
while
(
true
)
{
nscoord
spacePerTrack
=
std
:
:
max
<
nscoord
>
(
space
/
numGrowable
1
)
;
for
(
uint32_t
track
:
aGrowableTracks
)
{
TrackSize
&
sz
=
aPlan
[
track
]
;
if
(
sz
.
IsFrozen
(
)
)
{
continue
;
}
nscoord
newBase
=
sz
.
mBase
+
spacePerTrack
;
nscoord
limit
=
sz
.
mLimit
;
if
(
MOZ_UNLIKELY
(
(
sz
.
mState
&
TrackSize
:
:
eFitContent
)
&
&
aFitContentClamper
)
)
{
aFitContentClamper
(
track
sz
.
mBase
&
limit
)
;
}
if
(
newBase
>
limit
)
{
nscoord
consumed
=
limit
-
sz
.
mBase
;
if
(
consumed
>
0
)
{
space
-
=
consumed
;
sz
.
mBase
=
limit
;
}
sz
.
mState
|
=
TrackSize
:
:
eFrozen
;
if
(
-
-
numGrowable
=
=
0
)
{
return
space
;
}
}
else
{
sz
.
mBase
=
newBase
;
space
-
=
spacePerTrack
;
}
MOZ_ASSERT
(
space
>
=
0
)
;
if
(
space
=
=
0
)
{
return
0
;
}
}
}
MOZ_ASSERT_UNREACHABLE
(
"
we
don
'
t
exit
the
loop
above
except
by
return
"
)
;
return
0
;
}
static
uint32_t
MarkExcludedTracks
(
nsTArray
<
TrackSize
>
&
aPlan
uint32_t
aNumGrowable
const
nsTArray
<
uint32_t
>
&
aGrowableTracks
TrackSize
:
:
StateBits
aMinSizingSelector
TrackSize
:
:
StateBits
aMaxSizingSelector
TrackSize
:
:
StateBits
aSkipFlag
)
{
bool
foundOneSelected
=
false
;
bool
foundOneGrowable
=
false
;
uint32_t
numGrowable
=
aNumGrowable
;
for
(
uint32_t
track
:
aGrowableTracks
)
{
TrackSize
&
sz
=
aPlan
[
track
]
;
const
auto
state
=
sz
.
mState
;
if
(
state
&
aMinSizingSelector
)
{
foundOneSelected
=
true
;
if
(
state
&
aMaxSizingSelector
)
{
foundOneGrowable
=
true
;
continue
;
}
sz
.
mState
|
=
aSkipFlag
;
MOZ_ASSERT
(
numGrowable
!
=
0
)
;
-
-
numGrowable
;
}
}
if
(
foundOneSelected
&
&
!
foundOneGrowable
)
{
for
(
uint32_t
track
:
aGrowableTracks
)
{
aPlan
[
track
]
.
mState
&
=
~
aSkipFlag
;
}
numGrowable
=
aNumGrowable
;
}
return
numGrowable
;
}
template
<
TrackSizingPhase
phase
>
static
uint32_t
MarkExcludedTracks
(
nsTArray
<
TrackSize
>
&
aPlan
const
nsTArray
<
uint32_t
>
&
aGrowableTracks
TrackSize
:
:
StateBits
aSelector
)
{
uint32_t
numGrowable
=
aGrowableTracks
.
Length
(
)
;
if
(
phase
=
=
TrackSizingPhase
:
:
IntrinsicMaximums
|
|
phase
=
=
TrackSizingPhase
:
:
MaxContentMaximums
)
{
return
numGrowable
;
}
MOZ_ASSERT
(
aSelector
=
=
(
aSelector
&
TrackSize
:
:
eIntrinsicMinSizing
)
&
&
(
aSelector
&
TrackSize
:
:
eMaxContentMinSizing
)
"
Should
only
get
here
for
track
sizing
steps
2
.
1
to
2
.
3
"
)
;
numGrowable
=
MarkExcludedTracks
(
aPlan
numGrowable
aGrowableTracks
TrackSize
:
:
eMaxContentMinSizing
TrackSize
:
:
eMaxContentMaxSizing
TrackSize
:
:
eSkipGrowUnlimited1
)
;
auto
minOrAutoSelector
=
aSelector
&
~
TrackSize
:
:
eMaxContentMinSizing
;
if
(
minOrAutoSelector
)
{
numGrowable
=
MarkExcludedTracks
(
aPlan
numGrowable
aGrowableTracks
minOrAutoSelector
TrackSize
:
:
eIntrinsicMaxSizing
TrackSize
:
:
eSkipGrowUnlimited2
)
;
}
return
numGrowable
;
}
void
GrowSelectedTracksUnlimited
(
nscoord
aAvailableSpace
nsTArray
<
TrackSize
>
&
aPlan
const
nsTArray
<
uint32_t
>
&
aGrowableTracks
uint32_t
aNumGrowable
const
FitContentClamper
&
aFitContentClamper
)
const
{
MOZ_ASSERT
(
aAvailableSpace
>
0
&
&
aGrowableTracks
.
Length
(
)
>
0
&
&
aNumGrowable
<
=
aGrowableTracks
.
Length
(
)
)
;
nscoord
space
=
aAvailableSpace
;
DebugOnly
<
bool
>
didClamp
=
false
;
while
(
aNumGrowable
)
{
nscoord
spacePerTrack
=
std
:
:
max
<
nscoord
>
(
space
/
aNumGrowable
1
)
;
for
(
uint32_t
track
:
aGrowableTracks
)
{
TrackSize
&
sz
=
aPlan
[
track
]
;
if
(
sz
.
mState
&
TrackSize
:
:
eSkipGrowUnlimited
)
{
continue
;
}
nscoord
delta
=
spacePerTrack
;
nscoord
newBase
=
sz
.
mBase
+
delta
;
if
(
MOZ_UNLIKELY
(
(
sz
.
mState
&
TrackSize
:
:
eFitContent
)
&
&
aFitContentClamper
)
)
{
if
(
aFitContentClamper
(
track
sz
.
mBase
&
newBase
)
)
{
didClamp
=
true
;
delta
=
newBase
-
sz
.
mBase
;
MOZ_ASSERT
(
delta
>
=
0
"
track
size
shouldn
'
t
shrink
"
)
;
sz
.
mState
|
=
TrackSize
:
:
eSkipGrowUnlimited1
;
-
-
aNumGrowable
;
}
}
sz
.
mBase
=
newBase
;
space
-
=
delta
;
MOZ_ASSERT
(
space
>
=
0
)
;
if
(
space
=
=
0
)
{
return
;
}
}
}
MOZ_ASSERT
(
didClamp
"
we
don
'
t
exit
the
loop
above
except
by
return
"
"
unless
we
clamped
some
track
'
s
size
"
)
;
}
template
<
TrackSizingPhase
phase
>
void
DistributeToTrackSizes
(
nscoord
aAvailableSpace
nsTArray
<
TrackSize
>
&
aPlan
nsTArray
<
TrackSize
>
&
aItemPlan
nsTArray
<
uint32_t
>
&
aGrowableTracks
TrackSize
:
:
StateBits
aSelector
const
FitContentClamper
&
aFitContentClamper
)
{
InitializeItemPlan
<
phase
>
(
aItemPlan
aGrowableTracks
)
;
nscoord
space
=
GrowTracksToLimit
(
aAvailableSpace
aItemPlan
aGrowableTracks
aFitContentClamper
)
;
if
(
space
>
0
)
{
uint32_t
numGrowable
=
MarkExcludedTracks
<
phase
>
(
aItemPlan
aGrowableTracks
aSelector
)
;
GrowSelectedTracksUnlimited
(
space
aItemPlan
aGrowableTracks
numGrowable
aFitContentClamper
)
;
}
for
(
uint32_t
track
:
aGrowableTracks
)
{
nscoord
&
plannedSize
=
aPlan
[
track
]
.
mBase
;
nscoord
itemIncurredSize
=
aItemPlan
[
track
]
.
mBase
;
if
(
plannedSize
<
itemIncurredSize
)
{
plannedSize
=
itemIncurredSize
;
}
}
}
void
DistributeFreeSpace
(
nscoord
aAvailableSize
)
{
const
uint32_t
numTracks
=
mSizes
.
Length
(
)
;
if
(
MOZ_UNLIKELY
(
numTracks
=
=
0
|
|
aAvailableSize
<
=
0
)
)
{
return
;
}
if
(
aAvailableSize
=
=
NS_UNCONSTRAINEDSIZE
)
{
for
(
TrackSize
&
sz
:
mSizes
)
{
sz
.
mBase
=
sz
.
mLimit
;
}
}
else
{
nscoord
space
=
aAvailableSize
;
uint32_t
numGrowable
=
numTracks
;
for
(
const
TrackSize
&
sz
:
mSizes
)
{
space
-
=
sz
.
mBase
;
MOZ_ASSERT
(
sz
.
mBase
<
=
sz
.
mLimit
)
;
if
(
sz
.
mBase
=
=
sz
.
mLimit
)
{
-
-
numGrowable
;
}
}
while
(
space
>
0
&
&
numGrowable
)
{
nscoord
spacePerTrack
=
std
:
:
max
<
nscoord
>
(
space
/
numGrowable
1
)
;
for
(
uint32_t
i
=
0
;
i
<
numTracks
&
&
space
>
0
;
+
+
i
)
{
TrackSize
&
sz
=
mSizes
[
i
]
;
if
(
sz
.
mBase
=
=
sz
.
mLimit
)
{
continue
;
}
nscoord
newBase
=
sz
.
mBase
+
spacePerTrack
;
if
(
newBase
>
=
sz
.
mLimit
)
{
space
-
=
sz
.
mLimit
-
sz
.
mBase
;
sz
.
mBase
=
sz
.
mLimit
;
-
-
numGrowable
;
}
else
{
space
-
=
spacePerTrack
;
sz
.
mBase
=
newBase
;
}
}
}
}
}
float
FindFrUnitSize
(
const
LineRange
&
aRange
const
nsTArray
<
uint32_t
>
&
aFlexTracks
const
TrackSizingFunctions
&
aFunctions
nscoord
aSpaceToFill
)
const
;
float
FindUsedFlexFraction
(
GridReflowInput
&
aState
nsTArray
<
GridItemInfo
>
&
aGridItems
const
nsTArray
<
uint32_t
>
&
aFlexTracks
const
TrackSizingFunctions
&
aFunctions
nscoord
aAvailableSize
)
const
;
void
StretchFlexibleTracks
(
GridReflowInput
&
aState
nsTArray
<
GridItemInfo
>
&
aGridItems
const
TrackSizingFunctions
&
aFunctions
nscoord
aAvailableSize
)
;
void
CalculateSizes
(
GridReflowInput
&
aState
nsTArray
<
GridItemInfo
>
&
aGridItems
const
TrackSizingFunctions
&
aFunctions
nscoord
aContentBoxSize
LineRange
GridArea
:
:
*
aRange
SizingConstraint
aConstraint
)
;
void
AlignJustifyContent
(
const
nsStylePosition
*
aStyle
WritingMode
aWM
nscoord
aContentBoxSize
bool
aIsSubgridded
)
;
nscoord
GridLineEdge
(
uint32_t
aLine
GridLineSide
aSide
)
const
{
if
(
MOZ_UNLIKELY
(
mSizes
.
IsEmpty
(
)
)
)
{
MOZ_ASSERT
(
aLine
=
=
0
"
We
should
only
resolve
line
1
in
an
empty
grid
"
)
;
return
nscoord
(
0
)
;
}
MOZ_ASSERT
(
aLine
<
=
mSizes
.
Length
(
)
"
mSizes
is
too
small
"
)
;
if
(
aSide
=
=
GridLineSide
:
:
BeforeGridGap
)
{
if
(
aLine
=
=
0
)
{
return
nscoord
(
0
)
;
}
const
TrackSize
&
sz
=
mSizes
[
aLine
-
1
]
;
return
sz
.
mPosition
+
sz
.
mBase
;
}
if
(
aLine
=
=
mSizes
.
Length
(
)
)
{
return
mContentBoxSize
;
}
return
mSizes
[
aLine
]
.
mPosition
;
}
nscoord
SumOfGridGaps
(
)
const
{
auto
len
=
mSizes
.
Length
(
)
;
return
MOZ_LIKELY
(
len
>
1
)
?
(
len
-
1
)
*
mGridGap
:
0
;
}
void
BreakBeforeRow
(
uint32_t
aRow
)
{
MOZ_ASSERT
(
mAxis
=
=
eLogicalAxisBlock
"
Should
only
be
fragmenting
in
the
block
axis
(
between
rows
)
"
)
;
nscoord
prevRowEndPos
=
0
;
if
(
aRow
!
=
0
)
{
auto
&
prevSz
=
mSizes
[
aRow
-
1
]
;
prevRowEndPos
=
prevSz
.
mPosition
+
prevSz
.
mBase
;
}
auto
&
sz
=
mSizes
[
aRow
]
;
const
nscoord
gap
=
sz
.
mPosition
-
prevRowEndPos
;
sz
.
mState
|
=
TrackSize
:
:
eBreakBefore
;
if
(
gap
!
=
0
)
{
for
(
uint32_t
i
=
aRow
len
=
mSizes
.
Length
(
)
;
i
<
len
;
+
+
i
)
{
mSizes
[
i
]
.
mPosition
-
=
gap
;
}
}
}
void
ResizeRow
(
uint32_t
aRow
nscoord
aNewSize
)
{
MOZ_ASSERT
(
mAxis
=
=
eLogicalAxisBlock
"
Should
only
be
fragmenting
in
the
block
axis
(
between
rows
)
"
)
;
MOZ_ASSERT
(
aNewSize
>
=
0
)
;
auto
&
sz
=
mSizes
[
aRow
]
;
nscoord
delta
=
aNewSize
-
sz
.
mBase
;
NS_WARNING_ASSERTION
(
delta
!
=
nscoord
(
0
)
"
Useless
call
to
ResizeRow
"
)
;
sz
.
mBase
=
aNewSize
;
const
uint32_t
numRows
=
mSizes
.
Length
(
)
;
for
(
uint32_t
r
=
aRow
+
1
;
r
<
numRows
;
+
+
r
)
{
mSizes
[
r
]
.
mPosition
+
=
delta
;
}
}
nscoord
ResolveSize
(
const
LineRange
&
aRange
)
const
{
MOZ_ASSERT
(
mCanResolveLineRangeSize
)
;
MOZ_ASSERT
(
aRange
.
Extent
(
)
>
0
"
grid
items
cover
at
least
one
track
"
)
;
nscoord
pos
size
;
aRange
.
ToPositionAndLength
(
mSizes
&
pos
&
size
)
;
return
size
;
}
nsTArray
<
RefPtr
<
nsAtom
>
>
GetExplicitLineNamesAtIndex
(
const
nsStyleGridTemplate
&
aGridTemplate
const
TrackSizingFunctions
&
aFunctions
uint32_t
aIndex
)
{
nsTArray
<
RefPtr
<
nsAtom
>
>
lineNames
;
bool
hasRepeatAuto
=
aGridTemplate
.
HasRepeatAuto
(
)
;
const
nsTArray
<
nsTArray
<
RefPtr
<
nsAtom
>
>
>
&
lineNameLists
=
aGridTemplate
.
mLineNameLists
;
if
(
!
hasRepeatAuto
)
{
if
(
aIndex
<
lineNameLists
.
Length
(
)
)
{
lineNames
.
AppendElements
(
lineNameLists
[
aIndex
]
)
;
}
}
else
{
const
uint32_t
repeatTrackCount
=
aFunctions
.
NumRepeatTracks
(
)
;
const
uint32_t
repeatAutoStart
=
aGridTemplate
.
mRepeatAutoIndex
;
const
uint32_t
repeatAutoEnd
=
(
repeatAutoStart
+
repeatTrackCount
)
;
const
int32_t
repeatEndDelta
=
int32_t
(
repeatTrackCount
-
1
)
;
if
(
aIndex
<
=
repeatAutoStart
)
{
if
(
aIndex
<
lineNameLists
.
Length
(
)
)
{
lineNames
.
AppendElements
(
lineNameLists
[
aIndex
]
)
;
}
}
if
(
aIndex
<
=
repeatAutoEnd
&
&
aIndex
>
repeatAutoStart
)
{
lineNames
.
AppendElements
(
aGridTemplate
.
mRepeatAutoLineNameListAfter
)
;
}
if
(
aIndex
<
repeatAutoEnd
&
&
aIndex
>
=
repeatAutoStart
)
{
lineNames
.
AppendElements
(
aGridTemplate
.
mRepeatAutoLineNameListBefore
)
;
}
if
(
aIndex
>
repeatAutoEnd
&
&
aIndex
>
repeatAutoStart
)
{
uint32_t
i
=
aIndex
-
repeatEndDelta
;
if
(
i
<
lineNameLists
.
Length
(
)
)
{
lineNames
.
AppendElements
(
lineNameLists
[
i
]
)
;
}
}
}
return
lineNames
;
}
#
ifdef
DEBUG
void
Dump
(
)
const
{
for
(
uint32_t
i
=
0
len
=
mSizes
.
Length
(
)
;
i
<
len
;
+
+
i
)
{
printf
(
"
%
d
:
"
i
)
;
mSizes
[
i
]
.
Dump
(
)
;
printf
(
"
\
n
"
)
;
}
}
#
endif
AutoTArray
<
TrackSize
32
>
mSizes
;
nscoord
mContentBoxSize
;
nscoord
mGridGap
;
PerBaseline
<
nscoord
>
mBaseline
;
TrackSize
:
:
StateBits
mStateUnion
;
LogicalAxis
mAxis
;
PerBaseline
<
uint8_t
>
mBaselineSubtreeAlign
;
bool
mCanResolveLineRangeSize
;
}
;
struct
nsGridContainerFrame
:
:
SharedGridData
{
SharedGridData
(
)
:
mCols
(
eLogicalAxisInline
)
mRows
(
eLogicalAxisBlock
)
mGenerateComputedGridInfo
(
false
)
{
}
Tracks
mCols
;
Tracks
mRows
;
struct
RowData
{
nscoord
mBase
;
nscoord
mGap
;
}
;
nsTArray
<
RowData
>
mOriginalRowData
;
nsTArray
<
GridItemInfo
>
mGridItems
;
nsTArray
<
GridItemInfo
>
mAbsPosItems
;
bool
mGenerateComputedGridInfo
;
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
Prop
SharedGridData
)
}
;
struct
MOZ_STACK_CLASS
nsGridContainerFrame
:
:
GridReflowInput
{
GridReflowInput
(
nsGridContainerFrame
*
aFrame
const
ReflowInput
&
aRI
)
:
GridReflowInput
(
aFrame
*
aRI
.
mRenderingContext
&
aRI
aRI
.
mStylePosition
aRI
.
GetWritingMode
(
)
)
{
}
GridReflowInput
(
nsGridContainerFrame
*
aFrame
gfxContext
&
aRC
)
:
GridReflowInput
(
aFrame
aRC
nullptr
aFrame
-
>
StylePosition
(
)
aFrame
-
>
GetWritingMode
(
)
)
{
}
void
InitializeForContinuation
(
nsGridContainerFrame
*
aGridContainerFrame
nscoord
aConsumedBSize
)
{
MOZ_ASSERT
(
aGridContainerFrame
-
>
GetPrevInFlow
(
)
"
don
'
t
call
this
on
the
first
-
in
-
flow
"
)
;
MOZ_ASSERT
(
mGridItems
.
IsEmpty
(
)
&
&
mAbsPosItems
.
IsEmpty
(
)
"
shouldn
'
t
have
any
item
data
yet
"
)
;
uint32_t
fragment
=
0
;
nsIFrame
*
firstInFlow
=
aGridContainerFrame
;
for
(
auto
pif
=
aGridContainerFrame
-
>
GetPrevInFlow
(
)
;
pif
;
pif
=
pif
-
>
GetPrevInFlow
(
)
)
{
+
+
fragment
;
firstInFlow
=
pif
;
}
mSharedGridData
=
firstInFlow
-
>
GetProperty
(
SharedGridData
:
:
Prop
(
)
)
;
MOZ_ASSERT
(
mSharedGridData
"
first
-
in
-
flow
must
have
SharedGridData
"
)
;
auto
&
rowSizes
=
mSharedGridData
-
>
mRows
.
mSizes
;
const
uint32_t
numRows
=
rowSizes
.
Length
(
)
;
mStartRow
=
numRows
;
for
(
uint32_t
row
=
0
breakCount
=
0
;
row
<
numRows
;
+
+
row
)
{
if
(
rowSizes
[
row
]
.
mState
&
TrackSize
:
:
eBreakBefore
)
{
if
(
fragment
=
=
+
+
breakCount
)
{
mStartRow
=
row
;
mFragBStart
=
rowSizes
[
row
]
.
mPosition
;
const
auto
&
origRowData
=
mSharedGridData
-
>
mOriginalRowData
;
rowSizes
[
row
]
.
mBase
=
origRowData
[
row
]
.
mBase
;
nscoord
prevEndPos
=
rowSizes
[
row
]
.
mPosition
+
rowSizes
[
row
]
.
mBase
;
while
(
+
+
row
<
numRows
)
{
auto
&
sz
=
rowSizes
[
row
]
;
const
auto
&
orig
=
origRowData
[
row
]
;
sz
.
mPosition
=
prevEndPos
+
orig
.
mGap
;
sz
.
mBase
=
orig
.
mBase
;
sz
.
mState
&
=
~
TrackSize
:
:
eBreakBefore
;
prevEndPos
=
sz
.
mPosition
+
sz
.
mBase
;
}
break
;
}
}
}
if
(
mStartRow
=
=
numRows
)
{
mFragBStart
=
aConsumedBSize
;
}
mCols
=
mSharedGridData
-
>
mCols
;
mRows
=
mSharedGridData
-
>
mRows
;
if
(
firstInFlow
-
>
GetProperty
(
UsedTrackSizes
:
:
Prop
(
)
)
)
{
auto
*
prop
=
aGridContainerFrame
-
>
GetProperty
(
UsedTrackSizes
:
:
Prop
(
)
)
;
if
(
!
prop
)
{
prop
=
new
UsedTrackSizes
(
)
;
aGridContainerFrame
-
>
SetProperty
(
UsedTrackSizes
:
:
Prop
(
)
prop
)
;
}
prop
-
>
mCanResolveLineRangeSize
=
{
true
true
}
;
prop
-
>
mSizes
[
eLogicalAxisInline
]
=
mCols
.
mSizes
;
prop
-
>
mSizes
[
eLogicalAxisBlock
]
=
mRows
.
mSizes
;
}
mIter
.
Reset
(
)
;
for
(
;
!
mIter
.
AtEnd
(
)
;
mIter
.
Next
(
)
)
{
nsIFrame
*
child
=
*
mIter
;
nsIFrame
*
childFirstInFlow
=
child
-
>
FirstInFlow
(
)
;
DebugOnly
<
size_t
>
len
=
mGridItems
.
Length
(
)
;
for
(
auto
&
itemInfo
:
mSharedGridData
-
>
mGridItems
)
{
if
(
itemInfo
.
mFrame
=
=
childFirstInFlow
)
{
auto
item
=
mGridItems
.
AppendElement
(
GridItemInfo
(
child
itemInfo
.
mArea
)
)
;
item
-
>
mState
[
0
]
|
=
itemInfo
.
mState
[
0
]
&
ItemState
:
:
eAllBaselineBits
;
item
-
>
mState
[
1
]
|
=
itemInfo
.
mState
[
1
]
&
ItemState
:
:
eAllBaselineBits
;
item
-
>
mBaselineOffset
[
0
]
=
itemInfo
.
mBaselineOffset
[
0
]
;
item
-
>
mBaselineOffset
[
1
]
=
itemInfo
.
mBaselineOffset
[
1
]
;
break
;
}
}
MOZ_ASSERT
(
mGridItems
.
Length
(
)
=
=
len
+
1
"
can
'
t
find
GridItemInfo
"
)
;
}
nsFrameList
absPosChildren
(
aGridContainerFrame
-
>
GetChildList
(
aGridContainerFrame
-
>
GetAbsoluteListID
(
)
)
)
;
for
(
auto
f
:
absPosChildren
)
{
nsIFrame
*
childFirstInFlow
=
f
-
>
FirstInFlow
(
)
;
DebugOnly
<
size_t
>
len
=
mAbsPosItems
.
Length
(
)
;
for
(
auto
&
itemInfo
:
mSharedGridData
-
>
mAbsPosItems
)
{
if
(
itemInfo
.
mFrame
=
=
childFirstInFlow
)
{
mAbsPosItems
.
AppendElement
(
GridItemInfo
(
f
itemInfo
.
mArea
)
)
;
break
;
}
}
MOZ_ASSERT
(
mAbsPosItems
.
Length
(
)
=
=
len
+
1
"
can
'
t
find
GridItemInfo
"
)
;
}
if
(
mSharedGridData
-
>
mGenerateComputedGridInfo
)
{
aGridContainerFrame
-
>
AddStateBits
(
NS_STATE_GRID_GENERATE_COMPUTED_VALUES
)
;
}
}
void
CalculateTrackSizesForAxis
(
LogicalAxis
aAxis
const
Grid
&
aGrid
nscoord
aCBSize
SizingConstraint
aConstraint
)
;
void
CalculateTrackSizes
(
const
Grid
&
aGrid
const
LogicalSize
&
aContentBox
SizingConstraint
aConstraint
)
;
LogicalSize
PercentageBasisFor
(
LogicalAxis
aAxis
const
GridItemInfo
&
aGridItem
)
const
;
LogicalRect
ContainingBlockFor
(
const
GridArea
&
aArea
)
const
;
LogicalRect
ContainingBlockForAbsPos
(
const
GridArea
&
aArea
const
LogicalPoint
&
aGridOrigin
const
LogicalRect
&
aGridCB
)
const
;
static
void
CollectSubgridForAxis
(
LogicalAxis
aAxis
WritingMode
aContainerWM
const
LineRange
&
aRangeInAxis
const
LineRange
&
aRangeInOppositeAxis
const
GridItemInfo
&
aItem
const
nsTArray
<
GridItemInfo
>
&
aItems
nsTArray
<
GridItemInfo
>
&
aResult
)
{
const
auto
oppositeAxis
=
GetOrthogonalAxis
(
aAxis
)
;
bool
itemIsSubgridInOppositeAxis
=
aItem
.
IsSubgrid
(
oppositeAxis
)
;
auto
subgridWM
=
aItem
.
mFrame
-
>
GetWritingMode
(
)
;
bool
isOrthogonal
=
subgridWM
.
IsOrthogonalTo
(
aContainerWM
)
;
bool
isSameDirInAxis
=
subgridWM
.
ParallelAxisStartsOnSameSide
(
aAxis
aContainerWM
)
;
bool
isSameDirInOppositeAxis
=
subgridWM
.
ParallelAxisStartsOnSameSide
(
oppositeAxis
aContainerWM
)
;
if
(
isOrthogonal
)
{
Swap
(
isSameDirInAxis
isSameDirInOppositeAxis
)
;
}
uint32_t
offsetInAxis
=
aRangeInAxis
.
mStart
;
uint32_t
gridEndInAxis
=
aRangeInAxis
.
Extent
(
)
;
uint32_t
offsetInOppositeAxis
=
aRangeInOppositeAxis
.
mStart
;
uint32_t
gridEndInOppositeAxis
=
aRangeInOppositeAxis
.
Extent
(
)
;
for
(
const
auto
&
subgridItem
:
aItems
)
{
auto
*
newItem
=
aResult
.
AppendElement
(
isOrthogonal
?
subgridItem
.
Transpose
(
)
:
subgridItem
)
;
if
(
MOZ_UNLIKELY
(
!
isSameDirInAxis
)
)
{
newItem
-
>
ReverseDirection
(
aAxis
gridEndInAxis
)
;
}
newItem
-
>
mArea
.
LineRangeForAxis
(
aAxis
)
.
Translate
(
offsetInAxis
)
;
if
(
itemIsSubgridInOppositeAxis
)
{
if
(
MOZ_UNLIKELY
(
!
isSameDirInOppositeAxis
)
)
{
newItem
-
>
ReverseDirection
(
oppositeAxis
gridEndInOppositeAxis
)
;
}
LineRange
&
range
=
newItem
-
>
mArea
.
LineRangeForAxis
(
oppositeAxis
)
;
range
.
Translate
(
offsetInOppositeAxis
)
;
}
if
(
newItem
-
>
IsSubgrid
(
aAxis
)
)
{
auto
*
subgrid
=
subgridItem
.
SubgridFrame
(
)
-
>
GetProperty
(
Subgrid
:
:
Prop
(
)
)
;
CollectSubgridForAxis
(
aAxis
aContainerWM
newItem
-
>
mArea
.
LineRangeForAxis
(
aAxis
)
newItem
-
>
mArea
.
LineRangeForAxis
(
oppositeAxis
)
*
newItem
subgrid
-
>
mGridItems
aResult
)
;
}
}
}
void
CollectSubgridItemsForAxis
(
LogicalAxis
aAxis
nsTArray
<
GridItemInfo
>
&
aResult
)
const
{
for
(
const
auto
&
item
:
mGridItems
)
{
if
(
item
.
IsSubgrid
(
aAxis
)
)
{
const
auto
oppositeAxis
=
GetOrthogonalAxis
(
aAxis
)
;
auto
*
subgrid
=
item
.
SubgridFrame
(
)
-
>
GetProperty
(
Subgrid
:
:
Prop
(
)
)
;
CollectSubgridForAxis
(
aAxis
mWM
item
.
mArea
.
LineRangeForAxis
(
aAxis
)
item
.
mArea
.
LineRangeForAxis
(
oppositeAxis
)
item
subgrid
-
>
mGridItems
aResult
)
;
}
}
}
CSSOrderAwareFrameIterator
mIter
;
const
nsStylePosition
*
const
mGridStyle
;
Tracks
mCols
;
Tracks
mRows
;
TrackSizingFunctions
mColFunctions
;
TrackSizingFunctions
mRowFunctions
;
nsTArray
<
GridItemInfo
>
mGridItems
;
nsTArray
<
GridItemInfo
>
mAbsPosItems
;
const
ReflowInput
*
const
mReflowInput
;
gfxContext
&
mRenderingContext
;
nsGridContainerFrame
*
const
mFrame
;
SharedGridData
*
mSharedGridData
;
LogicalMargin
mBorderPadding
;
nscoord
mFragBStart
;
uint32_t
mStartRow
;
uint32_t
mNextFragmentStartRow
;
LogicalSides
mSkipSides
;
const
WritingMode
mWM
;
bool
mInFragmentainer
;
private
:
GridReflowInput
(
nsGridContainerFrame
*
aFrame
gfxContext
&
aRenderingContext
const
ReflowInput
*
aReflowInput
const
nsStylePosition
*
aGridStyle
const
WritingMode
&
aWM
)
:
mIter
(
aFrame
kPrincipalList
)
mGridStyle
(
aGridStyle
)
mCols
(
eLogicalAxisInline
)
mRows
(
eLogicalAxisBlock
)
mColFunctions
(
mGridStyle
-
>
GridTemplateColumns
(
)
mGridStyle
-
>
mGridAutoColumnsMin
mGridStyle
-
>
mGridAutoColumnsMax
)
mRowFunctions
(
mGridStyle
-
>
GridTemplateRows
(
)
mGridStyle
-
>
mGridAutoRowsMin
mGridStyle
-
>
mGridAutoRowsMax
)
mReflowInput
(
aReflowInput
)
mRenderingContext
(
aRenderingContext
)
mFrame
(
aFrame
)
mSharedGridData
(
nullptr
)
mBorderPadding
(
aWM
)
mFragBStart
(
0
)
mStartRow
(
0
)
mNextFragmentStartRow
(
0
)
mWM
(
aWM
)
mInFragmentainer
(
false
)
{
MOZ_ASSERT
(
!
aReflowInput
|
|
aReflowInput
-
>
mFrame
=
=
mFrame
)
;
if
(
aReflowInput
)
{
mBorderPadding
=
aReflowInput
-
>
ComputedLogicalBorderPadding
(
)
;
mSkipSides
=
aFrame
-
>
PreReflowBlockLevelLogicalSkipSides
(
)
;
mBorderPadding
.
ApplySkipSides
(
mSkipSides
)
;
}
}
}
;
using
GridReflowInput
=
nsGridContainerFrame
:
:
GridReflowInput
;
struct
MOZ_STACK_CLASS
nsGridContainerFrame
:
:
Grid
{
explicit
Grid
(
const
Grid
*
aParentGrid
=
nullptr
)
:
mParentGrid
(
aParentGrid
)
{
}
void
PlaceGridItems
(
GridReflowInput
&
aState
const
RepeatTrackSizingInput
&
aRepeatSizing
)
;
void
SubgridPlaceGridItems
(
GridReflowInput
&
aParentState
Grid
*
aParentGrid
const
GridItemInfo
&
aGridItem
)
;
LineRange
ResolveAbsPosLineRange
(
const
StyleGridLine
&
aStart
const
StyleGridLine
&
aEnd
const
LineNameMap
&
aNameMap
LogicalAxis
aAxis
uint32_t
aExplicitGridEnd
int32_t
aGridStart
int32_t
aGridEnd
const
nsStylePosition
*
aStyle
)
;
GridArea
PlaceAbsPos
(
nsIFrame
*
aChild
const
LineNameMap
&
aColLineNameMap
const
LineNameMap
&
aRowLineNameMap
const
nsStylePosition
*
aStyle
)
;
uint32_t
FindAutoCol
(
uint32_t
aStartCol
uint32_t
aLockedRow
const
GridArea
*
aArea
)
const
;
void
PlaceAutoCol
(
uint32_t
aStartCol
GridArea
*
aArea
uint32_t
aClampMaxColLine
)
const
;
uint32_t
FindAutoRow
(
uint32_t
aLockedCol
uint32_t
aStartRow
const
GridArea
*
aArea
)
const
;
void
PlaceAutoRow
(
uint32_t
aStartRow
GridArea
*
aArea
uint32_t
aClampMaxRowLine
)
const
;
void
PlaceAutoAutoInRowOrder
(
uint32_t
aStartCol
uint32_t
aStartRow
GridArea
*
aArea
uint32_t
aClampMaxColLine
uint32_t
aClampMaxRowLine
)
const
;
void
PlaceAutoAutoInColOrder
(
uint32_t
aStartCol
uint32_t
aStartRow
GridArea
*
aArea
uint32_t
aClampMaxColLine
uint32_t
aClampMaxRowLine
)
const
;
static
int32_t
AutoIfOutside
(
int32_t
aLine
int32_t
aMin
int32_t
aMax
)
{
MOZ_ASSERT
(
aMin
<
=
aMax
)
;
if
(
aLine
<
aMin
|
|
aLine
>
aMax
)
{
return
kAutoLine
;
}
return
aLine
;
}
void
InflateGridFor
(
const
GridArea
&
aArea
)
{
mGridColEnd
=
std
:
:
max
(
mGridColEnd
aArea
.
mCols
.
HypotheticalEnd
(
)
)
;
mGridRowEnd
=
std
:
:
max
(
mGridRowEnd
aArea
.
mRows
.
HypotheticalEnd
(
)
)
;
MOZ_ASSERT
(
mGridColEnd
<
=
kTranslatedMaxLine
&
&
mGridRowEnd
<
=
kTranslatedMaxLine
)
;
}
int32_t
ResolveLine
(
const
StyleGridLine
&
aLine
int32_t
aNth
uint32_t
aFromIndex
const
LineNameMap
&
aNameMap
LogicalSide
aSide
uint32_t
aExplicitGridEnd
const
nsStylePosition
*
aStyle
)
;
typedef
std
:
:
pair
<
int32_t
int32_t
>
LinePair
;
LinePair
ResolveLineRangeHelper
(
const
StyleGridLine
&
aStart
const
StyleGridLine
&
aEnd
const
LineNameMap
&
aNameMap
LogicalAxis
aAxis
uint32_t
aExplicitGridEnd
const
nsStylePosition
*
aStyle
)
;
LineRange
ResolveLineRange
(
const
StyleGridLine
&
aStart
const
StyleGridLine
&
aEnd
const
LineNameMap
&
aNameMap
LogicalAxis
aAxis
uint32_t
aExplicitGridEnd
const
nsStylePosition
*
aStyle
)
;
GridArea
PlaceDefinite
(
nsIFrame
*
aChild
const
LineNameMap
&
aColLineNameMap
const
LineNameMap
&
aRowLineNameMap
const
nsStylePosition
*
aStyle
)
;
bool
HasImplicitNamedArea
(
nsAtom
*
aName
)
const
{
return
mAreas
&
&
mAreas
-
>
has
(
aName
)
;
}
static
bool
IsNameWithSuffix
(
nsAtom
*
aString
const
nsString
&
aSuffix
uint32_t
*
aIndex
)
{
if
(
StringEndsWith
(
nsDependentAtomString
(
aString
)
aSuffix
)
)
{
*
aIndex
=
aString
-
>
GetLength
(
)
-
aSuffix
.
Length
(
)
;
return
*
aIndex
!
=
0
;
}
return
false
;
}
static
bool
IsNameWithEndSuffix
(
nsAtom
*
aString
uint32_t
*
aIndex
)
{
return
IsNameWithSuffix
(
aString
NS_LITERAL_STRING
(
"
-
end
"
)
aIndex
)
;
}
static
bool
IsNameWithStartSuffix
(
nsAtom
*
aString
uint32_t
*
aIndex
)
{
return
IsNameWithSuffix
(
aString
NS_LITERAL_STRING
(
"
-
start
"
)
aIndex
)
;
}
const
LineNameMap
*
ParentLineMapForAxis
(
bool
aIsOrthogonal
LogicalAxis
aAxis
)
const
{
if
(
!
mParentGrid
)
{
return
nullptr
;
}
bool
isRows
=
aIsOrthogonal
=
=
(
aAxis
=
=
eLogicalAxisInline
)
;
return
isRows
?
mParentGrid
-
>
mRowNameMap
:
mParentGrid
-
>
mColNameMap
;
}
void
SetLineMaps
(
const
LineNameMap
*
aColNameMap
const
LineNameMap
*
aRowNameMap
)
{
mColNameMap
=
aColNameMap
;
mRowNameMap
=
aRowNameMap
;
}
struct
CellMap
{
struct
Cell
{
Cell
(
)
:
mIsOccupied
(
false
)
{
}
bool
mIsOccupied
:
1
;
}
;
void
Fill
(
const
GridArea
&
aGridArea
)
{
MOZ_ASSERT
(
aGridArea
.
IsDefinite
(
)
)
;
MOZ_ASSERT
(
aGridArea
.
mRows
.
mStart
<
aGridArea
.
mRows
.
mEnd
)
;
MOZ_ASSERT
(
aGridArea
.
mCols
.
mStart
<
aGridArea
.
mCols
.
mEnd
)
;
const
auto
numRows
=
aGridArea
.
mRows
.
mEnd
;
const
auto
numCols
=
aGridArea
.
mCols
.
mEnd
;
mCells
.
EnsureLengthAtLeast
(
numRows
)
;
for
(
auto
i
=
aGridArea
.
mRows
.
mStart
;
i
<
numRows
;
+
+
i
)
{
nsTArray
<
Cell
>
&
cellsInRow
=
mCells
[
i
]
;
cellsInRow
.
EnsureLengthAtLeast
(
numCols
)
;
for
(
auto
j
=
aGridArea
.
mCols
.
mStart
;
j
<
numCols
;
+
+
j
)
{
cellsInRow
[
j
]
.
mIsOccupied
=
true
;
}
}
}
uint32_t
IsEmptyCol
(
uint32_t
aCol
)
const
{
for
(
auto
&
row
:
mCells
)
{
if
(
aCol
<
row
.
Length
(
)
&
&
row
[
aCol
]
.
mIsOccupied
)
{
return
false
;
}
}
return
true
;
}
uint32_t
IsEmptyRow
(
uint32_t
aRow
)
const
{
if
(
aRow
>
=
mCells
.
Length
(
)
)
{
return
true
;
}
for
(
const
Cell
&
cell
:
mCells
[
aRow
]
)
{
if
(
cell
.
mIsOccupied
)
{
return
false
;
}
}
return
true
;
}
#
ifdef
DEBUG
void
Dump
(
)
const
{
const
size_t
numRows
=
mCells
.
Length
(
)
;
for
(
size_t
i
=
0
;
i
<
numRows
;
+
+
i
)
{
const
nsTArray
<
Cell
>
&
cellsInRow
=
mCells
[
i
]
;
const
size_t
numCols
=
cellsInRow
.
Length
(
)
;
printf
(
"
%
lu
:
\
t
"
(
unsigned
long
)
i
+
1
)
;
for
(
size_t
j
=
0
;
j
<
numCols
;
+
+
j
)
{
printf
(
cellsInRow
[
j
]
.
mIsOccupied
?
"
X
"
:
"
.
"
)
;
}
printf
(
"
\
n
"
)
;
}
}
#
endif
nsTArray
<
nsTArray
<
Cell
>
>
mCells
;
}
;
CellMap
mCellMap
;
ImplicitNamedAreas
*
mAreas
;
uint32_t
mExplicitGridColEnd
;
uint32_t
mExplicitGridRowEnd
;
uint32_t
mGridColEnd
;
uint32_t
mGridRowEnd
;
uint32_t
mExplicitGridOffsetCol
;
uint32_t
mExplicitGridOffsetRow
;
const
Grid
*
mParentGrid
;
const
LineNameMap
*
mColNameMap
;
const
LineNameMap
*
mRowNameMap
;
}
;
static
Subgrid
*
SubgridComputeMarginBorderPadding
(
const
GridItemInfo
&
aGridItem
const
LogicalSize
&
aPercentageBasis
)
{
auto
*
subgridFrame
=
aGridItem
.
SubgridFrame
(
)
;
auto
cbWM
=
aGridItem
.
mFrame
-
>
GetParent
(
)
-
>
GetWritingMode
(
)
;
nsMargin
physicalMBP
;
{
auto
wm
=
subgridFrame
-
>
GetWritingMode
(
)
;
auto
pmPercentageBasis
=
cbWM
.
IsOrthogonalTo
(
wm
)
?
aPercentageBasis
.
BSize
(
wm
)
:
aPercentageBasis
.
ISize
(
wm
)
;
SizeComputationInput
sz
(
subgridFrame
nullptr
cbWM
pmPercentageBasis
)
;
physicalMBP
=
sz
.
ComputedPhysicalMargin
(
)
+
sz
.
ComputedPhysicalBorderPadding
(
)
;
}
auto
*
subgrid
=
subgridFrame
-
>
GetProperty
(
Subgrid
:
:
Prop
(
)
)
;
subgrid
-
>
mMarginBorderPadding
=
LogicalMargin
(
cbWM
physicalMBP
)
;
if
(
aGridItem
.
mFrame
!
=
subgridFrame
)
{
nsIScrollableFrame
*
scrollFrame
=
aGridItem
.
mFrame
-
>
GetScrollTargetFrame
(
)
;
if
(
scrollFrame
)
{
nsMargin
ssz
=
scrollFrame
-
>
GetActualScrollbarSizes
(
)
;
subgrid
-
>
mMarginBorderPadding
+
=
LogicalMargin
(
cbWM
ssz
)
;
}
if
(
aGridItem
.
mFrame
-
>
IsFieldSetFrame
(
)
)
{
const
auto
*
f
=
static_cast
<
nsFieldSetFrame
*
>
(
aGridItem
.
mFrame
)
;
const
auto
*
inner
=
f
-
>
GetInner
(
)
;
auto
wm
=
inner
-
>
GetWritingMode
(
)
;
LogicalPoint
pos
=
inner
-
>
GetLogicalPosition
(
aGridItem
.
mFrame
-
>
GetSize
(
)
)
;
LogicalMargin
offsets
(
wm
pos
.
B
(
wm
)
0
0
0
)
;
subgrid
-
>
mMarginBorderPadding
+
=
offsets
.
ConvertTo
(
cbWM
wm
)
;
}
}
return
subgrid
;
}
static
void
CopyUsedTrackSizes
(
nsTArray
<
TrackSize
>
&
aResult
const
nsGridContainerFrame
*
aUsedTrackSizesFrame
const
UsedTrackSizes
*
aUsedTrackSizes
const
nsGridContainerFrame
*
aSubgridFrame
const
Subgrid
*
aSubgrid
LogicalAxis
aSubgridAxis
)
{
MOZ_ASSERT
(
aSubgridFrame
-
>
ParentGridContainerForSubgrid
(
)
=
=
aUsedTrackSizesFrame
)
;
aResult
.
SetLength
(
aSubgridAxis
=
=
eLogicalAxisInline
?
aSubgrid
-
>
mGridColEnd
:
aSubgrid
-
>
mGridRowEnd
)
;
auto
parentAxis
=
aSubgrid
-
>
mIsOrthogonal
?
GetOrthogonalAxis
(
aSubgridAxis
)
:
aSubgridAxis
;
const
auto
&
parentSizes
=
aUsedTrackSizes
-
>
mSizes
[
parentAxis
]
;
MOZ_ASSERT
(
aUsedTrackSizes
-
>
mCanResolveLineRangeSize
[
parentAxis
]
)
;
if
(
parentSizes
.
IsEmpty
(
)
)
{
return
;
}
const
auto
&
range
=
aSubgrid
-
>
mArea
.
LineRangeForAxis
(
parentAxis
)
;
const
auto
cbwm
=
aUsedTrackSizesFrame
-
>
GetWritingMode
(
)
;
const
auto
wm
=
aSubgridFrame
-
>
GetWritingMode
(
)
;
if
(
parentAxis
=
=
eLogicalAxisInline
)
{
const
nsIFrame
*
outerGridItemFrame
=
aSubgridFrame
;
for
(
nsIFrame
*
parent
=
aSubgridFrame
-
>
GetParent
(
)
;
parent
!
=
aUsedTrackSizesFrame
;
parent
=
parent
-
>
GetParent
(
)
)
{
MOZ_ASSERT
(
!
parent
-
>
IsGridContainerFrame
(
)
)
;
outerGridItemFrame
=
parent
;
}
auto
sizeInAxis
=
range
.
ToLength
(
aUsedTrackSizes
-
>
mSizes
[
parentAxis
]
)
;
LogicalSize
pmPercentageBasis
=
aSubgrid
-
>
mIsOrthogonal
?
LogicalSize
(
wm
nscoord
(
0
)
sizeInAxis
)
:
LogicalSize
(
wm
sizeInAxis
nscoord
(
0
)
)
;
GridItemInfo
info
(
const_cast
<
nsIFrame
*
>
(
outerGridItemFrame
)
aSubgrid
-
>
mArea
)
;
SubgridComputeMarginBorderPadding
(
info
pmPercentageBasis
)
;
}
const
LogicalMargin
&
mbp
=
aSubgrid
-
>
mMarginBorderPadding
;
if
(
MOZ_LIKELY
(
cbwm
.
ParallelAxisStartsOnSameSide
(
parentAxis
wm
)
)
)
{
uint32_t
i
=
range
.
mStart
;
nscoord
startMBP
=
mbp
.
Start
(
parentAxis
cbwm
)
;
nscoord
startPos
=
parentSizes
[
i
]
.
mPosition
+
startMBP
;
for
(
auto
&
sz
:
aResult
)
{
sz
=
parentSizes
[
i
+
+
]
;
sz
.
mPosition
-
=
startPos
;
}
aResult
[
0
]
.
mPosition
=
0
;
aResult
[
0
]
.
mBase
-
=
startMBP
;
aResult
.
LastElement
(
)
.
mBase
-
=
mbp
.
End
(
parentAxis
cbwm
)
;
}
else
{
const
uint32_t
first
=
range
.
mEnd
-
1
;
uint32_t
i
=
first
;
const
auto
&
parentEnd
=
parentSizes
[
first
]
;
nscoord
startMBP
=
mbp
.
End
(
parentAxis
cbwm
)
;
nscoord
parentEndPos
=
parentEnd
.
mPosition
+
parentEnd
.
mBase
-
startMBP
;
for
(
auto
&
sz
:
aResult
)
{
sz
=
parentSizes
[
i
-
-
]
;
sz
.
mPosition
=
parentEndPos
-
(
sz
.
mPosition
+
sz
.
mBase
)
;
}
aResult
[
0
]
.
mPosition
=
0
;
aResult
[
0
]
.
mBase
-
=
startMBP
;
aResult
.
LastElement
(
)
.
mBase
-
=
mbp
.
Start
(
parentAxis
cbwm
)
;
}
}
void
nsGridContainerFrame
:
:
UsedTrackSizes
:
:
ResolveTrackSizesForAxis
(
nsGridContainerFrame
*
aFrame
LogicalAxis
aAxis
gfxContext
&
aRC
)
{
if
(
mCanResolveLineRangeSize
[
aAxis
]
)
{
return
;
}
if
(
!
aFrame
-
>
IsSubgrid
(
)
)
{
return
;
}
auto
*
parent
=
aFrame
-
>
ParentGridContainerForSubgrid
(
)
;
auto
*
parentSizes
=
parent
-
>
GetUsedTrackSizes
(
)
;
if
(
!
parentSizes
)
{
parentSizes
=
new
UsedTrackSizes
(
)
;
parent
-
>
SetProperty
(
UsedTrackSizes
:
:
Prop
(
)
parentSizes
)
;
}
auto
*
subgrid
=
aFrame
-
>
GetProperty
(
Subgrid
:
:
Prop
(
)
)
;
const
auto
parentAxis
=
subgrid
-
>
mIsOrthogonal
?
GetOrthogonalAxis
(
aAxis
)
:
aAxis
;
parentSizes
-
>
ResolveTrackSizesForAxis
(
parent
parentAxis
aRC
)
;
if
(
!
parentSizes
-
>
mCanResolveLineRangeSize
[
parentAxis
]
)
{
if
(
aFrame
-
>
IsSubgrid
(
aAxis
)
)
{
ResolveSubgridTrackSizesForAxis
(
aFrame
aAxis
subgrid
aRC
NS_UNCONSTRAINEDSIZE
)
;
}
return
;
}
if
(
aFrame
-
>
IsSubgrid
(
aAxis
)
)
{
CopyUsedTrackSizes
(
mSizes
[
aAxis
]
parent
parentSizes
aFrame
subgrid
aAxis
)
;
mCanResolveLineRangeSize
[
aAxis
]
=
true
;
}
else
{
const
auto
&
range
=
subgrid
-
>
mArea
.
LineRangeForAxis
(
parentAxis
)
;
nscoord
contentBoxSize
=
range
.
ToLength
(
parentSizes
-
>
mSizes
[
parentAxis
]
)
;
auto
parentWM
=
aFrame
-
>
GetParent
(
)
-
>
GetWritingMode
(
)
;
contentBoxSize
-
=
subgrid
-
>
mMarginBorderPadding
.
StartEnd
(
parentAxis
parentWM
)
;
contentBoxSize
=
std
:
:
max
(
nscoord
(
0
)
contentBoxSize
)
;
ResolveSubgridTrackSizesForAxis
(
aFrame
aAxis
subgrid
aRC
contentBoxSize
)
;
}
}
void
nsGridContainerFrame
:
:
UsedTrackSizes
:
:
ResolveSubgridTrackSizesForAxis
(
nsGridContainerFrame
*
aFrame
LogicalAxis
aAxis
Subgrid
*
aSubgrid
gfxContext
&
aRC
nscoord
aContentBoxSize
)
{
GridReflowInput
state
(
aFrame
aRC
)
;
state
.
mGridItems
=
aSubgrid
-
>
mGridItems
;
Grid
grid
;
grid
.
mGridColEnd
=
aSubgrid
-
>
mGridColEnd
;
grid
.
mGridRowEnd
=
aSubgrid
-
>
mGridRowEnd
;
state
.
CalculateTrackSizesForAxis
(
aAxis
grid
aContentBoxSize
SizingConstraint
:
:
NoConstraint
)
;
const
auto
&
tracks
=
aAxis
=
=
eLogicalAxisInline
?
state
.
mCols
:
state
.
mRows
;
mSizes
[
aAxis
]
=
tracks
.
mSizes
;
mCanResolveLineRangeSize
[
aAxis
]
=
tracks
.
mCanResolveLineRangeSize
;
MOZ_ASSERT
(
mCanResolveLineRangeSize
[
aAxis
]
)
;
}
void
nsGridContainerFrame
:
:
GridReflowInput
:
:
CalculateTrackSizesForAxis
(
LogicalAxis
aAxis
const
Grid
&
aGrid
nscoord
aContentBoxSize
SizingConstraint
aConstraint
)
{
auto
&
tracks
=
aAxis
=
=
eLogicalAxisInline
?
mCols
:
mRows
;
const
auto
&
sizingFunctions
=
aAxis
=
=
eLogicalAxisInline
?
mColFunctions
:
mRowFunctions
;
const
auto
&
gapStyle
=
aAxis
=
=
eLogicalAxisInline
?
mGridStyle
-
>
mColumnGap
:
mGridStyle
-
>
mRowGap
;
uint32_t
gridEnd
=
aAxis
=
=
eLogicalAxisInline
?
aGrid
.
mGridColEnd
:
aGrid
.
mGridRowEnd
;
Maybe
<
SubgridFallbackTrackSizingFunctions
>
fallbackTrackSizing
;
bool
useParentGaps
=
false
;
const
bool
isSubgriddedAxis
=
mFrame
-
>
IsSubgrid
(
aAxis
)
;
if
(
MOZ_LIKELY
(
!
isSubgriddedAxis
)
)
{
tracks
.
Initialize
(
sizingFunctions
gapStyle
gridEnd
aContentBoxSize
)
;
}
else
{
tracks
.
mGridGap
=
nsLayoutUtils
:
:
ResolveGapToLength
(
gapStyle
aContentBoxSize
)
;
tracks
.
mContentBoxSize
=
aContentBoxSize
;
const
auto
*
subgrid
=
mFrame
-
>
GetProperty
(
Subgrid
:
:
Prop
(
)
)
;
tracks
.
mSizes
.
SetLength
(
gridEnd
)
;
auto
*
parent
=
mFrame
-
>
ParentGridContainerForSubgrid
(
)
;
auto
parentAxis
=
subgrid
-
>
mIsOrthogonal
?
GetOrthogonalAxis
(
aAxis
)
:
aAxis
;
const
auto
*
parentSizes
=
parent
-
>
GetUsedTrackSizes
(
)
;
if
(
parentSizes
&
&
parentSizes
-
>
mCanResolveLineRangeSize
[
parentAxis
]
)
{
CopyUsedTrackSizes
(
tracks
.
mSizes
parent
parentSizes
mFrame
subgrid
aAxis
)
;
useParentGaps
=
gapStyle
.
IsNormal
(
)
;
}
else
{
fallbackTrackSizing
.
emplace
(
mFrame
subgrid
parent
parentAxis
)
;
tracks
.
Initialize
(
TrackSizingFunctions
(
fallbackTrackSizing
-
>
mMinSizingFunctions
fallbackTrackSizing
-
>
mMaxSizingFunctions
*
fallbackTrackSizing
-
>
mAutoMinSizing
*
fallbackTrackSizing
-
>
mAutoMaxSizing
fallbackTrackSizing
-
>
mHasRepeatAuto
fallbackTrackSizing
-
>
mRepeatAutoIndex
)
gapStyle
gridEnd
aContentBoxSize
)
;
}
}
if
(
MOZ_LIKELY
(
!
isSubgriddedAxis
)
|
|
fallbackTrackSizing
.
isSome
(
)
)
{
const
size_t
origGridItemCount
=
mGridItems
.
Length
(
)
;
if
(
mFrame
-
>
HasSubgridItems
(
aAxis
)
)
{
CollectSubgridItemsForAxis
(
aAxis
mGridItems
)
;
}
tracks
.
CalculateSizes
(
*
this
mGridItems
fallbackTrackSizing
.
isSome
(
)
?
TrackSizingFunctions
(
fallbackTrackSizing
-
>
mMinSizingFunctions
fallbackTrackSizing
-
>
mMaxSizingFunctions
*
fallbackTrackSizing
-
>
mAutoMinSizing
*
fallbackTrackSizing
-
>
mAutoMaxSizing
fallbackTrackSizing
-
>
mHasRepeatAuto
fallbackTrackSizing
-
>
mRepeatAutoIndex
)
:
sizingFunctions
aContentBoxSize
aAxis
=
=
eLogicalAxisInline
?
&
GridArea
:
:
mCols
:
&
GridArea
:
:
mRows
aConstraint
)
;
mGridItems
.
TruncateLength
(
origGridItemCount
)
;
}
if
(
aContentBoxSize
!
=
NS_UNCONSTRAINEDSIZE
)
{
tracks
.
AlignJustifyContent
(
mGridStyle
mWM
aContentBoxSize
isSubgriddedAxis
)
;
}
else
if
(
!
useParentGaps
)
{
const
nscoord
gridGap
=
tracks
.
mGridGap
;
nscoord
pos
=
0
;
for
(
TrackSize
&
sz
:
tracks
.
mSizes
)
{
sz
.
mPosition
=
pos
;
pos
+
=
sz
.
mBase
+
gridGap
;
}
}
if
(
aConstraint
=
=
SizingConstraint
:
:
NoConstraint
&
&
(
mFrame
-
>
HasSubgridItems
(
)
|
|
mFrame
-
>
IsSubgrid
(
)
)
)
{
mFrame
-
>
StoreUsedTrackSizes
(
aAxis
tracks
.
mSizes
)
;
}
tracks
.
mCanResolveLineRangeSize
=
true
;
}
void
nsGridContainerFrame
:
:
GridReflowInput
:
:
CalculateTrackSizes
(
const
Grid
&
aGrid
const
LogicalSize
&
aContentBox
SizingConstraint
aConstraint
)
{
CalculateTrackSizesForAxis
(
eLogicalAxisInline
aGrid
aContentBox
.
ISize
(
mWM
)
aConstraint
)
;
CalculateTrackSizesForAxis
(
eLogicalAxisBlock
aGrid
aContentBox
.
BSize
(
mWM
)
aConstraint
)
;
}
static
uint32_t
GetDisplayFlagsForGridItem
(
nsIFrame
*
aFrame
)
{
const
nsStylePosition
*
pos
=
aFrame
-
>
StylePosition
(
)
;
if
(
pos
-
>
mZIndex
.
IsInteger
(
)
)
{
return
nsIFrame
:
:
DISPLAY_CHILD_FORCE_STACKING_CONTEXT
;
}
return
nsIFrame
:
:
DISPLAY_CHILD_FORCE_PSEUDO_STACKING_CONTEXT
;
}
static
void
AlignJustifySelf
(
uint8_t
aAlignment
LogicalAxis
aAxis
AlignJustifyFlags
aFlags
nscoord
aBaselineAdjust
nscoord
aCBSize
const
ReflowInput
&
aRI
const
LogicalSize
&
aChildSize
LogicalPoint
*
aPos
)
{
MOZ_ASSERT
(
aAlignment
!
=
NS_STYLE_ALIGN_AUTO
"
unexpected
'
auto
'
"
"
computed
value
for
normal
flow
grid
item
"
)
;
nscoord
offset
=
CSSAlignUtils
:
:
AlignJustifySelf
(
aAlignment
aAxis
aFlags
aBaselineAdjust
aCBSize
aRI
aChildSize
)
;
if
(
offset
!
=
0
)
{
WritingMode
wm
=
aRI
.
GetWritingMode
(
)
;
nscoord
&
pos
=
aAxis
=
=
eLogicalAxisBlock
?
aPos
-
>
B
(
wm
)
:
aPos
-
>
I
(
wm
)
;
pos
+
=
MOZ_LIKELY
(
aFlags
&
AlignJustifyFlags
:
:
SameSide
)
?
offset
:
-
offset
;
}
}
static
void
AlignSelf
(
const
nsGridContainerFrame
:
:
GridItemInfo
&
aGridItem
uint8_t
aAlignSelf
nscoord
aCBSize
const
WritingMode
aCBWM
const
ReflowInput
&
aRI
const
LogicalSize
&
aSize
LogicalPoint
*
aPos
)
{
auto
alignSelf
=
aAlignSelf
;
AlignJustifyFlags
flags
=
AlignJustifyFlags
:
:
NoFlags
;
if
(
alignSelf
&
NS_STYLE_ALIGN_SAFE
)
{
flags
|
=
AlignJustifyFlags
:
:
OverflowSafe
;
}
alignSelf
&
=
~
NS_STYLE_ALIGN_FLAG_BITS
;
WritingMode
childWM
=
aRI
.
GetWritingMode
(
)
;
if
(
aCBWM
.
ParallelAxisStartsOnSameSide
(
eLogicalAxisBlock
childWM
)
)
{
flags
|
=
AlignJustifyFlags
:
:
SameSide
;
}
if
(
alignSelf
=
=
NS_STYLE_ALIGN_LEFT
|
|
alignSelf
=
=
NS_STYLE_ALIGN_RIGHT
)
{
alignSelf
=
NS_STYLE_ALIGN_START
;
}
if
(
MOZ_LIKELY
(
alignSelf
=
=
NS_STYLE_ALIGN_NORMAL
)
)
{
alignSelf
=
NS_STYLE_ALIGN_STRETCH
;
}
nscoord
baselineAdjust
=
0
;
if
(
alignSelf
=
=
NS_STYLE_ALIGN_BASELINE
|
|
alignSelf
=
=
NS_STYLE_ALIGN_LAST_BASELINE
)
{
alignSelf
=
aGridItem
.
GetSelfBaseline
(
alignSelf
eLogicalAxisBlock
&
baselineAdjust
)
;
}
bool
isOrthogonal
=
aCBWM
.
IsOrthogonalTo
(
childWM
)
;
LogicalAxis
axis
=
isOrthogonal
?
eLogicalAxisInline
:
eLogicalAxisBlock
;
AlignJustifySelf
(
alignSelf
axis
flags
baselineAdjust
aCBSize
aRI
aSize
aPos
)
;
}
static
void
JustifySelf
(
const
nsGridContainerFrame
:
:
GridItemInfo
&
aGridItem
uint8_t
aJustifySelf
nscoord
aCBSize
const
WritingMode
aCBWM
const
ReflowInput
&
aRI
const
LogicalSize
&
aSize
LogicalPoint
*
aPos
)
{
auto
justifySelf
=
aJustifySelf
;
AlignJustifyFlags
flags
=
AlignJustifyFlags
:
:
NoFlags
;
if
(
justifySelf
&
NS_STYLE_JUSTIFY_SAFE
)
{
flags
|
=
AlignJustifyFlags
:
:
OverflowSafe
;
}
justifySelf
&
=
~
NS_STYLE_JUSTIFY_FLAG_BITS
;
WritingMode
childWM
=
aRI
.
GetWritingMode
(
)
;
if
(
aCBWM
.
ParallelAxisStartsOnSameSide
(
eLogicalAxisInline
childWM
)
)
{
flags
|
=
AlignJustifyFlags
:
:
SameSide
;
}
if
(
MOZ_LIKELY
(
justifySelf
=
=
NS_STYLE_ALIGN_NORMAL
)
)
{
justifySelf
=
NS_STYLE_ALIGN_STRETCH
;
}
nscoord
baselineAdjust
=
0
;
switch
(
justifySelf
)
{
case
NS_STYLE_JUSTIFY_LEFT
:
justifySelf
=
aCBWM
.
IsBidiLTR
(
)
?
NS_STYLE_JUSTIFY_START
:
NS_STYLE_JUSTIFY_END
;
break
;
case
NS_STYLE_JUSTIFY_RIGHT
:
justifySelf
=
aCBWM
.
IsBidiLTR
(
)
?
NS_STYLE_JUSTIFY_END
:
NS_STYLE_JUSTIFY_START
;
break
;
case
NS_STYLE_JUSTIFY_BASELINE
:
case
NS_STYLE_JUSTIFY_LAST_BASELINE
:
justifySelf
=
aGridItem
.
GetSelfBaseline
(
justifySelf
eLogicalAxisInline
&
baselineAdjust
)
;
break
;
}
bool
isOrthogonal
=
aCBWM
.
IsOrthogonalTo
(
childWM
)
;
LogicalAxis
axis
=
isOrthogonal
?
eLogicalAxisBlock
:
eLogicalAxisInline
;
AlignJustifySelf
(
justifySelf
axis
flags
baselineAdjust
aCBSize
aRI
aSize
aPos
)
;
}
static
uint16_t
GetAlignJustifyValue
(
uint16_t
aAlignment
const
WritingMode
aWM
const
bool
aIsAlign
bool
*
aOverflowSafe
)
{
*
aOverflowSafe
=
aAlignment
&
NS_STYLE_ALIGN_SAFE
;
aAlignment
&
=
(
NS_STYLE_ALIGN_ALL_BITS
&
~
NS_STYLE_ALIGN_FLAG_BITS
)
;
switch
(
aAlignment
)
{
case
NS_STYLE_ALIGN_LEFT
:
case
NS_STYLE_ALIGN_RIGHT
:
{
if
(
aIsAlign
)
{
return
NS_STYLE_ALIGN_START
;
}
bool
isStart
=
aWM
.
IsBidiLTR
(
)
=
=
(
aAlignment
=
=
NS_STYLE_ALIGN_LEFT
)
;
return
isStart
?
NS_STYLE_ALIGN_START
:
NS_STYLE_ALIGN_END
;
}
case
NS_STYLE_ALIGN_FLEX_START
:
return
NS_STYLE_ALIGN_START
;
case
NS_STYLE_ALIGN_FLEX_END
:
return
NS_STYLE_ALIGN_END
;
}
return
aAlignment
;
}
static
uint16_t
GetAlignJustifyFallbackIfAny
(
uint16_t
aAlignment
const
WritingMode
aWM
const
bool
aIsAlign
bool
*
aOverflowSafe
)
{
uint16_t
fallback
=
aAlignment
>
>
NS_STYLE_ALIGN_ALL_SHIFT
;
if
(
fallback
)
{
return
GetAlignJustifyValue
(
fallback
aWM
aIsAlign
aOverflowSafe
)
;
}
switch
(
aAlignment
)
{
case
NS_STYLE_ALIGN_STRETCH
:
case
NS_STYLE_ALIGN_SPACE_BETWEEN
:
return
NS_STYLE_ALIGN_START
;
case
NS_STYLE_ALIGN_SPACE_AROUND
:
case
NS_STYLE_ALIGN_SPACE_EVENLY
:
return
NS_STYLE_ALIGN_CENTER
;
}
return
0
;
}
NS_QUERYFRAME_HEAD
(
nsGridContainerFrame
)
NS_QUERYFRAME_ENTRY
(
nsGridContainerFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsContainerFrame
)
NS_IMPL_FRAMEARENA_HELPERS
(
nsGridContainerFrame
)
nsContainerFrame
*
NS_NewGridContainerFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsGridContainerFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
const
nsRect
&
nsGridContainerFrame
:
:
GridItemCB
(
nsIFrame
*
aChild
)
{
MOZ_ASSERT
(
(
aChild
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
&
&
aChild
-
>
IsAbsolutelyPositioned
(
)
)
;
nsRect
*
cb
=
aChild
-
>
GetProperty
(
GridItemContainingBlockRect
(
)
)
;
MOZ_ASSERT
(
cb
"
this
method
must
only
be
called
on
grid
items
and
the
grid
"
"
container
should
'
ve
reflowed
this
item
by
now
and
set
up
cb
"
)
;
return
*
cb
;
}
void
nsGridContainerFrame
:
:
AddImplicitNamedAreas
(
const
nsTArray
<
nsTArray
<
RefPtr
<
nsAtom
>
>
>
&
aLineNameLists
)
{
const
uint32_t
len
=
std
:
:
min
(
aLineNameLists
.
Length
(
)
size_t
(
kMaxLine
)
)
;
nsTHashtable
<
nsStringHashKey
>
currentStarts
;
ImplicitNamedAreas
*
areas
=
GetImplicitNamedAreas
(
)
;
for
(
uint32_t
i
=
0
;
i
<
len
;
+
+
i
)
{
for
(
nsAtom
*
name
:
aLineNameLists
[
i
]
)
{
uint32_t
indexOfSuffix
;
if
(
Grid
:
:
IsNameWithStartSuffix
(
name
&
indexOfSuffix
)
|
|
Grid
:
:
IsNameWithEndSuffix
(
name
&
indexOfSuffix
)
)
{
nsDependentSubstring
areaName
(
nsDependentAtomString
(
name
)
0
indexOfSuffix
)
;
if
(
!
areas
)
{
areas
=
new
ImplicitNamedAreas
;
SetProperty
(
ImplicitNamedAreasProperty
(
)
areas
)
;
}
RefPtr
<
nsAtom
>
name
=
NS_Atomize
(
areaName
)
;
auto
addPtr
=
areas
-
>
lookupForAdd
(
name
)
;
if
(
!
addPtr
)
{
if
(
!
areas
-
>
add
(
addPtr
name
NamedArea
{
StyleAtom
(
do_AddRef
(
name
)
)
{
0
0
}
{
0
0
}
}
)
)
{
MOZ_CRASH
(
"
OOM
while
adding
grid
name
lists
"
)
;
}
}
}
}
}
}
void
nsGridContainerFrame
:
:
InitImplicitNamedAreas
(
const
nsStylePosition
*
aStyle
)
{
ImplicitNamedAreas
*
areas
=
GetImplicitNamedAreas
(
)
;
if
(
areas
)
{
areas
-
>
clear
(
)
;
}
AddImplicitNamedAreas
(
aStyle
-
>
GridTemplateColumns
(
)
.
mLineNameLists
)
;
AddImplicitNamedAreas
(
aStyle
-
>
GridTemplateRows
(
)
.
mLineNameLists
)
;
if
(
areas
&
&
areas
-
>
count
(
)
=
=
0
)
{
DeleteProperty
(
ImplicitNamedAreasProperty
(
)
)
;
}
}
int32_t
nsGridContainerFrame
:
:
Grid
:
:
ResolveLine
(
const
StyleGridLine
&
aLine
int32_t
aNth
uint32_t
aFromIndex
const
LineNameMap
&
aNameMap
LogicalSide
aSide
uint32_t
aExplicitGridEnd
const
nsStylePosition
*
aStyle
)
{
MOZ_ASSERT
(
!
aLine
.
IsAuto
(
)
)
;
int32_t
line
=
0
;
if
(
aLine
.
LineName
(
)
-
>
IsEmpty
(
)
)
{
MOZ_ASSERT
(
aNth
!
=
0
"
css
-
grid
9
.
2
:
<
integer
>
must
not
be
zero
.
"
)
;
line
=
int32_t
(
aFromIndex
)
+
aNth
;
}
else
{
if
(
aNth
=
=
0
)
{
aNth
=
1
;
}
bool
isNameOnly
=
!
aLine
.
is_span
&
&
aLine
.
line_num
=
=
0
;
if
(
isNameOnly
)
{
AutoTArray
<
uint32_t
16
>
implicitLines
;
aNameMap
.
FindNamedAreas
(
aLine
.
ident
.
AsAtom
(
)
aSide
implicitLines
)
;
if
(
!
implicitLines
.
IsEmpty
(
)
|
|
aNameMap
.
HasImplicitNamedArea
(
aLine
.
LineName
(
)
)
)
{
nsAutoString
lineName
(
nsDependentAtomString
(
aLine
.
LineName
(
)
)
)
;
if
(
IsStart
(
aSide
)
)
{
lineName
.
AppendLiteral
(
"
-
start
"
)
;
}
else
{
lineName
.
AppendLiteral
(
"
-
end
"
)
;
}
RefPtr
<
nsAtom
>
name
=
NS_Atomize
(
lineName
)
;
line
=
aNameMap
.
FindNamedLine
(
name
&
aNth
aFromIndex
implicitLines
)
;
}
}
if
(
line
=
=
0
)
{
AutoTArray
<
uint32_t
16
>
implicitLines
;
uint32_t
index
;
bool
useStart
=
IsNameWithStartSuffix
(
aLine
.
LineName
(
)
&
index
)
;
if
(
useStart
|
|
IsNameWithEndSuffix
(
aLine
.
LineName
(
)
&
index
)
)
{
auto
side
=
MakeLogicalSide
(
GetAxis
(
aSide
)
useStart
?
eLogicalEdgeStart
:
eLogicalEdgeEnd
)
;
RefPtr
<
nsAtom
>
name
=
NS_Atomize
(
nsDependentSubstring
(
nsDependentAtomString
(
aLine
.
LineName
(
)
)
0
index
)
)
;
aNameMap
.
FindNamedAreas
(
name
side
implicitLines
)
;
}
line
=
aNameMap
.
FindNamedLine
(
aLine
.
LineName
(
)
&
aNth
aFromIndex
implicitLines
)
;
}
if
(
line
=
=
0
)
{
MOZ_ASSERT
(
aNth
!
=
0
"
we
found
all
N
named
lines
but
'
line
'
is
zero
!
"
)
;
int32_t
edgeLine
;
if
(
aLine
.
is_span
)
{
edgeLine
=
IsStart
(
aSide
)
?
1
:
aExplicitGridEnd
;
}
else
{
edgeLine
=
aNth
<
0
?
1
:
aExplicitGridEnd
;
}
line
=
edgeLine
+
aNth
;
}
}
return
clamped
(
line
aNameMap
.
mClampMinLine
aNameMap
.
mClampMaxLine
)
;
}
nsGridContainerFrame
:
:
Grid
:
:
LinePair
nsGridContainerFrame
:
:
Grid
:
:
ResolveLineRangeHelper
(
const
StyleGridLine
&
aStart
const
StyleGridLine
&
aEnd
const
LineNameMap
&
aNameMap
LogicalAxis
aAxis
uint32_t
aExplicitGridEnd
const
nsStylePosition
*
aStyle
)
{
MOZ_ASSERT
(
int32_t
(
kAutoLine
)
>
kMaxLine
)
;
if
(
aStart
.
is_span
)
{
if
(
aEnd
.
is_span
|
|
aEnd
.
IsAuto
(
)
)
{
if
(
aStart
.
LineName
(
)
-
>
IsEmpty
(
)
)
{
return
LinePair
(
kAutoLine
aStart
.
line_num
)
;
}
return
LinePair
(
kAutoLine
1
)
;
}
uint32_t
from
=
aEnd
.
line_num
<
0
?
aExplicitGridEnd
+
1
:
0
;
auto
end
=
ResolveLine
(
aEnd
aEnd
.
line_num
from
aNameMap
MakeLogicalSide
(
aAxis
eLogicalEdgeEnd
)
aExplicitGridEnd
aStyle
)
;
int32_t
span
=
aStart
.
line_num
=
=
0
?
1
:
aStart
.
line_num
;
if
(
end
<
=
1
)
{
int32_t
start
=
std
:
:
max
(
end
-
span
aNameMap
.
mClampMinLine
)
;
return
LinePair
(
start
end
)
;
}
auto
start
=
ResolveLine
(
aStart
-
span
end
aNameMap
MakeLogicalSide
(
aAxis
eLogicalEdgeStart
)
aExplicitGridEnd
aStyle
)
;
return
LinePair
(
start
end
)
;
}
int32_t
start
=
kAutoLine
;
if
(
aStart
.
IsAuto
(
)
)
{
if
(
aEnd
.
IsAuto
(
)
)
{
return
LinePair
(
start
1
)
;
}
if
(
aEnd
.
is_span
)
{
if
(
aEnd
.
LineName
(
)
-
>
IsEmpty
(
)
)
{
MOZ_ASSERT
(
aEnd
.
line_num
!
=
0
)
;
return
LinePair
(
start
aEnd
.
line_num
)
;
}
return
LinePair
(
start
1
)
;
}
}
else
{
uint32_t
from
=
aStart
.
line_num
<
0
?
aExplicitGridEnd
+
1
:
0
;
start
=
ResolveLine
(
aStart
aStart
.
line_num
from
aNameMap
MakeLogicalSide
(
aAxis
eLogicalEdgeStart
)
aExplicitGridEnd
aStyle
)
;
if
(
aEnd
.
IsAuto
(
)
)
{
return
LinePair
(
start
start
)
;
}
}
uint32_t
from
;
int32_t
nth
=
aEnd
.
line_num
=
=
0
?
1
:
aEnd
.
line_num
;
if
(
aEnd
.
is_span
)
{
if
(
MOZ_UNLIKELY
(
start
<
0
)
)
{
if
(
aEnd
.
LineName
(
)
-
>
IsEmpty
(
)
)
{
return
LinePair
(
start
start
+
nth
)
;
}
from
=
0
;
}
else
{
if
(
start
>
=
int32_t
(
aExplicitGridEnd
)
)
{
return
LinePair
(
start
std
:
:
min
(
start
+
nth
aNameMap
.
mClampMaxLine
)
)
;
}
from
=
start
;
}
}
else
{
from
=
aEnd
.
line_num
<
0
?
aExplicitGridEnd
+
1
:
0
;
}
auto
end
=
ResolveLine
(
aEnd
nth
from
aNameMap
MakeLogicalSide
(
aAxis
eLogicalEdgeEnd
)
aExplicitGridEnd
aStyle
)
;
if
(
start
=
=
int32_t
(
kAutoLine
)
)
{
start
=
std
:
:
max
(
aNameMap
.
mClampMinLine
end
-
1
)
;
}
return
LinePair
(
start
end
)
;
}
nsGridContainerFrame
:
:
LineRange
nsGridContainerFrame
:
:
Grid
:
:
ResolveLineRange
(
const
StyleGridLine
&
aStart
const
StyleGridLine
&
aEnd
const
LineNameMap
&
aNameMap
LogicalAxis
aAxis
uint32_t
aExplicitGridEnd
const
nsStylePosition
*
aStyle
)
{
LinePair
r
=
ResolveLineRangeHelper
(
aStart
aEnd
aNameMap
aAxis
aExplicitGridEnd
aStyle
)
;
MOZ_ASSERT
(
r
.
second
!
=
int32_t
(
kAutoLine
)
)
;
if
(
r
.
first
=
=
int32_t
(
kAutoLine
)
)
{
r
.
second
=
std
:
:
min
(
r
.
second
aNameMap
.
mClampMaxLine
-
1
)
;
}
else
{
if
(
r
.
first
>
r
.
second
)
{
Swap
(
r
.
first
r
.
second
)
;
}
else
if
(
r
.
first
=
=
r
.
second
)
{
if
(
MOZ_UNLIKELY
(
r
.
first
=
=
aNameMap
.
mClampMaxLine
)
)
{
r
.
first
=
aNameMap
.
mClampMaxLine
-
1
;
}
r
.
second
=
r
.
first
+
1
;
}
}
return
LineRange
(
r
.
first
r
.
second
)
;
}
nsGridContainerFrame
:
:
GridArea
nsGridContainerFrame
:
:
Grid
:
:
PlaceDefinite
(
nsIFrame
*
aChild
const
LineNameMap
&
aColLineNameMap
const
LineNameMap
&
aRowLineNameMap
const
nsStylePosition
*
aStyle
)
{
const
nsStylePosition
*
itemStyle
=
aChild
-
>
StylePosition
(
)
;
return
GridArea
(
ResolveLineRange
(
itemStyle
-
>
mGridColumnStart
itemStyle
-
>
mGridColumnEnd
aColLineNameMap
eLogicalAxisInline
mExplicitGridColEnd
aStyle
)
ResolveLineRange
(
itemStyle
-
>
mGridRowStart
itemStyle
-
>
mGridRowEnd
aRowLineNameMap
eLogicalAxisBlock
mExplicitGridRowEnd
aStyle
)
)
;
}
nsGridContainerFrame
:
:
LineRange
nsGridContainerFrame
:
:
Grid
:
:
ResolveAbsPosLineRange
(
const
StyleGridLine
&
aStart
const
StyleGridLine
&
aEnd
const
LineNameMap
&
aNameMap
LogicalAxis
aAxis
uint32_t
aExplicitGridEnd
int32_t
aGridStart
int32_t
aGridEnd
const
nsStylePosition
*
aStyle
)
{
if
(
aStart
.
IsAuto
(
)
)
{
if
(
aEnd
.
IsAuto
(
)
)
{
return
LineRange
(
kAutoLine
kAutoLine
)
;
}
uint32_t
from
=
aEnd
.
line_num
<
0
?
aExplicitGridEnd
+
1
:
0
;
int32_t
end
=
ResolveLine
(
aEnd
aEnd
.
line_num
from
aNameMap
MakeLogicalSide
(
aAxis
eLogicalEdgeEnd
)
aExplicitGridEnd
aStyle
)
;
if
(
aEnd
.
is_span
)
{
+
+
end
;
}
end
=
AutoIfOutside
(
end
aGridStart
aGridEnd
)
;
return
LineRange
(
kAutoLine
end
)
;
}
if
(
aEnd
.
IsAuto
(
)
)
{
uint32_t
from
=
aStart
.
line_num
<
0
?
aExplicitGridEnd
+
1
:
0
;
int32_t
start
=
ResolveLine
(
aStart
aStart
.
line_num
from
aNameMap
MakeLogicalSide
(
aAxis
eLogicalEdgeStart
)
aExplicitGridEnd
aStyle
)
;
if
(
aStart
.
is_span
)
{
start
=
std
:
:
max
(
aGridEnd
-
start
aGridStart
)
;
}
start
=
AutoIfOutside
(
start
aGridStart
aGridEnd
)
;
return
LineRange
(
start
kAutoLine
)
;
}
LineRange
r
=
ResolveLineRange
(
aStart
aEnd
aNameMap
aAxis
aExplicitGridEnd
aStyle
)
;
if
(
r
.
IsAuto
(
)
)
{
MOZ_ASSERT
(
aStart
.
is_span
&
&
aEnd
.
is_span
"
span
/
span
is
the
only
case
"
"
leading
to
IsAuto
here
-
-
we
dealt
with
the
other
cases
above
"
)
;
return
LineRange
(
kAutoLine
kAutoLine
)
;
}
return
LineRange
(
AutoIfOutside
(
r
.
mUntranslatedStart
aGridStart
aGridEnd
)
AutoIfOutside
(
r
.
mUntranslatedEnd
aGridStart
aGridEnd
)
)
;
}
nsGridContainerFrame
:
:
GridArea
nsGridContainerFrame
:
:
Grid
:
:
PlaceAbsPos
(
nsIFrame
*
aChild
const
LineNameMap
&
aColLineNameMap
const
LineNameMap
&
aRowLineNameMap
const
nsStylePosition
*
aStyle
)
{
const
nsStylePosition
*
itemStyle
=
aChild
-
>
StylePosition
(
)
;
int32_t
gridColStart
=
1
-
mExplicitGridOffsetCol
;
int32_t
gridRowStart
=
1
-
mExplicitGridOffsetRow
;
return
GridArea
(
ResolveAbsPosLineRange
(
itemStyle
-
>
mGridColumnStart
itemStyle
-
>
mGridColumnEnd
aColLineNameMap
eLogicalAxisInline
mExplicitGridColEnd
gridColStart
mGridColEnd
aStyle
)
ResolveAbsPosLineRange
(
itemStyle
-
>
mGridRowStart
itemStyle
-
>
mGridRowEnd
aRowLineNameMap
eLogicalAxisBlock
mExplicitGridRowEnd
gridRowStart
mGridRowEnd
aStyle
)
)
;
}
uint32_t
nsGridContainerFrame
:
:
Grid
:
:
FindAutoCol
(
uint32_t
aStartCol
uint32_t
aLockedRow
const
GridArea
*
aArea
)
const
{
const
uint32_t
extent
=
aArea
-
>
mCols
.
Extent
(
)
;
const
uint32_t
iStart
=
aLockedRow
;
const
uint32_t
iEnd
=
iStart
+
aArea
-
>
mRows
.
Extent
(
)
;
uint32_t
candidate
=
aStartCol
;
for
(
uint32_t
i
=
iStart
;
i
<
iEnd
;
)
{
if
(
i
>
=
mCellMap
.
mCells
.
Length
(
)
)
{
break
;
}
const
nsTArray
<
CellMap
:
:
Cell
>
&
cellsInRow
=
mCellMap
.
mCells
[
i
]
;
const
uint32_t
len
=
cellsInRow
.
Length
(
)
;
const
uint32_t
lastCandidate
=
candidate
;
for
(
uint32_t
j
=
candidate
gap
=
0
;
j
<
len
&
&
gap
<
extent
;
+
+
j
)
{
if
(
!
cellsInRow
[
j
]
.
mIsOccupied
)
{
+
+
gap
;
continue
;
}
candidate
=
j
+
1
;
gap
=
0
;
}
if
(
lastCandidate
<
candidate
&
&
i
!
=
iStart
)
{
i
=
iStart
;
}
else
{
+
+
i
;
}
}
return
candidate
;
}
void
nsGridContainerFrame
:
:
Grid
:
:
PlaceAutoCol
(
uint32_t
aStartCol
GridArea
*
aArea
uint32_t
aClampMaxColLine
)
const
{
MOZ_ASSERT
(
aArea
-
>
mRows
.
IsDefinite
(
)
&
&
aArea
-
>
mCols
.
IsAuto
(
)
)
;
uint32_t
col
=
FindAutoCol
(
aStartCol
aArea
-
>
mRows
.
mStart
aArea
)
;
aArea
-
>
mCols
.
ResolveAutoPosition
(
col
aClampMaxColLine
)
;
MOZ_ASSERT
(
aArea
-
>
IsDefinite
(
)
)
;
}
uint32_t
nsGridContainerFrame
:
:
Grid
:
:
FindAutoRow
(
uint32_t
aLockedCol
uint32_t
aStartRow
const
GridArea
*
aArea
)
const
{
const
uint32_t
extent
=
aArea
-
>
mRows
.
Extent
(
)
;
const
uint32_t
jStart
=
aLockedCol
;
const
uint32_t
jEnd
=
jStart
+
aArea
-
>
mCols
.
Extent
(
)
;
const
uint32_t
iEnd
=
mCellMap
.
mCells
.
Length
(
)
;
uint32_t
candidate
=
aStartRow
;
for
(
uint32_t
i
=
candidate
gap
=
0
;
i
<
iEnd
&
&
gap
<
extent
;
+
+
i
)
{
+
+
gap
;
const
nsTArray
<
CellMap
:
:
Cell
>
&
cellsInRow
=
mCellMap
.
mCells
[
i
]
;
const
uint32_t
clampedJEnd
=
std
:
:
min
<
uint32_t
>
(
jEnd
cellsInRow
.
Length
(
)
)
;
for
(
uint32_t
j
=
jStart
;
j
<
clampedJEnd
;
+
+
j
)
{
if
(
cellsInRow
[
j
]
.
mIsOccupied
)
{
candidate
=
i
+
1
;
gap
=
0
;
break
;
}
}
}
return
candidate
;
}
void
nsGridContainerFrame
:
:
Grid
:
:
PlaceAutoRow
(
uint32_t
aStartRow
GridArea
*
aArea
uint32_t
aClampMaxRowLine
)
const
{
MOZ_ASSERT
(
aArea
-
>
mCols
.
IsDefinite
(
)
&
&
aArea
-
>
mRows
.
IsAuto
(
)
)
;
uint32_t
row
=
FindAutoRow
(
aArea
-
>
mCols
.
mStart
aStartRow
aArea
)
;
aArea
-
>
mRows
.
ResolveAutoPosition
(
row
aClampMaxRowLine
)
;
MOZ_ASSERT
(
aArea
-
>
IsDefinite
(
)
)
;
}
void
nsGridContainerFrame
:
:
Grid
:
:
PlaceAutoAutoInRowOrder
(
uint32_t
aStartCol
uint32_t
aStartRow
GridArea
*
aArea
uint32_t
aClampMaxColLine
uint32_t
aClampMaxRowLine
)
const
{
MOZ_ASSERT
(
aArea
-
>
mCols
.
IsAuto
(
)
&
&
aArea
-
>
mRows
.
IsAuto
(
)
)
;
const
uint32_t
colExtent
=
aArea
-
>
mCols
.
Extent
(
)
;
const
uint32_t
gridRowEnd
=
mGridRowEnd
;
const
uint32_t
gridColEnd
=
mGridColEnd
;
uint32_t
col
=
aStartCol
;
uint32_t
row
=
aStartRow
;
for
(
;
row
<
gridRowEnd
;
+
+
row
)
{
col
=
FindAutoCol
(
col
row
aArea
)
;
if
(
col
+
colExtent
<
=
gridColEnd
)
{
break
;
}
col
=
0
;
}
MOZ_ASSERT
(
row
<
gridRowEnd
|
|
col
=
=
0
"
expected
column
0
for
placing
in
a
new
row
"
)
;
aArea
-
>
mCols
.
ResolveAutoPosition
(
col
aClampMaxColLine
)
;
aArea
-
>
mRows
.
ResolveAutoPosition
(
row
aClampMaxRowLine
)
;
MOZ_ASSERT
(
aArea
-
>
IsDefinite
(
)
)
;
}
void
nsGridContainerFrame
:
:
Grid
:
:
PlaceAutoAutoInColOrder
(
uint32_t
aStartCol
uint32_t
aStartRow
GridArea
*
aArea
uint32_t
aClampMaxColLine
uint32_t
aClampMaxRowLine
)
const
{
MOZ_ASSERT
(
aArea
-
>
mCols
.
IsAuto
(
)
&
&
aArea
-
>
mRows
.
IsAuto
(
)
)
;
const
uint32_t
rowExtent
=
aArea
-
>
mRows
.
Extent
(
)
;
const
uint32_t
gridRowEnd
=
mGridRowEnd
;
const
uint32_t
gridColEnd
=
mGridColEnd
;
uint32_t
col
=
aStartCol
;
uint32_t
row
=
aStartRow
;
for
(
;
col
<
gridColEnd
;
+
+
col
)
{
row
=
FindAutoRow
(
col
row
aArea
)
;
if
(
row
+
rowExtent
<
=
gridRowEnd
)
{
break
;
}
row
=
0
;
}
MOZ_ASSERT
(
col
<
gridColEnd
|
|
row
=
=
0
"
expected
row
0
for
placing
in
a
new
column
"
)
;
aArea
-
>
mCols
.
ResolveAutoPosition
(
col
aClampMaxColLine
)
;
aArea
-
>
mRows
.
ResolveAutoPosition
(
row
aClampMaxRowLine
)
;
MOZ_ASSERT
(
aArea
-
>
IsDefinite
(
)
)
;
}
void
nsGridContainerFrame
:
:
Grid
:
:
SubgridPlaceGridItems
(
GridReflowInput
&
aParentState
Grid
*
aParentGrid
const
GridItemInfo
&
aGridItem
)
{
MOZ_ASSERT
(
aGridItem
.
mArea
.
IsDefinite
(
)
|
|
aGridItem
.
mFrame
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
"
the
subgrid
'
s
lines
should
be
resolved
by
now
"
)
;
if
(
aGridItem
.
IsSubgrid
(
eLogicalAxisInline
)
)
{
aParentState
.
mFrame
-
>
AddStateBits
(
NS_STATE_GRID_HAS_COL_SUBGRID_ITEM
)
;
}
if
(
aGridItem
.
IsSubgrid
(
eLogicalAxisBlock
)
)
{
aParentState
.
mFrame
-
>
AddStateBits
(
NS_STATE_GRID_HAS_ROW_SUBGRID_ITEM
)
;
}
auto
*
childGrid
=
aGridItem
.
SubgridFrame
(
)
;
const
auto
*
pos
=
childGrid
-
>
StylePosition
(
)
;
childGrid
-
>
NormalizeChildLists
(
)
;
GridReflowInput
state
(
childGrid
aParentState
.
mRenderingContext
)
;
childGrid
-
>
InitImplicitNamedAreas
(
pos
)
;
const
bool
isOrthogonal
=
aParentState
.
mWM
.
IsOrthogonalTo
(
state
.
mWM
)
;
auto
*
subgrid
=
childGrid
-
>
GetProperty
(
Subgrid
:
:
Prop
(
)
)
;
if
(
!
subgrid
)
{
subgrid
=
new
Subgrid
(
aGridItem
.
mArea
isOrthogonal
aParentState
.
mWM
)
;
childGrid
-
>
SetProperty
(
Subgrid
:
:
Prop
(
)
subgrid
)
;
}
else
{
subgrid
-
>
mArea
=
aGridItem
.
mArea
;
subgrid
-
>
mIsOrthogonal
=
isOrthogonal
;
subgrid
-
>
mGridItems
.
Clear
(
)
;
subgrid
-
>
mAbsPosItems
.
Clear
(
)
;
}
if
(
MOZ_UNLIKELY
(
subgrid
-
>
mArea
.
mCols
.
mStart
=
=
kAutoLine
)
)
{
subgrid
-
>
mArea
.
mCols
.
mStart
=
0
;
}
if
(
MOZ_UNLIKELY
(
subgrid
-
>
mArea
.
mCols
.
mEnd
=
=
kAutoLine
)
)
{
subgrid
-
>
mArea
.
mCols
.
mEnd
=
aParentGrid
-
>
mExplicitGridOffsetCol
+
aParentGrid
-
>
mExplicitGridColEnd
-
1
;
}
if
(
MOZ_UNLIKELY
(
subgrid
-
>
mArea
.
mRows
.
mStart
=
=
kAutoLine
)
)
{
subgrid
-
>
mArea
.
mRows
.
mStart
=
0
;
}
if
(
MOZ_UNLIKELY
(
subgrid
-
>
mArea
.
mRows
.
mEnd
=
=
kAutoLine
)
)
{
subgrid
-
>
mArea
.
mRows
.
mEnd
=
aParentGrid
-
>
mExplicitGridOffsetRow
+
aParentGrid
-
>
mExplicitGridRowEnd
-
1
;
}
RepeatTrackSizingInput
repeatSizing
(
state
.
mWM
)
;
if
(
!
childGrid
-
>
IsColSubgrid
(
)
&
&
state
.
mColFunctions
.
mHasRepeatAuto
)
{
repeatSizing
.
SetDefiniteSizes
(
eLogicalAxisInline
state
.
mWM
state
.
mGridStyle
-
>
MinISize
(
state
.
mWM
)
state
.
mGridStyle
-
>
ISize
(
state
.
mWM
)
state
.
mGridStyle
-
>
MaxISize
(
state
.
mWM
)
)
;
}
if
(
!
childGrid
-
>
IsRowSubgrid
(
)
&
&
state
.
mRowFunctions
.
mHasRepeatAuto
)
{
repeatSizing
.
SetDefiniteSizes
(
eLogicalAxisBlock
state
.
mWM
state
.
mGridStyle
-
>
MinBSize
(
state
.
mWM
)
state
.
mGridStyle
-
>
BSize
(
state
.
mWM
)
state
.
mGridStyle
-
>
MaxBSize
(
state
.
mWM
)
)
;
}
PlaceGridItems
(
state
repeatSizing
)
;
subgrid
-
>
mGridItems
=
std
:
:
move
(
state
.
mGridItems
)
;
subgrid
-
>
mAbsPosItems
=
std
:
:
move
(
state
.
mAbsPosItems
)
;
subgrid
-
>
mGridColEnd
=
mGridColEnd
;
subgrid
-
>
mGridRowEnd
=
mGridRowEnd
;
}
void
nsGridContainerFrame
:
:
Grid
:
:
PlaceGridItems
(
GridReflowInput
&
aState
const
RepeatTrackSizingInput
&
aSizes
)
{
MOZ_ASSERT
(
mCellMap
.
mCells
.
IsEmpty
(
)
"
unexpected
entries
in
cell
map
"
)
;
mAreas
=
aState
.
mFrame
-
>
GetImplicitNamedAreas
(
)
;
if
(
aState
.
mFrame
-
>
HasSubgridItems
(
)
|
|
aState
.
mFrame
-
>
IsSubgrid
(
)
)
{
if
(
auto
*
uts
=
aState
.
mFrame
-
>
GetUsedTrackSizes
(
)
)
{
uts
-
>
mCanResolveLineRangeSize
=
{
false
false
}
;
uts
-
>
mSizes
[
eLogicalAxisInline
]
.
ClearAndRetainStorage
(
)
;
uts
-
>
mSizes
[
eLogicalAxisBlock
]
.
ClearAndRetainStorage
(
)
;
}
}
aState
.
mFrame
-
>
RemoveStateBits
(
NS_STATE_GRID_HAS_COL_SUBGRID_ITEM
|
NS_STATE_GRID_HAS_ROW_SUBGRID_ITEM
)
;
const
nsStylePosition
*
const
gridStyle
=
aState
.
mGridStyle
;
const
auto
*
areas
=
gridStyle
-
>
mGridTemplateAreas
.
IsNone
(
)
?
nullptr
:
&
*
gridStyle
-
>
mGridTemplateAreas
.
AsAreas
(
)
;
int32_t
clampMinColLine
=
kMinLine
;
int32_t
clampMaxColLine
=
kMaxLine
;
uint32_t
numRepeatCols
;
const
LineNameMap
*
parentLineNameMap
=
nullptr
;
const
LineRange
*
subgridRange
=
nullptr
;
bool
subgridAxisIsSameDirection
=
true
;
if
(
!
aState
.
mFrame
-
>
IsColSubgrid
(
)
)
{
numRepeatCols
=
aState
.
mColFunctions
.
InitRepeatTracks
(
gridStyle
-
>
mColumnGap
aSizes
.
mMin
.
ISize
(
aState
.
mWM
)
aSizes
.
mSize
.
ISize
(
aState
.
mWM
)
aSizes
.
mMax
.
ISize
(
aState
.
mWM
)
)
;
uint32_t
areaCols
=
areas
?
areas
-
>
width
+
1
:
1
;
mExplicitGridColEnd
=
aState
.
mColFunctions
.
ComputeExplicitGridEnd
(
areaCols
)
;
}
else
{
const
auto
*
subgrid
=
aState
.
mFrame
-
>
GetProperty
(
Subgrid
:
:
Prop
(
)
)
;
subgridRange
=
&
subgrid
-
>
SubgridCols
(
)
;
uint32_t
extent
=
subgridRange
-
>
Extent
(
)
;
mExplicitGridColEnd
=
extent
+
1
;
clampMinColLine
=
1
;
clampMaxColLine
=
mExplicitGridColEnd
;
const
auto
&
cols
=
gridStyle
-
>
GridTemplateColumns
(
)
;
numRepeatCols
=
cols
.
HasRepeatAuto
(
)
?
std
:
:
max
<
uint32_t
>
(
extent
-
cols
.
mLineNameLists
.
Length
(
)
1
)
:
0
;
parentLineNameMap
=
ParentLineMapForAxis
(
subgrid
-
>
mIsOrthogonal
eLogicalAxisInline
)
;
auto
parentWM
=
aState
.
mFrame
-
>
ParentGridContainerForSubgrid
(
)
-
>
GetWritingMode
(
)
;
subgridAxisIsSameDirection
=
aState
.
mWM
.
ParallelAxisStartsOnSameSide
(
eLogicalAxisInline
parentWM
)
;
}
mGridColEnd
=
mExplicitGridColEnd
;
LineNameMap
colLineNameMap
(
gridStyle
mAreas
gridStyle
-
>
GridTemplateColumns
(
)
numRepeatCols
clampMinColLine
clampMaxColLine
parentLineNameMap
subgridRange
subgridAxisIsSameDirection
)
;
int32_t
clampMinRowLine
=
kMinLine
;
int32_t
clampMaxRowLine
=
kMaxLine
;
uint32_t
numRepeatRows
;
if
(
!
aState
.
mFrame
-
>
IsRowSubgrid
(
)
)
{
numRepeatRows
=
aState
.
mRowFunctions
.
InitRepeatTracks
(
gridStyle
-
>
mRowGap
aSizes
.
mMin
.
BSize
(
aState
.
mWM
)
aSizes
.
mSize
.
BSize
(
aState
.
mWM
)
aSizes
.
mMax
.
BSize
(
aState
.
mWM
)
)
;
uint32_t
areaRows
=
areas
?
areas
-
>
strings
.
Length
(
)
+
1
:
1
;
mExplicitGridRowEnd
=
aState
.
mRowFunctions
.
ComputeExplicitGridEnd
(
areaRows
)
;
parentLineNameMap
=
nullptr
;
subgridRange
=
nullptr
;
}
else
{
const
auto
*
subgrid
=
aState
.
mFrame
-
>
GetProperty
(
Subgrid
:
:
Prop
(
)
)
;
subgridRange
=
&
subgrid
-
>
SubgridRows
(
)
;
uint32_t
extent
=
subgridRange
-
>
Extent
(
)
;
mExplicitGridRowEnd
=
extent
+
1
;
clampMinRowLine
=
1
;
clampMaxRowLine
=
mExplicitGridRowEnd
;
const
auto
&
rows
=
gridStyle
-
>
GridTemplateRows
(
)
;
numRepeatRows
=
rows
.
HasRepeatAuto
(
)
?
std
:
:
max
<
uint32_t
>
(
extent
-
rows
.
mLineNameLists
.
Length
(
)
1
)
:
0
;
parentLineNameMap
=
ParentLineMapForAxis
(
subgrid
-
>
mIsOrthogonal
eLogicalAxisBlock
)
;
auto
parentWM
=
aState
.
mFrame
-
>
ParentGridContainerForSubgrid
(
)
-
>
GetWritingMode
(
)
;
subgridAxisIsSameDirection
=
aState
.
mWM
.
ParallelAxisStartsOnSameSide
(
eLogicalAxisBlock
parentWM
)
;
}
mGridRowEnd
=
mExplicitGridRowEnd
;
LineNameMap
rowLineNameMap
(
gridStyle
mAreas
gridStyle
-
>
GridTemplateRows
(
)
numRepeatRows
clampMinRowLine
clampMaxRowLine
parentLineNameMap
subgridRange
subgridAxisIsSameDirection
)
;
const
bool
isSubgridOrItemInSubgrid
=
aState
.
mFrame
-
>
IsSubgrid
(
)
|
|
!
!
mParentGrid
;
auto
SetSubgridChildEdgeBits
=
[
this
isSubgridOrItemInSubgrid
]
(
GridItemInfo
&
aItem
)
-
>
void
{
if
(
isSubgridOrItemInSubgrid
)
{
const
auto
&
area
=
aItem
.
mArea
;
if
(
area
.
mCols
.
mStart
=
=
0
)
{
aItem
.
mState
[
eLogicalAxisInline
]
|
=
ItemState
:
:
eStartEdge
;
}
if
(
area
.
mCols
.
mEnd
=
=
mGridColEnd
)
{
aItem
.
mState
[
eLogicalAxisInline
]
|
=
ItemState
:
:
eEndEdge
;
}
if
(
area
.
mRows
.
mStart
=
=
0
)
{
aItem
.
mState
[
eLogicalAxisBlock
]
|
=
ItemState
:
:
eStartEdge
;
}
if
(
area
.
mRows
.
mEnd
=
=
mGridRowEnd
)
{
aItem
.
mState
[
eLogicalAxisBlock
]
|
=
ItemState
:
:
eEndEdge
;
}
}
}
;
SetLineMaps
(
&
colLineNameMap
&
rowLineNameMap
)
;
int32_t
minCol
=
1
;
int32_t
minRow
=
1
;
aState
.
mGridItems
.
ClearAndRetainStorage
(
)
;
aState
.
mIter
.
Reset
(
)
;
for
(
;
!
aState
.
mIter
.
AtEnd
(
)
;
aState
.
mIter
.
Next
(
)
)
{
nsIFrame
*
child
=
*
aState
.
mIter
;
GridItemInfo
*
info
=
aState
.
mGridItems
.
AppendElement
(
GridItemInfo
(
child
PlaceDefinite
(
child
colLineNameMap
rowLineNameMap
gridStyle
)
)
)
;
MOZ_ASSERT
(
aState
.
mIter
.
ItemIndex
(
)
=
=
aState
.
mGridItems
.
Length
(
)
-
1
"
ItemIndex
(
)
is
broken
"
)
;
GridArea
&
area
=
info
-
>
mArea
;
if
(
area
.
mCols
.
IsDefinite
(
)
)
{
minCol
=
std
:
:
min
(
minCol
area
.
mCols
.
mUntranslatedStart
)
;
}
if
(
area
.
mRows
.
IsDefinite
(
)
)
{
minRow
=
std
:
:
min
(
minRow
area
.
mRows
.
mUntranslatedStart
)
;
}
}
mExplicitGridOffsetCol
=
1
-
minCol
;
mExplicitGridOffsetRow
=
1
-
minRow
;
aState
.
mColFunctions
.
mExplicitGridOffset
=
mExplicitGridOffsetCol
;
aState
.
mRowFunctions
.
mExplicitGridOffset
=
mExplicitGridOffsetRow
;
const
int32_t
offsetToColZero
=
int32_t
(
mExplicitGridOffsetCol
)
-
1
;
const
int32_t
offsetToRowZero
=
int32_t
(
mExplicitGridOffsetRow
)
-
1
;
mGridColEnd
+
=
offsetToColZero
;
mGridRowEnd
+
=
offsetToRowZero
;
clampMaxColLine
+
=
offsetToColZero
;
clampMaxRowLine
+
=
offsetToRowZero
;
aState
.
mIter
.
Reset
(
)
;
for
(
;
!
aState
.
mIter
.
AtEnd
(
)
;
aState
.
mIter
.
Next
(
)
)
{
auto
&
item
=
aState
.
mGridItems
[
aState
.
mIter
.
ItemIndex
(
)
]
;
GridArea
&
area
=
item
.
mArea
;
if
(
area
.
mCols
.
IsDefinite
(
)
)
{
area
.
mCols
.
mStart
=
area
.
mCols
.
mUntranslatedStart
+
offsetToColZero
;
area
.
mCols
.
mEnd
=
area
.
mCols
.
mUntranslatedEnd
+
offsetToColZero
;
}
if
(
area
.
mRows
.
IsDefinite
(
)
)
{
area
.
mRows
.
mStart
=
area
.
mRows
.
mUntranslatedStart
+
offsetToRowZero
;
area
.
mRows
.
mEnd
=
area
.
mRows
.
mUntranslatedEnd
+
offsetToRowZero
;
}
if
(
area
.
IsDefinite
(
)
)
{
if
(
item
.
IsSubgrid
(
)
)
{
Grid
grid
(
this
)
;
grid
.
SubgridPlaceGridItems
(
aState
this
item
)
;
}
mCellMap
.
Fill
(
area
)
;
InflateGridFor
(
area
)
;
SetSubgridChildEdgeBits
(
item
)
;
}
}
auto
flowStyle
=
gridStyle
-
>
mGridAutoFlow
;
const
bool
isRowOrder
=
(
flowStyle
&
NS_STYLE_GRID_AUTO_FLOW_ROW
)
;
const
bool
isSparse
=
!
(
flowStyle
&
NS_STYLE_GRID_AUTO_FLOW_DENSE
)
;
{
Maybe
<
nsDataHashtable
<
nsUint32HashKey
uint32_t
>
>
cursors
;
if
(
isSparse
)
{
cursors
.
emplace
(
)
;
}
auto
placeAutoMinorFunc
=
isRowOrder
?
&
Grid
:
:
PlaceAutoCol
:
&
Grid
:
:
PlaceAutoRow
;
uint32_t
clampMaxLine
=
isRowOrder
?
clampMaxColLine
:
clampMaxRowLine
;
aState
.
mIter
.
Reset
(
)
;
for
(
;
!
aState
.
mIter
.
AtEnd
(
)
;
aState
.
mIter
.
Next
(
)
)
{
auto
&
item
=
aState
.
mGridItems
[
aState
.
mIter
.
ItemIndex
(
)
]
;
GridArea
&
area
=
item
.
mArea
;
LineRange
&
major
=
isRowOrder
?
area
.
mRows
:
area
.
mCols
;
LineRange
&
minor
=
isRowOrder
?
area
.
mCols
:
area
.
mRows
;
if
(
major
.
IsDefinite
(
)
&
&
minor
.
IsAuto
(
)
)
{
uint32_t
cursor
=
0
;
if
(
isSparse
)
{
cursors
-
>
Get
(
major
.
mStart
&
cursor
)
;
}
(
this
-
>
*
placeAutoMinorFunc
)
(
cursor
&
area
clampMaxLine
)
;
if
(
item
.
IsSubgrid
(
)
)
{
Grid
grid
(
this
)
;
grid
.
SubgridPlaceGridItems
(
aState
this
item
)
;
}
mCellMap
.
Fill
(
area
)
;
SetSubgridChildEdgeBits
(
item
)
;
if
(
isSparse
)
{
cursors
-
>
Put
(
major
.
mStart
minor
.
mEnd
)
;
}
}
InflateGridFor
(
area
)
;
}
}
uint32_t
cursorMajor
=
0
;
uint32_t
cursorMinor
=
0
;
auto
placeAutoMajorFunc
=
isRowOrder
?
&
Grid
:
:
PlaceAutoRow
:
&
Grid
:
:
PlaceAutoCol
;
uint32_t
clampMaxMajorLine
=
isRowOrder
?
clampMaxRowLine
:
clampMaxColLine
;
aState
.
mIter
.
Reset
(
)
;
for
(
;
!
aState
.
mIter
.
AtEnd
(
)
;
aState
.
mIter
.
Next
(
)
)
{
auto
&
item
=
aState
.
mGridItems
[
aState
.
mIter
.
ItemIndex
(
)
]
;
GridArea
&
area
=
item
.
mArea
;
MOZ_ASSERT
(
*
aState
.
mIter
=
=
item
.
mFrame
"
iterator
out
of
sync
with
aState
.
mGridItems
"
)
;
LineRange
&
major
=
isRowOrder
?
area
.
mRows
:
area
.
mCols
;
LineRange
&
minor
=
isRowOrder
?
area
.
mCols
:
area
.
mRows
;
if
(
major
.
IsAuto
(
)
)
{
if
(
minor
.
IsDefinite
(
)
)
{
if
(
isSparse
)
{
if
(
minor
.
mStart
<
cursorMinor
)
{
+
+
cursorMajor
;
}
cursorMinor
=
minor
.
mStart
;
}
(
this
-
>
*
placeAutoMajorFunc
)
(
cursorMajor
&
area
clampMaxMajorLine
)
;
if
(
isSparse
)
{
cursorMajor
=
major
.
mStart
;
}
}
else
{
if
(
isRowOrder
)
{
PlaceAutoAutoInRowOrder
(
cursorMinor
cursorMajor
&
area
clampMaxColLine
clampMaxRowLine
)
;
}
else
{
PlaceAutoAutoInColOrder
(
cursorMajor
cursorMinor
&
area
clampMaxColLine
clampMaxRowLine
)
;
}
if
(
isSparse
)
{
cursorMajor
=
major
.
mStart
;
cursorMinor
=
minor
.
mEnd
;
#
ifdef
DEBUG
uint32_t
gridMajorEnd
=
isRowOrder
?
mGridRowEnd
:
mGridColEnd
;
uint32_t
gridMinorEnd
=
isRowOrder
?
mGridColEnd
:
mGridRowEnd
;
MOZ_ASSERT
(
cursorMajor
<
=
gridMajorEnd
"
we
shouldn
'
t
need
to
place
items
further
than
1
track
"
"
past
the
current
end
of
the
grid
in
major
dimension
"
)
;
MOZ_ASSERT
(
cursorMinor
<
=
gridMinorEnd
"
we
shouldn
'
t
add
implicit
minor
tracks
for
auto
/
auto
"
)
;
#
endif
}
}
if
(
item
.
IsSubgrid
(
)
)
{
Grid
grid
(
this
)
;
grid
.
SubgridPlaceGridItems
(
aState
this
item
)
;
}
mCellMap
.
Fill
(
area
)
;
InflateGridFor
(
area
)
;
SetSubgridChildEdgeBits
(
item
)
;
}
}
if
(
aState
.
mFrame
-
>
IsAbsoluteContainer
(
)
)
{
nsFrameList
children
(
aState
.
mFrame
-
>
GetChildList
(
aState
.
mFrame
-
>
GetAbsoluteListID
(
)
)
)
;
const
int32_t
offsetToColZero
=
int32_t
(
mExplicitGridOffsetCol
)
-
1
;
const
int32_t
offsetToRowZero
=
int32_t
(
mExplicitGridOffsetRow
)
-
1
;
AutoRestore
<
uint32_t
>
save1
(
mGridColEnd
)
;
AutoRestore
<
uint32_t
>
save2
(
mGridRowEnd
)
;
mGridColEnd
-
=
offsetToColZero
;
mGridRowEnd
-
=
offsetToRowZero
;
aState
.
mAbsPosItems
.
ClearAndRetainStorage
(
)
;
size_t
i
=
0
;
for
(
nsFrameList
:
:
Enumerator
e
(
children
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
+
+
i
)
{
nsIFrame
*
child
=
e
.
get
(
)
;
GridItemInfo
*
info
=
aState
.
mAbsPosItems
.
AppendElement
(
GridItemInfo
(
child
PlaceAbsPos
(
child
colLineNameMap
rowLineNameMap
gridStyle
)
)
)
;
GridArea
&
area
=
info
-
>
mArea
;
if
(
area
.
mCols
.
mUntranslatedStart
!
=
int32_t
(
kAutoLine
)
)
{
area
.
mCols
.
mStart
=
area
.
mCols
.
mUntranslatedStart
+
offsetToColZero
;
}
if
(
area
.
mCols
.
mUntranslatedEnd
!
=
int32_t
(
kAutoLine
)
)
{
area
.
mCols
.
mEnd
=
area
.
mCols
.
mUntranslatedEnd
+
offsetToColZero
;
}
if
(
area
.
mRows
.
mUntranslatedStart
!
=
int32_t
(
kAutoLine
)
)
{
area
.
mRows
.
mStart
=
area
.
mRows
.
mUntranslatedStart
+
offsetToRowZero
;
}
if
(
area
.
mRows
.
mUntranslatedEnd
!
=
int32_t
(
kAutoLine
)
)
{
area
.
mRows
.
mEnd
=
area
.
mRows
.
mUntranslatedEnd
+
offsetToRowZero
;
}
if
(
info
-
>
IsSubgrid
(
)
)
{
Grid
grid
(
this
)
;
grid
.
SubgridPlaceGridItems
(
aState
this
*
info
)
;
}
}
}
Maybe
<
nsTArray
<
uint32_t
>
>
colAdjust
;
uint32_t
numEmptyCols
=
0
;
if
(
aState
.
mColFunctions
.
mHasRepeatAuto
&
&
!
gridStyle
-
>
GridTemplateColumns
(
)
.
mIsAutoFill
&
&
aState
.
mColFunctions
.
NumRepeatTracks
(
)
>
0
)
{
const
uint32_t
repeatStart
=
(
aState
.
mColFunctions
.
mExplicitGridOffset
+
aState
.
mColFunctions
.
mRepeatAutoStart
)
;
const
uint32_t
numRepeats
=
aState
.
mColFunctions
.
NumRepeatTracks
(
)
;
const
uint32_t
numColLines
=
mGridColEnd
+
1
;
for
(
uint32_t
i
=
0
;
i
<
numRepeats
;
+
+
i
)
{
if
(
numEmptyCols
)
{
(
*
colAdjust
)
[
repeatStart
+
i
]
=
numEmptyCols
;
}
if
(
mCellMap
.
IsEmptyCol
(
repeatStart
+
i
)
)
{
+
+
numEmptyCols
;
if
(
colAdjust
.
isNothing
(
)
)
{
colAdjust
.
emplace
(
numColLines
)
;
colAdjust
-
>
SetLength
(
numColLines
)
;
PodZero
(
colAdjust
-
>
Elements
(
)
colAdjust
-
>
Length
(
)
)
;
}
aState
.
mColFunctions
.
mRemovedRepeatTracks
[
i
]
=
true
;
}
}
if
(
numEmptyCols
)
{
for
(
uint32_t
col
=
repeatStart
+
numRepeats
;
col
<
numColLines
;
+
+
col
)
{
(
*
colAdjust
)
[
col
]
=
numEmptyCols
;
}
}
}
Maybe
<
nsTArray
<
uint32_t
>
>
rowAdjust
;
uint32_t
numEmptyRows
=
0
;
if
(
aState
.
mRowFunctions
.
mHasRepeatAuto
&
&
!
gridStyle
-
>
GridTemplateRows
(
)
.
mIsAutoFill
&
&
aState
.
mRowFunctions
.
NumRepeatTracks
(
)
>
0
)
{
const
uint32_t
repeatStart
=
(
aState
.
mRowFunctions
.
mExplicitGridOffset
+
aState
.
mRowFunctions
.
mRepeatAutoStart
)
;
const
uint32_t
numRepeats
=
aState
.
mRowFunctions
.
NumRepeatTracks
(
)
;
const
uint32_t
numRowLines
=
mGridRowEnd
+
1
;
for
(
uint32_t
i
=
0
;
i
<
numRepeats
;
+
+
i
)
{
if
(
numEmptyRows
)
{
(
*
rowAdjust
)
[
repeatStart
+
i
]
=
numEmptyRows
;
}
if
(
mCellMap
.
IsEmptyRow
(
repeatStart
+
i
)
)
{
+
+
numEmptyRows
;
if
(
rowAdjust
.
isNothing
(
)
)
{
rowAdjust
.
emplace
(
numRowLines
)
;
rowAdjust
-
>
SetLength
(
numRowLines
)
;
PodZero
(
rowAdjust
-
>
Elements
(
)
rowAdjust
-
>
Length
(
)
)
;
}
aState
.
mRowFunctions
.
mRemovedRepeatTracks
[
i
]
=
true
;
}
}
if
(
numEmptyRows
)
{
for
(
uint32_t
row
=
repeatStart
+
numRepeats
;
row
<
numRowLines
;
+
+
row
)
{
(
*
rowAdjust
)
[
row
]
=
numEmptyRows
;
}
}
}
if
(
numEmptyCols
|
|
numEmptyRows
)
{
for
(
auto
&
item
:
aState
.
mGridItems
)
{
GridArea
&
area
=
item
.
mArea
;
if
(
numEmptyCols
)
{
area
.
mCols
.
AdjustForRemovedTracks
(
*
colAdjust
)
;
}
if
(
numEmptyRows
)
{
area
.
mRows
.
AdjustForRemovedTracks
(
*
rowAdjust
)
;
}
}
for
(
auto
&
item
:
aState
.
mAbsPosItems
)
{
GridArea
&
area
=
item
.
mArea
;
if
(
numEmptyCols
)
{
area
.
mCols
.
AdjustAbsPosForRemovedTracks
(
*
colAdjust
)
;
}
if
(
numEmptyRows
)
{
area
.
mRows
.
AdjustAbsPosForRemovedTracks
(
*
rowAdjust
)
;
}
}
mGridColEnd
-
=
numEmptyCols
;
mExplicitGridColEnd
-
=
numEmptyCols
;
mGridRowEnd
-
=
numEmptyRows
;
mExplicitGridRowEnd
-
=
numEmptyRows
;
auto
colRepeatCount
=
aState
.
mColFunctions
.
NumRepeatTracks
(
)
;
aState
.
mColFunctions
.
SetNumRepeatTracks
(
colRepeatCount
-
numEmptyCols
)
;
auto
rowRepeatCount
=
aState
.
mRowFunctions
.
NumRepeatTracks
(
)
;
aState
.
mRowFunctions
.
SetNumRepeatTracks
(
rowRepeatCount
-
numEmptyRows
)
;
}
if
(
mAreas
&
&
aState
.
mFrame
-
>
HasAnyStateBits
(
NS_STATE_GRID_GENERATE_COMPUTED_VALUES
)
)
{
for
(
auto
iter
=
mAreas
-
>
iter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
auto
&
areaInfo
=
iter
.
get
(
)
.
value
(
)
;
StyleGridLine
lineStartAndEnd
;
lineStartAndEnd
.
ident
=
areaInfo
.
name
;
LineRange
columnLines
=
ResolveLineRange
(
lineStartAndEnd
lineStartAndEnd
colLineNameMap
eLogicalAxisInline
mExplicitGridColEnd
gridStyle
)
;
LineRange
rowLines
=
ResolveLineRange
(
lineStartAndEnd
lineStartAndEnd
rowLineNameMap
eLogicalAxisBlock
mExplicitGridRowEnd
gridStyle
)
;
areaInfo
.
columns
.
start
=
columnLines
.
mStart
+
mExplicitGridOffsetCol
;
areaInfo
.
columns
.
end
=
columnLines
.
mEnd
+
mExplicitGridOffsetCol
;
areaInfo
.
rows
.
start
=
rowLines
.
mStart
+
mExplicitGridOffsetRow
;
areaInfo
.
rows
.
end
=
rowLines
.
mEnd
+
mExplicitGridOffsetRow
;
}
}
}
void
nsGridContainerFrame
:
:
Tracks
:
:
Initialize
(
const
TrackSizingFunctions
&
aFunctions
const
NonNegativeLengthPercentageOrNormal
&
aGridGap
uint32_t
aNumTracks
nscoord
aContentBoxSize
)
{
MOZ_ASSERT
(
aNumTracks
>
=
aFunctions
.
mExplicitGridOffset
+
aFunctions
.
NumExplicitTracks
(
)
)
;
mSizes
.
SetLength
(
aNumTracks
)
;
PodZero
(
mSizes
.
Elements
(
)
mSizes
.
Length
(
)
)
;
for
(
uint32_t
i
=
0
len
=
mSizes
.
Length
(
)
;
i
<
len
;
+
+
i
)
{
mStateUnion
|
=
mSizes
[
i
]
.
Initialize
(
aContentBoxSize
aFunctions
.
MinSizingFor
(
i
)
aFunctions
.
MaxSizingFor
(
i
)
)
;
}
mGridGap
=
nsLayoutUtils
:
:
ResolveGapToLength
(
aGridGap
aContentBoxSize
)
;
mContentBoxSize
=
aContentBoxSize
;
}
static
nscoord
MeasuringReflow
(
nsIFrame
*
aChild
const
ReflowInput
*
aReflowInput
gfxContext
*
aRC
const
LogicalSize
&
aAvailableSize
const
LogicalSize
&
aCBSize
nscoord
aIMinSizeClamp
=
NS_MAXSIZE
nscoord
aBMinSizeClamp
=
NS_MAXSIZE
)
{
nsContainerFrame
*
parent
=
aChild
-
>
GetParent
(
)
;
nsPresContext
*
pc
=
aChild
-
>
PresContext
(
)
;
Maybe
<
ReflowInput
>
dummyParentState
;
const
ReflowInput
*
rs
=
aReflowInput
;
if
(
!
aReflowInput
)
{
MOZ_ASSERT
(
!
parent
-
>
HasAnyStateBits
(
NS_FRAME_IN_REFLOW
)
)
;
dummyParentState
.
emplace
(
pc
parent
aRC
LogicalSize
(
parent
-
>
GetWritingMode
(
)
0
NS_UNCONSTRAINEDSIZE
)
ReflowInput
:
:
DUMMY_PARENT_REFLOW_INPUT
)
;
rs
=
dummyParentState
.
ptr
(
)
;
}
#
ifdef
DEBUG
parent
-
>
SetProperty
(
nsContainerFrame
:
:
DebugReflowingWithInfiniteISize
(
)
true
)
;
#
endif
auto
wm
=
aChild
-
>
GetWritingMode
(
)
;
uint32_t
riFlags
=
ReflowInput
:
:
COMPUTE_SIZE_USE_AUTO_BSIZE
;
if
(
aAvailableSize
.
ISize
(
wm
)
=
=
INFINITE_ISIZE_COORD
)
{
riFlags
|
=
ReflowInput
:
:
COMPUTE_SIZE_SHRINK_WRAP
;
}
if
(
aIMinSizeClamp
!
=
NS_MAXSIZE
)
{
riFlags
|
=
ReflowInput
:
:
I_CLAMP_MARGIN_BOX_MIN_SIZE
;
}
if
(
aBMinSizeClamp
!
=
NS_MAXSIZE
)
{
riFlags
|
=
ReflowInput
:
:
B_CLAMP_MARGIN_BOX_MIN_SIZE
;
aChild
-
>
SetProperty
(
nsIFrame
:
:
BClampMarginBoxMinSizeProperty
(
)
aBMinSizeClamp
)
;
}
else
{
aChild
-
>
DeleteProperty
(
nsIFrame
:
:
BClampMarginBoxMinSizeProperty
(
)
)
;
}
ReflowInput
childRI
(
pc
*
rs
aChild
aAvailableSize
Some
(
aCBSize
)
riFlags
)
;
childRI
.
SetBResize
(
true
)
;
ReflowOutput
childSize
(
childRI
)
;
nsReflowStatus
childStatus
;
const
uint32_t
flags
=
NS_FRAME_NO_MOVE_FRAME
|
NS_FRAME_NO_SIZE_VIEW
|
NS_FRAME_NO_DELETE_NEXT_IN_FLOW_CHILD
;
parent
-
>
ReflowChild
(
aChild
pc
childSize
childRI
wm
LogicalPoint
(
wm
)
nsSize
(
)
flags
childStatus
)
;
nsContainerFrame
:
:
FinishReflowChild
(
aChild
pc
childSize
&
childRI
wm
LogicalPoint
(
wm
)
nsSize
(
)
flags
)
;
#
ifdef
DEBUG
parent
-
>
DeleteProperty
(
nsContainerFrame
:
:
DebugReflowingWithInfiniteISize
(
)
)
;
#
endif
return
childSize
.
BSize
(
wm
)
;
}
static
LogicalMargin
SubgridAccumulatedMarginBorderPadding
(
nsIFrame
*
aFrame
const
Subgrid
*
aSubgrid
WritingMode
aResultWM
LogicalAxis
aAxis
)
{
MOZ_ASSERT
(
aFrame
-
>
IsGridContainerFrame
(
)
)
;
auto
*
subgridFrame
=
static_cast
<
nsGridContainerFrame
*
>
(
aFrame
)
;
LogicalMargin
result
(
aSubgrid
-
>
mMarginBorderPadding
)
;
auto
*
parent
=
subgridFrame
-
>
ParentGridContainerForSubgrid
(
)
;
auto
subgridCBWM
=
parent
-
>
GetWritingMode
(
)
;
auto
childRange
=
aSubgrid
-
>
mArea
.
LineRangeForAxis
(
aAxis
)
;
bool
skipStartSide
=
false
;
bool
skipEndSide
=
false
;
auto
axis
=
aSubgrid
-
>
mIsOrthogonal
?
GetOrthogonalAxis
(
aAxis
)
:
aAxis
;
while
(
parent
-
>
IsSubgrid
(
axis
)
)
{
auto
*
parentSubgrid
=
parent
-
>
GetProperty
(
Subgrid
:
:
Prop
(
)
)
;
auto
*
grandParent
=
parent
-
>
ParentGridContainerForSubgrid
(
)
;
auto
parentCBWM
=
grandParent
-
>
GetWritingMode
(
)
;
if
(
parentCBWM
.
IsOrthogonalTo
(
subgridCBWM
)
)
{
axis
=
GetOrthogonalAxis
(
axis
)
;
}
const
auto
&
parentRange
=
parentSubgrid
-
>
mArea
.
LineRangeForAxis
(
axis
)
;
bool
sameDir
=
parentCBWM
.
ParallelAxisStartsOnSameSide
(
axis
subgridCBWM
)
;
if
(
sameDir
)
{
skipStartSide
|
=
childRange
.
mStart
!
=
0
;
skipEndSide
|
=
childRange
.
mEnd
!
=
parentRange
.
Extent
(
)
;
}
else
{
skipEndSide
|
=
childRange
.
mStart
!
=
0
;
skipStartSide
|
=
childRange
.
mEnd
!
=
parentRange
.
Extent
(
)
;
}
if
(
skipStartSide
&
&
skipEndSide
)
{
break
;
}
auto
mbp
=
parentSubgrid
-
>
mMarginBorderPadding
.
ConvertTo
(
subgridCBWM
parentCBWM
)
;
if
(
skipStartSide
)
{
mbp
.
Start
(
aAxis
subgridCBWM
)
=
nscoord
(
0
)
;
}
if
(
skipEndSide
)
{
mbp
.
End
(
aAxis
subgridCBWM
)
=
nscoord
(
0
)
;
}
result
+
=
mbp
;
parent
=
grandParent
;
childRange
=
parentRange
;
}
return
result
.
ConvertTo
(
aResultWM
subgridCBWM
)
;
}
static
nscoord
ContentContribution
(
const
GridItemInfo
&
aGridItem
const
GridReflowInput
&
aState
gfxContext
*
aRC
WritingMode
aCBWM
LogicalAxis
aAxis
const
Maybe
<
LogicalSize
>
&
aPercentageBasis
IntrinsicISizeType
aConstraint
nscoord
aMinSizeClamp
=
NS_MAXSIZE
uint32_t
aFlags
=
0
)
{
nsIFrame
*
child
=
aGridItem
.
mFrame
;
nscoord
extraMargin
=
0
;
nsGridContainerFrame
:
:
Subgrid
*
subgrid
=
nullptr
;
if
(
child
-
>
GetParent
(
)
!
=
aState
.
mFrame
)
{
auto
*
subgridFrame
=
child
-
>
GetParent
(
)
;
subgrid
=
subgridFrame
-
>
GetProperty
(
Subgrid
:
:
Prop
(
)
)
;
const
auto
itemEdgeBits
=
aGridItem
.
mState
[
aAxis
]
&
ItemState
:
:
eEdgeBits
;
if
(
itemEdgeBits
)
{
LogicalMargin
mbp
=
SubgridAccumulatedMarginBorderPadding
(
subgridFrame
subgrid
aCBWM
aAxis
)
;
if
(
itemEdgeBits
&
ItemState
:
:
eStartEdge
)
{
extraMargin
+
=
mbp
.
Start
(
aAxis
aCBWM
)
;
}
if
(
itemEdgeBits
&
ItemState
:
:
eEndEdge
)
{
extraMargin
+
=
mbp
.
End
(
aAxis
aCBWM
)
;
}
}
if
(
itemEdgeBits
!
=
ItemState
:
:
eEdgeBits
)
{
auto
subgridAxis
=
aCBWM
.
IsOrthogonalTo
(
subgridFrame
-
>
GetWritingMode
(
)
)
?
GetOrthogonalAxis
(
aAxis
)
:
aAxis
;
auto
&
gapStyle
=
subgridAxis
=
=
eLogicalAxisBlock
?
subgridFrame
-
>
StylePosition
(
)
-
>
mRowGap
:
subgridFrame
-
>
StylePosition
(
)
-
>
mColumnGap
;
if
(
!
gapStyle
.
IsNormal
(
)
)
{
auto
subgridExtent
=
subgridAxis
=
=
eLogicalAxisBlock
?
subgrid
-
>
mGridRowEnd
:
subgrid
-
>
mGridColEnd
;
if
(
subgridExtent
>
1
)
{
nscoord
subgridGap
=
nsLayoutUtils
:
:
ResolveGapToLength
(
gapStyle
NS_UNCONSTRAINEDSIZE
)
;
auto
&
tracks
=
aAxis
=
=
eLogicalAxisBlock
?
aState
.
mRows
:
aState
.
mCols
;
auto
gapDelta
=
subgridGap
-
tracks
.
mGridGap
;
if
(
!
itemEdgeBits
)
{
extraMargin
+
=
gapDelta
;
}
else
{
extraMargin
+
=
gapDelta
/
2
;
}
}
}
}
}
PhysicalAxis
axis
(
aCBWM
.
PhysicalAxis
(
aAxis
)
)
;
nscoord
size
=
nsLayoutUtils
:
:
IntrinsicForAxis
(
axis
aRC
child
aConstraint
aPercentageBasis
aFlags
|
nsLayoutUtils
:
:
BAIL_IF_REFLOW_NEEDED
aMinSizeClamp
)
;
auto
childWM
=
child
-
>
GetWritingMode
(
)
;
const
bool
isOrthogonal
=
childWM
.
IsOrthogonalTo
(
aCBWM
)
;
auto
childAxis
=
isOrthogonal
?
GetOrthogonalAxis
(
aAxis
)
:
aAxis
;
if
(
size
=
=
NS_INTRINSIC_ISIZE_UNKNOWN
&
&
childAxis
=
=
eLogicalAxisBlock
)
{
nscoord
availISize
=
INFINITE_ISIZE_COORD
;
nscoord
availBSize
=
NS_UNCONSTRAINEDSIZE
;
nscoord
iMinSizeClamp
=
NS_MAXSIZE
;
nscoord
bMinSizeClamp
=
NS_MAXSIZE
;
LogicalSize
cbSize
(
childWM
0
NS_UNCONSTRAINEDSIZE
)
;
if
(
child
-
>
GetParent
(
)
!
=
aState
.
mFrame
)
{
auto
*
subgridFrame
=
static_cast
<
nsGridContainerFrame
*
>
(
child
-
>
GetParent
(
)
)
;
MOZ_ASSERT
(
subgridFrame
-
>
IsGridContainerFrame
(
)
)
;
auto
*
uts
=
subgridFrame
-
>
GetProperty
(
UsedTrackSizes
:
:
Prop
(
)
)
;
if
(
!
uts
)
{
uts
=
new
UsedTrackSizes
(
)
;
subgridFrame
-
>
SetProperty
(
UsedTrackSizes
:
:
Prop
(
)
uts
)
;
}
auto
subgridAxis
=
childWM
.
IsOrthogonalTo
(
subgridFrame
-
>
GetWritingMode
(
)
)
?
eLogicalAxisBlock
:
eLogicalAxisInline
;
uts
-
>
ResolveTrackSizesForAxis
(
subgridFrame
subgridAxis
*
aRC
)
;
if
(
uts
-
>
mCanResolveLineRangeSize
[
subgridAxis
]
)
{
auto
*
subgrid
=
subgridFrame
-
>
GetProperty
(
nsGridContainerFrame
:
:
Subgrid
:
:
Prop
(
)
)
;
const
GridItemInfo
*
originalItem
=
nullptr
;
for
(
const
auto
&
item
:
subgrid
-
>
mGridItems
)
{
if
(
item
.
mFrame
=
=
child
)
{
originalItem
=
&
item
;
break
;
}
}
MOZ_ASSERT
(
originalItem
"
huh
?
"
)
;
const
auto
&
range
=
originalItem
-
>
mArea
.
LineRangeForAxis
(
subgridAxis
)
;
nscoord
pos
sz
;
range
.
ToPositionAndLength
(
uts
-
>
mSizes
[
subgridAxis
]
&
pos
&
sz
)
;
if
(
childWM
.
IsOrthogonalTo
(
subgridFrame
-
>
GetWritingMode
(
)
)
)
{
availBSize
=
sz
;
cbSize
.
BSize
(
childWM
)
=
sz
;
if
(
aGridItem
.
mState
[
aAxis
]
&
ItemState
:
:
eClampMarginBoxMinSize
)
{
bMinSizeClamp
=
sz
;
}
}
else
{
availISize
=
sz
;
cbSize
.
ISize
(
childWM
)
=
sz
;
if
(
aGridItem
.
mState
[
aAxis
]
&
ItemState
:
:
eClampMarginBoxMinSize
)
{
iMinSizeClamp
=
sz
;
}
}
}
}
else
if
(
aState
.
mCols
.
mCanResolveLineRangeSize
)
{
nscoord
sz
=
aState
.
mCols
.
ResolveSize
(
aGridItem
.
mArea
.
mCols
)
;
if
(
isOrthogonal
)
{
availBSize
=
sz
;
cbSize
.
BSize
(
childWM
)
=
sz
;
if
(
aGridItem
.
mState
[
aAxis
]
&
ItemState
:
:
eClampMarginBoxMinSize
)
{
bMinSizeClamp
=
sz
;
}
}
else
{
availISize
=
sz
;
cbSize
.
ISize
(
childWM
)
=
sz
;
if
(
aGridItem
.
mState
[
aAxis
]
&
ItemState
:
:
eClampMarginBoxMinSize
)
{
iMinSizeClamp
=
sz
;
}
}
}
if
(
isOrthogonal
=
=
(
aAxis
=
=
eLogicalAxisInline
)
)
{
bMinSizeClamp
=
aMinSizeClamp
;
}
else
{
iMinSizeClamp
=
aMinSizeClamp
;
}
LogicalSize
availableSize
(
childWM
availISize
availBSize
)
;
size
=
:
:
MeasuringReflow
(
child
aState
.
mReflowInput
aRC
availableSize
cbSize
iMinSizeClamp
bMinSizeClamp
)
;
size
+
=
child
-
>
GetLogicalUsedMargin
(
childWM
)
.
BStartEnd
(
childWM
)
;
nscoord
overflow
=
size
-
aMinSizeClamp
;
if
(
MOZ_UNLIKELY
(
overflow
>
0
)
)
{
nscoord
contentSize
=
child
-
>
ContentBSize
(
childWM
)
;
nscoord
newContentSize
=
std
:
:
max
(
nscoord
(
0
)
contentSize
-
overflow
)
;
size
-
=
contentSize
-
newContentSize
;
}
}
MOZ_ASSERT
(
aGridItem
.
mBaselineOffset
[
aAxis
]
>
=
0
"
baseline
offset
should
be
non
-
negative
at
this
point
"
)
;
MOZ_ASSERT
(
(
aGridItem
.
mState
[
aAxis
]
&
ItemState
:
:
eIsBaselineAligned
)
|
|
aGridItem
.
mBaselineOffset
[
aAxis
]
=
=
nscoord
(
0
)
"
baseline
offset
should
be
zero
when
not
baseline
-
aligned
"
)
;
size
+
=
aGridItem
.
mBaselineOffset
[
aAxis
]
;
size
+
=
extraMargin
;
return
std
:
:
max
(
size
0
)
;
}
struct
CachedIntrinsicSizes
{
Maybe
<
nscoord
>
mMinSize
;
Maybe
<
nscoord
>
mMinContentContribution
;
Maybe
<
nscoord
>
mMaxContentContribution
;
Maybe
<
LogicalSize
>
mPercentageBasis
;
nscoord
mMinSizeClamp
=
NS_MAXSIZE
;
}
;
static
nscoord
MinContentContribution
(
const
GridItemInfo
&
aGridItem
const
GridReflowInput
&
aState
gfxContext
*
aRC
WritingMode
aCBWM
LogicalAxis
aAxis
CachedIntrinsicSizes
*
aCache
)
{
if
(
aCache
-
>
mMinContentContribution
.
isSome
(
)
)
{
return
aCache
-
>
mMinContentContribution
.
value
(
)
;
}
if
(
aCache
-
>
mPercentageBasis
.
isNothing
(
)
)
{
aCache
-
>
mPercentageBasis
.
emplace
(
aState
.
PercentageBasisFor
(
aAxis
aGridItem
)
)
;
}
nscoord
s
=
ContentContribution
(
aGridItem
aState
aRC
aCBWM
aAxis
aCache
-
>
mPercentageBasis
nsLayoutUtils
:
:
MIN_ISIZE
aCache
-
>
mMinSizeClamp
)
;
aCache
-
>
mMinContentContribution
.
emplace
(
s
)
;
return
s
;
}
static
nscoord
MaxContentContribution
(
const
GridItemInfo
&
aGridItem
const
GridReflowInput
&
aState
gfxContext
*
aRC
WritingMode
aCBWM
LogicalAxis
aAxis
CachedIntrinsicSizes
*
aCache
)
{
if
(
aCache
-
>
mMaxContentContribution
.
isSome
(
)
)
{
return
aCache
-
>
mMaxContentContribution
.
value
(
)
;
}
if
(
aCache
-
>
mPercentageBasis
.
isNothing
(
)
)
{
aCache
-
>
mPercentageBasis
.
emplace
(
aState
.
PercentageBasisFor
(
aAxis
aGridItem
)
)
;
}
nscoord
s
=
ContentContribution
(
aGridItem
aState
aRC
aCBWM
aAxis
aCache
-
>
mPercentageBasis
nsLayoutUtils
:
:
PREF_ISIZE
aCache
-
>
mMinSizeClamp
)
;
aCache
-
>
mMaxContentContribution
.
emplace
(
s
)
;
return
s
;
}
static
nscoord
MinSize
(
const
GridItemInfo
&
aGridItem
const
GridReflowInput
&
aState
gfxContext
*
aRC
WritingMode
aCBWM
LogicalAxis
aAxis
CachedIntrinsicSizes
*
aCache
)
{
if
(
aCache
-
>
mMinSize
.
isSome
(
)
)
{
return
aCache
-
>
mMinSize
.
value
(
)
;
}
nsIFrame
*
child
=
aGridItem
.
mFrame
;
PhysicalAxis
axis
(
aCBWM
.
PhysicalAxis
(
aAxis
)
)
;
const
nsStylePosition
*
stylePos
=
child
-
>
StylePosition
(
)
;
StyleSize
sizeStyle
=
axis
=
=
eAxisHorizontal
?
stylePos
-
>
mWidth
:
stylePos
-
>
mHeight
;
auto
ourInlineAxis
=
child
-
>
GetWritingMode
(
)
.
PhysicalAxis
(
eLogicalAxisInline
)
;
if
(
axis
!
=
ourInlineAxis
&
&
sizeStyle
.
IsExtremumLength
(
)
)
{
sizeStyle
=
StyleSize
:
:
Auto
(
)
;
}
if
(
!
sizeStyle
.
IsAuto
(
)
&
&
!
sizeStyle
.
HasPercent
(
)
)
{
nscoord
s
=
MinContentContribution
(
aGridItem
aState
aRC
aCBWM
aAxis
aCache
)
;
aCache
-
>
mMinSize
.
emplace
(
s
)
;
return
s
;
}
if
(
aCache
-
>
mPercentageBasis
.
isNothing
(
)
)
{
aCache
-
>
mPercentageBasis
.
emplace
(
aState
.
PercentageBasisFor
(
aAxis
aGridItem
)
)
;
}
MOZ_ASSERT
(
aGridItem
.
mBaselineOffset
[
aAxis
]
>
=
0
"
baseline
offset
should
be
non
-
negative
at
this
point
"
)
;
MOZ_ASSERT
(
(
aGridItem
.
mState
[
aAxis
]
&
ItemState
:
:
eIsBaselineAligned
)
|
|
aGridItem
.
mBaselineOffset
[
aAxis
]
=
=
nscoord
(
0
)
"
baseline
offset
should
be
zero
when
not
baseline
-
aligned
"
)
;
nscoord
sz
=
aGridItem
.
mBaselineOffset
[
aAxis
]
+
nsLayoutUtils
:
:
MinSizeContributionForAxis
(
axis
aRC
child
nsLayoutUtils
:
:
MIN_ISIZE
*
aCache
-
>
mPercentageBasis
)
;
const
StyleSize
&
style
=
axis
=
=
eAxisHorizontal
?
stylePos
-
>
mMinWidth
:
stylePos
-
>
mMinHeight
;
const
bool
inInlineAxis
=
axis
=
=
ourInlineAxis
;
const
bool
isAuto
=
style
.
IsAuto
(
)
|
|
(
!
inInlineAxis
&
&
style
.
IsExtremumLength
(
)
)
;
if
(
(
inInlineAxis
&
&
style
.
IsExtremumLength
(
)
)
|
|
(
isAuto
&
&
child
-
>
StyleDisplay
(
)
-
>
mOverflowX
=
=
StyleOverflow
:
:
Visible
)
)
{
MOZ_ASSERT
(
isAuto
|
|
sz
=
=
NS_UNCONSTRAINEDSIZE
)
;
sz
=
std
:
:
min
(
sz
ContentContribution
(
aGridItem
aState
aRC
aCBWM
aAxis
aCache
-
>
mPercentageBasis
nsLayoutUtils
:
:
MIN_ISIZE
aCache
-
>
mMinSizeClamp
nsLayoutUtils
:
:
MIN_INTRINSIC_ISIZE
)
)
;
}
aCache
-
>
mMinSize
.
emplace
(
sz
)
;
return
sz
;
}
void
nsGridContainerFrame
:
:
Tracks
:
:
CalculateSizes
(
GridReflowInput
&
aState
nsTArray
<
GridItemInfo
>
&
aGridItems
const
TrackSizingFunctions
&
aFunctions
nscoord
aContentBoxSize
LineRange
GridArea
:
:
*
aRange
SizingConstraint
aConstraint
)
{
nscoord
percentageBasis
=
aContentBoxSize
;
if
(
percentageBasis
=
=
NS_UNCONSTRAINEDSIZE
)
{
percentageBasis
=
0
;
}
InitializeItemBaselines
(
aState
aGridItems
)
;
ResolveIntrinsicSize
(
aState
aGridItems
aFunctions
aRange
percentageBasis
aConstraint
)
;
if
(
aConstraint
!
=
SizingConstraint
:
:
MinContent
)
{
nscoord
freeSpace
=
aContentBoxSize
;
if
(
freeSpace
!
=
NS_UNCONSTRAINEDSIZE
)
{
freeSpace
-
=
SumOfGridGaps
(
)
;
}
DistributeFreeSpace
(
freeSpace
)
;
StretchFlexibleTracks
(
aState
aGridItems
aFunctions
freeSpace
)
;
}
}
TrackSize
:
:
StateBits
nsGridContainerFrame
:
:
Tracks
:
:
StateBitsForRange
(
const
LineRange
&
aRange
)
const
{
MOZ_ASSERT
(
!
aRange
.
IsAuto
(
)
"
must
have
a
definite
range
"
)
;
TrackSize
:
:
StateBits
state
=
TrackSize
:
:
StateBits
(
0
)
;
for
(
auto
i
:
aRange
.
Range
(
)
)
{
state
|
=
mSizes
[
i
]
.
mState
;
}
return
state
;
}
static
void
AddSubgridContribution
(
TrackSize
&
aSize
nscoord
aMarginBorderPadding
)
{
if
(
aSize
.
mState
&
TrackSize
:
:
eIntrinsicMinSizing
)
{
aSize
.
mBase
=
std
:
:
max
(
aSize
.
mBase
aMarginBorderPadding
)
;
aSize
.
mLimit
=
std
:
:
max
(
aSize
.
mLimit
aSize
.
mBase
)
;
}
if
(
aSize
.
mState
&
(
TrackSize
:
:
eIntrinsicMaxSizing
|
TrackSize
:
:
eFitContent
)
)
{
aSize
.
mLimit
=
std
:
:
max
(
aSize
.
mLimit
aMarginBorderPadding
)
;
}
}
bool
nsGridContainerFrame
:
:
Tracks
:
:
ResolveIntrinsicSizeStep1
(
GridReflowInput
&
aState
const
TrackSizingFunctions
&
aFunctions
nscoord
aPercentageBasis
SizingConstraint
aConstraint
const
LineRange
&
aRange
const
GridItemInfo
&
aGridItem
)
{
CachedIntrinsicSizes
cache
;
TrackSize
&
sz
=
mSizes
[
aRange
.
mStart
]
;
WritingMode
wm
=
aState
.
mWM
;
gfxContext
*
rc
=
&
aState
.
mRenderingContext
;
if
(
sz
.
mState
&
TrackSize
:
:
eAutoMinSizing
)
{
nscoord
s
;
if
(
aGridItem
.
ShouldApplyAutoMinSize
(
wm
mAxis
aPercentageBasis
)
)
{
aGridItem
.
mState
[
mAxis
]
|
=
ItemState
:
:
eApplyAutoMinSize
;
if
(
TrackSize
:
:
IsDefiniteMaxSizing
(
sz
.
mState
)
)
{
auto
maxCoord
=
aFunctions
.
MaxSizingFor
(
aRange
.
mStart
)
;
cache
.
mMinSizeClamp
=
maxCoord
.
ComputeCoordPercentCalc
(
aPercentageBasis
)
;
aGridItem
.
mState
[
mAxis
]
|
=
ItemState
:
:
eClampMarginBoxMinSize
;
}
if
(
aConstraint
!
=
SizingConstraint
:
:
MaxContent
)
{
s
=
MinContentContribution
(
aGridItem
aState
rc
wm
mAxis
&
cache
)
;
}
else
{
s
=
MaxContentContribution
(
aGridItem
aState
rc
wm
mAxis
&
cache
)
;
}
}
else
{
s
=
MinSize
(
aGridItem
aState
rc
wm
mAxis
&
cache
)
;
}
sz
.
mBase
=
std
:
:
max
(
sz
.
mBase
s
)
;
}
else
if
(
sz
.
mState
&
TrackSize
:
:
eMinContentMinSizing
)
{
auto
s
=
MinContentContribution
(
aGridItem
aState
rc
wm
mAxis
&
cache
)
;
sz
.
mBase
=
std
:
:
max
(
sz
.
mBase
s
)
;
}
else
if
(
sz
.
mState
&
TrackSize
:
:
eMaxContentMinSizing
)
{
auto
s
=
MaxContentContribution
(
aGridItem
aState
rc
wm
mAxis
&
cache
)
;
sz
.
mBase
=
std
:
:
max
(
sz
.
mBase
s
)
;
}
if
(
sz
.
mState
&
TrackSize
:
:
eMinContentMaxSizing
)
{
auto
s
=
MinContentContribution
(
aGridItem
aState
rc
wm
mAxis
&
cache
)
;
if
(
sz
.
mLimit
=
=
NS_UNCONSTRAINEDSIZE
)
{
sz
.
mLimit
=
s
;
}
else
{
sz
.
mLimit
=
std
:
:
max
(
sz
.
mLimit
s
)
;
}
}
else
if
(
sz
.
mState
&
(
TrackSize
:
:
eAutoMaxSizing
|
TrackSize
:
:
eMaxContentMaxSizing
)
)
{
auto
s
=
MaxContentContribution
(
aGridItem
aState
rc
wm
mAxis
&
cache
)
;
if
(
sz
.
mLimit
=
=
NS_UNCONSTRAINEDSIZE
)
{
sz
.
mLimit
=
s
;
}
else
{
sz
.
mLimit
=
std
:
:
max
(
sz
.
mLimit
s
)
;
}
if
(
MOZ_UNLIKELY
(
sz
.
mState
&
TrackSize
:
:
eFitContent
)
)
{
auto
maxCoord
=
aFunctions
.
MaxSizingFor
(
aRange
.
mStart
)
;
nscoord
fitContentClamp
=
maxCoord
.
ComputeCoordPercentCalc
(
aPercentageBasis
)
;
sz
.
mLimit
=
std
:
:
min
(
sz
.
mLimit
fitContentClamp
)
;
}
}
if
(
sz
.
mLimit
<
sz
.
mBase
)
{
sz
.
mLimit
=
sz
.
mBase
;
}
return
sz
.
mState
&
TrackSize
:
:
eFlexMaxSizing
;
}
void
nsGridContainerFrame
:
:
Tracks
:
:
CalculateItemBaselines
(
nsTArray
<
ItemBaselineData
>
&
aBaselineItems
BaselineSharingGroup
aBaselineGroup
)
{
if
(
aBaselineItems
.
IsEmpty
(
)
)
{
return
;
}
std
:
:
sort
(
aBaselineItems
.
begin
(
)
aBaselineItems
.
end
(
)
ItemBaselineData
:
:
IsBaselineTrackLessThan
)
;
MOZ_ASSERT
(
mSizes
.
Length
(
)
>
0
"
having
an
item
implies
at
least
one
track
"
)
;
const
uint32_t
lastTrack
=
mSizes
.
Length
(
)
-
1
;
nscoord
maxBaseline
=
0
;
nscoord
maxDescent
=
0
;
uint32_t
currentTrack
=
kAutoLine
;
uint32_t
trackStartIndex
=
0
;
for
(
uint32_t
i
=
0
len
=
aBaselineItems
.
Length
(
)
;
true
;
+
+
i
)
{
if
(
i
!
=
len
)
{
const
ItemBaselineData
&
item
=
aBaselineItems
[
i
]
;
if
(
currentTrack
=
=
item
.
mBaselineTrack
)
{
maxBaseline
=
std
:
:
max
(
maxBaseline
item
.
mBaseline
)
;
maxDescent
=
std
:
:
max
(
maxDescent
item
.
mSize
-
item
.
mBaseline
)
;
continue
;
}
}
for
(
uint32_t
j
=
trackStartIndex
;
j
<
i
;
+
+
j
)
{
const
ItemBaselineData
&
item
=
aBaselineItems
[
j
]
;
item
.
mGridItem
-
>
mBaselineOffset
[
mAxis
]
=
maxBaseline
-
item
.
mBaseline
;
MOZ_ASSERT
(
item
.
mGridItem
-
>
mBaselineOffset
[
mAxis
]
>
=
0
)
;
}
if
(
i
!
=
0
)
{
mSizes
[
currentTrack
]
.
mBaselineSubtreeSize
[
aBaselineGroup
]
=
maxBaseline
+
maxDescent
;
if
(
currentTrack
=
=
0
&
&
aBaselineGroup
=
=
BaselineSharingGroup
:
:
First
)
{
mBaseline
[
aBaselineGroup
]
=
maxBaseline
;
}
if
(
currentTrack
=
=
lastTrack
&
&
aBaselineGroup
=
=
BaselineSharingGroup
:
:
Last
)
{
mBaseline
[
aBaselineGroup
]
=
maxBaseline
;
}
}
if
(
i
=
=
len
)
{
break
;
}
const
ItemBaselineData
&
item
=
aBaselineItems
[
i
]
;
currentTrack
=
item
.
mBaselineTrack
;
trackStartIndex
=
i
;
maxBaseline
=
item
.
mBaseline
;
maxDescent
=
item
.
mSize
-
item
.
mBaseline
;
}
}
void
nsGridContainerFrame
:
:
Tracks
:
:
InitializeItemBaselines
(
GridReflowInput
&
aState
nsTArray
<
GridItemInfo
>
&
aGridItems
)
{
if
(
aState
.
mFrame
-
>
IsSubgrid
(
mAxis
)
)
{
return
;
}
nsTArray
<
ItemBaselineData
>
firstBaselineItems
;
nsTArray
<
ItemBaselineData
>
lastBaselineItems
;
WritingMode
wm
=
aState
.
mWM
;
ComputedStyle
*
containerSC
=
aState
.
mFrame
-
>
Style
(
)
;
for
(
GridItemInfo
&
gridItem
:
aGridItems
)
{
if
(
gridItem
.
IsSubgrid
(
mAxis
)
)
{
continue
;
}
nsIFrame
*
child
=
gridItem
.
mFrame
;
uint32_t
baselineTrack
=
kAutoLine
;
auto
state
=
ItemState
(
0
)
;
auto
childWM
=
child
-
>
GetWritingMode
(
)
;
const
bool
isOrthogonal
=
wm
.
IsOrthogonalTo
(
childWM
)
;
const
bool
isInlineAxis
=
mAxis
=
=
eLogicalAxisInline
;
const
bool
itemHasBaselineParallelToTrack
=
isInlineAxis
=
=
isOrthogonal
;
if
(
itemHasBaselineParallelToTrack
)
{
auto
selfAlignment
=
isOrthogonal
?
child
-
>
StylePosition
(
)
-
>
UsedJustifySelf
(
containerSC
)
:
child
-
>
StylePosition
(
)
-
>
UsedAlignSelf
(
containerSC
)
;
selfAlignment
&
=
~
NS_STYLE_ALIGN_FLAG_BITS
;
if
(
selfAlignment
=
=
NS_STYLE_ALIGN_BASELINE
)
{
state
|
=
ItemState
:
:
eFirstBaseline
|
ItemState
:
:
eSelfBaseline
;
const
GridArea
&
area
=
gridItem
.
mArea
;
baselineTrack
=
isInlineAxis
?
area
.
mCols
.
mStart
:
area
.
mRows
.
mStart
;
}
else
if
(
selfAlignment
=
=
NS_STYLE_ALIGN_LAST_BASELINE
)
{
state
|
=
ItemState
:
:
eLastBaseline
|
ItemState
:
:
eSelfBaseline
;
const
GridArea
&
area
=
gridItem
.
mArea
;
baselineTrack
=
(
isInlineAxis
?
area
.
mCols
.
mEnd
:
area
.
mRows
.
mEnd
)
-
1
;
}
auto
alignContent
=
child
-
>
StylePosition
(
)
-
>
mAlignContent
;
alignContent
&
=
~
NS_STYLE_ALIGN_FLAG_BITS
;
if
(
alignContent
=
=
NS_STYLE_ALIGN_BASELINE
|
|
alignContent
=
=
NS_STYLE_ALIGN_LAST_BASELINE
)
{
const
auto
selfAlignEdge
=
alignContent
=
=
NS_STYLE_ALIGN_BASELINE
?
NS_STYLE_ALIGN_SELF_START
:
NS_STYLE_ALIGN_SELF_END
;
bool
validCombo
=
selfAlignment
=
=
NS_STYLE_ALIGN_NORMAL
|
|
selfAlignment
=
=
NS_STYLE_ALIGN_STRETCH
|
|
selfAlignment
=
=
selfAlignEdge
;
if
(
!
validCombo
)
{
LogicalAxis
alignAxis
=
GetOrthogonalAxis
(
mAxis
)
;
bool
sameSide
=
wm
.
ParallelAxisStartsOnSameSide
(
alignAxis
childWM
)
;
switch
(
selfAlignment
)
{
case
NS_STYLE_ALIGN_LEFT
:
selfAlignment
=
!
isInlineAxis
|
|
wm
.
IsBidiLTR
(
)
?
NS_STYLE_ALIGN_START
:
NS_STYLE_ALIGN_END
;
break
;
case
NS_STYLE_ALIGN_RIGHT
:
selfAlignment
=
isInlineAxis
&
&
wm
.
IsBidiLTR
(
)
?
NS_STYLE_ALIGN_END
:
NS_STYLE_ALIGN_START
;
break
;
}
switch
(
selfAlignment
)
{
case
NS_STYLE_ALIGN_START
:
case
NS_STYLE_ALIGN_FLEX_START
:
validCombo
=
sameSide
=
=
(
alignContent
=
=
NS_STYLE_ALIGN_BASELINE
)
;
break
;
case
NS_STYLE_ALIGN_END
:
case
NS_STYLE_ALIGN_FLEX_END
:
validCombo
=
sameSide
=
=
(
alignContent
=
=
NS_STYLE_ALIGN_LAST_BASELINE
)
;
break
;
}
}
if
(
validCombo
)
{
const
GridArea
&
area
=
gridItem
.
mArea
;
if
(
alignContent
=
=
NS_STYLE_ALIGN_BASELINE
)
{
state
|
=
ItemState
:
:
eFirstBaseline
|
ItemState
:
:
eContentBaseline
;
baselineTrack
=
isInlineAxis
?
area
.
mCols
.
mStart
:
area
.
mRows
.
mStart
;
}
else
if
(
alignContent
=
=
NS_STYLE_ALIGN_LAST_BASELINE
)
{
state
|
=
ItemState
:
:
eLastBaseline
|
ItemState
:
:
eContentBaseline
;
baselineTrack
=
(
isInlineAxis
?
area
.
mCols
.
mEnd
:
area
.
mRows
.
mEnd
)
-
1
;
}
}
}
}
if
(
state
&
ItemState
:
:
eIsBaselineAligned
)
{
LogicalSize
avail
(
childWM
INFINITE_ISIZE_COORD
NS_UNCONSTRAINEDSIZE
)
;
auto
*
rc
=
&
aState
.
mRenderingContext
;
LogicalSize
cbSize
(
childWM
0
0
)
;
:
:
MeasuringReflow
(
child
aState
.
mReflowInput
rc
avail
cbSize
)
;
nscoord
baseline
;
nsGridContainerFrame
*
grid
=
do_QueryFrame
(
child
)
;
if
(
state
&
ItemState
:
:
eFirstBaseline
)
{
if
(
grid
)
{
if
(
isOrthogonal
=
=
isInlineAxis
)
{
grid
-
>
GetBBaseline
(
BaselineSharingGroup
:
:
First
&
baseline
)
;
}
else
{
grid
-
>
GetIBaseline
(
BaselineSharingGroup
:
:
First
&
baseline
)
;
}
}
if
(
grid
|
|
nsLayoutUtils
:
:
GetFirstLineBaseline
(
wm
child
&
baseline
)
)
{
NS_ASSERTION
(
baseline
!
=
NS_INTRINSIC_ISIZE_UNKNOWN
"
about
to
use
an
unknown
baseline
"
)
;
auto
frameSize
=
isInlineAxis
?
child
-
>
ISize
(
wm
)
:
child
-
>
BSize
(
wm
)
;
auto
m
=
child
-
>
GetLogicalUsedMargin
(
wm
)
;
baseline
+
=
isInlineAxis
?
m
.
IStart
(
wm
)
:
m
.
BStart
(
wm
)
;
auto
alignSize
=
frameSize
+
(
isInlineAxis
?
m
.
IStartEnd
(
wm
)
:
m
.
BStartEnd
(
wm
)
)
;
firstBaselineItems
.
AppendElement
(
ItemBaselineData
(
{
baselineTrack
baseline
alignSize
&
gridItem
}
)
)
;
}
else
{
state
&
=
~
ItemState
:
:
eAllBaselineBits
;
}
}
else
{
if
(
grid
)
{
if
(
isOrthogonal
=
=
isInlineAxis
)
{
grid
-
>
GetBBaseline
(
BaselineSharingGroup
:
:
Last
&
baseline
)
;
}
else
{
grid
-
>
GetIBaseline
(
BaselineSharingGroup
:
:
Last
&
baseline
)
;
}
}
if
(
grid
|
|
nsLayoutUtils
:
:
GetLastLineBaseline
(
wm
child
&
baseline
)
)
{
NS_ASSERTION
(
baseline
!
=
NS_INTRINSIC_ISIZE_UNKNOWN
"
about
to
use
an
unknown
baseline
"
)
;
auto
frameSize
=
isInlineAxis
?
child
-
>
ISize
(
wm
)
:
child
-
>
BSize
(
wm
)
;
auto
m
=
child
-
>
GetLogicalUsedMargin
(
wm
)
;
if
(
!
grid
)
{
baseline
=
frameSize
-
baseline
;
}
auto
descent
=
baseline
+
(
isInlineAxis
?
m
.
IEnd
(
wm
)
:
m
.
BEnd
(
wm
)
)
;
auto
alignSize
=
frameSize
+
(
isInlineAxis
?
m
.
IStartEnd
(
wm
)
:
m
.
BStartEnd
(
wm
)
)
;
lastBaselineItems
.
AppendElement
(
ItemBaselineData
(
{
baselineTrack
descent
alignSize
&
gridItem
}
)
)
;
}
else
{
state
&
=
~
ItemState
:
:
eAllBaselineBits
;
}
}
}
MOZ_ASSERT
(
(
state
&
(
ItemState
:
:
eFirstBaseline
|
ItemState
:
:
eLastBaseline
)
)
!
=
(
ItemState
:
:
eFirstBaseline
|
ItemState
:
:
eLastBaseline
)
"
first
/
last
baseline
bits
are
mutually
exclusive
"
)
;
MOZ_ASSERT
(
(
state
&
(
ItemState
:
:
eSelfBaseline
|
ItemState
:
:
eContentBaseline
)
)
!
=
(
ItemState
:
:
eSelfBaseline
|
ItemState
:
:
eContentBaseline
)
"
*
-
self
and
*
-
content
baseline
bits
are
mutually
exclusive
"
)
;
MOZ_ASSERT
(
!
(
state
&
(
ItemState
:
:
eFirstBaseline
|
ItemState
:
:
eLastBaseline
)
)
=
=
!
(
state
&
(
ItemState
:
:
eSelfBaseline
|
ItemState
:
:
eContentBaseline
)
)
"
first
/
last
bit
requires
self
/
content
bit
and
vice
versa
"
)
;
gridItem
.
mState
[
mAxis
]
|
=
state
;
gridItem
.
mBaselineOffset
[
mAxis
]
=
nscoord
(
0
)
;
}
if
(
firstBaselineItems
.
IsEmpty
(
)
&
&
lastBaselineItems
.
IsEmpty
(
)
)
{
return
;
}
mBaselineSubtreeAlign
[
BaselineSharingGroup
:
:
First
]
=
NS_STYLE_ALIGN_START
;
mBaselineSubtreeAlign
[
BaselineSharingGroup
:
:
Last
]
=
NS_STYLE_ALIGN_END
;
CalculateItemBaselines
(
firstBaselineItems
BaselineSharingGroup
:
:
First
)
;
CalculateItemBaselines
(
lastBaselineItems
BaselineSharingGroup
:
:
Last
)
;
}
void
nsGridContainerFrame
:
:
Tracks
:
:
AlignBaselineSubtree
(
const
GridItemInfo
&
aGridItem
)
const
{
auto
state
=
aGridItem
.
mState
[
mAxis
]
;
if
(
!
(
state
&
ItemState
:
:
eIsBaselineAligned
)
)
{
return
;
}
const
GridArea
&
area
=
aGridItem
.
mArea
;
int32_t
baselineTrack
;
const
bool
isFirstBaseline
=
state
&
ItemState
:
:
eFirstBaseline
;
if
(
isFirstBaseline
)
{
baselineTrack
=
mAxis
=
=
eLogicalAxisBlock
?
area
.
mRows
.
mStart
:
area
.
mCols
.
mStart
;
}
else
{
baselineTrack
=
(
mAxis
=
=
eLogicalAxisBlock
?
area
.
mRows
.
mEnd
:
area
.
mCols
.
mEnd
)
-
1
;
}
const
TrackSize
&
sz
=
mSizes
[
baselineTrack
]
;
auto
baselineGroup
=
isFirstBaseline
?
BaselineSharingGroup
:
:
First
:
BaselineSharingGroup
:
:
Last
;
nscoord
delta
=
sz
.
mBase
-
sz
.
mBaselineSubtreeSize
[
baselineGroup
]
;
const
auto
subtreeAlign
=
mBaselineSubtreeAlign
[
baselineGroup
]
;
switch
(
subtreeAlign
)
{
case
NS_STYLE_ALIGN_START
:
if
(
state
&
ItemState
:
:
eLastBaseline
)
{
aGridItem
.
mBaselineOffset
[
mAxis
]
+
=
delta
;
}
break
;
case
NS_STYLE_ALIGN_END
:
if
(
isFirstBaseline
)
{
aGridItem
.
mBaselineOffset
[
mAxis
]
+
=
delta
;
}
break
;
case
NS_STYLE_ALIGN_CENTER
:
aGridItem
.
mBaselineOffset
[
mAxis
]
+
=
delta
/
2
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
baseline
subtree
alignment
"
)
;
}
}
template
<
nsGridContainerFrame
:
:
Tracks
:
:
TrackSizingPhase
phase
>
bool
nsGridContainerFrame
:
:
Tracks
:
:
GrowSizeForSpanningItems
(
nsTArray
<
Step2ItemData
>
:
:
iterator
aIter
const
nsTArray
<
Step2ItemData
>
:
:
iterator
aIterEnd
nsTArray
<
uint32_t
>
&
aTracks
nsTArray
<
TrackSize
>
&
aPlan
nsTArray
<
TrackSize
>
&
aItemPlan
TrackSize
:
:
StateBits
aSelector
const
FitContentClamper
&
aFitContentClamper
bool
aNeedInfinitelyGrowableFlag
)
{
constexpr
bool
isMaxSizingPhase
=
phase
=
=
TrackSizingPhase
:
:
IntrinsicMaximums
|
|
phase
=
=
TrackSizingPhase
:
:
MaxContentMaximums
;
bool
needToUpdateSizes
=
false
;
InitializePlan
<
phase
>
(
aPlan
)
;
for
(
;
aIter
!
=
aIterEnd
;
+
+
aIter
)
{
const
Step2ItemData
&
item
=
*
aIter
;
if
(
!
(
item
.
mState
&
aSelector
)
)
{
continue
;
}
if
(
isMaxSizingPhase
)
{
for
(
auto
i
:
item
.
mLineRange
.
Range
(
)
)
{
aPlan
[
i
]
.
mState
|
=
TrackSize
:
:
eModified
;
}
}
nscoord
space
=
item
.
SizeContributionForPhase
<
phase
>
(
)
;
if
(
space
<
=
0
)
{
continue
;
}
aTracks
.
ClearAndRetainStorage
(
)
;
space
=
CollectGrowable
<
phase
>
(
space
item
.
mLineRange
aSelector
aTracks
)
;
if
(
space
>
0
)
{
DistributeToTrackSizes
<
phase
>
(
space
aPlan
aItemPlan
aTracks
aSelector
aFitContentClamper
)
;
needToUpdateSizes
=
true
;
}
}
if
(
isMaxSizingPhase
)
{
needToUpdateSizes
=
true
;
}
if
(
needToUpdateSizes
)
{
CopyPlanToSize
<
phase
>
(
aPlan
aNeedInfinitelyGrowableFlag
)
;
}
return
needToUpdateSizes
;
}
void
nsGridContainerFrame
:
:
Tracks
:
:
ResolveIntrinsicSize
(
GridReflowInput
&
aState
nsTArray
<
GridItemInfo
>
&
aGridItems
const
TrackSizingFunctions
&
aFunctions
LineRange
GridArea
:
:
*
aRange
nscoord
aPercentageBasis
SizingConstraint
aConstraint
)
{
struct
PerSpanData
{
PerSpanData
(
)
:
mItemCountWithSameSpan
(
0
)
mStateBits
(
TrackSize
:
:
StateBits
(
0
)
)
{
}
uint32_t
mItemCountWithSameSpan
;
TrackSize
:
:
StateBits
mStateBits
;
}
;
AutoTArray
<
PerSpanData
16
>
perSpanData
;
nsTArray
<
Step2ItemData
>
step2Items
;
gfxContext
*
rc
=
&
aState
.
mRenderingContext
;
WritingMode
wm
=
aState
.
mWM
;
uint32_t
maxSpan
=
0
;
const
auto
contentBasedMinSelector
=
aConstraint
=
=
SizingConstraint
:
:
MinContent
?
TrackSize
:
:
eIntrinsicMinSizing
:
TrackSize
:
:
eMinOrMaxContentMinSizing
;
const
auto
maxContentMinSelector
=
aConstraint
=
=
SizingConstraint
:
:
MaxContent
?
(
TrackSize
:
:
eMaxContentMinSizing
|
TrackSize
:
:
eAutoMinSizing
)
:
TrackSize
:
:
eMaxContentMinSizing
;
for
(
auto
&
gridItem
:
aGridItems
)
{
MOZ_ASSERT
(
!
(
gridItem
.
mState
[
mAxis
]
&
(
ItemState
:
:
eApplyAutoMinSize
|
ItemState
:
:
eIsFlexing
|
ItemState
:
:
eClampMarginBoxMinSize
)
)
"
Why
are
any
of
these
bits
set
already
?
"
)
;
const
GridArea
&
area
=
gridItem
.
mArea
;
const
LineRange
&
lineRange
=
area
.
*
aRange
;
uint32_t
span
=
lineRange
.
Extent
(
)
;
if
(
MOZ_UNLIKELY
(
gridItem
.
mState
[
mAxis
]
&
ItemState
:
:
eIsSubgrid
)
)
{
auto
itemWM
=
gridItem
.
mFrame
-
>
GetWritingMode
(
)
;
auto
percentageBasis
=
aState
.
PercentageBasisFor
(
mAxis
gridItem
)
;
if
(
percentageBasis
.
ISize
(
itemWM
)
=
=
NS_UNCONSTRAINEDSIZE
)
{
percentageBasis
.
ISize
(
itemWM
)
=
nscoord
(
0
)
;
}
if
(
percentageBasis
.
BSize
(
itemWM
)
=
=
NS_UNCONSTRAINEDSIZE
)
{
percentageBasis
.
BSize
(
itemWM
)
=
nscoord
(
0
)
;
}
auto
*
subgrid
=
SubgridComputeMarginBorderPadding
(
gridItem
percentageBasis
)
;
LogicalMargin
mbp
=
SubgridAccumulatedMarginBorderPadding
(
gridItem
.
SubgridFrame
(
)
subgrid
wm
mAxis
)
;
if
(
span
=
=
1
)
{
AddSubgridContribution
(
mSizes
[
lineRange
.
mStart
]
mbp
.
StartEnd
(
mAxis
wm
)
)
;
}
else
{
AddSubgridContribution
(
mSizes
[
lineRange
.
mStart
]
mbp
.
Start
(
mAxis
wm
)
)
;
AddSubgridContribution
(
mSizes
[
lineRange
.
mEnd
-
1
]
mbp
.
End
(
mAxis
wm
)
)
;
}
continue
;
}
if
(
span
=
=
1
)
{
if
(
ResolveIntrinsicSizeStep1
(
aState
aFunctions
aPercentageBasis
aConstraint
lineRange
gridItem
)
)
{
gridItem
.
mState
[
mAxis
]
|
=
ItemState
:
:
eIsFlexing
;
}
}
else
{
TrackSize
:
:
StateBits
state
=
StateBitsForRange
(
lineRange
)
;
if
(
(
state
&
TrackSize
:
:
eAutoMinSizing
)
&
&
gridItem
.
ShouldApplyAutoMinSize
(
wm
mAxis
aPercentageBasis
)
)
{
gridItem
.
mState
[
mAxis
]
|
=
ItemState
:
:
eApplyAutoMinSize
;
}
if
(
state
&
TrackSize
:
:
eFlexMaxSizing
)
{
gridItem
.
mState
[
mAxis
]
|
=
ItemState
:
:
eIsFlexing
;
}
else
if
(
state
&
(
TrackSize
:
:
eIntrinsicMinSizing
|
TrackSize
:
:
eIntrinsicMaxSizing
)
)
{
maxSpan
=
std
:
:
max
(
maxSpan
span
)
;
if
(
span
>
=
perSpanData
.
Length
(
)
)
{
perSpanData
.
SetLength
(
2
*
span
)
;
}
perSpanData
[
span
]
.
mItemCountWithSameSpan
+
+
;
perSpanData
[
span
]
.
mStateBits
|
=
state
;
CachedIntrinsicSizes
cache
;
if
(
TrackSize
:
:
IsDefiniteMaxSizing
(
state
)
&
&
(
gridItem
.
mState
[
mAxis
]
&
ItemState
:
:
eApplyAutoMinSize
)
)
{
nscoord
minSizeClamp
=
0
;
for
(
auto
i
:
lineRange
.
Range
(
)
)
{
auto
maxCoord
=
aFunctions
.
MaxSizingFor
(
i
)
;
minSizeClamp
+
=
maxCoord
.
ComputeCoordPercentCalc
(
aPercentageBasis
)
;
}
minSizeClamp
+
=
mGridGap
*
(
span
-
1
)
;
cache
.
mMinSizeClamp
=
minSizeClamp
;
gridItem
.
mState
[
mAxis
]
|
=
ItemState
:
:
eClampMarginBoxMinSize
;
}
nscoord
minSize
=
0
;
if
(
state
&
(
TrackSize
:
:
eIntrinsicMinSizing
|
TrackSize
:
:
eIntrinsicMaxSizing
)
)
{
minSize
=
MinSize
(
gridItem
aState
rc
wm
mAxis
&
cache
)
;
}
nscoord
minContent
=
0
;
if
(
state
&
contentBasedMinSelector
)
{
minContent
=
MinContentContribution
(
gridItem
aState
rc
wm
mAxis
&
cache
)
;
}
nscoord
maxContent
=
0
;
if
(
state
&
(
maxContentMinSelector
|
TrackSize
:
:
eAutoOrMaxContentMaxSizing
)
)
{
maxContent
=
MaxContentContribution
(
gridItem
aState
rc
wm
mAxis
&
cache
)
;
}
step2Items
.
AppendElement
(
Step2ItemData
(
{
span
state
lineRange
minSize
minContent
maxContent
gridItem
.
mFrame
}
)
)
;
}
}
MOZ_ASSERT
(
!
(
gridItem
.
mState
[
mAxis
]
&
ItemState
:
:
eClampMarginBoxMinSize
)
|
|
(
gridItem
.
mState
[
mAxis
]
&
ItemState
:
:
eApplyAutoMinSize
)
"
clamping
only
applies
to
Automatic
Minimum
Size
"
)
;
}
if
(
maxSpan
)
{
auto
fitContentClamper
=
[
&
aFunctions
aPercentageBasis
]
(
uint32_t
aTrack
nscoord
aMinSize
nscoord
*
aSize
)
{
nscoord
fitContentLimit
=
:
:
ResolveToDefiniteSize
(
aFunctions
.
MaxSizingFor
(
aTrack
)
aPercentageBasis
)
;
if
(
*
aSize
>
fitContentLimit
)
{
*
aSize
=
std
:
:
max
(
aMinSize
fitContentLimit
)
;
return
true
;
}
return
false
;
}
;
std
:
:
sort
(
step2Items
.
begin
(
)
step2Items
.
end
(
)
Step2ItemData
:
:
IsSpanLessThan
)
;
nsTArray
<
uint32_t
>
tracks
(
maxSpan
)
;
nsTArray
<
TrackSize
>
plan
(
mSizes
.
Length
(
)
)
;
plan
.
SetLength
(
mSizes
.
Length
(
)
)
;
nsTArray
<
TrackSize
>
itemPlan
(
mSizes
.
Length
(
)
)
;
itemPlan
.
SetLength
(
mSizes
.
Length
(
)
)
;
auto
spanGroupStart
=
step2Items
.
begin
(
)
;
auto
spanGroupEnd
=
spanGroupStart
;
const
auto
end
=
step2Items
.
end
(
)
;
for
(
;
spanGroupStart
!
=
end
;
spanGroupStart
=
spanGroupEnd
)
{
const
uint32_t
span
=
spanGroupStart
-
>
mSpan
;
spanGroupEnd
=
spanGroupStart
+
perSpanData
[
span
]
.
mItemCountWithSameSpan
;
TrackSize
:
:
StateBits
stateBitsForSpan
=
perSpanData
[
span
]
.
mStateBits
;
bool
updatedBase
=
false
;
TrackSize
:
:
StateBits
selector
(
TrackSize
:
:
eIntrinsicMinSizing
)
;
if
(
stateBitsForSpan
&
selector
)
{
updatedBase
=
GrowSizeForSpanningItems
<
TrackSizingPhase
:
:
IntrinsicMinimums
>
(
spanGroupStart
spanGroupEnd
tracks
plan
itemPlan
selector
)
;
}
selector
=
contentBasedMinSelector
;
if
(
stateBitsForSpan
&
selector
)
{
updatedBase
|
=
GrowSizeForSpanningItems
<
TrackSizingPhase
:
:
ContentBasedMinimums
>
(
spanGroupStart
spanGroupEnd
tracks
plan
itemPlan
selector
)
;
}
selector
=
maxContentMinSelector
;
if
(
stateBitsForSpan
&
selector
)
{
updatedBase
|
=
GrowSizeForSpanningItems
<
TrackSizingPhase
:
:
MaxContentMinimums
>
(
spanGroupStart
spanGroupEnd
tracks
plan
itemPlan
selector
)
;
}
if
(
updatedBase
)
{
for
(
TrackSize
&
sz
:
mSizes
)
{
if
(
sz
.
mBase
>
sz
.
mLimit
)
{
sz
.
mLimit
=
sz
.
mBase
;
}
}
}
selector
=
TrackSize
:
:
eIntrinsicMaxSizing
;
if
(
stateBitsForSpan
&
selector
)
{
const
bool
willRunStep2_6
=
stateBitsForSpan
&
TrackSize
:
:
eAutoOrMaxContentMaxSizing
;
GrowSizeForSpanningItems
<
TrackSizingPhase
:
:
IntrinsicMaximums
>
(
spanGroupStart
spanGroupEnd
tracks
plan
itemPlan
selector
fitContentClamper
willRunStep2_6
)
;
if
(
willRunStep2_6
)
{
selector
=
TrackSize
:
:
eAutoOrMaxContentMaxSizing
;
GrowSizeForSpanningItems
<
TrackSizingPhase
:
:
MaxContentMaximums
>
(
spanGroupStart
spanGroupEnd
tracks
plan
itemPlan
selector
fitContentClamper
)
;
}
}
}
}
for
(
TrackSize
&
sz
:
mSizes
)
{
if
(
sz
.
mLimit
=
=
NS_UNCONSTRAINEDSIZE
)
{
sz
.
mLimit
=
sz
.
mBase
;
}
}
}
float
nsGridContainerFrame
:
:
Tracks
:
:
FindFrUnitSize
(
const
LineRange
&
aRange
const
nsTArray
<
uint32_t
>
&
aFlexTracks
const
TrackSizingFunctions
&
aFunctions
nscoord
aSpaceToFill
)
const
{
MOZ_ASSERT
(
aSpaceToFill
>
0
&
&
!
aFlexTracks
.
IsEmpty
(
)
)
;
float
flexFactorSum
=
0
.
0f
;
nscoord
leftOverSpace
=
aSpaceToFill
;
for
(
auto
i
:
aRange
.
Range
(
)
)
{
const
TrackSize
&
sz
=
mSizes
[
i
]
;
if
(
sz
.
mState
&
TrackSize
:
:
eFlexMaxSizing
)
{
flexFactorSum
+
=
aFunctions
.
MaxSizingFor
(
i
)
.
GetFlexFractionValue
(
)
;
}
else
{
leftOverSpace
-
=
sz
.
mBase
;
if
(
leftOverSpace
<
=
0
)
{
return
0
.
0f
;
}
}
}
bool
restart
;
float
hypotheticalFrSize
;
nsTArray
<
uint32_t
>
flexTracks
(
aFlexTracks
)
;
uint32_t
numFlexTracks
=
flexTracks
.
Length
(
)
;
do
{
restart
=
false
;
hypotheticalFrSize
=
leftOverSpace
/
std
:
:
max
(
flexFactorSum
1
.
0f
)
;
for
(
uint32_t
i
=
0
len
=
flexTracks
.
Length
(
)
;
i
<
len
;
+
+
i
)
{
uint32_t
track
=
flexTracks
[
i
]
;
if
(
track
=
=
kAutoLine
)
{
continue
;
}
float
flexFactor
=
aFunctions
.
MaxSizingFor
(
track
)
.
GetFlexFractionValue
(
)
;
const
nscoord
base
=
mSizes
[
track
]
.
mBase
;
if
(
flexFactor
*
hypotheticalFrSize
<
base
)
{
flexTracks
[
i
]
=
kAutoLine
;
flexFactorSum
-
=
flexFactor
;
leftOverSpace
-
=
base
;
-
-
numFlexTracks
;
if
(
numFlexTracks
=
=
0
|
|
leftOverSpace
<
=
0
)
{
return
0
.
0f
;
}
restart
=
true
;
}
}
}
while
(
restart
)
;
return
hypotheticalFrSize
;
}
float
nsGridContainerFrame
:
:
Tracks
:
:
FindUsedFlexFraction
(
GridReflowInput
&
aState
nsTArray
<
GridItemInfo
>
&
aGridItems
const
nsTArray
<
uint32_t
>
&
aFlexTracks
const
TrackSizingFunctions
&
aFunctions
nscoord
aAvailableSize
)
const
{
if
(
aAvailableSize
!
=
NS_UNCONSTRAINEDSIZE
)
{
const
TranslatedLineRange
range
(
0
mSizes
.
Length
(
)
)
;
return
FindFrUnitSize
(
range
aFlexTracks
aFunctions
aAvailableSize
)
;
}
float
fr
=
0
.
0f
;
for
(
uint32_t
track
:
aFlexTracks
)
{
float
flexFactor
=
aFunctions
.
MaxSizingFor
(
track
)
.
GetFlexFractionValue
(
)
;
float
possiblyDividedBaseSize
=
(
flexFactor
>
1
.
0f
)
?
mSizes
[
track
]
.
mBase
/
flexFactor
:
mSizes
[
track
]
.
mBase
;
fr
=
std
:
:
max
(
fr
possiblyDividedBaseSize
)
;
}
WritingMode
wm
=
aState
.
mWM
;
gfxContext
*
rc
=
&
aState
.
mRenderingContext
;
for
(
const
GridItemInfo
&
item
:
aGridItems
)
{
if
(
item
.
mState
[
mAxis
]
&
ItemState
:
:
eIsFlexing
)
{
auto
pb
=
Some
(
aState
.
PercentageBasisFor
(
mAxis
item
)
)
;
nscoord
spaceToFill
=
ContentContribution
(
item
aState
rc
wm
mAxis
pb
nsLayoutUtils
:
:
PREF_ISIZE
)
;
const
LineRange
&
range
=
mAxis
=
=
eLogicalAxisInline
?
item
.
mArea
.
mCols
:
item
.
mArea
.
mRows
;
MOZ_ASSERT
(
range
.
Extent
(
)
>
=
1
)
;
const
auto
spannedGaps
=
range
.
Extent
(
)
-
1
;
if
(
spannedGaps
>
0
)
{
spaceToFill
-
=
mGridGap
*
spannedGaps
;
}
if
(
spaceToFill
<
=
0
)
{
continue
;
}
nsTArray
<
uint32_t
>
itemFlexTracks
;
for
(
auto
i
:
range
.
Range
(
)
)
{
if
(
mSizes
[
i
]
.
mState
&
TrackSize
:
:
eFlexMaxSizing
)
{
itemFlexTracks
.
AppendElement
(
i
)
;
}
}
float
itemFr
=
FindFrUnitSize
(
range
itemFlexTracks
aFunctions
spaceToFill
)
;
fr
=
std
:
:
max
(
fr
itemFr
)
;
}
}
return
fr
;
}
void
nsGridContainerFrame
:
:
Tracks
:
:
StretchFlexibleTracks
(
GridReflowInput
&
aState
nsTArray
<
GridItemInfo
>
&
aGridItems
const
TrackSizingFunctions
&
aFunctions
nscoord
aAvailableSize
)
{
if
(
aAvailableSize
<
=
0
)
{
return
;
}
nsTArray
<
uint32_t
>
flexTracks
(
mSizes
.
Length
(
)
)
;
for
(
uint32_t
i
=
0
len
=
mSizes
.
Length
(
)
;
i
<
len
;
+
+
i
)
{
if
(
mSizes
[
i
]
.
mState
&
TrackSize
:
:
eFlexMaxSizing
)
{
flexTracks
.
AppendElement
(
i
)
;
}
}
if
(
flexTracks
.
IsEmpty
(
)
)
{
return
;
}
nscoord
minSize
=
0
;
nscoord
maxSize
=
NS_UNCONSTRAINEDSIZE
;
if
(
aState
.
mReflowInput
)
{
auto
*
ri
=
aState
.
mReflowInput
;
minSize
=
mAxis
=
=
eLogicalAxisBlock
?
ri
-
>
ComputedMinBSize
(
)
:
ri
-
>
ComputedMinISize
(
)
;
maxSize
=
mAxis
=
=
eLogicalAxisBlock
?
ri
-
>
ComputedMaxBSize
(
)
:
ri
-
>
ComputedMaxISize
(
)
;
}
Maybe
<
nsTArray
<
TrackSize
>
>
origSizes
;
bool
applyMinMax
=
(
minSize
!
=
0
|
|
maxSize
!
=
NS_UNCONSTRAINEDSIZE
)
&
&
aAvailableSize
=
=
NS_UNCONSTRAINEDSIZE
;
while
(
true
)
{
float
fr
=
FindUsedFlexFraction
(
aState
aGridItems
flexTracks
aFunctions
aAvailableSize
)
;
if
(
fr
!
=
0
.
0f
)
{
for
(
uint32_t
i
:
flexTracks
)
{
float
flexFactor
=
aFunctions
.
MaxSizingFor
(
i
)
.
GetFlexFractionValue
(
)
;
nscoord
flexLength
=
NSToCoordRound
(
flexFactor
*
fr
)
;
nscoord
&
base
=
mSizes
[
i
]
.
mBase
;
if
(
flexLength
>
base
)
{
if
(
applyMinMax
&
&
origSizes
.
isNothing
(
)
)
{
origSizes
.
emplace
(
mSizes
)
;
}
base
=
flexLength
;
}
}
}
if
(
applyMinMax
)
{
applyMinMax
=
false
;
nscoord
newSize
=
0
;
for
(
auto
&
sz
:
mSizes
)
{
newSize
+
=
sz
.
mBase
;
}
const
auto
sumOfGridGaps
=
SumOfGridGaps
(
)
;
newSize
+
=
sumOfGridGaps
;
if
(
newSize
>
maxSize
)
{
aAvailableSize
=
maxSize
;
}
else
if
(
newSize
<
minSize
)
{
aAvailableSize
=
minSize
;
}
if
(
aAvailableSize
!
=
NS_UNCONSTRAINEDSIZE
)
{
aAvailableSize
=
std
:
:
max
(
0
aAvailableSize
-
sumOfGridGaps
)
;
if
(
origSizes
.
isSome
(
)
)
{
mSizes
=
std
:
:
move
(
*
origSizes
)
;
origSizes
.
reset
(
)
;
}
if
(
aAvailableSize
=
=
0
)
{
break
;
}
continue
;
}
}
break
;
}
}
void
nsGridContainerFrame
:
:
Tracks
:
:
AlignJustifyContent
(
const
nsStylePosition
*
aStyle
WritingMode
aWM
nscoord
aContentBoxSize
bool
aIsSubgriddedAxis
)
{
const
bool
isAlign
=
mAxis
=
=
eLogicalAxisBlock
;
if
(
MOZ_UNLIKELY
(
aIsSubgriddedAxis
)
)
{
auto
&
gap
=
isAlign
?
aStyle
-
>
mRowGap
:
aStyle
-
>
mColumnGap
;
if
(
gap
.
IsNormal
(
)
)
{
return
;
}
auto
len
=
mSizes
.
Length
(
)
;
if
(
len
<
=
1
)
{
return
;
}
nsTArray
<
nscoord
>
gapDeltas
;
const
size_t
numGaps
=
len
-
1
;
gapDeltas
.
SetLength
(
numGaps
)
;
for
(
size_t
i
=
0
;
i
<
numGaps
;
+
+
i
)
{
TrackSize
&
sz1
=
mSizes
[
i
]
;
TrackSize
&
sz2
=
mSizes
[
i
+
1
]
;
nscoord
currentGap
=
sz2
.
mPosition
-
(
sz1
.
mPosition
+
sz1
.
mBase
)
;
gapDeltas
[
i
]
=
mGridGap
-
currentGap
;
}
nscoord
currentPos
=
mSizes
[
0
]
.
mPosition
;
nscoord
lastHalfDelta
(
0
)
;
for
(
size_t
i
=
0
;
i
<
numGaps
;
+
+
i
)
{
TrackSize
&
sz
=
mSizes
[
i
]
;
nscoord
delta
=
gapDeltas
[
i
]
;
nscoord
halfDelta
;
nscoord
roundingError
=
NSCoordDivRem
(
delta
2
&
halfDelta
)
;
auto
newSize
=
sz
.
mBase
-
(
halfDelta
+
roundingError
)
-
lastHalfDelta
;
lastHalfDelta
=
halfDelta
;
if
(
newSize
>
=
0
)
{
sz
.
mBase
=
newSize
;
sz
.
mPosition
=
currentPos
;
currentPos
+
=
newSize
+
mGridGap
;
}
else
{
sz
.
mBase
=
nscoord
(
0
)
;
sz
.
mPosition
=
currentPos
+
newSize
;
currentPos
=
sz
.
mPosition
+
mGridGap
;
}
}
auto
&
lastTrack
=
mSizes
.
LastElement
(
)
;
auto
newSize
=
lastTrack
.
mBase
-
lastHalfDelta
;
if
(
newSize
>
=
0
)
{
lastTrack
.
mBase
=
newSize
;
lastTrack
.
mPosition
=
currentPos
;
}
else
{
lastTrack
.
mBase
=
nscoord
(
0
)
;
lastTrack
.
mPosition
=
currentPos
+
newSize
;
}
return
;
}
if
(
mSizes
.
IsEmpty
(
)
)
{
return
;
}
auto
valueAndFallback
=
isAlign
?
aStyle
-
>
mAlignContent
:
aStyle
-
>
mJustifyContent
;
bool
overflowSafe
;
auto
alignment
=
:
:
GetAlignJustifyValue
(
valueAndFallback
aWM
isAlign
&
overflowSafe
)
;
if
(
alignment
=
=
NS_STYLE_ALIGN_NORMAL
)
{
MOZ_ASSERT
(
valueAndFallback
=
=
NS_STYLE_ALIGN_NORMAL
"
*
-
content
:
normal
cannot
be
specified
with
explicit
fallback
"
)
;
alignment
=
NS_STYLE_ALIGN_STRETCH
;
valueAndFallback
=
alignment
;
}
size_t
numAutoTracks
=
0
;
nscoord
space
;
if
(
alignment
!
=
NS_STYLE_ALIGN_START
)
{
nscoord
trackSizeSum
=
0
;
if
(
aIsSubgriddedAxis
)
{
numAutoTracks
=
mSizes
.
Length
(
)
;
}
else
{
for
(
const
TrackSize
&
sz
:
mSizes
)
{
trackSizeSum
+
=
sz
.
mBase
;
if
(
sz
.
mState
&
TrackSize
:
:
eAutoMaxSizing
)
{
+
+
numAutoTracks
;
}
}
}
space
=
aContentBoxSize
-
trackSizeSum
-
SumOfGridGaps
(
)
;
if
(
space
<
0
|
|
(
alignment
=
=
NS_STYLE_ALIGN_SPACE_BETWEEN
&
&
mSizes
.
Length
(
)
=
=
1
)
)
{
auto
fallback
=
:
:
GetAlignJustifyFallbackIfAny
(
valueAndFallback
aWM
isAlign
&
overflowSafe
)
;
if
(
fallback
)
{
alignment
=
fallback
;
}
}
if
(
space
=
=
0
|
|
(
space
<
0
&
&
overflowSafe
)
)
{
alignment
=
NS_STYLE_ALIGN_START
;
}
}
nscoord
pos
=
0
;
bool
distribute
=
true
;
switch
(
alignment
)
{
case
NS_STYLE_ALIGN_BASELINE
:
case
NS_STYLE_ALIGN_LAST_BASELINE
:
NS_WARNING
(
"
NYI
:
'
first
/
last
baseline
'
(
bug
1151204
)
"
)
;
MOZ_FALLTHROUGH
;
case
NS_STYLE_ALIGN_START
:
distribute
=
false
;
break
;
case
NS_STYLE_ALIGN_END
:
pos
=
space
;
distribute
=
false
;
break
;
case
NS_STYLE_ALIGN_CENTER
:
pos
=
space
/
2
;
distribute
=
false
;
break
;
case
NS_STYLE_ALIGN_STRETCH
:
distribute
=
numAutoTracks
!
=
0
;
break
;
}
if
(
!
distribute
)
{
for
(
TrackSize
&
sz
:
mSizes
)
{
sz
.
mPosition
=
pos
;
pos
+
=
sz
.
mBase
+
mGridGap
;
}
return
;
}
MOZ_ASSERT
(
space
>
0
"
should
'
ve
handled
that
on
the
fallback
path
above
"
)
;
nscoord
between
roundingError
;
switch
(
alignment
)
{
case
NS_STYLE_ALIGN_STRETCH
:
{
MOZ_ASSERT
(
numAutoTracks
>
0
"
we
handled
numAutoTracks
=
=
0
above
"
)
;
nscoord
spacePerTrack
;
roundingError
=
NSCoordDivRem
(
space
numAutoTracks
&
spacePerTrack
)
;
for
(
TrackSize
&
sz
:
mSizes
)
{
sz
.
mPosition
=
pos
;
if
(
!
(
sz
.
mState
&
TrackSize
:
:
eAutoMaxSizing
)
)
{
pos
+
=
sz
.
mBase
+
mGridGap
;
continue
;
}
nscoord
stretch
=
spacePerTrack
;
if
(
roundingError
)
{
roundingError
-
=
1
;
stretch
+
=
1
;
}
nscoord
newBase
=
sz
.
mBase
+
stretch
;
sz
.
mBase
=
newBase
;
pos
+
=
newBase
+
mGridGap
;
}
MOZ_ASSERT
(
!
roundingError
"
we
didn
'
t
distribute
all
rounding
error
?
"
)
;
return
;
}
case
NS_STYLE_ALIGN_SPACE_BETWEEN
:
MOZ_ASSERT
(
mSizes
.
Length
(
)
>
1
"
should
'
ve
used
a
fallback
above
"
)
;
roundingError
=
NSCoordDivRem
(
space
mSizes
.
Length
(
)
-
1
&
between
)
;
break
;
case
NS_STYLE_ALIGN_SPACE_AROUND
:
roundingError
=
NSCoordDivRem
(
space
mSizes
.
Length
(
)
&
between
)
;
pos
=
between
/
2
;
break
;
case
NS_STYLE_ALIGN_SPACE_EVENLY
:
roundingError
=
NSCoordDivRem
(
space
mSizes
.
Length
(
)
+
1
&
between
)
;
pos
=
between
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unknown
align
-
/
justify
-
content
value
"
)
;
between
=
0
;
roundingError
=
0
;
}
between
+
=
mGridGap
;
for
(
TrackSize
&
sz
:
mSizes
)
{
sz
.
mPosition
=
pos
;
nscoord
spacing
=
between
;
if
(
roundingError
)
{
roundingError
-
=
1
;
spacing
+
=
1
;
}
pos
+
=
sz
.
mBase
+
spacing
;
}
MOZ_ASSERT
(
!
roundingError
"
we
didn
'
t
distribute
all
rounding
error
?
"
)
;
}
void
nsGridContainerFrame
:
:
LineRange
:
:
ToPositionAndLength
(
const
nsTArray
<
TrackSize
>
&
aTrackSizes
nscoord
*
aPos
nscoord
*
aLength
)
const
{
MOZ_ASSERT
(
mStart
!
=
kAutoLine
&
&
mEnd
!
=
kAutoLine
"
expected
a
definite
LineRange
"
)
;
MOZ_ASSERT
(
mStart
<
mEnd
)
;
nscoord
startPos
=
aTrackSizes
[
mStart
]
.
mPosition
;
const
TrackSize
&
sz
=
aTrackSizes
[
mEnd
-
1
]
;
*
aPos
=
startPos
;
*
aLength
=
(
sz
.
mPosition
+
sz
.
mBase
)
-
startPos
;
}
nscoord
nsGridContainerFrame
:
:
LineRange
:
:
ToLength
(
const
nsTArray
<
TrackSize
>
&
aTrackSizes
)
const
{
MOZ_ASSERT
(
mStart
!
=
kAutoLine
&
&
mEnd
!
=
kAutoLine
"
expected
a
definite
LineRange
"
)
;
MOZ_ASSERT
(
mStart
<
mEnd
)
;
nscoord
startPos
=
aTrackSizes
[
mStart
]
.
mPosition
;
const
TrackSize
&
sz
=
aTrackSizes
[
mEnd
-
1
]
;
return
(
sz
.
mPosition
+
sz
.
mBase
)
-
startPos
;
}
void
nsGridContainerFrame
:
:
LineRange
:
:
ToPositionAndLengthForAbsPos
(
const
Tracks
&
aTracks
nscoord
aGridOrigin
nscoord
*
aPos
nscoord
*
aLength
)
const
{
if
(
mEnd
=
=
kAutoLine
)
{
if
(
mStart
=
=
kAutoLine
)
{
}
else
{
const
nscoord
endPos
=
*
aPos
+
*
aLength
;
auto
side
=
mStart
=
=
aTracks
.
mSizes
.
Length
(
)
?
GridLineSide
:
:
BeforeGridGap
:
GridLineSide
:
:
AfterGridGap
;
nscoord
startPos
=
aTracks
.
GridLineEdge
(
mStart
side
)
;
*
aPos
=
aGridOrigin
+
startPos
;
*
aLength
=
std
:
:
max
(
endPos
-
*
aPos
0
)
;
}
}
else
{
if
(
mStart
=
=
kAutoLine
)
{
auto
side
=
mEnd
=
=
0
?
GridLineSide
:
:
AfterGridGap
:
GridLineSide
:
:
BeforeGridGap
;
nscoord
endPos
=
aTracks
.
GridLineEdge
(
mEnd
side
)
;
*
aLength
=
std
:
:
max
(
aGridOrigin
+
endPos
0
)
;
}
else
if
(
MOZ_LIKELY
(
mStart
!
=
mEnd
)
)
{
nscoord
pos
;
ToPositionAndLength
(
aTracks
.
mSizes
&
pos
aLength
)
;
*
aPos
=
aGridOrigin
+
pos
;
}
else
{
nscoord
pos
=
aTracks
.
GridLineEdge
(
mStart
GridLineSide
:
:
BeforeGridGap
)
;
*
aPos
=
aGridOrigin
+
pos
;
*
aLength
=
nscoord
(
0
)
;
}
}
}
LogicalSize
nsGridContainerFrame
:
:
GridReflowInput
:
:
PercentageBasisFor
(
LogicalAxis
aAxis
const
GridItemInfo
&
aGridItem
)
const
{
auto
wm
=
aGridItem
.
mFrame
-
>
GetWritingMode
(
)
;
const
auto
*
itemParent
=
aGridItem
.
mFrame
-
>
GetParent
(
)
;
if
(
MOZ_UNLIKELY
(
itemParent
!
=
mFrame
)
)
{
MOZ_ASSERT
(
itemParent
-
>
IsGridContainerFrame
(
)
)
;
auto
*
subgridFrame
=
static_cast
<
const
nsGridContainerFrame
*
>
(
itemParent
)
;
MOZ_ASSERT
(
subgridFrame
-
>
IsSubgrid
(
)
)
;
if
(
auto
*
uts
=
subgridFrame
-
>
GetUsedTrackSizes
(
)
)
{
auto
subgridWM
=
subgridFrame
-
>
GetWritingMode
(
)
;
LogicalSize
cbSize
(
subgridWM
NS_UNCONSTRAINEDSIZE
NS_UNCONSTRAINEDSIZE
)
;
if
(
!
subgridFrame
-
>
IsSubgrid
(
eLogicalAxisInline
)
&
&
uts
-
>
mCanResolveLineRangeSize
[
eLogicalAxisInline
]
)
{
auto
rangeAxis
=
subgridWM
.
IsOrthogonalTo
(
mWM
)
?
eLogicalAxisBlock
:
eLogicalAxisInline
;
const
auto
&
range
=
aGridItem
.
mArea
.
LineRangeForAxis
(
rangeAxis
)
;
cbSize
.
ISize
(
subgridWM
)
=
range
.
ToLength
(
uts
-
>
mSizes
[
eLogicalAxisInline
]
)
;
}
if
(
!
subgridFrame
-
>
IsSubgrid
(
eLogicalAxisBlock
)
&
&
uts
-
>
mCanResolveLineRangeSize
[
eLogicalAxisBlock
]
)
{
auto
rangeAxis
=
subgridWM
.
IsOrthogonalTo
(
mWM
)
?
eLogicalAxisInline
:
eLogicalAxisBlock
;
const
auto
&
range
=
aGridItem
.
mArea
.
LineRangeForAxis
(
rangeAxis
)
;
cbSize
.
BSize
(
subgridWM
)
=
range
.
ToLength
(
uts
-
>
mSizes
[
eLogicalAxisBlock
]
)
;
}
return
cbSize
.
ConvertTo
(
wm
subgridWM
)
;
}
return
LogicalSize
(
wm
NS_UNCONSTRAINEDSIZE
NS_UNCONSTRAINEDSIZE
)
;
}
if
(
aAxis
=
=
eLogicalAxisInline
|
|
!
mCols
.
mCanResolveLineRangeSize
)
{
return
LogicalSize
(
wm
NS_UNCONSTRAINEDSIZE
NS_UNCONSTRAINEDSIZE
)
;
}
MOZ_ASSERT
(
!
mRows
.
mCanResolveLineRangeSize
)
;
nscoord
colSize
=
aGridItem
.
mArea
.
mCols
.
ToLength
(
mCols
.
mSizes
)
;
nscoord
rowSize
=
NS_UNCONSTRAINEDSIZE
;
return
!
wm
.
IsOrthogonalTo
(
mWM
)
?
LogicalSize
(
wm
colSize
rowSize
)
:
LogicalSize
(
wm
rowSize
colSize
)
;
}
LogicalRect
nsGridContainerFrame
:
:
GridReflowInput
:
:
ContainingBlockFor
(
const
GridArea
&
aArea
)
const
{
nscoord
i
b
iSize
bSize
;
MOZ_ASSERT
(
aArea
.
mCols
.
Extent
(
)
>
0
"
grid
items
cover
at
least
one
track
"
)
;
MOZ_ASSERT
(
aArea
.
mRows
.
Extent
(
)
>
0
"
grid
items
cover
at
least
one
track
"
)
;
aArea
.
mCols
.
ToPositionAndLength
(
mCols
.
mSizes
&
i
&
iSize
)
;
aArea
.
mRows
.
ToPositionAndLength
(
mRows
.
mSizes
&
b
&
bSize
)
;
return
LogicalRect
(
mWM
i
b
iSize
bSize
)
;
}
LogicalRect
nsGridContainerFrame
:
:
GridReflowInput
:
:
ContainingBlockForAbsPos
(
const
GridArea
&
aArea
const
LogicalPoint
&
aGridOrigin
const
LogicalRect
&
aGridCB
)
const
{
nscoord
i
=
aGridCB
.
IStart
(
mWM
)
;
nscoord
b
=
aGridCB
.
BStart
(
mWM
)
;
nscoord
iSize
=
aGridCB
.
ISize
(
mWM
)
;
nscoord
bSize
=
aGridCB
.
BSize
(
mWM
)
;
aArea
.
mCols
.
ToPositionAndLengthForAbsPos
(
mCols
aGridOrigin
.
I
(
mWM
)
&
i
&
iSize
)
;
aArea
.
mRows
.
ToPositionAndLengthForAbsPos
(
mRows
aGridOrigin
.
B
(
mWM
)
&
b
&
bSize
)
;
return
LogicalRect
(
mWM
i
b
iSize
bSize
)
;
}
Maybe
<
nsGridContainerFrame
:
:
Fragmentainer
>
nsGridContainerFrame
:
:
GetNearestFragmentainer
(
const
GridReflowInput
&
aState
)
const
{
Maybe
<
nsGridContainerFrame
:
:
Fragmentainer
>
data
;
const
ReflowInput
*
gridRI
=
aState
.
mReflowInput
;
if
(
gridRI
-
>
AvailableBSize
(
)
=
=
NS_UNCONSTRAINEDSIZE
)
{
return
data
;
}
WritingMode
wm
=
aState
.
mWM
;
const
ReflowInput
*
cbRI
=
gridRI
-
>
mCBReflowInput
;
for
(
;
cbRI
;
cbRI
=
cbRI
-
>
mCBReflowInput
)
{
nsIScrollableFrame
*
sf
=
do_QueryFrame
(
cbRI
-
>
mFrame
)
;
if
(
sf
)
{
break
;
}
if
(
wm
.
IsOrthogonalTo
(
cbRI
-
>
GetWritingMode
(
)
)
)
{
break
;
}
LayoutFrameType
frameType
=
cbRI
-
>
mFrame
-
>
Type
(
)
;
if
(
(
frameType
=
=
LayoutFrameType
:
:
Canvas
&
&
PresContext
(
)
-
>
IsPaginated
(
)
)
|
|
frameType
=
=
LayoutFrameType
:
:
ColumnSet
)
{
data
.
emplace
(
)
;
data
-
>
mIsTopOfPage
=
gridRI
-
>
mFlags
.
mIsTopOfPage
;
data
-
>
mToFragmentainerEnd
=
aState
.
mFragBStart
+
gridRI
-
>
AvailableBSize
(
)
-
aState
.
mBorderPadding
.
BStart
(
wm
)
;
const
auto
numRows
=
aState
.
mRows
.
mSizes
.
Length
(
)
;
data
-
>
mCanBreakAtStart
=
numRows
>
0
&
&
aState
.
mRows
.
mSizes
[
0
]
.
mPosition
>
0
;
nscoord
bSize
=
gridRI
-
>
ComputedBSize
(
)
;
data
-
>
mIsAutoBSize
=
bSize
=
=
NS_UNCONSTRAINEDSIZE
;
if
(
data
-
>
mIsAutoBSize
)
{
bSize
=
gridRI
-
>
ComputedMinBSize
(
)
;
}
else
{
bSize
=
NS_CSS_MINMAX
(
bSize
gridRI
-
>
ComputedMinBSize
(
)
gridRI
-
>
ComputedMaxBSize
(
)
)
;
}
nscoord
gridEnd
=
aState
.
mRows
.
GridLineEdge
(
numRows
GridLineSide
:
:
BeforeGridGap
)
;
data
-
>
mCanBreakAtEnd
=
bSize
>
gridEnd
&
&
bSize
>
aState
.
mFragBStart
;
break
;
}
}
return
data
;
}
void
nsGridContainerFrame
:
:
ReflowInFlowChild
(
nsIFrame
*
aChild
const
GridItemInfo
*
aGridItemInfo
nsSize
aContainerSize
const
Maybe
<
nscoord
>
&
aStretchBSize
const
Fragmentainer
*
aFragmentainer
const
GridReflowInput
&
aState
const
LogicalRect
&
aContentArea
ReflowOutput
&
aDesiredSize
nsReflowStatus
&
aStatus
)
{
nsPresContext
*
pc
=
PresContext
(
)
;
ComputedStyle
*
containerSC
=
Style
(
)
;
WritingMode
wm
=
aState
.
mReflowInput
-
>
GetWritingMode
(
)
;
const
bool
isGridItem
=
!
!
aGridItemInfo
;
MOZ_ASSERT
(
isGridItem
=
=
!
aChild
-
>
IsPlaceholderFrame
(
)
)
;
LogicalRect
cb
(
wm
)
;
WritingMode
childWM
=
aChild
-
>
GetWritingMode
(
)
;
bool
isConstrainedBSize
=
false
;
nscoord
toFragmentainerEnd
;
nscoord
consumedGridAreaBSize
=
0
;
const
bool
isOrthogonal
=
wm
.
IsOrthogonalTo
(
childWM
)
;
if
(
MOZ_LIKELY
(
isGridItem
)
)
{
MOZ_ASSERT
(
aGridItemInfo
-
>
mFrame
=
=
aChild
)
;
const
GridArea
&
area
=
aGridItemInfo
-
>
mArea
;
MOZ_ASSERT
(
area
.
IsDefinite
(
)
)
;
cb
=
aState
.
ContainingBlockFor
(
area
)
;
isConstrainedBSize
=
aFragmentainer
&
&
!
wm
.
IsOrthogonalTo
(
childWM
)
;
if
(
isConstrainedBSize
)
{
nscoord
gridAreaBOffset
=
cb
.
BStart
(
wm
)
-
aState
.
mFragBStart
;
consumedGridAreaBSize
=
std
:
:
max
(
0
-
gridAreaBOffset
)
;
cb
.
BStart
(
wm
)
=
std
:
:
max
(
0
gridAreaBOffset
)
;
toFragmentainerEnd
=
aFragmentainer
-
>
mToFragmentainerEnd
-
aState
.
mFragBStart
-
cb
.
BStart
(
wm
)
;
toFragmentainerEnd
=
std
:
:
max
(
toFragmentainerEnd
0
)
;
}
cb
+
=
aContentArea
.
Origin
(
wm
)
;
aState
.
mRows
.
AlignBaselineSubtree
(
*
aGridItemInfo
)
;
aState
.
mCols
.
AlignBaselineSubtree
(
*
aGridItemInfo
)
;
typedef
const
FramePropertyDescriptor
<
SmallValueHolder
<
nscoord
>
>
*
Prop
;
auto
SetProp
=
[
aGridItemInfo
aChild
]
(
LogicalAxis
aGridAxis
Prop
aProp
)
{
auto
state
=
aGridItemInfo
-
>
mState
[
aGridAxis
]
;
auto
baselineAdjust
=
(
state
&
ItemState
:
:
eContentBaseline
)
?
aGridItemInfo
-
>
mBaselineOffset
[
aGridAxis
]
:
nscoord
(
0
)
;
if
(
baselineAdjust
<
nscoord
(
0
)
)
{
baselineAdjust
=
nscoord
(
0
)
;
}
else
if
(
baselineAdjust
>
nscoord
(
0
)
&
&
(
state
&
ItemState
:
:
eLastBaseline
)
)
{
baselineAdjust
=
-
baselineAdjust
;
}
if
(
baselineAdjust
!
=
nscoord
(
0
)
)
{
aChild
-
>
SetProperty
(
aProp
baselineAdjust
)
;
}
else
{
aChild
-
>
DeleteProperty
(
aProp
)
;
}
}
;
SetProp
(
eLogicalAxisBlock
isOrthogonal
?
IBaselinePadProperty
(
)
:
BBaselinePadProperty
(
)
)
;
SetProp
(
eLogicalAxisInline
isOrthogonal
?
BBaselinePadProperty
(
)
:
IBaselinePadProperty
(
)
)
;
}
else
{
cb
=
aContentArea
;
aChild
-
>
AddStateBits
(
PLACEHOLDER_STATICPOS_NEEDS_CSSALIGN
)
;
}
LogicalSize
reflowSize
(
cb
.
Size
(
wm
)
)
;
if
(
isConstrainedBSize
)
{
reflowSize
.
BSize
(
wm
)
=
toFragmentainerEnd
;
}
LogicalSize
childCBSize
=
reflowSize
.
ConvertTo
(
childWM
wm
)
;
uint32_t
flags
=
0
;
if
(
aGridItemInfo
)
{
auto
*
pos
=
aChild
-
>
StylePosition
(
)
;
auto
j
=
pos
-
>
UsedJustifySelf
(
Style
(
)
)
;
auto
a
=
pos
-
>
UsedAlignSelf
(
Style
(
)
)
;
bool
stretch
[
2
]
;
stretch
[
eLogicalAxisInline
]
=
j
=
=
NS_STYLE_JUSTIFY_NORMAL
|
|
j
=
=
NS_STYLE_JUSTIFY_STRETCH
;
stretch
[
eLogicalAxisBlock
]
=
a
=
=
NS_STYLE_ALIGN_NORMAL
|
|
a
=
=
NS_STYLE_ALIGN_STRETCH
;
auto
childIAxis
=
isOrthogonal
?
eLogicalAxisBlock
:
eLogicalAxisInline
;
if
(
stretch
[
childIAxis
]
&
&
aGridItemInfo
-
>
mState
[
childIAxis
]
&
ItemState
:
:
eClampMarginBoxMinSize
)
{
flags
|
=
ReflowInput
:
:
I_CLAMP_MARGIN_BOX_MIN_SIZE
;
}
auto
childBAxis
=
GetOrthogonalAxis
(
childIAxis
)
;
if
(
stretch
[
childBAxis
]
&
&
aGridItemInfo
-
>
mState
[
childBAxis
]
&
ItemState
:
:
eClampMarginBoxMinSize
)
{
flags
|
=
ReflowInput
:
:
B_CLAMP_MARGIN_BOX_MIN_SIZE
;
aChild
-
>
SetProperty
(
BClampMarginBoxMinSizeProperty
(
)
childCBSize
.
BSize
(
childWM
)
)
;
}
else
{
aChild
-
>
DeleteProperty
(
BClampMarginBoxMinSizeProperty
(
)
)
;
}
if
(
(
aGridItemInfo
-
>
mState
[
childIAxis
]
&
ItemState
:
:
eApplyAutoMinSize
)
)
{
flags
|
=
ReflowInput
:
:
I_APPLY_AUTO_MIN_SIZE
;
}
}
if
(
!
isConstrainedBSize
)
{
childCBSize
.
BSize
(
childWM
)
=
NS_UNCONSTRAINEDSIZE
;
}
LogicalSize
percentBasis
(
cb
.
Size
(
wm
)
.
ConvertTo
(
childWM
wm
)
)
;
ReflowInput
childRI
(
pc
*
aState
.
mReflowInput
aChild
childCBSize
Some
(
percentBasis
)
flags
)
;
childRI
.
mFlags
.
mIsTopOfPage
=
aFragmentainer
?
aFragmentainer
-
>
mIsTopOfPage
:
false
;
childRI
.
SetBResize
(
true
)
;
if
(
aChild
-
>
IsTableWrapperFrame
(
)
)
{
LogicalSize
*
cb
=
aChild
-
>
GetProperty
(
nsTableWrapperFrame
:
:
GridItemCBSizeProperty
(
)
)
;
if
(
!
cb
)
{
cb
=
new
LogicalSize
(
childWM
)
;
aChild
-
>
SetProperty
(
nsTableWrapperFrame
:
:
GridItemCBSizeProperty
(
)
cb
)
;
}
*
cb
=
percentBasis
;
}
if
(
isConstrainedBSize
&
&
!
wm
.
IsOrthogonalTo
(
childWM
)
)
{
bool
stretch
=
false
;
if
(
!
childRI
.
mStyleMargin
-
>
HasBlockAxisAuto
(
childWM
)
&
&
(
childRI
.
mStylePosition
-
>
BSize
(
childWM
)
.
IsAuto
(
)
|
|
childRI
.
mStylePosition
-
>
BSize
(
childWM
)
.
IsExtremumLength
(
)
)
)
{
auto
blockAxisAlignment
=
childRI
.
mStylePosition
-
>
UsedAlignSelf
(
Style
(
)
)
;
if
(
blockAxisAlignment
=
=
NS_STYLE_ALIGN_NORMAL
|
|
blockAxisAlignment
=
=
NS_STYLE_ALIGN_STRETCH
)
{
stretch
=
true
;
}
}
if
(
stretch
)
{
aChild
-
>
SetProperty
(
FragStretchBSizeProperty
(
)
*
aStretchBSize
)
;
}
else
{
aChild
-
>
DeleteProperty
(
FragStretchBSizeProperty
(
)
)
;
}
}
ReflowOutput
childSize
(
childRI
)
;
const
nsSize
dummyContainerSize
;
ReflowChild
(
aChild
pc
childSize
childRI
childWM
LogicalPoint
(
childWM
)
dummyContainerSize
0
aStatus
)
;
LogicalPoint
childPos
=
cb
.
Origin
(
wm
)
.
ConvertTo
(
childWM
wm
aContainerSize
-
childSize
.
PhysicalSize
(
)
)
;
if
(
MOZ_LIKELY
(
isGridItem
)
)
{
LogicalSize
size
=
childSize
.
Size
(
childWM
)
;
if
(
aStatus
.
IsComplete
(
)
)
{
auto
align
=
childRI
.
mStylePosition
-
>
UsedAlignSelf
(
containerSC
)
;
auto
state
=
aGridItemInfo
-
>
mState
[
eLogicalAxisBlock
]
;
if
(
state
&
ItemState
:
:
eContentBaseline
)
{
align
=
(
state
&
ItemState
:
:
eFirstBaseline
)
?
NS_STYLE_ALIGN_SELF_START
:
NS_STYLE_ALIGN_SELF_END
;
}
nscoord
cbsz
=
cb
.
BSize
(
wm
)
-
consumedGridAreaBSize
;
AlignSelf
(
*
aGridItemInfo
align
cbsz
wm
childRI
size
&
childPos
)
;
}
auto
justify
=
childRI
.
mStylePosition
-
>
UsedJustifySelf
(
containerSC
)
;
auto
state
=
aGridItemInfo
-
>
mState
[
eLogicalAxisInline
]
;
if
(
state
&
ItemState
:
:
eContentBaseline
)
{
justify
=
(
state
&
ItemState
:
:
eFirstBaseline
)
?
NS_STYLE_JUSTIFY_SELF_START
:
NS_STYLE_JUSTIFY_SELF_END
;
}
nscoord
cbsz
=
cb
.
ISize
(
wm
)
;
JustifySelf
(
*
aGridItemInfo
justify
cbsz
wm
childRI
size
&
childPos
)
;
}
childRI
.
ApplyRelativePositioning
(
&
childPos
aContainerSize
)
;
FinishReflowChild
(
aChild
pc
childSize
&
childRI
childWM
childPos
aContainerSize
0
)
;
ConsiderChildOverflow
(
aDesiredSize
.
mOverflowAreas
aChild
)
;
}
nscoord
nsGridContainerFrame
:
:
ReflowInFragmentainer
(
GridReflowInput
&
aState
const
LogicalRect
&
aContentArea
ReflowOutput
&
aDesiredSize
nsReflowStatus
&
aStatus
Fragmentainer
&
aFragmentainer
const
nsSize
&
aContainerSize
)
{
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
aState
.
mReflowInput
)
;
nsTArray
<
const
GridItemInfo
*
>
sortedItems
(
aState
.
mGridItems
.
Length
(
)
)
;
nsTArray
<
nsIFrame
*
>
placeholders
(
aState
.
mAbsPosItems
.
Length
(
)
)
;
aState
.
mIter
.
Reset
(
CSSOrderAwareFrameIterator
:
:
eIncludeAll
)
;
for
(
;
!
aState
.
mIter
.
AtEnd
(
)
;
aState
.
mIter
.
Next
(
)
)
{
nsIFrame
*
child
=
*
aState
.
mIter
;
if
(
!
child
-
>
IsPlaceholderFrame
(
)
)
{
const
GridItemInfo
*
info
=
&
aState
.
mGridItems
[
aState
.
mIter
.
ItemIndex
(
)
]
;
sortedItems
.
AppendElement
(
info
)
;
}
else
{
placeholders
.
AppendElement
(
child
)
;
}
}
std
:
:
sort
(
sortedItems
.
begin
(
)
sortedItems
.
end
(
)
GridItemInfo
:
:
IsStartRowLessThan
)
;
for
(
auto
child
:
placeholders
)
{
nsReflowStatus
childStatus
;
ReflowInFlowChild
(
child
nullptr
aContainerSize
Nothing
(
)
&
aFragmentainer
aState
aContentArea
aDesiredSize
childStatus
)
;
MOZ_ASSERT
(
childStatus
.
IsComplete
(
)
"
nsPlaceholderFrame
should
never
need
to
be
fragmented
"
)
;
}
nscoord
childAvailableSize
=
aFragmentainer
.
mToFragmentainerEnd
;
const
uint32_t
startRow
=
aState
.
mStartRow
;
const
uint32_t
numRows
=
aState
.
mRows
.
mSizes
.
Length
(
)
;
bool
isBDBClone
=
aState
.
mReflowInput
-
>
mStyleBorder
-
>
mBoxDecorationBreak
=
=
StyleBoxDecorationBreak
:
:
Clone
;
nscoord
bpBEnd
=
aState
.
mBorderPadding
.
BEnd
(
aState
.
mWM
)
;
uint32_t
endRow
=
numRows
;
for
(
uint32_t
row
=
startRow
;
row
<
numRows
;
+
+
row
)
{
auto
&
sz
=
aState
.
mRows
.
mSizes
[
row
]
;
const
nscoord
bEnd
=
sz
.
mPosition
+
sz
.
mBase
;
nscoord
remainingAvailableSize
=
childAvailableSize
-
bEnd
;
if
(
remainingAvailableSize
<
0
|
|
(
isBDBClone
&
&
remainingAvailableSize
<
bpBEnd
)
)
{
endRow
=
row
;
break
;
}
}
const
bool
isTopOfPage
=
aFragmentainer
.
mIsTopOfPage
;
bool
isForcedBreak
=
false
;
const
bool
avoidBreakInside
=
ShouldAvoidBreakInside
(
*
aState
.
mReflowInput
)
;
for
(
const
GridItemInfo
*
info
:
sortedItems
)
{
uint32_t
itemStartRow
=
info
-
>
mArea
.
mRows
.
mStart
;
if
(
itemStartRow
=
=
endRow
)
{
break
;
}
auto
disp
=
info
-
>
mFrame
-
>
StyleDisplay
(
)
;
if
(
disp
-
>
BreakBefore
(
)
)
{
if
(
(
itemStartRow
=
=
0
&
&
!
isTopOfPage
)
|
|
avoidBreakInside
)
{
aStatus
.
SetInlineLineBreakBeforeAndReset
(
)
;
return
aState
.
mFragBStart
;
}
if
(
(
itemStartRow
>
startRow
|
|
(
itemStartRow
=
=
startRow
&
&
!
isTopOfPage
)
)
&
&
itemStartRow
<
endRow
)
{
endRow
=
itemStartRow
;
isForcedBreak
=
true
;
aStatus
.
Reset
(
)
;
break
;
}
}
uint32_t
itemEndRow
=
info
-
>
mArea
.
mRows
.
mEnd
;
if
(
disp
-
>
BreakAfter
(
)
)
{
if
(
itemEndRow
!
=
numRows
)
{
if
(
itemEndRow
>
startRow
&
&
itemEndRow
<
endRow
)
{
endRow
=
itemEndRow
;
isForcedBreak
=
true
;
}
}
else
{
aStatus
.
SetInlineLineBreakAfter
(
)
;
}
}
}
if
(
startRow
=
=
endRow
&
&
startRow
!
=
numRows
&
&
(
startRow
!
=
0
|
|
!
aFragmentainer
.
mCanBreakAtStart
)
)
{
+
+
endRow
;
}
if
(
avoidBreakInside
&
&
endRow
<
numRows
)
{
aStatus
.
SetInlineLineBreakBeforeAndReset
(
)
;
return
aState
.
mFragBStart
;
}
nscoord
bEndRow
=
aState
.
mRows
.
GridLineEdge
(
endRow
GridLineSide
:
:
BeforeGridGap
)
;
nscoord
bSize
;
if
(
aFragmentainer
.
mIsAutoBSize
)
{
if
(
endRow
<
numRows
)
{
bSize
=
bEndRow
;
auto
clampedBSize
=
ClampToCSSMaxBSize
(
bSize
aState
.
mReflowInput
)
;
if
(
MOZ_UNLIKELY
(
clampedBSize
!
=
bSize
)
)
{
bSize
=
clampedBSize
;
}
else
if
(
!
isBDBClone
)
{
bpBEnd
=
0
;
}
}
else
{
bSize
=
NS_CSS_MINMAX
(
bEndRow
aState
.
mReflowInput
-
>
ComputedMinBSize
(
)
aState
.
mReflowInput
-
>
ComputedMaxBSize
(
)
)
;
}
}
else
{
bSize
=
NS_CSS_MINMAX
(
aState
.
mReflowInput
-
>
ComputedBSize
(
)
aState
.
mReflowInput
-
>
ComputedMinBSize
(
)
aState
.
mReflowInput
-
>
ComputedMaxBSize
(
)
)
;
}
bool
overflow
=
bSize
+
bpBEnd
>
childAvailableSize
;
if
(
overflow
)
{
if
(
avoidBreakInside
)
{
aStatus
.
SetInlineLineBreakBeforeAndReset
(
)
;
return
aState
.
mFragBStart
;
}
bool
breakAfterLastRow
=
endRow
=
=
numRows
&
&
aFragmentainer
.
mCanBreakAtEnd
;
if
(
breakAfterLastRow
)
{
MOZ_ASSERT
(
bEndRow
<
bSize
"
bogus
aFragmentainer
.
mCanBreakAtEnd
"
)
;
nscoord
availableSize
=
childAvailableSize
;
if
(
isBDBClone
)
{
availableSize
-
=
bpBEnd
;
}
availableSize
=
std
:
:
max
(
availableSize
aState
.
mFragBStart
+
AppUnitsPerCSSPixel
(
)
)
;
nscoord
newBSize
=
std
:
:
min
(
bSize
availableSize
)
;
newBSize
=
std
:
:
max
(
newBSize
bEndRow
)
;
if
(
newBSize
<
bSize
|
|
!
isBDBClone
)
{
aStatus
.
SetIncomplete
(
)
;
}
bSize
=
newBSize
;
}
else
if
(
bSize
<
=
bEndRow
&
&
startRow
+
1
<
endRow
)
{
if
(
endRow
=
=
numRows
)
{
-
-
endRow
;
bEndRow
=
aState
.
mRows
.
GridLineEdge
(
endRow
GridLineSide
:
:
BeforeGridGap
)
;
bSize
=
bEndRow
;
if
(
aFragmentainer
.
mIsAutoBSize
)
{
bSize
=
ClampToCSSMaxBSize
(
bSize
aState
.
mReflowInput
)
;
}
}
aStatus
.
SetIncomplete
(
)
;
}
else
if
(
endRow
<
numRows
)
{
bSize
=
ClampToCSSMaxBSize
(
bEndRow
aState
.
mReflowInput
&
aStatus
)
;
}
}
else
{
if
(
endRow
<
numRows
&
&
(
isForcedBreak
|
|
(
aFragmentainer
.
mIsAutoBSize
&
&
bEndRow
=
=
bSize
)
)
)
{
bSize
=
ClampToCSSMaxBSize
(
bEndRow
aState
.
mReflowInput
&
aStatus
)
;
}
}
if
(
endRow
<
numRows
)
{
childAvailableSize
=
bEndRow
;
if
(
aStatus
.
IsComplete
(
)
)
{
aStatus
.
SetOverflowIncomplete
(
)
;
aStatus
.
SetNextInFlowNeedsReflow
(
)
;
}
}
else
{
childAvailableSize
=
std
:
:
max
(
childAvailableSize
bEndRow
)
;
}
return
ReflowRowsInFragmentainer
(
aState
aContentArea
aDesiredSize
aStatus
aFragmentainer
aContainerSize
sortedItems
startRow
endRow
bSize
childAvailableSize
)
;
}
nscoord
nsGridContainerFrame
:
:
ReflowRowsInFragmentainer
(
GridReflowInput
&
aState
const
LogicalRect
&
aContentArea
ReflowOutput
&
aDesiredSize
nsReflowStatus
&
aStatus
Fragmentainer
&
aFragmentainer
const
nsSize
&
aContainerSize
const
nsTArray
<
const
GridItemInfo
*
>
&
aSortedItems
uint32_t
aStartRow
uint32_t
aEndRow
nscoord
aBSize
nscoord
aAvailableSize
)
{
FrameHashtable
pushedItems
;
FrameHashtable
incompleteItems
;
FrameHashtable
overflowIncompleteItems
;
bool
isBDBClone
=
aState
.
mReflowInput
-
>
mStyleBorder
-
>
mBoxDecorationBreak
=
=
StyleBoxDecorationBreak
:
:
Clone
;
bool
didGrowRow
=
false
;
bool
isRowTopOfPage
=
aStartRow
!
=
0
|
|
!
aFragmentainer
.
mCanBreakAtStart
;
const
bool
isStartRowTopOfPage
=
isRowTopOfPage
;
const
nscoord
gridAvailableSize
=
aFragmentainer
.
mToFragmentainerEnd
;
aFragmentainer
.
mToFragmentainerEnd
=
aAvailableSize
;
uint32_t
row
=
0
;
for
(
int32_t
i
=
0
len
=
aSortedItems
.
Length
(
)
;
i
<
len
;
+
+
i
)
{
const
GridItemInfo
*
const
info
=
aSortedItems
[
i
]
;
nsIFrame
*
child
=
info
-
>
mFrame
;
row
=
info
-
>
mArea
.
mRows
.
mStart
;
MOZ_ASSERT
(
child
-
>
GetPrevInFlow
(
)
?
row
<
aStartRow
:
row
>
=
aStartRow
"
unexpected
child
start
row
"
)
;
if
(
row
>
=
aEndRow
)
{
pushedItems
.
PutEntry
(
child
)
;
continue
;
}
bool
rowCanGrow
=
false
;
nscoord
maxRowSize
=
0
;
if
(
row
>
=
aStartRow
)
{
if
(
row
>
aStartRow
)
{
isRowTopOfPage
=
false
;
}
rowCanGrow
=
!
didGrowRow
&
&
info
-
>
mArea
.
mRows
.
Extent
(
)
=
=
1
;
if
(
rowCanGrow
)
{
auto
&
sz
=
aState
.
mRows
.
mSizes
[
row
]
;
rowCanGrow
=
(
sz
.
mState
&
TrackSize
:
:
eMinOrMaxContentMinSizing
)
|
|
(
(
sz
.
mState
&
TrackSize
:
:
eFlexMaxSizing
)
&
&
aFragmentainer
.
mIsAutoBSize
)
;
if
(
rowCanGrow
)
{
if
(
isBDBClone
)
{
maxRowSize
=
gridAvailableSize
-
aState
.
mBorderPadding
.
BEnd
(
aState
.
mWM
)
;
}
else
{
maxRowSize
=
gridAvailableSize
;
}
maxRowSize
-
=
sz
.
mPosition
;
rowCanGrow
=
maxRowSize
>
sz
.
mBase
;
}
}
}
aFragmentainer
.
mIsTopOfPage
=
isRowTopOfPage
&
&
!
rowCanGrow
;
nsReflowStatus
childStatus
;
nscoord
bSize
=
aState
.
mRows
.
GridLineEdge
(
std
:
:
min
(
aEndRow
info
-
>
mArea
.
mRows
.
mEnd
)
GridLineSide
:
:
BeforeGridGap
)
-
aState
.
mRows
.
GridLineEdge
(
std
:
:
max
(
aStartRow
row
)
GridLineSide
:
:
AfterGridGap
)
;
ReflowInFlowChild
(
child
info
aContainerSize
Some
(
bSize
)
&
aFragmentainer
aState
aContentArea
aDesiredSize
childStatus
)
;
MOZ_ASSERT
(
childStatus
.
IsInlineBreakBefore
(
)
|
|
!
childStatus
.
IsFullyComplete
(
)
|
|
!
child
-
>
GetNextInFlow
(
)
"
fully
-
complete
reflow
should
destroy
any
NIFs
"
)
;
if
(
childStatus
.
IsInlineBreakBefore
(
)
)
{
MOZ_ASSERT
(
!
child
-
>
GetPrevInFlow
(
)
"
continuations
should
never
report
InlineBreak
:
:
Before
status
"
)
;
MOZ_ASSERT
(
!
aFragmentainer
.
mIsTopOfPage
"
got
IsInlineBreakBefore
(
)
at
top
of
page
"
)
;
if
(
!
didGrowRow
)
{
if
(
rowCanGrow
)
{
aState
.
mRows
.
ResizeRow
(
row
maxRowSize
)
;
if
(
aState
.
mSharedGridData
)
{
aState
.
mSharedGridData
-
>
mRows
.
ResizeRow
(
row
maxRowSize
)
;
}
didGrowRow
=
true
;
aEndRow
=
row
+
1
;
i
=
-
1
;
isRowTopOfPage
=
isStartRowTopOfPage
;
overflowIncompleteItems
.
Clear
(
)
;
incompleteItems
.
Clear
(
)
;
nscoord
bEndRow
=
aState
.
mRows
.
GridLineEdge
(
aEndRow
GridLineSide
:
:
BeforeGridGap
)
;
aFragmentainer
.
mToFragmentainerEnd
=
bEndRow
;
if
(
aFragmentainer
.
mIsAutoBSize
)
{
aBSize
=
ClampToCSSMaxBSize
(
bEndRow
aState
.
mReflowInput
&
aStatus
)
;
}
else
if
(
aStatus
.
IsIncomplete
(
)
)
{
aBSize
=
NS_CSS_MINMAX
(
aState
.
mReflowInput
-
>
ComputedBSize
(
)
aState
.
mReflowInput
-
>
ComputedMinBSize
(
)
aState
.
mReflowInput
-
>
ComputedMaxBSize
(
)
)
;
aBSize
=
std
:
:
min
(
bEndRow
aBSize
)
;
}
continue
;
}
if
(
!
isRowTopOfPage
)
{
aEndRow
=
row
;
aBSize
=
aState
.
mRows
.
GridLineEdge
(
aEndRow
GridLineSide
:
:
BeforeGridGap
)
;
i
=
-
1
;
isRowTopOfPage
=
isStartRowTopOfPage
;
overflowIncompleteItems
.
Clear
(
)
;
incompleteItems
.
Clear
(
)
;
aStatus
.
SetIncomplete
(
)
;
continue
;
}
NS_ERROR
(
"
got
InlineBreak
:
:
Before
at
top
-
of
-
page
"
)
;
childStatus
.
Reset
(
)
;
}
else
{
childStatus
.
Reset
(
)
;
if
(
child
-
>
GetNextInFlow
(
)
)
{
childStatus
.
SetIncomplete
(
)
;
}
}
}
else
if
(
childStatus
.
IsInlineBreakAfter
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
child
reflow
status
"
)
;
}
MOZ_ASSERT
(
!
childStatus
.
IsInlineBreakBefore
(
)
"
should
'
ve
handled
InlineBreak
:
:
Before
above
"
)
;
if
(
childStatus
.
IsIncomplete
(
)
)
{
incompleteItems
.
PutEntry
(
child
)
;
}
else
if
(
!
childStatus
.
IsFullyComplete
(
)
)
{
overflowIncompleteItems
.
PutEntry
(
child
)
;
}
}
aState
.
mNextFragmentStartRow
=
aEndRow
;
if
(
aEndRow
<
aState
.
mRows
.
mSizes
.
Length
(
)
)
{
aState
.
mRows
.
BreakBeforeRow
(
aEndRow
)
;
if
(
aState
.
mSharedGridData
)
{
aState
.
mSharedGridData
-
>
mRows
.
BreakBeforeRow
(
aEndRow
)
;
}
}
if
(
!
pushedItems
.
IsEmpty
(
)
|
|
!
incompleteItems
.
IsEmpty
(
)
|
|
!
overflowIncompleteItems
.
IsEmpty
(
)
)
{
if
(
aStatus
.
IsComplete
(
)
)
{
aStatus
.
SetOverflowIncomplete
(
)
;
aStatus
.
SetNextInFlowNeedsReflow
(
)
;
}
nsFrameList
pushedList
;
nsFrameList
incompleteList
;
nsFrameList
overflowIncompleteList
;
auto
*
pc
=
PresContext
(
)
;
auto
*
fc
=
pc
-
>
PresShell
(
)
-
>
FrameConstructor
(
)
;
for
(
nsIFrame
*
child
=
GetChildList
(
kPrincipalList
)
.
FirstChild
(
)
;
child
;
)
{
MOZ_ASSERT
(
(
pushedItems
.
Contains
(
child
)
?
1
:
0
)
+
(
incompleteItems
.
Contains
(
child
)
?
1
:
0
)
+
(
overflowIncompleteItems
.
Contains
(
child
)
?
1
:
0
)
<
=
1
"
child
should
only
be
in
one
of
these
sets
"
)
;
nsIFrame
*
next
=
child
-
>
GetNextSibling
(
)
;
if
(
pushedItems
.
Contains
(
child
)
)
{
MOZ_ASSERT
(
child
-
>
GetParent
(
)
=
=
this
)
;
StealFrame
(
child
)
;
pushedList
.
AppendFrame
(
nullptr
child
)
;
}
else
if
(
incompleteItems
.
Contains
(
child
)
)
{
nsIFrame
*
childNIF
=
child
-
>
GetNextInFlow
(
)
;
if
(
!
childNIF
)
{
childNIF
=
fc
-
>
CreateContinuingFrame
(
pc
child
this
)
;
incompleteList
.
AppendFrame
(
nullptr
childNIF
)
;
}
else
{
auto
parent
=
static_cast
<
nsGridContainerFrame
*
>
(
childNIF
-
>
GetParent
(
)
)
;
MOZ_ASSERT
(
parent
!
=
this
|
|
!
mFrames
.
ContainsFrame
(
childNIF
)
"
child
'
s
NIF
shouldn
'
t
be
in
the
same
principal
list
"
)
;
if
(
(
childNIF
-
>
GetStateBits
(
)
&
NS_FRAME_IS_OVERFLOW_CONTAINER
)
|
|
(
parent
!
=
this
&
&
parent
!
=
GetNextInFlow
(
)
)
)
{
parent
-
>
StealFrame
(
childNIF
)
;
childNIF
-
>
RemoveStateBits
(
NS_FRAME_IS_OVERFLOW_CONTAINER
)
;
if
(
parent
=
=
this
)
{
incompleteList
.
AppendFrame
(
nullptr
childNIF
)
;
}
else
{
if
(
parent
=
=
GetNextInFlow
(
)
)
{
nsFrameList
toMove
(
childNIF
childNIF
)
;
parent
-
>
MergeSortedOverflow
(
toMove
)
;
}
else
{
ReparentFrame
(
childNIF
parent
this
)
;
incompleteList
.
AppendFrame
(
nullptr
childNIF
)
;
}
}
}
}
}
else
if
(
overflowIncompleteItems
.
Contains
(
child
)
)
{
nsIFrame
*
childNIF
=
child
-
>
GetNextInFlow
(
)
;
if
(
!
childNIF
)
{
childNIF
=
fc
-
>
CreateContinuingFrame
(
pc
child
this
)
;
childNIF
-
>
AddStateBits
(
NS_FRAME_IS_OVERFLOW_CONTAINER
)
;
overflowIncompleteList
.
AppendFrame
(
nullptr
childNIF
)
;
}
else
{
DebugOnly
<
nsGridContainerFrame
*
>
lastParent
=
this
;
auto
nif
=
static_cast
<
nsGridContainerFrame
*
>
(
GetNextInFlow
(
)
)
;
while
(
childNIF
&
&
!
childNIF
-
>
HasAnyStateBits
(
NS_FRAME_IS_OVERFLOW_CONTAINER
)
)
{
auto
parent
=
static_cast
<
nsGridContainerFrame
*
>
(
childNIF
-
>
GetParent
(
)
)
;
parent
-
>
StealFrame
(
childNIF
)
;
childNIF
-
>
AddStateBits
(
NS_FRAME_IS_OVERFLOW_CONTAINER
)
;
if
(
parent
=
=
this
)
{
overflowIncompleteList
.
AppendFrame
(
nullptr
childNIF
)
;
}
else
{
if
(
!
nif
|
|
parent
=
=
nif
)
{
nsFrameList
toMove
(
childNIF
childNIF
)
;
parent
-
>
MergeSortedExcessOverflowContainers
(
toMove
)
;
}
else
{
ReparentFrame
(
childNIF
parent
nif
)
;
nsFrameList
toMove
(
childNIF
childNIF
)
;
nif
-
>
MergeSortedExcessOverflowContainers
(
toMove
)
;
}
nif
=
nullptr
;
}
lastParent
=
parent
;
childNIF
=
childNIF
-
>
GetNextInFlow
(
)
;
}
}
}
child
=
next
;
}
if
(
!
pushedList
.
IsEmpty
(
)
)
{
MergeSortedOverflow
(
pushedList
)
;
AddStateBits
(
NS_STATE_GRID_DID_PUSH_ITEMS
)
;
aState
.
mIter
.
Invalidate
(
)
;
}
if
(
!
incompleteList
.
IsEmpty
(
)
)
{
MergeSortedOverflow
(
incompleteList
)
;
aState
.
mIter
.
Invalidate
(
)
;
}
if
(
!
overflowIncompleteList
.
IsEmpty
(
)
)
{
MergeSortedExcessOverflowContainers
(
overflowIncompleteList
)
;
}
}
return
aBSize
;
}
nsGridContainerFrame
*
nsGridContainerFrame
:
:
ParentGridContainerForSubgrid
(
)
const
{
MOZ_ASSERT
(
IsSubgrid
(
)
)
;
nsIFrame
*
p
=
GetParent
(
)
;
while
(
p
-
>
GetContent
(
)
=
=
GetContent
(
)
)
{
p
=
p
-
>
GetParent
(
)
;
}
MOZ_ASSERT
(
p
-
>
IsGridContainerFrame
(
)
)
;
auto
*
parent
=
static_cast
<
nsGridContainerFrame
*
>
(
p
)
;
MOZ_ASSERT
(
parent
-
>
HasSubgridItems
(
)
)
;
return
parent
;
}
nscoord
nsGridContainerFrame
:
:
ReflowChildren
(
GridReflowInput
&
aState
const
LogicalRect
&
aContentArea
ReflowOutput
&
aDesiredSize
nsReflowStatus
&
aStatus
)
{
MOZ_ASSERT
(
aState
.
mReflowInput
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
nsOverflowAreas
ocBounds
;
nsReflowStatus
ocStatus
;
if
(
GetPrevInFlow
(
)
)
{
ReflowOverflowContainerChildren
(
PresContext
(
)
*
aState
.
mReflowInput
ocBounds
0
ocStatus
MergeSortedFrameListsFor
)
;
}
WritingMode
wm
=
aState
.
mReflowInput
-
>
GetWritingMode
(
)
;
const
nsSize
containerSize
=
(
aContentArea
.
Size
(
wm
)
+
aState
.
mBorderPadding
.
Size
(
wm
)
)
.
GetPhysicalSize
(
wm
)
;
nscoord
bSize
=
aContentArea
.
BSize
(
wm
)
;
Maybe
<
Fragmentainer
>
fragmentainer
=
GetNearestFragmentainer
(
aState
)
;
if
(
MOZ_UNLIKELY
(
fragmentainer
.
isSome
(
)
)
)
{
aState
.
mInFragmentainer
=
true
;
bSize
=
ReflowInFragmentainer
(
aState
aContentArea
aDesiredSize
aStatus
*
fragmentainer
containerSize
)
;
}
else
{
aState
.
mIter
.
Reset
(
CSSOrderAwareFrameIterator
:
:
eIncludeAll
)
;
for
(
;
!
aState
.
mIter
.
AtEnd
(
)
;
aState
.
mIter
.
Next
(
)
)
{
nsIFrame
*
child
=
*
aState
.
mIter
;
const
GridItemInfo
*
info
=
nullptr
;
if
(
!
child
-
>
IsPlaceholderFrame
(
)
)
{
info
=
&
aState
.
mGridItems
[
aState
.
mIter
.
ItemIndex
(
)
]
;
}
ReflowInFlowChild
(
*
aState
.
mIter
info
containerSize
Nothing
(
)
nullptr
aState
aContentArea
aDesiredSize
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsComplete
(
)
"
child
should
be
complete
"
"
in
unconstrained
reflow
"
)
;
}
}
aDesiredSize
.
mOverflowAreas
.
UnionWith
(
ocBounds
)
;
aStatus
.
MergeCompletionStatusFrom
(
ocStatus
)
;
if
(
IsAbsoluteContainer
(
)
)
{
nsFrameList
children
(
GetChildList
(
GetAbsoluteListID
(
)
)
)
;
if
(
!
children
.
IsEmpty
(
)
)
{
LogicalMargin
pad
(
aState
.
mReflowInput
-
>
ComputedLogicalPadding
(
)
)
;
const
LogicalPoint
gridOrigin
(
wm
pad
.
IStart
(
wm
)
pad
.
BStart
(
wm
)
)
;
const
LogicalRect
gridCB
(
wm
0
0
aContentArea
.
ISize
(
wm
)
+
pad
.
IStartEnd
(
wm
)
bSize
+
pad
.
BStartEnd
(
wm
)
)
;
const
nsSize
gridCBPhysicalSize
=
gridCB
.
Size
(
wm
)
.
GetPhysicalSize
(
wm
)
;
size_t
i
=
0
;
for
(
nsFrameList
:
:
Enumerator
e
(
children
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
+
+
i
)
{
nsIFrame
*
child
=
e
.
get
(
)
;
MOZ_ASSERT
(
i
<
aState
.
mAbsPosItems
.
Length
(
)
)
;
MOZ_ASSERT
(
aState
.
mAbsPosItems
[
i
]
.
mFrame
=
=
child
)
;
GridArea
&
area
=
aState
.
mAbsPosItems
[
i
]
.
mArea
;
LogicalRect
itemCB
=
aState
.
ContainingBlockForAbsPos
(
area
gridOrigin
gridCB
)
;
nsRect
*
cb
=
child
-
>
GetProperty
(
GridItemContainingBlockRect
(
)
)
;
if
(
!
cb
)
{
cb
=
new
nsRect
;
child
-
>
SetProperty
(
GridItemContainingBlockRect
(
)
cb
)
;
}
*
cb
=
itemCB
.
GetPhysicalRect
(
wm
gridCBPhysicalSize
)
;
}
nsRect
dummyRect
;
AbsPosReflowFlags
flags
=
AbsPosReflowFlags
:
:
CBWidthAndHeightChanged
;
flags
|
=
AbsPosReflowFlags
:
:
ConstrainHeight
;
flags
|
=
AbsPosReflowFlags
:
:
IsGridContainerCB
;
GetAbsoluteContainingBlock
(
)
-
>
Reflow
(
this
PresContext
(
)
*
aState
.
mReflowInput
aStatus
dummyRect
flags
&
aDesiredSize
.
mOverflowAreas
)
;
}
}
return
bSize
;
}
void
nsGridContainerFrame
:
:
NormalizeChildLists
(
)
{
auto
prevInFlow
=
static_cast
<
nsGridContainerFrame
*
>
(
GetPrevInFlow
(
)
)
;
if
(
prevInFlow
)
{
AutoFrameListPtr
overflow
(
PresContext
(
)
prevInFlow
-
>
StealOverflowFrames
(
)
)
;
if
(
overflow
)
{
ReparentFrames
(
*
overflow
prevInFlow
this
)
;
:
:
MergeSortedFrameLists
(
mFrames
*
overflow
GetContent
(
)
)
;
nsFrameList
continuations
;
for
(
nsIFrame
*
f
=
mFrames
.
FirstChild
(
)
;
f
;
)
{
nsIFrame
*
next
=
f
-
>
GetNextSibling
(
)
;
nsIFrame
*
pif
=
f
-
>
GetPrevInFlow
(
)
;
if
(
pif
&
&
pif
-
>
GetParent
(
)
=
=
this
)
{
mFrames
.
RemoveFrame
(
f
)
;
continuations
.
AppendFrame
(
nullptr
f
)
;
}
f
=
next
;
}
MergeSortedOverflow
(
continuations
)
;
nsFrameList
*
overflowContainers
=
GetPropTableFrames
(
OverflowContainersProperty
(
)
)
;
if
(
overflowContainers
)
{
nsFrameList
moveToEOC
;
for
(
nsIFrame
*
f
=
overflowContainers
-
>
FirstChild
(
)
;
f
;
)
{
nsIFrame
*
next
=
f
-
>
GetNextSibling
(
)
;
nsIFrame
*
pif
=
f
-
>
GetPrevInFlow
(
)
;
if
(
pif
&
&
pif
-
>
GetParent
(
)
=
=
this
)
{
overflowContainers
-
>
RemoveFrame
(
f
)
;
moveToEOC
.
AppendFrame
(
nullptr
f
)
;
}
f
=
next
;
}
if
(
overflowContainers
-
>
IsEmpty
(
)
)
{
DeleteProperty
(
OverflowContainersProperty
(
)
)
;
}
MergeSortedExcessOverflowContainers
(
moveToEOC
)
;
}
}
}
DebugOnly
<
bool
>
foundOwnPushedChild
=
false
;
{
nsFrameList
*
ourOverflow
=
GetOverflowFrames
(
)
;
if
(
ourOverflow
)
{
nsFrameList
items
;
for
(
nsIFrame
*
f
=
ourOverflow
-
>
FirstChild
(
)
;
f
;
)
{
nsIFrame
*
next
=
f
-
>
GetNextSibling
(
)
;
nsIFrame
*
pif
=
f
-
>
GetPrevInFlow
(
)
;
if
(
!
pif
|
|
pif
-
>
GetParent
(
)
!
=
this
)
{
MOZ_ASSERT
(
f
-
>
GetParent
(
)
=
=
this
)
;
ourOverflow
-
>
RemoveFrame
(
f
)
;
items
.
AppendFrame
(
nullptr
f
)
;
if
(
!
pif
)
{
foundOwnPushedChild
=
true
;
}
}
f
=
next
;
}
:
:
MergeSortedFrameLists
(
mFrames
items
GetContent
(
)
)
;
if
(
ourOverflow
-
>
IsEmpty
(
)
)
{
DestroyOverflowList
(
)
;
}
}
}
if
(
HasAnyStateBits
(
NS_STATE_GRID_HAS_CHILD_NIFS
)
)
{
nsFrameList
framesToPush
;
nsIFrame
*
firstChild
=
mFrames
.
FirstChild
(
)
;
for
(
auto
child
=
firstChild
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
auto
*
childNIF
=
child
-
>
GetNextInFlow
(
)
)
{
if
(
childNIF
-
>
GetParent
(
)
=
=
this
)
{
for
(
auto
c
=
child
-
>
GetNextSibling
(
)
;
c
;
c
=
c
-
>
GetNextSibling
(
)
)
{
if
(
c
=
=
childNIF
)
{
mFrames
.
RemoveFrame
(
childNIF
)
;
framesToPush
.
AppendFrame
(
nullptr
childNIF
)
;
break
;
}
}
}
}
}
if
(
!
framesToPush
.
IsEmpty
(
)
)
{
MergeSortedOverflow
(
framesToPush
)
;
}
RemoveStateBits
(
NS_STATE_GRID_HAS_CHILD_NIFS
)
;
}
if
(
HasAnyStateBits
(
NS_STATE_GRID_DID_PUSH_ITEMS
)
)
{
RemoveStateBits
(
NS_STATE_GRID_DID_PUSH_ITEMS
)
;
nsFrameList
items
;
auto
nif
=
static_cast
<
nsGridContainerFrame
*
>
(
GetNextInFlow
(
)
)
;
auto
firstNIF
=
nif
;
DebugOnly
<
bool
>
nifNeedPushedItem
=
false
;
while
(
nif
)
{
nsFrameList
nifItems
;
for
(
nsIFrame
*
nifChild
=
nif
-
>
GetChildList
(
kPrincipalList
)
.
FirstChild
(
)
;
nifChild
;
)
{
nsIFrame
*
next
=
nifChild
-
>
GetNextSibling
(
)
;
if
(
!
nifChild
-
>
GetPrevInFlow
(
)
)
{
nif
-
>
StealFrame
(
nifChild
)
;
ReparentFrame
(
nifChild
nif
this
)
;
nifItems
.
AppendFrame
(
nullptr
nifChild
)
;
nifNeedPushedItem
=
false
;
}
nifChild
=
next
;
}
:
:
MergeSortedFrameLists
(
items
nifItems
GetContent
(
)
)
;
if
(
!
nif
-
>
HasAnyStateBits
(
NS_STATE_GRID_DID_PUSH_ITEMS
)
)
{
MOZ_ASSERT
(
!
nifNeedPushedItem
|
|
mDidPushItemsBitMayLie
"
NS_STATE_GRID_DID_PUSH_ITEMS
lied
"
)
;
break
;
}
nifNeedPushedItem
=
true
;
for
(
nsIFrame
*
nifChild
=
nif
-
>
GetChildList
(
kOverflowList
)
.
FirstChild
(
)
;
nifChild
;
)
{
nsIFrame
*
next
=
nifChild
-
>
GetNextSibling
(
)
;
if
(
!
nifChild
-
>
GetPrevInFlow
(
)
)
{
nif
-
>
StealFrame
(
nifChild
)
;
ReparentFrame
(
nifChild
nif
this
)
;
nifItems
.
AppendFrame
(
nullptr
nifChild
)
;
nifNeedPushedItem
=
false
;
}
nifChild
=
next
;
}
:
:
MergeSortedFrameLists
(
items
nifItems
GetContent
(
)
)
;
nif
-
>
RemoveStateBits
(
NS_STATE_GRID_DID_PUSH_ITEMS
)
;
nif
=
static_cast
<
nsGridContainerFrame
*
>
(
nif
-
>
GetNextInFlow
(
)
)
;
MOZ_ASSERT
(
nif
|
|
!
nifNeedPushedItem
|
|
mDidPushItemsBitMayLie
"
NS_STATE_GRID_DID_PUSH_ITEMS
lied
"
)
;
}
if
(
!
items
.
IsEmpty
(
)
)
{
nsFrameList
childNIFs
;
nsFrameList
childOCNIFs
;
for
(
auto
child
:
items
)
{
auto
childNIF
=
child
-
>
GetNextInFlow
(
)
;
if
(
childNIF
&
&
childNIF
-
>
GetParent
(
)
!
=
firstNIF
)
{
auto
parent
=
childNIF
-
>
GetParent
(
)
;
parent
-
>
StealFrame
(
childNIF
)
;
ReparentFrame
(
childNIF
parent
firstNIF
)
;
if
(
(
childNIF
-
>
GetStateBits
(
)
&
NS_FRAME_IS_OVERFLOW_CONTAINER
)
)
{
childOCNIFs
.
AppendFrame
(
nullptr
childNIF
)
;
}
else
{
childNIFs
.
AppendFrame
(
nullptr
childNIF
)
;
}
}
}
firstNIF
-
>
MergeSortedOverflow
(
childNIFs
)
;
firstNIF
-
>
MergeSortedExcessOverflowContainers
(
childOCNIFs
)
;
}
MOZ_ASSERT
(
foundOwnPushedChild
|
|
!
items
.
IsEmpty
(
)
|
|
mDidPushItemsBitMayLie
"
NS_STATE_GRID_DID_PUSH_ITEMS
lied
"
)
;
:
:
MergeSortedFrameLists
(
mFrames
items
GetContent
(
)
)
;
}
}
void
nsGridContainerFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsGridContainerFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aDesiredSize
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
if
(
IsFrameTreeTooDeep
(
aReflowInput
aDesiredSize
aStatus
)
)
{
return
;
}
NormalizeChildLists
(
)
;
#
ifdef
DEBUG
mDidPushItemsBitMayLie
=
false
;
SanityCheckGridItemsBeforeReflow
(
)
;
#
endif
for
(
auto
&
perAxisBaseline
:
mBaseline
)
{
for
(
auto
&
baseline
:
perAxisBaseline
)
{
baseline
=
NS_INTRINSIC_ISIZE_UNKNOWN
;
}
}
const
nsStylePosition
*
stylePos
=
aReflowInput
.
mStylePosition
;
auto
prevInFlow
=
static_cast
<
nsGridContainerFrame
*
>
(
GetPrevInFlow
(
)
)
;
if
(
MOZ_LIKELY
(
!
prevInFlow
)
)
{
InitImplicitNamedAreas
(
stylePos
)
;
}
else
{
MOZ_ASSERT
(
(
prevInFlow
-
>
GetStateBits
(
)
&
kIsSubgridBits
)
=
=
(
GetStateBits
(
)
&
kIsSubgridBits
)
"
continuations
should
have
same
kIsSubgridBits
"
)
;
}
GridReflowInput
gridReflowInput
(
this
aReflowInput
)
;
if
(
gridReflowInput
.
mIter
.
ItemsAreAlreadyInOrder
(
)
)
{
AddStateBits
(
NS_STATE_GRID_NORMAL_FLOW_CHILDREN_IN_CSS_ORDER
)
;
}
else
{
RemoveStateBits
(
NS_STATE_GRID_NORMAL_FLOW_CHILDREN_IN_CSS_ORDER
)
;
}
if
(
gridReflowInput
.
mIter
.
AtEnd
(
)
|
|
aReflowInput
.
mStyleDisplay
-
>
IsContainLayout
(
)
)
{
AddStateBits
(
NS_STATE_GRID_SYNTHESIZE_BASELINE
)
;
}
else
{
RemoveStateBits
(
NS_STATE_GRID_SYNTHESIZE_BASELINE
)
;
}
const
nscoord
computedBSize
=
aReflowInput
.
ComputedBSize
(
)
;
const
nscoord
computedISize
=
aReflowInput
.
ComputedISize
(
)
;
const
WritingMode
&
wm
=
gridReflowInput
.
mWM
;
const
LogicalSize
computedSize
(
wm
computedISize
computedBSize
)
;
nscoord
consumedBSize
=
0
;
nscoord
bSize
=
0
;
if
(
MOZ_LIKELY
(
!
prevInFlow
)
)
{
Grid
grid
;
if
(
MOZ_LIKELY
(
!
IsSubgrid
(
)
)
)
{
RepeatTrackSizingInput
repeatSizing
(
aReflowInput
.
ComputedMinSize
(
)
computedSize
aReflowInput
.
ComputedMaxSize
(
)
)
;
grid
.
PlaceGridItems
(
gridReflowInput
repeatSizing
)
;
}
else
{
auto
*
subgrid
=
GetProperty
(
Subgrid
:
:
Prop
(
)
)
;
MOZ_ASSERT
(
subgrid
"
an
ancestor
forgot
to
call
PlaceGridItems
?
"
)
;
gridReflowInput
.
mGridItems
=
subgrid
-
>
mGridItems
;
gridReflowInput
.
mAbsPosItems
=
subgrid
-
>
mAbsPosItems
;
grid
.
mGridColEnd
=
subgrid
-
>
mGridColEnd
;
grid
.
mGridRowEnd
=
subgrid
-
>
mGridRowEnd
;
}
gridReflowInput
.
CalculateTrackSizes
(
grid
computedSize
SizingConstraint
:
:
NoConstraint
)
;
if
(
!
aReflowInput
.
mStyleDisplay
-
>
IsContainSize
(
)
)
{
const
auto
&
rowSizes
=
gridReflowInput
.
mRows
.
mSizes
;
if
(
MOZ_LIKELY
(
!
IsSubgrid
(
eLogicalAxisBlock
)
)
)
{
for
(
const
auto
&
sz
:
rowSizes
)
{
bSize
+
=
sz
.
mBase
;
}
bSize
+
=
gridReflowInput
.
mRows
.
SumOfGridGaps
(
)
;
}
else
if
(
computedBSize
=
=
NS_UNCONSTRAINEDSIZE
)
{
bSize
=
gridReflowInput
.
mRows
.
GridLineEdge
(
rowSizes
.
Length
(
)
GridLineSide
:
:
BeforeGridGap
)
;
}
}
}
else
{
consumedBSize
=
ConsumedBSize
(
wm
)
;
gridReflowInput
.
InitializeForContinuation
(
this
consumedBSize
)
;
if
(
!
aReflowInput
.
mStyleDisplay
-
>
IsContainSize
(
)
)
{
const
uint32_t
numRows
=
gridReflowInput
.
mRows
.
mSizes
.
Length
(
)
;
bSize
=
gridReflowInput
.
mRows
.
GridLineEdge
(
numRows
GridLineSide
:
:
AfterGridGap
)
;
}
}
if
(
computedBSize
=
=
NS_UNCONSTRAINEDSIZE
)
{
bSize
=
NS_CSS_MINMAX
(
bSize
aReflowInput
.
ComputedMinBSize
(
)
aReflowInput
.
ComputedMaxBSize
(
)
)
;
}
else
{
bSize
=
computedBSize
;
}
bSize
=
std
:
:
max
(
bSize
-
consumedBSize
0
)
;
auto
&
bp
=
gridReflowInput
.
mBorderPadding
;
LogicalRect
contentArea
(
wm
bp
.
IStart
(
wm
)
bp
.
BStart
(
wm
)
computedISize
bSize
)
;
if
(
!
prevInFlow
)
{
const
auto
&
rowSizes
=
gridReflowInput
.
mRows
.
mSizes
;
if
(
!
IsRowSubgrid
(
)
)
{
if
(
computedBSize
=
=
NS_UNCONSTRAINEDSIZE
&
&
stylePos
-
>
mRowGap
.
IsLengthPercentage
(
)
&
&
stylePos
-
>
mRowGap
.
AsLengthPercentage
(
)
.
HasPercent
(
)
)
{
gridReflowInput
.
mRows
.
mGridGap
=
nsLayoutUtils
:
:
ResolveGapToLength
(
stylePos
-
>
mRowGap
bSize
)
;
}
gridReflowInput
.
mRows
.
AlignJustifyContent
(
stylePos
wm
bSize
false
)
;
}
else
{
if
(
computedBSize
=
=
NS_UNCONSTRAINEDSIZE
)
{
bSize
=
gridReflowInput
.
mRows
.
GridLineEdge
(
rowSizes
.
Length
(
)
GridLineSide
:
:
BeforeGridGap
)
;
contentArea
.
BSize
(
wm
)
=
bSize
;
}
}
if
(
HasSubgridItems
(
)
|
|
IsSubgrid
(
)
)
{
StoreUsedTrackSizes
(
eLogicalAxisBlock
rowSizes
)
;
}
}
bSize
=
ReflowChildren
(
gridReflowInput
contentArea
aDesiredSize
aStatus
)
;
bSize
=
std
:
:
max
(
bSize
-
consumedBSize
0
)
;
if
(
!
aStatus
.
IsComplete
(
)
&
&
!
gridReflowInput
.
mSkipSides
.
BEnd
(
)
&
&
StyleBorder
(
)
-
>
mBoxDecorationBreak
!
=
StyleBoxDecorationBreak
:
:
Clone
)
{
bp
.
BEnd
(
wm
)
=
nscoord
(
0
)
;
}
LogicalSize
desiredSize
(
wm
computedISize
+
bp
.
IStartEnd
(
wm
)
bSize
+
bp
.
BStartEnd
(
wm
)
)
;
aDesiredSize
.
SetSize
(
wm
desiredSize
)
;
nsRect
frameRect
(
0
0
aDesiredSize
.
Width
(
)
aDesiredSize
.
Height
(
)
)
;
aDesiredSize
.
mOverflowAreas
.
UnionAllWith
(
frameRect
)
;
if
(
HasAnyStateBits
(
NS_FRAME_IS_OVERFLOW_CONTAINER
)
)
{
if
(
!
aStatus
.
IsComplete
(
)
)
{
aStatus
.
SetOverflowIncomplete
(
)
;
aStatus
.
SetNextInFlowNeedsReflow
(
)
;
}
bSize
=
0
;
desiredSize
.
BSize
(
wm
)
=
bSize
+
bp
.
BStartEnd
(
wm
)
;
aDesiredSize
.
SetSize
(
wm
desiredSize
)
;
}
if
(
!
gridReflowInput
.
mInFragmentainer
)
{
MOZ_ASSERT
(
gridReflowInput
.
mIter
.
IsValid
(
)
)
;
auto
sz
=
frameRect
.
Size
(
)
;
CalculateBaselines
(
BaselineSet
:
:
eBoth
&
gridReflowInput
.
mIter
&
gridReflowInput
.
mGridItems
gridReflowInput
.
mCols
0
gridReflowInput
.
mCols
.
mSizes
.
Length
(
)
wm
sz
bp
.
IStart
(
wm
)
bp
.
IEnd
(
wm
)
desiredSize
.
ISize
(
wm
)
)
;
CalculateBaselines
(
BaselineSet
:
:
eBoth
&
gridReflowInput
.
mIter
&
gridReflowInput
.
mGridItems
gridReflowInput
.
mRows
0
gridReflowInput
.
mRows
.
mSizes
.
Length
(
)
wm
sz
bp
.
BStart
(
wm
)
bp
.
BEnd
(
wm
)
desiredSize
.
BSize
(
wm
)
)
;
}
else
{
BaselineSet
baselines
=
BaselineSet
:
:
eNone
;
if
(
gridReflowInput
.
mStartRow
=
=
0
&
&
gridReflowInput
.
mStartRow
!
=
gridReflowInput
.
mNextFragmentStartRow
)
{
baselines
=
BaselineSet
:
:
eFirst
;
}
uint32_t
len
=
gridReflowInput
.
mRows
.
mSizes
.
Length
(
)
;
if
(
gridReflowInput
.
mStartRow
!
=
len
&
&
gridReflowInput
.
mNextFragmentStartRow
=
=
len
)
{
baselines
=
BaselineSet
(
baselines
|
BaselineSet
:
:
eLast
)
;
}
Maybe
<
CSSOrderAwareFrameIterator
>
iter
;
Maybe
<
nsTArray
<
GridItemInfo
>
>
gridItems
;
if
(
baselines
!
=
BaselineSet
:
:
eNone
)
{
using
Filter
=
CSSOrderAwareFrameIterator
:
:
ChildFilter
;
using
Order
=
CSSOrderAwareFrameIterator
:
:
OrderState
;
bool
ordered
=
gridReflowInput
.
mIter
.
ItemsAreAlreadyInOrder
(
)
;
auto
orderState
=
ordered
?
Order
:
:
eKnownOrdered
:
Order
:
:
eKnownUnordered
;
iter
.
emplace
(
this
kPrincipalList
Filter
:
:
eSkipPlaceholders
orderState
)
;
gridItems
.
emplace
(
)
;
for
(
;
!
iter
-
>
AtEnd
(
)
;
iter
-
>
Next
(
)
)
{
auto
child
=
*
*
iter
;
for
(
const
auto
&
info
:
gridReflowInput
.
mGridItems
)
{
if
(
info
.
mFrame
=
=
child
)
{
gridItems
-
>
AppendElement
(
info
)
;
}
}
}
}
auto
sz
=
frameRect
.
Size
(
)
;
CalculateBaselines
(
baselines
iter
.
ptrOr
(
nullptr
)
gridItems
.
ptrOr
(
nullptr
)
gridReflowInput
.
mCols
0
gridReflowInput
.
mCols
.
mSizes
.
Length
(
)
wm
sz
bp
.
IStart
(
wm
)
bp
.
IEnd
(
wm
)
desiredSize
.
ISize
(
wm
)
)
;
CalculateBaselines
(
baselines
iter
.
ptrOr
(
nullptr
)
gridItems
.
ptrOr
(
nullptr
)
gridReflowInput
.
mRows
gridReflowInput
.
mStartRow
gridReflowInput
.
mNextFragmentStartRow
wm
sz
bp
.
BStart
(
wm
)
bp
.
BEnd
(
wm
)
desiredSize
.
BSize
(
wm
)
)
;
}
if
(
HasAnyStateBits
(
NS_STATE_GRID_GENERATE_COMPUTED_VALUES
)
)
{
uint32_t
colTrackCount
=
gridReflowInput
.
mCols
.
mSizes
.
Length
(
)
;
nsTArray
<
nscoord
>
colTrackPositions
(
colTrackCount
)
;
nsTArray
<
nscoord
>
colTrackSizes
(
colTrackCount
)
;
nsTArray
<
uint32_t
>
colTrackStates
(
colTrackCount
)
;
nsTArray
<
bool
>
colRemovedRepeatTracks
(
gridReflowInput
.
mColFunctions
.
mRemovedRepeatTracks
)
;
uint32_t
col
=
0
;
for
(
const
TrackSize
&
sz
:
gridReflowInput
.
mCols
.
mSizes
)
{
colTrackPositions
.
AppendElement
(
sz
.
mPosition
)
;
colTrackSizes
.
AppendElement
(
sz
.
mBase
)
;
bool
isRepeat
=
(
(
col
>
=
gridReflowInput
.
mColFunctions
.
mRepeatAutoStart
)
&
&
(
col
<
gridReflowInput
.
mColFunctions
.
mRepeatAutoEnd
)
)
;
colTrackStates
.
AppendElement
(
isRepeat
?
(
uint32_t
)
mozilla
:
:
dom
:
:
GridTrackState
:
:
Repeat
:
(
uint32_t
)
mozilla
:
:
dom
:
:
GridTrackState
:
:
Static
)
;
col
+
+
;
}
ComputedGridTrackInfo
*
colInfo
=
new
ComputedGridTrackInfo
(
gridReflowInput
.
mColFunctions
.
mExplicitGridOffset
IsSubgrid
(
eLogicalAxisInline
)
?
colTrackSizes
.
Length
(
)
:
gridReflowInput
.
mColFunctions
.
NumExplicitTracks
(
)
0
col
std
:
:
move
(
colTrackPositions
)
std
:
:
move
(
colTrackSizes
)
std
:
:
move
(
colTrackStates
)
std
:
:
move
(
colRemovedRepeatTracks
)
gridReflowInput
.
mColFunctions
.
mRepeatAutoStart
)
;
SetProperty
(
GridColTrackInfo
(
)
colInfo
)
;
uint32_t
rowTrackCount
=
gridReflowInput
.
mRows
.
mSizes
.
Length
(
)
;
nsTArray
<
nscoord
>
rowTrackPositions
(
rowTrackCount
)
;
nsTArray
<
nscoord
>
rowTrackSizes
(
rowTrackCount
)
;
nsTArray
<
uint32_t
>
rowTrackStates
(
rowTrackCount
)
;
nsTArray
<
bool
>
rowRemovedRepeatTracks
(
gridReflowInput
.
mRowFunctions
.
mRemovedRepeatTracks
)
;
uint32_t
row
=
0
;
for
(
const
TrackSize
&
sz
:
gridReflowInput
.
mRows
.
mSizes
)
{
rowTrackPositions
.
AppendElement
(
sz
.
mPosition
)
;
rowTrackSizes
.
AppendElement
(
sz
.
mBase
)
;
bool
isRepeat
=
(
(
row
>
=
gridReflowInput
.
mRowFunctions
.
mRepeatAutoStart
)
&
&
(
row
<
gridReflowInput
.
mRowFunctions
.
mRepeatAutoEnd
)
)
;
rowTrackStates
.
AppendElement
(
isRepeat
?
(
uint32_t
)
mozilla
:
:
dom
:
:
GridTrackState
:
:
Repeat
:
(
uint32_t
)
mozilla
:
:
dom
:
:
GridTrackState
:
:
Static
)
;
row
+
+
;
}
ComputedGridTrackInfo
*
rowInfo
=
new
ComputedGridTrackInfo
(
gridReflowInput
.
mRowFunctions
.
mExplicitGridOffset
IsSubgrid
(
eLogicalAxisBlock
)
?
rowTrackSizes
.
Length
(
)
:
gridReflowInput
.
mRowFunctions
.
NumExplicitTracks
(
)
gridReflowInput
.
mStartRow
row
std
:
:
move
(
rowTrackPositions
)
std
:
:
move
(
rowTrackSizes
)
std
:
:
move
(
rowTrackStates
)
std
:
:
move
(
rowRemovedRepeatTracks
)
gridReflowInput
.
mRowFunctions
.
mRepeatAutoStart
)
;
SetProperty
(
GridRowTrackInfo
(
)
rowInfo
)
;
if
(
prevInFlow
)
{
ComputedGridTrackInfo
*
priorRowInfo
=
prevInFlow
-
>
GetProperty
(
GridRowTrackInfo
(
)
)
;
if
(
priorRowInfo
-
>
mPositions
.
Length
(
)
>
priorRowInfo
-
>
mStartFragmentTrack
)
{
nscoord
delta
=
priorRowInfo
-
>
mPositions
[
priorRowInfo
-
>
mStartFragmentTrack
]
;
for
(
nscoord
&
pos
:
priorRowInfo
-
>
mPositions
)
{
pos
-
=
delta
;
}
}
ComputedGridTrackInfo
*
revisedPriorRowInfo
=
new
ComputedGridTrackInfo
(
priorRowInfo
-
>
mNumLeadingImplicitTracks
priorRowInfo
-
>
mNumExplicitTracks
priorRowInfo
-
>
mStartFragmentTrack
gridReflowInput
.
mStartRow
std
:
:
move
(
priorRowInfo
-
>
mPositions
)
std
:
:
move
(
priorRowInfo
-
>
mSizes
)
std
:
:
move
(
priorRowInfo
-
>
mStates
)
std
:
:
move
(
priorRowInfo
-
>
mRemovedRepeatTracks
)
priorRowInfo
-
>
mRepeatFirstTrack
)
;
prevInFlow
-
>
SetProperty
(
GridRowTrackInfo
(
)
revisedPriorRowInfo
)
;
}
uint32_t
capacity
=
gridReflowInput
.
mCols
.
mSizes
.
Length
(
)
;
const
nsStyleGridTemplate
&
gridColTemplate
=
gridReflowInput
.
mGridStyle
-
>
GridTemplateColumns
(
)
;
nsTArray
<
nsTArray
<
RefPtr
<
nsAtom
>
>
>
columnLineNames
(
capacity
)
;
for
(
col
=
0
;
col
<
=
gridReflowInput
.
mCols
.
mSizes
.
Length
(
)
;
col
+
+
)
{
nsTArray
<
RefPtr
<
nsAtom
>
>
explicitNames
=
gridReflowInput
.
mCols
.
GetExplicitLineNamesAtIndex
(
gridColTemplate
gridReflowInput
.
mColFunctions
col
-
gridReflowInput
.
mColFunctions
.
mExplicitGridOffset
)
;
columnLineNames
.
AppendElement
(
explicitNames
)
;
}
nsTArray
<
RefPtr
<
nsAtom
>
>
colNamesFollowingRepeat
;
if
(
gridColTemplate
.
HasRepeatAuto
(
)
)
{
uint32_t
repeatAutoEnd
=
gridColTemplate
.
mRepeatAutoIndex
+
1
;
MOZ_ASSERT
(
repeatAutoEnd
<
gridColTemplate
.
mLineNameLists
.
Length
(
)
)
;
colNamesFollowingRepeat
.
AppendElements
(
gridColTemplate
.
mLineNameLists
[
repeatAutoEnd
]
)
;
}
ComputedGridLineInfo
*
columnLineInfo
=
new
ComputedGridLineInfo
(
std
:
:
move
(
columnLineNames
)
gridColTemplate
.
mRepeatAutoLineNameListBefore
gridColTemplate
.
mRepeatAutoLineNameListAfter
std
:
:
move
(
colNamesFollowingRepeat
)
)
;
SetProperty
(
GridColumnLineInfo
(
)
columnLineInfo
)
;
capacity
=
gridReflowInput
.
mRows
.
mSizes
.
Length
(
)
;
const
nsStyleGridTemplate
&
gridRowTemplate
=
gridReflowInput
.
mGridStyle
-
>
GridTemplateRows
(
)
;
nsTArray
<
nsTArray
<
RefPtr
<
nsAtom
>
>
>
rowLineNames
(
capacity
)
;
for
(
row
=
0
;
row
<
=
gridReflowInput
.
mRows
.
mSizes
.
Length
(
)
;
row
+
+
)
{
nsTArray
<
RefPtr
<
nsAtom
>
>
explicitNames
=
gridReflowInput
.
mRows
.
GetExplicitLineNamesAtIndex
(
gridRowTemplate
gridReflowInput
.
mRowFunctions
row
-
gridReflowInput
.
mRowFunctions
.
mExplicitGridOffset
)
;
rowLineNames
.
AppendElement
(
explicitNames
)
;
}
nsTArray
<
RefPtr
<
nsAtom
>
>
rowNamesFollowingRepeat
;
if
(
gridRowTemplate
.
HasRepeatAuto
(
)
)
{
uint32_t
repeatAutoEnd
=
gridRowTemplate
.
mRepeatAutoIndex
+
1
;
MOZ_ASSERT
(
repeatAutoEnd
<
gridRowTemplate
.
mLineNameLists
.
Length
(
)
)
;
rowNamesFollowingRepeat
.
AppendElements
(
gridRowTemplate
.
mLineNameLists
[
repeatAutoEnd
]
)
;
}
ComputedGridLineInfo
*
rowLineInfo
=
new
ComputedGridLineInfo
(
std
:
:
move
(
rowLineNames
)
gridRowTemplate
.
mRepeatAutoLineNameListBefore
gridRowTemplate
.
mRepeatAutoLineNameListAfter
std
:
:
move
(
rowNamesFollowingRepeat
)
)
;
SetProperty
(
GridRowLineInfo
(
)
rowLineInfo
)
;
if
(
!
gridReflowInput
.
mGridStyle
-
>
mGridTemplateAreas
.
IsNone
(
)
)
{
auto
*
areas
=
new
StyleOwnedSlice
<
NamedArea
>
(
gridReflowInput
.
mGridStyle
-
>
mGridTemplateAreas
.
AsAreas
(
)
-
>
areas
)
;
SetProperty
(
ExplicitNamedAreasProperty
(
)
areas
)
;
}
else
{
DeleteProperty
(
ExplicitNamedAreasProperty
(
)
)
;
}
}
if
(
!
prevInFlow
)
{
SharedGridData
*
sharedGridData
=
GetProperty
(
SharedGridData
:
:
Prop
(
)
)
;
if
(
!
aStatus
.
IsFullyComplete
(
)
)
{
if
(
!
sharedGridData
)
{
sharedGridData
=
new
SharedGridData
;
SetProperty
(
SharedGridData
:
:
Prop
(
)
sharedGridData
)
;
}
sharedGridData
-
>
mCols
.
mSizes
.
Clear
(
)
;
sharedGridData
-
>
mCols
.
mSizes
.
SwapElements
(
gridReflowInput
.
mCols
.
mSizes
)
;
sharedGridData
-
>
mCols
.
mContentBoxSize
=
gridReflowInput
.
mCols
.
mContentBoxSize
;
sharedGridData
-
>
mCols
.
mBaselineSubtreeAlign
=
gridReflowInput
.
mCols
.
mBaselineSubtreeAlign
;
sharedGridData
-
>
mRows
.
mSizes
.
Clear
(
)
;
sharedGridData
-
>
mRows
.
mSizes
.
SwapElements
(
gridReflowInput
.
mRows
.
mSizes
)
;
auto
&
origRowData
=
sharedGridData
-
>
mOriginalRowData
;
origRowData
.
ClearAndRetainStorage
(
)
;
origRowData
.
SetCapacity
(
sharedGridData
-
>
mRows
.
mSizes
.
Length
(
)
)
;
nscoord
prevTrackEnd
=
0
;
for
(
auto
&
sz
:
sharedGridData
-
>
mRows
.
mSizes
)
{
SharedGridData
:
:
RowData
data
=
{
sz
.
mBase
sz
.
mPosition
-
prevTrackEnd
}
;
origRowData
.
AppendElement
(
data
)
;
prevTrackEnd
=
sz
.
mPosition
+
sz
.
mBase
;
}
sharedGridData
-
>
mRows
.
mContentBoxSize
=
gridReflowInput
.
mRows
.
mContentBoxSize
;
sharedGridData
-
>
mRows
.
mBaselineSubtreeAlign
=
gridReflowInput
.
mRows
.
mBaselineSubtreeAlign
;
sharedGridData
-
>
mGridItems
.
Clear
(
)
;
sharedGridData
-
>
mGridItems
.
SwapElements
(
gridReflowInput
.
mGridItems
)
;
sharedGridData
-
>
mAbsPosItems
.
Clear
(
)
;
sharedGridData
-
>
mAbsPosItems
.
SwapElements
(
gridReflowInput
.
mAbsPosItems
)
;
sharedGridData
-
>
mGenerateComputedGridInfo
=
HasAnyStateBits
(
NS_STATE_GRID_GENERATE_COMPUTED_VALUES
)
;
}
else
if
(
sharedGridData
&
&
!
GetNextInFlow
(
)
)
{
DeleteProperty
(
SharedGridData
:
:
Prop
(
)
)
;
}
}
FinishAndStoreOverflow
(
&
aDesiredSize
)
;
NS_FRAME_SET_TRUNCATION
(
aStatus
aReflowInput
aDesiredSize
)
;
}
void
nsGridContainerFrame
:
:
UpdateSubgridFrameState
(
)
{
nsFrameState
oldBits
=
GetStateBits
(
)
&
kIsSubgridBits
;
nsFrameState
newBits
=
ComputeSelfSubgridBits
(
)
;
if
(
newBits
!
=
oldBits
)
{
RemoveStateBits
(
kIsSubgridBits
)
;
if
(
!
newBits
)
{
DeleteProperty
(
Subgrid
:
:
Prop
(
)
)
;
}
else
{
AddStateBits
(
newBits
)
;
}
}
}
nsFrameState
nsGridContainerFrame
:
:
ComputeSelfSubgridBits
(
)
const
{
auto
*
display
=
StyleDisplay
(
)
;
if
(
display
-
>
IsContainLayout
(
)
|
|
display
-
>
IsContainPaint
(
)
)
{
return
nsFrameState
(
0
)
;
}
auto
*
parent
=
GetParent
(
)
;
while
(
parent
&
&
parent
-
>
GetContent
(
)
=
=
GetContent
(
)
)
{
parent
=
parent
-
>
GetParent
(
)
;
}
nsFrameState
bits
=
nsFrameState
(
0
)
;
if
(
parent
&
&
parent
-
>
IsGridContainerFrame
(
)
)
{
const
auto
*
pos
=
StylePosition
(
)
;
if
(
pos
-
>
GridTemplateColumns
(
)
.
mIsSubgrid
)
{
bits
|
=
NS_STATE_GRID_IS_COL_SUBGRID
;
}
if
(
pos
-
>
GridTemplateRows
(
)
.
mIsSubgrid
)
{
bits
|
=
NS_STATE_GRID_IS_ROW_SUBGRID
;
}
}
return
bits
;
}
void
nsGridContainerFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
nsContainerFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
nsFrameState
bits
=
nsFrameState
(
0
)
;
if
(
MOZ_LIKELY
(
!
aPrevInFlow
)
)
{
bits
=
ComputeSelfSubgridBits
(
)
;
}
else
{
bits
=
aPrevInFlow
-
>
GetStateBits
(
)
&
(
kIsSubgridBits
|
NS_STATE_GRID_HAS_COL_SUBGRID_ITEM
|
NS_STATE_GRID_HAS_ROW_SUBGRID_ITEM
)
;
}
AddStateBits
(
bits
)
;
}
void
nsGridContainerFrame
:
:
DidSetComputedStyle
(
ComputedStyle
*
aOldStyle
)
{
nsContainerFrame
:
:
DidSetComputedStyle
(
aOldStyle
)
;
if
(
!
aOldStyle
)
{
return
;
}
UpdateSubgridFrameState
(
)
;
}
nscoord
nsGridContainerFrame
:
:
IntrinsicISize
(
gfxContext
*
aRenderingContext
IntrinsicISizeType
aType
)
{
NormalizeChildLists
(
)
;
GridReflowInput
state
(
this
*
aRenderingContext
)
;
InitImplicitNamedAreas
(
state
.
mGridStyle
)
;
RepeatTrackSizingInput
repeatSizing
(
state
.
mWM
)
;
if
(
!
IsColSubgrid
(
)
&
&
state
.
mColFunctions
.
mHasRepeatAuto
)
{
repeatSizing
.
SetDefiniteSizes
(
eLogicalAxisInline
state
.
mWM
state
.
mGridStyle
-
>
MinISize
(
state
.
mWM
)
state
.
mGridStyle
-
>
ISize
(
state
.
mWM
)
state
.
mGridStyle
-
>
MaxISize
(
state
.
mWM
)
)
;
}
if
(
!
IsRowSubgrid
(
)
&
&
state
.
mRowFunctions
.
mHasRepeatAuto
&
&
!
(
state
.
mGridStyle
-
>
mGridAutoFlow
&
NS_STYLE_GRID_AUTO_FLOW_ROW
)
)
{
repeatSizing
.
SetDefiniteSizes
(
eLogicalAxisBlock
state
.
mWM
state
.
mGridStyle
-
>
MinBSize
(
state
.
mWM
)
state
.
mGridStyle
-
>
BSize
(
state
.
mWM
)
state
.
mGridStyle
-
>
MaxBSize
(
state
.
mWM
)
)
;
}
Grid
grid
;
if
(
MOZ_LIKELY
(
!
IsSubgrid
(
)
)
)
{
grid
.
PlaceGridItems
(
state
repeatSizing
)
;
}
else
{
auto
*
subgrid
=
GetProperty
(
Subgrid
:
:
Prop
(
)
)
;
state
.
mGridItems
=
subgrid
-
>
mGridItems
;
state
.
mAbsPosItems
=
subgrid
-
>
mAbsPosItems
;
grid
.
mGridColEnd
=
subgrid
-
>
mGridColEnd
;
grid
.
mGridRowEnd
=
subgrid
-
>
mGridRowEnd
;
}
if
(
grid
.
mGridColEnd
=
=
0
)
{
return
nscoord
(
0
)
;
}
auto
constraint
=
aType
=
=
nsLayoutUtils
:
:
MIN_ISIZE
?
SizingConstraint
:
:
MinContent
:
SizingConstraint
:
:
MaxContent
;
state
.
CalculateTrackSizesForAxis
(
eLogicalAxisInline
grid
NS_UNCONSTRAINEDSIZE
constraint
)
;
if
(
MOZ_LIKELY
(
!
IsSubgrid
(
)
)
)
{
nscoord
length
=
0
;
for
(
const
TrackSize
&
sz
:
state
.
mCols
.
mSizes
)
{
length
+
=
sz
.
mBase
;
}
return
length
+
state
.
mCols
.
SumOfGridGaps
(
)
;
}
const
auto
&
last
=
state
.
mCols
.
mSizes
.
LastElement
(
)
;
return
last
.
mPosition
+
last
.
mBase
;
}
nscoord
nsGridContainerFrame
:
:
GetMinISize
(
gfxContext
*
aRC
)
{
DISPLAY_MIN_INLINE_SIZE
(
this
mCachedMinISize
)
;
if
(
mCachedMinISize
=
=
NS_INTRINSIC_ISIZE_UNKNOWN
)
{
mCachedMinISize
=
StyleDisplay
(
)
-
>
IsContainSize
(
)
?
0
:
IntrinsicISize
(
aRC
nsLayoutUtils
:
:
MIN_ISIZE
)
;
}
return
mCachedMinISize
;
}
nscoord
nsGridContainerFrame
:
:
GetPrefISize
(
gfxContext
*
aRC
)
{
DISPLAY_PREF_INLINE_SIZE
(
this
mCachedPrefISize
)
;
if
(
mCachedPrefISize
=
=
NS_INTRINSIC_ISIZE_UNKNOWN
)
{
mCachedPrefISize
=
StyleDisplay
(
)
-
>
IsContainSize
(
)
?
0
:
IntrinsicISize
(
aRC
nsLayoutUtils
:
:
PREF_ISIZE
)
;
}
return
mCachedPrefISize
;
}
void
nsGridContainerFrame
:
:
MarkIntrinsicISizesDirty
(
)
{
mCachedMinISize
=
NS_INTRINSIC_ISIZE_UNKNOWN
;
mCachedPrefISize
=
NS_INTRINSIC_ISIZE_UNKNOWN
;
for
(
auto
&
perAxisBaseline
:
mBaseline
)
{
for
(
auto
&
baseline
:
perAxisBaseline
)
{
baseline
=
NS_INTRINSIC_ISIZE_UNKNOWN
;
}
}
nsContainerFrame
:
:
MarkIntrinsicISizesDirty
(
)
;
}
void
nsGridContainerFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
DisplayBorderBackgroundOutline
(
aBuilder
aLists
)
;
if
(
GetPrevInFlow
(
)
)
{
DisplayOverflowContainers
(
aBuilder
aLists
)
;
}
typedef
CSSOrderAwareFrameIterator
:
:
OrderState
OrderState
;
OrderState
order
=
HasAnyStateBits
(
NS_STATE_GRID_NORMAL_FLOW_CHILDREN_IN_CSS_ORDER
)
?
OrderState
:
:
eKnownOrdered
:
OrderState
:
:
eKnownUnordered
;
CSSOrderAwareFrameIterator
iter
(
this
kPrincipalList
CSSOrderAwareFrameIterator
:
:
eIncludeAll
order
)
;
for
(
;
!
iter
.
AtEnd
(
)
;
iter
.
Next
(
)
)
{
nsIFrame
*
child
=
*
iter
;
BuildDisplayListForChild
(
aBuilder
child
aLists
:
:
GetDisplayFlagsForGridItem
(
child
)
)
;
}
}
bool
nsGridContainerFrame
:
:
DrainSelfOverflowList
(
)
{
AutoFrameListPtr
overflowFrames
(
PresContext
(
)
StealOverflowFrames
(
)
)
;
if
(
overflowFrames
)
{
:
:
MergeSortedFrameLists
(
mFrames
*
overflowFrames
GetContent
(
)
)
;
AddStateBits
(
NS_STATE_GRID_HAS_CHILD_NIFS
)
;
return
true
;
}
return
false
;
}
void
nsGridContainerFrame
:
:
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
{
NoteNewChildren
(
aListID
aFrameList
)
;
nsContainerFrame
:
:
AppendFrames
(
aListID
aFrameList
)
;
}
void
nsGridContainerFrame
:
:
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
aFrameList
)
{
NoteNewChildren
(
aListID
aFrameList
)
;
nsContainerFrame
:
:
InsertFrames
(
aListID
aPrevFrame
aFrameList
)
;
}
void
nsGridContainerFrame
:
:
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
{
#
ifdef
DEBUG
ChildListIDs
supportedLists
=
{
kAbsoluteList
kFixedList
kPrincipalList
kNoReflowPrincipalList
}
;
supportedLists
+
=
kBackdropList
;
MOZ_ASSERT
(
supportedLists
.
contains
(
aListID
)
"
unexpected
child
list
"
)
;
if
(
aListID
=
=
kPrincipalList
&
&
!
aOldFrame
-
>
GetPrevInFlow
(
)
)
{
nsGridContainerFrame
*
frameThatMayLie
=
this
;
do
{
frameThatMayLie
-
>
mDidPushItemsBitMayLie
=
true
;
frameThatMayLie
=
static_cast
<
nsGridContainerFrame
*
>
(
frameThatMayLie
-
>
GetPrevInFlow
(
)
)
;
}
while
(
frameThatMayLie
)
;
}
#
endif
nsContainerFrame
:
:
RemoveFrame
(
aListID
aOldFrame
)
;
}
uint16_t
nsGridContainerFrame
:
:
CSSAlignmentForAbsPosChild
(
const
ReflowInput
&
aChildRI
LogicalAxis
aLogicalAxis
)
const
{
MOZ_ASSERT
(
aChildRI
.
mFrame
-
>
IsAbsolutelyPositioned
(
)
"
This
method
should
only
be
called
for
abspos
children
"
)
;
uint16_t
alignment
=
(
aLogicalAxis
=
=
eLogicalAxisInline
)
?
aChildRI
.
mStylePosition
-
>
UsedJustifySelf
(
Style
(
)
)
:
aChildRI
.
mStylePosition
-
>
UsedAlignSelf
(
Style
(
)
)
;
uint16_t
alignmentFlags
=
alignment
&
NS_STYLE_ALIGN_FLAG_BITS
;
alignment
&
=
~
NS_STYLE_ALIGN_FLAG_BITS
;
if
(
alignment
=
=
NS_STYLE_ALIGN_NORMAL
)
{
alignment
=
aChildRI
.
mFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eReplaced
)
?
NS_STYLE_ALIGN_START
:
NS_STYLE_ALIGN_STRETCH
;
}
else
if
(
alignment
=
=
NS_STYLE_ALIGN_FLEX_START
)
{
alignment
=
NS_STYLE_ALIGN_START
;
}
else
if
(
alignment
=
=
NS_STYLE_ALIGN_FLEX_END
)
{
alignment
=
NS_STYLE_ALIGN_END
;
}
else
if
(
alignment
=
=
NS_STYLE_ALIGN_LEFT
|
|
alignment
=
=
NS_STYLE_ALIGN_RIGHT
)
{
if
(
aLogicalAxis
=
=
eLogicalAxisInline
)
{
const
bool
isLeft
=
(
alignment
=
=
NS_STYLE_ALIGN_LEFT
)
;
WritingMode
wm
=
GetWritingMode
(
)
;
alignment
=
(
isLeft
=
=
wm
.
IsBidiLTR
(
)
)
?
NS_STYLE_ALIGN_START
:
NS_STYLE_ALIGN_END
;
}
else
{
alignment
=
NS_STYLE_ALIGN_START
;
}
}
else
if
(
alignment
=
=
NS_STYLE_ALIGN_BASELINE
)
{
alignment
=
NS_STYLE_ALIGN_START
;
}
else
if
(
alignment
=
=
NS_STYLE_ALIGN_LAST_BASELINE
)
{
alignment
=
NS_STYLE_ALIGN_END
;
}
return
(
alignment
|
alignmentFlags
)
;
}
nscoord
nsGridContainerFrame
:
:
SynthesizeBaseline
(
const
FindItemInGridOrderResult
&
aGridOrderItem
LogicalAxis
aAxis
BaselineSharingGroup
aGroup
const
nsSize
&
aCBPhysicalSize
nscoord
aCBSize
WritingMode
aCBWM
)
{
if
(
MOZ_UNLIKELY
(
!
aGridOrderItem
.
mItem
)
)
{
return
:
:
SynthesizeBaselineFromBorderBox
(
aGroup
aCBWM
aCBSize
)
;
}
auto
GetBBaseline
=
[
]
(
BaselineSharingGroup
aGroup
WritingMode
aWM
const
nsIFrame
*
aFrame
nscoord
*
aBaseline
)
{
return
aGroup
=
=
BaselineSharingGroup
:
:
First
?
nsLayoutUtils
:
:
GetFirstLineBaseline
(
aWM
aFrame
aBaseline
)
:
nsLayoutUtils
:
:
GetLastLineBaseline
(
aWM
aFrame
aBaseline
)
;
}
;
nsIFrame
*
child
=
aGridOrderItem
.
mItem
-
>
mFrame
;
nsGridContainerFrame
*
grid
=
do_QueryFrame
(
child
)
;
auto
childWM
=
child
-
>
GetWritingMode
(
)
;
bool
isOrthogonal
=
aCBWM
.
IsOrthogonalTo
(
childWM
)
;
nscoord
baseline
;
nscoord
start
;
nscoord
size
;
if
(
aAxis
=
=
eLogicalAxisBlock
)
{
start
=
child
-
>
GetLogicalNormalPosition
(
aCBWM
aCBPhysicalSize
)
.
B
(
aCBWM
)
;
size
=
child
-
>
BSize
(
aCBWM
)
;
if
(
grid
&
&
aGridOrderItem
.
mIsInEdgeTrack
)
{
isOrthogonal
?
grid
-
>
GetIBaseline
(
aGroup
&
baseline
)
:
grid
-
>
GetBBaseline
(
aGroup
&
baseline
)
;
}
else
if
(
!
isOrthogonal
&
&
aGridOrderItem
.
mIsInEdgeTrack
)
{
baseline
=
child
-
>
BaselineBOffset
(
childWM
aGroup
AlignmentContext
:
:
Grid
)
;
}
else
{
baseline
=
:
:
SynthesizeBaselineFromBorderBox
(
aGroup
childWM
size
)
;
}
}
else
{
start
=
child
-
>
GetLogicalNormalPosition
(
aCBWM
aCBPhysicalSize
)
.
I
(
aCBWM
)
;
size
=
child
-
>
ISize
(
aCBWM
)
;
if
(
grid
&
&
aGridOrderItem
.
mIsInEdgeTrack
)
{
isOrthogonal
?
grid
-
>
GetBBaseline
(
aGroup
&
baseline
)
:
grid
-
>
GetIBaseline
(
aGroup
&
baseline
)
;
}
else
if
(
isOrthogonal
&
&
aGridOrderItem
.
mIsInEdgeTrack
&
&
GetBBaseline
(
aGroup
childWM
child
&
baseline
)
)
{
if
(
aGroup
=
=
BaselineSharingGroup
:
:
Last
)
{
baseline
=
size
-
baseline
;
}
}
else
{
baseline
=
:
:
SynthesizeBaselineFromBorderBox
(
aGroup
childWM
size
)
;
}
}
return
aGroup
=
=
BaselineSharingGroup
:
:
First
?
start
+
baseline
:
aCBSize
-
start
-
size
+
baseline
;
}
void
nsGridContainerFrame
:
:
CalculateBaselines
(
BaselineSet
aBaselineSet
CSSOrderAwareFrameIterator
*
aIter
const
nsTArray
<
GridItemInfo
>
*
aGridItems
const
Tracks
&
aTracks
uint32_t
aFragmentStartTrack
uint32_t
aFirstExcludedTrack
WritingMode
aWM
const
nsSize
&
aCBPhysicalSize
nscoord
aCBBorderPaddingStart
nscoord
aCBBorderPaddingEnd
nscoord
aCBSize
)
{
const
auto
axis
=
aTracks
.
mAxis
;
auto
firstBaseline
=
aTracks
.
mBaseline
[
BaselineSharingGroup
:
:
First
]
;
if
(
!
(
aBaselineSet
&
BaselineSet
:
:
eFirst
)
)
{
mBaseline
[
axis
]
[
BaselineSharingGroup
:
:
First
]
=
:
:
SynthesizeBaselineFromBorderBox
(
BaselineSharingGroup
:
:
First
aWM
aCBSize
)
;
}
else
if
(
firstBaseline
=
=
NS_INTRINSIC_ISIZE_UNKNOWN
)
{
FindItemInGridOrderResult
gridOrderFirstItem
=
FindFirstItemInGridOrder
(
*
aIter
*
aGridItems
axis
=
=
eLogicalAxisBlock
?
&
GridArea
:
:
mRows
:
&
GridArea
:
:
mCols
axis
=
=
eLogicalAxisBlock
?
&
GridArea
:
:
mCols
:
&
GridArea
:
:
mRows
aFragmentStartTrack
)
;
mBaseline
[
axis
]
[
BaselineSharingGroup
:
:
First
]
=
SynthesizeBaseline
(
gridOrderFirstItem
axis
BaselineSharingGroup
:
:
First
aCBPhysicalSize
aCBSize
aWM
)
;
}
else
{
MOZ_ASSERT
(
!
aGridItems
-
>
IsEmpty
(
)
)
;
nscoord
gapBeforeStartTrack
=
aFragmentStartTrack
=
=
0
?
aTracks
.
GridLineEdge
(
aFragmentStartTrack
GridLineSide
:
:
AfterGridGap
)
:
nscoord
(
0
)
;
mBaseline
[
axis
]
[
BaselineSharingGroup
:
:
First
]
=
aCBBorderPaddingStart
+
gapBeforeStartTrack
+
firstBaseline
;
}
auto
lastBaseline
=
aTracks
.
mBaseline
[
BaselineSharingGroup
:
:
Last
]
;
if
(
!
(
aBaselineSet
&
BaselineSet
:
:
eLast
)
)
{
mBaseline
[
axis
]
[
BaselineSharingGroup
:
:
Last
]
=
:
:
SynthesizeBaselineFromBorderBox
(
BaselineSharingGroup
:
:
Last
aWM
aCBSize
)
;
}
else
if
(
lastBaseline
=
=
NS_INTRINSIC_ISIZE_UNKNOWN
)
{
using
Iter
=
ReverseCSSOrderAwareFrameIterator
;
auto
orderState
=
aIter
-
>
ItemsAreAlreadyInOrder
(
)
?
Iter
:
:
OrderState
:
:
eKnownOrdered
:
Iter
:
:
OrderState
:
:
eKnownUnordered
;
Iter
iter
(
this
kPrincipalList
Iter
:
:
ChildFilter
:
:
eSkipPlaceholders
orderState
)
;
iter
.
SetItemCount
(
aGridItems
-
>
Length
(
)
)
;
FindItemInGridOrderResult
gridOrderLastItem
=
FindLastItemInGridOrder
(
iter
*
aGridItems
axis
=
=
eLogicalAxisBlock
?
&
GridArea
:
:
mRows
:
&
GridArea
:
:
mCols
axis
=
=
eLogicalAxisBlock
?
&
GridArea
:
:
mCols
:
&
GridArea
:
:
mRows
aFragmentStartTrack
aFirstExcludedTrack
)
;
mBaseline
[
axis
]
[
BaselineSharingGroup
:
:
Last
]
=
SynthesizeBaseline
(
gridOrderLastItem
axis
BaselineSharingGroup
:
:
Last
aCBPhysicalSize
aCBSize
aWM
)
;
}
else
{
MOZ_ASSERT
(
!
aGridItems
-
>
IsEmpty
(
)
)
;
auto
borderBoxStartToEndOfEndTrack
=
aCBBorderPaddingStart
+
aTracks
.
GridLineEdge
(
aFirstExcludedTrack
GridLineSide
:
:
BeforeGridGap
)
-
aTracks
.
GridLineEdge
(
aFragmentStartTrack
GridLineSide
:
:
BeforeGridGap
)
;
mBaseline
[
axis
]
[
BaselineSharingGroup
:
:
Last
]
=
(
aCBSize
-
borderBoxStartToEndOfEndTrack
)
+
lastBaseline
;
}
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
nsGridContainerFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
NS_LITERAL_STRING
(
"
GridContainer
"
)
aResult
)
;
}
#
endif
void
nsGridContainerFrame
:
:
NoteNewChildren
(
ChildListID
aListID
const
nsFrameList
&
aFrameList
)
{
#
ifdef
DEBUG
ChildListIDs
supportedLists
=
{
kAbsoluteList
kFixedList
kPrincipalList
kNoReflowPrincipalList
}
;
supportedLists
+
=
kBackdropList
;
MOZ_ASSERT
(
supportedLists
.
contains
(
aListID
)
"
unexpected
child
list
"
)
;
#
endif
mozilla
:
:
PresShell
*
presShell
=
PresShell
(
)
;
for
(
auto
pif
=
GetPrevInFlow
(
)
;
pif
;
pif
=
pif
-
>
GetPrevInFlow
(
)
)
{
if
(
aListID
=
=
kPrincipalList
)
{
pif
-
>
AddStateBits
(
NS_STATE_GRID_DID_PUSH_ITEMS
)
;
}
presShell
-
>
FrameNeedsReflow
(
pif
IntrinsicDirty
:
:
TreeChange
NS_FRAME_IS_DIRTY
)
;
}
}
void
nsGridContainerFrame
:
:
MergeSortedOverflow
(
nsFrameList
&
aList
)
{
if
(
aList
.
IsEmpty
(
)
)
{
return
;
}
MOZ_ASSERT
(
!
aList
.
FirstChild
(
)
-
>
HasAnyStateBits
(
NS_FRAME_IS_OVERFLOW_CONTAINER
)
"
this
is
the
wrong
list
to
put
this
child
frame
"
)
;
MOZ_ASSERT
(
aList
.
FirstChild
(
)
-
>
GetParent
(
)
=
=
this
)
;
nsFrameList
*
overflow
=
GetOverflowFrames
(
)
;
if
(
overflow
)
{
:
:
MergeSortedFrameLists
(
*
overflow
aList
GetContent
(
)
)
;
}
else
{
SetOverflowFrames
(
aList
)
;
}
}
void
nsGridContainerFrame
:
:
MergeSortedExcessOverflowContainers
(
nsFrameList
&
aList
)
{
if
(
aList
.
IsEmpty
(
)
)
{
return
;
}
MOZ_ASSERT
(
aList
.
FirstChild
(
)
-
>
HasAnyStateBits
(
NS_FRAME_IS_OVERFLOW_CONTAINER
)
"
this
is
the
wrong
list
to
put
this
child
frame
"
)
;
MOZ_ASSERT
(
aList
.
FirstChild
(
)
-
>
GetParent
(
)
=
=
this
)
;
nsFrameList
*
eoc
=
GetPropTableFrames
(
ExcessOverflowContainersProperty
(
)
)
;
if
(
eoc
)
{
:
:
MergeSortedFrameLists
(
*
eoc
aList
GetContent
(
)
)
;
}
else
{
SetPropTableFrames
(
new
(
PresShell
(
)
)
nsFrameList
(
aList
)
ExcessOverflowContainersProperty
(
)
)
;
}
}
nsGridContainerFrame
:
:
FindItemInGridOrderResult
nsGridContainerFrame
:
:
FindFirstItemInGridOrder
(
CSSOrderAwareFrameIterator
&
aIter
const
nsTArray
<
GridItemInfo
>
&
aGridItems
LineRange
GridArea
:
:
*
aMajor
LineRange
GridArea
:
:
*
aMinor
uint32_t
aFragmentStartTrack
)
{
FindItemInGridOrderResult
result
=
{
nullptr
false
}
;
uint32_t
minMajor
=
kTranslatedMaxLine
+
1
;
uint32_t
minMinor
=
kTranslatedMaxLine
+
1
;
aIter
.
Reset
(
)
;
for
(
;
!
aIter
.
AtEnd
(
)
;
aIter
.
Next
(
)
)
{
const
GridItemInfo
&
item
=
aGridItems
[
aIter
.
ItemIndex
(
)
]
;
if
(
(
item
.
mArea
.
*
aMajor
)
.
mEnd
<
=
aFragmentStartTrack
)
{
continue
;
}
uint32_t
major
=
(
item
.
mArea
.
*
aMajor
)
.
mStart
;
uint32_t
minor
=
(
item
.
mArea
.
*
aMinor
)
.
mStart
;
if
(
major
<
minMajor
|
|
(
major
=
=
minMajor
&
&
minor
<
minMinor
)
)
{
minMajor
=
major
;
minMinor
=
minor
;
result
.
mItem
=
&
item
;
result
.
mIsInEdgeTrack
=
major
=
=
0U
;
}
}
return
result
;
}
nsGridContainerFrame
:
:
FindItemInGridOrderResult
nsGridContainerFrame
:
:
FindLastItemInGridOrder
(
ReverseCSSOrderAwareFrameIterator
&
aIter
const
nsTArray
<
GridItemInfo
>
&
aGridItems
LineRange
GridArea
:
:
*
aMajor
LineRange
GridArea
:
:
*
aMinor
uint32_t
aFragmentStartTrack
uint32_t
aFirstExcludedTrack
)
{
FindItemInGridOrderResult
result
=
{
nullptr
false
}
;
int32_t
maxMajor
=
-
1
;
int32_t
maxMinor
=
-
1
;
aIter
.
Reset
(
)
;
int32_t
lastMajorTrack
=
int32_t
(
aFirstExcludedTrack
)
-
1
;
for
(
;
!
aIter
.
AtEnd
(
)
;
aIter
.
Next
(
)
)
{
const
GridItemInfo
&
item
=
aGridItems
[
aIter
.
ItemIndex
(
)
]
;
int32_t
major
=
(
item
.
mArea
.
*
aMajor
)
.
mEnd
-
1
;
MOZ_ASSERT
(
(
item
.
mArea
.
*
aMajor
)
.
mStart
<
aFirstExcludedTrack
"
found
an
item
that
belongs
to
some
later
fragment
"
)
;
if
(
major
<
int32_t
(
aFragmentStartTrack
)
)
{
continue
;
}
int32_t
minor
=
(
item
.
mArea
.
*
aMinor
)
.
mEnd
-
1
;
MOZ_ASSERT
(
minor
>
=
0
&
&
major
>
=
0
"
grid
item
must
have
span
>
=
1
"
)
;
if
(
major
>
maxMajor
|
|
(
major
=
=
maxMajor
&
&
minor
>
maxMinor
)
)
{
maxMajor
=
major
;
maxMinor
=
minor
;
result
.
mItem
=
&
item
;
result
.
mIsInEdgeTrack
=
major
=
=
lastMajorTrack
;
}
}
return
result
;
}
nsGridContainerFrame
:
:
UsedTrackSizes
*
nsGridContainerFrame
:
:
GetUsedTrackSizes
(
)
const
{
return
GetProperty
(
UsedTrackSizes
:
:
Prop
(
)
)
;
}
void
nsGridContainerFrame
:
:
StoreUsedTrackSizes
(
LogicalAxis
aAxis
const
nsTArray
<
TrackSize
>
&
aSizes
)
{
auto
*
uts
=
GetUsedTrackSizes
(
)
;
if
(
!
uts
)
{
uts
=
new
UsedTrackSizes
(
)
;
SetProperty
(
UsedTrackSizes
:
:
Prop
(
)
uts
)
;
}
uts
-
>
mSizes
[
aAxis
]
=
aSizes
;
uts
-
>
mCanResolveLineRangeSize
[
aAxis
]
=
true
;
for
(
auto
&
sz
:
uts
-
>
mSizes
[
aAxis
]
)
{
sz
.
mState
&
=
~
(
TrackSize
:
:
eFrozen
|
TrackSize
:
:
eSkipGrowUnlimited
|
TrackSize
:
:
eInfinitelyGrowable
)
;
}
}
#
ifdef
DEBUG
void
nsGridContainerFrame
:
:
SetInitialChildList
(
ChildListID
aListID
nsFrameList
&
aChildList
)
{
#
ifdef
DEBUG
ChildListIDs
supportedLists
=
{
kAbsoluteList
kFixedList
kPrincipalList
}
;
supportedLists
+
=
kBackdropList
;
MOZ_ASSERT
(
supportedLists
.
contains
(
aListID
)
"
unexpected
child
list
"
)
;
#
endif
return
nsContainerFrame
:
:
SetInitialChildList
(
aListID
aChildList
)
;
}
void
nsGridContainerFrame
:
:
SanityCheckGridItemsBeforeReflow
(
)
const
{
ChildListIDs
absLists
=
{
kAbsoluteList
kFixedList
kOverflowContainersList
kExcessOverflowContainersList
}
;
ChildListIDs
itemLists
=
{
kPrincipalList
kOverflowList
}
;
for
(
const
nsIFrame
*
f
=
this
;
f
;
f
=
f
-
>
GetNextInFlow
(
)
)
{
MOZ_ASSERT
(
!
f
-
>
HasAnyStateBits
(
NS_STATE_GRID_DID_PUSH_ITEMS
)
"
At
start
of
reflow
we
should
'
ve
pulled
items
back
from
all
"
"
NIFs
and
cleared
NS_STATE_GRID_DID_PUSH_ITEMS
in
the
process
"
)
;
for
(
nsIFrame
:
:
ChildListIterator
childLists
(
f
)
;
!
childLists
.
IsDone
(
)
;
childLists
.
Next
(
)
)
{
if
(
!
itemLists
.
contains
(
childLists
.
CurrentID
(
)
)
)
{
MOZ_ASSERT
(
absLists
.
contains
(
childLists
.
CurrentID
(
)
)
|
|
childLists
.
CurrentID
(
)
=
=
kBackdropList
"
unexpected
non
-
empty
child
list
"
)
;
continue
;
}
for
(
auto
child
:
childLists
.
CurrentList
(
)
)
{
MOZ_ASSERT
(
f
=
=
this
|
|
child
-
>
GetPrevInFlow
(
)
"
all
pushed
items
must
be
pulled
up
before
reflow
"
)
;
}
}
}
const
auto
pif
=
static_cast
<
nsGridContainerFrame
*
>
(
GetPrevInFlow
(
)
)
;
if
(
pif
)
{
const
nsFrameList
*
oc
=
GetPropTableFrames
(
OverflowContainersProperty
(
)
)
;
const
nsFrameList
*
eoc
=
GetPropTableFrames
(
ExcessOverflowContainersProperty
(
)
)
;
const
nsFrameList
*
pifEOC
=
pif
-
>
GetPropTableFrames
(
ExcessOverflowContainersProperty
(
)
)
;
for
(
const
nsIFrame
*
child
:
pif
-
>
GetChildList
(
kPrincipalList
)
)
{
const
nsIFrame
*
childNIF
=
child
-
>
GetNextInFlow
(
)
;
MOZ_ASSERT
(
!
childNIF
|
|
mFrames
.
ContainsFrame
(
childNIF
)
|
|
(
pifEOC
&
&
pifEOC
-
>
ContainsFrame
(
childNIF
)
)
|
|
(
oc
&
&
oc
-
>
ContainsFrame
(
childNIF
)
)
|
|
(
eoc
&
&
eoc
-
>
ContainsFrame
(
childNIF
)
)
)
;
}
}
}
void
nsGridContainerFrame
:
:
TrackSize
:
:
Dump
(
)
const
{
printf
(
"
mPosition
=
%
d
mBase
=
%
d
mLimit
=
%
d
"
mPosition
mBase
mLimit
)
;
printf
(
"
min
:
"
)
;
if
(
mState
&
eAutoMinSizing
)
{
printf
(
"
auto
"
)
;
}
else
if
(
mState
&
eMinContentMinSizing
)
{
printf
(
"
min
-
content
"
)
;
}
else
if
(
mState
&
eMaxContentMinSizing
)
{
printf
(
"
max
-
content
"
)
;
}
printf
(
"
max
:
"
)
;
if
(
mState
&
eAutoMaxSizing
)
{
printf
(
"
auto
"
)
;
}
else
if
(
mState
&
eMinContentMaxSizing
)
{
printf
(
"
min
-
content
"
)
;
}
else
if
(
mState
&
eMaxContentMaxSizing
)
{
printf
(
"
max
-
content
"
)
;
}
else
if
(
mState
&
eFlexMaxSizing
)
{
printf
(
"
flex
"
)
;
}
if
(
mState
&
eFrozen
)
{
printf
(
"
frozen
"
)
;
}
if
(
mState
&
eModified
)
{
printf
(
"
modified
"
)
;
}
if
(
mState
&
eBreakBefore
)
{
printf
(
"
break
-
before
"
)
;
}
}
#
endif
nsGridContainerFrame
*
nsGridContainerFrame
:
:
GetGridContainerFrame
(
nsIFrame
*
aFrame
)
{
nsGridContainerFrame
*
gridFrame
=
nullptr
;
if
(
aFrame
)
{
nsIFrame
*
inner
=
aFrame
;
if
(
MOZ_UNLIKELY
(
aFrame
-
>
IsFieldSetFrame
(
)
)
)
{
inner
=
static_cast
<
nsFieldSetFrame
*
>
(
aFrame
)
-
>
GetInner
(
)
;
}
inner
=
inner
-
>
GetContentInsertionFrame
(
)
;
nsIFrame
*
possibleGridFrame
=
inner
?
inner
:
aFrame
;
gridFrame
=
possibleGridFrame
-
>
IsGridContainerFrame
(
)
?
static_cast
<
nsGridContainerFrame
*
>
(
possibleGridFrame
)
:
nullptr
;
}
return
gridFrame
;
}
nsGridContainerFrame
*
nsGridContainerFrame
:
:
GetGridFrameWithComputedInfo
(
nsIFrame
*
aFrame
)
{
nsGridContainerFrame
*
gridFrame
=
GetGridContainerFrame
(
aFrame
)
;
if
(
gridFrame
)
{
bool
reflowNeeded
=
(
!
gridFrame
-
>
HasProperty
(
GridColTrackInfo
(
)
)
|
|
!
gridFrame
-
>
HasProperty
(
GridRowTrackInfo
(
)
)
|
|
!
gridFrame
-
>
HasProperty
(
GridColumnLineInfo
(
)
)
|
|
!
gridFrame
-
>
HasProperty
(
GridRowLineInfo
(
)
)
)
;
if
(
reflowNeeded
)
{
AutoWeakFrame
weakFrameRef
(
aFrame
)
;
RefPtr
<
mozilla
:
:
PresShell
>
presShell
=
gridFrame
-
>
PresShell
(
)
;
gridFrame
-
>
AddStateBits
(
NS_STATE_GRID_GENERATE_COMPUTED_VALUES
)
;
presShell
-
>
FrameNeedsReflow
(
gridFrame
IntrinsicDirty
:
:
Resize
NS_FRAME_IS_DIRTY
)
;
presShell
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
if
(
!
weakFrameRef
.
IsAlive
(
)
)
{
return
nullptr
;
}
gridFrame
=
GetGridContainerFrame
(
weakFrameRef
.
GetFrame
(
)
)
;
MOZ_ASSERT
(
!
gridFrame
|
|
gridFrame
-
>
HasProperty
(
GridColTrackInfo
(
)
)
)
;
MOZ_ASSERT
(
!
gridFrame
|
|
gridFrame
-
>
HasProperty
(
GridRowTrackInfo
(
)
)
)
;
MOZ_ASSERT
(
!
gridFrame
|
|
gridFrame
-
>
HasProperty
(
GridColumnLineInfo
(
)
)
)
;
MOZ_ASSERT
(
!
gridFrame
|
|
gridFrame
-
>
HasProperty
(
GridRowLineInfo
(
)
)
)
;
}
}
return
gridFrame
;
}
