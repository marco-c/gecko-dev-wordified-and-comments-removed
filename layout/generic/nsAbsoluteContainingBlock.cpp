#
include
"
nsAbsoluteContainingBlock
.
h
"
#
include
"
mozilla
/
CSSAlignUtils
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
ReflowInput
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
nsAtomicContainerFrame
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsGridContainerFrame
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsPlaceholderFrame
.
h
"
#
include
"
nsPresContext
.
h
"
#
ifdef
DEBUG
#
include
"
nsBlockFrame
.
h
"
static
void
PrettyUC
(
nscoord
aSize
char
*
aBuf
int
aBufSize
)
{
if
(
NS_UNCONSTRAINEDSIZE
=
=
aSize
)
{
strcpy
(
aBuf
"
UC
"
)
;
}
else
{
if
(
(
int32_t
)
0xdeadbeef
=
=
aSize
)
{
strcpy
(
aBuf
"
deadbeef
"
)
;
}
else
{
snprintf
(
aBuf
aBufSize
"
%
d
"
aSize
)
;
}
}
}
#
endif
using
namespace
mozilla
;
void
nsAbsoluteContainingBlock
:
:
SetInitialChildList
(
nsIFrame
*
aDelegatingFrame
FrameChildListID
aListID
nsFrameList
&
&
aChildList
)
{
MOZ_ASSERT
(
mChildListID
=
=
aListID
"
unexpected
child
list
name
"
)
;
#
ifdef
DEBUG
nsIFrame
:
:
VerifyDirtyBitSet
(
aChildList
)
;
for
(
nsIFrame
*
f
:
aChildList
)
{
MOZ_ASSERT
(
f
-
>
GetParent
(
)
=
=
aDelegatingFrame
"
Unexpected
parent
"
)
;
}
#
endif
mAbsoluteFrames
=
std
:
:
move
(
aChildList
)
;
}
void
nsAbsoluteContainingBlock
:
:
AppendFrames
(
nsIFrame
*
aDelegatingFrame
FrameChildListID
aListID
nsFrameList
&
&
aFrameList
)
{
NS_ASSERTION
(
mChildListID
=
=
aListID
"
unexpected
child
list
"
)
;
#
ifdef
DEBUG
nsIFrame
:
:
VerifyDirtyBitSet
(
aFrameList
)
;
#
endif
mAbsoluteFrames
.
AppendFrames
(
nullptr
std
:
:
move
(
aFrameList
)
)
;
aDelegatingFrame
-
>
PresShell
(
)
-
>
FrameNeedsReflow
(
aDelegatingFrame
IntrinsicDirty
:
:
None
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
}
void
nsAbsoluteContainingBlock
:
:
InsertFrames
(
nsIFrame
*
aDelegatingFrame
FrameChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
&
aFrameList
)
{
NS_ASSERTION
(
mChildListID
=
=
aListID
"
unexpected
child
list
"
)
;
NS_ASSERTION
(
!
aPrevFrame
|
|
aPrevFrame
-
>
GetParent
(
)
=
=
aDelegatingFrame
"
inserting
after
sibling
frame
with
different
parent
"
)
;
#
ifdef
DEBUG
nsIFrame
:
:
VerifyDirtyBitSet
(
aFrameList
)
;
#
endif
mAbsoluteFrames
.
InsertFrames
(
nullptr
aPrevFrame
std
:
:
move
(
aFrameList
)
)
;
aDelegatingFrame
-
>
PresShell
(
)
-
>
FrameNeedsReflow
(
aDelegatingFrame
IntrinsicDirty
:
:
None
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
}
void
nsAbsoluteContainingBlock
:
:
RemoveFrame
(
FrameDestroyContext
&
aContext
FrameChildListID
aListID
nsIFrame
*
aOldFrame
)
{
NS_ASSERTION
(
mChildListID
=
=
aListID
"
unexpected
child
list
"
)
;
if
(
nsIFrame
*
nif
=
aOldFrame
-
>
GetNextInFlow
(
)
)
{
nif
-
>
GetParent
(
)
-
>
DeleteNextInFlowChild
(
aContext
nif
false
)
;
}
mAbsoluteFrames
.
DestroyFrame
(
aContext
aOldFrame
)
;
}
static
void
MaybeMarkAncestorsAsHavingDescendantDependentOnItsStaticPos
(
nsIFrame
*
aFrame
nsIFrame
*
aContainingBlockFrame
)
{
MOZ_ASSERT
(
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
)
;
if
(
!
aFrame
-
>
StylePosition
(
)
-
>
NeedsHypotheticalPositionIfAbsPos
(
)
)
{
return
;
}
if
(
aFrame
-
>
GetPrevContinuation
(
)
)
{
return
;
}
auto
*
placeholder
=
aFrame
-
>
GetPlaceholderFrame
(
)
;
MOZ_ASSERT
(
placeholder
)
;
if
(
!
placeholder
-
>
HasAnyStateBits
(
PLACEHOLDER_FOR_FIXEDPOS
)
)
{
return
;
}
for
(
nsIFrame
*
ancestor
=
placeholder
-
>
GetParent
(
)
;
ancestor
;
ancestor
=
ancestor
-
>
GetParent
(
)
)
{
do
{
if
(
ancestor
-
>
DescendantMayDependOnItsStaticPosition
(
)
)
{
return
;
}
if
(
aFrame
=
=
aContainingBlockFrame
)
{
return
;
}
ancestor
-
>
SetDescendantMayDependOnItsStaticPosition
(
true
)
;
nsIFrame
*
prev
=
ancestor
-
>
GetPrevContinuation
(
)
;
if
(
!
prev
)
{
break
;
}
ancestor
=
prev
;
}
while
(
true
)
;
}
}
void
nsAbsoluteContainingBlock
:
:
Reflow
(
nsContainerFrame
*
aDelegatingFrame
nsPresContext
*
aPresContext
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aReflowStatus
const
nsRect
&
aContainingBlock
AbsPosReflowFlags
aFlags
OverflowAreas
*
aOverflowAreas
)
{
if
(
aDelegatingFrame
-
>
IsPageContentFrame
(
)
)
{
MOZ_ASSERT
(
mChildListID
=
=
FrameChildListID
:
:
Fixed
)
;
aOverflowAreas
=
nullptr
;
}
nsReflowStatus
reflowStatus
;
const
bool
reflowAll
=
aReflowInput
.
ShouldReflowAllKids
(
)
;
const
bool
isGrid
=
!
!
(
aFlags
&
AbsPosReflowFlags
:
:
IsGridContainerCB
)
;
nsIFrame
*
kidFrame
;
nsOverflowContinuationTracker
tracker
(
aDelegatingFrame
true
)
;
for
(
kidFrame
=
mAbsoluteFrames
.
FirstChild
(
)
;
kidFrame
;
kidFrame
=
kidFrame
-
>
GetNextSibling
(
)
)
{
AnchorPosReferencedAnchors
*
referencedAnchors
=
nullptr
;
if
(
kidFrame
-
>
HasAnchorPosReference
(
)
)
{
referencedAnchors
=
kidFrame
-
>
SetOrUpdateDeletableProperty
(
nsIFrame
:
:
AnchorPosReferences
(
)
)
;
}
else
{
kidFrame
-
>
RemoveProperty
(
nsIFrame
:
:
AnchorPosReferences
(
)
)
;
}
bool
kidNeedsReflow
=
reflowAll
|
|
kidFrame
-
>
IsSubtreeDirty
(
)
|
|
FrameDependsOnContainer
(
kidFrame
!
!
(
aFlags
&
AbsPosReflowFlags
:
:
CBWidthChanged
)
!
!
(
aFlags
&
AbsPosReflowFlags
:
:
CBHeightChanged
)
referencedAnchors
)
;
if
(
kidFrame
-
>
IsSubtreeDirty
(
)
)
{
MaybeMarkAncestorsAsHavingDescendantDependentOnItsStaticPos
(
kidFrame
aDelegatingFrame
)
;
}
nscoord
availBSize
=
aReflowInput
.
AvailableBSize
(
)
;
const
nsRect
&
cb
=
isGrid
?
nsGridContainerFrame
:
:
GridItemCB
(
kidFrame
)
:
aContainingBlock
;
WritingMode
containerWM
=
aReflowInput
.
GetWritingMode
(
)
;
if
(
!
kidNeedsReflow
&
&
availBSize
!
=
NS_UNCONSTRAINEDSIZE
)
{
WritingMode
kidWM
=
kidFrame
-
>
GetWritingMode
(
)
;
if
(
containerWM
.
GetBlockDir
(
)
!
=
kidWM
.
GetBlockDir
(
)
)
{
kidNeedsReflow
=
true
;
}
else
{
nscoord
kidBEnd
=
kidFrame
-
>
GetLogicalRect
(
cb
.
Size
(
)
)
.
BEnd
(
kidWM
)
;
nscoord
kidOverflowBEnd
=
LogicalRect
(
containerWM
kidFrame
-
>
ScrollableOverflowRectRelativeToSelf
(
)
+
kidFrame
-
>
GetPosition
(
)
aContainingBlock
.
Size
(
)
)
.
BEnd
(
containerWM
)
;
NS_ASSERTION
(
kidOverflowBEnd
>
=
kidBEnd
"
overflow
area
should
be
at
least
as
large
as
frame
rect
"
)
;
if
(
kidOverflowBEnd
>
availBSize
|
|
(
kidBEnd
<
availBSize
&
&
kidFrame
-
>
GetNextInFlow
(
)
)
)
{
kidNeedsReflow
=
true
;
}
}
}
if
(
kidNeedsReflow
&
&
!
aPresContext
-
>
HasPendingInterrupt
(
)
)
{
nsReflowStatus
kidStatus
;
ReflowAbsoluteFrame
(
aDelegatingFrame
aPresContext
aReflowInput
cb
aFlags
kidFrame
kidStatus
aOverflowAreas
referencedAnchors
)
;
MOZ_ASSERT
(
!
kidStatus
.
IsInlineBreakBefore
(
)
"
ShouldAvoidBreakInside
should
prevent
this
from
happening
"
)
;
nsIFrame
*
nextFrame
=
kidFrame
-
>
GetNextInFlow
(
)
;
if
(
!
kidStatus
.
IsFullyComplete
(
)
&
&
aDelegatingFrame
-
>
CanContainOverflowContainers
(
)
)
{
if
(
!
nextFrame
)
{
nextFrame
=
aPresContext
-
>
PresShell
(
)
-
>
FrameConstructor
(
)
-
>
CreateContinuingFrame
(
kidFrame
aDelegatingFrame
)
;
}
tracker
.
Insert
(
nextFrame
kidStatus
)
;
reflowStatus
.
MergeCompletionStatusFrom
(
kidStatus
)
;
}
else
if
(
nextFrame
)
{
nsOverflowContinuationTracker
:
:
AutoFinish
fini
(
&
tracker
kidFrame
)
;
FrameDestroyContext
context
(
aPresContext
-
>
PresShell
(
)
)
;
nextFrame
-
>
GetParent
(
)
-
>
DeleteNextInFlowChild
(
context
nextFrame
true
)
;
}
}
else
{
tracker
.
Skip
(
kidFrame
reflowStatus
)
;
if
(
aOverflowAreas
)
{
aDelegatingFrame
-
>
ConsiderChildOverflow
(
*
aOverflowAreas
kidFrame
)
;
}
}
if
(
kidNeedsReflow
&
&
aPresContext
-
>
CheckForInterrupt
(
aDelegatingFrame
)
)
{
if
(
aDelegatingFrame
-
>
HasAnyStateBits
(
NS_FRAME_IS_DIRTY
)
)
{
kidFrame
-
>
MarkSubtreeDirty
(
)
;
}
else
{
kidFrame
-
>
AddStateBits
(
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
}
}
}
if
(
reflowStatus
.
IsIncomplete
(
)
)
{
reflowStatus
.
SetOverflowIncomplete
(
)
;
reflowStatus
.
SetNextInFlowNeedsReflow
(
)
;
}
aReflowStatus
.
MergeCompletionStatusFrom
(
reflowStatus
)
;
}
static
inline
bool
IsFixedPaddingSize
(
const
LengthPercentage
&
aCoord
)
{
return
aCoord
.
ConvertsToLength
(
)
;
}
static
inline
bool
IsFixedMarginSize
(
const
AnchorResolvedMargin
&
aCoord
)
{
return
aCoord
-
>
ConvertsToLength
(
)
;
}
static
inline
bool
IsFixedOffset
(
const
AnchorResolvedInset
&
aInset
)
{
return
aInset
-
>
ConvertsToLength
(
)
;
}
bool
nsAbsoluteContainingBlock
:
:
FrameDependsOnContainer
(
nsIFrame
*
f
bool
aCBWidthChanged
bool
aCBHeightChanged
AnchorPosReferencedAnchors
*
aReferencedAnchors
)
{
const
nsStylePosition
*
pos
=
f
-
>
StylePosition
(
)
;
if
(
pos
-
>
NeedsHypotheticalPositionIfAbsPos
(
)
)
{
return
true
;
}
if
(
!
aCBWidthChanged
&
&
!
aCBHeightChanged
)
{
return
false
;
}
const
nsStylePadding
*
padding
=
f
-
>
StylePadding
(
)
;
const
nsStyleMargin
*
margin
=
f
-
>
StyleMargin
(
)
;
WritingMode
wm
=
f
-
>
GetWritingMode
(
)
;
const
auto
anchorResolutionParams
=
AnchorPosResolutionParams
:
:
From
(
f
aReferencedAnchors
)
;
if
(
wm
.
IsVertical
(
)
?
aCBHeightChanged
:
aCBWidthChanged
)
{
if
(
nsStylePosition
:
:
ISizeDependsOnContainer
(
pos
-
>
ISize
(
wm
anchorResolutionParams
)
)
|
|
nsStylePosition
:
:
MinISizeDependsOnContainer
(
pos
-
>
MinISize
(
wm
anchorResolutionParams
)
)
|
|
nsStylePosition
:
:
MaxISizeDependsOnContainer
(
pos
-
>
MaxISize
(
wm
anchorResolutionParams
)
)
|
|
!
IsFixedPaddingSize
(
padding
-
>
mPadding
.
GetIStart
(
wm
)
)
|
|
!
IsFixedPaddingSize
(
padding
-
>
mPadding
.
GetIEnd
(
wm
)
)
)
{
return
true
;
}
if
(
!
IsFixedMarginSize
(
margin
-
>
GetMargin
(
LogicalSide
:
:
IStart
wm
anchorResolutionParams
)
)
|
|
!
IsFixedMarginSize
(
margin
-
>
GetMargin
(
LogicalSide
:
:
IEnd
wm
anchorResolutionParams
)
)
)
{
return
true
;
}
}
if
(
wm
.
IsVertical
(
)
?
aCBWidthChanged
:
aCBHeightChanged
)
{
const
auto
bSize
=
pos
-
>
BSize
(
wm
anchorResolutionParams
)
;
const
auto
anchorOffsetResolutionParams
=
AnchorPosOffsetResolutionParams
:
:
UseCBFrameSize
(
anchorResolutionParams
)
;
if
(
(
nsStylePosition
:
:
BSizeDependsOnContainer
(
bSize
)
&
&
!
(
bSize
-
>
IsAuto
(
)
&
&
pos
-
>
GetAnchorResolvedInset
(
LogicalSide
:
:
BEnd
wm
anchorOffsetResolutionParams
)
-
>
IsAuto
(
)
&
&
!
pos
-
>
GetAnchorResolvedInset
(
LogicalSide
:
:
BStart
wm
anchorOffsetResolutionParams
)
-
>
IsAuto
(
)
)
)
|
|
nsStylePosition
:
:
MinBSizeDependsOnContainer
(
pos
-
>
MinBSize
(
wm
anchorResolutionParams
)
)
|
|
nsStylePosition
:
:
MaxBSizeDependsOnContainer
(
pos
-
>
MaxBSize
(
wm
anchorResolutionParams
)
)
|
|
!
IsFixedPaddingSize
(
padding
-
>
mPadding
.
GetBStart
(
wm
)
)
|
|
!
IsFixedPaddingSize
(
padding
-
>
mPadding
.
GetBEnd
(
wm
)
)
)
{
return
true
;
}
if
(
!
IsFixedMarginSize
(
margin
-
>
GetMargin
(
LogicalSide
:
:
BStart
wm
anchorResolutionParams
)
)
|
|
!
IsFixedMarginSize
(
margin
-
>
GetMargin
(
LogicalSide
:
:
BEnd
wm
anchorResolutionParams
)
)
)
{
return
true
;
}
}
if
(
aCBWidthChanged
)
{
const
auto
anchorOffsetResolutionParams
=
AnchorPosOffsetResolutionParams
:
:
UseCBFrameSize
(
anchorResolutionParams
)
;
if
(
!
IsFixedOffset
(
pos
-
>
GetAnchorResolvedInset
(
eSideLeft
anchorOffsetResolutionParams
)
)
)
{
return
true
;
}
if
(
(
wm
.
GetInlineDir
(
)
=
=
WritingMode
:
:
InlineDir
:
:
RTL
|
|
wm
.
GetBlockDir
(
)
=
=
WritingMode
:
:
BlockDir
:
:
RL
)
&
&
!
pos
-
>
GetAnchorResolvedInset
(
eSideRight
anchorOffsetResolutionParams
)
-
>
IsAuto
(
)
)
{
return
true
;
}
}
if
(
aCBHeightChanged
)
{
const
auto
anchorOffsetResolutionParams
=
AnchorPosOffsetResolutionParams
:
:
UseCBFrameSize
(
anchorResolutionParams
)
;
if
(
!
IsFixedOffset
(
pos
-
>
GetAnchorResolvedInset
(
eSideTop
anchorOffsetResolutionParams
)
)
)
{
return
true
;
}
if
(
wm
.
GetInlineDir
(
)
=
=
WritingMode
:
:
InlineDir
:
:
BTT
&
&
!
pos
-
>
GetAnchorResolvedInset
(
eSideBottom
anchorOffsetResolutionParams
)
-
>
IsAuto
(
)
)
{
return
true
;
}
}
return
false
;
}
void
nsAbsoluteContainingBlock
:
:
DestroyFrames
(
DestroyContext
&
aContext
)
{
mAbsoluteFrames
.
DestroyFrames
(
aContext
)
;
}
void
nsAbsoluteContainingBlock
:
:
MarkSizeDependentFramesDirty
(
)
{
DoMarkFramesDirty
(
false
)
;
}
void
nsAbsoluteContainingBlock
:
:
MarkAllFramesDirty
(
)
{
DoMarkFramesDirty
(
true
)
;
}
void
nsAbsoluteContainingBlock
:
:
DoMarkFramesDirty
(
bool
aMarkAllDirty
)
{
for
(
nsIFrame
*
kidFrame
:
mAbsoluteFrames
)
{
if
(
aMarkAllDirty
)
{
kidFrame
-
>
MarkSubtreeDirty
(
)
;
}
else
if
(
FrameDependsOnContainer
(
kidFrame
true
true
)
)
{
kidFrame
-
>
AddStateBits
(
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
}
}
}
static
nsContainerFrame
*
GetPlaceholderContainer
(
nsIFrame
*
aPositionedFrame
)
{
nsIFrame
*
placeholder
=
aPositionedFrame
-
>
GetPlaceholderFrame
(
)
;
return
placeholder
?
placeholder
-
>
GetParent
(
)
:
nullptr
;
}
struct
NonAutoAlignParams
{
nscoord
mCurrentStartInset
;
nscoord
mCurrentEndInset
;
NonAutoAlignParams
(
nscoord
aStartInset
nscoord
aEndInset
)
:
mCurrentStartInset
(
aStartInset
)
mCurrentEndInset
(
aEndInset
)
{
}
}
;
static
nscoord
OffsetToAlignedStaticPos
(
const
ReflowInput
&
aKidReflowInput
const
LogicalSize
&
aKidSizeInAbsPosCBWM
const
LogicalSize
&
aAbsPosCBSize
const
nsContainerFrame
*
aPlaceholderContainer
WritingMode
aAbsPosCBWM
LogicalAxis
aAbsPosCBAxis
Maybe
<
NonAutoAlignParams
>
aNonAutoAlignParams
)
{
if
(
!
aPlaceholderContainer
)
{
NS_ERROR
(
"
Missing
placeholder
-
container
when
computing
a
"
"
CSS
Box
Alignment
static
position
"
)
;
return
0
;
}
WritingMode
pcWM
=
aPlaceholderContainer
-
>
GetWritingMode
(
)
;
LogicalAxis
pcAxis
=
(
pcWM
.
IsOrthogonalTo
(
aAbsPosCBWM
)
?
GetOrthogonalAxis
(
aAbsPosCBAxis
)
:
aAbsPosCBAxis
)
;
const
LogicalSize
alignAreaSize
=
[
&
]
(
)
{
if
(
!
aNonAutoAlignParams
)
{
const
bool
placeholderContainerIsContainingBlock
=
aPlaceholderContainer
=
=
aKidReflowInput
.
mCBReflowInput
-
>
mFrame
;
LayoutFrameType
parentType
=
aPlaceholderContainer
-
>
Type
(
)
;
LogicalSize
alignAreaSize
(
pcWM
)
;
if
(
parentType
=
=
LayoutFrameType
:
:
FlexContainer
)
{
if
(
placeholderContainerIsContainingBlock
)
{
alignAreaSize
=
aAbsPosCBSize
.
ConvertTo
(
pcWM
aAbsPosCBWM
)
;
alignAreaSize
-
=
aPlaceholderContainer
-
>
GetLogicalUsedPadding
(
pcWM
)
.
Size
(
pcWM
)
;
}
else
{
alignAreaSize
=
aPlaceholderContainer
-
>
GetLogicalSize
(
pcWM
)
;
LogicalMargin
pcBorderPadding
=
aPlaceholderContainer
-
>
GetLogicalUsedBorderAndPadding
(
pcWM
)
;
alignAreaSize
-
=
pcBorderPadding
.
Size
(
pcWM
)
;
}
return
alignAreaSize
;
}
if
(
parentType
=
=
LayoutFrameType
:
:
GridContainer
)
{
if
(
placeholderContainerIsContainingBlock
)
{
alignAreaSize
=
aAbsPosCBSize
.
ConvertTo
(
pcWM
aAbsPosCBWM
)
;
}
else
{
alignAreaSize
=
aPlaceholderContainer
-
>
GetLogicalSize
(
pcWM
)
;
LogicalMargin
pcBorderPadding
=
aPlaceholderContainer
-
>
GetLogicalUsedBorderAndPadding
(
pcWM
)
;
alignAreaSize
-
=
pcBorderPadding
.
Size
(
pcWM
)
;
}
return
alignAreaSize
;
}
}
return
aAbsPosCBSize
.
ConvertTo
(
pcWM
aAbsPosCBWM
)
;
}
(
)
;
const
nscoord
existingOffset
=
aNonAutoAlignParams
?
aNonAutoAlignParams
-
>
mCurrentStartInset
+
aNonAutoAlignParams
-
>
mCurrentEndInset
:
0
;
const
nscoord
alignAreaSizeInAxis
=
(
(
pcAxis
=
=
LogicalAxis
:
:
Inline
)
?
alignAreaSize
.
ISize
(
pcWM
)
:
alignAreaSize
.
BSize
(
pcWM
)
)
-
existingOffset
;
using
AlignJustifyFlag
=
CSSAlignUtils
:
:
AlignJustifyFlag
;
CSSAlignUtils
:
:
AlignJustifyFlags
flags
(
AlignJustifyFlag
:
:
IgnoreAutoMargins
)
;
StyleAlignFlags
alignConst
=
aNonAutoAlignParams
?
aPlaceholderContainer
-
>
CSSAlignmentForAbsPosChildWithinContainingBlock
(
aKidReflowInput
pcAxis
)
:
aPlaceholderContainer
-
>
CSSAlignmentForAbsPosChild
(
aKidReflowInput
pcAxis
)
;
const
auto
safetyBits
=
alignConst
&
(
StyleAlignFlags
:
:
SAFE
|
StyleAlignFlags
:
:
UNSAFE
)
;
alignConst
&
=
~
StyleAlignFlags
:
:
FLAG_BITS
;
if
(
safetyBits
&
StyleAlignFlags
:
:
SAFE
)
{
flags
+
=
AlignJustifyFlag
:
:
OverflowSafe
;
}
WritingMode
kidWM
=
aKidReflowInput
.
GetWritingMode
(
)
;
if
(
pcWM
.
ParallelAxisStartsOnSameSide
(
pcAxis
kidWM
)
)
{
flags
+
=
AlignJustifyFlag
:
:
SameSide
;
}
if
(
aNonAutoAlignParams
)
{
flags
+
=
AlignJustifyFlag
:
:
AligningMarginBox
;
}
const
nscoord
baselineAdjust
=
nscoord
(
0
)
;
LogicalSize
kidSizeInOwnWM
=
aKidSizeInAbsPosCBWM
.
ConvertTo
(
kidWM
aAbsPosCBWM
)
;
LogicalAxis
kidAxis
=
(
kidWM
.
IsOrthogonalTo
(
aAbsPosCBWM
)
?
GetOrthogonalAxis
(
aAbsPosCBAxis
)
:
aAbsPosCBAxis
)
;
nscoord
offset
=
CSSAlignUtils
:
:
AlignJustifySelf
(
alignConst
kidAxis
flags
baselineAdjust
alignAreaSizeInAxis
aKidReflowInput
kidSizeInOwnWM
)
;
const
auto
rawAlignConst
=
(
pcAxis
=
=
LogicalAxis
:
:
Inline
)
?
aKidReflowInput
.
mStylePosition
-
>
mJustifySelf
.
_0
:
aKidReflowInput
.
mStylePosition
-
>
mAlignSelf
.
_0
;
if
(
aNonAutoAlignParams
&
&
!
safetyBits
&
&
rawAlignConst
!
=
StyleAlignFlags
:
:
AUTO
)
{
const
auto
unionedStartOffset
=
std
:
:
min
(
0
aNonAutoAlignParams
-
>
mCurrentStartInset
)
;
const
auto
cbSize
=
aAbsPosCBSize
.
Size
(
aAbsPosCBAxis
aAbsPosCBWM
)
;
const
auto
unionedEndOffset
=
std
:
:
max
(
cbSize
cbSize
-
aNonAutoAlignParams
-
>
mCurrentEndInset
)
;
const
auto
kidSizeInAxis
=
aKidSizeInAbsPosCBWM
.
Size
(
aAbsPosCBAxis
aAbsPosCBWM
)
;
if
(
unionedEndOffset
-
unionedStartOffset
<
kidSizeInAxis
)
{
offset
=
-
aNonAutoAlignParams
-
>
mCurrentStartInset
+
unionedStartOffset
;
}
else
{
const
auto
start
=
aNonAutoAlignParams
-
>
mCurrentStartInset
;
const
auto
end
=
start
+
kidSizeInAxis
;
if
(
start
<
unionedStartOffset
)
{
offset
=
unionedStartOffset
-
start
;
}
else
if
(
end
>
unionedEndOffset
)
{
offset
=
unionedEndOffset
-
end
;
}
}
}
if
(
!
pcWM
.
ParallelAxisStartsOnSameSide
(
pcAxis
aAbsPosCBWM
)
)
{
return
-
offset
;
}
return
offset
;
}
void
nsAbsoluteContainingBlock
:
:
ResolveSizeDependentOffsets
(
nsPresContext
*
aPresContext
ReflowInput
&
aKidReflowInput
const
LogicalSize
&
aKidSize
const
LogicalMargin
&
aMargin
LogicalMargin
*
aOffsets
LogicalSize
*
aLogicalCBSize
)
{
WritingMode
wm
=
aKidReflowInput
.
GetWritingMode
(
)
;
WritingMode
outerWM
=
aKidReflowInput
.
mParentReflowInput
-
>
GetWritingMode
(
)
;
if
(
(
NS_AUTOOFFSET
=
=
aOffsets
-
>
IStart
(
outerWM
)
)
|
|
(
NS_AUTOOFFSET
=
=
aOffsets
-
>
BStart
(
outerWM
)
)
|
|
aKidReflowInput
.
mFlags
.
mIOffsetsNeedCSSAlign
|
|
aKidReflowInput
.
mFlags
.
mBOffsetsNeedCSSAlign
)
{
if
(
-
1
=
=
aLogicalCBSize
-
>
ISize
(
wm
)
)
{
const
ReflowInput
*
parentRI
=
aKidReflowInput
.
mParentReflowInput
;
*
aLogicalCBSize
=
aKidReflowInput
.
ComputeContainingBlockRectangle
(
aPresContext
parentRI
)
;
}
const
LogicalSize
logicalCBSizeOuterWM
=
aLogicalCBSize
-
>
ConvertTo
(
outerWM
wm
)
;
nsContainerFrame
*
placeholderContainer
=
nullptr
;
if
(
NS_AUTOOFFSET
=
=
aOffsets
-
>
IStart
(
outerWM
)
)
{
NS_ASSERTION
(
NS_AUTOOFFSET
!
=
aOffsets
-
>
IEnd
(
outerWM
)
"
Can
'
t
solve
for
both
start
and
end
"
)
;
aOffsets
-
>
IStart
(
outerWM
)
=
logicalCBSizeOuterWM
.
ISize
(
outerWM
)
-
aOffsets
-
>
IEnd
(
outerWM
)
-
aMargin
.
IStartEnd
(
outerWM
)
-
aKidSize
.
ISize
(
outerWM
)
;
}
else
if
(
aKidReflowInput
.
mFlags
.
mIOffsetsNeedCSSAlign
)
{
placeholderContainer
=
GetPlaceholderContainer
(
aKidReflowInput
.
mFrame
)
;
nscoord
offset
=
OffsetToAlignedStaticPos
(
aKidReflowInput
aKidSize
logicalCBSizeOuterWM
placeholderContainer
outerWM
LogicalAxis
:
:
Inline
Nothing
{
}
)
;
aOffsets
-
>
IStart
(
outerWM
)
+
=
offset
;
aOffsets
-
>
IEnd
(
outerWM
)
=
logicalCBSizeOuterWM
.
ISize
(
outerWM
)
-
(
aOffsets
-
>
IStart
(
outerWM
)
+
aKidSize
.
ISize
(
outerWM
)
)
;
}
if
(
NS_AUTOOFFSET
=
=
aOffsets
-
>
BStart
(
outerWM
)
)
{
aOffsets
-
>
BStart
(
outerWM
)
=
logicalCBSizeOuterWM
.
BSize
(
outerWM
)
-
aOffsets
-
>
BEnd
(
outerWM
)
-
aMargin
.
BStartEnd
(
outerWM
)
-
aKidSize
.
BSize
(
outerWM
)
;
}
else
if
(
aKidReflowInput
.
mFlags
.
mBOffsetsNeedCSSAlign
)
{
if
(
!
placeholderContainer
)
{
placeholderContainer
=
GetPlaceholderContainer
(
aKidReflowInput
.
mFrame
)
;
}
nscoord
offset
=
OffsetToAlignedStaticPos
(
aKidReflowInput
aKidSize
logicalCBSizeOuterWM
placeholderContainer
outerWM
LogicalAxis
:
:
Block
Nothing
{
}
)
;
aOffsets
-
>
BStart
(
outerWM
)
+
=
offset
;
aOffsets
-
>
BEnd
(
outerWM
)
=
logicalCBSizeOuterWM
.
BSize
(
outerWM
)
-
(
aOffsets
-
>
BStart
(
outerWM
)
+
aKidSize
.
BSize
(
outerWM
)
)
;
}
aKidReflowInput
.
SetComputedLogicalOffsets
(
outerWM
*
aOffsets
)
;
}
}
void
nsAbsoluteContainingBlock
:
:
ResolveAutoMarginsAfterLayout
(
ReflowInput
&
aKidReflowInput
const
LogicalSize
*
aLogicalCBSize
const
LogicalSize
&
aKidSize
LogicalMargin
&
aMargin
LogicalMargin
&
aOffsets
)
{
MOZ_ASSERT
(
aKidReflowInput
.
mFrame
-
>
HasIntrinsicKeywordForBSize
(
)
)
;
WritingMode
wm
=
aKidReflowInput
.
GetWritingMode
(
)
;
WritingMode
outerWM
=
aKidReflowInput
.
mParentReflowInput
-
>
GetWritingMode
(
)
;
const
LogicalSize
kidSizeInWM
=
aKidSize
.
ConvertTo
(
wm
outerWM
)
;
LogicalMargin
marginInWM
=
aMargin
.
ConvertTo
(
wm
outerWM
)
;
LogicalMargin
offsetsInWM
=
aOffsets
.
ConvertTo
(
wm
outerWM
)
;
const
bool
autoOffset
=
offsetsInWM
.
BEnd
(
wm
)
=
=
NS_AUTOOFFSET
|
|
offsetsInWM
.
BStart
(
wm
)
=
=
NS_AUTOOFFSET
;
nscoord
availMarginSpace
=
autoOffset
?
0
:
aLogicalCBSize
-
>
BSize
(
wm
)
-
kidSizeInWM
.
BSize
(
wm
)
-
offsetsInWM
.
BStartEnd
(
wm
)
-
marginInWM
.
BStartEnd
(
wm
)
;
const
auto
&
styleMargin
=
aKidReflowInput
.
mStyleMargin
;
const
auto
anchorResolutionParams
=
AnchorPosResolutionParams
:
:
From
(
&
aKidReflowInput
)
;
if
(
wm
.
IsOrthogonalTo
(
outerWM
)
)
{
ReflowInput
:
:
ComputeAbsPosInlineAutoMargin
(
availMarginSpace
outerWM
styleMargin
-
>
GetMargin
(
LogicalSide
:
:
IStart
outerWM
anchorResolutionParams
)
-
>
IsAuto
(
)
styleMargin
-
>
GetMargin
(
LogicalSide
:
:
IEnd
outerWM
anchorResolutionParams
)
-
>
IsAuto
(
)
aMargin
aOffsets
)
;
}
else
{
ReflowInput
:
:
ComputeAbsPosBlockAutoMargin
(
availMarginSpace
outerWM
styleMargin
-
>
GetMargin
(
LogicalSide
:
:
BStart
outerWM
anchorResolutionParams
)
-
>
IsAuto
(
)
styleMargin
-
>
GetMargin
(
LogicalSide
:
:
BEnd
outerWM
anchorResolutionParams
)
-
>
IsAuto
(
)
aMargin
aOffsets
)
;
}
aKidReflowInput
.
SetComputedLogicalMargin
(
outerWM
aMargin
)
;
aKidReflowInput
.
SetComputedLogicalOffsets
(
outerWM
aOffsets
)
;
nsMargin
*
propValue
=
aKidReflowInput
.
mFrame
-
>
GetProperty
(
nsIFrame
:
:
UsedMarginProperty
(
)
)
;
MOZ_ASSERT_IF
(
styleMargin
-
>
HasInlineAxisAuto
(
outerWM
anchorResolutionParams
)
|
|
styleMargin
-
>
HasBlockAxisAuto
(
outerWM
anchorResolutionParams
)
propValue
)
;
if
(
propValue
)
{
*
propValue
=
aMargin
.
GetPhysicalMargin
(
outerWM
)
;
}
}
void
nsAbsoluteContainingBlock
:
:
ReflowAbsoluteFrame
(
nsIFrame
*
aDelegatingFrame
nsPresContext
*
aPresContext
const
ReflowInput
&
aReflowInput
const
nsRect
&
aContainingBlock
AbsPosReflowFlags
aFlags
nsIFrame
*
aKidFrame
nsReflowStatus
&
aStatus
OverflowAreas
*
aOverflowAreas
AnchorPosReferencedAnchors
*
aReferencedAnchors
)
{
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
#
ifdef
DEBUG
if
(
nsBlockFrame
:
:
gNoisyReflow
)
{
nsIFrame
:
:
IndentBy
(
stdout
nsBlockFrame
:
:
gNoiseIndent
)
;
printf
(
"
abs
pos
"
)
;
nsAutoString
name
;
aKidFrame
-
>
GetFrameName
(
name
)
;
printf
(
"
%
s
"
NS_LossyConvertUTF16toASCII
(
name
)
.
get
(
)
)
;
char
width
[
16
]
;
char
height
[
16
]
;
PrettyUC
(
aReflowInput
.
AvailableWidth
(
)
width
16
)
;
PrettyUC
(
aReflowInput
.
AvailableHeight
(
)
height
16
)
;
printf
(
"
a
=
%
s
%
s
"
width
height
)
;
PrettyUC
(
aReflowInput
.
ComputedWidth
(
)
width
16
)
;
PrettyUC
(
aReflowInput
.
ComputedHeight
(
)
height
16
)
;
printf
(
"
c
=
%
s
%
s
\
n
"
width
height
)
;
}
AutoNoisyIndenter
indent
(
nsBlockFrame
:
:
gNoisy
)
;
#
endif
WritingMode
wm
=
aKidFrame
-
>
GetWritingMode
(
)
;
LogicalSize
logicalCBSize
(
wm
aContainingBlock
.
Size
(
)
)
;
nscoord
availISize
=
logicalCBSize
.
ISize
(
wm
)
;
if
(
availISize
=
=
-
1
)
{
NS_ASSERTION
(
aReflowInput
.
ComputedSize
(
wm
)
.
ISize
(
wm
)
!
=
NS_UNCONSTRAINEDSIZE
"
Must
have
a
useful
inline
-
size
_somewhere_
"
)
;
availISize
=
aReflowInput
.
ComputedSizeWithPadding
(
wm
)
.
ISize
(
wm
)
;
}
ReflowInput
:
:
InitFlags
initFlags
;
if
(
aFlags
&
AbsPosReflowFlags
:
:
IsGridContainerCB
)
{
nsIFrame
*
placeholder
=
aKidFrame
-
>
GetPlaceholderFrame
(
)
;
if
(
placeholder
&
&
placeholder
-
>
GetParent
(
)
=
=
aDelegatingFrame
)
{
initFlags
+
=
ReflowInput
:
:
InitFlag
:
:
StaticPosIsCBOrigin
;
}
}
bool
constrainBSize
=
(
aReflowInput
.
AvailableBSize
(
)
!
=
NS_UNCONSTRAINEDSIZE
)
&
&
(
aFlags
&
AbsPosReflowFlags
:
:
ConstrainHeight
)
&
&
!
aDelegatingFrame
-
>
IsInlineFrame
(
)
&
&
!
aKidFrame
-
>
IsColumnSetWrapperFrame
(
)
&
&
(
aKidFrame
-
>
GetLogicalRect
(
aContainingBlock
.
Size
(
)
)
.
BStart
(
wm
)
<
=
aReflowInput
.
AvailableBSize
(
)
)
;
const
WritingMode
outerWM
=
aReflowInput
.
GetWritingMode
(
)
;
const
LogicalMargin
border
=
aDelegatingFrame
-
>
GetLogicalUsedBorder
(
outerWM
)
;
const
nscoord
availBSize
=
constrainBSize
?
aReflowInput
.
AvailableBSize
(
)
-
border
.
ConvertTo
(
wm
outerWM
)
.
BStart
(
wm
)
:
NS_UNCONSTRAINEDSIZE
;
ReflowInput
kidReflowInput
(
aPresContext
aReflowInput
aKidFrame
LogicalSize
(
wm
availISize
availBSize
)
Some
(
logicalCBSize
)
initFlags
{
}
{
}
aReferencedAnchors
)
;
if
(
nscoord
kidAvailBSize
=
kidReflowInput
.
AvailableBSize
(
)
;
kidAvailBSize
!
=
NS_UNCONSTRAINEDSIZE
)
{
kidAvailBSize
-
=
kidReflowInput
.
ComputedLogicalMargin
(
wm
)
.
BStart
(
wm
)
;
const
nscoord
kidOffsetBStart
=
kidReflowInput
.
ComputedLogicalOffsets
(
wm
)
.
BStart
(
wm
)
;
if
(
NS_AUTOOFFSET
!
=
kidOffsetBStart
)
{
kidAvailBSize
-
=
kidOffsetBStart
;
}
kidReflowInput
.
SetAvailableBSize
(
kidAvailBSize
)
;
}
ReflowOutput
kidDesiredSize
(
kidReflowInput
)
;
aKidFrame
-
>
Reflow
(
aPresContext
kidDesiredSize
kidReflowInput
aStatus
)
;
if
(
!
aKidFrame
-
>
IsMenuPopupFrame
(
)
)
{
const
LogicalSize
kidSize
=
kidDesiredSize
.
Size
(
outerWM
)
;
LogicalMargin
offsets
=
kidReflowInput
.
ComputedLogicalOffsets
(
outerWM
)
;
LogicalMargin
margin
=
kidReflowInput
.
ComputedLogicalMargin
(
outerWM
)
;
if
(
kidReflowInput
.
mFlags
.
mIOffsetsNeedCSSAlign
)
{
margin
.
IStart
(
outerWM
)
=
margin
.
IEnd
(
outerWM
)
=
0
;
}
if
(
kidReflowInput
.
mFlags
.
mBOffsetsNeedCSSAlign
)
{
margin
.
BStart
(
outerWM
)
=
margin
.
BEnd
(
outerWM
)
=
0
;
}
ResolveSizeDependentOffsets
(
aPresContext
kidReflowInput
kidSize
margin
&
offsets
&
logicalCBSize
)
;
if
(
kidReflowInput
.
mFrame
-
>
HasIntrinsicKeywordForBSize
(
)
)
{
ResolveAutoMarginsAfterLayout
(
kidReflowInput
&
logicalCBSize
kidSize
margin
offsets
)
;
}
const
auto
*
stylePos
=
aKidFrame
-
>
StylePosition
(
)
;
const
auto
anchorResolutionParams
=
AnchorPosOffsetResolutionParams
:
:
UseCBFrameSize
(
AnchorPosResolutionParams
:
:
From
(
aKidFrame
aReferencedAnchors
)
)
;
const
bool
iInsetAuto
=
stylePos
-
>
GetAnchorResolvedInset
(
LogicalSide
:
:
IStart
outerWM
anchorResolutionParams
)
-
>
IsAuto
(
)
|
|
stylePos
-
>
GetAnchorResolvedInset
(
LogicalSide
:
:
IEnd
outerWM
anchorResolutionParams
)
-
>
IsAuto
(
)
;
const
bool
bInsetAuto
=
stylePos
-
>
GetAnchorResolvedInset
(
LogicalSide
:
:
BStart
outerWM
anchorResolutionParams
)
-
>
IsAuto
(
)
|
|
stylePos
-
>
GetAnchorResolvedInset
(
LogicalSide
:
:
BEnd
outerWM
anchorResolutionParams
)
-
>
IsAuto
(
)
;
const
LogicalSize
logicalCBSizeOuterWM
(
outerWM
aContainingBlock
.
Size
(
)
)
;
const
LogicalSize
kidMarginBox
{
outerWM
margin
.
IStartEnd
(
outerWM
)
+
kidSize
.
ISize
(
outerWM
)
margin
.
BStartEnd
(
outerWM
)
+
kidSize
.
BSize
(
outerWM
)
}
;
const
auto
*
placeholderContainer
=
GetPlaceholderContainer
(
kidReflowInput
.
mFrame
)
;
if
(
!
iInsetAuto
)
{
MOZ_ASSERT
(
!
kidReflowInput
.
mFlags
.
mIOffsetsNeedCSSAlign
"
Non
-
auto
inline
inset
but
requires
CSS
alignment
for
static
"
"
position
?
"
)
;
auto
alignOffset
=
OffsetToAlignedStaticPos
(
kidReflowInput
kidMarginBox
logicalCBSizeOuterWM
placeholderContainer
outerWM
LogicalAxis
:
:
Inline
Some
(
NonAutoAlignParams
{
offsets
.
IStart
(
outerWM
)
offsets
.
IEnd
(
outerWM
)
}
)
)
;
offsets
.
IStart
(
outerWM
)
+
=
alignOffset
;
offsets
.
IEnd
(
outerWM
)
=
logicalCBSizeOuterWM
.
ISize
(
outerWM
)
-
(
offsets
.
IStart
(
outerWM
)
+
kidMarginBox
.
ISize
(
outerWM
)
)
;
}
if
(
!
bInsetAuto
)
{
MOZ_ASSERT
(
!
kidReflowInput
.
mFlags
.
mBOffsetsNeedCSSAlign
"
Non
-
auto
block
inset
but
requires
CSS
alignment
for
static
"
"
position
?
"
)
;
auto
alignOffset
=
OffsetToAlignedStaticPos
(
kidReflowInput
kidMarginBox
logicalCBSizeOuterWM
placeholderContainer
outerWM
LogicalAxis
:
:
Block
Some
(
NonAutoAlignParams
{
offsets
.
BStart
(
outerWM
)
offsets
.
BEnd
(
outerWM
)
}
)
)
;
offsets
.
BStart
(
outerWM
)
+
=
alignOffset
;
offsets
.
BEnd
(
outerWM
)
=
logicalCBSizeOuterWM
.
BSize
(
outerWM
)
-
(
offsets
.
BStart
(
outerWM
)
+
kidMarginBox
.
BSize
(
outerWM
)
)
;
}
LogicalRect
rect
(
outerWM
border
.
StartOffset
(
outerWM
)
+
offsets
.
StartOffset
(
outerWM
)
+
margin
.
StartOffset
(
outerWM
)
kidSize
)
;
nsRect
r
=
rect
.
GetPhysicalRect
(
outerWM
logicalCBSize
.
GetPhysicalSize
(
wm
)
+
border
.
Size
(
outerWM
)
.
GetPhysicalSize
(
outerWM
)
)
;
r
.
x
+
=
aContainingBlock
.
x
;
r
.
y
+
=
aContainingBlock
.
y
;
aKidFrame
-
>
SetRect
(
r
)
;
nsView
*
view
=
aKidFrame
-
>
GetView
(
)
;
if
(
view
)
{
nsContainerFrame
:
:
SyncFrameViewAfterReflow
(
aPresContext
aKidFrame
view
kidDesiredSize
.
InkOverflow
(
)
)
;
}
else
{
nsContainerFrame
:
:
PositionChildViews
(
aKidFrame
)
;
}
}
aKidFrame
-
>
DidReflow
(
aPresContext
&
kidReflowInput
)
;
const
nsRect
r
=
aKidFrame
-
>
GetRect
(
)
;
#
ifdef
DEBUG
if
(
nsBlockFrame
:
:
gNoisyReflow
)
{
nsIFrame
:
:
IndentBy
(
stdout
nsBlockFrame
:
:
gNoiseIndent
-
1
)
;
printf
(
"
abs
pos
"
)
;
nsAutoString
name
;
aKidFrame
-
>
GetFrameName
(
name
)
;
printf
(
"
%
s
"
NS_LossyConvertUTF16toASCII
(
name
)
.
get
(
)
)
;
printf
(
"
%
p
rect
=
%
d
%
d
%
d
%
d
\
n
"
static_cast
<
void
*
>
(
aKidFrame
)
r
.
x
r
.
y
r
.
width
r
.
height
)
;
}
#
endif
if
(
aOverflowAreas
)
{
aOverflowAreas
-
>
UnionWith
(
kidDesiredSize
.
mOverflowAreas
+
r
.
TopLeft
(
)
)
;
}
}
