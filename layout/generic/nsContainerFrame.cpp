#
include
"
nsContainerFrame
.
h
"
#
include
"
nsContainerFrameInlines
.
h
"
#
include
"
mozilla
/
ComputedStyle
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
dom
/
HTMLSummaryElement
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
"
nsAbsoluteContainingBlock
.
h
"
#
include
"
nsAttrValue
.
h
"
#
include
"
nsAttrValueInlines
.
h
"
#
include
"
nsFlexContainerFrame
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsPoint
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsView
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsCSSRendering
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsIBaseWindow
.
h
"
#
include
"
nsBoxLayoutState
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
nsBlockFrame
.
h
"
#
include
"
nsPlaceholderFrame
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderAPI
.
h
"
#
include
<
algorithm
>
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
layout
;
using
mozilla
:
:
gfx
:
:
ColorPattern
;
using
mozilla
:
:
gfx
:
:
DeviceColor
;
using
mozilla
:
:
gfx
:
:
Rect
;
using
mozilla
:
:
gfx
:
:
sRGBColor
;
using
mozilla
:
:
gfx
:
:
ToDeviceColor
;
nsContainerFrame
:
:
~
nsContainerFrame
(
)
=
default
;
NS_QUERYFRAME_HEAD
(
nsContainerFrame
)
NS_QUERYFRAME_ENTRY
(
nsContainerFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsSplittableFrame
)
void
nsContainerFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
nsSplittableFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
if
(
aPrevInFlow
)
{
if
(
aPrevInFlow
-
>
HasAnyStateBits
(
NS_FRAME_HAS_CHILD_WITH_VIEW
)
)
{
AddStateBits
(
NS_FRAME_HAS_CHILD_WITH_VIEW
)
;
}
}
}
void
nsContainerFrame
:
:
SetInitialChildList
(
ChildListID
aListID
nsFrameList
&
aChildList
)
{
#
ifdef
DEBUG
nsIFrame
:
:
VerifyDirtyBitSet
(
aChildList
)
;
for
(
nsIFrame
*
f
:
aChildList
)
{
MOZ_ASSERT
(
f
-
>
GetParent
(
)
=
=
this
"
Unexpected
parent
"
)
;
}
#
endif
if
(
aListID
=
=
kPrincipalList
)
{
MOZ_ASSERT
(
mFrames
.
IsEmpty
(
)
"
unexpected
second
call
to
SetInitialChildList
"
)
;
mFrames
.
SetFrames
(
aChildList
)
;
}
else
if
(
aListID
=
=
kBackdropList
)
{
MOZ_ASSERT
(
StyleDisplay
(
)
-
>
mTopLayer
!
=
StyleTopLayer
:
:
None
"
Only
top
layer
frames
should
have
backdrop
"
)
;
MOZ_ASSERT
(
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
"
Top
layer
frames
should
be
out
-
of
-
flow
"
)
;
MOZ_ASSERT
(
!
GetProperty
(
BackdropProperty
(
)
)
"
We
shouldn
'
t
have
setup
backdrop
frame
list
before
"
)
;
#
ifdef
DEBUG
{
nsIFrame
*
placeholder
=
aChildList
.
FirstChild
(
)
;
MOZ_ASSERT
(
aChildList
.
OnlyChild
(
)
"
Should
have
only
one
backdrop
"
)
;
MOZ_ASSERT
(
placeholder
-
>
IsPlaceholderFrame
(
)
"
The
frame
to
be
stored
should
be
a
placeholder
"
)
;
MOZ_ASSERT
(
static_cast
<
nsPlaceholderFrame
*
>
(
placeholder
)
-
>
GetOutOfFlowFrame
(
)
-
>
IsBackdropFrame
(
)
"
The
placeholder
should
points
to
a
backdrop
frame
"
)
;
}
#
endif
nsFrameList
*
list
=
new
(
PresShell
(
)
)
nsFrameList
(
aChildList
)
;
SetProperty
(
BackdropProperty
(
)
list
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
child
list
"
)
;
}
}
void
nsContainerFrame
:
:
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
{
MOZ_ASSERT
(
aListID
=
=
kPrincipalList
|
|
aListID
=
=
kNoReflowPrincipalList
"
unexpected
child
list
"
)
;
if
(
MOZ_UNLIKELY
(
aFrameList
.
IsEmpty
(
)
)
)
{
return
;
}
DrainSelfOverflowList
(
)
;
mFrames
.
AppendFrames
(
this
aFrameList
)
;
if
(
aListID
!
=
kNoReflowPrincipalList
)
{
PresShell
(
)
-
>
FrameNeedsReflow
(
this
IntrinsicDirty
:
:
TreeChange
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
}
}
void
nsContainerFrame
:
:
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
const
nsLineList
:
:
iterator
*
aPrevFrameLine
nsFrameList
&
aFrameList
)
{
MOZ_ASSERT
(
aListID
=
=
kPrincipalList
|
|
aListID
=
=
kNoReflowPrincipalList
"
unexpected
child
list
"
)
;
NS_ASSERTION
(
!
aPrevFrame
|
|
aPrevFrame
-
>
GetParent
(
)
=
=
this
"
inserting
after
sibling
frame
with
different
parent
"
)
;
if
(
MOZ_UNLIKELY
(
aFrameList
.
IsEmpty
(
)
)
)
{
return
;
}
DrainSelfOverflowList
(
)
;
mFrames
.
InsertFrames
(
this
aPrevFrame
aFrameList
)
;
if
(
aListID
!
=
kNoReflowPrincipalList
)
{
PresShell
(
)
-
>
FrameNeedsReflow
(
this
IntrinsicDirty
:
:
TreeChange
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
}
}
void
nsContainerFrame
:
:
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
{
MOZ_ASSERT
(
aListID
=
=
kPrincipalList
|
|
aListID
=
=
kNoReflowPrincipalList
"
unexpected
child
list
"
)
;
AutoTArray
<
nsIFrame
*
10
>
continuations
;
{
nsIFrame
*
continuation
=
aOldFrame
;
while
(
continuation
)
{
continuations
.
AppendElement
(
continuation
)
;
continuation
=
continuation
-
>
GetNextContinuation
(
)
;
}
}
mozilla
:
:
PresShell
*
presShell
=
PresShell
(
)
;
nsContainerFrame
*
lastParent
=
nullptr
;
const
bool
generateReflowCommand
=
(
kNoReflowPrincipalList
!
=
aListID
)
;
for
(
nsIFrame
*
continuation
:
Reversed
(
continuations
)
)
{
nsContainerFrame
*
parent
=
continuation
-
>
GetParent
(
)
;
parent
-
>
StealFrame
(
continuation
)
;
continuation
-
>
Destroy
(
)
;
if
(
generateReflowCommand
&
&
parent
!
=
lastParent
)
{
presShell
-
>
FrameNeedsReflow
(
parent
IntrinsicDirty
:
:
TreeChange
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
lastParent
=
parent
;
}
}
}
void
nsContainerFrame
:
:
DestroyAbsoluteFrames
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
{
if
(
IsAbsoluteContainer
(
)
)
{
GetAbsoluteContainingBlock
(
)
-
>
DestroyFrames
(
this
aDestructRoot
aPostDestroyData
)
;
MarkAsNotAbsoluteContainingBlock
(
)
;
}
}
void
nsContainerFrame
:
:
SafelyDestroyFrameListProp
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
mozilla
:
:
PresShell
*
aPresShell
FrameListPropertyDescriptor
aProp
)
{
while
(
nsFrameList
*
frameList
=
GetProperty
(
aProp
)
)
{
nsIFrame
*
frame
=
frameList
-
>
RemoveFirstChild
(
)
;
if
(
MOZ_LIKELY
(
frame
)
)
{
frame
-
>
DestroyFrom
(
aDestructRoot
aPostDestroyData
)
;
}
else
{
Unused
<
<
TakeProperty
(
aProp
)
;
frameList
-
>
Delete
(
aPresShell
)
;
return
;
}
}
}
void
nsContainerFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
{
if
(
HasView
(
)
)
{
GetView
(
)
-
>
SetFrame
(
nullptr
)
;
}
DestroyAbsoluteFrames
(
aDestructRoot
aPostDestroyData
)
;
mFrames
.
DestroyFramesFrom
(
aDestructRoot
aPostDestroyData
)
;
if
(
HasAnyStateBits
(
NS_FRAME_PART_OF_IBSPLIT
)
)
{
if
(
nsIFrame
*
prevSib
=
GetProperty
(
nsIFrame
:
:
IBSplitPrevSibling
(
)
)
)
{
NS_WARNING_ASSERTION
(
this
=
=
prevSib
-
>
GetProperty
(
nsIFrame
:
:
IBSplitSibling
(
)
)
"
IB
sibling
chain
is
inconsistent
"
)
;
prevSib
-
>
RemoveProperty
(
nsIFrame
:
:
IBSplitSibling
(
)
)
;
}
if
(
nsIFrame
*
nextSib
=
GetProperty
(
nsIFrame
:
:
IBSplitSibling
(
)
)
)
{
NS_WARNING_ASSERTION
(
this
=
=
nextSib
-
>
GetProperty
(
nsIFrame
:
:
IBSplitPrevSibling
(
)
)
"
IB
sibling
chain
is
inconsistent
"
)
;
nextSib
-
>
RemoveProperty
(
nsIFrame
:
:
IBSplitPrevSibling
(
)
)
;
}
#
ifdef
DEBUG
RemoveStateBits
(
NS_FRAME_PART_OF_IBSPLIT
)
;
#
endif
}
if
(
MOZ_UNLIKELY
(
!
mProperties
.
IsEmpty
(
)
)
)
{
using
T
=
mozilla
:
:
FrameProperties
:
:
UntypedDescriptor
;
bool
hasO
=
false
hasOC
=
false
hasEOC
=
false
hasBackdrop
=
false
;
mProperties
.
ForEach
(
[
&
]
(
const
T
&
aProp
void
*
)
{
if
(
aProp
=
=
OverflowProperty
(
)
)
{
hasO
=
true
;
}
else
if
(
aProp
=
=
OverflowContainersProperty
(
)
)
{
hasOC
=
true
;
}
else
if
(
aProp
=
=
ExcessOverflowContainersProperty
(
)
)
{
hasEOC
=
true
;
}
else
if
(
aProp
=
=
BackdropProperty
(
)
)
{
hasBackdrop
=
true
;
}
return
true
;
}
)
;
nsPresContext
*
pc
=
PresContext
(
)
;
mozilla
:
:
PresShell
*
presShell
=
pc
-
>
PresShell
(
)
;
if
(
hasO
)
{
SafelyDestroyFrameListProp
(
aDestructRoot
aPostDestroyData
presShell
OverflowProperty
(
)
)
;
}
MOZ_ASSERT
(
IsFrameOfType
(
eCanContainOverflowContainers
)
|
|
!
(
hasOC
|
|
hasEOC
)
"
this
type
of
frame
shouldn
'
t
have
overflow
containers
"
)
;
if
(
hasOC
)
{
SafelyDestroyFrameListProp
(
aDestructRoot
aPostDestroyData
presShell
OverflowContainersProperty
(
)
)
;
}
if
(
hasEOC
)
{
SafelyDestroyFrameListProp
(
aDestructRoot
aPostDestroyData
presShell
ExcessOverflowContainersProperty
(
)
)
;
}
MOZ_ASSERT
(
!
GetProperty
(
BackdropProperty
(
)
)
|
|
StyleDisplay
(
)
-
>
mTopLayer
!
=
StyleTopLayer
:
:
None
"
only
top
layer
frame
may
have
backdrop
"
)
;
if
(
hasBackdrop
)
{
SafelyDestroyFrameListProp
(
aDestructRoot
aPostDestroyData
presShell
BackdropProperty
(
)
)
;
}
}
nsSplittableFrame
:
:
DestroyFrom
(
aDestructRoot
aPostDestroyData
)
;
}
const
nsFrameList
&
nsContainerFrame
:
:
GetChildList
(
ChildListID
aListID
)
const
{
switch
(
aListID
)
{
case
kPrincipalList
:
return
mFrames
;
case
kOverflowList
:
{
nsFrameList
*
list
=
GetOverflowFrames
(
)
;
return
list
?
*
list
:
nsFrameList
:
:
EmptyList
(
)
;
}
case
kOverflowContainersList
:
{
nsFrameList
*
list
=
GetOverflowContainers
(
)
;
return
list
?
*
list
:
nsFrameList
:
:
EmptyList
(
)
;
}
case
kExcessOverflowContainersList
:
{
nsFrameList
*
list
=
GetExcessOverflowContainers
(
)
;
return
list
?
*
list
:
nsFrameList
:
:
EmptyList
(
)
;
}
case
kBackdropList
:
{
nsFrameList
*
list
=
GetProperty
(
BackdropProperty
(
)
)
;
return
list
?
*
list
:
nsFrameList
:
:
EmptyList
(
)
;
}
default
:
return
nsSplittableFrame
:
:
GetChildList
(
aListID
)
;
}
}
void
nsContainerFrame
:
:
GetChildLists
(
nsTArray
<
ChildList
>
*
aLists
)
const
{
mFrames
.
AppendIfNonempty
(
aLists
kPrincipalList
)
;
using
T
=
mozilla
:
:
FrameProperties
:
:
UntypedDescriptor
;
mProperties
.
ForEach
(
[
this
aLists
]
(
const
T
&
aProp
void
*
aValue
)
{
typedef
const
nsFrameList
*
L
;
if
(
aProp
=
=
OverflowProperty
(
)
)
{
L
(
aValue
)
-
>
AppendIfNonempty
(
aLists
kOverflowList
)
;
}
else
if
(
aProp
=
=
OverflowContainersProperty
(
)
)
{
MOZ_ASSERT
(
IsFrameOfType
(
nsIFrame
:
:
eCanContainOverflowContainers
)
"
found
unexpected
OverflowContainersProperty
"
)
;
Unused
<
<
this
;
L
(
aValue
)
-
>
AppendIfNonempty
(
aLists
kOverflowContainersList
)
;
}
else
if
(
aProp
=
=
ExcessOverflowContainersProperty
(
)
)
{
MOZ_ASSERT
(
IsFrameOfType
(
nsIFrame
:
:
eCanContainOverflowContainers
)
"
found
unexpected
ExcessOverflowContainersProperty
"
)
;
Unused
<
<
this
;
L
(
aValue
)
-
>
AppendIfNonempty
(
aLists
kExcessOverflowContainersList
)
;
}
else
if
(
aProp
=
=
BackdropProperty
(
)
)
{
L
(
aValue
)
-
>
AppendIfNonempty
(
aLists
kBackdropList
)
;
}
return
true
;
}
)
;
nsSplittableFrame
:
:
GetChildLists
(
aLists
)
;
}
void
nsContainerFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
DisplayBorderBackgroundOutline
(
aBuilder
aLists
)
;
BuildDisplayListForNonBlockChildren
(
aBuilder
aLists
)
;
}
void
nsContainerFrame
:
:
BuildDisplayListForNonBlockChildren
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
DisplayChildFlags
aFlags
)
{
nsIFrame
*
kid
=
mFrames
.
FirstChild
(
)
;
nsDisplayListSet
set
(
aLists
aLists
.
Content
(
)
)
;
while
(
kid
)
{
BuildDisplayListForChild
(
aBuilder
kid
set
aFlags
)
;
kid
=
kid
-
>
GetNextSibling
(
)
;
}
}
class
nsDisplaySelectionOverlay
:
public
nsPaintedDisplayItem
{
public
:
nsDisplaySelectionOverlay
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
int16_t
aSelectionValue
)
:
nsPaintedDisplayItem
(
aBuilder
aFrame
)
mSelectionValue
(
aSelectionValue
)
{
MOZ_COUNT_CTOR
(
nsDisplaySelectionOverlay
)
;
}
MOZ_COUNTED_DTOR_OVERRIDE
(
nsDisplaySelectionOverlay
)
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
;
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
NS_DISPLAY_DECL_NAME
(
"
SelectionOverlay
"
TYPE_SELECTION_OVERLAY
)
private
:
DeviceColor
ComputeColor
(
)
const
;
static
DeviceColor
ComputeColorFromSelectionStyle
(
ComputedStyle
&
)
;
static
DeviceColor
ApplyTransparencyIfNecessary
(
nscolor
)
;
int16_t
mSelectionValue
;
}
;
DeviceColor
nsDisplaySelectionOverlay
:
:
ApplyTransparencyIfNecessary
(
nscolor
aColor
)
{
if
(
NS_GET_A
(
aColor
)
!
=
255
)
{
return
ToDeviceColor
(
aColor
)
;
}
auto
color
=
sRGBColor
:
:
FromABGR
(
aColor
)
;
color
.
a
=
0
.
5
;
return
ToDeviceColor
(
color
)
;
}
DeviceColor
nsDisplaySelectionOverlay
:
:
ComputeColorFromSelectionStyle
(
ComputedStyle
&
aStyle
)
{
return
ApplyTransparencyIfNecessary
(
aStyle
.
GetVisitedDependentColor
(
&
nsStyleBackground
:
:
mBackgroundColor
)
)
;
}
DeviceColor
nsDisplaySelectionOverlay
:
:
ComputeColor
(
)
const
{
LookAndFeel
:
:
ColorID
colorID
;
if
(
RefPtr
<
ComputedStyle
>
style
=
mFrame
-
>
ComputeSelectionStyle
(
mSelectionValue
)
)
{
return
ComputeColorFromSelectionStyle
(
*
style
)
;
}
if
(
mSelectionValue
=
=
nsISelectionController
:
:
SELECTION_ON
)
{
colorID
=
LookAndFeel
:
:
ColorID
:
:
Highlight
;
}
else
if
(
mSelectionValue
=
=
nsISelectionController
:
:
SELECTION_ATTENTION
)
{
colorID
=
LookAndFeel
:
:
ColorID
:
:
TextSelectBackgroundAttention
;
}
else
{
colorID
=
LookAndFeel
:
:
ColorID
:
:
TextSelectBackgroundDisabled
;
}
return
ApplyTransparencyIfNecessary
(
LookAndFeel
:
:
Color
(
colorID
mFrame
NS_RGB
(
255
255
255
)
)
)
;
}
void
nsDisplaySelectionOverlay
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
DrawTarget
&
aDrawTarget
=
*
aCtx
-
>
GetDrawTarget
(
)
;
ColorPattern
color
(
ComputeColor
(
)
)
;
nsIntRect
pxRect
=
GetPaintRect
(
)
.
ToOutsidePixels
(
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
Rect
rect
(
pxRect
.
x
pxRect
.
y
pxRect
.
width
pxRect
.
height
)
;
MaybeSnapToDevicePixels
(
rect
aDrawTarget
true
)
;
aDrawTarget
.
FillRect
(
rect
color
)
;
}
bool
nsDisplaySelectionOverlay
:
:
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
wr
:
:
LayoutRect
bounds
=
wr
:
:
ToLayoutRect
(
LayoutDeviceRect
:
:
FromAppUnits
(
nsRect
(
ToReferenceFrame
(
)
Frame
(
)
-
>
GetSize
(
)
)
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
)
;
aBuilder
.
PushRect
(
bounds
bounds
!
BackfaceIsHidden
(
)
wr
:
:
ToColorF
(
ComputeColor
(
)
)
)
;
return
true
;
}
void
nsContainerFrame
:
:
DisplaySelectionOverlay
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
uint16_t
aContentType
)
{
if
(
!
IsSelected
(
)
|
|
!
IsVisibleForPainting
(
)
)
{
return
;
}
int16_t
displaySelection
=
PresShell
(
)
-
>
GetSelectionFlags
(
)
;
if
(
!
(
displaySelection
&
aContentType
)
)
{
return
;
}
const
nsFrameSelection
*
frameSelection
=
GetConstFrameSelection
(
)
;
int16_t
selectionValue
=
frameSelection
-
>
GetDisplaySelection
(
)
;
if
(
selectionValue
<
=
nsISelectionController
:
:
SELECTION_HIDDEN
)
{
return
;
}
nsIContent
*
newContent
=
mContent
-
>
GetParent
(
)
;
int32_t
offset
=
0
;
if
(
newContent
)
{
offset
=
newContent
-
>
ComputeIndexOf
(
mContent
)
;
}
UniquePtr
<
SelectionDetails
>
details
=
frameSelection
-
>
LookUpSelection
(
newContent
offset
1
false
)
;
if
(
!
details
)
{
return
;
}
bool
normal
=
false
;
for
(
SelectionDetails
*
sd
=
details
.
get
(
)
;
sd
;
sd
=
sd
-
>
mNext
.
get
(
)
)
{
if
(
sd
-
>
mSelectionType
=
=
SelectionType
:
:
eNormal
)
{
normal
=
true
;
}
}
if
(
!
normal
&
&
aContentType
=
=
nsISelectionDisplay
:
:
DISPLAY_IMAGES
)
{
return
;
}
aList
-
>
AppendNewToTop
<
nsDisplaySelectionOverlay
>
(
aBuilder
this
selectionValue
)
;
}
void
nsContainerFrame
:
:
ChildIsDirty
(
nsIFrame
*
aChild
)
{
NS_ASSERTION
(
aChild
-
>
IsSubtreeDirty
(
)
"
child
isn
'
t
actually
dirty
"
)
;
AddStateBits
(
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
}
nsIFrame
:
:
FrameSearchResult
nsContainerFrame
:
:
PeekOffsetNoAmount
(
bool
aForward
int32_t
*
aOffset
)
{
NS_ASSERTION
(
aOffset
&
&
*
aOffset
<
=
1
"
aOffset
out
of
range
"
)
;
return
CONTINUE_EMPTY
;
}
nsIFrame
:
:
FrameSearchResult
nsContainerFrame
:
:
PeekOffsetCharacter
(
bool
aForward
int32_t
*
aOffset
PeekOffsetCharacterOptions
aOptions
)
{
NS_ASSERTION
(
aOffset
&
&
*
aOffset
<
=
1
"
aOffset
out
of
range
"
)
;
return
CONTINUE_EMPTY
;
}
void
nsContainerFrame
:
:
PositionFrameView
(
nsIFrame
*
aKidFrame
)
{
nsIFrame
*
parentFrame
=
aKidFrame
-
>
GetParent
(
)
;
if
(
!
aKidFrame
-
>
HasView
(
)
|
|
!
parentFrame
)
return
;
nsView
*
view
=
aKidFrame
-
>
GetView
(
)
;
nsViewManager
*
vm
=
view
-
>
GetViewManager
(
)
;
nsPoint
pt
;
nsView
*
ancestorView
=
parentFrame
-
>
GetClosestView
(
&
pt
)
;
if
(
ancestorView
!
=
view
-
>
GetParent
(
)
)
{
NS_ASSERTION
(
ancestorView
=
=
view
-
>
GetParent
(
)
-
>
GetParent
(
)
"
Allowed
only
one
anonymous
view
between
frames
"
)
;
return
;
}
pt
+
=
aKidFrame
-
>
GetPosition
(
)
;
vm
-
>
MoveViewTo
(
view
pt
.
x
pt
.
y
)
;
}
nsresult
nsContainerFrame
:
:
ReparentFrameView
(
nsIFrame
*
aChildFrame
nsIFrame
*
aOldParentFrame
nsIFrame
*
aNewParentFrame
)
{
MOZ_ASSERT
(
aChildFrame
"
null
child
frame
pointer
"
)
;
MOZ_ASSERT
(
aOldParentFrame
"
null
old
parent
frame
pointer
"
)
;
MOZ_ASSERT
(
aNewParentFrame
"
null
new
parent
frame
pointer
"
)
;
MOZ_ASSERT
(
aOldParentFrame
!
=
aNewParentFrame
"
same
old
and
new
parent
frame
"
)
;
while
(
!
aOldParentFrame
-
>
HasView
(
)
&
&
!
aNewParentFrame
-
>
HasView
(
)
)
{
aOldParentFrame
=
aOldParentFrame
-
>
GetParent
(
)
;
aNewParentFrame
=
aNewParentFrame
-
>
GetParent
(
)
;
NS_ASSERTION
(
aOldParentFrame
&
&
aNewParentFrame
"
didn
'
t
find
view
"
)
;
if
(
aOldParentFrame
=
=
aNewParentFrame
)
{
break
;
}
}
if
(
aOldParentFrame
=
=
aNewParentFrame
)
{
return
NS_OK
;
}
nsView
*
oldParentView
=
aOldParentFrame
-
>
GetClosestView
(
)
;
nsView
*
newParentView
=
aNewParentFrame
-
>
GetClosestView
(
)
;
if
(
oldParentView
!
=
newParentView
)
{
aChildFrame
-
>
ReparentFrameViewTo
(
oldParentView
-
>
GetViewManager
(
)
newParentView
oldParentView
)
;
}
return
NS_OK
;
}
void
nsContainerFrame
:
:
ReparentFrameViewList
(
const
nsFrameList
&
aChildFrameList
nsIFrame
*
aOldParentFrame
nsIFrame
*
aNewParentFrame
)
{
MOZ_ASSERT
(
aChildFrameList
.
NotEmpty
(
)
"
empty
child
frame
list
"
)
;
MOZ_ASSERT
(
aOldParentFrame
"
null
old
parent
frame
pointer
"
)
;
MOZ_ASSERT
(
aNewParentFrame
"
null
new
parent
frame
pointer
"
)
;
MOZ_ASSERT
(
aOldParentFrame
!
=
aNewParentFrame
"
same
old
and
new
parent
frame
"
)
;
while
(
!
aOldParentFrame
-
>
HasView
(
)
&
&
!
aNewParentFrame
-
>
HasView
(
)
)
{
aOldParentFrame
=
aOldParentFrame
-
>
GetParent
(
)
;
aNewParentFrame
=
aNewParentFrame
-
>
GetParent
(
)
;
NS_ASSERTION
(
aOldParentFrame
&
&
aNewParentFrame
"
didn
'
t
find
view
"
)
;
if
(
aOldParentFrame
=
=
aNewParentFrame
)
{
break
;
}
}
if
(
aOldParentFrame
=
=
aNewParentFrame
)
{
return
;
}
nsView
*
oldParentView
=
aOldParentFrame
-
>
GetClosestView
(
)
;
nsView
*
newParentView
=
aNewParentFrame
-
>
GetClosestView
(
)
;
if
(
oldParentView
!
=
newParentView
)
{
nsViewManager
*
viewManager
=
oldParentView
-
>
GetViewManager
(
)
;
for
(
nsFrameList
:
:
Enumerator
e
(
aChildFrameList
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
)
{
e
.
get
(
)
-
>
ReparentFrameViewTo
(
viewManager
newParentView
oldParentView
)
;
}
}
}
void
nsContainerFrame
:
:
ReparentFrame
(
nsIFrame
*
aFrame
nsContainerFrame
*
aOldParent
nsContainerFrame
*
aNewParent
)
{
NS_ASSERTION
(
aOldParent
=
=
aFrame
-
>
GetParent
(
)
"
Parent
not
consistent
with
expectations
"
)
;
aFrame
-
>
SetParent
(
aNewParent
)
;
ReparentFrameView
(
aFrame
aOldParent
aNewParent
)
;
}
void
nsContainerFrame
:
:
ReparentFrames
(
nsFrameList
&
aFrameList
nsContainerFrame
*
aOldParent
nsContainerFrame
*
aNewParent
)
{
for
(
auto
*
f
:
aFrameList
)
{
ReparentFrame
(
f
aOldParent
aNewParent
)
;
}
}
static
nsIWidget
*
GetPresContextContainerWidget
(
nsPresContext
*
aPresContext
)
{
nsCOMPtr
<
nsISupports
>
container
=
aPresContext
-
>
Document
(
)
-
>
GetContainer
(
)
;
nsCOMPtr
<
nsIBaseWindow
>
baseWindow
=
do_QueryInterface
(
container
)
;
if
(
!
baseWindow
)
return
nullptr
;
nsCOMPtr
<
nsIWidget
>
mainWidget
;
baseWindow
-
>
GetMainWidget
(
getter_AddRefs
(
mainWidget
)
)
;
return
mainWidget
;
}
static
bool
IsTopLevelWidget
(
nsIWidget
*
aWidget
)
{
nsWindowType
windowType
=
aWidget
-
>
WindowType
(
)
;
return
windowType
=
=
eWindowType_toplevel
|
|
windowType
=
=
eWindowType_dialog
|
|
windowType
=
=
eWindowType_popup
|
|
windowType
=
=
eWindowType_sheet
;
}
void
nsContainerFrame
:
:
SyncWindowProperties
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
nsView
*
aView
gfxContext
*
aRC
uint32_t
aFlags
)
{
#
ifdef
MOZ_XUL
if
(
!
aView
|
|
!
nsCSSRendering
:
:
IsCanvasFrame
(
aFrame
)
|
|
!
aView
-
>
HasWidget
(
)
)
return
;
nsCOMPtr
<
nsIWidget
>
windowWidget
=
GetPresContextContainerWidget
(
aPresContext
)
;
if
(
!
windowWidget
|
|
!
IsTopLevelWidget
(
windowWidget
)
)
return
;
nsViewManager
*
vm
=
aView
-
>
GetViewManager
(
)
;
nsView
*
rootView
=
vm
-
>
GetRootView
(
)
;
if
(
aView
!
=
rootView
)
return
;
Element
*
rootElement
=
aPresContext
-
>
Document
(
)
-
>
GetRootElement
(
)
;
if
(
!
rootElement
)
{
return
;
}
nsIFrame
*
rootFrame
=
aPresContext
-
>
PresShell
(
)
-
>
FrameConstructor
(
)
-
>
GetRootElementStyleFrame
(
)
;
if
(
!
rootFrame
)
return
;
if
(
aFlags
&
SET_ASYNC
)
{
aView
-
>
SetNeedsWindowPropertiesSync
(
)
;
return
;
}
RefPtr
<
nsPresContext
>
kungFuDeathGrip
(
aPresContext
)
;
AutoWeakFrame
weak
(
rootFrame
)
;
if
(
!
aPresContext
-
>
PresShell
(
)
-
>
GetRootScrollFrame
(
)
)
{
nsTransparencyMode
mode
=
nsLayoutUtils
:
:
GetFrameTransparency
(
aFrame
rootFrame
)
;
StyleWindowShadow
shadow
=
rootFrame
-
>
StyleUIReset
(
)
-
>
mWindowShadow
;
nsCOMPtr
<
nsIWidget
>
viewWidget
=
aView
-
>
GetWidget
(
)
;
viewWidget
-
>
SetTransparencyMode
(
mode
)
;
windowWidget
-
>
SetWindowShadowStyle
(
shadow
)
;
}
if
(
!
aRC
)
return
;
if
(
!
weak
.
IsAlive
(
)
)
{
return
;
}
nsSize
minSize
(
0
0
)
;
nsSize
maxSize
(
NS_UNCONSTRAINEDSIZE
NS_UNCONSTRAINEDSIZE
)
;
if
(
rootElement
-
>
IsXULElement
(
)
)
{
nsBoxLayoutState
aState
(
aPresContext
aRC
)
;
minSize
=
rootFrame
-
>
GetXULMinSize
(
aState
)
;
maxSize
=
rootFrame
-
>
GetXULMaxSize
(
aState
)
;
}
else
{
auto
*
pos
=
rootFrame
-
>
StylePosition
(
)
;
if
(
pos
-
>
mMinWidth
.
ConvertsToLength
(
)
)
{
minSize
.
width
=
pos
-
>
mMinWidth
.
ToLength
(
)
;
}
if
(
pos
-
>
mMinHeight
.
ConvertsToLength
(
)
)
{
minSize
.
height
=
pos
-
>
mMinHeight
.
ToLength
(
)
;
}
if
(
pos
-
>
mMaxWidth
.
ConvertsToLength
(
)
)
{
maxSize
.
width
=
pos
-
>
mMaxWidth
.
ToLength
(
)
;
}
if
(
pos
-
>
mMaxHeight
.
ConvertsToLength
(
)
)
{
maxSize
.
height
=
pos
-
>
mMaxHeight
.
ToLength
(
)
;
}
}
SetSizeConstraints
(
aPresContext
windowWidget
minSize
maxSize
)
;
#
endif
}
void
nsContainerFrame
:
:
SetSizeConstraints
(
nsPresContext
*
aPresContext
nsIWidget
*
aWidget
const
nsSize
&
aMinSize
const
nsSize
&
aMaxSize
)
{
LayoutDeviceIntSize
devMinSize
(
aPresContext
-
>
AppUnitsToDevPixels
(
aMinSize
.
width
)
aPresContext
-
>
AppUnitsToDevPixels
(
aMinSize
.
height
)
)
;
LayoutDeviceIntSize
devMaxSize
(
aMaxSize
.
width
=
=
NS_UNCONSTRAINEDSIZE
?
NS_MAXSIZE
:
aPresContext
-
>
AppUnitsToDevPixels
(
aMaxSize
.
width
)
aMaxSize
.
height
=
=
NS_UNCONSTRAINEDSIZE
?
NS_MAXSIZE
:
aPresContext
-
>
AppUnitsToDevPixels
(
aMaxSize
.
height
)
)
;
if
(
devMinSize
.
width
>
devMaxSize
.
width
)
devMaxSize
.
width
=
devMinSize
.
width
;
if
(
devMinSize
.
height
>
devMaxSize
.
height
)
devMaxSize
.
height
=
devMinSize
.
height
;
nsIWidget
*
rootWidget
=
aPresContext
-
>
GetNearestWidget
(
)
;
DesktopToLayoutDeviceScale
constraintsScale
(
MOZ_WIDGET_INVALID_SCALE
)
;
if
(
rootWidget
)
{
constraintsScale
=
rootWidget
-
>
GetDesktopToDeviceScale
(
)
;
}
widget
:
:
SizeConstraints
constraints
(
devMinSize
devMaxSize
constraintsScale
)
;
LayoutDeviceIntSize
windowSize
=
aWidget
-
>
ClientToWindowSize
(
LayoutDeviceIntSize
(
200
200
)
)
;
if
(
constraints
.
mMinSize
.
width
)
constraints
.
mMinSize
.
width
+
=
windowSize
.
width
-
200
;
if
(
constraints
.
mMinSize
.
height
)
constraints
.
mMinSize
.
height
+
=
windowSize
.
height
-
200
;
if
(
constraints
.
mMaxSize
.
width
!
=
NS_MAXSIZE
)
constraints
.
mMaxSize
.
width
+
=
windowSize
.
width
-
200
;
if
(
constraints
.
mMaxSize
.
height
!
=
NS_MAXSIZE
)
constraints
.
mMaxSize
.
height
+
=
windowSize
.
height
-
200
;
aWidget
-
>
SetSizeConstraints
(
constraints
)
;
}
void
nsContainerFrame
:
:
SyncFrameViewAfterReflow
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
nsView
*
aView
const
nsRect
&
aInkOverflowArea
ReflowChildFlags
aFlags
)
{
if
(
!
aView
)
{
return
;
}
if
(
!
(
aFlags
&
ReflowChildFlags
:
:
NoMoveView
)
)
{
PositionFrameView
(
aFrame
)
;
}
if
(
!
(
aFlags
&
ReflowChildFlags
:
:
NoSizeView
)
)
{
nsViewManager
*
vm
=
aView
-
>
GetViewManager
(
)
;
vm
-
>
ResizeView
(
aView
aInkOverflowArea
true
)
;
}
}
void
nsContainerFrame
:
:
DoInlineMinISize
(
gfxContext
*
aRenderingContext
InlineMinISizeData
*
aData
)
{
auto
handleChildren
=
[
aRenderingContext
]
(
auto
frame
auto
data
)
{
for
(
nsIFrame
*
kid
:
frame
-
>
mFrames
)
{
kid
-
>
AddInlineMinISize
(
aRenderingContext
data
)
;
}
}
;
DoInlineIntrinsicISize
(
aData
handleChildren
)
;
}
void
nsContainerFrame
:
:
DoInlinePrefISize
(
gfxContext
*
aRenderingContext
InlinePrefISizeData
*
aData
)
{
auto
handleChildren
=
[
aRenderingContext
]
(
auto
frame
auto
data
)
{
for
(
nsIFrame
*
kid
:
frame
-
>
mFrames
)
{
kid
-
>
AddInlinePrefISize
(
aRenderingContext
data
)
;
}
}
;
DoInlineIntrinsicISize
(
aData
handleChildren
)
;
aData
-
>
mLineIsEmpty
=
false
;
}
LogicalSize
nsContainerFrame
:
:
ComputeAutoSize
(
gfxContext
*
aRenderingContext
WritingMode
aWM
const
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
LogicalSize
&
aMargin
const
mozilla
:
:
LogicalSize
&
aBorderPadding
const
StyleSizeOverrides
&
aSizeOverrides
ComputeSizeFlags
aFlags
)
{
LogicalSize
result
(
aWM
0xdeadbeef
NS_UNCONSTRAINEDSIZE
)
;
nscoord
availBased
=
aAvailableISize
-
aMargin
.
ISize
(
aWM
)
-
aBorderPadding
.
ISize
(
aWM
)
;
if
(
aFlags
.
contains
(
ComputeSizeFlag
:
:
ShrinkWrap
)
|
|
IsFrameOfType
(
eReplaced
)
)
{
const
auto
&
styleISize
=
aSizeOverrides
.
mStyleISize
?
*
aSizeOverrides
.
mStyleISize
:
StylePosition
(
)
-
>
ISize
(
aWM
)
;
if
(
styleISize
.
IsAuto
(
)
)
{
result
.
ISize
(
aWM
)
=
ShrinkWidthToFit
(
aRenderingContext
availBased
aFlags
)
;
}
}
else
{
result
.
ISize
(
aWM
)
=
availBased
;
}
if
(
IsTableCaption
(
)
)
{
AutoMaybeDisableFontInflation
an
(
this
)
;
WritingMode
tableWM
=
GetParent
(
)
-
>
GetWritingMode
(
)
;
StyleCaptionSide
captionSide
=
StyleTableBorder
(
)
-
>
mCaptionSide
;
if
(
aWM
.
IsOrthogonalTo
(
tableWM
)
)
{
if
(
captionSide
=
=
StyleCaptionSide
:
:
Top
|
|
captionSide
=
=
StyleCaptionSide
:
:
TopOutside
|
|
captionSide
=
=
StyleCaptionSide
:
:
Bottom
|
|
captionSide
=
=
StyleCaptionSide
:
:
BottomOutside
)
{
result
.
ISize
(
aWM
)
=
GetMinISize
(
aRenderingContext
)
;
}
else
{
nscoord
pref
=
GetPrefISize
(
aRenderingContext
)
;
if
(
pref
>
aCBSize
.
ISize
(
aWM
)
)
{
pref
=
aCBSize
.
ISize
(
aWM
)
;
}
if
(
pref
<
result
.
ISize
(
aWM
)
)
{
result
.
ISize
(
aWM
)
=
pref
;
}
}
}
else
{
if
(
captionSide
=
=
StyleCaptionSide
:
:
Left
|
|
captionSide
=
=
StyleCaptionSide
:
:
Right
)
{
result
.
ISize
(
aWM
)
=
GetMinISize
(
aRenderingContext
)
;
}
else
if
(
captionSide
=
=
StyleCaptionSide
:
:
Top
|
|
captionSide
=
=
StyleCaptionSide
:
:
Bottom
)
{
nscoord
min
=
GetMinISize
(
aRenderingContext
)
;
if
(
min
>
aCBSize
.
ISize
(
aWM
)
)
{
min
=
aCBSize
.
ISize
(
aWM
)
;
}
if
(
min
>
result
.
ISize
(
aWM
)
)
{
result
.
ISize
(
aWM
)
=
min
;
}
}
}
}
return
result
;
}
void
nsContainerFrame
:
:
ReflowChild
(
nsIFrame
*
aKidFrame
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
const
WritingMode
&
aWM
const
LogicalPoint
&
aPos
const
nsSize
&
aContainerSize
ReflowChildFlags
aFlags
nsReflowStatus
&
aStatus
nsOverflowContinuationTracker
*
aTracker
)
{
MOZ_ASSERT
(
aReflowInput
.
mFrame
=
=
aKidFrame
"
bad
reflow
input
"
)
;
if
(
aWM
.
IsPhysicalRTL
(
)
)
{
NS_ASSERTION
(
aContainerSize
.
width
!
=
NS_UNCONSTRAINEDSIZE
"
ReflowChild
with
unconstrained
container
width
!
"
)
;
}
MOZ_ASSERT
(
aDesiredSize
.
InkOverflow
(
)
=
=
nsRect
(
0
0
0
0
)
&
&
aDesiredSize
.
ScrollableOverflow
(
)
=
=
nsRect
(
0
0
0
0
)
"
please
reset
the
overflow
areas
before
calling
ReflowChild
"
)
;
if
(
ReflowChildFlags
:
:
NoMoveFrame
!
=
(
aFlags
&
ReflowChildFlags
:
:
NoMoveFrame
)
)
{
aKidFrame
-
>
SetPosition
(
aWM
aPos
aContainerSize
)
;
}
if
(
!
(
aFlags
&
ReflowChildFlags
:
:
NoMoveView
)
)
{
PositionFrameView
(
aKidFrame
)
;
PositionChildViews
(
aKidFrame
)
;
}
aKidFrame
-
>
Reflow
(
aPresContext
aDesiredSize
aReflowInput
aStatus
)
;
if
(
!
aStatus
.
IsInlineBreakBefore
(
)
&
&
aStatus
.
IsFullyComplete
(
)
&
&
!
(
aFlags
&
ReflowChildFlags
:
:
NoDeleteNextInFlowChild
)
)
{
nsIFrame
*
kidNextInFlow
=
aKidFrame
-
>
GetNextInFlow
(
)
;
if
(
kidNextInFlow
)
{
nsOverflowContinuationTracker
:
:
AutoFinish
fini
(
aTracker
aKidFrame
)
;
kidNextInFlow
-
>
GetParent
(
)
-
>
DeleteNextInFlowChild
(
kidNextInFlow
true
)
;
}
}
}
void
nsContainerFrame
:
:
ReflowChild
(
nsIFrame
*
aKidFrame
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nscoord
aX
nscoord
aY
ReflowChildFlags
aFlags
nsReflowStatus
&
aStatus
nsOverflowContinuationTracker
*
aTracker
)
{
MOZ_ASSERT
(
aReflowInput
.
mFrame
=
=
aKidFrame
"
bad
reflow
input
"
)
;
if
(
ReflowChildFlags
:
:
NoMoveFrame
!
=
(
aFlags
&
ReflowChildFlags
:
:
NoMoveFrame
)
)
{
aKidFrame
-
>
SetPosition
(
nsPoint
(
aX
aY
)
)
;
}
if
(
!
(
aFlags
&
ReflowChildFlags
:
:
NoMoveView
)
)
{
PositionFrameView
(
aKidFrame
)
;
PositionChildViews
(
aKidFrame
)
;
}
aKidFrame
-
>
Reflow
(
aPresContext
aDesiredSize
aReflowInput
aStatus
)
;
if
(
aStatus
.
IsFullyComplete
(
)
&
&
!
(
aFlags
&
ReflowChildFlags
:
:
NoDeleteNextInFlowChild
)
)
{
nsIFrame
*
kidNextInFlow
=
aKidFrame
-
>
GetNextInFlow
(
)
;
if
(
kidNextInFlow
)
{
nsOverflowContinuationTracker
:
:
AutoFinish
fini
(
aTracker
aKidFrame
)
;
kidNextInFlow
-
>
GetParent
(
)
-
>
DeleteNextInFlowChild
(
kidNextInFlow
true
)
;
}
}
}
void
nsContainerFrame
:
:
PositionChildViews
(
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_HAS_CHILD_WITH_VIEW
)
)
{
return
;
}
for
(
const
auto
&
[
list
listID
]
:
aFrame
-
>
ChildLists
(
)
)
{
if
(
listID
=
=
kPopupList
)
{
continue
;
}
for
(
nsIFrame
*
childFrame
:
list
)
{
if
(
childFrame
-
>
HasView
(
)
)
{
PositionFrameView
(
childFrame
)
;
}
else
{
PositionChildViews
(
childFrame
)
;
}
}
}
}
#
if
defined
(
_MSC_VER
)
&
&
!
defined
(
__clang__
)
&
&
defined
(
_M_AMD64
)
#
pragma
optimize
(
"
g
"
off
)
#
endif
void
nsContainerFrame
:
:
FinishReflowChild
(
nsIFrame
*
aKidFrame
nsPresContext
*
aPresContext
const
ReflowOutput
&
aDesiredSize
const
ReflowInput
*
aReflowInput
const
WritingMode
&
aWM
const
LogicalPoint
&
aPos
const
nsSize
&
aContainerSize
nsIFrame
:
:
ReflowChildFlags
aFlags
)
{
MOZ_ASSERT
(
!
aReflowInput
|
|
aReflowInput
-
>
mFrame
=
=
aKidFrame
)
;
MOZ_ASSERT
(
aReflowInput
|
|
aKidFrame
-
>
IsFrameOfType
(
eMathML
)
|
|
aKidFrame
-
>
IsTableCellFrame
(
)
"
aReflowInput
should
be
passed
in
almost
all
cases
"
)
;
if
(
aWM
.
IsPhysicalRTL
(
)
)
{
NS_ASSERTION
(
aContainerSize
.
width
!
=
NS_UNCONSTRAINEDSIZE
"
FinishReflowChild
with
unconstrained
container
width
!
"
)
;
}
nsPoint
curOrigin
=
aKidFrame
-
>
GetPosition
(
)
;
const
LogicalSize
convertedSize
=
aDesiredSize
.
Size
(
aWM
)
;
LogicalPoint
pos
(
aPos
)
;
if
(
aFlags
&
ReflowChildFlags
:
:
ApplyRelativePositioning
)
{
MOZ_ASSERT
(
aReflowInput
"
caller
must
have
passed
reflow
input
"
)
;
aKidFrame
-
>
SetSize
(
aWM
convertedSize
)
;
const
LogicalMargin
offsets
=
aReflowInput
-
>
ComputedLogicalOffsets
(
aWM
)
;
ReflowInput
:
:
ApplyRelativePositioning
(
aKidFrame
aWM
offsets
&
pos
aContainerSize
)
;
}
if
(
ReflowChildFlags
:
:
NoMoveFrame
!
=
(
aFlags
&
ReflowChildFlags
:
:
NoMoveFrame
)
)
{
aKidFrame
-
>
SetRect
(
aWM
LogicalRect
(
aWM
pos
convertedSize
)
aContainerSize
)
;
}
else
{
aKidFrame
-
>
SetSize
(
aWM
convertedSize
)
;
}
if
(
aKidFrame
-
>
HasView
(
)
)
{
nsView
*
view
=
aKidFrame
-
>
GetView
(
)
;
SyncFrameViewAfterReflow
(
aPresContext
aKidFrame
view
aDesiredSize
.
InkOverflow
(
)
aFlags
)
;
}
nsPoint
newOrigin
=
aKidFrame
-
>
GetPosition
(
)
;
if
(
!
(
aFlags
&
ReflowChildFlags
:
:
NoMoveView
)
&
&
curOrigin
!
=
newOrigin
)
{
if
(
!
aKidFrame
-
>
HasView
(
)
)
{
PositionChildViews
(
aKidFrame
)
;
}
}
aKidFrame
-
>
DidReflow
(
aPresContext
aReflowInput
)
;
}
#
if
defined
(
_MSC_VER
)
&
&
!
defined
(
__clang__
)
&
&
defined
(
_M_AMD64
)
#
pragma
optimize
(
"
"
on
)
#
endif
void
nsContainerFrame
:
:
FinishReflowChild
(
nsIFrame
*
aKidFrame
nsPresContext
*
aPresContext
const
ReflowOutput
&
aDesiredSize
const
ReflowInput
*
aReflowInput
nscoord
aX
nscoord
aY
ReflowChildFlags
aFlags
)
{
MOZ_ASSERT
(
!
(
aFlags
&
ReflowChildFlags
:
:
ApplyRelativePositioning
)
"
only
the
logical
version
supports
ApplyRelativePositioning
"
"
since
ApplyRelativePositioning
requires
the
container
size
"
)
;
nsPoint
curOrigin
=
aKidFrame
-
>
GetPosition
(
)
;
nsPoint
pos
(
aX
aY
)
;
nsSize
size
(
aDesiredSize
.
PhysicalSize
(
)
)
;
if
(
ReflowChildFlags
:
:
NoMoveFrame
!
=
(
aFlags
&
ReflowChildFlags
:
:
NoMoveFrame
)
)
{
aKidFrame
-
>
SetRect
(
nsRect
(
pos
size
)
)
;
}
else
{
aKidFrame
-
>
SetSize
(
size
)
;
}
if
(
aKidFrame
-
>
HasView
(
)
)
{
nsView
*
view
=
aKidFrame
-
>
GetView
(
)
;
SyncFrameViewAfterReflow
(
aPresContext
aKidFrame
view
aDesiredSize
.
InkOverflow
(
)
aFlags
)
;
}
if
(
!
(
aFlags
&
ReflowChildFlags
:
:
NoMoveView
)
&
&
curOrigin
!
=
pos
)
{
if
(
!
aKidFrame
-
>
HasView
(
)
)
{
PositionChildViews
(
aKidFrame
)
;
}
}
aKidFrame
-
>
DidReflow
(
aPresContext
aReflowInput
)
;
}
void
nsContainerFrame
:
:
ReflowOverflowContainerChildren
(
nsPresContext
*
aPresContext
const
ReflowInput
&
aReflowInput
OverflowAreas
&
aOverflowRects
ReflowChildFlags
aFlags
nsReflowStatus
&
aStatus
ChildFrameMerger
aMergeFunc
Maybe
<
nsSize
>
aContainerSize
)
{
MOZ_ASSERT
(
aPresContext
"
null
pointer
"
)
;
nsFrameList
*
overflowContainers
=
DrainExcessOverflowContainersList
(
aMergeFunc
)
;
if
(
!
overflowContainers
)
{
return
;
}
nsOverflowContinuationTracker
tracker
(
this
false
false
)
;
bool
shouldReflowAllKids
=
aReflowInput
.
ShouldReflowAllKids
(
)
;
for
(
nsIFrame
*
frame
:
*
overflowContainers
)
{
if
(
frame
-
>
GetPrevInFlow
(
)
-
>
GetParent
(
)
!
=
GetPrevInFlow
(
)
)
{
if
(
GetNextInFlow
(
)
)
{
nsReflowStatus
status
;
status
.
SetOverflowIncomplete
(
)
;
aStatus
.
MergeCompletionStatusFrom
(
status
)
;
}
continue
;
}
auto
ScrollableOverflowExceedsAvailableBSize
=
[
this
&
aReflowInput
]
(
nsIFrame
*
aFrame
)
{
if
(
aReflowInput
.
AvailableBSize
(
)
=
=
NS_UNCONSTRAINEDSIZE
)
{
return
false
;
}
const
auto
parentWM
=
GetWritingMode
(
)
;
const
nscoord
scrollableOverflowRectBEnd
=
LogicalRect
(
parentWM
aFrame
-
>
ScrollableOverflowRectRelativeToParent
(
)
GetSize
(
)
)
.
BEnd
(
parentWM
)
;
return
scrollableOverflowRectBEnd
>
aReflowInput
.
AvailableBSize
(
)
;
}
;
if
(
shouldReflowAllKids
|
|
frame
-
>
IsSubtreeDirty
(
)
|
|
ScrollableOverflowExceedsAvailableBSize
(
frame
)
)
{
nsIFrame
*
prevInFlow
=
frame
-
>
GetPrevInFlow
(
)
;
NS_ASSERTION
(
prevInFlow
"
overflow
container
frame
must
have
a
prev
-
in
-
flow
"
)
;
NS_ASSERTION
(
frame
-
>
HasAnyStateBits
(
NS_FRAME_IS_OVERFLOW_CONTAINER
)
"
overflow
container
frame
must
have
overflow
container
bit
set
"
)
;
WritingMode
wm
=
frame
-
>
GetWritingMode
(
)
;
nsSize
containerSize
=
aContainerSize
.
valueOr
(
aReflowInput
.
AvailableSize
(
wm
)
.
GetPhysicalSize
(
wm
)
)
;
LogicalRect
prevRect
=
prevInFlow
-
>
GetLogicalRect
(
wm
containerSize
)
;
LogicalSize
availSpace
(
wm
prevRect
.
ISize
(
wm
)
aReflowInput
.
AvailableSize
(
wm
)
.
BSize
(
wm
)
)
;
ReflowOutput
desiredSize
(
aReflowInput
)
;
ReflowInput
frameState
(
aPresContext
aReflowInput
frame
availSpace
)
;
nsReflowStatus
frameStatus
;
LogicalPoint
pos
(
wm
prevRect
.
IStart
(
wm
)
0
)
;
ReflowChild
(
frame
aPresContext
desiredSize
frameState
wm
pos
containerSize
aFlags
frameStatus
&
tracker
)
;
FinishReflowChild
(
frame
aPresContext
desiredSize
&
frameState
wm
pos
containerSize
aFlags
)
;
if
(
!
frameStatus
.
IsFullyComplete
(
)
)
{
if
(
frame
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
)
{
frameStatus
.
SetOverflowIncomplete
(
)
;
}
else
{
NS_ASSERTION
(
frameStatus
.
IsComplete
(
)
"
overflow
container
frames
can
'
t
be
incomplete
only
"
"
overflow
-
incomplete
"
)
;
}
nsIFrame
*
nif
=
frame
-
>
GetNextInFlow
(
)
;
if
(
!
nif
)
{
NS_ASSERTION
(
frameStatus
.
NextInFlowNeedsReflow
(
)
"
Someone
forgot
a
NextInFlowNeedsReflow
flag
"
)
;
nif
=
PresShell
(
)
-
>
FrameConstructor
(
)
-
>
CreateContinuingFrame
(
frame
this
)
;
}
else
if
(
!
nif
-
>
HasAnyStateBits
(
NS_FRAME_IS_OVERFLOW_CONTAINER
)
)
{
nif
-
>
GetParent
(
)
-
>
StealFrame
(
nif
)
;
}
tracker
.
Insert
(
nif
frameStatus
)
;
}
aStatus
.
MergeCompletionStatusFrom
(
frameStatus
)
;
}
else
{
tracker
.
Skip
(
frame
aStatus
)
;
if
(
aReflowInput
.
mFloatManager
)
{
nsBlockFrame
:
:
RecoverFloatsFor
(
frame
*
aReflowInput
.
mFloatManager
aReflowInput
.
GetWritingMode
(
)
aReflowInput
.
ComputedPhysicalSize
(
)
)
;
}
}
ConsiderChildOverflow
(
aOverflowRects
frame
)
;
}
}
void
nsContainerFrame
:
:
DisplayOverflowContainers
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
nsFrameList
*
overflowconts
=
GetOverflowContainers
(
)
;
if
(
overflowconts
)
{
for
(
nsIFrame
*
frame
:
*
overflowconts
)
{
BuildDisplayListForChild
(
aBuilder
frame
aLists
)
;
}
}
}
bool
nsContainerFrame
:
:
TryRemoveFrame
(
FrameListPropertyDescriptor
aProp
nsIFrame
*
aChildToRemove
)
{
nsFrameList
*
list
=
GetProperty
(
aProp
)
;
if
(
list
&
&
list
-
>
StartRemoveFrame
(
aChildToRemove
)
)
{
if
(
list
-
>
IsEmpty
(
)
)
{
Unused
<
<
TakeProperty
(
aProp
)
;
list
-
>
Delete
(
PresShell
(
)
)
;
}
return
true
;
}
return
false
;
}
bool
nsContainerFrame
:
:
MaybeStealOverflowContainerFrame
(
nsIFrame
*
aChild
)
{
bool
removed
=
false
;
if
(
MOZ_UNLIKELY
(
aChild
-
>
HasAnyStateBits
(
NS_FRAME_IS_OVERFLOW_CONTAINER
)
)
)
{
removed
=
TryRemoveFrame
(
OverflowContainersProperty
(
)
aChild
)
;
if
(
!
removed
)
{
removed
=
TryRemoveFrame
(
ExcessOverflowContainersProperty
(
)
aChild
)
;
}
}
return
removed
;
}
void
nsContainerFrame
:
:
StealFrame
(
nsIFrame
*
aChild
)
{
#
ifdef
DEBUG
if
(
!
mFrames
.
ContainsFrame
(
aChild
)
)
{
nsFrameList
*
list
=
GetOverflowFrames
(
)
;
if
(
!
list
|
|
!
list
-
>
ContainsFrame
(
aChild
)
)
{
list
=
GetOverflowContainers
(
)
;
if
(
!
list
|
|
!
list
-
>
ContainsFrame
(
aChild
)
)
{
list
=
GetExcessOverflowContainers
(
)
;
MOZ_ASSERT
(
list
&
&
list
-
>
ContainsFrame
(
aChild
)
"
aChild
isn
'
t
our
child
"
"
or
on
a
frame
list
not
supported
by
StealFrame
"
)
;
}
}
}
#
endif
if
(
MaybeStealOverflowContainerFrame
(
aChild
)
)
{
return
;
}
if
(
mFrames
.
StartRemoveFrame
(
aChild
)
)
{
return
;
}
nsFrameList
*
frameList
=
GetOverflowFrames
(
)
;
if
(
frameList
&
&
frameList
-
>
ContinueRemoveFrame
(
aChild
)
)
{
if
(
frameList
-
>
IsEmpty
(
)
)
{
DestroyOverflowList
(
)
;
}
return
;
}
MOZ_ASSERT_UNREACHABLE
(
"
StealFrame
:
can
'
t
find
aChild
"
)
;
}
nsFrameList
nsContainerFrame
:
:
StealFramesAfter
(
nsIFrame
*
aChild
)
{
NS_ASSERTION
(
!
aChild
|
|
!
aChild
-
>
HasAnyStateBits
(
NS_FRAME_IS_OVERFLOW_CONTAINER
)
"
StealFramesAfter
doesn
'
t
handle
overflow
containers
"
)
;
NS_ASSERTION
(
!
IsBlockFrame
(
)
"
unexpected
call
"
)
;
if
(
!
aChild
)
{
nsFrameList
copy
(
mFrames
)
;
mFrames
.
Clear
(
)
;
return
copy
;
}
for
(
nsFrameList
:
:
FrameLinkEnumerator
iter
(
mFrames
)
;
!
iter
.
AtEnd
(
)
;
iter
.
Next
(
)
)
{
if
(
iter
.
PrevFrame
(
)
=
=
aChild
)
{
return
mFrames
.
ExtractTail
(
iter
)
;
}
}
nsFrameList
*
overflowFrames
=
GetOverflowFrames
(
)
;
if
(
overflowFrames
)
{
for
(
nsFrameList
:
:
FrameLinkEnumerator
iter
(
*
overflowFrames
)
;
!
iter
.
AtEnd
(
)
;
iter
.
Next
(
)
)
{
if
(
iter
.
PrevFrame
(
)
=
=
aChild
)
{
return
overflowFrames
-
>
ExtractTail
(
iter
)
;
}
}
}
NS_ERROR
(
"
StealFramesAfter
:
can
'
t
find
aChild
"
)
;
return
nsFrameList
:
:
EmptyList
(
)
;
}
nsIFrame
*
nsContainerFrame
:
:
CreateNextInFlow
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
!
IsBlockFrame
(
)
"
you
should
have
called
nsBlockFrame
:
:
CreateContinuationFor
instead
"
)
;
MOZ_ASSERT
(
mFrames
.
ContainsFrame
(
aFrame
)
"
expected
an
in
-
flow
child
frame
"
)
;
nsIFrame
*
nextInFlow
=
aFrame
-
>
GetNextInFlow
(
)
;
if
(
nullptr
=
=
nextInFlow
)
{
nextInFlow
=
PresShell
(
)
-
>
FrameConstructor
(
)
-
>
CreateContinuingFrame
(
aFrame
this
)
;
mFrames
.
InsertFrame
(
nullptr
aFrame
nextInFlow
)
;
NS_FRAME_LOG
(
NS_FRAME_TRACE_NEW_FRAMES
(
"
nsContainerFrame
:
:
CreateNextInFlow
:
frame
=
%
p
nextInFlow
=
%
p
"
aFrame
nextInFlow
)
)
;
return
nextInFlow
;
}
return
nullptr
;
}
void
nsContainerFrame
:
:
DeleteNextInFlowChild
(
nsIFrame
*
aNextInFlow
bool
aDeletingEmptyFrames
)
{
#
ifdef
DEBUG
nsIFrame
*
prevInFlow
=
aNextInFlow
-
>
GetPrevInFlow
(
)
;
#
endif
MOZ_ASSERT
(
prevInFlow
"
bad
prev
-
in
-
flow
"
)
;
nsIFrame
*
nextNextInFlow
=
aNextInFlow
-
>
GetNextInFlow
(
)
;
if
(
nextNextInFlow
)
{
AutoTArray
<
nsIFrame
*
8
>
frames
;
for
(
nsIFrame
*
f
=
nextNextInFlow
;
f
;
f
=
f
-
>
GetNextInFlow
(
)
)
{
frames
.
AppendElement
(
f
)
;
}
for
(
nsIFrame
*
delFrame
:
Reversed
(
frames
)
)
{
delFrame
-
>
GetParent
(
)
-
>
DeleteNextInFlowChild
(
delFrame
aDeletingEmptyFrames
)
;
}
}
StealFrame
(
aNextInFlow
)
;
#
ifdef
DEBUG
if
(
aDeletingEmptyFrames
)
{
nsLayoutUtils
:
:
AssertTreeOnlyEmptyNextInFlows
(
aNextInFlow
)
;
}
#
endif
aNextInFlow
-
>
Destroy
(
)
;
MOZ_ASSERT
(
!
prevInFlow
-
>
GetNextInFlow
(
)
"
non
null
next
-
in
-
flow
"
)
;
}
void
nsContainerFrame
:
:
PushChildrenToOverflow
(
nsIFrame
*
aFromChild
nsIFrame
*
aPrevSibling
)
{
MOZ_ASSERT
(
aFromChild
"
null
pointer
"
)
;
MOZ_ASSERT
(
aPrevSibling
"
pushing
first
child
"
)
;
MOZ_ASSERT
(
aPrevSibling
-
>
GetNextSibling
(
)
=
=
aFromChild
"
bad
prev
sibling
"
)
;
SetOverflowFrames
(
mFrames
.
RemoveFramesAfter
(
aPrevSibling
)
)
;
}
void
nsContainerFrame
:
:
PushChildren
(
nsIFrame
*
aFromChild
nsIFrame
*
aPrevSibling
)
{
MOZ_ASSERT
(
aFromChild
"
null
pointer
"
)
;
MOZ_ASSERT
(
aPrevSibling
"
pushing
first
child
"
)
;
MOZ_ASSERT
(
aPrevSibling
-
>
GetNextSibling
(
)
=
=
aFromChild
"
bad
prev
sibling
"
)
;
nsFrameList
tail
=
mFrames
.
RemoveFramesAfter
(
aPrevSibling
)
;
nsContainerFrame
*
nextInFlow
=
static_cast
<
nsContainerFrame
*
>
(
GetNextInFlow
(
)
)
;
if
(
nextInFlow
)
{
for
(
nsIFrame
*
f
=
aFromChild
;
f
;
f
=
f
-
>
GetNextSibling
(
)
)
{
nsContainerFrame
:
:
ReparentFrameView
(
f
this
nextInFlow
)
;
}
nextInFlow
-
>
mFrames
.
InsertFrames
(
nextInFlow
nullptr
tail
)
;
}
else
{
SetOverflowFrames
(
std
:
:
move
(
tail
)
)
;
}
}
bool
nsContainerFrame
:
:
PushIncompleteChildren
(
const
FrameHashtable
&
aPushedItems
const
FrameHashtable
&
aIncompleteItems
const
FrameHashtable
&
aOverflowIncompleteItems
)
{
MOZ_ASSERT
(
IsFlexOrGridContainer
(
)
"
Only
Grid
/
Flex
containers
can
call
this
!
"
)
;
if
(
aPushedItems
.
IsEmpty
(
)
&
&
aIncompleteItems
.
IsEmpty
(
)
&
&
aOverflowIncompleteItems
.
IsEmpty
(
)
)
{
return
false
;
}
nsFrameList
pushedList
;
nsFrameList
incompleteList
;
nsFrameList
overflowIncompleteList
;
auto
*
fc
=
PresShell
(
)
-
>
FrameConstructor
(
)
;
for
(
nsIFrame
*
child
=
GetChildList
(
kPrincipalList
)
.
FirstChild
(
)
;
child
;
)
{
MOZ_ASSERT
(
(
aPushedItems
.
Contains
(
child
)
?
1
:
0
)
+
(
aIncompleteItems
.
Contains
(
child
)
?
1
:
0
)
+
(
aOverflowIncompleteItems
.
Contains
(
child
)
?
1
:
0
)
<
=
1
"
child
should
only
be
in
one
of
these
sets
"
)
;
nsIFrame
*
next
=
child
-
>
GetNextSibling
(
)
;
if
(
aPushedItems
.
Contains
(
child
)
)
{
MOZ_ASSERT
(
child
-
>
GetParent
(
)
=
=
this
)
;
StealFrame
(
child
)
;
pushedList
.
AppendFrame
(
nullptr
child
)
;
}
else
if
(
aIncompleteItems
.
Contains
(
child
)
)
{
nsIFrame
*
childNIF
=
child
-
>
GetNextInFlow
(
)
;
if
(
!
childNIF
)
{
childNIF
=
fc
-
>
CreateContinuingFrame
(
child
this
)
;
incompleteList
.
AppendFrame
(
nullptr
childNIF
)
;
}
else
{
auto
*
parent
=
childNIF
-
>
GetParent
(
)
;
MOZ_ASSERT
(
parent
!
=
this
|
|
!
mFrames
.
ContainsFrame
(
childNIF
)
"
child
'
s
NIF
shouldn
'
t
be
in
the
same
principal
list
"
)
;
if
(
childNIF
-
>
HasAnyStateBits
(
NS_FRAME_IS_OVERFLOW_CONTAINER
)
|
|
(
parent
!
=
this
&
&
parent
!
=
GetNextInFlow
(
)
)
)
{
parent
-
>
StealFrame
(
childNIF
)
;
childNIF
-
>
RemoveStateBits
(
NS_FRAME_IS_OVERFLOW_CONTAINER
)
;
if
(
parent
=
=
this
)
{
incompleteList
.
AppendFrame
(
nullptr
childNIF
)
;
}
else
{
if
(
parent
=
=
GetNextInFlow
(
)
)
{
nsFrameList
toMove
(
childNIF
childNIF
)
;
parent
-
>
MergeSortedOverflow
(
toMove
)
;
}
else
{
ReparentFrame
(
childNIF
parent
this
)
;
incompleteList
.
AppendFrame
(
nullptr
childNIF
)
;
}
}
}
}
}
else
if
(
aOverflowIncompleteItems
.
Contains
(
child
)
)
{
nsIFrame
*
childNIF
=
child
-
>
GetNextInFlow
(
)
;
if
(
!
childNIF
)
{
childNIF
=
fc
-
>
CreateContinuingFrame
(
child
this
)
;
childNIF
-
>
AddStateBits
(
NS_FRAME_IS_OVERFLOW_CONTAINER
)
;
overflowIncompleteList
.
AppendFrame
(
nullptr
childNIF
)
;
}
else
{
DebugOnly
<
nsContainerFrame
*
>
lastParent
=
this
;
auto
*
nif
=
static_cast
<
nsContainerFrame
*
>
(
GetNextInFlow
(
)
)
;
while
(
childNIF
&
&
!
childNIF
-
>
HasAnyStateBits
(
NS_FRAME_IS_OVERFLOW_CONTAINER
)
)
{
auto
*
parent
=
childNIF
-
>
GetParent
(
)
;
parent
-
>
StealFrame
(
childNIF
)
;
childNIF
-
>
AddStateBits
(
NS_FRAME_IS_OVERFLOW_CONTAINER
)
;
if
(
parent
=
=
this
)
{
overflowIncompleteList
.
AppendFrame
(
nullptr
childNIF
)
;
}
else
{
if
(
!
nif
|
|
parent
=
=
nif
)
{
nsFrameList
toMove
(
childNIF
childNIF
)
;
parent
-
>
MergeSortedExcessOverflowContainers
(
toMove
)
;
}
else
{
ReparentFrame
(
childNIF
parent
nif
)
;
nsFrameList
toMove
(
childNIF
childNIF
)
;
nif
-
>
MergeSortedExcessOverflowContainers
(
toMove
)
;
}
nif
=
nullptr
;
}
lastParent
=
parent
;
childNIF
=
childNIF
-
>
GetNextInFlow
(
)
;
}
}
}
child
=
next
;
}
if
(
!
pushedList
.
IsEmpty
(
)
)
{
MergeSortedOverflow
(
pushedList
)
;
}
if
(
!
incompleteList
.
IsEmpty
(
)
)
{
MergeSortedOverflow
(
incompleteList
)
;
}
if
(
!
overflowIncompleteList
.
IsEmpty
(
)
)
{
auto
*
nif
=
static_cast
<
nsContainerFrame
*
>
(
GetNextInFlow
(
)
)
;
nsFrameList
*
oc
=
nif
?
nif
-
>
GetOverflowContainers
(
)
:
nullptr
;
if
(
oc
)
{
ReparentFrames
(
overflowIncompleteList
this
nif
)
;
MergeSortedFrameLists
(
*
oc
overflowIncompleteList
GetContent
(
)
)
;
}
else
{
MergeSortedExcessOverflowContainers
(
overflowIncompleteList
)
;
}
}
return
true
;
}
void
nsContainerFrame
:
:
NormalizeChildLists
(
)
{
MOZ_ASSERT
(
IsFlexOrGridContainer
(
)
"
Only
Flex
/
Grid
containers
can
call
this
!
"
)
;
const
auto
didPushItemsBit
=
IsFlexContainerFrame
(
)
?
NS_STATE_FLEX_DID_PUSH_ITEMS
:
NS_STATE_GRID_DID_PUSH_ITEMS
;
const
auto
hasChildNifBit
=
IsFlexContainerFrame
(
)
?
NS_STATE_FLEX_HAS_CHILD_NIFS
:
NS_STATE_GRID_HAS_CHILD_NIFS
;
auto
*
prevInFlow
=
static_cast
<
nsContainerFrame
*
>
(
GetPrevInFlow
(
)
)
;
if
(
prevInFlow
)
{
AutoFrameListPtr
overflow
(
PresContext
(
)
prevInFlow
-
>
StealOverflowFrames
(
)
)
;
if
(
overflow
)
{
ReparentFrames
(
*
overflow
prevInFlow
this
)
;
MergeSortedFrameLists
(
mFrames
*
overflow
GetContent
(
)
)
;
nsFrameList
continuations
;
for
(
nsIFrame
*
f
=
mFrames
.
FirstChild
(
)
;
f
;
)
{
nsIFrame
*
next
=
f
-
>
GetNextSibling
(
)
;
nsIFrame
*
pif
=
f
-
>
GetPrevInFlow
(
)
;
if
(
pif
&
&
pif
-
>
GetParent
(
)
=
=
this
)
{
mFrames
.
RemoveFrame
(
f
)
;
continuations
.
AppendFrame
(
nullptr
f
)
;
}
f
=
next
;
}
MergeSortedOverflow
(
continuations
)
;
nsFrameList
*
overflowContainers
=
DrainExcessOverflowContainersList
(
MergeSortedFrameListsFor
)
;
if
(
overflowContainers
)
{
nsFrameList
moveToEOC
;
for
(
nsIFrame
*
f
=
overflowContainers
-
>
FirstChild
(
)
;
f
;
)
{
nsIFrame
*
next
=
f
-
>
GetNextSibling
(
)
;
nsIFrame
*
pif
=
f
-
>
GetPrevInFlow
(
)
;
if
(
pif
&
&
pif
-
>
GetParent
(
)
=
=
this
)
{
overflowContainers
-
>
RemoveFrame
(
f
)
;
moveToEOC
.
AppendFrame
(
nullptr
f
)
;
}
f
=
next
;
}
if
(
overflowContainers
-
>
IsEmpty
(
)
)
{
DestroyOverflowContainers
(
)
;
}
MergeSortedExcessOverflowContainers
(
moveToEOC
)
;
}
}
}
auto
PullItemsNextInFlow
=
[
this
]
(
const
nsFrameList
&
aItems
)
{
auto
*
firstNIF
=
static_cast
<
nsContainerFrame
*
>
(
GetNextInFlow
(
)
)
;
if
(
!
firstNIF
)
{
return
;
}
nsFrameList
childNIFs
;
nsFrameList
childOCNIFs
;
for
(
auto
*
child
:
aItems
)
{
if
(
auto
*
childNIF
=
child
-
>
GetNextInFlow
(
)
)
{
if
(
auto
*
parent
=
childNIF
-
>
GetParent
(
)
;
parent
!
=
this
&
&
parent
!
=
firstNIF
)
{
parent
-
>
StealFrame
(
childNIF
)
;
ReparentFrame
(
childNIF
parent
firstNIF
)
;
if
(
childNIF
-
>
HasAnyStateBits
(
NS_FRAME_IS_OVERFLOW_CONTAINER
)
)
{
childOCNIFs
.
AppendFrame
(
nullptr
childNIF
)
;
}
else
{
childNIFs
.
AppendFrame
(
nullptr
childNIF
)
;
}
}
}
}
firstNIF
-
>
MergeSortedOverflow
(
childNIFs
)
;
firstNIF
-
>
MergeSortedExcessOverflowContainers
(
childOCNIFs
)
;
}
;
DebugOnly
<
bool
>
foundOwnPushedChild
=
false
;
{
nsFrameList
*
ourOverflow
=
GetOverflowFrames
(
)
;
if
(
ourOverflow
)
{
nsFrameList
items
;
for
(
nsIFrame
*
f
=
ourOverflow
-
>
FirstChild
(
)
;
f
;
)
{
nsIFrame
*
next
=
f
-
>
GetNextSibling
(
)
;
nsIFrame
*
pif
=
f
-
>
GetPrevInFlow
(
)
;
if
(
!
pif
|
|
pif
-
>
GetParent
(
)
!
=
this
)
{
MOZ_ASSERT
(
f
-
>
GetParent
(
)
=
=
this
)
;
ourOverflow
-
>
RemoveFrame
(
f
)
;
items
.
AppendFrame
(
nullptr
f
)
;
if
(
!
pif
)
{
foundOwnPushedChild
=
true
;
}
}
f
=
next
;
}
if
(
ourOverflow
-
>
IsEmpty
(
)
)
{
DestroyOverflowList
(
)
;
ourOverflow
=
nullptr
;
}
if
(
items
.
NotEmpty
(
)
)
{
PullItemsNextInFlow
(
items
)
;
}
MergeSortedFrameLists
(
mFrames
items
GetContent
(
)
)
;
}
}
if
(
HasAnyStateBits
(
hasChildNifBit
)
)
{
nsFrameList
framesToPush
;
nsIFrame
*
firstChild
=
mFrames
.
FirstChild
(
)
;
for
(
auto
*
child
=
firstChild
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
auto
*
childNIF
=
child
-
>
GetNextInFlow
(
)
)
{
if
(
childNIF
-
>
GetParent
(
)
=
=
this
)
{
for
(
auto
*
c
=
child
-
>
GetNextSibling
(
)
;
c
;
c
=
c
-
>
GetNextSibling
(
)
)
{
if
(
c
=
=
childNIF
)
{
mFrames
.
RemoveFrame
(
childNIF
)
;
framesToPush
.
AppendFrame
(
nullptr
childNIF
)
;
break
;
}
}
}
}
}
if
(
!
framesToPush
.
IsEmpty
(
)
)
{
MergeSortedOverflow
(
framesToPush
)
;
}
RemoveStateBits
(
hasChildNifBit
)
;
}
if
(
HasAnyStateBits
(
didPushItemsBit
)
)
{
RemoveStateBits
(
didPushItemsBit
)
;
nsFrameList
items
;
auto
*
nif
=
static_cast
<
nsContainerFrame
*
>
(
GetNextInFlow
(
)
)
;
DebugOnly
<
bool
>
nifNeedPushedItem
=
false
;
while
(
nif
)
{
nsFrameList
nifItems
;
for
(
nsIFrame
*
nifChild
=
nif
-
>
GetChildList
(
kPrincipalList
)
.
FirstChild
(
)
;
nifChild
;
)
{
nsIFrame
*
next
=
nifChild
-
>
GetNextSibling
(
)
;
if
(
!
nifChild
-
>
GetPrevInFlow
(
)
)
{
nif
-
>
StealFrame
(
nifChild
)
;
ReparentFrame
(
nifChild
nif
this
)
;
nifItems
.
AppendFrame
(
nullptr
nifChild
)
;
nifNeedPushedItem
=
false
;
}
nifChild
=
next
;
}
MergeSortedFrameLists
(
items
nifItems
GetContent
(
)
)
;
if
(
!
nif
-
>
HasAnyStateBits
(
didPushItemsBit
)
)
{
MOZ_ASSERT
(
!
nifNeedPushedItem
|
|
mDidPushItemsBitMayLie
"
The
state
bit
stored
in
didPushItemsBit
lied
!
"
)
;
break
;
}
nifNeedPushedItem
=
true
;
for
(
nsIFrame
*
nifChild
=
nif
-
>
GetChildList
(
kOverflowList
)
.
FirstChild
(
)
;
nifChild
;
)
{
nsIFrame
*
next
=
nifChild
-
>
GetNextSibling
(
)
;
if
(
!
nifChild
-
>
GetPrevInFlow
(
)
)
{
nif
-
>
StealFrame
(
nifChild
)
;
ReparentFrame
(
nifChild
nif
this
)
;
nifItems
.
AppendFrame
(
nullptr
nifChild
)
;
nifNeedPushedItem
=
false
;
}
nifChild
=
next
;
}
MergeSortedFrameLists
(
items
nifItems
GetContent
(
)
)
;
nif
-
>
RemoveStateBits
(
didPushItemsBit
)
;
nif
=
static_cast
<
nsContainerFrame
*
>
(
nif
-
>
GetNextInFlow
(
)
)
;
MOZ_ASSERT
(
nif
|
|
!
nifNeedPushedItem
|
|
mDidPushItemsBitMayLie
"
The
state
bit
stored
in
didPushItemsBit
lied
!
"
)
;
}
if
(
!
items
.
IsEmpty
(
)
)
{
PullItemsNextInFlow
(
items
)
;
}
MOZ_ASSERT
(
foundOwnPushedChild
|
|
!
items
.
IsEmpty
(
)
|
|
mDidPushItemsBitMayLie
"
The
state
bit
stored
in
didPushItemsBit
lied
!
"
)
;
MergeSortedFrameLists
(
mFrames
items
GetContent
(
)
)
;
}
}
void
nsContainerFrame
:
:
NoteNewChildren
(
ChildListID
aListID
const
nsFrameList
&
aFrameList
)
{
MOZ_ASSERT
(
aListID
=
=
kPrincipalList
"
unexpected
child
list
"
)
;
MOZ_ASSERT
(
IsFlexOrGridContainer
(
)
"
Only
Flex
/
Grid
containers
can
call
this
!
"
)
;
mozilla
:
:
PresShell
*
presShell
=
PresShell
(
)
;
const
auto
didPushItemsBit
=
IsFlexContainerFrame
(
)
?
NS_STATE_FLEX_DID_PUSH_ITEMS
:
NS_STATE_GRID_DID_PUSH_ITEMS
;
for
(
auto
*
pif
=
GetPrevInFlow
(
)
;
pif
;
pif
=
pif
-
>
GetPrevInFlow
(
)
)
{
pif
-
>
AddStateBits
(
didPushItemsBit
)
;
presShell
-
>
FrameNeedsReflow
(
pif
IntrinsicDirty
:
:
TreeChange
NS_FRAME_IS_DIRTY
)
;
}
}
bool
nsContainerFrame
:
:
MoveOverflowToChildList
(
)
{
bool
result
=
false
;
nsContainerFrame
*
prevInFlow
=
(
nsContainerFrame
*
)
GetPrevInFlow
(
)
;
if
(
nullptr
!
=
prevInFlow
)
{
AutoFrameListPtr
prevOverflowFrames
(
PresContext
(
)
prevInFlow
-
>
StealOverflowFrames
(
)
)
;
if
(
prevOverflowFrames
)
{
NS_ASSERTION
(
mFrames
.
IsEmpty
(
)
|
|
IsTableFrame
(
)
"
bad
overflow
list
"
)
;
nsContainerFrame
:
:
ReparentFrameViewList
(
*
prevOverflowFrames
prevInFlow
this
)
;
mFrames
.
AppendFrames
(
this
*
prevOverflowFrames
)
;
result
=
true
;
}
}
return
DrainSelfOverflowList
(
)
|
|
result
;
}
void
nsContainerFrame
:
:
MergeSortedOverflow
(
nsFrameList
&
aList
)
{
if
(
aList
.
IsEmpty
(
)
)
{
return
;
}
MOZ_ASSERT
(
!
aList
.
FirstChild
(
)
-
>
HasAnyStateBits
(
NS_FRAME_IS_OVERFLOW_CONTAINER
)
"
this
is
the
wrong
list
to
put
this
child
frame
"
)
;
MOZ_ASSERT
(
aList
.
FirstChild
(
)
-
>
GetParent
(
)
=
=
this
)
;
nsFrameList
*
overflow
=
GetOverflowFrames
(
)
;
if
(
overflow
)
{
MergeSortedFrameLists
(
*
overflow
aList
GetContent
(
)
)
;
}
else
{
SetOverflowFrames
(
std
:
:
move
(
aList
)
)
;
}
}
void
nsContainerFrame
:
:
MergeSortedExcessOverflowContainers
(
nsFrameList
&
aList
)
{
if
(
aList
.
IsEmpty
(
)
)
{
return
;
}
MOZ_ASSERT
(
aList
.
FirstChild
(
)
-
>
HasAnyStateBits
(
NS_FRAME_IS_OVERFLOW_CONTAINER
)
"
this
is
the
wrong
list
to
put
this
child
frame
"
)
;
MOZ_ASSERT
(
aList
.
FirstChild
(
)
-
>
GetParent
(
)
=
=
this
)
;
if
(
nsFrameList
*
eoc
=
GetExcessOverflowContainers
(
)
)
{
MergeSortedFrameLists
(
*
eoc
aList
GetContent
(
)
)
;
}
else
{
SetExcessOverflowContainers
(
std
:
:
move
(
aList
)
)
;
}
}
nsIFrame
*
nsContainerFrame
:
:
GetFirstNonAnonBoxInSubtree
(
nsIFrame
*
aFrame
)
{
while
(
aFrame
)
{
if
(
!
aFrame
-
>
Style
(
)
-
>
IsAnonBox
(
)
|
|
nsCSSAnonBoxes
:
:
IsNonElement
(
aFrame
-
>
Style
(
)
-
>
GetPseudoType
(
)
)
)
{
break
;
}
if
(
MOZ_UNLIKELY
(
aFrame
-
>
IsTableWrapperFrame
(
)
)
)
{
nsIFrame
*
captionDescendant
=
GetFirstNonAnonBoxInSubtree
(
aFrame
-
>
GetChildList
(
kCaptionList
)
.
FirstChild
(
)
)
;
if
(
captionDescendant
)
{
return
captionDescendant
;
}
}
else
if
(
MOZ_UNLIKELY
(
aFrame
-
>
IsTableFrame
(
)
)
)
{
nsIFrame
*
colgroupDescendant
=
GetFirstNonAnonBoxInSubtree
(
aFrame
-
>
GetChildList
(
kColGroupList
)
.
FirstChild
(
)
)
;
if
(
colgroupDescendant
)
{
return
colgroupDescendant
;
}
}
aFrame
=
aFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
}
return
aFrame
;
}
static
bool
IsPrevContinuationOf
(
nsIFrame
*
aFrame1
nsIFrame
*
aFrame2
)
{
nsIFrame
*
prev
=
aFrame2
;
while
(
(
prev
=
prev
-
>
GetPrevContinuation
(
)
)
)
{
if
(
prev
=
=
aFrame1
)
{
return
true
;
}
}
return
false
;
}
void
nsContainerFrame
:
:
MergeSortedFrameLists
(
nsFrameList
&
aDest
nsFrameList
&
aSrc
nsIContent
*
aCommonAncestor
)
{
auto
FrameForDOMPositionComparison
=
[
]
(
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
-
>
Style
(
)
-
>
IsAnonBox
(
)
)
{
return
aFrame
;
}
for
(
nsIFrame
*
f
=
aFrame
-
>
FirstContinuation
(
)
;
f
;
f
=
f
-
>
GetNextContinuation
(
)
)
{
if
(
nsIFrame
*
nonAnonBox
=
GetFirstNonAnonBoxInSubtree
(
f
)
)
{
return
nonAnonBox
;
}
}
MOZ_ASSERT_UNREACHABLE
(
"
Why
is
there
no
non
-
anonymous
descendants
in
the
continuation
chain
?
"
)
;
return
aFrame
;
}
;
nsIFrame
*
dest
=
aDest
.
FirstChild
(
)
;
for
(
nsIFrame
*
src
=
aSrc
.
FirstChild
(
)
;
src
;
)
{
if
(
!
dest
)
{
aDest
.
AppendFrames
(
nullptr
aSrc
)
;
break
;
}
nsIContent
*
srcContent
=
FrameForDOMPositionComparison
(
src
)
-
>
GetContent
(
)
;
nsIContent
*
destContent
=
FrameForDOMPositionComparison
(
dest
)
-
>
GetContent
(
)
;
int32_t
result
=
nsLayoutUtils
:
:
CompareTreePosition
(
srcContent
destContent
aCommonAncestor
)
;
if
(
MOZ_UNLIKELY
(
result
=
=
0
)
)
{
if
(
MOZ_UNLIKELY
(
srcContent
-
>
IsGeneratedContentContainerForBefore
(
)
)
)
{
if
(
MOZ_LIKELY
(
!
destContent
-
>
IsGeneratedContentContainerForBefore
(
)
)
|
|
:
:
IsPrevContinuationOf
(
src
dest
)
)
{
result
=
-
1
;
}
}
else
if
(
MOZ_UNLIKELY
(
srcContent
-
>
IsGeneratedContentContainerForAfter
(
)
)
)
{
if
(
MOZ_UNLIKELY
(
destContent
-
>
IsGeneratedContentContainerForAfter
(
)
)
&
&
:
:
IsPrevContinuationOf
(
src
dest
)
)
{
result
=
-
1
;
}
}
else
if
(
:
:
IsPrevContinuationOf
(
src
dest
)
)
{
result
=
-
1
;
}
}
if
(
result
<
0
)
{
nsIFrame
*
next
=
src
-
>
GetNextSibling
(
)
;
aSrc
.
RemoveFrame
(
src
)
;
aDest
.
InsertFrame
(
nullptr
dest
-
>
GetPrevSibling
(
)
src
)
;
src
=
next
;
}
else
{
dest
=
dest
-
>
GetNextSibling
(
)
;
}
}
MOZ_ASSERT
(
aSrc
.
IsEmpty
(
)
)
;
}
bool
nsContainerFrame
:
:
MoveInlineOverflowToChildList
(
nsIFrame
*
aLineContainer
)
{
MOZ_ASSERT
(
aLineContainer
"
Must
have
line
container
for
moving
inline
overflows
"
)
;
bool
result
=
false
;
if
(
auto
prevInFlow
=
static_cast
<
nsContainerFrame
*
>
(
GetPrevInFlow
(
)
)
)
{
AutoFrameListPtr
prevOverflowFrames
(
PresContext
(
)
prevInFlow
-
>
StealOverflowFrames
(
)
)
;
if
(
prevOverflowFrames
)
{
if
(
aLineContainer
-
>
GetPrevContinuation
(
)
)
{
ReparentFloatsForInlineChild
(
aLineContainer
prevOverflowFrames
-
>
FirstChild
(
)
true
)
;
}
nsContainerFrame
:
:
ReparentFrameViewList
(
*
prevOverflowFrames
prevInFlow
this
)
;
mFrames
.
InsertFrames
(
this
nullptr
*
prevOverflowFrames
)
;
result
=
true
;
}
}
return
DrainSelfOverflowList
(
)
|
|
result
;
}
bool
nsContainerFrame
:
:
DrainSelfOverflowList
(
)
{
AutoFrameListPtr
overflowFrames
(
PresContext
(
)
StealOverflowFrames
(
)
)
;
if
(
overflowFrames
)
{
mFrames
.
AppendFrames
(
nullptr
*
overflowFrames
)
;
return
true
;
}
return
false
;
}
bool
nsContainerFrame
:
:
DrainAndMergeSelfOverflowList
(
)
{
MOZ_ASSERT
(
IsFlexOrGridContainer
(
)
"
Only
Flex
/
Grid
containers
can
call
this
!
"
)
;
AutoFrameListPtr
overflowFrames
(
PresContext
(
)
StealOverflowFrames
(
)
)
;
if
(
overflowFrames
)
{
MergeSortedFrameLists
(
mFrames
*
overflowFrames
GetContent
(
)
)
;
AddStateBits
(
IsFlexContainerFrame
(
)
?
NS_STATE_FLEX_HAS_CHILD_NIFS
:
NS_STATE_GRID_HAS_CHILD_NIFS
)
;
return
true
;
}
return
false
;
}
nsFrameList
*
nsContainerFrame
:
:
DrainExcessOverflowContainersList
(
ChildFrameMerger
aMergeFunc
)
{
nsFrameList
*
overflowContainers
=
GetOverflowContainers
(
)
;
if
(
auto
*
prev
=
static_cast
<
nsContainerFrame
*
>
(
GetPrevInFlow
(
)
)
)
{
AutoFrameListPtr
excessFrames
(
PresContext
(
)
prev
-
>
StealExcessOverflowContainers
(
)
)
;
if
(
excessFrames
)
{
excessFrames
-
>
ApplySetParent
(
this
)
;
nsContainerFrame
:
:
ReparentFrameViewList
(
*
excessFrames
prev
this
)
;
if
(
overflowContainers
)
{
aMergeFunc
(
*
excessFrames
*
overflowContainers
this
)
;
*
overflowContainers
=
std
:
:
move
(
*
excessFrames
)
;
}
else
{
overflowContainers
=
SetOverflowContainers
(
std
:
:
move
(
*
excessFrames
)
)
;
}
}
}
AutoFrameListPtr
selfExcessOCFrames
(
PresContext
(
)
StealExcessOverflowContainers
(
)
)
;
if
(
selfExcessOCFrames
)
{
nsFrameList
toMove
;
auto
child
=
selfExcessOCFrames
-
>
FirstChild
(
)
;
while
(
child
)
{
auto
next
=
child
-
>
GetNextSibling
(
)
;
MOZ_ASSERT
(
child
-
>
GetPrevInFlow
(
)
"
ExcessOverflowContainers
frames
must
be
continuations
"
)
;
if
(
child
-
>
GetPrevInFlow
(
)
-
>
GetParent
(
)
!
=
this
)
{
selfExcessOCFrames
-
>
RemoveFrame
(
child
)
;
toMove
.
AppendFrame
(
nullptr
child
)
;
}
child
=
next
;
}
if
(
selfExcessOCFrames
-
>
NotEmpty
(
)
)
{
SetExcessOverflowContainers
(
std
:
:
move
(
*
selfExcessOCFrames
)
)
;
}
if
(
toMove
.
NotEmpty
(
)
)
{
if
(
overflowContainers
)
{
aMergeFunc
(
*
overflowContainers
toMove
this
)
;
}
else
{
overflowContainers
=
SetOverflowContainers
(
std
:
:
move
(
toMove
)
)
;
}
}
}
return
overflowContainers
;
}
nsIFrame
*
nsContainerFrame
:
:
GetNextInFlowChild
(
ContinuationTraversingState
&
aState
bool
*
aIsInOverflow
)
{
nsContainerFrame
*
&
nextInFlow
=
aState
.
mNextInFlow
;
while
(
nextInFlow
)
{
nsIFrame
*
frame
=
nextInFlow
-
>
mFrames
.
FirstChild
(
)
;
if
(
frame
)
{
if
(
aIsInOverflow
)
{
*
aIsInOverflow
=
false
;
}
return
frame
;
}
nsFrameList
*
overflowFrames
=
nextInFlow
-
>
GetOverflowFrames
(
)
;
if
(
overflowFrames
)
{
if
(
aIsInOverflow
)
{
*
aIsInOverflow
=
true
;
}
return
overflowFrames
-
>
FirstChild
(
)
;
}
nextInFlow
=
static_cast
<
nsContainerFrame
*
>
(
nextInFlow
-
>
GetNextInFlow
(
)
)
;
}
return
nullptr
;
}
nsIFrame
*
nsContainerFrame
:
:
PullNextInFlowChild
(
ContinuationTraversingState
&
aState
)
{
bool
isInOverflow
;
nsIFrame
*
frame
=
GetNextInFlowChild
(
aState
&
isInOverflow
)
;
if
(
frame
)
{
nsContainerFrame
*
nextInFlow
=
aState
.
mNextInFlow
;
if
(
isInOverflow
)
{
nsFrameList
*
overflowFrames
=
nextInFlow
-
>
GetOverflowFrames
(
)
;
overflowFrames
-
>
RemoveFirstChild
(
)
;
if
(
overflowFrames
-
>
IsEmpty
(
)
)
{
nextInFlow
-
>
DestroyOverflowList
(
)
;
}
}
else
{
nextInFlow
-
>
mFrames
.
RemoveFirstChild
(
)
;
}
mFrames
.
AppendFrame
(
this
frame
)
;
nsContainerFrame
:
:
ReparentFrameView
(
frame
nextInFlow
this
)
;
}
return
frame
;
}
void
nsContainerFrame
:
:
ReparentFloatsForInlineChild
(
nsIFrame
*
aOurLineContainer
nsIFrame
*
aFrame
bool
aReparentSiblings
)
{
NS_ASSERTION
(
aOurLineContainer
-
>
GetNextContinuation
(
)
|
|
aOurLineContainer
-
>
GetPrevContinuation
(
)
"
Don
'
t
call
this
when
we
have
no
continuation
it
'
s
a
waste
"
)
;
if
(
!
aFrame
)
{
NS_ASSERTION
(
aReparentSiblings
"
Why
did
we
get
called
?
"
)
;
return
;
}
nsBlockFrame
*
frameBlock
=
nsLayoutUtils
:
:
GetFloatContainingBlock
(
aFrame
)
;
if
(
!
frameBlock
|
|
frameBlock
=
=
aOurLineContainer
)
{
return
;
}
nsBlockFrame
*
ourBlock
=
do_QueryFrame
(
aOurLineContainer
)
;
NS_ASSERTION
(
ourBlock
"
Not
a
block
but
broke
vertically
?
"
)
;
while
(
true
)
{
ourBlock
-
>
ReparentFloats
(
aFrame
frameBlock
false
)
;
if
(
!
aReparentSiblings
)
return
;
nsIFrame
*
next
=
aFrame
-
>
GetNextSibling
(
)
;
if
(
!
next
)
return
;
if
(
next
-
>
GetParent
(
)
=
=
aFrame
-
>
GetParent
(
)
)
{
aFrame
=
next
;
continue
;
}
ReparentFloatsForInlineChild
(
aOurLineContainer
next
aReparentSiblings
)
;
return
;
}
}
bool
nsContainerFrame
:
:
ResolvedOrientationIsVertical
(
)
{
StyleOrient
orient
=
StyleDisplay
(
)
-
>
mOrient
;
switch
(
orient
)
{
case
StyleOrient
:
:
Horizontal
:
return
false
;
case
StyleOrient
:
:
Vertical
:
return
true
;
case
StyleOrient
:
:
Inline
:
return
GetWritingMode
(
)
.
IsVertical
(
)
;
case
StyleOrient
:
:
Block
:
return
!
GetWritingMode
(
)
.
IsVertical
(
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
-
moz
-
orient
value
"
)
;
return
false
;
}
LogicalSize
nsContainerFrame
:
:
ComputeSizeWithIntrinsicDimensions
(
gfxContext
*
aRenderingContext
WritingMode
aWM
const
IntrinsicSize
&
aIntrinsicSize
const
AspectRatio
&
aAspectRatio
const
LogicalSize
&
aCBSize
const
LogicalSize
&
aMargin
const
LogicalSize
&
aBorderPadding
const
StyleSizeOverrides
&
aSizeOverrides
ComputeSizeFlags
aFlags
)
{
const
nsStylePosition
*
stylePos
=
StylePosition
(
)
;
const
auto
&
styleISize
=
aSizeOverrides
.
mStyleISize
?
*
aSizeOverrides
.
mStyleISize
:
stylePos
-
>
ISize
(
aWM
)
;
const
auto
&
styleBSize
=
aSizeOverrides
.
mStyleBSize
?
*
aSizeOverrides
.
mStyleBSize
:
stylePos
-
>
BSize
(
aWM
)
;
const
auto
&
aspectRatio
=
aSizeOverrides
.
mAspectRatio
?
*
aSizeOverrides
.
mAspectRatio
:
aAspectRatio
;
auto
*
parentFrame
=
GetParent
(
)
;
const
bool
isGridItem
=
IsGridItem
(
)
;
const
bool
isFlexItem
=
IsFlexItem
(
)
&
&
!
parentFrame
-
>
HasAnyStateBits
(
NS_STATE_FLEX_IS_EMULATING_LEGACY_BOX
)
;
LogicalAxis
flexMainAxis
=
eLogicalAxisInline
;
if
(
isFlexItem
)
{
flexMainAxis
=
nsFlexContainerFrame
:
:
IsItemInlineAxisMainAxis
(
this
)
?
eLogicalAxisInline
:
eLogicalAxisBlock
;
}
const
bool
isAutoISize
=
styleISize
.
IsAuto
(
)
;
const
bool
isAutoBSize
=
nsLayoutUtils
:
:
IsAutoBSize
(
styleBSize
aCBSize
.
BSize
(
aWM
)
)
|
|
aFlags
.
contains
(
ComputeSizeFlag
:
:
UseAutoBSize
)
;
const
auto
boxSizingAdjust
=
stylePos
-
>
mBoxSizing
=
=
StyleBoxSizing
:
:
Border
?
aBorderPadding
:
LogicalSize
(
aWM
)
;
const
nscoord
boxSizingToMarginEdgeISize
=
aMargin
.
ISize
(
aWM
)
+
aBorderPadding
.
ISize
(
aWM
)
-
boxSizingAdjust
.
ISize
(
aWM
)
;
nscoord
iSize
minISize
maxISize
bSize
minBSize
maxBSize
;
enum
class
Stretch
{
StretchPreservingRatio
Stretch
NoStretch
}
;
const
auto
eStretchPreservingRatio
=
Stretch
:
:
StretchPreservingRatio
;
const
auto
eStretch
=
Stretch
:
:
Stretch
;
const
auto
eNoStretch
=
Stretch
:
:
NoStretch
;
Stretch
stretchI
=
eNoStretch
;
Stretch
stretchB
=
eNoStretch
;
const
bool
isOrthogonal
=
aWM
.
IsOrthogonalTo
(
parentFrame
-
>
GetWritingMode
(
)
)
;
const
bool
isVertical
=
aWM
.
IsVertical
(
)
;
const
LogicalSize
fallbackIntrinsicSize
(
aWM
kFallbackIntrinsicSize
)
;
const
auto
&
isizeCoord
=
isVertical
?
aIntrinsicSize
.
height
:
aIntrinsicSize
.
width
;
const
bool
hasIntrinsicISize
=
isizeCoord
.
isSome
(
)
;
nscoord
intrinsicISize
=
std
:
:
max
(
0
isizeCoord
.
valueOr
(
0
)
)
;
const
auto
&
bsizeCoord
=
isVertical
?
aIntrinsicSize
.
width
:
aIntrinsicSize
.
height
;
const
bool
hasIntrinsicBSize
=
bsizeCoord
.
isSome
(
)
;
nscoord
intrinsicBSize
=
std
:
:
max
(
0
bsizeCoord
.
valueOr
(
0
)
)
;
if
(
!
isAutoISize
)
{
iSize
=
ComputeISizeValue
(
aRenderingContext
aWM
aCBSize
boxSizingAdjust
boxSizingToMarginEdgeISize
styleISize
aSizeOverrides
aFlags
)
.
mISize
;
}
else
if
(
MOZ_UNLIKELY
(
isGridItem
)
&
&
!
parentFrame
-
>
IsMasonry
(
isOrthogonal
?
eLogicalAxisBlock
:
eLogicalAxisInline
)
)
{
MOZ_ASSERT
(
!
IsTrueOverflowContainer
(
)
)
;
auto
cbSize
=
aCBSize
.
ISize
(
aWM
)
;
if
(
cbSize
!
=
NS_UNCONSTRAINEDSIZE
)
{
if
(
!
StyleMargin
(
)
-
>
HasInlineAxisAuto
(
aWM
)
)
{
auto
inlineAxisAlignment
=
isOrthogonal
?
stylePos
-
>
UsedAlignSelf
(
GetParent
(
)
-
>
Style
(
)
)
.
_0
:
stylePos
-
>
UsedJustifySelf
(
GetParent
(
)
-
>
Style
(
)
)
.
_0
;
if
(
inlineAxisAlignment
=
=
StyleAlignFlags
:
:
STRETCH
)
{
stretchI
=
eStretch
;
}
}
if
(
stretchI
!
=
eNoStretch
|
|
aFlags
.
contains
(
ComputeSizeFlag
:
:
IClampMarginBoxMinSize
)
)
{
iSize
=
std
:
:
max
(
nscoord
(
0
)
cbSize
-
aBorderPadding
.
ISize
(
aWM
)
-
aMargin
.
ISize
(
aWM
)
)
;
}
}
else
{
aFlags
-
=
ComputeSizeFlag
:
:
IClampMarginBoxMinSize
;
}
}
const
auto
&
maxISizeCoord
=
stylePos
-
>
MaxISize
(
aWM
)
;
if
(
!
maxISizeCoord
.
IsNone
(
)
&
&
!
(
isFlexItem
&
&
flexMainAxis
=
=
eLogicalAxisInline
)
)
{
maxISize
=
ComputeISizeValue
(
aRenderingContext
aWM
aCBSize
boxSizingAdjust
boxSizingToMarginEdgeISize
maxISizeCoord
aSizeOverrides
aFlags
)
.
mISize
;
}
else
{
maxISize
=
nscoord_MAX
;
}
const
auto
&
minISizeCoord
=
stylePos
-
>
MinISize
(
aWM
)
;
if
(
!
minISizeCoord
.
IsAuto
(
)
&
&
!
(
isFlexItem
&
&
flexMainAxis
=
=
eLogicalAxisInline
)
)
{
minISize
=
ComputeISizeValue
(
aRenderingContext
aWM
aCBSize
boxSizingAdjust
boxSizingToMarginEdgeISize
minISizeCoord
aSizeOverrides
aFlags
)
.
mISize
;
}
else
{
minISize
=
0
;
}
if
(
!
isAutoBSize
)
{
bSize
=
nsLayoutUtils
:
:
ComputeBSizeValue
(
aCBSize
.
BSize
(
aWM
)
boxSizingAdjust
.
BSize
(
aWM
)
styleBSize
.
AsLengthPercentage
(
)
)
;
}
else
if
(
MOZ_UNLIKELY
(
isGridItem
)
&
&
!
parentFrame
-
>
IsMasonry
(
isOrthogonal
?
eLogicalAxisInline
:
eLogicalAxisBlock
)
)
{
MOZ_ASSERT
(
!
IsTrueOverflowContainer
(
)
)
;
auto
cbSize
=
aCBSize
.
BSize
(
aWM
)
;
if
(
cbSize
!
=
NS_UNCONSTRAINEDSIZE
)
{
if
(
!
StyleMargin
(
)
-
>
HasBlockAxisAuto
(
aWM
)
)
{
auto
blockAxisAlignment
=
!
isOrthogonal
?
stylePos
-
>
UsedAlignSelf
(
GetParent
(
)
-
>
Style
(
)
)
.
_0
:
stylePos
-
>
UsedJustifySelf
(
GetParent
(
)
-
>
Style
(
)
)
.
_0
;
if
(
blockAxisAlignment
=
=
StyleAlignFlags
:
:
STRETCH
)
{
stretchB
=
eStretch
;
}
}
if
(
stretchB
!
=
eNoStretch
|
|
aFlags
.
contains
(
ComputeSizeFlag
:
:
BClampMarginBoxMinSize
)
)
{
bSize
=
std
:
:
max
(
nscoord
(
0
)
cbSize
-
aBorderPadding
.
BSize
(
aWM
)
-
aMargin
.
BSize
(
aWM
)
)
;
}
}
else
{
aFlags
-
=
ComputeSizeFlag
:
:
BClampMarginBoxMinSize
;
}
}
const
auto
&
maxBSizeCoord
=
stylePos
-
>
MaxBSize
(
aWM
)
;
if
(
!
nsLayoutUtils
:
:
IsAutoBSize
(
maxBSizeCoord
aCBSize
.
BSize
(
aWM
)
)
&
&
!
(
isFlexItem
&
&
flexMainAxis
=
=
eLogicalAxisBlock
)
)
{
maxBSize
=
nsLayoutUtils
:
:
ComputeBSizeValue
(
aCBSize
.
BSize
(
aWM
)
boxSizingAdjust
.
BSize
(
aWM
)
maxBSizeCoord
.
AsLengthPercentage
(
)
)
;
}
else
{
maxBSize
=
nscoord_MAX
;
}
const
auto
&
minBSizeCoord
=
stylePos
-
>
MinBSize
(
aWM
)
;
if
(
!
nsLayoutUtils
:
:
IsAutoBSize
(
minBSizeCoord
aCBSize
.
BSize
(
aWM
)
)
&
&
!
(
isFlexItem
&
&
flexMainAxis
=
=
eLogicalAxisBlock
)
)
{
minBSize
=
nsLayoutUtils
:
:
ComputeBSizeValue
(
aCBSize
.
BSize
(
aWM
)
boxSizingAdjust
.
BSize
(
aWM
)
minBSizeCoord
.
AsLengthPercentage
(
)
)
;
}
else
{
minBSize
=
0
;
}
NS_ASSERTION
(
aCBSize
.
ISize
(
aWM
)
!
=
NS_UNCONSTRAINEDSIZE
"
Our
containing
block
must
not
have
unconstrained
inline
-
size
!
"
)
;
if
(
isAutoISize
)
{
if
(
isAutoBSize
)
{
nscoord
tentISize
tentBSize
;
if
(
hasIntrinsicISize
)
{
tentISize
=
intrinsicISize
;
}
else
if
(
hasIntrinsicBSize
&
&
aspectRatio
)
{
tentISize
=
aspectRatio
.
ComputeRatioDependentSize
(
LogicalAxis
:
:
eLogicalAxisInline
aWM
intrinsicBSize
boxSizingAdjust
)
;
}
else
if
(
aspectRatio
)
{
tentISize
=
aCBSize
.
ISize
(
aWM
)
-
boxSizingToMarginEdgeISize
;
if
(
tentISize
<
0
)
{
tentISize
=
0
;
}
}
else
{
tentISize
=
fallbackIntrinsicSize
.
ISize
(
aWM
)
;
}
if
(
aFlags
.
contains
(
ComputeSizeFlag
:
:
IClampMarginBoxMinSize
)
&
&
stretchI
!
=
eStretch
&
&
tentISize
>
iSize
)
{
stretchI
=
(
stretchB
=
=
eStretch
?
eStretch
:
eStretchPreservingRatio
)
;
}
if
(
hasIntrinsicBSize
)
{
tentBSize
=
intrinsicBSize
;
}
else
if
(
aspectRatio
)
{
tentBSize
=
aspectRatio
.
ComputeRatioDependentSize
(
LogicalAxis
:
:
eLogicalAxisBlock
aWM
tentISize
boxSizingAdjust
)
;
}
else
{
tentBSize
=
fallbackIntrinsicSize
.
BSize
(
aWM
)
;
}
if
(
aFlags
.
contains
(
ComputeSizeFlag
:
:
BClampMarginBoxMinSize
)
&
&
stretchB
!
=
eStretch
&
&
tentBSize
>
bSize
)
{
stretchB
=
(
stretchI
=
=
eStretch
?
eStretch
:
eStretchPreservingRatio
)
;
}
if
(
stretchI
=
=
eStretch
)
{
tentISize
=
iSize
;
if
(
stretchB
=
=
eStretch
)
{
tentBSize
=
bSize
;
}
else
if
(
stretchB
=
=
eStretchPreservingRatio
&
&
aspectRatio
)
{
tentBSize
=
aspectRatio
.
ComputeRatioDependentSize
(
LogicalAxis
:
:
eLogicalAxisBlock
aWM
iSize
boxSizingAdjust
)
;
}
}
else
if
(
stretchB
=
=
eStretch
)
{
tentBSize
=
bSize
;
if
(
stretchI
=
=
eStretchPreservingRatio
&
&
aspectRatio
)
{
tentISize
=
aspectRatio
.
ComputeRatioDependentSize
(
LogicalAxis
:
:
eLogicalAxisInline
aWM
bSize
boxSizingAdjust
)
;
}
}
else
if
(
stretchI
=
=
eStretchPreservingRatio
&
&
aspectRatio
)
{
tentISize
=
iSize
;
tentBSize
=
aspectRatio
.
ComputeRatioDependentSize
(
LogicalAxis
:
:
eLogicalAxisBlock
aWM
iSize
boxSizingAdjust
)
;
if
(
stretchB
=
=
eStretchPreservingRatio
&
&
tentBSize
>
bSize
)
{
tentBSize
=
bSize
;
tentISize
=
aspectRatio
.
ComputeRatioDependentSize
(
LogicalAxis
:
:
eLogicalAxisInline
aWM
bSize
boxSizingAdjust
)
;
}
}
else
if
(
stretchB
=
=
eStretchPreservingRatio
&
&
aspectRatio
)
{
tentBSize
=
bSize
;
tentISize
=
aspectRatio
.
ComputeRatioDependentSize
(
LogicalAxis
:
:
eLogicalAxisInline
aWM
bSize
boxSizingAdjust
)
;
}
if
(
aspectRatio
&
&
stretchI
!
=
eStretch
&
&
stretchB
!
=
eStretch
)
{
nsSize
autoSize
=
nsLayoutUtils
:
:
ComputeAutoSizeWithIntrinsicDimensions
(
minISize
minBSize
maxISize
maxBSize
tentISize
tentBSize
)
;
iSize
=
autoSize
.
width
;
bSize
=
autoSize
.
height
;
}
else
{
iSize
=
NS_CSS_MINMAX
(
tentISize
minISize
maxISize
)
;
bSize
=
NS_CSS_MINMAX
(
tentBSize
minBSize
maxBSize
)
;
}
}
else
{
bSize
=
NS_CSS_MINMAX
(
bSize
minBSize
maxBSize
)
;
if
(
stretchI
!
=
eStretch
)
{
if
(
aspectRatio
)
{
iSize
=
aspectRatio
.
ComputeRatioDependentSize
(
LogicalAxis
:
:
eLogicalAxisInline
aWM
bSize
boxSizingAdjust
)
;
}
else
if
(
hasIntrinsicISize
)
{
if
(
!
(
aFlags
.
contains
(
ComputeSizeFlag
:
:
IClampMarginBoxMinSize
)
&
&
intrinsicISize
>
iSize
)
)
{
iSize
=
intrinsicISize
;
}
}
else
{
iSize
=
fallbackIntrinsicSize
.
ISize
(
aWM
)
;
}
}
iSize
=
NS_CSS_MINMAX
(
iSize
minISize
maxISize
)
;
}
}
else
{
if
(
isAutoBSize
)
{
iSize
=
NS_CSS_MINMAX
(
iSize
minISize
maxISize
)
;
if
(
stretchB
!
=
eStretch
)
{
if
(
aspectRatio
)
{
bSize
=
aspectRatio
.
ComputeRatioDependentSize
(
LogicalAxis
:
:
eLogicalAxisBlock
aWM
iSize
boxSizingAdjust
)
;
}
else
if
(
hasIntrinsicBSize
)
{
if
(
!
(
aFlags
.
contains
(
ComputeSizeFlag
:
:
BClampMarginBoxMinSize
)
&
&
intrinsicBSize
>
bSize
)
)
{
bSize
=
intrinsicBSize
;
}
}
else
{
bSize
=
fallbackIntrinsicSize
.
BSize
(
aWM
)
;
}
}
bSize
=
NS_CSS_MINMAX
(
bSize
minBSize
maxBSize
)
;
}
else
{
iSize
=
NS_CSS_MINMAX
(
iSize
minISize
maxISize
)
;
bSize
=
NS_CSS_MINMAX
(
bSize
minBSize
maxBSize
)
;
}
}
return
LogicalSize
(
aWM
iSize
bSize
)
;
}
nsRect
nsContainerFrame
:
:
ComputeSimpleTightBounds
(
DrawTarget
*
aDrawTarget
)
const
{
if
(
StyleOutline
(
)
-
>
ShouldPaintOutline
(
)
|
|
StyleBorder
(
)
-
>
HasBorder
(
)
|
|
!
StyleBackground
(
)
-
>
IsTransparent
(
this
)
|
|
StyleDisplay
(
)
-
>
HasAppearance
(
)
)
{
return
InkOverflowRect
(
)
;
}
nsRect
r
(
0
0
0
0
)
;
for
(
const
auto
&
childLists
:
ChildLists
(
)
)
{
for
(
nsIFrame
*
child
:
childLists
.
mList
)
{
r
.
UnionRect
(
r
child
-
>
ComputeTightBounds
(
aDrawTarget
)
+
child
-
>
GetPosition
(
)
)
;
}
}
return
r
;
}
void
nsContainerFrame
:
:
PushDirtyBitToAbsoluteFrames
(
)
{
if
(
!
HasAnyStateBits
(
NS_FRAME_IS_DIRTY
)
)
{
return
;
}
if
(
!
HasAbsolutelyPositionedChildren
(
)
)
{
return
;
}
GetAbsoluteContainingBlock
(
)
-
>
MarkAllFramesDirty
(
)
;
}
#
define
MAX_FRAME_DEPTH
(
MAX_REFLOW_DEPTH
+
4
)
bool
nsContainerFrame
:
:
IsFrameTreeTooDeep
(
const
ReflowInput
&
aReflowInput
ReflowOutput
&
aMetrics
nsReflowStatus
&
aStatus
)
{
if
(
aReflowInput
.
mReflowDepth
>
MAX_FRAME_DEPTH
)
{
NS_WARNING
(
"
frame
tree
too
deep
;
setting
zero
size
and
returning
"
)
;
AddStateBits
(
NS_FRAME_TOO_DEEP_IN_FRAME_TREE
)
;
ClearOverflowRects
(
)
;
aMetrics
.
ClearSize
(
)
;
aMetrics
.
SetBlockStartAscent
(
0
)
;
aMetrics
.
mCarriedOutBEndMargin
.
Zero
(
)
;
aMetrics
.
mOverflowAreas
.
Clear
(
)
;
aStatus
.
Reset
(
)
;
if
(
GetNextInFlow
(
)
)
{
aStatus
.
SetIncomplete
(
)
;
}
return
true
;
}
RemoveStateBits
(
NS_FRAME_TOO_DEEP_IN_FRAME_TREE
)
;
return
false
;
}
bool
nsContainerFrame
:
:
ShouldAvoidBreakInside
(
const
ReflowInput
&
aReflowInput
)
const
{
const
auto
*
disp
=
StyleDisplay
(
)
;
const
bool
mayAvoidBreak
=
[
&
]
{
switch
(
disp
-
>
mBreakInside
)
{
case
StyleBreakWithin
:
:
Auto
:
return
false
;
case
StyleBreakWithin
:
:
Avoid
:
return
true
;
case
StyleBreakWithin
:
:
AvoidPage
:
return
aReflowInput
.
mBreakType
=
=
ReflowInput
:
:
BreakType
:
:
Page
;
case
StyleBreakWithin
:
:
AvoidColumn
:
return
aReflowInput
.
mBreakType
=
=
ReflowInput
:
:
BreakType
:
:
Column
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
break
-
inside
value
"
)
;
return
false
;
}
(
)
;
if
(
!
mayAvoidBreak
)
{
return
false
;
}
if
(
aReflowInput
.
mFlags
.
mIsTopOfPage
)
{
return
false
;
}
if
(
IsAbsolutelyPositioned
(
disp
)
)
{
return
false
;
}
if
(
GetPrevInFlow
(
)
)
{
return
false
;
}
return
true
;
}
void
nsContainerFrame
:
:
ConsiderChildOverflow
(
OverflowAreas
&
aOverflowAreas
nsIFrame
*
aChildFrame
)
{
if
(
StyleDisplay
(
)
-
>
IsContainLayout
(
)
&
&
IsFrameOfType
(
eSupportsContainLayoutAndPaint
)
)
{
nsRect
childVisual
=
aChildFrame
-
>
InkOverflowRect
(
)
;
OverflowAreas
combined
=
OverflowAreas
(
childVisual
nsRect
(
)
)
;
aOverflowAreas
.
UnionWith
(
combined
+
aChildFrame
-
>
GetPosition
(
)
)
;
}
else
{
aOverflowAreas
.
UnionWith
(
aChildFrame
-
>
GetOverflowAreasRelativeToParent
(
)
)
;
}
}
StyleAlignFlags
nsContainerFrame
:
:
CSSAlignmentForAbsPosChild
(
const
ReflowInput
&
aChildRI
LogicalAxis
aLogicalAxis
)
const
{
MOZ_ASSERT
(
aChildRI
.
mFrame
-
>
IsAbsolutelyPositioned
(
)
"
This
method
should
only
be
called
for
abspos
children
"
)
;
NS_ERROR
(
"
Child
classes
that
use
css
box
alignment
for
abspos
children
"
"
should
provide
their
own
implementation
of
this
method
!
"
)
;
return
StyleAlignFlags
:
:
START
;
}
nsOverflowContinuationTracker
:
:
nsOverflowContinuationTracker
(
nsContainerFrame
*
aFrame
bool
aWalkOOFFrames
bool
aSkipOverflowContainerChildren
)
:
mOverflowContList
(
nullptr
)
mPrevOverflowCont
(
nullptr
)
mSentry
(
nullptr
)
mParent
(
aFrame
)
mSkipOverflowContainerChildren
(
aSkipOverflowContainerChildren
)
mWalkOOFFrames
(
aWalkOOFFrames
)
{
MOZ_ASSERT
(
aFrame
"
null
frame
pointer
"
)
;
SetupOverflowContList
(
)
;
}
void
nsOverflowContinuationTracker
:
:
SetupOverflowContList
(
)
{
MOZ_ASSERT
(
mParent
"
null
frame
pointer
"
)
;
MOZ_ASSERT
(
!
mOverflowContList
"
already
have
list
"
)
;
nsContainerFrame
*
nif
=
static_cast
<
nsContainerFrame
*
>
(
mParent
-
>
GetNextInFlow
(
)
)
;
if
(
nif
)
{
mOverflowContList
=
nif
-
>
GetOverflowContainers
(
)
;
if
(
mOverflowContList
)
{
mParent
=
nif
;
SetUpListWalker
(
)
;
}
}
if
(
!
mOverflowContList
)
{
mOverflowContList
=
mParent
-
>
GetExcessOverflowContainers
(
)
;
if
(
mOverflowContList
)
{
SetUpListWalker
(
)
;
}
}
}
void
nsOverflowContinuationTracker
:
:
SetUpListWalker
(
)
{
NS_ASSERTION
(
!
mSentry
&
&
!
mPrevOverflowCont
"
forgot
to
reset
mSentry
or
mPrevOverflowCont
"
)
;
if
(
mOverflowContList
)
{
nsIFrame
*
cur
=
mOverflowContList
-
>
FirstChild
(
)
;
if
(
mSkipOverflowContainerChildren
)
{
while
(
cur
&
&
cur
-
>
GetPrevInFlow
(
)
-
>
HasAnyStateBits
(
NS_FRAME_IS_OVERFLOW_CONTAINER
)
)
{
mPrevOverflowCont
=
cur
;
cur
=
cur
-
>
GetNextSibling
(
)
;
}
while
(
cur
&
&
(
cur
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
!
=
mWalkOOFFrames
)
)
{
mPrevOverflowCont
=
cur
;
cur
=
cur
-
>
GetNextSibling
(
)
;
}
}
if
(
cur
)
{
mSentry
=
cur
-
>
GetPrevInFlow
(
)
;
}
}
}
void
nsOverflowContinuationTracker
:
:
StepForward
(
)
{
MOZ_ASSERT
(
mOverflowContList
"
null
list
"
)
;
if
(
mPrevOverflowCont
)
{
mPrevOverflowCont
=
mPrevOverflowCont
-
>
GetNextSibling
(
)
;
}
else
{
mPrevOverflowCont
=
mOverflowContList
-
>
FirstChild
(
)
;
}
if
(
mSkipOverflowContainerChildren
)
{
nsIFrame
*
cur
=
mPrevOverflowCont
-
>
GetNextSibling
(
)
;
while
(
cur
&
&
(
cur
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
!
=
mWalkOOFFrames
)
)
{
mPrevOverflowCont
=
cur
;
cur
=
cur
-
>
GetNextSibling
(
)
;
}
}
mSentry
=
(
mPrevOverflowCont
-
>
GetNextSibling
(
)
)
?
mPrevOverflowCont
-
>
GetNextSibling
(
)
-
>
GetPrevInFlow
(
)
:
nullptr
;
}
nsresult
nsOverflowContinuationTracker
:
:
Insert
(
nsIFrame
*
aOverflowCont
nsReflowStatus
&
aReflowStatus
)
{
MOZ_ASSERT
(
aOverflowCont
"
null
frame
pointer
"
)
;
MOZ_ASSERT
(
!
mSkipOverflowContainerChildren
|
|
mWalkOOFFrames
=
=
aOverflowCont
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
"
shouldn
'
t
insert
frame
that
doesn
'
t
match
walker
type
"
)
;
MOZ_ASSERT
(
aOverflowCont
-
>
GetPrevInFlow
(
)
"
overflow
containers
must
have
a
prev
-
in
-
flow
"
)
;
nsresult
rv
=
NS_OK
;
bool
reparented
=
false
;
nsPresContext
*
presContext
=
aOverflowCont
-
>
PresContext
(
)
;
bool
addToList
=
!
mSentry
|
|
aOverflowCont
!
=
mSentry
-
>
GetNextInFlow
(
)
;
if
(
addToList
&
&
aOverflowCont
-
>
GetParent
(
)
=
=
mParent
&
&
aOverflowCont
-
>
HasAnyStateBits
(
NS_FRAME_IS_OVERFLOW_CONTAINER
)
&
&
mOverflowContList
&
&
mOverflowContList
-
>
ContainsFrame
(
aOverflowCont
)
)
{
addToList
=
false
;
mPrevOverflowCont
=
aOverflowCont
-
>
GetPrevSibling
(
)
;
}
if
(
addToList
)
{
if
(
aOverflowCont
-
>
HasAnyStateBits
(
NS_FRAME_IS_OVERFLOW_CONTAINER
)
)
{
NS_ASSERTION
(
!
(
mOverflowContList
&
&
mOverflowContList
-
>
ContainsFrame
(
aOverflowCont
)
)
"
overflow
containers
out
of
order
"
)
;
aOverflowCont
-
>
GetParent
(
)
-
>
StealFrame
(
aOverflowCont
)
;
}
else
{
aOverflowCont
-
>
AddStateBits
(
NS_FRAME_IS_OVERFLOW_CONTAINER
)
;
}
if
(
!
mOverflowContList
)
{
mOverflowContList
=
new
(
presContext
-
>
PresShell
(
)
)
nsFrameList
(
)
;
mParent
-
>
SetProperty
(
nsContainerFrame
:
:
ExcessOverflowContainersProperty
(
)
mOverflowContList
)
;
SetUpListWalker
(
)
;
}
if
(
aOverflowCont
-
>
GetParent
(
)
!
=
mParent
)
{
nsContainerFrame
:
:
ReparentFrameView
(
aOverflowCont
aOverflowCont
-
>
GetParent
(
)
mParent
)
;
reparented
=
true
;
}
nsIFrame
*
pif
=
aOverflowCont
-
>
GetPrevInFlow
(
)
;
nsIFrame
*
nif
=
aOverflowCont
-
>
GetNextInFlow
(
)
;
if
(
(
pif
&
&
pif
-
>
GetParent
(
)
=
=
mParent
&
&
pif
!
=
mPrevOverflowCont
)
|
|
(
nif
&
&
nif
-
>
GetParent
(
)
=
=
mParent
&
&
mPrevOverflowCont
)
)
{
for
(
nsFrameList
:
:
Enumerator
e
(
*
mOverflowContList
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
)
{
nsIFrame
*
f
=
e
.
get
(
)
;
if
(
f
=
=
pif
)
{
mPrevOverflowCont
=
pif
;
break
;
}
if
(
f
=
=
nif
)
{
mPrevOverflowCont
=
f
-
>
GetPrevSibling
(
)
;
break
;
}
}
}
mOverflowContList
-
>
InsertFrame
(
mParent
mPrevOverflowCont
aOverflowCont
)
;
aReflowStatus
.
SetNextInFlowNeedsReflow
(
)
;
}
if
(
aReflowStatus
.
NextInFlowNeedsReflow
(
)
)
{
aOverflowCont
-
>
MarkSubtreeDirty
(
)
;
}
StepForward
(
)
;
NS_ASSERTION
(
mPrevOverflowCont
=
=
aOverflowCont
|
|
(
mSkipOverflowContainerChildren
&
&
mPrevOverflowCont
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
!
=
aOverflowCont
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
)
"
OverflowContTracker
in
unexpected
state
"
)
;
if
(
addToList
)
{
nsIFrame
*
f
=
aOverflowCont
-
>
GetNextInFlow
(
)
;
if
(
f
&
&
(
!
f
-
>
HasAnyStateBits
(
NS_FRAME_IS_OVERFLOW_CONTAINER
)
|
|
(
!
reparented
&
&
f
-
>
GetParent
(
)
=
=
mParent
)
|
|
(
reparented
&
&
f
-
>
GetParent
(
)
!
=
mParent
)
)
)
{
if
(
!
f
-
>
HasAnyStateBits
(
NS_FRAME_IS_OVERFLOW_CONTAINER
)
)
{
f
-
>
GetParent
(
)
-
>
StealFrame
(
f
)
;
}
Insert
(
f
aReflowStatus
)
;
}
}
return
rv
;
}
void
nsOverflowContinuationTracker
:
:
BeginFinish
(
nsIFrame
*
aChild
)
{
MOZ_ASSERT
(
aChild
"
null
ptr
"
)
;
MOZ_ASSERT
(
aChild
-
>
GetNextInFlow
(
)
"
supposed
to
call
Finish
*
before
*
deleting
next
-
in
-
flow
!
"
)
;
for
(
nsIFrame
*
f
=
aChild
;
f
;
f
=
f
-
>
GetNextInFlow
(
)
)
{
if
(
f
=
=
mPrevOverflowCont
)
{
mSentry
=
nullptr
;
mPrevOverflowCont
=
nullptr
;
break
;
}
if
(
f
=
=
mSentry
)
{
mSentry
=
nullptr
;
break
;
}
}
}
void
nsOverflowContinuationTracker
:
:
EndFinish
(
nsIFrame
*
aChild
)
{
if
(
!
mOverflowContList
)
{
return
;
}
nsFrameList
*
eoc
=
mParent
-
>
GetExcessOverflowContainers
(
)
;
if
(
eoc
!
=
mOverflowContList
)
{
nsFrameList
*
oc
=
mParent
-
>
GetOverflowContainers
(
)
;
if
(
oc
!
=
mOverflowContList
)
{
mPrevOverflowCont
=
nullptr
;
mSentry
=
nullptr
;
mParent
=
aChild
-
>
GetParent
(
)
;
mOverflowContList
=
nullptr
;
SetupOverflowContList
(
)
;
return
;
}
}
if
(
!
mSentry
)
{
if
(
!
mPrevOverflowCont
)
{
SetUpListWalker
(
)
;
}
else
{
mozilla
:
:
AutoRestore
<
nsIFrame
*
>
saved
(
mPrevOverflowCont
)
;
mPrevOverflowCont
=
mPrevOverflowCont
-
>
GetPrevSibling
(
)
;
StepForward
(
)
;
}
}
}
#
ifdef
DEBUG
void
nsContainerFrame
:
:
SanityCheckChildListsBeforeReflow
(
)
const
{
MOZ_ASSERT
(
IsFlexOrGridContainer
(
)
"
Only
Flex
/
Grid
containers
can
call
this
!
"
)
;
const
auto
didPushItemsBit
=
IsFlexContainerFrame
(
)
?
NS_STATE_FLEX_DID_PUSH_ITEMS
:
NS_STATE_GRID_DID_PUSH_ITEMS
;
ChildListIDs
absLists
=
{
kAbsoluteList
kFixedList
kOverflowContainersList
kExcessOverflowContainersList
}
;
ChildListIDs
itemLists
=
{
kPrincipalList
kOverflowList
}
;
for
(
const
nsIFrame
*
f
=
this
;
f
;
f
=
f
-
>
GetNextInFlow
(
)
)
{
MOZ_ASSERT
(
!
f
-
>
HasAnyStateBits
(
didPushItemsBit
)
"
At
start
of
reflow
we
should
'
ve
pulled
items
back
from
all
"
"
NIFs
and
cleared
the
state
bit
stored
in
didPushItemsBit
in
"
"
the
process
.
"
)
;
for
(
const
auto
&
[
list
listID
]
:
f
-
>
ChildLists
(
)
)
{
if
(
!
itemLists
.
contains
(
listID
)
)
{
MOZ_ASSERT
(
absLists
.
contains
(
listID
)
|
|
listID
=
=
kBackdropList
"
unexpected
non
-
empty
child
list
"
)
;
continue
;
}
for
(
const
auto
*
child
:
list
)
{
MOZ_ASSERT
(
f
=
=
this
|
|
child
-
>
GetPrevInFlow
(
)
"
all
pushed
items
must
be
pulled
up
before
reflow
"
)
;
}
}
}
const
auto
*
pif
=
static_cast
<
nsContainerFrame
*
>
(
GetPrevInFlow
(
)
)
;
if
(
pif
)
{
const
nsFrameList
*
oc
=
GetOverflowContainers
(
)
;
const
nsFrameList
*
eoc
=
GetExcessOverflowContainers
(
)
;
const
nsFrameList
*
pifEOC
=
pif
-
>
GetExcessOverflowContainers
(
)
;
for
(
const
nsIFrame
*
child
:
pif
-
>
GetChildList
(
kPrincipalList
)
)
{
const
nsIFrame
*
childNIF
=
child
-
>
GetNextInFlow
(
)
;
MOZ_ASSERT
(
!
childNIF
|
|
mFrames
.
ContainsFrame
(
childNIF
)
|
|
(
pifEOC
&
&
pifEOC
-
>
ContainsFrame
(
childNIF
)
)
|
|
(
oc
&
&
oc
-
>
ContainsFrame
(
childNIF
)
)
|
|
(
eoc
&
&
eoc
-
>
ContainsFrame
(
childNIF
)
)
)
;
}
}
}
void
nsContainerFrame
:
:
SetDidPushItemsBitIfNeeded
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
{
MOZ_ASSERT
(
IsFlexOrGridContainer
(
)
"
Only
Flex
/
Grid
containers
can
call
this
!
"
)
;
if
(
aListID
=
=
kPrincipalList
&
&
!
aOldFrame
-
>
GetPrevInFlow
(
)
)
{
nsContainerFrame
*
frameThatMayLie
=
this
;
do
{
frameThatMayLie
-
>
mDidPushItemsBitMayLie
=
true
;
frameThatMayLie
=
static_cast
<
nsContainerFrame
*
>
(
frameThatMayLie
-
>
GetPrevInFlow
(
)
)
;
}
while
(
frameThatMayLie
)
;
}
}
#
endif
#
ifdef
DEBUG_FRAME_DUMP
void
nsContainerFrame
:
:
List
(
FILE
*
out
const
char
*
aPrefix
ListFlags
aFlags
)
const
{
nsCString
str
;
ListGeneric
(
str
aPrefix
aFlags
)
;
ExtraContainerFrameInfo
(
str
)
;
fprintf_stderr
(
out
"
%
s
<
\
n
"
str
.
get
(
)
)
;
const
nsCString
pfx
=
nsCString
(
aPrefix
)
+
"
"
_ns
;
for
(
nsIFrame
*
kid
:
PrincipalChildList
(
)
)
{
kid
-
>
List
(
out
pfx
.
get
(
)
aFlags
)
;
}
const
ChildListIDs
skippedListIDs
=
{
kPrincipalList
}
;
ListChildLists
(
out
pfx
.
get
(
)
aFlags
skippedListIDs
)
;
fprintf_stderr
(
out
"
%
s
>
\
n
"
aPrefix
)
;
}
void
nsContainerFrame
:
:
ListWithMatchedRules
(
FILE
*
out
const
char
*
aPrefix
)
const
{
fprintf_stderr
(
out
"
%
s
%
s
\
n
"
aPrefix
ListTag
(
)
.
get
(
)
)
;
nsCString
rulePrefix
;
rulePrefix
+
=
aPrefix
;
rulePrefix
+
=
"
"
;
ListMatchedRules
(
out
rulePrefix
.
get
(
)
)
;
nsCString
childPrefix
;
childPrefix
+
=
aPrefix
;
childPrefix
+
=
"
"
;
for
(
const
auto
&
childList
:
ChildLists
(
)
)
{
for
(
const
nsIFrame
*
kid
:
childList
.
mList
)
{
kid
-
>
ListWithMatchedRules
(
out
childPrefix
.
get
(
)
)
;
}
}
}
void
nsContainerFrame
:
:
ListChildLists
(
FILE
*
aOut
const
char
*
aPrefix
ListFlags
aFlags
ChildListIDs
aSkippedListIDs
)
const
{
const
nsCString
nestedPfx
=
nsCString
(
aPrefix
)
+
"
"
_ns
;
for
(
const
auto
&
[
list
listID
]
:
ChildLists
(
)
)
{
if
(
aSkippedListIDs
.
contains
(
listID
)
)
{
continue
;
}
const
nsPrintfCString
str
(
"
%
s
%
s
%
p
<
\
n
"
aPrefix
ChildListName
(
listID
)
&
GetChildList
(
listID
)
)
;
fprintf_stderr
(
aOut
"
%
s
"
str
.
get
(
)
)
;
for
(
nsIFrame
*
kid
:
list
)
{
NS_ASSERTION
(
kid
-
>
GetParent
(
)
=
=
this
"
Bad
parent
frame
pointer
!
"
)
;
kid
-
>
List
(
aOut
nestedPfx
.
get
(
)
aFlags
)
;
}
fprintf_stderr
(
aOut
"
%
s
>
\
n
"
aPrefix
)
;
}
}
void
nsContainerFrame
:
:
ExtraContainerFrameInfo
(
nsACString
&
aTo
)
const
{
(
void
)
aTo
;
}
#
endif
