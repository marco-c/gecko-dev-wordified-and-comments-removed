#
include
"
nsContainerFrame
.
h
"
#
include
"
mozilla
/
ComputedStyle
.
h
"
#
include
"
mozilla
/
dom
/
HTMLSummaryElement
.
h
"
#
include
"
nsAbsoluteContainingBlock
.
h
"
#
include
"
nsAttrValue
.
h
"
#
include
"
nsAttrValueInlines
.
h
"
#
include
"
nsFlexContainerFrame
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsPoint
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsView
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsCSSRendering
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsIBaseWindow
.
h
"
#
include
"
nsBoxLayoutState
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
nsBlockFrame
.
h
"
#
include
"
nsBulletFrame
.
h
"
#
include
"
nsPlaceholderFrame
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
<
algorithm
>
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
layout
;
nsContainerFrame
:
:
~
nsContainerFrame
(
)
{
}
NS_QUERYFRAME_HEAD
(
nsContainerFrame
)
NS_QUERYFRAME_ENTRY
(
nsContainerFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsSplittableFrame
)
void
nsContainerFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
nsSplittableFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
if
(
aPrevInFlow
)
{
if
(
aPrevInFlow
-
>
GetStateBits
(
)
&
NS_FRAME_HAS_CHILD_WITH_VIEW
)
AddStateBits
(
NS_FRAME_HAS_CHILD_WITH_VIEW
)
;
}
}
void
nsContainerFrame
:
:
SetInitialChildList
(
ChildListID
aListID
nsFrameList
&
aChildList
)
{
#
ifdef
DEBUG
nsFrame
:
:
VerifyDirtyBitSet
(
aChildList
)
;
#
endif
if
(
aListID
=
=
kPrincipalList
)
{
MOZ_ASSERT
(
mFrames
.
IsEmpty
(
)
"
unexpected
second
call
to
SetInitialChildList
"
)
;
mFrames
.
SetFrames
(
aChildList
)
;
}
else
if
(
aListID
=
=
kBackdropList
)
{
MOZ_ASSERT
(
StyleDisplay
(
)
-
>
mTopLayer
!
=
NS_STYLE_TOP_LAYER_NONE
"
Only
top
layer
frames
should
have
backdrop
"
)
;
MOZ_ASSERT
(
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
"
Top
layer
frames
should
be
out
-
of
-
flow
"
)
;
MOZ_ASSERT
(
!
GetProperty
(
BackdropProperty
(
)
)
"
We
shouldn
'
t
have
setup
backdrop
frame
list
before
"
)
;
#
ifdef
DEBUG
{
nsIFrame
*
placeholder
=
aChildList
.
FirstChild
(
)
;
MOZ_ASSERT
(
aChildList
.
OnlyChild
(
)
"
Should
have
only
one
backdrop
"
)
;
MOZ_ASSERT
(
placeholder
-
>
IsPlaceholderFrame
(
)
"
The
frame
to
be
stored
should
be
a
placeholder
"
)
;
MOZ_ASSERT
(
static_cast
<
nsPlaceholderFrame
*
>
(
placeholder
)
-
>
GetOutOfFlowFrame
(
)
-
>
IsBackdropFrame
(
)
"
The
placeholder
should
points
to
a
backdrop
frame
"
)
;
}
#
endif
nsFrameList
*
list
=
new
(
PresShell
(
)
)
nsFrameList
(
aChildList
)
;
SetProperty
(
BackdropProperty
(
)
list
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
child
list
"
)
;
}
}
void
nsContainerFrame
:
:
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
{
MOZ_ASSERT
(
aListID
=
=
kPrincipalList
|
|
aListID
=
=
kNoReflowPrincipalList
"
unexpected
child
list
"
)
;
if
(
MOZ_UNLIKELY
(
aFrameList
.
IsEmpty
(
)
)
)
{
return
;
}
DrainSelfOverflowList
(
)
;
mFrames
.
AppendFrames
(
this
aFrameList
)
;
if
(
aListID
!
=
kNoReflowPrincipalList
)
{
PresShell
(
)
-
>
FrameNeedsReflow
(
this
nsIPresShell
:
:
eTreeChange
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
}
}
void
nsContainerFrame
:
:
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
aFrameList
)
{
MOZ_ASSERT
(
aListID
=
=
kPrincipalList
|
|
aListID
=
=
kNoReflowPrincipalList
"
unexpected
child
list
"
)
;
NS_ASSERTION
(
!
aPrevFrame
|
|
aPrevFrame
-
>
GetParent
(
)
=
=
this
"
inserting
after
sibling
frame
with
different
parent
"
)
;
if
(
MOZ_UNLIKELY
(
aFrameList
.
IsEmpty
(
)
)
)
{
return
;
}
DrainSelfOverflowList
(
)
;
mFrames
.
InsertFrames
(
this
aPrevFrame
aFrameList
)
;
if
(
aListID
!
=
kNoReflowPrincipalList
)
{
PresShell
(
)
-
>
FrameNeedsReflow
(
this
nsIPresShell
:
:
eTreeChange
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
}
}
void
nsContainerFrame
:
:
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
{
MOZ_ASSERT
(
aListID
=
=
kPrincipalList
|
|
aListID
=
=
kNoReflowPrincipalList
"
unexpected
child
list
"
)
;
AutoTArray
<
nsIFrame
*
10
>
continuations
;
{
nsIFrame
*
continuation
=
aOldFrame
;
while
(
continuation
)
{
continuations
.
AppendElement
(
continuation
)
;
continuation
=
continuation
-
>
GetNextContinuation
(
)
;
}
}
nsIPresShell
*
shell
=
PresShell
(
)
;
nsContainerFrame
*
lastParent
=
nullptr
;
const
bool
generateReflowCommand
=
(
kNoReflowPrincipalList
!
=
aListID
)
;
for
(
nsIFrame
*
continuation
:
Reversed
(
continuations
)
)
{
nsContainerFrame
*
parent
=
continuation
-
>
GetParent
(
)
;
parent
-
>
StealFrame
(
continuation
)
;
continuation
-
>
Destroy
(
)
;
if
(
generateReflowCommand
&
&
parent
!
=
lastParent
)
{
shell
-
>
FrameNeedsReflow
(
parent
nsIPresShell
:
:
eTreeChange
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
lastParent
=
parent
;
}
}
}
void
nsContainerFrame
:
:
DestroyAbsoluteFrames
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
{
if
(
IsAbsoluteContainer
(
)
)
{
GetAbsoluteContainingBlock
(
)
-
>
DestroyFrames
(
this
aDestructRoot
aPostDestroyData
)
;
MarkAsNotAbsoluteContainingBlock
(
)
;
}
}
void
nsContainerFrame
:
:
SafelyDestroyFrameListProp
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
nsIPresShell
*
aPresShell
FrameListPropertyDescriptor
aProp
)
{
while
(
nsFrameList
*
frameList
=
GetProperty
(
aProp
)
)
{
nsIFrame
*
frame
=
frameList
-
>
RemoveFirstChild
(
)
;
if
(
MOZ_LIKELY
(
frame
)
)
{
frame
-
>
DestroyFrom
(
aDestructRoot
aPostDestroyData
)
;
}
else
{
RemoveProperty
(
aProp
)
;
frameList
-
>
Delete
(
aPresShell
)
;
return
;
}
}
}
void
nsContainerFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
{
if
(
HasView
(
)
)
{
GetView
(
)
-
>
SetFrame
(
nullptr
)
;
}
DestroyAbsoluteFrames
(
aDestructRoot
aPostDestroyData
)
;
mFrames
.
DestroyFramesFrom
(
aDestructRoot
aPostDestroyData
)
;
if
(
HasAnyStateBits
(
NS_FRAME_PART_OF_IBSPLIT
)
)
{
nsIFrame
*
prevSib
=
GetProperty
(
nsIFrame
:
:
IBSplitPrevSibling
(
)
)
;
if
(
prevSib
)
{
NS_WARNING_ASSERTION
(
this
=
=
prevSib
-
>
GetProperty
(
nsIFrame
:
:
IBSplitSibling
(
)
)
"
IB
sibling
chain
is
inconsistent
"
)
;
prevSib
-
>
DeleteProperty
(
nsIFrame
:
:
IBSplitSibling
(
)
)
;
}
nsIFrame
*
nextSib
=
GetProperty
(
nsIFrame
:
:
IBSplitSibling
(
)
)
;
if
(
nextSib
)
{
NS_WARNING_ASSERTION
(
this
=
=
nextSib
-
>
GetProperty
(
nsIFrame
:
:
IBSplitPrevSibling
(
)
)
"
IB
sibling
chain
is
inconsistent
"
)
;
nextSib
-
>
DeleteProperty
(
nsIFrame
:
:
IBSplitPrevSibling
(
)
)
;
}
#
ifdef
DEBUG
RemoveStateBits
(
NS_FRAME_PART_OF_IBSPLIT
)
;
#
endif
}
if
(
MOZ_UNLIKELY
(
!
mProperties
.
IsEmpty
(
)
)
)
{
using
T
=
mozilla
:
:
FrameProperties
:
:
UntypedDescriptor
;
bool
hasO
=
false
hasOC
=
false
hasEOC
=
false
hasBackdrop
=
false
;
mProperties
.
ForEach
(
[
&
]
(
const
T
&
aProp
void
*
)
{
if
(
aProp
=
=
OverflowProperty
(
)
)
{
hasO
=
true
;
}
else
if
(
aProp
=
=
OverflowContainersProperty
(
)
)
{
hasOC
=
true
;
}
else
if
(
aProp
=
=
ExcessOverflowContainersProperty
(
)
)
{
hasEOC
=
true
;
}
else
if
(
aProp
=
=
BackdropProperty
(
)
)
{
hasBackdrop
=
true
;
}
return
true
;
}
)
;
nsPresContext
*
pc
=
PresContext
(
)
;
nsIPresShell
*
shell
=
pc
-
>
PresShell
(
)
;
if
(
hasO
)
{
SafelyDestroyFrameListProp
(
aDestructRoot
aPostDestroyData
shell
OverflowProperty
(
)
)
;
}
MOZ_ASSERT
(
IsFrameOfType
(
eCanContainOverflowContainers
)
|
|
!
(
hasOC
|
|
hasEOC
)
"
this
type
of
frame
shouldn
'
t
have
overflow
containers
"
)
;
if
(
hasOC
)
{
SafelyDestroyFrameListProp
(
aDestructRoot
aPostDestroyData
shell
OverflowContainersProperty
(
)
)
;
}
if
(
hasEOC
)
{
SafelyDestroyFrameListProp
(
aDestructRoot
aPostDestroyData
shell
ExcessOverflowContainersProperty
(
)
)
;
}
MOZ_ASSERT
(
!
GetProperty
(
BackdropProperty
(
)
)
|
|
StyleDisplay
(
)
-
>
mTopLayer
!
=
NS_STYLE_TOP_LAYER_NONE
"
only
top
layer
frame
may
have
backdrop
"
)
;
if
(
hasBackdrop
)
{
SafelyDestroyFrameListProp
(
aDestructRoot
aPostDestroyData
shell
BackdropProperty
(
)
)
;
}
}
nsSplittableFrame
:
:
DestroyFrom
(
aDestructRoot
aPostDestroyData
)
;
}
const
nsFrameList
&
nsContainerFrame
:
:
GetChildList
(
ChildListID
aListID
)
const
{
switch
(
aListID
)
{
case
kPrincipalList
:
return
mFrames
;
case
kOverflowList
:
{
nsFrameList
*
list
=
GetOverflowFrames
(
)
;
return
list
?
*
list
:
nsFrameList
:
:
EmptyList
(
)
;
}
case
kOverflowContainersList
:
{
nsFrameList
*
list
=
GetPropTableFrames
(
OverflowContainersProperty
(
)
)
;
return
list
?
*
list
:
nsFrameList
:
:
EmptyList
(
)
;
}
case
kExcessOverflowContainersList
:
{
nsFrameList
*
list
=
GetPropTableFrames
(
ExcessOverflowContainersProperty
(
)
)
;
return
list
?
*
list
:
nsFrameList
:
:
EmptyList
(
)
;
}
case
kBackdropList
:
{
nsFrameList
*
list
=
GetPropTableFrames
(
BackdropProperty
(
)
)
;
return
list
?
*
list
:
nsFrameList
:
:
EmptyList
(
)
;
}
default
:
return
nsSplittableFrame
:
:
GetChildList
(
aListID
)
;
}
}
void
nsContainerFrame
:
:
GetChildLists
(
nsTArray
<
ChildList
>
*
aLists
)
const
{
mFrames
.
AppendIfNonempty
(
aLists
kPrincipalList
)
;
using
T
=
mozilla
:
:
FrameProperties
:
:
UntypedDescriptor
;
mProperties
.
ForEach
(
[
this
aLists
]
(
const
T
&
aProp
void
*
aValue
)
{
typedef
const
nsFrameList
*
L
;
if
(
aProp
=
=
OverflowProperty
(
)
)
{
L
(
aValue
)
-
>
AppendIfNonempty
(
aLists
kOverflowList
)
;
}
else
if
(
aProp
=
=
OverflowContainersProperty
(
)
)
{
MOZ_ASSERT
(
IsFrameOfType
(
nsIFrame
:
:
eCanContainOverflowContainers
)
"
found
unexpected
OverflowContainersProperty
"
)
;
Unused
<
<
this
;
L
(
aValue
)
-
>
AppendIfNonempty
(
aLists
kOverflowContainersList
)
;
}
else
if
(
aProp
=
=
ExcessOverflowContainersProperty
(
)
)
{
MOZ_ASSERT
(
IsFrameOfType
(
nsIFrame
:
:
eCanContainOverflowContainers
)
"
found
unexpected
ExcessOverflowContainersProperty
"
)
;
Unused
<
<
this
;
L
(
aValue
)
-
>
AppendIfNonempty
(
aLists
kExcessOverflowContainersList
)
;
}
else
if
(
aProp
=
=
BackdropProperty
(
)
)
{
L
(
aValue
)
-
>
AppendIfNonempty
(
aLists
kBackdropList
)
;
}
return
true
;
}
)
;
nsSplittableFrame
:
:
GetChildLists
(
aLists
)
;
}
void
nsContainerFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
DisplayBorderBackgroundOutline
(
aBuilder
aLists
)
;
BuildDisplayListForNonBlockChildren
(
aBuilder
aLists
)
;
}
void
nsContainerFrame
:
:
BuildDisplayListForNonBlockChildren
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
uint32_t
aFlags
)
{
nsIFrame
*
kid
=
mFrames
.
FirstChild
(
)
;
nsDisplayListSet
set
(
aLists
aLists
.
Content
(
)
)
;
while
(
kid
)
{
BuildDisplayListForChild
(
aBuilder
kid
set
aFlags
)
;
kid
=
kid
-
>
GetNextSibling
(
)
;
}
}
void
nsContainerFrame
:
:
ChildIsDirty
(
nsIFrame
*
aChild
)
{
NS_ASSERTION
(
NS_SUBTREE_DIRTY
(
aChild
)
"
child
isn
'
t
actually
dirty
"
)
;
AddStateBits
(
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
}
nsIFrame
:
:
FrameSearchResult
nsContainerFrame
:
:
PeekOffsetNoAmount
(
bool
aForward
int32_t
*
aOffset
)
{
NS_ASSERTION
(
aOffset
&
&
*
aOffset
<
=
1
"
aOffset
out
of
range
"
)
;
return
CONTINUE_EMPTY
;
}
nsIFrame
:
:
FrameSearchResult
nsContainerFrame
:
:
PeekOffsetCharacter
(
bool
aForward
int32_t
*
aOffset
PeekOffsetCharacterOptions
aOptions
)
{
NS_ASSERTION
(
aOffset
&
&
*
aOffset
<
=
1
"
aOffset
out
of
range
"
)
;
return
CONTINUE_EMPTY
;
}
void
nsContainerFrame
:
:
PositionFrameView
(
nsIFrame
*
aKidFrame
)
{
nsIFrame
*
parentFrame
=
aKidFrame
-
>
GetParent
(
)
;
if
(
!
aKidFrame
-
>
HasView
(
)
|
|
!
parentFrame
)
return
;
nsView
*
view
=
aKidFrame
-
>
GetView
(
)
;
nsViewManager
*
vm
=
view
-
>
GetViewManager
(
)
;
nsPoint
pt
;
nsView
*
ancestorView
=
parentFrame
-
>
GetClosestView
(
&
pt
)
;
if
(
ancestorView
!
=
view
-
>
GetParent
(
)
)
{
NS_ASSERTION
(
ancestorView
=
=
view
-
>
GetParent
(
)
-
>
GetParent
(
)
"
Allowed
only
one
anonymous
view
between
frames
"
)
;
return
;
}
pt
+
=
aKidFrame
-
>
GetPosition
(
)
;
vm
-
>
MoveViewTo
(
view
pt
.
x
pt
.
y
)
;
}
nsresult
nsContainerFrame
:
:
ReparentFrameView
(
nsIFrame
*
aChildFrame
nsIFrame
*
aOldParentFrame
nsIFrame
*
aNewParentFrame
)
{
MOZ_ASSERT
(
aChildFrame
"
null
child
frame
pointer
"
)
;
MOZ_ASSERT
(
aOldParentFrame
"
null
old
parent
frame
pointer
"
)
;
MOZ_ASSERT
(
aNewParentFrame
"
null
new
parent
frame
pointer
"
)
;
MOZ_ASSERT
(
aOldParentFrame
!
=
aNewParentFrame
"
same
old
and
new
parent
frame
"
)
;
while
(
!
aOldParentFrame
-
>
HasView
(
)
&
&
!
aNewParentFrame
-
>
HasView
(
)
)
{
aOldParentFrame
=
aOldParentFrame
-
>
GetParent
(
)
;
aNewParentFrame
=
aNewParentFrame
-
>
GetParent
(
)
;
NS_ASSERTION
(
aOldParentFrame
&
&
aNewParentFrame
"
didn
'
t
find
view
"
)
;
if
(
aOldParentFrame
=
=
aNewParentFrame
)
{
break
;
}
}
if
(
aOldParentFrame
=
=
aNewParentFrame
)
{
return
NS_OK
;
}
nsView
*
oldParentView
=
aOldParentFrame
-
>
GetClosestView
(
)
;
nsView
*
newParentView
=
aNewParentFrame
-
>
GetClosestView
(
)
;
if
(
oldParentView
!
=
newParentView
)
{
aChildFrame
-
>
ReparentFrameViewTo
(
oldParentView
-
>
GetViewManager
(
)
newParentView
oldParentView
)
;
}
return
NS_OK
;
}
nsresult
nsContainerFrame
:
:
ReparentFrameViewList
(
const
nsFrameList
&
aChildFrameList
nsIFrame
*
aOldParentFrame
nsIFrame
*
aNewParentFrame
)
{
MOZ_ASSERT
(
aChildFrameList
.
NotEmpty
(
)
"
empty
child
frame
list
"
)
;
MOZ_ASSERT
(
aOldParentFrame
"
null
old
parent
frame
pointer
"
)
;
MOZ_ASSERT
(
aNewParentFrame
"
null
new
parent
frame
pointer
"
)
;
MOZ_ASSERT
(
aOldParentFrame
!
=
aNewParentFrame
"
same
old
and
new
parent
frame
"
)
;
while
(
!
aOldParentFrame
-
>
HasView
(
)
&
&
!
aNewParentFrame
-
>
HasView
(
)
)
{
aOldParentFrame
=
aOldParentFrame
-
>
GetParent
(
)
;
aNewParentFrame
=
aNewParentFrame
-
>
GetParent
(
)
;
NS_ASSERTION
(
aOldParentFrame
&
&
aNewParentFrame
"
didn
'
t
find
view
"
)
;
if
(
aOldParentFrame
=
=
aNewParentFrame
)
{
break
;
}
}
if
(
aOldParentFrame
=
=
aNewParentFrame
)
{
return
NS_OK
;
}
nsView
*
oldParentView
=
aOldParentFrame
-
>
GetClosestView
(
)
;
nsView
*
newParentView
=
aNewParentFrame
-
>
GetClosestView
(
)
;
if
(
oldParentView
!
=
newParentView
)
{
nsViewManager
*
viewManager
=
oldParentView
-
>
GetViewManager
(
)
;
for
(
nsFrameList
:
:
Enumerator
e
(
aChildFrameList
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
)
{
e
.
get
(
)
-
>
ReparentFrameViewTo
(
viewManager
newParentView
oldParentView
)
;
}
}
return
NS_OK
;
}
static
nsIWidget
*
GetPresContextContainerWidget
(
nsPresContext
*
aPresContext
)
{
nsCOMPtr
<
nsISupports
>
container
=
aPresContext
-
>
Document
(
)
-
>
GetContainer
(
)
;
nsCOMPtr
<
nsIBaseWindow
>
baseWindow
=
do_QueryInterface
(
container
)
;
if
(
!
baseWindow
)
return
nullptr
;
nsCOMPtr
<
nsIWidget
>
mainWidget
;
baseWindow
-
>
GetMainWidget
(
getter_AddRefs
(
mainWidget
)
)
;
return
mainWidget
;
}
static
bool
IsTopLevelWidget
(
nsIWidget
*
aWidget
)
{
nsWindowType
windowType
=
aWidget
-
>
WindowType
(
)
;
return
windowType
=
=
eWindowType_toplevel
|
|
windowType
=
=
eWindowType_dialog
|
|
windowType
=
=
eWindowType_popup
|
|
windowType
=
=
eWindowType_sheet
;
}
void
nsContainerFrame
:
:
SyncWindowProperties
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
nsView
*
aView
gfxContext
*
aRC
uint32_t
aFlags
)
{
#
ifdef
MOZ_XUL
if
(
!
aView
|
|
!
nsCSSRendering
:
:
IsCanvasFrame
(
aFrame
)
|
|
!
aView
-
>
HasWidget
(
)
)
return
;
nsCOMPtr
<
nsIWidget
>
windowWidget
=
GetPresContextContainerWidget
(
aPresContext
)
;
if
(
!
windowWidget
|
|
!
IsTopLevelWidget
(
windowWidget
)
)
return
;
nsViewManager
*
vm
=
aView
-
>
GetViewManager
(
)
;
nsView
*
rootView
=
vm
-
>
GetRootView
(
)
;
if
(
aView
!
=
rootView
)
return
;
Element
*
rootElement
=
aPresContext
-
>
Document
(
)
-
>
GetRootElement
(
)
;
if
(
!
rootElement
|
|
!
rootElement
-
>
IsXULElement
(
)
)
{
return
;
}
nsIFrame
*
rootFrame
=
aPresContext
-
>
PresShell
(
)
-
>
FrameConstructor
(
)
-
>
GetRootElementStyleFrame
(
)
;
if
(
!
rootFrame
)
return
;
if
(
aFlags
&
SET_ASYNC
)
{
aView
-
>
SetNeedsWindowPropertiesSync
(
)
;
return
;
}
RefPtr
<
nsPresContext
>
kungFuDeathGrip
(
aPresContext
)
;
AutoWeakFrame
weak
(
rootFrame
)
;
nsTransparencyMode
mode
=
nsLayoutUtils
:
:
GetFrameTransparency
(
aFrame
rootFrame
)
;
int32_t
shadow
=
rootFrame
-
>
StyleUIReset
(
)
-
>
mWindowShadow
;
nsCOMPtr
<
nsIWidget
>
viewWidget
=
aView
-
>
GetWidget
(
)
;
viewWidget
-
>
SetTransparencyMode
(
mode
)
;
windowWidget
-
>
SetWindowShadowStyle
(
shadow
)
;
if
(
!
aRC
)
return
;
if
(
!
weak
.
IsAlive
(
)
)
{
return
;
}
nsBoxLayoutState
aState
(
aPresContext
aRC
)
;
nsSize
minSize
=
rootFrame
-
>
GetXULMinSize
(
aState
)
;
nsSize
maxSize
=
rootFrame
-
>
GetXULMaxSize
(
aState
)
;
SetSizeConstraints
(
aPresContext
windowWidget
minSize
maxSize
)
;
#
endif
}
void
nsContainerFrame
:
:
SetSizeConstraints
(
nsPresContext
*
aPresContext
nsIWidget
*
aWidget
const
nsSize
&
aMinSize
const
nsSize
&
aMaxSize
)
{
LayoutDeviceIntSize
devMinSize
(
aPresContext
-
>
AppUnitsToDevPixels
(
aMinSize
.
width
)
aPresContext
-
>
AppUnitsToDevPixels
(
aMinSize
.
height
)
)
;
LayoutDeviceIntSize
devMaxSize
(
aMaxSize
.
width
=
=
NS_INTRINSICSIZE
?
NS_MAXSIZE
:
aPresContext
-
>
AppUnitsToDevPixels
(
aMaxSize
.
width
)
aMaxSize
.
height
=
=
NS_INTRINSICSIZE
?
NS_MAXSIZE
:
aPresContext
-
>
AppUnitsToDevPixels
(
aMaxSize
.
height
)
)
;
if
(
devMinSize
.
width
>
devMaxSize
.
width
)
devMaxSize
.
width
=
devMinSize
.
width
;
if
(
devMinSize
.
height
>
devMaxSize
.
height
)
devMaxSize
.
height
=
devMinSize
.
height
;
widget
:
:
SizeConstraints
constraints
(
devMinSize
devMaxSize
)
;
LayoutDeviceIntSize
windowSize
=
aWidget
-
>
ClientToWindowSize
(
LayoutDeviceIntSize
(
200
200
)
)
;
if
(
constraints
.
mMinSize
.
width
)
constraints
.
mMinSize
.
width
+
=
windowSize
.
width
-
200
;
if
(
constraints
.
mMinSize
.
height
)
constraints
.
mMinSize
.
height
+
=
windowSize
.
height
-
200
;
if
(
constraints
.
mMaxSize
.
width
!
=
NS_MAXSIZE
)
constraints
.
mMaxSize
.
width
+
=
windowSize
.
width
-
200
;
if
(
constraints
.
mMaxSize
.
height
!
=
NS_MAXSIZE
)
constraints
.
mMaxSize
.
height
+
=
windowSize
.
height
-
200
;
aWidget
-
>
SetSizeConstraints
(
constraints
)
;
}
void
nsContainerFrame
:
:
SyncFrameViewAfterReflow
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
nsView
*
aView
const
nsRect
&
aVisualOverflowArea
uint32_t
aFlags
)
{
if
(
!
aView
)
{
return
;
}
if
(
0
=
=
(
aFlags
&
NS_FRAME_NO_MOVE_VIEW
)
)
{
PositionFrameView
(
aFrame
)
;
}
if
(
0
=
=
(
aFlags
&
NS_FRAME_NO_SIZE_VIEW
)
)
{
nsViewManager
*
vm
=
aView
-
>
GetViewManager
(
)
;
vm
-
>
ResizeView
(
aView
aVisualOverflowArea
true
)
;
}
}
static
nscoord
GetCoord
(
const
nsStyleCoord
&
aCoord
nscoord
aIfNotCoord
)
{
if
(
aCoord
.
ConvertsToLength
(
)
)
{
return
aCoord
.
ComputeCoordPercentCalc
(
0
)
;
}
return
aIfNotCoord
;
}
void
nsContainerFrame
:
:
DoInlineIntrinsicISize
(
gfxContext
*
aRenderingContext
InlineIntrinsicISizeData
*
aData
nsLayoutUtils
:
:
IntrinsicISizeType
aType
)
{
if
(
GetPrevInFlow
(
)
)
return
;
MOZ_ASSERT
(
aType
=
=
nsLayoutUtils
:
:
MIN_ISIZE
|
|
aType
=
=
nsLayoutUtils
:
:
PREF_ISIZE
"
bad
type
"
)
;
WritingMode
wm
=
GetWritingMode
(
)
;
mozilla
:
:
Side
startSide
=
wm
.
PhysicalSideForInlineAxis
(
eLogicalEdgeStart
)
;
mozilla
:
:
Side
endSide
=
wm
.
PhysicalSideForInlineAxis
(
eLogicalEdgeEnd
)
;
const
nsStylePadding
*
stylePadding
=
StylePadding
(
)
;
const
nsStyleBorder
*
styleBorder
=
StyleBorder
(
)
;
const
nsStyleMargin
*
styleMargin
=
StyleMargin
(
)
;
nscoord
clonePBM
=
0
;
const
bool
sliceBreak
=
styleBorder
-
>
mBoxDecorationBreak
=
=
StyleBoxDecorationBreak
:
:
Slice
;
if
(
!
GetPrevContinuation
(
)
)
{
nscoord
startPBM
=
std
:
:
max
(
GetCoord
(
stylePadding
-
>
mPadding
.
Get
(
startSide
)
0
)
0
)
+
styleBorder
-
>
GetComputedBorderWidth
(
startSide
)
+
GetCoord
(
styleMargin
-
>
mMargin
.
Get
(
startSide
)
0
)
;
if
(
MOZ_LIKELY
(
sliceBreak
)
)
{
aData
-
>
mCurrentLine
+
=
startPBM
;
}
else
{
clonePBM
=
startPBM
;
}
}
nscoord
endPBM
=
std
:
:
max
(
GetCoord
(
stylePadding
-
>
mPadding
.
Get
(
endSide
)
0
)
0
)
+
styleBorder
-
>
GetComputedBorderWidth
(
endSide
)
+
GetCoord
(
styleMargin
-
>
mMargin
.
Get
(
endSide
)
0
)
;
if
(
MOZ_UNLIKELY
(
!
sliceBreak
)
)
{
clonePBM
+
=
endPBM
;
}
const
nsLineList_iterator
*
savedLine
=
aData
-
>
mLine
;
nsIFrame
*
const
savedLineContainer
=
aData
-
>
LineContainer
(
)
;
nsContainerFrame
*
lastInFlow
;
for
(
nsContainerFrame
*
nif
=
this
;
nif
;
nif
=
static_cast
<
nsContainerFrame
*
>
(
nif
-
>
GetNextInFlow
(
)
)
)
{
if
(
aData
-
>
mCurrentLine
=
=
0
)
{
aData
-
>
mCurrentLine
=
clonePBM
;
}
for
(
nsIFrame
*
kid
:
nif
-
>
mFrames
)
{
if
(
aType
=
=
nsLayoutUtils
:
:
MIN_ISIZE
)
kid
-
>
AddInlineMinISize
(
aRenderingContext
static_cast
<
InlineMinISizeData
*
>
(
aData
)
)
;
else
kid
-
>
AddInlinePrefISize
(
aRenderingContext
static_cast
<
InlinePrefISizeData
*
>
(
aData
)
)
;
}
aData
-
>
mLine
=
nullptr
;
aData
-
>
SetLineContainer
(
nullptr
)
;
lastInFlow
=
nif
;
}
aData
-
>
mLine
=
savedLine
;
aData
-
>
SetLineContainer
(
savedLineContainer
)
;
if
(
MOZ_LIKELY
(
!
lastInFlow
-
>
GetNextContinuation
(
)
&
&
sliceBreak
)
)
{
aData
-
>
mCurrentLine
+
=
endPBM
;
}
}
LogicalSize
nsContainerFrame
:
:
ComputeAutoSize
(
gfxContext
*
aRenderingContext
WritingMode
aWM
const
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
LogicalSize
&
aMargin
const
LogicalSize
&
aBorder
const
LogicalSize
&
aPadding
ComputeSizeFlags
aFlags
)
{
LogicalSize
result
(
aWM
0xdeadbeef
NS_UNCONSTRAINEDSIZE
)
;
nscoord
availBased
=
aAvailableISize
-
aMargin
.
ISize
(
aWM
)
-
aBorder
.
ISize
(
aWM
)
-
aPadding
.
ISize
(
aWM
)
;
if
(
(
aFlags
&
ComputeSizeFlags
:
:
eShrinkWrap
)
|
|
IsFrameOfType
(
eReplaced
)
)
{
const
nsStylePosition
*
pos
=
StylePosition
(
)
;
if
(
pos
-
>
ISize
(
aWM
)
.
GetUnit
(
)
=
=
eStyleUnit_Auto
|
|
(
pos
-
>
mFlexBasis
.
GetUnit
(
)
=
=
eStyleUnit_Enumerated
&
&
pos
-
>
mFlexBasis
.
GetIntValue
(
)
=
=
NS_STYLE_FLEX_BASIS_CONTENT
&
&
IsFlexItem
(
)
&
&
nsFlexContainerFrame
:
:
IsItemInlineAxisMainAxis
(
this
)
)
)
{
result
.
ISize
(
aWM
)
=
ShrinkWidthToFit
(
aRenderingContext
availBased
aFlags
)
;
}
}
else
{
result
.
ISize
(
aWM
)
=
availBased
;
}
if
(
IsTableCaption
(
)
)
{
AutoMaybeDisableFontInflation
an
(
this
)
;
WritingMode
tableWM
=
GetParent
(
)
-
>
GetWritingMode
(
)
;
uint8_t
captionSide
=
StyleTableBorder
(
)
-
>
mCaptionSide
;
if
(
aWM
.
IsOrthogonalTo
(
tableWM
)
)
{
if
(
captionSide
=
=
NS_STYLE_CAPTION_SIDE_TOP
|
|
captionSide
=
=
NS_STYLE_CAPTION_SIDE_TOP_OUTSIDE
|
|
captionSide
=
=
NS_STYLE_CAPTION_SIDE_BOTTOM
|
|
captionSide
=
=
NS_STYLE_CAPTION_SIDE_BOTTOM_OUTSIDE
)
{
result
.
ISize
(
aWM
)
=
GetMinISize
(
aRenderingContext
)
;
}
else
{
nscoord
pref
=
GetPrefISize
(
aRenderingContext
)
;
if
(
pref
>
aCBSize
.
ISize
(
aWM
)
)
{
pref
=
aCBSize
.
ISize
(
aWM
)
;
}
if
(
pref
<
result
.
ISize
(
aWM
)
)
{
result
.
ISize
(
aWM
)
=
pref
;
}
}
}
else
{
if
(
captionSide
=
=
NS_STYLE_CAPTION_SIDE_LEFT
|
|
captionSide
=
=
NS_STYLE_CAPTION_SIDE_RIGHT
)
{
result
.
ISize
(
aWM
)
=
GetMinISize
(
aRenderingContext
)
;
}
else
if
(
captionSide
=
=
NS_STYLE_CAPTION_SIDE_TOP
|
|
captionSide
=
=
NS_STYLE_CAPTION_SIDE_BOTTOM
)
{
nscoord
min
=
GetMinISize
(
aRenderingContext
)
;
if
(
min
>
aCBSize
.
ISize
(
aWM
)
)
{
min
=
aCBSize
.
ISize
(
aWM
)
;
}
if
(
min
>
result
.
ISize
(
aWM
)
)
{
result
.
ISize
(
aWM
)
=
min
;
}
}
}
}
return
result
;
}
void
nsContainerFrame
:
:
ReflowChild
(
nsIFrame
*
aKidFrame
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
const
WritingMode
&
aWM
const
LogicalPoint
&
aPos
const
nsSize
&
aContainerSize
uint32_t
aFlags
nsReflowStatus
&
aStatus
nsOverflowContinuationTracker
*
aTracker
)
{
MOZ_ASSERT
(
aReflowInput
.
mFrame
=
=
aKidFrame
"
bad
reflow
state
"
)
;
if
(
aWM
.
IsVerticalRL
(
)
|
|
(
!
aWM
.
IsVertical
(
)
&
&
!
aWM
.
IsBidiLTR
(
)
)
)
{
NS_ASSERTION
(
aContainerSize
.
width
!
=
NS_UNCONSTRAINEDSIZE
"
ReflowChild
with
unconstrained
container
width
!
"
)
;
}
MOZ_ASSERT
(
aDesiredSize
.
VisualOverflow
(
)
=
=
nsRect
(
0
0
0
0
)
&
&
aDesiredSize
.
ScrollableOverflow
(
)
=
=
nsRect
(
0
0
0
0
)
"
please
reset
the
overflow
areas
before
calling
ReflowChild
"
)
;
if
(
NS_FRAME_NO_MOVE_FRAME
!
=
(
aFlags
&
NS_FRAME_NO_MOVE_FRAME
)
)
{
aKidFrame
-
>
SetPosition
(
aWM
aPos
aContainerSize
)
;
}
if
(
0
=
=
(
aFlags
&
NS_FRAME_NO_MOVE_VIEW
)
)
{
PositionFrameView
(
aKidFrame
)
;
PositionChildViews
(
aKidFrame
)
;
}
aKidFrame
-
>
Reflow
(
aPresContext
aDesiredSize
aReflowInput
aStatus
)
;
if
(
!
aStatus
.
IsInlineBreakBefore
(
)
&
&
aStatus
.
IsFullyComplete
(
)
&
&
!
(
aFlags
&
NS_FRAME_NO_DELETE_NEXT_IN_FLOW_CHILD
)
)
{
nsIFrame
*
kidNextInFlow
=
aKidFrame
-
>
GetNextInFlow
(
)
;
if
(
kidNextInFlow
)
{
nsOverflowContinuationTracker
:
:
AutoFinish
fini
(
aTracker
aKidFrame
)
;
kidNextInFlow
-
>
GetParent
(
)
-
>
DeleteNextInFlowChild
(
kidNextInFlow
true
)
;
}
}
}
void
nsContainerFrame
:
:
ReflowChild
(
nsIFrame
*
aKidFrame
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nscoord
aX
nscoord
aY
uint32_t
aFlags
nsReflowStatus
&
aStatus
nsOverflowContinuationTracker
*
aTracker
)
{
MOZ_ASSERT
(
aReflowInput
.
mFrame
=
=
aKidFrame
"
bad
reflow
state
"
)
;
if
(
NS_FRAME_NO_MOVE_FRAME
!
=
(
aFlags
&
NS_FRAME_NO_MOVE_FRAME
)
)
{
aKidFrame
-
>
SetPosition
(
nsPoint
(
aX
aY
)
)
;
}
if
(
0
=
=
(
aFlags
&
NS_FRAME_NO_MOVE_VIEW
)
)
{
PositionFrameView
(
aKidFrame
)
;
PositionChildViews
(
aKidFrame
)
;
}
aKidFrame
-
>
Reflow
(
aPresContext
aDesiredSize
aReflowInput
aStatus
)
;
if
(
aStatus
.
IsFullyComplete
(
)
&
&
!
(
aFlags
&
NS_FRAME_NO_DELETE_NEXT_IN_FLOW_CHILD
)
)
{
nsIFrame
*
kidNextInFlow
=
aKidFrame
-
>
GetNextInFlow
(
)
;
if
(
kidNextInFlow
)
{
nsOverflowContinuationTracker
:
:
AutoFinish
fini
(
aTracker
aKidFrame
)
;
kidNextInFlow
-
>
GetParent
(
)
-
>
DeleteNextInFlowChild
(
kidNextInFlow
true
)
;
}
}
}
void
nsContainerFrame
:
:
PositionChildViews
(
nsIFrame
*
aFrame
)
{
if
(
!
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_HAS_CHILD_WITH_VIEW
)
)
{
return
;
}
ChildListIterator
lists
(
aFrame
)
;
for
(
;
!
lists
.
IsDone
(
)
;
lists
.
Next
(
)
)
{
if
(
lists
.
CurrentID
(
)
=
=
kPopupList
)
{
continue
;
}
nsFrameList
:
:
Enumerator
childFrames
(
lists
.
CurrentList
(
)
)
;
for
(
;
!
childFrames
.
AtEnd
(
)
;
childFrames
.
Next
(
)
)
{
nsIFrame
*
childFrame
=
childFrames
.
get
(
)
;
if
(
childFrame
-
>
HasView
(
)
)
{
PositionFrameView
(
childFrame
)
;
}
else
{
PositionChildViews
(
childFrame
)
;
}
}
}
}
#
if
defined
(
_MSC_VER
)
&
&
!
defined
(
__clang__
)
&
&
defined
(
_M_AMD64
)
#
pragma
optimize
(
"
g
"
off
)
#
endif
void
nsContainerFrame
:
:
FinishReflowChild
(
nsIFrame
*
aKidFrame
nsPresContext
*
aPresContext
const
ReflowOutput
&
aDesiredSize
const
ReflowInput
*
aReflowInput
const
WritingMode
&
aWM
const
LogicalPoint
&
aPos
const
nsSize
&
aContainerSize
uint32_t
aFlags
)
{
if
(
aWM
.
IsVerticalRL
(
)
|
|
(
!
aWM
.
IsVertical
(
)
&
&
!
aWM
.
IsBidiLTR
(
)
)
)
{
NS_ASSERTION
(
aContainerSize
.
width
!
=
NS_UNCONSTRAINEDSIZE
"
FinishReflowChild
with
unconstrained
container
width
!
"
)
;
}
nsPoint
curOrigin
=
aKidFrame
-
>
GetPosition
(
)
;
WritingMode
outerWM
=
aDesiredSize
.
GetWritingMode
(
)
;
LogicalSize
convertedSize
=
aDesiredSize
.
Size
(
outerWM
)
.
ConvertTo
(
aWM
outerWM
)
;
if
(
NS_FRAME_NO_MOVE_FRAME
!
=
(
aFlags
&
NS_FRAME_NO_MOVE_FRAME
)
)
{
aKidFrame
-
>
SetRect
(
aWM
LogicalRect
(
aWM
aPos
convertedSize
)
aContainerSize
)
;
}
else
{
aKidFrame
-
>
SetSize
(
aWM
convertedSize
)
;
}
if
(
aKidFrame
-
>
HasView
(
)
)
{
nsView
*
view
=
aKidFrame
-
>
GetView
(
)
;
SyncFrameViewAfterReflow
(
aPresContext
aKidFrame
view
aDesiredSize
.
VisualOverflow
(
)
aFlags
)
;
}
nsPoint
newOrigin
=
aKidFrame
-
>
GetPosition
(
)
;
if
(
!
(
aFlags
&
NS_FRAME_NO_MOVE_VIEW
)
&
&
curOrigin
!
=
newOrigin
)
{
if
(
!
aKidFrame
-
>
HasView
(
)
)
{
PositionChildViews
(
aKidFrame
)
;
}
}
aKidFrame
-
>
DidReflow
(
aPresContext
aReflowInput
)
;
}
#
if
defined
(
_MSC_VER
)
&
&
!
defined
(
__clang__
)
&
&
defined
(
_M_AMD64
)
#
pragma
optimize
(
"
"
on
)
#
endif
void
nsContainerFrame
:
:
FinishReflowChild
(
nsIFrame
*
aKidFrame
nsPresContext
*
aPresContext
const
ReflowOutput
&
aDesiredSize
const
ReflowInput
*
aReflowInput
nscoord
aX
nscoord
aY
uint32_t
aFlags
)
{
nsPoint
curOrigin
=
aKidFrame
-
>
GetPosition
(
)
;
if
(
NS_FRAME_NO_MOVE_FRAME
!
=
(
aFlags
&
NS_FRAME_NO_MOVE_FRAME
)
)
{
aKidFrame
-
>
SetRect
(
nsRect
(
aX
aY
aDesiredSize
.
Width
(
)
aDesiredSize
.
Height
(
)
)
)
;
}
else
{
aKidFrame
-
>
SetSize
(
nsSize
(
aDesiredSize
.
Width
(
)
aDesiredSize
.
Height
(
)
)
)
;
}
if
(
aKidFrame
-
>
HasView
(
)
)
{
nsView
*
view
=
aKidFrame
-
>
GetView
(
)
;
SyncFrameViewAfterReflow
(
aPresContext
aKidFrame
view
aDesiredSize
.
VisualOverflow
(
)
aFlags
)
;
}
if
(
!
(
aFlags
&
NS_FRAME_NO_MOVE_VIEW
)
&
&
(
curOrigin
.
x
!
=
aX
|
|
curOrigin
.
y
!
=
aY
)
)
{
if
(
!
aKidFrame
-
>
HasView
(
)
)
{
PositionChildViews
(
aKidFrame
)
;
}
}
aKidFrame
-
>
DidReflow
(
aPresContext
aReflowInput
)
;
}
void
nsContainerFrame
:
:
ReflowOverflowContainerChildren
(
nsPresContext
*
aPresContext
const
ReflowInput
&
aReflowInput
nsOverflowAreas
&
aOverflowRects
uint32_t
aFlags
nsReflowStatus
&
aStatus
ChildFrameMerger
aMergeFunc
)
{
MOZ_ASSERT
(
aPresContext
"
null
pointer
"
)
;
nsFrameList
*
overflowContainers
=
DrainExcessOverflowContainersList
(
aMergeFunc
)
;
if
(
!
overflowContainers
)
{
return
;
}
nsOverflowContinuationTracker
tracker
(
this
false
false
)
;
bool
shouldReflowAllKids
=
aReflowInput
.
ShouldReflowAllKids
(
)
;
for
(
nsIFrame
*
frame
:
*
overflowContainers
)
{
if
(
frame
-
>
GetPrevInFlow
(
)
-
>
GetParent
(
)
!
=
GetPrevInFlow
(
)
)
{
if
(
GetNextInFlow
(
)
)
{
nsReflowStatus
status
;
status
.
SetOverflowIncomplete
(
)
;
aStatus
.
MergeCompletionStatusFrom
(
status
)
;
}
continue
;
}
if
(
shouldReflowAllKids
|
|
NS_SUBTREE_DIRTY
(
frame
)
)
{
nsIFrame
*
prevInFlow
=
frame
-
>
GetPrevInFlow
(
)
;
NS_ASSERTION
(
prevInFlow
"
overflow
container
frame
must
have
a
prev
-
in
-
flow
"
)
;
NS_ASSERTION
(
frame
-
>
GetStateBits
(
)
&
NS_FRAME_IS_OVERFLOW_CONTAINER
"
overflow
container
frame
must
have
overflow
container
bit
set
"
)
;
WritingMode
wm
=
frame
-
>
GetWritingMode
(
)
;
nsSize
containerSize
=
aReflowInput
.
AvailableSize
(
wm
)
.
GetPhysicalSize
(
wm
)
;
LogicalRect
prevRect
=
prevInFlow
-
>
GetLogicalRect
(
wm
containerSize
)
;
LogicalSize
availSpace
(
wm
prevRect
.
ISize
(
wm
)
aReflowInput
.
AvailableSize
(
wm
)
.
BSize
(
wm
)
)
;
ReflowOutput
desiredSize
(
aReflowInput
)
;
ReflowInput
frameState
(
aPresContext
aReflowInput
frame
availSpace
)
;
nsReflowStatus
frameStatus
;
LogicalPoint
pos
(
wm
prevRect
.
IStart
(
wm
)
0
)
;
ReflowChild
(
frame
aPresContext
desiredSize
frameState
wm
pos
containerSize
aFlags
frameStatus
&
tracker
)
;
FinishReflowChild
(
frame
aPresContext
desiredSize
&
frameState
wm
pos
containerSize
aFlags
)
;
if
(
!
frameStatus
.
IsFullyComplete
(
)
)
{
if
(
frame
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
{
frameStatus
.
SetOverflowIncomplete
(
)
;
}
else
{
NS_ASSERTION
(
frameStatus
.
IsComplete
(
)
"
overflow
container
frames
can
'
t
be
incomplete
only
overflow
-
incomplete
"
)
;
}
nsIFrame
*
nif
=
frame
-
>
GetNextInFlow
(
)
;
if
(
!
nif
)
{
NS_ASSERTION
(
frameStatus
.
NextInFlowNeedsReflow
(
)
"
Someone
forgot
a
NextInFlowNeedsReflow
flag
"
)
;
nif
=
aPresContext
-
>
PresShell
(
)
-
>
FrameConstructor
(
)
-
>
CreateContinuingFrame
(
aPresContext
frame
this
)
;
}
else
if
(
!
(
nif
-
>
GetStateBits
(
)
&
NS_FRAME_IS_OVERFLOW_CONTAINER
)
)
{
nsresult
rv
=
nif
-
>
GetParent
(
)
-
>
StealFrame
(
nif
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
}
tracker
.
Insert
(
nif
frameStatus
)
;
}
aStatus
.
MergeCompletionStatusFrom
(
frameStatus
)
;
}
else
{
tracker
.
Skip
(
frame
aStatus
)
;
if
(
aReflowInput
.
mFloatManager
)
{
nsBlockFrame
:
:
RecoverFloatsFor
(
frame
*
aReflowInput
.
mFloatManager
aReflowInput
.
GetWritingMode
(
)
aReflowInput
.
ComputedPhysicalSize
(
)
)
;
}
}
ConsiderChildOverflow
(
aOverflowRects
frame
)
;
}
}
void
nsContainerFrame
:
:
DisplayOverflowContainers
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
nsFrameList
*
overflowconts
=
GetPropTableFrames
(
OverflowContainersProperty
(
)
)
;
if
(
overflowconts
)
{
for
(
nsIFrame
*
frame
:
*
overflowconts
)
{
BuildDisplayListForChild
(
aBuilder
frame
aLists
)
;
}
}
}
static
bool
TryRemoveFrame
(
nsIFrame
*
aFrame
nsContainerFrame
:
:
FrameListPropertyDescriptor
aProp
nsIFrame
*
aChildToRemove
)
{
nsFrameList
*
list
=
aFrame
-
>
GetProperty
(
aProp
)
;
if
(
list
&
&
list
-
>
StartRemoveFrame
(
aChildToRemove
)
)
{
if
(
list
-
>
IsEmpty
(
)
)
{
aFrame
-
>
RemoveProperty
(
aProp
)
;
list
-
>
Delete
(
aFrame
-
>
PresShell
(
)
)
;
}
return
true
;
}
return
false
;
}
bool
nsContainerFrame
:
:
MaybeStealOverflowContainerFrame
(
nsIFrame
*
aChild
)
{
bool
removed
=
false
;
if
(
MOZ_UNLIKELY
(
aChild
-
>
GetStateBits
(
)
&
NS_FRAME_IS_OVERFLOW_CONTAINER
)
)
{
removed
=
:
:
TryRemoveFrame
(
this
OverflowContainersProperty
(
)
aChild
)
;
if
(
!
removed
)
{
removed
=
:
:
TryRemoveFrame
(
this
ExcessOverflowContainersProperty
(
)
aChild
)
;
}
}
return
removed
;
}
nsresult
nsContainerFrame
:
:
StealFrame
(
nsIFrame
*
aChild
)
{
#
ifdef
DEBUG
if
(
!
mFrames
.
ContainsFrame
(
aChild
)
)
{
nsFrameList
*
list
=
GetOverflowFrames
(
)
;
if
(
!
list
|
|
!
list
-
>
ContainsFrame
(
aChild
)
)
{
list
=
GetProperty
(
OverflowContainersProperty
(
)
)
;
if
(
!
list
|
|
!
list
-
>
ContainsFrame
(
aChild
)
)
{
list
=
GetProperty
(
ExcessOverflowContainersProperty
(
)
)
;
MOZ_ASSERT
(
list
&
&
list
-
>
ContainsFrame
(
aChild
)
"
aChild
isn
'
t
our
child
"
"
or
on
a
frame
list
not
supported
by
StealFrame
"
)
;
}
}
}
#
endif
bool
removed
=
MaybeStealOverflowContainerFrame
(
aChild
)
;
if
(
!
removed
)
{
removed
=
mFrames
.
StartRemoveFrame
(
aChild
)
;
if
(
!
removed
)
{
nsFrameList
*
frameList
=
GetOverflowFrames
(
)
;
if
(
frameList
)
{
removed
=
frameList
-
>
ContinueRemoveFrame
(
aChild
)
;
if
(
frameList
-
>
IsEmpty
(
)
)
{
DestroyOverflowList
(
)
;
}
}
}
}
MOZ_ASSERT
(
removed
"
StealFrame
:
can
'
t
find
aChild
"
)
;
return
removed
?
NS_OK
:
NS_ERROR_UNEXPECTED
;
}
nsFrameList
nsContainerFrame
:
:
StealFramesAfter
(
nsIFrame
*
aChild
)
{
NS_ASSERTION
(
!
aChild
|
|
!
(
aChild
-
>
GetStateBits
(
)
&
NS_FRAME_IS_OVERFLOW_CONTAINER
)
"
StealFramesAfter
doesn
'
t
handle
overflow
containers
"
)
;
NS_ASSERTION
(
!
IsBlockFrame
(
)
"
unexpected
call
"
)
;
if
(
!
aChild
)
{
nsFrameList
copy
(
mFrames
)
;
mFrames
.
Clear
(
)
;
return
copy
;
}
for
(
nsFrameList
:
:
FrameLinkEnumerator
iter
(
mFrames
)
;
!
iter
.
AtEnd
(
)
;
iter
.
Next
(
)
)
{
if
(
iter
.
PrevFrame
(
)
=
=
aChild
)
{
return
mFrames
.
ExtractTail
(
iter
)
;
}
}
nsFrameList
*
overflowFrames
=
GetOverflowFrames
(
)
;
if
(
overflowFrames
)
{
for
(
nsFrameList
:
:
FrameLinkEnumerator
iter
(
*
overflowFrames
)
;
!
iter
.
AtEnd
(
)
;
iter
.
Next
(
)
)
{
if
(
iter
.
PrevFrame
(
)
=
=
aChild
)
{
return
overflowFrames
-
>
ExtractTail
(
iter
)
;
}
}
}
NS_ERROR
(
"
StealFramesAfter
:
can
'
t
find
aChild
"
)
;
return
nsFrameList
:
:
EmptyList
(
)
;
}
nsIFrame
*
nsContainerFrame
:
:
CreateNextInFlow
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
!
IsBlockFrame
(
)
"
you
should
have
called
nsBlockFrame
:
:
CreateContinuationFor
instead
"
)
;
MOZ_ASSERT
(
mFrames
.
ContainsFrame
(
aFrame
)
"
expected
an
in
-
flow
child
frame
"
)
;
nsPresContext
*
pc
=
PresContext
(
)
;
nsIFrame
*
nextInFlow
=
aFrame
-
>
GetNextInFlow
(
)
;
if
(
nullptr
=
=
nextInFlow
)
{
nextInFlow
=
pc
-
>
PresShell
(
)
-
>
FrameConstructor
(
)
-
>
CreateContinuingFrame
(
pc
aFrame
this
)
;
mFrames
.
InsertFrame
(
nullptr
aFrame
nextInFlow
)
;
NS_FRAME_LOG
(
NS_FRAME_TRACE_NEW_FRAMES
(
"
nsContainerFrame
:
:
CreateNextInFlow
:
frame
=
%
p
nextInFlow
=
%
p
"
aFrame
nextInFlow
)
)
;
return
nextInFlow
;
}
return
nullptr
;
}
void
nsContainerFrame
:
:
DeleteNextInFlowChild
(
nsIFrame
*
aNextInFlow
bool
aDeletingEmptyFrames
)
{
#
ifdef
DEBUG
nsIFrame
*
prevInFlow
=
aNextInFlow
-
>
GetPrevInFlow
(
)
;
#
endif
MOZ_ASSERT
(
prevInFlow
"
bad
prev
-
in
-
flow
"
)
;
nsIFrame
*
nextNextInFlow
=
aNextInFlow
-
>
GetNextInFlow
(
)
;
if
(
nextNextInFlow
)
{
AutoTArray
<
nsIFrame
*
8
>
frames
;
for
(
nsIFrame
*
f
=
nextNextInFlow
;
f
;
f
=
f
-
>
GetNextInFlow
(
)
)
{
frames
.
AppendElement
(
f
)
;
}
for
(
nsIFrame
*
delFrame
:
Reversed
(
frames
)
)
{
delFrame
-
>
GetParent
(
)
-
>
DeleteNextInFlowChild
(
delFrame
aDeletingEmptyFrames
)
;
}
}
DebugOnly
<
nsresult
>
rv
=
StealFrame
(
aNextInFlow
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
StealFrame
failure
"
)
;
#
ifdef
DEBUG
if
(
aDeletingEmptyFrames
)
{
nsLayoutUtils
:
:
AssertTreeOnlyEmptyNextInFlows
(
aNextInFlow
)
;
}
#
endif
aNextInFlow
-
>
Destroy
(
)
;
MOZ_ASSERT
(
!
prevInFlow
-
>
GetNextInFlow
(
)
"
non
null
next
-
in
-
flow
"
)
;
}
void
nsContainerFrame
:
:
SetOverflowFrames
(
const
nsFrameList
&
aOverflowFrames
)
{
MOZ_ASSERT
(
aOverflowFrames
.
NotEmpty
(
)
"
Shouldn
'
t
be
called
"
)
;
nsPresContext
*
pc
=
PresContext
(
)
;
nsFrameList
*
newList
=
new
(
pc
-
>
PresShell
(
)
)
nsFrameList
(
aOverflowFrames
)
;
SetProperty
(
OverflowProperty
(
)
newList
)
;
}
nsFrameList
*
nsContainerFrame
:
:
GetPropTableFrames
(
FrameListPropertyDescriptor
aProperty
)
const
{
return
GetProperty
(
aProperty
)
;
}
nsFrameList
*
nsContainerFrame
:
:
RemovePropTableFrames
(
FrameListPropertyDescriptor
aProperty
)
{
return
RemoveProperty
(
aProperty
)
;
}
void
nsContainerFrame
:
:
SetPropTableFrames
(
nsFrameList
*
aFrameList
FrameListPropertyDescriptor
aProperty
)
{
MOZ_ASSERT
(
aProperty
&
&
aFrameList
"
null
ptr
"
)
;
MOZ_ASSERT
(
(
aProperty
!
=
nsContainerFrame
:
:
OverflowContainersProperty
(
)
&
&
aProperty
!
=
nsContainerFrame
:
:
ExcessOverflowContainersProperty
(
)
)
|
|
IsFrameOfType
(
nsIFrame
:
:
eCanContainOverflowContainers
)
"
this
type
of
frame
can
'
t
have
overflow
containers
"
)
;
MOZ_ASSERT
(
!
GetPropTableFrames
(
aProperty
)
)
;
SetProperty
(
aProperty
aFrameList
)
;
}
void
nsContainerFrame
:
:
PushChildrenToOverflow
(
nsIFrame
*
aFromChild
nsIFrame
*
aPrevSibling
)
{
MOZ_ASSERT
(
aFromChild
"
null
pointer
"
)
;
MOZ_ASSERT
(
aPrevSibling
"
pushing
first
child
"
)
;
MOZ_ASSERT
(
aPrevSibling
-
>
GetNextSibling
(
)
=
=
aFromChild
"
bad
prev
sibling
"
)
;
SetOverflowFrames
(
mFrames
.
RemoveFramesAfter
(
aPrevSibling
)
)
;
}
void
nsContainerFrame
:
:
PushChildren
(
nsIFrame
*
aFromChild
nsIFrame
*
aPrevSibling
)
{
MOZ_ASSERT
(
aFromChild
"
null
pointer
"
)
;
MOZ_ASSERT
(
aPrevSibling
"
pushing
first
child
"
)
;
MOZ_ASSERT
(
aPrevSibling
-
>
GetNextSibling
(
)
=
=
aFromChild
"
bad
prev
sibling
"
)
;
nsFrameList
tail
=
mFrames
.
RemoveFramesAfter
(
aPrevSibling
)
;
nsContainerFrame
*
nextInFlow
=
static_cast
<
nsContainerFrame
*
>
(
GetNextInFlow
(
)
)
;
if
(
nextInFlow
)
{
for
(
nsIFrame
*
f
=
aFromChild
;
f
;
f
=
f
-
>
GetNextSibling
(
)
)
{
nsContainerFrame
:
:
ReparentFrameView
(
f
this
nextInFlow
)
;
}
nextInFlow
-
>
mFrames
.
InsertFrames
(
nextInFlow
nullptr
tail
)
;
}
else
{
SetOverflowFrames
(
tail
)
;
}
}
bool
nsContainerFrame
:
:
MoveOverflowToChildList
(
)
{
bool
result
=
false
;
nsContainerFrame
*
prevInFlow
=
(
nsContainerFrame
*
)
GetPrevInFlow
(
)
;
if
(
nullptr
!
=
prevInFlow
)
{
AutoFrameListPtr
prevOverflowFrames
(
PresContext
(
)
prevInFlow
-
>
StealOverflowFrames
(
)
)
;
if
(
prevOverflowFrames
)
{
NS_ASSERTION
(
mFrames
.
IsEmpty
(
)
|
|
IsTableFrame
(
)
"
bad
overflow
list
"
)
;
nsContainerFrame
:
:
ReparentFrameViewList
(
*
prevOverflowFrames
prevInFlow
this
)
;
mFrames
.
AppendFrames
(
this
*
prevOverflowFrames
)
;
result
=
true
;
}
}
return
DrainSelfOverflowList
(
)
|
|
result
;
}
bool
nsContainerFrame
:
:
MoveInlineOverflowToChildList
(
nsIFrame
*
aLineContainer
)
{
MOZ_ASSERT
(
aLineContainer
"
Must
have
line
container
for
moving
inline
overflows
"
)
;
bool
result
=
false
;
if
(
auto
prevInFlow
=
static_cast
<
nsContainerFrame
*
>
(
GetPrevInFlow
(
)
)
)
{
AutoFrameListPtr
prevOverflowFrames
(
PresContext
(
)
prevInFlow
-
>
StealOverflowFrames
(
)
)
;
if
(
prevOverflowFrames
)
{
if
(
aLineContainer
-
>
GetPrevContinuation
(
)
)
{
ReparentFloatsForInlineChild
(
aLineContainer
prevOverflowFrames
-
>
FirstChild
(
)
true
ReparentingDirection
:
:
Forwards
)
;
}
nsContainerFrame
:
:
ReparentFrameViewList
(
*
prevOverflowFrames
prevInFlow
this
)
;
mFrames
.
InsertFrames
(
this
nullptr
*
prevOverflowFrames
)
;
result
=
true
;
}
}
return
DrainSelfOverflowList
(
)
|
|
result
;
}
bool
nsContainerFrame
:
:
DrainSelfOverflowList
(
)
{
AutoFrameListPtr
overflowFrames
(
PresContext
(
)
StealOverflowFrames
(
)
)
;
if
(
overflowFrames
)
{
mFrames
.
AppendFrames
(
nullptr
*
overflowFrames
)
;
return
true
;
}
return
false
;
}
nsFrameList
*
nsContainerFrame
:
:
DrainExcessOverflowContainersList
(
ChildFrameMerger
aMergeFunc
)
{
nsFrameList
*
overflowContainers
=
GetPropTableFrames
(
OverflowContainersProperty
(
)
)
;
NS_ASSERTION
(
!
(
overflowContainers
&
&
GetPrevInFlow
(
)
&
&
static_cast
<
nsContainerFrame
*
>
(
GetPrevInFlow
(
)
)
-
>
GetPropTableFrames
(
ExcessOverflowContainersProperty
(
)
)
)
"
conflicting
overflow
containers
lists
"
)
;
if
(
!
overflowContainers
)
{
nsContainerFrame
*
prev
=
(
nsContainerFrame
*
)
GetPrevInFlow
(
)
;
if
(
prev
)
{
nsFrameList
*
excessFrames
=
prev
-
>
RemovePropTableFrames
(
ExcessOverflowContainersProperty
(
)
)
;
if
(
excessFrames
)
{
excessFrames
-
>
ApplySetParent
(
this
)
;
nsContainerFrame
:
:
ReparentFrameViewList
(
*
excessFrames
prev
this
)
;
overflowContainers
=
excessFrames
;
SetPropTableFrames
(
overflowContainers
OverflowContainersProperty
(
)
)
;
}
}
}
nsFrameList
*
selfExcessOCFrames
=
RemovePropTableFrames
(
ExcessOverflowContainersProperty
(
)
)
;
if
(
selfExcessOCFrames
)
{
nsFrameList
toMove
;
auto
child
=
selfExcessOCFrames
-
>
FirstChild
(
)
;
while
(
child
)
{
auto
next
=
child
-
>
GetNextSibling
(
)
;
MOZ_ASSERT
(
child
-
>
GetPrevInFlow
(
)
"
ExcessOverflowContainers
frames
must
be
continuations
"
)
;
if
(
child
-
>
GetPrevInFlow
(
)
-
>
GetParent
(
)
!
=
this
)
{
selfExcessOCFrames
-
>
RemoveFrame
(
child
)
;
toMove
.
AppendFrame
(
nullptr
child
)
;
}
child
=
next
;
}
if
(
toMove
.
IsEmpty
(
)
)
{
SetPropTableFrames
(
selfExcessOCFrames
ExcessOverflowContainersProperty
(
)
)
;
}
else
if
(
overflowContainers
)
{
aMergeFunc
(
*
overflowContainers
toMove
this
)
;
if
(
selfExcessOCFrames
-
>
IsEmpty
(
)
)
{
selfExcessOCFrames
-
>
Delete
(
PresShell
(
)
)
;
}
else
{
SetPropTableFrames
(
selfExcessOCFrames
ExcessOverflowContainersProperty
(
)
)
;
}
}
else
{
if
(
selfExcessOCFrames
-
>
IsEmpty
(
)
)
{
*
selfExcessOCFrames
=
toMove
;
overflowContainers
=
selfExcessOCFrames
;
}
else
{
SetPropTableFrames
(
selfExcessOCFrames
ExcessOverflowContainersProperty
(
)
)
;
auto
shell
=
PresShell
(
)
;
overflowContainers
=
new
(
shell
)
nsFrameList
(
toMove
)
;
}
SetPropTableFrames
(
overflowContainers
OverflowContainersProperty
(
)
)
;
}
}
return
overflowContainers
;
}
nsIFrame
*
nsContainerFrame
:
:
GetNextInFlowChild
(
ContinuationTraversingState
&
aState
bool
*
aIsInOverflow
)
{
nsContainerFrame
*
&
nextInFlow
=
aState
.
mNextInFlow
;
while
(
nextInFlow
)
{
nsIFrame
*
frame
=
nextInFlow
-
>
mFrames
.
FirstChild
(
)
;
if
(
frame
)
{
if
(
aIsInOverflow
)
{
*
aIsInOverflow
=
false
;
}
return
frame
;
}
nsFrameList
*
overflowFrames
=
nextInFlow
-
>
GetOverflowFrames
(
)
;
if
(
overflowFrames
)
{
if
(
aIsInOverflow
)
{
*
aIsInOverflow
=
true
;
}
return
overflowFrames
-
>
FirstChild
(
)
;
}
nextInFlow
=
static_cast
<
nsContainerFrame
*
>
(
nextInFlow
-
>
GetNextInFlow
(
)
)
;
}
return
nullptr
;
}
nsIFrame
*
nsContainerFrame
:
:
PullNextInFlowChild
(
ContinuationTraversingState
&
aState
)
{
bool
isInOverflow
;
nsIFrame
*
frame
=
GetNextInFlowChild
(
aState
&
isInOverflow
)
;
if
(
frame
)
{
nsContainerFrame
*
nextInFlow
=
aState
.
mNextInFlow
;
if
(
isInOverflow
)
{
nsFrameList
*
overflowFrames
=
nextInFlow
-
>
GetOverflowFrames
(
)
;
overflowFrames
-
>
RemoveFirstChild
(
)
;
if
(
overflowFrames
-
>
IsEmpty
(
)
)
{
nextInFlow
-
>
DestroyOverflowList
(
)
;
}
}
else
{
nextInFlow
-
>
mFrames
.
RemoveFirstChild
(
)
;
}
mFrames
.
AppendFrame
(
this
frame
)
;
nsContainerFrame
:
:
ReparentFrameView
(
frame
nextInFlow
this
)
;
}
return
frame
;
}
void
nsContainerFrame
:
:
ReparentFloatsForInlineChild
(
nsIFrame
*
aOurLineContainer
nsIFrame
*
aFrame
bool
aReparentSiblings
ReparentingDirection
aDirection
)
{
NS_ASSERTION
(
aOurLineContainer
-
>
GetNextContinuation
(
)
|
|
aOurLineContainer
-
>
GetPrevContinuation
(
)
"
Don
'
t
call
this
when
we
have
no
continuation
it
'
s
a
waste
"
)
;
if
(
!
aFrame
)
{
NS_ASSERTION
(
aReparentSiblings
"
Why
did
we
get
called
?
"
)
;
return
;
}
nsBlockFrame
*
frameBlock
=
nsLayoutUtils
:
:
GetFloatContainingBlock
(
aFrame
)
;
if
(
!
frameBlock
|
|
frameBlock
=
=
aOurLineContainer
)
{
return
;
}
nsBlockFrame
*
ourBlock
=
nsLayoutUtils
:
:
GetAsBlock
(
aOurLineContainer
)
;
NS_ASSERTION
(
ourBlock
"
Not
a
block
but
broke
vertically
?
"
)
;
while
(
true
)
{
ourBlock
-
>
ReparentFloats
(
aFrame
frameBlock
false
aDirection
)
;
if
(
!
aReparentSiblings
)
return
;
nsIFrame
*
next
=
aFrame
-
>
GetNextSibling
(
)
;
if
(
!
next
)
return
;
if
(
next
-
>
GetParent
(
)
=
=
aFrame
-
>
GetParent
(
)
)
{
aFrame
=
next
;
continue
;
}
ReparentFloatsForInlineChild
(
aOurLineContainer
next
aReparentSiblings
aDirection
)
;
return
;
}
}
bool
nsContainerFrame
:
:
ResolvedOrientationIsVertical
(
)
{
StyleOrient
orient
=
StyleDisplay
(
)
-
>
mOrient
;
switch
(
orient
)
{
case
StyleOrient
:
:
Horizontal
:
return
false
;
case
StyleOrient
:
:
Vertical
:
return
true
;
case
StyleOrient
:
:
Inline
:
return
GetWritingMode
(
)
.
IsVertical
(
)
;
case
StyleOrient
:
:
Block
:
return
!
GetWritingMode
(
)
.
IsVertical
(
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
-
moz
-
orient
value
"
)
;
return
false
;
}
bool
nsContainerFrame
:
:
FrameStartsCounterScope
(
nsIFrame
*
aFrame
)
{
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
!
content
|
|
!
content
-
>
IsHTMLElement
(
)
)
return
false
;
nsAtom
*
localName
=
content
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
return
localName
=
=
nsGkAtoms
:
:
ol
|
|
localName
=
=
nsGkAtoms
:
:
ul
|
|
localName
=
=
nsGkAtoms
:
:
dir
|
|
localName
=
=
nsGkAtoms
:
:
menu
;
}
bool
nsContainerFrame
:
:
RenumberList
(
)
{
if
(
!
FrameStartsCounterScope
(
this
)
)
{
return
false
;
}
MOZ_ASSERT
(
mContent
-
>
IsHTMLElement
(
)
"
FrameStartsCounterScope
should
only
return
true
for
HTML
elements
"
)
;
int32_t
ordinal
=
1
;
int32_t
increment
;
if
(
mContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
ol
)
&
&
mContent
-
>
AsElement
(
)
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
reversed
)
)
{
increment
=
-
1
;
}
else
{
increment
=
1
;
}
nsGenericHTMLElement
*
hc
=
nsGenericHTMLElement
:
:
FromNode
(
mContent
)
;
MOZ_ASSERT
(
hc
"
How
is
mContent
not
HTML
?
"
)
;
const
nsAttrValue
*
attr
=
hc
-
>
GetParsedAttr
(
nsGkAtoms
:
:
start
)
;
nsContainerFrame
*
fif
=
static_cast
<
nsContainerFrame
*
>
(
FirstInFlow
(
)
)
;
if
(
attr
&
&
attr
-
>
Type
(
)
=
=
nsAttrValue
:
:
eInteger
)
{
ordinal
=
attr
-
>
GetIntegerValue
(
)
;
}
else
if
(
increment
<
0
)
{
ordinal
=
0
;
fif
-
>
RenumberChildFrames
(
&
ordinal
0
-
increment
true
)
;
}
return
fif
-
>
RenumberChildFrames
(
&
ordinal
0
increment
false
)
;
}
#
define
MAX_DEPTH_FOR_LIST_RENUMBERING
200
/
/
200
open
displayable
tags
is
pretty
unrealistic
bool
nsContainerFrame
:
:
RenumberFrameAndDescendants
(
int32_t
*
aOrdinal
int32_t
aDepth
int32_t
aIncrement
bool
aForCounting
)
{
MOZ_ASSERT
(
aOrdinal
"
null
params
are
immoral
!
"
)
;
if
(
MAX_DEPTH_FOR_LIST_RENUMBERING
<
aDepth
)
{
return
false
;
}
const
nsStyleDisplay
*
display
=
StyleDisplay
(
)
;
nsIFrame
*
kid
=
GetContentInsertionFrame
(
)
;
if
(
!
kid
)
{
return
false
;
}
HTMLSummaryElement
*
summary
=
HTMLSummaryElement
:
:
FromNode
(
kid
-
>
GetContent
(
)
)
;
if
(
summary
&
&
summary
-
>
IsMainSummary
(
)
)
{
return
false
;
}
bool
kidRenumberedABullet
=
false
;
if
(
mozilla
:
:
StyleDisplay
:
:
ListItem
=
=
display
-
>
mDisplay
)
{
nsBlockFrame
*
listItem
=
nsLayoutUtils
:
:
GetAsBlock
(
kid
)
;
if
(
listItem
)
{
nsBulletFrame
*
bullet
=
listItem
-
>
GetBullet
(
)
;
if
(
bullet
)
{
if
(
!
aForCounting
)
{
bool
changed
;
*
aOrdinal
=
bullet
-
>
SetListItemOrdinal
(
*
aOrdinal
&
changed
aIncrement
)
;
if
(
changed
)
{
kidRenumberedABullet
=
true
;
bullet
-
>
AddStateBits
(
NS_FRAME_IS_DIRTY
)
;
nsIFrame
*
f
=
bullet
;
do
{
nsIFrame
*
parent
=
f
-
>
GetParent
(
)
;
parent
-
>
ChildIsDirty
(
f
)
;
f
=
parent
;
}
while
(
f
!
=
listItem
)
;
}
}
else
{
*
aOrdinal
+
=
aIncrement
;
}
}
bool
meToo
=
listItem
-
>
RenumberChildFrames
(
aOrdinal
aDepth
+
1
aIncrement
aForCounting
)
;
if
(
meToo
)
{
kidRenumberedABullet
=
true
;
}
}
}
else
if
(
display
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
Block
|
|
display
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
Flex
|
|
display
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
Grid
)
{
if
(
FrameStartsCounterScope
(
kid
)
)
{
}
else
{
nsContainerFrame
*
container
=
do_QueryFrame
(
kid
)
;
if
(
container
)
{
kidRenumberedABullet
=
container
-
>
RenumberChildFrames
(
aOrdinal
aDepth
+
1
aIncrement
aForCounting
)
;
}
}
}
return
kidRenumberedABullet
;
}
bool
nsContainerFrame
:
:
RenumberChildFrames
(
int32_t
*
aOrdinal
int32_t
aDepth
int32_t
aIncrement
bool
aForCounting
)
{
bool
renumbered
=
false
;
for
(
auto
kid
:
mFrames
)
{
bool
kidRenumbered
=
kid
-
>
RenumberFrameAndDescendants
(
aOrdinal
aDepth
aIncrement
aForCounting
)
;
if
(
!
aForCounting
&
&
kidRenumbered
)
{
renumbered
=
true
;
}
}
if
(
renumbered
&
&
aDepth
!
=
0
)
{
AddStateBits
(
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
}
return
renumbered
;
}
uint16_t
nsContainerFrame
:
:
CSSAlignmentForAbsPosChild
(
const
ReflowInput
&
aChildRI
LogicalAxis
aLogicalAxis
)
const
{
MOZ_ASSERT
(
aChildRI
.
mFrame
-
>
IsAbsolutelyPositioned
(
)
"
This
method
should
only
be
called
for
abspos
children
"
)
;
NS_ERROR
(
"
Child
classes
that
use
css
box
alignment
for
abspos
children
"
"
should
provide
their
own
implementation
of
this
method
!
"
)
;
return
NS_STYLE_ALIGN_START
;
}
nsresult
nsContainerFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
nsresult
rv
=
nsSplittableFrame
:
:
AttributeChanged
(
aNameSpaceID
aAttribute
aModType
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
nsGkAtoms
:
:
start
=
=
aAttribute
|
|
(
nsGkAtoms
:
:
reversed
=
=
aAttribute
&
&
mContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
ol
)
)
)
{
if
(
RenumberList
(
)
)
{
PresShell
(
)
-
>
FrameNeedsReflow
(
this
nsIPresShell
:
:
eStyleChange
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
}
}
return
rv
;
}
nsOverflowContinuationTracker
:
:
nsOverflowContinuationTracker
(
nsContainerFrame
*
aFrame
bool
aWalkOOFFrames
bool
aSkipOverflowContainerChildren
)
:
mOverflowContList
(
nullptr
)
mPrevOverflowCont
(
nullptr
)
mSentry
(
nullptr
)
mParent
(
aFrame
)
mSkipOverflowContainerChildren
(
aSkipOverflowContainerChildren
)
mWalkOOFFrames
(
aWalkOOFFrames
)
{
MOZ_ASSERT
(
aFrame
"
null
frame
pointer
"
)
;
SetupOverflowContList
(
)
;
}
void
nsOverflowContinuationTracker
:
:
SetupOverflowContList
(
)
{
MOZ_ASSERT
(
mParent
"
null
frame
pointer
"
)
;
MOZ_ASSERT
(
!
mOverflowContList
"
already
have
list
"
)
;
nsContainerFrame
*
nif
=
static_cast
<
nsContainerFrame
*
>
(
mParent
-
>
GetNextInFlow
(
)
)
;
if
(
nif
)
{
mOverflowContList
=
nif
-
>
GetPropTableFrames
(
nsContainerFrame
:
:
OverflowContainersProperty
(
)
)
;
if
(
mOverflowContList
)
{
mParent
=
nif
;
SetUpListWalker
(
)
;
}
}
if
(
!
mOverflowContList
)
{
mOverflowContList
=
mParent
-
>
GetPropTableFrames
(
nsContainerFrame
:
:
ExcessOverflowContainersProperty
(
)
)
;
if
(
mOverflowContList
)
{
SetUpListWalker
(
)
;
}
}
}
void
nsOverflowContinuationTracker
:
:
SetUpListWalker
(
)
{
NS_ASSERTION
(
!
mSentry
&
&
!
mPrevOverflowCont
"
forgot
to
reset
mSentry
or
mPrevOverflowCont
"
)
;
if
(
mOverflowContList
)
{
nsIFrame
*
cur
=
mOverflowContList
-
>
FirstChild
(
)
;
if
(
mSkipOverflowContainerChildren
)
{
while
(
cur
&
&
(
cur
-
>
GetPrevInFlow
(
)
-
>
GetStateBits
(
)
&
NS_FRAME_IS_OVERFLOW_CONTAINER
)
)
{
mPrevOverflowCont
=
cur
;
cur
=
cur
-
>
GetNextSibling
(
)
;
}
while
(
cur
&
&
(
!
(
cur
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
=
=
mWalkOOFFrames
)
)
{
mPrevOverflowCont
=
cur
;
cur
=
cur
-
>
GetNextSibling
(
)
;
}
}
if
(
cur
)
{
mSentry
=
cur
-
>
GetPrevInFlow
(
)
;
}
}
}
void
nsOverflowContinuationTracker
:
:
StepForward
(
)
{
MOZ_ASSERT
(
mOverflowContList
"
null
list
"
)
;
if
(
mPrevOverflowCont
)
{
mPrevOverflowCont
=
mPrevOverflowCont
-
>
GetNextSibling
(
)
;
}
else
{
mPrevOverflowCont
=
mOverflowContList
-
>
FirstChild
(
)
;
}
if
(
mSkipOverflowContainerChildren
)
{
nsIFrame
*
cur
=
mPrevOverflowCont
-
>
GetNextSibling
(
)
;
while
(
cur
&
&
(
!
(
cur
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
=
=
mWalkOOFFrames
)
)
{
mPrevOverflowCont
=
cur
;
cur
=
cur
-
>
GetNextSibling
(
)
;
}
}
mSentry
=
(
mPrevOverflowCont
-
>
GetNextSibling
(
)
)
?
mPrevOverflowCont
-
>
GetNextSibling
(
)
-
>
GetPrevInFlow
(
)
:
nullptr
;
}
nsresult
nsOverflowContinuationTracker
:
:
Insert
(
nsIFrame
*
aOverflowCont
nsReflowStatus
&
aReflowStatus
)
{
MOZ_ASSERT
(
aOverflowCont
"
null
frame
pointer
"
)
;
MOZ_ASSERT
(
!
mSkipOverflowContainerChildren
|
|
mWalkOOFFrames
=
=
!
!
(
aOverflowCont
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
"
shouldn
'
t
insert
frame
that
doesn
'
t
match
walker
type
"
)
;
MOZ_ASSERT
(
aOverflowCont
-
>
GetPrevInFlow
(
)
"
overflow
containers
must
have
a
prev
-
in
-
flow
"
)
;
nsresult
rv
=
NS_OK
;
bool
reparented
=
false
;
nsPresContext
*
presContext
=
aOverflowCont
-
>
PresContext
(
)
;
bool
addToList
=
!
mSentry
|
|
aOverflowCont
!
=
mSentry
-
>
GetNextInFlow
(
)
;
if
(
addToList
&
&
aOverflowCont
-
>
GetParent
(
)
=
=
mParent
&
&
(
aOverflowCont
-
>
GetStateBits
(
)
&
NS_FRAME_IS_OVERFLOW_CONTAINER
)
&
&
mOverflowContList
&
&
mOverflowContList
-
>
ContainsFrame
(
aOverflowCont
)
)
{
addToList
=
false
;
mPrevOverflowCont
=
aOverflowCont
-
>
GetPrevSibling
(
)
;
}
if
(
addToList
)
{
if
(
aOverflowCont
-
>
GetStateBits
(
)
&
NS_FRAME_IS_OVERFLOW_CONTAINER
)
{
NS_ASSERTION
(
!
(
mOverflowContList
&
&
mOverflowContList
-
>
ContainsFrame
(
aOverflowCont
)
)
"
overflow
containers
out
of
order
"
)
;
rv
=
aOverflowCont
-
>
GetParent
(
)
-
>
StealFrame
(
aOverflowCont
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
else
{
aOverflowCont
-
>
AddStateBits
(
NS_FRAME_IS_OVERFLOW_CONTAINER
)
;
}
if
(
!
mOverflowContList
)
{
mOverflowContList
=
new
(
presContext
-
>
PresShell
(
)
)
nsFrameList
(
)
;
mParent
-
>
SetPropTableFrames
(
mOverflowContList
nsContainerFrame
:
:
ExcessOverflowContainersProperty
(
)
)
;
SetUpListWalker
(
)
;
}
if
(
aOverflowCont
-
>
GetParent
(
)
!
=
mParent
)
{
nsContainerFrame
:
:
ReparentFrameView
(
aOverflowCont
aOverflowCont
-
>
GetParent
(
)
mParent
)
;
reparented
=
true
;
}
nsIFrame
*
pif
=
aOverflowCont
-
>
GetPrevInFlow
(
)
;
nsIFrame
*
nif
=
aOverflowCont
-
>
GetNextInFlow
(
)
;
if
(
(
pif
&
&
pif
-
>
GetParent
(
)
=
=
mParent
&
&
pif
!
=
mPrevOverflowCont
)
|
|
(
nif
&
&
nif
-
>
GetParent
(
)
=
=
mParent
&
&
mPrevOverflowCont
)
)
{
for
(
nsFrameList
:
:
Enumerator
e
(
*
mOverflowContList
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
)
{
nsIFrame
*
f
=
e
.
get
(
)
;
if
(
f
=
=
pif
)
{
mPrevOverflowCont
=
pif
;
break
;
}
if
(
f
=
=
nif
)
{
mPrevOverflowCont
=
f
-
>
GetPrevSibling
(
)
;
break
;
}
}
}
mOverflowContList
-
>
InsertFrame
(
mParent
mPrevOverflowCont
aOverflowCont
)
;
aReflowStatus
.
SetNextInFlowNeedsReflow
(
)
;
}
if
(
aReflowStatus
.
NextInFlowNeedsReflow
(
)
)
aOverflowCont
-
>
AddStateBits
(
NS_FRAME_IS_DIRTY
)
;
StepForward
(
)
;
NS_ASSERTION
(
mPrevOverflowCont
=
=
aOverflowCont
|
|
(
mSkipOverflowContainerChildren
&
&
(
mPrevOverflowCont
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
!
=
(
aOverflowCont
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
)
"
OverflowContTracker
in
unexpected
state
"
)
;
if
(
addToList
)
{
nsIFrame
*
f
=
aOverflowCont
-
>
GetNextContinuation
(
)
;
if
(
f
&
&
(
!
(
f
-
>
GetStateBits
(
)
&
NS_FRAME_IS_OVERFLOW_CONTAINER
)
|
|
(
!
reparented
&
&
f
-
>
GetParent
(
)
=
=
mParent
)
|
|
(
reparented
&
&
f
-
>
GetParent
(
)
!
=
mParent
)
)
)
{
if
(
!
(
f
-
>
GetStateBits
(
)
&
NS_FRAME_IS_OVERFLOW_CONTAINER
)
)
{
rv
=
f
-
>
GetParent
(
)
-
>
StealFrame
(
f
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
Insert
(
f
aReflowStatus
)
;
}
}
return
rv
;
}
void
nsOverflowContinuationTracker
:
:
BeginFinish
(
nsIFrame
*
aChild
)
{
MOZ_ASSERT
(
aChild
"
null
ptr
"
)
;
MOZ_ASSERT
(
aChild
-
>
GetNextInFlow
(
)
"
supposed
to
call
Finish
*
before
*
deleting
next
-
in
-
flow
!
"
)
;
for
(
nsIFrame
*
f
=
aChild
;
f
;
f
=
f
-
>
GetNextInFlow
(
)
)
{
if
(
f
=
=
mPrevOverflowCont
)
{
mSentry
=
nullptr
;
mPrevOverflowCont
=
nullptr
;
break
;
}
if
(
f
=
=
mSentry
)
{
mSentry
=
nullptr
;
break
;
}
}
}
void
nsOverflowContinuationTracker
:
:
EndFinish
(
nsIFrame
*
aChild
)
{
if
(
!
mOverflowContList
)
{
return
;
}
nsFrameList
*
eoc
=
mParent
-
>
GetProperty
(
nsContainerFrame
:
:
ExcessOverflowContainersProperty
(
)
)
;
if
(
eoc
!
=
mOverflowContList
)
{
nsFrameList
*
oc
=
static_cast
<
nsFrameList
*
>
(
mParent
-
>
GetProperty
(
nsContainerFrame
:
:
OverflowContainersProperty
(
)
)
)
;
if
(
oc
!
=
mOverflowContList
)
{
mPrevOverflowCont
=
nullptr
;
mSentry
=
nullptr
;
mParent
=
aChild
-
>
GetParent
(
)
;
mOverflowContList
=
nullptr
;
SetupOverflowContList
(
)
;
return
;
}
}
if
(
!
mSentry
)
{
if
(
!
mPrevOverflowCont
)
{
SetUpListWalker
(
)
;
}
else
{
mozilla
:
:
AutoRestore
<
nsIFrame
*
>
saved
(
mPrevOverflowCont
)
;
mPrevOverflowCont
=
mPrevOverflowCont
-
>
GetPrevSibling
(
)
;
StepForward
(
)
;
}
}
}
#
ifdef
DEBUG_FRAME_DUMP
void
nsContainerFrame
:
:
List
(
FILE
*
out
const
char
*
aPrefix
uint32_t
aFlags
)
const
{
nsCString
str
;
ListGeneric
(
str
aPrefix
aFlags
)
;
bool
outputOneList
=
false
;
ChildListIterator
lists
(
this
)
;
for
(
;
!
lists
.
IsDone
(
)
;
lists
.
Next
(
)
)
{
if
(
outputOneList
)
{
str
+
=
aPrefix
;
}
if
(
lists
.
CurrentID
(
)
!
=
kPrincipalList
)
{
if
(
!
outputOneList
)
{
str
+
=
"
\
n
"
;
str
+
=
aPrefix
;
}
str
+
=
nsPrintfCString
(
"
%
s
%
p
"
mozilla
:
:
layout
:
:
ChildListName
(
lists
.
CurrentID
(
)
)
&
GetChildList
(
lists
.
CurrentID
(
)
)
)
;
}
fprintf_stderr
(
out
"
%
s
<
\
n
"
str
.
get
(
)
)
;
str
=
"
"
;
nsFrameList
:
:
Enumerator
childFrames
(
lists
.
CurrentList
(
)
)
;
for
(
;
!
childFrames
.
AtEnd
(
)
;
childFrames
.
Next
(
)
)
{
nsIFrame
*
kid
=
childFrames
.
get
(
)
;
NS_ASSERTION
(
kid
-
>
GetParent
(
)
=
=
this
"
bad
parent
frame
pointer
"
)
;
nsCString
pfx
(
aPrefix
)
;
pfx
+
=
"
"
;
kid
-
>
List
(
out
pfx
.
get
(
)
aFlags
)
;
}
fprintf_stderr
(
out
"
%
s
>
\
n
"
aPrefix
)
;
outputOneList
=
true
;
}
if
(
!
outputOneList
)
{
fprintf_stderr
(
out
"
%
s
<
>
\
n
"
str
.
get
(
)
)
;
}
}
#
endif
