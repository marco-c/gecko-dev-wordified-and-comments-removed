#
include
"
nsFrameList
.
h
"
#
include
"
mozilla
/
intl
/
BidiEmbeddingLevel
.
h
"
#
include
"
mozilla
/
ArenaObjectID
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
nsBidiPresUtils
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsILineIterator
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsPresContext
.
h
"
using
namespace
mozilla
;
namespace
mozilla
{
namespace
detail
{
const
AlignedFrameListBytes
gEmptyFrameListBytes
=
{
0
}
;
}
}
void
*
nsFrameList
:
:
operator
new
(
size_t
sz
mozilla
:
:
PresShell
*
aPresShell
)
{
return
aPresShell
-
>
AllocateByObjectID
(
eArenaObjectID_nsFrameList
sz
)
;
}
void
nsFrameList
:
:
Delete
(
mozilla
:
:
PresShell
*
aPresShell
)
{
MOZ_ASSERT
(
this
!
=
&
EmptyList
(
)
"
Shouldn
'
t
Delete
(
)
this
list
"
)
;
NS_ASSERTION
(
IsEmpty
(
)
"
Shouldn
'
t
Delete
(
)
a
non
-
empty
list
"
)
;
aPresShell
-
>
FreeByObjectID
(
eArenaObjectID_nsFrameList
this
)
;
}
void
nsFrameList
:
:
DestroyFrames
(
)
{
while
(
nsIFrame
*
frame
=
RemoveFirstChild
(
)
)
{
frame
-
>
Destroy
(
)
;
}
mLastChild
=
nullptr
;
}
void
nsFrameList
:
:
DestroyFramesFrom
(
nsIFrame
*
aDestructRoot
layout
:
:
PostFrameDestroyData
&
aPostDestroyData
)
{
MOZ_ASSERT
(
aDestructRoot
"
Missing
destruct
root
"
)
;
while
(
nsIFrame
*
frame
=
RemoveFirstChild
(
)
)
{
frame
-
>
DestroyFrom
(
aDestructRoot
aPostDestroyData
)
;
}
mLastChild
=
nullptr
;
}
void
nsFrameList
:
:
SetFrames
(
nsIFrame
*
aFrameList
)
{
MOZ_ASSERT
(
!
mFirstChild
"
Losing
frames
"
)
;
mFirstChild
=
aFrameList
;
mLastChild
=
nsLayoutUtils
:
:
GetLastSibling
(
mFirstChild
)
;
}
void
nsFrameList
:
:
RemoveFrame
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
"
null
ptr
"
)
;
#
ifdef
DEBUG_FRAME_LIST
MOZ_ASSERT
(
ContainsFrame
(
aFrame
)
"
wrong
list
"
)
;
#
endif
nsIFrame
*
nextFrame
=
aFrame
-
>
GetNextSibling
(
)
;
if
(
aFrame
=
=
mFirstChild
)
{
mFirstChild
=
nextFrame
;
aFrame
-
>
SetNextSibling
(
nullptr
)
;
if
(
!
nextFrame
)
{
mLastChild
=
nullptr
;
}
}
else
{
nsIFrame
*
prevSibling
=
aFrame
-
>
GetPrevSibling
(
)
;
NS_ASSERTION
(
prevSibling
&
&
prevSibling
-
>
GetNextSibling
(
)
=
=
aFrame
"
Broken
frame
linkage
"
)
;
prevSibling
-
>
SetNextSibling
(
nextFrame
)
;
aFrame
-
>
SetNextSibling
(
nullptr
)
;
if
(
!
nextFrame
)
{
mLastChild
=
prevSibling
;
}
}
}
nsFrameList
nsFrameList
:
:
RemoveFramesAfter
(
nsIFrame
*
aAfterFrame
)
{
if
(
!
aAfterFrame
)
{
nsFrameList
result
;
result
.
InsertFrames
(
nullptr
nullptr
*
this
)
;
return
result
;
}
MOZ_ASSERT
(
NotEmpty
(
)
"
illegal
operation
on
empty
list
"
)
;
#
ifdef
DEBUG_FRAME_LIST
MOZ_ASSERT
(
ContainsFrame
(
aAfterFrame
)
"
wrong
list
"
)
;
#
endif
nsIFrame
*
tail
=
aAfterFrame
-
>
GetNextSibling
(
)
;
nsIFrame
*
oldLastChild
=
mLastChild
;
mLastChild
=
aAfterFrame
;
aAfterFrame
-
>
SetNextSibling
(
nullptr
)
;
return
nsFrameList
(
tail
tail
?
oldLastChild
:
nullptr
)
;
}
nsIFrame
*
nsFrameList
:
:
RemoveFirstChild
(
)
{
if
(
mFirstChild
)
{
nsIFrame
*
firstChild
=
mFirstChild
;
RemoveFrame
(
firstChild
)
;
return
firstChild
;
}
return
nullptr
;
}
void
nsFrameList
:
:
DestroyFrame
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
"
null
ptr
"
)
;
RemoveFrame
(
aFrame
)
;
aFrame
-
>
Destroy
(
)
;
}
nsFrameList
:
:
Slice
nsFrameList
:
:
InsertFrames
(
nsContainerFrame
*
aParent
nsIFrame
*
aPrevSibling
nsFrameList
&
aFrameList
)
{
MOZ_ASSERT
(
aFrameList
.
NotEmpty
(
)
"
Unexpected
empty
list
"
)
;
if
(
aParent
)
{
aFrameList
.
ApplySetParent
(
aParent
)
;
}
NS_ASSERTION
(
IsEmpty
(
)
|
|
FirstChild
(
)
-
>
GetParent
(
)
=
=
aFrameList
.
FirstChild
(
)
-
>
GetParent
(
)
"
frame
to
add
has
different
parent
"
)
;
NS_ASSERTION
(
!
aPrevSibling
|
|
aPrevSibling
-
>
GetParent
(
)
=
=
aFrameList
.
FirstChild
(
)
-
>
GetParent
(
)
"
prev
sibling
has
different
parent
"
)
;
#
ifdef
DEBUG_FRAME_LIST
NS_ASSERTION
(
!
aPrevSibling
|
|
ContainsFrame
(
aPrevSibling
)
"
prev
sibling
is
not
on
this
list
"
)
;
#
endif
nsIFrame
*
firstNewFrame
=
aFrameList
.
FirstChild
(
)
;
nsIFrame
*
nextSibling
;
if
(
aPrevSibling
)
{
nextSibling
=
aPrevSibling
-
>
GetNextSibling
(
)
;
aPrevSibling
-
>
SetNextSibling
(
firstNewFrame
)
;
}
else
{
nextSibling
=
mFirstChild
;
mFirstChild
=
firstNewFrame
;
}
nsIFrame
*
lastNewFrame
=
aFrameList
.
LastChild
(
)
;
lastNewFrame
-
>
SetNextSibling
(
nextSibling
)
;
if
(
!
nextSibling
)
{
mLastChild
=
lastNewFrame
;
}
VerifyList
(
)
;
aFrameList
.
Clear
(
)
;
return
Slice
(
*
this
firstNewFrame
nextSibling
)
;
}
nsFrameList
nsFrameList
:
:
ExtractHead
(
FrameLinkEnumerator
&
aLink
)
{
MOZ_ASSERT
(
&
aLink
.
List
(
)
=
=
this
"
Unexpected
list
"
)
;
MOZ_ASSERT
(
!
aLink
.
PrevFrame
(
)
|
|
aLink
.
PrevFrame
(
)
-
>
GetNextSibling
(
)
=
=
aLink
.
NextFrame
(
)
"
Unexpected
PrevFrame
(
)
"
)
;
MOZ_ASSERT
(
aLink
.
PrevFrame
(
)
|
|
aLink
.
NextFrame
(
)
=
=
FirstChild
(
)
"
Unexpected
NextFrame
(
)
"
)
;
MOZ_ASSERT
(
!
aLink
.
PrevFrame
(
)
|
|
aLink
.
NextFrame
(
)
!
=
FirstChild
(
)
"
Unexpected
NextFrame
(
)
"
)
;
MOZ_ASSERT
(
aLink
.
mEnd
=
=
nullptr
"
Unexpected
mEnd
for
frame
link
enumerator
"
)
;
nsIFrame
*
prev
=
aLink
.
PrevFrame
(
)
;
nsIFrame
*
newFirstFrame
=
nullptr
;
if
(
prev
)
{
prev
-
>
SetNextSibling
(
nullptr
)
;
newFirstFrame
=
mFirstChild
;
mFirstChild
=
aLink
.
NextFrame
(
)
;
if
(
!
mFirstChild
)
{
mLastChild
=
nullptr
;
}
aLink
.
mPrev
=
nullptr
;
}
return
nsFrameList
(
newFirstFrame
prev
)
;
}
nsFrameList
nsFrameList
:
:
ExtractTail
(
FrameLinkEnumerator
&
aLink
)
{
MOZ_ASSERT
(
&
aLink
.
List
(
)
=
=
this
"
Unexpected
list
"
)
;
MOZ_ASSERT
(
!
aLink
.
PrevFrame
(
)
|
|
aLink
.
PrevFrame
(
)
-
>
GetNextSibling
(
)
=
=
aLink
.
NextFrame
(
)
"
Unexpected
PrevFrame
(
)
"
)
;
MOZ_ASSERT
(
aLink
.
PrevFrame
(
)
|
|
aLink
.
NextFrame
(
)
=
=
FirstChild
(
)
"
Unexpected
NextFrame
(
)
"
)
;
MOZ_ASSERT
(
!
aLink
.
PrevFrame
(
)
|
|
aLink
.
NextFrame
(
)
!
=
FirstChild
(
)
"
Unexpected
NextFrame
(
)
"
)
;
MOZ_ASSERT
(
aLink
.
mEnd
=
=
nullptr
"
Unexpected
mEnd
for
frame
link
enumerator
"
)
;
nsIFrame
*
prev
=
aLink
.
PrevFrame
(
)
;
nsIFrame
*
newFirstFrame
;
nsIFrame
*
newLastFrame
;
if
(
prev
)
{
prev
-
>
SetNextSibling
(
nullptr
)
;
newFirstFrame
=
aLink
.
NextFrame
(
)
;
newLastFrame
=
newFirstFrame
?
mLastChild
:
nullptr
;
mLastChild
=
prev
;
}
else
{
newFirstFrame
=
mFirstChild
;
newLastFrame
=
mLastChild
;
Clear
(
)
;
}
aLink
.
mFrame
=
nullptr
;
MOZ_ASSERT
(
aLink
.
AtEnd
(
)
"
What
'
s
going
on
here
?
"
)
;
return
nsFrameList
(
newFirstFrame
newLastFrame
)
;
}
nsIFrame
*
nsFrameList
:
:
FrameAt
(
int32_t
aIndex
)
const
{
MOZ_ASSERT
(
aIndex
>
=
0
"
invalid
arg
"
)
;
if
(
aIndex
<
0
)
return
nullptr
;
nsIFrame
*
frame
=
mFirstChild
;
while
(
(
aIndex
-
-
>
0
)
&
&
frame
)
{
frame
=
frame
-
>
GetNextSibling
(
)
;
}
return
frame
;
}
int32_t
nsFrameList
:
:
IndexOf
(
nsIFrame
*
aFrame
)
const
{
int32_t
count
=
0
;
for
(
nsIFrame
*
f
=
mFirstChild
;
f
;
f
=
f
-
>
GetNextSibling
(
)
)
{
if
(
f
=
=
aFrame
)
return
count
;
+
+
count
;
}
return
-
1
;
}
bool
nsFrameList
:
:
ContainsFrame
(
const
nsIFrame
*
aFrame
)
const
{
MOZ_ASSERT
(
aFrame
"
null
ptr
"
)
;
nsIFrame
*
frame
=
mFirstChild
;
while
(
frame
)
{
if
(
frame
=
=
aFrame
)
{
return
true
;
}
frame
=
frame
-
>
GetNextSibling
(
)
;
}
return
false
;
}
int32_t
nsFrameList
:
:
GetLength
(
)
const
{
int32_t
count
=
0
;
nsIFrame
*
frame
=
mFirstChild
;
while
(
frame
)
{
count
+
+
;
frame
=
frame
-
>
GetNextSibling
(
)
;
}
return
count
;
}
void
nsFrameList
:
:
ApplySetParent
(
nsContainerFrame
*
aParent
)
const
{
NS_ASSERTION
(
aParent
"
null
ptr
"
)
;
for
(
nsIFrame
*
f
=
FirstChild
(
)
;
f
;
f
=
f
-
>
GetNextSibling
(
)
)
{
f
-
>
SetParent
(
aParent
)
;
}
}
void
nsFrameList
:
:
UnhookFrameFromSiblings
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
-
>
GetPrevSibling
(
)
&
&
aFrame
-
>
GetNextSibling
(
)
)
;
nsIFrame
*
const
nextSibling
=
aFrame
-
>
GetNextSibling
(
)
;
nsIFrame
*
const
prevSibling
=
aFrame
-
>
GetPrevSibling
(
)
;
aFrame
-
>
SetNextSibling
(
nullptr
)
;
prevSibling
-
>
SetNextSibling
(
nextSibling
)
;
MOZ_ASSERT
(
!
aFrame
-
>
GetPrevSibling
(
)
&
&
!
aFrame
-
>
GetNextSibling
(
)
)
;
}
#
ifdef
DEBUG_FRAME_DUMP
void
nsFrameList
:
:
List
(
FILE
*
out
)
const
{
fprintf_stderr
(
out
"
<
\
n
"
)
;
for
(
nsIFrame
*
frame
=
mFirstChild
;
frame
;
frame
=
frame
-
>
GetNextSibling
(
)
)
{
frame
-
>
List
(
out
"
"
)
;
}
fprintf_stderr
(
out
"
>
\
n
"
)
;
}
#
endif
nsIFrame
*
nsFrameList
:
:
GetPrevVisualFor
(
nsIFrame
*
aFrame
)
const
{
if
(
!
mFirstChild
)
return
nullptr
;
nsIFrame
*
parent
=
mFirstChild
-
>
GetParent
(
)
;
if
(
!
parent
)
return
aFrame
?
aFrame
-
>
GetPrevSibling
(
)
:
LastChild
(
)
;
mozilla
:
:
intl
:
:
BidiDirection
paraDir
=
nsBidiPresUtils
:
:
ParagraphDirection
(
mFirstChild
)
;
AutoAssertNoDomMutations
guard
;
nsILineIterator
*
iter
=
parent
-
>
GetLineIterator
(
)
;
if
(
!
iter
)
{
if
(
parent
-
>
IsLineFrame
(
)
)
{
if
(
paraDir
=
=
mozilla
:
:
intl
:
:
BidiDirection
:
:
LTR
)
{
return
nsBidiPresUtils
:
:
GetFrameToLeftOf
(
aFrame
mFirstChild
-
1
)
;
}
else
{
return
nsBidiPresUtils
:
:
GetFrameToRightOf
(
aFrame
mFirstChild
-
1
)
;
}
}
else
{
if
(
nsBidiPresUtils
:
:
IsFrameInParagraphDirection
(
mFirstChild
)
)
{
return
aFrame
?
aFrame
-
>
GetPrevSibling
(
)
:
LastChild
(
)
;
}
else
{
return
aFrame
?
aFrame
-
>
GetNextSibling
(
)
:
mFirstChild
;
}
}
}
int32_t
thisLine
;
if
(
aFrame
)
{
thisLine
=
iter
-
>
FindLineContaining
(
aFrame
)
;
if
(
thisLine
<
0
)
return
nullptr
;
}
else
{
thisLine
=
iter
-
>
GetNumLines
(
)
;
}
nsIFrame
*
frame
=
nullptr
;
if
(
aFrame
)
{
auto
line
=
iter
-
>
GetLine
(
thisLine
)
.
unwrap
(
)
;
if
(
paraDir
=
=
mozilla
:
:
intl
:
:
BidiDirection
:
:
LTR
)
{
frame
=
nsBidiPresUtils
:
:
GetFrameToLeftOf
(
aFrame
line
.
mFirstFrameOnLine
line
.
mNumFramesOnLine
)
;
}
else
{
frame
=
nsBidiPresUtils
:
:
GetFrameToRightOf
(
aFrame
line
.
mFirstFrameOnLine
line
.
mNumFramesOnLine
)
;
}
}
if
(
!
frame
&
&
thisLine
>
0
)
{
auto
line
=
iter
-
>
GetLine
(
thisLine
-
1
)
.
unwrap
(
)
;
if
(
paraDir
=
=
mozilla
:
:
intl
:
:
BidiDirection
:
:
LTR
)
{
frame
=
nsBidiPresUtils
:
:
GetFrameToLeftOf
(
nullptr
line
.
mFirstFrameOnLine
line
.
mNumFramesOnLine
)
;
}
else
{
frame
=
nsBidiPresUtils
:
:
GetFrameToRightOf
(
nullptr
line
.
mFirstFrameOnLine
line
.
mNumFramesOnLine
)
;
}
}
return
frame
;
}
nsIFrame
*
nsFrameList
:
:
GetNextVisualFor
(
nsIFrame
*
aFrame
)
const
{
if
(
!
mFirstChild
)
return
nullptr
;
nsIFrame
*
parent
=
mFirstChild
-
>
GetParent
(
)
;
if
(
!
parent
)
return
aFrame
?
aFrame
-
>
GetPrevSibling
(
)
:
mFirstChild
;
mozilla
:
:
intl
:
:
BidiDirection
paraDir
=
nsBidiPresUtils
:
:
ParagraphDirection
(
mFirstChild
)
;
AutoAssertNoDomMutations
guard
;
nsILineIterator
*
iter
=
parent
-
>
GetLineIterator
(
)
;
if
(
!
iter
)
{
if
(
parent
-
>
IsLineFrame
(
)
)
{
if
(
paraDir
=
=
mozilla
:
:
intl
:
:
BidiDirection
:
:
LTR
)
{
return
nsBidiPresUtils
:
:
GetFrameToRightOf
(
aFrame
mFirstChild
-
1
)
;
}
else
{
return
nsBidiPresUtils
:
:
GetFrameToLeftOf
(
aFrame
mFirstChild
-
1
)
;
}
}
else
{
if
(
nsBidiPresUtils
:
:
IsFrameInParagraphDirection
(
mFirstChild
)
)
{
return
aFrame
?
aFrame
-
>
GetNextSibling
(
)
:
mFirstChild
;
}
else
{
return
aFrame
?
aFrame
-
>
GetPrevSibling
(
)
:
LastChild
(
)
;
}
}
}
int32_t
thisLine
;
if
(
aFrame
)
{
thisLine
=
iter
-
>
FindLineContaining
(
aFrame
)
;
if
(
thisLine
<
0
)
return
nullptr
;
}
else
{
thisLine
=
-
1
;
}
nsIFrame
*
frame
=
nullptr
;
if
(
aFrame
)
{
auto
line
=
iter
-
>
GetLine
(
thisLine
)
.
unwrap
(
)
;
if
(
paraDir
=
=
mozilla
:
:
intl
:
:
BidiDirection
:
:
LTR
)
{
frame
=
nsBidiPresUtils
:
:
GetFrameToRightOf
(
aFrame
line
.
mFirstFrameOnLine
line
.
mNumFramesOnLine
)
;
}
else
{
frame
=
nsBidiPresUtils
:
:
GetFrameToLeftOf
(
aFrame
line
.
mFirstFrameOnLine
line
.
mNumFramesOnLine
)
;
}
}
int32_t
numLines
=
iter
-
>
GetNumLines
(
)
;
if
(
!
frame
&
&
thisLine
<
numLines
-
1
)
{
auto
line
=
iter
-
>
GetLine
(
thisLine
+
1
)
.
unwrap
(
)
;
if
(
paraDir
=
=
mozilla
:
:
intl
:
:
BidiDirection
:
:
LTR
)
{
frame
=
nsBidiPresUtils
:
:
GetFrameToRightOf
(
nullptr
line
.
mFirstFrameOnLine
line
.
mNumFramesOnLine
)
;
}
else
{
frame
=
nsBidiPresUtils
:
:
GetFrameToLeftOf
(
nullptr
line
.
mFirstFrameOnLine
line
.
mNumFramesOnLine
)
;
}
}
return
frame
;
}
#
ifdef
DEBUG_FRAME_LIST
void
nsFrameList
:
:
VerifyList
(
)
const
{
NS_ASSERTION
(
(
mFirstChild
=
=
nullptr
)
=
=
(
mLastChild
=
=
nullptr
)
"
bad
list
state
"
)
;
if
(
IsEmpty
(
)
)
{
return
;
}
NS_ASSERTION
(
!
mFirstChild
-
>
GetPrevSibling
(
)
"
bad
prev
sibling
pointer
"
)
;
nsIFrame
*
first
=
mFirstChild
*
second
=
mFirstChild
;
for
(
;
;
)
{
first
=
first
-
>
GetNextSibling
(
)
;
second
=
second
-
>
GetNextSibling
(
)
;
if
(
!
second
)
{
break
;
}
NS_ASSERTION
(
second
-
>
GetPrevSibling
(
)
-
>
GetNextSibling
(
)
=
=
second
"
bad
prev
sibling
pointer
"
)
;
second
=
second
-
>
GetNextSibling
(
)
;
if
(
first
=
=
second
)
{
NS_ERROR
(
"
loop
in
frame
list
.
This
will
probably
hang
soon
.
"
)
;
return
;
}
if
(
!
second
)
{
break
;
}
NS_ASSERTION
(
second
-
>
GetPrevSibling
(
)
-
>
GetNextSibling
(
)
=
=
second
"
bad
prev
sibling
pointer
"
)
;
}
NS_ASSERTION
(
mLastChild
=
=
nsLayoutUtils
:
:
GetLastSibling
(
mFirstChild
)
"
bogus
mLastChild
"
)
;
}
#
endif
namespace
mozilla
{
AutoFrameListPtr
:
:
~
AutoFrameListPtr
(
)
{
if
(
mFrameList
)
{
mFrameList
-
>
Delete
(
mPresContext
-
>
PresShell
(
)
)
;
}
}
}
