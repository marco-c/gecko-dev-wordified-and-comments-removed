#
ifndef
mozilla_ReflowOutput_h
#
define
mozilla_ReflowOutput_h
#
include
"
mozilla
/
EnumeratedRange
.
h
"
#
include
"
mozilla
/
WritingModes
.
h
"
#
include
"
nsBoundingMetrics
.
h
"
#
include
"
nsRect
.
h
"
namespace
mozilla
{
struct
ReflowInput
;
enum
class
OverflowType
:
uint8_t
{
Ink
Scrollable
}
;
constexpr
auto
AllOverflowTypes
(
)
{
return
mozilla
:
:
MakeInclusiveEnumeratedRange
(
OverflowType
:
:
Ink
OverflowType
:
:
Scrollable
)
;
}
}
enum
nsOverflowType
{
eInkOverflow
eScrollableOverflow
eOverflowType_LENGTH
}
;
struct
nsOverflowAreas
{
private
:
nsRect
mRects
[
2
]
;
public
:
using
OverflowType
=
mozilla
:
:
OverflowType
;
nsRect
&
Overflow
(
size_t
aIndex
)
{
NS_ASSERTION
(
aIndex
<
2
"
index
out
of
range
"
)
;
return
mRects
[
aIndex
]
;
}
const
nsRect
&
Overflow
(
size_t
aIndex
)
const
{
NS_ASSERTION
(
aIndex
<
2
"
index
out
of
range
"
)
;
return
mRects
[
aIndex
]
;
}
nsRect
&
InkOverflow
(
)
{
return
mRects
[
eInkOverflow
]
;
}
const
nsRect
&
InkOverflow
(
)
const
{
return
mRects
[
eInkOverflow
]
;
}
nsRect
&
ScrollableOverflow
(
)
{
return
mRects
[
eScrollableOverflow
]
;
}
const
nsRect
&
ScrollableOverflow
(
)
const
{
return
mRects
[
eScrollableOverflow
]
;
}
nsRect
&
Overflow
(
OverflowType
aType
)
{
return
aType
=
=
OverflowType
:
:
Ink
?
InkOverflow
(
)
:
ScrollableOverflow
(
)
;
}
const
nsRect
&
Overflow
(
OverflowType
aType
)
const
{
return
aType
=
=
OverflowType
:
:
Ink
?
InkOverflow
(
)
:
ScrollableOverflow
(
)
;
}
nsOverflowAreas
(
)
{
}
nsOverflowAreas
(
const
nsRect
&
aInkOverflow
const
nsRect
&
aScrollableOverflow
)
{
mRects
[
eInkOverflow
]
=
aInkOverflow
;
mRects
[
eScrollableOverflow
]
=
aScrollableOverflow
;
}
nsOverflowAreas
(
const
nsOverflowAreas
&
aOther
)
{
*
this
=
aOther
;
}
nsOverflowAreas
&
operator
=
(
const
nsOverflowAreas
&
aOther
)
{
mRects
[
0
]
=
aOther
.
mRects
[
0
]
;
mRects
[
1
]
=
aOther
.
mRects
[
1
]
;
return
*
this
;
}
bool
operator
=
=
(
const
nsOverflowAreas
&
aOther
)
const
{
return
InkOverflow
(
)
.
IsEqualInterior
(
aOther
.
InkOverflow
(
)
)
&
&
ScrollableOverflow
(
)
.
IsEqualEdges
(
aOther
.
ScrollableOverflow
(
)
)
;
}
bool
operator
!
=
(
const
nsOverflowAreas
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
nsOverflowAreas
operator
+
(
const
nsPoint
&
aPoint
)
const
{
nsOverflowAreas
result
(
*
this
)
;
result
+
=
aPoint
;
return
result
;
}
nsOverflowAreas
&
operator
+
=
(
const
nsPoint
&
aPoint
)
{
mRects
[
0
]
+
=
aPoint
;
mRects
[
1
]
+
=
aPoint
;
return
*
this
;
}
void
Clear
(
)
{
mRects
[
0
]
.
SetRect
(
0
0
0
0
)
;
mRects
[
1
]
.
SetRect
(
0
0
0
0
)
;
}
void
UnionWith
(
const
nsOverflowAreas
&
aOther
)
;
void
UnionAllWith
(
const
nsRect
&
aRect
)
;
void
SetAllTo
(
const
nsRect
&
aRect
)
;
}
;
struct
nsCollapsingMargin
{
private
:
nscoord
mMostPos
;
nscoord
mMostNeg
;
public
:
nsCollapsingMargin
(
)
:
mMostPos
(
0
)
mMostNeg
(
0
)
{
}
nsCollapsingMargin
(
const
nsCollapsingMargin
&
aOther
)
=
default
;
bool
operator
=
=
(
const
nsCollapsingMargin
&
aOther
)
{
return
mMostPos
=
=
aOther
.
mMostPos
&
&
mMostNeg
=
=
aOther
.
mMostNeg
;
}
bool
operator
!
=
(
const
nsCollapsingMargin
&
aOther
)
{
return
!
(
*
this
=
=
aOther
)
;
}
nsCollapsingMargin
&
operator
=
(
const
nsCollapsingMargin
&
aOther
)
=
default
;
void
Include
(
nscoord
aCoord
)
{
if
(
aCoord
>
mMostPos
)
mMostPos
=
aCoord
;
else
if
(
aCoord
<
mMostNeg
)
mMostNeg
=
aCoord
;
}
void
Include
(
const
nsCollapsingMargin
&
aOther
)
{
if
(
aOther
.
mMostPos
>
mMostPos
)
mMostPos
=
aOther
.
mMostPos
;
if
(
aOther
.
mMostNeg
<
mMostNeg
)
mMostNeg
=
aOther
.
mMostNeg
;
}
void
Zero
(
)
{
mMostPos
=
0
;
mMostNeg
=
0
;
}
bool
IsZero
(
)
const
{
return
(
mMostPos
=
=
0
)
&
&
(
mMostNeg
=
=
0
)
;
}
nscoord
get
(
)
const
{
return
mMostPos
+
mMostNeg
;
}
}
;
namespace
mozilla
{
class
ReflowOutput
{
public
:
explicit
ReflowOutput
(
mozilla
:
:
WritingMode
aWritingMode
)
:
mSize
(
aWritingMode
)
mWritingMode
(
aWritingMode
)
{
}
explicit
ReflowOutput
(
const
ReflowInput
&
aReflowInput
)
;
nscoord
ISize
(
mozilla
:
:
WritingMode
aWritingMode
)
const
{
return
mSize
.
ISize
(
aWritingMode
)
;
}
nscoord
BSize
(
mozilla
:
:
WritingMode
aWritingMode
)
const
{
return
mSize
.
BSize
(
aWritingMode
)
;
}
mozilla
:
:
LogicalSize
Size
(
mozilla
:
:
WritingMode
aWritingMode
)
const
{
return
mSize
.
ConvertTo
(
aWritingMode
mWritingMode
)
;
}
nscoord
&
ISize
(
mozilla
:
:
WritingMode
aWritingMode
)
{
return
mSize
.
ISize
(
aWritingMode
)
;
}
nscoord
&
BSize
(
mozilla
:
:
WritingMode
aWritingMode
)
{
return
mSize
.
BSize
(
aWritingMode
)
;
}
void
SetSize
(
mozilla
:
:
WritingMode
aWM
mozilla
:
:
LogicalSize
aSize
)
{
mSize
=
aSize
.
ConvertTo
(
mWritingMode
aWM
)
;
}
void
ClearSize
(
)
{
mSize
.
SizeTo
(
mWritingMode
0
0
)
;
}
nscoord
Width
(
)
const
{
return
mSize
.
Width
(
mWritingMode
)
;
}
nscoord
Height
(
)
const
{
return
mSize
.
Height
(
mWritingMode
)
;
}
nscoord
&
Width
(
)
{
return
mWritingMode
.
IsVertical
(
)
?
mSize
.
BSize
(
mWritingMode
)
:
mSize
.
ISize
(
mWritingMode
)
;
}
nscoord
&
Height
(
)
{
return
mWritingMode
.
IsVertical
(
)
?
mSize
.
ISize
(
mWritingMode
)
:
mSize
.
BSize
(
mWritingMode
)
;
}
nsSize
PhysicalSize
(
)
const
{
return
mSize
.
GetPhysicalSize
(
mWritingMode
)
;
}
enum
{
ASK_FOR_BASELINE
=
nscoord_MAX
}
;
nscoord
BlockStartAscent
(
)
const
{
return
mBlockStartAscent
;
}
void
SetBlockStartAscent
(
nscoord
aAscent
)
{
mBlockStartAscent
=
aAscent
;
}
nsBoundingMetrics
mBoundingMetrics
;
nsCollapsingMargin
mCarriedOutBEndMargin
;
nsOverflowAreas
mOverflowAreas
;
nsRect
&
InkOverflow
(
)
{
return
mOverflowAreas
.
InkOverflow
(
)
;
}
const
nsRect
&
InkOverflow
(
)
const
{
return
mOverflowAreas
.
InkOverflow
(
)
;
}
nsRect
&
ScrollableOverflow
(
)
{
return
mOverflowAreas
.
ScrollableOverflow
(
)
;
}
const
nsRect
&
ScrollableOverflow
(
)
const
{
return
mOverflowAreas
.
ScrollableOverflow
(
)
;
}
void
SetOverflowAreasToDesiredBounds
(
)
;
void
UnionOverflowAreasWithDesiredBounds
(
)
;
mozilla
:
:
WritingMode
GetWritingMode
(
)
const
{
return
mWritingMode
;
}
private
:
LogicalSize
mSize
;
nscoord
mBlockStartAscent
=
ASK_FOR_BASELINE
;
mozilla
:
:
WritingMode
mWritingMode
;
}
;
}
#
endif
