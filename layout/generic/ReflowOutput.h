#
ifndef
mozilla_ReflowOutput_h
#
define
mozilla_ReflowOutput_h
#
include
"
mozilla
/
EnumeratedRange
.
h
"
#
include
"
mozilla
/
WritingModes
.
h
"
#
include
"
nsBoundingMetrics
.
h
"
#
include
"
nsRect
.
h
"
namespace
mozilla
{
struct
ReflowInput
;
enum
class
OverflowType
:
uint8_t
{
Ink
Scrollable
}
;
constexpr
auto
AllOverflowTypes
(
)
{
return
mozilla
:
:
MakeInclusiveEnumeratedRange
(
OverflowType
:
:
Ink
OverflowType
:
:
Scrollable
)
;
}
struct
OverflowAreas
{
public
:
nsRect
&
InkOverflow
(
)
{
return
mInk
;
}
const
nsRect
&
InkOverflow
(
)
const
{
return
mInk
;
}
nsRect
&
ScrollableOverflow
(
)
{
return
mScrollable
;
}
const
nsRect
&
ScrollableOverflow
(
)
const
{
return
mScrollable
;
}
nsRect
&
Overflow
(
OverflowType
aType
)
{
return
aType
=
=
OverflowType
:
:
Ink
?
InkOverflow
(
)
:
ScrollableOverflow
(
)
;
}
const
nsRect
&
Overflow
(
OverflowType
aType
)
const
{
return
aType
=
=
OverflowType
:
:
Ink
?
InkOverflow
(
)
:
ScrollableOverflow
(
)
;
}
OverflowAreas
(
)
=
default
;
OverflowAreas
(
const
nsRect
&
aInkOverflow
const
nsRect
&
aScrollableOverflow
)
:
mInk
(
aInkOverflow
)
mScrollable
(
aScrollableOverflow
)
{
}
bool
operator
=
=
(
const
OverflowAreas
&
aOther
)
const
{
return
InkOverflow
(
)
.
IsEqualInterior
(
aOther
.
InkOverflow
(
)
)
&
&
ScrollableOverflow
(
)
.
IsEqualEdges
(
aOther
.
ScrollableOverflow
(
)
)
;
}
bool
operator
!
=
(
const
OverflowAreas
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
OverflowAreas
operator
+
(
const
nsPoint
&
aPoint
)
const
{
OverflowAreas
result
(
*
this
)
;
result
+
=
aPoint
;
return
result
;
}
OverflowAreas
&
operator
+
=
(
const
nsPoint
&
aPoint
)
{
mInk
+
=
aPoint
;
mScrollable
+
=
aPoint
;
return
*
this
;
}
void
Clear
(
)
{
SetAllTo
(
nsRect
(
)
)
;
}
void
UnionWith
(
const
OverflowAreas
&
aOther
)
;
void
UnionAllWith
(
const
nsRect
&
aRect
)
;
void
SetAllTo
(
const
nsRect
&
aRect
)
;
void
ApplyClipping
(
const
nsRect
&
aBounds
PhysicalAxes
aClipAxes
const
nsSize
&
aOverflowMargin
)
{
ApplyOverflowClippingOnRect
(
InkOverflow
(
)
aBounds
aClipAxes
aOverflowMargin
)
;
ApplyOverflowClippingOnRect
(
ScrollableOverflow
(
)
aBounds
aClipAxes
aOverflowMargin
)
;
}
static
nsRect
GetOverflowClipRect
(
const
nsRect
&
aRectToClip
const
nsRect
&
aBounds
PhysicalAxes
aClipAxes
const
nsSize
&
aOverflowMargin
)
;
static
void
ApplyOverflowClippingOnRect
(
nsRect
&
aOverflowRect
const
nsRect
&
aBounds
PhysicalAxes
aClipAxes
const
nsSize
&
aOverflowMargin
)
;
private
:
nsRect
mInk
;
nsRect
mScrollable
;
}
;
}
struct
nsCollapsingMargin
{
private
:
nscoord
mMostPos
;
nscoord
mMostNeg
;
public
:
nsCollapsingMargin
(
)
:
mMostPos
(
0
)
mMostNeg
(
0
)
{
}
nsCollapsingMargin
(
const
nsCollapsingMargin
&
aOther
)
=
default
;
bool
operator
=
=
(
const
nsCollapsingMargin
&
aOther
)
const
{
return
mMostPos
=
=
aOther
.
mMostPos
&
&
mMostNeg
=
=
aOther
.
mMostNeg
;
}
bool
operator
!
=
(
const
nsCollapsingMargin
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
nsCollapsingMargin
&
operator
=
(
const
nsCollapsingMargin
&
aOther
)
=
default
;
void
Include
(
nscoord
aCoord
)
{
if
(
aCoord
>
mMostPos
)
mMostPos
=
aCoord
;
else
if
(
aCoord
<
mMostNeg
)
mMostNeg
=
aCoord
;
}
void
Include
(
const
nsCollapsingMargin
&
aOther
)
{
if
(
aOther
.
mMostPos
>
mMostPos
)
mMostPos
=
aOther
.
mMostPos
;
if
(
aOther
.
mMostNeg
<
mMostNeg
)
mMostNeg
=
aOther
.
mMostNeg
;
}
void
Zero
(
)
{
mMostPos
=
0
;
mMostNeg
=
0
;
}
bool
IsZero
(
)
const
{
return
(
mMostPos
=
=
0
)
&
&
(
mMostNeg
=
=
0
)
;
}
nscoord
get
(
)
const
{
return
mMostPos
+
mMostNeg
;
}
}
;
namespace
mozilla
{
class
ReflowOutput
{
public
:
explicit
ReflowOutput
(
mozilla
:
:
WritingMode
aWritingMode
)
:
mSize
(
aWritingMode
)
mWritingMode
(
aWritingMode
)
{
}
explicit
ReflowOutput
(
const
ReflowInput
&
aReflowInput
)
;
nscoord
ISize
(
mozilla
:
:
WritingMode
aWritingMode
)
const
{
return
mSize
.
ISize
(
aWritingMode
)
;
}
nscoord
BSize
(
mozilla
:
:
WritingMode
aWritingMode
)
const
{
return
mSize
.
BSize
(
aWritingMode
)
;
}
mozilla
:
:
LogicalSize
Size
(
mozilla
:
:
WritingMode
aWritingMode
)
const
{
return
mSize
.
ConvertTo
(
aWritingMode
mWritingMode
)
;
}
nscoord
&
ISize
(
mozilla
:
:
WritingMode
aWritingMode
)
{
return
mSize
.
ISize
(
aWritingMode
)
;
}
nscoord
&
BSize
(
mozilla
:
:
WritingMode
aWritingMode
)
{
return
mSize
.
BSize
(
aWritingMode
)
;
}
void
SetSize
(
mozilla
:
:
WritingMode
aWM
mozilla
:
:
LogicalSize
aSize
)
{
mSize
=
aSize
.
ConvertTo
(
mWritingMode
aWM
)
;
}
void
ClearSize
(
)
{
mSize
.
SizeTo
(
mWritingMode
0
0
)
;
}
nscoord
Width
(
)
const
{
return
mSize
.
Width
(
mWritingMode
)
;
}
nscoord
Height
(
)
const
{
return
mSize
.
Height
(
mWritingMode
)
;
}
nscoord
&
Width
(
)
{
return
mWritingMode
.
IsVertical
(
)
?
mSize
.
BSize
(
mWritingMode
)
:
mSize
.
ISize
(
mWritingMode
)
;
}
nscoord
&
Height
(
)
{
return
mWritingMode
.
IsVertical
(
)
?
mSize
.
ISize
(
mWritingMode
)
:
mSize
.
BSize
(
mWritingMode
)
;
}
nsSize
PhysicalSize
(
)
const
{
return
mSize
.
GetPhysicalSize
(
mWritingMode
)
;
}
enum
{
ASK_FOR_BASELINE
=
nscoord_MAX
}
;
nscoord
BlockStartAscent
(
)
const
{
return
mBlockStartAscent
;
}
void
SetBlockStartAscent
(
nscoord
aAscent
)
{
mBlockStartAscent
=
aAscent
;
}
nsBoundingMetrics
mBoundingMetrics
;
nsCollapsingMargin
mCarriedOutBEndMargin
;
OverflowAreas
mOverflowAreas
;
nsRect
&
InkOverflow
(
)
{
return
mOverflowAreas
.
InkOverflow
(
)
;
}
const
nsRect
&
InkOverflow
(
)
const
{
return
mOverflowAreas
.
InkOverflow
(
)
;
}
nsRect
&
ScrollableOverflow
(
)
{
return
mOverflowAreas
.
ScrollableOverflow
(
)
;
}
const
nsRect
&
ScrollableOverflow
(
)
const
{
return
mOverflowAreas
.
ScrollableOverflow
(
)
;
}
void
SetOverflowAreasToDesiredBounds
(
)
;
void
UnionOverflowAreasWithDesiredBounds
(
)
;
mozilla
:
:
WritingMode
GetWritingMode
(
)
const
{
return
mWritingMode
;
}
private
:
LogicalSize
mSize
;
nscoord
mBlockStartAscent
=
ASK_FOR_BASELINE
;
mozilla
:
:
WritingMode
mWritingMode
;
}
;
}
#
endif
