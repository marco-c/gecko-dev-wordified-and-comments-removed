#
ifndef
mozilla_CSSOrderAwareFrameIterator_h
#
define
mozilla_CSSOrderAwareFrameIterator_h
#
include
<
algorithm
>
#
include
"
nsFrameList
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
if
defined
(
__clang__
)
&
&
__clang_major__
=
=
3
&
&
__clang_minor__
<
=
9
#
define
CLANG_CRASH_BUG
1
#
endif
namespace
mozilla
{
template
<
typename
Iterator
>
class
CSSOrderAwareFrameIteratorT
{
public
:
enum
OrderState
{
eUnknownOrder
eKnownOrdered
eKnownUnordered
}
;
enum
ChildFilter
{
eSkipPlaceholders
eIncludeAll
}
;
enum
OrderingProperty
{
eUseOrder
eUseBoxOrdinalGroup
}
;
CSSOrderAwareFrameIteratorT
(
nsIFrame
*
aContainer
nsIFrame
:
:
ChildListID
aListID
ChildFilter
aFilter
=
eSkipPlaceholders
OrderState
aState
=
eUnknownOrder
OrderingProperty
aOrderProp
=
eUseOrder
)
:
mChildren
(
aContainer
-
>
GetChildList
(
aListID
)
)
mArrayIndex
(
0
)
mItemIndex
(
0
)
mSkipPlaceholders
(
aFilter
=
=
eSkipPlaceholders
)
#
ifdef
DEBUG
mContainer
(
aContainer
)
mListID
(
aListID
)
#
endif
{
MOZ_ASSERT
(
aContainer
-
>
IsFlexOrGridContainer
(
)
"
Only
use
this
iterator
in
a
container
that
honors
'
order
'
"
)
;
size_t
count
=
0
;
bool
isOrdered
=
aState
!
=
eKnownUnordered
;
if
(
aState
=
=
eUnknownOrder
)
{
auto
maxOrder
=
std
:
:
numeric_limits
<
int32_t
>
:
:
min
(
)
;
for
(
auto
child
:
mChildren
)
{
+
+
count
;
int32_t
order
;
if
(
aOrderProp
=
=
eUseBoxOrdinalGroup
)
{
uint32_t
clampedBoxOrdinal
=
std
:
:
min
(
child
-
>
StyleXUL
(
)
-
>
mBoxOrdinal
static_cast
<
uint32_t
>
(
INT32_MAX
)
)
;
order
=
static_cast
<
int32_t
>
(
clampedBoxOrdinal
)
;
}
else
{
order
=
child
-
>
StylePosition
(
)
-
>
mOrder
;
}
if
(
order
<
maxOrder
)
{
isOrdered
=
false
;
break
;
}
maxOrder
=
order
;
}
}
if
(
isOrdered
)
{
mIter
.
emplace
(
begin
(
mChildren
)
)
;
mIterEnd
.
emplace
(
end
(
mChildren
)
)
;
}
else
{
count
*
=
2
;
mArray
.
emplace
(
count
)
;
for
(
Iterator
i
(
begin
(
mChildren
)
)
iEnd
(
end
(
mChildren
)
)
;
i
!
=
iEnd
;
+
+
i
)
{
mArray
-
>
AppendElement
(
*
i
)
;
}
auto
comparator
=
(
aOrderProp
=
=
eUseBoxOrdinalGroup
)
?
CSSBoxOrdinalGroupComparator
:
CSSOrderComparator
;
std
:
:
stable_sort
(
mArray
-
>
begin
(
)
mArray
-
>
end
(
)
comparator
)
;
}
if
(
mSkipPlaceholders
)
{
SkipPlaceholders
(
)
;
}
}
~
CSSOrderAwareFrameIteratorT
(
)
{
MOZ_ASSERT
(
IsForward
(
)
=
=
mItemCount
.
isNothing
(
)
)
;
}
bool
IsForward
(
)
const
;
Iterator
begin
(
const
nsFrameList
&
aList
)
;
Iterator
end
(
const
nsFrameList
&
aList
)
;
nsIFrame
*
operator
*
(
)
const
{
MOZ_ASSERT
(
!
AtEnd
(
)
)
;
if
(
mIter
.
isSome
(
)
)
{
return
*
*
mIter
;
}
return
(
*
mArray
)
[
mArrayIndex
]
;
}
size_t
ItemIndex
(
)
const
{
MOZ_ASSERT
(
!
AtEnd
(
)
)
;
MOZ_ASSERT
(
!
(
*
*
this
)
-
>
IsPlaceholderFrame
(
)
"
MUST
not
call
this
when
at
a
placeholder
"
)
;
MOZ_ASSERT
(
IsForward
(
)
|
|
mItemIndex
<
*
mItemCount
"
Returning
an
out
-
of
-
range
mItemIndex
.
.
.
"
)
;
return
mItemIndex
;
}
void
SetItemCount
(
size_t
aItemCount
)
{
#
ifndef
CLANG_CRASH_BUG
MOZ_ASSERT
(
mIter
.
isSome
(
)
|
|
aItemCount
<
=
mArray
-
>
Length
(
)
"
item
count
mismatch
"
)
;
#
endif
mItemCount
.
emplace
(
aItemCount
)
;
mItemIndex
=
IsForward
(
)
?
0
:
*
mItemCount
-
1
;
}
void
SkipPlaceholders
(
)
{
if
(
mIter
.
isSome
(
)
)
{
for
(
;
*
mIter
!
=
*
mIterEnd
;
+
+
*
mIter
)
{
nsIFrame
*
child
=
*
*
mIter
;
if
(
!
child
-
>
IsPlaceholderFrame
(
)
)
{
return
;
}
}
}
else
{
for
(
;
mArrayIndex
<
mArray
-
>
Length
(
)
;
+
+
mArrayIndex
)
{
nsIFrame
*
child
=
(
*
mArray
)
[
mArrayIndex
]
;
if
(
!
child
-
>
IsPlaceholderFrame
(
)
)
{
return
;
}
}
}
}
bool
AtEnd
(
)
const
{
#
ifndef
CLANG_CRASH_BUG
MOZ_ASSERT
(
mIter
.
isSome
(
)
|
|
mArrayIndex
<
=
mArray
-
>
Length
(
)
)
;
#
endif
return
mIter
?
(
*
mIter
=
=
*
mIterEnd
)
:
mArrayIndex
>
=
mArray
-
>
Length
(
)
;
}
void
Next
(
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
!
AtEnd
(
)
)
;
nsFrameList
list
=
mContainer
-
>
GetChildList
(
mListID
)
;
MOZ_ASSERT
(
list
.
FirstChild
(
)
=
=
mChildren
.
FirstChild
(
)
&
&
list
.
LastChild
(
)
=
=
mChildren
.
LastChild
(
)
"
the
list
of
child
frames
must
not
change
while
iterating
!
"
)
;
#
endif
if
(
mSkipPlaceholders
|
|
!
(
*
*
this
)
-
>
IsPlaceholderFrame
(
)
)
{
IsForward
(
)
?
+
+
mItemIndex
:
-
-
mItemIndex
;
}
if
(
mIter
.
isSome
(
)
)
{
+
+
*
mIter
;
}
else
{
+
+
mArrayIndex
;
}
if
(
mSkipPlaceholders
)
{
SkipPlaceholders
(
)
;
}
}
void
Reset
(
ChildFilter
aFilter
=
eSkipPlaceholders
)
{
if
(
mIter
.
isSome
(
)
)
{
mIter
.
reset
(
)
;
mIter
.
emplace
(
begin
(
mChildren
)
)
;
mIterEnd
.
reset
(
)
;
mIterEnd
.
emplace
(
end
(
mChildren
)
)
;
}
else
{
mArrayIndex
=
0
;
}
mItemIndex
=
IsForward
(
)
?
0
:
*
mItemCount
-
1
;
mSkipPlaceholders
=
aFilter
=
=
eSkipPlaceholders
;
if
(
mSkipPlaceholders
)
{
SkipPlaceholders
(
)
;
}
}
bool
IsValid
(
)
const
{
return
mIter
.
isSome
(
)
|
|
mArray
.
isSome
(
)
;
}
void
Invalidate
(
)
{
mIter
.
reset
(
)
;
mArray
.
reset
(
)
;
mozWritePoison
(
&
mChildren
sizeof
(
mChildren
)
)
;
}
bool
ItemsAreAlreadyInOrder
(
)
const
{
return
mIter
.
isSome
(
)
;
}
static
bool
CSSOrderComparator
(
nsIFrame
*
const
&
a
nsIFrame
*
const
&
b
)
;
static
bool
CSSBoxOrdinalGroupComparator
(
nsIFrame
*
const
&
a
nsIFrame
*
const
&
b
)
;
private
:
nsFrameList
mChildren
;
Maybe
<
Iterator
>
mIter
;
Maybe
<
Iterator
>
mIterEnd
;
Maybe
<
nsTArray
<
nsIFrame
*
>
>
mArray
;
size_t
mArrayIndex
;
size_t
mItemIndex
;
Maybe
<
size_t
>
mItemCount
;
bool
mSkipPlaceholders
;
#
ifdef
DEBUG
nsIFrame
*
mContainer
;
nsIFrame
:
:
ChildListID
mListID
;
#
endif
}
;
typedef
CSSOrderAwareFrameIteratorT
<
nsFrameList
:
:
iterator
>
CSSOrderAwareFrameIterator
;
typedef
CSSOrderAwareFrameIteratorT
<
nsFrameList
:
:
reverse_iterator
>
ReverseCSSOrderAwareFrameIterator
;
}
#
endif
