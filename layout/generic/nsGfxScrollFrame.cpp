#
include
"
nsGfxScrollFrame
.
h
"
#
include
"
ActiveLayerTracker
.
h
"
#
include
"
base
/
compiler_specific
.
h
"
#
include
"
DisplayItemClip
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIContentViewer
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsView
.
h
"
#
include
"
nsViewportInfo
.
h
"
#
include
"
nsIScrollable
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
include
"
nsFontMetrics
.
h
"
#
include
"
nsBoxLayoutState
.
h
"
#
include
"
mozilla
/
dom
/
NodeInfo
.
h
"
#
include
"
nsScrollbarFrame
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsIScrollbarMediator
.
h
"
#
include
"
nsITextControlFrame
.
h
"
#
include
"
nsNodeInfoManager
.
h
"
#
include
"
nsContentCreatorFunctions
.
h
"
#
include
"
mozilla
/
PresState
.
h
"
#
include
"
nsIHTMLDocument
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsBidiPresUtils
.
h
"
#
include
"
nsBidiUtils
.
h
"
#
include
"
mozilla
/
ContentEvents
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
HTMLTextAreaElement
.
h
"
#
include
<
stdint
.
h
>
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
FrameLayerBuilder
.
h
"
#
include
"
nsSubDocumentFrame
.
h
"
#
include
"
nsSVGOuterSVGFrame
.
h
"
#
include
"
nsIObjectLoadingContent
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
ScrollbarActivity
.
h
"
#
include
"
nsRefreshDriver
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsSVGIntegrationUtils
.
h
"
#
include
"
nsIScrollPositionListener
.
h
"
#
include
"
StickyScrollContainer
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsILayoutHistoryState
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
ScrollAnimationPhysics
.
h
"
#
include
"
ScrollAnimationBezierPhysics
.
h
"
#
include
"
ScrollAnimationMSDPhysics
.
h
"
#
include
"
ScrollSnap
.
h
"
#
include
"
UnitTransforms
.
h
"
#
include
"
nsPluginFrame
.
h
"
#
include
"
nsSliderFrame
.
h
"
#
include
"
mozilla
/
layers
/
APZCCallbackHelper
.
h
"
#
include
"
mozilla
/
layers
/
AxisPhysicsModel
.
h
"
#
include
"
mozilla
/
layers
/
AxisPhysicsMSDModel
.
h
"
#
include
"
mozilla
/
layers
/
LayerTransactionChild
.
h
"
#
include
"
mozilla
/
layers
/
ScrollLinkedEffectDetector
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
VisualViewport
.
h
"
#
include
"
LayersLogging
.
h
"
#
include
<
algorithm
>
#
include
<
cstdlib
>
#
include
<
cmath
>
#
define
PAINT_SKIP_LOG
(
.
.
.
)
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
layout
;
static
uint32_t
GetOverflowChange
(
const
nsRect
&
aCurScrolledRect
const
nsRect
&
aPrevScrolledRect
)
{
uint32_t
result
=
0
;
if
(
aPrevScrolledRect
.
x
!
=
aCurScrolledRect
.
x
|
|
aPrevScrolledRect
.
width
!
=
aCurScrolledRect
.
width
)
{
result
|
=
nsIScrollableFrame
:
:
HORIZONTAL
;
}
if
(
aPrevScrolledRect
.
y
!
=
aCurScrolledRect
.
y
|
|
aPrevScrolledRect
.
height
!
=
aCurScrolledRect
.
height
)
{
result
|
=
nsIScrollableFrame
:
:
VERTICAL
;
}
return
result
;
}
nsHTMLScrollFrame
*
NS_NewHTMLScrollFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
bool
aIsRoot
)
{
return
new
(
aPresShell
)
nsHTMLScrollFrame
(
aStyle
aIsRoot
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsHTMLScrollFrame
)
nsHTMLScrollFrame
:
:
nsHTMLScrollFrame
(
ComputedStyle
*
aStyle
nsIFrame
:
:
ClassID
aID
bool
aIsRoot
)
:
nsContainerFrame
(
aStyle
aID
)
mHelper
(
ALLOW_THIS_IN_INITIALIZER_LIST
(
this
)
aIsRoot
)
{
}
void
nsHTMLScrollFrame
:
:
ScrollbarActivityStarted
(
)
const
{
if
(
mHelper
.
mScrollbarActivity
)
{
mHelper
.
mScrollbarActivity
-
>
ActivityStarted
(
)
;
}
}
void
nsHTMLScrollFrame
:
:
ScrollbarActivityStopped
(
)
const
{
if
(
mHelper
.
mScrollbarActivity
)
{
mHelper
.
mScrollbarActivity
-
>
ActivityStopped
(
)
;
}
}
nsresult
nsHTMLScrollFrame
:
:
CreateAnonymousContent
(
nsTArray
<
ContentInfo
>
&
aElements
)
{
return
mHelper
.
CreateAnonymousContent
(
aElements
)
;
}
void
nsHTMLScrollFrame
:
:
AppendAnonymousContentTo
(
nsTArray
<
nsIContent
*
>
&
aElements
uint32_t
aFilter
)
{
mHelper
.
AppendAnonymousContentTo
(
aElements
aFilter
)
;
}
void
nsHTMLScrollFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
{
DestroyAbsoluteFrames
(
aDestructRoot
aPostDestroyData
)
;
mHelper
.
Destroy
(
aPostDestroyData
)
;
nsContainerFrame
:
:
DestroyFrom
(
aDestructRoot
aPostDestroyData
)
;
}
void
nsHTMLScrollFrame
:
:
SetInitialChildList
(
ChildListID
aListID
nsFrameList
&
aChildList
)
{
nsContainerFrame
:
:
SetInitialChildList
(
aListID
aChildList
)
;
mHelper
.
ReloadChildFrames
(
)
;
}
void
nsHTMLScrollFrame
:
:
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
{
NS_ASSERTION
(
aListID
=
=
kPrincipalList
"
Only
main
list
supported
"
)
;
mFrames
.
AppendFrames
(
nullptr
aFrameList
)
;
mHelper
.
ReloadChildFrames
(
)
;
}
void
nsHTMLScrollFrame
:
:
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
aFrameList
)
{
NS_ASSERTION
(
aListID
=
=
kPrincipalList
"
Only
main
list
supported
"
)
;
NS_ASSERTION
(
!
aPrevFrame
|
|
aPrevFrame
-
>
GetParent
(
)
=
=
this
"
inserting
after
sibling
frame
with
different
parent
"
)
;
mFrames
.
InsertFrames
(
nullptr
aPrevFrame
aFrameList
)
;
mHelper
.
ReloadChildFrames
(
)
;
}
void
nsHTMLScrollFrame
:
:
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
{
NS_ASSERTION
(
aListID
=
=
kPrincipalList
"
Only
main
list
supported
"
)
;
mFrames
.
DestroyFrame
(
aOldFrame
)
;
mHelper
.
ReloadChildFrames
(
)
;
}
namespace
mozilla
{
enum
class
ShowScrollbar
:
uint8_t
{
Auto
Always
Never
}
;
static
ShowScrollbar
ShouldShowScrollbar
(
StyleOverflow
aOverflow
)
{
switch
(
aOverflow
)
{
case
StyleOverflow
:
:
Scroll
:
return
ShowScrollbar
:
:
Always
;
case
StyleOverflow
:
:
Hidden
:
return
ShowScrollbar
:
:
Never
;
default
:
case
StyleOverflow
:
:
Auto
:
return
ShowScrollbar
:
:
Auto
;
}
}
struct
MOZ_STACK_CLASS
ScrollReflowInput
{
const
ReflowInput
&
mReflowInput
;
nsBoxLayoutState
mBoxState
;
ShowScrollbar
mHScrollbar
;
ShowScrollbar
mVScrollbar
;
nsMargin
mComputedBorder
;
nsOverflowAreas
mContentsOverflowAreas
;
MOZ_INIT_OUTSIDE_CTOR
bool
mReflowedContentsWithHScrollbar
;
MOZ_INIT_OUTSIDE_CTOR
bool
mReflowedContentsWithVScrollbar
;
nsSize
mInsideBorderSize
;
MOZ_INIT_OUTSIDE_CTOR
bool
mShowHScrollbar
;
MOZ_INIT_OUTSIDE_CTOR
bool
mShowVScrollbar
;
ScrollReflowInput
(
nsIScrollableFrame
*
aFrame
const
ReflowInput
&
aReflowInput
)
:
mReflowInput
(
aReflowInput
)
mBoxState
(
aReflowInput
.
mFrame
-
>
PresContext
(
)
aReflowInput
.
mRenderingContext
)
{
ScrollStyles
styles
=
aFrame
-
>
GetScrollStyles
(
)
;
mHScrollbar
=
ShouldShowScrollbar
(
styles
.
mHorizontal
)
;
mVScrollbar
=
ShouldShowScrollbar
(
styles
.
mVertical
)
;
}
}
;
}
static
nsSize
ComputeInsideBorderSize
(
ScrollReflowInput
*
aState
const
nsSize
&
aDesiredInsideBorderSize
)
{
nscoord
contentWidth
=
aState
-
>
mReflowInput
.
ComputedWidth
(
)
;
if
(
contentWidth
=
=
NS_UNCONSTRAINEDSIZE
)
{
contentWidth
=
aDesiredInsideBorderSize
.
width
-
aState
-
>
mReflowInput
.
ComputedPhysicalPadding
(
)
.
LeftRight
(
)
;
}
nscoord
contentHeight
=
aState
-
>
mReflowInput
.
ComputedHeight
(
)
;
if
(
contentHeight
=
=
NS_UNCONSTRAINEDSIZE
)
{
contentHeight
=
aDesiredInsideBorderSize
.
height
-
aState
-
>
mReflowInput
.
ComputedPhysicalPadding
(
)
.
TopBottom
(
)
;
}
contentWidth
=
aState
-
>
mReflowInput
.
ApplyMinMaxWidth
(
contentWidth
)
;
contentHeight
=
aState
-
>
mReflowInput
.
ApplyMinMaxHeight
(
contentHeight
)
;
return
nsSize
(
contentWidth
+
aState
-
>
mReflowInput
.
ComputedPhysicalPadding
(
)
.
LeftRight
(
)
contentHeight
+
aState
-
>
mReflowInput
.
ComputedPhysicalPadding
(
)
.
TopBottom
(
)
)
;
}
static
void
GetScrollbarMetrics
(
nsBoxLayoutState
&
aState
nsIFrame
*
aBox
nsSize
*
aMin
nsSize
*
aPref
)
{
NS_ASSERTION
(
aState
.
GetRenderingContext
(
)
"
Must
have
rendering
context
in
layout
state
for
size
"
"
computations
"
)
;
if
(
aMin
)
{
*
aMin
=
aBox
-
>
GetXULMinSize
(
aState
)
;
nsBox
:
:
AddMargin
(
aBox
*
aMin
)
;
if
(
aMin
-
>
width
<
0
)
{
aMin
-
>
width
=
0
;
}
if
(
aMin
-
>
height
<
0
)
{
aMin
-
>
height
=
0
;
}
}
if
(
aPref
)
{
*
aPref
=
aBox
-
>
GetXULPrefSize
(
aState
)
;
nsBox
:
:
AddMargin
(
aBox
*
aPref
)
;
if
(
aPref
-
>
width
<
0
)
{
aPref
-
>
width
=
0
;
}
if
(
aPref
-
>
height
<
0
)
{
aPref
-
>
height
=
0
;
}
}
}
bool
nsHTMLScrollFrame
:
:
TryLayout
(
ScrollReflowInput
*
aState
ReflowOutput
*
aKidMetrics
bool
aAssumeHScroll
bool
aAssumeVScroll
bool
aForce
)
{
if
(
(
aState
-
>
mVScrollbar
=
=
ShowScrollbar
:
:
Never
&
&
aAssumeVScroll
)
|
|
(
aState
-
>
mHScrollbar
=
=
ShowScrollbar
:
:
Never
&
&
aAssumeHScroll
)
)
{
NS_ASSERTION
(
!
aForce
"
Shouldn
'
t
be
forcing
a
hidden
scrollbar
to
show
!
"
)
;
return
false
;
}
if
(
aAssumeVScroll
!
=
aState
-
>
mReflowedContentsWithVScrollbar
|
|
(
aAssumeHScroll
!
=
aState
-
>
mReflowedContentsWithHScrollbar
&
&
ScrolledContentDependsOnHeight
(
aState
)
)
)
{
if
(
aAssumeHScroll
!
=
aState
-
>
mReflowedContentsWithHScrollbar
)
{
nsLayoutUtils
:
:
MarkIntrinsicISizesDirtyIfDependentOnBSize
(
mHelper
.
mScrolledFrame
)
;
}
aKidMetrics
-
>
mOverflowAreas
.
Clear
(
)
;
ReflowScrolledFrame
(
aState
aAssumeHScroll
aAssumeVScroll
aKidMetrics
)
;
}
nsSize
vScrollbarMinSize
(
0
0
)
;
nsSize
vScrollbarPrefSize
(
0
0
)
;
if
(
mHelper
.
mVScrollbarBox
)
{
GetScrollbarMetrics
(
aState
-
>
mBoxState
mHelper
.
mVScrollbarBox
&
vScrollbarMinSize
aAssumeVScroll
?
&
vScrollbarPrefSize
:
nullptr
)
;
nsScrollbarFrame
*
scrollbar
=
do_QueryFrame
(
mHelper
.
mVScrollbarBox
)
;
scrollbar
-
>
SetScrollbarMediatorContent
(
mContent
)
;
}
nscoord
vScrollbarDesiredWidth
=
aAssumeVScroll
?
vScrollbarPrefSize
.
width
:
0
;
nscoord
vScrollbarMinHeight
=
aAssumeVScroll
?
vScrollbarMinSize
.
height
:
0
;
nsSize
hScrollbarMinSize
(
0
0
)
;
nsSize
hScrollbarPrefSize
(
0
0
)
;
if
(
mHelper
.
mHScrollbarBox
)
{
GetScrollbarMetrics
(
aState
-
>
mBoxState
mHelper
.
mHScrollbarBox
&
hScrollbarMinSize
aAssumeHScroll
?
&
hScrollbarPrefSize
:
nullptr
)
;
nsScrollbarFrame
*
scrollbar
=
do_QueryFrame
(
mHelper
.
mHScrollbarBox
)
;
scrollbar
-
>
SetScrollbarMediatorContent
(
mContent
)
;
}
nscoord
hScrollbarDesiredHeight
=
aAssumeHScroll
?
hScrollbarPrefSize
.
height
:
0
;
nscoord
hScrollbarMinWidth
=
aAssumeHScroll
?
hScrollbarMinSize
.
width
:
0
;
nsSize
desiredInsideBorderSize
;
desiredInsideBorderSize
.
width
=
vScrollbarDesiredWidth
+
std
:
:
max
(
aKidMetrics
-
>
Width
(
)
hScrollbarMinWidth
)
;
desiredInsideBorderSize
.
height
=
hScrollbarDesiredHeight
+
std
:
:
max
(
aKidMetrics
-
>
Height
(
)
vScrollbarMinHeight
)
;
aState
-
>
mInsideBorderSize
=
ComputeInsideBorderSize
(
aState
desiredInsideBorderSize
)
;
nsSize
layoutSize
=
mHelper
.
mIsUsingMinimumScaleSize
?
mHelper
.
mMinimumScaleSize
:
aState
-
>
mInsideBorderSize
;
nsSize
scrollPortSize
=
nsSize
(
std
:
:
max
(
0
layoutSize
.
width
-
vScrollbarDesiredWidth
)
std
:
:
max
(
0
layoutSize
.
height
-
hScrollbarDesiredHeight
)
)
;
nsSize
visualViewportSize
=
scrollPortSize
;
nsIPresShell
*
presShell
=
PresShell
(
)
;
if
(
mHelper
.
mIsRoot
&
&
presShell
-
>
IsVisualViewportSizeSet
(
)
)
{
nsSize
compositionSize
=
nsLayoutUtils
:
:
CalculateCompositionSizeForFrame
(
this
false
)
;
float
resolution
=
presShell
-
>
GetResolution
(
)
;
compositionSize
.
width
/
=
resolution
;
compositionSize
.
height
/
=
resolution
;
visualViewportSize
=
nsSize
(
std
:
:
max
(
0
compositionSize
.
width
-
vScrollbarDesiredWidth
)
std
:
:
max
(
0
compositionSize
.
height
-
hScrollbarDesiredHeight
)
)
;
}
nsRect
scrolledRect
=
mHelper
.
GetUnsnappedScrolledRectInternal
(
aState
-
>
mContentsOverflowAreas
.
ScrollableOverflow
(
)
scrollPortSize
)
;
nscoord
oneDevPixel
=
aState
-
>
mBoxState
.
PresContext
(
)
-
>
DevPixelsToAppUnits
(
1
)
;
if
(
!
aForce
)
{
if
(
aState
-
>
mHScrollbar
!
=
ShowScrollbar
:
:
Never
)
{
bool
wantHScrollbar
=
aState
-
>
mHScrollbar
=
=
ShowScrollbar
:
:
Always
|
|
scrolledRect
.
XMost
(
)
>
=
visualViewportSize
.
width
+
oneDevPixel
|
|
scrolledRect
.
x
<
=
-
oneDevPixel
;
if
(
scrollPortSize
.
width
<
hScrollbarMinSize
.
width
)
wantHScrollbar
=
false
;
if
(
wantHScrollbar
!
=
aAssumeHScroll
)
return
false
;
}
if
(
aState
-
>
mVScrollbar
!
=
ShowScrollbar
:
:
Never
)
{
bool
wantVScrollbar
=
aState
-
>
mVScrollbar
=
=
ShowScrollbar
:
:
Always
|
|
scrolledRect
.
YMost
(
)
>
=
visualViewportSize
.
height
+
oneDevPixel
|
|
scrolledRect
.
y
<
=
-
oneDevPixel
;
if
(
scrollPortSize
.
height
<
vScrollbarMinSize
.
height
)
wantVScrollbar
=
false
;
if
(
wantVScrollbar
!
=
aAssumeVScroll
)
return
false
;
}
}
do
{
if
(
!
mHelper
.
mIsRoot
)
{
break
;
}
nscoord
scrolledWidth
=
scrolledRect
.
width
+
oneDevPixel
;
if
(
scrolledWidth
<
=
scrollPortSize
.
width
)
{
break
;
}
nsPresContext
*
pc
=
PresContext
(
)
;
ScrollStyles
styles
=
pc
-
>
GetViewportScrollStylesOverride
(
)
;
if
(
styles
.
mHorizontal
!
=
StyleOverflow
:
:
Hidden
)
{
break
;
}
Document
*
doc
=
pc
-
>
Document
(
)
;
if
(
!
doc
-
>
IsTopLevelContentDocument
(
)
)
{
break
;
}
doc
-
>
UpdateViewportOverflowType
(
scrolledWidth
scrollPortSize
.
width
)
;
}
while
(
false
)
;
aState
-
>
mShowHScrollbar
=
aAssumeHScroll
;
aState
-
>
mShowVScrollbar
=
aAssumeVScroll
;
nsPoint
scrollPortOrigin
(
aState
-
>
mComputedBorder
.
left
aState
-
>
mComputedBorder
.
top
)
;
if
(
!
IsScrollbarOnRight
(
)
)
{
nscoord
vScrollbarActualWidth
=
layoutSize
.
width
-
scrollPortSize
.
width
;
scrollPortOrigin
.
x
+
=
vScrollbarActualWidth
;
}
mHelper
.
mScrollPort
=
nsRect
(
scrollPortOrigin
scrollPortSize
)
;
return
true
;
}
bool
nsHTMLScrollFrame
:
:
ScrolledContentDependsOnHeight
(
ScrollReflowInput
*
aState
)
{
return
mHelper
.
mScrolledFrame
-
>
HasAnyStateBits
(
NS_FRAME_CONTAINS_RELATIVE_BSIZE
|
NS_FRAME_DESCENDANT_INTRINSIC_ISIZE_DEPENDS_ON_BSIZE
)
|
|
aState
-
>
mReflowInput
.
ComputedBSize
(
)
!
=
NS_UNCONSTRAINEDSIZE
|
|
aState
-
>
mReflowInput
.
ComputedMinBSize
(
)
>
0
|
|
aState
-
>
mReflowInput
.
ComputedMaxBSize
(
)
!
=
NS_UNCONSTRAINEDSIZE
;
}
void
nsHTMLScrollFrame
:
:
ReflowScrolledFrame
(
ScrollReflowInput
*
aState
bool
aAssumeHScroll
bool
aAssumeVScroll
ReflowOutput
*
aMetrics
)
{
WritingMode
wm
=
mHelper
.
mScrolledFrame
-
>
GetWritingMode
(
)
;
LogicalMargin
padding
=
aState
-
>
mReflowInput
.
ComputedLogicalPadding
(
)
;
nscoord
availISize
=
aState
-
>
mReflowInput
.
ComputedISize
(
)
+
padding
.
IStartEnd
(
wm
)
;
nscoord
computedBSize
=
aState
-
>
mReflowInput
.
ComputedBSize
(
)
;
nscoord
computedMinBSize
=
aState
-
>
mReflowInput
.
ComputedMinBSize
(
)
;
nscoord
computedMaxBSize
=
aState
-
>
mReflowInput
.
ComputedMaxBSize
(
)
;
if
(
!
ShouldPropagateComputedBSizeToScrolledContent
(
)
)
{
computedBSize
=
NS_UNCONSTRAINEDSIZE
;
computedMinBSize
=
0
;
computedMaxBSize
=
NS_UNCONSTRAINEDSIZE
;
}
if
(
wm
.
IsVertical
(
)
)
{
if
(
aAssumeVScroll
)
{
nsSize
vScrollbarPrefSize
;
GetScrollbarMetrics
(
aState
-
>
mBoxState
mHelper
.
mVScrollbarBox
nullptr
&
vScrollbarPrefSize
)
;
if
(
computedBSize
!
=
NS_UNCONSTRAINEDSIZE
)
{
computedBSize
=
std
:
:
max
(
0
computedBSize
-
vScrollbarPrefSize
.
width
)
;
}
computedMinBSize
=
std
:
:
max
(
0
computedMinBSize
-
vScrollbarPrefSize
.
width
)
;
if
(
computedMaxBSize
!
=
NS_UNCONSTRAINEDSIZE
)
{
computedMaxBSize
=
std
:
:
max
(
0
computedMaxBSize
-
vScrollbarPrefSize
.
width
)
;
}
}
if
(
aAssumeHScroll
)
{
nsSize
hScrollbarPrefSize
;
GetScrollbarMetrics
(
aState
-
>
mBoxState
mHelper
.
mHScrollbarBox
nullptr
&
hScrollbarPrefSize
)
;
availISize
=
std
:
:
max
(
0
availISize
-
hScrollbarPrefSize
.
height
)
;
}
}
else
{
if
(
aAssumeHScroll
)
{
nsSize
hScrollbarPrefSize
;
GetScrollbarMetrics
(
aState
-
>
mBoxState
mHelper
.
mHScrollbarBox
nullptr
&
hScrollbarPrefSize
)
;
if
(
computedBSize
!
=
NS_UNCONSTRAINEDSIZE
)
{
computedBSize
=
std
:
:
max
(
0
computedBSize
-
hScrollbarPrefSize
.
height
)
;
}
computedMinBSize
=
std
:
:
max
(
0
computedMinBSize
-
hScrollbarPrefSize
.
height
)
;
if
(
computedMaxBSize
!
=
NS_UNCONSTRAINEDSIZE
)
{
computedMaxBSize
=
std
:
:
max
(
0
computedMaxBSize
-
hScrollbarPrefSize
.
height
)
;
}
}
if
(
aAssumeVScroll
)
{
nsSize
vScrollbarPrefSize
;
GetScrollbarMetrics
(
aState
-
>
mBoxState
mHelper
.
mVScrollbarBox
nullptr
&
vScrollbarPrefSize
)
;
availISize
=
std
:
:
max
(
0
availISize
-
vScrollbarPrefSize
.
width
)
;
}
}
nsPresContext
*
presContext
=
PresContext
(
)
;
ReflowInput
kidReflowInput
(
presContext
aState
-
>
mReflowInput
mHelper
.
mScrolledFrame
LogicalSize
(
wm
availISize
NS_UNCONSTRAINEDSIZE
)
nullptr
ReflowInput
:
:
CALLER_WILL_INIT
)
;
const
nsMargin
physicalPadding
=
padding
.
GetPhysicalMargin
(
wm
)
;
kidReflowInput
.
Init
(
presContext
nullptr
nullptr
&
physicalPadding
)
;
kidReflowInput
.
mFlags
.
mAssumingHScrollbar
=
aAssumeHScroll
;
kidReflowInput
.
mFlags
.
mAssumingVScrollbar
=
aAssumeVScroll
;
kidReflowInput
.
SetComputedBSize
(
computedBSize
)
;
kidReflowInput
.
ComputedMinBSize
(
)
=
computedMinBSize
;
kidReflowInput
.
ComputedMaxBSize
(
)
=
computedMaxBSize
;
if
(
aState
-
>
mReflowInput
.
IsBResizeForWM
(
kidReflowInput
.
GetWritingMode
(
)
)
)
{
kidReflowInput
.
SetBResize
(
true
)
;
}
bool
didHaveHorizontalScrollbar
=
mHelper
.
mHasHorizontalScrollbar
;
bool
didHaveVerticalScrollbar
=
mHelper
.
mHasVerticalScrollbar
;
mHelper
.
mHasHorizontalScrollbar
=
aAssumeHScroll
;
mHelper
.
mHasVerticalScrollbar
=
aAssumeVScroll
;
nsReflowStatus
status
;
const
nsSize
dummyContainerSize
;
ReflowChild
(
mHelper
.
mScrolledFrame
presContext
*
aMetrics
kidReflowInput
wm
LogicalPoint
(
wm
)
dummyContainerSize
NS_FRAME_NO_MOVE_FRAME
status
)
;
mHelper
.
mHasHorizontalScrollbar
=
didHaveHorizontalScrollbar
;
mHelper
.
mHasVerticalScrollbar
=
didHaveVerticalScrollbar
;
FinishReflowChild
(
mHelper
.
mScrolledFrame
presContext
*
aMetrics
&
kidReflowInput
wm
LogicalPoint
(
wm
)
dummyContainerSize
NS_FRAME_NO_MOVE_FRAME
|
NS_FRAME_NO_SIZE_VIEW
)
;
aMetrics
-
>
UnionOverflowAreasWithDesiredBounds
(
)
;
auto
*
disp
=
StyleDisplay
(
)
;
if
(
MOZ_UNLIKELY
(
disp
-
>
mOverflowClipBoxBlock
=
=
StyleOverflowClipBox
:
:
ContentBox
|
|
disp
-
>
mOverflowClipBoxInline
=
=
StyleOverflowClipBox
:
:
ContentBox
)
)
{
nsOverflowAreas
childOverflow
;
nsLayoutUtils
:
:
UnionChildOverflow
(
mHelper
.
mScrolledFrame
childOverflow
)
;
nsRect
childScrollableOverflow
=
childOverflow
.
ScrollableOverflow
(
)
;
if
(
disp
-
>
mOverflowClipBoxBlock
=
=
StyleOverflowClipBox
:
:
PaddingBox
)
{
padding
.
BStart
(
wm
)
=
nscoord
(
0
)
;
padding
.
BEnd
(
wm
)
=
nscoord
(
0
)
;
}
if
(
disp
-
>
mOverflowClipBoxInline
=
=
StyleOverflowClipBox
:
:
PaddingBox
)
{
padding
.
IStart
(
wm
)
=
nscoord
(
0
)
;
padding
.
IEnd
(
wm
)
=
nscoord
(
0
)
;
}
childScrollableOverflow
.
Inflate
(
padding
.
GetPhysicalMargin
(
wm
)
)
;
nsRect
contentArea
=
wm
.
IsVertical
(
)
?
nsRect
(
0
0
computedBSize
availISize
)
:
nsRect
(
0
0
availISize
computedBSize
)
;
if
(
!
contentArea
.
Contains
(
childScrollableOverflow
)
)
{
aMetrics
-
>
mOverflowAreas
.
ScrollableOverflow
(
)
=
childScrollableOverflow
;
}
}
aState
-
>
mContentsOverflowAreas
=
aMetrics
-
>
mOverflowAreas
;
aState
-
>
mReflowedContentsWithHScrollbar
=
aAssumeHScroll
;
aState
-
>
mReflowedContentsWithVScrollbar
=
aAssumeVScroll
;
}
bool
nsHTMLScrollFrame
:
:
GuessHScrollbarNeeded
(
const
ScrollReflowInput
&
aState
)
{
if
(
aState
.
mHScrollbar
!
=
ShowScrollbar
:
:
Auto
)
{
return
aState
.
mHScrollbar
=
=
ShowScrollbar
:
:
Always
;
}
return
mHelper
.
mHasHorizontalScrollbar
;
}
bool
nsHTMLScrollFrame
:
:
GuessVScrollbarNeeded
(
const
ScrollReflowInput
&
aState
)
{
if
(
aState
.
mVScrollbar
!
=
ShowScrollbar
:
:
Auto
)
{
return
aState
.
mVScrollbar
=
=
ShowScrollbar
:
:
Always
;
}
if
(
mHelper
.
mHadNonInitialReflow
)
{
return
mHelper
.
mHasVerticalScrollbar
;
}
if
(
InInitialReflow
(
)
)
return
false
;
if
(
mHelper
.
mIsRoot
)
{
nsIFrame
*
f
=
mHelper
.
mScrolledFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
f
&
&
f
-
>
IsSVGOuterSVGFrame
(
)
&
&
static_cast
<
nsSVGOuterSVGFrame
*
>
(
f
)
-
>
VerticalScrollbarNotNeeded
(
)
)
{
return
false
;
}
return
true
;
}
return
false
;
}
bool
nsHTMLScrollFrame
:
:
InInitialReflow
(
)
const
{
return
!
mHelper
.
mIsRoot
&
&
(
GetStateBits
(
)
&
NS_FRAME_FIRST_REFLOW
)
;
}
void
nsHTMLScrollFrame
:
:
ReflowContents
(
ScrollReflowInput
*
aState
const
ReflowOutput
&
aDesiredSize
)
{
ReflowOutput
kidDesiredSize
(
aDesiredSize
.
GetWritingMode
(
)
)
;
ReflowScrolledFrame
(
aState
GuessHScrollbarNeeded
(
*
aState
)
GuessVScrollbarNeeded
(
*
aState
)
&
kidDesiredSize
)
;
if
(
(
aState
-
>
mReflowedContentsWithHScrollbar
|
|
aState
-
>
mReflowedContentsWithVScrollbar
)
&
&
aState
-
>
mVScrollbar
!
=
ShowScrollbar
:
:
Always
&
&
aState
-
>
mHScrollbar
!
=
ShowScrollbar
:
:
Always
)
{
nsSize
insideBorderSize
=
ComputeInsideBorderSize
(
aState
nsSize
(
kidDesiredSize
.
Width
(
)
kidDesiredSize
.
Height
(
)
)
)
;
nsRect
scrolledRect
=
mHelper
.
GetUnsnappedScrolledRectInternal
(
kidDesiredSize
.
ScrollableOverflow
(
)
insideBorderSize
)
;
if
(
nsRect
(
nsPoint
(
0
0
)
insideBorderSize
)
.
Contains
(
scrolledRect
)
)
{
kidDesiredSize
.
mOverflowAreas
.
Clear
(
)
;
ReflowScrolledFrame
(
aState
false
false
&
kidDesiredSize
)
;
}
}
if
(
IsRootScrollFrameOfDocument
(
)
)
{
mHelper
.
UpdateMinimumScaleSize
(
aState
-
>
mContentsOverflowAreas
.
ScrollableOverflow
(
)
kidDesiredSize
.
PhysicalSize
(
)
)
;
}
if
(
TryLayout
(
aState
&
kidDesiredSize
aState
-
>
mReflowedContentsWithHScrollbar
aState
-
>
mReflowedContentsWithVScrollbar
false
)
)
return
;
if
(
TryLayout
(
aState
&
kidDesiredSize
!
aState
-
>
mReflowedContentsWithHScrollbar
aState
-
>
mReflowedContentsWithVScrollbar
false
)
)
return
;
bool
newVScrollbarState
=
!
aState
-
>
mReflowedContentsWithVScrollbar
;
if
(
TryLayout
(
aState
&
kidDesiredSize
false
newVScrollbarState
false
)
)
return
;
if
(
TryLayout
(
aState
&
kidDesiredSize
true
newVScrollbarState
false
)
)
return
;
TryLayout
(
aState
&
kidDesiredSize
aState
-
>
mHScrollbar
!
=
ShowScrollbar
:
:
Never
aState
-
>
mVScrollbar
!
=
ShowScrollbar
:
:
Never
true
)
;
}
void
nsHTMLScrollFrame
:
:
PlaceScrollArea
(
ScrollReflowInput
&
aState
const
nsPoint
&
aScrollPosition
)
{
nsIFrame
*
scrolledFrame
=
mHelper
.
mScrolledFrame
;
scrolledFrame
-
>
SetPosition
(
mHelper
.
mScrollPort
.
TopLeft
(
)
-
aScrollPosition
)
;
AdjustForPerspective
(
aState
.
mContentsOverflowAreas
.
ScrollableOverflow
(
)
)
;
nsRect
scrolledArea
;
nsSize
portSize
=
mHelper
.
mScrollPort
.
Size
(
)
;
nsRect
scrolledRect
=
mHelper
.
GetUnsnappedScrolledRectInternal
(
aState
.
mContentsOverflowAreas
.
ScrollableOverflow
(
)
portSize
)
;
scrolledArea
.
UnionRectEdges
(
scrolledRect
nsRect
(
nsPoint
(
0
0
)
portSize
)
)
;
nsOverflowAreas
overflow
(
scrolledArea
scrolledArea
)
;
scrolledFrame
-
>
FinishAndStoreOverflow
(
overflow
scrolledFrame
-
>
GetSize
(
)
)
;
nsContainerFrame
:
:
SyncFrameViewAfterReflow
(
scrolledFrame
-
>
PresContext
(
)
scrolledFrame
scrolledFrame
-
>
GetView
(
)
scrolledArea
0
)
;
}
nscoord
nsHTMLScrollFrame
:
:
GetIntrinsicVScrollbarWidth
(
gfxContext
*
aRenderingContext
)
{
ScrollStyles
ss
=
GetScrollStyles
(
)
;
if
(
ss
.
mVertical
!
=
StyleOverflow
:
:
Scroll
|
|
!
mHelper
.
mVScrollbarBox
)
return
0
;
nsBoxLayoutState
bls
(
PresContext
(
)
aRenderingContext
0
)
;
nsSize
vScrollbarPrefSize
(
0
0
)
;
GetScrollbarMetrics
(
bls
mHelper
.
mVScrollbarBox
nullptr
&
vScrollbarPrefSize
)
;
return
vScrollbarPrefSize
.
width
;
}
nscoord
nsHTMLScrollFrame
:
:
GetMinISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
result
=
mHelper
.
mScrolledFrame
-
>
GetMinISize
(
aRenderingContext
)
;
DISPLAY_MIN_INLINE_SIZE
(
this
result
)
;
return
result
+
GetIntrinsicVScrollbarWidth
(
aRenderingContext
)
;
}
nscoord
nsHTMLScrollFrame
:
:
GetPrefISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
result
=
mHelper
.
mScrolledFrame
-
>
GetPrefISize
(
aRenderingContext
)
;
DISPLAY_PREF_INLINE_SIZE
(
this
result
)
;
return
NSCoordSaturatingAdd
(
result
GetIntrinsicVScrollbarWidth
(
aRenderingContext
)
)
;
}
nsresult
nsHTMLScrollFrame
:
:
GetXULPadding
(
nsMargin
&
aMargin
)
{
aMargin
.
SizeTo
(
0
0
0
0
)
;
return
NS_OK
;
}
bool
nsHTMLScrollFrame
:
:
IsXULCollapsed
(
)
{
return
false
;
}
static
Element
*
GetBrowserRoot
(
nsIContent
*
aContent
)
{
if
(
aContent
)
{
Document
*
doc
=
aContent
-
>
GetUncomposedDoc
(
)
;
if
(
nsPIDOMWindowOuter
*
win
=
doc
-
>
GetWindow
(
)
)
{
Element
*
frameElement
=
win
-
>
GetFrameElementInternal
(
)
;
if
(
frameElement
&
&
frameElement
-
>
NodeInfo
(
)
-
>
Equals
(
nsGkAtoms
:
:
browser
kNameSpaceID_XUL
)
)
return
frameElement
;
}
}
return
nullptr
;
}
static
void
GetScrollableOverflowForPerspective
(
nsIFrame
*
aScrolledFrame
nsIFrame
*
aCurrentFrame
const
nsRect
aScrollPort
nsPoint
aOffset
nsRect
&
aScrolledFrameOverflowArea
)
{
FrameChildListIDs
skip
=
{
nsIFrame
:
:
kSelectPopupList
nsIFrame
:
:
kPopupList
}
;
for
(
nsIFrame
:
:
ChildListIterator
childLists
(
aCurrentFrame
)
;
!
childLists
.
IsDone
(
)
;
childLists
.
Next
(
)
)
{
if
(
skip
.
contains
(
childLists
.
CurrentID
(
)
)
)
{
continue
;
}
for
(
nsIFrame
*
child
:
childLists
.
CurrentList
(
)
)
{
nsPoint
offset
=
aOffset
;
if
(
aScrolledFrame
=
=
aCurrentFrame
)
{
offset
=
child
-
>
GetPosition
(
)
;
}
if
(
child
-
>
Extend3DContext
(
)
)
{
GetScrollableOverflowForPerspective
(
aScrolledFrame
child
aScrollPort
offset
aScrolledFrameOverflowArea
)
;
}
if
(
child
-
>
IsTransformed
(
)
)
{
nsPoint
scrollPos
=
aScrolledFrame
-
>
GetPosition
(
)
;
nsRect
preScroll
=
nsDisplayTransform
:
:
TransformRect
(
child
-
>
GetScrollableOverflowRectRelativeToSelf
(
)
child
)
;
aScrolledFrame
-
>
SetPosition
(
scrollPos
+
nsPoint
(
600
600
)
)
;
nsRect
postScroll
=
nsDisplayTransform
:
:
TransformRect
(
child
-
>
GetScrollableOverflowRectRelativeToSelf
(
)
child
)
;
aScrolledFrame
-
>
SetPosition
(
scrollPos
)
;
double
rightDelta
=
(
postScroll
.
XMost
(
)
-
preScroll
.
XMost
(
)
+
600
.
0
)
/
600
.
0
;
double
bottomDelta
=
(
postScroll
.
YMost
(
)
-
preScroll
.
YMost
(
)
+
600
.
0
)
/
600
.
0
;
NS_ASSERTION
(
rightDelta
>
0
.
0f
&
&
bottomDelta
>
0
.
0f
"
Scrolling
can
'
t
be
reversed
!
"
)
;
preScroll
+
=
offset
+
scrollPos
;
nsMargin
overhang
(
std
:
:
max
(
0
aScrollPort
.
Y
(
)
-
preScroll
.
Y
(
)
)
std
:
:
max
(
0
preScroll
.
XMost
(
)
-
aScrollPort
.
XMost
(
)
)
std
:
:
max
(
0
preScroll
.
YMost
(
)
-
aScrollPort
.
YMost
(
)
)
std
:
:
max
(
0
aScrollPort
.
X
(
)
-
preScroll
.
X
(
)
)
)
;
overhang
.
top
/
=
bottomDelta
;
overhang
.
right
/
=
rightDelta
;
overhang
.
bottom
/
=
bottomDelta
;
overhang
.
left
/
=
rightDelta
;
nsRect
overflow
=
aScrollPort
-
scrollPos
;
overflow
.
Inflate
(
overhang
)
;
aScrolledFrameOverflowArea
.
UnionRect
(
aScrolledFrameOverflowArea
overflow
)
;
}
else
if
(
aCurrentFrame
=
=
aScrolledFrame
)
{
aScrolledFrameOverflowArea
.
UnionRect
(
aScrolledFrameOverflowArea
child
-
>
GetScrollableOverflowRectRelativeToParent
(
)
)
;
}
}
}
}
void
nsHTMLScrollFrame
:
:
AdjustForPerspective
(
nsRect
&
aScrollableOverflow
)
{
if
(
!
ChildrenHavePerspective
(
)
)
{
return
;
}
aScrollableOverflow
.
SetEmpty
(
)
;
GetScrollableOverflowForPerspective
(
mHelper
.
mScrolledFrame
mHelper
.
mScrolledFrame
mHelper
.
mScrollPort
nsPoint
(
)
aScrollableOverflow
)
;
}
void
nsHTMLScrollFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsHTMLScrollFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aDesiredSize
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
mHelper
.
HandleScrollbarStyleSwitching
(
)
;
ScrollReflowInput
state
(
this
aReflowInput
)
;
if
(
!
mHelper
.
mVScrollbarBox
|
|
mHelper
.
mNeverHasVerticalScrollbar
)
{
state
.
mVScrollbar
=
ShowScrollbar
:
:
Never
;
}
if
(
!
mHelper
.
mHScrollbarBox
|
|
mHelper
.
mNeverHasHorizontalScrollbar
)
{
state
.
mHScrollbar
=
ShowScrollbar
:
:
Never
;
}
bool
reflowHScrollbar
=
true
;
bool
reflowVScrollbar
=
true
;
bool
reflowScrollCorner
=
true
;
if
(
!
aReflowInput
.
ShouldReflowAllKids
(
)
)
{
#
define
NEEDS_REFLOW
(
frame_
)
(
(
frame_
)
&
&
NS_SUBTREE_DIRTY
(
frame_
)
)
reflowHScrollbar
=
NEEDS_REFLOW
(
mHelper
.
mHScrollbarBox
)
;
reflowVScrollbar
=
NEEDS_REFLOW
(
mHelper
.
mVScrollbarBox
)
;
reflowScrollCorner
=
NEEDS_REFLOW
(
mHelper
.
mScrollCornerBox
)
|
|
NEEDS_REFLOW
(
mHelper
.
mResizerBox
)
;
#
undef
NEEDS_REFLOW
}
if
(
mHelper
.
mIsRoot
)
{
mHelper
.
mCollapsedResizer
=
true
;
Element
*
browserRoot
=
GetBrowserRoot
(
mContent
)
;
if
(
browserRoot
)
{
bool
showResizer
=
browserRoot
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
showresizer
)
;
reflowScrollCorner
=
showResizer
=
=
mHelper
.
mCollapsedResizer
;
mHelper
.
mCollapsedResizer
=
!
showResizer
;
}
ComputedStyle
*
scrollbarStyle
=
nsLayoutUtils
:
:
StyleForScrollbar
(
this
)
;
auto
scrollbarWidth
=
scrollbarStyle
-
>
StyleUIReset
(
)
-
>
mScrollbarWidth
;
if
(
scrollbarWidth
=
=
StyleScrollbarWidth
:
:
None
)
{
state
.
mVScrollbar
=
ShowScrollbar
:
:
Never
;
state
.
mHScrollbar
=
ShowScrollbar
:
:
Never
;
}
}
nsRect
oldScrollAreaBounds
=
mHelper
.
mScrollPort
;
nsRect
oldScrolledAreaBounds
=
mHelper
.
mScrolledFrame
-
>
GetScrollableOverflowRectRelativeToParent
(
)
;
nsPoint
oldScrollPosition
=
mHelper
.
GetScrollPosition
(
)
;
state
.
mComputedBorder
=
aReflowInput
.
ComputedPhysicalBorderPadding
(
)
-
aReflowInput
.
ComputedPhysicalPadding
(
)
;
ReflowContents
(
&
state
aDesiredSize
)
;
nsSize
layoutSize
=
mHelper
.
mIsUsingMinimumScaleSize
?
mHelper
.
mMinimumScaleSize
:
state
.
mInsideBorderSize
;
aDesiredSize
.
Width
(
)
=
layoutSize
.
width
+
state
.
mComputedBorder
.
LeftRight
(
)
;
aDesiredSize
.
Height
(
)
=
layoutSize
.
height
+
state
.
mComputedBorder
.
TopBottom
(
)
;
SetSize
(
aDesiredSize
.
GetWritingMode
(
)
aDesiredSize
.
Size
(
aDesiredSize
.
GetWritingMode
(
)
)
)
;
PlaceScrollArea
(
state
oldScrollPosition
)
;
if
(
!
mHelper
.
mPostedReflowCallback
)
{
PresShell
(
)
-
>
PostReflowCallback
(
&
mHelper
)
;
mHelper
.
mPostedReflowCallback
=
true
;
}
bool
didHaveHScrollbar
=
mHelper
.
mHasHorizontalScrollbar
;
bool
didHaveVScrollbar
=
mHelper
.
mHasVerticalScrollbar
;
mHelper
.
mHasHorizontalScrollbar
=
state
.
mShowHScrollbar
;
mHelper
.
mHasVerticalScrollbar
=
state
.
mShowVScrollbar
;
nsRect
newScrollAreaBounds
=
mHelper
.
mScrollPort
;
nsRect
newScrolledAreaBounds
=
mHelper
.
mScrolledFrame
-
>
GetScrollableOverflowRectRelativeToParent
(
)
;
if
(
mHelper
.
mSkippedScrollbarLayout
|
|
reflowHScrollbar
|
|
reflowVScrollbar
|
|
reflowScrollCorner
|
|
(
GetStateBits
(
)
&
NS_FRAME_IS_DIRTY
)
|
|
didHaveHScrollbar
!
=
state
.
mShowHScrollbar
|
|
didHaveVScrollbar
!
=
state
.
mShowVScrollbar
|
|
!
oldScrollAreaBounds
.
IsEqualEdges
(
newScrollAreaBounds
)
|
|
!
oldScrolledAreaBounds
.
IsEqualEdges
(
newScrolledAreaBounds
)
)
{
if
(
!
mHelper
.
mSuppressScrollbarUpdate
)
{
mHelper
.
mSkippedScrollbarLayout
=
false
;
ScrollFrameHelper
:
:
SetScrollbarVisibility
(
mHelper
.
mHScrollbarBox
state
.
mShowHScrollbar
)
;
ScrollFrameHelper
:
:
SetScrollbarVisibility
(
mHelper
.
mVScrollbarBox
state
.
mShowVScrollbar
)
;
nsRect
insideBorderArea
=
nsRect
(
nsPoint
(
state
.
mComputedBorder
.
left
state
.
mComputedBorder
.
top
)
layoutSize
)
;
mHelper
.
LayoutScrollbars
(
state
.
mBoxState
insideBorderArea
oldScrollAreaBounds
)
;
}
else
{
mHelper
.
mSkippedScrollbarLayout
=
true
;
}
}
aDesiredSize
.
SetOverflowAreasToDesiredBounds
(
)
;
mHelper
.
UpdateSticky
(
)
;
FinishReflowWithAbsoluteFrames
(
aPresContext
aDesiredSize
aReflowInput
aStatus
)
;
if
(
!
InInitialReflow
(
)
&
&
!
mHelper
.
mHadNonInitialReflow
)
{
mHelper
.
mHadNonInitialReflow
=
true
;
}
if
(
mHelper
.
mIsRoot
&
&
!
oldScrolledAreaBounds
.
IsEqualEdges
(
newScrolledAreaBounds
)
)
{
mHelper
.
PostScrolledAreaEvent
(
)
;
}
mHelper
.
UpdatePrevScrolledRect
(
)
;
aStatus
.
Reset
(
)
;
NS_FRAME_SET_TRUNCATION
(
aStatus
aReflowInput
aDesiredSize
)
;
mHelper
.
PostOverflowEvent
(
)
;
}
void
nsHTMLScrollFrame
:
:
DidReflow
(
nsPresContext
*
aPresContext
const
ReflowInput
*
aReflowInput
)
{
nsContainerFrame
:
:
DidReflow
(
aPresContext
aReflowInput
)
;
PresShell
(
)
-
>
PostPendingScrollAnchorAdjustment
(
GetAnchor
(
)
)
;
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
nsHTMLScrollFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
NS_LITERAL_STRING
(
"
HTMLScroll
"
)
aResult
)
;
}
#
endif
#
ifdef
ACCESSIBILITY
a11y
:
:
AccType
nsHTMLScrollFrame
:
:
AccessibleType
(
)
{
if
(
IsTableCaption
(
)
)
{
return
GetRect
(
)
.
IsEmpty
(
)
?
a11y
:
:
eNoType
:
a11y
:
:
eHTMLCaptionType
;
}
if
(
mContent
-
>
IsRootOfNativeAnonymousSubtree
(
)
|
|
GetScrollStyles
(
)
.
IsHiddenInBothDirections
(
)
)
{
return
a11y
:
:
eNoType
;
}
return
a11y
:
:
eHyperTextType
;
}
#
endif
NS_QUERYFRAME_HEAD
(
nsHTMLScrollFrame
)
NS_QUERYFRAME_ENTRY
(
nsIAnonymousContentCreator
)
NS_QUERYFRAME_ENTRY
(
nsIScrollableFrame
)
NS_QUERYFRAME_ENTRY
(
nsIStatefulFrame
)
NS_QUERYFRAME_ENTRY
(
nsIScrollbarMediator
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsContainerFrame
)
nsXULScrollFrame
*
NS_NewXULScrollFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
bool
aIsRoot
bool
aClipAllDescendants
)
{
return
new
(
aPresShell
)
nsXULScrollFrame
(
aStyle
aIsRoot
aClipAllDescendants
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsXULScrollFrame
)
nsXULScrollFrame
:
:
nsXULScrollFrame
(
ComputedStyle
*
aStyle
bool
aIsRoot
bool
aClipAllDescendants
)
:
nsBoxFrame
(
aStyle
kClassID
aIsRoot
)
mHelper
(
ALLOW_THIS_IN_INITIALIZER_LIST
(
this
)
aIsRoot
)
{
SetXULLayoutManager
(
nullptr
)
;
mHelper
.
mClipAllDescendants
=
aClipAllDescendants
;
}
void
nsXULScrollFrame
:
:
ScrollbarActivityStarted
(
)
const
{
if
(
mHelper
.
mScrollbarActivity
)
{
mHelper
.
mScrollbarActivity
-
>
ActivityStarted
(
)
;
}
}
void
nsXULScrollFrame
:
:
ScrollbarActivityStopped
(
)
const
{
if
(
mHelper
.
mScrollbarActivity
)
{
mHelper
.
mScrollbarActivity
-
>
ActivityStopped
(
)
;
}
}
nsMargin
ScrollFrameHelper
:
:
GetDesiredScrollbarSizes
(
nsBoxLayoutState
*
aState
)
{
NS_ASSERTION
(
aState
&
&
aState
-
>
GetRenderingContext
(
)
"
Must
have
rendering
context
in
layout
state
for
size
"
"
computations
"
)
;
nsMargin
result
(
0
0
0
0
)
;
if
(
mVScrollbarBox
)
{
nsSize
size
=
mVScrollbarBox
-
>
GetXULPrefSize
(
*
aState
)
;
nsBox
:
:
AddMargin
(
mVScrollbarBox
size
)
;
if
(
IsScrollbarOnRight
(
)
)
result
.
left
=
size
.
width
;
else
result
.
right
=
size
.
width
;
}
if
(
mHScrollbarBox
)
{
nsSize
size
=
mHScrollbarBox
-
>
GetXULPrefSize
(
*
aState
)
;
nsBox
:
:
AddMargin
(
mHScrollbarBox
size
)
;
result
.
bottom
=
size
.
height
;
}
return
result
;
}
nscoord
ScrollFrameHelper
:
:
GetNondisappearingScrollbarWidth
(
nsBoxLayoutState
*
aState
WritingMode
aWM
)
{
NS_ASSERTION
(
aState
&
&
aState
-
>
GetRenderingContext
(
)
"
Must
have
rendering
context
in
layout
state
for
size
"
"
computations
"
)
;
bool
verticalWM
=
aWM
.
IsVertical
(
)
;
if
(
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
eIntID_UseOverlayScrollbars
)
!
=
0
)
{
nsITheme
*
theme
=
aState
-
>
PresContext
(
)
-
>
GetTheme
(
)
;
if
(
theme
&
&
theme
-
>
ThemeSupportsWidget
(
aState
-
>
PresContext
(
)
verticalWM
?
mHScrollbarBox
:
mVScrollbarBox
StyleAppearance
:
:
ScrollbarNonDisappearing
)
)
{
LayoutDeviceIntSize
size
;
bool
canOverride
=
true
;
theme
-
>
GetMinimumWidgetSize
(
aState
-
>
PresContext
(
)
verticalWM
?
mHScrollbarBox
:
mVScrollbarBox
StyleAppearance
:
:
ScrollbarNonDisappearing
&
size
&
canOverride
)
;
return
aState
-
>
PresContext
(
)
-
>
DevPixelsToAppUnits
(
verticalWM
?
size
.
height
:
size
.
width
)
;
}
}
nsMargin
sizes
(
GetDesiredScrollbarSizes
(
aState
)
)
;
return
verticalWM
?
sizes
.
TopBottom
(
)
:
sizes
.
LeftRight
(
)
;
}
void
ScrollFrameHelper
:
:
HandleScrollbarStyleSwitching
(
)
{
if
(
mScrollbarActivity
&
&
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
eIntID_UseOverlayScrollbars
)
=
=
0
)
{
mScrollbarActivity
-
>
Destroy
(
)
;
mScrollbarActivity
=
nullptr
;
mOuter
-
>
PresContext
(
)
-
>
ThemeChanged
(
)
;
}
else
if
(
!
mScrollbarActivity
&
&
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
eIntID_UseOverlayScrollbars
)
!
=
0
)
{
mScrollbarActivity
=
new
ScrollbarActivity
(
do_QueryFrame
(
mOuter
)
)
;
mOuter
-
>
PresContext
(
)
-
>
ThemeChanged
(
)
;
}
}
#
if
defined
(
MOZ_WIDGET_ANDROID
)
static
bool
IsFocused
(
nsIContent
*
aContent
)
{
while
(
aContent
&
&
aContent
-
>
IsInAnonymousSubtree
(
)
)
{
aContent
=
aContent
-
>
GetParent
(
)
;
}
return
aContent
?
nsContentUtils
:
:
IsFocusedContent
(
aContent
)
:
false
;
}
#
endif
void
ScrollFrameHelper
:
:
SetScrollableByAPZ
(
bool
aScrollable
)
{
mScrollableByAPZ
=
aScrollable
;
}
void
ScrollFrameHelper
:
:
SetZoomableByAPZ
(
bool
aZoomable
)
{
if
(
mZoomableByAPZ
!
=
aZoomable
)
{
mZoomableByAPZ
=
aZoomable
;
mOuter
-
>
SchedulePaint
(
)
;
}
}
void
ScrollFrameHelper
:
:
SetHasOutOfFlowContentInsideFilter
(
)
{
mHasOutOfFlowContentInsideFilter
=
true
;
}
bool
ScrollFrameHelper
:
:
WantAsyncScroll
(
)
const
{
if
(
mZoomableByAPZ
)
{
return
true
;
}
ScrollStyles
styles
=
GetScrollStylesFromFrame
(
)
;
nscoord
oneDevPixel
=
GetScrolledFrame
(
)
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
nsRect
scrollRange
=
GetScrollRange
(
)
;
if
(
!
GetScrollRangeForClamping
(
)
.
IsEqualInterior
(
scrollRange
)
)
{
return
true
;
}
bool
isVScrollable
=
(
scrollRange
.
height
>
=
oneDevPixel
)
&
&
(
styles
.
mVertical
!
=
StyleOverflow
:
:
Hidden
)
;
bool
isHScrollable
=
(
scrollRange
.
width
>
=
oneDevPixel
)
&
&
(
styles
.
mHorizontal
!
=
StyleOverflow
:
:
Hidden
)
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
bool
canScrollWithoutScrollbars
=
!
IsForTextControlWithNoScrollbars
(
)
|
|
IsFocused
(
mOuter
-
>
GetContent
(
)
)
;
#
else
bool
canScrollWithoutScrollbars
=
true
;
#
endif
bool
isVAsyncScrollable
=
isVScrollable
&
&
(
mVScrollbarBox
|
|
canScrollWithoutScrollbars
)
;
bool
isHAsyncScrollable
=
isHScrollable
&
&
(
mHScrollbarBox
|
|
canScrollWithoutScrollbars
)
;
return
isVAsyncScrollable
|
|
isHAsyncScrollable
;
}
static
nsRect
GetOnePixelRangeAroundPoint
(
const
nsPoint
&
aPoint
bool
aIsHorizontal
)
{
nsRect
allowedRange
(
aPoint
nsSize
(
)
)
;
nscoord
halfPixel
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
0
.
5f
)
;
if
(
aIsHorizontal
)
{
allowedRange
.
x
=
aPoint
.
x
-
halfPixel
;
allowedRange
.
width
=
halfPixel
*
2
-
1
;
}
else
{
allowedRange
.
y
=
aPoint
.
y
-
halfPixel
;
allowedRange
.
height
=
halfPixel
*
2
-
1
;
}
return
allowedRange
;
}
void
ScrollFrameHelper
:
:
ScrollByPage
(
nsScrollbarFrame
*
aScrollbar
int32_t
aDirection
nsIScrollbarMediator
:
:
ScrollSnapMode
aSnap
)
{
ScrollByUnit
(
aScrollbar
nsIScrollableFrame
:
:
SMOOTH
aDirection
nsIScrollableFrame
:
:
PAGES
aSnap
)
;
}
void
ScrollFrameHelper
:
:
ScrollByWhole
(
nsScrollbarFrame
*
aScrollbar
int32_t
aDirection
nsIScrollbarMediator
:
:
ScrollSnapMode
aSnap
)
{
ScrollByUnit
(
aScrollbar
nsIScrollableFrame
:
:
INSTANT
aDirection
nsIScrollableFrame
:
:
WHOLE
aSnap
)
;
}
void
ScrollFrameHelper
:
:
ScrollByLine
(
nsScrollbarFrame
*
aScrollbar
int32_t
aDirection
nsIScrollbarMediator
:
:
ScrollSnapMode
aSnap
)
{
bool
isHorizontal
=
aScrollbar
-
>
IsXULHorizontal
(
)
;
nsIntPoint
delta
;
if
(
isHorizontal
)
{
const
double
kScrollMultiplier
=
Preferences
:
:
GetInt
(
"
toolkit
.
scrollbox
.
horizontalScrollDistance
"
NS_DEFAULT_HORIZONTAL_SCROLL_DISTANCE
)
;
delta
.
x
=
aDirection
*
kScrollMultiplier
;
if
(
GetLineScrollAmount
(
)
.
width
*
delta
.
x
>
GetPageScrollAmount
(
)
.
width
)
{
ScrollByPage
(
aScrollbar
aDirection
)
;
return
;
}
}
else
{
const
double
kScrollMultiplier
=
Preferences
:
:
GetInt
(
"
toolkit
.
scrollbox
.
verticalScrollDistance
"
NS_DEFAULT_VERTICAL_SCROLL_DISTANCE
)
;
delta
.
y
=
aDirection
*
kScrollMultiplier
;
if
(
GetLineScrollAmount
(
)
.
height
*
delta
.
y
>
GetPageScrollAmount
(
)
.
height
)
{
ScrollByPage
(
aScrollbar
aDirection
)
;
return
;
}
}
nsIntPoint
overflow
;
ScrollBy
(
delta
nsIScrollableFrame
:
:
LINES
nsIScrollableFrame
:
:
SMOOTH
&
overflow
nsGkAtoms
:
:
other
nsIScrollableFrame
:
:
NOT_MOMENTUM
aSnap
)
;
}
void
ScrollFrameHelper
:
:
RepeatButtonScroll
(
nsScrollbarFrame
*
aScrollbar
)
{
aScrollbar
-
>
MoveToNewPosition
(
)
;
}
void
ScrollFrameHelper
:
:
ThumbMoved
(
nsScrollbarFrame
*
aScrollbar
nscoord
aOldPos
nscoord
aNewPos
)
{
MOZ_ASSERT
(
aScrollbar
!
=
nullptr
)
;
bool
isHorizontal
=
aScrollbar
-
>
IsXULHorizontal
(
)
;
nsPoint
current
=
GetScrollPosition
(
)
;
nsPoint
dest
=
current
;
if
(
isHorizontal
)
{
dest
.
x
=
IsPhysicalLTR
(
)
?
aNewPos
:
aNewPos
-
GetScrollRange
(
)
.
width
;
}
else
{
dest
.
y
=
aNewPos
;
}
nsRect
allowedRange
=
GetOnePixelRangeAroundPoint
(
dest
isHorizontal
)
;
if
(
allowedRange
.
ClampPoint
(
current
)
=
=
current
)
{
return
;
}
ScrollTo
(
dest
nsIScrollableFrame
:
:
INSTANT
nsGkAtoms
:
:
other
&
allowedRange
)
;
}
void
ScrollFrameHelper
:
:
ScrollbarReleased
(
nsScrollbarFrame
*
aScrollbar
)
{
mVelocityQueue
.
Reset
(
)
;
ScrollSnap
(
mDestination
nsIScrollableFrame
:
:
SMOOTH
)
;
}
void
ScrollFrameHelper
:
:
ScrollByUnit
(
nsScrollbarFrame
*
aScrollbar
nsIScrollableFrame
:
:
ScrollMode
aMode
int32_t
aDirection
nsIScrollableFrame
:
:
ScrollUnit
aUnit
nsIScrollbarMediator
:
:
ScrollSnapMode
aSnap
)
{
MOZ_ASSERT
(
aScrollbar
!
=
nullptr
)
;
bool
isHorizontal
=
aScrollbar
-
>
IsXULHorizontal
(
)
;
nsIntPoint
delta
;
if
(
isHorizontal
)
{
delta
.
x
=
aDirection
;
}
else
{
delta
.
y
=
aDirection
;
}
nsIntPoint
overflow
;
ScrollBy
(
delta
aUnit
aMode
&
overflow
nsGkAtoms
:
:
other
nsIScrollableFrame
:
:
NOT_MOMENTUM
aSnap
)
;
}
nsresult
nsXULScrollFrame
:
:
CreateAnonymousContent
(
nsTArray
<
ContentInfo
>
&
aElements
)
{
return
mHelper
.
CreateAnonymousContent
(
aElements
)
;
}
void
nsXULScrollFrame
:
:
AppendAnonymousContentTo
(
nsTArray
<
nsIContent
*
>
&
aElements
uint32_t
aFilter
)
{
mHelper
.
AppendAnonymousContentTo
(
aElements
aFilter
)
;
}
void
nsXULScrollFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
{
mHelper
.
Destroy
(
aPostDestroyData
)
;
nsBoxFrame
:
:
DestroyFrom
(
aDestructRoot
aPostDestroyData
)
;
}
void
nsXULScrollFrame
:
:
SetInitialChildList
(
ChildListID
aListID
nsFrameList
&
aChildList
)
{
nsBoxFrame
:
:
SetInitialChildList
(
aListID
aChildList
)
;
if
(
aListID
=
=
kPrincipalList
)
{
mHelper
.
ReloadChildFrames
(
)
;
}
}
void
nsXULScrollFrame
:
:
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
{
nsBoxFrame
:
:
AppendFrames
(
aListID
aFrameList
)
;
mHelper
.
ReloadChildFrames
(
)
;
}
void
nsXULScrollFrame
:
:
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
aFrameList
)
{
nsBoxFrame
:
:
InsertFrames
(
aListID
aPrevFrame
aFrameList
)
;
mHelper
.
ReloadChildFrames
(
)
;
}
void
nsXULScrollFrame
:
:
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
{
nsBoxFrame
:
:
RemoveFrame
(
aListID
aOldFrame
)
;
mHelper
.
ReloadChildFrames
(
)
;
}
nsresult
nsXULScrollFrame
:
:
GetXULPadding
(
nsMargin
&
aMargin
)
{
aMargin
.
SizeTo
(
0
0
0
0
)
;
return
NS_OK
;
}
nscoord
nsXULScrollFrame
:
:
GetXULBoxAscent
(
nsBoxLayoutState
&
aState
)
{
if
(
!
mHelper
.
mScrolledFrame
)
return
0
;
nscoord
ascent
=
mHelper
.
mScrolledFrame
-
>
GetXULBoxAscent
(
aState
)
;
nsMargin
m
(
0
0
0
0
)
;
GetXULBorderAndPadding
(
m
)
;
ascent
+
=
m
.
top
;
GetXULMargin
(
m
)
;
ascent
+
=
m
.
top
;
return
ascent
;
}
nsSize
nsXULScrollFrame
:
:
GetXULPrefSize
(
nsBoxLayoutState
&
aState
)
{
nsSize
pref
=
mHelper
.
mScrolledFrame
-
>
GetXULPrefSize
(
aState
)
;
ScrollStyles
styles
=
GetScrollStyles
(
)
;
if
(
mHelper
.
mVScrollbarBox
&
&
styles
.
mVertical
=
=
StyleOverflow
:
:
Scroll
)
{
nsSize
vSize
=
mHelper
.
mVScrollbarBox
-
>
GetXULPrefSize
(
aState
)
;
nsBox
:
:
AddMargin
(
mHelper
.
mVScrollbarBox
vSize
)
;
pref
.
width
+
=
vSize
.
width
;
}
if
(
mHelper
.
mHScrollbarBox
&
&
styles
.
mHorizontal
=
=
StyleOverflow
:
:
Scroll
)
{
nsSize
hSize
=
mHelper
.
mHScrollbarBox
-
>
GetXULPrefSize
(
aState
)
;
nsBox
:
:
AddMargin
(
mHelper
.
mHScrollbarBox
hSize
)
;
pref
.
height
+
=
hSize
.
height
;
}
AddBorderAndPadding
(
pref
)
;
bool
widthSet
heightSet
;
nsIFrame
:
:
AddXULPrefSize
(
this
pref
widthSet
heightSet
)
;
return
pref
;
}
nsSize
nsXULScrollFrame
:
:
GetXULMinSize
(
nsBoxLayoutState
&
aState
)
{
nsSize
min
=
mHelper
.
mScrolledFrame
-
>
GetXULMinSizeForScrollArea
(
aState
)
;
ScrollStyles
styles
=
GetScrollStyles
(
)
;
if
(
mHelper
.
mVScrollbarBox
&
&
styles
.
mVertical
=
=
StyleOverflow
:
:
Scroll
)
{
nsSize
vSize
=
mHelper
.
mVScrollbarBox
-
>
GetXULMinSize
(
aState
)
;
AddMargin
(
mHelper
.
mVScrollbarBox
vSize
)
;
min
.
width
+
=
vSize
.
width
;
if
(
min
.
height
<
vSize
.
height
)
min
.
height
=
vSize
.
height
;
}
if
(
mHelper
.
mHScrollbarBox
&
&
styles
.
mHorizontal
=
=
StyleOverflow
:
:
Scroll
)
{
nsSize
hSize
=
mHelper
.
mHScrollbarBox
-
>
GetXULMinSize
(
aState
)
;
AddMargin
(
mHelper
.
mHScrollbarBox
hSize
)
;
min
.
height
+
=
hSize
.
height
;
if
(
min
.
width
<
hSize
.
width
)
min
.
width
=
hSize
.
width
;
}
AddBorderAndPadding
(
min
)
;
bool
widthSet
heightSet
;
nsIFrame
:
:
AddXULMinSize
(
aState
this
min
widthSet
heightSet
)
;
return
min
;
}
nsSize
nsXULScrollFrame
:
:
GetXULMaxSize
(
nsBoxLayoutState
&
aState
)
{
nsSize
maxSize
(
NS_INTRINSICSIZE
NS_INTRINSICSIZE
)
;
AddBorderAndPadding
(
maxSize
)
;
bool
widthSet
heightSet
;
nsIFrame
:
:
AddXULMaxSize
(
this
maxSize
widthSet
heightSet
)
;
return
maxSize
;
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
nsXULScrollFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
NS_LITERAL_STRING
(
"
XULScroll
"
)
aResult
)
;
}
#
endif
NS_IMETHODIMP
nsXULScrollFrame
:
:
DoXULLayout
(
nsBoxLayoutState
&
aState
)
{
uint32_t
flags
=
aState
.
LayoutFlags
(
)
;
nsresult
rv
=
XULLayout
(
aState
)
;
aState
.
SetLayoutFlags
(
flags
)
;
nsBox
:
:
DoXULLayout
(
aState
)
;
return
rv
;
}
NS_QUERYFRAME_HEAD
(
nsXULScrollFrame
)
NS_QUERYFRAME_ENTRY
(
nsIAnonymousContentCreator
)
NS_QUERYFRAME_ENTRY
(
nsIScrollableFrame
)
NS_QUERYFRAME_ENTRY
(
nsIStatefulFrame
)
NS_QUERYFRAME_ENTRY
(
nsIScrollbarMediator
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsBoxFrame
)
#
define
SMOOTH_SCROLL_PREF_NAME
"
general
.
smoothScroll
"
class
ScrollFrameHelper
:
:
AsyncSmoothMSDScroll
final
:
public
nsARefreshObserver
{
public
:
AsyncSmoothMSDScroll
(
const
nsPoint
&
aInitialPosition
const
nsPoint
&
aInitialDestination
const
nsSize
&
aInitialVelocity
const
nsRect
&
aRange
const
mozilla
:
:
TimeStamp
&
aStartTime
nsPresContext
*
aPresContext
)
:
mXAxisModel
(
aInitialPosition
.
x
aInitialDestination
.
x
aInitialVelocity
.
width
gfxPrefs
:
:
ScrollBehaviorSpringConstant
(
)
gfxPrefs
:
:
ScrollBehaviorDampingRatio
(
)
)
mYAxisModel
(
aInitialPosition
.
y
aInitialDestination
.
y
aInitialVelocity
.
height
gfxPrefs
:
:
ScrollBehaviorSpringConstant
(
)
gfxPrefs
:
:
ScrollBehaviorDampingRatio
(
)
)
mRange
(
aRange
)
mLastRefreshTime
(
aStartTime
)
mCallee
(
nullptr
)
mOneDevicePixelInAppUnits
(
aPresContext
-
>
DevPixelsToAppUnits
(
1
)
)
{
Telemetry
:
:
SetHistogramRecordingEnabled
(
Telemetry
:
:
FX_REFRESH_DRIVER_SYNC_SCROLL_FRAME_DELAY_MS
true
)
;
}
NS_INLINE_DECL_REFCOUNTING
(
AsyncSmoothMSDScroll
override
)
nsSize
GetVelocity
(
)
{
return
nsSize
(
mXAxisModel
.
GetVelocity
(
)
mYAxisModel
.
GetVelocity
(
)
)
;
}
nsPoint
GetPosition
(
)
{
return
nsPoint
(
NSToCoordRound
(
mXAxisModel
.
GetPosition
(
)
)
NSToCoordRound
(
mYAxisModel
.
GetPosition
(
)
)
)
;
}
void
SetDestination
(
const
nsPoint
&
aDestination
)
{
mXAxisModel
.
SetDestination
(
static_cast
<
int32_t
>
(
aDestination
.
x
)
)
;
mYAxisModel
.
SetDestination
(
static_cast
<
int32_t
>
(
aDestination
.
y
)
)
;
}
void
SetRange
(
const
nsRect
&
aRange
)
{
mRange
=
aRange
;
}
nsRect
GetRange
(
)
{
return
mRange
;
}
void
Simulate
(
const
TimeDuration
&
aDeltaTime
)
{
mXAxisModel
.
Simulate
(
aDeltaTime
)
;
mYAxisModel
.
Simulate
(
aDeltaTime
)
;
nsPoint
desired
=
GetPosition
(
)
;
nsPoint
clamped
=
mRange
.
ClampPoint
(
desired
)
;
if
(
desired
.
x
!
=
clamped
.
x
)
{
mXAxisModel
.
SetVelocity
(
0
.
0
)
;
mXAxisModel
.
SetPosition
(
clamped
.
x
)
;
}
if
(
desired
.
y
!
=
clamped
.
y
)
{
mYAxisModel
.
SetVelocity
(
0
.
0
)
;
mYAxisModel
.
SetPosition
(
clamped
.
y
)
;
}
}
bool
IsFinished
(
)
{
return
mXAxisModel
.
IsFinished
(
mOneDevicePixelInAppUnits
)
&
&
mYAxisModel
.
IsFinished
(
mOneDevicePixelInAppUnits
)
;
}
virtual
void
WillRefresh
(
mozilla
:
:
TimeStamp
aTime
)
override
{
mozilla
:
:
TimeDuration
deltaTime
=
aTime
-
mLastRefreshTime
;
mLastRefreshTime
=
aTime
;
ScrollFrameHelper
:
:
AsyncSmoothMSDScrollCallback
(
mCallee
deltaTime
)
;
}
void
SetRefreshObserver
(
ScrollFrameHelper
*
aCallee
)
{
NS_ASSERTION
(
aCallee
&
&
!
mCallee
"
AsyncSmoothMSDScroll
:
:
SetRefreshObserver
-
Invalid
usage
.
"
)
;
RefreshDriver
(
aCallee
)
-
>
AddRefreshObserver
(
this
FlushType
:
:
Style
)
;
mCallee
=
aCallee
;
}
void
RemoveObserver
(
)
{
if
(
mCallee
)
{
RefreshDriver
(
mCallee
)
-
>
RemoveRefreshObserver
(
this
FlushType
:
:
Style
)
;
mCallee
=
nullptr
;
}
}
private
:
~
AsyncSmoothMSDScroll
(
)
{
RemoveObserver
(
)
;
Telemetry
:
:
SetHistogramRecordingEnabled
(
Telemetry
:
:
FX_REFRESH_DRIVER_SYNC_SCROLL_FRAME_DELAY_MS
false
)
;
}
nsRefreshDriver
*
RefreshDriver
(
ScrollFrameHelper
*
aCallee
)
{
return
aCallee
-
>
mOuter
-
>
PresContext
(
)
-
>
RefreshDriver
(
)
;
}
mozilla
:
:
layers
:
:
AxisPhysicsMSDModel
mXAxisModel
mYAxisModel
;
nsRect
mRange
;
mozilla
:
:
TimeStamp
mLastRefreshTime
;
ScrollFrameHelper
*
mCallee
;
nscoord
mOneDevicePixelInAppUnits
;
}
;
class
ScrollFrameHelper
:
:
AsyncScroll
final
:
public
nsARefreshObserver
{
public
:
typedef
mozilla
:
:
TimeStamp
TimeStamp
;
typedef
mozilla
:
:
TimeDuration
TimeDuration
;
explicit
AsyncScroll
(
)
:
mCallee
(
nullptr
)
{
Telemetry
:
:
SetHistogramRecordingEnabled
(
Telemetry
:
:
FX_REFRESH_DRIVER_SYNC_SCROLL_FRAME_DELAY_MS
true
)
;
}
private
:
~
AsyncScroll
(
)
{
RemoveObserver
(
)
;
Telemetry
:
:
SetHistogramRecordingEnabled
(
Telemetry
:
:
FX_REFRESH_DRIVER_SYNC_SCROLL_FRAME_DELAY_MS
false
)
;
}
public
:
void
InitSmoothScroll
(
TimeStamp
aTime
nsPoint
aInitialPosition
nsPoint
aDestination
nsAtom
*
aOrigin
const
nsRect
&
aRange
const
nsSize
&
aCurrentVelocity
)
;
void
Init
(
const
nsRect
&
aRange
)
{
mAnimationPhysics
=
nullptr
;
mRange
=
aRange
;
}
bool
IsSmoothScroll
(
)
{
return
mAnimationPhysics
!
=
nullptr
;
}
bool
IsFinished
(
const
TimeStamp
&
aTime
)
const
{
MOZ_RELEASE_ASSERT
(
mAnimationPhysics
)
;
return
mAnimationPhysics
-
>
IsFinished
(
aTime
)
;
}
nsPoint
PositionAt
(
const
TimeStamp
&
aTime
)
const
{
MOZ_RELEASE_ASSERT
(
mAnimationPhysics
)
;
return
mAnimationPhysics
-
>
PositionAt
(
aTime
)
;
}
nsSize
VelocityAt
(
const
TimeStamp
&
aTime
)
const
{
MOZ_RELEASE_ASSERT
(
mAnimationPhysics
)
;
return
mAnimationPhysics
-
>
VelocityAt
(
aTime
)
;
}
RefPtr
<
nsAtom
>
mOrigin
;
nsRect
mRange
;
private
:
void
InitPreferences
(
TimeStamp
aTime
nsAtom
*
aOrigin
)
;
UniquePtr
<
ScrollAnimationPhysics
>
mAnimationPhysics
;
public
:
NS_INLINE_DECL_REFCOUNTING
(
AsyncScroll
override
)
void
SetRefreshObserver
(
ScrollFrameHelper
*
aCallee
)
{
NS_ASSERTION
(
aCallee
&
&
!
mCallee
"
AsyncScroll
:
:
SetRefreshObserver
-
Invalid
usage
.
"
)
;
RefreshDriver
(
aCallee
)
-
>
AddRefreshObserver
(
this
FlushType
:
:
Style
)
;
mCallee
=
aCallee
;
nsIPresShell
*
shell
=
mCallee
-
>
mOuter
-
>
PresShell
(
)
;
MOZ_ASSERT
(
shell
)
;
shell
-
>
SuppressDisplayport
(
true
)
;
}
virtual
void
WillRefresh
(
mozilla
:
:
TimeStamp
aTime
)
override
{
ScrollFrameHelper
:
:
AsyncScrollCallback
(
mCallee
aTime
)
;
}
void
RemoveObserver
(
)
{
if
(
mCallee
)
{
RefreshDriver
(
mCallee
)
-
>
RemoveRefreshObserver
(
this
FlushType
:
:
Style
)
;
nsIPresShell
*
shell
=
mCallee
-
>
mOuter
-
>
PresShell
(
)
;
MOZ_ASSERT
(
shell
)
;
shell
-
>
SuppressDisplayport
(
false
)
;
mCallee
=
nullptr
;
}
}
private
:
ScrollFrameHelper
*
mCallee
;
nsRefreshDriver
*
RefreshDriver
(
ScrollFrameHelper
*
aCallee
)
{
return
aCallee
-
>
mOuter
-
>
PresContext
(
)
-
>
RefreshDriver
(
)
;
}
}
;
static
ScrollAnimationBezierPhysicsSettings
ComputeBezierAnimationSettingsForOrigin
(
nsAtom
*
aOrigin
)
{
int32_t
minMS
=
0
;
int32_t
maxMS
=
0
;
bool
isOriginSmoothnessEnabled
=
false
;
double
intervalRatio
=
1
;
static
const
int32_t
kDefaultMinMS
=
150
kDefaultMaxMS
=
150
;
static
const
bool
kDefaultIsSmoothEnabled
=
true
;
nsAutoCString
originName
;
aOrigin
-
>
ToUTF8String
(
originName
)
;
nsAutoCString
prefBase
=
NS_LITERAL_CSTRING
(
"
general
.
smoothScroll
.
"
)
+
originName
;
isOriginSmoothnessEnabled
=
Preferences
:
:
GetBool
(
prefBase
.
get
(
)
kDefaultIsSmoothEnabled
)
;
if
(
isOriginSmoothnessEnabled
)
{
nsAutoCString
prefMin
=
prefBase
+
NS_LITERAL_CSTRING
(
"
.
durationMinMS
"
)
;
nsAutoCString
prefMax
=
prefBase
+
NS_LITERAL_CSTRING
(
"
.
durationMaxMS
"
)
;
minMS
=
Preferences
:
:
GetInt
(
prefMin
.
get
(
)
kDefaultMinMS
)
;
maxMS
=
Preferences
:
:
GetInt
(
prefMax
.
get
(
)
kDefaultMaxMS
)
;
static
const
int32_t
kSmoothScrollMaxAllowedAnimationDurationMS
=
10000
;
maxMS
=
clamped
(
maxMS
0
kSmoothScrollMaxAllowedAnimationDurationMS
)
;
minMS
=
clamped
(
minMS
0
maxMS
)
;
}
static
const
double
kDefaultDurationToIntervalRatio
=
2
;
intervalRatio
=
Preferences
:
:
GetInt
(
"
general
.
smoothScroll
.
durationToIntervalRatio
"
kDefaultDurationToIntervalRatio
*
100
)
/
100
.
0
;
intervalRatio
=
std
:
:
max
(
1
.
0
intervalRatio
)
;
return
ScrollAnimationBezierPhysicsSettings
{
minMS
maxMS
intervalRatio
}
;
}
void
ScrollFrameHelper
:
:
AsyncScroll
:
:
InitSmoothScroll
(
TimeStamp
aTime
nsPoint
aInitialPosition
nsPoint
aDestination
nsAtom
*
aOrigin
const
nsRect
&
aRange
const
nsSize
&
aCurrentVelocity
)
{
if
(
!
aOrigin
|
|
aOrigin
=
=
nsGkAtoms
:
:
restore
|
|
aOrigin
=
=
nsGkAtoms
:
:
relative
)
{
aOrigin
=
nsGkAtoms
:
:
other
;
}
MOZ_ASSERT
(
aOrigin
!
=
nsGkAtoms
:
:
apz
)
;
if
(
!
mAnimationPhysics
|
|
aOrigin
!
=
mOrigin
)
{
mOrigin
=
aOrigin
;
if
(
gfxPrefs
:
:
SmoothScrollMSDPhysicsEnabled
(
)
)
{
mAnimationPhysics
=
MakeUnique
<
ScrollAnimationMSDPhysics
>
(
aInitialPosition
)
;
}
else
{
ScrollAnimationBezierPhysicsSettings
settings
=
ComputeBezierAnimationSettingsForOrigin
(
mOrigin
)
;
mAnimationPhysics
=
MakeUnique
<
ScrollAnimationBezierPhysics
>
(
aInitialPosition
settings
)
;
}
}
mRange
=
aRange
;
mAnimationPhysics
-
>
Update
(
aTime
aDestination
aCurrentVelocity
)
;
}
bool
ScrollFrameHelper
:
:
IsSmoothScrollingEnabled
(
)
{
return
Preferences
:
:
GetBool
(
SMOOTH_SCROLL_PREF_NAME
false
)
;
}
class
ScrollFrameActivityTracker
final
:
public
nsExpirationTracker
<
ScrollFrameHelper
4
>
{
public
:
enum
{
TIMEOUT_MS
=
1000
}
;
explicit
ScrollFrameActivityTracker
(
nsIEventTarget
*
aEventTarget
)
:
nsExpirationTracker
<
ScrollFrameHelper
4
>
(
TIMEOUT_MS
"
ScrollFrameActivityTracker
"
aEventTarget
)
{
}
~
ScrollFrameActivityTracker
(
)
{
AgeAllGenerations
(
)
;
}
virtual
void
NotifyExpired
(
ScrollFrameHelper
*
aObject
)
override
{
RemoveObject
(
aObject
)
;
aObject
-
>
MarkNotRecentlyScrolled
(
)
;
}
}
;
static
ScrollFrameActivityTracker
*
gScrollFrameActivityTracker
=
nullptr
;
static
uint32_t
sScrollGenerationCounter
=
0
;
ScrollFrameHelper
:
:
ScrollFrameHelper
(
nsContainerFrame
*
aOuter
bool
aIsRoot
)
:
mHScrollbarBox
(
nullptr
)
mVScrollbarBox
(
nullptr
)
mScrolledFrame
(
nullptr
)
mScrollCornerBox
(
nullptr
)
mResizerBox
(
nullptr
)
mOuter
(
aOuter
)
mReferenceFrameDuringPainting
(
nullptr
)
mAsyncScroll
(
nullptr
)
mAsyncSmoothMSDScroll
(
nullptr
)
mLastScrollOrigin
(
nsGkAtoms
:
:
other
)
mLastSmoothScrollOrigin
(
nullptr
)
mScrollGeneration
(
+
+
sScrollGenerationCounter
)
mDestination
(
0
0
)
mRestorePos
(
-
1
-
1
)
mLastPos
(
-
1
-
1
)
mApzScrollPos
(
0
0
)
mScrollPosForLayerPixelAlignment
(
-
1
-
1
)
mLastUpdateFramesPos
(
-
1
-
1
)
mDisplayPortAtLastFrameUpdate
(
)
mScrollParentID
(
mozilla
:
:
layers
:
:
ScrollableLayerGuid
:
:
NULL_SCROLL_ID
)
mAnchor
(
this
)
mAllowScrollOriginDowngrade
(
false
)
mHadDisplayPortAtLastFrameUpdate
(
false
)
mNeverHasVerticalScrollbar
(
false
)
mNeverHasHorizontalScrollbar
(
false
)
mHasVerticalScrollbar
(
false
)
mHasHorizontalScrollbar
(
false
)
mFrameIsUpdatingScrollbar
(
false
)
mDidHistoryRestore
(
false
)
mIsRoot
(
aIsRoot
)
mClipAllDescendants
(
aIsRoot
)
mSuppressScrollbarUpdate
(
false
)
mSkippedScrollbarLayout
(
false
)
mHadNonInitialReflow
(
false
)
mHorizontalOverflow
(
false
)
mVerticalOverflow
(
false
)
mPostedReflowCallback
(
false
)
mMayHaveDirtyFixedChildren
(
false
)
mUpdateScrollbarAttributes
(
false
)
mHasBeenScrolledRecently
(
false
)
mCollapsedResizer
(
false
)
mWillBuildScrollableLayer
(
false
)
mIsScrollParent
(
false
)
mIsScrollableLayerInRootContainer
(
false
)
mAddClipRectToLayer
(
false
)
mHasBeenScrolled
(
false
)
mIgnoreMomentumScroll
(
false
)
mTransformingByAPZ
(
false
)
mScrollableByAPZ
(
false
)
mZoomableByAPZ
(
false
)
mHasOutOfFlowContentInsideFilter
(
false
)
mSuppressScrollbarRepaints
(
false
)
mIsUsingMinimumScaleSize
(
false
)
mVelocityQueue
(
aOuter
-
>
PresContext
(
)
)
{
if
(
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
eIntID_UseOverlayScrollbars
)
!
=
0
)
{
mScrollbarActivity
=
new
ScrollbarActivity
(
do_QueryFrame
(
aOuter
)
)
;
}
EnsureFrameVisPrefsCached
(
)
;
if
(
IsAlwaysActive
(
)
&
&
gfxPrefs
:
:
LayersTilesEnabled
(
)
&
&
!
nsLayoutUtils
:
:
UsesAsyncScrolling
(
mOuter
)
&
&
mOuter
-
>
GetContent
(
)
)
{
nsLayoutUtils
:
:
SetDisplayPortMargins
(
mOuter
-
>
GetContent
(
)
mOuter
-
>
PresShell
(
)
ScreenMargin
(
)
0
nsLayoutUtils
:
:
RepaintMode
:
:
DoNotRepaint
)
;
nsLayoutUtils
:
:
SetZeroMarginDisplayPortOnAsyncScrollableAncestors
(
mOuter
nsLayoutUtils
:
:
RepaintMode
:
:
DoNotRepaint
)
;
}
}
ScrollFrameHelper
:
:
~
ScrollFrameHelper
(
)
{
if
(
mScrollEvent
)
{
mScrollEvent
-
>
Revoke
(
)
;
}
if
(
mScrollEndEvent
)
{
mScrollEndEvent
-
>
Revoke
(
)
;
}
}
void
ScrollFrameHelper
:
:
AsyncSmoothMSDScrollCallback
(
ScrollFrameHelper
*
aInstance
mozilla
:
:
TimeDuration
aDeltaTime
)
{
NS_ASSERTION
(
aInstance
!
=
nullptr
"
aInstance
must
not
be
null
"
)
;
NS_ASSERTION
(
aInstance
-
>
mAsyncSmoothMSDScroll
"
Did
not
expect
AsyncSmoothMSDScrollCallback
without
an
active
"
"
MSD
scroll
.
"
)
;
nsRect
range
=
aInstance
-
>
mAsyncSmoothMSDScroll
-
>
GetRange
(
)
;
aInstance
-
>
mAsyncSmoothMSDScroll
-
>
Simulate
(
aDeltaTime
)
;
if
(
!
aInstance
-
>
mAsyncSmoothMSDScroll
-
>
IsFinished
(
)
)
{
nsPoint
destination
=
aInstance
-
>
mAsyncSmoothMSDScroll
-
>
GetPosition
(
)
;
nsRect
intermediateRange
=
nsRect
(
destination
nsSize
(
)
)
.
UnionEdges
(
range
)
;
aInstance
-
>
ScrollToImpl
(
destination
intermediateRange
)
;
return
;
}
aInstance
-
>
CompleteAsyncScroll
(
range
)
;
}
void
ScrollFrameHelper
:
:
AsyncScrollCallback
(
ScrollFrameHelper
*
aInstance
mozilla
:
:
TimeStamp
aTime
)
{
MOZ_ASSERT
(
aInstance
!
=
nullptr
"
aInstance
must
not
be
null
"
)
;
MOZ_ASSERT
(
aInstance
-
>
mAsyncScroll
"
Did
not
expect
AsyncScrollCallback
without
an
active
async
scroll
.
"
)
;
if
(
!
aInstance
|
|
!
aInstance
-
>
mAsyncScroll
)
{
return
;
}
nsRect
range
=
aInstance
-
>
mAsyncScroll
-
>
mRange
;
if
(
aInstance
-
>
mAsyncScroll
-
>
IsSmoothScroll
(
)
)
{
if
(
!
aInstance
-
>
mAsyncScroll
-
>
IsFinished
(
aTime
)
)
{
nsPoint
destination
=
aInstance
-
>
mAsyncScroll
-
>
PositionAt
(
aTime
)
;
nsRect
intermediateRange
=
nsRect
(
aInstance
-
>
GetScrollPosition
(
)
nsSize
(
)
)
.
UnionEdges
(
range
)
;
aInstance
-
>
ScrollToImpl
(
destination
intermediateRange
)
;
return
;
}
}
aInstance
-
>
CompleteAsyncScroll
(
range
)
;
}
void
ScrollFrameHelper
:
:
CompleteAsyncScroll
(
const
nsRect
&
aRange
nsAtom
*
aOrigin
)
{
RemoveObservers
(
)
;
AutoWeakFrame
weakFrame
(
mOuter
)
;
ScrollToImpl
(
mDestination
aRange
aOrigin
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
;
}
mDestination
=
GetScrollPosition
(
)
;
PostScrollEndEvent
(
)
;
}
bool
ScrollFrameHelper
:
:
HasPluginFrames
(
)
{
#
if
defined
(
XP_WIN
)
|
|
defined
(
MOZ_WIDGET_GTK
)
if
(
XRE_IsContentProcess
(
)
)
{
nsPresContext
*
presContext
=
mOuter
-
>
PresContext
(
)
;
nsRootPresContext
*
rootPresContext
=
presContext
-
>
GetRootPresContext
(
)
;
if
(
!
rootPresContext
|
|
rootPresContext
-
>
NeedToComputePluginGeometryUpdates
(
)
)
{
return
true
;
}
}
#
endif
return
false
;
}
bool
ScrollFrameHelper
:
:
HasBgAttachmentLocal
(
)
const
{
const
nsStyleBackground
*
bg
=
mOuter
-
>
StyleBackground
(
)
;
return
bg
-
>
HasLocalBackground
(
)
;
}
void
ScrollFrameHelper
:
:
ScrollTo
(
nsPoint
aScrollPosition
nsIScrollableFrame
:
:
ScrollMode
aMode
nsAtom
*
aOrigin
const
nsRect
*
aRange
nsIScrollbarMediator
:
:
ScrollSnapMode
aSnap
)
{
if
(
aOrigin
=
=
nullptr
)
{
aOrigin
=
nsGkAtoms
:
:
other
;
}
ScrollToWithOrigin
(
aScrollPosition
aMode
aOrigin
aRange
aSnap
)
;
}
void
ScrollFrameHelper
:
:
ScrollToCSSPixels
(
const
CSSIntPoint
&
aScrollPosition
nsIScrollableFrame
:
:
ScrollMode
aMode
nsAtom
*
aOrigin
)
{
nsPoint
current
=
GetScrollPosition
(
)
;
CSSIntPoint
currentCSSPixels
=
GetScrollPositionCSSPixels
(
)
;
nsPoint
pt
=
CSSPoint
:
:
ToAppUnits
(
aScrollPosition
)
;
nscoord
halfPixel
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
0
.
5f
)
;
nsRect
range
(
pt
.
x
-
halfPixel
pt
.
y
-
halfPixel
2
*
halfPixel
-
1
2
*
halfPixel
-
1
)
;
if
(
currentCSSPixels
.
x
=
=
aScrollPosition
.
x
)
{
pt
.
x
=
current
.
x
;
range
.
x
=
pt
.
x
;
range
.
width
=
0
;
}
if
(
currentCSSPixels
.
y
=
=
aScrollPosition
.
y
)
{
pt
.
y
=
current
.
y
;
range
.
y
=
pt
.
y
;
range
.
height
=
0
;
}
if
(
aOrigin
=
=
nullptr
)
{
aOrigin
=
nsGkAtoms
:
:
other
;
}
ScrollTo
(
pt
aMode
aOrigin
&
range
)
;
}
void
ScrollFrameHelper
:
:
ScrollToCSSPixelsApproximate
(
const
CSSPoint
&
aScrollPosition
nsAtom
*
aOrigin
)
{
nsPoint
pt
=
CSSPoint
:
:
ToAppUnits
(
aScrollPosition
)
;
nscoord
halfRange
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
1000
)
;
nsRect
range
(
pt
.
x
-
halfRange
pt
.
y
-
halfRange
2
*
halfRange
-
1
2
*
halfRange
-
1
)
;
ScrollToWithOrigin
(
pt
nsIScrollableFrame
:
:
INSTANT
aOrigin
&
range
)
;
}
CSSIntPoint
ScrollFrameHelper
:
:
GetScrollPositionCSSPixels
(
)
{
return
CSSIntPoint
:
:
FromAppUnitsRounded
(
GetScrollPosition
(
)
)
;
}
void
ScrollFrameHelper
:
:
ScrollToWithOrigin
(
nsPoint
aScrollPosition
nsIScrollableFrame
:
:
ScrollMode
aMode
nsAtom
*
aOrigin
const
nsRect
*
aRange
nsIScrollbarMediator
:
:
ScrollSnapMode
aSnap
)
{
if
(
aOrigin
!
=
nsGkAtoms
:
:
restore
)
{
mRestorePos
.
x
=
mRestorePos
.
y
=
-
1
;
}
if
(
aSnap
=
=
nsIScrollableFrame
:
:
ENABLE_SNAP
)
{
GetSnapPointForDestination
(
nsIScrollableFrame
:
:
DEVICE_PIXELS
mDestination
aScrollPosition
)
;
}
nsRect
scrollRange
=
GetScrollRangeForClamping
(
)
;
mDestination
=
scrollRange
.
ClampPoint
(
aScrollPosition
)
;
if
(
mDestination
!
=
aScrollPosition
&
&
aOrigin
=
=
nsGkAtoms
:
:
restore
&
&
GetPageLoadingState
(
)
!
=
LoadingState
:
:
Loading
)
{
aOrigin
=
nsGkAtoms
:
:
other
;
}
nsRect
range
=
aRange
?
*
aRange
:
nsRect
(
aScrollPosition
nsSize
(
0
0
)
)
;
if
(
aMode
!
=
nsIScrollableFrame
:
:
SMOOTH_MSD
)
{
mApzSmoothScrollDestination
=
Nothing
(
)
;
}
if
(
aMode
=
=
nsIScrollableFrame
:
:
INSTANT
)
{
CompleteAsyncScroll
(
range
aOrigin
)
;
return
;
}
nsPresContext
*
presContext
=
mOuter
-
>
PresContext
(
)
;
TimeStamp
now
=
presContext
-
>
RefreshDriver
(
)
-
>
IsTestControllingRefreshesEnabled
(
)
?
presContext
-
>
RefreshDriver
(
)
-
>
MostRecentRefresh
(
)
:
TimeStamp
:
:
Now
(
)
;
bool
isSmoothScroll
=
(
aMode
=
=
nsIScrollableFrame
:
:
SMOOTH
)
&
&
IsSmoothScrollingEnabled
(
)
;
nsSize
currentVelocity
(
0
0
)
;
if
(
gfxPrefs
:
:
ScrollBehaviorEnabled
(
)
)
{
if
(
aMode
=
=
nsIScrollableFrame
:
:
SMOOTH_MSD
)
{
mIgnoreMomentumScroll
=
true
;
if
(
!
mAsyncSmoothMSDScroll
)
{
nsPoint
sv
=
mVelocityQueue
.
GetVelocity
(
)
;
currentVelocity
.
width
=
sv
.
x
;
currentVelocity
.
height
=
sv
.
y
;
if
(
mAsyncScroll
)
{
if
(
mAsyncScroll
-
>
IsSmoothScroll
(
)
)
{
currentVelocity
=
mAsyncScroll
-
>
VelocityAt
(
now
)
;
}
mAsyncScroll
=
nullptr
;
}
if
(
nsLayoutUtils
:
:
AsyncPanZoomEnabled
(
mOuter
)
&
&
WantAsyncScroll
(
)
)
{
if
(
mApzSmoothScrollDestination
=
=
Some
(
mDestination
)
&
&
mScrollGeneration
=
=
sScrollGenerationCounter
)
{
return
;
}
mLastSmoothScrollOrigin
=
aOrigin
;
mApzSmoothScrollDestination
=
Some
(
mDestination
)
;
mScrollGeneration
=
+
+
sScrollGenerationCounter
;
if
(
!
nsLayoutUtils
:
:
HasDisplayPort
(
mOuter
-
>
GetContent
(
)
)
)
{
nsLayoutUtils
:
:
CalculateAndSetDisplayPortMargins
(
mOuter
-
>
GetScrollTargetFrame
(
)
nsLayoutUtils
:
:
RepaintMode
:
:
DoNotRepaint
)
;
nsIFrame
*
frame
=
do_QueryFrame
(
mOuter
-
>
GetScrollTargetFrame
(
)
)
;
nsLayoutUtils
:
:
SetZeroMarginDisplayPortOnAsyncScrollableAncestors
(
frame
nsLayoutUtils
:
:
RepaintMode
:
:
DoNotRepaint
)
;
}
mOuter
-
>
SchedulePaint
(
)
;
return
;
}
mAsyncSmoothMSDScroll
=
new
AsyncSmoothMSDScroll
(
GetScrollPosition
(
)
mDestination
currentVelocity
GetScrollRangeForClamping
(
)
now
presContext
)
;
mAsyncSmoothMSDScroll
-
>
SetRefreshObserver
(
this
)
;
}
else
{
mAsyncSmoothMSDScroll
-
>
SetRange
(
GetScrollRangeForClamping
(
)
)
;
mAsyncSmoothMSDScroll
-
>
SetDestination
(
mDestination
)
;
}
return
;
}
else
{
if
(
mAsyncSmoothMSDScroll
)
{
currentVelocity
=
mAsyncSmoothMSDScroll
-
>
GetVelocity
(
)
;
mAsyncSmoothMSDScroll
=
nullptr
;
}
}
}
if
(
!
mAsyncScroll
)
{
mAsyncScroll
=
new
AsyncScroll
(
)
;
mAsyncScroll
-
>
SetRefreshObserver
(
this
)
;
}
if
(
isSmoothScroll
)
{
mAsyncScroll
-
>
InitSmoothScroll
(
now
GetScrollPosition
(
)
mDestination
aOrigin
range
currentVelocity
)
;
}
else
{
mAsyncScroll
-
>
Init
(
range
)
;
}
}
static
void
AdjustViews
(
nsIFrame
*
aFrame
)
{
nsView
*
view
=
aFrame
-
>
GetView
(
)
;
if
(
view
)
{
nsPoint
pt
;
aFrame
-
>
GetParent
(
)
-
>
GetClosestView
(
&
pt
)
;
pt
+
=
aFrame
-
>
GetPosition
(
)
;
view
-
>
SetPosition
(
pt
.
x
pt
.
y
)
;
return
;
}
if
(
!
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_HAS_CHILD_WITH_VIEW
)
)
{
return
;
}
nsIFrame
:
:
ChildListIterator
lists
(
aFrame
)
;
for
(
;
!
lists
.
IsDone
(
)
;
lists
.
Next
(
)
)
{
if
(
lists
.
CurrentID
(
)
=
=
nsIFrame
:
:
kPopupList
)
{
continue
;
}
nsFrameList
:
:
Enumerator
childFrames
(
lists
.
CurrentList
(
)
)
;
for
(
;
!
childFrames
.
AtEnd
(
)
;
childFrames
.
Next
(
)
)
{
AdjustViews
(
childFrames
.
get
(
)
)
;
}
}
}
void
ScrollFrameHelper
:
:
MarkScrollbarsDirtyForReflow
(
)
const
{
nsIPresShell
*
presShell
=
mOuter
-
>
PresShell
(
)
;
if
(
mVScrollbarBox
)
{
presShell
-
>
FrameNeedsReflow
(
mVScrollbarBox
nsIPresShell
:
:
eResize
NS_FRAME_IS_DIRTY
)
;
}
if
(
mHScrollbarBox
)
{
presShell
-
>
FrameNeedsReflow
(
mHScrollbarBox
nsIPresShell
:
:
eResize
NS_FRAME_IS_DIRTY
)
;
}
}
bool
ScrollFrameHelper
:
:
ShouldClampScrollPosition
(
)
const
{
if
(
!
mIsRoot
)
return
true
;
nsSubDocumentFrame
*
subdocFrame
=
static_cast
<
nsSubDocumentFrame
*
>
(
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
mOuter
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
)
)
;
return
!
subdocFrame
|
|
subdocFrame
-
>
ShouldClampScrollPosition
(
)
;
}
bool
ScrollFrameHelper
:
:
IsAlwaysActive
(
)
const
{
if
(
nsDisplayItem
:
:
ForceActiveLayers
(
)
)
{
return
true
;
}
if
(
!
(
mIsRoot
&
&
mOuter
-
>
PresContext
(
)
-
>
IsRootContentDocument
(
)
)
)
{
return
false
;
}
if
(
mHasBeenScrolled
)
{
return
true
;
}
ScrollStyles
styles
=
GetScrollStylesFromFrame
(
)
;
return
(
styles
.
mHorizontal
!
=
StyleOverflow
:
:
Hidden
&
&
styles
.
mVertical
!
=
StyleOverflow
:
:
Hidden
)
;
}
static
void
RemoveDisplayPortCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
{
ScrollFrameHelper
*
helper
=
static_cast
<
ScrollFrameHelper
*
>
(
aClosure
)
;
MOZ_ASSERT
(
helper
-
>
mDisplayPortExpiryTimer
)
;
helper
-
>
mDisplayPortExpiryTimer
=
nullptr
;
if
(
!
helper
-
>
AllowDisplayPortExpiration
(
)
|
|
helper
-
>
mIsScrollParent
)
{
return
;
}
nsLayoutUtils
:
:
RemoveDisplayPort
(
helper
-
>
mOuter
-
>
GetContent
(
)
)
;
nsLayoutUtils
:
:
ExpireDisplayPortOnAsyncScrollableAncestor
(
helper
-
>
mOuter
)
;
helper
-
>
mOuter
-
>
SchedulePaint
(
)
;
helper
-
>
mScrollableByAPZ
=
false
;
}
void
ScrollFrameHelper
:
:
MarkEverScrolled
(
)
{
mHasBeenScrolled
=
true
;
}
void
ScrollFrameHelper
:
:
MarkNotRecentlyScrolled
(
)
{
if
(
!
mHasBeenScrolledRecently
)
return
;
mHasBeenScrolledRecently
=
false
;
mOuter
-
>
SchedulePaint
(
)
;
}
void
ScrollFrameHelper
:
:
MarkRecentlyScrolled
(
)
{
mHasBeenScrolledRecently
=
true
;
if
(
IsAlwaysActive
(
)
)
{
return
;
}
if
(
mActivityExpirationState
.
IsTracked
(
)
)
{
gScrollFrameActivityTracker
-
>
MarkUsed
(
this
)
;
}
else
{
if
(
!
gScrollFrameActivityTracker
)
{
gScrollFrameActivityTracker
=
new
ScrollFrameActivityTracker
(
SystemGroup
:
:
EventTargetFor
(
TaskCategory
:
:
Other
)
)
;
}
gScrollFrameActivityTracker
-
>
AddObject
(
this
)
;
}
ResetDisplayPortExpiryTimer
(
)
;
}
void
ScrollFrameHelper
:
:
ResetDisplayPortExpiryTimer
(
)
{
if
(
mDisplayPortExpiryTimer
)
{
mDisplayPortExpiryTimer
-
>
InitWithNamedFuncCallback
(
RemoveDisplayPortCallback
this
gfxPrefs
:
:
APZDisplayPortExpiryTime
(
)
nsITimer
:
:
TYPE_ONE_SHOT
"
ScrollFrameHelper
:
:
ResetDisplayPortExpiryTimer
"
)
;
}
}
bool
ScrollFrameHelper
:
:
AllowDisplayPortExpiration
(
)
{
if
(
IsAlwaysActive
(
)
)
{
return
false
;
}
if
(
mIsRoot
&
&
mOuter
-
>
PresContext
(
)
-
>
IsRoot
(
)
)
{
return
false
;
}
return
true
;
}
void
ScrollFrameHelper
:
:
TriggerDisplayPortExpiration
(
)
{
if
(
!
AllowDisplayPortExpiration
(
)
)
{
return
;
}
if
(
!
gfxPrefs
:
:
APZDisplayPortExpiryTime
(
)
)
{
return
;
}
if
(
!
mDisplayPortExpiryTimer
)
{
mDisplayPortExpiryTimer
=
NS_NewTimer
(
)
;
}
ResetDisplayPortExpiryTimer
(
)
;
}
void
ScrollFrameHelper
:
:
ScrollVisual
(
)
{
MarkEverScrolled
(
)
;
AdjustViews
(
mScrolledFrame
)
;
MarkRecentlyScrolled
(
)
;
}
static
nscoord
ClampAndAlignWithPixels
(
nscoord
aDesired
nscoord
aBoundLower
nscoord
aBoundUpper
nscoord
aDestLower
nscoord
aDestUpper
nscoord
aAppUnitsPerPixel
double
aRes
nscoord
aCurrent
)
{
nscoord
destLower
=
clamped
(
aDestLower
aBoundLower
aBoundUpper
)
;
nscoord
destUpper
=
clamped
(
aDestUpper
aBoundLower
aBoundUpper
)
;
nscoord
desired
=
clamped
(
aDesired
destLower
destUpper
)
;
double
currentLayerVal
=
(
aRes
*
aCurrent
)
/
aAppUnitsPerPixel
;
double
desiredLayerVal
=
(
aRes
*
desired
)
/
aAppUnitsPerPixel
;
double
delta
=
desiredLayerVal
-
currentLayerVal
;
double
nearestLayerVal
=
NS_round
(
delta
)
+
currentLayerVal
;
nscoord
aligned
=
NSToCoordRoundWithClamp
(
nearestLayerVal
*
aAppUnitsPerPixel
/
aRes
)
;
if
(
aBoundUpper
=
=
destUpper
&
&
static_cast
<
decltype
(
Abs
(
desired
)
)
>
(
aBoundUpper
-
desired
)
<
Abs
(
desired
-
aligned
)
)
return
aBoundUpper
;
if
(
aBoundLower
=
=
destLower
&
&
static_cast
<
decltype
(
Abs
(
desired
)
)
>
(
desired
-
aBoundLower
)
<
Abs
(
aligned
-
desired
)
)
return
aBoundLower
;
if
(
aligned
>
=
destLower
&
&
aligned
<
=
destUpper
)
return
aligned
;
double
oppositeLayerVal
=
nearestLayerVal
+
(
(
nearestLayerVal
<
desiredLayerVal
)
?
1
.
0
:
-
1
.
0
)
;
nscoord
opposite
=
NSToCoordRoundWithClamp
(
oppositeLayerVal
*
aAppUnitsPerPixel
/
aRes
)
;
if
(
opposite
>
=
destLower
&
&
opposite
<
=
destUpper
)
{
return
opposite
;
}
return
desired
;
}
static
nsPoint
ClampAndAlignWithLayerPixels
(
const
nsPoint
&
aPt
const
nsRect
&
aBounds
const
nsRect
&
aRange
const
nsPoint
&
aCurrent
nscoord
aAppUnitsPerPixel
const
gfxSize
&
aScale
)
{
return
nsPoint
(
ClampAndAlignWithPixels
(
aPt
.
x
aBounds
.
x
aBounds
.
XMost
(
)
aRange
.
x
aRange
.
XMost
(
)
aAppUnitsPerPixel
aScale
.
width
aCurrent
.
x
)
ClampAndAlignWithPixels
(
aPt
.
y
aBounds
.
y
aBounds
.
YMost
(
)
aRange
.
y
aRange
.
YMost
(
)
aAppUnitsPerPixel
aScale
.
height
aCurrent
.
y
)
)
;
}
void
ScrollFrameHelper
:
:
ScrollActivityCallback
(
nsITimer
*
aTimer
void
*
anInstance
)
{
ScrollFrameHelper
*
self
=
static_cast
<
ScrollFrameHelper
*
>
(
anInstance
)
;
self
-
>
mScrollActivityTimer
-
>
Cancel
(
)
;
self
-
>
mScrollActivityTimer
=
nullptr
;
self
-
>
mOuter
-
>
PresShell
(
)
-
>
SynthesizeMouseMove
(
true
)
;
}
void
ScrollFrameHelper
:
:
ScheduleSyntheticMouseMove
(
)
{
if
(
!
mScrollActivityTimer
)
{
mScrollActivityTimer
=
NS_NewTimer
(
mOuter
-
>
PresContext
(
)
-
>
Document
(
)
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
)
;
if
(
!
mScrollActivityTimer
)
{
return
;
}
}
mScrollActivityTimer
-
>
InitWithNamedFuncCallback
(
ScrollActivityCallback
this
100
nsITimer
:
:
TYPE_ONE_SHOT
"
ScrollFrameHelper
:
:
ScheduleSyntheticMouseMove
"
)
;
}
void
ScrollFrameHelper
:
:
NotifyApproximateFrameVisibilityUpdate
(
bool
aIgnoreDisplayPort
)
{
mLastUpdateFramesPos
=
GetScrollPosition
(
)
;
if
(
aIgnoreDisplayPort
)
{
mHadDisplayPortAtLastFrameUpdate
=
false
;
mDisplayPortAtLastFrameUpdate
=
nsRect
(
)
;
}
else
{
mHadDisplayPortAtLastFrameUpdate
=
nsLayoutUtils
:
:
GetDisplayPort
(
mOuter
-
>
GetContent
(
)
&
mDisplayPortAtLastFrameUpdate
)
;
}
}
bool
ScrollFrameHelper
:
:
GetDisplayPortAtLastApproximateFrameVisibilityUpdate
(
nsRect
*
aDisplayPort
)
{
if
(
mHadDisplayPortAtLastFrameUpdate
)
{
*
aDisplayPort
=
mDisplayPortAtLastFrameUpdate
;
}
return
mHadDisplayPortAtLastFrameUpdate
;
}
void
ScrollFrameHelper
:
:
ScrollToImpl
(
nsPoint
aPt
const
nsRect
&
aRange
nsAtom
*
aOrigin
)
{
if
(
aOrigin
=
=
nullptr
)
{
aOrigin
=
nsGkAtoms
:
:
other
;
}
nsPresContext
*
presContext
=
mOuter
-
>
PresContext
(
)
;
nscoord
appUnitsPerDevPixel
=
presContext
-
>
AppUnitsPerDevPixel
(
)
;
gfxSize
scale
=
FrameLayerBuilder
:
:
GetPaintedLayerScaleForFrame
(
mScrolledFrame
)
;
nsPoint
curPos
=
GetScrollPosition
(
)
;
nsPoint
alignWithPos
=
mScrollPosForLayerPixelAlignment
=
=
nsPoint
(
-
1
-
1
)
?
curPos
:
mScrollPosForLayerPixelAlignment
;
nsPoint
pt
=
ClampAndAlignWithLayerPixels
(
aPt
GetScrollRangeForClamping
(
)
aRange
alignWithPos
appUnitsPerDevPixel
scale
)
;
if
(
pt
=
=
curPos
)
{
return
;
}
bool
needFrameVisibilityUpdate
=
mLastUpdateFramesPos
=
=
nsPoint
(
-
1
-
1
)
;
nsPoint
dist
(
std
:
:
abs
(
pt
.
x
-
mLastUpdateFramesPos
.
x
)
std
:
:
abs
(
pt
.
y
-
mLastUpdateFramesPos
.
y
)
)
;
nsSize
visualViewportSize
=
GetVisualViewportSize
(
)
;
nscoord
horzAllowance
=
std
:
:
max
(
visualViewportSize
.
width
/
std
:
:
max
(
sHorzScrollFraction
1
)
AppUnitsPerCSSPixel
(
)
)
;
nscoord
vertAllowance
=
std
:
:
max
(
visualViewportSize
.
height
/
std
:
:
max
(
sVertScrollFraction
1
)
AppUnitsPerCSSPixel
(
)
)
;
if
(
dist
.
x
>
=
horzAllowance
|
|
dist
.
y
>
=
vertAllowance
)
{
needFrameVisibilityUpdate
=
true
;
}
for
(
uint32_t
i
=
0
;
i
<
mListeners
.
Length
(
)
;
i
+
+
)
{
mListeners
[
i
]
-
>
ScrollPositionWillChange
(
pt
.
x
pt
.
y
)
;
}
nsRect
oldDisplayPort
;
nsIContent
*
content
=
mOuter
-
>
GetContent
(
)
;
nsLayoutUtils
:
:
GetHighResolutionDisplayPort
(
content
&
oldDisplayPort
)
;
oldDisplayPort
.
MoveBy
(
-
mScrolledFrame
-
>
GetPosition
(
)
)
;
mScrolledFrame
-
>
SetPosition
(
mScrollPort
.
TopLeft
(
)
-
pt
)
;
if
(
aOrigin
=
=
nsGkAtoms
:
:
relative
&
&
(
mLastScrollOrigin
&
&
mLastScrollOrigin
!
=
nsGkAtoms
:
:
relative
&
&
mLastScrollOrigin
!
=
nsGkAtoms
:
:
apz
)
)
{
aOrigin
=
nsGkAtoms
:
:
other
;
}
bool
isScrollOriginDowngrade
=
nsLayoutUtils
:
:
CanScrollOriginClobberApz
(
mLastScrollOrigin
)
&
&
!
nsLayoutUtils
:
:
CanScrollOriginClobberApz
(
aOrigin
)
;
bool
allowScrollOriginChange
=
mAllowScrollOriginDowngrade
|
|
!
isScrollOriginDowngrade
;
if
(
allowScrollOriginChange
)
{
mLastScrollOrigin
=
aOrigin
;
mAllowScrollOriginDowngrade
=
false
;
}
mLastSmoothScrollOrigin
=
nullptr
;
mScrollGeneration
=
+
+
sScrollGenerationCounter
;
if
(
mLastScrollOrigin
=
=
nsGkAtoms
:
:
apz
)
{
mApzScrollPos
=
GetScrollPosition
(
)
;
}
if
(
mIsRoot
&
&
nsLayoutUtils
:
:
CanScrollOriginClobberApz
(
mLastScrollOrigin
)
)
{
content
-
>
SetProperty
(
nsGkAtoms
:
:
apzCallbackTransform
new
CSSPoint
(
)
nsINode
:
:
DeleteProperty
<
CSSPoint
>
)
;
presContext
-
>
PresShell
(
)
-
>
SetVisualViewportOffset
(
pt
curPos
)
;
}
ScrollVisual
(
)
;
mAnchor
.
UserScrolled
(
)
;
bool
schedulePaint
=
true
;
if
(
nsLayoutUtils
:
:
AsyncPanZoomEnabled
(
mOuter
)
&
&
!
nsLayoutUtils
:
:
ShouldDisableApzForElement
(
content
)
&
&
gfxPrefs
:
:
APZPaintSkipping
(
)
)
{
nsRect
displayPort
;
bool
usingDisplayPort
=
nsLayoutUtils
:
:
GetHighResolutionDisplayPort
(
content
&
displayPort
)
;
displayPort
.
MoveBy
(
-
mScrolledFrame
-
>
GetPosition
(
)
)
;
PAINT_SKIP_LOG
(
"
New
scrollpos
%
s
usingDP
%
d
dpEqual
%
d
scrollableByApz
%
d
plugins
"
"
%
d
perspective
%
d
bglocal
%
d
filter
%
d
\
n
"
Stringify
(
CSSPoint
:
:
FromAppUnits
(
GetScrollPosition
(
)
)
)
.
c_str
(
)
usingDisplayPort
displayPort
.
IsEqualEdges
(
oldDisplayPort
)
mScrollableByAPZ
HasPluginFrames
(
)
HasPerspective
(
)
HasBgAttachmentLocal
(
)
mHasOutOfFlowContentInsideFilter
)
;
if
(
usingDisplayPort
&
&
displayPort
.
IsEqualEdges
(
oldDisplayPort
)
&
&
!
HasPerspective
(
)
&
&
!
HasBgAttachmentLocal
(
)
&
&
!
mHasOutOfFlowContentInsideFilter
)
{
bool
haveScrollLinkedEffects
=
content
-
>
GetComposedDoc
(
)
-
>
HasScrollLinkedEffect
(
)
;
bool
apzDisabled
=
haveScrollLinkedEffects
&
&
gfxPrefs
:
:
APZDisableForScrollLinkedEffects
(
)
;
if
(
!
apzDisabled
&
&
!
HasPluginFrames
(
)
)
{
if
(
LastScrollOrigin
(
)
=
=
nsGkAtoms
:
:
apz
)
{
schedulePaint
=
false
;
PAINT_SKIP_LOG
(
"
Skipping
due
to
APZ
scroll
\
n
"
)
;
}
else
if
(
mScrollableByAPZ
)
{
nsIWidget
*
widget
=
presContext
-
>
GetNearestWidget
(
)
;
LayerManager
*
manager
=
widget
?
widget
-
>
GetLayerManager
(
)
:
nullptr
;
if
(
manager
)
{
mozilla
:
:
layers
:
:
ScrollableLayerGuid
:
:
ViewID
id
;
bool
success
=
nsLayoutUtils
:
:
FindIDFor
(
content
&
id
)
;
MOZ_ASSERT
(
success
)
;
success
=
manager
-
>
SetPendingScrollUpdateForNextTransaction
(
id
{
mScrollGeneration
CSSPoint
:
:
FromAppUnits
(
GetScrollPosition
(
)
)
CSSPoint
:
:
FromAppUnits
(
GetApzScrollPosition
(
)
)
mLastScrollOrigin
=
=
nsGkAtoms
:
:
relative
}
)
;
if
(
success
)
{
schedulePaint
=
false
;
mOuter
-
>
SchedulePaint
(
nsIFrame
:
:
PAINT_COMPOSITE_ONLY
)
;
PAINT_SKIP_LOG
(
"
Skipping
due
to
APZ
-
forwarded
main
-
thread
scroll
\
n
"
)
;
}
else
{
PAINT_SKIP_LOG
(
"
Failed
to
set
pending
scroll
update
on
layer
manager
\
n
"
)
;
}
}
}
}
}
}
if
(
schedulePaint
)
{
mOuter
-
>
SchedulePaint
(
)
;
if
(
needFrameVisibilityUpdate
)
{
presContext
-
>
PresShell
(
)
-
>
ScheduleApproximateFrameVisibilityUpdateNow
(
)
;
}
}
if
(
mOuter
-
>
ChildrenHavePerspective
(
)
)
{
mOuter
-
>
RecomputePerspectiveChildrenOverflow
(
mOuter
)
;
mScrolledFrame
-
>
UpdateOverflow
(
)
;
mOuter
-
>
UpdateOverflow
(
)
;
}
ScheduleSyntheticMouseMove
(
)
;
{
AutoScrollbarRepaintSuppression
repaintSuppression
(
this
!
schedulePaint
)
;
AutoWeakFrame
weakFrame
(
mOuter
)
;
UpdateScrollbarPosition
(
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
;
}
}
presContext
-
>
RecordInteractionTime
(
nsPresContext
:
:
InteractionType
:
:
eScrollInteraction
TimeStamp
:
:
Now
(
)
)
;
PostScrollEvent
(
)
;
if
(
mIsRoot
)
{
if
(
auto
*
window
=
nsGlobalWindowInner
:
:
Cast
(
mOuter
-
>
PresContext
(
)
-
>
Document
(
)
-
>
GetInnerWindow
(
)
)
)
{
window
-
>
VisualViewport
(
)
-
>
PostScrollEvent
(
presContext
-
>
PresShell
(
)
-
>
GetVisualViewportOffset
(
)
curPos
)
;
}
}
for
(
uint32_t
i
=
0
;
i
<
mListeners
.
Length
(
)
;
i
+
+
)
{
mListeners
[
i
]
-
>
ScrollPositionDidChange
(
pt
.
x
pt
.
y
)
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
=
presContext
-
>
GetDocShell
(
)
;
if
(
docShell
)
{
docShell
-
>
NotifyScrollObservers
(
)
;
}
}
static
Maybe
<
int32_t
>
MaxZIndexInList
(
nsDisplayList
*
aList
nsDisplayListBuilder
*
aBuilder
)
{
Maybe
<
int32_t
>
maxZIndex
=
Nothing
(
)
;
for
(
nsDisplayItem
*
item
=
aList
-
>
GetBottom
(
)
;
item
;
item
=
item
-
>
GetAbove
(
)
)
{
if
(
!
maxZIndex
)
{
maxZIndex
=
Some
(
item
-
>
ZIndex
(
)
)
;
}
else
{
maxZIndex
=
Some
(
std
:
:
max
(
maxZIndex
.
value
(
)
item
-
>
ZIndex
(
)
)
)
;
}
}
return
maxZIndex
;
}
template
<
class
T
>
static
void
AppendInternalItemToTop
(
const
nsDisplayListSet
&
aLists
T
*
aItem
const
Maybe
<
int32_t
>
&
aZIndex
)
{
if
(
aZIndex
)
{
aItem
-
>
SetOverrideZIndex
(
aZIndex
.
value
(
)
)
;
aLists
.
PositionedDescendants
(
)
-
>
AppendToTop
(
aItem
)
;
}
else
{
aLists
.
Content
(
)
-
>
AppendToTop
(
aItem
)
;
}
}
static
const
uint32_t
APPEND_OWN_LAYER
=
0x1
;
static
const
uint32_t
APPEND_POSITIONED
=
0x2
;
static
const
uint32_t
APPEND_SCROLLBAR_CONTAINER
=
0x4
;
static
const
uint32_t
APPEND_OVERLAY
=
0x8
;
static
const
uint32_t
APPEND_TOP
=
0x10
;
static
void
AppendToTop
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
nsDisplayList
*
aSource
nsIFrame
*
aSourceFrame
uint32_t
aFlags
)
{
if
(
aSource
-
>
IsEmpty
(
)
)
return
;
nsDisplayWrapList
*
newItem
;
const
ActiveScrolledRoot
*
asr
=
aBuilder
-
>
CurrentActiveScrolledRoot
(
)
;
if
(
aFlags
&
APPEND_OWN_LAYER
)
{
ScrollbarData
scrollbarData
;
if
(
aFlags
&
APPEND_SCROLLBAR_CONTAINER
)
{
scrollbarData
=
ScrollbarData
:
:
CreateForScrollbarContainer
(
aBuilder
-
>
GetCurrentScrollbarDirection
(
)
aBuilder
-
>
GetCurrentScrollbarTarget
(
)
)
;
MOZ_ASSERT
(
scrollbarData
.
mDirection
.
isSome
(
)
)
;
}
newItem
=
MakeDisplayItem
<
nsDisplayOwnLayer
>
(
aBuilder
aSourceFrame
aSource
asr
nsDisplayOwnLayerFlags
:
:
eNone
scrollbarData
)
;
}
else
{
newItem
=
MakeDisplayItem
<
nsDisplayWrapList
>
(
aBuilder
aSourceFrame
aSource
asr
false
1
)
;
}
if
(
aFlags
&
APPEND_POSITIONED
)
{
Maybe
<
int32_t
>
zIndex
=
Nothing
(
)
;
if
(
aFlags
&
APPEND_TOP
)
{
zIndex
=
Some
(
INT32_MAX
)
;
}
else
if
(
aFlags
&
APPEND_OVERLAY
)
{
zIndex
=
MaxZIndexInList
(
aLists
.
PositionedDescendants
(
)
aBuilder
)
;
}
else
if
(
aSourceFrame
-
>
StylePosition
(
)
-
>
mZIndex
.
GetUnit
(
)
=
=
eStyleUnit_Integer
)
{
zIndex
=
Some
(
aSourceFrame
-
>
StylePosition
(
)
-
>
mZIndex
.
GetIntValue
(
)
)
;
}
AppendInternalItemToTop
(
aLists
newItem
zIndex
)
;
}
else
{
aLists
.
BorderBackground
(
)
-
>
AppendToTop
(
newItem
)
;
}
}
struct
HoveredStateComparator
{
static
bool
Hovered
(
const
nsIFrame
*
aFrame
)
{
return
aFrame
-
>
GetContent
(
)
-
>
IsElement
(
)
&
&
aFrame
-
>
GetContent
(
)
-
>
AsElement
(
)
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
hover
)
;
}
bool
Equals
(
nsIFrame
*
A
nsIFrame
*
B
)
const
{
return
Hovered
(
A
)
=
=
Hovered
(
B
)
;
}
bool
LessThan
(
nsIFrame
*
A
nsIFrame
*
B
)
const
{
return
!
Hovered
(
A
)
&
&
Hovered
(
B
)
;
}
}
;
void
ScrollFrameHelper
:
:
AppendScrollPartsTo
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
bool
aCreateLayer
bool
aPositioned
)
{
const
bool
overlayScrollbars
=
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
eIntID_UseOverlayScrollbars
)
!
=
0
;
AutoTArray
<
nsIFrame
*
3
>
scrollParts
;
for
(
nsIFrame
*
kid
:
mOuter
-
>
PrincipalChildList
(
)
)
{
if
(
kid
=
=
mScrolledFrame
|
|
(
kid
-
>
IsAbsPosContainingBlock
(
)
|
|
overlayScrollbars
)
!
=
aPositioned
)
{
continue
;
}
scrollParts
.
AppendElement
(
kid
)
;
}
if
(
scrollParts
.
IsEmpty
(
)
)
{
return
;
}
const
mozilla
:
:
layers
:
:
ScrollableLayerGuid
:
:
ViewID
scrollTargetId
=
IsMaybeScrollingActive
(
)
?
nsLayoutUtils
:
:
FindOrCreateIDFor
(
mScrolledFrame
-
>
GetContent
(
)
)
:
mozilla
:
:
layers
:
:
ScrollableLayerGuid
:
:
NULL_SCROLL_ID
;
scrollParts
.
Sort
(
HoveredStateComparator
(
)
)
;
DisplayListClipState
:
:
AutoSaveRestore
clipState
(
aBuilder
)
;
if
(
mIsRoot
)
{
clipState
.
ClipContentDescendants
(
mOuter
-
>
GetRectRelativeToSelf
(
)
+
aBuilder
-
>
ToReferenceFrame
(
mOuter
)
)
;
}
for
(
uint32_t
i
=
0
;
i
<
scrollParts
.
Length
(
)
;
+
+
i
)
{
Maybe
<
ScrollDirection
>
scrollDirection
;
uint32_t
appendToTopFlags
=
0
;
if
(
scrollParts
[
i
]
=
=
mVScrollbarBox
)
{
scrollDirection
.
emplace
(
ScrollDirection
:
:
eVertical
)
;
appendToTopFlags
|
=
APPEND_SCROLLBAR_CONTAINER
;
}
if
(
scrollParts
[
i
]
=
=
mHScrollbarBox
)
{
MOZ_ASSERT
(
!
scrollDirection
.
isSome
(
)
)
;
scrollDirection
.
emplace
(
ScrollDirection
:
:
eHorizontal
)
;
appendToTopFlags
|
=
APPEND_SCROLLBAR_CONTAINER
;
}
if
(
scrollParts
[
i
]
=
=
mResizerBox
&
&
!
HasResizer
(
)
)
{
continue
;
}
const
nsRect
visible
=
mIsRoot
&
&
mOuter
-
>
PresContext
(
)
-
>
IsRootContentDocument
(
)
?
scrollParts
[
i
]
-
>
GetVisualOverflowRectRelativeToParent
(
)
:
aBuilder
-
>
GetVisibleRect
(
)
;
if
(
visible
.
IsEmpty
(
)
)
{
continue
;
}
const
nsRect
dirty
=
mIsRoot
&
&
mOuter
-
>
PresContext
(
)
-
>
IsRootContentDocument
(
)
?
scrollParts
[
i
]
-
>
GetVisualOverflowRectRelativeToParent
(
)
:
aBuilder
-
>
GetDirtyRect
(
)
;
const
bool
isOverlayScrollbar
=
scrollDirection
.
isSome
(
)
&
&
overlayScrollbars
;
const
bool
createLayer
=
aCreateLayer
|
|
isOverlayScrollbar
|
|
gfxPrefs
:
:
AlwaysLayerizeScrollbarTrackTestOnly
(
)
;
nsDisplayListCollection
partList
(
aBuilder
)
;
{
nsDisplayListBuilder
:
:
AutoBuildingDisplayList
buildingForChild
(
aBuilder
mOuter
visible
dirty
true
)
;
nsDisplayListBuilder
:
:
AutoCurrentScrollbarInfoSetter
infoSetter
(
aBuilder
scrollTargetId
scrollDirection
createLayer
)
;
mOuter
-
>
BuildDisplayListForChild
(
aBuilder
scrollParts
[
i
]
partList
nsIFrame
:
:
DISPLAY_CHILD_FORCE_STACKING_CONTEXT
)
;
}
if
(
partList
.
PositionedDescendants
(
)
-
>
IsEmpty
(
)
)
{
continue
;
}
if
(
createLayer
)
{
appendToTopFlags
|
=
APPEND_OWN_LAYER
;
}
if
(
aPositioned
)
{
appendToTopFlags
|
=
APPEND_POSITIONED
;
}
if
(
isOverlayScrollbar
|
|
scrollParts
[
i
]
=
=
mResizerBox
)
{
if
(
isOverlayScrollbar
&
&
mIsRoot
)
{
appendToTopFlags
|
=
APPEND_TOP
;
}
else
{
appendToTopFlags
|
=
APPEND_OVERLAY
;
aBuilder
-
>
SetDisablePartialUpdates
(
true
)
;
}
}
{
nsDisplayListBuilder
:
:
AutoBuildingDisplayList
buildingForChild
(
aBuilder
scrollParts
[
i
]
visible
+
mOuter
-
>
GetOffsetTo
(
scrollParts
[
i
]
)
dirty
+
mOuter
-
>
GetOffsetTo
(
scrollParts
[
i
]
)
true
)
;
nsDisplayListBuilder
:
:
AutoCurrentScrollbarInfoSetter
infoSetter
(
aBuilder
scrollTargetId
scrollDirection
createLayer
)
;
:
:
AppendToTop
(
aBuilder
aLists
partList
.
PositionedDescendants
(
)
scrollParts
[
i
]
appendToTopFlags
)
;
}
}
}
bool
ScrollFrameHelper
:
:
sFrameVisPrefsCached
=
false
;
uint32_t
ScrollFrameHelper
:
:
sHorzExpandScrollPort
=
0
;
uint32_t
ScrollFrameHelper
:
:
sVertExpandScrollPort
=
1
;
int32_t
ScrollFrameHelper
:
:
sHorzScrollFraction
=
2
;
int32_t
ScrollFrameHelper
:
:
sVertScrollFraction
=
2
;
void
ScrollFrameHelper
:
:
EnsureFrameVisPrefsCached
(
)
{
if
(
!
sFrameVisPrefsCached
)
{
Preferences
:
:
AddUintVarCache
(
&
sHorzExpandScrollPort
"
layout
.
framevisibility
.
numscrollportwidths
"
(
uint32_t
)
0
)
;
Preferences
:
:
AddUintVarCache
(
&
sVertExpandScrollPort
"
layout
.
framevisibility
.
numscrollportheights
"
1
)
;
Preferences
:
:
AddIntVarCache
(
&
sHorzScrollFraction
"
layout
.
framevisibility
.
amountscrollbeforeupdatehorizontal
"
2
)
;
Preferences
:
:
AddIntVarCache
(
&
sVertScrollFraction
"
layout
.
framevisibility
.
amountscrollbeforeupdatevertical
"
2
)
;
sFrameVisPrefsCached
=
true
;
}
}
nsRect
ScrollFrameHelper
:
:
ExpandRectToNearlyVisible
(
const
nsRect
&
aRect
)
const
{
nsRect
scrollRange
=
GetScrollRangeForClamping
(
)
;
nsPoint
scrollPos
=
GetScrollPosition
(
)
;
nsMargin
expand
(
0
0
0
0
)
;
nscoord
vertShift
=
sVertExpandScrollPort
*
aRect
.
height
;
if
(
scrollRange
.
y
<
scrollPos
.
y
)
{
expand
.
top
=
vertShift
;
}
if
(
scrollPos
.
y
<
scrollRange
.
YMost
(
)
)
{
expand
.
bottom
=
vertShift
;
}
nscoord
horzShift
=
sHorzExpandScrollPort
*
aRect
.
width
;
if
(
scrollRange
.
x
<
scrollPos
.
x
)
{
expand
.
left
=
horzShift
;
}
if
(
scrollPos
.
x
<
scrollRange
.
XMost
(
)
)
{
expand
.
right
=
horzShift
;
}
nsRect
rect
=
aRect
;
rect
.
Inflate
(
expand
)
;
return
rect
;
}
static
bool
ShouldBeClippedByFrame
(
nsIFrame
*
aClipFrame
nsIFrame
*
aClippedFrame
)
{
return
nsLayoutUtils
:
:
IsProperAncestorFrame
(
aClipFrame
aClippedFrame
)
;
}
static
void
ClipItemsExceptCaret
(
nsDisplayList
*
aList
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aClipFrame
const
DisplayItemClipChain
*
aExtraClip
nsDataHashtable
<
nsPtrHashKey
<
const
DisplayItemClipChain
>
const
DisplayItemClipChain
*
>
&
aCache
)
{
for
(
nsDisplayItem
*
i
=
aList
-
>
GetBottom
(
)
;
i
;
i
=
i
-
>
GetAbove
(
)
)
{
if
(
!
ShouldBeClippedByFrame
(
aClipFrame
i
-
>
Frame
(
)
)
)
{
continue
;
}
if
(
i
-
>
GetType
(
)
!
=
DisplayItemType
:
:
TYPE_CARET
)
{
const
DisplayItemClipChain
*
clip
=
i
-
>
GetClipChain
(
)
;
const
DisplayItemClipChain
*
intersection
=
nullptr
;
if
(
aCache
.
Get
(
clip
&
intersection
)
)
{
i
-
>
SetClipChain
(
intersection
true
)
;
}
else
{
i
-
>
IntersectClip
(
aBuilder
aExtraClip
true
)
;
aCache
.
Put
(
clip
i
-
>
GetClipChain
(
)
)
;
}
}
nsDisplayList
*
children
=
i
-
>
GetSameCoordinateSystemChildren
(
)
;
if
(
children
)
{
ClipItemsExceptCaret
(
children
aBuilder
aClipFrame
aExtraClip
aCache
)
;
}
}
}
static
void
ClipListsExceptCaret
(
nsDisplayListCollection
*
aLists
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aClipFrame
const
DisplayItemClipChain
*
aExtraClip
)
{
nsDataHashtable
<
nsPtrHashKey
<
const
DisplayItemClipChain
>
const
DisplayItemClipChain
*
>
cache
;
ClipItemsExceptCaret
(
aLists
-
>
BorderBackground
(
)
aBuilder
aClipFrame
aExtraClip
cache
)
;
ClipItemsExceptCaret
(
aLists
-
>
BlockBorderBackgrounds
(
)
aBuilder
aClipFrame
aExtraClip
cache
)
;
ClipItemsExceptCaret
(
aLists
-
>
Floats
(
)
aBuilder
aClipFrame
aExtraClip
cache
)
;
ClipItemsExceptCaret
(
aLists
-
>
PositionedDescendants
(
)
aBuilder
aClipFrame
aExtraClip
cache
)
;
ClipItemsExceptCaret
(
aLists
-
>
Outlines
(
)
aBuilder
aClipFrame
aExtraClip
cache
)
;
ClipItemsExceptCaret
(
aLists
-
>
Content
(
)
aBuilder
aClipFrame
aExtraClip
cache
)
;
}
void
ScrollFrameHelper
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
SetAndNullOnExit
<
const
nsIFrame
>
tmpBuilder
(
mReferenceFrameDuringPainting
aBuilder
-
>
GetCurrentReferenceFrame
(
)
)
;
if
(
aBuilder
-
>
IsForFrameVisibility
(
)
)
{
NotifyApproximateFrameVisibilityUpdate
(
false
)
;
}
mOuter
-
>
DisplayBorderBackgroundOutline
(
aBuilder
aLists
)
;
if
(
aBuilder
-
>
IsPaintingToWindow
(
)
)
{
if
(
IsMaybeScrollingActive
(
)
)
{
if
(
mScrollPosForLayerPixelAlignment
=
=
nsPoint
(
-
1
-
1
)
)
{
mScrollPosForLayerPixelAlignment
=
GetScrollPosition
(
)
;
}
}
else
{
mScrollPosForLayerPixelAlignment
=
nsPoint
(
-
1
-
1
)
;
}
}
bool
ignoringThisScrollFrame
=
aBuilder
-
>
GetIgnoreScrollFrame
(
)
=
=
mOuter
;
nsRect
visibleRect
=
aBuilder
-
>
GetVisibleRect
(
)
;
nsRect
dirtyRect
=
aBuilder
-
>
GetDirtyRect
(
)
;
if
(
!
ignoringThisScrollFrame
)
{
visibleRect
=
visibleRect
.
Intersect
(
mScrollPort
)
;
dirtyRect
=
dirtyRect
.
Intersect
(
mScrollPort
)
;
}
bool
dirtyRectHasBeenOverriden
=
false
;
Unused
<
<
DecideScrollableLayer
(
aBuilder
&
visibleRect
&
dirtyRect
!
mIsRoot
&
dirtyRectHasBeenOverriden
)
;
if
(
aBuilder
-
>
IsForFrameVisibility
(
)
)
{
dirtyRect
=
ExpandRectToNearlyVisible
(
dirtyRect
)
;
visibleRect
=
dirtyRect
;
}
bool
createLayersForScrollbars
=
mIsRoot
&
&
mOuter
-
>
PresContext
(
)
-
>
IsRootContentDocument
(
)
;
nsIScrollableFrame
*
sf
=
do_QueryFrame
(
mOuter
)
;
MOZ_ASSERT
(
sf
)
;
bool
isRcdRsf
=
mIsRoot
&
&
mOuter
-
>
PresContext
(
)
-
>
IsRootContentDocument
(
)
;
if
(
ignoringThisScrollFrame
)
{
mAddClipRectToLayer
=
false
;
bool
addScrollBars
=
mIsRoot
&
&
mWillBuildScrollableLayer
&
&
aBuilder
-
>
IsPaintingToWindow
(
)
;
if
(
addScrollBars
)
{
AppendScrollPartsTo
(
aBuilder
aLists
createLayersForScrollbars
false
)
;
}
{
nsDisplayListBuilder
:
:
AutoCurrentActiveScrolledRootSetter
asrSetter
(
aBuilder
)
;
if
(
aBuilder
-
>
IsPaintingToWindow
(
)
&
&
gfxPrefs
:
:
LayoutUseContainersForRootFrames
(
)
&
&
mIsRoot
)
{
asrSetter
.
EnterScrollFrame
(
sf
)
;
if
(
isRcdRsf
)
{
aBuilder
-
>
SetActiveScrolledRootForRootScrollframe
(
aBuilder
-
>
CurrentActiveScrolledRoot
(
)
)
;
}
}
nsDisplayListBuilder
:
:
AutoBuildingDisplayList
building
(
aBuilder
mOuter
visibleRect
dirtyRect
aBuilder
-
>
IsAtRootOfPseudoStackingContext
(
)
)
;
mOuter
-
>
BuildDisplayListForChild
(
aBuilder
mScrolledFrame
aLists
)
;
}
if
(
addScrollBars
)
{
AppendScrollPartsTo
(
aBuilder
aLists
createLayersForScrollbars
true
)
;
}
return
;
}
mAddClipRectToLayer
=
!
(
mIsRoot
&
&
mOuter
-
>
PresShell
(
)
-
>
GetIsViewportOverridden
(
)
)
;
bool
couldBuildLayer
=
false
;
if
(
aBuilder
-
>
IsPaintingToWindow
(
)
)
{
if
(
mWillBuildScrollableLayer
)
{
couldBuildLayer
=
true
;
}
else
{
couldBuildLayer
=
nsLayoutUtils
:
:
AsyncPanZoomEnabled
(
mOuter
)
&
&
WantAsyncScroll
(
)
&
&
(
!
(
gfxPrefs
:
:
LayoutUseContainersForRootFrames
(
)
&
&
mIsRoot
)
|
|
(
aBuilder
-
>
RootReferenceFrame
(
)
-
>
PresContext
(
)
!
=
mOuter
-
>
PresContext
(
)
)
)
;
}
}
AppendScrollPartsTo
(
aBuilder
aLists
createLayersForScrollbars
false
)
;
const
nsStyleDisplay
*
disp
=
mOuter
-
>
StyleDisplay
(
)
;
if
(
disp
&
&
(
disp
-
>
mWillChangeBitField
&
NS_STYLE_WILL_CHANGE_SCROLL
)
)
{
aBuilder
-
>
AddToWillChangeBudget
(
mOuter
GetVisualViewportSize
(
)
)
;
}
mScrollParentID
=
aBuilder
-
>
GetCurrentScrollParentId
(
)
;
Maybe
<
nsRect
>
contentBoxClip
;
Maybe
<
const
DisplayItemClipChain
*
>
extraContentBoxClipForNonCaretContent
;
if
(
MOZ_UNLIKELY
(
disp
-
>
mOverflowClipBoxBlock
=
=
StyleOverflowClipBox
:
:
ContentBox
|
|
disp
-
>
mOverflowClipBoxInline
=
=
StyleOverflowClipBox
:
:
ContentBox
)
)
{
WritingMode
wm
=
mScrolledFrame
-
>
GetWritingMode
(
)
;
bool
cbH
=
(
wm
.
IsVertical
(
)
?
disp
-
>
mOverflowClipBoxBlock
:
disp
-
>
mOverflowClipBoxInline
)
=
=
StyleOverflowClipBox
:
:
ContentBox
;
bool
cbV
=
(
wm
.
IsVertical
(
)
?
disp
-
>
mOverflowClipBoxInline
:
disp
-
>
mOverflowClipBoxBlock
)
=
=
StyleOverflowClipBox
:
:
ContentBox
;
nsRect
clipRect
=
mScrollPort
+
aBuilder
-
>
ToReferenceFrame
(
mOuter
)
;
nsRect
so
=
mScrolledFrame
-
>
GetScrollableOverflowRect
(
)
;
if
(
(
cbH
&
&
(
clipRect
.
width
!
=
so
.
width
|
|
so
.
x
<
0
)
)
|
|
(
cbV
&
&
(
clipRect
.
height
!
=
so
.
height
|
|
so
.
y
<
0
)
)
)
{
nsMargin
padding
=
mOuter
-
>
GetUsedPadding
(
)
;
if
(
!
cbH
)
{
padding
.
left
=
padding
.
right
=
nscoord
(
0
)
;
}
if
(
!
cbV
)
{
padding
.
top
=
padding
.
bottom
=
nscoord
(
0
)
;
}
clipRect
.
Deflate
(
padding
)
;
const
ActiveScrolledRoot
*
asr
=
aBuilder
-
>
CurrentActiveScrolledRoot
(
)
;
DisplayItemClip
newClip
;
newClip
.
SetTo
(
clipRect
)
;
const
DisplayItemClipChain
*
extraClip
=
aBuilder
-
>
AllocateDisplayItemClipChain
(
newClip
asr
nullptr
)
;
extraContentBoxClipForNonCaretContent
=
Some
(
extraClip
)
;
nsIFrame
*
caretFrame
=
aBuilder
-
>
GetCaretFrame
(
)
;
if
(
caretFrame
&
&
caretFrame
-
>
GetRect
(
)
.
height
!
=
0
)
{
nsRect
caretRect
=
aBuilder
-
>
GetCaretRect
(
)
;
nsRect
inflatedClip
=
clipRect
;
inflatedClip
.
Inflate
(
nsMargin
(
caretRect
.
height
/
2
caretRect
.
width
0
0
)
)
;
contentBoxClip
=
Some
(
inflatedClip
)
;
}
}
}
nsDisplayListCollection
scrolledContent
(
aBuilder
)
;
{
nsDisplayListBuilder
:
:
AutoCurrentScrollParentIdSetter
idSetter
(
aBuilder
couldBuildLayer
&
&
mScrolledFrame
-
>
GetContent
(
)
?
nsLayoutUtils
:
:
FindOrCreateIDFor
(
mScrolledFrame
-
>
GetContent
(
)
)
:
aBuilder
-
>
GetCurrentScrollParentId
(
)
)
;
nsRect
clipRect
=
mScrollPort
+
aBuilder
-
>
ToReferenceFrame
(
mOuter
)
;
nscoord
radii
[
8
]
;
bool
haveRadii
=
mOuter
-
>
GetPaddingBoxBorderRadii
(
radii
)
;
if
(
mIsRoot
)
{
clipRect
.
SizeTo
(
nsLayoutUtils
:
:
CalculateCompositionSizeForFrame
(
mOuter
)
)
;
if
(
mOuter
-
>
PresContext
(
)
-
>
IsRootContentDocument
(
)
)
{
double
res
=
mOuter
-
>
PresShell
(
)
-
>
GetResolution
(
)
;
clipRect
.
width
=
NSToCoordRound
(
clipRect
.
width
/
res
)
;
clipRect
.
height
=
NSToCoordRound
(
clipRect
.
height
/
res
)
;
}
}
DisplayListClipState
:
:
AutoSaveRestore
clipState
(
aBuilder
)
;
if
(
mClipAllDescendants
)
{
clipState
.
ClipContentDescendants
(
clipRect
haveRadii
?
radii
:
nullptr
)
;
}
else
{
clipState
.
ClipContainingBlockDescendants
(
clipRect
haveRadii
?
radii
:
nullptr
)
;
}
Maybe
<
DisplayListClipState
:
:
AutoSaveRestore
>
contentBoxClipState
;
;
if
(
contentBoxClip
)
{
contentBoxClipState
.
emplace
(
aBuilder
)
;
if
(
mClipAllDescendants
)
{
contentBoxClipState
-
>
ClipContentDescendants
(
*
contentBoxClip
)
;
}
else
{
contentBoxClipState
-
>
ClipContainingBlockDescendants
(
*
contentBoxClip
)
;
}
}
nsDisplayListBuilder
:
:
AutoCurrentActiveScrolledRootSetter
asrSetter
(
aBuilder
)
;
if
(
mWillBuildScrollableLayer
&
&
aBuilder
-
>
IsPaintingToWindow
(
)
)
{
asrSetter
.
EnterScrollFrame
(
sf
)
;
}
if
(
mIsScrollableLayerInRootContainer
&
&
isRcdRsf
)
{
aBuilder
-
>
SetActiveScrolledRootForRootScrollframe
(
aBuilder
-
>
CurrentActiveScrolledRoot
(
)
)
;
}
if
(
mWillBuildScrollableLayer
&
&
aBuilder
-
>
BuildCompositorHitTestInfo
(
)
)
{
CompositorHitTestInfo
info
=
mScrolledFrame
-
>
GetCompositorHitTestInfo
(
aBuilder
)
;
if
(
info
!
=
CompositorHitTestInvisibleToHit
)
{
auto
*
hitInfo
=
MakeDisplayItem
<
nsDisplayCompositorHitTestInfo
>
(
aBuilder
mScrolledFrame
info
1
)
;
aBuilder
-
>
SetCompositorHitTestInfo
(
hitInfo
-
>
HitTestArea
(
)
hitInfo
-
>
HitTestFlags
(
)
)
;
scrolledContent
.
BorderBackground
(
)
-
>
AppendToTop
(
hitInfo
)
;
}
}
{
DisplayListClipState
:
:
AutoSaveRestore
scrolledRectClipState
(
aBuilder
)
;
nsRect
scrolledRectClip
=
GetUnsnappedScrolledRectInternal
(
mScrolledFrame
-
>
GetScrollableOverflowRect
(
)
mScrollPort
.
Size
(
)
)
+
mScrolledFrame
-
>
GetPosition
(
)
;
if
(
mWillBuildScrollableLayer
&
&
aBuilder
-
>
IsPaintingToWindow
(
)
)
{
scrolledRectClip
=
scrolledRectClip
.
Intersect
(
visibleRect
)
;
}
scrolledRectClipState
.
ClipContainingBlockDescendants
(
scrolledRectClip
+
aBuilder
-
>
ToReferenceFrame
(
mOuter
)
)
;
nsDisplayListBuilder
:
:
AutoBuildingDisplayList
building
(
aBuilder
mOuter
visibleRect
dirtyRect
aBuilder
-
>
IsAtRootOfPseudoStackingContext
(
)
)
;
mOuter
-
>
BuildDisplayListForChild
(
aBuilder
mScrolledFrame
scrolledContent
)
;
if
(
dirtyRectHasBeenOverriden
&
&
gfxPrefs
:
:
LayoutDisplayListShowArea
(
)
)
{
nsDisplaySolidColor
*
color
=
MakeDisplayItem
<
nsDisplaySolidColor
>
(
aBuilder
mOuter
dirtyRect
+
aBuilder
-
>
GetCurrentFrameOffsetToReferenceFrame
(
)
NS_RGBA
(
0
0
255
64
)
false
)
;
color
-
>
SetOverrideZIndex
(
INT32_MAX
)
;
scrolledContent
.
PositionedDescendants
(
)
-
>
AppendToTop
(
color
)
;
}
}
if
(
extraContentBoxClipForNonCaretContent
)
{
ClipListsExceptCaret
(
&
scrolledContent
aBuilder
mScrolledFrame
*
extraContentBoxClipForNonCaretContent
)
;
}
if
(
aBuilder
-
>
IsPaintingToWindow
(
)
)
{
mIsScrollParent
=
idSetter
.
ShouldForceLayerForScrollParent
(
)
;
}
if
(
idSetter
.
ShouldForceLayerForScrollParent
(
)
&
&
!
gfxPrefs
:
:
LayoutUseContainersForRootFrames
(
)
)
{
MOZ_ASSERT
(
couldBuildLayer
&
&
mScrolledFrame
-
>
GetContent
(
)
&
&
aBuilder
-
>
IsPaintingToWindow
(
)
)
;
if
(
!
mWillBuildScrollableLayer
)
{
nsLayoutUtils
:
:
SetDisplayPortMargins
(
mOuter
-
>
GetContent
(
)
mOuter
-
>
PresShell
(
)
ScreenMargin
(
)
0
nsLayoutUtils
:
:
RepaintMode
:
:
DoNotRepaint
)
;
nsRect
copyOfDirtyRect
=
dirtyRect
;
nsRect
copyOfVisibleRect
=
visibleRect
;
Unused
<
<
DecideScrollableLayer
(
aBuilder
&
copyOfVisibleRect
&
copyOfDirtyRect
false
nullptr
)
;
if
(
mWillBuildScrollableLayer
)
{
asrSetter
.
InsertScrollFrame
(
sf
)
;
aBuilder
-
>
SetDisablePartialUpdates
(
true
)
;
}
}
}
}
if
(
mWillBuildScrollableLayer
&
&
aBuilder
-
>
IsPaintingToWindow
(
)
)
{
aBuilder
-
>
ForceLayerForScrollParent
(
)
;
}
if
(
couldBuildLayer
)
{
if
(
!
mWillBuildScrollableLayer
)
{
if
(
aBuilder
-
>
BuildCompositorHitTestInfo
(
)
)
{
CompositorHitTestInfo
info
(
CompositorHitTestFlags
:
:
eVisibleToHitTest
CompositorHitTestFlags
:
:
eDispatchToContent
)
;
ScrollStyles
scrollStyles
=
GetScrollStylesFromFrame
(
)
;
if
(
scrollStyles
.
mOverscrollBehaviorX
!
=
StyleOverscrollBehavior
:
:
Auto
|
|
scrollStyles
.
mOverscrollBehaviorY
!
=
StyleOverscrollBehavior
:
:
Auto
)
{
info
+
=
CompositorHitTestFlags
:
:
eRequiresTargetConfirmation
;
}
nsDisplayCompositorHitTestInfo
*
hitInfo
=
MakeDisplayItem
<
nsDisplayCompositorHitTestInfo
>
(
aBuilder
mScrolledFrame
info
1
Some
(
mScrollPort
+
aBuilder
-
>
ToReferenceFrame
(
mOuter
)
)
)
;
AppendInternalItemToTop
(
scrolledContent
hitInfo
Some
(
INT32_MAX
)
)
;
}
}
if
(
aBuilder
-
>
ShouldBuildScrollInfoItemsForHoisting
(
)
)
{
aBuilder
-
>
AppendNewScrollInfoItemForHoisting
(
MakeDisplayItem
<
nsDisplayScrollInfoLayer
>
(
aBuilder
mScrolledFrame
mOuter
)
)
;
}
}
AppendScrollPartsTo
(
aBuilder
scrolledContent
createLayersForScrollbars
true
)
;
scrolledContent
.
MoveTo
(
aLists
)
;
}
bool
ScrollFrameHelper
:
:
DecideScrollableLayer
(
nsDisplayListBuilder
*
aBuilder
nsRect
*
aVisibleRect
nsRect
*
aDirtyRect
bool
aSetBase
bool
*
aDirtyRectHasBeenOverriden
)
{
bool
oldWillBuildScrollableLayer
=
mWillBuildScrollableLayer
;
nsIContent
*
content
=
mOuter
-
>
GetContent
(
)
;
bool
usingDisplayPort
=
nsLayoutUtils
:
:
HasDisplayPort
(
content
)
;
if
(
aBuilder
-
>
IsPaintingToWindow
(
)
)
{
if
(
aSetBase
)
{
nsRect
displayportBase
=
*
aVisibleRect
;
nsPresContext
*
pc
=
mOuter
-
>
PresContext
(
)
;
if
(
mIsRoot
&
&
(
pc
-
>
IsRootContentDocument
(
)
|
|
!
pc
-
>
GetParentPresContext
(
)
)
)
{
displayportBase
=
nsRect
(
nsPoint
(
0
0
)
nsLayoutUtils
:
:
CalculateCompositionSizeForFrame
(
mOuter
)
)
;
}
else
{
displayportBase
=
aVisibleRect
-
>
Intersect
(
mScrollPort
)
;
if
(
usingDisplayPort
)
{
const
nsPresContext
*
rootPresContext
=
pc
-
>
GetToplevelContentDocumentPresContext
(
)
;
if
(
!
rootPresContext
)
{
rootPresContext
=
pc
-
>
GetRootPresContext
(
)
;
}
if
(
rootPresContext
)
{
const
nsIPresShell
*
const
rootPresShell
=
rootPresContext
-
>
PresShell
(
)
;
nsIFrame
*
rootFrame
=
rootPresShell
-
>
GetRootScrollFrame
(
)
;
if
(
!
rootFrame
)
{
rootFrame
=
rootPresShell
-
>
GetRootFrame
(
)
;
}
if
(
rootFrame
)
{
nsRect
rootCompBounds
=
nsRect
(
nsPoint
(
0
0
)
nsLayoutUtils
:
:
CalculateCompositionSizeForFrame
(
rootFrame
)
)
;
if
(
rootPresContext
-
>
IsRootContentDocument
(
)
&
&
rootFrame
=
=
rootPresShell
-
>
GetRootScrollFrame
(
)
)
{
rootCompBounds
=
rootCompBounds
.
RemoveResolution
(
rootPresShell
-
>
GetResolution
(
)
)
;
}
nsLayoutUtils
:
:
TransformRect
(
rootFrame
mOuter
rootCompBounds
)
;
rootCompBounds
+
=
CSSPoint
:
:
ToAppUnits
(
nsLayoutUtils
:
:
GetCumulativeApzCallbackTransform
(
mOuter
)
)
;
if
(
rootCompBounds
.
x
>
displayportBase
.
x
&
&
rootCompBounds
.
XMost
(
)
>
displayportBase
.
XMost
(
)
)
{
rootCompBounds
.
x
-
=
(
rootCompBounds
.
XMost
(
)
-
displayportBase
.
XMost
(
)
)
;
}
else
if
(
rootCompBounds
.
x
<
displayportBase
.
x
&
&
rootCompBounds
.
XMost
(
)
<
displayportBase
.
XMost
(
)
)
{
rootCompBounds
.
x
=
displayportBase
.
x
;
}
if
(
rootCompBounds
.
y
>
displayportBase
.
y
&
&
rootCompBounds
.
YMost
(
)
>
displayportBase
.
YMost
(
)
)
{
rootCompBounds
.
y
-
=
(
rootCompBounds
.
YMost
(
)
-
displayportBase
.
YMost
(
)
)
;
}
else
if
(
rootCompBounds
.
y
<
displayportBase
.
y
&
&
rootCompBounds
.
YMost
(
)
<
displayportBase
.
YMost
(
)
)
{
rootCompBounds
.
y
=
displayportBase
.
y
;
}
displayportBase
=
displayportBase
.
Intersect
(
rootCompBounds
)
;
}
}
}
displayportBase
-
=
mScrollPort
.
TopLeft
(
)
;
}
nsLayoutUtils
:
:
SetDisplayPortBase
(
mOuter
-
>
GetContent
(
)
displayportBase
)
;
}
MOZ_ASSERT
(
content
-
>
GetProperty
(
nsGkAtoms
:
:
DisplayPortBase
)
)
;
nsRect
displayPort
;
usingDisplayPort
=
nsLayoutUtils
:
:
GetDisplayPort
(
content
&
displayPort
RelativeTo
:
:
ScrollFrame
)
;
if
(
usingDisplayPort
)
{
*
aVisibleRect
=
displayPort
;
if
(
!
aBuilder
-
>
IsPartialUpdate
(
)
|
|
aBuilder
-
>
InInvalidSubtree
(
)
)
{
*
aDirtyRect
=
displayPort
;
if
(
aDirtyRectHasBeenOverriden
)
{
*
aDirtyRectHasBeenOverriden
=
true
;
}
}
else
if
(
mOuter
-
>
HasOverrideDirtyRegion
(
)
)
{
nsRect
*
rect
=
mOuter
-
>
GetProperty
(
nsDisplayListBuilder
:
:
DisplayListBuildingDisplayPortRect
(
)
)
;
if
(
rect
)
{
*
aDirtyRect
=
*
rect
;
if
(
aDirtyRectHasBeenOverriden
)
{
*
aDirtyRectHasBeenOverriden
=
true
;
}
}
}
}
else
if
(
mIsRoot
)
{
nsIPresShell
*
presShell
=
mOuter
-
>
PresShell
(
)
;
*
aVisibleRect
=
aVisibleRect
-
>
RemoveResolution
(
presShell
-
>
GetResolution
(
)
)
;
*
aDirtyRect
=
aDirtyRect
-
>
RemoveResolution
(
presShell
-
>
GetResolution
(
)
)
;
}
}
mWillBuildScrollableLayer
=
usingDisplayPort
|
|
nsContentUtils
:
:
HasScrollgrab
(
content
)
;
if
(
oldWillBuildScrollableLayer
!
=
mWillBuildScrollableLayer
)
{
aBuilder
-
>
RecomputeCurrentAnimatedGeometryRoot
(
)
;
}
if
(
gfxPrefs
:
:
LayoutUseContainersForRootFrames
(
)
&
&
mWillBuildScrollableLayer
&
&
mIsRoot
)
{
mIsScrollableLayerInRootContainer
=
true
;
}
return
mWillBuildScrollableLayer
;
}
Maybe
<
ScrollMetadata
>
ScrollFrameHelper
:
:
ComputeScrollMetadata
(
LayerManager
*
aLayerManager
const
nsIFrame
*
aContainerReferenceFrame
const
Maybe
<
ContainerLayerParameters
>
&
aParameters
const
DisplayItemClip
*
aClip
)
const
{
if
(
!
mWillBuildScrollableLayer
|
|
mIsScrollableLayerInRootContainer
)
{
return
Nothing
(
)
;
}
if
(
!
nsLayoutUtils
:
:
UsesAsyncScrolling
(
mOuter
)
)
{
return
Nothing
(
)
;
}
nsPoint
toReferenceFrame
=
mOuter
-
>
GetOffsetToCrossDoc
(
aContainerReferenceFrame
)
;
Maybe
<
nsRect
>
parentLayerClip
;
if
(
aClip
&
&
(
!
gfxPrefs
:
:
LayoutUseContainersForRootFrames
(
)
|
|
mAddClipRectToLayer
)
)
{
parentLayerClip
=
Some
(
aClip
-
>
GetClipRect
(
)
)
;
}
bool
isRootContent
=
mIsRoot
&
&
mOuter
-
>
PresContext
(
)
-
>
IsRootContentDocument
(
)
;
MOZ_ASSERT
(
mScrolledFrame
-
>
GetContent
(
)
)
;
nsRect
scrollport
=
mScrollPort
+
toReferenceFrame
;
return
Some
(
nsLayoutUtils
:
:
ComputeScrollMetadata
(
mScrolledFrame
mOuter
mOuter
-
>
GetContent
(
)
aContainerReferenceFrame
aLayerManager
mScrollParentID
scrollport
parentLayerClip
isRootContent
aParameters
)
)
;
}
void
ScrollFrameHelper
:
:
ClipLayerToDisplayPort
(
Layer
*
aLayer
const
DisplayItemClip
*
aClip
const
ContainerLayerParameters
&
aParameters
)
const
{
if
(
!
nsLayoutUtils
:
:
UsesAsyncScrolling
(
mOuter
)
)
{
Maybe
<
nsRect
>
parentLayerClip
;
if
(
aClip
&
&
(
!
gfxPrefs
:
:
LayoutUseContainersForRootFrames
(
)
|
|
mAddClipRectToLayer
)
)
{
parentLayerClip
=
Some
(
aClip
-
>
GetClipRect
(
)
)
;
}
if
(
parentLayerClip
)
{
ParentLayerIntRect
displayportClip
=
ViewAs
<
ParentLayerPixel
>
(
parentLayerClip
-
>
ScaleToNearestPixels
(
aParameters
.
mXScale
aParameters
.
mYScale
mScrolledFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
)
;
ParentLayerIntRect
layerClip
;
if
(
const
ParentLayerIntRect
*
origClip
=
aLayer
-
>
GetClipRect
(
)
.
ptrOr
(
nullptr
)
)
{
layerClip
=
displayportClip
.
Intersect
(
*
origClip
)
;
}
else
{
layerClip
=
displayportClip
;
}
aLayer
-
>
SetClipRect
(
Some
(
layerClip
)
)
;
}
}
}
bool
ScrollFrameHelper
:
:
IsRectNearlyVisible
(
const
nsRect
&
aRect
)
const
{
nsRect
displayPort
;
bool
usingDisplayport
=
nsLayoutUtils
:
:
GetDisplayPort
(
mOuter
-
>
GetContent
(
)
&
displayPort
RelativeTo
:
:
ScrollFrame
)
;
return
aRect
.
Intersects
(
ExpandRectToNearlyVisible
(
usingDisplayport
?
displayPort
:
mScrollPort
)
)
;
}
static
void
HandleScrollPref
(
nsIScrollable
*
aScrollable
int32_t
aOrientation
StyleOverflow
&
aValue
)
{
int32_t
pref
;
aScrollable
-
>
GetDefaultScrollbarPreferences
(
aOrientation
&
pref
)
;
switch
(
pref
)
{
case
nsIScrollable
:
:
Scrollbar_Auto
:
break
;
case
nsIScrollable
:
:
Scrollbar_Never
:
aValue
=
StyleOverflow
:
:
Hidden
;
break
;
case
nsIScrollable
:
:
Scrollbar_Always
:
aValue
=
StyleOverflow
:
:
Scroll
;
break
;
}
}
ScrollStyles
ScrollFrameHelper
:
:
GetScrollStylesFromFrame
(
)
const
{
nsPresContext
*
presContext
=
mOuter
-
>
PresContext
(
)
;
if
(
!
presContext
-
>
IsDynamic
(
)
&
&
!
(
mIsRoot
&
&
presContext
-
>
HasPaginatedScrolling
(
)
)
)
{
return
ScrollStyles
(
StyleOverflow
:
:
Hidden
StyleOverflow
:
:
Hidden
)
;
}
if
(
!
mIsRoot
)
{
const
nsStyleDisplay
*
disp
=
mOuter
-
>
StyleDisplay
(
)
;
return
ScrollStyles
(
disp
)
;
}
ScrollStyles
result
=
presContext
-
>
GetViewportScrollStylesOverride
(
)
;
nsCOMPtr
<
nsISupports
>
container
=
presContext
-
>
GetContainerWeak
(
)
;
nsCOMPtr
<
nsIScrollable
>
scrollable
=
do_QueryInterface
(
container
)
;
if
(
scrollable
)
{
HandleScrollPref
(
scrollable
nsIScrollable
:
:
ScrollOrientation_X
result
.
mHorizontal
)
;
HandleScrollPref
(
scrollable
nsIScrollable
:
:
ScrollOrientation_Y
result
.
mVertical
)
;
}
return
result
;
}
nsRect
ScrollFrameHelper
:
:
GetScrollRange
(
)
const
{
return
GetScrollRange
(
mScrollPort
.
width
mScrollPort
.
height
)
;
}
nsRect
ScrollFrameHelper
:
:
GetScrollRange
(
nscoord
aWidth
nscoord
aHeight
)
const
{
nsRect
range
=
GetScrolledRect
(
)
;
range
.
width
=
std
:
:
max
(
range
.
width
-
aWidth
0
)
;
range
.
height
=
std
:
:
max
(
range
.
height
-
aHeight
0
)
;
return
range
;
}
nsRect
ScrollFrameHelper
:
:
GetScrollRangeForClamping
(
)
const
{
if
(
!
ShouldClampScrollPosition
(
)
)
{
return
nsRect
(
nscoord_MIN
/
2
nscoord_MIN
/
2
nscoord_MAX
-
nscoord_MIN
/
2
nscoord_MAX
-
nscoord_MIN
/
2
)
;
}
nsSize
visualViewportSize
=
GetVisualViewportSize
(
)
;
return
GetScrollRange
(
visualViewportSize
.
width
visualViewportSize
.
height
)
;
}
nsSize
ScrollFrameHelper
:
:
GetVisualViewportSize
(
)
const
{
nsIPresShell
*
presShell
=
mOuter
-
>
PresShell
(
)
;
if
(
mIsRoot
&
&
presShell
-
>
IsVisualViewportSizeSet
(
)
)
{
return
presShell
-
>
GetVisualViewportSize
(
)
;
}
return
mScrollPort
.
Size
(
)
;
}
nsPoint
ScrollFrameHelper
:
:
GetVisualViewportOffset
(
)
const
{
nsIPresShell
*
presShell
=
mOuter
-
>
PresShell
(
)
;
if
(
mIsRoot
&
&
presShell
-
>
IsVisualViewportSizeSet
(
)
)
{
return
presShell
-
>
GetVisualViewportOffset
(
)
;
}
return
GetScrollPosition
(
)
;
}
nsRect
ScrollFrameHelper
:
:
GetVisualOptimalViewingRect
(
)
const
{
nsIPresShell
*
presShell
=
mOuter
-
>
PresShell
(
)
;
if
(
mIsRoot
&
&
presShell
-
>
IsVisualViewportSizeSet
(
)
&
&
presShell
-
>
IsVisualViewportOffsetSet
(
)
)
{
return
nsRect
(
mScrollPort
.
TopLeft
(
)
-
GetScrollPosition
(
)
+
presShell
-
>
GetVisualViewportOffset
(
)
presShell
-
>
GetVisualViewportSize
(
)
)
;
}
return
mScrollPort
;
}
static
void
AdjustForWholeDelta
(
int32_t
aDelta
nscoord
*
aCoord
)
{
if
(
aDelta
<
0
)
{
*
aCoord
=
nscoord_MIN
;
}
else
if
(
aDelta
>
0
)
{
*
aCoord
=
nscoord_MAX
;
}
}
static
void
CalcRangeForScrollBy
(
int32_t
aDelta
nscoord
aPos
float
aNegTolerance
float
aPosTolerance
nscoord
aMultiplier
nscoord
*
aLower
nscoord
*
aUpper
)
{
if
(
!
aDelta
)
{
*
aLower
=
*
aUpper
=
aPos
;
return
;
}
*
aLower
=
aPos
-
NSToCoordRound
(
aMultiplier
*
(
aDelta
>
0
?
aNegTolerance
:
aPosTolerance
)
)
;
*
aUpper
=
aPos
+
NSToCoordRound
(
aMultiplier
*
(
aDelta
>
0
?
aPosTolerance
:
aNegTolerance
)
)
;
}
void
ScrollFrameHelper
:
:
ScrollBy
(
nsIntPoint
aDelta
nsIScrollableFrame
:
:
ScrollUnit
aUnit
nsIScrollableFrame
:
:
ScrollMode
aMode
nsIntPoint
*
aOverflow
nsAtom
*
aOrigin
nsIScrollableFrame
:
:
ScrollMomentum
aMomentum
nsIScrollbarMediator
:
:
ScrollSnapMode
aSnap
)
{
switch
(
aMomentum
)
{
case
nsIScrollableFrame
:
:
NOT_MOMENTUM
:
mIgnoreMomentumScroll
=
false
;
break
;
case
nsIScrollableFrame
:
:
SYNTHESIZED_MOMENTUM_EVENT
:
if
(
mIgnoreMomentumScroll
)
{
return
;
}
break
;
}
if
(
mAsyncSmoothMSDScroll
!
=
nullptr
)
{
mDestination
=
GetScrollPosition
(
)
;
}
nsSize
deltaMultiplier
;
float
negativeTolerance
;
float
positiveTolerance
;
if
(
!
aOrigin
)
{
aOrigin
=
nsGkAtoms
:
:
other
;
}
bool
isGenericOrigin
=
(
aOrigin
=
=
nsGkAtoms
:
:
other
)
;
switch
(
aUnit
)
{
case
nsIScrollableFrame
:
:
DEVICE_PIXELS
:
{
nscoord
appUnitsPerDevPixel
=
mOuter
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
deltaMultiplier
=
nsSize
(
appUnitsPerDevPixel
appUnitsPerDevPixel
)
;
if
(
isGenericOrigin
)
{
aOrigin
=
nsGkAtoms
:
:
pixels
;
}
negativeTolerance
=
positiveTolerance
=
0
.
5f
;
break
;
}
case
nsIScrollableFrame
:
:
LINES
:
{
deltaMultiplier
=
GetLineScrollAmount
(
)
;
if
(
isGenericOrigin
)
{
aOrigin
=
nsGkAtoms
:
:
lines
;
}
negativeTolerance
=
positiveTolerance
=
0
.
1f
;
break
;
}
case
nsIScrollableFrame
:
:
PAGES
:
{
deltaMultiplier
=
GetPageScrollAmount
(
)
;
if
(
isGenericOrigin
)
{
aOrigin
=
nsGkAtoms
:
:
pages
;
}
negativeTolerance
=
0
.
05f
;
positiveTolerance
=
0
;
break
;
}
case
nsIScrollableFrame
:
:
WHOLE
:
{
nsPoint
pos
=
GetScrollPosition
(
)
;
AdjustForWholeDelta
(
aDelta
.
x
&
pos
.
x
)
;
AdjustForWholeDelta
(
aDelta
.
y
&
pos
.
y
)
;
if
(
aSnap
=
=
nsIScrollableFrame
:
:
ENABLE_SNAP
)
{
GetSnapPointForDestination
(
aUnit
mDestination
pos
)
;
}
ScrollTo
(
pos
aMode
nsGkAtoms
:
:
other
)
;
if
(
aOverflow
)
{
*
aOverflow
=
nsIntPoint
(
0
0
)
;
}
return
;
}
default
:
NS_ERROR
(
"
Invalid
scroll
mode
"
)
;
return
;
}
nsPoint
newPos
=
mDestination
+
nsPoint
(
aDelta
.
x
*
deltaMultiplier
.
width
aDelta
.
y
*
deltaMultiplier
.
height
)
;
if
(
aSnap
=
=
nsIScrollableFrame
:
:
ENABLE_SNAP
)
{
ScrollStyles
styles
=
GetScrollStylesFromFrame
(
)
;
if
(
styles
.
mScrollSnapTypeY
!
=
StyleScrollSnapType
:
:
None
|
|
styles
.
mScrollSnapTypeX
!
=
StyleScrollSnapType
:
:
None
)
{
nscoord
appUnitsPerDevPixel
=
mOuter
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
deltaMultiplier
=
nsSize
(
appUnitsPerDevPixel
appUnitsPerDevPixel
)
;
negativeTolerance
=
0
.
1f
;
positiveTolerance
=
0
;
nsIScrollableFrame
:
:
ScrollUnit
snapUnit
=
aUnit
;
if
(
aOrigin
=
=
nsGkAtoms
:
:
mouseWheel
)
{
snapUnit
=
nsIScrollableFrame
:
:
LINES
;
}
GetSnapPointForDestination
(
snapUnit
mDestination
newPos
)
;
}
}
nscoord
rangeLowerX
rangeUpperX
rangeLowerY
rangeUpperY
;
CalcRangeForScrollBy
(
aDelta
.
x
newPos
.
x
negativeTolerance
positiveTolerance
deltaMultiplier
.
width
&
rangeLowerX
&
rangeUpperX
)
;
CalcRangeForScrollBy
(
aDelta
.
y
newPos
.
y
negativeTolerance
positiveTolerance
deltaMultiplier
.
height
&
rangeLowerY
&
rangeUpperY
)
;
nsRect
range
(
rangeLowerX
rangeLowerY
rangeUpperX
-
rangeLowerX
rangeUpperY
-
rangeLowerY
)
;
AutoWeakFrame
weakFrame
(
mOuter
)
;
ScrollToWithOrigin
(
newPos
aMode
aOrigin
&
range
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
;
}
if
(
aOverflow
)
{
nsPoint
clampAmount
=
newPos
-
mDestination
;
float
appUnitsPerDevPixel
=
mOuter
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
*
aOverflow
=
nsIntPoint
(
NSAppUnitsToIntPixels
(
clampAmount
.
x
appUnitsPerDevPixel
)
NSAppUnitsToIntPixels
(
clampAmount
.
y
appUnitsPerDevPixel
)
)
;
}
if
(
aUnit
=
=
nsIScrollableFrame
:
:
DEVICE_PIXELS
&
&
!
nsLayoutUtils
:
:
AsyncPanZoomEnabled
(
mOuter
)
)
{
mVelocityQueue
.
Sample
(
GetScrollPosition
(
)
)
;
}
}
void
ScrollFrameHelper
:
:
ScrollByCSSPixels
(
const
CSSIntPoint
&
aDelta
nsIScrollableFrame
:
:
ScrollMode
aMode
nsAtom
*
aOrigin
)
{
nsPoint
current
=
GetScrollPosition
(
)
;
nsPoint
pt
=
current
+
CSSPoint
:
:
ToAppUnits
(
aDelta
)
;
nscoord
halfPixel
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
0
.
5f
)
;
nsRect
range
(
pt
.
x
-
halfPixel
pt
.
y
-
halfPixel
2
*
halfPixel
-
1
2
*
halfPixel
-
1
)
;
if
(
aDelta
.
x
=
=
0
.
0f
)
{
pt
.
x
=
current
.
x
;
range
.
x
=
pt
.
x
;
range
.
width
=
0
;
}
if
(
aDelta
.
y
=
=
0
.
0f
)
{
pt
.
y
=
current
.
y
;
range
.
y
=
pt
.
y
;
range
.
height
=
0
;
}
if
(
aOrigin
=
=
nullptr
)
{
aOrigin
=
nsGkAtoms
:
:
other
;
}
ScrollToWithOrigin
(
pt
aMode
aOrigin
&
range
nsIScrollbarMediator
:
:
DISABLE_SNAP
)
;
}
void
ScrollFrameHelper
:
:
ScrollSnap
(
nsIScrollableFrame
:
:
ScrollMode
aMode
)
{
float
flingSensitivity
=
gfxPrefs
:
:
ScrollSnapPredictionSensitivity
(
)
;
int
maxVelocity
=
gfxPrefs
:
:
ScrollSnapPredictionMaxVelocity
(
)
;
maxVelocity
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
maxVelocity
)
;
int
maxOffset
=
maxVelocity
*
flingSensitivity
;
nsPoint
velocity
=
mVelocityQueue
.
GetVelocity
(
)
;
nsPoint
predictedOffset
=
nsPoint
(
velocity
.
x
*
flingSensitivity
velocity
.
y
*
flingSensitivity
)
;
predictedOffset
.
Clamp
(
maxOffset
)
;
nsPoint
pos
=
GetScrollPosition
(
)
;
nsPoint
destinationPos
=
pos
+
predictedOffset
;
ScrollSnap
(
destinationPos
aMode
)
;
}
void
ScrollFrameHelper
:
:
ScrollSnap
(
const
nsPoint
&
aDestination
nsIScrollableFrame
:
:
ScrollMode
aMode
)
{
nsRect
scrollRange
=
GetScrollRangeForClamping
(
)
;
nsPoint
pos
=
GetScrollPosition
(
)
;
nsPoint
snapDestination
=
scrollRange
.
ClampPoint
(
aDestination
)
;
if
(
GetSnapPointForDestination
(
nsIScrollableFrame
:
:
DEVICE_PIXELS
pos
snapDestination
)
)
{
ScrollTo
(
snapDestination
aMode
nsGkAtoms
:
:
other
)
;
}
}
nsSize
ScrollFrameHelper
:
:
GetLineScrollAmount
(
)
const
{
RefPtr
<
nsFontMetrics
>
fm
=
nsLayoutUtils
:
:
GetInflatedFontMetricsForFrame
(
mOuter
)
;
NS_ASSERTION
(
fm
"
FontMetrics
is
null
assuming
fontHeight
=
=
1
appunit
"
)
;
static
nscoord
sMinLineScrollAmountInPixels
=
-
1
;
if
(
sMinLineScrollAmountInPixels
<
0
)
{
Preferences
:
:
AddIntVarCache
(
&
sMinLineScrollAmountInPixels
"
mousewheel
.
min_line_scroll_amount
"
1
)
;
}
int32_t
appUnitsPerDevPixel
=
mOuter
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
nscoord
minScrollAmountInAppUnits
=
std
:
:
max
(
1
sMinLineScrollAmountInPixels
)
*
appUnitsPerDevPixel
;
nscoord
horizontalAmount
=
fm
?
fm
-
>
AveCharWidth
(
)
:
0
;
nscoord
verticalAmount
=
fm
?
fm
-
>
MaxHeight
(
)
:
0
;
return
nsSize
(
std
:
:
max
(
horizontalAmount
minScrollAmountInAppUnits
)
std
:
:
max
(
verticalAmount
minScrollAmountInAppUnits
)
)
;
}
struct
TopAndBottom
{
TopAndBottom
(
nscoord
aTop
nscoord
aBottom
)
:
top
(
aTop
)
bottom
(
aBottom
)
{
}
nscoord
top
bottom
;
}
;
struct
TopComparator
{
bool
Equals
(
const
TopAndBottom
&
A
const
TopAndBottom
&
B
)
const
{
return
A
.
top
=
=
B
.
top
;
}
bool
LessThan
(
const
TopAndBottom
&
A
const
TopAndBottom
&
B
)
const
{
return
A
.
top
<
B
.
top
;
}
}
;
struct
ReverseBottomComparator
{
bool
Equals
(
const
TopAndBottom
&
A
const
TopAndBottom
&
B
)
const
{
return
A
.
bottom
=
=
B
.
bottom
;
}
bool
LessThan
(
const
TopAndBottom
&
A
const
TopAndBottom
&
B
)
const
{
return
A
.
bottom
>
B
.
bottom
;
}
}
;
static
nsSize
GetScrollPortSizeExcludingHeadersAndFooters
(
nsIFrame
*
aViewportFrame
const
nsRect
&
aScrollPort
)
{
AutoTArray
<
TopAndBottom
50
>
list
;
nsFrameList
fixedFrames
=
aViewportFrame
-
>
GetChildList
(
nsIFrame
:
:
kFixedList
)
;
for
(
nsFrameList
:
:
Enumerator
iterator
(
fixedFrames
)
;
!
iterator
.
AtEnd
(
)
;
iterator
.
Next
(
)
)
{
nsIFrame
*
f
=
iterator
.
get
(
)
;
nsRect
r
=
f
-
>
GetRectRelativeToSelf
(
)
;
r
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
f
r
aViewportFrame
)
;
r
=
r
.
Intersect
(
aScrollPort
)
;
if
(
(
r
.
width
>
=
aScrollPort
.
width
/
2
|
|
r
.
width
>
=
NSIntPixelsToAppUnits
(
800
AppUnitsPerCSSPixel
(
)
)
)
&
&
r
.
height
<
=
aScrollPort
.
height
/
3
)
{
list
.
AppendElement
(
TopAndBottom
(
r
.
y
r
.
YMost
(
)
)
)
;
}
}
list
.
Sort
(
TopComparator
(
)
)
;
nscoord
headerBottom
=
0
;
for
(
uint32_t
i
=
0
;
i
<
list
.
Length
(
)
;
+
+
i
)
{
if
(
list
[
i
]
.
top
<
=
headerBottom
)
{
headerBottom
=
std
:
:
max
(
headerBottom
list
[
i
]
.
bottom
)
;
}
}
list
.
Sort
(
ReverseBottomComparator
(
)
)
;
nscoord
footerTop
=
aScrollPort
.
height
;
for
(
uint32_t
i
=
0
;
i
<
list
.
Length
(
)
;
+
+
i
)
{
if
(
list
[
i
]
.
bottom
>
=
footerTop
)
{
footerTop
=
std
:
:
min
(
footerTop
list
[
i
]
.
top
)
;
}
}
headerBottom
=
std
:
:
min
(
aScrollPort
.
height
/
3
headerBottom
)
;
footerTop
=
std
:
:
max
(
aScrollPort
.
height
-
aScrollPort
.
height
/
3
footerTop
)
;
return
nsSize
(
aScrollPort
.
width
footerTop
-
headerBottom
)
;
}
nsSize
ScrollFrameHelper
:
:
GetPageScrollAmount
(
)
const
{
nsSize
lineScrollAmount
=
GetLineScrollAmount
(
)
;
nsSize
effectiveScrollPortSize
;
if
(
mIsRoot
)
{
nsIFrame
*
root
=
mOuter
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
;
effectiveScrollPortSize
=
GetScrollPortSizeExcludingHeadersAndFooters
(
root
mScrollPort
)
;
}
else
{
effectiveScrollPortSize
=
mScrollPort
.
Size
(
)
;
}
return
nsSize
(
effectiveScrollPortSize
.
width
-
std
:
:
min
(
effectiveScrollPortSize
.
width
/
10
2
*
lineScrollAmount
.
width
)
effectiveScrollPortSize
.
height
-
std
:
:
min
(
effectiveScrollPortSize
.
height
/
10
2
*
lineScrollAmount
.
height
)
)
;
}
void
ScrollFrameHelper
:
:
ScrollToRestoredPosition
(
)
{
if
(
mRestorePos
.
y
=
=
-
1
|
|
mLastPos
.
x
=
=
-
1
|
|
mLastPos
.
y
=
=
-
1
)
{
return
;
}
if
(
GetLogicalVisualViewportOffset
(
)
=
=
mLastPos
)
{
if
(
mRestorePos
!
=
mLastPos
)
{
LoadingState
state
=
GetPageLoadingState
(
)
;
if
(
state
=
=
LoadingState
:
:
Stopped
&
&
!
NS_SUBTREE_DIRTY
(
mOuter
)
)
{
return
;
}
nsPoint
scrollToPos
=
mRestorePos
;
if
(
!
IsPhysicalLTR
(
)
)
{
scrollToPos
.
x
-
=
(
GetVisualViewportSize
(
)
.
width
-
mScrolledFrame
-
>
GetRect
(
)
.
width
)
;
}
AutoWeakFrame
weakFrame
(
mOuter
)
;
ScrollToWithOrigin
(
scrollToPos
nsIScrollableFrame
:
:
INSTANT
nsGkAtoms
:
:
restore
nullptr
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
;
}
if
(
state
=
=
LoadingState
:
:
Loading
|
|
NS_SUBTREE_DIRTY
(
mOuter
)
)
{
mLastPos
=
GetLogicalVisualViewportOffset
(
)
;
return
;
}
}
mRestorePos
.
y
=
-
1
;
mLastPos
.
x
=
-
1
;
mLastPos
.
y
=
-
1
;
}
else
{
mLastPos
.
x
=
-
1
;
mLastPos
.
y
=
-
1
;
}
}
auto
ScrollFrameHelper
:
:
GetPageLoadingState
(
)
-
>
LoadingState
{
bool
loadCompleted
=
false
stopped
=
false
;
nsCOMPtr
<
nsIDocShell
>
ds
=
mOuter
-
>
GetContent
(
)
-
>
GetComposedDoc
(
)
-
>
GetDocShell
(
)
;
if
(
ds
)
{
nsCOMPtr
<
nsIContentViewer
>
cv
;
ds
-
>
GetContentViewer
(
getter_AddRefs
(
cv
)
)
;
loadCompleted
=
cv
-
>
GetLoadCompleted
(
)
;
stopped
=
cv
-
>
GetIsStopped
(
)
;
}
return
loadCompleted
?
(
stopped
?
LoadingState
:
:
Stopped
:
LoadingState
:
:
Loaded
)
:
LoadingState
:
:
Loading
;
}
nsresult
ScrollFrameHelper
:
:
FireScrollPortEvent
(
)
{
mAsyncScrollPortEvent
.
Forget
(
)
;
nsSize
scrollportSize
=
mScrollPort
.
Size
(
)
;
nsSize
childSize
=
GetScrolledRect
(
)
.
Size
(
)
;
bool
newVerticalOverflow
=
childSize
.
height
>
scrollportSize
.
height
;
bool
vertChanged
=
mVerticalOverflow
!
=
newVerticalOverflow
;
bool
newHorizontalOverflow
=
childSize
.
width
>
scrollportSize
.
width
;
bool
horizChanged
=
mHorizontalOverflow
!
=
newHorizontalOverflow
;
if
(
!
vertChanged
&
&
!
horizChanged
)
{
return
NS_OK
;
}
bool
both
=
vertChanged
&
&
horizChanged
&
&
newVerticalOverflow
=
=
newHorizontalOverflow
;
InternalScrollPortEvent
:
:
OrientType
orient
;
if
(
both
)
{
orient
=
InternalScrollPortEvent
:
:
eBoth
;
mHorizontalOverflow
=
newHorizontalOverflow
;
mVerticalOverflow
=
newVerticalOverflow
;
}
else
if
(
vertChanged
)
{
orient
=
InternalScrollPortEvent
:
:
eVertical
;
mVerticalOverflow
=
newVerticalOverflow
;
if
(
horizChanged
)
{
PostOverflowEvent
(
)
;
}
}
else
{
orient
=
InternalScrollPortEvent
:
:
eHorizontal
;
mHorizontalOverflow
=
newHorizontalOverflow
;
}
InternalScrollPortEvent
event
(
true
(
orient
=
=
InternalScrollPortEvent
:
:
eHorizontal
?
mHorizontalOverflow
:
mVerticalOverflow
)
?
eScrollPortOverflow
:
eScrollPortUnderflow
nullptr
)
;
event
.
mOrient
=
orient
;
return
EventDispatcher
:
:
Dispatch
(
mOuter
-
>
GetContent
(
)
mOuter
-
>
PresContext
(
)
&
event
)
;
}
void
ScrollFrameHelper
:
:
PostScrollEndEvent
(
)
{
if
(
mScrollEndEvent
)
{
return
;
}
mScrollEndEvent
=
new
ScrollEndEvent
(
this
)
;
}
void
ScrollFrameHelper
:
:
FireScrollEndEvent
(
)
{
MOZ_ASSERT
(
mOuter
-
>
GetContent
(
)
)
;
MOZ_ASSERT
(
mScrollEndEvent
)
;
mScrollEndEvent
-
>
Revoke
(
)
;
mScrollEndEvent
=
nullptr
;
nsContentUtils
:
:
DispatchEventOnlyToChrome
(
mOuter
-
>
GetContent
(
)
-
>
OwnerDoc
(
)
mOuter
-
>
GetContent
(
)
NS_LITERAL_STRING
(
"
scrollend
"
)
CanBubble
:
:
eYes
Cancelable
:
:
eNo
)
;
}
void
ScrollFrameHelper
:
:
ReloadChildFrames
(
)
{
mScrolledFrame
=
nullptr
;
mHScrollbarBox
=
nullptr
;
mVScrollbarBox
=
nullptr
;
mScrollCornerBox
=
nullptr
;
mResizerBox
=
nullptr
;
for
(
nsIFrame
*
frame
:
mOuter
-
>
PrincipalChildList
(
)
)
{
nsIContent
*
content
=
frame
-
>
GetContent
(
)
;
if
(
content
=
=
mOuter
-
>
GetContent
(
)
)
{
NS_ASSERTION
(
!
mScrolledFrame
"
Already
found
the
scrolled
frame
"
)
;
mScrolledFrame
=
frame
;
}
else
{
nsAutoString
value
;
if
(
content
-
>
IsElement
(
)
)
{
content
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
orient
value
)
;
}
if
(
!
value
.
IsEmpty
(
)
)
{
if
(
value
.
LowerCaseEqualsLiteral
(
"
horizontal
"
)
)
{
NS_ASSERTION
(
!
mHScrollbarBox
"
Found
multiple
horizontal
scrollbars
?
"
)
;
mHScrollbarBox
=
frame
;
}
else
{
NS_ASSERTION
(
!
mVScrollbarBox
"
Found
multiple
vertical
scrollbars
?
"
)
;
mVScrollbarBox
=
frame
;
}
}
else
if
(
content
-
>
IsXULElement
(
nsGkAtoms
:
:
resizer
)
)
{
NS_ASSERTION
(
!
mResizerBox
"
Found
multiple
resizers
"
)
;
mResizerBox
=
frame
;
}
else
if
(
content
-
>
IsXULElement
(
nsGkAtoms
:
:
scrollcorner
)
)
{
NS_ASSERTION
(
!
mScrollCornerBox
"
Found
multiple
scrollcorners
"
)
;
mScrollCornerBox
=
frame
;
}
}
}
}
bool
ScrollFrameHelper
:
:
IsForTextControlWithNoScrollbars
(
)
const
{
nsIFrame
*
parent
=
mOuter
-
>
GetParent
(
)
;
nsITextControlFrame
*
textFrame
=
do_QueryFrame
(
parent
)
;
if
(
textFrame
)
{
HTMLTextAreaElement
*
textAreaElement
=
HTMLTextAreaElement
:
:
FromNode
(
parent
-
>
GetContent
(
)
)
;
if
(
!
textAreaElement
)
{
return
true
;
}
}
return
false
;
}
nsresult
ScrollFrameHelper
:
:
CreateAnonymousContent
(
nsTArray
<
nsIAnonymousContentCreator
:
:
ContentInfo
>
&
aElements
)
{
nsPresContext
*
presContext
=
mOuter
-
>
PresContext
(
)
;
if
(
presContext
-
>
Document
(
)
-
>
IsBeingUsedAsImage
(
)
|
|
(
!
presContext
-
>
IsDynamic
(
)
&
&
!
(
mIsRoot
&
&
presContext
-
>
HasPaginatedScrolling
(
)
)
)
)
{
mNeverHasVerticalScrollbar
=
mNeverHasHorizontalScrollbar
=
true
;
return
NS_OK
;
}
auto
resizeStyle
=
mOuter
-
>
StyleDisplay
(
)
-
>
mResize
;
bool
isResizable
=
resizeStyle
!
=
StyleResize
:
:
None
&
&
!
mOuter
-
>
HasAnyStateBits
(
NS_FRAME_GENERATED_CONTENT
)
;
nsIScrollableFrame
*
scrollable
=
do_QueryFrame
(
mOuter
)
;
bool
canHaveHorizontal
;
bool
canHaveVertical
;
if
(
!
mIsRoot
)
{
if
(
mOuter
-
>
StyleUIReset
(
)
-
>
mScrollbarWidth
=
=
StyleScrollbarWidth
:
:
None
)
{
canHaveHorizontal
=
false
;
canHaveVertical
=
false
;
}
else
{
ScrollStyles
styles
=
scrollable
-
>
GetScrollStyles
(
)
;
canHaveHorizontal
=
styles
.
mHorizontal
!
=
StyleOverflow
:
:
Hidden
;
canHaveVertical
=
styles
.
mVertical
!
=
StyleOverflow
:
:
Hidden
;
}
if
(
!
canHaveHorizontal
&
&
!
canHaveVertical
&
&
!
isResizable
)
{
return
NS_OK
;
}
}
else
{
canHaveHorizontal
=
true
;
canHaveVertical
=
true
;
}
if
(
IsForTextControlWithNoScrollbars
(
)
)
{
mNeverHasVerticalScrollbar
=
mNeverHasHorizontalScrollbar
=
true
;
return
NS_OK
;
}
nsNodeInfoManager
*
nodeInfoManager
=
presContext
-
>
Document
(
)
-
>
NodeInfoManager
(
)
;
RefPtr
<
NodeInfo
>
nodeInfo
=
nodeInfoManager
-
>
GetNodeInfo
(
nsGkAtoms
:
:
scrollbar
nullptr
kNameSpaceID_XUL
nsINode
:
:
ELEMENT_NODE
)
;
NS_ENSURE_TRUE
(
nodeInfo
NS_ERROR_OUT_OF_MEMORY
)
;
if
(
canHaveHorizontal
)
{
RefPtr
<
NodeInfo
>
ni
=
nodeInfo
;
NS_TrustedNewXULElement
(
getter_AddRefs
(
mHScrollbarContent
)
ni
.
forget
(
)
)
;
#
ifdef
DEBUG
mHScrollbarContent
-
>
SetProperty
(
nsGkAtoms
:
:
restylableAnonymousNode
reinterpret_cast
<
void
*
>
(
true
)
)
;
#
endif
mHScrollbarContent
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
orient
NS_LITERAL_STRING
(
"
horizontal
"
)
false
)
;
mHScrollbarContent
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
clickthrough
NS_LITERAL_STRING
(
"
always
"
)
false
)
;
if
(
mIsRoot
)
{
mHScrollbarContent
-
>
SetProperty
(
nsGkAtoms
:
:
docLevelNativeAnonymousContent
reinterpret_cast
<
void
*
>
(
true
)
)
;
mHScrollbarContent
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
root_
NS_LITERAL_STRING
(
"
true
"
)
false
)
;
}
if
(
!
aElements
.
AppendElement
(
mHScrollbarContent
)
)
return
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
canHaveVertical
)
{
RefPtr
<
NodeInfo
>
ni
=
nodeInfo
;
NS_TrustedNewXULElement
(
getter_AddRefs
(
mVScrollbarContent
)
ni
.
forget
(
)
)
;
#
ifdef
DEBUG
mVScrollbarContent
-
>
SetProperty
(
nsGkAtoms
:
:
restylableAnonymousNode
reinterpret_cast
<
void
*
>
(
true
)
)
;
#
endif
mVScrollbarContent
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
orient
NS_LITERAL_STRING
(
"
vertical
"
)
false
)
;
mVScrollbarContent
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
clickthrough
NS_LITERAL_STRING
(
"
always
"
)
false
)
;
if
(
mIsRoot
)
{
mVScrollbarContent
-
>
SetProperty
(
nsGkAtoms
:
:
docLevelNativeAnonymousContent
reinterpret_cast
<
void
*
>
(
true
)
)
;
mVScrollbarContent
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
root_
NS_LITERAL_STRING
(
"
true
"
)
false
)
;
}
if
(
!
aElements
.
AppendElement
(
mVScrollbarContent
)
)
return
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
isResizable
)
{
RefPtr
<
NodeInfo
>
nodeInfo
;
nodeInfo
=
nodeInfoManager
-
>
GetNodeInfo
(
nsGkAtoms
:
:
resizer
nullptr
kNameSpaceID_XUL
nsINode
:
:
ELEMENT_NODE
)
;
NS_ENSURE_TRUE
(
nodeInfo
NS_ERROR_OUT_OF_MEMORY
)
;
NS_TrustedNewXULElement
(
getter_AddRefs
(
mResizerContent
)
nodeInfo
.
forget
(
)
)
;
nsAutoString
dir
;
switch
(
resizeStyle
)
{
case
StyleResize
:
:
Horizontal
:
if
(
IsScrollbarOnRight
(
)
)
{
dir
.
AssignLiteral
(
"
right
"
)
;
}
else
{
dir
.
AssignLiteral
(
"
left
"
)
;
}
break
;
case
StyleResize
:
:
Vertical
:
dir
.
AssignLiteral
(
"
bottom
"
)
;
if
(
!
IsScrollbarOnRight
(
)
)
{
mResizerContent
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
flip
EmptyString
(
)
false
)
;
}
break
;
case
StyleResize
:
:
Both
:
if
(
IsScrollbarOnRight
(
)
)
{
dir
.
AssignLiteral
(
"
bottomright
"
)
;
}
else
{
dir
.
AssignLiteral
(
"
bottomleft
"
)
;
}
break
;
default
:
NS_WARNING
(
"
only
resizable
types
should
have
resizers
"
)
;
}
mResizerContent
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
dir
dir
false
)
;
if
(
mIsRoot
)
{
mResizerContent
-
>
SetProperty
(
nsGkAtoms
:
:
docLevelNativeAnonymousContent
reinterpret_cast
<
void
*
>
(
true
)
)
;
Element
*
browserRoot
=
GetBrowserRoot
(
mOuter
-
>
GetContent
(
)
)
;
mCollapsedResizer
=
!
(
browserRoot
&
&
browserRoot
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
showresizer
)
)
;
}
else
{
mResizerContent
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
element
NS_LITERAL_STRING
(
"
_parent
"
)
false
)
;
}
mResizerContent
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
clickthrough
NS_LITERAL_STRING
(
"
always
"
)
false
)
;
if
(
!
aElements
.
AppendElement
(
mResizerContent
)
)
return
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
canHaveHorizontal
&
&
canHaveVertical
)
{
nodeInfo
=
nodeInfoManager
-
>
GetNodeInfo
(
nsGkAtoms
:
:
scrollcorner
nullptr
kNameSpaceID_XUL
nsINode
:
:
ELEMENT_NODE
)
;
NS_TrustedNewXULElement
(
getter_AddRefs
(
mScrollCornerContent
)
nodeInfo
.
forget
(
)
)
;
if
(
mIsRoot
)
{
mScrollCornerContent
-
>
SetProperty
(
nsGkAtoms
:
:
docLevelNativeAnonymousContent
reinterpret_cast
<
void
*
>
(
true
)
)
;
}
if
(
!
aElements
.
AppendElement
(
mScrollCornerContent
)
)
return
NS_ERROR_OUT_OF_MEMORY
;
}
return
NS_OK
;
}
void
ScrollFrameHelper
:
:
AppendAnonymousContentTo
(
nsTArray
<
nsIContent
*
>
&
aElements
uint32_t
aFilter
)
{
if
(
mHScrollbarContent
)
{
aElements
.
AppendElement
(
mHScrollbarContent
)
;
}
if
(
mVScrollbarContent
)
{
aElements
.
AppendElement
(
mVScrollbarContent
)
;
}
if
(
mScrollCornerContent
)
{
aElements
.
AppendElement
(
mScrollCornerContent
)
;
}
if
(
mResizerContent
)
{
aElements
.
AppendElement
(
mResizerContent
)
;
}
}
void
ScrollFrameHelper
:
:
Destroy
(
PostDestroyData
&
aPostDestroyData
)
{
mAnchor
.
Destroy
(
)
;
if
(
mScrollbarActivity
)
{
mScrollbarActivity
-
>
Destroy
(
)
;
mScrollbarActivity
=
nullptr
;
}
aPostDestroyData
.
AddAnonymousContent
(
mHScrollbarContent
.
forget
(
)
)
;
aPostDestroyData
.
AddAnonymousContent
(
mVScrollbarContent
.
forget
(
)
)
;
aPostDestroyData
.
AddAnonymousContent
(
mScrollCornerContent
.
forget
(
)
)
;
aPostDestroyData
.
AddAnonymousContent
(
mResizerContent
.
forget
(
)
)
;
if
(
mPostedReflowCallback
)
{
mOuter
-
>
PresShell
(
)
-
>
CancelReflowCallback
(
this
)
;
mPostedReflowCallback
=
false
;
}
if
(
mDisplayPortExpiryTimer
)
{
mDisplayPortExpiryTimer
-
>
Cancel
(
)
;
mDisplayPortExpiryTimer
=
nullptr
;
}
if
(
mActivityExpirationState
.
IsTracked
(
)
)
{
gScrollFrameActivityTracker
-
>
RemoveObject
(
this
)
;
}
if
(
gScrollFrameActivityTracker
&
&
gScrollFrameActivityTracker
-
>
IsEmpty
(
)
)
{
delete
gScrollFrameActivityTracker
;
gScrollFrameActivityTracker
=
nullptr
;
}
if
(
mScrollActivityTimer
)
{
mScrollActivityTimer
-
>
Cancel
(
)
;
mScrollActivityTimer
=
nullptr
;
}
RemoveObservers
(
)
;
}
void
ScrollFrameHelper
:
:
RemoveObservers
(
)
{
if
(
mAsyncScroll
)
{
mAsyncScroll
-
>
RemoveObserver
(
)
;
mAsyncScroll
=
nullptr
;
}
if
(
mAsyncSmoothMSDScroll
)
{
mAsyncSmoothMSDScroll
-
>
RemoveObserver
(
)
;
mAsyncSmoothMSDScroll
=
nullptr
;
}
}
void
ScrollFrameHelper
:
:
UpdateScrollbarPosition
(
)
{
AutoWeakFrame
weakFrame
(
mOuter
)
;
mFrameIsUpdatingScrollbar
=
true
;
nsPoint
pt
=
GetScrollPosition
(
)
;
if
(
mVScrollbarBox
)
{
SetCoordAttribute
(
mVScrollbarBox
-
>
GetContent
(
)
-
>
AsElement
(
)
nsGkAtoms
:
:
curpos
pt
.
y
-
GetScrolledRect
(
)
.
y
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
;
}
}
if
(
mHScrollbarBox
)
{
SetCoordAttribute
(
mHScrollbarBox
-
>
GetContent
(
)
-
>
AsElement
(
)
nsGkAtoms
:
:
curpos
pt
.
x
-
GetScrolledRect
(
)
.
x
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
;
}
}
mFrameIsUpdatingScrollbar
=
false
;
}
void
ScrollFrameHelper
:
:
CurPosAttributeChanged
(
nsIContent
*
aContent
bool
aDoScroll
)
{
NS_ASSERTION
(
aContent
"
aContent
must
not
be
null
"
)
;
NS_ASSERTION
(
(
mHScrollbarBox
&
&
mHScrollbarBox
-
>
GetContent
(
)
=
=
aContent
)
|
|
(
mVScrollbarBox
&
&
mVScrollbarBox
-
>
GetContent
(
)
=
=
aContent
)
"
unexpected
child
"
)
;
MOZ_ASSERT
(
aContent
-
>
IsElement
(
)
)
;
if
(
mFrameIsUpdatingScrollbar
)
return
;
nsRect
scrolledRect
=
GetScrolledRect
(
)
;
nsPoint
current
=
GetScrollPosition
(
)
-
scrolledRect
.
TopLeft
(
)
;
nsPoint
dest
;
nsRect
allowedRange
;
dest
.
x
=
GetCoordAttribute
(
mHScrollbarBox
nsGkAtoms
:
:
curpos
current
.
x
&
allowedRange
.
x
&
allowedRange
.
width
)
;
dest
.
y
=
GetCoordAttribute
(
mVScrollbarBox
nsGkAtoms
:
:
curpos
current
.
y
&
allowedRange
.
y
&
allowedRange
.
height
)
;
current
+
=
scrolledRect
.
TopLeft
(
)
;
dest
+
=
scrolledRect
.
TopLeft
(
)
;
allowedRange
+
=
scrolledRect
.
TopLeft
(
)
;
if
(
allowedRange
.
ClampPoint
(
current
)
=
=
current
)
{
return
;
}
if
(
mScrollbarActivity
)
{
RefPtr
<
ScrollbarActivity
>
scrollbarActivity
(
mScrollbarActivity
)
;
scrollbarActivity
-
>
ActivityOccurred
(
)
;
}
const
bool
isSmooth
=
aContent
-
>
AsElement
(
)
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
smooth
)
;
if
(
isSmooth
)
{
AutoWeakFrame
weakFrame
(
mOuter
)
;
UpdateScrollbarPosition
(
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
;
}
}
if
(
aDoScroll
)
{
ScrollToWithOrigin
(
dest
isSmooth
?
nsIScrollableFrame
:
:
SMOOTH
:
nsIScrollableFrame
:
:
INSTANT
nsGkAtoms
:
:
scrollbars
&
allowedRange
)
;
}
}
ScrollFrameHelper
:
:
ScrollEvent
:
:
ScrollEvent
(
ScrollFrameHelper
*
aHelper
bool
aDelayed
)
:
Runnable
(
"
ScrollFrameHelper
:
:
ScrollEvent
"
)
mHelper
(
aHelper
)
{
mHelper
-
>
mOuter
-
>
PresContext
(
)
-
>
RefreshDriver
(
)
-
>
PostScrollEvent
(
this
aDelayed
)
;
}
NS_IMETHODIMP
ScrollFrameHelper
:
:
ScrollEvent
:
:
Run
(
)
{
if
(
mHelper
)
{
mHelper
-
>
FireScrollEvent
(
)
;
}
return
NS_OK
;
}
ScrollFrameHelper
:
:
ScrollEndEvent
:
:
ScrollEndEvent
(
ScrollFrameHelper
*
aHelper
)
:
Runnable
(
"
ScrollFrameHelper
:
:
ScrollEndEvent
"
)
mHelper
(
aHelper
)
{
mHelper
-
>
mOuter
-
>
PresContext
(
)
-
>
RefreshDriver
(
)
-
>
PostScrollEvent
(
this
)
;
}
NS_IMETHODIMP
ScrollFrameHelper
:
:
ScrollEndEvent
:
:
Run
(
)
{
if
(
mHelper
)
{
mHelper
-
>
FireScrollEndEvent
(
)
;
}
return
NS_OK
;
}
void
ScrollFrameHelper
:
:
FireScrollEvent
(
)
{
nsIContent
*
content
=
mOuter
-
>
GetContent
(
)
;
nsPresContext
*
prescontext
=
mOuter
-
>
PresContext
(
)
;
#
ifdef
MOZ_GECKO_PROFILER
nsCOMPtr
<
nsIDocShell
>
docShell
=
prescontext
-
>
GetDocShell
(
)
;
AUTO_PROFILER_TRACING_DOCSHELL
(
"
Paint
"
"
FireScrollEvent
"
GRAPHICS
docShell
)
;
#
endif
MOZ_ASSERT
(
mScrollEvent
)
;
mScrollEvent
-
>
Revoke
(
)
;
mScrollEvent
=
nullptr
;
if
(
content
-
>
GetComposedDoc
(
)
&
&
content
-
>
GetComposedDoc
(
)
-
>
EventHandlingSuppressed
(
)
)
{
content
-
>
GetComposedDoc
(
)
-
>
SetHasDelayedRefreshEvent
(
)
;
PostScrollEvent
(
true
)
;
return
;
}
ActiveLayerTracker
:
:
SetCurrentScrollHandlerFrame
(
mOuter
)
;
WidgetGUIEvent
event
(
true
eScroll
nullptr
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
mozilla
:
:
layers
:
:
ScrollLinkedEffectDetector
detector
(
content
-
>
GetComposedDoc
(
)
)
;
if
(
mIsRoot
)
{
if
(
Document
*
doc
=
content
-
>
GetUncomposedDoc
(
)
)
{
EventDispatcher
:
:
Dispatch
(
ToSupports
(
doc
)
prescontext
&
event
nullptr
&
status
)
;
}
}
else
{
event
.
mFlags
.
mBubbles
=
false
;
EventDispatcher
:
:
Dispatch
(
content
prescontext
&
event
nullptr
&
status
)
;
}
ActiveLayerTracker
:
:
SetCurrentScrollHandlerFrame
(
nullptr
)
;
}
void
ScrollFrameHelper
:
:
PostScrollEvent
(
bool
aDelayed
)
{
if
(
mScrollEvent
)
{
return
;
}
mScrollEvent
=
new
ScrollEvent
(
this
aDelayed
)
;
}
NS_IMETHODIMP
ScrollFrameHelper
:
:
AsyncScrollPortEvent
:
:
Run
(
)
{
if
(
mHelper
)
{
mHelper
-
>
mOuter
-
>
PresContext
(
)
-
>
Document
(
)
-
>
FlushPendingNotifications
(
FlushType
:
:
InterruptibleLayout
)
;
}
return
mHelper
?
mHelper
-
>
FireScrollPortEvent
(
)
:
NS_OK
;
}
bool
nsXULScrollFrame
:
:
AddHorizontalScrollbar
(
nsBoxLayoutState
&
aState
bool
aOnBottom
)
{
if
(
!
mHelper
.
mHScrollbarBox
)
{
return
true
;
}
return
AddRemoveScrollbar
(
aState
aOnBottom
true
true
)
;
}
bool
nsXULScrollFrame
:
:
AddVerticalScrollbar
(
nsBoxLayoutState
&
aState
bool
aOnRight
)
{
if
(
!
mHelper
.
mVScrollbarBox
)
{
return
true
;
}
return
AddRemoveScrollbar
(
aState
aOnRight
false
true
)
;
}
void
nsXULScrollFrame
:
:
RemoveHorizontalScrollbar
(
nsBoxLayoutState
&
aState
bool
aOnBottom
)
{
DebugOnly
<
bool
>
result
=
AddRemoveScrollbar
(
aState
aOnBottom
true
false
)
;
NS_ASSERTION
(
result
"
Removing
horizontal
scrollbar
failed
to
fit
?
?
"
)
;
}
void
nsXULScrollFrame
:
:
RemoveVerticalScrollbar
(
nsBoxLayoutState
&
aState
bool
aOnRight
)
{
DebugOnly
<
bool
>
result
=
AddRemoveScrollbar
(
aState
aOnRight
false
false
)
;
NS_ASSERTION
(
result
"
Removing
vertical
scrollbar
failed
to
fit
?
?
"
)
;
}
bool
nsXULScrollFrame
:
:
AddRemoveScrollbar
(
nsBoxLayoutState
&
aState
bool
aOnRightOrBottom
bool
aHorizontal
bool
aAdd
)
{
if
(
aHorizontal
)
{
if
(
mHelper
.
mNeverHasHorizontalScrollbar
|
|
!
mHelper
.
mHScrollbarBox
)
return
false
;
nsSize
hSize
=
mHelper
.
mHScrollbarBox
-
>
GetXULPrefSize
(
aState
)
;
nsBox
:
:
AddMargin
(
mHelper
.
mHScrollbarBox
hSize
)
;
ScrollFrameHelper
:
:
SetScrollbarVisibility
(
mHelper
.
mHScrollbarBox
aAdd
)
;
bool
hasHorizontalScrollbar
;
bool
fit
=
AddRemoveScrollbar
(
hasHorizontalScrollbar
mHelper
.
mScrollPort
.
y
mHelper
.
mScrollPort
.
height
hSize
.
height
aOnRightOrBottom
aAdd
)
;
mHelper
.
mHasHorizontalScrollbar
=
hasHorizontalScrollbar
;
if
(
!
fit
)
{
ScrollFrameHelper
:
:
SetScrollbarVisibility
(
mHelper
.
mHScrollbarBox
!
aAdd
)
;
}
return
fit
;
}
else
{
if
(
mHelper
.
mNeverHasVerticalScrollbar
|
|
!
mHelper
.
mVScrollbarBox
)
return
false
;
nsSize
vSize
=
mHelper
.
mVScrollbarBox
-
>
GetXULPrefSize
(
aState
)
;
nsBox
:
:
AddMargin
(
mHelper
.
mVScrollbarBox
vSize
)
;
ScrollFrameHelper
:
:
SetScrollbarVisibility
(
mHelper
.
mVScrollbarBox
aAdd
)
;
bool
hasVerticalScrollbar
;
bool
fit
=
AddRemoveScrollbar
(
hasVerticalScrollbar
mHelper
.
mScrollPort
.
x
mHelper
.
mScrollPort
.
width
vSize
.
width
aOnRightOrBottom
aAdd
)
;
mHelper
.
mHasVerticalScrollbar
=
hasVerticalScrollbar
;
if
(
!
fit
)
{
ScrollFrameHelper
:
:
SetScrollbarVisibility
(
mHelper
.
mVScrollbarBox
!
aAdd
)
;
}
return
fit
;
}
}
bool
nsXULScrollFrame
:
:
AddRemoveScrollbar
(
bool
&
aHasScrollbar
nscoord
&
aXY
nscoord
&
aSize
nscoord
aSbSize
bool
aOnRightOrBottom
bool
aAdd
)
{
nscoord
size
=
aSize
;
nscoord
xy
=
aXY
;
if
(
size
!
=
NS_INTRINSICSIZE
)
{
if
(
aAdd
)
{
size
-
=
aSbSize
;
if
(
!
aOnRightOrBottom
&
&
size
>
=
0
)
xy
+
=
aSbSize
;
}
else
{
size
+
=
aSbSize
;
if
(
!
aOnRightOrBottom
)
xy
-
=
aSbSize
;
}
}
if
(
size
>
=
0
)
{
aHasScrollbar
=
aAdd
;
aSize
=
size
;
aXY
=
xy
;
return
true
;
}
aHasScrollbar
=
false
;
return
false
;
}
void
nsXULScrollFrame
:
:
LayoutScrollArea
(
nsBoxLayoutState
&
aState
const
nsPoint
&
aScrollPosition
)
{
uint32_t
oldflags
=
aState
.
LayoutFlags
(
)
;
nsRect
childRect
=
nsRect
(
mHelper
.
mScrollPort
.
TopLeft
(
)
-
aScrollPosition
mHelper
.
mScrollPort
.
Size
(
)
)
;
int32_t
flags
=
NS_FRAME_NO_MOVE_VIEW
;
nsSize
minSize
=
mHelper
.
mScrolledFrame
-
>
GetXULMinSize
(
aState
)
;
if
(
minSize
.
height
>
childRect
.
height
)
childRect
.
height
=
minSize
.
height
;
if
(
minSize
.
width
>
childRect
.
width
)
childRect
.
width
=
minSize
.
width
;
aState
.
SetLayoutFlags
(
flags
)
;
ClampAndSetBounds
(
aState
childRect
aScrollPosition
)
;
mHelper
.
mScrolledFrame
-
>
XULLayout
(
aState
)
;
childRect
=
mHelper
.
mScrolledFrame
-
>
GetRect
(
)
;
if
(
childRect
.
width
<
mHelper
.
mScrollPort
.
width
|
|
childRect
.
height
<
mHelper
.
mScrollPort
.
height
)
{
childRect
.
width
=
std
:
:
max
(
childRect
.
width
mHelper
.
mScrollPort
.
width
)
;
childRect
.
height
=
std
:
:
max
(
childRect
.
height
mHelper
.
mScrollPort
.
height
)
;
ClampAndSetBounds
(
aState
childRect
aScrollPosition
true
)
;
}
aState
.
SetLayoutFlags
(
oldflags
)
;
}
void
ScrollFrameHelper
:
:
PostOverflowEvent
(
)
{
if
(
mAsyncScrollPortEvent
.
IsPending
(
)
)
{
return
;
}
nsSize
scrollportSize
=
mScrollPort
.
Size
(
)
;
nsSize
childSize
=
GetScrolledRect
(
)
.
Size
(
)
;
bool
newVerticalOverflow
=
childSize
.
height
>
scrollportSize
.
height
;
bool
vertChanged
=
mVerticalOverflow
!
=
newVerticalOverflow
;
bool
newHorizontalOverflow
=
childSize
.
width
>
scrollportSize
.
width
;
bool
horizChanged
=
mHorizontalOverflow
!
=
newHorizontalOverflow
;
if
(
!
vertChanged
&
&
!
horizChanged
)
{
return
;
}
nsRootPresContext
*
rpc
=
mOuter
-
>
PresContext
(
)
-
>
GetRootPresContext
(
)
;
if
(
!
rpc
)
{
return
;
}
mAsyncScrollPortEvent
=
new
AsyncScrollPortEvent
(
this
)
;
rpc
-
>
AddWillPaintObserver
(
mAsyncScrollPortEvent
.
get
(
)
)
;
}
nsIFrame
*
ScrollFrameHelper
:
:
GetFrameForDir
(
)
const
{
nsIFrame
*
frame
=
mOuter
;
if
(
mIsRoot
)
{
nsPresContext
*
presContext
=
mOuter
-
>
PresContext
(
)
;
Document
*
document
=
presContext
-
>
Document
(
)
;
Element
*
root
=
document
-
>
GetRootElement
(
)
;
nsCOMPtr
<
nsIHTMLDocument
>
htmlDoc
=
do_QueryInterface
(
document
)
;
if
(
htmlDoc
)
{
Element
*
bodyElement
=
document
-
>
GetBodyElement
(
)
;
if
(
bodyElement
)
{
root
=
bodyElement
;
}
}
if
(
root
)
{
nsIFrame
*
rootsFrame
=
root
-
>
GetPrimaryFrame
(
)
;
if
(
rootsFrame
)
{
frame
=
rootsFrame
;
}
}
}
return
frame
;
}
bool
ScrollFrameHelper
:
:
IsScrollbarOnRight
(
)
const
{
nsPresContext
*
presContext
=
mOuter
-
>
PresContext
(
)
;
if
(
!
mIsRoot
)
{
return
IsPhysicalLTR
(
)
;
}
switch
(
presContext
-
>
GetCachedIntPref
(
kPresContext_ScrollbarSide
)
)
{
default
:
case
0
:
return
presContext
-
>
GetCachedIntPref
(
kPresContext_BidiDirection
)
=
=
IBMBIDI_TEXTDIRECTION_LTR
;
case
1
:
return
IsPhysicalLTR
(
)
;
case
2
:
return
true
;
case
3
:
return
false
;
}
}
bool
ScrollFrameHelper
:
:
IsMaybeScrollingActive
(
)
const
{
const
nsStyleDisplay
*
disp
=
mOuter
-
>
StyleDisplay
(
)
;
if
(
disp
&
&
(
disp
-
>
mWillChangeBitField
&
NS_STYLE_WILL_CHANGE_SCROLL
)
)
{
return
true
;
}
nsIContent
*
content
=
mOuter
-
>
GetContent
(
)
;
return
mHasBeenScrolledRecently
|
|
IsAlwaysActive
(
)
|
|
nsLayoutUtils
:
:
HasDisplayPort
(
content
)
|
|
nsContentUtils
:
:
HasScrollgrab
(
content
)
;
}
bool
ScrollFrameHelper
:
:
IsScrollingActive
(
nsDisplayListBuilder
*
aBuilder
)
const
{
const
nsStyleDisplay
*
disp
=
mOuter
-
>
StyleDisplay
(
)
;
if
(
disp
&
&
(
disp
-
>
mWillChangeBitField
&
NS_STYLE_WILL_CHANGE_SCROLL
)
&
&
aBuilder
-
>
IsInWillChangeBudget
(
mOuter
GetVisualViewportSize
(
)
)
)
{
return
true
;
}
nsIContent
*
content
=
mOuter
-
>
GetContent
(
)
;
return
mHasBeenScrolledRecently
|
|
IsAlwaysActive
(
)
|
|
nsLayoutUtils
:
:
HasDisplayPort
(
content
)
|
|
nsContentUtils
:
:
HasScrollgrab
(
content
)
;
}
nsresult
nsXULScrollFrame
:
:
XULLayout
(
nsBoxLayoutState
&
aState
)
{
bool
scrollbarRight
=
IsScrollbarOnRight
(
)
;
bool
scrollbarBottom
=
true
;
nsRect
clientRect
(
0
0
0
0
)
;
GetXULClientRect
(
clientRect
)
;
nsRect
oldScrollAreaBounds
=
mHelper
.
mScrollPort
;
nsPoint
oldScrollPosition
=
mHelper
.
GetLogicalScrollPosition
(
)
;
mHelper
.
mScrollPort
=
clientRect
;
ScrollStyles
styles
=
GetScrollStyles
(
)
;
if
(
styles
.
mHorizontal
=
=
StyleOverflow
:
:
Scroll
)
mHelper
.
mHasHorizontalScrollbar
=
true
;
if
(
styles
.
mVertical
=
=
StyleOverflow
:
:
Scroll
)
mHelper
.
mHasVerticalScrollbar
=
true
;
if
(
mHelper
.
mHasHorizontalScrollbar
)
AddHorizontalScrollbar
(
aState
scrollbarBottom
)
;
if
(
mHelper
.
mHasVerticalScrollbar
)
AddVerticalScrollbar
(
aState
scrollbarRight
)
;
LayoutScrollArea
(
aState
oldScrollPosition
)
;
bool
needsLayout
=
false
;
if
(
styles
.
mVertical
!
=
StyleOverflow
:
:
Scroll
)
{
nsRect
scrolledRect
=
mHelper
.
GetScrolledRect
(
)
;
if
(
scrolledRect
.
height
<
=
mHelper
.
mScrollPort
.
height
|
|
styles
.
mVertical
!
=
StyleOverflow
:
:
Auto
)
{
if
(
mHelper
.
mHasVerticalScrollbar
)
{
RemoveVerticalScrollbar
(
aState
scrollbarRight
)
;
needsLayout
=
true
;
}
}
else
{
if
(
!
mHelper
.
mHasVerticalScrollbar
)
{
if
(
AddVerticalScrollbar
(
aState
scrollbarRight
)
)
{
needsLayout
=
true
;
}
}
}
if
(
needsLayout
)
{
nsBoxLayoutState
resizeState
(
aState
)
;
LayoutScrollArea
(
resizeState
oldScrollPosition
)
;
needsLayout
=
false
;
}
}
if
(
styles
.
mHorizontal
!
=
StyleOverflow
:
:
Scroll
)
{
nsRect
scrolledRect
=
mHelper
.
GetScrolledRect
(
)
;
if
(
(
scrolledRect
.
width
>
mHelper
.
mScrollPort
.
width
)
&
&
styles
.
mHorizontal
=
=
StyleOverflow
:
:
Auto
)
{
if
(
!
mHelper
.
mHasHorizontalScrollbar
)
{
if
(
AddHorizontalScrollbar
(
aState
scrollbarBottom
)
)
{
{
nsBoxLayoutState
resizeState
(
aState
)
;
LayoutScrollArea
(
resizeState
oldScrollPosition
)
;
needsLayout
=
false
;
}
scrolledRect
=
mHelper
.
GetScrolledRect
(
)
;
if
(
styles
.
mVertical
=
=
StyleOverflow
:
:
Auto
&
&
!
mHelper
.
mHasVerticalScrollbar
&
&
scrolledRect
.
height
>
mHelper
.
mScrollPort
.
height
)
{
if
(
AddVerticalScrollbar
(
aState
scrollbarRight
)
)
{
needsLayout
=
true
;
}
}
}
}
}
else
{
if
(
mHelper
.
mHasHorizontalScrollbar
)
{
RemoveHorizontalScrollbar
(
aState
scrollbarBottom
)
;
needsLayout
=
true
;
}
}
}
if
(
needsLayout
)
{
nsBoxLayoutState
resizeState
(
aState
)
;
LayoutScrollArea
(
resizeState
oldScrollPosition
)
;
needsLayout
=
false
;
}
nsSize
hMinSize
(
0
0
)
;
if
(
mHelper
.
mHScrollbarBox
&
&
mHelper
.
mHasHorizontalScrollbar
)
{
GetScrollbarMetrics
(
aState
mHelper
.
mHScrollbarBox
&
hMinSize
nullptr
)
;
}
nsSize
vMinSize
(
0
0
)
;
if
(
mHelper
.
mVScrollbarBox
&
&
mHelper
.
mHasVerticalScrollbar
)
{
GetScrollbarMetrics
(
aState
mHelper
.
mVScrollbarBox
&
vMinSize
nullptr
)
;
}
if
(
mHelper
.
mHasHorizontalScrollbar
&
&
(
hMinSize
.
width
>
clientRect
.
width
-
vMinSize
.
width
|
|
hMinSize
.
height
>
clientRect
.
height
)
)
{
RemoveHorizontalScrollbar
(
aState
scrollbarBottom
)
;
needsLayout
=
true
;
}
if
(
mHelper
.
mHasVerticalScrollbar
&
&
(
vMinSize
.
height
>
clientRect
.
height
-
hMinSize
.
height
|
|
vMinSize
.
width
>
clientRect
.
width
)
)
{
RemoveVerticalScrollbar
(
aState
scrollbarRight
)
;
needsLayout
=
true
;
}
if
(
needsLayout
)
{
nsBoxLayoutState
resizeState
(
aState
)
;
LayoutScrollArea
(
resizeState
oldScrollPosition
)
;
}
if
(
!
mHelper
.
mSuppressScrollbarUpdate
)
{
mHelper
.
LayoutScrollbars
(
aState
clientRect
oldScrollAreaBounds
)
;
}
if
(
!
mHelper
.
mPostedReflowCallback
)
{
PresShell
(
)
-
>
PostReflowCallback
(
&
mHelper
)
;
mHelper
.
mPostedReflowCallback
=
true
;
}
if
(
!
(
GetStateBits
(
)
&
NS_FRAME_FIRST_REFLOW
)
)
{
mHelper
.
mHadNonInitialReflow
=
true
;
}
mHelper
.
UpdateSticky
(
)
;
nsIFrame
*
f
=
mHelper
.
mScrolledFrame
-
>
GetContentInsertionFrame
(
)
;
if
(
nsLayoutUtils
:
:
GetAsBlock
(
f
)
)
{
nsRect
origRect
=
f
-
>
GetRect
(
)
;
nsRect
clippedRect
=
origRect
;
clippedRect
.
MoveBy
(
mHelper
.
mScrollPort
.
TopLeft
(
)
)
;
clippedRect
.
IntersectRect
(
clippedRect
mHelper
.
mScrollPort
)
;
nsOverflowAreas
overflow
=
f
-
>
GetOverflowAreas
(
)
;
f
-
>
FinishAndStoreOverflow
(
overflow
clippedRect
.
Size
(
)
)
;
clippedRect
.
MoveTo
(
origRect
.
TopLeft
(
)
)
;
f
-
>
SetRect
(
clippedRect
)
;
}
mHelper
.
UpdatePrevScrolledRect
(
)
;
mHelper
.
PostOverflowEvent
(
)
;
return
NS_OK
;
}
void
ScrollFrameHelper
:
:
FinishReflowForScrollbar
(
Element
*
aElement
nscoord
aMinXY
nscoord
aMaxXY
nscoord
aCurPosXY
nscoord
aPageIncrement
nscoord
aIncrement
)
{
SetCoordAttribute
(
aElement
nsGkAtoms
:
:
curpos
aCurPosXY
-
aMinXY
)
;
SetScrollbarEnabled
(
aElement
aMaxXY
-
aMinXY
)
;
SetCoordAttribute
(
aElement
nsGkAtoms
:
:
maxpos
aMaxXY
-
aMinXY
)
;
SetCoordAttribute
(
aElement
nsGkAtoms
:
:
pageincrement
aPageIncrement
)
;
SetCoordAttribute
(
aElement
nsGkAtoms
:
:
increment
aIncrement
)
;
}
void
ScrollFrameHelper
:
:
UpdateMinimumScaleSize
(
const
nsRect
&
aScrollableOverflow
const
nsSize
&
aICBSize
)
{
MOZ_ASSERT
(
mIsRoot
)
;
mIsUsingMinimumScaleSize
=
false
;
if
(
!
mOuter
-
>
PresShell
(
)
-
>
GetIsViewportOverridden
(
)
)
{
return
;
}
nsPresContext
*
pc
=
mOuter
-
>
PresContext
(
)
;
MOZ_ASSERT
(
pc
-
>
IsRootContentDocument
(
)
"
The
pres
context
should
be
for
the
root
content
document
"
)
;
const
ScrollStyles
&
styles
=
pc
-
>
GetViewportScrollStylesOverride
(
)
;
if
(
styles
.
mHorizontal
!
=
StyleOverflow
:
:
Hidden
)
{
return
;
}
RefPtr
<
MobileViewportManager
>
manager
=
mOuter
-
>
PresShell
(
)
-
>
GetMobileViewportManager
(
)
;
MOZ_ASSERT
(
manager
)
;
ScreenIntSize
displaySize
=
ViewAs
<
ScreenPixel
>
(
manager
-
>
DisplaySize
(
)
PixelCastJustification
:
:
LayoutDeviceIsScreenForBounds
)
;
if
(
displaySize
.
width
=
=
0
|
|
displaySize
.
height
=
=
0
)
{
return
;
}
Document
*
doc
=
pc
-
>
Document
(
)
;
MOZ_ASSERT
(
doc
"
The
document
should
be
valid
"
)
;
if
(
doc
-
>
GetFullscreenElement
(
)
)
{
return
;
}
nsViewportInfo
viewportInfo
=
doc
-
>
GetViewportInfo
(
displaySize
)
;
nsSize
maximumPossibleSize
=
CSSSize
:
:
ToAppUnits
(
ScreenSize
(
displaySize
)
/
viewportInfo
.
GetMinZoom
(
)
)
;
mMinimumScaleSize
=
Min
(
maximumPossibleSize
nsSize
(
aScrollableOverflow
.
XMost
(
)
aScrollableOverflow
.
YMost
(
)
)
)
;
mMinimumScaleSize
=
Max
(
aICBSize
mMinimumScaleSize
)
;
if
(
mMinimumScaleSize
.
width
!
=
aICBSize
.
width
)
{
mIsUsingMinimumScaleSize
=
true
;
}
}
bool
ScrollFrameHelper
:
:
ReflowFinished
(
)
{
mPostedReflowCallback
=
false
;
bool
doScroll
=
true
;
if
(
NS_SUBTREE_DIRTY
(
mOuter
)
)
{
doScroll
=
false
;
}
nsAutoScriptBlocker
scriptBlocker
;
if
(
doScroll
)
{
ScrollToRestoredPosition
(
)
;
nsPoint
currentScrollPos
=
GetScrollPosition
(
)
;
ScrollToImpl
(
currentScrollPos
nsRect
(
currentScrollPos
nsSize
(
0
0
)
)
)
;
if
(
!
mAsyncScroll
&
&
!
mAsyncSmoothMSDScroll
&
&
!
mApzSmoothScrollDestination
)
{
mDestination
=
GetScrollPosition
(
)
;
}
}
if
(
!
mUpdateScrollbarAttributes
)
{
return
false
;
}
mUpdateScrollbarAttributes
=
false
;
if
(
mMayHaveDirtyFixedChildren
)
{
mMayHaveDirtyFixedChildren
=
false
;
nsIFrame
*
parentFrame
=
mOuter
-
>
GetParent
(
)
;
for
(
nsIFrame
*
fixedChild
=
parentFrame
-
>
GetChildList
(
nsIFrame
:
:
kFixedList
)
.
FirstChild
(
)
;
fixedChild
;
fixedChild
=
fixedChild
-
>
GetNextSibling
(
)
)
{
mOuter
-
>
PresShell
(
)
-
>
FrameNeedsReflow
(
fixedChild
nsIPresShell
:
:
eResize
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
}
}
nsRect
scrolledContentRect
=
GetScrolledRect
(
)
;
nsSize
scrollClampingScrollPort
=
GetVisualViewportSize
(
)
;
nscoord
minX
=
scrolledContentRect
.
x
;
nscoord
maxX
=
scrolledContentRect
.
XMost
(
)
-
scrollClampingScrollPort
.
width
;
nscoord
minY
=
scrolledContentRect
.
y
;
nscoord
maxY
=
scrolledContentRect
.
YMost
(
)
-
scrollClampingScrollPort
.
height
;
NS_ASSERTION
(
!
mFrameIsUpdatingScrollbar
"
We
shouldn
'
t
be
reentering
here
"
)
;
mFrameIsUpdatingScrollbar
=
true
;
RefPtr
<
Element
>
vScroll
=
mVScrollbarBox
?
mVScrollbarBox
-
>
GetContent
(
)
-
>
AsElement
(
)
:
nullptr
;
RefPtr
<
Element
>
hScroll
=
mHScrollbarBox
?
mHScrollbarBox
-
>
GetContent
(
)
-
>
AsElement
(
)
:
nullptr
;
if
(
vScroll
|
|
hScroll
)
{
AutoWeakFrame
weakFrame
(
mOuter
)
;
nsPoint
scrollPos
=
GetScrollPosition
(
)
;
nsSize
lineScrollAmount
=
GetLineScrollAmount
(
)
;
if
(
vScroll
)
{
const
double
kScrollMultiplier
=
Preferences
:
:
GetInt
(
"
toolkit
.
scrollbox
.
verticalScrollDistance
"
NS_DEFAULT_VERTICAL_SCROLL_DISTANCE
)
;
nscoord
increment
=
lineScrollAmount
.
height
*
kScrollMultiplier
;
nscoord
pageincrement
=
nscoord
(
scrollClampingScrollPort
.
height
-
increment
)
;
nscoord
pageincrementMin
=
nscoord
(
float
(
scrollClampingScrollPort
.
height
)
*
0
.
8
)
;
FinishReflowForScrollbar
(
vScroll
minY
maxY
scrollPos
.
y
std
:
:
max
(
pageincrement
pageincrementMin
)
increment
)
;
}
if
(
hScroll
)
{
const
double
kScrollMultiplier
=
Preferences
:
:
GetInt
(
"
toolkit
.
scrollbox
.
horizontalScrollDistance
"
NS_DEFAULT_HORIZONTAL_SCROLL_DISTANCE
)
;
nscoord
increment
=
lineScrollAmount
.
width
*
kScrollMultiplier
;
FinishReflowForScrollbar
(
hScroll
minX
maxX
scrollPos
.
x
nscoord
(
float
(
scrollClampingScrollPort
.
width
)
*
0
.
8
)
increment
)
;
}
NS_ENSURE_TRUE
(
weakFrame
.
IsAlive
(
)
false
)
;
}
mFrameIsUpdatingScrollbar
=
false
;
if
(
!
mHScrollbarBox
&
&
!
mVScrollbarBox
)
return
false
;
CurPosAttributeChanged
(
mVScrollbarBox
?
mVScrollbarBox
-
>
GetContent
(
)
-
>
AsElement
(
)
:
mHScrollbarBox
-
>
GetContent
(
)
-
>
AsElement
(
)
doScroll
)
;
return
doScroll
;
}
void
ScrollFrameHelper
:
:
ReflowCallbackCanceled
(
)
{
mPostedReflowCallback
=
false
;
}
bool
ScrollFrameHelper
:
:
ComputeCustomOverflow
(
nsOverflowAreas
&
aOverflowAreas
)
{
nsIScrollableFrame
*
sf
=
do_QueryFrame
(
mOuter
)
;
ScrollStyles
ss
=
sf
-
>
GetScrollStyles
(
)
;
nsRect
scrolledRect
=
GetScrolledRect
(
)
;
uint32_t
overflowChange
=
GetOverflowChange
(
scrolledRect
mPrevScrolledRect
)
;
mPrevScrolledRect
=
scrolledRect
;
bool
needReflow
=
false
;
nsPoint
scrollPosition
=
GetScrollPosition
(
)
;
if
(
overflowChange
&
nsIScrollableFrame
:
:
HORIZONTAL
)
{
if
(
ss
.
mHorizontal
!
=
StyleOverflow
:
:
Hidden
|
|
scrollPosition
.
x
)
{
needReflow
=
true
;
}
}
if
(
overflowChange
&
nsIScrollableFrame
:
:
VERTICAL
)
{
if
(
ss
.
mVertical
!
=
StyleOverflow
:
:
Hidden
|
|
scrollPosition
.
y
)
{
needReflow
=
true
;
}
}
if
(
needReflow
)
{
mOuter
-
>
PresShell
(
)
-
>
FrameNeedsReflow
(
mOuter
nsIPresShell
:
:
eResize
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
mSkippedScrollbarLayout
=
true
;
return
false
;
}
PostOverflowEvent
(
)
;
return
mOuter
-
>
nsContainerFrame
:
:
ComputeCustomOverflow
(
aOverflowAreas
)
;
}
void
ScrollFrameHelper
:
:
UpdateSticky
(
)
{
StickyScrollContainer
*
ssc
=
StickyScrollContainer
:
:
GetStickyScrollContainerForScrollFrame
(
mOuter
)
;
if
(
ssc
)
{
nsIScrollableFrame
*
scrollFrame
=
do_QueryFrame
(
mOuter
)
;
ssc
-
>
UpdatePositions
(
scrollFrame
-
>
GetScrollPosition
(
)
mOuter
)
;
}
}
void
ScrollFrameHelper
:
:
UpdatePrevScrolledRect
(
)
{
mPrevScrolledRect
=
GetScrolledRect
(
)
;
}
void
ScrollFrameHelper
:
:
AdjustScrollbarRectForResizer
(
nsIFrame
*
aFrame
nsPresContext
*
aPresContext
nsRect
&
aRect
bool
aHasResizer
ScrollDirection
aDirection
)
{
if
(
(
aDirection
=
=
ScrollDirection
:
:
eVertical
?
aRect
.
width
:
aRect
.
height
)
=
=
0
)
{
return
;
}
nsRect
resizerRect
;
if
(
aHasResizer
)
{
resizerRect
=
mResizerBox
-
>
GetRect
(
)
;
}
else
{
nsPoint
offset
;
nsIWidget
*
widget
=
aFrame
-
>
GetNearestWidget
(
offset
)
;
LayoutDeviceIntRect
widgetRect
;
if
(
!
widget
|
|
!
widget
-
>
ShowsResizeIndicator
(
&
widgetRect
)
)
{
return
;
}
resizerRect
=
nsRect
(
aPresContext
-
>
DevPixelsToAppUnits
(
widgetRect
.
x
)
-
offset
.
x
aPresContext
-
>
DevPixelsToAppUnits
(
widgetRect
.
y
)
-
offset
.
y
aPresContext
-
>
DevPixelsToAppUnits
(
widgetRect
.
width
)
aPresContext
-
>
DevPixelsToAppUnits
(
widgetRect
.
height
)
)
;
}
if
(
resizerRect
.
Contains
(
aRect
.
BottomRight
(
)
-
nsPoint
(
1
1
)
)
)
{
switch
(
aDirection
)
{
case
ScrollDirection
:
:
eVertical
:
aRect
.
height
=
std
:
:
max
(
0
resizerRect
.
y
-
aRect
.
y
)
;
break
;
case
ScrollDirection
:
:
eHorizontal
:
aRect
.
width
=
std
:
:
max
(
0
resizerRect
.
x
-
aRect
.
x
)
;
break
;
}
}
else
if
(
resizerRect
.
Contains
(
aRect
.
BottomLeft
(
)
+
nsPoint
(
1
-
1
)
)
)
{
switch
(
aDirection
)
{
case
ScrollDirection
:
:
eVertical
:
aRect
.
height
=
std
:
:
max
(
0
resizerRect
.
y
-
aRect
.
y
)
;
break
;
case
ScrollDirection
:
:
eHorizontal
:
{
nscoord
xmost
=
aRect
.
XMost
(
)
;
aRect
.
x
=
std
:
:
max
(
aRect
.
x
resizerRect
.
XMost
(
)
)
;
aRect
.
width
=
xmost
-
aRect
.
x
;
break
;
}
}
}
}
static
void
AdjustOverlappingScrollbars
(
nsRect
&
aVRect
nsRect
&
aHRect
)
{
if
(
aVRect
.
IsEmpty
(
)
|
|
aHRect
.
IsEmpty
(
)
)
return
;
const
nsRect
oldVRect
=
aVRect
;
const
nsRect
oldHRect
=
aHRect
;
if
(
oldVRect
.
Contains
(
oldHRect
.
BottomRight
(
)
-
nsPoint
(
1
1
)
)
)
{
aHRect
.
width
=
std
:
:
max
(
0
oldVRect
.
x
-
oldHRect
.
x
)
;
}
else
if
(
oldVRect
.
Contains
(
oldHRect
.
BottomLeft
(
)
-
nsPoint
(
0
1
)
)
)
{
nscoord
overlap
=
std
:
:
min
(
oldHRect
.
width
oldVRect
.
XMost
(
)
-
oldHRect
.
x
)
;
aHRect
.
x
+
=
overlap
;
aHRect
.
width
-
=
overlap
;
}
if
(
oldHRect
.
Contains
(
oldVRect
.
BottomRight
(
)
-
nsPoint
(
1
1
)
)
)
{
aVRect
.
height
=
std
:
:
max
(
0
oldHRect
.
y
-
oldVRect
.
y
)
;
}
}
void
ScrollFrameHelper
:
:
LayoutScrollbars
(
nsBoxLayoutState
&
aState
const
nsRect
&
aContentArea
const
nsRect
&
aOldScrollArea
)
{
NS_ASSERTION
(
!
mSuppressScrollbarUpdate
"
This
should
have
been
suppressed
"
)
;
nsIPresShell
*
presShell
=
mOuter
-
>
PresShell
(
)
;
bool
hasResizer
=
HasResizer
(
)
;
bool
scrollbarOnLeft
=
!
IsScrollbarOnRight
(
)
;
bool
overlayScrollBarsWithZoom
=
mIsRoot
&
&
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
eIntID_UseOverlayScrollbars
)
&
&
presShell
-
>
IsVisualViewportSizeSet
(
)
;
nsSize
scrollPortClampingSize
=
mScrollPort
.
Size
(
)
;
double
res
=
1
.
0
;
if
(
overlayScrollBarsWithZoom
)
{
scrollPortClampingSize
=
presShell
-
>
GetVisualViewportSize
(
)
;
res
=
presShell
-
>
GetCumulativeResolution
(
)
;
}
if
(
mScrollCornerBox
|
|
mResizerBox
)
{
MOZ_ASSERT
(
!
mScrollCornerBox
|
|
mScrollCornerBox
-
>
IsXULBoxFrame
(
)
"
Must
be
a
box
frame
!
"
)
;
nsRect
r
(
0
0
0
0
)
;
if
(
aContentArea
.
x
!
=
mScrollPort
.
x
|
|
scrollbarOnLeft
)
{
r
.
x
=
aContentArea
.
x
;
r
.
width
=
mScrollPort
.
x
-
aContentArea
.
x
;
NS_ASSERTION
(
r
.
width
>
=
0
"
Scroll
area
should
be
inside
client
rect
"
)
;
}
else
{
r
.
width
=
aContentArea
.
XMost
(
)
-
mScrollPort
.
XMost
(
)
;
r
.
x
=
aContentArea
.
XMost
(
)
-
r
.
width
;
NS_ASSERTION
(
r
.
width
>
=
0
"
Scroll
area
should
be
inside
client
rect
"
)
;
}
if
(
aContentArea
.
y
!
=
mScrollPort
.
y
)
{
NS_ERROR
(
"
top
scrollbars
not
supported
"
)
;
}
else
{
r
.
height
=
aContentArea
.
YMost
(
)
-
mScrollPort
.
YMost
(
)
;
r
.
y
=
aContentArea
.
YMost
(
)
-
r
.
height
;
NS_ASSERTION
(
r
.
height
>
=
0
"
Scroll
area
should
be
inside
client
rect
"
)
;
}
if
(
mScrollCornerBox
)
{
nsBoxFrame
:
:
LayoutChildAt
(
aState
mScrollCornerBox
r
)
;
}
if
(
hasResizer
)
{
nscoord
defaultSize
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
15
)
;
nsSize
resizerMinSize
=
mResizerBox
-
>
GetXULMinSize
(
aState
)
;
nscoord
vScrollbarWidth
=
mVScrollbarBox
?
mVScrollbarBox
-
>
GetXULPrefSize
(
aState
)
.
width
:
defaultSize
;
r
.
width
=
std
:
:
max
(
std
:
:
max
(
r
.
width
vScrollbarWidth
)
resizerMinSize
.
width
)
;
if
(
aContentArea
.
x
=
=
mScrollPort
.
x
&
&
!
scrollbarOnLeft
)
{
r
.
x
=
aContentArea
.
XMost
(
)
-
r
.
width
;
}
nscoord
hScrollbarHeight
=
mHScrollbarBox
?
mHScrollbarBox
-
>
GetXULPrefSize
(
aState
)
.
height
:
defaultSize
;
r
.
height
=
std
:
:
max
(
std
:
:
max
(
r
.
height
hScrollbarHeight
)
resizerMinSize
.
height
)
;
if
(
aContentArea
.
y
=
=
mScrollPort
.
y
)
{
r
.
y
=
aContentArea
.
YMost
(
)
-
r
.
height
;
}
nsBoxFrame
:
:
LayoutChildAt
(
aState
mResizerBox
r
)
;
}
else
if
(
mResizerBox
)
{
nsBoxFrame
:
:
LayoutChildAt
(
aState
mResizerBox
nsRect
(
)
)
;
}
}
nsPresContext
*
presContext
=
mScrolledFrame
-
>
PresContext
(
)
;
nsRect
vRect
;
if
(
mVScrollbarBox
)
{
MOZ_ASSERT
(
mVScrollbarBox
-
>
IsXULBoxFrame
(
)
"
Must
be
a
box
frame
!
"
)
;
vRect
=
mScrollPort
;
if
(
overlayScrollBarsWithZoom
)
{
vRect
.
height
=
NSToCoordRound
(
res
*
scrollPortClampingSize
.
height
)
;
}
vRect
.
width
=
aContentArea
.
width
-
mScrollPort
.
width
;
vRect
.
x
=
scrollbarOnLeft
?
aContentArea
.
x
:
mScrollPort
.
x
+
NSToCoordRound
(
res
*
scrollPortClampingSize
.
width
)
;
if
(
mHasVerticalScrollbar
)
{
nsMargin
margin
;
mVScrollbarBox
-
>
GetXULMargin
(
margin
)
;
vRect
.
Deflate
(
margin
)
;
}
AdjustScrollbarRectForResizer
(
mOuter
presContext
vRect
hasResizer
ScrollDirection
:
:
eVertical
)
;
}
nsRect
hRect
;
if
(
mHScrollbarBox
)
{
MOZ_ASSERT
(
mHScrollbarBox
-
>
IsXULBoxFrame
(
)
"
Must
be
a
box
frame
!
"
)
;
hRect
=
mScrollPort
;
if
(
overlayScrollBarsWithZoom
)
{
hRect
.
width
=
NSToCoordRound
(
res
*
scrollPortClampingSize
.
width
)
;
}
hRect
.
height
=
aContentArea
.
height
-
mScrollPort
.
height
;
hRect
.
y
=
mScrollPort
.
y
+
NSToCoordRound
(
res
*
scrollPortClampingSize
.
height
)
;
if
(
mHasHorizontalScrollbar
)
{
nsMargin
margin
;
mHScrollbarBox
-
>
GetXULMargin
(
margin
)
;
hRect
.
Deflate
(
margin
)
;
}
AdjustScrollbarRectForResizer
(
mOuter
presContext
hRect
hasResizer
ScrollDirection
:
:
eHorizontal
)
;
}
if
(
!
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
eIntID_AllowOverlayScrollbarsOverlap
)
)
{
AdjustOverlappingScrollbars
(
vRect
hRect
)
;
}
if
(
mVScrollbarBox
)
{
nsBoxFrame
:
:
LayoutChildAt
(
aState
mVScrollbarBox
vRect
)
;
}
if
(
mHScrollbarBox
)
{
nsBoxFrame
:
:
LayoutChildAt
(
aState
mHScrollbarBox
hRect
)
;
}
if
(
aOldScrollArea
.
Size
(
)
!
=
mScrollPort
.
Size
(
)
&
&
!
(
mOuter
-
>
GetStateBits
(
)
&
NS_FRAME_IS_DIRTY
)
&
&
mIsRoot
)
{
mMayHaveDirtyFixedChildren
=
true
;
}
mUpdateScrollbarAttributes
=
true
;
if
(
!
mPostedReflowCallback
)
{
aState
.
PresShell
(
)
-
>
PostReflowCallback
(
this
)
;
mPostedReflowCallback
=
true
;
}
}
#
if
DEBUG
static
bool
ShellIsAlive
(
nsWeakPtr
&
aWeakPtr
)
{
nsCOMPtr
<
nsIPresShell
>
shell
(
do_QueryReferent
(
aWeakPtr
)
)
;
return
!
!
shell
;
}
#
endif
void
ScrollFrameHelper
:
:
SetScrollbarEnabled
(
Element
*
aElement
nscoord
aMaxPos
)
{
DebugOnly
<
nsWeakPtr
>
weakShell
(
do_GetWeakReference
(
mOuter
-
>
PresShell
(
)
)
)
;
if
(
aMaxPos
)
{
aElement
-
>
UnsetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
disabled
true
)
;
}
else
{
aElement
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
disabled
NS_LITERAL_STRING
(
"
true
"
)
true
)
;
}
MOZ_ASSERT
(
ShellIsAlive
(
weakShell
)
"
pres
shell
was
destroyed
by
scrolling
"
)
;
}
void
ScrollFrameHelper
:
:
SetCoordAttribute
(
Element
*
aElement
nsAtom
*
aAtom
nscoord
aSize
)
{
DebugOnly
<
nsWeakPtr
>
weakShell
(
do_GetWeakReference
(
mOuter
-
>
PresShell
(
)
)
)
;
int32_t
pixelSize
=
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
aSize
)
;
nsAutoString
newValue
;
newValue
.
AppendInt
(
pixelSize
)
;
if
(
aElement
-
>
AttrValueIs
(
kNameSpaceID_None
aAtom
newValue
eCaseMatters
)
)
{
return
;
}
AutoWeakFrame
weakFrame
(
mOuter
)
;
RefPtr
<
Element
>
kungFuDeathGrip
=
aElement
;
aElement
-
>
SetAttr
(
kNameSpaceID_None
aAtom
newValue
true
)
;
MOZ_ASSERT
(
ShellIsAlive
(
weakShell
)
"
pres
shell
was
destroyed
by
scrolling
"
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
;
}
if
(
mScrollbarActivity
)
{
RefPtr
<
ScrollbarActivity
>
scrollbarActivity
(
mScrollbarActivity
)
;
scrollbarActivity
-
>
ActivityOccurred
(
)
;
}
}
static
void
ReduceRadii
(
nscoord
aXBorder
nscoord
aYBorder
nscoord
&
aXRadius
nscoord
&
aYRadius
)
{
if
(
aXRadius
<
=
aXBorder
|
|
aYRadius
<
=
aYBorder
)
return
;
double
ratio
=
std
:
:
max
(
double
(
aXBorder
)
/
aXRadius
double
(
aYBorder
)
/
aYRadius
)
;
aXRadius
*
=
ratio
;
aYRadius
*
=
ratio
;
}
bool
ScrollFrameHelper
:
:
GetBorderRadii
(
const
nsSize
&
aFrameSize
const
nsSize
&
aBorderArea
Sides
aSkipSides
nscoord
aRadii
[
8
]
)
const
{
if
(
!
mOuter
-
>
nsContainerFrame
:
:
GetBorderRadii
(
aFrameSize
aBorderArea
aSkipSides
aRadii
)
)
{
return
false
;
}
nsMargin
sb
=
GetActualScrollbarSizes
(
)
;
nsMargin
border
=
mOuter
-
>
GetUsedBorder
(
)
;
if
(
sb
.
left
>
0
|
|
sb
.
top
>
0
)
{
ReduceRadii
(
border
.
left
border
.
top
aRadii
[
eCornerTopLeftX
]
aRadii
[
eCornerTopLeftY
]
)
;
}
if
(
sb
.
top
>
0
|
|
sb
.
right
>
0
)
{
ReduceRadii
(
border
.
right
border
.
top
aRadii
[
eCornerTopRightX
]
aRadii
[
eCornerTopRightY
]
)
;
}
if
(
sb
.
right
>
0
|
|
sb
.
bottom
>
0
)
{
ReduceRadii
(
border
.
right
border
.
bottom
aRadii
[
eCornerBottomRightX
]
aRadii
[
eCornerBottomRightY
]
)
;
}
if
(
sb
.
bottom
>
0
|
|
sb
.
left
>
0
)
{
ReduceRadii
(
border
.
left
border
.
bottom
aRadii
[
eCornerBottomLeftX
]
aRadii
[
eCornerBottomLeftY
]
)
;
}
return
true
;
}
static
nscoord
SnapCoord
(
nscoord
aCoord
double
aRes
nscoord
aAppUnitsPerPixel
)
{
double
snappedToLayerPixels
=
NS_round
(
(
aRes
*
aCoord
)
/
aAppUnitsPerPixel
)
;
return
NSToCoordRoundWithClamp
(
snappedToLayerPixels
*
aAppUnitsPerPixel
/
aRes
)
;
}
nsRect
ScrollFrameHelper
:
:
GetScrolledRect
(
)
const
{
nsRect
result
=
GetUnsnappedScrolledRectInternal
(
mScrolledFrame
-
>
GetScrollableOverflowRect
(
)
mScrollPort
.
Size
(
)
)
;
if
(
result
.
width
<
mScrollPort
.
width
)
{
NS_WARNING
(
"
Scrolled
rect
smaller
than
scrollport
?
"
)
;
}
if
(
result
.
height
<
mScrollPort
.
height
)
{
NS_WARNING
(
"
Scrolled
rect
smaller
than
scrollport
?
"
)
;
}
if
(
result
.
x
=
=
0
&
&
result
.
y
=
=
0
&
&
result
.
width
=
=
mScrollPort
.
width
&
&
result
.
height
=
=
mScrollPort
.
height
)
{
return
result
;
}
nsSize
visualViewportSize
=
GetVisualViewportSize
(
)
;
const
nsIFrame
*
referenceFrame
=
mReferenceFrameDuringPainting
?
mReferenceFrameDuringPainting
:
nsLayoutUtils
:
:
GetReferenceFrame
(
mOuter
)
;
nsPoint
toReferenceFrame
=
mOuter
-
>
GetOffsetToCrossDoc
(
referenceFrame
)
;
nsRect
scrollPort
(
mScrollPort
.
TopLeft
(
)
+
toReferenceFrame
visualViewportSize
)
;
nsRect
scrolledRect
=
result
+
scrollPort
.
TopLeft
(
)
;
if
(
scrollPort
.
Overflows
(
)
|
|
scrolledRect
.
Overflows
(
)
)
{
return
result
;
}
nscoord
appUnitsPerDevPixel
=
mScrolledFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
gfxSize
scale
=
FrameLayerBuilder
:
:
GetPaintedLayerScaleForFrame
(
mScrolledFrame
)
;
if
(
scale
.
IsEmpty
(
)
)
{
scale
=
gfxSize
(
1
.
0f
1
.
0f
)
;
}
nscoord
snappedScrolledAreaBottom
=
SnapCoord
(
scrolledRect
.
YMost
(
)
scale
.
height
appUnitsPerDevPixel
)
;
nscoord
snappedScrollPortBottom
=
SnapCoord
(
scrollPort
.
YMost
(
)
scale
.
height
appUnitsPerDevPixel
)
;
nscoord
maximumScrollOffsetY
=
snappedScrolledAreaBottom
-
snappedScrollPortBottom
;
result
.
SetBottomEdge
(
scrollPort
.
height
+
maximumScrollOffsetY
)
;
if
(
GetScrolledFrameDir
(
)
=
=
NS_STYLE_DIRECTION_LTR
)
{
nscoord
snappedScrolledAreaRight
=
SnapCoord
(
scrolledRect
.
XMost
(
)
scale
.
width
appUnitsPerDevPixel
)
;
nscoord
snappedScrollPortRight
=
SnapCoord
(
scrollPort
.
XMost
(
)
scale
.
width
appUnitsPerDevPixel
)
;
nscoord
maximumScrollOffsetX
=
snappedScrolledAreaRight
-
snappedScrollPortRight
;
result
.
SetRightEdge
(
scrollPort
.
width
+
maximumScrollOffsetX
)
;
}
else
{
nscoord
snappedScrolledAreaLeft
=
SnapCoord
(
scrolledRect
.
x
scale
.
width
appUnitsPerDevPixel
)
;
nscoord
snappedScrollPortLeft
=
SnapCoord
(
scrollPort
.
x
scale
.
width
appUnitsPerDevPixel
)
;
nscoord
minimumScrollOffsetX
=
snappedScrolledAreaLeft
-
snappedScrollPortLeft
;
result
.
SetLeftEdge
(
minimumScrollOffsetX
)
;
}
return
result
;
}
uint8_t
ScrollFrameHelper
:
:
GetScrolledFrameDir
(
)
const
{
if
(
mScrolledFrame
-
>
StyleTextReset
(
)
-
>
mUnicodeBidi
&
NS_STYLE_UNICODE_BIDI_PLAINTEXT
)
{
nsIFrame
*
childFrame
=
mScrolledFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
childFrame
)
{
return
(
nsBidiPresUtils
:
:
ParagraphDirection
(
childFrame
)
=
=
NSBIDI_LTR
)
?
NS_STYLE_DIRECTION_LTR
:
NS_STYLE_DIRECTION_RTL
;
}
}
return
IsBidiLTR
(
)
?
NS_STYLE_DIRECTION_LTR
:
NS_STYLE_DIRECTION_RTL
;
}
nsRect
ScrollFrameHelper
:
:
GetUnsnappedScrolledRectInternal
(
const
nsRect
&
aScrolledFrameOverflowArea
const
nsSize
&
aScrollPortSize
)
const
{
return
nsLayoutUtils
:
:
GetScrolledRect
(
mScrolledFrame
aScrolledFrameOverflowArea
aScrollPortSize
GetScrolledFrameDir
(
)
)
;
}
nsMargin
ScrollFrameHelper
:
:
GetActualScrollbarSizes
(
)
const
{
nsRect
r
=
mOuter
-
>
GetPaddingRectRelativeToSelf
(
)
;
return
nsMargin
(
mScrollPort
.
y
-
r
.
y
r
.
XMost
(
)
-
mScrollPort
.
XMost
(
)
r
.
YMost
(
)
-
mScrollPort
.
YMost
(
)
mScrollPort
.
x
-
r
.
x
)
;
}
void
ScrollFrameHelper
:
:
SetScrollbarVisibility
(
nsIFrame
*
aScrollbar
bool
aVisible
)
{
nsScrollbarFrame
*
scrollbar
=
do_QueryFrame
(
aScrollbar
)
;
if
(
scrollbar
)
{
nsIScrollbarMediator
*
mediator
=
scrollbar
-
>
GetScrollbarMediator
(
)
;
if
(
mediator
)
{
mediator
-
>
VisibilityChanged
(
aVisible
)
;
}
}
}
nscoord
ScrollFrameHelper
:
:
GetCoordAttribute
(
nsIFrame
*
aBox
nsAtom
*
aAtom
nscoord
aDefaultValue
nscoord
*
aRangeStart
nscoord
*
aRangeLength
)
{
if
(
aBox
)
{
nsIContent
*
content
=
aBox
-
>
GetContent
(
)
;
nsAutoString
value
;
if
(
content
-
>
IsElement
(
)
)
{
content
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
aAtom
value
)
;
}
if
(
!
value
.
IsEmpty
(
)
)
{
nsresult
error
;
nscoord
result
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
value
.
ToInteger
(
&
error
)
)
;
nscoord
halfPixel
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
0
.
5f
)
;
*
aRangeStart
=
result
-
halfPixel
;
*
aRangeLength
=
halfPixel
*
2
-
1
;
return
result
;
}
}
*
aRangeStart
=
aDefaultValue
;
*
aRangeLength
=
0
;
return
aDefaultValue
;
}
UniquePtr
<
PresState
>
ScrollFrameHelper
:
:
SaveState
(
)
const
{
nsIScrollbarMediator
*
mediator
=
do_QueryFrame
(
GetScrolledFrame
(
)
)
;
if
(
mediator
)
{
return
nullptr
;
}
bool
isInSmoothScroll
=
IsProcessingAsyncScroll
(
)
|
|
mLastSmoothScrollOrigin
;
if
(
!
mHasBeenScrolled
&
&
!
mDidHistoryRestore
&
&
!
isInSmoothScroll
)
{
return
nullptr
;
}
UniquePtr
<
PresState
>
state
=
NewPresState
(
)
;
bool
allowScrollOriginDowngrade
=
!
nsLayoutUtils
:
:
CanScrollOriginClobberApz
(
mLastScrollOrigin
)
|
|
mAllowScrollOriginDowngrade
;
nsPoint
pt
=
GetLogicalVisualViewportOffset
(
)
;
if
(
isInSmoothScroll
)
{
pt
=
mDestination
;
allowScrollOriginDowngrade
=
false
;
}
if
(
mRestorePos
.
y
!
=
-
1
&
&
pt
=
=
mLastPos
)
{
pt
=
mRestorePos
;
}
state
-
>
scrollState
(
)
=
pt
;
state
-
>
allowScrollOriginDowngrade
(
)
=
allowScrollOriginDowngrade
;
if
(
mIsRoot
)
{
nsIPresShell
*
shell
=
mOuter
-
>
PresShell
(
)
;
state
-
>
resolution
(
)
=
shell
-
>
GetResolution
(
)
;
}
return
state
;
}
void
ScrollFrameHelper
:
:
RestoreState
(
PresState
*
aState
)
{
mRestorePos
=
aState
-
>
scrollState
(
)
;
MOZ_ASSERT
(
mLastScrollOrigin
=
=
nsGkAtoms
:
:
other
)
;
mAllowScrollOriginDowngrade
=
aState
-
>
allowScrollOriginDowngrade
(
)
;
mDidHistoryRestore
=
true
;
mLastPos
=
mScrolledFrame
?
GetLogicalVisualViewportOffset
(
)
:
nsPoint
(
0
0
)
;
MOZ_ASSERT
(
mIsRoot
|
|
aState
-
>
resolution
(
)
=
=
1
.
0
)
;
if
(
mIsRoot
)
{
nsIPresShell
*
presShell
=
mOuter
-
>
PresShell
(
)
;
presShell
-
>
SetResolutionAndScaleTo
(
aState
-
>
resolution
(
)
nsIPresShell
:
:
ChangeOrigin
:
:
eMainThread
)
;
}
}
void
ScrollFrameHelper
:
:
PostScrolledAreaEvent
(
)
{
if
(
mScrolledAreaEvent
.
IsPending
(
)
)
{
return
;
}
mScrolledAreaEvent
=
new
ScrolledAreaEvent
(
this
)
;
nsContentUtils
:
:
AddScriptRunner
(
mScrolledAreaEvent
.
get
(
)
)
;
}
NS_IMETHODIMP
ScrollFrameHelper
:
:
ScrolledAreaEvent
:
:
Run
(
)
{
if
(
mHelper
)
{
mHelper
-
>
FireScrolledAreaEvent
(
)
;
}
return
NS_OK
;
}
void
ScrollFrameHelper
:
:
FireScrolledAreaEvent
(
)
{
mScrolledAreaEvent
.
Forget
(
)
;
InternalScrollAreaEvent
event
(
true
eScrolledAreaChanged
nullptr
)
;
nsPresContext
*
prescontext
=
mOuter
-
>
PresContext
(
)
;
nsIContent
*
content
=
mOuter
-
>
GetContent
(
)
;
event
.
mArea
=
mScrolledFrame
-
>
GetScrollableOverflowRectRelativeToParent
(
)
;
if
(
Document
*
doc
=
content
-
>
GetUncomposedDoc
(
)
)
{
EventDispatcher
:
:
Dispatch
(
ToSupports
(
doc
)
prescontext
&
event
nullptr
)
;
}
}
uint32_t
nsIScrollableFrame
:
:
GetPerceivedScrollingDirections
(
)
const
{
nscoord
oneDevPixel
=
GetScrolledFrame
(
)
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
uint32_t
directions
=
GetScrollbarVisibility
(
)
;
nsRect
scrollRange
=
GetScrollRange
(
)
;
if
(
scrollRange
.
width
>
=
oneDevPixel
)
{
directions
|
=
HORIZONTAL
;
}
if
(
scrollRange
.
height
>
=
oneDevPixel
)
{
directions
|
=
VERTICAL
;
}
return
directions
;
}
static
void
CollectScrollSnapCoordinates
(
nsIFrame
*
aFrame
nsIFrame
*
aScrolledFrame
nsTArray
<
nsPoint
>
&
aOutCoords
)
{
nsIFrame
:
:
ChildListIterator
childLists
(
aFrame
)
;
for
(
;
!
childLists
.
IsDone
(
)
;
childLists
.
Next
(
)
)
{
nsFrameList
:
:
Enumerator
childFrames
(
childLists
.
CurrentList
(
)
)
;
for
(
;
!
childFrames
.
AtEnd
(
)
;
childFrames
.
Next
(
)
)
{
nsIFrame
*
f
=
childFrames
.
get
(
)
;
const
nsStyleDisplay
*
styleDisplay
=
f
-
>
StyleDisplay
(
)
;
size_t
coordCount
=
styleDisplay
-
>
mScrollSnapCoordinate
.
Length
(
)
;
if
(
coordCount
)
{
nsRect
frameRect
=
f
-
>
GetRect
(
)
;
nsPoint
offset
=
f
-
>
GetOffsetTo
(
aScrolledFrame
)
;
nsRect
edgesRect
=
nsRect
(
offset
frameRect
.
Size
(
)
)
;
for
(
size_t
coordNum
=
0
;
coordNum
<
coordCount
;
coordNum
+
+
)
{
const
Position
&
coordPosition
=
f
-
>
StyleDisplay
(
)
-
>
mScrollSnapCoordinate
[
coordNum
]
;
nsPoint
coordPoint
=
edgesRect
.
TopLeft
(
)
;
coordPoint
+
=
nsPoint
(
coordPosition
.
mXPosition
.
mLength
coordPosition
.
mYPosition
.
mLength
)
;
if
(
coordPosition
.
mXPosition
.
mHasPercent
)
{
coordPoint
.
x
+
=
NSToCoordRound
(
coordPosition
.
mXPosition
.
mPercent
*
frameRect
.
width
)
;
}
if
(
coordPosition
.
mYPosition
.
mHasPercent
)
{
coordPoint
.
y
+
=
NSToCoordRound
(
coordPosition
.
mYPosition
.
mPercent
*
frameRect
.
height
)
;
}
aOutCoords
.
AppendElement
(
coordPoint
)
;
}
}
CollectScrollSnapCoordinates
(
f
aScrolledFrame
aOutCoords
)
;
}
}
}
static
layers
:
:
ScrollSnapInfo
ComputeScrollSnapInfo
(
const
ScrollFrameHelper
&
aScrollFrame
)
{
ScrollSnapInfo
result
;
ScrollStyles
styles
=
aScrollFrame
.
GetScrollStylesFromFrame
(
)
;
if
(
styles
.
mScrollSnapTypeY
=
=
StyleScrollSnapType
:
:
None
&
&
styles
.
mScrollSnapTypeX
=
=
StyleScrollSnapType
:
:
None
)
{
return
result
;
}
result
.
mScrollSnapTypeX
=
styles
.
mScrollSnapTypeX
;
result
.
mScrollSnapTypeY
=
styles
.
mScrollSnapTypeY
;
nsSize
scrollPortSize
=
aScrollFrame
.
GetScrollPortRect
(
)
.
Size
(
)
;
result
.
mScrollSnapDestination
=
nsPoint
(
styles
.
mScrollSnapDestinationX
.
mLength
styles
.
mScrollSnapDestinationY
.
mLength
)
;
if
(
styles
.
mScrollSnapDestinationX
.
mHasPercent
)
{
result
.
mScrollSnapDestination
.
x
+
=
NSToCoordFloorClamped
(
styles
.
mScrollSnapDestinationX
.
mPercent
*
scrollPortSize
.
width
)
;
}
if
(
styles
.
mScrollSnapDestinationY
.
mHasPercent
)
{
result
.
mScrollSnapDestination
.
y
+
=
NSToCoordFloorClamped
(
styles
.
mScrollSnapDestinationY
.
mPercent
*
scrollPortSize
.
height
)
;
}
if
(
styles
.
mScrollSnapPointsX
.
GetUnit
(
)
!
=
eStyleUnit_None
)
{
result
.
mScrollSnapIntervalX
=
Some
(
styles
.
mScrollSnapPointsX
.
ComputeCoordPercentCalc
(
scrollPortSize
.
width
)
)
;
}
if
(
styles
.
mScrollSnapPointsY
.
GetUnit
(
)
!
=
eStyleUnit_None
)
{
result
.
mScrollSnapIntervalY
=
Some
(
styles
.
mScrollSnapPointsY
.
ComputeCoordPercentCalc
(
scrollPortSize
.
height
)
)
;
}
CollectScrollSnapCoordinates
(
aScrollFrame
.
GetScrolledFrame
(
)
aScrollFrame
.
GetScrolledFrame
(
)
result
.
mScrollSnapCoordinates
)
;
return
result
;
}
layers
:
:
ScrollSnapInfo
ScrollFrameHelper
:
:
GetScrollSnapInfo
(
)
const
{
return
ComputeScrollSnapInfo
(
*
this
)
;
}
bool
ScrollFrameHelper
:
:
GetSnapPointForDestination
(
nsIScrollableFrame
:
:
ScrollUnit
aUnit
nsPoint
aStartPos
nsPoint
&
aDestination
)
{
Maybe
<
nsPoint
>
snapPoint
=
ScrollSnapUtils
:
:
GetSnapPointForDestination
(
GetScrollSnapInfo
(
)
aUnit
mScrollPort
.
Size
(
)
GetScrollRangeForClamping
(
)
aStartPos
aDestination
)
;
if
(
snapPoint
)
{
aDestination
=
snapPoint
.
ref
(
)
;
return
true
;
}
return
false
;
}
bool
ScrollFrameHelper
:
:
UsesContainerScrolling
(
)
const
{
if
(
gfxPrefs
:
:
LayoutUseContainersForRootFrames
(
)
)
{
return
mIsRoot
;
}
return
false
;
}
bool
ScrollFrameHelper
:
:
DragScroll
(
WidgetEvent
*
aEvent
)
{
nscoord
margin
=
20
*
mOuter
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
if
(
mScrollPort
.
width
<
margin
*
2
|
|
mScrollPort
.
height
<
margin
*
2
)
{
return
false
;
}
bool
willScroll
=
false
;
nsPoint
pnt
=
nsLayoutUtils
:
:
GetEventCoordinatesRelativeTo
(
aEvent
mOuter
)
;
nsPoint
scrollPoint
=
GetScrollPosition
(
)
;
nsRect
rangeRect
=
GetScrollRangeForClamping
(
)
;
nsPoint
offset
;
if
(
mHasHorizontalScrollbar
)
{
if
(
pnt
.
x
>
=
mScrollPort
.
x
&
&
pnt
.
x
<
=
mScrollPort
.
x
+
margin
)
{
offset
.
x
=
-
margin
;
if
(
scrollPoint
.
x
>
0
)
{
willScroll
=
true
;
}
}
else
if
(
pnt
.
x
>
=
mScrollPort
.
XMost
(
)
-
margin
&
&
pnt
.
x
<
=
mScrollPort
.
XMost
(
)
)
{
offset
.
x
=
margin
;
if
(
scrollPoint
.
x
<
rangeRect
.
width
)
{
willScroll
=
true
;
}
}
}
if
(
mHasVerticalScrollbar
)
{
if
(
pnt
.
y
>
=
mScrollPort
.
y
&
&
pnt
.
y
<
=
mScrollPort
.
y
+
margin
)
{
offset
.
y
=
-
margin
;
if
(
scrollPoint
.
y
>
0
)
{
willScroll
=
true
;
}
}
else
if
(
pnt
.
y
>
=
mScrollPort
.
YMost
(
)
-
margin
&
&
pnt
.
y
<
=
mScrollPort
.
YMost
(
)
)
{
offset
.
y
=
margin
;
if
(
scrollPoint
.
y
<
rangeRect
.
height
)
{
willScroll
=
true
;
}
}
}
if
(
offset
.
x
|
|
offset
.
y
)
{
ScrollTo
(
GetScrollPosition
(
)
+
offset
nsIScrollableFrame
:
:
NORMAL
nsGkAtoms
:
:
other
)
;
}
return
willScroll
;
}
static
nsSliderFrame
*
GetSliderFrame
(
nsIFrame
*
aScrollbarFrame
)
{
if
(
!
aScrollbarFrame
)
{
return
nullptr
;
}
for
(
nsIFrame
:
:
ChildListIterator
childLists
(
aScrollbarFrame
)
;
!
childLists
.
IsDone
(
)
;
childLists
.
Next
(
)
)
{
for
(
nsIFrame
*
frame
:
childLists
.
CurrentList
(
)
)
{
if
(
nsSliderFrame
*
sliderFrame
=
do_QueryFrame
(
frame
)
)
{
return
sliderFrame
;
}
}
}
return
nullptr
;
}
static
void
AsyncScrollbarDragInitiated
(
uint64_t
aDragBlockId
nsIFrame
*
aScrollbar
)
{
if
(
nsSliderFrame
*
sliderFrame
=
GetSliderFrame
(
aScrollbar
)
)
{
sliderFrame
-
>
AsyncScrollbarDragInitiated
(
aDragBlockId
)
;
}
}
void
ScrollFrameHelper
:
:
AsyncScrollbarDragInitiated
(
uint64_t
aDragBlockId
ScrollDirection
aDirection
)
{
switch
(
aDirection
)
{
case
ScrollDirection
:
:
eVertical
:
:
:
AsyncScrollbarDragInitiated
(
aDragBlockId
mVScrollbarBox
)
;
break
;
case
ScrollDirection
:
:
eHorizontal
:
:
:
AsyncScrollbarDragInitiated
(
aDragBlockId
mHScrollbarBox
)
;
break
;
}
}
static
void
AsyncScrollbarDragRejected
(
nsIFrame
*
aScrollbar
)
{
if
(
nsSliderFrame
*
sliderFrame
=
GetSliderFrame
(
aScrollbar
)
)
{
sliderFrame
-
>
AsyncScrollbarDragRejected
(
)
;
}
}
void
ScrollFrameHelper
:
:
AsyncScrollbarDragRejected
(
)
{
:
:
AsyncScrollbarDragRejected
(
mHScrollbarBox
)
;
:
:
AsyncScrollbarDragRejected
(
mVScrollbarBox
)
;
}
