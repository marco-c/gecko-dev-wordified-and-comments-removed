#
include
"
nsRubyFrame
.
h
"
#
include
"
RubyUtils
.
h
"
#
include
"
mozilla
/
ComputedStyle
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
WritingModes
.
h
"
#
include
"
nsLineLayout
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsRubyBaseContainerFrame
.
h
"
#
include
"
nsRubyTextContainerFrame
.
h
"
using
namespace
mozilla
;
NS_QUERYFRAME_HEAD
(
nsRubyFrame
)
NS_QUERYFRAME_ENTRY
(
nsRubyFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsInlineFrame
)
NS_IMPL_FRAMEARENA_HELPERS
(
nsRubyFrame
)
nsContainerFrame
*
NS_NewRubyFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsRubyFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
bool
nsRubyFrame
:
:
IsFrameOfType
(
uint32_t
aFlags
)
const
{
if
(
aFlags
&
eBidiInlineContainer
)
{
return
false
;
}
return
nsInlineFrame
:
:
IsFrameOfType
(
aFlags
)
;
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
nsRubyFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
NS_LITERAL_STRING
(
"
Ruby
"
)
aResult
)
;
}
#
endif
void
nsRubyFrame
:
:
AddInlineMinISize
(
gfxContext
*
aRenderingContext
nsIFrame
:
:
InlineMinISizeData
*
aData
)
{
for
(
nsIFrame
*
frame
=
this
;
frame
;
frame
=
frame
-
>
GetNextInFlow
(
)
)
{
for
(
RubySegmentEnumerator
e
(
static_cast
<
nsRubyFrame
*
>
(
frame
)
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
)
{
e
.
GetBaseContainer
(
)
-
>
AddInlineMinISize
(
aRenderingContext
aData
)
;
}
}
}
void
nsRubyFrame
:
:
AddInlinePrefISize
(
gfxContext
*
aRenderingContext
nsIFrame
:
:
InlinePrefISizeData
*
aData
)
{
for
(
nsIFrame
*
frame
=
this
;
frame
;
frame
=
frame
-
>
GetNextInFlow
(
)
)
{
for
(
RubySegmentEnumerator
e
(
static_cast
<
nsRubyFrame
*
>
(
frame
)
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
)
{
e
.
GetBaseContainer
(
)
-
>
AddInlinePrefISize
(
aRenderingContext
aData
)
;
}
}
aData
-
>
mLineIsEmpty
=
false
;
}
static
nsRubyBaseContainerFrame
*
FindRubyBaseContainerAncestor
(
nsIFrame
*
aFrame
)
{
for
(
nsIFrame
*
ancestor
=
aFrame
-
>
GetParent
(
)
;
ancestor
&
&
ancestor
-
>
IsFrameOfType
(
nsIFrame
:
:
eLineParticipant
)
;
ancestor
=
ancestor
-
>
GetParent
(
)
)
{
if
(
ancestor
-
>
IsRubyBaseContainerFrame
(
)
)
{
return
static_cast
<
nsRubyBaseContainerFrame
*
>
(
ancestor
)
;
}
}
return
nullptr
;
}
void
nsRubyFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsRubyFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aDesiredSize
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
if
(
!
aReflowInput
.
mLineLayout
)
{
NS_ASSERTION
(
aReflowInput
.
mLineLayout
"
No
line
layout
provided
to
RubyFrame
reflow
method
.
"
)
;
return
;
}
MoveInlineOverflowToChildList
(
aReflowInput
.
mLineLayout
-
>
LineContainerFrame
(
)
)
;
mLeadings
.
Reset
(
)
;
for
(
nsIFrame
*
child
:
PrincipalChildList
(
)
)
{
if
(
child
-
>
HasAnyStateBits
(
NS_FRAME_IS_DIRTY
)
&
&
child
-
>
IsRubyTextContainerFrame
(
)
)
{
for
(
nsIFrame
*
grandchild
:
child
-
>
PrincipalChildList
(
)
)
{
grandchild
-
>
AddStateBits
(
NS_FRAME_IS_DIRTY
)
;
}
child
-
>
RemoveStateBits
(
NS_FRAME_IS_DIRTY
)
;
child
-
>
AddStateBits
(
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
}
}
WritingMode
frameWM
=
aReflowInput
.
GetWritingMode
(
)
;
WritingMode
lineWM
=
aReflowInput
.
mLineLayout
-
>
GetWritingMode
(
)
;
LogicalMargin
borderPadding
=
aReflowInput
.
ComputedLogicalBorderPadding
(
)
;
nscoord
startEdge
=
0
;
const
bool
boxDecorationBreakClone
=
StyleBorder
(
)
-
>
mBoxDecorationBreak
=
=
StyleBoxDecorationBreak
:
:
Clone
;
if
(
boxDecorationBreakClone
|
|
!
GetPrevContinuation
(
)
)
{
startEdge
=
borderPadding
.
IStart
(
frameWM
)
;
}
NS_ASSERTION
(
aReflowInput
.
AvailableISize
(
)
!
=
NS_UNCONSTRAINEDSIZE
"
should
no
longer
use
available
widths
"
)
;
nscoord
availableISize
=
aReflowInput
.
AvailableISize
(
)
;
availableISize
-
=
startEdge
+
borderPadding
.
IEnd
(
frameWM
)
;
aReflowInput
.
mLineLayout
-
>
BeginSpan
(
this
&
aReflowInput
startEdge
availableISize
&
mBaseline
)
;
for
(
RubySegmentEnumerator
e
(
this
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
)
{
ReflowSegment
(
aPresContext
aReflowInput
e
.
GetBaseContainer
(
)
aStatus
)
;
if
(
aStatus
.
IsInlineBreak
(
)
)
{
break
;
}
}
ContinuationTraversingState
pullState
(
this
)
;
while
(
aStatus
.
IsEmpty
(
)
)
{
nsRubyBaseContainerFrame
*
baseContainer
=
PullOneSegment
(
aReflowInput
.
mLineLayout
pullState
)
;
if
(
!
baseContainer
)
{
break
;
}
ReflowSegment
(
aPresContext
aReflowInput
baseContainer
aStatus
)
;
}
MOZ_ASSERT
(
!
aStatus
.
IsOverflowIncomplete
(
)
)
;
aDesiredSize
.
ISize
(
lineWM
)
=
aReflowInput
.
mLineLayout
-
>
EndSpan
(
this
)
;
if
(
boxDecorationBreakClone
|
|
!
GetPrevContinuation
(
)
)
{
aDesiredSize
.
ISize
(
lineWM
)
+
=
borderPadding
.
IStart
(
frameWM
)
;
}
if
(
boxDecorationBreakClone
|
|
aStatus
.
IsComplete
(
)
)
{
aDesiredSize
.
ISize
(
lineWM
)
+
=
borderPadding
.
IEnd
(
frameWM
)
;
}
if
(
nsRubyBaseContainerFrame
*
rbc
=
FindRubyBaseContainerAncestor
(
this
)
)
{
rbc
-
>
UpdateDescendantLeadings
(
mLeadings
)
;
}
nsLayoutUtils
:
:
SetBSizeFromFontMetrics
(
this
aDesiredSize
borderPadding
lineWM
frameWM
)
;
}
void
nsRubyFrame
:
:
ReflowSegment
(
nsPresContext
*
aPresContext
const
ReflowInput
&
aReflowInput
nsRubyBaseContainerFrame
*
aBaseContainer
nsReflowStatus
&
aStatus
)
{
WritingMode
lineWM
=
aReflowInput
.
mLineLayout
-
>
GetWritingMode
(
)
;
LogicalSize
availSize
(
lineWM
aReflowInput
.
AvailableISize
(
)
aReflowInput
.
AvailableBSize
(
)
)
;
WritingMode
rubyWM
=
GetWritingMode
(
)
;
NS_ASSERTION
(
!
rubyWM
.
IsOrthogonalTo
(
lineWM
)
"
Ruby
frame
writing
-
mode
shouldn
'
t
be
orthogonal
to
its
line
"
)
;
AutoRubyTextContainerArray
textContainers
(
aBaseContainer
)
;
const
uint32_t
rtcCount
=
textContainers
.
Length
(
)
;
ReflowOutput
baseMetrics
(
aReflowInput
)
;
bool
pushedFrame
;
aReflowInput
.
mLineLayout
-
>
ReflowFrame
(
aBaseContainer
aStatus
&
baseMetrics
pushedFrame
)
;
if
(
aStatus
.
IsInlineBreakBefore
(
)
)
{
if
(
aBaseContainer
!
=
mFrames
.
FirstChild
(
)
)
{
aStatus
.
Reset
(
)
;
aStatus
.
SetInlineLineBreakAfter
(
)
;
aStatus
.
SetIncomplete
(
)
;
PushChildrenToOverflow
(
aBaseContainer
aBaseContainer
-
>
GetPrevSibling
(
)
)
;
aReflowInput
.
mLineLayout
-
>
SetDirtyNextLine
(
)
;
}
return
;
}
if
(
aStatus
.
IsIncomplete
(
)
)
{
MOZ_ASSERT
(
aStatus
.
IsInlineBreakAfter
(
)
)
;
nsIFrame
*
lastChild
;
if
(
rtcCount
>
0
)
{
lastChild
=
textContainers
.
LastElement
(
)
;
}
else
{
lastChild
=
aBaseContainer
;
}
nsIFrame
*
newBaseContainer
=
CreateNextInFlow
(
aBaseContainer
)
;
if
(
newBaseContainer
)
{
mFrames
.
RemoveFrame
(
newBaseContainer
)
;
mFrames
.
InsertFrame
(
nullptr
lastChild
newBaseContainer
)
;
nsIFrame
*
newLastChild
=
newBaseContainer
;
for
(
uint32_t
i
=
0
;
i
<
rtcCount
;
i
+
+
)
{
nsIFrame
*
newTextContainer
=
CreateNextInFlow
(
textContainers
[
i
]
)
;
MOZ_ASSERT
(
newTextContainer
"
Next
-
in
-
flow
of
rtc
should
not
exist
"
"
if
the
corresponding
rbc
does
not
"
)
;
mFrames
.
RemoveFrame
(
newTextContainer
)
;
mFrames
.
InsertFrame
(
nullptr
newLastChild
newTextContainer
)
;
newLastChild
=
newTextContainer
;
}
}
if
(
lastChild
!
=
mFrames
.
LastChild
(
)
)
{
PushChildrenToOverflow
(
lastChild
-
>
GetNextSibling
(
)
lastChild
)
;
aReflowInput
.
mLineLayout
-
>
SetDirtyNextLine
(
)
;
}
}
else
{
for
(
uint32_t
i
=
0
;
i
<
rtcCount
;
i
+
+
)
{
nsIFrame
*
nextRTC
=
textContainers
[
i
]
-
>
GetNextInFlow
(
)
;
if
(
nextRTC
)
{
nextRTC
-
>
GetParent
(
)
-
>
DeleteNextInFlowChild
(
nextRTC
true
)
;
}
}
}
nscoord
segmentISize
=
baseMetrics
.
ISize
(
lineWM
)
;
const
nsSize
dummyContainerSize
;
LogicalRect
baseRect
=
aBaseContainer
-
>
GetLogicalRect
(
lineWM
dummyContainerSize
)
;
baseRect
.
BStart
(
lineWM
)
=
0
;
LogicalRect
offsetRect
=
baseRect
;
RubyBlockLeadings
descLeadings
=
aBaseContainer
-
>
GetDescendantLeadings
(
)
;
offsetRect
.
BStart
(
lineWM
)
-
=
descLeadings
.
mStart
;
offsetRect
.
BSize
(
lineWM
)
+
=
descLeadings
.
mStart
+
descLeadings
.
mEnd
;
for
(
uint32_t
i
=
0
;
i
<
rtcCount
;
i
+
+
)
{
nsRubyTextContainerFrame
*
textContainer
=
textContainers
[
i
]
;
WritingMode
rtcWM
=
textContainer
-
>
GetWritingMode
(
)
;
nsReflowStatus
textReflowStatus
;
ReflowOutput
textMetrics
(
aReflowInput
)
;
ReflowInput
textReflowInput
(
aPresContext
aReflowInput
textContainer
availSize
.
ConvertTo
(
rtcWM
lineWM
)
)
;
textContainer
-
>
Reflow
(
aPresContext
textMetrics
textReflowInput
textReflowStatus
)
;
NS_ASSERTION
(
textReflowStatus
.
IsEmpty
(
)
"
Ruby
text
container
must
not
break
itself
inside
"
)
;
LogicalSize
size
=
textMetrics
.
Size
(
rubyWM
)
.
ConvertTo
(
lineWM
rubyWM
)
;
textContainer
-
>
SetSize
(
lineWM
size
)
;
nscoord
reservedISize
=
RubyUtils
:
:
GetReservedISize
(
textContainer
)
;
segmentISize
=
std
:
:
max
(
segmentISize
size
.
ISize
(
lineWM
)
+
reservedISize
)
;
uint8_t
rubyPosition
=
textContainer
-
>
StyleText
(
)
-
>
mRubyPosition
;
MOZ_ASSERT
(
rubyPosition
=
=
NS_STYLE_RUBY_POSITION_OVER
|
|
rubyPosition
=
=
NS_STYLE_RUBY_POSITION_UNDER
)
;
Maybe
<
LogicalSide
>
side
;
if
(
rubyPosition
=
=
NS_STYLE_RUBY_POSITION_OVER
)
{
side
.
emplace
(
lineWM
.
LogicalSideForLineRelativeDir
(
eLineRelativeDirOver
)
)
;
}
else
if
(
rubyPosition
=
=
NS_STYLE_RUBY_POSITION_UNDER
)
{
side
.
emplace
(
lineWM
.
LogicalSideForLineRelativeDir
(
eLineRelativeDirUnder
)
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unsupported
ruby
-
position
"
)
;
}
LogicalPoint
position
(
lineWM
)
;
if
(
side
.
isSome
(
)
)
{
if
(
nsLayoutUtils
:
:
IsInterCharacterRubyEnabled
(
)
&
&
rtcWM
.
IsVerticalRL
(
)
&
&
lineWM
.
GetInlineDir
(
)
=
=
WritingMode
:
:
eInlineLTR
)
{
LogicalPoint
offset
(
lineWM
offsetRect
.
ISize
(
lineWM
)
offsetRect
.
BSize
(
lineWM
)
>
size
.
BSize
(
lineWM
)
?
(
offsetRect
.
BSize
(
lineWM
)
-
size
.
BSize
(
lineWM
)
)
/
2
:
0
)
;
position
=
offsetRect
.
Origin
(
lineWM
)
+
offset
;
aReflowInput
.
mLineLayout
-
>
AdvanceICoord
(
size
.
ISize
(
lineWM
)
)
;
}
else
if
(
side
.
value
(
)
=
=
eLogicalSideBStart
)
{
offsetRect
.
BStart
(
lineWM
)
-
=
size
.
BSize
(
lineWM
)
;
offsetRect
.
BSize
(
lineWM
)
+
=
size
.
BSize
(
lineWM
)
;
position
=
offsetRect
.
Origin
(
lineWM
)
;
}
else
if
(
side
.
value
(
)
=
=
eLogicalSideBEnd
)
{
position
=
offsetRect
.
Origin
(
lineWM
)
+
LogicalPoint
(
lineWM
0
offsetRect
.
BSize
(
lineWM
)
)
;
offsetRect
.
BSize
(
lineWM
)
+
=
size
.
BSize
(
lineWM
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
?
?
?
"
)
;
}
}
FinishReflowChild
(
textContainer
aPresContext
textMetrics
&
textReflowInput
lineWM
position
dummyContainerSize
0
)
;
}
MOZ_ASSERT
(
baseRect
.
ISize
(
lineWM
)
=
=
offsetRect
.
ISize
(
lineWM
)
"
Annotations
should
only
be
placed
on
the
block
directions
"
)
;
nscoord
deltaISize
=
segmentISize
-
baseMetrics
.
ISize
(
lineWM
)
;
if
(
deltaISize
<
=
0
)
{
RubyUtils
:
:
ClearReservedISize
(
aBaseContainer
)
;
}
else
{
RubyUtils
:
:
SetReservedISize
(
aBaseContainer
deltaISize
)
;
aReflowInput
.
mLineLayout
-
>
AdvanceICoord
(
deltaISize
)
;
}
nscoord
startLeading
=
baseRect
.
BStart
(
lineWM
)
-
offsetRect
.
BStart
(
lineWM
)
;
nscoord
endLeading
=
offsetRect
.
BEnd
(
lineWM
)
-
baseRect
.
BEnd
(
lineWM
)
;
NS_WARNING_ASSERTION
(
startLeading
>
=
0
&
&
endLeading
>
=
0
"
Leadings
should
be
non
-
negative
(
because
adding
"
"
ruby
annotation
can
only
increase
the
size
)
"
)
;
mLeadings
.
Update
(
startLeading
endLeading
)
;
}
nsRubyBaseContainerFrame
*
nsRubyFrame
:
:
PullOneSegment
(
const
nsLineLayout
*
aLineLayout
ContinuationTraversingState
&
aState
)
{
nsIFrame
*
baseFrame
=
GetNextInFlowChild
(
aState
)
;
if
(
!
baseFrame
)
{
return
nullptr
;
}
MOZ_ASSERT
(
baseFrame
-
>
IsRubyBaseContainerFrame
(
)
)
;
nsBlockFrame
*
oldFloatCB
=
nsLayoutUtils
:
:
GetFloatContainingBlock
(
baseFrame
)
;
PullNextInFlowChild
(
aState
)
;
nsIFrame
*
nextFrame
;
while
(
(
nextFrame
=
GetNextInFlowChild
(
aState
)
)
!
=
nullptr
&
&
nextFrame
-
>
IsRubyTextContainerFrame
(
)
)
{
PullNextInFlowChild
(
aState
)
;
}
if
(
nsBlockFrame
*
newFloatCB
=
do_QueryFrame
(
aLineLayout
-
>
LineContainerFrame
(
)
)
)
{
if
(
oldFloatCB
&
&
oldFloatCB
!
=
newFloatCB
)
{
newFloatCB
-
>
ReparentFloats
(
baseFrame
oldFloatCB
true
ReparentingDirection
:
:
Backwards
)
;
}
}
return
static_cast
<
nsRubyBaseContainerFrame
*
>
(
baseFrame
)
;
}
