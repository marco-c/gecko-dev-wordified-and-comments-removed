#
include
"
nsRubyFrame
.
h
"
#
include
"
RubyUtils
.
h
"
#
include
"
mozilla
/
ComputedStyle
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
mozilla
/
WritingModes
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsLineLayout
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsContainerFrameInlines
.
h
"
#
include
"
nsRubyBaseContainerFrame
.
h
"
#
include
"
nsRubyTextContainerFrame
.
h
"
using
namespace
mozilla
;
NS_QUERYFRAME_HEAD
(
nsRubyFrame
)
NS_QUERYFRAME_ENTRY
(
nsRubyFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsInlineFrame
)
NS_IMPL_FRAMEARENA_HELPERS
(
nsRubyFrame
)
nsContainerFrame
*
NS_NewRubyFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsRubyFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
nsRubyFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
u
"
Ruby
"
_ns
aResult
)
;
}
#
endif
void
nsRubyFrame
:
:
AddInlineMinISize
(
const
IntrinsicSizeInput
&
aInput
InlineMinISizeData
*
aData
)
{
auto
handleChildren
=
[
&
]
(
auto
frame
auto
data
)
{
const
IntrinsicSizeInput
input
(
aInput
.
mContext
)
;
for
(
RubySegmentEnumerator
e
(
static_cast
<
nsRubyFrame
*
>
(
frame
)
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
)
{
e
.
GetBaseContainer
(
)
-
>
AddInlineMinISize
(
input
data
)
;
}
}
;
DoInlineIntrinsicISize
(
aData
handleChildren
)
;
}
void
nsRubyFrame
:
:
AddInlinePrefISize
(
const
IntrinsicSizeInput
&
aInput
InlinePrefISizeData
*
aData
)
{
auto
handleChildren
=
[
&
]
(
auto
frame
auto
data
)
{
const
IntrinsicSizeInput
input
(
aInput
.
mContext
)
;
for
(
RubySegmentEnumerator
e
(
static_cast
<
nsRubyFrame
*
>
(
frame
)
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
)
{
e
.
GetBaseContainer
(
)
-
>
AddInlinePrefISize
(
input
data
)
;
}
}
;
DoInlineIntrinsicISize
(
aData
handleChildren
)
;
aData
-
>
mLineIsEmpty
=
false
;
}
static
nsRubyBaseContainerFrame
*
FindRubyBaseContainerAncestor
(
nsIFrame
*
aFrame
)
{
for
(
nsIFrame
*
ancestor
=
aFrame
-
>
GetParent
(
)
;
ancestor
&
&
ancestor
-
>
IsLineParticipant
(
)
;
ancestor
=
ancestor
-
>
GetParent
(
)
)
{
if
(
ancestor
-
>
IsRubyBaseContainerFrame
(
)
)
{
return
static_cast
<
nsRubyBaseContainerFrame
*
>
(
ancestor
)
;
}
}
return
nullptr
;
}
void
nsRubyFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsRubyFrame
"
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
if
(
!
aReflowInput
.
mLineLayout
)
{
NS_ASSERTION
(
aReflowInput
.
mLineLayout
"
No
line
layout
provided
to
RubyFrame
reflow
method
.
"
)
;
return
;
}
MoveInlineOverflowToChildList
(
aReflowInput
.
mLineLayout
-
>
LineContainerFrame
(
)
)
;
mLeadings
.
Reset
(
)
;
WritingMode
frameWM
=
aReflowInput
.
GetWritingMode
(
)
;
WritingMode
lineWM
=
aReflowInput
.
mLineLayout
-
>
GetWritingMode
(
)
;
LogicalMargin
borderPadding
=
aReflowInput
.
ComputedLogicalBorderPadding
(
frameWM
)
;
nsLayoutUtils
:
:
SetBSizeFromFontMetrics
(
this
aDesiredSize
borderPadding
lineWM
frameWM
)
;
nscoord
startEdge
=
0
;
const
bool
boxDecorationBreakClone
=
StyleBorder
(
)
-
>
mBoxDecorationBreak
=
=
StyleBoxDecorationBreak
:
:
Clone
;
if
(
boxDecorationBreakClone
|
|
!
GetPrevContinuation
(
)
)
{
startEdge
=
borderPadding
.
IStart
(
frameWM
)
;
}
NS_ASSERTION
(
aReflowInput
.
AvailableISize
(
)
!
=
NS_UNCONSTRAINEDSIZE
"
should
no
longer
use
available
widths
"
)
;
nscoord
endEdge
=
aReflowInput
.
AvailableISize
(
)
-
borderPadding
.
IEnd
(
frameWM
)
;
aReflowInput
.
mLineLayout
-
>
BeginSpan
(
this
&
aReflowInput
startEdge
endEdge
&
mBaseline
)
;
for
(
RubySegmentEnumerator
e
(
this
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
)
{
ReflowSegment
(
aPresContext
aReflowInput
aDesiredSize
.
BlockStartAscent
(
)
aDesiredSize
.
BSize
(
lineWM
)
e
.
GetBaseContainer
(
)
aStatus
)
;
if
(
aStatus
.
IsInlineBreak
(
)
)
{
break
;
}
}
ContinuationTraversingState
pullState
(
this
)
;
while
(
aStatus
.
IsEmpty
(
)
)
{
nsRubyBaseContainerFrame
*
baseContainer
=
PullOneSegment
(
aReflowInput
.
mLineLayout
pullState
)
;
if
(
!
baseContainer
)
{
break
;
}
ReflowSegment
(
aPresContext
aReflowInput
aDesiredSize
.
BlockStartAscent
(
)
aDesiredSize
.
BSize
(
lineWM
)
baseContainer
aStatus
)
;
}
MOZ_ASSERT
(
!
aStatus
.
IsOverflowIncomplete
(
)
)
;
aDesiredSize
.
ISize
(
lineWM
)
=
aReflowInput
.
mLineLayout
-
>
EndSpan
(
this
)
;
if
(
boxDecorationBreakClone
|
|
!
GetPrevContinuation
(
)
)
{
aDesiredSize
.
ISize
(
lineWM
)
+
=
borderPadding
.
IStart
(
frameWM
)
;
}
if
(
boxDecorationBreakClone
|
|
aStatus
.
IsComplete
(
)
)
{
aDesiredSize
.
ISize
(
lineWM
)
+
=
borderPadding
.
IEnd
(
frameWM
)
;
}
if
(
nsRubyBaseContainerFrame
*
rbc
=
FindRubyBaseContainerAncestor
(
this
)
)
{
rbc
-
>
UpdateDescendantLeadings
(
mLeadings
)
;
}
ReflowAbsoluteFrames
(
aPresContext
aDesiredSize
aReflowInput
aStatus
)
;
}
void
nsRubyFrame
:
:
ReflowSegment
(
nsPresContext
*
aPresContext
const
ReflowInput
&
aReflowInput
nscoord
aBlockStartAscent
nscoord
aBlockSize
nsRubyBaseContainerFrame
*
aBaseContainer
nsReflowStatus
&
aStatus
)
{
WritingMode
lineWM
=
aReflowInput
.
mLineLayout
-
>
GetWritingMode
(
)
;
LogicalSize
availSize
(
lineWM
aReflowInput
.
AvailableISize
(
)
aReflowInput
.
AvailableBSize
(
)
)
;
NS_ASSERTION
(
!
GetWritingMode
(
)
.
IsOrthogonalTo
(
lineWM
)
"
Ruby
frame
writing
-
mode
shouldn
'
t
be
orthogonal
to
its
line
"
)
;
AutoRubyTextContainerArray
textContainers
(
aBaseContainer
)
;
const
uint32_t
rtcCount
=
textContainers
.
Length
(
)
;
ReflowOutput
baseMetrics
(
aReflowInput
)
;
bool
pushedFrame
;
aReflowInput
.
mLineLayout
-
>
ReflowFrame
(
aBaseContainer
aStatus
&
baseMetrics
pushedFrame
)
;
if
(
aStatus
.
IsInlineBreakBefore
(
)
)
{
if
(
aBaseContainer
!
=
mFrames
.
FirstChild
(
)
)
{
aStatus
.
Reset
(
)
;
aStatus
.
SetInlineLineBreakAfter
(
)
;
aStatus
.
SetIncomplete
(
)
;
PushChildrenToOverflow
(
aBaseContainer
aBaseContainer
-
>
GetPrevSibling
(
)
)
;
aReflowInput
.
mLineLayout
-
>
SetDirtyNextLine
(
)
;
}
return
;
}
if
(
aStatus
.
IsIncomplete
(
)
)
{
MOZ_ASSERT
(
aStatus
.
IsInlineBreakAfter
(
)
)
;
nsIFrame
*
lastChild
;
if
(
rtcCount
>
0
)
{
lastChild
=
textContainers
.
LastElement
(
)
;
}
else
{
lastChild
=
aBaseContainer
;
}
nsIFrame
*
newBaseContainer
=
CreateNextInFlow
(
aBaseContainer
)
;
if
(
newBaseContainer
)
{
mFrames
.
RemoveFrame
(
newBaseContainer
)
;
mFrames
.
InsertFrame
(
nullptr
lastChild
newBaseContainer
)
;
nsIFrame
*
newLastChild
=
newBaseContainer
;
for
(
uint32_t
i
=
0
;
i
<
rtcCount
;
i
+
+
)
{
nsIFrame
*
newTextContainer
=
CreateNextInFlow
(
textContainers
[
i
]
)
;
MOZ_ASSERT
(
newTextContainer
"
Next
-
in
-
flow
of
rtc
should
not
exist
"
"
if
the
corresponding
rbc
does
not
"
)
;
mFrames
.
RemoveFrame
(
newTextContainer
)
;
mFrames
.
InsertFrame
(
nullptr
newLastChild
newTextContainer
)
;
newLastChild
=
newTextContainer
;
}
}
if
(
lastChild
!
=
mFrames
.
LastChild
(
)
)
{
PushChildrenToOverflow
(
lastChild
-
>
GetNextSibling
(
)
lastChild
)
;
aReflowInput
.
mLineLayout
-
>
SetDirtyNextLine
(
)
;
}
}
else
if
(
rtcCount
)
{
DestroyContext
context
(
PresShell
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
rtcCount
;
i
+
+
)
{
if
(
nsIFrame
*
nextRTC
=
textContainers
[
i
]
-
>
GetNextInFlow
(
)
)
{
nextRTC
-
>
GetParent
(
)
-
>
DeleteNextInFlowChild
(
context
nextRTC
true
)
;
}
}
}
nscoord
segmentISize
=
baseMetrics
.
ISize
(
lineWM
)
;
const
nsSize
dummyContainerSize
;
LogicalRect
baseRect
=
aBaseContainer
-
>
GetLogicalRect
(
lineWM
dummyContainerSize
)
;
baseRect
.
BStart
(
lineWM
)
=
aBlockStartAscent
-
baseMetrics
.
BlockStartAscent
(
)
;
LogicalRect
offsetRect
=
baseRect
;
RubyBlockLeadings
descLeadings
=
aBaseContainer
-
>
GetDescendantLeadings
(
)
;
offsetRect
.
BStart
(
lineWM
)
-
=
descLeadings
.
mStart
;
offsetRect
.
BSize
(
lineWM
)
+
=
descLeadings
.
mStart
+
descLeadings
.
mEnd
;
Maybe
<
LineRelativeDir
>
lastLineSide
;
for
(
uint32_t
i
=
0
;
i
<
rtcCount
;
i
+
+
)
{
nsRubyTextContainerFrame
*
textContainer
=
textContainers
[
i
]
;
WritingMode
rtcWM
=
textContainer
-
>
GetWritingMode
(
)
;
nsReflowStatus
textReflowStatus
;
ReflowOutput
textMetrics
(
aReflowInput
)
;
ReflowInput
textReflowInput
(
aPresContext
aReflowInput
textContainer
availSize
.
ConvertTo
(
rtcWM
lineWM
)
)
;
textContainer
-
>
Reflow
(
aPresContext
textMetrics
textReflowInput
textReflowStatus
)
;
NS_ASSERTION
(
textReflowStatus
.
IsEmpty
(
)
"
Ruby
text
container
must
not
break
itself
inside
"
)
;
const
LogicalSize
size
=
textMetrics
.
Size
(
lineWM
)
;
textContainer
-
>
SetSize
(
lineWM
size
)
;
nscoord
reservedISize
=
RubyUtils
:
:
GetReservedISize
(
textContainer
)
;
segmentISize
=
std
:
:
max
(
segmentISize
size
.
ISize
(
lineWM
)
+
reservedISize
)
;
Maybe
<
LineRelativeDir
>
lineSide
;
switch
(
textContainer
-
>
StyleText
(
)
-
>
mRubyPosition
)
{
case
StyleRubyPosition
:
:
Over
:
lineSide
.
emplace
(
LineRelativeDir
:
:
Over
)
;
break
;
case
StyleRubyPosition
:
:
Under
:
lineSide
.
emplace
(
LineRelativeDir
:
:
Under
)
;
break
;
case
StyleRubyPosition
:
:
AlternateOver
:
if
(
lastLineSide
.
isSome
(
)
&
&
lastLineSide
.
value
(
)
=
=
LineRelativeDir
:
:
Over
)
{
lineSide
.
emplace
(
LineRelativeDir
:
:
Under
)
;
}
else
{
lineSide
.
emplace
(
LineRelativeDir
:
:
Over
)
;
}
break
;
case
StyleRubyPosition
:
:
AlternateUnder
:
if
(
lastLineSide
.
isSome
(
)
&
&
lastLineSide
.
value
(
)
=
=
LineRelativeDir
:
:
Under
)
{
lineSide
.
emplace
(
LineRelativeDir
:
:
Over
)
;
}
else
{
lineSide
.
emplace
(
LineRelativeDir
:
:
Under
)
;
}
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unsupported
ruby
-
position
"
)
;
}
lastLineSide
=
lineSide
;
LogicalPoint
position
(
lineWM
)
;
if
(
lineSide
.
isSome
(
)
)
{
LogicalSide
logicalSide
=
lineWM
.
LogicalSideForLineRelativeDir
(
lineSide
.
value
(
)
)
;
if
(
StaticPrefs
:
:
layout_css_ruby_intercharacter_enabled
(
)
&
&
rtcWM
.
IsVerticalRL
(
)
&
&
lineWM
.
GetInlineDir
(
)
=
=
WritingMode
:
:
InlineDir
:
:
LTR
)
{
LogicalPoint
offset
(
lineWM
offsetRect
.
ISize
(
lineWM
)
offsetRect
.
BSize
(
lineWM
)
>
size
.
BSize
(
lineWM
)
?
(
offsetRect
.
BSize
(
lineWM
)
-
size
.
BSize
(
lineWM
)
)
/
2
:
0
)
;
position
=
offsetRect
.
Origin
(
lineWM
)
+
offset
;
aReflowInput
.
mLineLayout
-
>
AdvanceICoord
(
size
.
ISize
(
lineWM
)
)
;
}
else
if
(
logicalSide
=
=
LogicalSide
:
:
BStart
)
{
offsetRect
.
BStart
(
lineWM
)
-
=
size
.
BSize
(
lineWM
)
;
offsetRect
.
BSize
(
lineWM
)
+
=
size
.
BSize
(
lineWM
)
;
position
=
offsetRect
.
Origin
(
lineWM
)
;
}
else
if
(
logicalSide
=
=
LogicalSide
:
:
BEnd
)
{
position
=
offsetRect
.
Origin
(
lineWM
)
+
LogicalPoint
(
lineWM
0
offsetRect
.
BSize
(
lineWM
)
)
;
offsetRect
.
BSize
(
lineWM
)
+
=
size
.
BSize
(
lineWM
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
?
?
?
"
)
;
}
}
FinishReflowChild
(
textContainer
aPresContext
textMetrics
&
textReflowInput
lineWM
position
dummyContainerSize
ReflowChildFlags
:
:
Default
)
;
}
MOZ_ASSERT
(
baseRect
.
ISize
(
lineWM
)
=
=
offsetRect
.
ISize
(
lineWM
)
"
Annotations
should
only
be
placed
on
the
block
directions
"
)
;
nscoord
deltaISize
=
segmentISize
-
baseMetrics
.
ISize
(
lineWM
)
;
if
(
deltaISize
<
=
0
)
{
RubyUtils
:
:
ClearReservedISize
(
aBaseContainer
)
;
}
else
{
RubyUtils
:
:
SetReservedISize
(
aBaseContainer
deltaISize
)
;
aReflowInput
.
mLineLayout
-
>
AdvanceICoord
(
deltaISize
)
;
}
nscoord
startLeading
=
-
offsetRect
.
BStart
(
lineWM
)
;
nscoord
endLeading
=
offsetRect
.
BEnd
(
lineWM
)
-
aBlockSize
;
NS_WARNING_ASSERTION
(
startLeading
>
=
0
&
&
endLeading
>
=
0
"
Leadings
should
be
non
-
negative
(
because
adding
"
"
ruby
annotation
can
only
increase
the
size
)
"
)
;
mLeadings
.
Update
(
startLeading
endLeading
)
;
}
nsRubyBaseContainerFrame
*
nsRubyFrame
:
:
PullOneSegment
(
const
nsLineLayout
*
aLineLayout
ContinuationTraversingState
&
aState
)
{
nsIFrame
*
baseFrame
=
GetNextInFlowChild
(
aState
)
;
if
(
!
baseFrame
)
{
return
nullptr
;
}
MOZ_ASSERT
(
baseFrame
-
>
IsRubyBaseContainerFrame
(
)
)
;
nsBlockFrame
*
oldFloatCB
=
nsLayoutUtils
:
:
GetFloatContainingBlock
(
baseFrame
)
;
PullNextInFlowChild
(
aState
)
;
nsIFrame
*
nextFrame
;
while
(
(
nextFrame
=
GetNextInFlowChild
(
aState
)
)
!
=
nullptr
&
&
nextFrame
-
>
IsRubyTextContainerFrame
(
)
)
{
PullNextInFlowChild
(
aState
)
;
}
if
(
nsBlockFrame
*
newFloatCB
=
do_QueryFrame
(
aLineLayout
-
>
LineContainerFrame
(
)
)
)
{
if
(
oldFloatCB
&
&
oldFloatCB
!
=
newFloatCB
)
{
newFloatCB
-
>
ReparentFloats
(
baseFrame
oldFloatCB
true
)
;
}
}
return
static_cast
<
nsRubyBaseContainerFrame
*
>
(
baseFrame
)
;
}
