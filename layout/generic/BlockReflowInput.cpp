#
include
"
BlockReflowInput
.
h
"
#
include
<
algorithm
>
#
include
"
LayoutLogging
.
h
"
#
include
"
nsBlockFrame
.
h
"
#
include
"
nsLineLayout
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
TextOverflow
.
h
"
#
ifdef
DEBUG
#
include
"
nsBlockDebugFlags
.
h
"
#
endif
using
namespace
mozilla
;
using
namespace
mozilla
:
:
layout
;
static
bool
sFloatFragmentsInsideColumnEnabled
;
static
bool
sFloatFragmentsInsideColumnPrefCached
;
BlockReflowInput
:
:
BlockReflowInput
(
const
ReflowInput
&
aReflowInput
nsPresContext
*
aPresContext
nsBlockFrame
*
aFrame
bool
aBStartMarginRoot
bool
aBEndMarginRoot
bool
aBlockNeedsFloatManager
nscoord
aConsumedBSize
)
:
mBlock
(
aFrame
)
mPresContext
(
aPresContext
)
mReflowInput
(
aReflowInput
)
mContentArea
(
aReflowInput
.
GetWritingMode
(
)
)
mPushedFloats
(
nullptr
)
mOverflowTracker
(
nullptr
)
mBorderPadding
(
mReflowInput
.
ComputedLogicalBorderPadding
(
)
)
mPrevBEndMargin
(
)
mLineNumber
(
0
)
mFloatBreakType
(
StyleClear
:
:
None
)
mConsumedBSize
(
aConsumedBSize
)
{
if
(
!
sFloatFragmentsInsideColumnPrefCached
)
{
sFloatFragmentsInsideColumnPrefCached
=
true
;
Preferences
:
:
AddBoolVarCache
(
&
sFloatFragmentsInsideColumnEnabled
"
layout
.
float
-
fragments
-
inside
-
column
.
enabled
"
)
;
}
mFlags
.
mFloatFragmentsInsideColumnEnabled
=
sFloatFragmentsInsideColumnEnabled
;
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
mFlags
.
mIsFirstInflow
=
!
aFrame
-
>
GetPrevInFlow
(
)
;
mFlags
.
mIsOverflowContainer
=
IS_TRUE_OVERFLOW_CONTAINER
(
aFrame
)
;
nsIFrame
:
:
LogicalSides
logicalSkipSides
=
aFrame
-
>
GetLogicalSkipSides
(
&
aReflowInput
)
;
mBorderPadding
.
ApplySkipSides
(
logicalSkipSides
)
;
mContainerSize
.
width
=
aReflowInput
.
ComputedWidth
(
)
;
if
(
mContainerSize
.
width
=
=
NS_UNCONSTRAINEDSIZE
)
{
mContainerSize
.
width
=
0
;
}
mContainerSize
.
width
+
=
mBorderPadding
.
LeftRight
(
wm
)
;
mContainerSize
.
height
=
aReflowInput
.
ComputedHeight
(
)
+
mBorderPadding
.
TopBottom
(
wm
)
;
if
(
(
aBStartMarginRoot
&
&
!
logicalSkipSides
.
BStart
(
)
)
|
|
0
!
=
mBorderPadding
.
BStart
(
wm
)
)
{
mFlags
.
mIsBStartMarginRoot
=
true
;
mFlags
.
mShouldApplyBStartMargin
=
true
;
}
if
(
(
aBEndMarginRoot
&
&
!
logicalSkipSides
.
BEnd
(
)
)
|
|
0
!
=
mBorderPadding
.
BEnd
(
wm
)
)
{
mFlags
.
mIsBEndMarginRoot
=
true
;
}
if
(
aBlockNeedsFloatManager
)
{
mFlags
.
mBlockNeedsFloatManager
=
true
;
}
mFlags
.
mCanHaveTextOverflow
=
css
:
:
TextOverflow
:
:
CanHaveTextOverflow
(
mBlock
)
;
MOZ_ASSERT
(
FloatManager
(
)
"
Float
manager
should
be
valid
when
creating
BlockReflowInput
!
"
)
;
FloatManager
(
)
-
>
GetTranslation
(
mFloatManagerI
mFloatManagerB
)
;
FloatManager
(
)
-
>
PushState
(
&
mFloatManagerStateBefore
)
;
mNextInFlow
=
static_cast
<
nsBlockFrame
*
>
(
mBlock
-
>
GetNextInFlow
(
)
)
;
LAYOUT_WARN_IF_FALSE
(
NS_UNCONSTRAINEDSIZE
!
=
aReflowInput
.
ComputedISize
(
)
"
have
unconstrained
width
;
this
should
only
result
"
"
from
very
large
sizes
not
attempts
at
intrinsic
"
"
width
calculation
"
)
;
mContentArea
.
ISize
(
wm
)
=
aReflowInput
.
ComputedISize
(
)
;
if
(
NS_UNCONSTRAINEDSIZE
!
=
aReflowInput
.
AvailableBSize
(
)
)
{
mBEndEdge
=
aReflowInput
.
AvailableBSize
(
)
-
mBorderPadding
.
BEnd
(
wm
)
;
mContentArea
.
BSize
(
wm
)
=
std
:
:
max
(
0
mBEndEdge
-
mBorderPadding
.
BStart
(
wm
)
)
;
}
else
{
mFlags
.
mHasUnconstrainedBSize
=
true
;
mContentArea
.
BSize
(
wm
)
=
mBEndEdge
=
NS_UNCONSTRAINEDSIZE
;
}
mContentArea
.
IStart
(
wm
)
=
mBorderPadding
.
IStart
(
wm
)
;
mBCoord
=
mContentArea
.
BStart
(
wm
)
=
mBorderPadding
.
BStart
(
wm
)
;
mPrevChild
=
nullptr
;
mCurrentLine
=
aFrame
-
>
LinesEnd
(
)
;
mMinLineHeight
=
aReflowInput
.
CalcLineHeight
(
)
;
}
nscoord
BlockReflowInput
:
:
ConsumedBSize
(
)
{
if
(
mConsumedBSize
=
=
NS_INTRINSICSIZE
)
{
mConsumedBSize
=
mBlock
-
>
ConsumedBSize
(
mReflowInput
.
GetWritingMode
(
)
)
;
}
return
mConsumedBSize
;
}
void
BlockReflowInput
:
:
ComputeReplacedBlockOffsetsForFloats
(
nsIFrame
*
aFrame
const
LogicalRect
&
aFloatAvailableSpace
nscoord
&
aIStartResult
nscoord
&
aIEndResult
)
const
{
WritingMode
wm
=
mReflowInput
.
GetWritingMode
(
)
;
NS_ASSERTION
(
aFloatAvailableSpace
.
IStart
(
wm
)
>
=
mContentArea
.
IStart
(
wm
)
"
bad
avail
space
rect
inline
-
coord
"
)
;
NS_ASSERTION
(
aFloatAvailableSpace
.
ISize
(
wm
)
=
=
0
|
|
aFloatAvailableSpace
.
IEnd
(
wm
)
<
=
mContentArea
.
IEnd
(
wm
)
"
bad
avail
space
rect
inline
-
size
"
)
;
nscoord
iStartOffset
iEndOffset
;
if
(
aFloatAvailableSpace
.
ISize
(
wm
)
=
=
mContentArea
.
ISize
(
wm
)
)
{
iStartOffset
=
0
;
iEndOffset
=
0
;
}
else
{
LogicalMargin
frameMargin
(
wm
)
;
SizeComputationInput
os
(
aFrame
mReflowInput
.
mRenderingContext
wm
mContentArea
.
ISize
(
wm
)
)
;
frameMargin
=
os
.
ComputedLogicalMargin
(
)
.
ConvertTo
(
wm
aFrame
-
>
GetWritingMode
(
)
)
;
nscoord
iStartFloatIOffset
=
aFloatAvailableSpace
.
IStart
(
wm
)
-
mContentArea
.
IStart
(
wm
)
;
iStartOffset
=
std
:
:
max
(
iStartFloatIOffset
frameMargin
.
IStart
(
wm
)
)
-
frameMargin
.
IStart
(
wm
)
;
iStartOffset
=
std
:
:
max
(
iStartOffset
0
)
;
nscoord
iEndFloatIOffset
=
mContentArea
.
IEnd
(
wm
)
-
aFloatAvailableSpace
.
IEnd
(
wm
)
;
iEndOffset
=
std
:
:
max
(
iEndFloatIOffset
frameMargin
.
IEnd
(
wm
)
)
-
frameMargin
.
IEnd
(
wm
)
;
iEndOffset
=
std
:
:
max
(
iEndOffset
0
)
;
}
aIStartResult
=
iStartOffset
;
aIEndResult
=
iEndOffset
;
}
static
nscoord
GetBEndMarginClone
(
nsIFrame
*
aFrame
gfxContext
*
aRenderingContext
const
LogicalRect
&
aContentArea
WritingMode
aWritingMode
)
{
if
(
aFrame
-
>
StyleBorder
(
)
-
>
mBoxDecorationBreak
=
=
StyleBoxDecorationBreak
:
:
Clone
)
{
SizeComputationInput
os
(
aFrame
aRenderingContext
aWritingMode
aContentArea
.
ISize
(
aWritingMode
)
)
;
return
os
.
ComputedLogicalMargin
(
)
.
ConvertTo
(
aWritingMode
aFrame
-
>
GetWritingMode
(
)
)
.
BEnd
(
aWritingMode
)
;
}
return
0
;
}
void
BlockReflowInput
:
:
ComputeBlockAvailSpace
(
nsIFrame
*
aFrame
const
nsFlowAreaRect
&
aFloatAvailableSpace
bool
aBlockAvoidsFloats
LogicalRect
&
aResult
)
{
#
ifdef
REALLY_NOISY_REFLOW
printf
(
"
CBAS
frame
=
%
p
has
floats
%
d
\
n
"
aFrame
aFloatAvailableSpace
.
HasFloats
(
)
)
;
#
endif
WritingMode
wm
=
mReflowInput
.
GetWritingMode
(
)
;
aResult
.
BStart
(
wm
)
=
mBCoord
;
aResult
.
BSize
(
wm
)
=
mFlags
.
mHasUnconstrainedBSize
?
NS_UNCONSTRAINEDSIZE
:
mReflowInput
.
AvailableBSize
(
)
-
mBCoord
-
GetBEndMarginClone
(
aFrame
mReflowInput
.
mRenderingContext
mContentArea
wm
)
;
NS_ASSERTION
(
nsBlockFrame
:
:
BlockCanIntersectFloats
(
aFrame
)
=
=
!
aBlockAvoidsFloats
"
unexpected
replaced
width
"
)
;
if
(
!
aBlockAvoidsFloats
)
{
if
(
aFloatAvailableSpace
.
HasFloats
(
)
)
{
const
nsStyleBorder
*
borderStyle
=
aFrame
-
>
StyleBorder
(
)
;
switch
(
borderStyle
-
>
mFloatEdge
)
{
default
:
case
StyleFloatEdge
:
:
ContentBox
:
aResult
.
IStart
(
wm
)
=
mContentArea
.
IStart
(
wm
)
;
aResult
.
ISize
(
wm
)
=
mContentArea
.
ISize
(
wm
)
;
break
;
case
StyleFloatEdge
:
:
MarginBox
:
{
aResult
.
IStart
(
wm
)
=
aFloatAvailableSpace
.
mRect
.
IStart
(
wm
)
;
aResult
.
ISize
(
wm
)
=
aFloatAvailableSpace
.
mRect
.
ISize
(
wm
)
;
}
break
;
}
}
else
{
aResult
.
IStart
(
wm
)
=
mContentArea
.
IStart
(
wm
)
;
aResult
.
ISize
(
wm
)
=
mContentArea
.
ISize
(
wm
)
;
}
}
else
{
nscoord
iStartOffset
iEndOffset
;
ComputeReplacedBlockOffsetsForFloats
(
aFrame
aFloatAvailableSpace
.
mRect
iStartOffset
iEndOffset
)
;
aResult
.
IStart
(
wm
)
=
mContentArea
.
IStart
(
wm
)
+
iStartOffset
;
aResult
.
ISize
(
wm
)
=
mContentArea
.
ISize
(
wm
)
-
iStartOffset
-
iEndOffset
;
}
#
ifdef
REALLY_NOISY_REFLOW
printf
(
"
CBAS
:
result
%
d
%
d
%
d
%
d
\
n
"
aResult
.
IStart
(
wm
)
aResult
.
BStart
(
wm
)
aResult
.
ISize
(
wm
)
aResult
.
BSize
(
wm
)
)
;
#
endif
}
bool
BlockReflowInput
:
:
ReplacedBlockFitsInAvailSpace
(
nsIFrame
*
aReplacedBlock
const
nsFlowAreaRect
&
aFloatAvailableSpace
)
const
{
if
(
!
aFloatAvailableSpace
.
HasFloats
(
)
)
{
return
true
;
}
WritingMode
wm
=
mReflowInput
.
GetWritingMode
(
)
;
nsBlockFrame
:
:
ReplacedElementISizeToClear
replacedISize
=
nsBlockFrame
:
:
ISizeToClearPastFloats
(
*
this
aFloatAvailableSpace
.
mRect
aReplacedBlock
)
;
return
std
:
:
max
(
aFloatAvailableSpace
.
mRect
.
IStart
(
wm
)
-
mContentArea
.
IStart
(
wm
)
replacedISize
.
marginIStart
)
+
replacedISize
.
borderBoxISize
+
(
mContentArea
.
IEnd
(
wm
)
-
aFloatAvailableSpace
.
mRect
.
IEnd
(
wm
)
)
<
=
mContentArea
.
ISize
(
wm
)
;
}
nsFlowAreaRect
BlockReflowInput
:
:
GetFloatAvailableSpaceWithState
(
nscoord
aBCoord
ShapeType
aShapeType
nsFloatManager
:
:
SavedState
*
aState
)
const
{
WritingMode
wm
=
mReflowInput
.
GetWritingMode
(
)
;
#
ifdef
DEBUG
nscoord
wI
wB
;
FloatManager
(
)
-
>
GetTranslation
(
wI
wB
)
;
NS_ASSERTION
(
(
wI
=
=
mFloatManagerI
)
&
&
(
wB
=
=
mFloatManagerB
)
"
bad
coord
system
"
)
;
#
endif
nscoord
blockSize
=
(
mContentArea
.
BSize
(
wm
)
=
=
nscoord_MAX
)
?
nscoord_MAX
:
std
:
:
max
(
mContentArea
.
BEnd
(
wm
)
-
aBCoord
0
)
;
nsFlowAreaRect
result
=
FloatManager
(
)
-
>
GetFlowArea
(
wm
aBCoord
blockSize
BandInfoType
:
:
BandFromPoint
aShapeType
mContentArea
aState
ContainerSize
(
)
)
;
if
(
result
.
mRect
.
ISize
(
wm
)
<
0
)
{
result
.
mRect
.
ISize
(
wm
)
=
0
;
}
#
ifdef
DEBUG
if
(
nsBlockFrame
:
:
gNoisyReflow
)
{
nsFrame
:
:
IndentBy
(
stdout
nsBlockFrame
:
:
gNoiseIndent
)
;
printf
(
"
%
s
:
band
=
%
d
%
d
%
d
%
d
hasfloats
=
%
d
\
n
"
__func__
result
.
mRect
.
IStart
(
wm
)
result
.
mRect
.
BStart
(
wm
)
result
.
mRect
.
ISize
(
wm
)
result
.
mRect
.
BSize
(
wm
)
result
.
HasFloats
(
)
)
;
}
#
endif
return
result
;
}
nsFlowAreaRect
BlockReflowInput
:
:
GetFloatAvailableSpaceForBSize
(
nscoord
aBCoord
nscoord
aBSize
nsFloatManager
:
:
SavedState
*
aState
)
const
{
WritingMode
wm
=
mReflowInput
.
GetWritingMode
(
)
;
#
ifdef
DEBUG
nscoord
wI
wB
;
FloatManager
(
)
-
>
GetTranslation
(
wI
wB
)
;
NS_ASSERTION
(
(
wI
=
=
mFloatManagerI
)
&
&
(
wB
=
=
mFloatManagerB
)
"
bad
coord
system
"
)
;
#
endif
nsFlowAreaRect
result
=
FloatManager
(
)
-
>
GetFlowArea
(
wm
aBCoord
aBSize
BandInfoType
:
:
WidthWithinHeight
ShapeType
:
:
ShapeOutside
mContentArea
aState
ContainerSize
(
)
)
;
if
(
result
.
mRect
.
ISize
(
wm
)
<
0
)
{
result
.
mRect
.
ISize
(
wm
)
=
0
;
}
#
ifdef
DEBUG
if
(
nsBlockFrame
:
:
gNoisyReflow
)
{
nsFrame
:
:
IndentBy
(
stdout
nsBlockFrame
:
:
gNoiseIndent
)
;
printf
(
"
%
s
:
space
=
%
d
%
d
%
d
%
d
hasfloats
=
%
d
\
n
"
__func__
result
.
mRect
.
IStart
(
wm
)
result
.
mRect
.
BStart
(
wm
)
result
.
mRect
.
ISize
(
wm
)
result
.
mRect
.
BSize
(
wm
)
result
.
HasFloats
(
)
)
;
}
#
endif
return
result
;
}
void
BlockReflowInput
:
:
ReconstructMarginBefore
(
nsLineList
:
:
iterator
aLine
)
{
mPrevBEndMargin
.
Zero
(
)
;
nsBlockFrame
*
block
=
mBlock
;
nsLineList
:
:
iterator
firstLine
=
block
-
>
LinesBegin
(
)
;
for
(
;
;
)
{
-
-
aLine
;
if
(
aLine
-
>
IsBlock
(
)
)
{
mPrevBEndMargin
=
aLine
-
>
GetCarriedOutBEndMargin
(
)
;
break
;
}
if
(
!
aLine
-
>
IsEmpty
(
)
)
{
break
;
}
if
(
aLine
=
=
firstLine
)
{
if
(
!
mFlags
.
mIsBStartMarginRoot
)
{
mPrevBEndMargin
.
Zero
(
)
;
}
break
;
}
}
}
void
BlockReflowInput
:
:
SetupPushedFloatList
(
)
{
MOZ_ASSERT
(
!
mFlags
.
mIsFloatListInBlockPropertyTable
=
=
!
mPushedFloats
"
flag
mismatch
"
)
;
if
(
!
mFlags
.
mIsFloatListInBlockPropertyTable
)
{
mPushedFloats
=
mBlock
-
>
EnsurePushedFloats
(
)
;
mFlags
.
mIsFloatListInBlockPropertyTable
=
true
;
}
}
void
BlockReflowInput
:
:
AppendPushedFloatChain
(
nsIFrame
*
aFloatCont
)
{
SetupPushedFloatList
(
)
;
while
(
true
)
{
aFloatCont
-
>
AddStateBits
(
NS_FRAME_IS_PUSHED_FLOAT
)
;
mPushedFloats
-
>
AppendFrame
(
mBlock
aFloatCont
)
;
aFloatCont
=
aFloatCont
-
>
GetNextInFlow
(
)
;
if
(
!
aFloatCont
|
|
aFloatCont
-
>
GetParent
(
)
!
=
mBlock
)
{
break
;
}
DebugOnly
<
nsresult
>
rv
=
mBlock
-
>
StealFrame
(
aFloatCont
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
StealFrame
should
succeed
"
)
;
}
}
void
BlockReflowInput
:
:
RecoverFloats
(
nsLineList
:
:
iterator
aLine
nscoord
aDeltaBCoord
)
{
WritingMode
wm
=
mReflowInput
.
GetWritingMode
(
)
;
if
(
aLine
-
>
HasFloats
(
)
)
{
nsFloatCache
*
fc
=
aLine
-
>
GetFirstFloat
(
)
;
while
(
fc
)
{
nsIFrame
*
floatFrame
=
fc
-
>
mFloat
;
if
(
aDeltaBCoord
!
=
0
)
{
floatFrame
-
>
MovePositionBy
(
nsPoint
(
0
aDeltaBCoord
)
)
;
nsContainerFrame
:
:
PositionFrameView
(
floatFrame
)
;
nsContainerFrame
:
:
PositionChildViews
(
floatFrame
)
;
}
#
ifdef
DEBUG
if
(
nsBlockFrame
:
:
gNoisyReflow
|
|
nsBlockFrame
:
:
gNoisyFloatManager
)
{
nscoord
tI
tB
;
FloatManager
(
)
-
>
GetTranslation
(
tI
tB
)
;
nsFrame
:
:
IndentBy
(
stdout
nsBlockFrame
:
:
gNoiseIndent
)
;
printf
(
"
RecoverFloats
:
tIB
=
%
d
%
d
(
%
d
%
d
)
"
tI
tB
mFloatManagerI
mFloatManagerB
)
;
floatFrame
-
>
ListTag
(
stdout
)
;
LogicalRect
region
=
nsFloatManager
:
:
GetRegionFor
(
wm
floatFrame
ContainerSize
(
)
)
;
printf
(
"
aDeltaBCoord
=
%
d
region
=
{
%
d
%
d
%
d
%
d
}
\
n
"
aDeltaBCoord
region
.
IStart
(
wm
)
region
.
BStart
(
wm
)
region
.
ISize
(
wm
)
region
.
BSize
(
wm
)
)
;
}
#
endif
FloatManager
(
)
-
>
AddFloat
(
floatFrame
nsFloatManager
:
:
GetRegionFor
(
wm
floatFrame
ContainerSize
(
)
)
wm
ContainerSize
(
)
)
;
fc
=
fc
-
>
Next
(
)
;
}
}
else
if
(
aLine
-
>
IsBlock
(
)
)
{
nsBlockFrame
:
:
RecoverFloatsFor
(
aLine
-
>
mFirstChild
*
FloatManager
(
)
wm
ContainerSize
(
)
)
;
}
}
void
BlockReflowInput
:
:
RecoverStateFrom
(
nsLineList
:
:
iterator
aLine
nscoord
aDeltaBCoord
)
{
mCurrentLine
=
aLine
;
if
(
aLine
-
>
HasFloats
(
)
|
|
aLine
-
>
IsBlock
(
)
)
{
RecoverFloats
(
aLine
aDeltaBCoord
)
;
#
ifdef
DEBUG
if
(
nsBlockFrame
:
:
gNoisyReflow
|
|
nsBlockFrame
:
:
gNoisyFloatManager
)
{
FloatManager
(
)
-
>
List
(
stdout
)
;
}
#
endif
}
}
bool
BlockReflowInput
:
:
AddFloat
(
nsLineLayout
*
aLineLayout
nsIFrame
*
aFloat
nscoord
aAvailableISize
)
{
MOZ_ASSERT
(
aLineLayout
"
must
have
line
layout
"
)
;
MOZ_ASSERT
(
mBlock
-
>
LinesEnd
(
)
!
=
mCurrentLine
"
null
ptr
"
)
;
MOZ_ASSERT
(
aFloat
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
"
aFloat
must
be
an
out
-
of
-
flow
frame
"
)
;
MOZ_ASSERT
(
aFloat
-
>
GetParent
(
)
"
float
must
have
parent
"
)
;
MOZ_ASSERT
(
aFloat
-
>
GetParent
(
)
-
>
IsFrameOfType
(
nsIFrame
:
:
eBlockFrame
)
"
float
'
s
parent
must
be
block
"
)
;
if
(
aFloat
-
>
HasAnyStateBits
(
NS_FRAME_IS_PUSHED_FLOAT
)
|
|
aFloat
-
>
GetParent
(
)
!
=
mBlock
)
{
MOZ_ASSERT
(
aFloat
-
>
HasAnyStateBits
(
NS_FRAME_IS_PUSHED_FLOAT
|
NS_FRAME_FIRST_REFLOW
)
"
float
should
be
in
this
block
unless
it
was
marked
as
"
"
pushed
float
or
just
inserted
"
)
;
MOZ_ASSERT
(
aFloat
-
>
GetParent
(
)
-
>
FirstContinuation
(
)
=
=
mBlock
-
>
FirstContinuation
(
)
)
;
auto
*
floatParent
=
static_cast
<
nsBlockFrame
*
>
(
aFloat
-
>
GetParent
(
)
)
;
floatParent
-
>
StealFrame
(
aFloat
)
;
aFloat
-
>
RemoveStateBits
(
NS_FRAME_IS_PUSHED_FLOAT
)
;
mBlock
-
>
mFloats
.
AppendFrame
(
mBlock
aFloat
)
;
}
nscoord
oI
oB
;
FloatManager
(
)
-
>
GetTranslation
(
oI
oB
)
;
nscoord
dI
=
oI
-
mFloatManagerI
;
nscoord
dB
=
oB
-
mFloatManagerB
;
FloatManager
(
)
-
>
Translate
(
-
dI
-
dB
)
;
bool
placed
;
LogicalRect
floatAvailableSpace
=
GetFloatAvailableSpaceForPlacingFloat
(
mBCoord
)
.
mRect
;
if
(
mBelowCurrentLineFloats
.
IsEmpty
(
)
&
&
(
aLineLayout
-
>
LineIsEmpty
(
)
|
|
mBlock
-
>
ComputeFloatISize
(
*
this
floatAvailableSpace
aFloat
)
<
=
aAvailableISize
)
)
{
placed
=
FlowAndPlaceFloat
(
aFloat
)
;
if
(
placed
)
{
WritingMode
wm
=
mReflowInput
.
GetWritingMode
(
)
;
nsFlowAreaRect
floatAvailSpace
=
mLineBSize
.
isNothing
(
)
?
GetFloatAvailableSpace
(
mBCoord
)
:
GetFloatAvailableSpaceForBSize
(
mBCoord
mLineBSize
.
value
(
)
nullptr
)
;
LogicalRect
availSpace
(
wm
floatAvailSpace
.
mRect
.
IStart
(
wm
)
mBCoord
floatAvailSpace
.
mRect
.
ISize
(
wm
)
floatAvailSpace
.
mRect
.
BSize
(
wm
)
)
;
aLineLayout
-
>
UpdateBand
(
wm
availSpace
aFloat
)
;
mCurrentLineFloats
.
Append
(
mFloatCacheFreeList
.
Alloc
(
aFloat
)
)
;
}
else
{
(
*
aLineLayout
-
>
GetLine
(
)
)
-
>
SetHadFloatPushed
(
)
;
}
}
else
{
placed
=
true
;
mBelowCurrentLineFloats
.
Append
(
mFloatCacheFreeList
.
Alloc
(
aFloat
)
)
;
}
FloatManager
(
)
-
>
Translate
(
dI
dB
)
;
return
placed
;
}
bool
BlockReflowInput
:
:
CanPlaceFloat
(
nscoord
aFloatISize
const
nsFlowAreaRect
&
aFloatAvailableSpace
)
{
return
!
aFloatAvailableSpace
.
HasFloats
(
)
|
|
aFloatAvailableSpace
.
mRect
.
ISize
(
mReflowInput
.
GetWritingMode
(
)
)
>
=
aFloatISize
;
}
static
nscoord
FloatMarginISize
(
const
ReflowInput
&
aCBReflowInput
nscoord
aFloatAvailableISize
nsIFrame
*
aFloat
const
SizeComputationInput
&
aFloatOffsetState
)
{
AutoMaybeDisableFontInflation
an
(
aFloat
)
;
WritingMode
wm
=
aFloatOffsetState
.
GetWritingMode
(
)
;
LogicalSize
floatSize
=
aFloat
-
>
ComputeSize
(
aCBReflowInput
.
mRenderingContext
wm
aCBReflowInput
.
ComputedSize
(
wm
)
aFloatAvailableISize
aFloatOffsetState
.
ComputedLogicalMargin
(
)
.
Size
(
wm
)
aFloatOffsetState
.
ComputedLogicalBorderPadding
(
)
.
Size
(
wm
)
-
aFloatOffsetState
.
ComputedLogicalPadding
(
)
.
Size
(
wm
)
aFloatOffsetState
.
ComputedLogicalPadding
(
)
.
Size
(
wm
)
nsIFrame
:
:
ComputeSizeFlags
:
:
eShrinkWrap
)
;
WritingMode
cbwm
=
aCBReflowInput
.
GetWritingMode
(
)
;
nscoord
floatISize
=
floatSize
.
ConvertTo
(
cbwm
wm
)
.
ISize
(
cbwm
)
;
if
(
floatISize
=
=
NS_UNCONSTRAINEDSIZE
)
{
return
NS_UNCONSTRAINEDSIZE
;
}
return
floatISize
+
aFloatOffsetState
.
ComputedLogicalMargin
(
)
.
Size
(
wm
)
.
ConvertTo
(
cbwm
wm
)
.
ISize
(
cbwm
)
+
aFloatOffsetState
.
ComputedLogicalBorderPadding
(
)
.
Size
(
wm
)
.
ConvertTo
(
cbwm
wm
)
.
ISize
(
cbwm
)
;
}
struct
ShapeInvalidationData
{
StyleShapeSource
mShapeOutside
;
float
mShapeImageThreshold
=
0
.
0
;
mozilla
:
:
LengthPercentage
mShapeMargin
;
ShapeInvalidationData
(
)
=
default
;
explicit
ShapeInvalidationData
(
const
nsStyleDisplay
&
aDisplay
)
{
Update
(
aDisplay
)
;
}
static
bool
IsNeeded
(
const
nsStyleDisplay
&
aDisplay
)
{
return
aDisplay
.
mShapeOutside
.
GetType
(
)
!
=
StyleShapeSourceType
:
:
None
;
}
void
Update
(
const
nsStyleDisplay
&
aDisplay
)
{
MOZ_ASSERT
(
IsNeeded
(
aDisplay
)
)
;
mShapeOutside
=
aDisplay
.
mShapeOutside
;
mShapeImageThreshold
=
aDisplay
.
mShapeImageThreshold
;
mShapeMargin
=
aDisplay
.
mShapeMargin
;
}
bool
Matches
(
const
nsStyleDisplay
&
aDisplay
)
const
{
return
mShapeOutside
=
=
aDisplay
.
mShapeOutside
&
&
mShapeImageThreshold
=
=
aDisplay
.
mShapeImageThreshold
&
&
mShapeMargin
=
=
aDisplay
.
mShapeMargin
;
}
}
;
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
ShapeInvalidationDataProperty
ShapeInvalidationData
)
bool
BlockReflowInput
:
:
FlowAndPlaceFloat
(
nsIFrame
*
aFloat
)
{
MOZ_ASSERT
(
aFloat
-
>
GetParent
(
)
=
=
mBlock
)
;
WritingMode
wm
=
mReflowInput
.
GetWritingMode
(
)
;
AutoRestore
<
nscoord
>
restoreBCoord
(
mBCoord
)
;
const
nsStyleDisplay
*
floatDisplay
=
aFloat
-
>
StyleDisplay
(
)
;
LogicalRect
oldRegion
=
nsFloatManager
:
:
GetRegionFor
(
wm
aFloat
ContainerSize
(
)
)
;
ShapeInvalidationData
*
invalidationData
=
aFloat
-
>
GetProperty
(
ShapeInvalidationDataProperty
(
)
)
;
mBCoord
=
std
:
:
max
(
FloatManager
(
)
-
>
GetLowestFloatTop
(
)
mBCoord
)
;
if
(
StyleClear
:
:
None
!
=
floatDisplay
-
>
mBreakType
)
{
mBCoord
=
ClearFloats
(
mBCoord
floatDisplay
-
>
mBreakType
)
;
}
nsFlowAreaRect
floatAvailableSpace
=
GetFloatAvailableSpaceForPlacingFloat
(
mBCoord
)
;
LogicalRect
adjustedAvailableSpace
=
mBlock
-
>
AdjustFloatAvailableSpace
(
*
this
floatAvailableSpace
.
mRect
aFloat
)
;
NS_ASSERTION
(
aFloat
-
>
GetParent
(
)
=
=
mBlock
"
Float
frame
has
wrong
parent
"
)
;
SizeComputationInput
offsets
(
aFloat
mReflowInput
.
mRenderingContext
wm
mReflowInput
.
ComputedISize
(
)
)
;
nscoord
floatMarginISize
=
FloatMarginISize
(
mReflowInput
adjustedAvailableSpace
.
ISize
(
wm
)
aFloat
offsets
)
;
LogicalMargin
floatMargin
(
wm
)
;
LogicalMargin
floatOffsets
(
wm
)
;
nsReflowStatus
reflowStatus
;
bool
earlyFloatReflow
=
aFloat
-
>
IsLetterFrame
(
)
|
|
floatMarginISize
=
=
NS_UNCONSTRAINEDSIZE
;
if
(
earlyFloatReflow
)
{
mBlock
-
>
ReflowFloat
(
*
this
adjustedAvailableSpace
aFloat
floatMargin
floatOffsets
false
reflowStatus
)
;
floatMarginISize
=
aFloat
-
>
ISize
(
wm
)
+
floatMargin
.
IStartEnd
(
wm
)
;
NS_ASSERTION
(
reflowStatus
.
IsComplete
(
)
"
letter
frames
and
orthogonal
floats
with
auto
block
-
size
"
"
shouldn
'
t
break
and
if
they
do
now
then
they
'
re
breaking
"
"
at
the
wrong
point
"
)
;
}
StyleFloat
floatStyle
=
floatDisplay
-
>
mFloat
;
MOZ_ASSERT
(
StyleFloat
:
:
Left
=
=
floatStyle
|
|
StyleFloat
:
:
Right
=
=
floatStyle
"
Invalid
float
type
!
"
)
;
bool
keepFloatOnSameLine
=
false
;
bool
mustPlaceFloat
=
mReflowInput
.
mFlags
.
mIsTopOfPage
&
&
IsAdjacentWithTop
(
)
;
for
(
;
;
)
{
if
(
mReflowInput
.
AvailableHeight
(
)
!
=
NS_UNCONSTRAINEDSIZE
&
&
floatAvailableSpace
.
mRect
.
BSize
(
wm
)
<
=
0
&
&
!
mustPlaceFloat
)
{
PushFloatPastBreak
(
aFloat
)
;
return
false
;
}
if
(
CanPlaceFloat
(
floatMarginISize
floatAvailableSpace
)
)
{
break
;
}
if
(
StyleDisplay
:
:
Table
!
=
floatDisplay
-
>
mDisplay
|
|
eCompatibility_NavQuirks
!
=
mPresContext
-
>
CompatibilityMode
(
)
)
{
mBCoord
+
=
floatAvailableSpace
.
mRect
.
BSize
(
wm
)
;
if
(
adjustedAvailableSpace
.
BSize
(
wm
)
!
=
NS_UNCONSTRAINEDSIZE
)
{
adjustedAvailableSpace
.
BSize
(
wm
)
-
=
floatAvailableSpace
.
mRect
.
BSize
(
wm
)
;
}
floatAvailableSpace
=
GetFloatAvailableSpaceForPlacingFloat
(
mBCoord
)
;
}
else
{
nsFloatCache
*
fc
=
mCurrentLineFloats
.
Head
(
)
;
nsIFrame
*
prevFrame
=
nullptr
;
while
(
fc
)
{
if
(
fc
-
>
mFloat
=
=
aFloat
)
{
break
;
}
prevFrame
=
fc
-
>
mFloat
;
fc
=
fc
-
>
Next
(
)
;
}
if
(
prevFrame
)
{
if
(
prevFrame
-
>
IsTableWrapperFrame
(
)
)
{
nsIContent
*
content
=
prevFrame
-
>
GetContent
(
)
;
if
(
content
&
&
content
-
>
IsElement
(
)
&
&
content
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
align
NS_LITERAL_STRING
(
"
left
"
)
eIgnoreCase
)
)
{
keepFloatOnSameLine
=
true
;
break
;
}
}
}
mBCoord
+
=
floatAvailableSpace
.
mRect
.
BSize
(
wm
)
;
floatAvailableSpace
=
GetFloatAvailableSpaceForPlacingFloat
(
mBCoord
)
;
adjustedAvailableSpace
=
mBlock
-
>
AdjustFloatAvailableSpace
(
*
this
floatAvailableSpace
.
mRect
aFloat
)
;
floatMarginISize
=
FloatMarginISize
(
mReflowInput
adjustedAvailableSpace
.
ISize
(
wm
)
aFloat
offsets
)
;
}
mustPlaceFloat
=
false
;
}
LogicalPoint
floatPos
(
wm
)
;
bool
leftFloat
=
floatStyle
=
=
StyleFloat
:
:
Left
;
if
(
leftFloat
=
=
wm
.
IsBidiLTR
(
)
)
{
floatPos
.
I
(
wm
)
=
floatAvailableSpace
.
mRect
.
IStart
(
wm
)
;
}
else
{
if
(
!
keepFloatOnSameLine
)
{
floatPos
.
I
(
wm
)
=
floatAvailableSpace
.
mRect
.
IEnd
(
wm
)
-
floatMarginISize
;
}
else
{
floatPos
.
I
(
wm
)
=
floatAvailableSpace
.
mRect
.
IStart
(
wm
)
;
}
}
floatPos
.
B
(
wm
)
=
std
:
:
max
(
mBCoord
ContentBStart
(
)
)
;
if
(
!
earlyFloatReflow
)
{
bool
pushedDown
=
mBCoord
!
=
restoreBCoord
.
SavedValue
(
)
;
mBlock
-
>
ReflowFloat
(
*
this
adjustedAvailableSpace
aFloat
floatMargin
floatOffsets
pushedDown
reflowStatus
)
;
}
if
(
aFloat
-
>
GetPrevInFlow
(
)
)
floatMargin
.
BStart
(
wm
)
=
0
;
if
(
reflowStatus
.
IsIncomplete
(
)
)
floatMargin
.
BEnd
(
wm
)
=
0
;
if
(
(
ContentBSize
(
)
!
=
NS_UNCONSTRAINEDSIZE
&
&
!
mFlags
.
mFloatFragmentsInsideColumnEnabled
&
&
adjustedAvailableSpace
.
BSize
(
wm
)
=
=
NS_UNCONSTRAINEDSIZE
&
&
!
mustPlaceFloat
&
&
aFloat
-
>
BSize
(
wm
)
+
floatMargin
.
BStartEnd
(
wm
)
>
ContentBEnd
(
)
-
floatPos
.
B
(
wm
)
)
|
|
reflowStatus
.
IsTruncated
(
)
|
|
reflowStatus
.
IsInlineBreakBefore
(
)
)
{
PushFloatPastBreak
(
aFloat
)
;
return
false
;
}
if
(
ContentBSize
(
)
!
=
NS_UNCONSTRAINEDSIZE
&
&
!
mustPlaceFloat
&
&
(
!
mReflowInput
.
mFlags
.
mIsTopOfPage
|
|
floatPos
.
B
(
wm
)
>
0
)
&
&
StyleBreakWithin
:
:
Avoid
=
=
aFloat
-
>
StyleDisplay
(
)
-
>
mBreakInside
&
&
(
!
reflowStatus
.
IsFullyComplete
(
)
|
|
aFloat
-
>
BSize
(
wm
)
+
floatMargin
.
BStartEnd
(
wm
)
>
ContentBEnd
(
)
-
floatPos
.
B
(
wm
)
)
&
&
!
aFloat
-
>
GetPrevInFlow
(
)
)
{
PushFloatPastBreak
(
aFloat
)
;
return
false
;
}
LogicalPoint
origin
(
wm
floatMargin
.
IStart
(
wm
)
+
floatPos
.
I
(
wm
)
floatMargin
.
BStart
(
wm
)
+
floatPos
.
B
(
wm
)
)
;
ReflowInput
:
:
ApplyRelativePositioning
(
aFloat
wm
floatOffsets
&
origin
ContainerSize
(
)
)
;
bool
moved
=
aFloat
-
>
GetLogicalPosition
(
wm
ContainerSize
(
)
)
!
=
origin
;
if
(
moved
)
{
aFloat
-
>
SetPosition
(
wm
origin
ContainerSize
(
)
)
;
nsContainerFrame
:
:
PositionFrameView
(
aFloat
)
;
nsContainerFrame
:
:
PositionChildViews
(
aFloat
)
;
}
mFloatOverflowAreas
.
UnionWith
(
aFloat
-
>
GetOverflowAreas
(
)
+
aFloat
-
>
GetPosition
(
)
)
;
LogicalRect
region
=
nsFloatManager
:
:
CalculateRegionFor
(
wm
aFloat
floatMargin
ContainerSize
(
)
)
;
if
(
reflowStatus
.
IsIncomplete
(
)
&
&
(
NS_UNCONSTRAINEDSIZE
!
=
ContentBSize
(
)
)
)
{
region
.
BSize
(
wm
)
=
std
:
:
max
(
region
.
BSize
(
wm
)
ContentBSize
(
)
-
floatPos
.
B
(
wm
)
)
;
}
FloatManager
(
)
-
>
AddFloat
(
aFloat
region
wm
ContainerSize
(
)
)
;
nsFloatManager
:
:
StoreRegionFor
(
wm
aFloat
region
ContainerSize
(
)
)
;
const
bool
invalidationDataNeeded
=
ShapeInvalidationData
:
:
IsNeeded
(
*
floatDisplay
)
;
if
(
!
region
.
IsEqualEdges
(
oldRegion
)
|
|
!
!
invalidationData
!
=
invalidationDataNeeded
|
|
(
invalidationData
&
&
!
invalidationData
-
>
Matches
(
*
floatDisplay
)
)
)
{
nscoord
blockStart
=
std
:
:
min
(
region
.
BStart
(
wm
)
oldRegion
.
BStart
(
wm
)
)
;
nscoord
blockEnd
=
std
:
:
max
(
region
.
BEnd
(
wm
)
oldRegion
.
BEnd
(
wm
)
)
;
FloatManager
(
)
-
>
IncludeInDamage
(
blockStart
blockEnd
)
;
}
if
(
invalidationDataNeeded
)
{
if
(
invalidationData
)
{
invalidationData
-
>
Update
(
*
floatDisplay
)
;
}
else
{
aFloat
-
>
SetProperty
(
ShapeInvalidationDataProperty
(
)
new
ShapeInvalidationData
(
*
floatDisplay
)
)
;
}
}
else
if
(
invalidationData
)
{
invalidationData
=
nullptr
;
aFloat
-
>
DeleteProperty
(
ShapeInvalidationDataProperty
(
)
)
;
}
if
(
!
reflowStatus
.
IsFullyComplete
(
)
)
{
mBlock
-
>
SplitFloat
(
*
this
aFloat
reflowStatus
)
;
}
else
{
MOZ_ASSERT
(
!
aFloat
-
>
GetNextInFlow
(
)
)
;
}
#
ifdef
DEBUG
if
(
nsBlockFrame
:
:
gNoisyFloatManager
)
{
nscoord
tI
tB
;
FloatManager
(
)
-
>
GetTranslation
(
tI
tB
)
;
mBlock
-
>
ListTag
(
stdout
)
;
printf
(
"
:
FlowAndPlaceFloat
:
AddFloat
:
tIB
=
%
d
%
d
(
%
d
%
d
)
{
%
d
%
d
%
d
%
d
}
\
n
"
tI
tB
mFloatManagerI
mFloatManagerB
region
.
IStart
(
wm
)
region
.
BStart
(
wm
)
region
.
ISize
(
wm
)
region
.
BSize
(
wm
)
)
;
}
if
(
nsBlockFrame
:
:
gNoisyReflow
)
{
nsRect
r
=
aFloat
-
>
GetRect
(
)
;
nsFrame
:
:
IndentBy
(
stdout
nsBlockFrame
:
:
gNoiseIndent
)
;
printf
(
"
placed
float
:
"
)
;
aFloat
-
>
ListTag
(
stdout
)
;
printf
(
"
%
d
%
d
%
d
%
d
\
n
"
r
.
x
r
.
y
r
.
width
r
.
height
)
;
}
#
endif
return
true
;
}
void
BlockReflowInput
:
:
PushFloatPastBreak
(
nsIFrame
*
aFloat
)
{
StyleFloat
floatStyle
=
aFloat
-
>
StyleDisplay
(
)
-
>
mFloat
;
if
(
floatStyle
=
=
StyleFloat
:
:
Left
)
{
FloatManager
(
)
-
>
SetPushedLeftFloatPastBreak
(
)
;
}
else
{
MOZ_ASSERT
(
floatStyle
=
=
StyleFloat
:
:
Right
"
Unexpected
float
value
!
"
)
;
FloatManager
(
)
-
>
SetPushedRightFloatPastBreak
(
)
;
}
DebugOnly
<
nsresult
>
rv
=
mBlock
-
>
StealFrame
(
aFloat
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
StealFrame
should
succeed
"
)
;
AppendPushedFloatChain
(
aFloat
)
;
mReflowStatus
.
SetOverflowIncomplete
(
)
;
}
void
BlockReflowInput
:
:
PlaceBelowCurrentLineFloats
(
nsLineBox
*
aLine
)
{
MOZ_ASSERT
(
mBelowCurrentLineFloats
.
NotEmpty
(
)
)
;
nsFloatCache
*
fc
=
mBelowCurrentLineFloats
.
Head
(
)
;
while
(
fc
)
{
#
ifdef
DEBUG
if
(
nsBlockFrame
:
:
gNoisyReflow
)
{
nsFrame
:
:
IndentBy
(
stdout
nsBlockFrame
:
:
gNoiseIndent
)
;
printf
(
"
placing
bcl
float
:
"
)
;
fc
-
>
mFloat
-
>
ListTag
(
stdout
)
;
printf
(
"
\
n
"
)
;
}
#
endif
bool
placed
=
FlowAndPlaceFloat
(
fc
-
>
mFloat
)
;
nsFloatCache
*
next
=
fc
-
>
Next
(
)
;
if
(
!
placed
)
{
mBelowCurrentLineFloats
.
Remove
(
fc
)
;
delete
fc
;
aLine
-
>
SetHadFloatPushed
(
)
;
}
fc
=
next
;
}
aLine
-
>
AppendFloats
(
mBelowCurrentLineFloats
)
;
}
nscoord
BlockReflowInput
:
:
ClearFloats
(
nscoord
aBCoord
StyleClear
aBreakType
nsIFrame
*
aReplacedBlock
uint32_t
aFlags
)
{
#
ifdef
DEBUG
if
(
nsBlockFrame
:
:
gNoisyReflow
)
{
nsFrame
:
:
IndentBy
(
stdout
nsBlockFrame
:
:
gNoiseIndent
)
;
printf
(
"
clear
floats
:
in
:
aBCoord
=
%
d
\
n
"
aBCoord
)
;
}
#
endif
#
ifdef
NOISY_FLOAT_CLEARING
printf
(
"
BlockReflowInput
:
:
ClearFloats
:
aBCoord
=
%
d
breakType
=
%
s
\
n
"
aBCoord
nsLineBox
:
:
BreakTypeToString
(
aBreakType
)
)
;
FloatManager
(
)
-
>
List
(
stdout
)
;
#
endif
if
(
!
FloatManager
(
)
-
>
HasAnyFloats
(
)
)
{
return
aBCoord
;
}
nscoord
newBCoord
=
aBCoord
;
if
(
aBreakType
!
=
StyleClear
:
:
None
)
{
newBCoord
=
FloatManager
(
)
-
>
ClearFloats
(
newBCoord
aBreakType
aFlags
)
;
}
if
(
aReplacedBlock
)
{
for
(
;
;
)
{
nsFlowAreaRect
floatAvailableSpace
=
GetFloatAvailableSpace
(
newBCoord
)
;
if
(
ReplacedBlockFitsInAvailSpace
(
aReplacedBlock
floatAvailableSpace
)
)
{
break
;
}
if
(
!
AdvanceToNextBand
(
floatAvailableSpace
.
mRect
&
newBCoord
)
)
{
break
;
}
}
}
#
ifdef
DEBUG
if
(
nsBlockFrame
:
:
gNoisyReflow
)
{
nsFrame
:
:
IndentBy
(
stdout
nsBlockFrame
:
:
gNoiseIndent
)
;
printf
(
"
clear
floats
:
out
:
y
=
%
d
\
n
"
newBCoord
)
;
}
#
endif
return
newBCoord
;
}
