#
include
"
nsFontInflationData
.
h
"
#
include
"
FrameProperties
.
h
"
#
include
"
nsTextControlFrame
.
h
"
#
include
"
nsListControlFrame
.
h
"
#
include
"
nsComboboxControlFrame
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
ReflowInput
.
h
"
#
include
"
nsTextFrameUtils
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
layout
;
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
FontInflationDataProperty
nsFontInflationData
)
nsFontInflationData
*
nsFontInflationData
:
:
FindFontInflationDataFor
(
const
nsIFrame
*
aFrame
)
{
const
nsIFrame
*
bfc
=
FlowRootFor
(
aFrame
)
;
NS_ASSERTION
(
bfc
-
>
GetStateBits
(
)
&
NS_FRAME_FONT_INFLATION_FLOW_ROOT
"
should
have
found
a
flow
root
"
)
;
MOZ_ASSERT
(
aFrame
-
>
GetWritingMode
(
)
.
IsVertical
(
)
=
=
bfc
-
>
GetWritingMode
(
)
.
IsVertical
(
)
"
current
writing
mode
should
match
that
of
our
flow
root
"
)
;
return
bfc
-
>
GetProperty
(
FontInflationDataProperty
(
)
)
;
}
bool
nsFontInflationData
:
:
UpdateFontInflationDataISizeFor
(
const
ReflowInput
&
aReflowInput
)
{
nsIFrame
*
bfc
=
aReflowInput
.
mFrame
;
NS_ASSERTION
(
bfc
-
>
GetStateBits
(
)
&
NS_FRAME_FONT_INFLATION_FLOW_ROOT
"
should
have
been
given
a
flow
root
"
)
;
nsFontInflationData
*
data
=
bfc
-
>
GetProperty
(
FontInflationDataProperty
(
)
)
;
bool
oldInflationEnabled
;
nscoord
oldUsableISize
;
if
(
data
)
{
oldUsableISize
=
data
-
>
mUsableISize
;
oldInflationEnabled
=
data
-
>
mInflationEnabled
;
}
else
{
data
=
new
nsFontInflationData
(
bfc
)
;
bfc
-
>
SetProperty
(
FontInflationDataProperty
(
)
data
)
;
oldUsableISize
=
-
1
;
oldInflationEnabled
=
true
;
}
data
-
>
UpdateISize
(
aReflowInput
)
;
if
(
oldInflationEnabled
!
=
data
-
>
mInflationEnabled
)
return
true
;
return
oldInflationEnabled
&
&
oldUsableISize
!
=
data
-
>
mUsableISize
;
}
void
nsFontInflationData
:
:
MarkFontInflationDataTextDirty
(
nsIFrame
*
aBFCFrame
)
{
NS_ASSERTION
(
aBFCFrame
-
>
GetStateBits
(
)
&
NS_FRAME_FONT_INFLATION_FLOW_ROOT
"
should
have
been
given
a
flow
root
"
)
;
nsFontInflationData
*
data
=
aBFCFrame
-
>
GetProperty
(
FontInflationDataProperty
(
)
)
;
if
(
data
)
{
data
-
>
MarkTextDirty
(
)
;
}
}
nsFontInflationData
:
:
nsFontInflationData
(
nsIFrame
*
aBFCFrame
)
:
mBFCFrame
(
aBFCFrame
)
mUsableISize
(
0
)
mTextAmount
(
0
)
mTextThreshold
(
0
)
mInflationEnabled
(
false
)
mTextDirty
(
true
)
{
}
static
nsIFrame
*
NearestCommonAncestorFirstInFlow
(
nsIFrame
*
aFrame1
nsIFrame
*
aFrame2
nsIFrame
*
aKnownCommonAncestor
)
{
aFrame1
=
aFrame1
-
>
FirstInFlow
(
)
;
aFrame2
=
aFrame2
-
>
FirstInFlow
(
)
;
aKnownCommonAncestor
=
aKnownCommonAncestor
-
>
FirstInFlow
(
)
;
AutoTArray
<
nsIFrame
*
32
>
ancestors1
ancestors2
;
for
(
nsIFrame
*
f
=
aFrame1
;
f
!
=
aKnownCommonAncestor
;
(
f
=
f
-
>
GetParent
(
)
)
&
&
(
f
=
f
-
>
FirstInFlow
(
)
)
)
{
ancestors1
.
AppendElement
(
f
)
;
}
for
(
nsIFrame
*
f
=
aFrame2
;
f
!
=
aKnownCommonAncestor
;
(
f
=
f
-
>
GetParent
(
)
)
&
&
(
f
=
f
-
>
FirstInFlow
(
)
)
)
{
ancestors2
.
AppendElement
(
f
)
;
}
nsIFrame
*
result
=
aKnownCommonAncestor
;
uint32_t
i1
=
ancestors1
.
Length
(
)
i2
=
ancestors2
.
Length
(
)
;
while
(
i1
-
-
!
=
0
&
&
i2
-
-
!
=
0
)
{
if
(
ancestors1
[
i1
]
!
=
ancestors2
[
i2
]
)
{
break
;
}
result
=
ancestors1
[
i1
]
;
}
return
result
;
}
static
nscoord
ComputeDescendantISize
(
const
ReflowInput
&
aAncestorReflowInput
nsIFrame
*
aDescendantFrame
)
{
nsIFrame
*
ancestorFrame
=
aAncestorReflowInput
.
mFrame
-
>
FirstInFlow
(
)
;
if
(
aDescendantFrame
=
=
ancestorFrame
)
{
return
aAncestorReflowInput
.
ComputedISize
(
)
;
}
AutoTArray
<
nsIFrame
*
16
>
frames
;
for
(
nsIFrame
*
f
=
aDescendantFrame
;
f
!
=
ancestorFrame
;
f
=
f
-
>
GetParent
(
)
-
>
FirstInFlow
(
)
)
{
frames
.
AppendElement
(
f
)
;
}
uint32_t
len
=
frames
.
Length
(
)
;
ReflowInput
*
reflowInputs
=
static_cast
<
ReflowInput
*
>
(
moz_xmalloc
(
sizeof
(
ReflowInput
)
*
len
)
)
;
nsPresContext
*
presContext
=
aDescendantFrame
-
>
PresContext
(
)
;
for
(
uint32_t
i
=
0
;
i
<
len
;
+
+
i
)
{
const
ReflowInput
&
parentReflowInput
=
(
i
=
=
0
)
?
aAncestorReflowInput
:
reflowInputs
[
i
-
1
]
;
nsIFrame
*
frame
=
frames
[
len
-
i
-
1
]
;
WritingMode
wm
=
frame
-
>
GetWritingMode
(
)
;
LogicalSize
availSize
=
parentReflowInput
.
ComputedSize
(
wm
)
;
availSize
.
BSize
(
wm
)
=
NS_UNCONSTRAINEDSIZE
;
MOZ_ASSERT
(
frame
-
>
GetParent
(
)
-
>
FirstInFlow
(
)
=
=
parentReflowInput
.
mFrame
-
>
FirstInFlow
(
)
"
bad
logic
in
this
function
"
)
;
new
(
reflowInputs
+
i
)
ReflowInput
(
presContext
parentReflowInput
frame
availSize
)
;
}
MOZ_ASSERT
(
reflowInputs
[
len
-
1
]
.
mFrame
=
=
aDescendantFrame
"
bad
logic
in
this
function
"
)
;
nscoord
result
=
reflowInputs
[
len
-
1
]
.
ComputedISize
(
)
;
for
(
uint32_t
i
=
len
;
i
-
-
!
=
0
;
)
{
reflowInputs
[
i
]
.
~
ReflowInput
(
)
;
}
free
(
reflowInputs
)
;
return
result
;
}
void
nsFontInflationData
:
:
UpdateISize
(
const
ReflowInput
&
aReflowInput
)
{
nsIFrame
*
bfc
=
aReflowInput
.
mFrame
;
NS_ASSERTION
(
bfc
-
>
GetStateBits
(
)
&
NS_FRAME_FONT_INFLATION_FLOW_ROOT
"
must
be
block
formatting
context
"
)
;
nsIFrame
*
firstInflatableDescendant
=
FindEdgeInflatableFrameIn
(
bfc
eFromStart
)
;
if
(
!
firstInflatableDescendant
)
{
mTextAmount
=
0
;
mTextThreshold
=
0
;
mTextDirty
=
false
;
mInflationEnabled
=
false
;
return
;
}
nsIFrame
*
lastInflatableDescendant
=
FindEdgeInflatableFrameIn
(
bfc
eFromEnd
)
;
MOZ_ASSERT
(
!
firstInflatableDescendant
=
=
!
lastInflatableDescendant
"
null
-
ness
should
match
;
NearestCommonAncestorFirstInFlow
"
"
will
crash
when
passed
null
"
)
;
nsIFrame
*
nca
=
NearestCommonAncestorFirstInFlow
(
firstInflatableDescendant
lastInflatableDescendant
bfc
)
;
while
(
!
nca
-
>
IsContainerForFontSizeInflation
(
)
)
{
nca
=
nca
-
>
GetParent
(
)
-
>
FirstInFlow
(
)
;
}
nscoord
newNCAISize
=
ComputeDescendantISize
(
aReflowInput
nca
)
;
PresShell
*
presShell
=
bfc
-
>
PresShell
(
)
;
uint32_t
lineThreshold
=
presShell
-
>
FontSizeInflationLineThreshold
(
)
;
nscoord
newTextThreshold
=
(
newNCAISize
*
lineThreshold
)
/
100
;
if
(
mTextThreshold
<
=
mTextAmount
&
&
mTextAmount
<
newTextThreshold
)
{
mTextDirty
=
true
;
}
nsPresContext
*
presContext
=
bfc
-
>
PresContext
(
)
;
MOZ_ASSERT
(
bfc
-
>
GetWritingMode
(
)
.
IsVertical
(
)
=
=
nca
-
>
GetWritingMode
(
)
.
IsVertical
(
)
"
writing
mode
of
NCA
should
match
that
of
its
flow
root
"
)
;
nscoord
iFrameISize
=
bfc
-
>
GetWritingMode
(
)
.
IsVertical
(
)
?
presContext
-
>
GetVisibleArea
(
)
.
height
:
presContext
-
>
GetVisibleArea
(
)
.
width
;
mUsableISize
=
std
:
:
min
(
iFrameISize
newNCAISize
)
;
mTextThreshold
=
newTextThreshold
;
mInflationEnabled
=
mTextAmount
>
=
mTextThreshold
;
}
nsIFrame
*
nsFontInflationData
:
:
FindEdgeInflatableFrameIn
(
nsIFrame
*
aFrame
SearchDirection
aDirection
)
{
nsIFormControlFrame
*
fcf
=
do_QueryFrame
(
aFrame
)
;
if
(
fcf
)
{
return
aFrame
;
}
AutoTArray
<
FrameChildList
4
>
lists
;
aFrame
-
>
GetChildLists
(
&
lists
)
;
for
(
uint32_t
i
=
0
len
=
lists
.
Length
(
)
;
i
<
len
;
+
+
i
)
{
const
nsFrameList
&
list
=
lists
[
(
aDirection
=
=
eFromStart
)
?
i
:
len
-
i
-
1
]
.
mList
;
for
(
nsIFrame
*
kid
=
(
aDirection
=
=
eFromStart
)
?
list
.
FirstChild
(
)
:
list
.
LastChild
(
)
;
kid
;
kid
=
(
aDirection
=
=
eFromStart
)
?
kid
-
>
GetNextSibling
(
)
:
kid
-
>
GetPrevSibling
(
)
)
{
if
(
kid
-
>
GetStateBits
(
)
&
NS_FRAME_FONT_INFLATION_FLOW_ROOT
)
{
continue
;
}
if
(
kid
-
>
IsTextFrame
(
)
)
{
nsIContent
*
content
=
kid
-
>
GetContent
(
)
;
if
(
content
&
&
kid
=
=
content
-
>
GetPrimaryFrame
(
)
)
{
uint32_t
len
=
nsTextFrameUtils
:
:
ComputeApproximateLengthWithWhitespaceCompression
(
content
-
>
AsText
(
)
kid
-
>
StyleText
(
)
)
;
if
(
len
!
=
0
)
{
return
kid
;
}
}
}
else
{
nsIFrame
*
kidResult
=
FindEdgeInflatableFrameIn
(
kid
aDirection
)
;
if
(
kidResult
)
{
return
kidResult
;
}
}
}
}
return
nullptr
;
}
void
nsFontInflationData
:
:
ScanText
(
)
{
mTextDirty
=
false
;
mTextAmount
=
0
;
ScanTextIn
(
mBFCFrame
)
;
mInflationEnabled
=
mTextAmount
>
=
mTextThreshold
;
}
static
uint32_t
DoCharCountOfLargestOption
(
nsIFrame
*
aContainer
)
{
uint32_t
result
=
0
;
for
(
nsIFrame
*
option
:
aContainer
-
>
PrincipalChildList
(
)
)
{
uint32_t
optionResult
;
if
(
option
-
>
GetContent
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
optgroup
)
)
{
optionResult
=
DoCharCountOfLargestOption
(
option
)
;
}
else
{
optionResult
=
0
;
for
(
nsIFrame
*
optionChild
:
option
-
>
PrincipalChildList
(
)
)
{
if
(
optionChild
-
>
IsTextFrame
(
)
)
{
optionResult
+
=
nsTextFrameUtils
:
:
ComputeApproximateLengthWithWhitespaceCompression
(
optionChild
-
>
GetContent
(
)
-
>
AsText
(
)
optionChild
-
>
StyleText
(
)
)
;
}
}
}
if
(
optionResult
>
result
)
{
result
=
optionResult
;
}
}
return
result
;
}
static
uint32_t
CharCountOfLargestOption
(
nsIFrame
*
aListControlFrame
)
{
return
DoCharCountOfLargestOption
(
static_cast
<
nsListControlFrame
*
>
(
aListControlFrame
)
-
>
GetOptionsContainer
(
)
)
;
}
void
nsFontInflationData
:
:
ScanTextIn
(
nsIFrame
*
aFrame
)
{
nsIFrame
:
:
ChildListIterator
lists
(
aFrame
)
;
for
(
;
!
lists
.
IsDone
(
)
;
lists
.
Next
(
)
)
{
nsFrameList
:
:
Enumerator
kids
(
lists
.
CurrentList
(
)
)
;
for
(
;
!
kids
.
AtEnd
(
)
;
kids
.
Next
(
)
)
{
nsIFrame
*
kid
=
kids
.
get
(
)
;
if
(
kid
-
>
GetStateBits
(
)
&
NS_FRAME_FONT_INFLATION_FLOW_ROOT
)
{
continue
;
}
LayoutFrameType
fType
=
kid
-
>
Type
(
)
;
if
(
fType
=
=
LayoutFrameType
:
:
Text
)
{
nsIContent
*
content
=
kid
-
>
GetContent
(
)
;
if
(
content
&
&
kid
=
=
content
-
>
GetPrimaryFrame
(
)
)
{
uint32_t
len
=
nsTextFrameUtils
:
:
ComputeApproximateLengthWithWhitespaceCompression
(
content
-
>
AsText
(
)
kid
-
>
StyleText
(
)
)
;
if
(
len
!
=
0
)
{
nscoord
fontSize
=
kid
-
>
StyleFont
(
)
-
>
mFont
.
size
;
if
(
fontSize
>
0
)
{
mTextAmount
+
=
fontSize
*
len
;
}
}
}
}
else
if
(
fType
=
=
LayoutFrameType
:
:
TextInput
)
{
nscoord
fontSize
=
kid
-
>
StyleFont
(
)
-
>
mFont
.
size
;
int32_t
charCount
=
static_cast
<
nsTextControlFrame
*
>
(
kid
)
-
>
GetCols
(
)
;
mTextAmount
+
=
charCount
*
fontSize
;
}
else
if
(
fType
=
=
LayoutFrameType
:
:
ComboboxControl
)
{
nscoord
fontSize
=
kid
-
>
StyleFont
(
)
-
>
mFont
.
size
;
int32_t
charCount
=
CharCountOfLargestOption
(
static_cast
<
nsComboboxControlFrame
*
>
(
kid
)
-
>
GetDropDown
(
)
)
;
mTextAmount
+
=
charCount
*
fontSize
;
}
else
if
(
fType
=
=
LayoutFrameType
:
:
ListControl
)
{
nscoord
fontSize
=
kid
-
>
StyleFont
(
)
-
>
mFont
.
size
;
int32_t
charCount
=
CharCountOfLargestOption
(
kid
)
;
mTextAmount
+
=
charCount
*
fontSize
;
}
else
{
ScanTextIn
(
kid
)
;
}
if
(
mTextAmount
>
=
mTextThreshold
)
{
return
;
}
}
}
}
