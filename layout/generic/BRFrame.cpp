#
include
"
mozilla
/
CaretAssociationHint
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
TextControlElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBRElement
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
nsBlockFrame
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsComputedDOMStyle
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsFontMetrics
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsHTMLParts
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsLineLayout
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsTextFrame
.
h
"
#
include
"
nsIContent
.
h
"
using
namespace
mozilla
;
namespace
mozilla
{
class
BRFrame
final
:
public
nsIFrame
{
public
:
NS_DECL_FRAMEARENA_HELPERS
(
BRFrame
)
friend
nsIFrame
*
:
:
NS_NewBRFrame
(
mozilla
:
:
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
ContentOffsets
CalcContentOffsetsFromFramePoint
(
const
nsPoint
&
aPoint
)
override
;
FrameSearchResult
PeekOffsetNoAmount
(
bool
aForward
int32_t
*
aOffset
)
override
;
FrameSearchResult
PeekOffsetCharacter
(
bool
aForward
int32_t
*
aOffset
PeekOffsetCharacterOptions
aOptions
=
PeekOffsetCharacterOptions
(
)
)
override
;
FrameSearchResult
PeekOffsetWord
(
bool
aForward
bool
aWordSelectEatSpace
bool
aIsKeyboardSelect
int32_t
*
aOffset
PeekWordState
*
aState
bool
aTrimSpaces
)
override
;
void
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aMetrics
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
override
;
void
AddInlineMinISize
(
const
IntrinsicSizeInput
&
aInput
InlineMinISizeData
*
aData
)
override
;
void
AddInlinePrefISize
(
const
IntrinsicSizeInput
&
aInput
InlinePrefISizeData
*
aData
)
override
;
Maybe
<
nscoord
>
GetNaturalBaselineBOffset
(
WritingMode
aWM
BaselineSharingGroup
aBaselineGroup
BaselineExportContext
)
const
override
;
#
ifdef
ACCESSIBILITY
mozilla
:
:
a11y
:
:
AccType
AccessibleType
(
)
override
;
#
endif
#
ifdef
DEBUG_FRAME_DUMP
nsresult
GetFrameName
(
nsAString
&
aResult
)
const
override
{
return
MakeFrameName
(
u
"
BR
"
_ns
aResult
)
;
}
#
endif
protected
:
BRFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
:
nsIFrame
(
aStyle
aPresContext
kClassID
)
mAscent
(
NS_INTRINSIC_ISIZE_UNKNOWN
)
{
}
virtual
~
BRFrame
(
)
;
nscoord
mAscent
;
}
;
}
nsIFrame
*
NS_NewBRFrame
(
mozilla
:
:
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
BRFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
BRFrame
)
BRFrame
:
:
~
BRFrame
(
)
=
default
;
void
BRFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aMetrics
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
BRFrame
"
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
LogicalSize
finalSize
(
wm
)
;
finalSize
.
BSize
(
wm
)
=
0
;
finalSize
.
ISize
(
wm
)
=
0
;
aMetrics
.
SetBlockStartAscent
(
0
)
;
nsLineLayout
*
ll
=
aReflowInput
.
mLineLayout
;
if
(
ll
&
&
!
GetParent
(
)
-
>
Style
(
)
-
>
ShouldSuppressLineBreak
(
)
)
{
if
(
ll
-
>
LineIsEmpty
(
)
|
|
aPresContext
-
>
CompatibilityMode
(
)
=
=
eCompatibility_FullStandards
)
{
RefPtr
<
nsFontMetrics
>
fm
=
nsLayoutUtils
:
:
GetInflatedFontMetricsForFrame
(
this
)
;
if
(
fm
)
{
nscoord
logicalHeight
=
aReflowInput
.
GetLineHeight
(
)
;
finalSize
.
BSize
(
wm
)
=
logicalHeight
;
aMetrics
.
SetBlockStartAscent
(
nsLayoutUtils
:
:
GetCenteredFontBaseline
(
fm
logicalHeight
wm
.
IsLineInverted
(
)
)
)
;
}
else
{
aMetrics
.
SetBlockStartAscent
(
aMetrics
.
BSize
(
wm
)
=
0
)
;
}
finalSize
.
ISize
(
wm
)
=
1
;
}
aStatus
.
SetInlineLineBreakAfter
(
aReflowInput
.
mStyleDisplay
-
>
UsedClear
(
aReflowInput
.
GetCBWritingMode
(
)
)
)
;
ll
-
>
SetLineEndsInBR
(
true
)
;
}
aMetrics
.
SetSize
(
wm
finalSize
)
;
aMetrics
.
SetOverflowAreasToDesiredBounds
(
)
;
mAscent
=
aMetrics
.
BlockStartAscent
(
)
;
}
void
BRFrame
:
:
AddInlineMinISize
(
const
IntrinsicSizeInput
&
aInput
InlineMinISizeData
*
aData
)
{
if
(
!
GetParent
(
)
-
>
Style
(
)
-
>
ShouldSuppressLineBreak
(
)
)
{
aData
-
>
ForceBreak
(
)
;
}
}
void
BRFrame
:
:
AddInlinePrefISize
(
const
IntrinsicSizeInput
&
aInput
InlinePrefISizeData
*
aData
)
{
if
(
!
GetParent
(
)
-
>
Style
(
)
-
>
ShouldSuppressLineBreak
(
)
)
{
aData
-
>
mCurrentLine
+
=
1
;
aData
-
>
ForceBreak
(
)
;
}
}
Maybe
<
nscoord
>
BRFrame
:
:
GetNaturalBaselineBOffset
(
WritingMode
aWM
BaselineSharingGroup
aBaselineGroup
BaselineExportContext
)
const
{
if
(
aBaselineGroup
=
=
BaselineSharingGroup
:
:
Last
)
{
return
Nothing
{
}
;
}
return
Some
(
mAscent
)
;
}
nsIFrame
:
:
ContentOffsets
BRFrame
:
:
CalcContentOffsetsFromFramePoint
(
const
nsPoint
&
aPoint
)
{
ContentOffsets
offsets
;
offsets
.
content
=
mContent
-
>
GetParent
(
)
;
if
(
offsets
.
content
)
{
offsets
.
offset
=
offsets
.
content
-
>
ComputeIndexOf_Deprecated
(
mContent
)
;
offsets
.
secondaryOffset
=
offsets
.
offset
;
offsets
.
associate
=
CaretAssociationHint
:
:
After
;
}
return
offsets
;
}
nsIFrame
:
:
FrameSearchResult
BRFrame
:
:
PeekOffsetNoAmount
(
bool
aForward
int32_t
*
aOffset
)
{
NS_ASSERTION
(
aOffset
&
&
*
aOffset
<
=
1
"
aOffset
out
of
range
"
)
;
int32_t
startOffset
=
*
aOffset
;
if
(
!
aForward
&
&
startOffset
!
=
0
)
{
*
aOffset
=
0
;
return
FOUND
;
}
return
(
startOffset
=
=
0
)
?
FOUND
:
CONTINUE
;
}
nsIFrame
:
:
FrameSearchResult
BRFrame
:
:
PeekOffsetCharacter
(
bool
aForward
int32_t
*
aOffset
PeekOffsetCharacterOptions
aOptions
)
{
NS_ASSERTION
(
aOffset
&
&
*
aOffset
<
=
1
"
aOffset
out
of
range
"
)
;
return
CONTINUE
;
}
nsIFrame
:
:
FrameSearchResult
BRFrame
:
:
PeekOffsetWord
(
bool
aForward
bool
aWordSelectEatSpace
bool
aIsKeyboardSelect
int32_t
*
aOffset
PeekWordState
*
aState
bool
aTrimSpaces
)
{
NS_ASSERTION
(
aOffset
&
&
*
aOffset
<
=
1
"
aOffset
out
of
range
"
)
;
return
CONTINUE
;
}
#
ifdef
ACCESSIBILITY
a11y
:
:
AccType
BRFrame
:
:
AccessibleType
(
)
{
dom
:
:
HTMLBRElement
*
brElement
=
dom
:
:
HTMLBRElement
:
:
FromNode
(
mContent
)
;
if
(
!
brElement
-
>
IsPaddingForEmptyLastLine
(
)
)
{
return
a11y
:
:
eHTMLBRType
;
}
if
(
brElement
-
>
IsInNativeAnonymousSubtree
(
)
)
{
const
auto
*
textControlElement
=
TextControlElement
:
:
FromNodeOrNull
(
brElement
-
>
GetClosestNativeAnonymousSubtreeRootParentOrHost
(
)
)
;
if
(
textControlElement
&
&
textControlElement
-
>
IsSingleLineTextControlOrTextArea
(
)
)
{
return
a11y
:
:
eNoType
;
}
}
nsIFrame
*
const
parentFrame
=
GetParent
(
)
;
if
(
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
|
|
!
parentFrame
)
{
return
a11y
:
:
eHTMLBRType
;
}
nsIFrame
*
const
currentBlock
=
nsBlockFrame
:
:
GetNearestAncestorBlock
(
parentFrame
)
;
nsIContent
*
const
currentBlockContent
=
currentBlock
?
currentBlock
-
>
GetContent
(
)
:
nullptr
;
for
(
nsIContent
*
previousContent
=
brElement
-
>
GetPrevNode
(
currentBlockContent
)
;
previousContent
;
previousContent
=
previousContent
-
>
GetPrevNode
(
currentBlockContent
)
)
{
nsIFrame
*
const
precedingContentFrame
=
previousContent
-
>
GetPrimaryFrame
(
)
;
if
(
!
precedingContentFrame
|
|
precedingContentFrame
-
>
IsEmpty
(
)
)
{
continue
;
}
if
(
precedingContentFrame
-
>
IsBlockFrameOrSubclass
(
)
)
{
break
;
}
return
a11y
:
:
eHTMLBRType
;
}
return
a11y
:
:
eHTMLBRType
;
}
#
endif
