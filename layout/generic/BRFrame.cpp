#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBRElement
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsFontMetrics
.
h
"
#
include
"
nsHTMLParts
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsLineLayout
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsIContent
.
h
"
using
namespace
mozilla
;
namespace
mozilla
{
class
BRFrame
final
:
public
nsIFrame
{
public
:
NS_DECL_FRAMEARENA_HELPERS
(
BRFrame
)
friend
nsIFrame
*
:
:
NS_NewBRFrame
(
mozilla
:
:
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
ContentOffsets
CalcContentOffsetsFromFramePoint
(
const
nsPoint
&
aPoint
)
override
;
virtual
FrameSearchResult
PeekOffsetNoAmount
(
bool
aForward
int32_t
*
aOffset
)
override
;
virtual
FrameSearchResult
PeekOffsetCharacter
(
bool
aForward
int32_t
*
aOffset
PeekOffsetCharacterOptions
aOptions
=
PeekOffsetCharacterOptions
(
)
)
override
;
virtual
FrameSearchResult
PeekOffsetWord
(
bool
aForward
bool
aWordSelectEatSpace
bool
aIsKeyboardSelect
int32_t
*
aOffset
PeekWordState
*
aState
bool
aTrimSpaces
)
override
;
virtual
void
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
override
;
virtual
void
AddInlineMinISize
(
gfxContext
*
aRenderingContext
InlineMinISizeData
*
aData
)
override
;
virtual
void
AddInlinePrefISize
(
gfxContext
*
aRenderingContext
InlinePrefISizeData
*
aData
)
override
;
virtual
nscoord
GetMinISize
(
gfxContext
*
aRenderingContext
)
override
;
virtual
nscoord
GetPrefISize
(
gfxContext
*
aRenderingContext
)
override
;
virtual
nscoord
GetLogicalBaseline
(
mozilla
:
:
WritingMode
aWritingMode
)
const
override
;
virtual
bool
IsFrameOfType
(
uint32_t
aFlags
)
const
override
{
return
nsIFrame
:
:
IsFrameOfType
(
aFlags
&
~
(
nsIFrame
:
:
eReplaced
|
nsIFrame
:
:
eLineParticipant
)
)
;
}
#
ifdef
ACCESSIBILITY
virtual
mozilla
:
:
a11y
:
:
AccType
AccessibleType
(
)
override
;
#
endif
protected
:
explicit
BRFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
:
nsIFrame
(
aStyle
aPresContext
kClassID
)
mAscent
(
NS_INTRINSIC_ISIZE_UNKNOWN
)
{
}
virtual
~
BRFrame
(
)
;
nscoord
mAscent
;
}
;
}
nsIFrame
*
NS_NewBRFrame
(
mozilla
:
:
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
BRFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
BRFrame
)
BRFrame
:
:
~
BRFrame
(
)
=
default
;
void
BRFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aMetrics
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
BRFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aMetrics
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
LogicalSize
finalSize
(
wm
)
;
finalSize
.
BSize
(
wm
)
=
0
;
finalSize
.
ISize
(
wm
)
=
0
;
aMetrics
.
SetBlockStartAscent
(
0
)
;
nsLineLayout
*
ll
=
aReflowInput
.
mLineLayout
;
if
(
ll
&
&
!
GetParent
(
)
-
>
Style
(
)
-
>
ShouldSuppressLineBreak
(
)
)
{
if
(
ll
-
>
LineIsEmpty
(
)
|
|
aPresContext
-
>
CompatibilityMode
(
)
=
=
eCompatibility_FullStandards
)
{
RefPtr
<
nsFontMetrics
>
fm
=
nsLayoutUtils
:
:
GetInflatedFontMetricsForFrame
(
this
)
;
if
(
fm
)
{
nscoord
logicalHeight
=
aReflowInput
.
GetLineHeight
(
)
;
finalSize
.
BSize
(
wm
)
=
logicalHeight
;
aMetrics
.
SetBlockStartAscent
(
nsLayoutUtils
:
:
GetCenteredFontBaseline
(
fm
logicalHeight
wm
.
IsLineInverted
(
)
)
)
;
}
else
{
aMetrics
.
SetBlockStartAscent
(
aMetrics
.
BSize
(
wm
)
=
0
)
;
}
finalSize
.
ISize
(
wm
)
=
1
;
}
StyleClear
breakType
=
aReflowInput
.
mStyleDisplay
-
>
mBreakType
;
if
(
StyleClear
:
:
None
=
=
breakType
)
{
breakType
=
StyleClear
:
:
Line
;
}
aStatus
.
SetInlineLineBreakAfter
(
breakType
)
;
ll
-
>
SetLineEndsInBR
(
true
)
;
}
aMetrics
.
SetSize
(
wm
finalSize
)
;
aMetrics
.
SetOverflowAreasToDesiredBounds
(
)
;
mAscent
=
aMetrics
.
BlockStartAscent
(
)
;
}
void
BRFrame
:
:
AddInlineMinISize
(
gfxContext
*
aRenderingContext
nsIFrame
:
:
InlineMinISizeData
*
aData
)
{
if
(
!
GetParent
(
)
-
>
Style
(
)
-
>
ShouldSuppressLineBreak
(
)
)
{
aData
-
>
ForceBreak
(
)
;
}
}
void
BRFrame
:
:
AddInlinePrefISize
(
gfxContext
*
aRenderingContext
nsIFrame
:
:
InlinePrefISizeData
*
aData
)
{
if
(
!
GetParent
(
)
-
>
Style
(
)
-
>
ShouldSuppressLineBreak
(
)
)
{
aData
-
>
mCurrentLine
+
=
1
;
aData
-
>
ForceBreak
(
)
;
}
}
nscoord
BRFrame
:
:
GetMinISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
result
=
0
;
DISPLAY_MIN_INLINE_SIZE
(
this
result
)
;
return
result
;
}
nscoord
BRFrame
:
:
GetPrefISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
result
=
0
;
DISPLAY_PREF_INLINE_SIZE
(
this
result
)
;
return
result
;
}
nscoord
BRFrame
:
:
GetLogicalBaseline
(
mozilla
:
:
WritingMode
aWritingMode
)
const
{
return
mAscent
;
}
nsIFrame
:
:
ContentOffsets
BRFrame
:
:
CalcContentOffsetsFromFramePoint
(
const
nsPoint
&
aPoint
)
{
ContentOffsets
offsets
;
offsets
.
content
=
mContent
-
>
GetParent
(
)
;
if
(
offsets
.
content
)
{
offsets
.
offset
=
offsets
.
content
-
>
ComputeIndexOf_Deprecated
(
mContent
)
;
offsets
.
secondaryOffset
=
offsets
.
offset
;
offsets
.
associate
=
CARET_ASSOCIATE_AFTER
;
}
return
offsets
;
}
nsIFrame
:
:
FrameSearchResult
BRFrame
:
:
PeekOffsetNoAmount
(
bool
aForward
int32_t
*
aOffset
)
{
NS_ASSERTION
(
aOffset
&
&
*
aOffset
<
=
1
"
aOffset
out
of
range
"
)
;
int32_t
startOffset
=
*
aOffset
;
if
(
!
aForward
&
&
startOffset
!
=
0
)
{
*
aOffset
=
0
;
return
FOUND
;
}
return
(
startOffset
=
=
0
)
?
FOUND
:
CONTINUE
;
}
nsIFrame
:
:
FrameSearchResult
BRFrame
:
:
PeekOffsetCharacter
(
bool
aForward
int32_t
*
aOffset
PeekOffsetCharacterOptions
aOptions
)
{
NS_ASSERTION
(
aOffset
&
&
*
aOffset
<
=
1
"
aOffset
out
of
range
"
)
;
return
CONTINUE
;
}
nsIFrame
:
:
FrameSearchResult
BRFrame
:
:
PeekOffsetWord
(
bool
aForward
bool
aWordSelectEatSpace
bool
aIsKeyboardSelect
int32_t
*
aOffset
PeekWordState
*
aState
bool
aTrimSpaces
)
{
NS_ASSERTION
(
aOffset
&
&
*
aOffset
<
=
1
"
aOffset
out
of
range
"
)
;
return
CONTINUE
;
}
#
ifdef
ACCESSIBILITY
a11y
:
:
AccType
BRFrame
:
:
AccessibleType
(
)
{
dom
:
:
HTMLBRElement
*
brElement
=
dom
:
:
HTMLBRElement
:
:
FromNode
(
mContent
)
;
if
(
brElement
-
>
IsPaddingForEmptyEditor
(
)
|
|
brElement
-
>
IsPaddingForEmptyLastLine
(
)
)
{
return
a11y
:
:
eNoType
;
}
return
a11y
:
:
eHTMLBRType
;
}
#
endif
