#
include
"
nsSplittableFrame
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsFieldSetFrame
.
h
"
#
include
"
nsIFrameInlines
.
h
"
using
namespace
mozilla
;
NS_QUERYFRAME_HEAD
(
nsSplittableFrame
)
NS_QUERYFRAME_ENTRY
(
nsSplittableFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsIFrame
)
void
nsSplittableFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
if
(
aPrevInFlow
)
{
aPrevInFlow
-
>
SetNextInFlow
(
this
)
;
}
nsIFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
}
void
nsSplittableFrame
:
:
Destroy
(
DestroyContext
&
aContext
)
{
if
(
mPrevContinuation
|
|
mNextContinuation
)
{
RemoveFromFlow
(
this
)
;
}
nsIFrame
:
:
Destroy
(
aContext
)
;
}
nsIFrame
*
nsSplittableFrame
:
:
GetPrevContinuation
(
)
const
{
return
mPrevContinuation
;
}
nsIFrame
*
nsSplittableFrame
:
:
GetNextContinuation
(
)
const
{
return
mNextContinuation
;
}
void
nsSplittableFrame
:
:
SetNextContinuation
(
nsIFrame
*
aFrame
bool
aIsFluid
)
{
MOZ_ASSERT
(
!
aFrame
|
|
Type
(
)
=
=
aFrame
-
>
Type
(
)
"
Setting
a
next
-
continuation
with
an
incorrect
type
!
"
)
;
MOZ_ASSERT
(
!
IsInNextContinuationChain
(
aFrame
this
)
"
We
shouldn
'
t
be
in
aFrame
'
s
next
-
continuation
chain
!
"
)
;
MOZ_ASSERT
(
!
IsInPrevContinuationChain
(
this
aFrame
)
"
aFrame
shouldn
'
t
be
in
our
prev
-
continuation
chain
!
"
)
;
if
(
mNextContinuation
&
&
mNextContinuation
!
=
aFrame
)
{
MOZ_ASSERT
(
mNextContinuation
-
>
GetPrevContinuation
(
)
=
=
this
"
The
existing
link
is
wrong
!
"
)
;
auto
*
next
=
static_cast
<
nsSplittableFrame
*
>
(
mNextContinuation
)
;
next
-
>
mPrevContinuation
=
nullptr
;
}
mNextContinuation
=
aFrame
;
if
(
mNextContinuation
)
{
mNextContinuation
-
>
AddOrRemoveStateBits
(
NS_FRAME_IS_FLUID_CONTINUATION
aIsFluid
)
;
auto
*
next
=
static_cast
<
nsSplittableFrame
*
>
(
mNextContinuation
)
;
next
-
>
mPrevContinuation
=
this
;
}
}
nsIFrame
*
nsSplittableFrame
:
:
FirstContinuation
(
)
const
{
nsSplittableFrame
*
firstContinuation
=
const_cast
<
nsSplittableFrame
*
>
(
this
)
;
while
(
firstContinuation
-
>
mPrevContinuation
)
{
firstContinuation
=
static_cast
<
nsSplittableFrame
*
>
(
firstContinuation
-
>
mPrevContinuation
)
;
}
MOZ_ASSERT
(
firstContinuation
"
post
-
condition
failed
"
)
;
return
firstContinuation
;
}
nsIFrame
*
nsSplittableFrame
:
:
LastContinuation
(
)
const
{
nsSplittableFrame
*
lastContinuation
=
const_cast
<
nsSplittableFrame
*
>
(
this
)
;
while
(
lastContinuation
-
>
mNextContinuation
)
{
lastContinuation
=
static_cast
<
nsSplittableFrame
*
>
(
lastContinuation
-
>
mNextContinuation
)
;
}
MOZ_ASSERT
(
lastContinuation
"
post
-
condition
failed
"
)
;
return
lastContinuation
;
}
#
ifdef
DEBUG
bool
nsSplittableFrame
:
:
IsInPrevContinuationChain
(
nsIFrame
*
aFrame1
nsIFrame
*
aFrame2
)
{
int32_t
iterations
=
0
;
while
(
aFrame1
&
&
iterations
<
10
)
{
if
(
aFrame1
=
=
aFrame2
)
return
true
;
aFrame1
=
aFrame1
-
>
GetPrevContinuation
(
)
;
+
+
iterations
;
}
return
false
;
}
bool
nsSplittableFrame
:
:
IsInNextContinuationChain
(
nsIFrame
*
aFrame1
nsIFrame
*
aFrame2
)
{
int32_t
iterations
=
0
;
while
(
aFrame1
&
&
iterations
<
10
)
{
if
(
aFrame1
=
=
aFrame2
)
return
true
;
aFrame1
=
aFrame1
-
>
GetNextContinuation
(
)
;
+
+
iterations
;
}
return
false
;
}
#
endif
nsIFrame
*
nsSplittableFrame
:
:
GetPrevInFlow
(
)
const
{
return
HasAnyStateBits
(
NS_FRAME_IS_FLUID_CONTINUATION
)
?
mPrevContinuation
:
nullptr
;
}
nsIFrame
*
nsSplittableFrame
:
:
GetNextInFlow
(
)
const
{
return
mNextContinuation
&
&
mNextContinuation
-
>
HasAnyStateBits
(
NS_FRAME_IS_FLUID_CONTINUATION
)
?
mNextContinuation
:
nullptr
;
}
nsIFrame
*
nsSplittableFrame
:
:
FirstInFlow
(
)
const
{
nsSplittableFrame
*
firstInFlow
=
const_cast
<
nsSplittableFrame
*
>
(
this
)
;
while
(
nsIFrame
*
prev
=
firstInFlow
-
>
GetPrevInFlow
(
)
)
{
firstInFlow
=
static_cast
<
nsSplittableFrame
*
>
(
prev
)
;
}
MOZ_ASSERT
(
firstInFlow
"
post
-
condition
failed
"
)
;
return
firstInFlow
;
}
nsIFrame
*
nsSplittableFrame
:
:
LastInFlow
(
)
const
{
nsSplittableFrame
*
lastInFlow
=
const_cast
<
nsSplittableFrame
*
>
(
this
)
;
while
(
nsIFrame
*
next
=
lastInFlow
-
>
GetNextInFlow
(
)
)
{
lastInFlow
=
static_cast
<
nsSplittableFrame
*
>
(
next
)
;
}
MOZ_ASSERT
(
lastInFlow
"
post
-
condition
failed
"
)
;
return
lastInFlow
;
}
void
nsSplittableFrame
:
:
RemoveFromFlow
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
)
;
nsIFrame
*
prevContinuation
=
aFrame
-
>
GetPrevContinuation
(
)
;
nsIFrame
*
nextContinuation
=
aFrame
-
>
GetNextContinuation
(
)
;
nsIFrame
*
prevInFlow
=
aFrame
-
>
GetPrevInFlow
(
)
;
nsIFrame
*
nextInFlow
=
aFrame
-
>
GetNextInFlow
(
)
;
aFrame
-
>
SetNextInFlow
(
nullptr
)
;
if
(
prevInFlow
&
&
nextInFlow
)
{
prevInFlow
-
>
SetNextInFlow
(
nextInFlow
)
;
}
else
if
(
prevContinuation
)
{
prevContinuation
-
>
SetNextContinuation
(
nextContinuation
)
;
}
}
NS_DECLARE_FRAME_PROPERTY_SMALL_VALUE
(
ConsumedBSizeProperty
nscoord
)
;
nscoord
nsSplittableFrame
:
:
CalcAndCacheConsumedBSize
(
)
{
nsIFrame
*
prev
=
GetPrevContinuation
(
)
;
if
(
!
prev
)
{
return
0
;
}
const
auto
wm
=
GetWritingMode
(
)
;
nscoord
bSize
=
0
;
for
(
;
prev
;
prev
=
prev
-
>
GetPrevContinuation
(
)
)
{
if
(
prev
-
>
IsTrueOverflowContainer
(
)
)
{
continue
;
}
bSize
+
=
prev
-
>
ContentBSize
(
wm
)
;
bool
found
=
false
;
nscoord
consumed
=
prev
-
>
GetProperty
(
ConsumedBSizeProperty
(
)
&
found
)
;
if
(
found
)
{
bSize
+
=
consumed
;
break
;
}
MOZ_ASSERT
(
!
prev
-
>
GetPrevContinuation
(
)
"
Property
should
always
be
set
on
prev
continuation
if
not
"
"
the
first
continuation
"
)
;
}
SetProperty
(
ConsumedBSizeProperty
(
)
bSize
)
;
return
bSize
;
}
nscoord
nsSplittableFrame
:
:
GetEffectiveComputedBSize
(
const
ReflowInput
&
aReflowInput
nscoord
aConsumedBSize
)
const
{
nscoord
bSize
=
aReflowInput
.
ComputedBSize
(
)
;
if
(
bSize
=
=
NS_UNCONSTRAINEDSIZE
)
{
return
NS_UNCONSTRAINEDSIZE
;
}
bSize
-
=
aConsumedBSize
;
if
(
IsTrueOverflowContainer
(
)
&
&
Style
(
)
-
>
GetPseudoType
(
)
=
=
PseudoStyleType
:
:
fieldsetContent
)
{
for
(
nsFieldSetFrame
*
fieldset
=
do_QueryFrame
(
GetParent
(
)
)
;
fieldset
;
fieldset
=
static_cast
<
nsFieldSetFrame
*
>
(
fieldset
-
>
GetPrevInFlow
(
)
)
)
{
bSize
-
=
fieldset
-
>
LegendSpace
(
)
;
}
}
return
std
:
:
max
(
0
bSize
)
;
}
LogicalSides
nsSplittableFrame
:
:
GetBlockLevelLogicalSkipSides
(
bool
aAfterReflow
)
const
{
LogicalSides
skip
(
mWritingMode
)
;
if
(
MOZ_UNLIKELY
(
IsTrueOverflowContainer
(
)
)
)
{
skip
|
=
eLogicalSideBitsBBoth
;
return
skip
;
}
if
(
MOZ_UNLIKELY
(
StyleBorder
(
)
-
>
mBoxDecorationBreak
=
=
StyleBoxDecorationBreak
:
:
Clone
)
)
{
return
skip
;
}
if
(
GetPrevContinuation
(
)
)
{
skip
|
=
eLogicalSideBitsBStart
;
}
if
(
HasColumnSpanSiblings
(
)
)
{
skip
|
=
eLogicalSideBitsBEnd
;
}
if
(
aAfterReflow
)
{
nsIFrame
*
nif
=
GetNextContinuation
(
)
;
if
(
nif
&
&
!
nif
-
>
IsTrueOverflowContainer
(
)
)
{
skip
|
=
eLogicalSideBitsBEnd
;
}
}
return
skip
;
}
