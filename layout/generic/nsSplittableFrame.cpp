#
include
"
nsSplittableFrame
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsFieldSetFrame
.
h
"
#
include
"
nsIFrameInlines
.
h
"
using
namespace
mozilla
;
void
nsSplittableFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
if
(
aPrevInFlow
)
{
SetPrevInFlow
(
aPrevInFlow
)
;
aPrevInFlow
-
>
SetNextInFlow
(
this
)
;
}
nsIFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
}
void
nsSplittableFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
{
if
(
mPrevContinuation
|
|
mNextContinuation
)
{
RemoveFromFlow
(
this
)
;
}
nsIFrame
:
:
DestroyFrom
(
aDestructRoot
aPostDestroyData
)
;
}
nsIFrame
*
nsSplittableFrame
:
:
GetPrevContinuation
(
)
const
{
return
mPrevContinuation
;
}
void
nsSplittableFrame
:
:
SetPrevContinuation
(
nsIFrame
*
aFrame
)
{
NS_ASSERTION
(
!
aFrame
|
|
Type
(
)
=
=
aFrame
-
>
Type
(
)
"
setting
a
prev
continuation
with
incorrect
type
!
"
)
;
NS_ASSERTION
(
!
IsInPrevContinuationChain
(
aFrame
this
)
"
creating
a
loop
in
continuation
chain
!
"
)
;
mPrevContinuation
=
aFrame
;
RemoveStateBits
(
NS_FRAME_IS_FLUID_CONTINUATION
)
;
}
nsIFrame
*
nsSplittableFrame
:
:
GetNextContinuation
(
)
const
{
return
mNextContinuation
;
}
void
nsSplittableFrame
:
:
SetNextContinuation
(
nsIFrame
*
aFrame
)
{
NS_ASSERTION
(
!
aFrame
|
|
Type
(
)
=
=
aFrame
-
>
Type
(
)
"
setting
a
next
continuation
with
incorrect
type
!
"
)
;
NS_ASSERTION
(
!
IsInNextContinuationChain
(
aFrame
this
)
"
creating
a
loop
in
continuation
chain
!
"
)
;
mNextContinuation
=
aFrame
;
if
(
aFrame
)
aFrame
-
>
RemoveStateBits
(
NS_FRAME_IS_FLUID_CONTINUATION
)
;
}
nsIFrame
*
nsSplittableFrame
:
:
FirstContinuation
(
)
const
{
nsSplittableFrame
*
firstContinuation
=
const_cast
<
nsSplittableFrame
*
>
(
this
)
;
while
(
firstContinuation
-
>
mPrevContinuation
)
{
firstContinuation
=
static_cast
<
nsSplittableFrame
*
>
(
firstContinuation
-
>
mPrevContinuation
)
;
}
MOZ_ASSERT
(
firstContinuation
"
post
-
condition
failed
"
)
;
return
firstContinuation
;
}
nsIFrame
*
nsSplittableFrame
:
:
LastContinuation
(
)
const
{
nsSplittableFrame
*
lastContinuation
=
const_cast
<
nsSplittableFrame
*
>
(
this
)
;
while
(
lastContinuation
-
>
mNextContinuation
)
{
lastContinuation
=
static_cast
<
nsSplittableFrame
*
>
(
lastContinuation
-
>
mNextContinuation
)
;
}
MOZ_ASSERT
(
lastContinuation
"
post
-
condition
failed
"
)
;
return
lastContinuation
;
}
#
ifdef
DEBUG
bool
nsSplittableFrame
:
:
IsInPrevContinuationChain
(
nsIFrame
*
aFrame1
nsIFrame
*
aFrame2
)
{
int32_t
iterations
=
0
;
while
(
aFrame1
&
&
iterations
<
10
)
{
if
(
aFrame1
=
=
aFrame2
)
return
true
;
aFrame1
=
aFrame1
-
>
GetPrevContinuation
(
)
;
+
+
iterations
;
}
return
false
;
}
bool
nsSplittableFrame
:
:
IsInNextContinuationChain
(
nsIFrame
*
aFrame1
nsIFrame
*
aFrame2
)
{
int32_t
iterations
=
0
;
while
(
aFrame1
&
&
iterations
<
10
)
{
if
(
aFrame1
=
=
aFrame2
)
return
true
;
aFrame1
=
aFrame1
-
>
GetNextContinuation
(
)
;
+
+
iterations
;
}
return
false
;
}
#
endif
nsIFrame
*
nsSplittableFrame
:
:
GetPrevInFlow
(
)
const
{
return
HasAnyStateBits
(
NS_FRAME_IS_FLUID_CONTINUATION
)
?
mPrevContinuation
:
nullptr
;
}
void
nsSplittableFrame
:
:
SetPrevInFlow
(
nsIFrame
*
aFrame
)
{
NS_ASSERTION
(
!
aFrame
|
|
Type
(
)
=
=
aFrame
-
>
Type
(
)
"
setting
a
prev
in
flow
with
incorrect
type
!
"
)
;
NS_ASSERTION
(
!
IsInPrevContinuationChain
(
aFrame
this
)
"
creating
a
loop
in
continuation
chain
!
"
)
;
mPrevContinuation
=
aFrame
;
AddStateBits
(
NS_FRAME_IS_FLUID_CONTINUATION
)
;
}
nsIFrame
*
nsSplittableFrame
:
:
GetNextInFlow
(
)
const
{
return
mNextContinuation
&
&
mNextContinuation
-
>
HasAnyStateBits
(
NS_FRAME_IS_FLUID_CONTINUATION
)
?
mNextContinuation
:
nullptr
;
}
void
nsSplittableFrame
:
:
SetNextInFlow
(
nsIFrame
*
aFrame
)
{
NS_ASSERTION
(
!
aFrame
|
|
Type
(
)
=
=
aFrame
-
>
Type
(
)
"
setting
a
next
in
flow
with
incorrect
type
!
"
)
;
NS_ASSERTION
(
!
IsInNextContinuationChain
(
aFrame
this
)
"
creating
a
loop
in
continuation
chain
!
"
)
;
mNextContinuation
=
aFrame
;
if
(
aFrame
)
aFrame
-
>
AddStateBits
(
NS_FRAME_IS_FLUID_CONTINUATION
)
;
}
nsIFrame
*
nsSplittableFrame
:
:
FirstInFlow
(
)
const
{
nsSplittableFrame
*
firstInFlow
=
const_cast
<
nsSplittableFrame
*
>
(
this
)
;
while
(
nsIFrame
*
prev
=
firstInFlow
-
>
GetPrevInFlow
(
)
)
{
firstInFlow
=
static_cast
<
nsSplittableFrame
*
>
(
prev
)
;
}
MOZ_ASSERT
(
firstInFlow
"
post
-
condition
failed
"
)
;
return
firstInFlow
;
}
nsIFrame
*
nsSplittableFrame
:
:
LastInFlow
(
)
const
{
nsSplittableFrame
*
lastInFlow
=
const_cast
<
nsSplittableFrame
*
>
(
this
)
;
while
(
nsIFrame
*
next
=
lastInFlow
-
>
GetNextInFlow
(
)
)
{
lastInFlow
=
static_cast
<
nsSplittableFrame
*
>
(
next
)
;
}
MOZ_ASSERT
(
lastInFlow
"
post
-
condition
failed
"
)
;
return
lastInFlow
;
}
void
nsSplittableFrame
:
:
RemoveFromFlow
(
nsIFrame
*
aFrame
)
{
nsIFrame
*
prevContinuation
=
aFrame
-
>
GetPrevContinuation
(
)
;
nsIFrame
*
nextContinuation
=
aFrame
-
>
GetNextContinuation
(
)
;
if
(
aFrame
-
>
GetPrevInFlow
(
)
&
&
aFrame
-
>
GetNextInFlow
(
)
)
{
if
(
prevContinuation
)
{
prevContinuation
-
>
SetNextInFlow
(
nextContinuation
)
;
}
if
(
nextContinuation
)
{
nextContinuation
-
>
SetPrevInFlow
(
prevContinuation
)
;
}
}
else
{
if
(
prevContinuation
)
{
prevContinuation
-
>
SetNextContinuation
(
nextContinuation
)
;
}
if
(
nextContinuation
)
{
nextContinuation
-
>
SetPrevContinuation
(
prevContinuation
)
;
}
}
aFrame
-
>
SetPrevInFlow
(
nullptr
)
;
aFrame
-
>
SetNextInFlow
(
nullptr
)
;
}
NS_DECLARE_FRAME_PROPERTY_SMALL_VALUE
(
ConsumedBSizeProperty
nscoord
)
;
nscoord
nsSplittableFrame
:
:
CalcAndCacheConsumedBSize
(
WritingMode
aWM
)
{
nsIFrame
*
prev
=
GetPrevContinuation
(
)
;
if
(
!
prev
)
{
return
0
;
}
nscoord
bSize
=
0
;
for
(
;
prev
;
prev
=
prev
-
>
GetPrevContinuation
(
)
)
{
bSize
+
=
prev
-
>
ContentSize
(
aWM
)
.
BSize
(
aWM
)
;
bool
found
=
false
;
nscoord
consumed
=
prev
-
>
GetProperty
(
ConsumedBSizeProperty
(
)
&
found
)
;
if
(
found
)
{
bSize
+
=
consumed
;
break
;
}
MOZ_ASSERT
(
!
prev
-
>
GetPrevContinuation
(
)
"
Property
should
always
be
set
on
prev
continuation
if
not
"
"
the
first
continuation
"
)
;
}
SetProperty
(
ConsumedBSizeProperty
(
)
bSize
)
;
return
bSize
;
}
nscoord
nsSplittableFrame
:
:
GetEffectiveComputedBSize
(
const
ReflowInput
&
aReflowInput
nscoord
aConsumedBSize
)
const
{
nscoord
bSize
=
aReflowInput
.
ComputedBSize
(
)
;
if
(
bSize
=
=
NS_UNCONSTRAINEDSIZE
)
{
return
NS_UNCONSTRAINEDSIZE
;
}
bSize
-
=
aConsumedBSize
;
if
(
IsTrueOverflowContainer
(
)
&
&
Style
(
)
-
>
GetPseudoType
(
)
=
=
PseudoStyleType
:
:
fieldsetContent
)
{
for
(
nsFieldSetFrame
*
fieldset
=
do_QueryFrame
(
GetParent
(
)
)
;
fieldset
;
fieldset
=
static_cast
<
nsFieldSetFrame
*
>
(
fieldset
-
>
GetPrevInFlow
(
)
)
)
{
bSize
-
=
fieldset
-
>
LegendSpace
(
)
;
}
}
return
std
:
:
max
(
0
bSize
)
;
}
nsIFrame
:
:
LogicalSides
nsSplittableFrame
:
:
GetLogicalSkipSides
(
const
Maybe
<
SkipSidesDuringReflow
>
&
aDuringReflow
)
const
{
LogicalSides
skip
(
mWritingMode
)
;
if
(
IsTrueOverflowContainer
(
)
)
{
skip
|
=
eLogicalSideBitsBBoth
;
return
skip
;
}
if
(
MOZ_UNLIKELY
(
StyleBorder
(
)
-
>
mBoxDecorationBreak
=
=
StyleBoxDecorationBreak
:
:
Clone
)
)
{
return
skip
;
}
if
(
GetPrevContinuation
(
)
)
{
skip
|
=
eLogicalSideBitsBStart
;
}
if
(
aDuringReflow
)
{
nscoord
availBSize
=
aDuringReflow
-
>
mReflowInput
.
AvailableBSize
(
)
;
if
(
NS_UNCONSTRAINEDSIZE
!
=
availBSize
)
{
nscoord
effectiveBSize
=
GetEffectiveComputedBSize
(
aDuringReflow
-
>
mReflowInput
aDuringReflow
-
>
mConsumedBSize
)
;
if
(
effectiveBSize
!
=
NS_UNCONSTRAINEDSIZE
&
&
effectiveBSize
>
availBSize
)
{
skip
|
=
eLogicalSideBitsBEnd
;
}
}
}
else
{
nsIFrame
*
nif
=
GetNextContinuation
(
)
;
if
(
nif
&
&
!
nif
-
>
IsTrueOverflowContainer
(
)
)
{
skip
|
=
eLogicalSideBitsBEnd
;
}
}
if
(
HasColumnSpanSiblings
(
)
)
{
skip
|
=
eLogicalSideBitsBEnd
;
}
return
skip
;
}
LogicalSides
nsSplittableFrame
:
:
PreReflowBlockLevelLogicalSkipSides
(
)
const
{
LogicalSides
skip
(
mWritingMode
)
;
if
(
MOZ_UNLIKELY
(
IsTrueOverflowContainer
(
)
)
)
{
skip
|
=
mozilla
:
:
eLogicalSideBitsBBoth
;
return
skip
;
}
if
(
MOZ_LIKELY
(
StyleBorder
(
)
-
>
mBoxDecorationBreak
!
=
StyleBoxDecorationBreak
:
:
Clone
)
&
&
GetPrevInFlow
(
)
)
{
skip
|
=
mozilla
:
:
eLogicalSideBitsBStart
;
return
skip
;
}
return
skip
;
}
