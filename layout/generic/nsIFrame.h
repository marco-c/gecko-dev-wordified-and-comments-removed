#
ifndef
nsIFrame_h___
#
define
nsIFrame_h___
#
ifndef
MOZILLA_INTERNAL_API
#
error
This
header
/
class
should
only
be
used
within
Mozilla
code
.
It
should
not
be
used
by
extensions
.
#
endif
#
if
(
defined
(
XP_WIN
)
&
&
!
defined
(
HAVE_64BIT_BUILD
)
)
|
|
defined
(
ANDROID
)
#
define
MAX_REFLOW_DEPTH
585
#
else
#
define
MAX_REFLOW_DEPTH
1026
#
endif
#
include
<
algorithm
>
#
include
<
stdio
.
h
>
#
include
"
CaretAssociationHint
.
h
"
#
include
"
FrameProperties
.
h
"
#
include
"
LayoutConstants
.
h
"
#
include
"
mozilla
/
layout
/
FrameChildList
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
SmallPointerArray
.
h
"
#
include
"
mozilla
/
WritingModes
.
h
"
#
include
"
nsDirection
.
h
"
#
include
"
nsFrameList
.
h
"
#
include
"
nsFrameState
.
h
"
#
include
"
mozilla
/
ReflowOutput
.
h
"
#
include
"
nsITheme
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsQueryFrame
.
h
"
#
include
"
nsString
.
h
"
#
include
"
mozilla
/
ComputedStyle
.
h
"
#
include
"
nsStyleStruct
.
h
"
#
include
"
Visibility
.
h
"
#
include
"
nsChangeHint
.
h
"
#
include
"
mozilla
/
ComputedStyleInlines
.
h
"
#
include
"
mozilla
/
gfx
/
CompositorHitTestInfo
.
h
"
#
include
"
mozilla
/
gfx
/
MatrixFwd
.
h
"
#
include
"
nsDisplayItemTypes
.
h
"
#
ifdef
ACCESSIBILITY
#
include
"
mozilla
/
a11y
/
AccTypes
.
h
"
#
endif
class
nsAtom
;
class
nsPresContext
;
class
nsView
;
class
nsIWidget
;
class
nsISelectionController
;
class
nsBoxLayoutState
;
class
nsBoxLayout
;
class
nsILineIterator
;
class
nsDisplayItemBase
;
class
nsDisplayListBuilder
;
class
nsDisplayListSet
;
class
nsDisplayList
;
class
gfxSkipChars
;
class
gfxSkipCharsIterator
;
class
gfxContext
;
class
nsLineList_iterator
;
class
nsAbsoluteContainingBlock
;
class
nsIContent
;
class
nsContainerFrame
;
class
nsPlaceholderFrame
;
class
nsStyleChangeList
;
class
nsWindowSizes
;
struct
nsPeekOffsetStruct
;
struct
nsPoint
;
struct
nsRect
;
struct
nsSize
;
struct
nsMargin
;
struct
CharacterDataChangeInfo
;
namespace
mozilla
{
enum
class
PseudoStyleType
:
uint8_t
;
class
EventStates
;
class
PresShell
;
struct
ReflowInput
;
class
ReflowOutput
;
class
ServoRestyleState
;
class
DisplayItemData
;
class
EffectSet
;
namespace
layers
{
class
Layer
;
class
LayerManager
;
}
namespace
layout
{
class
ScrollAnchorContainer
;
}
namespace
dom
{
class
Selection
;
}
}
#
define
NS_SUBTREE_DIRTY
(
_frame
)
\
(
(
(
_frame
)
-
>
GetStateBits
(
)
&
\
(
NS_FRAME_IS_DIRTY
|
NS_FRAME_HAS_DIRTY_CHILDREN
)
)
!
=
0
)
#
define
INFINITE_ISIZE_COORD
nscoord
(
NS_MAXSIZE
-
(
1000000
*
60
)
)
namespace
mozilla
{
enum
class
LayoutFrameType
:
uint8_t
{
#
define
FRAME_TYPE
(
ty_
)
ty_
#
include
"
mozilla
/
FrameTypeList
.
h
"
#
undef
FRAME_TYPE
}
;
}
enum
nsSelectionAmount
{
eSelectCharacter
=
0
eSelectCluster
=
1
eSelectWord
=
2
eSelectWordNoSpace
=
3
eSelectLine
=
4
eSelectBeginLine
=
5
eSelectEndLine
=
6
eSelectNoAmount
=
7
eSelectParagraph
=
8
}
;
class
nsReflowStatus
final
{
using
StyleClear
=
mozilla
:
:
StyleClear
;
public
:
nsReflowStatus
(
)
:
mBreakType
(
StyleClear
:
:
None
)
mInlineBreak
(
InlineBreak
:
:
None
)
mCompletion
(
Completion
:
:
FullyComplete
)
mNextInFlowNeedsReflow
(
false
)
mTruncated
(
false
)
mFirstLetterComplete
(
false
)
{
}
void
Reset
(
)
{
mBreakType
=
StyleClear
:
:
None
;
mInlineBreak
=
InlineBreak
:
:
None
;
mCompletion
=
Completion
:
:
FullyComplete
;
mNextInFlowNeedsReflow
=
false
;
mTruncated
=
false
;
mFirstLetterComplete
=
false
;
}
bool
IsEmpty
(
)
const
{
return
(
IsFullyComplete
(
)
&
&
!
IsInlineBreak
(
)
&
&
!
mNextInFlowNeedsReflow
&
&
!
mTruncated
&
&
!
mFirstLetterComplete
)
;
}
enum
class
Completion
:
uint8_t
{
FullyComplete
OverflowIncomplete
Incomplete
}
;
bool
IsIncomplete
(
)
const
{
return
mCompletion
=
=
Completion
:
:
Incomplete
;
}
bool
IsOverflowIncomplete
(
)
const
{
return
mCompletion
=
=
Completion
:
:
OverflowIncomplete
;
}
bool
IsFullyComplete
(
)
const
{
return
mCompletion
=
=
Completion
:
:
FullyComplete
;
}
bool
IsComplete
(
)
const
{
return
!
IsIncomplete
(
)
;
}
void
SetIncomplete
(
)
{
mCompletion
=
Completion
:
:
Incomplete
;
}
void
SetOverflowIncomplete
(
)
{
mCompletion
=
Completion
:
:
OverflowIncomplete
;
}
bool
NextInFlowNeedsReflow
(
)
const
{
return
mNextInFlowNeedsReflow
;
}
void
SetNextInFlowNeedsReflow
(
)
{
mNextInFlowNeedsReflow
=
true
;
}
bool
IsTruncated
(
)
const
{
return
mTruncated
;
}
void
UpdateTruncated
(
const
mozilla
:
:
ReflowInput
&
aReflowInput
const
mozilla
:
:
ReflowOutput
&
aMetrics
)
;
void
MergeCompletionStatusFrom
(
const
nsReflowStatus
&
aStatus
)
{
if
(
mCompletion
<
aStatus
.
mCompletion
)
{
mCompletion
=
aStatus
.
mCompletion
;
}
static_assert
(
Completion
:
:
Incomplete
>
Completion
:
:
OverflowIncomplete
&
&
Completion
:
:
OverflowIncomplete
>
Completion
:
:
FullyComplete
"
mCompletion
merging
won
'
t
work
without
this
!
"
)
;
mNextInFlowNeedsReflow
|
=
aStatus
.
mNextInFlowNeedsReflow
;
mTruncated
|
=
aStatus
.
mTruncated
;
}
enum
class
InlineBreak
:
uint8_t
{
None
Before
After
}
;
bool
IsInlineBreak
(
)
const
{
return
mInlineBreak
!
=
InlineBreak
:
:
None
;
}
bool
IsInlineBreakBefore
(
)
const
{
return
mInlineBreak
=
=
InlineBreak
:
:
Before
;
}
bool
IsInlineBreakAfter
(
)
const
{
return
mInlineBreak
=
=
InlineBreak
:
:
After
;
}
StyleClear
BreakType
(
)
const
{
return
mBreakType
;
}
void
SetInlineLineBreakBeforeAndReset
(
)
{
Reset
(
)
;
mBreakType
=
StyleClear
:
:
Line
;
mInlineBreak
=
InlineBreak
:
:
Before
;
}
void
SetInlineLineBreakAfter
(
StyleClear
aBreakType
=
StyleClear
:
:
Line
)
{
MOZ_ASSERT
(
aBreakType
!
=
StyleClear
:
:
None
"
Break
-
after
with
StyleClear
:
:
None
is
meaningless
!
"
)
;
mBreakType
=
aBreakType
;
mInlineBreak
=
InlineBreak
:
:
After
;
}
bool
FirstLetterComplete
(
)
const
{
return
mFirstLetterComplete
;
}
void
SetFirstLetterComplete
(
)
{
mFirstLetterComplete
=
true
;
}
private
:
StyleClear
mBreakType
;
InlineBreak
mInlineBreak
;
Completion
mCompletion
;
bool
mNextInFlowNeedsReflow
:
1
;
bool
mTruncated
:
1
;
bool
mFirstLetterComplete
:
1
;
}
;
#
define
NS_FRAME_SET_TRUNCATION
(
aStatus
aReflowInput
aMetrics
)
\
aStatus
.
UpdateTruncated
(
aReflowInput
aMetrics
)
;
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
nsReflowStatus
&
aStatus
)
;
#
define
NS_FRAME_OVERFLOW_DELTA_MAX
0xfe
#
define
NS_FRAME_OVERFLOW_NONE
0x00000000
#
define
NS_FRAME_OVERFLOW_LARGE
0x000000ff
typedef
uint8_t
nsBidiLevel
;
#
define
NSBIDI_DEFAULT_LTR
0xfe
#
define
NSBIDI_DEFAULT_RTL
0xff
#
define
NSBIDI_MAX_EXPLICIT_LEVEL
125
#
define
NSBIDI_LEVEL_OVERRIDE
0x80
enum
nsBidiDirection
{
NSBIDI_LTR
NSBIDI_RTL
NSBIDI_MIXED
}
;
namespace
mozilla
{
enum
class
BaselineSharingGroup
{
First
=
0
Last
=
1
}
;
enum
class
AlignmentContext
{
Inline
Table
Flexbox
Grid
}
;
struct
IntrinsicSize
{
Maybe
<
nscoord
>
width
;
Maybe
<
nscoord
>
height
;
IntrinsicSize
(
)
=
default
;
IntrinsicSize
(
nscoord
aWidth
nscoord
aHeight
)
:
width
(
Some
(
aWidth
)
)
height
(
Some
(
aHeight
)
)
{
}
bool
operator
=
=
(
const
IntrinsicSize
&
rhs
)
{
return
width
=
=
rhs
.
width
&
&
height
=
=
rhs
.
height
;
}
bool
operator
!
=
(
const
IntrinsicSize
&
rhs
)
{
return
!
(
*
this
=
=
rhs
)
;
}
}
;
static
const
nsBidiLevel
kBidiLevelNone
=
0xff
;
struct
FrameBidiData
{
nsBidiLevel
baseLevel
;
nsBidiLevel
embeddingLevel
;
nsBidiLevel
precedingControl
;
}
;
}
template
<
typename
T
>
static
void
DeleteValue
(
T
*
aPropertyValue
)
{
delete
aPropertyValue
;
}
template
<
typename
T
>
static
void
ReleaseValue
(
T
*
aPropertyValue
)
{
aPropertyValue
-
>
Release
(
)
;
}
class
nsIFrame
:
public
nsQueryFrame
{
public
:
using
AlignmentContext
=
mozilla
:
:
AlignmentContext
;
using
BaselineSharingGroup
=
mozilla
:
:
BaselineSharingGroup
;
template
<
typename
T
>
using
Maybe
=
mozilla
:
:
Maybe
<
T
>
;
using
Nothing
=
mozilla
:
:
Nothing
;
using
OnNonvisible
=
mozilla
:
:
OnNonvisible
;
template
<
typename
T
=
void
>
using
PropertyDescriptor
=
const
mozilla
:
:
FramePropertyDescriptor
<
T
>
*
;
using
ReflowInput
=
mozilla
:
:
ReflowInput
;
using
ReflowOutput
=
mozilla
:
:
ReflowOutput
;
using
Visibility
=
mozilla
:
:
Visibility
;
using
StyleFlexBasis
=
mozilla
:
:
StyleFlexBasis
;
using
StyleSize
=
mozilla
:
:
StyleSize
;
using
LengthPercentage
=
mozilla
:
:
LengthPercentage
;
using
StyleExtremumLength
=
mozilla
:
:
StyleExtremumLength
;
typedef
mozilla
:
:
ComputedStyle
ComputedStyle
;
typedef
mozilla
:
:
FrameProperties
FrameProperties
;
typedef
mozilla
:
:
layers
:
:
Layer
Layer
;
typedef
mozilla
:
:
layers
:
:
LayerManager
LayerManager
;
typedef
mozilla
:
:
layout
:
:
FrameChildList
ChildList
;
typedef
mozilla
:
:
layout
:
:
FrameChildListID
ChildListID
;
typedef
mozilla
:
:
layout
:
:
FrameChildListIDs
ChildListIDs
;
typedef
mozilla
:
:
layout
:
:
FrameChildListIterator
ChildListIterator
;
typedef
mozilla
:
:
layout
:
:
FrameChildListArrayIterator
ChildListArrayIterator
;
typedef
mozilla
:
:
gfx
:
:
DrawTarget
DrawTarget
;
typedef
mozilla
:
:
gfx
:
:
Matrix
Matrix
;
typedef
mozilla
:
:
gfx
:
:
Matrix4x4
Matrix4x4
;
typedef
mozilla
:
:
gfx
:
:
Matrix4x4Flagged
Matrix4x4Flagged
;
typedef
mozilla
:
:
Sides
Sides
;
typedef
mozilla
:
:
LogicalSides
LogicalSides
;
typedef
mozilla
:
:
SmallPointerArray
<
mozilla
:
:
DisplayItemData
>
DisplayItemDataArray
;
typedef
nsQueryFrame
:
:
ClassID
ClassID
;
NS_DECL_QUERYFRAME_TARGET
(
nsIFrame
)
explicit
nsIFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
ClassID
aID
)
:
mRect
(
)
mContent
(
nullptr
)
mComputedStyle
(
aStyle
)
mPresContext
(
aPresContext
)
mParent
(
nullptr
)
mNextSibling
(
nullptr
)
mPrevSibling
(
nullptr
)
mState
(
NS_FRAME_FIRST_REFLOW
|
NS_FRAME_IS_DIRTY
)
mWritingMode
(
aStyle
)
mClass
(
aID
)
mMayHaveRoundedCorners
(
false
)
mHasImageRequest
(
false
)
mHasFirstLetterChild
(
false
)
mParentIsWrapperAnonBox
(
false
)
mIsWrapperBoxNeedingRestyle
(
false
)
mReflowRequestedForCharDataChange
(
false
)
mForceDescendIntoIfVisible
(
false
)
mBuiltDisplayList
(
false
)
mFrameIsModified
(
false
)
mHasOverrideDirtyRegion
(
false
)
mMayHaveWillChangeBudget
(
false
)
mIsPrimaryFrame
(
false
)
mMayHaveTransformAnimation
(
false
)
mMayHaveOpacityAnimation
(
false
)
mAllDescendantsAreInvisible
(
false
)
mInScrollAnchorChain
(
false
)
{
MOZ_ASSERT
(
mComputedStyle
)
;
MOZ_ASSERT
(
mPresContext
)
;
mozilla
:
:
PodZero
(
&
mOverflow
)
;
}
nsPresContext
*
PresContext
(
)
const
{
return
mPresContext
;
}
mozilla
:
:
PresShell
*
PresShell
(
)
const
{
return
PresContext
(
)
-
>
PresShell
(
)
;
}
virtual
void
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
=
0
;
using
PostDestroyData
=
mozilla
:
:
layout
:
:
PostFrameDestroyData
;
struct
MOZ_RAII
AutoPostDestroyData
{
explicit
AutoPostDestroyData
(
nsPresContext
*
aPresContext
)
:
mPresContext
(
aPresContext
)
{
}
~
AutoPostDestroyData
(
)
{
for
(
auto
&
content
:
mozilla
:
:
Reversed
(
mData
.
mAnonymousContent
)
)
{
nsIFrame
:
:
DestroyAnonymousContent
(
mPresContext
content
.
forget
(
)
)
;
}
}
nsPresContext
*
mPresContext
;
PostDestroyData
mData
;
}
;
void
Destroy
(
)
{
AutoPostDestroyData
data
(
PresContext
(
)
)
;
DestroyFrom
(
this
data
.
mData
)
;
}
enum
FrameSearchResult
{
FOUND
=
0x00
CONTINUE
=
0x1
CONTINUE_EMPTY
=
0x2
|
CONTINUE
CONTINUE_UNSELECTABLE
=
0x4
|
CONTINUE
}
;
struct
MOZ_STACK_CLASS
PeekOffsetCharacterOptions
{
bool
mRespectClusters
;
bool
mIgnoreUserStyleAll
;
PeekOffsetCharacterOptions
(
)
:
mRespectClusters
(
true
)
mIgnoreUserStyleAll
(
false
)
{
}
}
;
protected
:
friend
class
nsBlockFrame
;
virtual
bool
IsFrameSelected
(
)
const
;
virtual
void
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
=
0
;
friend
class
nsFrameList
;
friend
class
nsLineBox
;
friend
class
nsContainerFrame
;
friend
class
nsFrame
;
template
<
class
Source
>
friend
class
do_QueryFrameHelper
;
public
:
nsIContent
*
GetContent
(
)
const
{
return
mContent
;
}
virtual
nsContainerFrame
*
GetContentInsertionFrame
(
)
{
return
nullptr
;
}
virtual
bool
DrainSelfOverflowList
(
)
{
return
false
;
}
virtual
nsIScrollableFrame
*
GetScrollTargetFrame
(
)
{
return
nullptr
;
}
virtual
nsresult
GetOffsets
(
int32_t
&
start
int32_t
&
end
)
const
=
0
;
virtual
void
AdjustOffsetsForBidi
(
int32_t
aStart
int32_t
aEnd
)
{
}
ComputedStyle
*
Style
(
)
const
{
return
mComputedStyle
;
}
void
AssertNewStyleIsSane
(
ComputedStyle
&
)
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
;
#
else
{
}
#
endif
void
SetComputedStyle
(
ComputedStyle
*
aStyle
)
{
if
(
aStyle
!
=
mComputedStyle
)
{
AssertNewStyleIsSane
(
*
aStyle
)
;
RefPtr
<
ComputedStyle
>
oldComputedStyle
=
mComputedStyle
.
forget
(
)
;
mComputedStyle
=
aStyle
;
DidSetComputedStyle
(
oldComputedStyle
)
;
}
}
void
SetComputedStyleWithoutNotification
(
ComputedStyle
*
aStyle
)
{
if
(
aStyle
!
=
mComputedStyle
)
{
mComputedStyle
=
aStyle
;
}
}
virtual
void
DidSetComputedStyle
(
ComputedStyle
*
aOldComputedStyle
)
=
0
;
#
define
STYLE_STRUCT
(
name_
)
\
const
nsStyle
#
#
name_
*
Style
#
#
name_
(
)
const
MOZ_NONNULL_RETURN
{
\
NS_ASSERTION
(
mComputedStyle
"
No
style
found
!
"
)
;
\
return
mComputedStyle
-
>
Style
#
#
name_
(
)
;
\
}
\
const
nsStyle
#
#
name_
*
Style
#
#
name_
#
#
WithOptionalParam
(
\
const
nsStyle
#
#
name_
*
aStyleStruct
)
const
MOZ_NONNULL_RETURN
{
\
if
(
aStyleStruct
)
{
\
MOZ_ASSERT
(
aStyleStruct
=
=
Style
#
#
name_
(
)
)
;
\
return
aStyleStruct
;
\
}
\
return
Style
#
#
name_
(
)
;
\
}
#
include
"
nsStyleStructList
.
h
"
#
undef
STYLE_STRUCT
template
<
typename
T
typename
S
>
nscolor
GetVisitedDependentColor
(
T
S
:
:
*
aField
)
{
return
mComputedStyle
-
>
GetVisitedDependentColor
(
aField
)
;
}
virtual
ComputedStyle
*
GetAdditionalComputedStyle
(
int32_t
aIndex
)
const
=
0
;
virtual
void
SetAdditionalComputedStyle
(
int32_t
aIndex
ComputedStyle
*
aComputedStyle
)
=
0
;
already_AddRefed
<
ComputedStyle
>
ComputeSelectionStyle
(
int16_t
aSelectionStatus
)
const
;
nsContainerFrame
*
GetParent
(
)
const
{
return
mParent
;
}
inline
nsContainerFrame
*
GetInFlowParent
(
)
const
;
inline
nsIFrame
*
GetClosestFlattenedTreeAncestorPrimaryFrame
(
)
const
;
inline
nsPlaceholderFrame
*
GetPlaceholderFrame
(
)
const
{
MOZ_ASSERT
(
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
)
;
return
GetProperty
(
PlaceholderFrameProperty
(
)
)
;
}
void
SetParent
(
nsContainerFrame
*
aParent
)
;
mozilla
:
:
WritingMode
GetWritingMode
(
)
const
{
return
mWritingMode
;
}
mozilla
:
:
WritingMode
WritingModeForLine
(
mozilla
:
:
WritingMode
aSelfWM
nsIFrame
*
aSubFrame
)
const
;
nsRect
GetRect
(
)
const
{
return
mRect
;
}
nsPoint
GetPosition
(
)
const
{
return
mRect
.
TopLeft
(
)
;
}
nsSize
GetSize
(
)
const
{
return
mRect
.
Size
(
)
;
}
nsRect
GetRectRelativeToSelf
(
)
const
{
return
nsRect
(
nsPoint
(
0
0
)
mRect
.
Size
(
)
)
;
}
mozilla
:
:
LogicalRect
GetLogicalRect
(
const
nsSize
&
aContainerSize
)
const
{
return
GetLogicalRect
(
GetWritingMode
(
)
aContainerSize
)
;
}
mozilla
:
:
LogicalPoint
GetLogicalPosition
(
const
nsSize
&
aContainerSize
)
const
{
return
GetLogicalPosition
(
GetWritingMode
(
)
aContainerSize
)
;
}
mozilla
:
:
LogicalSize
GetLogicalSize
(
)
const
{
return
GetLogicalSize
(
GetWritingMode
(
)
)
;
}
mozilla
:
:
LogicalRect
GetLogicalRect
(
mozilla
:
:
WritingMode
aWritingMode
const
nsSize
&
aContainerSize
)
const
{
return
mozilla
:
:
LogicalRect
(
aWritingMode
GetRect
(
)
aContainerSize
)
;
}
mozilla
:
:
LogicalPoint
GetLogicalPosition
(
mozilla
:
:
WritingMode
aWritingMode
const
nsSize
&
aContainerSize
)
const
{
return
GetLogicalRect
(
aWritingMode
aContainerSize
)
.
Origin
(
aWritingMode
)
;
}
mozilla
:
:
LogicalSize
GetLogicalSize
(
mozilla
:
:
WritingMode
aWritingMode
)
const
{
return
mozilla
:
:
LogicalSize
(
aWritingMode
GetSize
(
)
)
;
}
nscoord
IStart
(
const
nsSize
&
aContainerSize
)
const
{
return
IStart
(
GetWritingMode
(
)
aContainerSize
)
;
}
nscoord
IStart
(
mozilla
:
:
WritingMode
aWritingMode
const
nsSize
&
aContainerSize
)
const
{
return
GetLogicalPosition
(
aWritingMode
aContainerSize
)
.
I
(
aWritingMode
)
;
}
nscoord
BStart
(
const
nsSize
&
aContainerSize
)
const
{
return
BStart
(
GetWritingMode
(
)
aContainerSize
)
;
}
nscoord
BStart
(
mozilla
:
:
WritingMode
aWritingMode
const
nsSize
&
aContainerSize
)
const
{
return
GetLogicalPosition
(
aWritingMode
aContainerSize
)
.
B
(
aWritingMode
)
;
}
nscoord
ISize
(
)
const
{
return
ISize
(
GetWritingMode
(
)
)
;
}
nscoord
ISize
(
mozilla
:
:
WritingMode
aWritingMode
)
const
{
return
GetLogicalSize
(
aWritingMode
)
.
ISize
(
aWritingMode
)
;
}
nscoord
BSize
(
)
const
{
return
BSize
(
GetWritingMode
(
)
)
;
}
nscoord
BSize
(
mozilla
:
:
WritingMode
aWritingMode
)
const
{
return
GetLogicalSize
(
aWritingMode
)
.
BSize
(
aWritingMode
)
;
}
nscoord
ContentBSize
(
)
const
{
return
ContentBSize
(
GetWritingMode
(
)
)
;
}
nscoord
ContentBSize
(
mozilla
:
:
WritingMode
aWritingMode
)
const
{
auto
bp
=
GetLogicalUsedBorderAndPadding
(
aWritingMode
)
;
bp
.
ApplySkipSides
(
GetLogicalSkipSides
(
)
)
;
return
std
:
:
max
(
0
BSize
(
aWritingMode
)
-
bp
.
BStartEnd
(
aWritingMode
)
)
;
}
void
SetRect
(
const
nsRect
&
aRect
bool
aRebuildDisplayItems
=
true
)
{
if
(
aRect
=
=
mRect
)
{
return
;
}
if
(
mOverflow
.
mType
!
=
NS_FRAME_OVERFLOW_LARGE
&
&
mOverflow
.
mType
!
=
NS_FRAME_OVERFLOW_NONE
)
{
nsOverflowAreas
overflow
=
GetOverflowAreas
(
)
;
mRect
=
aRect
;
SetOverflowAreas
(
overflow
)
;
}
else
{
mRect
=
aRect
;
}
if
(
aRebuildDisplayItems
)
{
MarkNeedsDisplayItemRebuild
(
)
;
}
}
void
SetRect
(
const
mozilla
:
:
LogicalRect
&
aRect
const
nsSize
&
aContainerSize
)
{
SetRect
(
GetWritingMode
(
)
aRect
aContainerSize
)
;
}
void
SetRect
(
mozilla
:
:
WritingMode
aWritingMode
const
mozilla
:
:
LogicalRect
&
aRect
const
nsSize
&
aContainerSize
)
{
SetRect
(
aRect
.
GetPhysicalRect
(
aWritingMode
aContainerSize
)
)
;
}
void
SetSize
(
const
mozilla
:
:
LogicalSize
&
aSize
)
{
SetSize
(
GetWritingMode
(
)
aSize
)
;
}
void
SetSize
(
mozilla
:
:
WritingMode
aWritingMode
const
mozilla
:
:
LogicalSize
&
aSize
)
{
if
(
(
!
aWritingMode
.
IsVertical
(
)
&
&
!
aWritingMode
.
IsBidiLTR
(
)
)
|
|
aWritingMode
.
IsVerticalRL
(
)
)
{
nscoord
oldWidth
=
mRect
.
Width
(
)
;
SetSize
(
aSize
.
GetPhysicalSize
(
aWritingMode
)
)
;
mRect
.
x
-
=
mRect
.
Width
(
)
-
oldWidth
;
}
else
{
SetSize
(
aSize
.
GetPhysicalSize
(
aWritingMode
)
)
;
}
}
void
SetSize
(
const
nsSize
&
aSize
bool
aRebuildDisplayItems
=
true
)
{
SetRect
(
nsRect
(
mRect
.
TopLeft
(
)
aSize
)
aRebuildDisplayItems
)
;
}
void
SetPosition
(
const
nsPoint
&
aPt
)
{
if
(
mRect
.
TopLeft
(
)
=
=
aPt
)
{
return
;
}
mRect
.
MoveTo
(
aPt
)
;
MarkNeedsDisplayItemRebuild
(
)
;
}
void
SetPosition
(
mozilla
:
:
WritingMode
aWritingMode
const
mozilla
:
:
LogicalPoint
&
aPt
const
nsSize
&
aContainerSize
)
{
SetPosition
(
aPt
.
GetPhysicalPoint
(
aWritingMode
aContainerSize
-
mRect
.
Size
(
)
)
)
;
}
void
MovePositionBy
(
const
nsPoint
&
aTranslation
)
;
void
MovePositionBy
(
mozilla
:
:
WritingMode
aWritingMode
const
mozilla
:
:
LogicalPoint
&
aTranslation
)
{
const
nsSize
nullContainerSize
;
MovePositionBy
(
aTranslation
.
GetPhysicalPoint
(
aWritingMode
nullContainerSize
)
)
;
}
nsRect
GetNormalRect
(
)
const
;
inline
nsPoint
GetNormalPosition
(
bool
*
aHasProperty
=
nullptr
)
const
;
mozilla
:
:
LogicalPoint
GetLogicalNormalPosition
(
mozilla
:
:
WritingMode
aWritingMode
const
nsSize
&
aContainerSize
)
const
{
return
mozilla
:
:
LogicalPoint
(
aWritingMode
GetNormalPosition
(
)
aContainerSize
-
mRect
.
Size
(
)
)
;
}
virtual
nsPoint
GetPositionOfChildIgnoringScrolling
(
const
nsIFrame
*
aChild
)
{
return
aChild
-
>
GetPosition
(
)
;
}
nsPoint
GetPositionIgnoringScrolling
(
)
const
;
typedef
AutoTArray
<
nsDisplayItemBase
*
4
>
DisplayItemArray
;
#
define
NS_DECLARE_FRAME_PROPERTY_WITH_DTOR
(
prop
type
dtor
)
\
static
const
mozilla
:
:
FramePropertyDescriptor
<
type
>
*
prop
(
)
{
\
/
*
Use
of
constexpr
caused
startup
crashes
with
MSVC2015u1
PGO
.
*
/
\
static
const
auto
descriptor
=
\
mozilla
:
:
FramePropertyDescriptor
<
type
>
:
:
NewWithDestructor
<
dtor
>
(
)
;
\
return
&
descriptor
;
\
}
#
define
NS_DECLARE_FRAME_PROPERTY_WITH_FRAME_IN_DTOR
(
prop
type
dtor
)
\
static
const
mozilla
:
:
FramePropertyDescriptor
<
type
>
*
prop
(
)
{
\
/
*
Use
of
constexpr
caused
startup
crashes
with
MSVC2015u1
PGO
.
*
/
\
static
const
auto
descriptor
=
mozilla
:
:
FramePropertyDescriptor
<
\
type
>
:
:
NewWithDestructorWithFrame
<
dtor
>
(
)
;
\
return
&
descriptor
;
\
}
#
define
NS_DECLARE_FRAME_PROPERTY_WITHOUT_DTOR
(
prop
type
)
\
static
const
mozilla
:
:
FramePropertyDescriptor
<
type
>
*
prop
(
)
{
\
/
*
Use
of
constexpr
caused
startup
crashes
with
MSVC2015u1
PGO
.
*
/
\
static
const
auto
descriptor
=
\
mozilla
:
:
FramePropertyDescriptor
<
type
>
:
:
NewWithoutDestructor
(
)
;
\
return
&
descriptor
;
\
}
#
define
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
prop
type
)
\
NS_DECLARE_FRAME_PROPERTY_WITH_DTOR
(
prop
type
DeleteValue
)
#
define
NS_DECLARE_FRAME_PROPERTY_RELEASABLE
(
prop
type
)
\
NS_DECLARE_FRAME_PROPERTY_WITH_DTOR
(
prop
type
ReleaseValue
)
#
define
NS_DECLARE_FRAME_PROPERTY_WITH_DTOR_NEVER_CALLED
(
prop
type
)
\
static
void
AssertOnDestroyingProperty
#
#
prop
(
type
*
)
{
\
MOZ_ASSERT_UNREACHABLE
(
\
"
Frame
property
"
#
prop
\
"
should
never
be
destroyed
by
the
FrameProperties
class
"
)
;
\
}
\
NS_DECLARE_FRAME_PROPERTY_WITH_DTOR
(
prop
type
\
AssertOnDestroyingProperty
#
#
prop
)
#
define
NS_DECLARE_FRAME_PROPERTY_SMALL_VALUE
(
prop
type
)
\
NS_DECLARE_FRAME_PROPERTY_WITHOUT_DTOR
(
prop
mozilla
:
:
SmallValueHolder
<
type
>
)
NS_DECLARE_FRAME_PROPERTY_WITHOUT_DTOR
(
IBSplitSibling
nsContainerFrame
)
NS_DECLARE_FRAME_PROPERTY_WITHOUT_DTOR
(
IBSplitPrevSibling
nsContainerFrame
)
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
NormalPositionProperty
nsPoint
)
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
ComputedOffsetProperty
nsMargin
)
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
OutlineInnerRectProperty
nsRect
)
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
PreEffectsBBoxProperty
nsRect
)
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
PreTransformOverflowAreasProperty
nsOverflowAreas
)
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
OverflowAreasProperty
nsOverflowAreas
)
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
InitialOverflowProperty
nsOverflowAreas
)
#
ifdef
DEBUG
NS_DECLARE_FRAME_PROPERTY_SMALL_VALUE
(
DebugInitialOverflowPropertyApplied
bool
)
#
endif
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
UsedMarginProperty
nsMargin
)
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
UsedPaddingProperty
nsMargin
)
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
UsedBorderProperty
nsMargin
)
NS_DECLARE_FRAME_PROPERTY_SMALL_VALUE
(
LineBaselineOffset
nscoord
)
NS_DECLARE_FRAME_PROPERTY_SMALL_VALUE
(
FlexItemMainSizeOverride
nscoord
)
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
InvalidationRect
nsRect
)
NS_DECLARE_FRAME_PROPERTY_SMALL_VALUE
(
RefusedAsyncAnimationProperty
bool
)
NS_DECLARE_FRAME_PROPERTY_SMALL_VALUE
(
FragStretchBSizeProperty
nscoord
)
NS_DECLARE_FRAME_PROPERTY_SMALL_VALUE
(
BClampMarginBoxMinSizeProperty
nscoord
)
NS_DECLARE_FRAME_PROPERTY_SMALL_VALUE
(
IBaselinePadProperty
nscoord
)
NS_DECLARE_FRAME_PROPERTY_SMALL_VALUE
(
BBaselinePadProperty
nscoord
)
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
DisplayItems
DisplayItemArray
)
NS_DECLARE_FRAME_PROPERTY_SMALL_VALUE
(
BidiDataProperty
mozilla
:
:
FrameBidiData
)
NS_DECLARE_FRAME_PROPERTY_WITHOUT_DTOR
(
PlaceholderFrameProperty
nsPlaceholderFrame
)
NS_DECLARE_FRAME_PROPERTY_SMALL_VALUE
(
HasColumnSpanSiblings
bool
)
mozilla
:
:
FrameBidiData
GetBidiData
(
)
const
{
bool
exists
;
mozilla
:
:
FrameBidiData
bidiData
=
GetProperty
(
BidiDataProperty
(
)
&
exists
)
;
if
(
!
exists
)
{
bidiData
.
precedingControl
=
mozilla
:
:
kBidiLevelNone
;
}
return
bidiData
;
}
nsBidiLevel
GetBaseLevel
(
)
const
{
return
GetBidiData
(
)
.
baseLevel
;
}
nsBidiLevel
GetEmbeddingLevel
(
)
const
{
return
GetBidiData
(
)
.
embeddingLevel
;
}
virtual
nsMargin
GetUsedMargin
(
)
const
;
virtual
mozilla
:
:
LogicalMargin
GetLogicalUsedMargin
(
mozilla
:
:
WritingMode
aWritingMode
)
const
{
return
mozilla
:
:
LogicalMargin
(
aWritingMode
GetUsedMargin
(
)
)
;
}
virtual
nsMargin
GetUsedBorder
(
)
const
;
virtual
mozilla
:
:
LogicalMargin
GetLogicalUsedBorder
(
mozilla
:
:
WritingMode
aWritingMode
)
const
{
return
mozilla
:
:
LogicalMargin
(
aWritingMode
GetUsedBorder
(
)
)
;
}
virtual
nsMargin
GetUsedPadding
(
)
const
;
virtual
mozilla
:
:
LogicalMargin
GetLogicalUsedPadding
(
mozilla
:
:
WritingMode
aWritingMode
)
const
{
return
mozilla
:
:
LogicalMargin
(
aWritingMode
GetUsedPadding
(
)
)
;
}
nsMargin
GetUsedBorderAndPadding
(
)
const
{
return
GetUsedBorder
(
)
+
GetUsedPadding
(
)
;
}
mozilla
:
:
LogicalMargin
GetLogicalUsedBorderAndPadding
(
mozilla
:
:
WritingMode
aWritingMode
)
const
{
return
mozilla
:
:
LogicalMargin
(
aWritingMode
GetUsedBorderAndPadding
(
)
)
;
}
nsRect
GetPaddingRect
(
)
const
;
nsRect
GetPaddingRectRelativeToSelf
(
)
const
;
nsRect
GetContentRect
(
)
const
;
nsRect
GetContentRectRelativeToSelf
(
)
const
;
nsRect
GetMarginRectRelativeToSelf
(
)
const
;
virtual
nsRect
VisualBorderRectRelativeToSelf
(
)
const
{
return
nsRect
(
0
0
mRect
.
Width
(
)
mRect
.
Height
(
)
)
;
}
static
bool
ComputeBorderRadii
(
const
mozilla
:
:
BorderRadius
&
const
nsSize
&
aFrameSize
const
nsSize
&
aBorderArea
Sides
aSkipSides
nscoord
aRadii
[
8
]
)
;
static
void
InsetBorderRadii
(
nscoord
aRadii
[
8
]
const
nsMargin
&
aOffsets
)
;
static
void
OutsetBorderRadii
(
nscoord
aRadii
[
8
]
const
nsMargin
&
aOffsets
)
;
virtual
bool
GetBorderRadii
(
const
nsSize
&
aFrameSize
const
nsSize
&
aBorderArea
Sides
aSkipSides
nscoord
aRadii
[
8
]
)
const
;
bool
GetBorderRadii
(
nscoord
aRadii
[
8
]
)
const
;
bool
GetMarginBoxBorderRadii
(
nscoord
aRadii
[
8
]
)
const
;
bool
GetPaddingBoxBorderRadii
(
nscoord
aRadii
[
8
]
)
const
;
bool
GetContentBoxBorderRadii
(
nscoord
aRadii
[
8
]
)
const
;
bool
GetBoxBorderRadii
(
nscoord
aRadii
[
8
]
nsMargin
aOffset
bool
aIsOutset
)
const
;
bool
GetShapeBoxBorderRadii
(
nscoord
aRadii
[
8
]
)
const
;
virtual
nscoord
GetLogicalBaseline
(
mozilla
:
:
WritingMode
aWM
)
const
=
0
;
inline
nscoord
SynthesizeBaselineBOffsetFromMarginBox
(
mozilla
:
:
WritingMode
aWM
BaselineSharingGroup
aGroup
)
const
;
inline
nscoord
SynthesizeBaselineBOffsetFromBorderBox
(
mozilla
:
:
WritingMode
aWM
BaselineSharingGroup
aGroup
)
const
;
inline
nscoord
BaselineBOffset
(
mozilla
:
:
WritingMode
aWM
BaselineSharingGroup
aBaselineGroup
AlignmentContext
aAlignmentContext
)
const
;
virtual
bool
GetVerticalAlignBaseline
(
mozilla
:
:
WritingMode
aWM
nscoord
*
aBaseline
)
const
{
return
false
;
}
virtual
bool
GetNaturalBaselineBOffset
(
mozilla
:
:
WritingMode
aWM
BaselineSharingGroup
aBaselineGroup
nscoord
*
aBaseline
)
const
{
return
false
;
}
virtual
nscoord
GetCaretBaseline
(
)
const
{
return
GetLogicalBaseline
(
GetWritingMode
(
)
)
;
}
bool
TrackingVisibility
(
)
const
{
return
bool
(
GetStateBits
(
)
&
NS_FRAME_VISIBILITY_IS_TRACKED
)
;
}
Visibility
GetVisibility
(
)
const
;
void
UpdateVisibilitySynchronously
(
)
;
NS_DECLARE_FRAME_PROPERTY_SMALL_VALUE
(
VisibilityStateProperty
uint32_t
)
;
protected
:
void
EnableVisibilityTracking
(
)
;
void
DisableVisibilityTracking
(
)
;
virtual
void
OnVisibilityChange
(
Visibility
aNewVisibility
const
Maybe
<
OnNonvisible
>
&
aNonvisibleAction
=
Nothing
(
)
)
;
public
:
void
DecApproximateVisibleCount
(
const
Maybe
<
OnNonvisible
>
&
aNonvisibleAction
=
Nothing
(
)
)
;
void
IncApproximateVisibleCount
(
)
;
virtual
const
nsFrameList
&
GetChildList
(
ChildListID
aListID
)
const
=
0
;
const
nsFrameList
&
PrincipalChildList
(
)
const
{
return
GetChildList
(
kPrincipalList
)
;
}
virtual
void
GetChildLists
(
nsTArray
<
ChildList
>
*
aLists
)
const
=
0
;
void
GetCrossDocChildLists
(
nsTArray
<
ChildList
>
*
aLists
)
;
static
const
ChildListID
kPrincipalList
=
mozilla
:
:
layout
:
:
kPrincipalList
;
static
const
ChildListID
kAbsoluteList
=
mozilla
:
:
layout
:
:
kAbsoluteList
;
static
const
ChildListID
kBulletList
=
mozilla
:
:
layout
:
:
kBulletList
;
static
const
ChildListID
kCaptionList
=
mozilla
:
:
layout
:
:
kCaptionList
;
static
const
ChildListID
kColGroupList
=
mozilla
:
:
layout
:
:
kColGroupList
;
static
const
ChildListID
kExcessOverflowContainersList
=
mozilla
:
:
layout
:
:
kExcessOverflowContainersList
;
static
const
ChildListID
kFixedList
=
mozilla
:
:
layout
:
:
kFixedList
;
static
const
ChildListID
kFloatList
=
mozilla
:
:
layout
:
:
kFloatList
;
static
const
ChildListID
kOverflowContainersList
=
mozilla
:
:
layout
:
:
kOverflowContainersList
;
static
const
ChildListID
kOverflowList
=
mozilla
:
:
layout
:
:
kOverflowList
;
static
const
ChildListID
kOverflowOutOfFlowList
=
mozilla
:
:
layout
:
:
kOverflowOutOfFlowList
;
static
const
ChildListID
kPopupList
=
mozilla
:
:
layout
:
:
kPopupList
;
static
const
ChildListID
kPushedFloatsList
=
mozilla
:
:
layout
:
:
kPushedFloatsList
;
static
const
ChildListID
kSelectPopupList
=
mozilla
:
:
layout
:
:
kSelectPopupList
;
static
const
ChildListID
kBackdropList
=
mozilla
:
:
layout
:
:
kBackdropList
;
static
const
ChildListID
kNoReflowPrincipalList
=
mozilla
:
:
layout
:
:
kNoReflowPrincipalList
;
nsIFrame
*
GetNextSibling
(
)
const
{
return
mNextSibling
;
}
void
SetNextSibling
(
nsIFrame
*
aNextSibling
)
{
NS_ASSERTION
(
this
!
=
aNextSibling
"
Creating
a
circular
frame
list
this
is
very
bad
.
"
)
;
if
(
mNextSibling
&
&
mNextSibling
-
>
GetPrevSibling
(
)
=
=
this
)
{
mNextSibling
-
>
mPrevSibling
=
nullptr
;
}
mNextSibling
=
aNextSibling
;
if
(
mNextSibling
)
{
mNextSibling
-
>
mPrevSibling
=
this
;
}
}
nsIFrame
*
GetPrevSibling
(
)
const
{
return
mPrevSibling
;
}
virtual
void
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
}
void
DisplayCaret
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
)
;
virtual
nscolor
GetCaretColorAt
(
int32_t
aOffset
)
;
bool
IsThemed
(
nsITheme
:
:
Transparency
*
aTransparencyState
=
nullptr
)
const
{
return
IsThemed
(
StyleDisplay
(
)
aTransparencyState
)
;
}
bool
IsThemed
(
const
nsStyleDisplay
*
aDisp
nsITheme
:
:
Transparency
*
aTransparencyState
=
nullptr
)
const
{
if
(
!
aDisp
-
>
HasAppearance
(
)
)
{
return
false
;
}
nsIFrame
*
mutable_this
=
const_cast
<
nsIFrame
*
>
(
this
)
;
nsPresContext
*
pc
=
PresContext
(
)
;
nsITheme
*
theme
=
pc
-
>
GetTheme
(
)
;
if
(
!
theme
|
|
!
theme
-
>
ThemeSupportsWidget
(
pc
mutable_this
aDisp
-
>
mAppearance
)
)
return
false
;
if
(
aTransparencyState
)
{
*
aTransparencyState
=
theme
-
>
GetWidgetTransparency
(
mutable_this
aDisp
-
>
mAppearance
)
;
}
return
true
;
}
void
BuildDisplayListForStackingContext
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
bool
*
aCreatedContainerItem
=
nullptr
)
;
enum
{
DISPLAY_CHILD_FORCE_PSEUDO_STACKING_CONTEXT
=
0x01
DISPLAY_CHILD_FORCE_STACKING_CONTEXT
=
0x02
DISPLAY_CHILD_INLINE
=
0x04
}
;
void
BuildDisplayListForChild
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aChild
const
nsDisplayListSet
&
aLists
uint32_t
aFlags
=
0
)
;
void
BuildDisplayListForSimpleChild
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aChild
const
nsDisplayListSet
&
aLists
)
;
bool
RefusedAsyncAnimation
(
)
const
{
return
GetProperty
(
RefusedAsyncAnimationProperty
(
)
)
;
}
bool
IsTransformed
(
const
nsStyleDisplay
*
aStyleDisplay
)
const
;
bool
IsTransformed
(
)
const
{
return
IsTransformed
(
StyleDisplay
(
)
)
;
}
bool
IsCSSTransformed
(
const
nsStyleDisplay
*
aStyleDisplay
)
const
;
bool
HasAnimationOfTransform
(
)
const
;
bool
HasOpacity
(
const
nsStyleDisplay
*
aStyleDisplay
const
nsStyleEffects
*
aStyleEffects
mozilla
:
:
EffectSet
*
aEffectSet
=
nullptr
)
const
{
return
HasOpacityInternal
(
1
.
0f
aStyleDisplay
aStyleEffects
aEffectSet
)
;
}
bool
HasVisualOpacity
(
const
nsStyleDisplay
*
aStyleDisplay
const
nsStyleEffects
*
aStyleEffects
mozilla
:
:
EffectSet
*
aEffectSet
=
nullptr
)
const
{
return
HasOpacityInternal
(
0
.
99f
aStyleDisplay
aStyleEffects
aEffectSet
)
;
}
virtual
bool
HasTransformGetter
(
)
const
{
return
false
;
}
virtual
bool
IsSVGTransformed
(
Matrix
*
aOwnTransforms
=
nullptr
Matrix
*
aFromParentTransforms
=
nullptr
)
const
;
bool
Extend3DContext
(
const
nsStyleDisplay
*
aStyleDisplay
const
nsStyleEffects
*
aStyleEffects
mozilla
:
:
EffectSet
*
aEffectSetForOpacity
=
nullptr
)
const
;
bool
Extend3DContext
(
mozilla
:
:
EffectSet
*
aEffectSetForOpacity
=
nullptr
)
const
{
return
Extend3DContext
(
StyleDisplay
(
)
StyleEffects
(
)
aEffectSetForOpacity
)
;
}
bool
Combines3DTransformWithAncestors
(
const
nsStyleDisplay
*
aStyleDisplay
)
const
;
bool
Combines3DTransformWithAncestors
(
)
const
{
return
Combines3DTransformWithAncestors
(
StyleDisplay
(
)
)
;
}
bool
In3DContextAndBackfaceIsHidden
(
)
const
;
bool
IsPreserve3DLeaf
(
const
nsStyleDisplay
*
aStyleDisplay
mozilla
:
:
EffectSet
*
aEffectSet
=
nullptr
)
const
{
return
Combines3DTransformWithAncestors
(
aStyleDisplay
)
&
&
!
Extend3DContext
(
aStyleDisplay
StyleEffects
(
)
aEffectSet
)
;
}
bool
IsPreserve3DLeaf
(
mozilla
:
:
EffectSet
*
aEffectSet
=
nullptr
)
const
{
return
IsPreserve3DLeaf
(
StyleDisplay
(
)
aEffectSet
)
;
}
bool
HasPerspective
(
const
nsStyleDisplay
*
aStyleDisplay
)
const
;
bool
HasPerspective
(
)
const
{
return
HasPerspective
(
StyleDisplay
(
)
)
;
}
bool
ChildrenHavePerspective
(
const
nsStyleDisplay
*
aStyleDisplay
)
const
;
bool
ChildrenHavePerspective
(
)
const
{
return
ChildrenHavePerspective
(
StyleDisplay
(
)
)
;
}
void
ComputePreserve3DChildrenOverflow
(
nsOverflowAreas
&
aOverflowAreas
)
;
void
RecomputePerspectiveChildrenOverflow
(
const
nsIFrame
*
aStartFrame
)
;
int32_t
ZIndex
(
)
const
;
bool
IsScrollAnchor
(
mozilla
:
:
layout
:
:
ScrollAnchorContainer
*
*
aOutContainer
=
nullptr
)
;
bool
IsInScrollAnchorChain
(
)
const
;
void
SetInScrollAnchorChain
(
bool
aInChain
)
;
uint32_t
GetDepthInFrameTree
(
)
const
;
virtual
nsresult
HandleEvent
(
nsPresContext
*
aPresContext
mozilla
:
:
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
=
0
;
virtual
nsresult
GetContentForEvent
(
mozilla
:
:
WidgetEvent
*
aEvent
nsIContent
*
*
aContent
)
=
0
;
struct
MOZ_STACK_CLASS
ContentOffsets
{
ContentOffsets
(
)
:
offset
(
0
)
secondaryOffset
(
0
)
associate
(
mozilla
:
:
CARET_ASSOCIATE_BEFORE
)
{
}
bool
IsNull
(
)
{
return
!
content
;
}
int32_t
StartOffset
(
)
{
return
std
:
:
min
(
offset
secondaryOffset
)
;
}
int32_t
EndOffset
(
)
{
return
std
:
:
max
(
offset
secondaryOffset
)
;
}
nsCOMPtr
<
nsIContent
>
content
;
int32_t
offset
;
int32_t
secondaryOffset
;
mozilla
:
:
CaretAssociationHint
associate
;
}
;
enum
{
IGNORE_SELECTION_STYLE
=
0x01
SKIP_HIDDEN
=
0x02
}
;
ContentOffsets
GetContentOffsetsFromPoint
(
const
nsPoint
&
aPoint
uint32_t
aFlags
=
0
)
;
virtual
ContentOffsets
GetContentOffsetsFromPointExternal
(
const
nsPoint
&
aPoint
uint32_t
aFlags
=
0
)
{
return
GetContentOffsetsFromPoint
(
aPoint
aFlags
)
;
}
void
AssociateImage
(
const
nsStyleImage
&
aImage
nsPresContext
*
aPresContext
uint32_t
aImageLoaderFlags
)
;
enum
class
AllowCustomCursorImage
{
No
Yes
}
;
struct
MOZ_STACK_CLASS
Cursor
{
mozilla
:
:
StyleCursorKind
mCursor
=
mozilla
:
:
StyleCursorKind
:
:
Auto
;
AllowCustomCursorImage
mAllowCustomCursor
=
AllowCustomCursorImage
:
:
Yes
;
RefPtr
<
mozilla
:
:
ComputedStyle
>
mStyle
;
}
;
virtual
mozilla
:
:
Maybe
<
Cursor
>
GetCursor
(
const
nsPoint
&
)
;
virtual
nsresult
GetPointFromOffset
(
int32_t
inOffset
nsPoint
*
outPoint
)
=
0
;
virtual
nsresult
GetCharacterRectsInRange
(
int32_t
aInOffset
int32_t
aLength
nsTArray
<
nsRect
>
&
aRects
)
=
0
;
virtual
nsresult
GetChildFrameContainingOffset
(
int32_t
inContentOffset
bool
inHint
int32_t
*
outFrameContentOffset
nsIFrame
*
*
outChildFrame
)
=
0
;
nsFrameState
GetStateBits
(
)
const
{
return
mState
;
}
void
AddStateBits
(
nsFrameState
aBits
)
{
mState
|
=
aBits
;
}
void
RemoveStateBits
(
nsFrameState
aBits
)
{
mState
&
=
~
aBits
;
}
void
AddOrRemoveStateBits
(
nsFrameState
aBits
bool
aVal
)
{
aVal
?
AddStateBits
(
aBits
)
:
RemoveStateBits
(
aBits
)
;
}
bool
HasAllStateBits
(
nsFrameState
aBits
)
const
{
return
(
mState
&
aBits
)
=
=
aBits
;
}
bool
HasAnyStateBits
(
nsFrameState
aBits
)
const
{
return
mState
&
aBits
;
}
bool
IsPrimaryFrame
(
)
const
{
return
mIsPrimaryFrame
;
}
void
SetIsPrimaryFrame
(
bool
aIsPrimary
)
{
mIsPrimaryFrame
=
aIsPrimary
;
}
virtual
nsresult
CharacterDataChanged
(
const
CharacterDataChangeInfo
&
)
=
0
;
virtual
nsresult
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
=
0
;
virtual
void
ContentStatesChanged
(
mozilla
:
:
EventStates
aStates
)
;
virtual
nsIFrame
*
GetPrevContinuation
(
)
const
=
0
;
virtual
void
SetPrevContinuation
(
nsIFrame
*
)
=
0
;
virtual
nsIFrame
*
GetNextContinuation
(
)
const
=
0
;
virtual
void
SetNextContinuation
(
nsIFrame
*
)
=
0
;
virtual
nsIFrame
*
FirstContinuation
(
)
const
{
return
const_cast
<
nsIFrame
*
>
(
this
)
;
}
virtual
nsIFrame
*
LastContinuation
(
)
const
{
return
const_cast
<
nsIFrame
*
>
(
this
)
;
}
nsIFrame
*
GetTailContinuation
(
)
;
virtual
nsIFrame
*
GetPrevInFlowVirtual
(
)
const
=
0
;
nsIFrame
*
GetPrevInFlow
(
)
const
{
return
GetPrevInFlowVirtual
(
)
;
}
virtual
void
SetPrevInFlow
(
nsIFrame
*
)
=
0
;
virtual
nsIFrame
*
GetNextInFlowVirtual
(
)
const
=
0
;
nsIFrame
*
GetNextInFlow
(
)
const
{
return
GetNextInFlowVirtual
(
)
;
}
virtual
void
SetNextInFlow
(
nsIFrame
*
)
=
0
;
virtual
nsIFrame
*
FirstInFlow
(
)
const
{
return
const_cast
<
nsIFrame
*
>
(
this
)
;
}
virtual
nsIFrame
*
LastInFlow
(
)
const
{
return
const_cast
<
nsIFrame
*
>
(
this
)
;
}
virtual
void
MarkIntrinsicISizesDirty
(
)
=
0
;
virtual
nscoord
GetMinISize
(
gfxContext
*
aRenderingContext
)
=
0
;
virtual
nscoord
GetPrefISize
(
gfxContext
*
aRenderingContext
)
=
0
;
struct
InlineIntrinsicISizeData
{
InlineIntrinsicISizeData
(
)
:
mLine
(
nullptr
)
mLineContainer
(
nullptr
)
mPrevLines
(
0
)
mCurrentLine
(
0
)
mTrailingWhitespace
(
0
)
mSkipWhitespace
(
true
)
{
}
const
nsLineList_iterator
*
mLine
;
private
:
nsIFrame
*
mLineContainer
;
public
:
void
SetLineContainer
(
nsIFrame
*
aLineContainer
)
{
mLineContainer
=
aLineContainer
;
}
nsIFrame
*
LineContainer
(
)
const
{
return
mLineContainer
;
}
nscoord
mPrevLines
;
nscoord
mCurrentLine
;
nscoord
mTrailingWhitespace
;
bool
mSkipWhitespace
;
class
FloatInfo
{
public
:
FloatInfo
(
const
nsIFrame
*
aFrame
nscoord
aWidth
)
:
mFrame
(
aFrame
)
mWidth
(
aWidth
)
{
}
const
nsIFrame
*
Frame
(
)
const
{
return
mFrame
;
}
nscoord
Width
(
)
const
{
return
mWidth
;
}
private
:
const
nsIFrame
*
mFrame
;
nscoord
mWidth
;
}
;
nsTArray
<
FloatInfo
>
mFloats
;
}
;
struct
InlineMinISizeData
:
public
InlineIntrinsicISizeData
{
InlineMinISizeData
(
)
:
mAtStartOfLine
(
true
)
{
}
void
DefaultAddInlineMinISize
(
nsIFrame
*
aFrame
nscoord
aISize
bool
aAllowBreak
=
true
)
;
void
ForceBreak
(
)
;
void
OptionallyBreak
(
nscoord
aHyphenWidth
=
0
)
;
bool
mAtStartOfLine
;
}
;
struct
InlinePrefISizeData
:
public
InlineIntrinsicISizeData
{
typedef
mozilla
:
:
StyleClear
StyleClear
;
InlinePrefISizeData
(
)
:
mLineIsEmpty
(
true
)
{
}
void
ForceBreak
(
StyleClear
aBreakType
=
StyleClear
:
:
Both
)
;
void
DefaultAddInlinePrefISize
(
nscoord
aISize
)
;
bool
mLineIsEmpty
;
}
;
virtual
void
AddInlineMinISize
(
gfxContext
*
aRenderingContext
InlineMinISizeData
*
aData
)
=
0
;
virtual
void
AddInlinePrefISize
(
gfxContext
*
aRenderingContext
InlinePrefISizeData
*
aData
)
=
0
;
struct
IntrinsicISizeOffsetData
{
nscoord
hPadding
hBorder
hMargin
;
IntrinsicISizeOffsetData
(
)
:
hPadding
(
0
)
hBorder
(
0
)
hMargin
(
0
)
{
}
}
;
virtual
IntrinsicISizeOffsetData
IntrinsicISizeOffsets
(
nscoord
aPercentageBasis
=
NS_UNCONSTRAINEDSIZE
)
=
0
;
IntrinsicISizeOffsetData
IntrinsicBSizeOffsets
(
nscoord
aPercentageBasis
=
NS_UNCONSTRAINEDSIZE
)
;
virtual
mozilla
:
:
IntrinsicSize
GetIntrinsicSize
(
)
=
0
;
virtual
nsSize
GetIntrinsicRatio
(
)
=
0
;
enum
ComputeSizeFlags
{
eDefault
=
0
eShrinkWrap
=
1
<
<
0
eUseAutoBSize
=
1
<
<
1
eIClampMarginBoxMinSize
=
1
<
<
2
eBClampMarginBoxMinSize
=
1
<
<
3
eIApplyAutoMinSize
=
1
<
<
4
}
;
virtual
mozilla
:
:
LogicalSize
ComputeSize
(
gfxContext
*
aRenderingContext
mozilla
:
:
WritingMode
aWritingMode
const
mozilla
:
:
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
mozilla
:
:
LogicalSize
&
aMargin
const
mozilla
:
:
LogicalSize
&
aBorder
const
mozilla
:
:
LogicalSize
&
aPadding
ComputeSizeFlags
aFlags
)
=
0
;
virtual
nsRect
ComputeTightBounds
(
DrawTarget
*
aDrawTarget
)
const
;
virtual
nsresult
GetPrefWidthTightBounds
(
gfxContext
*
aContext
nscoord
*
aX
nscoord
*
aXMost
)
;
virtual
void
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aReflowOutput
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
=
0
;
virtual
void
DidReflow
(
nsPresContext
*
aPresContext
const
ReflowInput
*
aReflowInput
)
=
0
;
bool
UpdateOverflow
(
)
;
virtual
bool
ComputeCustomOverflow
(
nsOverflowAreas
&
aOverflowAreas
)
=
0
;
virtual
void
UnionChildOverflow
(
nsOverflowAreas
&
aOverflowAreas
)
=
0
;
virtual
bool
CanContinueTextRun
(
)
const
=
0
;
struct
RenderedText
{
nsAutoString
mString
;
uint32_t
mOffsetWithinNodeRenderedText
;
int32_t
mOffsetWithinNodeText
;
RenderedText
(
)
:
mOffsetWithinNodeRenderedText
(
0
)
mOffsetWithinNodeText
(
0
)
{
}
}
;
enum
class
TextOffsetType
{
OffsetsInContentText
OffsetsInRenderedText
}
;
enum
class
TrailingWhitespace
{
Trim
DontTrim
}
;
virtual
RenderedText
GetRenderedText
(
uint32_t
aStartOffset
=
0
uint32_t
aEndOffset
=
UINT32_MAX
TextOffsetType
aOffsetType
=
TextOffsetType
:
:
OffsetsInContentText
TrailingWhitespace
aTrimTrailingWhitespace
=
TrailingWhitespace
:
:
Trim
)
{
return
RenderedText
(
)
;
}
virtual
bool
HasAnyNoncollapsedCharacters
(
)
{
return
false
;
}
virtual
bool
OnlySystemGroupDispatch
(
mozilla
:
:
EventMessage
aMessage
)
const
{
return
false
;
}
bool
HasView
(
)
const
{
return
!
!
(
mState
&
NS_FRAME_HAS_VIEW
)
;
}
protected
:
virtual
nsView
*
GetViewInternal
(
)
const
{
MOZ_ASSERT_UNREACHABLE
(
"
method
should
have
been
overridden
by
subclass
"
)
;
return
nullptr
;
}
virtual
void
SetViewInternal
(
nsView
*
aView
)
{
MOZ_ASSERT_UNREACHABLE
(
"
method
should
have
been
overridden
by
subclass
"
)
;
}
public
:
nsView
*
GetView
(
)
const
{
if
(
MOZ_LIKELY
(
!
HasView
(
)
)
)
{
return
nullptr
;
}
nsView
*
view
=
GetViewInternal
(
)
;
MOZ_ASSERT
(
view
"
GetViewInternal
(
)
should
agree
with
HasView
(
)
"
)
;
return
view
;
}
void
SetView
(
nsView
*
aView
)
;
nsView
*
GetClosestView
(
nsPoint
*
aOffset
=
nullptr
)
const
;
nsIFrame
*
GetAncestorWithView
(
)
const
;
void
SyncFrameViewProperties
(
nsView
*
aView
=
nullptr
)
;
nsPoint
GetOffsetTo
(
const
nsIFrame
*
aOther
)
const
;
nsPoint
GetOffsetToIgnoringScrolling
(
const
nsIFrame
*
aOther
)
const
;
nsPoint
GetOffsetToCrossDoc
(
const
nsIFrame
*
aOther
)
const
;
nsPoint
GetOffsetToCrossDoc
(
const
nsIFrame
*
aOther
const
int32_t
aAPD
)
const
;
mozilla
:
:
CSSIntRect
GetScreenRect
(
)
const
;
nsRect
GetScreenRectInAppUnits
(
)
const
;
void
GetOffsetFromView
(
nsPoint
&
aOffset
nsView
*
*
aView
)
const
;
nsIWidget
*
GetNearestWidget
(
)
const
;
nsIWidget
*
GetNearestWidget
(
nsPoint
&
aOffset
)
const
;
bool
IsContentDisabled
(
)
const
;
mozilla
:
:
LayoutFrameType
Type
(
)
const
{
MOZ_ASSERT
(
uint8_t
(
mClass
)
<
mozilla
:
:
ArrayLength
(
sLayoutFrameTypes
)
)
;
return
sLayoutFrameTypes
[
uint8_t
(
mClass
)
]
;
}
#
define
FRAME_TYPE
(
name_
)
\
bool
Is
#
#
name_
#
#
Frame
(
)
const
{
\
return
Type
(
)
=
=
mozilla
:
:
LayoutFrameType
:
:
name_
;
\
}
#
include
"
mozilla
/
FrameTypeList
.
h
"
#
undef
FRAME_TYPE
enum
{
IN_CSS_UNITS
=
1
<
<
0
STOP_AT_STACKING_CONTEXT_AND_DISPLAY_PORT
=
1
<
<
1
}
;
Matrix4x4Flagged
GetTransformMatrix
(
const
nsIFrame
*
aStopAtAncestor
nsIFrame
*
*
aOutAncestor
uint32_t
aFlags
=
0
)
const
;
enum
{
eMathML
=
1
<
<
0
eSVG
=
1
<
<
1
eSVGForeignObject
=
1
<
<
2
eSVGContainer
=
1
<
<
3
eSVGGeometry
=
1
<
<
4
eSVGPaintServer
=
1
<
<
5
eBidiInlineContainer
=
1
<
<
6
eReplaced
=
1
<
<
7
eReplacedContainsBlock
=
1
<
<
8
eLineParticipant
=
1
<
<
9
eXULBox
=
1
<
<
10
eCanContainOverflowContainers
=
1
<
<
11
eTablePart
=
1
<
<
12
eExcludesIgnorableWhitespace
=
1
<
<
13
eSupportsCSSTransforms
=
1
<
<
14
eReplacedSizing
=
1
<
<
15
eSupportsContainLayoutAndPaint
=
1
<
<
16
eDEBUGAllFrames
=
1
<
<
30
eDEBUGNoFrames
=
1
<
<
31
}
;
virtual
bool
IsFrameOfType
(
uint32_t
aFlags
)
const
{
return
!
(
aFlags
&
~
(
#
ifdef
DEBUG
nsIFrame
:
:
eDEBUGAllFrames
|
#
endif
nsIFrame
:
:
eSupportsCSSTransforms
|
nsIFrame
:
:
eSupportsContainLayoutAndPaint
)
)
;
}
bool
IsBlockWrapper
(
)
const
;
bool
IsBlockFrameOrSubclass
(
)
const
;
enum
{
SKIP_SCROLLED_FRAME
=
0x01
}
;
nsIFrame
*
GetContainingBlock
(
uint32_t
aFlags
const
nsStyleDisplay
*
aStyleDisplay
)
const
;
nsIFrame
*
GetContainingBlock
(
uint32_t
aFlags
=
0
)
const
{
return
GetContainingBlock
(
aFlags
StyleDisplay
(
)
)
;
}
virtual
bool
IsFloatContainingBlock
(
)
const
{
return
false
;
}
bool
IsLeaf
(
)
const
{
MOZ_ASSERT
(
uint8_t
(
mClass
)
<
mozilla
:
:
ArrayLength
(
sFrameClassBits
)
)
;
FrameClassBits
bits
=
sFrameClassBits
[
uint8_t
(
mClass
)
]
;
if
(
MOZ_UNLIKELY
(
bits
&
eFrameClassBitsDynamicLeaf
)
)
{
return
IsLeafDynamic
(
)
;
}
return
bits
&
eFrameClassBitsLeaf
;
}
virtual
void
InvalidateFrame
(
uint32_t
aDisplayItemKey
=
0
bool
aRebuildDisplayItems
=
true
)
;
virtual
void
InvalidateFrameWithRect
(
const
nsRect
&
aRect
uint32_t
aDisplayItemKey
=
0
bool
aRebuildDisplayItems
=
true
)
;
void
InvalidateFrameSubtree
(
bool
aRebuildDisplayItems
=
true
)
;
virtual
void
InvalidateFrameForRemoval
(
)
{
}
static
void
*
LayerIsPrerenderedDataKey
(
)
{
return
&
sLayerIsPrerenderedDataKey
;
}
static
uint8_t
sLayerIsPrerenderedDataKey
;
bool
TryUpdateTransformOnly
(
Layer
*
*
aLayerResult
)
;
bool
IsInvalid
(
nsRect
&
aRect
)
;
bool
HasInvalidFrameInSubtree
(
)
{
return
HasAnyStateBits
(
NS_FRAME_NEEDS_PAINT
|
NS_FRAME_DESCENDANT_NEEDS_PAINT
)
;
}
void
ClearInvalidationStateBits
(
)
;
enum
PaintType
{
PAINT_DEFAULT
=
0
PAINT_COMPOSITE_ONLY
PAINT_DELAYED_COMPRESS
}
;
void
SchedulePaint
(
PaintType
aType
=
PAINT_DEFAULT
bool
aFrameChanged
=
true
)
;
void
SchedulePaintWithoutInvalidatingObservers
(
PaintType
aType
=
PAINT_DEFAULT
)
;
enum
{
UPDATE_IS_ASYNC
=
1
<
<
0
}
;
Layer
*
InvalidateLayer
(
DisplayItemType
aDisplayItemKey
const
nsIntRect
*
aDamageRect
=
nullptr
const
nsRect
*
aFrameDamageRect
=
nullptr
uint32_t
aFlags
=
0
)
;
void
MarkNeedsDisplayItemRebuild
(
)
;
nsRect
GetVisualOverflowRect
(
)
const
{
return
GetOverflowRect
(
eVisualOverflow
)
;
}
nsRect
GetScrollableOverflowRect
(
)
const
{
return
GetOverflowRect
(
eScrollableOverflow
)
;
}
nsRect
GetOverflowRect
(
nsOverflowType
aType
)
const
;
nsOverflowAreas
GetOverflowAreas
(
)
const
;
nsOverflowAreas
GetOverflowAreasRelativeToSelf
(
)
const
;
nsRect
GetScrollableOverflowRectRelativeToParent
(
)
const
;
nsRect
GetScrollableOverflowRectRelativeToSelf
(
)
const
;
nsRect
GetVisualOverflowRectRelativeToSelf
(
)
const
;
nsRect
GetVisualOverflowRectRelativeToParent
(
)
const
;
nsRect
GetPreEffectsVisualOverflowRect
(
)
const
;
bool
FinishAndStoreOverflow
(
nsOverflowAreas
&
aOverflowAreas
nsSize
aNewSize
nsSize
*
aOldSize
=
nullptr
const
nsStyleDisplay
*
aStyleDisplay
=
nullptr
)
;
bool
FinishAndStoreOverflow
(
ReflowOutput
*
aMetrics
const
nsStyleDisplay
*
aStyleDisplay
=
nullptr
)
{
return
FinishAndStoreOverflow
(
aMetrics
-
>
mOverflowAreas
nsSize
(
aMetrics
-
>
Width
(
)
aMetrics
-
>
Height
(
)
)
nullptr
aStyleDisplay
)
;
}
bool
HasOverflowAreas
(
)
const
{
return
mOverflow
.
mType
!
=
NS_FRAME_OVERFLOW_NONE
;
}
bool
ClearOverflowRects
(
)
;
Sides
GetSkipSides
(
const
ReflowInput
*
aReflowInput
=
nullptr
)
const
;
virtual
LogicalSides
GetLogicalSkipSides
(
const
ReflowInput
*
aReflowInput
=
nullptr
)
const
{
return
LogicalSides
(
)
;
}
bool
IsSelected
(
)
const
{
return
(
GetContent
(
)
&
&
GetContent
(
)
-
>
IsSelectionDescendant
(
)
)
?
IsFrameSelected
(
)
:
false
;
}
bool
IsSelectable
(
mozilla
:
:
StyleUserSelect
*
aSelectStyle
)
const
;
virtual
nsresult
GetSelectionController
(
nsPresContext
*
aPresContext
nsISelectionController
*
*
aSelCon
)
=
0
;
already_AddRefed
<
nsFrameSelection
>
GetFrameSelection
(
)
;
const
nsFrameSelection
*
GetConstFrameSelection
(
)
const
;
virtual
nsresult
PeekOffset
(
nsPeekOffsetStruct
*
aPos
)
;
nsresult
GetFrameFromDirection
(
nsDirection
aDirection
bool
aVisual
bool
aJumpLines
bool
aScrollViewStop
bool
aForceEditableRegion
nsIFrame
*
*
aOutFrame
int32_t
*
aOutOffset
bool
*
aOutJumpedLine
bool
*
aOutMovedOverNonSelectableText
)
;
virtual
nsresult
CheckVisibility
(
nsPresContext
*
aContext
int32_t
aStartIndex
int32_t
aEndIndex
bool
aRecurse
bool
*
aFinished
bool
*
_retval
)
=
0
;
virtual
void
ChildIsDirty
(
nsIFrame
*
aChild
)
=
0
;
#
ifdef
ACCESSIBILITY
virtual
mozilla
:
:
a11y
:
:
AccType
AccessibleType
(
)
=
0
;
#
endif
virtual
ComputedStyle
*
GetParentComputedStyle
(
nsIFrame
*
*
aProviderFrame
)
const
=
0
;
void
UpdateStyleOfOwnedAnonBoxes
(
mozilla
:
:
ServoRestyleState
&
aRestyleState
)
{
if
(
GetStateBits
(
)
&
NS_FRAME_OWNS_ANON_BOXES
)
{
DoUpdateStyleOfOwnedAnonBoxes
(
aRestyleState
)
;
}
}
protected
:
void
DoUpdateStyleOfOwnedAnonBoxes
(
mozilla
:
:
ServoRestyleState
&
aRestyleState
)
;
void
UpdateStyleOfChildAnonBox
(
nsIFrame
*
aChildFrame
mozilla
:
:
ServoRestyleState
&
aRestyleState
)
;
friend
class
mozilla
:
:
ServoRestyleState
;
public
:
static
nsChangeHint
UpdateStyleOfOwnedChildFrame
(
nsIFrame
*
aChildFrame
ComputedStyle
*
aNewComputedStyle
mozilla
:
:
ServoRestyleState
&
aRestyleState
const
Maybe
<
ComputedStyle
*
>
&
aContinuationComputedStyle
=
Nothing
(
)
)
;
struct
OwnedAnonBox
{
typedef
void
(
*
UpdateStyleFn
)
(
nsIFrame
*
aOwningFrame
nsIFrame
*
aAnonBox
mozilla
:
:
ServoRestyleState
&
aRestyleState
)
;
explicit
OwnedAnonBox
(
nsIFrame
*
aAnonBoxFrame
UpdateStyleFn
aUpdateStyleFn
=
nullptr
)
:
mAnonBoxFrame
(
aAnonBoxFrame
)
mUpdateStyleFn
(
aUpdateStyleFn
)
{
}
nsIFrame
*
mAnonBoxFrame
;
UpdateStyleFn
mUpdateStyleFn
;
}
;
void
AppendOwnedAnonBoxes
(
nsTArray
<
OwnedAnonBox
>
&
aResult
)
{
if
(
GetStateBits
(
)
&
NS_FRAME_OWNS_ANON_BOXES
)
{
if
(
IsInlineFrame
(
)
)
{
return
;
}
DoAppendOwnedAnonBoxes
(
aResult
)
;
}
}
protected
:
void
DoAppendOwnedAnonBoxes
(
nsTArray
<
OwnedAnonBox
>
&
aResult
)
;
public
:
virtual
void
AppendDirectlyOwnedAnonBoxes
(
nsTArray
<
OwnedAnonBox
>
&
aResult
)
;
bool
IsVisibleForPainting
(
)
;
bool
IsVisibleOrCollapsedForPainting
(
)
;
bool
IsStackingContext
(
const
nsStyleDisplay
*
aStyleDisplay
const
nsStylePosition
*
aStylePosition
const
nsStyleEffects
*
aStyleEffects
bool
aIsPositioned
)
;
bool
IsStackingContext
(
)
;
virtual
bool
HonorPrintBackgroundSettings
(
)
{
return
true
;
}
virtual
bool
IsEmpty
(
)
=
0
;
virtual
bool
CachedIsEmpty
(
)
;
virtual
bool
IsSelfEmpty
(
)
=
0
;
bool
IsGeneratedContentFrame
(
)
const
{
return
(
mState
&
NS_FRAME_GENERATED_CONTENT
)
!
=
0
;
}
bool
IsPseudoFrame
(
const
nsIContent
*
aParentContent
)
{
return
mContent
=
=
aParentContent
;
}
template
<
typename
T
>
FrameProperties
:
:
PropertyType
<
T
>
GetProperty
(
FrameProperties
:
:
Descriptor
<
T
>
aProperty
bool
*
aFoundResult
=
nullptr
)
const
{
return
mProperties
.
Get
(
aProperty
aFoundResult
)
;
}
template
<
typename
T
>
bool
HasProperty
(
FrameProperties
:
:
Descriptor
<
T
>
aProperty
)
const
{
return
mProperties
.
Has
(
aProperty
)
;
}
template
<
typename
T
>
void
SetProperty
(
FrameProperties
:
:
Descriptor
<
T
>
aProperty
FrameProperties
:
:
PropertyType
<
T
>
aValue
)
{
mProperties
.
Set
(
aProperty
aValue
this
)
;
}
template
<
typename
T
>
void
AddProperty
(
FrameProperties
:
:
Descriptor
<
T
>
aProperty
FrameProperties
:
:
PropertyType
<
T
>
aValue
)
{
mProperties
.
Add
(
aProperty
aValue
)
;
}
template
<
typename
T
>
FrameProperties
:
:
PropertyType
<
T
>
RemoveProperty
(
FrameProperties
:
:
Descriptor
<
T
>
aProperty
bool
*
aFoundResult
=
nullptr
)
{
return
mProperties
.
Remove
(
aProperty
aFoundResult
)
;
}
template
<
typename
T
>
void
DeleteProperty
(
FrameProperties
:
:
Descriptor
<
T
>
aProperty
)
{
mProperties
.
Delete
(
aProperty
this
)
;
}
void
DeleteAllProperties
(
)
{
mProperties
.
DeleteAll
(
this
)
;
}
virtual
void
AddSizeOfExcludingThisForTree
(
nsWindowSizes
&
aWindowSizes
)
const
;
virtual
bool
SupportsVisibilityHidden
(
)
{
return
true
;
}
Maybe
<
nsRect
>
GetClipPropClipRect
(
const
nsStyleDisplay
*
aDisp
const
nsStyleEffects
*
aEffects
const
nsSize
&
aSize
)
const
;
virtual
bool
IsFocusable
(
int32_t
*
aTabIndex
=
nullptr
bool
aWithMouse
=
false
)
;
bool
IsXULBoxFrame
(
)
const
{
return
IsFrameOfType
(
nsIFrame
:
:
eXULBox
)
;
}
enum
Halignment
{
hAlign_Left
hAlign_Right
hAlign_Center
}
;
enum
Valignment
{
vAlign_Top
vAlign_Middle
vAlign_BaseLine
vAlign_Bottom
}
;
virtual
nsSize
GetXULMinSize
(
nsBoxLayoutState
&
aBoxLayoutState
)
=
0
;
virtual
nsSize
GetXULPrefSize
(
nsBoxLayoutState
&
aBoxLayoutState
)
=
0
;
virtual
nsSize
GetXULMaxSize
(
nsBoxLayoutState
&
aBoxLayoutState
)
=
0
;
virtual
nsSize
GetXULMinSizeForScrollArea
(
nsBoxLayoutState
&
aBoxLayoutState
)
=
0
;
uint32_t
GetXULOrdinal
(
)
;
virtual
nscoord
GetXULFlex
(
)
=
0
;
virtual
nscoord
GetXULBoxAscent
(
nsBoxLayoutState
&
aBoxLayoutState
)
=
0
;
virtual
bool
IsXULCollapsed
(
)
=
0
;
virtual
void
SetXULBounds
(
nsBoxLayoutState
&
aBoxLayoutState
const
nsRect
&
aRect
bool
aRemoveOverflowAreas
=
false
)
=
0
;
nsresult
XULLayout
(
nsBoxLayoutState
&
aBoxLayoutState
)
;
virtual
nsresult
GetXULBorderAndPadding
(
nsMargin
&
aBorderAndPadding
)
;
virtual
nsresult
GetXULBorder
(
nsMargin
&
aBorder
)
=
0
;
virtual
nsresult
GetXULPadding
(
nsMargin
&
aBorderAndPadding
)
=
0
;
virtual
nsresult
GetXULMargin
(
nsMargin
&
aMargin
)
=
0
;
virtual
void
SetXULLayoutManager
(
nsBoxLayout
*
aLayout
)
{
}
virtual
nsBoxLayout
*
GetXULLayoutManager
(
)
{
return
nullptr
;
}
nsresult
GetXULClientRect
(
nsRect
&
aContentRect
)
;
virtual
uint32_t
GetXULLayoutFlags
(
)
{
return
0
;
}
virtual
Valignment
GetXULVAlign
(
)
const
=
0
;
virtual
Halignment
GetXULHAlign
(
)
const
=
0
;
bool
IsXULHorizontal
(
)
const
{
return
(
mState
&
NS_STATE_IS_HORIZONTAL
)
!
=
0
;
}
bool
IsXULNormalDirection
(
)
const
{
return
(
mState
&
NS_STATE_IS_DIRECTION_NORMAL
)
!
=
0
;
}
nsresult
XULRedraw
(
nsBoxLayoutState
&
aState
)
;
virtual
nsresult
XULRelayoutChildAtOrdinal
(
nsIFrame
*
aChild
)
=
0
;
static
bool
AddXULPrefSize
(
nsIFrame
*
aBox
nsSize
&
aSize
bool
&
aWidth
bool
&
aHeightSet
)
;
static
bool
AddXULMinSize
(
nsBoxLayoutState
&
aState
nsIFrame
*
aBox
nsSize
&
aSize
bool
&
aWidth
bool
&
aHeightSet
)
;
static
bool
AddXULMaxSize
(
nsIFrame
*
aBox
nsSize
&
aSize
bool
&
aWidth
bool
&
aHeightSet
)
;
static
bool
AddXULFlex
(
nsIFrame
*
aBox
nscoord
&
aFlex
)
;
virtual
bool
HasSignificantTerminalNewline
(
)
const
;
struct
CaretPosition
{
CaretPosition
(
)
;
~
CaretPosition
(
)
;
nsCOMPtr
<
nsIContent
>
mResultContent
;
int32_t
mContentOffset
;
}
;
CaretPosition
GetExtremeCaretPosition
(
bool
aStart
)
;
virtual
nsILineIterator
*
GetLineIterator
(
)
=
0
;
virtual
void
PullOverflowsFromPrevInFlow
(
)
{
}
void
ClearPresShellsFromLastPaint
(
)
{
PaintedPresShellList
(
)
-
>
Clear
(
)
;
}
void
AddPaintedPresShell
(
mozilla
:
:
PresShell
*
aPresShell
)
{
PaintedPresShellList
(
)
-
>
AppendElement
(
do_GetWeakReference
(
aPresShell
)
)
;
}
void
UpdatePaintCountForPaintedPresShells
(
)
{
for
(
nsWeakPtr
&
item
:
*
PaintedPresShellList
(
)
)
{
if
(
RefPtr
<
mozilla
:
:
PresShell
>
presShell
=
do_QueryReferent
(
item
)
)
{
presShell
-
>
IncrementPaintCount
(
)
;
}
}
}
bool
DidPaintPresShell
(
mozilla
:
:
PresShell
*
aPresShell
)
{
for
(
nsWeakPtr
&
item
:
*
PaintedPresShellList
(
)
)
{
RefPtr
<
mozilla
:
:
PresShell
>
presShell
=
do_QueryReferent
(
item
)
;
if
(
presShell
=
=
aPresShell
)
{
return
true
;
}
}
return
false
;
}
bool
IsAbsoluteContainer
(
)
const
{
return
!
!
(
mState
&
NS_FRAME_HAS_ABSPOS_CHILDREN
)
;
}
bool
HasAbsolutelyPositionedChildren
(
)
const
;
nsAbsoluteContainingBlock
*
GetAbsoluteContainingBlock
(
)
const
;
void
MarkAsAbsoluteContainingBlock
(
)
;
void
MarkAsNotAbsoluteContainingBlock
(
)
;
virtual
mozilla
:
:
layout
:
:
FrameChildListID
GetAbsoluteListID
(
)
const
{
return
kAbsoluteList
;
}
bool
CheckAndClearPaintedState
(
)
;
bool
CheckAndClearDisplayListState
(
)
;
enum
{
VISIBILITY_CROSS_CHROME_CONTENT_BOUNDARY
=
0x01
}
;
bool
IsVisibleConsideringAncestors
(
uint32_t
aFlags
=
0
)
const
;
struct
FrameWithDistance
{
nsIFrame
*
mFrame
;
nscoord
mXDistance
;
nscoord
mYDistance
;
}
;
virtual
void
FindCloserFrameForSelection
(
const
nsPoint
&
aPoint
FrameWithDistance
*
aCurrentBestFrame
)
;
inline
bool
IsFlexItem
(
)
const
;
inline
bool
IsFlexOrGridItem
(
)
const
;
inline
bool
IsFlexOrGridContainer
(
)
const
;
inline
bool
IsTableCaption
(
)
const
;
inline
bool
IsBlockInside
(
)
const
;
inline
bool
IsBlockOutside
(
)
const
;
inline
bool
IsInlineOutside
(
)
const
;
inline
mozilla
:
:
StyleDisplay
GetDisplay
(
)
const
;
inline
bool
IsFloating
(
)
const
;
inline
bool
IsAbsPosContainingBlock
(
)
const
;
inline
bool
IsFixedPosContainingBlock
(
)
const
;
inline
bool
IsRelativelyPositioned
(
)
const
;
inline
bool
IsStickyPositioned
(
)
const
;
inline
bool
IsAbsolutelyPositioned
(
const
nsStyleDisplay
*
aStyleDisplay
=
nullptr
)
const
;
inline
bool
IsColumnSpan
(
)
const
;
inline
bool
IsColumnSpanInMulticolSubtree
(
)
const
;
Maybe
<
mozilla
:
:
StyleVerticalAlignKeyword
>
VerticalAlignEnum
(
)
const
;
void
CreateOwnLayerIfNeeded
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
bool
*
aCreatedContainerItem
=
nullptr
)
;
static
void
AddInPopupStateBitToDescendants
(
nsIFrame
*
aFrame
)
;
static
void
RemoveInPopupStateBitFromDescendants
(
nsIFrame
*
aFrame
)
;
template
<
bool
IsLessThanOrEqual
(
nsIFrame
*
nsIFrame
*
)
>
static
void
SortFrameList
(
nsFrameList
&
aFrameList
)
;
template
<
bool
IsLessThanOrEqual
(
nsIFrame
*
nsIFrame
*
)
>
static
bool
IsFrameListSorted
(
nsFrameList
&
aFrameList
)
;
bool
FrameIsNonFirstInIBSplit
(
)
const
{
return
(
GetStateBits
(
)
&
NS_FRAME_PART_OF_IBSPLIT
)
&
&
FirstContinuation
(
)
-
>
GetProperty
(
nsIFrame
:
:
IBSplitPrevSibling
(
)
)
;
}
bool
FrameIsNonLastInIBSplit
(
)
const
{
return
(
GetStateBits
(
)
&
NS_FRAME_PART_OF_IBSPLIT
)
&
&
FirstContinuation
(
)
-
>
GetProperty
(
nsIFrame
:
:
IBSplitSibling
(
)
)
;
}
bool
IsContainerForFontSizeInflation
(
)
const
{
return
GetStateBits
(
)
&
NS_FRAME_FONT_INFLATION_CONTAINER
;
}
bool
FrameMaintainsOverflow
(
)
const
{
return
!
HasAllStateBits
(
NS_FRAME_SVG_LAYOUT
|
NS_FRAME_IS_NONDISPLAY
)
&
&
!
(
IsSVGOuterSVGFrame
(
)
&
&
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
)
;
}
bool
BackfaceIsHidden
(
const
nsStyleDisplay
*
aStyleDisplay
)
const
{
MOZ_ASSERT
(
aStyleDisplay
=
=
StyleDisplay
(
)
)
;
return
aStyleDisplay
-
>
BackfaceIsHidden
(
)
;
}
bool
BackfaceIsHidden
(
)
const
{
return
StyleDisplay
(
)
-
>
BackfaceIsHidden
(
)
;
}
bool
IsScrolledOutOfView
(
)
const
;
Matrix
ComputeWidgetTransform
(
)
;
virtual
void
UpdateWidgetProperties
(
)
;
bool
HasImageRequest
(
)
const
{
return
mHasImageRequest
;
}
void
SetHasImageRequest
(
bool
aHasRequest
)
{
mHasImageRequest
=
aHasRequest
;
}
bool
HasFirstLetterChild
(
)
const
{
return
mHasFirstLetterChild
;
}
bool
ParentIsWrapperAnonBox
(
)
const
{
return
mParentIsWrapperAnonBox
;
}
void
SetParentIsWrapperAnonBox
(
)
{
mParentIsWrapperAnonBox
=
true
;
}
bool
IsWrapperAnonBoxNeedingRestyle
(
)
const
{
return
mIsWrapperBoxNeedingRestyle
;
}
void
SetIsWrapperAnonBoxNeedingRestyle
(
bool
aNeedsRestyle
)
{
mIsWrapperBoxNeedingRestyle
=
aNeedsRestyle
;
}
bool
MayHaveTransformAnimation
(
)
const
{
return
mMayHaveTransformAnimation
;
}
void
SetMayHaveTransformAnimation
(
)
{
mMayHaveTransformAnimation
=
true
;
}
bool
MayHaveOpacityAnimation
(
)
const
{
return
mMayHaveOpacityAnimation
;
}
void
SetMayHaveOpacityAnimation
(
)
{
mMayHaveOpacityAnimation
=
true
;
}
bool
IsVisibleOrMayHaveVisibleDescendants
(
)
const
{
return
!
mAllDescendantsAreInvisible
|
|
StyleVisibility
(
)
-
>
IsVisible
(
)
;
}
void
UpdateVisibleDescendantsState
(
)
;
virtual
bool
RenumberFrameAndDescendants
(
int32_t
*
aOrdinal
int32_t
aDepth
int32_t
aIncrement
bool
aForCounting
)
{
return
false
;
}
nscoord
ComputeISizeValue
(
gfxContext
*
aRenderingContext
nscoord
aContainingBlockISize
nscoord
aContentEdgeToBoxSizing
nscoord
aBoxSizingToMarginEdge
StyleExtremumLength
aSize
ComputeSizeFlags
aFlags
)
;
nscoord
ComputeISizeValue
(
gfxContext
*
aRenderingContext
nscoord
aContainingBlockISize
nscoord
aContentEdgeToBoxSizing
nscoord
aBoxSizingToMarginEdge
const
LengthPercentage
&
aSize
ComputeSizeFlags
aFlags
)
;
template
<
typename
SizeOrMaxSize
>
nscoord
ComputeISizeValue
(
gfxContext
*
aRenderingContext
nscoord
aContainingBlockISize
nscoord
aContentEdgeToBoxSizing
nscoord
aBoxSizingToMarginEdge
const
SizeOrMaxSize
&
aSize
ComputeSizeFlags
aFlags
=
eDefault
)
{
MOZ_ASSERT
(
aSize
.
IsExtremumLength
(
)
|
|
aSize
.
IsLengthPercentage
(
)
"
This
doesn
'
t
handle
auto
/
none
"
)
;
if
(
aSize
.
IsLengthPercentage
(
)
)
{
return
ComputeISizeValue
(
aRenderingContext
aContainingBlockISize
aContentEdgeToBoxSizing
aBoxSizingToMarginEdge
aSize
.
AsLengthPercentage
(
)
aFlags
)
;
}
return
ComputeISizeValue
(
aRenderingContext
aContainingBlockISize
aContentEdgeToBoxSizing
aBoxSizingToMarginEdge
aSize
.
AsExtremumLength
(
)
aFlags
)
;
}
DisplayItemDataArray
&
DisplayItemData
(
)
{
return
mDisplayItemData
;
}
const
DisplayItemDataArray
&
DisplayItemData
(
)
const
{
return
mDisplayItemData
;
}
void
AddDisplayItem
(
nsDisplayItemBase
*
aItem
)
;
bool
RemoveDisplayItem
(
nsDisplayItemBase
*
aItem
)
;
void
RemoveDisplayItemDataForDeletion
(
)
;
bool
HasDisplayItems
(
)
;
bool
HasDisplayItem
(
nsDisplayItemBase
*
aItem
)
;
bool
HasDisplayItem
(
uint32_t
aKey
)
;
void
DiscardOldItems
(
)
;
bool
ForceDescendIntoIfVisible
(
)
const
{
return
mForceDescendIntoIfVisible
;
}
void
SetForceDescendIntoIfVisible
(
bool
aForce
)
{
mForceDescendIntoIfVisible
=
aForce
;
}
bool
BuiltDisplayList
(
)
{
return
mBuiltDisplayList
;
}
void
SetBuiltDisplayList
(
bool
aBuilt
)
{
mBuiltDisplayList
=
aBuilt
;
}
bool
IsFrameModified
(
)
{
return
mFrameIsModified
;
}
void
SetFrameIsModified
(
bool
aFrameIsModified
)
{
mFrameIsModified
=
aFrameIsModified
;
}
bool
HasOverrideDirtyRegion
(
)
{
return
mHasOverrideDirtyRegion
;
}
void
SetHasOverrideDirtyRegion
(
bool
aHasDirtyRegion
)
{
mHasOverrideDirtyRegion
=
aHasDirtyRegion
;
}
bool
MayHaveWillChangeBudget
(
)
{
return
mMayHaveWillChangeBudget
;
}
void
SetMayHaveWillChangeBudget
(
bool
aHasBudget
)
{
mMayHaveWillChangeBudget
=
aHasBudget
;
}
nsRect
GetCompositorHitTestArea
(
nsDisplayListBuilder
*
aBuilder
)
;
mozilla
:
:
gfx
:
:
CompositorHitTestInfo
GetCompositorHitTestInfo
(
nsDisplayListBuilder
*
aBuilder
)
;
protected
:
static
void
DestroyAnonymousContent
(
nsPresContext
*
aPresContext
already_AddRefed
<
nsIContent
>
&
&
aContent
)
;
void
ReparentFrameViewTo
(
nsViewManager
*
aViewManager
nsView
*
aNewParentView
nsView
*
aOldParentView
)
;
virtual
bool
IsLeafDynamic
(
)
const
{
return
false
;
}
nsRect
mRect
;
nsCOMPtr
<
nsIContent
>
mContent
;
RefPtr
<
ComputedStyle
>
mComputedStyle
;
private
:
nsPresContext
*
const
mPresContext
;
nsContainerFrame
*
mParent
;
nsIFrame
*
mNextSibling
;
nsIFrame
*
mPrevSibling
;
DisplayItemDataArray
mDisplayItemData
;
void
MarkAbsoluteFramesForDisplayList
(
nsDisplayListBuilder
*
aBuilder
)
;
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
PaintedPresShellsProperty
nsTArray
<
nsWeakPtr
>
)
nsTArray
<
nsWeakPtr
>
*
PaintedPresShellList
(
)
{
bool
found
;
nsTArray
<
nsWeakPtr
>
*
list
=
GetProperty
(
PaintedPresShellsProperty
(
)
&
found
)
;
if
(
!
found
)
{
list
=
new
nsTArray
<
nsWeakPtr
>
(
)
;
AddProperty
(
PaintedPresShellsProperty
(
)
list
)
;
}
else
{
MOZ_ASSERT
(
list
"
this
property
should
only
store
non
-
null
values
"
)
;
}
return
list
;
}
protected
:
inline
void
PropagateRootElementWritingMode
(
mozilla
:
:
WritingMode
aRootElemWM
)
;
void
MarkInReflow
(
)
{
#
ifdef
DEBUG_dbaron_off
NS_ASSERTION
(
!
(
mState
&
NS_FRAME_IN_REFLOW
)
"
frame
is
already
in
reflow
"
)
;
#
endif
AddStateBits
(
NS_FRAME_IN_REFLOW
)
;
}
nsFrameState
mState
;
FrameProperties
mProperties
;
struct
VisualDeltas
{
uint8_t
mLeft
;
uint8_t
mTop
;
uint8_t
mRight
;
uint8_t
mBottom
;
bool
operator
=
=
(
const
VisualDeltas
&
aOther
)
const
{
return
mLeft
=
=
aOther
.
mLeft
&
&
mTop
=
=
aOther
.
mTop
&
&
mRight
=
=
aOther
.
mRight
&
&
mBottom
=
=
aOther
.
mBottom
;
}
bool
operator
!
=
(
const
VisualDeltas
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
}
;
union
{
uint32_t
mType
;
VisualDeltas
mVisualDeltas
;
}
mOverflow
;
mozilla
:
:
WritingMode
mWritingMode
;
ClassID
mClass
;
bool
mMayHaveRoundedCorners
:
1
;
bool
mHasImageRequest
:
1
;
bool
mHasFirstLetterChild
:
1
;
bool
mParentIsWrapperAnonBox
:
1
;
bool
mIsWrapperBoxNeedingRestyle
:
1
;
bool
mReflowRequestedForCharDataChange
:
1
;
bool
mForceDescendIntoIfVisible
:
1
;
bool
mBuiltDisplayList
:
1
;
bool
mFrameIsModified
:
1
;
bool
mHasOverrideDirtyRegion
:
1
;
bool
mMayHaveWillChangeBudget
:
1
;
private
:
bool
mIsPrimaryFrame
:
1
;
bool
mMayHaveTransformAnimation
:
1
;
bool
mMayHaveOpacityAnimation
:
1
;
bool
mAllDescendantsAreInvisible
:
1
;
bool
mInScrollAnchorChain
:
1
;
protected
:
virtual
FrameSearchResult
PeekOffsetNoAmount
(
bool
aForward
int32_t
*
aOffset
)
=
0
;
virtual
FrameSearchResult
PeekOffsetCharacter
(
bool
aForward
int32_t
*
aOffset
PeekOffsetCharacterOptions
aOptions
=
PeekOffsetCharacterOptions
(
)
)
=
0
;
static_assert
(
sizeof
(
PeekOffsetCharacterOptions
)
<
=
sizeof
(
intptr_t
)
"
aOptions
should
be
changed
to
const
reference
"
)
;
struct
PeekWordState
{
bool
mAtStart
;
bool
mSawBeforeType
;
bool
mLastCharWasPunctuation
;
bool
mLastCharWasWhitespace
;
bool
mSeenNonPunctuationSinceWhitespace
;
nsAutoString
mContext
;
PeekWordState
(
)
:
mAtStart
(
true
)
mSawBeforeType
(
false
)
mLastCharWasPunctuation
(
false
)
mLastCharWasWhitespace
(
false
)
mSeenNonPunctuationSinceWhitespace
(
false
)
{
}
void
SetSawBeforeType
(
)
{
mSawBeforeType
=
true
;
}
void
Update
(
bool
aAfterPunctuation
bool
aAfterWhitespace
)
{
mLastCharWasPunctuation
=
aAfterPunctuation
;
mLastCharWasWhitespace
=
aAfterWhitespace
;
if
(
aAfterWhitespace
)
{
mSeenNonPunctuationSinceWhitespace
=
false
;
}
else
if
(
!
aAfterPunctuation
)
{
mSeenNonPunctuationSinceWhitespace
=
true
;
}
mAtStart
=
false
;
}
}
;
virtual
FrameSearchResult
PeekOffsetWord
(
bool
aForward
bool
aWordSelectEatSpace
bool
aIsKeyboardSelect
int32_t
*
aOffset
PeekWordState
*
aState
bool
aTrimSpaces
)
=
0
;
nsresult
PeekOffsetParagraph
(
nsPeekOffsetStruct
*
aPos
)
;
private
:
nsOverflowAreas
*
GetOverflowAreasProperty
(
)
const
{
MOZ_ASSERT
(
mOverflow
.
mType
=
=
NS_FRAME_OVERFLOW_LARGE
)
;
nsOverflowAreas
*
overflow
=
GetProperty
(
OverflowAreasProperty
(
)
)
;
MOZ_ASSERT
(
overflow
)
;
return
overflow
;
}
nsRect
GetVisualOverflowFromDeltas
(
)
const
{
MOZ_ASSERT
(
mOverflow
.
mType
!
=
NS_FRAME_OVERFLOW_LARGE
"
should
not
be
called
when
overflow
is
in
a
property
"
)
;
return
nsRect
(
-
(
int32_t
)
mOverflow
.
mVisualDeltas
.
mLeft
-
(
int32_t
)
mOverflow
.
mVisualDeltas
.
mTop
mRect
.
Width
(
)
+
mOverflow
.
mVisualDeltas
.
mRight
+
mOverflow
.
mVisualDeltas
.
mLeft
mRect
.
Height
(
)
+
mOverflow
.
mVisualDeltas
.
mBottom
+
mOverflow
.
mVisualDeltas
.
mTop
)
;
}
bool
SetOverflowAreas
(
const
nsOverflowAreas
&
aOverflowAreas
)
;
template
<
bool
IsLessThanOrEqual
(
nsIFrame
*
nsIFrame
*
)
>
static
nsIFrame
*
SortedMerge
(
nsIFrame
*
aLeft
nsIFrame
*
aRight
)
;
template
<
bool
IsLessThanOrEqual
(
nsIFrame
*
nsIFrame
*
)
>
static
nsIFrame
*
MergeSort
(
nsIFrame
*
aSource
)
;
bool
HasOpacityInternal
(
float
aThreshold
const
nsStyleDisplay
*
aStyleDisplay
const
nsStyleEffects
*
aStyleEffects
mozilla
:
:
EffectSet
*
aEffectSet
=
nullptr
)
const
;
static
const
mozilla
:
:
LayoutFrameType
sLayoutFrameTypes
[
#
define
FRAME_ID
(
.
.
.
)
1
+
#
define
ABSTRACT_FRAME_ID
(
.
.
.
)
#
include
"
nsFrameIdList
.
h
"
#
undef
FRAME_ID
#
undef
ABSTRACT_FRAME_ID
0
]
;
enum
FrameClassBits
{
eFrameClassBitsNone
=
0x0
eFrameClassBitsLeaf
=
0x1
eFrameClassBitsDynamicLeaf
=
0x2
}
;
static
const
FrameClassBits
sFrameClassBits
[
#
define
FRAME_ID
(
.
.
.
)
1
+
#
define
ABSTRACT_FRAME_ID
(
.
.
.
)
#
include
"
nsFrameIdList
.
h
"
#
undef
FRAME_ID
#
undef
ABSTRACT_FRAME_ID
0
]
;
#
ifdef
DEBUG_FRAME_DUMP
public
:
static
void
IndentBy
(
FILE
*
out
int32_t
aIndent
)
{
while
(
-
-
aIndent
>
=
0
)
fputs
(
"
"
out
)
;
}
void
ListTag
(
FILE
*
out
)
const
{
fputs
(
ListTag
(
)
.
get
(
)
out
)
;
}
nsAutoCString
ListTag
(
)
const
;
void
ListGeneric
(
nsACString
&
aTo
const
char
*
aPrefix
=
"
"
uint32_t
aFlags
=
0
)
const
;
enum
{
TRAVERSE_SUBDOCUMENT_FRAMES
=
0x01
}
;
virtual
void
List
(
FILE
*
out
=
stderr
const
char
*
aPrefix
=
"
"
uint32_t
aFlags
=
0
)
const
;
static
void
RootFrameList
(
nsPresContext
*
aPresContext
FILE
*
out
=
stderr
const
char
*
aPrefix
=
"
"
)
;
virtual
void
DumpFrameTree
(
)
const
;
void
DumpFrameTreeLimited
(
)
const
;
virtual
nsresult
GetFrameName
(
nsAString
&
aResult
)
const
=
0
;
#
endif
}
;
class
WeakFrame
;
class
MOZ_NONHEAP_CLASS
AutoWeakFrame
{
public
:
explicit
AutoWeakFrame
(
)
:
mPrev
(
nullptr
)
mFrame
(
nullptr
)
{
}
AutoWeakFrame
(
const
AutoWeakFrame
&
aOther
)
:
mPrev
(
nullptr
)
mFrame
(
nullptr
)
{
Init
(
aOther
.
GetFrame
(
)
)
;
}
MOZ_IMPLICIT
AutoWeakFrame
(
const
WeakFrame
&
aOther
)
;
MOZ_IMPLICIT
AutoWeakFrame
(
nsIFrame
*
aFrame
)
:
mPrev
(
nullptr
)
mFrame
(
nullptr
)
{
Init
(
aFrame
)
;
}
AutoWeakFrame
&
operator
=
(
AutoWeakFrame
&
aOther
)
{
Init
(
aOther
.
GetFrame
(
)
)
;
return
*
this
;
}
AutoWeakFrame
&
operator
=
(
nsIFrame
*
aFrame
)
{
Init
(
aFrame
)
;
return
*
this
;
}
nsIFrame
*
operator
-
>
(
)
{
return
mFrame
;
}
operator
nsIFrame
*
(
)
{
return
mFrame
;
}
void
Clear
(
mozilla
:
:
PresShell
*
aPresShell
)
{
if
(
aPresShell
)
{
aPresShell
-
>
RemoveAutoWeakFrame
(
this
)
;
}
mFrame
=
nullptr
;
mPrev
=
nullptr
;
}
bool
IsAlive
(
)
{
return
!
!
mFrame
;
}
nsIFrame
*
GetFrame
(
)
const
{
return
mFrame
;
}
AutoWeakFrame
*
GetPreviousWeakFrame
(
)
{
return
mPrev
;
}
void
SetPreviousWeakFrame
(
AutoWeakFrame
*
aPrev
)
{
mPrev
=
aPrev
;
}
~
AutoWeakFrame
(
)
{
Clear
(
mFrame
?
mFrame
-
>
PresContext
(
)
-
>
GetPresShell
(
)
:
nullptr
)
;
}
private
:
void
*
operator
new
(
size_t
)
=
delete
;
void
*
operator
new
[
]
(
size_t
)
=
delete
;
void
operator
delete
(
void
*
)
=
delete
;
void
operator
delete
[
]
(
void
*
)
=
delete
;
void
Init
(
nsIFrame
*
aFrame
)
;
AutoWeakFrame
*
mPrev
;
nsIFrame
*
mFrame
;
}
;
inline
do_QueryFrameHelper
<
nsIFrame
>
do_QueryFrame
(
AutoWeakFrame
&
s
)
{
return
do_QueryFrameHelper
<
nsIFrame
>
(
s
.
GetFrame
(
)
)
;
}
class
MOZ_HEAP_CLASS
WeakFrame
{
public
:
WeakFrame
(
)
:
mFrame
(
nullptr
)
{
}
WeakFrame
(
const
WeakFrame
&
aOther
)
:
mFrame
(
nullptr
)
{
Init
(
aOther
.
GetFrame
(
)
)
;
}
MOZ_IMPLICIT
WeakFrame
(
const
AutoWeakFrame
&
aOther
)
:
mFrame
(
nullptr
)
{
Init
(
aOther
.
GetFrame
(
)
)
;
}
MOZ_IMPLICIT
WeakFrame
(
nsIFrame
*
aFrame
)
:
mFrame
(
nullptr
)
{
Init
(
aFrame
)
;
}
~
WeakFrame
(
)
{
Clear
(
mFrame
?
mFrame
-
>
PresContext
(
)
-
>
GetPresShell
(
)
:
nullptr
)
;
}
WeakFrame
&
operator
=
(
WeakFrame
&
aOther
)
{
Init
(
aOther
.
GetFrame
(
)
)
;
return
*
this
;
}
WeakFrame
&
operator
=
(
nsIFrame
*
aFrame
)
{
Init
(
aFrame
)
;
return
*
this
;
}
nsIFrame
*
operator
-
>
(
)
{
return
mFrame
;
}
operator
nsIFrame
*
(
)
{
return
mFrame
;
}
void
Clear
(
mozilla
:
:
PresShell
*
aPresShell
)
{
if
(
aPresShell
)
{
aPresShell
-
>
RemoveWeakFrame
(
this
)
;
}
mFrame
=
nullptr
;
}
bool
IsAlive
(
)
{
return
!
!
mFrame
;
}
nsIFrame
*
GetFrame
(
)
const
{
return
mFrame
;
}
private
:
void
Init
(
nsIFrame
*
aFrame
)
;
nsIFrame
*
mFrame
;
}
;
inline
do_QueryFrameHelper
<
nsIFrame
>
do_QueryFrame
(
WeakFrame
&
s
)
{
return
do_QueryFrameHelper
<
nsIFrame
>
(
s
.
GetFrame
(
)
)
;
}
inline
bool
nsFrameList
:
:
ContinueRemoveFrame
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
!
aFrame
-
>
GetPrevSibling
(
)
|
|
!
aFrame
-
>
GetNextSibling
(
)
"
Forgot
to
call
StartRemoveFrame
?
"
)
;
if
(
aFrame
=
=
mLastChild
)
{
MOZ_ASSERT
(
!
aFrame
-
>
GetNextSibling
(
)
"
broken
frame
list
"
)
;
nsIFrame
*
prevSibling
=
aFrame
-
>
GetPrevSibling
(
)
;
if
(
!
prevSibling
)
{
MOZ_ASSERT
(
aFrame
=
=
mFirstChild
"
broken
frame
list
"
)
;
mFirstChild
=
mLastChild
=
nullptr
;
return
true
;
}
MOZ_ASSERT
(
prevSibling
-
>
GetNextSibling
(
)
=
=
aFrame
"
Broken
frame
linkage
"
)
;
prevSibling
-
>
SetNextSibling
(
nullptr
)
;
mLastChild
=
prevSibling
;
return
true
;
}
if
(
aFrame
=
=
mFirstChild
)
{
MOZ_ASSERT
(
!
aFrame
-
>
GetPrevSibling
(
)
"
broken
frame
list
"
)
;
mFirstChild
=
aFrame
-
>
GetNextSibling
(
)
;
aFrame
-
>
SetNextSibling
(
nullptr
)
;
MOZ_ASSERT
(
mFirstChild
"
broken
frame
list
"
)
;
return
true
;
}
return
false
;
}
inline
bool
nsFrameList
:
:
StartRemoveFrame
(
nsIFrame
*
aFrame
)
{
if
(
aFrame
-
>
GetPrevSibling
(
)
&
&
aFrame
-
>
GetNextSibling
(
)
)
{
UnhookFrameFromSiblings
(
aFrame
)
;
return
true
;
}
return
ContinueRemoveFrame
(
aFrame
)
;
}
inline
void
nsFrameList
:
:
Enumerator
:
:
Next
(
)
{
NS_ASSERTION
(
!
AtEnd
(
)
"
Should
have
checked
AtEnd
(
)
!
"
)
;
mFrame
=
mFrame
-
>
GetNextSibling
(
)
;
}
inline
nsFrameList
:
:
FrameLinkEnumerator
:
:
FrameLinkEnumerator
(
const
nsFrameList
&
aList
nsIFrame
*
aPrevFrame
)
:
Enumerator
(
aList
)
{
mPrev
=
aPrevFrame
;
mFrame
=
aPrevFrame
?
aPrevFrame
-
>
GetNextSibling
(
)
:
aList
.
FirstChild
(
)
;
}
inline
void
nsFrameList
:
:
FrameLinkEnumerator
:
:
Next
(
)
{
mPrev
=
mFrame
;
Enumerator
:
:
Next
(
)
;
}
template
<
typename
Predicate
>
inline
void
nsFrameList
:
:
FrameLinkEnumerator
:
:
Find
(
Predicate
&
&
aPredicate
)
{
static_assert
(
std
:
:
is_same
<
typename
mozilla
:
:
FunctionTypeTraits
<
Predicate
>
:
:
ReturnType
bool
>
:
:
value
&
&
mozilla
:
:
FunctionTypeTraits
<
Predicate
>
:
:
arity
=
=
1
&
&
std
:
:
is_same
<
typename
mozilla
:
:
FunctionTypeTraits
<
Predicate
>
:
:
template
ParameterType
<
0
>
nsIFrame
*
>
:
:
value
"
aPredicate
should
be
of
this
function
signature
:
bool
(
nsIFrame
*
)
"
)
;
for
(
;
!
AtEnd
(
)
;
Next
(
)
)
{
if
(
aPredicate
(
mFrame
)
)
{
return
;
}
}
}
inline
nsFrameList
:
:
Iterator
&
nsFrameList
:
:
Iterator
:
:
operator
+
+
(
)
{
mCurrent
=
mCurrent
-
>
GetNextSibling
(
)
;
return
*
this
;
}
inline
nsFrameList
:
:
Iterator
&
nsFrameList
:
:
Iterator
:
:
operator
-
-
(
)
{
if
(
!
mCurrent
)
{
mCurrent
=
mList
.
LastChild
(
)
;
}
else
{
mCurrent
=
mCurrent
-
>
GetPrevSibling
(
)
;
}
return
*
this
;
}
template
<
bool
IsLessThanOrEqual
(
nsIFrame
*
nsIFrame
*
)
>
nsIFrame
*
nsIFrame
:
:
SortedMerge
(
nsIFrame
*
aLeft
nsIFrame
*
aRight
)
{
MOZ_ASSERT
(
aLeft
&
&
aRight
"
SortedMerge
must
have
non
-
empty
lists
"
)
;
nsIFrame
*
result
;
if
(
IsLessThanOrEqual
(
aLeft
aRight
)
)
{
result
=
aLeft
;
aLeft
=
aLeft
-
>
GetNextSibling
(
)
;
if
(
!
aLeft
)
{
result
-
>
SetNextSibling
(
aRight
)
;
return
result
;
}
}
else
{
result
=
aRight
;
aRight
=
aRight
-
>
GetNextSibling
(
)
;
if
(
!
aRight
)
{
result
-
>
SetNextSibling
(
aLeft
)
;
return
result
;
}
}
nsIFrame
*
last
=
result
;
for
(
;
;
)
{
if
(
IsLessThanOrEqual
(
aLeft
aRight
)
)
{
last
-
>
SetNextSibling
(
aLeft
)
;
last
=
aLeft
;
aLeft
=
aLeft
-
>
GetNextSibling
(
)
;
if
(
!
aLeft
)
{
last
-
>
SetNextSibling
(
aRight
)
;
return
result
;
}
}
else
{
last
-
>
SetNextSibling
(
aRight
)
;
last
=
aRight
;
aRight
=
aRight
-
>
GetNextSibling
(
)
;
if
(
!
aRight
)
{
last
-
>
SetNextSibling
(
aLeft
)
;
return
result
;
}
}
}
}
template
<
bool
IsLessThanOrEqual
(
nsIFrame
*
nsIFrame
*
)
>
nsIFrame
*
nsIFrame
:
:
MergeSort
(
nsIFrame
*
aSource
)
{
MOZ_ASSERT
(
aSource
"
MergeSort
null
arg
"
)
;
nsIFrame
*
sorted
[
32
]
=
{
nullptr
}
;
nsIFrame
*
*
fill
=
&
sorted
[
0
]
;
nsIFrame
*
*
left
;
nsIFrame
*
rest
=
aSource
;
do
{
nsIFrame
*
current
=
rest
;
rest
=
rest
-
>
GetNextSibling
(
)
;
current
-
>
SetNextSibling
(
nullptr
)
;
for
(
left
=
&
sorted
[
0
]
;
left
!
=
fill
&
&
*
left
;
+
+
left
)
{
current
=
SortedMerge
<
IsLessThanOrEqual
>
(
*
left
current
)
;
*
left
=
nullptr
;
}
*
left
=
current
;
if
(
left
=
=
fill
)
+
+
fill
;
}
while
(
rest
)
;
nsIFrame
*
result
=
nullptr
;
for
(
left
=
&
sorted
[
0
]
;
left
!
=
fill
;
+
+
left
)
{
if
(
*
left
)
{
result
=
result
?
SortedMerge
<
IsLessThanOrEqual
>
(
*
left
result
)
:
*
left
;
}
}
return
result
;
}
template
<
bool
IsLessThanOrEqual
(
nsIFrame
*
nsIFrame
*
)
>
void
nsIFrame
:
:
SortFrameList
(
nsFrameList
&
aFrameList
)
{
nsIFrame
*
head
=
MergeSort
<
IsLessThanOrEqual
>
(
aFrameList
.
FirstChild
(
)
)
;
aFrameList
=
nsFrameList
(
head
nsLayoutUtils
:
:
GetLastSibling
(
head
)
)
;
MOZ_ASSERT
(
IsFrameListSorted
<
IsLessThanOrEqual
>
(
aFrameList
)
"
After
we
sort
a
frame
list
it
should
be
in
sorted
order
.
.
.
"
)
;
}
template
<
bool
IsLessThanOrEqual
(
nsIFrame
*
nsIFrame
*
)
>
bool
nsIFrame
:
:
IsFrameListSorted
(
nsFrameList
&
aFrameList
)
{
if
(
aFrameList
.
IsEmpty
(
)
)
{
return
true
;
}
nsFrameList
:
:
Enumerator
trailingIter
(
aFrameList
)
;
nsFrameList
:
:
Enumerator
iter
(
aFrameList
)
;
iter
.
Next
(
)
;
while
(
!
iter
.
AtEnd
(
)
)
{
MOZ_ASSERT
(
!
trailingIter
.
AtEnd
(
)
"
trailing
iter
shouldn
'
t
finish
first
"
)
;
if
(
!
IsLessThanOrEqual
(
trailingIter
.
get
(
)
iter
.
get
(
)
)
)
{
return
false
;
}
trailingIter
.
Next
(
)
;
iter
.
Next
(
)
;
}
return
true
;
}
nsPoint
nsIFrame
:
:
GetNormalPosition
(
bool
*
aHasProperty
)
const
{
nsPoint
*
normalPosition
=
GetProperty
(
NormalPositionProperty
(
)
)
;
if
(
normalPosition
)
{
if
(
aHasProperty
)
{
*
aHasProperty
=
true
;
}
return
*
normalPosition
;
}
if
(
aHasProperty
)
{
*
aHasProperty
=
false
;
}
return
GetPosition
(
)
;
}
#
endif
