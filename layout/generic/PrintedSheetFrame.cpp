#
include
"
mozilla
/
PrintedSheetFrame
.
h
"
#
include
"
mozilla
/
StaticPrefs_print
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
nsPageFrame
.
h
"
#
include
"
nsPageSequenceFrame
.
h
"
using
namespace
mozilla
;
PrintedSheetFrame
*
NS_NewPrintedSheetFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
PrintedSheetFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
namespace
mozilla
{
NS_QUERYFRAME_HEAD
(
PrintedSheetFrame
)
NS_QUERYFRAME_ENTRY
(
PrintedSheetFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsContainerFrame
)
NS_IMPL_FRAMEARENA_HELPERS
(
PrintedSheetFrame
)
void
PrintedSheetFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
if
(
PresContext
(
)
-
>
IsScreen
(
)
)
{
DisplayBorderBackgroundOutline
(
aBuilder
aLists
)
;
}
for
(
auto
*
frame
:
mFrames
)
{
if
(
!
frame
-
>
HasAnyStateBits
(
NS_PAGE_SKIPPED_BY_CUSTOM_RANGE
)
)
{
BuildDisplayListForChild
(
aBuilder
frame
aLists
)
;
}
}
}
static
bool
TagIfSkippedByCustomRange
(
nsPageFrame
*
aPageFrame
int32_t
aPageNum
nsSharedPageData
*
aPD
)
{
if
(
!
StaticPrefs
:
:
print_tab_modal_enabled
(
)
|
|
!
aPageFrame
-
>
PresContext
(
)
-
>
IsScreen
(
)
)
{
return
false
;
}
if
(
!
aPD
-
>
mDoingPageRange
)
{
MOZ_ASSERT
(
!
aPageFrame
-
>
HasAnyStateBits
(
NS_PAGE_SKIPPED_BY_CUSTOM_RANGE
)
"
page
frames
shouldn
'
t
be
tagged
as
skipped
if
we
'
re
not
"
"
printing
with
a
custom
page
range
"
)
;
return
false
;
}
bool
isPageSkipped
=
false
;
if
(
aPageNum
<
aPD
-
>
mFromPageNum
|
|
aPageNum
>
aPD
-
>
mToPageNum
)
{
isPageSkipped
=
true
;
}
else
{
const
auto
&
ranges
=
aPD
-
>
mPageRanges
;
int32_t
length
=
ranges
.
Length
(
)
;
if
(
length
&
&
(
length
%
2
=
=
0
)
)
{
isPageSkipped
=
true
;
for
(
int32_t
i
=
0
;
i
<
length
;
i
+
=
2
)
{
if
(
ranges
[
i
]
<
=
aPageNum
&
&
aPageNum
<
=
ranges
[
i
+
1
]
)
{
isPageSkipped
=
false
;
break
;
}
}
}
}
if
(
!
isPageSkipped
)
{
MOZ_ASSERT
(
!
aPageFrame
-
>
HasAnyStateBits
(
NS_PAGE_SKIPPED_BY_CUSTOM_RANGE
)
"
page
frames
NS_PAGE_SKIPPED_BY_CUSTOM_RANGE
state
should
"
"
only
be
set
if
we
actually
want
to
skip
the
page
"
)
;
return
false
;
}
aPageFrame
-
>
AddStateBits
(
NS_PAGE_SKIPPED_BY_CUSTOM_RANGE
)
;
return
true
;
}
void
PrintedSheetFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aReflowOutput
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
PrintedSheetFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aReflowOutput
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
MoveOverflowToChildList
(
)
;
const
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
const
nsSize
physPageSize
=
aPresContext
-
>
GetPageSize
(
)
;
const
LogicalSize
pageSize
(
wm
physPageSize
)
;
uint32_t
numPagesOnThisSheet
=
0
;
static
const
uint32_t
kDesiredPagesPerSheet
=
1
;
for
(
auto
*
childFrame
=
mFrames
.
FirstChild
(
)
;
childFrame
;
childFrame
=
childFrame
-
>
GetNextSibling
(
)
)
{
MOZ_ASSERT
(
childFrame
-
>
IsPageFrame
(
)
"
we
'
re
only
expecting
page
frames
as
children
"
)
;
auto
*
pageFrame
=
static_cast
<
nsPageFrame
*
>
(
childFrame
)
;
pageFrame
-
>
SetSharedPageData
(
mPD
)
;
pageFrame
-
>
DeterminePageNum
(
)
;
if
(
!
TagIfSkippedByCustomRange
(
pageFrame
pageFrame
-
>
GetPageNum
(
)
mPD
)
)
{
numPagesOnThisSheet
+
+
;
}
ReflowInput
pageReflowInput
(
aPresContext
aReflowInput
pageFrame
pageSize
)
;
LogicalPoint
pagePos
(
wm
)
;
ReflowOutput
pageReflowOutput
(
pageReflowInput
)
;
nsReflowStatus
status
;
ReflowChild
(
pageFrame
aPresContext
pageReflowOutput
pageReflowInput
wm
pagePos
physPageSize
ReflowChildFlags
:
:
Default
status
)
;
FinishReflowChild
(
pageFrame
aPresContext
pageReflowOutput
&
pageReflowInput
wm
pagePos
physPageSize
ReflowChildFlags
:
:
Default
)
;
NS_ASSERTION
(
!
pageFrame
-
>
GetNextInFlow
(
)
"
bad
child
flow
list
"
)
;
if
(
status
.
IsFullyComplete
(
)
)
{
mPD
-
>
mRawNumPages
=
pageFrame
-
>
GetPageNum
(
)
;
}
else
{
nsIFrame
*
continuingPage
=
PresShell
(
)
-
>
FrameConstructor
(
)
-
>
CreateContinuingFrame
(
pageFrame
this
)
;
mFrames
.
InsertFrame
(
nullptr
pageFrame
continuingPage
)
;
const
bool
isContinuingPageSkipped
=
TagIfSkippedByCustomRange
(
static_cast
<
nsPageFrame
*
>
(
continuingPage
)
pageFrame
-
>
GetPageNum
(
)
+
1
mPD
)
;
if
(
numPagesOnThisSheet
=
=
kDesiredPagesPerSheet
&
&
!
isContinuingPageSkipped
)
{
PushChildrenToOverflow
(
continuingPage
pageFrame
)
;
aStatus
.
SetIncomplete
(
)
;
}
}
}
if
(
!
GetPrevContinuation
(
)
)
{
NS_WARNING_ASSERTION
(
numPagesOnThisSheet
>
0
"
Shouldn
'
t
create
a
sheet
with
no
displayable
pages
"
"
on
it
"
)
;
}
else
{
MOZ_ASSERT
(
numPagesOnThisSheet
>
0
"
Shouldn
'
t
create
a
sheet
with
no
displayable
pages
on
it
"
)
;
}
MOZ_ASSERT
(
numPagesOnThisSheet
<
=
kDesiredPagesPerSheet
"
Shouldn
'
t
have
more
than
desired
number
of
displayable
pages
"
"
on
this
sheet
"
)
;
aReflowOutput
.
ISize
(
wm
)
=
aReflowInput
.
AvailableISize
(
)
;
if
(
aReflowInput
.
AvailableBSize
(
)
!
=
NS_UNCONSTRAINEDSIZE
)
{
aReflowOutput
.
BSize
(
wm
)
=
aReflowInput
.
AvailableBSize
(
)
;
}
aReflowOutput
.
SetOverflowAreasToDesiredBounds
(
)
;
FinishAndStoreOverflow
(
&
aReflowOutput
)
;
NS_FRAME_SET_TRUNCATION
(
aStatus
aReflowInput
aReflowOutput
)
;
}
void
PrintedSheetFrame
:
:
AppendDirectlyOwnedAnonBoxes
(
nsTArray
<
OwnedAnonBox
>
&
aResult
)
{
MOZ_ASSERT
(
mFrames
.
FirstChild
(
)
&
&
mFrames
.
FirstChild
(
)
-
>
IsPageFrame
(
)
"
PrintedSheetFrame
must
have
a
nsPageFrame
child
"
)
;
aResult
.
AppendElement
(
mFrames
.
FirstChild
(
)
)
;
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
PrintedSheetFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
u
"
PrintedSheet
"
_ns
aResult
)
;
}
#
endif
}
