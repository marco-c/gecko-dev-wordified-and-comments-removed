#
include
"
PrintedSheetFrame
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
nsPageFrame
.
h
"
using
namespace
mozilla
;
PrintedSheetFrame
*
NS_NewPrintedSheetFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
PrintedSheetFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
namespace
mozilla
{
NS_QUERYFRAME_HEAD
(
PrintedSheetFrame
)
NS_QUERYFRAME_ENTRY
(
PrintedSheetFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsContainerFrame
)
NS_IMPL_FRAMEARENA_HELPERS
(
PrintedSheetFrame
)
void
PrintedSheetFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
if
(
PresContext
(
)
-
>
IsScreen
(
)
)
{
DisplayBorderBackgroundOutline
(
aBuilder
aLists
)
;
}
for
(
auto
*
frame
:
mFrames
)
{
BuildDisplayListForChild
(
aBuilder
frame
aLists
)
;
}
}
void
PrintedSheetFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aReflowOutput
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
PrintedSheetFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aReflowOutput
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
MoveOverflowToChildList
(
)
;
const
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
const
nsSize
physPageSize
=
aPresContext
-
>
GetPageSize
(
)
;
const
LogicalSize
pageSize
(
wm
physPageSize
)
;
MOZ_ASSERT
(
mFrames
.
GetLength
(
)
=
=
1
"
how
did
we
get
more
than
one
page
per
sheet
"
)
;
for
(
auto
*
childFrame
:
mFrames
)
{
MOZ_ASSERT
(
childFrame
-
>
IsPageFrame
(
)
"
we
'
re
only
expecting
page
frames
as
children
"
)
;
auto
*
pageFrame
=
static_cast
<
nsPageFrame
*
>
(
childFrame
)
;
pageFrame
-
>
SetSharedPageData
(
mPD
)
;
ReflowInput
pageReflowInput
(
aPresContext
aReflowInput
pageFrame
pageSize
)
;
LogicalPoint
pagePos
(
wm
)
;
ReflowOutput
pageReflowOutput
(
pageReflowInput
)
;
nsReflowStatus
status
;
ReflowChild
(
pageFrame
aPresContext
pageReflowOutput
pageReflowInput
wm
pagePos
physPageSize
ReflowChildFlags
:
:
Default
status
)
;
FinishReflowChild
(
pageFrame
aPresContext
pageReflowOutput
&
pageReflowInput
wm
pagePos
physPageSize
ReflowChildFlags
:
:
Default
)
;
nsIFrame
*
pageNextInFlow
=
pageFrame
-
>
GetNextInFlow
(
)
;
if
(
status
.
IsFullyComplete
(
)
)
{
NS_ASSERTION
(
!
pageNextInFlow
"
bad
child
flow
list
"
)
;
}
else
{
aStatus
.
SetIncomplete
(
)
;
if
(
!
pageNextInFlow
)
{
nsIFrame
*
continuingPage
=
PresShell
(
)
-
>
FrameConstructor
(
)
-
>
CreateContinuingFrame
(
pageFrame
this
)
;
mFrames
.
InsertFrame
(
nullptr
pageFrame
continuingPage
)
;
PushChildrenToOverflow
(
continuingPage
pageFrame
)
;
}
}
}
aReflowOutput
.
ISize
(
wm
)
=
aReflowInput
.
AvailableISize
(
)
;
if
(
aReflowInput
.
AvailableBSize
(
)
!
=
NS_UNCONSTRAINEDSIZE
)
{
aReflowOutput
.
BSize
(
wm
)
=
aReflowInput
.
AvailableBSize
(
)
;
}
aReflowOutput
.
SetOverflowAreasToDesiredBounds
(
)
;
FinishAndStoreOverflow
(
&
aReflowOutput
)
;
NS_FRAME_SET_TRUNCATION
(
aStatus
aReflowInput
aReflowOutput
)
;
}
void
PrintedSheetFrame
:
:
AppendDirectlyOwnedAnonBoxes
(
nsTArray
<
OwnedAnonBox
>
&
aResult
)
{
MOZ_ASSERT
(
mFrames
.
FirstChild
(
)
&
&
mFrames
.
FirstChild
(
)
-
>
IsPageFrame
(
)
"
PrintedSheetFrame
must
have
a
nsPageFrame
child
"
)
;
aResult
.
AppendElement
(
mFrames
.
FirstChild
(
)
)
;
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
PrintedSheetFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
u
"
PrintedSheet
"
_ns
aResult
)
;
}
#
endif
}
