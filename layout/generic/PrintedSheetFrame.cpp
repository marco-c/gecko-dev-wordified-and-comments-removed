#
include
"
mozilla
/
PrintedSheetFrame
.
h
"
#
include
<
tuple
>
#
include
"
mozilla
/
StaticPrefs_print
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
nsPageFrame
.
h
"
#
include
"
nsPageSequenceFrame
.
h
"
using
namespace
mozilla
;
PrintedSheetFrame
*
NS_NewPrintedSheetFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
PrintedSheetFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
namespace
mozilla
{
NS_QUERYFRAME_HEAD
(
PrintedSheetFrame
)
NS_QUERYFRAME_ENTRY
(
PrintedSheetFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsContainerFrame
)
NS_IMPL_FRAMEARENA_HELPERS
(
PrintedSheetFrame
)
std
:
:
tuple
<
uint32_t
uint32_t
>
GetRowAndColFromIdx
(
uint32_t
aIdxOnSheet
uint32_t
aNumCols
)
{
return
{
aIdxOnSheet
/
aNumCols
aIdxOnSheet
%
aNumCols
}
;
}
gfx
:
:
Matrix4x4
ComputePagesPerSheetTransform
(
nsIFrame
*
aFrame
float
aAppUnitsPerPixel
)
{
MOZ_ASSERT
(
aFrame
-
>
IsPageFrame
(
)
)
;
auto
*
pageFrame
=
static_cast
<
nsPageFrame
*
>
(
aFrame
)
;
float
scale
=
1
.
0f
;
nsPoint
gridOrigin
;
uint32_t
rowIdx
=
0
;
uint32_t
colIdx
=
0
;
nsSharedPageData
*
pd
=
pageFrame
-
>
GetSharedPageData
(
)
;
if
(
pd
)
{
const
auto
*
ppsInfo
=
pd
-
>
PagesPerSheetInfo
(
)
;
if
(
ppsInfo
-
>
mNumPages
>
1
)
{
scale
=
pd
-
>
mPagesPerSheetScale
;
gridOrigin
=
pd
-
>
mPagesPerSheetGridOrigin
;
std
:
:
tie
(
rowIdx
colIdx
)
=
GetRowAndColFromIdx
(
pageFrame
-
>
IndexOnSheet
(
)
pd
-
>
mPagesPerSheetNumCols
)
;
}
}
auto
transform
=
gfx
:
:
Matrix4x4
:
:
Scaling
(
scale
scale
1
)
;
nsSize
pageSize
=
pageFrame
-
>
PresContext
(
)
-
>
GetPageSize
(
)
;
transform
.
PreTranslate
(
NSAppUnitsToFloatPixels
(
colIdx
*
pageSize
.
width
aAppUnitsPerPixel
)
NSAppUnitsToFloatPixels
(
rowIdx
*
pageSize
.
height
aAppUnitsPerPixel
)
0
)
;
return
transform
.
PostTranslate
(
NSAppUnitsToFloatPixels
(
gridOrigin
.
x
aAppUnitsPerPixel
)
NSAppUnitsToFloatPixels
(
gridOrigin
.
y
aAppUnitsPerPixel
)
0
)
;
}
void
PrintedSheetFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
if
(
PresContext
(
)
-
>
IsScreen
(
)
)
{
DisplayBorderBackgroundOutline
(
aBuilder
aLists
)
;
}
const
nsRect
visible
=
aBuilder
-
>
GetVisibleRect
(
)
;
for
(
auto
*
frame
:
mFrames
)
{
if
(
!
frame
-
>
HasAnyStateBits
(
NS_PAGE_SKIPPED_BY_CUSTOM_RANGE
)
)
{
nsDisplayList
content
;
frame
-
>
BuildDisplayListForStackingContext
(
aBuilder
&
content
)
;
content
.
AppendNewToTop
<
nsDisplayTransform
>
(
aBuilder
frame
&
content
content
.
GetBuildingRect
(
)
ComputePagesPerSheetTransform
)
;
aLists
.
Content
(
)
-
>
AppendToTop
(
&
content
)
;
}
}
}
static
bool
TagIfSkippedByCustomRange
(
nsPageFrame
*
aPageFrame
int32_t
aPageNum
nsSharedPageData
*
aPD
)
{
if
(
!
nsIPrintSettings
:
:
IsPageSkipped
(
aPageNum
aPD
-
>
mPageRanges
)
)
{
MOZ_ASSERT
(
!
aPageFrame
-
>
HasAnyStateBits
(
NS_PAGE_SKIPPED_BY_CUSTOM_RANGE
)
"
page
frames
NS_PAGE_SKIPPED_BY_CUSTOM_RANGE
state
should
"
"
only
be
set
if
we
actually
want
to
skip
the
page
"
)
;
return
false
;
}
aPageFrame
-
>
AddStateBits
(
NS_PAGE_SKIPPED_BY_CUSTOM_RANGE
)
;
return
true
;
}
void
PrintedSheetFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aReflowOutput
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
PrintedSheetFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aReflowOutput
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
MoveOverflowToChildList
(
)
;
const
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
const
nsSize
physPageSize
=
aPresContext
-
>
GetPageSize
(
)
;
const
LogicalSize
pageSize
(
wm
physPageSize
)
;
uint32_t
numPagesOnThisSheet
=
0
;
const
uint32_t
desiredPagesPerSheet
=
mPD
-
>
PagesPerSheetInfo
(
)
-
>
mNumPages
;
if
(
desiredPagesPerSheet
>
1
&
&
!
GetPrevContinuation
(
)
)
{
ComputePagesPerSheetOriginAndScale
(
)
;
}
for
(
auto
*
childFrame
=
mFrames
.
FirstChild
(
)
;
childFrame
;
childFrame
=
childFrame
-
>
GetNextSibling
(
)
)
{
MOZ_ASSERT
(
childFrame
-
>
IsPageFrame
(
)
"
we
'
re
only
expecting
page
frames
as
children
"
)
;
auto
*
pageFrame
=
static_cast
<
nsPageFrame
*
>
(
childFrame
)
;
pageFrame
-
>
SetSharedPageData
(
mPD
)
;
pageFrame
-
>
DeterminePageNum
(
)
;
if
(
!
TagIfSkippedByCustomRange
(
pageFrame
pageFrame
-
>
GetPageNum
(
)
mPD
)
)
{
pageFrame
-
>
SetIndexOnSheet
(
numPagesOnThisSheet
)
;
numPagesOnThisSheet
+
+
;
}
ReflowInput
pageReflowInput
(
aPresContext
aReflowInput
pageFrame
pageSize
)
;
LogicalPoint
pagePos
(
wm
)
;
ReflowOutput
pageReflowOutput
(
pageReflowInput
)
;
nsReflowStatus
status
;
ReflowChild
(
pageFrame
aPresContext
pageReflowOutput
pageReflowInput
wm
pagePos
physPageSize
ReflowChildFlags
:
:
Default
status
)
;
FinishReflowChild
(
pageFrame
aPresContext
pageReflowOutput
&
pageReflowInput
wm
pagePos
physPageSize
ReflowChildFlags
:
:
Default
)
;
NS_ASSERTION
(
!
pageFrame
-
>
GetNextInFlow
(
)
"
bad
child
flow
list
"
)
;
if
(
status
.
IsFullyComplete
(
)
)
{
mPD
-
>
mRawNumPages
=
pageFrame
-
>
GetPageNum
(
)
;
}
else
{
nsIFrame
*
continuingPage
=
PresShell
(
)
-
>
FrameConstructor
(
)
-
>
CreateContinuingFrame
(
pageFrame
this
)
;
mFrames
.
InsertFrame
(
nullptr
pageFrame
continuingPage
)
;
const
bool
isContinuingPageSkipped
=
TagIfSkippedByCustomRange
(
static_cast
<
nsPageFrame
*
>
(
continuingPage
)
pageFrame
-
>
GetPageNum
(
)
+
1
mPD
)
;
if
(
numPagesOnThisSheet
>
=
desiredPagesPerSheet
&
&
!
isContinuingPageSkipped
)
{
PushChildrenToOverflow
(
continuingPage
pageFrame
)
;
aStatus
.
SetIncomplete
(
)
;
}
}
}
if
(
!
GetPrevContinuation
(
)
)
{
NS_WARNING_ASSERTION
(
numPagesOnThisSheet
>
0
"
Shouldn
'
t
create
a
sheet
with
no
displayable
pages
"
"
on
it
"
)
;
}
else
{
MOZ_ASSERT
(
numPagesOnThisSheet
>
0
"
Shouldn
'
t
create
a
sheet
with
no
displayable
pages
on
it
"
)
;
}
MOZ_ASSERT
(
numPagesOnThisSheet
<
=
desiredPagesPerSheet
"
Shouldn
'
t
have
more
than
desired
number
of
displayable
pages
"
"
on
this
sheet
"
)
;
mNumPages
=
numPagesOnThisSheet
;
aReflowOutput
.
ISize
(
wm
)
=
aReflowInput
.
AvailableISize
(
)
;
if
(
aReflowInput
.
AvailableBSize
(
)
!
=
NS_UNCONSTRAINEDSIZE
)
{
aReflowOutput
.
BSize
(
wm
)
=
aReflowInput
.
AvailableBSize
(
)
;
}
aReflowOutput
.
SetOverflowAreasToDesiredBounds
(
)
;
FinishAndStoreOverflow
(
&
aReflowOutput
)
;
NS_FRAME_SET_TRUNCATION
(
aStatus
aReflowInput
aReflowOutput
)
;
}
void
PrintedSheetFrame
:
:
ComputePagesPerSheetOriginAndScale
(
)
{
MOZ_ASSERT
(
mPD
-
>
PagesPerSheetInfo
(
)
-
>
mNumPages
>
1
"
Unnecessary
to
call
this
in
a
regular
1
-
page
-
per
-
sheet
scenario
;
"
"
the
computed
values
won
'
t
ever
be
used
in
that
case
"
)
;
MOZ_ASSERT
(
!
GetPrevContinuation
(
)
"
Only
needs
to
be
called
once
so
1st
continuation
handles
it
"
)
;
const
nsSize
pageSize
=
PresContext
(
)
-
>
GetPageSize
(
)
;
nsSize
availSpaceOnSheet
=
pageSize
;
nsMargin
uwm
=
nsPresContext
:
:
CSSTwipsToAppUnits
(
mPD
-
>
mPrintSettings
-
>
GetUnwriteableMarginInTwips
(
)
)
;
availSpaceOnSheet
.
width
-
=
uwm
.
LeftRight
(
)
;
availSpaceOnSheet
.
height
-
=
uwm
.
TopBottom
(
)
;
nsPoint
pageGridOrigin
(
uwm
.
left
uwm
.
top
)
;
const
auto
*
ppsInfo
=
mPD
-
>
PagesPerSheetInfo
(
)
;
uint32_t
numCols
=
ppsInfo
-
>
mLargerNumTracks
;
uint32_t
numRows
=
ppsInfo
-
>
mNumPages
/
numCols
;
nsSize
pageGridFullSize
(
numCols
*
pageSize
.
width
numRows
*
pageSize
.
height
)
;
if
(
MOZ_UNLIKELY
(
availSpaceOnSheet
.
IsEmpty
(
)
|
|
pageGridFullSize
.
IsEmpty
(
)
)
)
{
NS_WARNING
(
"
Zero
area
for
pages
-
per
-
sheet
grid
or
zero
-
sized
grid
"
)
;
mPD
-
>
mPagesPerSheetGridOrigin
=
pageGridOrigin
;
mPD
-
>
mPagesPerSheetNumCols
=
1
;
mPD
-
>
mPagesPerSheetScale
=
0
.
0f
;
return
;
}
float
hScale
=
availSpaceOnSheet
.
width
/
static_cast
<
float
>
(
pageGridFullSize
.
width
)
;
float
vScale
=
availSpaceOnSheet
.
height
/
static_cast
<
float
>
(
pageGridFullSize
.
height
)
;
float
scale
=
std
:
:
min
(
hScale
vScale
)
;
if
(
hScale
<
vScale
)
{
nscoord
extraSpace
=
availSpaceOnSheet
.
height
-
NSToCoordFloor
(
scale
*
pageGridFullSize
.
height
)
;
if
(
MOZ_LIKELY
(
extraSpace
>
0
)
)
{
pageGridOrigin
.
y
+
=
extraSpace
/
2
;
}
}
else
if
(
vScale
<
hScale
)
{
nscoord
extraSpace
=
availSpaceOnSheet
.
width
-
NSToCoordFloor
(
scale
*
pageGridFullSize
.
width
)
;
if
(
MOZ_LIKELY
(
extraSpace
>
0
)
)
{
pageGridOrigin
.
x
+
=
extraSpace
/
2
;
}
}
mPD
-
>
mPagesPerSheetGridOrigin
=
pageGridOrigin
;
mPD
-
>
mPagesPerSheetNumCols
=
numCols
;
mPD
-
>
mPagesPerSheetScale
=
scale
;
}
void
PrintedSheetFrame
:
:
AppendDirectlyOwnedAnonBoxes
(
nsTArray
<
OwnedAnonBox
>
&
aResult
)
{
MOZ_ASSERT
(
mFrames
.
FirstChild
(
)
&
&
mFrames
.
FirstChild
(
)
-
>
IsPageFrame
(
)
"
PrintedSheetFrame
must
have
a
nsPageFrame
child
"
)
;
aResult
.
AppendElement
(
mFrames
.
FirstChild
(
)
)
;
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
PrintedSheetFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
u
"
PrintedSheet
"
_ns
aResult
)
;
}
#
endif
}
