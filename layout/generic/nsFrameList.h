#
ifndef
nsFrameList_h___
#
define
nsFrameList_h___
#
include
<
stdio
.
h
>
#
include
"
nsDebug
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
FunctionTypeTraits
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
if
defined
(
DEBUG
)
|
|
defined
(
MOZ_DUMP_PAINTING
)
|
|
defined
(
MOZ_LAYOUT_DEBUGGER
)
#
define
DEBUG_FRAME_DUMP
1
#
endif
class
nsContainerFrame
;
class
nsIContent
;
class
nsIFrame
;
class
nsPresContext
;
namespace
mozilla
{
class
PresShell
;
namespace
layout
{
class
FrameChildList
;
enum
FrameChildListID
{
kPrincipalList
kPopupList
kCaptionList
kColGroupList
kAbsoluteList
kFixedList
kOverflowList
kOverflowContainersList
kExcessOverflowContainersList
kOverflowOutOfFlowList
kFloatList
kBulletList
kPushedFloatsList
kBackdropList
kNoReflowPrincipalList
}
;
struct
PostFrameDestroyData
{
PostFrameDestroyData
(
const
PostFrameDestroyData
&
)
=
delete
;
PostFrameDestroyData
(
)
=
default
;
AutoTArray
<
RefPtr
<
nsIContent
>
100
>
mAnonymousContent
;
void
AddAnonymousContent
(
already_AddRefed
<
nsIContent
>
&
&
aContent
)
{
mAnonymousContent
.
AppendElement
(
aContent
)
;
}
}
;
}
}
class
nsFrameList
{
struct
ForwardFrameTraversal
final
{
static
inline
nsIFrame
*
Next
(
nsIFrame
*
)
;
static
inline
nsIFrame
*
Prev
(
nsIFrame
*
)
;
}
;
struct
BackwardFrameTraversal
final
{
static
inline
nsIFrame
*
Next
(
nsIFrame
*
)
;
static
inline
nsIFrame
*
Prev
(
nsIFrame
*
)
;
}
;
public
:
template
<
typename
FrameTraversal
>
class
Iterator
;
class
Slice
;
using
iterator
=
Iterator
<
ForwardFrameTraversal
>
;
using
const_iterator
=
Iterator
<
ForwardFrameTraversal
>
;
using
reverse_iterator
=
Iterator
<
BackwardFrameTraversal
>
;
using
const_reverse_iterator
=
Iterator
<
BackwardFrameTraversal
>
;
nsFrameList
(
)
:
mFirstChild
(
nullptr
)
mLastChild
(
nullptr
)
{
}
nsFrameList
(
nsIFrame
*
aFirstFrame
nsIFrame
*
aLastFrame
)
:
mFirstChild
(
aFirstFrame
)
mLastChild
(
aLastFrame
)
{
VerifyList
(
)
;
}
nsFrameList
(
const
nsFrameList
&
aOther
)
=
delete
;
nsFrameList
&
operator
=
(
const
nsFrameList
&
aOther
)
=
delete
;
nsFrameList
Clone
(
)
const
{
return
nsFrameList
(
mFirstChild
mLastChild
)
;
}
nsFrameList
(
nsFrameList
&
&
aOther
)
:
mFirstChild
(
aOther
.
mFirstChild
)
mLastChild
(
aOther
.
mLastChild
)
{
aOther
.
Clear
(
)
;
VerifyList
(
)
;
}
nsFrameList
&
operator
=
(
nsFrameList
&
&
aOther
)
{
if
(
this
!
=
&
aOther
)
{
SetFrames
(
aOther
)
;
}
return
*
this
;
}
void
*
operator
new
(
size_t
sz
mozilla
:
:
PresShell
*
aPresShell
)
;
void
Delete
(
mozilla
:
:
PresShell
*
aPresShell
)
;
void
DestroyFrames
(
)
;
void
DestroyFramesFrom
(
nsIFrame
*
aDestructRoot
mozilla
:
:
layout
:
:
PostFrameDestroyData
&
aPostDestroyData
)
;
void
Clear
(
)
{
mFirstChild
=
mLastChild
=
nullptr
;
}
void
SetFrames
(
nsIFrame
*
aFrameList
)
;
void
SetFrames
(
nsFrameList
&
aFrameList
)
{
MOZ_ASSERT
(
!
mFirstChild
"
Losing
frames
"
)
;
mFirstChild
=
aFrameList
.
FirstChild
(
)
;
mLastChild
=
aFrameList
.
LastChild
(
)
;
aFrameList
.
Clear
(
)
;
}
Slice
AppendFrames
(
nsContainerFrame
*
aParent
nsFrameList
&
aFrameList
)
{
return
InsertFrames
(
aParent
LastChild
(
)
aFrameList
)
;
}
void
AppendFrame
(
nsContainerFrame
*
aParent
nsIFrame
*
aFrame
)
{
nsFrameList
temp
(
aFrame
aFrame
)
;
AppendFrames
(
aParent
temp
)
;
}
void
RemoveFrame
(
nsIFrame
*
aFrame
)
;
[
[
nodiscard
]
]
nsFrameList
TakeFramesBefore
(
nsIFrame
*
aFrame
)
;
[
[
nodiscard
]
]
nsFrameList
TakeFramesAfter
(
nsIFrame
*
aFrame
)
;
nsIFrame
*
RemoveFirstChild
(
)
;
inline
bool
StartRemoveFrame
(
nsIFrame
*
aFrame
)
;
inline
bool
ContinueRemoveFrame
(
nsIFrame
*
aFrame
)
;
void
DestroyFrame
(
nsIFrame
*
aFrame
)
;
void
InsertFrame
(
nsContainerFrame
*
aParent
nsIFrame
*
aPrevSibling
nsIFrame
*
aFrame
)
{
nsFrameList
temp
(
aFrame
aFrame
)
;
InsertFrames
(
aParent
aPrevSibling
temp
)
;
}
Slice
InsertFrames
(
nsContainerFrame
*
aParent
nsIFrame
*
aPrevSibling
nsFrameList
&
aFrameList
)
;
template
<
typename
Predicate
>
nsFrameList
Split
(
Predicate
&
&
aPredicate
)
{
static_assert
(
std
:
:
is_same
<
typename
mozilla
:
:
FunctionTypeTraits
<
Predicate
>
:
:
ReturnType
bool
>
:
:
value
&
&
mozilla
:
:
FunctionTypeTraits
<
Predicate
>
:
:
arity
=
=
1
&
&
std
:
:
is_same
<
typename
mozilla
:
:
FunctionTypeTraits
<
Predicate
>
:
:
template
ParameterType
<
0
>
nsIFrame
*
>
:
:
value
"
aPredicate
should
be
of
this
function
signature
:
bool
(
nsIFrame
*
)
"
)
;
for
(
nsIFrame
*
f
:
*
this
)
{
if
(
aPredicate
(
f
)
)
{
return
TakeFramesBefore
(
f
)
;
}
}
return
std
:
:
move
(
*
this
)
;
}
nsIFrame
*
FirstChild
(
)
const
{
return
mFirstChild
;
}
nsIFrame
*
LastChild
(
)
const
{
return
mLastChild
;
}
nsIFrame
*
FrameAt
(
int32_t
aIndex
)
const
;
int32_t
IndexOf
(
nsIFrame
*
aFrame
)
const
;
bool
IsEmpty
(
)
const
{
return
nullptr
=
=
mFirstChild
;
}
bool
NotEmpty
(
)
const
{
return
nullptr
!
=
mFirstChild
;
}
bool
ContainsFrame
(
const
nsIFrame
*
aFrame
)
const
;
int32_t
GetLength
(
)
const
;
nsIFrame
*
OnlyChild
(
)
const
{
if
(
FirstChild
(
)
=
=
LastChild
(
)
)
{
return
FirstChild
(
)
;
}
return
nullptr
;
}
void
ApplySetParent
(
nsContainerFrame
*
aParent
)
const
;
inline
void
AppendIfNonempty
(
nsTArray
<
mozilla
:
:
layout
:
:
FrameChildList
>
*
aLists
mozilla
:
:
layout
:
:
FrameChildListID
aListID
)
const
;
nsIFrame
*
GetPrevVisualFor
(
nsIFrame
*
aFrame
)
const
;
nsIFrame
*
GetNextVisualFor
(
nsIFrame
*
aFrame
)
const
;
#
ifdef
DEBUG_FRAME_DUMP
void
List
(
FILE
*
out
)
const
;
#
endif
static
inline
const
nsFrameList
&
EmptyList
(
)
;
class
Slice
{
public
:
MOZ_IMPLICIT
Slice
(
const
nsFrameList
&
aList
)
:
mStart
(
aList
.
FirstChild
(
)
)
mEnd
(
nullptr
)
{
}
Slice
(
nsIFrame
*
aStart
nsIFrame
*
aEnd
)
:
mStart
(
aStart
)
mEnd
(
aEnd
)
{
}
iterator
begin
(
)
const
{
return
iterator
(
mStart
)
;
}
const_iterator
cbegin
(
)
const
{
return
begin
(
)
;
}
iterator
end
(
)
const
{
return
iterator
(
mEnd
)
;
}
const_iterator
cend
(
)
const
{
return
end
(
)
;
}
private
:
nsIFrame
*
const
mStart
;
nsIFrame
*
const
mEnd
;
}
;
template
<
typename
FrameTraversal
>
class
Iterator
final
{
public
:
using
value_type
=
nsIFrame
*
const
;
using
pointer
=
value_type
*
;
using
reference
=
value_type
&
;
using
difference_type
=
ptrdiff_t
;
using
iterator_category
=
std
:
:
input_iterator_tag
;
explicit
constexpr
Iterator
(
nsIFrame
*
aCurrent
)
:
mCurrent
(
aCurrent
)
{
}
nsIFrame
*
operator
*
(
)
const
{
return
mCurrent
;
}
Iterator
&
operator
+
+
(
)
{
mCurrent
=
FrameTraversal
:
:
Next
(
mCurrent
)
;
return
*
this
;
}
Iterator
&
operator
-
-
(
)
{
mCurrent
=
FrameTraversal
:
:
Prev
(
mCurrent
)
;
return
*
this
;
}
Iterator
operator
+
+
(
int
)
{
auto
ret
=
*
this
;
+
+
*
this
;
return
ret
;
}
Iterator
operator
-
-
(
int
)
{
auto
ret
=
*
this
;
-
-
*
this
;
return
ret
;
}
bool
operator
=
=
(
const
Iterator
<
FrameTraversal
>
&
aOther
)
const
{
return
mCurrent
=
=
aOther
.
mCurrent
;
}
bool
operator
!
=
(
const
Iterator
<
FrameTraversal
>
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
private
:
nsIFrame
*
mCurrent
;
}
;
iterator
begin
(
)
const
{
return
iterator
(
mFirstChild
)
;
}
const_iterator
cbegin
(
)
const
{
return
begin
(
)
;
}
iterator
end
(
)
const
{
return
iterator
(
nullptr
)
;
}
const_iterator
cend
(
)
const
{
return
end
(
)
;
}
reverse_iterator
rbegin
(
)
const
{
return
reverse_iterator
(
mLastChild
)
;
}
const_reverse_iterator
crbegin
(
)
const
{
return
rbegin
(
)
;
}
reverse_iterator
rend
(
)
const
{
return
reverse_iterator
(
nullptr
)
;
}
const_reverse_iterator
crend
(
)
const
{
return
rend
(
)
;
}
private
:
void
operator
delete
(
void
*
)
=
delete
;
#
ifdef
DEBUG_FRAME_LIST
void
VerifyList
(
)
const
;
#
else
void
VerifyList
(
)
const
{
}
#
endif
protected
:
static
void
UnhookFrameFromSiblings
(
nsIFrame
*
aFrame
)
;
nsIFrame
*
mFirstChild
;
nsIFrame
*
mLastChild
;
}
;
namespace
mozilla
{
class
MOZ_RAII
AutoFrameListPtr
final
{
public
:
AutoFrameListPtr
(
nsPresContext
*
aPresContext
nsFrameList
*
aFrameList
)
:
mPresContext
(
aPresContext
)
mFrameList
(
aFrameList
)
{
}
~
AutoFrameListPtr
(
)
;
operator
nsFrameList
*
(
)
const
{
return
mFrameList
;
}
nsFrameList
*
operator
-
>
(
)
const
{
return
mFrameList
;
}
private
:
nsPresContext
*
mPresContext
;
nsFrameList
*
mFrameList
;
}
;
namespace
detail
{
union
AlignedFrameListBytes
{
void
*
ptr
;
char
bytes
[
sizeof
(
nsFrameList
)
]
;
}
;
extern
const
AlignedFrameListBytes
gEmptyFrameListBytes
;
}
}
inline
const
nsFrameList
&
nsFrameList
:
:
EmptyList
(
)
{
return
*
reinterpret_cast
<
const
nsFrameList
*
>
(
&
mozilla
:
:
detail
:
:
gEmptyFrameListBytes
)
;
}
#
endif
