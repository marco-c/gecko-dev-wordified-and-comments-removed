#
ifndef
LAYOUT_GENERIC_ABSOLUTE_CONTAINING_BLOCK_H_
#
define
LAYOUT_GENERIC_ABSOLUTE_CONTAINING_BLOCK_H_
#
include
"
nsFrameList
.
h
"
#
include
"
nsIFrame
.
h
"
class
nsContainerFrame
;
class
nsPresContext
;
namespace
mozilla
{
enum
class
AbsPosReflowFlag
:
uint8_t
{
AllowFragmentation
CBWidthChanged
CBHeightChanged
IsGridContainerCB
}
;
using
AbsPosReflowFlags
=
EnumSet
<
AbsPosReflowFlag
>
;
struct
StylePositionArea
;
class
AbsoluteContainingBlock
{
public
:
explicit
AbsoluteContainingBlock
(
FrameChildListID
aChildListID
)
#
ifdef
DEBUG
:
mChildListID
(
aChildListID
)
#
endif
{
MOZ_ASSERT
(
mChildListID
=
=
FrameChildListID
:
:
Absolute
|
|
mChildListID
=
=
FrameChildListID
:
:
Fixed
"
should
either
represent
position
:
fixed
or
absolute
content
"
)
;
}
const
nsFrameList
&
GetChildList
(
)
const
{
return
mAbsoluteFrames
;
}
const
nsFrameList
&
GetPushedChildList
(
)
const
{
return
mPushedAbsoluteFrames
;
}
void
SetInitialChildList
(
nsIFrame
*
aDelegatingFrame
FrameChildListID
aListID
nsFrameList
&
&
aChildList
)
;
void
AppendFrames
(
nsIFrame
*
aDelegatingFrame
FrameChildListID
aListID
nsFrameList
&
&
aFrameList
)
;
void
InsertFrames
(
nsIFrame
*
aDelegatingFrame
FrameChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
&
aFrameList
)
;
void
RemoveFrame
(
FrameDestroyContext
&
FrameChildListID
nsIFrame
*
)
;
[
[
nodiscard
]
]
nsFrameList
StealPushedChildList
(
)
;
bool
PrepareAbsoluteFrames
(
nsContainerFrame
*
aDelegatingFrame
)
;
bool
HasAbsoluteFrames
(
)
const
{
return
mAbsoluteFrames
.
NotEmpty
(
)
;
}
void
Reflow
(
nsContainerFrame
*
aDelegatingFrame
nsPresContext
*
aPresContext
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aReflowStatus
const
nsRect
&
aContainingBlock
AbsPosReflowFlags
aFlags
OverflowAreas
*
aOverflowAreas
)
;
using
DestroyContext
=
nsIFrame
:
:
DestroyContext
;
void
DestroyFrames
(
DestroyContext
&
)
;
void
MarkSizeDependentFramesDirty
(
)
;
void
MarkAllFramesDirty
(
)
;
protected
:
bool
FrameDependsOnContainer
(
nsIFrame
*
aFrame
bool
aCBWidthChanged
bool
aCBHeightChanged
mozilla
:
:
AnchorPosResolutionCache
*
aAnchorPosResolutionCache
=
nullptr
)
;
void
ResolveSizeDependentOffsets
(
ReflowInput
&
aKidReflowInput
const
LogicalSize
&
aCBSize
const
LogicalSize
&
aKidSize
const
LogicalMargin
&
aMargin
const
StylePositionArea
&
aResolvedPositionArea
LogicalMargin
&
aOffsets
)
;
void
ResolveAutoMarginsAfterLayout
(
ReflowInput
&
aKidReflowInput
const
LogicalSize
&
aCBSize
const
LogicalSize
&
aKidSize
LogicalMargin
&
aMargin
const
LogicalMargin
&
aOffsets
)
;
void
ReflowAbsoluteFrame
(
nsContainerFrame
*
aDelegatingFrame
nsPresContext
*
aPresContext
const
ReflowInput
&
aReflowInput
const
nsRect
&
aOriginalContainingBlockRect
const
nsRect
&
aOriginalScrollableContainingBlockRect
AbsPosReflowFlags
aFlags
nsIFrame
*
aKidFrame
nsReflowStatus
&
aStatus
OverflowAreas
*
aOverflowAreas
mozilla
:
:
AnchorPosResolutionCache
*
aAnchorPosResolutionCache
=
nullptr
)
;
void
DoMarkFramesDirty
(
bool
aMarkAllDirty
)
;
void
StealFrame
(
nsIFrame
*
aFrame
)
;
void
DrainPushedChildList
(
const
nsIFrame
*
aDelegatingFrame
)
;
nsFrameList
mAbsoluteFrames
;
nsFrameList
mPushedAbsoluteFrames
;
#
ifdef
DEBUG
FrameChildListID
const
mChildListID
;
#
endif
}
;
}
#
endif
