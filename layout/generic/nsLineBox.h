#
ifndef
nsLineBox_h___
#
define
nsLineBox_h___
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
nsILineIterator
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsTHashSet
.
h
"
#
include
<
algorithm
>
class
nsLineBox
;
class
nsFloatCache
;
class
nsFloatCacheList
;
class
nsFloatCacheFreeList
;
class
nsWindowSizes
;
namespace
mozilla
{
class
PresShell
;
}
class
nsFloatCache
{
public
:
nsFloatCache
(
)
;
#
ifdef
NS_BUILD_REFCNT_LOGGING
~
nsFloatCache
(
)
;
#
else
~
nsFloatCache
(
)
=
default
;
#
endif
nsFloatCache
*
Next
(
)
const
{
return
mNext
;
}
nsIFrame
*
mFloat
;
protected
:
nsFloatCache
*
mNext
;
friend
class
nsFloatCacheList
;
friend
class
nsFloatCacheFreeList
;
}
;
class
nsFloatCacheList
{
public
:
#
ifdef
NS_BUILD_REFCNT_LOGGING
nsFloatCacheList
(
)
;
#
else
nsFloatCacheList
(
)
:
mHead
(
nullptr
)
{
}
#
endif
~
nsFloatCacheList
(
)
;
bool
IsEmpty
(
)
const
{
return
nullptr
=
=
mHead
;
}
bool
NotEmpty
(
)
const
{
return
nullptr
!
=
mHead
;
}
nsFloatCache
*
Head
(
)
const
{
return
mHead
;
}
nsFloatCache
*
Tail
(
)
const
;
void
DeleteAll
(
)
;
nsFloatCache
*
Find
(
nsIFrame
*
aOutOfFlowFrame
)
;
void
Remove
(
nsFloatCache
*
aElement
)
{
RemoveAndReturnPrev
(
aElement
)
;
}
void
Append
(
nsFloatCacheFreeList
&
aList
)
;
protected
:
nsFloatCache
*
mHead
;
nsFloatCache
*
RemoveAndReturnPrev
(
nsFloatCache
*
aElement
)
;
friend
class
nsFloatCacheFreeList
;
}
;
class
nsFloatCacheFreeList
:
private
nsFloatCacheList
{
public
:
#
ifdef
NS_BUILD_REFCNT_LOGGING
nsFloatCacheFreeList
(
)
;
~
nsFloatCacheFreeList
(
)
;
#
else
nsFloatCacheFreeList
(
)
:
mTail
(
nullptr
)
{
}
~
nsFloatCacheFreeList
(
)
=
default
;
#
endif
bool
IsEmpty
(
)
const
{
return
nullptr
=
=
mHead
;
}
nsFloatCache
*
Head
(
)
const
{
return
mHead
;
}
nsFloatCache
*
Tail
(
)
const
{
return
mTail
;
}
bool
NotEmpty
(
)
const
{
return
nullptr
!
=
mHead
;
}
void
DeleteAll
(
)
;
void
Append
(
nsFloatCacheList
&
aList
)
;
void
Append
(
nsFloatCache
*
aFloatCache
)
;
void
Remove
(
nsFloatCache
*
aElement
)
;
nsFloatCache
*
Alloc
(
nsIFrame
*
aFloat
)
;
protected
:
nsFloatCache
*
mTail
;
friend
class
nsFloatCacheList
;
}
;
#
define
LINE_MAX_CHILD_COUNT
INT32_MAX
nsLineBox
*
NS_NewLineBox
(
mozilla
:
:
PresShell
*
aPresShell
nsIFrame
*
aFrame
bool
aIsBlock
)
;
nsLineBox
*
NS_NewLineBox
(
mozilla
:
:
PresShell
*
aPresShell
nsLineBox
*
aFromLine
nsIFrame
*
aFrame
int32_t
aCount
)
;
class
nsLineList
;
class
nsLineList_iterator
;
class
nsLineList_const_iterator
;
class
nsLineList_reverse_iterator
;
class
nsLineList_const_reverse_iterator
;
class
nsLineLink
{
public
:
friend
class
nsLineList
;
friend
class
nsLineList_iterator
;
friend
class
nsLineList_reverse_iterator
;
friend
class
nsLineList_const_iterator
;
friend
class
nsLineList_const_reverse_iterator
;
private
:
nsLineLink
*
_mNext
;
nsLineLink
*
_mPrev
;
}
;
class
nsLineBox
final
:
public
nsLineLink
{
private
:
nsLineBox
(
nsIFrame
*
aFrame
int32_t
aCount
bool
aIsBlock
)
;
~
nsLineBox
(
)
;
void
*
operator
new
(
size_t
sz
mozilla
:
:
PresShell
*
aPresShell
)
;
void
operator
delete
(
void
*
aPtr
size_t
sz
)
=
delete
;
public
:
friend
nsLineBox
*
NS_NewLineBox
(
mozilla
:
:
PresShell
*
aPresShell
nsIFrame
*
aFrame
bool
aIsBlock
)
;
friend
nsLineBox
*
NS_NewLineBox
(
mozilla
:
:
PresShell
*
aPresShell
nsLineBox
*
aFromLine
nsIFrame
*
aFrame
int32_t
aCount
)
;
void
Destroy
(
mozilla
:
:
PresShell
*
aPresShell
)
;
bool
IsBlock
(
)
const
{
return
mFlags
.
mBlock
;
}
bool
IsInline
(
)
const
{
return
!
mFlags
.
mBlock
;
}
void
MarkDirty
(
)
{
mFlags
.
mDirty
=
1
;
}
void
ClearDirty
(
)
{
mFlags
.
mDirty
=
0
;
}
bool
IsDirty
(
)
const
{
return
mFlags
.
mDirty
;
}
void
MarkPreviousMarginDirty
(
)
{
mFlags
.
mPreviousMarginDirty
=
1
;
}
void
ClearPreviousMarginDirty
(
)
{
mFlags
.
mPreviousMarginDirty
=
0
;
}
bool
IsPreviousMarginDirty
(
)
const
{
return
mFlags
.
mPreviousMarginDirty
;
}
void
SetHasClearance
(
)
{
mFlags
.
mHasClearance
=
1
;
}
void
ClearHasClearance
(
)
{
mFlags
.
mHasClearance
=
0
;
}
bool
HasClearance
(
)
const
{
return
mFlags
.
mHasClearance
;
}
void
SetLineIsImpactedByFloat
(
bool
aValue
)
{
mFlags
.
mImpactedByFloat
=
aValue
;
}
bool
IsImpactedByFloat
(
)
const
{
return
mFlags
.
mImpactedByFloat
;
}
void
SetLineWrapped
(
bool
aOn
)
{
mFlags
.
mLineWrapped
=
aOn
;
}
bool
IsLineWrapped
(
)
const
{
return
mFlags
.
mLineWrapped
;
}
void
SetInvalidateTextRuns
(
bool
aOn
)
{
mFlags
.
mInvalidateTextRuns
=
aOn
;
}
bool
GetInvalidateTextRuns
(
)
const
{
return
mFlags
.
mInvalidateTextRuns
;
}
void
DisableResizeReflowOptimization
(
)
{
mFlags
.
mResizeReflowOptimizationDisabled
=
true
;
}
void
EnableResizeReflowOptimization
(
)
{
mFlags
.
mResizeReflowOptimizationDisabled
=
false
;
}
bool
ResizeReflowOptimizationDisabled
(
)
const
{
return
mFlags
.
mResizeReflowOptimizationDisabled
;
}
void
SetHasMarker
(
)
{
mFlags
.
mHasMarker
=
true
;
InvalidateCachedIsEmpty
(
)
;
}
void
ClearHasMarker
(
)
{
mFlags
.
mHasMarker
=
false
;
InvalidateCachedIsEmpty
(
)
;
}
bool
HasMarker
(
)
const
{
return
mFlags
.
mHasMarker
;
}
void
SetHadFloatPushed
(
)
{
mFlags
.
mHadFloatPushed
=
true
;
}
void
ClearHadFloatPushed
(
)
{
mFlags
.
mHadFloatPushed
=
false
;
}
bool
HadFloatPushed
(
)
const
{
return
mFlags
.
mHadFloatPushed
;
}
void
SetHasLineClampEllipsis
(
)
{
mFlags
.
mHasLineClampEllipsis
=
true
;
}
void
ClearHasLineClampEllipsis
(
)
{
mFlags
.
mHasLineClampEllipsis
=
false
;
}
bool
HasLineClampEllipsis
(
)
const
{
return
mFlags
.
mHasLineClampEllipsis
;
}
void
SetMovedFragments
(
)
{
mFlags
.
mMovedFragments
=
true
;
}
void
ClearMovedFragments
(
)
{
mFlags
.
mMovedFragments
=
false
;
}
bool
MovedFragments
(
)
const
{
return
mFlags
.
mMovedFragments
;
}
private
:
static
const
uint32_t
kMinChildCountForHashtable
=
200
;
void
StealHashTableFrom
(
nsLineBox
*
aFromLine
uint32_t
aFromLineNewCount
)
;
void
NoteFramesMovedFrom
(
nsLineBox
*
aFromLine
)
;
void
SwitchToHashtable
(
)
{
MOZ_ASSERT
(
!
mFlags
.
mHasHashedFrames
)
;
uint32_t
count
=
GetChildCount
(
)
;
mFlags
.
mHasHashedFrames
=
1
;
uint32_t
minLength
=
std
:
:
max
(
kMinChildCountForHashtable
uint32_t
(
PLDHashTable
:
:
kDefaultInitialLength
)
)
;
mFrames
=
new
nsTHashSet
<
nsIFrame
*
>
(
std
:
:
max
(
count
minLength
)
)
;
for
(
nsIFrame
*
f
=
mFirstChild
;
count
-
-
>
0
;
f
=
f
-
>
GetNextSibling
(
)
)
{
mFrames
-
>
Insert
(
f
)
;
}
}
void
SwitchToCounter
(
)
{
MOZ_ASSERT
(
mFlags
.
mHasHashedFrames
)
;
uint32_t
count
=
GetChildCount
(
)
;
delete
mFrames
;
mFlags
.
mHasHashedFrames
=
0
;
mChildCount
=
count
;
}
public
:
int32_t
GetChildCount
(
)
const
{
return
MOZ_UNLIKELY
(
mFlags
.
mHasHashedFrames
)
?
mFrames
-
>
Count
(
)
:
mChildCount
;
}
void
NoteFrameAdded
(
nsIFrame
*
aFrame
)
{
if
(
MOZ_UNLIKELY
(
mFlags
.
mHasHashedFrames
)
)
{
mFrames
-
>
Insert
(
aFrame
)
;
}
else
{
if
(
+
+
mChildCount
>
=
kMinChildCountForHashtable
)
{
SwitchToHashtable
(
)
;
}
}
}
void
NoteFrameRemoved
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
GetChildCount
(
)
>
0
)
;
if
(
MOZ_UNLIKELY
(
mFlags
.
mHasHashedFrames
)
)
{
mFrames
-
>
Remove
(
aFrame
)
;
if
(
mFrames
-
>
Count
(
)
<
kMinChildCountForHashtable
)
{
SwitchToCounter
(
)
;
}
}
else
{
-
-
mChildCount
;
}
}
using
StyleClear
=
mozilla
:
:
StyleClear
;
bool
HasBreakBefore
(
)
const
{
return
IsBlock
(
)
&
&
StyleClear
:
:
None
!
=
BreakType
(
)
;
}
void
SetBreakTypeBefore
(
StyleClear
aBreakType
)
{
MOZ_ASSERT
(
IsBlock
(
)
"
Only
blocks
have
break
-
before
"
)
;
MOZ_ASSERT
(
aBreakType
=
=
StyleClear
:
:
None
|
|
aBreakType
=
=
StyleClear
:
:
Left
|
|
aBreakType
=
=
StyleClear
:
:
Right
|
|
aBreakType
=
=
StyleClear
:
:
Both
"
Only
float
break
types
are
allowed
before
a
line
"
)
;
mFlags
.
mBreakType
=
aBreakType
;
}
StyleClear
GetBreakTypeBefore
(
)
const
{
return
IsBlock
(
)
?
BreakType
(
)
:
StyleClear
:
:
None
;
}
bool
HasBreakAfter
(
)
const
{
return
!
IsBlock
(
)
&
&
StyleClear
:
:
None
!
=
BreakType
(
)
;
}
void
SetBreakTypeAfter
(
StyleClear
aBreakType
)
{
MOZ_ASSERT
(
!
IsBlock
(
)
"
Only
inlines
have
break
-
after
"
)
;
mFlags
.
mBreakType
=
aBreakType
;
}
bool
HasFloatBreakAfter
(
)
const
{
return
!
IsBlock
(
)
&
&
(
StyleClear
:
:
Left
=
=
BreakType
(
)
|
|
StyleClear
:
:
Right
=
=
BreakType
(
)
|
|
StyleClear
:
:
Both
=
=
BreakType
(
)
)
;
}
StyleClear
GetBreakTypeAfter
(
)
const
{
return
!
IsBlock
(
)
?
BreakType
(
)
:
StyleClear
:
:
None
;
}
nsCollapsingMargin
GetCarriedOutBEndMargin
(
)
const
;
bool
SetCarriedOutBEndMargin
(
nsCollapsingMargin
aValue
)
;
bool
HasFloats
(
)
const
{
return
(
IsInline
(
)
&
&
mInlineData
)
&
&
mInlineData
-
>
mFloats
.
NotEmpty
(
)
;
}
nsFloatCache
*
GetFirstFloat
(
)
;
void
FreeFloats
(
nsFloatCacheFreeList
&
aFreeList
)
;
void
AppendFloats
(
nsFloatCacheFreeList
&
aFreeList
)
;
bool
RemoveFloat
(
nsIFrame
*
aFrame
)
;
void
SetOverflowAreas
(
const
mozilla
:
:
OverflowAreas
&
aOverflowAreas
)
;
mozilla
:
:
LogicalRect
GetOverflowArea
(
mozilla
:
:
OverflowType
aType
mozilla
:
:
WritingMode
aWM
const
nsSize
&
aContainerSize
)
{
return
mozilla
:
:
LogicalRect
(
aWM
GetOverflowArea
(
aType
)
aContainerSize
)
;
}
nsRect
GetOverflowArea
(
mozilla
:
:
OverflowType
aType
)
const
{
return
mData
?
mData
-
>
mOverflowAreas
.
Overflow
(
aType
)
:
GetPhysicalBounds
(
)
;
}
mozilla
:
:
OverflowAreas
GetOverflowAreas
(
)
const
{
if
(
mData
)
{
return
mData
-
>
mOverflowAreas
;
}
nsRect
bounds
=
GetPhysicalBounds
(
)
;
return
mozilla
:
:
OverflowAreas
(
bounds
bounds
)
;
}
nsRect
InkOverflowRect
(
)
const
{
return
GetOverflowArea
(
mozilla
:
:
OverflowType
:
:
Ink
)
;
}
nsRect
ScrollableOverflowRect
(
)
{
return
GetOverflowArea
(
mozilla
:
:
OverflowType
:
:
Scrollable
)
;
}
void
SlideBy
(
nscoord
aDBCoord
const
nsSize
&
aContainerSize
)
{
NS_ASSERTION
(
aContainerSize
=
=
mContainerSize
|
|
mContainerSize
=
=
nsSize
(
-
1
-
1
)
"
container
size
doesn
'
t
match
"
)
;
mContainerSize
=
aContainerSize
;
mBounds
.
BStart
(
mWritingMode
)
+
=
aDBCoord
;
if
(
mData
)
{
const
nsSize
nullContainerSize
;
nsPoint
physicalDelta
=
mozilla
:
:
LogicalPoint
(
mWritingMode
0
aDBCoord
)
.
GetPhysicalPoint
(
mWritingMode
nullContainerSize
)
;
for
(
const
auto
otype
:
mozilla
:
:
AllOverflowTypes
(
)
)
{
mData
-
>
mOverflowAreas
.
Overflow
(
otype
)
+
=
physicalDelta
;
}
}
}
nsSize
UpdateContainerSize
(
const
nsSize
aNewContainerSize
)
{
NS_ASSERTION
(
mContainerSize
!
=
nsSize
(
-
1
-
1
)
"
container
size
not
set
"
)
;
nsSize
delta
=
mContainerSize
-
aNewContainerSize
;
mContainerSize
=
aNewContainerSize
;
if
(
mWritingMode
.
IsVerticalRL
(
)
&
&
mData
)
{
nsPoint
physicalDelta
(
-
delta
.
width
0
)
;
for
(
const
auto
otype
:
mozilla
:
:
AllOverflowTypes
(
)
)
{
mData
-
>
mOverflowAreas
.
Overflow
(
otype
)
+
=
physicalDelta
;
}
}
return
delta
;
}
void
IndentBy
(
nscoord
aDICoord
const
nsSize
&
aContainerSize
)
{
NS_ASSERTION
(
aContainerSize
=
=
mContainerSize
|
|
mContainerSize
=
=
nsSize
(
-
1
-
1
)
"
container
size
doesn
'
t
match
"
)
;
mContainerSize
=
aContainerSize
;
mBounds
.
IStart
(
mWritingMode
)
+
=
aDICoord
;
}
void
ExpandBy
(
nscoord
aDISize
const
nsSize
&
aContainerSize
)
{
NS_ASSERTION
(
aContainerSize
=
=
mContainerSize
|
|
mContainerSize
=
=
nsSize
(
-
1
-
1
)
"
container
size
doesn
'
t
match
"
)
;
mContainerSize
=
aContainerSize
;
mBounds
.
ISize
(
mWritingMode
)
+
=
aDISize
;
}
nscoord
GetLogicalAscent
(
)
const
{
return
mAscent
;
}
void
SetLogicalAscent
(
nscoord
aAscent
)
{
mAscent
=
aAscent
;
}
nscoord
BStart
(
)
const
{
return
mBounds
.
BStart
(
mWritingMode
)
;
}
nscoord
BSize
(
)
const
{
return
mBounds
.
BSize
(
mWritingMode
)
;
}
nscoord
BEnd
(
)
const
{
return
mBounds
.
BEnd
(
mWritingMode
)
;
}
nscoord
IStart
(
)
const
{
return
mBounds
.
IStart
(
mWritingMode
)
;
}
nscoord
ISize
(
)
const
{
return
mBounds
.
ISize
(
mWritingMode
)
;
}
nscoord
IEnd
(
)
const
{
return
mBounds
.
IEnd
(
mWritingMode
)
;
}
void
SetBoundsEmpty
(
)
{
mBounds
.
IStart
(
mWritingMode
)
=
0
;
mBounds
.
ISize
(
mWritingMode
)
=
0
;
mBounds
.
BStart
(
mWritingMode
)
=
0
;
mBounds
.
BSize
(
mWritingMode
)
=
0
;
}
using
PostDestroyData
=
nsIFrame
:
:
PostDestroyData
;
static
void
DeleteLineList
(
nsPresContext
*
aPresContext
nsLineList
&
aLines
nsIFrame
*
aDestructRoot
nsFrameList
*
aFrames
PostDestroyData
&
aPostDestroyData
)
;
static
bool
RFindLineContaining
(
nsIFrame
*
aFrame
const
nsLineList_iterator
&
aBegin
nsLineList_iterator
&
aEnd
nsIFrame
*
aLastFrameBeforeEnd
int32_t
*
aFrameIndexInLine
)
;
#
ifdef
DEBUG_FRAME_DUMP
static
const
char
*
BreakTypeToString
(
StyleClear
aBreakType
)
;
char
*
StateToString
(
char
*
aBuf
int32_t
aBufSize
)
const
;
void
List
(
FILE
*
out
int32_t
aIndent
nsIFrame
:
:
ListFlags
aFlags
=
nsIFrame
:
:
ListFlags
(
)
)
const
;
void
List
(
FILE
*
out
=
stderr
const
char
*
aPrefix
=
"
"
nsIFrame
:
:
ListFlags
aFlags
=
nsIFrame
:
:
ListFlags
(
)
)
const
;
nsIFrame
*
LastChild
(
)
const
;
#
endif
void
AddSizeOfExcludingThis
(
nsWindowSizes
&
aSizes
)
const
;
int32_t
IndexOf
(
nsIFrame
*
aFrame
)
const
;
int32_t
RIndexOf
(
nsIFrame
*
aFrame
nsIFrame
*
aLastFrameInLine
)
const
;
bool
Contains
(
nsIFrame
*
aFrame
)
const
{
return
MOZ_UNLIKELY
(
mFlags
.
mHasHashedFrames
)
?
mFrames
-
>
Contains
(
aFrame
)
:
IndexOf
(
aFrame
)
>
=
0
;
}
bool
IsEmpty
(
)
const
;
bool
CachedIsEmpty
(
)
;
void
InvalidateCachedIsEmpty
(
)
{
mFlags
.
mEmptyCacheValid
=
false
;
}
bool
IsValidCachedIsEmpty
(
)
{
return
mFlags
.
mEmptyCacheValid
;
}
#
ifdef
DEBUG
static
int32_t
GetCtorCount
(
)
;
#
endif
nsIFrame
*
mFirstChild
;
mozilla
:
:
WritingMode
mWritingMode
;
nsSize
mContainerSize
;
private
:
mozilla
:
:
LogicalRect
mBounds
;
public
:
const
mozilla
:
:
LogicalRect
&
GetBounds
(
)
{
return
mBounds
;
}
nsRect
GetPhysicalBounds
(
)
const
{
if
(
mBounds
.
IsAllZero
(
)
)
{
return
nsRect
(
0
0
0
0
)
;
}
NS_ASSERTION
(
mContainerSize
!
=
nsSize
(
-
1
-
1
)
"
mContainerSize
not
initialized
"
)
;
return
mBounds
.
GetPhysicalRect
(
mWritingMode
mContainerSize
)
;
}
void
SetBounds
(
mozilla
:
:
WritingMode
aWritingMode
nscoord
aIStart
nscoord
aBStart
nscoord
aISize
nscoord
aBSize
const
nsSize
&
aContainerSize
)
{
mWritingMode
=
aWritingMode
;
mContainerSize
=
aContainerSize
;
mBounds
=
mozilla
:
:
LogicalRect
(
aWritingMode
aIStart
aBStart
aISize
aBSize
)
;
}
union
{
nsTHashSet
<
nsIFrame
*
>
*
mFrames
;
uint32_t
mChildCount
;
}
;
struct
FlagBits
{
bool
mDirty
:
1
;
bool
mPreviousMarginDirty
:
1
;
bool
mHasClearance
:
1
;
bool
mBlock
:
1
;
bool
mImpactedByFloat
:
1
;
bool
mLineWrapped
:
1
;
bool
mInvalidateTextRuns
:
1
;
bool
mResizeReflowOptimizationDisabled
:
1
;
bool
mEmptyCacheValid
:
1
;
bool
mEmptyCacheState
:
1
;
bool
mHasMarker
:
1
;
bool
mHadFloatPushed
:
1
;
bool
mHasHashedFrames
:
1
;
bool
mHasLineClampEllipsis
:
1
;
bool
mMovedFragments
:
1
;
StyleClear
mBreakType
;
}
;
struct
ExtraData
{
explicit
ExtraData
(
const
nsRect
&
aBounds
)
:
mOverflowAreas
(
aBounds
aBounds
)
{
}
mozilla
:
:
OverflowAreas
mOverflowAreas
;
}
;
struct
ExtraBlockData
:
public
ExtraData
{
explicit
ExtraBlockData
(
const
nsRect
&
aBounds
)
:
ExtraData
(
aBounds
)
mCarriedOutBEndMargin
(
)
{
}
nsCollapsingMargin
mCarriedOutBEndMargin
;
}
;
struct
ExtraInlineData
:
public
ExtraData
{
explicit
ExtraInlineData
(
const
nsRect
&
aBounds
)
:
ExtraData
(
aBounds
)
mFloatEdgeIStart
(
nscoord_MIN
)
mFloatEdgeIEnd
(
nscoord_MIN
)
{
}
nscoord
mFloatEdgeIStart
;
nscoord
mFloatEdgeIEnd
;
nsFloatCacheList
mFloats
;
}
;
bool
GetFloatEdges
(
nscoord
*
aStart
nscoord
*
aEnd
)
const
{
MOZ_ASSERT
(
IsInline
(
)
"
block
line
can
'
t
have
float
edges
"
)
;
if
(
mInlineData
&
&
mInlineData
-
>
mFloatEdgeIStart
!
=
nscoord_MIN
)
{
*
aStart
=
mInlineData
-
>
mFloatEdgeIStart
;
*
aEnd
=
mInlineData
-
>
mFloatEdgeIEnd
;
return
true
;
}
return
false
;
}
void
SetFloatEdges
(
nscoord
aStart
nscoord
aEnd
)
;
void
ClearFloatEdges
(
)
;
protected
:
nscoord
mAscent
;
static_assert
(
sizeof
(
FlagBits
)
<
=
sizeof
(
uint32_t
)
"
size
of
FlagBits
should
not
be
larger
than
size
of
uint32_t
"
)
;
union
{
uint32_t
mAllFlags
;
FlagBits
mFlags
;
}
;
StyleClear
BreakType
(
)
const
{
return
mFlags
.
mBreakType
;
}
;
union
{
ExtraData
*
mData
;
ExtraBlockData
*
mBlockData
;
ExtraInlineData
*
mInlineData
;
}
;
void
Cleanup
(
)
;
void
MaybeFreeData
(
)
;
}
;
class
nsLineList_iterator
{
public
:
friend
class
nsLineList
;
friend
class
nsLineList_reverse_iterator
;
friend
class
nsLineList_const_iterator
;
friend
class
nsLineList_const_reverse_iterator
;
typedef
nsLineList_iterator
iterator_self_type
;
typedef
nsLineList_reverse_iterator
iterator_reverse_type
;
typedef
nsLineBox
&
reference
;
typedef
const
nsLineBox
&
const_reference
;
typedef
nsLineBox
*
pointer
;
typedef
const
nsLineBox
*
const_pointer
;
typedef
uint32_t
size_type
;
typedef
int32_t
difference_type
;
typedef
nsLineLink
link_type
;
#
ifdef
DEBUG
nsLineList_iterator
(
)
:
mListLink
(
nullptr
)
{
memset
(
&
mCurrent
0xcd
sizeof
(
mCurrent
)
)
;
}
#
else
#
endif
inline
iterator_self_type
&
operator
=
(
const
iterator_self_type
&
aOther
)
;
inline
iterator_self_type
&
operator
=
(
const
iterator_reverse_type
&
aOther
)
;
iterator_self_type
&
operator
+
+
(
)
{
mCurrent
=
mCurrent
-
>
_mNext
;
return
*
this
;
}
iterator_self_type
operator
+
+
(
int
)
{
iterator_self_type
rv
(
*
this
)
;
mCurrent
=
mCurrent
-
>
_mNext
;
return
rv
;
}
iterator_self_type
&
operator
-
-
(
)
{
mCurrent
=
mCurrent
-
>
_mPrev
;
return
*
this
;
}
iterator_self_type
operator
-
-
(
int
)
{
iterator_self_type
rv
(
*
this
)
;
mCurrent
=
mCurrent
-
>
_mPrev
;
return
rv
;
}
reference
operator
*
(
)
{
MOZ_ASSERT
(
mListLink
)
;
MOZ_ASSERT
(
mCurrent
!
=
mListLink
"
running
past
end
"
)
;
return
*
static_cast
<
pointer
>
(
mCurrent
)
;
}
pointer
operator
-
>
(
)
{
MOZ_ASSERT
(
mListLink
)
;
MOZ_ASSERT
(
mCurrent
!
=
mListLink
"
running
past
end
"
)
;
return
static_cast
<
pointer
>
(
mCurrent
)
;
}
pointer
get
(
)
{
MOZ_ASSERT
(
mListLink
)
;
MOZ_ASSERT
(
mCurrent
!
=
mListLink
"
running
past
end
"
)
;
return
static_cast
<
pointer
>
(
mCurrent
)
;
}
operator
pointer
(
)
{
MOZ_ASSERT
(
mListLink
)
;
MOZ_ASSERT
(
mCurrent
!
=
mListLink
"
running
past
end
"
)
;
return
static_cast
<
pointer
>
(
mCurrent
)
;
}
const_reference
operator
*
(
)
const
{
MOZ_ASSERT
(
mListLink
)
;
MOZ_ASSERT
(
mCurrent
!
=
mListLink
"
running
past
end
"
)
;
return
*
static_cast
<
const_pointer
>
(
mCurrent
)
;
}
const_pointer
operator
-
>
(
)
const
{
MOZ_ASSERT
(
mListLink
)
;
MOZ_ASSERT
(
mCurrent
!
=
mListLink
"
running
past
end
"
)
;
return
static_cast
<
const_pointer
>
(
mCurrent
)
;
}
#
ifndef
__MWERKS__
operator
const_pointer
(
)
const
{
MOZ_ASSERT
(
mListLink
)
;
MOZ_ASSERT
(
mCurrent
!
=
mListLink
"
running
past
end
"
)
;
return
static_cast
<
const_pointer
>
(
mCurrent
)
;
}
#
endif
iterator_self_type
next
(
)
{
iterator_self_type
copy
(
*
this
)
;
return
+
+
copy
;
}
const
iterator_self_type
next
(
)
const
{
iterator_self_type
copy
(
*
this
)
;
return
+
+
copy
;
}
iterator_self_type
prev
(
)
{
iterator_self_type
copy
(
*
this
)
;
return
-
-
copy
;
}
const
iterator_self_type
prev
(
)
const
{
iterator_self_type
copy
(
*
this
)
;
return
-
-
copy
;
}
bool
operator
=
=
(
const
iterator_self_type
aOther
)
const
{
MOZ_ASSERT
(
mListLink
)
;
MOZ_ASSERT
(
mListLink
=
=
aOther
.
mListLink
"
comparing
iterators
over
different
lists
"
)
;
return
mCurrent
=
=
aOther
.
mCurrent
;
}
bool
operator
!
=
(
const
iterator_self_type
aOther
)
const
{
MOZ_ASSERT
(
mListLink
)
;
MOZ_ASSERT
(
mListLink
=
=
aOther
.
mListLink
"
comparing
iterators
over
different
lists
"
)
;
return
mCurrent
!
=
aOther
.
mCurrent
;
}
bool
operator
=
=
(
const
iterator_self_type
aOther
)
{
MOZ_ASSERT
(
mListLink
)
;
MOZ_ASSERT
(
mListLink
=
=
aOther
.
mListLink
"
comparing
iterators
over
different
lists
"
)
;
return
mCurrent
=
=
aOther
.
mCurrent
;
}
bool
operator
!
=
(
const
iterator_self_type
aOther
)
{
MOZ_ASSERT
(
mListLink
)
;
MOZ_ASSERT
(
mListLink
=
=
aOther
.
mListLink
"
comparing
iterators
over
different
lists
"
)
;
return
mCurrent
!
=
aOther
.
mCurrent
;
}
#
ifdef
DEBUG
bool
IsInSameList
(
const
iterator_self_type
aOther
)
const
{
return
mListLink
=
=
aOther
.
mListLink
;
}
#
endif
private
:
link_type
*
mCurrent
;
#
ifdef
DEBUG
link_type
*
mListLink
;
#
endif
}
;
class
nsLineList_reverse_iterator
{
public
:
friend
class
nsLineList
;
friend
class
nsLineList_iterator
;
friend
class
nsLineList_const_iterator
;
friend
class
nsLineList_const_reverse_iterator
;
typedef
nsLineList_reverse_iterator
iterator_self_type
;
typedef
nsLineList_iterator
iterator_reverse_type
;
typedef
nsLineBox
&
reference
;
typedef
const
nsLineBox
&
const_reference
;
typedef
nsLineBox
*
pointer
;
typedef
const
nsLineBox
*
const_pointer
;
typedef
uint32_t
size_type
;
typedef
int32_t
difference_type
;
typedef
nsLineLink
link_type
;
#
ifdef
DEBUG
nsLineList_reverse_iterator
(
)
:
mListLink
(
nullptr
)
{
memset
(
&
mCurrent
0xcd
sizeof
(
mCurrent
)
)
;
}
#
else
#
endif
inline
iterator_self_type
&
operator
=
(
const
iterator_reverse_type
&
aOther
)
;
inline
iterator_self_type
&
operator
=
(
const
iterator_self_type
&
aOther
)
;
iterator_self_type
&
operator
+
+
(
)
{
mCurrent
=
mCurrent
-
>
_mPrev
;
return
*
this
;
}
iterator_self_type
operator
+
+
(
int
)
{
iterator_self_type
rv
(
*
this
)
;
mCurrent
=
mCurrent
-
>
_mPrev
;
return
rv
;
}
iterator_self_type
&
operator
-
-
(
)
{
mCurrent
=
mCurrent
-
>
_mNext
;
return
*
this
;
}
iterator_self_type
operator
-
-
(
int
)
{
iterator_self_type
rv
(
*
this
)
;
mCurrent
=
mCurrent
-
>
_mNext
;
return
rv
;
}
reference
operator
*
(
)
{
MOZ_ASSERT
(
mListLink
)
;
MOZ_ASSERT
(
mCurrent
!
=
mListLink
"
running
past
end
"
)
;
return
*
static_cast
<
pointer
>
(
mCurrent
)
;
}
pointer
operator
-
>
(
)
{
MOZ_ASSERT
(
mListLink
)
;
MOZ_ASSERT
(
mCurrent
!
=
mListLink
"
running
past
end
"
)
;
return
static_cast
<
pointer
>
(
mCurrent
)
;
}
pointer
get
(
)
{
MOZ_ASSERT
(
mListLink
)
;
MOZ_ASSERT
(
mCurrent
!
=
mListLink
"
running
past
end
"
)
;
return
static_cast
<
pointer
>
(
mCurrent
)
;
}
operator
pointer
(
)
{
MOZ_ASSERT
(
mListLink
)
;
MOZ_ASSERT
(
mCurrent
!
=
mListLink
"
running
past
end
"
)
;
return
static_cast
<
pointer
>
(
mCurrent
)
;
}
const_reference
operator
*
(
)
const
{
MOZ_ASSERT
(
mListLink
)
;
MOZ_ASSERT
(
mCurrent
!
=
mListLink
"
running
past
end
"
)
;
return
*
static_cast
<
const_pointer
>
(
mCurrent
)
;
}
const_pointer
operator
-
>
(
)
const
{
MOZ_ASSERT
(
mListLink
)
;
MOZ_ASSERT
(
mCurrent
!
=
mListLink
"
running
past
end
"
)
;
return
static_cast
<
const_pointer
>
(
mCurrent
)
;
}
#
ifndef
__MWERKS__
operator
const_pointer
(
)
const
{
MOZ_ASSERT
(
mListLink
)
;
MOZ_ASSERT
(
mCurrent
!
=
mListLink
"
running
past
end
"
)
;
return
static_cast
<
const_pointer
>
(
mCurrent
)
;
}
#
endif
bool
operator
=
=
(
const
iterator_self_type
aOther
)
const
{
MOZ_ASSERT
(
mListLink
)
;
NS_ASSERTION
(
mListLink
=
=
aOther
.
mListLink
"
comparing
iterators
over
different
lists
"
)
;
return
mCurrent
=
=
aOther
.
mCurrent
;
}
bool
operator
!
=
(
const
iterator_self_type
aOther
)
const
{
MOZ_ASSERT
(
mListLink
)
;
NS_ASSERTION
(
mListLink
=
=
aOther
.
mListLink
"
comparing
iterators
over
different
lists
"
)
;
return
mCurrent
!
=
aOther
.
mCurrent
;
}
bool
operator
=
=
(
const
iterator_self_type
aOther
)
{
MOZ_ASSERT
(
mListLink
)
;
NS_ASSERTION
(
mListLink
=
=
aOther
.
mListLink
"
comparing
iterators
over
different
lists
"
)
;
return
mCurrent
=
=
aOther
.
mCurrent
;
}
bool
operator
!
=
(
const
iterator_self_type
aOther
)
{
MOZ_ASSERT
(
mListLink
)
;
NS_ASSERTION
(
mListLink
=
=
aOther
.
mListLink
"
comparing
iterators
over
different
lists
"
)
;
return
mCurrent
!
=
aOther
.
mCurrent
;
}
#
ifdef
DEBUG
bool
IsInSameList
(
const
iterator_self_type
aOther
)
const
{
return
mListLink
=
=
aOther
.
mListLink
;
}
#
endif
private
:
link_type
*
mCurrent
;
#
ifdef
DEBUG
link_type
*
mListLink
;
#
endif
}
;
class
nsLineList_const_iterator
{
public
:
friend
class
nsLineList
;
friend
class
nsLineList_iterator
;
friend
class
nsLineList_reverse_iterator
;
friend
class
nsLineList_const_reverse_iterator
;
typedef
nsLineList_const_iterator
iterator_self_type
;
typedef
nsLineList_const_reverse_iterator
iterator_reverse_type
;
typedef
nsLineList_iterator
iterator_nonconst_type
;
typedef
nsLineList_reverse_iterator
iterator_nonconst_reverse_type
;
typedef
nsLineBox
&
reference
;
typedef
const
nsLineBox
&
const_reference
;
typedef
nsLineBox
*
pointer
;
typedef
const
nsLineBox
*
const_pointer
;
typedef
uint32_t
size_type
;
typedef
int32_t
difference_type
;
typedef
nsLineLink
link_type
;
#
ifdef
DEBUG
nsLineList_const_iterator
(
)
:
mListLink
(
nullptr
)
{
memset
(
&
mCurrent
0xcd
sizeof
(
mCurrent
)
)
;
}
#
else
#
endif
inline
iterator_self_type
&
operator
=
(
const
iterator_nonconst_type
&
aOther
)
;
inline
iterator_self_type
&
operator
=
(
const
iterator_nonconst_reverse_type
&
aOther
)
;
inline
iterator_self_type
&
operator
=
(
const
iterator_self_type
&
aOther
)
;
inline
iterator_self_type
&
operator
=
(
const
iterator_reverse_type
&
aOther
)
;
iterator_self_type
&
operator
+
+
(
)
{
mCurrent
=
mCurrent
-
>
_mNext
;
return
*
this
;
}
iterator_self_type
operator
+
+
(
int
)
{
iterator_self_type
rv
(
*
this
)
;
mCurrent
=
mCurrent
-
>
_mNext
;
return
rv
;
}
iterator_self_type
&
operator
-
-
(
)
{
mCurrent
=
mCurrent
-
>
_mPrev
;
return
*
this
;
}
iterator_self_type
operator
-
-
(
int
)
{
iterator_self_type
rv
(
*
this
)
;
mCurrent
=
mCurrent
-
>
_mPrev
;
return
rv
;
}
const_reference
operator
*
(
)
const
{
MOZ_ASSERT
(
mListLink
)
;
MOZ_ASSERT
(
mCurrent
!
=
mListLink
"
running
past
end
"
)
;
return
*
static_cast
<
const_pointer
>
(
mCurrent
)
;
}
const_pointer
operator
-
>
(
)
const
{
MOZ_ASSERT
(
mListLink
)
;
MOZ_ASSERT
(
mCurrent
!
=
mListLink
"
running
past
end
"
)
;
return
static_cast
<
const_pointer
>
(
mCurrent
)
;
}
const_pointer
get
(
)
const
{
MOZ_ASSERT
(
mListLink
)
;
MOZ_ASSERT
(
mCurrent
!
=
mListLink
"
running
past
end
"
)
;
return
static_cast
<
const_pointer
>
(
mCurrent
)
;
}
#
ifndef
__MWERKS__
operator
const_pointer
(
)
const
{
MOZ_ASSERT
(
mListLink
)
;
MOZ_ASSERT
(
mCurrent
!
=
mListLink
"
running
past
end
"
)
;
return
static_cast
<
const_pointer
>
(
mCurrent
)
;
}
#
endif
const
iterator_self_type
next
(
)
const
{
iterator_self_type
copy
(
*
this
)
;
return
+
+
copy
;
}
const
iterator_self_type
prev
(
)
const
{
iterator_self_type
copy
(
*
this
)
;
return
-
-
copy
;
}
bool
operator
=
=
(
const
iterator_self_type
aOther
)
const
{
MOZ_ASSERT
(
mListLink
)
;
NS_ASSERTION
(
mListLink
=
=
aOther
.
mListLink
"
comparing
iterators
over
different
lists
"
)
;
return
mCurrent
=
=
aOther
.
mCurrent
;
}
bool
operator
!
=
(
const
iterator_self_type
aOther
)
const
{
MOZ_ASSERT
(
mListLink
)
;
NS_ASSERTION
(
mListLink
=
=
aOther
.
mListLink
"
comparing
iterators
over
different
lists
"
)
;
return
mCurrent
!
=
aOther
.
mCurrent
;
}
bool
operator
=
=
(
const
iterator_self_type
aOther
)
{
MOZ_ASSERT
(
mListLink
)
;
NS_ASSERTION
(
mListLink
=
=
aOther
.
mListLink
"
comparing
iterators
over
different
lists
"
)
;
return
mCurrent
=
=
aOther
.
mCurrent
;
}
bool
operator
!
=
(
const
iterator_self_type
aOther
)
{
MOZ_ASSERT
(
mListLink
)
;
NS_ASSERTION
(
mListLink
=
=
aOther
.
mListLink
"
comparing
iterators
over
different
lists
"
)
;
return
mCurrent
!
=
aOther
.
mCurrent
;
}
#
ifdef
DEBUG
bool
IsInSameList
(
const
iterator_self_type
aOther
)
const
{
return
mListLink
=
=
aOther
.
mListLink
;
}
#
endif
private
:
const
link_type
*
mCurrent
;
#
ifdef
DEBUG
const
link_type
*
mListLink
;
#
endif
}
;
class
nsLineList_const_reverse_iterator
{
public
:
friend
class
nsLineList
;
friend
class
nsLineList_iterator
;
friend
class
nsLineList_reverse_iterator
;
friend
class
nsLineList_const_iterator
;
typedef
nsLineList_const_reverse_iterator
iterator_self_type
;
typedef
nsLineList_const_iterator
iterator_reverse_type
;
typedef
nsLineList_iterator
iterator_nonconst_reverse_type
;
typedef
nsLineList_reverse_iterator
iterator_nonconst_type
;
typedef
nsLineBox
&
reference
;
typedef
const
nsLineBox
&
const_reference
;
typedef
nsLineBox
*
pointer
;
typedef
const
nsLineBox
*
const_pointer
;
typedef
uint32_t
size_type
;
typedef
int32_t
difference_type
;
typedef
nsLineLink
link_type
;
#
ifdef
DEBUG
nsLineList_const_reverse_iterator
(
)
:
mListLink
(
nullptr
)
{
memset
(
&
mCurrent
0xcd
sizeof
(
mCurrent
)
)
;
}
#
else
#
endif
inline
iterator_self_type
&
operator
=
(
const
iterator_nonconst_type
&
aOther
)
;
inline
iterator_self_type
&
operator
=
(
const
iterator_nonconst_reverse_type
&
aOther
)
;
inline
iterator_self_type
&
operator
=
(
const
iterator_self_type
&
aOther
)
;
inline
iterator_self_type
&
operator
=
(
const
iterator_reverse_type
&
aOther
)
;
iterator_self_type
&
operator
+
+
(
)
{
mCurrent
=
mCurrent
-
>
_mPrev
;
return
*
this
;
}
iterator_self_type
operator
+
+
(
int
)
{
iterator_self_type
rv
(
*
this
)
;
mCurrent
=
mCurrent
-
>
_mPrev
;
return
rv
;
}
iterator_self_type
&
operator
-
-
(
)
{
mCurrent
=
mCurrent
-
>
_mNext
;
return
*
this
;
}
iterator_self_type
operator
-
-
(
int
)
{
iterator_self_type
rv
(
*
this
)
;
mCurrent
=
mCurrent
-
>
_mNext
;
return
rv
;
}
const_reference
operator
*
(
)
const
{
MOZ_ASSERT
(
mListLink
)
;
MOZ_ASSERT
(
mCurrent
!
=
mListLink
"
running
past
end
"
)
;
return
*
static_cast
<
const_pointer
>
(
mCurrent
)
;
}
const_pointer
operator
-
>
(
)
const
{
MOZ_ASSERT
(
mListLink
)
;
MOZ_ASSERT
(
mCurrent
!
=
mListLink
"
running
past
end
"
)
;
return
static_cast
<
const_pointer
>
(
mCurrent
)
;
}
const_pointer
get
(
)
const
{
MOZ_ASSERT
(
mListLink
)
;
MOZ_ASSERT
(
mCurrent
!
=
mListLink
"
running
past
end
"
)
;
return
static_cast
<
const_pointer
>
(
mCurrent
)
;
}
#
ifndef
__MWERKS__
operator
const_pointer
(
)
const
{
MOZ_ASSERT
(
mListLink
)
;
MOZ_ASSERT
(
mCurrent
!
=
mListLink
"
running
past
end
"
)
;
return
static_cast
<
const_pointer
>
(
mCurrent
)
;
}
#
endif
bool
operator
=
=
(
const
iterator_self_type
aOther
)
const
{
MOZ_ASSERT
(
mListLink
)
;
NS_ASSERTION
(
mListLink
=
=
aOther
.
mListLink
"
comparing
iterators
over
different
lists
"
)
;
return
mCurrent
=
=
aOther
.
mCurrent
;
}
bool
operator
!
=
(
const
iterator_self_type
aOther
)
const
{
MOZ_ASSERT
(
mListLink
)
;
NS_ASSERTION
(
mListLink
=
=
aOther
.
mListLink
"
comparing
iterators
over
different
lists
"
)
;
return
mCurrent
!
=
aOther
.
mCurrent
;
}
bool
operator
=
=
(
const
iterator_self_type
aOther
)
{
MOZ_ASSERT
(
mListLink
)
;
NS_ASSERTION
(
mListLink
=
=
aOther
.
mListLink
"
comparing
iterators
over
different
lists
"
)
;
return
mCurrent
=
=
aOther
.
mCurrent
;
}
bool
operator
!
=
(
const
iterator_self_type
aOther
)
{
MOZ_ASSERT
(
mListLink
)
;
NS_ASSERTION
(
mListLink
=
=
aOther
.
mListLink
"
comparing
iterators
over
different
lists
"
)
;
return
mCurrent
!
=
aOther
.
mCurrent
;
}
#
ifdef
DEBUG
bool
IsInSameList
(
const
iterator_self_type
aOther
)
const
{
return
mListLink
=
=
aOther
.
mListLink
;
}
#
endif
const
link_type
*
mCurrent
;
#
ifdef
DEBUG
const
link_type
*
mListLink
;
#
endif
}
;
class
nsLineList
{
public
:
friend
class
nsLineList_iterator
;
friend
class
nsLineList_reverse_iterator
;
friend
class
nsLineList_const_iterator
;
friend
class
nsLineList_const_reverse_iterator
;
typedef
uint32_t
size_type
;
typedef
int32_t
difference_type
;
typedef
nsLineLink
link_type
;
private
:
link_type
mLink
;
public
:
typedef
nsLineList
self_type
;
typedef
nsLineBox
&
reference
;
typedef
const
nsLineBox
&
const_reference
;
typedef
nsLineBox
*
pointer
;
typedef
const
nsLineBox
*
const_pointer
;
typedef
nsLineList_iterator
iterator
;
typedef
nsLineList_reverse_iterator
reverse_iterator
;
typedef
nsLineList_const_iterator
const_iterator
;
typedef
nsLineList_const_reverse_iterator
const_reverse_iterator
;
nsLineList
(
)
{
MOZ_COUNT_CTOR
(
nsLineList
)
;
clear
(
)
;
}
MOZ_COUNTED_DTOR
(
nsLineList
)
const_iterator
begin
(
)
const
{
const_iterator
rv
;
rv
.
mCurrent
=
mLink
.
_mNext
;
#
ifdef
DEBUG
rv
.
mListLink
=
&
mLink
;
#
endif
return
rv
;
}
iterator
begin
(
)
{
iterator
rv
;
rv
.
mCurrent
=
mLink
.
_mNext
;
#
ifdef
DEBUG
rv
.
mListLink
=
&
mLink
;
#
endif
return
rv
;
}
iterator
begin
(
nsLineBox
*
aLine
)
{
iterator
rv
;
rv
.
mCurrent
=
aLine
;
#
ifdef
DEBUG
rv
.
mListLink
=
&
mLink
;
#
endif
return
rv
;
}
const_iterator
end
(
)
const
{
const_iterator
rv
;
rv
.
mCurrent
=
&
mLink
;
#
ifdef
DEBUG
rv
.
mListLink
=
&
mLink
;
#
endif
return
rv
;
}
iterator
end
(
)
{
iterator
rv
;
rv
.
mCurrent
=
&
mLink
;
#
ifdef
DEBUG
rv
.
mListLink
=
&
mLink
;
#
endif
return
rv
;
}
const_reverse_iterator
rbegin
(
)
const
{
const_reverse_iterator
rv
;
rv
.
mCurrent
=
mLink
.
_mPrev
;
#
ifdef
DEBUG
rv
.
mListLink
=
&
mLink
;
#
endif
return
rv
;
}
reverse_iterator
rbegin
(
)
{
reverse_iterator
rv
;
rv
.
mCurrent
=
mLink
.
_mPrev
;
#
ifdef
DEBUG
rv
.
mListLink
=
&
mLink
;
#
endif
return
rv
;
}
reverse_iterator
rbegin
(
nsLineBox
*
aLine
)
{
reverse_iterator
rv
;
rv
.
mCurrent
=
aLine
;
#
ifdef
DEBUG
rv
.
mListLink
=
&
mLink
;
#
endif
return
rv
;
}
const_reverse_iterator
rend
(
)
const
{
const_reverse_iterator
rv
;
rv
.
mCurrent
=
&
mLink
;
#
ifdef
DEBUG
rv
.
mListLink
=
&
mLink
;
#
endif
return
rv
;
}
reverse_iterator
rend
(
)
{
reverse_iterator
rv
;
rv
.
mCurrent
=
&
mLink
;
#
ifdef
DEBUG
rv
.
mListLink
=
&
mLink
;
#
endif
return
rv
;
}
bool
empty
(
)
const
{
return
mLink
.
_mNext
=
=
&
mLink
;
}
size_type
size
(
)
const
{
size_type
count
=
0
;
for
(
const
link_type
*
cur
=
mLink
.
_mNext
;
cur
!
=
&
mLink
;
cur
=
cur
-
>
_mNext
)
{
+
+
count
;
}
return
count
;
}
pointer
front
(
)
{
NS_ASSERTION
(
!
empty
(
)
"
no
element
to
return
"
)
;
return
static_cast
<
pointer
>
(
mLink
.
_mNext
)
;
}
const_pointer
front
(
)
const
{
NS_ASSERTION
(
!
empty
(
)
"
no
element
to
return
"
)
;
return
static_cast
<
const_pointer
>
(
mLink
.
_mNext
)
;
}
pointer
back
(
)
{
NS_ASSERTION
(
!
empty
(
)
"
no
element
to
return
"
)
;
return
static_cast
<
pointer
>
(
mLink
.
_mPrev
)
;
}
const_pointer
back
(
)
const
{
NS_ASSERTION
(
!
empty
(
)
"
no
element
to
return
"
)
;
return
static_cast
<
const_pointer
>
(
mLink
.
_mPrev
)
;
}
void
push_front
(
pointer
aNew
)
{
aNew
-
>
_mNext
=
mLink
.
_mNext
;
mLink
.
_mNext
-
>
_mPrev
=
aNew
;
aNew
-
>
_mPrev
=
&
mLink
;
mLink
.
_mNext
=
aNew
;
}
void
pop_front
(
)
{
NS_ASSERTION
(
!
empty
(
)
"
no
element
to
pop
"
)
;
link_type
*
newFirst
=
mLink
.
_mNext
-
>
_mNext
;
newFirst
-
>
_mPrev
=
&
mLink
;
mLink
.
_mNext
=
newFirst
;
}
void
push_back
(
pointer
aNew
)
{
aNew
-
>
_mPrev
=
mLink
.
_mPrev
;
mLink
.
_mPrev
-
>
_mNext
=
aNew
;
aNew
-
>
_mNext
=
&
mLink
;
mLink
.
_mPrev
=
aNew
;
}
void
pop_back
(
)
{
NS_ASSERTION
(
!
empty
(
)
"
no
element
to
pop
"
)
;
link_type
*
newLast
=
mLink
.
_mPrev
-
>
_mPrev
;
newLast
-
>
_mNext
=
&
mLink
;
mLink
.
_mPrev
=
newLast
;
}
iterator
before_insert
(
iterator
position
pointer
x
)
{
x
-
>
_mPrev
=
position
.
mCurrent
-
>
_mPrev
;
x
-
>
_mNext
=
position
.
mCurrent
;
position
.
mCurrent
-
>
_mPrev
-
>
_mNext
=
x
;
position
.
mCurrent
-
>
_mPrev
=
x
;
return
-
-
position
;
}
iterator
after_insert
(
iterator
position
pointer
x
)
{
x
-
>
_mNext
=
position
.
mCurrent
-
>
_mNext
;
x
-
>
_mPrev
=
position
.
mCurrent
;
position
.
mCurrent
-
>
_mNext
-
>
_mPrev
=
x
;
position
.
mCurrent
-
>
_mNext
=
x
;
return
+
+
position
;
}
iterator
erase
(
iterator
position
)
{
position
-
>
_mPrev
-
>
_mNext
=
position
-
>
_mNext
;
position
-
>
_mNext
-
>
_mPrev
=
position
-
>
_mPrev
;
return
+
+
position
;
}
void
swap
(
self_type
&
y
)
{
link_type
tmp
(
y
.
mLink
)
;
y
.
mLink
=
mLink
;
mLink
=
tmp
;
if
(
!
empty
(
)
)
{
mLink
.
_mNext
-
>
_mPrev
=
&
mLink
;
mLink
.
_mPrev
-
>
_mNext
=
&
mLink
;
}
if
(
!
y
.
empty
(
)
)
{
y
.
mLink
.
_mNext
-
>
_mPrev
=
&
y
.
mLink
;
y
.
mLink
.
_mPrev
-
>
_mNext
=
&
y
.
mLink
;
}
}
void
clear
(
)
{
mLink
.
_mNext
=
&
mLink
;
mLink
.
_mPrev
=
&
mLink
;
}
void
splice
(
iterator
position
self_type
&
x
)
{
position
.
mCurrent
-
>
_mPrev
-
>
_mNext
=
x
.
mLink
.
_mNext
;
x
.
mLink
.
_mNext
-
>
_mPrev
=
position
.
mCurrent
-
>
_mPrev
;
x
.
mLink
.
_mPrev
-
>
_mNext
=
position
.
mCurrent
;
position
.
mCurrent
-
>
_mPrev
=
x
.
mLink
.
_mPrev
;
x
.
clear
(
)
;
}
void
splice
(
iterator
position
self_type
&
x
iterator
i
)
{
NS_ASSERTION
(
!
x
.
empty
(
)
"
Can
'
t
insert
from
empty
list
.
"
)
;
NS_ASSERTION
(
position
!
=
i
&
&
position
.
mCurrent
!
=
i
-
>
_mNext
"
We
don
'
t
check
for
this
case
.
"
)
;
i
-
>
_mPrev
-
>
_mNext
=
i
-
>
_mNext
;
i
-
>
_mNext
-
>
_mPrev
=
i
-
>
_mPrev
;
i
-
>
_mPrev
=
position
.
mCurrent
-
>
_mPrev
;
position
.
mCurrent
-
>
_mPrev
-
>
_mNext
=
i
.
get
(
)
;
i
-
>
_mNext
=
position
.
mCurrent
;
position
.
mCurrent
-
>
_mPrev
=
i
.
get
(
)
;
}
void
splice
(
iterator
position
self_type
&
x
iterator
first
iterator
last
)
{
NS_ASSERTION
(
!
x
.
empty
(
)
"
Can
'
t
insert
from
empty
list
.
"
)
;
if
(
first
=
=
last
)
return
;
-
-
last
;
first
-
>
_mPrev
-
>
_mNext
=
last
-
>
_mNext
;
last
-
>
_mNext
-
>
_mPrev
=
first
-
>
_mPrev
;
first
-
>
_mPrev
=
position
.
mCurrent
-
>
_mPrev
;
position
.
mCurrent
-
>
_mPrev
-
>
_mNext
=
first
.
get
(
)
;
last
-
>
_mNext
=
position
.
mCurrent
;
position
.
mCurrent
-
>
_mPrev
=
last
.
get
(
)
;
}
}
;
#
ifdef
DEBUG
#
define
ASSIGN_FROM
(
other_
)
\
mCurrent
=
other_
.
mCurrent
;
\
mListLink
=
other_
.
mListLink
;
\
return
*
this
;
#
else
#
define
ASSIGN_FROM
(
other_
)
\
mCurrent
=
other_
.
mCurrent
;
\
return
*
this
;
#
endif
inline
nsLineList_iterator
&
nsLineList_iterator
:
:
operator
=
(
const
nsLineList_iterator
&
aOther
)
=
default
;
inline
nsLineList_iterator
&
nsLineList_iterator
:
:
operator
=
(
const
nsLineList_reverse_iterator
&
aOther
)
{
ASSIGN_FROM
(
aOther
)
}
inline
nsLineList_reverse_iterator
&
nsLineList_reverse_iterator
:
:
operator
=
(
const
nsLineList_iterator
&
aOther
)
{
ASSIGN_FROM
(
aOther
)
}
inline
nsLineList_reverse_iterator
&
nsLineList_reverse_iterator
:
:
operator
=
(
const
nsLineList_reverse_iterator
&
aOther
)
=
default
;
inline
nsLineList_const_iterator
&
nsLineList_const_iterator
:
:
operator
=
(
const
nsLineList_iterator
&
aOther
)
{
ASSIGN_FROM
(
aOther
)
}
inline
nsLineList_const_iterator
&
nsLineList_const_iterator
:
:
operator
=
(
const
nsLineList_reverse_iterator
&
aOther
)
{
ASSIGN_FROM
(
aOther
)
}
inline
nsLineList_const_iterator
&
nsLineList_const_iterator
:
:
operator
=
(
const
nsLineList_const_iterator
&
aOther
)
=
default
;
inline
nsLineList_const_iterator
&
nsLineList_const_iterator
:
:
operator
=
(
const
nsLineList_const_reverse_iterator
&
aOther
)
{
ASSIGN_FROM
(
aOther
)
}
inline
nsLineList_const_reverse_iterator
&
nsLineList_const_reverse_iterator
:
:
operator
=
(
const
nsLineList_iterator
&
aOther
)
{
ASSIGN_FROM
(
aOther
)
}
inline
nsLineList_const_reverse_iterator
&
nsLineList_const_reverse_iterator
:
:
operator
=
(
const
nsLineList_reverse_iterator
&
aOther
)
{
ASSIGN_FROM
(
aOther
)
}
inline
nsLineList_const_reverse_iterator
&
nsLineList_const_reverse_iterator
:
:
operator
=
(
const
nsLineList_const_iterator
&
aOther
)
{
ASSIGN_FROM
(
aOther
)
}
inline
nsLineList_const_reverse_iterator
&
nsLineList_const_reverse_iterator
:
:
operator
=
(
const
nsLineList_const_reverse_iterator
&
aOther
)
=
default
;
class
nsLineIterator
final
:
public
nsILineIterator
{
public
:
nsLineIterator
(
const
nsLineList
&
aLines
bool
aRightToLeft
)
:
mLines
(
aLines
)
mRightToLeft
(
aRightToLeft
)
{
mIter
=
mLines
.
begin
(
)
;
if
(
mIter
!
=
mLines
.
end
(
)
)
{
mIndex
=
0
;
}
}
~
nsLineIterator
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mMutationGuard
.
Mutated
(
0
)
)
;
}
;
void
DisposeLineIterator
(
)
final
{
delete
this
;
}
int32_t
GetNumLines
(
)
const
final
{
if
(
mNumLines
<
0
)
{
mNumLines
=
int32_t
(
mLines
.
size
(
)
)
;
}
return
mNumLines
;
}
bool
GetDirection
(
)
final
{
return
mRightToLeft
;
}
mozilla
:
:
Result
<
LineInfo
nsresult
>
GetLine
(
int32_t
aLineNumber
)
final
;
int32_t
FindLineContaining
(
nsIFrame
*
aFrame
int32_t
aStartLine
=
0
)
final
;
NS_IMETHOD
FindFrameAt
(
int32_t
aLineNumber
nsPoint
aPos
nsIFrame
*
*
aFrameFound
bool
*
aPosIsBeforeFirstFrame
bool
*
aPosIsAfterLastFrame
)
final
;
NS_IMETHOD
CheckLineOrder
(
int32_t
aLine
bool
*
aIsReordered
nsIFrame
*
*
aFirstVisual
nsIFrame
*
*
aLastVisual
)
final
;
private
:
nsLineIterator
(
)
=
delete
;
nsLineIterator
(
const
nsLineIterator
&
aOther
)
=
delete
;
const
nsLineBox
*
GetNextLine
(
)
{
MOZ_ASSERT
(
mIter
!
=
mLines
.
end
(
)
"
Already
at
end
!
"
)
;
+
+
mIndex
;
+
+
mIter
;
return
mIter
=
=
mLines
.
end
(
)
?
nullptr
:
mIter
.
get
(
)
;
}
const
nsLineBox
*
GetLineAt
(
int32_t
aIndex
)
{
if
(
aIndex
<
0
|
|
(
mNumLines
>
=
0
&
&
aIndex
>
=
mNumLines
)
)
{
return
nullptr
;
}
while
(
mIndex
>
aIndex
)
{
-
-
mIter
;
-
-
mIndex
;
}
while
(
mIndex
<
aIndex
)
{
if
(
mIter
=
=
mLines
.
end
(
)
)
{
return
nullptr
;
}
+
+
mIter
;
+
+
mIndex
;
}
return
mIter
.
get
(
)
;
}
const
nsLineList
&
mLines
;
nsLineList_const_iterator
mIter
;
int32_t
mIndex
=
-
1
;
mutable
int32_t
mNumLines
=
-
1
;
const
bool
mRightToLeft
;
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
nsMutationGuard
mMutationGuard
;
#
endif
}
;
#
endif
