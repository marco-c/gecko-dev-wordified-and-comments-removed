#
ifndef
nsBlockFrame_h___
#
define
nsBlockFrame_h___
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsHTMLParts
.
h
"
#
include
"
nsLineBox
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsFloatManager
.
h
"
enum
class
LineReflowStatus
{
OK
Stop
RedoNoPull
RedoMoreFloats
RedoNextBand
Truncated
}
;
class
nsBlockInFlowLineIterator
;
namespace
mozilla
{
class
BlockReflowInput
;
class
PresShell
;
class
ServoRestyleState
;
class
ServoStyleSet
;
}
class
nsBlockFrame
:
public
nsContainerFrame
{
using
BlockReflowInput
=
mozilla
:
:
BlockReflowInput
;
public
:
NS_DECL_FRAMEARENA_HELPERS
(
nsBlockFrame
)
typedef
nsLineList
:
:
iterator
LineIterator
;
typedef
nsLineList
:
:
const_iterator
ConstLineIterator
;
typedef
nsLineList
:
:
reverse_iterator
ReverseLineIterator
;
typedef
nsLineList
:
:
const_reverse_iterator
ConstReverseLineIterator
;
LineIterator
LinesBegin
(
)
{
return
mLines
.
begin
(
)
;
}
LineIterator
LinesEnd
(
)
{
return
mLines
.
end
(
)
;
}
ConstLineIterator
LinesBegin
(
)
const
{
return
mLines
.
begin
(
)
;
}
ConstLineIterator
LinesEnd
(
)
const
{
return
mLines
.
end
(
)
;
}
ReverseLineIterator
LinesRBegin
(
)
{
return
mLines
.
rbegin
(
)
;
}
ReverseLineIterator
LinesREnd
(
)
{
return
mLines
.
rend
(
)
;
}
ConstReverseLineIterator
LinesRBegin
(
)
const
{
return
mLines
.
rbegin
(
)
;
}
ConstReverseLineIterator
LinesREnd
(
)
const
{
return
mLines
.
rend
(
)
;
}
LineIterator
LinesBeginFrom
(
nsLineBox
*
aList
)
{
return
mLines
.
begin
(
aList
)
;
}
ReverseLineIterator
LinesRBeginFrom
(
nsLineBox
*
aList
)
{
return
mLines
.
rbegin
(
aList
)
;
}
nsLineList
&
Lines
(
)
{
return
mLines
;
}
const
nsLineList
&
Lines
(
)
const
{
return
mLines
;
}
friend
nsBlockFrame
*
NS_NewBlockFrame
(
mozilla
:
:
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
NS_DECL_QUERYFRAME
void
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
override
;
void
SetInitialChildList
(
ChildListID
aListID
nsFrameList
&
aChildList
)
override
;
void
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
override
;
void
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
const
nsLineList
:
:
iterator
*
aPrevFrameLine
nsFrameList
&
aFrameList
)
override
;
void
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
override
;
nsContainerFrame
*
GetContentInsertionFrame
(
)
override
;
void
AppendDirectlyOwnedAnonBoxes
(
nsTArray
<
OwnedAnonBox
>
&
aResult
)
override
;
const
nsFrameList
&
GetChildList
(
ChildListID
aListID
)
const
override
;
void
GetChildLists
(
nsTArray
<
ChildList
>
*
aLists
)
const
override
;
nscoord
GetLogicalBaseline
(
mozilla
:
:
WritingMode
aWritingMode
)
const
override
;
bool
GetVerticalAlignBaseline
(
mozilla
:
:
WritingMode
aWM
nscoord
*
aBaseline
)
const
override
{
NS_ASSERTION
(
!
aWM
.
IsOrthogonalTo
(
GetWritingMode
(
)
)
"
You
should
only
call
this
on
frames
with
a
WM
that
'
s
"
"
parallel
to
aWM
"
)
;
nscoord
lastBaseline
;
if
(
GetNaturalBaselineBOffset
(
aWM
BaselineSharingGroup
:
:
Last
&
lastBaseline
)
)
{
*
aBaseline
=
BSize
(
)
-
lastBaseline
;
return
true
;
}
return
false
;
}
bool
GetNaturalBaselineBOffset
(
mozilla
:
:
WritingMode
aWM
BaselineSharingGroup
aBaselineGroup
nscoord
*
aBaseline
)
const
override
;
nscoord
GetCaretBaseline
(
)
const
override
;
void
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
override
;
bool
IsFloatContainingBlock
(
)
const
override
;
void
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
override
;
bool
IsFrameOfType
(
uint32_t
aFlags
)
const
override
{
return
nsContainerFrame
:
:
IsFrameOfType
(
aFlags
&
~
(
nsIFrame
:
:
eCanContainOverflowContainers
)
)
;
}
void
InvalidateFrame
(
uint32_t
aDisplayItemKey
=
0
bool
aRebuildDisplayItems
=
true
)
override
;
void
InvalidateFrameWithRect
(
const
nsRect
&
aRect
uint32_t
aDisplayItemKey
=
0
bool
aRebuildDisplayItems
=
true
)
override
;
#
ifdef
DEBUG_FRAME_DUMP
void
List
(
FILE
*
out
=
stderr
const
char
*
aPrefix
=
"
"
ListFlags
aFlags
=
ListFlags
(
)
)
const
override
;
nsresult
GetFrameName
(
nsAString
&
aResult
)
const
override
;
#
endif
#
ifdef
DEBUG
const
char
*
LineReflowStatusToString
(
LineReflowStatus
aLineReflowStatus
)
const
;
#
endif
#
ifdef
ACCESSIBILITY
mozilla
:
:
a11y
:
:
AccType
AccessibleType
(
)
override
;
#
endif
void
ClearLineCursor
(
)
;
nsLineBox
*
GetFirstLineContaining
(
nscoord
y
)
;
void
SetupLineCursor
(
)
;
class
MOZ_STACK_CLASS
AutoLineCursorSetup
{
public
:
explicit
AutoLineCursorSetup
(
nsBlockFrame
*
aFrame
)
:
mFrame
(
aFrame
)
mOrigCursor
(
aFrame
-
>
GetLineCursor
(
)
)
{
if
(
!
mOrigCursor
)
{
mFrame
-
>
SetupLineCursor
(
)
;
}
}
~
AutoLineCursorSetup
(
)
{
if
(
mOrigCursor
)
{
mFrame
-
>
SetProperty
(
LineCursorProperty
(
)
mOrigCursor
)
;
}
else
{
mFrame
-
>
ClearLineCursor
(
)
;
}
}
private
:
nsBlockFrame
*
mFrame
;
nsLineBox
*
mOrigCursor
;
}
;
void
ChildIsDirty
(
nsIFrame
*
aChild
)
override
;
bool
IsEmpty
(
)
override
;
bool
CachedIsEmpty
(
)
override
;
bool
IsSelfEmpty
(
)
override
;
bool
MarkerIsEmpty
(
)
const
;
bool
HasMarker
(
)
const
{
return
HasOutsideMarker
(
)
|
|
HasInsideMarker
(
)
;
}
bool
HasInsideMarker
(
)
const
{
return
0
!
=
(
mState
&
NS_BLOCK_FRAME_HAS_INSIDE_MARKER
)
;
}
bool
HasOutsideMarker
(
)
const
{
return
0
!
=
(
mState
&
NS_BLOCK_FRAME_HAS_OUTSIDE_MARKER
)
;
}
nsIFrame
*
GetMarker
(
)
const
{
nsIFrame
*
outside
=
GetOutsideMarker
(
)
;
return
outside
?
outside
:
GetInsideMarker
(
)
;
}
nsIFrame
*
GetFirstLetter
(
)
const
;
nsIFrame
*
GetFirstLineFrame
(
)
const
;
void
MarkIntrinsicISizesDirty
(
)
override
;
private
:
void
CheckIntrinsicCacheAgainstShrinkWrapState
(
)
;
public
:
nscoord
GetMinISize
(
gfxContext
*
aRenderingContext
)
override
;
nscoord
GetPrefISize
(
gfxContext
*
aRenderingContext
)
override
;
nsRect
ComputeTightBounds
(
DrawTarget
*
aDrawTarget
)
const
override
;
nsresult
GetPrefWidthTightBounds
(
gfxContext
*
aContext
nscoord
*
aX
nscoord
*
aXMost
)
override
;
nscoord
ComputeFinalBSize
(
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
nscoord
aBEndEdgeOfChildren
const
mozilla
:
:
LogicalMargin
&
aBorderPadding
nscoord
aConsumed
)
;
void
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
override
;
bool
DrainSelfOverflowList
(
)
override
;
void
StealFrame
(
nsIFrame
*
aChild
)
override
;
void
DeleteNextInFlowChild
(
nsIFrame
*
aNextInFlow
bool
aDeletingEmptyFrames
)
override
;
virtual
const
nsStyleText
*
StyleTextForLineLayout
(
)
;
bool
CheckForCollapsedBEndMarginFromClearanceLine
(
)
;
static
nsresult
GetCurrentLine
(
BlockReflowInput
*
aState
nsLineBox
*
*
aOutCurrentLine
)
;
void
IsMarginRoot
(
bool
*
aBStartMarginRoot
bool
*
aBEndMarginRoot
)
;
static
bool
BlockNeedsFloatManager
(
nsIFrame
*
aBlock
)
;
static
bool
BlockCanIntersectFloats
(
nsIFrame
*
aFrame
)
;
struct
ReplacedElementISizeToClear
{
nscoord
marginIStart
borderBoxISize
;
}
;
static
ReplacedElementISizeToClear
ISizeToClearPastFloats
(
const
BlockReflowInput
&
aState
const
mozilla
:
:
LogicalRect
&
aFloatAvailableSpace
nsIFrame
*
aFrame
)
;
void
SplitFloat
(
BlockReflowInput
&
aState
nsIFrame
*
aFloat
const
nsReflowStatus
&
aFloatStatus
)
;
static
nsBlockFrame
*
GetNearestAncestorBlock
(
nsIFrame
*
aCandidate
)
;
struct
FrameLines
{
nsLineList
mLines
;
nsFrameList
mFrames
;
}
;
void
UpdatePseudoElementStyles
(
mozilla
:
:
ServoRestyleState
&
aRestyleState
)
;
void
UpdateFirstLetterStyle
(
mozilla
:
:
ServoRestyleState
&
aRestyleState
)
;
protected
:
explicit
nsBlockFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
ClassID
aID
=
kClassID
)
:
nsContainerFrame
(
aStyle
aPresContext
aID
)
{
#
ifdef
DEBUG
InitDebugFlags
(
)
;
#
endif
}
virtual
~
nsBlockFrame
(
)
;
#
ifdef
DEBUG
already_AddRefed
<
ComputedStyle
>
GetFirstLetterStyle
(
nsPresContext
*
aPresContext
)
;
#
endif
NS_DECLARE_FRAME_PROPERTY_WITHOUT_DTOR
(
LineCursorProperty
nsLineBox
)
bool
HasLineCursor
(
)
{
return
HasAnyStateBits
(
NS_BLOCK_HAS_LINE_CURSOR
)
;
}
nsLineBox
*
GetLineCursor
(
)
{
return
HasLineCursor
(
)
?
GetProperty
(
LineCursorProperty
(
)
)
:
nullptr
;
}
nsLineBox
*
NewLineBox
(
nsIFrame
*
aFrame
bool
aIsBlock
)
{
return
NS_NewLineBox
(
PresShell
(
)
aFrame
aIsBlock
)
;
}
nsLineBox
*
NewLineBox
(
nsLineBox
*
aFromLine
nsIFrame
*
aFrame
int32_t
aCount
)
{
return
NS_NewLineBox
(
PresShell
(
)
aFromLine
aFrame
aCount
)
;
}
void
FreeLineBox
(
nsLineBox
*
aLine
)
{
if
(
aLine
=
=
GetLineCursor
(
)
)
{
ClearLineCursor
(
)
;
}
aLine
-
>
Destroy
(
PresShell
(
)
)
;
}
void
RemoveFrameFromLine
(
nsIFrame
*
aChild
nsLineList
:
:
iterator
aLine
nsFrameList
&
aFrameList
nsLineList
&
aLineList
)
;
void
TryAllLines
(
nsLineList
:
:
iterator
*
aIterator
nsLineList
:
:
iterator
*
aStartIterator
nsLineList
:
:
iterator
*
aEndIterator
bool
*
aInOverflowLines
FrameLines
*
*
aOverflowLines
)
;
void
SlideLine
(
BlockReflowInput
&
aState
nsLineBox
*
aLine
nscoord
aDeltaBCoord
)
;
void
UpdateLineContainerSize
(
nsLineBox
*
aLine
const
nsSize
&
aNewContainerSize
)
;
void
MoveChildFramesOfLine
(
nsLineBox
*
aLine
nscoord
aDeltaBCoord
)
;
void
ComputeFinalSize
(
const
ReflowInput
&
aReflowInput
BlockReflowInput
&
aState
ReflowOutput
&
aMetrics
nscoord
*
aBEndEdgeOfChildren
)
;
void
ComputeOverflowAreas
(
const
nsRect
&
aBounds
const
nsStyleDisplay
*
aDisplay
nscoord
aBEndEdgeOfChildren
mozilla
:
:
OverflowAreas
&
aOverflowAreas
)
;
void
AddFrames
(
nsFrameList
&
aFrameList
nsIFrame
*
aPrevSibling
const
nsLineList
:
:
iterator
*
aPrevSiblingLine
)
;
nsContainerFrame
*
GetRubyContentPseudoFrame
(
)
;
nsresult
ResolveBidi
(
)
;
bool
IsVisualFormControl
(
nsPresContext
*
aPresContext
)
;
public
:
void
SetMarkerFrameForListItem
(
nsIFrame
*
aMarkerFrame
)
;
enum
{
REMOVE_FIXED_CONTINUATIONS
=
0x02
FRAMES_ARE_EMPTY
=
0x04
}
;
void
DoRemoveFrame
(
nsIFrame
*
aDeletedFrame
uint32_t
aFlags
)
{
AutoPostDestroyData
data
(
PresContext
(
)
)
;
DoRemoveFrameInternal
(
aDeletedFrame
aFlags
data
.
mData
)
;
}
void
ReparentFloats
(
nsIFrame
*
aFirstFrame
nsBlockFrame
*
aOldParent
bool
aReparentSiblings
)
;
virtual
bool
ComputeCustomOverflow
(
mozilla
:
:
OverflowAreas
&
aOverflowAreas
)
override
;
virtual
void
UnionChildOverflow
(
mozilla
:
:
OverflowAreas
&
aOverflowAreas
)
override
;
static
void
RecoverFloatsFor
(
nsIFrame
*
aFrame
nsFloatManager
&
aFloatManager
mozilla
:
:
WritingMode
aWM
const
nsSize
&
aContainerSize
)
;
bool
HasPushedFloatsFromPrevContinuation
(
)
const
{
if
(
!
mFloats
.
IsEmpty
(
)
)
{
if
(
mFloats
.
FirstChild
(
)
-
>
HasAnyStateBits
(
NS_FRAME_IS_PUSHED_FLOAT
)
)
{
return
true
;
}
}
#
ifdef
DEBUG
for
(
nsFrameList
:
:
Enumerator
e
(
mFloats
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
)
{
nsIFrame
*
f
=
e
.
get
(
)
;
NS_ASSERTION
(
!
f
-
>
HasAnyStateBits
(
NS_FRAME_IS_PUSHED_FLOAT
)
"
pushed
floats
must
be
at
the
beginning
of
the
float
list
"
)
;
}
#
endif
if
(
HasPushedFloats
(
)
)
{
auto
*
pushedFloats
=
GetPushedFloats
(
)
;
return
pushedFloats
&
&
!
pushedFloats
-
>
IsEmpty
(
)
;
}
return
false
;
}
void
AddSizeOfExcludingThisForTree
(
nsWindowSizes
&
)
const
override
;
void
ClearLineClampEllipsis
(
)
;
protected
:
void
DoRemoveFrameInternal
(
nsIFrame
*
aDeletedFrame
uint32_t
aFlags
PostDestroyData
&
data
)
;
bool
DrainOverflowLines
(
)
;
bool
MaybeHasFloats
(
)
const
{
if
(
!
mFloats
.
IsEmpty
(
)
)
{
return
true
;
}
nsFrameList
*
list
=
GetPushedFloats
(
)
;
if
(
list
&
&
!
list
-
>
IsEmpty
(
)
)
{
return
true
;
}
return
HasAnyStateBits
(
NS_BLOCK_HAS_OVERFLOW_OUT_OF_FLOWS
)
;
}
void
DrainSelfPushedFloats
(
)
;
void
DrainPushedFloats
(
)
;
void
RecoverFloats
(
nsFloatManager
&
aFloatManager
mozilla
:
:
WritingMode
aWM
const
nsSize
&
aContainerSize
)
;
void
ReflowPushedFloats
(
BlockReflowInput
&
aState
mozilla
:
:
OverflowAreas
&
aOverflowAreas
)
;
mozilla
:
:
StyleClear
FindTrailingClear
(
)
;
void
RemoveFloat
(
nsIFrame
*
aFloat
)
;
void
RemoveFloatFromFloatCache
(
nsIFrame
*
aFloat
)
;
void
CollectFloats
(
nsIFrame
*
aFrame
nsFrameList
&
aList
bool
aCollectFromSiblings
)
{
if
(
MaybeHasFloats
(
)
)
{
DoCollectFloats
(
aFrame
aList
aCollectFromSiblings
)
;
}
}
void
DoCollectFloats
(
nsIFrame
*
aFrame
nsFrameList
&
aList
bool
aCollectFromSiblings
)
;
static
void
DoRemoveOutOfFlowFrame
(
nsIFrame
*
aFrame
)
;
void
PrepareResizeReflow
(
BlockReflowInput
&
aState
)
;
void
ReflowDirtyLines
(
BlockReflowInput
&
aState
)
;
void
MarkLineDirtyForInterrupt
(
nsLineBox
*
aLine
)
;
void
ReflowLine
(
BlockReflowInput
&
aState
LineIterator
aLine
bool
*
aKeepReflowGoing
)
;
bool
PlaceLine
(
BlockReflowInput
&
aState
nsLineLayout
&
aLineLayout
LineIterator
aLine
nsFloatManager
:
:
SavedState
*
aFloatStateBeforeLine
nsFlowAreaRect
&
aFlowArea
nscoord
&
aAvailableSpaceBSize
bool
*
aKeepReflowGoing
)
;
void
LazyMarkLinesDirty
(
)
;
void
MarkLineDirty
(
LineIterator
aLine
const
nsLineList
*
aLineList
)
;
bool
IsLastLine
(
BlockReflowInput
&
aState
LineIterator
aLine
)
;
void
DeleteLine
(
BlockReflowInput
&
aState
nsLineList
:
:
iterator
aLine
nsLineList
:
:
iterator
aLineEnd
)
;
bool
ShouldApplyBStartMargin
(
BlockReflowInput
&
aState
nsLineBox
*
aLine
)
;
void
ReflowBlockFrame
(
BlockReflowInput
&
aState
LineIterator
aLine
bool
*
aKeepGoing
)
;
void
ReflowInlineFrames
(
BlockReflowInput
&
aState
LineIterator
aLine
bool
*
aKeepLineGoing
)
;
void
DoReflowInlineFrames
(
BlockReflowInput
&
aState
nsLineLayout
&
aLineLayout
LineIterator
aLine
nsFlowAreaRect
&
aFloatAvailableSpace
nscoord
&
aAvailableSpaceBSize
nsFloatManager
:
:
SavedState
*
aFloatStateBeforeLine
bool
*
aKeepReflowGoing
LineReflowStatus
*
aLineReflowStatus
bool
aAllowPullUp
)
;
void
ReflowInlineFrame
(
BlockReflowInput
&
aState
nsLineLayout
&
aLineLayout
LineIterator
aLine
nsIFrame
*
aFrame
LineReflowStatus
*
aLineReflowStatus
)
;
mozilla
:
:
LogicalRect
AdjustFloatAvailableSpace
(
BlockReflowInput
&
aState
const
mozilla
:
:
LogicalRect
&
aFloatAvailableSpace
)
;
nscoord
ComputeFloatISize
(
BlockReflowInput
&
aState
const
mozilla
:
:
LogicalRect
&
aFloatAvailableSpace
nsIFrame
*
aFloat
)
;
void
ReflowFloat
(
BlockReflowInput
&
aState
const
mozilla
:
:
LogicalRect
&
aAdjustedAvailableSpace
nsIFrame
*
aFloat
mozilla
:
:
LogicalMargin
&
aFloatMargin
mozilla
:
:
LogicalMargin
&
aFloatOffsets
bool
aFloatPushedDown
nsReflowStatus
&
aReflowStatus
)
;
bool
CreateContinuationFor
(
BlockReflowInput
&
aState
nsLineBox
*
aLine
nsIFrame
*
aFrame
)
;
void
PushTruncatedLine
(
BlockReflowInput
&
aState
LineIterator
aLine
bool
*
aKeepReflowGoing
)
;
void
SplitLine
(
BlockReflowInput
&
aState
nsLineLayout
&
aLineLayout
LineIterator
aLine
nsIFrame
*
aFrame
LineReflowStatus
*
aLineReflowStatus
)
;
nsIFrame
*
PullFrame
(
BlockReflowInput
&
aState
LineIterator
aLine
)
;
nsIFrame
*
PullFrameFrom
(
nsLineBox
*
aLine
nsBlockFrame
*
aFromContainer
nsLineList
:
:
iterator
aFromLine
)
;
void
PushLines
(
BlockReflowInput
&
aState
nsLineList
:
:
iterator
aLineBefore
)
;
void
PropagateFloatDamage
(
BlockReflowInput
&
aState
nsLineBox
*
aLine
nscoord
aDeltaBCoord
)
;
void
CheckFloats
(
BlockReflowInput
&
aState
)
;
void
ReflowOutsideMarker
(
nsIFrame
*
aMarkerFrame
BlockReflowInput
&
aState
ReflowOutput
&
aMetrics
nscoord
aLineTop
)
;
virtual
nsILineIterator
*
GetLineIterator
(
)
override
;
public
:
bool
HasOverflowLines
(
)
const
{
return
HasAnyStateBits
(
NS_BLOCK_HAS_OVERFLOW_LINES
)
;
}
FrameLines
*
GetOverflowLines
(
)
const
;
protected
:
FrameLines
*
RemoveOverflowLines
(
)
;
void
SetOverflowLines
(
FrameLines
*
aOverflowLines
)
;
void
DestroyOverflowLines
(
)
;
struct
nsAutoOOFFrameList
{
nsFrameList
mList
;
explicit
nsAutoOOFFrameList
(
nsBlockFrame
*
aBlock
)
:
mPropValue
(
aBlock
-
>
GetOverflowOutOfFlows
(
)
)
mBlock
(
aBlock
)
{
if
(
mPropValue
)
{
mList
=
*
mPropValue
;
}
}
~
nsAutoOOFFrameList
(
)
{
mBlock
-
>
SetOverflowOutOfFlows
(
mList
mPropValue
)
;
}
protected
:
nsFrameList
*
const
mPropValue
;
nsBlockFrame
*
const
mBlock
;
}
;
friend
struct
nsAutoOOFFrameList
;
nsFrameList
*
GetOverflowOutOfFlows
(
)
const
;
void
SetOverflowOutOfFlows
(
const
nsFrameList
&
aList
nsFrameList
*
aPropValue
)
;
nsIFrame
*
GetInsideMarker
(
)
const
;
nsIFrame
*
GetOutsideMarker
(
)
const
;
nsFrameList
*
GetOutsideMarkerList
(
)
const
;
bool
HasPushedFloats
(
)
const
{
return
HasAnyStateBits
(
NS_BLOCK_HAS_PUSHED_FLOATS
)
;
}
nsFrameList
*
GetPushedFloats
(
)
const
;
nsFrameList
*
EnsurePushedFloats
(
)
;
nsFrameList
*
RemovePushedFloats
(
)
;
#
ifdef
DEBUG
void
VerifyLines
(
bool
aFinalCheckOK
)
;
void
VerifyOverflowSituation
(
)
;
int32_t
GetDepth
(
)
const
;
#
endif
nscoord
mCachedMinISize
=
NS_INTRINSIC_ISIZE_UNKNOWN
;
nscoord
mCachedPrefISize
=
NS_INTRINSIC_ISIZE_UNKNOWN
;
nsLineList
mLines
;
nsFrameList
mFloats
;
friend
class
mozilla
:
:
BlockReflowInput
;
friend
class
nsBlockInFlowLineIterator
;
#
ifdef
DEBUG
public
:
static
bool
gLamePaintMetrics
;
static
bool
gLameReflowMetrics
;
static
bool
gNoisy
;
static
bool
gNoisyDamageRepair
;
static
bool
gNoisyIntrinsic
;
static
bool
gNoisyReflow
;
static
bool
gReallyNoisyReflow
;
static
bool
gNoisyFloatManager
;
static
bool
gVerifyLines
;
static
bool
gDisableResizeOpt
;
static
int32_t
gNoiseIndent
;
static
const
char
*
kReflowCommandType
[
]
;
protected
:
static
void
InitDebugFlags
(
)
;
#
endif
}
;
#
ifdef
DEBUG
class
AutoNoisyIndenter
{
public
:
explicit
AutoNoisyIndenter
(
bool
aDoIndent
)
:
mIndented
(
aDoIndent
)
{
if
(
mIndented
)
{
nsBlockFrame
:
:
gNoiseIndent
+
+
;
}
}
~
AutoNoisyIndenter
(
)
{
if
(
mIndented
)
{
nsBlockFrame
:
:
gNoiseIndent
-
-
;
}
}
private
:
bool
mIndented
;
}
;
#
endif
class
nsBlockInFlowLineIterator
{
public
:
typedef
nsBlockFrame
:
:
LineIterator
LineIterator
;
nsBlockInFlowLineIterator
(
nsBlockFrame
*
aFrame
LineIterator
aLine
)
;
nsBlockInFlowLineIterator
(
nsBlockFrame
*
aFrame
bool
*
aFoundValidLine
)
;
nsBlockInFlowLineIterator
(
nsBlockFrame
*
aFrame
nsIFrame
*
aFindFrame
bool
*
aFoundValidLine
)
;
nsBlockInFlowLineIterator
(
)
:
mFrame
(
nullptr
)
{
}
LineIterator
GetLine
(
)
{
return
mLine
;
}
bool
IsLastLineInList
(
)
;
nsBlockFrame
*
GetContainer
(
)
{
return
mFrame
;
}
bool
GetInOverflow
(
)
{
return
mLineList
!
=
&
mFrame
-
>
mLines
;
}
nsLineList
*
GetLineList
(
)
{
return
mLineList
;
}
LineIterator
End
(
)
;
bool
Next
(
)
;
bool
Prev
(
)
;
nsBlockInFlowLineIterator
(
nsBlockFrame
*
aFrame
LineIterator
aLine
bool
aInOverflow
)
;
private
:
nsBlockFrame
*
mFrame
;
LineIterator
mLine
;
nsLineList
*
mLineList
;
bool
FindValidLine
(
)
;
}
;
#
endif
