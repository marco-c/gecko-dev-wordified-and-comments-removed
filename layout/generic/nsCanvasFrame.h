#
ifndef
nsCanvasFrame_h___
#
define
nsCanvasFrame_h___
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsIScrollPositionListener
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsIAnonymousContentCreator
.
h
"
class
nsPresContext
;
class
nsRenderingContext
;
class
nsCanvasFrame
final
:
public
nsContainerFrame
public
nsIScrollPositionListener
public
nsIAnonymousContentCreator
{
public
:
explicit
nsCanvasFrame
(
nsStyleContext
*
aContext
)
:
nsContainerFrame
(
aContext
)
mDoPaintFocus
(
false
)
mAddedScrollPositionListener
(
false
)
{
}
NS_DECL_QUERYFRAME_TARGET
(
nsCanvasFrame
)
NS_DECL_QUERYFRAME
NS_DECL_FRAMEARENA_HELPERS
virtual
void
DestroyFrom
(
nsIFrame
*
aDestructRoot
)
override
;
virtual
mozilla
:
:
WritingMode
GetWritingMode
(
)
const
override
{
nsIContent
*
rootElem
=
GetContent
(
)
;
if
(
rootElem
)
{
nsIFrame
*
rootElemFrame
=
rootElem
-
>
GetPrimaryFrame
(
)
;
if
(
rootElemFrame
)
{
return
rootElemFrame
-
>
GetWritingMode
(
)
;
}
}
return
nsIFrame
:
:
GetWritingMode
(
)
;
}
#
ifdef
DEBUG
virtual
void
SetInitialChildList
(
ChildListID
aListID
nsFrameList
&
aChildList
)
override
;
virtual
void
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
override
;
virtual
void
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
aFrameList
)
override
;
virtual
void
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
override
;
#
endif
virtual
nscoord
GetMinISize
(
nsRenderingContext
*
aRenderingContext
)
override
;
virtual
nscoord
GetPrefISize
(
nsRenderingContext
*
aRenderingContext
)
override
;
virtual
void
Reflow
(
nsPresContext
*
aPresContext
nsHTMLReflowMetrics
&
aDesiredSize
const
nsHTMLReflowState
&
aReflowState
nsReflowStatus
&
aStatus
)
override
;
virtual
bool
IsFrameOfType
(
uint32_t
aFlags
)
const
override
{
return
nsContainerFrame
:
:
IsFrameOfType
(
aFlags
&
~
(
nsIFrame
:
:
eCanContainOverflowContainers
)
)
;
}
virtual
nsresult
CreateAnonymousContent
(
nsTArray
<
ContentInfo
>
&
aElements
)
override
;
virtual
void
AppendAnonymousContentTo
(
nsTArray
<
nsIContent
*
>
&
aElements
uint32_t
aFilter
)
override
;
mozilla
:
:
dom
:
:
Element
*
GetCustomContentContainer
(
)
const
{
return
mCustomContentContainer
;
}
void
ShowCustomContentContainer
(
)
;
void
HideCustomContentContainer
(
)
;
NS_IMETHOD
SetHasFocus
(
bool
aHasFocus
)
;
virtual
void
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aDirtyRect
const
nsDisplayListSet
&
aLists
)
override
;
void
PaintFocus
(
mozilla
:
:
gfx
:
:
DrawTarget
*
aRenderingContext
nsPoint
aPt
)
;
virtual
void
ScrollPositionWillChange
(
nscoord
aX
nscoord
aY
)
override
;
virtual
void
ScrollPositionDidChange
(
nscoord
aX
nscoord
aY
)
override
{
}
virtual
nsIAtom
*
GetType
(
)
const
override
;
virtual
nsresult
StealFrame
(
nsIFrame
*
aChild
bool
aForceNormal
)
override
{
NS_ASSERTION
(
!
aForceNormal
"
No
-
one
should
be
passing
this
in
here
"
)
;
nsresult
rv
=
nsContainerFrame
:
:
StealFrame
(
aChild
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
rv
=
nsContainerFrame
:
:
StealFrame
(
aChild
)
;
}
return
rv
;
}
#
ifdef
DEBUG_FRAME_DUMP
virtual
nsresult
GetFrameName
(
nsAString
&
aResult
)
const
override
;
#
endif
virtual
nsresult
GetContentForEvent
(
mozilla
:
:
WidgetEvent
*
aEvent
nsIContent
*
*
aContent
)
override
;
nsRect
CanvasArea
(
)
const
;
protected
:
bool
mDoPaintFocus
;
bool
mAddedScrollPositionListener
;
nsCOMPtr
<
mozilla
:
:
dom
:
:
Element
>
mCustomContentContainer
;
}
;
class
nsDisplayCanvasBackgroundColor
:
public
nsDisplaySolidColorBase
{
public
:
nsDisplayCanvasBackgroundColor
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
:
nsDisplaySolidColorBase
(
aBuilder
aFrame
NS_RGBA
(
0
0
0
0
)
)
{
}
virtual
bool
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
override
{
return
NS_GET_A
(
mColor
)
>
0
;
}
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
override
{
nsCanvasFrame
*
frame
=
static_cast
<
nsCanvasFrame
*
>
(
mFrame
)
;
*
aSnap
=
true
;
return
frame
-
>
CanvasArea
(
)
+
ToReferenceFrame
(
)
;
}
virtual
void
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
override
{
aOutFrames
-
>
AppendElement
(
mFrame
)
;
}
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
nsRenderingContext
*
aCtx
)
override
;
void
SetExtraBackgroundColor
(
nscolor
aColor
)
{
mColor
=
aColor
;
}
NS_DISPLAY_DECL_NAME
(
"
CanvasBackgroundColor
"
TYPE_CANVAS_BACKGROUND_COLOR
)
#
ifdef
MOZ_DUMP_PAINTING
virtual
void
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
override
;
#
endif
}
;
class
nsDisplayCanvasBackgroundImage
:
public
nsDisplayBackgroundImage
{
public
:
nsDisplayCanvasBackgroundImage
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
uint32_t
aLayer
const
nsStyleBackground
*
aBg
)
:
nsDisplayBackgroundImage
(
aBuilder
aFrame
aLayer
aBg
)
{
if
(
ShouldFixToViewport
(
aBuilder
)
)
{
mAnimatedGeometryRoot
=
aBuilder
-
>
FindAnimatedGeometryRootFor
(
this
)
;
}
}
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
nsRenderingContext
*
aCtx
)
override
;
virtual
void
NotifyRenderingChanged
(
)
override
{
mFrame
-
>
Properties
(
)
.
Delete
(
nsIFrame
:
:
CachedBackgroundImage
(
)
)
;
mFrame
-
>
Properties
(
)
.
Delete
(
nsIFrame
:
:
CachedBackgroundImageDT
(
)
)
;
}
virtual
bool
ShouldFixToViewport
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
mBackgroundStyle
-
>
mLayers
.
mLayers
[
mLayer
]
.
mAttachment
=
=
NS_STYLE_IMAGELAYER_ATTACHMENT_FIXED
&
&
!
mBackgroundStyle
-
>
mLayers
.
mLayers
[
mLayer
]
.
mImage
.
IsEmpty
(
)
;
}
virtual
bool
SupportsOptimizingToImage
(
)
override
{
return
false
;
}
NS_DISPLAY_DECL_NAME
(
"
CanvasBackgroundImage
"
TYPE_CANVAS_BACKGROUND_IMAGE
)
}
;
class
nsDisplayCanvasThemedBackground
:
public
nsDisplayThemedBackground
{
public
:
nsDisplayCanvasThemedBackground
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
:
nsDisplayThemedBackground
(
aBuilder
aFrame
)
{
}
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
nsRenderingContext
*
aCtx
)
override
;
NS_DISPLAY_DECL_NAME
(
"
CanvasThemedBackground
"
TYPE_CANVAS_THEMED_BACKGROUND
)
}
;
#
endif
