#
include
"
mozilla
/
ReflowInput
.
h
"
#
include
"
LayoutLogging
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsCSSAnonBoxes
.
h
"
#
include
"
nsFrame
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsFontMetrics
.
h
"
#
include
"
nsBlockFrame
.
h
"
#
include
"
nsLineBox
.
h
"
#
include
"
nsImageFrame
.
h
"
#
include
"
nsTableFrame
.
h
"
#
include
"
nsTableCellFrame
.
h
"
#
include
"
nsIPercentBSizeObserver
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
nsFontInflationData
.
h
"
#
include
"
StickyScrollContainer
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
CounterStyleManager
.
h
"
#
include
<
algorithm
>
#
include
"
mozilla
/
dom
/
HTMLInputElement
.
h
"
#
include
"
nsGridContainerFrame
.
h
"
#
ifdef
DEBUG
#
undef
NOISY_VERTICAL_ALIGN
#
else
#
undef
NOISY_VERTICAL_ALIGN
#
endif
using
namespace
mozilla
;
using
namespace
mozilla
:
:
css
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
layout
;
enum
eNormalLineHeightControl
{
eUninitialized
=
-
1
eNoExternalLeading
=
0
eIncludeExternalLeading
eCompensateLeading
}
;
static
eNormalLineHeightControl
sNormalLineHeightControl
=
eUninitialized
;
ReflowInput
:
:
ReflowInput
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
gfxContext
*
aRenderingContext
const
LogicalSize
&
aAvailableSpace
uint32_t
aFlags
)
:
SizeComputationInput
(
aFrame
aRenderingContext
)
mCBReflowInput
(
nullptr
)
mBlockDelta
(
0
)
mOrthogonalLimit
(
NS_UNCONSTRAINEDSIZE
)
mAvailableWidth
(
0
)
mAvailableHeight
(
0
)
mContainingBlockSize
(
mWritingMode
)
mReflowDepth
(
0
)
{
MOZ_ASSERT
(
aRenderingContext
"
no
rendering
context
"
)
;
MOZ_ASSERT
(
aPresContext
"
no
pres
context
"
)
;
MOZ_ASSERT
(
aFrame
"
no
frame
"
)
;
MOZ_ASSERT
(
aPresContext
=
=
aFrame
-
>
PresContext
(
)
"
wrong
pres
context
"
)
;
mParentReflowInput
=
nullptr
;
AvailableISize
(
)
=
aAvailableSpace
.
ISize
(
mWritingMode
)
;
AvailableBSize
(
)
=
aAvailableSpace
.
BSize
(
mWritingMode
)
;
mFloatManager
=
nullptr
;
mLineLayout
=
nullptr
;
mDiscoveredClearance
=
nullptr
;
mPercentBSizeObserver
=
nullptr
;
if
(
aFlags
&
DUMMY_PARENT_REFLOW_STATE
)
{
mFlags
.
mDummyParentReflowInput
=
true
;
}
if
(
aFlags
&
COMPUTE_SIZE_SHRINK_WRAP
)
{
mFlags
.
mShrinkWrap
=
true
;
}
if
(
aFlags
&
COMPUTE_SIZE_USE_AUTO_BSIZE
)
{
mFlags
.
mUseAutoBSize
=
true
;
}
if
(
aFlags
&
STATIC_POS_IS_CB_ORIGIN
)
{
mFlags
.
mStaticPosIsCBOrigin
=
true
;
}
if
(
aFlags
&
I_CLAMP_MARGIN_BOX_MIN_SIZE
)
{
mFlags
.
mIClampMarginBoxMinSize
=
true
;
}
if
(
aFlags
&
B_CLAMP_MARGIN_BOX_MIN_SIZE
)
{
mFlags
.
mBClampMarginBoxMinSize
=
true
;
}
if
(
aFlags
&
I_APPLY_AUTO_MIN_SIZE
)
{
mFlags
.
mApplyAutoMinSize
=
true
;
}
if
(
!
(
aFlags
&
CALLER_WILL_INIT
)
)
{
Init
(
aPresContext
)
;
}
}
static
bool
CheckNextInFlowParenthood
(
nsIFrame
*
aFrame
nsIFrame
*
aParent
)
{
nsIFrame
*
frameNext
=
aFrame
-
>
GetNextInFlow
(
)
;
nsIFrame
*
parentNext
=
aParent
-
>
GetNextInFlow
(
)
;
return
frameNext
&
&
parentNext
&
&
frameNext
-
>
GetParent
(
)
=
=
parentNext
;
}
static
nscoord
FontSizeInflationListMarginAdjustment
(
const
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eBlockFrame
)
)
{
return
0
;
}
const
nsBlockFrame
*
blockFrame
=
static_cast
<
const
nsBlockFrame
*
>
(
aFrame
)
;
if
(
!
blockFrame
-
>
HasBullet
(
)
)
{
return
0
;
}
float
inflation
=
nsLayoutUtils
:
:
FontSizeInflationFor
(
aFrame
)
;
if
(
inflation
>
1
.
0f
)
{
auto
listStyleType
=
aFrame
-
>
StyleList
(
)
-
>
mCounterStyle
-
>
GetStyle
(
)
;
if
(
listStyleType
!
=
NS_STYLE_LIST_STYLE_NONE
&
&
listStyleType
!
=
NS_STYLE_LIST_STYLE_DISC
&
&
listStyleType
!
=
NS_STYLE_LIST_STYLE_CIRCLE
&
&
listStyleType
!
=
NS_STYLE_LIST_STYLE_SQUARE
&
&
listStyleType
!
=
NS_STYLE_LIST_STYLE_DISCLOSURE_CLOSED
&
&
listStyleType
!
=
NS_STYLE_LIST_STYLE_DISCLOSURE_OPEN
)
{
return
nsPresContext
:
:
CSSPixelsToAppUnits
(
40
)
*
(
inflation
-
1
)
;
}
}
return
0
;
}
SizeComputationInput
:
:
SizeComputationInput
(
nsIFrame
*
aFrame
gfxContext
*
aRenderingContext
WritingMode
aContainingBlockWritingMode
nscoord
aContainingBlockISize
)
:
mFrame
(
aFrame
)
mRenderingContext
(
aRenderingContext
)
mWritingMode
(
aFrame
-
>
GetWritingMode
(
)
)
{
ReflowInputFlags
flags
;
InitOffsets
(
aContainingBlockWritingMode
aContainingBlockISize
mFrame
-
>
Type
(
)
flags
)
;
}
ReflowInput
:
:
ReflowInput
(
nsPresContext
*
aPresContext
const
ReflowInput
&
aParentReflowInput
nsIFrame
*
aFrame
const
LogicalSize
&
aAvailableSpace
const
LogicalSize
*
aContainingBlockSize
uint32_t
aFlags
)
:
SizeComputationInput
(
aFrame
aParentReflowInput
.
mRenderingContext
)
mCBReflowInput
(
nullptr
)
mBlockDelta
(
0
)
mOrthogonalLimit
(
NS_UNCONSTRAINEDSIZE
)
mAvailableWidth
(
0
)
mAvailableHeight
(
0
)
mContainingBlockSize
(
mWritingMode
)
mFlags
(
aParentReflowInput
.
mFlags
)
mReflowDepth
(
aParentReflowInput
.
mReflowDepth
+
1
)
{
MOZ_ASSERT
(
aPresContext
"
no
pres
context
"
)
;
MOZ_ASSERT
(
aFrame
"
no
frame
"
)
;
MOZ_ASSERT
(
aPresContext
=
=
aFrame
-
>
PresContext
(
)
"
wrong
pres
context
"
)
;
MOZ_ASSERT
(
!
mFlags
.
mSpecialBSizeReflow
|
|
!
NS_SUBTREE_DIRTY
(
aFrame
)
"
frame
should
be
clean
when
getting
special
bsize
reflow
"
)
;
mParentReflowInput
=
&
aParentReflowInput
;
AvailableISize
(
)
=
aAvailableSpace
.
ISize
(
mWritingMode
)
;
AvailableBSize
(
)
=
aAvailableSpace
.
BSize
(
mWritingMode
)
;
if
(
mWritingMode
.
IsOrthogonalTo
(
aParentReflowInput
.
GetWritingMode
(
)
)
)
{
if
(
AvailableISize
(
)
=
=
NS_UNCONSTRAINEDSIZE
&
&
aParentReflowInput
.
ComputedBSize
(
)
!
=
NS_UNCONSTRAINEDSIZE
)
{
AvailableISize
(
)
=
aParentReflowInput
.
ComputedBSize
(
)
;
}
}
mFloatManager
=
aParentReflowInput
.
mFloatManager
;
if
(
mFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eLineParticipant
)
)
mLineLayout
=
aParentReflowInput
.
mLineLayout
;
else
mLineLayout
=
nullptr
;
mFlags
.
mNextInFlowUntouched
=
aParentReflowInput
.
mFlags
.
mNextInFlowUntouched
&
&
CheckNextInFlowParenthood
(
aFrame
aParentReflowInput
.
mFrame
)
;
mFlags
.
mAssumingHScrollbar
=
mFlags
.
mAssumingVScrollbar
=
false
;
mFlags
.
mIsColumnBalancing
=
false
;
mFlags
.
mIsFlexContainerMeasuringBSize
=
false
;
mFlags
.
mDummyParentReflowInput
=
false
;
mFlags
.
mShrinkWrap
=
!
!
(
aFlags
&
COMPUTE_SIZE_SHRINK_WRAP
)
;
mFlags
.
mUseAutoBSize
=
!
!
(
aFlags
&
COMPUTE_SIZE_USE_AUTO_BSIZE
)
;
mFlags
.
mStaticPosIsCBOrigin
=
!
!
(
aFlags
&
STATIC_POS_IS_CB_ORIGIN
)
;
mFlags
.
mIOffsetsNeedCSSAlign
=
mFlags
.
mBOffsetsNeedCSSAlign
=
false
;
mFlags
.
mIClampMarginBoxMinSize
=
!
!
(
aFlags
&
I_CLAMP_MARGIN_BOX_MIN_SIZE
)
;
mFlags
.
mBClampMarginBoxMinSize
=
!
!
(
aFlags
&
B_CLAMP_MARGIN_BOX_MIN_SIZE
)
;
mFlags
.
mApplyAutoMinSize
=
!
!
(
aFlags
&
I_APPLY_AUTO_MIN_SIZE
)
;
mDiscoveredClearance
=
nullptr
;
mPercentBSizeObserver
=
(
aParentReflowInput
.
mPercentBSizeObserver
&
&
aParentReflowInput
.
mPercentBSizeObserver
-
>
NeedsToObserve
(
*
this
)
)
?
aParentReflowInput
.
mPercentBSizeObserver
:
nullptr
;
if
(
(
aFlags
&
DUMMY_PARENT_REFLOW_STATE
)
|
|
(
mParentReflowInput
-
>
mFlags
.
mDummyParentReflowInput
&
&
mFrame
-
>
IsTableFrame
(
)
)
)
{
mFlags
.
mDummyParentReflowInput
=
true
;
}
if
(
!
(
aFlags
&
CALLER_WILL_INIT
)
)
{
Init
(
aPresContext
aContainingBlockSize
)
;
}
}
inline
nscoord
SizeComputationInput
:
:
ComputeISizeValue
(
nscoord
aContainingBlockISize
nscoord
aContentEdgeToBoxSizing
nscoord
aBoxSizingToMarginEdge
const
nsStyleCoord
&
aCoord
)
const
{
return
mFrame
-
>
ComputeISizeValue
(
mRenderingContext
aContainingBlockISize
aContentEdgeToBoxSizing
aBoxSizingToMarginEdge
aCoord
)
;
}
nscoord
SizeComputationInput
:
:
ComputeISizeValue
(
nscoord
aContainingBlockISize
StyleBoxSizing
aBoxSizing
const
nsStyleCoord
&
aCoord
)
const
{
WritingMode
wm
=
GetWritingMode
(
)
;
nscoord
inside
=
0
outside
=
ComputedLogicalBorderPadding
(
)
.
IStartEnd
(
wm
)
+
ComputedLogicalMargin
(
)
.
IStartEnd
(
wm
)
;
if
(
aBoxSizing
=
=
StyleBoxSizing
:
:
Border
)
{
inside
=
ComputedLogicalBorderPadding
(
)
.
IStartEnd
(
wm
)
;
}
outside
-
=
inside
;
return
ComputeISizeValue
(
aContainingBlockISize
inside
outside
aCoord
)
;
}
nscoord
SizeComputationInput
:
:
ComputeBSizeValue
(
nscoord
aContainingBlockBSize
StyleBoxSizing
aBoxSizing
const
nsStyleCoord
&
aCoord
)
const
{
WritingMode
wm
=
GetWritingMode
(
)
;
nscoord
inside
=
0
;
if
(
aBoxSizing
=
=
StyleBoxSizing
:
:
Border
)
{
inside
=
ComputedLogicalBorderPadding
(
)
.
BStartEnd
(
wm
)
;
}
return
nsLayoutUtils
:
:
ComputeBSizeValue
(
aContainingBlockBSize
inside
aCoord
)
;
}
void
ReflowInput
:
:
SetComputedWidth
(
nscoord
aComputedWidth
)
{
NS_ASSERTION
(
mFrame
"
Must
have
a
frame
!
"
)
;
MOZ_ASSERT
(
aComputedWidth
>
=
0
"
Invalid
computed
width
"
)
;
if
(
ComputedWidth
(
)
!
=
aComputedWidth
)
{
ComputedWidth
(
)
=
aComputedWidth
;
LayoutFrameType
frameType
=
mFrame
-
>
Type
(
)
;
if
(
frameType
!
=
LayoutFrameType
:
:
Viewport
|
|
mWritingMode
.
IsVertical
(
)
)
{
InitResizeFlags
(
mFrame
-
>
PresContext
(
)
frameType
)
;
}
}
}
void
ReflowInput
:
:
SetComputedHeight
(
nscoord
aComputedHeight
)
{
NS_ASSERTION
(
mFrame
"
Must
have
a
frame
!
"
)
;
MOZ_ASSERT
(
aComputedHeight
>
=
0
"
Invalid
computed
height
"
)
;
if
(
ComputedHeight
(
)
!
=
aComputedHeight
)
{
ComputedHeight
(
)
=
aComputedHeight
;
LayoutFrameType
frameType
=
mFrame
-
>
Type
(
)
;
if
(
frameType
!
=
LayoutFrameType
:
:
Viewport
|
|
!
mWritingMode
.
IsVertical
(
)
)
{
InitResizeFlags
(
mFrame
-
>
PresContext
(
)
frameType
)
;
}
}
}
void
ReflowInput
:
:
MarkFrameChildrenDirty
(
nsIFrame
*
aFrame
)
{
if
(
aFrame
-
>
IsXULBoxFrame
(
)
)
{
return
;
}
for
(
nsIFrame
:
:
ChildListIterator
childLists
(
aFrame
)
;
!
childLists
.
IsDone
(
)
;
childLists
.
Next
(
)
)
{
for
(
nsIFrame
*
childFrame
:
childLists
.
CurrentList
(
)
)
{
if
(
!
childFrame
-
>
IsTableColGroupFrame
(
)
)
{
childFrame
-
>
AddStateBits
(
NS_FRAME_IS_DIRTY
)
;
}
}
}
}
void
ReflowInput
:
:
Init
(
nsPresContext
*
aPresContext
const
LogicalSize
*
aContainingBlockSize
const
nsMargin
*
aBorder
const
nsMargin
*
aPadding
)
{
if
(
(
mFrame
-
>
GetStateBits
(
)
&
NS_FRAME_IS_DIRTY
)
)
{
MarkFrameChildrenDirty
(
mFrame
)
;
}
if
(
AvailableISize
(
)
=
=
NS_UNCONSTRAINEDSIZE
)
{
for
(
const
ReflowInput
*
parent
=
mParentReflowInput
;
parent
!
=
nullptr
;
parent
=
parent
-
>
mParentReflowInput
)
{
if
(
parent
-
>
GetWritingMode
(
)
.
IsOrthogonalTo
(
mWritingMode
)
&
&
parent
-
>
mOrthogonalLimit
!
=
NS_UNCONSTRAINEDSIZE
)
{
AvailableISize
(
)
=
parent
-
>
mOrthogonalLimit
;
break
;
}
}
}
LAYOUT_WARN_IF_FALSE
(
AvailableISize
(
)
!
=
NS_UNCONSTRAINEDSIZE
"
have
unconstrained
inline
-
size
;
this
should
only
"
"
result
from
very
large
sizes
not
attempts
at
"
"
intrinsic
inline
-
size
calculation
"
)
;
mStylePosition
=
mFrame
-
>
StylePosition
(
)
;
mStyleDisplay
=
mFrame
-
>
StyleDisplay
(
)
;
mStyleVisibility
=
mFrame
-
>
StyleVisibility
(
)
;
mStyleBorder
=
mFrame
-
>
StyleBorder
(
)
;
mStyleMargin
=
mFrame
-
>
StyleMargin
(
)
;
mStylePadding
=
mFrame
-
>
StylePadding
(
)
;
mStyleText
=
mFrame
-
>
StyleText
(
)
;
InitCBReflowInput
(
)
;
LayoutFrameType
type
=
mFrame
-
>
Type
(
)
;
if
(
type
=
=
mozilla
:
:
LayoutFrameType
:
:
Placeholder
)
{
ComputedBSize
(
)
=
ComputedISize
(
)
=
0
;
return
;
}
InitFrameType
(
type
)
;
LogicalSize
cbSize
(
mWritingMode
-
1
-
1
)
;
if
(
aContainingBlockSize
)
{
cbSize
=
*
aContainingBlockSize
;
}
InitConstraints
(
aPresContext
cbSize
aBorder
aPadding
type
)
;
InitResizeFlags
(
aPresContext
type
)
;
InitDynamicReflowRoot
(
)
;
nsIFrame
*
parent
=
mFrame
-
>
GetParent
(
)
;
if
(
parent
&
&
(
parent
-
>
GetStateBits
(
)
&
NS_FRAME_IN_CONSTRAINED_BSIZE
)
&
&
!
(
parent
-
>
IsScrollFrame
(
)
&
&
parent
-
>
StyleDisplay
(
)
-
>
mOverflowY
!
=
StyleOverflow
:
:
Hidden
)
)
{
mFrame
-
>
AddStateBits
(
NS_FRAME_IN_CONSTRAINED_BSIZE
)
;
}
else
if
(
type
=
=
LayoutFrameType
:
:
SVGForeignObject
)
{
mFrame
-
>
AddStateBits
(
NS_FRAME_IN_CONSTRAINED_BSIZE
)
;
}
else
{
const
nsStyleCoord
&
bSizeCoord
=
mStylePosition
-
>
BSize
(
mWritingMode
)
;
const
nsStyleCoord
&
maxBSizeCoord
=
mStylePosition
-
>
MaxBSize
(
mWritingMode
)
;
if
(
(
!
bSizeCoord
.
IsAutoOrEnum
(
)
|
|
!
maxBSizeCoord
.
IsAutoOrEnum
(
)
)
&
&
(
mFrame
-
>
GetContent
(
)
&
&
!
(
mFrame
-
>
GetContent
(
)
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
body
nsGkAtoms
:
:
html
)
)
)
)
{
nsIFrame
*
containingBlk
=
mFrame
;
while
(
containingBlk
)
{
const
nsStylePosition
*
stylePos
=
containingBlk
-
>
StylePosition
(
)
;
const
nsStyleCoord
&
bSizeCoord
=
stylePos
-
>
BSize
(
mWritingMode
)
;
const
nsStyleCoord
&
maxBSizeCoord
=
stylePos
-
>
MaxBSize
(
mWritingMode
)
;
if
(
(
bSizeCoord
.
IsCoordPercentCalcUnit
(
)
&
&
!
bSizeCoord
.
HasPercent
(
)
)
|
|
(
maxBSizeCoord
.
IsCoordPercentCalcUnit
(
)
&
&
!
maxBSizeCoord
.
HasPercent
(
)
)
)
{
mFrame
-
>
AddStateBits
(
NS_FRAME_IN_CONSTRAINED_BSIZE
)
;
break
;
}
else
if
(
(
bSizeCoord
.
IsCoordPercentCalcUnit
(
)
&
&
bSizeCoord
.
HasPercent
(
)
)
|
|
(
maxBSizeCoord
.
IsCoordPercentCalcUnit
(
)
&
&
maxBSizeCoord
.
HasPercent
(
)
)
)
{
if
(
!
(
containingBlk
=
containingBlk
-
>
GetContainingBlock
(
)
)
)
{
mFrame
-
>
RemoveStateBits
(
NS_FRAME_IN_CONSTRAINED_BSIZE
)
;
break
;
}
continue
;
}
else
{
mFrame
-
>
RemoveStateBits
(
NS_FRAME_IN_CONSTRAINED_BSIZE
)
;
break
;
}
}
}
else
{
mFrame
-
>
RemoveStateBits
(
NS_FRAME_IN_CONSTRAINED_BSIZE
)
;
}
}
if
(
mParentReflowInput
&
&
mParentReflowInput
-
>
GetWritingMode
(
)
.
IsOrthogonalTo
(
mWritingMode
)
)
{
if
(
type
=
=
LayoutFrameType
:
:
ColumnSet
&
&
eStyleUnit_Auto
=
=
mStylePosition
-
>
ISize
(
mWritingMode
)
.
GetUnit
(
)
)
{
ComputedISize
(
)
=
NS_UNCONSTRAINEDSIZE
;
}
else
{
AvailableBSize
(
)
=
NS_UNCONSTRAINEDSIZE
;
}
}
if
(
mStyleDisplay
-
>
IsContainSize
(
)
)
{
AvailableBSize
(
)
=
NS_UNCONSTRAINEDSIZE
;
}
LAYOUT_WARN_IF_FALSE
(
(
mFrameType
=
=
NS_CSS_FRAME_TYPE_INLINE
&
&
!
mFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eReplaced
)
)
|
|
type
=
=
LayoutFrameType
:
:
Text
|
|
ComputedISize
(
)
!
=
NS_UNCONSTRAINEDSIZE
"
have
unconstrained
inline
-
size
;
this
should
only
"
"
result
from
very
large
sizes
not
attempts
at
"
"
intrinsic
inline
-
size
calculation
"
)
;
}
void
ReflowInput
:
:
InitCBReflowInput
(
)
{
if
(
!
mParentReflowInput
)
{
mCBReflowInput
=
nullptr
;
return
;
}
if
(
mParentReflowInput
-
>
mFlags
.
mDummyParentReflowInput
)
{
mCBReflowInput
=
mParentReflowInput
;
return
;
}
if
(
mParentReflowInput
-
>
mFrame
=
=
mFrame
-
>
GetContainingBlock
(
0
mStyleDisplay
)
)
{
if
(
mFrame
-
>
IsTableFrame
(
)
)
{
mCBReflowInput
=
mParentReflowInput
-
>
mCBReflowInput
;
}
else
{
mCBReflowInput
=
mParentReflowInput
;
}
}
else
{
mCBReflowInput
=
mParentReflowInput
-
>
mCBReflowInput
;
}
}
static
bool
IsQuirkContainingBlockHeight
(
const
ReflowInput
*
rs
LayoutFrameType
aFrameType
)
{
if
(
LayoutFrameType
:
:
Block
=
=
aFrameType
|
|
#
ifdef
MOZ_XUL
LayoutFrameType
:
:
XULLabel
=
=
aFrameType
|
|
#
endif
LayoutFrameType
:
:
Scroll
=
=
aFrameType
)
{
if
(
NS_AUTOHEIGHT
=
=
rs
-
>
ComputedHeight
(
)
)
{
if
(
!
rs
-
>
mFrame
-
>
IsAbsolutelyPositioned
(
rs
-
>
mStyleDisplay
)
)
{
return
false
;
}
}
}
return
true
;
}
void
ReflowInput
:
:
InitResizeFlags
(
nsPresContext
*
aPresContext
LayoutFrameType
aFrameType
)
{
SetBResize
(
false
)
;
SetIResize
(
false
)
;
const
WritingMode
wm
=
mWritingMode
;
bool
isIResize
=
mFrame
-
>
ISize
(
wm
)
!
=
ComputedISize
(
)
+
ComputedLogicalBorderPadding
(
)
.
IStartEnd
(
wm
)
|
|
(
mStylePosition
-
>
mBoxSizing
!
=
StyleBoxSizing
:
:
Content
&
&
mStylePadding
-
>
IsWidthDependent
(
)
)
;
if
(
(
mFrame
-
>
GetStateBits
(
)
&
NS_FRAME_FONT_INFLATION_FLOW_ROOT
)
&
&
nsLayoutUtils
:
:
FontSizeInflationEnabled
(
aPresContext
)
)
{
bool
dirty
=
nsFontInflationData
:
:
UpdateFontInflationDataISizeFor
(
*
this
)
&
&
!
mFlags
.
mDummyParentReflowInput
;
if
(
dirty
|
|
(
!
mFrame
-
>
GetParent
(
)
&
&
isIResize
)
)
{
if
(
mFrame
-
>
IsSVGForeignObjectFrame
(
)
)
{
mFrame
-
>
AddStateBits
(
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
nsIFrame
*
kid
=
mFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
kid
)
{
kid
-
>
AddStateBits
(
NS_FRAME_IS_DIRTY
)
;
MarkFrameChildrenDirty
(
kid
)
;
}
}
else
{
mFrame
-
>
AddStateBits
(
NS_FRAME_IS_DIRTY
)
;
MarkFrameChildrenDirty
(
mFrame
)
;
}
AutoTArray
<
nsIFrame
*
32
>
stack
;
stack
.
AppendElement
(
mFrame
)
;
do
{
nsIFrame
*
f
=
stack
.
PopLastElement
(
)
;
nsIFrame
:
:
ChildListIterator
lists
(
f
)
;
for
(
;
!
lists
.
IsDone
(
)
;
lists
.
Next
(
)
)
{
nsFrameList
:
:
Enumerator
childFrames
(
lists
.
CurrentList
(
)
)
;
for
(
;
!
childFrames
.
AtEnd
(
)
;
childFrames
.
Next
(
)
)
{
nsIFrame
*
kid
=
childFrames
.
get
(
)
;
kid
-
>
MarkIntrinsicISizesDirty
(
)
;
stack
.
AppendElement
(
kid
)
;
}
}
}
while
(
stack
.
Length
(
)
!
=
0
)
;
}
}
SetIResize
(
!
(
mFrame
-
>
GetStateBits
(
)
&
NS_FRAME_IS_DIRTY
)
&
&
isIResize
)
;
if
(
IsTableCell
(
aFrameType
)
&
&
(
mFlags
.
mSpecialBSizeReflow
|
|
(
mFrame
-
>
FirstInFlow
(
)
-
>
GetStateBits
(
)
&
NS_TABLE_CELL_HAD_SPECIAL_REFLOW
)
)
&
&
(
mFrame
-
>
GetStateBits
(
)
&
NS_FRAME_CONTAINS_RELATIVE_BSIZE
)
)
{
SetBResize
(
true
)
;
}
else
if
(
mCBReflowInput
&
&
mFrame
-
>
IsBlockWrapper
(
)
)
{
SetBResize
(
mCBReflowInput
-
>
IsBResizeForWM
(
wm
)
)
;
}
else
if
(
mCBReflowInput
&
&
!
nsLayoutUtils
:
:
GetAsBlock
(
mFrame
)
)
{
SetBResize
(
mCBReflowInput
-
>
IsBResizeForWM
(
wm
)
)
;
if
(
ComputedBSize
(
)
=
=
NS_AUTOHEIGHT
)
{
SetBResize
(
IsBResize
(
)
|
|
NS_SUBTREE_DIRTY
(
mFrame
)
)
;
}
}
else
if
(
ComputedBSize
(
)
=
=
NS_AUTOHEIGHT
)
{
if
(
eCompatibility_NavQuirks
=
=
aPresContext
-
>
CompatibilityMode
(
)
&
&
mCBReflowInput
)
{
SetBResize
(
mCBReflowInput
-
>
IsBResizeForWM
(
wm
)
)
;
}
else
{
SetBResize
(
IsIResize
(
)
)
;
}
SetBResize
(
IsBResize
(
)
|
|
NS_SUBTREE_DIRTY
(
mFrame
)
)
;
}
else
{
SetBResize
(
mFrame
-
>
BSize
(
wm
)
!
=
ComputedBSize
(
)
+
ComputedLogicalBorderPadding
(
)
.
BStartEnd
(
wm
)
)
;
}
bool
dependsOnCBBSize
=
(
mStylePosition
-
>
BSizeDependsOnContainer
(
wm
)
&
&
mStylePosition
-
>
BSize
(
wm
)
.
GetUnit
(
)
!
=
eStyleUnit_Auto
)
|
|
mStylePosition
-
>
MinBSizeDependsOnContainer
(
wm
)
|
|
mStylePosition
-
>
MaxBSizeDependsOnContainer
(
wm
)
|
|
mStylePosition
-
>
OffsetHasPercent
(
wm
.
PhysicalSide
(
eLogicalSideBStart
)
)
|
|
mStylePosition
-
>
mOffset
.
GetBEndUnit
(
wm
)
!
=
eStyleUnit_Auto
|
|
mFrame
-
>
IsXULBoxFrame
(
)
;
if
(
mStyleText
-
>
mLineHeight
.
GetUnit
(
)
=
=
eStyleUnit_Enumerated
)
{
NS_ASSERTION
(
mStyleText
-
>
mLineHeight
.
GetIntValue
(
)
=
=
NS_STYLE_LINE_HEIGHT_BLOCK_HEIGHT
"
bad
line
-
height
value
"
)
;
mFrame
-
>
AddStateBits
(
NS_FRAME_CONTAINS_RELATIVE_BSIZE
)
;
dependsOnCBBSize
|
=
!
nsLayoutUtils
:
:
IsNonWrapperBlock
(
mFrame
)
;
}
if
(
!
IsBResize
(
)
&
&
mCBReflowInput
&
&
(
IsTableCell
(
mCBReflowInput
-
>
mFrame
-
>
Type
(
)
)
|
|
mCBReflowInput
-
>
mFlags
.
mHeightDependsOnAncestorCell
)
&
&
!
mCBReflowInput
-
>
mFlags
.
mSpecialBSizeReflow
&
&
dependsOnCBBSize
)
{
SetBResize
(
true
)
;
mFlags
.
mHeightDependsOnAncestorCell
=
true
;
}
if
(
dependsOnCBBSize
&
&
mCBReflowInput
)
{
const
ReflowInput
*
rs
=
this
;
bool
hitCBReflowInput
=
false
;
do
{
rs
=
rs
-
>
mParentReflowInput
;
if
(
!
rs
)
{
break
;
}
if
(
rs
-
>
mFrame
-
>
GetStateBits
(
)
&
NS_FRAME_CONTAINS_RELATIVE_BSIZE
)
{
break
;
}
rs
-
>
mFrame
-
>
AddStateBits
(
NS_FRAME_CONTAINS_RELATIVE_BSIZE
)
;
if
(
rs
=
=
mCBReflowInput
)
{
hitCBReflowInput
=
true
;
}
}
while
(
!
hitCBReflowInput
|
|
(
eCompatibility_NavQuirks
=
=
aPresContext
-
>
CompatibilityMode
(
)
&
&
!
IsQuirkContainingBlockHeight
(
rs
rs
-
>
mFrame
-
>
Type
(
)
)
)
)
;
}
if
(
mFrame
-
>
GetStateBits
(
)
&
NS_FRAME_IS_DIRTY
)
{
mFrame
-
>
RemoveStateBits
(
NS_FRAME_CONTAINS_RELATIVE_BSIZE
)
;
}
}
static
inline
bool
IsIntrinsicKeyword
(
const
nsStyleCoord
&
aCoord
)
{
if
(
aCoord
.
GetUnit
(
)
!
=
eStyleUnit_Enumerated
)
{
return
false
;
}
return
aCoord
.
GetIntValue
(
)
!
=
NS_STYLE_WIDTH_AVAILABLE
;
}
static
bool
AreDynamicReflowRootsEnabled
(
)
{
static
bool
sAreDynamicReflowRootsEnabled
;
static
bool
sIsPrefCached
=
false
;
if
(
!
sIsPrefCached
)
{
sIsPrefCached
=
true
;
Preferences
:
:
AddBoolVarCache
(
&
sAreDynamicReflowRootsEnabled
"
layout
.
dynamic
-
reflow
-
roots
.
enabled
"
)
;
}
return
sAreDynamicReflowRootsEnabled
;
}
void
ReflowInput
:
:
InitDynamicReflowRoot
(
)
{
auto
display
=
mStyleDisplay
-
>
mDisplay
;
if
(
mFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eLineParticipant
)
|
|
nsStyleDisplay
:
:
IsRubyDisplayType
(
display
)
|
|
mFrameType
=
=
NS_CSS_FRAME_TYPE_INTERNAL_TABLE
|
|
display
=
=
StyleDisplay
:
:
Table
|
|
display
=
=
StyleDisplay
:
:
InlineTable
|
|
(
mFrame
-
>
GetParent
(
)
&
&
mFrame
-
>
GetParent
(
)
-
>
IsXULBoxFrame
(
)
)
)
{
NS_ASSERTION
(
!
(
mFrame
-
>
GetStateBits
(
)
&
NS_FRAME_DYNAMIC_REFLOW_ROOT
)
"
should
not
have
dynamic
reflow
root
bit
"
)
;
return
;
}
bool
canBeDynamicReflowRoot
=
AreDynamicReflowRootsEnabled
(
)
;
const
nsStyleCoord
&
width
=
mStylePosition
-
>
mWidth
;
const
nsStyleCoord
&
height
=
mStylePosition
-
>
mHeight
;
if
(
canBeDynamicReflowRoot
&
&
(
!
width
.
IsCoordPercentCalcUnit
(
)
|
|
width
.
HasPercent
(
)
|
|
!
height
.
IsCoordPercentCalcUnit
(
)
|
|
height
.
HasPercent
(
)
|
|
IsIntrinsicKeyword
(
mStylePosition
-
>
mMinWidth
)
|
|
IsIntrinsicKeyword
(
mStylePosition
-
>
mMaxWidth
)
|
|
IsIntrinsicKeyword
(
mStylePosition
-
>
mMinHeight
)
|
|
IsIntrinsicKeyword
(
mStylePosition
-
>
mMaxHeight
)
|
|
(
(
mStylePosition
-
>
mMinWidth
.
GetUnit
(
)
=
=
eStyleUnit_Auto
|
|
mStylePosition
-
>
mMinHeight
.
GetUnit
(
)
=
=
eStyleUnit_Auto
)
&
&
mFrame
-
>
IsFlexOrGridItem
(
)
)
)
)
{
canBeDynamicReflowRoot
=
false
;
}
if
(
canBeDynamicReflowRoot
&
&
mFrame
-
>
IsFlexItem
(
)
)
{
const
nsStyleCoord
&
flexBasis
=
mStylePosition
-
>
mFlexBasis
;
if
(
flexBasis
.
GetUnit
(
)
!
=
eStyleUnit_Auto
&
&
(
!
flexBasis
.
IsCoordPercentCalcUnit
(
)
|
|
flexBasis
.
HasPercent
(
)
)
)
{
canBeDynamicReflowRoot
=
false
;
}
}
if
(
canBeDynamicReflowRoot
&
&
!
mFrame
-
>
IsFixedPosContainingBlock
(
)
)
{
canBeDynamicReflowRoot
=
false
;
}
if
(
canBeDynamicReflowRoot
&
&
mFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eBlockFrame
)
&
&
!
mFrame
-
>
HasAllStateBits
(
NS_BLOCK_FLOAT_MGR
|
NS_BLOCK_MARGIN_ROOT
)
)
{
canBeDynamicReflowRoot
=
false
;
}
if
(
canBeDynamicReflowRoot
)
{
mFrame
-
>
AddStateBits
(
NS_FRAME_DYNAMIC_REFLOW_ROOT
)
;
}
else
{
mFrame
-
>
RemoveStateBits
(
NS_FRAME_DYNAMIC_REFLOW_ROOT
)
;
}
}
nscoord
ReflowInput
:
:
GetContainingBlockContentISize
(
WritingMode
aWritingMode
)
const
{
if
(
!
mCBReflowInput
)
{
return
0
;
}
return
mCBReflowInput
-
>
GetWritingMode
(
)
.
IsOrthogonalTo
(
aWritingMode
)
?
mCBReflowInput
-
>
ComputedBSize
(
)
:
mCBReflowInput
-
>
ComputedISize
(
)
;
}
void
ReflowInput
:
:
InitFrameType
(
LayoutFrameType
aFrameType
)
{
const
nsStyleDisplay
*
disp
=
mStyleDisplay
;
nsCSSFrameType
frameType
;
DISPLAY_INIT_TYPE
(
mFrame
this
)
;
if
(
aFrameType
=
=
LayoutFrameType
:
:
Table
)
{
mFrameType
=
NS_CSS_FRAME_TYPE_BLOCK
;
return
;
}
NS_ASSERTION
(
mFrame
-
>
StyleDisplay
(
)
-
>
IsAbsolutelyPositionedStyle
(
)
=
=
disp
-
>
IsAbsolutelyPositionedStyle
(
)
"
Unexpected
position
style
"
)
;
NS_ASSERTION
(
mFrame
-
>
StyleDisplay
(
)
-
>
IsFloatingStyle
(
)
=
=
disp
-
>
IsFloatingStyle
(
)
"
Unexpected
float
style
"
)
;
if
(
mFrame
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
{
if
(
disp
-
>
IsAbsolutelyPositioned
(
mFrame
)
)
{
frameType
=
NS_CSS_FRAME_TYPE_ABSOLUTE
;
if
(
mFrame
-
>
GetPrevInFlow
(
)
)
frameType
=
NS_CSS_FRAME_TYPE_BLOCK
;
}
else
if
(
disp
-
>
IsFloating
(
mFrame
)
)
{
frameType
=
NS_CSS_FRAME_TYPE_FLOATING
;
}
else
{
NS_ASSERTION
(
disp
-
>
mDisplay
=
=
StyleDisplay
:
:
MozPopup
"
unknown
out
of
flow
frame
type
"
)
;
frameType
=
NS_CSS_FRAME_TYPE_UNKNOWN
;
}
}
else
{
switch
(
GetDisplay
(
)
)
{
case
StyleDisplay
:
:
Block
:
case
StyleDisplay
:
:
ListItem
:
case
StyleDisplay
:
:
Table
:
case
StyleDisplay
:
:
TableCaption
:
case
StyleDisplay
:
:
Flex
:
case
StyleDisplay
:
:
WebkitBox
:
case
StyleDisplay
:
:
Grid
:
case
StyleDisplay
:
:
FlowRoot
:
case
StyleDisplay
:
:
RubyTextContainer
:
frameType
=
NS_CSS_FRAME_TYPE_BLOCK
;
break
;
case
StyleDisplay
:
:
Inline
:
case
StyleDisplay
:
:
InlineBlock
:
case
StyleDisplay
:
:
InlineTable
:
case
StyleDisplay
:
:
MozInlineBox
:
case
StyleDisplay
:
:
MozInlineGrid
:
case
StyleDisplay
:
:
MozInlineStack
:
case
StyleDisplay
:
:
InlineFlex
:
case
StyleDisplay
:
:
WebkitInlineBox
:
case
StyleDisplay
:
:
InlineGrid
:
case
StyleDisplay
:
:
Ruby
:
case
StyleDisplay
:
:
RubyBase
:
case
StyleDisplay
:
:
RubyText
:
case
StyleDisplay
:
:
RubyBaseContainer
:
frameType
=
NS_CSS_FRAME_TYPE_INLINE
;
break
;
case
StyleDisplay
:
:
TableCell
:
case
StyleDisplay
:
:
TableRowGroup
:
case
StyleDisplay
:
:
TableColumn
:
case
StyleDisplay
:
:
TableColumnGroup
:
case
StyleDisplay
:
:
TableHeaderGroup
:
case
StyleDisplay
:
:
TableFooterGroup
:
case
StyleDisplay
:
:
TableRow
:
frameType
=
NS_CSS_FRAME_TYPE_INTERNAL_TABLE
;
break
;
case
StyleDisplay
:
:
None
:
default
:
frameType
=
NS_CSS_FRAME_TYPE_UNKNOWN
;
break
;
}
}
if
(
mFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eReplacedContainsBlock
)
)
{
frameType
=
NS_FRAME_REPLACED_CONTAINS_BLOCK
(
frameType
)
;
}
else
if
(
mFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eReplaced
)
)
{
frameType
=
NS_FRAME_REPLACED
(
frameType
)
;
}
mFrameType
=
frameType
;
}
void
ReflowInput
:
:
ComputeRelativeOffsets
(
WritingMode
aWM
nsIFrame
*
aFrame
const
LogicalSize
&
aCBSize
nsMargin
&
aComputedOffsets
)
{
LogicalMargin
offsets
(
aWM
)
;
mozilla
:
:
Side
inlineStart
=
aWM
.
PhysicalSide
(
eLogicalSideIStart
)
;
mozilla
:
:
Side
inlineEnd
=
aWM
.
PhysicalSide
(
eLogicalSideIEnd
)
;
mozilla
:
:
Side
blockStart
=
aWM
.
PhysicalSide
(
eLogicalSideBStart
)
;
mozilla
:
:
Side
blockEnd
=
aWM
.
PhysicalSide
(
eLogicalSideBEnd
)
;
const
nsStylePosition
*
position
=
aFrame
-
>
StylePosition
(
)
;
bool
inlineStartIsAuto
=
eStyleUnit_Auto
=
=
position
-
>
mOffset
.
GetUnit
(
inlineStart
)
;
bool
inlineEndIsAuto
=
eStyleUnit_Auto
=
=
position
-
>
mOffset
.
GetUnit
(
inlineEnd
)
;
if
(
!
inlineStartIsAuto
&
&
!
inlineEndIsAuto
)
{
inlineEndIsAuto
=
true
;
}
if
(
inlineStartIsAuto
)
{
if
(
inlineEndIsAuto
)
{
offsets
.
IStart
(
aWM
)
=
offsets
.
IEnd
(
aWM
)
=
0
;
}
else
{
offsets
.
IEnd
(
aWM
)
=
nsLayoutUtils
:
:
ComputeCBDependentValue
(
aCBSize
.
ISize
(
aWM
)
position
-
>
mOffset
.
Get
(
inlineEnd
)
)
;
offsets
.
IStart
(
aWM
)
=
-
offsets
.
IEnd
(
aWM
)
;
}
}
else
{
NS_ASSERTION
(
inlineEndIsAuto
"
unexpected
specified
constraint
"
)
;
offsets
.
IStart
(
aWM
)
=
nsLayoutUtils
:
:
ComputeCBDependentValue
(
aCBSize
.
ISize
(
aWM
)
position
-
>
mOffset
.
Get
(
inlineStart
)
)
;
offsets
.
IEnd
(
aWM
)
=
-
offsets
.
IStart
(
aWM
)
;
}
bool
blockStartIsAuto
=
eStyleUnit_Auto
=
=
position
-
>
mOffset
.
GetUnit
(
blockStart
)
;
bool
blockEndIsAuto
=
eStyleUnit_Auto
=
=
position
-
>
mOffset
.
GetUnit
(
blockEnd
)
;
if
(
NS_AUTOHEIGHT
=
=
aCBSize
.
BSize
(
aWM
)
)
{
if
(
position
-
>
OffsetHasPercent
(
blockStart
)
)
{
blockStartIsAuto
=
true
;
}
if
(
position
-
>
OffsetHasPercent
(
blockEnd
)
)
{
blockEndIsAuto
=
true
;
}
}
if
(
!
blockStartIsAuto
&
&
!
blockEndIsAuto
)
{
blockEndIsAuto
=
true
;
}
if
(
blockStartIsAuto
)
{
if
(
blockEndIsAuto
)
{
offsets
.
BStart
(
aWM
)
=
offsets
.
BEnd
(
aWM
)
=
0
;
}
else
{
offsets
.
BEnd
(
aWM
)
=
nsLayoutUtils
:
:
ComputeBSizeDependentValue
(
aCBSize
.
BSize
(
aWM
)
position
-
>
mOffset
.
Get
(
blockEnd
)
)
;
offsets
.
BStart
(
aWM
)
=
-
offsets
.
BEnd
(
aWM
)
;
}
}
else
{
NS_ASSERTION
(
blockEndIsAuto
"
unexpected
specified
constraint
"
)
;
offsets
.
BStart
(
aWM
)
=
nsLayoutUtils
:
:
ComputeBSizeDependentValue
(
aCBSize
.
BSize
(
aWM
)
position
-
>
mOffset
.
Get
(
blockStart
)
)
;
offsets
.
BEnd
(
aWM
)
=
-
offsets
.
BStart
(
aWM
)
;
}
aComputedOffsets
=
offsets
.
GetPhysicalMargin
(
aWM
)
;
nsMargin
*
physicalOffsets
=
aFrame
-
>
GetProperty
(
nsIFrame
:
:
ComputedOffsetProperty
(
)
)
;
if
(
physicalOffsets
)
{
*
physicalOffsets
=
aComputedOffsets
;
}
else
{
aFrame
-
>
AddProperty
(
nsIFrame
:
:
ComputedOffsetProperty
(
)
new
nsMargin
(
aComputedOffsets
)
)
;
}
}
void
ReflowInput
:
:
ApplyRelativePositioning
(
nsIFrame
*
aFrame
const
nsMargin
&
aComputedOffsets
nsPoint
*
aPosition
)
{
if
(
!
aFrame
-
>
IsRelativelyPositioned
(
)
)
{
NS_ASSERTION
(
!
aFrame
-
>
GetProperty
(
nsIFrame
:
:
NormalPositionProperty
(
)
)
"
We
assume
that
changing
the
'
position
'
property
causes
"
"
frame
reconstruction
.
If
that
ever
changes
this
code
"
"
should
call
"
"
aFrame
-
>
DeleteProperty
(
nsIFrame
:
:
NormalPositionProperty
(
)
)
"
)
;
return
;
}
nsPoint
*
normalPosition
=
aFrame
-
>
GetProperty
(
nsIFrame
:
:
NormalPositionProperty
(
)
)
;
if
(
normalPosition
)
{
*
normalPosition
=
*
aPosition
;
}
else
{
aFrame
-
>
AddProperty
(
nsIFrame
:
:
NormalPositionProperty
(
)
new
nsPoint
(
*
aPosition
)
)
;
}
const
nsStyleDisplay
*
display
=
aFrame
-
>
StyleDisplay
(
)
;
if
(
NS_STYLE_POSITION_RELATIVE
=
=
display
-
>
mPosition
)
{
*
aPosition
+
=
nsPoint
(
aComputedOffsets
.
left
aComputedOffsets
.
top
)
;
}
else
if
(
NS_STYLE_POSITION_STICKY
=
=
display
-
>
mPosition
&
&
!
aFrame
-
>
GetNextContinuation
(
)
&
&
!
aFrame
-
>
GetPrevContinuation
(
)
&
&
!
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_PART_OF_IBSPLIT
)
)
{
StickyScrollContainer
*
ssc
=
StickyScrollContainer
:
:
GetStickyScrollContainerForFrame
(
aFrame
)
;
if
(
ssc
)
{
*
aPosition
=
ssc
-
>
ComputePosition
(
aFrame
)
;
}
}
}
static
bool
IsXULCollapsedXULFrame
(
nsIFrame
*
aFrame
)
{
return
aFrame
&
&
aFrame
-
>
IsXULBoxFrame
(
)
&
&
aFrame
-
>
IsXULCollapsed
(
)
;
}
nsIFrame
*
ReflowInput
:
:
GetHypotheticalBoxContainer
(
nsIFrame
*
aFrame
nscoord
&
aCBIStartEdge
LogicalSize
&
aCBSize
)
const
{
aFrame
=
aFrame
-
>
GetContainingBlock
(
)
;
NS_ASSERTION
(
aFrame
!
=
mFrame
"
How
did
that
happen
?
"
)
;
const
ReflowInput
*
reflowInput
;
if
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_IN_REFLOW
)
{
for
(
reflowInput
=
mParentReflowInput
;
reflowInput
&
&
reflowInput
-
>
mFrame
!
=
aFrame
;
reflowInput
=
reflowInput
-
>
mParentReflowInput
)
{
}
}
else
{
reflowInput
=
nullptr
;
}
if
(
reflowInput
)
{
WritingMode
wm
=
reflowInput
-
>
GetWritingMode
(
)
;
NS_ASSERTION
(
wm
=
=
aFrame
-
>
GetWritingMode
(
)
"
unexpected
writing
mode
"
)
;
aCBIStartEdge
=
reflowInput
-
>
ComputedLogicalBorderPadding
(
)
.
IStart
(
wm
)
;
aCBSize
=
reflowInput
-
>
ComputedSize
(
wm
)
;
}
else
{
NS_ASSERTION
(
!
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_IN_REFLOW
)
"
aFrame
shouldn
'
t
be
in
reflow
;
we
'
ll
lie
if
it
is
"
)
;
WritingMode
wm
=
aFrame
-
>
GetWritingMode
(
)
;
aCBIStartEdge
=
0
;
aCBSize
=
aFrame
-
>
GetLogicalSize
(
wm
)
;
if
(
!
aCBSize
.
IsAllZero
(
)
|
|
(
!
IsXULCollapsedXULFrame
(
aFrame
-
>
GetParent
(
)
)
)
)
{
LogicalMargin
borderPadding
=
aFrame
-
>
GetLogicalUsedBorderAndPadding
(
wm
)
;
aCBIStartEdge
+
=
borderPadding
.
IStart
(
wm
)
;
aCBSize
-
=
borderPadding
.
Size
(
wm
)
;
}
}
return
aFrame
;
}
struct
nsHypotheticalPosition
{
nscoord
mIStart
;
nscoord
mBStart
;
WritingMode
mWritingMode
;
}
;
static
bool
GetIntrinsicSizeFor
(
nsIFrame
*
aFrame
nsSize
&
aIntrinsicSize
LayoutFrameType
aFrameType
)
{
bool
success
=
false
;
if
(
aFrameType
=
=
LayoutFrameType
:
:
Image
)
{
nsImageFrame
*
imageFrame
=
(
nsImageFrame
*
)
aFrame
;
if
(
NS_SUCCEEDED
(
imageFrame
-
>
GetIntrinsicImageSize
(
aIntrinsicSize
)
)
)
{
success
=
(
aIntrinsicSize
!
=
nsSize
(
0
0
)
)
;
}
}
return
success
;
}
void
ReflowInput
:
:
CalculateBorderPaddingMargin
(
LogicalAxis
aAxis
nscoord
aContainingBlockSize
nscoord
*
aInsideBoxSizing
nscoord
*
aOutsideBoxSizing
)
const
{
WritingMode
wm
=
GetWritingMode
(
)
;
mozilla
:
:
Side
startSide
=
wm
.
PhysicalSide
(
MakeLogicalSide
(
aAxis
eLogicalEdgeStart
)
)
;
mozilla
:
:
Side
endSide
=
wm
.
PhysicalSide
(
MakeLogicalSide
(
aAxis
eLogicalEdgeEnd
)
)
;
nsMargin
styleBorder
=
mStyleBorder
-
>
GetComputedBorder
(
)
;
nscoord
borderStartEnd
=
styleBorder
.
Side
(
startSide
)
+
styleBorder
.
Side
(
endSide
)
;
nscoord
paddingStartEnd
marginStartEnd
;
nsMargin
stylePadding
;
if
(
mStylePadding
-
>
GetPadding
(
stylePadding
)
)
{
paddingStartEnd
=
stylePadding
.
Side
(
startSide
)
+
stylePadding
.
Side
(
endSide
)
;
}
else
{
nscoord
start
end
;
start
=
nsLayoutUtils
:
:
ComputeCBDependentValue
(
aContainingBlockSize
mStylePadding
-
>
mPadding
.
Get
(
startSide
)
)
;
end
=
nsLayoutUtils
:
:
ComputeCBDependentValue
(
aContainingBlockSize
mStylePadding
-
>
mPadding
.
Get
(
endSide
)
)
;
paddingStartEnd
=
start
+
end
;
}
nsMargin
styleMargin
;
if
(
mStyleMargin
-
>
GetMargin
(
styleMargin
)
)
{
marginStartEnd
=
styleMargin
.
Side
(
startSide
)
+
styleMargin
.
Side
(
endSide
)
;
}
else
{
nscoord
start
end
;
if
(
eStyleUnit_Auto
=
=
mStyleMargin
-
>
mMargin
.
GetUnit
(
startSide
)
)
{
start
=
0
;
}
else
{
start
=
nsLayoutUtils
:
:
ComputeCBDependentValue
(
aContainingBlockSize
mStyleMargin
-
>
mMargin
.
Get
(
startSide
)
)
;
}
if
(
eStyleUnit_Auto
=
=
mStyleMargin
-
>
mMargin
.
GetUnit
(
endSide
)
)
{
end
=
0
;
}
else
{
end
=
nsLayoutUtils
:
:
ComputeCBDependentValue
(
aContainingBlockSize
mStyleMargin
-
>
mMargin
.
Get
(
endSide
)
)
;
}
marginStartEnd
=
start
+
end
;
}
nscoord
outside
=
paddingStartEnd
+
borderStartEnd
+
marginStartEnd
;
nscoord
inside
=
0
;
if
(
mStylePosition
-
>
mBoxSizing
=
=
StyleBoxSizing
:
:
Border
)
{
inside
=
borderStartEnd
+
paddingStartEnd
;
}
outside
-
=
inside
;
*
aInsideBoxSizing
=
inside
;
*
aOutsideBoxSizing
=
outside
;
}
static
bool
AreAllEarlierInFlowFramesEmpty
(
nsIFrame
*
aFrame
nsIFrame
*
aDescendant
bool
*
aFound
)
{
if
(
aFrame
=
=
aDescendant
)
{
*
aFound
=
true
;
return
true
;
}
if
(
aFrame
-
>
IsPlaceholderFrame
(
)
)
{
auto
ph
=
static_cast
<
nsPlaceholderFrame
*
>
(
aFrame
)
;
MOZ_ASSERT
(
ph
-
>
IsSelfEmpty
(
)
&
&
ph
-
>
PrincipalChildList
(
)
.
IsEmpty
(
)
)
;
ph
-
>
SetLineIsEmptySoFar
(
true
)
;
}
else
{
if
(
!
aFrame
-
>
IsSelfEmpty
(
)
)
{
*
aFound
=
false
;
return
false
;
}
for
(
nsIFrame
*
f
:
aFrame
-
>
PrincipalChildList
(
)
)
{
bool
allEmpty
=
AreAllEarlierInFlowFramesEmpty
(
f
aDescendant
aFound
)
;
if
(
*
aFound
|
|
!
allEmpty
)
{
return
allEmpty
;
}
}
}
*
aFound
=
false
;
return
true
;
}
void
ReflowInput
:
:
CalculateHypotheticalPosition
(
nsPresContext
*
aPresContext
nsPlaceholderFrame
*
aPlaceholderFrame
const
ReflowInput
*
aCBReflowInput
nsHypotheticalPosition
&
aHypotheticalPos
LayoutFrameType
aFrameType
)
const
{
NS_ASSERTION
(
mStyleDisplay
-
>
mOriginalDisplay
!
=
StyleDisplay
:
:
None
"
mOriginalDisplay
has
not
been
properly
initialized
"
)
;
nscoord
blockIStartContentEdge
;
WritingMode
cbwm
=
aCBReflowInput
-
>
GetWritingMode
(
)
;
LogicalSize
blockContentSize
(
cbwm
)
;
nsIFrame
*
containingBlock
=
GetHypotheticalBoxContainer
(
aPlaceholderFrame
blockIStartContentEdge
blockContentSize
)
;
WritingMode
wm
=
containingBlock
-
>
GetWritingMode
(
)
;
nsStyleCoord
styleISize
=
mStylePosition
-
>
ISize
(
wm
)
;
bool
isAutoISize
=
styleISize
.
GetUnit
(
)
=
=
eStyleUnit_Auto
;
nsSize
intrinsicSize
;
bool
knowIntrinsicSize
=
false
;
if
(
NS_FRAME_IS_REPLACED
(
mFrameType
)
&
&
isAutoISize
)
{
knowIntrinsicSize
=
GetIntrinsicSizeFor
(
mFrame
intrinsicSize
aFrameType
)
;
}
nscoord
boxISize
;
bool
knowBoxISize
=
false
;
if
(
(
StyleDisplay
:
:
Inline
=
=
mStyleDisplay
-
>
mOriginalDisplay
)
&
&
!
NS_FRAME_IS_REPLACED
(
mFrameType
)
)
{
}
else
{
nscoord
insideBoxSizing
outsideBoxSizing
;
CalculateBorderPaddingMargin
(
eLogicalAxisInline
blockContentSize
.
ISize
(
wm
)
&
insideBoxSizing
&
outsideBoxSizing
)
;
if
(
NS_FRAME_IS_REPLACED
(
mFrameType
)
&
&
isAutoISize
)
{
if
(
knowIntrinsicSize
)
{
boxISize
=
LogicalSize
(
wm
intrinsicSize
)
.
ISize
(
wm
)
+
outsideBoxSizing
+
insideBoxSizing
;
knowBoxISize
=
true
;
}
}
else
if
(
isAutoISize
)
{
boxISize
=
blockContentSize
.
ISize
(
wm
)
;
knowBoxISize
=
true
;
}
else
{
boxISize
=
ComputeISizeValue
(
blockContentSize
.
ISize
(
wm
)
insideBoxSizing
outsideBoxSizing
styleISize
)
+
insideBoxSizing
+
outsideBoxSizing
;
knowBoxISize
=
true
;
}
}
nsSize
containerSize
=
containingBlock
-
>
GetStateBits
(
)
&
NS_FRAME_IN_REFLOW
?
aCBReflowInput
-
>
ComputedSizeAsContainerIfConstrained
(
)
:
containingBlock
-
>
GetSize
(
)
;
LogicalPoint
placeholderOffset
(
wm
aPlaceholderFrame
-
>
GetOffsetToIgnoringScrolling
(
containingBlock
)
containerSize
)
;
nsBlockFrame
*
blockFrame
=
nsLayoutUtils
:
:
GetAsBlock
(
containingBlock
-
>
GetContentInsertionFrame
(
)
)
;
if
(
blockFrame
)
{
const
nsSize
nullContainerSize
;
LogicalPoint
blockOffset
(
wm
blockFrame
-
>
GetOffsetToIgnoringScrolling
(
containingBlock
)
nullContainerSize
)
;
bool
isValid
;
nsBlockInFlowLineIterator
iter
(
blockFrame
aPlaceholderFrame
&
isValid
)
;
if
(
!
isValid
)
{
aHypotheticalPos
.
mBStart
=
placeholderOffset
.
B
(
wm
)
;
}
else
{
NS_ASSERTION
(
iter
.
GetContainer
(
)
=
=
blockFrame
"
Found
placeholder
in
wrong
block
!
"
)
;
nsBlockFrame
:
:
LineIterator
lineBox
=
iter
.
GetLine
(
)
;
LogicalRect
lineBounds
=
lineBox
-
>
GetBounds
(
)
.
ConvertTo
(
wm
lineBox
-
>
mWritingMode
lineBox
-
>
mContainerSize
)
;
if
(
mStyleDisplay
-
>
IsOriginalDisplayInlineOutsideStyle
(
)
)
{
aHypotheticalPos
.
mBStart
=
lineBounds
.
BStart
(
wm
)
+
blockOffset
.
B
(
wm
)
;
}
else
{
if
(
lineBox
!
=
iter
.
End
(
)
)
{
nsIFrame
*
firstFrame
=
lineBox
-
>
mFirstChild
;
bool
allEmpty
=
false
;
if
(
firstFrame
=
=
aPlaceholderFrame
)
{
aPlaceholderFrame
-
>
SetLineIsEmptySoFar
(
true
)
;
allEmpty
=
true
;
}
else
{
auto
prev
=
aPlaceholderFrame
-
>
GetPrevSibling
(
)
;
if
(
prev
&
&
prev
-
>
IsPlaceholderFrame
(
)
)
{
auto
ph
=
static_cast
<
nsPlaceholderFrame
*
>
(
prev
)
;
if
(
ph
-
>
GetLineIsEmptySoFar
(
&
allEmpty
)
)
{
aPlaceholderFrame
-
>
SetLineIsEmptySoFar
(
allEmpty
)
;
}
}
}
if
(
!
allEmpty
)
{
bool
found
=
false
;
while
(
firstFrame
)
{
allEmpty
=
AreAllEarlierInFlowFramesEmpty
(
firstFrame
aPlaceholderFrame
&
found
)
;
if
(
found
|
|
!
allEmpty
)
{
break
;
}
firstFrame
=
firstFrame
-
>
GetNextSibling
(
)
;
}
aPlaceholderFrame
-
>
SetLineIsEmptySoFar
(
allEmpty
)
;
}
NS_ASSERTION
(
firstFrame
"
Couldn
'
t
find
placeholder
!
"
)
;
if
(
allEmpty
)
{
aHypotheticalPos
.
mBStart
=
lineBounds
.
BStart
(
wm
)
+
blockOffset
.
B
(
wm
)
;
}
else
{
aHypotheticalPos
.
mBStart
=
lineBounds
.
BEnd
(
wm
)
+
blockOffset
.
B
(
wm
)
;
}
}
else
{
aHypotheticalPos
.
mBStart
=
placeholderOffset
.
B
(
wm
)
;
}
}
}
}
else
{
aHypotheticalPos
.
mBStart
=
placeholderOffset
.
B
(
wm
)
;
}
if
(
mStyleDisplay
-
>
IsOriginalDisplayInlineOutsideStyle
(
)
|
|
mFlags
.
mIOffsetsNeedCSSAlign
)
{
aHypotheticalPos
.
mIStart
=
placeholderOffset
.
I
(
wm
)
;
}
else
{
aHypotheticalPos
.
mIStart
=
blockIStartContentEdge
;
}
nsPoint
cbOffset
=
containingBlock
-
>
GetOffsetToIgnoringScrolling
(
aCBReflowInput
-
>
mFrame
)
;
nsSize
reflowSize
=
aCBReflowInput
-
>
ComputedSizeAsContainerIfConstrained
(
)
;
LogicalPoint
logCBOffs
(
wm
cbOffset
reflowSize
-
containerSize
)
;
aHypotheticalPos
.
mIStart
+
=
logCBOffs
.
I
(
wm
)
;
aHypotheticalPos
.
mBStart
+
=
logCBOffs
.
B
(
wm
)
;
LogicalMargin
border
=
aCBReflowInput
-
>
ComputedLogicalBorderPadding
(
)
-
aCBReflowInput
-
>
ComputedLogicalPadding
(
)
;
border
=
border
.
ConvertTo
(
wm
aCBReflowInput
-
>
GetWritingMode
(
)
)
;
aHypotheticalPos
.
mIStart
-
=
border
.
IStart
(
wm
)
;
aHypotheticalPos
.
mBStart
-
=
border
.
BStart
(
wm
)
;
if
(
cbwm
.
GetBlockDir
(
)
!
=
wm
.
GetBlockDir
(
)
)
{
nscoord
insideBoxSizing
outsideBoxSizing
;
CalculateBorderPaddingMargin
(
eLogicalAxisBlock
blockContentSize
.
BSize
(
wm
)
&
insideBoxSizing
&
outsideBoxSizing
)
;
nscoord
boxBSize
;
nsStyleCoord
styleBSize
=
mStylePosition
-
>
BSize
(
wm
)
;
if
(
styleBSize
.
IsAutoOrEnum
(
)
)
{
if
(
NS_FRAME_IS_REPLACED
(
mFrameType
)
&
&
knowIntrinsicSize
)
{
boxBSize
=
LogicalSize
(
wm
intrinsicSize
)
.
BSize
(
wm
)
+
outsideBoxSizing
+
insideBoxSizing
;
}
else
{
boxBSize
=
0
;
}
}
else
{
boxBSize
=
nsLayoutUtils
:
:
ComputeBSizeValue
(
blockContentSize
.
BSize
(
wm
)
insideBoxSizing
styleBSize
)
+
insideBoxSizing
+
outsideBoxSizing
;
}
LogicalSize
boxSize
(
wm
knowBoxISize
?
boxISize
:
0
boxBSize
)
;
LogicalPoint
origin
(
wm
aHypotheticalPos
.
mIStart
aHypotheticalPos
.
mBStart
)
;
origin
=
origin
.
ConvertTo
(
cbwm
wm
reflowSize
-
boxSize
.
GetPhysicalSize
(
wm
)
)
;
aHypotheticalPos
.
mIStart
=
origin
.
I
(
cbwm
)
;
aHypotheticalPos
.
mBStart
=
origin
.
B
(
cbwm
)
;
aHypotheticalPos
.
mWritingMode
=
cbwm
;
}
else
{
aHypotheticalPos
.
mWritingMode
=
wm
;
}
}
void
ReflowInput
:
:
InitAbsoluteConstraints
(
nsPresContext
*
aPresContext
const
ReflowInput
*
aCBReflowInput
const
LogicalSize
&
aCBSize
LayoutFrameType
aFrameType
)
{
WritingMode
wm
=
GetWritingMode
(
)
;
WritingMode
cbwm
=
aCBReflowInput
-
>
GetWritingMode
(
)
;
NS_WARNING_ASSERTION
(
aCBSize
.
BSize
(
cbwm
)
!
=
NS_AUTOHEIGHT
"
containing
block
bsize
must
be
constrained
"
)
;
NS_ASSERTION
(
aFrameType
!
=
LayoutFrameType
:
:
Table
"
InitAbsoluteConstraints
should
not
be
called
on
table
frames
"
)
;
NS_ASSERTION
(
mFrame
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
"
Why
are
we
here
?
"
)
;
const
auto
&
styleOffset
=
mStylePosition
-
>
mOffset
;
bool
iStartIsAuto
=
styleOffset
.
GetIStartUnit
(
cbwm
)
=
=
eStyleUnit_Auto
;
bool
iEndIsAuto
=
styleOffset
.
GetIEndUnit
(
cbwm
)
=
=
eStyleUnit_Auto
;
bool
bStartIsAuto
=
styleOffset
.
GetBStartUnit
(
cbwm
)
=
=
eStyleUnit_Auto
;
bool
bEndIsAuto
=
styleOffset
.
GetBEndUnit
(
cbwm
)
=
=
eStyleUnit_Auto
;
nsHypotheticalPosition
hypotheticalPos
;
if
(
(
iStartIsAuto
&
&
iEndIsAuto
)
|
|
(
bStartIsAuto
&
&
bEndIsAuto
)
)
{
nsPlaceholderFrame
*
placeholderFrame
=
mFrame
-
>
GetPlaceholderFrame
(
)
;
MOZ_ASSERT
(
placeholderFrame
"
no
placeholder
frame
"
)
;
if
(
placeholderFrame
-
>
HasAnyStateBits
(
PLACEHOLDER_STATICPOS_NEEDS_CSSALIGN
)
)
{
DebugOnly
<
nsIFrame
*
>
placeholderParent
=
placeholderFrame
-
>
GetParent
(
)
;
MOZ_ASSERT
(
placeholderParent
"
shouldn
'
t
have
unparented
placeholders
"
)
;
MOZ_ASSERT
(
placeholderParent
-
>
IsFlexOrGridContainer
(
)
"
This
flag
should
only
be
set
on
grid
/
flex
children
"
)
;
mFlags
.
mIOffsetsNeedCSSAlign
=
(
iStartIsAuto
&
&
iEndIsAuto
)
;
mFlags
.
mBOffsetsNeedCSSAlign
=
(
bStartIsAuto
&
&
bEndIsAuto
)
;
}
if
(
mFlags
.
mStaticPosIsCBOrigin
)
{
hypotheticalPos
.
mWritingMode
=
cbwm
;
hypotheticalPos
.
mIStart
=
nscoord
(
0
)
;
hypotheticalPos
.
mBStart
=
nscoord
(
0
)
;
}
else
{
CalculateHypotheticalPosition
(
aPresContext
placeholderFrame
aCBReflowInput
hypotheticalPos
aFrameType
)
;
if
(
aCBReflowInput
-
>
mFrame
-
>
IsGridContainerFrame
(
)
)
{
nsRect
cb
=
nsGridContainerFrame
:
:
GridItemCB
(
mFrame
)
;
nscoord
left
(
0
)
;
nscoord
right
(
0
)
;
if
(
cbwm
.
IsBidiLTR
(
)
)
{
left
=
cb
.
X
(
)
;
}
else
{
right
=
aCBReflowInput
-
>
ComputedWidth
(
)
+
aCBReflowInput
-
>
ComputedPhysicalPadding
(
)
.
LeftRight
(
)
-
cb
.
XMost
(
)
;
}
LogicalMargin
offsets
(
cbwm
nsMargin
(
cb
.
Y
(
)
right
nscoord
(
0
)
left
)
)
;
hypotheticalPos
.
mIStart
-
=
offsets
.
IStart
(
cbwm
)
;
hypotheticalPos
.
mBStart
-
=
offsets
.
BStart
(
cbwm
)
;
}
}
}
LogicalSize
cbSize
=
aCBSize
;
LogicalMargin
offsets
=
ComputedLogicalOffsets
(
)
.
ConvertTo
(
cbwm
wm
)
;
if
(
iStartIsAuto
)
{
offsets
.
IStart
(
cbwm
)
=
0
;
}
else
{
offsets
.
IStart
(
cbwm
)
=
nsLayoutUtils
:
:
ComputeCBDependentValue
(
cbSize
.
ISize
(
cbwm
)
styleOffset
.
GetIStart
(
cbwm
)
)
;
}
if
(
iEndIsAuto
)
{
offsets
.
IEnd
(
cbwm
)
=
0
;
}
else
{
offsets
.
IEnd
(
cbwm
)
=
nsLayoutUtils
:
:
ComputeCBDependentValue
(
cbSize
.
ISize
(
cbwm
)
styleOffset
.
GetIEnd
(
cbwm
)
)
;
}
if
(
iStartIsAuto
&
&
iEndIsAuto
)
{
if
(
cbwm
.
IsBidiLTR
(
)
!
=
hypotheticalPos
.
mWritingMode
.
IsBidiLTR
(
)
)
{
offsets
.
IEnd
(
cbwm
)
=
hypotheticalPos
.
mIStart
;
iEndIsAuto
=
false
;
}
else
{
offsets
.
IStart
(
cbwm
)
=
hypotheticalPos
.
mIStart
;
iStartIsAuto
=
false
;
}
}
if
(
bStartIsAuto
)
{
offsets
.
BStart
(
cbwm
)
=
0
;
}
else
{
offsets
.
BStart
(
cbwm
)
=
nsLayoutUtils
:
:
ComputeBSizeDependentValue
(
cbSize
.
BSize
(
cbwm
)
styleOffset
.
GetBStart
(
cbwm
)
)
;
}
if
(
bEndIsAuto
)
{
offsets
.
BEnd
(
cbwm
)
=
0
;
}
else
{
offsets
.
BEnd
(
cbwm
)
=
nsLayoutUtils
:
:
ComputeBSizeDependentValue
(
cbSize
.
BSize
(
cbwm
)
styleOffset
.
GetBEnd
(
cbwm
)
)
;
}
if
(
bStartIsAuto
&
&
bEndIsAuto
)
{
offsets
.
BStart
(
cbwm
)
=
hypotheticalPos
.
mBStart
;
bStartIsAuto
=
false
;
}
SetComputedLogicalOffsets
(
offsets
.
ConvertTo
(
wm
cbwm
)
)
;
typedef
nsIFrame
:
:
ComputeSizeFlags
ComputeSizeFlags
;
ComputeSizeFlags
computeSizeFlags
=
ComputeSizeFlags
:
:
eDefault
;
if
(
mFlags
.
mIClampMarginBoxMinSize
)
{
computeSizeFlags
=
ComputeSizeFlags
(
computeSizeFlags
|
ComputeSizeFlags
:
:
eIClampMarginBoxMinSize
)
;
}
if
(
mFlags
.
mBClampMarginBoxMinSize
)
{
computeSizeFlags
=
ComputeSizeFlags
(
computeSizeFlags
|
ComputeSizeFlags
:
:
eBClampMarginBoxMinSize
)
;
}
if
(
mFlags
.
mApplyAutoMinSize
)
{
computeSizeFlags
=
ComputeSizeFlags
(
computeSizeFlags
|
ComputeSizeFlags
:
:
eIApplyAutoMinSize
)
;
}
if
(
mFlags
.
mShrinkWrap
)
{
computeSizeFlags
=
ComputeSizeFlags
(
computeSizeFlags
|
ComputeSizeFlags
:
:
eShrinkWrap
)
;
}
if
(
mFlags
.
mUseAutoBSize
)
{
computeSizeFlags
=
ComputeSizeFlags
(
computeSizeFlags
|
ComputeSizeFlags
:
:
eUseAutoBSize
)
;
}
if
(
wm
.
IsOrthogonalTo
(
cbwm
)
)
{
if
(
bStartIsAuto
|
|
bEndIsAuto
)
{
computeSizeFlags
=
ComputeSizeFlags
(
computeSizeFlags
|
ComputeSizeFlags
:
:
eShrinkWrap
)
;
}
}
else
{
if
(
iStartIsAuto
|
|
iEndIsAuto
)
{
computeSizeFlags
=
ComputeSizeFlags
(
computeSizeFlags
|
ComputeSizeFlags
:
:
eShrinkWrap
)
;
}
}
LogicalSize
computedSize
(
wm
)
;
{
AutoMaybeDisableFontInflation
an
(
mFrame
)
;
computedSize
=
mFrame
-
>
ComputeSize
(
mRenderingContext
wm
cbSize
.
ConvertTo
(
wm
cbwm
)
cbSize
.
ConvertTo
(
wm
cbwm
)
.
ISize
(
wm
)
ComputedLogicalMargin
(
)
.
Size
(
wm
)
+
ComputedLogicalOffsets
(
)
.
Size
(
wm
)
ComputedLogicalBorderPadding
(
)
.
Size
(
wm
)
-
ComputedLogicalPadding
(
)
.
Size
(
wm
)
ComputedLogicalPadding
(
)
.
Size
(
wm
)
computeSizeFlags
)
;
ComputedISize
(
)
=
computedSize
.
ISize
(
wm
)
;
ComputedBSize
(
)
=
computedSize
.
BSize
(
wm
)
;
NS_ASSERTION
(
ComputedISize
(
)
>
=
0
"
Bogus
inline
-
size
"
)
;
NS_ASSERTION
(
ComputedBSize
(
)
=
=
NS_UNCONSTRAINEDSIZE
|
|
ComputedBSize
(
)
>
=
0
"
Bogus
block
-
size
"
)
;
}
computedSize
=
computedSize
.
ConvertTo
(
cbwm
wm
)
;
LogicalMargin
margin
=
ComputedLogicalMargin
(
)
.
ConvertTo
(
cbwm
wm
)
;
const
LogicalMargin
borderPadding
=
ComputedLogicalBorderPadding
(
)
.
ConvertTo
(
cbwm
wm
)
;
bool
iSizeIsAuto
=
eStyleUnit_Auto
=
=
mStylePosition
-
>
ISize
(
cbwm
)
.
GetUnit
(
)
;
bool
marginIStartIsAuto
=
false
;
bool
marginIEndIsAuto
=
false
;
bool
marginBStartIsAuto
=
false
;
bool
marginBEndIsAuto
=
false
;
if
(
iStartIsAuto
)
{
if
(
iSizeIsAuto
)
{
offsets
.
IStart
(
cbwm
)
=
NS_AUTOOFFSET
;
}
else
{
offsets
.
IStart
(
cbwm
)
=
cbSize
.
ISize
(
cbwm
)
-
offsets
.
IEnd
(
cbwm
)
-
computedSize
.
ISize
(
cbwm
)
-
margin
.
IStartEnd
(
cbwm
)
-
borderPadding
.
IStartEnd
(
cbwm
)
;
}
}
else
if
(
iEndIsAuto
)
{
if
(
iSizeIsAuto
)
{
offsets
.
IEnd
(
cbwm
)
=
NS_AUTOOFFSET
;
}
else
{
offsets
.
IEnd
(
cbwm
)
=
cbSize
.
ISize
(
cbwm
)
-
offsets
.
IStart
(
cbwm
)
-
computedSize
.
ISize
(
cbwm
)
-
margin
.
IStartEnd
(
cbwm
)
-
borderPadding
.
IStartEnd
(
cbwm
)
;
}
}
else
{
if
(
wm
.
IsOrthogonalTo
(
cbwm
)
)
{
nscoord
autoISize
=
cbSize
.
ISize
(
cbwm
)
-
margin
.
IStartEnd
(
cbwm
)
-
borderPadding
.
IStartEnd
(
cbwm
)
-
offsets
.
IStartEnd
(
cbwm
)
;
if
(
autoISize
<
0
)
{
autoISize
=
0
;
}
if
(
computedSize
.
ISize
(
cbwm
)
=
=
NS_UNCONSTRAINEDSIZE
)
{
computedSize
.
ISize
(
cbwm
)
=
autoISize
;
LogicalSize
maxSize
=
ComputedMaxSize
(
cbwm
)
;
LogicalSize
minSize
=
ComputedMinSize
(
cbwm
)
;
if
(
computedSize
.
ISize
(
cbwm
)
>
maxSize
.
ISize
(
cbwm
)
)
{
computedSize
.
ISize
(
cbwm
)
=
maxSize
.
ISize
(
cbwm
)
;
}
if
(
computedSize
.
ISize
(
cbwm
)
<
minSize
.
ISize
(
cbwm
)
)
{
computedSize
.
ISize
(
cbwm
)
=
minSize
.
ISize
(
cbwm
)
;
}
}
}
nscoord
availMarginSpace
=
aCBSize
.
ISize
(
cbwm
)
-
offsets
.
IStartEnd
(
cbwm
)
-
margin
.
IStartEnd
(
cbwm
)
-
borderPadding
.
IStartEnd
(
cbwm
)
-
computedSize
.
ISize
(
cbwm
)
;
marginIStartIsAuto
=
eStyleUnit_Auto
=
=
mStyleMargin
-
>
mMargin
.
GetIStartUnit
(
cbwm
)
;
marginIEndIsAuto
=
eStyleUnit_Auto
=
=
mStyleMargin
-
>
mMargin
.
GetIEndUnit
(
cbwm
)
;
if
(
marginIStartIsAuto
)
{
if
(
marginIEndIsAuto
)
{
if
(
availMarginSpace
<
0
)
{
margin
.
IEnd
(
cbwm
)
=
availMarginSpace
;
}
else
{
margin
.
IStart
(
cbwm
)
=
availMarginSpace
/
2
;
margin
.
IEnd
(
cbwm
)
=
availMarginSpace
-
margin
.
IStart
(
cbwm
)
;
}
}
else
{
margin
.
IStart
(
cbwm
)
=
availMarginSpace
;
}
}
else
{
if
(
marginIEndIsAuto
)
{
margin
.
IEnd
(
cbwm
)
=
availMarginSpace
;
}
else
{
offsets
.
IEnd
(
cbwm
)
+
=
availMarginSpace
;
}
}
}
bool
bSizeIsAuto
=
mStylePosition
-
>
BSize
(
cbwm
)
.
IsAutoOrEnum
(
)
;
if
(
bStartIsAuto
)
{
if
(
bSizeIsAuto
)
{
offsets
.
BStart
(
cbwm
)
=
NS_AUTOOFFSET
;
}
else
{
offsets
.
BStart
(
cbwm
)
=
cbSize
.
BSize
(
cbwm
)
-
margin
.
BStartEnd
(
cbwm
)
-
borderPadding
.
BStartEnd
(
cbwm
)
-
computedSize
.
BSize
(
cbwm
)
-
offsets
.
BEnd
(
cbwm
)
;
}
}
else
if
(
bEndIsAuto
)
{
if
(
bSizeIsAuto
)
{
offsets
.
BEnd
(
cbwm
)
=
NS_AUTOOFFSET
;
}
else
{
offsets
.
BEnd
(
cbwm
)
=
cbSize
.
BSize
(
cbwm
)
-
margin
.
BStartEnd
(
cbwm
)
-
borderPadding
.
BStartEnd
(
cbwm
)
-
computedSize
.
BSize
(
cbwm
)
-
offsets
.
BStart
(
cbwm
)
;
}
}
else
{
nscoord
autoBSize
=
cbSize
.
BSize
(
cbwm
)
-
margin
.
BStartEnd
(
cbwm
)
-
borderPadding
.
BStartEnd
(
cbwm
)
-
offsets
.
BStartEnd
(
cbwm
)
;
if
(
autoBSize
<
0
)
{
autoBSize
=
0
;
}
if
(
computedSize
.
BSize
(
cbwm
)
=
=
NS_UNCONSTRAINEDSIZE
)
{
computedSize
.
BSize
(
cbwm
)
=
autoBSize
;
LogicalSize
maxSize
=
ComputedMaxSize
(
cbwm
)
;
LogicalSize
minSize
=
ComputedMinSize
(
cbwm
)
;
if
(
computedSize
.
BSize
(
cbwm
)
>
maxSize
.
BSize
(
cbwm
)
)
{
computedSize
.
BSize
(
cbwm
)
=
maxSize
.
BSize
(
cbwm
)
;
}
if
(
computedSize
.
BSize
(
cbwm
)
<
minSize
.
BSize
(
cbwm
)
)
{
computedSize
.
BSize
(
cbwm
)
=
minSize
.
BSize
(
cbwm
)
;
}
}
nscoord
availMarginSpace
=
autoBSize
-
computedSize
.
BSize
(
cbwm
)
;
marginBStartIsAuto
=
eStyleUnit_Auto
=
=
mStyleMargin
-
>
mMargin
.
GetBStartUnit
(
cbwm
)
;
marginBEndIsAuto
=
eStyleUnit_Auto
=
=
mStyleMargin
-
>
mMargin
.
GetBEndUnit
(
cbwm
)
;
if
(
marginBStartIsAuto
)
{
if
(
marginBEndIsAuto
)
{
margin
.
BStart
(
cbwm
)
=
availMarginSpace
/
2
;
margin
.
BEnd
(
cbwm
)
=
availMarginSpace
-
margin
.
BStart
(
cbwm
)
;
}
else
{
margin
.
BStart
(
cbwm
)
=
availMarginSpace
;
}
}
else
{
if
(
marginBEndIsAuto
)
{
margin
.
BEnd
(
cbwm
)
=
availMarginSpace
;
}
else
{
offsets
.
BEnd
(
cbwm
)
+
=
availMarginSpace
;
}
}
}
ComputedBSize
(
)
=
computedSize
.
ConvertTo
(
wm
cbwm
)
.
BSize
(
wm
)
;
ComputedISize
(
)
=
computedSize
.
ConvertTo
(
wm
cbwm
)
.
ISize
(
wm
)
;
SetComputedLogicalOffsets
(
offsets
.
ConvertTo
(
wm
cbwm
)
)
;
LogicalMargin
marginInOurWM
=
margin
.
ConvertTo
(
wm
cbwm
)
;
SetComputedLogicalMargin
(
marginInOurWM
)
;
if
(
marginIStartIsAuto
|
|
marginIEndIsAuto
|
|
marginBStartIsAuto
|
|
marginBEndIsAuto
)
{
nsMargin
*
propValue
=
mFrame
-
>
GetProperty
(
nsIFrame
:
:
UsedMarginProperty
(
)
)
;
MOZ_ASSERT
(
propValue
"
UsedMarginProperty
should
have
been
created
"
"
by
InitOffsets
.
"
)
;
*
propValue
=
marginInOurWM
.
GetPhysicalMargin
(
wm
)
;
}
}
static
nscoord
GetBlockMarginBorderPadding
(
const
ReflowInput
*
aReflowInput
)
{
nscoord
result
=
0
;
if
(
!
aReflowInput
)
return
result
;
nsMargin
margin
=
aReflowInput
-
>
ComputedPhysicalMargin
(
)
;
if
(
NS_AUTOMARGIN
=
=
margin
.
top
)
margin
.
top
=
0
;
if
(
NS_AUTOMARGIN
=
=
margin
.
bottom
)
margin
.
bottom
=
0
;
result
+
=
margin
.
top
+
margin
.
bottom
;
result
+
=
aReflowInput
-
>
ComputedPhysicalBorderPadding
(
)
.
top
+
aReflowInput
-
>
ComputedPhysicalBorderPadding
(
)
.
bottom
;
return
result
;
}
static
nscoord
CalcQuirkContainingBlockHeight
(
const
ReflowInput
*
aCBReflowInput
)
{
const
ReflowInput
*
firstAncestorRI
=
nullptr
;
const
ReflowInput
*
secondAncestorRI
=
nullptr
;
nscoord
result
=
NS_AUTOHEIGHT
;
const
ReflowInput
*
ri
=
aCBReflowInput
;
for
(
;
ri
;
ri
=
ri
-
>
mParentReflowInput
)
{
LayoutFrameType
frameType
=
ri
-
>
mFrame
-
>
Type
(
)
;
if
(
LayoutFrameType
:
:
Block
=
=
frameType
|
|
#
ifdef
MOZ_XUL
LayoutFrameType
:
:
XULLabel
=
=
frameType
|
|
#
endif
LayoutFrameType
:
:
Scroll
=
=
frameType
)
{
secondAncestorRI
=
firstAncestorRI
;
firstAncestorRI
=
ri
;
if
(
NS_AUTOHEIGHT
=
=
ri
-
>
ComputedHeight
(
)
)
{
if
(
ri
-
>
mFrame
-
>
IsAbsolutelyPositioned
(
ri
-
>
mStyleDisplay
)
)
{
break
;
}
else
{
continue
;
}
}
}
else
if
(
LayoutFrameType
:
:
Canvas
=
=
frameType
)
{
}
else
if
(
LayoutFrameType
:
:
PageContent
=
=
frameType
)
{
nsIFrame
*
prevInFlow
=
ri
-
>
mFrame
-
>
GetPrevInFlow
(
)
;
if
(
prevInFlow
)
break
;
}
else
{
break
;
}
result
=
(
LayoutFrameType
:
:
PageContent
=
=
frameType
)
?
ri
-
>
AvailableHeight
(
)
:
ri
-
>
ComputedHeight
(
)
;
if
(
NS_AUTOHEIGHT
=
=
result
)
return
result
;
if
(
(
LayoutFrameType
:
:
Canvas
=
=
frameType
)
|
|
(
LayoutFrameType
:
:
PageContent
=
=
frameType
)
)
{
result
-
=
GetBlockMarginBorderPadding
(
firstAncestorRI
)
;
result
-
=
GetBlockMarginBorderPadding
(
secondAncestorRI
)
;
#
ifdef
DEBUG
if
(
firstAncestorRI
)
{
nsIContent
*
frameContent
=
firstAncestorRI
-
>
mFrame
-
>
GetContent
(
)
;
if
(
frameContent
)
{
NS_ASSERTION
(
frameContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
html
)
"
First
ancestor
is
not
HTML
"
)
;
}
}
if
(
secondAncestorRI
)
{
nsIContent
*
frameContent
=
secondAncestorRI
-
>
mFrame
-
>
GetContent
(
)
;
if
(
frameContent
)
{
NS_ASSERTION
(
frameContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
"
Second
ancestor
is
not
BODY
"
)
;
}
}
#
endif
}
else
if
(
LayoutFrameType
:
:
Block
=
=
frameType
&
&
ri
-
>
mParentReflowInput
&
&
ri
-
>
mParentReflowInput
-
>
mFrame
-
>
IsCanvasFrame
(
)
)
{
result
-
=
GetBlockMarginBorderPadding
(
secondAncestorRI
)
;
}
break
;
}
return
std
:
:
max
(
result
0
)
;
}
LogicalSize
ReflowInput
:
:
ComputeContainingBlockRectangle
(
nsPresContext
*
aPresContext
const
ReflowInput
*
aContainingBlockRI
)
const
{
LogicalSize
cbSize
=
aContainingBlockRI
-
>
ComputedSize
(
)
;
WritingMode
wm
=
aContainingBlockRI
-
>
GetWritingMode
(
)
;
if
(
NS_FRAME_GET_TYPE
(
mFrameType
)
=
=
NS_CSS_FRAME_TYPE_ABSOLUTE
|
|
(
mFrame
-
>
IsTableFrame
(
)
&
&
mFrame
-
>
IsAbsolutelyPositioned
(
mStyleDisplay
)
&
&
(
mFrame
-
>
GetParent
(
)
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
)
)
{
if
(
NS_FRAME_GET_TYPE
(
aContainingBlockRI
-
>
mFrameType
)
=
=
NS_CSS_FRAME_TYPE_INLINE
)
{
LogicalMargin
computedBorder
=
aContainingBlockRI
-
>
ComputedLogicalBorderPadding
(
)
-
aContainingBlockRI
-
>
ComputedLogicalPadding
(
)
;
cbSize
.
ISize
(
wm
)
=
aContainingBlockRI
-
>
mFrame
-
>
ISize
(
wm
)
-
computedBorder
.
IStartEnd
(
wm
)
;
NS_ASSERTION
(
cbSize
.
ISize
(
wm
)
>
=
0
"
Negative
containing
block
isize
!
"
)
;
cbSize
.
BSize
(
wm
)
=
aContainingBlockRI
-
>
mFrame
-
>
BSize
(
wm
)
-
computedBorder
.
BStartEnd
(
wm
)
;
NS_ASSERTION
(
cbSize
.
BSize
(
wm
)
>
=
0
"
Negative
containing
block
bsize
!
"
)
;
}
else
{
cbSize
.
ISize
(
wm
)
+
=
aContainingBlockRI
-
>
ComputedLogicalPadding
(
)
.
IStartEnd
(
wm
)
;
cbSize
.
BSize
(
wm
)
+
=
aContainingBlockRI
-
>
ComputedLogicalPadding
(
)
.
BStartEnd
(
wm
)
;
}
}
else
{
if
(
!
wm
.
IsVertical
(
)
&
&
NS_AUTOHEIGHT
=
=
cbSize
.
BSize
(
wm
)
)
{
if
(
eCompatibility_NavQuirks
=
=
aPresContext
-
>
CompatibilityMode
(
)
&
&
(
mStylePosition
-
>
mHeight
.
GetUnit
(
)
=
=
eStyleUnit_Percent
|
|
(
mFrame
-
>
IsTableWrapperFrame
(
)
&
&
mFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
-
>
StylePosition
(
)
-
>
mHeight
.
GetUnit
(
)
=
=
eStyleUnit_Percent
)
)
)
{
cbSize
.
BSize
(
wm
)
=
CalcQuirkContainingBlockHeight
(
aContainingBlockRI
)
;
}
}
}
return
cbSize
.
ConvertTo
(
GetWritingMode
(
)
wm
)
;
}
static
eNormalLineHeightControl
GetNormalLineHeightCalcControl
(
void
)
{
if
(
sNormalLineHeightControl
=
=
eUninitialized
)
{
int32_t
val
=
Preferences
:
:
GetInt
(
"
browser
.
display
.
normal_lineheight_calc_control
"
eNoExternalLeading
)
;
sNormalLineHeightControl
=
static_cast
<
eNormalLineHeightControl
>
(
val
)
;
}
return
sNormalLineHeightControl
;
}
static
inline
bool
IsSideCaption
(
nsIFrame
*
aFrame
const
nsStyleDisplay
*
aStyleDisplay
WritingMode
aWM
)
{
if
(
aStyleDisplay
-
>
mDisplay
!
=
StyleDisplay
:
:
TableCaption
)
{
return
false
;
}
uint8_t
captionSide
=
aFrame
-
>
StyleTableBorder
(
)
-
>
mCaptionSide
;
return
captionSide
=
=
NS_STYLE_CAPTION_SIDE_LEFT
|
|
captionSide
=
=
NS_STYLE_CAPTION_SIDE_RIGHT
;
}
void
ReflowInput
:
:
InitConstraints
(
nsPresContext
*
aPresContext
const
LogicalSize
&
aContainingBlockSize
const
nsMargin
*
aBorder
const
nsMargin
*
aPadding
LayoutFrameType
aFrameType
)
{
WritingMode
wm
=
GetWritingMode
(
)
;
DISPLAY_INIT_CONSTRAINTS
(
mFrame
this
aContainingBlockSize
.
ISize
(
wm
)
aContainingBlockSize
.
BSize
(
wm
)
aBorder
aPadding
)
;
if
(
nullptr
=
=
mParentReflowInput
|
|
mFlags
.
mDummyParentReflowInput
)
{
InitOffsets
(
wm
aContainingBlockSize
.
ISize
(
wm
)
aFrameType
mFlags
aBorder
aPadding
mStyleDisplay
)
;
ComputedPhysicalMargin
(
)
.
SizeTo
(
0
0
0
0
)
;
ComputedPhysicalOffsets
(
)
.
SizeTo
(
0
0
0
0
)
;
ComputedISize
(
)
=
AvailableISize
(
)
-
ComputedLogicalBorderPadding
(
)
.
IStartEnd
(
wm
)
;
if
(
ComputedISize
(
)
<
0
)
{
ComputedISize
(
)
=
0
;
}
if
(
AvailableBSize
(
)
!
=
NS_UNCONSTRAINEDSIZE
)
{
ComputedBSize
(
)
=
AvailableBSize
(
)
-
ComputedLogicalBorderPadding
(
)
.
BStartEnd
(
wm
)
;
if
(
ComputedBSize
(
)
<
0
)
{
ComputedBSize
(
)
=
0
;
}
}
else
{
ComputedBSize
(
)
=
NS_UNCONSTRAINEDSIZE
;
}
ComputedMinWidth
(
)
=
ComputedMinHeight
(
)
=
0
;
ComputedMaxWidth
(
)
=
ComputedMaxHeight
(
)
=
NS_UNCONSTRAINEDSIZE
;
}
else
{
const
ReflowInput
*
cbri
=
mCBReflowInput
;
MOZ_ASSERT
(
cbri
"
no
containing
block
"
)
;
MOZ_ASSERT
(
mFrame
-
>
GetParent
(
)
)
;
LogicalSize
cbSize
=
(
aContainingBlockSize
=
=
LogicalSize
(
wm
-
1
-
1
)
)
?
ComputeContainingBlockRectangle
(
aPresContext
cbri
)
:
aContainingBlockSize
;
if
(
NS_AUTOHEIGHT
=
=
cbSize
.
BSize
(
wm
)
)
{
if
(
cbri
-
>
mParentReflowInput
)
{
if
(
IsTableCell
(
cbri
-
>
mFrame
-
>
Type
(
)
)
)
{
cbSize
.
BSize
(
wm
)
=
cbri
-
>
ComputedSize
(
wm
)
.
BSize
(
wm
)
;
}
}
}
WritingMode
cbwm
=
cbri
-
>
GetWritingMode
(
)
;
InitOffsets
(
cbwm
cbSize
.
ConvertTo
(
cbwm
wm
)
.
ISize
(
cbwm
)
aFrameType
mFlags
aBorder
aPadding
mStyleDisplay
)
;
const
nsStyleCoord
&
blockSize
=
mStylePosition
-
>
BSize
(
wm
)
;
nsStyleUnit
blockSizeUnit
=
blockSize
.
IsAutoOrEnum
(
)
?
eStyleUnit_Auto
:
blockSize
.
GetUnit
(
)
;
if
(
blockSize
.
HasPercent
(
)
)
{
if
(
NS_AUTOHEIGHT
=
=
cbSize
.
BSize
(
wm
)
)
{
if
(
NS_FRAME_REPLACED
(
NS_CSS_FRAME_TYPE_INLINE
)
=
=
mFrameType
|
|
NS_FRAME_REPLACED_CONTAINS_BLOCK
(
NS_CSS_FRAME_TYPE_INLINE
)
=
=
mFrameType
)
{
NS_ASSERTION
(
nullptr
!
=
cbri
"
no
containing
block
"
)
;
if
(
!
wm
.
IsVertical
(
)
&
&
eCompatibility_NavQuirks
=
=
aPresContext
-
>
CompatibilityMode
(
)
)
{
if
(
!
IsTableCell
(
cbri
-
>
mFrame
-
>
Type
(
)
)
)
{
cbSize
.
BSize
(
wm
)
=
CalcQuirkContainingBlockHeight
(
cbri
)
;
if
(
cbSize
.
BSize
(
wm
)
=
=
NS_AUTOHEIGHT
)
{
blockSizeUnit
=
eStyleUnit_Auto
;
}
}
else
{
blockSizeUnit
=
eStyleUnit_Auto
;
}
}
else
{
nscoord
computedBSize
=
cbri
-
>
ComputedSize
(
wm
)
.
BSize
(
wm
)
;
if
(
NS_AUTOHEIGHT
!
=
computedBSize
)
{
cbSize
.
BSize
(
wm
)
=
computedBSize
;
}
else
{
blockSizeUnit
=
eStyleUnit_Auto
;
}
}
}
else
{
blockSizeUnit
=
eStyleUnit_Auto
;
}
}
}
if
(
mStyleDisplay
-
>
IsRelativelyPositioned
(
mFrame
)
&
&
NS_STYLE_POSITION_RELATIVE
=
=
mStyleDisplay
-
>
mPosition
)
{
ComputeRelativeOffsets
(
cbwm
mFrame
cbSize
.
ConvertTo
(
cbwm
wm
)
ComputedPhysicalOffsets
(
)
)
;
}
else
{
ComputedPhysicalOffsets
(
)
.
SizeTo
(
0
0
0
0
)
;
}
ComputeMinMaxValues
(
cbSize
)
;
if
(
NS_CSS_FRAME_TYPE_INTERNAL_TABLE
=
=
mFrameType
)
{
bool
rowOrRowGroup
=
false
;
const
nsStyleCoord
&
inlineSize
=
mStylePosition
-
>
ISize
(
wm
)
;
nsStyleUnit
inlineSizeUnit
=
inlineSize
.
GetUnit
(
)
;
if
(
(
StyleDisplay
:
:
TableRow
=
=
mStyleDisplay
-
>
mDisplay
)
|
|
(
StyleDisplay
:
:
TableRowGroup
=
=
mStyleDisplay
-
>
mDisplay
)
)
{
inlineSizeUnit
=
eStyleUnit_Auto
;
rowOrRowGroup
=
true
;
}
if
(
eStyleUnit_Auto
=
=
inlineSizeUnit
|
|
(
inlineSize
.
IsCalcUnit
(
)
&
&
inlineSize
.
CalcHasPercent
(
)
)
)
{
ComputedISize
(
)
=
AvailableISize
(
)
;
if
(
(
ComputedISize
(
)
!
=
NS_UNCONSTRAINEDSIZE
)
&
&
!
rowOrRowGroup
)
{
ComputedISize
(
)
-
=
ComputedLogicalBorderPadding
(
)
.
IStartEnd
(
wm
)
;
if
(
ComputedISize
(
)
<
0
)
ComputedISize
(
)
=
0
;
}
NS_ASSERTION
(
ComputedISize
(
)
>
=
0
"
Bogus
computed
isize
"
)
;
}
else
{
NS_ASSERTION
(
inlineSizeUnit
=
=
inlineSize
.
GetUnit
(
)
"
unexpected
inline
size
unit
change
"
)
;
ComputedISize
(
)
=
ComputeISizeValue
(
cbSize
.
ISize
(
wm
)
mStylePosition
-
>
mBoxSizing
inlineSize
)
;
}
if
(
(
StyleDisplay
:
:
TableColumn
=
=
mStyleDisplay
-
>
mDisplay
)
|
|
(
StyleDisplay
:
:
TableColumnGroup
=
=
mStyleDisplay
-
>
mDisplay
)
)
{
blockSizeUnit
=
eStyleUnit_Auto
;
}
if
(
eStyleUnit_Auto
=
=
blockSizeUnit
|
|
(
blockSize
.
IsCalcUnit
(
)
&
&
blockSize
.
CalcHasPercent
(
)
)
)
{
ComputedBSize
(
)
=
NS_AUTOHEIGHT
;
}
else
{
NS_ASSERTION
(
blockSizeUnit
=
=
blockSize
.
GetUnit
(
)
"
unexpected
block
size
unit
change
"
)
;
ComputedBSize
(
)
=
ComputeBSizeValue
(
cbSize
.
BSize
(
wm
)
mStylePosition
-
>
mBoxSizing
blockSize
)
;
}
ComputedMinWidth
(
)
=
ComputedMinHeight
(
)
=
0
;
ComputedMaxWidth
(
)
=
ComputedMaxHeight
(
)
=
NS_UNCONSTRAINEDSIZE
;
}
else
if
(
NS_FRAME_GET_TYPE
(
mFrameType
)
=
=
NS_CSS_FRAME_TYPE_ABSOLUTE
)
{
InitAbsoluteConstraints
(
aPresContext
cbri
cbSize
.
ConvertTo
(
cbri
-
>
GetWritingMode
(
)
wm
)
aFrameType
)
;
}
else
{
AutoMaybeDisableFontInflation
an
(
mFrame
)
;
bool
isBlock
=
NS_CSS_FRAME_TYPE_BLOCK
=
=
NS_FRAME_GET_TYPE
(
mFrameType
)
;
typedef
nsIFrame
:
:
ComputeSizeFlags
ComputeSizeFlags
;
ComputeSizeFlags
computeSizeFlags
=
isBlock
?
ComputeSizeFlags
:
:
eDefault
:
ComputeSizeFlags
:
:
eShrinkWrap
;
if
(
mFlags
.
mIClampMarginBoxMinSize
)
{
computeSizeFlags
=
ComputeSizeFlags
(
computeSizeFlags
|
ComputeSizeFlags
:
:
eIClampMarginBoxMinSize
)
;
}
if
(
mFlags
.
mBClampMarginBoxMinSize
)
{
computeSizeFlags
=
ComputeSizeFlags
(
computeSizeFlags
|
ComputeSizeFlags
:
:
eBClampMarginBoxMinSize
)
;
}
if
(
mFlags
.
mApplyAutoMinSize
)
{
computeSizeFlags
=
ComputeSizeFlags
(
computeSizeFlags
|
ComputeSizeFlags
:
:
eIApplyAutoMinSize
)
;
}
if
(
mFlags
.
mShrinkWrap
)
{
computeSizeFlags
=
ComputeSizeFlags
(
computeSizeFlags
|
ComputeSizeFlags
:
:
eShrinkWrap
)
;
}
if
(
mFlags
.
mUseAutoBSize
)
{
computeSizeFlags
=
ComputeSizeFlags
(
computeSizeFlags
|
ComputeSizeFlags
:
:
eUseAutoBSize
)
;
}
nsIFrame
*
alignCB
=
mFrame
-
>
GetParent
(
)
;
if
(
alignCB
-
>
IsTableWrapperFrame
(
)
&
&
alignCB
-
>
GetParent
(
)
)
{
if
(
alignCB
-
>
GetParent
(
)
-
>
IsGridContainerFrame
(
)
)
{
alignCB
=
alignCB
-
>
GetParent
(
)
;
}
}
if
(
alignCB
-
>
IsGridContainerFrame
(
)
)
{
auto
inlineAxisAlignment
=
wm
.
IsOrthogonalTo
(
cbwm
)
?
mStylePosition
-
>
UsedAlignSelf
(
alignCB
-
>
Style
(
)
)
:
mStylePosition
-
>
UsedJustifySelf
(
alignCB
-
>
Style
(
)
)
;
if
(
(
inlineAxisAlignment
!
=
NS_STYLE_ALIGN_STRETCH
&
&
inlineAxisAlignment
!
=
NS_STYLE_ALIGN_NORMAL
)
|
|
mStyleMargin
-
>
mMargin
.
GetIStartUnit
(
wm
)
=
=
eStyleUnit_Auto
|
|
mStyleMargin
-
>
mMargin
.
GetIEndUnit
(
wm
)
=
=
eStyleUnit_Auto
)
{
computeSizeFlags
=
ComputeSizeFlags
(
computeSizeFlags
|
ComputeSizeFlags
:
:
eShrinkWrap
)
;
}
}
else
{
if
(
isBlock
&
&
(
(
aFrameType
=
=
LayoutFrameType
:
:
Legend
&
&
mFrame
-
>
Style
(
)
-
>
GetPseudo
(
)
!
=
nsCSSAnonBoxes
:
:
scrolledContent
(
)
)
|
|
(
aFrameType
=
=
LayoutFrameType
:
:
Scroll
&
&
mFrame
-
>
GetContentInsertionFrame
(
)
-
>
IsLegendFrame
(
)
)
|
|
(
mCBReflowInput
&
&
mCBReflowInput
-
>
GetWritingMode
(
)
.
IsOrthogonalTo
(
mWritingMode
)
)
)
)
{
computeSizeFlags
=
ComputeSizeFlags
(
computeSizeFlags
|
ComputeSizeFlags
:
:
eShrinkWrap
)
;
}
if
(
alignCB
-
>
IsFlexContainerFrame
(
)
)
{
computeSizeFlags
=
ComputeSizeFlags
(
computeSizeFlags
|
ComputeSizeFlags
:
:
eShrinkWrap
)
;
if
(
mFlags
.
mIsFlexContainerMeasuringBSize
)
{
computeSizeFlags
=
ComputeSizeFlags
(
computeSizeFlags
|
ComputeSizeFlags
:
:
eUseAutoBSize
)
;
}
}
else
{
MOZ_ASSERT
(
!
mFlags
.
mIsFlexContainerMeasuringBSize
"
We
'
re
not
in
a
flex
container
so
the
flag
"
"
'
mIsFlexContainerMeasuringBSize
'
shouldn
'
t
be
set
"
)
;
}
}
if
(
cbSize
.
ISize
(
wm
)
=
=
NS_UNCONSTRAINEDSIZE
)
{
cbSize
.
ISize
(
wm
)
=
AvailableISize
(
)
;
}
LogicalSize
size
=
mFrame
-
>
ComputeSize
(
mRenderingContext
wm
cbSize
AvailableISize
(
)
ComputedLogicalMargin
(
)
.
Size
(
wm
)
ComputedLogicalBorderPadding
(
)
.
Size
(
wm
)
-
ComputedLogicalPadding
(
)
.
Size
(
wm
)
ComputedLogicalPadding
(
)
.
Size
(
wm
)
computeSizeFlags
)
;
ComputedISize
(
)
=
size
.
ISize
(
wm
)
;
ComputedBSize
(
)
=
size
.
BSize
(
wm
)
;
NS_ASSERTION
(
ComputedISize
(
)
>
=
0
"
Bogus
inline
-
size
"
)
;
NS_ASSERTION
(
ComputedBSize
(
)
=
=
NS_UNCONSTRAINEDSIZE
|
|
ComputedBSize
(
)
>
=
0
"
Bogus
block
-
size
"
)
;
if
(
isBlock
&
&
!
IsSideCaption
(
mFrame
mStyleDisplay
cbwm
)
&
&
mStyleDisplay
-
>
mDisplay
!
=
StyleDisplay
:
:
InlineTable
&
&
!
alignCB
-
>
IsFlexOrGridContainer
(
)
)
{
CalculateBlockSideMargins
(
aFrameType
)
;
}
}
}
mContainingBlockSize
=
aContainingBlockSize
;
}
static
void
UpdateProp
(
nsIFrame
*
aFrame
const
FramePropertyDescriptor
<
nsMargin
>
*
aProperty
bool
aNeeded
const
nsMargin
&
aNewValue
)
{
if
(
aNeeded
)
{
nsMargin
*
propValue
=
aFrame
-
>
GetProperty
(
aProperty
)
;
if
(
propValue
)
{
*
propValue
=
aNewValue
;
}
else
{
aFrame
-
>
AddProperty
(
aProperty
new
nsMargin
(
aNewValue
)
)
;
}
}
else
{
aFrame
-
>
DeleteProperty
(
aProperty
)
;
}
}
void
SizeComputationInput
:
:
InitOffsets
(
WritingMode
aWM
nscoord
aPercentBasis
LayoutFrameType
aFrameType
ReflowInputFlags
aFlags
const
nsMargin
*
aBorder
const
nsMargin
*
aPadding
const
nsStyleDisplay
*
aDisplay
)
{
DISPLAY_INIT_OFFSETS
(
mFrame
this
aPercentBasis
aWM
aBorder
aPadding
)
;
nsPresContext
*
presContext
=
mFrame
-
>
PresContext
(
)
;
mFrame
-
>
DeleteProperty
(
nsIFrame
:
:
UsedBorderProperty
(
)
)
;
bool
needMarginProp
=
ComputeMargin
(
aWM
aPercentBasis
)
;
:
:
UpdateProp
(
mFrame
nsIFrame
:
:
UsedMarginProperty
(
)
needMarginProp
ComputedPhysicalMargin
(
)
)
;
const
nsStyleDisplay
*
disp
=
mFrame
-
>
StyleDisplayWithOptionalParam
(
aDisplay
)
;
bool
isThemed
=
mFrame
-
>
IsThemed
(
disp
)
;
bool
needPaddingProp
;
LayoutDeviceIntMargin
widgetPadding
;
if
(
isThemed
&
&
presContext
-
>
GetTheme
(
)
-
>
GetWidgetPadding
(
presContext
-
>
DeviceContext
(
)
mFrame
disp
-
>
mAppearance
&
widgetPadding
)
)
{
ComputedPhysicalPadding
(
)
=
LayoutDevicePixel
:
:
ToAppUnits
(
widgetPadding
presContext
-
>
AppUnitsPerDevPixel
(
)
)
;
needPaddingProp
=
false
;
}
else
if
(
nsSVGUtils
:
:
IsInSVGTextSubtree
(
mFrame
)
)
{
ComputedPhysicalPadding
(
)
.
SizeTo
(
0
0
0
0
)
;
needPaddingProp
=
false
;
}
else
if
(
aPadding
)
{
ComputedPhysicalPadding
(
)
=
*
aPadding
;
needPaddingProp
=
mFrame
-
>
StylePadding
(
)
-
>
IsWidthDependent
(
)
|
|
mFrame
-
>
HasAnyStateBits
(
NS_FRAME_REFLOW_ROOT
|
NS_FRAME_DYNAMIC_REFLOW_ROOT
)
;
}
else
{
needPaddingProp
=
ComputePadding
(
aWM
aPercentBasis
aFrameType
)
;
}
typedef
const
FramePropertyDescriptor
<
SmallValueHolder
<
nscoord
>
>
*
Prop
;
auto
ApplyBaselinePadding
=
[
this
&
needPaddingProp
]
(
LogicalAxis
aAxis
Prop
aProp
)
{
bool
found
;
nscoord
val
=
mFrame
-
>
GetProperty
(
aProp
&
found
)
;
if
(
found
)
{
NS_ASSERTION
(
val
!
=
nscoord
(
0
)
"
zero
in
this
property
is
useless
"
)
;
WritingMode
wm
=
GetWritingMode
(
)
;
LogicalSide
side
;
if
(
val
>
0
)
{
side
=
MakeLogicalSide
(
aAxis
eLogicalEdgeStart
)
;
}
else
{
side
=
MakeLogicalSide
(
aAxis
eLogicalEdgeEnd
)
;
val
=
-
val
;
}
mComputedPadding
.
Side
(
wm
.
PhysicalSide
(
side
)
)
+
=
val
;
needPaddingProp
=
true
;
}
}
;
if
(
!
aFlags
.
mUseAutoBSize
)
{
ApplyBaselinePadding
(
eLogicalAxisBlock
nsIFrame
:
:
BBaselinePadProperty
(
)
)
;
}
if
(
!
aFlags
.
mShrinkWrap
)
{
ApplyBaselinePadding
(
eLogicalAxisInline
nsIFrame
:
:
IBaselinePadProperty
(
)
)
;
}
if
(
isThemed
)
{
LayoutDeviceIntMargin
border
=
presContext
-
>
GetTheme
(
)
-
>
GetWidgetBorder
(
presContext
-
>
DeviceContext
(
)
mFrame
disp
-
>
mAppearance
)
;
ComputedPhysicalBorderPadding
(
)
=
LayoutDevicePixel
:
:
ToAppUnits
(
border
presContext
-
>
AppUnitsPerDevPixel
(
)
)
;
}
else
if
(
nsSVGUtils
:
:
IsInSVGTextSubtree
(
mFrame
)
)
{
ComputedPhysicalBorderPadding
(
)
.
SizeTo
(
0
0
0
0
)
;
}
else
if
(
aBorder
)
{
ComputedPhysicalBorderPadding
(
)
=
*
aBorder
;
}
else
{
ComputedPhysicalBorderPadding
(
)
=
mFrame
-
>
StyleBorder
(
)
-
>
GetComputedBorder
(
)
;
}
ComputedPhysicalBorderPadding
(
)
+
=
ComputedPhysicalPadding
(
)
;
if
(
aFrameType
=
=
LayoutFrameType
:
:
Table
)
{
nsTableFrame
*
tableFrame
=
static_cast
<
nsTableFrame
*
>
(
mFrame
)
;
if
(
tableFrame
-
>
IsBorderCollapse
(
)
)
{
ComputedPhysicalPadding
(
)
.
SizeTo
(
0
0
0
0
)
;
SetComputedLogicalBorderPadding
(
tableFrame
-
>
GetIncludedOuterBCBorder
(
mWritingMode
)
)
;
}
ComputedPhysicalMargin
(
)
.
SizeTo
(
0
0
0
0
)
;
}
else
if
(
aFrameType
=
=
LayoutFrameType
:
:
Scrollbar
)
{
nsSize
size
(
mFrame
-
>
GetSize
(
)
)
;
if
(
size
.
width
=
=
0
|
|
size
.
height
=
=
0
)
{
ComputedPhysicalPadding
(
)
.
SizeTo
(
0
0
0
0
)
;
ComputedPhysicalBorderPadding
(
)
.
SizeTo
(
0
0
0
0
)
;
}
}
:
:
UpdateProp
(
mFrame
nsIFrame
:
:
UsedPaddingProperty
(
)
needPaddingProp
ComputedPhysicalPadding
(
)
)
;
}
void
ReflowInput
:
:
CalculateBlockSideMargins
(
LayoutFrameType
aFrameType
)
{
WritingMode
cbWM
=
mCBReflowInput
?
mCBReflowInput
-
>
GetWritingMode
(
)
:
GetWritingMode
(
)
;
nscoord
availISizeCBWM
=
AvailableSize
(
cbWM
)
.
ISize
(
cbWM
)
;
nscoord
computedISizeCBWM
=
ComputedSize
(
cbWM
)
.
ISize
(
cbWM
)
;
if
(
computedISizeCBWM
=
=
NS_UNCONSTRAINEDSIZE
)
{
computedISizeCBWM
=
availISizeCBWM
;
}
LAYOUT_WARN_IF_FALSE
(
NS_UNCONSTRAINEDSIZE
!
=
computedISizeCBWM
&
&
NS_UNCONSTRAINEDSIZE
!
=
availISizeCBWM
"
have
unconstrained
inline
-
size
;
this
should
only
"
"
result
from
very
large
sizes
not
attempts
at
"
"
intrinsic
inline
-
size
calculation
"
)
;
LogicalMargin
margin
=
ComputedLogicalMargin
(
)
.
ConvertTo
(
cbWM
mWritingMode
)
;
LogicalMargin
borderPadding
=
ComputedLogicalBorderPadding
(
)
.
ConvertTo
(
cbWM
mWritingMode
)
;
nscoord
sum
=
margin
.
IStartEnd
(
cbWM
)
+
borderPadding
.
IStartEnd
(
cbWM
)
+
computedISizeCBWM
;
if
(
sum
=
=
availISizeCBWM
)
{
return
;
}
nscoord
availMarginSpace
=
availISizeCBWM
-
sum
;
if
(
availMarginSpace
<
0
)
{
margin
.
IEnd
(
cbWM
)
+
=
availMarginSpace
;
SetComputedLogicalMargin
(
margin
.
ConvertTo
(
mWritingMode
cbWM
)
)
;
return
;
}
const
nsStyleSides
&
styleSides
=
mStyleMargin
-
>
mMargin
;
bool
isAutoStartMargin
=
eStyleUnit_Auto
=
=
styleSides
.
GetIStartUnit
(
cbWM
)
;
bool
isAutoEndMargin
=
eStyleUnit_Auto
=
=
styleSides
.
GetIEndUnit
(
cbWM
)
;
if
(
!
isAutoStartMargin
&
&
!
isAutoEndMargin
)
{
const
ReflowInput
*
pri
=
mParentReflowInput
;
if
(
aFrameType
=
=
LayoutFrameType
:
:
Table
)
{
NS_ASSERTION
(
pri
-
>
mFrame
-
>
IsTableWrapperFrame
(
)
"
table
not
inside
table
wrapper
"
)
;
pri
=
pri
-
>
mParentReflowInput
;
}
if
(
pri
&
&
(
pri
-
>
mStyleText
-
>
mTextAlign
=
=
NS_STYLE_TEXT_ALIGN_MOZ_LEFT
|
|
pri
-
>
mStyleText
-
>
mTextAlign
=
=
NS_STYLE_TEXT_ALIGN_MOZ_CENTER
|
|
pri
-
>
mStyleText
-
>
mTextAlign
=
=
NS_STYLE_TEXT_ALIGN_MOZ_RIGHT
)
)
{
if
(
pri
-
>
mWritingMode
.
IsBidiLTR
(
)
)
{
isAutoStartMargin
=
pri
-
>
mStyleText
-
>
mTextAlign
!
=
NS_STYLE_TEXT_ALIGN_MOZ_LEFT
;
isAutoEndMargin
=
pri
-
>
mStyleText
-
>
mTextAlign
!
=
NS_STYLE_TEXT_ALIGN_MOZ_RIGHT
;
}
else
{
isAutoStartMargin
=
pri
-
>
mStyleText
-
>
mTextAlign
!
=
NS_STYLE_TEXT_ALIGN_MOZ_RIGHT
;
isAutoEndMargin
=
pri
-
>
mStyleText
-
>
mTextAlign
!
=
NS_STYLE_TEXT_ALIGN_MOZ_LEFT
;
}
}
else
{
isAutoEndMargin
=
true
;
}
}
if
(
isAutoStartMargin
)
{
if
(
isAutoEndMargin
)
{
nscoord
forStart
=
availMarginSpace
/
2
;
margin
.
IStart
(
cbWM
)
+
=
forStart
;
margin
.
IEnd
(
cbWM
)
+
=
availMarginSpace
-
forStart
;
}
else
{
margin
.
IStart
(
cbWM
)
+
=
availMarginSpace
;
}
}
else
if
(
isAutoEndMargin
)
{
margin
.
IEnd
(
cbWM
)
+
=
availMarginSpace
;
}
LogicalMargin
marginInOurWM
=
margin
.
ConvertTo
(
mWritingMode
cbWM
)
;
SetComputedLogicalMargin
(
marginInOurWM
)
;
if
(
isAutoStartMargin
|
|
isAutoEndMargin
)
{
nsMargin
*
propValue
=
mFrame
-
>
GetProperty
(
nsIFrame
:
:
UsedMarginProperty
(
)
)
;
if
(
propValue
)
{
*
propValue
=
marginInOurWM
.
GetPhysicalMargin
(
mWritingMode
)
;
}
}
}
#
define
NORMAL_LINE_HEIGHT_FACTOR
1
.
2f
/
/
in
term
of
emHeight
static
nscoord
GetNormalLineHeight
(
nsFontMetrics
*
aFontMetrics
)
{
MOZ_ASSERT
(
nullptr
!
=
aFontMetrics
"
no
font
metrics
"
)
;
nscoord
normalLineHeight
;
nscoord
externalLeading
=
aFontMetrics
-
>
ExternalLeading
(
)
;
nscoord
internalLeading
=
aFontMetrics
-
>
InternalLeading
(
)
;
nscoord
emHeight
=
aFontMetrics
-
>
EmHeight
(
)
;
switch
(
GetNormalLineHeightCalcControl
(
)
)
{
case
eIncludeExternalLeading
:
normalLineHeight
=
emHeight
+
internalLeading
+
externalLeading
;
break
;
case
eCompensateLeading
:
if
(
!
internalLeading
&
&
!
externalLeading
)
normalLineHeight
=
NSToCoordRound
(
emHeight
*
NORMAL_LINE_HEIGHT_FACTOR
)
;
else
normalLineHeight
=
emHeight
+
internalLeading
+
externalLeading
;
break
;
default
:
normalLineHeight
=
emHeight
+
internalLeading
;
}
return
normalLineHeight
;
}
static
inline
nscoord
ComputeLineHeight
(
ComputedStyle
*
aComputedStyle
nsPresContext
*
aPresContext
nscoord
aBlockBSize
float
aFontSizeInflation
)
{
const
nsStyleCoord
&
lhCoord
=
aComputedStyle
-
>
StyleText
(
)
-
>
mLineHeight
;
if
(
lhCoord
.
GetUnit
(
)
=
=
eStyleUnit_Coord
)
{
nscoord
result
=
lhCoord
.
GetCoordValue
(
)
;
if
(
aFontSizeInflation
!
=
1
.
0f
)
{
result
=
NSToCoordRound
(
result
*
aFontSizeInflation
)
;
}
return
result
;
}
if
(
lhCoord
.
GetUnit
(
)
=
=
eStyleUnit_Factor
)
return
NSToCoordRound
(
lhCoord
.
GetFactorValue
(
)
*
aFontSizeInflation
*
aComputedStyle
-
>
StyleFont
(
)
-
>
mFont
.
size
)
;
NS_ASSERTION
(
lhCoord
.
GetUnit
(
)
=
=
eStyleUnit_Normal
|
|
lhCoord
.
GetUnit
(
)
=
=
eStyleUnit_Enumerated
"
bad
line
-
height
unit
"
)
;
if
(
lhCoord
.
GetUnit
(
)
=
=
eStyleUnit_Enumerated
)
{
NS_ASSERTION
(
lhCoord
.
GetIntValue
(
)
=
=
NS_STYLE_LINE_HEIGHT_BLOCK_HEIGHT
"
bad
line
-
height
value
"
)
;
if
(
aBlockBSize
!
=
NS_AUTOHEIGHT
)
{
return
aBlockBSize
;
}
}
RefPtr
<
nsFontMetrics
>
fm
=
nsLayoutUtils
:
:
GetFontMetricsForComputedStyle
(
aComputedStyle
aPresContext
aFontSizeInflation
)
;
return
GetNormalLineHeight
(
fm
)
;
}
nscoord
ReflowInput
:
:
CalcLineHeight
(
)
const
{
nscoord
blockBSize
=
nsLayoutUtils
:
:
IsNonWrapperBlock
(
mFrame
)
?
ComputedBSize
(
)
:
(
mCBReflowInput
?
mCBReflowInput
-
>
ComputedBSize
(
)
:
NS_AUTOHEIGHT
)
;
return
CalcLineHeight
(
mFrame
-
>
GetContent
(
)
mFrame
-
>
Style
(
)
mFrame
-
>
PresContext
(
)
blockBSize
nsLayoutUtils
:
:
FontSizeInflationFor
(
mFrame
)
)
;
}
nscoord
ReflowInput
:
:
CalcLineHeight
(
nsIContent
*
aContent
ComputedStyle
*
aComputedStyle
nsPresContext
*
aPresContext
nscoord
aBlockBSize
float
aFontSizeInflation
)
{
MOZ_ASSERT
(
aComputedStyle
"
Must
have
a
ComputedStyle
"
)
;
nscoord
lineHeight
=
ComputeLineHeight
(
aComputedStyle
aPresContext
aBlockBSize
aFontSizeInflation
)
;
NS_ASSERTION
(
lineHeight
>
=
0
"
ComputeLineHeight
screwed
up
"
)
;
HTMLInputElement
*
input
=
HTMLInputElement
:
:
FromNodeOrNull
(
aContent
)
;
if
(
input
&
&
input
-
>
IsSingleLineTextControl
(
)
)
{
nscoord
lineHeightOne
=
aFontSizeInflation
*
aComputedStyle
-
>
StyleFont
(
)
-
>
mFont
.
size
;
if
(
lineHeight
<
lineHeightOne
)
{
lineHeight
=
lineHeightOne
;
}
}
return
lineHeight
;
}
bool
SizeComputationInput
:
:
ComputeMargin
(
WritingMode
aWM
nscoord
aPercentBasis
)
{
if
(
nsSVGUtils
:
:
IsInSVGTextSubtree
(
mFrame
)
)
{
return
false
;
}
const
nsStyleMargin
*
styleMargin
=
mFrame
-
>
StyleMargin
(
)
;
bool
isCBDependent
=
!
styleMargin
-
>
GetMargin
(
ComputedPhysicalMargin
(
)
)
;
if
(
isCBDependent
)
{
LogicalMargin
m
(
aWM
)
;
m
.
IStart
(
aWM
)
=
nsLayoutUtils
:
:
ComputeCBDependentValue
(
aPercentBasis
styleMargin
-
>
mMargin
.
GetIStart
(
aWM
)
)
;
m
.
IEnd
(
aWM
)
=
nsLayoutUtils
:
:
ComputeCBDependentValue
(
aPercentBasis
styleMargin
-
>
mMargin
.
GetIEnd
(
aWM
)
)
;
m
.
BStart
(
aWM
)
=
nsLayoutUtils
:
:
ComputeCBDependentValue
(
aPercentBasis
styleMargin
-
>
mMargin
.
GetBStart
(
aWM
)
)
;
m
.
BEnd
(
aWM
)
=
nsLayoutUtils
:
:
ComputeCBDependentValue
(
aPercentBasis
styleMargin
-
>
mMargin
.
GetBEnd
(
aWM
)
)
;
SetComputedLogicalMargin
(
aWM
m
)
;
}
nscoord
marginAdjustment
=
FontSizeInflationListMarginAdjustment
(
mFrame
)
;
if
(
marginAdjustment
>
0
)
{
LogicalMargin
m
=
ComputedLogicalMargin
(
)
;
m
.
IStart
(
mWritingMode
)
+
=
marginAdjustment
;
SetComputedLogicalMargin
(
m
)
;
}
return
isCBDependent
;
}
bool
SizeComputationInput
:
:
ComputePadding
(
WritingMode
aWM
nscoord
aPercentBasis
LayoutFrameType
aFrameType
)
{
const
nsStylePadding
*
stylePadding
=
mFrame
-
>
StylePadding
(
)
;
bool
isCBDependent
=
!
stylePadding
-
>
GetPadding
(
ComputedPhysicalPadding
(
)
)
;
if
(
LayoutFrameType
:
:
TableRowGroup
=
=
aFrameType
|
|
LayoutFrameType
:
:
TableColGroup
=
=
aFrameType
|
|
LayoutFrameType
:
:
TableRow
=
=
aFrameType
|
|
LayoutFrameType
:
:
TableCol
=
=
aFrameType
)
{
ComputedPhysicalPadding
(
)
.
SizeTo
(
0
0
0
0
)
;
}
else
if
(
isCBDependent
)
{
LogicalMargin
p
(
aWM
)
;
p
.
IStart
(
aWM
)
=
std
:
:
max
(
0
nsLayoutUtils
:
:
ComputeCBDependentValue
(
aPercentBasis
stylePadding
-
>
mPadding
.
GetIStart
(
aWM
)
)
)
;
p
.
IEnd
(
aWM
)
=
std
:
:
max
(
0
nsLayoutUtils
:
:
ComputeCBDependentValue
(
aPercentBasis
stylePadding
-
>
mPadding
.
GetIEnd
(
aWM
)
)
)
;
p
.
BStart
(
aWM
)
=
std
:
:
max
(
0
nsLayoutUtils
:
:
ComputeCBDependentValue
(
aPercentBasis
stylePadding
-
>
mPadding
.
GetBStart
(
aWM
)
)
)
;
p
.
BEnd
(
aWM
)
=
std
:
:
max
(
0
nsLayoutUtils
:
:
ComputeCBDependentValue
(
aPercentBasis
stylePadding
-
>
mPadding
.
GetBEnd
(
aWM
)
)
)
;
SetComputedLogicalPadding
(
aWM
p
)
;
}
return
isCBDependent
;
}
void
ReflowInput
:
:
ComputeMinMaxValues
(
const
LogicalSize
&
aCBSize
)
{
WritingMode
wm
=
GetWritingMode
(
)
;
const
nsStyleCoord
&
minISize
=
mStylePosition
-
>
MinISize
(
wm
)
;
const
nsStyleCoord
&
maxISize
=
mStylePosition
-
>
MaxISize
(
wm
)
;
const
nsStyleCoord
&
minBSize
=
mStylePosition
-
>
MinBSize
(
wm
)
;
const
nsStyleCoord
&
maxBSize
=
mStylePosition
-
>
MaxBSize
(
wm
)
;
if
(
eStyleUnit_Auto
=
=
minISize
.
GetUnit
(
)
)
{
ComputedMinISize
(
)
=
0
;
}
else
{
ComputedMinISize
(
)
=
ComputeISizeValue
(
aCBSize
.
ISize
(
wm
)
mStylePosition
-
>
mBoxSizing
minISize
)
;
}
if
(
eStyleUnit_None
=
=
maxISize
.
GetUnit
(
)
)
{
ComputedMaxISize
(
)
=
NS_UNCONSTRAINEDSIZE
;
}
else
{
ComputedMaxISize
(
)
=
ComputeISizeValue
(
aCBSize
.
ISize
(
wm
)
mStylePosition
-
>
mBoxSizing
maxISize
)
;
}
if
(
ComputedMinISize
(
)
>
ComputedMaxISize
(
)
)
{
ComputedMaxISize
(
)
=
ComputedMinISize
(
)
;
}
const
nscoord
&
bPercentageBasis
=
aCBSize
.
BSize
(
wm
)
;
auto
BSizeBehavesAsInitialValue
=
[
&
]
(
const
nsStyleCoord
&
aBSize
)
{
return
nsLayoutUtils
:
:
IsAutoBSize
(
aBSize
bPercentageBasis
)
|
|
(
mFrameType
=
=
NS_CSS_FRAME_TYPE_INTERNAL_TABLE
&
&
aBSize
.
IsCalcUnit
(
)
&
&
aBSize
.
CalcHasPercent
(
)
)
|
|
mFlags
.
mIsFlexContainerMeasuringBSize
;
}
;
if
(
BSizeBehavesAsInitialValue
(
minBSize
)
)
{
ComputedMinBSize
(
)
=
0
;
}
else
{
ComputedMinBSize
(
)
=
ComputeBSizeValue
(
bPercentageBasis
mStylePosition
-
>
mBoxSizing
minBSize
)
;
}
if
(
BSizeBehavesAsInitialValue
(
maxBSize
)
)
{
ComputedMaxBSize
(
)
=
NS_UNCONSTRAINEDSIZE
;
}
else
{
ComputedMaxBSize
(
)
=
ComputeBSizeValue
(
bPercentageBasis
mStylePosition
-
>
mBoxSizing
maxBSize
)
;
}
if
(
ComputedMinBSize
(
)
>
ComputedMaxBSize
(
)
)
{
ComputedMaxBSize
(
)
=
ComputedMinBSize
(
)
;
}
}
bool
ReflowInput
:
:
IsFloating
(
)
const
{
return
mStyleDisplay
-
>
IsFloating
(
mFrame
)
;
}
mozilla
:
:
StyleDisplay
ReflowInput
:
:
GetDisplay
(
)
const
{
return
mStyleDisplay
-
>
GetDisplay
(
mFrame
)
;
}
