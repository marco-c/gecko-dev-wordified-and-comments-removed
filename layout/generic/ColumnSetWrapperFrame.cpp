#
include
"
ColumnSetWrapperFrame
.
h
"
#
include
"
mozilla
/
ColumnUtils
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIFrameInlines
.
h
"
using
namespace
mozilla
;
nsBlockFrame
*
NS_NewColumnSetWrapperFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
nsFrameState
aStateFlags
)
{
ColumnSetWrapperFrame
*
frame
=
new
(
aPresShell
)
ColumnSetWrapperFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
frame
-
>
AddStateBits
(
aStateFlags
)
;
return
frame
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
ColumnSetWrapperFrame
)
NS_QUERYFRAME_HEAD
(
ColumnSetWrapperFrame
)
NS_QUERYFRAME_ENTRY
(
ColumnSetWrapperFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsBlockFrame
)
ColumnSetWrapperFrame
:
:
ColumnSetWrapperFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
:
nsBlockFrame
(
aStyle
aPresContext
kClassID
)
{
}
void
ColumnSetWrapperFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
nsBlockFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
RemoveStateBits
(
NS_BLOCK_NEEDS_BIDI_RESOLUTION
)
;
}
nsContainerFrame
*
ColumnSetWrapperFrame
:
:
GetContentInsertionFrame
(
)
{
nsIFrame
*
columnSet
=
PrincipalChildList
(
)
.
OnlyChild
(
)
;
if
(
columnSet
)
{
MOZ_ASSERT
(
columnSet
-
>
IsColumnSetFrame
(
)
)
;
return
columnSet
-
>
GetContentInsertionFrame
(
)
;
}
return
this
;
}
void
ColumnSetWrapperFrame
:
:
AppendDirectlyOwnedAnonBoxes
(
nsTArray
<
OwnedAnonBox
>
&
aResult
)
{
MOZ_ASSERT
(
!
GetPrevContinuation
(
)
"
Who
set
NS_FRAME_OWNS_ANON_BOXES
on
our
continuations
?
"
)
;
auto
FindFirstChildInChildLists
=
[
this
]
(
)
-
>
nsIFrame
*
{
const
ChildListID
listIDs
[
]
=
{
FrameChildListID
:
:
Principal
FrameChildListID
:
:
Overflow
}
;
for
(
nsIFrame
*
frag
=
this
;
frag
;
frag
=
frag
-
>
GetNextInFlow
(
)
)
{
for
(
ChildListID
id
:
listIDs
)
{
const
nsFrameList
&
list
=
frag
-
>
GetChildList
(
id
)
;
if
(
nsIFrame
*
firstChild
=
list
.
FirstChild
(
)
)
{
return
firstChild
;
}
}
}
return
nullptr
;
}
;
nsIFrame
*
columnSet
=
FindFirstChildInChildLists
(
)
;
MOZ_ASSERT
(
columnSet
&
&
columnSet
-
>
IsColumnSetFrame
(
)
"
The
first
child
should
always
be
ColumnSet
!
"
)
;
aResult
.
AppendElement
(
OwnedAnonBox
(
columnSet
)
)
;
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
ColumnSetWrapperFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
u
"
ColumnSetWrapper
"
_ns
aResult
)
;
}
#
endif
void
ColumnSetWrapperFrame
:
:
AppendFrames
(
ChildListID
aListID
nsFrameList
&
&
aFrameList
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
!
mFinishedBuildingColumns
"
Should
only
call
once
!
"
)
;
mFinishedBuildingColumns
=
true
;
#
endif
nsBlockFrame
:
:
AppendFrames
(
aListID
std
:
:
move
(
aFrameList
)
)
;
#
ifdef
DEBUG
nsIFrame
*
firstColumnSet
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
for
(
nsIFrame
*
child
:
PrincipalChildList
(
)
)
{
if
(
child
-
>
IsColumnSpan
(
)
)
{
AssertColumnSpanWrapperSubtreeIsSane
(
child
)
;
}
else
if
(
child
!
=
firstColumnSet
)
{
MOZ_ASSERT
(
child
-
>
IsColumnSetFrame
(
)
&
&
child
-
>
GetPrevContinuation
(
)
"
ColumnSet
'
s
prev
-
continuation
is
not
set
properly
?
"
)
;
}
}
#
endif
}
void
ColumnSetWrapperFrame
:
:
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
const
nsLineList
:
:
iterator
*
aPrevFrameLine
nsFrameList
&
&
aFrameList
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unsupported
operation
!
"
)
;
nsBlockFrame
:
:
InsertFrames
(
aListID
aPrevFrame
aPrevFrameLine
std
:
:
move
(
aFrameList
)
)
;
}
void
ColumnSetWrapperFrame
:
:
RemoveFrame
(
DestroyContext
&
aContext
ChildListID
aListID
nsIFrame
*
aOldFrame
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unsupported
operation
!
"
)
;
nsBlockFrame
:
:
RemoveFrame
(
aContext
aListID
aOldFrame
)
;
}
void
ColumnSetWrapperFrame
:
:
MarkIntrinsicISizesDirty
(
)
{
nsBlockFrame
:
:
MarkIntrinsicISizesDirty
(
)
;
for
(
nsIFrame
*
f
=
FirstContinuation
(
)
;
f
;
f
=
f
-
>
GetNextContinuation
(
)
)
{
f
-
>
RemoveStateBits
(
NS_BLOCK_NEEDS_BIDI_RESOLUTION
)
;
}
}
nscoord
ColumnSetWrapperFrame
:
:
IntrinsicISize
(
gfxContext
*
aContext
IntrinsicISizeType
aType
)
{
if
(
aType
=
=
IntrinsicISizeType
:
:
MinISize
)
{
if
(
mCachedMinISize
=
=
NS_INTRINSIC_ISIZE_UNKNOWN
)
{
mCachedMinISize
=
MinISize
(
aContext
)
;
}
return
mCachedMinISize
;
}
if
(
mCachedPrefISize
=
=
NS_INTRINSIC_ISIZE_UNKNOWN
)
{
mCachedPrefISize
=
PrefISize
(
aContext
)
;
}
return
mCachedPrefISize
;
}
nscoord
ColumnSetWrapperFrame
:
:
MinISize
(
gfxContext
*
aContext
)
{
nscoord
iSize
=
0
;
if
(
Maybe
<
nscoord
>
containISize
=
ContainIntrinsicISize
(
NS_UNCONSTRAINEDSIZE
)
)
{
if
(
*
containISize
!
=
NS_UNCONSTRAINEDSIZE
)
{
return
*
containISize
;
}
const
nsStyleColumn
*
colStyle
=
StyleColumn
(
)
;
if
(
colStyle
-
>
mColumnWidth
.
IsLength
(
)
)
{
iSize
=
0
;
}
else
{
MOZ_ASSERT
(
!
colStyle
-
>
mColumnCount
.
IsAuto
(
)
"
column
-
count
and
column
-
width
can
'
t
both
be
auto
!
"
)
;
const
nscoord
colGap
=
ColumnUtils
:
:
GetColumnGap
(
this
NS_UNCONSTRAINEDSIZE
)
;
iSize
=
ColumnUtils
:
:
IntrinsicISize
(
colStyle
-
>
mColumnCount
.
AsInteger
(
)
colGap
0
)
;
}
}
else
{
for
(
nsIFrame
*
f
:
PrincipalChildList
(
)
)
{
iSize
=
std
:
:
max
(
iSize
f
-
>
GetMinISize
(
aContext
)
)
;
}
}
return
iSize
;
}
nscoord
ColumnSetWrapperFrame
:
:
PrefISize
(
gfxContext
*
aContext
)
{
nscoord
iSize
=
0
;
if
(
Maybe
<
nscoord
>
containISize
=
ContainIntrinsicISize
(
NS_UNCONSTRAINEDSIZE
)
)
{
if
(
*
containISize
!
=
NS_UNCONSTRAINEDSIZE
)
{
return
*
containISize
;
}
const
nsStyleColumn
*
colStyle
=
StyleColumn
(
)
;
nscoord
colISize
;
if
(
colStyle
-
>
mColumnWidth
.
IsLength
(
)
)
{
colISize
=
ColumnUtils
:
:
ClampUsedColumnWidth
(
colStyle
-
>
mColumnWidth
.
AsLength
(
)
)
;
}
else
{
MOZ_ASSERT
(
!
colStyle
-
>
mColumnCount
.
IsAuto
(
)
"
column
-
count
and
column
-
width
can
'
t
both
be
auto
!
"
)
;
colISize
=
0
;
}
const
uint32_t
numColumns
=
colStyle
-
>
mColumnCount
.
IsAuto
(
)
?
1
:
colStyle
-
>
mColumnCount
.
AsInteger
(
)
;
const
nscoord
colGap
=
ColumnUtils
:
:
GetColumnGap
(
this
NS_UNCONSTRAINEDSIZE
)
;
iSize
=
ColumnUtils
:
:
IntrinsicISize
(
numColumns
colGap
colISize
)
;
}
else
{
for
(
nsIFrame
*
f
:
PrincipalChildList
(
)
)
{
iSize
=
std
:
:
max
(
iSize
f
-
>
GetPrefISize
(
aContext
)
)
;
}
}
return
iSize
;
}
template
<
typename
Iterator
>
Maybe
<
nscoord
>
ColumnSetWrapperFrame
:
:
GetBaselineBOffset
(
Iterator
aStart
Iterator
aEnd
WritingMode
aWM
BaselineSharingGroup
aBaselineGroup
BaselineExportContext
aExportContext
)
const
{
MOZ_ASSERT
(
(
*
aStart
=
=
PrincipalChildList
(
)
.
FirstChild
(
)
&
&
aBaselineGroup
=
=
BaselineSharingGroup
:
:
First
)
|
|
(
*
aStart
=
=
PrincipalChildList
(
)
.
LastChild
(
)
&
&
aBaselineGroup
=
=
BaselineSharingGroup
:
:
Last
)
"
Iterator
direction
must
match
baseline
sharing
group
.
"
)
;
if
(
StyleDisplay
(
)
-
>
IsContainLayout
(
)
)
{
return
Nothing
{
}
;
}
for
(
auto
itr
=
aStart
;
itr
!
=
aEnd
;
+
+
itr
)
{
const
nsIFrame
*
kid
=
*
itr
;
auto
kidBaseline
=
kid
-
>
GetNaturalBaselineBOffset
(
aWM
aBaselineGroup
aExportContext
)
;
if
(
!
kidBaseline
)
{
continue
;
}
LogicalRect
kidRect
{
aWM
kid
-
>
GetLogicalNormalPosition
(
aWM
GetSize
(
)
)
kid
-
>
GetLogicalSize
(
aWM
)
}
;
if
(
aBaselineGroup
=
=
BaselineSharingGroup
:
:
First
)
{
*
kidBaseline
+
=
kidRect
.
BStart
(
aWM
)
;
}
else
{
*
kidBaseline
+
=
(
GetLogicalSize
(
)
.
BSize
(
aWM
)
-
kidRect
.
BEnd
(
aWM
)
)
;
}
return
kidBaseline
;
}
return
Nothing
{
}
;
}
Maybe
<
nscoord
>
ColumnSetWrapperFrame
:
:
GetNaturalBaselineBOffset
(
WritingMode
aWM
BaselineSharingGroup
aBaselineGroup
BaselineExportContext
aExportContext
)
const
{
if
(
aBaselineGroup
=
=
BaselineSharingGroup
:
:
First
)
{
return
GetBaselineBOffset
(
PrincipalChildList
(
)
.
cbegin
(
)
PrincipalChildList
(
)
.
cend
(
)
aWM
aBaselineGroup
aExportContext
)
;
}
return
GetBaselineBOffset
(
PrincipalChildList
(
)
.
crbegin
(
)
PrincipalChildList
(
)
.
crend
(
)
aWM
aBaselineGroup
aExportContext
)
;
}
#
ifdef
DEBUG
void
ColumnSetWrapperFrame
:
:
AssertColumnSpanWrapperSubtreeIsSane
(
const
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
-
>
IsColumnSpan
(
)
"
aFrame
is
not
column
-
span
?
"
)
;
if
(
!
nsLayoutUtils
:
:
GetStyleFrame
(
const_cast
<
nsIFrame
*
>
(
aFrame
)
)
-
>
Style
(
)
-
>
IsAnonBox
(
)
)
{
return
;
}
MOZ_ASSERT
(
aFrame
-
>
Style
(
)
-
>
GetPseudoType
(
)
=
=
PseudoStyleType
:
:
columnSpanWrapper
"
aFrame
should
be
:
:
-
moz
-
column
-
span
-
wrapper
"
)
;
MOZ_ASSERT
(
!
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_OWNS_ANON_BOXES
)
"
:
:
-
moz
-
column
-
span
-
wrapper
anonymous
blocks
cannot
own
"
"
other
types
of
anonymous
blocks
!
"
)
;
for
(
const
nsIFrame
*
child
:
aFrame
-
>
PrincipalChildList
(
)
)
{
AssertColumnSpanWrapperSubtreeIsSane
(
child
)
;
}
}
#
endif
