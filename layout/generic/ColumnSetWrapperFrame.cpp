#
include
"
ColumnSetWrapperFrame
.
h
"
#
include
"
mozilla
/
ColumnUtils
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIFrameInlines
.
h
"
using
namespace
mozilla
;
nsBlockFrame
*
NS_NewColumnSetWrapperFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
nsFrameState
aStateFlags
)
{
ColumnSetWrapperFrame
*
frame
=
new
(
aPresShell
)
ColumnSetWrapperFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
frame
-
>
AddStateBits
(
aStateFlags
|
NS_BLOCK_FORMATTING_CONTEXT_STATE_BITS
)
;
return
frame
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
ColumnSetWrapperFrame
)
NS_QUERYFRAME_HEAD
(
ColumnSetWrapperFrame
)
NS_QUERYFRAME_ENTRY
(
ColumnSetWrapperFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsBlockFrame
)
ColumnSetWrapperFrame
:
:
ColumnSetWrapperFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
:
nsBlockFrame
(
aStyle
aPresContext
kClassID
)
{
}
void
ColumnSetWrapperFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
nsBlockFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
RemoveStateBits
(
NS_BLOCK_NEEDS_BIDI_RESOLUTION
)
;
}
nsContainerFrame
*
ColumnSetWrapperFrame
:
:
GetContentInsertionFrame
(
)
{
nsIFrame
*
columnSet
=
PrincipalChildList
(
)
.
OnlyChild
(
)
;
if
(
columnSet
)
{
MOZ_ASSERT
(
columnSet
-
>
IsColumnSetFrame
(
)
)
;
return
columnSet
-
>
GetContentInsertionFrame
(
)
;
}
return
this
;
}
void
ColumnSetWrapperFrame
:
:
AppendDirectlyOwnedAnonBoxes
(
nsTArray
<
OwnedAnonBox
>
&
aResult
)
{
MOZ_ASSERT
(
!
GetPrevContinuation
(
)
"
Who
set
NS_FRAME_OWNS_ANON_BOXES
on
our
continuations
?
"
)
;
auto
FindFirstChildInChildLists
=
[
this
]
(
)
-
>
nsIFrame
*
{
const
ChildListID
listIDs
[
]
=
{
kPrincipalList
kOverflowList
}
;
for
(
nsIFrame
*
frag
=
this
;
frag
;
frag
=
frag
-
>
GetNextInFlow
(
)
)
{
for
(
ChildListID
id
:
listIDs
)
{
const
nsFrameList
&
list
=
frag
-
>
GetChildList
(
id
)
;
if
(
nsIFrame
*
firstChild
=
list
.
FirstChild
(
)
)
{
return
firstChild
;
}
}
}
return
nullptr
;
}
;
nsIFrame
*
columnSet
=
FindFirstChildInChildLists
(
)
;
MOZ_ASSERT
(
columnSet
&
&
columnSet
-
>
IsColumnSetFrame
(
)
"
The
first
child
should
always
be
ColumnSet
!
"
)
;
aResult
.
AppendElement
(
OwnedAnonBox
(
columnSet
)
)
;
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
ColumnSetWrapperFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
u
"
ColumnSetWrapper
"
_ns
aResult
)
;
}
#
endif
void
ColumnSetWrapperFrame
:
:
AppendFrames
(
ChildListID
aListID
nsFrameList
&
&
aFrameList
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
!
mFinishedBuildingColumns
"
Should
only
call
once
!
"
)
;
mFinishedBuildingColumns
=
true
;
#
endif
nsBlockFrame
:
:
AppendFrames
(
aListID
std
:
:
move
(
aFrameList
)
)
;
#
ifdef
DEBUG
nsIFrame
*
firstColumnSet
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
for
(
nsIFrame
*
child
:
PrincipalChildList
(
)
)
{
if
(
child
-
>
IsColumnSpan
(
)
)
{
AssertColumnSpanWrapperSubtreeIsSane
(
child
)
;
}
else
if
(
child
!
=
firstColumnSet
)
{
MOZ_ASSERT
(
child
-
>
IsColumnSetFrame
(
)
&
&
child
-
>
GetPrevContinuation
(
)
"
ColumnSet
'
s
prev
-
continuation
is
not
set
properly
?
"
)
;
}
}
#
endif
}
void
ColumnSetWrapperFrame
:
:
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
const
nsLineList
:
:
iterator
*
aPrevFrameLine
nsFrameList
&
&
aFrameList
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unsupported
operation
!
"
)
;
nsBlockFrame
:
:
InsertFrames
(
aListID
aPrevFrame
aPrevFrameLine
std
:
:
move
(
aFrameList
)
)
;
}
void
ColumnSetWrapperFrame
:
:
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Unsupported
operation
!
"
)
;
nsBlockFrame
:
:
RemoveFrame
(
aListID
aOldFrame
)
;
}
void
ColumnSetWrapperFrame
:
:
MarkIntrinsicISizesDirty
(
)
{
nsBlockFrame
:
:
MarkIntrinsicISizesDirty
(
)
;
for
(
nsIFrame
*
f
=
FirstContinuation
(
)
;
f
;
f
=
f
-
>
GetNextContinuation
(
)
)
{
f
-
>
RemoveStateBits
(
NS_BLOCK_NEEDS_BIDI_RESOLUTION
)
;
}
}
nscoord
ColumnSetWrapperFrame
:
:
GetMinISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
iSize
=
0
;
DISPLAY_MIN_INLINE_SIZE
(
this
iSize
)
;
if
(
Maybe
<
nscoord
>
containISize
=
ContainIntrinsicISize
(
NS_UNCONSTRAINEDSIZE
)
)
{
if
(
*
containISize
!
=
NS_UNCONSTRAINEDSIZE
)
{
return
*
containISize
;
}
const
nsStyleColumn
*
colStyle
=
StyleColumn
(
)
;
if
(
colStyle
-
>
mColumnWidth
.
IsLength
(
)
)
{
iSize
=
0
;
}
else
{
MOZ_ASSERT
(
colStyle
-
>
mColumnCount
!
=
nsStyleColumn
:
:
kColumnCountAuto
"
column
-
count
and
column
-
width
can
'
t
both
be
auto
!
"
)
;
const
nscoord
colGap
=
ColumnUtils
:
:
GetColumnGap
(
this
NS_UNCONSTRAINEDSIZE
)
;
iSize
=
ColumnUtils
:
:
IntrinsicISize
(
colStyle
-
>
mColumnCount
colGap
0
)
;
}
}
else
{
for
(
nsIFrame
*
f
:
PrincipalChildList
(
)
)
{
iSize
=
std
:
:
max
(
iSize
f
-
>
GetMinISize
(
aRenderingContext
)
)
;
}
}
return
iSize
;
}
nscoord
ColumnSetWrapperFrame
:
:
GetPrefISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
iSize
=
0
;
DISPLAY_PREF_INLINE_SIZE
(
this
iSize
)
;
if
(
Maybe
<
nscoord
>
containISize
=
ContainIntrinsicISize
(
NS_UNCONSTRAINEDSIZE
)
)
{
if
(
*
containISize
!
=
NS_UNCONSTRAINEDSIZE
)
{
return
*
containISize
;
}
const
nsStyleColumn
*
colStyle
=
StyleColumn
(
)
;
nscoord
colISize
;
if
(
colStyle
-
>
mColumnWidth
.
IsLength
(
)
)
{
colISize
=
ColumnUtils
:
:
ClampUsedColumnWidth
(
colStyle
-
>
mColumnWidth
.
AsLength
(
)
)
;
}
else
{
MOZ_ASSERT
(
colStyle
-
>
mColumnCount
!
=
nsStyleColumn
:
:
kColumnCountAuto
"
column
-
count
and
column
-
width
can
'
t
both
be
auto
!
"
)
;
colISize
=
0
;
}
const
uint32_t
numColumns
=
colStyle
-
>
mColumnCount
=
=
nsStyleColumn
:
:
kColumnCountAuto
?
1
:
colStyle
-
>
mColumnCount
;
const
nscoord
colGap
=
ColumnUtils
:
:
GetColumnGap
(
this
NS_UNCONSTRAINEDSIZE
)
;
iSize
=
ColumnUtils
:
:
IntrinsicISize
(
numColumns
colGap
colISize
)
;
}
else
{
for
(
nsIFrame
*
f
:
PrincipalChildList
(
)
)
{
iSize
=
std
:
:
max
(
iSize
f
-
>
GetPrefISize
(
aRenderingContext
)
)
;
}
}
return
iSize
;
}
#
ifdef
DEBUG
void
ColumnSetWrapperFrame
:
:
AssertColumnSpanWrapperSubtreeIsSane
(
const
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
-
>
IsColumnSpan
(
)
"
aFrame
is
not
column
-
span
?
"
)
;
if
(
!
nsLayoutUtils
:
:
GetStyleFrame
(
const_cast
<
nsIFrame
*
>
(
aFrame
)
)
-
>
Style
(
)
-
>
IsAnonBox
(
)
)
{
return
;
}
MOZ_ASSERT
(
aFrame
-
>
Style
(
)
-
>
GetPseudoType
(
)
=
=
PseudoStyleType
:
:
columnSpanWrapper
"
aFrame
should
be
:
:
-
moz
-
column
-
span
-
wrapper
"
)
;
MOZ_ASSERT
(
!
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_OWNS_ANON_BOXES
)
"
:
:
-
moz
-
column
-
span
-
wrapper
anonymous
blocks
cannot
own
"
"
other
types
of
anonymous
blocks
!
"
)
;
for
(
const
nsIFrame
*
child
:
aFrame
-
>
PrincipalChildList
(
)
)
{
AssertColumnSpanWrapperSubtreeIsSane
(
child
)
;
}
}
#
endif
