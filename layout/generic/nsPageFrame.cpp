#
include
"
nsPageFrame
.
h
"
#
include
"
mozilla
/
AppUnits
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
nsDeviceContext
.
h
"
#
include
"
nsFontMetrics
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsFieldSetFrame
.
h
"
#
include
"
nsPageContentFrame
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsPageSequenceFrame
.
h
"
#
include
"
nsTextFormatter
.
h
"
#
include
"
nsBidiUtils
.
h
"
#
include
"
nsIPrintSettings
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
extern
mozilla
:
:
LazyLogModule
gLayoutPrintingLog
;
#
define
PR_PL
(
_p1
)
MOZ_LOG
(
gLayoutPrintingLog
mozilla
:
:
LogLevel
:
:
Debug
_p1
)
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
nsPageFrame
*
NS_NewPageFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsPageFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsPageFrame
)
NS_QUERYFRAME_HEAD
(
nsPageFrame
)
NS_QUERYFRAME_ENTRY
(
nsPageFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsContainerFrame
)
nsPageFrame
:
:
nsPageFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
:
nsContainerFrame
(
aStyle
aPresContext
kClassID
)
{
}
nsPageFrame
:
:
~
nsPageFrame
(
)
=
default
;
nsReflowStatus
nsPageFrame
:
:
ReflowPageContent
(
nsPresContext
*
aPresContext
const
ReflowInput
&
aPageReflowInput
)
{
if
(
mFrames
.
IsEmpty
(
)
)
{
return
{
}
;
}
nsIFrame
*
frame
=
mFrames
.
FirstChild
(
)
;
nsSize
maxSize
=
aPresContext
-
>
GetPageSize
(
)
;
float
scale
=
aPresContext
-
>
GetPageScale
(
)
;
maxSize
.
width
=
NSToCoordCeil
(
maxSize
.
width
/
scale
)
;
if
(
maxSize
.
height
!
=
NS_UNCONSTRAINEDSIZE
)
{
maxSize
.
height
=
NSToCoordCeil
(
maxSize
.
height
/
scale
)
;
}
const
nscoord
onePixel
=
AppUnitsPerCSSPixel
(
)
;
if
(
maxSize
.
width
<
onePixel
|
|
maxSize
.
height
<
onePixel
)
{
NS_WARNING
(
"
Reflow
aborted
;
no
space
for
content
"
)
;
return
{
}
;
}
ReflowInput
kidReflowInput
(
aPresContext
aPageReflowInput
frame
LogicalSize
(
frame
-
>
GetWritingMode
(
)
maxSize
)
)
;
kidReflowInput
.
mFlags
.
mIsTopOfPage
=
true
;
kidReflowInput
.
mFlags
.
mTableIsSplittable
=
true
;
mPageContentMargin
=
aPresContext
-
>
GetDefaultPageMargin
(
)
;
if
(
mPD
-
>
mPrintSettings
-
>
GetHonorPageRuleMargins
(
)
)
{
const
auto
&
margin
=
kidReflowInput
.
mStyleMargin
-
>
mMargin
;
for
(
const
auto
side
:
mozilla
:
:
AllPhysicalSides
(
)
)
{
if
(
!
margin
.
Get
(
side
)
.
IsAuto
(
)
)
{
nscoord
computed
=
kidReflowInput
.
ComputedPhysicalMargin
(
)
.
Side
(
side
)
;
if
(
computed
=
=
0
)
{
mPageContentMargin
.
Side
(
side
)
=
0
;
}
else
{
nscoord
unwriteable
=
nsPresContext
:
:
CSSTwipsToAppUnits
(
mPD
-
>
mPrintSettings
-
>
GetUnwriteableMarginInTwips
(
)
.
Side
(
side
)
)
;
mPageContentMargin
.
Side
(
side
)
=
std
:
:
max
(
kidReflowInput
.
ComputedPhysicalMargin
(
)
.
Side
(
side
)
unwriteable
)
;
}
}
}
}
nscoord
maxWidth
=
maxSize
.
width
-
mPageContentMargin
.
LeftRight
(
)
/
scale
;
nscoord
maxHeight
;
if
(
maxSize
.
height
=
=
NS_UNCONSTRAINEDSIZE
)
{
maxHeight
=
NS_UNCONSTRAINEDSIZE
;
}
else
{
maxHeight
=
maxSize
.
height
-
mPageContentMargin
.
TopBottom
(
)
/
scale
;
}
if
(
maxWidth
<
onePixel
|
|
maxHeight
<
onePixel
)
{
mPageContentMargin
=
aPresContext
-
>
GetDefaultPageMargin
(
)
;
maxWidth
=
maxSize
.
width
-
mPageContentMargin
.
LeftRight
(
)
/
scale
;
if
(
maxHeight
!
=
NS_UNCONSTRAINEDSIZE
)
{
maxHeight
=
maxSize
.
height
-
mPageContentMargin
.
TopBottom
(
)
/
scale
;
}
}
if
(
maxWidth
<
onePixel
|
|
maxHeight
<
onePixel
)
{
NS_WARNING
(
"
Reflow
aborted
;
no
space
for
content
"
)
;
return
{
}
;
}
kidReflowInput
.
SetComputedWidth
(
maxWidth
)
;
kidReflowInput
.
SetComputedHeight
(
maxHeight
)
;
nscoord
xc
=
mPageContentMargin
.
left
;
nscoord
yc
=
mPageContentMargin
.
top
;
ReflowOutput
kidOutput
(
kidReflowInput
)
;
nsReflowStatus
kidStatus
;
ReflowChild
(
frame
aPresContext
kidOutput
kidReflowInput
xc
yc
ReflowChildFlags
:
:
Default
kidStatus
)
;
FinishReflowChild
(
frame
aPresContext
kidOutput
&
kidReflowInput
xc
yc
ReflowChildFlags
:
:
Default
)
;
NS_ASSERTION
(
!
kidStatus
.
IsFullyComplete
(
)
|
|
!
frame
-
>
GetNextInFlow
(
)
"
bad
child
flow
list
"
)
;
return
kidStatus
;
}
void
nsPageFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aReflowOutput
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsPageFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aReflowOutput
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
MOZ_ASSERT
(
mPD
"
Need
a
pointer
to
nsSharedPageData
before
reflow
starts
"
)
;
NS_ASSERTION
(
mFrames
.
FirstChild
(
)
&
&
mFrames
.
FirstChild
(
)
-
>
IsPageContentFrame
(
)
"
pageFrame
must
have
a
pageContentFrame
child
"
)
;
aStatus
=
ReflowPageContent
(
aPresContext
aReflowInput
)
;
PR_PL
(
(
"
PageFrame
:
:
Reflow
%
p
"
this
)
)
;
PR_PL
(
(
"
[
%
d
%
d
]
[
%
d
%
d
]
\
n
"
aReflowOutput
.
Width
(
)
aReflowOutput
.
Height
(
)
aReflowInput
.
AvailableWidth
(
)
aReflowInput
.
AvailableHeight
(
)
)
)
;
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
aReflowOutput
.
ISize
(
wm
)
=
aReflowInput
.
AvailableISize
(
)
;
if
(
aReflowInput
.
AvailableBSize
(
)
!
=
NS_UNCONSTRAINEDSIZE
)
{
aReflowOutput
.
BSize
(
wm
)
=
aReflowInput
.
AvailableBSize
(
)
;
}
aReflowOutput
.
SetOverflowAreasToDesiredBounds
(
)
;
FinishAndStoreOverflow
(
&
aReflowOutput
)
;
PR_PL
(
(
"
PageFrame
:
:
Reflow
%
p
"
this
)
)
;
PR_PL
(
(
"
[
%
d
%
d
]
\
n
"
aReflowInput
.
AvailableWidth
(
)
aReflowInput
.
AvailableHeight
(
)
)
)
;
NS_FRAME_SET_TRUNCATION
(
aStatus
aReflowInput
aReflowOutput
)
;
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
nsPageFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
u
"
Page
"
_ns
aResult
)
;
}
#
endif
void
nsPageFrame
:
:
ProcessSpecialCodes
(
const
nsString
&
aStr
nsString
&
aNewStr
)
{
aNewStr
=
aStr
;
constexpr
auto
kDate
=
u
"
&
D
"
_ns
;
if
(
aStr
.
Find
(
kDate
)
!
=
kNotFound
)
{
aNewStr
.
ReplaceSubstring
(
kDate
mPD
-
>
mDateTimeStr
)
;
}
constexpr
auto
kPageAndTotal
=
u
"
&
PT
"
_ns
;
if
(
aStr
.
Find
(
kPageAndTotal
)
!
=
kNotFound
)
{
nsAutoString
uStr
;
nsTextFormatter
:
:
ssprintf
(
uStr
mPD
-
>
mPageNumAndTotalsFormat
.
get
(
)
mPageNum
mPD
-
>
mRawNumPages
)
;
aNewStr
.
ReplaceSubstring
(
kPageAndTotal
uStr
)
;
}
constexpr
auto
kPage
=
u
"
&
P
"
_ns
;
if
(
aStr
.
Find
(
kPage
)
!
=
kNotFound
)
{
nsAutoString
uStr
;
nsTextFormatter
:
:
ssprintf
(
uStr
mPD
-
>
mPageNumFormat
.
get
(
)
mPageNum
)
;
aNewStr
.
ReplaceSubstring
(
kPage
uStr
)
;
}
constexpr
auto
kTitle
=
u
"
&
T
"
_ns
;
if
(
aStr
.
Find
(
kTitle
)
!
=
kNotFound
)
{
aNewStr
.
ReplaceSubstring
(
kTitle
mPD
-
>
mDocTitle
)
;
}
constexpr
auto
kDocURL
=
u
"
&
U
"
_ns
;
if
(
aStr
.
Find
(
kDocURL
)
!
=
kNotFound
)
{
aNewStr
.
ReplaceSubstring
(
kDocURL
mPD
-
>
mDocURL
)
;
}
constexpr
auto
kPageTotal
=
u
"
&
L
"
_ns
;
if
(
aStr
.
Find
(
kPageTotal
)
!
=
kNotFound
)
{
nsAutoString
uStr
;
nsTextFormatter
:
:
ssprintf
(
uStr
mPD
-
>
mPageNumFormat
.
get
(
)
mPD
-
>
mRawNumPages
)
;
aNewStr
.
ReplaceSubstring
(
kPageTotal
uStr
)
;
}
}
nscoord
nsPageFrame
:
:
GetXPosition
(
gfxContext
&
aRenderingContext
nsFontMetrics
&
aFontMetrics
const
nsRect
&
aRect
int32_t
aJust
const
nsString
&
aStr
)
{
nscoord
width
=
nsLayoutUtils
:
:
AppUnitWidthOfStringBidi
(
aStr
this
aFontMetrics
aRenderingContext
)
;
nscoord
x
=
aRect
.
x
;
switch
(
aJust
)
{
case
nsIPrintSettings
:
:
kJustLeft
:
x
+
=
mPD
-
>
mEdgePaperMargin
.
left
;
break
;
case
nsIPrintSettings
:
:
kJustCenter
:
x
+
=
(
aRect
.
width
-
width
)
/
2
;
break
;
case
nsIPrintSettings
:
:
kJustRight
:
x
+
=
aRect
.
width
-
width
-
mPD
-
>
mEdgePaperMargin
.
right
;
break
;
}
return
x
;
}
void
nsPageFrame
:
:
DrawHeaderFooter
(
gfxContext
&
aRenderingContext
nsFontMetrics
&
aFontMetrics
nsHeaderFooterEnum
aHeaderFooter
const
nsString
&
aStrLeft
const
nsString
&
aStrCenter
const
nsString
&
aStrRight
const
nsRect
&
aRect
nscoord
aAscent
nscoord
aHeight
)
{
int32_t
numStrs
=
0
;
if
(
!
aStrLeft
.
IsEmpty
(
)
)
numStrs
+
+
;
if
(
!
aStrCenter
.
IsEmpty
(
)
)
numStrs
+
+
;
if
(
!
aStrRight
.
IsEmpty
(
)
)
numStrs
+
+
;
if
(
numStrs
=
=
0
)
return
;
nscoord
strSpace
=
aRect
.
width
/
numStrs
;
if
(
!
aStrLeft
.
IsEmpty
(
)
)
{
DrawHeaderFooter
(
aRenderingContext
aFontMetrics
aHeaderFooter
nsIPrintSettings
:
:
kJustLeft
aStrLeft
aRect
aAscent
aHeight
strSpace
)
;
}
if
(
!
aStrCenter
.
IsEmpty
(
)
)
{
DrawHeaderFooter
(
aRenderingContext
aFontMetrics
aHeaderFooter
nsIPrintSettings
:
:
kJustCenter
aStrCenter
aRect
aAscent
aHeight
strSpace
)
;
}
if
(
!
aStrRight
.
IsEmpty
(
)
)
{
DrawHeaderFooter
(
aRenderingContext
aFontMetrics
aHeaderFooter
nsIPrintSettings
:
:
kJustRight
aStrRight
aRect
aAscent
aHeight
strSpace
)
;
}
}
void
nsPageFrame
:
:
DrawHeaderFooter
(
gfxContext
&
aRenderingContext
nsFontMetrics
&
aFontMetrics
nsHeaderFooterEnum
aHeaderFooter
int32_t
aJust
const
nsString
&
aStr
const
nsRect
&
aRect
nscoord
aAscent
nscoord
aHeight
nscoord
aWidth
)
{
nscoord
contentWidth
=
aWidth
-
(
mPD
-
>
mEdgePaperMargin
.
left
+
mPD
-
>
mEdgePaperMargin
.
right
)
;
DrawTarget
*
drawTarget
=
aRenderingContext
.
GetDrawTarget
(
)
;
if
(
(
aHeaderFooter
=
=
eHeader
&
&
aHeight
<
mPageContentMargin
.
top
)
|
|
(
aHeaderFooter
=
=
eFooter
&
&
aHeight
<
mPageContentMargin
.
bottom
)
)
{
nsAutoString
str
;
ProcessSpecialCodes
(
aStr
str
)
;
int32_t
indx
;
int32_t
textWidth
=
0
;
const
char16_t
*
text
=
str
.
get
(
)
;
int32_t
len
=
(
int32_t
)
str
.
Length
(
)
;
if
(
len
=
=
0
)
{
return
;
}
if
(
nsLayoutUtils
:
:
BinarySearchForPosition
(
drawTarget
aFontMetrics
text
0
0
0
len
int32_t
(
contentWidth
)
indx
textWidth
)
)
{
if
(
indx
<
len
-
1
)
{
if
(
indx
>
3
)
{
str
.
Truncate
(
indx
-
3
)
;
str
.
AppendLiteral
(
"
.
.
.
"
)
;
}
else
{
str
.
Truncate
(
)
;
}
}
}
else
{
return
;
}
if
(
HasRTLChars
(
str
)
)
{
PresContext
(
)
-
>
SetBidiEnabled
(
)
;
}
nscoord
x
=
GetXPosition
(
aRenderingContext
aFontMetrics
aRect
aJust
str
)
;
nscoord
y
;
if
(
aHeaderFooter
=
=
eHeader
)
{
y
=
aRect
.
y
+
mPD
-
>
mEdgePaperMargin
.
top
;
}
else
{
y
=
aRect
.
YMost
(
)
-
aHeight
-
mPD
-
>
mEdgePaperMargin
.
bottom
;
}
aRenderingContext
.
Save
(
)
;
aRenderingContext
.
Clip
(
NSRectToSnappedRect
(
aRect
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
*
drawTarget
)
)
;
aRenderingContext
.
SetColor
(
sRGBColor
:
:
OpaqueBlack
(
)
)
;
nsLayoutUtils
:
:
DrawString
(
this
aFontMetrics
&
aRenderingContext
str
.
get
(
)
str
.
Length
(
)
nsPoint
(
x
y
+
aAscent
)
nullptr
DrawStringFlags
:
:
ForceHorizontal
)
;
aRenderingContext
.
Restore
(
)
;
}
}
static
void
PruneDisplayListForExtraPage
(
nsDisplayListBuilder
*
aBuilder
nsPageFrame
*
aPage
nsIFrame
*
aExtraPage
nsDisplayList
*
aList
)
{
nsDisplayList
newList
;
while
(
true
)
{
nsDisplayItem
*
i
=
aList
-
>
RemoveBottom
(
)
;
if
(
!
i
)
break
;
nsDisplayList
*
subList
=
i
-
>
GetSameCoordinateSystemChildren
(
)
;
if
(
subList
)
{
PruneDisplayListForExtraPage
(
aBuilder
aPage
aExtraPage
subList
)
;
i
-
>
UpdateBounds
(
aBuilder
)
;
}
else
{
nsIFrame
*
f
=
i
-
>
Frame
(
)
;
if
(
!
nsLayoutUtils
:
:
IsProperAncestorFrameCrossDoc
(
aPage
f
)
)
{
i
-
>
Destroy
(
aBuilder
)
;
continue
;
}
}
newList
.
AppendToTop
(
i
)
;
}
aList
-
>
AppendToTop
(
&
newList
)
;
}
static
void
BuildDisplayListForExtraPage
(
nsDisplayListBuilder
*
aBuilder
nsPageFrame
*
aPage
nsIFrame
*
aExtraPage
nsDisplayList
*
aList
)
{
if
(
!
aExtraPage
-
>
HasAnyStateBits
(
NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO
)
)
{
return
;
}
nsDisplayList
list
;
aExtraPage
-
>
BuildDisplayListForStackingContext
(
aBuilder
&
list
)
;
PruneDisplayListForExtraPage
(
aBuilder
aPage
aExtraPage
&
list
)
;
aList
-
>
AppendToTop
(
&
list
)
;
}
static
gfx
:
:
Matrix4x4
ComputePageTransform
(
nsIFrame
*
aFrame
float
aAppUnitsPerPixel
)
{
float
scale
=
aFrame
-
>
PresContext
(
)
-
>
GetPageScale
(
)
;
return
gfx
:
:
Matrix4x4
:
:
Scaling
(
scale
scale
1
)
;
}
class
nsDisplayHeaderFooter
final
:
public
nsPaintedDisplayItem
{
public
:
nsDisplayHeaderFooter
(
nsDisplayListBuilder
*
aBuilder
nsPageFrame
*
aFrame
)
:
nsPaintedDisplayItem
(
aBuilder
aFrame
)
{
MOZ_COUNT_CTOR
(
nsDisplayHeaderFooter
)
;
}
MOZ_COUNTED_DTOR_OVERRIDE
(
nsDisplayHeaderFooter
)
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
{
#
ifdef
DEBUG
nsPageFrame
*
pageFrame
=
do_QueryFrame
(
mFrame
)
;
MOZ_ASSERT
(
pageFrame
"
We
should
have
an
nsPageFrame
"
)
;
#
endif
static_cast
<
nsPageFrame
*
>
(
mFrame
)
-
>
PaintHeaderFooter
(
*
aCtx
ToReferenceFrame
(
)
IsSubpixelAADisabled
(
)
)
;
}
NS_DISPLAY_DECL_NAME
(
"
HeaderFooter
"
TYPE_HEADER_FOOTER
)
virtual
nsRect
GetComponentAlphaBounds
(
nsDisplayListBuilder
*
aBuilder
)
const
override
{
bool
snap
;
return
GetBounds
(
aBuilder
&
snap
)
;
}
}
;
static
void
PaintMarginGuides
(
nsIFrame
*
aFrame
DrawTarget
*
aDrawTarget
const
nsRect
&
aDirtyRect
nsPoint
aPt
)
{
ColorPattern
pattern
(
ToDeviceColor
(
sRGBColor
(
0
.
0f
0
.
0f
1
.
0f
)
)
)
;
Float
dashes
[
]
=
{
2
.
0f
2
.
0f
}
;
StrokeOptions
stroke
(
0
.
5f
JoinStyle
:
:
MITER_OR_BEVEL
CapStyle
:
:
BUTT
10
.
0f
ArrayLength
(
dashes
)
dashes
0
.
0f
)
;
DrawOptions
options
;
MOZ_RELEASE_ASSERT
(
aFrame
-
>
IsPageFrame
(
)
)
;
const
nsMargin
&
margin
=
static_cast
<
nsPageFrame
*
>
(
aFrame
)
-
>
GetUsedPageContentMargin
(
)
;
int32_t
appUnitsPerDevPx
=
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
nsRect
rect
(
aPt
aFrame
-
>
GetSize
(
)
)
;
rect
.
Deflate
(
nsMargin
(
margin
.
top
0
margin
.
bottom
0
)
)
;
Rect
r
=
NSRectToRect
(
rect
appUnitsPerDevPx
)
;
aDrawTarget
-
>
StrokeLine
(
r
.
TopLeft
(
)
r
.
TopRight
(
)
pattern
stroke
options
)
;
aDrawTarget
-
>
StrokeLine
(
r
.
BottomLeft
(
)
r
.
BottomRight
(
)
pattern
stroke
options
)
;
rect
=
nsRect
(
aPt
aFrame
-
>
GetSize
(
)
)
;
rect
.
Deflate
(
nsMargin
(
0
margin
.
left
0
margin
.
right
)
)
;
r
=
NSRectToRect
(
rect
appUnitsPerDevPx
)
;
aDrawTarget
-
>
StrokeLine
(
r
.
TopLeft
(
)
r
.
BottomLeft
(
)
pattern
stroke
options
)
;
aDrawTarget
-
>
StrokeLine
(
r
.
TopRight
(
)
r
.
BottomRight
(
)
pattern
stroke
options
)
;
}
using
PageAndOffset
=
std
:
:
pair
<
nsPageContentFrame
*
nscoord
>
;
static
nsTArray
<
PageAndOffset
>
GetPreviousPagesWithOverflow
(
nsPageContentFrame
*
aPage
)
{
nsTArray
<
PageAndOffset
>
pages
(
8
)
;
auto
GetPreviousPageContentFrame
=
[
]
(
nsPageContentFrame
*
aPageCF
)
{
nsIFrame
*
prevCont
=
aPageCF
-
>
GetPrevContinuation
(
)
;
MOZ_ASSERT
(
!
prevCont
|
|
prevCont
-
>
IsPageContentFrame
(
)
"
Expected
nsPageContentFrame
or
nullptr
"
)
;
return
static_cast
<
nsPageContentFrame
*
>
(
prevCont
)
;
}
;
nsPageContentFrame
*
pageCF
=
aPage
;
nscoord
offsetToCurrentPageTop
=
0
;
while
(
(
pageCF
=
GetPreviousPageContentFrame
(
pageCF
)
)
)
{
offsetToCurrentPageTop
+
=
pageCF
-
>
GetSize
(
)
.
Height
(
)
;
if
(
pageCF
-
>
HasOverflowAreas
(
)
)
{
pages
.
EmplaceBack
(
pageCF
offsetToCurrentPageTop
)
;
}
}
return
pages
;
}
static
void
BuildPreviousPageOverflow
(
nsDisplayListBuilder
*
aBuilder
nsPageFrame
*
aPageFrame
nsPageContentFrame
*
aCurrentPageCF
const
nsDisplayListSet
&
aLists
)
{
const
auto
previousPagesAndOffsets
=
GetPreviousPagesWithOverflow
(
aCurrentPageCF
)
;
for
(
const
PageAndOffset
&
pair
:
Reversed
(
previousPagesAndOffsets
)
)
{
auto
*
prevPageCF
=
pair
.
first
;
const
nscoord
offsetToCurrentPageTop
=
pair
.
second
;
const
auto
inkOverflow
=
prevPageCF
-
>
InkOverflowRectRelativeToSelf
(
)
;
const
auto
remainingOverflow
=
inkOverflow
.
YMost
(
)
-
offsetToCurrentPageTop
;
if
(
remainingOverflow
<
=
0
)
{
continue
;
}
nsRect
overflowRect
=
inkOverflow
;
overflowRect
.
y
=
offsetToCurrentPageTop
;
overflowRect
.
height
=
std
:
:
min
(
remainingOverflow
prevPageCF
-
>
GetSize
(
)
.
Height
(
)
)
;
{
const
nsRect
visibleRect
=
overflowRect
+
prevPageCF
-
>
GetOffsetTo
(
aPageFrame
)
;
nsDisplayListBuilder
:
:
AutoBuildingDisplayList
buildingForChild
(
aBuilder
aPageFrame
visibleRect
visibleRect
)
;
const
nsPoint
pageOffset
=
aCurrentPageCF
-
>
GetOffsetTo
(
prevPageCF
)
;
const
nsPoint
additionalOffset
(
pageOffset
.
X
(
)
pageOffset
.
Y
(
)
-
offsetToCurrentPageTop
)
;
buildingForChild
.
SetAdditionalOffset
(
additionalOffset
)
;
aPageFrame
-
>
BuildDisplayListForChild
(
aBuilder
prevPageCF
aLists
)
;
}
}
}
void
nsPageFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
nsDisplayListCollection
set
(
aBuilder
)
;
nsPresContext
*
pc
=
PresContext
(
)
;
nsIFrame
*
child
=
mFrames
.
FirstChild
(
)
;
float
scale
=
pc
-
>
GetPageScale
(
)
;
nsRect
clipRect
(
nsPoint
(
0
0
)
child
-
>
GetSize
(
)
)
;
nscoord
expectedPageContentHeight
=
NSToCoordCeil
(
GetSize
(
)
.
height
/
scale
)
;
if
(
clipRect
.
height
>
expectedPageContentHeight
)
{
NS_ASSERTION
(
mPageNum
>
0
"
page
num
should
be
positive
"
)
;
clipRect
.
y
=
NSToCoordCeil
(
(
-
child
-
>
GetRect
(
)
.
y
+
pc
-
>
GetDefaultPageMargin
(
)
.
top
)
/
scale
)
;
clipRect
.
height
=
expectedPageContentHeight
;
NS_ASSERTION
(
clipRect
.
y
<
child
-
>
GetSize
(
)
.
height
"
Should
be
clipping
to
region
inside
the
page
content
bounds
"
)
;
}
clipRect
+
=
aBuilder
-
>
ToReferenceFrame
(
child
)
;
nsDisplayList
content
;
{
DisplayListClipState
:
:
AutoSaveRestore
clipState
(
aBuilder
)
;
clipState
.
Clear
(
)
;
clipState
.
ClipContainingBlockDescendants
(
clipRect
)
;
MOZ_ASSERT
(
child
-
>
IsPageContentFrame
(
)
"
unexpected
child
frame
type
"
)
;
auto
*
currentPageCF
=
static_cast
<
nsPageContentFrame
*
>
(
child
)
;
if
(
StaticPrefs
:
:
layout_display_list_improve_fragmentation
(
)
&
&
mPageNum
<
=
255
)
{
nsDisplayListBuilder
:
:
AutoPageNumberSetter
p
(
aBuilder
mPageNum
)
;
BuildPreviousPageOverflow
(
aBuilder
this
currentPageCF
set
)
;
}
const
nsRect
childOverflowRect
=
child
-
>
InkOverflowRectRelativeToSelf
(
)
;
const
nsRect
visibleRect
=
childOverflowRect
+
child
-
>
GetOffsetTo
(
this
)
;
nsDisplayListBuilder
:
:
AutoBuildingDisplayList
buildingForChild
(
aBuilder
this
visibleRect
visibleRect
)
;
BuildDisplayListForChild
(
aBuilder
child
set
)
;
set
.
SerializeWithCorrectZOrder
(
&
content
child
-
>
GetContent
(
)
)
;
NS_ASSERTION
(
mPageNum
<
=
255
"
Too
many
pages
to
handle
OOFs
"
)
;
if
(
mPageNum
<
=
255
)
{
nsDisplayListBuilder
:
:
AutoPageNumberSetter
p
(
aBuilder
mPageNum
)
;
auto
*
pageCF
=
currentPageCF
;
while
(
(
pageCF
=
static_cast
<
nsPageContentFrame
*
>
(
pageCF
-
>
GetNextContinuation
(
)
)
)
)
{
nsRect
childVisible
=
childOverflowRect
+
child
-
>
GetOffsetTo
(
pageCF
)
;
nsDisplayListBuilder
:
:
AutoBuildingDisplayList
buildingForChild
(
aBuilder
pageCF
childVisible
childVisible
)
;
BuildDisplayListForExtraPage
(
aBuilder
this
pageCF
&
content
)
;
}
}
nsDisplayListBuilder
:
:
AutoBuildingDisplayList
building
(
aBuilder
child
childOverflowRect
childOverflowRect
)
;
nsRect
backgroundRect
=
nsRect
(
aBuilder
-
>
ToReferenceFrame
(
child
)
child
-
>
GetSize
(
)
)
;
pc
-
>
GetPresShell
(
)
-
>
AddCanvasBackgroundColorItem
(
aBuilder
&
content
child
backgroundRect
NS_RGBA
(
0
0
0
0
)
)
;
}
content
.
AppendNewToTop
<
nsDisplayTransform
>
(
aBuilder
child
&
content
content
.
GetBuildingRect
(
)
:
:
ComputePageTransform
)
;
if
(
pc
-
>
IsRootPaginatedDocument
(
)
)
{
content
.
AppendNewToTop
<
nsDisplayHeaderFooter
>
(
aBuilder
this
)
;
if
(
pc
-
>
Type
(
)
=
=
nsPresContext
:
:
eContext_PrintPreview
&
&
mPD
-
>
mPrintSettings
-
>
GetShowMarginGuides
(
)
)
{
content
.
AppendNewToTop
<
nsDisplayGeneric
>
(
aBuilder
this
PaintMarginGuides
"
MarginGuides
"
DisplayItemType
:
:
TYPE_MARGIN_GUIDES
)
;
}
}
aLists
.
Content
(
)
-
>
AppendToTop
(
&
content
)
;
}
void
nsPageFrame
:
:
DeterminePageNum
(
)
{
auto
*
prevContinuation
=
static_cast
<
nsPageFrame
*
>
(
GetPrevContinuation
(
)
)
;
mPageNum
=
prevContinuation
?
prevContinuation
-
>
GetPageNum
(
)
+
1
:
1
;
}
void
nsPageFrame
:
:
PaintHeaderFooter
(
gfxContext
&
aRenderingContext
nsPoint
aPt
bool
aDisableSubpixelAA
)
{
nsPresContext
*
pc
=
PresContext
(
)
;
nsRect
rect
(
aPt
mRect
.
Size
(
)
)
;
aRenderingContext
.
SetColor
(
sRGBColor
:
:
OpaqueBlack
(
)
)
;
DrawTargetAutoDisableSubpixelAntialiasing
disable
(
aRenderingContext
.
GetDrawTarget
(
)
aDisableSubpixelAA
)
;
nsFontMetrics
:
:
Params
params
;
params
.
userFontSet
=
pc
-
>
GetUserFontSet
(
)
;
params
.
textPerf
=
pc
-
>
GetTextPerfMetrics
(
)
;
params
.
fontStats
=
pc
-
>
GetFontMatchingStats
(
)
;
params
.
featureValueLookup
=
pc
-
>
GetFontFeatureValuesLookup
(
)
;
RefPtr
<
nsFontMetrics
>
fontMet
=
pc
-
>
DeviceContext
(
)
-
>
GetMetricsFor
(
mPD
-
>
mHeadFootFont
params
)
;
nscoord
ascent
=
fontMet
-
>
MaxAscent
(
)
;
nscoord
visibleHeight
=
fontMet
-
>
MaxHeight
(
)
;
nsString
headerLeft
headerCenter
headerRight
;
mPD
-
>
mPrintSettings
-
>
GetHeaderStrLeft
(
headerLeft
)
;
mPD
-
>
mPrintSettings
-
>
GetHeaderStrCenter
(
headerCenter
)
;
mPD
-
>
mPrintSettings
-
>
GetHeaderStrRight
(
headerRight
)
;
DrawHeaderFooter
(
aRenderingContext
*
fontMet
eHeader
headerLeft
headerCenter
headerRight
rect
ascent
visibleHeight
)
;
nsString
footerLeft
footerCenter
footerRight
;
mPD
-
>
mPrintSettings
-
>
GetFooterStrLeft
(
footerLeft
)
;
mPD
-
>
mPrintSettings
-
>
GetFooterStrCenter
(
footerCenter
)
;
mPD
-
>
mPrintSettings
-
>
GetFooterStrRight
(
footerRight
)
;
DrawHeaderFooter
(
aRenderingContext
*
fontMet
eFooter
footerLeft
footerCenter
footerRight
rect
ascent
visibleHeight
)
;
}
void
nsPageFrame
:
:
SetSharedPageData
(
nsSharedPageData
*
aPD
)
{
mPD
=
aPD
;
nsPageContentFrame
*
pcf
=
static_cast
<
nsPageContentFrame
*
>
(
mFrames
.
FirstChild
(
)
)
;
if
(
pcf
)
{
pcf
-
>
SetSharedPageData
(
mPD
)
;
}
}
void
nsPageFrame
:
:
AppendDirectlyOwnedAnonBoxes
(
nsTArray
<
OwnedAnonBox
>
&
aResult
)
{
MOZ_ASSERT
(
mFrames
.
FirstChild
(
)
&
&
mFrames
.
FirstChild
(
)
-
>
IsPageContentFrame
(
)
"
pageFrame
must
have
a
pageContentFrame
child
"
)
;
aResult
.
AppendElement
(
mFrames
.
FirstChild
(
)
)
;
}
nsIFrame
*
NS_NewPageBreakFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
MOZ_ASSERT
(
aPresShell
"
null
PresShell
"
)
;
NS_ASSERTION
(
aPresShell
-
>
GetPresContext
(
)
-
>
IsPaginated
(
)
"
created
a
page
break
frame
while
not
printing
"
)
;
return
new
(
aPresShell
)
nsPageBreakFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsPageBreakFrame
)
nsPageBreakFrame
:
:
nsPageBreakFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
:
nsLeafFrame
(
aStyle
aPresContext
kClassID
)
mHaveReflowed
(
false
)
{
}
nsPageBreakFrame
:
:
~
nsPageBreakFrame
(
)
=
default
;
nscoord
nsPageBreakFrame
:
:
GetIntrinsicISize
(
)
{
return
nsPresContext
:
:
CSSPixelsToAppUnits
(
1
)
;
}
nscoord
nsPageBreakFrame
:
:
GetIntrinsicBSize
(
)
{
return
0
;
}
void
nsPageBreakFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aReflowOutput
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
DO_GLOBAL_REFLOW_COUNT
(
"
nsPageBreakFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aReflowOutput
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
nscoord
bSize
=
aReflowInput
.
AvailableBSize
(
)
;
if
(
aReflowInput
.
AvailableBSize
(
)
=
=
NS_UNCONSTRAINEDSIZE
)
{
bSize
=
nscoord
(
0
)
;
}
else
if
(
GetContent
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
legend
)
)
{
nsContainerFrame
*
parent
=
GetParent
(
)
;
if
(
parent
&
&
parent
-
>
Style
(
)
-
>
GetPseudoType
(
)
=
=
PseudoStyleType
:
:
fieldsetContent
)
{
while
(
(
parent
=
parent
-
>
GetParent
(
)
)
)
{
if
(
nsFieldSetFrame
*
fieldset
=
do_QueryFrame
(
parent
)
)
{
auto
*
legend
=
fieldset
-
>
GetLegend
(
)
;
if
(
legend
&
&
legend
-
>
GetContent
(
)
=
=
GetContent
(
)
)
{
bSize
=
nscoord
(
0
)
;
}
break
;
}
}
}
}
LogicalSize
finalSize
(
wm
GetIntrinsicISize
(
)
bSize
)
;
finalSize
.
BSize
(
wm
)
-
=
finalSize
.
BSize
(
wm
)
%
nsPresContext
:
:
CSSPixelsToAppUnits
(
1
)
;
aReflowOutput
.
SetSize
(
wm
finalSize
)
;
mHaveReflowed
=
true
;
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
nsPageBreakFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
u
"
PageBreak
"
_ns
aResult
)
;
}
#
endif
