#
include
"
nsPlaceholderFrame
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
mozilla
/
dom
/
ElementInlines
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
PresShellInlines
.
h
"
#
include
"
mozilla
/
ServoStyleSetInlines
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsPresContextInlines
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsIContentInlines
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
gfx
;
nsPlaceholderFrame
*
NS_NewPlaceholderFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
nsFrameState
aTypeBits
)
{
return
new
(
aPresShell
)
nsPlaceholderFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
aTypeBits
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsPlaceholderFrame
)
#
ifdef
DEBUG
NS_QUERYFRAME_HEAD
(
nsPlaceholderFrame
)
NS_QUERYFRAME_ENTRY
(
nsPlaceholderFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsIFrame
)
#
endif
void
nsPlaceholderFrame
:
:
AddInlineMinISize
(
const
IntrinsicSizeInput
&
aInput
InlineMinISizeData
*
aData
)
{
AddFloatToIntrinsicISizeData
(
aInput
IntrinsicISizeType
:
:
MinISize
aData
)
;
}
void
nsPlaceholderFrame
:
:
AddInlinePrefISize
(
const
IntrinsicSizeInput
&
aInput
InlinePrefISizeData
*
aData
)
{
AddFloatToIntrinsicISizeData
(
aInput
IntrinsicISizeType
:
:
PrefISize
aData
)
;
}
void
nsPlaceholderFrame
:
:
AddFloatToIntrinsicISizeData
(
const
IntrinsicSizeInput
&
aInput
IntrinsicISizeType
aType
InlineIntrinsicISizeData
*
aData
)
const
{
if
(
mOutOfFlowFrame
-
>
IsFloating
(
)
)
{
const
IntrinsicSizeInput
floatInput
(
aInput
mOutOfFlowFrame
-
>
GetWritingMode
(
)
GetWritingMode
(
)
)
;
const
nscoord
floatISize
=
nsLayoutUtils
:
:
IntrinsicForContainer
(
floatInput
.
mContext
mOutOfFlowFrame
aType
floatInput
.
mPercentageBasisForChildren
)
;
aData
-
>
mFloats
.
EmplaceBack
(
mOutOfFlowFrame
floatISize
)
;
}
}
void
nsPlaceholderFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
#
ifdef
DEBUG
if
(
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
&
&
!
mOutOfFlowFrame
-
>
IsMenuPopupFrame
(
)
&
&
!
mOutOfFlowFrame
-
>
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
)
{
bool
isInContinuationOrIBSplit
=
false
;
nsIFrame
*
ancestor
=
this
;
while
(
(
ancestor
=
ancestor
-
>
GetParent
(
)
)
)
{
if
(
nsLayoutUtils
:
:
GetPrevContinuationOrIBSplitSibling
(
ancestor
)
)
{
isInContinuationOrIBSplit
=
true
;
break
;
}
}
if
(
isInContinuationOrIBSplit
)
{
NS_WARNING
(
"
Out
-
of
-
flow
frame
got
reflowed
before
its
placeholder
"
)
;
}
else
{
NS_ERROR
(
"
Out
-
of
-
flow
frame
got
reflowed
before
its
placeholder
"
)
;
}
}
#
endif
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsPlaceholderFrame
"
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
aDesiredSize
.
ClearSize
(
)
;
}
static
FrameChildListID
ChildListIDForOutOfFlow
(
nsFrameState
aPlaceholderState
const
nsIFrame
*
aChild
)
{
if
(
aPlaceholderState
&
PLACEHOLDER_FOR_FLOAT
)
{
return
FrameChildListID
:
:
Float
;
}
if
(
aPlaceholderState
&
PLACEHOLDER_FOR_FIXEDPOS
)
{
return
nsLayoutUtils
:
:
MayBeReallyFixedPos
(
aChild
)
?
FrameChildListID
:
:
Fixed
:
FrameChildListID
:
:
Absolute
;
}
if
(
aPlaceholderState
&
PLACEHOLDER_FOR_ABSPOS
)
{
return
FrameChildListID
:
:
Absolute
;
}
MOZ_DIAGNOSTIC_ASSERT
(
false
"
unknown
list
"
)
;
return
FrameChildListID
:
:
Float
;
}
void
nsPlaceholderFrame
:
:
Destroy
(
DestroyContext
&
aContext
)
{
if
(
nsIFrame
*
oof
=
mOutOfFlowFrame
)
{
mOutOfFlowFrame
=
nullptr
;
oof
-
>
RemoveProperty
(
nsIFrame
:
:
PlaceholderFrameProperty
(
)
)
;
ChildListID
listId
=
ChildListIDForOutOfFlow
(
GetStateBits
(
)
oof
)
;
nsFrameManager
*
fm
=
PresContext
(
)
-
>
FrameConstructor
(
)
;
fm
-
>
RemoveFrame
(
aContext
listId
oof
)
;
}
nsIFrame
:
:
Destroy
(
aContext
)
;
}
bool
nsPlaceholderFrame
:
:
CanContinueTextRun
(
)
const
{
if
(
!
mOutOfFlowFrame
)
{
return
false
;
}
return
mOutOfFlowFrame
-
>
CanContinueTextRun
(
)
;
}
ComputedStyle
*
nsPlaceholderFrame
:
:
GetParentComputedStyleForOutOfFlow
(
nsIFrame
*
*
aProviderFrame
)
const
{
MOZ_ASSERT
(
GetParent
(
)
"
How
can
we
not
have
a
parent
here
?
"
)
;
Element
*
parentElement
=
mContent
?
mContent
-
>
GetFlattenedTreeParentElement
(
)
:
nullptr
;
if
(
parentElement
&
&
MOZ_LIKELY
(
parentElement
-
>
HasServoData
(
)
)
&
&
Servo_Element_IsDisplayContents
(
parentElement
)
)
{
RefPtr
<
ComputedStyle
>
style
=
ServoStyleSet
:
:
ResolveServoStyle
(
*
parentElement
)
;
*
aProviderFrame
=
nullptr
;
return
style
;
}
return
GetLayoutParentStyleForOutOfFlow
(
aProviderFrame
)
;
}
ComputedStyle
*
nsPlaceholderFrame
:
:
GetLayoutParentStyleForOutOfFlow
(
nsIFrame
*
*
aProviderFrame
)
const
{
*
aProviderFrame
=
CorrectStyleParentFrame
(
GetParent
(
)
PseudoStyleType
:
:
MAX
)
;
return
*
aProviderFrame
?
(
*
aProviderFrame
)
-
>
Style
(
)
:
nullptr
;
}
#
if
defined
(
DEBUG
)
|
|
(
defined
(
MOZ_REFLOW_PERF_DSP
)
&
&
defined
(
MOZ_REFLOW_PERF
)
)
void
nsPlaceholderFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
DO_GLOBAL_REFLOW_COUNT_DSP
(
"
nsPlaceholderFrame
"
)
;
}
#
endif
#
ifdef
DEBUG_FRAME_DUMP
nsresult
nsPlaceholderFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
u
"
Placeholder
"
_ns
aResult
)
;
}
void
nsPlaceholderFrame
:
:
List
(
FILE
*
out
const
char
*
aPrefix
ListFlags
aFlags
)
const
{
nsCString
str
;
ListGeneric
(
str
aPrefix
aFlags
)
;
if
(
mOutOfFlowFrame
)
{
str
+
=
"
outOfFlowFrame
=
"
;
str
+
=
mOutOfFlowFrame
-
>
ListTag
(
)
;
}
fprintf_stderr
(
out
"
%
s
\
n
"
str
.
get
(
)
)
;
}
#
endif
