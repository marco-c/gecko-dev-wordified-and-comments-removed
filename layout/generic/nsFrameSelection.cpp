#
include
"
nsFrameSelection
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsISelectionListener
.
h
"
#
include
"
nsContentCID
.
h
"
#
include
"
nsDeviceContext
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIDOMNode
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsITableCellLayout
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTableWrapperFrame
.
h
"
#
include
"
nsTableCellFrame
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsCCUncollectableMarker
.
h
"
#
include
"
nsIContentIterator
.
h
"
#
include
"
nsIDocumentEncoder
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
<
algorithm
>
#
include
"
nsContentUtils
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIFrameTraversal
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsLayoutCID
.
h
"
#
include
"
nsBidiPresUtils
.
h
"
static
NS_DEFINE_CID
(
kFrameTraversalCID
NS_FRAMETRAVERSAL_CID
)
;
#
include
"
nsTextFrame
.
h
"
#
include
"
nsIDOMText
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
nsDOMClassInfoID
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsCaret
.
h
"
#
include
"
AccessibleCaretEventHub
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsIDOMDocument
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsAutoCopyListener
.
h
"
#
include
"
SelectionChangeListener
.
h
"
#
include
"
nsCopySupport
.
h
"
#
include
"
nsIClipboard
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsIBidiKeyboard
.
h
"
#
include
"
nsError
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
ShadowRoot
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
dom
/
SelectionBinding
.
h
"
#
include
"
mozilla
/
AsyncEventDispatcher
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
layers
/
ScrollInputMethods
.
h
"
#
include
"
nsIEditor
.
h
"
#
include
"
nsIHTMLEditor
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
mozilla
:
:
layers
:
:
ScrollInputMethod
;
static
bool
IsValidSelectionPoint
(
nsFrameSelection
*
aFrameSel
nsINode
*
aNode
)
;
static
nsIAtom
*
GetTag
(
nsINode
*
aNode
)
;
static
nsINode
*
ParentOffset
(
nsINode
*
aNode
int32_t
*
aChildOffset
)
;
static
nsINode
*
GetCellParent
(
nsINode
*
aDomNode
)
;
#
ifdef
PRINT_RANGE
static
void
printRange
(
nsRange
*
aDomRange
)
;
#
define
DEBUG_OUT_RANGE
(
x
)
printRange
(
x
)
#
else
#
define
DEBUG_OUT_RANGE
(
x
)
#
endif
nsPeekOffsetStruct
:
:
nsPeekOffsetStruct
(
nsSelectionAmount
aAmount
nsDirection
aDirection
int32_t
aStartOffset
nsPoint
aDesiredPos
bool
aJumpLines
bool
aScrollViewStop
bool
aIsKeyboardSelect
bool
aVisual
bool
aExtend
EWordMovementType
aWordMovementType
)
:
mAmount
(
aAmount
)
mDirection
(
aDirection
)
mStartOffset
(
aStartOffset
)
mDesiredPos
(
aDesiredPos
)
mWordMovementType
(
aWordMovementType
)
mJumpLines
(
aJumpLines
)
mScrollViewStop
(
aScrollViewStop
)
mIsKeyboardSelect
(
aIsKeyboardSelect
)
mVisual
(
aVisual
)
mExtend
(
aExtend
)
mResultContent
(
)
mResultFrame
(
nullptr
)
mContentOffset
(
0
)
mAttach
(
CARET_ASSOCIATE_BEFORE
)
{
}
static
int8_t
GetIndexFromSelectionType
(
SelectionType
aSelectionType
)
{
switch
(
aSelectionType
)
{
case
SelectionType
:
:
eNormal
:
return
0
;
case
SelectionType
:
:
eSpellCheck
:
return
1
;
case
SelectionType
:
:
eIMERawClause
:
return
2
;
case
SelectionType
:
:
eIMESelectedRawClause
:
return
3
;
case
SelectionType
:
:
eIMEConvertedClause
:
return
4
;
case
SelectionType
:
:
eIMESelectedClause
:
return
5
;
case
SelectionType
:
:
eAccessibility
:
return
6
;
case
SelectionType
:
:
eFind
:
return
7
;
case
SelectionType
:
:
eURLSecondary
:
return
8
;
case
SelectionType
:
:
eURLStrikeout
:
return
9
;
default
:
return
-
1
;
}
}
static
SelectionType
GetSelectionTypeFromIndex
(
int8_t
aIndex
)
{
static
const
SelectionType
kSelectionTypes
[
]
=
{
SelectionType
:
:
eNormal
SelectionType
:
:
eSpellCheck
SelectionType
:
:
eIMERawClause
SelectionType
:
:
eIMESelectedRawClause
SelectionType
:
:
eIMEConvertedClause
SelectionType
:
:
eIMESelectedClause
SelectionType
:
:
eAccessibility
SelectionType
:
:
eFind
SelectionType
:
:
eURLSecondary
SelectionType
:
:
eURLStrikeout
}
;
if
(
NS_WARN_IF
(
aIndex
<
0
)
|
|
NS_WARN_IF
(
static_cast
<
size_t
>
(
aIndex
)
>
=
ArrayLength
(
kSelectionTypes
)
)
)
{
return
SelectionType
:
:
eNormal
;
}
return
kSelectionTypes
[
aIndex
]
;
}
bool
IsValidSelectionPoint
(
nsFrameSelection
*
aFrameSel
nsINode
*
aNode
)
{
if
(
!
aFrameSel
|
|
!
aNode
)
return
false
;
nsIContent
*
limiter
=
aFrameSel
-
>
GetLimiter
(
)
;
if
(
limiter
&
&
limiter
!
=
aNode
&
&
limiter
!
=
aNode
-
>
GetParent
(
)
)
{
return
false
;
}
limiter
=
aFrameSel
-
>
GetAncestorLimiter
(
)
;
return
!
limiter
|
|
nsContentUtils
:
:
ContentIsDescendantOf
(
aNode
limiter
)
;
}
namespace
mozilla
{
struct
MOZ_RAII
AutoPrepareFocusRange
{
AutoPrepareFocusRange
(
Selection
*
aSelection
bool
aContinueSelection
bool
aMultipleSelection
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
if
(
aSelection
-
>
mRanges
.
Length
(
)
<
=
1
)
{
return
;
}
if
(
aSelection
-
>
mFrameSelection
-
>
IsUserSelectionReason
(
)
)
{
mUserSelect
.
emplace
(
aSelection
)
;
}
bool
userSelection
=
aSelection
-
>
mUserInitiated
;
nsTArray
<
RangeData
>
&
ranges
=
aSelection
-
>
mRanges
;
if
(
!
userSelection
|
|
(
!
aContinueSelection
&
&
aMultipleSelection
)
)
{
for
(
RangeData
&
entry
:
ranges
)
{
entry
.
mRange
-
>
SetIsGenerated
(
false
)
;
}
return
;
}
int16_t
reason
=
aSelection
-
>
mFrameSelection
-
>
mSelectionChangeReason
;
bool
isAnchorRelativeOp
=
(
reason
&
(
nsISelectionListener
:
:
DRAG_REASON
|
nsISelectionListener
:
:
MOUSEDOWN_REASON
|
nsISelectionListener
:
:
MOUSEUP_REASON
|
nsISelectionListener
:
:
COLLAPSETOSTART_REASON
)
)
;
if
(
!
isAnchorRelativeOp
)
{
return
;
}
const
size_t
len
=
ranges
.
Length
(
)
;
size_t
newAnchorFocusIndex
=
size_t
(
-
1
)
;
if
(
aSelection
-
>
GetDirection
(
)
=
=
eDirNext
)
{
for
(
size_t
i
=
0
;
i
<
len
;
+
+
i
)
{
if
(
ranges
[
i
]
.
mRange
-
>
IsGenerated
(
)
)
{
newAnchorFocusIndex
=
i
;
break
;
}
}
}
else
{
size_t
i
=
len
;
while
(
i
-
-
)
{
if
(
ranges
[
i
]
.
mRange
-
>
IsGenerated
(
)
)
{
newAnchorFocusIndex
=
i
;
break
;
}
}
}
if
(
newAnchorFocusIndex
=
=
size_t
(
-
1
)
)
{
return
;
}
if
(
aSelection
-
>
mAnchorFocusRange
)
{
aSelection
-
>
mAnchorFocusRange
-
>
SetIsGenerated
(
true
)
;
}
nsRange
*
range
=
ranges
[
newAnchorFocusIndex
]
.
mRange
;
range
-
>
SetIsGenerated
(
false
)
;
aSelection
-
>
mAnchorFocusRange
=
range
;
RefPtr
<
nsPresContext
>
presContext
=
aSelection
-
>
GetPresContext
(
)
;
size_t
i
=
len
;
while
(
i
-
-
)
{
range
=
aSelection
-
>
mRanges
[
i
]
.
mRange
;
if
(
range
-
>
IsGenerated
(
)
)
{
range
-
>
SetSelection
(
nullptr
)
;
aSelection
-
>
SelectFrames
(
presContext
range
false
)
;
aSelection
-
>
mRanges
.
RemoveElementAt
(
i
)
;
}
}
if
(
aSelection
-
>
mFrameSelection
)
{
aSelection
-
>
mFrameSelection
-
>
InvalidateDesiredPos
(
)
;
}
}
Maybe
<
Selection
:
:
AutoUserInitiated
>
mUserSelect
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
}
nsFrameSelection
:
:
nsFrameSelection
(
)
{
for
(
size_t
i
=
0
;
i
<
kPresentSelectionTypeCount
;
i
+
+
)
{
mDomSelections
[
i
]
=
new
Selection
(
this
)
;
mDomSelections
[
i
]
-
>
SetType
(
GetSelectionTypeFromIndex
(
i
)
)
;
}
mBatching
=
0
;
mChangesDuringBatching
=
false
;
mNotifyFrames
=
true
;
mMouseDoubleDownState
=
false
;
mHint
=
CARET_ASSOCIATE_BEFORE
;
mCaretBidiLevel
=
BIDI_LEVEL_UNDEFINED
;
mKbdBidiLevel
=
NSBIDI_LTR
;
mDragSelectingCells
=
false
;
mSelectingTableCellMode
=
0
;
mSelectedCellIndex
=
0
;
nsAutoCopyListener
*
autoCopy
=
nullptr
;
#
ifdef
XP_MACOSX
autoCopy
=
nsAutoCopyListener
:
:
GetInstance
(
nsIClipboard
:
:
kSelectionCache
)
;
#
endif
if
(
Preferences
:
:
GetBool
(
"
clipboard
.
autocopy
"
)
)
{
autoCopy
=
nsAutoCopyListener
:
:
GetInstance
(
nsIClipboard
:
:
kSelectionClipboard
)
;
}
if
(
autoCopy
)
{
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
if
(
mDomSelections
[
index
]
)
{
autoCopy
-
>
Listen
(
mDomSelections
[
index
]
)
;
}
}
mDisplaySelection
=
nsISelectionController
:
:
SELECTION_OFF
;
mSelectionChangeReason
=
nsISelectionListener
:
:
NO_REASON
;
mDelayedMouseEventValid
=
false
;
mDelayedMouseEventIsShift
=
false
;
mDelayedMouseEventClickCount
=
0
;
}
nsFrameSelection
:
:
~
nsFrameSelection
(
)
{
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
nsFrameSelection
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
nsFrameSelection
)
for
(
size_t
i
=
0
;
i
<
kPresentSelectionTypeCount
;
+
+
i
)
{
tmp
-
>
mDomSelections
[
i
]
=
nullptr
;
}
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mCellParent
)
tmp
-
>
mSelectingTableCellMode
=
0
;
tmp
-
>
mDragSelectingCells
=
false
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mStartSelectedCell
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mEndSelectedCell
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mAppendStartSelectedCell
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mUnselectCellOnMouseUp
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mMaintainRange
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mLimiter
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mAncestorLimiter
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
nsFrameSelection
)
if
(
tmp
-
>
mShell
&
&
tmp
-
>
mShell
-
>
GetDocument
(
)
&
&
nsCCUncollectableMarker
:
:
InGeneration
(
cb
tmp
-
>
mShell
-
>
GetDocument
(
)
-
>
GetMarkedCCGeneration
(
)
)
)
{
return
NS_SUCCESS_INTERRUPTED_TRAVERSE
;
}
for
(
size_t
i
=
0
;
i
<
kPresentSelectionTypeCount
;
+
+
i
)
{
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDomSelections
[
i
]
)
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mCellParent
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mStartSelectedCell
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mEndSelectedCell
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAppendStartSelectedCell
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mUnselectCellOnMouseUp
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mMaintainRange
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mLimiter
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAncestorLimiter
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE
(
nsFrameSelection
AddRef
)
NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE
(
nsFrameSelection
Release
)
nsresult
nsFrameSelection
:
:
FetchDesiredPos
(
nsPoint
&
aDesiredPos
)
{
if
(
!
mShell
)
{
NS_ERROR
(
"
fetch
desired
position
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
mDesiredPosSet
)
{
aDesiredPos
=
mDesiredPos
;
return
NS_OK
;
}
RefPtr
<
nsCaret
>
caret
=
mShell
-
>
GetCaret
(
)
;
if
(
!
caret
)
{
return
NS_ERROR_NULL_POINTER
;
}
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
caret
-
>
SetSelection
(
mDomSelections
[
index
]
)
;
nsRect
coord
;
nsIFrame
*
caretFrame
=
caret
-
>
GetGeometry
(
&
coord
)
;
if
(
!
caretFrame
)
{
return
NS_ERROR_FAILURE
;
}
nsPoint
viewOffset
(
0
0
)
;
nsView
*
view
=
nullptr
;
caretFrame
-
>
GetOffsetFromView
(
viewOffset
&
view
)
;
if
(
view
)
{
coord
+
=
viewOffset
;
}
aDesiredPos
=
coord
.
TopLeft
(
)
;
return
NS_OK
;
}
void
nsFrameSelection
:
:
InvalidateDesiredPos
(
)
{
mDesiredPosSet
=
false
;
}
void
nsFrameSelection
:
:
SetDesiredPos
(
nsPoint
aPos
)
{
mDesiredPos
=
aPos
;
mDesiredPosSet
=
true
;
}
nsresult
nsFrameSelection
:
:
ConstrainFrameAndPointToAnchorSubtree
(
nsIFrame
*
aFrame
nsPoint
&
aPoint
nsIFrame
*
*
aRetFrame
nsPoint
&
aRetPoint
)
{
if
(
!
aFrame
|
|
!
aRetFrame
)
return
NS_ERROR_NULL_POINTER
;
*
aRetFrame
=
aFrame
;
aRetPoint
=
aPoint
;
nsresult
result
;
nsCOMPtr
<
nsIDOMNode
>
anchorNode
;
int32_t
anchorOffset
=
0
;
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
if
(
!
mDomSelections
[
index
]
)
return
NS_ERROR_NULL_POINTER
;
result
=
mDomSelections
[
index
]
-
>
GetAnchorNode
(
getter_AddRefs
(
anchorNode
)
)
;
if
(
NS_FAILED
(
result
)
)
return
result
;
if
(
!
anchorNode
)
return
NS_OK
;
result
=
mDomSelections
[
index
]
-
>
GetAnchorOffset
(
&
anchorOffset
)
;
if
(
NS_FAILED
(
result
)
)
return
result
;
nsCOMPtr
<
nsIContent
>
anchorContent
=
do_QueryInterface
(
anchorNode
)
;
if
(
!
anchorContent
)
return
NS_ERROR_FAILURE
;
NS_ENSURE_STATE
(
mShell
)
;
nsIContent
*
anchorRoot
=
anchorContent
-
>
GetSelectionRootContent
(
mShell
)
;
NS_ENSURE_TRUE
(
anchorRoot
NS_ERROR_UNEXPECTED
)
;
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
content
)
{
nsIContent
*
contentRoot
=
content
-
>
GetSelectionRootContent
(
mShell
)
;
NS_ENSURE_TRUE
(
contentRoot
NS_ERROR_UNEXPECTED
)
;
if
(
anchorRoot
=
=
contentRoot
)
{
nsIContent
*
capturedContent
=
nsIPresShell
:
:
GetCapturingContent
(
)
;
if
(
capturedContent
!
=
content
)
{
return
NS_OK
;
}
nsIFrame
*
rootFrame
=
mShell
-
>
FrameManager
(
)
-
>
GetRootFrame
(
)
;
nsPoint
ptInRoot
=
aPoint
+
aFrame
-
>
GetOffsetTo
(
rootFrame
)
;
nsIFrame
*
cursorFrame
=
nsLayoutUtils
:
:
GetFrameForPoint
(
rootFrame
ptInRoot
)
;
if
(
cursorFrame
&
&
cursorFrame
-
>
PresContext
(
)
-
>
PresShell
(
)
=
=
mShell
)
{
nsIContent
*
cursorContent
=
cursorFrame
-
>
GetContent
(
)
;
NS_ENSURE_TRUE
(
cursorContent
NS_ERROR_FAILURE
)
;
nsIContent
*
cursorContentRoot
=
cursorContent
-
>
GetSelectionRootContent
(
mShell
)
;
NS_ENSURE_TRUE
(
cursorContentRoot
NS_ERROR_UNEXPECTED
)
;
if
(
cursorContentRoot
=
=
anchorRoot
)
{
*
aRetFrame
=
cursorFrame
;
aRetPoint
=
aPoint
+
aFrame
-
>
GetOffsetTo
(
cursorFrame
)
;
return
NS_OK
;
}
}
}
}
*
aRetFrame
=
anchorRoot
-
>
GetPrimaryFrame
(
)
;
if
(
!
*
aRetFrame
)
return
NS_ERROR_FAILURE
;
aRetPoint
=
aPoint
+
aFrame
-
>
GetOffsetTo
(
*
aRetFrame
)
;
return
NS_OK
;
}
void
nsFrameSelection
:
:
SetCaretBidiLevel
(
nsBidiLevel
aLevel
)
{
mCaretBidiLevel
=
aLevel
;
RefPtr
<
nsCaret
>
caret
;
if
(
mShell
&
&
(
caret
=
mShell
-
>
GetCaret
(
)
)
)
{
caret
-
>
SchedulePaint
(
)
;
}
}
nsBidiLevel
nsFrameSelection
:
:
GetCaretBidiLevel
(
)
const
{
return
mCaretBidiLevel
;
}
void
nsFrameSelection
:
:
UndefineCaretBidiLevel
(
)
{
mCaretBidiLevel
|
=
BIDI_LEVEL_UNDEFINED
;
}
#
ifdef
PRINT_RANGE
void
printRange
(
nsRange
*
aDomRange
)
{
if
(
!
aDomRange
)
{
printf
(
"
NULL
nsIDOMRange
\
n
"
)
;
}
nsINode
*
startNode
=
aDomRange
-
>
GetStartContainer
(
)
;
nsINode
*
endNode
=
aDomRange
-
>
GetEndContainer
(
)
;
int32_t
startOffset
=
aDomRange
-
>
StartOffset
(
)
;
int32_t
endOffset
=
aDomRange
-
>
EndOffset
(
)
;
printf
(
"
range
:
0x
%
lx
\
t
start
:
0x
%
lx
%
ld
\
t
end
:
0x
%
lx
%
ld
\
n
"
(
unsigned
long
)
aDomRange
(
unsigned
long
)
startNode
(
long
)
startOffset
(
unsigned
long
)
endNode
(
long
)
endOffset
)
;
}
#
endif
static
nsIAtom
*
GetTag
(
nsINode
*
aNode
)
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
aNode
)
;
if
(
!
content
)
{
NS_NOTREACHED
(
"
bad
node
passed
to
GetTag
(
)
"
)
;
return
nullptr
;
}
return
content
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
}
nsINode
*
ParentOffset
(
nsINode
*
aNode
int32_t
*
aChildOffset
)
{
if
(
!
aNode
|
|
!
aChildOffset
)
return
nullptr
;
nsIContent
*
parent
=
aNode
-
>
GetParent
(
)
;
if
(
parent
)
{
*
aChildOffset
=
parent
-
>
IndexOf
(
aNode
)
;
return
parent
;
}
return
nullptr
;
}
static
nsINode
*
GetCellParent
(
nsINode
*
aDomNode
)
{
if
(
!
aDomNode
)
return
nullptr
;
nsINode
*
current
=
aDomNode
;
while
(
current
)
{
nsIAtom
*
tag
=
GetTag
(
current
)
;
if
(
tag
=
=
nsGkAtoms
:
:
td
|
|
tag
=
=
nsGkAtoms
:
:
th
)
return
current
;
current
=
current
-
>
GetParent
(
)
;
}
return
nullptr
;
}
void
nsFrameSelection
:
:
Init
(
nsIPresShell
*
aShell
nsIContent
*
aLimiter
)
{
mShell
=
aShell
;
mDragState
=
false
;
mDesiredPosSet
=
false
;
mLimiter
=
aLimiter
;
mCaretMovementStyle
=
Preferences
:
:
GetInt
(
"
bidi
.
edit
.
caret_movement_style
"
2
)
;
static
bool
prefCachesInitialized
=
false
;
if
(
!
prefCachesInitialized
)
{
prefCachesInitialized
=
true
;
Preferences
:
:
AddBoolVarCache
(
&
sSelectionEventsEnabled
"
dom
.
select_events
.
enabled
"
false
)
;
Preferences
:
:
AddBoolVarCache
(
&
sSelectionEventsOnTextControlsEnabled
"
dom
.
select_events
.
textcontrols
.
enabled
"
false
)
;
}
RefPtr
<
AccessibleCaretEventHub
>
eventHub
=
mShell
-
>
GetAccessibleCaretEventHub
(
)
;
if
(
eventHub
)
{
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
if
(
mDomSelections
[
index
]
)
{
mDomSelections
[
index
]
-
>
AddSelectionListener
(
eventHub
)
;
}
}
bool
plaintextControl
=
(
aLimiter
!
=
nullptr
)
;
bool
initSelectEvents
=
plaintextControl
?
sSelectionEventsOnTextControlsEnabled
:
sSelectionEventsEnabled
;
nsIDocument
*
doc
=
aShell
-
>
GetDocument
(
)
;
if
(
initSelectEvents
|
|
(
doc
&
&
nsContentUtils
:
:
IsSystemPrincipal
(
doc
-
>
NodePrincipal
(
)
)
)
)
{
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
if
(
mDomSelections
[
index
]
)
{
RefPtr
<
SelectionChangeListener
>
listener
=
new
SelectionChangeListener
;
mDomSelections
[
index
]
-
>
AddSelectionListener
(
listener
)
;
}
}
}
bool
nsFrameSelection
:
:
sSelectionEventsEnabled
=
false
;
bool
nsFrameSelection
:
:
sSelectionEventsOnTextControlsEnabled
=
false
;
nsresult
nsFrameSelection
:
:
MoveCaret
(
nsDirection
aDirection
bool
aContinueSelection
nsSelectionAmount
aAmount
CaretMovementStyle
aMovementStyle
)
{
bool
visualMovement
=
aMovementStyle
=
=
eVisual
|
|
(
aMovementStyle
=
=
eUsePrefStyle
&
&
(
mCaretMovementStyle
=
=
1
|
|
(
mCaretMovementStyle
=
=
2
&
&
!
aContinueSelection
)
)
)
;
NS_ENSURE_STATE
(
mShell
)
;
mShell
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
if
(
!
mShell
)
{
return
NS_OK
;
}
nsPresContext
*
context
=
mShell
-
>
GetPresContext
(
)
;
if
(
!
context
)
return
NS_ERROR_FAILURE
;
bool
isCollapsed
;
nsPoint
desiredPos
(
0
0
)
;
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
RefPtr
<
Selection
>
sel
=
mDomSelections
[
index
]
;
if
(
!
sel
)
return
NS_ERROR_NULL_POINTER
;
int32_t
scrollFlags
=
Selection
:
:
SCROLL_FOR_CARET_MOVE
;
nsINode
*
focusNode
=
sel
-
>
GetFocusNode
(
)
;
if
(
focusNode
&
&
(
focusNode
-
>
IsEditable
(
)
|
|
(
focusNode
-
>
IsElement
(
)
&
&
focusNode
-
>
AsElement
(
)
-
>
State
(
)
.
HasState
(
NS_EVENT_STATE_MOZ_READWRITE
)
)
)
)
{
scrollFlags
|
=
Selection
:
:
SCROLL_OVERFLOW_HIDDEN
;
}
nsresult
result
=
sel
-
>
GetIsCollapsed
(
&
isCollapsed
)
;
if
(
NS_FAILED
(
result
)
)
{
return
result
;
}
int32_t
caretStyle
=
Preferences
:
:
GetInt
(
"
layout
.
selection
.
caret_style
"
0
)
;
if
(
caretStyle
=
=
0
#
ifdef
XP_WIN
&
&
aAmount
!
=
eSelectLine
#
endif
)
{
caretStyle
=
2
;
}
bool
doCollapse
=
!
isCollapsed
&
&
!
aContinueSelection
&
&
caretStyle
=
=
2
&
&
aAmount
<
=
eSelectLine
;
if
(
doCollapse
)
{
if
(
aDirection
=
=
eDirPrevious
)
{
PostReason
(
nsISelectionListener
:
:
COLLAPSETOSTART_REASON
)
;
mHint
=
CARET_ASSOCIATE_AFTER
;
}
else
{
PostReason
(
nsISelectionListener
:
:
COLLAPSETOEND_REASON
)
;
mHint
=
CARET_ASSOCIATE_BEFORE
;
}
}
else
{
PostReason
(
nsISelectionListener
:
:
KEYPRESS_REASON
)
;
}
AutoPrepareFocusRange
prep
(
sel
aContinueSelection
false
)
;
if
(
aAmount
=
=
eSelectLine
)
{
result
=
FetchDesiredPos
(
desiredPos
)
;
if
(
NS_FAILED
(
result
)
)
{
return
result
;
}
SetDesiredPos
(
desiredPos
)
;
}
if
(
doCollapse
)
{
const
nsRange
*
anchorFocusRange
=
sel
-
>
GetAnchorFocusRange
(
)
;
if
(
anchorFocusRange
)
{
nsINode
*
node
;
int32_t
offset
;
if
(
aDirection
=
=
eDirPrevious
)
{
node
=
anchorFocusRange
-
>
GetStartContainer
(
)
;
offset
=
anchorFocusRange
-
>
StartOffset
(
)
;
}
else
{
node
=
anchorFocusRange
-
>
GetEndContainer
(
)
;
offset
=
anchorFocusRange
-
>
EndOffset
(
)
;
}
sel
-
>
Collapse
(
node
offset
)
;
}
sel
-
>
ScrollIntoView
(
nsISelectionController
:
:
SELECTION_FOCUS_REGION
nsIPresShell
:
:
ScrollAxis
(
)
nsIPresShell
:
:
ScrollAxis
(
)
scrollFlags
)
;
return
NS_OK
;
}
nsIFrame
*
frame
;
int32_t
offsetused
=
0
;
result
=
sel
-
>
GetPrimaryFrameForFocusNode
(
&
frame
&
offsetused
visualMovement
)
;
if
(
NS_FAILED
(
result
)
|
|
!
frame
)
return
NS_FAILED
(
result
)
?
result
:
NS_ERROR_FAILURE
;
nsPeekOffsetStruct
pos
(
aAmount
eDirPrevious
offsetused
desiredPos
true
mLimiter
!
=
nullptr
true
visualMovement
aContinueSelection
)
;
nsBidiDirection
paraDir
=
nsBidiPresUtils
:
:
ParagraphDirection
(
frame
)
;
CaretAssociateHint
tHint
(
mHint
)
;
switch
(
aAmount
)
{
case
eSelectCharacter
:
case
eSelectCluster
:
case
eSelectWord
:
case
eSelectWordNoSpace
:
InvalidateDesiredPos
(
)
;
pos
.
mAmount
=
aAmount
;
pos
.
mDirection
=
(
visualMovement
&
&
paraDir
=
=
NSBIDI_RTL
)
?
nsDirection
(
1
-
aDirection
)
:
aDirection
;
break
;
case
eSelectLine
:
pos
.
mAmount
=
aAmount
;
pos
.
mDirection
=
aDirection
;
break
;
case
eSelectBeginLine
:
case
eSelectEndLine
:
InvalidateDesiredPos
(
)
;
pos
.
mAmount
=
aAmount
;
pos
.
mDirection
=
(
visualMovement
&
&
paraDir
=
=
NSBIDI_RTL
)
?
nsDirection
(
1
-
aDirection
)
:
aDirection
;
break
;
default
:
return
NS_ERROR_FAILURE
;
}
if
(
NS_SUCCEEDED
(
result
=
frame
-
>
PeekOffset
(
&
pos
)
)
&
&
pos
.
mResultContent
)
{
nsIFrame
*
theFrame
;
int32_t
currentOffset
frameStart
frameEnd
;
if
(
aAmount
<
=
eSelectWordNoSpace
)
{
theFrame
=
pos
.
mResultFrame
;
theFrame
-
>
GetOffsets
(
frameStart
frameEnd
)
;
currentOffset
=
pos
.
mContentOffset
;
if
(
frameEnd
=
=
currentOffset
&
&
!
(
frameStart
=
=
0
&
&
frameEnd
=
=
0
)
)
tHint
=
CARET_ASSOCIATE_BEFORE
;
else
tHint
=
CARET_ASSOCIATE_AFTER
;
}
else
{
tHint
=
pos
.
mAttach
;
theFrame
=
GetFrameForNodeOffset
(
pos
.
mResultContent
pos
.
mContentOffset
tHint
&
currentOffset
)
;
if
(
!
theFrame
)
return
NS_ERROR_FAILURE
;
theFrame
-
>
GetOffsets
(
frameStart
frameEnd
)
;
}
if
(
context
-
>
BidiEnabled
(
)
)
{
switch
(
aAmount
)
{
case
eSelectBeginLine
:
case
eSelectEndLine
:
{
FrameBidiData
bidiData
=
theFrame
-
>
GetBidiData
(
)
;
SetCaretBidiLevel
(
visualMovement
?
bidiData
.
embeddingLevel
:
bidiData
.
baseLevel
)
;
break
;
}
default
:
if
(
(
pos
.
mContentOffset
!
=
frameStart
&
&
pos
.
mContentOffset
!
=
frameEnd
)
|
|
eSelectLine
=
=
aAmount
)
{
SetCaretBidiLevel
(
theFrame
-
>
GetEmbeddingLevel
(
)
)
;
}
else
{
BidiLevelFromMove
(
mShell
pos
.
mResultContent
pos
.
mContentOffset
aAmount
tHint
)
;
}
}
}
result
=
TakeFocus
(
pos
.
mResultContent
pos
.
mContentOffset
pos
.
mContentOffset
tHint
aContinueSelection
false
)
;
}
else
if
(
aAmount
<
=
eSelectWordNoSpace
&
&
aDirection
=
=
eDirNext
&
&
!
aContinueSelection
)
{
bool
isBRFrame
=
frame
-
>
IsBrFrame
(
)
;
sel
-
>
Collapse
(
sel
-
>
GetFocusNode
(
)
sel
-
>
FocusOffset
(
)
)
;
if
(
!
isBRFrame
)
{
mHint
=
CARET_ASSOCIATE_BEFORE
;
}
result
=
NS_OK
;
}
if
(
NS_SUCCEEDED
(
result
)
)
{
result
=
mDomSelections
[
index
]
-
>
ScrollIntoView
(
nsISelectionController
:
:
SELECTION_FOCUS_REGION
nsIPresShell
:
:
ScrollAxis
(
)
nsIPresShell
:
:
ScrollAxis
(
)
scrollFlags
)
;
}
return
result
;
}
nsPrevNextBidiLevels
nsFrameSelection
:
:
GetPrevNextBidiLevels
(
nsIContent
*
aNode
uint32_t
aContentOffset
bool
aJumpLines
)
const
{
return
GetPrevNextBidiLevels
(
aNode
aContentOffset
mHint
aJumpLines
)
;
}
nsPrevNextBidiLevels
nsFrameSelection
:
:
GetPrevNextBidiLevels
(
nsIContent
*
aNode
uint32_t
aContentOffset
CaretAssociateHint
aHint
bool
aJumpLines
)
const
{
nsIFrame
*
currentFrame
;
int32_t
currentOffset
;
int32_t
frameStart
frameEnd
;
nsDirection
direction
;
nsPrevNextBidiLevels
levels
;
levels
.
SetData
(
nullptr
nullptr
0
0
)
;
currentFrame
=
GetFrameForNodeOffset
(
aNode
aContentOffset
aHint
&
currentOffset
)
;
if
(
!
currentFrame
)
return
levels
;
currentFrame
-
>
GetOffsets
(
frameStart
frameEnd
)
;
if
(
0
=
=
frameStart
&
&
0
=
=
frameEnd
)
direction
=
eDirPrevious
;
else
if
(
frameStart
=
=
currentOffset
)
direction
=
eDirPrevious
;
else
if
(
frameEnd
=
=
currentOffset
)
direction
=
eDirNext
;
else
{
nsBidiLevel
currentLevel
=
currentFrame
-
>
GetEmbeddingLevel
(
)
;
levels
.
SetData
(
currentFrame
currentFrame
currentLevel
currentLevel
)
;
return
levels
;
}
nsIFrame
*
newFrame
;
int32_t
offset
;
bool
jumpedLine
movedOverNonSelectableText
;
nsresult
rv
=
currentFrame
-
>
GetFrameFromDirection
(
direction
false
aJumpLines
true
&
newFrame
&
offset
&
jumpedLine
&
movedOverNonSelectableText
)
;
if
(
NS_FAILED
(
rv
)
)
newFrame
=
nullptr
;
FrameBidiData
currentBidi
=
currentFrame
-
>
GetBidiData
(
)
;
nsBidiLevel
currentLevel
=
currentBidi
.
embeddingLevel
;
nsBidiLevel
newLevel
=
newFrame
?
newFrame
-
>
GetEmbeddingLevel
(
)
:
currentBidi
.
baseLevel
;
if
(
!
aJumpLines
)
{
if
(
currentFrame
-
>
IsBrFrame
(
)
)
{
currentFrame
=
nullptr
;
currentLevel
=
currentBidi
.
baseLevel
;
}
if
(
newFrame
&
&
newFrame
-
>
IsBrFrame
(
)
)
{
newFrame
=
nullptr
;
newLevel
=
currentBidi
.
baseLevel
;
}
}
if
(
direction
=
=
eDirNext
)
levels
.
SetData
(
currentFrame
newFrame
currentLevel
newLevel
)
;
else
levels
.
SetData
(
newFrame
currentFrame
newLevel
currentLevel
)
;
return
levels
;
}
nsresult
nsFrameSelection
:
:
GetFrameFromLevel
(
nsIFrame
*
aFrameIn
nsDirection
aDirection
nsBidiLevel
aBidiLevel
nsIFrame
*
*
aFrameOut
)
const
{
NS_ENSURE_STATE
(
mShell
)
;
nsBidiLevel
foundLevel
=
0
;
nsIFrame
*
foundFrame
=
aFrameIn
;
nsCOMPtr
<
nsIFrameEnumerator
>
frameTraversal
;
nsresult
result
;
nsCOMPtr
<
nsIFrameTraversal
>
trav
(
do_CreateInstance
(
kFrameTraversalCID
&
result
)
)
;
if
(
NS_FAILED
(
result
)
)
return
result
;
result
=
trav
-
>
NewFrameTraversal
(
getter_AddRefs
(
frameTraversal
)
mShell
-
>
GetPresContext
(
)
aFrameIn
eLeaf
false
false
false
false
)
;
if
(
NS_FAILED
(
result
)
)
return
result
;
do
{
*
aFrameOut
=
foundFrame
;
if
(
aDirection
=
=
eDirNext
)
frameTraversal
-
>
Next
(
)
;
else
frameTraversal
-
>
Prev
(
)
;
foundFrame
=
frameTraversal
-
>
CurrentItem
(
)
;
if
(
!
foundFrame
)
return
NS_ERROR_FAILURE
;
foundLevel
=
foundFrame
-
>
GetEmbeddingLevel
(
)
;
}
while
(
foundLevel
>
aBidiLevel
)
;
return
NS_OK
;
}
nsresult
nsFrameSelection
:
:
MaintainSelection
(
nsSelectionAmount
aAmount
)
{
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
if
(
!
mDomSelections
[
index
]
)
return
NS_ERROR_NULL_POINTER
;
mMaintainedAmount
=
aAmount
;
const
nsRange
*
anchorFocusRange
=
mDomSelections
[
index
]
-
>
GetAnchorFocusRange
(
)
;
if
(
anchorFocusRange
&
&
aAmount
!
=
eSelectNoAmount
)
{
mMaintainRange
=
anchorFocusRange
-
>
CloneRange
(
)
;
return
NS_OK
;
}
mMaintainRange
=
nullptr
;
return
NS_OK
;
}
void
nsFrameSelection
:
:
BidiLevelFromMove
(
nsIPresShell
*
aPresShell
nsIContent
*
aNode
uint32_t
aContentOffset
nsSelectionAmount
aAmount
CaretAssociateHint
aHint
)
{
switch
(
aAmount
)
{
case
eSelectCharacter
:
case
eSelectCluster
:
case
eSelectWord
:
case
eSelectWordNoSpace
:
case
eSelectBeginLine
:
case
eSelectEndLine
:
case
eSelectNoAmount
:
{
nsPrevNextBidiLevels
levels
=
GetPrevNextBidiLevels
(
aNode
aContentOffset
aHint
false
)
;
SetCaretBidiLevel
(
aHint
=
=
CARET_ASSOCIATE_BEFORE
?
levels
.
mLevelBefore
:
levels
.
mLevelAfter
)
;
break
;
}
default
:
UndefineCaretBidiLevel
(
)
;
}
}
void
nsFrameSelection
:
:
BidiLevelFromClick
(
nsIContent
*
aNode
uint32_t
aContentOffset
)
{
nsIFrame
*
clickInFrame
=
nullptr
;
int32_t
OffsetNotUsed
;
clickInFrame
=
GetFrameForNodeOffset
(
aNode
aContentOffset
mHint
&
OffsetNotUsed
)
;
if
(
!
clickInFrame
)
return
;
SetCaretBidiLevel
(
clickInFrame
-
>
GetEmbeddingLevel
(
)
)
;
}
bool
nsFrameSelection
:
:
AdjustForMaintainedSelection
(
nsIContent
*
aContent
int32_t
aOffset
)
{
if
(
!
mMaintainRange
)
return
false
;
if
(
!
aContent
)
{
return
false
;
}
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
if
(
!
mDomSelections
[
index
]
)
return
false
;
nsINode
*
rangeStartNode
=
mMaintainRange
-
>
GetStartContainer
(
)
;
nsINode
*
rangeEndNode
=
mMaintainRange
-
>
GetEndContainer
(
)
;
int32_t
rangeStartOffset
=
mMaintainRange
-
>
StartOffset
(
)
;
int32_t
rangeEndOffset
=
mMaintainRange
-
>
EndOffset
(
)
;
int32_t
relToStart
=
nsContentUtils
:
:
ComparePoints
(
rangeStartNode
rangeStartOffset
aContent
aOffset
)
;
int32_t
relToEnd
=
nsContentUtils
:
:
ComparePoints
(
rangeEndNode
rangeEndOffset
aContent
aOffset
)
;
if
(
(
relToStart
<
0
&
&
relToEnd
>
0
)
|
|
(
relToStart
>
0
&
&
mDomSelections
[
index
]
-
>
GetDirection
(
)
=
=
eDirNext
)
|
|
(
relToEnd
<
0
&
&
mDomSelections
[
index
]
-
>
GetDirection
(
)
=
=
eDirPrevious
)
)
{
mDomSelections
[
index
]
-
>
ReplaceAnchorFocusRange
(
mMaintainRange
)
;
if
(
relToStart
<
0
&
&
relToEnd
>
0
)
{
return
true
;
}
mDomSelections
[
index
]
-
>
SetDirection
(
relToStart
>
0
?
eDirPrevious
:
eDirNext
)
;
}
return
false
;
}
nsresult
nsFrameSelection
:
:
HandleClick
(
nsIContent
*
aNewFocus
uint32_t
aContentOffset
uint32_t
aContentEndOffset
bool
aContinueSelection
bool
aMultipleSelection
CaretAssociateHint
aHint
)
{
if
(
!
aNewFocus
)
return
NS_ERROR_INVALID_ARG
;
InvalidateDesiredPos
(
)
;
if
(
!
aContinueSelection
)
{
mMaintainRange
=
nullptr
;
if
(
!
IsValidSelectionPoint
(
this
aNewFocus
)
)
{
mAncestorLimiter
=
nullptr
;
}
}
if
(
!
mDragSelectingCells
)
{
BidiLevelFromClick
(
aNewFocus
aContentOffset
)
;
PostReason
(
nsISelectionListener
:
:
MOUSEDOWN_REASON
+
nsISelectionListener
:
:
DRAG_REASON
)
;
if
(
aContinueSelection
&
&
AdjustForMaintainedSelection
(
aNewFocus
aContentOffset
)
)
return
NS_OK
;
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
AutoPrepareFocusRange
prep
(
mDomSelections
[
index
]
aContinueSelection
aMultipleSelection
)
;
return
TakeFocus
(
aNewFocus
aContentOffset
aContentEndOffset
aHint
aContinueSelection
aMultipleSelection
)
;
}
return
NS_OK
;
}
void
nsFrameSelection
:
:
HandleDrag
(
nsIFrame
*
aFrame
nsPoint
aPoint
)
{
if
(
!
aFrame
|
|
!
mShell
)
return
;
nsresult
result
;
nsIFrame
*
newFrame
=
0
;
nsPoint
newPoint
;
result
=
ConstrainFrameAndPointToAnchorSubtree
(
aFrame
aPoint
&
newFrame
newPoint
)
;
if
(
NS_FAILED
(
result
)
)
return
;
if
(
!
newFrame
)
return
;
nsIFrame
:
:
ContentOffsets
offsets
=
newFrame
-
>
GetContentOffsetsFromPoint
(
newPoint
)
;
if
(
!
offsets
.
content
)
return
;
if
(
newFrame
-
>
IsSelected
(
)
&
&
AdjustForMaintainedSelection
(
offsets
.
content
offsets
.
offset
)
)
return
;
if
(
mMaintainRange
&
&
mMaintainedAmount
!
=
eSelectNoAmount
)
{
nsINode
*
rangenode
=
mMaintainRange
-
>
GetStartContainer
(
)
;
int32_t
rangeOffset
=
mMaintainRange
-
>
StartOffset
(
)
;
int32_t
relativePosition
=
nsContentUtils
:
:
ComparePoints
(
rangenode
rangeOffset
offsets
.
content
offsets
.
offset
)
;
nsDirection
direction
=
relativePosition
>
0
?
eDirPrevious
:
eDirNext
;
nsSelectionAmount
amount
=
mMaintainedAmount
;
if
(
amount
=
=
eSelectBeginLine
&
&
direction
=
=
eDirNext
)
amount
=
eSelectEndLine
;
int32_t
offset
;
nsIFrame
*
frame
=
GetFrameForNodeOffset
(
offsets
.
content
offsets
.
offset
CARET_ASSOCIATE_AFTER
&
offset
)
;
if
(
frame
&
&
amount
=
=
eSelectWord
&
&
direction
=
=
eDirPrevious
)
{
nsPeekOffsetStruct
charPos
(
eSelectCharacter
eDirNext
offset
nsPoint
(
0
0
)
false
mLimiter
!
=
nullptr
false
false
false
)
;
if
(
NS_SUCCEEDED
(
frame
-
>
PeekOffset
(
&
charPos
)
)
)
{
frame
=
charPos
.
mResultFrame
;
offset
=
charPos
.
mContentOffset
;
}
}
nsPeekOffsetStruct
pos
(
amount
direction
offset
nsPoint
(
0
0
)
false
mLimiter
!
=
nullptr
false
false
false
)
;
if
(
frame
&
&
NS_SUCCEEDED
(
frame
-
>
PeekOffset
(
&
pos
)
)
&
&
pos
.
mResultContent
)
{
offsets
.
content
=
pos
.
mResultContent
;
offsets
.
offset
=
pos
.
mContentOffset
;
}
}
HandleClick
(
offsets
.
content
offsets
.
offset
offsets
.
offset
true
false
offsets
.
associate
)
;
}
nsresult
nsFrameSelection
:
:
StartAutoScrollTimer
(
nsIFrame
*
aFrame
nsPoint
aPoint
uint32_t
aDelay
)
{
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
if
(
!
mDomSelections
[
index
]
)
{
return
NS_ERROR_NULL_POINTER
;
}
return
mDomSelections
[
index
]
-
>
StartAutoScrollTimer
(
aFrame
aPoint
aDelay
)
;
}
void
nsFrameSelection
:
:
StopAutoScrollTimer
(
)
{
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
if
(
!
mDomSelections
[
index
]
)
{
return
;
}
mDomSelections
[
index
]
-
>
StopAutoScrollTimer
(
)
;
}
nsresult
nsFrameSelection
:
:
TakeFocus
(
nsIContent
*
aNewFocus
uint32_t
aContentOffset
uint32_t
aContentEndOffset
CaretAssociateHint
aHint
bool
aContinueSelection
bool
aMultipleSelection
)
{
if
(
!
aNewFocus
)
return
NS_ERROR_NULL_POINTER
;
NS_ENSURE_STATE
(
mShell
)
;
if
(
!
IsValidSelectionPoint
(
this
aNewFocus
)
)
return
NS_ERROR_FAILURE
;
mSelectingTableCellMode
=
0
;
mDragSelectingCells
=
false
;
mStartSelectedCell
=
nullptr
;
mEndSelectedCell
=
nullptr
;
mAppendStartSelectedCell
=
nullptr
;
mHint
=
aHint
;
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
if
(
!
mDomSelections
[
index
]
)
return
NS_ERROR_NULL_POINTER
;
Maybe
<
Selection
:
:
AutoUserInitiated
>
userSelect
;
if
(
IsUserSelectionReason
(
)
)
{
userSelect
.
emplace
(
mDomSelections
[
index
]
)
;
}
if
(
!
aContinueSelection
)
{
uint32_t
batching
=
mBatching
;
bool
changes
=
mChangesDuringBatching
;
mBatching
=
1
;
if
(
aMultipleSelection
)
{
mDomSelections
[
index
]
-
>
RemoveCollapsedRanges
(
)
;
RefPtr
<
nsRange
>
newRange
=
new
nsRange
(
aNewFocus
)
;
newRange
-
>
CollapseTo
(
aNewFocus
aContentOffset
)
;
mDomSelections
[
index
]
-
>
AddRange
(
newRange
)
;
mBatching
=
batching
;
mChangesDuringBatching
=
changes
;
}
else
{
bool
oldDesiredPosSet
=
mDesiredPosSet
;
mDomSelections
[
index
]
-
>
Collapse
(
aNewFocus
aContentOffset
)
;
mDesiredPosSet
=
oldDesiredPosSet
;
mBatching
=
batching
;
mChangesDuringBatching
=
changes
;
}
if
(
aContentEndOffset
!
=
aContentOffset
)
{
mDomSelections
[
index
]
-
>
Extend
(
aNewFocus
aContentEndOffset
)
;
}
NS_ENSURE_STATE
(
mShell
)
;
bool
editableCell
=
false
;
RefPtr
<
nsPresContext
>
context
=
mShell
-
>
GetPresContext
(
)
;
if
(
context
)
{
nsCOMPtr
<
nsIHTMLEditor
>
editor
=
do_QueryInterface
(
nsContentUtils
:
:
GetHTMLEditor
(
context
)
)
;
if
(
editor
)
{
nsINode
*
cellparent
=
GetCellParent
(
aNewFocus
)
;
nsCOMPtr
<
nsINode
>
editorHostNode
=
editor
-
>
GetActiveEditingHost
(
)
;
editableCell
=
cellparent
&
&
editorHostNode
&
&
nsContentUtils
:
:
ContentIsDescendantOf
(
cellparent
editorHostNode
)
;
if
(
editableCell
)
{
mCellParent
=
cellparent
;
#
ifdef
DEBUG_TABLE_SELECTION
printf
(
"
*
TakeFocus
-
Collapsing
into
new
cell
\
n
"
)
;
#
endif
}
}
}
}
else
{
if
(
aContinueSelection
&
&
aNewFocus
)
{
int32_t
offset
;
nsINode
*
cellparent
=
GetCellParent
(
aNewFocus
)
;
if
(
mCellParent
&
&
cellparent
&
&
cellparent
!
=
mCellParent
)
{
#
ifdef
DEBUG_TABLE_SELECTION
printf
(
"
*
TakeFocus
-
moving
into
new
cell
\
n
"
)
;
#
endif
WidgetMouseEvent
event
(
false
eVoidEvent
nullptr
WidgetMouseEvent
:
:
eReal
)
;
nsINode
*
parent
=
ParentOffset
(
mCellParent
&
offset
)
;
if
(
parent
)
HandleTableSelection
(
parent
offset
nsISelectionPrivate
:
:
TABLESELECTION_CELL
&
event
)
;
parent
=
ParentOffset
(
cellparent
&
offset
)
;
event
.
mModifiers
&
=
~
MODIFIER_SHIFT
;
if
(
parent
)
{
mCellParent
=
cellparent
;
HandleTableSelection
(
parent
offset
nsISelectionPrivate
:
:
TABLESELECTION_CELL
&
event
)
;
}
}
else
{
if
(
mDomSelections
[
index
]
-
>
GetDirection
(
)
=
=
eDirNext
&
&
aContentEndOffset
>
aContentOffset
)
{
mDomSelections
[
index
]
-
>
Extend
(
aNewFocus
aContentEndOffset
)
;
}
else
mDomSelections
[
index
]
-
>
Extend
(
aNewFocus
aContentOffset
)
;
}
}
}
if
(
GetBatching
(
)
)
return
NS_OK
;
return
NotifySelectionListeners
(
SelectionType
:
:
eNormal
)
;
}
UniquePtr
<
SelectionDetails
>
nsFrameSelection
:
:
LookUpSelection
(
nsIContent
*
aContent
int32_t
aContentOffset
int32_t
aContentLength
bool
aSlowCheck
)
const
{
if
(
!
aContent
|
|
!
mShell
)
return
nullptr
;
UniquePtr
<
SelectionDetails
>
details
;
for
(
size_t
j
=
0
;
j
<
kPresentSelectionTypeCount
;
j
+
+
)
{
if
(
mDomSelections
[
j
]
)
{
details
=
mDomSelections
[
j
]
-
>
LookUpSelection
(
aContent
aContentOffset
aContentLength
Move
(
details
)
ToSelectionType
(
1
<
<
j
)
aSlowCheck
)
;
}
}
return
details
;
}
void
nsFrameSelection
:
:
SetDragState
(
bool
aState
)
{
if
(
mDragState
=
=
aState
)
return
;
mDragState
=
aState
;
if
(
!
mDragState
)
{
mDragSelectingCells
=
false
;
PostReason
(
nsISelectionListener
:
:
MOUSEUP_REASON
)
;
NotifySelectionListeners
(
SelectionType
:
:
eNormal
)
;
}
}
Selection
*
nsFrameSelection
:
:
GetSelection
(
SelectionType
aSelectionType
)
const
{
int8_t
index
=
GetIndexFromSelectionType
(
aSelectionType
)
;
if
(
index
<
0
)
return
nullptr
;
return
mDomSelections
[
index
]
;
}
nsresult
nsFrameSelection
:
:
ScrollSelectionIntoView
(
SelectionType
aSelectionType
SelectionRegion
aRegion
int16_t
aFlags
)
const
{
int8_t
index
=
GetIndexFromSelectionType
(
aSelectionType
)
;
if
(
index
<
0
)
return
NS_ERROR_INVALID_ARG
;
if
(
!
mDomSelections
[
index
]
)
return
NS_ERROR_NULL_POINTER
;
nsIPresShell
:
:
ScrollAxis
verticalScroll
=
nsIPresShell
:
:
ScrollAxis
(
)
;
int32_t
flags
=
Selection
:
:
SCROLL_DO_FLUSH
;
if
(
aFlags
&
nsISelectionController
:
:
SCROLL_SYNCHRONOUS
)
{
flags
|
=
Selection
:
:
SCROLL_SYNCHRONOUS
;
}
else
if
(
aFlags
&
nsISelectionController
:
:
SCROLL_FIRST_ANCESTOR_ONLY
)
{
flags
|
=
Selection
:
:
SCROLL_FIRST_ANCESTOR_ONLY
;
}
if
(
aFlags
&
nsISelectionController
:
:
SCROLL_OVERFLOW_HIDDEN
)
{
flags
|
=
Selection
:
:
SCROLL_OVERFLOW_HIDDEN
;
}
if
(
aFlags
&
nsISelectionController
:
:
SCROLL_CENTER_VERTICALLY
)
{
verticalScroll
=
nsIPresShell
:
:
ScrollAxis
(
nsIPresShell
:
:
SCROLL_CENTER
nsIPresShell
:
:
SCROLL_IF_NOT_FULLY_VISIBLE
)
;
}
if
(
aFlags
&
nsISelectionController
:
:
SCROLL_FOR_CARET_MOVE
)
{
flags
|
=
Selection
:
:
SCROLL_FOR_CARET_MOVE
;
}
RefPtr
<
Selection
>
sel
=
mDomSelections
[
index
]
;
return
sel
-
>
ScrollIntoView
(
aRegion
verticalScroll
nsIPresShell
:
:
ScrollAxis
(
)
flags
)
;
}
nsresult
nsFrameSelection
:
:
RepaintSelection
(
SelectionType
aSelectionType
)
{
int8_t
index
=
GetIndexFromSelectionType
(
aSelectionType
)
;
if
(
index
<
0
)
return
NS_ERROR_INVALID_ARG
;
if
(
!
mDomSelections
[
index
]
)
return
NS_ERROR_NULL_POINTER
;
NS_ENSURE_STATE
(
mShell
)
;
#
ifdef
XP_MACOSX
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
fm
-
>
GetActiveWindow
(
)
&
&
aSelectionType
=
=
SelectionType
:
:
eNormal
)
{
UpdateSelectionCacheOnRepaintSelection
(
mDomSelections
[
index
]
)
;
}
#
endif
return
mDomSelections
[
index
]
-
>
Repaint
(
mShell
-
>
GetPresContext
(
)
)
;
}
nsIFrame
*
nsFrameSelection
:
:
GetFrameForNodeOffset
(
nsIContent
*
aNode
int32_t
aOffset
CaretAssociateHint
aHint
int32_t
*
aReturnOffset
)
const
{
if
(
!
aNode
|
|
!
aReturnOffset
|
|
!
mShell
)
return
nullptr
;
if
(
aOffset
<
0
)
return
nullptr
;
if
(
!
aNode
-
>
GetPrimaryFrame
(
)
&
&
!
mShell
-
>
FrameManager
(
)
-
>
GetDisplayContentsStyleFor
(
aNode
)
)
{
return
nullptr
;
}
nsIFrame
*
returnFrame
=
nullptr
;
nsCOMPtr
<
nsIContent
>
theNode
;
while
(
true
)
{
*
aReturnOffset
=
aOffset
;
theNode
=
aNode
;
if
(
aNode
-
>
IsElement
(
)
)
{
int32_t
childIndex
=
0
;
int32_t
numChildren
=
theNode
-
>
GetChildCount
(
)
;
if
(
aHint
=
=
CARET_ASSOCIATE_BEFORE
)
{
if
(
aOffset
>
0
)
{
childIndex
=
aOffset
-
1
;
}
else
{
childIndex
=
aOffset
;
}
}
else
{
NS_ASSERTION
(
aHint
=
=
CARET_ASSOCIATE_AFTER
"
unknown
direction
"
)
;
if
(
aOffset
>
=
numChildren
)
{
if
(
numChildren
>
0
)
{
childIndex
=
numChildren
-
1
;
}
else
{
childIndex
=
0
;
}
}
else
{
childIndex
=
aOffset
;
}
}
if
(
childIndex
>
0
|
|
numChildren
>
0
)
{
nsCOMPtr
<
nsIContent
>
childNode
=
theNode
-
>
GetChildAt
(
childIndex
)
;
if
(
!
childNode
)
{
break
;
}
theNode
=
childNode
;
}
if
(
theNode
-
>
IsElement
(
)
&
&
theNode
-
>
GetChildCount
(
)
&
&
!
theNode
-
>
HasIndependentSelection
(
)
)
{
aNode
=
theNode
;
aOffset
=
aOffset
>
childIndex
?
theNode
-
>
GetChildCount
(
)
:
0
;
continue
;
}
else
{
nsCOMPtr
<
nsIDOMText
>
textNode
=
do_QueryInterface
(
theNode
)
;
if
(
textNode
)
{
if
(
theNode
-
>
GetPrimaryFrame
(
)
)
{
if
(
aOffset
>
childIndex
)
{
uint32_t
textLength
=
0
;
nsresult
rv
=
textNode
-
>
GetLength
(
&
textLength
)
;
if
(
NS_FAILED
(
rv
)
)
{
break
;
}
*
aReturnOffset
=
(
int32_t
)
textLength
;
}
else
{
*
aReturnOffset
=
0
;
}
}
else
{
int32_t
numChildren
=
aNode
-
>
GetChildCount
(
)
;
int32_t
newChildIndex
=
aHint
=
=
CARET_ASSOCIATE_BEFORE
?
childIndex
-
1
:
childIndex
+
1
;
if
(
newChildIndex
>
=
0
&
&
newChildIndex
<
numChildren
)
{
nsCOMPtr
<
nsIContent
>
newChildNode
=
aNode
-
>
GetChildAt
(
newChildIndex
)
;
if
(
!
newChildNode
)
{
return
nullptr
;
}
aNode
=
newChildNode
;
aOffset
=
aHint
=
=
CARET_ASSOCIATE_BEFORE
?
aNode
-
>
GetChildCount
(
)
:
0
;
continue
;
}
else
{
theNode
=
aNode
;
}
}
}
}
}
mozilla
:
:
dom
:
:
ShadowRoot
*
shadowRoot
=
mozilla
:
:
dom
:
:
ShadowRoot
:
:
FromNode
(
theNode
)
;
if
(
shadowRoot
)
{
theNode
=
shadowRoot
-
>
GetHost
(
)
;
}
returnFrame
=
theNode
-
>
GetPrimaryFrame
(
)
;
if
(
!
returnFrame
)
{
if
(
aHint
=
=
CARET_ASSOCIATE_BEFORE
)
{
if
(
aOffset
>
0
)
{
-
-
aOffset
;
continue
;
}
else
{
break
;
}
}
else
{
int32_t
end
=
theNode
-
>
GetChildCount
(
)
;
if
(
aOffset
<
end
)
{
+
+
aOffset
;
continue
;
}
else
{
break
;
}
}
}
break
;
}
if
(
!
returnFrame
)
return
nullptr
;
if
(
aOffset
>
0
&
&
(
uint32_t
)
aOffset
>
=
aNode
-
>
Length
(
)
&
&
theNode
=
=
aNode
-
>
GetLastChild
(
)
)
{
nsIFrame
*
newFrame
;
nsLayoutUtils
:
:
IsInvisibleBreak
(
theNode
&
newFrame
)
;
if
(
newFrame
)
{
returnFrame
=
newFrame
;
*
aReturnOffset
=
0
;
}
}
returnFrame
-
>
GetChildFrameContainingOffset
(
*
aReturnOffset
aHint
=
=
CARET_ASSOCIATE_AFTER
&
aOffset
&
returnFrame
)
;
return
returnFrame
;
}
void
nsFrameSelection
:
:
CommonPageMove
(
bool
aForward
bool
aExtend
nsIScrollableFrame
*
aScrollableFrame
)
{
nsIFrame
*
scrolledFrame
=
aScrollableFrame
-
>
GetScrolledFrame
(
)
;
if
(
!
scrolledFrame
)
return
;
nsISelection
*
domSel
=
GetSelection
(
SelectionType
:
:
eNormal
)
;
if
(
!
domSel
)
{
return
;
}
nsRect
caretPos
;
nsIFrame
*
caretFrame
=
nsCaret
:
:
GetGeometry
(
domSel
&
caretPos
)
;
if
(
!
caretFrame
)
return
;
nsSize
scrollDelta
=
aScrollableFrame
-
>
GetPageScrollAmount
(
)
;
if
(
aForward
)
caretPos
.
y
+
=
scrollDelta
.
height
;
else
caretPos
.
y
-
=
scrollDelta
.
height
;
caretPos
+
=
caretFrame
-
>
GetOffsetTo
(
scrolledFrame
)
;
nsPoint
desiredPoint
;
desiredPoint
.
x
=
caretPos
.
x
;
desiredPoint
.
y
=
caretPos
.
y
+
caretPos
.
height
/
2
;
nsIFrame
:
:
ContentOffsets
offsets
=
scrolledFrame
-
>
GetContentOffsetsFromPoint
(
desiredPoint
)
;
if
(
!
offsets
.
content
)
return
;
mozilla
:
:
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
SCROLL_INPUT_METHODS
(
uint32_t
)
ScrollInputMethod
:
:
MainThreadScrollPage
)
;
aScrollableFrame
-
>
ScrollBy
(
nsIntPoint
(
0
aForward
?
1
:
-
1
)
nsIScrollableFrame
:
:
PAGES
nsIScrollableFrame
:
:
SMOOTH
)
;
HandleClick
(
offsets
.
content
offsets
.
offset
offsets
.
offset
aExtend
false
CARET_ASSOCIATE_AFTER
)
;
}
nsresult
nsFrameSelection
:
:
PhysicalMove
(
int16_t
aDirection
int16_t
aAmount
bool
aExtend
)
{
NS_ENSURE_STATE
(
mShell
)
;
mShell
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
if
(
!
mShell
)
{
return
NS_OK
;
}
if
(
aDirection
<
0
|
|
aDirection
>
3
|
|
aAmount
<
0
|
|
aAmount
>
1
)
{
return
NS_ERROR_FAILURE
;
}
nsPresContext
*
context
=
mShell
-
>
GetPresContext
(
)
;
if
(
!
context
)
{
return
NS_ERROR_FAILURE
;
}
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
RefPtr
<
Selection
>
sel
=
mDomSelections
[
index
]
;
if
(
!
sel
)
{
return
NS_ERROR_NULL_POINTER
;
}
static
const
nsSelectionAmount
inlineAmount
[
]
=
{
eSelectCluster
eSelectWord
}
;
static
const
nsSelectionAmount
blockPrevAmount
[
]
=
{
eSelectLine
eSelectBeginLine
}
;
static
const
nsSelectionAmount
blockNextAmount
[
]
=
{
eSelectLine
eSelectEndLine
}
;
struct
PhysicalToLogicalMapping
{
nsDirection
direction
;
const
nsSelectionAmount
*
amounts
;
}
;
static
const
PhysicalToLogicalMapping
verticalLR
[
4
]
=
{
{
eDirPrevious
blockPrevAmount
}
{
eDirNext
blockNextAmount
}
{
eDirPrevious
inlineAmount
}
{
eDirNext
inlineAmount
}
}
;
static
const
PhysicalToLogicalMapping
verticalRL
[
4
]
=
{
{
eDirNext
blockNextAmount
}
{
eDirPrevious
blockPrevAmount
}
{
eDirPrevious
inlineAmount
}
{
eDirNext
inlineAmount
}
}
;
static
const
PhysicalToLogicalMapping
horizontal
[
4
]
=
{
{
eDirPrevious
inlineAmount
}
{
eDirNext
inlineAmount
}
{
eDirPrevious
blockPrevAmount
}
{
eDirNext
blockNextAmount
}
}
;
WritingMode
wm
;
nsIFrame
*
frame
=
nullptr
;
int32_t
offsetused
=
0
;
if
(
NS_SUCCEEDED
(
sel
-
>
GetPrimaryFrameForFocusNode
(
&
frame
&
offsetused
true
)
)
)
{
if
(
frame
)
{
if
(
!
frame
-
>
StyleContext
(
)
-
>
IsTextCombined
(
)
)
{
wm
=
frame
-
>
GetWritingMode
(
)
;
}
else
{
MOZ_ASSERT
(
frame
-
>
IsTextFrame
(
)
)
;
wm
=
frame
-
>
GetParent
(
)
-
>
GetWritingMode
(
)
;
MOZ_ASSERT
(
wm
.
IsVertical
(
)
"
Text
combined
"
"
can
only
appear
in
vertical
text
"
)
;
}
}
}
const
PhysicalToLogicalMapping
&
mapping
=
wm
.
IsVertical
(
)
?
wm
.
IsVerticalLR
(
)
?
verticalLR
[
aDirection
]
:
verticalRL
[
aDirection
]
:
horizontal
[
aDirection
]
;
nsresult
rv
=
MoveCaret
(
mapping
.
direction
aExtend
mapping
.
amounts
[
aAmount
]
eVisual
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
mapping
.
amounts
[
aAmount
]
=
=
eSelectLine
)
{
rv
=
MoveCaret
(
mapping
.
direction
aExtend
mapping
.
amounts
[
aAmount
+
1
]
eVisual
)
;
}
else
if
(
mapping
.
amounts
[
aAmount
]
=
=
eSelectWord
&
&
mapping
.
direction
=
=
eDirNext
)
{
rv
=
MoveCaret
(
eDirNext
aExtend
eSelectEndLine
eVisual
)
;
}
}
return
rv
;
}
nsresult
nsFrameSelection
:
:
CharacterMove
(
bool
aForward
bool
aExtend
)
{
return
MoveCaret
(
aForward
?
eDirNext
:
eDirPrevious
aExtend
eSelectCluster
eUsePrefStyle
)
;
}
nsresult
nsFrameSelection
:
:
CharacterExtendForDelete
(
)
{
return
MoveCaret
(
eDirNext
true
eSelectCluster
eLogical
)
;
}
nsresult
nsFrameSelection
:
:
CharacterExtendForBackspace
(
)
{
return
MoveCaret
(
eDirPrevious
true
eSelectCharacter
eLogical
)
;
}
nsresult
nsFrameSelection
:
:
WordMove
(
bool
aForward
bool
aExtend
)
{
return
MoveCaret
(
aForward
?
eDirNext
:
eDirPrevious
aExtend
eSelectWord
eUsePrefStyle
)
;
}
nsresult
nsFrameSelection
:
:
WordExtendForDelete
(
bool
aForward
)
{
return
MoveCaret
(
aForward
?
eDirNext
:
eDirPrevious
true
eSelectWord
eLogical
)
;
}
nsresult
nsFrameSelection
:
:
LineMove
(
bool
aForward
bool
aExtend
)
{
return
MoveCaret
(
aForward
?
eDirNext
:
eDirPrevious
aExtend
eSelectLine
eUsePrefStyle
)
;
}
nsresult
nsFrameSelection
:
:
IntraLineMove
(
bool
aForward
bool
aExtend
)
{
if
(
aForward
)
{
return
MoveCaret
(
eDirNext
aExtend
eSelectEndLine
eLogical
)
;
}
else
{
return
MoveCaret
(
eDirPrevious
aExtend
eSelectBeginLine
eLogical
)
;
}
}
nsresult
nsFrameSelection
:
:
SelectAll
(
)
{
nsCOMPtr
<
nsIContent
>
rootContent
;
if
(
mLimiter
)
{
rootContent
=
mLimiter
;
}
else
if
(
mAncestorLimiter
)
{
rootContent
=
mAncestorLimiter
;
}
else
{
NS_ENSURE_STATE
(
mShell
)
;
nsIDocument
*
doc
=
mShell
-
>
GetDocument
(
)
;
if
(
!
doc
)
return
NS_ERROR_FAILURE
;
rootContent
=
doc
-
>
GetRootElement
(
)
;
if
(
!
rootContent
)
return
NS_ERROR_FAILURE
;
}
int32_t
numChildren
=
rootContent
-
>
GetChildCount
(
)
;
PostReason
(
nsISelectionListener
:
:
NO_REASON
)
;
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
AutoPrepareFocusRange
prep
(
mDomSelections
[
index
]
false
false
)
;
return
TakeFocus
(
rootContent
0
numChildren
CARET_ASSOCIATE_BEFORE
false
false
)
;
}
void
nsFrameSelection
:
:
StartBatchChanges
(
)
{
mBatching
+
+
;
}
void
nsFrameSelection
:
:
EndBatchChanges
(
int16_t
aReason
)
{
mBatching
-
-
;
NS_ASSERTION
(
mBatching
>
=
0
"
Bad
mBatching
"
)
;
if
(
mBatching
=
=
0
&
&
mChangesDuringBatching
)
{
int16_t
postReason
=
PopReason
(
)
|
aReason
;
PostReason
(
postReason
)
;
mChangesDuringBatching
=
false
;
NotifySelectionListeners
(
SelectionType
:
:
eNormal
)
;
}
}
nsresult
nsFrameSelection
:
:
NotifySelectionListeners
(
SelectionType
aSelectionType
)
{
int8_t
index
=
GetIndexFromSelectionType
(
aSelectionType
)
;
if
(
index
>
=
0
&
&
mDomSelections
[
index
]
)
{
RefPtr
<
Selection
>
selection
=
mDomSelections
[
index
]
;
return
selection
-
>
NotifySelectionListeners
(
)
;
}
return
NS_ERROR_FAILURE
;
}
static
bool
IsCell
(
nsIContent
*
aContent
)
{
return
aContent
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
td
nsGkAtoms
:
:
th
)
;
}
nsITableCellLayout
*
nsFrameSelection
:
:
GetCellLayout
(
nsIContent
*
aCellContent
)
const
{
NS_ENSURE_TRUE
(
mShell
nullptr
)
;
nsITableCellLayout
*
cellLayoutObject
=
do_QueryFrame
(
aCellContent
-
>
GetPrimaryFrame
(
)
)
;
return
cellLayoutObject
;
}
nsresult
nsFrameSelection
:
:
ClearNormalSelection
(
)
{
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
if
(
!
mDomSelections
[
index
]
)
return
NS_ERROR_NULL_POINTER
;
return
mDomSelections
[
index
]
-
>
RemoveAllRanges
(
)
;
}
static
nsIContent
*
GetFirstSelectedContent
(
nsRange
*
aRange
)
{
if
(
!
aRange
)
{
return
nullptr
;
}
NS_PRECONDITION
(
aRange
-
>
GetStartContainer
(
)
"
Must
have
start
parent
!
"
)
;
NS_PRECONDITION
(
aRange
-
>
GetStartContainer
(
)
-
>
IsElement
(
)
"
Unexpected
parent
"
)
;
return
aRange
-
>
GetStartContainer
(
)
-
>
GetChildAt
(
aRange
-
>
StartOffset
(
)
)
;
}
nsresult
nsFrameSelection
:
:
HandleTableSelection
(
nsINode
*
aParentContent
int32_t
aContentOffset
int32_t
aTarget
WidgetMouseEvent
*
aMouseEvent
)
{
NS_ENSURE_TRUE
(
aParentContent
NS_ERROR_NULL_POINTER
)
;
NS_ENSURE_TRUE
(
aMouseEvent
NS_ERROR_NULL_POINTER
)
;
if
(
mDragState
&
&
mDragSelectingCells
&
&
(
aTarget
&
nsISelectionPrivate
:
:
TABLESELECTION_TABLE
)
)
{
return
NS_OK
;
}
nsresult
result
=
NS_OK
;
nsIContent
*
childContent
=
aParentContent
-
>
GetChildAt
(
aContentOffset
)
;
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
if
(
!
mDomSelections
[
index
]
)
return
NS_ERROR_NULL_POINTER
;
mDomSelections
[
index
]
-
>
SetDirection
(
eDirNext
)
;
SelectionBatcher
selectionBatcher
(
mDomSelections
[
index
]
)
;
int32_t
startRowIndex
startColIndex
curRowIndex
curColIndex
;
if
(
mDragState
&
&
mDragSelectingCells
)
{
if
(
aTarget
!
=
nsISelectionPrivate
:
:
TABLESELECTION_TABLE
)
{
if
(
mEndSelectedCell
=
=
childContent
)
return
NS_OK
;
#
ifdef
DEBUG_TABLE_SELECTION
printf
(
"
mStartSelectedCell
=
%
p
mEndSelectedCell
=
%
p
childContent
=
%
p
\
n
"
mStartSelectedCell
.
get
(
)
mEndSelectedCell
.
get
(
)
childContent
)
;
#
endif
if
(
mSelectingTableCellMode
=
=
nsISelectionPrivate
:
:
TABLESELECTION_ROW
|
|
mSelectingTableCellMode
=
=
nsISelectionPrivate
:
:
TABLESELECTION_COLUMN
)
{
if
(
mEndSelectedCell
)
{
result
=
GetCellIndexes
(
mEndSelectedCell
startRowIndex
startColIndex
)
;
if
(
NS_FAILED
(
result
)
)
return
result
;
result
=
GetCellIndexes
(
childContent
curRowIndex
curColIndex
)
;
if
(
NS_FAILED
(
result
)
)
return
result
;
#
ifdef
DEBUG_TABLE_SELECTION
printf
(
"
curRowIndex
=
%
d
startRowIndex
=
%
d
curColIndex
=
%
d
startColIndex
=
%
d
\
n
"
curRowIndex
startRowIndex
curColIndex
startColIndex
)
;
#
endif
if
(
(
mSelectingTableCellMode
=
=
nsISelectionPrivate
:
:
TABLESELECTION_ROW
&
&
startRowIndex
=
=
curRowIndex
)
|
|
(
mSelectingTableCellMode
=
=
nsISelectionPrivate
:
:
TABLESELECTION_COLUMN
&
&
startColIndex
=
=
curColIndex
)
)
return
NS_OK
;
}
#
ifdef
DEBUG_TABLE_SELECTION
printf
(
"
Dragged
into
a
new
column
or
row
\
n
"
)
;
#
endif
return
SelectRowOrColumn
(
childContent
mSelectingTableCellMode
)
;
}
else
if
(
mSelectingTableCellMode
=
=
nsISelectionPrivate
:
:
TABLESELECTION_CELL
)
{
#
ifdef
DEBUG_TABLE_SELECTION
printf
(
"
HandleTableSelection
:
Dragged
into
a
new
cell
\
n
"
)
;
#
endif
if
(
mStartSelectedCell
&
&
aMouseEvent
-
>
IsShift
(
)
)
{
result
=
GetCellIndexes
(
mStartSelectedCell
startRowIndex
startColIndex
)
;
if
(
NS_FAILED
(
result
)
)
return
result
;
result
=
GetCellIndexes
(
childContent
curRowIndex
curColIndex
)
;
if
(
NS_FAILED
(
result
)
)
return
result
;
if
(
startRowIndex
=
=
curRowIndex
|
|
startColIndex
=
=
curColIndex
)
{
mStartSelectedCell
=
nullptr
;
mDomSelections
[
index
]
-
>
RemoveAllRanges
(
)
;
if
(
startRowIndex
=
=
curRowIndex
)
mSelectingTableCellMode
=
nsISelectionPrivate
:
:
TABLESELECTION_ROW
;
else
mSelectingTableCellMode
=
nsISelectionPrivate
:
:
TABLESELECTION_COLUMN
;
return
SelectRowOrColumn
(
childContent
mSelectingTableCellMode
)
;
}
}
return
SelectBlockOfCells
(
mStartSelectedCell
childContent
)
;
}
}
return
NS_OK
;
}
else
{
if
(
mDragState
)
{
#
ifdef
DEBUG_TABLE_SELECTION
printf
(
"
HandleTableSelection
:
Mouse
down
event
\
n
"
)
;
#
endif
mUnselectCellOnMouseUp
=
nullptr
;
if
(
aTarget
=
=
nsISelectionPrivate
:
:
TABLESELECTION_CELL
)
{
bool
isSelected
=
false
;
nsIContent
*
previousCellNode
=
GetFirstSelectedContent
(
GetFirstCellRange
(
)
)
;
if
(
previousCellNode
)
{
nsIFrame
*
cellFrame
=
childContent
-
>
GetPrimaryFrame
(
)
;
if
(
!
cellFrame
)
return
NS_ERROR_NULL_POINTER
;
isSelected
=
cellFrame
-
>
IsSelected
(
)
;
}
else
{
mDomSelections
[
index
]
-
>
RemoveAllRanges
(
)
;
}
mDragSelectingCells
=
true
;
mSelectingTableCellMode
=
aTarget
;
mStartSelectedCell
=
childContent
;
mEndSelectedCell
=
childContent
;
if
(
isSelected
)
{
mUnselectCellOnMouseUp
=
childContent
;
#
ifdef
DEBUG_TABLE_SELECTION
printf
(
"
HandleTableSelection
:
Saving
mUnselectCellOnMouseUp
\
n
"
)
;
#
endif
}
else
{
if
(
previousCellNode
&
&
!
IsInSameTable
(
previousCellNode
childContent
)
)
{
mDomSelections
[
index
]
-
>
RemoveAllRanges
(
)
;
mSelectingTableCellMode
=
aTarget
;
}
return
SelectCellElement
(
childContent
)
;
}
return
NS_OK
;
}
else
if
(
aTarget
=
=
nsISelectionPrivate
:
:
TABLESELECTION_TABLE
)
{
mDragSelectingCells
=
false
;
mStartSelectedCell
=
nullptr
;
mEndSelectedCell
=
nullptr
;
mDomSelections
[
index
]
-
>
RemoveAllRanges
(
)
;
return
CreateAndAddRange
(
aParentContent
aContentOffset
)
;
}
else
if
(
aTarget
=
=
nsISelectionPrivate
:
:
TABLESELECTION_ROW
|
|
aTarget
=
=
nsISelectionPrivate
:
:
TABLESELECTION_COLUMN
)
{
#
ifdef
DEBUG_TABLE_SELECTION
printf
(
"
aTarget
=
=
%
d
\
n
"
aTarget
)
;
#
endif
mDragSelectingCells
=
true
;
mStartSelectedCell
=
nullptr
;
mDomSelections
[
index
]
-
>
RemoveAllRanges
(
)
;
mSelectingTableCellMode
=
aTarget
;
return
SelectRowOrColumn
(
childContent
aTarget
)
;
}
}
else
{
#
ifdef
DEBUG_TABLE_SELECTION
printf
(
"
HandleTableSelection
:
Mouse
UP
event
.
mDragSelectingCells
=
%
d
mStartSelectedCell
=
%
p
\
n
"
mDragSelectingCells
mStartSelectedCell
.
get
(
)
)
;
#
endif
int32_t
rangeCount
;
result
=
mDomSelections
[
index
]
-
>
GetRangeCount
(
&
rangeCount
)
;
if
(
NS_FAILED
(
result
)
)
return
result
;
if
(
rangeCount
>
0
&
&
aMouseEvent
-
>
IsShift
(
)
&
&
mAppendStartSelectedCell
&
&
mAppendStartSelectedCell
!
=
childContent
)
{
mDragSelectingCells
=
false
;
return
SelectBlockOfCells
(
mAppendStartSelectedCell
childContent
)
;
}
if
(
mDragSelectingCells
)
mAppendStartSelectedCell
=
mStartSelectedCell
;
mDragSelectingCells
=
false
;
mStartSelectedCell
=
nullptr
;
mEndSelectedCell
=
nullptr
;
bool
doMouseUpAction
=
false
;
#
ifdef
XP_MACOSX
doMouseUpAction
=
aMouseEvent
-
>
IsMeta
(
)
;
#
else
doMouseUpAction
=
aMouseEvent
-
>
IsControl
(
)
;
#
endif
if
(
!
doMouseUpAction
)
{
#
ifdef
DEBUG_TABLE_SELECTION
printf
(
"
HandleTableSelection
:
Ending
cell
selection
on
mouseup
:
mAppendStartSelectedCell
=
%
p
\
n
"
mAppendStartSelectedCell
.
get
(
)
)
;
#
endif
return
NS_OK
;
}
if
(
childContent
=
=
mUnselectCellOnMouseUp
)
{
nsINode
*
previousCellParent
=
nullptr
;
#
ifdef
DEBUG_TABLE_SELECTION
printf
(
"
HandleTableSelection
:
Unselecting
mUnselectCellOnMouseUp
;
rangeCount
=
%
d
\
n
"
rangeCount
)
;
#
endif
for
(
int32_t
i
=
0
;
i
<
rangeCount
;
i
+
+
)
{
RefPtr
<
nsRange
>
range
=
mDomSelections
[
index
]
-
>
GetRangeAt
(
i
)
;
if
(
!
range
)
return
NS_ERROR_NULL_POINTER
;
nsINode
*
container
=
range
-
>
GetStartContainer
(
)
;
if
(
!
container
)
{
return
NS_ERROR_NULL_POINTER
;
}
int32_t
offset
=
range
-
>
StartOffset
(
)
;
nsIContent
*
child
=
container
-
>
GetChildAt
(
offset
)
;
if
(
child
&
&
IsCell
(
child
)
)
{
previousCellParent
=
container
;
}
if
(
!
previousCellParent
)
break
;
if
(
previousCellParent
=
=
aParentContent
&
&
offset
=
=
aContentOffset
)
{
if
(
rangeCount
=
=
1
)
{
#
ifdef
DEBUG_TABLE_SELECTION
printf
(
"
HandleTableSelection
:
Unselecting
single
selected
cell
\
n
"
)
;
#
endif
mStartSelectedCell
=
nullptr
;
mEndSelectedCell
=
nullptr
;
mAppendStartSelectedCell
=
nullptr
;
return
mDomSelections
[
index
]
-
>
Collapse
(
childContent
0
)
;
}
#
ifdef
DEBUG_TABLE_SELECTION
printf
(
"
HandleTableSelection
:
Removing
cell
from
multi
-
cell
selection
\
n
"
)
;
#
endif
if
(
childContent
=
=
mAppendStartSelectedCell
)
mAppendStartSelectedCell
=
nullptr
;
return
mDomSelections
[
index
]
-
>
RemoveRange
(
range
)
;
}
}
mUnselectCellOnMouseUp
=
nullptr
;
}
}
}
return
result
;
}
nsresult
nsFrameSelection
:
:
SelectBlockOfCells
(
nsIContent
*
aStartCell
nsIContent
*
aEndCell
)
{
NS_ENSURE_TRUE
(
aStartCell
NS_ERROR_NULL_POINTER
)
;
NS_ENSURE_TRUE
(
aEndCell
NS_ERROR_NULL_POINTER
)
;
mEndSelectedCell
=
aEndCell
;
nsresult
result
=
NS_OK
;
nsIContent
*
table
=
IsInSameTable
(
aStartCell
aEndCell
)
;
if
(
!
table
)
{
return
NS_OK
;
}
int32_t
startRowIndex
startColIndex
endRowIndex
endColIndex
;
result
=
GetCellIndexes
(
aStartCell
startRowIndex
startColIndex
)
;
if
(
NS_FAILED
(
result
)
)
return
result
;
result
=
GetCellIndexes
(
aEndCell
endRowIndex
endColIndex
)
;
if
(
NS_FAILED
(
result
)
)
return
result
;
if
(
mDragSelectingCells
)
{
UnselectCells
(
table
startRowIndex
startColIndex
endRowIndex
endColIndex
true
)
;
}
return
AddCellsToSelection
(
table
startRowIndex
startColIndex
endRowIndex
endColIndex
)
;
}
nsresult
nsFrameSelection
:
:
UnselectCells
(
nsIContent
*
aTableContent
int32_t
aStartRowIndex
int32_t
aStartColumnIndex
int32_t
aEndRowIndex
int32_t
aEndColumnIndex
bool
aRemoveOutsideOfCellRange
)
{
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
if
(
!
mDomSelections
[
index
]
)
return
NS_ERROR_NULL_POINTER
;
nsTableWrapperFrame
*
tableFrame
=
do_QueryFrame
(
aTableContent
-
>
GetPrimaryFrame
(
)
)
;
if
(
!
tableFrame
)
return
NS_ERROR_FAILURE
;
int32_t
minRowIndex
=
std
:
:
min
(
aStartRowIndex
aEndRowIndex
)
;
int32_t
maxRowIndex
=
std
:
:
max
(
aStartRowIndex
aEndRowIndex
)
;
int32_t
minColIndex
=
std
:
:
min
(
aStartColumnIndex
aEndColumnIndex
)
;
int32_t
maxColIndex
=
std
:
:
max
(
aStartColumnIndex
aEndColumnIndex
)
;
RefPtr
<
nsRange
>
range
=
GetFirstCellRange
(
)
;
nsIContent
*
cellNode
=
GetFirstSelectedContent
(
range
)
;
NS_PRECONDITION
(
!
range
|
|
cellNode
"
Must
have
cellNode
if
had
a
range
"
)
;
int32_t
curRowIndex
curColIndex
;
while
(
cellNode
)
{
nsresult
result
=
GetCellIndexes
(
cellNode
curRowIndex
curColIndex
)
;
if
(
NS_FAILED
(
result
)
)
return
result
;
#
ifdef
DEBUG_TABLE_SELECTION
if
(
!
range
)
printf
(
"
RemoveCellsToSelection
-
-
range
is
null
\
n
"
)
;
#
endif
if
(
range
)
{
if
(
aRemoveOutsideOfCellRange
)
{
if
(
curRowIndex
<
minRowIndex
|
|
curRowIndex
>
maxRowIndex
|
|
curColIndex
<
minColIndex
|
|
curColIndex
>
maxColIndex
)
{
mDomSelections
[
index
]
-
>
RemoveRange
(
range
)
;
mSelectedCellIndex
-
-
;
}
}
else
{
nsTableCellFrame
*
cellFrame
=
tableFrame
-
>
GetCellFrameAt
(
curRowIndex
curColIndex
)
;
int32_t
origRowIndex
origColIndex
;
cellFrame
-
>
GetRowIndex
(
origRowIndex
)
;
cellFrame
-
>
GetColIndex
(
origColIndex
)
;
uint32_t
actualRowSpan
=
tableFrame
-
>
GetEffectiveRowSpanAt
(
origRowIndex
origColIndex
)
;
uint32_t
actualColSpan
=
tableFrame
-
>
GetEffectiveColSpanAt
(
curRowIndex
curColIndex
)
;
if
(
origRowIndex
<
=
maxRowIndex
&
&
maxRowIndex
>
=
0
&
&
origRowIndex
+
actualRowSpan
-
1
>
=
static_cast
<
uint32_t
>
(
minRowIndex
)
&
&
origColIndex
<
=
maxColIndex
&
&
maxColIndex
>
=
0
&
&
origColIndex
+
actualColSpan
-
1
>
=
static_cast
<
uint32_t
>
(
minColIndex
)
)
{
mDomSelections
[
index
]
-
>
RemoveRange
(
range
)
;
mSelectedCellIndex
-
-
;
}
}
}
range
=
GetNextCellRange
(
)
;
cellNode
=
GetFirstSelectedContent
(
range
)
;
NS_PRECONDITION
(
!
range
|
|
cellNode
"
Must
have
cellNode
if
had
a
range
"
)
;
}
return
NS_OK
;
}
nsresult
nsFrameSelection
:
:
AddCellsToSelection
(
nsIContent
*
aTableContent
int32_t
aStartRowIndex
int32_t
aStartColumnIndex
int32_t
aEndRowIndex
int32_t
aEndColumnIndex
)
{
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
if
(
!
mDomSelections
[
index
]
)
return
NS_ERROR_NULL_POINTER
;
nsTableWrapperFrame
*
tableFrame
=
do_QueryFrame
(
aTableContent
-
>
GetPrimaryFrame
(
)
)
;
if
(
!
tableFrame
)
return
NS_ERROR_FAILURE
;
nsresult
result
=
NS_OK
;
int32_t
row
=
aStartRowIndex
;
while
(
true
)
{
int32_t
col
=
aStartColumnIndex
;
while
(
true
)
{
nsTableCellFrame
*
cellFrame
=
tableFrame
-
>
GetCellFrameAt
(
row
col
)
;
if
(
cellFrame
)
{
int32_t
origRow
origCol
;
cellFrame
-
>
GetRowIndex
(
origRow
)
;
cellFrame
-
>
GetColIndex
(
origCol
)
;
if
(
origRow
=
=
row
&
&
origCol
=
=
col
&
&
!
cellFrame
-
>
IsSelected
(
)
)
{
result
=
SelectCellElement
(
cellFrame
-
>
GetContent
(
)
)
;
if
(
NS_FAILED
(
result
)
)
return
result
;
}
}
if
(
col
=
=
aEndColumnIndex
)
break
;
if
(
aStartColumnIndex
<
aEndColumnIndex
)
col
+
+
;
else
col
-
-
;
}
if
(
row
=
=
aEndRowIndex
)
break
;
if
(
aStartRowIndex
<
aEndRowIndex
)
row
+
+
;
else
row
-
-
;
}
return
result
;
}
nsresult
nsFrameSelection
:
:
RemoveCellsFromSelection
(
nsIContent
*
aTable
int32_t
aStartRowIndex
int32_t
aStartColumnIndex
int32_t
aEndRowIndex
int32_t
aEndColumnIndex
)
{
return
UnselectCells
(
aTable
aStartRowIndex
aStartColumnIndex
aEndRowIndex
aEndColumnIndex
false
)
;
}
nsresult
nsFrameSelection
:
:
RestrictCellsToSelection
(
nsIContent
*
aTable
int32_t
aStartRowIndex
int32_t
aStartColumnIndex
int32_t
aEndRowIndex
int32_t
aEndColumnIndex
)
{
return
UnselectCells
(
aTable
aStartRowIndex
aStartColumnIndex
aEndRowIndex
aEndColumnIndex
true
)
;
}
nsresult
nsFrameSelection
:
:
SelectRowOrColumn
(
nsIContent
*
aCellContent
uint32_t
aTarget
)
{
if
(
!
aCellContent
)
return
NS_ERROR_NULL_POINTER
;
nsIContent
*
table
=
GetParentTable
(
aCellContent
)
;
if
(
!
table
)
return
NS_ERROR_NULL_POINTER
;
nsTableWrapperFrame
*
tableFrame
=
do_QueryFrame
(
table
-
>
GetPrimaryFrame
(
)
)
;
if
(
!
tableFrame
)
return
NS_ERROR_FAILURE
;
nsITableCellLayout
*
cellLayout
=
GetCellLayout
(
aCellContent
)
;
if
(
!
cellLayout
)
return
NS_ERROR_FAILURE
;
int32_t
rowIndex
colIndex
;
nsresult
result
=
cellLayout
-
>
GetCellIndexes
(
rowIndex
colIndex
)
;
if
(
NS_FAILED
(
result
)
)
return
result
;
if
(
aTarget
=
=
nsISelectionPrivate
:
:
TABLESELECTION_ROW
)
colIndex
=
0
;
if
(
aTarget
=
=
nsISelectionPrivate
:
:
TABLESELECTION_COLUMN
)
rowIndex
=
0
;
nsCOMPtr
<
nsIContent
>
firstCell
lastCell
;
while
(
true
)
{
nsCOMPtr
<
nsIContent
>
curCellContent
=
tableFrame
-
>
GetCellAt
(
rowIndex
colIndex
)
;
if
(
!
curCellContent
)
break
;
if
(
!
firstCell
)
firstCell
=
curCellContent
;
lastCell
=
curCellContent
.
forget
(
)
;
if
(
aTarget
=
=
nsISelectionPrivate
:
:
TABLESELECTION_ROW
)
colIndex
+
=
tableFrame
-
>
GetEffectiveRowSpanAt
(
rowIndex
colIndex
)
;
else
rowIndex
+
=
tableFrame
-
>
GetEffectiveRowSpanAt
(
rowIndex
colIndex
)
;
}
if
(
firstCell
&
&
lastCell
)
{
if
(
!
mStartSelectedCell
)
{
result
=
SelectCellElement
(
firstCell
)
;
if
(
NS_FAILED
(
result
)
)
return
result
;
mStartSelectedCell
=
firstCell
;
}
nsCOMPtr
<
nsIContent
>
lastCellContent
=
do_QueryInterface
(
lastCell
)
;
result
=
SelectBlockOfCells
(
mStartSelectedCell
lastCellContent
)
;
mEndSelectedCell
=
aCellContent
;
return
result
;
}
#
if
0
do
{
result
=
tableLayout
-
>
GetCellDataAt
(
rowIndex
colIndex
getter_AddRefs
(
cellElement
)
curRowIndex
curColIndex
rowSpan
colSpan
actualRowSpan
actualColSpan
isSelected
)
;
if
(
NS_FAILED
(
result
)
)
return
result
;
if
(
!
cellElement
)
break
;
NS_ASSERTION
(
actualColSpan
"
actualColSpan
is
0
!
"
)
;
NS_ASSERTION
(
actualRowSpan
"
actualRowSpan
is
0
!
"
)
;
if
(
!
isSelected
&
&
rowIndex
=
=
curRowIndex
&
&
colIndex
=
=
curColIndex
)
{
result
=
SelectCellElement
(
cellElement
)
;
if
(
NS_FAILED
(
result
)
)
return
result
;
}
if
(
aTarget
=
=
nsISelectionPrivate
:
:
TABLESELECTION_ROW
)
colIndex
+
=
actualColSpan
;
else
rowIndex
+
=
actualRowSpan
;
}
while
(
cellElement
)
;
#
endif
return
NS_OK
;
}
nsIContent
*
nsFrameSelection
:
:
GetFirstCellNodeInRange
(
nsRange
*
aRange
)
const
{
if
(
!
aRange
)
return
nullptr
;
nsINode
*
startContainer
=
aRange
-
>
GetStartContainer
(
)
;
if
(
!
startContainer
)
{
return
nullptr
;
}
int32_t
offset
=
aRange
-
>
StartOffset
(
)
;
nsIContent
*
childContent
=
startContainer
-
>
GetChildAt
(
offset
)
;
if
(
!
childContent
)
return
nullptr
;
if
(
!
IsCell
(
childContent
)
)
return
nullptr
;
return
childContent
;
}
nsRange
*
nsFrameSelection
:
:
GetFirstCellRange
(
)
{
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
if
(
!
mDomSelections
[
index
]
)
return
nullptr
;
nsRange
*
firstRange
=
mDomSelections
[
index
]
-
>
GetRangeAt
(
0
)
;
if
(
!
GetFirstCellNodeInRange
(
firstRange
)
)
{
return
nullptr
;
}
mSelectedCellIndex
=
1
;
return
firstRange
;
}
nsRange
*
nsFrameSelection
:
:
GetNextCellRange
(
)
{
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
if
(
!
mDomSelections
[
index
]
)
return
nullptr
;
nsRange
*
range
=
mDomSelections
[
index
]
-
>
GetRangeAt
(
mSelectedCellIndex
)
;
if
(
!
GetFirstCellNodeInRange
(
range
)
)
{
return
nullptr
;
}
mSelectedCellIndex
+
+
;
return
range
;
}
nsresult
nsFrameSelection
:
:
GetCellIndexes
(
nsIContent
*
aCell
int32_t
&
aRowIndex
int32_t
&
aColIndex
)
{
if
(
!
aCell
)
return
NS_ERROR_NULL_POINTER
;
aColIndex
=
0
;
aRowIndex
=
0
;
nsITableCellLayout
*
cellLayoutObject
=
GetCellLayout
(
aCell
)
;
if
(
!
cellLayoutObject
)
return
NS_ERROR_FAILURE
;
return
cellLayoutObject
-
>
GetCellIndexes
(
aRowIndex
aColIndex
)
;
}
nsIContent
*
nsFrameSelection
:
:
IsInSameTable
(
nsIContent
*
aContent1
nsIContent
*
aContent2
)
const
{
if
(
!
aContent1
|
|
!
aContent2
)
return
nullptr
;
nsIContent
*
tableNode1
=
GetParentTable
(
aContent1
)
;
nsIContent
*
tableNode2
=
GetParentTable
(
aContent2
)
;
return
(
tableNode1
=
=
tableNode2
)
?
tableNode1
:
nullptr
;
}
nsIContent
*
nsFrameSelection
:
:
GetParentTable
(
nsIContent
*
aCell
)
const
{
if
(
!
aCell
)
{
return
nullptr
;
}
for
(
nsIContent
*
parent
=
aCell
-
>
GetParent
(
)
;
parent
;
parent
=
parent
-
>
GetParent
(
)
)
{
if
(
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
{
return
parent
;
}
}
return
nullptr
;
}
nsresult
nsFrameSelection
:
:
SelectCellElement
(
nsIContent
*
aCellElement
)
{
nsIContent
*
parent
=
aCellElement
-
>
GetParent
(
)
;
int32_t
offset
=
parent
-
>
IndexOf
(
aCellElement
)
;
return
CreateAndAddRange
(
parent
offset
)
;
}
nsresult
nsFrameSelection
:
:
CreateAndAddRange
(
nsINode
*
aContainer
int32_t
aOffset
)
{
if
(
!
aContainer
)
{
return
NS_ERROR_NULL_POINTER
;
}
RefPtr
<
nsRange
>
range
=
new
nsRange
(
aContainer
)
;
nsresult
rv
=
range
-
>
SetStartAndEnd
(
aContainer
aOffset
aContainer
aOffset
+
1
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
if
(
!
mDomSelections
[
index
]
)
return
NS_ERROR_NULL_POINTER
;
return
mDomSelections
[
index
]
-
>
AddRange
(
range
)
;
}
void
nsFrameSelection
:
:
SetAncestorLimiter
(
nsIContent
*
aLimiter
)
{
if
(
mAncestorLimiter
!
=
aLimiter
)
{
mAncestorLimiter
=
aLimiter
;
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
if
(
!
mDomSelections
[
index
]
)
return
;
if
(
!
IsValidSelectionPoint
(
this
mDomSelections
[
index
]
-
>
GetFocusNode
(
)
)
)
{
ClearNormalSelection
(
)
;
if
(
mAncestorLimiter
)
{
PostReason
(
nsISelectionListener
:
:
NO_REASON
)
;
TakeFocus
(
mAncestorLimiter
0
0
CARET_ASSOCIATE_BEFORE
false
false
)
;
}
}
}
}
nsresult
nsFrameSelection
:
:
DeleteFromDocument
(
)
{
nsresult
res
;
bool
isCollapsed
;
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
if
(
!
mDomSelections
[
index
]
)
return
NS_ERROR_NULL_POINTER
;
mDomSelections
[
index
]
-
>
GetIsCollapsed
(
&
isCollapsed
)
;
if
(
isCollapsed
)
{
return
NS_OK
;
}
RefPtr
<
Selection
>
selection
=
mDomSelections
[
index
]
;
for
(
uint32_t
rangeIdx
=
0
;
rangeIdx
<
selection
-
>
RangeCount
(
)
;
+
+
rangeIdx
)
{
RefPtr
<
nsRange
>
range
=
selection
-
>
GetRangeAt
(
rangeIdx
)
;
res
=
range
-
>
DeleteContents
(
)
;
if
(
NS_FAILED
(
res
)
)
return
res
;
}
if
(
isCollapsed
)
mDomSelections
[
index
]
-
>
Collapse
(
mDomSelections
[
index
]
-
>
GetAnchorNode
(
)
mDomSelections
[
index
]
-
>
AnchorOffset
(
)
-
1
)
;
else
if
(
mDomSelections
[
index
]
-
>
AnchorOffset
(
)
>
0
)
mDomSelections
[
index
]
-
>
Collapse
(
mDomSelections
[
index
]
-
>
GetAnchorNode
(
)
mDomSelections
[
index
]
-
>
AnchorOffset
(
)
)
;
#
ifdef
DEBUG
else
printf
(
"
Don
'
t
know
how
to
set
selection
back
past
frame
boundary
\
n
"
)
;
#
endif
return
NS_OK
;
}
void
nsFrameSelection
:
:
SetDelayedCaretData
(
WidgetMouseEvent
*
aMouseEvent
)
{
if
(
aMouseEvent
)
{
mDelayedMouseEventValid
=
true
;
mDelayedMouseEventIsShift
=
aMouseEvent
-
>
IsShift
(
)
;
mDelayedMouseEventClickCount
=
aMouseEvent
-
>
mClickCount
;
}
else
{
mDelayedMouseEventValid
=
false
;
}
}
void
nsFrameSelection
:
:
DisconnectFromPresShell
(
)
{
RefPtr
<
AccessibleCaretEventHub
>
eventHub
=
mShell
-
>
GetAccessibleCaretEventHub
(
)
;
if
(
eventHub
)
{
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
mDomSelections
[
index
]
-
>
RemoveSelectionListener
(
eventHub
)
;
}
StopAutoScrollTimer
(
)
;
for
(
size_t
i
=
0
;
i
<
kPresentSelectionTypeCount
;
i
+
+
)
{
mDomSelections
[
i
]
-
>
Clear
(
nullptr
)
;
}
mShell
=
nullptr
;
}
nsresult
nsFrameSelection
:
:
UpdateSelectionCacheOnRepaintSelection
(
Selection
*
aSel
)
{
nsIPresShell
*
ps
=
aSel
-
>
GetPresShell
(
)
;
if
(
!
ps
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIDocument
>
aDoc
=
ps
-
>
GetDocument
(
)
;
bool
collapsed
;
if
(
aDoc
&
&
aSel
&
&
NS_SUCCEEDED
(
aSel
-
>
GetIsCollapsed
(
&
collapsed
)
)
&
&
!
collapsed
)
{
return
nsCopySupport
:
:
HTMLCopy
(
aSel
aDoc
nsIClipboard
:
:
kSelectionCache
false
)
;
}
return
NS_OK
;
}
nsAutoCopyListener
*
nsAutoCopyListener
:
:
sInstance
=
nullptr
;
NS_IMPL_ISUPPORTS
(
nsAutoCopyListener
nsISelectionListener
)
NS_IMETHODIMP
nsAutoCopyListener
:
:
NotifySelectionChanged
(
nsIDOMDocument
*
aDoc
nsISelection
*
aSel
int16_t
aReason
)
{
if
(
mCachedClipboard
=
=
nsIClipboard
:
:
kSelectionCache
)
{
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
!
fm
-
>
GetActiveWindow
(
)
)
{
return
NS_OK
;
}
}
if
(
!
(
aReason
&
nsISelectionListener
:
:
MOUSEUP_REASON
|
|
aReason
&
nsISelectionListener
:
:
SELECTALL_REASON
|
|
aReason
&
nsISelectionListener
:
:
KEYPRESS_REASON
)
)
return
NS_OK
;
bool
collapsed
;
if
(
!
aDoc
|
|
!
aSel
|
|
NS_FAILED
(
aSel
-
>
GetIsCollapsed
(
&
collapsed
)
)
|
|
collapsed
)
{
#
ifdef
DEBUG_CLIPBOARD
fprintf
(
stderr
"
CLIPBOARD
:
no
selection
/
collapsed
selection
\
n
"
)
;
#
endif
if
(
mCachedClipboard
=
=
nsIClipboard
:
:
kSelectionCache
)
{
return
nsCopySupport
:
:
ClearSelectionCache
(
)
;
}
return
NS_OK
;
}
nsCOMPtr
<
nsIDocument
>
doc
=
do_QueryInterface
(
aDoc
)
;
NS_ENSURE_TRUE
(
doc
NS_ERROR_FAILURE
)
;
return
nsCopySupport
:
:
HTMLCopy
(
aSel
doc
mCachedClipboard
false
)
;
}
