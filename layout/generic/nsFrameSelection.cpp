#
include
"
nsFrameSelection
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
ScrollTypes
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDebug
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsISelectionListener
.
h
"
#
include
"
nsContentCID
.
h
"
#
include
"
nsDeviceContext
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsITableCellLayout
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTableWrapperFrame
.
h
"
#
include
"
nsTableCellFrame
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsCCUncollectableMarker
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
<
algorithm
>
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIFrameTraversal
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsLayoutCID
.
h
"
#
include
"
nsBidiPresUtils
.
h
"
static
NS_DEFINE_CID
(
kFrameTraversalCID
NS_FRAMETRAVERSAL_CID
)
;
#
include
"
nsTextFrame
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsCaret
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsCopySupport
.
h
"
#
include
"
nsIClipboard
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsError
.
h
"
#
include
"
mozilla
/
AutoCopyListener
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
ShadowRoot
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
dom
/
SelectionBinding
.
h
"
#
include
"
mozilla
/
AsyncEventDispatcher
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
static
nsresult
AddCellsToSelection
(
nsIContent
*
aTableContent
int32_t
aStartRowIndex
int32_t
aStartColumnIndex
int32_t
aEndRowIndex
int32_t
aEndColumnIndex
Selection
&
aNormalSelection
)
;
static
nsAtom
*
GetTag
(
nsINode
*
aNode
)
;
static
nsINode
*
ParentOffset
(
nsINode
*
aNode
int32_t
*
aChildOffset
)
;
static
nsINode
*
GetCellParent
(
nsINode
*
aDomNode
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
static
nsresult
CreateAndAddRange
(
nsINode
*
aContainer
int32_t
aOffset
Selection
&
aNormalSelection
)
;
static
nsresult
SelectCellElement
(
nsIContent
*
aCellElement
Selection
&
aNormalSelection
)
;
#
ifdef
XP_MACOSX
static
nsresult
UpdateSelectionCacheOnRepaintSelection
(
Selection
*
aSel
)
;
#
endif
#
ifdef
PRINT_RANGE
static
void
printRange
(
nsRange
*
aDomRange
)
;
#
define
DEBUG_OUT_RANGE
(
x
)
printRange
(
x
)
#
else
#
define
DEBUG_OUT_RANGE
(
x
)
#
endif
nsPeekOffsetStruct
:
:
nsPeekOffsetStruct
(
nsSelectionAmount
aAmount
nsDirection
aDirection
int32_t
aStartOffset
nsPoint
aDesiredPos
bool
aJumpLines
bool
aScrollViewStop
bool
aIsKeyboardSelect
bool
aVisual
bool
aExtend
ForceEditableRegion
aForceEditableRegion
EWordMovementType
aWordMovementType
bool
aTrimSpaces
)
:
mAmount
(
aAmount
)
mDirection
(
aDirection
)
mStartOffset
(
aStartOffset
)
mDesiredPos
(
aDesiredPos
)
mWordMovementType
(
aWordMovementType
)
mJumpLines
(
aJumpLines
)
mTrimSpaces
(
aTrimSpaces
)
mScrollViewStop
(
aScrollViewStop
)
mIsKeyboardSelect
(
aIsKeyboardSelect
)
mVisual
(
aVisual
)
mExtend
(
aExtend
)
mForceEditableRegion
(
aForceEditableRegion
=
=
ForceEditableRegion
:
:
Yes
)
mResultContent
(
)
mResultFrame
(
nullptr
)
mContentOffset
(
0
)
mAttach
(
CARET_ASSOCIATE_BEFORE
)
{
}
static
const
int8_t
kIndexOfSelections
[
]
=
{
-
1
-
1
0
1
2
3
4
5
6
7
8
9
}
;
inline
int8_t
GetIndexFromSelectionType
(
SelectionType
aSelectionType
)
{
return
kIndexOfSelections
[
static_cast
<
int8_t
>
(
aSelectionType
)
+
1
]
;
}
bool
nsFrameSelection
:
:
IsValidSelectionPoint
(
nsINode
*
aNode
)
const
{
if
(
!
aNode
)
{
return
false
;
}
nsIContent
*
limiter
=
GetLimiter
(
)
;
if
(
limiter
&
&
limiter
!
=
aNode
&
&
limiter
!
=
aNode
-
>
GetParent
(
)
)
{
return
false
;
}
limiter
=
GetAncestorLimiter
(
)
;
return
!
limiter
|
|
aNode
-
>
IsInclusiveDescendantOf
(
limiter
)
;
}
namespace
mozilla
{
struct
MOZ_RAII
AutoPrepareFocusRange
{
AutoPrepareFocusRange
(
Selection
*
aSelection
const
bool
aMultiRangeSelection
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
MOZ_ASSERT
(
aSelection
)
;
MOZ_ASSERT
(
aSelection
-
>
GetType
(
)
=
=
SelectionType
:
:
eNormal
)
;
if
(
aSelection
-
>
mRanges
.
Length
(
)
<
=
1
)
{
return
;
}
if
(
aSelection
-
>
mFrameSelection
-
>
IsUserSelectionReason
(
)
)
{
mUserSelect
.
emplace
(
aSelection
)
;
}
bool
userSelection
=
aSelection
-
>
mUserInitiated
;
nsTArray
<
StyledRange
>
&
ranges
=
aSelection
-
>
mRanges
;
if
(
!
userSelection
|
|
aMultiRangeSelection
)
{
for
(
StyledRange
&
entry
:
ranges
)
{
entry
.
mRange
-
>
SetIsGenerated
(
false
)
;
}
return
;
}
int16_t
reason
=
aSelection
-
>
mFrameSelection
-
>
mSelectionChangeReasons
;
bool
isAnchorRelativeOp
=
(
reason
&
(
nsISelectionListener
:
:
DRAG_REASON
|
nsISelectionListener
:
:
MOUSEDOWN_REASON
|
nsISelectionListener
:
:
MOUSEUP_REASON
|
nsISelectionListener
:
:
COLLAPSETOSTART_REASON
)
)
;
if
(
!
isAnchorRelativeOp
)
{
return
;
}
const
size_t
len
=
ranges
.
Length
(
)
;
size_t
newAnchorFocusIndex
=
size_t
(
-
1
)
;
if
(
aSelection
-
>
GetDirection
(
)
=
=
eDirNext
)
{
for
(
size_t
i
=
0
;
i
<
len
;
+
+
i
)
{
if
(
ranges
[
i
]
.
mRange
-
>
IsGenerated
(
)
)
{
newAnchorFocusIndex
=
i
;
break
;
}
}
}
else
{
size_t
i
=
len
;
while
(
i
-
-
)
{
if
(
ranges
[
i
]
.
mRange
-
>
IsGenerated
(
)
)
{
newAnchorFocusIndex
=
i
;
break
;
}
}
}
if
(
newAnchorFocusIndex
=
=
size_t
(
-
1
)
)
{
return
;
}
if
(
aSelection
-
>
mAnchorFocusRange
)
{
aSelection
-
>
mAnchorFocusRange
-
>
SetIsGenerated
(
true
)
;
}
nsRange
*
range
=
ranges
[
newAnchorFocusIndex
]
.
mRange
;
range
-
>
SetIsGenerated
(
false
)
;
aSelection
-
>
mAnchorFocusRange
=
range
;
RefPtr
<
nsPresContext
>
presContext
=
aSelection
-
>
GetPresContext
(
)
;
size_t
i
=
len
;
while
(
i
-
-
)
{
range
=
aSelection
-
>
mRanges
[
i
]
.
mRange
;
if
(
range
-
>
IsGenerated
(
)
)
{
range
-
>
UnregisterSelection
(
)
;
aSelection
-
>
SelectFrames
(
presContext
range
false
)
;
aSelection
-
>
mRanges
.
RemoveElementAt
(
i
)
;
}
}
if
(
aSelection
-
>
mFrameSelection
)
{
aSelection
-
>
mFrameSelection
-
>
InvalidateDesiredPos
(
)
;
}
}
Maybe
<
Selection
:
:
AutoUserInitiated
>
mUserSelect
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
}
nsFrameSelection
:
:
nsFrameSelection
(
PresShell
*
aPresShell
nsIContent
*
aLimiter
const
bool
aAccessibleCaretEnabled
)
{
for
(
size_t
i
=
0
;
i
<
ArrayLength
(
mDomSelections
)
;
i
+
+
)
{
mDomSelections
[
i
]
=
new
Selection
(
kPresentSelectionTypes
[
i
]
this
)
;
}
#
ifdef
XP_MACOSX
bool
enableAutoCopy
=
true
;
AutoCopyListener
:
:
Init
(
nsIClipboard
:
:
kSelectionCache
)
;
#
else
bool
enableAutoCopy
=
AutoCopyListener
:
:
IsPrefEnabled
(
)
;
if
(
enableAutoCopy
)
{
AutoCopyListener
:
:
Init
(
nsIClipboard
:
:
kSelectionClipboard
)
;
}
#
endif
if
(
enableAutoCopy
)
{
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
if
(
mDomSelections
[
index
]
)
{
mDomSelections
[
index
]
-
>
NotifyAutoCopy
(
)
;
}
}
mPresShell
=
aPresShell
;
mDragState
=
false
;
mDesiredPos
.
mIsSet
=
false
;
mLimiters
.
mLimiter
=
aLimiter
;
mCaret
.
mMovementStyle
=
Preferences
:
:
GetInt
(
"
bidi
.
edit
.
caret_movement_style
"
2
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
static
bool
prefCachesInitialized
=
false
;
if
(
!
prefCachesInitialized
)
{
prefCachesInitialized
=
true
;
Preferences
:
:
AddBoolVarCache
(
&
sSelectionEventsOnTextControlsEnabled
"
dom
.
select_events
.
textcontrols
.
enabled
"
false
)
;
}
mAccessibleCaretEnabled
=
aAccessibleCaretEnabled
;
if
(
mAccessibleCaretEnabled
)
{
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
mDomSelections
[
index
]
-
>
MaybeNotifyAccessibleCaretEventHub
(
aPresShell
)
;
}
bool
plaintextControl
=
(
aLimiter
!
=
nullptr
)
;
bool
initSelectEvents
=
plaintextControl
?
sSelectionEventsOnTextControlsEnabled
:
StaticPrefs
:
:
dom_select_events_enabled
(
)
;
Document
*
doc
=
aPresShell
-
>
GetDocument
(
)
;
if
(
initSelectEvents
|
|
(
doc
&
&
doc
-
>
NodePrincipal
(
)
-
>
IsSystemPrincipal
(
)
)
)
{
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
if
(
mDomSelections
[
index
]
)
{
mDomSelections
[
index
]
-
>
EnableSelectionChangeEvent
(
)
;
}
}
}
nsFrameSelection
:
:
~
nsFrameSelection
(
)
=
default
;
NS_IMPL_CYCLE_COLLECTION_CLASS
(
nsFrameSelection
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
nsFrameSelection
)
for
(
size_t
i
=
0
;
i
<
ArrayLength
(
tmp
-
>
mDomSelections
)
;
+
+
i
)
{
tmp
-
>
mDomSelections
[
i
]
=
nullptr
;
}
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mTableSelection
.
mCellParent
)
tmp
-
>
mTableSelection
.
mMode
=
TableSelectionMode
:
:
None
;
tmp
-
>
mTableSelection
.
mDragSelectingCells
=
false
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mTableSelection
.
mStartSelectedCell
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mTableSelection
.
mEndSelectedCell
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mTableSelection
.
mAppendStartSelectedCell
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mTableSelection
.
mUnselectCellOnMouseUp
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mMaintainedRange
.
mRange
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mLimiters
.
mLimiter
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mLimiters
.
mAncestorLimiter
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
nsFrameSelection
)
if
(
tmp
-
>
mPresShell
&
&
tmp
-
>
mPresShell
-
>
GetDocument
(
)
&
&
nsCCUncollectableMarker
:
:
InGeneration
(
cb
tmp
-
>
mPresShell
-
>
GetDocument
(
)
-
>
GetMarkedCCGeneration
(
)
)
)
{
return
NS_SUCCESS_INTERRUPTED_TRAVERSE
;
}
for
(
size_t
i
=
0
;
i
<
ArrayLength
(
tmp
-
>
mDomSelections
)
;
+
+
i
)
{
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDomSelections
[
i
]
)
}
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTableSelection
.
mCellParent
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTableSelection
.
mStartSelectedCell
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTableSelection
.
mEndSelectedCell
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTableSelection
.
mAppendStartSelectedCell
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mTableSelection
.
mUnselectCellOnMouseUp
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mMaintainedRange
.
mRange
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mLimiters
.
mLimiter
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mLimiters
.
mAncestorLimiter
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE
(
nsFrameSelection
AddRef
)
NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE
(
nsFrameSelection
Release
)
nsresult
nsFrameSelection
:
:
FetchDesiredPos
(
nsPoint
&
aDesiredPos
)
{
if
(
!
mPresShell
)
{
NS_ERROR
(
"
fetch
desired
position
failed
"
)
;
return
NS_ERROR_FAILURE
;
}
if
(
mDesiredPos
.
mIsSet
)
{
aDesiredPos
=
mDesiredPos
.
mValue
;
return
NS_OK
;
}
RefPtr
<
nsCaret
>
caret
=
mPresShell
-
>
GetCaret
(
)
;
if
(
!
caret
)
{
return
NS_ERROR_NULL_POINTER
;
}
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
caret
-
>
SetSelection
(
mDomSelections
[
index
]
)
;
nsRect
coord
;
nsIFrame
*
caretFrame
=
caret
-
>
GetGeometry
(
&
coord
)
;
if
(
!
caretFrame
)
{
return
NS_ERROR_FAILURE
;
}
nsPoint
viewOffset
(
0
0
)
;
nsView
*
view
=
nullptr
;
caretFrame
-
>
GetOffsetFromView
(
viewOffset
&
view
)
;
if
(
view
)
{
coord
+
=
viewOffset
;
}
aDesiredPos
=
coord
.
TopLeft
(
)
;
return
NS_OK
;
}
void
nsFrameSelection
:
:
InvalidateDesiredPos
(
)
{
mDesiredPos
.
mIsSet
=
false
;
}
void
nsFrameSelection
:
:
SetDesiredPos
(
nsPoint
aPos
)
{
mDesiredPos
.
mValue
=
aPos
;
mDesiredPos
.
mIsSet
=
true
;
}
nsresult
nsFrameSelection
:
:
ConstrainFrameAndPointToAnchorSubtree
(
nsIFrame
*
aFrame
const
nsPoint
&
aPoint
nsIFrame
*
*
aRetFrame
nsPoint
&
aRetPoint
)
const
{
if
(
!
aFrame
|
|
!
aRetFrame
)
{
return
NS_ERROR_NULL_POINTER
;
}
*
aRetFrame
=
aFrame
;
aRetPoint
=
aPoint
;
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
if
(
!
mDomSelections
[
index
]
)
{
return
NS_ERROR_NULL_POINTER
;
}
nsCOMPtr
<
nsIContent
>
anchorContent
=
do_QueryInterface
(
mDomSelections
[
index
]
-
>
GetAnchorNode
(
)
)
;
if
(
!
anchorContent
)
{
return
NS_ERROR_FAILURE
;
}
NS_ENSURE_STATE
(
mPresShell
)
;
nsIContent
*
anchorRoot
=
anchorContent
-
>
GetSelectionRootContent
(
mPresShell
)
;
NS_ENSURE_TRUE
(
anchorRoot
NS_ERROR_UNEXPECTED
)
;
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
content
)
{
nsIContent
*
contentRoot
=
content
-
>
GetSelectionRootContent
(
mPresShell
)
;
NS_ENSURE_TRUE
(
contentRoot
NS_ERROR_UNEXPECTED
)
;
if
(
anchorRoot
=
=
contentRoot
)
{
nsIContent
*
capturedContent
=
PresShell
:
:
GetCapturingContent
(
)
;
if
(
capturedContent
!
=
content
)
{
return
NS_OK
;
}
nsIFrame
*
rootFrame
=
mPresShell
-
>
GetRootFrame
(
)
;
nsPoint
ptInRoot
=
aPoint
+
aFrame
-
>
GetOffsetTo
(
rootFrame
)
;
nsIFrame
*
cursorFrame
=
nsLayoutUtils
:
:
GetFrameForPoint
(
rootFrame
ptInRoot
)
;
if
(
cursorFrame
&
&
cursorFrame
-
>
PresShell
(
)
=
=
mPresShell
)
{
nsIContent
*
cursorContent
=
cursorFrame
-
>
GetContent
(
)
;
NS_ENSURE_TRUE
(
cursorContent
NS_ERROR_FAILURE
)
;
nsIContent
*
cursorContentRoot
=
cursorContent
-
>
GetSelectionRootContent
(
mPresShell
)
;
NS_ENSURE_TRUE
(
cursorContentRoot
NS_ERROR_UNEXPECTED
)
;
if
(
cursorContentRoot
=
=
anchorRoot
)
{
*
aRetFrame
=
cursorFrame
;
aRetPoint
=
aPoint
+
aFrame
-
>
GetOffsetTo
(
cursorFrame
)
;
return
NS_OK
;
}
}
}
}
*
aRetFrame
=
anchorRoot
-
>
GetPrimaryFrame
(
)
;
if
(
!
*
aRetFrame
)
{
return
NS_ERROR_FAILURE
;
}
aRetPoint
=
aPoint
+
aFrame
-
>
GetOffsetTo
(
*
aRetFrame
)
;
return
NS_OK
;
}
void
nsFrameSelection
:
:
SetCaretBidiLevel
(
nsBidiLevel
aLevel
)
{
mCaret
.
mBidiLevel
=
aLevel
;
RefPtr
<
nsCaret
>
caret
;
if
(
mPresShell
&
&
(
caret
=
mPresShell
-
>
GetCaret
(
)
)
)
{
caret
-
>
SchedulePaint
(
)
;
}
}
nsBidiLevel
nsFrameSelection
:
:
GetCaretBidiLevel
(
)
const
{
return
mCaret
.
mBidiLevel
;
}
void
nsFrameSelection
:
:
UndefineCaretBidiLevel
(
)
{
mCaret
.
mBidiLevel
|
=
BIDI_LEVEL_UNDEFINED
;
}
#
ifdef
PRINT_RANGE
void
printRange
(
nsRange
*
aDomRange
)
{
if
(
!
aDomRange
)
{
printf
(
"
NULL
Range
\
n
"
)
;
}
nsINode
*
startNode
=
aDomRange
-
>
GetStartContainer
(
)
;
nsINode
*
endNode
=
aDomRange
-
>
GetEndContainer
(
)
;
int32_t
startOffset
=
aDomRange
-
>
StartOffset
(
)
;
int32_t
endOffset
=
aDomRange
-
>
EndOffset
(
)
;
printf
(
"
range
:
0x
%
lx
\
t
start
:
0x
%
lx
%
ld
\
t
end
:
0x
%
lx
%
ld
\
n
"
(
unsigned
long
)
aDomRange
(
unsigned
long
)
startNode
(
long
)
startOffset
(
unsigned
long
)
endNode
(
long
)
endOffset
)
;
}
#
endif
static
nsAtom
*
GetTag
(
nsINode
*
aNode
)
{
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
aNode
)
;
if
(
!
content
)
{
MOZ_ASSERT_UNREACHABLE
(
"
bad
node
passed
to
GetTag
(
)
"
)
;
return
nullptr
;
}
return
content
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
}
nsINode
*
ParentOffset
(
nsINode
*
aNode
int32_t
*
aChildOffset
)
{
if
(
!
aNode
|
|
!
aChildOffset
)
return
nullptr
;
nsIContent
*
parent
=
aNode
-
>
GetParent
(
)
;
if
(
parent
)
{
*
aChildOffset
=
parent
-
>
ComputeIndexOf
(
aNode
)
;
return
parent
;
}
return
nullptr
;
}
static
nsINode
*
GetCellParent
(
nsINode
*
aDomNode
)
{
if
(
!
aDomNode
)
return
nullptr
;
nsINode
*
current
=
aDomNode
;
while
(
current
)
{
nsAtom
*
tag
=
GetTag
(
current
)
;
if
(
tag
=
=
nsGkAtoms
:
:
td
|
|
tag
=
=
nsGkAtoms
:
:
th
)
return
current
;
current
=
current
-
>
GetParent
(
)
;
}
return
nullptr
;
}
bool
nsFrameSelection
:
:
sSelectionEventsOnTextControlsEnabled
=
false
;
nsresult
nsFrameSelection
:
:
MoveCaret
(
nsDirection
aDirection
bool
aContinueSelection
nsSelectionAmount
aAmount
CaretMovementStyle
aMovementStyle
)
{
bool
visualMovement
=
aMovementStyle
=
=
eVisual
|
|
(
aMovementStyle
=
=
eUsePrefStyle
&
&
(
mCaret
.
mMovementStyle
=
=
1
|
|
(
mCaret
.
mMovementStyle
=
=
2
&
&
!
aContinueSelection
)
)
)
;
NS_ENSURE_STATE
(
mPresShell
)
;
OwningNonNull
<
PresShell
>
presShell
(
*
mPresShell
)
;
presShell
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
if
(
!
mPresShell
)
{
return
NS_OK
;
}
nsPresContext
*
context
=
mPresShell
-
>
GetPresContext
(
)
;
if
(
!
context
)
return
NS_ERROR_FAILURE
;
nsPoint
desiredPos
(
0
0
)
;
const
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
const
RefPtr
<
Selection
>
sel
=
mDomSelections
[
index
]
;
if
(
!
sel
)
{
return
NS_ERROR_NULL_POINTER
;
}
int32_t
scrollFlags
=
Selection
:
:
SCROLL_FOR_CARET_MOVE
;
const
bool
isEditorSelection
=
sel
-
>
IsEditorSelection
(
)
;
if
(
isEditorSelection
)
{
scrollFlags
|
=
Selection
:
:
SCROLL_OVERFLOW_HIDDEN
;
}
int32_t
caretStyle
=
Preferences
:
:
GetInt
(
"
layout
.
selection
.
caret_style
"
0
)
;
if
(
caretStyle
=
=
0
#
ifdef
XP_WIN
&
&
aAmount
!
=
eSelectLine
#
endif
)
{
caretStyle
=
2
;
}
bool
doCollapse
=
!
sel
-
>
IsCollapsed
(
)
&
&
!
aContinueSelection
&
&
caretStyle
=
=
2
&
&
aAmount
<
=
eSelectLine
;
if
(
doCollapse
)
{
if
(
aDirection
=
=
eDirPrevious
)
{
SetChangeReasons
(
nsISelectionListener
:
:
COLLAPSETOSTART_REASON
)
;
mCaret
.
mHint
=
CARET_ASSOCIATE_AFTER
;
}
else
{
SetChangeReasons
(
nsISelectionListener
:
:
COLLAPSETOEND_REASON
)
;
mCaret
.
mHint
=
CARET_ASSOCIATE_BEFORE
;
}
}
else
{
SetChangeReasons
(
nsISelectionListener
:
:
KEYPRESS_REASON
)
;
}
AutoPrepareFocusRange
prep
(
sel
false
)
;
if
(
aAmount
=
=
eSelectLine
)
{
nsresult
result
=
FetchDesiredPos
(
desiredPos
)
;
if
(
NS_FAILED
(
result
)
)
{
return
result
;
}
SetDesiredPos
(
desiredPos
)
;
}
if
(
doCollapse
)
{
const
nsRange
*
anchorFocusRange
=
sel
-
>
GetAnchorFocusRange
(
)
;
if
(
anchorFocusRange
)
{
nsINode
*
node
;
int32_t
offset
;
if
(
aDirection
=
=
eDirPrevious
)
{
node
=
anchorFocusRange
-
>
GetStartContainer
(
)
;
offset
=
anchorFocusRange
-
>
StartOffset
(
)
;
}
else
{
node
=
anchorFocusRange
-
>
GetEndContainer
(
)
;
offset
=
anchorFocusRange
-
>
EndOffset
(
)
;
}
sel
-
>
Collapse
(
node
offset
)
;
}
sel
-
>
ScrollIntoView
(
nsISelectionController
:
:
SELECTION_FOCUS_REGION
ScrollAxis
(
)
ScrollAxis
(
)
scrollFlags
)
;
return
NS_OK
;
}
nsIFrame
*
frame
;
int32_t
offsetused
=
0
;
nsresult
result
=
sel
-
>
GetPrimaryFrameForFocusNode
(
&
frame
&
offsetused
visualMovement
)
;
if
(
NS_FAILED
(
result
)
|
|
!
frame
)
return
NS_FAILED
(
result
)
?
result
:
NS_ERROR_FAILURE
;
const
auto
forceEditableRegion
=
isEditorSelection
?
nsPeekOffsetStruct
:
:
ForceEditableRegion
:
:
Yes
:
nsPeekOffsetStruct
:
:
ForceEditableRegion
:
:
No
;
nsPeekOffsetStruct
pos
(
aAmount
eDirPrevious
offsetused
desiredPos
true
mLimiters
.
mLimiter
!
=
nullptr
true
visualMovement
aContinueSelection
forceEditableRegion
)
;
nsBidiDirection
paraDir
=
nsBidiPresUtils
:
:
ParagraphDirection
(
frame
)
;
CaretAssociateHint
tHint
(
mCaret
.
mHint
)
;
switch
(
aAmount
)
{
case
eSelectCharacter
:
case
eSelectCluster
:
case
eSelectWord
:
case
eSelectWordNoSpace
:
InvalidateDesiredPos
(
)
;
pos
.
mAmount
=
aAmount
;
pos
.
mDirection
=
(
visualMovement
&
&
paraDir
=
=
NSBIDI_RTL
)
?
nsDirection
(
1
-
aDirection
)
:
aDirection
;
break
;
case
eSelectLine
:
pos
.
mAmount
=
aAmount
;
pos
.
mDirection
=
aDirection
;
break
;
case
eSelectBeginLine
:
case
eSelectEndLine
:
InvalidateDesiredPos
(
)
;
pos
.
mAmount
=
aAmount
;
pos
.
mDirection
=
(
visualMovement
&
&
paraDir
=
=
NSBIDI_RTL
)
?
nsDirection
(
1
-
aDirection
)
:
aDirection
;
break
;
default
:
return
NS_ERROR_FAILURE
;
}
if
(
NS_SUCCEEDED
(
result
=
frame
-
>
PeekOffset
(
&
pos
)
)
&
&
pos
.
mResultContent
)
{
nsIFrame
*
theFrame
;
int32_t
currentOffset
frameStart
frameEnd
;
if
(
aAmount
<
=
eSelectWordNoSpace
)
{
theFrame
=
pos
.
mResultFrame
;
theFrame
-
>
GetOffsets
(
frameStart
frameEnd
)
;
currentOffset
=
pos
.
mContentOffset
;
if
(
frameEnd
=
=
currentOffset
&
&
!
(
frameStart
=
=
0
&
&
frameEnd
=
=
0
)
)
tHint
=
CARET_ASSOCIATE_BEFORE
;
else
tHint
=
CARET_ASSOCIATE_AFTER
;
}
else
{
tHint
=
pos
.
mAttach
;
theFrame
=
GetFrameForNodeOffset
(
pos
.
mResultContent
pos
.
mContentOffset
tHint
&
currentOffset
)
;
if
(
!
theFrame
)
return
NS_ERROR_FAILURE
;
theFrame
-
>
GetOffsets
(
frameStart
frameEnd
)
;
}
if
(
context
-
>
BidiEnabled
(
)
)
{
switch
(
aAmount
)
{
case
eSelectBeginLine
:
case
eSelectEndLine
:
{
FrameBidiData
bidiData
=
theFrame
-
>
GetBidiData
(
)
;
SetCaretBidiLevel
(
visualMovement
?
bidiData
.
embeddingLevel
:
bidiData
.
baseLevel
)
;
break
;
}
default
:
if
(
(
pos
.
mContentOffset
!
=
frameStart
&
&
pos
.
mContentOffset
!
=
frameEnd
)
|
|
eSelectLine
=
=
aAmount
)
{
SetCaretBidiLevel
(
theFrame
-
>
GetEmbeddingLevel
(
)
)
;
}
else
{
BidiLevelFromMove
(
mPresShell
pos
.
mResultContent
pos
.
mContentOffset
aAmount
tHint
)
;
}
}
}
const
FocusMode
focusMode
=
aContinueSelection
?
FocusMode
:
:
kExtendSelection
:
FocusMode
:
:
kCollapseToNewPoint
;
result
=
TakeFocus
(
MOZ_KnownLive
(
pos
.
mResultContent
)
pos
.
mContentOffset
pos
.
mContentOffset
tHint
focusMode
)
;
}
else
if
(
aAmount
<
=
eSelectWordNoSpace
&
&
aDirection
=
=
eDirNext
&
&
!
aContinueSelection
)
{
bool
isBRFrame
=
frame
-
>
IsBrFrame
(
)
;
sel
-
>
Collapse
(
sel
-
>
GetFocusNode
(
)
sel
-
>
FocusOffset
(
)
)
;
if
(
!
isBRFrame
)
{
mCaret
.
mHint
=
CARET_ASSOCIATE_BEFORE
;
}
result
=
NS_OK
;
}
if
(
NS_SUCCEEDED
(
result
)
)
{
result
=
sel
-
>
ScrollIntoView
(
nsISelectionController
:
:
SELECTION_FOCUS_REGION
ScrollAxis
(
)
ScrollAxis
(
)
scrollFlags
)
;
}
return
result
;
}
nsPrevNextBidiLevels
nsFrameSelection
:
:
GetPrevNextBidiLevels
(
nsIContent
*
aNode
uint32_t
aContentOffset
bool
aJumpLines
)
const
{
return
GetPrevNextBidiLevels
(
aNode
aContentOffset
mCaret
.
mHint
aJumpLines
)
;
}
nsPrevNextBidiLevels
nsFrameSelection
:
:
GetPrevNextBidiLevels
(
nsIContent
*
aNode
uint32_t
aContentOffset
CaretAssociateHint
aHint
bool
aJumpLines
)
{
nsIFrame
*
currentFrame
;
int32_t
currentOffset
;
int32_t
frameStart
frameEnd
;
nsDirection
direction
;
nsPrevNextBidiLevels
levels
;
levels
.
SetData
(
nullptr
nullptr
0
0
)
;
currentFrame
=
GetFrameForNodeOffset
(
aNode
aContentOffset
aHint
&
currentOffset
)
;
if
(
!
currentFrame
)
return
levels
;
currentFrame
-
>
GetOffsets
(
frameStart
frameEnd
)
;
if
(
0
=
=
frameStart
&
&
0
=
=
frameEnd
)
direction
=
eDirPrevious
;
else
if
(
frameStart
=
=
currentOffset
)
direction
=
eDirPrevious
;
else
if
(
frameEnd
=
=
currentOffset
)
direction
=
eDirNext
;
else
{
nsBidiLevel
currentLevel
=
currentFrame
-
>
GetEmbeddingLevel
(
)
;
levels
.
SetData
(
currentFrame
currentFrame
currentLevel
currentLevel
)
;
return
levels
;
}
nsIFrame
*
newFrame
;
int32_t
offset
;
bool
jumpedLine
movedOverNonSelectableText
;
nsresult
rv
=
currentFrame
-
>
GetFrameFromDirection
(
direction
false
aJumpLines
true
false
&
newFrame
&
offset
&
jumpedLine
&
movedOverNonSelectableText
)
;
if
(
NS_FAILED
(
rv
)
)
newFrame
=
nullptr
;
FrameBidiData
currentBidi
=
currentFrame
-
>
GetBidiData
(
)
;
nsBidiLevel
currentLevel
=
currentBidi
.
embeddingLevel
;
nsBidiLevel
newLevel
=
newFrame
?
newFrame
-
>
GetEmbeddingLevel
(
)
:
currentBidi
.
baseLevel
;
if
(
!
aJumpLines
)
{
if
(
currentFrame
-
>
IsBrFrame
(
)
)
{
currentFrame
=
nullptr
;
currentLevel
=
currentBidi
.
baseLevel
;
}
if
(
newFrame
&
&
newFrame
-
>
IsBrFrame
(
)
)
{
newFrame
=
nullptr
;
newLevel
=
currentBidi
.
baseLevel
;
}
}
if
(
direction
=
=
eDirNext
)
levels
.
SetData
(
currentFrame
newFrame
currentLevel
newLevel
)
;
else
levels
.
SetData
(
newFrame
currentFrame
newLevel
currentLevel
)
;
return
levels
;
}
nsresult
nsFrameSelection
:
:
GetFrameFromLevel
(
nsIFrame
*
aFrameIn
nsDirection
aDirection
nsBidiLevel
aBidiLevel
nsIFrame
*
*
aFrameOut
)
const
{
NS_ENSURE_STATE
(
mPresShell
)
;
nsBidiLevel
foundLevel
=
0
;
nsIFrame
*
foundFrame
=
aFrameIn
;
nsCOMPtr
<
nsIFrameEnumerator
>
frameTraversal
;
nsresult
result
;
nsCOMPtr
<
nsIFrameTraversal
>
trav
(
do_CreateInstance
(
kFrameTraversalCID
&
result
)
)
;
if
(
NS_FAILED
(
result
)
)
return
result
;
result
=
trav
-
>
NewFrameTraversal
(
getter_AddRefs
(
frameTraversal
)
mPresShell
-
>
GetPresContext
(
)
aFrameIn
eLeaf
false
false
false
false
)
;
if
(
NS_FAILED
(
result
)
)
return
result
;
do
{
*
aFrameOut
=
foundFrame
;
if
(
aDirection
=
=
eDirNext
)
frameTraversal
-
>
Next
(
)
;
else
frameTraversal
-
>
Prev
(
)
;
foundFrame
=
frameTraversal
-
>
CurrentItem
(
)
;
if
(
!
foundFrame
)
return
NS_ERROR_FAILURE
;
foundLevel
=
foundFrame
-
>
GetEmbeddingLevel
(
)
;
}
while
(
foundLevel
>
aBidiLevel
)
;
return
NS_OK
;
}
nsresult
nsFrameSelection
:
:
MaintainSelection
(
nsSelectionAmount
aAmount
)
{
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
if
(
!
mDomSelections
[
index
]
)
{
return
NS_ERROR_NULL_POINTER
;
}
mMaintainedRange
.
MaintainAnchorFocusRange
(
*
mDomSelections
[
index
]
aAmount
)
;
return
NS_OK
;
}
void
nsFrameSelection
:
:
BidiLevelFromMove
(
PresShell
*
aPresShell
nsIContent
*
aNode
uint32_t
aContentOffset
nsSelectionAmount
aAmount
CaretAssociateHint
aHint
)
{
switch
(
aAmount
)
{
case
eSelectCharacter
:
case
eSelectCluster
:
case
eSelectWord
:
case
eSelectWordNoSpace
:
case
eSelectBeginLine
:
case
eSelectEndLine
:
case
eSelectNoAmount
:
{
nsPrevNextBidiLevels
levels
=
GetPrevNextBidiLevels
(
aNode
aContentOffset
aHint
false
)
;
SetCaretBidiLevel
(
aHint
=
=
CARET_ASSOCIATE_BEFORE
?
levels
.
mLevelBefore
:
levels
.
mLevelAfter
)
;
break
;
}
default
:
UndefineCaretBidiLevel
(
)
;
}
}
void
nsFrameSelection
:
:
BidiLevelFromClick
(
nsIContent
*
aNode
uint32_t
aContentOffset
)
{
nsIFrame
*
clickInFrame
=
nullptr
;
int32_t
OffsetNotUsed
;
clickInFrame
=
GetFrameForNodeOffset
(
aNode
aContentOffset
mCaret
.
mHint
&
OffsetNotUsed
)
;
if
(
!
clickInFrame
)
return
;
SetCaretBidiLevel
(
clickInFrame
-
>
GetEmbeddingLevel
(
)
)
;
}
bool
nsFrameSelection
:
:
MaintainedRange
:
:
AdjustNormalSelection
(
const
nsIContent
*
aContent
const
int32_t
aOffset
Selection
&
aNormalSelection
)
const
{
MOZ_ASSERT
(
aNormalSelection
.
Type
(
)
=
=
SelectionType
:
:
eNormal
)
;
if
(
!
mRange
)
{
return
false
;
}
if
(
!
aContent
)
{
return
false
;
}
nsINode
*
rangeStartNode
=
mRange
-
>
GetStartContainer
(
)
;
nsINode
*
rangeEndNode
=
mRange
-
>
GetEndContainer
(
)
;
int32_t
rangeStartOffset
=
mRange
-
>
StartOffset
(
)
;
int32_t
rangeEndOffset
=
mRange
-
>
EndOffset
(
)
;
const
Maybe
<
int32_t
>
relToStart
=
nsContentUtils
:
:
ComparePoints
(
rangeStartNode
rangeStartOffset
aContent
aOffset
)
;
if
(
NS_WARN_IF
(
!
relToStart
)
)
{
return
false
;
}
const
Maybe
<
int32_t
>
relToEnd
=
nsContentUtils
:
:
ComparePoints
(
rangeEndNode
rangeEndOffset
aContent
aOffset
)
;
if
(
NS_WARN_IF
(
!
relToEnd
)
)
{
return
false
;
}
if
(
(
*
relToStart
<
0
&
&
*
relToEnd
>
0
)
|
|
(
*
relToStart
>
0
&
&
aNormalSelection
.
GetDirection
(
)
=
=
eDirNext
)
|
|
(
*
relToEnd
<
0
&
&
aNormalSelection
.
GetDirection
(
)
=
=
eDirPrevious
)
)
{
aNormalSelection
.
ReplaceAnchorFocusRange
(
mRange
)
;
if
(
*
relToStart
<
0
&
&
*
relToEnd
>
0
)
{
return
true
;
}
aNormalSelection
.
SetDirection
(
*
relToStart
>
0
?
eDirPrevious
:
eDirNext
)
;
}
return
false
;
}
void
nsFrameSelection
:
:
MaintainedRange
:
:
AdjustContentOffsets
(
nsIFrame
:
:
ContentOffsets
&
aOffsets
const
bool
aScrollViewStop
)
const
{
if
(
mRange
&
&
mAmount
!
=
eSelectNoAmount
)
{
nsINode
*
rangenode
=
mRange
-
>
GetStartContainer
(
)
;
int32_t
rangeOffset
=
mRange
-
>
StartOffset
(
)
;
const
Maybe
<
int32_t
>
relativePosition
=
nsContentUtils
:
:
ComparePoints
(
rangenode
rangeOffset
aOffsets
.
content
aOffsets
.
offset
)
;
if
(
NS_WARN_IF
(
!
relativePosition
)
)
{
return
;
}
nsDirection
direction
=
*
relativePosition
>
0
?
eDirPrevious
:
eDirNext
;
nsSelectionAmount
amount
=
mAmount
;
if
(
amount
=
=
eSelectBeginLine
&
&
direction
=
=
eDirNext
)
{
amount
=
eSelectEndLine
;
}
int32_t
offset
;
nsIFrame
*
frame
=
GetFrameForNodeOffset
(
aOffsets
.
content
aOffsets
.
offset
CARET_ASSOCIATE_AFTER
&
offset
)
;
if
(
frame
&
&
amount
=
=
eSelectWord
&
&
direction
=
=
eDirPrevious
)
{
nsPeekOffsetStruct
charPos
(
eSelectCharacter
eDirNext
offset
nsPoint
(
0
0
)
false
aScrollViewStop
false
false
false
)
;
if
(
NS_SUCCEEDED
(
frame
-
>
PeekOffset
(
&
charPos
)
)
)
{
frame
=
charPos
.
mResultFrame
;
offset
=
charPos
.
mContentOffset
;
}
}
nsPeekOffsetStruct
pos
(
amount
direction
offset
nsPoint
(
0
0
)
false
aScrollViewStop
false
false
false
)
;
if
(
frame
&
&
NS_SUCCEEDED
(
frame
-
>
PeekOffset
(
&
pos
)
)
&
&
pos
.
mResultContent
)
{
aOffsets
.
content
=
pos
.
mResultContent
;
aOffsets
.
offset
=
pos
.
mContentOffset
;
}
}
}
void
nsFrameSelection
:
:
MaintainedRange
:
:
MaintainAnchorFocusRange
(
const
Selection
&
aNormalSelection
const
nsSelectionAmount
aAmount
)
{
MOZ_ASSERT
(
aNormalSelection
.
Type
(
)
=
=
SelectionType
:
:
eNormal
)
;
mAmount
=
aAmount
;
const
nsRange
*
anchorFocusRange
=
aNormalSelection
.
GetAnchorFocusRange
(
)
;
if
(
anchorFocusRange
&
&
aAmount
!
=
eSelectNoAmount
)
{
mRange
=
anchorFocusRange
-
>
CloneRange
(
)
;
return
;
}
mRange
=
nullptr
;
}
nsresult
nsFrameSelection
:
:
HandleClick
(
nsIContent
*
aNewFocus
uint32_t
aContentOffset
uint32_t
aContentEndOffset
const
FocusMode
aFocusMode
CaretAssociateHint
aHint
)
{
if
(
!
aNewFocus
)
return
NS_ERROR_INVALID_ARG
;
InvalidateDesiredPos
(
)
;
if
(
aFocusMode
!
=
FocusMode
:
:
kExtendSelection
)
{
mMaintainedRange
.
mRange
=
nullptr
;
if
(
!
IsValidSelectionPoint
(
aNewFocus
)
)
{
mLimiters
.
mAncestorLimiter
=
nullptr
;
}
}
if
(
!
mTableSelection
.
mDragSelectingCells
)
{
BidiLevelFromClick
(
aNewFocus
aContentOffset
)
;
SetChangeReasons
(
nsISelectionListener
:
:
MOUSEDOWN_REASON
+
nsISelectionListener
:
:
DRAG_REASON
)
;
const
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
RefPtr
<
Selection
>
selection
=
mDomSelections
[
index
]
;
MOZ_ASSERT
(
selection
)
;
if
(
(
aFocusMode
=
=
FocusMode
:
:
kExtendSelection
)
&
&
mMaintainedRange
.
AdjustNormalSelection
(
aNewFocus
aContentOffset
*
selection
)
)
{
return
NS_OK
;
}
AutoPrepareFocusRange
prep
(
selection
aFocusMode
=
=
FocusMode
:
:
kMultiRangeSelection
)
;
return
TakeFocus
(
aNewFocus
aContentOffset
aContentEndOffset
aHint
aFocusMode
)
;
}
return
NS_OK
;
}
void
nsFrameSelection
:
:
HandleDrag
(
nsIFrame
*
aFrame
const
nsPoint
&
aPoint
)
{
if
(
!
aFrame
|
|
!
mPresShell
)
{
return
;
}
nsresult
result
;
nsIFrame
*
newFrame
=
0
;
nsPoint
newPoint
;
result
=
ConstrainFrameAndPointToAnchorSubtree
(
aFrame
aPoint
&
newFrame
newPoint
)
;
if
(
NS_FAILED
(
result
)
)
return
;
if
(
!
newFrame
)
return
;
nsIFrame
:
:
ContentOffsets
offsets
=
newFrame
-
>
GetContentOffsetsFromPoint
(
newPoint
)
;
if
(
!
offsets
.
content
)
return
;
const
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
RefPtr
<
Selection
>
selection
=
mDomSelections
[
index
]
;
if
(
newFrame
-
>
IsSelected
(
)
&
&
selection
&
&
mMaintainedRange
.
AdjustNormalSelection
(
offsets
.
content
offsets
.
offset
*
selection
)
)
{
return
;
}
const
bool
scrollViewStop
=
mLimiters
.
mLimiter
!
=
nullptr
;
mMaintainedRange
.
AdjustContentOffsets
(
offsets
scrollViewStop
)
;
HandleClick
(
offsets
.
content
offsets
.
offset
offsets
.
offset
FocusMode
:
:
kExtendSelection
offsets
.
associate
)
;
}
nsresult
nsFrameSelection
:
:
StartAutoScrollTimer
(
nsIFrame
*
aFrame
const
nsPoint
&
aPoint
uint32_t
aDelay
)
{
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
if
(
!
mDomSelections
[
index
]
)
{
return
NS_ERROR_NULL_POINTER
;
}
RefPtr
<
Selection
>
selection
=
mDomSelections
[
index
]
;
return
selection
-
>
StartAutoScrollTimer
(
aFrame
aPoint
aDelay
)
;
}
void
nsFrameSelection
:
:
StopAutoScrollTimer
(
)
{
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
if
(
!
mDomSelections
[
index
]
)
{
return
;
}
mDomSelections
[
index
]
-
>
StopAutoScrollTimer
(
)
;
}
nsresult
nsFrameSelection
:
:
TakeFocus
(
nsIContent
*
aNewFocus
uint32_t
aContentOffset
uint32_t
aContentEndOffset
CaretAssociateHint
aHint
const
FocusMode
aFocusMode
)
{
if
(
!
aNewFocus
)
return
NS_ERROR_NULL_POINTER
;
NS_ENSURE_STATE
(
mPresShell
)
;
if
(
!
IsValidSelectionPoint
(
aNewFocus
)
)
{
return
NS_ERROR_FAILURE
;
}
mPresShell
-
>
FrameSelectionWillTakeFocus
(
*
this
)
;
mTableSelection
.
mMode
=
TableSelectionMode
:
:
None
;
mTableSelection
.
mDragSelectingCells
=
false
;
mTableSelection
.
mStartSelectedCell
=
nullptr
;
mTableSelection
.
mEndSelectedCell
=
nullptr
;
mTableSelection
.
mAppendStartSelectedCell
=
nullptr
;
mCaret
.
mHint
=
aHint
;
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
if
(
!
mDomSelections
[
index
]
)
return
NS_ERROR_NULL_POINTER
;
Maybe
<
Selection
:
:
AutoUserInitiated
>
userSelect
;
if
(
IsUserSelectionReason
(
)
)
{
userSelect
.
emplace
(
mDomSelections
[
index
]
)
;
}
if
(
aFocusMode
!
=
FocusMode
:
:
kExtendSelection
)
{
const
Batching
saveBatching
=
mBatching
;
mBatching
.
mCounter
=
1
;
if
(
aFocusMode
=
=
FocusMode
:
:
kMultiRangeSelection
)
{
mDomSelections
[
index
]
-
>
RemoveCollapsedRanges
(
)
;
ErrorResult
error
;
RefPtr
<
nsRange
>
newRange
=
nsRange
:
:
Create
(
aNewFocus
aContentOffset
aNewFocus
aContentOffset
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
MOZ_ASSERT
(
newRange
)
;
const
RefPtr
<
Selection
>
selection
{
mDomSelections
[
index
]
}
;
selection
-
>
AddRangeAndSelectFramesAndNotifyListeners
(
*
newRange
IgnoreErrors
(
)
)
;
mBatching
=
saveBatching
;
}
else
{
bool
oldDesiredPosSet
=
mDesiredPos
.
mIsSet
;
mDomSelections
[
index
]
-
>
Collapse
(
aNewFocus
aContentOffset
)
;
mDesiredPos
.
mIsSet
=
oldDesiredPosSet
;
mBatching
=
saveBatching
;
}
if
(
aContentEndOffset
!
=
aContentOffset
)
{
mDomSelections
[
index
]
-
>
Extend
(
aNewFocus
aContentEndOffset
)
;
}
NS_ENSURE_STATE
(
mPresShell
)
;
bool
editableCell
=
false
;
mTableSelection
.
mCellParent
=
nullptr
;
RefPtr
<
nsPresContext
>
context
=
mPresShell
-
>
GetPresContext
(
)
;
if
(
context
)
{
RefPtr
<
HTMLEditor
>
htmlEditor
=
nsContentUtils
:
:
GetHTMLEditor
(
context
)
;
if
(
htmlEditor
)
{
nsINode
*
cellparent
=
GetCellParent
(
aNewFocus
)
;
nsCOMPtr
<
nsINode
>
editorHostNode
=
htmlEditor
-
>
GetActiveEditingHost
(
)
;
editableCell
=
cellparent
&
&
editorHostNode
&
&
cellparent
-
>
IsInclusiveDescendantOf
(
editorHostNode
)
;
if
(
editableCell
)
{
mTableSelection
.
mCellParent
=
cellparent
;
#
ifdef
DEBUG_TABLE_SELECTION
printf
(
"
*
TakeFocus
-
Collapsing
into
new
cell
\
n
"
)
;
#
endif
}
}
}
}
else
{
if
(
(
aFocusMode
=
=
FocusMode
:
:
kExtendSelection
)
&
&
aNewFocus
)
{
int32_t
offset
;
nsINode
*
cellparent
=
GetCellParent
(
aNewFocus
)
;
if
(
mTableSelection
.
mCellParent
&
&
cellparent
&
&
cellparent
!
=
mTableSelection
.
mCellParent
)
{
#
ifdef
DEBUG_TABLE_SELECTION
printf
(
"
*
TakeFocus
-
moving
into
new
cell
\
n
"
)
;
#
endif
WidgetMouseEvent
event
(
false
eVoidEvent
nullptr
WidgetMouseEvent
:
:
eReal
)
;
nsINode
*
parent
=
ParentOffset
(
mTableSelection
.
mCellParent
&
offset
)
;
if
(
parent
)
HandleTableSelection
(
parent
offset
TableSelectionMode
:
:
Cell
&
event
)
;
parent
=
ParentOffset
(
cellparent
&
offset
)
;
event
.
mModifiers
&
=
~
MODIFIER_SHIFT
;
if
(
parent
)
{
mTableSelection
.
mCellParent
=
cellparent
;
HandleTableSelection
(
parent
offset
TableSelectionMode
:
:
Cell
&
event
)
;
}
}
else
{
if
(
mDomSelections
[
index
]
-
>
GetDirection
(
)
=
=
eDirNext
&
&
aContentEndOffset
>
aContentOffset
)
{
mDomSelections
[
index
]
-
>
Extend
(
aNewFocus
aContentEndOffset
)
;
}
else
mDomSelections
[
index
]
-
>
Extend
(
aNewFocus
aContentOffset
)
;
}
}
}
if
(
IsBatching
(
)
)
{
return
NS_OK
;
}
return
NotifySelectionListeners
(
SelectionType
:
:
eNormal
)
;
}
UniquePtr
<
SelectionDetails
>
nsFrameSelection
:
:
LookUpSelection
(
nsIContent
*
aContent
int32_t
aContentOffset
int32_t
aContentLength
bool
aSlowCheck
)
const
{
if
(
!
aContent
|
|
!
mPresShell
)
{
return
nullptr
;
}
UniquePtr
<
SelectionDetails
>
details
;
for
(
size_t
j
=
0
;
j
<
ArrayLength
(
mDomSelections
)
;
j
+
+
)
{
if
(
mDomSelections
[
j
]
)
{
details
=
mDomSelections
[
j
]
-
>
LookUpSelection
(
aContent
aContentOffset
aContentLength
std
:
:
move
(
details
)
kPresentSelectionTypes
[
j
]
aSlowCheck
)
;
}
}
return
details
;
}
void
nsFrameSelection
:
:
SetDragState
(
bool
aState
)
{
if
(
mDragState
=
=
aState
)
return
;
mDragState
=
aState
;
if
(
!
mDragState
)
{
mTableSelection
.
mDragSelectingCells
=
false
;
SetChangeReasons
(
nsISelectionListener
:
:
MOUSEUP_REASON
)
;
NotifySelectionListeners
(
SelectionType
:
:
eNormal
)
;
}
}
Selection
*
nsFrameSelection
:
:
GetSelection
(
SelectionType
aSelectionType
)
const
{
int8_t
index
=
GetIndexFromSelectionType
(
aSelectionType
)
;
if
(
index
<
0
)
return
nullptr
;
return
mDomSelections
[
index
]
;
}
nsresult
nsFrameSelection
:
:
ScrollSelectionIntoView
(
SelectionType
aSelectionType
SelectionRegion
aRegion
int16_t
aFlags
)
const
{
int8_t
index
=
GetIndexFromSelectionType
(
aSelectionType
)
;
if
(
index
<
0
)
return
NS_ERROR_INVALID_ARG
;
if
(
!
mDomSelections
[
index
]
)
return
NS_ERROR_NULL_POINTER
;
ScrollAxis
verticalScroll
=
ScrollAxis
(
)
;
int32_t
flags
=
Selection
:
:
SCROLL_DO_FLUSH
;
if
(
aFlags
&
nsISelectionController
:
:
SCROLL_SYNCHRONOUS
)
{
flags
|
=
Selection
:
:
SCROLL_SYNCHRONOUS
;
}
else
if
(
aFlags
&
nsISelectionController
:
:
SCROLL_FIRST_ANCESTOR_ONLY
)
{
flags
|
=
Selection
:
:
SCROLL_FIRST_ANCESTOR_ONLY
;
}
if
(
aFlags
&
nsISelectionController
:
:
SCROLL_OVERFLOW_HIDDEN
)
{
flags
|
=
Selection
:
:
SCROLL_OVERFLOW_HIDDEN
;
}
if
(
aFlags
&
nsISelectionController
:
:
SCROLL_CENTER_VERTICALLY
)
{
verticalScroll
=
ScrollAxis
(
kScrollToCenter
WhenToScroll
:
:
IfNotFullyVisible
)
;
}
if
(
aFlags
&
nsISelectionController
:
:
SCROLL_FOR_CARET_MOVE
)
{
flags
|
=
Selection
:
:
SCROLL_FOR_CARET_MOVE
;
}
RefPtr
<
Selection
>
sel
=
mDomSelections
[
index
]
;
return
sel
-
>
ScrollIntoView
(
aRegion
verticalScroll
ScrollAxis
(
)
flags
)
;
}
nsresult
nsFrameSelection
:
:
RepaintSelection
(
SelectionType
aSelectionType
)
{
int8_t
index
=
GetIndexFromSelectionType
(
aSelectionType
)
;
if
(
index
<
0
)
return
NS_ERROR_INVALID_ARG
;
if
(
!
mDomSelections
[
index
]
)
return
NS_ERROR_NULL_POINTER
;
NS_ENSURE_STATE
(
mPresShell
)
;
#
ifdef
XP_MACOSX
Document
*
doc
=
mPresShell
-
>
GetDocument
(
)
;
if
(
doc
&
&
IsInActiveTab
(
doc
)
&
&
aSelectionType
=
=
SelectionType
:
:
eNormal
)
{
UpdateSelectionCacheOnRepaintSelection
(
mDomSelections
[
index
]
)
;
}
#
endif
return
mDomSelections
[
index
]
-
>
Repaint
(
mPresShell
-
>
GetPresContext
(
)
)
;
}
static
bool
IsDisplayContents
(
const
nsIContent
*
aContent
)
{
return
aContent
-
>
IsElement
(
)
&
&
aContent
-
>
AsElement
(
)
-
>
IsDisplayContents
(
)
;
}
nsIFrame
*
nsFrameSelection
:
:
GetFrameForNodeOffset
(
nsIContent
*
aNode
int32_t
aOffset
CaretAssociateHint
aHint
int32_t
*
aReturnOffset
)
{
if
(
!
aNode
|
|
!
aReturnOffset
)
return
nullptr
;
if
(
aOffset
<
0
)
return
nullptr
;
if
(
!
aNode
-
>
GetPrimaryFrame
(
)
&
&
!
IsDisplayContents
(
aNode
)
)
{
return
nullptr
;
}
nsIFrame
*
returnFrame
=
nullptr
;
nsCOMPtr
<
nsIContent
>
theNode
;
while
(
true
)
{
*
aReturnOffset
=
aOffset
;
theNode
=
aNode
;
if
(
aNode
-
>
IsElement
(
)
)
{
int32_t
childIndex
=
0
;
int32_t
numChildren
=
theNode
-
>
GetChildCount
(
)
;
if
(
aHint
=
=
CARET_ASSOCIATE_BEFORE
)
{
if
(
aOffset
>
0
)
{
childIndex
=
aOffset
-
1
;
}
else
{
childIndex
=
aOffset
;
}
}
else
{
NS_ASSERTION
(
aHint
=
=
CARET_ASSOCIATE_AFTER
"
unknown
direction
"
)
;
if
(
aOffset
>
=
numChildren
)
{
if
(
numChildren
>
0
)
{
childIndex
=
numChildren
-
1
;
}
else
{
childIndex
=
0
;
}
}
else
{
childIndex
=
aOffset
;
}
}
if
(
childIndex
>
0
|
|
numChildren
>
0
)
{
nsCOMPtr
<
nsIContent
>
childNode
=
theNode
-
>
GetChildAt_Deprecated
(
childIndex
)
;
if
(
!
childNode
)
{
break
;
}
theNode
=
childNode
;
}
if
(
theNode
-
>
IsElement
(
)
&
&
theNode
-
>
GetChildCount
(
)
&
&
!
theNode
-
>
HasIndependentSelection
(
)
)
{
aNode
=
theNode
;
aOffset
=
aOffset
>
childIndex
?
theNode
-
>
GetChildCount
(
)
:
0
;
continue
;
}
else
{
RefPtr
<
Text
>
textNode
=
theNode
-
>
GetAsText
(
)
;
if
(
textNode
)
{
if
(
theNode
-
>
GetPrimaryFrame
(
)
)
{
if
(
aOffset
>
childIndex
)
{
uint32_t
textLength
=
textNode
-
>
Length
(
)
;
*
aReturnOffset
=
(
int32_t
)
textLength
;
}
else
{
*
aReturnOffset
=
0
;
}
}
else
{
int32_t
numChildren
=
aNode
-
>
GetChildCount
(
)
;
int32_t
newChildIndex
=
aHint
=
=
CARET_ASSOCIATE_BEFORE
?
childIndex
-
1
:
childIndex
+
1
;
if
(
newChildIndex
>
=
0
&
&
newChildIndex
<
numChildren
)
{
nsCOMPtr
<
nsIContent
>
newChildNode
=
aNode
-
>
GetChildAt_Deprecated
(
newChildIndex
)
;
if
(
!
newChildNode
)
{
return
nullptr
;
}
aNode
=
newChildNode
;
aOffset
=
aHint
=
=
CARET_ASSOCIATE_BEFORE
?
aNode
-
>
GetChildCount
(
)
:
0
;
continue
;
}
else
{
theNode
=
aNode
;
}
}
}
}
}
if
(
ShadowRoot
*
shadow
=
ShadowRoot
:
:
FromNode
(
theNode
)
)
{
theNode
=
shadow
-
>
GetHost
(
)
;
}
returnFrame
=
theNode
-
>
GetPrimaryFrame
(
)
;
if
(
!
returnFrame
)
{
if
(
aHint
=
=
CARET_ASSOCIATE_BEFORE
)
{
if
(
aOffset
>
0
)
{
-
-
aOffset
;
continue
;
}
else
{
break
;
}
}
else
{
int32_t
end
=
theNode
-
>
GetChildCount
(
)
;
if
(
aOffset
<
end
)
{
+
+
aOffset
;
continue
;
}
else
{
break
;
}
}
}
break
;
}
if
(
!
returnFrame
)
return
nullptr
;
if
(
aOffset
>
0
&
&
(
uint32_t
)
aOffset
>
=
aNode
-
>
Length
(
)
&
&
theNode
=
=
aNode
-
>
GetLastChild
(
)
)
{
nsIFrame
*
newFrame
;
nsLayoutUtils
:
:
IsInvisibleBreak
(
theNode
&
newFrame
)
;
if
(
newFrame
)
{
returnFrame
=
newFrame
;
*
aReturnOffset
=
0
;
}
}
returnFrame
-
>
GetChildFrameContainingOffset
(
*
aReturnOffset
aHint
=
=
CARET_ASSOCIATE_AFTER
&
aOffset
&
returnFrame
)
;
return
returnFrame
;
}
nsIFrame
*
nsFrameSelection
:
:
GetFrameToPageSelect
(
)
const
{
if
(
NS_WARN_IF
(
!
mPresShell
)
)
{
return
nullptr
;
}
nsIFrame
*
rootFrameToSelect
;
if
(
mLimiters
.
mLimiter
)
{
rootFrameToSelect
=
mLimiters
.
mLimiter
-
>
GetPrimaryFrame
(
)
;
if
(
NS_WARN_IF
(
!
rootFrameToSelect
)
)
{
return
nullptr
;
}
}
else
if
(
mLimiters
.
mAncestorLimiter
)
{
rootFrameToSelect
=
mLimiters
.
mAncestorLimiter
-
>
GetPrimaryFrame
(
)
;
if
(
NS_WARN_IF
(
!
rootFrameToSelect
)
)
{
return
nullptr
;
}
}
else
{
rootFrameToSelect
=
mPresShell
-
>
GetRootScrollFrame
(
)
;
if
(
NS_WARN_IF
(
!
rootFrameToSelect
)
)
{
return
nullptr
;
}
}
nsCOMPtr
<
nsIContent
>
contentToSelect
=
mPresShell
-
>
GetContentForScrolling
(
)
;
if
(
contentToSelect
)
{
for
(
nsIFrame
*
frame
=
contentToSelect
-
>
GetPrimaryFrame
(
)
;
frame
&
&
frame
!
=
rootFrameToSelect
;
frame
=
frame
-
>
GetParent
(
)
)
{
nsIScrollableFrame
*
scrollableFrame
=
do_QueryFrame
(
frame
)
;
if
(
!
scrollableFrame
)
{
continue
;
}
ScrollStyles
scrollStyles
=
scrollableFrame
-
>
GetScrollStyles
(
)
;
if
(
scrollStyles
.
mVertical
=
=
StyleOverflow
:
:
Hidden
)
{
continue
;
}
uint32_t
directions
=
scrollableFrame
-
>
GetAvailableScrollingDirections
(
)
;
if
(
directions
&
nsIScrollableFrame
:
:
VERTICAL
)
{
return
frame
;
}
}
}
return
rootFrameToSelect
;
}
nsresult
nsFrameSelection
:
:
PageMove
(
bool
aForward
bool
aExtend
nsIFrame
*
aFrame
SelectionIntoView
aSelectionIntoView
)
{
MOZ_ASSERT
(
aFrame
)
;
nsIScrollableFrame
*
scrollableFrame
=
aFrame
-
>
GetScrollTargetFrame
(
)
;
nsIFrame
*
scrolledFrame
=
scrollableFrame
?
scrollableFrame
-
>
GetScrolledFrame
(
)
:
aFrame
;
if
(
!
scrolledFrame
)
{
return
NS_OK
;
}
RefPtr
<
Selection
>
selection
=
GetSelection
(
SelectionType
:
:
eNormal
)
;
if
(
!
selection
)
{
return
NS_OK
;
}
nsRect
caretPos
;
nsIFrame
*
caretFrame
=
nsCaret
:
:
GetGeometry
(
selection
&
caretPos
)
;
if
(
!
caretFrame
)
{
return
NS_OK
;
}
nsIFrame
*
frameToClick
=
scrolledFrame
;
if
(
!
IsValidSelectionPoint
(
scrolledFrame
-
>
GetContent
(
)
)
)
{
frameToClick
=
GetFrameToPageSelect
(
)
;
if
(
NS_WARN_IF
(
!
frameToClick
)
)
{
return
NS_OK
;
}
}
if
(
scrollableFrame
)
{
if
(
aForward
)
{
caretPos
.
y
+
=
scrollableFrame
-
>
GetPageScrollAmount
(
)
.
height
;
}
else
{
caretPos
.
y
-
=
scrollableFrame
-
>
GetPageScrollAmount
(
)
.
height
;
}
}
else
{
if
(
aForward
)
{
caretPos
.
y
+
=
frameToClick
-
>
GetSize
(
)
.
height
;
}
else
{
caretPos
.
y
-
=
frameToClick
-
>
GetSize
(
)
.
height
;
}
}
caretPos
+
=
caretFrame
-
>
GetOffsetTo
(
frameToClick
)
;
nsPoint
desiredPoint
;
desiredPoint
.
x
=
caretPos
.
x
;
desiredPoint
.
y
=
caretPos
.
y
+
caretPos
.
height
/
2
;
nsIFrame
:
:
ContentOffsets
offsets
=
frameToClick
-
>
GetContentOffsetsFromPoint
(
desiredPoint
)
;
if
(
!
offsets
.
content
)
{
return
NS_OK
;
}
bool
selectionChanged
;
{
SelectionBatcher
ensureNoSelectionChangeNotifications
(
selection
)
;
RangeBoundary
oldAnchor
=
selection
-
>
AnchorRef
(
)
;
RangeBoundary
oldFocus
=
selection
-
>
FocusRef
(
)
;
const
FocusMode
focusMode
=
aExtend
?
FocusMode
:
:
kExtendSelection
:
FocusMode
:
:
kCollapseToNewPoint
;
HandleClick
(
offsets
.
content
offsets
.
offset
offsets
.
offset
focusMode
CARET_ASSOCIATE_AFTER
)
;
selectionChanged
=
selection
-
>
AnchorRef
(
)
!
=
oldAnchor
|
|
selection
-
>
FocusRef
(
)
!
=
oldFocus
;
}
bool
doScrollSelectionIntoView
=
!
(
aSelectionIntoView
=
=
SelectionIntoView
:
:
IfChanged
&
&
!
selectionChanged
)
;
if
(
scrollableFrame
)
{
ScrollMode
scrollMode
=
doScrollSelectionIntoView
&
&
!
selectionChanged
&
&
scrolledFrame
!
=
frameToClick
?
ScrollMode
:
:
Instant
:
ScrollMode
:
:
Smooth
;
scrollableFrame
-
>
ScrollBy
(
nsIntPoint
(
0
aForward
?
1
:
-
1
)
ScrollUnit
:
:
PAGES
scrollMode
)
;
}
if
(
!
doScrollSelectionIntoView
)
{
return
NS_OK
;
}
return
ScrollSelectionIntoView
(
SelectionType
:
:
eNormal
nsISelectionController
:
:
SELECTION_FOCUS_REGION
nsISelectionController
:
:
SCROLL_SYNCHRONOUS
|
nsISelectionController
:
:
SCROLL_FOR_CARET_MOVE
)
;
}
nsresult
nsFrameSelection
:
:
PhysicalMove
(
int16_t
aDirection
int16_t
aAmount
bool
aExtend
)
{
NS_ENSURE_STATE
(
mPresShell
)
;
OwningNonNull
<
PresShell
>
presShell
(
*
mPresShell
)
;
presShell
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
if
(
!
mPresShell
)
{
return
NS_OK
;
}
if
(
aDirection
<
0
|
|
aDirection
>
3
|
|
aAmount
<
0
|
|
aAmount
>
1
)
{
return
NS_ERROR_FAILURE
;
}
nsPresContext
*
context
=
mPresShell
-
>
GetPresContext
(
)
;
if
(
!
context
)
{
return
NS_ERROR_FAILURE
;
}
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
RefPtr
<
Selection
>
sel
=
mDomSelections
[
index
]
;
if
(
!
sel
)
{
return
NS_ERROR_NULL_POINTER
;
}
static
const
nsSelectionAmount
inlineAmount
[
]
=
{
eSelectCluster
eSelectWord
}
;
static
const
nsSelectionAmount
blockPrevAmount
[
]
=
{
eSelectLine
eSelectBeginLine
}
;
static
const
nsSelectionAmount
blockNextAmount
[
]
=
{
eSelectLine
eSelectEndLine
}
;
struct
PhysicalToLogicalMapping
{
nsDirection
direction
;
const
nsSelectionAmount
*
amounts
;
}
;
static
const
PhysicalToLogicalMapping
verticalLR
[
4
]
=
{
{
eDirPrevious
blockPrevAmount
}
{
eDirNext
blockNextAmount
}
{
eDirPrevious
inlineAmount
}
{
eDirNext
inlineAmount
}
}
;
static
const
PhysicalToLogicalMapping
verticalRL
[
4
]
=
{
{
eDirNext
blockNextAmount
}
{
eDirPrevious
blockPrevAmount
}
{
eDirPrevious
inlineAmount
}
{
eDirNext
inlineAmount
}
}
;
static
const
PhysicalToLogicalMapping
horizontal
[
4
]
=
{
{
eDirPrevious
inlineAmount
}
{
eDirNext
inlineAmount
}
{
eDirPrevious
blockPrevAmount
}
{
eDirNext
blockNextAmount
}
}
;
WritingMode
wm
;
nsIFrame
*
frame
=
nullptr
;
int32_t
offsetused
=
0
;
if
(
NS_SUCCEEDED
(
sel
-
>
GetPrimaryFrameForFocusNode
(
&
frame
&
offsetused
true
)
)
)
{
if
(
frame
)
{
if
(
!
frame
-
>
Style
(
)
-
>
IsTextCombined
(
)
)
{
wm
=
frame
-
>
GetWritingMode
(
)
;
}
else
{
MOZ_ASSERT
(
frame
-
>
IsTextFrame
(
)
)
;
wm
=
frame
-
>
GetParent
(
)
-
>
GetWritingMode
(
)
;
MOZ_ASSERT
(
wm
.
IsVertical
(
)
"
Text
combined
"
"
can
only
appear
in
vertical
text
"
)
;
}
}
}
const
PhysicalToLogicalMapping
&
mapping
=
wm
.
IsVertical
(
)
?
wm
.
IsVerticalLR
(
)
?
verticalLR
[
aDirection
]
:
verticalRL
[
aDirection
]
:
horizontal
[
aDirection
]
;
nsresult
rv
=
MoveCaret
(
mapping
.
direction
aExtend
mapping
.
amounts
[
aAmount
]
eVisual
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
mapping
.
amounts
[
aAmount
]
=
=
eSelectLine
)
{
rv
=
MoveCaret
(
mapping
.
direction
aExtend
mapping
.
amounts
[
aAmount
+
1
]
eVisual
)
;
}
else
if
(
mapping
.
amounts
[
aAmount
]
=
=
eSelectWord
&
&
mapping
.
direction
=
=
eDirNext
)
{
rv
=
MoveCaret
(
eDirNext
aExtend
eSelectEndLine
eVisual
)
;
}
}
return
rv
;
}
nsresult
nsFrameSelection
:
:
CharacterMove
(
bool
aForward
bool
aExtend
)
{
return
MoveCaret
(
aForward
?
eDirNext
:
eDirPrevious
aExtend
eSelectCluster
eUsePrefStyle
)
;
}
nsresult
nsFrameSelection
:
:
CharacterExtendForDelete
(
)
{
return
MoveCaret
(
eDirNext
true
eSelectCluster
eLogical
)
;
}
nsresult
nsFrameSelection
:
:
CharacterExtendForBackspace
(
)
{
return
MoveCaret
(
eDirPrevious
true
eSelectCharacter
eLogical
)
;
}
nsresult
nsFrameSelection
:
:
WordMove
(
bool
aForward
bool
aExtend
)
{
return
MoveCaret
(
aForward
?
eDirNext
:
eDirPrevious
aExtend
eSelectWord
eUsePrefStyle
)
;
}
nsresult
nsFrameSelection
:
:
WordExtendForDelete
(
bool
aForward
)
{
return
MoveCaret
(
aForward
?
eDirNext
:
eDirPrevious
true
eSelectWord
eLogical
)
;
}
nsresult
nsFrameSelection
:
:
LineMove
(
bool
aForward
bool
aExtend
)
{
return
MoveCaret
(
aForward
?
eDirNext
:
eDirPrevious
aExtend
eSelectLine
eUsePrefStyle
)
;
}
nsresult
nsFrameSelection
:
:
IntraLineMove
(
bool
aForward
bool
aExtend
)
{
if
(
aForward
)
{
return
MoveCaret
(
eDirNext
aExtend
eSelectEndLine
eLogical
)
;
}
else
{
return
MoveCaret
(
eDirPrevious
aExtend
eSelectBeginLine
eLogical
)
;
}
}
nsresult
nsFrameSelection
:
:
SelectAll
(
)
{
nsCOMPtr
<
nsIContent
>
rootContent
;
if
(
mLimiters
.
mLimiter
)
{
rootContent
=
mLimiters
.
mLimiter
;
}
else
if
(
mLimiters
.
mAncestorLimiter
)
{
rootContent
=
mLimiters
.
mAncestorLimiter
;
}
else
{
NS_ENSURE_STATE
(
mPresShell
)
;
Document
*
doc
=
mPresShell
-
>
GetDocument
(
)
;
if
(
!
doc
)
return
NS_ERROR_FAILURE
;
rootContent
=
doc
-
>
GetRootElement
(
)
;
if
(
!
rootContent
)
return
NS_ERROR_FAILURE
;
}
int32_t
numChildren
=
rootContent
-
>
GetChildCount
(
)
;
SetChangeReasons
(
nsISelectionListener
:
:
NO_REASON
)
;
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
AutoPrepareFocusRange
prep
(
mDomSelections
[
index
]
false
)
;
return
TakeFocus
(
rootContent
0
numChildren
CARET_ASSOCIATE_BEFORE
FocusMode
:
:
kCollapseToNewPoint
)
;
}
void
nsFrameSelection
:
:
StartBatchChanges
(
)
{
mBatching
.
mCounter
+
+
;
}
void
nsFrameSelection
:
:
EndBatchChanges
(
int16_t
aReasons
)
{
MOZ_ASSERT
(
mBatching
.
mCounter
>
0
"
Bad
mBatching
.
mCounter
"
)
;
mBatching
.
mCounter
-
-
;
if
(
mBatching
.
mCounter
=
=
0
&
&
mBatching
.
mChangesDuringBatching
)
{
AddChangeReasons
(
aReasons
)
;
mBatching
.
mChangesDuringBatching
=
false
;
NotifySelectionListeners
(
SelectionType
:
:
eNormal
)
;
}
}
nsresult
nsFrameSelection
:
:
NotifySelectionListeners
(
SelectionType
aSelectionType
)
{
int8_t
index
=
GetIndexFromSelectionType
(
aSelectionType
)
;
if
(
index
>
=
0
&
&
mDomSelections
[
index
]
)
{
RefPtr
<
Selection
>
selection
=
mDomSelections
[
index
]
;
return
selection
-
>
NotifySelectionListeners
(
)
;
}
return
NS_ERROR_FAILURE
;
}
static
bool
IsCell
(
nsIContent
*
aContent
)
{
return
aContent
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
td
nsGkAtoms
:
:
th
)
;
}
nsITableCellLayout
*
nsFrameSelection
:
:
GetCellLayout
(
nsIContent
*
aCellContent
)
{
nsITableCellLayout
*
cellLayoutObject
=
do_QueryFrame
(
aCellContent
-
>
GetPrimaryFrame
(
)
)
;
return
cellLayoutObject
;
}
nsresult
nsFrameSelection
:
:
ClearNormalSelection
(
)
{
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
if
(
!
mDomSelections
[
index
]
)
return
NS_ERROR_NULL_POINTER
;
ErrorResult
err
;
mDomSelections
[
index
]
-
>
RemoveAllRanges
(
err
)
;
return
err
.
StealNSResult
(
)
;
}
static
nsIContent
*
GetFirstSelectedContent
(
nsRange
*
aRange
)
{
if
(
!
aRange
)
{
return
nullptr
;
}
MOZ_ASSERT
(
aRange
-
>
GetStartContainer
(
)
"
Must
have
start
parent
!
"
)
;
MOZ_ASSERT
(
aRange
-
>
GetStartContainer
(
)
-
>
IsElement
(
)
"
Unexpected
parent
"
)
;
return
aRange
-
>
GetChildAtStartOffset
(
)
;
}
nsresult
nsFrameSelection
:
:
HandleTableSelection
(
nsINode
*
aParentContent
int32_t
aContentOffset
TableSelectionMode
aTarget
WidgetMouseEvent
*
aMouseEvent
)
{
const
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
RefPtr
<
Selection
>
selection
=
mDomSelections
[
index
]
;
if
(
!
selection
)
{
return
NS_ERROR_NULL_POINTER
;
}
return
mTableSelection
.
HandleSelection
(
aParentContent
aContentOffset
aTarget
aMouseEvent
mDragState
*
selection
)
;
}
nsresult
nsFrameSelection
:
:
TableSelection
:
:
HandleSelection
(
nsINode
*
aParentContent
int32_t
aContentOffset
TableSelectionMode
aTarget
WidgetMouseEvent
*
aMouseEvent
bool
aDragState
Selection
&
aNormalSelection
)
{
MOZ_ASSERT
(
aNormalSelection
.
Type
(
)
=
=
SelectionType
:
:
eNormal
)
;
NS_ENSURE_TRUE
(
aParentContent
NS_ERROR_NULL_POINTER
)
;
NS_ENSURE_TRUE
(
aMouseEvent
NS_ERROR_NULL_POINTER
)
;
if
(
aDragState
&
&
mDragSelectingCells
&
&
aTarget
=
=
TableSelectionMode
:
:
Table
)
{
return
NS_OK
;
}
nsresult
result
=
NS_OK
;
nsIContent
*
childContent
=
aParentContent
-
>
GetChildAt_Deprecated
(
aContentOffset
)
;
aNormalSelection
.
SetDirection
(
eDirNext
)
;
SelectionBatcher
selectionBatcher
(
&
aNormalSelection
)
;
int32_t
startRowIndex
startColIndex
curRowIndex
curColIndex
;
if
(
aDragState
&
&
mDragSelectingCells
)
{
if
(
aTarget
!
=
TableSelectionMode
:
:
Table
)
{
if
(
mEndSelectedCell
=
=
childContent
)
{
return
NS_OK
;
}
#
ifdef
DEBUG_TABLE_SELECTION
printf
(
"
mStartSelectedCell
=
%
p
"
"
mEndSelectedCell
=
%
p
childContent
=
%
p
"
"
\
n
"
mStartSelectedCell
.
get
(
)
mEndSelectedCell
.
get
(
)
childContent
)
;
#
endif
if
(
mMode
=
=
TableSelectionMode
:
:
Row
|
|
mMode
=
=
TableSelectionMode
:
:
Column
)
{
if
(
mEndSelectedCell
)
{
result
=
GetCellIndexes
(
mEndSelectedCell
startRowIndex
startColIndex
)
;
if
(
NS_FAILED
(
result
)
)
{
return
result
;
}
result
=
GetCellIndexes
(
childContent
curRowIndex
curColIndex
)
;
if
(
NS_FAILED
(
result
)
)
{
return
result
;
}
#
ifdef
DEBUG_TABLE_SELECTION
printf
(
"
curRowIndex
=
%
d
startRowIndex
=
%
d
curColIndex
=
%
d
"
"
startColIndex
=
%
d
\
n
"
curRowIndex
startRowIndex
curColIndex
startColIndex
)
;
#
endif
if
(
(
mMode
=
=
TableSelectionMode
:
:
Row
&
&
startRowIndex
=
=
curRowIndex
)
|
|
(
mMode
=
=
TableSelectionMode
:
:
Column
&
&
startColIndex
=
=
curColIndex
)
)
{
return
NS_OK
;
}
}
#
ifdef
DEBUG_TABLE_SELECTION
printf
(
"
Dragged
into
a
new
column
or
row
\
n
"
)
;
#
endif
return
SelectRowOrColumn
(
childContent
aNormalSelection
)
;
}
if
(
mMode
=
=
TableSelectionMode
:
:
Cell
)
{
#
ifdef
DEBUG_TABLE_SELECTION
printf
(
"
HandleTableSelection
:
Dragged
into
a
new
cell
\
n
"
)
;
#
endif
if
(
mStartSelectedCell
&
&
aMouseEvent
-
>
IsShift
(
)
)
{
result
=
GetCellIndexes
(
mStartSelectedCell
startRowIndex
startColIndex
)
;
if
(
NS_FAILED
(
result
)
)
{
return
result
;
}
result
=
GetCellIndexes
(
childContent
curRowIndex
curColIndex
)
;
if
(
NS_FAILED
(
result
)
)
{
return
result
;
}
if
(
startRowIndex
=
=
curRowIndex
|
|
startColIndex
=
=
curColIndex
)
{
mStartSelectedCell
=
nullptr
;
aNormalSelection
.
RemoveAllRanges
(
IgnoreErrors
(
)
)
;
if
(
startRowIndex
=
=
curRowIndex
)
{
mMode
=
TableSelectionMode
:
:
Row
;
}
else
{
mMode
=
TableSelectionMode
:
:
Column
;
}
return
SelectRowOrColumn
(
childContent
aNormalSelection
)
;
}
}
return
SelectBlockOfCells
(
mStartSelectedCell
childContent
aNormalSelection
)
;
}
}
return
NS_OK
;
}
else
{
if
(
aDragState
)
{
#
ifdef
DEBUG_TABLE_SELECTION
printf
(
"
HandleTableSelection
:
Mouse
down
event
\
n
"
)
;
#
endif
mUnselectCellOnMouseUp
=
nullptr
;
if
(
aTarget
=
=
TableSelectionMode
:
:
Cell
)
{
bool
isSelected
=
false
;
nsIContent
*
previousCellNode
=
GetFirstSelectedContent
(
GetFirstCellRange
(
aNormalSelection
)
)
;
if
(
previousCellNode
)
{
nsIFrame
*
cellFrame
=
childContent
-
>
GetPrimaryFrame
(
)
;
if
(
!
cellFrame
)
{
return
NS_ERROR_NULL_POINTER
;
}
isSelected
=
cellFrame
-
>
IsSelected
(
)
;
}
else
{
aNormalSelection
.
RemoveAllRanges
(
IgnoreErrors
(
)
)
;
}
mDragSelectingCells
=
true
;
mMode
=
aTarget
;
mStartSelectedCell
=
childContent
;
mEndSelectedCell
=
childContent
;
if
(
isSelected
)
{
mUnselectCellOnMouseUp
=
childContent
;
#
ifdef
DEBUG_TABLE_SELECTION
printf
(
"
HandleTableSelection
:
Saving
"
"
mUnselectCellOnMouseUp
\
n
"
)
;
#
endif
}
else
{
if
(
previousCellNode
&
&
!
IsInSameTable
(
previousCellNode
childContent
)
)
{
aNormalSelection
.
RemoveAllRanges
(
IgnoreErrors
(
)
)
;
mMode
=
aTarget
;
}
return
:
:
SelectCellElement
(
childContent
aNormalSelection
)
;
}
return
NS_OK
;
}
if
(
aTarget
=
=
TableSelectionMode
:
:
Table
)
{
mDragSelectingCells
=
false
;
mStartSelectedCell
=
nullptr
;
mEndSelectedCell
=
nullptr
;
aNormalSelection
.
RemoveAllRanges
(
IgnoreErrors
(
)
)
;
return
CreateAndAddRange
(
aParentContent
aContentOffset
aNormalSelection
)
;
}
if
(
aTarget
=
=
TableSelectionMode
:
:
Row
|
|
aTarget
=
=
TableSelectionMode
:
:
Column
)
{
#
ifdef
DEBUG_TABLE_SELECTION
printf
(
"
aTarget
=
=
%
d
\
n
"
aTarget
)
;
#
endif
mDragSelectingCells
=
true
;
mStartSelectedCell
=
nullptr
;
aNormalSelection
.
RemoveAllRanges
(
IgnoreErrors
(
)
)
;
mMode
=
aTarget
;
return
SelectRowOrColumn
(
childContent
aNormalSelection
)
;
}
}
else
{
#
ifdef
DEBUG_TABLE_SELECTION
printf
(
"
HandleTableSelection
:
Mouse
UP
event
.
"
"
mDragSelectingCells
=
%
d
"
"
mStartSelectedCell
=
%
p
\
n
"
mDragSelectingCells
mStartSelectedCell
.
get
(
)
)
;
#
endif
uint32_t
rangeCount
=
aNormalSelection
.
RangeCount
(
)
;
if
(
rangeCount
>
0
&
&
aMouseEvent
-
>
IsShift
(
)
&
&
mAppendStartSelectedCell
&
&
mAppendStartSelectedCell
!
=
childContent
)
{
mDragSelectingCells
=
false
;
return
SelectBlockOfCells
(
mAppendStartSelectedCell
childContent
aNormalSelection
)
;
}
if
(
mDragSelectingCells
)
{
mAppendStartSelectedCell
=
mStartSelectedCell
;
}
mDragSelectingCells
=
false
;
mStartSelectedCell
=
nullptr
;
mEndSelectedCell
=
nullptr
;
bool
doMouseUpAction
=
false
;
#
ifdef
XP_MACOSX
doMouseUpAction
=
aMouseEvent
-
>
IsMeta
(
)
;
#
else
doMouseUpAction
=
aMouseEvent
-
>
IsControl
(
)
;
#
endif
if
(
!
doMouseUpAction
)
{
#
ifdef
DEBUG_TABLE_SELECTION
printf
(
"
HandleTableSelection
:
Ending
cell
selection
on
mouseup
:
"
"
mAppendStartSelectedCell
=
%
p
\
n
"
mAppendStartSelectedCell
.
get
(
)
)
;
#
endif
return
NS_OK
;
}
if
(
childContent
=
=
mUnselectCellOnMouseUp
)
{
nsINode
*
previousCellParent
=
nullptr
;
#
ifdef
DEBUG_TABLE_SELECTION
printf
(
"
HandleTableSelection
:
Unselecting
"
"
mUnselectCellOnMouseUp
;
"
"
rangeCount
=
%
d
\
n
"
rangeCount
)
;
#
endif
for
(
uint32_t
i
=
0
;
i
<
rangeCount
;
i
+
+
)
{
RefPtr
<
nsRange
>
range
=
aNormalSelection
.
GetRangeAt
(
i
)
;
if
(
!
range
)
{
return
NS_ERROR_NULL_POINTER
;
}
nsINode
*
container
=
range
-
>
GetStartContainer
(
)
;
if
(
!
container
)
{
return
NS_ERROR_NULL_POINTER
;
}
int32_t
offset
=
range
-
>
StartOffset
(
)
;
nsIContent
*
child
=
range
-
>
GetChildAtStartOffset
(
)
;
if
(
child
&
&
IsCell
(
child
)
)
{
previousCellParent
=
container
;
}
if
(
!
previousCellParent
)
{
break
;
}
if
(
previousCellParent
=
=
aParentContent
&
&
offset
=
=
aContentOffset
)
{
if
(
rangeCount
=
=
1
)
{
#
ifdef
DEBUG_TABLE_SELECTION
printf
(
"
HandleTableSelection
:
Unselecting
single
selected
cell
\
n
"
)
;
#
endif
mStartSelectedCell
=
nullptr
;
mEndSelectedCell
=
nullptr
;
mAppendStartSelectedCell
=
nullptr
;
return
aNormalSelection
.
Collapse
(
childContent
0
)
;
}
#
ifdef
DEBUG_TABLE_SELECTION
printf
(
"
HandleTableSelection
:
Removing
cell
from
multi
-
cell
"
"
selection
\
n
"
)
;
#
endif
if
(
childContent
=
=
mAppendStartSelectedCell
)
{
mAppendStartSelectedCell
=
nullptr
;
}
ErrorResult
err
;
aNormalSelection
.
RemoveRangeAndUnselectFramesAndNotifyListeners
(
*
range
err
)
;
return
err
.
StealNSResult
(
)
;
}
}
mUnselectCellOnMouseUp
=
nullptr
;
}
}
}
return
result
;
}
nsresult
nsFrameSelection
:
:
TableSelection
:
:
SelectBlockOfCells
(
nsIContent
*
aStartCell
nsIContent
*
aEndCell
Selection
&
aNormalSelection
)
{
NS_ENSURE_TRUE
(
aStartCell
NS_ERROR_NULL_POINTER
)
;
NS_ENSURE_TRUE
(
aEndCell
NS_ERROR_NULL_POINTER
)
;
mEndSelectedCell
=
aEndCell
;
nsresult
result
=
NS_OK
;
const
RefPtr
<
nsIContent
>
table
=
IsInSameTable
(
aStartCell
aEndCell
)
;
if
(
!
table
)
{
return
NS_OK
;
}
int32_t
startRowIndex
startColIndex
endRowIndex
endColIndex
;
result
=
GetCellIndexes
(
aStartCell
startRowIndex
startColIndex
)
;
if
(
NS_FAILED
(
result
)
)
return
result
;
result
=
GetCellIndexes
(
aEndCell
endRowIndex
endColIndex
)
;
if
(
NS_FAILED
(
result
)
)
return
result
;
if
(
mDragSelectingCells
)
{
UnselectCells
(
table
startRowIndex
startColIndex
endRowIndex
endColIndex
true
aNormalSelection
)
;
}
return
AddCellsToSelection
(
table
startRowIndex
startColIndex
endRowIndex
endColIndex
aNormalSelection
)
;
}
nsresult
nsFrameSelection
:
:
TableSelection
:
:
UnselectCells
(
nsIContent
*
aTableContent
int32_t
aStartRowIndex
int32_t
aStartColumnIndex
int32_t
aEndRowIndex
int32_t
aEndColumnIndex
bool
aRemoveOutsideOfCellRange
mozilla
:
:
dom
:
:
Selection
&
aNormalSelection
)
{
MOZ_ASSERT
(
aNormalSelection
.
Type
(
)
=
=
SelectionType
:
:
eNormal
)
;
nsTableWrapperFrame
*
tableFrame
=
do_QueryFrame
(
aTableContent
-
>
GetPrimaryFrame
(
)
)
;
if
(
!
tableFrame
)
return
NS_ERROR_FAILURE
;
int32_t
minRowIndex
=
std
:
:
min
(
aStartRowIndex
aEndRowIndex
)
;
int32_t
maxRowIndex
=
std
:
:
max
(
aStartRowIndex
aEndRowIndex
)
;
int32_t
minColIndex
=
std
:
:
min
(
aStartColumnIndex
aEndColumnIndex
)
;
int32_t
maxColIndex
=
std
:
:
max
(
aStartColumnIndex
aEndColumnIndex
)
;
RefPtr
<
nsRange
>
range
=
GetFirstCellRange
(
aNormalSelection
)
;
nsIContent
*
cellNode
=
GetFirstSelectedContent
(
range
)
;
MOZ_ASSERT
(
!
range
|
|
cellNode
"
Must
have
cellNode
if
had
a
range
"
)
;
int32_t
curRowIndex
curColIndex
;
while
(
cellNode
)
{
nsresult
result
=
GetCellIndexes
(
cellNode
curRowIndex
curColIndex
)
;
if
(
NS_FAILED
(
result
)
)
return
result
;
#
ifdef
DEBUG_TABLE_SELECTION
if
(
!
range
)
printf
(
"
RemoveCellsToSelection
-
-
range
is
null
\
n
"
)
;
#
endif
if
(
range
)
{
if
(
aRemoveOutsideOfCellRange
)
{
if
(
curRowIndex
<
minRowIndex
|
|
curRowIndex
>
maxRowIndex
|
|
curColIndex
<
minColIndex
|
|
curColIndex
>
maxColIndex
)
{
aNormalSelection
.
RemoveRangeAndUnselectFramesAndNotifyListeners
(
*
range
IgnoreErrors
(
)
)
;
mSelectedCellIndex
-
-
;
}
}
else
{
nsTableCellFrame
*
cellFrame
=
tableFrame
-
>
GetCellFrameAt
(
curRowIndex
curColIndex
)
;
uint32_t
origRowIndex
=
cellFrame
-
>
RowIndex
(
)
;
uint32_t
origColIndex
=
cellFrame
-
>
ColIndex
(
)
;
uint32_t
actualRowSpan
=
tableFrame
-
>
GetEffectiveRowSpanAt
(
origRowIndex
origColIndex
)
;
uint32_t
actualColSpan
=
tableFrame
-
>
GetEffectiveColSpanAt
(
curRowIndex
curColIndex
)
;
if
(
origRowIndex
<
=
static_cast
<
uint32_t
>
(
maxRowIndex
)
&
&
maxRowIndex
>
=
0
&
&
origRowIndex
+
actualRowSpan
-
1
>
=
static_cast
<
uint32_t
>
(
minRowIndex
)
&
&
origColIndex
<
=
static_cast
<
uint32_t
>
(
maxColIndex
)
&
&
maxColIndex
>
=
0
&
&
origColIndex
+
actualColSpan
-
1
>
=
static_cast
<
uint32_t
>
(
minColIndex
)
)
{
aNormalSelection
.
RemoveRangeAndUnselectFramesAndNotifyListeners
(
*
range
IgnoreErrors
(
)
)
;
mSelectedCellIndex
-
-
;
}
}
}
range
=
GetNextCellRange
(
aNormalSelection
)
;
cellNode
=
GetFirstSelectedContent
(
range
)
;
MOZ_ASSERT
(
!
range
|
|
cellNode
"
Must
have
cellNode
if
had
a
range
"
)
;
}
return
NS_OK
;
}
nsresult
SelectCellElement
(
nsIContent
*
aCellElement
Selection
&
aNormalSelection
)
{
MOZ_ASSERT
(
aNormalSelection
.
Type
(
)
=
=
SelectionType
:
:
eNormal
)
;
nsIContent
*
parent
=
aCellElement
-
>
GetParent
(
)
;
int32_t
offset
=
parent
-
>
ComputeIndexOf
(
aCellElement
)
;
return
CreateAndAddRange
(
parent
offset
aNormalSelection
)
;
}
static
nsresult
AddCellsToSelection
(
nsIContent
*
aTableContent
int32_t
aStartRowIndex
int32_t
aStartColumnIndex
int32_t
aEndRowIndex
int32_t
aEndColumnIndex
Selection
&
aNormalSelection
)
{
MOZ_ASSERT
(
aNormalSelection
.
Type
(
)
=
=
SelectionType
:
:
eNormal
)
;
nsTableWrapperFrame
*
tableFrame
=
do_QueryFrame
(
aTableContent
-
>
GetPrimaryFrame
(
)
)
;
if
(
!
tableFrame
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
result
=
NS_OK
;
uint32_t
row
=
aStartRowIndex
;
while
(
true
)
{
uint32_t
col
=
aStartColumnIndex
;
while
(
true
)
{
nsTableCellFrame
*
cellFrame
=
tableFrame
-
>
GetCellFrameAt
(
row
col
)
;
if
(
cellFrame
)
{
uint32_t
origRow
=
cellFrame
-
>
RowIndex
(
)
;
uint32_t
origCol
=
cellFrame
-
>
ColIndex
(
)
;
if
(
origRow
=
=
row
&
&
origCol
=
=
col
&
&
!
cellFrame
-
>
IsSelected
(
)
)
{
result
=
SelectCellElement
(
cellFrame
-
>
GetContent
(
)
aNormalSelection
)
;
if
(
NS_FAILED
(
result
)
)
{
return
result
;
}
}
}
if
(
col
=
=
static_cast
<
uint32_t
>
(
aEndColumnIndex
)
)
{
break
;
}
if
(
aStartColumnIndex
<
aEndColumnIndex
)
{
col
+
+
;
}
else
{
col
-
-
;
}
}
if
(
row
=
=
static_cast
<
uint32_t
>
(
aEndRowIndex
)
)
{
break
;
}
if
(
aStartRowIndex
<
aEndRowIndex
)
{
row
+
+
;
}
else
{
row
-
-
;
}
}
return
result
;
}
nsresult
nsFrameSelection
:
:
RemoveCellsFromSelection
(
nsIContent
*
aTable
int32_t
aStartRowIndex
int32_t
aStartColumnIndex
int32_t
aEndRowIndex
int32_t
aEndColumnIndex
)
{
const
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
const
RefPtr
<
mozilla
:
:
dom
:
:
Selection
>
selection
=
mDomSelections
[
index
]
;
if
(
!
selection
)
{
return
NS_ERROR_NULL_POINTER
;
}
return
mTableSelection
.
UnselectCells
(
aTable
aStartRowIndex
aStartColumnIndex
aEndRowIndex
aEndColumnIndex
false
*
selection
)
;
}
nsresult
nsFrameSelection
:
:
RestrictCellsToSelection
(
nsIContent
*
aTable
int32_t
aStartRowIndex
int32_t
aStartColumnIndex
int32_t
aEndRowIndex
int32_t
aEndColumnIndex
)
{
const
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
const
RefPtr
<
mozilla
:
:
dom
:
:
Selection
>
selection
=
mDomSelections
[
index
]
;
if
(
!
selection
)
{
return
NS_ERROR_NULL_POINTER
;
}
return
mTableSelection
.
UnselectCells
(
aTable
aStartRowIndex
aStartColumnIndex
aEndRowIndex
aEndColumnIndex
true
*
selection
)
;
}
nsresult
nsFrameSelection
:
:
TableSelection
:
:
SelectRowOrColumn
(
nsIContent
*
aCellContent
Selection
&
aNormalSelection
)
{
MOZ_ASSERT
(
aNormalSelection
.
Type
(
)
=
=
SelectionType
:
:
eNormal
)
;
if
(
!
aCellContent
)
{
return
NS_ERROR_NULL_POINTER
;
}
nsIContent
*
table
=
GetParentTable
(
aCellContent
)
;
if
(
!
table
)
{
return
NS_ERROR_NULL_POINTER
;
}
nsTableWrapperFrame
*
tableFrame
=
do_QueryFrame
(
table
-
>
GetPrimaryFrame
(
)
)
;
if
(
!
tableFrame
)
{
return
NS_ERROR_FAILURE
;
}
nsITableCellLayout
*
cellLayout
=
GetCellLayout
(
aCellContent
)
;
if
(
!
cellLayout
)
{
return
NS_ERROR_FAILURE
;
}
int32_t
rowIndex
colIndex
;
nsresult
result
=
cellLayout
-
>
GetCellIndexes
(
rowIndex
colIndex
)
;
if
(
NS_FAILED
(
result
)
)
{
return
result
;
}
if
(
mMode
=
=
TableSelectionMode
:
:
Row
)
{
colIndex
=
0
;
}
if
(
mMode
=
=
TableSelectionMode
:
:
Column
)
{
rowIndex
=
0
;
}
nsCOMPtr
<
nsIContent
>
firstCell
lastCell
;
while
(
true
)
{
nsCOMPtr
<
nsIContent
>
curCellContent
=
tableFrame
-
>
GetCellAt
(
rowIndex
colIndex
)
;
if
(
!
curCellContent
)
{
break
;
}
if
(
!
firstCell
)
{
firstCell
=
curCellContent
;
}
lastCell
=
std
:
:
move
(
curCellContent
)
;
if
(
mMode
=
=
TableSelectionMode
:
:
Row
)
{
colIndex
+
=
tableFrame
-
>
GetEffectiveRowSpanAt
(
rowIndex
colIndex
)
;
}
else
{
rowIndex
+
=
tableFrame
-
>
GetEffectiveRowSpanAt
(
rowIndex
colIndex
)
;
}
}
if
(
firstCell
&
&
lastCell
)
{
if
(
!
mStartSelectedCell
)
{
result
=
:
:
SelectCellElement
(
firstCell
aNormalSelection
)
;
if
(
NS_FAILED
(
result
)
)
{
return
result
;
}
mStartSelectedCell
=
firstCell
;
}
result
=
SelectBlockOfCells
(
mStartSelectedCell
lastCell
aNormalSelection
)
;
mEndSelectedCell
=
aCellContent
;
return
result
;
}
#
if
0
do
{
result
=
tableLayout
-
>
GetCellDataAt
(
rowIndex
colIndex
getter_AddRefs
(
cellElement
)
curRowIndex
curColIndex
rowSpan
colSpan
actualRowSpan
actualColSpan
isSelected
)
;
if
(
NS_FAILED
(
result
)
)
return
result
;
if
(
!
cellElement
)
break
;
NS_ASSERTION
(
actualColSpan
"
actualColSpan
is
0
!
"
)
;
NS_ASSERTION
(
actualRowSpan
"
actualRowSpan
is
0
!
"
)
;
if
(
!
isSelected
&
&
rowIndex
=
=
curRowIndex
&
&
colIndex
=
=
curColIndex
)
{
result
=
SelectCellElement
(
cellElement
)
;
if
(
NS_FAILED
(
result
)
)
return
result
;
}
if
(
mMode
=
=
TableSelectionMode
:
:
Row
)
colIndex
+
=
actualColSpan
;
else
rowIndex
+
=
actualRowSpan
;
}
while
(
cellElement
)
;
#
endif
return
NS_OK
;
}
nsIContent
*
nsFrameSelection
:
:
GetFirstCellNodeInRange
(
const
nsRange
*
aRange
)
{
if
(
!
aRange
)
return
nullptr
;
nsIContent
*
childContent
=
aRange
-
>
GetChildAtStartOffset
(
)
;
if
(
!
childContent
)
return
nullptr
;
if
(
!
IsCell
(
childContent
)
)
return
nullptr
;
return
childContent
;
}
nsRange
*
nsFrameSelection
:
:
TableSelection
:
:
GetFirstCellRange
(
const
mozilla
:
:
dom
:
:
Selection
&
aNormalSelection
)
{
MOZ_ASSERT
(
aNormalSelection
.
Type
(
)
=
=
SelectionType
:
:
eNormal
)
;
nsRange
*
firstRange
=
aNormalSelection
.
GetRangeAt
(
0
)
;
if
(
!
GetFirstCellNodeInRange
(
firstRange
)
)
{
return
nullptr
;
}
mSelectedCellIndex
=
1
;
return
firstRange
;
}
nsRange
*
nsFrameSelection
:
:
TableSelection
:
:
GetNextCellRange
(
const
mozilla
:
:
dom
:
:
Selection
&
aNormalSelection
)
{
MOZ_ASSERT
(
aNormalSelection
.
Type
(
)
=
=
SelectionType
:
:
eNormal
)
;
nsRange
*
range
=
aNormalSelection
.
GetRangeAt
(
mSelectedCellIndex
)
;
if
(
!
GetFirstCellNodeInRange
(
range
)
)
{
return
nullptr
;
}
mSelectedCellIndex
+
+
;
return
range
;
}
nsresult
nsFrameSelection
:
:
GetCellIndexes
(
nsIContent
*
aCell
int32_t
&
aRowIndex
int32_t
&
aColIndex
)
{
if
(
!
aCell
)
return
NS_ERROR_NULL_POINTER
;
aColIndex
=
0
;
aRowIndex
=
0
;
nsITableCellLayout
*
cellLayoutObject
=
GetCellLayout
(
aCell
)
;
if
(
!
cellLayoutObject
)
return
NS_ERROR_FAILURE
;
return
cellLayoutObject
-
>
GetCellIndexes
(
aRowIndex
aColIndex
)
;
}
nsIContent
*
nsFrameSelection
:
:
IsInSameTable
(
nsIContent
*
aContent1
nsIContent
*
aContent2
)
{
if
(
!
aContent1
|
|
!
aContent2
)
return
nullptr
;
nsIContent
*
tableNode1
=
GetParentTable
(
aContent1
)
;
nsIContent
*
tableNode2
=
GetParentTable
(
aContent2
)
;
return
(
tableNode1
=
=
tableNode2
)
?
tableNode1
:
nullptr
;
}
nsIContent
*
nsFrameSelection
:
:
GetParentTable
(
nsIContent
*
aCell
)
{
if
(
!
aCell
)
{
return
nullptr
;
}
for
(
nsIContent
*
parent
=
aCell
-
>
GetParent
(
)
;
parent
;
parent
=
parent
-
>
GetParent
(
)
)
{
if
(
parent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
{
return
parent
;
}
}
return
nullptr
;
}
nsresult
nsFrameSelection
:
:
SelectCellElement
(
nsIContent
*
aCellElement
)
{
const
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
const
RefPtr
<
Selection
>
selection
=
mDomSelections
[
index
]
;
if
(
!
selection
)
{
return
NS_ERROR_NULL_POINTER
;
}
return
:
:
SelectCellElement
(
aCellElement
*
selection
)
;
}
nsresult
CreateAndAddRange
(
nsINode
*
aContainer
int32_t
aOffset
Selection
&
aNormalSelection
)
{
MOZ_ASSERT
(
aNormalSelection
.
Type
(
)
=
=
SelectionType
:
:
eNormal
)
;
if
(
!
aContainer
)
{
return
NS_ERROR_NULL_POINTER
;
}
ErrorResult
error
;
RefPtr
<
nsRange
>
range
=
nsRange
:
:
Create
(
aContainer
aOffset
aContainer
aOffset
+
1
error
)
;
if
(
NS_WARN_IF
(
error
.
Failed
(
)
)
)
{
return
error
.
StealNSResult
(
)
;
}
MOZ_ASSERT
(
range
)
;
ErrorResult
err
;
aNormalSelection
.
AddRangeAndSelectFramesAndNotifyListeners
(
*
range
err
)
;
return
err
.
StealNSResult
(
)
;
}
void
nsFrameSelection
:
:
SetAncestorLimiter
(
nsIContent
*
aLimiter
)
{
if
(
mLimiters
.
mAncestorLimiter
!
=
aLimiter
)
{
mLimiters
.
mAncestorLimiter
=
aLimiter
;
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
if
(
!
mDomSelections
[
index
]
)
return
;
if
(
!
IsValidSelectionPoint
(
mDomSelections
[
index
]
-
>
GetFocusNode
(
)
)
)
{
ClearNormalSelection
(
)
;
if
(
mLimiters
.
mAncestorLimiter
)
{
SetChangeReasons
(
nsISelectionListener
:
:
NO_REASON
)
;
nsCOMPtr
<
nsIContent
>
limiter
(
mLimiters
.
mAncestorLimiter
)
;
TakeFocus
(
limiter
0
0
CARET_ASSOCIATE_BEFORE
FocusMode
:
:
kCollapseToNewPoint
)
;
}
}
}
}
void
nsFrameSelection
:
:
SetDelayedCaretData
(
WidgetMouseEvent
*
aMouseEvent
)
{
if
(
aMouseEvent
)
{
mDelayedMouseEvent
.
mIsValid
=
true
;
mDelayedMouseEvent
.
mIsShift
=
aMouseEvent
-
>
IsShift
(
)
;
mDelayedMouseEvent
.
mClickCount
=
aMouseEvent
-
>
mClickCount
;
}
else
{
mDelayedMouseEvent
.
mIsValid
=
false
;
}
}
void
nsFrameSelection
:
:
DisconnectFromPresShell
(
)
{
if
(
mAccessibleCaretEnabled
)
{
int8_t
index
=
GetIndexFromSelectionType
(
SelectionType
:
:
eNormal
)
;
mDomSelections
[
index
]
-
>
StopNotifyingAccessibleCaretEventHub
(
)
;
}
StopAutoScrollTimer
(
)
;
for
(
size_t
i
=
0
;
i
<
ArrayLength
(
mDomSelections
)
;
i
+
+
)
{
mDomSelections
[
i
]
-
>
Clear
(
nullptr
)
;
}
mPresShell
=
nullptr
;
}
#
ifdef
XP_MACOSX
static
nsresult
UpdateSelectionCacheOnRepaintSelection
(
Selection
*
aSel
)
{
PresShell
*
presShell
=
aSel
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
NS_OK
;
}
nsCOMPtr
<
Document
>
aDoc
=
presShell
-
>
GetDocument
(
)
;
if
(
aDoc
&
&
aSel
&
&
!
aSel
-
>
IsCollapsed
(
)
)
{
return
nsCopySupport
:
:
EncodeDocumentWithContextAndPutToClipboard
(
aSel
aDoc
nsIClipboard
:
:
kSelectionCache
false
)
;
}
return
NS_OK
;
}
#
endif
int16_t
AutoCopyListener
:
:
sClipboardID
=
-
1
;
void
AutoCopyListener
:
:
OnSelectionChange
(
Document
*
aDocument
Selection
&
aSelection
int16_t
aReason
)
{
MOZ_ASSERT
(
IsValidClipboardID
(
sClipboardID
)
)
;
if
(
sClipboardID
=
=
nsIClipboard
:
:
kSelectionCache
)
{
if
(
!
aDocument
|
|
!
IsInActiveTab
(
aDocument
)
)
{
return
;
}
}
static
const
int16_t
kResasonsToHandle
=
nsISelectionListener
:
:
MOUSEUP_REASON
|
nsISelectionListener
:
:
SELECTALL_REASON
|
nsISelectionListener
:
:
KEYPRESS_REASON
;
if
(
!
(
aReason
&
kResasonsToHandle
)
)
{
return
;
}
if
(
!
aDocument
|
|
aSelection
.
IsCollapsed
(
)
)
{
#
ifdef
DEBUG_CLIPBOARD
fprintf
(
stderr
"
CLIPBOARD
:
no
selection
/
collapsed
selection
\
n
"
)
;
#
endif
if
(
sClipboardID
!
=
nsIClipboard
:
:
kSelectionCache
)
{
return
;
}
DebugOnly
<
nsresult
>
rv
=
nsCopySupport
:
:
ClearSelectionCache
(
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
nsCopySupport
:
:
ClearSelectionCache
(
)
failed
"
)
;
return
;
}
DebugOnly
<
nsresult
>
rv
=
nsCopySupport
:
:
EncodeDocumentWithContextAndPutToClipboard
(
&
aSelection
aDocument
sClipboardID
false
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
nsCopySupport
:
:
EncodeDocumentWithContextAndPutToClipboard
(
)
failed
"
)
;
}
