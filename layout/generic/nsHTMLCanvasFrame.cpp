#
include
"
nsHTMLCanvasFrame
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
dom
/
HTMLCanvasElement
.
h
"
#
include
"
mozilla
/
layers
/
ImageDataSerializer
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderCanvasRenderer
.
h
"
#
include
"
mozilla
/
layers
/
RenderRootStateManager
.
h
"
#
include
"
mozilla
/
webgpu
/
CanvasContext
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsStyleUtil
.
h
"
#
include
"
Layers
.
h
"
#
include
"
ActiveLayerTracker
.
h
"
#
include
<
algorithm
>
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
gfx
;
static
IntrinsicSize
IntrinsicSizeFromCanvasSize
(
const
nsIntSize
&
aCanvasSizeInPx
)
{
return
IntrinsicSize
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
aCanvasSizeInPx
.
width
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
aCanvasSizeInPx
.
height
)
)
;
}
static
AspectRatio
IntrinsicRatioFromCanvasSize
(
const
nsIntSize
&
aCanvasSizeInPx
)
{
return
AspectRatio
:
:
FromSize
(
aCanvasSizeInPx
.
width
aCanvasSizeInPx
.
height
)
;
}
class
nsDisplayCanvas
final
:
public
nsPaintedDisplayItem
{
public
:
nsDisplayCanvas
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
:
nsPaintedDisplayItem
(
aBuilder
aFrame
)
{
MOZ_COUNT_CTOR
(
nsDisplayCanvas
)
;
}
MOZ_COUNTED_DTOR_OVERRIDE
(
nsDisplayCanvas
)
NS_DISPLAY_DECL_NAME
(
"
nsDisplayCanvas
"
TYPE_CANVAS
)
virtual
nsRegion
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
{
*
aSnap
=
false
;
nsHTMLCanvasFrame
*
f
=
static_cast
<
nsHTMLCanvasFrame
*
>
(
Frame
(
)
)
;
HTMLCanvasElement
*
canvas
=
HTMLCanvasElement
:
:
FromNode
(
f
-
>
GetContent
(
)
)
;
nsRegion
result
;
if
(
canvas
-
>
GetIsOpaque
(
)
)
{
nsRect
constraintRect
=
GetBounds
(
aBuilder
aSnap
)
;
nsIntSize
canvasSize
=
f
-
>
GetCanvasSize
(
)
;
IntrinsicSize
intrinsicSize
=
IntrinsicSizeFromCanvasSize
(
canvasSize
)
;
AspectRatio
intrinsicRatio
=
IntrinsicRatioFromCanvasSize
(
canvasSize
)
;
const
nsRect
destRect
=
nsLayoutUtils
:
:
ComputeObjectDestRect
(
constraintRect
intrinsicSize
intrinsicRatio
f
-
>
StylePosition
(
)
)
;
return
nsRegion
(
destRect
.
Intersect
(
constraintRect
)
)
;
}
return
result
;
}
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
{
*
aSnap
=
true
;
return
Frame
(
)
-
>
GetContentRectRelativeToSelf
(
)
+
ToReferenceFrame
(
)
;
}
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
{
HTMLCanvasElement
*
element
=
static_cast
<
HTMLCanvasElement
*
>
(
mFrame
-
>
GetContent
(
)
)
;
element
-
>
HandlePrintCallback
(
mFrame
-
>
PresContext
(
)
)
;
if
(
element
-
>
IsOffscreen
(
)
)
{
RefPtr
<
ImageContainer
>
container
=
element
-
>
GetImageContainer
(
)
;
if
(
container
)
{
nsHTMLCanvasFrame
*
canvasFrame
=
static_cast
<
nsHTMLCanvasFrame
*
>
(
mFrame
)
;
nsIntSize
canvasSizeInPx
=
canvasFrame
-
>
GetCanvasSize
(
)
;
IntrinsicSize
intrinsicSize
=
IntrinsicSizeFromCanvasSize
(
canvasSizeInPx
)
;
AspectRatio
intrinsicRatio
=
IntrinsicRatioFromCanvasSize
(
canvasSizeInPx
)
;
nsRect
area
=
mFrame
-
>
GetContentRectRelativeToSelf
(
)
+
ToReferenceFrame
(
)
;
nsRect
dest
=
nsLayoutUtils
:
:
ComputeObjectDestRect
(
area
intrinsicSize
intrinsicRatio
mFrame
-
>
StylePosition
(
)
)
;
LayoutDeviceRect
bounds
=
LayoutDeviceRect
:
:
FromAppUnits
(
dest
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
aManager
-
>
CommandBuilder
(
)
.
PushImage
(
this
container
aBuilder
aResources
aSc
bounds
bounds
)
;
}
return
true
;
}
switch
(
element
-
>
GetCurrentContextType
(
)
)
{
case
CanvasContextType
:
:
Canvas2D
:
case
CanvasContextType
:
:
WebGL1
:
case
CanvasContextType
:
:
WebGL2
:
{
bool
isRecycled
;
RefPtr
<
WebRenderCanvasData
>
canvasData
=
aManager
-
>
CommandBuilder
(
)
.
CreateOrRecycleWebRenderUserData
<
WebRenderCanvasData
>
(
this
&
isRecycled
)
;
nsHTMLCanvasFrame
*
canvasFrame
=
static_cast
<
nsHTMLCanvasFrame
*
>
(
mFrame
)
;
if
(
!
canvasFrame
-
>
UpdateWebRenderCanvasData
(
aDisplayListBuilder
canvasData
)
)
{
return
true
;
}
WebRenderCanvasRendererAsync
*
data
=
canvasData
-
>
GetCanvasRenderer
(
)
;
MOZ_ASSERT
(
data
)
;
data
-
>
UpdateCompositableClient
(
)
;
nsIntSize
canvasSizeInPx
=
data
-
>
GetSize
(
)
;
IntrinsicSize
intrinsicSize
=
IntrinsicSizeFromCanvasSize
(
canvasSizeInPx
)
;
AspectRatio
intrinsicRatio
=
IntrinsicRatioFromCanvasSize
(
canvasSizeInPx
)
;
nsRect
area
=
mFrame
-
>
GetContentRectRelativeToSelf
(
)
+
ToReferenceFrame
(
)
;
nsRect
dest
=
nsLayoutUtils
:
:
ComputeObjectDestRect
(
area
intrinsicSize
intrinsicRatio
mFrame
-
>
StylePosition
(
)
)
;
LayoutDeviceRect
bounds
=
LayoutDeviceRect
:
:
FromAppUnits
(
dest
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
wr
:
:
LayoutRect
r
=
wr
:
:
ToLayoutRect
(
bounds
)
;
aBuilder
.
PushIFrame
(
r
!
BackfaceIsHidden
(
)
data
-
>
GetPipelineId
(
)
.
ref
(
)
false
)
;
LayoutDeviceRect
scBounds
(
LayoutDevicePoint
(
0
0
)
bounds
.
Size
(
)
)
;
auto
filter
=
wr
:
:
ToImageRendering
(
mFrame
-
>
UsedImageRendering
(
)
)
;
auto
mixBlendMode
=
wr
:
:
MixBlendMode
:
:
Normal
;
aManager
-
>
WrBridge
(
)
-
>
AddWebRenderParentCommand
(
OpUpdateAsyncImagePipeline
(
data
-
>
GetPipelineId
(
)
.
value
(
)
scBounds
VideoInfo
:
:
Rotation
:
:
kDegree_0
filter
mixBlendMode
)
)
;
break
;
}
case
CanvasContextType
:
:
WebGPU
:
{
nsHTMLCanvasFrame
*
canvasFrame
=
static_cast
<
nsHTMLCanvasFrame
*
>
(
mFrame
)
;
HTMLCanvasElement
*
canvasElement
=
static_cast
<
HTMLCanvasElement
*
>
(
canvasFrame
-
>
GetContent
(
)
)
;
webgpu
:
:
CanvasContext
*
canvasContext
=
canvasElement
-
>
GetWebGPUContext
(
)
;
if
(
!
canvasContext
)
{
return
true
;
}
bool
isRecycled
;
RefPtr
<
WebRenderLocalCanvasData
>
canvasData
=
aManager
-
>
CommandBuilder
(
)
.
CreateOrRecycleWebRenderUserData
<
WebRenderLocalCanvasData
>
(
this
&
isRecycled
)
;
if
(
!
canvasContext
-
>
UpdateWebRenderLocalCanvasData
(
canvasData
)
)
{
return
true
;
}
const
wr
:
:
ImageDescriptor
imageDesc
=
canvasContext
-
>
MakeImageDescriptor
(
)
;
wr
:
:
ImageKey
imageKey
;
auto
imageKeyMaybe
=
canvasContext
-
>
GetImageKey
(
)
;
if
(
imageKeyMaybe
&
&
aManager
-
>
WrBridge
(
)
-
>
GetNamespace
(
)
=
=
imageKeyMaybe
-
>
mNamespace
)
{
imageKey
=
imageKeyMaybe
.
value
(
)
;
}
else
{
imageKey
=
canvasContext
-
>
CreateImageKey
(
aManager
)
;
aResources
.
AddPrivateExternalImage
(
canvasContext
-
>
mExternalImageId
imageKey
imageDesc
)
;
}
{
nsIntSize
canvasSizeInPx
=
canvasFrame
-
>
GetCanvasSize
(
)
;
IntrinsicSize
intrinsicSize
=
IntrinsicSizeFromCanvasSize
(
canvasSizeInPx
)
;
AspectRatio
intrinsicRatio
=
IntrinsicRatioFromCanvasSize
(
canvasSizeInPx
)
;
nsRect
area
=
mFrame
-
>
GetContentRectRelativeToSelf
(
)
+
ToReferenceFrame
(
)
;
nsRect
dest
=
nsLayoutUtils
:
:
ComputeObjectDestRect
(
area
intrinsicSize
intrinsicRatio
mFrame
-
>
StylePosition
(
)
)
;
LayoutDeviceRect
bounds
=
LayoutDeviceRect
:
:
FromAppUnits
(
dest
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
auto
rendering
=
wr
:
:
ToImageRendering
(
mFrame
-
>
UsedImageRendering
(
)
)
;
aBuilder
.
PushImage
(
wr
:
:
ToLayoutRect
(
bounds
)
wr
:
:
ToLayoutRect
(
bounds
)
!
BackfaceIsHidden
(
)
rendering
imageKey
)
;
}
canvasData
-
>
mDescriptor
=
imageDesc
;
canvasData
-
>
mImageKey
=
imageKey
;
canvasData
-
>
RequestFrameReadback
(
)
;
break
;
}
case
CanvasContextType
:
:
ImageBitmap
:
{
nsHTMLCanvasFrame
*
canvasFrame
=
static_cast
<
nsHTMLCanvasFrame
*
>
(
mFrame
)
;
nsIntSize
canvasSizeInPx
=
canvasFrame
-
>
GetCanvasSize
(
)
;
if
(
canvasSizeInPx
.
width
<
=
0
|
|
canvasSizeInPx
.
height
<
=
0
)
{
return
true
;
}
bool
isRecycled
;
RefPtr
<
WebRenderCanvasData
>
canvasData
=
aManager
-
>
CommandBuilder
(
)
.
CreateOrRecycleWebRenderUserData
<
WebRenderCanvasData
>
(
this
&
isRecycled
)
;
if
(
!
canvasFrame
-
>
UpdateWebRenderCanvasData
(
aDisplayListBuilder
canvasData
)
)
{
canvasData
-
>
ClearImageContainer
(
)
;
return
true
;
}
IntrinsicSize
intrinsicSize
=
IntrinsicSizeFromCanvasSize
(
canvasSizeInPx
)
;
AspectRatio
intrinsicRatio
=
IntrinsicRatioFromCanvasSize
(
canvasSizeInPx
)
;
nsRect
area
=
mFrame
-
>
GetContentRectRelativeToSelf
(
)
+
ToReferenceFrame
(
)
;
nsRect
dest
=
nsLayoutUtils
:
:
ComputeObjectDestRect
(
area
intrinsicSize
intrinsicRatio
mFrame
-
>
StylePosition
(
)
)
;
LayoutDeviceRect
bounds
=
LayoutDeviceRect
:
:
FromAppUnits
(
dest
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
aManager
-
>
CommandBuilder
(
)
.
PushImage
(
this
canvasData
-
>
GetImageContainer
(
)
aBuilder
aResources
aSc
bounds
bounds
)
;
break
;
}
case
CanvasContextType
:
:
NoContext
:
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unknown
canvas
context
type
"
)
;
}
return
true
;
}
virtual
bool
IsContentful
(
)
const
override
{
nsHTMLCanvasFrame
*
f
=
static_cast
<
nsHTMLCanvasFrame
*
>
(
Frame
(
)
)
;
HTMLCanvasElement
*
canvas
=
HTMLCanvasElement
:
:
FromNode
(
f
-
>
GetContent
(
)
)
;
return
canvas
-
>
MaybeModified
(
)
;
}
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
{
nsHTMLCanvasFrame
*
f
=
static_cast
<
nsHTMLCanvasFrame
*
>
(
Frame
(
)
)
;
HTMLCanvasElement
*
canvas
=
HTMLCanvasElement
:
:
FromNode
(
f
-
>
GetContent
(
)
)
;
nsRect
area
=
f
-
>
GetContentRectRelativeToSelf
(
)
+
ToReferenceFrame
(
)
;
nsIntSize
canvasSizeInPx
=
f
-
>
GetCanvasSize
(
)
;
nsPresContext
*
presContext
=
f
-
>
PresContext
(
)
;
canvas
-
>
HandlePrintCallback
(
presContext
)
;
if
(
canvasSizeInPx
.
width
<
=
0
|
|
canvasSizeInPx
.
height
<
=
0
|
|
area
.
IsEmpty
(
)
)
{
return
;
}
IntrinsicSize
intrinsicSize
=
IntrinsicSizeFromCanvasSize
(
canvasSizeInPx
)
;
AspectRatio
intrinsicRatio
=
IntrinsicRatioFromCanvasSize
(
canvasSizeInPx
)
;
nsRect
dest
=
nsLayoutUtils
:
:
ComputeObjectDestRect
(
area
intrinsicSize
intrinsicRatio
f
-
>
StylePosition
(
)
)
;
gfxRect
destGFXRect
=
presContext
-
>
AppUnitsToGfxUnits
(
dest
)
;
gfxPoint
p
=
destGFXRect
.
TopLeft
(
)
;
Matrix
transform
=
Matrix
:
:
Translation
(
p
.
x
p
.
y
)
;
transform
.
PreScale
(
destGFXRect
.
Width
(
)
/
canvasSizeInPx
.
width
destGFXRect
.
Height
(
)
/
canvasSizeInPx
.
height
)
;
gfxContextMatrixAutoSaveRestore
saveMatrix
(
aCtx
)
;
aCtx
-
>
SetMatrix
(
gfxUtils
:
:
SnapTransformTranslation
(
aCtx
-
>
CurrentMatrix
(
)
nullptr
)
)
;
if
(
RefPtr
<
layers
:
:
Image
>
image
=
canvas
-
>
GetAsImage
(
)
)
{
RefPtr
<
gfx
:
:
SourceSurface
>
surface
=
image
-
>
GetAsSourceSurface
(
)
;
if
(
!
surface
|
|
!
surface
-
>
IsValid
(
)
)
{
return
;
}
gfx
:
:
IntSize
size
=
surface
-
>
GetSize
(
)
;
transform
=
gfxUtils
:
:
SnapTransform
(
transform
gfxRect
(
0
0
size
.
width
size
.
height
)
nullptr
)
;
aCtx
-
>
Multiply
(
transform
)
;
aCtx
-
>
GetDrawTarget
(
)
-
>
FillRect
(
Rect
(
0
0
size
.
width
size
.
height
)
SurfacePattern
(
surface
ExtendMode
:
:
CLAMP
Matrix
(
)
nsLayoutUtils
:
:
GetSamplingFilterForFrame
(
f
)
)
)
;
return
;
}
if
(
canvas
-
>
IsOffscreen
(
)
)
{
return
;
}
RefPtr
<
CanvasRenderer
>
renderer
=
new
CanvasRenderer
(
)
;
if
(
!
canvas
-
>
InitializeCanvasRenderer
(
aBuilder
renderer
)
)
{
return
;
}
renderer
-
>
FirePreTransactionCallback
(
)
;
const
auto
snapshot
=
renderer
-
>
BorrowSnapshot
(
)
;
if
(
!
snapshot
)
return
;
const
auto
&
surface
=
snapshot
-
>
mSurf
;
transform
=
gfxUtils
:
:
SnapTransform
(
transform
gfxRect
(
0
0
canvasSizeInPx
.
width
canvasSizeInPx
.
height
)
nullptr
)
;
if
(
!
renderer
-
>
YIsDown
(
)
)
{
transform
.
PreTranslate
(
0
.
0f
canvasSizeInPx
.
height
)
.
PreScale
(
1
.
0f
-
1
.
0f
)
;
}
aCtx
-
>
Multiply
(
transform
)
;
aCtx
-
>
GetDrawTarget
(
)
-
>
FillRect
(
Rect
(
0
0
canvasSizeInPx
.
width
canvasSizeInPx
.
height
)
SurfacePattern
(
surface
ExtendMode
:
:
CLAMP
Matrix
(
)
nsLayoutUtils
:
:
GetSamplingFilterForFrame
(
f
)
)
)
;
renderer
-
>
FireDidTransactionCallback
(
)
;
renderer
-
>
ResetDirty
(
)
;
}
}
;
nsIFrame
*
NS_NewHTMLCanvasFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsHTMLCanvasFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
NS_QUERYFRAME_HEAD
(
nsHTMLCanvasFrame
)
NS_QUERYFRAME_ENTRY
(
nsHTMLCanvasFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsContainerFrame
)
NS_IMPL_FRAMEARENA_HELPERS
(
nsHTMLCanvasFrame
)
void
nsHTMLCanvasFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
nsContainerFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
ActiveLayerTracker
:
:
NotifyContentChange
(
this
)
;
}
void
nsHTMLCanvasFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestroyRoot
PostDestroyData
&
aPostDestroyData
)
{
if
(
IsPrimaryFrame
(
)
)
{
HTMLCanvasElement
:
:
FromNode
(
*
mContent
)
-
>
ResetPrintCallback
(
)
;
}
nsContainerFrame
:
:
DestroyFrom
(
aDestroyRoot
aPostDestroyData
)
;
}
nsHTMLCanvasFrame
:
:
~
nsHTMLCanvasFrame
(
)
=
default
;
nsIntSize
nsHTMLCanvasFrame
:
:
GetCanvasSize
(
)
const
{
nsIntSize
size
(
0
0
)
;
HTMLCanvasElement
*
canvas
=
HTMLCanvasElement
:
:
FromNodeOrNull
(
GetContent
(
)
)
;
if
(
canvas
)
{
size
=
canvas
-
>
GetSize
(
)
;
MOZ_ASSERT
(
size
.
width
>
=
0
&
&
size
.
height
>
=
0
"
we
should
'
ve
required
<
canvas
>
width
/
height
attrs
to
be
"
"
unsigned
(
non
-
negative
)
values
"
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
couldn
'
t
get
canvas
size
"
)
;
}
return
size
;
}
nscoord
nsHTMLCanvasFrame
:
:
GetMinISize
(
gfxContext
*
aRenderingContext
)
{
bool
vertical
=
GetWritingMode
(
)
.
IsVertical
(
)
;
nscoord
result
;
if
(
StyleDisplay
(
)
-
>
IsContainSize
(
)
)
{
result
=
0
;
}
else
{
result
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
vertical
?
GetCanvasSize
(
)
.
height
:
GetCanvasSize
(
)
.
width
)
;
}
DISPLAY_MIN_INLINE_SIZE
(
this
result
)
;
return
result
;
}
nscoord
nsHTMLCanvasFrame
:
:
GetPrefISize
(
gfxContext
*
aRenderingContext
)
{
bool
vertical
=
GetWritingMode
(
)
.
IsVertical
(
)
;
nscoord
result
;
if
(
StyleDisplay
(
)
-
>
IsContainSize
(
)
)
{
result
=
0
;
}
else
{
result
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
vertical
?
GetCanvasSize
(
)
.
height
:
GetCanvasSize
(
)
.
width
)
;
}
DISPLAY_PREF_INLINE_SIZE
(
this
result
)
;
return
result
;
}
IntrinsicSize
nsHTMLCanvasFrame
:
:
GetIntrinsicSize
(
)
{
if
(
StyleDisplay
(
)
-
>
IsContainSize
(
)
)
{
return
IntrinsicSize
(
0
0
)
;
}
return
IntrinsicSizeFromCanvasSize
(
GetCanvasSize
(
)
)
;
}
AspectRatio
nsHTMLCanvasFrame
:
:
GetIntrinsicRatio
(
)
const
{
if
(
StyleDisplay
(
)
-
>
IsContainSize
(
)
)
{
return
AspectRatio
(
)
;
}
return
IntrinsicRatioFromCanvasSize
(
GetCanvasSize
(
)
)
;
}
nsIFrame
:
:
SizeComputationResult
nsHTMLCanvasFrame
:
:
ComputeSize
(
gfxContext
*
aRenderingContext
WritingMode
aWM
const
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
LogicalSize
&
aMargin
const
LogicalSize
&
aBorderPadding
const
StyleSizeOverrides
&
aSizeOverrides
ComputeSizeFlags
aFlags
)
{
return
{
ComputeSizeWithIntrinsicDimensions
(
aRenderingContext
aWM
GetIntrinsicSize
(
)
GetAspectRatio
(
)
aCBSize
aMargin
aBorderPadding
aSizeOverrides
aFlags
)
AspectRatioUsage
:
:
None
}
;
}
void
nsHTMLCanvasFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aMetrics
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsHTMLCanvasFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aMetrics
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
NS_FRAME_TRACE
(
NS_FRAME_TRACE_CALLS
(
"
enter
nsHTMLCanvasFrame
:
:
Reflow
:
availSize
=
%
d
%
d
"
aReflowInput
.
AvailableWidth
(
)
aReflowInput
.
AvailableHeight
(
)
)
)
;
MOZ_ASSERT
(
mState
&
NS_FRAME_IN_REFLOW
"
frame
is
not
in
reflow
"
)
;
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
const
LogicalSize
finalSize
=
aReflowInput
.
ComputedSizeWithBorderPadding
(
wm
)
;
aMetrics
.
SetSize
(
wm
finalSize
)
;
aMetrics
.
SetOverflowAreasToDesiredBounds
(
)
;
FinishAndStoreOverflow
(
&
aMetrics
)
;
nsReflowStatus
childStatus
;
nsIFrame
*
childFrame
=
mFrames
.
FirstChild
(
)
;
WritingMode
childWM
=
childFrame
-
>
GetWritingMode
(
)
;
LogicalSize
availSize
=
aReflowInput
.
ComputedSize
(
childWM
)
;
availSize
.
BSize
(
childWM
)
=
NS_UNCONSTRAINEDSIZE
;
NS_ASSERTION
(
!
childFrame
-
>
GetNextSibling
(
)
"
HTML
canvas
should
have
1
kid
"
)
;
ReflowOutput
childDesiredSize
(
aReflowInput
.
GetWritingMode
(
)
)
;
ReflowInput
childReflowInput
(
aPresContext
aReflowInput
childFrame
availSize
)
;
ReflowChild
(
childFrame
aPresContext
childDesiredSize
childReflowInput
0
0
ReflowChildFlags
:
:
Default
childStatus
nullptr
)
;
FinishReflowChild
(
childFrame
aPresContext
childDesiredSize
&
childReflowInput
0
0
ReflowChildFlags
:
:
Default
)
;
NS_FRAME_TRACE
(
NS_FRAME_TRACE_CALLS
(
"
exit
nsHTMLCanvasFrame
:
:
Reflow
:
size
=
%
d
%
d
"
aMetrics
.
ISize
(
wm
)
aMetrics
.
BSize
(
wm
)
)
)
;
NS_FRAME_SET_TRUNCATION
(
aStatus
aReflowInput
aMetrics
)
;
}
bool
nsHTMLCanvasFrame
:
:
UpdateWebRenderCanvasData
(
nsDisplayListBuilder
*
aBuilder
WebRenderCanvasData
*
aCanvasData
)
{
HTMLCanvasElement
*
element
=
static_cast
<
HTMLCanvasElement
*
>
(
GetContent
(
)
)
;
return
element
-
>
UpdateWebRenderCanvasData
(
aBuilder
aCanvasData
)
;
}
void
nsHTMLCanvasFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
if
(
!
IsVisibleForPainting
(
)
)
return
;
DisplayBorderBackgroundOutline
(
aBuilder
aLists
)
;
uint32_t
clipFlags
=
nsStyleUtil
:
:
ObjectPropsMightCauseOverflow
(
StylePosition
(
)
)
?
0
:
DisplayListClipState
:
:
ASSUME_DRAWING_RESTRICTED_TO_CONTENT_RECT
;
DisplayListClipState
:
:
AutoClipContainingBlockDescendantsToContentBox
clip
(
aBuilder
this
clipFlags
)
;
aLists
.
Content
(
)
-
>
AppendNewToTop
<
nsDisplayCanvas
>
(
aBuilder
this
)
;
DisplaySelectionOverlay
(
aBuilder
aLists
.
Content
(
)
nsISelectionDisplay
:
:
DISPLAY_IMAGES
)
;
}
void
nsHTMLCanvasFrame
:
:
AppendDirectlyOwnedAnonBoxes
(
nsTArray
<
OwnedAnonBox
>
&
aResult
)
{
MOZ_ASSERT
(
mFrames
.
FirstChild
(
)
"
Must
have
our
canvas
content
anon
box
"
)
;
MOZ_ASSERT
(
!
mFrames
.
FirstChild
(
)
-
>
GetNextSibling
(
)
"
Must
only
have
our
canvas
content
anon
box
"
)
;
aResult
.
AppendElement
(
OwnedAnonBox
(
mFrames
.
FirstChild
(
)
)
)
;
}
#
ifdef
ACCESSIBILITY
a11y
:
:
AccType
nsHTMLCanvasFrame
:
:
AccessibleType
(
)
{
return
a11y
:
:
eHTMLCanvasType
;
}
#
endif
#
ifdef
DEBUG_FRAME_DUMP
nsresult
nsHTMLCanvasFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
u
"
HTMLCanvas
"
_ns
aResult
)
;
}
#
endif
