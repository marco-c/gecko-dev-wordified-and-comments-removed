#
include
"
nsBackdropFrame
.
h
"
#
include
"
nsDisplayList
.
h
"
using
namespace
mozilla
;
NS_IMPL_FRAMEARENA_HELPERS
(
nsBackdropFrame
)
#
ifdef
DEBUG_FRAME_DUMP
nsresult
nsBackdropFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
u
"
Backdrop
"
_ns
aResult
)
;
}
#
endif
ComputedStyle
*
nsBackdropFrame
:
:
GetParentComputedStyle
(
nsIFrame
*
*
aProviderFrame
)
const
{
*
aProviderFrame
=
nullptr
;
return
nullptr
;
}
void
nsBackdropFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
DO_GLOBAL_REFLOW_COUNT_DSP
(
"
nsBackdropFrame
"
)
;
auto
display
=
StyleDisplay
(
)
-
>
mDisplay
;
if
(
display
=
=
mozilla
:
:
StyleDisplay
:
:
None
|
|
display
=
=
mozilla
:
:
StyleDisplay
:
:
Contents
)
{
return
;
}
DisplayBorderBackgroundOutline
(
aBuilder
aLists
)
;
}
LogicalSize
nsBackdropFrame
:
:
ComputeAutoSize
(
gfxContext
*
aRenderingContext
WritingMode
aWM
const
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
LogicalSize
&
aMargin
const
LogicalSize
&
aBorder
const
LogicalSize
&
aPadding
ComputeSizeFlags
aFlags
)
{
LogicalSize
result
(
aWM
0xdeadbeef
NS_UNCONSTRAINEDSIZE
)
;
if
(
aFlags
.
contains
(
ComputeSizeFlag
:
:
ShrinkWrap
)
)
{
result
.
ISize
(
aWM
)
=
0
;
}
else
{
result
.
ISize
(
aWM
)
=
aAvailableISize
-
aMargin
.
ISize
(
aWM
)
-
aBorder
.
ISize
(
aWM
)
-
aPadding
.
ISize
(
aWM
)
;
}
return
result
;
}
void
nsBackdropFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsBackdropFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aDesiredSize
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
LogicalMargin
borderPadding
=
aReflowInput
.
ComputedLogicalBorderPadding
(
)
;
nscoord
isize
=
aReflowInput
.
ComputedISize
(
)
+
borderPadding
.
IStartEnd
(
wm
)
;
nscoord
bsize
=
aReflowInput
.
ComputedBSize
(
)
+
borderPadding
.
BStartEnd
(
wm
)
;
aDesiredSize
.
SetSize
(
wm
LogicalSize
(
wm
isize
bsize
)
)
;
}
