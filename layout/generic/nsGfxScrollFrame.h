#
ifndef
nsGfxScrollFrame_h___
#
define
nsGfxScrollFrame_h___
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsIAnonymousContentCreator
.
h
"
#
include
"
nsBoxFrame
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsIScrollbarMediator
.
h
"
#
include
"
nsIStatefulFrame
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsIReflowCallback
.
h
"
#
include
"
nsBoxLayoutState
.
h
"
#
include
"
nsQueryFrame
.
h
"
#
include
"
nsRefreshDriver
.
h
"
#
include
"
nsExpirationTracker
.
h
"
#
include
"
TextOverflow
.
h
"
#
include
"
ScrollVelocityQueue
.
h
"
#
include
"
mozilla
/
PresState
.
h
"
#
include
"
mozilla
/
layout
/
ScrollAnchorContainer
.
h
"
class
nsPresContext
;
class
nsIPresShell
;
class
nsIContent
;
class
nsAtom
;
class
nsIScrollPositionListener
;
namespace
mozilla
{
struct
ScrollReflowInput
;
namespace
layers
{
class
Layer
;
class
LayerManager
;
}
namespace
layout
{
class
ScrollbarActivity
;
}
class
ScrollFrameHelper
:
public
nsIReflowCallback
{
public
:
typedef
nsIFrame
:
:
Sides
Sides
;
typedef
mozilla
:
:
CSSIntPoint
CSSIntPoint
;
typedef
mozilla
:
:
layout
:
:
ScrollbarActivity
ScrollbarActivity
;
typedef
mozilla
:
:
layers
:
:
FrameMetrics
FrameMetrics
;
typedef
mozilla
:
:
layers
:
:
ScrollableLayerGuid
ScrollableLayerGuid
;
typedef
mozilla
:
:
layers
:
:
ScrollSnapInfo
ScrollSnapInfo
;
typedef
mozilla
:
:
layers
:
:
Layer
Layer
;
typedef
mozilla
:
:
layers
:
:
LayerManager
LayerManager
;
typedef
mozilla
:
:
layout
:
:
ScrollAnchorContainer
ScrollAnchorContainer
;
class
AsyncScroll
;
class
AsyncSmoothMSDScroll
;
ScrollFrameHelper
(
nsContainerFrame
*
aOuter
bool
aIsRoot
)
;
~
ScrollFrameHelper
(
)
;
mozilla
:
:
ScrollStyles
GetScrollStylesFromFrame
(
)
const
;
void
ReloadChildFrames
(
)
;
nsresult
CreateAnonymousContent
(
nsTArray
<
nsIAnonymousContentCreator
:
:
ContentInfo
>
&
aElements
)
;
void
AppendAnonymousContentTo
(
nsTArray
<
nsIContent
*
>
&
aElements
uint32_t
aFilter
)
;
nsresult
FireScrollPortEvent
(
)
;
void
PostScrollEndEvent
(
)
;
void
FireScrollEndEvent
(
)
;
void
PostOverflowEvent
(
)
;
using
PostDestroyData
=
nsIFrame
:
:
PostDestroyData
;
void
Destroy
(
PostDestroyData
&
aPostDestroyData
)
;
void
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
;
void
AppendScrollPartsTo
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
bool
aCreateLayer
bool
aPositioned
)
;
bool
GetBorderRadii
(
const
nsSize
&
aFrameSize
const
nsSize
&
aBorderArea
Sides
aSkipSides
nscoord
aRadii
[
8
]
)
const
;
virtual
bool
ReflowFinished
(
)
override
;
virtual
void
ReflowCallbackCanceled
(
)
override
;
void
CurPosAttributeChanged
(
nsIContent
*
aChild
bool
aDoScroll
=
true
)
;
void
PostScrollEvent
(
bool
aDelayed
=
false
)
;
void
FireScrollEvent
(
)
;
void
PostScrolledAreaEvent
(
)
;
void
FireScrolledAreaEvent
(
)
;
bool
IsSmoothScrollingEnabled
(
)
;
class
ScrollEvent
:
public
Runnable
{
public
:
NS_DECL_NSIRUNNABLE
explicit
ScrollEvent
(
ScrollFrameHelper
*
aHelper
bool
aDelayed
)
;
void
Revoke
(
)
{
mHelper
=
nullptr
;
}
private
:
ScrollFrameHelper
*
mHelper
;
}
;
class
ScrollEndEvent
:
public
Runnable
{
public
:
NS_DECL_NSIRUNNABLE
explicit
ScrollEndEvent
(
ScrollFrameHelper
*
aHelper
)
;
void
Revoke
(
)
{
mHelper
=
nullptr
;
}
private
:
ScrollFrameHelper
*
mHelper
;
}
;
class
AsyncScrollPortEvent
:
public
Runnable
{
public
:
NS_DECL_NSIRUNNABLE
explicit
AsyncScrollPortEvent
(
ScrollFrameHelper
*
helper
)
:
Runnable
(
"
ScrollFrameHelper
:
:
AsyncScrollPortEvent
"
)
mHelper
(
helper
)
{
}
void
Revoke
(
)
{
mHelper
=
nullptr
;
}
private
:
ScrollFrameHelper
*
mHelper
;
}
;
class
ScrolledAreaEvent
:
public
Runnable
{
public
:
NS_DECL_NSIRUNNABLE
explicit
ScrolledAreaEvent
(
ScrollFrameHelper
*
helper
)
:
Runnable
(
"
ScrollFrameHelper
:
:
ScrolledAreaEvent
"
)
mHelper
(
helper
)
{
}
void
Revoke
(
)
{
mHelper
=
nullptr
;
}
private
:
ScrollFrameHelper
*
mHelper
;
}
;
void
FinishReflowForScrollbar
(
mozilla
:
:
dom
:
:
Element
*
aElement
nscoord
aMinXY
nscoord
aMaxXY
nscoord
aCurPosXY
nscoord
aPageIncrement
nscoord
aIncrement
)
;
void
SetScrollbarEnabled
(
mozilla
:
:
dom
:
:
Element
*
aElement
nscoord
aMaxPos
)
;
void
SetCoordAttribute
(
mozilla
:
:
dom
:
:
Element
*
aElement
nsAtom
*
aAtom
nscoord
aSize
)
;
nscoord
GetCoordAttribute
(
nsIFrame
*
aFrame
nsAtom
*
aAtom
nscoord
aDefaultValue
nscoord
*
aRangeStart
nscoord
*
aRangeLength
)
;
void
UpdateScrollbarPosition
(
)
;
nsRect
GetScrollPortRect
(
)
const
{
return
mScrollPort
;
}
nsPoint
GetScrollPosition
(
)
const
{
return
mScrollPort
.
TopLeft
(
)
-
mScrolledFrame
-
>
GetPosition
(
)
;
}
nsPoint
GetLogicalScrollPosition
(
)
const
{
nsPoint
pt
;
pt
.
x
=
IsPhysicalLTR
(
)
?
mScrollPort
.
x
-
mScrolledFrame
-
>
GetPosition
(
)
.
x
:
mScrollPort
.
XMost
(
)
-
mScrolledFrame
-
>
GetRect
(
)
.
XMost
(
)
;
pt
.
y
=
mScrollPort
.
y
-
mScrolledFrame
-
>
GetPosition
(
)
.
y
;
return
pt
;
}
nsPoint
GetApzScrollPosition
(
)
const
{
return
mApzScrollPos
;
}
nsRect
GetScrollRange
(
)
const
;
nsRect
GetScrollRange
(
nscoord
aWidth
nscoord
aHeight
)
const
;
nsSize
GetVisualViewportSize
(
)
const
;
nsPoint
GetVisualViewportOffset
(
)
const
;
nsRect
GetVisualOptimalViewingRect
(
)
const
;
nsPoint
GetLogicalVisualViewportOffset
(
)
const
{
nsPoint
pt
=
GetVisualViewportOffset
(
)
;
if
(
!
IsPhysicalLTR
(
)
)
{
pt
.
x
+
=
GetVisualViewportSize
(
)
.
width
-
mScrolledFrame
-
>
GetRect
(
)
.
width
;
}
return
pt
;
}
void
ScrollSnap
(
nsIScrollableFrame
:
:
ScrollMode
aMode
=
nsIScrollableFrame
:
:
SMOOTH_MSD
)
;
void
ScrollSnap
(
const
nsPoint
&
aDestination
nsIScrollableFrame
:
:
ScrollMode
aMode
=
nsIScrollableFrame
:
:
SMOOTH_MSD
)
;
protected
:
nsRect
GetScrollRangeForClamping
(
)
const
;
public
:
static
void
AsyncScrollCallback
(
ScrollFrameHelper
*
aInstance
mozilla
:
:
TimeStamp
aTime
)
;
static
void
AsyncSmoothMSDScrollCallback
(
ScrollFrameHelper
*
aInstance
mozilla
:
:
TimeDuration
aDeltaTime
)
;
void
ScrollTo
(
nsPoint
aScrollPosition
nsIScrollableFrame
:
:
ScrollMode
aMode
nsAtom
*
aOrigin
=
nullptr
const
nsRect
*
aRange
=
nullptr
nsIScrollbarMediator
:
:
ScrollSnapMode
aSnap
=
nsIScrollbarMediator
:
:
DISABLE_SNAP
)
;
void
ScrollToCSSPixels
(
const
CSSIntPoint
&
aScrollPosition
nsIScrollableFrame
:
:
ScrollMode
aMode
=
nsIScrollableFrame
:
:
INSTANT
nsAtom
*
aOrigin
=
nullptr
)
;
void
ScrollToCSSPixelsApproximate
(
const
mozilla
:
:
CSSPoint
&
aScrollPosition
nsAtom
*
aOrigin
=
nullptr
)
;
CSSIntPoint
GetScrollPositionCSSPixels
(
)
;
void
ScrollToImpl
(
nsPoint
aScrollPosition
const
nsRect
&
aRange
nsAtom
*
aOrigin
=
nullptr
)
;
void
ScrollVisual
(
)
;
void
ScrollBy
(
nsIntPoint
aDelta
nsIScrollableFrame
:
:
ScrollUnit
aUnit
nsIScrollableFrame
:
:
ScrollMode
aMode
nsIntPoint
*
aOverflow
nsAtom
*
aOrigin
=
nullptr
nsIScrollableFrame
:
:
ScrollMomentum
aMomentum
=
nsIScrollableFrame
:
:
NOT_MOMENTUM
nsIScrollbarMediator
:
:
ScrollSnapMode
aSnap
=
nsIScrollbarMediator
:
:
DISABLE_SNAP
)
;
void
ScrollByCSSPixels
(
const
CSSIntPoint
&
aDelta
nsIScrollableFrame
:
:
ScrollMode
aMode
=
nsIScrollableFrame
:
:
INSTANT
nsAtom
*
aOrigin
=
nullptr
)
;
void
ScrollToRestoredPosition
(
)
;
enum
class
LoadingState
{
Loading
Stopped
Loaded
}
;
LoadingState
GetPageLoadingState
(
)
;
bool
GetSnapPointForDestination
(
nsIScrollableFrame
:
:
ScrollUnit
aUnit
nsPoint
aStartPos
nsPoint
&
aDestination
)
;
nsSize
GetLineScrollAmount
(
)
const
;
nsSize
GetPageScrollAmount
(
)
const
;
mozilla
:
:
UniquePtr
<
mozilla
:
:
PresState
>
SaveState
(
)
const
;
void
RestoreState
(
mozilla
:
:
PresState
*
aState
)
;
nsIFrame
*
GetScrolledFrame
(
)
const
{
return
mScrolledFrame
;
}
nsIFrame
*
GetScrollbarBox
(
bool
aVertical
)
const
{
return
aVertical
?
mVScrollbarBox
:
mHScrollbarBox
;
}
void
AddScrollPositionListener
(
nsIScrollPositionListener
*
aListener
)
{
mListeners
.
AppendElement
(
aListener
)
;
}
void
RemoveScrollPositionListener
(
nsIScrollPositionListener
*
aListener
)
{
mListeners
.
RemoveElement
(
aListener
)
;
}
static
void
SetScrollbarVisibility
(
nsIFrame
*
aScrollbar
bool
aVisible
)
;
nsRect
GetScrolledRect
(
)
const
;
nsRect
GetUnsnappedScrolledRectInternal
(
const
nsRect
&
aScrolledOverflowArea
const
nsSize
&
aScrollPortSize
)
const
;
uint32_t
GetScrollbarVisibility
(
)
const
{
return
(
mHasVerticalScrollbar
?
nsIScrollableFrame
:
:
VERTICAL
:
0
)
|
(
mHasHorizontalScrollbar
?
nsIScrollableFrame
:
:
HORIZONTAL
:
0
)
;
}
nsMargin
GetActualScrollbarSizes
(
)
const
;
nsMargin
GetDesiredScrollbarSizes
(
nsBoxLayoutState
*
aState
)
;
nscoord
GetNondisappearingScrollbarWidth
(
nsBoxLayoutState
*
aState
mozilla
:
:
WritingMode
aVerticalWM
)
;
bool
IsPhysicalLTR
(
)
const
{
WritingMode
wm
=
GetFrameForDir
(
)
-
>
GetWritingMode
(
)
;
return
wm
.
IsVertical
(
)
?
wm
.
IsVerticalLR
(
)
:
wm
.
IsBidiLTR
(
)
;
}
bool
IsBidiLTR
(
)
const
{
nsIFrame
*
frame
=
GetFrameForDir
(
)
;
return
frame
-
>
StyleVisibility
(
)
-
>
mDirection
=
=
NS_STYLE_DIRECTION_LTR
;
}
private
:
nsIFrame
*
GetFrameForDir
(
)
const
;
public
:
bool
IsScrollbarOnRight
(
)
const
;
bool
IsScrollingActive
(
nsDisplayListBuilder
*
aBuilder
)
const
;
bool
IsMaybeAsynchronouslyScrolled
(
)
const
{
return
mWillBuildScrollableLayer
;
}
bool
IsMaybeScrollingActive
(
)
const
;
bool
IsProcessingAsyncScroll
(
)
const
{
return
mAsyncScroll
!
=
nullptr
|
|
mAsyncSmoothMSDScroll
!
=
nullptr
;
}
void
ResetScrollPositionForLayerPixelAlignment
(
)
{
mScrollPosForLayerPixelAlignment
=
GetScrollPosition
(
)
;
}
bool
ComputeCustomOverflow
(
nsOverflowAreas
&
aOverflowAreas
)
;
void
UpdateSticky
(
)
;
void
UpdatePrevScrolledRect
(
)
;
bool
IsRectNearlyVisible
(
const
nsRect
&
aRect
)
const
;
nsRect
ExpandRectToNearlyVisible
(
const
nsRect
&
aRect
)
const
;
void
AdjustScrollbarRectForResizer
(
nsIFrame
*
aFrame
nsPresContext
*
aPresContext
nsRect
&
aRect
bool
aHasResizer
mozilla
:
:
layers
:
:
ScrollDirection
aDirection
)
;
bool
HasResizer
(
)
{
return
mResizerBox
&
&
!
mCollapsedResizer
;
}
void
LayoutScrollbars
(
nsBoxLayoutState
&
aState
const
nsRect
&
aContentArea
const
nsRect
&
aOldScrollArea
)
;
void
MarkScrollbarsDirtyForReflow
(
)
const
;
bool
ShouldClampScrollPosition
(
)
const
;
bool
IsAlwaysActive
(
)
const
;
void
MarkEverScrolled
(
)
;
void
MarkRecentlyScrolled
(
)
;
void
MarkNotRecentlyScrolled
(
)
;
nsExpirationState
*
GetExpirationState
(
)
{
return
&
mActivityExpirationState
;
}
void
SetTransformingByAPZ
(
bool
aTransforming
)
{
if
(
mTransformingByAPZ
&
&
!
aTransforming
)
{
PostScrollEndEvent
(
)
;
}
mTransformingByAPZ
=
aTransforming
;
if
(
!
mozilla
:
:
css
:
:
TextOverflow
:
:
HasClippedOverflow
(
mOuter
)
)
{
mOuter
-
>
SchedulePaint
(
)
;
}
}
bool
IsTransformingByAPZ
(
)
const
{
return
mTransformingByAPZ
;
}
void
SetScrollableByAPZ
(
bool
aScrollable
)
;
void
SetZoomableByAPZ
(
bool
aZoomable
)
;
void
SetHasOutOfFlowContentInsideFilter
(
)
;
bool
UsesContainerScrolling
(
)
const
;
ScrollSnapInfo
GetScrollSnapInfo
(
)
const
;
bool
DecideScrollableLayer
(
nsDisplayListBuilder
*
aBuilder
nsRect
*
aVisibleRect
nsRect
*
aDirtyRect
bool
aSetBase
bool
*
aDirtyRectHasBeenOverriden
=
nullptr
)
;
void
NotifyApzTransaction
(
)
{
mAllowScrollOriginDowngrade
=
true
;
mApzScrollPos
=
GetScrollPosition
(
)
;
}
void
NotifyApproximateFrameVisibilityUpdate
(
bool
aIgnoreDisplayPort
)
;
bool
GetDisplayPortAtLastApproximateFrameVisibilityUpdate
(
nsRect
*
aDisplayPort
)
;
bool
AllowDisplayPortExpiration
(
)
;
void
TriggerDisplayPortExpiration
(
)
;
void
ResetDisplayPortExpiryTimer
(
)
;
void
ScheduleSyntheticMouseMove
(
)
;
static
void
ScrollActivityCallback
(
nsITimer
*
aTimer
void
*
anInstance
)
;
void
HandleScrollbarStyleSwitching
(
)
;
nsAtom
*
LastScrollOrigin
(
)
const
{
return
mLastScrollOrigin
;
}
nsAtom
*
LastSmoothScrollOrigin
(
)
const
{
return
mLastSmoothScrollOrigin
;
}
uint32_t
CurrentScrollGeneration
(
)
const
{
return
mScrollGeneration
;
}
nsPoint
LastScrollDestination
(
)
const
{
return
mDestination
;
}
void
ResetScrollInfoIfGeneration
(
uint32_t
aGeneration
)
{
if
(
aGeneration
=
=
mScrollGeneration
)
{
mLastScrollOrigin
=
nullptr
;
mLastSmoothScrollOrigin
=
nullptr
;
}
}
bool
WantAsyncScroll
(
)
const
;
Maybe
<
mozilla
:
:
layers
:
:
ScrollMetadata
>
ComputeScrollMetadata
(
LayerManager
*
aLayerManager
const
nsIFrame
*
aContainerReferenceFrame
const
Maybe
<
ContainerLayerParameters
>
&
aParameters
const
mozilla
:
:
DisplayItemClip
*
aClip
)
const
;
void
ClipLayerToDisplayPort
(
Layer
*
aLayer
const
mozilla
:
:
DisplayItemClip
*
aClip
const
ContainerLayerParameters
&
aParameters
)
const
;
void
ScrollByPage
(
nsScrollbarFrame
*
aScrollbar
int32_t
aDirection
nsIScrollbarMediator
:
:
ScrollSnapMode
aSnap
=
nsIScrollbarMediator
:
:
DISABLE_SNAP
)
;
void
ScrollByWhole
(
nsScrollbarFrame
*
aScrollbar
int32_t
aDirection
nsIScrollbarMediator
:
:
ScrollSnapMode
aSnap
=
nsIScrollbarMediator
:
:
DISABLE_SNAP
)
;
void
ScrollByLine
(
nsScrollbarFrame
*
aScrollbar
int32_t
aDirection
nsIScrollbarMediator
:
:
ScrollSnapMode
aSnap
=
nsIScrollbarMediator
:
:
DISABLE_SNAP
)
;
void
RepeatButtonScroll
(
nsScrollbarFrame
*
aScrollbar
)
;
void
ThumbMoved
(
nsScrollbarFrame
*
aScrollbar
nscoord
aOldPos
nscoord
aNewPos
)
;
void
ScrollbarReleased
(
nsScrollbarFrame
*
aScrollbar
)
;
void
ScrollByUnit
(
nsScrollbarFrame
*
aScrollbar
nsIScrollableFrame
:
:
ScrollMode
aMode
int32_t
aDirection
nsIScrollableFrame
:
:
ScrollUnit
aUnit
nsIScrollbarMediator
:
:
ScrollSnapMode
aSnap
=
nsIScrollbarMediator
:
:
DISABLE_SNAP
)
;
bool
ShouldSuppressScrollbarRepaints
(
)
const
{
return
mSuppressScrollbarRepaints
;
}
bool
DragScroll
(
WidgetEvent
*
aEvent
)
;
void
AsyncScrollbarDragInitiated
(
uint64_t
aDragBlockId
mozilla
:
:
layers
:
:
ScrollDirection
aDirection
)
;
void
AsyncScrollbarDragRejected
(
)
;
bool
IsRootScrollFrameOfDocument
(
)
const
{
return
mIsRoot
;
}
void
UpdateMinimumScaleSize
(
const
nsRect
&
aScrollableOverflow
const
nsSize
&
aICBSize
)
;
nsCOMPtr
<
mozilla
:
:
dom
:
:
Element
>
mHScrollbarContent
;
nsCOMPtr
<
mozilla
:
:
dom
:
:
Element
>
mVScrollbarContent
;
nsCOMPtr
<
mozilla
:
:
dom
:
:
Element
>
mScrollCornerContent
;
nsCOMPtr
<
mozilla
:
:
dom
:
:
Element
>
mResizerContent
;
RefPtr
<
ScrollEvent
>
mScrollEvent
;
RefPtr
<
ScrollEndEvent
>
mScrollEndEvent
;
nsRevocableEventPtr
<
AsyncScrollPortEvent
>
mAsyncScrollPortEvent
;
nsRevocableEventPtr
<
ScrolledAreaEvent
>
mScrolledAreaEvent
;
nsIFrame
*
mHScrollbarBox
;
nsIFrame
*
mVScrollbarBox
;
nsIFrame
*
mScrolledFrame
;
nsIFrame
*
mScrollCornerBox
;
nsIFrame
*
mResizerBox
;
nsContainerFrame
*
mOuter
;
const
nsIFrame
*
mReferenceFrameDuringPainting
;
RefPtr
<
AsyncScroll
>
mAsyncScroll
;
RefPtr
<
AsyncSmoothMSDScroll
>
mAsyncSmoothMSDScroll
;
RefPtr
<
ScrollbarActivity
>
mScrollbarActivity
;
nsTArray
<
nsIScrollPositionListener
*
>
mListeners
;
nsAtom
*
mLastScrollOrigin
;
nsAtom
*
mLastSmoothScrollOrigin
;
Maybe
<
nsPoint
>
mApzSmoothScrollDestination
;
uint32_t
mScrollGeneration
;
nsRect
mScrollPort
;
nsSize
mMinimumScaleSize
;
nsPoint
mDestination
;
nsPoint
mRestorePos
;
nsPoint
mLastPos
;
nsPoint
mApzScrollPos
;
nsExpirationState
mActivityExpirationState
;
nsCOMPtr
<
nsITimer
>
mScrollActivityTimer
;
nsPoint
mScrollPosForLayerPixelAlignment
;
nsPoint
mLastUpdateFramesPos
;
nsRect
mDisplayPortAtLastFrameUpdate
;
nsRect
mPrevScrolledRect
;
ScrollableLayerGuid
:
:
ViewID
mScrollParentID
;
nsCOMPtr
<
nsITimer
>
mDisplayPortExpiryTimer
;
ScrollAnchorContainer
mAnchor
;
bool
mAllowScrollOriginDowngrade
:
1
;
bool
mHadDisplayPortAtLastFrameUpdate
:
1
;
bool
mNeverHasVerticalScrollbar
:
1
;
bool
mNeverHasHorizontalScrollbar
:
1
;
bool
mHasVerticalScrollbar
:
1
;
bool
mHasHorizontalScrollbar
:
1
;
bool
mFrameIsUpdatingScrollbar
:
1
;
bool
mDidHistoryRestore
:
1
;
bool
mIsRoot
:
1
;
bool
mClipAllDescendants
:
1
;
bool
mSuppressScrollbarUpdate
:
1
;
bool
mSkippedScrollbarLayout
:
1
;
bool
mHadNonInitialReflow
:
1
;
bool
mHorizontalOverflow
:
1
;
bool
mVerticalOverflow
:
1
;
bool
mPostedReflowCallback
:
1
;
bool
mMayHaveDirtyFixedChildren
:
1
;
bool
mUpdateScrollbarAttributes
:
1
;
bool
mHasBeenScrolledRecently
:
1
;
bool
mCollapsedResizer
:
1
;
bool
mWillBuildScrollableLayer
:
1
;
bool
mIsScrollParent
:
1
;
bool
mIsScrollableLayerInRootContainer
:
1
;
bool
mAddClipRectToLayer
:
1
;
bool
mHasBeenScrolled
:
1
;
bool
mIgnoreMomentumScroll
:
1
;
bool
mTransformingByAPZ
:
1
;
bool
mScrollableByAPZ
:
1
;
bool
mZoomableByAPZ
:
1
;
bool
mHasOutOfFlowContentInsideFilter
:
1
;
bool
mSuppressScrollbarRepaints
:
1
;
bool
mIsUsingMinimumScaleSize
:
1
;
mozilla
:
:
layout
:
:
ScrollVelocityQueue
mVelocityQueue
;
protected
:
class
AutoScrollbarRepaintSuppression
;
friend
class
AutoScrollbarRepaintSuppression
;
class
AutoScrollbarRepaintSuppression
{
public
:
AutoScrollbarRepaintSuppression
(
ScrollFrameHelper
*
aHelper
bool
aSuppress
)
:
mHelper
(
aHelper
)
mOldSuppressValue
(
aHelper
-
>
mSuppressScrollbarRepaints
)
{
mHelper
-
>
mSuppressScrollbarRepaints
=
aSuppress
;
}
~
AutoScrollbarRepaintSuppression
(
)
{
mHelper
-
>
mSuppressScrollbarRepaints
=
mOldSuppressValue
;
}
private
:
ScrollFrameHelper
*
mHelper
;
bool
mOldSuppressValue
;
}
;
void
ScrollToWithOrigin
(
nsPoint
aScrollPosition
nsIScrollableFrame
:
:
ScrollMode
aMode
nsAtom
*
aOrigin
const
nsRect
*
aRange
nsIScrollbarMediator
:
:
ScrollSnapMode
aSnap
=
nsIScrollbarMediator
:
:
DISABLE_SNAP
)
;
void
CompleteAsyncScroll
(
const
nsRect
&
aRange
nsAtom
*
aOrigin
=
nullptr
)
;
bool
HasPluginFrames
(
)
;
bool
HasPerspective
(
)
const
{
return
mOuter
-
>
ChildrenHavePerspective
(
)
;
}
bool
HasBgAttachmentLocal
(
)
const
;
uint8_t
GetScrolledFrameDir
(
)
const
;
bool
IsForTextControlWithNoScrollbars
(
)
const
;
void
RemoveObservers
(
)
;
static
void
EnsureFrameVisPrefsCached
(
)
;
static
bool
sFrameVisPrefsCached
;
static
uint32_t
sHorzExpandScrollPort
;
static
uint32_t
sVertExpandScrollPort
;
static
int32_t
sHorzScrollFraction
;
static
int32_t
sVertScrollFraction
;
}
;
}
class
nsHTMLScrollFrame
:
public
nsContainerFrame
public
nsIScrollableFrame
public
nsIAnonymousContentCreator
public
nsIStatefulFrame
{
public
:
typedef
mozilla
:
:
ScrollFrameHelper
ScrollFrameHelper
;
typedef
mozilla
:
:
CSSIntPoint
CSSIntPoint
;
typedef
mozilla
:
:
ScrollReflowInput
ScrollReflowInput
;
typedef
mozilla
:
:
layout
:
:
ScrollAnchorContainer
ScrollAnchorContainer
;
friend
nsHTMLScrollFrame
*
NS_NewHTMLScrollFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
bool
aIsRoot
)
;
NS_DECL_QUERYFRAME
NS_DECL_FRAMEARENA_HELPERS
(
nsHTMLScrollFrame
)
virtual
void
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
override
{
mHelper
.
BuildDisplayList
(
aBuilder
aLists
)
;
}
bool
TryLayout
(
ScrollReflowInput
*
aState
ReflowOutput
*
aKidMetrics
bool
aAssumeVScroll
bool
aAssumeHScroll
bool
aForce
)
;
bool
ScrolledContentDependsOnHeight
(
ScrollReflowInput
*
aState
)
;
void
ReflowScrolledFrame
(
ScrollReflowInput
*
aState
bool
aAssumeHScroll
bool
aAssumeVScroll
ReflowOutput
*
aMetrics
)
;
void
ReflowContents
(
ScrollReflowInput
*
aState
const
ReflowOutput
&
aDesiredSize
)
;
void
PlaceScrollArea
(
ScrollReflowInput
&
aState
const
nsPoint
&
aScrollPosition
)
;
nscoord
GetIntrinsicVScrollbarWidth
(
gfxContext
*
aRenderingContext
)
;
virtual
bool
GetBorderRadii
(
const
nsSize
&
aFrameSize
const
nsSize
&
aBorderArea
Sides
aSkipSides
nscoord
aRadii
[
8
]
)
const
override
{
return
mHelper
.
GetBorderRadii
(
aFrameSize
aBorderArea
aSkipSides
aRadii
)
;
}
virtual
nscoord
GetMinISize
(
gfxContext
*
aRenderingContext
)
override
;
virtual
nscoord
GetPrefISize
(
gfxContext
*
aRenderingContext
)
override
;
virtual
nsresult
GetXULPadding
(
nsMargin
&
aPadding
)
override
;
virtual
bool
IsXULCollapsed
(
)
override
;
virtual
void
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
override
;
virtual
void
DidReflow
(
nsPresContext
*
aPresContext
const
ReflowInput
*
aReflowInput
)
override
;
virtual
bool
ComputeCustomOverflow
(
nsOverflowAreas
&
aOverflowAreas
)
override
{
return
mHelper
.
ComputeCustomOverflow
(
aOverflowAreas
)
;
}
nscoord
GetLogicalBaseline
(
mozilla
:
:
WritingMode
aWritingMode
)
const
override
;
bool
GetVerticalAlignBaseline
(
mozilla
:
:
WritingMode
aWM
nscoord
*
aBaseline
)
const
override
{
NS_ASSERTION
(
!
aWM
.
IsOrthogonalTo
(
GetWritingMode
(
)
)
"
You
should
only
call
this
on
frames
with
a
WM
that
'
s
"
"
parallel
to
aWM
"
)
;
*
aBaseline
=
GetLogicalBaseline
(
aWM
)
;
return
true
;
}
void
AdjustForPerspective
(
nsRect
&
aScrollableOverflow
)
;
virtual
void
SetInitialChildList
(
ChildListID
aListID
nsFrameList
&
aChildList
)
override
;
virtual
void
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
override
;
virtual
void
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
aFrameList
)
override
;
virtual
void
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
override
;
virtual
void
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
override
;
virtual
nsIScrollableFrame
*
GetScrollTargetFrame
(
)
override
{
return
this
;
}
virtual
nsContainerFrame
*
GetContentInsertionFrame
(
)
override
{
return
mHelper
.
GetScrolledFrame
(
)
-
>
GetContentInsertionFrame
(
)
;
}
virtual
bool
DoesClipChildren
(
)
override
{
return
true
;
}
nsPoint
GetPositionOfChildIgnoringScrolling
(
const
nsIFrame
*
aChild
)
override
{
nsPoint
pt
=
aChild
-
>
GetPosition
(
)
;
if
(
aChild
=
=
mHelper
.
GetScrolledFrame
(
)
)
pt
+
=
GetScrollPosition
(
)
;
return
pt
;
}
virtual
nsresult
CreateAnonymousContent
(
nsTArray
<
ContentInfo
>
&
aElements
)
override
;
virtual
void
AppendAnonymousContentTo
(
nsTArray
<
nsIContent
*
>
&
aElements
uint32_t
aFilter
)
override
;
virtual
nsIFrame
*
GetScrolledFrame
(
)
const
override
{
return
mHelper
.
GetScrolledFrame
(
)
;
}
virtual
mozilla
:
:
ScrollStyles
GetScrollStyles
(
)
const
override
{
return
mHelper
.
GetScrollStylesFromFrame
(
)
;
}
virtual
uint32_t
GetScrollbarVisibility
(
)
const
override
{
return
mHelper
.
GetScrollbarVisibility
(
)
;
}
virtual
nsMargin
GetActualScrollbarSizes
(
)
const
override
{
return
mHelper
.
GetActualScrollbarSizes
(
)
;
}
virtual
nsMargin
GetDesiredScrollbarSizes
(
nsBoxLayoutState
*
aState
)
override
{
return
mHelper
.
GetDesiredScrollbarSizes
(
aState
)
;
}
virtual
nsMargin
GetDesiredScrollbarSizes
(
nsPresContext
*
aPresContext
gfxContext
*
aRC
)
override
{
nsBoxLayoutState
bls
(
aPresContext
aRC
0
)
;
return
GetDesiredScrollbarSizes
(
&
bls
)
;
}
virtual
nscoord
GetNondisappearingScrollbarWidth
(
nsPresContext
*
aPresContext
gfxContext
*
aRC
mozilla
:
:
WritingMode
aWM
)
override
{
nsBoxLayoutState
bls
(
aPresContext
aRC
0
)
;
return
mHelper
.
GetNondisappearingScrollbarWidth
(
&
bls
aWM
)
;
}
virtual
nsRect
GetScrolledRect
(
)
const
override
{
return
mHelper
.
GetScrolledRect
(
)
;
}
virtual
nsRect
GetScrollPortRect
(
)
const
override
{
return
mHelper
.
GetScrollPortRect
(
)
;
}
virtual
nsPoint
GetScrollPosition
(
)
const
override
{
return
mHelper
.
GetScrollPosition
(
)
;
}
virtual
nsPoint
GetLogicalScrollPosition
(
)
const
override
{
return
mHelper
.
GetLogicalScrollPosition
(
)
;
}
virtual
nsPoint
GetApzScrollPosition
(
)
const
override
{
return
mHelper
.
GetApzScrollPosition
(
)
;
}
virtual
nsRect
GetScrollRange
(
)
const
override
{
return
mHelper
.
GetScrollRange
(
)
;
}
virtual
nsSize
GetVisualViewportSize
(
)
const
override
{
return
mHelper
.
GetVisualViewportSize
(
)
;
}
virtual
nsPoint
GetVisualViewportOffset
(
)
const
override
{
return
mHelper
.
GetVisualViewportOffset
(
)
;
}
virtual
nsSize
GetLineScrollAmount
(
)
const
override
{
return
mHelper
.
GetLineScrollAmount
(
)
;
}
virtual
nsSize
GetPageScrollAmount
(
)
const
override
{
return
mHelper
.
GetPageScrollAmount
(
)
;
}
virtual
void
ScrollTo
(
nsPoint
aScrollPosition
ScrollMode
aMode
const
nsRect
*
aRange
=
nullptr
nsIScrollbarMediator
:
:
ScrollSnapMode
aSnap
=
nsIScrollbarMediator
:
:
DISABLE_SNAP
)
override
{
mHelper
.
ScrollTo
(
aScrollPosition
aMode
nsGkAtoms
:
:
other
aRange
aSnap
)
;
}
virtual
void
ScrollToCSSPixels
(
const
CSSIntPoint
&
aScrollPosition
nsIScrollableFrame
:
:
ScrollMode
aMode
=
nsIScrollableFrame
:
:
INSTANT
nsAtom
*
aOrigin
=
nullptr
)
override
{
mHelper
.
ScrollToCSSPixels
(
aScrollPosition
aMode
aOrigin
)
;
}
virtual
void
ScrollToCSSPixelsApproximate
(
const
mozilla
:
:
CSSPoint
&
aScrollPosition
nsAtom
*
aOrigin
=
nullptr
)
override
{
mHelper
.
ScrollToCSSPixelsApproximate
(
aScrollPosition
aOrigin
)
;
}
virtual
CSSIntPoint
GetScrollPositionCSSPixels
(
)
override
{
return
mHelper
.
GetScrollPositionCSSPixels
(
)
;
}
virtual
void
ScrollBy
(
nsIntPoint
aDelta
ScrollUnit
aUnit
ScrollMode
aMode
nsIntPoint
*
aOverflow
nsAtom
*
aOrigin
=
nullptr
nsIScrollableFrame
:
:
ScrollMomentum
aMomentum
=
nsIScrollableFrame
:
:
NOT_MOMENTUM
nsIScrollbarMediator
:
:
ScrollSnapMode
aSnap
=
nsIScrollbarMediator
:
:
DISABLE_SNAP
)
override
{
mHelper
.
ScrollBy
(
aDelta
aUnit
aMode
aOverflow
aOrigin
aMomentum
aSnap
)
;
}
virtual
void
ScrollByCSSPixels
(
const
CSSIntPoint
&
aDelta
nsIScrollableFrame
:
:
ScrollMode
aMode
=
nsIScrollableFrame
:
:
INSTANT
nsAtom
*
aOrigin
=
nullptr
)
override
{
mHelper
.
ScrollByCSSPixels
(
aDelta
aMode
aOrigin
)
;
}
virtual
void
ScrollSnap
(
)
override
{
mHelper
.
ScrollSnap
(
)
;
}
virtual
void
ScrollToRestoredPosition
(
)
override
{
mHelper
.
ScrollToRestoredPosition
(
)
;
}
virtual
void
AddScrollPositionListener
(
nsIScrollPositionListener
*
aListener
)
override
{
mHelper
.
AddScrollPositionListener
(
aListener
)
;
}
virtual
void
RemoveScrollPositionListener
(
nsIScrollPositionListener
*
aListener
)
override
{
mHelper
.
RemoveScrollPositionListener
(
aListener
)
;
}
virtual
void
CurPosAttributeChanged
(
nsIContent
*
aChild
)
override
{
mHelper
.
CurPosAttributeChanged
(
aChild
)
;
}
NS_IMETHOD
PostScrolledAreaEventForCurrentArea
(
)
override
{
mHelper
.
PostScrolledAreaEvent
(
)
;
return
NS_OK
;
}
virtual
bool
IsScrollingActive
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
mHelper
.
IsScrollingActive
(
aBuilder
)
;
}
virtual
bool
IsMaybeScrollingActive
(
)
const
override
{
return
mHelper
.
IsMaybeScrollingActive
(
)
;
}
virtual
bool
IsMaybeAsynchronouslyScrolled
(
)
override
{
return
mHelper
.
IsMaybeAsynchronouslyScrolled
(
)
;
}
virtual
bool
IsProcessingAsyncScroll
(
)
override
{
return
mHelper
.
IsProcessingAsyncScroll
(
)
;
}
virtual
void
ResetScrollPositionForLayerPixelAlignment
(
)
override
{
mHelper
.
ResetScrollPositionForLayerPixelAlignment
(
)
;
}
virtual
bool
DidHistoryRestore
(
)
const
override
{
return
mHelper
.
mDidHistoryRestore
;
}
virtual
void
ClearDidHistoryRestore
(
)
override
{
mHelper
.
mDidHistoryRestore
=
false
;
}
virtual
void
MarkEverScrolled
(
)
override
{
mHelper
.
MarkEverScrolled
(
)
;
}
virtual
bool
IsRectNearlyVisible
(
const
nsRect
&
aRect
)
override
{
return
mHelper
.
IsRectNearlyVisible
(
aRect
)
;
}
virtual
nsRect
ExpandRectToNearlyVisible
(
const
nsRect
&
aRect
)
const
override
{
return
mHelper
.
ExpandRectToNearlyVisible
(
aRect
)
;
}
virtual
nsAtom
*
LastScrollOrigin
(
)
override
{
return
mHelper
.
LastScrollOrigin
(
)
;
}
virtual
nsAtom
*
LastSmoothScrollOrigin
(
)
override
{
return
mHelper
.
LastSmoothScrollOrigin
(
)
;
}
virtual
uint32_t
CurrentScrollGeneration
(
)
override
{
return
mHelper
.
CurrentScrollGeneration
(
)
;
}
virtual
nsPoint
LastScrollDestination
(
)
override
{
return
mHelper
.
LastScrollDestination
(
)
;
}
virtual
void
ResetScrollInfoIfGeneration
(
uint32_t
aGeneration
)
override
{
mHelper
.
ResetScrollInfoIfGeneration
(
aGeneration
)
;
}
virtual
bool
WantAsyncScroll
(
)
const
override
{
return
mHelper
.
WantAsyncScroll
(
)
;
}
virtual
mozilla
:
:
Maybe
<
mozilla
:
:
layers
:
:
ScrollMetadata
>
ComputeScrollMetadata
(
LayerManager
*
aLayerManager
const
nsIFrame
*
aContainerReferenceFrame
const
Maybe
<
ContainerLayerParameters
>
&
aParameters
const
mozilla
:
:
DisplayItemClip
*
aClip
)
const
override
{
return
mHelper
.
ComputeScrollMetadata
(
aLayerManager
aContainerReferenceFrame
aParameters
aClip
)
;
}
virtual
void
ClipLayerToDisplayPort
(
Layer
*
aLayer
const
mozilla
:
:
DisplayItemClip
*
aClip
const
ContainerLayerParameters
&
aParameters
)
const
override
{
mHelper
.
ClipLayerToDisplayPort
(
aLayer
aClip
aParameters
)
;
}
virtual
void
MarkScrollbarsDirtyForReflow
(
)
const
override
{
mHelper
.
MarkScrollbarsDirtyForReflow
(
)
;
}
virtual
bool
UsesContainerScrolling
(
)
const
override
{
return
mHelper
.
UsesContainerScrolling
(
)
;
}
virtual
bool
DecideScrollableLayer
(
nsDisplayListBuilder
*
aBuilder
nsRect
*
aVisibleRect
nsRect
*
aDirtyRect
bool
aSetBase
)
override
{
return
mHelper
.
DecideScrollableLayer
(
aBuilder
aVisibleRect
aDirtyRect
aSetBase
)
;
}
virtual
void
NotifyApzTransaction
(
)
override
{
mHelper
.
NotifyApzTransaction
(
)
;
}
virtual
void
NotifyApproximateFrameVisibilityUpdate
(
bool
aIgnoreDisplayPort
)
override
{
mHelper
.
NotifyApproximateFrameVisibilityUpdate
(
aIgnoreDisplayPort
)
;
}
virtual
bool
GetDisplayPortAtLastApproximateFrameVisibilityUpdate
(
nsRect
*
aDisplayPort
)
override
{
return
mHelper
.
GetDisplayPortAtLastApproximateFrameVisibilityUpdate
(
aDisplayPort
)
;
}
void
TriggerDisplayPortExpiration
(
)
override
{
mHelper
.
TriggerDisplayPortExpiration
(
)
;
}
mozilla
:
:
UniquePtr
<
mozilla
:
:
PresState
>
SaveState
(
)
override
{
return
mHelper
.
SaveState
(
)
;
}
NS_IMETHOD
RestoreState
(
mozilla
:
:
PresState
*
aState
)
override
{
NS_ENSURE_ARG_POINTER
(
aState
)
;
mHelper
.
RestoreState
(
aState
)
;
return
NS_OK
;
}
virtual
void
ScrollByPage
(
nsScrollbarFrame
*
aScrollbar
int32_t
aDirection
nsIScrollbarMediator
:
:
ScrollSnapMode
aSnap
=
nsIScrollbarMediator
:
:
DISABLE_SNAP
)
override
{
mHelper
.
ScrollByPage
(
aScrollbar
aDirection
aSnap
)
;
}
virtual
void
ScrollByWhole
(
nsScrollbarFrame
*
aScrollbar
int32_t
aDirection
nsIScrollbarMediator
:
:
ScrollSnapMode
aSnap
=
nsIScrollbarMediator
:
:
DISABLE_SNAP
)
override
{
mHelper
.
ScrollByWhole
(
aScrollbar
aDirection
aSnap
)
;
}
virtual
void
ScrollByLine
(
nsScrollbarFrame
*
aScrollbar
int32_t
aDirection
nsIScrollbarMediator
:
:
ScrollSnapMode
aSnap
=
nsIScrollbarMediator
:
:
DISABLE_SNAP
)
override
{
mHelper
.
ScrollByLine
(
aScrollbar
aDirection
aSnap
)
;
}
virtual
void
RepeatButtonScroll
(
nsScrollbarFrame
*
aScrollbar
)
override
{
mHelper
.
RepeatButtonScroll
(
aScrollbar
)
;
}
virtual
void
ThumbMoved
(
nsScrollbarFrame
*
aScrollbar
nscoord
aOldPos
nscoord
aNewPos
)
override
{
mHelper
.
ThumbMoved
(
aScrollbar
aOldPos
aNewPos
)
;
}
virtual
void
ScrollbarReleased
(
nsScrollbarFrame
*
aScrollbar
)
override
{
mHelper
.
ScrollbarReleased
(
aScrollbar
)
;
}
virtual
void
VisibilityChanged
(
bool
aVisible
)
override
{
}
virtual
nsIFrame
*
GetScrollbarBox
(
bool
aVertical
)
override
{
return
mHelper
.
GetScrollbarBox
(
aVertical
)
;
}
virtual
void
ScrollbarActivityStarted
(
)
const
override
;
virtual
void
ScrollbarActivityStopped
(
)
const
override
;
virtual
bool
IsScrollbarOnRight
(
)
const
override
{
return
mHelper
.
IsScrollbarOnRight
(
)
;
}
virtual
bool
ShouldSuppressScrollbarRepaints
(
)
const
override
{
return
mHelper
.
ShouldSuppressScrollbarRepaints
(
)
;
}
virtual
void
SetTransformingByAPZ
(
bool
aTransforming
)
override
{
mHelper
.
SetTransformingByAPZ
(
aTransforming
)
;
}
bool
IsTransformingByAPZ
(
)
const
override
{
return
mHelper
.
IsTransformingByAPZ
(
)
;
}
void
SetScrollableByAPZ
(
bool
aScrollable
)
override
{
mHelper
.
SetScrollableByAPZ
(
aScrollable
)
;
}
void
SetZoomableByAPZ
(
bool
aZoomable
)
override
{
mHelper
.
SetZoomableByAPZ
(
aZoomable
)
;
}
void
SetHasOutOfFlowContentInsideFilter
(
)
override
{
mHelper
.
SetHasOutOfFlowContentInsideFilter
(
)
;
}
ScrollSnapInfo
GetScrollSnapInfo
(
)
const
override
{
return
mHelper
.
GetScrollSnapInfo
(
)
;
}
virtual
bool
DragScroll
(
mozilla
:
:
WidgetEvent
*
aEvent
)
override
{
return
mHelper
.
DragScroll
(
aEvent
)
;
}
virtual
void
AsyncScrollbarDragInitiated
(
uint64_t
aDragBlockId
mozilla
:
:
layers
:
:
ScrollDirection
aDirection
)
override
{
return
mHelper
.
AsyncScrollbarDragInitiated
(
aDragBlockId
aDirection
)
;
}
virtual
void
AsyncScrollbarDragRejected
(
)
override
{
return
mHelper
.
AsyncScrollbarDragRejected
(
)
;
}
virtual
bool
IsRootScrollFrameOfDocument
(
)
const
override
{
return
mHelper
.
IsRootScrollFrameOfDocument
(
)
;
}
virtual
const
ScrollAnchorContainer
*
GetAnchor
(
)
const
override
{
return
&
mHelper
.
mAnchor
;
}
virtual
ScrollAnchorContainer
*
GetAnchor
(
)
override
{
return
&
mHelper
.
mAnchor
;
}
void
AppendDirectlyOwnedAnonBoxes
(
nsTArray
<
OwnedAnonBox
>
&
aResult
)
override
{
aResult
.
AppendElement
(
OwnedAnonBox
(
mHelper
.
GetScrolledFrame
(
)
)
)
;
}
#
ifdef
DEBUG_FRAME_DUMP
virtual
nsresult
GetFrameName
(
nsAString
&
aResult
)
const
override
;
#
endif
#
ifdef
ACCESSIBILITY
virtual
mozilla
:
:
a11y
:
:
AccType
AccessibleType
(
)
override
;
#
endif
protected
:
nsHTMLScrollFrame
(
ComputedStyle
*
aStyle
bool
aIsRoot
)
:
nsHTMLScrollFrame
(
aStyle
kClassID
aIsRoot
)
{
}
nsHTMLScrollFrame
(
ComputedStyle
*
aStyle
nsIFrame
:
:
ClassID
aID
bool
aIsRoot
)
;
void
SetSuppressScrollbarUpdate
(
bool
aSuppress
)
{
mHelper
.
mSuppressScrollbarUpdate
=
aSuppress
;
}
bool
GuessHScrollbarNeeded
(
const
ScrollReflowInput
&
aState
)
;
bool
GuessVScrollbarNeeded
(
const
ScrollReflowInput
&
aState
)
;
bool
IsScrollbarUpdateSuppressed
(
)
const
{
return
mHelper
.
mSuppressScrollbarUpdate
;
}
bool
InInitialReflow
(
)
const
;
virtual
bool
ShouldPropagateComputedBSizeToScrolledContent
(
)
const
{
return
true
;
}
private
:
friend
class
mozilla
:
:
ScrollFrameHelper
;
ScrollFrameHelper
mHelper
;
}
;
class
nsXULScrollFrame
final
:
public
nsBoxFrame
public
nsIScrollableFrame
public
nsIAnonymousContentCreator
public
nsIStatefulFrame
{
public
:
typedef
mozilla
:
:
ScrollFrameHelper
ScrollFrameHelper
;
typedef
mozilla
:
:
CSSIntPoint
CSSIntPoint
;
typedef
mozilla
:
:
layout
:
:
ScrollAnchorContainer
ScrollAnchorContainer
;
NS_DECL_QUERYFRAME
NS_DECL_FRAMEARENA_HELPERS
(
nsXULScrollFrame
)
friend
nsXULScrollFrame
*
NS_NewXULScrollFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
bool
aIsRoot
bool
aClipAllDescendants
)
;
virtual
void
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
override
{
mHelper
.
BuildDisplayList
(
aBuilder
aLists
)
;
}
#
if
0
virtual
nscoord
GetMinISize
(
gfxContext
*
aRenderingContext
)
override
;
#
endif
virtual
bool
ComputeCustomOverflow
(
nsOverflowAreas
&
aOverflowAreas
)
override
{
return
mHelper
.
ComputeCustomOverflow
(
aOverflowAreas
)
;
}
bool
GetVerticalAlignBaseline
(
mozilla
:
:
WritingMode
aWM
nscoord
*
aBaseline
)
const
override
{
*
aBaseline
=
GetLogicalBaseline
(
aWM
)
;
return
true
;
}
virtual
void
SetInitialChildList
(
ChildListID
aListID
nsFrameList
&
aChildList
)
override
;
virtual
void
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
override
;
virtual
void
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
aFrameList
)
override
;
virtual
void
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
override
;
virtual
void
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
override
;
virtual
nsIScrollableFrame
*
GetScrollTargetFrame
(
)
override
{
return
this
;
}
virtual
nsContainerFrame
*
GetContentInsertionFrame
(
)
override
{
return
mHelper
.
GetScrolledFrame
(
)
-
>
GetContentInsertionFrame
(
)
;
}
virtual
bool
DoesClipChildren
(
)
override
{
return
true
;
}
nsPoint
GetPositionOfChildIgnoringScrolling
(
const
nsIFrame
*
aChild
)
override
{
nsPoint
pt
=
aChild
-
>
GetPosition
(
)
;
if
(
aChild
=
=
mHelper
.
GetScrolledFrame
(
)
)
pt
+
=
mHelper
.
GetLogicalScrollPosition
(
)
;
return
pt
;
}
virtual
nsresult
CreateAnonymousContent
(
nsTArray
<
ContentInfo
>
&
aElements
)
override
;
virtual
void
AppendAnonymousContentTo
(
nsTArray
<
nsIContent
*
>
&
aElements
uint32_t
aFilter
)
override
;
virtual
nsSize
GetXULMinSize
(
nsBoxLayoutState
&
aBoxLayoutState
)
override
;
virtual
nsSize
GetXULPrefSize
(
nsBoxLayoutState
&
aBoxLayoutState
)
override
;
virtual
nsSize
GetXULMaxSize
(
nsBoxLayoutState
&
aBoxLayoutState
)
override
;
virtual
nscoord
GetXULBoxAscent
(
nsBoxLayoutState
&
aBoxLayoutState
)
override
;
NS_IMETHOD
DoXULLayout
(
nsBoxLayoutState
&
aBoxLayoutState
)
override
;
virtual
nsresult
GetXULPadding
(
nsMargin
&
aPadding
)
override
;
virtual
bool
GetBorderRadii
(
const
nsSize
&
aFrameSize
const
nsSize
&
aBorderArea
Sides
aSkipSides
nscoord
aRadii
[
8
]
)
const
override
{
return
mHelper
.
GetBorderRadii
(
aFrameSize
aBorderArea
aSkipSides
aRadii
)
;
}
nsresult
XULLayout
(
nsBoxLayoutState
&
aState
)
;
void
LayoutScrollArea
(
nsBoxLayoutState
&
aState
const
nsPoint
&
aScrollPosition
)
;
static
bool
AddRemoveScrollbar
(
bool
&
aHasScrollbar
nscoord
&
aXY
nscoord
&
aSize
nscoord
aSbSize
bool
aOnRightOrBottom
bool
aAdd
)
;
bool
AddRemoveScrollbar
(
nsBoxLayoutState
&
aState
bool
aOnRightOrBottom
bool
aHorizontal
bool
aAdd
)
;
bool
AddHorizontalScrollbar
(
nsBoxLayoutState
&
aState
bool
aOnBottom
)
;
bool
AddVerticalScrollbar
(
nsBoxLayoutState
&
aState
bool
aOnRight
)
;
void
RemoveHorizontalScrollbar
(
nsBoxLayoutState
&
aState
bool
aOnBottom
)
;
void
RemoveVerticalScrollbar
(
nsBoxLayoutState
&
aState
bool
aOnRight
)
;
static
void
AdjustReflowInputForPrintPreview
(
nsBoxLayoutState
&
aState
bool
&
aSetBack
)
;
static
void
AdjustReflowInputBack
(
nsBoxLayoutState
&
aState
bool
aSetBack
)
;
virtual
nsIFrame
*
GetScrolledFrame
(
)
const
override
{
return
mHelper
.
GetScrolledFrame
(
)
;
}
virtual
mozilla
:
:
ScrollStyles
GetScrollStyles
(
)
const
override
{
return
mHelper
.
GetScrollStylesFromFrame
(
)
;
}
virtual
uint32_t
GetScrollbarVisibility
(
)
const
override
{
return
mHelper
.
GetScrollbarVisibility
(
)
;
}
virtual
nsMargin
GetActualScrollbarSizes
(
)
const
override
{
return
mHelper
.
GetActualScrollbarSizes
(
)
;
}
virtual
nsMargin
GetDesiredScrollbarSizes
(
nsBoxLayoutState
*
aState
)
override
{
return
mHelper
.
GetDesiredScrollbarSizes
(
aState
)
;
}
virtual
nsMargin
GetDesiredScrollbarSizes
(
nsPresContext
*
aPresContext
gfxContext
*
aRC
)
override
{
nsBoxLayoutState
bls
(
aPresContext
aRC
0
)
;
return
GetDesiredScrollbarSizes
(
&
bls
)
;
}
virtual
nscoord
GetNondisappearingScrollbarWidth
(
nsPresContext
*
aPresContext
gfxContext
*
aRC
mozilla
:
:
WritingMode
aWM
)
override
{
nsBoxLayoutState
bls
(
aPresContext
aRC
0
)
;
return
mHelper
.
GetNondisappearingScrollbarWidth
(
&
bls
aWM
)
;
}
virtual
nsRect
GetScrolledRect
(
)
const
override
{
return
mHelper
.
GetScrolledRect
(
)
;
}
virtual
nsRect
GetScrollPortRect
(
)
const
override
{
return
mHelper
.
GetScrollPortRect
(
)
;
}
virtual
nsPoint
GetScrollPosition
(
)
const
override
{
return
mHelper
.
GetScrollPosition
(
)
;
}
virtual
nsPoint
GetLogicalScrollPosition
(
)
const
override
{
return
mHelper
.
GetLogicalScrollPosition
(
)
;
}
virtual
nsPoint
GetApzScrollPosition
(
)
const
override
{
return
mHelper
.
GetApzScrollPosition
(
)
;
}
virtual
nsRect
GetScrollRange
(
)
const
override
{
return
mHelper
.
GetScrollRange
(
)
;
}
virtual
nsSize
GetVisualViewportSize
(
)
const
override
{
return
mHelper
.
GetVisualViewportSize
(
)
;
}
virtual
nsPoint
GetVisualViewportOffset
(
)
const
override
{
return
mHelper
.
GetVisualViewportOffset
(
)
;
}
virtual
nsSize
GetLineScrollAmount
(
)
const
override
{
return
mHelper
.
GetLineScrollAmount
(
)
;
}
virtual
nsSize
GetPageScrollAmount
(
)
const
override
{
return
mHelper
.
GetPageScrollAmount
(
)
;
}
virtual
void
ScrollTo
(
nsPoint
aScrollPosition
ScrollMode
aMode
const
nsRect
*
aRange
=
nullptr
ScrollSnapMode
aSnap
=
nsIScrollbarMediator
:
:
DISABLE_SNAP
)
override
{
mHelper
.
ScrollTo
(
aScrollPosition
aMode
nsGkAtoms
:
:
other
aRange
aSnap
)
;
}
virtual
void
ScrollToCSSPixels
(
const
CSSIntPoint
&
aScrollPosition
nsIScrollableFrame
:
:
ScrollMode
aMode
=
nsIScrollableFrame
:
:
INSTANT
nsAtom
*
aOrigin
=
nullptr
)
override
{
mHelper
.
ScrollToCSSPixels
(
aScrollPosition
aMode
aOrigin
)
;
}
virtual
void
ScrollToCSSPixelsApproximate
(
const
mozilla
:
:
CSSPoint
&
aScrollPosition
nsAtom
*
aOrigin
=
nullptr
)
override
{
mHelper
.
ScrollToCSSPixelsApproximate
(
aScrollPosition
aOrigin
)
;
}
virtual
CSSIntPoint
GetScrollPositionCSSPixels
(
)
override
{
return
mHelper
.
GetScrollPositionCSSPixels
(
)
;
}
virtual
void
ScrollBy
(
nsIntPoint
aDelta
ScrollUnit
aUnit
ScrollMode
aMode
nsIntPoint
*
aOverflow
nsAtom
*
aOrigin
=
nullptr
nsIScrollableFrame
:
:
ScrollMomentum
aMomentum
=
nsIScrollableFrame
:
:
NOT_MOMENTUM
nsIScrollbarMediator
:
:
ScrollSnapMode
aSnap
=
nsIScrollbarMediator
:
:
DISABLE_SNAP
)
override
{
mHelper
.
ScrollBy
(
aDelta
aUnit
aMode
aOverflow
aOrigin
aMomentum
aSnap
)
;
}
virtual
void
ScrollByCSSPixels
(
const
CSSIntPoint
&
aDelta
nsIScrollableFrame
:
:
ScrollMode
aMode
=
nsIScrollableFrame
:
:
INSTANT
nsAtom
*
aOrigin
=
nullptr
)
override
{
mHelper
.
ScrollByCSSPixels
(
aDelta
aMode
aOrigin
)
;
}
virtual
void
ScrollSnap
(
)
override
{
mHelper
.
ScrollSnap
(
)
;
}
virtual
void
ScrollToRestoredPosition
(
)
override
{
mHelper
.
ScrollToRestoredPosition
(
)
;
}
virtual
void
AddScrollPositionListener
(
nsIScrollPositionListener
*
aListener
)
override
{
mHelper
.
AddScrollPositionListener
(
aListener
)
;
}
virtual
void
RemoveScrollPositionListener
(
nsIScrollPositionListener
*
aListener
)
override
{
mHelper
.
RemoveScrollPositionListener
(
aListener
)
;
}
virtual
void
CurPosAttributeChanged
(
nsIContent
*
aChild
)
override
{
mHelper
.
CurPosAttributeChanged
(
aChild
)
;
}
NS_IMETHOD
PostScrolledAreaEventForCurrentArea
(
)
override
{
mHelper
.
PostScrolledAreaEvent
(
)
;
return
NS_OK
;
}
virtual
bool
IsScrollingActive
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
mHelper
.
IsScrollingActive
(
aBuilder
)
;
}
virtual
bool
IsMaybeScrollingActive
(
)
const
override
{
return
mHelper
.
IsMaybeScrollingActive
(
)
;
}
virtual
bool
IsMaybeAsynchronouslyScrolled
(
)
override
{
return
mHelper
.
IsMaybeAsynchronouslyScrolled
(
)
;
}
virtual
bool
IsProcessingAsyncScroll
(
)
override
{
return
mHelper
.
IsProcessingAsyncScroll
(
)
;
}
virtual
void
ResetScrollPositionForLayerPixelAlignment
(
)
override
{
mHelper
.
ResetScrollPositionForLayerPixelAlignment
(
)
;
}
virtual
bool
DidHistoryRestore
(
)
const
override
{
return
mHelper
.
mDidHistoryRestore
;
}
virtual
void
ClearDidHistoryRestore
(
)
override
{
mHelper
.
mDidHistoryRestore
=
false
;
}
virtual
void
MarkEverScrolled
(
)
override
{
mHelper
.
MarkEverScrolled
(
)
;
}
virtual
bool
IsRectNearlyVisible
(
const
nsRect
&
aRect
)
override
{
return
mHelper
.
IsRectNearlyVisible
(
aRect
)
;
}
virtual
nsRect
ExpandRectToNearlyVisible
(
const
nsRect
&
aRect
)
const
override
{
return
mHelper
.
ExpandRectToNearlyVisible
(
aRect
)
;
}
virtual
nsAtom
*
LastScrollOrigin
(
)
override
{
return
mHelper
.
LastScrollOrigin
(
)
;
}
virtual
nsAtom
*
LastSmoothScrollOrigin
(
)
override
{
return
mHelper
.
LastSmoothScrollOrigin
(
)
;
}
virtual
uint32_t
CurrentScrollGeneration
(
)
override
{
return
mHelper
.
CurrentScrollGeneration
(
)
;
}
virtual
nsPoint
LastScrollDestination
(
)
override
{
return
mHelper
.
LastScrollDestination
(
)
;
}
virtual
void
ResetScrollInfoIfGeneration
(
uint32_t
aGeneration
)
override
{
mHelper
.
ResetScrollInfoIfGeneration
(
aGeneration
)
;
}
virtual
bool
WantAsyncScroll
(
)
const
override
{
return
mHelper
.
WantAsyncScroll
(
)
;
}
virtual
mozilla
:
:
Maybe
<
mozilla
:
:
layers
:
:
ScrollMetadata
>
ComputeScrollMetadata
(
LayerManager
*
aLayerManager
const
nsIFrame
*
aContainerReferenceFrame
const
Maybe
<
ContainerLayerParameters
>
&
aParameters
const
mozilla
:
:
DisplayItemClip
*
aClip
)
const
override
{
return
mHelper
.
ComputeScrollMetadata
(
aLayerManager
aContainerReferenceFrame
aParameters
aClip
)
;
}
virtual
void
ClipLayerToDisplayPort
(
Layer
*
aLayer
const
mozilla
:
:
DisplayItemClip
*
aClip
const
ContainerLayerParameters
&
aParameters
)
const
override
{
mHelper
.
ClipLayerToDisplayPort
(
aLayer
aClip
aParameters
)
;
}
virtual
void
MarkScrollbarsDirtyForReflow
(
)
const
override
{
mHelper
.
MarkScrollbarsDirtyForReflow
(
)
;
}
mozilla
:
:
UniquePtr
<
mozilla
:
:
PresState
>
SaveState
(
)
override
{
return
mHelper
.
SaveState
(
)
;
}
NS_IMETHOD
RestoreState
(
mozilla
:
:
PresState
*
aState
)
override
{
NS_ENSURE_ARG_POINTER
(
aState
)
;
mHelper
.
RestoreState
(
aState
)
;
return
NS_OK
;
}
virtual
bool
IsFrameOfType
(
uint32_t
aFlags
)
const
override
{
if
(
aFlags
&
(
nsIFrame
:
:
eReplacedContainsBlock
|
nsIFrame
:
:
eReplaced
)
)
return
false
;
return
nsBoxFrame
:
:
IsFrameOfType
(
aFlags
)
;
}
virtual
void
ScrollByPage
(
nsScrollbarFrame
*
aScrollbar
int32_t
aDirection
nsIScrollbarMediator
:
:
ScrollSnapMode
aSnap
=
nsIScrollbarMediator
:
:
DISABLE_SNAP
)
override
{
mHelper
.
ScrollByPage
(
aScrollbar
aDirection
aSnap
)
;
}
virtual
void
ScrollByWhole
(
nsScrollbarFrame
*
aScrollbar
int32_t
aDirection
nsIScrollbarMediator
:
:
ScrollSnapMode
aSnap
=
nsIScrollbarMediator
:
:
DISABLE_SNAP
)
override
{
mHelper
.
ScrollByWhole
(
aScrollbar
aDirection
aSnap
)
;
}
virtual
void
ScrollByLine
(
nsScrollbarFrame
*
aScrollbar
int32_t
aDirection
nsIScrollbarMediator
:
:
ScrollSnapMode
aSnap
=
nsIScrollbarMediator
:
:
DISABLE_SNAP
)
override
{
mHelper
.
ScrollByLine
(
aScrollbar
aDirection
aSnap
)
;
}
virtual
void
RepeatButtonScroll
(
nsScrollbarFrame
*
aScrollbar
)
override
{
mHelper
.
RepeatButtonScroll
(
aScrollbar
)
;
}
virtual
void
ThumbMoved
(
nsScrollbarFrame
*
aScrollbar
nscoord
aOldPos
nscoord
aNewPos
)
override
{
mHelper
.
ThumbMoved
(
aScrollbar
aOldPos
aNewPos
)
;
}
virtual
void
ScrollbarReleased
(
nsScrollbarFrame
*
aScrollbar
)
override
{
mHelper
.
ScrollbarReleased
(
aScrollbar
)
;
}
virtual
void
VisibilityChanged
(
bool
aVisible
)
override
{
}
virtual
nsIFrame
*
GetScrollbarBox
(
bool
aVertical
)
override
{
return
mHelper
.
GetScrollbarBox
(
aVertical
)
;
}
virtual
void
ScrollbarActivityStarted
(
)
const
override
;
virtual
void
ScrollbarActivityStopped
(
)
const
override
;
virtual
bool
IsScrollbarOnRight
(
)
const
override
{
return
mHelper
.
IsScrollbarOnRight
(
)
;
}
virtual
bool
ShouldSuppressScrollbarRepaints
(
)
const
override
{
return
mHelper
.
ShouldSuppressScrollbarRepaints
(
)
;
}
virtual
void
SetTransformingByAPZ
(
bool
aTransforming
)
override
{
mHelper
.
SetTransformingByAPZ
(
aTransforming
)
;
}
virtual
bool
UsesContainerScrolling
(
)
const
override
{
return
mHelper
.
UsesContainerScrolling
(
)
;
}
bool
IsTransformingByAPZ
(
)
const
override
{
return
mHelper
.
IsTransformingByAPZ
(
)
;
}
void
SetScrollableByAPZ
(
bool
aScrollable
)
override
{
mHelper
.
SetScrollableByAPZ
(
aScrollable
)
;
}
void
SetZoomableByAPZ
(
bool
aZoomable
)
override
{
mHelper
.
SetZoomableByAPZ
(
aZoomable
)
;
}
void
SetHasOutOfFlowContentInsideFilter
(
)
override
{
mHelper
.
SetHasOutOfFlowContentInsideFilter
(
)
;
}
virtual
bool
DecideScrollableLayer
(
nsDisplayListBuilder
*
aBuilder
nsRect
*
aVisibleRect
nsRect
*
aDirtyRect
bool
aSetBase
)
override
{
return
mHelper
.
DecideScrollableLayer
(
aBuilder
aVisibleRect
aDirtyRect
aSetBase
)
;
}
virtual
void
NotifyApzTransaction
(
)
override
{
mHelper
.
NotifyApzTransaction
(
)
;
}
virtual
void
NotifyApproximateFrameVisibilityUpdate
(
bool
aIgnoreDisplayPort
)
override
{
mHelper
.
NotifyApproximateFrameVisibilityUpdate
(
aIgnoreDisplayPort
)
;
}
virtual
bool
GetDisplayPortAtLastApproximateFrameVisibilityUpdate
(
nsRect
*
aDisplayPort
)
override
{
return
mHelper
.
GetDisplayPortAtLastApproximateFrameVisibilityUpdate
(
aDisplayPort
)
;
}
void
TriggerDisplayPortExpiration
(
)
override
{
mHelper
.
TriggerDisplayPortExpiration
(
)
;
}
ScrollSnapInfo
GetScrollSnapInfo
(
)
const
override
{
return
mHelper
.
GetScrollSnapInfo
(
)
;
}
virtual
bool
DragScroll
(
mozilla
:
:
WidgetEvent
*
aEvent
)
override
{
return
mHelper
.
DragScroll
(
aEvent
)
;
}
virtual
void
AsyncScrollbarDragInitiated
(
uint64_t
aDragBlockId
mozilla
:
:
layers
:
:
ScrollDirection
aDirection
)
override
{
return
mHelper
.
AsyncScrollbarDragInitiated
(
aDragBlockId
aDirection
)
;
}
virtual
void
AsyncScrollbarDragRejected
(
)
override
{
return
mHelper
.
AsyncScrollbarDragRejected
(
)
;
}
virtual
bool
IsRootScrollFrameOfDocument
(
)
const
override
{
return
mHelper
.
IsRootScrollFrameOfDocument
(
)
;
}
virtual
const
ScrollAnchorContainer
*
GetAnchor
(
)
const
override
{
return
&
mHelper
.
mAnchor
;
}
virtual
ScrollAnchorContainer
*
GetAnchor
(
)
override
{
return
&
mHelper
.
mAnchor
;
}
void
AppendDirectlyOwnedAnonBoxes
(
nsTArray
<
OwnedAnonBox
>
&
aResult
)
override
{
aResult
.
AppendElement
(
OwnedAnonBox
(
mHelper
.
GetScrolledFrame
(
)
)
)
;
}
#
ifdef
DEBUG_FRAME_DUMP
virtual
nsresult
GetFrameName
(
nsAString
&
aResult
)
const
override
;
#
endif
protected
:
nsXULScrollFrame
(
ComputedStyle
*
aStyle
bool
aIsRoot
bool
aClipAllDescendants
)
;
void
ClampAndSetBounds
(
nsBoxLayoutState
&
aState
nsRect
&
aRect
nsPoint
aScrollPosition
bool
aRemoveOverflowAreas
=
false
)
{
if
(
!
mHelper
.
IsPhysicalLTR
(
)
)
{
aRect
.
x
=
mHelper
.
mScrollPort
.
XMost
(
)
-
aScrollPosition
.
x
-
aRect
.
width
;
}
mHelper
.
mScrolledFrame
-
>
SetXULBounds
(
aState
aRect
aRemoveOverflowAreas
)
;
}
private
:
friend
class
mozilla
:
:
ScrollFrameHelper
;
ScrollFrameHelper
mHelper
;
}
;
#
endif
