#
ifndef
nsGfxScrollFrame_h___
#
define
nsGfxScrollFrame_h___
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsIAnonymousContentCreator
.
h
"
#
include
"
nsBoxFrame
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsIScrollbarMediator
.
h
"
#
include
"
nsIStatefulFrame
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsIReflowCallback
.
h
"
#
include
"
nsBoxLayoutState
.
h
"
#
include
"
nsQueryFrame
.
h
"
#
include
"
nsExpirationTracker
.
h
"
#
include
"
TextOverflow
.
h
"
#
include
"
ScrollVelocityQueue
.
h
"
#
include
"
mozilla
/
ScrollTypes
.
h
"
#
include
"
mozilla
/
PresState
.
h
"
#
include
"
mozilla
/
layout
/
ScrollAnchorContainer
.
h
"
#
include
"
mozilla
/
TypedEnumBits
.
h
"
class
nsPresContext
;
class
nsIContent
;
class
nsAtom
;
class
nsIScrollPositionListener
;
class
AutoContainsBlendModeCapturer
;
namespace
mozilla
{
class
PresShell
;
struct
ScrollReflowInput
;
namespace
layers
{
class
Layer
;
class
WebRenderLayerManager
;
}
namespace
layout
{
class
ScrollbarActivity
;
}
class
ScrollFrameHelper
:
public
nsIReflowCallback
{
public
:
using
Sides
=
nsIFrame
:
:
Sides
;
using
CSSIntPoint
=
mozilla
:
:
CSSIntPoint
;
using
ScrollbarActivity
=
mozilla
:
:
layout
:
:
ScrollbarActivity
;
using
FrameMetrics
=
mozilla
:
:
layers
:
:
FrameMetrics
;
using
ScrollableLayerGuid
=
mozilla
:
:
layers
:
:
ScrollableLayerGuid
;
using
ScrollSnapInfo
=
mozilla
:
:
layers
:
:
ScrollSnapInfo
;
using
Layer
=
mozilla
:
:
layers
:
:
Layer
;
using
WebRenderLayerManager
=
mozilla
:
:
layers
:
:
WebRenderLayerManager
;
using
ScrollAnchorContainer
=
mozilla
:
:
layout
:
:
ScrollAnchorContainer
;
using
APZScrollAnimationType
=
mozilla
:
:
APZScrollAnimationType
;
using
Element
=
mozilla
:
:
dom
:
:
Element
;
using
AnimationState
=
nsIScrollableFrame
:
:
AnimationState
;
using
SnapTargetSet
=
nsTHashSet
<
RefPtr
<
nsIContent
>
>
;
using
InScrollingGesture
=
nsIScrollableFrame
:
:
InScrollingGesture
;
class
AsyncScroll
;
class
AsyncSmoothMSDScroll
;
ScrollFrameHelper
(
nsContainerFrame
*
aOuter
bool
aIsRoot
)
;
~
ScrollFrameHelper
(
)
;
mozilla
:
:
ScrollStyles
GetScrollStylesFromFrame
(
)
const
;
mozilla
:
:
layers
:
:
OverscrollBehaviorInfo
GetOverscrollBehaviorInfo
(
)
const
;
bool
IsForTextControlWithNoScrollbars
(
)
const
;
enum
class
AnonymousContentType
{
VerticalScrollbar
HorizontalScrollbar
Resizer
}
;
EnumSet
<
AnonymousContentType
>
GetNeededAnonymousContent
(
)
const
;
EnumSet
<
AnonymousContentType
>
GetCurrentAnonymousContent
(
)
const
;
bool
HasAllNeededScrollbars
(
)
const
{
return
GetCurrentAnonymousContent
(
)
.
contains
(
GetNeededAnonymousContent
(
)
)
;
}
void
ReloadChildFrames
(
)
;
nsresult
CreateAnonymousContent
(
nsTArray
<
nsIAnonymousContentCreator
:
:
ContentInfo
>
&
aElements
)
;
void
AppendAnonymousContentTo
(
nsTArray
<
nsIContent
*
>
&
aElements
uint32_t
aFilter
)
;
enum
class
OverflowState
:
uint32_t
{
None
=
0
Vertical
=
(
1
<
<
0
)
Horizontal
=
(
1
<
<
1
)
}
;
OverflowState
GetOverflowState
(
)
const
;
MOZ_CAN_RUN_SCRIPT
nsresult
FireScrollPortEvent
(
)
;
void
PostScrollEndEvent
(
)
;
void
FireScrollEndEvent
(
)
;
void
PostOverflowEvent
(
)
;
using
PostDestroyData
=
nsIFrame
:
:
PostDestroyData
;
void
Destroy
(
PostDestroyData
&
aPostDestroyData
)
;
void
DidSetComputedStyle
(
ComputedStyle
*
aOldComputedStyle
)
;
void
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
;
void
MaybeCreateTopLayerAndWrapRootItems
(
nsDisplayListBuilder
*
nsDisplayListCollection
&
bool
aCreateAsyncZoom
AutoContainsBlendModeCapturer
*
aAsyncZoomBlendCapture
const
nsRect
&
aAsyncZoomClipRect
nscoord
*
aRadii
)
;
void
AppendScrollPartsTo
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
bool
aCreateLayer
bool
aPositioned
)
;
bool
GetBorderRadii
(
const
nsSize
&
aFrameSize
const
nsSize
&
aBorderArea
Sides
aSkipSides
nscoord
aRadii
[
8
]
)
const
;
bool
ReflowFinished
(
)
final
;
void
ReflowCallbackCanceled
(
)
final
;
void
CurPosAttributeChanged
(
nsIContent
*
aChild
bool
aDoScroll
=
true
)
;
void
PostScrollEvent
(
bool
aDelayed
=
false
)
;
MOZ_CAN_RUN_SCRIPT
void
FireScrollEvent
(
)
;
void
PostScrolledAreaEvent
(
)
;
MOZ_CAN_RUN_SCRIPT
void
FireScrolledAreaEvent
(
)
;
bool
IsSmoothScrollingEnabled
(
)
;
void
FinishReflowForScrollbar
(
Element
*
aElement
nscoord
aMinXY
nscoord
aMaxXY
nscoord
aCurPosXY
nscoord
aPageIncrement
nscoord
aIncrement
)
;
void
SetScrollbarEnabled
(
Element
*
aElement
nscoord
aMaxPos
)
;
void
SetCoordAttribute
(
Element
*
aElement
nsAtom
*
aAtom
nscoord
aSize
)
;
nscoord
GetCoordAttribute
(
nsIFrame
*
aFrame
nsAtom
*
aAtom
nscoord
aDefaultValue
nscoord
*
aRangeStart
nscoord
*
aRangeLength
)
;
void
UpdateScrollbarPosition
(
)
;
nsSize
GetLayoutSize
(
)
const
{
if
(
mIsUsingMinimumScaleSize
)
{
return
mICBSize
;
}
return
mScrollPort
.
Size
(
)
;
}
nsRect
GetScrollPortRect
(
)
const
{
return
mScrollPort
;
}
nsPoint
GetScrollPosition
(
)
const
{
return
mScrollPort
.
TopLeft
(
)
-
mScrolledFrame
-
>
GetPosition
(
)
;
}
nsPoint
GetLogicalScrollPosition
(
)
const
{
nsPoint
pt
;
pt
.
x
=
IsPhysicalLTR
(
)
?
mScrollPort
.
x
-
mScrolledFrame
-
>
GetPosition
(
)
.
x
:
mScrollPort
.
XMost
(
)
-
mScrolledFrame
-
>
GetRect
(
)
.
XMost
(
)
;
pt
.
y
=
mScrollPort
.
y
-
mScrolledFrame
-
>
GetPosition
(
)
.
y
;
return
pt
;
}
nsRect
GetLayoutScrollRange
(
)
const
;
nsRect
GetScrollRange
(
nscoord
aWidth
nscoord
aHeight
)
const
;
nsSize
GetVisualViewportSize
(
)
const
;
nsPoint
GetVisualViewportOffset
(
)
const
;
bool
SetVisualViewportOffset
(
const
nsPoint
&
aOffset
bool
aRepaint
)
;
nsRect
GetVisualScrollRange
(
)
const
;
nsRect
GetScrollRangeForUserInputEvents
(
)
const
;
const
nsRect
&
ScrollPort
(
)
const
{
return
mScrollPort
;
}
void
SetScrollPort
(
const
nsRect
&
aNewScrollPort
)
{
if
(
!
mScrollPort
.
IsEqualEdges
(
aNewScrollPort
)
)
{
mMayScheduleScrollAnimations
=
true
;
}
mScrollPort
=
aNewScrollPort
;
}
nsRect
GetVisualOptimalViewingRect
(
)
const
;
nsPoint
GetLogicalVisualViewportOffset
(
)
const
{
nsPoint
pt
=
GetVisualViewportOffset
(
)
;
if
(
!
IsPhysicalLTR
(
)
)
{
pt
.
x
+
=
GetVisualViewportSize
(
)
.
width
-
mScrolledFrame
-
>
GetRect
(
)
.
width
;
}
return
pt
;
}
void
ScrollSnap
(
ScrollMode
aMode
=
ScrollMode
:
:
SmoothMsd
)
;
void
ScrollSnap
(
const
nsPoint
&
aDestination
ScrollMode
aMode
=
ScrollMode
:
:
SmoothMsd
)
;
bool
HasPendingScrollRestoration
(
)
const
{
return
mRestorePos
!
=
nsPoint
(
-
1
-
1
)
;
}
bool
IsProcessingScrollEvent
(
)
const
{
return
mProcessingScrollEvent
;
}
public
:
static
void
AsyncScrollCallback
(
ScrollFrameHelper
*
aInstance
mozilla
:
:
TimeStamp
aTime
)
;
static
void
AsyncSmoothMSDScrollCallback
(
ScrollFrameHelper
*
aInstance
mozilla
:
:
TimeDuration
aDeltaTime
)
;
void
ScrollTo
(
nsPoint
aScrollPosition
ScrollMode
aMode
ScrollOrigin
aOrigin
=
ScrollOrigin
:
:
NotSpecified
const
nsRect
*
aRange
=
nullptr
mozilla
:
:
ScrollSnapFlags
aSnapFlags
=
mozilla
:
:
ScrollSnapFlags
:
:
Disabled
ScrollTriggeredByScript
aTriggeredByScript
=
ScrollTriggeredByScript
:
:
No
)
;
void
ScrollToCSSPixels
(
const
CSSIntPoint
&
aScrollPosition
ScrollMode
aMode
=
ScrollMode
:
:
Instant
)
;
void
ScrollToCSSPixelsForApz
(
const
mozilla
:
:
CSSPoint
&
aScrollPosition
mozilla
:
:
ScrollSnapTargetIds
&
&
aLastSnapTargetIds
)
;
CSSIntPoint
GetScrollPositionCSSPixels
(
)
;
void
ScrollToImpl
(
nsPoint
aPt
const
nsRect
&
aRange
ScrollOrigin
aOrigin
=
ScrollOrigin
:
:
NotSpecified
ScrollTriggeredByScript
aTriggeredByScript
=
ScrollTriggeredByScript
:
:
No
)
;
void
ScrollVisual
(
)
;
void
ScrollBy
(
nsIntPoint
aDelta
mozilla
:
:
ScrollUnit
aUnit
ScrollMode
aMode
nsIntPoint
*
aOverflow
ScrollOrigin
aOrigin
=
ScrollOrigin
:
:
NotSpecified
nsIScrollableFrame
:
:
ScrollMomentum
aMomentum
=
nsIScrollableFrame
:
:
NOT_MOMENTUM
mozilla
:
:
ScrollSnapFlags
aSnapFlags
=
mozilla
:
:
ScrollSnapFlags
:
:
Disabled
)
;
void
ScrollByCSSPixels
(
const
CSSIntPoint
&
aDelta
ScrollMode
aMode
=
ScrollMode
:
:
Instant
mozilla
:
:
ScrollSnapFlags
aSnapFlags
=
mozilla
:
:
ScrollSnapFlags
:
:
IntendedDirection
|
mozilla
:
:
ScrollSnapFlags
:
:
IntendedEndPosition
)
;
void
ScrollToRestoredPosition
(
)
;
enum
class
LoadingState
{
Loading
Stopped
Loaded
}
;
LoadingState
GetPageLoadingState
(
)
;
Maybe
<
SnapTarget
>
GetSnapPointForDestination
(
mozilla
:
:
ScrollUnit
aUnit
mozilla
:
:
ScrollSnapFlags
aFlags
const
nsPoint
&
aStartPos
const
nsPoint
&
aDestination
)
;
Maybe
<
mozilla
:
:
SnapTarget
>
GetSnapPointForResnap
(
)
;
bool
NeedsResnap
(
)
;
void
SetLastSnapTargetIds
(
UniquePtr
<
ScrollSnapTargetIds
>
aId
)
;
nsMargin
GetScrollPadding
(
)
const
;
nsSize
GetLineScrollAmount
(
)
const
;
nsSize
GetPageScrollAmount
(
)
const
;
mozilla
:
:
UniquePtr
<
mozilla
:
:
PresState
>
SaveState
(
)
const
;
void
RestoreState
(
mozilla
:
:
PresState
*
aState
)
;
nsIFrame
*
GetScrolledFrame
(
)
const
{
return
mScrolledFrame
;
}
nsIFrame
*
GetScrollbarBox
(
bool
aVertical
)
const
{
return
aVertical
?
mVScrollbarBox
:
mHScrollbarBox
;
}
void
AddScrollPositionListener
(
nsIScrollPositionListener
*
aListener
)
{
mListeners
.
AppendElement
(
aListener
)
;
}
void
RemoveScrollPositionListener
(
nsIScrollPositionListener
*
aListener
)
{
mListeners
.
RemoveElement
(
aListener
)
;
}
static
void
SetScrollbarVisibility
(
nsIFrame
*
aScrollbar
bool
aVisible
)
;
nsRect
GetScrolledRect
(
)
const
;
nsRect
GetUnsnappedScrolledRectInternal
(
const
nsRect
&
aScrolledOverflowArea
const
nsSize
&
aScrollPortSize
)
const
;
layers
:
:
ScrollDirections
GetAvailableScrollingDirectionsForUserInputEvents
(
)
const
;
layers
:
:
ScrollDirections
GetScrollbarVisibility
(
)
const
{
layers
:
:
ScrollDirections
result
;
if
(
mHasHorizontalScrollbar
)
{
result
+
=
layers
:
:
ScrollDirection
:
:
eHorizontal
;
}
if
(
mHasVerticalScrollbar
)
{
result
+
=
layers
:
:
ScrollDirection
:
:
eVertical
;
}
return
result
;
}
nsMargin
GetActualScrollbarSizes
(
nsIScrollableFrame
:
:
ScrollbarSizesOptions
aOptions
=
nsIScrollableFrame
:
:
ScrollbarSizesOptions
:
:
NONE
)
const
;
nsMargin
GetDesiredScrollbarSizes
(
nsBoxLayoutState
*
aState
)
;
bool
IsPhysicalLTR
(
)
const
{
return
mOuter
-
>
GetWritingMode
(
)
.
IsPhysicalLTR
(
)
;
}
bool
IsBidiLTR
(
)
const
{
return
mOuter
-
>
GetWritingMode
(
)
.
IsBidiLTR
(
)
;
}
private
:
nsIFrame
*
GetFrameForStyle
(
)
const
;
ScrollSnapInfo
ComputeScrollSnapInfo
(
)
;
bool
NeedsScrollSnap
(
)
const
;
nsSize
GetSnapportSize
(
)
const
;
void
ScheduleScrollAnimations
(
)
;
void
TryScheduleScrollAnimations
(
)
{
if
(
!
mMayScheduleScrollAnimations
)
{
return
;
}
ScheduleScrollAnimations
(
)
;
mMayScheduleScrollAnimations
=
false
;
}
public
:
bool
IsScrollbarOnRight
(
)
const
;
bool
IsScrollingActive
(
)
const
;
bool
IsMaybeAsynchronouslyScrolled
(
)
const
{
return
mWillBuildScrollableLayer
;
}
bool
ComputeCustomOverflow
(
mozilla
:
:
OverflowAreas
&
aOverflowAreas
)
;
void
UpdateSticky
(
)
;
void
UpdatePrevScrolledRect
(
)
;
bool
IsRectNearlyVisible
(
const
nsRect
&
aRect
)
const
;
nsRect
ExpandRectToNearlyVisible
(
const
nsRect
&
aRect
)
const
;
void
AdjustScrollbarRectForResizer
(
nsIFrame
*
aFrame
nsPresContext
*
aPresContext
nsRect
&
aRect
bool
aHasResizer
mozilla
:
:
layers
:
:
ScrollDirection
aDirection
)
;
void
LayoutScrollbars
(
nsBoxLayoutState
&
aState
const
nsRect
&
aInsideBorderArea
const
nsRect
&
aOldScrollPort
)
;
void
MarkScrollbarsDirtyForReflow
(
)
const
;
void
InvalidateScrollbars
(
)
const
;
bool
IsAlwaysActive
(
)
const
;
void
MarkEverScrolled
(
)
;
void
MarkRecentlyScrolled
(
)
;
void
MarkNotRecentlyScrolled
(
)
;
nsExpirationState
*
GetExpirationState
(
)
{
return
&
mActivityExpirationState
;
}
void
SetTransformingByAPZ
(
bool
aTransforming
)
{
if
(
mTransformingByAPZ
&
&
!
aTransforming
)
{
PostScrollEndEvent
(
)
;
}
mTransformingByAPZ
=
aTransforming
;
if
(
!
mozilla
:
:
css
:
:
TextOverflow
:
:
HasClippedTextOverflow
(
mOuter
)
|
|
mozilla
:
:
css
:
:
TextOverflow
:
:
HasBlockEllipsis
(
mScrolledFrame
)
)
{
mOuter
-
>
SchedulePaint
(
)
;
}
}
bool
IsTransformingByAPZ
(
)
const
{
return
mTransformingByAPZ
;
}
void
SetScrollableByAPZ
(
bool
aScrollable
)
;
void
SetZoomableByAPZ
(
bool
aZoomable
)
;
void
SetHasOutOfFlowContentInsideFilter
(
)
;
bool
UsesOverlayScrollbars
(
)
const
;
ScrollSnapInfo
GetScrollSnapInfo
(
)
;
bool
IsLastSnappedTarget
(
const
nsIFrame
*
aFrame
)
const
;
void
TryResnap
(
)
;
void
PostPendingResnapIfNeeded
(
const
nsIFrame
*
aFrame
)
;
void
PostPendingResnap
(
)
;
static
bool
ShouldActivateAllScrollFrames
(
)
;
nsRect
RestrictToRootDisplayPort
(
const
nsRect
&
aDisplayportBase
)
;
bool
DecideScrollableLayer
(
nsDisplayListBuilder
*
aBuilder
nsRect
*
aVisibleRect
nsRect
*
aDirtyRect
bool
aSetBase
bool
*
aDirtyRectHasBeenOverriden
=
nullptr
)
;
void
NotifyApzTransaction
(
)
;
void
NotifyApproximateFrameVisibilityUpdate
(
bool
aIgnoreDisplayPort
)
;
bool
GetDisplayPortAtLastApproximateFrameVisibilityUpdate
(
nsRect
*
aDisplayPort
)
;
bool
AllowDisplayPortExpiration
(
)
;
void
TriggerDisplayPortExpiration
(
)
;
void
ResetDisplayPortExpiryTimer
(
)
;
void
ScheduleSyntheticMouseMove
(
)
;
static
void
ScrollActivityCallback
(
nsITimer
*
aTimer
void
*
anInstance
)
;
void
HandleScrollbarStyleSwitching
(
)
;
ScrollOrigin
LastScrollOrigin
(
)
const
{
return
mLastScrollOrigin
;
}
bool
IsApzAnimationInProgress
(
)
const
{
return
mCurrentAPZScrollAnimationType
!
=
APZScrollAnimationType
:
:
No
;
}
MainThreadScrollGeneration
CurrentScrollGeneration
(
)
const
{
return
mScrollGeneration
;
}
APZScrollGeneration
ScrollGenerationOnApz
(
)
const
{
return
mScrollGenerationOnApz
;
}
nsPoint
LastScrollDestination
(
)
const
{
return
mDestination
;
}
nsTArray
<
ScrollPositionUpdate
>
GetScrollUpdates
(
)
const
;
bool
HasScrollUpdates
(
)
const
{
return
!
mScrollUpdates
.
IsEmpty
(
)
;
}
bool
IsLastScrollUpdateAnimating
(
)
const
;
mozilla
:
:
EnumSet
<
AnimationState
>
ScrollAnimationState
(
)
const
;
void
ResetScrollInfoIfNeeded
(
const
MainThreadScrollGeneration
&
aGeneration
const
APZScrollGeneration
&
aGenerationOnApz
APZScrollAnimationType
aAPZScrollAnimationType
InScrollingGesture
aInScrollingGesture
)
;
bool
WantAsyncScroll
(
)
const
;
Maybe
<
mozilla
:
:
layers
:
:
ScrollMetadata
>
ComputeScrollMetadata
(
WebRenderLayerManager
*
aLayerManager
const
nsIFrame
*
aItemFrame
const
nsPoint
&
aOffsetToReferenceFrame
)
const
;
void
ScrollByPage
(
nsScrollbarFrame
*
aScrollbar
int32_t
aDirection
mozilla
:
:
ScrollSnapFlags
aSnapFlags
=
mozilla
:
:
ScrollSnapFlags
:
:
Disabled
)
;
void
ScrollByWhole
(
nsScrollbarFrame
*
aScrollbar
int32_t
aDirection
mozilla
:
:
ScrollSnapFlags
aSnapFlags
=
mozilla
:
:
ScrollSnapFlags
:
:
Disabled
)
;
void
ScrollByLine
(
nsScrollbarFrame
*
aScrollbar
int32_t
aDirection
mozilla
:
:
ScrollSnapFlags
aSnapFlags
=
mozilla
:
:
ScrollSnapFlags
:
:
Disabled
)
;
void
ScrollByUnit
(
nsScrollbarFrame
*
aScrollbar
ScrollMode
aMode
int32_t
aDirection
ScrollUnit
aUnit
mozilla
:
:
ScrollSnapFlags
aSnapFlags
=
mozilla
:
:
ScrollSnapFlags
:
:
Disabled
)
;
void
RepeatButtonScroll
(
nsScrollbarFrame
*
aScrollbar
)
;
void
ThumbMoved
(
nsScrollbarFrame
*
aScrollbar
nscoord
aOldPos
nscoord
aNewPos
)
;
void
ScrollbarReleased
(
nsScrollbarFrame
*
aScrollbar
)
;
bool
ShouldSuppressScrollbarRepaints
(
)
const
{
return
mSuppressScrollbarRepaints
;
}
bool
DragScroll
(
WidgetEvent
*
aEvent
)
;
void
AsyncScrollbarDragInitiated
(
uint64_t
aDragBlockId
mozilla
:
:
layers
:
:
ScrollDirection
aDirection
)
;
void
AsyncScrollbarDragRejected
(
)
;
bool
IsRootScrollFrameOfDocument
(
)
const
{
return
mIsRoot
;
}
bool
SmoothScrollVisual
(
const
nsPoint
&
aVisualViewportOffset
mozilla
:
:
layers
:
:
FrameMetrics
:
:
ScrollOffsetUpdateType
aUpdateType
)
;
bool
IsSmoothScroll
(
mozilla
:
:
dom
:
:
ScrollBehavior
aBehavior
)
const
;
void
UpdateMinimumScaleSize
(
const
nsRect
&
aScrollableOverflow
const
nsSize
&
aICBSize
)
;
nsSize
TrueOuterSize
(
nsDisplayListBuilder
*
aBuilder
)
const
;
already_AddRefed
<
Element
>
MakeScrollbar
(
dom
:
:
NodeInfo
*
aNodeInfo
bool
aVertical
AnonymousContentKey
&
aKey
)
;
void
AppendScrollUpdate
(
const
ScrollPositionUpdate
&
aUpdate
)
;
nsCOMPtr
<
Element
>
mHScrollbarContent
;
nsCOMPtr
<
Element
>
mVScrollbarContent
;
nsCOMPtr
<
Element
>
mScrollCornerContent
;
nsCOMPtr
<
Element
>
mResizerContent
;
class
ScrollEvent
;
class
ScrollEndEvent
;
class
AsyncScrollPortEvent
;
class
ScrolledAreaEvent
;
RefPtr
<
ScrollEvent
>
mScrollEvent
;
RefPtr
<
ScrollEndEvent
>
mScrollEndEvent
;
nsRevocableEventPtr
<
AsyncScrollPortEvent
>
mAsyncScrollPortEvent
;
nsRevocableEventPtr
<
ScrolledAreaEvent
>
mScrolledAreaEvent
;
nsIFrame
*
mHScrollbarBox
;
nsIFrame
*
mVScrollbarBox
;
nsIFrame
*
mScrolledFrame
;
nsIFrame
*
mScrollCornerBox
;
nsIFrame
*
mResizerBox
;
nsContainerFrame
*
mOuter
;
const
nsIFrame
*
mReferenceFrameDuringPainting
;
RefPtr
<
AsyncScroll
>
mAsyncScroll
;
RefPtr
<
AsyncSmoothMSDScroll
>
mAsyncSmoothMSDScroll
;
RefPtr
<
ScrollbarActivity
>
mScrollbarActivity
;
nsTArray
<
nsIScrollPositionListener
*
>
mListeners
;
ScrollOrigin
mLastScrollOrigin
;
Maybe
<
nsPoint
>
mApzSmoothScrollDestination
;
MainThreadScrollGeneration
mScrollGeneration
;
APZScrollGeneration
mScrollGenerationOnApz
;
nsTArray
<
ScrollPositionUpdate
>
mScrollUpdates
;
nsSize
mMinimumScaleSize
;
nsSize
mICBSize
;
nsPoint
mDestination
;
nsPoint
mRestorePos
;
nsPoint
mLastPos
;
nsPoint
mApzScrollPos
;
nsExpirationState
mActivityExpirationState
;
nsCOMPtr
<
nsITimer
>
mScrollActivityTimer
;
nsPoint
mLastUpdateFramesPos
;
nsRect
mDisplayPortAtLastFrameUpdate
;
nsRect
mPrevScrolledRect
;
ScrollableLayerGuid
:
:
ViewID
mScrollParentID
;
nsCOMPtr
<
nsITimer
>
mDisplayPortExpiryTimer
;
ScrollAnchorContainer
mAnchor
;
SnapTargetSet
mSnapTargets
;
APZScrollAnimationType
mCurrentAPZScrollAnimationType
;
InScrollingGesture
mInScrollingGesture
:
1
;
bool
mAllowScrollOriginDowngrade
:
1
;
bool
mHadDisplayPortAtLastFrameUpdate
:
1
;
bool
mHasVerticalScrollbar
:
1
;
bool
mHasHorizontalScrollbar
:
1
;
bool
mOnlyNeedVScrollbarToScrollVVInsideLV
:
1
;
bool
mOnlyNeedHScrollbarToScrollVVInsideLV
:
1
;
bool
mFrameIsUpdatingScrollbar
:
1
;
bool
mDidHistoryRestore
:
1
;
bool
mIsRoot
:
1
;
bool
mSuppressScrollbarUpdate
:
1
;
bool
mSkippedScrollbarLayout
:
1
;
bool
mHadNonInitialReflow
:
1
;
bool
mFirstReflow
:
1
;
bool
mHorizontalOverflow
:
1
;
bool
mVerticalOverflow
:
1
;
bool
mPostedReflowCallback
:
1
;
bool
mMayHaveDirtyFixedChildren
:
1
;
bool
mUpdateScrollbarAttributes
:
1
;
bool
mHasBeenScrolledRecently
:
1
;
bool
mWillBuildScrollableLayer
:
1
;
bool
mIsParentToActiveScrollFrames
:
1
;
bool
mHasBeenScrolled
:
1
;
bool
mIgnoreMomentumScroll
:
1
;
bool
mTransformingByAPZ
:
1
;
bool
mScrollableByAPZ
:
1
;
bool
mZoomableByAPZ
:
1
;
bool
mHasOutOfFlowContentInsideFilter
:
1
;
bool
mSuppressScrollbarRepaints
:
1
;
bool
mIsUsingMinimumScaleSize
:
1
;
bool
mMinimumScaleSizeChanged
:
1
;
bool
mProcessingScrollEvent
:
1
;
bool
mApzAnimationRequested
:
1
;
bool
mReclampVVOffsetInReflowFinished
:
1
;
bool
mMayScheduleScrollAnimations
:
1
;
#
ifdef
MOZ_WIDGET_ANDROID
bool
mHasVerticalOverflowForDynamicToolbar
:
1
;
#
endif
mozilla
:
:
layout
:
:
ScrollVelocityQueue
mVelocityQueue
;
protected
:
class
AutoScrollbarRepaintSuppression
;
friend
class
AutoScrollbarRepaintSuppression
;
class
AutoScrollbarRepaintSuppression
{
public
:
AutoScrollbarRepaintSuppression
(
ScrollFrameHelper
*
aHelper
AutoWeakFrame
&
aWeakOuter
bool
aSuppress
)
:
mHelper
(
aHelper
)
mWeakOuter
(
aWeakOuter
)
mOldSuppressValue
(
aHelper
-
>
mSuppressScrollbarRepaints
)
{
mHelper
-
>
mSuppressScrollbarRepaints
=
aSuppress
;
}
~
AutoScrollbarRepaintSuppression
(
)
{
if
(
mWeakOuter
.
IsAlive
(
)
)
{
mHelper
-
>
mSuppressScrollbarRepaints
=
mOldSuppressValue
;
}
}
private
:
ScrollFrameHelper
*
mHelper
;
AutoWeakFrame
&
mWeakOuter
;
bool
mOldSuppressValue
;
}
;
struct
ScrollOperationParams
{
ScrollOperationParams
(
const
ScrollOperationParams
&
)
=
delete
;
ScrollOperationParams
(
ScrollMode
aMode
ScrollOrigin
aOrigin
)
:
mMode
(
aMode
)
mOrigin
(
aOrigin
)
{
}
ScrollOperationParams
(
ScrollMode
aMode
ScrollOrigin
aOrigin
ScrollSnapTargetIds
&
&
aSnapTargetIds
)
:
ScrollOperationParams
(
aMode
aOrigin
)
{
mTargetIds
=
std
:
:
move
(
aSnapTargetIds
)
;
}
ScrollOperationParams
(
ScrollMode
aMode
ScrollOrigin
aOrigin
mozilla
:
:
ScrollSnapFlags
aSnapFlags
ScrollTriggeredByScript
aTriggeredByScript
)
:
ScrollOperationParams
(
aMode
aOrigin
)
{
mSnapFlags
=
aSnapFlags
;
mTriggeredByScript
=
aTriggeredByScript
;
}
ScrollMode
mMode
;
ScrollOrigin
mOrigin
;
mozilla
:
:
ScrollSnapFlags
mSnapFlags
=
mozilla
:
:
ScrollSnapFlags
:
:
Disabled
;
ScrollTriggeredByScript
mTriggeredByScript
=
ScrollTriggeredByScript
:
:
No
;
ScrollSnapTargetIds
mTargetIds
;
bool
IsInstant
(
)
const
{
return
mMode
=
=
ScrollMode
:
:
Instant
;
}
bool
IsSmoothMsd
(
)
const
{
return
mMode
=
=
ScrollMode
:
:
SmoothMsd
;
}
bool
IsSmooth
(
)
const
{
return
mMode
=
=
ScrollMode
:
:
Smooth
;
}
bool
IsScrollSnapDisabled
(
)
const
{
return
mSnapFlags
=
=
mozilla
:
:
ScrollSnapFlags
:
:
Disabled
;
}
}
;
void
ScrollToWithOrigin
(
nsPoint
aScrollPosition
const
nsRect
*
aRange
ScrollOperationParams
&
&
aParams
)
;
void
CompleteAsyncScroll
(
const
nsRect
&
aRange
UniquePtr
<
ScrollSnapTargetIds
>
aSnapTargetIds
ScrollOrigin
aOrigin
=
ScrollOrigin
:
:
NotSpecified
)
;
bool
HasPerspective
(
)
const
{
return
mOuter
-
>
ChildrenHavePerspective
(
)
;
}
bool
HasBgAttachmentLocal
(
)
const
;
mozilla
:
:
StyleDirection
GetScrolledFrameDir
(
)
const
;
void
ApzSmoothScrollTo
(
const
nsPoint
&
aDestination
ScrollOrigin
aOrigin
ScrollTriggeredByScript
aTriggeredByScript
UniquePtr
<
ScrollSnapTargetIds
>
aSnapTargetIds
)
;
void
RemoveObservers
(
)
;
private
:
nsRect
mScrollPort
;
UniquePtr
<
ScrollSnapTargetIds
>
mLastSnapTargetIds
;
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
ScrollFrameHelper
:
:
OverflowState
)
}
class
nsHTMLScrollFrame
:
public
nsContainerFrame
public
nsIScrollableFrame
public
nsIAnonymousContentCreator
public
nsIStatefulFrame
{
public
:
using
ScrollFrameHelper
=
mozilla
:
:
ScrollFrameHelper
;
using
CSSIntPoint
=
mozilla
:
:
CSSIntPoint
;
using
ScrollReflowInput
=
mozilla
:
:
ScrollReflowInput
;
using
ScrollAnchorContainer
=
mozilla
:
:
layout
:
:
ScrollAnchorContainer
;
friend
nsHTMLScrollFrame
*
NS_NewHTMLScrollFrame
(
mozilla
:
:
PresShell
*
aPresShell
ComputedStyle
*
aStyle
bool
aIsRoot
)
;
NS_DECL_QUERYFRAME
NS_DECL_FRAMEARENA_HELPERS
(
nsHTMLScrollFrame
)
void
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
override
{
mHelper
.
BuildDisplayList
(
aBuilder
aLists
)
;
}
bool
TryLayout
(
ScrollReflowInput
&
aState
ReflowOutput
*
aKidMetrics
bool
aAssumeHScroll
bool
aAssumeVScroll
bool
aForce
)
;
bool
ScrolledContentDependsOnBSize
(
const
ScrollReflowInput
&
aState
)
const
;
void
ReflowScrolledFrame
(
ScrollReflowInput
&
aState
bool
aAssumeHScroll
bool
aAssumeVScroll
ReflowOutput
*
aMetrics
)
;
void
ReflowContents
(
ScrollReflowInput
&
aState
const
ReflowOutput
&
aDesiredSize
)
;
void
PlaceScrollArea
(
ScrollReflowInput
&
aState
const
nsPoint
&
aScrollPosition
)
;
nscoord
IntrinsicScrollbarGutterSizeAtInlineEdges
(
gfxContext
*
aRenderingContext
)
;
bool
GetBorderRadii
(
const
nsSize
&
aFrameSize
const
nsSize
&
aBorderArea
Sides
aSkipSides
nscoord
aRadii
[
8
]
)
const
final
{
return
mHelper
.
GetBorderRadii
(
aFrameSize
aBorderArea
aSkipSides
aRadii
)
;
}
nscoord
GetMinISize
(
gfxContext
*
aRenderingContext
)
override
;
nscoord
GetPrefISize
(
gfxContext
*
aRenderingContext
)
override
;
nsresult
GetXULPadding
(
nsMargin
&
aPadding
)
final
;
bool
IsXULCollapsed
(
)
final
;
void
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
override
;
void
DidReflow
(
nsPresContext
*
aPresContext
const
ReflowInput
*
aReflowInput
)
override
;
bool
ComputeCustomOverflow
(
mozilla
:
:
OverflowAreas
&
aOverflowAreas
)
final
{
return
mHelper
.
ComputeCustomOverflow
(
aOverflowAreas
)
;
}
nscoord
GetLogicalBaseline
(
mozilla
:
:
WritingMode
aWritingMode
)
const
final
;
bool
GetVerticalAlignBaseline
(
mozilla
:
:
WritingMode
aWM
nscoord
*
aBaseline
)
const
final
{
NS_ASSERTION
(
!
aWM
.
IsOrthogonalTo
(
GetWritingMode
(
)
)
"
You
should
only
call
this
on
frames
with
a
WM
that
'
s
"
"
parallel
to
aWM
"
)
;
*
aBaseline
=
GetLogicalBaseline
(
aWM
)
;
return
true
;
}
void
AdjustForPerspective
(
nsRect
&
aScrollableOverflow
)
;
void
SetInitialChildList
(
ChildListID
aListID
nsFrameList
&
aChildList
)
override
;
void
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
final
;
void
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
const
nsLineList
:
:
iterator
*
aPrevFrameLine
nsFrameList
&
aFrameList
)
final
;
void
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
final
;
void
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
)
override
;
void
DidSetComputedStyle
(
ComputedStyle
*
aOldComputedStyle
)
final
{
nsContainerFrame
:
:
DidSetComputedStyle
(
aOldComputedStyle
)
;
mHelper
.
DidSetComputedStyle
(
aOldComputedStyle
)
;
}
nsIScrollableFrame
*
GetScrollTargetFrame
(
)
const
final
{
return
const_cast
<
nsHTMLScrollFrame
*
>
(
this
)
;
}
nsContainerFrame
*
GetContentInsertionFrame
(
)
override
{
return
mHelper
.
GetScrolledFrame
(
)
-
>
GetContentInsertionFrame
(
)
;
}
bool
DoesClipChildrenInBothAxes
(
)
final
{
return
true
;
}
nsPoint
GetPositionOfChildIgnoringScrolling
(
const
nsIFrame
*
aChild
)
final
{
nsPoint
pt
=
aChild
-
>
GetPosition
(
)
;
if
(
aChild
=
=
mHelper
.
GetScrolledFrame
(
)
)
pt
+
=
GetScrollPosition
(
)
;
return
pt
;
}
nsresult
CreateAnonymousContent
(
nsTArray
<
ContentInfo
>
&
)
final
;
void
AppendAnonymousContentTo
(
nsTArray
<
nsIContent
*
>
&
uint32_t
aFilter
)
final
;
nsIFrame
*
GetScrolledFrame
(
)
const
final
{
return
mHelper
.
GetScrolledFrame
(
)
;
}
mozilla
:
:
ScrollStyles
GetScrollStyles
(
)
const
override
{
return
mHelper
.
GetScrollStylesFromFrame
(
)
;
}
bool
IsForTextControlWithNoScrollbars
(
)
const
final
{
return
mHelper
.
IsForTextControlWithNoScrollbars
(
)
;
}
bool
HasAllNeededScrollbars
(
)
const
final
{
return
mHelper
.
HasAllNeededScrollbars
(
)
;
}
mozilla
:
:
layers
:
:
OverscrollBehaviorInfo
GetOverscrollBehaviorInfo
(
)
const
final
{
return
mHelper
.
GetOverscrollBehaviorInfo
(
)
;
}
mozilla
:
:
layers
:
:
ScrollDirections
GetAvailableScrollingDirectionsForUserInputEvents
(
)
const
final
{
return
mHelper
.
GetAvailableScrollingDirectionsForUserInputEvents
(
)
;
}
mozilla
:
:
layers
:
:
ScrollDirections
GetScrollbarVisibility
(
)
const
final
{
return
mHelper
.
GetScrollbarVisibility
(
)
;
}
nsMargin
GetActualScrollbarSizes
(
nsIScrollableFrame
:
:
ScrollbarSizesOptions
aOptions
=
nsIScrollableFrame
:
:
ScrollbarSizesOptions
:
:
NONE
)
const
final
{
return
mHelper
.
GetActualScrollbarSizes
(
aOptions
)
;
}
nsMargin
GetDesiredScrollbarSizes
(
nsBoxLayoutState
*
aState
)
final
{
return
mHelper
.
GetDesiredScrollbarSizes
(
aState
)
;
}
nsMargin
GetDesiredScrollbarSizes
(
nsPresContext
*
aPresContext
gfxContext
*
aRC
)
final
{
nsBoxLayoutState
bls
(
aPresContext
aRC
0
)
;
return
GetDesiredScrollbarSizes
(
&
bls
)
;
}
nsSize
GetLayoutSize
(
)
const
final
{
return
mHelper
.
GetLayoutSize
(
)
;
}
nsRect
GetScrolledRect
(
)
const
final
{
return
mHelper
.
GetScrolledRect
(
)
;
}
nsRect
GetScrollPortRect
(
)
const
final
{
return
mHelper
.
GetScrollPortRect
(
)
;
}
nsPoint
GetScrollPosition
(
)
const
final
{
return
mHelper
.
GetScrollPosition
(
)
;
}
nsPoint
GetLogicalScrollPosition
(
)
const
final
{
return
mHelper
.
GetLogicalScrollPosition
(
)
;
}
nsRect
GetScrollRange
(
)
const
final
{
return
mHelper
.
GetLayoutScrollRange
(
)
;
}
nsSize
GetVisualViewportSize
(
)
const
final
{
return
mHelper
.
GetVisualViewportSize
(
)
;
}
nsPoint
GetVisualViewportOffset
(
)
const
final
{
return
mHelper
.
GetVisualViewportOffset
(
)
;
}
bool
SetVisualViewportOffset
(
const
nsPoint
&
aOffset
bool
aRepaint
)
final
{
return
mHelper
.
SetVisualViewportOffset
(
aOffset
aRepaint
)
;
}
nsRect
GetVisualScrollRange
(
)
const
final
{
return
mHelper
.
GetVisualScrollRange
(
)
;
}
nsRect
GetScrollRangeForUserInputEvents
(
)
const
final
{
return
mHelper
.
GetScrollRangeForUserInputEvents
(
)
;
}
nsSize
GetLineScrollAmount
(
)
const
final
{
return
mHelper
.
GetLineScrollAmount
(
)
;
}
nsSize
GetPageScrollAmount
(
)
const
final
{
return
mHelper
.
GetPageScrollAmount
(
)
;
}
nsMargin
GetScrollPadding
(
)
const
final
{
return
mHelper
.
GetScrollPadding
(
)
;
}
void
ScrollTo
(
nsPoint
aScrollPosition
ScrollMode
aMode
const
nsRect
*
aRange
=
nullptr
mozilla
:
:
ScrollSnapFlags
aSnapFlags
=
mozilla
:
:
ScrollSnapFlags
:
:
Disabled
mozilla
:
:
ScrollTriggeredByScript
aTriggeredByScript
=
mozilla
:
:
ScrollTriggeredByScript
:
:
No
)
final
{
mHelper
.
ScrollTo
(
aScrollPosition
aMode
ScrollOrigin
:
:
Other
aRange
aSnapFlags
)
;
}
void
ScrollToCSSPixels
(
const
CSSIntPoint
&
aScrollPosition
ScrollMode
aMode
=
ScrollMode
:
:
Instant
)
final
{
mHelper
.
ScrollToCSSPixels
(
aScrollPosition
aMode
)
;
}
void
ScrollToCSSPixelsForApz
(
const
mozilla
:
:
CSSPoint
&
aScrollPosition
mozilla
:
:
ScrollSnapTargetIds
&
&
aLastSnapTargetIds
)
final
{
mHelper
.
ScrollToCSSPixelsForApz
(
aScrollPosition
std
:
:
move
(
aLastSnapTargetIds
)
)
;
}
CSSIntPoint
GetScrollPositionCSSPixels
(
)
final
{
return
mHelper
.
GetScrollPositionCSSPixels
(
)
;
}
void
ScrollBy
(
nsIntPoint
aDelta
mozilla
:
:
ScrollUnit
aUnit
ScrollMode
aMode
nsIntPoint
*
aOverflow
ScrollOrigin
aOrigin
=
ScrollOrigin
:
:
NotSpecified
nsIScrollableFrame
:
:
ScrollMomentum
aMomentum
=
nsIScrollableFrame
:
:
NOT_MOMENTUM
mozilla
:
:
ScrollSnapFlags
aSnapFlags
=
mozilla
:
:
ScrollSnapFlags
:
:
Disabled
)
final
{
mHelper
.
ScrollBy
(
aDelta
aUnit
aMode
aOverflow
aOrigin
aMomentum
aSnapFlags
)
;
}
void
ScrollByCSSPixels
(
const
CSSIntPoint
&
aDelta
ScrollMode
aMode
=
ScrollMode
:
:
Instant
)
final
{
mHelper
.
ScrollByCSSPixels
(
aDelta
aMode
)
;
}
void
ScrollSnap
(
)
final
{
mHelper
.
ScrollSnap
(
)
;
}
void
ScrollToRestoredPosition
(
)
final
{
mHelper
.
ScrollToRestoredPosition
(
)
;
}
void
AddScrollPositionListener
(
nsIScrollPositionListener
*
aListener
)
final
{
mHelper
.
AddScrollPositionListener
(
aListener
)
;
}
void
RemoveScrollPositionListener
(
nsIScrollPositionListener
*
aListener
)
final
{
mHelper
.
RemoveScrollPositionListener
(
aListener
)
;
}
void
CurPosAttributeChanged
(
nsIContent
*
aChild
)
final
{
mHelper
.
CurPosAttributeChanged
(
aChild
)
;
}
NS_IMETHOD
PostScrolledAreaEventForCurrentArea
(
)
final
{
mHelper
.
PostScrolledAreaEvent
(
)
;
return
NS_OK
;
}
bool
IsScrollingActive
(
)
final
{
return
mHelper
.
IsScrollingActive
(
)
;
}
bool
IsMaybeAsynchronouslyScrolled
(
)
final
{
return
mHelper
.
IsMaybeAsynchronouslyScrolled
(
)
;
}
bool
DidHistoryRestore
(
)
const
final
{
return
mHelper
.
mDidHistoryRestore
;
}
void
ClearDidHistoryRestore
(
)
final
{
mHelper
.
mDidHistoryRestore
=
false
;
}
void
MarkEverScrolled
(
)
final
{
mHelper
.
MarkEverScrolled
(
)
;
}
bool
IsRectNearlyVisible
(
const
nsRect
&
aRect
)
final
{
return
mHelper
.
IsRectNearlyVisible
(
aRect
)
;
}
nsRect
ExpandRectToNearlyVisible
(
const
nsRect
&
aRect
)
const
final
{
return
mHelper
.
ExpandRectToNearlyVisible
(
aRect
)
;
}
ScrollOrigin
LastScrollOrigin
(
)
final
{
return
mHelper
.
LastScrollOrigin
(
)
;
}
using
AnimationState
=
nsIScrollableFrame
:
:
AnimationState
;
mozilla
:
:
EnumSet
<
AnimationState
>
ScrollAnimationState
(
)
const
final
{
return
mHelper
.
ScrollAnimationState
(
)
;
}
mozilla
:
:
MainThreadScrollGeneration
CurrentScrollGeneration
(
)
const
final
{
return
mHelper
.
CurrentScrollGeneration
(
)
;
}
mozilla
:
:
APZScrollGeneration
ScrollGenerationOnApz
(
)
const
final
{
return
mHelper
.
ScrollGenerationOnApz
(
)
;
}
nsPoint
LastScrollDestination
(
)
final
{
return
mHelper
.
LastScrollDestination
(
)
;
}
nsTArray
<
mozilla
:
:
ScrollPositionUpdate
>
GetScrollUpdates
(
)
const
final
{
return
mHelper
.
GetScrollUpdates
(
)
;
}
bool
HasScrollUpdates
(
)
const
final
{
return
mHelper
.
HasScrollUpdates
(
)
;
}
void
ResetScrollInfoIfNeeded
(
const
mozilla
:
:
MainThreadScrollGeneration
&
aGeneration
const
mozilla
:
:
APZScrollGeneration
&
aGenerationOnApz
mozilla
:
:
APZScrollAnimationType
aAPZScrollAnimationType
InScrollingGesture
aInScrollingGesture
)
final
{
mHelper
.
ResetScrollInfoIfNeeded
(
aGeneration
aGenerationOnApz
aAPZScrollAnimationType
aInScrollingGesture
)
;
}
bool
WantAsyncScroll
(
)
const
final
{
return
mHelper
.
WantAsyncScroll
(
)
;
}
mozilla
:
:
Maybe
<
mozilla
:
:
layers
:
:
ScrollMetadata
>
ComputeScrollMetadata
(
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aLayerManager
const
nsIFrame
*
aItemFrame
const
nsPoint
&
aOffsetToReferenceFrame
)
const
final
{
return
mHelper
.
ComputeScrollMetadata
(
aLayerManager
aItemFrame
aOffsetToReferenceFrame
)
;
}
void
MarkScrollbarsDirtyForReflow
(
)
const
final
{
mHelper
.
MarkScrollbarsDirtyForReflow
(
)
;
}
void
InvalidateScrollbars
(
)
const
final
{
mHelper
.
InvalidateScrollbars
(
)
;
}
void
UpdateScrollbarPosition
(
)
final
{
mHelper
.
UpdateScrollbarPosition
(
)
;
}
bool
DecideScrollableLayer
(
nsDisplayListBuilder
*
aBuilder
nsRect
*
aVisibleRect
nsRect
*
aDirtyRect
bool
aSetBase
)
final
{
return
mHelper
.
DecideScrollableLayer
(
aBuilder
aVisibleRect
aDirtyRect
aSetBase
)
;
}
void
NotifyApzTransaction
(
)
final
{
mHelper
.
NotifyApzTransaction
(
)
;
}
void
NotifyApproximateFrameVisibilityUpdate
(
bool
aIgnoreDisplayPort
)
final
{
mHelper
.
NotifyApproximateFrameVisibilityUpdate
(
aIgnoreDisplayPort
)
;
}
bool
GetDisplayPortAtLastApproximateFrameVisibilityUpdate
(
nsRect
*
aDisplayPort
)
final
{
return
mHelper
.
GetDisplayPortAtLastApproximateFrameVisibilityUpdate
(
aDisplayPort
)
;
}
void
TriggerDisplayPortExpiration
(
)
final
{
mHelper
.
TriggerDisplayPortExpiration
(
)
;
}
mozilla
:
:
UniquePtr
<
mozilla
:
:
PresState
>
SaveState
(
)
final
{
return
mHelper
.
SaveState
(
)
;
}
NS_IMETHOD
RestoreState
(
mozilla
:
:
PresState
*
aState
)
final
{
NS_ENSURE_ARG_POINTER
(
aState
)
;
mHelper
.
RestoreState
(
aState
)
;
return
NS_OK
;
}
void
ScrollByPage
(
nsScrollbarFrame
*
aScrollbar
int32_t
aDirection
mozilla
:
:
ScrollSnapFlags
aSnapFlags
=
mozilla
:
:
ScrollSnapFlags
:
:
Disabled
)
final
{
mHelper
.
ScrollByPage
(
aScrollbar
aDirection
aSnapFlags
)
;
}
void
ScrollByWhole
(
nsScrollbarFrame
*
aScrollbar
int32_t
aDirection
mozilla
:
:
ScrollSnapFlags
aSnapFlags
=
mozilla
:
:
ScrollSnapFlags
:
:
Disabled
)
final
{
mHelper
.
ScrollByWhole
(
aScrollbar
aDirection
aSnapFlags
)
;
}
void
ScrollByLine
(
nsScrollbarFrame
*
aScrollbar
int32_t
aDirection
mozilla
:
:
ScrollSnapFlags
aSnapFlags
=
mozilla
:
:
ScrollSnapFlags
:
:
Disabled
)
final
{
mHelper
.
ScrollByLine
(
aScrollbar
aDirection
aSnapFlags
)
;
}
void
ScrollByUnit
(
nsScrollbarFrame
*
aScrollbar
ScrollMode
aMode
int32_t
aDirection
mozilla
:
:
ScrollUnit
aUnit
mozilla
:
:
ScrollSnapFlags
aSnapFlags
=
mozilla
:
:
ScrollSnapFlags
:
:
Disabled
)
final
{
mHelper
.
ScrollByUnit
(
aScrollbar
aMode
aDirection
aUnit
aSnapFlags
)
;
}
void
RepeatButtonScroll
(
nsScrollbarFrame
*
aScrollbar
)
final
{
mHelper
.
RepeatButtonScroll
(
aScrollbar
)
;
}
void
ThumbMoved
(
nsScrollbarFrame
*
aScrollbar
nscoord
aOldPos
nscoord
aNewPos
)
final
{
mHelper
.
ThumbMoved
(
aScrollbar
aOldPos
aNewPos
)
;
}
void
ScrollbarReleased
(
nsScrollbarFrame
*
aScrollbar
)
final
{
mHelper
.
ScrollbarReleased
(
aScrollbar
)
;
}
void
VisibilityChanged
(
bool
aVisible
)
final
{
}
nsIFrame
*
GetScrollbarBox
(
bool
aVertical
)
final
{
return
mHelper
.
GetScrollbarBox
(
aVertical
)
;
}
void
ScrollbarActivityStarted
(
)
const
final
;
void
ScrollbarActivityStopped
(
)
const
final
;
bool
IsScrollbarOnRight
(
)
const
final
{
return
mHelper
.
IsScrollbarOnRight
(
)
;
}
bool
ShouldSuppressScrollbarRepaints
(
)
const
final
{
return
mHelper
.
ShouldSuppressScrollbarRepaints
(
)
;
}
void
SetTransformingByAPZ
(
bool
aTransforming
)
final
{
mHelper
.
SetTransformingByAPZ
(
aTransforming
)
;
}
bool
IsTransformingByAPZ
(
)
const
final
{
return
mHelper
.
IsTransformingByAPZ
(
)
;
}
void
SetScrollableByAPZ
(
bool
aScrollable
)
final
{
mHelper
.
SetScrollableByAPZ
(
aScrollable
)
;
}
void
SetZoomableByAPZ
(
bool
aZoomable
)
final
{
mHelper
.
SetZoomableByAPZ
(
aZoomable
)
;
}
void
SetHasOutOfFlowContentInsideFilter
(
)
final
{
mHelper
.
SetHasOutOfFlowContentInsideFilter
(
)
;
}
ScrollSnapInfo
GetScrollSnapInfo
(
)
final
{
return
mHelper
.
GetScrollSnapInfo
(
)
;
}
void
TryResnap
(
)
final
{
mHelper
.
TryResnap
(
)
;
}
void
PostPendingResnapIfNeeded
(
const
nsIFrame
*
aFrame
)
final
{
mHelper
.
PostPendingResnapIfNeeded
(
aFrame
)
;
}
void
PostPendingResnap
(
)
final
{
mHelper
.
PostPendingResnap
(
)
;
}
bool
DragScroll
(
mozilla
:
:
WidgetEvent
*
aEvent
)
final
{
return
mHelper
.
DragScroll
(
aEvent
)
;
}
void
AsyncScrollbarDragInitiated
(
uint64_t
aDragBlockId
mozilla
:
:
layers
:
:
ScrollDirection
aDirection
)
final
{
return
mHelper
.
AsyncScrollbarDragInitiated
(
aDragBlockId
aDirection
)
;
}
void
AsyncScrollbarDragRejected
(
)
final
{
return
mHelper
.
AsyncScrollbarDragRejected
(
)
;
}
bool
IsRootScrollFrameOfDocument
(
)
const
final
{
return
mHelper
.
IsRootScrollFrameOfDocument
(
)
;
}
const
ScrollAnchorContainer
*
Anchor
(
)
const
final
{
return
&
mHelper
.
mAnchor
;
}
ScrollAnchorContainer
*
Anchor
(
)
final
{
return
&
mHelper
.
mAnchor
;
}
void
AppendDirectlyOwnedAnonBoxes
(
nsTArray
<
OwnedAnonBox
>
&
aResult
)
final
{
aResult
.
AppendElement
(
OwnedAnonBox
(
mHelper
.
GetScrolledFrame
(
)
)
)
;
}
bool
SmoothScrollVisual
(
const
nsPoint
&
aVisualViewportOffset
mozilla
:
:
layers
:
:
FrameMetrics
:
:
ScrollOffsetUpdateType
aUpdateType
)
final
{
return
mHelper
.
SmoothScrollVisual
(
aVisualViewportOffset
aUpdateType
)
;
}
bool
IsSmoothScroll
(
mozilla
:
:
dom
:
:
ScrollBehavior
aBehavior
)
const
final
{
return
mHelper
.
IsSmoothScroll
(
aBehavior
)
;
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
GetFrameName
(
nsAString
&
aResult
)
const
override
;
#
endif
#
ifdef
ACCESSIBILITY
mozilla
:
:
a11y
:
:
AccType
AccessibleType
(
)
override
;
#
endif
protected
:
nsHTMLScrollFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
bool
aIsRoot
)
:
nsHTMLScrollFrame
(
aStyle
aPresContext
kClassID
aIsRoot
)
{
}
nsHTMLScrollFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
nsIFrame
:
:
ClassID
aID
bool
aIsRoot
)
;
void
SetSuppressScrollbarUpdate
(
bool
aSuppress
)
{
mHelper
.
mSuppressScrollbarUpdate
=
aSuppress
;
}
bool
GuessHScrollbarNeeded
(
const
ScrollReflowInput
&
aState
)
;
bool
GuessVScrollbarNeeded
(
const
ScrollReflowInput
&
aState
)
;
bool
IsScrollbarUpdateSuppressed
(
)
const
{
return
mHelper
.
mSuppressScrollbarUpdate
;
}
bool
InInitialReflow
(
)
const
;
virtual
bool
ShouldPropagateComputedBSizeToScrolledContent
(
)
const
{
return
true
;
}
private
:
friend
class
mozilla
:
:
ScrollFrameHelper
;
ScrollFrameHelper
mHelper
;
}
;
class
nsXULScrollFrame
final
:
public
nsBoxFrame
public
nsIScrollableFrame
public
nsIAnonymousContentCreator
public
nsIStatefulFrame
{
public
:
using
ScrollFrameHelper
=
mozilla
:
:
ScrollFrameHelper
;
using
CSSIntPoint
=
mozilla
:
:
CSSIntPoint
;
using
ScrollAnchorContainer
=
mozilla
:
:
layout
:
:
ScrollAnchorContainer
;
NS_DECL_QUERYFRAME
NS_DECL_FRAMEARENA_HELPERS
(
nsXULScrollFrame
)
friend
nsXULScrollFrame
*
NS_NewXULScrollFrame
(
mozilla
:
:
PresShell
*
aPresShell
ComputedStyle
*
aStyle
bool
aIsRoot
)
;
void
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
final
{
mHelper
.
BuildDisplayList
(
aBuilder
aLists
)
;
}
#
if
0
nscoord
GetMinISize
(
gfxContext
*
aRenderingContext
)
final
;
#
endif
bool
ComputeCustomOverflow
(
mozilla
:
:
OverflowAreas
&
aOverflowAreas
)
final
{
return
mHelper
.
ComputeCustomOverflow
(
aOverflowAreas
)
;
}
bool
GetVerticalAlignBaseline
(
mozilla
:
:
WritingMode
aWM
nscoord
*
aBaseline
)
const
final
{
*
aBaseline
=
GetLogicalBaseline
(
aWM
)
;
return
true
;
}
void
SetInitialChildList
(
ChildListID
aListID
nsFrameList
&
aChildList
)
final
;
void
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
final
;
void
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
const
nsLineList
:
:
iterator
*
aPrevFrameLine
nsFrameList
&
aFrameList
)
final
;
void
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
final
;
void
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
final
;
void
DidSetComputedStyle
(
ComputedStyle
*
aOldComputedStyle
)
final
{
nsBoxFrame
:
:
DidSetComputedStyle
(
aOldComputedStyle
)
;
mHelper
.
DidSetComputedStyle
(
aOldComputedStyle
)
;
}
;
nsIScrollableFrame
*
GetScrollTargetFrame
(
)
const
final
{
return
const_cast
<
nsXULScrollFrame
*
>
(
this
)
;
}
nsContainerFrame
*
GetContentInsertionFrame
(
)
final
{
return
mHelper
.
GetScrolledFrame
(
)
-
>
GetContentInsertionFrame
(
)
;
}
bool
DoesClipChildrenInBothAxes
(
)
final
{
return
true
;
}
nsPoint
GetPositionOfChildIgnoringScrolling
(
const
nsIFrame
*
aChild
)
final
{
nsPoint
pt
=
aChild
-
>
GetPosition
(
)
;
if
(
aChild
=
=
mHelper
.
GetScrolledFrame
(
)
)
pt
+
=
mHelper
.
GetLogicalScrollPosition
(
)
;
return
pt
;
}
nsresult
CreateAnonymousContent
(
nsTArray
<
ContentInfo
>
&
aElements
)
final
;
void
AppendAnonymousContentTo
(
nsTArray
<
nsIContent
*
>
&
aElements
uint32_t
aFilter
)
final
;
nsSize
GetXULMinSize
(
nsBoxLayoutState
&
aBoxLayoutState
)
final
;
nsSize
GetXULPrefSize
(
nsBoxLayoutState
&
aBoxLayoutState
)
final
;
nsSize
GetXULMaxSize
(
nsBoxLayoutState
&
aBoxLayoutState
)
final
;
nscoord
GetXULBoxAscent
(
nsBoxLayoutState
&
aBoxLayoutState
)
final
;
NS_IMETHOD
DoXULLayout
(
nsBoxLayoutState
&
aBoxLayoutState
)
final
;
nsresult
GetXULPadding
(
nsMargin
&
aPadding
)
final
;
bool
GetBorderRadii
(
const
nsSize
&
aFrameSize
const
nsSize
&
aBorderArea
Sides
aSkipSides
nscoord
aRadii
[
8
]
)
const
final
{
return
mHelper
.
GetBorderRadii
(
aFrameSize
aBorderArea
aSkipSides
aRadii
)
;
}
nsresult
XULLayout
(
nsBoxLayoutState
&
aState
)
;
void
LayoutScrollArea
(
nsBoxLayoutState
&
aState
const
nsPoint
&
aScrollPosition
)
;
bool
AddRemoveScrollbar
(
nsBoxLayoutState
&
aState
bool
aOnRightOrBottom
bool
aHorizontal
bool
aAdd
)
;
bool
AddHorizontalScrollbar
(
nsBoxLayoutState
&
aState
bool
aOnBottom
)
;
bool
AddVerticalScrollbar
(
nsBoxLayoutState
&
aState
bool
aOnRight
)
;
void
RemoveHorizontalScrollbar
(
nsBoxLayoutState
&
aState
bool
aOnBottom
)
;
void
RemoveVerticalScrollbar
(
nsBoxLayoutState
&
aState
bool
aOnRight
)
;
static
void
AdjustReflowInputForPrintPreview
(
nsBoxLayoutState
&
aState
bool
&
aSetBack
)
;
static
void
AdjustReflowInputBack
(
nsBoxLayoutState
&
aState
bool
aSetBack
)
;
nsIFrame
*
GetScrolledFrame
(
)
const
final
{
return
mHelper
.
GetScrolledFrame
(
)
;
}
mozilla
:
:
ScrollStyles
GetScrollStyles
(
)
const
final
{
return
mHelper
.
GetScrollStylesFromFrame
(
)
;
}
bool
IsForTextControlWithNoScrollbars
(
)
const
final
{
return
mHelper
.
IsForTextControlWithNoScrollbars
(
)
;
}
bool
HasAllNeededScrollbars
(
)
const
final
{
return
mHelper
.
HasAllNeededScrollbars
(
)
;
}
mozilla
:
:
layers
:
:
OverscrollBehaviorInfo
GetOverscrollBehaviorInfo
(
)
const
final
{
return
mHelper
.
GetOverscrollBehaviorInfo
(
)
;
}
mozilla
:
:
layers
:
:
ScrollDirections
GetAvailableScrollingDirectionsForUserInputEvents
(
)
const
final
{
return
mHelper
.
GetAvailableScrollingDirectionsForUserInputEvents
(
)
;
}
mozilla
:
:
layers
:
:
ScrollDirections
GetScrollbarVisibility
(
)
const
final
{
return
mHelper
.
GetScrollbarVisibility
(
)
;
}
nsMargin
GetActualScrollbarSizes
(
nsIScrollableFrame
:
:
ScrollbarSizesOptions
aOptions
=
nsIScrollableFrame
:
:
ScrollbarSizesOptions
:
:
NONE
)
const
final
{
return
mHelper
.
GetActualScrollbarSizes
(
aOptions
)
;
}
nsMargin
GetDesiredScrollbarSizes
(
nsBoxLayoutState
*
aState
)
final
{
return
mHelper
.
GetDesiredScrollbarSizes
(
aState
)
;
}
nsMargin
GetDesiredScrollbarSizes
(
nsPresContext
*
aPresContext
gfxContext
*
aRC
)
final
{
nsBoxLayoutState
bls
(
aPresContext
aRC
0
)
;
return
GetDesiredScrollbarSizes
(
&
bls
)
;
}
nsSize
GetLayoutSize
(
)
const
final
{
return
mHelper
.
GetLayoutSize
(
)
;
}
nsRect
GetScrolledRect
(
)
const
final
{
return
mHelper
.
GetScrolledRect
(
)
;
}
nsRect
GetScrollPortRect
(
)
const
final
{
return
mHelper
.
GetScrollPortRect
(
)
;
}
nsPoint
GetScrollPosition
(
)
const
final
{
return
mHelper
.
GetScrollPosition
(
)
;
}
nsPoint
GetLogicalScrollPosition
(
)
const
final
{
return
mHelper
.
GetLogicalScrollPosition
(
)
;
}
nsRect
GetScrollRange
(
)
const
final
{
return
mHelper
.
GetLayoutScrollRange
(
)
;
}
nsSize
GetVisualViewportSize
(
)
const
final
{
return
mHelper
.
GetVisualViewportSize
(
)
;
}
nsPoint
GetVisualViewportOffset
(
)
const
final
{
return
mHelper
.
GetVisualViewportOffset
(
)
;
}
bool
SetVisualViewportOffset
(
const
nsPoint
&
aOffset
bool
aRepaint
)
final
{
return
mHelper
.
SetVisualViewportOffset
(
aOffset
aRepaint
)
;
}
nsRect
GetVisualScrollRange
(
)
const
final
{
return
mHelper
.
GetVisualScrollRange
(
)
;
}
nsRect
GetScrollRangeForUserInputEvents
(
)
const
final
{
return
mHelper
.
GetScrollRangeForUserInputEvents
(
)
;
}
nsSize
GetLineScrollAmount
(
)
const
final
{
return
mHelper
.
GetLineScrollAmount
(
)
;
}
nsSize
GetPageScrollAmount
(
)
const
final
{
return
mHelper
.
GetPageScrollAmount
(
)
;
}
nsMargin
GetScrollPadding
(
)
const
final
{
return
mHelper
.
GetScrollPadding
(
)
;
}
void
ScrollTo
(
nsPoint
aScrollPosition
ScrollMode
aMode
const
nsRect
*
aRange
=
nullptr
mozilla
:
:
ScrollSnapFlags
aSnapFlags
=
mozilla
:
:
ScrollSnapFlags
:
:
Disabled
mozilla
:
:
ScrollTriggeredByScript
aTriggeredByScript
=
mozilla
:
:
ScrollTriggeredByScript
:
:
No
)
final
{
mHelper
.
ScrollTo
(
aScrollPosition
aMode
ScrollOrigin
:
:
Other
aRange
aSnapFlags
)
;
}
void
ScrollToCSSPixels
(
const
CSSIntPoint
&
aScrollPosition
ScrollMode
aMode
=
ScrollMode
:
:
Instant
)
final
{
mHelper
.
ScrollToCSSPixels
(
aScrollPosition
aMode
)
;
}
void
ScrollToCSSPixelsForApz
(
const
mozilla
:
:
CSSPoint
&
aScrollPosition
mozilla
:
:
ScrollSnapTargetIds
&
&
aLastSnapTargetIds
)
final
{
mHelper
.
ScrollToCSSPixelsForApz
(
aScrollPosition
std
:
:
move
(
aLastSnapTargetIds
)
)
;
}
CSSIntPoint
GetScrollPositionCSSPixels
(
)
final
{
return
mHelper
.
GetScrollPositionCSSPixels
(
)
;
}
void
ScrollBy
(
nsIntPoint
aDelta
mozilla
:
:
ScrollUnit
aUnit
ScrollMode
aMode
nsIntPoint
*
aOverflow
ScrollOrigin
aOrigin
=
ScrollOrigin
:
:
NotSpecified
nsIScrollableFrame
:
:
ScrollMomentum
aMomentum
=
nsIScrollableFrame
:
:
NOT_MOMENTUM
mozilla
:
:
ScrollSnapFlags
aSnapFlags
=
mozilla
:
:
ScrollSnapFlags
:
:
Disabled
)
final
{
mHelper
.
ScrollBy
(
aDelta
aUnit
aMode
aOverflow
aOrigin
aMomentum
aSnapFlags
)
;
}
void
ScrollByCSSPixels
(
const
CSSIntPoint
&
aDelta
ScrollMode
aMode
=
ScrollMode
:
:
Instant
)
final
{
mHelper
.
ScrollByCSSPixels
(
aDelta
aMode
)
;
}
void
ScrollSnap
(
)
final
{
mHelper
.
ScrollSnap
(
)
;
}
void
ScrollToRestoredPosition
(
)
final
{
mHelper
.
ScrollToRestoredPosition
(
)
;
}
void
AddScrollPositionListener
(
nsIScrollPositionListener
*
aListener
)
final
{
mHelper
.
AddScrollPositionListener
(
aListener
)
;
}
void
RemoveScrollPositionListener
(
nsIScrollPositionListener
*
aListener
)
final
{
mHelper
.
RemoveScrollPositionListener
(
aListener
)
;
}
void
CurPosAttributeChanged
(
nsIContent
*
aChild
)
final
{
mHelper
.
CurPosAttributeChanged
(
aChild
)
;
}
NS_IMETHOD
PostScrolledAreaEventForCurrentArea
(
)
final
{
mHelper
.
PostScrolledAreaEvent
(
)
;
return
NS_OK
;
}
bool
IsScrollingActive
(
)
final
{
return
mHelper
.
IsScrollingActive
(
)
;
}
bool
IsMaybeAsynchronouslyScrolled
(
)
final
{
return
mHelper
.
IsMaybeAsynchronouslyScrolled
(
)
;
}
bool
DidHistoryRestore
(
)
const
final
{
return
mHelper
.
mDidHistoryRestore
;
}
void
ClearDidHistoryRestore
(
)
final
{
mHelper
.
mDidHistoryRestore
=
false
;
}
void
MarkEverScrolled
(
)
final
{
mHelper
.
MarkEverScrolled
(
)
;
}
bool
IsRectNearlyVisible
(
const
nsRect
&
aRect
)
final
{
return
mHelper
.
IsRectNearlyVisible
(
aRect
)
;
}
nsRect
ExpandRectToNearlyVisible
(
const
nsRect
&
aRect
)
const
final
{
return
mHelper
.
ExpandRectToNearlyVisible
(
aRect
)
;
}
ScrollOrigin
LastScrollOrigin
(
)
final
{
return
mHelper
.
LastScrollOrigin
(
)
;
}
using
AnimationState
=
nsIScrollableFrame
:
:
AnimationState
;
mozilla
:
:
EnumSet
<
AnimationState
>
ScrollAnimationState
(
)
const
final
{
return
mHelper
.
ScrollAnimationState
(
)
;
}
mozilla
:
:
MainThreadScrollGeneration
CurrentScrollGeneration
(
)
const
final
{
return
mHelper
.
CurrentScrollGeneration
(
)
;
}
mozilla
:
:
APZScrollGeneration
ScrollGenerationOnApz
(
)
const
final
{
return
mHelper
.
ScrollGenerationOnApz
(
)
;
}
nsPoint
LastScrollDestination
(
)
final
{
return
mHelper
.
LastScrollDestination
(
)
;
}
nsTArray
<
mozilla
:
:
ScrollPositionUpdate
>
GetScrollUpdates
(
)
const
final
{
return
mHelper
.
GetScrollUpdates
(
)
;
}
bool
HasScrollUpdates
(
)
const
final
{
return
mHelper
.
HasScrollUpdates
(
)
;
}
void
ResetScrollInfoIfNeeded
(
const
mozilla
:
:
MainThreadScrollGeneration
&
aGeneration
const
mozilla
:
:
APZScrollGeneration
&
aGenerationOnApz
mozilla
:
:
APZScrollAnimationType
aAPZScrollAnimationType
InScrollingGesture
aInScrollingGesture
)
final
{
mHelper
.
ResetScrollInfoIfNeeded
(
aGeneration
aGenerationOnApz
aAPZScrollAnimationType
aInScrollingGesture
)
;
}
bool
WantAsyncScroll
(
)
const
final
{
return
mHelper
.
WantAsyncScroll
(
)
;
}
mozilla
:
:
Maybe
<
mozilla
:
:
layers
:
:
ScrollMetadata
>
ComputeScrollMetadata
(
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aLayerManager
const
nsIFrame
*
aItemFrame
const
nsPoint
&
aOffsetToReferenceFrame
)
const
final
{
return
mHelper
.
ComputeScrollMetadata
(
aLayerManager
aItemFrame
aOffsetToReferenceFrame
)
;
}
void
MarkScrollbarsDirtyForReflow
(
)
const
final
{
mHelper
.
MarkScrollbarsDirtyForReflow
(
)
;
}
void
InvalidateScrollbars
(
)
const
final
{
mHelper
.
InvalidateScrollbars
(
)
;
}
void
UpdateScrollbarPosition
(
)
final
{
mHelper
.
UpdateScrollbarPosition
(
)
;
}
mozilla
:
:
UniquePtr
<
mozilla
:
:
PresState
>
SaveState
(
)
final
{
return
mHelper
.
SaveState
(
)
;
}
NS_IMETHOD
RestoreState
(
mozilla
:
:
PresState
*
aState
)
final
{
NS_ENSURE_ARG_POINTER
(
aState
)
;
mHelper
.
RestoreState
(
aState
)
;
return
NS_OK
;
}
bool
IsFrameOfType
(
uint32_t
aFlags
)
const
final
{
if
(
aFlags
&
(
nsIFrame
:
:
eReplacedContainsBlock
|
nsIFrame
:
:
eReplaced
)
)
return
false
;
return
nsBoxFrame
:
:
IsFrameOfType
(
aFlags
)
;
}
void
ScrollByPage
(
nsScrollbarFrame
*
aScrollbar
int32_t
aDirection
mozilla
:
:
ScrollSnapFlags
aSnapFlags
=
mozilla
:
:
ScrollSnapFlags
:
:
Disabled
)
final
{
mHelper
.
ScrollByPage
(
aScrollbar
aDirection
aSnapFlags
)
;
}
void
ScrollByWhole
(
nsScrollbarFrame
*
aScrollbar
int32_t
aDirection
mozilla
:
:
ScrollSnapFlags
aSnapFlags
=
mozilla
:
:
ScrollSnapFlags
:
:
Disabled
)
final
{
mHelper
.
ScrollByWhole
(
aScrollbar
aDirection
aSnapFlags
)
;
}
void
ScrollByLine
(
nsScrollbarFrame
*
aScrollbar
int32_t
aDirection
mozilla
:
:
ScrollSnapFlags
aSnapFlags
=
mozilla
:
:
ScrollSnapFlags
:
:
Disabled
)
final
{
mHelper
.
ScrollByLine
(
aScrollbar
aDirection
aSnapFlags
)
;
}
void
ScrollByUnit
(
nsScrollbarFrame
*
aScrollbar
ScrollMode
aMode
int32_t
aDirection
mozilla
:
:
ScrollUnit
aUnit
mozilla
:
:
ScrollSnapFlags
aSnapFlags
=
mozilla
:
:
ScrollSnapFlags
:
:
Disabled
)
final
{
mHelper
.
ScrollByUnit
(
aScrollbar
aMode
aDirection
aUnit
aSnapFlags
)
;
}
void
RepeatButtonScroll
(
nsScrollbarFrame
*
aScrollbar
)
final
{
mHelper
.
RepeatButtonScroll
(
aScrollbar
)
;
}
void
ThumbMoved
(
nsScrollbarFrame
*
aScrollbar
nscoord
aOldPos
nscoord
aNewPos
)
final
{
mHelper
.
ThumbMoved
(
aScrollbar
aOldPos
aNewPos
)
;
}
void
ScrollbarReleased
(
nsScrollbarFrame
*
aScrollbar
)
final
{
mHelper
.
ScrollbarReleased
(
aScrollbar
)
;
}
void
VisibilityChanged
(
bool
aVisible
)
final
{
}
nsIFrame
*
GetScrollbarBox
(
bool
aVertical
)
final
{
return
mHelper
.
GetScrollbarBox
(
aVertical
)
;
}
void
ScrollbarActivityStarted
(
)
const
final
;
void
ScrollbarActivityStopped
(
)
const
final
;
bool
IsScrollbarOnRight
(
)
const
final
{
return
mHelper
.
IsScrollbarOnRight
(
)
;
}
bool
ShouldSuppressScrollbarRepaints
(
)
const
final
{
return
mHelper
.
ShouldSuppressScrollbarRepaints
(
)
;
}
void
SetTransformingByAPZ
(
bool
aTransforming
)
final
{
mHelper
.
SetTransformingByAPZ
(
aTransforming
)
;
}
bool
IsTransformingByAPZ
(
)
const
final
{
return
mHelper
.
IsTransformingByAPZ
(
)
;
}
void
SetScrollableByAPZ
(
bool
aScrollable
)
final
{
mHelper
.
SetScrollableByAPZ
(
aScrollable
)
;
}
void
SetZoomableByAPZ
(
bool
aZoomable
)
final
{
mHelper
.
SetZoomableByAPZ
(
aZoomable
)
;
}
void
SetHasOutOfFlowContentInsideFilter
(
)
final
{
mHelper
.
SetHasOutOfFlowContentInsideFilter
(
)
;
}
bool
DecideScrollableLayer
(
nsDisplayListBuilder
*
aBuilder
nsRect
*
aVisibleRect
nsRect
*
aDirtyRect
bool
aSetBase
)
final
{
return
mHelper
.
DecideScrollableLayer
(
aBuilder
aVisibleRect
aDirtyRect
aSetBase
)
;
}
void
NotifyApzTransaction
(
)
final
{
mHelper
.
NotifyApzTransaction
(
)
;
}
void
NotifyApproximateFrameVisibilityUpdate
(
bool
aIgnoreDisplayPort
)
final
{
mHelper
.
NotifyApproximateFrameVisibilityUpdate
(
aIgnoreDisplayPort
)
;
}
bool
GetDisplayPortAtLastApproximateFrameVisibilityUpdate
(
nsRect
*
aDisplayPort
)
final
{
return
mHelper
.
GetDisplayPortAtLastApproximateFrameVisibilityUpdate
(
aDisplayPort
)
;
}
void
TriggerDisplayPortExpiration
(
)
final
{
mHelper
.
TriggerDisplayPortExpiration
(
)
;
}
ScrollSnapInfo
GetScrollSnapInfo
(
)
final
{
return
mHelper
.
GetScrollSnapInfo
(
)
;
}
void
TryResnap
(
)
final
{
mHelper
.
TryResnap
(
)
;
}
void
PostPendingResnapIfNeeded
(
const
nsIFrame
*
aFrame
)
final
{
mHelper
.
PostPendingResnapIfNeeded
(
aFrame
)
;
}
void
PostPendingResnap
(
)
final
{
mHelper
.
PostPendingResnap
(
)
;
}
bool
DragScroll
(
mozilla
:
:
WidgetEvent
*
aEvent
)
final
{
return
mHelper
.
DragScroll
(
aEvent
)
;
}
void
AsyncScrollbarDragInitiated
(
uint64_t
aDragBlockId
mozilla
:
:
layers
:
:
ScrollDirection
aDirection
)
final
{
return
mHelper
.
AsyncScrollbarDragInitiated
(
aDragBlockId
aDirection
)
;
}
void
AsyncScrollbarDragRejected
(
)
final
{
return
mHelper
.
AsyncScrollbarDragRejected
(
)
;
}
bool
IsRootScrollFrameOfDocument
(
)
const
final
{
return
mHelper
.
IsRootScrollFrameOfDocument
(
)
;
}
const
ScrollAnchorContainer
*
Anchor
(
)
const
final
{
return
&
mHelper
.
mAnchor
;
}
ScrollAnchorContainer
*
Anchor
(
)
final
{
return
&
mHelper
.
mAnchor
;
}
void
AppendDirectlyOwnedAnonBoxes
(
nsTArray
<
OwnedAnonBox
>
&
aResult
)
final
{
aResult
.
AppendElement
(
OwnedAnonBox
(
mHelper
.
GetScrolledFrame
(
)
)
)
;
}
bool
SmoothScrollVisual
(
const
nsPoint
&
aVisualViewportOffset
mozilla
:
:
layers
:
:
FrameMetrics
:
:
ScrollOffsetUpdateType
aUpdateType
)
final
{
return
mHelper
.
SmoothScrollVisual
(
aVisualViewportOffset
aUpdateType
)
;
}
bool
IsSmoothScroll
(
mozilla
:
:
dom
:
:
ScrollBehavior
aBehavior
)
const
final
{
return
mHelper
.
IsSmoothScroll
(
aBehavior
)
;
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
GetFrameName
(
nsAString
&
aResult
)
const
final
;
#
endif
protected
:
nsXULScrollFrame
(
ComputedStyle
*
nsPresContext
*
bool
aIsRoot
)
;
void
ClampAndSetBounds
(
nsBoxLayoutState
&
aState
nsRect
&
aRect
nsPoint
aScrollPosition
bool
aRemoveOverflowAreas
=
false
)
{
if
(
!
mHelper
.
IsPhysicalLTR
(
)
)
{
aRect
.
x
=
mHelper
.
ScrollPort
(
)
.
XMost
(
)
-
aScrollPosition
.
x
-
aRect
.
width
;
}
mHelper
.
mScrolledFrame
-
>
SetXULBounds
(
aState
aRect
aRemoveOverflowAreas
)
;
}
private
:
friend
class
mozilla
:
:
ScrollFrameHelper
;
ScrollFrameHelper
mHelper
;
}
;
#
endif
