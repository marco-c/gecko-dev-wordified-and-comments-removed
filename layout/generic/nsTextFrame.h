#
ifndef
nsTextFrame_h__
#
define
nsTextFrame_h__
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsFrame
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
nsGenericDOMDataNode
.
h
"
#
include
"
nsSplittableFrame
.
h
"
#
include
"
nsLineBox
.
h
"
#
include
"
gfxSkipChars
.
h
"
#
include
"
gfxTextRun
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
JustificationUtils
.
h
"
#
include
"
RubyUtils
.
h
"
#
include
"
TextDrawTarget
.
h
"
#
if
defined
(
XP_WIN
)
&
&
defined
(
DrawText
)
#
undef
DrawText
#
endif
class
nsTextPaintStyle
;
class
PropertyProvider
;
struct
SelectionDetails
;
class
nsTextFragment
;
class
nsDisplayTextGeometry
;
class
nsDisplayText
;
namespace
mozilla
{
class
SVGContextPaint
;
}
;
class
nsTextFrame
:
public
nsFrame
{
typedef
mozilla
:
:
LayoutDeviceRect
LayoutDeviceRect
;
typedef
mozilla
:
:
RawSelectionType
RawSelectionType
;
typedef
mozilla
:
:
SelectionType
SelectionType
;
typedef
mozilla
:
:
TextRangeStyle
TextRangeStyle
;
typedef
mozilla
:
:
gfx
:
:
DrawTarget
DrawTarget
;
typedef
mozilla
:
:
gfx
:
:
Point
Point
;
typedef
mozilla
:
:
gfx
:
:
Rect
Rect
;
typedef
mozilla
:
:
gfx
:
:
Size
Size
;
typedef
mozilla
:
:
layout
:
:
TextDrawTarget
TextDrawTarget
;
typedef
gfxTextRun
:
:
Range
Range
;
public
:
explicit
nsTextFrame
(
nsStyleContext
*
aContext
ClassID
aID
=
kClassID
)
:
nsFrame
(
aContext
aID
)
mNextContinuation
(
nullptr
)
mContentOffset
(
0
)
mContentLengthHint
(
0
)
mAscent
(
0
)
{
}
NS_DECL_FRAMEARENA_HELPERS
(
nsTextFrame
)
friend
class
nsContinuingTextFrame
;
friend
class
nsDisplayTextGeometry
;
friend
class
nsDisplayText
;
NS_DECL_QUERYFRAME
void
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
override
;
void
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
override
;
void
DestroyFrom
(
nsIFrame
*
aDestructRoot
)
override
;
nsresult
GetCursor
(
const
nsPoint
&
aPoint
nsIFrame
:
:
Cursor
&
aCursor
)
override
;
nsresult
CharacterDataChanged
(
CharacterDataChangeInfo
*
aInfo
)
final
;
nsTextFrame
*
GetPrevContinuation
(
)
const
override
{
return
nullptr
;
}
nsTextFrame
*
GetNextContinuation
(
)
const
final
{
return
mNextContinuation
;
}
void
SetNextContinuation
(
nsIFrame
*
aNextContinuation
)
final
{
NS_ASSERTION
(
!
aNextContinuation
|
|
Type
(
)
=
=
aNextContinuation
-
>
Type
(
)
"
setting
a
next
continuation
with
incorrect
type
!
"
)
;
NS_ASSERTION
(
!
nsSplittableFrame
:
:
IsInNextContinuationChain
(
aNextContinuation
this
)
"
creating
a
loop
in
continuation
chain
!
"
)
;
mNextContinuation
=
static_cast
<
nsTextFrame
*
>
(
aNextContinuation
)
;
if
(
aNextContinuation
)
aNextContinuation
-
>
RemoveStateBits
(
NS_FRAME_IS_FLUID_CONTINUATION
)
;
if
(
GetContent
(
)
-
>
HasFlag
(
NS_HAS_FLOWLENGTH_PROPERTY
)
)
{
GetContent
(
)
-
>
DeleteProperty
(
nsGkAtoms
:
:
flowlength
)
;
GetContent
(
)
-
>
UnsetFlags
(
NS_HAS_FLOWLENGTH_PROPERTY
)
;
}
}
nsIFrame
*
GetNextInFlowVirtual
(
)
const
override
{
return
GetNextInFlow
(
)
;
}
nsTextFrame
*
GetNextInFlow
(
)
const
{
return
mNextContinuation
&
&
(
mNextContinuation
-
>
GetStateBits
(
)
&
NS_FRAME_IS_FLUID_CONTINUATION
)
?
mNextContinuation
:
nullptr
;
}
void
SetNextInFlow
(
nsIFrame
*
aNextInFlow
)
final
{
NS_ASSERTION
(
!
aNextInFlow
|
|
Type
(
)
=
=
aNextInFlow
-
>
Type
(
)
"
setting
a
next
in
flow
with
incorrect
type
!
"
)
;
NS_ASSERTION
(
!
nsSplittableFrame
:
:
IsInNextContinuationChain
(
aNextInFlow
this
)
"
creating
a
loop
in
continuation
chain
!
"
)
;
mNextContinuation
=
static_cast
<
nsTextFrame
*
>
(
aNextInFlow
)
;
if
(
mNextContinuation
&
&
!
mNextContinuation
-
>
HasAnyStateBits
(
NS_FRAME_IS_FLUID_CONTINUATION
)
)
{
if
(
GetContent
(
)
-
>
HasFlag
(
NS_HAS_FLOWLENGTH_PROPERTY
)
)
{
GetContent
(
)
-
>
DeleteProperty
(
nsGkAtoms
:
:
flowlength
)
;
GetContent
(
)
-
>
UnsetFlags
(
NS_HAS_FLOWLENGTH_PROPERTY
)
;
}
}
if
(
aNextInFlow
)
{
aNextInFlow
-
>
AddStateBits
(
NS_FRAME_IS_FLUID_CONTINUATION
)
;
}
}
nsTextFrame
*
LastInFlow
(
)
const
final
;
nsTextFrame
*
LastContinuation
(
)
const
final
;
nsSplittableType
GetSplittableType
(
)
const
final
{
return
NS_FRAME_SPLITTABLE
;
}
bool
IsFrameOfType
(
uint32_t
aFlags
)
const
final
{
return
nsFrame
:
:
IsFrameOfType
(
aFlags
&
~
(
nsIFrame
:
:
eReplaced
|
nsIFrame
:
:
eLineParticipant
)
)
;
}
bool
ShouldSuppressLineBreak
(
)
const
{
if
(
mozilla
:
:
RubyUtils
:
:
IsRubyContentBox
(
GetParent
(
)
-
>
Type
(
)
)
)
{
return
true
;
}
return
StyleContext
(
)
-
>
ShouldSuppressLineBreak
(
)
;
}
void
InvalidateFrame
(
uint32_t
aDisplayItemKey
=
0
)
override
;
void
InvalidateFrameWithRect
(
const
nsRect
&
aRect
uint32_t
aDisplayItemKey
=
0
)
override
;
#
ifdef
DEBUG_FRAME_DUMP
void
List
(
FILE
*
out
=
stderr
const
char
*
aPrefix
=
"
"
uint32_t
aFlags
=
0
)
const
override
;
nsresult
GetFrameName
(
nsAString
&
aResult
)
const
override
;
void
ToCString
(
nsCString
&
aBuf
int32_t
*
aTotalContentLength
)
const
;
#
endif
#
ifdef
DEBUG
nsFrameState
GetDebugStateBits
(
)
const
override
;
#
endif
ContentOffsets
CalcContentOffsetsFromFramePoint
(
nsPoint
aPoint
)
override
;
ContentOffsets
GetCharacterOffsetAtFramePoint
(
const
nsPoint
&
aPoint
)
;
void
SetSelectedRange
(
uint32_t
aStart
uint32_t
aEnd
bool
aSelected
SelectionType
aSelectionType
)
;
FrameSearchResult
PeekOffsetNoAmount
(
bool
aForward
int32_t
*
aOffset
)
override
;
FrameSearchResult
PeekOffsetCharacter
(
bool
aForward
int32_t
*
aOffset
PeekOffsetCharacterOptions
aOptions
=
PeekOffsetCharacterOptions
(
)
)
override
;
FrameSearchResult
PeekOffsetWord
(
bool
aForward
bool
aWordSelectEatSpace
bool
aIsKeyboardSelect
int32_t
*
aOffset
PeekWordState
*
aState
)
override
;
nsresult
CheckVisibility
(
nsPresContext
*
aContext
int32_t
aStartIndex
int32_t
aEndIndex
bool
aRecurse
bool
*
aFinished
bool
*
_retval
)
override
;
enum
{
ALLOW_FRAME_CREATION_AND_DESTRUCTION
=
0x01
}
;
void
SetLength
(
int32_t
aLength
nsLineLayout
*
aLineLayout
uint32_t
aSetLengthFlags
=
0
)
;
nsresult
GetOffsets
(
int32_t
&
start
int32_t
&
end
)
const
override
;
void
AdjustOffsetsForBidi
(
int32_t
start
int32_t
end
)
override
;
nsresult
GetPointFromOffset
(
int32_t
inOffset
nsPoint
*
outPoint
)
override
;
nsresult
GetCharacterRectsInRange
(
int32_t
aInOffset
int32_t
aLength
nsTArray
<
nsRect
>
&
aRects
)
override
;
nsresult
GetChildFrameContainingOffset
(
int32_t
inContentOffset
bool
inHint
int32_t
*
outFrameContentOffset
nsIFrame
*
*
outChildFrame
)
override
;
bool
IsVisibleInSelection
(
nsISelection
*
aSelection
)
override
;
bool
IsEmpty
(
)
override
;
bool
IsSelfEmpty
(
)
override
{
return
IsEmpty
(
)
;
}
nscoord
GetLogicalBaseline
(
mozilla
:
:
WritingMode
aWritingMode
)
const
final
;
bool
HasSignificantTerminalNewline
(
)
const
override
;
bool
IsAtEndOfLine
(
)
const
;
bool
HasNoncollapsedCharacters
(
)
const
{
return
(
GetStateBits
(
)
&
TEXT_HAS_NONCOLLAPSED_CHARACTERS
)
!
=
0
;
}
#
ifdef
ACCESSIBILITY
mozilla
:
:
a11y
:
:
AccType
AccessibleType
(
)
override
;
#
endif
float
GetFontSizeInflation
(
)
const
;
bool
IsCurrentFontInflation
(
float
aInflation
)
const
;
bool
HasFontSizeInflation
(
)
const
{
return
(
GetStateBits
(
)
&
TEXT_HAS_FONT_INFLATION
)
!
=
0
;
}
void
SetFontSizeInflation
(
float
aInflation
)
;
void
MarkIntrinsicISizesDirty
(
)
override
;
nscoord
GetMinISize
(
gfxContext
*
aRenderingContext
)
override
;
nscoord
GetPrefISize
(
gfxContext
*
aRenderingContext
)
override
;
void
AddInlineMinISize
(
gfxContext
*
aRenderingContext
InlineMinISizeData
*
aData
)
override
;
void
AddInlinePrefISize
(
gfxContext
*
aRenderingContext
InlinePrefISizeData
*
aData
)
override
;
mozilla
:
:
LogicalSize
ComputeSize
(
gfxContext
*
aRenderingContext
mozilla
:
:
WritingMode
aWritingMode
const
mozilla
:
:
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
mozilla
:
:
LogicalSize
&
aMargin
const
mozilla
:
:
LogicalSize
&
aBorder
const
mozilla
:
:
LogicalSize
&
aPadding
ComputeSizeFlags
aFlags
)
override
;
nsRect
ComputeTightBounds
(
DrawTarget
*
aDrawTarget
)
const
override
;
nsresult
GetPrefWidthTightBounds
(
gfxContext
*
aContext
nscoord
*
aX
nscoord
*
aXMost
)
override
;
void
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aMetrics
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
override
;
bool
CanContinueTextRun
(
)
const
override
;
struct
TrimOutput
{
bool
mChanged
;
nscoord
mDeltaWidth
;
}
;
TrimOutput
TrimTrailingWhiteSpace
(
DrawTarget
*
aDrawTarget
)
;
RenderedText
GetRenderedText
(
uint32_t
aStartOffset
=
0
uint32_t
aEndOffset
=
UINT32_MAX
TextOffsetType
aOffsetType
=
TextOffsetType
:
:
OFFSETS_IN_CONTENT_TEXT
TrailingWhitespace
aTrimTrailingWhitespace
=
TrailingWhitespace
:
:
TRIM_TRAILING_WHITESPACE
)
override
;
nsOverflowAreas
RecomputeOverflow
(
nsIFrame
*
aBlockFrame
)
;
enum
TextRunType
{
eInflated
eNotInflated
}
;
void
AddInlineMinISizeForFlow
(
gfxContext
*
aRenderingContext
nsIFrame
:
:
InlineMinISizeData
*
aData
TextRunType
aTextRunType
)
;
void
AddInlinePrefISizeForFlow
(
gfxContext
*
aRenderingContext
InlinePrefISizeData
*
aData
TextRunType
aTextRunType
)
;
bool
MeasureCharClippedText
(
nscoord
aVisIStartEdge
nscoord
aVisIEndEdge
nscoord
*
aSnappedStartEdge
nscoord
*
aSnappedEndEdge
)
;
bool
MeasureCharClippedText
(
PropertyProvider
&
aProvider
nscoord
aVisIStartEdge
nscoord
aVisIEndEdge
uint32_t
*
aStartOffset
uint32_t
*
aMaxLength
nscoord
*
aSnappedStartEdge
nscoord
*
aSnappedEndEdge
)
;
struct
DrawPathCallbacks
:
gfxTextRunDrawCallbacks
{
explicit
DrawPathCallbacks
(
bool
aShouldPaintSVGGlyphs
=
false
)
:
gfxTextRunDrawCallbacks
(
aShouldPaintSVGGlyphs
)
{
}
virtual
void
NotifySelectionBackgroundNeedsFill
(
const
Rect
&
aBackgroundRect
nscolor
aColor
DrawTarget
&
aDrawTarget
)
{
}
virtual
void
PaintDecorationLine
(
Rect
aPath
nscolor
aColor
)
{
}
virtual
void
PaintSelectionDecorationLine
(
Rect
aPath
nscolor
aColor
)
{
}
virtual
void
NotifyBeforeText
(
nscolor
aColor
)
{
}
virtual
void
NotifyAfterText
(
)
{
}
virtual
void
NotifyBeforeSelectionDecorationLine
(
nscolor
aColor
)
{
}
virtual
void
NotifySelectionDecorationLinePathEmitted
(
)
{
}
}
;
struct
PaintTextParams
{
gfxContext
*
context
;
TextDrawTarget
*
textDrawer
;
gfxPoint
framePt
;
LayoutDeviceRect
dirtyRect
;
mozilla
:
:
SVGContextPaint
*
contextPaint
=
nullptr
;
DrawPathCallbacks
*
callbacks
=
nullptr
;
enum
{
PaintText
PaintTextBGColor
GenerateTextMask
}
;
uint8_t
state
=
PaintText
;
explicit
PaintTextParams
(
gfxContext
*
aContext
)
:
context
(
aContext
)
textDrawer
(
nullptr
)
{
}
bool
IsPaintText
(
)
const
{
return
state
=
=
PaintText
;
}
bool
IsGenerateTextMask
(
)
const
{
return
state
=
=
GenerateTextMask
;
}
bool
IsPaintBGColor
(
)
const
{
return
state
=
=
PaintTextBGColor
;
}
}
;
struct
PaintTextSelectionParams
:
PaintTextParams
{
gfxPoint
textBaselinePt
;
PropertyProvider
*
provider
=
nullptr
;
Range
contentRange
;
nsTextPaintStyle
*
textPaintStyle
=
nullptr
;
explicit
PaintTextSelectionParams
(
const
PaintTextParams
&
aParams
)
:
PaintTextParams
(
aParams
)
{
}
}
;
struct
DrawTextRunParams
{
gfxContext
*
context
;
TextDrawTarget
*
textDrawer
;
PropertyProvider
*
provider
=
nullptr
;
gfxFloat
*
advanceWidth
=
nullptr
;
mozilla
:
:
SVGContextPaint
*
contextPaint
=
nullptr
;
DrawPathCallbacks
*
callbacks
=
nullptr
;
nscolor
textColor
=
NS_RGBA
(
0
0
0
0
)
;
nscolor
textStrokeColor
=
NS_RGBA
(
0
0
0
0
)
;
float
textStrokeWidth
=
0
.
0f
;
bool
drawSoftHyphen
=
false
;
explicit
DrawTextRunParams
(
gfxContext
*
aContext
)
:
context
(
aContext
)
textDrawer
(
nullptr
)
{
}
}
;
struct
DrawTextParams
:
DrawTextRunParams
{
gfxPoint
framePt
;
LayoutDeviceRect
dirtyRect
;
const
nsTextPaintStyle
*
textStyle
=
nullptr
;
const
nsCharClipDisplayItem
:
:
ClipEdges
*
clipEdges
=
nullptr
;
const
nscolor
*
decorationOverrideColor
=
nullptr
;
explicit
DrawTextParams
(
gfxContext
*
aContext
)
:
DrawTextRunParams
(
aContext
)
{
}
}
;
void
PaintText
(
const
PaintTextParams
&
aParams
const
nsCharClipDisplayItem
&
aItem
float
aOpacity
=
1
.
0f
)
;
bool
PaintTextWithSelection
(
const
PaintTextSelectionParams
&
aParams
const
nsCharClipDisplayItem
:
:
ClipEdges
&
aClipEdges
)
;
bool
PaintTextWithSelectionColors
(
const
PaintTextSelectionParams
&
aParams
const
mozilla
:
:
UniquePtr
<
SelectionDetails
>
&
aDetails
RawSelectionType
*
aAllRawSelectionTypes
const
nsCharClipDisplayItem
:
:
ClipEdges
&
aClipEdges
)
;
void
PaintTextSelectionDecorations
(
const
PaintTextSelectionParams
&
aParams
const
mozilla
:
:
UniquePtr
<
SelectionDetails
>
&
aDetails
SelectionType
aSelectionType
)
;
void
DrawEmphasisMarks
(
gfxContext
*
aContext
mozilla
:
:
WritingMode
aWM
const
gfxPoint
&
aTextBaselinePt
const
gfxPoint
&
aFramePt
Range
aRange
const
nscolor
*
aDecorationOverrideColor
PropertyProvider
*
aProvider
)
;
nscolor
GetCaretColorAt
(
int32_t
aOffset
)
override
;
int16_t
GetSelectionStatus
(
int16_t
*
aSelectionFlags
)
;
int32_t
GetContentOffset
(
)
const
{
return
mContentOffset
;
}
int32_t
GetContentLength
(
)
const
{
NS_ASSERTION
(
GetContentEnd
(
)
-
mContentOffset
>
=
0
"
negative
length
"
)
;
return
GetContentEnd
(
)
-
mContentOffset
;
}
int32_t
GetContentEnd
(
)
const
;
int32_t
GetContentLengthHint
(
)
const
{
return
mContentLengthHint
;
}
int32_t
GetInFlowContentLength
(
)
;
gfxSkipCharsIterator
EnsureTextRun
(
TextRunType
aWhichTextRun
DrawTarget
*
aRefDrawTarget
=
nullptr
nsIFrame
*
aLineContainer
=
nullptr
const
nsLineList
:
:
iterator
*
aLine
=
nullptr
uint32_t
*
aFlowEndInTextRun
=
nullptr
)
;
gfxTextRun
*
GetTextRun
(
TextRunType
aWhichTextRun
)
{
if
(
aWhichTextRun
=
=
eInflated
|
|
!
HasFontSizeInflation
(
)
)
return
mTextRun
;
return
GetUninflatedTextRun
(
)
;
}
gfxTextRun
*
GetUninflatedTextRun
(
)
;
void
SetTextRun
(
gfxTextRun
*
aTextRun
TextRunType
aWhichTextRun
float
aInflation
)
;
bool
IsInTextRunUserData
(
)
const
{
return
GetStateBits
(
)
&
(
TEXT_IN_TEXTRUN_USER_DATA
|
TEXT_IN_UNINFLATED_TEXTRUN_USER_DATA
)
;
}
bool
RemoveTextRun
(
gfxTextRun
*
aTextRun
)
;
void
ClearTextRun
(
nsTextFrame
*
aStartContinuation
TextRunType
aWhichTextRun
)
;
void
ClearTextRuns
(
)
{
ClearTextRun
(
nullptr
nsTextFrame
:
:
eInflated
)
;
if
(
HasFontSizeInflation
(
)
)
{
ClearTextRun
(
nullptr
nsTextFrame
:
:
eNotInflated
)
;
}
}
void
DisconnectTextRuns
(
)
;
struct
TrimmedOffsets
{
int32_t
mStart
;
int32_t
mLength
;
int32_t
GetEnd
(
)
const
{
return
mStart
+
mLength
;
}
}
;
TrimmedOffsets
GetTrimmedOffsets
(
const
nsTextFragment
*
aFrag
bool
aTrimAfter
bool
aPostReflow
=
true
)
const
;
void
ReflowText
(
nsLineLayout
&
aLineLayout
nscoord
aAvailableWidth
DrawTarget
*
aDrawTarget
ReflowOutput
&
aMetrics
nsReflowStatus
&
aStatus
)
;
bool
IsFloatingFirstLetterChild
(
)
const
;
bool
IsInitialLetterChild
(
)
const
;
bool
ComputeCustomOverflow
(
nsOverflowAreas
&
aOverflowAreas
)
override
;
void
AssignJustificationGaps
(
const
mozilla
:
:
JustificationAssignment
&
aAssign
)
;
mozilla
:
:
JustificationAssignment
GetJustificationAssignment
(
)
const
;
uint32_t
CountGraphemeClusters
(
)
const
;
protected
:
virtual
~
nsTextFrame
(
)
;
RefPtr
<
gfxTextRun
>
mTextRun
;
nsTextFrame
*
mNextContinuation
;
int32_t
mContentOffset
;
int32_t
mContentLengthHint
;
nscoord
mAscent
;
bool
IsFrameSelected
(
)
const
override
;
mozilla
:
:
UniquePtr
<
SelectionDetails
>
GetSelectionDetails
(
)
;
void
UnionAdditionalOverflow
(
nsPresContext
*
aPresContext
nsIFrame
*
aBlock
PropertyProvider
&
aProvider
nsRect
*
aVisualOverflowRect
bool
aIncludeTextDecorations
)
;
nsRect
UpdateTextEmphasis
(
mozilla
:
:
WritingMode
aWM
PropertyProvider
&
aProvider
)
;
struct
PaintShadowParams
{
gfxTextRun
:
:
Range
range
;
LayoutDeviceRect
dirtyRect
;
gfxPoint
framePt
;
gfxPoint
textBaselinePt
;
gfxContext
*
context
;
TextDrawTarget
*
textDrawer
;
nscolor
foregroundColor
=
NS_RGBA
(
0
0
0
0
)
;
const
nsCharClipDisplayItem
:
:
ClipEdges
*
clipEdges
=
nullptr
;
PropertyProvider
*
provider
=
nullptr
;
nscoord
leftSideOffset
=
0
;
explicit
PaintShadowParams
(
const
PaintTextParams
&
aParams
)
:
dirtyRect
(
aParams
.
dirtyRect
)
framePt
(
aParams
.
framePt
)
context
(
aParams
.
context
)
textDrawer
(
aParams
.
textDrawer
)
{
}
}
;
void
PaintOneShadow
(
const
PaintShadowParams
&
aParams
nsCSSShadowItem
*
aShadowDetails
gfxRect
&
aBoundingBox
uint32_t
aBlurFlags
)
;
void
PaintShadows
(
nsCSSShadowArray
*
aShadow
const
PaintShadowParams
&
aParams
)
;
struct
LineDecoration
{
nsIFrame
*
mFrame
;
nscoord
mBaselineOffset
;
nscolor
mColor
;
uint8_t
mStyle
;
LineDecoration
(
nsIFrame
*
const
aFrame
const
nscoord
aOff
const
nscolor
aColor
const
uint8_t
aStyle
)
:
mFrame
(
aFrame
)
mBaselineOffset
(
aOff
)
mColor
(
aColor
)
mStyle
(
aStyle
)
{
}
LineDecoration
(
const
LineDecoration
&
aOther
)
:
mFrame
(
aOther
.
mFrame
)
mBaselineOffset
(
aOther
.
mBaselineOffset
)
mColor
(
aOther
.
mColor
)
mStyle
(
aOther
.
mStyle
)
{
}
bool
operator
=
=
(
const
LineDecoration
&
aOther
)
const
{
return
mFrame
=
=
aOther
.
mFrame
&
&
mStyle
=
=
aOther
.
mStyle
&
&
mColor
=
=
aOther
.
mColor
&
&
mBaselineOffset
=
=
aOther
.
mBaselineOffset
;
}
bool
operator
!
=
(
const
LineDecoration
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
}
;
struct
TextDecorations
{
AutoTArray
<
LineDecoration
1
>
mOverlines
mUnderlines
mStrikes
;
TextDecorations
(
)
{
}
bool
HasDecorationLines
(
)
const
{
return
HasUnderline
(
)
|
|
HasOverline
(
)
|
|
HasStrikeout
(
)
;
}
bool
HasUnderline
(
)
const
{
return
!
mUnderlines
.
IsEmpty
(
)
;
}
bool
HasOverline
(
)
const
{
return
!
mOverlines
.
IsEmpty
(
)
;
}
bool
HasStrikeout
(
)
const
{
return
!
mStrikes
.
IsEmpty
(
)
;
}
bool
operator
=
=
(
const
TextDecorations
&
aOther
)
const
{
return
mOverlines
=
=
aOther
.
mOverlines
&
&
mUnderlines
=
=
aOther
.
mUnderlines
&
&
mStrikes
=
=
aOther
.
mStrikes
;
}
bool
operator
!
=
(
const
TextDecorations
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
}
;
enum
TextDecorationColorResolution
{
eResolvedColors
eUnresolvedColors
}
;
void
GetTextDecorations
(
nsPresContext
*
aPresContext
TextDecorationColorResolution
aColorResolution
TextDecorations
&
aDecorations
)
;
void
DrawTextRun
(
Range
aRange
const
gfxPoint
&
aTextBaselinePt
const
DrawTextRunParams
&
aParams
)
;
void
DrawTextRunAndDecorations
(
Range
aRange
const
gfxPoint
&
aTextBaselinePt
const
DrawTextParams
&
aParams
const
TextDecorations
&
aDecorations
)
;
void
DrawText
(
Range
aRange
const
gfxPoint
&
aTextBaselinePt
const
DrawTextParams
&
aParams
)
;
bool
CombineSelectionUnderlineRect
(
nsPresContext
*
aPresContext
nsRect
&
aRect
)
;
void
DrawSelectionDecorations
(
gfxContext
*
aContext
const
LayoutDeviceRect
&
aDirtyRect
mozilla
:
:
SelectionType
aSelectionType
nsTextPaintStyle
&
aTextPaintStyle
const
TextRangeStyle
&
aRangeStyle
const
Point
&
aPt
gfxFloat
aICoordInFrame
gfxFloat
aWidth
gfxFloat
aAscent
const
gfxFont
:
:
Metrics
&
aFontMetrics
DrawPathCallbacks
*
aCallbacks
bool
aVertical
gfxFloat
aDecorationOffsetDir
uint8_t
aDecoration
)
;
struct
PaintDecorationLineParams
;
void
PaintDecorationLine
(
const
PaintDecorationLineParams
&
aParams
)
;
gfxFloat
ComputeDescentLimitForSelectionUnderline
(
nsPresContext
*
aPresContext
const
gfxFont
:
:
Metrics
&
aFontMetrics
)
;
static
bool
GetSelectionTextColors
(
SelectionType
aSelectionType
nsTextPaintStyle
&
aTextPaintStyle
const
TextRangeStyle
&
aRangeStyle
nscolor
*
aForeground
nscolor
*
aBackground
)
;
static
gfxFloat
ComputeSelectionUnderlineHeight
(
nsPresContext
*
aPresContext
const
gfxFont
:
:
Metrics
&
aFontMetrics
SelectionType
aSelectionType
)
;
ContentOffsets
GetCharacterOffsetAtFramePointInternal
(
nsPoint
aPoint
bool
aForInsertionPoint
)
;
void
ClearFrameOffsetCache
(
)
;
bool
HasAnyNoncollapsedCharacters
(
)
override
;
void
ClearMetrics
(
ReflowOutput
&
aMetrics
)
;
void
UpdateIteratorFromOffset
(
const
PropertyProvider
&
aProperties
int32_t
&
aInOffset
gfxSkipCharsIterator
&
aIter
)
;
nsPoint
GetPointFromIterator
(
const
gfxSkipCharsIterator
&
aIter
PropertyProvider
&
aProperties
)
;
}
;
#
endif
