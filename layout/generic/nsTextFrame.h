#
ifndef
nsTextFrame_h__
#
define
nsTextFrame_h__
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsSplittableFrame
.
h
"
#
include
"
gfxSkipChars
.
h
"
#
include
"
gfxTextRun
.
h
"
#
include
"
JustificationUtils
.
h
"
#
if
defined
(
XP_WIN
)
&
&
defined
(
DrawText
)
#
undef
DrawText
#
endif
class
nsTextPaintStyle
;
class
nsLineList_iterator
;
struct
SelectionDetails
;
class
nsTextFragment
;
namespace
mozilla
{
class
SVGContextPaint
;
class
SVGTextFrame
;
class
nsDisplayTextGeometry
;
class
nsDisplayText
;
}
class
nsTextFrame
:
public
nsIFrame
{
typedef
mozilla
:
:
LayoutDeviceRect
LayoutDeviceRect
;
typedef
mozilla
:
:
SelectionTypeMask
SelectionTypeMask
;
typedef
mozilla
:
:
SelectionType
SelectionType
;
typedef
mozilla
:
:
TextRangeStyle
TextRangeStyle
;
typedef
mozilla
:
:
gfx
:
:
DrawTarget
DrawTarget
;
typedef
mozilla
:
:
gfx
:
:
Point
Point
;
typedef
mozilla
:
:
gfx
:
:
Rect
Rect
;
typedef
mozilla
:
:
gfx
:
:
Size
Size
;
typedef
gfxTextRun
:
:
Range
Range
;
public
:
enum
TextRunType
:
uint8_t
;
struct
TabWidthStore
;
class
MOZ_STACK_CLASS
PropertyProvider
final
:
public
gfxTextRun
:
:
PropertyProvider
{
typedef
gfxTextRun
:
:
Range
Range
;
typedef
gfxTextRun
:
:
HyphenType
HyphenType
;
typedef
mozilla
:
:
gfx
:
:
DrawTarget
DrawTarget
;
public
:
PropertyProvider
(
gfxTextRun
*
aTextRun
const
nsStyleText
*
aTextStyle
const
nsTextFragment
*
aFrag
nsTextFrame
*
aFrame
const
gfxSkipCharsIterator
&
aStart
int32_t
aLength
nsIFrame
*
aLineContainer
nscoord
aOffsetFromBlockOriginForTabs
nsTextFrame
:
:
TextRunType
aWhichTextRun
)
;
PropertyProvider
(
nsTextFrame
*
aFrame
const
gfxSkipCharsIterator
&
aStart
nsTextFrame
:
:
TextRunType
aWhichTextRun
nsFontMetrics
*
aFontMetrics
)
;
PropertyProvider
(
nsTextFrame
*
aFrame
const
gfxSkipCharsIterator
&
aStart
)
:
PropertyProvider
(
aFrame
aStart
nsTextFrame
:
:
eInflated
aFrame
-
>
InflatedFontMetrics
(
)
)
{
}
void
InitializeForDisplay
(
bool
aTrimAfter
)
;
void
InitializeForMeasure
(
)
;
void
GetSpacing
(
Range
aRange
Spacing
*
aSpacing
)
const
final
;
gfxFloat
GetHyphenWidth
(
)
const
final
;
void
GetHyphenationBreaks
(
Range
aRange
HyphenType
*
aBreakBefore
)
const
final
;
mozilla
:
:
StyleHyphens
GetHyphensOption
(
)
const
final
{
return
mTextStyle
-
>
mHyphens
;
}
mozilla
:
:
gfx
:
:
ShapedTextFlags
GetShapedTextFlags
(
)
const
final
;
already_AddRefed
<
DrawTarget
>
GetDrawTarget
(
)
const
final
;
uint32_t
GetAppUnitsPerDevUnit
(
)
const
final
{
return
mTextRun
-
>
GetAppUnitsPerDevUnit
(
)
;
}
void
GetSpacingInternal
(
Range
aRange
Spacing
*
aSpacing
bool
aIgnoreTabs
)
const
;
mozilla
:
:
JustificationInfo
ComputeJustification
(
Range
aRange
nsTArray
<
mozilla
:
:
JustificationAssignment
>
*
aAssignments
=
nullptr
)
;
const
nsTextFrame
*
GetFrame
(
)
const
{
return
mFrame
;
}
const
gfxSkipCharsIterator
&
GetStart
(
)
const
{
return
mStart
;
}
uint32_t
GetOriginalLength
(
)
const
{
NS_ASSERTION
(
mLength
!
=
INT32_MAX
"
Length
not
known
"
)
;
return
mLength
;
}
const
nsTextFragment
*
GetFragment
(
)
const
{
return
mFrag
;
}
gfxFontGroup
*
GetFontGroup
(
)
const
{
if
(
!
mFontGroup
)
{
mFontGroup
=
GetFontMetrics
(
)
-
>
GetThebesFontGroup
(
)
;
}
return
mFontGroup
;
}
nsFontMetrics
*
GetFontMetrics
(
)
const
{
if
(
!
mFontMetrics
)
{
InitFontGroupAndFontMetrics
(
)
;
}
return
mFontMetrics
;
}
void
CalcTabWidths
(
Range
aTransformedRange
gfxFloat
aTabWidth
)
const
;
gfxFloat
MinTabAdvance
(
)
const
;
const
gfxSkipCharsIterator
&
GetEndHint
(
)
const
{
return
mTempIterator
;
}
protected
:
void
SetupJustificationSpacing
(
bool
aPostReflow
)
;
void
InitFontGroupAndFontMetrics
(
)
const
;
const
RefPtr
<
gfxTextRun
>
mTextRun
;
mutable
gfxFontGroup
*
mFontGroup
;
mutable
RefPtr
<
nsFontMetrics
>
mFontMetrics
;
const
nsStyleText
*
mTextStyle
;
const
nsTextFragment
*
mFrag
;
const
nsIFrame
*
mLineContainer
;
nsTextFrame
*
mFrame
;
gfxSkipCharsIterator
mStart
;
const
gfxSkipCharsIterator
mTempIterator
;
mutable
nsTextFrame
:
:
TabWidthStore
*
mTabWidths
;
mutable
uint32_t
mTabWidthsAnalyzedLimit
;
int32_t
mLength
;
const
gfxFloat
mWordSpacing
;
const
gfxFloat
mLetterSpacing
;
mutable
gfxFloat
mMinTabAdvance
;
mutable
gfxFloat
mHyphenWidth
;
mutable
gfxFloat
mOffsetFromBlockOriginForTabs
;
uint32_t
mJustificationArrayStart
;
nsTArray
<
Spacing
>
mJustificationSpacings
;
const
bool
mReflowing
;
const
nsTextFrame
:
:
TextRunType
mWhichTextRun
;
}
;
explicit
nsTextFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
ClassID
aID
=
kClassID
)
:
nsIFrame
(
aStyle
aPresContext
aID
)
mNextContinuation
(
nullptr
)
mContentOffset
(
0
)
mContentLengthHint
(
0
)
mAscent
(
0
)
mIsSelected
(
SelectionState
:
:
Unknown
)
{
}
NS_DECL_FRAMEARENA_HELPERS
(
nsTextFrame
)
friend
class
nsContinuingTextFrame
;
NS_DECL_QUERYFRAME
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
ContinuationsProperty
nsTArray
<
nsTextFrame
*
>
)
void
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
final
;
void
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
override
;
void
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
override
;
mozilla
:
:
Maybe
<
Cursor
>
GetCursor
(
const
nsPoint
&
)
final
;
nsresult
CharacterDataChanged
(
const
CharacterDataChangeInfo
&
)
final
;
nsTextFrame
*
FirstContinuation
(
)
const
override
{
return
const_cast
<
nsTextFrame
*
>
(
this
)
;
}
nsTextFrame
*
GetPrevContinuation
(
)
const
override
{
return
nullptr
;
}
nsTextFrame
*
GetNextContinuation
(
)
const
final
{
return
mNextContinuation
;
}
void
SetNextContinuation
(
nsIFrame
*
aNextContinuation
)
final
{
NS_ASSERTION
(
!
aNextContinuation
|
|
Type
(
)
=
=
aNextContinuation
-
>
Type
(
)
"
setting
a
next
continuation
with
incorrect
type
!
"
)
;
NS_ASSERTION
(
!
nsSplittableFrame
:
:
IsInNextContinuationChain
(
aNextContinuation
this
)
"
creating
a
loop
in
continuation
chain
!
"
)
;
mNextContinuation
=
static_cast
<
nsTextFrame
*
>
(
aNextContinuation
)
;
if
(
aNextContinuation
)
aNextContinuation
-
>
RemoveStateBits
(
NS_FRAME_IS_FLUID_CONTINUATION
)
;
if
(
GetContent
(
)
-
>
HasFlag
(
NS_HAS_FLOWLENGTH_PROPERTY
)
)
{
GetContent
(
)
-
>
RemoveProperty
(
nsGkAtoms
:
:
flowlength
)
;
GetContent
(
)
-
>
UnsetFlags
(
NS_HAS_FLOWLENGTH_PROPERTY
)
;
}
}
nsTextFrame
*
GetNextInFlow
(
)
const
final
{
return
mNextContinuation
&
&
mNextContinuation
-
>
HasAnyStateBits
(
NS_FRAME_IS_FLUID_CONTINUATION
)
?
mNextContinuation
:
nullptr
;
}
void
SetNextInFlow
(
nsIFrame
*
aNextInFlow
)
final
{
NS_ASSERTION
(
!
aNextInFlow
|
|
Type
(
)
=
=
aNextInFlow
-
>
Type
(
)
"
setting
a
next
in
flow
with
incorrect
type
!
"
)
;
NS_ASSERTION
(
!
nsSplittableFrame
:
:
IsInNextContinuationChain
(
aNextInFlow
this
)
"
creating
a
loop
in
continuation
chain
!
"
)
;
mNextContinuation
=
static_cast
<
nsTextFrame
*
>
(
aNextInFlow
)
;
if
(
mNextContinuation
&
&
!
mNextContinuation
-
>
HasAnyStateBits
(
NS_FRAME_IS_FLUID_CONTINUATION
)
)
{
if
(
GetContent
(
)
-
>
HasFlag
(
NS_HAS_FLOWLENGTH_PROPERTY
)
)
{
GetContent
(
)
-
>
RemoveProperty
(
nsGkAtoms
:
:
flowlength
)
;
GetContent
(
)
-
>
UnsetFlags
(
NS_HAS_FLOWLENGTH_PROPERTY
)
;
}
}
if
(
aNextInFlow
)
{
aNextInFlow
-
>
AddStateBits
(
NS_FRAME_IS_FLUID_CONTINUATION
)
;
}
}
nsTextFrame
*
LastInFlow
(
)
const
final
;
nsTextFrame
*
LastContinuation
(
)
const
final
;
bool
IsFrameOfType
(
uint32_t
aFlags
)
const
final
{
return
nsIFrame
:
:
IsFrameOfType
(
aFlags
&
~
(
nsIFrame
:
:
eReplaced
|
nsIFrame
:
:
eLineParticipant
)
)
;
}
bool
ShouldSuppressLineBreak
(
)
const
;
void
InvalidateFrame
(
uint32_t
aDisplayItemKey
=
0
bool
aRebuildDisplayItems
=
true
)
final
;
void
InvalidateFrameWithRect
(
const
nsRect
&
aRect
uint32_t
aDisplayItemKey
=
0
bool
aRebuildDisplayItems
=
true
)
final
;
#
ifdef
DEBUG_FRAME_DUMP
void
List
(
FILE
*
out
=
stderr
const
char
*
aPrefix
=
"
"
ListFlags
aFlags
=
ListFlags
(
)
)
const
final
;
nsresult
GetFrameName
(
nsAString
&
aResult
)
const
final
;
void
ToCString
(
nsCString
&
aBuf
)
const
;
void
ListTextRuns
(
FILE
*
out
nsTHashSet
<
const
void
*
>
&
aSeen
)
const
final
;
#
endif
const
nsTextFragment
*
TextFragment
(
)
const
{
return
&
mContent
-
>
AsText
(
)
-
>
TextFragment
(
)
;
}
bool
IsEntirelyWhitespace
(
)
const
;
ContentOffsets
CalcContentOffsetsFromFramePoint
(
const
nsPoint
&
aPoint
)
final
;
ContentOffsets
GetCharacterOffsetAtFramePoint
(
const
nsPoint
&
aPoint
)
;
void
SelectionStateChanged
(
uint32_t
aStart
uint32_t
aEnd
bool
aSelected
SelectionType
aSelectionType
)
;
FrameSearchResult
PeekOffsetNoAmount
(
bool
aForward
int32_t
*
aOffset
)
final
;
FrameSearchResult
PeekOffsetCharacter
(
bool
aForward
int32_t
*
aOffset
PeekOffsetCharacterOptions
aOptions
=
PeekOffsetCharacterOptions
(
)
)
final
;
FrameSearchResult
PeekOffsetWord
(
bool
aForward
bool
aWordSelectEatSpace
bool
aIsKeyboardSelect
int32_t
*
aOffset
PeekWordState
*
aState
bool
aTrimSpaces
)
final
;
[
[
nodiscard
]
]
bool
HasVisibleText
(
)
;
enum
{
ALLOW_FRAME_CREATION_AND_DESTRUCTION
=
0x01
}
;
void
SetLength
(
int32_t
aLength
nsLineLayout
*
aLineLayout
uint32_t
aSetLengthFlags
=
0
)
;
std
:
:
pair
<
int32_t
int32_t
>
GetOffsets
(
)
const
final
;
void
AdjustOffsetsForBidi
(
int32_t
start
int32_t
end
)
final
;
nsresult
GetPointFromOffset
(
int32_t
inOffset
nsPoint
*
outPoint
)
final
;
nsresult
GetCharacterRectsInRange
(
int32_t
aInOffset
int32_t
aLength
nsTArray
<
nsRect
>
&
aRects
)
final
;
nsresult
GetChildFrameContainingOffset
(
int32_t
inContentOffset
bool
inHint
int32_t
*
outFrameContentOffset
nsIFrame
*
*
outChildFrame
)
final
;
bool
IsEmpty
(
)
final
;
bool
IsSelfEmpty
(
)
final
{
return
IsEmpty
(
)
;
}
Maybe
<
nscoord
>
GetNaturalBaselineBOffset
(
mozilla
:
:
WritingMode
aWM
BaselineSharingGroup
aBaselineGroup
BaselineExportContext
)
const
override
;
bool
HasSignificantTerminalNewline
(
)
const
final
;
bool
IsAtEndOfLine
(
)
const
;
bool
HasNoncollapsedCharacters
(
)
const
{
return
HasAnyStateBits
(
TEXT_HAS_NONCOLLAPSED_CHARACTERS
)
;
}
#
ifdef
ACCESSIBILITY
mozilla
:
:
a11y
:
:
AccType
AccessibleType
(
)
final
;
#
endif
float
GetFontSizeInflation
(
)
const
;
bool
IsCurrentFontInflation
(
float
aInflation
)
const
;
bool
HasFontSizeInflation
(
)
const
{
return
HasAnyStateBits
(
TEXT_HAS_FONT_INFLATION
)
;
}
void
SetFontSizeInflation
(
float
aInflation
)
;
void
MarkIntrinsicISizesDirty
(
)
final
;
nscoord
GetMinISize
(
gfxContext
*
aRenderingContext
)
final
;
nscoord
GetPrefISize
(
gfxContext
*
aRenderingContext
)
final
;
void
AddInlineMinISize
(
gfxContext
*
aRenderingContext
InlineMinISizeData
*
aData
)
override
;
void
AddInlinePrefISize
(
gfxContext
*
aRenderingContext
InlinePrefISizeData
*
aData
)
override
;
SizeComputationResult
ComputeSize
(
gfxContext
*
aRenderingContext
mozilla
:
:
WritingMode
aWM
const
mozilla
:
:
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
mozilla
:
:
LogicalSize
&
aMargin
const
mozilla
:
:
LogicalSize
&
aBorderPadding
const
mozilla
:
:
StyleSizeOverrides
&
aSizeOverrides
mozilla
:
:
ComputeSizeFlags
aFlags
)
final
;
nsRect
ComputeTightBounds
(
DrawTarget
*
aDrawTarget
)
const
final
;
nsresult
GetPrefWidthTightBounds
(
gfxContext
*
aContext
nscoord
*
aX
nscoord
*
aXMost
)
final
;
void
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aMetrics
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
final
;
bool
CanContinueTextRun
(
)
const
final
;
struct
TrimOutput
{
bool
mChanged
;
nscoord
mDeltaWidth
;
}
;
TrimOutput
TrimTrailingWhiteSpace
(
DrawTarget
*
aDrawTarget
)
;
RenderedText
GetRenderedText
(
uint32_t
aStartOffset
=
0
uint32_t
aEndOffset
=
UINT32_MAX
TextOffsetType
aOffsetType
=
TextOffsetType
:
:
OffsetsInContentText
TrailingWhitespace
aTrimTrailingWhitespace
=
TrailingWhitespace
:
:
Trim
)
final
;
mozilla
:
:
OverflowAreas
RecomputeOverflow
(
nsIFrame
*
aBlockFrame
bool
aIncludeShadows
=
true
)
;
enum
TextRunType
:
uint8_t
{
eInflated
eNotInflated
}
;
void
AddInlineMinISizeForFlow
(
gfxContext
*
aRenderingContext
nsIFrame
:
:
InlineMinISizeData
*
aData
TextRunType
aTextRunType
)
;
void
AddInlinePrefISizeForFlow
(
gfxContext
*
aRenderingContext
InlinePrefISizeData
*
aData
TextRunType
aTextRunType
)
;
bool
MeasureCharClippedText
(
nscoord
aVisIStartEdge
nscoord
aVisIEndEdge
nscoord
*
aSnappedStartEdge
nscoord
*
aSnappedEndEdge
)
;
bool
MeasureCharClippedText
(
PropertyProvider
&
aProvider
nscoord
aVisIStartEdge
nscoord
aVisIEndEdge
uint32_t
*
aStartOffset
uint32_t
*
aMaxLength
nscoord
*
aSnappedStartEdge
nscoord
*
aSnappedEndEdge
)
;
bool
HasNonSuppressedText
(
)
const
;
struct
DrawPathCallbacks
:
gfxTextRunDrawCallbacks
{
explicit
DrawPathCallbacks
(
bool
aShouldPaintSVGGlyphs
=
false
)
:
gfxTextRunDrawCallbacks
(
aShouldPaintSVGGlyphs
)
{
}
virtual
void
NotifySelectionBackgroundNeedsFill
(
const
Rect
&
aBackgroundRect
nscolor
aColor
DrawTarget
&
aDrawTarget
)
{
}
virtual
void
PaintDecorationLine
(
Rect
aPath
nscolor
aColor
)
{
}
virtual
void
PaintSelectionDecorationLine
(
Rect
aPath
nscolor
aColor
)
{
}
virtual
void
NotifyBeforeText
(
nscolor
aColor
)
{
}
virtual
void
NotifyAfterText
(
)
{
}
virtual
void
NotifyBeforeSelectionDecorationLine
(
nscolor
aColor
)
{
}
virtual
void
NotifySelectionDecorationLinePathEmitted
(
)
{
}
}
;
struct
MOZ_STACK_CLASS
PaintTextParams
{
gfxContext
*
context
;
Point
framePt
;
LayoutDeviceRect
dirtyRect
;
mozilla
:
:
SVGContextPaint
*
contextPaint
=
nullptr
;
DrawPathCallbacks
*
callbacks
=
nullptr
;
enum
{
PaintText
GenerateTextMask
}
;
uint8_t
state
=
PaintText
;
explicit
PaintTextParams
(
gfxContext
*
aContext
)
:
context
(
aContext
)
{
}
bool
IsPaintText
(
)
const
{
return
state
=
=
PaintText
;
}
bool
IsGenerateTextMask
(
)
const
{
return
state
=
=
GenerateTextMask
;
}
}
;
struct
PaintTextSelectionParams
;
struct
DrawTextRunParams
;
struct
DrawTextParams
;
struct
ClipEdges
;
struct
PaintShadowParams
;
struct
PaintDecorationLineParams
;
struct
SelectionRange
{
const
SelectionDetails
*
mDetails
;
gfxTextRun
:
:
Range
mRange
;
uint32_t
mPriority
;
}
;
void
PaintText
(
const
PaintTextParams
&
aParams
const
nscoord
aVisIStartEdge
const
nscoord
aVisIEndEdge
const
nsPoint
&
aToReferenceFrame
const
bool
aIsSelected
float
aOpacity
=
1
.
0f
)
;
bool
PaintTextWithSelection
(
const
PaintTextSelectionParams
&
aParams
const
ClipEdges
&
aClipEdges
)
;
bool
PaintTextWithSelectionColors
(
const
PaintTextSelectionParams
&
aParams
const
mozilla
:
:
UniquePtr
<
SelectionDetails
>
&
aDetails
SelectionTypeMask
*
aAllSelectionTypeMask
const
ClipEdges
&
aClipEdges
)
;
void
PaintTextSelectionDecorations
(
const
PaintTextSelectionParams
&
aParams
const
mozilla
:
:
UniquePtr
<
SelectionDetails
>
&
aDetails
SelectionType
aSelectionType
)
;
SelectionTypeMask
ResolveSelections
(
const
PaintTextSelectionParams
&
aParams
const
SelectionDetails
*
aDetails
nsTArray
<
SelectionRange
>
&
aResult
SelectionType
aSelectionType
bool
*
aAnyBackgrounds
=
nullptr
)
const
;
void
DrawEmphasisMarks
(
gfxContext
*
aContext
mozilla
:
:
WritingMode
aWM
const
mozilla
:
:
gfx
:
:
Point
&
aTextBaselinePt
const
mozilla
:
:
gfx
:
:
Point
&
aFramePt
Range
aRange
const
nscolor
*
aDecorationOverrideColor
PropertyProvider
*
aProvider
)
;
nscolor
GetCaretColorAt
(
int32_t
aOffset
)
final
;
int16_t
GetSelectionStatus
(
int16_t
*
aSelectionFlags
)
;
int32_t
GetContentOffset
(
)
const
{
return
mContentOffset
;
}
int32_t
GetContentLength
(
)
const
{
NS_ASSERTION
(
GetContentEnd
(
)
-
mContentOffset
>
=
0
"
negative
length
"
)
;
return
GetContentEnd
(
)
-
mContentOffset
;
}
int32_t
GetContentEnd
(
)
const
;
int32_t
GetContentLengthHint
(
)
const
{
return
mContentLengthHint
;
}
int32_t
GetInFlowContentLength
(
)
;
gfxSkipCharsIterator
EnsureTextRun
(
TextRunType
aWhichTextRun
DrawTarget
*
aRefDrawTarget
=
nullptr
nsIFrame
*
aLineContainer
=
nullptr
const
nsLineList_iterator
*
aLine
=
nullptr
uint32_t
*
aFlowEndInTextRun
=
nullptr
)
;
gfxTextRun
*
GetTextRun
(
TextRunType
aWhichTextRun
)
const
{
if
(
aWhichTextRun
=
=
eInflated
|
|
!
HasFontSizeInflation
(
)
)
return
mTextRun
;
return
GetUninflatedTextRun
(
)
;
}
gfxTextRun
*
GetUninflatedTextRun
(
)
const
;
void
SetTextRun
(
gfxTextRun
*
aTextRun
TextRunType
aWhichTextRun
float
aInflation
)
;
bool
IsInTextRunUserData
(
)
const
{
return
HasAnyStateBits
(
TEXT_IN_TEXTRUN_USER_DATA
|
TEXT_IN_UNINFLATED_TEXTRUN_USER_DATA
)
;
}
bool
RemoveTextRun
(
gfxTextRun
*
aTextRun
)
;
void
ClearTextRun
(
nsTextFrame
*
aStartContinuation
TextRunType
aWhichTextRun
)
;
void
ClearTextRuns
(
)
{
ClearTextRun
(
nullptr
nsTextFrame
:
:
eInflated
)
;
if
(
HasFontSizeInflation
(
)
)
{
ClearTextRun
(
nullptr
nsTextFrame
:
:
eNotInflated
)
;
}
}
void
DisconnectTextRuns
(
)
;
struct
TrimmedOffsets
{
int32_t
mStart
;
int32_t
mLength
;
int32_t
GetEnd
(
)
const
{
return
mStart
+
mLength
;
}
}
;
enum
class
TrimmedOffsetFlags
:
uint8_t
{
Default
=
0
NotPostReflow
=
1
<
<
0
NoTrimAfter
=
1
<
<
1
NoTrimBefore
=
1
<
<
2
}
;
TrimmedOffsets
GetTrimmedOffsets
(
const
nsTextFragment
*
aFrag
TrimmedOffsetFlags
aFlags
=
TrimmedOffsetFlags
:
:
Default
)
const
;
void
ReflowText
(
nsLineLayout
&
aLineLayout
nscoord
aAvailableWidth
DrawTarget
*
aDrawTarget
ReflowOutput
&
aMetrics
nsReflowStatus
&
aStatus
)
;
nscoord
ComputeLineHeight
(
)
const
;
bool
IsFloatingFirstLetterChild
(
)
const
;
bool
IsInitialLetterChild
(
)
const
;
bool
ComputeCustomOverflow
(
mozilla
:
:
OverflowAreas
&
aOverflowAreas
)
final
;
bool
ComputeCustomOverflowInternal
(
mozilla
:
:
OverflowAreas
&
aOverflowAreas
bool
aIncludeShadows
)
;
void
AssignJustificationGaps
(
const
mozilla
:
:
JustificationAssignment
&
aAssign
)
;
mozilla
:
:
JustificationAssignment
GetJustificationAssignment
(
)
const
;
uint32_t
CountGraphemeClusters
(
)
const
;
bool
HasAnyNoncollapsedCharacters
(
)
final
;
void
NotifyNativeAnonymousTextnodeChange
(
uint32_t
aOldLength
)
;
nsFontMetrics
*
InflatedFontMetrics
(
)
const
;
nsRect
WebRenderBounds
(
)
;
nsTextFrame
*
FindContinuationForOffset
(
int32_t
aOffset
)
;
void
SetHangableISize
(
nscoord
aISize
)
;
nscoord
GetHangableISize
(
)
const
;
protected
:
virtual
~
nsTextFrame
(
)
;
friend
class
mozilla
:
:
nsDisplayTextGeometry
;
friend
class
mozilla
:
:
nsDisplayText
;
mutable
RefPtr
<
nsFontMetrics
>
mFontMetrics
;
RefPtr
<
gfxTextRun
>
mTextRun
;
nsTextFrame
*
mNextContinuation
;
int32_t
mContentOffset
;
int32_t
mContentLengthHint
;
nscoord
mAscent
;
enum
class
SelectionState
:
uint8_t
{
Unknown
Selected
NotSelected
}
;
mutable
SelectionState
mIsSelected
;
bool
mHasContinuationsProperty
=
false
;
bool
mHasHangableWS
=
false
;
bool
IsFrameSelected
(
)
const
final
;
void
InvalidateSelectionState
(
)
{
mIsSelected
=
SelectionState
:
:
Unknown
;
}
mozilla
:
:
UniquePtr
<
SelectionDetails
>
GetSelectionDetails
(
)
;
void
UnionAdditionalOverflow
(
nsPresContext
*
aPresContext
nsIFrame
*
aBlock
PropertyProvider
&
aProvider
nsRect
*
aInkOverflowRect
bool
aIncludeTextDecorations
bool
aIncludeShadows
)
;
nsRect
UpdateTextEmphasis
(
mozilla
:
:
WritingMode
aWM
PropertyProvider
&
aProvider
)
;
void
PaintOneShadow
(
const
PaintShadowParams
&
aParams
const
mozilla
:
:
StyleSimpleShadow
&
aShadowDetails
gfxRect
&
aBoundingBox
uint32_t
aBlurFlags
)
;
void
PaintShadows
(
mozilla
:
:
Span
<
const
mozilla
:
:
StyleSimpleShadow
>
const
PaintShadowParams
&
aParams
)
;
struct
LineDecoration
{
nsIFrame
*
mFrame
;
nscoord
mBaselineOffset
;
const
mozilla
:
:
LengthPercentageOrAuto
mTextUnderlineOffset
;
const
mozilla
:
:
StyleTextDecorationLength
mTextDecorationThickness
;
nscolor
mColor
;
mozilla
:
:
StyleTextDecorationStyle
mStyle
;
const
mozilla
:
:
StyleTextUnderlinePosition
mTextUnderlinePosition
;
LineDecoration
(
nsIFrame
*
const
aFrame
const
nscoord
aOff
mozilla
:
:
StyleTextUnderlinePosition
aUnderlinePosition
const
mozilla
:
:
LengthPercentageOrAuto
&
aUnderlineOffset
const
mozilla
:
:
StyleTextDecorationLength
&
aDecThickness
const
nscolor
aColor
const
mozilla
:
:
StyleTextDecorationStyle
aStyle
)
:
mFrame
(
aFrame
)
mBaselineOffset
(
aOff
)
mTextUnderlineOffset
(
aUnderlineOffset
)
mTextDecorationThickness
(
aDecThickness
)
mColor
(
aColor
)
mStyle
(
aStyle
)
mTextUnderlinePosition
(
aUnderlinePosition
)
{
}
LineDecoration
(
const
LineDecoration
&
aOther
)
=
default
;
bool
operator
=
=
(
const
LineDecoration
&
aOther
)
const
{
return
mFrame
=
=
aOther
.
mFrame
&
&
mStyle
=
=
aOther
.
mStyle
&
&
mColor
=
=
aOther
.
mColor
&
&
mBaselineOffset
=
=
aOther
.
mBaselineOffset
&
&
mTextUnderlinePosition
=
=
aOther
.
mTextUnderlinePosition
&
&
mTextUnderlineOffset
=
=
aOther
.
mTextUnderlineOffset
&
&
mTextDecorationThickness
=
=
aOther
.
mTextDecorationThickness
;
}
bool
operator
!
=
(
const
LineDecoration
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
}
;
struct
TextDecorations
{
AutoTArray
<
LineDecoration
1
>
mOverlines
mUnderlines
mStrikes
;
TextDecorations
(
)
=
default
;
bool
HasDecorationLines
(
)
const
{
return
HasUnderline
(
)
|
|
HasOverline
(
)
|
|
HasStrikeout
(
)
;
}
bool
HasUnderline
(
)
const
{
return
!
mUnderlines
.
IsEmpty
(
)
;
}
bool
HasOverline
(
)
const
{
return
!
mOverlines
.
IsEmpty
(
)
;
}
bool
HasStrikeout
(
)
const
{
return
!
mStrikes
.
IsEmpty
(
)
;
}
bool
operator
=
=
(
const
TextDecorations
&
aOther
)
const
{
return
mOverlines
=
=
aOther
.
mOverlines
&
&
mUnderlines
=
=
aOther
.
mUnderlines
&
&
mStrikes
=
=
aOther
.
mStrikes
;
}
bool
operator
!
=
(
const
TextDecorations
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
}
;
enum
TextDecorationColorResolution
{
eResolvedColors
eUnresolvedColors
}
;
void
GetTextDecorations
(
nsPresContext
*
aPresContext
TextDecorationColorResolution
aColorResolution
TextDecorations
&
aDecorations
)
;
void
DrawTextRun
(
Range
aRange
const
mozilla
:
:
gfx
:
:
Point
&
aTextBaselinePt
const
DrawTextRunParams
&
aParams
)
;
void
DrawTextRunAndDecorations
(
Range
aRange
const
mozilla
:
:
gfx
:
:
Point
&
aTextBaselinePt
const
DrawTextParams
&
aParams
const
TextDecorations
&
aDecorations
)
;
void
DrawText
(
Range
aRange
const
mozilla
:
:
gfx
:
:
Point
&
aTextBaselinePt
const
DrawTextParams
&
aParams
)
;
bool
CombineSelectionUnderlineRect
(
nsPresContext
*
aPresContext
nsRect
&
aRect
)
;
void
GetSelectionTextShadow
(
SelectionType
aSelectionType
nsTextPaintStyle
&
aTextPaintStyle
mozilla
:
:
Span
<
const
mozilla
:
:
StyleSimpleShadow
>
*
aShadows
)
;
void
DrawSelectionDecorations
(
gfxContext
*
aContext
const
LayoutDeviceRect
&
aDirtyRect
mozilla
:
:
SelectionType
aSelectionType
nsTextPaintStyle
&
aTextPaintStyle
const
TextRangeStyle
&
aRangeStyle
const
Point
&
aPt
gfxFloat
aICoordInFrame
gfxFloat
aWidth
gfxFloat
aAscent
const
gfxFont
:
:
Metrics
&
aFontMetrics
DrawPathCallbacks
*
aCallbacks
bool
aVertical
mozilla
:
:
StyleTextDecorationLine
aDecoration
)
;
void
PaintDecorationLine
(
const
PaintDecorationLineParams
&
aParams
)
;
gfxFloat
ComputeDescentLimitForSelectionUnderline
(
nsPresContext
*
aPresContext
const
gfxFont
:
:
Metrics
&
aFontMetrics
)
;
static
bool
GetSelectionTextColors
(
SelectionType
aSelectionType
const
nsAtom
*
aHighlightName
nsTextPaintStyle
&
aTextPaintStyle
const
TextRangeStyle
&
aRangeStyle
nscolor
*
aForeground
nscolor
*
aBackground
)
;
static
gfxFloat
ComputeSelectionUnderlineHeight
(
nsPresContext
*
aPresContext
const
gfxFont
:
:
Metrics
&
aFontMetrics
SelectionType
aSelectionType
)
;
ContentOffsets
GetCharacterOffsetAtFramePointInternal
(
const
nsPoint
&
aPoint
bool
aForInsertionPoint
)
;
static
float
GetTextCombineScaleFactor
(
nsTextFrame
*
aFrame
)
;
void
ClearFrameOffsetCache
(
)
;
void
ClearMetrics
(
ReflowOutput
&
aMetrics
)
;
nsTArray
<
nsTextFrame
*
>
*
GetContinuations
(
)
;
void
ClearCachedContinuations
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mHasContinuationsProperty
)
{
RemoveProperty
(
ContinuationsProperty
(
)
)
;
mHasContinuationsProperty
=
false
;
}
}
void
UpdateIteratorFromOffset
(
const
PropertyProvider
&
aProperties
int32_t
&
aInOffset
gfxSkipCharsIterator
&
aIter
)
;
nsPoint
GetPointFromIterator
(
const
gfxSkipCharsIterator
&
aIter
PropertyProvider
&
aProperties
)
;
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
nsTextFrame
:
:
TrimmedOffsetFlags
)
#
endif
