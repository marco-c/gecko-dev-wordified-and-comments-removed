#
include
"
nsInlineFrame
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
mozilla
/
ComputedStyle
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
mozilla
/
SVGTextFrame
.
h
"
#
include
"
mozilla
/
SVGUtils
.
h
"
#
include
"
nsLineLayout
.
h
"
#
include
"
nsBlockFrame
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsPlaceholderFrame
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsPresContextInlines
.
h
"
#
include
"
nsCSSAnonBoxes
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsStyleChangeList
.
h
"
#
ifdef
DEBUG
#
undef
NOISY_PUSHING
#
endif
using
namespace
mozilla
;
using
namespace
mozilla
:
:
layout
;
nsInlineFrame
*
NS_NewInlineFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsInlineFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsInlineFrame
)
NS_QUERYFRAME_HEAD
(
nsInlineFrame
)
NS_QUERYFRAME_ENTRY
(
nsInlineFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsContainerFrame
)
#
ifdef
DEBUG_FRAME_DUMP
nsresult
nsInlineFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
u
"
Inline
"
_ns
aResult
)
;
}
#
endif
void
nsInlineFrame
:
:
InvalidateFrame
(
uint32_t
aDisplayItemKey
bool
aRebuildDisplayItems
)
{
if
(
SVGUtils
:
:
IsInSVGTextSubtree
(
this
)
)
{
nsIFrame
*
svgTextFrame
=
nsLayoutUtils
:
:
GetClosestFrameOfType
(
GetParent
(
)
LayoutFrameType
:
:
SVGText
)
;
svgTextFrame
-
>
InvalidateFrame
(
)
;
return
;
}
nsContainerFrame
:
:
InvalidateFrame
(
aDisplayItemKey
aRebuildDisplayItems
)
;
}
void
nsInlineFrame
:
:
InvalidateFrameWithRect
(
const
nsRect
&
aRect
uint32_t
aDisplayItemKey
bool
aRebuildDisplayItems
)
{
if
(
SVGUtils
:
:
IsInSVGTextSubtree
(
this
)
)
{
nsIFrame
*
svgTextFrame
=
nsLayoutUtils
:
:
GetClosestFrameOfType
(
GetParent
(
)
LayoutFrameType
:
:
SVGText
)
;
svgTextFrame
-
>
InvalidateFrame
(
)
;
return
;
}
nsContainerFrame
:
:
InvalidateFrameWithRect
(
aRect
aDisplayItemKey
aRebuildDisplayItems
)
;
}
static
inline
bool
IsMarginZero
(
const
LengthPercentageOrAuto
&
aLength
)
{
return
aLength
.
IsAuto
(
)
|
|
nsLayoutUtils
:
:
IsMarginZero
(
aLength
.
AsLengthPercentage
(
)
)
;
}
bool
nsInlineFrame
:
:
IsSelfEmpty
(
)
{
#
if
0
if
(
GetPresContext
(
)
-
>
CompatibilityMode
(
)
=
=
eCompatibility_FullStandards
)
{
return
false
;
}
#
endif
const
nsStyleMargin
*
margin
=
StyleMargin
(
)
;
const
nsStyleBorder
*
border
=
StyleBorder
(
)
;
const
nsStylePadding
*
padding
=
StylePadding
(
)
;
WritingMode
wm
=
GetWritingMode
(
)
;
bool
haveStart
haveEnd
;
auto
HaveSide
=
[
&
]
(
mozilla
:
:
Side
aSide
)
-
>
bool
{
return
border
-
>
GetComputedBorderWidth
(
aSide
)
!
=
0
|
|
!
nsLayoutUtils
:
:
IsPaddingZero
(
padding
-
>
mPadding
.
Get
(
aSide
)
)
|
|
!
IsMarginZero
(
margin
-
>
mMargin
.
Get
(
aSide
)
)
;
}
;
if
(
wm
.
IsVertical
(
)
)
{
haveStart
=
HaveSide
(
eSideTop
)
;
haveEnd
=
HaveSide
(
eSideBottom
)
;
}
else
{
haveStart
=
HaveSide
(
eSideLeft
)
;
haveEnd
=
HaveSide
(
eSideRight
)
;
}
if
(
haveStart
|
|
haveEnd
)
{
if
(
HasAnyStateBits
(
NS_FRAME_PART_OF_IBSPLIT
)
&
&
StyleBorder
(
)
-
>
mBoxDecorationBreak
=
=
StyleBoxDecorationBreak
:
:
Slice
)
{
if
(
wm
.
IsBidiRTL
(
)
)
{
std
:
:
swap
(
haveStart
haveEnd
)
;
}
nsIFrame
*
firstCont
=
FirstContinuation
(
)
;
return
(
!
haveStart
|
|
firstCont
-
>
FrameIsNonFirstInIBSplit
(
)
)
&
&
(
!
haveEnd
|
|
firstCont
-
>
FrameIsNonLastInIBSplit
(
)
)
;
}
return
false
;
}
return
true
;
}
bool
nsInlineFrame
:
:
IsEmpty
(
)
{
if
(
!
IsSelfEmpty
(
)
)
{
return
false
;
}
for
(
nsIFrame
*
kid
:
mFrames
)
{
if
(
!
kid
-
>
IsEmpty
(
)
)
return
false
;
}
return
true
;
}
nsIFrame
:
:
FrameSearchResult
nsInlineFrame
:
:
PeekOffsetCharacter
(
bool
aForward
int32_t
*
aOffset
PeekOffsetCharacterOptions
aOptions
)
{
NS_ASSERTION
(
aOffset
&
&
*
aOffset
<
=
1
"
aOffset
out
of
range
"
)
;
int32_t
startOffset
=
*
aOffset
;
if
(
startOffset
<
0
)
startOffset
=
1
;
if
(
aForward
=
=
(
startOffset
=
=
0
)
)
{
*
aOffset
=
1
-
startOffset
;
}
return
CONTINUE
;
}
void
nsInlineFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
{
nsFrameList
*
overflowFrames
=
GetOverflowFrames
(
)
;
if
(
overflowFrames
)
{
overflowFrames
-
>
ApplySetParent
(
this
)
;
}
nsContainerFrame
:
:
DestroyFrom
(
aDestructRoot
aPostDestroyData
)
;
}
void
nsInlineFrame
:
:
StealFrame
(
nsIFrame
*
aChild
)
{
if
(
MaybeStealOverflowContainerFrame
(
aChild
)
)
{
return
;
}
nsInlineFrame
*
parent
=
this
;
do
{
if
(
parent
-
>
mFrames
.
StartRemoveFrame
(
aChild
)
)
{
return
;
}
nsFrameList
*
frameList
=
parent
-
>
GetOverflowFrames
(
)
;
if
(
frameList
&
&
frameList
-
>
ContinueRemoveFrame
(
aChild
)
)
{
if
(
frameList
-
>
IsEmpty
(
)
)
{
parent
-
>
DestroyOverflowList
(
)
;
}
return
;
}
parent
=
static_cast
<
nsInlineFrame
*
>
(
parent
-
>
GetNextInFlow
(
)
)
;
}
while
(
parent
)
;
MOZ_ASSERT_UNREACHABLE
(
"
nsInlineFrame
:
:
StealFrame
:
can
'
t
find
aChild
"
)
;
}
void
nsInlineFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
BuildDisplayListForInline
(
aBuilder
aLists
)
;
if
(
!
mFrames
.
FirstChild
(
)
)
{
DisplaySelectionOverlay
(
aBuilder
aLists
.
Content
(
)
)
;
}
}
void
nsInlineFrame
:
:
AddInlineMinISize
(
gfxContext
*
aRenderingContext
nsIFrame
:
:
InlineMinISizeData
*
aData
)
{
DoInlineMinISize
(
aRenderingContext
aData
)
;
}
void
nsInlineFrame
:
:
AddInlinePrefISize
(
gfxContext
*
aRenderingContext
nsIFrame
:
:
InlinePrefISizeData
*
aData
)
{
DoInlinePrefISize
(
aRenderingContext
aData
)
;
}
nsIFrame
:
:
SizeComputationResult
nsInlineFrame
:
:
ComputeSize
(
gfxContext
*
aRenderingContext
WritingMode
aWM
const
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
LogicalSize
&
aMargin
const
LogicalSize
&
aBorderPadding
const
StyleSizeOverrides
&
aSizeOverrides
ComputeSizeFlags
aFlags
)
{
return
{
LogicalSize
(
aWM
NS_UNCONSTRAINEDSIZE
NS_UNCONSTRAINEDSIZE
)
AspectRatioUsage
:
:
None
}
;
}
nsRect
nsInlineFrame
:
:
ComputeTightBounds
(
DrawTarget
*
aDrawTarget
)
const
{
if
(
Style
(
)
-
>
HasTextDecorationLines
(
)
)
{
return
InkOverflowRect
(
)
;
}
return
ComputeSimpleTightBounds
(
aDrawTarget
)
;
}
static
void
ReparentChildListStyle
(
nsPresContext
*
aPresContext
const
nsFrameList
:
:
Slice
&
aFrames
nsIFrame
*
aParentFrame
)
{
RestyleManager
*
restyleManager
=
aPresContext
-
>
RestyleManager
(
)
;
for
(
nsIFrame
*
f
:
aFrames
)
{
NS_ASSERTION
(
f
-
>
GetParent
(
)
=
=
aParentFrame
"
Bogus
parentage
"
)
;
restyleManager
-
>
ReparentComputedStyleForFirstLine
(
f
)
;
nsLayoutUtils
:
:
MarkDescendantsDirty
(
f
)
;
}
}
void
nsInlineFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aMetrics
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsInlineFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aMetrics
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
if
(
nullptr
=
=
aReflowInput
.
mLineLayout
)
{
NS_ERROR
(
"
must
have
non
-
null
aReflowInput
.
mLineLayout
"
)
;
return
;
}
if
(
IsFrameTreeTooDeep
(
aReflowInput
aMetrics
aStatus
)
)
{
return
;
}
bool
lazilySetParentPointer
=
false
;
nsInlineFrame
*
prevInFlow
=
(
nsInlineFrame
*
)
GetPrevInFlow
(
)
;
if
(
prevInFlow
)
{
AutoFrameListPtr
prevOverflowFrames
(
aPresContext
prevInFlow
-
>
StealOverflowFrames
(
)
)
;
if
(
prevOverflowFrames
)
{
nsContainerFrame
:
:
ReparentFrameViewList
(
*
prevOverflowFrames
prevInFlow
this
)
;
if
(
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
&
&
mFrames
.
IsEmpty
(
)
&
&
!
GetNextInFlow
(
)
)
{
mFrames
.
SetFrames
(
*
prevOverflowFrames
)
;
lazilySetParentPointer
=
true
;
}
else
{
const
nsFrameList
:
:
Slice
&
newFrames
=
mFrames
.
InsertFrames
(
this
nullptr
std
:
:
move
(
*
prevOverflowFrames
)
)
;
if
(
aReflowInput
.
mLineLayout
-
>
GetInFirstLine
(
)
)
{
ReparentChildListStyle
(
aPresContext
newFrames
this
)
;
}
}
}
}
#
ifdef
DEBUG
if
(
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
)
{
nsFrameList
*
overflowFrames
=
GetOverflowFrames
(
)
;
NS_ASSERTION
(
!
overflowFrames
|
|
overflowFrames
-
>
IsEmpty
(
)
"
overflow
list
is
not
empty
for
initial
reflow
"
)
;
}
#
endif
if
(
!
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
)
{
DrainSelfOverflowListInternal
(
aReflowInput
.
mLineLayout
-
>
GetInFirstLine
(
)
)
;
}
InlineReflowInput
irs
;
irs
.
mPrevFrame
=
nullptr
;
irs
.
mLineContainer
=
aReflowInput
.
mLineLayout
-
>
LineContainerFrame
(
)
;
irs
.
mLineLayout
=
aReflowInput
.
mLineLayout
;
irs
.
mNextInFlow
=
(
nsInlineFrame
*
)
GetNextInFlow
(
)
;
irs
.
mSetParentPointer
=
lazilySetParentPointer
;
if
(
mFrames
.
IsEmpty
(
)
)
{
Unused
<
<
PullOneFrame
(
aPresContext
irs
)
;
}
ReflowFrames
(
aPresContext
aReflowInput
irs
aMetrics
aStatus
)
;
ReflowAbsoluteFrames
(
aPresContext
aMetrics
aReflowInput
aStatus
)
;
}
nsresult
nsInlineFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
nsresult
rv
=
nsContainerFrame
:
:
AttributeChanged
(
aNameSpaceID
aAttribute
aModType
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
SVGUtils
:
:
IsInSVGTextSubtree
(
this
)
)
{
SVGTextFrame
*
f
=
static_cast
<
SVGTextFrame
*
>
(
nsLayoutUtils
:
:
GetClosestFrameOfType
(
this
LayoutFrameType
:
:
SVGText
)
)
;
f
-
>
HandleAttributeChangeInDescendant
(
mContent
-
>
AsElement
(
)
aNameSpaceID
aAttribute
)
;
}
return
NS_OK
;
}
bool
nsInlineFrame
:
:
DrainSelfOverflowListInternal
(
bool
aInFirstLine
)
{
AutoFrameListPtr
overflowFrames
(
PresContext
(
)
StealOverflowFrames
(
)
)
;
if
(
!
overflowFrames
|
|
overflowFrames
-
>
IsEmpty
(
)
)
{
return
false
;
}
nsIFrame
*
firstChild
=
overflowFrames
-
>
FirstChild
(
)
;
RestyleManager
*
restyleManager
=
PresContext
(
)
-
>
RestyleManager
(
)
;
for
(
nsIFrame
*
f
=
firstChild
;
f
;
f
=
f
-
>
GetNextSibling
(
)
)
{
f
-
>
SetParent
(
this
)
;
if
(
MOZ_UNLIKELY
(
aInFirstLine
)
)
{
restyleManager
-
>
ReparentComputedStyleForFirstLine
(
f
)
;
nsLayoutUtils
:
:
MarkDescendantsDirty
(
f
)
;
}
}
mFrames
.
AppendFrames
(
nullptr
std
:
:
move
(
*
overflowFrames
)
)
;
return
true
;
}
bool
nsInlineFrame
:
:
DrainSelfOverflowList
(
)
{
nsIFrame
*
lineContainer
=
nsLayoutUtils
:
:
FindNearestBlockAncestor
(
this
)
;
bool
inFirstLine
=
false
;
for
(
nsIFrame
*
p
=
GetParent
(
)
;
p
!
=
lineContainer
;
p
=
p
-
>
GetParent
(
)
)
{
if
(
p
-
>
IsLineFrame
(
)
)
{
inFirstLine
=
true
;
break
;
}
}
return
DrainSelfOverflowListInternal
(
inFirstLine
)
;
}
bool
nsInlineFrame
:
:
CanContinueTextRun
(
)
const
{
return
true
;
}
void
nsInlineFrame
:
:
PullOverflowsFromPrevInFlow
(
)
{
nsInlineFrame
*
prevInFlow
=
static_cast
<
nsInlineFrame
*
>
(
GetPrevInFlow
(
)
)
;
if
(
prevInFlow
)
{
nsPresContext
*
presContext
=
PresContext
(
)
;
AutoFrameListPtr
prevOverflowFrames
(
presContext
prevInFlow
-
>
StealOverflowFrames
(
)
)
;
if
(
prevOverflowFrames
)
{
nsContainerFrame
:
:
ReparentFrameViewList
(
*
prevOverflowFrames
prevInFlow
this
)
;
mFrames
.
InsertFrames
(
this
nullptr
std
:
:
move
(
*
prevOverflowFrames
)
)
;
}
}
}
void
nsInlineFrame
:
:
ReflowFrames
(
nsPresContext
*
aPresContext
const
ReflowInput
&
aReflowInput
InlineReflowInput
&
irs
ReflowOutput
&
aMetrics
nsReflowStatus
&
aStatus
)
{
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
nsLineLayout
*
lineLayout
=
aReflowInput
.
mLineLayout
;
bool
inFirstLine
=
aReflowInput
.
mLineLayout
-
>
GetInFirstLine
(
)
;
RestyleManager
*
restyleManager
=
aPresContext
-
>
RestyleManager
(
)
;
WritingMode
frameWM
=
aReflowInput
.
GetWritingMode
(
)
;
WritingMode
lineWM
=
aReflowInput
.
mLineLayout
-
>
mRootSpan
-
>
mWritingMode
;
LogicalMargin
framePadding
=
aReflowInput
.
ComputedLogicalBorderPadding
(
frameWM
)
;
nscoord
startEdge
=
0
;
const
bool
boxDecorationBreakClone
=
MOZ_UNLIKELY
(
StyleBorder
(
)
-
>
mBoxDecorationBreak
=
=
StyleBoxDecorationBreak
:
:
Clone
)
;
if
(
(
!
GetPrevContinuation
(
)
&
&
!
FrameIsNonFirstInIBSplit
(
)
)
|
|
boxDecorationBreakClone
)
{
startEdge
=
framePadding
.
IStart
(
frameWM
)
;
}
nscoord
availableISize
=
aReflowInput
.
AvailableISize
(
)
;
NS_ASSERTION
(
availableISize
!
=
NS_UNCONSTRAINEDSIZE
"
should
no
longer
use
available
widths
"
)
;
availableISize
-
=
startEdge
;
availableISize
-
=
framePadding
.
IEnd
(
frameWM
)
;
lineLayout
-
>
BeginSpan
(
this
&
aReflowInput
startEdge
startEdge
+
availableISize
&
mBaseline
)
;
nsIFrame
*
frame
=
mFrames
.
FirstChild
(
)
;
bool
done
=
false
;
while
(
frame
)
{
if
(
irs
.
mSetParentPointer
)
{
nsIFrame
*
child
=
frame
;
do
{
child
-
>
SetParent
(
this
)
;
if
(
inFirstLine
)
{
restyleManager
-
>
ReparentComputedStyleForFirstLine
(
child
)
;
nsLayoutUtils
:
:
MarkDescendantsDirty
(
child
)
;
}
nsIFrame
*
nextSibling
=
child
-
>
GetNextSibling
(
)
;
child
=
child
-
>
GetNextInFlow
(
)
;
if
(
MOZ_UNLIKELY
(
child
)
)
{
while
(
child
!
=
nextSibling
&
&
nextSibling
)
{
nextSibling
=
nextSibling
-
>
GetNextSibling
(
)
;
}
if
(
!
nextSibling
)
{
child
=
nullptr
;
}
}
MOZ_ASSERT
(
!
child
|
|
mFrames
.
ContainsFrame
(
child
)
)
;
}
while
(
child
)
;
nsIFrame
*
realFrame
=
nsPlaceholderFrame
:
:
GetRealFrameFor
(
frame
)
;
if
(
realFrame
-
>
IsLetterFrame
(
)
)
{
nsIFrame
*
child
=
realFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
child
)
{
NS_ASSERTION
(
child
-
>
IsTextFrame
(
)
"
unexpected
frame
type
"
)
;
nsIFrame
*
nextInFlow
=
child
-
>
GetNextInFlow
(
)
;
for
(
;
nextInFlow
;
nextInFlow
=
nextInFlow
-
>
GetNextInFlow
(
)
)
{
NS_ASSERTION
(
nextInFlow
-
>
IsTextFrame
(
)
"
unexpected
frame
type
"
)
;
if
(
mFrames
.
ContainsFrame
(
nextInFlow
)
)
{
nextInFlow
-
>
SetParent
(
this
)
;
if
(
inFirstLine
)
{
restyleManager
-
>
ReparentComputedStyleForFirstLine
(
nextInFlow
)
;
nsLayoutUtils
:
:
MarkDescendantsDirty
(
nextInFlow
)
;
}
}
else
{
#
ifdef
DEBUG
for
(
;
nextInFlow
;
nextInFlow
=
nextInFlow
-
>
GetNextInFlow
(
)
)
{
NS_ASSERTION
(
!
mFrames
.
ContainsFrame
(
nextInFlow
)
"
unexpected
letter
frame
flow
"
)
;
}
#
endif
break
;
}
}
}
}
}
MOZ_ASSERT
(
frame
-
>
GetParent
(
)
=
=
this
)
;
if
(
!
done
)
{
bool
reflowingFirstLetter
=
lineLayout
-
>
GetFirstLetterStyleOK
(
)
;
ReflowInlineFrame
(
aPresContext
aReflowInput
irs
frame
aStatus
)
;
done
=
aStatus
.
IsInlineBreak
(
)
|
|
(
!
reflowingFirstLetter
&
&
aStatus
.
IsIncomplete
(
)
)
;
if
(
done
)
{
if
(
!
irs
.
mSetParentPointer
)
{
break
;
}
nsFrameList
*
pushedFrames
=
GetOverflowFrames
(
)
;
if
(
pushedFrames
&
&
pushedFrames
-
>
FirstChild
(
)
=
=
frame
)
{
break
;
}
}
else
{
irs
.
mPrevFrame
=
frame
;
}
}
frame
=
frame
-
>
GetNextSibling
(
)
;
}
if
(
!
done
&
&
GetNextInFlow
(
)
)
{
while
(
true
)
{
bool
reflowingFirstLetter
=
lineLayout
-
>
GetFirstLetterStyleOK
(
)
;
if
(
!
frame
)
{
frame
=
PullOneFrame
(
aPresContext
irs
)
;
}
#
ifdef
NOISY_PUSHING
printf
(
"
%
p
pulled
up
%
p
\
n
"
this
frame
)
;
#
endif
if
(
!
frame
)
{
break
;
}
ReflowInlineFrame
(
aPresContext
aReflowInput
irs
frame
aStatus
)
;
if
(
aStatus
.
IsInlineBreak
(
)
|
|
(
!
reflowingFirstLetter
&
&
aStatus
.
IsIncomplete
(
)
)
)
{
break
;
}
irs
.
mPrevFrame
=
frame
;
frame
=
frame
-
>
GetNextSibling
(
)
;
}
}
NS_ASSERTION
(
!
aStatus
.
IsComplete
(
)
|
|
!
GetOverflowFrames
(
)
"
We
can
'
t
be
complete
AND
have
overflow
frames
!
"
)
;
aMetrics
.
ISize
(
lineWM
)
=
lineLayout
-
>
EndSpan
(
this
)
;
if
(
(
!
GetPrevContinuation
(
)
&
&
!
FrameIsNonFirstInIBSplit
(
)
)
|
|
boxDecorationBreakClone
)
{
aMetrics
.
ISize
(
lineWM
)
+
=
framePadding
.
IStart
(
frameWM
)
;
}
if
(
(
aStatus
.
IsComplete
(
)
&
&
!
LastInFlow
(
)
-
>
GetNextContinuation
(
)
&
&
!
FrameIsNonLastInIBSplit
(
)
)
|
|
boxDecorationBreakClone
)
{
aMetrics
.
ISize
(
lineWM
)
+
=
framePadding
.
IEnd
(
frameWM
)
;
}
nsLayoutUtils
:
:
SetBSizeFromFontMetrics
(
this
aMetrics
framePadding
lineWM
frameWM
)
;
aMetrics
.
mOverflowAreas
.
Clear
(
)
;
#
ifdef
NOISY_FINAL_SIZE
ListTag
(
stdout
)
;
printf
(
"
:
metrics
=
%
d
%
d
ascent
=
%
d
\
n
"
aMetrics
.
Width
(
)
aMetrics
.
Height
(
)
aMetrics
.
TopAscent
(
)
)
;
#
endif
}
bool
nsInlineFrame
:
:
HasFramesToPull
(
nsInlineFrame
*
aNextInFlow
)
{
while
(
aNextInFlow
)
{
if
(
!
aNextInFlow
-
>
mFrames
.
IsEmpty
(
)
)
{
return
true
;
}
if
(
const
nsFrameList
*
overflow
=
aNextInFlow
-
>
GetOverflowFrames
(
)
)
{
if
(
!
overflow
-
>
IsEmpty
(
)
)
{
return
true
;
}
}
aNextInFlow
=
static_cast
<
nsInlineFrame
*
>
(
aNextInFlow
-
>
GetNextInFlow
(
)
)
;
}
return
false
;
}
void
nsInlineFrame
:
:
ReflowInlineFrame
(
nsPresContext
*
aPresContext
const
ReflowInput
&
aReflowInput
InlineReflowInput
&
irs
nsIFrame
*
aFrame
nsReflowStatus
&
aStatus
)
{
nsLineLayout
*
lineLayout
=
aReflowInput
.
mLineLayout
;
bool
reflowingFirstLetter
=
lineLayout
-
>
GetFirstLetterStyleOK
(
)
;
bool
pushedFrame
;
aStatus
.
Reset
(
)
;
lineLayout
-
>
ReflowFrame
(
aFrame
aStatus
nullptr
pushedFrame
)
;
if
(
aStatus
.
IsInlineBreakBefore
(
)
)
{
if
(
aFrame
!
=
mFrames
.
FirstChild
(
)
)
{
StyleClear
oldClearType
=
aStatus
.
FloatClearType
(
)
;
aStatus
.
Reset
(
)
;
aStatus
.
SetIncomplete
(
)
;
aStatus
.
SetInlineLineBreakAfter
(
oldClearType
)
;
PushFrames
(
aPresContext
aFrame
irs
.
mPrevFrame
irs
)
;
}
else
{
}
return
;
}
if
(
!
aStatus
.
IsFullyComplete
(
)
)
{
CreateNextInFlow
(
aFrame
)
;
}
if
(
aStatus
.
IsInlineBreakAfter
(
)
)
{
nsIFrame
*
nextFrame
=
aFrame
-
>
GetNextSibling
(
)
;
if
(
nextFrame
)
{
aStatus
.
SetIncomplete
(
)
;
PushFrames
(
aPresContext
nextFrame
aFrame
irs
)
;
}
else
{
if
(
HasFramesToPull
(
static_cast
<
nsInlineFrame
*
>
(
GetNextInFlow
(
)
)
)
)
{
aStatus
.
SetIncomplete
(
)
;
}
}
return
;
}
if
(
!
aStatus
.
IsFullyComplete
(
)
&
&
!
reflowingFirstLetter
)
{
nsIFrame
*
nextFrame
=
aFrame
-
>
GetNextSibling
(
)
;
if
(
nextFrame
)
{
PushFrames
(
aPresContext
nextFrame
aFrame
irs
)
;
}
}
}
nsIFrame
*
nsInlineFrame
:
:
PullOneFrame
(
nsPresContext
*
aPresContext
InlineReflowInput
&
irs
)
{
nsIFrame
*
frame
=
nullptr
;
nsInlineFrame
*
nextInFlow
=
irs
.
mNextInFlow
;
#
ifdef
DEBUG
bool
willPull
=
HasFramesToPull
(
nextInFlow
)
;
#
endif
while
(
nextInFlow
)
{
frame
=
nextInFlow
-
>
mFrames
.
FirstChild
(
)
;
if
(
!
frame
)
{
nsFrameList
*
overflowFrames
=
nextInFlow
-
>
GetOverflowFrames
(
)
;
if
(
overflowFrames
)
{
frame
=
overflowFrames
-
>
RemoveFirstChild
(
)
;
if
(
overflowFrames
-
>
IsEmpty
(
)
)
{
nextInFlow
-
>
DestroyOverflowList
(
)
;
}
else
{
}
nextInFlow
-
>
mFrames
.
SetFrames
(
frame
)
;
}
}
if
(
frame
)
{
if
(
irs
.
mLineContainer
&
&
irs
.
mLineContainer
-
>
GetNextContinuation
(
)
)
{
ReparentFloatsForInlineChild
(
irs
.
mLineContainer
frame
false
)
;
}
nextInFlow
-
>
mFrames
.
RemoveFirstChild
(
)
;
mFrames
.
InsertFrame
(
this
irs
.
mPrevFrame
frame
)
;
if
(
irs
.
mLineLayout
)
{
irs
.
mLineLayout
-
>
SetDirtyNextLine
(
)
;
}
nsContainerFrame
:
:
ReparentFrameView
(
frame
nextInFlow
this
)
;
break
;
}
nextInFlow
=
static_cast
<
nsInlineFrame
*
>
(
nextInFlow
-
>
GetNextInFlow
(
)
)
;
irs
.
mNextInFlow
=
nextInFlow
;
}
MOZ_ASSERT
(
!
!
frame
=
=
willPull
)
;
return
frame
;
}
void
nsInlineFrame
:
:
PushFrames
(
nsPresContext
*
aPresContext
nsIFrame
*
aFromChild
nsIFrame
*
aPrevSibling
InlineReflowInput
&
aState
)
{
#
ifdef
NOISY_PUSHING
printf
(
"
%
p
pushing
aFromChild
%
p
disconnecting
from
prev
sib
%
p
\
n
"
this
aFromChild
aPrevSibling
)
;
#
endif
PushChildrenToOverflow
(
aFromChild
aPrevSibling
)
;
if
(
aState
.
mLineLayout
)
{
aState
.
mLineLayout
-
>
SetDirtyNextLine
(
)
;
}
}
LogicalSides
nsInlineFrame
:
:
GetLogicalSkipSides
(
)
const
{
LogicalSides
skip
(
mWritingMode
)
;
if
(
MOZ_UNLIKELY
(
StyleBorder
(
)
-
>
mBoxDecorationBreak
=
=
StyleBoxDecorationBreak
:
:
Clone
)
)
{
return
skip
;
}
if
(
!
IsFirst
(
)
)
{
nsInlineFrame
*
prev
=
(
nsInlineFrame
*
)
GetPrevContinuation
(
)
;
if
(
HasAnyStateBits
(
NS_INLINE_FRAME_BIDI_VISUAL_STATE_IS_SET
)
|
|
(
prev
&
&
(
prev
-
>
mRect
.
height
|
|
prev
-
>
mRect
.
width
)
)
)
{
skip
|
=
eLogicalSideBitsIStart
;
}
else
{
}
}
if
(
!
IsLast
(
)
)
{
nsInlineFrame
*
next
=
(
nsInlineFrame
*
)
GetNextContinuation
(
)
;
if
(
HasAnyStateBits
(
NS_INLINE_FRAME_BIDI_VISUAL_STATE_IS_SET
)
|
|
(
next
&
&
(
next
-
>
mRect
.
height
|
|
next
-
>
mRect
.
width
)
)
)
{
skip
|
=
eLogicalSideBitsIEnd
;
}
else
{
}
}
if
(
HasAnyStateBits
(
NS_FRAME_PART_OF_IBSPLIT
)
)
{
if
(
skip
!
=
LogicalSides
(
mWritingMode
eLogicalSideBitsIBoth
)
)
{
nsIFrame
*
firstContinuation
=
FirstContinuation
(
)
;
if
(
firstContinuation
-
>
FrameIsNonLastInIBSplit
(
)
)
{
skip
|
=
eLogicalSideBitsIEnd
;
}
if
(
firstContinuation
-
>
FrameIsNonFirstInIBSplit
(
)
)
{
skip
|
=
eLogicalSideBitsIStart
;
}
}
}
return
skip
;
}
nscoord
nsInlineFrame
:
:
GetLogicalBaseline
(
mozilla
:
:
WritingMode
aWritingMode
)
const
{
return
mBaseline
;
}
#
ifdef
ACCESSIBILITY
a11y
:
:
AccType
nsInlineFrame
:
:
AccessibleType
(
)
{
if
(
mContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
img
)
)
return
a11y
:
:
eHyperTextType
;
return
a11y
:
:
eNoType
;
}
#
endif
void
nsInlineFrame
:
:
UpdateStyleOfOwnedAnonBoxesForIBSplit
(
ServoRestyleState
&
aRestyleState
)
{
MOZ_ASSERT
(
HasAnyStateBits
(
NS_FRAME_OWNS_ANON_BOXES
)
"
Why
did
we
get
called
?
"
)
;
MOZ_ASSERT
(
HasAnyStateBits
(
NS_FRAME_PART_OF_IBSPLIT
)
"
Why
did
we
have
the
NS_FRAME_OWNS_ANON_BOXES
bit
set
?
"
)
;
MOZ_ASSERT
(
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
this
)
=
=
this
"
Only
the
primary
frame
of
the
inline
in
a
block
-
inside
-
inline
"
"
split
should
have
NS_FRAME_OWNS_ANON_BOXES
"
)
;
MOZ_ASSERT
(
mContent
-
>
GetPrimaryFrame
(
)
=
=
this
"
We
should
be
the
primary
frame
for
our
element
"
)
;
nsIFrame
*
blockFrame
=
GetProperty
(
nsIFrame
:
:
IBSplitSibling
(
)
)
;
MOZ_ASSERT
(
blockFrame
"
Why
did
we
have
an
IB
split
?
"
)
;
ComputedStyle
*
ourStyle
=
Style
(
)
;
RefPtr
<
ComputedStyle
>
newContext
=
aRestyleState
.
StyleSet
(
)
.
ResolveInheritingAnonymousBoxStyle
(
PseudoStyleType
:
:
mozBlockInsideInlineWrapper
ourStyle
)
;
while
(
blockFrame
)
{
MOZ_ASSERT
(
!
blockFrame
-
>
GetPrevContinuation
(
)
"
Must
be
first
continuation
"
)
;
MOZ_ASSERT
(
blockFrame
-
>
Style
(
)
-
>
GetPseudoType
(
)
=
=
PseudoStyleType
:
:
mozBlockInsideInlineWrapper
"
Unexpected
kind
of
ComputedStyle
"
)
;
for
(
nsIFrame
*
cont
=
blockFrame
;
cont
;
cont
=
cont
-
>
GetNextContinuation
(
)
)
{
cont
-
>
SetComputedStyle
(
newContext
)
;
}
nsIFrame
*
nextInline
=
blockFrame
-
>
GetProperty
(
nsIFrame
:
:
IBSplitSibling
(
)
)
;
if
(
MOZ_UNLIKELY
(
!
nextInline
)
)
{
break
;
}
MOZ_ASSERT
(
nextInline
"
There
is
always
a
trailing
inline
in
an
IB
split
"
)
;
for
(
nsIFrame
*
cont
=
nextInline
;
cont
;
cont
=
cont
-
>
GetNextContinuation
(
)
)
{
cont
-
>
SetComputedStyle
(
ourStyle
)
;
}
blockFrame
=
nextInline
-
>
GetProperty
(
nsIFrame
:
:
IBSplitSibling
(
)
)
;
}
}
nsFirstLineFrame
*
NS_NewFirstLineFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsFirstLineFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsFirstLineFrame
)
void
nsFirstLineFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
nsInlineFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
if
(
!
aPrevInFlow
)
{
MOZ_ASSERT
(
Style
(
)
-
>
GetPseudoType
(
)
=
=
PseudoStyleType
:
:
firstLine
)
;
return
;
}
if
(
aPrevInFlow
-
>
Style
(
)
-
>
GetPseudoType
(
)
=
=
PseudoStyleType
:
:
firstLine
)
{
MOZ_ASSERT
(
FirstInFlow
(
)
=
=
aPrevInFlow
)
;
ComputedStyle
*
parentContext
=
aParent
-
>
Style
(
)
;
RefPtr
<
ComputedStyle
>
newSC
=
PresContext
(
)
-
>
StyleSet
(
)
-
>
ResolveInheritingAnonymousBoxStyle
(
PseudoStyleType
:
:
mozLineFrame
parentContext
)
;
SetComputedStyle
(
newSC
)
;
}
else
{
MOZ_ASSERT
(
FirstInFlow
(
)
!
=
aPrevInFlow
)
;
MOZ_ASSERT
(
aPrevInFlow
-
>
Style
(
)
-
>
GetPseudoType
(
)
=
=
PseudoStyleType
:
:
mozLineFrame
)
;
}
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
nsFirstLineFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
u
"
Line
"
_ns
aResult
)
;
}
#
endif
nsIFrame
*
nsFirstLineFrame
:
:
PullOneFrame
(
nsPresContext
*
aPresContext
InlineReflowInput
&
irs
)
{
nsIFrame
*
frame
=
nsInlineFrame
:
:
PullOneFrame
(
aPresContext
irs
)
;
if
(
frame
&
&
!
GetPrevInFlow
(
)
)
{
NS_ASSERTION
(
frame
-
>
GetParent
(
)
=
=
this
"
Incorrect
parent
?
"
)
;
aPresContext
-
>
RestyleManager
(
)
-
>
ReparentComputedStyleForFirstLine
(
frame
)
;
nsLayoutUtils
:
:
MarkDescendantsDirty
(
frame
)
;
}
return
frame
;
}
void
nsFirstLineFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aMetrics
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
if
(
nullptr
=
=
aReflowInput
.
mLineLayout
)
{
return
;
}
nsFirstLineFrame
*
prevInFlow
=
(
nsFirstLineFrame
*
)
GetPrevInFlow
(
)
;
if
(
prevInFlow
)
{
AutoFrameListPtr
prevOverflowFrames
(
aPresContext
prevInFlow
-
>
StealOverflowFrames
(
)
)
;
if
(
prevOverflowFrames
)
{
const
nsFrameList
:
:
Slice
&
newFrames
=
mFrames
.
InsertFrames
(
this
nullptr
std
:
:
move
(
*
prevOverflowFrames
)
)
;
ReparentChildListStyle
(
aPresContext
newFrames
this
)
;
}
}
DrainSelfOverflowList
(
)
;
InlineReflowInput
irs
;
irs
.
mPrevFrame
=
nullptr
;
irs
.
mLineContainer
=
aReflowInput
.
mLineLayout
-
>
LineContainerFrame
(
)
;
irs
.
mLineLayout
=
aReflowInput
.
mLineLayout
;
irs
.
mNextInFlow
=
(
nsInlineFrame
*
)
GetNextInFlow
(
)
;
bool
wasEmpty
=
mFrames
.
IsEmpty
(
)
;
if
(
wasEmpty
)
{
PullOneFrame
(
aPresContext
irs
)
;
}
if
(
nullptr
=
=
GetPrevInFlow
(
)
)
{
irs
.
mPrevFrame
=
mFrames
.
LastChild
(
)
;
for
(
;
;
)
{
nsIFrame
*
frame
=
PullOneFrame
(
aPresContext
irs
)
;
if
(
!
frame
)
{
break
;
}
irs
.
mPrevFrame
=
frame
;
}
irs
.
mPrevFrame
=
nullptr
;
}
NS_ASSERTION
(
!
aReflowInput
.
mLineLayout
-
>
GetInFirstLine
(
)
"
Nested
first
-
line
frames
?
BOGUS
"
)
;
aReflowInput
.
mLineLayout
-
>
SetInFirstLine
(
true
)
;
ReflowFrames
(
aPresContext
aReflowInput
irs
aMetrics
aStatus
)
;
aReflowInput
.
mLineLayout
-
>
SetInFirstLine
(
false
)
;
ReflowAbsoluteFrames
(
aPresContext
aMetrics
aReflowInput
aStatus
)
;
}
void
nsFirstLineFrame
:
:
PullOverflowsFromPrevInFlow
(
)
{
nsFirstLineFrame
*
prevInFlow
=
static_cast
<
nsFirstLineFrame
*
>
(
GetPrevInFlow
(
)
)
;
if
(
prevInFlow
)
{
nsPresContext
*
presContext
=
PresContext
(
)
;
AutoFrameListPtr
prevOverflowFrames
(
presContext
prevInFlow
-
>
StealOverflowFrames
(
)
)
;
if
(
prevOverflowFrames
)
{
const
nsFrameList
:
:
Slice
&
newFrames
=
mFrames
.
InsertFrames
(
this
nullptr
std
:
:
move
(
*
prevOverflowFrames
)
)
;
ReparentChildListStyle
(
presContext
newFrames
this
)
;
}
}
}
bool
nsFirstLineFrame
:
:
DrainSelfOverflowList
(
)
{
AutoFrameListPtr
overflowFrames
(
PresContext
(
)
StealOverflowFrames
(
)
)
;
if
(
overflowFrames
)
{
bool
result
=
!
overflowFrames
-
>
IsEmpty
(
)
;
const
nsFrameList
:
:
Slice
&
newFrames
=
mFrames
.
AppendFrames
(
nullptr
std
:
:
move
(
*
overflowFrames
)
)
;
ReparentChildListStyle
(
PresContext
(
)
newFrames
this
)
;
return
result
;
}
return
false
;
}
