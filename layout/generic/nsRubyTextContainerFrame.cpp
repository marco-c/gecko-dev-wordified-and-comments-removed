#
include
"
nsRubyTextContainerFrame
.
h
"
#
include
"
mozilla
/
ComputedStyle
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
WritingModes
.
h
"
#
include
"
nsLineLayout
.
h
"
#
include
"
nsPresContext
.
h
"
using
namespace
mozilla
;
NS_QUERYFRAME_HEAD
(
nsRubyTextContainerFrame
)
NS_QUERYFRAME_ENTRY
(
nsRubyTextContainerFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsContainerFrame
)
NS_IMPL_FRAMEARENA_HELPERS
(
nsRubyTextContainerFrame
)
nsContainerFrame
*
NS_NewRubyTextContainerFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsRubyTextContainerFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
nsRubyTextContainerFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
NS_LITERAL_STRING
(
"
RubyTextContainer
"
)
aResult
)
;
}
#
endif
bool
nsRubyTextContainerFrame
:
:
IsFrameOfType
(
uint32_t
aFlags
)
const
{
if
(
aFlags
&
(
eSupportsCSSTransforms
|
eSupportsContainLayoutAndPaint
)
)
{
return
false
;
}
return
nsContainerFrame
:
:
IsFrameOfType
(
aFlags
)
;
}
void
nsRubyTextContainerFrame
:
:
SetInitialChildList
(
ChildListID
aListID
nsFrameList
&
aChildList
)
{
nsContainerFrame
:
:
SetInitialChildList
(
aListID
aChildList
)
;
if
(
aListID
=
=
kPrincipalList
)
{
UpdateSpanFlag
(
)
;
}
}
void
nsRubyTextContainerFrame
:
:
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
{
nsContainerFrame
:
:
AppendFrames
(
aListID
aFrameList
)
;
UpdateSpanFlag
(
)
;
}
void
nsRubyTextContainerFrame
:
:
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
aFrameList
)
{
nsContainerFrame
:
:
InsertFrames
(
aListID
aPrevFrame
aFrameList
)
;
UpdateSpanFlag
(
)
;
}
void
nsRubyTextContainerFrame
:
:
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
{
nsContainerFrame
:
:
RemoveFrame
(
aListID
aOldFrame
)
;
UpdateSpanFlag
(
)
;
}
void
nsRubyTextContainerFrame
:
:
UpdateSpanFlag
(
)
{
bool
isSpan
=
false
;
if
(
!
GetPrevContinuation
(
)
&
&
!
GetNextContinuation
(
)
)
{
nsIFrame
*
onlyChild
=
mFrames
.
OnlyChild
(
)
;
if
(
onlyChild
&
&
onlyChild
-
>
IsPseudoFrame
(
GetContent
(
)
)
)
{
isSpan
=
true
;
}
}
if
(
isSpan
)
{
AddStateBits
(
NS_RUBY_TEXT_CONTAINER_IS_SPAN
)
;
}
else
{
RemoveStateBits
(
NS_RUBY_TEXT_CONTAINER_IS_SPAN
)
;
}
}
void
nsRubyTextContainerFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsRubyTextContainerFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aDesiredSize
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
WritingMode
rtcWM
=
GetWritingMode
(
)
;
nscoord
minBCoord
=
nscoord_MAX
;
nscoord
maxBCoord
=
nscoord_MIN
;
const
nsSize
dummyContainerSize
;
for
(
nsFrameList
:
:
Enumerator
e
(
mFrames
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
)
{
nsIFrame
*
child
=
e
.
get
(
)
;
MOZ_ASSERT
(
child
-
>
IsRubyTextFrame
(
)
)
;
LogicalRect
rect
=
child
-
>
GetLogicalRect
(
rtcWM
dummyContainerSize
)
;
LogicalMargin
margin
=
child
-
>
GetLogicalUsedMargin
(
rtcWM
)
;
nscoord
blockStart
=
rect
.
BStart
(
rtcWM
)
-
margin
.
BStart
(
rtcWM
)
;
minBCoord
=
std
:
:
min
(
minBCoord
blockStart
)
;
nscoord
blockEnd
=
rect
.
BEnd
(
rtcWM
)
+
margin
.
BEnd
(
rtcWM
)
;
maxBCoord
=
std
:
:
max
(
maxBCoord
blockEnd
)
;
}
LogicalSize
size
(
rtcWM
mISize
0
)
;
if
(
!
mFrames
.
IsEmpty
(
)
)
{
if
(
MOZ_UNLIKELY
(
minBCoord
>
maxBCoord
)
)
{
NS_WARNING
(
"
bad
block
coord
"
)
;
minBCoord
=
maxBCoord
=
0
;
}
size
.
BSize
(
rtcWM
)
=
maxBCoord
-
minBCoord
;
nsSize
containerSize
=
size
.
GetPhysicalSize
(
rtcWM
)
;
for
(
nsFrameList
:
:
Enumerator
e
(
mFrames
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
)
{
nsIFrame
*
child
=
e
.
get
(
)
;
LogicalPoint
pos
=
child
-
>
GetLogicalPosition
(
rtcWM
dummyContainerSize
)
;
pos
.
B
(
rtcWM
)
-
=
minBCoord
;
child
-
>
SetPosition
(
rtcWM
pos
containerSize
)
;
nsContainerFrame
:
:
PlaceFrameView
(
child
)
;
}
}
aDesiredSize
.
SetSize
(
rtcWM
size
)
;
}
