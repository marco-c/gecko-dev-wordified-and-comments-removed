#
include
"
ScrollAnchorContainer
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
mozilla
/
StaticPrefs
.
h
"
#
include
"
mozilla
/
ToString
.
h
"
#
include
"
nsGfxScrollFrame
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
define
ANCHOR_LOG
(
.
.
.
)
namespace
mozilla
{
namespace
layout
{
ScrollAnchorContainer
:
:
ScrollAnchorContainer
(
ScrollFrameHelper
*
aScrollFrame
)
:
mScrollFrame
(
aScrollFrame
)
mAnchorNode
(
nullptr
)
mLastAnchorOffset
(
0
)
mAnchorNodeIsDirty
(
true
)
mApplyingAnchorAdjustment
(
false
)
mSuppressAnchorAdjustment
(
false
)
{
}
ScrollAnchorContainer
:
:
~
ScrollAnchorContainer
(
)
{
}
ScrollAnchorContainer
*
ScrollAnchorContainer
:
:
FindFor
(
nsIFrame
*
aFrame
)
{
aFrame
=
aFrame
-
>
GetParent
(
)
;
if
(
!
aFrame
)
{
return
nullptr
;
}
nsIScrollableFrame
*
nearest
=
nsLayoutUtils
:
:
GetNearestScrollableFrame
(
aFrame
nsLayoutUtils
:
:
SCROLLABLE_SAME_DOC
|
nsLayoutUtils
:
:
SCROLLABLE_INCLUDE_HIDDEN
)
;
if
(
nearest
)
{
return
nearest
-
>
GetAnchor
(
)
;
}
return
nullptr
;
}
nsIFrame
*
ScrollAnchorContainer
:
:
Frame
(
)
const
{
return
mScrollFrame
-
>
mOuter
;
}
nsIScrollableFrame
*
ScrollAnchorContainer
:
:
ScrollableFrame
(
)
const
{
return
Frame
(
)
-
>
GetScrollTargetFrame
(
)
;
}
static
void
SetAnchorFlags
(
const
nsIFrame
*
aScrolledFrame
nsIFrame
*
aAnchorNode
bool
aInScrollAnchorChain
)
{
nsIFrame
*
frame
=
aAnchorNode
;
while
(
frame
&
&
frame
!
=
aScrolledFrame
)
{
MOZ_ASSERT
(
frame
=
=
aAnchorNode
|
|
!
frame
-
>
IsScrollFrame
(
)
"
We
shouldn
'
t
select
an
anchor
node
inside
a
nested
scroll
frame
.
"
)
;
frame
-
>
SetInScrollAnchorChain
(
aInScrollAnchorChain
)
;
frame
=
frame
-
>
GetParent
(
)
;
}
MOZ_ASSERT
(
frame
"
The
anchor
node
should
be
a
descendant
of
the
scroll
frame
"
)
;
if
(
StaticPrefs
:
:
layout_css_scroll_anchoring_highlight
(
)
)
{
for
(
nsIFrame
*
frame
=
aAnchorNode
-
>
FirstContinuation
(
)
;
!
!
frame
;
frame
=
frame
-
>
GetNextContinuation
(
)
)
{
frame
-
>
InvalidateFrame
(
)
;
}
}
}
static
nsRect
FindScrollAnchoringBoundingRect
(
const
nsIFrame
*
aScrollFrame
nsIFrame
*
aCandidate
)
{
MOZ_ASSERT
(
nsLayoutUtils
:
:
IsProperAncestorFrame
(
aScrollFrame
aCandidate
)
)
;
if
(
!
!
Text
:
:
FromNodeOrNull
(
aCandidate
-
>
GetContent
(
)
)
)
{
nsIFrame
*
blockAncestor
=
nsLayoutUtils
:
:
FindNearestBlockAncestor
(
aCandidate
)
;
MOZ_ASSERT
(
nsLayoutUtils
:
:
IsProperAncestorFrame
(
aScrollFrame
blockAncestor
)
)
;
nsRect
bounding
;
for
(
nsIFrame
*
continuation
=
aCandidate
-
>
FirstContinuation
(
)
;
continuation
;
continuation
=
continuation
-
>
GetNextContinuation
(
)
)
{
nsRect
overflowRect
=
continuation
-
>
GetScrollableOverflowRectRelativeToSelf
(
)
;
overflowRect
+
=
continuation
-
>
GetOffsetTo
(
blockAncestor
)
;
bounding
=
bounding
.
Union
(
overflowRect
)
;
}
return
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
blockAncestor
bounding
aScrollFrame
)
;
}
nsRect
borderRect
=
aCandidate
-
>
GetRectRelativeToSelf
(
)
;
nsRect
overflowRect
=
aCandidate
-
>
GetScrollableOverflowRectRelativeToSelf
(
)
;
NS_ASSERTION
(
overflowRect
.
Contains
(
borderRect
)
"
overflow
rect
must
include
border
rect
and
the
clamping
logic
"
"
here
depends
on
that
"
)
;
WritingMode
writingMode
=
aScrollFrame
-
>
GetWritingMode
(
)
;
switch
(
writingMode
.
GetBlockDir
(
)
)
{
case
WritingMode
:
:
eBlockTB
:
{
overflowRect
.
SetBoxY
(
borderRect
.
Y
(
)
overflowRect
.
YMost
(
)
)
;
break
;
}
case
WritingMode
:
:
eBlockLR
:
{
overflowRect
.
SetBoxX
(
borderRect
.
X
(
)
overflowRect
.
XMost
(
)
)
;
break
;
}
case
WritingMode
:
:
eBlockRL
:
{
overflowRect
.
SetBoxX
(
overflowRect
.
X
(
)
borderRect
.
XMost
(
)
)
;
break
;
}
}
nsRect
transformed
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
aCandidate
overflowRect
aScrollFrame
)
;
return
transformed
;
}
static
nscoord
FindScrollAnchoringBoundingOffset
(
const
ScrollFrameHelper
*
aScrollFrame
nsIFrame
*
aCandidate
)
{
WritingMode
writingMode
=
aScrollFrame
-
>
mOuter
-
>
GetWritingMode
(
)
;
nsRect
physicalBounding
=
FindScrollAnchoringBoundingRect
(
aScrollFrame
-
>
mOuter
aCandidate
)
;
LogicalRect
logicalBounding
(
writingMode
physicalBounding
aScrollFrame
-
>
mScrolledFrame
-
>
GetSize
(
)
)
;
return
logicalBounding
.
BStart
(
writingMode
)
;
}
void
ScrollAnchorContainer
:
:
SelectAnchor
(
)
{
MOZ_ASSERT
(
mScrollFrame
-
>
mScrolledFrame
)
;
MOZ_ASSERT
(
mAnchorNodeIsDirty
)
;
if
(
!
StaticPrefs
:
:
layout_css_scroll_anchoring_enabled
(
)
)
{
return
;
}
AUTO_PROFILER_LABEL
(
"
ScrollAnchorContainer
:
:
SelectAnchor
"
LAYOUT
)
;
ANCHOR_LOG
(
"
Selecting
anchor
for
%
p
with
scroll
-
port
=
%
s
.
\
n
"
this
mozilla
:
:
ToString
(
mScrollFrame
-
>
GetVisualOptimalViewingRect
(
)
)
.
c_str
(
)
)
;
const
nsStyleDisplay
*
disp
=
Frame
(
)
-
>
StyleDisplay
(
)
;
bool
overflowAnchor
=
disp
-
>
mOverflowAnchor
=
=
mozilla
:
:
StyleOverflowAnchor
:
:
Auto
;
bool
isScrolled
=
mScrollFrame
-
>
GetLogicalScrollPosition
(
)
!
=
nsPoint
(
)
;
bool
hasPerspective
=
Frame
(
)
-
>
ChildrenHavePerspective
(
)
;
nsIFrame
*
oldAnchor
=
mAnchorNode
;
if
(
overflowAnchor
&
&
isScrolled
&
&
!
hasPerspective
)
{
ANCHOR_LOG
(
"
Beginning
candidate
selection
.
\
n
"
)
;
mAnchorNode
=
FindAnchorIn
(
mScrollFrame
-
>
mScrolledFrame
)
;
}
else
{
if
(
!
overflowAnchor
)
{
ANCHOR_LOG
(
"
Skipping
candidate
selection
for
overflow
-
anchor
:
none
\
n
"
)
;
}
if
(
!
isScrolled
)
{
ANCHOR_LOG
(
"
Skipping
candidate
selection
for
not
being
scrolled
\
n
"
)
;
}
if
(
hasPerspective
)
{
ANCHOR_LOG
(
"
Skipping
candidate
selection
for
scroll
frame
with
perspective
\
n
"
)
;
}
mAnchorNode
=
nullptr
;
}
if
(
oldAnchor
!
=
mAnchorNode
)
{
ANCHOR_LOG
(
"
Anchor
node
has
changed
from
(
%
p
)
to
(
%
p
)
.
\
n
"
oldAnchor
mAnchorNode
)
;
if
(
oldAnchor
)
{
SetAnchorFlags
(
mScrollFrame
-
>
mScrolledFrame
oldAnchor
false
)
;
}
if
(
mAnchorNode
)
{
SetAnchorFlags
(
mScrollFrame
-
>
mScrolledFrame
mAnchorNode
true
)
;
}
}
else
{
ANCHOR_LOG
(
"
Anchor
node
has
remained
(
%
p
)
.
\
n
"
mAnchorNode
)
;
}
if
(
mAnchorNode
)
{
mLastAnchorOffset
=
FindScrollAnchoringBoundingOffset
(
mScrollFrame
mAnchorNode
)
;
ANCHOR_LOG
(
"
Using
last
anchor
offset
=
%
d
.
\
n
"
mLastAnchorOffset
)
;
}
else
{
mLastAnchorOffset
=
0
;
}
mAnchorNodeIsDirty
=
false
;
}
void
ScrollAnchorContainer
:
:
UserScrolled
(
)
{
if
(
mApplyingAnchorAdjustment
)
{
return
;
}
InvalidateAnchor
(
)
;
}
void
ScrollAnchorContainer
:
:
SuppressAdjustments
(
)
{
ANCHOR_LOG
(
"
Received
a
scroll
anchor
suppression
for
%
p
.
\
n
"
this
)
;
mSuppressAnchorAdjustment
=
true
;
}
void
ScrollAnchorContainer
:
:
InvalidateAnchor
(
)
{
ANCHOR_LOG
(
"
Invalidating
scroll
anchor
%
p
for
%
p
.
\
n
"
mAnchorNode
this
)
;
if
(
mAnchorNode
)
{
SetAnchorFlags
(
mScrollFrame
-
>
mScrolledFrame
mAnchorNode
false
)
;
}
mAnchorNode
=
nullptr
;
mAnchorNodeIsDirty
=
true
;
mLastAnchorOffset
=
0
;
if
(
!
StaticPrefs
:
:
layout_css_scroll_anchoring_enabled
(
)
)
{
return
;
}
Frame
(
)
-
>
PresShell
(
)
-
>
PostPendingScrollAnchorSelection
(
this
)
;
}
void
ScrollAnchorContainer
:
:
Destroy
(
)
{
if
(
mAnchorNode
)
{
SetAnchorFlags
(
mScrollFrame
-
>
mScrolledFrame
mAnchorNode
false
)
;
}
mAnchorNode
=
nullptr
;
mAnchorNodeIsDirty
=
false
;
mLastAnchorOffset
=
0
;
}
void
ScrollAnchorContainer
:
:
ApplyAdjustments
(
)
{
if
(
!
mAnchorNode
|
|
mAnchorNodeIsDirty
)
{
mSuppressAnchorAdjustment
=
false
;
ANCHOR_LOG
(
"
Ignoring
post
-
reflow
(
anchor
=
%
p
dirty
=
%
d
container
=
%
p
)
.
\
n
"
mAnchorNode
mAnchorNodeIsDirty
this
)
;
return
;
}
nscoord
current
=
FindScrollAnchoringBoundingOffset
(
mScrollFrame
mAnchorNode
)
;
nscoord
logicalAdjustment
=
current
-
mLastAnchorOffset
;
WritingMode
writingMode
=
Frame
(
)
-
>
GetWritingMode
(
)
;
ANCHOR_LOG
(
"
Anchor
has
moved
from
%
d
to
%
d
.
\
n
"
mLastAnchorOffset
current
)
;
if
(
logicalAdjustment
=
=
0
)
{
ANCHOR_LOG
(
"
Ignoring
zero
delta
anchor
adjustment
for
%
p
.
\
n
"
this
)
;
mSuppressAnchorAdjustment
=
false
;
return
;
}
if
(
mSuppressAnchorAdjustment
)
{
ANCHOR_LOG
(
"
Applying
anchor
adjustment
suppression
for
%
p
.
\
n
"
this
)
;
mSuppressAnchorAdjustment
=
false
;
InvalidateAnchor
(
)
;
return
;
}
ANCHOR_LOG
(
"
Applying
anchor
adjustment
of
%
d
in
%
s
for
%
p
and
anchor
%
p
.
\
n
"
logicalAdjustment
writingMode
.
DebugString
(
)
this
mAnchorNode
)
;
nsPoint
physicalAdjustment
;
switch
(
writingMode
.
GetBlockDir
(
)
)
{
case
WritingMode
:
:
eBlockTB
:
{
physicalAdjustment
.
y
=
logicalAdjustment
;
break
;
}
case
WritingMode
:
:
eBlockLR
:
{
physicalAdjustment
.
x
=
logicalAdjustment
;
break
;
}
case
WritingMode
:
:
eBlockRL
:
{
physicalAdjustment
.
x
=
-
logicalAdjustment
;
break
;
}
}
MOZ_ASSERT
(
!
mApplyingAnchorAdjustment
)
;
mApplyingAnchorAdjustment
=
true
;
mScrollFrame
-
>
ScrollTo
(
mScrollFrame
-
>
GetScrollPosition
(
)
+
physicalAdjustment
nsIScrollableFrame
:
:
INSTANT
nsGkAtoms
:
:
relative
)
;
mApplyingAnchorAdjustment
=
false
;
nsPresContext
*
pc
=
Frame
(
)
-
>
PresContext
(
)
;
Document
*
doc
=
pc
-
>
Document
(
)
;
doc
-
>
UpdateForScrollAnchorAdjustment
(
logicalAdjustment
)
;
mLastAnchorOffset
=
FindScrollAnchoringBoundingOffset
(
mScrollFrame
mAnchorNode
)
;
}
ScrollAnchorContainer
:
:
ExamineResult
ScrollAnchorContainer
:
:
ExamineAnchorCandidate
(
nsIFrame
*
aFrame
)
const
{
#
ifdef
DEBUG_FRAME_DUMP
nsCString
tag
=
aFrame
-
>
ListTag
(
)
;
ANCHOR_LOG
(
"
\
tVisiting
frame
=
%
s
(
%
p
)
.
\
n
"
tag
.
get
(
)
aFrame
)
;
#
else
ANCHOR_LOG
(
"
\
t
\
tVisiting
frame
=
%
p
.
\
n
"
aFrame
)
;
#
endif
bool
isText
=
!
!
Text
:
:
FromNodeOrNull
(
aFrame
-
>
GetContent
(
)
)
;
bool
isContinuation
=
!
!
aFrame
-
>
GetPrevContinuation
(
)
;
if
(
isText
&
&
isContinuation
)
{
ANCHOR_LOG
(
"
\
t
\
tExcluding
continuation
text
node
.
\
n
"
)
;
return
ExamineResult
:
:
Exclude
;
}
const
nsStyleDisplay
*
disp
=
aFrame
-
>
StyleDisplay
(
)
;
if
(
disp
-
>
mOverflowAnchor
=
=
mozilla
:
:
StyleOverflowAnchor
:
:
None
)
{
ANCHOR_LOG
(
"
\
t
\
tExcluding
overflow
-
anchor
:
none
.
\
n
"
)
;
return
ExamineResult
:
:
Exclude
;
}
if
(
aFrame
-
>
IsStickyPositioned
(
)
)
{
ANCHOR_LOG
(
"
\
t
\
tExcluding
position
:
sticky
.
\
n
"
)
;
return
ExamineResult
:
:
Exclude
;
}
if
(
aFrame
-
>
IsBrFrame
(
)
)
{
ANCHOR_LOG
(
"
\
t
\
tExcluding
<
br
>
.
\
n
"
)
;
return
ExamineResult
:
:
Exclude
;
}
bool
isChrome
=
aFrame
-
>
GetContent
(
)
&
&
aFrame
-
>
GetContent
(
)
-
>
ChromeOnlyAccess
(
)
;
bool
isPseudo
=
aFrame
-
>
Style
(
)
-
>
IsPseudoElement
(
)
;
if
(
isChrome
&
&
!
isPseudo
)
{
ANCHOR_LOG
(
"
\
t
\
tExcluding
chrome
only
content
.
\
n
"
)
;
return
ExamineResult
:
:
Exclude
;
}
nsIScrollableFrame
*
scrollable
=
do_QueryFrame
(
aFrame
)
;
bool
canDescend
=
!
scrollable
&
&
!
aFrame
-
>
IsSVGOuterSVGFrame
(
)
;
bool
isBlockOutside
=
aFrame
-
>
IsBlockOutside
(
)
;
bool
isAnonBox
=
aFrame
-
>
Style
(
)
-
>
IsAnonBox
(
)
&
&
!
isText
;
bool
isInlineOutside
=
aFrame
-
>
IsInlineOutside
(
)
&
&
!
isText
;
if
(
(
isAnonBox
|
|
isInlineOutside
)
&
&
canDescend
)
{
ANCHOR_LOG
(
"
\
t
\
tSearching
descendants
of
anon
or
inline
box
(
a
=
%
d
i
=
%
d
)
.
\
n
"
isAnonBox
isInlineOutside
)
;
return
ExamineResult
:
:
PassThrough
;
}
if
(
!
isBlockOutside
&
&
!
isText
)
{
ANCHOR_LOG
(
"
\
t
\
tExcluding
non
block
-
outside
or
text
node
(
b
=
%
d
t
=
%
d
)
.
\
n
"
isBlockOutside
isText
)
;
return
ExamineResult
:
:
Exclude
;
}
nsRect
rect
=
FindScrollAnchoringBoundingRect
(
Frame
(
)
aFrame
)
;
ANCHOR_LOG
(
"
\
t
\
trect
=
[
%
d
%
d
x
%
d
%
d
]
.
\
n
"
rect
.
x
rect
.
y
rect
.
width
rect
.
height
)
;
nsRect
visibleRect
;
if
(
!
visibleRect
.
IntersectRect
(
rect
mScrollFrame
-
>
GetVisualOptimalViewingRect
(
)
)
)
{
return
ExamineResult
:
:
Exclude
;
}
if
(
canDescend
&
&
isContinuation
)
{
ANCHOR_LOG
(
"
\
t
\
tSearching
descendants
of
a
continuation
.
\
n
"
)
;
return
ExamineResult
:
:
PassThrough
;
}
if
(
visibleRect
.
IsEqualEdges
(
rect
)
)
{
ANCHOR_LOG
(
"
\
t
\
tFully
visible
taking
.
\
n
"
)
;
return
ExamineResult
:
:
Accept
;
}
if
(
!
canDescend
)
{
ANCHOR_LOG
(
"
\
t
\
tIntersects
a
frame
that
we
can
'
t
descend
into
taking
.
\
n
"
)
;
return
ExamineResult
:
:
Accept
;
}
ANCHOR_LOG
(
"
\
t
\
tIntersects
valid
candidate
checking
descendants
.
\
n
"
)
;
return
ExamineResult
:
:
Traverse
;
}
nsIFrame
*
ScrollAnchorContainer
:
:
FindAnchorIn
(
nsIFrame
*
aFrame
)
const
{
for
(
nsIFrame
:
:
ChildListIterator
lists
(
aFrame
)
;
!
lists
.
IsDone
(
)
;
lists
.
Next
(
)
)
{
if
(
lists
.
CurrentID
(
)
=
=
FrameChildListID
:
:
kAbsoluteList
|
|
lists
.
CurrentID
(
)
=
=
FrameChildListID
:
:
kFixedList
|
|
lists
.
CurrentID
(
)
=
=
FrameChildListID
:
:
kFloatList
|
|
lists
.
CurrentID
(
)
=
=
FrameChildListID
:
:
kOverflowOutOfFlowList
)
{
continue
;
}
if
(
nsIFrame
*
anchor
=
FindAnchorInList
(
lists
.
CurrentList
(
)
)
)
{
return
anchor
;
}
}
const
nsFrameList
&
absPosList
=
aFrame
-
>
GetChildList
(
FrameChildListID
:
:
kAbsoluteList
)
;
if
(
nsIFrame
*
anchor
=
FindAnchorInList
(
absPosList
)
)
{
return
anchor
;
}
return
nullptr
;
}
nsIFrame
*
ScrollAnchorContainer
:
:
FindAnchorInList
(
const
nsFrameList
&
aFrameList
)
const
{
for
(
nsIFrame
*
child
:
aFrameList
)
{
nsIFrame
*
realFrame
=
nsPlaceholderFrame
:
:
GetRealFrameFor
(
child
)
;
if
(
child
!
=
realFrame
)
{
if
(
!
nsLayoutUtils
:
:
IsProperAncestorFrame
(
Frame
(
)
realFrame
)
)
{
ANCHOR_LOG
(
"
\
t
\
tSkipping
out
of
flow
frame
that
is
not
a
descendant
of
the
"
"
scroll
frame
.
\
n
"
)
;
continue
;
}
ANCHOR_LOG
(
"
\
t
\
tFollowing
placeholder
to
out
of
flow
frame
.
\
n
"
)
;
child
=
realFrame
;
}
ExamineResult
examine
=
ExamineAnchorCandidate
(
child
)
;
switch
(
examine
)
{
case
ExamineResult
:
:
Exclude
:
{
continue
;
}
case
ExamineResult
:
:
PassThrough
:
{
nsIFrame
*
candidate
=
FindAnchorIn
(
child
)
;
if
(
!
candidate
)
{
continue
;
}
return
candidate
;
}
case
ExamineResult
:
:
Traverse
:
{
nsIFrame
*
candidate
=
FindAnchorIn
(
child
)
;
if
(
!
candidate
)
{
return
child
;
}
return
candidate
;
}
case
ExamineResult
:
:
Accept
:
{
return
child
;
}
}
}
return
nullptr
;
}
}
}
