#
include
"
ScrollAnchorContainer
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
mozilla
/
StaticPrefs
.
h
"
#
include
"
nsGfxScrollFrame
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
define
ANCHOR_LOG
(
.
.
.
)
namespace
mozilla
{
namespace
layout
{
ScrollAnchorContainer
:
:
ScrollAnchorContainer
(
ScrollFrameHelper
*
aScrollFrame
)
:
mScrollFrame
(
aScrollFrame
)
mAnchorNode
(
nullptr
)
mLastAnchorPos
(
0
0
)
mAnchorNodeIsDirty
(
true
)
mApplyingAnchorAdjustment
(
false
)
mSuppressAnchorAdjustment
(
false
)
{
}
ScrollAnchorContainer
:
:
~
ScrollAnchorContainer
(
)
{
}
ScrollAnchorContainer
*
ScrollAnchorContainer
:
:
FindFor
(
nsIFrame
*
aFrame
)
{
aFrame
=
aFrame
-
>
GetParent
(
)
;
if
(
!
aFrame
)
{
return
nullptr
;
}
nsIScrollableFrame
*
nearest
=
nsLayoutUtils
:
:
GetNearestScrollableFrame
(
aFrame
nsLayoutUtils
:
:
SCROLLABLE_SAME_DOC
|
nsLayoutUtils
:
:
SCROLLABLE_INCLUDE_HIDDEN
)
;
if
(
nearest
)
{
return
nearest
-
>
GetAnchor
(
)
;
}
return
nullptr
;
}
nsIFrame
*
ScrollAnchorContainer
:
:
Frame
(
)
const
{
return
mScrollFrame
-
>
mOuter
;
}
nsIScrollableFrame
*
ScrollAnchorContainer
:
:
ScrollableFrame
(
)
const
{
return
Frame
(
)
-
>
GetScrollTargetFrame
(
)
;
}
static
void
SetAnchorFlags
(
const
nsIFrame
*
aScrolledFrame
nsIFrame
*
aAnchorNode
bool
aInScrollAnchorChain
)
{
nsIFrame
*
frame
=
aAnchorNode
;
while
(
frame
&
&
frame
!
=
aScrolledFrame
)
{
MOZ_ASSERT
(
frame
=
=
aAnchorNode
|
|
!
frame
-
>
IsScrollFrame
(
)
"
We
shouldn
'
t
select
an
anchor
node
inside
a
nested
scroll
frame
.
"
)
;
frame
-
>
SetInScrollAnchorChain
(
aInScrollAnchorChain
)
;
frame
=
frame
-
>
GetParent
(
)
;
}
MOZ_ASSERT
(
frame
"
The
anchor
node
should
be
a
descendant
of
the
scroll
frame
"
)
;
if
(
StaticPrefs
:
:
layout_css_scroll_anchoring_highlight
(
)
)
{
for
(
nsIFrame
*
frame
=
aAnchorNode
-
>
FirstContinuation
(
)
;
!
!
frame
;
frame
=
frame
-
>
GetNextContinuation
(
)
)
{
frame
-
>
InvalidateFrame
(
)
;
}
}
}
static
nsRect
FindScrollAnchoringBoundingRect
(
const
nsIFrame
*
aScrollFrame
nsIFrame
*
aCandidate
)
{
MOZ_ASSERT
(
nsLayoutUtils
:
:
IsProperAncestorFrame
(
aScrollFrame
aCandidate
)
)
;
if
(
!
!
Text
:
:
FromNodeOrNull
(
aCandidate
-
>
GetContent
(
)
)
)
{
nsRect
bounding
;
for
(
nsIFrame
*
continuation
=
aCandidate
-
>
FirstContinuation
(
)
;
continuation
;
continuation
=
continuation
-
>
GetNextContinuation
(
)
)
{
nsRect
localRect
=
continuation
-
>
GetScrollableOverflowRectRelativeToSelf
(
)
;
nsRect
transformed
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
continuation
localRect
aScrollFrame
)
;
bounding
=
bounding
.
Union
(
transformed
)
;
}
return
bounding
;
}
nsRect
localRect
=
aCandidate
-
>
GetScrollableOverflowRectRelativeToSelf
(
)
;
if
(
localRect
.
X
(
)
<
0
)
{
localRect
.
SetBoxX
(
0
localRect
.
XMost
(
)
)
;
}
if
(
localRect
.
Y
(
)
<
0
)
{
localRect
.
SetBoxY
(
0
localRect
.
YMost
(
)
)
;
}
nsRect
transformed
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
aCandidate
localRect
aScrollFrame
)
;
return
transformed
;
}
void
ScrollAnchorContainer
:
:
SelectAnchor
(
)
{
MOZ_ASSERT
(
mScrollFrame
-
>
mScrolledFrame
)
;
MOZ_ASSERT
(
mAnchorNodeIsDirty
)
;
if
(
!
StaticPrefs
:
:
layout_css_scroll_anchoring_enabled
(
)
)
{
return
;
}
AUTO_PROFILER_LABEL
(
"
ScrollAnchorContainer
:
:
SelectAnchor
"
LAYOUT
)
;
ANCHOR_LOG
(
"
Selecting
anchor
for
%
p
with
scroll
-
port
[
%
d
%
d
x
%
d
%
d
]
.
\
n
"
this
mScrollFrame
-
>
mScrollPort
.
x
mScrollFrame
-
>
mScrollPort
.
y
mScrollFrame
-
>
mScrollPort
.
width
mScrollFrame
-
>
mScrollPort
.
height
)
;
const
nsStyleDisplay
*
disp
=
Frame
(
)
-
>
StyleDisplay
(
)
;
bool
overflowAnchor
=
disp
-
>
mOverflowAnchor
=
=
mozilla
:
:
StyleOverflowAnchor
:
:
Auto
;
bool
isScrolled
=
mScrollFrame
-
>
GetLogicalScrollPosition
(
)
!
=
nsPoint
(
)
;
bool
hasPerspective
=
Frame
(
)
-
>
ChildrenHavePerspective
(
)
;
nsIFrame
*
oldAnchor
=
mAnchorNode
;
if
(
overflowAnchor
&
&
isScrolled
&
&
!
hasPerspective
)
{
ANCHOR_LOG
(
"
Beginning
candidate
selection
.
\
n
"
)
;
mAnchorNode
=
FindAnchorIn
(
mScrollFrame
-
>
mScrolledFrame
)
;
}
else
{
if
(
!
overflowAnchor
)
{
ANCHOR_LOG
(
"
Skipping
candidate
selection
for
overflow
-
anchor
:
none
\
n
"
)
;
}
if
(
!
isScrolled
)
{
ANCHOR_LOG
(
"
Skipping
candidate
selection
for
not
being
scrolled
\
n
"
)
;
}
if
(
hasPerspective
)
{
ANCHOR_LOG
(
"
Skipping
candidate
selection
for
scroll
frame
with
perspective
\
n
"
)
;
}
mAnchorNode
=
nullptr
;
}
if
(
oldAnchor
!
=
mAnchorNode
)
{
ANCHOR_LOG
(
"
Anchor
node
has
changed
from
(
%
p
)
to
(
%
p
)
.
\
n
"
oldAnchor
mAnchorNode
)
;
if
(
oldAnchor
)
{
SetAnchorFlags
(
mScrollFrame
-
>
mScrolledFrame
oldAnchor
false
)
;
}
if
(
mAnchorNode
)
{
SetAnchorFlags
(
mScrollFrame
-
>
mScrolledFrame
mAnchorNode
true
)
;
}
}
else
{
ANCHOR_LOG
(
"
Anchor
node
has
remained
(
%
p
)
.
\
n
"
mAnchorNode
)
;
}
if
(
mAnchorNode
)
{
mLastAnchorPos
=
FindScrollAnchoringBoundingRect
(
Frame
(
)
mAnchorNode
)
.
TopLeft
(
)
;
ANCHOR_LOG
(
"
Using
last
anchor
position
=
[
%
d
%
d
]
.
\
n
"
mLastAnchorPos
.
x
mLastAnchorPos
.
y
)
;
}
else
{
mLastAnchorPos
=
nsPoint
(
)
;
}
mAnchorNodeIsDirty
=
false
;
}
void
ScrollAnchorContainer
:
:
UserScrolled
(
)
{
if
(
mApplyingAnchorAdjustment
)
{
return
;
}
InvalidateAnchor
(
)
;
}
void
ScrollAnchorContainer
:
:
SuppressAdjustments
(
)
{
ANCHOR_LOG
(
"
Received
a
scroll
anchor
suppression
for
%
p
.
\
n
"
this
)
;
mSuppressAnchorAdjustment
=
true
;
}
void
ScrollAnchorContainer
:
:
InvalidateAnchor
(
)
{
if
(
!
StaticPrefs
:
:
layout_css_scroll_anchoring_enabled
(
)
)
{
return
;
}
ANCHOR_LOG
(
"
Invalidating
scroll
anchor
%
p
for
%
p
.
\
n
"
mAnchorNode
this
)
;
if
(
mAnchorNode
)
{
SetAnchorFlags
(
mScrollFrame
-
>
mScrolledFrame
mAnchorNode
false
)
;
}
mAnchorNode
=
nullptr
;
mAnchorNodeIsDirty
=
true
;
mLastAnchorPos
=
nsPoint
(
)
;
Frame
(
)
-
>
PresShell
(
)
-
>
PostPendingScrollAnchorSelection
(
this
)
;
}
void
ScrollAnchorContainer
:
:
Destroy
(
)
{
if
(
mAnchorNode
)
{
SetAnchorFlags
(
mScrollFrame
-
>
mScrolledFrame
mAnchorNode
false
)
;
}
mAnchorNode
=
nullptr
;
mAnchorNodeIsDirty
=
false
;
mLastAnchorPos
=
nsPoint
(
)
;
}
void
ScrollAnchorContainer
:
:
ApplyAdjustments
(
)
{
if
(
!
mAnchorNode
|
|
mAnchorNodeIsDirty
)
{
mSuppressAnchorAdjustment
=
false
;
ANCHOR_LOG
(
"
Ignoring
post
-
reflow
(
anchor
=
%
p
dirty
=
%
d
container
=
%
p
)
.
\
n
"
mAnchorNode
mAnchorNodeIsDirty
this
)
;
return
;
}
nsPoint
current
=
FindScrollAnchoringBoundingRect
(
Frame
(
)
mAnchorNode
)
.
TopLeft
(
)
;
nsPoint
adjustment
=
current
-
mLastAnchorPos
;
nsIntPoint
adjustmentDevicePixels
=
adjustment
.
ToNearestPixels
(
Frame
(
)
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
ANCHOR_LOG
(
"
Anchor
has
moved
from
[
%
d
%
d
]
to
[
%
d
%
d
]
.
\
n
"
mLastAnchorPos
.
x
mLastAnchorPos
.
y
current
.
x
current
.
y
)
;
WritingMode
writingMode
=
Frame
(
)
-
>
GetWritingMode
(
)
;
if
(
writingMode
.
IsVertical
(
)
)
{
adjustmentDevicePixels
.
y
=
0
;
}
else
{
adjustmentDevicePixels
.
x
=
0
;
}
if
(
adjustmentDevicePixels
=
=
nsIntPoint
(
)
)
{
ANCHOR_LOG
(
"
Ignoring
zero
delta
anchor
adjustment
for
%
p
.
\
n
"
this
)
;
mSuppressAnchorAdjustment
=
false
;
return
;
}
if
(
mSuppressAnchorAdjustment
)
{
ANCHOR_LOG
(
"
Applying
anchor
adjustment
suppression
for
%
p
.
\
n
"
this
)
;
mSuppressAnchorAdjustment
=
false
;
InvalidateAnchor
(
)
;
return
;
}
ANCHOR_LOG
(
"
Applying
anchor
adjustment
of
(
%
d
%
d
)
for
%
p
and
anchor
%
p
.
\
n
"
adjustment
.
x
adjustment
.
y
this
mAnchorNode
)
;
MOZ_ASSERT
(
!
mApplyingAnchorAdjustment
)
;
mApplyingAnchorAdjustment
=
true
;
mScrollFrame
-
>
ScrollBy
(
adjustmentDevicePixels
nsIScrollableFrame
:
:
DEVICE_PIXELS
nsIScrollableFrame
:
:
INSTANT
nullptr
nsGkAtoms
:
:
relative
)
;
mApplyingAnchorAdjustment
=
false
;
mLastAnchorPos
=
FindScrollAnchoringBoundingRect
(
Frame
(
)
mAnchorNode
)
.
TopLeft
(
)
;
}
ScrollAnchorContainer
:
:
ExamineResult
ScrollAnchorContainer
:
:
ExamineAnchorCandidate
(
nsIFrame
*
aFrame
)
const
{
#
ifdef
DEBUG_FRAME_DUMP
nsCString
tag
=
aFrame
-
>
ListTag
(
)
;
ANCHOR_LOG
(
"
\
tVisiting
frame
=
%
s
(
%
p
)
.
\
n
"
tag
.
get
(
)
aFrame
)
;
#
else
ANCHOR_LOG
(
"
\
t
\
tVisiting
frame
=
%
p
.
\
n
"
aFrame
)
;
#
endif
const
nsStyleDisplay
*
disp
=
aFrame
-
>
StyleDisplay
(
)
;
if
(
disp
-
>
mOverflowAnchor
=
=
mozilla
:
:
StyleOverflowAnchor
:
:
None
)
{
ANCHOR_LOG
(
"
\
t
\
tExcluding
overflow
-
anchor
:
none
.
\
n
"
)
;
return
ExamineResult
:
:
Exclude
;
}
if
(
aFrame
-
>
IsStickyPositioned
(
)
)
{
ANCHOR_LOG
(
"
\
t
\
tExcluding
position
:
sticky
.
\
n
"
)
;
return
ExamineResult
:
:
Exclude
;
}
if
(
aFrame
-
>
IsBrFrame
(
)
)
{
ANCHOR_LOG
(
"
\
t
\
tExcluding
<
br
>
.
\
n
"
)
;
return
ExamineResult
:
:
Exclude
;
}
bool
isChrome
=
aFrame
-
>
GetContent
(
)
&
&
aFrame
-
>
GetContent
(
)
-
>
ChromeOnlyAccess
(
)
;
bool
isPseudo
=
aFrame
-
>
Style
(
)
-
>
IsPseudoElement
(
)
;
if
(
isChrome
&
&
!
isPseudo
)
{
ANCHOR_LOG
(
"
\
t
\
tExcluding
chrome
only
content
.
\
n
"
)
;
return
ExamineResult
:
:
Exclude
;
}
nsIScrollableFrame
*
scrollable
=
do_QueryFrame
(
aFrame
)
;
bool
canDescend
=
!
scrollable
&
&
!
aFrame
-
>
IsSVGOuterSVGFrame
(
)
;
bool
isBlockOutside
=
aFrame
-
>
IsBlockOutside
(
)
;
bool
isText
=
!
!
Text
:
:
FromNodeOrNull
(
aFrame
-
>
GetContent
(
)
)
;
bool
isAnonBox
=
aFrame
-
>
Style
(
)
-
>
IsAnonBox
(
)
&
&
!
isText
;
bool
isInlineOutside
=
aFrame
-
>
IsInlineOutside
(
)
&
&
!
isText
;
bool
isContinuation
=
!
!
aFrame
-
>
GetPrevContinuation
(
)
;
if
(
(
isAnonBox
|
|
isInlineOutside
)
&
&
canDescend
)
{
ANCHOR_LOG
(
"
\
t
\
tSearching
descendants
of
anon
or
inline
box
(
a
=
%
d
i
=
%
d
)
.
\
n
"
isAnonBox
isInlineOutside
)
;
return
ExamineResult
:
:
PassThrough
;
}
if
(
!
isBlockOutside
&
&
!
isText
)
{
ANCHOR_LOG
(
"
\
t
\
tExcluding
non
block
-
outside
or
text
node
(
b
=
%
d
t
=
%
d
)
.
\
n
"
isBlockOutside
isText
)
;
return
ExamineResult
:
:
Exclude
;
}
nsRect
rect
=
FindScrollAnchoringBoundingRect
(
Frame
(
)
aFrame
)
;
ANCHOR_LOG
(
"
\
t
\
trect
=
[
%
d
%
d
x
%
d
%
d
]
.
\
n
"
rect
.
x
rect
.
y
rect
.
width
rect
.
height
)
;
nsRect
visibleRect
;
if
(
!
visibleRect
.
IntersectRect
(
rect
mScrollFrame
-
>
mScrollPort
)
)
{
return
ExamineResult
:
:
Exclude
;
}
if
(
canDescend
&
&
isContinuation
)
{
ANCHOR_LOG
(
"
\
t
\
tSearching
descendants
of
a
continuation
.
\
n
"
)
;
return
ExamineResult
:
:
PassThrough
;
}
if
(
visibleRect
.
IsEqualEdges
(
rect
)
)
{
ANCHOR_LOG
(
"
\
t
\
tFully
visible
taking
.
\
n
"
)
;
return
ExamineResult
:
:
Accept
;
}
if
(
!
canDescend
)
{
ANCHOR_LOG
(
"
\
t
\
tIntersects
a
frame
that
we
can
'
t
descend
into
taking
.
\
n
"
)
;
return
ExamineResult
:
:
Accept
;
}
ANCHOR_LOG
(
"
\
t
\
tIntersects
valid
candidate
checking
descendants
.
\
n
"
)
;
return
ExamineResult
:
:
Traverse
;
}
nsIFrame
*
ScrollAnchorContainer
:
:
FindAnchorIn
(
nsIFrame
*
aFrame
)
const
{
for
(
nsIFrame
:
:
ChildListIterator
lists
(
aFrame
)
;
!
lists
.
IsDone
(
)
;
lists
.
Next
(
)
)
{
if
(
lists
.
CurrentID
(
)
=
=
FrameChildListID
:
:
kAbsoluteList
|
|
lists
.
CurrentID
(
)
=
=
FrameChildListID
:
:
kFixedList
|
|
lists
.
CurrentID
(
)
=
=
FrameChildListID
:
:
kFloatList
|
|
lists
.
CurrentID
(
)
=
=
FrameChildListID
:
:
kOverflowOutOfFlowList
)
{
continue
;
}
if
(
nsIFrame
*
anchor
=
FindAnchorInList
(
lists
.
CurrentList
(
)
)
)
{
return
anchor
;
}
}
const
nsFrameList
&
absPosList
=
aFrame
-
>
GetChildList
(
FrameChildListID
:
:
kAbsoluteList
)
;
if
(
nsIFrame
*
anchor
=
FindAnchorInList
(
absPosList
)
)
{
return
anchor
;
}
return
nullptr
;
}
nsIFrame
*
ScrollAnchorContainer
:
:
FindAnchorInList
(
const
nsFrameList
&
aFrameList
)
const
{
for
(
nsIFrame
*
child
:
aFrameList
)
{
nsIFrame
*
realFrame
=
nsPlaceholderFrame
:
:
GetRealFrameFor
(
child
)
;
if
(
child
!
=
realFrame
)
{
if
(
!
nsLayoutUtils
:
:
IsProperAncestorFrame
(
Frame
(
)
realFrame
)
)
{
ANCHOR_LOG
(
"
\
t
\
tSkipping
out
of
flow
frame
that
is
not
a
descendant
of
the
"
"
scroll
frame
.
\
n
"
)
;
continue
;
}
ANCHOR_LOG
(
"
\
t
\
tFollowing
placeholder
to
out
of
flow
frame
.
\
n
"
)
;
child
=
realFrame
;
}
ExamineResult
examine
=
ExamineAnchorCandidate
(
child
)
;
switch
(
examine
)
{
case
ExamineResult
:
:
Exclude
:
{
continue
;
}
case
ExamineResult
:
:
PassThrough
:
{
nsIFrame
*
candidate
=
FindAnchorIn
(
child
)
;
if
(
!
candidate
)
{
continue
;
}
return
candidate
;
}
case
ExamineResult
:
:
Traverse
:
{
nsIFrame
*
candidate
=
FindAnchorIn
(
child
)
;
if
(
!
candidate
)
{
return
child
;
}
return
candidate
;
}
case
ExamineResult
:
:
Accept
:
{
return
child
;
}
}
}
return
nullptr
;
}
}
}
