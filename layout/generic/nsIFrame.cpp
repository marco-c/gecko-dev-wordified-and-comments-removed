#
include
"
nsIFrame
.
h
"
#
include
<
stdarg
.
h
>
#
include
<
algorithm
>
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ComputedStyle
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
DisplayPortUtils
.
h
"
#
include
"
mozilla
/
dom
/
CSSAnimation
.
h
"
#
include
"
mozilla
/
dom
/
CSSTransition
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
include
"
mozilla
/
dom
/
AncestorIterator
.
h
"
#
include
"
mozilla
/
dom
/
ElementInlines
.
h
"
#
include
"
mozilla
/
dom
/
ImageTracker
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
#
include
"
mozilla
/
gfx
/
PathHelpers
.
h
"
#
include
"
mozilla
/
intl
/
BidiEmbeddingLevel
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
PresShellInlines
.
h
"
#
include
"
mozilla
/
ResultExtensions
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
StaticAnalysisFunctions
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
mozilla
/
StaticPrefs_print
.
h
"
#
include
"
mozilla
/
SVGMaskFrame
.
h
"
#
include
"
mozilla
/
SVGObserverUtils
.
h
"
#
include
"
mozilla
/
SVGTextFrame
.
h
"
#
include
"
mozilla
/
SVGIntegrationUtils
.
h
"
#
include
"
mozilla
/
SVGUtils
.
h
"
#
include
"
mozilla
/
ToString
.
h
"
#
include
"
mozilla
/
ViewportUtils
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsFieldSetFrame
.
h
"
#
include
"
nsFlexContainerFrame
.
h
"
#
include
"
nsFrameList
.
h
"
#
include
"
nsPlaceholderFrame
.
h
"
#
include
"
nsIBaseWindow
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
nsCSSProps
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsCSSRendering
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsTableWrapperFrame
.
h
"
#
include
"
nsView
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsPresContextInlines
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
LayoutLogging
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
nsImageFrame
.
h
"
#
include
"
nsInlineFrame
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsGridContainerFrame
.
h
"
#
include
"
nsCSSAnonBoxes
.
h
"
#
include
"
nsCanvasFrame
.
h
"
#
include
"
nsFieldSetFrame
.
h
"
#
include
"
nsFrameTraversal
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsITextControlFrame
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsIPercentBSizeObserver
.
h
"
#
include
"
nsStyleStructInlines
.
h
"
#
include
"
nsBidiPresUtils
.
h
"
#
include
"
RubyUtils
.
h
"
#
include
"
TextOverflow
.
h
"
#
include
"
nsAnimationManager
.
h
"
#
include
"
imgIRequest
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsBoxLayoutState
.
h
"
#
include
"
nsBlockFrame
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsChangeHint
.
h
"
#
include
"
nsDeckFrame
.
h
"
#
include
"
nsSubDocumentFrame
.
h
"
#
include
"
RetainedDisplayListBuilder
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
nsAbsoluteContainingBlock
.
h
"
#
include
"
ScrollSnap
.
h
"
#
include
"
StickyScrollContainer
.
h
"
#
include
"
nsFontInflationData
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsStyleChangeList
.
h
"
#
include
"
nsWindowSizes
.
h
"
#
ifdef
ACCESSIBILITY
#
include
"
nsAccessibilityService
.
h
"
#
endif
#
include
"
mozilla
/
AsyncEventDispatcher
.
h
"
#
include
"
mozilla
/
CSSClipPathInstance
.
h
"
#
include
"
mozilla
/
EffectCompositor
.
h
"
#
include
"
mozilla
/
EffectSet
.
h
"
#
include
"
mozilla
/
EventListenerManager
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
mozilla
/
ServoStyleSetInlines
.
h
"
#
include
"
mozilla
/
css
/
ImageLoader
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBodyElement
.
h
"
#
include
"
mozilla
/
dom
/
SVGPathData
.
h
"
#
include
"
mozilla
/
dom
/
TouchEvent
.
h
"
#
include
"
mozilla
/
gfx
/
Tools
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderUserData
.
h
"
#
include
"
mozilla
/
layout
/
ScrollAnchorContainer
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
ActiveLayerTracker
.
h
"
#
include
"
nsITheme
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
css
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
layout
;
typedef
nsAbsoluteContainingBlock
:
:
AbsPosReflowFlags
AbsPosReflowFlags
;
using
nsStyleTransformMatrix
:
:
TransformReferenceBox
;
const
mozilla
:
:
LayoutFrameType
nsIFrame
:
:
sLayoutFrameTypes
[
#
define
FRAME_ID
(
.
.
.
)
1
+
#
define
ABSTRACT_FRAME_ID
(
.
.
.
)
#
include
"
mozilla
/
FrameIdList
.
h
"
#
undef
FRAME_ID
#
undef
ABSTRACT_FRAME_ID
0
]
=
{
#
define
FRAME_ID
(
class_
type_
.
.
.
)
mozilla
:
:
LayoutFrameType
:
:
type_
#
define
ABSTRACT_FRAME_ID
(
.
.
.
)
#
include
"
mozilla
/
FrameIdList
.
h
"
#
undef
FRAME_ID
#
undef
ABSTRACT_FRAME_ID
}
;
const
nsIFrame
:
:
FrameClassBits
nsIFrame
:
:
sFrameClassBits
[
#
define
FRAME_ID
(
.
.
.
)
1
+
#
define
ABSTRACT_FRAME_ID
(
.
.
.
)
#
include
"
mozilla
/
FrameIdList
.
h
"
#
undef
FRAME_ID
#
undef
ABSTRACT_FRAME_ID
0
]
=
{
#
define
Leaf
eFrameClassBitsLeaf
#
define
NotLeaf
eFrameClassBitsNone
#
define
DynamicLeaf
eFrameClassBitsDynamicLeaf
#
define
FRAME_ID
(
class_
type_
leaf_
.
.
.
)
leaf_
#
define
ABSTRACT_FRAME_ID
(
.
.
.
)
#
include
"
mozilla
/
FrameIdList
.
h
"
#
undef
Leaf
#
undef
NotLeaf
#
undef
DynamicLeaf
#
undef
FRAME_ID
#
undef
ABSTRACT_FRAME_ID
}
;
struct
nsBoxLayoutMetrics
{
nsSize
mPrefSize
;
nsSize
mMinSize
;
nsSize
mMaxSize
;
nsSize
mBlockMinSize
;
nsSize
mBlockPrefSize
;
nscoord
mBlockAscent
;
nscoord
mFlex
;
nscoord
mAscent
;
nsSize
mLastSize
;
}
;
struct
nsContentAndOffset
{
nsIContent
*
mContent
=
nullptr
;
int32_t
mOffset
=
0
;
}
;
#
define
SELECTION_DEBUG
0
#
define
FORCE_SELECTION_UPDATE
1
#
define
CALC_DEBUG
0
#
include
"
nsILineIterator
.
h
"
#
include
"
prenv
.
h
"
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
BoxMetricsProperty
nsBoxLayoutMetrics
)
static
void
InitBoxMetrics
(
nsIFrame
*
aFrame
bool
aClear
)
{
if
(
aClear
)
{
aFrame
-
>
RemoveProperty
(
BoxMetricsProperty
(
)
)
;
}
nsBoxLayoutMetrics
*
metrics
=
new
nsBoxLayoutMetrics
(
)
;
aFrame
-
>
SetProperty
(
BoxMetricsProperty
(
)
metrics
)
;
aFrame
-
>
nsIFrame
:
:
MarkIntrinsicISizesDirty
(
)
;
metrics
-
>
mBlockAscent
=
0
;
metrics
-
>
mLastSize
.
SizeTo
(
0
0
)
;
}
template
<
typename
T
>
static
void
SetOrUpdateRectValuedProperty
(
nsIFrame
*
aFrame
FrameProperties
:
:
Descriptor
<
T
>
aProperty
const
nsRect
&
aNewValue
)
{
bool
found
;
nsRect
*
rectStorage
=
aFrame
-
>
GetProperty
(
aProperty
&
found
)
;
if
(
!
found
)
{
rectStorage
=
new
nsRect
(
aNewValue
)
;
aFrame
-
>
AddProperty
(
aProperty
rectStorage
)
;
}
else
{
*
rectStorage
=
aNewValue
;
}
}
static
bool
IsXULBoxWrapped
(
const
nsIFrame
*
aFrame
)
{
return
aFrame
-
>
GetParent
(
)
&
&
aFrame
-
>
GetParent
(
)
-
>
IsXULBoxFrame
(
)
&
&
!
aFrame
-
>
IsXULBoxFrame
(
)
;
}
void
nsIFrame
:
:
DestroyAnonymousContent
(
nsPresContext
*
aPresContext
already_AddRefed
<
nsIContent
>
&
&
aContent
)
{
if
(
nsCOMPtr
<
nsIContent
>
content
=
aContent
)
{
aPresContext
-
>
EventStateManager
(
)
-
>
NativeAnonymousContentRemoved
(
content
)
;
aPresContext
-
>
PresShell
(
)
-
>
NativeAnonymousContentRemoved
(
content
)
;
content
-
>
UnbindFromTree
(
)
;
}
}
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
nsReflowStatus
&
aStatus
)
{
char
complete
=
'
Y
'
;
if
(
aStatus
.
IsIncomplete
(
)
)
{
complete
=
'
N
'
;
}
else
if
(
aStatus
.
IsOverflowIncomplete
(
)
)
{
complete
=
'
O
'
;
}
char
brk
=
'
N
'
;
if
(
aStatus
.
IsInlineBreakBefore
(
)
)
{
brk
=
'
B
'
;
}
else
if
(
aStatus
.
IsInlineBreakAfter
(
)
)
{
brk
=
'
A
'
;
}
aStream
<
<
"
[
"
<
<
"
Complete
=
"
<
<
complete
<
<
"
"
<
<
"
NIF
=
"
<
<
(
aStatus
.
NextInFlowNeedsReflow
(
)
?
'
Y
'
:
'
N
'
)
<
<
"
"
<
<
"
Break
=
"
<
<
brk
<
<
"
"
<
<
"
FirstLetter
=
"
<
<
(
aStatus
.
FirstLetterComplete
(
)
?
'
Y
'
:
'
N
'
)
<
<
"
]
"
;
return
aStream
;
}
#
ifdef
DEBUG
mozilla
:
:
LazyLogModule
nsIFrame
:
:
sFrameLogModule
(
"
frame
"
)
;
#
endif
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
AbsoluteContainingBlockProperty
nsAbsoluteContainingBlock
)
bool
nsIFrame
:
:
HasAbsolutelyPositionedChildren
(
)
const
{
return
IsAbsoluteContainer
(
)
&
&
GetAbsoluteContainingBlock
(
)
-
>
HasAbsoluteFrames
(
)
;
}
nsAbsoluteContainingBlock
*
nsIFrame
:
:
GetAbsoluteContainingBlock
(
)
const
{
NS_ASSERTION
(
IsAbsoluteContainer
(
)
"
The
frame
is
not
marked
as
an
abspos
container
correctly
"
)
;
nsAbsoluteContainingBlock
*
absCB
=
GetProperty
(
AbsoluteContainingBlockProperty
(
)
)
;
NS_ASSERTION
(
absCB
"
The
frame
is
marked
as
an
abspos
container
but
doesn
'
t
have
"
"
the
property
"
)
;
return
absCB
;
}
void
nsIFrame
:
:
MarkAsAbsoluteContainingBlock
(
)
{
MOZ_ASSERT
(
HasAnyStateBits
(
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
)
;
NS_ASSERTION
(
!
GetProperty
(
AbsoluteContainingBlockProperty
(
)
)
"
Already
has
an
abs
-
pos
containing
block
property
?
"
)
;
NS_ASSERTION
(
!
HasAnyStateBits
(
NS_FRAME_HAS_ABSPOS_CHILDREN
)
"
Already
has
NS_FRAME_HAS_ABSPOS_CHILDREN
state
bit
?
"
)
;
AddStateBits
(
NS_FRAME_HAS_ABSPOS_CHILDREN
)
;
SetProperty
(
AbsoluteContainingBlockProperty
(
)
new
nsAbsoluteContainingBlock
(
GetAbsoluteListID
(
)
)
)
;
}
void
nsIFrame
:
:
MarkAsNotAbsoluteContainingBlock
(
)
{
NS_ASSERTION
(
!
HasAbsolutelyPositionedChildren
(
)
"
Think
of
the
children
!
"
)
;
NS_ASSERTION
(
GetProperty
(
AbsoluteContainingBlockProperty
(
)
)
"
Should
have
an
abs
-
pos
containing
block
property
"
)
;
NS_ASSERTION
(
HasAnyStateBits
(
NS_FRAME_HAS_ABSPOS_CHILDREN
)
"
Should
have
NS_FRAME_HAS_ABSPOS_CHILDREN
state
bit
"
)
;
MOZ_ASSERT
(
HasAnyStateBits
(
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
)
;
RemoveStateBits
(
NS_FRAME_HAS_ABSPOS_CHILDREN
)
;
RemoveProperty
(
AbsoluteContainingBlockProperty
(
)
)
;
}
bool
nsIFrame
:
:
CheckAndClearPaintedState
(
)
{
bool
result
=
HasAnyStateBits
(
NS_FRAME_PAINTED_THEBES
)
;
RemoveStateBits
(
NS_FRAME_PAINTED_THEBES
)
;
for
(
const
auto
&
childList
:
ChildLists
(
)
)
{
for
(
nsIFrame
*
child
:
childList
.
mList
)
{
if
(
child
-
>
CheckAndClearPaintedState
(
)
)
{
result
=
true
;
}
}
}
return
result
;
}
bool
nsIFrame
:
:
CheckAndClearDisplayListState
(
)
{
bool
result
=
BuiltDisplayList
(
)
;
SetBuiltDisplayList
(
false
)
;
for
(
const
auto
&
childList
:
ChildLists
(
)
)
{
for
(
nsIFrame
*
child
:
childList
.
mList
)
{
if
(
child
-
>
CheckAndClearDisplayListState
(
)
)
{
result
=
true
;
}
}
}
return
result
;
}
bool
nsIFrame
:
:
IsVisibleConsideringAncestors
(
uint32_t
aFlags
)
const
{
if
(
!
StyleVisibility
(
)
-
>
IsVisible
(
)
)
{
return
false
;
}
if
(
PresShell
(
)
-
>
IsUnderHiddenEmbedderElement
(
)
)
{
return
false
;
}
const
nsIFrame
*
frame
=
this
;
while
(
frame
)
{
nsView
*
view
=
frame
-
>
GetView
(
)
;
if
(
view
&
&
view
-
>
GetVisibility
(
)
=
=
nsViewVisibility_kHide
)
return
false
;
if
(
this
!
=
frame
&
&
frame
-
>
IsContentHidden
(
)
)
return
false
;
nsIFrame
*
parent
=
frame
-
>
GetParent
(
)
;
nsDeckFrame
*
deck
=
do_QueryFrame
(
parent
)
;
if
(
deck
)
{
if
(
deck
-
>
GetSelectedBox
(
)
!
=
frame
)
return
false
;
}
if
(
parent
)
{
frame
=
parent
;
}
else
{
parent
=
nsLayoutUtils
:
:
GetCrossDocParentFrameInProcess
(
frame
)
;
if
(
!
parent
)
break
;
if
(
(
aFlags
&
nsIFrame
:
:
VISIBILITY_CROSS_CHROME_CONTENT_BOUNDARY
)
=
=
0
&
&
parent
-
>
PresContext
(
)
-
>
IsChrome
(
)
&
&
!
frame
-
>
PresContext
(
)
-
>
IsChrome
(
)
)
{
break
;
}
frame
=
parent
;
}
}
return
true
;
}
void
nsIFrame
:
:
FindCloserFrameForSelection
(
const
nsPoint
&
aPoint
FrameWithDistance
*
aCurrentBestFrame
)
{
if
(
nsLayoutUtils
:
:
PointIsCloserToRect
(
aPoint
mRect
aCurrentBestFrame
-
>
mXDistance
aCurrentBestFrame
-
>
mYDistance
)
)
{
aCurrentBestFrame
-
>
mFrame
=
this
;
}
}
void
nsIFrame
:
:
ElementStateChanged
(
mozilla
:
:
dom
:
:
ElementState
aStates
)
{
}
void
WeakFrame
:
:
Clear
(
mozilla
:
:
PresShell
*
aPresShell
)
{
if
(
aPresShell
)
{
aPresShell
-
>
RemoveWeakFrame
(
this
)
;
}
mFrame
=
nullptr
;
}
AutoWeakFrame
:
:
AutoWeakFrame
(
const
WeakFrame
&
aOther
)
:
mPrev
(
nullptr
)
mFrame
(
nullptr
)
{
Init
(
aOther
.
GetFrame
(
)
)
;
}
void
AutoWeakFrame
:
:
Clear
(
mozilla
:
:
PresShell
*
aPresShell
)
{
if
(
aPresShell
)
{
aPresShell
-
>
RemoveAutoWeakFrame
(
this
)
;
}
mFrame
=
nullptr
;
mPrev
=
nullptr
;
}
AutoWeakFrame
:
:
~
AutoWeakFrame
(
)
{
Clear
(
mFrame
?
mFrame
-
>
PresContext
(
)
-
>
GetPresShell
(
)
:
nullptr
)
;
}
void
AutoWeakFrame
:
:
Init
(
nsIFrame
*
aFrame
)
{
Clear
(
mFrame
?
mFrame
-
>
PresContext
(
)
-
>
GetPresShell
(
)
:
nullptr
)
;
mFrame
=
aFrame
;
if
(
mFrame
)
{
mozilla
:
:
PresShell
*
presShell
=
mFrame
-
>
PresContext
(
)
-
>
GetPresShell
(
)
;
NS_WARNING_ASSERTION
(
presShell
"
Null
PresShell
in
AutoWeakFrame
!
"
)
;
if
(
presShell
)
{
presShell
-
>
AddAutoWeakFrame
(
this
)
;
}
else
{
mFrame
=
nullptr
;
}
}
}
void
WeakFrame
:
:
Init
(
nsIFrame
*
aFrame
)
{
Clear
(
mFrame
?
mFrame
-
>
PresContext
(
)
-
>
GetPresShell
(
)
:
nullptr
)
;
mFrame
=
aFrame
;
if
(
mFrame
)
{
mozilla
:
:
PresShell
*
presShell
=
mFrame
-
>
PresContext
(
)
-
>
GetPresShell
(
)
;
MOZ_ASSERT
(
presShell
"
Null
PresShell
in
WeakFrame
!
"
)
;
if
(
presShell
)
{
presShell
-
>
AddWeakFrame
(
this
)
;
}
else
{
mFrame
=
nullptr
;
}
}
}
nsIFrame
*
NS_NewEmptyFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsIFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
nsIFrame
:
:
~
nsIFrame
(
)
{
MOZ_COUNT_DTOR
(
nsIFrame
)
;
MOZ_ASSERT
(
GetVisibility
(
)
!
=
Visibility
:
:
ApproximatelyVisible
"
Visible
nsFrame
is
being
destroyed
"
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsIFrame
)
void
nsIFrame
:
:
operator
delete
(
void
*
size_t
)
{
MOZ_CRASH
(
"
nsIFrame
:
:
operator
delete
should
never
be
called
"
)
;
}
NS_QUERYFRAME_HEAD
(
nsIFrame
)
NS_QUERYFRAME_ENTRY
(
nsIFrame
)
NS_QUERYFRAME_TAIL_INHERITANCE_ROOT
static
bool
IsFontSizeInflationContainer
(
nsIFrame
*
aFrame
const
nsStyleDisplay
*
aStyleDisplay
)
{
if
(
!
aFrame
-
>
GetParent
(
)
)
{
return
true
;
}
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
content
&
&
content
-
>
IsInNativeAnonymousSubtree
(
)
)
{
nsCanvasFrame
*
canvas
=
aFrame
-
>
PresShell
(
)
-
>
GetCanvasFrame
(
)
;
return
canvas
&
&
canvas
-
>
GetCustomContentContainer
(
)
=
=
content
;
}
LayoutFrameType
frameType
=
aFrame
-
>
Type
(
)
;
bool
isInline
=
(
nsStyleDisplay
:
:
IsInlineFlow
(
aFrame
-
>
GetDisplay
(
)
)
|
|
RubyUtils
:
:
IsRubyBox
(
frameType
)
|
|
(
aStyleDisplay
-
>
IsFloatingStyle
(
)
&
&
frameType
=
=
LayoutFrameType
:
:
Letter
)
|
|
(
aFrame
-
>
GetParent
(
)
-
>
GetContent
(
)
=
=
content
)
|
|
(
content
&
&
(
content
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
option
nsGkAtoms
:
:
optgroup
nsGkAtoms
:
:
select
nsGkAtoms
:
:
input
nsGkAtoms
:
:
button
nsGkAtoms
:
:
textarea
)
)
)
)
&
&
!
(
aFrame
-
>
IsXULBoxFrame
(
)
&
&
aFrame
-
>
GetParent
(
)
-
>
IsXULBoxFrame
(
)
)
;
NS_ASSERTION
(
!
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eLineParticipant
)
|
|
isInline
|
|
aFrame
-
>
IsBrFrame
(
)
|
|
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eMathML
)
"
line
participants
must
not
be
containers
"
)
;
return
!
isInline
;
}
static
void
MaybeScheduleReflowSVGNonDisplayText
(
nsIFrame
*
aFrame
)
{
if
(
!
SVGUtils
:
:
IsInSVGTextSubtree
(
aFrame
)
)
{
return
;
}
SVGTextFrame
*
svgTextFrame
=
static_cast
<
SVGTextFrame
*
>
(
nsLayoutUtils
:
:
GetClosestFrameOfType
(
aFrame
LayoutFrameType
:
:
SVGText
)
)
;
nsIFrame
*
anonBlock
=
svgTextFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
!
anonBlock
|
|
anonBlock
-
>
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
)
{
return
;
}
if
(
!
svgTextFrame
-
>
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
|
|
svgTextFrame
-
>
HasAnyStateBits
(
NS_STATE_SVG_TEXT_IN_REFLOW
)
)
{
return
;
}
svgTextFrame
-
>
ScheduleReflowSVGNonDisplayText
(
IntrinsicDirty
:
:
StyleChange
)
;
}
bool
nsIFrame
:
:
IsPrimaryFrameOfRootOrBodyElement
(
)
const
{
if
(
!
IsPrimaryFrame
(
)
)
{
return
false
;
}
nsIContent
*
content
=
GetContent
(
)
;
Document
*
document
=
content
-
>
OwnerDoc
(
)
;
return
content
=
=
document
-
>
GetRootElement
(
)
|
|
content
=
=
document
-
>
GetBodyElement
(
)
;
}
bool
nsIFrame
:
:
IsRenderedLegend
(
)
const
{
if
(
auto
*
parent
=
GetParent
(
)
;
parent
&
&
parent
-
>
IsFieldSetFrame
(
)
)
{
return
static_cast
<
nsFieldSetFrame
*
>
(
parent
)
-
>
GetLegend
(
)
=
=
this
;
}
return
false
;
}
void
nsIFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
MOZ_ASSERT
(
nsQueryFrame
:
:
FrameIID
(
mClass
)
=
=
GetFrameId
(
)
)
;
MOZ_ASSERT
(
!
mContent
"
Double
-
initing
a
frame
?
"
)
;
NS_ASSERTION
(
IsFrameOfType
(
eDEBUGAllFrames
)
&
&
!
IsFrameOfType
(
eDEBUGNoFrames
)
"
IsFrameOfType
implementation
that
doesn
'
t
call
base
class
"
)
;
mContent
=
aContent
;
mParent
=
aParent
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mParent
|
|
PresShell
(
)
=
=
mParent
-
>
PresShell
(
)
)
;
if
(
aPrevInFlow
)
{
mWritingMode
=
aPrevInFlow
-
>
GetWritingMode
(
)
;
AddStateBits
(
aPrevInFlow
-
>
GetStateBits
(
)
&
(
NS_FRAME_GENERATED_CONTENT
|
NS_FRAME_OUT_OF_FLOW
|
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
|
NS_FRAME_INDEPENDENT_SELECTION
|
NS_FRAME_PART_OF_IBSPLIT
|
NS_FRAME_MAY_BE_TRANSFORMED
|
NS_FRAME_HAS_MULTI_COLUMN_ANCESTOR
)
)
;
mHasColumnSpanSiblings
=
aPrevInFlow
-
>
HasColumnSpanSiblings
(
)
;
}
else
{
PresContext
(
)
-
>
ConstructedFrame
(
)
;
}
if
(
GetParent
(
)
)
{
if
(
MOZ_UNLIKELY
(
mContent
=
=
PresContext
(
)
-
>
Document
(
)
-
>
GetRootElement
(
)
&
&
mContent
=
=
GetParent
(
)
-
>
GetContent
(
)
)
)
{
mWritingMode
=
GetParent
(
)
-
>
GetWritingMode
(
)
;
}
AddStateBits
(
GetParent
(
)
-
>
GetStateBits
(
)
&
(
NS_FRAME_GENERATED_CONTENT
|
NS_FRAME_INDEPENDENT_SELECTION
|
NS_FRAME_IS_SVG_TEXT
|
NS_FRAME_IN_POPUP
|
NS_FRAME_IS_NONDISPLAY
)
)
;
if
(
HasAnyStateBits
(
NS_FRAME_IN_POPUP
)
&
&
TrackingVisibility
(
)
)
{
IncApproximateVisibleCount
(
)
;
}
}
if
(
aPrevInFlow
)
{
mMayHaveOpacityAnimation
=
aPrevInFlow
-
>
MayHaveOpacityAnimation
(
)
;
mMayHaveTransformAnimation
=
aPrevInFlow
-
>
MayHaveTransformAnimation
(
)
;
}
else
if
(
mContent
)
{
EffectSet
*
effectSet
=
EffectSet
:
:
GetEffectSetForStyleFrame
(
this
)
;
if
(
effectSet
)
{
mMayHaveOpacityAnimation
=
effectSet
-
>
MayHaveOpacityAnimation
(
)
;
if
(
effectSet
-
>
MayHaveTransformAnimation
(
)
)
{
if
(
IsFrameOfType
(
eSupportsCSSTransforms
)
)
{
mMayHaveTransformAnimation
=
true
;
AddStateBits
(
NS_FRAME_MAY_BE_TRANSFORMED
)
;
}
else
if
(
aParent
&
&
nsLayoutUtils
:
:
GetStyleFrame
(
aParent
)
=
=
this
)
{
MOZ_ASSERT
(
aParent
-
>
IsFrameOfType
(
eSupportsCSSTransforms
)
"
Style
frames
that
don
'
t
support
transforms
should
have
parents
"
"
that
do
"
)
;
aParent
-
>
mMayHaveTransformAnimation
=
true
;
aParent
-
>
AddStateBits
(
NS_FRAME_MAY_BE_TRANSFORMED
)
;
}
}
}
}
const
nsStyleDisplay
*
disp
=
StyleDisplay
(
)
;
if
(
disp
-
>
HasTransform
(
this
)
)
{
AddStateBits
(
NS_FRAME_MAY_BE_TRANSFORMED
)
;
}
if
(
disp
-
>
mContainerType
)
{
PresContext
(
)
-
>
RegisterContainerQueryFrame
(
this
)
;
}
if
(
disp
-
>
IsContainLayout
(
)
&
&
disp
-
>
GetContainSizeAxes
(
)
.
IsBoth
(
)
&
&
IsFrameOfType
(
eSupportsContainLayoutAndPaint
)
&
&
!
IsTableWrapperFrame
(
)
)
{
AddStateBits
(
NS_FRAME_REFLOW_ROOT
)
;
}
if
(
nsLayoutUtils
:
:
FontSizeInflationEnabled
(
PresContext
(
)
)
|
|
!
GetParent
(
)
#
ifdef
DEBUG
|
|
true
#
endif
)
{
if
(
IsFontSizeInflationContainer
(
this
disp
)
)
{
AddStateBits
(
NS_FRAME_FONT_INFLATION_CONTAINER
)
;
if
(
!
GetParent
(
)
|
|
disp
-
>
IsFloating
(
this
)
|
|
disp
-
>
IsAbsolutelyPositioned
(
this
)
|
|
GetParent
(
)
-
>
IsFlexContainerFrame
(
)
|
|
GetParent
(
)
-
>
IsGridContainerFrame
(
)
)
{
AddStateBits
(
NS_FRAME_FONT_INFLATION_FLOW_ROOT
)
;
}
}
NS_ASSERTION
(
GetParent
(
)
|
|
HasAnyStateBits
(
NS_FRAME_FONT_INFLATION_CONTAINER
)
"
root
frame
should
always
be
a
container
"
)
;
}
if
(
PresShell
(
)
-
>
AssumeAllFramesVisible
(
)
&
&
TrackingVisibility
(
)
)
{
IncApproximateVisibleCount
(
)
;
}
DidSetComputedStyle
(
nullptr
)
;
if
(
:
:
IsXULBoxWrapped
(
this
)
)
:
:
InitBoxMetrics
(
this
false
)
;
if
(
!
IsPlaceholderFrame
(
)
&
&
!
aPrevInFlow
)
{
UpdateVisibleDescendantsState
(
)
;
}
UpdateAnimationVisibility
(
)
;
}
void
nsIFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
{
NS_ASSERTION
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
destroy
called
on
frame
while
scripts
not
blocked
"
)
;
NS_ASSERTION
(
!
GetNextSibling
(
)
&
&
!
GetPrevSibling
(
)
"
Frames
should
be
removed
before
destruction
.
"
)
;
NS_ASSERTION
(
aDestructRoot
"
Must
specify
destruct
root
"
)
;
MOZ_ASSERT
(
!
HasAbsolutelyPositionedChildren
(
)
)
;
MOZ_ASSERT
(
!
HasAnyStateBits
(
NS_FRAME_PART_OF_IBSPLIT
)
"
NS_FRAME_PART_OF_IBSPLIT
set
on
non
-
nsContainerFrame
?
"
)
;
MaybeScheduleReflowSVGNonDisplayText
(
this
)
;
SVGObserverUtils
:
:
InvalidateDirectRenderingObservers
(
this
)
;
const
auto
*
disp
=
StyleDisplay
(
)
;
if
(
disp
-
>
mPosition
=
=
StylePositionProperty
:
:
Sticky
)
{
if
(
auto
*
ssc
=
StickyScrollContainer
:
:
GetStickyScrollContainerForFrame
(
this
)
)
{
ssc
-
>
RemoveFrame
(
this
)
;
}
}
if
(
disp
-
>
mContainerType
)
{
PresContext
(
)
-
>
UnregisterContainerQueryFrame
(
this
)
;
}
nsPresContext
*
presContext
=
PresContext
(
)
;
mozilla
:
:
PresShell
*
presShell
=
presContext
-
>
GetPresShell
(
)
;
if
(
mState
&
NS_FRAME_OUT_OF_FLOW
)
{
nsPlaceholderFrame
*
placeholder
=
GetPlaceholderFrame
(
)
;
NS_ASSERTION
(
!
placeholder
|
|
(
aDestructRoot
!
=
this
)
"
Don
'
t
call
Destroy
(
)
on
OOFs
call
Destroy
(
)
on
the
placeholder
.
"
)
;
NS_ASSERTION
(
!
placeholder
|
|
nsLayoutUtils
:
:
IsProperAncestorFrame
(
aDestructRoot
placeholder
)
"
Placeholder
relationship
should
have
been
torn
down
already
;
"
"
this
might
mean
we
have
a
stray
placeholder
in
the
tree
.
"
)
;
if
(
placeholder
)
{
placeholder
-
>
SetOutOfFlowFrame
(
nullptr
)
;
}
}
if
(
IsPrimaryFrame
(
)
)
{
ActiveLayerTracker
:
:
TransferActivityToContent
(
this
mContent
)
;
}
ScrollAnchorContainer
*
anchor
=
nullptr
;
if
(
IsScrollAnchor
(
&
anchor
)
)
{
anchor
-
>
InvalidateAnchor
(
)
;
}
if
(
HasCSSAnimations
(
)
|
|
HasCSSTransitions
(
)
|
|
EffectSet
:
:
GetEffectSetForStyleFrame
(
this
)
)
{
RestyleManager
:
:
AnimationsWithDestroyedFrame
*
adf
=
presContext
-
>
RestyleManager
(
)
-
>
GetAnimationsWithDestroyedFrame
(
)
;
if
(
adf
)
{
adf
-
>
Put
(
mContent
mComputedStyle
)
;
}
}
DisableVisibilityTracking
(
)
;
PresContext
(
)
-
>
GetPresShell
(
)
-
>
RemoveFrameFromApproximatelyVisibleList
(
this
)
;
presShell
-
>
NotifyDestroyingFrame
(
this
)
;
if
(
mState
&
NS_FRAME_EXTERNAL_REFERENCE
)
{
presShell
-
>
ClearFrameRefs
(
this
)
;
}
nsView
*
view
=
GetView
(
)
;
if
(
view
)
{
view
-
>
SetFrame
(
nullptr
)
;
view
-
>
Destroy
(
)
;
}
if
(
IsPrimaryFrame
(
)
)
{
mContent
-
>
SetPrimaryFrame
(
nullptr
)
;
if
(
HasAnyStateBits
(
NS_FRAME_GENERATED_CONTENT
)
&
&
mContent
-
>
IsRootOfNativeAnonymousSubtree
(
)
)
{
aPostDestroyData
.
AddAnonymousContent
(
mContent
.
forget
(
)
)
;
}
}
RemoveAllProperties
(
)
;
nsQueryFrame
:
:
FrameIID
id
=
GetFrameId
(
)
;
this
-
>
~
nsIFrame
(
)
;
#
ifdef
DEBUG
{
nsIFrame
*
rootFrame
=
presShell
-
>
GetRootFrame
(
)
;
MOZ_ASSERT
(
rootFrame
)
;
if
(
this
!
=
rootFrame
)
{
auto
*
builder
=
nsLayoutUtils
:
:
GetRetainedDisplayListBuilder
(
rootFrame
)
;
auto
*
data
=
builder
?
builder
-
>
Data
(
)
:
nullptr
;
const
bool
inData
=
data
&
&
(
data
-
>
IsModified
(
this
)
|
|
data
-
>
HasProps
(
this
)
)
;
if
(
inData
)
{
DL_LOG
(
LogLevel
:
:
Warning
"
Frame
%
p
found
in
retained
data
"
this
)
;
}
MOZ_ASSERT
(
!
inData
"
Deleted
frame
in
retained
data
!
"
)
;
}
}
#
endif
presShell
-
>
FreeFrame
(
id
this
)
;
}
std
:
:
pair
<
int32_t
int32_t
>
nsIFrame
:
:
GetOffsets
(
)
const
{
return
std
:
:
make_pair
(
0
0
)
;
}
static
void
CompareLayers
(
const
nsStyleImageLayers
*
aFirstLayers
const
nsStyleImageLayers
*
aSecondLayers
const
std
:
:
function
<
void
(
imgRequestProxy
*
aReq
)
>
&
aCallback
)
{
NS_FOR_VISIBLE_IMAGE_LAYERS_BACK_TO_FRONT
(
i
(
*
aFirstLayers
)
)
{
const
auto
&
image
=
aFirstLayers
-
>
mLayers
[
i
]
.
mImage
;
if
(
!
image
.
IsImageRequestType
(
)
|
|
!
image
.
IsResolved
(
)
)
{
continue
;
}
if
(
!
aSecondLayers
|
|
i
>
=
aSecondLayers
-
>
mImageCount
|
|
(
!
aSecondLayers
-
>
mLayers
[
i
]
.
mImage
.
IsResolved
(
)
|
|
image
.
GetImageRequest
(
)
!
=
aSecondLayers
-
>
mLayers
[
i
]
.
mImage
.
GetImageRequest
(
)
)
)
{
if
(
imgRequestProxy
*
req
=
image
.
GetImageRequest
(
)
)
{
aCallback
(
req
)
;
}
}
}
}
static
void
AddAndRemoveImageAssociations
(
ImageLoader
&
aImageLoader
nsIFrame
*
aFrame
const
nsStyleImageLayers
*
aOldLayers
const
nsStyleImageLayers
*
aNewLayers
)
{
if
(
aOldLayers
&
&
aFrame
-
>
HasImageRequest
(
)
)
{
CompareLayers
(
aOldLayers
aNewLayers
[
&
]
(
imgRequestProxy
*
aReq
)
{
aImageLoader
.
DisassociateRequestFromFrame
(
aReq
aFrame
)
;
}
)
;
}
CompareLayers
(
aNewLayers
aOldLayers
[
&
]
(
imgRequestProxy
*
aReq
)
{
aImageLoader
.
AssociateRequestToFrame
(
aReq
aFrame
)
;
}
)
;
}
void
nsIFrame
:
:
AddDisplayItem
(
nsDisplayItem
*
aItem
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mDisplayItems
.
Contains
(
aItem
)
)
;
mDisplayItems
.
AppendElement
(
aItem
)
;
}
bool
nsIFrame
:
:
RemoveDisplayItem
(
nsDisplayItem
*
aItem
)
{
return
mDisplayItems
.
RemoveElement
(
aItem
)
;
}
bool
nsIFrame
:
:
HasDisplayItems
(
)
{
return
!
mDisplayItems
.
IsEmpty
(
)
;
}
bool
nsIFrame
:
:
HasDisplayItem
(
nsDisplayItem
*
aItem
)
{
return
mDisplayItems
.
Contains
(
aItem
)
;
}
bool
nsIFrame
:
:
HasDisplayItem
(
uint32_t
aKey
)
{
for
(
nsDisplayItem
*
i
:
mDisplayItems
)
{
if
(
i
-
>
GetPerFrameKey
(
)
=
=
aKey
)
{
return
true
;
}
}
return
false
;
}
template
<
typename
Condition
>
static
void
DiscardDisplayItems
(
nsIFrame
*
aFrame
Condition
aCondition
)
{
for
(
nsDisplayItem
*
i
:
aFrame
-
>
DisplayItems
(
)
)
{
if
(
aCondition
(
i
)
&
&
i
-
>
FrameForInvalidation
(
)
=
=
aFrame
)
{
i
-
>
SetCantBeReused
(
)
;
}
}
}
static
void
DiscardOldItems
(
nsIFrame
*
aFrame
)
{
DiscardDisplayItems
(
aFrame
[
]
(
nsDisplayItem
*
aItem
)
{
return
aItem
-
>
IsOldItem
(
)
;
}
)
;
}
void
nsIFrame
:
:
RemoveDisplayItemDataForDeletion
(
)
{
WebRenderUserDataTable
*
userDataTable
=
TakeProperty
(
WebRenderUserDataProperty
:
:
Key
(
)
)
;
if
(
userDataTable
)
{
for
(
const
auto
&
data
:
userDataTable
-
>
Values
(
)
)
{
data
-
>
RemoveFromTable
(
)
;
}
delete
userDataTable
;
}
if
(
!
nsLayoutUtils
:
:
AreRetainedDisplayListsEnabled
(
)
)
{
return
;
}
auto
*
builder
=
nsLayoutUtils
:
:
GetRetainedDisplayListBuilder
(
this
)
;
if
(
!
builder
)
{
MOZ_ASSERT
(
DisplayItems
(
)
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
!
IsFrameModified
(
)
)
;
return
;
}
for
(
nsDisplayItem
*
i
:
DisplayItems
(
)
)
{
if
(
i
-
>
GetDependentFrame
(
)
=
=
this
&
&
!
i
-
>
HasDeletedFrame
(
)
)
{
i
-
>
Frame
(
)
-
>
MarkNeedsDisplayItemRebuild
(
)
;
}
i
-
>
RemoveFrame
(
this
)
;
}
DisplayItems
(
)
.
Clear
(
)
;
nsAutoString
name
;
#
ifdef
DEBUG_FRAME_DUMP
if
(
DL_LOG_TEST
(
LogLevel
:
:
Debug
)
)
{
GetFrameName
(
name
)
;
}
#
endif
DL_LOGV
(
"
Removing
display
item
data
for
frame
%
p
(
%
s
)
"
this
NS_ConvertUTF16toUTF8
(
name
)
.
get
(
)
)
;
auto
*
data
=
builder
-
>
Data
(
)
;
if
(
MayHaveWillChangeBudget
(
)
)
{
data
-
>
Flags
(
this
)
=
RetainedDisplayListData
:
:
FrameFlag
:
:
HadWillChange
;
}
else
{
data
-
>
Remove
(
this
)
;
}
}
void
nsIFrame
:
:
MarkNeedsDisplayItemRebuild
(
)
{
if
(
!
nsLayoutUtils
:
:
AreRetainedDisplayListsEnabled
(
)
|
|
IsFrameModified
(
)
|
|
HasAnyStateBits
(
NS_FRAME_IN_POPUP
)
)
{
return
;
}
if
(
Type
(
)
=
=
LayoutFrameType
:
:
Placeholder
)
{
nsIFrame
*
oof
=
static_cast
<
nsPlaceholderFrame
*
>
(
this
)
-
>
GetOutOfFlowFrame
(
)
;
if
(
oof
)
{
oof
-
>
MarkNeedsDisplayItemRebuild
(
)
;
}
return
;
}
nsIFrame
*
rootFrame
=
PresShell
(
)
-
>
GetRootFrame
(
)
;
if
(
rootFrame
-
>
IsFrameModified
(
)
)
{
return
;
}
auto
*
builder
=
nsLayoutUtils
:
:
GetRetainedDisplayListBuilder
(
this
)
;
if
(
!
builder
)
{
MOZ_ASSERT
(
DisplayItems
(
)
.
IsEmpty
(
)
)
;
return
;
}
RetainedDisplayListData
*
data
=
builder
-
>
Data
(
)
;
MOZ_ASSERT
(
data
)
;
if
(
data
-
>
AtModifiedFrameLimit
(
)
)
{
data
-
>
AddModifiedFrame
(
rootFrame
)
;
return
;
}
nsAutoString
name
;
#
ifdef
DEBUG_FRAME_DUMP
if
(
DL_LOG_TEST
(
LogLevel
:
:
Debug
)
)
{
GetFrameName
(
name
)
;
}
#
endif
DL_LOGV
(
"
RDL
-
Rebuilding
display
items
for
frame
%
p
(
%
s
)
"
this
NS_ConvertUTF16toUTF8
(
name
)
.
get
(
)
)
;
data
-
>
AddModifiedFrame
(
this
)
;
MOZ_ASSERT
(
PresContext
(
)
-
>
LayoutPhaseCount
(
nsLayoutPhase
:
:
DisplayListBuilding
)
=
=
0
)
;
for
(
nsDisplayItem
*
i
:
DisplayItems
(
)
)
{
if
(
i
-
>
HasDeletedFrame
(
)
|
|
i
-
>
Frame
(
)
=
=
this
)
{
continue
;
}
if
(
i
-
>
GetDependentFrame
(
)
=
=
this
)
{
i
-
>
Frame
(
)
-
>
MarkNeedsDisplayItemRebuild
(
)
;
}
}
}
void
nsIFrame
:
:
DidSetComputedStyle
(
ComputedStyle
*
aOldComputedStyle
)
{
#
ifdef
ACCESSIBILITY
if
(
aOldComputedStyle
)
{
if
(
nsAccessibilityService
*
accService
=
GetAccService
(
)
)
{
accService
-
>
NotifyOfComputedStyleChange
(
PresShell
(
)
mContent
)
;
}
}
#
endif
MaybeScheduleReflowSVGNonDisplayText
(
this
)
;
Document
*
doc
=
PresContext
(
)
-
>
Document
(
)
;
ImageLoader
*
loader
=
doc
-
>
StyleImageLoader
(
)
;
const
bool
isNonText
=
!
IsTextFrame
(
)
;
if
(
isNonText
)
{
mComputedStyle
-
>
StartImageLoads
(
*
doc
aOldComputedStyle
)
;
}
const
nsStyleImageLayers
*
oldLayers
=
aOldComputedStyle
?
&
aOldComputedStyle
-
>
StyleBackground
(
)
-
>
mImage
:
nullptr
;
const
nsStyleImageLayers
*
newLayers
=
&
StyleBackground
(
)
-
>
mImage
;
AddAndRemoveImageAssociations
(
*
loader
this
oldLayers
newLayers
)
;
oldLayers
=
aOldComputedStyle
?
&
aOldComputedStyle
-
>
StyleSVGReset
(
)
-
>
mMask
:
nullptr
;
newLayers
=
&
StyleSVGReset
(
)
-
>
mMask
;
AddAndRemoveImageAssociations
(
*
loader
this
oldLayers
newLayers
)
;
const
nsStyleDisplay
*
disp
=
StyleDisplay
(
)
;
bool
handleStickyChange
=
false
;
if
(
aOldComputedStyle
)
{
bool
needAnchorSuppression
=
false
;
nsMargin
oldValue
(
0
0
0
0
)
;
nsMargin
newValue
(
0
0
0
0
)
;
const
nsStyleMargin
*
oldMargin
=
aOldComputedStyle
-
>
StyleMargin
(
)
;
if
(
oldMargin
-
>
GetMargin
(
oldValue
)
)
{
if
(
!
StyleMargin
(
)
-
>
GetMargin
(
newValue
)
|
|
oldValue
!
=
newValue
)
{
if
(
!
HasProperty
(
UsedMarginProperty
(
)
)
)
{
AddProperty
(
UsedMarginProperty
(
)
new
nsMargin
(
oldValue
)
)
;
}
needAnchorSuppression
=
true
;
}
}
const
nsStylePadding
*
oldPadding
=
aOldComputedStyle
-
>
StylePadding
(
)
;
if
(
oldPadding
-
>
GetPadding
(
oldValue
)
)
{
if
(
!
StylePadding
(
)
-
>
GetPadding
(
newValue
)
|
|
oldValue
!
=
newValue
)
{
if
(
!
HasProperty
(
UsedPaddingProperty
(
)
)
)
{
AddProperty
(
UsedPaddingProperty
(
)
new
nsMargin
(
oldValue
)
)
;
}
needAnchorSuppression
=
true
;
}
}
const
nsStyleBorder
*
oldBorder
=
aOldComputedStyle
-
>
StyleBorder
(
)
;
oldValue
=
oldBorder
-
>
GetComputedBorder
(
)
;
newValue
=
StyleBorder
(
)
-
>
GetComputedBorder
(
)
;
if
(
oldValue
!
=
newValue
&
&
!
HasProperty
(
UsedBorderProperty
(
)
)
)
{
AddProperty
(
UsedBorderProperty
(
)
new
nsMargin
(
oldValue
)
)
;
}
const
nsStyleDisplay
*
oldDisp
=
aOldComputedStyle
-
>
StyleDisplay
(
)
;
if
(
oldDisp
-
>
mOverflowAnchor
!
=
disp
-
>
mOverflowAnchor
)
{
if
(
auto
*
container
=
ScrollAnchorContainer
:
:
FindFor
(
this
)
)
{
container
-
>
InvalidateAnchor
(
)
;
}
if
(
nsIScrollableFrame
*
scrollableFrame
=
do_QueryFrame
(
this
)
)
{
scrollableFrame
-
>
Anchor
(
)
-
>
InvalidateAnchor
(
)
;
}
}
if
(
mInScrollAnchorChain
)
{
const
nsStylePosition
*
pos
=
StylePosition
(
)
;
const
nsStylePosition
*
oldPos
=
aOldComputedStyle
-
>
StylePosition
(
)
;
if
(
!
needAnchorSuppression
&
&
(
oldPos
-
>
mOffset
!
=
pos
-
>
mOffset
|
|
oldPos
-
>
mWidth
!
=
pos
-
>
mWidth
|
|
oldPos
-
>
mMinWidth
!
=
pos
-
>
mMinWidth
|
|
oldPos
-
>
mMaxWidth
!
=
pos
-
>
mMaxWidth
|
|
oldPos
-
>
mHeight
!
=
pos
-
>
mHeight
|
|
oldPos
-
>
mMinHeight
!
=
pos
-
>
mMinHeight
|
|
oldPos
-
>
mMaxHeight
!
=
pos
-
>
mMaxHeight
|
|
oldDisp
-
>
mPosition
!
=
disp
-
>
mPosition
|
|
oldDisp
-
>
mTransform
!
=
disp
-
>
mTransform
)
)
{
needAnchorSuppression
=
true
;
}
if
(
needAnchorSuppression
&
&
StaticPrefs
:
:
layout_css_scroll_anchoring_suppressions_enabled
(
)
)
{
ScrollAnchorContainer
:
:
FindFor
(
this
)
-
>
SuppressAdjustments
(
)
;
}
}
if
(
disp
-
>
mPosition
!
=
oldDisp
-
>
mPosition
)
{
if
(
!
disp
-
>
IsRelativelyOrStickyPositionedStyle
(
)
&
&
oldDisp
-
>
IsRelativelyOrStickyPositionedStyle
(
)
)
{
RemoveProperty
(
NormalPositionProperty
(
)
)
;
}
handleStickyChange
=
disp
-
>
mPosition
=
=
StylePositionProperty
:
:
Sticky
|
|
oldDisp
-
>
mPosition
=
=
StylePositionProperty
:
:
Sticky
;
}
if
(
disp
-
>
mScrollSnapAlign
!
=
oldDisp
-
>
mScrollSnapAlign
)
{
ScrollSnapUtils
:
:
PostPendingResnapFor
(
this
)
;
}
if
(
aOldComputedStyle
-
>
IsRootElementStyle
(
)
&
&
disp
-
>
mScrollSnapType
!
=
oldDisp
-
>
mScrollSnapType
)
{
if
(
nsIScrollableFrame
*
scrollableFrame
=
PresShell
(
)
-
>
GetRootScrollFrameAsScrollable
(
)
)
{
scrollableFrame
-
>
PostPendingResnap
(
)
;
}
}
}
else
{
handleStickyChange
=
disp
-
>
mPosition
=
=
StylePositionProperty
:
:
Sticky
;
}
if
(
handleStickyChange
&
&
!
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
&
&
!
GetPrevInFlow
(
)
)
{
if
(
auto
*
ssc
=
StickyScrollContainer
:
:
GetStickyScrollContainerForFrame
(
this
)
)
{
if
(
disp
-
>
mPosition
=
=
StylePositionProperty
:
:
Sticky
)
{
ssc
-
>
AddFrame
(
this
)
;
}
else
{
ssc
-
>
RemoveFrame
(
this
)
;
}
}
}
imgIRequest
*
oldBorderImage
=
aOldComputedStyle
?
aOldComputedStyle
-
>
StyleBorder
(
)
-
>
GetBorderImageRequest
(
)
:
nullptr
;
imgIRequest
*
newBorderImage
=
StyleBorder
(
)
-
>
GetBorderImageRequest
(
)
;
if
(
oldBorderImage
!
=
newBorderImage
)
{
if
(
oldBorderImage
&
&
HasImageRequest
(
)
)
{
RemoveProperty
(
CachedBorderImageDataProperty
(
)
)
;
loader
-
>
DisassociateRequestFromFrame
(
oldBorderImage
this
)
;
}
if
(
newBorderImage
)
{
loader
-
>
AssociateRequestToFrame
(
newBorderImage
this
)
;
}
}
auto
GetShapeImageRequest
=
[
]
(
const
ComputedStyle
*
aStyle
)
-
>
imgIRequest
*
{
if
(
!
aStyle
)
{
return
nullptr
;
}
auto
&
shape
=
aStyle
-
>
StyleDisplay
(
)
-
>
mShapeOutside
;
if
(
!
shape
.
IsImage
(
)
)
{
return
nullptr
;
}
return
shape
.
AsImage
(
)
.
GetImageRequest
(
)
;
}
;
imgIRequest
*
oldShapeImage
=
GetShapeImageRequest
(
aOldComputedStyle
)
;
imgIRequest
*
newShapeImage
=
GetShapeImageRequest
(
Style
(
)
)
;
if
(
oldShapeImage
!
=
newShapeImage
)
{
if
(
oldShapeImage
&
&
HasImageRequest
(
)
)
{
loader
-
>
DisassociateRequestFromFrame
(
oldShapeImage
this
)
;
}
if
(
newShapeImage
)
{
loader
-
>
AssociateRequestToFrame
(
newShapeImage
this
ImageLoader
:
:
Flags
:
:
RequiresReflowOnFirstFrameCompleteAndLoadEventBlocking
)
;
}
}
const
bool
isNonTextFirstContinuation
=
isNonText
&
&
!
GetPrevContinuation
(
)
;
if
(
isNonTextFirstContinuation
)
{
SVGObserverUtils
:
:
InitiateResourceDocLoads
(
this
)
;
}
if
(
StyleVisibility
(
)
-
>
mDirection
=
=
StyleDirection
:
:
Rtl
)
{
PresContext
(
)
-
>
SetBidiEnabled
(
)
;
}
const
StyleOffsetPath
*
oldPath
=
aOldComputedStyle
?
&
aOldComputedStyle
-
>
StyleDisplay
(
)
-
>
mOffsetPath
:
nullptr
;
const
StyleOffsetPath
&
newPath
=
StyleDisplay
(
)
-
>
mOffsetPath
;
if
(
!
oldPath
|
|
*
oldPath
!
=
newPath
)
{
if
(
newPath
.
IsPath
(
)
)
{
RefPtr
<
gfx
:
:
PathBuilder
>
builder
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
ScreenReferenceDrawTarget
(
)
-
>
CreatePathBuilder
(
gfx
:
:
FillRule
:
:
FILL_WINDING
)
;
RefPtr
<
gfx
:
:
Path
>
path
=
MotionPathUtils
:
:
BuildPath
(
newPath
.
AsPath
(
)
builder
)
;
if
(
path
)
{
SetProperty
(
nsIFrame
:
:
OffsetPathCache
(
)
path
.
forget
(
)
.
take
(
)
)
;
}
else
{
RemoveProperty
(
nsIFrame
:
:
OffsetPathCache
(
)
)
;
}
}
else
if
(
oldPath
)
{
RemoveProperty
(
nsIFrame
:
:
OffsetPathCache
(
)
)
;
}
}
RemoveStateBits
(
NS_FRAME_SIMPLE_EVENT_REGIONS
|
NS_FRAME_SIMPLE_DISPLAYLIST
)
;
mMayHaveRoundedCorners
=
true
;
}
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
void
nsIFrame
:
:
AssertNewStyleIsSane
(
ComputedStyle
&
aNewStyle
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aNewStyle
.
GetPseudoType
(
)
=
=
mComputedStyle
-
>
GetPseudoType
(
)
|
|
(
mComputedStyle
-
>
GetPseudoType
(
)
=
=
PseudoStyleType
:
:
firstLine
&
&
aNewStyle
.
GetPseudoType
(
)
=
=
PseudoStyleType
:
:
mozLineFrame
)
|
|
(
mComputedStyle
-
>
GetPseudoType
(
)
=
=
PseudoStyleType
:
:
mozText
&
&
aNewStyle
.
GetPseudoType
(
)
=
=
PseudoStyleType
:
:
firstLetterContinuation
)
|
|
(
mComputedStyle
-
>
GetPseudoType
(
)
=
=
PseudoStyleType
:
:
firstLetterContinuation
&
&
aNewStyle
.
GetPseudoType
(
)
=
=
PseudoStyleType
:
:
mozText
)
)
;
}
#
endif
void
nsIFrame
:
:
ReparentFrameViewTo
(
nsViewManager
*
aViewManager
nsView
*
aNewParentView
nsView
*
aOldParentView
)
{
if
(
HasView
(
)
)
{
if
(
IsMenuPopupFrame
(
)
)
{
return
;
}
nsView
*
view
=
GetView
(
)
;
aViewManager
-
>
RemoveChild
(
view
)
;
nsView
*
insertBefore
=
nsLayoutUtils
:
:
FindSiblingViewFor
(
aNewParentView
this
)
;
aViewManager
-
>
InsertChild
(
aNewParentView
view
insertBefore
insertBefore
!
=
nullptr
)
;
}
else
if
(
HasAnyStateBits
(
NS_FRAME_HAS_CHILD_WITH_VIEW
)
)
{
for
(
const
auto
&
childList
:
ChildLists
(
)
)
{
for
(
nsIFrame
*
child
:
childList
.
mList
)
{
child
-
>
ReparentFrameViewTo
(
aViewManager
aNewParentView
aOldParentView
)
;
}
}
}
}
void
nsIFrame
:
:
SyncFrameViewProperties
(
nsView
*
aView
)
{
if
(
!
aView
)
{
aView
=
GetView
(
)
;
if
(
!
aView
)
{
return
;
}
}
nsViewManager
*
vm
=
aView
-
>
GetViewManager
(
)
;
if
(
!
SupportsVisibilityHidden
(
)
)
{
ComputedStyle
*
sc
=
Style
(
)
;
vm
-
>
SetViewVisibility
(
aView
sc
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
?
nsViewVisibility_kShow
:
nsViewVisibility_kHide
)
;
}
const
auto
zIndex
=
ZIndex
(
)
;
const
bool
autoZIndex
=
!
zIndex
;
vm
-
>
SetViewZIndex
(
aView
autoZIndex
zIndex
.
valueOr
(
0
)
)
;
}
void
nsIFrame
:
:
CreateView
(
)
{
MOZ_ASSERT
(
!
HasView
(
)
)
;
nsView
*
parentView
=
GetParent
(
)
-
>
GetClosestView
(
)
;
MOZ_ASSERT
(
parentView
"
no
parent
with
view
"
)
;
nsViewManager
*
viewManager
=
parentView
-
>
GetViewManager
(
)
;
MOZ_ASSERT
(
viewManager
"
null
view
manager
"
)
;
nsView
*
view
=
viewManager
-
>
CreateView
(
GetRect
(
)
parentView
)
;
SyncFrameViewProperties
(
view
)
;
nsView
*
insertBefore
=
nsLayoutUtils
:
:
FindSiblingViewFor
(
parentView
this
)
;
viewManager
-
>
InsertChild
(
parentView
view
insertBefore
insertBefore
!
=
nullptr
)
;
ReparentFrameViewTo
(
viewManager
view
parentView
)
;
SetView
(
view
)
;
NS_FRAME_LOG
(
NS_FRAME_TRACE_CALLS
(
"
nsIFrame
:
:
CreateView
:
frame
=
%
p
view
=
%
p
"
this
view
)
)
;
}
#
ifndef
_MSC_VER
const
nsIFrame
:
:
ChildListID
nsIFrame
:
:
kPrincipalList
;
const
nsIFrame
:
:
ChildListID
nsIFrame
:
:
kAbsoluteList
;
const
nsIFrame
:
:
ChildListID
nsIFrame
:
:
kBulletList
;
const
nsIFrame
:
:
ChildListID
nsIFrame
:
:
kCaptionList
;
const
nsIFrame
:
:
ChildListID
nsIFrame
:
:
kColGroupList
;
const
nsIFrame
:
:
ChildListID
nsIFrame
:
:
kExcessOverflowContainersList
;
const
nsIFrame
:
:
ChildListID
nsIFrame
:
:
kFixedList
;
const
nsIFrame
:
:
ChildListID
nsIFrame
:
:
kFloatList
;
const
nsIFrame
:
:
ChildListID
nsIFrame
:
:
kOverflowContainersList
;
const
nsIFrame
:
:
ChildListID
nsIFrame
:
:
kOverflowList
;
const
nsIFrame
:
:
ChildListID
nsIFrame
:
:
kOverflowOutOfFlowList
;
const
nsIFrame
:
:
ChildListID
nsIFrame
:
:
kPopupList
;
const
nsIFrame
:
:
ChildListID
nsIFrame
:
:
kPushedFloatsList
;
const
nsIFrame
:
:
ChildListID
nsIFrame
:
:
kNoReflowPrincipalList
;
#
endif
nsMargin
nsIFrame
:
:
GetUsedMargin
(
)
const
{
nsMargin
margin
(
0
0
0
0
)
;
if
(
(
(
mState
&
NS_FRAME_FIRST_REFLOW
)
&
&
!
(
mState
&
NS_FRAME_IN_REFLOW
)
)
|
|
SVGUtils
:
:
IsInSVGTextSubtree
(
this
)
)
return
margin
;
nsMargin
*
m
=
GetProperty
(
UsedMarginProperty
(
)
)
;
if
(
m
)
{
margin
=
*
m
;
}
else
{
if
(
!
StyleMargin
(
)
-
>
GetMargin
(
margin
)
)
{
NS_ERROR
(
"
Returning
bogus
0
-
sized
margin
because
this
margin
"
"
depends
on
layout
&
isn
'
t
cached
!
"
)
;
}
}
return
margin
;
}
nsMargin
nsIFrame
:
:
GetUsedBorder
(
)
const
{
nsMargin
border
(
0
0
0
0
)
;
if
(
(
(
mState
&
NS_FRAME_FIRST_REFLOW
)
&
&
!
(
mState
&
NS_FRAME_IN_REFLOW
)
)
|
|
SVGUtils
:
:
IsInSVGTextSubtree
(
this
)
)
return
border
;
nsIFrame
*
mutable_this
=
const_cast
<
nsIFrame
*
>
(
this
)
;
const
nsStyleDisplay
*
disp
=
StyleDisplay
(
)
;
if
(
mutable_this
-
>
IsThemed
(
disp
)
)
{
nsPresContext
*
pc
=
PresContext
(
)
;
LayoutDeviceIntMargin
widgetBorder
=
pc
-
>
Theme
(
)
-
>
GetWidgetBorder
(
pc
-
>
DeviceContext
(
)
mutable_this
disp
-
>
EffectiveAppearance
(
)
)
;
border
=
LayoutDevicePixel
:
:
ToAppUnits
(
widgetBorder
pc
-
>
AppUnitsPerDevPixel
(
)
)
;
return
border
;
}
nsMargin
*
b
=
GetProperty
(
UsedBorderProperty
(
)
)
;
if
(
b
)
{
border
=
*
b
;
}
else
{
border
=
StyleBorder
(
)
-
>
GetComputedBorder
(
)
;
}
return
border
;
}
nsMargin
nsIFrame
:
:
GetUsedPadding
(
)
const
{
nsMargin
padding
(
0
0
0
0
)
;
if
(
(
(
mState
&
NS_FRAME_FIRST_REFLOW
)
&
&
!
(
mState
&
NS_FRAME_IN_REFLOW
)
)
|
|
SVGUtils
:
:
IsInSVGTextSubtree
(
this
)
)
return
padding
;
nsIFrame
*
mutable_this
=
const_cast
<
nsIFrame
*
>
(
this
)
;
const
nsStyleDisplay
*
disp
=
StyleDisplay
(
)
;
if
(
mutable_this
-
>
IsThemed
(
disp
)
)
{
nsPresContext
*
pc
=
PresContext
(
)
;
LayoutDeviceIntMargin
widgetPadding
;
if
(
pc
-
>
Theme
(
)
-
>
GetWidgetPadding
(
pc
-
>
DeviceContext
(
)
mutable_this
disp
-
>
EffectiveAppearance
(
)
&
widgetPadding
)
)
{
return
LayoutDevicePixel
:
:
ToAppUnits
(
widgetPadding
pc
-
>
AppUnitsPerDevPixel
(
)
)
;
}
}
nsMargin
*
p
=
GetProperty
(
UsedPaddingProperty
(
)
)
;
if
(
p
)
{
padding
=
*
p
;
}
else
{
if
(
!
StylePadding
(
)
-
>
GetPadding
(
padding
)
)
{
NS_ERROR
(
"
Returning
bogus
0
-
sized
padding
because
this
padding
"
"
depends
on
layout
&
isn
'
t
cached
!
"
)
;
}
}
return
padding
;
}
nsIFrame
:
:
Sides
nsIFrame
:
:
GetSkipSides
(
)
const
{
if
(
MOZ_UNLIKELY
(
StyleBorder
(
)
-
>
mBoxDecorationBreak
=
=
StyleBoxDecorationBreak
:
:
Clone
)
&
&
!
HasAnyStateBits
(
NS_FRAME_IS_OVERFLOW_CONTAINER
)
)
{
return
Sides
(
)
;
}
WritingMode
writingMode
=
GetWritingMode
(
)
;
LogicalSides
logicalSkip
=
GetLogicalSkipSides
(
)
;
Sides
skip
;
if
(
logicalSkip
.
BStart
(
)
)
{
if
(
writingMode
.
IsVertical
(
)
)
{
skip
|
=
writingMode
.
IsVerticalLR
(
)
?
SideBits
:
:
eLeft
:
SideBits
:
:
eRight
;
}
else
{
skip
|
=
SideBits
:
:
eTop
;
}
}
if
(
logicalSkip
.
BEnd
(
)
)
{
if
(
writingMode
.
IsVertical
(
)
)
{
skip
|
=
writingMode
.
IsVerticalLR
(
)
?
SideBits
:
:
eRight
:
SideBits
:
:
eLeft
;
}
else
{
skip
|
=
SideBits
:
:
eBottom
;
}
}
if
(
logicalSkip
.
IStart
(
)
)
{
if
(
writingMode
.
IsVertical
(
)
)
{
skip
|
=
SideBits
:
:
eTop
;
}
else
{
skip
|
=
writingMode
.
IsBidiLTR
(
)
?
SideBits
:
:
eLeft
:
SideBits
:
:
eRight
;
}
}
if
(
logicalSkip
.
IEnd
(
)
)
{
if
(
writingMode
.
IsVertical
(
)
)
{
skip
|
=
SideBits
:
:
eBottom
;
}
else
{
skip
|
=
writingMode
.
IsBidiLTR
(
)
?
SideBits
:
:
eRight
:
SideBits
:
:
eLeft
;
}
}
return
skip
;
}
nsRect
nsIFrame
:
:
GetPaddingRectRelativeToSelf
(
)
const
{
nsMargin
border
=
GetUsedBorder
(
)
.
ApplySkipSides
(
GetSkipSides
(
)
)
;
nsRect
r
(
0
0
mRect
.
width
mRect
.
height
)
;
r
.
Deflate
(
border
)
;
return
r
;
}
nsRect
nsIFrame
:
:
GetPaddingRect
(
)
const
{
return
GetPaddingRectRelativeToSelf
(
)
+
GetPosition
(
)
;
}
WritingMode
nsIFrame
:
:
WritingModeForLine
(
WritingMode
aSelfWM
nsIFrame
*
aSubFrame
)
const
{
MOZ_ASSERT
(
aSelfWM
=
=
GetWritingMode
(
)
)
;
WritingMode
writingMode
=
aSelfWM
;
if
(
StyleTextReset
(
)
-
>
mUnicodeBidi
&
NS_STYLE_UNICODE_BIDI_PLAINTEXT
)
{
mozilla
:
:
intl
:
:
BidiEmbeddingLevel
frameLevel
=
nsBidiPresUtils
:
:
GetFrameBaseLevel
(
aSubFrame
)
;
writingMode
.
SetDirectionFromBidiLevel
(
frameLevel
)
;
}
return
writingMode
;
}
nsRect
nsIFrame
:
:
GetMarginRect
(
)
const
{
return
GetMarginRectRelativeToSelf
(
)
+
GetPosition
(
)
;
}
nsRect
nsIFrame
:
:
GetMarginRectRelativeToSelf
(
)
const
{
nsMargin
m
=
GetUsedMargin
(
)
.
ApplySkipSides
(
GetSkipSides
(
)
)
;
nsRect
r
(
0
0
mRect
.
width
mRect
.
height
)
;
r
.
Inflate
(
m
)
;
return
r
;
}
bool
nsIFrame
:
:
IsTransformed
(
)
const
{
if
(
!
HasAnyStateBits
(
NS_FRAME_MAY_BE_TRANSFORMED
)
)
{
MOZ_ASSERT
(
!
IsCSSTransformed
(
)
)
;
MOZ_ASSERT
(
!
IsSVGTransformed
(
)
)
;
return
false
;
}
return
IsCSSTransformed
(
)
|
|
IsSVGTransformed
(
)
;
}
bool
nsIFrame
:
:
IsCSSTransformed
(
)
const
{
return
HasAnyStateBits
(
NS_FRAME_MAY_BE_TRANSFORMED
)
&
&
(
StyleDisplay
(
)
-
>
HasTransform
(
this
)
|
|
HasAnimationOfTransform
(
)
)
;
}
bool
nsIFrame
:
:
HasAnimationOfTransform
(
)
const
{
return
IsPrimaryFrame
(
)
&
&
nsLayoutUtils
:
:
HasAnimationOfTransformAndMotionPath
(
this
)
&
&
IsFrameOfType
(
eSupportsCSSTransforms
)
;
}
bool
nsIFrame
:
:
ChildrenHavePerspective
(
const
nsStyleDisplay
*
aStyleDisplay
)
const
{
MOZ_ASSERT
(
aStyleDisplay
=
=
StyleDisplay
(
)
)
;
return
aStyleDisplay
-
>
HasPerspective
(
this
)
;
}
bool
nsIFrame
:
:
HasAnimationOfOpacity
(
EffectSet
*
aEffectSet
)
const
{
return
(
(
nsLayoutUtils
:
:
IsPrimaryStyleFrame
(
this
)
|
|
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
this
)
-
>
IsPrimaryFrame
(
)
)
&
&
nsLayoutUtils
:
:
HasAnimationOfPropertySet
(
this
nsCSSPropertyIDSet
:
:
OpacityProperties
(
)
aEffectSet
)
)
;
}
bool
nsIFrame
:
:
HasOpacityInternal
(
float
aThreshold
const
nsStyleDisplay
*
aStyleDisplay
const
nsStyleEffects
*
aStyleEffects
EffectSet
*
aEffectSet
)
const
{
MOZ_ASSERT
(
0
.
0
<
=
aThreshold
&
&
aThreshold
<
=
1
.
0
"
Invalid
argument
"
)
;
if
(
aStyleEffects
-
>
mOpacity
<
aThreshold
|
|
aStyleDisplay
-
>
mWillChange
.
bits
&
StyleWillChangeBits
:
:
OPACITY
)
{
return
true
;
}
if
(
!
mMayHaveOpacityAnimation
)
{
return
false
;
}
return
HasAnimationOfOpacity
(
aEffectSet
)
;
}
bool
nsIFrame
:
:
IsSVGTransformed
(
gfx
:
:
Matrix
*
aOwnTransforms
gfx
:
:
Matrix
*
aFromParentTransforms
)
const
{
return
false
;
}
bool
nsIFrame
:
:
Extend3DContext
(
const
nsStyleDisplay
*
aStyleDisplay
const
nsStyleEffects
*
aStyleEffects
mozilla
:
:
EffectSet
*
aEffectSetForOpacity
)
const
{
if
(
!
(
mState
&
NS_FRAME_MAY_BE_TRANSFORMED
)
)
{
return
false
;
}
const
nsStyleDisplay
*
disp
=
StyleDisplayWithOptionalParam
(
aStyleDisplay
)
;
if
(
disp
-
>
mTransformStyle
!
=
StyleTransformStyle
:
:
Preserve3d
|
|
!
IsFrameOfType
(
nsIFrame
:
:
eSupportsCSSTransforms
)
)
{
return
false
;
}
if
(
IsScrollFrame
(
)
)
{
return
false
;
}
const
nsStyleEffects
*
effects
=
StyleEffectsWithOptionalParam
(
aStyleEffects
)
;
if
(
HasOpacity
(
disp
effects
aEffectSetForOpacity
)
)
{
return
false
;
}
return
ShouldApplyOverflowClipping
(
disp
)
=
=
PhysicalAxes
:
:
None
&
&
!
GetClipPropClipRect
(
disp
effects
GetSize
(
)
)
&
&
!
SVGIntegrationUtils
:
:
UsingEffectsForFrame
(
this
)
&
&
!
effects
-
>
HasMixBlendMode
(
)
&
&
disp
-
>
mIsolation
!
=
StyleIsolation
:
:
Isolate
;
}
bool
nsIFrame
:
:
Combines3DTransformWithAncestors
(
)
const
{
nsIFrame
*
parent
=
GetClosestFlattenedTreeAncestorPrimaryFrame
(
)
;
if
(
!
parent
|
|
!
parent
-
>
Extend3DContext
(
)
)
{
return
false
;
}
return
IsCSSTransformed
(
)
|
|
BackfaceIsHidden
(
)
;
}
bool
nsIFrame
:
:
In3DContextAndBackfaceIsHidden
(
)
const
{
return
BackfaceIsHidden
(
)
&
&
Combines3DTransformWithAncestors
(
)
;
}
bool
nsIFrame
:
:
HasPerspective
(
)
const
{
if
(
!
IsCSSTransformed
(
)
)
{
return
false
;
}
nsIFrame
*
parent
=
GetClosestFlattenedTreeAncestorPrimaryFrame
(
)
;
if
(
!
parent
)
{
return
false
;
}
return
parent
-
>
ChildrenHavePerspective
(
)
;
}
nsRect
nsIFrame
:
:
GetContentRectRelativeToSelf
(
)
const
{
nsMargin
bp
=
GetUsedBorderAndPadding
(
)
.
ApplySkipSides
(
GetSkipSides
(
)
)
;
nsRect
r
(
0
0
mRect
.
width
mRect
.
height
)
;
r
.
Deflate
(
bp
)
;
return
r
;
}
nsRect
nsIFrame
:
:
GetContentRect
(
)
const
{
return
GetContentRectRelativeToSelf
(
)
+
GetPosition
(
)
;
}
bool
nsIFrame
:
:
ComputeBorderRadii
(
const
BorderRadius
&
aBorderRadius
const
nsSize
&
aFrameSize
const
nsSize
&
aBorderArea
Sides
aSkipSides
nscoord
aRadii
[
8
]
)
{
for
(
const
auto
i
:
mozilla
:
:
AllPhysicalHalfCorners
(
)
)
{
const
LengthPercentage
&
c
=
aBorderRadius
.
Get
(
i
)
;
nscoord
axis
=
HalfCornerIsX
(
i
)
?
aFrameSize
.
width
:
aFrameSize
.
height
;
aRadii
[
i
]
=
std
:
:
max
(
0
c
.
Resolve
(
axis
)
)
;
}
if
(
aSkipSides
.
Top
(
)
)
{
aRadii
[
eCornerTopLeftX
]
=
0
;
aRadii
[
eCornerTopLeftY
]
=
0
;
aRadii
[
eCornerTopRightX
]
=
0
;
aRadii
[
eCornerTopRightY
]
=
0
;
}
if
(
aSkipSides
.
Right
(
)
)
{
aRadii
[
eCornerTopRightX
]
=
0
;
aRadii
[
eCornerTopRightY
]
=
0
;
aRadii
[
eCornerBottomRightX
]
=
0
;
aRadii
[
eCornerBottomRightY
]
=
0
;
}
if
(
aSkipSides
.
Bottom
(
)
)
{
aRadii
[
eCornerBottomRightX
]
=
0
;
aRadii
[
eCornerBottomRightY
]
=
0
;
aRadii
[
eCornerBottomLeftX
]
=
0
;
aRadii
[
eCornerBottomLeftY
]
=
0
;
}
if
(
aSkipSides
.
Left
(
)
)
{
aRadii
[
eCornerBottomLeftX
]
=
0
;
aRadii
[
eCornerBottomLeftY
]
=
0
;
aRadii
[
eCornerTopLeftX
]
=
0
;
aRadii
[
eCornerTopLeftY
]
=
0
;
}
bool
haveRadius
=
false
;
double
ratio
=
1
.
0f
;
for
(
const
auto
side
:
mozilla
:
:
AllPhysicalSides
(
)
)
{
uint32_t
hc1
=
SideToHalfCorner
(
side
false
true
)
;
uint32_t
hc2
=
SideToHalfCorner
(
side
true
true
)
;
nscoord
length
=
SideIsVertical
(
side
)
?
aBorderArea
.
height
:
aBorderArea
.
width
;
nscoord
sum
=
aRadii
[
hc1
]
+
aRadii
[
hc2
]
;
if
(
sum
)
{
haveRadius
=
true
;
if
(
length
<
sum
)
{
ratio
=
std
:
:
min
(
ratio
double
(
length
)
/
sum
)
;
}
}
}
if
(
ratio
<
1
.
0
)
{
for
(
const
auto
corner
:
mozilla
:
:
AllPhysicalHalfCorners
(
)
)
{
aRadii
[
corner
]
*
=
ratio
;
}
}
return
haveRadius
;
}
void
nsIFrame
:
:
AdjustBorderRadii
(
nscoord
aRadii
[
8
]
const
nsMargin
&
aOffsets
)
{
auto
AdjustOffset
=
[
]
(
const
uint32_t
aRadius
const
nscoord
aOffset
)
{
if
(
aOffset
>
0
)
{
const
double
ratio
=
aRadius
/
double
(
aOffset
)
;
if
(
ratio
<
1
.
0
)
{
return
nscoord
(
aOffset
*
(
1
.
0
+
std
:
:
pow
(
ratio
-
1
3
)
)
)
;
}
}
return
aOffset
;
}
;
for
(
const
auto
side
:
mozilla
:
:
AllPhysicalSides
(
)
)
{
const
nscoord
offset
=
aOffsets
.
Side
(
side
)
;
const
uint32_t
hc1
=
SideToHalfCorner
(
side
false
false
)
;
const
uint32_t
hc2
=
SideToHalfCorner
(
side
true
false
)
;
if
(
aRadii
[
hc1
]
>
0
)
{
const
nscoord
offset1
=
AdjustOffset
(
aRadii
[
hc1
]
offset
)
;
aRadii
[
hc1
]
=
std
:
:
max
(
0
aRadii
[
hc1
]
+
offset1
)
;
}
if
(
aRadii
[
hc2
]
>
0
)
{
const
nscoord
offset2
=
AdjustOffset
(
aRadii
[
hc2
]
offset
)
;
aRadii
[
hc2
]
=
std
:
:
max
(
0
aRadii
[
hc2
]
+
offset2
)
;
}
}
}
static
inline
bool
RadiiAreDefinitelyZero
(
const
BorderRadius
&
aBorderRadius
)
{
for
(
const
auto
corner
:
mozilla
:
:
AllPhysicalHalfCorners
(
)
)
{
if
(
!
aBorderRadius
.
Get
(
corner
)
.
IsDefinitelyZero
(
)
)
{
return
false
;
}
}
return
true
;
}
bool
nsIFrame
:
:
GetBorderRadii
(
const
nsSize
&
aFrameSize
const
nsSize
&
aBorderArea
Sides
aSkipSides
nscoord
aRadii
[
8
]
)
const
{
if
(
!
mMayHaveRoundedCorners
)
{
memset
(
aRadii
0
sizeof
(
nscoord
)
*
8
)
;
return
false
;
}
if
(
IsThemed
(
)
)
{
for
(
const
auto
corner
:
mozilla
:
:
AllPhysicalHalfCorners
(
)
)
{
aRadii
[
corner
]
=
0
;
}
return
false
;
}
const
auto
&
radii
=
StyleBorder
(
)
-
>
mBorderRadius
;
const
bool
hasRadii
=
ComputeBorderRadii
(
radii
aFrameSize
aBorderArea
aSkipSides
aRadii
)
;
if
(
!
hasRadii
)
{
const_cast
<
nsIFrame
*
>
(
this
)
-
>
mMayHaveRoundedCorners
=
!
RadiiAreDefinitelyZero
(
radii
)
;
}
return
hasRadii
;
}
bool
nsIFrame
:
:
GetBorderRadii
(
nscoord
aRadii
[
8
]
)
const
{
nsSize
sz
=
GetSize
(
)
;
return
GetBorderRadii
(
sz
sz
GetSkipSides
(
)
aRadii
)
;
}
bool
nsIFrame
:
:
GetMarginBoxBorderRadii
(
nscoord
aRadii
[
8
]
)
const
{
return
GetBoxBorderRadii
(
aRadii
GetUsedMargin
(
)
)
;
}
bool
nsIFrame
:
:
GetPaddingBoxBorderRadii
(
nscoord
aRadii
[
8
]
)
const
{
return
GetBoxBorderRadii
(
aRadii
-
GetUsedBorder
(
)
)
;
}
bool
nsIFrame
:
:
GetContentBoxBorderRadii
(
nscoord
aRadii
[
8
]
)
const
{
return
GetBoxBorderRadii
(
aRadii
-
GetUsedBorderAndPadding
(
)
)
;
}
bool
nsIFrame
:
:
GetBoxBorderRadii
(
nscoord
aRadii
[
8
]
const
nsMargin
&
aOffsets
)
const
{
if
(
!
GetBorderRadii
(
aRadii
)
)
{
return
false
;
}
AdjustBorderRadii
(
aRadii
aOffsets
)
;
for
(
const
auto
corner
:
mozilla
:
:
AllPhysicalHalfCorners
(
)
)
{
if
(
aRadii
[
corner
]
)
{
return
true
;
}
}
return
false
;
}
bool
nsIFrame
:
:
GetShapeBoxBorderRadii
(
nscoord
aRadii
[
8
]
)
const
{
using
Tag
=
StyleShapeOutside
:
:
Tag
;
auto
&
shapeOutside
=
StyleDisplay
(
)
-
>
mShapeOutside
;
auto
box
=
StyleShapeBox
:
:
MarginBox
;
switch
(
shapeOutside
.
tag
)
{
case
Tag
:
:
Image
:
case
Tag
:
:
None
:
return
false
;
case
Tag
:
:
Box
:
box
=
shapeOutside
.
AsBox
(
)
;
break
;
case
Tag
:
:
Shape
:
box
=
shapeOutside
.
AsShape
(
)
.
_1
;
break
;
}
switch
(
box
)
{
case
StyleShapeBox
:
:
ContentBox
:
return
GetContentBoxBorderRadii
(
aRadii
)
;
case
StyleShapeBox
:
:
PaddingBox
:
return
GetPaddingBoxBorderRadii
(
aRadii
)
;
case
StyleShapeBox
:
:
BorderBox
:
return
GetBorderRadii
(
aRadii
)
;
case
StyleShapeBox
:
:
MarginBox
:
return
GetMarginBoxBorderRadii
(
aRadii
)
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
box
value
"
)
;
return
false
;
}
}
ComputedStyle
*
nsIFrame
:
:
GetAdditionalComputedStyle
(
int32_t
aIndex
)
const
{
MOZ_ASSERT
(
aIndex
>
=
0
"
invalid
index
number
"
)
;
return
nullptr
;
}
void
nsIFrame
:
:
SetAdditionalComputedStyle
(
int32_t
aIndex
ComputedStyle
*
aComputedStyle
)
{
MOZ_ASSERT
(
aIndex
>
=
0
"
invalid
index
number
"
)
;
}
nscoord
nsIFrame
:
:
GetLogicalBaseline
(
WritingMode
aWritingMode
)
const
{
NS_ASSERTION
(
!
IsSubtreeDirty
(
)
"
frame
must
not
be
dirty
"
)
;
if
(
aWritingMode
.
IsLineInverted
(
)
)
{
return
-
GetLogicalUsedMargin
(
aWritingMode
)
.
BStart
(
aWritingMode
)
;
}
return
BSize
(
aWritingMode
)
+
GetLogicalUsedMargin
(
aWritingMode
)
.
BEnd
(
aWritingMode
)
;
}
const
nsFrameList
&
nsIFrame
:
:
GetChildList
(
ChildListID
aListID
)
const
{
if
(
IsAbsoluteContainer
(
)
&
&
aListID
=
=
GetAbsoluteListID
(
)
)
{
return
GetAbsoluteContainingBlock
(
)
-
>
GetChildList
(
)
;
}
else
{
return
nsFrameList
:
:
EmptyList
(
)
;
}
}
void
nsIFrame
:
:
GetChildLists
(
nsTArray
<
ChildList
>
*
aLists
)
const
{
if
(
IsAbsoluteContainer
(
)
)
{
nsFrameList
absoluteList
=
GetAbsoluteContainingBlock
(
)
-
>
GetChildList
(
)
;
absoluteList
.
AppendIfNonempty
(
aLists
GetAbsoluteListID
(
)
)
;
}
}
AutoTArray
<
nsIFrame
:
:
ChildList
4
>
nsIFrame
:
:
CrossDocChildLists
(
)
{
AutoTArray
<
ChildList
4
>
childLists
;
nsSubDocumentFrame
*
subdocumentFrame
=
do_QueryFrame
(
this
)
;
if
(
subdocumentFrame
)
{
nsIFrame
*
root
=
subdocumentFrame
-
>
GetSubdocumentRootFrame
(
)
;
if
(
root
)
{
childLists
.
EmplaceBack
(
nsFrameList
(
root
nsLayoutUtils
:
:
GetLastSibling
(
root
)
)
nsIFrame
:
:
kPrincipalList
)
;
}
}
GetChildLists
(
&
childLists
)
;
return
childLists
;
}
Visibility
nsIFrame
:
:
GetVisibility
(
)
const
{
if
(
!
HasAnyStateBits
(
NS_FRAME_VISIBILITY_IS_TRACKED
)
)
{
return
Visibility
:
:
Untracked
;
}
bool
isSet
=
false
;
uint32_t
visibleCount
=
GetProperty
(
VisibilityStateProperty
(
)
&
isSet
)
;
MOZ_ASSERT
(
isSet
"
Should
have
a
VisibilityStateProperty
value
"
"
if
NS_FRAME_VISIBILITY_IS_TRACKED
is
set
"
)
;
return
visibleCount
>
0
?
Visibility
:
:
ApproximatelyVisible
:
Visibility
:
:
ApproximatelyNonVisible
;
}
void
nsIFrame
:
:
UpdateVisibilitySynchronously
(
)
{
mozilla
:
:
PresShell
*
presShell
=
PresShell
(
)
;
if
(
!
presShell
)
{
return
;
}
if
(
presShell
-
>
AssumeAllFramesVisible
(
)
)
{
presShell
-
>
EnsureFrameInApproximatelyVisibleList
(
this
)
;
return
;
}
bool
visible
=
StyleVisibility
(
)
-
>
IsVisible
(
)
;
nsIFrame
*
f
=
GetParent
(
)
;
nsRect
rect
=
GetRectRelativeToSelf
(
)
;
nsIFrame
*
rectFrame
=
this
;
while
(
f
&
&
visible
)
{
nsIScrollableFrame
*
sf
=
do_QueryFrame
(
f
)
;
if
(
sf
)
{
nsRect
transformedRect
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
rectFrame
rect
f
)
;
if
(
!
sf
-
>
IsRectNearlyVisible
(
transformedRect
)
)
{
visible
=
false
;
break
;
}
rect
=
transformedRect
.
MoveInsideAndClamp
(
sf
-
>
GetScrollPortRect
(
)
)
;
rectFrame
=
f
;
}
nsIFrame
*
parent
=
f
-
>
GetParent
(
)
;
if
(
!
parent
)
{
parent
=
nsLayoutUtils
:
:
GetCrossDocParentFrameInProcess
(
f
)
;
if
(
parent
&
&
parent
-
>
PresContext
(
)
-
>
IsChrome
(
)
)
{
break
;
}
}
f
=
parent
;
}
if
(
visible
)
{
presShell
-
>
EnsureFrameInApproximatelyVisibleList
(
this
)
;
}
else
{
presShell
-
>
RemoveFrameFromApproximatelyVisibleList
(
this
)
;
}
}
void
nsIFrame
:
:
EnableVisibilityTracking
(
)
{
if
(
HasAnyStateBits
(
NS_FRAME_VISIBILITY_IS_TRACKED
)
)
{
return
;
}
MOZ_ASSERT
(
!
HasProperty
(
VisibilityStateProperty
(
)
)
"
Shouldn
'
t
have
a
VisibilityStateProperty
value
"
"
if
NS_FRAME_VISIBILITY_IS_TRACKED
is
not
set
"
)
;
AddStateBits
(
NS_FRAME_VISIBILITY_IS_TRACKED
)
;
SetProperty
(
VisibilityStateProperty
(
)
0
)
;
mozilla
:
:
PresShell
*
presShell
=
PresShell
(
)
;
if
(
!
presShell
)
{
return
;
}
presShell
-
>
ScheduleApproximateFrameVisibilityUpdateSoon
(
)
;
}
void
nsIFrame
:
:
DisableVisibilityTracking
(
)
{
if
(
!
HasAnyStateBits
(
NS_FRAME_VISIBILITY_IS_TRACKED
)
)
{
return
;
}
bool
isSet
=
false
;
uint32_t
visibleCount
=
TakeProperty
(
VisibilityStateProperty
(
)
&
isSet
)
;
MOZ_ASSERT
(
isSet
"
Should
have
a
VisibilityStateProperty
value
"
"
if
NS_FRAME_VISIBILITY_IS_TRACKED
is
set
"
)
;
RemoveStateBits
(
NS_FRAME_VISIBILITY_IS_TRACKED
)
;
if
(
visibleCount
=
=
0
)
{
return
;
}
OnVisibilityChange
(
Visibility
:
:
ApproximatelyNonVisible
)
;
}
void
nsIFrame
:
:
DecApproximateVisibleCount
(
const
Maybe
<
OnNonvisible
>
&
aNonvisibleAction
)
{
MOZ_ASSERT
(
HasAnyStateBits
(
NS_FRAME_VISIBILITY_IS_TRACKED
)
)
;
bool
isSet
=
false
;
uint32_t
visibleCount
=
GetProperty
(
VisibilityStateProperty
(
)
&
isSet
)
;
MOZ_ASSERT
(
isSet
"
Should
have
a
VisibilityStateProperty
value
"
"
if
NS_FRAME_VISIBILITY_IS_TRACKED
is
set
"
)
;
MOZ_ASSERT
(
visibleCount
>
0
"
Frame
is
already
nonvisible
and
we
'
re
"
"
decrementing
its
visible
count
?
"
)
;
visibleCount
-
-
;
SetProperty
(
VisibilityStateProperty
(
)
visibleCount
)
;
if
(
visibleCount
>
0
)
{
return
;
}
OnVisibilityChange
(
Visibility
:
:
ApproximatelyNonVisible
aNonvisibleAction
)
;
}
void
nsIFrame
:
:
IncApproximateVisibleCount
(
)
{
MOZ_ASSERT
(
HasAnyStateBits
(
NS_FRAME_VISIBILITY_IS_TRACKED
)
)
;
bool
isSet
=
false
;
uint32_t
visibleCount
=
GetProperty
(
VisibilityStateProperty
(
)
&
isSet
)
;
MOZ_ASSERT
(
isSet
"
Should
have
a
VisibilityStateProperty
value
"
"
if
NS_FRAME_VISIBILITY_IS_TRACKED
is
set
"
)
;
visibleCount
+
+
;
SetProperty
(
VisibilityStateProperty
(
)
visibleCount
)
;
if
(
visibleCount
>
1
)
{
return
;
}
OnVisibilityChange
(
Visibility
:
:
ApproximatelyVisible
)
;
}
void
nsIFrame
:
:
OnVisibilityChange
(
Visibility
aNewVisibility
const
Maybe
<
OnNonvisible
>
&
aNonvisibleAction
)
{
}
static
nsIFrame
*
GetActiveSelectionFrame
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
)
{
nsIContent
*
capturingContent
=
PresShell
:
:
GetCapturingContent
(
)
;
if
(
capturingContent
)
{
nsIFrame
*
activeFrame
=
aPresContext
-
>
GetPrimaryFrameFor
(
capturingContent
)
;
return
activeFrame
?
activeFrame
:
aFrame
;
}
return
aFrame
;
}
int16_t
nsIFrame
:
:
DetermineDisplaySelection
(
)
{
int16_t
selType
=
nsISelectionController
:
:
SELECTION_OFF
;
nsCOMPtr
<
nsISelectionController
>
selCon
;
nsresult
result
=
GetSelectionController
(
PresContext
(
)
getter_AddRefs
(
selCon
)
)
;
if
(
NS_SUCCEEDED
(
result
)
&
&
selCon
)
{
result
=
selCon
-
>
GetDisplaySelection
(
&
selType
)
;
if
(
NS_SUCCEEDED
(
result
)
&
&
(
selType
!
=
nsISelectionController
:
:
SELECTION_OFF
)
)
{
if
(
!
IsSelectable
(
nullptr
)
)
{
selType
=
nsISelectionController
:
:
SELECTION_OFF
;
}
}
}
return
selType
;
}
static
Element
*
FindElementAncestorForMozSelection
(
nsIContent
*
aContent
)
{
NS_ENSURE_TRUE
(
aContent
nullptr
)
;
while
(
aContent
&
&
aContent
-
>
IsInNativeAnonymousSubtree
(
)
)
{
aContent
=
aContent
-
>
GetClosestNativeAnonymousSubtreeRootParent
(
)
;
}
NS_ASSERTION
(
aContent
"
aContent
isn
'
t
in
non
-
anonymous
tree
?
"
)
;
return
aContent
?
aContent
-
>
GetAsElementOrParentElement
(
)
:
nullptr
;
}
already_AddRefed
<
ComputedStyle
>
nsIFrame
:
:
ComputeSelectionStyle
(
int16_t
aSelectionStatus
)
const
{
if
(
aSelectionStatus
!
=
nsISelectionController
:
:
SELECTION_ON
&
&
aSelectionStatus
!
=
nsISelectionController
:
:
SELECTION_DISABLED
)
{
return
nullptr
;
}
if
(
PresContext
(
)
-
>
ForcingColors
(
)
)
{
return
nullptr
;
}
Element
*
element
=
FindElementAncestorForMozSelection
(
GetContent
(
)
)
;
if
(
!
element
)
{
return
nullptr
;
}
return
PresContext
(
)
-
>
StyleSet
(
)
-
>
ProbePseudoElementStyle
(
*
element
PseudoStyleType
:
:
selection
Style
(
)
)
;
}
template
<
typename
SizeOrMaxSize
>
static
inline
bool
IsIntrinsicKeyword
(
const
SizeOrMaxSize
&
aSize
)
{
return
aSize
.
IsMaxContent
(
)
|
|
aSize
.
IsMinContent
(
)
|
|
aSize
.
IsFitContent
(
)
|
|
aSize
.
IsFitContentFunction
(
)
;
}
bool
nsIFrame
:
:
CanBeDynamicReflowRoot
(
)
const
{
if
(
!
StaticPrefs
:
:
layout_dynamic_reflow_roots_enabled
(
)
)
{
return
false
;
}
auto
&
display
=
*
StyleDisplay
(
)
;
if
(
IsFrameOfType
(
nsIFrame
:
:
eLineParticipant
)
|
|
nsStyleDisplay
:
:
IsRubyDisplayType
(
display
.
mDisplay
)
|
|
display
.
DisplayOutside
(
)
=
=
StyleDisplayOutside
:
:
InternalTable
|
|
display
.
DisplayInside
(
)
=
=
StyleDisplayInside
:
:
Table
|
|
(
GetParent
(
)
&
&
GetParent
(
)
-
>
IsXULBoxFrame
(
)
)
)
{
MOZ_ASSERT
(
!
HasAnyStateBits
(
NS_FRAME_DYNAMIC_REFLOW_ROOT
)
"
should
not
have
dynamic
reflow
root
bit
"
)
;
return
false
;
}
auto
&
pos
=
*
StylePosition
(
)
;
const
auto
&
width
=
pos
.
mWidth
;
const
auto
&
height
=
pos
.
mHeight
;
if
(
!
width
.
IsLengthPercentage
(
)
|
|
width
.
HasPercent
(
)
|
|
!
height
.
IsLengthPercentage
(
)
|
|
height
.
HasPercent
(
)
|
|
IsIntrinsicKeyword
(
pos
.
mMinWidth
)
|
|
IsIntrinsicKeyword
(
pos
.
mMaxWidth
)
|
|
IsIntrinsicKeyword
(
pos
.
mMinHeight
)
|
|
IsIntrinsicKeyword
(
pos
.
mMaxHeight
)
|
|
(
(
pos
.
mMinWidth
.
IsAuto
(
)
|
|
pos
.
mMinHeight
.
IsAuto
(
)
)
&
&
IsFlexOrGridItem
(
)
)
)
{
return
false
;
}
if
(
IsFlexItem
(
)
)
{
const
auto
&
flexBasis
=
pos
.
mFlexBasis
;
if
(
!
flexBasis
.
IsAuto
(
)
)
{
if
(
!
flexBasis
.
IsSize
(
)
|
|
!
flexBasis
.
AsSize
(
)
.
IsLengthPercentage
(
)
|
|
flexBasis
.
AsSize
(
)
.
HasPercent
(
)
)
{
return
false
;
}
}
}
if
(
!
IsFixedPosContainingBlock
(
)
)
{
return
false
;
}
if
(
IsBlockFrameOrSubclass
(
)
&
&
!
HasAllStateBits
(
NS_BLOCK_FLOAT_MGR
|
NS_BLOCK_MARGIN_ROOT
)
)
{
return
false
;
}
if
(
pos
.
mGridTemplateColumns
.
IsSubgrid
(
)
|
|
pos
.
mGridTemplateRows
.
IsSubgrid
(
)
)
{
if
(
!
display
.
IsContainLayout
(
)
&
&
!
display
.
IsContainPaint
(
)
)
{
return
false
;
}
}
if
(
GetPrevContinuation
(
)
|
|
GetNextContinuation
(
)
)
{
return
false
;
}
return
true
;
}
void
nsIFrame
:
:
DisplayOutlineUnconditional
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
MOZ_ASSERT
(
!
IsTableColGroupFrame
(
)
&
&
!
IsTableColFrame
(
)
)
;
const
auto
&
outline
=
*
StyleOutline
(
)
;
if
(
!
outline
.
ShouldPaintOutline
(
)
)
{
return
;
}
if
(
IsTableFrame
(
)
)
{
return
;
}
if
(
HasAnyStateBits
(
NS_FRAME_PART_OF_IBSPLIT
)
&
&
ScrollableOverflowRect
(
)
.
IsEmpty
(
)
)
{
return
;
}
if
(
outline
.
mOutlineStyle
.
IsAuto
(
)
)
{
auto
*
disp
=
StyleDisplay
(
)
;
if
(
IsThemed
(
disp
)
&
&
PresContext
(
)
-
>
Theme
(
)
-
>
ThemeDrawsFocusForWidget
(
this
disp
-
>
EffectiveAppearance
(
)
)
)
{
return
;
}
}
aLists
.
Outlines
(
)
-
>
AppendNewToTop
<
nsDisplayOutline
>
(
aBuilder
this
)
;
}
void
nsIFrame
:
:
DisplayOutline
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
if
(
!
IsVisibleForPainting
(
)
)
return
;
DisplayOutlineUnconditional
(
aBuilder
aLists
)
;
}
void
nsIFrame
:
:
DisplayInsetBoxShadowUnconditional
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
)
{
const
auto
*
effects
=
StyleEffects
(
)
;
if
(
effects
-
>
HasBoxShadowWithInset
(
true
)
)
{
aList
-
>
AppendNewToTop
<
nsDisplayBoxShadowInner
>
(
aBuilder
this
)
;
}
}
void
nsIFrame
:
:
DisplayInsetBoxShadow
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
)
{
if
(
!
IsVisibleForPainting
(
)
)
return
;
DisplayInsetBoxShadowUnconditional
(
aBuilder
aList
)
;
}
void
nsIFrame
:
:
DisplayOutsetBoxShadowUnconditional
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
)
{
const
auto
*
effects
=
StyleEffects
(
)
;
if
(
effects
-
>
HasBoxShadowWithInset
(
false
)
)
{
aList
-
>
AppendNewToTop
<
nsDisplayBoxShadowOuter
>
(
aBuilder
this
)
;
}
}
void
nsIFrame
:
:
DisplayOutsetBoxShadow
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
)
{
if
(
!
IsVisibleForPainting
(
)
)
return
;
DisplayOutsetBoxShadowUnconditional
(
aBuilder
aList
)
;
}
void
nsIFrame
:
:
DisplayCaret
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
)
{
if
(
!
IsVisibleForPainting
(
)
)
return
;
aList
-
>
AppendNewToTop
<
nsDisplayCaret
>
(
aBuilder
this
)
;
}
nscolor
nsIFrame
:
:
GetCaretColorAt
(
int32_t
aOffset
)
{
return
nsLayoutUtils
:
:
GetColor
(
this
&
nsStyleUI
:
:
mCaretColor
)
;
}
auto
nsIFrame
:
:
ComputeShouldPaintBackground
(
)
const
-
>
ShouldPaintBackground
{
nsPresContext
*
pc
=
PresContext
(
)
;
ShouldPaintBackground
settings
{
pc
-
>
GetBackgroundColorDraw
(
)
pc
-
>
GetBackgroundImageDraw
(
)
}
;
if
(
settings
.
mColor
&
&
settings
.
mImage
)
{
return
settings
;
}
if
(
!
HonorPrintBackgroundSettings
(
)
|
|
StyleVisibility
(
)
-
>
mPrintColorAdjust
=
=
StylePrintColorAdjust
:
:
Exact
)
{
return
{
true
true
}
;
}
return
settings
;
}
bool
nsIFrame
:
:
DisplayBackgroundUnconditional
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
bool
aForceBackground
)
{
const
bool
hitTesting
=
aBuilder
-
>
IsForEventDelivery
(
)
;
if
(
hitTesting
&
&
!
aBuilder
-
>
HitTestIsForVisibility
(
)
)
{
aLists
.
BorderBackground
(
)
-
>
AppendNewToTop
<
nsDisplayEventReceiver
>
(
aBuilder
this
)
;
return
false
;
}
AppendedBackgroundType
result
=
AppendedBackgroundType
:
:
None
;
if
(
hitTesting
|
|
aForceBackground
|
|
!
StyleBackground
(
)
-
>
IsTransparent
(
this
)
|
|
StyleDisplay
(
)
-
>
HasAppearance
(
)
|
|
EffectCompositor
:
:
HasAnimationsForCompositor
(
this
DisplayItemType
:
:
TYPE_BACKGROUND_COLOR
)
)
{
result
=
nsDisplayBackgroundImage
:
:
AppendBackgroundItemsToTop
(
aBuilder
this
GetRectRelativeToSelf
(
)
+
aBuilder
-
>
ToReferenceFrame
(
this
)
aLists
.
BorderBackground
(
)
)
;
}
if
(
result
=
=
AppendedBackgroundType
:
:
None
)
{
aBuilder
-
>
BuildCompositorHitTestInfoIfNeeded
(
this
aLists
.
BorderBackground
(
)
)
;
}
return
result
=
=
AppendedBackgroundType
:
:
ThemedBackground
;
}
void
nsIFrame
:
:
DisplayBorderBackgroundOutline
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
bool
aForceBackground
)
{
if
(
!
IsVisibleForPainting
(
)
)
{
return
;
}
DisplayOutsetBoxShadowUnconditional
(
aBuilder
aLists
.
BorderBackground
(
)
)
;
bool
bgIsThemed
=
DisplayBackgroundUnconditional
(
aBuilder
aLists
aForceBackground
)
;
DisplayInsetBoxShadowUnconditional
(
aBuilder
aLists
.
BorderBackground
(
)
)
;
if
(
!
bgIsThemed
&
&
StyleBorder
(
)
-
>
HasBorder
(
)
&
&
!
IsTableFrame
(
)
)
{
aLists
.
BorderBackground
(
)
-
>
AppendNewToTop
<
nsDisplayBorder
>
(
aBuilder
this
)
;
}
DisplayOutlineUnconditional
(
aBuilder
aLists
)
;
}
inline
static
bool
IsSVGContentWithCSSClip
(
const
nsIFrame
*
aFrame
)
{
return
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_SVG_LAYOUT
)
&
&
aFrame
-
>
GetContent
(
)
-
>
IsAnyOfSVGElements
(
nsGkAtoms
:
:
svg
nsGkAtoms
:
:
foreignObject
)
;
}
Maybe
<
nsRect
>
nsIFrame
:
:
GetClipPropClipRect
(
const
nsStyleDisplay
*
aDisp
const
nsStyleEffects
*
aEffects
const
nsSize
&
aSize
)
const
{
if
(
aEffects
-
>
mClip
.
IsAuto
(
)
|
|
!
(
aDisp
-
>
IsAbsolutelyPositioned
(
this
)
|
|
IsSVGContentWithCSSClip
(
this
)
)
)
{
return
Nothing
(
)
;
}
auto
&
clipRect
=
aEffects
-
>
mClip
.
AsRect
(
)
;
nsRect
rect
=
clipRect
.
ToLayoutRect
(
)
;
if
(
MOZ_LIKELY
(
StyleBorder
(
)
-
>
mBoxDecorationBreak
=
=
StyleBoxDecorationBreak
:
:
Slice
)
)
{
nscoord
y
=
0
;
for
(
nsIFrame
*
f
=
GetPrevContinuation
(
)
;
f
;
f
=
f
-
>
GetPrevContinuation
(
)
)
{
y
+
=
f
-
>
GetRect
(
)
.
height
;
}
rect
.
MoveBy
(
nsPoint
(
0
-
y
)
)
;
}
if
(
clipRect
.
right
.
IsAuto
(
)
)
{
rect
.
width
=
aSize
.
width
-
rect
.
x
;
}
if
(
clipRect
.
bottom
.
IsAuto
(
)
)
{
rect
.
height
=
aSize
.
height
-
rect
.
y
;
}
return
Some
(
rect
)
;
}
static
void
ApplyOverflowClipping
(
nsDisplayListBuilder
*
aBuilder
const
nsIFrame
*
aFrame
nsIFrame
:
:
PhysicalAxes
aClipAxes
DisplayListClipState
:
:
AutoClipMultiple
&
aClipState
)
{
MOZ_ASSERT
(
aClipAxes
!
=
nsIFrame
:
:
PhysicalAxes
:
:
None
)
;
MOZ_ASSERT
(
aFrame
-
>
ShouldApplyOverflowClipping
(
aFrame
-
>
StyleDisplay
(
)
)
=
=
aClipAxes
)
;
nsRect
clipRect
;
bool
haveRadii
=
false
;
nscoord
radii
[
8
]
;
auto
*
disp
=
aFrame
-
>
StyleDisplay
(
)
;
auto
wm
=
aFrame
-
>
GetWritingMode
(
)
;
bool
cbH
=
(
wm
.
IsVertical
(
)
?
disp
-
>
mOverflowClipBoxBlock
:
disp
-
>
mOverflowClipBoxInline
)
=
=
StyleOverflowClipBox
:
:
ContentBox
;
bool
cbV
=
(
wm
.
IsVertical
(
)
?
disp
-
>
mOverflowClipBoxInline
:
disp
-
>
mOverflowClipBoxBlock
)
=
=
StyleOverflowClipBox
:
:
ContentBox
;
nsMargin
boxMargin
=
-
aFrame
-
>
GetUsedPadding
(
)
;
if
(
!
cbH
)
{
boxMargin
.
left
=
boxMargin
.
right
=
nscoord
(
0
)
;
}
if
(
!
cbV
)
{
boxMargin
.
top
=
boxMargin
.
bottom
=
nscoord
(
0
)
;
}
auto
clipMargin
=
aFrame
-
>
OverflowClipMargin
(
aClipAxes
)
;
boxMargin
-
=
aFrame
-
>
GetUsedBorder
(
)
;
boxMargin
+
=
nsMargin
(
clipMargin
.
height
clipMargin
.
width
clipMargin
.
height
clipMargin
.
width
)
;
boxMargin
.
ApplySkipSides
(
aFrame
-
>
GetSkipSides
(
)
)
;
nsRect
rect
(
nsPoint
(
0
0
)
aFrame
-
>
GetSize
(
)
)
;
rect
.
Inflate
(
boxMargin
)
;
if
(
MOZ_UNLIKELY
(
!
(
aClipAxes
&
nsIFrame
:
:
PhysicalAxes
:
:
Horizontal
)
)
)
{
nsRect
o
=
aFrame
-
>
InkOverflowRect
(
)
;
rect
.
x
=
o
.
x
;
rect
.
width
=
o
.
width
;
}
if
(
MOZ_UNLIKELY
(
!
(
aClipAxes
&
nsIFrame
:
:
PhysicalAxes
:
:
Vertical
)
)
)
{
nsRect
o
=
aFrame
-
>
InkOverflowRect
(
)
;
rect
.
y
=
o
.
y
;
rect
.
height
=
o
.
height
;
}
clipRect
=
rect
+
aBuilder
-
>
ToReferenceFrame
(
aFrame
)
;
haveRadii
=
aFrame
-
>
GetBoxBorderRadii
(
radii
boxMargin
)
;
aClipState
.
ClipContainingBlockDescendantsExtra
(
clipRect
haveRadii
?
radii
:
nullptr
)
;
}
nsSize
nsIFrame
:
:
OverflowClipMargin
(
PhysicalAxes
aClipAxes
)
const
{
nsSize
result
;
if
(
aClipAxes
=
=
PhysicalAxes
:
:
None
)
{
return
result
;
}
const
auto
&
margin
=
StyleMargin
(
)
-
>
mOverflowClipMargin
;
if
(
margin
.
IsZero
(
)
)
{
return
result
;
}
nscoord
marginAu
=
margin
.
ToAppUnits
(
)
;
if
(
aClipAxes
&
PhysicalAxes
:
:
Horizontal
)
{
result
.
width
=
marginAu
;
}
if
(
aClipAxes
&
PhysicalAxes
:
:
Vertical
)
{
result
.
height
=
marginAu
;
}
return
result
;
}
static
bool
BuilderHasScrolledClip
(
nsDisplayListBuilder
*
aBuilder
)
{
const
DisplayItemClipChain
*
currentClip
=
aBuilder
-
>
ClipState
(
)
.
GetCurrentCombinedClipChain
(
aBuilder
)
;
if
(
!
currentClip
)
{
return
false
;
}
const
ActiveScrolledRoot
*
currentClipASR
=
currentClip
-
>
mASR
;
const
ActiveScrolledRoot
*
currentASR
=
aBuilder
-
>
CurrentActiveScrolledRoot
(
)
;
return
ActiveScrolledRoot
:
:
PickDescendant
(
currentClipASR
currentASR
)
!
=
currentASR
;
}
class
AutoSaveRestoreContainsBlendMode
{
nsDisplayListBuilder
&
mBuilder
;
bool
mSavedContainsBlendMode
;
public
:
explicit
AutoSaveRestoreContainsBlendMode
(
nsDisplayListBuilder
&
aBuilder
)
:
mBuilder
(
aBuilder
)
mSavedContainsBlendMode
(
aBuilder
.
ContainsBlendMode
(
)
)
{
}
~
AutoSaveRestoreContainsBlendMode
(
)
{
mBuilder
.
SetContainsBlendMode
(
mSavedContainsBlendMode
)
;
}
}
;
static
void
CheckForApzAwareEventHandlers
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
{
if
(
aBuilder
-
>
GetAncestorHasApzAwareEventHandler
(
)
)
{
return
;
}
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
!
content
)
{
return
;
}
if
(
content
-
>
IsNodeApzAware
(
)
)
{
aBuilder
-
>
SetAncestorHasApzAwareEventHandler
(
true
)
;
}
}
static
void
UpdateCurrentHitTestInfo
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
{
if
(
!
aBuilder
-
>
BuildCompositorHitTestInfo
(
)
)
{
return
;
}
CheckForApzAwareEventHandlers
(
aBuilder
aFrame
)
;
const
CompositorHitTestInfo
info
=
aFrame
-
>
GetCompositorHitTestInfo
(
aBuilder
)
;
aBuilder
-
>
SetCompositorHitTestInfo
(
info
)
;
}
static
bool
FrameParticipatesIn3DContext
(
nsIFrame
*
aAncestor
nsIFrame
*
aDescendant
)
{
MOZ_ASSERT
(
aAncestor
!
=
aDescendant
)
;
MOZ_ASSERT
(
aAncestor
-
>
GetContent
(
)
!
=
aDescendant
-
>
GetContent
(
)
)
;
MOZ_ASSERT
(
aAncestor
-
>
Extend3DContext
(
)
)
;
nsIFrame
*
ancestor
=
aAncestor
-
>
FirstContinuation
(
)
;
MOZ_ASSERT
(
ancestor
-
>
IsPrimaryFrame
(
)
)
;
nsIFrame
*
frame
;
for
(
frame
=
aDescendant
-
>
GetClosestFlattenedTreeAncestorPrimaryFrame
(
)
;
frame
&
&
ancestor
!
=
frame
;
frame
=
frame
-
>
GetClosestFlattenedTreeAncestorPrimaryFrame
(
)
)
{
if
(
!
frame
-
>
Extend3DContext
(
)
)
{
return
false
;
}
}
MOZ_ASSERT
(
frame
=
=
ancestor
)
;
return
true
;
}
static
bool
ItemParticipatesIn3DContext
(
nsIFrame
*
aAncestor
nsDisplayItem
*
aItem
)
{
auto
type
=
aItem
-
>
GetType
(
)
;
const
bool
isContainer
=
type
=
=
DisplayItemType
:
:
TYPE_WRAP_LIST
|
|
type
=
=
DisplayItemType
:
:
TYPE_CONTAINER
;
if
(
isContainer
&
&
aItem
-
>
GetChildren
(
)
-
>
Length
(
)
=
=
1
)
{
type
=
aItem
-
>
GetChildren
(
)
-
>
GetBottom
(
)
-
>
GetType
(
)
;
}
if
(
type
!
=
DisplayItemType
:
:
TYPE_TRANSFORM
&
&
type
!
=
DisplayItemType
:
:
TYPE_PERSPECTIVE
)
{
return
false
;
}
nsIFrame
*
transformFrame
=
aItem
-
>
Frame
(
)
;
if
(
aAncestor
-
>
GetContent
(
)
=
=
transformFrame
-
>
GetContent
(
)
)
{
return
true
;
}
return
FrameParticipatesIn3DContext
(
aAncestor
transformFrame
)
;
}
static
void
WrapSeparatorTransform
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aNonParticipants
nsDisplayList
*
aParticipants
int
aIndex
nsDisplayItem
*
*
aSeparator
)
{
if
(
aNonParticipants
-
>
IsEmpty
(
)
)
{
return
;
}
nsDisplayTransform
*
item
=
MakeDisplayItemWithIndex
<
nsDisplayTransform
>
(
aBuilder
aFrame
aIndex
aNonParticipants
aBuilder
-
>
GetVisibleRect
(
)
)
;
if
(
*
aSeparator
=
=
nullptr
&
&
item
)
{
*
aSeparator
=
item
;
}
aParticipants
-
>
AppendToTop
(
item
)
;
}
static
Maybe
<
nsRect
>
ComputeClipForMaskItem
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aMaskedFrame
)
{
const
nsStyleSVGReset
*
svgReset
=
aMaskedFrame
-
>
StyleSVGReset
(
)
;
SVGUtils
:
:
MaskUsage
maskUsage
;
SVGUtils
:
:
DetermineMaskUsage
(
aMaskedFrame
false
maskUsage
)
;
nsPoint
offsetToUserSpace
=
nsLayoutUtils
:
:
ComputeOffsetToUserSpace
(
aBuilder
aMaskedFrame
)
;
int32_t
devPixelRatio
=
aMaskedFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
gfxPoint
devPixelOffsetToUserSpace
=
nsLayoutUtils
:
:
PointToGfxPoint
(
offsetToUserSpace
devPixelRatio
)
;
CSSToLayoutDeviceScale
cssToDevScale
=
aMaskedFrame
-
>
PresContext
(
)
-
>
CSSToDevPixelScale
(
)
;
nsPoint
toReferenceFrame
;
aBuilder
-
>
FindReferenceFrameFor
(
aMaskedFrame
&
toReferenceFrame
)
;
Maybe
<
gfxRect
>
combinedClip
;
if
(
maskUsage
.
shouldApplyBasicShapeOrPath
)
{
Maybe
<
Rect
>
result
=
CSSClipPathInstance
:
:
GetBoundingRectForBasicShapeOrPathClip
(
aMaskedFrame
svgReset
-
>
mClipPath
)
;
if
(
result
)
{
combinedClip
=
Some
(
ThebesRect
(
*
result
)
)
;
}
}
else
if
(
maskUsage
.
shouldApplyClipPath
)
{
gfxRect
result
=
SVGUtils
:
:
GetBBox
(
aMaskedFrame
SVGUtils
:
:
eBBoxIncludeClipped
|
SVGUtils
:
:
eBBoxIncludeFill
|
SVGUtils
:
:
eBBoxIncludeMarkers
|
SVGUtils
:
:
eBBoxIncludeStroke
|
SVGUtils
:
:
eDoNotClipToBBoxOfContentInsideClipPath
)
;
combinedClip
=
Some
(
ThebesRect
(
(
CSSRect
:
:
FromUnknownRect
(
ToRect
(
result
)
)
*
cssToDevScale
)
.
ToUnknownRect
(
)
)
)
;
}
else
{
nsRect
borderArea
(
toReferenceFrame
aMaskedFrame
-
>
GetSize
(
)
)
;
borderArea
-
=
offsetToUserSpace
;
nsRect
dirtyRect
(
nscoord_MIN
/
2
nscoord_MIN
/
2
nscoord_MAX
nscoord_MAX
)
;
nsIFrame
*
firstFrame
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
aMaskedFrame
)
;
nsTArray
<
SVGMaskFrame
*
>
maskFrames
;
SVGObserverUtils
:
:
GetAndObserveMasks
(
firstFrame
&
maskFrames
)
;
for
(
uint32_t
i
=
0
;
i
<
maskFrames
.
Length
(
)
;
+
+
i
)
{
gfxRect
clipArea
;
if
(
maskFrames
[
i
]
)
{
clipArea
=
maskFrames
[
i
]
-
>
GetMaskArea
(
aMaskedFrame
)
;
clipArea
=
ThebesRect
(
(
CSSRect
:
:
FromUnknownRect
(
ToRect
(
clipArea
)
)
*
cssToDevScale
)
.
ToUnknownRect
(
)
)
;
}
else
{
const
auto
&
layer
=
svgReset
-
>
mMask
.
mLayers
[
i
]
;
if
(
layer
.
mClip
=
=
StyleGeometryBox
:
:
NoClip
)
{
return
Nothing
(
)
;
}
nsCSSRendering
:
:
ImageLayerClipState
clipState
;
nsCSSRendering
:
:
GetImageLayerClip
(
layer
aMaskedFrame
*
aMaskedFrame
-
>
StyleBorder
(
)
borderArea
dirtyRect
false
devPixelRatio
&
clipState
)
;
clipArea
=
clipState
.
mDirtyRectInDevPx
;
}
combinedClip
=
UnionMaybeRects
(
combinedClip
Some
(
clipArea
)
)
;
}
}
if
(
combinedClip
)
{
if
(
combinedClip
-
>
IsEmpty
(
)
)
{
return
Nothing
(
)
;
}
*
combinedClip
+
=
devPixelOffsetToUserSpace
;
combinedClip
-
>
RoundOut
(
)
;
nsRect
result
=
nsLayoutUtils
:
:
RoundGfxRectToAppRect
(
*
combinedClip
devPixelRatio
)
;
result
-
=
toReferenceFrame
;
return
Some
(
result
)
;
}
return
Nothing
(
)
;
}
struct
AutoCheckBuilder
{
explicit
AutoCheckBuilder
(
nsDisplayListBuilder
*
aBuilder
)
:
mBuilder
(
aBuilder
)
{
aBuilder
-
>
Check
(
)
;
}
~
AutoCheckBuilder
(
)
{
mBuilder
-
>
Check
(
)
;
}
nsDisplayListBuilder
*
mBuilder
;
}
;
bool
TryToReuseStackingContextItem
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
nsIFrame
*
aFrame
)
{
if
(
!
aBuilder
-
>
IsForPainting
(
)
|
|
!
aBuilder
-
>
IsPartialUpdate
(
)
|
|
aBuilder
-
>
InInvalidSubtree
(
)
)
{
return
false
;
}
if
(
aFrame
-
>
IsFrameModified
(
)
|
|
aFrame
-
>
HasModifiedDescendants
(
)
)
{
return
false
;
}
auto
&
items
=
aFrame
-
>
DisplayItems
(
)
;
auto
*
res
=
std
:
:
find_if
(
items
.
begin
(
)
items
.
end
(
)
[
]
(
nsDisplayItem
*
aItem
)
{
return
aItem
-
>
IsPreProcessed
(
)
;
}
)
;
if
(
res
=
=
items
.
end
(
)
)
{
return
false
;
}
nsDisplayItem
*
container
=
*
res
;
MOZ_ASSERT
(
container
-
>
Frame
(
)
=
=
aFrame
)
;
DL_LOGD
(
"
RDL
-
Found
SC
item
%
p
(
%
s
)
(
frame
:
%
p
)
"
container
container
-
>
Name
(
)
container
-
>
Frame
(
)
)
;
aList
-
>
AppendToTop
(
container
)
;
aBuilder
-
>
ReuseDisplayItem
(
container
)
;
return
true
;
}
void
nsIFrame
:
:
BuildDisplayListForStackingContext
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
bool
*
aCreatedContainerItem
)
{
#
ifdef
DEBUG
DL_LOGV
(
"
BuildDisplayListForStackingContext
(
%
p
)
<
"
this
)
;
ScopeExit
e
(
[
this
]
(
)
{
DL_LOGV
(
"
>
BuildDisplayListForStackingContext
(
%
p
)
"
this
)
;
}
)
;
#
endif
AutoCheckBuilder
check
(
aBuilder
)
;
if
(
aBuilder
-
>
IsReusingStackingContextItems
(
)
&
&
TryToReuseStackingContextItem
(
aBuilder
aList
this
)
)
{
if
(
aCreatedContainerItem
)
{
*
aCreatedContainerItem
=
true
;
}
return
;
}
if
(
HasAnyStateBits
(
NS_FRAME_TOO_DEEP_IN_FRAME_TREE
)
)
{
return
;
}
const
auto
&
style
=
*
Style
(
)
;
const
nsStyleDisplay
*
disp
=
style
.
StyleDisplay
(
)
;
const
nsStyleEffects
*
effects
=
style
.
StyleEffects
(
)
;
EffectSet
*
effectSetForOpacity
=
EffectSet
:
:
GetEffectSetForFrame
(
this
nsCSSPropertyIDSet
:
:
OpacityProperties
(
)
)
;
bool
needHitTestInfo
=
aBuilder
-
>
BuildCompositorHitTestInfo
(
)
&
&
Style
(
)
-
>
PointerEvents
(
)
!
=
StylePointerEvents
:
:
None
;
bool
opacityItemForEventsOnly
=
false
;
if
(
effects
-
>
mOpacity
=
=
0
.
0
&
&
aBuilder
-
>
IsForPainting
(
)
&
&
!
(
disp
-
>
mWillChange
.
bits
&
StyleWillChangeBits
:
:
OPACITY
)
&
&
!
nsLayoutUtils
:
:
HasAnimationOfPropertySet
(
this
nsCSSPropertyIDSet
:
:
OpacityProperties
(
)
effectSetForOpacity
)
)
{
if
(
needHitTestInfo
)
{
opacityItemForEventsOnly
=
true
;
}
else
{
return
;
}
}
if
(
aBuilder
-
>
IsForPainting
(
)
&
&
disp
-
>
mWillChange
.
bits
)
{
aBuilder
-
>
AddToWillChangeBudget
(
this
GetSize
(
)
)
;
}
nsRect
visibleRect
=
aBuilder
-
>
GetVisibleRect
(
)
;
nsRect
dirtyRect
=
aBuilder
-
>
GetDirtyRect
(
)
;
const
bool
useOpacity
=
HasVisualOpacity
(
disp
effects
effectSetForOpacity
)
&
&
!
SVGUtils
:
:
CanOptimizeOpacity
(
this
)
;
const
bool
isTransformed
=
IsTransformed
(
)
;
const
bool
hasPerspective
=
isTransformed
&
&
HasPerspective
(
)
;
const
bool
extend3DContext
=
Extend3DContext
(
disp
effects
effectSetForOpacity
)
;
const
bool
combines3DTransformWithAncestors
=
(
extend3DContext
|
|
isTransformed
)
&
&
Combines3DTransformWithAncestors
(
)
;
Maybe
<
nsDisplayListBuilder
:
:
AutoPreserves3DContext
>
autoPreserves3DContext
;
if
(
extend3DContext
&
&
!
combines3DTransformWithAncestors
)
{
autoPreserves3DContext
.
emplace
(
aBuilder
)
;
aBuilder
-
>
SavePreserves3DRect
(
)
;
if
(
aBuilder
-
>
IsRetainingDisplayList
(
)
)
{
dirtyRect
=
visibleRect
;
aBuilder
-
>
SetDisablePartialUpdates
(
true
)
;
}
}
const
bool
useBlendMode
=
effects
-
>
mMixBlendMode
!
=
StyleBlend
:
:
Normal
;
if
(
useBlendMode
)
{
aBuilder
-
>
SetContainsBlendMode
(
true
)
;
}
AutoSaveRestoreContainsBlendMode
autoRestoreBlendMode
(
*
aBuilder
)
;
aBuilder
-
>
SetContainsBlendMode
(
false
)
;
bool
usingBackdropFilter
=
effects
-
>
HasBackdropFilters
(
)
&
&
IsVisibleForPainting
(
)
&
&
!
style
.
IsRootElementStyle
(
)
;
nsRect
visibleRectOutsideTransform
=
visibleRect
;
nsDisplayTransform
:
:
PrerenderInfo
prerenderInfo
;
bool
inTransform
=
aBuilder
-
>
IsInTransform
(
)
;
if
(
isTransformed
)
{
prerenderInfo
=
nsDisplayTransform
:
:
ShouldPrerenderTransformedContent
(
aBuilder
this
&
visibleRect
)
;
switch
(
prerenderInfo
.
mDecision
)
{
case
nsDisplayTransform
:
:
PrerenderDecision
:
:
Full
:
case
nsDisplayTransform
:
:
PrerenderDecision
:
:
Partial
:
dirtyRect
=
visibleRect
;
break
;
case
nsDisplayTransform
:
:
PrerenderDecision
:
:
No
:
{
if
(
(
extend3DContext
|
|
combines3DTransformWithAncestors
)
&
&
prerenderInfo
.
mHasAnimations
)
{
aBuilder
-
>
SavePreserves3DAllowAsyncAnimation
(
false
)
;
}
const
nsRect
overflow
=
InkOverflowRectRelativeToSelf
(
)
;
if
(
overflow
.
IsEmpty
(
)
&
&
!
extend3DContext
)
{
return
;
}
if
(
combines3DTransformWithAncestors
)
{
visibleRect
=
dirtyRect
=
aBuilder
-
>
GetPreserves3DRect
(
)
;
}
float
appPerDev
=
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
auto
transform
=
nsDisplayTransform
:
:
GetResultingTransformMatrix
(
this
nsPoint
(
)
appPerDev
nsDisplayTransform
:
:
kTransformRectFlags
)
;
nsRect
untransformedDirtyRect
;
if
(
nsDisplayTransform
:
:
UntransformRect
(
dirtyRect
overflow
transform
appPerDev
&
untransformedDirtyRect
)
)
{
dirtyRect
=
untransformedDirtyRect
;
nsDisplayTransform
:
:
UntransformRect
(
visibleRect
overflow
transform
appPerDev
&
visibleRect
)
;
}
else
{
dirtyRect
.
SetEmpty
(
)
;
visibleRect
.
SetEmpty
(
)
;
}
}
}
inTransform
=
true
;
}
else
if
(
IsFixedPosContainingBlock
(
)
)
{
visibleRect
.
IntersectRect
(
visibleRect
InkOverflowRect
(
)
)
;
dirtyRect
.
IntersectRect
(
dirtyRect
InkOverflowRect
(
)
)
;
}
bool
hasOverrideDirtyRect
=
false
;
if
(
!
aBuilder
-
>
IsReusingStackingContextItems
(
)
&
&
aBuilder
-
>
IsPartialUpdate
(
)
&
&
!
aBuilder
-
>
InInvalidSubtree
(
)
&
&
!
IsFrameModified
(
)
&
&
IsFixedPosContainingBlock
(
)
&
&
!
GetPrevContinuation
(
)
&
&
!
GetNextContinuation
(
)
)
{
dirtyRect
=
nsRect
(
)
;
if
(
HasOverrideDirtyRegion
(
)
)
{
nsDisplayListBuilder
:
:
DisplayListBuildingData
*
data
=
GetProperty
(
nsDisplayListBuilder
:
:
DisplayListBuildingRect
(
)
)
;
if
(
data
)
{
dirtyRect
=
data
-
>
mDirtyRect
.
Intersect
(
visibleRect
)
;
hasOverrideDirtyRect
=
true
;
}
}
}
bool
usingFilter
=
effects
-
>
HasFilters
(
)
&
&
!
style
.
IsRootElementStyle
(
)
;
bool
usingMask
=
SVGIntegrationUtils
:
:
UsingMaskOrClipPathForFrame
(
this
)
;
bool
usingSVGEffects
=
usingFilter
|
|
usingMask
;
nsRect
visibleRectOutsideSVGEffects
=
visibleRect
;
nsDisplayList
hoistedScrollInfoItemsStorage
(
aBuilder
)
;
if
(
usingSVGEffects
)
{
dirtyRect
=
SVGIntegrationUtils
:
:
GetRequiredSourceForInvalidArea
(
this
dirtyRect
)
;
visibleRect
=
SVGIntegrationUtils
:
:
GetRequiredSourceForInvalidArea
(
this
visibleRect
)
;
aBuilder
-
>
EnterSVGEffectsContents
(
this
&
hoistedScrollInfoItemsStorage
)
;
}
bool
useStickyPosition
=
disp
-
>
mPosition
=
=
StylePositionProperty
:
:
Sticky
;
bool
useFixedPosition
=
disp
-
>
mPosition
=
=
StylePositionProperty
:
:
Fixed
&
&
(
DisplayPortUtils
:
:
IsFixedPosFrameInDisplayPort
(
this
)
|
|
BuilderHasScrolledClip
(
aBuilder
)
)
;
nsDisplayListBuilder
:
:
AutoBuildingDisplayList
buildingDisplayList
(
aBuilder
this
visibleRect
dirtyRect
isTransformed
)
;
UpdateCurrentHitTestInfo
(
aBuilder
this
)
;
enum
class
ContainerItemType
:
uint8_t
{
None
=
0
OwnLayerIfNeeded
BlendMode
FixedPosition
OwnLayerForTransformWithRoundedClip
Perspective
Transform
SeparatorTransforms
Opacity
Filter
BlendContainer
}
;
nsDisplayListBuilder
:
:
AutoContainerASRTracker
contASRTracker
(
aBuilder
)
;
auto
cssClip
=
GetClipPropClipRect
(
disp
effects
GetSize
(
)
)
;
auto
ApplyClipProp
=
[
&
]
(
DisplayListClipState
:
:
AutoSaveRestore
&
aClipState
)
{
if
(
!
cssClip
)
{
return
;
}
nsPoint
offset
=
aBuilder
-
>
GetCurrentFrameOffsetToReferenceFrame
(
)
;
aBuilder
-
>
IntersectDirtyRect
(
*
cssClip
)
;
aBuilder
-
>
IntersectVisibleRect
(
*
cssClip
)
;
aClipState
.
ClipContentDescendants
(
*
cssClip
+
offset
)
;
}
;
DisplayListClipState
:
:
AutoSaveRestore
untransformedCssClip
(
aBuilder
)
;
if
(
!
isTransformed
)
{
ApplyClipProp
(
untransformedCssClip
)
;
}
ContainerItemType
clipCapturedBy
=
ContainerItemType
:
:
None
;
if
(
useFixedPosition
)
{
clipCapturedBy
=
ContainerItemType
:
:
FixedPosition
;
}
else
if
(
isTransformed
)
{
const
DisplayItemClipChain
*
currentClip
=
aBuilder
-
>
ClipState
(
)
.
GetCurrentCombinedClipChain
(
aBuilder
)
;
if
(
(
hasPerspective
|
|
extend3DContext
)
&
&
(
currentClip
&
&
currentClip
-
>
HasRoundedCorners
(
)
)
)
{
clipCapturedBy
=
ContainerItemType
:
:
OwnLayerForTransformWithRoundedClip
;
}
else
if
(
hasPerspective
)
{
clipCapturedBy
=
ContainerItemType
:
:
Perspective
;
}
else
{
clipCapturedBy
=
ContainerItemType
:
:
Transform
;
}
}
else
if
(
usingFilter
)
{
clipCapturedBy
=
ContainerItemType
:
:
Filter
;
}
DisplayListClipState
:
:
AutoSaveRestore
clipState
(
aBuilder
)
;
if
(
clipCapturedBy
!
=
ContainerItemType
:
:
None
)
{
clipState
.
Clear
(
)
;
}
DisplayListClipState
:
:
AutoSaveRestore
transformedCssClip
(
aBuilder
)
;
if
(
isTransformed
)
{
ApplyClipProp
(
transformedCssClip
)
;
}
nsDisplayListCollection
set
(
aBuilder
)
;
Maybe
<
nsRect
>
clipForMask
;
{
DisplayListClipState
:
:
AutoSaveRestore
nestedClipState
(
aBuilder
)
;
nsDisplayListBuilder
:
:
AutoInTransformSetter
inTransformSetter
(
aBuilder
inTransform
)
;
nsDisplayListBuilder
:
:
AutoEnterFilter
filterASRSetter
(
aBuilder
usingFilter
)
;
nsDisplayListBuilder
:
:
AutoInEventsOnly
inEventsSetter
(
aBuilder
opacityItemForEventsOnly
)
;
if
(
usingMask
&
&
!
usingFilter
)
{
clipForMask
=
ComputeClipForMaskItem
(
aBuilder
this
)
;
if
(
clipForMask
)
{
aBuilder
-
>
IntersectDirtyRect
(
*
clipForMask
)
;
aBuilder
-
>
IntersectVisibleRect
(
*
clipForMask
)
;
nestedClipState
.
ClipContentDescendants
(
*
clipForMask
+
aBuilder
-
>
GetCurrentFrameOffsetToReferenceFrame
(
)
)
;
}
}
if
(
extend3DContext
)
{
aBuilder
-
>
MarkPreserve3DFramesForDisplayList
(
this
)
;
}
aBuilder
-
>
AdjustWindowDraggingRegion
(
this
)
;
MarkAbsoluteFramesForDisplayList
(
aBuilder
)
;
aBuilder
-
>
Check
(
)
;
BuildDisplayList
(
aBuilder
set
)
;
SetBuiltDisplayList
(
true
)
;
aBuilder
-
>
Check
(
)
;
aBuilder
-
>
DisplayCaret
(
this
set
.
Outlines
(
)
)
;
if
(
(
aBuilder
-
>
ContainsBlendMode
(
)
)
&
&
aBuilder
-
>
IsRetainingDisplayList
(
)
)
{
if
(
aBuilder
-
>
IsPartialUpdate
(
)
)
{
aBuilder
-
>
SetPartialBuildFailed
(
true
)
;
}
else
{
aBuilder
-
>
SetDisablePartialUpdates
(
true
)
;
}
}
}
if
(
aBuilder
-
>
IsBackgroundOnly
(
)
)
{
set
.
BlockBorderBackgrounds
(
)
-
>
DeleteAll
(
aBuilder
)
;
set
.
Floats
(
)
-
>
DeleteAll
(
aBuilder
)
;
set
.
Content
(
)
-
>
DeleteAll
(
aBuilder
)
;
set
.
PositionedDescendants
(
)
-
>
DeleteAll
(
aBuilder
)
;
set
.
Outlines
(
)
-
>
DeleteAll
(
aBuilder
)
;
}
if
(
hasOverrideDirtyRect
&
&
StaticPrefs
:
:
layout_display_list_show_rebuild_area
(
)
)
{
nsDisplaySolidColor
*
color
=
MakeDisplayItem
<
nsDisplaySolidColor
>
(
aBuilder
this
dirtyRect
+
aBuilder
-
>
GetCurrentFrameOffsetToReferenceFrame
(
)
NS_RGBA
(
255
0
0
64
)
false
)
;
if
(
color
)
{
color
-
>
SetOverrideZIndex
(
INT32_MAX
)
;
set
.
PositionedDescendants
(
)
-
>
AppendToTop
(
color
)
;
}
}
nsIContent
*
content
=
GetContent
(
)
;
if
(
!
content
)
{
content
=
PresContext
(
)
-
>
Document
(
)
-
>
GetRootElement
(
)
;
}
nsDisplayList
resultList
(
aBuilder
)
;
set
.
SerializeWithCorrectZOrder
(
&
resultList
content
)
;
const
ActiveScrolledRoot
*
containerItemASR
=
contASRTracker
.
GetContainerASR
(
)
;
bool
createdContainer
=
false
;
if
(
aBuilder
-
>
ContainsBlendMode
(
)
)
{
DisplayListClipState
:
:
AutoSaveRestore
blendContainerClipState
(
aBuilder
)
;
resultList
.
AppendToTop
(
nsDisplayBlendContainer
:
:
CreateForMixBlendMode
(
aBuilder
this
&
resultList
containerItemASR
)
)
;
createdContainer
=
true
;
}
if
(
usingBackdropFilter
)
{
DisplayListClipState
:
:
AutoSaveRestore
clipState
(
aBuilder
)
;
nsRect
backdropRect
=
GetRectRelativeToSelf
(
)
+
aBuilder
-
>
ToReferenceFrame
(
this
)
;
resultList
.
AppendNewToTop
<
nsDisplayBackdropFilters
>
(
aBuilder
this
&
resultList
backdropRect
this
)
;
createdContainer
=
true
;
}
if
(
usingSVGEffects
)
{
MOZ_ASSERT
(
usingFilter
|
|
usingMask
"
Beside
filter
&
mask
/
clip
-
path
what
else
effect
do
we
have
?
"
)
;
if
(
clipCapturedBy
=
=
ContainerItemType
:
:
Filter
)
{
clipState
.
Restore
(
)
;
}
aBuilder
-
>
SetVisibleRect
(
visibleRectOutsideSVGEffects
)
;
if
(
usingFilter
&
&
!
aBuilder
-
>
IsForGenerateGlyphMask
(
)
)
{
resultList
.
AppendNewToTop
<
nsDisplayFilters
>
(
aBuilder
this
&
resultList
this
usingBackdropFilter
)
;
createdContainer
=
true
;
}
if
(
usingMask
)
{
DisplayListClipState
:
:
AutoSaveRestore
maskClipState
(
aBuilder
)
;
const
ActiveScrolledRoot
*
maskASR
=
clipForMask
.
isSome
(
)
?
aBuilder
-
>
CurrentActiveScrolledRoot
(
)
:
containerItemASR
;
resultList
.
AppendNewToTop
<
nsDisplayMasksAndClipPaths
>
(
aBuilder
this
&
resultList
maskASR
usingBackdropFilter
)
;
createdContainer
=
true
;
}
createdContainer
=
false
;
aBuilder
-
>
ExitSVGEffectsContents
(
)
;
resultList
.
AppendToTop
(
&
hoistedScrollInfoItemsStorage
)
;
}
if
(
useOpacity
)
{
DisplayListClipState
:
:
AutoSaveRestore
opacityClipState
(
aBuilder
)
;
const
bool
needsActiveOpacityLayer
=
nsDisplayOpacity
:
:
NeedsActiveLayer
(
aBuilder
this
)
;
resultList
.
AppendNewToTop
<
nsDisplayOpacity
>
(
aBuilder
this
&
resultList
containerItemASR
opacityItemForEventsOnly
needsActiveOpacityLayer
usingBackdropFilter
)
;
createdContainer
=
true
;
}
if
(
isTransformed
&
&
extend3DContext
)
{
nsDisplayList
nonparticipants
(
aBuilder
)
;
nsDisplayList
participants
(
aBuilder
)
;
int
index
=
1
;
nsDisplayItem
*
separator
=
nullptr
;
for
(
nsDisplayItem
*
item
:
resultList
.
TakeItems
(
)
)
{
if
(
ItemParticipatesIn3DContext
(
this
item
)
&
&
!
item
-
>
GetClip
(
)
.
HasClip
(
)
)
{
WrapSeparatorTransform
(
aBuilder
this
&
nonparticipants
&
participants
index
+
+
&
separator
)
;
participants
.
AppendToTop
(
item
)
;
}
else
{
nonparticipants
.
AppendToTop
(
item
)
;
}
}
WrapSeparatorTransform
(
aBuilder
this
&
nonparticipants
&
participants
index
+
+
&
separator
)
;
if
(
separator
)
{
createdContainer
=
true
;
}
resultList
.
AppendToTop
(
&
participants
)
;
}
if
(
isTransformed
)
{
transformedCssClip
.
Restore
(
)
;
if
(
clipCapturedBy
=
=
ContainerItemType
:
:
Transform
)
{
clipState
.
Restore
(
)
;
}
aBuilder
-
>
SetVisibleRect
(
visibleRectOutsideTransform
)
;
if
(
this
!
=
aBuilder
-
>
RootReferenceFrame
(
)
)
{
nsPoint
toOuterReferenceFrame
;
const
nsIFrame
*
outerReferenceFrame
=
aBuilder
-
>
FindReferenceFrameFor
(
GetParent
(
)
&
toOuterReferenceFrame
)
;
toOuterReferenceFrame
+
=
GetPosition
(
)
;
buildingDisplayList
.
SetReferenceFrameAndCurrentOffset
(
outerReferenceFrame
toOuterReferenceFrame
)
;
}
if
(
(
extend3DContext
|
|
combines3DTransformWithAncestors
)
&
&
prerenderInfo
.
CanUseAsyncAnimations
(
)
&
&
!
aBuilder
-
>
GetPreserves3DAllowAsyncAnimation
(
)
)
{
prerenderInfo
.
mDecision
=
nsDisplayTransform
:
:
PrerenderDecision
:
:
No
;
}
nsDisplayTransform
*
transformItem
=
MakeDisplayItem
<
nsDisplayTransform
>
(
aBuilder
this
&
resultList
visibleRect
prerenderInfo
.
mDecision
)
;
if
(
transformItem
)
{
resultList
.
AppendToTop
(
transformItem
)
;
createdContainer
=
true
;
}
if
(
hasPerspective
)
{
transformItem
-
>
MarkWithAssociatedPerspective
(
)
;
if
(
clipCapturedBy
=
=
ContainerItemType
:
:
Perspective
)
{
clipState
.
Restore
(
)
;
}
resultList
.
AppendNewToTop
<
nsDisplayPerspective
>
(
aBuilder
this
&
resultList
)
;
createdContainer
=
true
;
}
}
if
(
clipCapturedBy
=
=
ContainerItemType
:
:
OwnLayerForTransformWithRoundedClip
)
{
clipState
.
Restore
(
)
;
resultList
.
AppendNewToTopWithIndex
<
nsDisplayOwnLayer
>
(
aBuilder
this
nsDisplayOwnLayer
:
:
OwnLayerForTransformWithRoundedClip
&
resultList
aBuilder
-
>
CurrentActiveScrolledRoot
(
)
nsDisplayOwnLayerFlags
:
:
None
ScrollbarData
{
}
false
false
)
;
createdContainer
=
true
;
}
if
(
useFixedPosition
)
{
if
(
clipCapturedBy
=
=
ContainerItemType
:
:
FixedPosition
)
{
clipState
.
Restore
(
)
;
}
const
ActiveScrolledRoot
*
fixedASR
=
ActiveScrolledRoot
:
:
PickAncestor
(
containerItemASR
aBuilder
-
>
CurrentActiveScrolledRoot
(
)
)
;
resultList
.
AppendNewToTop
<
nsDisplayFixedPosition
>
(
aBuilder
this
&
resultList
fixedASR
containerItemASR
)
;
createdContainer
=
true
;
}
else
if
(
useStickyPosition
)
{
const
ActiveScrolledRoot
*
stickyASR
=
ActiveScrolledRoot
:
:
PickAncestor
(
containerItemASR
aBuilder
-
>
CurrentActiveScrolledRoot
(
)
)
;
auto
*
stickyItem
=
MakeDisplayItem
<
nsDisplayStickyPosition
>
(
aBuilder
this
&
resultList
stickyASR
aBuilder
-
>
CurrentActiveScrolledRoot
(
)
clipState
.
IsClippedToDisplayPort
(
)
)
;
bool
shouldFlatten
=
true
;
StickyScrollContainer
*
stickyScrollContainer
=
StickyScrollContainer
:
:
GetStickyScrollContainerForFrame
(
this
)
;
if
(
stickyScrollContainer
&
&
stickyScrollContainer
-
>
ScrollFrame
(
)
-
>
IsMaybeAsynchronouslyScrolled
(
)
)
{
shouldFlatten
=
false
;
}
stickyItem
-
>
SetShouldFlatten
(
shouldFlatten
)
;
resultList
.
AppendToTop
(
stickyItem
)
;
createdContainer
=
true
;
if
(
aBuilder
-
>
GetFilterASR
(
)
&
&
aBuilder
-
>
GetFilterASR
(
)
=
=
stickyASR
)
{
aBuilder
-
>
GetFilterASR
(
)
-
>
mScrollableFrame
-
>
SetHasOutOfFlowContentInsideFilter
(
)
;
}
}
if
(
useBlendMode
)
{
DisplayListClipState
:
:
AutoSaveRestore
blendModeClipState
(
aBuilder
)
;
resultList
.
AppendNewToTop
<
nsDisplayBlendMode
>
(
aBuilder
this
&
resultList
effects
-
>
mMixBlendMode
containerItemASR
false
)
;
createdContainer
=
true
;
}
bool
createdOwnLayer
=
false
;
CreateOwnLayerIfNeeded
(
aBuilder
&
resultList
nsDisplayOwnLayer
:
:
OwnLayerForStackingContext
&
createdOwnLayer
)
;
if
(
createdOwnLayer
)
{
createdContainer
=
true
;
}
if
(
aBuilder
-
>
IsReusingStackingContextItems
(
)
)
{
if
(
resultList
.
IsEmpty
(
)
)
{
return
;
}
nsDisplayItem
*
container
=
resultList
.
GetBottom
(
)
;
if
(
resultList
.
Length
(
)
>
1
|
|
container
-
>
Frame
(
)
!
=
this
)
{
container
=
MakeDisplayItem
<
nsDisplayContainer
>
(
aBuilder
this
containerItemASR
&
resultList
)
;
}
else
{
MOZ_ASSERT
(
resultList
.
Length
(
)
=
=
1
)
;
resultList
.
Clear
(
)
;
}
if
(
!
container
-
>
IsReusedItem
(
)
)
{
container
-
>
SetReusable
(
)
;
}
aList
-
>
AppendToTop
(
container
)
;
createdContainer
=
true
;
}
else
{
aList
-
>
AppendToTop
(
&
resultList
)
;
}
if
(
aCreatedContainerItem
)
{
*
aCreatedContainerItem
=
createdContainer
;
}
}
static
nsDisplayItem
*
WrapInWrapList
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
ActiveScrolledRoot
*
aContainerASR
bool
aBuiltContainerItem
=
false
)
{
nsDisplayItem
*
item
=
aList
-
>
GetBottom
(
)
;
if
(
!
item
)
{
return
nullptr
;
}
bool
needsWrapList
=
aList
-
>
Length
(
)
>
1
|
|
item
-
>
Frame
(
)
!
=
aFrame
|
|
item
-
>
GetChildren
(
)
;
if
(
aBuiltContainerItem
|
|
(
!
aBuilder
-
>
IsPartialUpdate
(
)
&
&
!
needsWrapList
)
)
{
MOZ_ASSERT
(
aList
-
>
Length
(
)
=
=
1
)
;
aList
-
>
Clear
(
)
;
return
item
;
}
if
(
aBuilder
-
>
IsPartialUpdate
(
)
&
&
!
aFrame
-
>
HasDisplayItem
(
uint32_t
(
DisplayItemType
:
:
TYPE_CONTAINER
)
)
)
{
if
(
needsWrapList
)
{
DiscardOldItems
(
aFrame
)
;
}
else
{
MOZ_ASSERT
(
aList
-
>
Length
(
)
=
=
1
)
;
aList
-
>
Clear
(
)
;
return
item
;
}
}
return
MakeDisplayItem
<
nsDisplayContainer
>
(
aBuilder
aFrame
aContainerASR
aList
)
;
}
static
bool
DescendIntoChild
(
nsDisplayListBuilder
*
aBuilder
const
nsIFrame
*
aChild
const
nsRect
&
aVisible
const
nsRect
&
aDirty
)
{
if
(
aChild
-
>
HasAnyStateBits
(
NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO
)
)
{
return
true
;
}
if
(
aChild
=
=
aBuilder
-
>
GetIgnoreScrollFrame
(
)
)
{
return
true
;
}
if
(
aChild
=
=
aBuilder
-
>
GetPresShellIgnoreScrollFrame
(
)
)
{
return
true
;
}
nsRect
overflow
=
aChild
-
>
InkOverflowRect
(
)
;
if
(
aBuilder
-
>
IsForEventDelivery
(
)
&
&
aChild
=
=
aChild
-
>
PresShell
(
)
-
>
GetRootScrollFrame
(
)
&
&
aChild
-
>
PresContext
(
)
-
>
IsRootContentDocumentCrossProcess
(
)
&
&
aChild
-
>
PresContext
(
)
-
>
HasDynamicToolbar
(
)
)
{
overflow
.
SizeTo
(
nsLayoutUtils
:
:
ExpandHeightForDynamicToolbar
(
aChild
-
>
PresContext
(
)
overflow
.
Size
(
)
)
)
;
}
if
(
aDirty
.
Intersects
(
overflow
)
)
{
return
true
;
}
if
(
aChild
-
>
ForceDescendIntoIfVisible
(
)
&
&
aVisible
.
Intersects
(
overflow
)
)
{
return
true
;
}
if
(
aChild
-
>
IsFrameOfType
(
nsIFrame
:
:
eTablePart
)
)
{
const
nsIFrame
*
f
=
aChild
;
nsRect
normalPositionOverflowRelativeToTable
=
overflow
;
while
(
f
-
>
IsFrameOfType
(
nsIFrame
:
:
eTablePart
)
)
{
normalPositionOverflowRelativeToTable
+
=
f
-
>
GetNormalPosition
(
)
;
f
=
f
-
>
GetParent
(
)
;
}
nsDisplayTableBackgroundSet
*
tableBGs
=
aBuilder
-
>
GetTableBackgroundSet
(
)
;
if
(
tableBGs
&
&
tableBGs
-
>
GetDirtyRect
(
)
.
Intersects
(
normalPositionOverflowRelativeToTable
)
)
{
return
true
;
}
}
return
false
;
}
void
nsIFrame
:
:
BuildDisplayListForSimpleChild
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aChild
const
nsDisplayListSet
&
aLists
)
{
MOZ_ASSERT
(
aChild
-
>
Type
(
)
!
=
LayoutFrameType
:
:
Placeholder
)
;
MOZ_ASSERT
(
!
aBuilder
-
>
GetSelectedFramesOnly
(
)
&
&
!
aBuilder
-
>
GetIncludeAllOutOfFlows
(
)
"
It
should
be
held
for
painting
to
window
"
)
;
MOZ_ASSERT
(
aChild
-
>
HasAnyStateBits
(
NS_FRAME_SIMPLE_DISPLAYLIST
)
)
;
const
nsPoint
offset
=
aChild
-
>
GetOffsetTo
(
this
)
;
const
nsRect
visible
=
aBuilder
-
>
GetVisibleRect
(
)
-
offset
;
const
nsRect
dirty
=
aBuilder
-
>
GetDirtyRect
(
)
-
offset
;
if
(
!
DescendIntoChild
(
aBuilder
aChild
visible
dirty
)
)
{
DL_LOGV
(
"
Skipped
frame
%
p
"
aChild
)
;
return
;
}
nsDisplayListBuilder
:
:
AutoBuildingDisplayList
buildingForChild
(
aBuilder
aChild
visible
dirty
false
)
;
UpdateCurrentHitTestInfo
(
aBuilder
aChild
)
;
aChild
-
>
MarkAbsoluteFramesForDisplayList
(
aBuilder
)
;
aBuilder
-
>
AdjustWindowDraggingRegion
(
aChild
)
;
aBuilder
-
>
Check
(
)
;
aChild
-
>
BuildDisplayList
(
aBuilder
aLists
)
;
aChild
-
>
SetBuiltDisplayList
(
true
)
;
aBuilder
-
>
Check
(
)
;
aBuilder
-
>
DisplayCaret
(
aChild
aLists
.
Outlines
(
)
)
;
}
nsIFrame
:
:
DisplayChildFlag
nsIFrame
:
:
DisplayFlagForFlexOrGridItem
(
)
const
{
MOZ_ASSERT
(
IsFlexOrGridItem
(
)
"
Should
only
be
called
on
flex
or
grid
items
!
"
)
;
return
DisplayChildFlag
:
:
ForcePseudoStackingContext
;
}
static
bool
ShouldSkipFrame
(
nsDisplayListBuilder
*
aBuilder
const
nsIFrame
*
aFrame
)
{
if
(
aBuilder
-
>
IsBackgroundOnly
(
)
)
{
return
true
;
}
if
(
aBuilder
-
>
IsForGenerateGlyphMask
(
)
&
&
(
!
aFrame
-
>
IsTextFrame
(
)
&
&
aFrame
-
>
IsLeaf
(
)
)
)
{
return
true
;
}
if
(
aBuilder
-
>
GetSelectedFramesOnly
(
)
&
&
(
aFrame
-
>
IsLeaf
(
)
&
&
!
aFrame
-
>
IsSelected
(
)
)
)
{
return
true
;
}
static
const
nsFrameState
skipFlags
=
(
NS_FRAME_TOO_DEEP_IN_FRAME_TREE
|
NS_FRAME_IS_NONDISPLAY
)
;
return
aFrame
-
>
HasAnyStateBits
(
skipFlags
)
;
}
void
nsIFrame
:
:
BuildDisplayListForChild
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aChild
const
nsDisplayListSet
&
aLists
DisplayChildFlags
aFlags
)
{
AutoCheckBuilder
check
(
aBuilder
)
;
#
ifdef
DEBUG
DL_LOGV
(
"
BuildDisplayListForChild
(
%
p
)
<
"
aChild
)
;
ScopeExit
e
(
[
aChild
]
(
)
{
DL_LOGV
(
"
>
BuildDisplayListForChild
(
%
p
)
"
aChild
)
;
}
)
;
#
endif
if
(
ShouldSkipFrame
(
aBuilder
aChild
)
)
{
return
;
}
if
(
IsContentHidden
(
)
)
{
return
;
}
Maybe
<
nsDisplayListBuilder
:
:
Linkifier
>
linkifier
;
if
(
StaticPrefs
:
:
print_save_as_pdf_links_enabled
(
)
&
&
aBuilder
-
>
IsForPrinting
(
)
)
{
linkifier
.
emplace
(
aBuilder
aChild
aLists
.
Content
(
)
)
;
linkifier
-
>
MaybeAppendLink
(
aBuilder
aChild
)
;
}
nsIFrame
*
child
=
aChild
;
auto
*
placeholder
=
child
-
>
IsPlaceholderFrame
(
)
?
static_cast
<
nsPlaceholderFrame
*
>
(
child
)
:
nullptr
;
nsIFrame
*
childOrOutOfFlow
=
placeholder
?
placeholder
-
>
GetOutOfFlowFrame
(
)
:
child
;
nsIFrame
*
parent
=
childOrOutOfFlow
-
>
GetParent
(
)
;
const
auto
*
parentDisplay
=
parent
-
>
StyleDisplay
(
)
;
const
auto
overflowClipAxes
=
parent
-
>
ShouldApplyOverflowClipping
(
parentDisplay
)
;
const
bool
isPaintingToWindow
=
aBuilder
-
>
IsPaintingToWindow
(
)
;
const
bool
doingShortcut
=
isPaintingToWindow
&
&
child
-
>
HasAnyStateBits
(
NS_FRAME_SIMPLE_DISPLAYLIST
)
&
&
!
(
overflowClipAxes
!
=
PhysicalAxes
:
:
None
|
|
child
-
>
MayHaveTransformAnimation
(
)
|
|
child
-
>
MayHaveOpacityAnimation
(
)
)
;
if
(
aBuilder
-
>
IsForPainting
(
)
)
{
aBuilder
-
>
ClearWillChangeBudgetStatus
(
child
)
;
}
if
(
StaticPrefs
:
:
layout_css_scroll_anchoring_highlight
(
)
)
{
if
(
child
-
>
FirstContinuation
(
)
-
>
IsScrollAnchor
(
)
)
{
nsRect
bounds
=
child
-
>
GetContentRectRelativeToSelf
(
)
+
aBuilder
-
>
ToReferenceFrame
(
child
)
;
nsDisplaySolidColor
*
color
=
MakeDisplayItem
<
nsDisplaySolidColor
>
(
aBuilder
child
bounds
NS_RGBA
(
255
0
255
64
)
)
;
if
(
color
)
{
color
-
>
SetOverrideZIndex
(
INT32_MAX
)
;
aLists
.
PositionedDescendants
(
)
-
>
AppendToTop
(
color
)
;
}
}
}
if
(
doingShortcut
)
{
BuildDisplayListForSimpleChild
(
aBuilder
child
aLists
)
;
return
;
}
NS_ASSERTION
(
aBuilder
-
>
GetCurrentFrame
(
)
=
=
this
"
Wrong
coord
space
!
"
)
;
const
nsPoint
offset
=
child
-
>
GetOffsetTo
(
this
)
;
nsRect
visible
=
aBuilder
-
>
GetVisibleRect
(
)
-
offset
;
nsRect
dirty
=
aBuilder
-
>
GetDirtyRect
(
)
-
offset
;
nsDisplayListBuilder
:
:
OutOfFlowDisplayData
*
savedOutOfFlowData
=
nullptr
;
if
(
placeholder
)
{
if
(
placeholder
-
>
HasAnyStateBits
(
PLACEHOLDER_FOR_TOPLAYER
)
)
{
return
;
}
child
=
childOrOutOfFlow
;
if
(
aBuilder
-
>
IsForPainting
(
)
)
{
aBuilder
-
>
ClearWillChangeBudgetStatus
(
child
)
;
}
static
const
nsFrameState
skipFlags
=
(
NS_FRAME_IS_PUSHED_FLOAT
|
NS_FRAME_TOO_DEEP_IN_FRAME_TREE
|
NS_FRAME_IS_NONDISPLAY
)
;
if
(
child
-
>
HasAnyStateBits
(
skipFlags
)
|
|
nsLayoutUtils
:
:
IsPopup
(
child
)
)
{
return
;
}
MOZ_ASSERT
(
child
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
)
;
savedOutOfFlowData
=
nsDisplayListBuilder
:
:
GetOutOfFlowData
(
child
)
;
if
(
aBuilder
-
>
GetIncludeAllOutOfFlows
(
)
)
{
visible
=
child
-
>
InkOverflowRect
(
)
;
dirty
=
child
-
>
InkOverflowRect
(
)
;
}
else
if
(
savedOutOfFlowData
)
{
visible
=
savedOutOfFlowData
-
>
GetVisibleRectForFrame
(
aBuilder
child
&
dirty
)
;
}
else
{
visible
.
SetEmpty
(
)
;
dirty
.
SetEmpty
(
)
;
}
}
NS_ASSERTION
(
!
child
-
>
IsPlaceholderFrame
(
)
"
Should
have
dealt
with
placeholders
already
"
)
;
if
(
!
DescendIntoChild
(
aBuilder
child
visible
dirty
)
)
{
DL_LOGV
(
"
Skipped
frame
%
p
"
child
)
;
return
;
}
const
bool
isSVG
=
child
-
>
HasAnyStateBits
(
NS_FRAME_SVG_LAYOUT
)
;
bool
awayFromCommonPath
=
!
isPaintingToWindow
;
bool
pseudoStackingContext
=
aFlags
.
contains
(
DisplayChildFlag
:
:
ForcePseudoStackingContext
)
;
if
(
!
pseudoStackingContext
&
&
!
isSVG
&
&
aFlags
.
contains
(
DisplayChildFlag
:
:
Inline
)
&
&
!
child
-
>
IsFrameOfType
(
eLineParticipant
)
)
{
pseudoStackingContext
=
true
;
}
const
nsStyleDisplay
*
ourDisp
=
StyleDisplay
(
)
;
if
(
IsThemed
(
ourDisp
)
&
&
!
PresContext
(
)
-
>
Theme
(
)
-
>
WidgetIsContainer
(
ourDisp
-
>
EffectiveAppearance
(
)
)
)
{
return
;
}
if
(
isPaintingToWindow
&
&
child
-
>
TrackingVisibility
(
)
&
&
child
-
>
IsVisibleForPainting
(
)
)
{
child
-
>
PresShell
(
)
-
>
EnsureFrameInApproximatelyVisibleList
(
child
)
;
awayFromCommonPath
=
true
;
}
const
nsStyleDisplay
*
disp
=
child
-
>
StyleDisplay
(
)
;
const
nsStyleEffects
*
effects
=
child
-
>
StyleEffects
(
)
;
const
bool
isPositioned
=
disp
-
>
IsPositionedStyle
(
)
;
const
bool
isStackingContext
=
aFlags
.
contains
(
DisplayChildFlag
:
:
ForceStackingContext
)
|
|
child
-
>
IsStackingContext
(
disp
effects
)
;
if
(
pseudoStackingContext
|
|
isStackingContext
|
|
isPositioned
|
|
placeholder
|
|
(
!
isSVG
&
&
disp
-
>
IsFloating
(
child
)
)
|
|
(
isSVG
&
&
effects
-
>
mClip
.
IsRect
(
)
&
&
IsSVGContentWithCSSClip
(
child
)
)
)
{
pseudoStackingContext
=
true
;
awayFromCommonPath
=
true
;
}
NS_ASSERTION
(
!
isStackingContext
|
|
pseudoStackingContext
"
Stacking
contexts
must
also
be
pseudo
-
stacking
-
contexts
"
)
;
nsDisplayListBuilder
:
:
AutoBuildingDisplayList
buildingForChild
(
aBuilder
child
visible
dirty
)
;
UpdateCurrentHitTestInfo
(
aBuilder
child
)
;
DisplayListClipState
:
:
AutoClipMultiple
clipState
(
aBuilder
)
;
nsDisplayListBuilder
:
:
AutoCurrentActiveScrolledRootSetter
asrSetter
(
aBuilder
)
;
if
(
savedOutOfFlowData
)
{
aBuilder
-
>
SetBuildingInvisibleItems
(
false
)
;
clipState
.
SetClipChainForContainingBlockDescendants
(
savedOutOfFlowData
-
>
mContainingBlockClipChain
)
;
asrSetter
.
SetCurrentActiveScrolledRoot
(
savedOutOfFlowData
-
>
mContainingBlockActiveScrolledRoot
)
;
MOZ_ASSERT
(
awayFromCommonPath
"
It
is
impossible
when
savedOutOfFlowData
is
true
"
)
;
}
else
if
(
HasAnyStateBits
(
NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO
)
&
&
placeholder
)
{
NS_ASSERTION
(
visible
.
IsEmpty
(
)
"
should
have
empty
visible
rect
"
)
;
aBuilder
-
>
SetBuildingInvisibleItems
(
true
)
;
clipState
.
SetClipChainForContainingBlockDescendants
(
nullptr
)
;
}
if
(
overflowClipAxes
!
=
PhysicalAxes
:
:
None
)
{
ApplyOverflowClipping
(
aBuilder
parent
overflowClipAxes
clipState
)
;
awayFromCommonPath
=
true
;
}
nsDisplayList
list
(
aBuilder
)
;
nsDisplayList
extraPositionedDescendants
(
aBuilder
)
;
const
ActiveScrolledRoot
*
wrapListASR
;
bool
builtContainerItem
=
false
;
if
(
isStackingContext
)
{
nsDisplayListBuilder
:
:
AutoContainerASRTracker
contASRTracker
(
aBuilder
)
;
child
-
>
BuildDisplayListForStackingContext
(
aBuilder
&
list
&
builtContainerItem
)
;
wrapListASR
=
contASRTracker
.
GetContainerASR
(
)
;
if
(
!
aBuilder
-
>
IsReusingStackingContextItems
(
)
&
&
aBuilder
-
>
GetCaretFrame
(
)
=
=
child
)
{
builtContainerItem
=
false
;
}
}
else
{
Maybe
<
nsRect
>
clipPropClip
=
child
-
>
GetClipPropClipRect
(
disp
effects
child
-
>
GetSize
(
)
)
;
if
(
clipPropClip
)
{
aBuilder
-
>
IntersectVisibleRect
(
*
clipPropClip
)
;
aBuilder
-
>
IntersectDirtyRect
(
*
clipPropClip
)
;
clipState
.
ClipContentDescendants
(
*
clipPropClip
+
aBuilder
-
>
ToReferenceFrame
(
child
)
)
;
awayFromCommonPath
=
true
;
}
child
-
>
MarkAbsoluteFramesForDisplayList
(
aBuilder
)
;
child
-
>
SetBuiltDisplayList
(
true
)
;
if
(
!
awayFromCommonPath
&
&
!
child
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
)
{
child
-
>
AddStateBits
(
NS_FRAME_SIMPLE_DISPLAYLIST
)
;
}
if
(
!
pseudoStackingContext
)
{
aBuilder
-
>
AdjustWindowDraggingRegion
(
child
)
;
aBuilder
-
>
Check
(
)
;
child
-
>
BuildDisplayList
(
aBuilder
aLists
)
;
aBuilder
-
>
Check
(
)
;
aBuilder
-
>
DisplayCaret
(
child
aLists
.
Outlines
(
)
)
;
return
;
}
nsDisplayListCollection
pseudoStack
(
aBuilder
)
;
aBuilder
-
>
AdjustWindowDraggingRegion
(
child
)
;
nsDisplayListBuilder
:
:
AutoContainerASRTracker
contASRTracker
(
aBuilder
)
;
aBuilder
-
>
Check
(
)
;
child
-
>
BuildDisplayList
(
aBuilder
pseudoStack
)
;
aBuilder
-
>
Check
(
)
;
if
(
aBuilder
-
>
DisplayCaret
(
child
pseudoStack
.
Outlines
(
)
)
)
{
builtContainerItem
=
false
;
}
wrapListASR
=
contASRTracker
.
GetContainerASR
(
)
;
list
.
AppendToTop
(
pseudoStack
.
BorderBackground
(
)
)
;
list
.
AppendToTop
(
pseudoStack
.
BlockBorderBackgrounds
(
)
)
;
list
.
AppendToTop
(
pseudoStack
.
Floats
(
)
)
;
list
.
AppendToTop
(
pseudoStack
.
Content
(
)
)
;
list
.
AppendToTop
(
pseudoStack
.
Outlines
(
)
)
;
extraPositionedDescendants
.
AppendToTop
(
pseudoStack
.
PositionedDescendants
(
)
)
;
}
buildingForChild
.
RestoreBuildingInvisibleItemsValue
(
)
;
if
(
!
list
.
IsEmpty
(
)
)
{
if
(
isPositioned
|
|
isStackingContext
)
{
nsDisplayItem
*
item
=
WrapInWrapList
(
aBuilder
child
&
list
wrapListASR
builtContainerItem
)
;
if
(
isSVG
)
{
aLists
.
Content
(
)
-
>
AppendToTop
(
item
)
;
}
else
{
aLists
.
PositionedDescendants
(
)
-
>
AppendToTop
(
item
)
;
}
}
else
if
(
!
isSVG
&
&
disp
-
>
IsFloating
(
child
)
)
{
aLists
.
Floats
(
)
-
>
AppendToTop
(
WrapInWrapList
(
aBuilder
child
&
list
wrapListASR
)
)
;
}
else
{
aLists
.
Content
(
)
-
>
AppendToTop
(
&
list
)
;
}
}
aLists
.
PositionedDescendants
(
)
-
>
AppendToTop
(
&
extraPositionedDescendants
)
;
}
void
nsIFrame
:
:
MarkAbsoluteFramesForDisplayList
(
nsDisplayListBuilder
*
aBuilder
)
{
if
(
IsAbsoluteContainer
(
)
)
{
aBuilder
-
>
MarkFramesForDisplayList
(
this
GetAbsoluteContainingBlock
(
)
-
>
GetChildList
(
)
)
;
}
}
nsresult
nsIFrame
:
:
GetContentForEvent
(
const
WidgetEvent
*
aEvent
nsIContent
*
*
aContent
)
{
nsIFrame
*
f
=
nsLayoutUtils
:
:
GetNonGeneratedAncestor
(
this
)
;
*
aContent
=
f
-
>
GetContent
(
)
;
NS_IF_ADDREF
(
*
aContent
)
;
return
NS_OK
;
}
void
nsIFrame
:
:
FireDOMEvent
(
const
nsAString
&
aDOMEventName
nsIContent
*
aContent
)
{
nsIContent
*
target
=
aContent
?
aContent
:
GetContent
(
)
;
if
(
target
)
{
RefPtr
<
AsyncEventDispatcher
>
asyncDispatcher
=
new
AsyncEventDispatcher
(
target
aDOMEventName
CanBubble
:
:
eYes
ChromeOnlyDispatch
:
:
eNo
)
;
DebugOnly
<
nsresult
>
rv
=
asyncDispatcher
-
>
PostDOMEvent
(
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AsyncEventDispatcher
failed
to
dispatch
"
)
;
}
}
nsresult
nsIFrame
:
:
HandleEvent
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
{
if
(
aEvent
-
>
mMessage
=
=
eMouseMove
)
{
return
HandleDrag
(
aPresContext
aEvent
aEventStatus
)
;
}
if
(
(
aEvent
-
>
mClass
=
=
eMouseEventClass
&
&
aEvent
-
>
AsMouseEvent
(
)
-
>
mButton
=
=
MouseButton
:
:
ePrimary
)
|
|
aEvent
-
>
mClass
=
=
eTouchEventClass
)
{
if
(
aEvent
-
>
mMessage
=
=
eMouseDown
|
|
aEvent
-
>
mMessage
=
=
eTouchStart
)
{
HandlePress
(
aPresContext
aEvent
aEventStatus
)
;
}
else
if
(
aEvent
-
>
mMessage
=
=
eMouseUp
|
|
aEvent
-
>
mMessage
=
=
eTouchEnd
)
{
HandleRelease
(
aPresContext
aEvent
aEventStatus
)
;
}
return
NS_OK
;
}
if
(
aEvent
-
>
mMessage
=
=
eMouseDown
)
{
WidgetMouseEvent
*
mouseEvent
=
aEvent
-
>
AsMouseEvent
(
)
;
if
(
mouseEvent
&
&
mouseEvent
-
>
mButton
=
=
MouseButton
:
:
eMiddle
)
{
if
(
*
aEventStatus
=
=
nsEventStatus_eConsumeNoDefault
)
{
return
NS_OK
;
}
return
MoveCaretToEventPoint
(
aPresContext
mouseEvent
aEventStatus
)
;
}
}
return
NS_OK
;
}
nsresult
nsIFrame
:
:
GetDataForTableSelection
(
const
nsFrameSelection
*
aFrameSelection
mozilla
:
:
PresShell
*
aPresShell
WidgetMouseEvent
*
aMouseEvent
nsIContent
*
*
aParentContent
int32_t
*
aContentOffset
TableSelectionMode
*
aTarget
)
{
if
(
!
aFrameSelection
|
|
!
aPresShell
|
|
!
aMouseEvent
|
|
!
aParentContent
|
|
!
aContentOffset
|
|
!
aTarget
)
return
NS_ERROR_NULL_POINTER
;
*
aParentContent
=
nullptr
;
*
aContentOffset
=
0
;
*
aTarget
=
TableSelectionMode
:
:
None
;
int16_t
displaySelection
=
aPresShell
-
>
GetSelectionFlags
(
)
;
bool
selectingTableCells
=
aFrameSelection
-
>
IsInTableSelectionMode
(
)
;
bool
doTableSelection
=
displaySelection
=
=
nsISelectionDisplay
:
:
DISPLAY_ALL
&
&
selectingTableCells
&
&
(
aMouseEvent
-
>
mMessage
=
=
eMouseMove
|
|
(
aMouseEvent
-
>
mMessage
=
=
eMouseUp
&
&
aMouseEvent
-
>
mButton
=
=
MouseButton
:
:
ePrimary
)
|
|
aMouseEvent
-
>
IsShift
(
)
)
;
if
(
!
doTableSelection
)
{
#
ifdef
XP_MACOSX
doTableSelection
=
aMouseEvent
-
>
IsMeta
(
)
|
|
(
aMouseEvent
-
>
IsShift
(
)
&
&
selectingTableCells
)
;
#
else
doTableSelection
=
aMouseEvent
-
>
IsControl
(
)
|
|
(
aMouseEvent
-
>
IsShift
(
)
&
&
selectingTableCells
)
;
#
endif
}
if
(
!
doTableSelection
)
return
NS_OK
;
nsIFrame
*
frame
=
this
;
bool
foundCell
=
false
;
bool
foundTable
=
false
;
nsIContent
*
limiter
=
aFrameSelection
-
>
GetLimiter
(
)
;
if
(
limiter
&
&
limiter
-
>
IsInclusiveDescendantOf
(
GetContent
(
)
)
)
return
NS_OK
;
while
(
frame
)
{
nsITableCellLayout
*
cellElement
=
do_QueryFrame
(
frame
)
;
if
(
cellElement
)
{
foundCell
=
true
;
break
;
}
else
{
nsTableWrapperFrame
*
tableFrame
=
do_QueryFrame
(
frame
)
;
if
(
tableFrame
)
{
foundTable
=
true
;
break
;
}
else
{
frame
=
frame
-
>
GetParent
(
)
;
if
(
frame
&
&
frame
-
>
GetContent
(
)
=
=
limiter
)
break
;
}
}
}
if
(
!
foundCell
&
&
!
foundTable
)
return
NS_OK
;
nsIContent
*
tableOrCellContent
=
frame
-
>
GetContent
(
)
;
if
(
!
tableOrCellContent
)
return
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsIContent
>
parentContent
=
tableOrCellContent
-
>
GetParent
(
)
;
if
(
!
parentContent
)
return
NS_ERROR_FAILURE
;
const
int32_t
offset
=
parentContent
-
>
ComputeIndexOf_Deprecated
(
tableOrCellContent
)
;
if
(
offset
<
0
)
{
return
NS_ERROR_FAILURE
;
}
parentContent
.
forget
(
aParentContent
)
;
*
aContentOffset
=
offset
;
#
if
0
if
(
selectRow
)
*
aTarget
=
TableSelectionMode
:
:
Row
;
else
if
(
selectColumn
)
*
aTarget
=
TableSelectionMode
:
:
Column
;
else
#
endif
if
(
foundCell
)
{
*
aTarget
=
TableSelectionMode
:
:
Cell
;
}
else
if
(
foundTable
)
{
*
aTarget
=
TableSelectionMode
:
:
Table
;
}
return
NS_OK
;
}
static
bool
IsEditingHost
(
const
nsIFrame
*
aFrame
)
{
auto
*
element
=
nsGenericHTMLElement
:
:
FromNodeOrNull
(
aFrame
-
>
GetContent
(
)
)
;
return
element
&
&
element
-
>
IsEditableRoot
(
)
;
}
static
StyleUserSelect
UsedUserSelect
(
const
nsIFrame
*
aFrame
)
{
if
(
aFrame
-
>
IsGeneratedContentFrame
(
)
)
{
return
StyleUserSelect
:
:
None
;
}
auto
style
=
aFrame
-
>
Style
(
)
-
>
UserSelect
(
)
;
if
(
style
!
=
StyleUserSelect
:
:
Auto
)
{
return
style
;
}
if
(
aFrame
-
>
IsTextInputFrame
(
)
|
|
IsEditingHost
(
aFrame
)
)
{
return
StyleUserSelect
:
:
Text
;
}
auto
*
parent
=
nsLayoutUtils
:
:
GetParentOrPlaceholderFor
(
aFrame
)
;
return
parent
?
UsedUserSelect
(
parent
)
:
StyleUserSelect
:
:
Text
;
}
bool
nsIFrame
:
:
IsSelectable
(
StyleUserSelect
*
aSelectStyle
)
const
{
auto
style
=
UsedUserSelect
(
this
)
;
if
(
aSelectStyle
)
{
*
aSelectStyle
=
style
;
}
return
style
!
=
StyleUserSelect
:
:
None
;
}
bool
nsIFrame
:
:
ShouldHaveLineIfEmpty
(
)
const
{
if
(
Style
(
)
-
>
IsPseudoOrAnonBox
(
)
&
&
Style
(
)
-
>
GetPseudoType
(
)
!
=
PseudoStyleType
:
:
scrolledContent
)
{
return
false
;
}
return
IsEditingHost
(
this
)
;
}
NS_IMETHODIMP
nsIFrame
:
:
HandlePress
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
{
NS_ENSURE_ARG_POINTER
(
aEventStatus
)
;
if
(
nsEventStatus_eConsumeNoDefault
=
=
*
aEventStatus
)
{
return
NS_OK
;
}
NS_ENSURE_ARG_POINTER
(
aEvent
)
;
if
(
aEvent
-
>
mClass
=
=
eTouchEventClass
)
{
return
NS_OK
;
}
return
MoveCaretToEventPoint
(
aPresContext
aEvent
-
>
AsMouseEvent
(
)
aEventStatus
)
;
}
nsresult
nsIFrame
:
:
MoveCaretToEventPoint
(
nsPresContext
*
aPresContext
WidgetMouseEvent
*
aMouseEvent
nsEventStatus
*
aEventStatus
)
{
MOZ_ASSERT
(
aPresContext
)
;
MOZ_ASSERT
(
aMouseEvent
)
;
MOZ_ASSERT
(
aMouseEvent
-
>
mMessage
=
=
eMouseDown
)
;
MOZ_ASSERT
(
aMouseEvent
-
>
mButton
=
=
MouseButton
:
:
ePrimary
|
|
aMouseEvent
-
>
mButton
=
=
MouseButton
:
:
eMiddle
)
;
MOZ_ASSERT
(
aEventStatus
)
;
MOZ_ASSERT
(
nsEventStatus_eConsumeNoDefault
!
=
*
aEventStatus
)
;
mozilla
:
:
PresShell
*
presShell
=
aPresContext
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
aPresContext
-
>
EventStateManager
(
)
-
>
EventStatusOK
(
aMouseEvent
)
)
{
return
NS_OK
;
}
const
nsPoint
pt
=
nsLayoutUtils
:
:
GetEventCoordinatesRelativeTo
(
aMouseEvent
RelativeTo
{
this
}
)
;
if
(
!
aMouseEvent
-
>
IsAlt
(
)
&
&
GetRectRelativeToSelf
(
)
.
Contains
(
pt
)
)
{
for
(
nsIContent
*
content
=
mContent
;
content
;
content
=
content
-
>
GetFlattenedTreeParent
(
)
)
{
if
(
nsContentUtils
:
:
ContentIsDraggable
(
content
)
&
&
!
content
-
>
IsEditable
(
)
)
{
return
NS_OK
;
}
}
}
const
bool
isEditor
=
presShell
-
>
GetSelectionFlags
(
)
=
=
nsISelectionDisplay
:
:
DISPLAY_ALL
;
const
bool
isPrimaryButtonDown
=
aMouseEvent
-
>
mButton
=
=
MouseButton
:
:
ePrimary
;
StyleUserSelect
selectStyle
;
if
(
!
IsSelectable
(
&
selectStyle
)
)
{
return
NS_OK
;
}
if
(
isPrimaryButtonDown
)
{
if
(
!
PresShell
:
:
GetCapturingContent
(
)
)
{
nsIScrollableFrame
*
scrollFrame
=
nsLayoutUtils
:
:
GetNearestScrollableFrame
(
this
nsLayoutUtils
:
:
SCROLLABLE_SAME_DOC
|
nsLayoutUtils
:
:
SCROLLABLE_INCLUDE_HIDDEN
)
;
if
(
scrollFrame
)
{
nsIFrame
*
capturingFrame
=
do_QueryFrame
(
scrollFrame
)
;
PresShell
:
:
SetCapturingContent
(
capturingFrame
-
>
GetContent
(
)
CaptureFlags
:
:
IgnoreAllowedState
)
;
}
}
}
const
nsFrameSelection
*
frameselection
=
selectStyle
=
=
StyleUserSelect
:
:
Text
?
GetConstFrameSelection
(
)
:
presShell
-
>
ConstFrameSelection
(
)
;
if
(
!
frameselection
|
|
frameselection
-
>
GetDisplaySelection
(
)
=
=
nsISelectionController
:
:
SELECTION_OFF
)
{
return
NS_OK
;
}
#
ifdef
XP_MACOSX
if
(
aMouseEvent
-
>
IsControl
(
)
)
{
return
NS_OK
;
}
const
bool
control
=
aMouseEvent
-
>
IsMeta
(
)
;
#
else
const
bool
control
=
aMouseEvent
-
>
IsControl
(
)
;
#
endif
RefPtr
<
nsFrameSelection
>
fc
=
const_cast
<
nsFrameSelection
*
>
(
frameselection
)
;
if
(
isPrimaryButtonDown
&
&
aMouseEvent
-
>
mClickCount
>
1
)
{
fc
-
>
SetDragState
(
true
)
;
return
HandleMultiplePress
(
aPresContext
aMouseEvent
aEventStatus
control
)
;
}
ContentOffsets
offsets
=
GetContentOffsetsFromPoint
(
pt
SKIP_HIDDEN
)
;
if
(
!
offsets
.
content
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aMouseEvent
-
>
mMessage
=
=
eMouseDown
&
&
aMouseEvent
-
>
mButton
=
=
MouseButton
:
:
eMiddle
&
&
!
offsets
.
content
-
>
IsEditable
(
)
)
{
if
(
!
Preferences
:
:
GetBool
(
"
middlemouse
.
paste
"
false
)
&
&
Preferences
:
:
GetBool
(
"
general
.
autoScroll
"
false
)
&
&
Preferences
:
:
GetBool
(
"
general
.
autoscroll
.
prevent_to_collapse_selection_
"
"
by_middle_mouse_down
"
false
)
)
{
return
NS_OK
;
}
}
if
(
isPrimaryButtonDown
)
{
nsCOMPtr
<
nsIContent
>
parentContent
;
int32_t
contentOffset
;
TableSelectionMode
target
;
nsresult
rv
=
GetDataForTableSelection
(
frameselection
presShell
aMouseEvent
getter_AddRefs
(
parentContent
)
&
contentOffset
&
target
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
parentContent
)
{
fc
-
>
SetDragState
(
true
)
;
return
fc
-
>
HandleTableSelection
(
parentContent
contentOffset
target
aMouseEvent
)
;
}
}
fc
-
>
SetDelayedCaretData
(
0
)
;
if
(
isPrimaryButtonDown
)
{
if
(
GetContent
(
)
&
&
GetContent
(
)
-
>
IsMaybeSelected
(
)
)
{
bool
inSelection
=
false
;
UniquePtr
<
SelectionDetails
>
details
=
frameselection
-
>
LookUpSelection
(
offsets
.
content
0
offsets
.
EndOffset
(
)
false
)
;
for
(
SelectionDetails
*
curDetail
=
details
.
get
(
)
;
curDetail
;
curDetail
=
curDetail
-
>
mNext
.
get
(
)
)
{
if
(
curDetail
-
>
mSelectionType
!
=
SelectionType
:
:
eSpellCheck
&
&
curDetail
-
>
mSelectionType
!
=
SelectionType
:
:
eFind
&
&
curDetail
-
>
mSelectionType
!
=
SelectionType
:
:
eURLSecondary
&
&
curDetail
-
>
mSelectionType
!
=
SelectionType
:
:
eURLStrikeout
&
&
curDetail
-
>
mStart
<
=
offsets
.
StartOffset
(
)
&
&
offsets
.
EndOffset
(
)
<
=
curDetail
-
>
mEnd
)
{
inSelection
=
true
;
}
}
if
(
inSelection
)
{
fc
-
>
SetDragState
(
false
)
;
fc
-
>
SetDelayedCaretData
(
aMouseEvent
)
;
return
NS_OK
;
}
}
fc
-
>
SetDragState
(
true
)
;
}
const
nsFrameSelection
:
:
FocusMode
focusMode
=
[
&
]
(
)
{
if
(
aMouseEvent
-
>
IsShift
(
)
)
{
if
(
isEditor
)
{
for
(
Element
*
element
:
mContent
-
>
InclusiveAncestorsOfType
<
Element
>
(
)
)
{
if
(
element
-
>
IsLink
(
)
)
{
return
nsFrameSelection
:
:
FocusMode
:
:
kCollapseToNewPoint
;
}
}
}
return
nsFrameSelection
:
:
FocusMode
:
:
kExtendSelection
;
}
if
(
isPrimaryButtonDown
&
&
control
)
{
return
nsFrameSelection
:
:
FocusMode
:
:
kMultiRangeSelection
;
}
return
nsFrameSelection
:
:
FocusMode
:
:
kCollapseToNewPoint
;
}
(
)
;
nsresult
rv
=
fc
-
>
HandleClick
(
MOZ_KnownLive
(
offsets
.
content
)
offsets
.
StartOffset
(
)
offsets
.
EndOffset
(
)
focusMode
offsets
.
associate
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
isPrimaryButtonDown
&
&
offsets
.
offset
!
=
offsets
.
secondaryOffset
)
{
fc
-
>
MaintainSelection
(
)
;
}
if
(
isPrimaryButtonDown
&
&
isEditor
&
&
!
aMouseEvent
-
>
IsShift
(
)
&
&
(
offsets
.
EndOffset
(
)
-
offsets
.
StartOffset
(
)
)
=
=
1
)
{
fc
-
>
SetDragState
(
false
)
;
}
return
NS_OK
;
}
nsresult
nsIFrame
:
:
SelectByTypeAtPoint
(
nsPresContext
*
aPresContext
const
nsPoint
&
aPoint
nsSelectionAmount
aBeginAmountType
nsSelectionAmount
aEndAmountType
uint32_t
aSelectFlags
)
{
NS_ENSURE_ARG_POINTER
(
aPresContext
)
;
if
(
DetermineDisplaySelection
(
)
=
=
nsISelectionController
:
:
SELECTION_OFF
)
{
return
NS_OK
;
}
ContentOffsets
offsets
=
GetContentOffsetsFromPoint
(
aPoint
SKIP_HIDDEN
)
;
if
(
!
offsets
.
content
)
{
return
NS_ERROR_FAILURE
;
}
int32_t
offset
;
nsIFrame
*
frame
=
nsFrameSelection
:
:
GetFrameForNodeOffset
(
offsets
.
content
offsets
.
offset
offsets
.
associate
&
offset
)
;
if
(
!
frame
)
{
return
NS_ERROR_FAILURE
;
}
return
frame
-
>
PeekBackwardAndForward
(
aBeginAmountType
aEndAmountType
offset
aBeginAmountType
!
=
eSelectWord
aSelectFlags
)
;
}
NS_IMETHODIMP
nsIFrame
:
:
HandleMultiplePress
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
bool
aControlHeld
)
{
NS_ENSURE_ARG_POINTER
(
aEvent
)
;
NS_ENSURE_ARG_POINTER
(
aEventStatus
)
;
if
(
nsEventStatus_eConsumeNoDefault
=
=
*
aEventStatus
|
|
DetermineDisplaySelection
(
)
=
=
nsISelectionController
:
:
SELECTION_OFF
)
{
return
NS_OK
;
}
nsSelectionAmount
beginAmount
endAmount
;
WidgetMouseEvent
*
mouseEvent
=
aEvent
-
>
AsMouseEvent
(
)
;
if
(
!
mouseEvent
)
{
return
NS_OK
;
}
if
(
mouseEvent
-
>
mClickCount
=
=
4
)
{
beginAmount
=
endAmount
=
eSelectParagraph
;
}
else
if
(
mouseEvent
-
>
mClickCount
=
=
3
)
{
if
(
Preferences
:
:
GetBool
(
"
browser
.
triple_click_selects_paragraph
"
)
)
{
beginAmount
=
endAmount
=
eSelectParagraph
;
}
else
{
beginAmount
=
eSelectBeginLine
;
endAmount
=
eSelectEndLine
;
}
}
else
if
(
mouseEvent
-
>
mClickCount
=
=
2
)
{
beginAmount
=
endAmount
=
eSelectWord
;
}
else
{
return
NS_OK
;
}
nsPoint
relPoint
=
nsLayoutUtils
:
:
GetEventCoordinatesRelativeTo
(
mouseEvent
RelativeTo
{
this
}
)
;
return
SelectByTypeAtPoint
(
aPresContext
relPoint
beginAmount
endAmount
(
aControlHeld
?
SELECT_ACCUMULATE
:
0
)
)
;
}
nsresult
nsIFrame
:
:
PeekBackwardAndForward
(
nsSelectionAmount
aAmountBack
nsSelectionAmount
aAmountForward
int32_t
aStartPos
bool
aJumpLines
uint32_t
aSelectFlags
)
{
nsIFrame
*
baseFrame
=
this
;
int32_t
baseOffset
=
aStartPos
;
nsresult
rv
;
if
(
aAmountBack
=
=
eSelectWord
)
{
nsPeekOffsetStruct
pos
(
eSelectCharacter
eDirNext
aStartPos
nsPoint
(
0
0
)
aJumpLines
true
false
false
false
)
;
rv
=
PeekOffset
(
&
pos
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
baseFrame
=
pos
.
mResultFrame
;
baseOffset
=
pos
.
mContentOffset
;
}
}
nsPeekOffsetStruct
startpos
(
aAmountBack
eDirPrevious
baseOffset
nsPoint
(
0
0
)
aJumpLines
true
false
false
false
)
;
rv
=
baseFrame
-
>
PeekOffset
(
&
startpos
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
startpos
.
mResultFrame
=
=
baseFrame
)
{
baseOffset
=
startpos
.
mContentOffset
;
}
else
{
baseFrame
=
this
;
baseOffset
=
aStartPos
;
}
nsPeekOffsetStruct
endpos
(
aAmountForward
eDirNext
baseOffset
nsPoint
(
0
0
)
aJumpLines
true
false
false
false
)
;
rv
=
baseFrame
-
>
PeekOffset
(
&
endpos
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
RefPtr
<
nsFrameSelection
>
frameSelection
=
GetFrameSelection
(
)
;
const
nsFrameSelection
:
:
FocusMode
focusMode
=
(
aSelectFlags
&
SELECT_ACCUMULATE
)
?
nsFrameSelection
:
:
FocusMode
:
:
kMultiRangeSelection
:
nsFrameSelection
:
:
FocusMode
:
:
kCollapseToNewPoint
;
rv
=
frameSelection
-
>
HandleClick
(
MOZ_KnownLive
(
startpos
.
mResultContent
)
startpos
.
mContentOffset
startpos
.
mContentOffset
focusMode
CARET_ASSOCIATE_AFTER
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
frameSelection
-
>
HandleClick
(
MOZ_KnownLive
(
endpos
.
mResultContent
)
endpos
.
mContentOffset
endpos
.
mContentOffset
nsFrameSelection
:
:
FocusMode
:
:
kExtendSelection
CARET_ASSOCIATE_BEFORE
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
frameSelection
-
>
MaintainSelection
(
aAmountBack
)
;
}
NS_IMETHODIMP
nsIFrame
:
:
HandleDrag
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
{
MOZ_ASSERT
(
aEvent
-
>
mClass
=
=
eMouseEventClass
"
HandleDrag
can
only
handle
mouse
event
"
)
;
NS_ENSURE_ARG_POINTER
(
aEventStatus
)
;
RefPtr
<
nsFrameSelection
>
frameselection
=
GetFrameSelection
(
)
;
if
(
!
frameselection
)
{
return
NS_OK
;
}
bool
mouseDown
=
frameselection
-
>
GetDragState
(
)
;
if
(
!
mouseDown
)
{
return
NS_OK
;
}
nsIFrame
*
scrollbar
=
nsLayoutUtils
:
:
GetClosestFrameOfType
(
this
LayoutFrameType
:
:
Scrollbar
)
;
if
(
!
scrollbar
)
{
if
(
DetermineDisplaySelection
(
)
=
=
nsISelectionController
:
:
SELECTION_OFF
)
{
return
NS_OK
;
}
}
frameselection
-
>
StopAutoScrollTimer
(
)
;
nsCOMPtr
<
nsIContent
>
parentContent
;
int32_t
contentOffset
;
TableSelectionMode
target
;
WidgetMouseEvent
*
mouseEvent
=
aEvent
-
>
AsMouseEvent
(
)
;
mozilla
:
:
PresShell
*
presShell
=
aPresContext
-
>
PresShell
(
)
;
nsresult
result
;
result
=
GetDataForTableSelection
(
frameselection
presShell
mouseEvent
getter_AddRefs
(
parentContent
)
&
contentOffset
&
target
)
;
AutoWeakFrame
weakThis
=
this
;
if
(
NS_SUCCEEDED
(
result
)
&
&
parentContent
)
{
result
=
frameselection
-
>
HandleTableSelection
(
parentContent
contentOffset
target
mouseEvent
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
result
)
)
)
{
return
result
;
}
}
else
{
nsPoint
pt
=
nsLayoutUtils
:
:
GetEventCoordinatesRelativeTo
(
mouseEvent
RelativeTo
{
this
}
)
;
frameselection
-
>
HandleDrag
(
this
pt
)
;
}
if
(
!
weakThis
.
IsAlive
(
)
)
{
return
NS_OK
;
}
nsIScrollableFrame
*
scrollFrame
=
nsLayoutUtils
:
:
GetNearestScrollableFrame
(
this
nsLayoutUtils
:
:
SCROLLABLE_SAME_DOC
|
nsLayoutUtils
:
:
SCROLLABLE_INCLUDE_HIDDEN
)
;
if
(
scrollFrame
)
{
nsIFrame
*
capturingFrame
=
scrollFrame
-
>
GetScrolledFrame
(
)
;
if
(
capturingFrame
)
{
nsPoint
pt
=
nsLayoutUtils
:
:
GetEventCoordinatesRelativeTo
(
mouseEvent
RelativeTo
{
capturingFrame
}
)
;
frameselection
-
>
StartAutoScrollTimer
(
capturingFrame
pt
30
)
;
}
}
return
NS_OK
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
static
nsresult
HandleFrameSelection
(
nsFrameSelection
*
aFrameSelection
nsIFrame
:
:
ContentOffsets
&
aOffsets
bool
aHandleTableSel
int32_t
aContentOffsetForTableSel
TableSelectionMode
aTargetForTableSel
nsIContent
*
aParentContentForTableSel
WidgetGUIEvent
*
aEvent
const
nsEventStatus
*
aEventStatus
)
{
if
(
!
aFrameSelection
)
{
return
NS_OK
;
}
nsresult
rv
=
NS_OK
;
if
(
nsEventStatus_eConsumeNoDefault
!
=
*
aEventStatus
)
{
if
(
!
aHandleTableSel
)
{
if
(
!
aOffsets
.
content
|
|
!
aFrameSelection
-
>
HasDelayedCaretData
(
)
)
{
return
NS_ERROR_FAILURE
;
}
aFrameSelection
-
>
SetDragState
(
true
)
;
const
nsFrameSelection
:
:
FocusMode
focusMode
=
aFrameSelection
-
>
IsShiftDownInDelayedCaretData
(
)
?
nsFrameSelection
:
:
FocusMode
:
:
kExtendSelection
:
nsFrameSelection
:
:
FocusMode
:
:
kCollapseToNewPoint
;
rv
=
aFrameSelection
-
>
HandleClick
(
MOZ_KnownLive
(
aOffsets
.
content
)
aOffsets
.
StartOffset
(
)
aOffsets
.
EndOffset
(
)
focusMode
aOffsets
.
associate
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
else
if
(
aParentContentForTableSel
)
{
aFrameSelection
-
>
SetDragState
(
false
)
;
rv
=
aFrameSelection
-
>
HandleTableSelection
(
aParentContentForTableSel
aContentOffsetForTableSel
aTargetForTableSel
aEvent
-
>
AsMouseEvent
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
aFrameSelection
-
>
SetDelayedCaretData
(
0
)
;
}
aFrameSelection
-
>
SetDragState
(
false
)
;
aFrameSelection
-
>
StopAutoScrollTimer
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsIFrame
:
:
HandleRelease
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
{
if
(
aEvent
-
>
mClass
!
=
eMouseEventClass
)
{
return
NS_OK
;
}
nsIFrame
*
activeFrame
=
GetActiveSelectionFrame
(
aPresContext
this
)
;
nsCOMPtr
<
nsIContent
>
captureContent
=
PresShell
:
:
GetCapturingContent
(
)
;
bool
selectionOff
=
(
DetermineDisplaySelection
(
)
=
=
nsISelectionController
:
:
SELECTION_OFF
)
;
RefPtr
<
nsFrameSelection
>
frameselection
;
ContentOffsets
offsets
;
nsCOMPtr
<
nsIContent
>
parentContent
;
int32_t
contentOffsetForTableSel
=
0
;
TableSelectionMode
targetForTableSel
=
TableSelectionMode
:
:
None
;
bool
handleTableSelection
=
true
;
if
(
!
selectionOff
)
{
frameselection
=
GetFrameSelection
(
)
;
if
(
nsEventStatus_eConsumeNoDefault
!
=
*
aEventStatus
&
&
frameselection
)
{
if
(
frameselection
-
>
MouseDownRecorded
(
)
)
{
nsPoint
pt
=
nsLayoutUtils
:
:
GetEventCoordinatesRelativeTo
(
aEvent
RelativeTo
{
this
}
)
;
offsets
=
GetContentOffsetsFromPoint
(
pt
SKIP_HIDDEN
)
;
handleTableSelection
=
false
;
}
else
{
GetDataForTableSelection
(
frameselection
PresShell
(
)
aEvent
-
>
AsMouseEvent
(
)
getter_AddRefs
(
parentContent
)
&
contentOffsetForTableSel
&
targetForTableSel
)
;
}
}
}
RefPtr
<
nsFrameSelection
>
frameSelection
;
if
(
activeFrame
!
=
this
&
&
activeFrame
-
>
DetermineDisplaySelection
(
)
!
=
nsISelectionController
:
:
SELECTION_OFF
)
{
frameSelection
=
activeFrame
-
>
GetFrameSelection
(
)
;
}
if
(
!
frameSelection
&
&
captureContent
)
{
if
(
Document
*
doc
=
captureContent
-
>
GetComposedDoc
(
)
)
{
mozilla
:
:
PresShell
*
capturingPresShell
=
doc
-
>
GetPresShell
(
)
;
if
(
capturingPresShell
&
&
capturingPresShell
!
=
PresContext
(
)
-
>
GetPresShell
(
)
)
{
frameSelection
=
capturingPresShell
-
>
FrameSelection
(
)
;
}
}
}
if
(
frameSelection
)
{
AutoWeakFrame
wf
(
this
)
;
frameSelection
-
>
SetDragState
(
false
)
;
frameSelection
-
>
StopAutoScrollTimer
(
)
;
if
(
wf
.
IsAlive
(
)
)
{
nsIScrollableFrame
*
scrollFrame
=
nsLayoutUtils
:
:
GetNearestScrollableFrame
(
this
nsLayoutUtils
:
:
SCROLLABLE_SAME_DOC
|
nsLayoutUtils
:
:
SCROLLABLE_INCLUDE_HIDDEN
)
;
if
(
scrollFrame
)
{
scrollFrame
-
>
ScrollSnap
(
)
;
}
}
}
return
selectionOff
?
NS_OK
:
HandleFrameSelection
(
frameselection
offsets
handleTableSelection
contentOffsetForTableSel
targetForTableSel
parentContent
aEvent
aEventStatus
)
;
}
struct
MOZ_STACK_CLASS
FrameContentRange
{
FrameContentRange
(
nsIContent
*
aContent
int32_t
aStart
int32_t
aEnd
)
:
content
(
aContent
)
start
(
aStart
)
end
(
aEnd
)
{
}
nsCOMPtr
<
nsIContent
>
content
;
int32_t
start
;
int32_t
end
;
}
;
static
FrameContentRange
GetRangeForFrame
(
const
nsIFrame
*
aFrame
)
{
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
!
content
)
{
NS_WARNING
(
"
Frame
has
no
content
"
)
;
return
FrameContentRange
(
nullptr
-
1
-
1
)
;
}
LayoutFrameType
type
=
aFrame
-
>
Type
(
)
;
if
(
type
=
=
LayoutFrameType
:
:
Text
)
{
auto
[
offset
offsetEnd
]
=
aFrame
-
>
GetOffsets
(
)
;
return
FrameContentRange
(
content
offset
offsetEnd
)
;
}
if
(
type
=
=
LayoutFrameType
:
:
Br
)
{
nsIContent
*
parent
=
content
-
>
GetParent
(
)
;
const
int32_t
beginOffset
=
parent
-
>
ComputeIndexOf_Deprecated
(
content
)
;
return
FrameContentRange
(
parent
beginOffset
beginOffset
)
;
}
while
(
content
-
>
IsRootOfNativeAnonymousSubtree
(
)
)
{
content
=
content
-
>
GetParent
(
)
;
}
nsIContent
*
parent
=
content
-
>
GetParent
(
)
;
if
(
aFrame
-
>
IsBlockOutside
(
)
|
|
!
parent
)
{
return
FrameContentRange
(
content
0
content
-
>
GetChildCount
(
)
)
;
}
const
int32_t
index
=
parent
-
>
ComputeIndexOf_Deprecated
(
content
)
;
MOZ_ASSERT
(
index
>
=
0
)
;
return
FrameContentRange
(
parent
index
index
+
1
)
;
}
struct
FrameTarget
{
explicit
operator
bool
(
)
const
{
return
!
!
frame
;
}
nsIFrame
*
frame
=
nullptr
;
bool
frameEdge
=
false
;
bool
afterFrame
=
false
;
}
;
static
FrameTarget
GetSelectionClosestFrame
(
nsIFrame
*
aFrame
const
nsPoint
&
aPoint
uint32_t
aFlags
)
;
static
bool
SelfIsSelectable
(
nsIFrame
*
aFrame
uint32_t
aFlags
)
{
if
(
(
aFlags
&
nsIFrame
:
:
SKIP_HIDDEN
)
&
&
!
aFrame
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
)
{
return
false
;
}
return
!
aFrame
-
>
IsGeneratedContentFrame
(
)
&
&
aFrame
-
>
Style
(
)
-
>
UserSelect
(
)
!
=
StyleUserSelect
:
:
None
;
}
static
bool
SelectionDescendToKids
(
nsIFrame
*
aFrame
)
{
if
(
aFrame
-
>
IsTextInputFrame
(
)
|
|
aFrame
-
>
IsListControlFrame
(
)
)
{
MOZ_ASSERT
(
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_INDEPENDENT_SELECTION
)
)
;
return
false
;
}
MOZ_ASSERT_IF
(
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_INDEPENDENT_SELECTION
)
aFrame
-
>
GetParent
(
)
-
>
HasAnyStateBits
(
NS_FRAME_INDEPENDENT_SELECTION
)
)
;
if
(
aFrame
-
>
IsGeneratedContentFrame
(
)
)
{
return
false
;
}
auto
style
=
aFrame
-
>
Style
(
)
-
>
UserSelect
(
)
;
return
style
!
=
StyleUserSelect
:
:
All
&
&
style
!
=
StyleUserSelect
:
:
None
;
}
static
FrameTarget
GetSelectionClosestFrameForChild
(
nsIFrame
*
aChild
const
nsPoint
&
aPoint
uint32_t
aFlags
)
{
nsIFrame
*
parent
=
aChild
-
>
GetParent
(
)
;
if
(
SelectionDescendToKids
(
aChild
)
)
{
nsPoint
pt
=
aPoint
-
aChild
-
>
GetOffsetTo
(
parent
)
;
return
GetSelectionClosestFrame
(
aChild
pt
aFlags
)
;
}
return
FrameTarget
{
aChild
false
false
}
;
}
static
FrameTarget
DrillDownToSelectionFrame
(
nsIFrame
*
aFrame
bool
aEndFrame
uint32_t
aFlags
)
{
if
(
SelectionDescendToKids
(
aFrame
)
)
{
nsIFrame
*
result
=
nullptr
;
nsIFrame
*
frame
=
aFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
!
aEndFrame
)
{
while
(
frame
&
&
(
!
SelfIsSelectable
(
frame
aFlags
)
|
|
frame
-
>
IsEmpty
(
)
)
)
frame
=
frame
-
>
GetNextSibling
(
)
;
if
(
frame
)
result
=
frame
;
}
else
{
while
(
frame
)
{
if
(
!
frame
-
>
IsEmpty
(
)
&
&
SelfIsSelectable
(
frame
aFlags
)
)
result
=
frame
;
frame
=
frame
-
>
GetNextSibling
(
)
;
}
}
if
(
result
)
return
DrillDownToSelectionFrame
(
result
aEndFrame
aFlags
)
;
}
return
FrameTarget
{
aFrame
true
aEndFrame
}
;
}
static
FrameTarget
GetSelectionClosestFrameForLine
(
nsBlockFrame
*
aParent
nsBlockFrame
:
:
LineIterator
aLine
const
nsPoint
&
aPoint
uint32_t
aFlags
)
{
if
(
aLine
=
=
aParent
-
>
LinesEnd
(
)
)
return
DrillDownToSelectionFrame
(
aParent
true
aFlags
)
;
nsIFrame
*
frame
=
aLine
-
>
mFirstChild
;
nsIFrame
*
closestFromIStart
=
nullptr
;
nsIFrame
*
closestFromIEnd
=
nullptr
;
nscoord
closestIStart
=
aLine
-
>
IStart
(
)
closestIEnd
=
aLine
-
>
IEnd
(
)
;
WritingMode
wm
=
aLine
-
>
mWritingMode
;
LogicalPoint
pt
(
wm
aPoint
aLine
-
>
mContainerSize
)
;
bool
canSkipBr
=
false
;
bool
lastFrameWasEditable
=
false
;
for
(
int32_t
n
=
aLine
-
>
GetChildCount
(
)
;
n
;
-
-
n
frame
=
frame
-
>
GetNextSibling
(
)
)
{
if
(
!
SelfIsSelectable
(
frame
aFlags
)
|
|
frame
-
>
IsEmpty
(
)
|
|
(
canSkipBr
&
&
frame
-
>
IsBrFrame
(
)
&
&
lastFrameWasEditable
=
=
frame
-
>
GetContent
(
)
-
>
IsEditable
(
)
)
)
{
continue
;
}
canSkipBr
=
true
;
lastFrameWasEditable
=
frame
-
>
GetContent
(
)
&
&
frame
-
>
GetContent
(
)
-
>
IsEditable
(
)
;
LogicalRect
frameRect
=
LogicalRect
(
wm
frame
-
>
GetRect
(
)
aLine
-
>
mContainerSize
)
;
if
(
pt
.
I
(
wm
)
>
=
frameRect
.
IStart
(
wm
)
)
{
if
(
pt
.
I
(
wm
)
<
frameRect
.
IEnd
(
wm
)
)
{
return
GetSelectionClosestFrameForChild
(
frame
aPoint
aFlags
)
;
}
if
(
frameRect
.
IEnd
(
wm
)
>
=
closestIStart
)
{
closestFromIStart
=
frame
;
closestIStart
=
frameRect
.
IEnd
(
wm
)
;
}
}
else
{
if
(
frameRect
.
IStart
(
wm
)
<
=
closestIEnd
)
{
closestFromIEnd
=
frame
;
closestIEnd
=
frameRect
.
IStart
(
wm
)
;
}
}
}
if
(
!
closestFromIStart
&
&
!
closestFromIEnd
)
{
return
FrameTarget
(
)
;
}
if
(
closestFromIStart
&
&
(
!
closestFromIEnd
|
|
(
abs
(
pt
.
I
(
wm
)
-
closestIStart
)
<
=
abs
(
pt
.
I
(
wm
)
-
closestIEnd
)
)
)
)
{
return
GetSelectionClosestFrameForChild
(
closestFromIStart
aPoint
aFlags
)
;
}
return
GetSelectionClosestFrameForChild
(
closestFromIEnd
aPoint
aFlags
)
;
}
static
FrameTarget
GetSelectionClosestFrameForBlock
(
nsIFrame
*
aFrame
const
nsPoint
&
aPoint
uint32_t
aFlags
)
{
nsBlockFrame
*
bf
=
do_QueryFrame
(
aFrame
)
;
if
(
!
bf
)
{
return
FrameTarget
(
)
;
}
nsBlockFrame
:
:
LineIterator
end
=
bf
-
>
LinesEnd
(
)
;
nsBlockFrame
:
:
LineIterator
curLine
=
bf
-
>
LinesBegin
(
)
;
nsBlockFrame
:
:
LineIterator
closestLine
=
end
;
if
(
curLine
!
=
end
)
{
WritingMode
wm
=
curLine
-
>
mWritingMode
;
LogicalPoint
pt
(
wm
aPoint
curLine
-
>
mContainerSize
)
;
do
{
nscoord
BCoord
=
pt
.
B
(
wm
)
-
curLine
-
>
BStart
(
)
;
nscoord
BSize
=
curLine
-
>
BSize
(
)
;
if
(
BCoord
>
=
0
&
&
BCoord
<
BSize
)
{
closestLine
=
curLine
;
break
;
}
if
(
BCoord
<
0
)
break
;
+
+
curLine
;
}
while
(
curLine
!
=
end
)
;
if
(
closestLine
=
=
end
)
{
nsBlockFrame
:
:
LineIterator
prevLine
=
curLine
.
prev
(
)
;
nsBlockFrame
:
:
LineIterator
nextLine
=
curLine
;
while
(
nextLine
!
=
end
&
&
nextLine
-
>
IsEmpty
(
)
)
+
+
nextLine
;
while
(
prevLine
!
=
end
&
&
prevLine
-
>
IsEmpty
(
)
)
-
-
prevLine
;
int32_t
dragOutOfFrame
=
Preferences
:
:
GetInt
(
"
browser
.
drag_out_of_frame_style
"
)
;
if
(
prevLine
=
=
end
)
{
if
(
dragOutOfFrame
=
=
1
|
|
nextLine
=
=
end
)
return
DrillDownToSelectionFrame
(
aFrame
false
aFlags
)
;
closestLine
=
nextLine
;
}
else
if
(
nextLine
=
=
end
)
{
if
(
dragOutOfFrame
=
=
1
)
return
DrillDownToSelectionFrame
(
aFrame
true
aFlags
)
;
closestLine
=
prevLine
;
}
else
{
if
(
pt
.
B
(
wm
)
-
prevLine
-
>
BEnd
(
)
<
nextLine
-
>
BStart
(
)
-
pt
.
B
(
wm
)
)
closestLine
=
prevLine
;
else
closestLine
=
nextLine
;
}
}
}
do
{
if
(
auto
target
=
GetSelectionClosestFrameForLine
(
bf
closestLine
aPoint
aFlags
)
)
{
return
target
;
}
+
+
closestLine
;
}
while
(
closestLine
!
=
end
)
;
return
DrillDownToSelectionFrame
(
aFrame
true
aFlags
)
;
}
static
bool
UseFrameEdge
(
nsIFrame
*
aFrame
)
{
if
(
aFrame
-
>
IsFlexOrGridContainer
(
)
|
|
aFrame
-
>
IsTableFrame
(
)
)
{
return
true
;
}
const
nsImageFrame
*
image
=
do_QueryFrame
(
aFrame
)
;
if
(
image
&
&
!
aFrame
-
>
GetContent
(
)
-
>
IsEditable
(
)
)
{
return
true
;
}
return
false
;
}
static
FrameTarget
LastResortFrameTargetForFrame
(
nsIFrame
*
aFrame
const
nsPoint
&
aPoint
)
{
if
(
!
UseFrameEdge
(
aFrame
)
)
{
return
{
aFrame
false
false
}
;
}
const
auto
&
rect
=
aFrame
-
>
GetRectRelativeToSelf
(
)
;
nscoord
reference
;
nscoord
middle
;
if
(
aFrame
-
>
GetWritingMode
(
)
.
IsVertical
(
)
)
{
reference
=
aPoint
.
y
;
middle
=
rect
.
Height
(
)
/
2
;
}
else
{
reference
=
aPoint
.
x
;
middle
=
rect
.
Width
(
)
/
2
;
}
const
bool
afterFrame
=
reference
>
middle
;
return
{
aFrame
true
afterFrame
}
;
}
static
FrameTarget
GetSelectionClosestFrame
(
nsIFrame
*
aFrame
const
nsPoint
&
aPoint
uint32_t
aFlags
)
{
if
(
auto
target
=
GetSelectionClosestFrameForBlock
(
aFrame
aPoint
aFlags
)
)
{
return
target
;
}
if
(
nsIFrame
*
kid
=
aFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
)
{
nsIFrame
:
:
FrameWithDistance
closest
=
{
nullptr
nscoord_MAX
nscoord_MAX
}
;
for
(
;
kid
;
kid
=
kid
-
>
GetNextSibling
(
)
)
{
if
(
!
SelfIsSelectable
(
kid
aFlags
)
|
|
kid
-
>
IsEmpty
(
)
)
continue
;
kid
-
>
FindCloserFrameForSelection
(
aPoint
&
closest
)
;
}
if
(
closest
.
mFrame
)
{
if
(
SVGUtils
:
:
IsInSVGTextSubtree
(
closest
.
mFrame
)
)
return
FrameTarget
{
closest
.
mFrame
false
false
}
;
return
GetSelectionClosestFrameForChild
(
closest
.
mFrame
aPoint
aFlags
)
;
}
}
return
LastResortFrameTargetForFrame
(
aFrame
aPoint
)
;
}
static
nsIFrame
:
:
ContentOffsets
OffsetsForSingleFrame
(
nsIFrame
*
aFrame
const
nsPoint
&
aPoint
)
{
nsIFrame
:
:
ContentOffsets
offsets
;
FrameContentRange
range
=
GetRangeForFrame
(
aFrame
)
;
offsets
.
content
=
range
.
content
;
if
(
aFrame
-
>
GetNextContinuation
(
)
|
|
aFrame
-
>
GetPrevContinuation
(
)
)
{
offsets
.
offset
=
range
.
start
;
offsets
.
secondaryOffset
=
range
.
end
;
offsets
.
associate
=
CARET_ASSOCIATE_AFTER
;
return
offsets
;
}
nsRect
rect
(
nsPoint
(
0
0
)
aFrame
-
>
GetSize
(
)
)
;
bool
isBlock
=
!
aFrame
-
>
StyleDisplay
(
)
-
>
IsInlineFlow
(
)
;
bool
isRtl
=
(
aFrame
-
>
StyleVisibility
(
)
-
>
mDirection
=
=
StyleDirection
:
:
Rtl
)
;
if
(
(
isBlock
&
&
rect
.
y
<
aPoint
.
y
)
|
|
(
!
isBlock
&
&
(
(
isRtl
&
&
rect
.
x
+
rect
.
width
/
2
>
aPoint
.
x
)
|
|
(
!
isRtl
&
&
rect
.
x
+
rect
.
width
/
2
<
aPoint
.
x
)
)
)
)
{
offsets
.
offset
=
range
.
end
;
if
(
rect
.
Contains
(
aPoint
)
)
offsets
.
secondaryOffset
=
range
.
start
;
else
offsets
.
secondaryOffset
=
range
.
end
;
}
else
{
offsets
.
offset
=
range
.
start
;
if
(
rect
.
Contains
(
aPoint
)
)
offsets
.
secondaryOffset
=
range
.
end
;
else
offsets
.
secondaryOffset
=
range
.
start
;
}
offsets
.
associate
=
offsets
.
offset
=
=
range
.
start
?
CARET_ASSOCIATE_AFTER
:
CARET_ASSOCIATE_BEFORE
;
return
offsets
;
}
static
nsIFrame
*
AdjustFrameForSelectionStyles
(
nsIFrame
*
aFrame
)
{
nsIFrame
*
adjustedFrame
=
aFrame
;
for
(
nsIFrame
*
frame
=
aFrame
;
frame
;
frame
=
frame
-
>
GetParent
(
)
)
{
auto
userSelect
=
frame
-
>
Style
(
)
-
>
UserSelect
(
)
;
if
(
userSelect
!
=
StyleUserSelect
:
:
Auto
&
&
userSelect
!
=
StyleUserSelect
:
:
All
)
{
break
;
}
if
(
userSelect
=
=
StyleUserSelect
:
:
All
|
|
frame
-
>
IsGeneratedContentFrame
(
)
)
{
adjustedFrame
=
frame
;
}
}
return
adjustedFrame
;
}
nsIFrame
:
:
ContentOffsets
nsIFrame
:
:
GetContentOffsetsFromPoint
(
const
nsPoint
&
aPoint
uint32_t
aFlags
)
{
nsIFrame
*
adjustedFrame
;
if
(
aFlags
&
IGNORE_SELECTION_STYLE
)
{
adjustedFrame
=
this
;
}
else
{
adjustedFrame
=
AdjustFrameForSelectionStyles
(
this
)
;
if
(
adjustedFrame
-
>
Style
(
)
-
>
UserSelect
(
)
=
=
StyleUserSelect
:
:
All
)
{
nsPoint
adjustedPoint
=
aPoint
+
GetOffsetTo
(
adjustedFrame
)
;
return
OffsetsForSingleFrame
(
adjustedFrame
adjustedPoint
)
;
}
if
(
adjustedFrame
!
=
this
)
{
adjustedFrame
=
adjustedFrame
-
>
GetParent
(
)
;
}
}
nsPoint
adjustedPoint
=
aPoint
+
GetOffsetTo
(
adjustedFrame
)
;
FrameTarget
closest
=
GetSelectionClosestFrame
(
adjustedFrame
adjustedPoint
aFlags
)
;
if
(
closest
.
frameEdge
)
{
ContentOffsets
offsets
;
FrameContentRange
range
=
GetRangeForFrame
(
closest
.
frame
)
;
offsets
.
content
=
range
.
content
;
if
(
closest
.
afterFrame
)
offsets
.
offset
=
range
.
end
;
else
offsets
.
offset
=
range
.
start
;
offsets
.
secondaryOffset
=
offsets
.
offset
;
offsets
.
associate
=
offsets
.
offset
=
=
range
.
start
?
CARET_ASSOCIATE_AFTER
:
CARET_ASSOCIATE_BEFORE
;
return
offsets
;
}
nsPoint
pt
;
if
(
closest
.
frame
!
=
this
)
{
if
(
SVGUtils
:
:
IsInSVGTextSubtree
(
closest
.
frame
)
)
{
pt
=
nsLayoutUtils
:
:
TransformAncestorPointToFrame
(
RelativeTo
{
closest
.
frame
}
aPoint
RelativeTo
{
this
}
)
;
}
else
{
pt
=
aPoint
-
closest
.
frame
-
>
GetOffsetTo
(
this
)
;
}
}
else
{
pt
=
aPoint
;
}
return
closest
.
frame
-
>
CalcContentOffsetsFromFramePoint
(
pt
)
;
}
nsIFrame
:
:
ContentOffsets
nsIFrame
:
:
CalcContentOffsetsFromFramePoint
(
const
nsPoint
&
aPoint
)
{
return
OffsetsForSingleFrame
(
this
aPoint
)
;
}
bool
nsIFrame
:
:
AssociateImage
(
const
StyleImage
&
aImage
)
{
imgRequestProxy
*
req
=
aImage
.
GetImageRequest
(
)
;
if
(
!
req
)
{
return
false
;
}
mozilla
:
:
css
:
:
ImageLoader
*
loader
=
PresContext
(
)
-
>
Document
(
)
-
>
StyleImageLoader
(
)
;
loader
-
>
AssociateRequestToFrame
(
req
this
)
;
return
true
;
}
void
nsIFrame
:
:
DisassociateImage
(
const
StyleImage
&
aImage
)
{
imgRequestProxy
*
req
=
aImage
.
GetImageRequest
(
)
;
if
(
!
req
)
{
return
;
}
mozilla
:
:
css
:
:
ImageLoader
*
loader
=
PresContext
(
)
-
>
Document
(
)
-
>
StyleImageLoader
(
)
;
loader
-
>
DisassociateRequestFromFrame
(
req
this
)
;
}
StyleImageRendering
nsIFrame
:
:
UsedImageRendering
(
)
const
{
ComputedStyle
*
style
;
if
(
nsCSSRendering
:
:
IsCanvasFrame
(
this
)
)
{
style
=
nsCSSRendering
:
:
FindBackground
(
this
)
;
}
else
{
style
=
Style
(
)
;
}
return
style
-
>
StyleVisibility
(
)
-
>
mImageRendering
;
}
StyleTouchAction
nsIFrame
:
:
UsedTouchAction
(
)
const
{
if
(
IsFrameOfType
(
eLineParticipant
)
)
{
return
StyleTouchAction
:
:
AUTO
;
}
auto
&
disp
=
*
StyleDisplay
(
)
;
if
(
disp
.
IsInternalTableStyleExceptCell
(
)
)
{
return
StyleTouchAction
:
:
AUTO
;
}
return
disp
.
mTouchAction
;
}
Maybe
<
nsIFrame
:
:
Cursor
>
nsIFrame
:
:
GetCursor
(
const
nsPoint
&
)
{
StyleCursorKind
kind
=
StyleUI
(
)
-
>
Cursor
(
)
.
keyword
;
if
(
kind
=
=
StyleCursorKind
:
:
Auto
)
{
kind
=
(
mContent
&
&
mContent
-
>
IsEditable
(
)
)
?
StyleCursorKind
:
:
Text
:
StyleCursorKind
:
:
Default
;
}
if
(
kind
=
=
StyleCursorKind
:
:
Text
&
&
GetWritingMode
(
)
.
IsVertical
(
)
)
{
kind
=
StyleCursorKind
:
:
VerticalText
;
}
return
Some
(
Cursor
{
kind
AllowCustomCursorImage
:
:
Yes
}
)
;
}
void
nsIFrame
:
:
MarkIntrinsicISizesDirty
(
)
{
if
(
:
:
IsXULBoxWrapped
(
this
)
)
{
nsBoxLayoutMetrics
*
metrics
=
BoxMetrics
(
)
;
XULSizeNeedsRecalc
(
metrics
-
>
mPrefSize
)
;
XULSizeNeedsRecalc
(
metrics
-
>
mMinSize
)
;
XULSizeNeedsRecalc
(
metrics
-
>
mMaxSize
)
;
XULSizeNeedsRecalc
(
metrics
-
>
mBlockPrefSize
)
;
XULSizeNeedsRecalc
(
metrics
-
>
mBlockMinSize
)
;
XULCoordNeedsRecalc
(
metrics
-
>
mFlex
)
;
XULCoordNeedsRecalc
(
metrics
-
>
mAscent
)
;
}
if
(
IsFlexItem
(
)
)
{
nsFlexContainerFrame
:
:
MarkCachedFlexMeasurementsDirty
(
this
)
;
}
if
(
HasAnyStateBits
(
NS_FRAME_FONT_INFLATION_FLOW_ROOT
)
)
{
nsFontInflationData
:
:
MarkFontInflationDataTextDirty
(
this
)
;
}
if
(
StaticPrefs
:
:
layout_css_grid_item_baxis_measurement_enabled
(
)
)
{
RemoveProperty
(
nsGridContainerFrame
:
:
CachedBAxisMeasurement
:
:
Prop
(
)
)
;
}
}
void
nsIFrame
:
:
MarkSubtreeDirty
(
)
{
if
(
HasAnyStateBits
(
NS_FRAME_IS_DIRTY
)
)
{
return
;
}
AddStateBits
(
NS_FRAME_IS_DIRTY
)
;
AutoTArray
<
nsIFrame
*
32
>
stack
;
for
(
const
auto
&
childLists
:
ChildLists
(
)
)
{
for
(
nsIFrame
*
kid
:
childLists
.
mList
)
{
stack
.
AppendElement
(
kid
)
;
}
}
while
(
!
stack
.
IsEmpty
(
)
)
{
nsIFrame
*
f
=
stack
.
PopLastElement
(
)
;
if
(
f
-
>
HasAnyStateBits
(
NS_FRAME_IS_DIRTY
)
|
|
f
-
>
IsTableColGroupFrame
(
)
|
|
f
-
>
IsXULBoxFrame
(
)
)
{
continue
;
}
f
-
>
AddStateBits
(
NS_FRAME_IS_DIRTY
)
;
for
(
const
auto
&
childLists
:
f
-
>
ChildLists
(
)
)
{
for
(
nsIFrame
*
kid
:
childLists
.
mList
)
{
stack
.
AppendElement
(
kid
)
;
}
}
}
}
nscoord
nsIFrame
:
:
GetMinISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
result
=
0
;
DISPLAY_MIN_INLINE_SIZE
(
this
result
)
;
return
result
;
}
nscoord
nsIFrame
:
:
GetPrefISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
result
=
0
;
DISPLAY_PREF_INLINE_SIZE
(
this
result
)
;
return
result
;
}
void
nsIFrame
:
:
AddInlineMinISize
(
gfxContext
*
aRenderingContext
nsIFrame
:
:
InlineMinISizeData
*
aData
)
{
nscoord
isize
=
nsLayoutUtils
:
:
IntrinsicForContainer
(
aRenderingContext
this
IntrinsicISizeType
:
:
MinISize
)
;
aData
-
>
DefaultAddInlineMinISize
(
this
isize
)
;
}
void
nsIFrame
:
:
AddInlinePrefISize
(
gfxContext
*
aRenderingContext
nsIFrame
:
:
InlinePrefISizeData
*
aData
)
{
nscoord
isize
=
nsLayoutUtils
:
:
IntrinsicForContainer
(
aRenderingContext
this
IntrinsicISizeType
:
:
PrefISize
)
;
aData
-
>
DefaultAddInlinePrefISize
(
isize
)
;
}
void
nsIFrame
:
:
InlineMinISizeData
:
:
DefaultAddInlineMinISize
(
nsIFrame
*
aFrame
nscoord
aISize
bool
aAllowBreak
)
{
auto
parent
=
aFrame
-
>
GetParent
(
)
;
MOZ_ASSERT
(
parent
"
Must
have
a
parent
if
we
get
here
!
"
)
;
const
bool
mayBreak
=
aAllowBreak
&
&
!
aFrame
-
>
CanContinueTextRun
(
)
&
&
!
parent
-
>
Style
(
)
-
>
ShouldSuppressLineBreak
(
)
&
&
parent
-
>
StyleText
(
)
-
>
WhiteSpaceCanWrap
(
parent
)
;
if
(
mayBreak
)
{
OptionallyBreak
(
)
;
}
mTrailingWhitespace
=
0
;
mSkipWhitespace
=
false
;
mCurrentLine
+
=
aISize
;
mAtStartOfLine
=
false
;
if
(
mayBreak
)
{
OptionallyBreak
(
)
;
}
}
void
nsIFrame
:
:
InlinePrefISizeData
:
:
DefaultAddInlinePrefISize
(
nscoord
aISize
)
{
mCurrentLine
=
NSCoordSaturatingAdd
(
mCurrentLine
aISize
)
;
mTrailingWhitespace
=
0
;
mSkipWhitespace
=
false
;
mLineIsEmpty
=
false
;
}
void
nsIFrame
:
:
InlineMinISizeData
:
:
ForceBreak
(
)
{
mCurrentLine
-
=
mTrailingWhitespace
;
mPrevLines
=
std
:
:
max
(
mPrevLines
mCurrentLine
)
;
mCurrentLine
=
mTrailingWhitespace
=
0
;
for
(
uint32_t
i
=
0
i_end
=
mFloats
.
Length
(
)
;
i
!
=
i_end
;
+
+
i
)
{
nscoord
float_min
=
mFloats
[
i
]
.
Width
(
)
;
if
(
float_min
>
mPrevLines
)
mPrevLines
=
float_min
;
}
mFloats
.
Clear
(
)
;
mSkipWhitespace
=
true
;
}
void
nsIFrame
:
:
InlineMinISizeData
:
:
OptionallyBreak
(
nscoord
aHyphenWidth
)
{
if
(
mCurrentLine
+
aHyphenWidth
<
0
|
|
mAtStartOfLine
)
return
;
mCurrentLine
+
=
aHyphenWidth
;
ForceBreak
(
)
;
}
void
nsIFrame
:
:
InlinePrefISizeData
:
:
ForceBreak
(
StyleClear
aBreakType
)
{
MOZ_ASSERT
(
aBreakType
=
=
StyleClear
:
:
None
|
|
aBreakType
=
=
StyleClear
:
:
Both
|
|
aBreakType
=
=
StyleClear
:
:
Left
|
|
aBreakType
=
=
StyleClear
:
:
Right
"
Must
be
a
physical
break
type
"
)
;
if
(
mFloats
.
Length
(
)
!
=
0
&
&
aBreakType
!
=
StyleClear
:
:
None
)
{
nscoord
floats_done
=
0
floats_cur_left
=
0
floats_cur_right
=
0
;
for
(
uint32_t
i
=
0
i_end
=
mFloats
.
Length
(
)
;
i
!
=
i_end
;
+
+
i
)
{
const
FloatInfo
&
floatInfo
=
mFloats
[
i
]
;
const
nsStyleDisplay
*
floatDisp
=
floatInfo
.
Frame
(
)
-
>
StyleDisplay
(
)
;
StyleClear
breakType
=
floatDisp
-
>
mBreakType
;
if
(
breakType
=
=
StyleClear
:
:
Left
|
|
breakType
=
=
StyleClear
:
:
Right
|
|
breakType
=
=
StyleClear
:
:
Both
)
{
nscoord
floats_cur
=
NSCoordSaturatingAdd
(
floats_cur_left
floats_cur_right
)
;
if
(
floats_cur
>
floats_done
)
{
floats_done
=
floats_cur
;
}
if
(
breakType
!
=
StyleClear
:
:
Right
)
{
floats_cur_left
=
0
;
}
if
(
breakType
!
=
StyleClear
:
:
Left
)
{
floats_cur_right
=
0
;
}
}
StyleFloat
floatStyle
=
floatDisp
-
>
mFloat
;
nscoord
&
floats_cur
=
floatStyle
=
=
StyleFloat
:
:
Left
?
floats_cur_left
:
floats_cur_right
;
nscoord
floatWidth
=
floatInfo
.
Width
(
)
;
floats_cur
=
NSCoordSaturatingAdd
(
floats_cur
std
:
:
max
(
0
floatWidth
)
)
;
}
nscoord
floats_cur
=
NSCoordSaturatingAdd
(
floats_cur_left
floats_cur_right
)
;
if
(
floats_cur
>
floats_done
)
floats_done
=
floats_cur
;
mCurrentLine
=
NSCoordSaturatingAdd
(
mCurrentLine
floats_done
)
;
if
(
aBreakType
=
=
StyleClear
:
:
Both
)
{
mFloats
.
Clear
(
)
;
}
else
{
nsTArray
<
FloatInfo
>
newFloats
;
MOZ_ASSERT
(
aBreakType
=
=
StyleClear
:
:
Left
|
|
aBreakType
=
=
StyleClear
:
:
Right
"
Other
values
should
have
been
handled
in
other
branches
"
)
;
StyleFloat
clearFloatType
=
aBreakType
=
=
StyleClear
:
:
Left
?
StyleFloat
:
:
Left
:
StyleFloat
:
:
Right
;
for
(
FloatInfo
&
floatInfo
:
Reversed
(
mFloats
)
)
{
const
nsStyleDisplay
*
floatDisp
=
floatInfo
.
Frame
(
)
-
>
StyleDisplay
(
)
;
if
(
floatDisp
-
>
mFloat
!
=
clearFloatType
)
{
newFloats
.
AppendElement
(
floatInfo
)
;
}
else
{
StyleClear
floatBreakType
=
floatDisp
-
>
mBreakType
;
if
(
floatBreakType
!
=
aBreakType
&
&
floatBreakType
!
=
StyleClear
:
:
None
)
{
break
;
}
}
}
newFloats
.
Reverse
(
)
;
mFloats
=
std
:
:
move
(
newFloats
)
;
}
}
mCurrentLine
=
NSCoordSaturatingSubtract
(
mCurrentLine
mTrailingWhitespace
nscoord_MAX
)
;
mPrevLines
=
std
:
:
max
(
mPrevLines
mCurrentLine
)
;
mCurrentLine
=
mTrailingWhitespace
=
0
;
mSkipWhitespace
=
true
;
mLineIsEmpty
=
true
;
}
static
nscoord
ResolveMargin
(
const
LengthPercentageOrAuto
&
aStyle
nscoord
aPercentageBasis
)
{
if
(
aStyle
.
IsAuto
(
)
)
{
return
nscoord
(
0
)
;
}
return
nsLayoutUtils
:
:
ResolveToLength
<
false
>
(
aStyle
.
AsLengthPercentage
(
)
aPercentageBasis
)
;
}
static
nscoord
ResolvePadding
(
const
LengthPercentage
&
aStyle
nscoord
aPercentageBasis
)
{
return
nsLayoutUtils
:
:
ResolveToLength
<
true
>
(
aStyle
aPercentageBasis
)
;
}
static
nsIFrame
:
:
IntrinsicSizeOffsetData
IntrinsicSizeOffsets
(
nsIFrame
*
aFrame
nscoord
aPercentageBasis
bool
aForISize
)
{
nsIFrame
:
:
IntrinsicSizeOffsetData
result
;
WritingMode
wm
=
aFrame
-
>
GetWritingMode
(
)
;
const
auto
&
margin
=
aFrame
-
>
StyleMargin
(
)
-
>
mMargin
;
bool
verticalAxis
=
aForISize
=
=
wm
.
IsVertical
(
)
;
if
(
verticalAxis
)
{
result
.
margin
+
=
ResolveMargin
(
margin
.
Get
(
eSideTop
)
aPercentageBasis
)
;
result
.
margin
+
=
ResolveMargin
(
margin
.
Get
(
eSideBottom
)
aPercentageBasis
)
;
}
else
{
result
.
margin
+
=
ResolveMargin
(
margin
.
Get
(
eSideLeft
)
aPercentageBasis
)
;
result
.
margin
+
=
ResolveMargin
(
margin
.
Get
(
eSideRight
)
aPercentageBasis
)
;
}
const
auto
&
padding
=
aFrame
-
>
StylePadding
(
)
-
>
mPadding
;
if
(
verticalAxis
)
{
result
.
padding
+
=
ResolvePadding
(
padding
.
Get
(
eSideTop
)
aPercentageBasis
)
;
result
.
padding
+
=
ResolvePadding
(
padding
.
Get
(
eSideBottom
)
aPercentageBasis
)
;
}
else
{
result
.
padding
+
=
ResolvePadding
(
padding
.
Get
(
eSideLeft
)
aPercentageBasis
)
;
result
.
padding
+
=
ResolvePadding
(
padding
.
Get
(
eSideRight
)
aPercentageBasis
)
;
}
const
nsStyleBorder
*
styleBorder
=
aFrame
-
>
StyleBorder
(
)
;
if
(
verticalAxis
)
{
result
.
border
+
=
styleBorder
-
>
GetComputedBorderWidth
(
eSideTop
)
;
result
.
border
+
=
styleBorder
-
>
GetComputedBorderWidth
(
eSideBottom
)
;
}
else
{
result
.
border
+
=
styleBorder
-
>
GetComputedBorderWidth
(
eSideLeft
)
;
result
.
border
+
=
styleBorder
-
>
GetComputedBorderWidth
(
eSideRight
)
;
}
const
nsStyleDisplay
*
disp
=
aFrame
-
>
StyleDisplay
(
)
;
if
(
aFrame
-
>
IsThemed
(
disp
)
)
{
nsPresContext
*
presContext
=
aFrame
-
>
PresContext
(
)
;
LayoutDeviceIntMargin
border
=
presContext
-
>
Theme
(
)
-
>
GetWidgetBorder
(
presContext
-
>
DeviceContext
(
)
aFrame
disp
-
>
EffectiveAppearance
(
)
)
;
result
.
border
=
presContext
-
>
DevPixelsToAppUnits
(
verticalAxis
?
border
.
TopBottom
(
)
:
border
.
LeftRight
(
)
)
;
LayoutDeviceIntMargin
padding
;
if
(
presContext
-
>
Theme
(
)
-
>
GetWidgetPadding
(
presContext
-
>
DeviceContext
(
)
aFrame
disp
-
>
EffectiveAppearance
(
)
&
padding
)
)
{
result
.
padding
=
presContext
-
>
DevPixelsToAppUnits
(
verticalAxis
?
padding
.
TopBottom
(
)
:
padding
.
LeftRight
(
)
)
;
}
}
return
result
;
}
nsIFrame
:
:
IntrinsicSizeOffsetData
nsIFrame
:
:
IntrinsicISizeOffsets
(
nscoord
aPercentageBasis
)
{
return
IntrinsicSizeOffsets
(
this
aPercentageBasis
true
)
;
}
nsIFrame
:
:
IntrinsicSizeOffsetData
nsIFrame
:
:
IntrinsicBSizeOffsets
(
nscoord
aPercentageBasis
)
{
return
IntrinsicSizeOffsets
(
this
aPercentageBasis
false
)
;
}
IntrinsicSize
nsIFrame
:
:
GetIntrinsicSize
(
)
{
return
IntrinsicSize
(
)
;
}
AspectRatio
nsIFrame
:
:
GetAspectRatio
(
)
const
{
if
(
!
IsFrameOfType
(
eSupportsAspectRatio
)
)
{
return
AspectRatio
(
)
;
}
const
StyleAspectRatio
&
aspectRatio
=
StylePosition
(
)
-
>
mAspectRatio
;
if
(
!
aspectRatio
.
BehavesAsAuto
(
)
)
{
return
aspectRatio
.
ratio
.
AsRatio
(
)
.
ToLayoutRatio
(
UseBoxSizing
:
:
Yes
)
;
}
if
(
auto
intrinsicRatio
=
GetIntrinsicRatio
(
)
)
{
return
intrinsicRatio
;
}
if
(
aspectRatio
.
HasRatio
(
)
)
{
return
aspectRatio
.
ratio
.
AsRatio
(
)
.
ToLayoutRatio
(
UseBoxSizing
:
:
No
)
;
}
return
AspectRatio
(
)
;
}
AspectRatio
nsIFrame
:
:
GetIntrinsicRatio
(
)
const
{
return
AspectRatio
(
)
;
}
static
bool
ShouldApplyAutomaticMinimumOnInlineAxis
(
WritingMode
aWM
const
nsStyleDisplay
*
aDisplay
const
nsStylePosition
*
aPosition
)
{
return
!
aDisplay
-
>
IsScrollableOverflow
(
)
&
&
aPosition
-
>
MinISize
(
aWM
)
.
IsAuto
(
)
;
}
struct
MinMaxSize
{
nscoord
mMinSize
=
0
;
nscoord
mMaxSize
=
NS_UNCONSTRAINEDSIZE
;
nscoord
ClampSizeToMinAndMax
(
nscoord
aSize
)
const
{
return
NS_CSS_MINMAX
(
aSize
mMinSize
mMaxSize
)
;
}
}
;
static
MinMaxSize
ComputeTransferredMinMaxInlineSize
(
const
WritingMode
aWM
const
AspectRatio
&
aAspectRatio
const
MinMaxSize
&
aMinMaxBSize
const
LogicalSize
&
aBoxSizingAdjustment
)
{
MinMaxSize
transferredISize
;
if
(
aMinMaxBSize
.
mMinSize
>
0
)
{
transferredISize
.
mMinSize
=
aAspectRatio
.
ComputeRatioDependentSize
(
LogicalAxis
:
:
eLogicalAxisInline
aWM
aMinMaxBSize
.
mMinSize
aBoxSizingAdjustment
)
;
}
if
(
aMinMaxBSize
.
mMaxSize
!
=
NS_UNCONSTRAINEDSIZE
)
{
transferredISize
.
mMaxSize
=
aAspectRatio
.
ComputeRatioDependentSize
(
LogicalAxis
:
:
eLogicalAxisInline
aWM
aMinMaxBSize
.
mMaxSize
aBoxSizingAdjustment
)
;
}
transferredISize
.
mMaxSize
=
std
:
:
max
(
transferredISize
.
mMinSize
transferredISize
.
mMaxSize
)
;
return
transferredISize
;
}
nsIFrame
:
:
SizeComputationResult
nsIFrame
:
:
ComputeSize
(
gfxContext
*
aRenderingContext
WritingMode
aWM
const
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
LogicalSize
&
aMargin
const
LogicalSize
&
aBorderPadding
const
StyleSizeOverrides
&
aSizeOverrides
ComputeSizeFlags
aFlags
)
{
MOZ_ASSERT
(
!
GetIntrinsicRatio
(
)
"
Please
override
this
method
and
call
"
"
nsContainerFrame
:
:
ComputeSizeWithIntrinsicDimensions
instead
.
"
)
;
LogicalSize
result
=
ComputeAutoSize
(
aRenderingContext
aWM
aCBSize
aAvailableISize
aMargin
aBorderPadding
aSizeOverrides
aFlags
)
;
const
nsStylePosition
*
stylePos
=
StylePosition
(
)
;
const
nsStyleDisplay
*
disp
=
StyleDisplay
(
)
;
auto
aspectRatioUsage
=
AspectRatioUsage
:
:
None
;
const
auto
boxSizingAdjust
=
stylePos
-
>
mBoxSizing
=
=
StyleBoxSizing
:
:
Border
?
aBorderPadding
:
LogicalSize
(
aWM
)
;
nscoord
boxSizingToMarginEdgeISize
=
aMargin
.
ISize
(
aWM
)
+
aBorderPadding
.
ISize
(
aWM
)
-
boxSizingAdjust
.
ISize
(
aWM
)
;
const
auto
&
styleISize
=
aSizeOverrides
.
mStyleISize
?
*
aSizeOverrides
.
mStyleISize
:
stylePos
-
>
ISize
(
aWM
)
;
const
auto
&
styleBSize
=
aSizeOverrides
.
mStyleBSize
?
*
aSizeOverrides
.
mStyleBSize
:
stylePos
-
>
BSize
(
aWM
)
;
const
auto
&
aspectRatio
=
aSizeOverrides
.
mAspectRatio
?
*
aSizeOverrides
.
mAspectRatio
:
GetAspectRatio
(
)
;
auto
parentFrame
=
GetParent
(
)
;
auto
alignCB
=
parentFrame
;
bool
isGridItem
=
IsGridItem
(
)
;
if
(
parentFrame
&
&
parentFrame
-
>
IsTableWrapperFrame
(
)
&
&
IsTableFrame
(
)
)
{
auto
tableWrapper
=
GetParent
(
)
;
auto
grandParent
=
tableWrapper
-
>
GetParent
(
)
;
isGridItem
=
grandParent
-
>
IsGridContainerFrame
(
)
&
&
!
tableWrapper
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
;
if
(
isGridItem
)
{
alignCB
=
grandParent
;
}
}
const
bool
isFlexItem
=
IsFlexItem
(
)
&
&
!
parentFrame
-
>
HasAnyStateBits
(
NS_STATE_FLEX_IS_EMULATING_LEGACY_BOX
)
;
LogicalAxis
flexMainAxis
=
eLogicalAxisInline
;
if
(
isFlexItem
)
{
flexMainAxis
=
nsFlexContainerFrame
:
:
IsItemInlineAxisMainAxis
(
this
)
?
eLogicalAxisInline
:
eLogicalAxisBlock
;
}
const
bool
isOrthogonal
=
aWM
.
IsOrthogonalTo
(
alignCB
-
>
GetWritingMode
(
)
)
;
const
bool
isAutoISize
=
styleISize
.
IsAuto
(
)
;
const
bool
isAutoBSize
=
nsLayoutUtils
:
:
IsAutoBSize
(
styleBSize
aCBSize
.
BSize
(
aWM
)
)
|
|
aFlags
.
contains
(
ComputeSizeFlag
:
:
UseAutoBSize
)
;
if
(
!
isAutoISize
)
{
auto
iSizeResult
=
ComputeISizeValue
(
aRenderingContext
aWM
aCBSize
boxSizingAdjust
boxSizingToMarginEdgeISize
styleISize
aSizeOverrides
aFlags
)
;
result
.
ISize
(
aWM
)
=
iSizeResult
.
mISize
;
aspectRatioUsage
=
iSizeResult
.
mAspectRatioUsage
;
}
else
if
(
MOZ_UNLIKELY
(
isGridItem
)
&
&
!
IsTrueOverflowContainer
(
)
)
{
bool
stretch
=
false
;
bool
mayUseAspectRatio
=
aspectRatio
&
&
!
isAutoBSize
;
if
(
!
aFlags
.
contains
(
ComputeSizeFlag
:
:
ShrinkWrap
)
&
&
!
StyleMargin
(
)
-
>
HasInlineAxisAuto
(
aWM
)
&
&
!
alignCB
-
>
IsMasonry
(
isOrthogonal
?
eLogicalAxisBlock
:
eLogicalAxisInline
)
)
{
auto
inlineAxisAlignment
=
isOrthogonal
?
StylePosition
(
)
-
>
UsedAlignSelf
(
alignCB
-
>
Style
(
)
)
.
_0
:
StylePosition
(
)
-
>
UsedJustifySelf
(
alignCB
-
>
Style
(
)
)
.
_0
;
stretch
=
inlineAxisAlignment
=
=
StyleAlignFlags
:
:
STRETCH
|
|
(
inlineAxisAlignment
=
=
StyleAlignFlags
:
:
NORMAL
&
&
!
mayUseAspectRatio
)
;
}
if
(
!
stretch
&
&
mayUseAspectRatio
)
{
auto
bSize
=
nsLayoutUtils
:
:
ComputeBSizeValue
(
aCBSize
.
BSize
(
aWM
)
boxSizingAdjust
.
BSize
(
aWM
)
styleBSize
.
AsLengthPercentage
(
)
)
;
result
.
ISize
(
aWM
)
=
aspectRatio
.
ComputeRatioDependentSize
(
LogicalAxis
:
:
eLogicalAxisInline
aWM
bSize
boxSizingAdjust
)
;
aspectRatioUsage
=
AspectRatioUsage
:
:
ToComputeISize
;
}
if
(
stretch
|
|
aFlags
.
contains
(
ComputeSizeFlag
:
:
IClampMarginBoxMinSize
)
)
{
auto
iSizeToFillCB
=
std
:
:
max
(
nscoord
(
0
)
aCBSize
.
ISize
(
aWM
)
-
aBorderPadding
.
ISize
(
aWM
)
-
aMargin
.
ISize
(
aWM
)
)
;
if
(
stretch
|
|
result
.
ISize
(
aWM
)
>
iSizeToFillCB
)
{
result
.
ISize
(
aWM
)
=
iSizeToFillCB
;
}
}
}
else
if
(
aspectRatio
&
&
!
isAutoBSize
)
{
auto
bSize
=
nsLayoutUtils
:
:
ComputeBSizeValue
(
aCBSize
.
BSize
(
aWM
)
boxSizingAdjust
.
BSize
(
aWM
)
styleBSize
.
AsLengthPercentage
(
)
)
;
result
.
ISize
(
aWM
)
=
aspectRatio
.
ComputeRatioDependentSize
(
LogicalAxis
:
:
eLogicalAxisInline
aWM
bSize
boxSizingAdjust
)
;
aspectRatioUsage
=
AspectRatioUsage
:
:
ToComputeISize
;
}
const
bool
isDefiniteISize
=
styleISize
.
IsLengthPercentage
(
)
;
const
auto
&
minBSizeCoord
=
stylePos
-
>
MinBSize
(
aWM
)
;
const
auto
&
maxBSizeCoord
=
stylePos
-
>
MaxBSize
(
aWM
)
;
const
bool
isAutoMinBSize
=
nsLayoutUtils
:
:
IsAutoBSize
(
minBSizeCoord
aCBSize
.
BSize
(
aWM
)
)
;
const
bool
isAutoMaxBSize
=
nsLayoutUtils
:
:
IsAutoBSize
(
maxBSizeCoord
aCBSize
.
BSize
(
aWM
)
)
;
if
(
aspectRatio
&
&
!
isDefiniteISize
)
{
const
MinMaxSize
minMaxBSize
{
isAutoMinBSize
?
0
:
nsLayoutUtils
:
:
ComputeBSizeValue
(
aCBSize
.
BSize
(
aWM
)
boxSizingAdjust
.
BSize
(
aWM
)
minBSizeCoord
.
AsLengthPercentage
(
)
)
isAutoMaxBSize
?
NS_UNCONSTRAINEDSIZE
:
nsLayoutUtils
:
:
ComputeBSizeValue
(
aCBSize
.
BSize
(
aWM
)
boxSizingAdjust
.
BSize
(
aWM
)
maxBSizeCoord
.
AsLengthPercentage
(
)
)
}
;
MinMaxSize
transferredMinMaxISize
=
ComputeTransferredMinMaxInlineSize
(
aWM
aspectRatio
minMaxBSize
boxSizingAdjust
)
;
result
.
ISize
(
aWM
)
=
transferredMinMaxISize
.
ClampSizeToMinAndMax
(
result
.
ISize
(
aWM
)
)
;
}
const
bool
isFlexItemInlineAxisMainAxis
=
isFlexItem
&
&
flexMainAxis
=
=
eLogicalAxisInline
;
const
auto
&
maxISizeCoord
=
stylePos
-
>
MaxISize
(
aWM
)
;
nscoord
maxISize
=
NS_UNCONSTRAINEDSIZE
;
if
(
!
maxISizeCoord
.
IsNone
(
)
&
&
!
isFlexItemInlineAxisMainAxis
)
{
maxISize
=
ComputeISizeValue
(
aRenderingContext
aWM
aCBSize
boxSizingAdjust
boxSizingToMarginEdgeISize
maxISizeCoord
aSizeOverrides
aFlags
)
.
mISize
;
result
.
ISize
(
aWM
)
=
std
:
:
min
(
maxISize
result
.
ISize
(
aWM
)
)
;
}
const
auto
&
minISizeCoord
=
stylePos
-
>
MinISize
(
aWM
)
;
nscoord
minISize
;
if
(
!
minISizeCoord
.
IsAuto
(
)
&
&
!
isFlexItemInlineAxisMainAxis
)
{
minISize
=
ComputeISizeValue
(
aRenderingContext
aWM
aCBSize
boxSizingAdjust
boxSizingToMarginEdgeISize
minISizeCoord
aSizeOverrides
aFlags
)
.
mISize
;
}
else
if
(
MOZ_UNLIKELY
(
aFlags
.
contains
(
ComputeSizeFlag
:
:
IApplyAutoMinSize
)
)
)
{
minISize
=
std
:
:
min
(
maxISize
GetMinISize
(
aRenderingContext
)
)
;
if
(
styleISize
.
IsLengthPercentage
(
)
)
{
minISize
=
std
:
:
min
(
minISize
result
.
ISize
(
aWM
)
)
;
}
else
if
(
aFlags
.
contains
(
ComputeSizeFlag
:
:
IClampMarginBoxMinSize
)
)
{
auto
maxMinISize
=
std
:
:
max
(
nscoord
(
0
)
aCBSize
.
ISize
(
aWM
)
-
aBorderPadding
.
ISize
(
aWM
)
-
aMargin
.
ISize
(
aWM
)
)
;
minISize
=
std
:
:
min
(
minISize
maxMinISize
)
;
}
}
else
if
(
aspectRatioUsage
=
=
AspectRatioUsage
:
:
ToComputeISize
&
&
ShouldApplyAutomaticMinimumOnInlineAxis
(
aWM
disp
stylePos
)
)
{
MOZ_ASSERT
(
!
IsFrameOfType
(
eReplacedSizing
)
"
aspect
-
ratio
minimums
should
not
apply
to
replaced
elements
"
)
;
minISize
=
GetMinISize
(
aRenderingContext
)
;
}
else
{
minISize
=
0
;
}
result
.
ISize
(
aWM
)
=
std
:
:
max
(
minISize
result
.
ISize
(
aWM
)
)
;
if
(
!
isAutoBSize
)
{
result
.
BSize
(
aWM
)
=
nsLayoutUtils
:
:
ComputeBSizeValue
(
aCBSize
.
BSize
(
aWM
)
boxSizingAdjust
.
BSize
(
aWM
)
styleBSize
.
AsLengthPercentage
(
)
)
;
}
else
if
(
MOZ_UNLIKELY
(
isGridItem
)
&
&
styleBSize
.
IsAuto
(
)
&
&
!
aFlags
.
contains
(
ComputeSizeFlag
:
:
UseAutoBSize
)
&
&
!
IsTrueOverflowContainer
(
)
&
&
!
alignCB
-
>
IsMasonry
(
isOrthogonal
?
eLogicalAxisInline
:
eLogicalAxisBlock
)
)
{
auto
cbSize
=
aCBSize
.
BSize
(
aWM
)
;
if
(
cbSize
!
=
NS_UNCONSTRAINEDSIZE
)
{
bool
stretch
=
false
;
bool
mayUseAspectRatio
=
aspectRatio
&
&
result
.
ISize
(
aWM
)
!
=
NS_UNCONSTRAINEDSIZE
;
if
(
!
StyleMargin
(
)
-
>
HasBlockAxisAuto
(
aWM
)
)
{
auto
blockAxisAlignment
=
isOrthogonal
?
StylePosition
(
)
-
>
UsedJustifySelf
(
alignCB
-
>
Style
(
)
)
.
_0
:
StylePosition
(
)
-
>
UsedAlignSelf
(
alignCB
-
>
Style
(
)
)
.
_0
;
stretch
=
blockAxisAlignment
=
=
StyleAlignFlags
:
:
STRETCH
|
|
(
blockAxisAlignment
=
=
StyleAlignFlags
:
:
NORMAL
&
&
!
mayUseAspectRatio
)
;
}
if
(
!
stretch
&
&
mayUseAspectRatio
)
{
result
.
BSize
(
aWM
)
=
aspectRatio
.
ComputeRatioDependentSize
(
LogicalAxis
:
:
eLogicalAxisBlock
aWM
result
.
ISize
(
aWM
)
boxSizingAdjust
)
;
MOZ_ASSERT
(
aspectRatioUsage
=
=
AspectRatioUsage
:
:
None
)
;
aspectRatioUsage
=
AspectRatioUsage
:
:
ToComputeBSize
;
}
if
(
stretch
|
|
aFlags
.
contains
(
ComputeSizeFlag
:
:
BClampMarginBoxMinSize
)
)
{
auto
bSizeToFillCB
=
std
:
:
max
(
nscoord
(
0
)
cbSize
-
aBorderPadding
.
BSize
(
aWM
)
-
aMargin
.
BSize
(
aWM
)
)
;
if
(
stretch
|
|
(
result
.
BSize
(
aWM
)
!
=
NS_UNCONSTRAINEDSIZE
&
&
result
.
BSize
(
aWM
)
>
bSizeToFillCB
)
)
{
result
.
BSize
(
aWM
)
=
bSizeToFillCB
;
}
}
}
}
else
if
(
aspectRatio
)
{
result
.
BSize
(
aWM
)
=
aspectRatio
.
ComputeRatioDependentSize
(
LogicalAxis
:
:
eLogicalAxisBlock
aWM
result
.
ISize
(
aWM
)
boxSizingAdjust
)
;
MOZ_ASSERT
(
aspectRatioUsage
=
=
AspectRatioUsage
:
:
None
)
;
aspectRatioUsage
=
AspectRatioUsage
:
:
ToComputeBSize
;
}
if
(
result
.
BSize
(
aWM
)
!
=
NS_UNCONSTRAINEDSIZE
)
{
const
bool
isFlexItemBlockAxisMainAxis
=
isFlexItem
&
&
flexMainAxis
=
=
eLogicalAxisBlock
;
if
(
!
isAutoMaxBSize
&
&
!
isFlexItemBlockAxisMainAxis
)
{
nscoord
maxBSize
=
nsLayoutUtils
:
:
ComputeBSizeValue
(
aCBSize
.
BSize
(
aWM
)
boxSizingAdjust
.
BSize
(
aWM
)
maxBSizeCoord
.
AsLengthPercentage
(
)
)
;
result
.
BSize
(
aWM
)
=
std
:
:
min
(
maxBSize
result
.
BSize
(
aWM
)
)
;
}
if
(
!
isAutoMinBSize
&
&
!
isFlexItemBlockAxisMainAxis
)
{
nscoord
minBSize
=
nsLayoutUtils
:
:
ComputeBSizeValue
(
aCBSize
.
BSize
(
aWM
)
boxSizingAdjust
.
BSize
(
aWM
)
minBSizeCoord
.
AsLengthPercentage
(
)
)
;
result
.
BSize
(
aWM
)
=
std
:
:
max
(
minBSize
result
.
BSize
(
aWM
)
)
;
}
}
if
(
IsThemed
(
disp
)
)
{
LayoutDeviceIntSize
widget
;
bool
canOverride
=
true
;
nsPresContext
*
presContext
=
PresContext
(
)
;
presContext
-
>
Theme
(
)
-
>
GetMinimumWidgetSize
(
presContext
this
disp
-
>
EffectiveAppearance
(
)
&
widget
&
canOverride
)
;
LogicalSize
size
(
aWM
nsSize
(
presContext
-
>
DevPixelsToAppUnits
(
widget
.
width
)
presContext
-
>
DevPixelsToAppUnits
(
widget
.
height
)
)
)
;
size
-
=
aBorderPadding
;
if
(
size
.
BSize
(
aWM
)
>
result
.
BSize
(
aWM
)
|
|
!
canOverride
)
{
result
.
BSize
(
aWM
)
=
size
.
BSize
(
aWM
)
;
}
if
(
size
.
ISize
(
aWM
)
>
result
.
ISize
(
aWM
)
|
|
!
canOverride
)
{
result
.
ISize
(
aWM
)
=
size
.
ISize
(
aWM
)
;
}
}
result
.
ISize
(
aWM
)
=
std
:
:
max
(
0
result
.
ISize
(
aWM
)
)
;
result
.
BSize
(
aWM
)
=
std
:
:
max
(
0
result
.
BSize
(
aWM
)
)
;
return
{
result
aspectRatioUsage
}
;
}
nsRect
nsIFrame
:
:
ComputeTightBounds
(
DrawTarget
*
aDrawTarget
)
const
{
return
InkOverflowRect
(
)
;
}
nsresult
nsIFrame
:
:
GetPrefWidthTightBounds
(
gfxContext
*
aContext
nscoord
*
aX
nscoord
*
aXMost
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
LogicalSize
nsIFrame
:
:
ComputeAutoSize
(
gfxContext
*
aRenderingContext
WritingMode
aWM
const
mozilla
:
:
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
mozilla
:
:
LogicalSize
&
aMargin
const
mozilla
:
:
LogicalSize
&
aBorderPadding
const
StyleSizeOverrides
&
aSizeOverrides
ComputeSizeFlags
aFlags
)
{
LogicalSize
result
(
aWM
0xdeadbeef
NS_UNCONSTRAINEDSIZE
)
;
const
auto
&
styleISize
=
aSizeOverrides
.
mStyleISize
?
*
aSizeOverrides
.
mStyleISize
:
StylePosition
(
)
-
>
ISize
(
aWM
)
;
if
(
styleISize
.
IsAuto
(
)
)
{
nscoord
availBased
=
aAvailableISize
-
aMargin
.
ISize
(
aWM
)
-
aBorderPadding
.
ISize
(
aWM
)
;
result
.
ISize
(
aWM
)
=
ShrinkWidthToFit
(
aRenderingContext
availBased
aFlags
)
;
}
return
result
;
}
nscoord
nsIFrame
:
:
ShrinkWidthToFit
(
gfxContext
*
aRenderingContext
nscoord
aISizeInCB
ComputeSizeFlags
aFlags
)
{
AutoMaybeDisableFontInflation
an
(
this
)
;
nscoord
result
;
nscoord
minISize
=
GetMinISize
(
aRenderingContext
)
;
if
(
minISize
>
aISizeInCB
)
{
const
bool
clamp
=
aFlags
.
contains
(
ComputeSizeFlag
:
:
IClampMarginBoxMinSize
)
;
result
=
MOZ_UNLIKELY
(
clamp
)
?
aISizeInCB
:
minISize
;
}
else
{
nscoord
prefISize
=
GetPrefISize
(
aRenderingContext
)
;
if
(
prefISize
>
aISizeInCB
)
{
result
=
aISizeInCB
;
}
else
{
result
=
prefISize
;
}
}
return
result
;
}
Maybe
<
nscoord
>
nsIFrame
:
:
ComputeInlineSizeFromAspectRatio
(
WritingMode
aWM
const
LogicalSize
&
aCBSize
const
LogicalSize
&
aContentEdgeToBoxSizing
const
StyleSizeOverrides
&
aSizeOverrides
ComputeSizeFlags
aFlags
)
const
{
const
AspectRatio
aspectRatio
=
aSizeOverrides
.
mAspectRatio
?
*
aSizeOverrides
.
mAspectRatio
:
StylePosition
(
)
-
>
mAspectRatio
.
ToLayoutRatio
(
)
;
if
(
!
IsFrameOfType
(
eSupportsAspectRatio
)
|
|
!
aspectRatio
)
{
return
Nothing
(
)
;
}
const
StyleSize
&
styleBSize
=
aSizeOverrides
.
mStyleBSize
?
*
aSizeOverrides
.
mStyleBSize
:
StylePosition
(
)
-
>
BSize
(
aWM
)
;
if
(
aFlags
.
contains
(
ComputeSizeFlag
:
:
UseAutoBSize
)
|
|
nsLayoutUtils
:
:
IsAutoBSize
(
styleBSize
aCBSize
.
BSize
(
aWM
)
)
)
{
return
Nothing
(
)
;
}
MOZ_ASSERT
(
styleBSize
.
IsLengthPercentage
(
)
)
;
nscoord
bSize
=
nsLayoutUtils
:
:
ComputeBSizeValue
(
aCBSize
.
BSize
(
aWM
)
aContentEdgeToBoxSizing
.
BSize
(
aWM
)
styleBSize
.
AsLengthPercentage
(
)
)
;
return
Some
(
aspectRatio
.
ComputeRatioDependentSize
(
LogicalAxis
:
:
eLogicalAxisInline
aWM
bSize
aContentEdgeToBoxSizing
)
)
;
}
nsIFrame
:
:
ISizeComputationResult
nsIFrame
:
:
ComputeISizeValue
(
gfxContext
*
aRenderingContext
const
WritingMode
aWM
const
LogicalSize
&
aContainingBlockSize
const
LogicalSize
&
aContentEdgeToBoxSizing
nscoord
aBoxSizingToMarginEdge
ExtremumLength
aSize
Maybe
<
nscoord
>
aAvailableISizeOverride
const
StyleSizeOverrides
&
aSizeOverrides
ComputeSizeFlags
aFlags
)
{
AutoMaybeDisableFontInflation
an
(
this
)
;
Maybe
<
nscoord
>
intrinsicSizeFromAspectRatio
=
aSize
=
=
ExtremumLength
:
:
MozAvailable
?
Nothing
(
)
:
ComputeInlineSizeFromAspectRatio
(
aWM
aContainingBlockSize
aContentEdgeToBoxSizing
aSizeOverrides
aFlags
)
;
nscoord
result
;
switch
(
aSize
)
{
case
ExtremumLength
:
:
MaxContent
:
result
=
intrinsicSizeFromAspectRatio
?
*
intrinsicSizeFromAspectRatio
:
GetPrefISize
(
aRenderingContext
)
;
NS_ASSERTION
(
result
>
=
0
"
inline
-
size
less
than
zero
"
)
;
return
{
result
intrinsicSizeFromAspectRatio
?
AspectRatioUsage
:
:
ToComputeISize
:
AspectRatioUsage
:
:
None
}
;
case
ExtremumLength
:
:
MinContent
:
result
=
intrinsicSizeFromAspectRatio
?
*
intrinsicSizeFromAspectRatio
:
GetMinISize
(
aRenderingContext
)
;
NS_ASSERTION
(
result
>
=
0
"
inline
-
size
less
than
zero
"
)
;
if
(
MOZ_UNLIKELY
(
aFlags
.
contains
(
ComputeSizeFlag
:
:
IClampMarginBoxMinSize
)
)
)
{
auto
available
=
aContainingBlockSize
.
ISize
(
aWM
)
-
(
aBoxSizingToMarginEdge
+
aContentEdgeToBoxSizing
.
ISize
(
aWM
)
)
;
result
=
std
:
:
min
(
available
result
)
;
}
return
{
result
intrinsicSizeFromAspectRatio
?
AspectRatioUsage
:
:
ToComputeISize
:
AspectRatioUsage
:
:
None
}
;
case
ExtremumLength
:
:
FitContentFunction
:
case
ExtremumLength
:
:
FitContent
:
{
nscoord
pref
=
NS_UNCONSTRAINEDSIZE
;
nscoord
min
=
0
;
if
(
intrinsicSizeFromAspectRatio
)
{
pref
=
min
=
*
intrinsicSizeFromAspectRatio
;
}
else
{
pref
=
GetPrefISize
(
aRenderingContext
)
;
min
=
GetMinISize
(
aRenderingContext
)
;
}
nscoord
fill
=
aAvailableISizeOverride
?
*
aAvailableISizeOverride
:
aContainingBlockSize
.
ISize
(
aWM
)
-
(
aBoxSizingToMarginEdge
+
aContentEdgeToBoxSizing
.
ISize
(
aWM
)
)
;
if
(
MOZ_UNLIKELY
(
aFlags
.
contains
(
ComputeSizeFlag
:
:
IClampMarginBoxMinSize
)
)
)
{
min
=
std
:
:
min
(
min
fill
)
;
}
result
=
std
:
:
max
(
min
std
:
:
min
(
pref
fill
)
)
;
NS_ASSERTION
(
result
>
=
0
"
inline
-
size
less
than
zero
"
)
;
return
{
result
}
;
}
case
ExtremumLength
:
:
MozAvailable
:
return
{
aContainingBlockSize
.
ISize
(
aWM
)
-
(
aBoxSizingToMarginEdge
+
aContentEdgeToBoxSizing
.
ISize
(
aWM
)
)
}
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
extremum
length
?
"
)
;
return
{
}
;
}
nscoord
nsIFrame
:
:
ComputeISizeValue
(
const
WritingMode
aWM
const
LogicalSize
&
aContainingBlockSize
const
LogicalSize
&
aContentEdgeToBoxSizing
const
LengthPercentage
&
aSize
)
{
LAYOUT_WARN_IF_FALSE
(
aContainingBlockSize
.
ISize
(
aWM
)
!
=
NS_UNCONSTRAINEDSIZE
"
have
unconstrained
inline
-
size
;
this
should
only
result
from
"
"
very
large
sizes
not
attempts
at
intrinsic
inline
-
size
"
"
calculation
"
)
;
NS_ASSERTION
(
aContainingBlockSize
.
ISize
(
aWM
)
>
=
0
"
inline
-
size
less
than
zero
"
)
;
nscoord
result
=
aSize
.
Resolve
(
aContainingBlockSize
.
ISize
(
aWM
)
)
;
result
-
=
aContentEdgeToBoxSizing
.
ISize
(
aWM
)
;
return
std
:
:
max
(
0
result
)
;
}
void
nsIFrame
:
:
DidReflow
(
nsPresContext
*
aPresContext
const
ReflowInput
*
aReflowInput
)
{
NS_FRAME_TRACE
(
NS_FRAME_TRACE_CALLS
(
"
nsIFrame
:
:
DidReflow
"
)
)
;
SVGObserverUtils
:
:
InvalidateDirectRenderingObservers
(
this
SVGObserverUtils
:
:
INVALIDATE_REFLOW
)
;
RemoveStateBits
(
NS_FRAME_IN_REFLOW
|
NS_FRAME_FIRST_REFLOW
|
NS_FRAME_IS_DIRTY
|
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
SetHasBSizeChange
(
false
)
;
SetHasPaddingChange
(
false
)
;
if
(
aReflowInput
&
&
aReflowInput
-
>
mPercentBSizeObserver
&
&
!
GetPrevInFlow
(
)
)
{
const
auto
&
bsize
=
aReflowInput
-
>
mStylePosition
-
>
BSize
(
aReflowInput
-
>
GetWritingMode
(
)
)
;
if
(
bsize
.
HasPercent
(
)
)
{
aReflowInput
-
>
mPercentBSizeObserver
-
>
NotifyPercentBSize
(
*
aReflowInput
)
;
}
}
aPresContext
-
>
ReflowedFrame
(
)
;
#
ifdef
ACCESSIBILITY
if
(
nsAccessibilityService
*
accService
=
PresShell
:
:
GetAccessibilityService
(
)
)
{
accService
-
>
NotifyOfPossibleBoundsChange
(
PresShell
(
)
mContent
)
;
}
#
endif
}
void
nsIFrame
:
:
FinishReflowWithAbsoluteFrames
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
bool
aConstrainBSize
)
{
ReflowAbsoluteFrames
(
aPresContext
aDesiredSize
aReflowInput
aStatus
aConstrainBSize
)
;
FinishAndStoreOverflow
(
&
aDesiredSize
aReflowInput
.
mStyleDisplay
)
;
}
void
nsIFrame
:
:
ReflowAbsoluteFrames
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
bool
aConstrainBSize
)
{
if
(
HasAbsolutelyPositionedChildren
(
)
)
{
nsAbsoluteContainingBlock
*
absoluteContainer
=
GetAbsoluteContainingBlock
(
)
;
nsMargin
usedBorder
=
GetUsedBorder
(
)
;
nscoord
containingBlockWidth
=
std
:
:
max
(
0
aDesiredSize
.
Width
(
)
-
usedBorder
.
LeftRight
(
)
)
;
nscoord
containingBlockHeight
=
std
:
:
max
(
0
aDesiredSize
.
Height
(
)
-
usedBorder
.
TopBottom
(
)
)
;
nsContainerFrame
*
container
=
do_QueryFrame
(
this
)
;
NS_ASSERTION
(
container
"
Abs
-
pos
children
only
supported
on
container
frames
for
now
"
)
;
nsRect
containingBlock
(
0
0
containingBlockWidth
containingBlockHeight
)
;
AbsPosReflowFlags
flags
=
AbsPosReflowFlags
:
:
CBWidthAndHeightChanged
;
if
(
aConstrainBSize
)
{
flags
|
=
AbsPosReflowFlags
:
:
ConstrainHeight
;
}
absoluteContainer
-
>
Reflow
(
container
aPresContext
aReflowInput
aStatus
containingBlock
flags
&
aDesiredSize
.
mOverflowAreas
)
;
}
}
bool
nsIFrame
:
:
CanContinueTextRun
(
)
const
{
return
false
;
}
void
nsIFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsFrame
"
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
aDesiredSize
.
ClearSize
(
)
;
}
bool
nsIFrame
:
:
IsContentDisabled
(
)
const
{
if
(
StyleUI
(
)
-
>
UserInput
(
)
=
=
StyleUserInput
:
:
None
)
{
return
true
;
}
auto
*
element
=
nsGenericHTMLElement
:
:
FromNodeOrNull
(
GetContent
(
)
)
;
return
element
&
&
element
-
>
IsDisabled
(
)
;
}
bool
nsIFrame
:
:
IsContentHidden
(
)
const
{
if
(
!
StyleDisplay
(
)
-
>
IsContentVisibilityHidden
(
)
)
{
return
false
;
}
return
IsFrameOfType
(
nsIFrame
:
:
eReplaced
)
|
|
!
StyleDisplay
(
)
-
>
IsInlineFlow
(
)
;
}
bool
nsIFrame
:
:
AncestorHidesContent
(
)
const
{
if
(
!
StaticPrefs
:
:
layout_css_content_visibility_enabled
(
)
)
{
return
false
;
}
for
(
nsIFrame
*
cur
=
GetInFlowParent
(
)
;
cur
;
cur
=
cur
-
>
GetInFlowParent
(
)
)
{
if
(
cur
-
>
IsContentHidden
(
)
)
{
return
true
;
}
}
return
false
;
}
nsresult
nsIFrame
:
:
CharacterDataChanged
(
const
CharacterDataChangeInfo
&
)
{
MOZ_ASSERT_UNREACHABLE
(
"
should
only
be
called
for
text
frames
"
)
;
return
NS_OK
;
}
nsresult
nsIFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
return
NS_OK
;
}
nsIFrame
*
nsIFrame
:
:
GetPrevContinuation
(
)
const
{
return
nullptr
;
}
void
nsIFrame
:
:
SetPrevContinuation
(
nsIFrame
*
aPrevContinuation
)
{
MOZ_ASSERT
(
false
"
not
splittable
"
)
;
}
nsIFrame
*
nsIFrame
:
:
GetNextContinuation
(
)
const
{
return
nullptr
;
}
void
nsIFrame
:
:
SetNextContinuation
(
nsIFrame
*
)
{
MOZ_ASSERT
(
false
"
not
splittable
"
)
;
}
nsIFrame
*
nsIFrame
:
:
GetPrevInFlow
(
)
const
{
return
nullptr
;
}
void
nsIFrame
:
:
SetPrevInFlow
(
nsIFrame
*
aPrevInFlow
)
{
MOZ_ASSERT
(
false
"
not
splittable
"
)
;
}
nsIFrame
*
nsIFrame
:
:
GetNextInFlow
(
)
const
{
return
nullptr
;
}
void
nsIFrame
:
:
SetNextInFlow
(
nsIFrame
*
)
{
MOZ_ASSERT
(
false
"
not
splittable
"
)
;
}
nsIFrame
*
nsIFrame
:
:
GetTailContinuation
(
)
{
nsIFrame
*
frame
=
this
;
while
(
frame
-
>
HasAnyStateBits
(
NS_FRAME_IS_OVERFLOW_CONTAINER
)
)
{
frame
=
frame
-
>
GetPrevContinuation
(
)
;
NS_ASSERTION
(
frame
"
first
continuation
can
'
t
be
overflow
container
"
)
;
}
for
(
nsIFrame
*
next
=
frame
-
>
GetNextContinuation
(
)
;
next
&
&
!
next
-
>
HasAnyStateBits
(
NS_FRAME_IS_OVERFLOW_CONTAINER
)
;
next
=
frame
-
>
GetNextContinuation
(
)
)
{
frame
=
next
;
}
MOZ_ASSERT
(
frame
"
illegal
state
in
continuation
chain
.
"
)
;
return
frame
;
}
void
nsIFrame
:
:
SetView
(
nsView
*
aView
)
{
if
(
aView
)
{
aView
-
>
SetFrame
(
this
)
;
#
ifdef
DEBUG
LayoutFrameType
frameType
=
Type
(
)
;
NS_ASSERTION
(
frameType
=
=
LayoutFrameType
:
:
SubDocument
|
|
frameType
=
=
LayoutFrameType
:
:
ListControl
|
|
frameType
=
=
LayoutFrameType
:
:
Viewport
|
|
frameType
=
=
LayoutFrameType
:
:
MenuPopup
"
Only
specific
frame
types
can
have
an
nsView
"
)
;
#
endif
SetViewInternal
(
aView
)
;
AddStateBits
(
NS_FRAME_HAS_VIEW
)
;
for
(
nsIFrame
*
f
=
GetParent
(
)
;
f
&
&
!
f
-
>
HasAnyStateBits
(
NS_FRAME_HAS_CHILD_WITH_VIEW
)
;
f
=
f
-
>
GetParent
(
)
)
f
-
>
AddStateBits
(
NS_FRAME_HAS_CHILD_WITH_VIEW
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Destroying
a
view
while
the
frame
is
alive
?
"
)
;
RemoveStateBits
(
NS_FRAME_HAS_VIEW
)
;
SetViewInternal
(
nullptr
)
;
}
}
nsIFrame
*
nsIFrame
:
:
GetAncestorWithView
(
)
const
{
for
(
nsIFrame
*
f
=
GetParent
(
)
;
nullptr
!
=
f
;
f
=
f
-
>
GetParent
(
)
)
{
if
(
f
-
>
HasView
(
)
)
{
return
f
;
}
}
return
nullptr
;
}
template
<
nsPoint
(
nsIFrame
:
:
*
PositionGetter
)
(
)
const
>
static
nsPoint
OffsetCalculator
(
const
nsIFrame
*
aThis
const
nsIFrame
*
aOther
)
{
MOZ_ASSERT
(
aOther
"
Must
have
frame
for
destination
coordinate
system
!
"
)
;
NS_ASSERTION
(
aThis
-
>
PresContext
(
)
=
=
aOther
-
>
PresContext
(
)
"
GetOffsetTo
called
on
frames
in
different
documents
"
)
;
nsPoint
offset
(
0
0
)
;
const
nsIFrame
*
f
;
for
(
f
=
aThis
;
f
!
=
aOther
&
&
f
;
f
=
f
-
>
GetParent
(
)
)
{
offset
+
=
(
f
-
>
*
PositionGetter
)
(
)
;
}
if
(
f
!
=
aOther
)
{
while
(
aOther
)
{
offset
-
=
(
aOther
-
>
*
PositionGetter
)
(
)
;
aOther
=
aOther
-
>
GetParent
(
)
;
}
}
return
offset
;
}
nsPoint
nsIFrame
:
:
GetOffsetTo
(
const
nsIFrame
*
aOther
)
const
{
return
OffsetCalculator
<
&
nsIFrame
:
:
GetPosition
>
(
this
aOther
)
;
}
nsPoint
nsIFrame
:
:
GetOffsetToIgnoringScrolling
(
const
nsIFrame
*
aOther
)
const
{
return
OffsetCalculator
<
&
nsIFrame
:
:
GetPositionIgnoringScrolling
>
(
this
aOther
)
;
}
nsPoint
nsIFrame
:
:
GetOffsetToCrossDoc
(
const
nsIFrame
*
aOther
)
const
{
return
GetOffsetToCrossDoc
(
aOther
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
}
nsPoint
nsIFrame
:
:
GetOffsetToCrossDoc
(
const
nsIFrame
*
aOther
const
int32_t
aAPD
)
const
{
MOZ_ASSERT
(
aOther
"
Must
have
frame
for
destination
coordinate
system
!
"
)
;
NS_ASSERTION
(
PresContext
(
)
-
>
GetRootPresContext
(
)
=
=
aOther
-
>
PresContext
(
)
-
>
GetRootPresContext
(
)
"
trying
to
get
the
offset
between
frames
in
different
document
"
"
hierarchies
?
"
)
;
if
(
PresContext
(
)
-
>
GetRootPresContext
(
)
!
=
aOther
-
>
PresContext
(
)
-
>
GetRootPresContext
(
)
)
{
MOZ_CRASH
(
"
trying
to
get
the
offset
between
frames
in
different
"
"
document
hierarchies
?
"
)
;
}
const
nsIFrame
*
root
=
nullptr
;
nsPoint
offset
(
0
0
)
docOffset
(
0
0
)
;
const
nsIFrame
*
f
=
this
;
int32_t
currAPD
=
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
while
(
f
&
&
f
!
=
aOther
)
{
docOffset
+
=
f
-
>
GetPosition
(
)
;
nsIFrame
*
parent
=
f
-
>
GetParent
(
)
;
if
(
parent
)
{
f
=
parent
;
}
else
{
nsPoint
newOffset
(
0
0
)
;
root
=
f
;
f
=
nsLayoutUtils
:
:
GetCrossDocParentFrameInProcess
(
f
&
newOffset
)
;
int32_t
newAPD
=
f
?
f
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
:
0
;
if
(
!
f
|
|
newAPD
!
=
currAPD
)
{
offset
+
=
docOffset
.
ScaleToOtherAppUnits
(
currAPD
aAPD
)
;
docOffset
.
x
=
docOffset
.
y
=
0
;
}
currAPD
=
newAPD
;
docOffset
+
=
newOffset
;
}
}
if
(
f
=
=
aOther
)
{
offset
+
=
docOffset
.
ScaleToOtherAppUnits
(
currAPD
aAPD
)
;
}
else
{
nsPoint
negOffset
=
aOther
-
>
GetOffsetToCrossDoc
(
root
aAPD
)
;
offset
-
=
negOffset
;
}
return
offset
;
}
CSSIntRect
nsIFrame
:
:
GetScreenRect
(
)
const
{
return
CSSIntRect
:
:
FromAppUnitsToNearest
(
GetScreenRectInAppUnits
(
)
)
;
}
nsRect
nsIFrame
:
:
GetScreenRectInAppUnits
(
)
const
{
nsPresContext
*
presContext
=
PresContext
(
)
;
nsIFrame
*
rootFrame
=
presContext
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
;
nsPoint
rootScreenPos
(
0
0
)
;
nsPoint
rootFrameOffsetInParent
(
0
0
)
;
nsIFrame
*
rootFrameParent
=
nsLayoutUtils
:
:
GetCrossDocParentFrameInProcess
(
rootFrame
&
rootFrameOffsetInParent
)
;
if
(
rootFrameParent
)
{
nsRect
parentScreenRectAppUnits
=
rootFrameParent
-
>
GetScreenRectInAppUnits
(
)
;
nsPresContext
*
parentPresContext
=
rootFrameParent
-
>
PresContext
(
)
;
double
parentScale
=
double
(
presContext
-
>
AppUnitsPerDevPixel
(
)
)
/
parentPresContext
-
>
AppUnitsPerDevPixel
(
)
;
nsPoint
rootPt
=
parentScreenRectAppUnits
.
TopLeft
(
)
+
rootFrameOffsetInParent
;
rootScreenPos
.
x
=
NS_round
(
parentScale
*
rootPt
.
x
)
;
rootScreenPos
.
y
=
NS_round
(
parentScale
*
rootPt
.
y
)
;
}
else
{
nsCOMPtr
<
nsIWidget
>
rootWidget
=
presContext
-
>
PresShell
(
)
-
>
GetViewManager
(
)
-
>
GetRootWidget
(
)
;
if
(
rootWidget
)
{
LayoutDeviceIntPoint
rootDevPx
=
rootWidget
-
>
WidgetToScreenOffset
(
)
;
rootScreenPos
.
x
=
presContext
-
>
DevPixelsToAppUnits
(
rootDevPx
.
x
)
;
rootScreenPos
.
y
=
presContext
-
>
DevPixelsToAppUnits
(
rootDevPx
.
y
)
;
}
}
return
nsRect
(
rootScreenPos
+
GetOffsetTo
(
rootFrame
)
GetSize
(
)
)
;
}
void
nsIFrame
:
:
GetOffsetFromView
(
nsPoint
&
aOffset
nsView
*
*
aView
)
const
{
MOZ_ASSERT
(
nullptr
!
=
aView
"
null
OUT
parameter
pointer
"
)
;
nsIFrame
*
frame
=
const_cast
<
nsIFrame
*
>
(
this
)
;
*
aView
=
nullptr
;
aOffset
.
MoveTo
(
0
0
)
;
do
{
aOffset
+
=
frame
-
>
GetPosition
(
)
;
frame
=
frame
-
>
GetParent
(
)
;
}
while
(
frame
&
&
!
frame
-
>
HasView
(
)
)
;
if
(
frame
)
{
*
aView
=
frame
-
>
GetView
(
)
;
}
}
nsIWidget
*
nsIFrame
:
:
GetNearestWidget
(
)
const
{
return
GetClosestView
(
)
-
>
GetNearestWidget
(
nullptr
)
;
}
nsIWidget
*
nsIFrame
:
:
GetNearestWidget
(
nsPoint
&
aOffset
)
const
{
nsPoint
offsetToView
;
nsPoint
offsetToWidget
;
nsIWidget
*
widget
=
GetClosestView
(
&
offsetToView
)
-
>
GetNearestWidget
(
&
offsetToWidget
)
;
aOffset
=
offsetToView
+
offsetToWidget
;
return
widget
;
}
Matrix4x4Flagged
nsIFrame
:
:
GetTransformMatrix
(
ViewportType
aViewportType
RelativeTo
aStopAtAncestor
nsIFrame
*
*
aOutAncestor
uint32_t
aFlags
)
const
{
MOZ_ASSERT
(
aOutAncestor
"
Need
a
place
to
put
the
ancestor
!
"
)
;
const
bool
isTransformed
=
IsTransformed
(
)
;
const
nsIFrame
*
zoomedContentRoot
=
nullptr
;
if
(
aStopAtAncestor
.
mViewportType
=
=
ViewportType
:
:
Visual
)
{
zoomedContentRoot
=
ViewportUtils
:
:
IsZoomedContentRoot
(
this
)
;
if
(
zoomedContentRoot
)
{
MOZ_ASSERT
(
aViewportType
!
=
ViewportType
:
:
Visual
)
;
}
}
if
(
isTransformed
|
|
zoomedContentRoot
)
{
Matrix4x4
result
;
int32_t
scaleFactor
=
(
(
aFlags
&
IN_CSS_UNITS
)
?
AppUnitsPerCSSPixel
(
)
:
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
if
(
isTransformed
)
{
NS_ASSERTION
(
nsLayoutUtils
:
:
GetCrossDocParentFrameInProcess
(
this
)
"
Cannot
transform
the
viewport
frame
!
"
)
;
result
=
result
*
nsDisplayTransform
:
:
GetResultingTransformMatrix
(
this
nsPoint
(
0
0
)
scaleFactor
nsDisplayTransform
:
:
INCLUDE_PERSPECTIVE
|
nsDisplayTransform
:
:
OFFSET_BY_ORIGIN
)
;
}
*
aOutAncestor
=
nsLayoutUtils
:
:
GetCrossDocParentFrameInProcess
(
this
)
;
nsPoint
delta
=
GetOffsetToCrossDoc
(
*
aOutAncestor
)
;
result
.
PostTranslate
(
NSAppUnitsToFloatPixels
(
delta
.
x
scaleFactor
)
NSAppUnitsToFloatPixels
(
delta
.
y
scaleFactor
)
0
.
0f
)
;
if
(
zoomedContentRoot
)
{
Matrix4x4
layoutToVisual
;
ScrollableLayerGuid
:
:
ViewID
targetScrollId
=
nsLayoutUtils
:
:
FindOrCreateIDFor
(
zoomedContentRoot
-
>
GetContent
(
)
)
;
if
(
aFlags
&
nsIFrame
:
:
IN_CSS_UNITS
)
{
layoutToVisual
=
ViewportUtils
:
:
GetVisualToLayoutTransform
(
targetScrollId
)
.
Inverse
(
)
.
ToUnknownMatrix
(
)
;
}
else
{
layoutToVisual
=
ViewportUtils
:
:
GetVisualToLayoutTransform
<
LayoutDevicePixel
>
(
targetScrollId
)
.
Inverse
(
)
.
ToUnknownMatrix
(
)
;
}
result
=
result
*
layoutToVisual
;
}
return
result
;
}
if
(
nsLayoutUtils
:
:
IsPopup
(
this
)
&
&
IsListControlFrame
(
)
)
{
nsPresContext
*
presContext
=
PresContext
(
)
;
nsIFrame
*
docRootFrame
=
presContext
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
;
nsIWidget
*
widget
=
GetView
(
)
-
>
GetWidget
(
)
;
nsPresContext
*
rootPresContext
=
PresContext
(
)
-
>
GetRootPresContext
(
)
;
if
(
widget
&
&
rootPresContext
)
{
nsIWidget
*
toplevel
=
rootPresContext
-
>
GetNearestWidget
(
)
;
if
(
toplevel
)
{
LayoutDeviceIntRect
screenBounds
=
widget
-
>
GetClientBounds
(
)
;
LayoutDeviceIntRect
toplevelScreenBounds
=
toplevel
-
>
GetClientBounds
(
)
;
LayoutDeviceIntPoint
translation
=
screenBounds
.
TopLeft
(
)
-
toplevelScreenBounds
.
TopLeft
(
)
;
Matrix4x4
transformToTop
;
transformToTop
.
_41
=
translation
.
x
;
transformToTop
.
_42
=
translation
.
y
;
*
aOutAncestor
=
docRootFrame
;
Matrix4x4
docRootTransformToTop
=
nsLayoutUtils
:
:
GetTransformToAncestor
(
RelativeTo
{
docRootFrame
}
RelativeTo
{
nullptr
}
)
.
GetMatrix
(
)
;
if
(
docRootTransformToTop
.
IsSingular
(
)
)
{
NS_WARNING
(
"
Containing
document
is
invisible
we
can
'
t
compute
a
valid
"
"
transform
"
)
;
}
else
{
docRootTransformToTop
.
Invert
(
)
;
return
transformToTop
*
docRootTransformToTop
;
}
}
}
}
*
aOutAncestor
=
nsLayoutUtils
:
:
GetCrossDocParentFrameInProcess
(
this
)
;
if
(
!
*
aOutAncestor
)
return
Matrix4x4
(
)
;
const
nsIFrame
*
current
=
this
;
auto
shouldStopAt
=
[
]
(
const
nsIFrame
*
aCurrent
nsIFrame
*
aAncestor
uint32_t
aFlags
)
{
return
aAncestor
-
>
IsTransformed
(
)
|
|
nsLayoutUtils
:
:
IsPopup
(
aAncestor
)
|
|
ViewportUtils
:
:
IsZoomedContentRoot
(
aAncestor
)
|
|
(
(
aFlags
&
STOP_AT_STACKING_CONTEXT_AND_DISPLAY_PORT
)
&
&
(
aAncestor
-
>
IsStackingContext
(
)
|
|
DisplayPortUtils
:
:
FrameHasDisplayPort
(
aAncestor
aCurrent
)
)
)
;
}
;
while
(
*
aOutAncestor
!
=
aStopAtAncestor
.
mFrame
&
&
!
shouldStopAt
(
current
*
aOutAncestor
aFlags
)
)
{
nsIFrame
*
parent
=
nsLayoutUtils
:
:
GetCrossDocParentFrameInProcess
(
*
aOutAncestor
)
;
if
(
!
parent
)
break
;
current
=
*
aOutAncestor
;
*
aOutAncestor
=
parent
;
}
NS_ASSERTION
(
*
aOutAncestor
"
Somehow
ended
up
with
a
null
ancestor
.
.
.
?
"
)
;
nsPoint
delta
=
GetOffsetToCrossDoc
(
*
aOutAncestor
)
;
int32_t
scaleFactor
=
(
(
aFlags
&
IN_CSS_UNITS
)
?
AppUnitsPerCSSPixel
(
)
:
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
return
Matrix4x4
:
:
Translation
(
NSAppUnitsToFloatPixels
(
delta
.
x
scaleFactor
)
NSAppUnitsToFloatPixels
(
delta
.
y
scaleFactor
)
0
.
0f
)
;
}
static
void
InvalidateRenderingObservers
(
nsIFrame
*
aDisplayRoot
nsIFrame
*
aFrame
bool
aFrameChanged
=
true
)
{
MOZ_ASSERT
(
aDisplayRoot
=
=
nsLayoutUtils
:
:
GetDisplayRootFrame
(
aFrame
)
)
;
SVGObserverUtils
:
:
InvalidateDirectRenderingObservers
(
aFrame
)
;
nsIFrame
*
parent
=
aFrame
;
while
(
parent
!
=
aDisplayRoot
&
&
(
parent
=
nsLayoutUtils
:
:
GetCrossDocParentFrameInProcess
(
parent
)
)
&
&
!
parent
-
>
HasAnyStateBits
(
NS_FRAME_DESCENDANT_NEEDS_PAINT
)
)
{
SVGObserverUtils
:
:
InvalidateDirectRenderingObservers
(
parent
)
;
}
if
(
!
aFrameChanged
)
{
return
;
}
aFrame
-
>
MarkNeedsDisplayItemRebuild
(
)
;
}
static
void
SchedulePaintInternal
(
nsIFrame
*
aDisplayRoot
nsIFrame
*
aFrame
nsIFrame
:
:
PaintType
aType
=
nsIFrame
:
:
PAINT_DEFAULT
)
{
MOZ_ASSERT
(
aDisplayRoot
=
=
nsLayoutUtils
:
:
GetDisplayRootFrame
(
aFrame
)
)
;
nsPresContext
*
pres
=
aDisplayRoot
-
>
PresContext
(
)
-
>
GetRootPresContext
(
)
;
if
(
!
pres
|
|
(
pres
-
>
Document
(
)
&
&
pres
-
>
Document
(
)
-
>
IsResourceDoc
(
)
)
)
{
return
;
}
if
(
!
pres
-
>
GetContainerWeak
(
)
)
{
NS_WARNING
(
"
Shouldn
'
t
call
SchedulePaint
in
a
detached
pres
context
"
)
;
return
;
}
pres
-
>
PresShell
(
)
-
>
ScheduleViewManagerFlush
(
)
;
if
(
aType
=
=
nsIFrame
:
:
PAINT_DEFAULT
)
{
aDisplayRoot
-
>
AddStateBits
(
NS_FRAME_UPDATE_LAYER_TREE
)
;
}
}
static
void
InvalidateFrameInternal
(
nsIFrame
*
aFrame
bool
aHasDisplayItem
bool
aRebuildDisplayItems
)
{
if
(
aHasDisplayItem
)
{
aFrame
-
>
AddStateBits
(
NS_FRAME_NEEDS_PAINT
)
;
}
if
(
aRebuildDisplayItems
)
{
aFrame
-
>
MarkNeedsDisplayItemRebuild
(
)
;
}
SVGObserverUtils
:
:
InvalidateDirectRenderingObservers
(
aFrame
)
;
bool
needsSchedulePaint
=
false
;
if
(
nsLayoutUtils
:
:
IsPopup
(
aFrame
)
)
{
needsSchedulePaint
=
true
;
}
else
{
nsIFrame
*
parent
=
nsLayoutUtils
:
:
GetCrossDocParentFrameInProcess
(
aFrame
)
;
while
(
parent
&
&
!
parent
-
>
HasAnyStateBits
(
NS_FRAME_DESCENDANT_NEEDS_PAINT
)
)
{
if
(
aHasDisplayItem
&
&
!
parent
-
>
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
)
{
parent
-
>
AddStateBits
(
NS_FRAME_DESCENDANT_NEEDS_PAINT
)
;
}
SVGObserverUtils
:
:
InvalidateDirectRenderingObservers
(
parent
)
;
if
(
nsLayoutUtils
:
:
IsPopup
(
parent
)
)
{
needsSchedulePaint
=
true
;
break
;
}
parent
=
nsLayoutUtils
:
:
GetCrossDocParentFrameInProcess
(
parent
)
;
}
if
(
!
parent
)
{
needsSchedulePaint
=
true
;
}
}
if
(
!
aHasDisplayItem
)
{
return
;
}
if
(
needsSchedulePaint
)
{
nsIFrame
*
displayRoot
=
nsLayoutUtils
:
:
GetDisplayRootFrame
(
aFrame
)
;
SchedulePaintInternal
(
displayRoot
aFrame
)
;
}
if
(
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_HAS_INVALID_RECT
)
)
{
aFrame
-
>
RemoveProperty
(
nsIFrame
:
:
InvalidationRect
(
)
)
;
aFrame
-
>
RemoveStateBits
(
NS_FRAME_HAS_INVALID_RECT
)
;
}
}
void
nsIFrame
:
:
InvalidateFrameSubtree
(
bool
aRebuildDisplayItems
)
{
InvalidateFrame
(
0
aRebuildDisplayItems
)
;
if
(
HasAnyStateBits
(
NS_FRAME_ALL_DESCENDANTS_NEED_PAINT
)
)
{
return
;
}
AddStateBits
(
NS_FRAME_ALL_DESCENDANTS_NEED_PAINT
)
;
for
(
const
auto
&
childList
:
CrossDocChildLists
(
)
)
{
for
(
nsIFrame
*
child
:
childList
.
mList
)
{
child
-
>
InvalidateFrameSubtree
(
false
)
;
}
}
}
void
nsIFrame
:
:
ClearInvalidationStateBits
(
)
{
if
(
HasAnyStateBits
(
NS_FRAME_DESCENDANT_NEEDS_PAINT
)
)
{
for
(
const
auto
&
childList
:
CrossDocChildLists
(
)
)
{
for
(
nsIFrame
*
child
:
childList
.
mList
)
{
child
-
>
ClearInvalidationStateBits
(
)
;
}
}
}
RemoveStateBits
(
NS_FRAME_NEEDS_PAINT
|
NS_FRAME_DESCENDANT_NEEDS_PAINT
|
NS_FRAME_ALL_DESCENDANTS_NEED_PAINT
)
;
}
bool
HasRetainedDataFor
(
const
nsIFrame
*
aFrame
uint32_t
aDisplayItemKey
)
{
if
(
RefPtr
<
WebRenderUserData
>
data
=
GetWebRenderUserData
<
WebRenderFallbackData
>
(
aFrame
aDisplayItemKey
)
)
{
return
true
;
}
return
false
;
}
void
nsIFrame
:
:
InvalidateFrame
(
uint32_t
aDisplayItemKey
bool
aRebuildDisplayItems
)
{
bool
hasDisplayItem
=
!
aDisplayItemKey
|
|
HasRetainedDataFor
(
this
aDisplayItemKey
)
;
InvalidateFrameInternal
(
this
hasDisplayItem
aRebuildDisplayItems
)
;
}
void
nsIFrame
:
:
InvalidateFrameWithRect
(
const
nsRect
&
aRect
uint32_t
aDisplayItemKey
bool
aRebuildDisplayItems
)
{
if
(
aRect
.
IsEmpty
(
)
)
{
return
;
}
bool
hasDisplayItem
=
!
aDisplayItemKey
|
|
HasRetainedDataFor
(
this
aDisplayItemKey
)
;
bool
alreadyInvalid
=
false
;
if
(
!
HasAnyStateBits
(
NS_FRAME_NEEDS_PAINT
)
)
{
InvalidateFrameInternal
(
this
hasDisplayItem
aRebuildDisplayItems
)
;
}
else
{
alreadyInvalid
=
true
;
}
if
(
!
hasDisplayItem
)
{
return
;
}
nsRect
*
rect
;
if
(
HasAnyStateBits
(
NS_FRAME_HAS_INVALID_RECT
)
)
{
rect
=
GetProperty
(
InvalidationRect
(
)
)
;
MOZ_ASSERT
(
rect
)
;
}
else
{
if
(
alreadyInvalid
)
{
return
;
}
rect
=
new
nsRect
(
)
;
AddProperty
(
InvalidationRect
(
)
rect
)
;
AddStateBits
(
NS_FRAME_HAS_INVALID_RECT
)
;
}
*
rect
=
rect
-
>
Union
(
aRect
)
;
}
uint8_t
nsIFrame
:
:
sLayerIsPrerenderedDataKey
;
bool
nsIFrame
:
:
IsInvalid
(
nsRect
&
aRect
)
{
if
(
!
HasAnyStateBits
(
NS_FRAME_NEEDS_PAINT
)
)
{
return
false
;
}
if
(
HasAnyStateBits
(
NS_FRAME_HAS_INVALID_RECT
)
)
{
nsRect
*
rect
=
GetProperty
(
InvalidationRect
(
)
)
;
NS_ASSERTION
(
rect
"
Must
have
an
invalid
rect
if
NS_FRAME_HAS_INVALID_RECT
is
set
!
"
)
;
aRect
=
*
rect
;
}
else
{
aRect
.
SetEmpty
(
)
;
}
return
true
;
}
void
nsIFrame
:
:
SchedulePaint
(
PaintType
aType
bool
aFrameChanged
)
{
nsIFrame
*
displayRoot
=
nsLayoutUtils
:
:
GetDisplayRootFrame
(
this
)
;
InvalidateRenderingObservers
(
displayRoot
this
aFrameChanged
)
;
SchedulePaintInternal
(
displayRoot
this
aType
)
;
}
void
nsIFrame
:
:
SchedulePaintWithoutInvalidatingObservers
(
PaintType
aType
)
{
nsIFrame
*
displayRoot
=
nsLayoutUtils
:
:
GetDisplayRootFrame
(
this
)
;
SchedulePaintInternal
(
displayRoot
this
aType
)
;
}
void
nsIFrame
:
:
InvalidateLayer
(
DisplayItemType
aDisplayItemKey
const
nsIntRect
*
aDamageRect
const
nsRect
*
aFrameDamageRect
uint32_t
aFlags
)
{
NS_ASSERTION
(
aDisplayItemKey
>
DisplayItemType
:
:
TYPE_ZERO
"
Need
a
key
"
)
;
nsIFrame
*
displayRoot
=
nsLayoutUtils
:
:
GetDisplayRootFrame
(
this
)
;
InvalidateRenderingObservers
(
displayRoot
this
false
)
;
if
(
(
aFlags
&
UPDATE_IS_ASYNC
)
&
&
WebRenderUserData
:
:
SupportsAsyncUpdate
(
this
)
)
{
return
;
}
if
(
aFrameDamageRect
&
&
aFrameDamageRect
-
>
IsEmpty
(
)
)
{
return
;
}
DisplayItemType
displayItemKey
=
aDisplayItemKey
;
if
(
aDisplayItemKey
=
=
DisplayItemType
:
:
TYPE_REMOTE
)
{
displayItemKey
=
DisplayItemType
:
:
TYPE_ZERO
;
}
if
(
aFrameDamageRect
)
{
InvalidateFrameWithRect
(
*
aFrameDamageRect
static_cast
<
uint32_t
>
(
displayItemKey
)
)
;
}
else
{
InvalidateFrame
(
static_cast
<
uint32_t
>
(
displayItemKey
)
)
;
}
}
static
nsRect
ComputeEffectsRect
(
nsIFrame
*
aFrame
const
nsRect
&
aOverflowRect
const
nsSize
&
aNewSize
)
{
nsRect
r
=
aOverflowRect
;
if
(
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_SVG_LAYOUT
)
)
{
if
(
aFrame
-
>
StyleEffects
(
)
-
>
HasFilters
(
)
)
{
SetOrUpdateRectValuedProperty
(
aFrame
nsIFrame
:
:
PreEffectsBBoxProperty
(
)
r
)
;
r
=
SVGUtils
:
:
GetPostFilterInkOverflowRect
(
aFrame
aOverflowRect
)
;
}
return
r
;
}
r
.
UnionRect
(
r
nsLayoutUtils
:
:
GetBoxShadowRectForFrame
(
aFrame
aNewSize
)
)
;
const
nsStyleBorder
*
styleBorder
=
aFrame
-
>
StyleBorder
(
)
;
nsMargin
outsetMargin
=
styleBorder
-
>
GetImageOutset
(
)
;
if
(
outsetMargin
!
=
nsMargin
(
0
0
0
0
)
)
{
nsRect
outsetRect
(
nsPoint
(
0
0
)
aNewSize
)
;
outsetRect
.
Inflate
(
outsetMargin
)
;
r
.
UnionRect
(
r
outsetRect
)
;
}
if
(
SVGIntegrationUtils
:
:
UsingOverflowAffectingEffects
(
aFrame
)
)
{
SetOrUpdateRectValuedProperty
(
aFrame
nsIFrame
:
:
PreEffectsBBoxProperty
(
)
r
)
;
r
=
SVGIntegrationUtils
:
:
ComputePostEffectsInkOverflowRect
(
aFrame
r
)
;
}
return
r
;
}
void
nsIFrame
:
:
MovePositionBy
(
const
nsPoint
&
aTranslation
)
{
nsPoint
position
=
GetNormalPosition
(
)
+
aTranslation
;
const
nsMargin
*
computedOffsets
=
nullptr
;
if
(
IsRelativelyOrStickyPositioned
(
)
)
{
computedOffsets
=
GetProperty
(
nsIFrame
:
:
ComputedOffsetProperty
(
)
)
;
}
ReflowInput
:
:
ApplyRelativePositioning
(
this
computedOffsets
?
*
computedOffsets
:
nsMargin
(
)
&
position
)
;
SetPosition
(
position
)
;
}
nsRect
nsIFrame
:
:
GetNormalRect
(
)
const
{
bool
hasProperty
;
nsPoint
normalPosition
=
GetProperty
(
NormalPositionProperty
(
)
&
hasProperty
)
;
if
(
hasProperty
)
{
return
nsRect
(
normalPosition
GetSize
(
)
)
;
}
return
GetRect
(
)
;
}
nsRect
nsIFrame
:
:
GetBoundingClientRect
(
)
{
return
nsLayoutUtils
:
:
GetAllInFlowRectsUnion
(
this
nsLayoutUtils
:
:
GetContainingBlockForClientRect
(
this
)
nsLayoutUtils
:
:
RECTS_ACCOUNT_FOR_TRANSFORMS
)
;
}
nsPoint
nsIFrame
:
:
GetPositionIgnoringScrolling
(
)
const
{
return
GetParent
(
)
?
GetParent
(
)
-
>
GetPositionOfChildIgnoringScrolling
(
this
)
:
GetPosition
(
)
;
}
nsRect
nsIFrame
:
:
GetOverflowRect
(
OverflowType
aType
)
const
{
if
(
mOverflow
.
mType
=
=
OverflowStorageType
:
:
Large
)
{
return
GetOverflowAreasProperty
(
)
-
>
Overflow
(
aType
)
;
}
if
(
aType
=
=
OverflowType
:
:
Ink
&
&
mOverflow
.
mType
!
=
OverflowStorageType
:
:
None
)
{
return
InkOverflowFromDeltas
(
)
;
}
return
GetRectRelativeToSelf
(
)
;
}
OverflowAreas
nsIFrame
:
:
GetOverflowAreas
(
)
const
{
if
(
mOverflow
.
mType
=
=
OverflowStorageType
:
:
Large
)
{
return
*
GetOverflowAreasProperty
(
)
;
}
return
OverflowAreas
(
InkOverflowFromDeltas
(
)
nsRect
(
nsPoint
(
0
0
)
GetSize
(
)
)
)
;
}
OverflowAreas
nsIFrame
:
:
GetOverflowAreasRelativeToSelf
(
)
const
{
if
(
IsTransformed
(
)
)
{
if
(
OverflowAreas
*
preTransformOverflows
=
GetProperty
(
PreTransformOverflowAreasProperty
(
)
)
)
{
return
*
preTransformOverflows
;
}
}
return
GetOverflowAreas
(
)
;
}
OverflowAreas
nsIFrame
:
:
GetOverflowAreasRelativeToParent
(
)
const
{
return
GetOverflowAreas
(
)
+
GetPosition
(
)
;
}
OverflowAreas
nsIFrame
:
:
GetActualAndNormalOverflowAreasRelativeToParent
(
)
const
{
if
(
MOZ_LIKELY
(
!
IsRelativelyOrStickyPositioned
(
)
)
)
{
return
GetOverflowAreasRelativeToParent
(
)
;
}
const
OverflowAreas
overflows
=
GetOverflowAreas
(
)
;
OverflowAreas
actualAndNormalOverflows
=
overflows
+
GetPosition
(
)
;
actualAndNormalOverflows
.
UnionWith
(
overflows
+
GetNormalPosition
(
)
)
;
return
actualAndNormalOverflows
;
}
nsRect
nsIFrame
:
:
ScrollableOverflowRectRelativeToParent
(
)
const
{
return
ScrollableOverflowRect
(
)
+
GetPosition
(
)
;
}
nsRect
nsIFrame
:
:
InkOverflowRectRelativeToParent
(
)
const
{
return
InkOverflowRect
(
)
+
GetPosition
(
)
;
}
nsRect
nsIFrame
:
:
ScrollableOverflowRectRelativeToSelf
(
)
const
{
if
(
IsTransformed
(
)
)
{
if
(
OverflowAreas
*
preTransformOverflows
=
GetProperty
(
PreTransformOverflowAreasProperty
(
)
)
)
{
return
preTransformOverflows
-
>
ScrollableOverflow
(
)
;
}
}
return
ScrollableOverflowRect
(
)
;
}
nsRect
nsIFrame
:
:
InkOverflowRectRelativeToSelf
(
)
const
{
if
(
IsTransformed
(
)
)
{
if
(
OverflowAreas
*
preTransformOverflows
=
GetProperty
(
PreTransformOverflowAreasProperty
(
)
)
)
{
return
preTransformOverflows
-
>
InkOverflow
(
)
;
}
}
return
InkOverflowRect
(
)
;
}
nsRect
nsIFrame
:
:
PreEffectsInkOverflowRect
(
)
const
{
nsRect
*
r
=
GetProperty
(
nsIFrame
:
:
PreEffectsBBoxProperty
(
)
)
;
return
r
?
*
r
:
InkOverflowRectRelativeToSelf
(
)
;
}
bool
nsIFrame
:
:
UpdateOverflow
(
)
{
MOZ_ASSERT
(
FrameMaintainsOverflow
(
)
"
Non
-
display
SVG
do
not
maintain
ink
overflow
rects
"
)
;
nsRect
rect
(
nsPoint
(
0
0
)
GetSize
(
)
)
;
OverflowAreas
overflowAreas
(
rect
rect
)
;
if
(
!
ComputeCustomOverflow
(
overflowAreas
)
)
{
return
false
;
}
UnionChildOverflow
(
overflowAreas
)
;
if
(
FinishAndStoreOverflow
(
overflowAreas
GetSize
(
)
)
)
{
nsView
*
view
=
GetView
(
)
;
if
(
view
)
{
ReflowChildFlags
flags
=
GetXULLayoutFlags
(
)
;
if
(
!
(
flags
&
ReflowChildFlags
:
:
NoSizeView
)
)
{
nsViewManager
*
vm
=
view
-
>
GetViewManager
(
)
;
vm
-
>
ResizeView
(
view
overflowAreas
.
InkOverflow
(
)
true
)
;
}
}
return
true
;
}
return
Combines3DTransformWithAncestors
(
)
;
}
bool
nsIFrame
:
:
ComputeCustomOverflow
(
OverflowAreas
&
aOverflowAreas
)
{
return
true
;
}
void
nsIFrame
:
:
UnionChildOverflow
(
OverflowAreas
&
aOverflowAreas
)
{
if
(
!
DoesClipChildrenInBothAxes
(
)
&
&
!
(
IsXULCollapsed
(
)
&
&
(
IsXULBoxFrame
(
)
|
|
:
:
IsXULBoxWrapped
(
this
)
)
)
)
{
nsLayoutUtils
:
:
UnionChildOverflow
(
this
aOverflowAreas
)
;
}
}
inline
static
bool
FormControlShrinksForPercentSize
(
const
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eReplaced
)
)
{
return
false
;
}
LayoutFrameType
fType
=
aFrame
-
>
Type
(
)
;
if
(
fType
=
=
LayoutFrameType
:
:
Meter
|
|
fType
=
=
LayoutFrameType
:
:
Progress
|
|
fType
=
=
LayoutFrameType
:
:
Range
)
{
return
true
;
}
if
(
!
static_cast
<
nsIFormControlFrame
*
>
(
do_QueryFrame
(
aFrame
)
)
)
{
return
false
;
}
if
(
fType
=
=
LayoutFrameType
:
:
GfxButtonControl
|
|
fType
=
=
LayoutFrameType
:
:
HTMLButtonControl
)
{
return
false
;
}
return
true
;
}
bool
nsIFrame
:
:
IsPercentageResolvedAgainstZero
(
const
StyleSize
&
aStyleSize
const
StyleMaxSize
&
aStyleMaxSize
)
const
{
const
bool
sizeHasPercent
=
aStyleSize
.
HasPercent
(
)
;
return
(
(
sizeHasPercent
|
|
aStyleMaxSize
.
HasPercent
(
)
)
&
&
IsFrameOfType
(
nsIFrame
:
:
eReplacedSizing
)
)
|
|
(
sizeHasPercent
&
&
FormControlShrinksForPercentSize
(
this
)
)
;
}
bool
nsIFrame
:
:
IsPercentageResolvedAgainstZero
(
const
LengthPercentage
&
aSize
SizeProperty
aProperty
)
const
{
if
(
aProperty
=
=
SizeProperty
:
:
MinSize
)
{
return
true
;
}
const
bool
hasPercentOnReplaced
=
aSize
.
HasPercent
(
)
&
&
IsFrameOfType
(
nsIFrame
:
:
eReplacedSizing
)
;
if
(
aProperty
=
=
SizeProperty
:
:
MaxSize
)
{
return
hasPercentOnReplaced
;
}
MOZ_ASSERT
(
aProperty
=
=
SizeProperty
:
:
Size
)
;
return
hasPercentOnReplaced
|
|
(
aSize
.
HasPercent
(
)
&
&
FormControlShrinksForPercentSize
(
this
)
)
;
}
bool
nsIFrame
:
:
IsBlockWrapper
(
)
const
{
auto
pseudoType
=
Style
(
)
-
>
GetPseudoType
(
)
;
return
pseudoType
=
=
PseudoStyleType
:
:
mozBlockInsideInlineWrapper
|
|
pseudoType
=
=
PseudoStyleType
:
:
buttonContent
|
|
pseudoType
=
=
PseudoStyleType
:
:
cellContent
|
|
pseudoType
=
=
PseudoStyleType
:
:
columnSpanWrapper
;
}
bool
nsIFrame
:
:
IsBlockFrameOrSubclass
(
)
const
{
const
nsBlockFrame
*
thisAsBlock
=
do_QueryFrame
(
this
)
;
return
!
!
thisAsBlock
;
}
static
nsIFrame
*
GetNearestBlockContainer
(
nsIFrame
*
frame
)
{
while
(
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eLineParticipant
)
|
|
frame
-
>
IsBlockWrapper
(
)
|
|
frame
-
>
IsTableRowFrame
(
)
)
{
frame
=
frame
-
>
GetParent
(
)
;
NS_ASSERTION
(
frame
"
How
come
we
got
to
the
root
frame
without
seeing
a
containing
block
?
"
)
;
}
return
frame
;
}
nsIFrame
*
nsIFrame
:
:
GetContainingBlock
(
uint32_t
aFlags
const
nsStyleDisplay
*
aStyleDisplay
)
const
{
MOZ_ASSERT
(
aStyleDisplay
=
=
StyleDisplay
(
)
)
;
if
(
!
GetParent
(
)
)
{
return
nullptr
;
}
nsIFrame
*
f
;
if
(
IsAbsolutelyPositioned
(
aStyleDisplay
)
)
{
f
=
GetParent
(
)
;
}
else
{
f
=
GetNearestBlockContainer
(
GetParent
(
)
)
;
}
if
(
aFlags
&
SKIP_SCROLLED_FRAME
&
&
f
&
&
f
-
>
Style
(
)
-
>
GetPseudoType
(
)
=
=
PseudoStyleType
:
:
scrolledContent
)
{
f
=
f
-
>
GetParent
(
)
;
}
return
f
;
}
#
ifdef
DEBUG_FRAME_DUMP
Maybe
<
uint32_t
>
nsIFrame
:
:
ContentIndexInContainer
(
const
nsIFrame
*
aFrame
)
{
if
(
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
)
{
return
content
-
>
ComputeIndexInParentContent
(
)
;
}
return
Nothing
(
)
;
}
nsAutoCString
nsIFrame
:
:
ListTag
(
)
const
{
nsAutoString
tmp
;
GetFrameName
(
tmp
)
;
nsAutoCString
tag
;
tag
+
=
NS_ConvertUTF16toUTF8
(
tmp
)
;
tag
+
=
nsPrintfCString
(
"
%
p
"
static_cast
<
const
void
*
>
(
this
)
)
;
return
tag
;
}
std
:
:
string
nsIFrame
:
:
ConvertToString
(
const
LogicalRect
&
aRect
const
WritingMode
aWM
ListFlags
aFlags
)
{
if
(
aFlags
.
contains
(
ListFlag
:
:
DisplayInCSSPixels
)
)
{
return
ToString
(
mozilla
:
:
CSSRect
(
CSSPixel
:
:
FromAppUnits
(
aRect
.
IStart
(
aWM
)
)
CSSPixel
:
:
FromAppUnits
(
aRect
.
BStart
(
aWM
)
)
CSSPixel
:
:
FromAppUnits
(
aRect
.
ISize
(
aWM
)
)
CSSPixel
:
:
FromAppUnits
(
aRect
.
BSize
(
aWM
)
)
)
)
;
}
return
ToString
(
aRect
)
;
}
std
:
:
string
nsIFrame
:
:
ConvertToString
(
const
LogicalSize
&
aSize
const
WritingMode
aWM
ListFlags
aFlags
)
{
if
(
aFlags
.
contains
(
ListFlag
:
:
DisplayInCSSPixels
)
)
{
return
ToString
(
CSSSize
(
CSSPixel
:
:
FromAppUnits
(
aSize
.
ISize
(
aWM
)
)
CSSPixel
:
:
FromAppUnits
(
aSize
.
BSize
(
aWM
)
)
)
)
;
}
return
ToString
(
aSize
)
;
}
void
nsIFrame
:
:
ListGeneric
(
nsACString
&
aTo
const
char
*
aPrefix
ListFlags
aFlags
)
const
{
aTo
+
=
aPrefix
;
aTo
+
=
ListTag
(
)
;
if
(
HasView
(
)
)
{
aTo
+
=
nsPrintfCString
(
"
[
view
=
%
p
]
"
static_cast
<
void
*
>
(
GetView
(
)
)
)
;
}
if
(
GetParent
(
)
)
{
aTo
+
=
nsPrintfCString
(
"
parent
=
%
p
"
static_cast
<
void
*
>
(
GetParent
(
)
)
)
;
}
if
(
GetNextSibling
(
)
)
{
aTo
+
=
nsPrintfCString
(
"
next
=
%
p
"
static_cast
<
void
*
>
(
GetNextSibling
(
)
)
)
;
}
if
(
GetPrevContinuation
(
)
)
{
bool
fluid
=
GetPrevInFlow
(
)
=
=
GetPrevContinuation
(
)
;
aTo
+
=
nsPrintfCString
(
"
prev
-
%
s
=
%
p
"
fluid
?
"
in
-
flow
"
:
"
continuation
"
static_cast
<
void
*
>
(
GetPrevContinuation
(
)
)
)
;
}
if
(
GetNextContinuation
(
)
)
{
bool
fluid
=
GetNextInFlow
(
)
=
=
GetNextContinuation
(
)
;
aTo
+
=
nsPrintfCString
(
"
next
-
%
s
=
%
p
"
fluid
?
"
in
-
flow
"
:
"
continuation
"
static_cast
<
void
*
>
(
GetNextContinuation
(
)
)
)
;
}
if
(
const
nsIFrame
:
:
PageValues
*
const
pageValues
=
GetProperty
(
PageValuesProperty
(
)
)
)
{
nsAutoCString
name
;
aTo
+
=
"
PageValues
=
{
"
;
if
(
pageValues
-
>
mStartPageValue
)
{
pageValues
-
>
mStartPageValue
-
>
ToUTF8String
(
name
)
;
aTo
+
=
name
;
}
else
{
aTo
+
=
"
<
null
>
"
;
}
aTo
+
=
"
"
;
if
(
pageValues
-
>
mEndPageValue
)
{
pageValues
-
>
mEndPageValue
-
>
ToUTF8String
(
name
)
;
aTo
+
=
name
;
}
else
{
aTo
+
=
"
<
null
>
"
;
}
aTo
+
=
"
}
"
;
}
void
*
IBsibling
=
GetProperty
(
IBSplitSibling
(
)
)
;
if
(
IBsibling
)
{
aTo
+
=
nsPrintfCString
(
"
IBSplitSibling
=
%
p
"
IBsibling
)
;
}
void
*
IBprevsibling
=
GetProperty
(
IBSplitPrevSibling
(
)
)
;
if
(
IBprevsibling
)
{
aTo
+
=
nsPrintfCString
(
"
IBSplitPrevSibling
=
%
p
"
IBprevsibling
)
;
}
if
(
nsLayoutUtils
:
:
FontSizeInflationEnabled
(
PresContext
(
)
)
)
{
if
(
HasAnyStateBits
(
NS_FRAME_FONT_INFLATION_FLOW_ROOT
)
)
{
aTo
+
=
nsPrintfCString
(
"
FFR
"
)
;
if
(
nsFontInflationData
*
data
=
nsFontInflationData
:
:
FindFontInflationDataFor
(
this
)
)
{
aTo
+
=
nsPrintfCString
(
"
enabled
=
%
s
UIS
=
%
s
"
data
-
>
InflationEnabled
(
)
?
"
yes
"
:
"
no
"
ConvertToString
(
data
-
>
UsableISize
(
)
aFlags
)
.
c_str
(
)
)
;
}
}
if
(
HasAnyStateBits
(
NS_FRAME_FONT_INFLATION_CONTAINER
)
)
{
aTo
+
=
nsPrintfCString
(
"
FIC
"
)
;
}
aTo
+
=
nsPrintfCString
(
"
FI
=
%
f
"
nsLayoutUtils
:
:
FontSizeInflationFor
(
this
)
)
;
}
aTo
+
=
nsPrintfCString
(
"
%
s
"
ConvertToString
(
mRect
aFlags
)
.
c_str
(
)
)
;
mozilla
:
:
WritingMode
wm
=
GetWritingMode
(
)
;
if
(
wm
.
IsVertical
(
)
|
|
wm
.
IsBidiRTL
(
)
)
{
aTo
+
=
nsPrintfCString
(
"
wm
=
%
s
logical
-
size
=
(
%
s
)
"
ToString
(
wm
)
.
c_str
(
)
ConvertToString
(
GetLogicalSize
(
)
wm
aFlags
)
.
c_str
(
)
)
;
}
nsIFrame
*
parent
=
GetParent
(
)
;
if
(
parent
)
{
WritingMode
pWM
=
parent
-
>
GetWritingMode
(
)
;
if
(
pWM
.
IsVertical
(
)
|
|
pWM
.
IsBidiRTL
(
)
)
{
nsSize
containerSize
=
parent
-
>
mRect
.
Size
(
)
;
LogicalRect
lr
(
pWM
mRect
containerSize
)
;
aTo
+
=
nsPrintfCString
(
"
parent
-
wm
=
%
s
cs
=
(
%
s
)
logical
-
rect
=
%
s
"
ToString
(
pWM
)
.
c_str
(
)
ConvertToString
(
containerSize
aFlags
)
.
c_str
(
)
ConvertToString
(
lr
pWM
aFlags
)
.
c_str
(
)
)
;
}
}
nsIFrame
*
f
=
const_cast
<
nsIFrame
*
>
(
this
)
;
if
(
f
-
>
HasOverflowAreas
(
)
)
{
nsRect
vo
=
f
-
>
InkOverflowRect
(
)
;
if
(
!
vo
.
IsEqualEdges
(
mRect
)
)
{
aTo
+
=
nsPrintfCString
(
"
ink
-
overflow
=
%
s
"
ConvertToString
(
vo
aFlags
)
.
c_str
(
)
)
;
}
nsRect
so
=
f
-
>
ScrollableOverflowRect
(
)
;
if
(
!
so
.
IsEqualEdges
(
mRect
)
)
{
aTo
+
=
nsPrintfCString
(
"
scr
-
overflow
=
%
s
"
ConvertToString
(
so
aFlags
)
.
c_str
(
)
)
;
}
}
bool
hasNormalPosition
;
nsPoint
normalPosition
=
GetNormalPosition
(
&
hasNormalPosition
)
;
if
(
hasNormalPosition
)
{
aTo
+
=
nsPrintfCString
(
"
normal
-
position
=
%
s
"
ConvertToString
(
normalPosition
aFlags
)
.
c_str
(
)
)
;
}
if
(
HasProperty
(
BidiDataProperty
(
)
)
)
{
FrameBidiData
bidi
=
GetBidiData
(
)
;
aTo
+
=
nsPrintfCString
(
"
bidi
(
%
d
%
d
%
d
)
"
bidi
.
baseLevel
.
Value
(
)
bidi
.
embeddingLevel
.
Value
(
)
bidi
.
precedingControl
.
Value
(
)
)
;
}
if
(
IsTransformed
(
)
)
{
aTo
+
=
nsPrintfCString
(
"
transformed
"
)
;
}
if
(
ChildrenHavePerspective
(
)
)
{
aTo
+
=
nsPrintfCString
(
"
perspective
"
)
;
}
if
(
Extend3DContext
(
)
)
{
aTo
+
=
nsPrintfCString
(
"
extend
-
3d
"
)
;
}
if
(
Combines3DTransformWithAncestors
(
)
)
{
aTo
+
=
nsPrintfCString
(
"
combines
-
3d
-
transform
-
with
-
ancestors
"
)
;
}
if
(
mContent
)
{
aTo
+
=
nsPrintfCString
(
"
[
content
=
%
p
]
"
static_cast
<
void
*
>
(
mContent
)
)
;
}
aTo
+
=
nsPrintfCString
(
"
[
cs
=
%
p
"
static_cast
<
void
*
>
(
mComputedStyle
)
)
;
if
(
mComputedStyle
)
{
auto
pseudoType
=
mComputedStyle
-
>
GetPseudoType
(
)
;
aTo
+
=
ToString
(
pseudoType
)
.
c_str
(
)
;
}
aTo
+
=
"
]
"
;
if
(
IsFrameModified
(
)
)
{
aTo
+
=
nsPrintfCString
(
"
modified
"
)
;
}
if
(
HasModifiedDescendants
(
)
)
{
aTo
+
=
nsPrintfCString
(
"
has
-
modified
-
descendants
"
)
;
}
}
void
nsIFrame
:
:
List
(
FILE
*
out
const
char
*
aPrefix
ListFlags
aFlags
)
const
{
nsCString
str
;
ListGeneric
(
str
aPrefix
aFlags
)
;
fprintf_stderr
(
out
"
%
s
\
n
"
str
.
get
(
)
)
;
}
void
nsIFrame
:
:
ListTextRuns
(
FILE
*
out
)
const
{
nsTHashSet
<
const
void
*
>
seen
;
ListTextRuns
(
out
seen
)
;
}
void
nsIFrame
:
:
ListTextRuns
(
FILE
*
out
nsTHashSet
<
const
void
*
>
&
aSeen
)
const
{
for
(
const
auto
&
childList
:
ChildLists
(
)
)
{
for
(
const
nsIFrame
*
kid
:
childList
.
mList
)
{
kid
-
>
ListTextRuns
(
out
aSeen
)
;
}
}
}
void
nsIFrame
:
:
ListMatchedRules
(
FILE
*
out
const
char
*
aPrefix
)
const
{
nsTArray
<
const
RawServoStyleRule
*
>
rawRuleList
;
Servo_ComputedValues_GetStyleRuleList
(
mComputedStyle
&
rawRuleList
)
;
for
(
const
RawServoStyleRule
*
rawRule
:
rawRuleList
)
{
nsAutoCString
ruleText
;
Servo_StyleRule_GetCssText
(
rawRule
&
ruleText
)
;
fprintf_stderr
(
out
"
%
s
%
s
\
n
"
aPrefix
ruleText
.
get
(
)
)
;
}
}
void
nsIFrame
:
:
ListWithMatchedRules
(
FILE
*
out
const
char
*
aPrefix
)
const
{
fprintf_stderr
(
out
"
%
s
%
s
\
n
"
aPrefix
ListTag
(
)
.
get
(
)
)
;
nsCString
rulePrefix
;
rulePrefix
+
=
aPrefix
;
rulePrefix
+
=
"
"
;
ListMatchedRules
(
out
rulePrefix
.
get
(
)
)
;
}
nsresult
nsIFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
u
"
Frame
"
_ns
aResult
)
;
}
nsresult
nsIFrame
:
:
MakeFrameName
(
const
nsAString
&
aType
nsAString
&
aResult
)
const
{
aResult
=
aType
;
if
(
mContent
&
&
!
mContent
-
>
IsText
(
)
)
{
nsAutoString
buf
;
mContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
-
>
ToString
(
buf
)
;
if
(
nsAtom
*
id
=
mContent
-
>
GetID
(
)
)
{
buf
.
AppendLiteral
(
"
id
=
"
)
;
buf
.
Append
(
nsDependentAtomString
(
id
)
)
;
}
if
(
IsSubDocumentFrame
(
)
)
{
nsAutoString
src
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
src
src
)
;
buf
.
AppendLiteral
(
"
src
=
"
)
;
buf
.
Append
(
src
)
;
}
aResult
.
Append
(
'
(
'
)
;
aResult
.
Append
(
buf
)
;
aResult
.
Append
(
'
)
'
)
;
}
aResult
.
Append
(
'
(
'
)
;
Maybe
<
uint32_t
>
index
=
ContentIndexInContainer
(
this
)
;
if
(
index
.
isSome
(
)
)
{
aResult
.
AppendInt
(
*
index
)
;
}
else
{
aResult
.
AppendInt
(
-
1
)
;
}
aResult
.
Append
(
'
)
'
)
;
return
NS_OK
;
}
void
nsIFrame
:
:
DumpFrameTree
(
)
const
{
PresShell
(
)
-
>
GetRootFrame
(
)
-
>
List
(
stderr
)
;
}
void
nsIFrame
:
:
DumpFrameTreeInCSSPixels
(
)
const
{
PresShell
(
)
-
>
GetRootFrame
(
)
-
>
List
(
stderr
"
"
ListFlag
:
:
DisplayInCSSPixels
)
;
}
void
nsIFrame
:
:
DumpFrameTreeLimited
(
)
const
{
List
(
stderr
)
;
}
void
nsIFrame
:
:
DumpFrameTreeLimitedInCSSPixels
(
)
const
{
List
(
stderr
"
"
ListFlag
:
:
DisplayInCSSPixels
)
;
}
#
endif
bool
nsIFrame
:
:
IsVisibleForPainting
(
)
{
return
StyleVisibility
(
)
-
>
IsVisible
(
)
;
}
bool
nsIFrame
:
:
IsVisibleOrCollapsedForPainting
(
)
{
return
StyleVisibility
(
)
-
>
IsVisibleOrCollapsed
(
)
;
}
bool
nsIFrame
:
:
IsEmpty
(
)
{
return
false
;
}
bool
nsIFrame
:
:
CachedIsEmpty
(
)
{
MOZ_ASSERT
(
!
HasAnyStateBits
(
NS_FRAME_IS_DIRTY
)
"
Must
only
be
called
on
reflowed
lines
"
)
;
return
IsEmpty
(
)
;
}
bool
nsIFrame
:
:
IsSelfEmpty
(
)
{
return
false
;
}
nsresult
nsIFrame
:
:
GetSelectionController
(
nsPresContext
*
aPresContext
nsISelectionController
*
*
aSelCon
)
{
if
(
!
aPresContext
|
|
!
aSelCon
)
return
NS_ERROR_INVALID_ARG
;
nsIFrame
*
frame
=
this
;
while
(
frame
&
&
frame
-
>
HasAnyStateBits
(
NS_FRAME_INDEPENDENT_SELECTION
)
)
{
nsITextControlFrame
*
tcf
=
do_QueryFrame
(
frame
)
;
if
(
tcf
)
{
return
tcf
-
>
GetOwnedSelectionController
(
aSelCon
)
;
}
frame
=
frame
-
>
GetParent
(
)
;
}
*
aSelCon
=
do_AddRef
(
aPresContext
-
>
PresShell
(
)
)
.
take
(
)
;
return
NS_OK
;
}
already_AddRefed
<
nsFrameSelection
>
nsIFrame
:
:
GetFrameSelection
(
)
{
RefPtr
<
nsFrameSelection
>
fs
=
const_cast
<
nsFrameSelection
*
>
(
GetConstFrameSelection
(
)
)
;
return
fs
.
forget
(
)
;
}
const
nsFrameSelection
*
nsIFrame
:
:
GetConstFrameSelection
(
)
const
{
nsIFrame
*
frame
=
const_cast
<
nsIFrame
*
>
(
this
)
;
while
(
frame
&
&
frame
-
>
HasAnyStateBits
(
NS_FRAME_INDEPENDENT_SELECTION
)
)
{
nsITextControlFrame
*
tcf
=
do_QueryFrame
(
frame
)
;
if
(
tcf
)
{
return
tcf
-
>
GetOwnedFrameSelection
(
)
;
}
frame
=
frame
-
>
GetParent
(
)
;
}
return
PresShell
(
)
-
>
ConstFrameSelection
(
)
;
}
bool
nsIFrame
:
:
IsFrameSelected
(
)
const
{
NS_ASSERTION
(
!
GetContent
(
)
|
|
GetContent
(
)
-
>
IsMaybeSelected
(
)
"
use
the
public
IsSelected
(
)
instead
"
)
;
return
GetContent
(
)
-
>
IsSelected
(
0
GetContent
(
)
-
>
GetChildCount
(
)
)
;
}
nsresult
nsIFrame
:
:
GetPointFromOffset
(
int32_t
inOffset
nsPoint
*
outPoint
)
{
MOZ_ASSERT
(
outPoint
!
=
nullptr
"
Null
parameter
"
)
;
nsRect
contentRect
=
GetContentRectRelativeToSelf
(
)
;
nsPoint
pt
=
contentRect
.
TopLeft
(
)
;
if
(
mContent
)
{
nsIContent
*
newContent
=
mContent
-
>
GetParent
(
)
;
if
(
newContent
)
{
const
int32_t
newOffset
=
newContent
-
>
ComputeIndexOf_Deprecated
(
mContent
)
;
bool
hasBidiData
;
FrameBidiData
bidiData
=
GetProperty
(
BidiDataProperty
(
)
&
hasBidiData
)
;
bool
isRTL
=
hasBidiData
?
bidiData
.
embeddingLevel
.
IsRTL
(
)
:
StyleVisibility
(
)
-
>
mDirection
=
=
StyleDirection
:
:
Rtl
;
if
(
(
!
isRTL
&
&
inOffset
>
newOffset
)
|
|
(
isRTL
&
&
inOffset
<
=
newOffset
)
)
{
pt
=
contentRect
.
TopRight
(
)
;
}
}
}
*
outPoint
=
pt
;
return
NS_OK
;
}
nsresult
nsIFrame
:
:
GetCharacterRectsInRange
(
int32_t
aInOffset
int32_t
aLength
nsTArray
<
nsRect
>
&
aOutRect
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
nsIFrame
:
:
GetChildFrameContainingOffset
(
int32_t
inContentOffset
bool
inHint
int32_t
*
outFrameContentOffset
nsIFrame
*
*
outChildFrame
)
{
MOZ_ASSERT
(
outChildFrame
&
&
outFrameContentOffset
"
Null
parameter
"
)
;
*
outFrameContentOffset
=
(
int32_t
)
inHint
;
nsRect
rect
=
GetRect
(
)
;
if
(
!
rect
.
width
|
|
!
rect
.
height
)
{
nsIFrame
*
nextFlow
=
GetNextInFlow
(
)
;
if
(
nextFlow
)
return
nextFlow
-
>
GetChildFrameContainingOffset
(
inContentOffset
inHint
outFrameContentOffset
outChildFrame
)
;
}
*
outChildFrame
=
this
;
return
NS_OK
;
}
nsresult
nsIFrame
:
:
GetNextPrevLineFromeBlockFrame
(
nsPresContext
*
aPresContext
nsPeekOffsetStruct
*
aPos
nsIFrame
*
aBlockFrame
int32_t
aLineStart
int8_t
aOutSideLimit
)
{
if
(
!
aBlockFrame
|
|
!
aPos
)
return
NS_ERROR_NULL_POINTER
;
aPos
-
>
mResultFrame
=
nullptr
;
aPos
-
>
mResultContent
=
nullptr
;
aPos
-
>
mAttach
=
aPos
-
>
mDirection
=
=
eDirNext
?
CARET_ASSOCIATE_AFTER
:
CARET_ASSOCIATE_BEFORE
;
AutoAssertNoDomMutations
guard
;
nsILineIterator
*
it
=
aBlockFrame
-
>
GetLineIterator
(
)
;
if
(
!
it
)
{
return
NS_ERROR_FAILURE
;
}
int32_t
searchingLine
=
aLineStart
;
int32_t
countLines
=
it
-
>
GetNumLines
(
)
;
if
(
aOutSideLimit
>
0
)
searchingLine
=
countLines
;
else
if
(
aOutSideLimit
<
0
)
searchingLine
=
-
1
;
else
if
(
(
aPos
-
>
mDirection
=
=
eDirPrevious
&
&
searchingLine
=
=
0
)
|
|
(
aPos
-
>
mDirection
=
=
eDirNext
&
&
searchingLine
>
=
(
countLines
-
1
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsIFrame
*
resultFrame
=
nullptr
;
nsIFrame
*
farStoppingFrame
=
nullptr
;
nsIFrame
*
nearStoppingFrame
=
nullptr
;
nsIFrame
*
firstFrame
;
nsIFrame
*
lastFrame
;
bool
isBeforeFirstFrame
isAfterLastFrame
;
bool
found
=
false
;
nsresult
result
=
NS_OK
;
while
(
!
found
)
{
if
(
aPos
-
>
mDirection
=
=
eDirPrevious
)
searchingLine
-
-
;
else
searchingLine
+
+
;
if
(
(
aPos
-
>
mDirection
=
=
eDirPrevious
&
&
searchingLine
<
0
)
|
|
(
aPos
-
>
mDirection
=
=
eDirNext
&
&
searchingLine
>
=
countLines
)
)
{
return
NS_ERROR_FAILURE
;
}
auto
line
=
it
-
>
GetLine
(
searchingLine
)
.
unwrap
(
)
;
if
(
!
line
.
mNumFramesOnLine
)
{
continue
;
}
lastFrame
=
firstFrame
=
line
.
mFirstFrameOnLine
;
for
(
int32_t
lineFrameCount
=
line
.
mNumFramesOnLine
;
lineFrameCount
>
1
;
lineFrameCount
-
-
)
{
lastFrame
=
lastFrame
-
>
GetNextSibling
(
)
;
if
(
!
lastFrame
)
{
NS_ERROR
(
"
GetLine
promised
more
frames
than
could
be
found
"
)
;
return
NS_ERROR_FAILURE
;
}
}
GetLastLeaf
(
&
lastFrame
)
;
if
(
aPos
-
>
mDirection
=
=
eDirNext
)
{
nearStoppingFrame
=
firstFrame
;
farStoppingFrame
=
lastFrame
;
}
else
{
nearStoppingFrame
=
lastFrame
;
farStoppingFrame
=
firstFrame
;
}
nsPoint
offset
;
nsView
*
view
;
aBlockFrame
-
>
GetOffsetFromView
(
offset
&
view
)
;
nsPoint
newDesiredPos
=
aPos
-
>
mDesiredCaretPos
-
offset
;
result
=
it
-
>
FindFrameAt
(
searchingLine
newDesiredPos
&
resultFrame
&
isBeforeFirstFrame
&
isAfterLastFrame
)
;
if
(
NS_FAILED
(
result
)
)
{
continue
;
}
if
(
resultFrame
)
{
if
(
resultFrame
-
>
CanProvideLineIterator
(
)
)
{
aPos
-
>
mResultFrame
=
resultFrame
;
return
NS_OK
;
}
result
=
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsIFrameEnumerator
>
frameTraversal
;
result
=
NS_NewFrameTraversal
(
getter_AddRefs
(
frameTraversal
)
aPresContext
resultFrame
ePostOrder
false
aPos
-
>
mScrollViewStop
false
false
)
;
if
(
NS_FAILED
(
result
)
)
return
result
;
auto
FoundValidFrame
=
[
aPos
]
(
const
ContentOffsets
&
aOffsets
const
nsIFrame
*
aFrame
)
{
if
(
!
aOffsets
.
content
)
{
return
false
;
}
if
(
!
aFrame
-
>
IsSelectable
(
nullptr
)
)
{
return
false
;
}
if
(
aPos
-
>
mForceEditableRegion
&
&
!
aOffsets
.
content
-
>
IsEditable
(
)
)
{
return
false
;
}
return
true
;
}
;
nsIFrame
*
storeOldResultFrame
=
resultFrame
;
while
(
!
found
)
{
nsPoint
point
;
nsRect
tempRect
=
resultFrame
-
>
GetRect
(
)
;
nsPoint
offset
;
nsView
*
view
;
resultFrame
-
>
GetOffsetFromView
(
offset
&
view
)
;
if
(
!
view
)
{
return
NS_ERROR_FAILURE
;
}
if
(
resultFrame
-
>
GetWritingMode
(
)
.
IsVertical
(
)
)
{
point
.
y
=
aPos
-
>
mDesiredCaretPos
.
y
;
point
.
x
=
tempRect
.
width
+
offset
.
x
;
}
else
{
point
.
y
=
tempRect
.
height
+
offset
.
y
;
point
.
x
=
aPos
-
>
mDesiredCaretPos
.
x
;
}
mozilla
:
:
PresShell
*
presShell
=
aPresContext
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
NS_ERROR_FAILURE
;
}
int16_t
isEditor
=
presShell
-
>
GetSelectionFlags
(
)
;
isEditor
=
isEditor
=
=
nsISelectionDisplay
:
:
DISPLAY_ALL
;
if
(
isEditor
)
{
if
(
resultFrame
-
>
IsTableWrapperFrame
(
)
)
{
if
(
(
(
point
.
x
-
offset
.
x
+
tempRect
.
x
)
<
0
)
|
|
(
(
point
.
x
-
offset
.
x
+
tempRect
.
x
)
>
tempRect
.
width
)
)
{
nsIContent
*
content
=
resultFrame
-
>
GetContent
(
)
;
if
(
content
)
{
nsIContent
*
parent
=
content
-
>
GetParent
(
)
;
if
(
parent
)
{
aPos
-
>
mResultContent
=
parent
;
aPos
-
>
mContentOffset
=
parent
-
>
ComputeIndexOf_Deprecated
(
content
)
;
aPos
-
>
mAttach
=
CARET_ASSOCIATE_BEFORE
;
if
(
(
point
.
x
-
offset
.
x
+
tempRect
.
x
)
>
tempRect
.
width
)
{
aPos
-
>
mContentOffset
+
+
;
aPos
-
>
mAttach
=
CARET_ASSOCIATE_AFTER
;
}
aPos
-
>
mResultFrame
=
resultFrame
-
>
GetParent
(
)
;
return
NS_POSITION_BEFORE_TABLE
;
}
}
}
}
}
if
(
!
resultFrame
-
>
HasView
(
)
)
{
nsView
*
view
;
nsPoint
offset
;
resultFrame
-
>
GetOffsetFromView
(
offset
&
view
)
;
ContentOffsets
offsets
=
resultFrame
-
>
GetContentOffsetsFromPoint
(
point
-
offset
)
;
aPos
-
>
mResultContent
=
offsets
.
content
;
aPos
-
>
mContentOffset
=
offsets
.
offset
;
aPos
-
>
mAttach
=
offsets
.
associate
;
if
(
FoundValidFrame
(
offsets
resultFrame
)
)
{
found
=
true
;
break
;
}
}
if
(
aPos
-
>
mDirection
=
=
eDirPrevious
&
&
(
resultFrame
=
=
farStoppingFrame
)
)
break
;
if
(
aPos
-
>
mDirection
=
=
eDirNext
&
&
(
resultFrame
=
=
nearStoppingFrame
)
)
break
;
resultFrame
=
frameTraversal
-
>
Traverse
(
false
)
;
if
(
!
resultFrame
)
return
NS_ERROR_FAILURE
;
}
if
(
!
found
)
{
resultFrame
=
storeOldResultFrame
;
result
=
NS_NewFrameTraversal
(
getter_AddRefs
(
frameTraversal
)
aPresContext
resultFrame
eLeaf
false
aPos
-
>
mScrollViewStop
false
false
)
;
}
while
(
!
found
)
{
nsPoint
point
=
aPos
-
>
mDesiredCaretPos
;
nsView
*
view
;
nsPoint
offset
;
resultFrame
-
>
GetOffsetFromView
(
offset
&
view
)
;
ContentOffsets
offsets
=
resultFrame
-
>
GetContentOffsetsFromPoint
(
point
-
offset
)
;
aPos
-
>
mResultContent
=
offsets
.
content
;
aPos
-
>
mContentOffset
=
offsets
.
offset
;
aPos
-
>
mAttach
=
offsets
.
associate
;
if
(
FoundValidFrame
(
offsets
resultFrame
)
)
{
found
=
true
;
if
(
resultFrame
=
=
farStoppingFrame
)
aPos
-
>
mAttach
=
CARET_ASSOCIATE_BEFORE
;
else
aPos
-
>
mAttach
=
CARET_ASSOCIATE_AFTER
;
break
;
}
if
(
aPos
-
>
mDirection
=
=
eDirPrevious
&
&
(
resultFrame
=
=
nearStoppingFrame
)
)
break
;
if
(
aPos
-
>
mDirection
=
=
eDirNext
&
&
(
resultFrame
=
=
farStoppingFrame
)
)
break
;
nsIFrame
*
tempFrame
=
frameTraversal
-
>
Traverse
(
true
)
;
if
(
!
tempFrame
)
break
;
resultFrame
=
tempFrame
;
}
aPos
-
>
mResultFrame
=
resultFrame
;
}
else
{
aPos
-
>
mAmount
=
eSelectLine
;
aPos
-
>
mStartOffset
=
0
;
aPos
-
>
mAttach
=
aPos
-
>
mDirection
=
=
eDirNext
?
CARET_ASSOCIATE_BEFORE
:
CARET_ASSOCIATE_AFTER
;
if
(
aPos
-
>
mDirection
=
=
eDirPrevious
)
aPos
-
>
mStartOffset
=
-
1
;
return
aBlockFrame
-
>
PeekOffset
(
aPos
)
;
}
}
return
NS_OK
;
}
nsIFrame
:
:
CaretPosition
nsIFrame
:
:
GetExtremeCaretPosition
(
bool
aStart
)
{
CaretPosition
result
;
FrameTarget
targetFrame
=
DrillDownToSelectionFrame
(
this
!
aStart
0
)
;
FrameContentRange
range
=
GetRangeForFrame
(
targetFrame
.
frame
)
;
result
.
mResultContent
=
range
.
content
;
result
.
mContentOffset
=
aStart
?
range
.
start
:
range
.
end
;
return
result
;
}
static
nsContentAndOffset
FindLineBreakInText
(
nsIFrame
*
aFrame
nsDirection
aDirection
)
{
nsContentAndOffset
result
;
if
(
aFrame
-
>
IsGeneratedContentFrame
(
)
|
|
!
aFrame
-
>
HasSignificantTerminalNewline
(
)
)
{
return
result
;
}
int32_t
endOffset
=
aFrame
-
>
GetOffsets
(
)
.
second
;
result
.
mContent
=
aFrame
-
>
GetContent
(
)
;
result
.
mOffset
=
endOffset
-
(
aDirection
=
=
eDirPrevious
?
0
:
1
)
;
return
result
;
}
static
nsContentAndOffset
FindLineBreakingFrame
(
nsIFrame
*
aFrame
nsDirection
aDirection
)
{
nsContentAndOffset
result
;
if
(
aFrame
-
>
IsGeneratedContentFrame
(
)
)
{
return
result
;
}
if
(
static_cast
<
nsIFormControlFrame
*
>
(
do_QueryFrame
(
aFrame
)
)
)
{
return
result
;
}
if
(
(
aFrame
-
>
IsBlockOutside
(
)
&
&
!
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_PART_OF_IBSPLIT
)
)
|
|
aFrame
-
>
IsBrFrame
(
)
)
{
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
result
.
mContent
=
content
-
>
GetParent
(
)
;
NS_ASSERTION
(
result
.
mContent
"
Unexpected
orphan
content
"
)
;
if
(
result
.
mContent
)
{
result
.
mOffset
=
result
.
mContent
-
>
ComputeIndexOf_Deprecated
(
content
)
+
(
aDirection
=
=
eDirPrevious
?
1
:
0
)
;
}
return
result
;
}
result
=
FindLineBreakInText
(
aFrame
aDirection
)
;
if
(
result
.
mContent
)
{
return
result
;
}
if
(
aDirection
=
=
eDirPrevious
)
{
nsIFrame
*
child
=
aFrame
-
>
GetChildList
(
nsIFrame
:
:
kPrincipalList
)
.
LastChild
(
)
;
while
(
child
&
&
!
result
.
mContent
)
{
result
=
FindLineBreakingFrame
(
child
aDirection
)
;
child
=
child
-
>
GetPrevSibling
(
)
;
}
}
else
{
nsIFrame
*
child
=
aFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
while
(
child
&
&
!
result
.
mContent
)
{
result
=
FindLineBreakingFrame
(
child
aDirection
)
;
child
=
child
-
>
GetNextSibling
(
)
;
}
}
return
result
;
}
nsresult
nsIFrame
:
:
PeekOffsetForParagraph
(
nsPeekOffsetStruct
*
aPos
)
{
nsIFrame
*
frame
=
this
;
nsContentAndOffset
blockFrameOrBR
;
blockFrameOrBR
.
mContent
=
nullptr
;
bool
reachedLimit
=
frame
-
>
IsBlockOutside
(
)
|
|
IsEditingHost
(
frame
)
;
auto
traverse
=
[
&
aPos
]
(
nsIFrame
*
current
)
{
return
aPos
-
>
mDirection
=
=
eDirPrevious
?
current
-
>
GetPrevSibling
(
)
:
current
-
>
GetNextSibling
(
)
;
}
;
while
(
!
reachedLimit
)
{
nsIFrame
*
parent
=
frame
-
>
GetParent
(
)
;
if
(
!
frame
-
>
mContent
|
|
!
frame
-
>
mContent
-
>
GetParent
(
)
)
{
reachedLimit
=
true
;
break
;
}
if
(
aPos
-
>
mDirection
=
=
eDirNext
)
{
blockFrameOrBR
=
FindLineBreakInText
(
frame
eDirNext
)
;
}
nsIFrame
*
sibling
=
traverse
(
frame
)
;
while
(
sibling
&
&
!
blockFrameOrBR
.
mContent
)
{
blockFrameOrBR
=
FindLineBreakingFrame
(
sibling
aPos
-
>
mDirection
)
;
sibling
=
traverse
(
sibling
)
;
}
if
(
blockFrameOrBR
.
mContent
)
{
aPos
-
>
mResultContent
=
blockFrameOrBR
.
mContent
;
aPos
-
>
mContentOffset
=
blockFrameOrBR
.
mOffset
;
break
;
}
frame
=
parent
;
reachedLimit
=
frame
&
&
(
frame
-
>
IsBlockOutside
(
)
|
|
IsEditingHost
(
frame
)
)
;
}
if
(
reachedLimit
)
{
aPos
-
>
mResultContent
=
frame
-
>
GetContent
(
)
;
if
(
aPos
-
>
mDirection
=
=
eDirPrevious
)
{
aPos
-
>
mContentOffset
=
0
;
}
else
if
(
aPos
-
>
mResultContent
)
{
aPos
-
>
mContentOffset
=
aPos
-
>
mResultContent
-
>
GetChildCount
(
)
;
}
}
return
NS_OK
;
}
static
bool
IsMovingInFrameDirection
(
const
nsIFrame
*
frame
nsDirection
aDirection
bool
aVisual
)
{
bool
isReverseDirection
=
aVisual
&
&
nsBidiPresUtils
:
:
IsReversedDirectionFrame
(
frame
)
;
return
aDirection
=
=
(
isReverseDirection
?
eDirPrevious
:
eDirNext
)
;
}
static
bool
ShouldWordSelectionEatSpace
(
const
nsPeekOffsetStruct
&
aPos
)
{
if
(
aPos
.
mWordMovementType
!
=
eDefaultBehavior
)
{
return
(
aPos
.
mWordMovementType
=
=
eEndWord
)
=
=
(
aPos
.
mDirection
=
=
eDirPrevious
)
;
}
return
aPos
.
mDirection
=
=
eDirNext
&
&
StaticPrefs
:
:
layout_word_select_eat_space_to_next_word
(
)
;
}
enum
class
OffsetIsAtLineEdge
:
bool
{
No
Yes
}
;
static
void
SetPeekResultFromFrame
(
nsPeekOffsetStruct
&
aPos
nsIFrame
*
aFrame
int32_t
aOffset
OffsetIsAtLineEdge
aAtLineEdge
)
{
FrameContentRange
range
=
GetRangeForFrame
(
aFrame
)
;
aPos
.
mResultFrame
=
aFrame
;
aPos
.
mResultContent
=
range
.
content
;
aPos
.
mContentOffset
=
aOffset
<
0
?
range
.
end
+
aOffset
+
1
:
range
.
start
+
aOffset
;
if
(
aAtLineEdge
=
=
OffsetIsAtLineEdge
:
:
Yes
)
{
aPos
.
mAttach
=
aPos
.
mContentOffset
=
=
range
.
start
?
CARET_ASSOCIATE_AFTER
:
CARET_ASSOCIATE_BEFORE
;
}
}
void
nsIFrame
:
:
SelectablePeekReport
:
:
TransferTo
(
nsPeekOffsetStruct
&
aPos
)
const
{
return
SetPeekResultFromFrame
(
aPos
mFrame
mOffset
OffsetIsAtLineEdge
:
:
No
)
;
}
nsIFrame
:
:
SelectablePeekReport
:
:
SelectablePeekReport
(
const
mozilla
:
:
GenericErrorResult
<
nsresult
>
&
&
aErr
)
{
MOZ_ASSERT
(
NS_FAILED
(
aErr
.
operator
nsresult
(
)
)
)
;
}
nsresult
nsIFrame
:
:
PeekOffsetForCharacter
(
nsPeekOffsetStruct
*
aPos
int32_t
aOffset
)
{
SelectablePeekReport
current
{
this
aOffset
}
;
nsIFrame
:
:
FrameSearchResult
peekSearchState
=
CONTINUE
;
while
(
peekSearchState
!
=
FOUND
)
{
bool
movingInFrameDirection
=
IsMovingInFrameDirection
(
current
.
mFrame
aPos
-
>
mDirection
aPos
-
>
mVisual
)
;
if
(
current
.
mJumpedLine
)
{
peekSearchState
=
current
.
PeekOffsetNoAmount
(
movingInFrameDirection
)
;
}
else
{
PeekOffsetCharacterOptions
options
;
options
.
mRespectClusters
=
aPos
-
>
mAmount
=
=
eSelectCluster
;
peekSearchState
=
current
.
PeekOffsetCharacter
(
movingInFrameDirection
options
)
;
}
current
.
mMovedOverNonSelectableText
|
=
peekSearchState
=
=
CONTINUE_UNSELECTABLE
;
if
(
peekSearchState
!
=
FOUND
)
{
SelectablePeekReport
next
=
current
.
mFrame
-
>
GetFrameFromDirection
(
*
aPos
)
;
if
(
next
.
Failed
(
)
)
{
return
NS_ERROR_FAILURE
;
}
next
.
mJumpedLine
|
=
current
.
mJumpedLine
;
next
.
mMovedOverNonSelectableText
|
=
current
.
mMovedOverNonSelectableText
;
next
.
mHasSelectableFrame
|
=
current
.
mHasSelectableFrame
;
current
=
next
;
}
if
(
peekSearchState
=
=
FOUND
&
&
current
.
mMovedOverNonSelectableText
&
&
(
!
aPos
-
>
mExtend
|
|
current
.
mHasSelectableFrame
)
)
{
auto
[
start
end
]
=
current
.
mFrame
-
>
GetOffsets
(
)
;
current
.
mOffset
=
aPos
-
>
mDirection
=
=
eDirNext
?
0
:
end
-
start
;
}
}
current
.
TransferTo
(
*
aPos
)
;
if
(
current
.
mOffset
<
0
&
&
current
.
mJumpedLine
&
&
aPos
-
>
mDirection
=
=
eDirPrevious
&
&
current
.
mFrame
-
>
HasSignificantTerminalNewline
(
)
&
&
!
current
.
mIgnoredBrFrame
)
{
-
-
aPos
-
>
mContentOffset
;
}
return
NS_OK
;
}
nsresult
nsIFrame
:
:
PeekOffsetForWord
(
nsPeekOffsetStruct
*
aPos
int32_t
aOffset
)
{
SelectablePeekReport
current
{
this
aOffset
}
;
bool
shouldStopAtHardBreak
=
aPos
-
>
mWordMovementType
=
=
eDefaultBehavior
&
&
StaticPrefs
:
:
layout_word_select_eat_space_to_next_word
(
)
;
bool
wordSelectEatSpace
=
ShouldWordSelectionEatSpace
(
*
aPos
)
;
PeekWordState
state
;
while
(
true
)
{
bool
movingInFrameDirection
=
IsMovingInFrameDirection
(
current
.
mFrame
aPos
-
>
mDirection
aPos
-
>
mVisual
)
;
FrameSearchResult
searchResult
=
current
.
mFrame
-
>
PeekOffsetWord
(
movingInFrameDirection
wordSelectEatSpace
aPos
-
>
mIsKeyboardSelect
&
current
.
mOffset
&
state
aPos
-
>
mTrimSpaces
)
;
if
(
searchResult
=
=
FOUND
)
{
break
;
}
SelectablePeekReport
next
=
current
.
mFrame
-
>
GetFrameFromDirection
(
*
aPos
)
;
if
(
next
.
Failed
(
)
)
{
if
(
next
.
mJumpedLine
&
&
wordSelectEatSpace
&
&
current
.
mFrame
-
>
HasSignificantTerminalNewline
(
)
&
&
current
.
mFrame
-
>
StyleText
(
)
-
>
mWhiteSpace
!
=
StyleWhiteSpace
:
:
PreLine
)
{
current
.
mOffset
-
=
1
;
}
break
;
}
if
(
next
.
mJumpedLine
&
&
!
wordSelectEatSpace
&
&
state
.
mSawBeforeType
)
{
break
;
}
if
(
shouldStopAtHardBreak
&
&
next
.
mJumpedHardBreak
)
{
if
(
aPos
-
>
mDirection
=
=
eDirPrevious
)
{
current
.
TransferTo
(
*
aPos
)
;
current
.
mFrame
-
>
PeekOffsetForCharacter
(
aPos
current
.
mOffset
)
;
return
NS_OK
;
}
if
(
state
.
mSawInlineCharacter
|
|
current
.
mJumpedHardBreak
)
{
if
(
current
.
mFrame
-
>
HasSignificantTerminalNewline
(
)
)
{
current
.
mOffset
-
=
1
;
}
current
.
TransferTo
(
*
aPos
)
;
return
NS_OK
;
}
state
.
Update
(
false
true
)
;
}
if
(
next
.
mJumpedLine
)
{
state
.
mContext
.
Truncate
(
)
;
}
current
=
next
;
if
(
wordSelectEatSpace
&
&
next
.
mJumpedLine
)
{
state
.
SetSawBeforeType
(
)
;
}
}
current
.
TransferTo
(
*
aPos
)
;
return
NS_OK
;
}
static
nsIFrame
*
GetFirstSelectableDescendantWithLineIterator
(
nsIFrame
*
aParentFrame
bool
aForceEditableRegion
)
{
auto
FoundValidFrame
=
[
aForceEditableRegion
]
(
const
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
-
>
IsSelectable
(
nullptr
)
)
{
return
false
;
}
if
(
aForceEditableRegion
&
&
!
aFrame
-
>
GetContent
(
)
-
>
IsEditable
(
)
)
{
return
false
;
}
return
true
;
}
;
for
(
nsIFrame
*
child
:
aParentFrame
-
>
PrincipalChildList
(
)
)
{
if
(
child
-
>
CanProvideLineIterator
(
)
&
&
FoundValidFrame
(
child
)
)
{
return
child
;
}
if
(
nsIFrame
*
nested
=
GetFirstSelectableDescendantWithLineIterator
(
child
aForceEditableRegion
)
)
{
return
nested
;
}
}
return
nullptr
;
}
nsresult
nsIFrame
:
:
PeekOffsetForLine
(
nsPeekOffsetStruct
*
aPos
)
{
nsIFrame
*
blockFrame
=
this
;
nsresult
result
=
NS_ERROR_FAILURE
;
AutoAssertNoDomMutations
guard
;
while
(
NS_FAILED
(
result
)
)
{
auto
[
newBlock
lineFrame
]
=
blockFrame
-
>
GetContainingBlockForLine
(
aPos
-
>
mScrollViewStop
)
;
if
(
!
newBlock
)
{
return
NS_ERROR_FAILURE
;
}
blockFrame
=
newBlock
;
nsILineIterator
*
iter
=
blockFrame
-
>
GetLineIterator
(
)
;
int32_t
thisLine
=
iter
-
>
FindLineContaining
(
lineFrame
)
;
if
(
NS_WARN_IF
(
thisLine
<
0
)
)
{
return
NS_ERROR_FAILURE
;
}
int
edgeCase
=
0
;
bool
doneLooping
=
false
;
nsIFrame
*
lastFrame
=
this
;
do
{
result
=
nsIFrame
:
:
GetNextPrevLineFromeBlockFrame
(
PresContext
(
)
aPos
blockFrame
thisLine
edgeCase
)
;
if
(
NS_SUCCEEDED
(
result
)
&
&
(
!
aPos
-
>
mResultFrame
|
|
aPos
-
>
mResultFrame
=
=
lastFrame
)
)
{
aPos
-
>
mResultFrame
=
nullptr
;
if
(
aPos
-
>
mDirection
=
=
eDirPrevious
)
{
thisLine
-
-
;
}
else
{
thisLine
+
+
;
}
}
else
{
doneLooping
=
true
;
}
lastFrame
=
aPos
-
>
mResultFrame
;
if
(
NS_SUCCEEDED
(
result
)
&
&
aPos
-
>
mResultFrame
&
&
blockFrame
!
=
aPos
-
>
mResultFrame
)
{
bool
shouldDrillIntoChildren
=
aPos
-
>
mResultFrame
-
>
IsTableWrapperFrame
(
)
|
|
aPos
-
>
mResultFrame
-
>
IsTableCellFrame
(
)
|
|
aPos
-
>
mResultFrame
-
>
IsFlexContainerFrame
(
)
|
|
aPos
-
>
mResultFrame
-
>
IsGridContainerFrame
(
)
;
if
(
shouldDrillIntoChildren
)
{
nsIFrame
*
child
=
GetFirstSelectableDescendantWithLineIterator
(
aPos
-
>
mResultFrame
aPos
-
>
mForceEditableRegion
)
;
if
(
child
)
{
aPos
-
>
mResultFrame
=
child
;
}
}
if
(
!
aPos
-
>
mResultFrame
-
>
CanProvideLineIterator
(
)
)
{
break
;
}
doneLooping
=
false
;
if
(
aPos
-
>
mDirection
=
=
eDirPrevious
)
{
edgeCase
=
1
;
}
else
{
edgeCase
=
-
1
;
}
thisLine
=
0
;
blockFrame
=
aPos
-
>
mResultFrame
;
}
}
while
(
!
doneLooping
)
;
}
return
result
;
}
nsresult
nsIFrame
:
:
PeekOffsetForLineEdge
(
nsPeekOffsetStruct
*
aPos
)
{
nsIFrame
*
frame
=
AdjustFrameForSelectionStyles
(
this
)
;
Element
*
editingHost
=
frame
-
>
GetContent
(
)
-
>
GetEditingHost
(
)
;
auto
[
blockFrame
lineFrame
]
=
frame
-
>
GetContainingBlockForLine
(
aPos
-
>
mScrollViewStop
)
;
if
(
!
blockFrame
)
{
return
NS_ERROR_FAILURE
;
}
AutoAssertNoDomMutations
guard
;
nsILineIterator
*
it
=
blockFrame
-
>
GetLineIterator
(
)
;
int32_t
thisLine
=
it
-
>
FindLineContaining
(
lineFrame
)
;
if
(
thisLine
<
0
)
{
return
NS_ERROR_FAILURE
;
}
nsIFrame
*
baseFrame
=
nullptr
;
bool
endOfLine
=
(
eSelectEndLine
=
=
aPos
-
>
mAmount
)
;
if
(
aPos
-
>
mVisual
&
&
PresContext
(
)
-
>
BidiEnabled
(
)
)
{
nsIFrame
*
firstFrame
;
bool
isReordered
;
nsIFrame
*
lastFrame
;
MOZ_TRY
(
it
-
>
CheckLineOrder
(
thisLine
&
isReordered
&
firstFrame
&
lastFrame
)
)
;
baseFrame
=
endOfLine
?
lastFrame
:
firstFrame
;
}
else
{
auto
line
=
it
-
>
GetLine
(
thisLine
)
.
unwrap
(
)
;
nsIFrame
*
frame
=
line
.
mFirstFrameOnLine
;
bool
lastFrameWasEditable
=
false
;
for
(
int32_t
count
=
line
.
mNumFramesOnLine
;
count
;
-
-
count
frame
=
frame
-
>
GetNextSibling
(
)
)
{
if
(
frame
-
>
IsGeneratedContentFrame
(
)
)
{
continue
;
}
if
(
endOfLine
&
&
line
.
mNumFramesOnLine
>
1
&
&
frame
-
>
IsBrFrame
(
)
&
&
lastFrameWasEditable
=
=
frame
-
>
GetContent
(
)
-
>
IsEditable
(
)
)
{
continue
;
}
lastFrameWasEditable
=
frame
-
>
GetContent
(
)
&
&
frame
-
>
GetContent
(
)
-
>
IsEditable
(
)
;
baseFrame
=
frame
;
if
(
!
endOfLine
)
{
break
;
}
}
}
if
(
!
baseFrame
)
{
return
NS_ERROR_FAILURE
;
}
if
(
editingHost
)
{
if
(
nsIFrame
*
frame
=
editingHost
-
>
GetPrimaryFrame
(
)
)
{
if
(
frame
-
>
IsInlineOutside
(
)
&
&
!
editingHost
-
>
Contains
(
baseFrame
-
>
GetContent
(
)
)
)
{
baseFrame
=
frame
;
if
(
endOfLine
)
{
baseFrame
=
baseFrame
-
>
LastContinuation
(
)
;
}
}
}
}
FrameTarget
targetFrame
=
DrillDownToSelectionFrame
(
baseFrame
endOfLine
0
)
;
SetPeekResultFromFrame
(
*
aPos
targetFrame
.
frame
endOfLine
?
-
1
:
0
OffsetIsAtLineEdge
:
:
Yes
)
;
if
(
endOfLine
&
&
targetFrame
.
frame
-
>
HasSignificantTerminalNewline
(
)
)
{
-
-
aPos
-
>
mContentOffset
;
}
if
(
!
aPos
-
>
mResultContent
)
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
nsIFrame
:
:
PeekOffset
(
nsPeekOffsetStruct
*
aPos
)
{
MOZ_ASSERT
(
aPos
)
;
if
(
NS_WARN_IF
(
HasAnyStateBits
(
NS_FRAME_IS_DIRTY
)
)
)
{
return
NS_ERROR_UNEXPECTED
;
}
int32_t
offset
=
aPos
-
>
mStartOffset
-
GetRangeForFrame
(
this
)
.
start
;
switch
(
aPos
-
>
mAmount
)
{
case
eSelectCharacter
:
case
eSelectCluster
:
return
PeekOffsetForCharacter
(
aPos
offset
)
;
case
eSelectWordNoSpace
:
if
(
aPos
-
>
mDirection
=
=
eDirPrevious
)
{
aPos
-
>
mWordMovementType
=
eStartWord
;
}
else
{
aPos
-
>
mWordMovementType
=
eEndWord
;
}
[
[
fallthrough
]
]
;
case
eSelectWord
:
return
PeekOffsetForWord
(
aPos
offset
)
;
case
eSelectLine
:
return
PeekOffsetForLine
(
aPos
)
;
case
eSelectBeginLine
:
case
eSelectEndLine
:
return
PeekOffsetForLineEdge
(
aPos
)
;
case
eSelectParagraph
:
return
PeekOffsetForParagraph
(
aPos
)
;
default
:
{
NS_ASSERTION
(
false
"
Invalid
amount
"
)
;
return
NS_ERROR_FAILURE
;
}
}
}
nsIFrame
:
:
FrameSearchResult
nsIFrame
:
:
PeekOffsetNoAmount
(
bool
aForward
int32_t
*
aOffset
)
{
NS_ASSERTION
(
aOffset
&
&
*
aOffset
<
=
1
"
aOffset
out
of
range
"
)
;
return
FOUND
;
}
nsIFrame
:
:
FrameSearchResult
nsIFrame
:
:
PeekOffsetCharacter
(
bool
aForward
int32_t
*
aOffset
PeekOffsetCharacterOptions
aOptions
)
{
NS_ASSERTION
(
aOffset
&
&
*
aOffset
<
=
1
"
aOffset
out
of
range
"
)
;
int32_t
startOffset
=
*
aOffset
;
if
(
startOffset
<
0
)
startOffset
=
1
;
if
(
aForward
=
=
(
startOffset
=
=
0
)
)
{
*
aOffset
=
1
-
startOffset
;
return
FOUND
;
}
return
CONTINUE
;
}
nsIFrame
:
:
FrameSearchResult
nsIFrame
:
:
PeekOffsetWord
(
bool
aForward
bool
aWordSelectEatSpace
bool
aIsKeyboardSelect
int32_t
*
aOffset
PeekWordState
*
aState
bool
)
{
NS_ASSERTION
(
aOffset
&
&
*
aOffset
<
=
1
"
aOffset
out
of
range
"
)
;
int32_t
startOffset
=
*
aOffset
;
aState
-
>
mContext
.
Truncate
(
)
;
if
(
startOffset
<
0
)
startOffset
=
1
;
if
(
aForward
=
=
(
startOffset
=
=
0
)
)
{
if
(
!
aState
-
>
mAtStart
)
{
if
(
aState
-
>
mLastCharWasPunctuation
)
{
if
(
BreakWordBetweenPunctuation
(
aState
aForward
false
false
aIsKeyboardSelect
)
)
return
FOUND
;
}
else
{
if
(
aWordSelectEatSpace
&
&
aState
-
>
mSawBeforeType
)
return
FOUND
;
}
}
*
aOffset
=
1
-
startOffset
;
aState
-
>
Update
(
false
false
)
;
if
(
!
aWordSelectEatSpace
)
aState
-
>
SetSawBeforeType
(
)
;
}
return
CONTINUE
;
}
bool
nsIFrame
:
:
BreakWordBetweenPunctuation
(
const
PeekWordState
*
aState
bool
aForward
bool
aPunctAfter
bool
aWhitespaceAfter
bool
aIsKeyboardSelect
)
{
NS_ASSERTION
(
aPunctAfter
!
=
aState
-
>
mLastCharWasPunctuation
"
Call
this
only
at
punctuation
boundaries
"
)
;
if
(
aState
-
>
mLastCharWasWhitespace
)
{
return
true
;
}
if
(
!
StaticPrefs
:
:
layout_word_select_stop_at_punctuation
(
)
)
{
return
aWhitespaceAfter
;
}
if
(
!
aIsKeyboardSelect
)
{
return
true
;
}
bool
afterPunct
=
aForward
?
aState
-
>
mLastCharWasPunctuation
:
aPunctAfter
;
if
(
!
afterPunct
)
{
return
false
;
}
return
aState
-
>
mSeenNonPunctuationSinceWhitespace
;
}
nsresult
nsIFrame
:
:
CheckVisibility
(
nsPresContext
*
int32_t
int32_t
bool
bool
*
bool
*
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
std
:
:
pair
<
nsIFrame
*
nsIFrame
*
>
nsIFrame
:
:
GetContainingBlockForLine
(
bool
aLockScroll
)
const
{
const
nsIFrame
*
parentFrame
=
this
;
const
nsIFrame
*
frame
;
while
(
parentFrame
)
{
frame
=
parentFrame
;
if
(
frame
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
)
{
if
(
frame
-
>
HasAnyStateBits
(
NS_FRAME_IS_OVERFLOW_CONTAINER
)
)
{
frame
=
frame
-
>
FirstInFlow
(
)
;
}
frame
=
frame
-
>
GetPlaceholderFrame
(
)
;
if
(
!
frame
)
{
return
std
:
:
pair
(
nullptr
nullptr
)
;
}
}
parentFrame
=
frame
-
>
GetParent
(
)
;
if
(
parentFrame
)
{
if
(
aLockScroll
&
&
parentFrame
-
>
IsScrollFrame
(
)
)
{
return
std
:
:
pair
(
nullptr
nullptr
)
;
}
if
(
parentFrame
-
>
CanProvideLineIterator
(
)
)
{
return
std
:
:
pair
(
const_cast
<
nsIFrame
*
>
(
parentFrame
)
const_cast
<
nsIFrame
*
>
(
frame
)
)
;
}
}
}
return
std
:
:
pair
(
nullptr
nullptr
)
;
}
Result
<
bool
nsresult
>
nsIFrame
:
:
IsVisuallyAtLineEdge
(
nsILineIterator
*
aLineIterator
int32_t
aLine
nsDirection
aDirection
)
{
nsIFrame
*
firstFrame
;
nsIFrame
*
lastFrame
;
bool
lineIsRTL
=
aLineIterator
-
>
GetDirection
(
)
;
bool
isReordered
;
MOZ_TRY
(
aLineIterator
-
>
CheckLineOrder
(
aLine
&
isReordered
&
firstFrame
&
lastFrame
)
)
;
nsIFrame
*
*
framePtr
=
aDirection
=
=
eDirPrevious
?
&
firstFrame
:
&
lastFrame
;
if
(
!
*
framePtr
)
{
return
true
;
}
bool
frameIsRTL
=
(
nsBidiPresUtils
:
:
FrameDirection
(
*
framePtr
)
=
=
mozilla
:
:
intl
:
:
BidiDirection
:
:
RTL
)
;
if
(
(
frameIsRTL
=
=
lineIsRTL
)
=
=
(
aDirection
=
=
eDirPrevious
)
)
{
nsIFrame
:
:
GetFirstLeaf
(
framePtr
)
;
}
else
{
nsIFrame
:
:
GetLastLeaf
(
framePtr
)
;
}
return
*
framePtr
=
=
this
;
}
Result
<
bool
nsresult
>
nsIFrame
:
:
IsLogicallyAtLineEdge
(
nsILineIterator
*
aLineIterator
int32_t
aLine
nsDirection
aDirection
)
{
auto
line
=
aLineIterator
-
>
GetLine
(
aLine
)
.
unwrap
(
)
;
if
(
aDirection
=
=
eDirPrevious
)
{
nsIFrame
*
firstFrame
=
line
.
mFirstFrameOnLine
;
nsIFrame
:
:
GetFirstLeaf
(
&
firstFrame
)
;
return
firstFrame
=
=
this
;
}
nsIFrame
*
lastFrame
=
line
.
mFirstFrameOnLine
;
for
(
int32_t
lineFrameCount
=
line
.
mNumFramesOnLine
;
lineFrameCount
>
1
;
lineFrameCount
-
-
)
{
lastFrame
=
lastFrame
-
>
GetNextSibling
(
)
;
if
(
!
lastFrame
)
{
NS_ERROR
(
"
should
not
be
reached
nsIFrame
"
)
;
return
Err
(
NS_ERROR_FAILURE
)
;
}
}
nsIFrame
:
:
GetLastLeaf
(
&
lastFrame
)
;
return
lastFrame
=
=
this
;
}
nsIFrame
:
:
SelectablePeekReport
nsIFrame
:
:
GetFrameFromDirection
(
nsDirection
aDirection
bool
aVisual
bool
aJumpLines
bool
aScrollViewStop
bool
aForceEditableRegion
)
{
SelectablePeekReport
result
;
nsPresContext
*
presContext
=
PresContext
(
)
;
bool
needsVisualTraversal
=
aVisual
&
&
presContext
-
>
BidiEnabled
(
)
;
nsCOMPtr
<
nsIFrameEnumerator
>
frameTraversal
;
MOZ_TRY
(
NS_NewFrameTraversal
(
getter_AddRefs
(
frameTraversal
)
presContext
this
eLeaf
needsVisualTraversal
aScrollViewStop
true
false
)
)
;
bool
selectable
=
false
;
nsIFrame
*
traversedFrame
=
this
;
AutoAssertNoDomMutations
guard
;
while
(
!
selectable
)
{
auto
[
blockFrame
lineFrame
]
=
traversedFrame
-
>
GetContainingBlockForLine
(
aScrollViewStop
)
;
if
(
!
blockFrame
)
{
return
result
;
}
nsILineIterator
*
it
=
blockFrame
-
>
GetLineIterator
(
)
;
int32_t
thisLine
=
it
-
>
FindLineContaining
(
lineFrame
)
;
if
(
thisLine
<
0
)
{
return
result
;
}
bool
atLineEdge
;
MOZ_TRY_VAR
(
atLineEdge
needsVisualTraversal
?
traversedFrame
-
>
IsVisuallyAtLineEdge
(
it
thisLine
aDirection
)
:
traversedFrame
-
>
IsLogicallyAtLineEdge
(
it
thisLine
aDirection
)
)
;
if
(
atLineEdge
)
{
result
.
mJumpedLine
=
true
;
if
(
!
aJumpLines
)
{
return
result
;
}
int32_t
lineToCheckWrap
=
aDirection
=
=
eDirPrevious
?
thisLine
-
1
:
thisLine
;
if
(
lineToCheckWrap
<
0
|
|
!
it
-
>
GetLine
(
lineToCheckWrap
)
.
unwrap
(
)
.
mIsWrapped
)
{
result
.
mJumpedHardBreak
=
true
;
}
}
traversedFrame
=
frameTraversal
-
>
Traverse
(
aDirection
=
=
eDirNext
)
;
if
(
!
traversedFrame
)
{
return
result
;
}
auto
IsSelectable
=
[
aForceEditableRegion
]
(
const
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
-
>
IsSelectable
(
nullptr
)
)
{
return
false
;
}
return
!
aForceEditableRegion
|
|
aFrame
-
>
GetContent
(
)
-
>
IsEditable
(
)
;
}
;
if
(
atLineEdge
&
&
aDirection
=
=
eDirPrevious
&
&
traversedFrame
-
>
IsBrFrame
(
)
)
{
for
(
nsIFrame
*
current
=
traversedFrame
-
>
GetPrevSibling
(
)
;
current
;
current
=
current
-
>
GetPrevSibling
(
)
)
{
if
(
!
current
-
>
IsBlockOutside
(
)
&
&
IsSelectable
(
current
)
)
{
if
(
!
current
-
>
IsBrFrame
(
)
)
{
result
.
mIgnoredBrFrame
=
true
;
}
break
;
}
}
if
(
result
.
mIgnoredBrFrame
)
{
continue
;
}
}
selectable
=
IsSelectable
(
traversedFrame
)
;
if
(
!
selectable
)
{
if
(
traversedFrame
-
>
IsSelectable
(
nullptr
)
)
{
result
.
mHasSelectableFrame
=
true
;
}
result
.
mMovedOverNonSelectableText
=
true
;
}
}
result
.
mOffset
=
(
aDirection
=
=
eDirNext
)
?
0
:
-
1
;
if
(
aVisual
&
&
nsBidiPresUtils
:
:
IsReversedDirectionFrame
(
traversedFrame
)
)
{
result
.
mOffset
=
-
1
-
result
.
mOffset
;
}
result
.
mFrame
=
traversedFrame
;
return
result
;
}
nsIFrame
:
:
SelectablePeekReport
nsIFrame
:
:
GetFrameFromDirection
(
const
nsPeekOffsetStruct
&
aPos
)
{
return
GetFrameFromDirection
(
aPos
.
mDirection
aPos
.
mVisual
aPos
.
mJumpLines
aPos
.
mScrollViewStop
aPos
.
mForceEditableRegion
)
;
}
nsView
*
nsIFrame
:
:
GetClosestView
(
nsPoint
*
aOffset
)
const
{
nsPoint
offset
(
0
0
)
;
for
(
const
nsIFrame
*
f
=
this
;
f
;
f
=
f
-
>
GetParent
(
)
)
{
if
(
f
-
>
HasView
(
)
)
{
if
(
aOffset
)
*
aOffset
=
offset
;
return
f
-
>
GetView
(
)
;
}
offset
+
=
f
-
>
GetPosition
(
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
No
view
on
any
parent
?
How
did
that
happen
?
"
)
;
return
nullptr
;
}
void
nsIFrame
:
:
ChildIsDirty
(
nsIFrame
*
aChild
)
{
MOZ_ASSERT_UNREACHABLE
(
"
should
never
be
called
on
a
frame
that
doesn
'
t
"
"
inherit
from
nsContainerFrame
"
)
;
}
#
ifdef
ACCESSIBILITY
a11y
:
:
AccType
nsIFrame
:
:
AccessibleType
(
)
{
if
(
IsTableCaption
(
)
&
&
!
GetRect
(
)
.
IsEmpty
(
)
)
{
return
a11y
:
:
eHTMLCaptionType
;
}
return
a11y
:
:
eNoType
;
}
#
endif
bool
nsIFrame
:
:
ClearOverflowRects
(
)
{
if
(
mOverflow
.
mType
=
=
OverflowStorageType
:
:
None
)
{
return
false
;
}
if
(
mOverflow
.
mType
=
=
OverflowStorageType
:
:
Large
)
{
RemoveProperty
(
OverflowAreasProperty
(
)
)
;
}
mOverflow
.
mType
=
OverflowStorageType
:
:
None
;
return
true
;
}
bool
nsIFrame
:
:
SetOverflowAreas
(
const
OverflowAreas
&
aOverflowAreas
)
{
if
(
mOverflow
.
mType
=
=
OverflowStorageType
:
:
Large
)
{
OverflowAreas
*
overflow
=
GetOverflowAreasProperty
(
)
;
bool
changed
=
*
overflow
!
=
aOverflowAreas
;
*
overflow
=
aOverflowAreas
;
return
changed
;
}
const
nsRect
&
vis
=
aOverflowAreas
.
InkOverflow
(
)
;
uint32_t
l
=
-
vis
.
x
t
=
-
vis
.
y
r
=
vis
.
XMost
(
)
-
mRect
.
width
b
=
vis
.
YMost
(
)
-
mRect
.
height
;
if
(
aOverflowAreas
.
ScrollableOverflow
(
)
.
IsEqualEdges
(
nsRect
(
nsPoint
(
0
0
)
GetSize
(
)
)
)
&
&
l
<
=
InkOverflowDeltas
:
:
kMax
&
&
t
<
=
InkOverflowDeltas
:
:
kMax
&
&
r
<
=
InkOverflowDeltas
:
:
kMax
&
&
b
<
=
InkOverflowDeltas
:
:
kMax
&
&
(
l
|
t
|
r
|
b
)
!
=
0
)
{
InkOverflowDeltas
oldDeltas
=
mOverflow
.
mInkOverflowDeltas
;
mOverflow
.
mInkOverflowDeltas
.
mLeft
=
l
;
mOverflow
.
mInkOverflowDeltas
.
mTop
=
t
;
mOverflow
.
mInkOverflowDeltas
.
mRight
=
r
;
mOverflow
.
mInkOverflowDeltas
.
mBottom
=
b
;
return
oldDeltas
!
=
mOverflow
.
mInkOverflowDeltas
;
}
else
{
bool
changed
=
!
aOverflowAreas
.
ScrollableOverflow
(
)
.
IsEqualEdges
(
nsRect
(
nsPoint
(
0
0
)
GetSize
(
)
)
)
|
|
!
aOverflowAreas
.
InkOverflow
(
)
.
IsEqualEdges
(
InkOverflowFromDeltas
(
)
)
;
mOverflow
.
mType
=
OverflowStorageType
:
:
Large
;
AddProperty
(
OverflowAreasProperty
(
)
new
OverflowAreas
(
aOverflowAreas
)
)
;
return
changed
;
}
}
enum
class
ApplyTransform
:
bool
{
No
Yes
}
;
static
nsRect
ComputeOutlineInnerRect
(
nsIFrame
*
aFrame
ApplyTransform
aApplyTransform
bool
&
aOutValid
const
nsSize
*
aSizeOverride
=
nullptr
const
OverflowAreas
*
aOverflowOverride
=
nullptr
)
{
const
nsRect
bounds
(
nsPoint
(
0
0
)
aSizeOverride
?
*
aSizeOverride
:
aFrame
-
>
GetSize
(
)
)
;
aOutValid
=
!
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_SVG_LAYOUT
)
|
|
!
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVGContainer
)
|
|
aFrame
-
>
IsSVGTextFrame
(
)
;
nsRect
u
;
if
(
!
aFrame
-
>
FrameMaintainsOverflow
(
)
)
{
return
u
;
}
bool
doTransform
=
aApplyTransform
=
=
ApplyTransform
:
:
Yes
&
&
aFrame
-
>
IsTransformed
(
)
;
TransformReferenceBox
boundsRefBox
(
nullptr
bounds
)
;
if
(
doTransform
)
{
u
=
nsDisplayTransform
:
:
TransformRect
(
bounds
aFrame
boundsRefBox
)
;
}
else
{
u
=
bounds
;
}
if
(
aOutValid
&
&
!
StaticPrefs
:
:
layout_outline_include_overflow
(
)
)
{
return
u
;
}
if
(
aOverflowOverride
)
{
if
(
!
doTransform
&
&
bounds
.
IsEqualEdges
(
aOverflowOverride
-
>
InkOverflow
(
)
)
&
&
bounds
.
IsEqualEdges
(
aOverflowOverride
-
>
ScrollableOverflow
(
)
)
)
{
return
u
;
}
}
else
{
if
(
!
doTransform
&
&
bounds
.
IsEqualEdges
(
aFrame
-
>
InkOverflowRect
(
)
)
&
&
bounds
.
IsEqualEdges
(
aFrame
-
>
ScrollableOverflowRect
(
)
)
)
{
return
u
;
}
}
const
nsStyleDisplay
*
disp
=
aFrame
-
>
StyleDisplay
(
)
;
LayoutFrameType
fType
=
aFrame
-
>
Type
(
)
;
if
(
fType
=
=
LayoutFrameType
:
:
Scroll
|
|
fType
=
=
LayoutFrameType
:
:
ListControl
|
|
fType
=
=
LayoutFrameType
:
:
SVGOuterSVG
)
{
return
u
;
}
auto
overflowClipAxes
=
aFrame
-
>
ShouldApplyOverflowClipping
(
disp
)
;
auto
overflowClipMargin
=
aFrame
-
>
OverflowClipMargin
(
overflowClipAxes
)
;
if
(
overflowClipAxes
=
=
nsIFrame
:
:
PhysicalAxes
:
:
Both
&
&
overflowClipMargin
=
=
nsSize
(
)
)
{
return
u
;
}
const
nsStyleEffects
*
effects
=
aFrame
-
>
StyleEffects
(
)
;
Maybe
<
nsRect
>
clipPropClipRect
=
aFrame
-
>
GetClipPropClipRect
(
disp
effects
bounds
.
Size
(
)
)
;
const
nsIFrame
:
:
ChildListIDs
skip
=
{
nsIFrame
:
:
kPopupList
nsIFrame
:
:
kAbsoluteList
nsIFrame
:
:
kFixedList
nsIFrame
:
:
kFloatList
nsIFrame
:
:
kOverflowList
}
;
for
(
const
auto
&
[
list
listID
]
:
aFrame
-
>
ChildLists
(
)
)
{
if
(
skip
.
contains
(
listID
)
)
{
continue
;
}
for
(
nsIFrame
*
child
:
list
)
{
if
(
child
-
>
IsPlaceholderFrame
(
)
)
{
continue
;
}
bool
validRect
=
true
;
nsRect
childRect
=
ComputeOutlineInnerRect
(
child
ApplyTransform
:
:
Yes
validRect
)
+
child
-
>
GetPosition
(
)
;
if
(
!
validRect
)
{
continue
;
}
if
(
clipPropClipRect
)
{
childRect
.
IntersectRect
(
childRect
*
clipPropClipRect
)
;
}
if
(
doTransform
&
&
!
child
-
>
Combines3DTransformWithAncestors
(
)
)
{
childRect
=
nsDisplayTransform
:
:
TransformRect
(
childRect
aFrame
boundsRefBox
)
;
}
if
(
!
aOutValid
&
&
validRect
)
{
u
=
childRect
;
aOutValid
=
true
;
}
else
{
u
=
u
.
UnionEdges
(
childRect
)
;
}
}
}
if
(
overflowClipAxes
!
=
nsIFrame
:
:
PhysicalAxes
:
:
None
)
{
OverflowAreas
:
:
ApplyOverflowClippingOnRect
(
u
bounds
overflowClipAxes
overflowClipMargin
)
;
}
return
u
;
}
static
void
ComputeAndIncludeOutlineArea
(
nsIFrame
*
aFrame
OverflowAreas
&
aOverflowAreas
const
nsSize
&
aNewSize
)
{
const
nsStyleOutline
*
outline
=
aFrame
-
>
StyleOutline
(
)
;
if
(
!
outline
-
>
ShouldPaintOutline
(
)
)
{
return
;
}
nsIFrame
*
frameForArea
=
aFrame
;
do
{
PseudoStyleType
pseudoType
=
frameForArea
-
>
Style
(
)
-
>
GetPseudoType
(
)
;
if
(
pseudoType
!
=
PseudoStyleType
:
:
mozBlockInsideInlineWrapper
)
break
;
frameForArea
=
frameForArea
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
NS_ASSERTION
(
frameForArea
"
anonymous
block
with
no
children
?
"
)
;
}
while
(
frameForArea
)
;
nsRect
innerRect
;
bool
validRect
=
false
;
if
(
frameForArea
=
=
aFrame
)
{
innerRect
=
ComputeOutlineInnerRect
(
aFrame
ApplyTransform
:
:
No
validRect
&
aNewSize
&
aOverflowAreas
)
;
}
else
{
for
(
;
frameForArea
;
frameForArea
=
frameForArea
-
>
GetNextSibling
(
)
)
{
nsRect
r
=
ComputeOutlineInnerRect
(
frameForArea
ApplyTransform
:
:
Yes
validRect
)
;
for
(
nsIFrame
*
f
=
frameForArea
*
parent
=
f
-
>
GetParent
(
)
;
;
f
=
parent
parent
=
f
-
>
GetParent
(
)
)
{
r
+
=
f
-
>
GetPosition
(
)
;
if
(
parent
=
=
aFrame
)
{
break
;
}
if
(
parent
-
>
IsTransformed
(
)
&
&
!
f
-
>
Combines3DTransformWithAncestors
(
)
)
{
TransformReferenceBox
refBox
(
parent
)
;
r
=
nsDisplayTransform
:
:
TransformRect
(
r
parent
refBox
)
;
}
}
innerRect
.
UnionRect
(
innerRect
r
)
;
}
}
if
(
innerRect
=
=
aFrame
-
>
GetRectRelativeToSelf
(
)
)
{
aFrame
-
>
RemoveProperty
(
nsIFrame
:
:
OutlineInnerRectProperty
(
)
)
;
}
else
{
SetOrUpdateRectValuedProperty
(
aFrame
nsIFrame
:
:
OutlineInnerRectProperty
(
)
innerRect
)
;
}
const
nscoord
offset
=
outline
-
>
mOutlineOffset
.
ToAppUnits
(
)
;
nsRect
outerRect
(
innerRect
)
;
if
(
outline
-
>
mOutlineStyle
.
IsAuto
(
)
)
{
nsPresContext
*
pc
=
aFrame
-
>
PresContext
(
)
;
outerRect
.
Inflate
(
offset
)
;
pc
-
>
Theme
(
)
-
>
GetWidgetOverflow
(
pc
-
>
DeviceContext
(
)
aFrame
StyleAppearance
:
:
FocusOutline
&
outerRect
)
;
}
else
{
nscoord
width
=
outline
-
>
GetOutlineWidth
(
)
;
outerRect
.
Inflate
(
width
+
offset
)
;
}
nsRect
&
vo
=
aOverflowAreas
.
InkOverflow
(
)
;
vo
=
vo
.
UnionEdges
(
innerRect
.
Union
(
outerRect
)
)
;
}
bool
nsIFrame
:
:
FinishAndStoreOverflow
(
OverflowAreas
&
aOverflowAreas
nsSize
aNewSize
nsSize
*
aOldSize
const
nsStyleDisplay
*
aStyleDisplay
)
{
MOZ_ASSERT
(
FrameMaintainsOverflow
(
)
"
Don
'
t
call
-
overflow
rects
not
maintained
on
these
SVG
frames
"
)
;
const
nsStyleDisplay
*
disp
=
StyleDisplayWithOptionalParam
(
aStyleDisplay
)
;
bool
hasTransform
=
IsTransformed
(
)
;
nsRect
bounds
(
nsPoint
(
0
0
)
aNewSize
)
;
if
(
hasTransform
|
|
Combines3DTransformWithAncestors
(
)
)
{
if
(
!
aOverflowAreas
.
InkOverflow
(
)
.
IsEqualEdges
(
bounds
)
|
|
!
aOverflowAreas
.
ScrollableOverflow
(
)
.
IsEqualEdges
(
bounds
)
)
{
OverflowAreas
*
initial
=
GetProperty
(
nsIFrame
:
:
InitialOverflowProperty
(
)
)
;
if
(
!
initial
)
{
AddProperty
(
nsIFrame
:
:
InitialOverflowProperty
(
)
new
OverflowAreas
(
aOverflowAreas
)
)
;
}
else
if
(
initial
!
=
&
aOverflowAreas
)
{
*
initial
=
aOverflowAreas
;
}
}
else
{
RemoveProperty
(
nsIFrame
:
:
InitialOverflowProperty
(
)
)
;
}
#
ifdef
DEBUG
SetProperty
(
nsIFrame
:
:
DebugInitialOverflowPropertyApplied
(
)
true
)
;
#
endif
}
else
{
#
ifdef
DEBUG
RemoveProperty
(
nsIFrame
:
:
DebugInitialOverflowPropertyApplied
(
)
)
;
#
endif
}
nsSize
oldSize
=
mRect
.
Size
(
)
;
bool
sizeChanged
=
(
(
aOldSize
?
*
aOldSize
:
oldSize
)
!
=
aNewSize
)
;
SetSize
(
aNewSize
false
)
;
const
auto
overflowClipAxes
=
ShouldApplyOverflowClipping
(
disp
)
;
if
(
ChildrenHavePerspective
(
disp
)
&
&
sizeChanged
)
{
RecomputePerspectiveChildrenOverflow
(
this
)
;
if
(
overflowClipAxes
!
=
PhysicalAxes
:
:
Both
)
{
aOverflowAreas
.
SetAllTo
(
bounds
)
;
DebugOnly
<
bool
>
ok
=
ComputeCustomOverflow
(
aOverflowAreas
)
;
MOZ_ASSERT
(
ok
"
FrameMaintainsOverflow
(
)
!
=
ComputeCustomOverflow
(
)
"
)
;
UnionChildOverflow
(
aOverflowAreas
)
;
}
}
for
(
const
auto
otype
:
AllOverflowTypes
(
)
)
{
DebugOnly
<
nsRect
*
>
r
=
&
aOverflowAreas
.
Overflow
(
otype
)
;
NS_ASSERTION
(
aNewSize
.
width
=
=
0
|
|
aNewSize
.
height
=
=
0
|
|
r
-
>
width
=
=
nscoord_MAX
|
|
r
-
>
height
=
=
nscoord_MAX
|
|
(
mState
&
NS_FRAME_SVG_LAYOUT
)
|
|
r
-
>
Contains
(
nsRect
(
nsPoint
(
0
0
)
aNewSize
)
)
"
Computed
overflow
area
must
contain
frame
bounds
"
)
;
}
const
bool
shouldIncludeBounds
=
[
&
]
{
if
(
aNewSize
.
width
=
=
0
&
&
IsInlineFrame
(
)
)
{
return
false
;
}
if
(
HasAnyStateBits
(
NS_FRAME_SVG_LAYOUT
)
)
{
return
overflowClipAxes
!
=
PhysicalAxes
:
:
None
;
}
return
true
;
}
(
)
;
if
(
shouldIncludeBounds
)
{
for
(
const
auto
otype
:
AllOverflowTypes
(
)
)
{
nsRect
&
o
=
aOverflowAreas
.
Overflow
(
otype
)
;
o
=
o
.
UnionEdges
(
bounds
)
;
}
}
if
(
overflowClipAxes
!
=
PhysicalAxes
:
:
None
)
{
aOverflowAreas
.
ApplyClipping
(
bounds
overflowClipAxes
OverflowClipMargin
(
overflowClipAxes
)
)
;
}
if
(
!
:
:
IsXULBoxWrapped
(
this
)
&
&
IsThemed
(
disp
)
)
{
nsRect
r
(
bounds
)
;
nsPresContext
*
presContext
=
PresContext
(
)
;
if
(
presContext
-
>
Theme
(
)
-
>
GetWidgetOverflow
(
presContext
-
>
DeviceContext
(
)
this
disp
-
>
EffectiveAppearance
(
)
&
r
)
)
{
nsRect
&
vo
=
aOverflowAreas
.
InkOverflow
(
)
;
vo
=
vo
.
UnionEdges
(
r
)
;
}
}
ComputeAndIncludeOutlineArea
(
this
aOverflowAreas
aNewSize
)
;
aOverflowAreas
.
InkOverflow
(
)
=
ComputeEffectsRect
(
this
aOverflowAreas
.
InkOverflow
(
)
aNewSize
)
;
const
nsStyleEffects
*
effects
=
StyleEffects
(
)
;
Maybe
<
nsRect
>
clipPropClipRect
=
GetClipPropClipRect
(
disp
effects
aNewSize
)
;
if
(
clipPropClipRect
)
{
for
(
const
auto
otype
:
AllOverflowTypes
(
)
)
{
nsRect
&
o
=
aOverflowAreas
.
Overflow
(
otype
)
;
o
.
IntersectRect
(
o
*
clipPropClipRect
)
;
}
}
if
(
hasTransform
)
{
SetProperty
(
nsIFrame
:
:
PreTransformOverflowAreasProperty
(
)
new
OverflowAreas
(
aOverflowAreas
)
)
;
if
(
Combines3DTransformWithAncestors
(
)
)
{
aOverflowAreas
.
SetAllTo
(
nsRect
(
)
)
;
}
else
{
TransformReferenceBox
refBox
(
this
)
;
for
(
const
auto
otype
:
AllOverflowTypes
(
)
)
{
nsRect
&
o
=
aOverflowAreas
.
Overflow
(
otype
)
;
o
=
nsDisplayTransform
:
:
TransformRect
(
o
this
refBox
)
;
}
if
(
Extend3DContext
(
disp
effects
)
)
{
ComputePreserve3DChildrenOverflow
(
aOverflowAreas
)
;
}
}
}
else
{
RemoveProperty
(
nsIFrame
:
:
PreTransformOverflowAreasProperty
(
)
)
;
}
SetSize
(
oldSize
false
)
;
bool
anyOverflowChanged
;
if
(
aOverflowAreas
!
=
OverflowAreas
(
bounds
bounds
)
)
{
anyOverflowChanged
=
SetOverflowAreas
(
aOverflowAreas
)
;
}
else
{
anyOverflowChanged
=
ClearOverflowRects
(
)
;
}
if
(
anyOverflowChanged
)
{
SVGObserverUtils
:
:
InvalidateDirectRenderingObservers
(
this
)
;
if
(
IsBlockFrameOrSubclass
(
)
&
&
TextOverflow
:
:
CanHaveOverflowMarkers
(
this
)
)
{
DiscardDisplayItems
(
this
[
]
(
nsDisplayItem
*
aItem
)
{
return
aItem
-
>
GetType
(
)
=
=
DisplayItemType
:
:
TYPE_TEXT_OVERFLOW
;
}
)
;
SchedulePaint
(
PAINT_DEFAULT
)
;
}
}
return
anyOverflowChanged
;
}
void
nsIFrame
:
:
RecomputePerspectiveChildrenOverflow
(
const
nsIFrame
*
aStartFrame
)
{
for
(
const
auto
&
childList
:
ChildLists
(
)
)
{
for
(
nsIFrame
*
child
:
childList
.
mList
)
{
if
(
!
child
-
>
FrameMaintainsOverflow
(
)
)
{
continue
;
}
if
(
child
-
>
HasPerspective
(
)
)
{
OverflowAreas
*
overflow
=
child
-
>
GetProperty
(
nsIFrame
:
:
InitialOverflowProperty
(
)
)
;
nsRect
bounds
(
nsPoint
(
0
0
)
child
-
>
GetSize
(
)
)
;
if
(
overflow
)
{
OverflowAreas
overflowCopy
=
*
overflow
;
child
-
>
FinishAndStoreOverflow
(
overflowCopy
bounds
.
Size
(
)
)
;
}
else
{
OverflowAreas
boundsOverflow
;
boundsOverflow
.
SetAllTo
(
bounds
)
;
child
-
>
FinishAndStoreOverflow
(
boundsOverflow
bounds
.
Size
(
)
)
;
}
}
else
if
(
child
-
>
GetContent
(
)
=
=
aStartFrame
-
>
GetContent
(
)
|
|
child
-
>
GetClosestFlattenedTreeAncestorPrimaryFrame
(
)
=
=
aStartFrame
)
{
child
-
>
RecomputePerspectiveChildrenOverflow
(
aStartFrame
)
;
}
}
}
}
void
nsIFrame
:
:
ComputePreserve3DChildrenOverflow
(
OverflowAreas
&
aOverflowAreas
)
{
nsRect
childVisual
;
nsRect
childScrollable
;
for
(
const
auto
&
childList
:
ChildLists
(
)
)
{
for
(
nsIFrame
*
child
:
childList
.
mList
)
{
if
(
child
-
>
Combines3DTransformWithAncestors
(
)
)
{
OverflowAreas
childOverflow
=
child
-
>
GetOverflowAreasRelativeToSelf
(
)
;
TransformReferenceBox
refBox
(
child
)
;
for
(
const
auto
otype
:
AllOverflowTypes
(
)
)
{
nsRect
&
o
=
childOverflow
.
Overflow
(
otype
)
;
o
=
nsDisplayTransform
:
:
TransformRect
(
o
child
refBox
)
;
}
aOverflowAreas
.
UnionWith
(
childOverflow
)
;
if
(
child
-
>
Extend3DContext
(
)
)
{
child
-
>
ComputePreserve3DChildrenOverflow
(
aOverflowAreas
)
;
}
}
}
}
}
bool
nsIFrame
:
:
ZIndexApplies
(
)
const
{
return
StyleDisplay
(
)
-
>
IsPositionedStyle
(
)
|
|
IsFlexOrGridItem
(
)
|
|
IsMenuPopupFrame
(
)
;
}
Maybe
<
int32_t
>
nsIFrame
:
:
ZIndex
(
)
const
{
if
(
!
ZIndexApplies
(
)
)
{
return
Nothing
(
)
;
}
const
auto
&
zIndex
=
StylePosition
(
)
-
>
mZIndex
;
if
(
zIndex
.
IsAuto
(
)
)
{
return
Nothing
(
)
;
}
return
Some
(
zIndex
.
AsInteger
(
)
)
;
}
bool
nsIFrame
:
:
IsScrollAnchor
(
ScrollAnchorContainer
*
*
aOutContainer
)
{
if
(
!
mInScrollAnchorChain
)
{
return
false
;
}
nsIFrame
*
f
=
this
;
while
(
auto
*
container
=
ScrollAnchorContainer
:
:
FindFor
(
f
)
)
{
if
(
nsIFrame
*
anchor
=
container
-
>
AnchorNode
(
)
)
{
if
(
anchor
!
=
this
)
{
return
false
;
}
if
(
aOutContainer
)
{
*
aOutContainer
=
container
;
}
return
true
;
}
f
=
container
-
>
Frame
(
)
;
}
return
false
;
}
bool
nsIFrame
:
:
IsInScrollAnchorChain
(
)
const
{
return
mInScrollAnchorChain
;
}
void
nsIFrame
:
:
SetInScrollAnchorChain
(
bool
aInChain
)
{
mInScrollAnchorChain
=
aInChain
;
}
uint32_t
nsIFrame
:
:
GetDepthInFrameTree
(
)
const
{
uint32_t
result
=
0
;
for
(
nsContainerFrame
*
ancestor
=
GetParent
(
)
;
ancestor
;
ancestor
=
ancestor
-
>
GetParent
(
)
)
{
result
+
+
;
}
return
result
;
}
static
nsIFrame
*
GetIBSplitSiblingForAnonymousBlock
(
const
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
"
Must
have
a
non
-
null
frame
!
"
)
;
NS_ASSERTION
(
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_PART_OF_IBSPLIT
)
"
GetIBSplitSibling
should
only
be
called
on
ib
-
split
frames
"
)
;
if
(
aFrame
-
>
Style
(
)
-
>
GetPseudoType
(
)
!
=
PseudoStyleType
:
:
mozBlockInsideInlineWrapper
)
{
return
nullptr
;
}
aFrame
=
aFrame
-
>
FirstContinuation
(
)
;
nsIFrame
*
ibSplitSibling
=
aFrame
-
>
GetProperty
(
nsIFrame
:
:
IBSplitPrevSibling
(
)
)
;
NS_ASSERTION
(
ibSplitSibling
"
Broken
frame
tree
?
"
)
;
return
ibSplitSibling
;
}
static
nsIFrame
*
GetCorrectedParent
(
const
nsIFrame
*
aFrame
)
{
nsIFrame
*
parent
=
aFrame
-
>
GetParent
(
)
;
if
(
!
parent
)
{
return
nullptr
;
}
if
(
aFrame
-
>
IsTableCaption
(
)
)
{
nsIFrame
*
innerTable
=
parent
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
!
innerTable
-
>
Style
(
)
-
>
IsAnonBox
(
)
)
{
return
innerTable
;
}
}
auto
pseudo
=
aFrame
-
>
Style
(
)
-
>
GetPseudoType
(
)
;
if
(
pseudo
=
=
PseudoStyleType
:
:
tableWrapper
)
{
pseudo
=
aFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
-
>
Style
(
)
-
>
GetPseudoType
(
)
;
}
if
(
pseudo
!
=
PseudoStyleType
:
:
NotPseudo
)
{
MOZ_ASSERT
(
aFrame
-
>
GetContent
(
)
)
;
Element
*
element
=
Element
:
:
FromNode
(
aFrame
-
>
GetContent
(
)
)
;
if
(
element
&
&
!
element
-
>
IsRootOfNativeAnonymousSubtree
(
)
&
&
element
-
>
GetPseudoElementType
(
)
=
=
aFrame
-
>
Style
(
)
-
>
GetPseudoType
(
)
)
{
while
(
parent
-
>
GetContent
(
)
&
&
!
parent
-
>
GetContent
(
)
-
>
IsRootOfNativeAnonymousSubtree
(
)
)
{
parent
=
parent
-
>
GetInFlowParent
(
)
;
}
parent
=
parent
-
>
GetInFlowParent
(
)
;
}
}
return
nsIFrame
:
:
CorrectStyleParentFrame
(
parent
pseudo
)
;
}
nsIFrame
*
nsIFrame
:
:
CorrectStyleParentFrame
(
nsIFrame
*
aProspectiveParent
PseudoStyleType
aChildPseudo
)
{
MOZ_ASSERT
(
aProspectiveParent
"
Must
have
a
prospective
parent
"
)
;
if
(
aChildPseudo
!
=
PseudoStyleType
:
:
NotPseudo
)
{
if
(
PseudoStyle
:
:
IsNonInheritingAnonBox
(
aChildPseudo
)
)
{
return
nullptr
;
}
if
(
PseudoStyle
:
:
IsAnonBox
(
aChildPseudo
)
&
&
!
nsCSSAnonBoxes
:
:
IsNonElement
(
aChildPseudo
)
)
{
NS_ASSERTION
(
aChildPseudo
!
=
PseudoStyleType
:
:
mozBlockInsideInlineWrapper
"
Should
have
dealt
with
kids
that
have
"
"
NS_FRAME_PART_OF_IBSPLIT
elsewhere
"
)
;
return
aProspectiveParent
;
}
}
nsIFrame
*
parent
=
aProspectiveParent
;
do
{
if
(
parent
-
>
HasAnyStateBits
(
NS_FRAME_PART_OF_IBSPLIT
)
)
{
nsIFrame
*
sibling
=
GetIBSplitSiblingForAnonymousBlock
(
parent
)
;
if
(
sibling
)
{
parent
=
sibling
;
}
}
if
(
!
parent
-
>
Style
(
)
-
>
IsPseudoOrAnonBox
(
)
)
{
return
parent
;
}
if
(
!
parent
-
>
Style
(
)
-
>
IsAnonBox
(
)
&
&
aChildPseudo
!
=
PseudoStyleType
:
:
MAX
)
{
return
parent
;
}
parent
=
parent
-
>
GetInFlowParent
(
)
;
}
while
(
parent
)
;
if
(
aProspectiveParent
-
>
Style
(
)
-
>
GetPseudoType
(
)
=
=
PseudoStyleType
:
:
viewportScroll
)
{
return
aProspectiveParent
;
}
NS_ASSERTION
(
aProspectiveParent
-
>
IsCanvasFrame
(
)
"
Should
have
found
a
parent
before
this
"
)
;
return
nullptr
;
}
ComputedStyle
*
nsIFrame
:
:
DoGetParentComputedStyle
(
nsIFrame
*
*
aProviderFrame
)
const
{
*
aProviderFrame
=
nullptr
;
if
(
MOZ_LIKELY
(
mContent
)
)
{
Element
*
parentElement
=
mContent
-
>
GetFlattenedTreeParentElement
(
)
;
if
(
MOZ_LIKELY
(
parentElement
)
)
{
auto
pseudo
=
Style
(
)
-
>
GetPseudoType
(
)
;
if
(
pseudo
=
=
PseudoStyleType
:
:
NotPseudo
|
|
!
mContent
-
>
IsElement
(
)
|
|
(
!
PseudoStyle
:
:
IsAnonBox
(
pseudo
)
&
&
IsPrimaryFrame
(
)
)
|
|
pseudo
=
=
PseudoStyleType
:
:
tableWrapper
)
{
if
(
MOZ_LIKELY
(
parentElement
-
>
HasServoData
(
)
)
&
&
Servo_Element_IsDisplayContents
(
parentElement
)
)
{
RefPtr
<
ComputedStyle
>
style
=
ServoStyleSet
:
:
ResolveServoStyle
(
*
parentElement
)
;
return
style
;
}
}
}
else
{
if
(
Style
(
)
-
>
GetPseudoType
(
)
=
=
PseudoStyleType
:
:
NotPseudo
)
{
return
nullptr
;
}
}
}
if
(
!
(
mState
&
NS_FRAME_OUT_OF_FLOW
)
)
{
if
(
mState
&
NS_FRAME_PART_OF_IBSPLIT
)
{
nsIFrame
*
ibSplitSibling
=
GetIBSplitSiblingForAnonymousBlock
(
this
)
;
if
(
ibSplitSibling
)
{
return
(
*
aProviderFrame
=
ibSplitSibling
)
-
>
Style
(
)
;
}
}
*
aProviderFrame
=
GetCorrectedParent
(
this
)
;
return
*
aProviderFrame
?
(
*
aProviderFrame
)
-
>
Style
(
)
:
nullptr
;
}
nsPlaceholderFrame
*
placeholder
=
FirstInFlow
(
)
-
>
GetPlaceholderFrame
(
)
;
if
(
!
placeholder
)
{
MOZ_ASSERT_UNREACHABLE
(
"
no
placeholder
frame
for
out
-
of
-
flow
frame
"
)
;
*
aProviderFrame
=
GetCorrectedParent
(
this
)
;
return
*
aProviderFrame
?
(
*
aProviderFrame
)
-
>
Style
(
)
:
nullptr
;
}
return
placeholder
-
>
GetParentComputedStyleForOutOfFlow
(
aProviderFrame
)
;
}
void
nsIFrame
:
:
GetLastLeaf
(
nsIFrame
*
*
aFrame
)
{
if
(
!
aFrame
|
|
!
*
aFrame
)
return
;
nsIFrame
*
child
=
*
aFrame
;
while
(
1
)
{
child
=
child
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
!
child
)
return
;
nsIFrame
*
siblingFrame
;
nsIContent
*
content
;
while
(
(
siblingFrame
=
child
-
>
GetNextSibling
(
)
)
&
&
(
content
=
siblingFrame
-
>
GetContent
(
)
)
&
&
!
content
-
>
IsRootOfNativeAnonymousSubtree
(
)
)
child
=
siblingFrame
;
*
aFrame
=
child
;
}
}
void
nsIFrame
:
:
GetFirstLeaf
(
nsIFrame
*
*
aFrame
)
{
if
(
!
aFrame
|
|
!
*
aFrame
)
return
;
nsIFrame
*
child
=
*
aFrame
;
while
(
1
)
{
child
=
child
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
!
child
)
return
;
*
aFrame
=
child
;
}
}
bool
nsIFrame
:
:
IsFocusableDueToScrollFrame
(
)
{
if
(
!
IsScrollFrame
(
)
)
{
if
(
nsFieldSetFrame
*
fieldset
=
do_QueryFrame
(
this
)
)
{
if
(
nsIFrame
*
inner
=
fieldset
-
>
GetInner
(
)
)
{
return
inner
-
>
IsFocusableDueToScrollFrame
(
)
;
}
}
return
false
;
}
if
(
!
mContent
-
>
IsHTMLElement
(
)
)
{
return
false
;
}
if
(
mContent
-
>
IsRootOfNativeAnonymousSubtree
(
)
)
{
return
false
;
}
if
(
!
mContent
-
>
GetParent
(
)
)
{
return
false
;
}
if
(
mContent
-
>
AsElement
(
)
-
>
HasAttr
(
nsGkAtoms
:
:
tabindex
)
)
{
return
false
;
}
nsIScrollableFrame
*
scrollFrame
=
do_QueryFrame
(
this
)
;
if
(
!
scrollFrame
)
{
return
false
;
}
if
(
scrollFrame
-
>
IsForTextControlWithNoScrollbars
(
)
)
{
return
false
;
}
if
(
scrollFrame
-
>
GetScrollStyles
(
)
.
IsHiddenInBothDirections
(
)
)
{
return
false
;
}
if
(
scrollFrame
-
>
GetScrollRange
(
)
.
IsEqualEdges
(
nsRect
(
0
0
0
0
)
)
)
{
return
false
;
}
return
true
;
}
nsIFrame
:
:
Focusable
nsIFrame
:
:
IsFocusable
(
bool
aWithMouse
)
{
if
(
PresContext
(
)
-
>
Type
(
)
=
=
nsPresContext
:
:
eContext_PrintPreview
)
{
return
{
}
;
}
if
(
!
mContent
|
|
!
mContent
-
>
IsElement
(
)
)
{
return
{
}
;
}
if
(
!
IsVisibleConsideringAncestors
(
)
)
{
return
{
}
;
}
const
nsStyleUI
&
ui
=
*
StyleUI
(
)
;
if
(
ui
.
IsInert
(
)
)
{
return
{
}
;
}
PseudoStyleType
pseudo
=
Style
(
)
-
>
GetPseudoType
(
)
;
if
(
pseudo
=
=
PseudoStyleType
:
:
anonymousFlexItem
|
|
pseudo
=
=
PseudoStyleType
:
:
anonymousGridItem
)
{
return
{
}
;
}
int32_t
tabIndex
=
-
1
;
if
(
ui
.
UserFocus
(
)
!
=
StyleUserFocus
:
:
Ignore
&
&
ui
.
UserFocus
(
)
!
=
StyleUserFocus
:
:
None
)
{
tabIndex
=
0
;
}
if
(
mContent
-
>
IsFocusable
(
&
tabIndex
aWithMouse
)
)
{
return
{
true
tabIndex
}
;
}
if
(
!
aWithMouse
&
&
IsFocusableDueToScrollFrame
(
)
)
{
return
{
true
0
}
;
}
return
{
false
tabIndex
}
;
}
bool
nsIFrame
:
:
HasSignificantTerminalNewline
(
)
const
{
return
false
;
}
static
StyleVerticalAlignKeyword
ConvertSVGDominantBaselineToVerticalAlign
(
StyleDominantBaseline
aDominantBaseline
)
{
switch
(
aDominantBaseline
)
{
case
StyleDominantBaseline
:
:
Hanging
:
case
StyleDominantBaseline
:
:
TextBeforeEdge
:
return
StyleVerticalAlignKeyword
:
:
TextTop
;
case
StyleDominantBaseline
:
:
TextAfterEdge
:
case
StyleDominantBaseline
:
:
Ideographic
:
return
StyleVerticalAlignKeyword
:
:
TextBottom
;
case
StyleDominantBaseline
:
:
Central
:
case
StyleDominantBaseline
:
:
Middle
:
case
StyleDominantBaseline
:
:
Mathematical
:
return
StyleVerticalAlignKeyword
:
:
Middle
;
case
StyleDominantBaseline
:
:
Auto
:
case
StyleDominantBaseline
:
:
Alphabetic
:
return
StyleVerticalAlignKeyword
:
:
Baseline
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
aDominantBaseline
value
"
)
;
return
StyleVerticalAlignKeyword
:
:
Baseline
;
}
}
Maybe
<
StyleVerticalAlignKeyword
>
nsIFrame
:
:
VerticalAlignEnum
(
)
const
{
if
(
SVGUtils
:
:
IsInSVGTextSubtree
(
this
)
)
{
StyleDominantBaseline
dominantBaseline
=
StyleSVG
(
)
-
>
mDominantBaseline
;
return
Some
(
ConvertSVGDominantBaselineToVerticalAlign
(
dominantBaseline
)
)
;
}
const
auto
&
verticalAlign
=
StyleDisplay
(
)
-
>
mVerticalAlign
;
if
(
verticalAlign
.
IsKeyword
(
)
)
{
return
Some
(
verticalAlign
.
AsKeyword
(
)
)
;
}
return
Nothing
(
)
;
}
NS_IMETHODIMP
nsIFrame
:
:
RefreshSizeCache
(
nsBoxLayoutState
&
aState
)
{
gfxContext
*
rendContext
=
aState
.
GetRenderingContext
(
)
;
if
(
rendContext
)
{
nsPresContext
*
presContext
=
aState
.
PresContext
(
)
;
nsBoxLayoutMetrics
*
metrics
=
BoxMetrics
(
)
;
if
(
!
XULNeedsRecalc
(
metrics
-
>
mBlockPrefSize
)
)
{
return
NS_OK
;
}
nsRect
rect
=
GetRect
(
)
;
nsMargin
bp
(
0
0
0
0
)
;
GetXULBorderAndPadding
(
bp
)
;
{
AutoMaybeDisableFontInflation
an
(
this
)
;
metrics
-
>
mBlockPrefSize
.
width
=
GetPrefISize
(
rendContext
)
+
bp
.
LeftRight
(
)
;
metrics
-
>
mBlockMinSize
.
width
=
GetMinISize
(
rendContext
)
+
bp
.
LeftRight
(
)
;
}
const
WritingMode
wm
=
aState
.
OuterReflowInput
(
)
?
aState
.
OuterReflowInput
(
)
-
>
GetWritingMode
(
)
:
GetWritingMode
(
)
;
ReflowOutput
desiredSize
(
wm
)
;
BoxReflow
(
aState
presContext
desiredSize
rendContext
rect
.
x
rect
.
y
metrics
-
>
mBlockPrefSize
.
width
NS_UNCONSTRAINEDSIZE
)
;
metrics
-
>
mBlockMinSize
.
height
=
0
;
AutoAssertNoDomMutations
guard
;
nsILineIterator
*
lines
=
GetLineIterator
(
)
;
if
(
lines
)
{
metrics
-
>
mBlockMinSize
.
height
=
0
;
int32_t
lineCount
=
lines
-
>
GetNumLines
(
)
;
for
(
int32_t
i
=
0
;
i
<
lineCount
;
+
+
i
)
{
auto
line
=
lines
-
>
GetLine
(
i
)
.
unwrap
(
)
;
if
(
line
.
mLineBounds
.
height
>
metrics
-
>
mBlockMinSize
.
height
)
{
metrics
-
>
mBlockMinSize
.
height
=
line
.
mLineBounds
.
height
;
}
}
}
else
{
metrics
-
>
mBlockMinSize
.
height
=
desiredSize
.
Height
(
)
;
}
metrics
-
>
mBlockPrefSize
.
height
=
metrics
-
>
mBlockMinSize
.
height
;
if
(
desiredSize
.
BlockStartAscent
(
)
=
=
ReflowOutput
:
:
ASK_FOR_BASELINE
)
{
if
(
!
nsLayoutUtils
:
:
GetFirstLineBaseline
(
wm
this
&
metrics
-
>
mBlockAscent
)
)
metrics
-
>
mBlockAscent
=
GetLogicalBaseline
(
wm
)
;
}
else
{
metrics
-
>
mBlockAscent
=
desiredSize
.
BlockStartAscent
(
)
;
}
#
ifdef
DEBUG_adaptor
printf
(
"
min
=
(
%
d
%
d
)
pref
=
(
%
d
%
d
)
ascent
=
%
d
\
n
"
metrics
-
>
mBlockMinSize
.
width
metrics
-
>
mBlockMinSize
.
height
metrics
-
>
mBlockPrefSize
.
width
metrics
-
>
mBlockPrefSize
.
height
metrics
-
>
mBlockAscent
)
;
#
endif
}
return
NS_OK
;
}
nsSize
nsIFrame
:
:
GetXULPrefSize
(
nsBoxLayoutState
&
aState
)
{
nsSize
size
(
0
0
)
;
DISPLAY_PREF_SIZE
(
this
size
)
;
nsBoxLayoutMetrics
*
metrics
=
BoxMetrics
(
)
;
if
(
!
XULNeedsRecalc
(
metrics
-
>
mPrefSize
)
)
{
size
=
metrics
-
>
mPrefSize
;
return
size
;
}
if
(
IsXULCollapsed
(
)
)
return
size
;
bool
widthSet
heightSet
;
bool
completelyRedefined
=
nsIFrame
:
:
AddXULPrefSize
(
this
size
widthSet
heightSet
)
;
if
(
!
completelyRedefined
)
{
RefreshSizeCache
(
aState
)
;
nsSize
blockSize
=
metrics
-
>
mBlockPrefSize
;
if
(
!
widthSet
)
size
.
width
=
blockSize
.
width
;
if
(
!
heightSet
)
size
.
height
=
blockSize
.
height
;
}
metrics
-
>
mPrefSize
=
size
;
return
size
;
}
nsSize
nsIFrame
:
:
GetXULMinSize
(
nsBoxLayoutState
&
aState
)
{
nsSize
size
(
0
0
)
;
DISPLAY_MIN_SIZE
(
this
size
)
;
nsBoxLayoutMetrics
*
metrics
=
BoxMetrics
(
)
;
if
(
!
XULNeedsRecalc
(
metrics
-
>
mMinSize
)
)
{
size
=
metrics
-
>
mMinSize
;
return
size
;
}
if
(
IsXULCollapsed
(
)
)
return
size
;
bool
widthSet
heightSet
;
bool
completelyRedefined
=
nsIFrame
:
:
AddXULMinSize
(
this
size
widthSet
heightSet
)
;
if
(
!
completelyRedefined
)
{
RefreshSizeCache
(
aState
)
;
nsSize
blockSize
=
metrics
-
>
mBlockMinSize
;
if
(
!
widthSet
)
size
.
width
=
blockSize
.
width
;
if
(
!
heightSet
)
size
.
height
=
blockSize
.
height
;
}
metrics
-
>
mMinSize
=
size
;
return
size
;
}
nsSize
nsIFrame
:
:
GetXULMaxSize
(
nsBoxLayoutState
&
aState
)
{
nsSize
size
(
NS_UNCONSTRAINEDSIZE
NS_UNCONSTRAINEDSIZE
)
;
DISPLAY_MAX_SIZE
(
this
size
)
;
nsBoxLayoutMetrics
*
metrics
=
BoxMetrics
(
)
;
if
(
!
XULNeedsRecalc
(
metrics
-
>
mMaxSize
)
)
{
size
=
metrics
-
>
mMaxSize
;
return
size
;
}
if
(
IsXULCollapsed
(
)
)
return
size
;
size
=
nsIFrame
:
:
GetUncachedXULMaxSize
(
aState
)
;
metrics
-
>
mMaxSize
=
size
;
return
size
;
}
int32_t
nsIFrame
:
:
GetXULFlex
(
)
{
nsBoxLayoutMetrics
*
metrics
=
BoxMetrics
(
)
;
if
(
XULNeedsRecalc
(
metrics
-
>
mFlex
)
)
{
metrics
-
>
mFlex
=
nsIFrame
:
:
ComputeXULFlex
(
this
)
;
}
return
metrics
-
>
mFlex
;
}
nscoord
nsIFrame
:
:
GetXULBoxAscent
(
nsBoxLayoutState
&
aState
)
{
nsBoxLayoutMetrics
*
metrics
=
BoxMetrics
(
)
;
if
(
!
XULNeedsRecalc
(
metrics
-
>
mAscent
)
)
{
return
metrics
-
>
mAscent
;
}
if
(
IsXULCollapsed
(
)
)
{
metrics
-
>
mAscent
=
0
;
}
else
{
RefreshSizeCache
(
aState
)
;
metrics
-
>
mAscent
=
metrics
-
>
mBlockAscent
;
}
return
metrics
-
>
mAscent
;
}
nsresult
nsIFrame
:
:
DoXULLayout
(
nsBoxLayoutState
&
aState
)
{
nsRect
ourRect
(
mRect
)
;
gfxContext
*
rendContext
=
aState
.
GetRenderingContext
(
)
;
nsPresContext
*
presContext
=
aState
.
PresContext
(
)
;
WritingMode
ourWM
=
GetWritingMode
(
)
;
const
WritingMode
outerWM
=
aState
.
OuterReflowInput
(
)
?
aState
.
OuterReflowInput
(
)
-
>
GetWritingMode
(
)
:
ourWM
;
ReflowOutput
desiredSize
(
outerWM
)
;
LogicalSize
ourSize
=
GetLogicalSize
(
outerWM
)
;
if
(
rendContext
)
{
BoxReflow
(
aState
presContext
desiredSize
rendContext
ourRect
.
x
ourRect
.
y
ourRect
.
width
ourRect
.
height
)
;
if
(
IsXULCollapsed
(
)
)
{
SetSize
(
nsSize
(
0
0
)
)
;
}
else
{
if
(
desiredSize
.
ISize
(
outerWM
)
>
ourSize
.
ISize
(
outerWM
)
|
|
desiredSize
.
BSize
(
outerWM
)
>
ourSize
.
BSize
(
outerWM
)
)
{
#
ifdef
DEBUG_GROW
XULDumpBox
(
stdout
)
;
printf
(
"
GREW
from
(
%
d
%
d
)
-
>
(
%
d
%
d
)
\
n
"
ourSize
.
ISize
(
outerWM
)
ourSize
.
BSize
(
outerWM
)
desiredSize
.
ISize
(
outerWM
)
desiredSize
.
BSize
(
outerWM
)
)
;
#
endif
if
(
desiredSize
.
ISize
(
outerWM
)
>
ourSize
.
ISize
(
outerWM
)
)
{
ourSize
.
ISize
(
outerWM
)
=
desiredSize
.
ISize
(
outerWM
)
;
}
if
(
desiredSize
.
BSize
(
outerWM
)
>
ourSize
.
BSize
(
outerWM
)
)
{
ourSize
.
BSize
(
outerWM
)
=
desiredSize
.
BSize
(
outerWM
)
;
}
}
SetSize
(
ourSize
.
ConvertTo
(
ourWM
outerWM
)
)
;
}
}
LogicalSize
size
(
GetLogicalSize
(
outerWM
)
)
;
desiredSize
.
ISize
(
outerWM
)
=
size
.
ISize
(
outerWM
)
;
desiredSize
.
BSize
(
outerWM
)
=
size
.
BSize
(
outerWM
)
;
desiredSize
.
UnionOverflowAreasWithDesiredBounds
(
)
;
if
(
HasAbsolutelyPositionedChildren
(
)
)
{
ReflowInput
reflowInput
(
aState
.
PresContext
(
)
this
aState
.
GetRenderingContext
(
)
LogicalSize
(
ourWM
ISize
(
)
NS_UNCONSTRAINEDSIZE
)
ReflowInput
:
:
InitFlag
:
:
DummyParentReflowInput
)
;
AddStateBits
(
NS_FRAME_IN_REFLOW
)
;
nsReflowStatus
reflowStatus
;
ReflowAbsoluteFrames
(
aState
.
PresContext
(
)
desiredSize
reflowInput
reflowStatus
)
;
RemoveStateBits
(
NS_FRAME_IN_REFLOW
)
;
}
nsSize
oldSize
(
ourRect
.
Size
(
)
)
;
FinishAndStoreOverflow
(
desiredSize
.
mOverflowAreas
size
.
GetPhysicalSize
(
outerWM
)
&
oldSize
)
;
SyncXULLayout
(
aState
)
;
return
NS_OK
;
}
void
nsIFrame
:
:
BoxReflow
(
nsBoxLayoutState
&
aState
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
gfxContext
*
aRenderingContext
nscoord
aX
nscoord
aY
nscoord
aWidth
nscoord
aHeight
bool
aMoveFrame
)
{
DO_GLOBAL_REFLOW_COUNT
(
"
nsBoxToBlockAdaptor
"
)
;
nsBoxLayoutMetrics
*
metrics
=
BoxMetrics
(
)
;
if
(
MOZ_UNLIKELY
(
!
metrics
)
)
{
MOZ_RELEASE_ASSERT
(
!
XRE_IsContentProcess
(
)
"
Starting
XUL
BoxReflow
w
/
o
BoxMetrics
(
in
content
)
?
"
)
;
MOZ_ASSERT_UNREACHABLE
(
"
Starting
XUL
BoxReflow
w
/
o
BoxMetrics
?
"
)
;
return
;
}
nsReflowStatus
status
;
bool
needsReflow
=
IsSubtreeDirty
(
)
;
if
(
!
needsReflow
)
{
if
(
aWidth
!
=
NS_UNCONSTRAINEDSIZE
&
&
aHeight
!
=
NS_UNCONSTRAINEDSIZE
)
{
if
(
(
metrics
-
>
mLastSize
.
width
=
=
0
|
|
metrics
-
>
mLastSize
.
height
=
=
0
)
&
&
(
aWidth
=
=
0
|
|
aHeight
=
=
0
)
)
{
needsReflow
=
false
;
aDesiredSize
.
Width
(
)
=
aWidth
;
aDesiredSize
.
Height
(
)
=
aHeight
;
SetSize
(
aDesiredSize
.
Size
(
GetWritingMode
(
)
)
)
;
}
else
{
aDesiredSize
.
Width
(
)
=
metrics
-
>
mLastSize
.
width
;
aDesiredSize
.
Height
(
)
=
metrics
-
>
mLastSize
.
height
;
if
(
metrics
-
>
mLastSize
.
width
=
=
aWidth
&
&
metrics
-
>
mLastSize
.
height
=
=
aHeight
)
needsReflow
=
false
;
else
needsReflow
=
true
;
}
}
else
{
needsReflow
=
true
;
}
}
if
(
needsReflow
)
{
aDesiredSize
.
ClearSize
(
)
;
nsMargin
margin
(
0
0
0
0
)
;
GetXULMargin
(
margin
)
;
nsSize
parentSize
(
aWidth
aHeight
)
;
if
(
parentSize
.
height
!
=
NS_UNCONSTRAINEDSIZE
)
parentSize
.
height
+
=
margin
.
TopBottom
(
)
;
if
(
parentSize
.
width
!
=
NS_UNCONSTRAINEDSIZE
)
parentSize
.
width
+
=
margin
.
LeftRight
(
)
;
nsIFrame
*
parentFrame
=
GetParent
(
)
;
WritingMode
parentWM
=
parentFrame
-
>
GetWritingMode
(
)
;
ReflowInput
parentReflowInput
(
aPresContext
parentFrame
aRenderingContext
LogicalSize
(
parentWM
parentSize
)
ReflowInput
:
:
InitFlag
:
:
DummyParentReflowInput
)
;
if
(
parentSize
.
width
!
=
NS_UNCONSTRAINEDSIZE
)
parentReflowInput
.
SetComputedWidth
(
std
:
:
max
(
parentSize
.
width
0
)
)
;
if
(
parentSize
.
height
!
=
NS_UNCONSTRAINEDSIZE
)
parentReflowInput
.
SetComputedHeight
(
std
:
:
max
(
parentSize
.
height
0
)
)
;
parentReflowInput
.
SetComputedLogicalMargin
(
parentWM
LogicalMargin
(
parentWM
)
)
;
nsMargin
padding
;
parentFrame
-
>
GetXULPadding
(
padding
)
;
parentReflowInput
.
SetComputedLogicalPadding
(
parentWM
LogicalMargin
(
parentWM
padding
)
)
;
nsMargin
border
;
parentFrame
-
>
GetXULBorder
(
border
)
;
parentReflowInput
.
SetComputedLogicalBorderPadding
(
parentWM
LogicalMargin
(
parentWM
border
+
padding
)
)
;
const
ReflowInput
*
outerReflowInput
=
aState
.
OuterReflowInput
(
)
;
NS_ASSERTION
(
!
outerReflowInput
|
|
outerReflowInput
-
>
mFrame
!
=
this
"
in
and
out
of
XUL
on
a
single
frame
?
"
)
;
const
ReflowInput
*
parentRI
;
if
(
outerReflowInput
&
&
outerReflowInput
-
>
mFrame
=
=
parentFrame
)
{
parentRI
=
outerReflowInput
;
}
else
{
parentRI
=
&
parentReflowInput
;
}
WritingMode
wm
=
GetWritingMode
(
)
;
LogicalSize
logicalSize
(
wm
nsSize
(
aWidth
aHeight
)
)
;
logicalSize
.
BSize
(
wm
)
=
NS_UNCONSTRAINEDSIZE
;
ReflowInput
reflowInput
(
aPresContext
*
parentRI
this
logicalSize
Nothing
(
)
ReflowInput
:
:
InitFlag
:
:
DummyParentReflowInput
)
;
reflowInput
.
mCBReflowInput
=
parentRI
;
reflowInput
.
mReflowDepth
=
aState
.
GetReflowDepth
(
)
;
if
(
aWidth
!
=
NS_UNCONSTRAINEDSIZE
)
{
nscoord
computedWidth
=
aWidth
-
reflowInput
.
ComputedPhysicalBorderPadding
(
)
.
LeftRight
(
)
;
computedWidth
=
std
:
:
max
(
computedWidth
0
)
;
reflowInput
.
SetComputedWidth
(
computedWidth
)
;
}
if
(
!
IsBlockFrameOrSubclass
(
)
)
{
if
(
aHeight
!
=
NS_UNCONSTRAINEDSIZE
)
{
nscoord
computedHeight
=
aHeight
-
reflowInput
.
ComputedPhysicalBorderPadding
(
)
.
TopBottom
(
)
;
computedHeight
=
std
:
:
max
(
computedHeight
0
)
;
reflowInput
.
SetComputedHeight
(
computedHeight
)
;
}
else
{
reflowInput
.
SetComputedHeight
(
ComputeSize
(
aRenderingContext
wm
logicalSize
logicalSize
.
ISize
(
wm
)
reflowInput
.
ComputedLogicalMargin
(
wm
)
.
Size
(
wm
)
reflowInput
.
ComputedLogicalBorderPadding
(
wm
)
.
Size
(
wm
)
{
}
{
}
)
.
mLogicalSize
.
Height
(
wm
)
)
;
}
}
if
(
metrics
-
>
mLastSize
.
width
!
=
aWidth
)
{
reflowInput
.
SetHResize
(
true
)
;
if
(
nsLayoutUtils
:
:
FontSizeInflationEnabled
(
aPresContext
)
)
{
this
-
>
MarkSubtreeDirty
(
)
;
}
}
if
(
metrics
-
>
mLastSize
.
height
!
=
aHeight
)
{
reflowInput
.
SetVResize
(
true
)
;
}
Reflow
(
aPresContext
aDesiredSize
reflowInput
status
)
;
NS_ASSERTION
(
status
.
IsComplete
(
)
"
bad
status
"
)
;
ReflowChildFlags
layoutFlags
=
aState
.
LayoutFlags
(
)
;
nsContainerFrame
:
:
FinishReflowChild
(
this
aPresContext
aDesiredSize
&
reflowInput
aX
aY
layoutFlags
|
ReflowChildFlags
:
:
NoMoveFrame
)
;
if
(
IsXULCollapsed
(
)
)
{
metrics
-
>
mAscent
=
0
;
}
else
{
if
(
aDesiredSize
.
BlockStartAscent
(
)
=
=
ReflowOutput
:
:
ASK_FOR_BASELINE
)
{
if
(
!
nsLayoutUtils
:
:
GetFirstLineBaseline
(
wm
this
&
metrics
-
>
mAscent
)
)
metrics
-
>
mAscent
=
GetLogicalBaseline
(
wm
)
;
}
else
metrics
-
>
mAscent
=
aDesiredSize
.
BlockStartAscent
(
)
;
}
}
else
{
aDesiredSize
.
SetBlockStartAscent
(
metrics
-
>
mBlockAscent
)
;
}
metrics
-
>
mLastSize
.
width
=
aDesiredSize
.
Width
(
)
;
metrics
-
>
mLastSize
.
height
=
aDesiredSize
.
Height
(
)
;
}
nsBoxLayoutMetrics
*
nsIFrame
:
:
BoxMetrics
(
)
const
{
nsBoxLayoutMetrics
*
metrics
=
GetProperty
(
BoxMetricsProperty
(
)
)
;
NS_ASSERTION
(
metrics
"
A
box
layout
method
was
called
but
InitBoxMetrics
was
never
called
"
)
;
return
metrics
;
}
void
nsIFrame
:
:
UpdateStyleOfChildAnonBox
(
nsIFrame
*
aChildFrame
ServoRestyleState
&
aRestyleState
)
{
#
ifdef
DEBUG
nsIFrame
*
parent
=
aChildFrame
-
>
GetInFlowParent
(
)
;
if
(
aChildFrame
-
>
IsTableFrame
(
)
)
{
parent
=
parent
-
>
GetParent
(
)
;
}
if
(
parent
-
>
IsLineFrame
(
)
)
{
parent
=
parent
-
>
GetParent
(
)
;
}
MOZ_ASSERT
(
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
parent
)
=
=
this
"
This
should
only
be
used
for
children
!
"
)
;
#
endif
MOZ_ASSERT
(
!
GetContent
(
)
|
|
!
aChildFrame
-
>
GetContent
(
)
|
|
aChildFrame
-
>
GetContent
(
)
=
=
GetContent
(
)
"
What
content
node
is
it
a
frame
for
?
"
)
;
MOZ_ASSERT
(
!
aChildFrame
-
>
GetPrevContinuation
(
)
"
Only
first
continuations
should
end
up
here
"
)
;
auto
pseudo
=
aChildFrame
-
>
Style
(
)
-
>
GetPseudoType
(
)
;
MOZ_ASSERT
(
PseudoStyle
:
:
IsAnonBox
(
pseudo
)
"
Child
is
not
an
anon
box
?
"
)
;
MOZ_ASSERT
(
!
PseudoStyle
:
:
IsNonInheritingAnonBox
(
pseudo
)
"
Why
did
the
caller
bother
calling
us
?
"
)
;
RefPtr
<
ComputedStyle
>
newContext
=
aRestyleState
.
StyleSet
(
)
.
ResolveInheritingAnonymousBoxStyle
(
pseudo
Style
(
)
)
;
nsChangeHint
childHint
=
UpdateStyleOfOwnedChildFrame
(
aChildFrame
newContext
aRestyleState
)
;
ServoRestyleState
childrenState
(
*
aChildFrame
aRestyleState
childHint
ServoRestyleState
:
:
Type
:
:
InFlow
)
;
aChildFrame
-
>
UpdateStyleOfOwnedAnonBoxes
(
childrenState
)
;
if
(
nsBlockFrame
*
block
=
do_QueryFrame
(
aChildFrame
)
)
{
block
-
>
UpdatePseudoElementStyles
(
childrenState
)
;
}
}
nsChangeHint
nsIFrame
:
:
UpdateStyleOfOwnedChildFrame
(
nsIFrame
*
aChildFrame
ComputedStyle
*
aNewComputedStyle
ServoRestyleState
&
aRestyleState
const
Maybe
<
ComputedStyle
*
>
&
aContinuationComputedStyle
)
{
MOZ_ASSERT
(
!
aChildFrame
-
>
GetAdditionalComputedStyle
(
0
)
"
We
don
'
t
handle
additional
styles
here
"
)
;
uint32_t
equalStructs
;
nsChangeHint
childHint
=
aChildFrame
-
>
Style
(
)
-
>
CalcStyleDifference
(
*
aNewComputedStyle
&
equalStructs
)
;
if
(
!
aChildFrame
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
)
{
childHint
=
NS_RemoveSubsumedHints
(
childHint
aRestyleState
.
ChangesHandledFor
(
aChildFrame
)
)
;
}
if
(
childHint
)
{
if
(
childHint
&
nsChangeHint_ReconstructFrame
)
{
aRestyleState
.
ChangeList
(
)
.
PopChangesForContent
(
aChildFrame
-
>
GetContent
(
)
)
;
}
aRestyleState
.
ChangeList
(
)
.
AppendChange
(
aChildFrame
aChildFrame
-
>
GetContent
(
)
childHint
)
;
}
aChildFrame
-
>
SetComputedStyle
(
aNewComputedStyle
)
;
ComputedStyle
*
continuationStyle
=
aContinuationComputedStyle
?
*
aContinuationComputedStyle
:
aNewComputedStyle
;
for
(
nsIFrame
*
kid
=
aChildFrame
-
>
GetNextContinuation
(
)
;
kid
;
kid
=
kid
-
>
GetNextContinuation
(
)
)
{
MOZ_ASSERT
(
!
kid
-
>
GetAdditionalComputedStyle
(
0
)
)
;
kid
-
>
SetComputedStyle
(
continuationStyle
)
;
}
return
childHint
;
}
void
nsIFrame
:
:
AddInPopupStateBitToDescendants
(
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_IN_POPUP
)
&
&
aFrame
-
>
TrackingVisibility
(
)
)
{
aFrame
-
>
IncApproximateVisibleCount
(
)
;
}
aFrame
-
>
AddStateBits
(
NS_FRAME_IN_POPUP
)
;
for
(
const
auto
&
childList
:
aFrame
-
>
CrossDocChildLists
(
)
)
{
for
(
nsIFrame
*
child
:
childList
.
mList
)
{
AddInPopupStateBitToDescendants
(
child
)
;
}
}
}
void
nsIFrame
:
:
RemoveInPopupStateBitFromDescendants
(
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_IN_POPUP
)
|
|
nsLayoutUtils
:
:
IsPopup
(
aFrame
)
)
{
return
;
}
aFrame
-
>
RemoveStateBits
(
NS_FRAME_IN_POPUP
)
;
if
(
aFrame
-
>
TrackingVisibility
(
)
)
{
aFrame
-
>
DecApproximateVisibleCount
(
)
;
}
for
(
const
auto
&
childList
:
aFrame
-
>
CrossDocChildLists
(
)
)
{
for
(
nsIFrame
*
child
:
childList
.
mList
)
{
RemoveInPopupStateBitFromDescendants
(
child
)
;
}
}
}
void
nsIFrame
:
:
SetParent
(
nsContainerFrame
*
aParent
)
{
MOZ_ASSERT_IF
(
ParentIsWrapperAnonBox
(
)
aParent
-
>
Style
(
)
-
>
IsInheritingAnonBox
(
)
)
;
mParent
=
aParent
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mParent
|
|
PresShell
(
)
=
=
mParent
-
>
PresShell
(
)
)
;
if
(
:
:
IsXULBoxWrapped
(
this
)
)
{
:
:
InitBoxMetrics
(
this
true
)
;
}
else
{
}
if
(
HasAnyStateBits
(
NS_FRAME_HAS_VIEW
|
NS_FRAME_HAS_CHILD_WITH_VIEW
)
)
{
for
(
nsIFrame
*
f
=
aParent
;
f
&
&
!
f
-
>
HasAnyStateBits
(
NS_FRAME_HAS_CHILD_WITH_VIEW
)
;
f
=
f
-
>
GetParent
(
)
)
{
f
-
>
AddStateBits
(
NS_FRAME_HAS_CHILD_WITH_VIEW
)
;
}
}
if
(
HasAnyStateBits
(
NS_FRAME_CONTAINS_RELATIVE_BSIZE
)
)
{
for
(
nsIFrame
*
f
=
aParent
;
f
;
f
=
f
-
>
GetParent
(
)
)
{
if
(
f
-
>
HasAnyStateBits
(
NS_FRAME_CONTAINS_RELATIVE_BSIZE
)
)
{
break
;
}
f
-
>
AddStateBits
(
NS_FRAME_CONTAINS_RELATIVE_BSIZE
)
;
}
}
if
(
HasAnyStateBits
(
NS_FRAME_DESCENDANT_INTRINSIC_ISIZE_DEPENDS_ON_BSIZE
)
)
{
for
(
nsIFrame
*
f
=
aParent
;
f
;
f
=
f
-
>
GetParent
(
)
)
{
if
(
f
-
>
HasAnyStateBits
(
NS_FRAME_DESCENDANT_INTRINSIC_ISIZE_DEPENDS_ON_BSIZE
)
)
{
break
;
}
f
-
>
AddStateBits
(
NS_FRAME_DESCENDANT_INTRINSIC_ISIZE_DEPENDS_ON_BSIZE
)
;
}
}
if
(
HasInvalidFrameInSubtree
(
)
)
{
for
(
nsIFrame
*
f
=
aParent
;
f
&
&
!
f
-
>
HasAnyStateBits
(
NS_FRAME_DESCENDANT_NEEDS_PAINT
|
NS_FRAME_IS_NONDISPLAY
)
;
f
=
nsLayoutUtils
:
:
GetCrossDocParentFrameInProcess
(
f
)
)
{
f
-
>
AddStateBits
(
NS_FRAME_DESCENDANT_NEEDS_PAINT
)
;
}
}
if
(
aParent
-
>
HasAnyStateBits
(
NS_FRAME_IN_POPUP
)
)
{
AddInPopupStateBitToDescendants
(
this
)
;
}
else
{
RemoveInPopupStateBitFromDescendants
(
this
)
;
}
if
(
aParent
-
>
HasAnyStateBits
(
NS_FRAME_ALL_DESCENDANTS_NEED_PAINT
)
)
{
InvalidateFrame
(
)
;
}
else
{
SchedulePaint
(
)
;
}
}
void
nsIFrame
:
:
CreateOwnLayerIfNeeded
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
uint16_t
aType
bool
*
aCreatedContainerItem
)
{
if
(
GetContent
(
)
&
&
GetContent
(
)
-
>
IsXULElement
(
)
&
&
GetContent
(
)
-
>
AsElement
(
)
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
layer
)
)
{
aList
-
>
AppendNewToTopWithIndex
<
nsDisplayOwnLayer
>
(
aBuilder
this
aType
aList
aBuilder
-
>
CurrentActiveScrolledRoot
(
)
nsDisplayOwnLayerFlags
:
:
None
ScrollbarData
{
}
true
false
)
;
if
(
aCreatedContainerItem
)
{
*
aCreatedContainerItem
=
true
;
}
}
}
bool
nsIFrame
:
:
IsStackingContext
(
const
nsStyleDisplay
*
aStyleDisplay
const
nsStyleEffects
*
aStyleEffects
)
{
if
(
HasOpacity
(
aStyleDisplay
aStyleEffects
nullptr
)
)
{
return
true
;
}
if
(
IsTransformed
(
)
)
{
return
true
;
}
auto
willChange
=
aStyleDisplay
-
>
mWillChange
.
bits
;
if
(
aStyleDisplay
-
>
IsContainPaint
(
)
|
|
aStyleDisplay
-
>
IsContainLayout
(
)
|
|
willChange
&
StyleWillChangeBits
:
:
CONTAIN
)
{
if
(
IsFrameOfType
(
eSupportsContainLayoutAndPaint
)
)
{
return
true
;
}
}
if
(
aStyleDisplay
-
>
HasPerspectiveStyle
(
)
|
|
willChange
&
StyleWillChangeBits
:
:
PERSPECTIVE
)
{
if
(
IsFrameOfType
(
eSupportsCSSTransforms
)
)
{
return
true
;
}
}
if
(
!
StylePosition
(
)
-
>
mZIndex
.
IsAuto
(
)
|
|
willChange
&
StyleWillChangeBits
:
:
Z_INDEX
)
{
if
(
ZIndexApplies
(
)
)
{
return
true
;
}
}
return
aStyleEffects
-
>
mMixBlendMode
!
=
StyleBlend
:
:
Normal
|
|
SVGIntegrationUtils
:
:
UsingEffectsForFrame
(
this
)
|
|
aStyleDisplay
-
>
IsPositionForcingStackingContext
(
)
|
|
aStyleDisplay
-
>
mIsolation
!
=
StyleIsolation
:
:
Auto
|
|
willChange
&
StyleWillChangeBits
:
:
STACKING_CONTEXT_UNCONDITIONAL
;
}
bool
nsIFrame
:
:
IsStackingContext
(
)
{
return
IsStackingContext
(
StyleDisplay
(
)
StyleEffects
(
)
)
;
}
static
bool
IsFrameScrolledOutOfView
(
const
nsIFrame
*
aTarget
const
nsRect
&
aTargetRect
const
nsIFrame
*
aParent
)
{
nsIFrame
*
clipParent
=
nullptr
;
for
(
nsIFrame
*
f
=
const_cast
<
nsIFrame
*
>
(
aParent
)
;
f
;
f
=
nsLayoutUtils
:
:
GetCrossDocParentFrameInProcess
(
f
)
)
{
nsIScrollableFrame
*
scrollableFrame
=
do_QueryFrame
(
f
)
;
if
(
scrollableFrame
)
{
clipParent
=
f
;
break
;
}
if
(
f
-
>
StyleDisplay
(
)
-
>
mPosition
=
=
StylePositionProperty
:
:
Fixed
&
&
nsLayoutUtils
:
:
IsReallyFixedPos
(
f
)
)
{
clipParent
=
f
-
>
GetParent
(
)
;
break
;
}
}
if
(
!
clipParent
)
{
return
nsLayoutUtils
:
:
FrameIsScrolledOutOfViewInCrossProcess
(
aTarget
)
;
}
nsRect
clipRect
=
clipParent
-
>
InkOverflowRectRelativeToSelf
(
)
;
if
(
clipRect
.
IsEmpty
(
)
)
{
return
true
;
}
nsRect
transformedRect
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
aTarget
aTargetRect
clipParent
)
;
if
(
transformedRect
.
IsEmpty
(
)
)
{
if
(
transformedRect
.
x
>
clipRect
.
XMost
(
)
|
|
transformedRect
.
y
>
clipRect
.
YMost
(
)
|
|
clipRect
.
x
>
transformedRect
.
XMost
(
)
|
|
clipRect
.
y
>
transformedRect
.
YMost
(
)
)
{
return
true
;
}
}
else
if
(
!
transformedRect
.
Intersects
(
clipRect
)
)
{
return
true
;
}
nsIFrame
*
parent
=
clipParent
-
>
GetParent
(
)
;
if
(
!
parent
)
{
return
false
;
}
return
IsFrameScrolledOutOfView
(
aTarget
aTargetRect
parent
)
;
}
bool
nsIFrame
:
:
IsScrolledOutOfView
(
)
const
{
nsRect
rect
=
InkOverflowRectRelativeToSelf
(
)
;
return
IsFrameScrolledOutOfView
(
this
rect
this
)
;
}
gfx
:
:
Matrix
nsIFrame
:
:
ComputeWidgetTransform
(
)
{
const
nsStyleUIReset
*
uiReset
=
StyleUIReset
(
)
;
if
(
uiReset
-
>
mMozWindowTransform
.
IsNone
(
)
)
{
return
gfx
:
:
Matrix
(
)
;
}
TransformReferenceBox
refBox
(
nullptr
nsRect
(
nsPoint
(
)
GetSize
(
)
)
)
;
nsPresContext
*
presContext
=
PresContext
(
)
;
int32_t
appUnitsPerDevPixel
=
presContext
-
>
AppUnitsPerDevPixel
(
)
;
gfx
:
:
Matrix4x4
matrix
=
nsStyleTransformMatrix
:
:
ReadTransforms
(
uiReset
-
>
mMozWindowTransform
refBox
float
(
appUnitsPerDevPixel
)
)
;
const
StyleTransformOrigin
&
origin
=
uiReset
-
>
mWindowTransformOrigin
;
Point
transformOrigin
=
nsStyleTransformMatrix
:
:
Convert2DPosition
(
origin
.
horizontal
origin
.
vertical
refBox
appUnitsPerDevPixel
)
;
matrix
.
ChangeBasis
(
Point3D
(
transformOrigin
.
x
transformOrigin
.
y
0
)
)
;
gfx
:
:
Matrix
result2d
;
if
(
!
matrix
.
CanDraw2D
(
&
result2d
)
)
{
NS_WARNING
(
"
-
moz
-
window
-
transform
does
not
describe
a
2D
transform
"
"
but
only
2d
transforms
are
supported
"
)
;
return
gfx
:
:
Matrix
(
)
;
}
return
result2d
;
}
void
nsIFrame
:
:
DoUpdateStyleOfOwnedAnonBoxes
(
ServoRestyleState
&
aRestyleState
)
{
if
(
IsInlineFrame
(
)
)
{
if
(
HasAnyStateBits
(
NS_FRAME_PART_OF_IBSPLIT
)
)
{
static_cast
<
nsInlineFrame
*
>
(
this
)
-
>
UpdateStyleOfOwnedAnonBoxesForIBSplit
(
aRestyleState
)
;
}
return
;
}
AutoTArray
<
OwnedAnonBox
4
>
frames
;
AppendDirectlyOwnedAnonBoxes
(
frames
)
;
for
(
OwnedAnonBox
&
box
:
frames
)
{
if
(
box
.
mUpdateStyleFn
)
{
box
.
mUpdateStyleFn
(
this
box
.
mAnonBoxFrame
aRestyleState
)
;
}
else
{
UpdateStyleOfChildAnonBox
(
box
.
mAnonBoxFrame
aRestyleState
)
;
}
}
}
void
nsIFrame
:
:
AppendDirectlyOwnedAnonBoxes
(
nsTArray
<
OwnedAnonBox
>
&
aResult
)
{
MOZ_ASSERT
(
!
HasAnyStateBits
(
NS_FRAME_OWNS_ANON_BOXES
)
)
;
MOZ_ASSERT
(
false
"
Why
did
this
get
called
?
"
)
;
}
void
nsIFrame
:
:
DoAppendOwnedAnonBoxes
(
nsTArray
<
OwnedAnonBox
>
&
aResult
)
{
size_t
i
=
aResult
.
Length
(
)
;
AppendDirectlyOwnedAnonBoxes
(
aResult
)
;
while
(
i
<
aResult
.
Length
(
)
)
{
nsIFrame
*
f
=
aResult
[
i
]
.
mAnonBoxFrame
;
if
(
f
-
>
HasAnyStateBits
(
NS_FRAME_OWNS_ANON_BOXES
)
)
{
f
-
>
AppendDirectlyOwnedAnonBoxes
(
aResult
)
;
}
+
+
i
;
}
}
nsIFrame
:
:
CaretPosition
:
:
CaretPosition
(
)
:
mContentOffset
(
0
)
{
}
nsIFrame
:
:
CaretPosition
:
:
~
CaretPosition
(
)
=
default
;
bool
nsIFrame
:
:
HasCSSAnimations
(
)
{
auto
collection
=
AnimationCollection
<
CSSAnimation
>
:
:
GetAnimationCollection
(
this
)
;
return
collection
&
&
collection
-
>
mAnimations
.
Length
(
)
>
0
;
}
bool
nsIFrame
:
:
HasCSSTransitions
(
)
{
auto
collection
=
AnimationCollection
<
CSSTransition
>
:
:
GetAnimationCollection
(
this
)
;
return
collection
&
&
collection
-
>
mAnimations
.
Length
(
)
>
0
;
}
void
nsIFrame
:
:
AddSizeOfExcludingThisForTree
(
nsWindowSizes
&
aSizes
)
const
{
aSizes
.
mLayoutFramePropertiesSize
+
=
mProperties
.
SizeOfExcludingThis
(
aSizes
.
mState
.
mMallocSizeOf
)
;
if
(
!
aSizes
.
mState
.
HaveSeenPtr
(
mComputedStyle
)
)
{
mComputedStyle
-
>
AddSizeOfIncludingThis
(
aSizes
&
aSizes
.
mLayoutComputedValuesNonDom
)
;
}
int32_t
index
=
0
;
while
(
auto
*
extra
=
GetAdditionalComputedStyle
(
index
+
+
)
)
{
if
(
!
aSizes
.
mState
.
HaveSeenPtr
(
extra
)
)
{
extra
-
>
AddSizeOfIncludingThis
(
aSizes
&
aSizes
.
mLayoutComputedValuesNonDom
)
;
}
}
for
(
const
auto
&
childList
:
ChildLists
(
)
)
{
for
(
const
nsIFrame
*
f
:
childList
.
mList
)
{
f
-
>
AddSizeOfExcludingThisForTree
(
aSizes
)
;
}
}
}
nsRect
nsIFrame
:
:
GetCompositorHitTestArea
(
nsDisplayListBuilder
*
aBuilder
)
{
nsRect
area
;
nsIScrollableFrame
*
scrollFrame
=
nsLayoutUtils
:
:
GetScrollableFrameFor
(
this
)
;
if
(
scrollFrame
)
{
area
=
ScrollableOverflowRect
(
)
;
}
else
{
area
=
GetRectRelativeToSelf
(
)
;
}
if
(
!
area
.
IsEmpty
(
)
)
{
return
area
+
aBuilder
-
>
ToReferenceFrame
(
this
)
;
}
return
area
;
}
CompositorHitTestInfo
nsIFrame
:
:
GetCompositorHitTestInfo
(
nsDisplayListBuilder
*
aBuilder
)
{
CompositorHitTestInfo
result
=
CompositorHitTestInvisibleToHit
;
if
(
aBuilder
-
>
IsInsidePointerEventsNoneDoc
(
)
)
{
return
result
;
}
if
(
!
GetParent
(
)
)
{
MOZ_ASSERT
(
IsViewportFrame
(
)
)
;
return
result
;
}
if
(
Style
(
)
-
>
PointerEvents
(
)
=
=
StylePointerEvents
:
:
None
)
{
return
result
;
}
if
(
!
StyleVisibility
(
)
-
>
IsVisible
(
)
)
{
return
result
;
}
result
=
CompositorHitTestFlags
:
:
eVisibleToHitTest
;
if
(
SVGIntegrationUtils
:
:
UsingMaskOrClipPathForFrame
(
this
)
)
{
if
(
!
gfxVars
:
:
UseWebRender
(
)
|
|
!
SVGIntegrationUtils
:
:
UsingSimpleClipPathForFrame
(
this
)
)
{
result
+
=
CompositorHitTestFlags
:
:
eIrregularArea
;
}
}
if
(
aBuilder
-
>
IsBuildingNonLayerizedScrollbar
(
)
)
{
result
+
=
CompositorHitTestFlags
:
:
eInactiveScrollframe
;
}
else
if
(
aBuilder
-
>
GetAncestorHasApzAwareEventHandler
(
)
)
{
result
+
=
CompositorHitTestFlags
:
:
eApzAwareListeners
;
}
else
if
(
IsRangeFrame
(
)
)
{
result
+
=
CompositorHitTestFlags
:
:
eApzAwareListeners
;
}
if
(
aBuilder
-
>
IsTouchEventPrefEnabledDoc
(
)
)
{
CompositorHitTestInfo
inheritedTouchAction
=
aBuilder
-
>
GetCompositorHitTestInfo
(
)
&
CompositorHitTestTouchActionMask
;
nsIFrame
*
touchActionFrame
=
this
;
if
(
nsIScrollableFrame
*
scrollFrame
=
nsLayoutUtils
:
:
GetScrollableFrameFor
(
this
)
)
{
ScrollStyles
ss
=
scrollFrame
-
>
GetScrollStyles
(
)
;
if
(
ss
.
mVertical
!
=
StyleOverflow
:
:
Hidden
|
|
ss
.
mHorizontal
!
=
StyleOverflow
:
:
Hidden
)
{
touchActionFrame
=
do_QueryFrame
(
scrollFrame
)
;
CompositorHitTestInfo
panMask
(
CompositorHitTestFlags
:
:
eTouchActionPanXDisabled
CompositorHitTestFlags
:
:
eTouchActionPanYDisabled
)
;
inheritedTouchAction
-
=
panMask
;
}
}
result
+
=
inheritedTouchAction
;
const
StyleTouchAction
touchAction
=
touchActionFrame
-
>
UsedTouchAction
(
)
;
if
(
touchAction
=
=
StyleTouchAction
:
:
AUTO
)
{
}
else
if
(
touchAction
&
StyleTouchAction
:
:
MANIPULATION
)
{
result
+
=
CompositorHitTestFlags
:
:
eTouchActionDoubleTapZoomDisabled
;
}
else
{
if
(
!
(
touchAction
&
StyleTouchAction
:
:
PINCH_ZOOM
)
)
{
result
+
=
CompositorHitTestFlags
:
:
eTouchActionPinchZoomDisabled
;
}
result
+
=
CompositorHitTestFlags
:
:
eTouchActionDoubleTapZoomDisabled
;
if
(
!
(
touchAction
&
StyleTouchAction
:
:
PAN_X
)
)
{
result
+
=
CompositorHitTestFlags
:
:
eTouchActionPanXDisabled
;
}
if
(
!
(
touchAction
&
StyleTouchAction
:
:
PAN_Y
)
)
{
result
+
=
CompositorHitTestFlags
:
:
eTouchActionPanYDisabled
;
}
if
(
touchAction
&
StyleTouchAction
:
:
NONE
)
{
MOZ_ASSERT
(
result
.
contains
(
CompositorHitTestTouchActionMask
)
)
;
}
}
}
const
Maybe
<
ScrollDirection
>
scrollDirection
=
aBuilder
-
>
GetCurrentScrollbarDirection
(
)
;
if
(
scrollDirection
.
isSome
(
)
)
{
if
(
GetContent
(
)
-
>
IsXULElement
(
nsGkAtoms
:
:
thumb
)
)
{
const
bool
thumbGetsLayer
=
aBuilder
-
>
GetCurrentScrollbarTarget
(
)
!
=
layers
:
:
ScrollableLayerGuid
:
:
NULL_SCROLL_ID
;
if
(
thumbGetsLayer
)
{
result
+
=
CompositorHitTestFlags
:
:
eScrollbarThumb
;
}
else
{
result
+
=
CompositorHitTestFlags
:
:
eInactiveScrollframe
;
}
}
if
(
*
scrollDirection
=
=
ScrollDirection
:
:
eVertical
)
{
result
+
=
CompositorHitTestFlags
:
:
eScrollbarVertical
;
}
result
+
=
CompositorHitTestFlags
:
:
eScrollbar
;
}
return
result
;
}
static
bool
HasNoVisibleDescendants
(
const
nsIFrame
*
aFrame
)
{
for
(
const
auto
&
childList
:
aFrame
-
>
ChildLists
(
)
)
{
for
(
nsIFrame
*
f
:
childList
.
mList
)
{
if
(
nsPlaceholderFrame
:
:
GetRealFrameFor
(
f
)
-
>
IsVisibleOrMayHaveVisibleDescendants
(
)
)
{
return
false
;
}
}
}
return
true
;
}
void
nsIFrame
:
:
UpdateVisibleDescendantsState
(
)
{
if
(
StyleVisibility
(
)
-
>
IsVisible
(
)
)
{
nsIFrame
*
ancestor
;
for
(
ancestor
=
GetInFlowParent
(
)
;
ancestor
&
&
!
ancestor
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
;
ancestor
=
ancestor
-
>
GetInFlowParent
(
)
)
{
ancestor
-
>
mAllDescendantsAreInvisible
=
false
;
}
}
else
{
mAllDescendantsAreInvisible
=
HasNoVisibleDescendants
(
this
)
;
}
}
void
nsIFrame
:
:
UpdateAnimationVisibility
(
)
{
auto
*
animationCollection
=
AnimationCollection
<
CSSAnimation
>
:
:
GetAnimationCollection
(
this
)
;
auto
*
transitionCollection
=
AnimationCollection
<
CSSTransition
>
:
:
GetAnimationCollection
(
this
)
;
if
(
(
!
animationCollection
|
|
animationCollection
-
>
mAnimations
.
IsEmpty
(
)
)
&
&
(
!
transitionCollection
|
|
transitionCollection
-
>
mAnimations
.
IsEmpty
(
)
)
)
{
return
;
}
bool
hidden
=
AncestorHidesContent
(
)
;
if
(
animationCollection
)
{
for
(
auto
&
animation
:
animationCollection
-
>
mAnimations
)
{
animation
-
>
SetHiddenByContentVisibility
(
hidden
)
;
}
}
if
(
transitionCollection
)
{
for
(
auto
&
transition
:
transitionCollection
-
>
mAnimations
)
{
transition
-
>
SetHiddenByContentVisibility
(
hidden
)
;
}
}
}
nsIFrame
:
:
PhysicalAxes
nsIFrame
:
:
ShouldApplyOverflowClipping
(
const
nsStyleDisplay
*
aDisp
)
const
{
MOZ_ASSERT
(
aDisp
=
=
StyleDisplay
(
)
"
Wrong
display
struct
"
)
;
if
(
aDisp
-
>
IsContainPaint
(
)
&
&
!
IsScrollFrame
(
)
&
&
IsFrameOfType
(
eSupportsContainLayoutAndPaint
)
)
{
return
PhysicalAxes
:
:
Both
;
}
if
(
aDisp
-
>
mOverflowX
=
=
StyleOverflow
:
:
Hidden
&
&
aDisp
-
>
mOverflowY
=
=
StyleOverflow
:
:
Hidden
)
{
LayoutFrameType
type
=
Type
(
)
;
switch
(
type
)
{
case
LayoutFrameType
:
:
Table
:
case
LayoutFrameType
:
:
TableCell
:
case
LayoutFrameType
:
:
SVGOuterSVG
:
case
LayoutFrameType
:
:
SVGInnerSVG
:
case
LayoutFrameType
:
:
SVGSymbol
:
case
LayoutFrameType
:
:
SVGForeignObject
:
return
PhysicalAxes
:
:
Both
;
default
:
if
(
IsFrameOfType
(
nsIFrame
:
:
eReplacedContainsBlock
)
)
{
if
(
type
=
=
mozilla
:
:
LayoutFrameType
:
:
TextInput
)
{
return
PhysicalAxes
:
:
None
;
}
return
PhysicalAxes
:
:
Both
;
}
}
}
if
(
MOZ_UNLIKELY
(
(
aDisp
-
>
mOverflowX
=
=
mozilla
:
:
StyleOverflow
:
:
Clip
|
|
aDisp
-
>
mOverflowY
=
=
mozilla
:
:
StyleOverflow
:
:
Clip
)
&
&
!
IsListControlFrame
(
)
)
)
{
const
auto
*
element
=
Element
:
:
FromNodeOrNull
(
GetContent
(
)
)
;
if
(
!
element
|
|
!
PresContext
(
)
-
>
ElementWouldPropagateScrollStyles
(
*
element
)
)
{
uint8_t
axes
=
uint8_t
(
PhysicalAxes
:
:
None
)
;
if
(
aDisp
-
>
mOverflowX
=
=
mozilla
:
:
StyleOverflow
:
:
Clip
)
{
axes
|
=
uint8_t
(
PhysicalAxes
:
:
Horizontal
)
;
}
if
(
aDisp
-
>
mOverflowY
=
=
mozilla
:
:
StyleOverflow
:
:
Clip
)
{
axes
|
=
uint8_t
(
PhysicalAxes
:
:
Vertical
)
;
}
return
PhysicalAxes
(
axes
)
;
}
}
if
(
HasAnyStateBits
(
NS_FRAME_SVG_LAYOUT
)
)
{
return
PhysicalAxes
:
:
None
;
}
bool
clip
=
HasAnyStateBits
(
NS_BLOCK_CLIP_PAGINATED_OVERFLOW
)
&
&
PresContext
(
)
-
>
IsPaginated
(
)
&
&
IsBlockFrame
(
)
;
return
clip
?
PhysicalAxes
:
:
Both
:
PhysicalAxes
:
:
None
;
}
#
ifdef
DEBUG
static
void
GetTagName
(
nsIFrame
*
aFrame
nsIContent
*
aContent
int
aResultSize
char
*
aResult
)
{
if
(
aContent
)
{
snprintf
(
aResult
aResultSize
"
%
s
%
p
"
nsAtomCString
(
aContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
.
get
(
)
aFrame
)
;
}
else
{
snprintf
(
aResult
aResultSize
"
%
p
"
aFrame
)
;
}
}
void
nsIFrame
:
:
Trace
(
const
char
*
aMethod
bool
aEnter
)
{
if
(
NS_FRAME_LOG_TEST
(
sFrameLogModule
NS_FRAME_TRACE_CALLS
)
)
{
char
tagbuf
[
40
]
;
GetTagName
(
this
mContent
sizeof
(
tagbuf
)
tagbuf
)
;
printf_stderr
(
"
%
s
:
%
s
%
s
"
tagbuf
aEnter
?
"
enter
"
:
"
exit
"
aMethod
)
;
}
}
void
nsIFrame
:
:
Trace
(
const
char
*
aMethod
bool
aEnter
const
nsReflowStatus
&
aStatus
)
{
if
(
NS_FRAME_LOG_TEST
(
sFrameLogModule
NS_FRAME_TRACE_CALLS
)
)
{
char
tagbuf
[
40
]
;
GetTagName
(
this
mContent
sizeof
(
tagbuf
)
tagbuf
)
;
printf_stderr
(
"
%
s
:
%
s
%
s
status
=
%
scomplete
%
s
"
tagbuf
aEnter
?
"
enter
"
:
"
exit
"
aMethod
aStatus
.
IsIncomplete
(
)
?
"
not
"
:
"
"
(
aStatus
.
NextInFlowNeedsReflow
(
)
)
?
"
+
reflow
"
:
"
"
)
;
}
}
void
nsIFrame
:
:
TraceMsg
(
const
char
*
aFormatString
.
.
.
)
{
if
(
NS_FRAME_LOG_TEST
(
sFrameLogModule
NS_FRAME_TRACE_CALLS
)
)
{
char
argbuf
[
200
]
;
va_list
ap
;
va_start
(
ap
aFormatString
)
;
VsprintfLiteral
(
argbuf
aFormatString
ap
)
;
va_end
(
ap
)
;
char
tagbuf
[
40
]
;
GetTagName
(
this
mContent
sizeof
(
tagbuf
)
tagbuf
)
;
printf_stderr
(
"
%
s
:
%
s
"
tagbuf
argbuf
)
;
}
}
void
nsIFrame
:
:
VerifyDirtyBitSet
(
const
nsFrameList
&
aFrameList
)
{
for
(
nsFrameList
:
:
Enumerator
e
(
aFrameList
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
)
{
NS_ASSERTION
(
e
.
get
(
)
-
>
HasAnyStateBits
(
NS_FRAME_IS_DIRTY
)
"
dirty
bit
not
set
"
)
;
}
}
DR_cookie
:
:
DR_cookie
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
const
ReflowInput
&
aReflowInput
ReflowOutput
&
aMetrics
nsReflowStatus
&
aStatus
)
:
mPresContext
(
aPresContext
)
mFrame
(
aFrame
)
mReflowInput
(
aReflowInput
)
mMetrics
(
aMetrics
)
mStatus
(
aStatus
)
{
MOZ_COUNT_CTOR
(
DR_cookie
)
;
mValue
=
nsIFrame
:
:
DisplayReflowEnter
(
aPresContext
mFrame
mReflowInput
)
;
}
DR_cookie
:
:
~
DR_cookie
(
)
{
MOZ_COUNT_DTOR
(
DR_cookie
)
;
nsIFrame
:
:
DisplayReflowExit
(
mPresContext
mFrame
mMetrics
mStatus
mValue
)
;
}
DR_layout_cookie
:
:
DR_layout_cookie
(
nsIFrame
*
aFrame
)
:
mFrame
(
aFrame
)
{
MOZ_COUNT_CTOR
(
DR_layout_cookie
)
;
mValue
=
nsIFrame
:
:
DisplayLayoutEnter
(
mFrame
)
;
}
DR_layout_cookie
:
:
~
DR_layout_cookie
(
)
{
MOZ_COUNT_DTOR
(
DR_layout_cookie
)
;
nsIFrame
:
:
DisplayLayoutExit
(
mFrame
mValue
)
;
}
DR_intrinsic_inline_size_cookie
:
:
DR_intrinsic_inline_size_cookie
(
nsIFrame
*
aFrame
const
char
*
aType
nscoord
&
aResult
)
:
mFrame
(
aFrame
)
mType
(
aType
)
mResult
(
aResult
)
{
MOZ_COUNT_CTOR
(
DR_intrinsic_inline_size_cookie
)
;
mValue
=
nsIFrame
:
:
DisplayIntrinsicISizeEnter
(
mFrame
mType
)
;
}
DR_intrinsic_inline_size_cookie
:
:
~
DR_intrinsic_inline_size_cookie
(
)
{
MOZ_COUNT_DTOR
(
DR_intrinsic_inline_size_cookie
)
;
nsIFrame
:
:
DisplayIntrinsicISizeExit
(
mFrame
mType
mResult
mValue
)
;
}
DR_intrinsic_size_cookie
:
:
DR_intrinsic_size_cookie
(
nsIFrame
*
aFrame
const
char
*
aType
nsSize
&
aResult
)
:
mFrame
(
aFrame
)
mType
(
aType
)
mResult
(
aResult
)
{
MOZ_COUNT_CTOR
(
DR_intrinsic_size_cookie
)
;
mValue
=
nsIFrame
:
:
DisplayIntrinsicSizeEnter
(
mFrame
mType
)
;
}
DR_intrinsic_size_cookie
:
:
~
DR_intrinsic_size_cookie
(
)
{
MOZ_COUNT_DTOR
(
DR_intrinsic_size_cookie
)
;
nsIFrame
:
:
DisplayIntrinsicSizeExit
(
mFrame
mType
mResult
mValue
)
;
}
DR_init_constraints_cookie
:
:
DR_init_constraints_cookie
(
nsIFrame
*
aFrame
ReflowInput
*
aState
nscoord
aCBWidth
nscoord
aCBHeight
const
mozilla
:
:
Maybe
<
mozilla
:
:
LogicalMargin
>
aBorder
const
mozilla
:
:
Maybe
<
mozilla
:
:
LogicalMargin
>
aPadding
)
:
mFrame
(
aFrame
)
mState
(
aState
)
{
MOZ_COUNT_CTOR
(
DR_init_constraints_cookie
)
;
nsMargin
border
;
if
(
aBorder
)
{
border
=
aBorder
-
>
GetPhysicalMargin
(
aFrame
-
>
GetWritingMode
(
)
)
;
}
nsMargin
padding
;
if
(
aPadding
)
{
padding
=
aPadding
-
>
GetPhysicalMargin
(
aFrame
-
>
GetWritingMode
(
)
)
;
}
mValue
=
ReflowInput
:
:
DisplayInitConstraintsEnter
(
mFrame
mState
aCBWidth
aCBHeight
aBorder
?
&
border
:
nullptr
aPadding
?
&
padding
:
nullptr
)
;
}
DR_init_constraints_cookie
:
:
~
DR_init_constraints_cookie
(
)
{
MOZ_COUNT_DTOR
(
DR_init_constraints_cookie
)
;
ReflowInput
:
:
DisplayInitConstraintsExit
(
mFrame
mState
mValue
)
;
}
DR_init_offsets_cookie
:
:
DR_init_offsets_cookie
(
nsIFrame
*
aFrame
SizeComputationInput
*
aState
nscoord
aPercentBasis
WritingMode
aCBWritingMode
const
mozilla
:
:
Maybe
<
mozilla
:
:
LogicalMargin
>
aBorder
const
mozilla
:
:
Maybe
<
mozilla
:
:
LogicalMargin
>
aPadding
)
:
mFrame
(
aFrame
)
mState
(
aState
)
{
MOZ_COUNT_CTOR
(
DR_init_offsets_cookie
)
;
nsMargin
border
;
if
(
aBorder
)
{
border
=
aBorder
-
>
GetPhysicalMargin
(
aFrame
-
>
GetWritingMode
(
)
)
;
}
nsMargin
padding
;
if
(
aPadding
)
{
padding
=
aPadding
-
>
GetPhysicalMargin
(
aFrame
-
>
GetWritingMode
(
)
)
;
}
mValue
=
SizeComputationInput
:
:
DisplayInitOffsetsEnter
(
mFrame
mState
aPercentBasis
aCBWritingMode
aBorder
?
&
border
:
nullptr
aPadding
?
&
padding
:
nullptr
)
;
}
DR_init_offsets_cookie
:
:
~
DR_init_offsets_cookie
(
)
{
MOZ_COUNT_DTOR
(
DR_init_offsets_cookie
)
;
SizeComputationInput
:
:
DisplayInitOffsetsExit
(
mFrame
mState
mValue
)
;
}
struct
DR_Rule
;
struct
DR_FrameTypeInfo
{
DR_FrameTypeInfo
(
LayoutFrameType
aFrameType
const
char
*
aFrameNameAbbrev
const
char
*
aFrameName
)
;
~
DR_FrameTypeInfo
(
)
;
LayoutFrameType
mType
;
char
mNameAbbrev
[
16
]
;
char
mName
[
32
]
;
nsTArray
<
DR_Rule
*
>
mRules
;
private
:
DR_FrameTypeInfo
&
operator
=
(
const
DR_FrameTypeInfo
&
)
=
delete
;
}
;
struct
DR_FrameTreeNode
;
struct
DR_Rule
;
struct
DR_State
{
DR_State
(
)
;
~
DR_State
(
)
;
void
Init
(
)
;
void
AddFrameTypeInfo
(
LayoutFrameType
aFrameType
const
char
*
aFrameNameAbbrev
const
char
*
aFrameName
)
;
DR_FrameTypeInfo
*
GetFrameTypeInfo
(
LayoutFrameType
aFrameType
)
;
DR_FrameTypeInfo
*
GetFrameTypeInfo
(
char
*
aFrameName
)
;
void
InitFrameTypeTable
(
)
;
DR_FrameTreeNode
*
CreateTreeNode
(
nsIFrame
*
aFrame
const
ReflowInput
*
aReflowInput
)
;
void
FindMatchingRule
(
DR_FrameTreeNode
&
aNode
)
;
bool
RuleMatches
(
DR_Rule
&
aRule
DR_FrameTreeNode
&
aNode
)
;
bool
GetToken
(
FILE
*
aFile
char
*
aBuf
size_t
aBufSize
)
;
DR_Rule
*
ParseRule
(
FILE
*
aFile
)
;
void
ParseRulesFile
(
)
;
void
AddRule
(
nsTArray
<
DR_Rule
*
>
&
aRules
DR_Rule
&
aRule
)
;
bool
IsWhiteSpace
(
int
c
)
;
bool
GetNumber
(
char
*
aBuf
int32_t
&
aNumber
)
;
void
PrettyUC
(
nscoord
aSize
char
*
aBuf
int
aBufSize
)
;
void
PrintMargin
(
const
char
*
tag
const
nsMargin
*
aMargin
)
;
void
DisplayFrameTypeInfo
(
nsIFrame
*
aFrame
int32_t
aIndent
)
;
void
DeleteTreeNode
(
DR_FrameTreeNode
&
aNode
)
;
bool
mInited
;
bool
mActive
;
int32_t
mCount
;
int32_t
mAssert
;
int32_t
mIndent
;
bool
mIndentUndisplayedFrames
;
bool
mDisplayPixelErrors
;
nsTArray
<
DR_Rule
*
>
mWildRules
;
nsTArray
<
DR_FrameTypeInfo
>
mFrameTypeTable
;
nsTArray
<
DR_FrameTreeNode
*
>
mFrameTreeLeaves
;
}
;
static
DR_State
*
DR_state
;
struct
DR_RulePart
{
explicit
DR_RulePart
(
LayoutFrameType
aFrameType
)
:
mFrameType
(
aFrameType
)
mNext
(
0
)
{
}
void
Destroy
(
)
;
LayoutFrameType
mFrameType
;
DR_RulePart
*
mNext
;
}
;
void
DR_RulePart
:
:
Destroy
(
)
{
if
(
mNext
)
{
mNext
-
>
Destroy
(
)
;
}
delete
this
;
}
struct
DR_Rule
{
DR_Rule
(
)
:
mLength
(
0
)
mTarget
(
nullptr
)
mDisplay
(
false
)
{
MOZ_COUNT_CTOR
(
DR_Rule
)
;
}
~
DR_Rule
(
)
{
if
(
mTarget
)
mTarget
-
>
Destroy
(
)
;
MOZ_COUNT_DTOR
(
DR_Rule
)
;
}
void
AddPart
(
LayoutFrameType
aFrameType
)
;
uint32_t
mLength
;
DR_RulePart
*
mTarget
;
bool
mDisplay
;
}
;
void
DR_Rule
:
:
AddPart
(
LayoutFrameType
aFrameType
)
{
DR_RulePart
*
newPart
=
new
DR_RulePart
(
aFrameType
)
;
newPart
-
>
mNext
=
mTarget
;
mTarget
=
newPart
;
mLength
+
+
;
}
DR_FrameTypeInfo
:
:
~
DR_FrameTypeInfo
(
)
{
int32_t
numElements
;
numElements
=
mRules
.
Length
(
)
;
for
(
int32_t
i
=
numElements
-
1
;
i
>
=
0
;
i
-
-
)
{
delete
mRules
.
ElementAt
(
i
)
;
}
}
DR_FrameTypeInfo
:
:
DR_FrameTypeInfo
(
LayoutFrameType
aFrameType
const
char
*
aFrameNameAbbrev
const
char
*
aFrameName
)
{
mType
=
aFrameType
;
PL_strncpyz
(
mNameAbbrev
aFrameNameAbbrev
sizeof
(
mNameAbbrev
)
)
;
PL_strncpyz
(
mName
aFrameName
sizeof
(
mName
)
)
;
}
struct
DR_FrameTreeNode
{
DR_FrameTreeNode
(
nsIFrame
*
aFrame
DR_FrameTreeNode
*
aParent
)
:
mFrame
(
aFrame
)
mParent
(
aParent
)
mDisplay
(
0
)
mIndent
(
0
)
{
MOZ_COUNT_CTOR
(
DR_FrameTreeNode
)
;
}
MOZ_COUNTED_DTOR
(
DR_FrameTreeNode
)
nsIFrame
*
mFrame
;
DR_FrameTreeNode
*
mParent
;
bool
mDisplay
;
uint32_t
mIndent
;
}
;
DR_State
:
:
DR_State
(
)
:
mInited
(
false
)
mActive
(
false
)
mCount
(
0
)
mAssert
(
-
1
)
mIndent
(
0
)
mIndentUndisplayedFrames
(
false
)
mDisplayPixelErrors
(
false
)
{
MOZ_COUNT_CTOR
(
DR_State
)
;
}
void
DR_State
:
:
Init
(
)
{
char
*
env
=
PR_GetEnv
(
"
GECKO_DISPLAY_REFLOW_ASSERT
"
)
;
int32_t
num
;
if
(
env
)
{
if
(
GetNumber
(
env
num
)
)
mAssert
=
num
;
else
printf
(
"
GECKO_DISPLAY_REFLOW_ASSERT
-
invalid
value
=
%
s
"
env
)
;
}
env
=
PR_GetEnv
(
"
GECKO_DISPLAY_REFLOW_INDENT_START
"
)
;
if
(
env
)
{
if
(
GetNumber
(
env
num
)
)
mIndent
=
num
;
else
printf
(
"
GECKO_DISPLAY_REFLOW_INDENT_START
-
invalid
value
=
%
s
"
env
)
;
}
env
=
PR_GetEnv
(
"
GECKO_DISPLAY_REFLOW_INDENT_UNDISPLAYED_FRAMES
"
)
;
if
(
env
)
{
if
(
GetNumber
(
env
num
)
)
mIndentUndisplayedFrames
=
num
;
else
printf
(
"
GECKO_DISPLAY_REFLOW_INDENT_UNDISPLAYED_FRAMES
-
invalid
value
=
%
s
"
env
)
;
}
env
=
PR_GetEnv
(
"
GECKO_DISPLAY_REFLOW_FLAG_PIXEL_ERRORS
"
)
;
if
(
env
)
{
if
(
GetNumber
(
env
num
)
)
mDisplayPixelErrors
=
num
;
else
printf
(
"
GECKO_DISPLAY_REFLOW_FLAG_PIXEL_ERRORS
-
invalid
value
=
%
s
"
env
)
;
}
InitFrameTypeTable
(
)
;
ParseRulesFile
(
)
;
mInited
=
true
;
}
DR_State
:
:
~
DR_State
(
)
{
MOZ_COUNT_DTOR
(
DR_State
)
;
int32_t
numElements
i
;
numElements
=
mWildRules
.
Length
(
)
;
for
(
i
=
numElements
-
1
;
i
>
=
0
;
i
-
-
)
{
delete
mWildRules
.
ElementAt
(
i
)
;
}
numElements
=
mFrameTreeLeaves
.
Length
(
)
;
for
(
i
=
numElements
-
1
;
i
>
=
0
;
i
-
-
)
{
delete
mFrameTreeLeaves
.
ElementAt
(
i
)
;
}
}
bool
DR_State
:
:
GetNumber
(
char
*
aBuf
int32_t
&
aNumber
)
{
if
(
sscanf
(
aBuf
"
%
d
"
&
aNumber
)
>
0
)
return
true
;
else
return
false
;
}
bool
DR_State
:
:
IsWhiteSpace
(
int
c
)
{
return
(
c
=
=
'
'
)
|
|
(
c
=
=
'
\
t
'
)
|
|
(
c
=
=
'
\
n
'
)
|
|
(
c
=
=
'
\
r
'
)
;
}
bool
DR_State
:
:
GetToken
(
FILE
*
aFile
char
*
aBuf
size_t
aBufSize
)
{
bool
haveToken
=
false
;
aBuf
[
0
]
=
0
;
int
c
=
-
1
;
for
(
c
=
getc
(
aFile
)
;
(
c
>
0
)
&
&
IsWhiteSpace
(
c
)
;
c
=
getc
(
aFile
)
)
{
}
if
(
c
>
0
)
{
haveToken
=
true
;
aBuf
[
0
]
=
c
;
size_t
cX
;
for
(
cX
=
1
;
cX
+
1
<
aBufSize
;
cX
+
+
)
{
c
=
getc
(
aFile
)
;
if
(
c
<
0
)
{
ungetc
(
'
'
aFile
)
;
break
;
}
else
{
if
(
IsWhiteSpace
(
c
)
)
{
break
;
}
else
{
aBuf
[
cX
]
=
c
;
}
}
}
aBuf
[
cX
]
=
0
;
}
return
haveToken
;
}
DR_Rule
*
DR_State
:
:
ParseRule
(
FILE
*
aFile
)
{
char
buf
[
128
]
;
int32_t
doDisplay
;
DR_Rule
*
rule
=
nullptr
;
while
(
GetToken
(
aFile
buf
sizeof
(
buf
)
)
)
{
if
(
GetNumber
(
buf
doDisplay
)
)
{
if
(
rule
)
{
rule
-
>
mDisplay
=
!
!
doDisplay
;
break
;
}
else
{
printf
(
"
unexpected
token
-
%
s
\
n
"
buf
)
;
}
}
else
{
if
(
!
rule
)
{
rule
=
new
DR_Rule
;
}
if
(
strcmp
(
buf
"
*
"
)
=
=
0
)
{
rule
-
>
AddPart
(
LayoutFrameType
:
:
None
)
;
}
else
{
DR_FrameTypeInfo
*
info
=
GetFrameTypeInfo
(
buf
)
;
if
(
info
)
{
rule
-
>
AddPart
(
info
-
>
mType
)
;
}
else
{
printf
(
"
invalid
frame
type
-
%
s
\
n
"
buf
)
;
}
}
}
}
return
rule
;
}
void
DR_State
:
:
AddRule
(
nsTArray
<
DR_Rule
*
>
&
aRules
DR_Rule
&
aRule
)
{
int32_t
numRules
=
aRules
.
Length
(
)
;
for
(
int32_t
ruleX
=
0
;
ruleX
<
numRules
;
ruleX
+
+
)
{
DR_Rule
*
rule
=
aRules
.
ElementAt
(
ruleX
)
;
NS_ASSERTION
(
rule
"
program
error
"
)
;
if
(
aRule
.
mLength
>
rule
-
>
mLength
)
{
aRules
.
InsertElementAt
(
ruleX
&
aRule
)
;
return
;
}
}
aRules
.
AppendElement
(
&
aRule
)
;
}
static
Maybe
<
bool
>
ShouldLogReflow
(
const
char
*
processes
)
{
switch
(
processes
[
0
]
)
{
case
'
A
'
:
case
'
a
'
:
return
Some
(
true
)
;
case
'
P
'
:
case
'
p
'
:
return
Some
(
XRE_IsParentProcess
(
)
)
;
case
'
C
'
:
case
'
c
'
:
return
Some
(
XRE_IsContentProcess
(
)
)
;
default
:
return
Nothing
{
}
;
}
}
void
DR_State
:
:
ParseRulesFile
(
)
{
char
*
processes
=
PR_GetEnv
(
"
GECKO_DISPLAY_REFLOW_PROCESSES
"
)
;
if
(
processes
)
{
Maybe
<
bool
>
enableLog
=
ShouldLogReflow
(
processes
)
;
if
(
enableLog
.
isNothing
(
)
)
{
MOZ_CRASH
(
"
GECKO_DISPLAY_REFLOW_PROCESSES
:
[
a
]
ll
[
p
]
arent
[
c
]
ontent
"
)
;
}
else
if
(
enableLog
.
value
(
)
)
{
DR_Rule
*
rule
=
new
DR_Rule
;
rule
-
>
AddPart
(
LayoutFrameType
:
:
None
)
;
rule
-
>
mDisplay
=
true
;
AddRule
(
mWildRules
*
rule
)
;
mActive
=
true
;
}
return
;
}
char
*
path
=
PR_GetEnv
(
"
GECKO_DISPLAY_REFLOW_RULES_FILE
"
)
;
if
(
path
)
{
FILE
*
inFile
=
fopen
(
path
"
r
"
)
;
if
(
!
inFile
)
{
MOZ_CRASH
(
"
Failed
to
open
the
specified
rules
file
;
Try
-
-
setpref
"
"
security
.
sandbox
.
content
.
level
=
2
if
the
sandbox
is
at
cause
"
)
;
}
for
(
DR_Rule
*
rule
=
ParseRule
(
inFile
)
;
rule
;
rule
=
ParseRule
(
inFile
)
)
{
if
(
rule
-
>
mTarget
)
{
LayoutFrameType
fType
=
rule
-
>
mTarget
-
>
mFrameType
;
if
(
fType
!
=
LayoutFrameType
:
:
None
)
{
DR_FrameTypeInfo
*
info
=
GetFrameTypeInfo
(
fType
)
;
AddRule
(
info
-
>
mRules
*
rule
)
;
}
else
{
AddRule
(
mWildRules
*
rule
)
;
}
mActive
=
true
;
}
}
fclose
(
inFile
)
;
}
}
void
DR_State
:
:
AddFrameTypeInfo
(
LayoutFrameType
aFrameType
const
char
*
aFrameNameAbbrev
const
char
*
aFrameName
)
{
mFrameTypeTable
.
EmplaceBack
(
aFrameType
aFrameNameAbbrev
aFrameName
)
;
}
DR_FrameTypeInfo
*
DR_State
:
:
GetFrameTypeInfo
(
LayoutFrameType
aFrameType
)
{
int32_t
numEntries
=
mFrameTypeTable
.
Length
(
)
;
NS_ASSERTION
(
numEntries
!
=
0
"
empty
FrameTypeTable
"
)
;
for
(
int32_t
i
=
0
;
i
<
numEntries
;
i
+
+
)
{
DR_FrameTypeInfo
&
info
=
mFrameTypeTable
.
ElementAt
(
i
)
;
if
(
info
.
mType
=
=
aFrameType
)
{
return
&
info
;
}
}
return
&
mFrameTypeTable
.
ElementAt
(
numEntries
-
1
)
;
}
DR_FrameTypeInfo
*
DR_State
:
:
GetFrameTypeInfo
(
char
*
aFrameName
)
{
int32_t
numEntries
=
mFrameTypeTable
.
Length
(
)
;
NS_ASSERTION
(
numEntries
!
=
0
"
empty
FrameTypeTable
"
)
;
for
(
int32_t
i
=
0
;
i
<
numEntries
;
i
+
+
)
{
DR_FrameTypeInfo
&
info
=
mFrameTypeTable
.
ElementAt
(
i
)
;
if
(
(
strcmp
(
aFrameName
info
.
mName
)
=
=
0
)
|
|
(
strcmp
(
aFrameName
info
.
mNameAbbrev
)
=
=
0
)
)
{
return
&
info
;
}
}
return
&
mFrameTypeTable
.
ElementAt
(
numEntries
-
1
)
;
}
void
DR_State
:
:
InitFrameTypeTable
(
)
{
AddFrameTypeInfo
(
LayoutFrameType
:
:
Block
"
block
"
"
block
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
Br
"
br
"
"
br
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
ColorControl
"
color
"
"
colorControl
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
GfxButtonControl
"
button
"
"
gfxButtonControl
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
HTMLButtonControl
"
HTMLbutton
"
"
HTMLButtonControl
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
HTMLCanvas
"
HTMLCanvas
"
"
HTMLCanvas
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
SubDocument
"
subdoc
"
"
subDocument
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
Image
"
img
"
"
image
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
Inline
"
inline
"
"
inline
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
Letter
"
letter
"
"
letter
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
Line
"
line
"
"
line
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
ListControl
"
select
"
"
select
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
Page
"
page
"
"
page
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
Placeholder
"
place
"
"
placeholder
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
Canvas
"
canvas
"
"
canvas
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
XULRoot
"
xulroot
"
"
xulroot
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
Scroll
"
scroll
"
"
scroll
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
TableCell
"
cell
"
"
tableCell
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
TableCol
"
col
"
"
tableCol
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
TableColGroup
"
colG
"
"
tableColGroup
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
Table
"
tbl
"
"
table
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
TableWrapper
"
tblW
"
"
tableWrapper
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
TableRowGroup
"
rowG
"
"
tableRowGroup
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
TableRow
"
row
"
"
tableRow
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
TextInput
"
textCtl
"
"
textInput
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
Text
"
text
"
"
text
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
Viewport
"
VP
"
"
viewport
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
Box
"
Box
"
"
Box
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
Slider
"
Slider
"
"
Slider
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
PopupSet
"
PopupSet
"
"
PopupSet
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
None
"
unknown
"
"
unknown
"
)
;
}
void
DR_State
:
:
DisplayFrameTypeInfo
(
nsIFrame
*
aFrame
int32_t
aIndent
)
{
DR_FrameTypeInfo
*
frameTypeInfo
=
GetFrameTypeInfo
(
aFrame
-
>
Type
(
)
)
;
if
(
frameTypeInfo
)
{
for
(
int32_t
i
=
0
;
i
<
aIndent
;
i
+
+
)
{
printf
(
"
"
)
;
}
if
(
!
strcmp
(
frameTypeInfo
-
>
mNameAbbrev
"
unknown
"
)
)
{
if
(
aFrame
)
{
nsAutoString
name
;
aFrame
-
>
GetFrameName
(
name
)
;
printf
(
"
%
s
%
p
"
NS_LossyConvertUTF16toASCII
(
name
)
.
get
(
)
(
void
*
)
aFrame
)
;
}
else
{
printf
(
"
%
s
%
p
"
frameTypeInfo
-
>
mNameAbbrev
(
void
*
)
aFrame
)
;
}
}
else
{
printf
(
"
%
s
%
p
"
frameTypeInfo
-
>
mNameAbbrev
(
void
*
)
aFrame
)
;
}
}
}
bool
DR_State
:
:
RuleMatches
(
DR_Rule
&
aRule
DR_FrameTreeNode
&
aNode
)
{
NS_ASSERTION
(
aRule
.
mTarget
"
program
error
"
)
;
DR_RulePart
*
rulePart
;
DR_FrameTreeNode
*
parentNode
;
for
(
rulePart
=
aRule
.
mTarget
-
>
mNext
parentNode
=
aNode
.
mParent
;
rulePart
&
&
parentNode
;
rulePart
=
rulePart
-
>
mNext
parentNode
=
parentNode
-
>
mParent
)
{
if
(
rulePart
-
>
mFrameType
!
=
LayoutFrameType
:
:
None
)
{
if
(
parentNode
-
>
mFrame
)
{
if
(
rulePart
-
>
mFrameType
!
=
parentNode
-
>
mFrame
-
>
Type
(
)
)
{
return
false
;
}
}
else
NS_ASSERTION
(
false
"
program
error
"
)
;
}
}
return
true
;
}
void
DR_State
:
:
FindMatchingRule
(
DR_FrameTreeNode
&
aNode
)
{
if
(
!
aNode
.
mFrame
)
{
NS_ASSERTION
(
false
"
invalid
DR_FrameTreeNode
\
n
"
)
;
return
;
}
bool
matchingRule
=
false
;
DR_FrameTypeInfo
*
info
=
GetFrameTypeInfo
(
aNode
.
mFrame
-
>
Type
(
)
)
;
NS_ASSERTION
(
info
"
program
error
"
)
;
int32_t
numRules
=
info
-
>
mRules
.
Length
(
)
;
for
(
int32_t
ruleX
=
0
;
ruleX
<
numRules
;
ruleX
+
+
)
{
DR_Rule
*
rule
=
info
-
>
mRules
.
ElementAt
(
ruleX
)
;
if
(
rule
&
&
RuleMatches
(
*
rule
aNode
)
)
{
aNode
.
mDisplay
=
rule
-
>
mDisplay
;
matchingRule
=
true
;
break
;
}
}
if
(
!
matchingRule
)
{
int32_t
numWildRules
=
mWildRules
.
Length
(
)
;
for
(
int32_t
ruleX
=
0
;
ruleX
<
numWildRules
;
ruleX
+
+
)
{
DR_Rule
*
rule
=
mWildRules
.
ElementAt
(
ruleX
)
;
if
(
rule
&
&
RuleMatches
(
*
rule
aNode
)
)
{
aNode
.
mDisplay
=
rule
-
>
mDisplay
;
break
;
}
}
}
}
DR_FrameTreeNode
*
DR_State
:
:
CreateTreeNode
(
nsIFrame
*
aFrame
const
ReflowInput
*
aReflowInput
)
{
nsIFrame
*
parentFrame
;
if
(
aReflowInput
)
{
const
ReflowInput
*
parentRI
=
aReflowInput
-
>
mParentReflowInput
;
parentFrame
=
(
parentRI
)
?
parentRI
-
>
mFrame
:
nullptr
;
}
else
{
parentFrame
=
aFrame
-
>
GetParent
(
)
;
}
DR_FrameTreeNode
*
parentNode
=
nullptr
;
DR_FrameTreeNode
*
lastLeaf
=
nullptr
;
if
(
mFrameTreeLeaves
.
Length
(
)
)
lastLeaf
=
mFrameTreeLeaves
.
ElementAt
(
mFrameTreeLeaves
.
Length
(
)
-
1
)
;
if
(
lastLeaf
)
{
for
(
parentNode
=
lastLeaf
;
parentNode
&
&
(
parentNode
-
>
mFrame
!
=
parentFrame
)
;
parentNode
=
parentNode
-
>
mParent
)
{
}
}
DR_FrameTreeNode
*
newNode
=
new
DR_FrameTreeNode
(
aFrame
parentNode
)
;
FindMatchingRule
(
*
newNode
)
;
newNode
-
>
mIndent
=
mIndent
;
if
(
newNode
-
>
mDisplay
|
|
mIndentUndisplayedFrames
)
{
+
+
mIndent
;
}
if
(
lastLeaf
&
&
(
lastLeaf
=
=
parentNode
)
)
{
mFrameTreeLeaves
.
RemoveLastElement
(
)
;
}
mFrameTreeLeaves
.
AppendElement
(
newNode
)
;
mCount
+
+
;
return
newNode
;
}
void
DR_State
:
:
PrettyUC
(
nscoord
aSize
char
*
aBuf
int
aBufSize
)
{
if
(
NS_UNCONSTRAINEDSIZE
=
=
aSize
)
{
strcpy
(
aBuf
"
UC
"
)
;
}
else
{
if
(
(
nscoord
)
0xdeadbeefU
=
=
aSize
)
{
strcpy
(
aBuf
"
deadbeef
"
)
;
}
else
{
snprintf
(
aBuf
aBufSize
"
%
d
"
aSize
)
;
}
}
}
void
DR_State
:
:
PrintMargin
(
const
char
*
tag
const
nsMargin
*
aMargin
)
{
if
(
aMargin
)
{
char
t
[
16
]
r
[
16
]
b
[
16
]
l
[
16
]
;
PrettyUC
(
aMargin
-
>
top
t
16
)
;
PrettyUC
(
aMargin
-
>
right
r
16
)
;
PrettyUC
(
aMargin
-
>
bottom
b
16
)
;
PrettyUC
(
aMargin
-
>
left
l
16
)
;
printf
(
"
%
s
=
%
s
%
s
%
s
%
s
"
tag
t
r
b
l
)
;
}
else
{
printf
(
"
%
s
=
%
p
"
tag
(
void
*
)
aMargin
)
;
}
}
void
DR_State
:
:
DeleteTreeNode
(
DR_FrameTreeNode
&
aNode
)
{
mFrameTreeLeaves
.
RemoveElement
(
&
aNode
)
;
int32_t
numLeaves
=
mFrameTreeLeaves
.
Length
(
)
;
if
(
(
0
=
=
numLeaves
)
|
|
(
aNode
.
mParent
!
=
mFrameTreeLeaves
.
ElementAt
(
numLeaves
-
1
)
)
)
{
mFrameTreeLeaves
.
AppendElement
(
aNode
.
mParent
)
;
}
if
(
aNode
.
mDisplay
|
|
mIndentUndisplayedFrames
)
{
-
-
mIndent
;
}
delete
&
aNode
;
}
static
void
CheckPixelError
(
nscoord
aSize
int32_t
aPixelToTwips
)
{
if
(
NS_UNCONSTRAINEDSIZE
!
=
aSize
)
{
if
(
(
aSize
%
aPixelToTwips
)
>
0
)
{
printf
(
"
VALUE
%
d
is
not
a
whole
pixel
\
n
"
aSize
)
;
}
}
}
static
void
DisplayReflowEnterPrint
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
const
ReflowInput
&
aReflowInput
DR_FrameTreeNode
&
aTreeNode
bool
aChanged
)
{
if
(
aTreeNode
.
mDisplay
)
{
DR_state
-
>
DisplayFrameTypeInfo
(
aFrame
aTreeNode
.
mIndent
)
;
char
width
[
16
]
;
char
height
[
16
]
;
DR_state
-
>
PrettyUC
(
aReflowInput
.
AvailableWidth
(
)
width
16
)
;
DR_state
-
>
PrettyUC
(
aReflowInput
.
AvailableHeight
(
)
height
16
)
;
printf
(
"
Reflow
a
=
%
s
%
s
"
width
height
)
;
DR_state
-
>
PrettyUC
(
aReflowInput
.
ComputedWidth
(
)
width
16
)
;
DR_state
-
>
PrettyUC
(
aReflowInput
.
ComputedHeight
(
)
height
16
)
;
printf
(
"
c
=
%
s
%
s
"
width
height
)
;
if
(
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_IS_DIRTY
)
)
printf
(
"
dirty
"
)
;
if
(
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_HAS_DIRTY_CHILDREN
)
)
printf
(
"
dirty
-
children
"
)
;
if
(
aReflowInput
.
mFlags
.
mSpecialBSizeReflow
)
printf
(
"
special
-
bsize
"
)
;
if
(
aReflowInput
.
IsHResize
(
)
)
printf
(
"
h
-
resize
"
)
;
if
(
aReflowInput
.
IsVResize
(
)
)
printf
(
"
v
-
resize
"
)
;
nsIFrame
*
inFlow
=
aFrame
-
>
GetPrevInFlow
(
)
;
if
(
inFlow
)
{
printf
(
"
pif
=
%
p
"
(
void
*
)
inFlow
)
;
}
inFlow
=
aFrame
-
>
GetNextInFlow
(
)
;
if
(
inFlow
)
{
printf
(
"
nif
=
%
p
"
(
void
*
)
inFlow
)
;
}
if
(
aChanged
)
printf
(
"
CHANGED
\
n
"
)
;
else
printf
(
"
cnt
=
%
d
\
n
"
DR_state
-
>
mCount
)
;
if
(
DR_state
-
>
mDisplayPixelErrors
)
{
int32_t
d2a
=
aPresContext
-
>
AppUnitsPerDevPixel
(
)
;
CheckPixelError
(
aReflowInput
.
AvailableWidth
(
)
d2a
)
;
CheckPixelError
(
aReflowInput
.
AvailableHeight
(
)
d2a
)
;
CheckPixelError
(
aReflowInput
.
ComputedWidth
(
)
d2a
)
;
CheckPixelError
(
aReflowInput
.
ComputedHeight
(
)
d2a
)
;
}
}
}
void
*
nsIFrame
:
:
DisplayReflowEnter
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
const
ReflowInput
&
aReflowInput
)
{
if
(
!
DR_state
-
>
mInited
)
DR_state
-
>
Init
(
)
;
if
(
!
DR_state
-
>
mActive
)
return
nullptr
;
NS_ASSERTION
(
aFrame
"
invalid
call
"
)
;
DR_FrameTreeNode
*
treeNode
=
DR_state
-
>
CreateTreeNode
(
aFrame
&
aReflowInput
)
;
if
(
treeNode
)
{
DisplayReflowEnterPrint
(
aPresContext
aFrame
aReflowInput
*
treeNode
false
)
;
}
return
treeNode
;
}
void
*
nsIFrame
:
:
DisplayLayoutEnter
(
nsIFrame
*
aFrame
)
{
if
(
!
DR_state
-
>
mInited
)
DR_state
-
>
Init
(
)
;
if
(
!
DR_state
-
>
mActive
)
return
nullptr
;
NS_ASSERTION
(
aFrame
"
invalid
call
"
)
;
DR_FrameTreeNode
*
treeNode
=
DR_state
-
>
CreateTreeNode
(
aFrame
nullptr
)
;
if
(
treeNode
&
&
treeNode
-
>
mDisplay
)
{
DR_state
-
>
DisplayFrameTypeInfo
(
aFrame
treeNode
-
>
mIndent
)
;
printf
(
"
XULLayout
\
n
"
)
;
}
return
treeNode
;
}
void
*
nsIFrame
:
:
DisplayIntrinsicISizeEnter
(
nsIFrame
*
aFrame
const
char
*
aType
)
{
if
(
!
DR_state
-
>
mInited
)
DR_state
-
>
Init
(
)
;
if
(
!
DR_state
-
>
mActive
)
return
nullptr
;
NS_ASSERTION
(
aFrame
"
invalid
call
"
)
;
DR_FrameTreeNode
*
treeNode
=
DR_state
-
>
CreateTreeNode
(
aFrame
nullptr
)
;
if
(
treeNode
&
&
treeNode
-
>
mDisplay
)
{
DR_state
-
>
DisplayFrameTypeInfo
(
aFrame
treeNode
-
>
mIndent
)
;
printf
(
"
Get
%
sISize
\
n
"
aType
)
;
}
return
treeNode
;
}
void
*
nsIFrame
:
:
DisplayIntrinsicSizeEnter
(
nsIFrame
*
aFrame
const
char
*
aType
)
{
if
(
!
DR_state
-
>
mInited
)
DR_state
-
>
Init
(
)
;
if
(
!
DR_state
-
>
mActive
)
return
nullptr
;
NS_ASSERTION
(
aFrame
"
invalid
call
"
)
;
DR_FrameTreeNode
*
treeNode
=
DR_state
-
>
CreateTreeNode
(
aFrame
nullptr
)
;
if
(
treeNode
&
&
treeNode
-
>
mDisplay
)
{
DR_state
-
>
DisplayFrameTypeInfo
(
aFrame
treeNode
-
>
mIndent
)
;
printf
(
"
Get
%
sSize
\
n
"
aType
)
;
}
return
treeNode
;
}
void
nsIFrame
:
:
DisplayReflowExit
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
ReflowOutput
&
aMetrics
const
nsReflowStatus
&
aStatus
void
*
aFrameTreeNode
)
{
if
(
!
DR_state
-
>
mActive
)
return
;
NS_ASSERTION
(
aFrame
"
DisplayReflowExit
-
invalid
call
"
)
;
if
(
!
aFrameTreeNode
)
return
;
DR_FrameTreeNode
*
treeNode
=
(
DR_FrameTreeNode
*
)
aFrameTreeNode
;
if
(
treeNode
-
>
mDisplay
)
{
DR_state
-
>
DisplayFrameTypeInfo
(
aFrame
treeNode
-
>
mIndent
)
;
char
width
[
16
]
;
char
height
[
16
]
;
char
x
[
16
]
;
char
y
[
16
]
;
DR_state
-
>
PrettyUC
(
aMetrics
.
Width
(
)
width
16
)
;
DR_state
-
>
PrettyUC
(
aMetrics
.
Height
(
)
height
16
)
;
printf
(
"
Reflow
d
=
%
s
%
s
"
width
height
)
;
if
(
!
aStatus
.
IsEmpty
(
)
)
{
printf
(
"
status
=
%
s
"
ToString
(
aStatus
)
.
c_str
(
)
)
;
}
if
(
aFrame
-
>
HasOverflowAreas
(
)
)
{
DR_state
-
>
PrettyUC
(
aMetrics
.
InkOverflow
(
)
.
x
x
16
)
;
DR_state
-
>
PrettyUC
(
aMetrics
.
InkOverflow
(
)
.
y
y
16
)
;
DR_state
-
>
PrettyUC
(
aMetrics
.
InkOverflow
(
)
.
width
width
16
)
;
DR_state
-
>
PrettyUC
(
aMetrics
.
InkOverflow
(
)
.
height
height
16
)
;
printf
(
"
vis
-
o
=
(
%
s
%
s
)
%
s
x
%
s
"
x
y
width
height
)
;
nsRect
storedOverflow
=
aFrame
-
>
InkOverflowRect
(
)
;
DR_state
-
>
PrettyUC
(
storedOverflow
.
x
x
16
)
;
DR_state
-
>
PrettyUC
(
storedOverflow
.
y
y
16
)
;
DR_state
-
>
PrettyUC
(
storedOverflow
.
width
width
16
)
;
DR_state
-
>
PrettyUC
(
storedOverflow
.
height
height
16
)
;
printf
(
"
vis
-
sto
=
(
%
s
%
s
)
%
s
x
%
s
"
x
y
width
height
)
;
DR_state
-
>
PrettyUC
(
aMetrics
.
ScrollableOverflow
(
)
.
x
x
16
)
;
DR_state
-
>
PrettyUC
(
aMetrics
.
ScrollableOverflow
(
)
.
y
y
16
)
;
DR_state
-
>
PrettyUC
(
aMetrics
.
ScrollableOverflow
(
)
.
width
width
16
)
;
DR_state
-
>
PrettyUC
(
aMetrics
.
ScrollableOverflow
(
)
.
height
height
16
)
;
printf
(
"
scr
-
o
=
(
%
s
%
s
)
%
s
x
%
s
"
x
y
width
height
)
;
storedOverflow
=
aFrame
-
>
ScrollableOverflowRect
(
)
;
DR_state
-
>
PrettyUC
(
storedOverflow
.
x
x
16
)
;
DR_state
-
>
PrettyUC
(
storedOverflow
.
y
y
16
)
;
DR_state
-
>
PrettyUC
(
storedOverflow
.
width
width
16
)
;
DR_state
-
>
PrettyUC
(
storedOverflow
.
height
height
16
)
;
printf
(
"
scr
-
sto
=
(
%
s
%
s
)
%
s
x
%
s
"
x
y
width
height
)
;
}
printf
(
"
\
n
"
)
;
if
(
DR_state
-
>
mDisplayPixelErrors
)
{
int32_t
d2a
=
aPresContext
-
>
AppUnitsPerDevPixel
(
)
;
CheckPixelError
(
aMetrics
.
Width
(
)
d2a
)
;
CheckPixelError
(
aMetrics
.
Height
(
)
d2a
)
;
}
}
DR_state
-
>
DeleteTreeNode
(
*
treeNode
)
;
}
void
nsIFrame
:
:
DisplayLayoutExit
(
nsIFrame
*
aFrame
void
*
aFrameTreeNode
)
{
if
(
!
DR_state
-
>
mActive
)
return
;
NS_ASSERTION
(
aFrame
"
non
-
null
frame
required
"
)
;
if
(
!
aFrameTreeNode
)
return
;
DR_FrameTreeNode
*
treeNode
=
(
DR_FrameTreeNode
*
)
aFrameTreeNode
;
if
(
treeNode
-
>
mDisplay
)
{
DR_state
-
>
DisplayFrameTypeInfo
(
aFrame
treeNode
-
>
mIndent
)
;
nsRect
rect
=
aFrame
-
>
GetRect
(
)
;
printf
(
"
XULLayout
=
%
d
%
d
%
d
%
d
\
n
"
rect
.
x
rect
.
y
rect
.
width
rect
.
height
)
;
}
DR_state
-
>
DeleteTreeNode
(
*
treeNode
)
;
}
void
nsIFrame
:
:
DisplayIntrinsicISizeExit
(
nsIFrame
*
aFrame
const
char
*
aType
nscoord
aResult
void
*
aFrameTreeNode
)
{
if
(
!
DR_state
-
>
mActive
)
return
;
NS_ASSERTION
(
aFrame
"
non
-
null
frame
required
"
)
;
if
(
!
aFrameTreeNode
)
return
;
DR_FrameTreeNode
*
treeNode
=
(
DR_FrameTreeNode
*
)
aFrameTreeNode
;
if
(
treeNode
-
>
mDisplay
)
{
DR_state
-
>
DisplayFrameTypeInfo
(
aFrame
treeNode
-
>
mIndent
)
;
char
iSize
[
16
]
;
DR_state
-
>
PrettyUC
(
aResult
iSize
16
)
;
printf
(
"
Get
%
sISize
=
%
s
\
n
"
aType
iSize
)
;
}
DR_state
-
>
DeleteTreeNode
(
*
treeNode
)
;
}
void
nsIFrame
:
:
DisplayIntrinsicSizeExit
(
nsIFrame
*
aFrame
const
char
*
aType
nsSize
aResult
void
*
aFrameTreeNode
)
{
if
(
!
DR_state
-
>
mActive
)
return
;
NS_ASSERTION
(
aFrame
"
non
-
null
frame
required
"
)
;
if
(
!
aFrameTreeNode
)
return
;
DR_FrameTreeNode
*
treeNode
=
(
DR_FrameTreeNode
*
)
aFrameTreeNode
;
if
(
treeNode
-
>
mDisplay
)
{
DR_state
-
>
DisplayFrameTypeInfo
(
aFrame
treeNode
-
>
mIndent
)
;
char
width
[
16
]
;
char
height
[
16
]
;
DR_state
-
>
PrettyUC
(
aResult
.
width
width
16
)
;
DR_state
-
>
PrettyUC
(
aResult
.
height
height
16
)
;
printf
(
"
Get
%
sSize
=
%
s
%
s
\
n
"
aType
width
height
)
;
}
DR_state
-
>
DeleteTreeNode
(
*
treeNode
)
;
}
void
nsIFrame
:
:
DisplayReflowStartup
(
)
{
DR_state
=
new
DR_State
(
)
;
}
void
nsIFrame
:
:
DisplayReflowShutdown
(
)
{
delete
DR_state
;
DR_state
=
nullptr
;
}
void
DR_cookie
:
:
Change
(
)
const
{
DR_FrameTreeNode
*
treeNode
=
(
DR_FrameTreeNode
*
)
mValue
;
if
(
treeNode
&
&
treeNode
-
>
mDisplay
)
{
DisplayReflowEnterPrint
(
mPresContext
mFrame
mReflowInput
*
treeNode
true
)
;
}
}
void
*
ReflowInput
:
:
DisplayInitConstraintsEnter
(
nsIFrame
*
aFrame
ReflowInput
*
aState
nscoord
aContainingBlockWidth
nscoord
aContainingBlockHeight
const
nsMargin
*
aBorder
const
nsMargin
*
aPadding
)
{
MOZ_ASSERT
(
aFrame
"
non
-
null
frame
required
"
)
;
MOZ_ASSERT
(
aState
"
non
-
null
state
required
"
)
;
if
(
!
DR_state
-
>
mInited
)
DR_state
-
>
Init
(
)
;
if
(
!
DR_state
-
>
mActive
)
return
nullptr
;
DR_FrameTreeNode
*
treeNode
=
DR_state
-
>
CreateTreeNode
(
aFrame
aState
)
;
if
(
treeNode
&
&
treeNode
-
>
mDisplay
)
{
DR_state
-
>
DisplayFrameTypeInfo
(
aFrame
treeNode
-
>
mIndent
)
;
printf
(
"
InitConstraints
parent
=
%
p
"
(
void
*
)
aState
-
>
mParentReflowInput
)
;
char
width
[
16
]
;
char
height
[
16
]
;
DR_state
-
>
PrettyUC
(
aContainingBlockWidth
width
16
)
;
DR_state
-
>
PrettyUC
(
aContainingBlockHeight
height
16
)
;
printf
(
"
cb
=
%
s
%
s
"
width
height
)
;
DR_state
-
>
PrettyUC
(
aState
-
>
AvailableWidth
(
)
width
16
)
;
DR_state
-
>
PrettyUC
(
aState
-
>
AvailableHeight
(
)
height
16
)
;
printf
(
"
as
=
%
s
%
s
"
width
height
)
;
DR_state
-
>
PrintMargin
(
"
b
"
aBorder
)
;
DR_state
-
>
PrintMargin
(
"
p
"
aPadding
)
;
putchar
(
'
\
n
'
)
;
}
return
treeNode
;
}
void
ReflowInput
:
:
DisplayInitConstraintsExit
(
nsIFrame
*
aFrame
ReflowInput
*
aState
void
*
aValue
)
{
MOZ_ASSERT
(
aFrame
"
non
-
null
frame
required
"
)
;
MOZ_ASSERT
(
aState
"
non
-
null
state
required
"
)
;
if
(
!
DR_state
-
>
mActive
)
return
;
if
(
!
aValue
)
return
;
DR_FrameTreeNode
*
treeNode
=
(
DR_FrameTreeNode
*
)
aValue
;
if
(
treeNode
-
>
mDisplay
)
{
DR_state
-
>
DisplayFrameTypeInfo
(
aFrame
treeNode
-
>
mIndent
)
;
char
cmiw
[
16
]
cw
[
16
]
cmxw
[
16
]
cmih
[
16
]
ch
[
16
]
cmxh
[
16
]
;
DR_state
-
>
PrettyUC
(
aState
-
>
ComputedMinWidth
(
)
cmiw
16
)
;
DR_state
-
>
PrettyUC
(
aState
-
>
ComputedWidth
(
)
cw
16
)
;
DR_state
-
>
PrettyUC
(
aState
-
>
ComputedMaxWidth
(
)
cmxw
16
)
;
DR_state
-
>
PrettyUC
(
aState
-
>
ComputedMinHeight
(
)
cmih
16
)
;
DR_state
-
>
PrettyUC
(
aState
-
>
ComputedHeight
(
)
ch
16
)
;
DR_state
-
>
PrettyUC
(
aState
-
>
ComputedMaxHeight
(
)
cmxh
16
)
;
printf
(
"
InitConstraints
=
cw
=
(
%
s
<
=
%
s
<
=
%
s
)
ch
=
(
%
s
<
=
%
s
<
=
%
s
)
"
cmiw
cw
cmxw
cmih
ch
cmxh
)
;
const
nsMargin
m
=
aState
-
>
ComputedPhysicalOffsets
(
)
;
DR_state
-
>
PrintMargin
(
"
co
"
&
m
)
;
putchar
(
'
\
n
'
)
;
}
DR_state
-
>
DeleteTreeNode
(
*
treeNode
)
;
}
void
*
SizeComputationInput
:
:
DisplayInitOffsetsEnter
(
nsIFrame
*
aFrame
SizeComputationInput
*
aState
nscoord
aPercentBasis
WritingMode
aCBWritingMode
const
nsMargin
*
aBorder
const
nsMargin
*
aPadding
)
{
MOZ_ASSERT
(
aFrame
"
non
-
null
frame
required
"
)
;
MOZ_ASSERT
(
aState
"
non
-
null
state
required
"
)
;
if
(
!
DR_state
-
>
mInited
)
DR_state
-
>
Init
(
)
;
if
(
!
DR_state
-
>
mActive
)
return
nullptr
;
DR_FrameTreeNode
*
treeNode
=
DR_state
-
>
CreateTreeNode
(
aFrame
nullptr
)
;
if
(
treeNode
&
&
treeNode
-
>
mDisplay
)
{
DR_state
-
>
DisplayFrameTypeInfo
(
aFrame
treeNode
-
>
mIndent
)
;
char
pctBasisStr
[
16
]
;
DR_state
-
>
PrettyUC
(
aPercentBasis
pctBasisStr
16
)
;
printf
(
"
InitOffsets
pct_basis
=
%
s
"
pctBasisStr
)
;
DR_state
-
>
PrintMargin
(
"
b
"
aBorder
)
;
DR_state
-
>
PrintMargin
(
"
p
"
aPadding
)
;
putchar
(
'
\
n
'
)
;
}
return
treeNode
;
}
void
SizeComputationInput
:
:
DisplayInitOffsetsExit
(
nsIFrame
*
aFrame
SizeComputationInput
*
aState
void
*
aValue
)
{
MOZ_ASSERT
(
aFrame
"
non
-
null
frame
required
"
)
;
MOZ_ASSERT
(
aState
"
non
-
null
state
required
"
)
;
if
(
!
DR_state
-
>
mActive
)
return
;
if
(
!
aValue
)
return
;
DR_FrameTreeNode
*
treeNode
=
(
DR_FrameTreeNode
*
)
aValue
;
if
(
treeNode
-
>
mDisplay
)
{
DR_state
-
>
DisplayFrameTypeInfo
(
aFrame
treeNode
-
>
mIndent
)
;
printf
(
"
InitOffsets
=
"
)
;
const
auto
m
=
aState
-
>
ComputedPhysicalMargin
(
)
;
DR_state
-
>
PrintMargin
(
"
m
"
&
m
)
;
const
auto
p
=
aState
-
>
ComputedPhysicalPadding
(
)
;
DR_state
-
>
PrintMargin
(
"
p
"
&
p
)
;
const
auto
bp
=
aState
-
>
ComputedPhysicalBorderPadding
(
)
;
DR_state
-
>
PrintMargin
(
"
b
+
p
"
&
bp
)
;
putchar
(
'
\
n
'
)
;
}
DR_state
-
>
DeleteTreeNode
(
*
treeNode
)
;
}
#
define
CASE
(
side
result
)
\
static_assert
(
SideIsVertical
(
side
)
=
=
result
"
SideIsVertical
is
wrong
"
)
CASE
(
eSideTop
false
)
;
CASE
(
eSideRight
true
)
;
CASE
(
eSideBottom
false
)
;
CASE
(
eSideLeft
true
)
;
#
undef
CASE
#
define
CASE
(
corner
result
)
\
static_assert
(
HalfCornerIsX
(
corner
)
=
=
result
"
HalfCornerIsX
is
wrong
"
)
CASE
(
eCornerTopLeftX
true
)
;
CASE
(
eCornerTopLeftY
false
)
;
CASE
(
eCornerTopRightX
true
)
;
CASE
(
eCornerTopRightY
false
)
;
CASE
(
eCornerBottomRightX
true
)
;
CASE
(
eCornerBottomRightY
false
)
;
CASE
(
eCornerBottomLeftX
true
)
;
CASE
(
eCornerBottomLeftY
false
)
;
#
undef
CASE
#
define
CASE
(
corner
result
)
\
static_assert
(
HalfToFullCorner
(
corner
)
=
=
result
\
"
HalfToFullCorner
is
"
\
"
wrong
"
)
CASE
(
eCornerTopLeftX
eCornerTopLeft
)
;
CASE
(
eCornerTopLeftY
eCornerTopLeft
)
;
CASE
(
eCornerTopRightX
eCornerTopRight
)
;
CASE
(
eCornerTopRightY
eCornerTopRight
)
;
CASE
(
eCornerBottomRightX
eCornerBottomRight
)
;
CASE
(
eCornerBottomRightY
eCornerBottomRight
)
;
CASE
(
eCornerBottomLeftX
eCornerBottomLeft
)
;
CASE
(
eCornerBottomLeftY
eCornerBottomLeft
)
;
#
undef
CASE
#
define
CASE
(
corner
vert
result
)
\
static_assert
(
FullToHalfCorner
(
corner
vert
)
=
=
result
\
"
FullToHalfCorner
is
wrong
"
)
CASE
(
eCornerTopLeft
false
eCornerTopLeftX
)
;
CASE
(
eCornerTopLeft
true
eCornerTopLeftY
)
;
CASE
(
eCornerTopRight
false
eCornerTopRightX
)
;
CASE
(
eCornerTopRight
true
eCornerTopRightY
)
;
CASE
(
eCornerBottomRight
false
eCornerBottomRightX
)
;
CASE
(
eCornerBottomRight
true
eCornerBottomRightY
)
;
CASE
(
eCornerBottomLeft
false
eCornerBottomLeftX
)
;
CASE
(
eCornerBottomLeft
true
eCornerBottomLeftY
)
;
#
undef
CASE
#
define
CASE
(
side
second
result
)
\
static_assert
(
SideToFullCorner
(
side
second
)
=
=
result
\
"
SideToFullCorner
is
wrong
"
)
CASE
(
eSideTop
false
eCornerTopLeft
)
;
CASE
(
eSideTop
true
eCornerTopRight
)
;
CASE
(
eSideRight
false
eCornerTopRight
)
;
CASE
(
eSideRight
true
eCornerBottomRight
)
;
CASE
(
eSideBottom
false
eCornerBottomRight
)
;
CASE
(
eSideBottom
true
eCornerBottomLeft
)
;
CASE
(
eSideLeft
false
eCornerBottomLeft
)
;
CASE
(
eSideLeft
true
eCornerTopLeft
)
;
#
undef
CASE
#
define
CASE
(
side
second
parallel
result
)
\
static_assert
(
SideToHalfCorner
(
side
second
parallel
)
=
=
result
\
"
SideToHalfCorner
is
wrong
"
)
CASE
(
eSideTop
false
true
eCornerTopLeftX
)
;
CASE
(
eSideTop
false
false
eCornerTopLeftY
)
;
CASE
(
eSideTop
true
true
eCornerTopRightX
)
;
CASE
(
eSideTop
true
false
eCornerTopRightY
)
;
CASE
(
eSideRight
false
false
eCornerTopRightX
)
;
CASE
(
eSideRight
false
true
eCornerTopRightY
)
;
CASE
(
eSideRight
true
false
eCornerBottomRightX
)
;
CASE
(
eSideRight
true
true
eCornerBottomRightY
)
;
CASE
(
eSideBottom
false
true
eCornerBottomRightX
)
;
CASE
(
eSideBottom
false
false
eCornerBottomRightY
)
;
CASE
(
eSideBottom
true
true
eCornerBottomLeftX
)
;
CASE
(
eSideBottom
true
false
eCornerBottomLeftY
)
;
CASE
(
eSideLeft
false
false
eCornerBottomLeftX
)
;
CASE
(
eSideLeft
false
true
eCornerBottomLeftY
)
;
CASE
(
eSideLeft
true
false
eCornerTopLeftX
)
;
CASE
(
eSideLeft
true
true
eCornerTopLeftY
)
;
#
undef
CASE
#
endif
