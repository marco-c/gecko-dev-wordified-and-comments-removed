#
include
"
nsSimplePageSequenceFrame
.
h
"
#
include
"
DateTimeFormat
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDeviceContext
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsIPrintSettings
.
h
"
#
include
"
nsPageFrame
.
h
"
#
include
"
nsSubDocumentFrame
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsHTMLCanvasFrame
.
h
"
#
include
"
mozilla
/
dom
/
HTMLCanvasElement
.
h
"
#
include
"
nsICanvasRenderingContextInternal
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
<
algorithm
>
#
define
OFFSET_NOT_SET
-
1
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
#
include
"
mozilla
/
Logging
.
h
"
mozilla
:
:
LazyLogModule
gLayoutPrintingLog
(
"
printing
-
layout
"
)
;
#
define
PR_PL
(
_p1
)
MOZ_LOG
(
gLayoutPrintingLog
mozilla
:
:
LogLevel
:
:
Debug
_p1
)
nsSimplePageSequenceFrame
*
NS_NewSimplePageSequenceFrame
(
nsIPresShell
*
aPresShell
nsStyleContext
*
aContext
)
{
return
new
(
aPresShell
)
nsSimplePageSequenceFrame
(
aContext
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsSimplePageSequenceFrame
)
nsSimplePageSequenceFrame
:
:
nsSimplePageSequenceFrame
(
nsStyleContext
*
aContext
)
:
nsContainerFrame
(
aContext
kClassID
)
mTotalPages
(
-
1
)
mSelectionHeight
(
-
1
)
mYSelOffset
(
0
)
mCalledBeginPage
(
false
)
mCurrentCanvasListSetup
(
false
)
{
nscoord
halfInch
=
PresContext
(
)
-
>
CSSTwipsToAppUnits
(
NS_INCHES_TO_TWIPS
(
0
.
5
)
)
;
mMargin
.
SizeTo
(
halfInch
halfInch
halfInch
halfInch
)
;
mPageData
=
new
nsSharedPageData
(
)
;
mPageData
-
>
mHeadFootFont
=
*
PresContext
(
)
-
>
GetDefaultFont
(
kGenericFont_serif
aContext
-
>
StyleFont
(
)
-
>
mLanguage
)
;
mPageData
-
>
mHeadFootFont
.
size
=
nsPresContext
:
:
CSSPointsToAppUnits
(
10
)
;
SetPageNumberFormat
(
"
pagenumber
"
"
%
1
d
"
true
)
;
SetPageNumberFormat
(
"
pageofpages
"
"
%
1
d
of
%
2
d
"
false
)
;
}
nsSimplePageSequenceFrame
:
:
~
nsSimplePageSequenceFrame
(
)
{
delete
mPageData
;
ResetPrintCanvasList
(
)
;
}
NS_QUERYFRAME_HEAD
(
nsSimplePageSequenceFrame
)
NS_QUERYFRAME_ENTRY
(
nsIPageSequenceFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsContainerFrame
)
void
nsSimplePageSequenceFrame
:
:
SetDesiredSize
(
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nscoord
aWidth
nscoord
aHeight
)
{
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
nscoord
scaledWidth
=
aWidth
*
PresContext
(
)
-
>
GetPrintPreviewScale
(
)
;
nscoord
scaledHeight
=
aHeight
*
PresContext
(
)
-
>
GetPrintPreviewScale
(
)
;
nscoord
scaledISize
=
(
wm
.
IsVertical
(
)
?
scaledHeight
:
scaledWidth
)
;
nscoord
scaledBSize
=
(
wm
.
IsVertical
(
)
?
scaledWidth
:
scaledHeight
)
;
aDesiredSize
.
ISize
(
wm
)
=
std
:
:
max
(
scaledISize
aReflowInput
.
AvailableISize
(
)
)
;
aDesiredSize
.
BSize
(
wm
)
=
std
:
:
max
(
scaledBSize
aReflowInput
.
ComputedBSize
(
)
)
;
}
nscoord
nsSimplePageSequenceFrame
:
:
ComputeCenteringMargin
(
nscoord
aContainerContentBoxWidth
nscoord
aChildPaddingBoxWidth
const
nsMargin
&
aChildPhysicalMargin
)
{
nscoord
childMarginBoxWidth
=
aChildPaddingBoxWidth
+
aChildPhysicalMargin
.
LeftRight
(
)
;
auto
ppScale
=
PresContext
(
)
-
>
GetPrintPreviewScale
(
)
;
nscoord
scaledChildMarginBoxWidth
=
NSToCoordRound
(
childMarginBoxWidth
*
ppScale
)
;
nscoord
scaledExtraSpace
=
aContainerContentBoxWidth
-
scaledChildMarginBoxWidth
;
if
(
scaledExtraSpace
<
=
0
)
{
return
0
;
}
return
NSToCoordRound
(
scaledExtraSpace
*
0
.
5
/
ppScale
)
;
}
void
nsSimplePageSequenceFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
NS_PRECONDITION
(
aPresContext
-
>
IsRootPaginatedDocument
(
)
"
A
Page
Sequence
is
only
for
real
pages
"
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsSimplePageSequenceFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aDesiredSize
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
NS_FRAME_TRACE_REFLOW_IN
(
"
nsSimplePageSequenceFrame
:
:
Reflow
"
)
;
if
(
!
(
GetStateBits
(
)
&
NS_FRAME_FIRST_REFLOW
)
)
{
SetDesiredSize
(
aDesiredSize
aReflowInput
mSize
.
width
mSize
.
height
)
;
aDesiredSize
.
SetOverflowAreasToDesiredBounds
(
)
;
FinishAndStoreOverflow
(
&
aDesiredSize
)
;
if
(
GetRect
(
)
.
Width
(
)
!
=
aDesiredSize
.
Width
(
)
)
{
for
(
nsFrameList
:
:
Enumerator
e
(
mFrames
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
)
{
nsIFrame
*
child
=
e
.
get
(
)
;
nsMargin
pageCSSMargin
=
child
-
>
GetUsedMargin
(
)
;
nscoord
centeringMargin
=
ComputeCenteringMargin
(
aReflowInput
.
ComputedWidth
(
)
child
-
>
GetRect
(
)
.
Width
(
)
pageCSSMargin
)
;
nscoord
newX
=
pageCSSMargin
.
left
+
centeringMargin
;
child
-
>
MovePositionBy
(
nsPoint
(
newX
-
child
-
>
GetNormalPosition
(
)
.
x
0
)
)
;
}
}
return
;
}
if
(
!
mPageData
-
>
mPrintSettings
&
&
aPresContext
-
>
Medium
(
)
=
=
nsGkAtoms
:
:
print
)
{
mPageData
-
>
mPrintSettings
=
aPresContext
-
>
GetPrintSettings
(
)
;
}
if
(
mPageData
-
>
mPrintSettings
)
{
nsIntMargin
unwriteableTwips
;
mPageData
-
>
mPrintSettings
-
>
GetUnwriteableMarginInTwips
(
unwriteableTwips
)
;
NS_ASSERTION
(
unwriteableTwips
.
left
>
=
0
&
&
unwriteableTwips
.
top
>
=
0
&
&
unwriteableTwips
.
right
>
=
0
&
&
unwriteableTwips
.
bottom
>
=
0
"
Unwriteable
twips
should
be
non
-
negative
"
)
;
nsIntMargin
marginTwips
;
mPageData
-
>
mPrintSettings
-
>
GetMarginInTwips
(
marginTwips
)
;
mMargin
=
aPresContext
-
>
CSSTwipsToAppUnits
(
marginTwips
+
unwriteableTwips
)
;
int16_t
printType
;
mPageData
-
>
mPrintSettings
-
>
GetPrintRange
(
&
printType
)
;
mPrintRangeType
=
printType
;
nsIntMargin
edgeTwips
;
mPageData
-
>
mPrintSettings
-
>
GetEdgeInTwips
(
edgeTwips
)
;
int32_t
inchInTwips
=
NS_INCHES_TO_INT_TWIPS
(
3
.
0
)
;
edgeTwips
.
top
=
clamped
(
edgeTwips
.
top
0
inchInTwips
)
;
edgeTwips
.
bottom
=
clamped
(
edgeTwips
.
bottom
0
inchInTwips
)
;
edgeTwips
.
left
=
clamped
(
edgeTwips
.
left
0
inchInTwips
)
;
edgeTwips
.
right
=
clamped
(
edgeTwips
.
right
0
inchInTwips
)
;
mPageData
-
>
mEdgePaperMargin
=
aPresContext
-
>
CSSTwipsToAppUnits
(
edgeTwips
+
unwriteableTwips
)
;
}
nsSize
pageSize
=
aPresContext
-
>
GetPageSize
(
)
;
mPageData
-
>
mReflowSize
=
pageSize
;
if
(
nsIPrintSettings
:
:
kRangeSelection
=
=
mPrintRangeType
)
{
mPageData
-
>
mReflowSize
.
height
=
NS_UNCONSTRAINEDSIZE
;
}
mPageData
-
>
mReflowMargin
=
mMargin
;
nscoord
y
=
0
;
nscoord
maxXMost
=
0
;
ReflowOutput
kidSize
(
aReflowInput
)
;
for
(
nsFrameList
:
:
Enumerator
e
(
mFrames
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
)
{
nsIFrame
*
kidFrame
=
e
.
get
(
)
;
nsPageFrame
*
pf
=
static_cast
<
nsPageFrame
*
>
(
kidFrame
)
;
pf
-
>
SetSharedPageData
(
mPageData
)
;
ReflowInput
kidReflowInput
(
aPresContext
aReflowInput
kidFrame
LogicalSize
(
kidFrame
-
>
GetWritingMode
(
)
pageSize
)
)
;
nsReflowStatus
status
;
kidReflowInput
.
SetComputedISize
(
kidReflowInput
.
AvailableISize
(
)
)
;
PR_PL
(
(
"
AV
ISize
:
%
d
BSize
:
%
d
\
n
"
kidReflowInput
.
AvailableISize
(
)
kidReflowInput
.
AvailableBSize
(
)
)
)
;
nsMargin
pageCSSMargin
=
kidReflowInput
.
ComputedPhysicalMargin
(
)
;
y
+
=
pageCSSMargin
.
top
;
nscoord
x
=
pageCSSMargin
.
left
;
ReflowChild
(
kidFrame
aPresContext
kidSize
kidReflowInput
x
y
0
status
)
;
x
+
=
ComputeCenteringMargin
(
aReflowInput
.
ComputedWidth
(
)
kidSize
.
Width
(
)
pageCSSMargin
)
;
FinishReflowChild
(
kidFrame
aPresContext
kidSize
nullptr
x
y
0
)
;
y
+
=
kidSize
.
Height
(
)
;
y
+
=
pageCSSMargin
.
bottom
;
maxXMost
=
std
:
:
max
(
maxXMost
x
+
kidSize
.
Width
(
)
+
pageCSSMargin
.
right
)
;
nsIFrame
*
kidNextInFlow
=
kidFrame
-
>
GetNextInFlow
(
)
;
if
(
status
.
IsFullyComplete
(
)
)
{
NS_ASSERTION
(
!
kidNextInFlow
"
bad
child
flow
list
"
)
;
}
else
if
(
!
kidNextInFlow
)
{
nsIFrame
*
continuingPage
=
aPresContext
-
>
PresShell
(
)
-
>
FrameConstructor
(
)
-
>
CreateContinuingFrame
(
aPresContext
kidFrame
this
)
;
mFrames
.
InsertFrame
(
nullptr
kidFrame
continuingPage
)
;
}
}
int32_t
pageTot
=
mFrames
.
GetLength
(
)
;
int32_t
pageNum
=
1
;
for
(
nsFrameList
:
:
Enumerator
e
(
mFrames
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
)
{
MOZ_ASSERT
(
e
.
get
(
)
-
>
IsPageFrame
(
)
"
only
expecting
nsPageFrame
children
.
Other
children
will
make
"
"
this
static_cast
bogus
&
probably
violate
other
assumptions
"
)
;
nsPageFrame
*
pf
=
static_cast
<
nsPageFrame
*
>
(
e
.
get
(
)
)
;
pf
-
>
SetPageNumInfo
(
pageNum
pageTot
)
;
pageNum
+
+
;
}
nsAutoString
formattedDateString
;
PRTime
now
=
PR_Now
(
)
;
if
(
NS_SUCCEEDED
(
DateTimeFormat
:
:
FormatPRTime
(
kDateFormatShort
kTimeFormatNoSeconds
now
formattedDateString
)
)
)
{
SetDateTimeStr
(
formattedDateString
)
;
}
SetDesiredSize
(
aDesiredSize
aReflowInput
maxXMost
y
)
;
aDesiredSize
.
SetOverflowAreasToDesiredBounds
(
)
;
FinishAndStoreOverflow
(
&
aDesiredSize
)
;
mSize
.
width
=
maxXMost
;
mSize
.
height
=
y
;
NS_FRAME_TRACE_REFLOW_OUT
(
"
nsSimplePageSequeceFrame
:
:
Reflow
"
aStatus
)
;
NS_FRAME_SET_TRUNCATION
(
aStatus
aReflowInput
aDesiredSize
)
;
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
nsSimplePageSequenceFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
NS_LITERAL_STRING
(
"
SimplePageSequence
"
)
aResult
)
;
}
#
endif
NS_IMETHODIMP
nsSimplePageSequenceFrame
:
:
GetCurrentPageNum
(
int32_t
*
aPageNum
)
{
NS_ENSURE_ARG_POINTER
(
aPageNum
)
;
*
aPageNum
=
mPageNum
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSimplePageSequenceFrame
:
:
GetNumPages
(
int32_t
*
aNumPages
)
{
NS_ENSURE_ARG_POINTER
(
aNumPages
)
;
*
aNumPages
=
mTotalPages
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSimplePageSequenceFrame
:
:
IsDoingPrintRange
(
bool
*
aDoing
)
{
NS_ENSURE_ARG_POINTER
(
aDoing
)
;
*
aDoing
=
mDoingPageRange
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSimplePageSequenceFrame
:
:
GetPrintRange
(
int32_t
*
aFromPage
int32_t
*
aToPage
)
{
NS_ENSURE_ARG_POINTER
(
aFromPage
)
;
NS_ENSURE_ARG_POINTER
(
aToPage
)
;
*
aFromPage
=
mFromPageNum
;
*
aToPage
=
mToPageNum
;
return
NS_OK
;
}
void
nsSimplePageSequenceFrame
:
:
SetPageNumberFormat
(
const
char
*
aPropName
const
char
*
aDefPropVal
bool
aPageNumOnly
)
{
nsAutoString
pageNumberFormat
;
nsresult
rv
=
nsContentUtils
:
:
GetLocalizedString
(
nsContentUtils
:
:
ePRINTING_PROPERTIES
aPropName
pageNumberFormat
)
;
if
(
NS_FAILED
(
rv
)
)
{
pageNumberFormat
.
AssignASCII
(
aDefPropVal
)
;
}
SetPageNumberFormat
(
pageNumberFormat
aPageNumOnly
)
;
}
NS_IMETHODIMP
nsSimplePageSequenceFrame
:
:
StartPrint
(
nsPresContext
*
aPresContext
nsIPrintSettings
*
aPrintSettings
const
nsAString
&
aDocTitle
const
nsAString
&
aDocURL
)
{
NS_ENSURE_ARG_POINTER
(
aPresContext
)
;
NS_ENSURE_ARG_POINTER
(
aPrintSettings
)
;
if
(
!
mPageData
-
>
mPrintSettings
)
{
mPageData
-
>
mPrintSettings
=
aPrintSettings
;
}
if
(
!
aDocTitle
.
IsEmpty
(
)
)
{
mPageData
-
>
mDocTitle
=
aDocTitle
;
}
if
(
!
aDocURL
.
IsEmpty
(
)
)
{
mPageData
-
>
mDocURL
=
aDocURL
;
}
aPrintSettings
-
>
GetStartPageRange
(
&
mFromPageNum
)
;
aPrintSettings
-
>
GetEndPageRange
(
&
mToPageNum
)
;
aPrintSettings
-
>
GetPageRanges
(
mPageRanges
)
;
mDoingPageRange
=
nsIPrintSettings
:
:
kRangeSpecifiedPageRange
=
=
mPrintRangeType
|
|
nsIPrintSettings
:
:
kRangeSelection
=
=
mPrintRangeType
;
int32_t
totalPages
=
mFrames
.
GetLength
(
)
;
if
(
mDoingPageRange
)
{
if
(
mFromPageNum
>
totalPages
)
{
return
NS_ERROR_INVALID_ARG
;
}
}
nsresult
rv
=
NS_OK
;
aPresContext
-
>
SetIsRenderingOnlySelection
(
nsIPrintSettings
:
:
kRangeSelection
=
=
mPrintRangeType
)
;
if
(
mDoingPageRange
)
{
nscoord
height
=
aPresContext
-
>
GetPageSize
(
)
.
height
;
int32_t
pageNum
=
1
;
nscoord
y
=
0
;
for
(
nsFrameList
:
:
Enumerator
e
(
mFrames
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
)
{
nsIFrame
*
page
=
e
.
get
(
)
;
if
(
pageNum
>
=
mFromPageNum
&
&
pageNum
<
=
mToPageNum
)
{
nsRect
rect
=
page
-
>
GetRect
(
)
;
rect
.
y
=
y
;
rect
.
height
=
height
;
page
-
>
SetRect
(
rect
)
;
y
+
=
rect
.
height
+
mMargin
.
top
+
mMargin
.
bottom
;
}
pageNum
+
+
;
}
if
(
nsIPrintSettings
:
:
kRangeSelection
!
=
mPrintRangeType
)
{
totalPages
=
pageNum
-
1
;
}
}
mPageNum
=
1
;
if
(
mTotalPages
=
=
-
1
)
{
mTotalPages
=
totalPages
;
}
return
rv
;
}
void
GetPrintCanvasElementsInFrame
(
nsIFrame
*
aFrame
nsTArray
<
RefPtr
<
HTMLCanvasElement
>
>
*
aArr
)
{
if
(
!
aFrame
)
{
return
;
}
for
(
nsIFrame
:
:
ChildListIterator
childLists
(
aFrame
)
;
!
childLists
.
IsDone
(
)
;
childLists
.
Next
(
)
)
{
nsFrameList
children
=
childLists
.
CurrentList
(
)
;
for
(
nsFrameList
:
:
Enumerator
e
(
children
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
)
{
nsIFrame
*
child
=
e
.
get
(
)
;
nsHTMLCanvasFrame
*
canvasFrame
=
do_QueryFrame
(
child
)
;
if
(
canvasFrame
)
{
HTMLCanvasElement
*
canvas
=
HTMLCanvasElement
:
:
FromContentOrNull
(
canvasFrame
-
>
GetContent
(
)
)
;
if
(
canvas
&
&
canvas
-
>
GetMozPrintCallback
(
)
)
{
aArr
-
>
AppendElement
(
canvas
)
;
continue
;
}
}
if
(
!
child
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
)
{
nsSubDocumentFrame
*
subdocumentFrame
=
do_QueryFrame
(
child
)
;
if
(
subdocumentFrame
)
{
nsIFrame
*
root
=
subdocumentFrame
-
>
GetSubdocumentRootFrame
(
)
;
child
=
root
;
}
}
GetPrintCanvasElementsInFrame
(
child
aArr
)
;
}
}
}
void
nsSimplePageSequenceFrame
:
:
DetermineWhetherToPrintPage
(
)
{
mPrintThisPage
=
true
;
bool
printEvenPages
printOddPages
;
mPageData
-
>
mPrintSettings
-
>
GetPrintOptions
(
nsIPrintSettings
:
:
kPrintEvenPages
&
printEvenPages
)
;
mPageData
-
>
mPrintSettings
-
>
GetPrintOptions
(
nsIPrintSettings
:
:
kPrintOddPages
&
printOddPages
)
;
if
(
mDoingPageRange
)
{
if
(
mPageNum
<
mFromPageNum
)
{
mPrintThisPage
=
false
;
}
else
if
(
mPageNum
>
mToPageNum
)
{
mPageNum
+
+
;
mPrintThisPage
=
false
;
return
;
}
else
{
int32_t
length
=
mPageRanges
.
Length
(
)
;
if
(
length
&
&
(
length
%
2
=
=
0
)
)
{
mPrintThisPage
=
false
;
int32_t
i
;
for
(
i
=
0
;
i
<
length
;
i
+
=
2
)
{
if
(
mPageRanges
[
i
]
<
=
mPageNum
&
&
mPageNum
<
=
mPageRanges
[
i
+
1
]
)
{
mPrintThisPage
=
true
;
break
;
}
}
}
}
}
if
(
mPageNum
&
0x1
)
{
if
(
!
printOddPages
)
{
mPrintThisPage
=
false
;
}
}
else
{
if
(
!
printEvenPages
)
{
mPrintThisPage
=
false
;
}
}
if
(
nsIPrintSettings
:
:
kRangeSelection
=
=
mPrintRangeType
)
{
mPrintThisPage
=
true
;
}
}
nsIFrame
*
nsSimplePageSequenceFrame
:
:
GetCurrentPageFrame
(
)
{
int32_t
i
=
1
;
for
(
nsFrameList
:
:
Enumerator
childFrames
(
mFrames
)
;
!
childFrames
.
AtEnd
(
)
;
childFrames
.
Next
(
)
)
{
if
(
i
=
=
mPageNum
)
{
return
childFrames
.
get
(
)
;
}
+
+
i
;
}
return
nullptr
;
}
NS_IMETHODIMP
nsSimplePageSequenceFrame
:
:
PrePrintNextPage
(
nsITimerCallback
*
aCallback
bool
*
aDone
)
{
nsIFrame
*
currentPage
=
GetCurrentPageFrame
(
)
;
if
(
!
currentPage
)
{
*
aDone
=
true
;
return
NS_ERROR_FAILURE
;
}
DetermineWhetherToPrintPage
(
)
;
if
(
!
mPrintThisPage
|
|
!
PresContext
(
)
-
>
IsRootPaginatedDocument
(
)
)
{
*
aDone
=
true
;
return
NS_OK
;
}
if
(
!
mCurrentCanvasListSetup
)
{
mCurrentCanvasListSetup
=
true
;
GetPrintCanvasElementsInFrame
(
currentPage
&
mCurrentCanvasList
)
;
if
(
mCurrentCanvasList
.
Length
(
)
!
=
0
)
{
nsresult
rv
=
NS_OK
;
nsDeviceContext
*
dc
=
PresContext
(
)
-
>
DeviceContext
(
)
;
PR_PL
(
(
"
\
n
"
)
)
;
PR_PL
(
(
"
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
BeginPage
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
\
n
"
)
)
;
rv
=
dc
-
>
BeginPage
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mCalledBeginPage
=
true
;
RefPtr
<
gfxContext
>
renderingContext
=
dc
-
>
CreateRenderingContext
(
)
;
NS_ENSURE_TRUE
(
renderingContext
NS_ERROR_OUT_OF_MEMORY
)
;
DrawTarget
*
drawTarget
=
renderingContext
-
>
GetDrawTarget
(
)
;
if
(
NS_WARN_IF
(
!
drawTarget
)
)
{
return
NS_ERROR_FAILURE
;
}
for
(
int32_t
i
=
mCurrentCanvasList
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
HTMLCanvasElement
*
canvas
=
mCurrentCanvasList
[
i
]
;
nsIntSize
size
=
canvas
-
>
GetSize
(
)
;
RefPtr
<
DrawTarget
>
canvasTarget
=
drawTarget
-
>
CreateSimilarDrawTarget
(
size
drawTarget
-
>
GetFormat
(
)
)
;
if
(
!
canvasTarget
)
{
continue
;
}
nsICanvasRenderingContextInternal
*
ctx
=
canvas
-
>
GetContextAtIndex
(
0
)
;
if
(
!
ctx
)
{
continue
;
}
ctx
-
>
InitializeWithDrawTarget
(
nullptr
WrapNotNull
(
canvasTarget
)
)
;
AutoWeakFrame
weakFrame
=
this
;
canvas
-
>
DispatchPrintCallback
(
aCallback
)
;
NS_ENSURE_STATE
(
weakFrame
.
IsAlive
(
)
)
;
}
}
}
uint32_t
doneCounter
=
0
;
for
(
int32_t
i
=
mCurrentCanvasList
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
HTMLCanvasElement
*
canvas
=
mCurrentCanvasList
[
i
]
;
if
(
canvas
-
>
IsPrintCallbackDone
(
)
)
{
doneCounter
+
+
;
}
}
*
aDone
=
doneCounter
=
=
mCurrentCanvasList
.
Length
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSimplePageSequenceFrame
:
:
ResetPrintCanvasList
(
)
{
for
(
int32_t
i
=
mCurrentCanvasList
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
HTMLCanvasElement
*
canvas
=
mCurrentCanvasList
[
i
]
;
canvas
-
>
ResetPrintCallback
(
)
;
}
mCurrentCanvasList
.
Clear
(
)
;
mCurrentCanvasListSetup
=
false
;
return
NS_OK
;
}
NS_IMETHODIMP
nsSimplePageSequenceFrame
:
:
PrintNextPage
(
)
{
nsIFrame
*
currentPageFrame
=
GetCurrentPageFrame
(
)
;
if
(
!
currentPageFrame
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
NS_OK
;
DetermineWhetherToPrintPage
(
)
;
if
(
mPrintThisPage
)
{
nsDeviceContext
*
dc
=
PresContext
(
)
-
>
DeviceContext
(
)
;
nsPageFrame
*
pf
=
static_cast
<
nsPageFrame
*
>
(
currentPageFrame
)
;
pf
-
>
SetPageNumInfo
(
mPageNum
mTotalPages
)
;
pf
-
>
SetSharedPageData
(
mPageData
)
;
nsIFrame
*
selectionContentFrame
=
nullptr
;
nscoord
pageContentHeight
=
PresContext
(
)
-
>
GetPageSize
(
)
.
height
-
(
mMargin
.
top
+
mMargin
.
bottom
)
;
nscoord
selectionY
=
pageContentHeight
;
int32_t
selectionCurrentPageNum
=
1
;
bool
haveUnfinishedSelectionToPrint
=
false
;
if
(
mSelectionHeight
>
=
0
)
{
selectionContentFrame
=
currentPageFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
MOZ_ASSERT
(
selectionContentFrame
-
>
IsPageContentFrame
(
)
&
&
!
selectionContentFrame
-
>
GetNextSibling
(
)
"
Unexpected
frame
tree
"
)
;
selectionContentFrame
-
>
SetPosition
(
selectionContentFrame
-
>
GetPosition
(
)
+
nsPoint
(
0
-
mYSelOffset
)
)
;
nsContainerFrame
:
:
PositionChildViews
(
selectionContentFrame
)
;
}
do
{
if
(
PresContext
(
)
-
>
IsRootPaginatedDocument
(
)
)
{
if
(
!
mCalledBeginPage
)
{
PR_PL
(
(
"
\
n
"
)
)
;
PR_PL
(
(
"
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
BeginPage
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
\
n
"
)
)
;
rv
=
dc
-
>
BeginPage
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
mCalledBeginPage
=
false
;
}
PR_PL
(
(
"
SeqFr
:
:
PrintNextPage
-
>
%
p
PageNo
:
%
d
"
pf
mPageNum
)
)
;
RefPtr
<
gfxContext
>
gCtx
=
dc
-
>
CreateRenderingContext
(
)
;
NS_ENSURE_TRUE
(
gCtx
NS_ERROR_OUT_OF_MEMORY
)
;
nsRect
drawingRect
(
nsPoint
(
0
0
)
currentPageFrame
-
>
GetSize
(
)
)
;
nsRegion
drawingRegion
(
drawingRect
)
;
nsLayoutUtils
:
:
PaintFrame
(
gCtx
currentPageFrame
drawingRegion
NS_RGBA
(
0
0
0
0
)
nsDisplayListBuilderMode
:
:
PAINTING
nsLayoutUtils
:
:
PaintFrameFlags
:
:
PAINT_SYNC_DECODE_IMAGES
)
;
if
(
mSelectionHeight
>
=
0
)
{
haveUnfinishedSelectionToPrint
=
(
selectionY
<
mSelectionHeight
)
;
if
(
haveUnfinishedSelectionToPrint
)
{
selectionY
+
=
pageContentHeight
;
selectionCurrentPageNum
+
+
;
pf
-
>
SetPageNumInfo
(
selectionCurrentPageNum
mTotalPages
)
;
selectionContentFrame
-
>
SetPosition
(
selectionContentFrame
-
>
GetPosition
(
)
+
nsPoint
(
0
-
pageContentHeight
)
)
;
nsContainerFrame
:
:
PositionChildViews
(
selectionContentFrame
)
;
PR_PL
(
(
"
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
End
Page
(
PrintNextPage
)
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
\
n
"
)
)
;
rv
=
dc
-
>
EndPage
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
}
while
(
haveUnfinishedSelectionToPrint
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsSimplePageSequenceFrame
:
:
DoPageEnd
(
)
{
nsresult
rv
=
NS_OK
;
if
(
PresContext
(
)
-
>
IsRootPaginatedDocument
(
)
&
&
mPrintThisPage
)
{
PR_PL
(
(
"
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
End
Page
(
DoPageEnd
)
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
\
n
"
)
)
;
rv
=
PresContext
(
)
-
>
DeviceContext
(
)
-
>
EndPage
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
ResetPrintCanvasList
(
)
;
mPageNum
+
+
;
return
rv
;
}
inline
gfx
:
:
Matrix4x4
ComputePageSequenceTransform
(
nsIFrame
*
aFrame
float
aAppUnitsPerPixel
)
{
float
scale
=
aFrame
-
>
PresContext
(
)
-
>
GetPrintPreviewScale
(
)
;
return
gfx
:
:
Matrix4x4
:
:
Scaling
(
scale
scale
1
)
;
}
void
nsSimplePageSequenceFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
DisplayBorderBackgroundOutline
(
aBuilder
aLists
)
;
nsDisplayList
content
(
aBuilder
)
;
{
DisplayListClipState
:
:
AutoSaveRestore
clipState
(
aBuilder
)
;
clipState
.
Clear
(
)
;
nsIFrame
*
child
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
nsRect
visible
=
aBuilder
-
>
GetVisibleRect
(
)
;
visible
.
ScaleInverseRoundOut
(
PresContext
(
)
-
>
GetPrintPreviewScale
(
)
)
;
while
(
child
)
{
if
(
child
-
>
GetVisualOverflowRectRelativeToParent
(
)
.
Intersects
(
visible
)
)
{
nsDisplayListBuilder
:
:
AutoBuildingDisplayList
buildingForChild
(
aBuilder
child
visible
-
child
-
>
GetPosition
(
)
visible
-
child
-
>
GetPosition
(
)
aBuilder
-
>
IsAtRootOfPseudoStackingContext
(
)
)
;
child
-
>
BuildDisplayListForStackingContext
(
aBuilder
&
content
)
;
aBuilder
-
>
ResetMarkedFramesForDisplayList
(
this
)
;
}
child
=
child
-
>
GetNextSibling
(
)
;
}
}
content
.
AppendNewToTop
(
new
(
aBuilder
)
nsDisplayTransform
(
aBuilder
this
&
content
content
.
GetVisibleRect
(
)
:
:
ComputePageSequenceTransform
)
)
;
aLists
.
Content
(
)
-
>
AppendToTop
(
&
content
)
;
}
void
nsSimplePageSequenceFrame
:
:
SetPageNumberFormat
(
const
nsAString
&
aFormatStr
bool
aForPageNumOnly
)
{
NS_ASSERTION
(
mPageData
!
=
nullptr
"
mPageData
string
cannot
be
null
!
"
)
;
if
(
aForPageNumOnly
)
{
mPageData
-
>
mPageNumFormat
=
aFormatStr
;
}
else
{
mPageData
-
>
mPageNumAndTotalsFormat
=
aFormatStr
;
}
}
void
nsSimplePageSequenceFrame
:
:
SetDateTimeStr
(
const
nsAString
&
aDateTimeStr
)
{
NS_ASSERTION
(
mPageData
!
=
nullptr
"
mPageData
string
cannot
be
null
!
"
)
;
mPageData
-
>
mDateTimeStr
=
aDateTimeStr
;
}
NS_IMETHODIMP
nsSimplePageSequenceFrame
:
:
GetSTFPercent
(
float
&
aSTFPercent
)
{
NS_ENSURE_TRUE
(
mPageData
NS_ERROR_UNEXPECTED
)
;
aSTFPercent
=
mPageData
-
>
mShrinkToFitRatio
;
return
NS_OK
;
}
void
nsSimplePageSequenceFrame
:
:
AppendDirectlyOwnedAnonBoxes
(
nsTArray
<
OwnedAnonBox
>
&
aResult
)
{
if
(
mFrames
.
NotEmpty
(
)
)
{
aResult
.
AppendElement
(
mFrames
.
FirstChild
(
)
)
;
}
}
