#
include
"
nsTextFrame
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ComputedStyle
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
BinarySearch
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
PodOperations
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsBlockFrame
.
h
"
#
include
"
nsFontMetrics
.
h
"
#
include
"
nsSplittableFrame
.
h
"
#
include
"
nsLineLayout
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsStyleStruct
.
h
"
#
include
"
nsStyleStructInlines
.
h
"
#
include
"
SVGTextFrame
.
h
"
#
include
"
nsCoord
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
nsCompatibility
.
h
"
#
include
"
nsCSSColorUtils
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsFrame
.
h
"
#
include
"
nsIMathMLFrame
.
h
"
#
include
"
nsPlaceholderFrame
.
h
"
#
include
"
nsTextFrameUtils
.
h
"
#
include
"
nsTextRunTransformations
.
h
"
#
include
"
MathMLTextRunFactory
.
h
"
#
include
"
nsUnicodeProperties
.
h
"
#
include
"
nsStyleUtil
.
h
"
#
include
"
nsRubyFrame
.
h
"
#
include
"
TextDrawTarget
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsCSSRendering
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsLineBreaker
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
mozilla
/
intl
/
WordBreaker
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
mozilla
/
layers
/
LayersMessages
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderLayerManager
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderBridgeChild
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderAPI
.
h
"
#
include
"
mozilla
/
layers
/
StackingContextHelper
.
h
"
#
include
<
algorithm
>
#
include
<
limits
>
#
ifdef
ACCESSIBILITY
#
include
"
nsAccessibilityService
.
h
"
#
endif
#
include
"
nsPrintfCString
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
mozilla
/
gfx
/
DrawTargetRecording
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
ifdef
DEBUG
#
undef
NOISY_REFLOW
#
undef
NOISY_TRIM
#
else
#
undef
NOISY_REFLOW
#
undef
NOISY_TRIM
#
endif
#
ifdef
DrawText
#
undef
DrawText
#
endif
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
layers
;
typedef
mozilla
:
:
layout
:
:
TextDrawTarget
TextDrawTarget
;
struct
TabWidth
{
TabWidth
(
uint32_t
aOffset
uint32_t
aWidth
)
:
mOffset
(
aOffset
)
mWidth
(
float
(
aWidth
)
)
{
}
uint32_t
mOffset
;
float
mWidth
;
}
;
struct
TabWidthStore
{
explicit
TabWidthStore
(
int32_t
aValidForContentOffset
)
:
mLimit
(
0
)
mValidForContentOffset
(
aValidForContentOffset
)
{
}
void
ApplySpacing
(
gfxTextRun
:
:
PropertyProvider
:
:
Spacing
*
aSpacing
uint32_t
aOffset
uint32_t
aLength
)
;
uint32_t
mLimit
;
int32_t
mValidForContentOffset
;
nsTArray
<
TabWidth
>
mWidths
;
}
;
namespace
{
struct
TabwidthAdaptor
{
const
nsTArray
<
TabWidth
>
&
mWidths
;
explicit
TabwidthAdaptor
(
const
nsTArray
<
TabWidth
>
&
aWidths
)
:
mWidths
(
aWidths
)
{
}
uint32_t
operator
[
]
(
size_t
aIdx
)
const
{
return
mWidths
[
aIdx
]
.
mOffset
;
}
}
;
}
void
TabWidthStore
:
:
ApplySpacing
(
gfxTextRun
:
:
PropertyProvider
:
:
Spacing
*
aSpacing
uint32_t
aOffset
uint32_t
aLength
)
{
size_t
i
=
0
;
const
size_t
len
=
mWidths
.
Length
(
)
;
if
(
aOffset
>
0
)
{
mozilla
:
:
BinarySearch
(
TabwidthAdaptor
(
mWidths
)
0
len
aOffset
&
i
)
;
}
uint32_t
limit
=
aOffset
+
aLength
;
while
(
i
<
len
)
{
const
TabWidth
&
tw
=
mWidths
[
i
]
;
if
(
tw
.
mOffset
>
=
limit
)
{
break
;
}
aSpacing
[
tw
.
mOffset
-
aOffset
]
.
mAfter
+
=
tw
.
mWidth
;
i
+
+
;
}
}
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
TabWidthProperty
TabWidthStore
)
NS_DECLARE_FRAME_PROPERTY_WITHOUT_DTOR
(
OffsetToFrameProperty
nsTextFrame
)
NS_DECLARE_FRAME_PROPERTY_RELEASABLE
(
UninflatedTextRunProperty
gfxTextRun
)
NS_DECLARE_FRAME_PROPERTY_SMALL_VALUE
(
FontSizeInflationProperty
float
)
class
GlyphObserver
:
public
gfxFont
:
:
GlyphChangeObserver
{
public
:
GlyphObserver
(
gfxFont
*
aFont
gfxTextRun
*
aTextRun
)
:
gfxFont
:
:
GlyphChangeObserver
(
aFont
)
mTextRun
(
aTextRun
)
{
MOZ_ASSERT
(
aTextRun
-
>
GetUserData
(
)
)
;
}
virtual
void
NotifyGlyphsChanged
(
)
override
;
private
:
gfxTextRun
*
mTextRun
;
}
;
static
const
nsFrameState
TEXT_REFLOW_FLAGS
=
TEXT_FIRST_LETTER
|
TEXT_START_OF_LINE
|
TEXT_END_OF_LINE
|
TEXT_HYPHEN_BREAK
|
TEXT_TRIMMED_TRAILING_WHITESPACE
|
TEXT_JUSTIFICATION_ENABLED
|
TEXT_HAS_NONCOLLAPSED_CHARACTERS
|
TEXT_SELECTION_UNDERLINE_OVERFLOWED
|
TEXT_NO_RENDERED_GLYPHS
;
static
const
nsFrameState
TEXT_WHITESPACE_FLAGS
=
TEXT_IS_ONLY_WHITESPACE
|
TEXT_ISNOT_ONLY_WHITESPACE
;
struct
SimpleTextRunUserData
{
nsTArray
<
UniquePtr
<
GlyphObserver
>
>
mGlyphObservers
;
nsTextFrame
*
mFrame
;
explicit
SimpleTextRunUserData
(
nsTextFrame
*
aFrame
)
:
mFrame
(
aFrame
)
{
}
}
;
struct
TextRunMappedFlow
{
nsTextFrame
*
mStartFrame
;
int32_t
mDOMOffsetToBeforeTransformOffset
;
uint32_t
mContentLength
;
}
;
struct
TextRunUserData
{
#
ifdef
DEBUG
TextRunMappedFlow
*
mMappedFlows
;
#
endif
uint32_t
mMappedFlowCount
;
uint32_t
mLastFlowIndex
;
}
;
struct
ComplexTextRunUserData
:
public
TextRunUserData
{
nsTArray
<
UniquePtr
<
GlyphObserver
>
>
mGlyphObservers
;
}
;
class
nsTextPaintStyle
{
public
:
explicit
nsTextPaintStyle
(
nsTextFrame
*
aFrame
)
;
void
SetResolveColors
(
bool
aResolveColors
)
{
mResolveColors
=
aResolveColors
;
}
nscolor
GetTextColor
(
)
;
nscolor
GetWebkitTextStrokeColor
(
)
{
if
(
nsSVGUtils
:
:
IsInSVGTextSubtree
(
mFrame
)
)
{
return
0
;
}
return
mFrame
-
>
StyleText
(
)
-
>
mWebkitTextStrokeColor
.
CalcColor
(
mFrame
)
;
}
float
GetWebkitTextStrokeWidth
(
)
{
if
(
nsSVGUtils
:
:
IsInSVGTextSubtree
(
mFrame
)
)
{
return
0
.
0f
;
}
nscoord
coord
=
mFrame
-
>
StyleText
(
)
-
>
mWebkitTextStrokeWidth
;
return
mFrame
-
>
PresContext
(
)
-
>
AppUnitsToFloatDevPixels
(
coord
)
;
}
bool
GetSelectionColors
(
nscolor
*
aForeColor
nscolor
*
aBackColor
)
;
void
GetHighlightColors
(
nscolor
*
aForeColor
nscolor
*
aBackColor
)
;
void
GetURLSecondaryColor
(
nscolor
*
aForeColor
)
;
void
GetIMESelectionColors
(
int32_t
aIndex
nscolor
*
aForeColor
nscolor
*
aBackColor
)
;
bool
GetSelectionUnderlineForPaint
(
int32_t
aIndex
nscolor
*
aLineColor
float
*
aRelativeSize
uint8_t
*
aStyle
)
;
static
bool
GetSelectionUnderline
(
nsPresContext
*
aPresContext
int32_t
aIndex
nscolor
*
aLineColor
float
*
aRelativeSize
uint8_t
*
aStyle
)
;
bool
GetSelectionShadow
(
nsCSSShadowArray
*
*
aShadow
)
;
nsPresContext
*
PresContext
(
)
const
{
return
mPresContext
;
}
enum
{
eIndexRawInput
=
0
eIndexSelRawText
eIndexConvText
eIndexSelConvText
eIndexSpellChecker
}
;
static
int32_t
GetUnderlineStyleIndexForSelectionType
(
SelectionType
aSelectionType
)
{
switch
(
aSelectionType
)
{
case
SelectionType
:
:
eIMERawClause
:
return
eIndexRawInput
;
case
SelectionType
:
:
eIMESelectedRawClause
:
return
eIndexSelRawText
;
case
SelectionType
:
:
eIMEConvertedClause
:
return
eIndexConvText
;
case
SelectionType
:
:
eIMESelectedClause
:
return
eIndexSelConvText
;
case
SelectionType
:
:
eSpellCheck
:
return
eIndexSpellChecker
;
default
:
NS_WARNING
(
"
non
-
IME
selection
type
"
)
;
return
eIndexRawInput
;
}
}
nscolor
GetSystemFieldForegroundColor
(
)
;
nscolor
GetSystemFieldBackgroundColor
(
)
;
protected
:
nsTextFrame
*
mFrame
;
nsPresContext
*
mPresContext
;
bool
mInitCommonColors
;
bool
mInitSelectionColorsAndShadow
;
bool
mResolveColors
;
nscolor
mSelectionTextColor
;
nscolor
mSelectionBGColor
;
RefPtr
<
nsCSSShadowArray
>
mSelectionShadow
;
bool
mHasSelectionShadow
;
int32_t
mSufficientContrast
;
nscolor
mFrameBackgroundColor
;
nscolor
mSystemFieldForegroundColor
;
nscolor
mSystemFieldBackgroundColor
;
struct
nsSelectionStyle
{
bool
mInit
;
nscolor
mTextColor
;
nscolor
mBGColor
;
nscolor
mUnderlineColor
;
uint8_t
mUnderlineStyle
;
float
mUnderlineRelativeSize
;
}
;
nsSelectionStyle
mSelectionStyle
[
5
]
;
void
InitCommonColors
(
)
;
bool
InitSelectionColorsAndShadow
(
)
;
nsSelectionStyle
*
GetSelectionStyle
(
int32_t
aIndex
)
;
void
InitSelectionStyle
(
int32_t
aIndex
)
;
bool
EnsureSufficientContrast
(
nscolor
*
aForeColor
nscolor
*
aBackColor
)
;
nscolor
GetResolvedForeColor
(
nscolor
aColor
nscolor
aDefaultForeColor
nscolor
aBackColor
)
;
}
;
static
TextRunUserData
*
CreateUserData
(
uint32_t
aMappedFlowCount
)
{
TextRunUserData
*
data
=
static_cast
<
TextRunUserData
*
>
(
moz_xmalloc
(
sizeof
(
TextRunUserData
)
+
aMappedFlowCount
*
sizeof
(
TextRunMappedFlow
)
)
)
;
#
ifdef
DEBUG
data
-
>
mMappedFlows
=
reinterpret_cast
<
TextRunMappedFlow
*
>
(
data
+
1
)
;
#
endif
data
-
>
mMappedFlowCount
=
aMappedFlowCount
;
data
-
>
mLastFlowIndex
=
0
;
return
data
;
}
static
void
DestroyUserData
(
TextRunUserData
*
aUserData
)
{
if
(
aUserData
)
{
free
(
aUserData
)
;
}
}
static
ComplexTextRunUserData
*
CreateComplexUserData
(
uint32_t
aMappedFlowCount
)
{
ComplexTextRunUserData
*
data
=
static_cast
<
ComplexTextRunUserData
*
>
(
moz_xmalloc
(
sizeof
(
ComplexTextRunUserData
)
+
aMappedFlowCount
*
sizeof
(
TextRunMappedFlow
)
)
)
;
new
(
data
)
ComplexTextRunUserData
(
)
;
#
ifdef
DEBUG
data
-
>
mMappedFlows
=
reinterpret_cast
<
TextRunMappedFlow
*
>
(
data
+
1
)
;
#
endif
data
-
>
mMappedFlowCount
=
aMappedFlowCount
;
data
-
>
mLastFlowIndex
=
0
;
return
data
;
}
static
void
DestroyComplexUserData
(
ComplexTextRunUserData
*
aUserData
)
{
if
(
aUserData
)
{
aUserData
-
>
~
ComplexTextRunUserData
(
)
;
free
(
aUserData
)
;
}
}
static
void
DestroyTextRunUserData
(
gfxTextRun
*
aTextRun
)
{
MOZ_ASSERT
(
aTextRun
-
>
GetUserData
(
)
)
;
if
(
aTextRun
-
>
GetFlags2
(
)
&
nsTextFrameUtils
:
:
Flags
:
:
TEXT_IS_SIMPLE_FLOW
)
{
if
(
aTextRun
-
>
GetFlags2
(
)
&
nsTextFrameUtils
:
:
Flags
:
:
TEXT_MIGHT_HAVE_GLYPH_CHANGES
)
{
delete
static_cast
<
SimpleTextRunUserData
*
>
(
aTextRun
-
>
GetUserData
(
)
)
;
}
}
else
{
if
(
aTextRun
-
>
GetFlags2
(
)
&
nsTextFrameUtils
:
:
Flags
:
:
TEXT_MIGHT_HAVE_GLYPH_CHANGES
)
{
DestroyComplexUserData
(
static_cast
<
ComplexTextRunUserData
*
>
(
aTextRun
-
>
GetUserData
(
)
)
)
;
}
else
{
DestroyUserData
(
static_cast
<
TextRunUserData
*
>
(
aTextRun
-
>
GetUserData
(
)
)
)
;
}
}
aTextRun
-
>
ClearFlagBits
(
nsTextFrameUtils
:
:
Flags
:
:
TEXT_MIGHT_HAVE_GLYPH_CHANGES
)
;
aTextRun
-
>
SetUserData
(
nullptr
)
;
}
static
TextRunMappedFlow
*
GetMappedFlows
(
const
gfxTextRun
*
aTextRun
)
{
MOZ_ASSERT
(
aTextRun
-
>
GetUserData
(
)
"
UserData
must
exist
.
"
)
;
MOZ_ASSERT
(
!
(
aTextRun
-
>
GetFlags2
(
)
&
nsTextFrameUtils
:
:
Flags
:
:
TEXT_IS_SIMPLE_FLOW
)
"
The
method
should
not
be
called
for
simple
flows
.
"
)
;
TextRunMappedFlow
*
flows
;
if
(
aTextRun
-
>
GetFlags2
(
)
&
nsTextFrameUtils
:
:
Flags
:
:
TEXT_MIGHT_HAVE_GLYPH_CHANGES
)
{
flows
=
reinterpret_cast
<
TextRunMappedFlow
*
>
(
static_cast
<
ComplexTextRunUserData
*
>
(
aTextRun
-
>
GetUserData
(
)
)
+
1
)
;
}
else
{
flows
=
reinterpret_cast
<
TextRunMappedFlow
*
>
(
static_cast
<
TextRunUserData
*
>
(
aTextRun
-
>
GetUserData
(
)
)
+
1
)
;
}
MOZ_ASSERT
(
static_cast
<
TextRunUserData
*
>
(
aTextRun
-
>
GetUserData
(
)
)
-
>
mMappedFlows
=
=
flows
"
GetMappedFlows
should
return
the
same
pointer
as
mMappedFlows
.
"
)
;
return
flows
;
}
static
nsTextFrame
*
GetFrameForSimpleFlow
(
const
gfxTextRun
*
aTextRun
)
{
MOZ_ASSERT
(
aTextRun
-
>
GetFlags2
(
)
&
nsTextFrameUtils
:
:
Flags
:
:
TEXT_IS_SIMPLE_FLOW
"
Not
so
simple
flow
?
"
)
;
if
(
aTextRun
-
>
GetFlags2
(
)
&
nsTextFrameUtils
:
:
Flags
:
:
TEXT_MIGHT_HAVE_GLYPH_CHANGES
)
{
return
static_cast
<
SimpleTextRunUserData
*
>
(
aTextRun
-
>
GetUserData
(
)
)
-
>
mFrame
;
}
return
static_cast
<
nsTextFrame
*
>
(
aTextRun
-
>
GetUserData
(
)
)
;
}
static
bool
ClearAllTextRunReferences
(
nsTextFrame
*
aFrame
gfxTextRun
*
aTextRun
nsTextFrame
*
aStartContinuation
nsFrameState
aWhichTextRunState
)
{
MOZ_ASSERT
(
aFrame
"
null
frame
"
)
;
MOZ_ASSERT
(
!
aStartContinuation
|
|
(
!
aStartContinuation
-
>
GetTextRun
(
nsTextFrame
:
:
eInflated
)
|
|
aStartContinuation
-
>
GetTextRun
(
nsTextFrame
:
:
eInflated
)
=
=
aTextRun
)
|
|
(
!
aStartContinuation
-
>
GetTextRun
(
nsTextFrame
:
:
eNotInflated
)
|
|
aStartContinuation
-
>
GetTextRun
(
nsTextFrame
:
:
eNotInflated
)
=
=
aTextRun
)
"
wrong
aStartContinuation
for
this
text
run
"
)
;
if
(
!
aStartContinuation
|
|
aStartContinuation
=
=
aFrame
)
{
aFrame
-
>
RemoveStateBits
(
aWhichTextRunState
)
;
}
else
{
do
{
NS_ASSERTION
(
aFrame
-
>
IsTextFrame
(
)
"
Bad
frame
"
)
;
aFrame
=
aFrame
-
>
GetNextContinuation
(
)
;
}
while
(
aFrame
&
&
aFrame
!
=
aStartContinuation
)
;
}
bool
found
=
aStartContinuation
=
=
aFrame
;
while
(
aFrame
)
{
NS_ASSERTION
(
aFrame
-
>
IsTextFrame
(
)
"
Bad
frame
"
)
;
if
(
!
aFrame
-
>
RemoveTextRun
(
aTextRun
)
)
{
break
;
}
aFrame
=
aFrame
-
>
GetNextContinuation
(
)
;
}
MOZ_ASSERT
(
!
found
|
|
aStartContinuation
"
how
did
we
find
null
?
"
)
;
return
found
;
}
static
void
UnhookTextRunFromFrames
(
gfxTextRun
*
aTextRun
nsTextFrame
*
aStartContinuation
)
{
if
(
!
aTextRun
-
>
GetUserData
(
)
)
{
return
;
}
if
(
aTextRun
-
>
GetFlags2
(
)
&
nsTextFrameUtils
:
:
Flags
:
:
TEXT_IS_SIMPLE_FLOW
)
{
nsTextFrame
*
userDataFrame
=
GetFrameForSimpleFlow
(
aTextRun
)
;
nsFrameState
whichTextRunState
=
userDataFrame
-
>
GetTextRun
(
nsTextFrame
:
:
eInflated
)
=
=
aTextRun
?
TEXT_IN_TEXTRUN_USER_DATA
:
TEXT_IN_UNINFLATED_TEXTRUN_USER_DATA
;
DebugOnly
<
bool
>
found
=
ClearAllTextRunReferences
(
userDataFrame
aTextRun
aStartContinuation
whichTextRunState
)
;
NS_ASSERTION
(
!
aStartContinuation
|
|
found
"
aStartContinuation
wasn
'
t
found
in
simple
flow
text
run
"
)
;
if
(
!
(
userDataFrame
-
>
GetStateBits
(
)
&
whichTextRunState
)
)
{
DestroyTextRunUserData
(
aTextRun
)
;
}
}
else
{
auto
userData
=
static_cast
<
TextRunUserData
*
>
(
aTextRun
-
>
GetUserData
(
)
)
;
TextRunMappedFlow
*
userMappedFlows
=
GetMappedFlows
(
aTextRun
)
;
int32_t
destroyFromIndex
=
aStartContinuation
?
-
1
:
0
;
for
(
uint32_t
i
=
0
;
i
<
userData
-
>
mMappedFlowCount
;
+
+
i
)
{
nsTextFrame
*
userDataFrame
=
userMappedFlows
[
i
]
.
mStartFrame
;
nsFrameState
whichTextRunState
=
userDataFrame
-
>
GetTextRun
(
nsTextFrame
:
:
eInflated
)
=
=
aTextRun
?
TEXT_IN_TEXTRUN_USER_DATA
:
TEXT_IN_UNINFLATED_TEXTRUN_USER_DATA
;
bool
found
=
ClearAllTextRunReferences
(
userDataFrame
aTextRun
aStartContinuation
whichTextRunState
)
;
if
(
found
)
{
if
(
userDataFrame
-
>
GetStateBits
(
)
&
whichTextRunState
)
{
destroyFromIndex
=
i
+
1
;
}
else
{
destroyFromIndex
=
i
;
}
aStartContinuation
=
nullptr
;
}
}
NS_ASSERTION
(
destroyFromIndex
>
=
0
"
aStartContinuation
wasn
'
t
found
in
multi
flow
text
run
"
)
;
if
(
destroyFromIndex
=
=
0
)
{
DestroyTextRunUserData
(
aTextRun
)
;
}
else
{
userData
-
>
mMappedFlowCount
=
uint32_t
(
destroyFromIndex
)
;
if
(
userData
-
>
mLastFlowIndex
>
=
uint32_t
(
destroyFromIndex
)
)
{
userData
-
>
mLastFlowIndex
=
uint32_t
(
destroyFromIndex
)
-
1
;
}
}
}
}
static
void
InvalidateFrameDueToGlyphsChanged
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
)
;
nsIPresShell
*
shell
=
aFrame
-
>
PresShell
(
)
;
for
(
nsIFrame
*
f
=
aFrame
;
f
;
f
=
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
f
)
)
{
f
-
>
InvalidateFrame
(
)
;
if
(
nsSVGUtils
:
:
IsInSVGTextSubtree
(
f
)
&
&
f
-
>
GetStateBits
(
)
&
NS_FRAME_IS_NONDISPLAY
)
{
auto
svgTextFrame
=
static_cast
<
SVGTextFrame
*
>
(
nsLayoutUtils
:
:
GetClosestFrameOfType
(
f
LayoutFrameType
:
:
SVGText
)
)
;
svgTextFrame
-
>
ScheduleReflowSVGNonDisplayText
(
nsIPresShell
:
:
eResize
)
;
}
else
{
shell
-
>
FrameNeedsReflow
(
f
nsIPresShell
:
:
eResize
NS_FRAME_IS_DIRTY
)
;
}
}
}
void
GlyphObserver
:
:
NotifyGlyphsChanged
(
)
{
if
(
mTextRun
-
>
GetFlags2
(
)
&
nsTextFrameUtils
:
:
Flags
:
:
TEXT_IS_SIMPLE_FLOW
)
{
InvalidateFrameDueToGlyphsChanged
(
GetFrameForSimpleFlow
(
mTextRun
)
)
;
return
;
}
auto
data
=
static_cast
<
TextRunUserData
*
>
(
mTextRun
-
>
GetUserData
(
)
)
;
TextRunMappedFlow
*
userMappedFlows
=
GetMappedFlows
(
mTextRun
)
;
for
(
uint32_t
i
=
0
;
i
<
data
-
>
mMappedFlowCount
;
+
+
i
)
{
InvalidateFrameDueToGlyphsChanged
(
userMappedFlows
[
i
]
.
mStartFrame
)
;
}
}
int32_t
nsTextFrame
:
:
GetContentEnd
(
)
const
{
nsTextFrame
*
next
=
GetNextContinuation
(
)
;
return
next
?
next
-
>
GetContentOffset
(
)
:
mContent
-
>
GetText
(
)
-
>
GetLength
(
)
;
}
struct
FlowLengthProperty
{
int32_t
mStartOffset
;
int32_t
mEndFlowOffset
;
}
;
int32_t
nsTextFrame
:
:
GetInFlowContentLength
(
)
{
if
(
!
(
mState
&
NS_FRAME_IS_BIDI
)
)
{
return
mContent
-
>
TextLength
(
)
-
mContentOffset
;
}
FlowLengthProperty
*
flowLength
=
mContent
-
>
HasFlag
(
NS_HAS_FLOWLENGTH_PROPERTY
)
?
static_cast
<
FlowLengthProperty
*
>
(
mContent
-
>
GetProperty
(
nsGkAtoms
:
:
flowlength
)
)
:
nullptr
;
if
(
flowLength
&
&
(
flowLength
-
>
mStartOffset
<
mContentOffset
|
|
(
flowLength
-
>
mStartOffset
=
=
mContentOffset
&
&
GetContentEnd
(
)
>
mContentOffset
)
)
&
&
flowLength
-
>
mEndFlowOffset
>
mContentOffset
)
{
#
ifdef
DEBUG
NS_ASSERTION
(
flowLength
-
>
mEndFlowOffset
>
=
GetContentEnd
(
)
"
frame
crosses
fixed
continuation
boundary
"
)
;
#
endif
return
flowLength
-
>
mEndFlowOffset
-
mContentOffset
;
}
nsTextFrame
*
nextBidi
=
LastInFlow
(
)
-
>
GetNextContinuation
(
)
;
int32_t
endFlow
=
nextBidi
?
nextBidi
-
>
GetContentOffset
(
)
:
mContent
-
>
TextLength
(
)
;
if
(
!
flowLength
)
{
flowLength
=
new
FlowLengthProperty
;
if
(
NS_FAILED
(
mContent
-
>
SetProperty
(
nsGkAtoms
:
:
flowlength
flowLength
nsINode
:
:
DeleteProperty
<
FlowLengthProperty
>
)
)
)
{
delete
flowLength
;
flowLength
=
nullptr
;
}
mContent
-
>
SetFlags
(
NS_HAS_FLOWLENGTH_PROPERTY
)
;
}
if
(
flowLength
)
{
flowLength
-
>
mStartOffset
=
mContentOffset
;
flowLength
-
>
mEndFlowOffset
=
endFlow
;
}
return
endFlow
-
mContentOffset
;
}
static
bool
IsSpaceCombiningSequenceTail
(
const
nsTextFragment
*
aFrag
uint32_t
aPos
)
{
NS_ASSERTION
(
aPos
<
=
aFrag
-
>
GetLength
(
)
"
Bad
offset
"
)
;
if
(
!
aFrag
-
>
Is2b
(
)
)
return
false
;
return
nsTextFrameUtils
:
:
IsSpaceCombiningSequenceTail
(
aFrag
-
>
Get2b
(
)
+
aPos
aFrag
-
>
GetLength
(
)
-
aPos
)
;
}
static
bool
IsCSSWordSpacingSpace
(
const
nsTextFragment
*
aFrag
uint32_t
aPos
const
nsTextFrame
*
aFrame
const
nsStyleText
*
aStyleText
)
{
NS_ASSERTION
(
aPos
<
aFrag
-
>
GetLength
(
)
"
No
text
for
IsSpace
!
"
)
;
char16_t
ch
=
aFrag
-
>
CharAt
(
aPos
)
;
switch
(
ch
)
{
case
'
'
:
case
CH_NBSP
:
return
!
IsSpaceCombiningSequenceTail
(
aFrag
aPos
+
1
)
;
case
'
\
r
'
:
case
'
\
t
'
:
return
!
aStyleText
-
>
WhiteSpaceIsSignificant
(
)
;
case
'
\
n
'
:
return
!
aStyleText
-
>
NewlineIsSignificant
(
aFrame
)
;
default
:
return
false
;
}
}
static
bool
IsTrimmableSpace
(
const
char16_t
*
aChars
uint32_t
aLength
)
{
NS_ASSERTION
(
aLength
>
0
"
No
text
for
IsSpace
!
"
)
;
char16_t
ch
=
*
aChars
;
if
(
ch
=
=
'
'
)
return
!
nsTextFrameUtils
:
:
IsSpaceCombiningSequenceTail
(
aChars
+
1
aLength
-
1
)
;
return
ch
=
=
'
\
t
'
|
|
ch
=
=
'
\
f
'
|
|
ch
=
=
'
\
n
'
|
|
ch
=
=
'
\
r
'
;
}
static
bool
IsTrimmableSpace
(
char
aCh
)
{
return
aCh
=
=
'
'
|
|
aCh
=
=
'
\
t
'
|
|
aCh
=
=
'
\
f
'
|
|
aCh
=
=
'
\
n
'
|
|
aCh
=
=
'
\
r
'
;
}
static
bool
IsTrimmableSpace
(
const
nsTextFragment
*
aFrag
uint32_t
aPos
const
nsStyleText
*
aStyleText
)
{
NS_ASSERTION
(
aPos
<
aFrag
-
>
GetLength
(
)
"
No
text
for
IsSpace
!
"
)
;
switch
(
aFrag
-
>
CharAt
(
aPos
)
)
{
case
'
'
:
return
!
aStyleText
-
>
WhiteSpaceIsSignificant
(
)
&
&
!
IsSpaceCombiningSequenceTail
(
aFrag
aPos
+
1
)
;
case
'
\
n
'
:
return
!
aStyleText
-
>
NewlineIsSignificantStyle
(
)
&
&
aStyleText
-
>
mWhiteSpace
!
=
mozilla
:
:
StyleWhiteSpace
:
:
PreSpace
;
case
'
\
t
'
:
case
'
\
r
'
:
case
'
\
f
'
:
return
!
aStyleText
-
>
WhiteSpaceIsSignificant
(
)
;
default
:
return
false
;
}
}
static
bool
IsSelectionSpace
(
const
nsTextFragment
*
aFrag
uint32_t
aPos
)
{
NS_ASSERTION
(
aPos
<
aFrag
-
>
GetLength
(
)
"
No
text
for
IsSpace
!
"
)
;
char16_t
ch
=
aFrag
-
>
CharAt
(
aPos
)
;
if
(
ch
=
=
'
'
|
|
ch
=
=
CH_NBSP
)
return
!
IsSpaceCombiningSequenceTail
(
aFrag
aPos
+
1
)
;
return
ch
=
=
'
\
t
'
|
|
ch
=
=
'
\
n
'
|
|
ch
=
=
'
\
f
'
|
|
ch
=
=
'
\
r
'
;
}
static
uint32_t
GetTrimmableWhitespaceCount
(
const
nsTextFragment
*
aFrag
int32_t
aStartOffset
int32_t
aLength
int32_t
aDirection
)
{
int32_t
count
=
0
;
if
(
aFrag
-
>
Is2b
(
)
)
{
const
char16_t
*
str
=
aFrag
-
>
Get2b
(
)
+
aStartOffset
;
int32_t
fragLen
=
aFrag
-
>
GetLength
(
)
-
aStartOffset
;
for
(
;
count
<
aLength
;
+
+
count
)
{
if
(
!
IsTrimmableSpace
(
str
fragLen
)
)
break
;
str
+
=
aDirection
;
fragLen
-
=
aDirection
;
}
}
else
{
const
char
*
str
=
aFrag
-
>
Get1b
(
)
+
aStartOffset
;
for
(
;
count
<
aLength
;
+
+
count
)
{
if
(
!
IsTrimmableSpace
(
*
str
)
)
break
;
str
+
=
aDirection
;
}
}
return
count
;
}
static
bool
IsAllWhitespace
(
const
nsTextFragment
*
aFrag
bool
aAllowNewline
)
{
if
(
aFrag
-
>
Is2b
(
)
)
return
false
;
int32_t
len
=
aFrag
-
>
GetLength
(
)
;
const
char
*
str
=
aFrag
-
>
Get1b
(
)
;
for
(
int32_t
i
=
0
;
i
<
len
;
+
+
i
)
{
char
ch
=
str
[
i
]
;
if
(
ch
=
=
'
'
|
|
ch
=
=
'
\
t
'
|
|
ch
=
=
'
\
r
'
|
|
(
ch
=
=
'
\
n
'
&
&
aAllowNewline
)
)
continue
;
return
false
;
}
return
true
;
}
static
void
ClearObserversFromTextRun
(
gfxTextRun
*
aTextRun
)
{
if
(
!
(
aTextRun
-
>
GetFlags2
(
)
&
nsTextFrameUtils
:
:
Flags
:
:
TEXT_MIGHT_HAVE_GLYPH_CHANGES
)
)
{
return
;
}
if
(
aTextRun
-
>
GetFlags2
(
)
&
nsTextFrameUtils
:
:
Flags
:
:
TEXT_IS_SIMPLE_FLOW
)
{
static_cast
<
SimpleTextRunUserData
*
>
(
aTextRun
-
>
GetUserData
(
)
)
-
>
mGlyphObservers
.
Clear
(
)
;
}
else
{
static_cast
<
ComplexTextRunUserData
*
>
(
aTextRun
-
>
GetUserData
(
)
)
-
>
mGlyphObservers
.
Clear
(
)
;
}
}
static
void
CreateObserversForAnimatedGlyphs
(
gfxTextRun
*
aTextRun
)
{
if
(
!
aTextRun
-
>
GetUserData
(
)
)
{
return
;
}
ClearObserversFromTextRun
(
aTextRun
)
;
nsTArray
<
gfxFont
*
>
fontsWithAnimatedGlyphs
;
uint32_t
numGlyphRuns
;
const
gfxTextRun
:
:
GlyphRun
*
glyphRuns
=
aTextRun
-
>
GetGlyphRuns
(
&
numGlyphRuns
)
;
for
(
uint32_t
i
=
0
;
i
<
numGlyphRuns
;
+
+
i
)
{
gfxFont
*
font
=
glyphRuns
[
i
]
.
mFont
;
if
(
font
-
>
GlyphsMayChange
(
)
&
&
!
fontsWithAnimatedGlyphs
.
Contains
(
font
)
)
{
fontsWithAnimatedGlyphs
.
AppendElement
(
font
)
;
}
}
if
(
fontsWithAnimatedGlyphs
.
IsEmpty
(
)
)
{
return
;
}
nsTArray
<
UniquePtr
<
GlyphObserver
>
>
*
observers
;
if
(
aTextRun
-
>
GetFlags2
(
)
&
nsTextFrameUtils
:
:
Flags
:
:
TEXT_IS_SIMPLE_FLOW
)
{
if
(
!
(
aTextRun
-
>
GetFlags2
(
)
&
nsTextFrameUtils
:
:
Flags
:
:
TEXT_MIGHT_HAVE_GLYPH_CHANGES
)
)
{
auto
frame
=
static_cast
<
nsTextFrame
*
>
(
aTextRun
-
>
GetUserData
(
)
)
;
aTextRun
-
>
SetUserData
(
new
SimpleTextRunUserData
(
frame
)
)
;
}
auto
data
=
static_cast
<
SimpleTextRunUserData
*
>
(
aTextRun
-
>
GetUserData
(
)
)
;
observers
=
&
data
-
>
mGlyphObservers
;
}
else
{
if
(
!
(
aTextRun
-
>
GetFlags2
(
)
&
nsTextFrameUtils
:
:
Flags
:
:
TEXT_MIGHT_HAVE_GLYPH_CHANGES
)
)
{
auto
oldData
=
static_cast
<
TextRunUserData
*
>
(
aTextRun
-
>
GetUserData
(
)
)
;
TextRunMappedFlow
*
oldMappedFlows
=
GetMappedFlows
(
aTextRun
)
;
ComplexTextRunUserData
*
data
=
CreateComplexUserData
(
oldData
-
>
mMappedFlowCount
)
;
TextRunMappedFlow
*
dataMappedFlows
=
reinterpret_cast
<
TextRunMappedFlow
*
>
(
data
+
1
)
;
data
-
>
mLastFlowIndex
=
oldData
-
>
mLastFlowIndex
;
for
(
uint32_t
i
=
0
;
i
<
oldData
-
>
mMappedFlowCount
;
+
+
i
)
{
dataMappedFlows
[
i
]
=
oldMappedFlows
[
i
]
;
}
DestroyUserData
(
oldData
)
;
aTextRun
-
>
SetUserData
(
data
)
;
}
auto
data
=
static_cast
<
ComplexTextRunUserData
*
>
(
aTextRun
-
>
GetUserData
(
)
)
;
observers
=
&
data
-
>
mGlyphObservers
;
}
aTextRun
-
>
SetFlagBits
(
nsTextFrameUtils
:
:
Flags
:
:
TEXT_MIGHT_HAVE_GLYPH_CHANGES
)
;
for
(
auto
font
:
fontsWithAnimatedGlyphs
)
{
observers
-
>
AppendElement
(
new
GlyphObserver
(
font
aTextRun
)
)
;
}
}
class
BuildTextRunsScanner
{
public
:
BuildTextRunsScanner
(
nsPresContext
*
aPresContext
DrawTarget
*
aDrawTarget
nsIFrame
*
aLineContainer
nsTextFrame
:
:
TextRunType
aWhichTextRun
)
:
mDrawTarget
(
aDrawTarget
)
mLineContainer
(
aLineContainer
)
mCommonAncestorWithLastFrame
(
nullptr
)
mMissingFonts
(
aPresContext
-
>
MissingFontRecorder
(
)
)
mBidiEnabled
(
aPresContext
-
>
BidiEnabled
(
)
)
mStartOfLine
(
true
)
mSkipIncompleteTextRuns
(
false
)
mCanStopOnThisLine
(
false
)
mWhichTextRun
(
aWhichTextRun
)
mNextRunContextInfo
(
nsTextFrameUtils
:
:
INCOMING_NONE
)
mCurrentRunContextInfo
(
nsTextFrameUtils
:
:
INCOMING_NONE
)
{
ResetRunInfo
(
)
;
}
~
BuildTextRunsScanner
(
)
{
NS_ASSERTION
(
mBreakSinks
.
IsEmpty
(
)
"
Should
have
been
cleared
"
)
;
NS_ASSERTION
(
mLineBreakBeforeFrames
.
IsEmpty
(
)
"
Should
have
been
cleared
"
)
;
NS_ASSERTION
(
mMappedFlows
.
IsEmpty
(
)
"
Should
have
been
cleared
"
)
;
}
void
SetAtStartOfLine
(
)
{
mStartOfLine
=
true
;
mCanStopOnThisLine
=
false
;
}
void
SetSkipIncompleteTextRuns
(
bool
aSkip
)
{
mSkipIncompleteTextRuns
=
aSkip
;
}
void
SetCommonAncestorWithLastFrame
(
nsIFrame
*
aFrame
)
{
mCommonAncestorWithLastFrame
=
aFrame
;
}
bool
CanStopOnThisLine
(
)
{
return
mCanStopOnThisLine
;
}
nsIFrame
*
GetCommonAncestorWithLastFrame
(
)
{
return
mCommonAncestorWithLastFrame
;
}
void
LiftCommonAncestorWithLastFrameToParent
(
nsIFrame
*
aFrame
)
{
if
(
mCommonAncestorWithLastFrame
&
&
mCommonAncestorWithLastFrame
-
>
GetParent
(
)
=
=
aFrame
)
{
mCommonAncestorWithLastFrame
=
aFrame
;
}
}
void
ScanFrame
(
nsIFrame
*
aFrame
)
;
bool
IsTextRunValidForMappedFlows
(
const
gfxTextRun
*
aTextRun
)
;
void
FlushFrames
(
bool
aFlushLineBreaks
bool
aSuppressTrailingBreak
)
;
void
FlushLineBreaks
(
gfxTextRun
*
aTrailingTextRun
)
;
void
ResetRunInfo
(
)
{
mLastFrame
=
nullptr
;
mMappedFlows
.
Clear
(
)
;
mLineBreakBeforeFrames
.
Clear
(
)
;
mMaxTextLength
=
0
;
mDoubleByteText
=
false
;
}
void
AccumulateRunInfo
(
nsTextFrame
*
aFrame
)
;
already_AddRefed
<
gfxTextRun
>
BuildTextRunForFrames
(
void
*
aTextBuffer
)
;
bool
SetupLineBreakerContext
(
gfxTextRun
*
aTextRun
)
;
void
AssignTextRun
(
gfxTextRun
*
aTextRun
float
aInflation
)
;
nsTextFrame
*
GetNextBreakBeforeFrame
(
uint32_t
*
aIndex
)
;
void
SetupBreakSinksForTextRun
(
gfxTextRun
*
aTextRun
const
void
*
aTextPtr
)
;
void
SetupTextEmphasisForTextRun
(
gfxTextRun
*
aTextRun
const
void
*
aTextPtr
)
;
struct
FindBoundaryState
{
nsIFrame
*
mStopAtFrame
;
nsTextFrame
*
mFirstTextFrame
;
nsTextFrame
*
mLastTextFrame
;
bool
mSeenTextRunBoundaryOnLaterLine
;
bool
mSeenTextRunBoundaryOnThisLine
;
bool
mSeenSpaceForLineBreakingOnThisLine
;
nsTArray
<
char16_t
>
&
mBuffer
;
}
;
enum
FindBoundaryResult
{
FB_CONTINUE
FB_STOPPED_AT_STOP_FRAME
FB_FOUND_VALID_TEXTRUN_BOUNDARY
}
;
FindBoundaryResult
FindBoundaries
(
nsIFrame
*
aFrame
FindBoundaryState
*
aState
)
;
bool
ContinueTextRunAcrossFrames
(
nsTextFrame
*
aFrame1
nsTextFrame
*
aFrame2
)
;
struct
MappedFlow
{
nsTextFrame
*
mStartFrame
;
nsTextFrame
*
mEndFrame
;
nsIFrame
*
mAncestorControllingInitialBreak
;
int32_t
GetContentEnd
(
)
{
return
mEndFrame
?
mEndFrame
-
>
GetContentOffset
(
)
:
mStartFrame
-
>
GetContent
(
)
-
>
GetText
(
)
-
>
GetLength
(
)
;
}
}
;
class
BreakSink
final
:
public
nsILineBreakSink
{
public
:
BreakSink
(
gfxTextRun
*
aTextRun
DrawTarget
*
aDrawTarget
uint32_t
aOffsetIntoTextRun
)
:
mTextRun
(
aTextRun
)
mDrawTarget
(
aDrawTarget
)
mOffsetIntoTextRun
(
aOffsetIntoTextRun
)
{
}
virtual
void
SetBreaks
(
uint32_t
aOffset
uint32_t
aLength
uint8_t
*
aBreakBefore
)
override
{
gfxTextRun
:
:
Range
range
(
aOffset
+
mOffsetIntoTextRun
aOffset
+
mOffsetIntoTextRun
+
aLength
)
;
if
(
mTextRun
-
>
SetPotentialLineBreaks
(
range
aBreakBefore
)
)
{
mTextRun
-
>
ClearFlagBits
(
nsTextFrameUtils
:
:
Flags
:
:
TEXT_NO_BREAKS
)
;
}
}
virtual
void
SetCapitalization
(
uint32_t
aOffset
uint32_t
aLength
bool
*
aCapitalize
)
override
{
MOZ_ASSERT
(
mTextRun
-
>
GetFlags2
(
)
&
nsTextFrameUtils
:
:
Flags
:
:
TEXT_IS_TRANSFORMED
"
Text
run
should
be
transformed
!
"
)
;
if
(
mTextRun
-
>
GetFlags2
(
)
&
nsTextFrameUtils
:
:
Flags
:
:
TEXT_IS_TRANSFORMED
)
{
nsTransformedTextRun
*
transformedTextRun
=
static_cast
<
nsTransformedTextRun
*
>
(
mTextRun
.
get
(
)
)
;
transformedTextRun
-
>
SetCapitalization
(
aOffset
+
mOffsetIntoTextRun
aLength
aCapitalize
)
;
}
}
void
Finish
(
gfxMissingFontRecorder
*
aMFR
)
{
MOZ_ASSERT
(
!
(
mTextRun
-
>
GetFlags2
(
)
&
nsTextFrameUtils
:
:
Flags
:
:
TEXT_UNUSED_FLAGS
)
"
Flag
set
that
should
never
be
set
!
(
memory
safety
error
?
)
"
)
;
if
(
mTextRun
-
>
GetFlags2
(
)
&
nsTextFrameUtils
:
:
Flags
:
:
TEXT_IS_TRANSFORMED
)
{
nsTransformedTextRun
*
transformedTextRun
=
static_cast
<
nsTransformedTextRun
*
>
(
mTextRun
.
get
(
)
)
;
transformedTextRun
-
>
FinishSettingProperties
(
mDrawTarget
aMFR
)
;
}
CreateObserversForAnimatedGlyphs
(
mTextRun
)
;
}
RefPtr
<
gfxTextRun
>
mTextRun
;
DrawTarget
*
mDrawTarget
;
uint32_t
mOffsetIntoTextRun
;
}
;
private
:
AutoTArray
<
MappedFlow
10
>
mMappedFlows
;
AutoTArray
<
nsTextFrame
*
50
>
mLineBreakBeforeFrames
;
AutoTArray
<
UniquePtr
<
BreakSink
>
10
>
mBreakSinks
;
nsLineBreaker
mLineBreaker
;
RefPtr
<
gfxTextRun
>
mCurrentFramesAllSameTextRun
;
DrawTarget
*
mDrawTarget
;
nsIFrame
*
mLineContainer
;
nsTextFrame
*
mLastFrame
;
nsIFrame
*
mCommonAncestorWithLastFrame
;
gfxMissingFontRecorder
*
mMissingFonts
;
uint32_t
mMaxTextLength
;
bool
mDoubleByteText
;
bool
mBidiEnabled
;
bool
mStartOfLine
;
bool
mSkipIncompleteTextRuns
;
bool
mCanStopOnThisLine
;
nsTextFrame
:
:
TextRunType
mWhichTextRun
;
uint8_t
mNextRunContextInfo
;
uint8_t
mCurrentRunContextInfo
;
}
;
static
nsIFrame
*
FindLineContainer
(
nsIFrame
*
aFrame
)
{
while
(
aFrame
&
&
(
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eLineParticipant
)
|
|
aFrame
-
>
CanContinueTextRun
(
)
)
)
{
aFrame
=
aFrame
-
>
GetParent
(
)
;
}
return
aFrame
;
}
static
bool
IsLineBreakingWhiteSpace
(
char16_t
aChar
)
{
return
nsLineBreaker
:
:
IsSpace
(
aChar
)
|
|
aChar
=
=
0x0A
;
}
static
bool
TextContainsLineBreakerWhiteSpace
(
const
void
*
aText
uint32_t
aLength
bool
aIsDoubleByte
)
{
if
(
aIsDoubleByte
)
{
const
char16_t
*
chars
=
static_cast
<
const
char16_t
*
>
(
aText
)
;
for
(
uint32_t
i
=
0
;
i
<
aLength
;
+
+
i
)
{
if
(
IsLineBreakingWhiteSpace
(
chars
[
i
]
)
)
return
true
;
}
return
false
;
}
else
{
const
uint8_t
*
chars
=
static_cast
<
const
uint8_t
*
>
(
aText
)
;
for
(
uint32_t
i
=
0
;
i
<
aLength
;
+
+
i
)
{
if
(
IsLineBreakingWhiteSpace
(
chars
[
i
]
)
)
return
true
;
}
return
false
;
}
}
static_assert
(
uint8_t
(
mozilla
:
:
StyleWhiteSpace
:
:
Normal
)
=
=
0
"
Convention
:
StyleWhiteSpace
:
:
Normal
should
be
0
"
)
;
static_assert
(
uint8_t
(
mozilla
:
:
StyleWhiteSpace
:
:
Pre
)
=
=
1
"
Convention
:
StyleWhiteSpace
:
:
Pre
should
be
1
"
)
;
static_assert
(
uint8_t
(
mozilla
:
:
StyleWhiteSpace
:
:
Nowrap
)
=
=
2
"
Convention
:
StyleWhiteSpace
:
:
NoWrap
should
be
2
"
)
;
static_assert
(
uint8_t
(
mozilla
:
:
StyleWhiteSpace
:
:
PreWrap
)
=
=
3
"
Convention
:
StyleWhiteSpace
:
:
PreWrap
should
be
3
"
)
;
static_assert
(
uint8_t
(
mozilla
:
:
StyleWhiteSpace
:
:
PreLine
)
=
=
4
"
Convention
:
StyleWhiteSpace
:
:
PreLine
should
be
4
"
)
;
static_assert
(
uint8_t
(
mozilla
:
:
StyleWhiteSpace
:
:
PreSpace
)
=
=
5
"
Convention
:
StyleWhiteSpace
:
:
PreSpace
should
be
5
"
)
;
static
nsTextFrameUtils
:
:
CompressionMode
GetCSSWhitespaceToCompressionMode
(
nsTextFrame
*
aFrame
const
nsStyleText
*
aStyleText
)
{
static
const
nsTextFrameUtils
:
:
CompressionMode
sModes
[
]
=
{
nsTextFrameUtils
:
:
COMPRESS_WHITESPACE_NEWLINE
nsTextFrameUtils
:
:
COMPRESS_NONE
nsTextFrameUtils
:
:
COMPRESS_WHITESPACE_NEWLINE
nsTextFrameUtils
:
:
COMPRESS_NONE
nsTextFrameUtils
:
:
COMPRESS_WHITESPACE
nsTextFrameUtils
:
:
COMPRESS_NONE_TRANSFORM_TO_SPACE
}
;
auto
compression
=
sModes
[
uint8_t
(
aStyleText
-
>
mWhiteSpace
)
]
;
if
(
compression
=
=
nsTextFrameUtils
:
:
COMPRESS_NONE
&
&
!
aStyleText
-
>
NewlineIsSignificant
(
aFrame
)
)
{
compression
=
nsTextFrameUtils
:
:
COMPRESS_NONE_TRANSFORM_TO_SPACE
;
}
return
compression
;
}
struct
FrameTextTraversal
{
FrameTextTraversal
(
)
:
mFrameToScan
(
nullptr
)
mOverflowFrameToScan
(
nullptr
)
mScanSiblings
(
false
)
mLineBreakerCanCrossFrameBoundary
(
false
)
mTextRunCanCrossFrameBoundary
(
false
)
{
}
nsIFrame
*
mFrameToScan
;
nsIFrame
*
mOverflowFrameToScan
;
bool
mScanSiblings
;
bool
mLineBreakerCanCrossFrameBoundary
;
bool
mTextRunCanCrossFrameBoundary
;
nsIFrame
*
NextFrameToScan
(
)
{
nsIFrame
*
f
;
if
(
mFrameToScan
)
{
f
=
mFrameToScan
;
mFrameToScan
=
mScanSiblings
?
f
-
>
GetNextSibling
(
)
:
nullptr
;
}
else
if
(
mOverflowFrameToScan
)
{
f
=
mOverflowFrameToScan
;
mOverflowFrameToScan
=
mScanSiblings
?
f
-
>
GetNextSibling
(
)
:
nullptr
;
}
else
{
f
=
nullptr
;
}
return
f
;
}
}
;
static
FrameTextTraversal
CanTextCrossFrameBoundary
(
nsIFrame
*
aFrame
)
{
FrameTextTraversal
result
;
bool
continuesTextRun
=
aFrame
-
>
CanContinueTextRun
(
)
;
if
(
aFrame
-
>
IsPlaceholderFrame
(
)
)
{
result
.
mLineBreakerCanCrossFrameBoundary
=
true
;
if
(
continuesTextRun
)
{
result
.
mFrameToScan
=
(
static_cast
<
nsPlaceholderFrame
*
>
(
aFrame
)
)
-
>
GetOutOfFlowFrame
(
)
;
}
else
{
result
.
mTextRunCanCrossFrameBoundary
=
true
;
}
}
else
{
if
(
continuesTextRun
)
{
result
.
mFrameToScan
=
aFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
result
.
mOverflowFrameToScan
=
aFrame
-
>
GetChildList
(
nsIFrame
:
:
kOverflowList
)
.
FirstChild
(
)
;
NS_WARNING_ASSERTION
(
!
result
.
mOverflowFrameToScan
"
Scanning
overflow
inline
frames
is
something
we
should
avoid
"
)
;
result
.
mScanSiblings
=
true
;
result
.
mTextRunCanCrossFrameBoundary
=
true
;
result
.
mLineBreakerCanCrossFrameBoundary
=
true
;
}
else
{
MOZ_ASSERT
(
!
aFrame
-
>
IsRubyTextContainerFrame
(
)
"
Shouldn
'
t
call
this
method
for
ruby
text
container
"
)
;
}
}
return
result
;
}
BuildTextRunsScanner
:
:
FindBoundaryResult
BuildTextRunsScanner
:
:
FindBoundaries
(
nsIFrame
*
aFrame
FindBoundaryState
*
aState
)
{
LayoutFrameType
frameType
=
aFrame
-
>
Type
(
)
;
if
(
frameType
=
=
LayoutFrameType
:
:
RubyTextContainer
)
{
return
FB_CONTINUE
;
}
nsTextFrame
*
textFrame
=
frameType
=
=
LayoutFrameType
:
:
Text
?
static_cast
<
nsTextFrame
*
>
(
aFrame
)
:
nullptr
;
if
(
textFrame
)
{
if
(
aState
-
>
mLastTextFrame
&
&
textFrame
!
=
aState
-
>
mLastTextFrame
-
>
GetNextInFlow
(
)
&
&
!
ContinueTextRunAcrossFrames
(
aState
-
>
mLastTextFrame
textFrame
)
)
{
aState
-
>
mSeenTextRunBoundaryOnThisLine
=
true
;
if
(
aState
-
>
mSeenSpaceForLineBreakingOnThisLine
)
return
FB_FOUND_VALID_TEXTRUN_BOUNDARY
;
}
if
(
!
aState
-
>
mFirstTextFrame
)
{
aState
-
>
mFirstTextFrame
=
textFrame
;
}
aState
-
>
mLastTextFrame
=
textFrame
;
}
if
(
aFrame
=
=
aState
-
>
mStopAtFrame
)
return
FB_STOPPED_AT_STOP_FRAME
;
if
(
textFrame
)
{
if
(
aState
-
>
mSeenSpaceForLineBreakingOnThisLine
)
{
return
FB_CONTINUE
;
}
const
nsTextFragment
*
frag
=
textFrame
-
>
GetContent
(
)
-
>
GetText
(
)
;
uint32_t
start
=
textFrame
-
>
GetContentOffset
(
)
;
uint32_t
length
=
textFrame
-
>
GetContentLength
(
)
;
const
void
*
text
;
if
(
frag
-
>
Is2b
(
)
)
{
aState
-
>
mBuffer
.
EnsureLengthAtLeast
(
length
)
;
nsTextFrameUtils
:
:
CompressionMode
compression
=
GetCSSWhitespaceToCompressionMode
(
textFrame
textFrame
-
>
StyleText
(
)
)
;
uint8_t
incomingFlags
=
0
;
gfxSkipChars
skipChars
;
nsTextFrameUtils
:
:
Flags
analysisFlags
;
char16_t
*
bufStart
=
aState
-
>
mBuffer
.
Elements
(
)
;
char16_t
*
bufEnd
=
nsTextFrameUtils
:
:
TransformText
(
frag
-
>
Get2b
(
)
+
start
length
bufStart
compression
&
incomingFlags
&
skipChars
&
analysisFlags
)
;
text
=
bufStart
;
length
=
bufEnd
-
bufStart
;
}
else
{
text
=
static_cast
<
const
void
*
>
(
frag
-
>
Get1b
(
)
+
start
)
;
}
if
(
TextContainsLineBreakerWhiteSpace
(
text
length
frag
-
>
Is2b
(
)
)
)
{
aState
-
>
mSeenSpaceForLineBreakingOnThisLine
=
true
;
if
(
aState
-
>
mSeenTextRunBoundaryOnLaterLine
)
{
return
FB_FOUND_VALID_TEXTRUN_BOUNDARY
;
}
}
return
FB_CONTINUE
;
}
FrameTextTraversal
traversal
=
CanTextCrossFrameBoundary
(
aFrame
)
;
if
(
!
traversal
.
mTextRunCanCrossFrameBoundary
)
{
aState
-
>
mSeenTextRunBoundaryOnThisLine
=
true
;
if
(
aState
-
>
mSeenSpaceForLineBreakingOnThisLine
)
return
FB_FOUND_VALID_TEXTRUN_BOUNDARY
;
}
for
(
nsIFrame
*
f
=
traversal
.
NextFrameToScan
(
)
;
f
;
f
=
traversal
.
NextFrameToScan
(
)
)
{
FindBoundaryResult
result
=
FindBoundaries
(
f
aState
)
;
if
(
result
!
=
FB_CONTINUE
)
return
result
;
}
if
(
!
traversal
.
mTextRunCanCrossFrameBoundary
)
{
aState
-
>
mSeenTextRunBoundaryOnThisLine
=
true
;
if
(
aState
-
>
mSeenSpaceForLineBreakingOnThisLine
)
return
FB_FOUND_VALID_TEXTRUN_BOUNDARY
;
}
return
FB_CONTINUE
;
}
#
define
NUM_LINES_TO_BUILD_TEXT_RUNS
200
static
void
BuildTextRuns
(
DrawTarget
*
aDrawTarget
nsTextFrame
*
aForFrame
nsIFrame
*
aLineContainer
const
nsLineList
:
:
iterator
*
aForFrameLine
nsTextFrame
:
:
TextRunType
aWhichTextRun
)
{
MOZ_ASSERT
(
aForFrame
"
for
no
frame
?
"
)
;
NS_ASSERTION
(
!
aForFrameLine
|
|
aLineContainer
"
line
but
no
line
container
"
)
;
nsIFrame
*
lineContainerChild
=
aForFrame
;
if
(
!
aLineContainer
)
{
if
(
aForFrame
-
>
IsFloatingFirstLetterChild
(
)
)
{
lineContainerChild
=
aForFrame
-
>
GetParent
(
)
-
>
GetPlaceholderFrame
(
)
;
}
aLineContainer
=
FindLineContainer
(
lineContainerChild
)
;
}
else
{
NS_ASSERTION
(
(
aLineContainer
=
=
FindLineContainer
(
aForFrame
)
|
|
(
aLineContainer
-
>
IsLetterFrame
(
)
&
&
aLineContainer
-
>
IsFloating
(
)
)
)
"
Wrong
line
container
hint
"
)
;
}
if
(
aForFrame
-
>
HasAnyStateBits
(
TEXT_IS_IN_TOKEN_MATHML
)
)
{
aLineContainer
-
>
AddStateBits
(
TEXT_IS_IN_TOKEN_MATHML
)
;
if
(
aForFrame
-
>
HasAnyStateBits
(
NS_FRAME_IS_IN_SINGLE_CHAR_MI
)
)
{
aLineContainer
-
>
AddStateBits
(
NS_FRAME_IS_IN_SINGLE_CHAR_MI
)
;
}
}
if
(
aForFrame
-
>
HasAnyStateBits
(
NS_FRAME_MATHML_SCRIPT_DESCENDANT
)
)
{
aLineContainer
-
>
AddStateBits
(
NS_FRAME_MATHML_SCRIPT_DESCENDANT
)
;
}
nsPresContext
*
presContext
=
aLineContainer
-
>
PresContext
(
)
;
BuildTextRunsScanner
scanner
(
presContext
aDrawTarget
aLineContainer
aWhichTextRun
)
;
nsBlockFrame
*
block
=
nsLayoutUtils
:
:
GetAsBlock
(
aLineContainer
)
;
if
(
!
block
)
{
nsIFrame
*
textRunContainer
=
aLineContainer
;
if
(
aLineContainer
-
>
IsRubyTextContainerFrame
(
)
)
{
textRunContainer
=
aForFrame
;
while
(
textRunContainer
&
&
!
textRunContainer
-
>
IsRubyTextFrame
(
)
)
{
textRunContainer
=
textRunContainer
-
>
GetParent
(
)
;
}
MOZ_ASSERT
(
textRunContainer
&
&
textRunContainer
-
>
GetParent
(
)
=
=
aLineContainer
)
;
}
else
{
NS_ASSERTION
(
!
aLineContainer
-
>
GetPrevInFlow
(
)
&
&
!
aLineContainer
-
>
GetNextInFlow
(
)
"
Breakable
non
-
block
line
containers
other
than
"
"
ruby
text
container
is
not
supported
"
)
;
}
scanner
.
SetAtStartOfLine
(
)
;
scanner
.
SetCommonAncestorWithLastFrame
(
nullptr
)
;
for
(
nsIFrame
*
child
:
textRunContainer
-
>
PrincipalChildList
(
)
)
{
scanner
.
ScanFrame
(
child
)
;
}
scanner
.
SetAtStartOfLine
(
)
;
scanner
.
FlushFrames
(
true
false
)
;
return
;
}
bool
isValid
=
true
;
nsBlockInFlowLineIterator
backIterator
(
block
&
isValid
)
;
if
(
aForFrameLine
)
{
backIterator
=
nsBlockInFlowLineIterator
(
block
*
aForFrameLine
)
;
}
else
{
backIterator
=
nsBlockInFlowLineIterator
(
block
lineContainerChild
&
isValid
)
;
NS_ASSERTION
(
isValid
"
aForFrame
not
found
in
block
someone
lied
to
us
"
)
;
NS_ASSERTION
(
backIterator
.
GetContainer
(
)
=
=
block
"
Someone
lied
to
us
about
the
block
"
)
;
}
nsBlockFrame
:
:
LineIterator
startLine
=
backIterator
.
GetLine
(
)
;
nsBlockInFlowLineIterator
forwardIterator
=
backIterator
;
nsIFrame
*
stopAtFrame
=
lineContainerChild
;
nsTextFrame
*
nextLineFirstTextFrame
=
nullptr
;
AutoTArray
<
char16_t
BIG_TEXT_NODE_SIZE
>
buffer
;
bool
seenTextRunBoundaryOnLaterLine
=
false
;
bool
mayBeginInTextRun
=
true
;
while
(
true
)
{
forwardIterator
=
backIterator
;
nsBlockFrame
:
:
LineIterator
line
=
backIterator
.
GetLine
(
)
;
if
(
!
backIterator
.
Prev
(
)
|
|
backIterator
.
GetLine
(
)
-
>
IsBlock
(
)
)
{
mayBeginInTextRun
=
false
;
break
;
}
BuildTextRunsScanner
:
:
FindBoundaryState
state
=
{
stopAtFrame
nullptr
nullptr
bool
(
seenTextRunBoundaryOnLaterLine
)
false
false
buffer
}
;
nsIFrame
*
child
=
line
-
>
mFirstChild
;
bool
foundBoundary
=
false
;
for
(
int32_t
i
=
line
-
>
GetChildCount
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
BuildTextRunsScanner
:
:
FindBoundaryResult
result
=
scanner
.
FindBoundaries
(
child
&
state
)
;
if
(
result
=
=
BuildTextRunsScanner
:
:
FB_FOUND_VALID_TEXTRUN_BOUNDARY
)
{
foundBoundary
=
true
;
break
;
}
else
if
(
result
=
=
BuildTextRunsScanner
:
:
FB_STOPPED_AT_STOP_FRAME
)
{
break
;
}
child
=
child
-
>
GetNextSibling
(
)
;
}
if
(
foundBoundary
)
break
;
if
(
!
stopAtFrame
&
&
state
.
mLastTextFrame
&
&
nextLineFirstTextFrame
&
&
!
scanner
.
ContinueTextRunAcrossFrames
(
state
.
mLastTextFrame
nextLineFirstTextFrame
)
)
{
if
(
state
.
mSeenSpaceForLineBreakingOnThisLine
)
break
;
seenTextRunBoundaryOnLaterLine
=
true
;
}
else
if
(
state
.
mSeenTextRunBoundaryOnThisLine
)
{
seenTextRunBoundaryOnLaterLine
=
true
;
}
stopAtFrame
=
nullptr
;
if
(
state
.
mFirstTextFrame
)
{
nextLineFirstTextFrame
=
state
.
mFirstTextFrame
;
}
}
scanner
.
SetSkipIncompleteTextRuns
(
mayBeginInTextRun
)
;
bool
seenStartLine
=
false
;
uint32_t
linesAfterStartLine
=
0
;
do
{
nsBlockFrame
:
:
LineIterator
line
=
forwardIterator
.
GetLine
(
)
;
if
(
line
-
>
IsBlock
(
)
)
break
;
line
-
>
SetInvalidateTextRuns
(
false
)
;
scanner
.
SetAtStartOfLine
(
)
;
scanner
.
SetCommonAncestorWithLastFrame
(
nullptr
)
;
nsIFrame
*
child
=
line
-
>
mFirstChild
;
for
(
int32_t
i
=
line
-
>
GetChildCount
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
scanner
.
ScanFrame
(
child
)
;
child
=
child
-
>
GetNextSibling
(
)
;
}
if
(
line
.
get
(
)
=
=
startLine
.
get
(
)
)
{
seenStartLine
=
true
;
}
if
(
seenStartLine
)
{
+
+
linesAfterStartLine
;
if
(
linesAfterStartLine
>
=
NUM_LINES_TO_BUILD_TEXT_RUNS
&
&
scanner
.
CanStopOnThisLine
(
)
)
{
scanner
.
FlushLineBreaks
(
nullptr
)
;
scanner
.
ResetRunInfo
(
)
;
return
;
}
}
}
while
(
forwardIterator
.
Next
(
)
)
;
scanner
.
SetAtStartOfLine
(
)
;
scanner
.
FlushFrames
(
true
false
)
;
}
static
char16_t
*
ExpandBuffer
(
char16_t
*
aDest
uint8_t
*
aSrc
uint32_t
aCount
)
{
while
(
aCount
)
{
*
aDest
=
*
aSrc
;
+
+
aDest
;
+
+
aSrc
;
-
-
aCount
;
}
return
aDest
;
}
bool
BuildTextRunsScanner
:
:
IsTextRunValidForMappedFlows
(
const
gfxTextRun
*
aTextRun
)
{
if
(
aTextRun
-
>
GetFlags2
(
)
&
nsTextFrameUtils
:
:
Flags
:
:
TEXT_IS_SIMPLE_FLOW
)
{
return
mMappedFlows
.
Length
(
)
=
=
1
&
&
mMappedFlows
[
0
]
.
mStartFrame
=
=
GetFrameForSimpleFlow
(
aTextRun
)
&
&
mMappedFlows
[
0
]
.
mEndFrame
=
=
nullptr
;
}
auto
userData
=
static_cast
<
TextRunUserData
*
>
(
aTextRun
-
>
GetUserData
(
)
)
;
TextRunMappedFlow
*
userMappedFlows
=
GetMappedFlows
(
aTextRun
)
;
if
(
userData
-
>
mMappedFlowCount
!
=
mMappedFlows
.
Length
(
)
)
return
false
;
for
(
uint32_t
i
=
0
;
i
<
mMappedFlows
.
Length
(
)
;
+
+
i
)
{
if
(
userMappedFlows
[
i
]
.
mStartFrame
!
=
mMappedFlows
[
i
]
.
mStartFrame
|
|
int32_t
(
userMappedFlows
[
i
]
.
mContentLength
)
!
=
mMappedFlows
[
i
]
.
GetContentEnd
(
)
-
mMappedFlows
[
i
]
.
mStartFrame
-
>
GetContentOffset
(
)
)
return
false
;
}
return
true
;
}
void
BuildTextRunsScanner
:
:
FlushFrames
(
bool
aFlushLineBreaks
bool
aSuppressTrailingBreak
)
{
RefPtr
<
gfxTextRun
>
textRun
;
if
(
!
mMappedFlows
.
IsEmpty
(
)
)
{
if
(
!
mSkipIncompleteTextRuns
&
&
mCurrentFramesAllSameTextRun
&
&
!
!
(
mCurrentFramesAllSameTextRun
-
>
GetFlags2
(
)
&
nsTextFrameUtils
:
:
Flags
:
:
TEXT_INCOMING_WHITESPACE
)
=
=
!
!
(
mCurrentRunContextInfo
&
nsTextFrameUtils
:
:
INCOMING_WHITESPACE
)
&
&
!
!
(
mCurrentFramesAllSameTextRun
-
>
GetFlags
(
)
&
gfx
:
:
ShapedTextFlags
:
:
TEXT_INCOMING_ARABICCHAR
)
=
=
!
!
(
mCurrentRunContextInfo
&
nsTextFrameUtils
:
:
INCOMING_ARABICCHAR
)
&
&
IsTextRunValidForMappedFlows
(
mCurrentFramesAllSameTextRun
)
)
{
textRun
=
mCurrentFramesAllSameTextRun
;
if
(
!
SetupLineBreakerContext
(
textRun
)
)
{
return
;
}
mNextRunContextInfo
=
nsTextFrameUtils
:
:
INCOMING_NONE
;
if
(
textRun
-
>
GetFlags2
(
)
&
nsTextFrameUtils
:
:
Flags
:
:
TEXT_TRAILING_WHITESPACE
)
{
mNextRunContextInfo
|
=
nsTextFrameUtils
:
:
INCOMING_WHITESPACE
;
}
if
(
textRun
-
>
GetFlags
(
)
&
gfx
:
:
ShapedTextFlags
:
:
TEXT_TRAILING_ARABICCHAR
)
{
mNextRunContextInfo
|
=
nsTextFrameUtils
:
:
INCOMING_ARABICCHAR
;
}
}
else
{
AutoTArray
<
uint8_t
BIG_TEXT_NODE_SIZE
>
buffer
;
uint32_t
bufferSize
=
mMaxTextLength
*
(
mDoubleByteText
?
2
:
1
)
;
if
(
bufferSize
<
mMaxTextLength
|
|
bufferSize
=
=
UINT32_MAX
|
|
!
buffer
.
AppendElements
(
bufferSize
fallible
)
)
{
return
;
}
textRun
=
BuildTextRunForFrames
(
buffer
.
Elements
(
)
)
;
}
}
if
(
aFlushLineBreaks
)
{
FlushLineBreaks
(
aSuppressTrailingBreak
?
nullptr
:
textRun
.
get
(
)
)
;
}
mCanStopOnThisLine
=
true
;
ResetRunInfo
(
)
;
}
void
BuildTextRunsScanner
:
:
FlushLineBreaks
(
gfxTextRun
*
aTrailingTextRun
)
{
bool
trailingLineBreak
;
nsresult
rv
=
mLineBreaker
.
Reset
(
&
trailingLineBreak
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
trailingLineBreak
&
&
aTrailingTextRun
)
{
aTrailingTextRun
-
>
SetFlagBits
(
nsTextFrameUtils
:
:
Flags
:
:
TEXT_HAS_TRAILING_BREAK
)
;
}
for
(
uint32_t
i
=
0
;
i
<
mBreakSinks
.
Length
(
)
;
+
+
i
)
{
mBreakSinks
[
i
]
-
>
Finish
(
mMissingFonts
)
;
}
mBreakSinks
.
Clear
(
)
;
}
void
BuildTextRunsScanner
:
:
AccumulateRunInfo
(
nsTextFrame
*
aFrame
)
{
if
(
mMaxTextLength
!
=
UINT32_MAX
)
{
NS_ASSERTION
(
mMaxTextLength
<
UINT32_MAX
-
aFrame
-
>
GetContentLength
(
)
"
integer
overflow
"
)
;
if
(
mMaxTextLength
>
=
UINT32_MAX
-
aFrame
-
>
GetContentLength
(
)
)
{
mMaxTextLength
=
UINT32_MAX
;
}
else
{
mMaxTextLength
+
=
aFrame
-
>
GetContentLength
(
)
;
}
}
mDoubleByteText
|
=
aFrame
-
>
GetContent
(
)
-
>
GetText
(
)
-
>
Is2b
(
)
;
mLastFrame
=
aFrame
;
mCommonAncestorWithLastFrame
=
aFrame
-
>
GetParent
(
)
;
MappedFlow
*
mappedFlow
=
&
mMappedFlows
[
mMappedFlows
.
Length
(
)
-
1
]
;
NS_ASSERTION
(
mappedFlow
-
>
mStartFrame
=
=
aFrame
|
|
mappedFlow
-
>
GetContentEnd
(
)
=
=
aFrame
-
>
GetContentOffset
(
)
"
Overlapping
or
discontiguous
frames
=
>
BAD
"
)
;
mappedFlow
-
>
mEndFrame
=
aFrame
-
>
GetNextContinuation
(
)
;
if
(
mCurrentFramesAllSameTextRun
!
=
aFrame
-
>
GetTextRun
(
mWhichTextRun
)
)
{
mCurrentFramesAllSameTextRun
=
nullptr
;
}
if
(
mStartOfLine
)
{
mLineBreakBeforeFrames
.
AppendElement
(
aFrame
)
;
mStartOfLine
=
false
;
}
}
static
bool
HasTerminalNewline
(
const
nsTextFrame
*
aFrame
)
{
if
(
aFrame
-
>
GetContentLength
(
)
=
=
0
)
return
false
;
const
nsTextFragment
*
frag
=
aFrame
-
>
GetContent
(
)
-
>
GetText
(
)
;
return
frag
-
>
CharAt
(
aFrame
-
>
GetContentEnd
(
)
-
1
)
=
=
'
\
n
'
;
}
static
gfxFont
:
:
Metrics
GetFirstFontMetrics
(
gfxFontGroup
*
aFontGroup
bool
aVerticalMetrics
)
{
if
(
!
aFontGroup
)
return
gfxFont
:
:
Metrics
(
)
;
gfxFont
*
font
=
aFontGroup
-
>
GetFirstValidFont
(
)
;
return
font
-
>
GetMetrics
(
aVerticalMetrics
?
gfxFont
:
:
eVertical
:
gfxFont
:
:
eHorizontal
)
;
}
static
gfxFloat
GetSpaceWidthAppUnits
(
const
gfxTextRun
*
aTextRun
)
{
gfxFloat
spaceWidthAppUnits
=
NS_round
(
GetFirstFontMetrics
(
aTextRun
-
>
GetFontGroup
(
)
aTextRun
-
>
UseCenterBaseline
(
)
)
.
spaceWidth
*
aTextRun
-
>
GetAppUnitsPerDevUnit
(
)
)
;
return
spaceWidthAppUnits
;
}
static
nscoord
LetterSpacing
(
nsIFrame
*
aFrame
const
nsStyleText
*
aStyleText
=
nullptr
)
{
if
(
nsSVGUtils
:
:
IsInSVGTextSubtree
(
aFrame
)
)
{
return
0
;
}
if
(
!
aStyleText
)
{
aStyleText
=
aFrame
-
>
StyleText
(
)
;
}
const
nsStyleCoord
&
coord
=
aStyleText
-
>
mLetterSpacing
;
if
(
eStyleUnit_Coord
=
=
coord
.
GetUnit
(
)
)
{
return
coord
.
GetCoordValue
(
)
;
}
return
0
;
}
static
nscoord
WordSpacing
(
nsIFrame
*
aFrame
const
gfxTextRun
*
aTextRun
const
nsStyleText
*
aStyleText
=
nullptr
)
{
if
(
nsSVGUtils
:
:
IsInSVGTextSubtree
(
aFrame
)
)
{
return
0
;
}
if
(
!
aStyleText
)
{
aStyleText
=
aFrame
-
>
StyleText
(
)
;
}
const
nsStyleCoord
&
coord
=
aStyleText
-
>
mWordSpacing
;
if
(
coord
.
IsCoordPercentCalcUnit
(
)
)
{
nscoord
pctBasis
=
coord
.
HasPercent
(
)
?
GetSpaceWidthAppUnits
(
aTextRun
)
:
0
;
return
coord
.
ComputeCoordPercentCalc
(
pctBasis
)
;
}
return
0
;
}
static
gfx
:
:
ShapedTextFlags
GetSpacingFlags
(
nsIFrame
*
aFrame
const
nsStyleText
*
aStyleText
=
nullptr
)
{
if
(
nsSVGUtils
:
:
IsInSVGTextSubtree
(
aFrame
)
)
{
return
gfx
:
:
ShapedTextFlags
(
)
;
}
const
nsStyleText
*
styleText
=
aFrame
-
>
StyleText
(
)
;
const
nsStyleCoord
&
ls
=
styleText
-
>
mLetterSpacing
;
const
nsStyleCoord
&
ws
=
styleText
-
>
mWordSpacing
;
bool
nonStandardSpacing
=
(
eStyleUnit_Coord
=
=
ls
.
GetUnit
(
)
&
&
ls
.
GetCoordValue
(
)
!
=
0
)
|
|
(
eStyleUnit_Coord
=
=
ws
.
GetUnit
(
)
&
&
ws
.
GetCoordValue
(
)
!
=
0
)
|
|
(
eStyleUnit_Percent
=
=
ws
.
GetUnit
(
)
&
&
ws
.
GetPercentValue
(
)
!
=
0
)
|
|
(
eStyleUnit_Calc
=
=
ws
.
GetUnit
(
)
&
&
!
ws
.
GetCalcValue
(
)
-
>
IsDefinitelyZero
(
)
)
;
return
nonStandardSpacing
?
gfx
:
:
ShapedTextFlags
:
:
TEXT_ENABLE_SPACING
:
gfx
:
:
ShapedTextFlags
(
)
;
}
bool
BuildTextRunsScanner
:
:
ContinueTextRunAcrossFrames
(
nsTextFrame
*
aFrame1
nsTextFrame
*
aFrame2
)
{
if
(
mBidiEnabled
)
{
FrameBidiData
data1
=
aFrame1
-
>
GetBidiData
(
)
;
FrameBidiData
data2
=
aFrame2
-
>
GetBidiData
(
)
;
if
(
data1
.
embeddingLevel
!
=
data2
.
embeddingLevel
|
|
data2
.
precedingControl
!
=
kBidiLevelNone
)
{
return
false
;
}
}
ComputedStyle
*
sc1
=
aFrame1
-
>
Style
(
)
;
const
nsStyleText
*
textStyle1
=
sc1
-
>
StyleText
(
)
;
if
(
textStyle1
-
>
NewlineIsSignificant
(
aFrame1
)
&
&
HasTerminalNewline
(
aFrame1
)
)
return
false
;
if
(
aFrame1
-
>
GetContent
(
)
=
=
aFrame2
-
>
GetContent
(
)
&
&
aFrame1
-
>
GetNextInFlow
(
)
!
=
aFrame2
)
{
return
false
;
}
ComputedStyle
*
sc2
=
aFrame2
-
>
Style
(
)
;
const
nsStyleText
*
textStyle2
=
sc2
-
>
StyleText
(
)
;
if
(
sc1
=
=
sc2
)
return
true
;
nsPresContext
*
pc
=
aFrame1
-
>
PresContext
(
)
;
MOZ_ASSERT
(
pc
=
=
aFrame2
-
>
PresContext
(
)
)
;
const
nsStyleFont
*
fontStyle1
=
sc1
-
>
StyleFont
(
)
;
const
nsStyleFont
*
fontStyle2
=
sc2
-
>
StyleFont
(
)
;
nscoord
letterSpacing1
=
LetterSpacing
(
aFrame1
)
;
nscoord
letterSpacing2
=
LetterSpacing
(
aFrame2
)
;
return
fontStyle1
-
>
mFont
=
=
fontStyle2
-
>
mFont
&
&
fontStyle1
-
>
mLanguage
=
=
fontStyle2
-
>
mLanguage
&
&
textStyle1
-
>
mTextTransform
=
=
textStyle2
-
>
mTextTransform
&
&
nsLayoutUtils
:
:
GetTextRunFlagsForStyle
(
sc1
pc
fontStyle1
textStyle1
letterSpacing1
)
=
=
nsLayoutUtils
:
:
GetTextRunFlagsForStyle
(
sc2
pc
fontStyle2
textStyle2
letterSpacing2
)
;
}
void
BuildTextRunsScanner
:
:
ScanFrame
(
nsIFrame
*
aFrame
)
{
LayoutFrameType
frameType
=
aFrame
-
>
Type
(
)
;
if
(
frameType
=
=
LayoutFrameType
:
:
RubyTextContainer
)
{
return
;
}
if
(
mMappedFlows
.
Length
(
)
>
0
)
{
MappedFlow
*
mappedFlow
=
&
mMappedFlows
[
mMappedFlows
.
Length
(
)
-
1
]
;
if
(
mappedFlow
-
>
mEndFrame
=
=
aFrame
&
&
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_IS_FLUID_CONTINUATION
)
)
{
NS_ASSERTION
(
frameType
=
=
LayoutFrameType
:
:
Text
"
Flow
-
sibling
of
a
text
frame
is
not
a
text
frame
?
"
)
;
if
(
mLastFrame
-
>
Style
(
)
=
=
aFrame
-
>
Style
(
)
&
&
!
HasTerminalNewline
(
mLastFrame
)
)
{
AccumulateRunInfo
(
static_cast
<
nsTextFrame
*
>
(
aFrame
)
)
;
return
;
}
}
}
if
(
frameType
=
=
LayoutFrameType
:
:
Text
)
{
nsTextFrame
*
frame
=
static_cast
<
nsTextFrame
*
>
(
aFrame
)
;
if
(
mLastFrame
)
{
if
(
!
ContinueTextRunAcrossFrames
(
mLastFrame
frame
)
)
{
FlushFrames
(
false
false
)
;
}
else
{
if
(
mLastFrame
-
>
GetContent
(
)
=
=
frame
-
>
GetContent
(
)
)
{
AccumulateRunInfo
(
frame
)
;
return
;
}
}
}
MappedFlow
*
mappedFlow
=
mMappedFlows
.
AppendElement
(
)
;
if
(
!
mappedFlow
)
return
;
mappedFlow
-
>
mStartFrame
=
frame
;
mappedFlow
-
>
mAncestorControllingInitialBreak
=
mCommonAncestorWithLastFrame
;
AccumulateRunInfo
(
frame
)
;
if
(
mMappedFlows
.
Length
(
)
=
=
1
)
{
mCurrentFramesAllSameTextRun
=
frame
-
>
GetTextRun
(
mWhichTextRun
)
;
mCurrentRunContextInfo
=
mNextRunContextInfo
;
}
return
;
}
FrameTextTraversal
traversal
=
CanTextCrossFrameBoundary
(
aFrame
)
;
bool
isBR
=
frameType
=
=
LayoutFrameType
:
:
Br
;
if
(
!
traversal
.
mLineBreakerCanCrossFrameBoundary
)
{
FlushFrames
(
true
isBR
)
;
mCommonAncestorWithLastFrame
=
aFrame
;
mNextRunContextInfo
&
=
~
nsTextFrameUtils
:
:
INCOMING_WHITESPACE
;
mStartOfLine
=
false
;
}
else
if
(
!
traversal
.
mTextRunCanCrossFrameBoundary
)
{
FlushFrames
(
false
false
)
;
}
for
(
nsIFrame
*
f
=
traversal
.
NextFrameToScan
(
)
;
f
;
f
=
traversal
.
NextFrameToScan
(
)
)
{
ScanFrame
(
f
)
;
}
if
(
!
traversal
.
mLineBreakerCanCrossFrameBoundary
)
{
FlushFrames
(
true
isBR
)
;
mCommonAncestorWithLastFrame
=
aFrame
;
mNextRunContextInfo
&
=
~
nsTextFrameUtils
:
:
INCOMING_WHITESPACE
;
}
else
if
(
!
traversal
.
mTextRunCanCrossFrameBoundary
)
{
FlushFrames
(
false
false
)
;
}
LiftCommonAncestorWithLastFrameToParent
(
aFrame
-
>
GetParent
(
)
)
;
}
nsTextFrame
*
BuildTextRunsScanner
:
:
GetNextBreakBeforeFrame
(
uint32_t
*
aIndex
)
{
uint32_t
index
=
*
aIndex
;
if
(
index
>
=
mLineBreakBeforeFrames
.
Length
(
)
)
return
nullptr
;
*
aIndex
=
index
+
1
;
return
static_cast
<
nsTextFrame
*
>
(
mLineBreakBeforeFrames
.
ElementAt
(
index
)
)
;
}
static
gfxFontGroup
*
GetFontGroupForFrame
(
const
nsIFrame
*
aFrame
float
aFontSizeInflation
nsFontMetrics
*
*
aOutFontMetrics
=
nullptr
)
{
RefPtr
<
nsFontMetrics
>
metrics
=
nsLayoutUtils
:
:
GetFontMetricsForFrame
(
aFrame
aFontSizeInflation
)
;
gfxFontGroup
*
fontGroup
=
metrics
-
>
GetThebesFontGroup
(
)
;
if
(
aOutFontMetrics
)
{
metrics
.
forget
(
aOutFontMetrics
)
;
}
return
fontGroup
;
}
static
already_AddRefed
<
DrawTarget
>
CreateReferenceDrawTarget
(
const
nsTextFrame
*
aTextFrame
)
{
RefPtr
<
gfxContext
>
ctx
=
aTextFrame
-
>
PresShell
(
)
-
>
CreateReferenceRenderingContext
(
)
;
RefPtr
<
DrawTarget
>
dt
=
ctx
-
>
GetDrawTarget
(
)
;
return
dt
.
forget
(
)
;
}
static
already_AddRefed
<
gfxTextRun
>
GetHyphenTextRun
(
const
gfxTextRun
*
aTextRun
DrawTarget
*
aDrawTarget
nsTextFrame
*
aTextFrame
)
{
RefPtr
<
DrawTarget
>
dt
=
aDrawTarget
;
if
(
!
dt
)
{
dt
=
CreateReferenceDrawTarget
(
aTextFrame
)
;
if
(
!
dt
)
{
return
nullptr
;
}
}
return
aTextRun
-
>
GetFontGroup
(
)
-
>
MakeHyphenTextRun
(
dt
aTextRun
-
>
GetAppUnitsPerDevUnit
(
)
)
;
}
already_AddRefed
<
gfxTextRun
>
BuildTextRunsScanner
:
:
BuildTextRunForFrames
(
void
*
aTextBuffer
)
{
gfxSkipChars
skipChars
;
const
void
*
textPtr
=
aTextBuffer
;
bool
anyTextTransformStyle
=
false
;
bool
anyMathMLStyling
=
false
;
bool
anyTextEmphasis
=
false
;
uint8_t
sstyScriptLevel
=
0
;
uint32_t
mathFlags
=
0
;
gfx
:
:
ShapedTextFlags
flags
=
gfx
:
:
ShapedTextFlags
(
)
;
nsTextFrameUtils
:
:
Flags
flags2
=
nsTextFrameUtils
:
:
Flags
:
:
TEXT_NO_BREAKS
;
if
(
mCurrentRunContextInfo
&
nsTextFrameUtils
:
:
INCOMING_WHITESPACE
)
{
flags2
|
=
nsTextFrameUtils
:
:
Flags
:
:
TEXT_INCOMING_WHITESPACE
;
}
if
(
mCurrentRunContextInfo
&
nsTextFrameUtils
:
:
INCOMING_ARABICCHAR
)
{
flags
|
=
gfx
:
:
ShapedTextFlags
:
:
TEXT_INCOMING_ARABICCHAR
;
}
AutoTArray
<
int32_t
50
>
textBreakPoints
;
TextRunUserData
dummyData
;
TextRunMappedFlow
dummyMappedFlow
;
TextRunMappedFlow
*
userMappedFlows
;
TextRunUserData
*
userData
;
TextRunUserData
*
userDataToDestroy
;
if
(
mMappedFlows
.
Length
(
)
=
=
1
&
&
!
mMappedFlows
[
0
]
.
mEndFrame
&
&
mMappedFlows
[
0
]
.
mStartFrame
-
>
GetContentOffset
(
)
=
=
0
)
{
userData
=
&
dummyData
;
userMappedFlows
=
&
dummyMappedFlow
;
userDataToDestroy
=
nullptr
;
dummyData
.
mMappedFlowCount
=
mMappedFlows
.
Length
(
)
;
dummyData
.
mLastFlowIndex
=
0
;
}
else
{
userData
=
CreateUserData
(
mMappedFlows
.
Length
(
)
)
;
userMappedFlows
=
reinterpret_cast
<
TextRunMappedFlow
*
>
(
userData
+
1
)
;
userDataToDestroy
=
userData
;
}
uint32_t
currentTransformedTextOffset
=
0
;
uint32_t
nextBreakIndex
=
0
;
nsTextFrame
*
nextBreakBeforeFrame
=
GetNextBreakBeforeFrame
(
&
nextBreakIndex
)
;
bool
isSVG
=
nsSVGUtils
:
:
IsInSVGTextSubtree
(
mLineContainer
)
;
bool
enabledJustification
=
(
mLineContainer
-
>
StyleText
(
)
-
>
mTextAlign
=
=
NS_STYLE_TEXT_ALIGN_JUSTIFY
|
|
mLineContainer
-
>
StyleText
(
)
-
>
mTextAlignLast
=
=
NS_STYLE_TEXT_ALIGN_JUSTIFY
)
;
const
nsStyleText
*
textStyle
=
nullptr
;
const
nsStyleFont
*
fontStyle
=
nullptr
;
ComputedStyle
*
lastComputedStyle
=
nullptr
;
for
(
uint32_t
i
=
0
;
i
<
mMappedFlows
.
Length
(
)
;
+
+
i
)
{
MappedFlow
*
mappedFlow
=
&
mMappedFlows
[
i
]
;
nsTextFrame
*
f
=
mappedFlow
-
>
mStartFrame
;
lastComputedStyle
=
f
-
>
Style
(
)
;
textStyle
=
f
-
>
StyleText
(
)
;
if
(
NS_STYLE_TEXT_TRANSFORM_NONE
!
=
textStyle
-
>
mTextTransform
|
|
lastComputedStyle
-
>
IsTextCombined
(
)
)
{
anyTextTransformStyle
=
true
;
}
if
(
textStyle
-
>
HasTextEmphasis
(
)
)
{
anyTextEmphasis
=
true
;
}
flags
|
=
GetSpacingFlags
(
f
)
;
nsTextFrameUtils
:
:
CompressionMode
compression
=
GetCSSWhitespaceToCompressionMode
(
f
textStyle
)
;
if
(
(
enabledJustification
|
|
f
-
>
ShouldSuppressLineBreak
(
)
)
&
&
!
textStyle
-
>
WhiteSpaceIsSignificant
(
)
&
&
!
isSVG
)
{
flags
|
=
gfx
:
:
ShapedTextFlags
:
:
TEXT_ENABLE_SPACING
;
}
fontStyle
=
f
-
>
StyleFont
(
)
;
nsIFrame
*
parent
=
mLineContainer
-
>
GetParent
(
)
;
if
(
NS_MATHML_MATHVARIANT_NONE
!
=
fontStyle
-
>
mMathVariant
)
{
if
(
NS_MATHML_MATHVARIANT_NORMAL
!
=
fontStyle
-
>
mMathVariant
)
{
anyMathMLStyling
=
true
;
}
}
else
if
(
mLineContainer
-
>
GetStateBits
(
)
&
NS_FRAME_IS_IN_SINGLE_CHAR_MI
)
{
flags2
|
=
nsTextFrameUtils
:
:
Flags
:
:
TEXT_IS_SINGLE_CHAR_MI
;
anyMathMLStyling
=
true
;
if
(
parent
)
{
nsIContent
*
content
=
parent
-
>
GetContent
(
)
;
if
(
content
&
&
content
-
>
IsElement
(
)
)
{
if
(
content
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
fontstyle_
NS_LITERAL_STRING
(
"
normal
"
)
eCaseMatters
)
)
{
mathFlags
|
=
MathMLTextRunFactory
:
:
MATH_FONT_STYLING_NORMAL
;
}
if
(
content
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
fontweight_
NS_LITERAL_STRING
(
"
bold
"
)
eCaseMatters
)
)
{
mathFlags
|
=
MathMLTextRunFactory
:
:
MATH_FONT_WEIGHT_BOLD
;
}
}
}
}
if
(
mLineContainer
-
>
HasAnyStateBits
(
TEXT_IS_IN_TOKEN_MATHML
)
)
{
if
(
!
(
parent
&
&
parent
-
>
GetContent
(
)
&
&
parent
-
>
GetContent
(
)
-
>
IsMathMLElement
(
nsGkAtoms
:
:
mtext_
)
)
)
{
flags
|
=
gfx
:
:
ShapedTextFlags
:
:
TEXT_USE_MATH_SCRIPT
;
}
nsIMathMLFrame
*
mathFrame
=
do_QueryFrame
(
parent
)
;
if
(
mathFrame
)
{
nsPresentationData
presData
;
mathFrame
-
>
GetPresentationData
(
presData
)
;
if
(
NS_MATHML_IS_DTLS_SET
(
presData
.
flags
)
)
{
mathFlags
|
=
MathMLTextRunFactory
:
:
MATH_FONT_FEATURE_DTLS
;
anyMathMLStyling
=
true
;
}
}
}
nsIFrame
*
child
=
mLineContainer
;
uint8_t
oldScriptLevel
=
0
;
while
(
parent
&
&
child
-
>
HasAnyStateBits
(
NS_FRAME_MATHML_SCRIPT_DESCENDANT
)
)
{
nsIMathMLFrame
*
mathFrame
=
do_QueryFrame
(
parent
)
;
if
(
mathFrame
)
{
sstyScriptLevel
+
=
mathFrame
-
>
ScriptIncrement
(
child
)
;
}
if
(
sstyScriptLevel
<
oldScriptLevel
)
{
sstyScriptLevel
=
UINT8_MAX
;
break
;
}
child
=
parent
;
parent
=
parent
-
>
GetParent
(
)
;
oldScriptLevel
=
sstyScriptLevel
;
}
if
(
sstyScriptLevel
)
{
anyMathMLStyling
=
true
;
}
nsIContent
*
content
=
f
-
>
GetContent
(
)
;
const
nsTextFragment
*
frag
=
content
-
>
GetText
(
)
;
int32_t
contentStart
=
mappedFlow
-
>
mStartFrame
-
>
GetContentOffset
(
)
;
int32_t
contentEnd
=
mappedFlow
-
>
GetContentEnd
(
)
;
int32_t
contentLength
=
contentEnd
-
contentStart
;
TextRunMappedFlow
*
newFlow
=
&
userMappedFlows
[
i
]
;
newFlow
-
>
mStartFrame
=
mappedFlow
-
>
mStartFrame
;
newFlow
-
>
mDOMOffsetToBeforeTransformOffset
=
skipChars
.
GetOriginalCharCount
(
)
-
mappedFlow
-
>
mStartFrame
-
>
GetContentOffset
(
)
;
newFlow
-
>
mContentLength
=
contentLength
;
while
(
nextBreakBeforeFrame
&
&
nextBreakBeforeFrame
-
>
GetContent
(
)
=
=
content
)
{
textBreakPoints
.
AppendElement
(
nextBreakBeforeFrame
-
>
GetContentOffset
(
)
+
newFlow
-
>
mDOMOffsetToBeforeTransformOffset
)
;
nextBreakBeforeFrame
=
GetNextBreakBeforeFrame
(
&
nextBreakIndex
)
;
}
nsTextFrameUtils
:
:
Flags
analysisFlags
;
if
(
frag
-
>
Is2b
(
)
)
{
NS_ASSERTION
(
mDoubleByteText
"
Wrong
buffer
char
size
!
"
)
;
char16_t
*
bufStart
=
static_cast
<
char16_t
*
>
(
aTextBuffer
)
;
char16_t
*
bufEnd
=
nsTextFrameUtils
:
:
TransformText
(
frag
-
>
Get2b
(
)
+
contentStart
contentLength
bufStart
compression
&
mNextRunContextInfo
&
skipChars
&
analysisFlags
)
;
aTextBuffer
=
bufEnd
;
currentTransformedTextOffset
=
bufEnd
-
static_cast
<
const
char16_t
*
>
(
textPtr
)
;
}
else
{
if
(
mDoubleByteText
)
{
AutoTArray
<
uint8_t
BIG_TEXT_NODE_SIZE
>
tempBuf
;
uint8_t
*
bufStart
=
tempBuf
.
AppendElements
(
contentLength
fallible
)
;
if
(
!
bufStart
)
{
DestroyUserData
(
userDataToDestroy
)
;
return
nullptr
;
}
uint8_t
*
end
=
nsTextFrameUtils
:
:
TransformText
(
reinterpret_cast
<
const
uint8_t
*
>
(
frag
-
>
Get1b
(
)
)
+
contentStart
contentLength
bufStart
compression
&
mNextRunContextInfo
&
skipChars
&
analysisFlags
)
;
aTextBuffer
=
ExpandBuffer
(
static_cast
<
char16_t
*
>
(
aTextBuffer
)
tempBuf
.
Elements
(
)
end
-
tempBuf
.
Elements
(
)
)
;
currentTransformedTextOffset
=
static_cast
<
char16_t
*
>
(
aTextBuffer
)
-
static_cast
<
const
char16_t
*
>
(
textPtr
)
;
}
else
{
uint8_t
*
bufStart
=
static_cast
<
uint8_t
*
>
(
aTextBuffer
)
;
uint8_t
*
end
=
nsTextFrameUtils
:
:
TransformText
(
reinterpret_cast
<
const
uint8_t
*
>
(
frag
-
>
Get1b
(
)
)
+
contentStart
contentLength
bufStart
compression
&
mNextRunContextInfo
&
skipChars
&
analysisFlags
)
;
aTextBuffer
=
end
;
currentTransformedTextOffset
=
end
-
static_cast
<
const
uint8_t
*
>
(
textPtr
)
;
}
}
flags2
|
=
analysisFlags
;
}
void
*
finalUserData
;
if
(
userData
=
=
&
dummyData
)
{
flags2
|
=
nsTextFrameUtils
:
:
Flags
:
:
TEXT_IS_SIMPLE_FLOW
;
userData
=
nullptr
;
finalUserData
=
mMappedFlows
[
0
]
.
mStartFrame
;
}
else
{
finalUserData
=
userData
;
}
uint32_t
transformedLength
=
currentTransformedTextOffset
;
nsTextFrame
*
firstFrame
=
mMappedFlows
[
0
]
.
mStartFrame
;
float
fontInflation
;
if
(
mWhichTextRun
=
=
nsTextFrame
:
:
eNotInflated
)
{
fontInflation
=
1
.
0f
;
}
else
{
fontInflation
=
nsLayoutUtils
:
:
FontSizeInflationFor
(
firstFrame
)
;
}
gfxFontGroup
*
fontGroup
=
GetFontGroupForFrame
(
firstFrame
fontInflation
)
;
if
(
!
fontGroup
)
{
DestroyUserData
(
userDataToDestroy
)
;
return
nullptr
;
}
if
(
flags2
&
nsTextFrameUtils
:
:
Flags
:
:
TEXT_HAS_TAB
)
{
flags
|
=
gfx
:
:
ShapedTextFlags
:
:
TEXT_ENABLE_SPACING
;
}
if
(
flags2
&
nsTextFrameUtils
:
:
Flags
:
:
TEXT_HAS_SHY
)
{
flags
|
=
gfx
:
:
ShapedTextFlags
:
:
TEXT_ENABLE_HYPHEN_BREAKS
;
}
if
(
mBidiEnabled
&
&
(
IS_LEVEL_RTL
(
firstFrame
-
>
GetEmbeddingLevel
(
)
)
)
)
{
flags
|
=
gfx
:
:
ShapedTextFlags
:
:
TEXT_IS_RTL
;
}
if
(
mNextRunContextInfo
&
nsTextFrameUtils
:
:
INCOMING_WHITESPACE
)
{
flags2
|
=
nsTextFrameUtils
:
:
Flags
:
:
TEXT_TRAILING_WHITESPACE
;
}
if
(
mNextRunContextInfo
&
nsTextFrameUtils
:
:
INCOMING_ARABICCHAR
)
{
flags
|
=
gfx
:
:
ShapedTextFlags
:
:
TEXT_TRAILING_ARABICCHAR
;
}
flags
|
=
nsLayoutUtils
:
:
GetTextRunFlagsForStyle
(
lastComputedStyle
firstFrame
-
>
PresContext
(
)
fontStyle
textStyle
LetterSpacing
(
firstFrame
textStyle
)
)
;
if
(
!
(
flags
&
gfx
:
:
ShapedTextFlags
:
:
TEXT_OPTIMIZE_SPEED
)
)
{
flags
|
=
gfx
:
:
ShapedTextFlags
:
:
TEXT_NEED_BOUNDING_BOX
;
}
NS_ASSERTION
(
nextBreakIndex
=
=
mLineBreakBeforeFrames
.
Length
(
)
"
Didn
'
t
find
all
the
frames
to
break
-
before
.
.
.
"
)
;
gfxSkipCharsIterator
iter
(
skipChars
)
;
AutoTArray
<
uint32_t
50
>
textBreakPointsAfterTransform
;
for
(
uint32_t
i
=
0
;
i
<
textBreakPoints
.
Length
(
)
;
+
+
i
)
{
nsTextFrameUtils
:
:
AppendLineBreakOffset
(
&
textBreakPointsAfterTransform
iter
.
ConvertOriginalToSkipped
(
textBreakPoints
[
i
]
)
)
;
}
if
(
mStartOfLine
)
{
nsTextFrameUtils
:
:
AppendLineBreakOffset
(
&
textBreakPointsAfterTransform
transformedLength
)
;
}
UniquePtr
<
nsTransformingTextRunFactory
>
transformingFactory
;
if
(
anyTextTransformStyle
)
{
transformingFactory
=
MakeUnique
<
nsCaseTransformTextRunFactory
>
(
std
:
:
move
(
transformingFactory
)
)
;
}
if
(
anyMathMLStyling
)
{
transformingFactory
=
MakeUnique
<
MathMLTextRunFactory
>
(
std
:
:
move
(
transformingFactory
)
mathFlags
sstyScriptLevel
fontInflation
)
;
}
nsTArray
<
RefPtr
<
nsTransformedCharStyle
>
>
styles
;
if
(
transformingFactory
)
{
iter
.
SetOriginalOffset
(
0
)
;
for
(
uint32_t
i
=
0
;
i
<
mMappedFlows
.
Length
(
)
;
+
+
i
)
{
MappedFlow
*
mappedFlow
=
&
mMappedFlows
[
i
]
;
nsTextFrame
*
f
;
ComputedStyle
*
sc
=
nullptr
;
RefPtr
<
nsTransformedCharStyle
>
charStyle
;
for
(
f
=
mappedFlow
-
>
mStartFrame
;
f
!
=
mappedFlow
-
>
mEndFrame
;
f
=
f
-
>
GetNextContinuation
(
)
)
{
uint32_t
offset
=
iter
.
GetSkippedOffset
(
)
;
iter
.
AdvanceOriginal
(
f
-
>
GetContentLength
(
)
)
;
uint32_t
end
=
iter
.
GetSkippedOffset
(
)
;
if
(
sc
!
=
f
-
>
Style
(
)
|
|
sc
-
>
IsTextCombined
(
)
)
{
sc
=
f
-
>
Style
(
)
;
charStyle
=
new
nsTransformedCharStyle
(
sc
f
-
>
PresContext
(
)
)
;
if
(
sc
-
>
IsTextCombined
(
)
&
&
f
-
>
CountGraphemeClusters
(
)
>
1
)
{
charStyle
-
>
mForceNonFullWidth
=
true
;
}
}
uint32_t
j
;
for
(
j
=
offset
;
j
<
end
;
+
+
j
)
{
styles
.
AppendElement
(
charStyle
)
;
}
}
}
flags2
|
=
nsTextFrameUtils
:
:
Flags
:
:
TEXT_IS_TRANSFORMED
;
NS_ASSERTION
(
iter
.
GetSkippedOffset
(
)
=
=
transformedLength
"
We
didn
'
t
cover
all
the
characters
in
the
text
run
!
"
)
;
}
RefPtr
<
gfxTextRun
>
textRun
;
gfxTextRunFactory
:
:
Parameters
params
=
{
mDrawTarget
finalUserData
&
skipChars
textBreakPointsAfterTransform
.
Elements
(
)
uint32_t
(
textBreakPointsAfterTransform
.
Length
(
)
)
int32_t
(
firstFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
}
;
if
(
mDoubleByteText
)
{
const
char16_t
*
text
=
static_cast
<
const
char16_t
*
>
(
textPtr
)
;
if
(
transformingFactory
)
{
textRun
=
transformingFactory
-
>
MakeTextRun
(
text
transformedLength
&
params
fontGroup
flags
flags2
std
:
:
move
(
styles
)
true
)
;
if
(
textRun
)
{
Unused
<
<
transformingFactory
.
release
(
)
;
}
}
else
{
textRun
=
fontGroup
-
>
MakeTextRun
(
text
transformedLength
&
params
flags
flags2
mMissingFonts
)
;
}
}
else
{
const
uint8_t
*
text
=
static_cast
<
const
uint8_t
*
>
(
textPtr
)
;
flags
|
=
gfx
:
:
ShapedTextFlags
:
:
TEXT_IS_8BIT
;
if
(
transformingFactory
)
{
textRun
=
transformingFactory
-
>
MakeTextRun
(
text
transformedLength
&
params
fontGroup
flags
flags2
std
:
:
move
(
styles
)
true
)
;
if
(
textRun
)
{
Unused
<
<
transformingFactory
.
release
(
)
;
}
}
else
{
textRun
=
fontGroup
-
>
MakeTextRun
(
text
transformedLength
&
params
flags
flags2
mMissingFonts
)
;
}
}
if
(
!
textRun
)
{
DestroyUserData
(
userDataToDestroy
)
;
return
nullptr
;
}
SetupBreakSinksForTextRun
(
textRun
.
get
(
)
textPtr
)
;
if
(
anyTextEmphasis
)
{
SetupTextEmphasisForTextRun
(
textRun
.
get
(
)
textPtr
)
;
}
if
(
mSkipIncompleteTextRuns
)
{
mSkipIncompleteTextRuns
=
!
TextContainsLineBreakerWhiteSpace
(
textPtr
transformedLength
mDoubleByteText
)
;
textRun
-
>
SetUserData
(
nullptr
)
;
DestroyUserData
(
userDataToDestroy
)
;
return
nullptr
;
}
AssignTextRun
(
textRun
.
get
(
)
fontInflation
)
;
return
textRun
.
forget
(
)
;
}
bool
BuildTextRunsScanner
:
:
SetupLineBreakerContext
(
gfxTextRun
*
aTextRun
)
{
AutoTArray
<
uint8_t
BIG_TEXT_NODE_SIZE
>
buffer
;
uint32_t
bufferSize
=
mMaxTextLength
*
(
mDoubleByteText
?
2
:
1
)
;
if
(
bufferSize
<
mMaxTextLength
|
|
bufferSize
=
=
UINT32_MAX
)
{
return
false
;
}
void
*
textPtr
=
buffer
.
AppendElements
(
bufferSize
fallible
)
;
if
(
!
textPtr
)
{
return
false
;
}
gfxSkipChars
skipChars
;
for
(
uint32_t
i
=
0
;
i
<
mMappedFlows
.
Length
(
)
;
+
+
i
)
{
MappedFlow
*
mappedFlow
=
&
mMappedFlows
[
i
]
;
nsTextFrame
*
f
=
mappedFlow
-
>
mStartFrame
;
const
nsStyleText
*
textStyle
=
f
-
>
StyleText
(
)
;
nsTextFrameUtils
:
:
CompressionMode
compression
=
GetCSSWhitespaceToCompressionMode
(
f
textStyle
)
;
nsIContent
*
content
=
f
-
>
GetContent
(
)
;
const
nsTextFragment
*
frag
=
content
-
>
GetText
(
)
;
int32_t
contentStart
=
mappedFlow
-
>
mStartFrame
-
>
GetContentOffset
(
)
;
int32_t
contentEnd
=
mappedFlow
-
>
GetContentEnd
(
)
;
int32_t
contentLength
=
contentEnd
-
contentStart
;
nsTextFrameUtils
:
:
Flags
analysisFlags
;
if
(
frag
-
>
Is2b
(
)
)
{
NS_ASSERTION
(
mDoubleByteText
"
Wrong
buffer
char
size
!
"
)
;
char16_t
*
bufStart
=
static_cast
<
char16_t
*
>
(
textPtr
)
;
char16_t
*
bufEnd
=
nsTextFrameUtils
:
:
TransformText
(
frag
-
>
Get2b
(
)
+
contentStart
contentLength
bufStart
compression
&
mNextRunContextInfo
&
skipChars
&
analysisFlags
)
;
textPtr
=
bufEnd
;
}
else
{
if
(
mDoubleByteText
)
{
AutoTArray
<
uint8_t
BIG_TEXT_NODE_SIZE
>
tempBuf
;
uint8_t
*
bufStart
=
tempBuf
.
AppendElements
(
contentLength
fallible
)
;
if
(
!
bufStart
)
{
return
false
;
}
uint8_t
*
end
=
nsTextFrameUtils
:
:
TransformText
(
reinterpret_cast
<
const
uint8_t
*
>
(
frag
-
>
Get1b
(
)
)
+
contentStart
contentLength
bufStart
compression
&
mNextRunContextInfo
&
skipChars
&
analysisFlags
)
;
textPtr
=
ExpandBuffer
(
static_cast
<
char16_t
*
>
(
textPtr
)
tempBuf
.
Elements
(
)
end
-
tempBuf
.
Elements
(
)
)
;
}
else
{
uint8_t
*
bufStart
=
static_cast
<
uint8_t
*
>
(
textPtr
)
;
uint8_t
*
end
=
nsTextFrameUtils
:
:
TransformText
(
reinterpret_cast
<
const
uint8_t
*
>
(
frag
-
>
Get1b
(
)
)
+
contentStart
contentLength
bufStart
compression
&
mNextRunContextInfo
&
skipChars
&
analysisFlags
)
;
textPtr
=
end
;
}
}
}
SetupBreakSinksForTextRun
(
aTextRun
buffer
.
Elements
(
)
)
;
return
true
;
}
static
bool
HasCompressedLeadingWhitespace
(
nsTextFrame
*
aFrame
const
nsStyleText
*
aStyleText
int32_t
aContentEndOffset
const
gfxSkipCharsIterator
&
aIterator
)
{
if
(
!
aIterator
.
IsOriginalCharSkipped
(
)
)
return
false
;
gfxSkipCharsIterator
iter
=
aIterator
;
int32_t
frameContentOffset
=
aFrame
-
>
GetContentOffset
(
)
;
const
nsTextFragment
*
frag
=
aFrame
-
>
GetContent
(
)
-
>
GetText
(
)
;
while
(
frameContentOffset
<
aContentEndOffset
&
&
iter
.
IsOriginalCharSkipped
(
)
)
{
if
(
IsTrimmableSpace
(
frag
frameContentOffset
aStyleText
)
)
return
true
;
+
+
frameContentOffset
;
iter
.
AdvanceOriginal
(
1
)
;
}
return
false
;
}
void
BuildTextRunsScanner
:
:
SetupBreakSinksForTextRun
(
gfxTextRun
*
aTextRun
const
void
*
aTextPtr
)
{
using
mozilla
:
:
intl
:
:
LineBreaker
;
switch
(
mLineContainer
-
>
StyleText
(
)
-
>
mWordBreak
)
{
case
NS_STYLE_WORDBREAK_BREAK_ALL
:
mLineBreaker
.
SetWordBreak
(
LineBreaker
:
:
kWordBreak_BreakAll
)
;
break
;
case
NS_STYLE_WORDBREAK_KEEP_ALL
:
mLineBreaker
.
SetWordBreak
(
LineBreaker
:
:
kWordBreak_KeepAll
)
;
break
;
default
:
mLineBreaker
.
SetWordBreak
(
LineBreaker
:
:
kWordBreak_Normal
)
;
break
;
}
const
nsStyleFont
*
styleFont
=
mMappedFlows
[
0
]
.
mStartFrame
-
>
StyleFont
(
)
;
nsAtom
*
hyphenationLanguage
=
styleFont
-
>
mExplicitLanguage
?
styleFont
-
>
mLanguage
.
get
(
)
:
nullptr
;
gfxSkipCharsIterator
iter
(
aTextRun
-
>
GetSkipChars
(
)
)
;
for
(
uint32_t
i
=
0
;
i
<
mMappedFlows
.
Length
(
)
;
+
+
i
)
{
MappedFlow
*
mappedFlow
=
&
mMappedFlows
[
i
]
;
uint32_t
offset
=
iter
.
GetSkippedOffset
(
)
;
gfxSkipCharsIterator
iterNext
=
iter
;
iterNext
.
AdvanceOriginal
(
mappedFlow
-
>
GetContentEnd
(
)
-
mappedFlow
-
>
mStartFrame
-
>
GetContentOffset
(
)
)
;
UniquePtr
<
BreakSink
>
*
breakSink
=
mBreakSinks
.
AppendElement
(
MakeUnique
<
BreakSink
>
(
aTextRun
mDrawTarget
offset
)
)
;
if
(
!
breakSink
|
|
!
*
breakSink
)
return
;
uint32_t
length
=
iterNext
.
GetSkippedOffset
(
)
-
offset
;
uint32_t
flags
=
0
;
nsIFrame
*
initialBreakController
=
mappedFlow
-
>
mAncestorControllingInitialBreak
;
if
(
!
initialBreakController
)
{
initialBreakController
=
mLineContainer
;
}
if
(
!
initialBreakController
-
>
StyleText
(
)
-
>
WhiteSpaceCanWrap
(
initialBreakController
)
)
{
flags
|
=
nsLineBreaker
:
:
BREAK_SUPPRESS_INITIAL
;
}
nsTextFrame
*
startFrame
=
mappedFlow
-
>
mStartFrame
;
const
nsStyleText
*
textStyle
=
startFrame
-
>
StyleText
(
)
;
if
(
!
textStyle
-
>
WhiteSpaceCanWrap
(
startFrame
)
)
{
flags
|
=
nsLineBreaker
:
:
BREAK_SUPPRESS_INSIDE
;
}
if
(
aTextRun
-
>
GetFlags2
(
)
&
nsTextFrameUtils
:
:
Flags
:
:
TEXT_NO_BREAKS
)
{
flags
|
=
nsLineBreaker
:
:
BREAK_SKIP_SETTING_NO_BREAKS
;
}
if
(
textStyle
-
>
mTextTransform
=
=
NS_STYLE_TEXT_TRANSFORM_CAPITALIZE
)
{
flags
|
=
nsLineBreaker
:
:
BREAK_NEED_CAPITALIZATION
;
}
if
(
textStyle
-
>
mHyphens
=
=
StyleHyphens
:
:
Auto
)
{
flags
|
=
nsLineBreaker
:
:
BREAK_USE_AUTO_HYPHENATION
;
}
if
(
HasCompressedLeadingWhitespace
(
startFrame
textStyle
mappedFlow
-
>
GetContentEnd
(
)
iter
)
)
{
mLineBreaker
.
AppendInvisibleWhitespace
(
flags
)
;
}
if
(
length
>
0
)
{
BreakSink
*
sink
=
mSkipIncompleteTextRuns
?
nullptr
:
(
*
breakSink
)
.
get
(
)
;
if
(
mDoubleByteText
)
{
const
char16_t
*
text
=
reinterpret_cast
<
const
char16_t
*
>
(
aTextPtr
)
;
mLineBreaker
.
AppendText
(
hyphenationLanguage
text
+
offset
length
flags
sink
)
;
}
else
{
const
uint8_t
*
text
=
reinterpret_cast
<
const
uint8_t
*
>
(
aTextPtr
)
;
mLineBreaker
.
AppendText
(
hyphenationLanguage
text
+
offset
length
flags
sink
)
;
}
}
iter
=
iterNext
;
}
}
static
bool
MayCharacterHaveEmphasisMark
(
uint32_t
aCh
)
{
auto
category
=
unicode
:
:
GetGeneralCategory
(
aCh
)
;
static_assert
(
IsUnsigned
<
decltype
(
category
)
>
:
:
value
&
&
HB_UNICODE_GENERAL_CATEGORY_CONTROL
=
=
0
"
if
this
constant
is
not
zero
or
category
is
signed
"
"
we
need
to
explicitly
do
the
comparison
below
"
)
;
return
!
(
category
<
=
HB_UNICODE_GENERAL_CATEGORY_UNASSIGNED
|
|
(
category
>
=
HB_UNICODE_GENERAL_CATEGORY_LINE_SEPARATOR
&
&
category
<
=
HB_UNICODE_GENERAL_CATEGORY_SPACE_SEPARATOR
)
)
;
}
static
bool
MayCharacterHaveEmphasisMark
(
uint8_t
aCh
)
{
bool
result
=
!
(
aCh
<
=
0x20
|
|
(
aCh
>
=
0x7f
&
&
aCh
<
=
0xa0
)
)
;
MOZ_ASSERT
(
result
=
=
MayCharacterHaveEmphasisMark
(
uint32_t
(
aCh
)
)
"
result
for
uint8_t
should
match
result
for
uint32_t
"
)
;
return
result
;
}
void
BuildTextRunsScanner
:
:
SetupTextEmphasisForTextRun
(
gfxTextRun
*
aTextRun
const
void
*
aTextPtr
)
{
if
(
!
mDoubleByteText
)
{
auto
text
=
reinterpret_cast
<
const
uint8_t
*
>
(
aTextPtr
)
;
for
(
auto
i
:
IntegerRange
(
aTextRun
-
>
GetLength
(
)
)
)
{
if
(
!
MayCharacterHaveEmphasisMark
(
text
[
i
]
)
)
{
aTextRun
-
>
SetNoEmphasisMark
(
i
)
;
}
}
}
else
{
auto
text
=
reinterpret_cast
<
const
char16_t
*
>
(
aTextPtr
)
;
auto
length
=
aTextRun
-
>
GetLength
(
)
;
for
(
size_t
i
=
0
;
i
<
length
;
+
+
i
)
{
if
(
NS_IS_HIGH_SURROGATE
(
text
[
i
]
)
&
&
i
+
1
<
length
&
&
NS_IS_LOW_SURROGATE
(
text
[
i
+
1
]
)
)
{
uint32_t
ch
=
SURROGATE_TO_UCS4
(
text
[
i
]
text
[
i
+
1
]
)
;
if
(
!
MayCharacterHaveEmphasisMark
(
ch
)
)
{
aTextRun
-
>
SetNoEmphasisMark
(
i
)
;
aTextRun
-
>
SetNoEmphasisMark
(
i
+
1
)
;
}
+
+
i
;
}
else
{
if
(
!
MayCharacterHaveEmphasisMark
(
uint32_t
(
text
[
i
]
)
)
)
{
aTextRun
-
>
SetNoEmphasisMark
(
i
)
;
}
}
}
}
}
static
inline
TextRunMappedFlow
*
FindFlowForContent
(
TextRunUserData
*
aUserData
nsIContent
*
aContent
TextRunMappedFlow
*
userMappedFlows
)
{
int32_t
i
=
aUserData
-
>
mLastFlowIndex
;
int32_t
delta
=
1
;
int32_t
sign
=
1
;
while
(
i
>
=
0
&
&
uint32_t
(
i
)
<
aUserData
-
>
mMappedFlowCount
)
{
TextRunMappedFlow
*
flow
=
&
userMappedFlows
[
i
]
;
if
(
flow
-
>
mStartFrame
-
>
GetContent
(
)
=
=
aContent
)
{
return
flow
;
}
i
+
=
delta
;
sign
=
-
sign
;
delta
=
-
delta
+
sign
;
}
i
+
=
delta
;
if
(
sign
>
0
)
{
for
(
;
i
<
int32_t
(
aUserData
-
>
mMappedFlowCount
)
;
+
+
i
)
{
TextRunMappedFlow
*
flow
=
&
userMappedFlows
[
i
]
;
if
(
flow
-
>
mStartFrame
-
>
GetContent
(
)
=
=
aContent
)
{
return
flow
;
}
}
}
else
{
for
(
;
i
>
=
0
;
-
-
i
)
{
TextRunMappedFlow
*
flow
=
&
userMappedFlows
[
i
]
;
if
(
flow
-
>
mStartFrame
-
>
GetContent
(
)
=
=
aContent
)
{
return
flow
;
}
}
}
return
nullptr
;
}
void
BuildTextRunsScanner
:
:
AssignTextRun
(
gfxTextRun
*
aTextRun
float
aInflation
)
{
for
(
uint32_t
i
=
0
;
i
<
mMappedFlows
.
Length
(
)
;
+
+
i
)
{
MappedFlow
*
mappedFlow
=
&
mMappedFlows
[
i
]
;
nsTextFrame
*
startFrame
=
mappedFlow
-
>
mStartFrame
;
nsTextFrame
*
endFrame
=
mappedFlow
-
>
mEndFrame
;
nsTextFrame
*
f
;
for
(
f
=
startFrame
;
f
!
=
endFrame
;
f
=
f
-
>
GetNextContinuation
(
)
)
{
#
ifdef
DEBUG_roc
if
(
f
-
>
GetTextRun
(
mWhichTextRun
)
)
{
gfxTextRun
*
textRun
=
f
-
>
GetTextRun
(
mWhichTextRun
)
;
if
(
textRun
-
>
GetFlags2
(
)
&
nsTextFrameUtils
:
:
Flags
:
:
TEXT_IS_SIMPLE_FLOW
)
{
if
(
mMappedFlows
[
0
]
.
mStartFrame
!
=
GetFrameForSimpleFlow
(
textRun
)
)
{
NS_WARNING
(
"
REASSIGNING
SIMPLE
FLOW
TEXT
RUN
!
"
)
;
}
}
else
{
auto
userData
=
static_cast
<
TextRunUserData
*
>
(
aTextRun
-
>
GetUserData
(
)
)
;
TextRunMappedFlow
*
userMappedFlows
=
GetMappedFlows
(
aTextRun
)
;
if
(
userData
-
>
mMappedFlowCount
>
=
mMappedFlows
.
Length
(
)
|
|
userMappedFlows
[
userData
-
>
mMappedFlowCount
-
1
]
.
mStartFrame
!
=
mMappedFlows
[
userdata
-
>
mMappedFlowCount
-
1
]
.
mStartFrame
)
{
NS_WARNING
(
"
REASSIGNING
MULTIFLOW
TEXT
RUN
(
not
append
)
!
"
)
;
}
}
}
#
endif
gfxTextRun
*
oldTextRun
=
f
-
>
GetTextRun
(
mWhichTextRun
)
;
if
(
oldTextRun
)
{
nsTextFrame
*
firstFrame
=
nullptr
;
uint32_t
startOffset
=
0
;
if
(
oldTextRun
-
>
GetFlags2
(
)
&
nsTextFrameUtils
:
:
Flags
:
:
TEXT_IS_SIMPLE_FLOW
)
{
firstFrame
=
GetFrameForSimpleFlow
(
oldTextRun
)
;
}
else
{
auto
userData
=
static_cast
<
TextRunUserData
*
>
(
oldTextRun
-
>
GetUserData
(
)
)
;
TextRunMappedFlow
*
userMappedFlows
=
GetMappedFlows
(
oldTextRun
)
;
firstFrame
=
userMappedFlows
[
0
]
.
mStartFrame
;
if
(
MOZ_UNLIKELY
(
f
!
=
firstFrame
)
)
{
TextRunMappedFlow
*
flow
=
FindFlowForContent
(
userData
f
-
>
GetContent
(
)
userMappedFlows
)
;
if
(
flow
)
{
startOffset
=
flow
-
>
mDOMOffsetToBeforeTransformOffset
;
}
else
{
NS_ERROR
(
"
Can
'
t
find
flow
containing
frame
'
f
'
"
)
;
}
}
}
nsTextFrame
*
clearFrom
=
nullptr
;
if
(
MOZ_UNLIKELY
(
f
!
=
firstFrame
)
)
{
gfxSkipCharsIterator
iter
(
oldTextRun
-
>
GetSkipChars
(
)
startOffset
f
-
>
GetContentOffset
(
)
)
;
uint32_t
textRunOffset
=
iter
.
ConvertOriginalToSkipped
(
f
-
>
GetContentOffset
(
)
)
;
clearFrom
=
textRunOffset
=
=
oldTextRun
-
>
GetLength
(
)
?
f
:
nullptr
;
}
f
-
>
ClearTextRun
(
clearFrom
mWhichTextRun
)
;
#
ifdef
DEBUG
if
(
firstFrame
&
&
!
firstFrame
-
>
GetTextRun
(
mWhichTextRun
)
)
{
for
(
uint32_t
j
=
0
;
j
<
mBreakSinks
.
Length
(
)
;
+
+
j
)
{
NS_ASSERTION
(
oldTextRun
!
=
mBreakSinks
[
j
]
-
>
mTextRun
"
destroyed
text
run
is
still
in
use
"
)
;
}
}
#
endif
}
f
-
>
SetTextRun
(
aTextRun
mWhichTextRun
aInflation
)
;
}
nsFrameState
whichTextRunState
=
startFrame
-
>
GetTextRun
(
nsTextFrame
:
:
eInflated
)
=
=
aTextRun
?
TEXT_IN_TEXTRUN_USER_DATA
:
TEXT_IN_UNINFLATED_TEXTRUN_USER_DATA
;
startFrame
-
>
AddStateBits
(
whichTextRunState
)
;
}
}
NS_QUERYFRAME_HEAD
(
nsTextFrame
)
NS_QUERYFRAME_ENTRY
(
nsTextFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsFrame
)
gfxSkipCharsIterator
nsTextFrame
:
:
EnsureTextRun
(
TextRunType
aWhichTextRun
DrawTarget
*
aRefDrawTarget
nsIFrame
*
aLineContainer
const
nsLineList
:
:
iterator
*
aLine
uint32_t
*
aFlowEndInTextRun
)
{
gfxTextRun
*
textRun
=
GetTextRun
(
aWhichTextRun
)
;
if
(
!
textRun
|
|
(
aLine
&
&
(
*
aLine
)
-
>
GetInvalidateTextRuns
(
)
)
)
{
RefPtr
<
DrawTarget
>
refDT
=
aRefDrawTarget
;
if
(
!
refDT
)
{
refDT
=
CreateReferenceDrawTarget
(
this
)
;
}
if
(
refDT
)
{
BuildTextRuns
(
refDT
this
aLineContainer
aLine
aWhichTextRun
)
;
}
textRun
=
GetTextRun
(
aWhichTextRun
)
;
if
(
!
textRun
)
{
return
gfxSkipCharsIterator
(
gfxPlatform
:
:
GetPlatform
(
)
-
>
EmptySkipChars
(
)
0
)
;
}
TabWidthStore
*
tabWidths
=
GetProperty
(
TabWidthProperty
(
)
)
;
if
(
tabWidths
&
&
tabWidths
-
>
mValidForContentOffset
!
=
GetContentOffset
(
)
)
{
DeleteProperty
(
TabWidthProperty
(
)
)
;
}
}
if
(
textRun
-
>
GetFlags2
(
)
&
nsTextFrameUtils
:
:
Flags
:
:
TEXT_IS_SIMPLE_FLOW
)
{
if
(
aFlowEndInTextRun
)
{
*
aFlowEndInTextRun
=
textRun
-
>
GetLength
(
)
;
}
return
gfxSkipCharsIterator
(
textRun
-
>
GetSkipChars
(
)
0
mContentOffset
)
;
}
auto
userData
=
static_cast
<
TextRunUserData
*
>
(
textRun
-
>
GetUserData
(
)
)
;
TextRunMappedFlow
*
userMappedFlows
=
GetMappedFlows
(
textRun
)
;
TextRunMappedFlow
*
flow
=
FindFlowForContent
(
userData
mContent
userMappedFlows
)
;
if
(
flow
)
{
uint32_t
flowIndex
=
flow
-
userMappedFlows
;
userData
-
>
mLastFlowIndex
=
flowIndex
;
gfxSkipCharsIterator
iter
(
textRun
-
>
GetSkipChars
(
)
flow
-
>
mDOMOffsetToBeforeTransformOffset
mContentOffset
)
;
if
(
aFlowEndInTextRun
)
{
if
(
flowIndex
+
1
<
userData
-
>
mMappedFlowCount
)
{
gfxSkipCharsIterator
end
(
textRun
-
>
GetSkipChars
(
)
)
;
*
aFlowEndInTextRun
=
end
.
ConvertOriginalToSkipped
(
flow
[
1
]
.
mStartFrame
-
>
GetContentOffset
(
)
+
flow
[
1
]
.
mDOMOffsetToBeforeTransformOffset
)
;
}
else
{
*
aFlowEndInTextRun
=
textRun
-
>
GetLength
(
)
;
}
}
return
iter
;
}
NS_ERROR
(
"
Can
'
t
find
flow
containing
this
frame
?
?
?
"
)
;
return
gfxSkipCharsIterator
(
gfxPlatform
:
:
GetPlatform
(
)
-
>
EmptySkipChars
(
)
0
)
;
}
static
uint32_t
GetEndOfTrimmedText
(
const
nsTextFragment
*
aFrag
const
nsStyleText
*
aStyleText
uint32_t
aStart
uint32_t
aEnd
gfxSkipCharsIterator
*
aIterator
)
{
aIterator
-
>
SetSkippedOffset
(
aEnd
)
;
while
(
aIterator
-
>
GetSkippedOffset
(
)
>
aStart
)
{
aIterator
-
>
AdvanceSkipped
(
-
1
)
;
if
(
!
IsTrimmableSpace
(
aFrag
aIterator
-
>
GetOriginalOffset
(
)
aStyleText
)
)
return
aIterator
-
>
GetSkippedOffset
(
)
+
1
;
}
return
aStart
;
}
nsTextFrame
:
:
TrimmedOffsets
nsTextFrame
:
:
GetTrimmedOffsets
(
const
nsTextFragment
*
aFrag
bool
aTrimAfter
bool
aPostReflow
)
const
{
NS_ASSERTION
(
mTextRun
"
Need
textrun
here
"
)
;
if
(
aPostReflow
)
{
NS_ASSERTION
(
!
(
GetStateBits
(
)
&
NS_FRAME_FIRST_REFLOW
)
|
|
(
GetParent
(
)
-
>
GetStateBits
(
)
&
NS_FRAME_TOO_DEEP_IN_FRAME_TREE
)
"
Can
only
call
this
on
frames
that
have
been
reflowed
"
)
;
NS_ASSERTION
(
!
(
GetStateBits
(
)
&
NS_FRAME_IN_REFLOW
)
"
Can
only
call
this
on
frames
that
are
not
being
reflowed
"
)
;
}
TrimmedOffsets
offsets
=
{
GetContentOffset
(
)
GetContentLength
(
)
}
;
const
nsStyleText
*
textStyle
=
StyleText
(
)
;
if
(
textStyle
-
>
WhiteSpaceIsSignificant
(
)
)
return
offsets
;
if
(
!
aPostReflow
|
|
(
GetStateBits
(
)
&
TEXT_START_OF_LINE
)
)
{
int32_t
whitespaceCount
=
GetTrimmableWhitespaceCount
(
aFrag
offsets
.
mStart
offsets
.
mLength
1
)
;
offsets
.
mStart
+
=
whitespaceCount
;
offsets
.
mLength
-
=
whitespaceCount
;
}
if
(
aTrimAfter
&
&
(
!
aPostReflow
|
|
(
GetStateBits
(
)
&
TEXT_END_OF_LINE
)
)
)
{
int32_t
whitespaceCount
=
GetTrimmableWhitespaceCount
(
aFrag
offsets
.
GetEnd
(
)
-
1
offsets
.
mLength
-
1
)
;
offsets
.
mLength
-
=
whitespaceCount
;
}
return
offsets
;
}
static
bool
IsJustifiableCharacter
(
const
nsStyleText
*
aTextStyle
const
nsTextFragment
*
aFrag
int32_t
aPos
bool
aLangIsCJ
)
{
NS_ASSERTION
(
aPos
>
=
0
"
negative
position
?
!
"
)
;
StyleTextJustify
justifyStyle
=
aTextStyle
-
>
mTextJustify
;
if
(
justifyStyle
=
=
StyleTextJustify
:
:
None
)
{
return
false
;
}
char16_t
ch
=
aFrag
-
>
CharAt
(
aPos
)
;
if
(
ch
=
=
'
\
n
'
|
|
ch
=
=
'
\
t
'
|
|
ch
=
=
'
\
r
'
)
{
return
true
;
}
if
(
ch
=
=
'
'
|
|
ch
=
=
CH_NBSP
)
{
if
(
!
aFrag
-
>
Is2b
(
)
)
{
return
true
;
}
return
!
nsTextFrameUtils
:
:
IsSpaceCombiningSequenceTail
(
aFrag
-
>
Get2b
(
)
+
aPos
+
1
aFrag
-
>
GetLength
(
)
-
(
aPos
+
1
)
)
;
}
if
(
justifyStyle
=
=
StyleTextJustify
:
:
InterCharacter
)
{
return
true
;
}
else
if
(
justifyStyle
=
=
StyleTextJustify
:
:
InterWord
)
{
return
false
;
}
if
(
ch
<
0x2150u
)
{
return
false
;
}
if
(
aLangIsCJ
)
{
if
(
(
0x2150u
<
=
ch
&
&
ch
<
=
0x22ffu
)
|
|
(
0x2460u
<
=
ch
&
&
ch
<
=
0x24ffu
)
|
|
(
0x2580u
<
=
ch
&
&
ch
<
=
0x27bfu
)
|
|
(
0x27f0u
<
=
ch
&
&
ch
<
=
0x2bffu
)
|
|
(
0x2e80u
<
=
ch
&
&
ch
<
=
0x312fu
)
|
|
(
0x3190u
<
=
ch
&
&
ch
<
=
0xabffu
)
|
|
(
0xf900u
<
=
ch
&
&
ch
<
=
0xfaffu
)
|
|
(
0xff5eu
<
=
ch
&
&
ch
<
=
0xff9fu
)
)
{
return
true
;
}
char16_t
ch2
;
if
(
NS_IS_HIGH_SURROGATE
(
ch
)
&
&
aFrag
-
>
GetLength
(
)
>
uint32_t
(
aPos
)
+
1
&
&
NS_IS_LOW_SURROGATE
(
ch2
=
aFrag
-
>
CharAt
(
aPos
+
1
)
)
)
{
uint32_t
u
=
SURROGATE_TO_UCS4
(
ch
ch2
)
;
if
(
0x20000u
<
=
u
&
&
u
<
=
0x2ffffu
)
{
return
true
;
}
}
}
return
false
;
}
void
nsTextFrame
:
:
ClearMetrics
(
ReflowOutput
&
aMetrics
)
{
aMetrics
.
ClearSize
(
)
;
aMetrics
.
SetBlockStartAscent
(
0
)
;
mAscent
=
0
;
AddStateBits
(
TEXT_NO_RENDERED_GLYPHS
)
;
}
static
int32_t
FindChar
(
const
nsTextFragment
*
frag
int32_t
aOffset
int32_t
aLength
char16_t
ch
)
{
int32_t
i
=
0
;
if
(
frag
-
>
Is2b
(
)
)
{
const
char16_t
*
str
=
frag
-
>
Get2b
(
)
+
aOffset
;
for
(
;
i
<
aLength
;
+
+
i
)
{
if
(
*
str
=
=
ch
)
return
i
+
aOffset
;
+
+
str
;
}
}
else
{
if
(
uint16_t
(
ch
)
<
=
0xFF
)
{
const
char
*
str
=
frag
-
>
Get1b
(
)
+
aOffset
;
const
void
*
p
=
memchr
(
str
ch
aLength
)
;
if
(
p
)
return
(
static_cast
<
const
char
*
>
(
p
)
-
str
)
+
aOffset
;
}
}
return
-
1
;
}
static
bool
IsChineseOrJapanese
(
const
nsTextFrame
*
aFrame
)
{
if
(
aFrame
-
>
ShouldSuppressLineBreak
(
)
)
{
return
true
;
}
nsAtom
*
language
=
aFrame
-
>
StyleFont
(
)
-
>
mLanguage
;
if
(
!
language
)
{
return
false
;
}
return
nsStyleUtil
:
:
MatchesLanguagePrefix
(
language
u
"
ja
"
)
|
|
nsStyleUtil
:
:
MatchesLanguagePrefix
(
language
u
"
zh
"
)
;
}
#
ifdef
DEBUG
static
bool
IsInBounds
(
const
gfxSkipCharsIterator
&
aStart
int32_t
aContentLength
gfxTextRun
:
:
Range
aRange
)
{
if
(
aStart
.
GetSkippedOffset
(
)
>
aRange
.
start
)
return
false
;
if
(
aContentLength
=
=
INT32_MAX
)
return
true
;
gfxSkipCharsIterator
iter
(
aStart
)
;
iter
.
AdvanceOriginal
(
aContentLength
)
;
return
iter
.
GetSkippedOffset
(
)
>
=
aRange
.
end
;
}
#
endif
class
MOZ_STACK_CLASS
PropertyProvider
final
:
public
gfxTextRun
:
:
PropertyProvider
{
typedef
gfxTextRun
:
:
Range
Range
;
typedef
gfxTextRun
:
:
HyphenType
HyphenType
;
public
:
PropertyProvider
(
gfxTextRun
*
aTextRun
const
nsStyleText
*
aTextStyle
const
nsTextFragment
*
aFrag
nsTextFrame
*
aFrame
const
gfxSkipCharsIterator
&
aStart
int32_t
aLength
nsIFrame
*
aLineContainer
nscoord
aOffsetFromBlockOriginForTabs
nsTextFrame
:
:
TextRunType
aWhichTextRun
)
:
mTextRun
(
aTextRun
)
mFontGroup
(
nullptr
)
mTextStyle
(
aTextStyle
)
mFrag
(
aFrag
)
mLineContainer
(
aLineContainer
)
mFrame
(
aFrame
)
mStart
(
aStart
)
mTempIterator
(
aStart
)
mTabWidths
(
nullptr
)
mTabWidthsAnalyzedLimit
(
0
)
mLength
(
aLength
)
mWordSpacing
(
WordSpacing
(
aFrame
mTextRun
aTextStyle
)
)
mLetterSpacing
(
LetterSpacing
(
aFrame
aTextStyle
)
)
mHyphenWidth
(
-
1
)
mOffsetFromBlockOriginForTabs
(
aOffsetFromBlockOriginForTabs
)
mJustificationArrayStart
(
0
)
mReflowing
(
true
)
mWhichTextRun
(
aWhichTextRun
)
{
NS_ASSERTION
(
mStart
.
IsInitialized
(
)
"
Start
not
initialized
?
"
)
;
}
PropertyProvider
(
nsTextFrame
*
aFrame
const
gfxSkipCharsIterator
&
aStart
nsTextFrame
:
:
TextRunType
aWhichTextRun
)
:
mTextRun
(
aFrame
-
>
GetTextRun
(
aWhichTextRun
)
)
mFontGroup
(
nullptr
)
mTextStyle
(
aFrame
-
>
StyleText
(
)
)
mFrag
(
aFrame
-
>
GetContent
(
)
-
>
GetText
(
)
)
mLineContainer
(
nullptr
)
mFrame
(
aFrame
)
mStart
(
aStart
)
mTempIterator
(
aStart
)
mTabWidths
(
nullptr
)
mTabWidthsAnalyzedLimit
(
0
)
mLength
(
aFrame
-
>
GetContentLength
(
)
)
mWordSpacing
(
WordSpacing
(
aFrame
mTextRun
)
)
mLetterSpacing
(
LetterSpacing
(
aFrame
)
)
mHyphenWidth
(
-
1
)
mOffsetFromBlockOriginForTabs
(
0
)
mJustificationArrayStart
(
0
)
mReflowing
(
false
)
mWhichTextRun
(
aWhichTextRun
)
{
NS_ASSERTION
(
mTextRun
"
Textrun
not
initialized
!
"
)
;
}
void
InitializeForDisplay
(
bool
aTrimAfter
)
;
void
InitializeForMeasure
(
)
;
void
GetSpacing
(
Range
aRange
Spacing
*
aSpacing
)
const
override
;
gfxFloat
GetHyphenWidth
(
)
const
override
;
void
GetHyphenationBreaks
(
Range
aRange
HyphenType
*
aBreakBefore
)
const
override
;
StyleHyphens
GetHyphensOption
(
)
const
override
{
return
mTextStyle
-
>
mHyphens
;
}
already_AddRefed
<
DrawTarget
>
GetDrawTarget
(
)
const
override
{
return
CreateReferenceDrawTarget
(
GetFrame
(
)
)
;
}
uint32_t
GetAppUnitsPerDevUnit
(
)
const
override
{
return
mTextRun
-
>
GetAppUnitsPerDevUnit
(
)
;
}
void
GetSpacingInternal
(
Range
aRange
Spacing
*
aSpacing
bool
aIgnoreTabs
)
const
;
JustificationInfo
ComputeJustification
(
Range
aRange
nsTArray
<
JustificationAssignment
>
*
aAssignments
=
nullptr
)
;
const
nsTextFrame
*
GetFrame
(
)
const
{
return
mFrame
;
}
const
gfxSkipCharsIterator
&
GetStart
(
)
const
{
return
mStart
;
}
uint32_t
GetOriginalLength
(
)
const
{
NS_ASSERTION
(
mLength
!
=
INT32_MAX
"
Length
not
known
"
)
;
return
mLength
;
}
const
nsTextFragment
*
GetFragment
(
)
const
{
return
mFrag
;
}
gfxFontGroup
*
GetFontGroup
(
)
const
{
if
(
!
mFontGroup
)
{
InitFontGroupAndFontMetrics
(
)
;
}
return
mFontGroup
;
}
nsFontMetrics
*
GetFontMetrics
(
)
const
{
if
(
!
mFontMetrics
)
{
InitFontGroupAndFontMetrics
(
)
;
}
return
mFontMetrics
;
}
void
CalcTabWidths
(
Range
aTransformedRange
gfxFloat
aTabWidth
)
const
;
const
gfxSkipCharsIterator
&
GetEndHint
(
)
const
{
return
mTempIterator
;
}
protected
:
void
SetupJustificationSpacing
(
bool
aPostReflow
)
;
void
InitFontGroupAndFontMetrics
(
)
const
{
float
inflation
=
(
mWhichTextRun
=
=
nsTextFrame
:
:
eInflated
)
?
mFrame
-
>
GetFontSizeInflation
(
)
:
1
.
0f
;
mFontGroup
=
GetFontGroupForFrame
(
mFrame
inflation
getter_AddRefs
(
mFontMetrics
)
)
;
}
const
RefPtr
<
gfxTextRun
>
mTextRun
;
mutable
gfxFontGroup
*
mFontGroup
;
mutable
RefPtr
<
nsFontMetrics
>
mFontMetrics
;
const
nsStyleText
*
mTextStyle
;
const
nsTextFragment
*
mFrag
;
const
nsIFrame
*
mLineContainer
;
nsTextFrame
*
mFrame
;
gfxSkipCharsIterator
mStart
;
const
gfxSkipCharsIterator
mTempIterator
;
mutable
TabWidthStore
*
mTabWidths
;
mutable
uint32_t
mTabWidthsAnalyzedLimit
;
int32_t
mLength
;
const
gfxFloat
mWordSpacing
;
const
gfxFloat
mLetterSpacing
;
mutable
gfxFloat
mHyphenWidth
;
mutable
gfxFloat
mOffsetFromBlockOriginForTabs
;
uint32_t
mJustificationArrayStart
;
nsTArray
<
Spacing
>
mJustificationSpacings
;
const
bool
mReflowing
;
const
nsTextFrame
:
:
TextRunType
mWhichTextRun
;
}
;
static
void
FindClusterStart
(
const
gfxTextRun
*
aTextRun
int32_t
aOriginalStart
gfxSkipCharsIterator
*
aPos
)
{
while
(
aPos
-
>
GetOriginalOffset
(
)
>
aOriginalStart
)
{
if
(
aPos
-
>
IsOriginalCharSkipped
(
)
|
|
aTextRun
-
>
IsClusterStart
(
aPos
-
>
GetSkippedOffset
(
)
)
)
{
break
;
}
aPos
-
>
AdvanceOriginal
(
-
1
)
;
}
}
static
void
FindClusterEnd
(
const
gfxTextRun
*
aTextRun
int32_t
aOriginalEnd
gfxSkipCharsIterator
*
aPos
bool
aAllowSplitLigature
=
true
)
{
MOZ_ASSERT
(
aPos
-
>
GetOriginalOffset
(
)
<
aOriginalEnd
"
character
outside
string
"
)
;
aPos
-
>
AdvanceOriginal
(
1
)
;
while
(
aPos
-
>
GetOriginalOffset
(
)
<
aOriginalEnd
)
{
if
(
aPos
-
>
IsOriginalCharSkipped
(
)
|
|
(
aTextRun
-
>
IsClusterStart
(
aPos
-
>
GetSkippedOffset
(
)
)
&
&
(
aAllowSplitLigature
|
|
aTextRun
-
>
IsLigatureGroupStart
(
aPos
-
>
GetSkippedOffset
(
)
)
)
)
)
{
break
;
}
aPos
-
>
AdvanceOriginal
(
1
)
;
}
aPos
-
>
AdvanceOriginal
(
-
1
)
;
}
JustificationInfo
PropertyProvider
:
:
ComputeJustification
(
Range
aRange
nsTArray
<
JustificationAssignment
>
*
aAssignments
)
{
JustificationInfo
info
;
if
(
mFrame
-
>
Style
(
)
-
>
IsTextCombined
(
)
)
{
return
info
;
}
bool
isCJ
=
IsChineseOrJapanese
(
mFrame
)
;
nsSkipCharsRunIterator
run
(
mStart
nsSkipCharsRunIterator
:
:
LENGTH_INCLUDES_SKIPPED
aRange
.
Length
(
)
)
;
run
.
SetOriginalOffset
(
aRange
.
start
)
;
mJustificationArrayStart
=
run
.
GetSkippedOffset
(
)
;
nsTArray
<
JustificationAssignment
>
assignments
;
assignments
.
SetCapacity
(
aRange
.
Length
(
)
)
;
while
(
run
.
NextRun
(
)
)
{
uint32_t
originalOffset
=
run
.
GetOriginalOffset
(
)
;
uint32_t
skippedOffset
=
run
.
GetSkippedOffset
(
)
;
uint32_t
length
=
run
.
GetRunLength
(
)
;
assignments
.
SetLength
(
skippedOffset
+
length
-
mJustificationArrayStart
)
;
gfxSkipCharsIterator
iter
=
run
.
GetPos
(
)
;
for
(
uint32_t
i
=
0
;
i
<
length
;
+
+
i
)
{
uint32_t
offset
=
originalOffset
+
i
;
if
(
!
IsJustifiableCharacter
(
mTextStyle
mFrag
offset
isCJ
)
)
{
continue
;
}
iter
.
SetOriginalOffset
(
offset
)
;
FindClusterStart
(
mTextRun
originalOffset
&
iter
)
;
uint32_t
firstCharOffset
=
iter
.
GetSkippedOffset
(
)
;
uint32_t
firstChar
=
firstCharOffset
>
mJustificationArrayStart
?
firstCharOffset
-
mJustificationArrayStart
:
0
;
if
(
!
firstChar
)
{
info
.
mIsStartJustifiable
=
true
;
}
else
{
auto
&
assign
=
assignments
[
firstChar
]
;
auto
&
prevAssign
=
assignments
[
firstChar
-
1
]
;
if
(
prevAssign
.
mGapsAtEnd
)
{
prevAssign
.
mGapsAtEnd
=
1
;
assign
.
mGapsAtStart
=
1
;
}
else
{
assign
.
mGapsAtStart
=
2
;
info
.
mInnerOpportunities
+
+
;
}
}
FindClusterEnd
(
mTextRun
originalOffset
+
length
&
iter
)
;
uint32_t
lastChar
=
iter
.
GetSkippedOffset
(
)
-
mJustificationArrayStart
;
assignments
[
lastChar
]
.
mGapsAtEnd
=
2
;
info
.
mInnerOpportunities
+
+
;
i
=
iter
.
GetOriginalOffset
(
)
-
originalOffset
;
}
}
if
(
!
assignments
.
IsEmpty
(
)
&
&
assignments
.
LastElement
(
)
.
mGapsAtEnd
)
{
MOZ_ASSERT
(
info
.
mInnerOpportunities
>
0
)
;
info
.
mInnerOpportunities
-
-
;
info
.
mIsEndJustifiable
=
true
;
}
if
(
aAssignments
)
{
*
aAssignments
=
std
:
:
move
(
assignments
)
;
}
return
info
;
}
void
PropertyProvider
:
:
GetSpacing
(
Range
aRange
Spacing
*
aSpacing
)
const
{
GetSpacingInternal
(
aRange
aSpacing
!
(
mTextRun
-
>
GetFlags2
(
)
&
nsTextFrameUtils
:
:
Flags
:
:
TEXT_HAS_TAB
)
)
;
}
static
bool
CanAddSpacingAfter
(
const
gfxTextRun
*
aTextRun
uint32_t
aOffset
)
{
if
(
aOffset
+
1
>
=
aTextRun
-
>
GetLength
(
)
)
return
true
;
return
aTextRun
-
>
IsClusterStart
(
aOffset
+
1
)
&
&
aTextRun
-
>
IsLigatureGroupStart
(
aOffset
+
1
)
&
&
!
aTextRun
-
>
CharIsFormattingControl
(
aOffset
)
;
}
static
gfxFloat
ComputeTabWidthAppUnits
(
const
nsIFrame
*
aFrame
gfxTextRun
*
aTextRun
)
{
const
nsStyleText
*
textStyle
=
aFrame
-
>
StyleText
(
)
;
if
(
textStyle
-
>
mTabSize
.
GetUnit
(
)
!
=
eStyleUnit_Factor
)
{
nscoord
w
=
textStyle
-
>
mTabSize
.
GetCoordValue
(
)
;
MOZ_ASSERT
(
w
>
=
0
)
;
return
w
;
}
gfxFloat
spaces
=
textStyle
-
>
mTabSize
.
GetFactorValue
(
)
;
MOZ_ASSERT
(
spaces
>
=
0
)
;
gfxFloat
spaceWidthAppUnits
=
NS_round
(
GetFirstFontMetrics
(
aTextRun
-
>
GetFontGroup
(
)
aTextRun
-
>
IsVertical
(
)
)
.
spaceWidth
*
aTextRun
-
>
GetAppUnitsPerDevUnit
(
)
)
;
return
spaces
*
spaceWidthAppUnits
;
}
void
PropertyProvider
:
:
GetSpacingInternal
(
Range
aRange
Spacing
*
aSpacing
bool
aIgnoreTabs
)
const
{
MOZ_ASSERT
(
IsInBounds
(
mStart
mLength
aRange
)
"
Range
out
of
bounds
"
)
;
uint32_t
index
;
for
(
index
=
0
;
index
<
aRange
.
Length
(
)
;
+
+
index
)
{
aSpacing
[
index
]
.
mBefore
=
0
.
0
;
aSpacing
[
index
]
.
mAfter
=
0
.
0
;
}
if
(
mFrame
-
>
Style
(
)
-
>
IsTextCombined
(
)
)
{
return
;
}
gfxSkipCharsIterator
start
(
mStart
)
;
start
.
SetSkippedOffset
(
aRange
.
start
)
;
if
(
mWordSpacing
|
|
mLetterSpacing
)
{
nsSkipCharsRunIterator
run
(
start
nsSkipCharsRunIterator
:
:
LENGTH_UNSKIPPED_ONLY
aRange
.
Length
(
)
)
;
while
(
run
.
NextRun
(
)
)
{
uint32_t
runOffsetInSubstring
=
run
.
GetSkippedOffset
(
)
-
aRange
.
start
;
gfxSkipCharsIterator
iter
=
run
.
GetPos
(
)
;
for
(
int32_t
i
=
0
;
i
<
run
.
GetRunLength
(
)
;
+
+
i
)
{
if
(
CanAddSpacingAfter
(
mTextRun
run
.
GetSkippedOffset
(
)
+
i
)
)
{
aSpacing
[
runOffsetInSubstring
+
i
]
.
mAfter
+
=
mLetterSpacing
;
}
if
(
IsCSSWordSpacingSpace
(
mFrag
i
+
run
.
GetOriginalOffset
(
)
mFrame
mTextStyle
)
)
{
iter
.
SetSkippedOffset
(
run
.
GetSkippedOffset
(
)
+
i
)
;
FindClusterEnd
(
mTextRun
run
.
GetOriginalOffset
(
)
+
run
.
GetRunLength
(
)
&
iter
)
;
uint32_t
runOffset
=
iter
.
GetSkippedOffset
(
)
-
aRange
.
start
;
aSpacing
[
runOffset
]
.
mAfter
+
=
mWordSpacing
;
}
}
}
}
if
(
!
aIgnoreTabs
)
{
gfxFloat
tabWidth
=
ComputeTabWidthAppUnits
(
mFrame
mTextRun
)
;
if
(
tabWidth
>
0
)
{
CalcTabWidths
(
aRange
tabWidth
)
;
if
(
mTabWidths
)
{
mTabWidths
-
>
ApplySpacing
(
aSpacing
aRange
.
start
-
mStart
.
GetSkippedOffset
(
)
aRange
.
Length
(
)
)
;
}
}
}
if
(
mJustificationSpacings
.
Length
(
)
>
0
)
{
auto
arrayEnd
=
mJustificationArrayStart
+
static_cast
<
uint32_t
>
(
mJustificationSpacings
.
Length
(
)
)
;
auto
end
=
std
:
:
min
(
aRange
.
end
arrayEnd
)
;
MOZ_ASSERT
(
aRange
.
start
>
=
mJustificationArrayStart
)
;
for
(
auto
i
=
aRange
.
start
;
i
<
end
;
i
+
+
)
{
const
auto
&
spacing
=
mJustificationSpacings
[
i
-
mJustificationArrayStart
]
;
uint32_t
offset
=
i
-
aRange
.
start
;
aSpacing
[
offset
]
.
mBefore
+
=
spacing
.
mBefore
;
aSpacing
[
offset
]
.
mAfter
+
=
spacing
.
mAfter
;
}
}
}
static
gfxFloat
AdvanceToNextTab
(
gfxFloat
aX
gfxFloat
aTabWidth
)
{
return
ceil
(
(
aX
+
1
)
/
aTabWidth
)
*
aTabWidth
;
}
void
PropertyProvider
:
:
CalcTabWidths
(
Range
aRange
gfxFloat
aTabWidth
)
const
{
MOZ_ASSERT
(
aTabWidth
>
0
)
;
if
(
!
mTabWidths
)
{
if
(
mReflowing
&
&
!
mLineContainer
)
{
return
;
}
if
(
!
mReflowing
)
{
mTabWidths
=
mFrame
-
>
GetProperty
(
TabWidthProperty
(
)
)
;
#
ifdef
DEBUG
for
(
uint32_t
i
=
aRange
.
end
;
i
>
aRange
.
start
;
-
-
i
)
{
if
(
mTextRun
-
>
CharIsTab
(
i
-
1
)
)
{
uint32_t
startOffset
=
mStart
.
GetSkippedOffset
(
)
;
NS_ASSERTION
(
mTabWidths
&
&
mTabWidths
-
>
mLimit
+
startOffset
>
=
i
"
Precomputed
tab
widths
are
missing
!
"
)
;
break
;
}
}
#
endif
return
;
}
}
uint32_t
startOffset
=
mStart
.
GetSkippedOffset
(
)
;
MOZ_ASSERT
(
aRange
.
start
>
=
startOffset
"
wrong
start
offset
"
)
;
MOZ_ASSERT
(
aRange
.
end
<
=
startOffset
+
mLength
"
beyond
the
end
"
)
;
uint32_t
tabsEnd
=
(
mTabWidths
?
mTabWidths
-
>
mLimit
:
mTabWidthsAnalyzedLimit
)
+
startOffset
;
if
(
tabsEnd
<
aRange
.
end
)
{
NS_ASSERTION
(
mReflowing
"
We
need
precomputed
tab
widths
but
don
'
t
have
enough
.
"
)
;
for
(
uint32_t
i
=
tabsEnd
;
i
<
aRange
.
end
;
+
+
i
)
{
Spacing
spacing
;
GetSpacingInternal
(
Range
(
i
i
+
1
)
&
spacing
true
)
;
mOffsetFromBlockOriginForTabs
+
=
spacing
.
mBefore
;
if
(
!
mTextRun
-
>
CharIsTab
(
i
)
)
{
if
(
mTextRun
-
>
IsClusterStart
(
i
)
)
{
uint32_t
clusterEnd
=
i
+
1
;
while
(
clusterEnd
<
mTextRun
-
>
GetLength
(
)
&
&
!
mTextRun
-
>
IsClusterStart
(
clusterEnd
)
)
{
+
+
clusterEnd
;
}
mOffsetFromBlockOriginForTabs
+
=
mTextRun
-
>
GetAdvanceWidth
(
Range
(
i
clusterEnd
)
nullptr
)
;
}
}
else
{
if
(
!
mTabWidths
)
{
mTabWidths
=
new
TabWidthStore
(
mFrame
-
>
GetContentOffset
(
)
)
;
mFrame
-
>
SetProperty
(
TabWidthProperty
(
)
mTabWidths
)
;
}
double
nextTab
=
AdvanceToNextTab
(
mOffsetFromBlockOriginForTabs
aTabWidth
)
;
mTabWidths
-
>
mWidths
.
AppendElement
(
TabWidth
(
i
-
startOffset
NSToIntRound
(
nextTab
-
mOffsetFromBlockOriginForTabs
)
)
)
;
mOffsetFromBlockOriginForTabs
=
nextTab
;
}
mOffsetFromBlockOriginForTabs
+
=
spacing
.
mAfter
;
}
if
(
mTabWidths
)
{
mTabWidths
-
>
mLimit
=
aRange
.
end
-
startOffset
;
}
}
if
(
!
mTabWidths
)
{
mFrame
-
>
DeleteProperty
(
TabWidthProperty
(
)
)
;
mTabWidthsAnalyzedLimit
=
std
:
:
max
(
mTabWidthsAnalyzedLimit
aRange
.
end
-
startOffset
)
;
}
}
gfxFloat
PropertyProvider
:
:
GetHyphenWidth
(
)
const
{
if
(
mHyphenWidth
<
0
)
{
mHyphenWidth
=
GetFontGroup
(
)
-
>
GetHyphenWidth
(
this
)
;
}
return
mHyphenWidth
+
mLetterSpacing
;
}
static
inline
bool
IS_HYPHEN
(
char16_t
u
)
{
return
(
u
=
=
char16_t
(
'
-
'
)
|
|
u
=
=
0x058A
|
|
u
=
=
0x2010
|
|
u
=
=
0x2012
|
|
u
=
=
0x2013
)
;
}
void
PropertyProvider
:
:
GetHyphenationBreaks
(
Range
aRange
HyphenType
*
aBreakBefore
)
const
{
MOZ_ASSERT
(
IsInBounds
(
mStart
mLength
aRange
)
"
Range
out
of
bounds
"
)
;
MOZ_ASSERT
(
mLength
!
=
INT32_MAX
"
Can
'
t
call
this
with
undefined
length
"
)
;
if
(
!
mTextStyle
-
>
WhiteSpaceCanWrap
(
mFrame
)
|
|
mTextStyle
-
>
mHyphens
=
=
StyleHyphens
:
:
None
)
{
memset
(
aBreakBefore
static_cast
<
uint8_t
>
(
HyphenType
:
:
None
)
aRange
.
Length
(
)
*
sizeof
(
HyphenType
)
)
;
return
;
}
nsSkipCharsRunIterator
run
(
mStart
nsSkipCharsRunIterator
:
:
LENGTH_UNSKIPPED_ONLY
aRange
.
Length
(
)
)
;
run
.
SetSkippedOffset
(
aRange
.
start
)
;
run
.
SetVisitSkipped
(
)
;
int32_t
prevTrailingCharOffset
=
run
.
GetPos
(
)
.
GetOriginalOffset
(
)
-
1
;
bool
allowHyphenBreakBeforeNextChar
=
prevTrailingCharOffset
>
=
mStart
.
GetOriginalOffset
(
)
&
&
prevTrailingCharOffset
<
mStart
.
GetOriginalOffset
(
)
+
mLength
&
&
mFrag
-
>
CharAt
(
prevTrailingCharOffset
)
=
=
CH_SHY
;
while
(
run
.
NextRun
(
)
)
{
NS_ASSERTION
(
run
.
GetRunLength
(
)
>
0
"
Shouldn
'
t
return
zero
-
length
runs
"
)
;
if
(
run
.
IsSkipped
(
)
)
{
allowHyphenBreakBeforeNextChar
=
mFrag
-
>
CharAt
(
run
.
GetOriginalOffset
(
)
+
run
.
GetRunLength
(
)
-
1
)
=
=
CH_SHY
;
}
else
{
int32_t
runOffsetInSubstring
=
run
.
GetSkippedOffset
(
)
-
aRange
.
start
;
memset
(
aBreakBefore
+
runOffsetInSubstring
static_cast
<
uint8_t
>
(
HyphenType
:
:
None
)
run
.
GetRunLength
(
)
*
sizeof
(
HyphenType
)
)
;
aBreakBefore
[
runOffsetInSubstring
]
=
allowHyphenBreakBeforeNextChar
&
&
(
!
(
mFrame
-
>
GetStateBits
(
)
&
TEXT_START_OF_LINE
)
|
|
run
.
GetSkippedOffset
(
)
>
mStart
.
GetSkippedOffset
(
)
)
?
HyphenType
:
:
Soft
:
HyphenType
:
:
None
;
allowHyphenBreakBeforeNextChar
=
false
;
}
}
if
(
mTextStyle
-
>
mHyphens
=
=
StyleHyphens
:
:
Auto
)
{
gfxSkipCharsIterator
skipIter
(
mStart
)
;
for
(
uint32_t
i
=
0
;
i
<
aRange
.
Length
(
)
;
+
+
i
)
{
if
(
IS_HYPHEN
(
mFrag
-
>
CharAt
(
skipIter
.
ConvertSkippedToOriginal
(
aRange
.
start
+
i
)
)
)
)
{
if
(
i
<
aRange
.
Length
(
)
-
1
)
{
aBreakBefore
[
i
+
1
]
=
HyphenType
:
:
Explicit
;
}
continue
;
}
if
(
mTextRun
-
>
CanHyphenateBefore
(
aRange
.
start
+
i
)
&
&
aBreakBefore
[
i
]
=
=
HyphenType
:
:
None
)
{
aBreakBefore
[
i
]
=
HyphenType
:
:
AutoWithoutManualInSameWord
;
}
}
}
}
void
PropertyProvider
:
:
InitializeForDisplay
(
bool
aTrimAfter
)
{
nsTextFrame
:
:
TrimmedOffsets
trimmed
=
mFrame
-
>
GetTrimmedOffsets
(
mFrag
aTrimAfter
)
;
mStart
.
SetOriginalOffset
(
trimmed
.
mStart
)
;
mLength
=
trimmed
.
mLength
;
SetupJustificationSpacing
(
true
)
;
}
void
PropertyProvider
:
:
InitializeForMeasure
(
)
{
nsTextFrame
:
:
TrimmedOffsets
trimmed
=
mFrame
-
>
GetTrimmedOffsets
(
mFrag
true
false
)
;
mStart
.
SetOriginalOffset
(
trimmed
.
mStart
)
;
mLength
=
trimmed
.
mLength
;
SetupJustificationSpacing
(
false
)
;
}
void
PropertyProvider
:
:
SetupJustificationSpacing
(
bool
aPostReflow
)
{
MOZ_ASSERT
(
mLength
!
=
INT32_MAX
"
Can
'
t
call
this
with
undefined
length
"
)
;
if
(
!
(
mFrame
-
>
GetStateBits
(
)
&
TEXT_JUSTIFICATION_ENABLED
)
)
{
return
;
}
gfxSkipCharsIterator
start
(
mStart
)
end
(
mStart
)
;
nsTextFrame
:
:
TrimmedOffsets
trimmed
=
mFrame
-
>
GetTrimmedOffsets
(
mFrag
true
aPostReflow
)
;
end
.
AdvanceOriginal
(
trimmed
.
mLength
)
;
gfxSkipCharsIterator
realEnd
(
end
)
;
Range
range
(
uint32_t
(
start
.
GetOriginalOffset
(
)
)
uint32_t
(
end
.
GetOriginalOffset
(
)
)
)
;
nsTArray
<
JustificationAssignment
>
assignments
;
JustificationInfo
info
=
ComputeJustification
(
range
&
assignments
)
;
auto
assign
=
mFrame
-
>
GetJustificationAssignment
(
)
;
auto
totalGaps
=
JustificationUtils
:
:
CountGaps
(
info
assign
)
;
if
(
!
totalGaps
|
|
assignments
.
IsEmpty
(
)
)
{
return
;
}
gfxFloat
naturalWidth
=
mTextRun
-
>
GetAdvanceWidth
(
Range
(
mStart
.
GetSkippedOffset
(
)
realEnd
.
GetSkippedOffset
(
)
)
this
)
;
if
(
mFrame
-
>
GetStateBits
(
)
&
TEXT_HYPHEN_BREAK
)
{
naturalWidth
+
=
GetHyphenWidth
(
)
;
}
nscoord
totalSpacing
=
mFrame
-
>
ISize
(
)
-
naturalWidth
;
if
(
totalSpacing
<
=
0
)
{
return
;
}
assignments
[
0
]
.
mGapsAtStart
=
assign
.
mGapsAtStart
;
assignments
.
LastElement
(
)
.
mGapsAtEnd
=
assign
.
mGapsAtEnd
;
MOZ_ASSERT
(
mJustificationSpacings
.
IsEmpty
(
)
)
;
JustificationApplicationState
state
(
totalGaps
totalSpacing
)
;
mJustificationSpacings
.
SetCapacity
(
assignments
.
Length
(
)
)
;
for
(
const
JustificationAssignment
&
assign
:
assignments
)
{
Spacing
*
spacing
=
mJustificationSpacings
.
AppendElement
(
)
;
spacing
-
>
mBefore
=
state
.
Consume
(
assign
.
mGapsAtStart
)
;
spacing
-
>
mAfter
=
state
.
Consume
(
assign
.
mGapsAtEnd
)
;
}
}
static
nscolor
EnsureDifferentColors
(
nscolor
colorA
nscolor
colorB
)
{
if
(
colorA
=
=
colorB
)
{
nscolor
res
;
res
=
NS_RGB
(
NS_GET_R
(
colorA
)
^
0xff
NS_GET_G
(
colorA
)
^
0xff
NS_GET_B
(
colorA
)
^
0xff
)
;
return
res
;
}
return
colorA
;
}
nsTextPaintStyle
:
:
nsTextPaintStyle
(
nsTextFrame
*
aFrame
)
:
mFrame
(
aFrame
)
mPresContext
(
aFrame
-
>
PresContext
(
)
)
mInitCommonColors
(
false
)
mInitSelectionColorsAndShadow
(
false
)
mResolveColors
(
true
)
mSelectionTextColor
(
NS_RGBA
(
0
0
0
0
)
)
mSelectionBGColor
(
NS_RGBA
(
0
0
0
0
)
)
mHasSelectionShadow
(
false
)
mSufficientContrast
(
0
)
mFrameBackgroundColor
(
NS_RGBA
(
0
0
0
0
)
)
mSystemFieldForegroundColor
(
NS_RGBA
(
0
0
0
0
)
)
mSystemFieldBackgroundColor
(
NS_RGBA
(
0
0
0
0
)
)
{
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
mSelectionStyle
)
;
i
+
+
)
mSelectionStyle
[
i
]
.
mInit
=
false
;
}
bool
nsTextPaintStyle
:
:
EnsureSufficientContrast
(
nscolor
*
aForeColor
nscolor
*
aBackColor
)
{
InitCommonColors
(
)
;
int32_t
backLuminosityDifference
=
NS_LUMINOSITY_DIFFERENCE
(
*
aBackColor
mFrameBackgroundColor
)
;
if
(
backLuminosityDifference
>
=
mSufficientContrast
)
return
false
;
int32_t
foreLuminosityDifference
=
NS_LUMINOSITY_DIFFERENCE
(
*
aForeColor
mFrameBackgroundColor
)
;
if
(
backLuminosityDifference
<
foreLuminosityDifference
)
{
nscolor
tmpColor
=
*
aForeColor
;
*
aForeColor
=
*
aBackColor
;
*
aBackColor
=
tmpColor
;
return
true
;
}
return
false
;
}
nscolor
nsTextPaintStyle
:
:
GetTextColor
(
)
{
if
(
nsSVGUtils
:
:
IsInSVGTextSubtree
(
mFrame
)
)
{
if
(
!
mResolveColors
)
return
NS_SAME_AS_FOREGROUND_COLOR
;
const
nsStyleSVG
*
style
=
mFrame
-
>
StyleSVG
(
)
;
switch
(
style
-
>
mFill
.
Type
(
)
)
{
case
eStyleSVGPaintType_None
:
return
NS_RGBA
(
0
0
0
0
)
;
case
eStyleSVGPaintType_Color
:
return
nsLayoutUtils
:
:
GetColor
(
mFrame
&
nsStyleSVG
:
:
mFill
)
;
default
:
NS_ERROR
(
"
cannot
resolve
SVG
paint
to
nscolor
"
)
;
return
NS_RGBA
(
0
0
0
255
)
;
}
}
return
nsLayoutUtils
:
:
GetColor
(
mFrame
&
nsStyleText
:
:
mWebkitTextFillColor
)
;
}
bool
nsTextPaintStyle
:
:
GetSelectionColors
(
nscolor
*
aForeColor
nscolor
*
aBackColor
)
{
NS_ASSERTION
(
aForeColor
"
aForeColor
is
null
"
)
;
NS_ASSERTION
(
aBackColor
"
aBackColor
is
null
"
)
;
if
(
!
InitSelectionColorsAndShadow
(
)
)
return
false
;
*
aForeColor
=
mSelectionTextColor
;
*
aBackColor
=
mSelectionBGColor
;
return
true
;
}
void
nsTextPaintStyle
:
:
GetHighlightColors
(
nscolor
*
aForeColor
nscolor
*
aBackColor
)
{
NS_ASSERTION
(
aForeColor
"
aForeColor
is
null
"
)
;
NS_ASSERTION
(
aBackColor
"
aBackColor
is
null
"
)
;
const
nsFrameSelection
*
frameSelection
=
mFrame
-
>
GetConstFrameSelection
(
)
;
const
Selection
*
selection
=
frameSelection
-
>
GetSelection
(
SelectionType
:
:
eFind
)
;
const
SelectionCustomColors
*
customColors
=
nullptr
;
if
(
selection
)
{
customColors
=
selection
-
>
GetCustomColors
(
)
;
}
if
(
!
customColors
)
{
nscolor
backColor
=
LookAndFeel
:
:
GetColor
(
LookAndFeel
:
:
eColorID_TextHighlightBackground
)
;
nscolor
foreColor
=
LookAndFeel
:
:
GetColor
(
LookAndFeel
:
:
eColorID_TextHighlightForeground
)
;
EnsureSufficientContrast
(
&
foreColor
&
backColor
)
;
*
aForeColor
=
foreColor
;
*
aBackColor
=
backColor
;
return
;
}
if
(
customColors
-
>
mForegroundColor
&
&
customColors
-
>
mBackgroundColor
)
{
nscolor
foreColor
=
*
customColors
-
>
mForegroundColor
;
nscolor
backColor
=
*
customColors
-
>
mBackgroundColor
;
if
(
EnsureSufficientContrast
(
&
foreColor
&
backColor
)
&
&
customColors
-
>
mAltForegroundColor
&
&
customColors
-
>
mAltBackgroundColor
)
{
foreColor
=
*
customColors
-
>
mAltForegroundColor
;
backColor
=
*
customColors
-
>
mAltBackgroundColor
;
}
*
aForeColor
=
foreColor
;
*
aBackColor
=
backColor
;
return
;
}
InitCommonColors
(
)
;
if
(
customColors
-
>
mBackgroundColor
)
{
nscolor
foreColor
=
GetTextColor
(
)
;
nscolor
backColor
=
*
customColors
-
>
mBackgroundColor
;
int32_t
luminosityDifference
=
NS_LUMINOSITY_DIFFERENCE
(
foreColor
backColor
)
;
if
(
mSufficientContrast
>
luminosityDifference
&
&
customColors
-
>
mAltBackgroundColor
)
{
int32_t
altLuminosityDifference
=
NS_LUMINOSITY_DIFFERENCE
(
foreColor
*
customColors
-
>
mAltBackgroundColor
)
;
if
(
luminosityDifference
<
altLuminosityDifference
)
{
backColor
=
*
customColors
-
>
mAltBackgroundColor
;
}
}
*
aForeColor
=
foreColor
;
*
aBackColor
=
backColor
;
return
;
}
if
(
customColors
-
>
mForegroundColor
)
{
nscolor
foreColor
=
*
customColors
-
>
mForegroundColor
;
int32_t
luminosityDifference
=
NS_LUMINOSITY_DIFFERENCE
(
foreColor
mFrameBackgroundColor
)
;
if
(
mSufficientContrast
>
luminosityDifference
&
&
customColors
-
>
mAltForegroundColor
)
{
int32_t
altLuminosityDifference
=
NS_LUMINOSITY_DIFFERENCE
(
*
customColors
-
>
mForegroundColor
mFrameBackgroundColor
)
;
if
(
luminosityDifference
<
altLuminosityDifference
)
{
foreColor
=
*
customColors
-
>
mAltForegroundColor
;
}
}
*
aForeColor
=
foreColor
;
*
aBackColor
=
NS_TRANSPARENT
;
return
;
}
*
aForeColor
=
GetTextColor
(
)
;
*
aBackColor
=
NS_TRANSPARENT
;
}
void
nsTextPaintStyle
:
:
GetURLSecondaryColor
(
nscolor
*
aForeColor
)
{
NS_ASSERTION
(
aForeColor
"
aForeColor
is
null
"
)
;
nscolor
textColor
=
GetTextColor
(
)
;
textColor
=
NS_RGBA
(
NS_GET_R
(
textColor
)
NS_GET_G
(
textColor
)
NS_GET_B
(
textColor
)
(
uint8_t
)
(
255
*
0
.
5f
)
)
;
InitCommonColors
(
)
;
*
aForeColor
=
NS_ComposeColors
(
mFrameBackgroundColor
textColor
)
;
}
void
nsTextPaintStyle
:
:
GetIMESelectionColors
(
int32_t
aIndex
nscolor
*
aForeColor
nscolor
*
aBackColor
)
{
NS_ASSERTION
(
aForeColor
"
aForeColor
is
null
"
)
;
NS_ASSERTION
(
aBackColor
"
aBackColor
is
null
"
)
;
NS_ASSERTION
(
aIndex
>
=
0
&
&
aIndex
<
5
"
Index
out
of
range
"
)
;
nsSelectionStyle
*
selectionStyle
=
GetSelectionStyle
(
aIndex
)
;
*
aForeColor
=
selectionStyle
-
>
mTextColor
;
*
aBackColor
=
selectionStyle
-
>
mBGColor
;
}
bool
nsTextPaintStyle
:
:
GetSelectionUnderlineForPaint
(
int32_t
aIndex
nscolor
*
aLineColor
float
*
aRelativeSize
uint8_t
*
aStyle
)
{
NS_ASSERTION
(
aLineColor
"
aLineColor
is
null
"
)
;
NS_ASSERTION
(
aRelativeSize
"
aRelativeSize
is
null
"
)
;
NS_ASSERTION
(
aIndex
>
=
0
&
&
aIndex
<
5
"
Index
out
of
range
"
)
;
nsSelectionStyle
*
selectionStyle
=
GetSelectionStyle
(
aIndex
)
;
if
(
selectionStyle
-
>
mUnderlineStyle
=
=
NS_STYLE_TEXT_DECORATION_STYLE_NONE
|
|
selectionStyle
-
>
mUnderlineColor
=
=
NS_TRANSPARENT
|
|
selectionStyle
-
>
mUnderlineRelativeSize
<
=
0
.
0f
)
return
false
;
*
aLineColor
=
selectionStyle
-
>
mUnderlineColor
;
*
aRelativeSize
=
selectionStyle
-
>
mUnderlineRelativeSize
;
*
aStyle
=
selectionStyle
-
>
mUnderlineStyle
;
return
true
;
}
void
nsTextPaintStyle
:
:
InitCommonColors
(
)
{
if
(
mInitCommonColors
)
return
;
nsIFrame
*
bgFrame
=
nsCSSRendering
:
:
FindNonTransparentBackgroundFrame
(
mFrame
)
;
NS_ASSERTION
(
bgFrame
"
Cannot
find
NonTransparentBackgroundFrame
.
"
)
;
nscolor
bgColor
=
bgFrame
-
>
GetVisitedDependentColor
(
&
nsStyleBackground
:
:
mBackgroundColor
)
;
nscolor
defaultBgColor
=
mPresContext
-
>
DefaultBackgroundColor
(
)
;
mFrameBackgroundColor
=
NS_ComposeColors
(
defaultBgColor
bgColor
)
;
mSystemFieldForegroundColor
=
LookAndFeel
:
:
GetColor
(
LookAndFeel
:
:
eColorID__moz_fieldtext
)
;
mSystemFieldBackgroundColor
=
LookAndFeel
:
:
GetColor
(
LookAndFeel
:
:
eColorID__moz_field
)
;
if
(
bgFrame
-
>
IsThemed
(
)
)
{
mSufficientContrast
=
0
;
mInitCommonColors
=
true
;
return
;
}
NS_ASSERTION
(
NS_GET_A
(
defaultBgColor
)
=
=
255
"
default
background
color
is
not
opaque
"
)
;
nscolor
defaultWindowBackgroundColor
=
LookAndFeel
:
:
GetColor
(
LookAndFeel
:
:
eColorID_WindowBackground
)
;
nscolor
selectionTextColor
=
LookAndFeel
:
:
GetColor
(
LookAndFeel
:
:
eColorID_TextSelectForeground
)
;
nscolor
selectionBGColor
=
LookAndFeel
:
:
GetColor
(
LookAndFeel
:
:
eColorID_TextSelectBackground
)
;
mSufficientContrast
=
std
:
:
min
(
std
:
:
min
(
NS_SUFFICIENT_LUMINOSITY_DIFFERENCE
NS_LUMINOSITY_DIFFERENCE
(
selectionTextColor
selectionBGColor
)
)
NS_LUMINOSITY_DIFFERENCE
(
defaultWindowBackgroundColor
selectionBGColor
)
)
;
mInitCommonColors
=
true
;
}
nscolor
nsTextPaintStyle
:
:
GetSystemFieldForegroundColor
(
)
{
InitCommonColors
(
)
;
return
mSystemFieldForegroundColor
;
}
nscolor
nsTextPaintStyle
:
:
GetSystemFieldBackgroundColor
(
)
{
InitCommonColors
(
)
;
return
mSystemFieldBackgroundColor
;
}
bool
nsTextPaintStyle
:
:
InitSelectionColorsAndShadow
(
)
{
if
(
mInitSelectionColorsAndShadow
)
return
true
;
int16_t
selectionFlags
;
int16_t
selectionStatus
=
mFrame
-
>
GetSelectionStatus
(
&
selectionFlags
)
;
if
(
!
(
selectionFlags
&
nsISelectionDisplay
:
:
DISPLAY_TEXT
)
|
|
selectionStatus
<
nsISelectionController
:
:
SELECTION_ON
)
{
return
false
;
}
mInitSelectionColorsAndShadow
=
true
;
if
(
selectionStatus
=
=
nsISelectionController
:
:
SELECTION_ON
)
{
if
(
RefPtr
<
ComputedStyle
>
style
=
mFrame
-
>
ComputeSelectionStyle
(
)
)
{
mSelectionBGColor
=
style
-
>
GetVisitedDependentColor
(
&
nsStyleBackground
:
:
mBackgroundColor
)
;
mSelectionTextColor
=
style
-
>
GetVisitedDependentColor
(
&
nsStyleText
:
:
mWebkitTextFillColor
)
;
mHasSelectionShadow
=
true
;
mSelectionShadow
=
style
-
>
StyleText
(
)
-
>
mTextShadow
;
return
true
;
}
}
nscolor
selectionBGColor
=
LookAndFeel
:
:
GetColor
(
LookAndFeel
:
:
eColorID_TextSelectBackground
)
;
if
(
selectionStatus
=
=
nsISelectionController
:
:
SELECTION_ATTENTION
)
{
mSelectionBGColor
=
LookAndFeel
:
:
GetColor
(
LookAndFeel
:
:
eColorID_TextSelectBackgroundAttention
)
;
mSelectionBGColor
=
EnsureDifferentColors
(
mSelectionBGColor
selectionBGColor
)
;
}
else
if
(
selectionStatus
!
=
nsISelectionController
:
:
SELECTION_ON
)
{
mSelectionBGColor
=
LookAndFeel
:
:
GetColor
(
LookAndFeel
:
:
eColorID_TextSelectBackgroundDisabled
)
;
mSelectionBGColor
=
EnsureDifferentColors
(
mSelectionBGColor
selectionBGColor
)
;
}
else
{
mSelectionBGColor
=
selectionBGColor
;
}
mSelectionTextColor
=
LookAndFeel
:
:
GetColor
(
LookAndFeel
:
:
eColorID_TextSelectForeground
)
;
if
(
mResolveColors
)
{
if
(
mSelectionTextColor
=
=
NS_DONT_CHANGE_COLOR
)
{
nscolor
frameColor
=
nsSVGUtils
:
:
IsInSVGTextSubtree
(
mFrame
)
?
mFrame
-
>
GetVisitedDependentColor
(
&
nsStyleSVG
:
:
mFill
)
:
mFrame
-
>
GetVisitedDependentColor
(
&
nsStyleText
:
:
mWebkitTextFillColor
)
;
mSelectionTextColor
=
EnsureDifferentColors
(
frameColor
mSelectionBGColor
)
;
}
else
if
(
mSelectionTextColor
=
=
NS_CHANGE_COLOR_IF_SAME_AS_BG
)
{
nscolor
frameColor
=
nsSVGUtils
:
:
IsInSVGTextSubtree
(
mFrame
)
?
mFrame
-
>
GetVisitedDependentColor
(
&
nsStyleSVG
:
:
mFill
)
:
mFrame
-
>
GetVisitedDependentColor
(
&
nsStyleText
:
:
mWebkitTextFillColor
)
;
if
(
frameColor
=
=
mSelectionBGColor
)
{
mSelectionTextColor
=
LookAndFeel
:
:
GetColor
(
LookAndFeel
:
:
eColorID_TextSelectForegroundCustom
)
;
}
}
else
{
EnsureSufficientContrast
(
&
mSelectionTextColor
&
mSelectionBGColor
)
;
}
}
else
{
if
(
mSelectionTextColor
=
=
NS_DONT_CHANGE_COLOR
)
{
mSelectionTextColor
=
NS_SAME_AS_FOREGROUND_COLOR
;
}
}
return
true
;
}
nsTextPaintStyle
:
:
nsSelectionStyle
*
nsTextPaintStyle
:
:
GetSelectionStyle
(
int32_t
aIndex
)
{
InitSelectionStyle
(
aIndex
)
;
return
&
mSelectionStyle
[
aIndex
]
;
}
struct
StyleIDs
{
LookAndFeel
:
:
ColorID
mForeground
mBackground
mLine
;
LookAndFeel
:
:
IntID
mLineStyle
;
LookAndFeel
:
:
FloatID
mLineRelativeSize
;
}
;
static
StyleIDs
SelectionStyleIDs
[
]
=
{
{
LookAndFeel
:
:
eColorID_IMERawInputForeground
LookAndFeel
:
:
eColorID_IMERawInputBackground
LookAndFeel
:
:
eColorID_IMERawInputUnderline
LookAndFeel
:
:
eIntID_IMERawInputUnderlineStyle
LookAndFeel
:
:
eFloatID_IMEUnderlineRelativeSize
}
{
LookAndFeel
:
:
eColorID_IMESelectedRawTextForeground
LookAndFeel
:
:
eColorID_IMESelectedRawTextBackground
LookAndFeel
:
:
eColorID_IMESelectedRawTextUnderline
LookAndFeel
:
:
eIntID_IMESelectedRawTextUnderlineStyle
LookAndFeel
:
:
eFloatID_IMEUnderlineRelativeSize
}
{
LookAndFeel
:
:
eColorID_IMEConvertedTextForeground
LookAndFeel
:
:
eColorID_IMEConvertedTextBackground
LookAndFeel
:
:
eColorID_IMEConvertedTextUnderline
LookAndFeel
:
:
eIntID_IMEConvertedTextUnderlineStyle
LookAndFeel
:
:
eFloatID_IMEUnderlineRelativeSize
}
{
LookAndFeel
:
:
eColorID_IMESelectedConvertedTextForeground
LookAndFeel
:
:
eColorID_IMESelectedConvertedTextBackground
LookAndFeel
:
:
eColorID_IMESelectedConvertedTextUnderline
LookAndFeel
:
:
eIntID_IMESelectedConvertedTextUnderline
LookAndFeel
:
:
eFloatID_IMEUnderlineRelativeSize
}
{
LookAndFeel
:
:
eColorID_LAST_COLOR
LookAndFeel
:
:
eColorID_LAST_COLOR
LookAndFeel
:
:
eColorID_SpellCheckerUnderline
LookAndFeel
:
:
eIntID_SpellCheckerUnderlineStyle
LookAndFeel
:
:
eFloatID_SpellCheckerUnderlineRelativeSize
}
}
;
void
nsTextPaintStyle
:
:
InitSelectionStyle
(
int32_t
aIndex
)
{
NS_ASSERTION
(
aIndex
>
=
0
&
&
aIndex
<
5
"
aIndex
is
invalid
"
)
;
nsSelectionStyle
*
selectionStyle
=
&
mSelectionStyle
[
aIndex
]
;
if
(
selectionStyle
-
>
mInit
)
return
;
StyleIDs
*
styleIDs
=
&
SelectionStyleIDs
[
aIndex
]
;
nscolor
foreColor
backColor
;
if
(
styleIDs
-
>
mForeground
=
=
LookAndFeel
:
:
eColorID_LAST_COLOR
)
{
foreColor
=
NS_SAME_AS_FOREGROUND_COLOR
;
}
else
{
foreColor
=
LookAndFeel
:
:
GetColor
(
styleIDs
-
>
mForeground
)
;
}
if
(
styleIDs
-
>
mBackground
=
=
LookAndFeel
:
:
eColorID_LAST_COLOR
)
{
backColor
=
NS_TRANSPARENT
;
}
else
{
backColor
=
LookAndFeel
:
:
GetColor
(
styleIDs
-
>
mBackground
)
;
}
NS_ASSERTION
(
foreColor
!
=
NS_TRANSPARENT
"
foreColor
cannot
be
NS_TRANSPARENT
"
)
;
NS_ASSERTION
(
backColor
!
=
NS_SAME_AS_FOREGROUND_COLOR
"
backColor
cannot
be
NS_SAME_AS_FOREGROUND_COLOR
"
)
;
NS_ASSERTION
(
backColor
!
=
NS_40PERCENT_FOREGROUND_COLOR
"
backColor
cannot
be
NS_40PERCENT_FOREGROUND_COLOR
"
)
;
if
(
mResolveColors
)
{
foreColor
=
GetResolvedForeColor
(
foreColor
GetTextColor
(
)
backColor
)
;
if
(
NS_GET_A
(
backColor
)
>
0
)
EnsureSufficientContrast
(
&
foreColor
&
backColor
)
;
}
nscolor
lineColor
;
float
relativeSize
;
uint8_t
lineStyle
;
GetSelectionUnderline
(
mPresContext
aIndex
&
lineColor
&
relativeSize
&
lineStyle
)
;
if
(
mResolveColors
)
lineColor
=
GetResolvedForeColor
(
lineColor
foreColor
backColor
)
;
selectionStyle
-
>
mTextColor
=
foreColor
;
selectionStyle
-
>
mBGColor
=
backColor
;
selectionStyle
-
>
mUnderlineColor
=
lineColor
;
selectionStyle
-
>
mUnderlineStyle
=
lineStyle
;
selectionStyle
-
>
mUnderlineRelativeSize
=
relativeSize
;
selectionStyle
-
>
mInit
=
true
;
}
bool
nsTextPaintStyle
:
:
GetSelectionUnderline
(
nsPresContext
*
aPresContext
int32_t
aIndex
nscolor
*
aLineColor
float
*
aRelativeSize
uint8_t
*
aStyle
)
{
NS_ASSERTION
(
aPresContext
"
aPresContext
is
null
"
)
;
NS_ASSERTION
(
aRelativeSize
"
aRelativeSize
is
null
"
)
;
NS_ASSERTION
(
aStyle
"
aStyle
is
null
"
)
;
NS_ASSERTION
(
aIndex
>
=
0
&
&
aIndex
<
5
"
Index
out
of
range
"
)
;
StyleIDs
&
styleID
=
SelectionStyleIDs
[
aIndex
]
;
nscolor
color
=
LookAndFeel
:
:
GetColor
(
styleID
.
mLine
)
;
int32_t
style
=
LookAndFeel
:
:
GetInt
(
styleID
.
mLineStyle
)
;
if
(
style
>
NS_STYLE_TEXT_DECORATION_STYLE_MAX
)
{
NS_ERROR
(
"
Invalid
underline
style
value
is
specified
"
)
;
style
=
NS_STYLE_TEXT_DECORATION_STYLE_SOLID
;
}
float
size
=
LookAndFeel
:
:
GetFloat
(
styleID
.
mLineRelativeSize
)
;
NS_ASSERTION
(
size
"
selection
underline
relative
size
must
be
larger
than
0
"
)
;
if
(
aLineColor
)
{
*
aLineColor
=
color
;
}
*
aRelativeSize
=
size
;
*
aStyle
=
style
;
return
style
!
=
NS_STYLE_TEXT_DECORATION_STYLE_NONE
&
&
color
!
=
NS_TRANSPARENT
&
&
size
>
0
.
0f
;
}
bool
nsTextPaintStyle
:
:
GetSelectionShadow
(
nsCSSShadowArray
*
*
aShadow
)
{
if
(
!
InitSelectionColorsAndShadow
(
)
)
{
return
false
;
}
if
(
mHasSelectionShadow
)
{
*
aShadow
=
mSelectionShadow
;
return
true
;
}
return
false
;
}
inline
nscolor
Get40PercentColor
(
nscolor
aForeColor
nscolor
aBackColor
)
{
nscolor
foreColor
=
NS_RGBA
(
NS_GET_R
(
aForeColor
)
NS_GET_G
(
aForeColor
)
NS_GET_B
(
aForeColor
)
(
uint8_t
)
(
255
*
0
.
4f
)
)
;
return
NS_ComposeColors
(
aBackColor
foreColor
)
;
}
nscolor
nsTextPaintStyle
:
:
GetResolvedForeColor
(
nscolor
aColor
nscolor
aDefaultForeColor
nscolor
aBackColor
)
{
if
(
aColor
=
=
NS_SAME_AS_FOREGROUND_COLOR
)
return
aDefaultForeColor
;
if
(
aColor
!
=
NS_40PERCENT_FOREGROUND_COLOR
)
return
aColor
;
nscolor
actualBGColor
=
aBackColor
;
if
(
actualBGColor
=
=
NS_TRANSPARENT
)
{
InitCommonColors
(
)
;
actualBGColor
=
mFrameBackgroundColor
;
}
return
Get40PercentColor
(
aDefaultForeColor
actualBGColor
)
;
}
#
ifdef
ACCESSIBILITY
a11y
:
:
AccType
nsTextFrame
:
:
AccessibleType
(
)
{
if
(
IsEmpty
(
)
)
{
RenderedText
text
=
GetRenderedText
(
0
UINT32_MAX
TextOffsetType
:
:
OFFSETS_IN_CONTENT_TEXT
TrailingWhitespace
:
:
DONT_TRIM_TRAILING_WHITESPACE
)
;
if
(
text
.
mString
.
IsEmpty
(
)
)
{
return
a11y
:
:
eNoType
;
}
}
return
a11y
:
:
eTextLeafType
;
}
#
endif
void
nsTextFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
NS_ASSERTION
(
!
aPrevInFlow
"
Can
'
t
be
a
continuation
!
"
)
;
MOZ_ASSERT
(
aContent
-
>
IsText
(
)
"
Bogus
content
!
"
)
;
if
(
aContent
-
>
HasFlag
(
NS_HAS_NEWLINE_PROPERTY
)
)
{
aContent
-
>
DeleteProperty
(
nsGkAtoms
:
:
newline
)
;
aContent
-
>
UnsetFlags
(
NS_HAS_NEWLINE_PROPERTY
)
;
}
if
(
aContent
-
>
HasFlag
(
NS_HAS_FLOWLENGTH_PROPERTY
)
)
{
aContent
-
>
DeleteProperty
(
nsGkAtoms
:
:
flowlength
)
;
aContent
-
>
UnsetFlags
(
NS_HAS_FLOWLENGTH_PROPERTY
)
;
}
aContent
-
>
UnsetFlags
(
NS_CREATE_FRAME_IF_NON_WHITESPACE
)
;
nsFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
}
void
nsTextFrame
:
:
ClearFrameOffsetCache
(
)
{
if
(
GetStateBits
(
)
&
TEXT_IN_OFFSET_CACHE
)
{
nsIFrame
*
primaryFrame
=
mContent
-
>
GetPrimaryFrame
(
)
;
if
(
primaryFrame
)
{
primaryFrame
-
>
DeleteProperty
(
OffsetToFrameProperty
(
)
)
;
}
RemoveStateBits
(
TEXT_IN_OFFSET_CACHE
)
;
}
}
void
nsTextFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
{
ClearFrameOffsetCache
(
)
;
ClearTextRuns
(
)
;
if
(
mNextContinuation
)
{
mNextContinuation
-
>
SetPrevInFlow
(
nullptr
)
;
}
nsFrame
:
:
DestroyFrom
(
aDestructRoot
aPostDestroyData
)
;
}
class
nsContinuingTextFrame
final
:
public
nsTextFrame
{
public
:
NS_DECL_FRAMEARENA_HELPERS
(
nsContinuingTextFrame
)
friend
nsIFrame
*
NS_NewContinuingTextFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
void
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
override
;
void
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
override
;
nsTextFrame
*
GetPrevContinuation
(
)
const
override
{
return
mPrevContinuation
;
}
void
SetPrevContinuation
(
nsIFrame
*
aPrevContinuation
)
override
{
NS_ASSERTION
(
!
aPrevContinuation
|
|
Type
(
)
=
=
aPrevContinuation
-
>
Type
(
)
"
setting
a
prev
continuation
with
incorrect
type
!
"
)
;
NS_ASSERTION
(
!
nsSplittableFrame
:
:
IsInPrevContinuationChain
(
aPrevContinuation
this
)
"
creating
a
loop
in
continuation
chain
!
"
)
;
mPrevContinuation
=
static_cast
<
nsTextFrame
*
>
(
aPrevContinuation
)
;
RemoveStateBits
(
NS_FRAME_IS_FLUID_CONTINUATION
)
;
}
nsIFrame
*
GetPrevInFlowVirtual
(
)
const
override
{
return
GetPrevInFlow
(
)
;
}
nsTextFrame
*
GetPrevInFlow
(
)
const
{
return
(
GetStateBits
(
)
&
NS_FRAME_IS_FLUID_CONTINUATION
)
?
mPrevContinuation
:
nullptr
;
}
void
SetPrevInFlow
(
nsIFrame
*
aPrevInFlow
)
override
{
NS_ASSERTION
(
!
aPrevInFlow
|
|
Type
(
)
=
=
aPrevInFlow
-
>
Type
(
)
"
setting
a
prev
in
flow
with
incorrect
type
!
"
)
;
NS_ASSERTION
(
!
nsSplittableFrame
:
:
IsInPrevContinuationChain
(
aPrevInFlow
this
)
"
creating
a
loop
in
continuation
chain
!
"
)
;
mPrevContinuation
=
static_cast
<
nsTextFrame
*
>
(
aPrevInFlow
)
;
AddStateBits
(
NS_FRAME_IS_FLUID_CONTINUATION
)
;
}
nsIFrame
*
FirstInFlow
(
)
const
override
;
nsIFrame
*
FirstContinuation
(
)
const
override
;
void
AddInlineMinISize
(
gfxContext
*
aRenderingContext
InlineMinISizeData
*
aData
)
override
;
void
AddInlinePrefISize
(
gfxContext
*
aRenderingContext
InlinePrefISizeData
*
aData
)
override
;
protected
:
explicit
nsContinuingTextFrame
(
ComputedStyle
*
aStyle
)
:
nsTextFrame
(
aStyle
kClassID
)
{
}
nsTextFrame
*
mPrevContinuation
;
}
;
void
nsContinuingTextFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
NS_ASSERTION
(
aPrevInFlow
"
Must
be
a
continuation
!
"
)
;
nsFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
nsTextFrame
*
prev
=
static_cast
<
nsTextFrame
*
>
(
aPrevInFlow
)
;
nsTextFrame
*
nextContinuation
=
prev
-
>
GetNextContinuation
(
)
;
SetPrevInFlow
(
aPrevInFlow
)
;
aPrevInFlow
-
>
SetNextInFlow
(
this
)
;
mContentOffset
=
prev
-
>
GetContentOffset
(
)
+
prev
-
>
GetContentLengthHint
(
)
;
NS_ASSERTION
(
mContentOffset
<
int32_t
(
aContent
-
>
GetText
(
)
-
>
GetLength
(
)
)
"
Creating
ContinuingTextFrame
but
there
is
no
more
content
"
)
;
if
(
prev
-
>
Style
(
)
!
=
Style
(
)
)
{
prev
-
>
ClearTextRuns
(
)
;
}
else
{
float
inflation
=
prev
-
>
GetFontSizeInflation
(
)
;
SetFontSizeInflation
(
inflation
)
;
mTextRun
=
prev
-
>
GetTextRun
(
nsTextFrame
:
:
eInflated
)
;
if
(
inflation
!
=
1
.
0f
)
{
gfxTextRun
*
uninflatedTextRun
=
prev
-
>
GetTextRun
(
nsTextFrame
:
:
eNotInflated
)
;
if
(
uninflatedTextRun
)
{
SetTextRun
(
uninflatedTextRun
nsTextFrame
:
:
eNotInflated
1
.
0f
)
;
}
}
}
if
(
aPrevInFlow
-
>
GetStateBits
(
)
&
NS_FRAME_IS_BIDI
)
{
FrameBidiData
bidiData
=
aPrevInFlow
-
>
GetBidiData
(
)
;
bidiData
.
precedingControl
=
kBidiLevelNone
;
SetProperty
(
BidiDataProperty
(
)
bidiData
)
;
if
(
nextContinuation
)
{
SetNextContinuation
(
nextContinuation
)
;
nextContinuation
-
>
SetPrevContinuation
(
this
)
;
while
(
nextContinuation
&
&
nextContinuation
-
>
GetContentOffset
(
)
<
mContentOffset
)
{
#
ifdef
DEBUG
FrameBidiData
nextBidiData
=
nextContinuation
-
>
GetBidiData
(
)
;
NS_ASSERTION
(
bidiData
.
embeddingLevel
=
=
nextBidiData
.
embeddingLevel
&
&
bidiData
.
baseLevel
=
=
nextBidiData
.
baseLevel
"
stealing
text
from
different
type
of
BIDI
continuation
"
)
;
MOZ_ASSERT
(
nextBidiData
.
precedingControl
=
=
kBidiLevelNone
"
There
shouldn
'
t
be
any
virtual
bidi
formatting
character
"
"
between
continuations
"
)
;
#
endif
nextContinuation
-
>
mContentOffset
=
mContentOffset
;
nextContinuation
=
nextContinuation
-
>
GetNextContinuation
(
)
;
}
}
AddStateBits
(
NS_FRAME_IS_BIDI
)
;
}
}
void
nsContinuingTextFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
{
ClearFrameOffsetCache
(
)
;
if
(
IsInTextRunUserData
(
)
|
|
(
mPrevContinuation
&
&
mPrevContinuation
-
>
Style
(
)
!
=
Style
(
)
)
)
{
ClearTextRuns
(
)
;
if
(
mPrevContinuation
)
{
mPrevContinuation
-
>
ClearTextRuns
(
)
;
}
}
nsSplittableFrame
:
:
RemoveFromFlow
(
this
)
;
nsFrame
:
:
DestroyFrom
(
aDestructRoot
aPostDestroyData
)
;
}
nsIFrame
*
nsContinuingTextFrame
:
:
FirstInFlow
(
)
const
{
nsIFrame
*
firstInFlow
*
previous
=
const_cast
<
nsIFrame
*
>
(
static_cast
<
const
nsIFrame
*
>
(
this
)
)
;
do
{
firstInFlow
=
previous
;
previous
=
firstInFlow
-
>
GetPrevInFlow
(
)
;
}
while
(
previous
)
;
MOZ_ASSERT
(
firstInFlow
"
post
-
condition
failed
"
)
;
return
firstInFlow
;
}
nsIFrame
*
nsContinuingTextFrame
:
:
FirstContinuation
(
)
const
{
nsIFrame
*
firstContinuation
*
previous
=
const_cast
<
nsIFrame
*
>
(
static_cast
<
const
nsIFrame
*
>
(
mPrevContinuation
)
)
;
NS_ASSERTION
(
previous
"
How
can
an
nsContinuingTextFrame
be
the
first
continuation
?
"
)
;
do
{
firstContinuation
=
previous
;
previous
=
firstContinuation
-
>
GetPrevContinuation
(
)
;
}
while
(
previous
)
;
MOZ_ASSERT
(
firstContinuation
"
post
-
condition
failed
"
)
;
return
firstContinuation
;
}
nscoord
nsTextFrame
:
:
GetMinISize
(
gfxContext
*
aRenderingContext
)
{
return
nsLayoutUtils
:
:
MinISizeFromInline
(
this
aRenderingContext
)
;
}
nscoord
nsTextFrame
:
:
GetPrefISize
(
gfxContext
*
aRenderingContext
)
{
return
nsLayoutUtils
:
:
PrefISizeFromInline
(
this
aRenderingContext
)
;
}
void
nsContinuingTextFrame
:
:
AddInlineMinISize
(
gfxContext
*
aRenderingContext
InlineMinISizeData
*
aData
)
{
}
void
nsContinuingTextFrame
:
:
AddInlinePrefISize
(
gfxContext
*
aRenderingContext
InlinePrefISizeData
*
aData
)
{
}
#
if
defined
(
DEBUG_rbs
)
|
|
defined
(
DEBUG_bzbarsky
)
static
void
VerifyNotDirty
(
nsFrameState
state
)
{
bool
isZero
=
state
&
NS_FRAME_FIRST_REFLOW
;
bool
isDirty
=
state
&
NS_FRAME_IS_DIRTY
;
if
(
!
isZero
&
&
isDirty
)
NS_WARNING
(
"
internal
offsets
may
be
out
-
of
-
sync
"
)
;
}
#
define
DEBUG_VERIFY_NOT_DIRTY
(
state
)
\
VerifyNotDirty
(
state
)
#
else
#
define
DEBUG_VERIFY_NOT_DIRTY
(
state
)
#
endif
nsIFrame
*
NS_NewTextFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsTextFrame
(
aStyle
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsTextFrame
)
nsIFrame
*
NS_NewContinuingTextFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsContinuingTextFrame
(
aStyle
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsContinuingTextFrame
)
nsTextFrame
:
:
~
nsTextFrame
(
)
{
}
nsresult
nsTextFrame
:
:
GetCursor
(
const
nsPoint
&
aPoint
nsIFrame
:
:
Cursor
&
aCursor
)
{
FillCursorInformationFromStyle
(
StyleUserInterface
(
)
aCursor
)
;
if
(
NS_STYLE_CURSOR_AUTO
=
=
aCursor
.
mCursor
)
{
if
(
!
IsSelectable
(
nullptr
)
)
{
aCursor
.
mCursor
=
NS_STYLE_CURSOR_DEFAULT
;
}
else
{
aCursor
.
mCursor
=
GetWritingMode
(
)
.
IsVertical
(
)
?
NS_STYLE_CURSOR_VERTICAL_TEXT
:
NS_STYLE_CURSOR_TEXT
;
}
return
NS_OK
;
}
else
{
return
nsFrame
:
:
GetCursor
(
aPoint
aCursor
)
;
}
}
nsTextFrame
*
nsTextFrame
:
:
LastInFlow
(
)
const
{
nsTextFrame
*
lastInFlow
=
const_cast
<
nsTextFrame
*
>
(
this
)
;
while
(
lastInFlow
-
>
GetNextInFlow
(
)
)
{
lastInFlow
=
lastInFlow
-
>
GetNextInFlow
(
)
;
}
MOZ_ASSERT
(
lastInFlow
"
post
-
condition
failed
"
)
;
return
lastInFlow
;
}
nsTextFrame
*
nsTextFrame
:
:
LastContinuation
(
)
const
{
nsTextFrame
*
lastContinuation
=
const_cast
<
nsTextFrame
*
>
(
this
)
;
while
(
lastContinuation
-
>
mNextContinuation
)
{
lastContinuation
=
lastContinuation
-
>
mNextContinuation
;
}
MOZ_ASSERT
(
lastContinuation
"
post
-
condition
failed
"
)
;
return
lastContinuation
;
}
void
nsTextFrame
:
:
InvalidateFrame
(
uint32_t
aDisplayItemKey
bool
aRebuildDisplayItems
)
{
if
(
nsSVGUtils
:
:
IsInSVGTextSubtree
(
this
)
)
{
nsIFrame
*
svgTextFrame
=
nsLayoutUtils
:
:
GetClosestFrameOfType
(
GetParent
(
)
LayoutFrameType
:
:
SVGText
)
;
svgTextFrame
-
>
InvalidateFrame
(
)
;
return
;
}
nsFrame
:
:
InvalidateFrame
(
aDisplayItemKey
aRebuildDisplayItems
)
;
}
void
nsTextFrame
:
:
InvalidateFrameWithRect
(
const
nsRect
&
aRect
uint32_t
aDisplayItemKey
bool
aRebuildDisplayItems
)
{
if
(
nsSVGUtils
:
:
IsInSVGTextSubtree
(
this
)
)
{
nsIFrame
*
svgTextFrame
=
nsLayoutUtils
:
:
GetClosestFrameOfType
(
GetParent
(
)
LayoutFrameType
:
:
SVGText
)
;
svgTextFrame
-
>
InvalidateFrame
(
)
;
return
;
}
nsFrame
:
:
InvalidateFrameWithRect
(
aRect
aDisplayItemKey
aRebuildDisplayItems
)
;
}
gfxTextRun
*
nsTextFrame
:
:
GetUninflatedTextRun
(
)
{
return
GetProperty
(
UninflatedTextRunProperty
(
)
)
;
}
void
nsTextFrame
:
:
SetTextRun
(
gfxTextRun
*
aTextRun
TextRunType
aWhichTextRun
float
aInflation
)
{
NS_ASSERTION
(
aTextRun
"
must
have
text
run
"
)
;
if
(
aWhichTextRun
=
=
eInflated
)
{
if
(
HasFontSizeInflation
(
)
&
&
aInflation
=
=
1
.
0f
)
{
ClearTextRun
(
nullptr
nsTextFrame
:
:
eNotInflated
)
;
}
SetFontSizeInflation
(
aInflation
)
;
}
else
{
MOZ_ASSERT
(
aInflation
=
=
1
.
0f
"
unexpected
inflation
"
)
;
if
(
HasFontSizeInflation
(
)
)
{
aTextRun
-
>
AddRef
(
)
;
SetProperty
(
UninflatedTextRunProperty
(
)
aTextRun
)
;
return
;
}
}
mTextRun
=
aTextRun
;
}
bool
nsTextFrame
:
:
RemoveTextRun
(
gfxTextRun
*
aTextRun
)
{
if
(
aTextRun
=
=
mTextRun
)
{
mTextRun
=
nullptr
;
return
true
;
}
if
(
(
GetStateBits
(
)
&
TEXT_HAS_FONT_INFLATION
)
&
&
GetProperty
(
UninflatedTextRunProperty
(
)
)
=
=
aTextRun
)
{
DeleteProperty
(
UninflatedTextRunProperty
(
)
)
;
return
true
;
}
return
false
;
}
void
nsTextFrame
:
:
ClearTextRun
(
nsTextFrame
*
aStartContinuation
TextRunType
aWhichTextRun
)
{
RefPtr
<
gfxTextRun
>
textRun
=
GetTextRun
(
aWhichTextRun
)
;
if
(
!
textRun
)
{
return
;
}
DebugOnly
<
bool
>
checkmTextrun
=
textRun
=
=
mTextRun
;
UnhookTextRunFromFrames
(
textRun
aStartContinuation
)
;
MOZ_ASSERT
(
checkmTextrun
?
!
mTextRun
:
!
GetProperty
(
UninflatedTextRunProperty
(
)
)
)
;
}
void
nsTextFrame
:
:
DisconnectTextRuns
(
)
{
MOZ_ASSERT
(
!
IsInTextRunUserData
(
)
"
Textrun
mentions
this
frame
in
its
user
data
so
we
can
'
t
just
disconnect
"
)
;
mTextRun
=
nullptr
;
if
(
(
GetStateBits
(
)
&
TEXT_HAS_FONT_INFLATION
)
)
{
DeleteProperty
(
UninflatedTextRunProperty
(
)
)
;
}
}
nsresult
nsTextFrame
:
:
CharacterDataChanged
(
const
CharacterDataChangeInfo
&
aInfo
)
{
if
(
mContent
-
>
HasFlag
(
NS_HAS_NEWLINE_PROPERTY
)
)
{
mContent
-
>
DeleteProperty
(
nsGkAtoms
:
:
newline
)
;
mContent
-
>
UnsetFlags
(
NS_HAS_NEWLINE_PROPERTY
)
;
}
if
(
mContent
-
>
HasFlag
(
NS_HAS_FLOWLENGTH_PROPERTY
)
)
{
mContent
-
>
DeleteProperty
(
nsGkAtoms
:
:
flowlength
)
;
mContent
-
>
UnsetFlags
(
NS_HAS_FLOWLENGTH_PROPERTY
)
;
}
nsTextFrame
*
next
;
nsTextFrame
*
textFrame
=
this
;
while
(
true
)
{
next
=
textFrame
-
>
GetNextContinuation
(
)
;
if
(
!
next
|
|
next
-
>
GetContentOffset
(
)
>
int32_t
(
aInfo
.
mChangeStart
)
)
break
;
textFrame
=
next
;
}
int32_t
endOfChangedText
=
aInfo
.
mChangeStart
+
aInfo
.
mReplaceLength
;
nsIFrame
*
lastDirtiedFrameParent
=
nullptr
;
nsIPresShell
*
shell
=
PresContext
(
)
-
>
GetPresShell
(
)
;
do
{
textFrame
-
>
RemoveStateBits
(
TEXT_WHITESPACE_FLAGS
)
;
textFrame
-
>
ClearTextRuns
(
)
;
nsIFrame
*
parentOfTextFrame
=
textFrame
-
>
GetParent
(
)
;
bool
areAncestorsAwareOfReflowRequest
=
false
;
if
(
lastDirtiedFrameParent
=
=
parentOfTextFrame
)
{
areAncestorsAwareOfReflowRequest
=
true
;
}
else
{
lastDirtiedFrameParent
=
parentOfTextFrame
;
}
if
(
textFrame
-
>
mReflowRequestedForCharDataChange
)
{
MOZ_ASSERT
(
textFrame
-
>
HasAnyStateBits
(
NS_FRAME_IS_DIRTY
)
"
mReflowRequestedForCharDataChange
should
only
be
set
"
"
on
dirty
frames
"
)
;
}
else
{
textFrame
-
>
mReflowRequestedForCharDataChange
=
true
;
if
(
!
areAncestorsAwareOfReflowRequest
)
{
shell
-
>
FrameNeedsReflow
(
textFrame
nsIPresShell
:
:
eStyleChange
NS_FRAME_IS_DIRTY
)
;
}
else
{
textFrame
-
>
AddStateBits
(
NS_FRAME_IS_DIRTY
)
;
}
}
textFrame
-
>
InvalidateFrame
(
)
;
if
(
textFrame
-
>
mContentOffset
>
endOfChangedText
)
{
textFrame
-
>
mContentOffset
=
endOfChangedText
;
}
textFrame
=
textFrame
-
>
GetNextContinuation
(
)
;
}
while
(
textFrame
&
&
textFrame
-
>
GetContentOffset
(
)
<
int32_t
(
aInfo
.
mChangeEnd
)
)
;
int32_t
sizeChange
=
aInfo
.
mChangeStart
+
aInfo
.
mReplaceLength
-
aInfo
.
mChangeEnd
;
if
(
sizeChange
)
{
while
(
textFrame
)
{
textFrame
-
>
mContentOffset
+
=
sizeChange
;
textFrame
-
>
ClearTextRuns
(
)
;
textFrame
=
textFrame
-
>
GetNextContinuation
(
)
;
}
}
return
NS_OK
;
}
class
nsDisplayText
final
:
public
nsCharClipDisplayItem
{
public
:
nsDisplayText
(
nsDisplayListBuilder
*
aBuilder
nsTextFrame
*
aFrame
const
Maybe
<
bool
>
&
aIsSelected
)
;
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayText
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayText
)
;
}
#
endif
virtual
void
RestoreState
(
)
override
{
nsCharClipDisplayItem
:
:
RestoreState
(
)
;
mOpacity
=
1
.
0f
;
}
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
{
*
aSnap
=
false
;
return
mBounds
;
}
virtual
void
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
override
{
if
(
nsRect
(
ToReferenceFrame
(
)
mFrame
-
>
GetSize
(
)
)
.
Intersects
(
aRect
)
)
{
aOutFrames
-
>
AppendElement
(
mFrame
)
;
}
}
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
;
NS_DISPLAY_DECL_NAME
(
"
Text
"
TYPE_TEXT
)
virtual
nsRect
GetComponentAlphaBounds
(
nsDisplayListBuilder
*
aBuilder
)
const
override
{
if
(
gfxPlatform
:
:
GetPlatform
(
)
-
>
RespectsFontStyleSmoothing
(
)
)
{
if
(
mFrame
-
>
StyleFont
(
)
-
>
mFont
.
smoothing
=
=
NS_FONT_SMOOTHING_GRAYSCALE
)
{
return
nsRect
(
)
;
}
}
bool
snap
;
return
GetBounds
(
aBuilder
&
snap
)
;
}
virtual
nsDisplayItemGeometry
*
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
override
;
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
;
void
RenderToContext
(
gfxContext
*
aCtx
nsDisplayListBuilder
*
aBuilder
bool
aIsRecording
=
false
)
;
bool
CanApplyOpacity
(
)
const
override
{
nsTextFrame
*
f
=
static_cast
<
nsTextFrame
*
>
(
mFrame
)
;
if
(
f
-
>
IsSelected
(
)
)
{
return
false
;
}
const
nsStyleText
*
textStyle
=
f
-
>
StyleText
(
)
;
if
(
textStyle
-
>
mTextShadow
)
{
return
false
;
}
nsTextFrame
:
:
TextDecorations
decorations
;
f
-
>
GetTextDecorations
(
f
-
>
PresContext
(
)
nsTextFrame
:
:
eResolvedColors
decorations
)
;
if
(
decorations
.
HasDecorationLines
(
)
)
{
return
false
;
}
return
true
;
}
void
ApplyOpacity
(
nsDisplayListBuilder
*
aBuilder
float
aOpacity
const
DisplayItemClipChain
*
aClip
)
override
{
NS_ASSERTION
(
CanApplyOpacity
(
)
"
ApplyOpacity
should
be
allowed
"
)
;
mOpacity
=
aOpacity
;
IntersectClip
(
aBuilder
aClip
false
)
;
}
void
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
override
{
#
ifdef
DEBUG
aStream
<
<
"
(
\
"
"
;
nsTextFrame
*
f
=
static_cast
<
nsTextFrame
*
>
(
mFrame
)
;
nsCString
buf
;
int32_t
totalContentLength
;
f
-
>
ToCString
(
buf
&
totalContentLength
)
;
aStream
<
<
buf
.
get
(
)
<
<
"
\
"
)
"
;
#
endif
}
nsRect
mBounds
;
float
mOpacity
;
}
;
class
nsDisplayTextGeometry
:
public
nsCharClipGeometry
{
public
:
nsDisplayTextGeometry
(
nsDisplayText
*
aItem
nsDisplayListBuilder
*
aBuilder
)
:
nsCharClipGeometry
(
aItem
aBuilder
)
mOpacity
(
aItem
-
>
mOpacity
)
{
nsTextFrame
*
f
=
static_cast
<
nsTextFrame
*
>
(
aItem
-
>
Frame
(
)
)
;
f
-
>
GetTextDecorations
(
f
-
>
PresContext
(
)
nsTextFrame
:
:
eResolvedColors
mDecorations
)
;
}
nsTextFrame
:
:
TextDecorations
mDecorations
;
float
mOpacity
;
}
;
nsDisplayItemGeometry
*
nsDisplayText
:
:
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
{
return
new
nsDisplayTextGeometry
(
this
aBuilder
)
;
}
void
nsDisplayText
:
:
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
{
const
nsDisplayTextGeometry
*
geometry
=
static_cast
<
const
nsDisplayTextGeometry
*
>
(
aGeometry
)
;
nsTextFrame
*
f
=
static_cast
<
nsTextFrame
*
>
(
mFrame
)
;
nsTextFrame
:
:
TextDecorations
decorations
;
f
-
>
GetTextDecorations
(
f
-
>
PresContext
(
)
nsTextFrame
:
:
eResolvedColors
decorations
)
;
bool
snap
;
nsRect
newRect
=
geometry
-
>
mBounds
;
nsRect
oldRect
=
GetBounds
(
aBuilder
&
snap
)
;
if
(
decorations
!
=
geometry
-
>
mDecorations
|
|
mVisIStartEdge
!
=
geometry
-
>
mVisIStartEdge
|
|
mVisIEndEdge
!
=
geometry
-
>
mVisIEndEdge
|
|
!
oldRect
.
IsEqualInterior
(
newRect
)
|
|
!
geometry
-
>
mBorderRect
.
IsEqualInterior
(
GetBorderRect
(
)
)
|
|
mOpacity
!
=
geometry
-
>
mOpacity
)
{
aInvalidRegion
-
>
Or
(
oldRect
newRect
)
;
}
}
NS_DECLARE_FRAME_PROPERTY_SMALL_VALUE
(
TextCombineScaleFactorProperty
float
)
static
float
GetTextCombineScaleFactor
(
nsTextFrame
*
aFrame
)
{
float
factor
=
aFrame
-
>
GetProperty
(
TextCombineScaleFactorProperty
(
)
)
;
return
factor
?
factor
:
1
.
0f
;
}
nsDisplayText
:
:
nsDisplayText
(
nsDisplayListBuilder
*
aBuilder
nsTextFrame
*
aFrame
const
Maybe
<
bool
>
&
aIsSelected
)
:
nsCharClipDisplayItem
(
aBuilder
aFrame
)
mOpacity
(
1
.
0f
)
{
MOZ_COUNT_CTOR
(
nsDisplayText
)
;
mIsFrameSelected
=
aIsSelected
;
mBounds
=
mFrame
-
>
GetVisualOverflowRectRelativeToSelf
(
)
+
ToReferenceFrame
(
)
;
mBounds
.
Inflate
(
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
}
void
nsDisplayText
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
AUTO_PROFILER_LABEL
(
"
nsDisplayText
:
:
Paint
"
GRAPHICS
)
;
DrawTargetAutoDisableSubpixelAntialiasing
disable
(
aCtx
-
>
GetDrawTarget
(
)
mDisableSubpixelAA
)
;
RenderToContext
(
aCtx
aBuilder
)
;
}
bool
nsDisplayText
:
:
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
if
(
mBounds
.
IsEmpty
(
)
)
{
return
true
;
}
auto
appUnitsPerDevPixel
=
Frame
(
)
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
gfx
:
:
Point
deviceOffset
=
LayoutDevicePoint
:
:
FromAppUnits
(
mBounds
.
TopLeft
(
)
appUnitsPerDevPixel
)
.
ToUnknownPoint
(
)
;
RefPtr
<
TextDrawTarget
>
textDrawer
=
new
TextDrawTarget
(
aBuilder
aSc
aManager
this
mBounds
)
;
RefPtr
<
gfxContext
>
captureCtx
=
gfxContext
:
:
CreateOrNull
(
textDrawer
deviceOffset
)
;
RenderToContext
(
captureCtx
aDisplayListBuilder
true
)
;
return
!
textDrawer
-
>
HasUnsupportedFeatures
(
)
;
}
void
nsDisplayText
:
:
RenderToContext
(
gfxContext
*
aCtx
nsDisplayListBuilder
*
aBuilder
bool
aIsRecording
)
{
nsTextFrame
*
f
=
static_cast
<
nsTextFrame
*
>
(
mFrame
)
;
auto
A2D
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
LayoutDeviceRect
extraVisible
=
LayoutDeviceRect
:
:
FromAppUnits
(
GetPaintRect
(
)
A2D
)
;
extraVisible
.
Inflate
(
1
)
;
gfxRect
pixelVisible
(
extraVisible
.
x
extraVisible
.
y
extraVisible
.
width
extraVisible
.
height
)
;
pixelVisible
.
Inflate
(
2
)
;
pixelVisible
.
RoundOut
(
)
;
bool
willClip
=
!
aBuilder
-
>
IsForGenerateGlyphMask
(
)
&
&
!
aBuilder
-
>
IsForPaintingSelectionBG
(
)
&
&
!
aIsRecording
;
if
(
willClip
)
{
aCtx
-
>
NewPath
(
)
;
aCtx
-
>
Rectangle
(
pixelVisible
)
;
aCtx
-
>
Clip
(
)
;
}
NS_ASSERTION
(
mVisIStartEdge
>
=
0
"
illegal
start
edge
"
)
;
NS_ASSERTION
(
mVisIEndEdge
>
=
0
"
illegal
end
edge
"
)
;
gfxContextMatrixAutoSaveRestore
matrixSR
;
nsPoint
framePt
=
ToReferenceFrame
(
)
;
if
(
f
-
>
Style
(
)
-
>
IsTextCombined
(
)
)
{
float
scaleFactor
=
GetTextCombineScaleFactor
(
f
)
;
if
(
scaleFactor
!
=
1
.
0f
)
{
if
(
auto
*
textDrawer
=
aCtx
-
>
GetTextDrawer
(
)
)
{
textDrawer
-
>
FoundUnsupportedFeature
(
)
;
return
;
}
matrixSR
.
SetContext
(
aCtx
)
;
gfxPoint
pt
=
nsLayoutUtils
:
:
PointToGfxPoint
(
framePt
A2D
)
;
gfxMatrix
mat
=
aCtx
-
>
CurrentMatrixDouble
(
)
.
PreTranslate
(
pt
)
.
PreScale
(
scaleFactor
1
.
0
)
.
PreTranslate
(
-
pt
)
;
aCtx
-
>
SetMatrixDouble
(
mat
)
;
}
}
nsTextFrame
:
:
PaintTextParams
params
(
aCtx
)
;
params
.
framePt
=
gfx
:
:
Point
(
framePt
.
x
framePt
.
y
)
;
params
.
dirtyRect
=
extraVisible
;
if
(
aBuilder
-
>
IsForGenerateGlyphMask
(
)
)
{
MOZ_ASSERT
(
!
aBuilder
-
>
IsForPaintingSelectionBG
(
)
)
;
params
.
state
=
nsTextFrame
:
:
PaintTextParams
:
:
GenerateTextMask
;
}
else
if
(
aBuilder
-
>
IsForPaintingSelectionBG
(
)
)
{
params
.
state
=
nsTextFrame
:
:
PaintTextParams
:
:
PaintTextBGColor
;
}
else
{
params
.
state
=
nsTextFrame
:
:
PaintTextParams
:
:
PaintText
;
}
f
-
>
PaintText
(
params
*
this
mOpacity
)
;
if
(
willClip
)
{
aCtx
-
>
PopClip
(
)
;
}
}
void
nsTextFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
if
(
!
IsVisibleForPainting
(
aBuilder
)
)
return
;
DO_GLOBAL_REFLOW_COUNT_DSP
(
"
nsTextFrame
"
)
;
const
nsStyleText
*
st
=
StyleText
(
)
;
bool
isTextTransparent
=
NS_GET_A
(
st
-
>
mWebkitTextFillColor
.
CalcColor
(
this
)
)
=
=
0
&
&
NS_GET_A
(
st
-
>
mWebkitTextStrokeColor
.
CalcColor
(
this
)
)
=
=
0
;
Maybe
<
bool
>
isSelected
;
if
(
(
(
GetStateBits
(
)
&
TEXT_NO_RENDERED_GLYPHS
)
|
|
(
isTextTransparent
&
&
!
StyleText
(
)
-
>
HasTextShadow
(
)
)
)
&
&
aBuilder
-
>
IsForPainting
(
)
&
&
!
nsSVGUtils
:
:
IsInSVGTextSubtree
(
this
)
)
{
isSelected
.
emplace
(
IsSelected
(
)
)
;
if
(
!
isSelected
.
value
(
)
)
{
TextDecorations
textDecs
;
GetTextDecorations
(
PresContext
(
)
eResolvedColors
textDecs
)
;
if
(
!
textDecs
.
HasDecorationLines
(
)
)
{
return
;
}
}
}
aLists
.
Content
(
)
-
>
AppendToTop
(
MakeDisplayItem
<
nsDisplayText
>
(
aBuilder
this
isSelected
)
)
;
}
static
nsIFrame
*
GetGeneratedContentOwner
(
nsIFrame
*
aFrame
bool
*
aIsBefore
)
{
*
aIsBefore
=
false
;
while
(
aFrame
&
&
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_GENERATED_CONTENT
)
)
{
if
(
aFrame
-
>
Style
(
)
-
>
GetPseudo
(
)
=
=
nsCSSPseudoElements
:
:
before
)
{
*
aIsBefore
=
true
;
}
aFrame
=
aFrame
-
>
GetParent
(
)
;
}
return
aFrame
;
}
UniquePtr
<
SelectionDetails
>
nsTextFrame
:
:
GetSelectionDetails
(
)
{
const
nsFrameSelection
*
frameSelection
=
GetConstFrameSelection
(
)
;
if
(
frameSelection
-
>
GetTableCellSelection
(
)
)
{
return
nullptr
;
}
if
(
!
(
GetStateBits
(
)
&
NS_FRAME_GENERATED_CONTENT
)
)
{
UniquePtr
<
SelectionDetails
>
details
=
frameSelection
-
>
LookUpSelection
(
mContent
GetContentOffset
(
)
GetContentLength
(
)
false
)
;
for
(
SelectionDetails
*
sd
=
details
.
get
(
)
;
sd
;
sd
=
sd
-
>
mNext
.
get
(
)
)
{
sd
-
>
mStart
+
=
mContentOffset
;
sd
-
>
mEnd
+
=
mContentOffset
;
}
return
details
;
}
bool
isBefore
;
nsIFrame
*
owner
=
GetGeneratedContentOwner
(
this
&
isBefore
)
;
if
(
!
owner
|
|
!
owner
-
>
GetContent
(
)
)
return
nullptr
;
UniquePtr
<
SelectionDetails
>
details
=
frameSelection
-
>
LookUpSelection
(
owner
-
>
GetContent
(
)
isBefore
?
0
:
owner
-
>
GetContent
(
)
-
>
GetChildCount
(
)
0
false
)
;
for
(
SelectionDetails
*
sd
=
details
.
get
(
)
;
sd
;
sd
=
sd
-
>
mNext
.
get
(
)
)
{
sd
-
>
mStart
=
GetContentOffset
(
)
;
sd
-
>
mEnd
=
GetContentEnd
(
)
;
}
return
details
;
}
static
void
PaintSelectionBackground
(
DrawTarget
&
aDrawTarget
nscolor
aColor
const
LayoutDeviceRect
&
aDirtyRect
const
LayoutDeviceRect
&
aRect
nsTextFrame
:
:
DrawPathCallbacks
*
aCallbacks
)
{
Rect
rect
=
aRect
.
Intersect
(
aDirtyRect
)
.
ToUnknownRect
(
)
;
MaybeSnapToDevicePixels
(
rect
aDrawTarget
)
;
if
(
aCallbacks
)
{
aCallbacks
-
>
NotifySelectionBackgroundNeedsFill
(
rect
aColor
aDrawTarget
)
;
}
else
{
ColorPattern
color
(
ToDeviceColor
(
aColor
)
)
;
aDrawTarget
.
FillRect
(
rect
color
)
;
}
}
static
nscoord
LazyGetLineBaselineOffset
(
nsIFrame
*
aChildFrame
nsBlockFrame
*
aBlockFrame
)
{
bool
offsetFound
;
nscoord
offset
=
aChildFrame
-
>
GetProperty
(
nsIFrame
:
:
LineBaselineOffset
(
)
&
offsetFound
)
;
if
(
!
offsetFound
)
{
for
(
nsBlockFrame
:
:
LineIterator
line
=
aBlockFrame
-
>
LinesBegin
(
)
line_end
=
aBlockFrame
-
>
LinesEnd
(
)
;
line
!
=
line_end
;
line
+
+
)
{
if
(
line
-
>
IsInline
(
)
)
{
int32_t
n
=
line
-
>
GetChildCount
(
)
;
nscoord
lineBaseline
=
line
-
>
BStart
(
)
+
line
-
>
GetLogicalAscent
(
)
;
for
(
nsIFrame
*
lineFrame
=
line
-
>
mFirstChild
;
n
>
0
;
lineFrame
=
lineFrame
-
>
GetNextSibling
(
)
-
-
n
)
{
offset
=
lineBaseline
-
lineFrame
-
>
GetNormalPosition
(
)
.
y
;
lineFrame
-
>
SetProperty
(
nsIFrame
:
:
LineBaselineOffset
(
)
offset
)
;
}
}
}
return
aChildFrame
-
>
GetProperty
(
nsIFrame
:
:
LineBaselineOffset
(
)
&
offsetFound
)
;
}
else
{
return
offset
;
}
}
static
bool
IsUnderlineRight
(
nsIFrame
*
aFrame
)
{
nsAtom
*
langAtom
=
aFrame
-
>
StyleFont
(
)
-
>
mLanguage
;
if
(
!
langAtom
)
{
return
false
;
}
nsAtomString
langStr
(
langAtom
)
;
return
(
StringBeginsWith
(
langStr
NS_LITERAL_STRING
(
"
ja
"
)
)
|
|
StringBeginsWith
(
langStr
NS_LITERAL_STRING
(
"
ko
"
)
)
)
&
&
(
langStr
.
Length
(
)
=
=
2
|
|
langStr
[
2
]
=
=
'
-
'
)
;
}
void
nsTextFrame
:
:
GetTextDecorations
(
nsPresContext
*
aPresContext
nsTextFrame
:
:
TextDecorationColorResolution
aColorResolution
nsTextFrame
:
:
TextDecorations
&
aDecorations
)
{
const
nsCompatibility
compatMode
=
aPresContext
-
>
CompatibilityMode
(
)
;
bool
useOverride
=
false
;
nscolor
overrideColor
=
NS_RGBA
(
0
0
0
0
)
;
bool
nearestBlockFound
=
false
;
WritingMode
wm
=
GetParent
(
)
-
>
GetWritingMode
(
)
;
bool
vertical
=
wm
.
IsVertical
(
)
;
nscoord
ascent
=
GetLogicalBaseline
(
wm
)
;
nscoord
physicalBlockStartOffset
=
wm
.
IsVerticalRL
(
)
?
GetSize
(
)
.
width
-
ascent
:
ascent
;
nscoord
baselineOffset
=
0
;
for
(
nsIFrame
*
f
=
this
*
fChild
=
nullptr
;
f
;
fChild
=
f
f
=
nsLayoutUtils
:
:
GetParentOrPlaceholderFor
(
f
)
)
{
ComputedStyle
*
const
context
=
f
-
>
Style
(
)
;
if
(
!
context
-
>
HasTextDecorationLines
(
)
)
{
break
;
}
const
nsStyleTextReset
*
const
styleText
=
context
-
>
StyleTextReset
(
)
;
const
uint8_t
textDecorations
=
styleText
-
>
mTextDecorationLine
;
if
(
!
useOverride
&
&
(
NS_STYLE_TEXT_DECORATION_LINE_OVERRIDE_ALL
&
textDecorations
)
)
{
useOverride
=
true
;
overrideColor
=
nsLayoutUtils
:
:
GetColor
(
f
&
nsStyleTextReset
:
:
mTextDecorationColor
)
;
}
nsBlockFrame
*
fBlock
=
nsLayoutUtils
:
:
GetAsBlock
(
f
)
;
const
bool
firstBlock
=
!
nearestBlockFound
&
&
fBlock
;
if
(
firstBlock
)
{
if
(
fChild
-
>
VerticalAlignEnum
(
)
!
=
NS_STYLE_VERTICAL_ALIGN_BASELINE
)
{
const
nscoord
lineBaselineOffset
=
LazyGetLineBaselineOffset
(
fChild
fBlock
)
;
baselineOffset
=
physicalBlockStartOffset
-
lineBaselineOffset
-
(
vertical
?
fChild
-
>
GetNormalPosition
(
)
.
x
:
fChild
-
>
GetNormalPosition
(
)
.
y
)
;
}
}
else
if
(
!
nearestBlockFound
)
{
nscoord
offset
=
wm
.
IsVerticalRL
(
)
?
f
-
>
GetSize
(
)
.
width
-
f
-
>
GetLogicalBaseline
(
wm
)
:
f
-
>
GetLogicalBaseline
(
wm
)
;
baselineOffset
=
physicalBlockStartOffset
-
offset
;
}
nearestBlockFound
=
nearestBlockFound
|
|
firstBlock
;
physicalBlockStartOffset
+
=
vertical
?
f
-
>
GetNormalPosition
(
)
.
x
:
f
-
>
GetNormalPosition
(
)
.
y
;
const
uint8_t
style
=
styleText
-
>
mTextDecorationStyle
;
if
(
textDecorations
)
{
nscolor
color
;
if
(
useOverride
)
{
color
=
overrideColor
;
}
else
if
(
nsSVGUtils
:
:
IsInSVGTextSubtree
(
this
)
)
{
color
=
aColorResolution
=
=
eResolvedColors
?
nsLayoutUtils
:
:
GetColor
(
f
&
nsStyleSVG
:
:
mFill
)
:
NS_SAME_AS_FOREGROUND_COLOR
;
}
else
{
color
=
nsLayoutUtils
:
:
GetColor
(
f
&
nsStyleTextReset
:
:
mTextDecorationColor
)
;
}
bool
swapUnderlineAndOverline
=
vertical
&
&
IsUnderlineRight
(
f
)
;
const
uint8_t
kUnderline
=
swapUnderlineAndOverline
?
NS_STYLE_TEXT_DECORATION_LINE_OVERLINE
:
NS_STYLE_TEXT_DECORATION_LINE_UNDERLINE
;
const
uint8_t
kOverline
=
swapUnderlineAndOverline
?
NS_STYLE_TEXT_DECORATION_LINE_UNDERLINE
:
NS_STYLE_TEXT_DECORATION_LINE_OVERLINE
;
if
(
textDecorations
&
kUnderline
)
{
aDecorations
.
mUnderlines
.
AppendElement
(
nsTextFrame
:
:
LineDecoration
(
f
baselineOffset
color
style
)
)
;
}
if
(
textDecorations
&
kOverline
)
{
aDecorations
.
mOverlines
.
AppendElement
(
nsTextFrame
:
:
LineDecoration
(
f
baselineOffset
color
style
)
)
;
}
if
(
textDecorations
&
NS_STYLE_TEXT_DECORATION_LINE_LINE_THROUGH
)
{
aDecorations
.
mStrikes
.
AppendElement
(
nsTextFrame
:
:
LineDecoration
(
f
baselineOffset
color
style
)
)
;
}
}
mozilla
:
:
StyleDisplay
display
=
f
-
>
GetDisplay
(
)
;
if
(
display
!
=
mozilla
:
:
StyleDisplay
:
:
Inline
&
&
(
!
nsStyleDisplay
:
:
IsRubyDisplayType
(
display
)
|
|
display
=
=
mozilla
:
:
StyleDisplay
:
:
RubyTextContainer
)
&
&
nsStyleDisplay
:
:
IsDisplayTypeInlineOutside
(
display
)
)
{
break
;
}
if
(
compatMode
=
=
eCompatibility_NavQuirks
&
&
f
-
>
GetContent
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
table
)
)
{
break
;
}
if
(
f
-
>
IsFloating
(
)
|
|
f
-
>
IsAbsolutelyPositioned
(
)
)
{
break
;
}
if
(
f
-
>
IsSVGOuterSVGFrame
(
)
)
{
break
;
}
}
}
static
float
GetInflationForTextDecorations
(
nsIFrame
*
aFrame
nscoord
aInflationMinFontSize
)
{
if
(
nsSVGUtils
:
:
IsInSVGTextSubtree
(
aFrame
)
)
{
const
nsIFrame
*
container
=
aFrame
;
while
(
!
container
-
>
IsSVGTextFrame
(
)
)
{
container
=
container
-
>
GetParent
(
)
;
}
NS_ASSERTION
(
container
"
expected
to
find
an
ancestor
SVGTextFrame
"
)
;
return
static_cast
<
const
SVGTextFrame
*
>
(
container
)
-
>
GetFontSizeScaleFactor
(
)
;
}
return
nsLayoutUtils
:
:
FontSizeInflationInner
(
aFrame
aInflationMinFontSize
)
;
}
struct
EmphasisMarkInfo
{
RefPtr
<
gfxTextRun
>
textRun
;
gfxFloat
advance
;
gfxFloat
baselineOffset
;
}
;
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
EmphasisMarkProperty
EmphasisMarkInfo
)
static
already_AddRefed
<
gfxTextRun
>
GenerateTextRunForEmphasisMarks
(
nsTextFrame
*
aFrame
nsFontMetrics
*
aFontMetrics
ComputedStyle
*
aComputedStyle
const
nsStyleText
*
aStyleText
)
{
const
nsString
&
emphasisString
=
aStyleText
-
>
mTextEmphasisStyleString
;
RefPtr
<
DrawTarget
>
dt
=
CreateReferenceDrawTarget
(
aFrame
)
;
auto
appUnitsPerDevUnit
=
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
gfx
:
:
ShapedTextFlags
flags
=
nsLayoutUtils
:
:
GetTextRunOrientFlagsForStyle
(
aComputedStyle
)
;
if
(
flags
=
=
gfx
:
:
ShapedTextFlags
:
:
TEXT_ORIENT_VERTICAL_MIXED
)
{
flags
=
gfx
:
:
ShapedTextFlags
:
:
TEXT_ORIENT_VERTICAL_UPRIGHT
;
}
return
aFontMetrics
-
>
GetThebesFontGroup
(
)
-
>
MakeTextRun
<
char16_t
>
(
emphasisString
.
get
(
)
emphasisString
.
Length
(
)
dt
appUnitsPerDevUnit
flags
nsTextFrameUtils
:
:
Flags
(
)
nullptr
)
;
}
static
nsRubyFrame
*
FindFurthestInlineRubyAncestor
(
nsTextFrame
*
aFrame
)
{
nsRubyFrame
*
rubyFrame
=
nullptr
;
for
(
nsIFrame
*
frame
=
aFrame
-
>
GetParent
(
)
;
frame
&
&
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eLineParticipant
)
;
frame
=
frame
-
>
GetParent
(
)
)
{
if
(
frame
-
>
IsRubyFrame
(
)
)
{
rubyFrame
=
static_cast
<
nsRubyFrame
*
>
(
frame
)
;
}
}
return
rubyFrame
;
}
nsRect
nsTextFrame
:
:
UpdateTextEmphasis
(
WritingMode
aWM
PropertyProvider
&
aProvider
)
{
const
nsStyleText
*
styleText
=
StyleText
(
)
;
if
(
!
styleText
-
>
HasTextEmphasis
(
)
)
{
DeleteProperty
(
EmphasisMarkProperty
(
)
)
;
return
nsRect
(
)
;
}
ComputedStyle
*
computedStyle
=
Style
(
)
;
bool
isTextCombined
=
computedStyle
-
>
IsTextCombined
(
)
;
if
(
isTextCombined
)
{
computedStyle
=
GetParent
(
)
-
>
Style
(
)
;
}
RefPtr
<
nsFontMetrics
>
fm
=
nsLayoutUtils
:
:
GetFontMetricsOfEmphasisMarks
(
computedStyle
PresContext
(
)
GetFontSizeInflation
(
)
)
;
EmphasisMarkInfo
*
info
=
new
EmphasisMarkInfo
;
info
-
>
textRun
=
GenerateTextRunForEmphasisMarks
(
this
fm
computedStyle
styleText
)
;
info
-
>
advance
=
info
-
>
textRun
-
>
GetAdvanceWidth
(
)
;
LogicalSide
side
=
styleText
-
>
TextEmphasisSide
(
aWM
)
;
LogicalSize
frameSize
=
GetLogicalSize
(
aWM
)
;
LogicalRect
overflowRect
(
aWM
-
info
-
>
advance
/
2
0
frameSize
.
ISize
(
aWM
)
+
info
-
>
advance
fm
-
>
MaxAscent
(
)
+
fm
-
>
MaxDescent
(
)
)
;
RefPtr
<
nsFontMetrics
>
baseFontMetrics
=
isTextCombined
?
nsLayoutUtils
:
:
GetInflatedFontMetricsForFrame
(
GetParent
(
)
)
:
do_AddRef
(
aProvider
.
GetFontMetrics
(
)
)
;
nscoord
absOffset
=
(
side
=
=
eLogicalSideBStart
)
!
=
aWM
.
IsLineInverted
(
)
?
baseFontMetrics
-
>
MaxAscent
(
)
+
fm
-
>
MaxDescent
(
)
:
baseFontMetrics
-
>
MaxDescent
(
)
+
fm
-
>
MaxAscent
(
)
;
RubyBlockLeadings
leadings
;
if
(
nsRubyFrame
*
ruby
=
FindFurthestInlineRubyAncestor
(
this
)
)
{
leadings
=
ruby
-
>
GetBlockLeadings
(
)
;
}
if
(
side
=
=
eLogicalSideBStart
)
{
info
-
>
baselineOffset
=
-
absOffset
-
leadings
.
mStart
;
overflowRect
.
BStart
(
aWM
)
=
-
overflowRect
.
BSize
(
aWM
)
-
leadings
.
mStart
;
}
else
{
MOZ_ASSERT
(
side
=
=
eLogicalSideBEnd
)
;
info
-
>
baselineOffset
=
absOffset
+
leadings
.
mEnd
;
overflowRect
.
BStart
(
aWM
)
=
frameSize
.
BSize
(
aWM
)
+
leadings
.
mEnd
;
}
if
(
isTextCombined
)
{
nscoord
gap
=
(
baseFontMetrics
-
>
MaxHeight
(
)
-
frameSize
.
BSize
(
aWM
)
)
/
2
;
overflowRect
.
BStart
(
aWM
)
+
=
gap
*
(
side
=
=
eLogicalSideBStart
?
-
1
:
1
)
;
}
SetProperty
(
EmphasisMarkProperty
(
)
info
)
;
return
overflowRect
.
GetPhysicalRect
(
aWM
frameSize
.
GetPhysicalSize
(
aWM
)
)
;
}
void
nsTextFrame
:
:
UnionAdditionalOverflow
(
nsPresContext
*
aPresContext
nsIFrame
*
aBlock
PropertyProvider
&
aProvider
nsRect
*
aVisualOverflowRect
bool
aIncludeTextDecorations
)
{
const
WritingMode
wm
=
GetWritingMode
(
)
;
bool
verticalRun
=
mTextRun
-
>
IsVertical
(
)
;
const
gfxFloat
appUnitsPerDevUnit
=
aPresContext
-
>
AppUnitsPerDevPixel
(
)
;
if
(
IsFloatingFirstLetterChild
(
)
)
{
bool
inverted
=
wm
.
IsLineInverted
(
)
;
uint8_t
decorationStyle
=
aBlock
-
>
Style
(
)
-
>
StyleTextReset
(
)
-
>
mTextDecorationStyle
;
if
(
decorationStyle
=
=
NS_STYLE_TEXT_DECORATION_STYLE_NONE
)
{
decorationStyle
=
NS_STYLE_TEXT_DECORATION_STYLE_SOLID
;
}
nsFontMetrics
*
fontMetrics
=
aProvider
.
GetFontMetrics
(
)
;
nscoord
underlineOffset
underlineSize
;
fontMetrics
-
>
GetUnderline
(
underlineOffset
underlineSize
)
;
nscoord
maxAscent
=
inverted
?
fontMetrics
-
>
MaxDescent
(
)
:
fontMetrics
-
>
MaxAscent
(
)
;
nsCSSRendering
:
:
DecorationRectParams
params
;
Float
gfxWidth
=
(
verticalRun
?
aVisualOverflowRect
-
>
height
:
aVisualOverflowRect
-
>
width
)
/
appUnitsPerDevUnit
;
params
.
lineSize
=
Size
(
gfxWidth
underlineSize
/
appUnitsPerDevUnit
)
;
params
.
ascent
=
gfxFloat
(
mAscent
)
/
appUnitsPerDevUnit
;
params
.
style
=
decorationStyle
;
params
.
vertical
=
verticalRun
;
params
.
sidewaysLeft
=
mTextRun
-
>
IsSidewaysLeft
(
)
;
params
.
offset
=
underlineOffset
/
appUnitsPerDevUnit
;
params
.
decoration
=
NS_STYLE_TEXT_DECORATION_LINE_UNDERLINE
;
nsRect
underlineRect
=
nsCSSRendering
:
:
GetTextDecorationRect
(
aPresContext
params
)
;
params
.
offset
=
maxAscent
/
appUnitsPerDevUnit
;
params
.
decoration
=
NS_STYLE_TEXT_DECORATION_LINE_OVERLINE
;
nsRect
overlineRect
=
nsCSSRendering
:
:
GetTextDecorationRect
(
aPresContext
params
)
;
aVisualOverflowRect
-
>
UnionRect
(
*
aVisualOverflowRect
underlineRect
)
;
aVisualOverflowRect
-
>
UnionRect
(
*
aVisualOverflowRect
overlineRect
)
;
}
if
(
aIncludeTextDecorations
)
{
WritingMode
parentWM
=
GetParent
(
)
-
>
GetWritingMode
(
)
;
bool
verticalDec
=
parentWM
.
IsVertical
(
)
;
bool
useVerticalMetrics
=
verticalDec
!
=
verticalRun
?
verticalDec
:
verticalRun
&
&
mTextRun
-
>
UseCenterBaseline
(
)
;
TextDecorations
textDecs
;
GetTextDecorations
(
aPresContext
eResolvedColors
textDecs
)
;
if
(
textDecs
.
HasDecorationLines
(
)
)
{
nscoord
inflationMinFontSize
=
nsLayoutUtils
:
:
InflationMinFontSizeFor
(
aBlock
)
;
const
nscoord
measure
=
verticalDec
?
GetSize
(
)
.
height
:
GetSize
(
)
.
width
;
gfxFloat
gfxWidth
=
measure
/
appUnitsPerDevUnit
;
gfxFloat
ascent
=
gfxFloat
(
GetLogicalBaseline
(
parentWM
)
)
/
appUnitsPerDevUnit
;
nscoord
frameBStart
=
0
;
if
(
parentWM
.
IsVerticalRL
(
)
)
{
frameBStart
=
GetSize
(
)
.
width
;
ascent
=
-
ascent
;
}
nsCSSRendering
:
:
DecorationRectParams
params
;
params
.
lineSize
=
Size
(
gfxWidth
0
)
;
params
.
ascent
=
ascent
;
params
.
vertical
=
verticalDec
;
params
.
sidewaysLeft
=
mTextRun
-
>
IsSidewaysLeft
(
)
;
nscoord
topOrLeft
(
nscoord_MAX
)
bottomOrRight
(
nscoord_MIN
)
;
typedef
gfxFont
:
:
Metrics
Metrics
;
auto
accumulateDecorationRect
=
[
&
]
(
const
LineDecoration
&
dec
gfxFloat
Metrics
:
:
*
lineSize
gfxFloat
Metrics
:
:
*
lineOffset
)
{
params
.
style
=
dec
.
mStyle
;
if
(
params
.
style
=
=
NS_STYLE_TEXT_DECORATION_STYLE_NONE
)
{
params
.
style
=
NS_STYLE_TEXT_DECORATION_STYLE_SOLID
;
}
float
inflation
=
GetInflationForTextDecorations
(
dec
.
mFrame
inflationMinFontSize
)
;
const
Metrics
metrics
=
GetFirstFontMetrics
(
GetFontGroupForFrame
(
dec
.
mFrame
inflation
)
useVerticalMetrics
)
;
params
.
lineSize
.
height
=
metrics
.
*
lineSize
;
params
.
offset
=
metrics
.
*
lineOffset
;
const
nsRect
decorationRect
=
nsCSSRendering
:
:
GetTextDecorationRect
(
aPresContext
params
)
+
(
verticalDec
?
nsPoint
(
frameBStart
-
dec
.
mBaselineOffset
0
)
:
nsPoint
(
0
-
dec
.
mBaselineOffset
)
)
;
if
(
verticalDec
)
{
topOrLeft
=
std
:
:
min
(
decorationRect
.
x
topOrLeft
)
;
bottomOrRight
=
std
:
:
max
(
decorationRect
.
XMost
(
)
bottomOrRight
)
;
}
else
{
topOrLeft
=
std
:
:
min
(
decorationRect
.
y
topOrLeft
)
;
bottomOrRight
=
std
:
:
max
(
decorationRect
.
YMost
(
)
bottomOrRight
)
;
}
}
;
params
.
decoration
=
NS_STYLE_TEXT_DECORATION_LINE_UNDERLINE
;
for
(
const
LineDecoration
&
dec
:
textDecs
.
mUnderlines
)
{
accumulateDecorationRect
(
dec
&
Metrics
:
:
underlineSize
&
Metrics
:
:
underlineOffset
)
;
}
params
.
decoration
=
NS_STYLE_TEXT_DECORATION_LINE_OVERLINE
;
for
(
const
LineDecoration
&
dec
:
textDecs
.
mOverlines
)
{
accumulateDecorationRect
(
dec
&
Metrics
:
:
underlineSize
&
Metrics
:
:
maxAscent
)
;
}
params
.
decoration
=
NS_STYLE_TEXT_DECORATION_LINE_LINE_THROUGH
;
for
(
const
LineDecoration
&
dec
:
textDecs
.
mStrikes
)
{
accumulateDecorationRect
(
dec
&
Metrics
:
:
strikeoutSize
&
Metrics
:
:
strikeoutOffset
)
;
}
aVisualOverflowRect
-
>
UnionRect
(
*
aVisualOverflowRect
verticalDec
?
nsRect
(
topOrLeft
0
bottomOrRight
-
topOrLeft
measure
)
:
nsRect
(
0
topOrLeft
measure
bottomOrRight
-
topOrLeft
)
)
;
}
aVisualOverflowRect
-
>
UnionRect
(
*
aVisualOverflowRect
UpdateTextEmphasis
(
parentWM
aProvider
)
)
;
}
nscoord
textStrokeWidth
=
StyleText
(
)
-
>
mWebkitTextStrokeWidth
;
if
(
textStrokeWidth
>
0
)
{
nsRect
strokeRect
=
*
aVisualOverflowRect
;
strokeRect
.
Inflate
(
textStrokeWidth
/
2
+
appUnitsPerDevUnit
)
;
aVisualOverflowRect
-
>
UnionRect
(
*
aVisualOverflowRect
strokeRect
)
;
}
nsRect
shadowRect
=
nsLayoutUtils
:
:
GetTextShadowRectsUnion
(
*
aVisualOverflowRect
this
)
;
aVisualOverflowRect
-
>
UnionRect
(
*
aVisualOverflowRect
shadowRect
)
;
if
(
!
IsSelected
(
)
|
|
!
CombineSelectionUnderlineRect
(
aPresContext
*
aVisualOverflowRect
)
)
return
;
AddStateBits
(
TEXT_SELECTION_UNDERLINE_OVERFLOWED
)
;
}
gfxFloat
nsTextFrame
:
:
ComputeDescentLimitForSelectionUnderline
(
nsPresContext
*
aPresContext
const
gfxFont
:
:
Metrics
&
aFontMetrics
)
{
gfxFloat
app
=
aPresContext
-
>
AppUnitsPerDevPixel
(
)
;
nscoord
lineHeightApp
=
ReflowInput
:
:
CalcLineHeight
(
GetContent
(
)
Style
(
)
PresContext
(
)
NS_AUTOHEIGHT
GetFontSizeInflation
(
)
)
;
gfxFloat
lineHeight
=
gfxFloat
(
lineHeightApp
)
/
app
;
if
(
lineHeight
<
=
aFontMetrics
.
maxHeight
)
{
return
aFontMetrics
.
maxDescent
;
}
return
aFontMetrics
.
maxDescent
+
(
lineHeight
-
aFontMetrics
.
maxHeight
)
/
2
;
}
static
const
SelectionTypeMask
kSelectionTypesWithDecorations
=
ToSelectionTypeMask
(
SelectionType
:
:
eSpellCheck
)
|
ToSelectionTypeMask
(
SelectionType
:
:
eURLStrikeout
)
|
ToSelectionTypeMask
(
SelectionType
:
:
eIMERawClause
)
|
ToSelectionTypeMask
(
SelectionType
:
:
eIMESelectedRawClause
)
|
ToSelectionTypeMask
(
SelectionType
:
:
eIMEConvertedClause
)
|
ToSelectionTypeMask
(
SelectionType
:
:
eIMESelectedClause
)
;
gfxFloat
nsTextFrame
:
:
ComputeSelectionUnderlineHeight
(
nsPresContext
*
aPresContext
const
gfxFont
:
:
Metrics
&
aFontMetrics
SelectionType
aSelectionType
)
{
switch
(
aSelectionType
)
{
case
SelectionType
:
:
eIMERawClause
:
case
SelectionType
:
:
eIMESelectedRawClause
:
case
SelectionType
:
:
eIMEConvertedClause
:
case
SelectionType
:
:
eIMESelectedClause
:
return
aFontMetrics
.
underlineSize
;
case
SelectionType
:
:
eSpellCheck
:
{
nscoord
defaultFontSize
=
aPresContext
-
>
GetDefaultFont
(
kPresContext_DefaultVariableFont_ID
nullptr
)
-
>
size
;
int32_t
zoomedFontSize
=
aPresContext
-
>
AppUnitsToDevPixels
(
nsStyleFont
:
:
ZoomText
(
aPresContext
defaultFontSize
)
)
;
gfxFloat
fontSize
=
std
:
:
min
(
gfxFloat
(
zoomedFontSize
)
aFontMetrics
.
emHeight
)
;
fontSize
=
std
:
:
max
(
fontSize
1
.
0
)
;
return
ceil
(
fontSize
/
20
)
;
}
default
:
NS_WARNING
(
"
Requested
underline
style
is
not
valid
"
)
;
return
aFontMetrics
.
underlineSize
;
}
}
enum
class
DecorationType
{
Normal
Selection
}
;
struct
nsTextFrame
:
:
PaintDecorationLineParams
:
nsCSSRendering
:
:
DecorationRectParams
{
gfxContext
*
context
=
nullptr
;
LayoutDeviceRect
dirtyRect
;
Point
pt
;
const
nscolor
*
overrideColor
=
nullptr
;
nscolor
color
=
NS_RGBA
(
0
0
0
0
)
;
gfxFloat
icoordInFrame
=
0
.
0f
;
DecorationType
decorationType
=
DecorationType
:
:
Normal
;
DrawPathCallbacks
*
callbacks
=
nullptr
;
}
;
void
nsTextFrame
:
:
PaintDecorationLine
(
const
PaintDecorationLineParams
&
aParams
)
{
nsCSSRendering
:
:
PaintDecorationLineParams
params
;
static_cast
<
nsCSSRendering
:
:
DecorationRectParams
&
>
(
params
)
=
aParams
;
params
.
dirtyRect
=
aParams
.
dirtyRect
.
ToUnknownRect
(
)
;
params
.
pt
=
aParams
.
pt
;
params
.
color
=
aParams
.
overrideColor
?
*
aParams
.
overrideColor
:
aParams
.
color
;
params
.
icoordInFrame
=
Float
(
aParams
.
icoordInFrame
)
;
if
(
aParams
.
callbacks
)
{
Rect
path
=
nsCSSRendering
:
:
DecorationLineToPath
(
params
)
;
if
(
aParams
.
decorationType
=
=
DecorationType
:
:
Normal
)
{
aParams
.
callbacks
-
>
PaintDecorationLine
(
path
params
.
color
)
;
}
else
{
aParams
.
callbacks
-
>
PaintSelectionDecorationLine
(
path
params
.
color
)
;
}
}
else
{
nsCSSRendering
:
:
PaintDecorationLine
(
this
*
aParams
.
context
-
>
GetDrawTarget
(
)
params
)
;
}
}
void
nsTextFrame
:
:
DrawSelectionDecorations
(
gfxContext
*
aContext
const
LayoutDeviceRect
&
aDirtyRect
SelectionType
aSelectionType
nsTextPaintStyle
&
aTextPaintStyle
const
TextRangeStyle
&
aRangeStyle
const
Point
&
aPt
gfxFloat
aICoordInFrame
gfxFloat
aWidth
gfxFloat
aAscent
const
gfxFont
:
:
Metrics
&
aFontMetrics
DrawPathCallbacks
*
aCallbacks
bool
aVertical
uint8_t
aDecoration
)
{
PaintDecorationLineParams
params
;
params
.
context
=
aContext
;
params
.
dirtyRect
=
aDirtyRect
;
params
.
pt
=
aPt
;
params
.
lineSize
.
width
=
aWidth
;
params
.
ascent
=
aAscent
;
params
.
offset
=
aDecoration
=
=
NS_STYLE_TEXT_DECORATION_LINE_UNDERLINE
?
aFontMetrics
.
underlineOffset
:
aFontMetrics
.
maxAscent
;
params
.
decoration
=
aDecoration
;
params
.
decorationType
=
DecorationType
:
:
Selection
;
params
.
callbacks
=
aCallbacks
;
params
.
vertical
=
aVertical
;
params
.
sidewaysLeft
=
mTextRun
-
>
IsSidewaysLeft
(
)
;
params
.
descentLimit
=
ComputeDescentLimitForSelectionUnderline
(
aTextPaintStyle
.
PresContext
(
)
aFontMetrics
)
;
float
relativeSize
;
switch
(
aSelectionType
)
{
case
SelectionType
:
:
eIMERawClause
:
case
SelectionType
:
:
eIMESelectedRawClause
:
case
SelectionType
:
:
eIMEConvertedClause
:
case
SelectionType
:
:
eIMESelectedClause
:
case
SelectionType
:
:
eSpellCheck
:
{
int32_t
index
=
nsTextPaintStyle
:
:
GetUnderlineStyleIndexForSelectionType
(
aSelectionType
)
;
bool
weDefineSelectionUnderline
=
aTextPaintStyle
.
GetSelectionUnderlineForPaint
(
index
&
params
.
color
&
relativeSize
&
params
.
style
)
;
params
.
lineSize
.
height
=
ComputeSelectionUnderlineHeight
(
aTextPaintStyle
.
PresContext
(
)
aFontMetrics
aSelectionType
)
;
bool
isIMEType
=
aSelectionType
!
=
SelectionType
:
:
eSpellCheck
;
if
(
isIMEType
)
{
params
.
pt
.
x
+
=
1
.
0
;
params
.
lineSize
.
width
-
=
2
.
0
;
}
if
(
isIMEType
&
&
aRangeStyle
.
IsDefined
(
)
)
{
if
(
aRangeStyle
.
IsLineStyleDefined
(
)
)
{
if
(
aRangeStyle
.
mLineStyle
=
=
TextRangeStyle
:
:
LINESTYLE_NONE
)
{
return
;
}
params
.
style
=
aRangeStyle
.
mLineStyle
;
relativeSize
=
aRangeStyle
.
mIsBoldLine
?
2
.
0f
:
1
.
0f
;
}
else
if
(
!
weDefineSelectionUnderline
)
{
return
;
}
if
(
aRangeStyle
.
IsUnderlineColorDefined
(
)
&
&
(
!
aRangeStyle
.
IsForegroundColorDefined
(
)
|
|
aRangeStyle
.
mUnderlineColor
!
=
aRangeStyle
.
mForegroundColor
)
)
{
params
.
color
=
aRangeStyle
.
mUnderlineColor
;
}
else
if
(
aRangeStyle
.
IsForegroundColorDefined
(
)
|
|
aRangeStyle
.
IsBackgroundColorDefined
(
)
)
{
nscolor
bg
;
GetSelectionTextColors
(
aSelectionType
aTextPaintStyle
aRangeStyle
&
params
.
color
&
bg
)
;
}
else
{
params
.
color
=
aTextPaintStyle
.
GetTextColor
(
)
;
}
}
else
if
(
!
weDefineSelectionUnderline
)
{
return
;
}
break
;
}
case
SelectionType
:
:
eURLStrikeout
:
{
nscoord
inflationMinFontSize
=
nsLayoutUtils
:
:
InflationMinFontSizeFor
(
this
)
;
float
inflation
=
GetInflationForTextDecorations
(
this
inflationMinFontSize
)
;
const
gfxFont
:
:
Metrics
metrics
=
GetFirstFontMetrics
(
GetFontGroupForFrame
(
this
inflation
)
aVertical
)
;
relativeSize
=
2
.
0f
;
aTextPaintStyle
.
GetURLSecondaryColor
(
&
params
.
color
)
;
params
.
style
=
NS_STYLE_TEXT_DECORATION_STYLE_SOLID
;
params
.
lineSize
.
height
=
metrics
.
strikeoutSize
;
params
.
offset
=
metrics
.
strikeoutOffset
+
0
.
5
;
params
.
decoration
=
NS_STYLE_TEXT_DECORATION_LINE_LINE_THROUGH
;
break
;
}
default
:
NS_WARNING
(
"
Requested
selection
decorations
when
there
aren
'
t
any
"
)
;
return
;
}
params
.
lineSize
.
height
*
=
relativeSize
;
params
.
icoordInFrame
=
(
aVertical
?
params
.
pt
.
y
-
aPt
.
y
:
params
.
pt
.
x
-
aPt
.
x
)
+
aICoordInFrame
;
PaintDecorationLine
(
params
)
;
}
bool
nsTextFrame
:
:
GetSelectionTextColors
(
SelectionType
aSelectionType
nsTextPaintStyle
&
aTextPaintStyle
const
TextRangeStyle
&
aRangeStyle
nscolor
*
aForeground
nscolor
*
aBackground
)
{
switch
(
aSelectionType
)
{
case
SelectionType
:
:
eNormal
:
return
aTextPaintStyle
.
GetSelectionColors
(
aForeground
aBackground
)
;
case
SelectionType
:
:
eFind
:
aTextPaintStyle
.
GetHighlightColors
(
aForeground
aBackground
)
;
return
true
;
case
SelectionType
:
:
eURLSecondary
:
aTextPaintStyle
.
GetURLSecondaryColor
(
aForeground
)
;
*
aBackground
=
NS_RGBA
(
0
0
0
0
)
;
return
true
;
case
SelectionType
:
:
eIMERawClause
:
case
SelectionType
:
:
eIMESelectedRawClause
:
case
SelectionType
:
:
eIMEConvertedClause
:
case
SelectionType
:
:
eIMESelectedClause
:
if
(
aRangeStyle
.
IsDefined
(
)
)
{
if
(
!
aRangeStyle
.
IsForegroundColorDefined
(
)
&
&
!
aRangeStyle
.
IsBackgroundColorDefined
(
)
)
{
*
aForeground
=
aTextPaintStyle
.
GetTextColor
(
)
;
*
aBackground
=
NS_RGBA
(
0
0
0
0
)
;
return
false
;
}
if
(
aRangeStyle
.
IsForegroundColorDefined
(
)
)
{
*
aForeground
=
aRangeStyle
.
mForegroundColor
;
if
(
aRangeStyle
.
IsBackgroundColorDefined
(
)
)
{
*
aBackground
=
aRangeStyle
.
mBackgroundColor
;
}
else
{
*
aBackground
=
aTextPaintStyle
.
GetSystemFieldBackgroundColor
(
)
;
}
}
else
{
*
aBackground
=
aRangeStyle
.
mBackgroundColor
;
*
aForeground
=
aTextPaintStyle
.
GetSystemFieldForegroundColor
(
)
;
}
return
true
;
}
aTextPaintStyle
.
GetIMESelectionColors
(
nsTextPaintStyle
:
:
GetUnderlineStyleIndexForSelectionType
(
aSelectionType
)
aForeground
aBackground
)
;
return
true
;
default
:
*
aForeground
=
aTextPaintStyle
.
GetTextColor
(
)
;
*
aBackground
=
NS_RGBA
(
0
0
0
0
)
;
return
false
;
}
}
static
bool
GetSelectionTextShadow
(
nsIFrame
*
aFrame
SelectionType
aSelectionType
nsTextPaintStyle
&
aTextPaintStyle
nsCSSShadowArray
*
*
aShadow
)
{
switch
(
aSelectionType
)
{
case
SelectionType
:
:
eNormal
:
return
aTextPaintStyle
.
GetSelectionShadow
(
aShadow
)
;
default
:
return
false
;
}
}
class
SelectionIterator
{
public
:
SelectionIterator
(
SelectionDetails
*
*
aSelectionDetails
gfxTextRun
:
:
Range
aRange
PropertyProvider
&
aProvider
gfxTextRun
*
aTextRun
gfxFloat
aXOffset
)
;
bool
GetNextSegment
(
gfxFloat
*
aXOffset
gfxTextRun
:
:
Range
*
aRange
gfxFloat
*
aHyphenWidth
SelectionType
*
aSelectionType
TextRangeStyle
*
aStyle
)
;
void
UpdateWithAdvance
(
gfxFloat
aAdvance
)
{
mXOffset
+
=
aAdvance
*
mTextRun
-
>
GetDirection
(
)
;
}
private
:
SelectionDetails
*
*
mSelectionDetails
;
PropertyProvider
&
mProvider
;
RefPtr
<
gfxTextRun
>
mTextRun
;
gfxSkipCharsIterator
mIterator
;
gfxTextRun
:
:
Range
mOriginalRange
;
gfxFloat
mXOffset
;
}
;
SelectionIterator
:
:
SelectionIterator
(
SelectionDetails
*
*
aSelectionDetails
gfxTextRun
:
:
Range
aRange
PropertyProvider
&
aProvider
gfxTextRun
*
aTextRun
gfxFloat
aXOffset
)
:
mSelectionDetails
(
aSelectionDetails
)
mProvider
(
aProvider
)
mTextRun
(
aTextRun
)
mIterator
(
aProvider
.
GetStart
(
)
)
mOriginalRange
(
aRange
)
mXOffset
(
aXOffset
)
{
mIterator
.
SetOriginalOffset
(
aRange
.
start
)
;
}
bool
SelectionIterator
:
:
GetNextSegment
(
gfxFloat
*
aXOffset
gfxTextRun
:
:
Range
*
aRange
gfxFloat
*
aHyphenWidth
SelectionType
*
aSelectionType
TextRangeStyle
*
aStyle
)
{
if
(
mIterator
.
GetOriginalOffset
(
)
>
=
int32_t
(
mOriginalRange
.
end
)
)
return
false
;
uint32_t
runOffset
=
mIterator
.
GetSkippedOffset
(
)
;
uint32_t
index
=
mIterator
.
GetOriginalOffset
(
)
-
mOriginalRange
.
start
;
SelectionDetails
*
sdptr
=
mSelectionDetails
[
index
]
;
SelectionType
selectionType
=
sdptr
?
sdptr
-
>
mSelectionType
:
SelectionType
:
:
eNone
;
TextRangeStyle
style
;
if
(
sdptr
)
{
style
=
sdptr
-
>
mTextRangeStyle
;
}
for
(
+
+
index
;
index
<
mOriginalRange
.
Length
(
)
;
+
+
index
)
{
if
(
sdptr
!
=
mSelectionDetails
[
index
]
)
break
;
}
mIterator
.
SetOriginalOffset
(
index
+
mOriginalRange
.
start
)
;
while
(
mIterator
.
GetOriginalOffset
(
)
<
int32_t
(
mOriginalRange
.
end
)
&
&
!
mIterator
.
IsOriginalCharSkipped
(
)
&
&
!
mTextRun
-
>
IsClusterStart
(
mIterator
.
GetSkippedOffset
(
)
)
)
{
mIterator
.
AdvanceOriginal
(
1
)
;
}
bool
haveHyphenBreak
=
(
mProvider
.
GetFrame
(
)
-
>
GetStateBits
(
)
&
TEXT_HYPHEN_BREAK
)
!
=
0
;
aRange
-
>
start
=
runOffset
;
aRange
-
>
end
=
mIterator
.
GetSkippedOffset
(
)
;
*
aXOffset
=
mXOffset
;
*
aHyphenWidth
=
0
;
if
(
mIterator
.
GetOriginalOffset
(
)
=
=
int32_t
(
mOriginalRange
.
end
)
&
&
haveHyphenBreak
)
{
*
aHyphenWidth
=
mProvider
.
GetHyphenWidth
(
)
;
}
*
aSelectionType
=
selectionType
;
*
aStyle
=
style
;
return
true
;
}
static
void
AddHyphenToMetrics
(
nsTextFrame
*
aTextFrame
const
gfxTextRun
*
aBaseTextRun
gfxTextRun
:
:
Metrics
*
aMetrics
gfxFont
:
:
BoundingBoxType
aBoundingBoxType
DrawTarget
*
aDrawTarget
)
{
RefPtr
<
gfxTextRun
>
hyphenTextRun
=
GetHyphenTextRun
(
aBaseTextRun
aDrawTarget
aTextFrame
)
;
if
(
!
hyphenTextRun
)
{
return
;
}
gfxTextRun
:
:
Metrics
hyphenMetrics
=
hyphenTextRun
-
>
MeasureText
(
aBoundingBoxType
aDrawTarget
)
;
if
(
aTextFrame
-
>
GetWritingMode
(
)
.
IsLineInverted
(
)
)
{
hyphenMetrics
.
mBoundingBox
.
y
=
-
hyphenMetrics
.
mBoundingBox
.
YMost
(
)
;
}
aMetrics
-
>
CombineWith
(
hyphenMetrics
aBaseTextRun
-
>
IsRightToLeft
(
)
)
;
}
void
nsTextFrame
:
:
PaintOneShadow
(
const
PaintShadowParams
&
aParams
nsCSSShadowItem
*
aShadowDetails
gfxRect
&
aBoundingBox
uint32_t
aBlurFlags
)
{
AUTO_PROFILER_LABEL
(
"
nsTextFrame
:
:
PaintOneShadow
"
GRAPHICS
)
;
gfx
:
:
Point
shadowOffset
(
aShadowDetails
-
>
mXOffset
aShadowDetails
-
>
mYOffset
)
;
nscoord
blurRadius
=
std
:
:
max
(
aShadowDetails
-
>
mRadius
0
)
;
nscolor
shadowColor
=
aShadowDetails
-
>
mColor
.
CalcColor
(
aParams
.
foregroundColor
)
;
if
(
auto
*
textDrawer
=
aParams
.
context
-
>
GetTextDrawer
(
)
)
{
wr
:
:
Shadow
wrShadow
;
wrShadow
.
offset
=
{
PresContext
(
)
-
>
AppUnitsToFloatDevPixels
(
aShadowDetails
-
>
mXOffset
)
PresContext
(
)
-
>
AppUnitsToFloatDevPixels
(
aShadowDetails
-
>
mYOffset
)
}
;
wrShadow
.
blur_radius
=
PresContext
(
)
-
>
AppUnitsToFloatDevPixels
(
blurRadius
)
;
wrShadow
.
color
=
wr
:
:
ToColorF
(
ToDeviceColor
(
shadowColor
)
)
;
textDrawer
-
>
AppendShadow
(
wrShadow
)
;
return
;
}
gfxRect
shadowGfxRect
;
WritingMode
wm
=
GetWritingMode
(
)
;
if
(
wm
.
IsVertical
(
)
)
{
shadowGfxRect
=
aBoundingBox
;
if
(
wm
.
IsVerticalRL
(
)
)
{
shadowGfxRect
.
x
=
-
shadowGfxRect
.
XMost
(
)
;
}
shadowGfxRect
+
=
gfxPoint
(
aParams
.
textBaselinePt
.
x
aParams
.
framePt
.
y
+
aParams
.
leftSideOffset
)
;
}
else
{
shadowGfxRect
=
aBoundingBox
+
gfxPoint
(
aParams
.
framePt
.
x
+
aParams
.
leftSideOffset
aParams
.
textBaselinePt
.
y
)
;
}
shadowGfxRect
+
=
gfxPoint
(
shadowOffset
.
x
shadowOffset
.
y
)
;
nsRect
shadowRect
(
NSToCoordRound
(
shadowGfxRect
.
X
(
)
)
NSToCoordRound
(
shadowGfxRect
.
Y
(
)
)
NSToCoordRound
(
shadowGfxRect
.
Width
(
)
)
NSToCoordRound
(
shadowGfxRect
.
Height
(
)
)
)
;
nsContextBoxBlur
contextBoxBlur
;
const
auto
A2D
=
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
gfxContext
*
shadowContext
=
contextBoxBlur
.
Init
(
shadowRect
0
blurRadius
A2D
aParams
.
context
LayoutDevicePixel
:
:
ToAppUnits
(
aParams
.
dirtyRect
A2D
)
nullptr
aBlurFlags
)
;
if
(
!
shadowContext
)
return
;
aParams
.
context
-
>
Save
(
)
;
aParams
.
context
-
>
SetColor
(
Color
:
:
FromABGR
(
shadowColor
)
)
;
gfxFloat
advanceWidth
;
nsTextPaintStyle
textPaintStyle
(
this
)
;
DrawTextParams
params
(
shadowContext
)
;
params
.
advanceWidth
=
&
advanceWidth
;
params
.
dirtyRect
=
aParams
.
dirtyRect
;
params
.
framePt
=
aParams
.
framePt
+
shadowOffset
;
params
.
provider
=
aParams
.
provider
;
params
.
textStyle
=
&
textPaintStyle
;
params
.
textColor
=
aParams
.
context
=
=
shadowContext
?
shadowColor
:
NS_RGB
(
0
0
0
)
;
params
.
clipEdges
=
aParams
.
clipEdges
;
params
.
drawSoftHyphen
=
(
GetStateBits
(
)
&
TEXT_HYPHEN_BREAK
)
!
=
0
;
params
.
decorationOverrideColor
=
&
params
.
textColor
;
DrawText
(
aParams
.
range
aParams
.
textBaselinePt
+
shadowOffset
params
)
;
contextBoxBlur
.
DoPaint
(
)
;
aParams
.
context
-
>
Restore
(
)
;
}
bool
nsTextFrame
:
:
PaintTextWithSelectionColors
(
const
PaintTextSelectionParams
&
aParams
const
UniquePtr
<
SelectionDetails
>
&
aDetails
SelectionTypeMask
*
aAllSelectionTypeMask
const
nsCharClipDisplayItem
:
:
ClipEdges
&
aClipEdges
)
{
const
gfxTextRun
:
:
Range
&
contentRange
=
aParams
.
contentRange
;
AutoTArray
<
SelectionDetails
*
BIG_TEXT_NODE_SIZE
>
prevailingSelectionsBuffer
;
SelectionDetails
*
*
prevailingSelections
=
prevailingSelectionsBuffer
.
AppendElements
(
contentRange
.
Length
(
)
fallible
)
;
if
(
!
prevailingSelections
)
{
return
false
;
}
SelectionTypeMask
allSelectionTypeMask
=
0
;
for
(
uint32_t
i
=
0
;
i
<
contentRange
.
Length
(
)
;
+
+
i
)
{
prevailingSelections
[
i
]
=
nullptr
;
}
bool
anyBackgrounds
=
false
;
for
(
SelectionDetails
*
sdptr
=
aDetails
.
get
(
)
;
sdptr
;
sdptr
=
sdptr
-
>
mNext
.
get
(
)
)
{
int32_t
start
=
std
:
:
max
(
0
sdptr
-
>
mStart
-
int32_t
(
contentRange
.
start
)
)
;
int32_t
end
=
std
:
:
min
(
int32_t
(
contentRange
.
Length
(
)
)
sdptr
-
>
mEnd
-
int32_t
(
contentRange
.
start
)
)
;
SelectionType
selectionType
=
sdptr
-
>
mSelectionType
;
if
(
start
<
end
)
{
allSelectionTypeMask
|
=
ToSelectionTypeMask
(
selectionType
)
;
nscolor
foreground
background
;
if
(
GetSelectionTextColors
(
selectionType
*
aParams
.
textPaintStyle
sdptr
-
>
mTextRangeStyle
&
foreground
&
background
)
)
{
if
(
NS_GET_A
(
background
)
>
0
)
{
anyBackgrounds
=
true
;
}
for
(
int32_t
i
=
start
;
i
<
end
;
+
+
i
)
{
if
(
!
prevailingSelections
[
i
]
|
|
selectionType
<
prevailingSelections
[
i
]
-
>
mSelectionType
)
{
prevailingSelections
[
i
]
=
sdptr
;
}
}
}
}
}
*
aAllSelectionTypeMask
=
allSelectionTypeMask
;
if
(
!
allSelectionTypeMask
)
{
return
false
;
}
bool
vertical
=
mTextRun
-
>
IsVertical
(
)
;
const
gfxFloat
startIOffset
=
vertical
?
aParams
.
textBaselinePt
.
y
-
aParams
.
framePt
.
y
:
aParams
.
textBaselinePt
.
x
-
aParams
.
framePt
.
x
;
gfxFloat
iOffset
hyphenWidth
;
Range
range
;
TextRangeStyle
rangeStyle
;
auto
*
textDrawer
=
aParams
.
context
-
>
GetTextDrawer
(
)
;
if
(
anyBackgrounds
&
&
!
aParams
.
IsGenerateTextMask
(
)
)
{
int32_t
appUnitsPerDevPixel
=
aParams
.
textPaintStyle
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
SelectionIterator
iterator
(
prevailingSelections
contentRange
*
aParams
.
provider
mTextRun
startIOffset
)
;
SelectionType
selectionType
;
while
(
iterator
.
GetNextSegment
(
&
iOffset
&
range
&
hyphenWidth
&
selectionType
&
rangeStyle
)
)
{
nscolor
foreground
background
;
GetSelectionTextColors
(
selectionType
*
aParams
.
textPaintStyle
rangeStyle
&
foreground
&
background
)
;
gfxFloat
advance
=
hyphenWidth
+
mTextRun
-
>
GetAdvanceWidth
(
range
aParams
.
provider
)
;
if
(
NS_GET_A
(
background
)
>
0
)
{
nsRect
bgRect
;
gfxFloat
offs
=
iOffset
-
(
mTextRun
-
>
IsInlineReversed
(
)
?
advance
:
0
)
;
if
(
vertical
)
{
bgRect
=
nsRect
(
aParams
.
framePt
.
x
aParams
.
framePt
.
y
+
offs
GetSize
(
)
.
width
advance
)
;
}
else
{
bgRect
=
nsRect
(
aParams
.
framePt
.
x
+
offs
aParams
.
framePt
.
y
advance
GetSize
(
)
.
height
)
;
}
LayoutDeviceRect
selectionRect
=
LayoutDeviceRect
:
:
FromAppUnits
(
bgRect
appUnitsPerDevPixel
)
;
if
(
textDrawer
)
{
textDrawer
-
>
AppendSelectionRect
(
selectionRect
ToDeviceColor
(
background
)
)
;
}
else
{
PaintSelectionBackground
(
*
aParams
.
context
-
>
GetDrawTarget
(
)
background
aParams
.
dirtyRect
selectionRect
aParams
.
callbacks
)
;
}
}
iterator
.
UpdateWithAdvance
(
advance
)
;
}
}
if
(
aParams
.
IsPaintBGColor
(
)
)
{
return
true
;
}
gfxFloat
advance
;
DrawTextParams
params
(
aParams
.
context
)
;
params
.
dirtyRect
=
aParams
.
dirtyRect
;
params
.
framePt
=
aParams
.
framePt
;
params
.
provider
=
aParams
.
provider
;
params
.
textStyle
=
aParams
.
textPaintStyle
;
params
.
clipEdges
=
&
aClipEdges
;
params
.
advanceWidth
=
&
advance
;
params
.
callbacks
=
aParams
.
callbacks
;
PaintShadowParams
shadowParams
(
aParams
)
;
shadowParams
.
provider
=
aParams
.
provider
;
shadowParams
.
clipEdges
=
&
aClipEdges
;
const
nsStyleText
*
textStyle
=
StyleText
(
)
;
SelectionIterator
iterator
(
prevailingSelections
contentRange
*
aParams
.
provider
mTextRun
startIOffset
)
;
SelectionType
selectionType
;
while
(
iterator
.
GetNextSegment
(
&
iOffset
&
range
&
hyphenWidth
&
selectionType
&
rangeStyle
)
)
{
nscolor
foreground
background
;
if
(
aParams
.
IsGenerateTextMask
(
)
)
{
foreground
=
NS_RGBA
(
0
0
0
255
)
;
}
else
{
GetSelectionTextColors
(
selectionType
*
aParams
.
textPaintStyle
rangeStyle
&
foreground
&
background
)
;
}
gfx
:
:
Point
textBaselinePt
=
vertical
?
gfx
:
:
Point
(
aParams
.
textBaselinePt
.
x
aParams
.
framePt
.
y
+
iOffset
)
:
gfx
:
:
Point
(
aParams
.
framePt
.
x
+
iOffset
aParams
.
textBaselinePt
.
y
)
;
nsCSSShadowArray
*
shadow
=
textStyle
-
>
GetTextShadow
(
)
;
GetSelectionTextShadow
(
this
selectionType
*
aParams
.
textPaintStyle
&
shadow
)
;
if
(
shadow
)
{
nscoord
startEdge
=
iOffset
;
if
(
mTextRun
-
>
IsInlineReversed
(
)
)
{
startEdge
-
=
hyphenWidth
+
mTextRun
-
>
GetAdvanceWidth
(
range
aParams
.
provider
)
;
}
shadowParams
.
range
=
range
;
shadowParams
.
textBaselinePt
=
textBaselinePt
;
shadowParams
.
foregroundColor
=
foreground
;
shadowParams
.
leftSideOffset
=
startEdge
;
PaintShadows
(
shadow
shadowParams
)
;
}
params
.
textColor
=
foreground
;
params
.
textStrokeColor
=
aParams
.
textPaintStyle
-
>
GetWebkitTextStrokeColor
(
)
;
params
.
textStrokeWidth
=
aParams
.
textPaintStyle
-
>
GetWebkitTextStrokeWidth
(
)
;
params
.
drawSoftHyphen
=
hyphenWidth
>
0
;
DrawText
(
range
textBaselinePt
params
)
;
advance
+
=
hyphenWidth
;
iterator
.
UpdateWithAdvance
(
advance
)
;
}
return
true
;
}
void
nsTextFrame
:
:
PaintTextSelectionDecorations
(
const
PaintTextSelectionParams
&
aParams
const
UniquePtr
<
SelectionDetails
>
&
aDetails
SelectionType
aSelectionType
)
{
if
(
aParams
.
provider
-
>
GetFontGroup
(
)
-
>
ShouldSkipDrawing
(
)
)
return
;
const
gfxTextRun
:
:
Range
&
contentRange
=
aParams
.
contentRange
;
AutoTArray
<
SelectionDetails
*
BIG_TEXT_NODE_SIZE
>
selectedCharsBuffer
;
SelectionDetails
*
*
selectedChars
=
selectedCharsBuffer
.
AppendElements
(
contentRange
.
Length
(
)
fallible
)
;
if
(
!
selectedChars
)
{
return
;
}
for
(
uint32_t
i
=
0
;
i
<
contentRange
.
Length
(
)
;
+
+
i
)
{
selectedChars
[
i
]
=
nullptr
;
}
for
(
SelectionDetails
*
sdptr
=
aDetails
.
get
(
)
;
sdptr
;
sdptr
=
sdptr
-
>
mNext
.
get
(
)
)
{
if
(
sdptr
-
>
mSelectionType
=
=
aSelectionType
)
{
int32_t
start
=
std
:
:
max
(
0
sdptr
-
>
mStart
-
int32_t
(
contentRange
.
start
)
)
;
int32_t
end
=
std
:
:
min
(
int32_t
(
contentRange
.
Length
(
)
)
sdptr
-
>
mEnd
-
int32_t
(
contentRange
.
start
)
)
;
for
(
int32_t
i
=
start
;
i
<
end
;
+
+
i
)
{
selectedChars
[
i
]
=
sdptr
;
}
}
}
gfxFont
*
firstFont
=
aParams
.
provider
-
>
GetFontGroup
(
)
-
>
GetFirstValidFont
(
)
;
bool
verticalRun
=
mTextRun
-
>
IsVertical
(
)
;
bool
rightUnderline
=
verticalRun
&
&
IsUnderlineRight
(
this
)
;
const
uint8_t
kDecoration
=
rightUnderline
?
NS_STYLE_TEXT_DECORATION_LINE_OVERLINE
:
NS_STYLE_TEXT_DECORATION_LINE_UNDERLINE
;
bool
useVerticalMetrics
=
verticalRun
&
&
mTextRun
-
>
UseCenterBaseline
(
)
;
gfxFont
:
:
Metrics
decorationMetrics
(
firstFont
-
>
GetMetrics
(
useVerticalMetrics
?
gfxFont
:
:
eVertical
:
gfxFont
:
:
eHorizontal
)
)
;
if
(
!
useVerticalMetrics
)
{
decorationMetrics
.
underlineOffset
=
aParams
.
provider
-
>
GetFontGroup
(
)
-
>
GetUnderlineOffset
(
)
;
}
gfxFloat
startIOffset
=
verticalRun
?
aParams
.
textBaselinePt
.
y
-
aParams
.
framePt
.
y
:
aParams
.
textBaselinePt
.
x
-
aParams
.
framePt
.
x
;
SelectionIterator
iterator
(
selectedChars
contentRange
*
aParams
.
provider
mTextRun
startIOffset
)
;
gfxFloat
iOffset
hyphenWidth
;
Range
range
;
int32_t
app
=
aParams
.
textPaintStyle
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
Point
pt
;
if
(
verticalRun
)
{
pt
.
x
=
(
aParams
.
textBaselinePt
.
x
-
mAscent
)
/
app
;
}
else
{
pt
.
y
=
(
aParams
.
textBaselinePt
.
y
-
mAscent
)
/
app
;
}
SelectionType
nextSelectionType
;
TextRangeStyle
selectedStyle
;
while
(
iterator
.
GetNextSegment
(
&
iOffset
&
range
&
hyphenWidth
&
nextSelectionType
&
selectedStyle
)
)
{
gfxFloat
advance
=
hyphenWidth
+
mTextRun
-
>
GetAdvanceWidth
(
range
aParams
.
provider
)
;
if
(
nextSelectionType
=
=
aSelectionType
)
{
if
(
verticalRun
)
{
pt
.
y
=
(
aParams
.
framePt
.
y
+
iOffset
-
(
mTextRun
-
>
IsInlineReversed
(
)
?
advance
:
0
)
)
/
app
;
}
else
{
pt
.
x
=
(
aParams
.
framePt
.
x
+
iOffset
-
(
mTextRun
-
>
IsInlineReversed
(
)
?
advance
:
0
)
)
/
app
;
}
gfxFloat
width
=
Abs
(
advance
)
/
app
;
gfxFloat
xInFrame
=
pt
.
x
-
(
aParams
.
framePt
.
x
/
app
)
;
DrawSelectionDecorations
(
aParams
.
context
aParams
.
dirtyRect
aSelectionType
*
aParams
.
textPaintStyle
selectedStyle
pt
xInFrame
width
mAscent
/
app
decorationMetrics
aParams
.
callbacks
verticalRun
kDecoration
)
;
}
iterator
.
UpdateWithAdvance
(
advance
)
;
}
}
bool
nsTextFrame
:
:
PaintTextWithSelection
(
const
PaintTextSelectionParams
&
aParams
const
nsCharClipDisplayItem
:
:
ClipEdges
&
aClipEdges
)
{
NS_ASSERTION
(
GetContent
(
)
-
>
IsSelectionDescendant
(
)
"
wrong
paint
path
"
)
;
UniquePtr
<
SelectionDetails
>
details
=
GetSelectionDetails
(
)
;
if
(
!
details
)
{
return
false
;
}
SelectionTypeMask
allSelectionTypeMask
;
if
(
!
PaintTextWithSelectionColors
(
aParams
details
&
allSelectionTypeMask
aClipEdges
)
)
{
return
false
;
}
allSelectionTypeMask
&
=
kSelectionTypesWithDecorations
;
MOZ_ASSERT
(
kPresentSelectionTypes
[
0
]
=
=
SelectionType
:
:
eNormal
"
The
following
for
loop
assumes
that
the
first
item
of
"
"
kPresentSelectionTypes
is
SelectionType
:
:
eNormal
"
)
;
for
(
size_t
i
=
ArrayLength
(
kPresentSelectionTypes
)
-
1
;
i
>
=
1
;
-
-
i
)
{
SelectionType
selectionType
=
kPresentSelectionTypes
[
i
]
;
if
(
ToSelectionTypeMask
(
selectionType
)
&
allSelectionTypeMask
)
{
PaintTextSelectionDecorations
(
aParams
details
selectionType
)
;
}
}
return
true
;
}
void
nsTextFrame
:
:
DrawEmphasisMarks
(
gfxContext
*
aContext
WritingMode
aWM
const
gfx
:
:
Point
&
aTextBaselinePt
const
gfx
:
:
Point
&
aFramePt
Range
aRange
const
nscolor
*
aDecorationOverrideColor
PropertyProvider
*
aProvider
)
{
const
EmphasisMarkInfo
*
info
=
GetProperty
(
EmphasisMarkProperty
(
)
)
;
if
(
!
info
)
{
return
;
}
bool
isTextCombined
=
Style
(
)
-
>
IsTextCombined
(
)
;
nscolor
color
=
aDecorationOverrideColor
?
*
aDecorationOverrideColor
:
nsLayoutUtils
:
:
GetColor
(
this
&
nsStyleText
:
:
mTextEmphasisColor
)
;
aContext
-
>
SetColor
(
Color
:
:
FromABGR
(
color
)
)
;
gfx
:
:
Point
pt
;
if
(
!
isTextCombined
)
{
pt
=
aTextBaselinePt
;
}
else
{
MOZ_ASSERT
(
aWM
.
IsVertical
(
)
)
;
pt
=
aFramePt
;
if
(
aWM
.
IsVerticalRL
(
)
)
{
pt
.
x
+
=
GetSize
(
)
.
width
-
GetLogicalBaseline
(
aWM
)
;
}
else
{
pt
.
x
+
=
GetLogicalBaseline
(
aWM
)
;
}
}
if
(
!
aWM
.
IsVertical
(
)
)
{
pt
.
y
+
=
info
-
>
baselineOffset
;
}
else
{
if
(
aWM
.
IsVerticalRL
(
)
)
{
pt
.
x
-
=
info
-
>
baselineOffset
;
}
else
{
pt
.
x
+
=
info
-
>
baselineOffset
;
}
}
if
(
!
isTextCombined
)
{
mTextRun
-
>
DrawEmphasisMarks
(
aContext
info
-
>
textRun
.
get
(
)
info
-
>
advance
pt
aRange
aProvider
)
;
}
else
{
pt
.
y
+
=
(
GetSize
(
)
.
height
-
info
-
>
advance
)
/
2
;
gfxTextRun
:
:
DrawParams
params
(
aContext
)
;
info
-
>
textRun
-
>
Draw
(
Range
(
info
-
>
textRun
.
get
(
)
)
pt
params
)
;
}
}
nscolor
nsTextFrame
:
:
GetCaretColorAt
(
int32_t
aOffset
)
{
MOZ_ASSERT
(
aOffset
>
=
0
"
aOffset
must
be
positive
"
)
;
nscolor
result
=
nsFrame
:
:
GetCaretColorAt
(
aOffset
)
;
gfxSkipCharsIterator
iter
=
EnsureTextRun
(
nsTextFrame
:
:
eInflated
)
;
PropertyProvider
provider
(
this
iter
nsTextFrame
:
:
eInflated
)
;
int32_t
contentOffset
=
provider
.
GetStart
(
)
.
GetOriginalOffset
(
)
;
int32_t
contentLength
=
provider
.
GetOriginalLength
(
)
;
MOZ_ASSERT
(
aOffset
>
=
contentOffset
&
&
aOffset
<
=
contentOffset
+
contentLength
"
aOffset
must
be
in
the
frame
'
s
range
"
)
;
int32_t
offsetInFrame
=
aOffset
-
contentOffset
;
if
(
offsetInFrame
<
0
|
|
offsetInFrame
>
=
contentLength
)
{
return
result
;
}
bool
isSolidTextColor
=
true
;
if
(
nsSVGUtils
:
:
IsInSVGTextSubtree
(
this
)
)
{
const
nsStyleSVG
*
style
=
StyleSVG
(
)
;
if
(
style
-
>
mFill
.
Type
(
)
!
=
eStyleSVGPaintType_None
&
&
style
-
>
mFill
.
Type
(
)
!
=
eStyleSVGPaintType_Color
)
{
isSolidTextColor
=
false
;
}
}
nsTextPaintStyle
textPaintStyle
(
this
)
;
textPaintStyle
.
SetResolveColors
(
isSolidTextColor
)
;
UniquePtr
<
SelectionDetails
>
details
=
GetSelectionDetails
(
)
;
SelectionType
selectionType
=
SelectionType
:
:
eNone
;
for
(
SelectionDetails
*
sdptr
=
details
.
get
(
)
;
sdptr
;
sdptr
=
sdptr
-
>
mNext
.
get
(
)
)
{
int32_t
start
=
std
:
:
max
(
0
sdptr
-
>
mStart
-
contentOffset
)
;
int32_t
end
=
std
:
:
min
(
contentLength
sdptr
-
>
mEnd
-
contentOffset
)
;
if
(
start
<
=
offsetInFrame
&
&
offsetInFrame
<
end
&
&
(
selectionType
=
=
SelectionType
:
:
eNone
|
|
sdptr
-
>
mSelectionType
<
selectionType
)
)
{
nscolor
foreground
background
;
if
(
GetSelectionTextColors
(
sdptr
-
>
mSelectionType
textPaintStyle
sdptr
-
>
mTextRangeStyle
&
foreground
&
background
)
)
{
if
(
!
isSolidTextColor
&
&
NS_IS_SELECTION_SPECIAL_COLOR
(
foreground
)
)
{
result
=
NS_RGBA
(
0
0
0
255
)
;
}
else
{
result
=
foreground
;
}
selectionType
=
sdptr
-
>
mSelectionType
;
}
}
}
return
result
;
}
static
gfxTextRun
:
:
Range
ComputeTransformedRange
(
PropertyProvider
&
aProvider
)
{
gfxSkipCharsIterator
iter
(
aProvider
.
GetStart
(
)
)
;
uint32_t
start
=
iter
.
GetSkippedOffset
(
)
;
iter
.
AdvanceOriginal
(
aProvider
.
GetOriginalLength
(
)
)
;
return
gfxTextRun
:
:
Range
(
start
iter
.
GetSkippedOffset
(
)
)
;
}
bool
nsTextFrame
:
:
MeasureCharClippedText
(
nscoord
aVisIStartEdge
nscoord
aVisIEndEdge
nscoord
*
aSnappedStartEdge
nscoord
*
aSnappedEndEdge
)
{
gfxSkipCharsIterator
iter
=
EnsureTextRun
(
nsTextFrame
:
:
eInflated
)
;
if
(
!
mTextRun
)
return
false
;
PropertyProvider
provider
(
this
iter
nsTextFrame
:
:
eInflated
)
;
provider
.
InitializeForDisplay
(
true
)
;
Range
range
=
ComputeTransformedRange
(
provider
)
;
uint32_t
startOffset
=
range
.
start
;
uint32_t
maxLength
=
range
.
Length
(
)
;
return
MeasureCharClippedText
(
provider
aVisIStartEdge
aVisIEndEdge
&
startOffset
&
maxLength
aSnappedStartEdge
aSnappedEndEdge
)
;
}
static
uint32_t
GetClusterLength
(
const
gfxTextRun
*
aTextRun
uint32_t
aStartOffset
uint32_t
aMaxLength
bool
aIsRTL
)
{
uint32_t
clusterLength
=
aIsRTL
?
0
:
1
;
while
(
clusterLength
<
aMaxLength
)
{
if
(
aTextRun
-
>
IsClusterStart
(
aStartOffset
+
clusterLength
)
)
{
if
(
aIsRTL
)
{
+
+
clusterLength
;
}
break
;
}
+
+
clusterLength
;
}
return
clusterLength
;
}
bool
nsTextFrame
:
:
MeasureCharClippedText
(
PropertyProvider
&
aProvider
nscoord
aVisIStartEdge
nscoord
aVisIEndEdge
uint32_t
*
aStartOffset
uint32_t
*
aMaxLength
nscoord
*
aSnappedStartEdge
nscoord
*
aSnappedEndEdge
)
{
*
aSnappedStartEdge
=
0
;
*
aSnappedEndEdge
=
0
;
if
(
aVisIStartEdge
<
=
0
&
&
aVisIEndEdge
<
=
0
)
{
return
true
;
}
uint32_t
offset
=
*
aStartOffset
;
uint32_t
maxLength
=
*
aMaxLength
;
const
nscoord
frameISize
=
ISize
(
)
;
const
bool
rtl
=
mTextRun
-
>
IsRightToLeft
(
)
;
gfxFloat
advanceWidth
=
0
;
const
nscoord
startEdge
=
rtl
?
aVisIEndEdge
:
aVisIStartEdge
;
if
(
startEdge
>
0
)
{
const
gfxFloat
maxAdvance
=
gfxFloat
(
startEdge
)
;
while
(
maxLength
>
0
)
{
uint32_t
clusterLength
=
GetClusterLength
(
mTextRun
offset
maxLength
rtl
)
;
advanceWidth
+
=
mTextRun
-
>
GetAdvanceWidth
(
Range
(
offset
offset
+
clusterLength
)
&
aProvider
)
;
maxLength
-
=
clusterLength
;
offset
+
=
clusterLength
;
if
(
advanceWidth
>
=
maxAdvance
)
{
break
;
}
}
nscoord
*
snappedStartEdge
=
rtl
?
aSnappedEndEdge
:
aSnappedStartEdge
;
*
snappedStartEdge
=
NSToCoordFloor
(
advanceWidth
)
;
*
aStartOffset
=
offset
;
}
const
nscoord
endEdge
=
rtl
?
aVisIStartEdge
:
aVisIEndEdge
;
if
(
endEdge
>
0
)
{
const
gfxFloat
maxAdvance
=
gfxFloat
(
frameISize
-
endEdge
)
;
while
(
maxLength
>
0
)
{
uint32_t
clusterLength
=
GetClusterLength
(
mTextRun
offset
maxLength
rtl
)
;
gfxFloat
nextAdvance
=
advanceWidth
+
mTextRun
-
>
GetAdvanceWidth
(
Range
(
offset
offset
+
clusterLength
)
&
aProvider
)
;
if
(
nextAdvance
>
maxAdvance
)
{
break
;
}
advanceWidth
=
nextAdvance
;
maxLength
-
=
clusterLength
;
offset
+
=
clusterLength
;
}
maxLength
=
offset
-
*
aStartOffset
;
nscoord
*
snappedEndEdge
=
rtl
?
aSnappedStartEdge
:
aSnappedEndEdge
;
*
snappedEndEdge
=
NSToCoordFloor
(
gfxFloat
(
frameISize
)
-
advanceWidth
)
;
}
*
aMaxLength
=
maxLength
;
return
maxLength
!
=
0
;
}
void
nsTextFrame
:
:
PaintShadows
(
nsCSSShadowArray
*
aShadow
const
PaintShadowParams
&
aParams
)
{
if
(
!
aShadow
)
{
return
;
}
gfxTextRun
:
:
Metrics
shadowMetrics
=
mTextRun
-
>
MeasureText
(
aParams
.
range
gfxFont
:
:
LOOSE_INK_EXTENTS
nullptr
aParams
.
provider
)
;
if
(
GetWritingMode
(
)
.
IsLineInverted
(
)
)
{
Swap
(
shadowMetrics
.
mAscent
shadowMetrics
.
mDescent
)
;
shadowMetrics
.
mBoundingBox
.
y
=
-
shadowMetrics
.
mBoundingBox
.
YMost
(
)
;
}
if
(
GetStateBits
(
)
&
TEXT_HYPHEN_BREAK
)
{
AddHyphenToMetrics
(
this
mTextRun
&
shadowMetrics
gfxFont
:
:
LOOSE_INK_EXTENTS
aParams
.
context
-
>
GetDrawTarget
(
)
)
;
}
gfxRect
decorationRect
(
0
-
shadowMetrics
.
mAscent
shadowMetrics
.
mAdvanceWidth
shadowMetrics
.
mAscent
+
shadowMetrics
.
mDescent
)
;
shadowMetrics
.
mBoundingBox
.
UnionRect
(
shadowMetrics
.
mBoundingBox
decorationRect
)
;
uint32_t
blurFlags
=
nsContextBoxBlur
:
:
DISABLE_HARDWARE_ACCELERATION_BLUR
;
uint32_t
numGlyphRuns
;
const
gfxTextRun
:
:
GlyphRun
*
run
=
mTextRun
-
>
GetGlyphRuns
(
&
numGlyphRuns
)
;
while
(
numGlyphRuns
-
-
>
0
)
{
if
(
run
-
>
mFont
-
>
AlwaysNeedsMaskForShadow
(
)
)
{
blurFlags
|
=
nsContextBoxBlur
:
:
FORCE_MASK
;
break
;
}
run
+
+
;
}
if
(
mTextRun
-
>
IsVertical
(
)
)
{
Swap
(
shadowMetrics
.
mBoundingBox
.
x
shadowMetrics
.
mBoundingBox
.
y
)
;
Swap
(
shadowMetrics
.
mBoundingBox
.
width
shadowMetrics
.
mBoundingBox
.
height
)
;
}
for
(
uint32_t
i
=
aShadow
-
>
Length
(
)
;
i
>
0
;
-
-
i
)
{
PaintOneShadow
(
aParams
aShadow
-
>
ShadowAt
(
i
-
1
)
shadowMetrics
.
mBoundingBox
blurFlags
)
;
}
}
static
bool
ShouldDrawSelection
(
const
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
)
{
return
true
;
}
const
nsStyleBackground
*
bg
=
aFrame
-
>
Style
(
)
-
>
StyleBackground
(
)
;
const
nsStyleImageLayers
&
layers
=
bg
-
>
mImage
;
NS_FOR_VISIBLE_IMAGE_LAYERS_BACK_TO_FRONT
(
i
layers
)
{
if
(
layers
.
mLayers
[
i
]
.
mClip
=
=
StyleGeometryBox
:
:
Text
)
{
return
false
;
}
}
return
ShouldDrawSelection
(
aFrame
-
>
GetParent
(
)
)
;
}
void
nsTextFrame
:
:
PaintText
(
const
PaintTextParams
&
aParams
const
nsCharClipDisplayItem
&
aItem
float
aOpacity
)
{
gfxSkipCharsIterator
iter
=
EnsureTextRun
(
nsTextFrame
:
:
eInflated
)
;
if
(
!
mTextRun
)
return
;
PropertyProvider
provider
(
this
iter
nsTextFrame
:
:
eInflated
)
;
if
(
aItem
.
mIsFrameSelected
.
isNothing
(
)
)
{
aItem
.
mIsFrameSelected
.
emplace
(
IsSelected
(
)
)
;
}
provider
.
InitializeForDisplay
(
!
aItem
.
mIsFrameSelected
.
value
(
)
)
;
const
bool
reversed
=
mTextRun
-
>
IsInlineReversed
(
)
;
const
bool
verticalRun
=
mTextRun
-
>
IsVertical
(
)
;
WritingMode
wm
=
GetWritingMode
(
)
;
const
float
frameWidth
=
GetSize
(
)
.
width
;
const
float
frameHeight
=
GetSize
(
)
.
height
;
gfx
:
:
Point
textBaselinePt
;
if
(
verticalRun
)
{
if
(
wm
.
IsVerticalLR
(
)
)
{
textBaselinePt
.
x
=
nsLayoutUtils
:
:
GetSnappedBaselineX
(
this
aParams
.
context
nscoord
(
aParams
.
framePt
.
x
)
mAscent
)
;
}
else
{
textBaselinePt
.
x
=
nsLayoutUtils
:
:
GetSnappedBaselineX
(
this
aParams
.
context
nscoord
(
aParams
.
framePt
.
x
)
+
frameWidth
-
mAscent
)
;
}
textBaselinePt
.
y
=
reversed
?
aParams
.
framePt
.
y
+
frameHeight
:
aParams
.
framePt
.
y
;
}
else
{
textBaselinePt
=
gfx
:
:
Point
(
reversed
?
aParams
.
framePt
.
x
+
frameWidth
:
aParams
.
framePt
.
x
nsLayoutUtils
:
:
GetSnappedBaselineY
(
this
aParams
.
context
aParams
.
framePt
.
y
mAscent
)
)
;
}
Range
range
=
ComputeTransformedRange
(
provider
)
;
uint32_t
startOffset
=
range
.
start
;
uint32_t
maxLength
=
range
.
Length
(
)
;
nscoord
snappedStartEdge
snappedEndEdge
;
if
(
!
MeasureCharClippedText
(
provider
aItem
.
mVisIStartEdge
aItem
.
mVisIEndEdge
&
startOffset
&
maxLength
&
snappedStartEdge
&
snappedEndEdge
)
)
{
return
;
}
if
(
verticalRun
)
{
textBaselinePt
.
y
+
=
reversed
?
-
snappedEndEdge
:
snappedStartEdge
;
}
else
{
textBaselinePt
.
x
+
=
reversed
?
-
snappedEndEdge
:
snappedStartEdge
;
}
nsCharClipDisplayItem
:
:
ClipEdges
clipEdges
(
aItem
snappedStartEdge
snappedEndEdge
)
;
nsTextPaintStyle
textPaintStyle
(
this
)
;
textPaintStyle
.
SetResolveColors
(
!
aParams
.
callbacks
)
;
if
(
aItem
.
mIsFrameSelected
.
value
(
)
&
&
(
aParams
.
IsPaintBGColor
(
)
|
|
ShouldDrawSelection
(
this
-
>
GetParent
(
)
)
)
)
{
MOZ_ASSERT
(
aOpacity
=
=
1
.
0f
"
We
don
'
t
support
opacity
with
selections
!
"
)
;
gfxSkipCharsIterator
tmp
(
provider
.
GetStart
(
)
)
;
Range
contentRange
(
uint32_t
(
tmp
.
ConvertSkippedToOriginal
(
startOffset
)
)
uint32_t
(
tmp
.
ConvertSkippedToOriginal
(
startOffset
+
maxLength
)
)
)
;
PaintTextSelectionParams
params
(
aParams
)
;
params
.
textBaselinePt
=
textBaselinePt
;
params
.
provider
=
&
provider
;
params
.
contentRange
=
contentRange
;
params
.
textPaintStyle
=
&
textPaintStyle
;
if
(
PaintTextWithSelection
(
params
clipEdges
)
)
{
return
;
}
}
if
(
aParams
.
IsPaintBGColor
(
)
)
{
return
;
}
nscolor
foregroundColor
=
aParams
.
IsGenerateTextMask
(
)
?
NS_RGBA
(
0
0
0
255
)
:
textPaintStyle
.
GetTextColor
(
)
;
if
(
aOpacity
!
=
1
.
0f
)
{
gfx
:
:
Color
gfxColor
=
gfx
:
:
Color
:
:
FromABGR
(
foregroundColor
)
;
gfxColor
.
a
*
=
aOpacity
;
foregroundColor
=
gfxColor
.
ToABGR
(
)
;
}
nscolor
textStrokeColor
=
aParams
.
IsGenerateTextMask
(
)
?
NS_RGBA
(
0
0
0
255
)
:
textPaintStyle
.
GetWebkitTextStrokeColor
(
)
;
if
(
aOpacity
!
=
1
.
0f
)
{
gfx
:
:
Color
gfxColor
=
gfx
:
:
Color
:
:
FromABGR
(
textStrokeColor
)
;
gfxColor
.
a
*
=
aOpacity
;
textStrokeColor
=
gfxColor
.
ToABGR
(
)
;
}
range
=
Range
(
startOffset
startOffset
+
maxLength
)
;
if
(
!
aParams
.
callbacks
&
&
aParams
.
IsPaintText
(
)
)
{
const
nsStyleText
*
textStyle
=
StyleText
(
)
;
PaintShadowParams
shadowParams
(
aParams
)
;
shadowParams
.
range
=
range
;
shadowParams
.
textBaselinePt
=
textBaselinePt
;
shadowParams
.
leftSideOffset
=
snappedStartEdge
;
shadowParams
.
provider
=
&
provider
;
shadowParams
.
foregroundColor
=
foregroundColor
;
shadowParams
.
clipEdges
=
&
clipEdges
;
PaintShadows
(
textStyle
-
>
mTextShadow
shadowParams
)
;
}
gfxFloat
advanceWidth
;
DrawTextParams
params
(
aParams
.
context
)
;
params
.
dirtyRect
=
aParams
.
dirtyRect
;
params
.
framePt
=
aParams
.
framePt
;
params
.
provider
=
&
provider
;
params
.
advanceWidth
=
&
advanceWidth
;
params
.
textStyle
=
&
textPaintStyle
;
params
.
textColor
=
foregroundColor
;
params
.
textStrokeColor
=
textStrokeColor
;
params
.
textStrokeWidth
=
textPaintStyle
.
GetWebkitTextStrokeWidth
(
)
;
params
.
clipEdges
=
&
clipEdges
;
params
.
drawSoftHyphen
=
(
GetStateBits
(
)
&
TEXT_HYPHEN_BREAK
)
!
=
0
;
params
.
contextPaint
=
aParams
.
contextPaint
;
params
.
callbacks
=
aParams
.
callbacks
;
DrawText
(
range
textBaselinePt
params
)
;
}
static
void
DrawTextRun
(
const
gfxTextRun
*
aTextRun
const
gfx
:
:
Point
&
aTextBaselinePt
gfxTextRun
:
:
Range
aRange
const
nsTextFrame
:
:
DrawTextRunParams
&
aParams
nsTextFrame
*
aFrame
)
{
gfxTextRun
:
:
DrawParams
params
(
aParams
.
context
)
;
params
.
provider
=
aParams
.
provider
;
params
.
advanceWidth
=
aParams
.
advanceWidth
;
params
.
contextPaint
=
aParams
.
contextPaint
;
params
.
callbacks
=
aParams
.
callbacks
;
if
(
aParams
.
callbacks
)
{
aParams
.
callbacks
-
>
NotifyBeforeText
(
aParams
.
textColor
)
;
params
.
drawMode
=
DrawMode
:
:
GLYPH_PATH
;
aTextRun
-
>
Draw
(
aRange
aTextBaselinePt
params
)
;
aParams
.
callbacks
-
>
NotifyAfterText
(
)
;
}
else
{
auto
*
textDrawer
=
aParams
.
context
-
>
GetTextDrawer
(
)
;
if
(
NS_GET_A
(
aParams
.
textColor
)
!
=
0
|
|
textDrawer
)
{
aParams
.
context
-
>
SetColor
(
Color
:
:
FromABGR
(
aParams
.
textColor
)
)
;
}
else
{
params
.
drawMode
=
DrawMode
:
:
GLYPH_STROKE
;
}
if
(
(
NS_GET_A
(
aParams
.
textStrokeColor
)
!
=
0
|
|
textDrawer
)
&
&
aParams
.
textStrokeWidth
!
=
0
.
0f
)
{
if
(
textDrawer
)
{
textDrawer
-
>
FoundUnsupportedFeature
(
)
;
return
;
}
params
.
drawMode
|
=
DrawMode
:
:
GLYPH_STROKE
;
if
(
gfxPrefs
:
:
PaintOrderEnabled
(
)
)
{
uint32_t
paintOrder
=
aFrame
-
>
StyleSVG
(
)
-
>
mPaintOrder
;
if
(
paintOrder
!
=
NS_STYLE_PAINT_ORDER_NORMAL
)
{
while
(
paintOrder
)
{
uint32_t
component
=
paintOrder
&
(
(
1
<
<
NS_STYLE_PAINT_ORDER_BITWIDTH
)
-
1
)
;
switch
(
component
)
{
case
NS_STYLE_PAINT_ORDER_FILL
:
paintOrder
=
0
;
break
;
case
NS_STYLE_PAINT_ORDER_STROKE
:
params
.
drawMode
|
=
DrawMode
:
:
GLYPH_STROKE_UNDERNEATH
;
paintOrder
=
0
;
break
;
}
paintOrder
>
>
=
NS_STYLE_PAINT_ORDER_BITWIDTH
;
}
}
}
StrokeOptions
strokeOpts
;
params
.
textStrokeColor
=
aParams
.
textStrokeColor
;
strokeOpts
.
mLineWidth
=
aParams
.
textStrokeWidth
;
params
.
strokeOpts
=
&
strokeOpts
;
aTextRun
-
>
Draw
(
aRange
aTextBaselinePt
params
)
;
}
else
{
aTextRun
-
>
Draw
(
aRange
aTextBaselinePt
params
)
;
}
}
}
void
nsTextFrame
:
:
DrawTextRun
(
Range
aRange
const
gfx
:
:
Point
&
aTextBaselinePt
const
DrawTextRunParams
&
aParams
)
{
MOZ_ASSERT
(
aParams
.
advanceWidth
"
Must
provide
advanceWidth
"
)
;
:
:
DrawTextRun
(
mTextRun
aTextBaselinePt
aRange
aParams
this
)
;
if
(
aParams
.
drawSoftHyphen
)
{
RefPtr
<
gfxTextRun
>
hyphenTextRun
=
GetHyphenTextRun
(
mTextRun
nullptr
this
)
;
if
(
hyphenTextRun
)
{
float
hyphenBaselineX
=
aTextBaselinePt
.
x
+
mTextRun
-
>
GetDirection
(
)
*
(
*
aParams
.
advanceWidth
)
-
(
mTextRun
-
>
IsRightToLeft
(
)
?
hyphenTextRun
-
>
GetAdvanceWidth
(
)
:
0
)
;
DrawTextRunParams
params
=
aParams
;
params
.
provider
=
nullptr
;
params
.
advanceWidth
=
nullptr
;
:
:
DrawTextRun
(
hyphenTextRun
.
get
(
)
gfx
:
:
Point
(
hyphenBaselineX
aTextBaselinePt
.
y
)
Range
(
hyphenTextRun
.
get
(
)
)
params
this
)
;
}
}
}
void
nsTextFrame
:
:
DrawTextRunAndDecorations
(
Range
aRange
const
gfx
:
:
Point
&
aTextBaselinePt
const
DrawTextParams
&
aParams
const
TextDecorations
&
aDecorations
)
{
const
gfxFloat
app
=
aParams
.
textStyle
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
const
WritingMode
wm
=
GetParent
(
)
-
>
GetWritingMode
(
)
;
bool
verticalDec
=
wm
.
IsVertical
(
)
;
bool
verticalRun
=
mTextRun
-
>
IsVertical
(
)
;
bool
useVerticalMetrics
=
verticalDec
!
=
verticalRun
?
verticalDec
:
verticalRun
&
&
mTextRun
-
>
UseCenterBaseline
(
)
;
nscoord
x
=
NSToCoordRound
(
aParams
.
framePt
.
x
)
;
nscoord
y
=
NSToCoordRound
(
aParams
.
framePt
.
y
)
;
const
nsSize
frameSize
=
GetSize
(
)
;
nscoord
measure
=
verticalDec
?
frameSize
.
height
:
frameSize
.
width
;
if
(
verticalDec
)
{
aParams
.
clipEdges
-
>
Intersect
(
&
y
&
measure
)
;
}
else
{
aParams
.
clipEdges
-
>
Intersect
(
&
x
&
measure
)
;
}
gfxFloat
ascent
=
gfxFloat
(
GetLogicalBaseline
(
wm
)
)
/
app
;
gfxFloat
frameBStart
=
verticalDec
?
aParams
.
framePt
.
x
:
aParams
.
framePt
.
y
;
if
(
wm
.
IsVerticalRL
(
)
)
{
frameBStart
+
=
frameSize
.
width
;
ascent
=
-
ascent
;
}
nscoord
inflationMinFontSize
=
nsLayoutUtils
:
:
InflationMinFontSizeFor
(
this
)
;
PaintDecorationLineParams
params
;
params
.
context
=
aParams
.
context
;
params
.
dirtyRect
=
aParams
.
dirtyRect
;
params
.
overrideColor
=
aParams
.
decorationOverrideColor
;
params
.
callbacks
=
aParams
.
callbacks
;
params
.
pt
=
Point
(
x
/
app
y
/
app
)
;
Float
&
bCoord
=
verticalDec
?
params
.
pt
.
x
:
params
.
pt
.
y
;
params
.
lineSize
=
Size
(
measure
/
app
0
)
;
params
.
ascent
=
ascent
;
params
.
vertical
=
verticalDec
;
params
.
sidewaysLeft
=
mTextRun
-
>
IsSidewaysLeft
(
)
;
gfxContextMatrixAutoSaveRestore
scaledRestorer
;
if
(
Style
(
)
-
>
IsTextCombined
(
)
)
{
float
scaleFactor
=
GetTextCombineScaleFactor
(
this
)
;
if
(
scaleFactor
!
=
1
.
0f
)
{
scaledRestorer
.
SetContext
(
aParams
.
context
)
;
gfxMatrix
unscaled
=
aParams
.
context
-
>
CurrentMatrixDouble
(
)
;
gfxPoint
pt
(
x
/
app
y
/
app
)
;
unscaled
.
PreTranslate
(
pt
)
.
PreScale
(
1
.
0f
/
scaleFactor
1
.
0f
)
.
PreTranslate
(
-
pt
)
;
aParams
.
context
-
>
SetMatrixDouble
(
unscaled
)
;
}
}
typedef
gfxFont
:
:
Metrics
Metrics
;
auto
paintDecorationLine
=
[
&
]
(
const
LineDecoration
&
dec
gfxFloat
Metrics
:
:
*
lineSize
gfxFloat
Metrics
:
:
*
lineOffset
)
{
if
(
dec
.
mStyle
=
=
NS_STYLE_TEXT_DECORATION_STYLE_NONE
)
{
return
;
}
float
inflation
=
GetInflationForTextDecorations
(
dec
.
mFrame
inflationMinFontSize
)
;
const
Metrics
metrics
=
GetFirstFontMetrics
(
GetFontGroupForFrame
(
dec
.
mFrame
inflation
)
useVerticalMetrics
)
;
params
.
lineSize
.
height
=
metrics
.
*
lineSize
;
bCoord
=
(
frameBStart
-
dec
.
mBaselineOffset
)
/
app
;
params
.
color
=
dec
.
mColor
;
params
.
offset
=
metrics
.
*
lineOffset
;
params
.
style
=
dec
.
mStyle
;
PaintDecorationLine
(
params
)
;
}
;
bool
skipClipping
=
aRange
.
Length
(
)
=
=
mTextRun
-
>
GetLength
(
)
|
|
verticalDec
!
=
verticalRun
;
gfxRect
clipRect
;
if
(
!
skipClipping
)
{
gfxFloat
clipLength
=
mTextRun
-
>
GetAdvanceWidth
(
aRange
aParams
.
provider
)
;
nsRect
visualRect
=
GetVisualOverflowRect
(
)
;
const
bool
isInlineReversed
=
mTextRun
-
>
IsInlineReversed
(
)
;
if
(
verticalDec
)
{
clipRect
.
x
=
aParams
.
framePt
.
x
+
visualRect
.
x
;
clipRect
.
y
=
isInlineReversed
?
aTextBaselinePt
.
y
-
clipLength
:
aTextBaselinePt
.
y
;
clipRect
.
width
=
visualRect
.
width
;
clipRect
.
height
=
clipLength
;
}
else
{
clipRect
.
x
=
isInlineReversed
?
aTextBaselinePt
.
x
-
clipLength
:
aTextBaselinePt
.
x
;
clipRect
.
y
=
aParams
.
framePt
.
y
+
visualRect
.
y
;
clipRect
.
width
=
clipLength
;
clipRect
.
height
=
visualRect
.
height
;
}
clipRect
.
Scale
(
1
/
app
)
;
clipRect
.
Round
(
)
;
params
.
context
-
>
Clip
(
clipRect
)
;
}
params
.
decoration
=
NS_STYLE_TEXT_DECORATION_LINE_UNDERLINE
;
for
(
const
LineDecoration
&
dec
:
Reversed
(
aDecorations
.
mUnderlines
)
)
{
paintDecorationLine
(
dec
&
Metrics
:
:
underlineSize
&
Metrics
:
:
underlineOffset
)
;
}
params
.
decoration
=
NS_STYLE_TEXT_DECORATION_LINE_OVERLINE
;
for
(
const
LineDecoration
&
dec
:
Reversed
(
aDecorations
.
mOverlines
)
)
{
paintDecorationLine
(
dec
&
Metrics
:
:
underlineSize
&
Metrics
:
:
maxAscent
)
;
}
if
(
!
skipClipping
)
{
params
.
context
-
>
PopClip
(
)
;
}
{
gfxContextMatrixAutoSaveRestore
unscaledRestorer
;
if
(
scaledRestorer
.
HasMatrix
(
)
)
{
unscaledRestorer
.
SetContext
(
aParams
.
context
)
;
aParams
.
context
-
>
SetMatrix
(
scaledRestorer
.
Matrix
(
)
)
;
}
DrawTextRun
(
aRange
aTextBaselinePt
aParams
)
;
}
DrawEmphasisMarks
(
aParams
.
context
wm
aTextBaselinePt
aParams
.
framePt
aRange
aParams
.
decorationOverrideColor
aParams
.
provider
)
;
if
(
!
skipClipping
)
{
params
.
context
-
>
Clip
(
clipRect
)
;
}
params
.
decoration
=
NS_STYLE_TEXT_DECORATION_LINE_LINE_THROUGH
;
for
(
const
LineDecoration
&
dec
:
Reversed
(
aDecorations
.
mStrikes
)
)
{
paintDecorationLine
(
dec
&
Metrics
:
:
strikeoutSize
&
Metrics
:
:
strikeoutOffset
)
;
}
if
(
!
skipClipping
)
{
params
.
context
-
>
PopClip
(
)
;
}
}
void
nsTextFrame
:
:
DrawText
(
Range
aRange
const
gfx
:
:
Point
&
aTextBaselinePt
const
DrawTextParams
&
aParams
)
{
TextDecorations
decorations
;
GetTextDecorations
(
aParams
.
textStyle
-
>
PresContext
(
)
aParams
.
callbacks
?
eUnresolvedColors
:
eResolvedColors
decorations
)
;
const
bool
drawDecorations
=
!
aParams
.
provider
-
>
GetFontGroup
(
)
-
>
ShouldSkipDrawing
(
)
&
&
(
decorations
.
HasDecorationLines
(
)
|
|
StyleText
(
)
-
>
HasTextEmphasis
(
)
)
;
if
(
drawDecorations
)
{
DrawTextRunAndDecorations
(
aRange
aTextBaselinePt
aParams
decorations
)
;
}
else
{
DrawTextRun
(
aRange
aTextBaselinePt
aParams
)
;
}
if
(
auto
*
textDrawer
=
aParams
.
context
-
>
GetTextDrawer
(
)
)
{
textDrawer
-
>
TerminateShadows
(
)
;
}
}
int16_t
nsTextFrame
:
:
GetSelectionStatus
(
int16_t
*
aSelectionFlags
)
{
nsCOMPtr
<
nsISelectionController
>
selectionController
;
nsresult
rv
=
GetSelectionController
(
PresContext
(
)
getter_AddRefs
(
selectionController
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
selectionController
)
return
nsISelectionController
:
:
SELECTION_OFF
;
selectionController
-
>
GetSelectionFlags
(
aSelectionFlags
)
;
int16_t
selectionValue
;
selectionController
-
>
GetDisplaySelection
(
&
selectionValue
)
;
return
selectionValue
;
}
bool
nsTextFrame
:
:
IsVisibleInSelection
(
Selection
*
aSelection
)
{
if
(
!
GetContent
(
)
-
>
IsSelectionDescendant
(
)
)
return
false
;
UniquePtr
<
SelectionDetails
>
details
=
GetSelectionDetails
(
)
;
bool
found
=
false
;
for
(
SelectionDetails
*
sdptr
=
details
.
get
(
)
;
sdptr
;
sdptr
=
sdptr
-
>
mNext
.
get
(
)
)
{
if
(
sdptr
-
>
mEnd
>
GetContentOffset
(
)
&
&
sdptr
-
>
mStart
<
GetContentEnd
(
)
&
&
sdptr
-
>
mSelectionType
=
=
SelectionType
:
:
eNormal
)
{
found
=
true
;
break
;
}
}
return
found
;
}
static
uint32_t
CountCharsFit
(
const
gfxTextRun
*
aTextRun
gfxTextRun
:
:
Range
aRange
gfxFloat
aWidth
PropertyProvider
*
aProvider
gfxFloat
*
aFitWidth
)
{
uint32_t
last
=
0
;
gfxFloat
width
=
0
;
for
(
uint32_t
i
=
1
;
i
<
=
aRange
.
Length
(
)
;
+
+
i
)
{
if
(
i
=
=
aRange
.
Length
(
)
|
|
aTextRun
-
>
IsClusterStart
(
aRange
.
start
+
i
)
)
{
gfxTextRun
:
:
Range
range
(
aRange
.
start
+
last
aRange
.
start
+
i
)
;
gfxFloat
nextWidth
=
width
+
aTextRun
-
>
GetAdvanceWidth
(
range
aProvider
)
;
if
(
nextWidth
>
aWidth
)
break
;
last
=
i
;
width
=
nextWidth
;
}
}
*
aFitWidth
=
width
;
return
last
;
}
nsIFrame
:
:
ContentOffsets
nsTextFrame
:
:
CalcContentOffsetsFromFramePoint
(
const
nsPoint
&
aPoint
)
{
return
GetCharacterOffsetAtFramePointInternal
(
aPoint
true
)
;
}
nsIFrame
:
:
ContentOffsets
nsTextFrame
:
:
GetCharacterOffsetAtFramePoint
(
const
nsPoint
&
aPoint
)
{
return
GetCharacterOffsetAtFramePointInternal
(
aPoint
false
)
;
}
nsIFrame
:
:
ContentOffsets
nsTextFrame
:
:
GetCharacterOffsetAtFramePointInternal
(
const
nsPoint
&
aPoint
bool
aForInsertionPoint
)
{
ContentOffsets
offsets
;
gfxSkipCharsIterator
iter
=
EnsureTextRun
(
nsTextFrame
:
:
eInflated
)
;
if
(
!
mTextRun
)
return
offsets
;
PropertyProvider
provider
(
this
iter
nsTextFrame
:
:
eInflated
)
;
provider
.
InitializeForDisplay
(
false
)
;
gfxFloat
width
=
mTextRun
-
>
IsVertical
(
)
?
(
mTextRun
-
>
IsInlineReversed
(
)
?
mRect
.
height
-
aPoint
.
y
:
aPoint
.
y
)
:
(
mTextRun
-
>
IsInlineReversed
(
)
?
mRect
.
width
-
aPoint
.
x
:
aPoint
.
x
)
;
if
(
Style
(
)
-
>
IsTextCombined
(
)
)
{
width
/
=
GetTextCombineScaleFactor
(
this
)
;
}
gfxFloat
fitWidth
;
Range
skippedRange
=
ComputeTransformedRange
(
provider
)
;
uint32_t
charsFit
=
CountCharsFit
(
mTextRun
skippedRange
width
&
provider
&
fitWidth
)
;
int32_t
selectedOffset
;
if
(
charsFit
<
skippedRange
.
Length
(
)
)
{
gfxSkipCharsIterator
extraCluster
(
provider
.
GetStart
(
)
)
;
extraCluster
.
AdvanceSkipped
(
charsFit
)
;
bool
allowSplitLigature
=
true
;
uint32_t
offs
=
extraCluster
.
GetOriginalOffset
(
)
;
const
nsTextFragment
*
frag
=
GetContent
(
)
-
>
GetText
(
)
;
if
(
offs
+
1
<
frag
-
>
GetLength
(
)
&
&
NS_IS_HIGH_SURROGATE
(
frag
-
>
CharAt
(
offs
)
)
&
&
NS_IS_LOW_SURROGATE
(
frag
-
>
CharAt
(
offs
+
1
)
)
&
&
gfxFontUtils
:
:
IsRegionalIndicator
(
SURROGATE_TO_UCS4
(
frag
-
>
CharAt
(
offs
)
frag
-
>
CharAt
(
offs
+
1
)
)
)
)
{
allowSplitLigature
=
false
;
if
(
extraCluster
.
GetSkippedOffset
(
)
>
1
&
&
!
mTextRun
-
>
IsLigatureGroupStart
(
extraCluster
.
GetSkippedOffset
(
)
)
)
{
extraCluster
.
AdvanceSkipped
(
-
2
)
;
fitWidth
-
=
mTextRun
-
>
GetAdvanceWidth
(
Range
(
extraCluster
.
GetSkippedOffset
(
)
extraCluster
.
GetSkippedOffset
(
)
+
2
)
&
provider
)
;
}
}
gfxSkipCharsIterator
extraClusterLastChar
(
extraCluster
)
;
FindClusterEnd
(
mTextRun
provider
.
GetStart
(
)
.
GetOriginalOffset
(
)
+
provider
.
GetOriginalLength
(
)
&
extraClusterLastChar
allowSplitLigature
)
;
PropertyProvider
:
:
Spacing
spacing
;
Range
extraClusterRange
(
extraCluster
.
GetSkippedOffset
(
)
extraClusterLastChar
.
GetSkippedOffset
(
)
+
1
)
;
gfxFloat
charWidth
=
mTextRun
-
>
GetAdvanceWidth
(
extraClusterRange
&
provider
&
spacing
)
;
charWidth
-
=
spacing
.
mBefore
+
spacing
.
mAfter
;
selectedOffset
=
!
aForInsertionPoint
|
|
width
<
=
fitWidth
+
spacing
.
mBefore
+
charWidth
/
2
?
extraCluster
.
GetOriginalOffset
(
)
:
extraClusterLastChar
.
GetOriginalOffset
(
)
+
1
;
}
else
{
selectedOffset
=
provider
.
GetStart
(
)
.
GetOriginalOffset
(
)
+
provider
.
GetOriginalLength
(
)
;
if
(
HasSignificantTerminalNewline
(
)
)
{
-
-
selectedOffset
;
}
}
offsets
.
content
=
GetContent
(
)
;
offsets
.
offset
=
offsets
.
secondaryOffset
=
selectedOffset
;
offsets
.
associate
=
mContentOffset
=
=
offsets
.
offset
?
CARET_ASSOCIATE_AFTER
:
CARET_ASSOCIATE_BEFORE
;
return
offsets
;
}
bool
nsTextFrame
:
:
CombineSelectionUnderlineRect
(
nsPresContext
*
aPresContext
nsRect
&
aRect
)
{
if
(
aRect
.
IsEmpty
(
)
)
return
false
;
nsRect
givenRect
=
aRect
;
RefPtr
<
nsFontMetrics
>
fm
=
nsLayoutUtils
:
:
GetFontMetricsForFrame
(
this
GetFontSizeInflation
(
)
)
;
gfxFontGroup
*
fontGroup
=
fm
-
>
GetThebesFontGroup
(
)
;
gfxFont
*
firstFont
=
fontGroup
-
>
GetFirstValidFont
(
)
;
WritingMode
wm
=
GetWritingMode
(
)
;
bool
verticalRun
=
wm
.
IsVertical
(
)
;
bool
useVerticalMetrics
=
verticalRun
&
&
!
wm
.
IsSideways
(
)
;
const
gfxFont
:
:
Metrics
&
metrics
=
firstFont
-
>
GetMetrics
(
useVerticalMetrics
?
gfxFont
:
:
eVertical
:
gfxFont
:
:
eHorizontal
)
;
nsCSSRendering
:
:
DecorationRectParams
params
;
params
.
ascent
=
aPresContext
-
>
AppUnitsToGfxUnits
(
mAscent
)
;
params
.
offset
=
fontGroup
-
>
GetUnderlineOffset
(
)
;
params
.
descentLimit
=
ComputeDescentLimitForSelectionUnderline
(
aPresContext
metrics
)
;
params
.
vertical
=
verticalRun
;
EnsureTextRun
(
nsTextFrame
:
:
eInflated
)
;
params
.
sidewaysLeft
=
mTextRun
?
mTextRun
-
>
IsSidewaysLeft
(
)
:
false
;
UniquePtr
<
SelectionDetails
>
details
=
GetSelectionDetails
(
)
;
for
(
SelectionDetails
*
sd
=
details
.
get
(
)
;
sd
;
sd
=
sd
-
>
mNext
.
get
(
)
)
{
if
(
sd
-
>
mStart
=
=
sd
-
>
mEnd
|
|
sd
-
>
mSelectionType
=
=
SelectionType
:
:
eInvalid
|
|
!
(
ToSelectionTypeMask
(
sd
-
>
mSelectionType
)
&
kSelectionTypesWithDecorations
)
|
|
sd
-
>
mSelectionType
=
=
SelectionType
:
:
eURLStrikeout
)
{
continue
;
}
float
relativeSize
;
int32_t
index
=
nsTextPaintStyle
:
:
GetUnderlineStyleIndexForSelectionType
(
sd
-
>
mSelectionType
)
;
if
(
sd
-
>
mSelectionType
=
=
SelectionType
:
:
eSpellCheck
)
{
if
(
!
nsTextPaintStyle
:
:
GetSelectionUnderline
(
aPresContext
index
nullptr
&
relativeSize
&
params
.
style
)
)
{
continue
;
}
}
else
{
TextRangeStyle
&
rangeStyle
=
sd
-
>
mTextRangeStyle
;
if
(
rangeStyle
.
IsDefined
(
)
)
{
if
(
!
rangeStyle
.
IsLineStyleDefined
(
)
|
|
rangeStyle
.
mLineStyle
=
=
TextRangeStyle
:
:
LINESTYLE_NONE
)
{
continue
;
}
params
.
style
=
rangeStyle
.
mLineStyle
;
relativeSize
=
rangeStyle
.
mIsBoldLine
?
2
.
0f
:
1
.
0f
;
}
else
if
(
!
nsTextPaintStyle
:
:
GetSelectionUnderline
(
aPresContext
index
nullptr
&
relativeSize
&
params
.
style
)
)
{
continue
;
}
}
nsRect
decorationArea
;
params
.
lineSize
=
Size
(
aPresContext
-
>
AppUnitsToGfxUnits
(
aRect
.
width
)
ComputeSelectionUnderlineHeight
(
aPresContext
metrics
sd
-
>
mSelectionType
)
)
;
relativeSize
=
std
:
:
max
(
relativeSize
1
.
0f
)
;
params
.
lineSize
.
height
*
=
relativeSize
;
decorationArea
=
nsCSSRendering
:
:
GetTextDecorationRect
(
aPresContext
params
)
;
aRect
.
UnionRect
(
aRect
decorationArea
)
;
}
return
!
aRect
.
IsEmpty
(
)
&
&
!
givenRect
.
Contains
(
aRect
)
;
}
bool
nsTextFrame
:
:
IsFrameSelected
(
)
const
{
NS_ASSERTION
(
!
GetContent
(
)
|
|
GetContent
(
)
-
>
IsSelectionDescendant
(
)
"
use
the
public
IsSelected
(
)
instead
"
)
;
return
nsRange
:
:
IsNodeSelected
(
GetContent
(
)
GetContentOffset
(
)
GetContentEnd
(
)
)
;
}
void
nsTextFrame
:
:
SetSelectedRange
(
uint32_t
aStart
uint32_t
aEnd
bool
aSelected
SelectionType
aSelectionType
)
{
NS_ASSERTION
(
!
GetPrevContinuation
(
)
"
Should
only
be
called
for
primary
frame
"
)
;
DEBUG_VERIFY_NOT_DIRTY
(
mState
)
;
if
(
aStart
=
=
aEnd
)
return
;
nsTextFrame
*
f
=
this
;
while
(
f
&
&
f
-
>
GetContentEnd
(
)
<
=
int32_t
(
aStart
)
)
{
f
=
f
-
>
GetNextContinuation
(
)
;
}
nsPresContext
*
presContext
=
PresContext
(
)
;
while
(
f
&
&
f
-
>
GetContentOffset
(
)
<
int32_t
(
aEnd
)
)
{
if
(
ToSelectionTypeMask
(
aSelectionType
)
&
kSelectionTypesWithDecorations
)
{
bool
didHaveOverflowingSelection
=
(
f
-
>
GetStateBits
(
)
&
TEXT_SELECTION_UNDERLINE_OVERFLOWED
)
!
=
0
;
nsRect
r
(
nsPoint
(
0
0
)
GetSize
(
)
)
;
if
(
didHaveOverflowingSelection
|
|
(
aSelected
&
&
f
-
>
CombineSelectionUnderlineRect
(
presContext
r
)
)
)
{
presContext
-
>
PresShell
(
)
-
>
FrameNeedsReflow
(
f
nsIPresShell
:
:
eStyleChange
NS_FRAME_IS_DIRTY
)
;
}
}
f
-
>
InvalidateFrame
(
)
;
f
=
f
-
>
GetNextContinuation
(
)
;
}
}
void
nsTextFrame
:
:
UpdateIteratorFromOffset
(
const
PropertyProvider
&
aProperties
int32_t
&
aInOffset
gfxSkipCharsIterator
&
aIter
)
{
if
(
aInOffset
<
GetContentOffset
(
)
)
{
NS_WARNING
(
"
offset
before
this
frame
'
s
content
"
)
;
aInOffset
=
GetContentOffset
(
)
;
}
else
if
(
aInOffset
>
GetContentEnd
(
)
)
{
NS_WARNING
(
"
offset
after
this
frame
'
s
content
"
)
;
aInOffset
=
GetContentEnd
(
)
;
}
int32_t
trimmedOffset
=
aProperties
.
GetStart
(
)
.
GetOriginalOffset
(
)
;
int32_t
trimmedEnd
=
trimmedOffset
+
aProperties
.
GetOriginalLength
(
)
;
aInOffset
=
std
:
:
max
(
aInOffset
trimmedOffset
)
;
aInOffset
=
std
:
:
min
(
aInOffset
trimmedEnd
)
;
aIter
.
SetOriginalOffset
(
aInOffset
)
;
if
(
aInOffset
<
trimmedEnd
&
&
!
aIter
.
IsOriginalCharSkipped
(
)
&
&
!
mTextRun
-
>
IsClusterStart
(
aIter
.
GetSkippedOffset
(
)
)
)
{
NS_WARNING
(
"
called
for
non
-
cluster
boundary
"
)
;
FindClusterStart
(
mTextRun
trimmedOffset
&
aIter
)
;
}
}
nsPoint
nsTextFrame
:
:
GetPointFromIterator
(
const
gfxSkipCharsIterator
&
aIter
PropertyProvider
&
aProperties
)
{
Range
range
(
aProperties
.
GetStart
(
)
.
GetSkippedOffset
(
)
aIter
.
GetSkippedOffset
(
)
)
;
gfxFloat
advance
=
mTextRun
-
>
GetAdvanceWidth
(
range
&
aProperties
)
;
nscoord
iSize
=
NSToCoordCeilClamped
(
advance
)
;
nsPoint
point
;
if
(
mTextRun
-
>
IsVertical
(
)
)
{
point
.
x
=
0
;
if
(
mTextRun
-
>
IsInlineReversed
(
)
)
{
point
.
y
=
mRect
.
height
-
iSize
;
}
else
{
point
.
y
=
iSize
;
}
}
else
{
point
.
y
=
0
;
if
(
mTextRun
-
>
IsInlineReversed
(
)
)
{
point
.
x
=
mRect
.
width
-
iSize
;
}
else
{
point
.
x
=
iSize
;
}
if
(
Style
(
)
-
>
IsTextCombined
(
)
)
{
point
.
x
*
=
GetTextCombineScaleFactor
(
this
)
;
}
}
return
point
;
}
nsresult
nsTextFrame
:
:
GetPointFromOffset
(
int32_t
inOffset
nsPoint
*
outPoint
)
{
if
(
!
outPoint
)
return
NS_ERROR_NULL_POINTER
;
DEBUG_VERIFY_NOT_DIRTY
(
mState
)
;
if
(
mState
&
NS_FRAME_IS_DIRTY
)
return
NS_ERROR_UNEXPECTED
;
if
(
GetContentLength
(
)
<
=
0
)
{
outPoint
-
>
x
=
0
;
outPoint
-
>
y
=
0
;
return
NS_OK
;
}
gfxSkipCharsIterator
iter
=
EnsureTextRun
(
nsTextFrame
:
:
eInflated
)
;
if
(
!
mTextRun
)
return
NS_ERROR_FAILURE
;
PropertyProvider
properties
(
this
iter
nsTextFrame
:
:
eInflated
)
;
properties
.
InitializeForDisplay
(
false
)
;
UpdateIteratorFromOffset
(
properties
inOffset
iter
)
;
*
outPoint
=
GetPointFromIterator
(
iter
properties
)
;
return
NS_OK
;
}
nsresult
nsTextFrame
:
:
GetCharacterRectsInRange
(
int32_t
aInOffset
int32_t
aLength
nsTArray
<
nsRect
>
&
aRects
)
{
DEBUG_VERIFY_NOT_DIRTY
(
mState
)
;
if
(
mState
&
NS_FRAME_IS_DIRTY
)
{
return
NS_ERROR_UNEXPECTED
;
}
if
(
GetContentLength
(
)
<
=
0
)
{
return
NS_OK
;
}
if
(
!
mTextRun
)
{
return
NS_ERROR_FAILURE
;
}
gfxSkipCharsIterator
iter
=
EnsureTextRun
(
nsTextFrame
:
:
eInflated
)
;
PropertyProvider
properties
(
this
iter
nsTextFrame
:
:
eInflated
)
;
properties
.
InitializeForDisplay
(
false
)
;
UpdateIteratorFromOffset
(
properties
aInOffset
iter
)
;
const
int32_t
kContentEnd
=
GetContentEnd
(
)
;
const
int32_t
kEndOffset
=
std
:
:
min
(
aInOffset
+
aLength
kContentEnd
)
;
while
(
aInOffset
<
kEndOffset
)
{
if
(
!
iter
.
IsOriginalCharSkipped
(
)
&
&
!
mTextRun
-
>
IsClusterStart
(
iter
.
GetSkippedOffset
(
)
)
)
{
FindClusterStart
(
mTextRun
properties
.
GetStart
(
)
.
GetOriginalOffset
(
)
+
properties
.
GetOriginalLength
(
)
&
iter
)
;
}
nsPoint
point
=
GetPointFromIterator
(
iter
properties
)
;
nsRect
rect
;
rect
.
x
=
point
.
x
;
rect
.
y
=
point
.
y
;
nscoord
iSize
=
0
;
if
(
aInOffset
<
kContentEnd
)
{
gfxSkipCharsIterator
nextIter
(
iter
)
;
nextIter
.
AdvanceOriginal
(
1
)
;
if
(
!
nextIter
.
IsOriginalCharSkipped
(
)
&
&
!
mTextRun
-
>
IsClusterStart
(
nextIter
.
GetSkippedOffset
(
)
)
)
{
FindClusterEnd
(
mTextRun
kContentEnd
&
nextIter
)
;
}
gfxFloat
advance
=
mTextRun
-
>
GetAdvanceWidth
(
Range
(
iter
.
GetSkippedOffset
(
)
nextIter
.
GetSkippedOffset
(
)
)
&
properties
)
;
iSize
=
NSToCoordCeilClamped
(
advance
)
;
}
if
(
mTextRun
-
>
IsVertical
(
)
)
{
rect
.
width
=
mRect
.
width
;
rect
.
height
=
iSize
;
}
else
{
rect
.
width
=
iSize
;
rect
.
height
=
mRect
.
height
;
if
(
Style
(
)
-
>
IsTextCombined
(
)
)
{
rect
.
width
*
=
GetTextCombineScaleFactor
(
this
)
;
}
}
aRects
.
AppendElement
(
rect
)
;
aInOffset
+
+
;
if
(
aInOffset
<
kEndOffset
)
{
iter
.
AdvanceOriginal
(
1
)
;
}
}
return
NS_OK
;
}
nsresult
nsTextFrame
:
:
GetChildFrameContainingOffset
(
int32_t
aContentOffset
bool
aHint
int32_t
*
aOutOffset
nsIFrame
*
*
aOutFrame
)
{
DEBUG_VERIFY_NOT_DIRTY
(
mState
)
;
#
if
0
if
(
mState
&
NS_FRAME_IS_DIRTY
)
return
NS_ERROR_UNEXPECTED
;
#
endif
NS_ASSERTION
(
aOutOffset
&
&
aOutFrame
"
Bad
out
parameters
"
)
;
NS_ASSERTION
(
aContentOffset
>
=
0
"
Negative
content
offset
existing
code
was
very
broken
!
"
)
;
nsIFrame
*
primaryFrame
=
mContent
-
>
GetPrimaryFrame
(
)
;
if
(
this
!
=
primaryFrame
)
{
return
primaryFrame
-
>
GetChildFrameContainingOffset
(
aContentOffset
aHint
aOutOffset
aOutFrame
)
;
}
nsTextFrame
*
f
=
this
;
int32_t
offset
=
mContentOffset
;
nsTextFrame
*
cachedFrame
=
GetProperty
(
OffsetToFrameProperty
(
)
)
;
if
(
cachedFrame
)
{
f
=
cachedFrame
;
offset
=
f
-
>
GetContentOffset
(
)
;
f
-
>
RemoveStateBits
(
TEXT_IN_OFFSET_CACHE
)
;
}
if
(
(
aContentOffset
>
=
offset
)
&
&
(
aHint
|
|
aContentOffset
!
=
offset
)
)
{
while
(
true
)
{
nsTextFrame
*
next
=
f
-
>
GetNextContinuation
(
)
;
if
(
!
next
|
|
aContentOffset
<
next
-
>
GetContentOffset
(
)
)
break
;
if
(
aContentOffset
=
=
next
-
>
GetContentOffset
(
)
)
{
if
(
aHint
)
{
f
=
next
;
if
(
f
-
>
GetContentLength
(
)
=
=
0
)
{
continue
;
}
}
break
;
}
f
=
next
;
}
}
else
{
while
(
true
)
{
nsTextFrame
*
prev
=
f
-
>
GetPrevContinuation
(
)
;
if
(
!
prev
|
|
aContentOffset
>
f
-
>
GetContentOffset
(
)
)
break
;
if
(
aContentOffset
=
=
f
-
>
GetContentOffset
(
)
)
{
if
(
!
aHint
)
{
f
=
prev
;
if
(
f
-
>
GetContentLength
(
)
=
=
0
)
{
continue
;
}
}
break
;
}
f
=
prev
;
}
}
*
aOutOffset
=
aContentOffset
-
f
-
>
GetContentOffset
(
)
;
*
aOutFrame
=
f
;
SetProperty
(
OffsetToFrameProperty
(
)
f
)
;
f
-
>
AddStateBits
(
TEXT_IN_OFFSET_CACHE
)
;
return
NS_OK
;
}
nsIFrame
:
:
FrameSearchResult
nsTextFrame
:
:
PeekOffsetNoAmount
(
bool
aForward
int32_t
*
aOffset
)
{
NS_ASSERTION
(
aOffset
&
&
*
aOffset
<
=
GetContentLength
(
)
"
aOffset
out
of
range
"
)
;
gfxSkipCharsIterator
iter
=
EnsureTextRun
(
nsTextFrame
:
:
eInflated
)
;
if
(
!
mTextRun
)
return
CONTINUE_EMPTY
;
TrimmedOffsets
trimmed
=
GetTrimmedOffsets
(
mContent
-
>
GetText
(
)
true
)
;
return
(
iter
.
ConvertOriginalToSkipped
(
trimmed
.
GetEnd
(
)
)
>
iter
.
ConvertOriginalToSkipped
(
trimmed
.
mStart
)
)
?
FOUND
:
CONTINUE
;
}
class
MOZ_STACK_CLASS
ClusterIterator
{
public
:
ClusterIterator
(
nsTextFrame
*
aTextFrame
int32_t
aPosition
int32_t
aDirection
nsString
&
aContext
)
;
bool
NextCluster
(
)
;
bool
IsWhitespace
(
)
;
bool
IsPunctuation
(
)
;
bool
HaveWordBreakBefore
(
)
{
return
mHaveWordBreak
;
}
int32_t
GetBeforeOffset
(
)
{
MOZ_ASSERT
(
mCharIndex
>
=
0
)
;
return
mDirection
<
0
?
GetAfterInternal
(
)
:
mCharIndex
;
}
int32_t
GetAfterOffset
(
)
{
MOZ_ASSERT
(
mCharIndex
>
=
0
)
;
return
mDirection
>
0
?
GetAfterInternal
(
)
:
mCharIndex
;
}
private
:
int32_t
GetAfterInternal
(
)
;
gfxSkipCharsIterator
mIterator
;
const
nsTextFragment
*
mFrag
;
nsTextFrame
*
mTextFrame
;
int32_t
mDirection
;
int32_t
mCharIndex
;
nsTextFrame
:
:
TrimmedOffsets
mTrimmed
;
nsTArray
<
bool
>
mWordBreaks
;
bool
mHaveWordBreak
;
}
;
static
bool
IsAcceptableCaretPosition
(
const
gfxSkipCharsIterator
&
aIter
bool
aRespectClusters
const
gfxTextRun
*
aTextRun
nsIFrame
*
aFrame
)
{
if
(
aIter
.
IsOriginalCharSkipped
(
)
)
return
false
;
uint32_t
index
=
aIter
.
GetSkippedOffset
(
)
;
if
(
aRespectClusters
&
&
!
aTextRun
-
>
IsClusterStart
(
index
)
)
return
false
;
if
(
index
>
0
)
{
uint32_t
offs
=
aIter
.
GetOriginalOffset
(
)
;
const
nsTextFragment
*
frag
=
aFrame
-
>
GetContent
(
)
-
>
GetText
(
)
;
uint32_t
ch
=
frag
-
>
CharAt
(
offs
)
;
if
(
gfxFontUtils
:
:
IsVarSelector
(
ch
)
|
|
(
NS_IS_LOW_SURROGATE
(
ch
)
&
&
offs
>
0
&
&
NS_IS_HIGH_SURROGATE
(
frag
-
>
CharAt
(
offs
-
1
)
)
)
)
{
return
false
;
}
if
(
NS_IS_HIGH_SURROGATE
(
ch
)
&
&
offs
+
1
<
frag
-
>
GetLength
(
)
)
{
uint32_t
ch2
=
frag
-
>
CharAt
(
offs
+
1
)
;
if
(
NS_IS_LOW_SURROGATE
(
ch2
)
)
{
ch
=
SURROGATE_TO_UCS4
(
ch
ch2
)
;
if
(
gfxFontUtils
:
:
IsVarSelector
(
ch
)
|
|
(
gfxFontUtils
:
:
IsRegionalIndicator
(
ch
)
&
&
!
aTextRun
-
>
IsLigatureGroupStart
(
index
)
)
)
{
return
false
;
}
}
}
}
return
true
;
}
nsIFrame
:
:
FrameSearchResult
nsTextFrame
:
:
PeekOffsetCharacter
(
bool
aForward
int32_t
*
aOffset
PeekOffsetCharacterOptions
aOptions
)
{
int32_t
contentLength
=
GetContentLength
(
)
;
NS_ASSERTION
(
aOffset
&
&
*
aOffset
<
=
contentLength
"
aOffset
out
of
range
"
)
;
if
(
!
aOptions
.
mIgnoreUserStyleAll
)
{
StyleUserSelect
selectStyle
;
IsSelectable
(
&
selectStyle
)
;
if
(
selectStyle
=
=
StyleUserSelect
:
:
All
)
{
return
CONTINUE_UNSELECTABLE
;
}
}
gfxSkipCharsIterator
iter
=
EnsureTextRun
(
nsTextFrame
:
:
eInflated
)
;
if
(
!
mTextRun
)
return
CONTINUE_EMPTY
;
TrimmedOffsets
trimmed
=
GetTrimmedOffsets
(
mContent
-
>
GetText
(
)
false
)
;
int32_t
startOffset
=
GetContentOffset
(
)
+
(
*
aOffset
<
0
?
contentLength
:
*
aOffset
)
;
if
(
!
aForward
)
{
for
(
int32_t
i
=
std
:
:
min
(
trimmed
.
GetEnd
(
)
startOffset
)
-
1
;
i
>
=
trimmed
.
mStart
;
-
-
i
)
{
iter
.
SetOriginalOffset
(
i
)
;
if
(
IsAcceptableCaretPosition
(
iter
aOptions
.
mRespectClusters
mTextRun
this
)
)
{
*
aOffset
=
i
-
mContentOffset
;
return
FOUND
;
}
}
*
aOffset
=
0
;
}
else
{
iter
.
SetOriginalOffset
(
startOffset
)
;
if
(
startOffset
<
=
trimmed
.
GetEnd
(
)
&
&
!
(
startOffset
<
trimmed
.
GetEnd
(
)
&
&
StyleText
(
)
-
>
NewlineIsSignificant
(
this
)
&
&
iter
.
GetSkippedOffset
(
)
<
mTextRun
-
>
GetLength
(
)
&
&
mTextRun
-
>
CharIsNewline
(
iter
.
GetSkippedOffset
(
)
)
)
)
{
for
(
int32_t
i
=
startOffset
+
1
;
i
<
=
trimmed
.
GetEnd
(
)
;
+
+
i
)
{
iter
.
SetOriginalOffset
(
i
)
;
if
(
i
=
=
trimmed
.
GetEnd
(
)
|
|
IsAcceptableCaretPosition
(
iter
aOptions
.
mRespectClusters
mTextRun
this
)
)
{
*
aOffset
=
i
-
mContentOffset
;
return
FOUND
;
}
}
}
*
aOffset
=
contentLength
;
}
return
CONTINUE
;
}
bool
ClusterIterator
:
:
IsWhitespace
(
)
{
NS_ASSERTION
(
mCharIndex
>
=
0
"
No
cluster
selected
"
)
;
return
IsSelectionSpace
(
mFrag
mCharIndex
)
;
}
bool
ClusterIterator
:
:
IsPunctuation
(
)
{
NS_ASSERTION
(
mCharIndex
>
=
0
"
No
cluster
selected
"
)
;
static
bool
sStopAtUnderscore
=
Preferences
:
:
GetBool
(
"
layout
.
word_select
.
stop_at_underscore
"
false
)
;
uint32_t
ch
=
mFrag
-
>
CharAt
(
mCharIndex
)
;
uint8_t
cat
=
unicode
:
:
GetGeneralCategory
(
ch
)
;
switch
(
cat
)
{
case
HB_UNICODE_GENERAL_CATEGORY_CONNECT_PUNCTUATION
:
if
(
ch
=
=
'
_
'
&
&
!
sStopAtUnderscore
)
{
return
false
;
}
MOZ_FALLTHROUGH
;
case
HB_UNICODE_GENERAL_CATEGORY_DASH_PUNCTUATION
:
case
HB_UNICODE_GENERAL_CATEGORY_CLOSE_PUNCTUATION
:
case
HB_UNICODE_GENERAL_CATEGORY_FINAL_PUNCTUATION
:
case
HB_UNICODE_GENERAL_CATEGORY_INITIAL_PUNCTUATION
:
case
HB_UNICODE_GENERAL_CATEGORY_OTHER_PUNCTUATION
:
case
HB_UNICODE_GENERAL_CATEGORY_OPEN_PUNCTUATION
:
case
HB_UNICODE_GENERAL_CATEGORY_CURRENCY_SYMBOL
:
case
HB_UNICODE_GENERAL_CATEGORY_MATH_SYMBOL
:
case
HB_UNICODE_GENERAL_CATEGORY_OTHER_SYMBOL
:
return
true
;
default
:
return
false
;
}
}
int32_t
ClusterIterator
:
:
GetAfterInternal
(
)
{
if
(
mFrag
-
>
Is2b
(
)
&
&
NS_IS_HIGH_SURROGATE
(
mFrag
-
>
Get2b
(
)
[
mCharIndex
]
)
&
&
uint32_t
(
mCharIndex
)
+
1
<
mFrag
-
>
GetLength
(
)
&
&
NS_IS_LOW_SURROGATE
(
mFrag
-
>
Get2b
(
)
[
mCharIndex
+
1
]
)
)
{
return
mCharIndex
+
2
;
}
return
mCharIndex
+
1
;
}
bool
ClusterIterator
:
:
NextCluster
(
)
{
if
(
!
mDirection
)
return
false
;
const
gfxTextRun
*
textRun
=
mTextFrame
-
>
GetTextRun
(
nsTextFrame
:
:
eInflated
)
;
mHaveWordBreak
=
false
;
while
(
true
)
{
bool
keepGoing
=
false
;
if
(
mDirection
>
0
)
{
if
(
mIterator
.
GetOriginalOffset
(
)
>
=
mTrimmed
.
GetEnd
(
)
)
return
false
;
keepGoing
=
mIterator
.
IsOriginalCharSkipped
(
)
|
|
mIterator
.
GetOriginalOffset
(
)
<
mTrimmed
.
mStart
|
|
!
textRun
-
>
IsClusterStart
(
mIterator
.
GetSkippedOffset
(
)
)
;
mCharIndex
=
mIterator
.
GetOriginalOffset
(
)
;
mIterator
.
AdvanceOriginal
(
1
)
;
}
else
{
if
(
mIterator
.
GetOriginalOffset
(
)
<
=
mTrimmed
.
mStart
)
return
false
;
mIterator
.
AdvanceOriginal
(
-
1
)
;
keepGoing
=
mIterator
.
IsOriginalCharSkipped
(
)
|
|
mIterator
.
GetOriginalOffset
(
)
>
=
mTrimmed
.
GetEnd
(
)
|
|
!
textRun
-
>
IsClusterStart
(
mIterator
.
GetSkippedOffset
(
)
)
;
mCharIndex
=
mIterator
.
GetOriginalOffset
(
)
;
}
if
(
mWordBreaks
[
GetBeforeOffset
(
)
-
mTextFrame
-
>
GetContentOffset
(
)
]
)
{
mHaveWordBreak
=
true
;
}
if
(
!
keepGoing
)
return
true
;
}
}
ClusterIterator
:
:
ClusterIterator
(
nsTextFrame
*
aTextFrame
int32_t
aPosition
int32_t
aDirection
nsString
&
aContext
)
:
mTextFrame
(
aTextFrame
)
mDirection
(
aDirection
)
mCharIndex
(
-
1
)
mHaveWordBreak
(
false
)
{
mIterator
=
aTextFrame
-
>
EnsureTextRun
(
nsTextFrame
:
:
eInflated
)
;
if
(
!
aTextFrame
-
>
GetTextRun
(
nsTextFrame
:
:
eInflated
)
)
{
mDirection
=
0
;
return
;
}
mIterator
.
SetOriginalOffset
(
aPosition
)
;
mFrag
=
aTextFrame
-
>
GetContent
(
)
-
>
GetText
(
)
;
mTrimmed
=
aTextFrame
-
>
GetTrimmedOffsets
(
mFrag
true
)
;
int32_t
textOffset
=
aTextFrame
-
>
GetContentOffset
(
)
;
int32_t
textLen
=
aTextFrame
-
>
GetContentLength
(
)
;
if
(
!
mWordBreaks
.
AppendElements
(
textLen
+
1
)
)
{
mDirection
=
0
;
return
;
}
memset
(
mWordBreaks
.
Elements
(
)
false
(
textLen
+
1
)
*
sizeof
(
bool
)
)
;
int32_t
textStart
;
if
(
aDirection
>
0
)
{
if
(
aContext
.
IsEmpty
(
)
)
{
mWordBreaks
[
0
]
=
true
;
}
textStart
=
aContext
.
Length
(
)
;
mFrag
-
>
AppendTo
(
aContext
textOffset
textLen
)
;
}
else
{
if
(
aContext
.
IsEmpty
(
)
)
{
mWordBreaks
[
textLen
]
=
true
;
}
textStart
=
0
;
nsAutoString
str
;
mFrag
-
>
AppendTo
(
str
textOffset
textLen
)
;
aContext
.
Insert
(
str
0
)
;
}
mozilla
:
:
intl
:
:
WordBreaker
*
wordBreaker
=
nsContentUtils
:
:
WordBreaker
(
)
;
for
(
int32_t
i
=
0
;
i
<
=
textLen
;
+
+
i
)
{
int32_t
indexInText
=
i
+
textStart
;
mWordBreaks
[
i
]
|
=
wordBreaker
-
>
BreakInBetween
(
aContext
.
get
(
)
indexInText
aContext
.
get
(
)
+
indexInText
aContext
.
Length
(
)
-
indexInText
)
;
}
}
nsIFrame
:
:
FrameSearchResult
nsTextFrame
:
:
PeekOffsetWord
(
bool
aForward
bool
aWordSelectEatSpace
bool
aIsKeyboardSelect
int32_t
*
aOffset
PeekWordState
*
aState
)
{
int32_t
contentLength
=
GetContentLength
(
)
;
NS_ASSERTION
(
aOffset
&
&
*
aOffset
<
=
contentLength
"
aOffset
out
of
range
"
)
;
StyleUserSelect
selectStyle
;
IsSelectable
(
&
selectStyle
)
;
if
(
selectStyle
=
=
StyleUserSelect
:
:
All
)
return
CONTINUE_UNSELECTABLE
;
int32_t
offset
=
GetContentOffset
(
)
+
(
*
aOffset
<
0
?
contentLength
:
*
aOffset
)
;
ClusterIterator
cIter
(
this
offset
aForward
?
1
:
-
1
aState
-
>
mContext
)
;
if
(
!
cIter
.
NextCluster
(
)
)
return
CONTINUE_EMPTY
;
do
{
bool
isPunctuation
=
cIter
.
IsPunctuation
(
)
;
bool
isWhitespace
=
cIter
.
IsWhitespace
(
)
;
bool
isWordBreakBefore
=
cIter
.
HaveWordBreakBefore
(
)
;
if
(
aWordSelectEatSpace
=
=
isWhitespace
&
&
!
aState
-
>
mSawBeforeType
)
{
aState
-
>
SetSawBeforeType
(
)
;
aState
-
>
Update
(
isPunctuation
isWhitespace
)
;
continue
;
}
if
(
!
aState
-
>
mAtStart
)
{
bool
canBreak
;
if
(
isPunctuation
!
=
aState
-
>
mLastCharWasPunctuation
)
{
canBreak
=
BreakWordBetweenPunctuation
(
aState
aForward
isPunctuation
isWhitespace
aIsKeyboardSelect
)
;
}
else
if
(
!
aState
-
>
mLastCharWasWhitespace
&
&
!
isWhitespace
&
&
!
isPunctuation
&
&
isWordBreakBefore
)
{
canBreak
=
true
;
}
else
{
canBreak
=
isWordBreakBefore
&
&
aState
-
>
mSawBeforeType
&
&
(
aWordSelectEatSpace
!
=
isWhitespace
)
;
}
if
(
canBreak
)
{
*
aOffset
=
cIter
.
GetBeforeOffset
(
)
-
mContentOffset
;
return
FOUND
;
}
}
aState
-
>
Update
(
isPunctuation
isWhitespace
)
;
}
while
(
cIter
.
NextCluster
(
)
)
;
*
aOffset
=
cIter
.
GetAfterOffset
(
)
-
mContentOffset
;
return
CONTINUE
;
}
nsresult
nsTextFrame
:
:
CheckVisibility
(
nsPresContext
*
aContext
int32_t
aStartIndex
int32_t
aEndIndex
bool
aRecurse
bool
*
aFinished
bool
*
aRetval
)
{
if
(
!
aRetval
)
return
NS_ERROR_NULL_POINTER
;
for
(
nsTextFrame
*
f
=
this
;
f
;
f
=
f
-
>
GetNextContinuation
(
)
)
{
int32_t
dummyOffset
=
0
;
if
(
f
-
>
PeekOffsetNoAmount
(
true
&
dummyOffset
)
=
=
FOUND
)
{
*
aRetval
=
true
;
return
NS_OK
;
}
}
*
aRetval
=
false
;
return
NS_OK
;
}
nsresult
nsTextFrame
:
:
GetOffsets
(
int32_t
&
start
int32_t
&
end
)
const
{
start
=
GetContentOffset
(
)
;
end
=
GetContentEnd
(
)
;
return
NS_OK
;
}
static
int32_t
FindEndOfPunctuationRun
(
const
nsTextFragment
*
aFrag
const
gfxTextRun
*
aTextRun
gfxSkipCharsIterator
*
aIter
int32_t
aOffset
int32_t
aStart
int32_t
aEnd
)
{
int32_t
i
;
for
(
i
=
aStart
;
i
<
aEnd
-
aOffset
;
+
+
i
)
{
if
(
nsContentUtils
:
:
IsFirstLetterPunctuationAt
(
aFrag
aOffset
+
i
)
)
{
aIter
-
>
SetOriginalOffset
(
aOffset
+
i
)
;
FindClusterEnd
(
aTextRun
aEnd
aIter
)
;
i
=
aIter
-
>
GetOriginalOffset
(
)
-
aOffset
;
}
else
{
break
;
}
}
return
i
;
}
static
bool
FindFirstLetterRange
(
const
nsTextFragment
*
aFrag
const
gfxTextRun
*
aTextRun
int32_t
aOffset
const
gfxSkipCharsIterator
&
aIter
int32_t
*
aLength
)
{
int32_t
i
;
int32_t
length
=
*
aLength
;
int32_t
endOffset
=
aOffset
+
length
;
gfxSkipCharsIterator
iter
(
aIter
)
;
i
=
FindEndOfPunctuationRun
(
aFrag
aTextRun
&
iter
aOffset
GetTrimmableWhitespaceCount
(
aFrag
aOffset
length
1
)
endOffset
)
;
if
(
i
=
=
length
)
return
false
;
if
(
!
nsContentUtils
:
:
IsAlphanumericAt
(
aFrag
aOffset
+
i
)
)
{
*
aLength
=
0
;
return
true
;
}
bool
allowSplitLigature
;
typedef
unicode
:
:
Script
Script
;
switch
(
unicode
:
:
GetScriptCode
(
aFrag
-
>
CharAt
(
aOffset
+
i
)
)
)
{
default
:
allowSplitLigature
=
true
;
break
;
case
Script
:
:
BENGALI
:
case
Script
:
:
DEVANAGARI
:
case
Script
:
:
GUJARATI
:
case
Script
:
:
GURMUKHI
:
case
Script
:
:
KANNADA
:
case
Script
:
:
MALAYALAM
:
case
Script
:
:
ORIYA
:
case
Script
:
:
TAMIL
:
case
Script
:
:
TELUGU
:
case
Script
:
:
SINHALA
:
case
Script
:
:
BALINESE
:
case
Script
:
:
LEPCHA
:
case
Script
:
:
REJANG
:
case
Script
:
:
SUNDANESE
:
case
Script
:
:
JAVANESE
:
case
Script
:
:
KAITHI
:
case
Script
:
:
MEETEI_MAYEK
:
case
Script
:
:
CHAKMA
:
case
Script
:
:
SHARADA
:
case
Script
:
:
TAKRI
:
case
Script
:
:
KHMER
:
case
Script
:
:
TIBETAN
:
case
Script
:
:
MYANMAR
:
case
Script
:
:
BUGINESE
:
case
Script
:
:
NEW_TAI_LUE
:
case
Script
:
:
CHAM
:
case
Script
:
:
TAI_THAM
:
allowSplitLigature
=
false
;
break
;
}
iter
.
SetOriginalOffset
(
aOffset
+
i
)
;
FindClusterEnd
(
aTextRun
endOffset
&
iter
allowSplitLigature
)
;
i
=
iter
.
GetOriginalOffset
(
)
-
aOffset
;
if
(
i
+
1
=
=
length
)
return
true
;
i
=
FindEndOfPunctuationRun
(
aFrag
aTextRun
&
iter
aOffset
i
+
1
endOffset
)
;
if
(
i
<
length
)
*
aLength
=
i
;
return
true
;
}
static
uint32_t
FindStartAfterSkippingWhitespace
(
PropertyProvider
*
aProvider
nsIFrame
:
:
InlineIntrinsicISizeData
*
aData
const
nsStyleText
*
aTextStyle
gfxSkipCharsIterator
*
aIterator
uint32_t
aFlowEndInTextRun
)
{
if
(
aData
-
>
mSkipWhitespace
)
{
while
(
aIterator
-
>
GetSkippedOffset
(
)
<
aFlowEndInTextRun
&
&
IsTrimmableSpace
(
aProvider
-
>
GetFragment
(
)
aIterator
-
>
GetOriginalOffset
(
)
aTextStyle
)
)
{
aIterator
-
>
AdvanceOriginal
(
1
)
;
}
}
return
aIterator
-
>
GetSkippedOffset
(
)
;
}
float
nsTextFrame
:
:
GetFontSizeInflation
(
)
const
{
if
(
!
HasFontSizeInflation
(
)
)
{
return
1
.
0f
;
}
return
GetProperty
(
FontSizeInflationProperty
(
)
)
;
}
void
nsTextFrame
:
:
SetFontSizeInflation
(
float
aInflation
)
{
if
(
aInflation
=
=
1
.
0f
)
{
if
(
HasFontSizeInflation
(
)
)
{
RemoveStateBits
(
TEXT_HAS_FONT_INFLATION
)
;
DeleteProperty
(
FontSizeInflationProperty
(
)
)
;
}
return
;
}
AddStateBits
(
TEXT_HAS_FONT_INFLATION
)
;
SetProperty
(
FontSizeInflationProperty
(
)
aInflation
)
;
}
void
nsTextFrame
:
:
MarkIntrinsicISizesDirty
(
)
{
ClearTextRuns
(
)
;
nsFrame
:
:
MarkIntrinsicISizesDirty
(
)
;
}
void
nsTextFrame
:
:
AddInlineMinISizeForFlow
(
gfxContext
*
aRenderingContext
nsIFrame
:
:
InlineMinISizeData
*
aData
TextRunType
aTextRunType
)
{
uint32_t
flowEndInTextRun
;
gfxSkipCharsIterator
iter
=
EnsureTextRun
(
aTextRunType
aRenderingContext
-
>
GetDrawTarget
(
)
aData
-
>
LineContainer
(
)
aData
-
>
mLine
&
flowEndInTextRun
)
;
gfxTextRun
*
textRun
=
GetTextRun
(
aTextRunType
)
;
if
(
!
textRun
)
return
;
const
nsStyleText
*
textStyle
=
StyleText
(
)
;
const
nsTextFragment
*
frag
=
mContent
-
>
GetText
(
)
;
int32_t
len
=
INT32_MAX
;
bool
hyphenating
=
frag
-
>
GetLength
(
)
>
0
&
&
(
textStyle
-
>
mHyphens
=
=
StyleHyphens
:
:
Auto
|
|
(
textStyle
-
>
mHyphens
=
=
StyleHyphens
:
:
Manual
&
&
!
!
(
textRun
-
>
GetFlags
(
)
&
gfx
:
:
ShapedTextFlags
:
:
TEXT_ENABLE_HYPHEN_BREAKS
)
)
)
;
if
(
hyphenating
)
{
gfxSkipCharsIterator
tmp
(
iter
)
;
len
=
std
:
:
min
<
int32_t
>
(
GetContentOffset
(
)
+
GetInFlowContentLength
(
)
tmp
.
ConvertSkippedToOriginal
(
flowEndInTextRun
)
)
-
iter
.
GetOriginalOffset
(
)
;
}
PropertyProvider
provider
(
textRun
textStyle
frag
this
iter
len
nullptr
0
aTextRunType
)
;
bool
collapseWhitespace
=
!
textStyle
-
>
WhiteSpaceIsSignificant
(
)
;
bool
preformatNewlines
=
textStyle
-
>
NewlineIsSignificant
(
this
)
;
bool
preformatTabs
=
textStyle
-
>
WhiteSpaceIsSignificant
(
)
;
gfxFloat
tabWidth
=
-
1
;
uint32_t
start
=
FindStartAfterSkippingWhitespace
(
&
provider
aData
textStyle
&
iter
flowEndInTextRun
)
;
if
(
Style
(
)
-
>
IsTextCombined
(
)
)
{
if
(
start
<
flowEndInTextRun
&
&
textRun
-
>
CanBreakLineBefore
(
start
)
)
{
aData
-
>
OptionallyBreak
(
)
;
}
aData
-
>
mCurrentLine
+
=
provider
.
GetFontMetrics
(
)
-
>
EmHeight
(
)
;
aData
-
>
mTrailingWhitespace
=
0
;
return
;
}
if
(
textStyle
-
>
WordCanWrap
(
this
)
)
{
aData
-
>
OptionallyBreak
(
)
;
aData
-
>
mCurrentLine
+
=
textRun
-
>
GetMinAdvanceWidth
(
Range
(
start
flowEndInTextRun
)
)
;
aData
-
>
mTrailingWhitespace
=
0
;
aData
-
>
mAtStartOfLine
=
false
;
aData
-
>
OptionallyBreak
(
)
;
return
;
}
AutoTArray
<
gfxTextRun
:
:
HyphenType
BIG_TEXT_NODE_SIZE
>
hyphBuffer
;
if
(
hyphenating
)
{
if
(
hyphBuffer
.
AppendElements
(
flowEndInTextRun
-
start
fallible
)
)
{
provider
.
GetHyphenationBreaks
(
Range
(
start
flowEndInTextRun
)
hyphBuffer
.
Elements
(
)
)
;
}
else
{
hyphenating
=
false
;
}
}
for
(
uint32_t
i
=
start
wordStart
=
start
;
i
<
=
flowEndInTextRun
;
+
+
i
)
{
bool
preformattedNewline
=
false
;
bool
preformattedTab
=
false
;
if
(
i
<
flowEndInTextRun
)
{
preformattedNewline
=
preformatNewlines
&
&
textRun
-
>
CharIsNewline
(
i
)
;
preformattedTab
=
preformatTabs
&
&
textRun
-
>
CharIsTab
(
i
)
;
if
(
!
textRun
-
>
CanBreakLineBefore
(
i
)
&
&
!
preformattedNewline
&
&
!
preformattedTab
&
&
(
!
hyphenating
|
|
hyphBuffer
[
i
-
start
]
=
=
gfxTextRun
:
:
HyphenType
:
:
None
)
)
{
continue
;
}
}
if
(
i
>
wordStart
)
{
nscoord
width
=
NSToCoordCeilClamped
(
textRun
-
>
GetAdvanceWidth
(
Range
(
wordStart
i
)
&
provider
)
)
;
width
=
std
:
:
max
(
0
width
)
;
aData
-
>
mCurrentLine
=
NSCoordSaturatingAdd
(
aData
-
>
mCurrentLine
width
)
;
aData
-
>
mAtStartOfLine
=
false
;
if
(
collapseWhitespace
)
{
uint32_t
trimStart
=
GetEndOfTrimmedText
(
frag
textStyle
wordStart
i
&
iter
)
;
if
(
trimStart
=
=
start
)
{
aData
-
>
mTrailingWhitespace
+
=
width
;
}
else
{
nscoord
wsWidth
=
NSToCoordCeilClamped
(
textRun
-
>
GetAdvanceWidth
(
Range
(
trimStart
i
)
&
provider
)
)
;
aData
-
>
mTrailingWhitespace
=
std
:
:
max
(
0
wsWidth
)
;
}
}
else
{
aData
-
>
mTrailingWhitespace
=
0
;
}
}
if
(
preformattedTab
)
{
PropertyProvider
:
:
Spacing
spacing
;
provider
.
GetSpacing
(
Range
(
i
i
+
1
)
&
spacing
)
;
aData
-
>
mCurrentLine
+
=
nscoord
(
spacing
.
mBefore
)
;
if
(
tabWidth
<
0
)
{
tabWidth
=
ComputeTabWidthAppUnits
(
this
textRun
)
;
}
gfxFloat
afterTab
=
AdvanceToNextTab
(
aData
-
>
mCurrentLine
tabWidth
)
;
aData
-
>
mCurrentLine
=
nscoord
(
afterTab
+
spacing
.
mAfter
)
;
wordStart
=
i
+
1
;
}
else
if
(
i
<
flowEndInTextRun
|
|
(
i
=
=
textRun
-
>
GetLength
(
)
&
&
(
textRun
-
>
GetFlags2
(
)
&
nsTextFrameUtils
:
:
Flags
:
:
TEXT_HAS_TRAILING_BREAK
)
)
)
{
if
(
preformattedNewline
)
{
aData
-
>
ForceBreak
(
)
;
}
else
if
(
i
<
flowEndInTextRun
&
&
hyphenating
&
&
hyphBuffer
[
i
-
start
]
!
=
gfxTextRun
:
:
HyphenType
:
:
None
)
{
aData
-
>
OptionallyBreak
(
NSToCoordRound
(
provider
.
GetHyphenWidth
(
)
)
)
;
}
else
{
aData
-
>
OptionallyBreak
(
)
;
}
wordStart
=
i
;
}
}
if
(
start
<
flowEndInTextRun
)
{
aData
-
>
mSkipWhitespace
=
IsTrimmableSpace
(
provider
.
GetFragment
(
)
iter
.
ConvertSkippedToOriginal
(
flowEndInTextRun
-
1
)
textStyle
)
;
}
}
bool
nsTextFrame
:
:
IsCurrentFontInflation
(
float
aInflation
)
const
{
return
fabsf
(
aInflation
-
GetFontSizeInflation
(
)
)
<
1e
-
6
;
}
void
nsTextFrame
:
:
AddInlineMinISize
(
gfxContext
*
aRenderingContext
nsIFrame
:
:
InlineMinISizeData
*
aData
)
{
float
inflation
=
nsLayoutUtils
:
:
FontSizeInflationFor
(
this
)
;
TextRunType
trtype
=
(
inflation
=
=
1
.
0f
)
?
eNotInflated
:
eInflated
;
if
(
trtype
=
=
eInflated
&
&
!
IsCurrentFontInflation
(
inflation
)
)
{
ClearTextRun
(
nullptr
nsTextFrame
:
:
eInflated
)
;
}
nsTextFrame
*
f
;
const
gfxTextRun
*
lastTextRun
=
nullptr
;
for
(
f
=
this
;
f
;
f
=
f
-
>
GetNextContinuation
(
)
)
{
if
(
f
=
=
this
|
|
f
-
>
GetTextRun
(
trtype
)
!
=
lastTextRun
)
{
nsIFrame
*
lc
;
if
(
aData
-
>
LineContainer
(
)
&
&
aData
-
>
LineContainer
(
)
!
=
(
lc
=
FindLineContainer
(
f
)
)
)
{
NS_ASSERTION
(
f
!
=
this
"
wrong
InlineMinISizeData
container
"
"
for
first
continuation
"
)
;
aData
-
>
mLine
=
nullptr
;
aData
-
>
SetLineContainer
(
lc
)
;
}
f
-
>
AddInlineMinISizeForFlow
(
aRenderingContext
aData
trtype
)
;
lastTextRun
=
f
-
>
GetTextRun
(
trtype
)
;
}
}
}
void
nsTextFrame
:
:
AddInlinePrefISizeForFlow
(
gfxContext
*
aRenderingContext
nsIFrame
:
:
InlinePrefISizeData
*
aData
TextRunType
aTextRunType
)
{
uint32_t
flowEndInTextRun
;
gfxSkipCharsIterator
iter
=
EnsureTextRun
(
aTextRunType
aRenderingContext
-
>
GetDrawTarget
(
)
aData
-
>
LineContainer
(
)
aData
-
>
mLine
&
flowEndInTextRun
)
;
gfxTextRun
*
textRun
=
GetTextRun
(
aTextRunType
)
;
if
(
!
textRun
)
return
;
const
nsStyleText
*
textStyle
=
StyleText
(
)
;
const
nsTextFragment
*
frag
=
mContent
-
>
GetText
(
)
;
PropertyProvider
provider
(
textRun
textStyle
frag
this
iter
INT32_MAX
nullptr
0
aTextRunType
)
;
if
(
Style
(
)
-
>
IsTextCombined
(
)
)
{
aData
-
>
mCurrentLine
+
=
provider
.
GetFontMetrics
(
)
-
>
EmHeight
(
)
;
aData
-
>
mTrailingWhitespace
=
0
;
aData
-
>
mLineIsEmpty
=
false
;
return
;
}
bool
collapseWhitespace
=
!
textStyle
-
>
WhiteSpaceIsSignificant
(
)
;
bool
preformatNewlines
=
textStyle
-
>
NewlineIsSignificant
(
this
)
;
bool
preformatTabs
=
textStyle
-
>
TabIsSignificant
(
)
;
gfxFloat
tabWidth
=
-
1
;
uint32_t
start
=
FindStartAfterSkippingWhitespace
(
&
provider
aData
textStyle
&
iter
flowEndInTextRun
)
;
uint32_t
loopStart
=
(
preformatNewlines
|
|
preformatTabs
)
?
start
:
flowEndInTextRun
;
for
(
uint32_t
i
=
loopStart
lineStart
=
start
;
i
<
=
flowEndInTextRun
;
+
+
i
)
{
bool
preformattedNewline
=
false
;
bool
preformattedTab
=
false
;
if
(
i
<
flowEndInTextRun
)
{
NS_ASSERTION
(
preformatNewlines
|
|
preformatTabs
"
We
can
'
t
be
here
unless
newlines
are
"
"
hard
breaks
or
there
are
tabs
"
)
;
preformattedNewline
=
preformatNewlines
&
&
textRun
-
>
CharIsNewline
(
i
)
;
preformattedTab
=
preformatTabs
&
&
textRun
-
>
CharIsTab
(
i
)
;
if
(
!
preformattedNewline
&
&
!
preformattedTab
)
{
continue
;
}
}
if
(
i
>
lineStart
)
{
nscoord
width
=
NSToCoordCeilClamped
(
textRun
-
>
GetAdvanceWidth
(
Range
(
lineStart
i
)
&
provider
)
)
;
width
=
std
:
:
max
(
0
width
)
;
aData
-
>
mCurrentLine
=
NSCoordSaturatingAdd
(
aData
-
>
mCurrentLine
width
)
;
aData
-
>
mLineIsEmpty
=
false
;
if
(
collapseWhitespace
)
{
uint32_t
trimStart
=
GetEndOfTrimmedText
(
frag
textStyle
lineStart
i
&
iter
)
;
if
(
trimStart
=
=
start
)
{
aData
-
>
mTrailingWhitespace
+
=
width
;
}
else
{
nscoord
wsWidth
=
NSToCoordCeilClamped
(
textRun
-
>
GetAdvanceWidth
(
Range
(
trimStart
i
)
&
provider
)
)
;
aData
-
>
mTrailingWhitespace
=
std
:
:
max
(
0
wsWidth
)
;
}
}
else
{
aData
-
>
mTrailingWhitespace
=
0
;
}
}
if
(
preformattedTab
)
{
PropertyProvider
:
:
Spacing
spacing
;
provider
.
GetSpacing
(
Range
(
i
i
+
1
)
&
spacing
)
;
aData
-
>
mCurrentLine
+
=
nscoord
(
spacing
.
mBefore
)
;
if
(
tabWidth
<
0
)
{
tabWidth
=
ComputeTabWidthAppUnits
(
this
textRun
)
;
}
gfxFloat
afterTab
=
AdvanceToNextTab
(
aData
-
>
mCurrentLine
tabWidth
)
;
aData
-
>
mCurrentLine
=
nscoord
(
afterTab
+
spacing
.
mAfter
)
;
aData
-
>
mLineIsEmpty
=
false
;
lineStart
=
i
+
1
;
}
else
if
(
preformattedNewline
)
{
aData
-
>
ForceBreak
(
)
;
lineStart
=
i
;
}
}
if
(
start
<
flowEndInTextRun
)
{
aData
-
>
mSkipWhitespace
=
IsTrimmableSpace
(
provider
.
GetFragment
(
)
iter
.
ConvertSkippedToOriginal
(
flowEndInTextRun
-
1
)
textStyle
)
;
}
}
void
nsTextFrame
:
:
AddInlinePrefISize
(
gfxContext
*
aRenderingContext
nsIFrame
:
:
InlinePrefISizeData
*
aData
)
{
float
inflation
=
nsLayoutUtils
:
:
FontSizeInflationFor
(
this
)
;
TextRunType
trtype
=
(
inflation
=
=
1
.
0f
)
?
eNotInflated
:
eInflated
;
if
(
trtype
=
=
eInflated
&
&
!
IsCurrentFontInflation
(
inflation
)
)
{
ClearTextRun
(
nullptr
nsTextFrame
:
:
eInflated
)
;
}
nsTextFrame
*
f
;
const
gfxTextRun
*
lastTextRun
=
nullptr
;
for
(
f
=
this
;
f
;
f
=
f
-
>
GetNextContinuation
(
)
)
{
if
(
f
=
=
this
|
|
f
-
>
GetTextRun
(
trtype
)
!
=
lastTextRun
)
{
nsIFrame
*
lc
;
if
(
aData
-
>
LineContainer
(
)
&
&
aData
-
>
LineContainer
(
)
!
=
(
lc
=
FindLineContainer
(
f
)
)
)
{
NS_ASSERTION
(
f
!
=
this
"
wrong
InlinePrefISizeData
container
"
"
for
first
continuation
"
)
;
aData
-
>
mLine
=
nullptr
;
aData
-
>
SetLineContainer
(
lc
)
;
}
f
-
>
AddInlinePrefISizeForFlow
(
aRenderingContext
aData
trtype
)
;
lastTextRun
=
f
-
>
GetTextRun
(
trtype
)
;
}
}
}
LogicalSize
nsTextFrame
:
:
ComputeSize
(
gfxContext
*
aRenderingContext
WritingMode
aWM
const
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
LogicalSize
&
aMargin
const
LogicalSize
&
aBorder
const
LogicalSize
&
aPadding
ComputeSizeFlags
aFlags
)
{
return
LogicalSize
(
aWM
NS_UNCONSTRAINEDSIZE
NS_UNCONSTRAINEDSIZE
)
;
}
static
nsRect
RoundOut
(
const
gfxRect
&
aRect
)
{
nsRect
r
;
r
.
x
=
NSToCoordFloor
(
aRect
.
X
(
)
)
;
r
.
y
=
NSToCoordFloor
(
aRect
.
Y
(
)
)
;
r
.
width
=
NSToCoordCeil
(
aRect
.
XMost
(
)
)
-
r
.
x
;
r
.
height
=
NSToCoordCeil
(
aRect
.
YMost
(
)
)
-
r
.
y
;
return
r
;
}
nsRect
nsTextFrame
:
:
ComputeTightBounds
(
DrawTarget
*
aDrawTarget
)
const
{
if
(
Style
(
)
-
>
HasTextDecorationLines
(
)
|
|
(
GetStateBits
(
)
&
TEXT_HYPHEN_BREAK
)
)
{
return
GetVisualOverflowRect
(
)
;
}
gfxSkipCharsIterator
iter
=
const_cast
<
nsTextFrame
*
>
(
this
)
-
>
EnsureTextRun
(
nsTextFrame
:
:
eInflated
)
;
if
(
!
mTextRun
)
return
nsRect
(
0
0
0
0
)
;
PropertyProvider
provider
(
const_cast
<
nsTextFrame
*
>
(
this
)
iter
nsTextFrame
:
:
eInflated
)
;
provider
.
InitializeForDisplay
(
true
)
;
gfxTextRun
:
:
Metrics
metrics
=
mTextRun
-
>
MeasureText
(
ComputeTransformedRange
(
provider
)
gfxFont
:
:
TIGHT_HINTED_OUTLINE_EXTENTS
aDrawTarget
&
provider
)
;
if
(
GetWritingMode
(
)
.
IsLineInverted
(
)
)
{
metrics
.
mBoundingBox
.
y
=
-
metrics
.
mBoundingBox
.
YMost
(
)
;
}
nsRect
boundingBox
=
RoundOut
(
metrics
.
mBoundingBox
)
;
boundingBox
+
=
nsPoint
(
0
mAscent
)
;
if
(
mTextRun
-
>
IsVertical
(
)
)
{
Swap
(
boundingBox
.
x
boundingBox
.
y
)
;
Swap
(
boundingBox
.
width
boundingBox
.
height
)
;
}
return
boundingBox
;
}
nsresult
nsTextFrame
:
:
GetPrefWidthTightBounds
(
gfxContext
*
aContext
nscoord
*
aX
nscoord
*
aXMost
)
{
gfxSkipCharsIterator
iter
=
const_cast
<
nsTextFrame
*
>
(
this
)
-
>
EnsureTextRun
(
nsTextFrame
:
:
eInflated
)
;
if
(
!
mTextRun
)
return
NS_ERROR_FAILURE
;
PropertyProvider
provider
(
const_cast
<
nsTextFrame
*
>
(
this
)
iter
nsTextFrame
:
:
eInflated
)
;
provider
.
InitializeForMeasure
(
)
;
gfxTextRun
:
:
Metrics
metrics
=
mTextRun
-
>
MeasureText
(
ComputeTransformedRange
(
provider
)
gfxFont
:
:
TIGHT_HINTED_OUTLINE_EXTENTS
aContext
-
>
GetDrawTarget
(
)
&
provider
)
;
*
aX
=
NSToCoordFloor
(
metrics
.
mBoundingBox
.
x
)
;
*
aXMost
=
NSToCoordCeil
(
metrics
.
mBoundingBox
.
XMost
(
)
)
;
return
NS_OK
;
}
static
bool
HasSoftHyphenBefore
(
const
nsTextFragment
*
aFrag
const
gfxTextRun
*
aTextRun
int32_t
aStartOffset
const
gfxSkipCharsIterator
&
aIter
)
{
if
(
aIter
.
GetSkippedOffset
(
)
<
aTextRun
-
>
GetLength
(
)
&
&
aTextRun
-
>
CanHyphenateBefore
(
aIter
.
GetSkippedOffset
(
)
)
)
{
return
true
;
}
if
(
!
(
aTextRun
-
>
GetFlags2
(
)
&
nsTextFrameUtils
:
:
Flags
:
:
TEXT_HAS_SHY
)
)
return
false
;
gfxSkipCharsIterator
iter
=
aIter
;
while
(
iter
.
GetOriginalOffset
(
)
>
aStartOffset
)
{
iter
.
AdvanceOriginal
(
-
1
)
;
if
(
!
iter
.
IsOriginalCharSkipped
(
)
)
break
;
if
(
aFrag
-
>
CharAt
(
iter
.
GetOriginalOffset
(
)
)
=
=
CH_SHY
)
return
true
;
}
return
false
;
}
static
void
RemoveEmptyInFlows
(
nsTextFrame
*
aFrame
nsTextFrame
*
aFirstToNotRemove
)
{
MOZ_ASSERT
(
aFrame
!
=
aFirstToNotRemove
"
This
will
go
very
badly
"
)
;
NS_ASSERTION
(
aFirstToNotRemove
-
>
GetPrevContinuation
(
)
=
=
aFirstToNotRemove
-
>
GetPrevInFlow
(
)
&
&
aFirstToNotRemove
-
>
GetPrevInFlow
(
)
!
=
nullptr
"
aFirstToNotRemove
should
have
a
fluid
prev
continuation
"
)
;
NS_ASSERTION
(
aFrame
-
>
GetPrevContinuation
(
)
=
=
aFrame
-
>
GetPrevInFlow
(
)
&
&
aFrame
-
>
GetPrevInFlow
(
)
!
=
nullptr
"
aFrame
should
have
a
fluid
prev
continuation
"
)
;
nsTextFrame
*
prevContinuation
=
aFrame
-
>
GetPrevContinuation
(
)
;
nsTextFrame
*
lastRemoved
=
aFirstToNotRemove
-
>
GetPrevContinuation
(
)
;
for
(
nsTextFrame
*
f
=
aFrame
;
f
!
=
aFirstToNotRemove
;
f
=
f
-
>
GetNextContinuation
(
)
)
{
if
(
f
-
>
IsInTextRunUserData
(
)
)
{
f
-
>
ClearTextRuns
(
)
;
}
else
{
f
-
>
DisconnectTextRuns
(
)
;
}
}
prevContinuation
-
>
SetNextInFlow
(
aFirstToNotRemove
)
;
aFirstToNotRemove
-
>
SetPrevInFlow
(
prevContinuation
)
;
aFrame
-
>
SetPrevInFlow
(
nullptr
)
;
lastRemoved
-
>
SetNextInFlow
(
nullptr
)
;
nsContainerFrame
*
parent
=
aFrame
-
>
GetParent
(
)
;
nsBlockFrame
*
parentBlock
=
nsLayoutUtils
:
:
GetAsBlock
(
parent
)
;
if
(
parentBlock
)
{
parentBlock
-
>
DoRemoveFrame
(
aFrame
nsBlockFrame
:
:
FRAMES_ARE_EMPTY
)
;
}
else
{
parent
-
>
RemoveFrame
(
nsIFrame
:
:
kNoReflowPrincipalList
aFrame
)
;
}
}
void
nsTextFrame
:
:
SetLength
(
int32_t
aLength
nsLineLayout
*
aLineLayout
uint32_t
aSetLengthFlags
)
{
mContentLengthHint
=
aLength
;
int32_t
end
=
GetContentOffset
(
)
+
aLength
;
nsTextFrame
*
f
=
GetNextInFlow
(
)
;
if
(
!
f
)
return
;
if
(
aLineLayout
&
&
(
end
!
=
f
-
>
mContentOffset
|
|
(
f
-
>
GetStateBits
(
)
&
NS_FRAME_IS_DIRTY
)
)
)
{
aLineLayout
-
>
SetDirtyNextLine
(
)
;
}
if
(
end
<
f
-
>
mContentOffset
)
{
if
(
aLineLayout
&
&
HasSignificantTerminalNewline
(
)
&
&
!
GetParent
(
)
-
>
IsLetterFrame
(
)
&
&
(
aSetLengthFlags
&
ALLOW_FRAME_CREATION_AND_DESTRUCTION
)
)
{
nsPresContext
*
presContext
=
PresContext
(
)
;
nsIFrame
*
newFrame
=
presContext
-
>
PresShell
(
)
-
>
FrameConstructor
(
)
-
>
CreateContinuingFrame
(
presContext
this
GetParent
(
)
)
;
nsTextFrame
*
next
=
static_cast
<
nsTextFrame
*
>
(
newFrame
)
;
nsFrameList
temp
(
next
next
)
;
GetParent
(
)
-
>
InsertFrames
(
kNoReflowPrincipalList
this
temp
)
;
f
=
next
;
}
f
-
>
mContentOffset
=
end
;
if
(
f
-
>
GetTextRun
(
nsTextFrame
:
:
eInflated
)
!
=
mTextRun
)
{
ClearTextRuns
(
)
;
f
-
>
ClearTextRuns
(
)
;
}
return
;
}
nsTextFrame
*
framesToRemove
=
nullptr
;
while
(
f
&
&
f
-
>
mContentOffset
<
end
)
{
f
-
>
mContentOffset
=
end
;
if
(
f
-
>
GetTextRun
(
nsTextFrame
:
:
eInflated
)
!
=
mTextRun
)
{
ClearTextRuns
(
)
;
f
-
>
ClearTextRuns
(
)
;
}
nsTextFrame
*
next
=
f
-
>
GetNextInFlow
(
)
;
if
(
next
&
&
next
-
>
mContentOffset
<
=
end
&
&
f
-
>
GetNextSibling
(
)
=
=
next
&
&
(
aSetLengthFlags
&
ALLOW_FRAME_CREATION_AND_DESTRUCTION
)
)
{
if
(
!
framesToRemove
)
{
framesToRemove
=
f
;
}
}
else
if
(
framesToRemove
)
{
RemoveEmptyInFlows
(
framesToRemove
f
)
;
framesToRemove
=
nullptr
;
}
f
=
next
;
}
MOZ_ASSERT
(
!
framesToRemove
|
|
(
f
&
&
f
-
>
mContentOffset
=
=
end
)
"
How
did
we
exit
the
loop
if
we
null
out
framesToRemove
if
"
"
!
next
|
|
next
-
>
mContentOffset
>
end
?
"
)
;
if
(
framesToRemove
)
{
RemoveEmptyInFlows
(
framesToRemove
f
)
;
}
#
ifdef
DEBUG
f
=
this
;
int32_t
iterations
=
0
;
while
(
f
&
&
iterations
<
10
)
{
f
-
>
GetContentLength
(
)
;
f
=
f
-
>
GetNextContinuation
(
)
;
+
+
iterations
;
}
f
=
this
;
iterations
=
0
;
while
(
f
&
&
iterations
<
10
)
{
f
-
>
GetContentLength
(
)
;
f
=
f
-
>
GetPrevContinuation
(
)
;
+
+
iterations
;
}
#
endif
}
bool
nsTextFrame
:
:
IsFloatingFirstLetterChild
(
)
const
{
nsIFrame
*
frame
=
GetParent
(
)
;
return
frame
&
&
frame
-
>
IsFloating
(
)
&
&
frame
-
>
IsLetterFrame
(
)
;
}
bool
nsTextFrame
:
:
IsInitialLetterChild
(
)
const
{
nsIFrame
*
frame
=
GetParent
(
)
;
return
frame
&
&
frame
-
>
StyleTextReset
(
)
-
>
mInitialLetterSize
!
=
0
.
0f
&
&
frame
-
>
IsLetterFrame
(
)
;
}
struct
NewlineProperty
{
int32_t
mStartOffset
;
int32_t
mNewlineOffset
;
}
;
void
nsTextFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aMetrics
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsTextFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aMetrics
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
if
(
!
aReflowInput
.
mLineLayout
)
{
ClearMetrics
(
aMetrics
)
;
return
;
}
ReflowText
(
*
aReflowInput
.
mLineLayout
aReflowInput
.
AvailableWidth
(
)
aReflowInput
.
mRenderingContext
-
>
GetDrawTarget
(
)
aMetrics
aStatus
)
;
NS_FRAME_SET_TRUNCATION
(
aStatus
aReflowInput
aMetrics
)
;
}
#
ifdef
ACCESSIBILITY
class
MOZ_STACK_CLASS
ReflowTextA11yNotifier
{
public
:
ReflowTextA11yNotifier
(
nsPresContext
*
aPresContext
nsIContent
*
aContent
)
:
mContent
(
aContent
)
mPresContext
(
aPresContext
)
{
}
~
ReflowTextA11yNotifier
(
)
{
nsAccessibilityService
*
accService
=
nsIPresShell
:
:
AccService
(
)
;
if
(
accService
)
{
accService
-
>
UpdateText
(
mPresContext
-
>
PresShell
(
)
mContent
)
;
}
}
private
:
ReflowTextA11yNotifier
(
)
;
ReflowTextA11yNotifier
(
const
ReflowTextA11yNotifier
&
)
;
ReflowTextA11yNotifier
&
operator
=
(
const
ReflowTextA11yNotifier
&
)
;
nsIContent
*
mContent
;
nsPresContext
*
mPresContext
;
}
;
#
endif
void
nsTextFrame
:
:
ReflowText
(
nsLineLayout
&
aLineLayout
nscoord
aAvailableWidth
DrawTarget
*
aDrawTarget
ReflowOutput
&
aMetrics
nsReflowStatus
&
aStatus
)
{
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
#
ifdef
NOISY_REFLOW
ListTag
(
stdout
)
;
printf
(
"
:
BeginReflow
:
availableWidth
=
%
d
\
n
"
aAvailableWidth
)
;
#
endif
nsPresContext
*
presContext
=
PresContext
(
)
;
#
ifdef
ACCESSIBILITY
if
(
StyleVisibility
(
)
-
>
IsVisible
(
)
)
{
ReflowTextA11yNotifier
(
presContext
mContent
)
;
}
#
endif
RemoveStateBits
(
TEXT_REFLOW_FLAGS
|
TEXT_WHITESPACE_FLAGS
)
;
mReflowRequestedForCharDataChange
=
false
;
int32_t
maxContentLength
=
GetInFlowContentLength
(
)
;
if
(
!
maxContentLength
)
{
ClearMetrics
(
aMetrics
)
;
return
;
}
#
ifdef
NOISY_BIDI
printf
(
"
Reflowed
textframe
\
n
"
)
;
#
endif
const
nsStyleText
*
textStyle
=
StyleText
(
)
;
bool
atStartOfLine
=
aLineLayout
.
LineAtStart
(
)
;
if
(
atStartOfLine
)
{
AddStateBits
(
TEXT_START_OF_LINE
)
;
}
uint32_t
flowEndInTextRun
;
nsIFrame
*
lineContainer
=
aLineLayout
.
LineContainerFrame
(
)
;
const
nsTextFragment
*
frag
=
mContent
-
>
GetText
(
)
;
int32_t
length
=
maxContentLength
;
int32_t
offset
=
GetContentOffset
(
)
;
int32_t
newLineOffset
=
-
1
;
int32_t
contentNewLineOffset
=
-
1
;
NewlineProperty
*
cachedNewlineOffset
=
nullptr
;
if
(
textStyle
-
>
NewlineIsSignificant
(
this
)
)
{
cachedNewlineOffset
=
mContent
-
>
HasFlag
(
NS_HAS_NEWLINE_PROPERTY
)
?
static_cast
<
NewlineProperty
*
>
(
mContent
-
>
GetProperty
(
nsGkAtoms
:
:
newline
)
)
:
nullptr
;
if
(
cachedNewlineOffset
&
&
cachedNewlineOffset
-
>
mStartOffset
<
=
offset
&
&
(
cachedNewlineOffset
-
>
mNewlineOffset
=
=
-
1
|
|
cachedNewlineOffset
-
>
mNewlineOffset
>
=
offset
)
)
{
contentNewLineOffset
=
cachedNewlineOffset
-
>
mNewlineOffset
;
}
else
{
contentNewLineOffset
=
FindChar
(
frag
offset
mContent
-
>
TextLength
(
)
-
offset
'
\
n
'
)
;
}
if
(
contentNewLineOffset
<
offset
+
length
)
{
newLineOffset
=
contentNewLineOffset
;
}
if
(
newLineOffset
>
=
0
)
{
length
=
newLineOffset
+
1
-
offset
;
}
}
if
(
(
atStartOfLine
&
&
!
textStyle
-
>
WhiteSpaceIsSignificant
(
)
)
|
|
(
GetStateBits
(
)
&
TEXT_IS_IN_TOKEN_MATHML
)
)
{
int32_t
skipLength
=
newLineOffset
>
=
0
?
length
-
1
:
length
;
int32_t
whitespaceCount
=
GetTrimmableWhitespaceCount
(
frag
offset
skipLength
1
)
;
if
(
whitespaceCount
)
{
offset
+
=
whitespaceCount
;
length
-
=
whitespaceCount
;
if
(
MOZ_UNLIKELY
(
offset
>
GetContentEnd
(
)
)
)
{
SetLength
(
offset
-
GetContentOffset
(
)
&
aLineLayout
ALLOW_FRAME_CREATION_AND_DESTRUCTION
)
;
}
}
}
if
(
length
=
=
0
)
{
ClearMetrics
(
aMetrics
)
;
return
;
}
bool
completedFirstLetter
=
false
;
if
(
aLineLayout
.
GetInFirstLetter
(
)
|
|
aLineLayout
.
GetInFirstLine
(
)
)
{
SetLength
(
maxContentLength
&
aLineLayout
ALLOW_FRAME_CREATION_AND_DESTRUCTION
)
;
if
(
aLineLayout
.
GetInFirstLetter
(
)
)
{
ClearTextRuns
(
)
;
gfxSkipCharsIterator
iter
=
EnsureTextRun
(
nsTextFrame
:
:
eInflated
aDrawTarget
lineContainer
aLineLayout
.
GetLine
(
)
&
flowEndInTextRun
)
;
if
(
mTextRun
)
{
int32_t
firstLetterLength
=
length
;
if
(
aLineLayout
.
GetFirstLetterStyleOK
(
)
)
{
completedFirstLetter
=
FindFirstLetterRange
(
frag
mTextRun
offset
iter
&
firstLetterLength
)
;
if
(
newLineOffset
>
=
0
)
{
firstLetterLength
=
std
:
:
min
(
firstLetterLength
length
-
1
)
;
if
(
length
=
=
1
)
{
completedFirstLetter
=
true
;
}
}
}
else
{
firstLetterLength
=
0
;
completedFirstLetter
=
true
;
}
length
=
firstLetterLength
;
if
(
length
)
{
AddStateBits
(
TEXT_FIRST_LETTER
)
;
}
SetLength
(
offset
+
length
-
GetContentOffset
(
)
&
aLineLayout
ALLOW_FRAME_CREATION_AND_DESTRUCTION
)
;
ClearTextRuns
(
)
;
}
}
}
float
fontSizeInflation
=
nsLayoutUtils
:
:
FontSizeInflationFor
(
this
)
;
if
(
!
IsCurrentFontInflation
(
fontSizeInflation
)
)
{
ClearTextRun
(
nullptr
nsTextFrame
:
:
eInflated
)
;
}
gfxSkipCharsIterator
iter
=
EnsureTextRun
(
nsTextFrame
:
:
eInflated
aDrawTarget
lineContainer
aLineLayout
.
GetLine
(
)
&
flowEndInTextRun
)
;
NS_ASSERTION
(
IsCurrentFontInflation
(
fontSizeInflation
)
"
EnsureTextRun
should
have
set
font
size
inflation
"
)
;
if
(
mTextRun
&
&
iter
.
GetOriginalEnd
(
)
<
offset
+
length
)
{
ClearTextRuns
(
)
;
iter
=
EnsureTextRun
(
nsTextFrame
:
:
eInflated
aDrawTarget
lineContainer
aLineLayout
.
GetLine
(
)
&
flowEndInTextRun
)
;
}
if
(
!
mTextRun
)
{
ClearMetrics
(
aMetrics
)
;
return
;
}
NS_ASSERTION
(
gfxSkipCharsIterator
(
iter
)
.
ConvertOriginalToSkipped
(
offset
+
length
)
<
=
mTextRun
-
>
GetLength
(
)
"
Text
run
does
not
map
enough
text
for
our
reflow
"
)
;
iter
.
SetOriginalOffset
(
offset
)
;
nscoord
xOffsetForTabs
=
(
mTextRun
-
>
GetFlags2
(
)
&
nsTextFrameUtils
:
:
Flags
:
:
TEXT_HAS_TAB
)
?
(
aLineLayout
.
GetCurrentFrameInlineDistanceFromBlock
(
)
-
lineContainer
-
>
GetUsedBorderAndPadding
(
)
.
left
)
:
-
1
;
PropertyProvider
provider
(
mTextRun
textStyle
frag
this
iter
length
lineContainer
xOffsetForTabs
nsTextFrame
:
:
eInflated
)
;
uint32_t
transformedOffset
=
provider
.
GetStart
(
)
.
GetSkippedOffset
(
)
;
gfxTextRun
:
:
Metrics
textMetrics
;
gfxFont
:
:
BoundingBoxType
boundingBoxType
=
IsFloatingFirstLetterChild
(
)
|
|
IsInitialLetterChild
(
)
?
gfxFont
:
:
TIGHT_HINTED_OUTLINE_EXTENTS
:
gfxFont
:
:
LOOSE_INK_EXTENTS
;
int32_t
limitLength
=
length
;
int32_t
forceBreak
=
aLineLayout
.
GetForcedBreakPosition
(
this
)
;
bool
forceBreakAfter
=
false
;
if
(
forceBreak
>
=
length
)
{
forceBreakAfter
=
forceBreak
=
=
length
;
forceBreak
=
-
1
;
}
if
(
forceBreak
>
=
0
)
{
limitLength
=
forceBreak
;
}
uint32_t
transformedLength
;
if
(
offset
+
limitLength
>
=
int32_t
(
frag
-
>
GetLength
(
)
)
)
{
NS_ASSERTION
(
offset
+
limitLength
=
=
int32_t
(
frag
-
>
GetLength
(
)
)
"
Content
offset
/
length
out
of
bounds
"
)
;
NS_ASSERTION
(
flowEndInTextRun
>
=
transformedOffset
"
Negative
flow
length
?
"
)
;
transformedLength
=
flowEndInTextRun
-
transformedOffset
;
}
else
{
gfxSkipCharsIterator
iter
(
provider
.
GetStart
(
)
)
;
iter
.
SetOriginalOffset
(
offset
+
limitLength
)
;
transformedLength
=
iter
.
GetSkippedOffset
(
)
-
transformedOffset
;
}
uint32_t
transformedLastBreak
=
0
;
bool
usedHyphenation
;
gfxFloat
trimmedWidth
=
0
;
gfxFloat
availWidth
=
aAvailableWidth
;
if
(
Style
(
)
-
>
IsTextCombined
(
)
)
{
availWidth
=
std
:
:
numeric_limits
<
gfxFloat
>
:
:
infinity
(
)
;
}
bool
canTrimTrailingWhitespace
=
!
textStyle
-
>
WhiteSpaceIsSignificant
(
)
|
|
(
GetStateBits
(
)
&
TEXT_IS_IN_TOKEN_MATHML
)
;
bool
whitespaceCanHang
=
textStyle
-
>
WhiteSpaceCanWrapStyle
(
)
&
&
textStyle
-
>
WhiteSpaceIsSignificant
(
)
;
gfxBreakPriority
breakPriority
=
aLineLayout
.
LastOptionalBreakPriority
(
)
;
gfxTextRun
:
:
SuppressBreak
suppressBreak
=
gfxTextRun
:
:
eNoSuppressBreak
;
bool
shouldSuppressLineBreak
=
ShouldSuppressLineBreak
(
)
;
if
(
shouldSuppressLineBreak
)
{
suppressBreak
=
gfxTextRun
:
:
eSuppressAllBreaks
;
}
else
if
(
!
aLineLayout
.
LineIsBreakable
(
)
)
{
suppressBreak
=
gfxTextRun
:
:
eSuppressInitialBreak
;
}
uint32_t
transformedCharsFit
=
mTextRun
-
>
BreakAndMeasureText
(
transformedOffset
transformedLength
(
GetStateBits
(
)
&
TEXT_START_OF_LINE
)
!
=
0
availWidth
&
provider
suppressBreak
canTrimTrailingWhitespace
?
&
trimmedWidth
:
nullptr
whitespaceCanHang
&
textMetrics
boundingBoxType
aDrawTarget
&
usedHyphenation
&
transformedLastBreak
textStyle
-
>
WordCanWrap
(
this
)
&
breakPriority
)
;
if
(
!
length
&
&
!
textMetrics
.
mAscent
&
&
!
textMetrics
.
mDescent
)
{
nsFontMetrics
*
fm
=
provider
.
GetFontMetrics
(
)
;
if
(
fm
)
{
textMetrics
.
mAscent
=
gfxFloat
(
fm
-
>
MaxAscent
(
)
)
;
textMetrics
.
mDescent
=
gfxFloat
(
fm
-
>
MaxDescent
(
)
)
;
}
}
if
(
GetWritingMode
(
)
.
IsLineInverted
(
)
)
{
Swap
(
textMetrics
.
mAscent
textMetrics
.
mDescent
)
;
textMetrics
.
mBoundingBox
.
y
=
-
textMetrics
.
mBoundingBox
.
YMost
(
)
;
}
gfxSkipCharsIterator
end
(
provider
.
GetEndHint
(
)
)
;
end
.
SetSkippedOffset
(
transformedOffset
+
transformedCharsFit
)
;
int32_t
charsFit
=
end
.
GetOriginalOffset
(
)
-
offset
;
if
(
offset
+
charsFit
=
=
newLineOffset
)
{
+
+
charsFit
;
}
int32_t
lastBreak
=
-
1
;
if
(
charsFit
>
=
limitLength
)
{
charsFit
=
limitLength
;
if
(
transformedLastBreak
!
=
UINT32_MAX
)
{
lastBreak
=
end
.
ConvertSkippedToOriginal
(
transformedOffset
+
transformedLastBreak
)
;
}
end
.
SetOriginalOffset
(
offset
+
charsFit
)
;
if
(
(
forceBreak
>
=
0
|
|
forceBreakAfter
)
&
&
HasSoftHyphenBefore
(
frag
mTextRun
offset
end
)
)
{
usedHyphenation
=
true
;
}
}
if
(
usedHyphenation
)
{
AddHyphenToMetrics
(
this
mTextRun
&
textMetrics
boundingBoxType
aDrawTarget
)
;
AddStateBits
(
TEXT_HYPHEN_BREAK
|
TEXT_HAS_NONCOLLAPSED_CHARACTERS
)
;
}
if
(
textMetrics
.
mBoundingBox
.
IsEmpty
(
)
)
{
AddStateBits
(
TEXT_NO_RENDERED_GLYPHS
)
;
}
gfxFloat
trimmableWidth
=
0
;
bool
brokeText
=
forceBreak
>
=
0
|
|
transformedCharsFit
<
transformedLength
;
if
(
canTrimTrailingWhitespace
)
{
if
(
brokeText
|
|
(
GetStateBits
(
)
&
TEXT_IS_IN_TOKEN_MATHML
)
)
{
AddStateBits
(
TEXT_TRIMMED_TRAILING_WHITESPACE
)
;
}
else
if
(
!
(
GetStateBits
(
)
&
TEXT_IS_IN_TOKEN_MATHML
)
)
{
textMetrics
.
mAdvanceWidth
+
=
trimmedWidth
;
trimmableWidth
=
trimmedWidth
;
if
(
mTextRun
-
>
IsRightToLeft
(
)
)
{
textMetrics
.
mBoundingBox
.
MoveBy
(
gfxPoint
(
trimmedWidth
0
)
)
;
}
}
}
if
(
!
brokeText
&
&
lastBreak
>
=
0
)
{
NS_ASSERTION
(
textMetrics
.
mAdvanceWidth
-
trimmableWidth
<
=
availWidth
"
If
the
text
doesn
'
t
fit
and
we
have
a
break
opportunity
why
didn
'
t
MeasureText
use
it
?
"
)
;
MOZ_ASSERT
(
lastBreak
>
=
offset
"
Strange
break
position
"
)
;
aLineLayout
.
NotifyOptionalBreakPosition
(
this
lastBreak
-
offset
true
breakPriority
)
;
}
int32_t
contentLength
=
offset
+
charsFit
-
GetContentOffset
(
)
;
if
(
GetStateBits
(
)
&
TEXT_FIRST_LETTER
)
{
textMetrics
.
mAscent
=
std
:
:
max
(
gfxFloat
(
0
.
0
)
-
textMetrics
.
mBoundingBox
.
Y
(
)
)
;
textMetrics
.
mDescent
=
std
:
:
max
(
gfxFloat
(
0
.
0
)
textMetrics
.
mBoundingBox
.
YMost
(
)
)
;
}
WritingMode
wm
=
GetWritingMode
(
)
;
LogicalSize
finalSize
(
wm
)
;
finalSize
.
ISize
(
wm
)
=
NSToCoordCeil
(
std
:
:
max
(
gfxFloat
(
0
.
0
)
textMetrics
.
mAdvanceWidth
)
)
;
if
(
transformedCharsFit
=
=
0
&
&
!
usedHyphenation
)
{
aMetrics
.
SetBlockStartAscent
(
0
)
;
finalSize
.
BSize
(
wm
)
=
0
;
}
else
if
(
boundingBoxType
!
=
gfxFont
:
:
LOOSE_INK_EXTENTS
)
{
aMetrics
.
SetBlockStartAscent
(
NSToCoordCeil
(
textMetrics
.
mAscent
)
)
;
finalSize
.
BSize
(
wm
)
=
aMetrics
.
BlockStartAscent
(
)
+
NSToCoordCeil
(
textMetrics
.
mDescent
)
;
}
else
{
nsFontMetrics
*
fm
=
provider
.
GetFontMetrics
(
)
;
nscoord
fontAscent
=
wm
.
IsLineInverted
(
)
?
fm
-
>
MaxDescent
(
)
:
fm
-
>
MaxAscent
(
)
;
nscoord
fontDescent
=
wm
.
IsLineInverted
(
)
?
fm
-
>
MaxAscent
(
)
:
fm
-
>
MaxDescent
(
)
;
aMetrics
.
SetBlockStartAscent
(
std
:
:
max
(
NSToCoordCeil
(
textMetrics
.
mAscent
)
fontAscent
)
)
;
nscoord
descent
=
std
:
:
max
(
NSToCoordCeil
(
textMetrics
.
mDescent
)
fontDescent
)
;
finalSize
.
BSize
(
wm
)
=
aMetrics
.
BlockStartAscent
(
)
+
descent
;
}
if
(
Style
(
)
-
>
IsTextCombined
(
)
)
{
nsFontMetrics
*
fm
=
provider
.
GetFontMetrics
(
)
;
gfxFloat
width
=
finalSize
.
ISize
(
wm
)
;
gfxFloat
em
=
fm
-
>
EmHeight
(
)
;
if
(
width
<
=
em
)
{
RemoveProperty
(
TextCombineScaleFactorProperty
(
)
)
;
}
else
{
SetProperty
(
TextCombineScaleFactorProperty
(
)
em
/
width
)
;
finalSize
.
ISize
(
wm
)
=
em
;
}
if
(
finalSize
.
BSize
(
wm
)
!
=
em
)
{
aMetrics
.
SetBlockStartAscent
(
aMetrics
.
BlockStartAscent
(
)
+
(
em
-
finalSize
.
BSize
(
wm
)
)
/
2
)
;
finalSize
.
BSize
(
wm
)
=
em
;
}
}
aMetrics
.
SetSize
(
wm
finalSize
)
;
NS_ASSERTION
(
aMetrics
.
BlockStartAscent
(
)
>
=
0
"
Negative
ascent
?
?
?
"
)
;
NS_ASSERTION
(
(
Style
(
)
-
>
IsTextCombined
(
)
?
aMetrics
.
ISize
(
aMetrics
.
GetWritingMode
(
)
)
:
aMetrics
.
BSize
(
aMetrics
.
GetWritingMode
(
)
)
)
-
aMetrics
.
BlockStartAscent
(
)
>
=
0
"
Negative
descent
?
?
?
"
)
;
mAscent
=
aMetrics
.
BlockStartAscent
(
)
;
nsRect
boundingBox
=
RoundOut
(
textMetrics
.
mBoundingBox
)
;
if
(
mTextRun
-
>
IsVertical
(
)
)
{
Swap
(
boundingBox
.
x
boundingBox
.
y
)
;
Swap
(
boundingBox
.
width
boundingBox
.
height
)
;
if
(
GetWritingMode
(
)
.
IsVerticalRL
(
)
)
{
boundingBox
.
x
=
-
boundingBox
.
XMost
(
)
;
boundingBox
.
x
+
=
aMetrics
.
Width
(
)
-
mAscent
;
}
else
{
boundingBox
.
x
+
=
mAscent
;
}
}
else
{
boundingBox
.
y
+
=
mAscent
;
}
aMetrics
.
SetOverflowAreasToDesiredBounds
(
)
;
aMetrics
.
VisualOverflow
(
)
.
UnionRect
(
aMetrics
.
VisualOverflow
(
)
boundingBox
)
;
UnionAdditionalOverflow
(
presContext
aLineLayout
.
LineContainerRI
(
)
-
>
mFrame
provider
&
aMetrics
.
VisualOverflow
(
)
false
)
;
if
(
transformedCharsFit
>
0
)
{
aLineLayout
.
SetTrimmableISize
(
NSToCoordFloor
(
trimmableWidth
)
)
;
AddStateBits
(
TEXT_HAS_NONCOLLAPSED_CHARACTERS
)
;
}
bool
breakAfter
=
forceBreakAfter
;
if
(
!
shouldSuppressLineBreak
)
{
if
(
charsFit
>
0
&
&
charsFit
=
=
length
&
&
textStyle
-
>
mHyphens
!
=
StyleHyphens
:
:
None
&
&
HasSoftHyphenBefore
(
frag
mTextRun
offset
end
)
)
{
bool
fits
=
textMetrics
.
mAdvanceWidth
+
provider
.
GetHyphenWidth
(
)
<
=
availWidth
;
aLineLayout
.
NotifyOptionalBreakPosition
(
this
length
fits
gfxBreakPriority
:
:
eNormalBreak
)
;
}
bool
emptyTextAtStartOfLine
=
atStartOfLine
&
&
length
=
=
0
;
if
(
!
breakAfter
&
&
charsFit
=
=
length
&
&
!
emptyTextAtStartOfLine
&
&
transformedOffset
+
transformedLength
=
=
mTextRun
-
>
GetLength
(
)
&
&
(
mTextRun
-
>
GetFlags2
(
)
&
nsTextFrameUtils
:
:
Flags
:
:
TEXT_HAS_TRAILING_BREAK
)
)
{
if
(
textMetrics
.
mAdvanceWidth
-
trimmableWidth
>
availWidth
)
{
breakAfter
=
true
;
}
else
{
aLineLayout
.
NotifyOptionalBreakPosition
(
this
length
true
gfxBreakPriority
:
:
eNormalBreak
)
;
}
}
}
if
(
contentLength
!
=
maxContentLength
)
{
aStatus
.
SetIncomplete
(
)
;
}
if
(
charsFit
=
=
0
&
&
length
>
0
&
&
!
usedHyphenation
)
{
aStatus
.
SetInlineLineBreakBeforeAndReset
(
)
;
}
else
if
(
contentLength
>
0
&
&
mContentOffset
+
contentLength
-
1
=
=
newLineOffset
)
{
aStatus
.
SetInlineLineBreakAfter
(
)
;
aLineLayout
.
SetLineEndsInBR
(
true
)
;
}
else
if
(
breakAfter
)
{
aStatus
.
SetInlineLineBreakAfter
(
)
;
}
if
(
completedFirstLetter
)
{
aLineLayout
.
SetFirstLetterStyleOK
(
false
)
;
aStatus
.
SetFirstLetterComplete
(
)
;
}
if
(
contentLength
<
maxContentLength
&
&
textStyle
-
>
NewlineIsSignificant
(
this
)
&
&
(
contentNewLineOffset
<
0
|
|
mContentOffset
+
contentLength
<
=
contentNewLineOffset
)
)
{
if
(
!
cachedNewlineOffset
)
{
cachedNewlineOffset
=
new
NewlineProperty
;
if
(
NS_FAILED
(
mContent
-
>
SetProperty
(
nsGkAtoms
:
:
newline
cachedNewlineOffset
nsINode
:
:
DeleteProperty
<
NewlineProperty
>
)
)
)
{
delete
cachedNewlineOffset
;
cachedNewlineOffset
=
nullptr
;
}
mContent
-
>
SetFlags
(
NS_HAS_NEWLINE_PROPERTY
)
;
}
if
(
cachedNewlineOffset
)
{
cachedNewlineOffset
-
>
mStartOffset
=
offset
;
cachedNewlineOffset
-
>
mNewlineOffset
=
contentNewLineOffset
;
}
}
else
if
(
cachedNewlineOffset
)
{
mContent
-
>
DeleteProperty
(
nsGkAtoms
:
:
newline
)
;
mContent
-
>
UnsetFlags
(
NS_HAS_NEWLINE_PROPERTY
)
;
}
if
(
!
textStyle
-
>
WhiteSpaceIsSignificant
(
)
&
&
(
lineContainer
-
>
StyleText
(
)
-
>
mTextAlign
=
=
NS_STYLE_TEXT_ALIGN_JUSTIFY
|
|
lineContainer
-
>
StyleText
(
)
-
>
mTextAlignLast
=
=
NS_STYLE_TEXT_ALIGN_JUSTIFY
|
|
shouldSuppressLineBreak
)
&
&
!
nsSVGUtils
:
:
IsInSVGTextSubtree
(
lineContainer
)
)
{
AddStateBits
(
TEXT_JUSTIFICATION_ENABLED
)
;
Range
range
(
uint32_t
(
offset
)
uint32_t
(
offset
+
charsFit
)
)
;
aLineLayout
.
SetJustificationInfo
(
provider
.
ComputeJustification
(
range
)
)
;
}
SetLength
(
contentLength
&
aLineLayout
ALLOW_FRAME_CREATION_AND_DESTRUCTION
)
;
InvalidateFrame
(
)
;
#
ifdef
NOISY_REFLOW
ListTag
(
stdout
)
;
printf
(
"
:
desiredSize
=
%
d
%
d
(
b
=
%
d
)
status
=
%
x
\
n
"
aMetrics
.
Width
(
)
aMetrics
.
Height
(
)
aMetrics
.
BlockStartAscent
(
)
aStatus
)
;
#
endif
}
bool
nsTextFrame
:
:
CanContinueTextRun
(
)
const
{
return
true
;
}
nsTextFrame
:
:
TrimOutput
nsTextFrame
:
:
TrimTrailingWhiteSpace
(
DrawTarget
*
aDrawTarget
)
{
MOZ_ASSERT
(
!
HasAnyStateBits
(
NS_FRAME_IS_DIRTY
|
NS_FRAME_FIRST_REFLOW
)
"
frame
should
have
been
reflowed
"
)
;
TrimOutput
result
;
result
.
mChanged
=
false
;
result
.
mDeltaWidth
=
0
;
AddStateBits
(
TEXT_END_OF_LINE
)
;
if
(
!
GetTextRun
(
nsTextFrame
:
:
eInflated
)
)
{
return
result
;
}
int32_t
contentLength
=
GetContentLength
(
)
;
if
(
!
contentLength
)
return
result
;
gfxSkipCharsIterator
start
=
EnsureTextRun
(
nsTextFrame
:
:
eInflated
aDrawTarget
)
;
NS_ENSURE_TRUE
(
mTextRun
result
)
;
uint32_t
trimmedStart
=
start
.
GetSkippedOffset
(
)
;
const
nsTextFragment
*
frag
=
mContent
-
>
GetText
(
)
;
TrimmedOffsets
trimmed
=
GetTrimmedOffsets
(
frag
true
)
;
gfxSkipCharsIterator
trimmedEndIter
=
start
;
const
nsStyleText
*
textStyle
=
StyleText
(
)
;
gfxFloat
delta
=
0
;
uint32_t
trimmedEnd
=
trimmedEndIter
.
ConvertOriginalToSkipped
(
trimmed
.
GetEnd
(
)
)
;
if
(
!
(
GetStateBits
(
)
&
TEXT_TRIMMED_TRAILING_WHITESPACE
)
&
&
trimmed
.
GetEnd
(
)
<
GetContentEnd
(
)
)
{
gfxSkipCharsIterator
end
=
trimmedEndIter
;
uint32_t
endOffset
=
end
.
ConvertOriginalToSkipped
(
GetContentOffset
(
)
+
contentLength
)
;
if
(
trimmedEnd
<
endOffset
)
{
PropertyProvider
provider
(
mTextRun
textStyle
frag
this
start
contentLength
nullptr
0
nsTextFrame
:
:
eInflated
)
;
delta
=
mTextRun
-
>
GetAdvanceWidth
(
Range
(
trimmedEnd
endOffset
)
&
provider
)
;
result
.
mChanged
=
true
;
}
}
gfxFloat
advanceDelta
;
mTextRun
-
>
SetLineBreaks
(
Range
(
trimmedStart
trimmedEnd
)
(
GetStateBits
(
)
&
TEXT_START_OF_LINE
)
!
=
0
true
&
advanceDelta
)
;
if
(
advanceDelta
!
=
0
)
{
result
.
mChanged
=
true
;
}
result
.
mDeltaWidth
=
NSToCoordFloor
(
delta
-
advanceDelta
)
;
NS_WARNING_ASSERTION
(
result
.
mDeltaWidth
>
=
0
"
Negative
deltawidth
something
odd
is
happening
"
)
;
#
ifdef
NOISY_TRIM
ListTag
(
stdout
)
;
printf
(
"
:
trim
=
>
%
d
\
n
"
result
.
mDeltaWidth
)
;
#
endif
return
result
;
}
nsOverflowAreas
nsTextFrame
:
:
RecomputeOverflow
(
nsIFrame
*
aBlockFrame
)
{
nsRect
bounds
(
nsPoint
(
0
0
)
GetSize
(
)
)
;
nsOverflowAreas
result
(
bounds
bounds
)
;
gfxSkipCharsIterator
iter
=
EnsureTextRun
(
nsTextFrame
:
:
eInflated
)
;
if
(
!
mTextRun
)
return
result
;
PropertyProvider
provider
(
this
iter
nsTextFrame
:
:
eInflated
)
;
provider
.
InitializeForDisplay
(
false
)
;
gfxTextRun
:
:
Metrics
textMetrics
=
mTextRun
-
>
MeasureText
(
ComputeTransformedRange
(
provider
)
gfxFont
:
:
LOOSE_INK_EXTENTS
nullptr
&
provider
)
;
if
(
GetWritingMode
(
)
.
IsLineInverted
(
)
)
{
textMetrics
.
mBoundingBox
.
y
=
-
textMetrics
.
mBoundingBox
.
YMost
(
)
;
}
nsRect
boundingBox
=
RoundOut
(
textMetrics
.
mBoundingBox
)
;
boundingBox
+
=
nsPoint
(
0
mAscent
)
;
if
(
mTextRun
-
>
IsVertical
(
)
)
{
Swap
(
boundingBox
.
x
boundingBox
.
y
)
;
Swap
(
boundingBox
.
width
boundingBox
.
height
)
;
}
nsRect
&
vis
=
result
.
VisualOverflow
(
)
;
vis
.
UnionRect
(
vis
boundingBox
)
;
UnionAdditionalOverflow
(
PresContext
(
)
aBlockFrame
provider
&
vis
true
)
;
return
result
;
}
static
void
TransformChars
(
nsTextFrame
*
aFrame
const
nsStyleText
*
aStyle
const
gfxTextRun
*
aTextRun
uint32_t
aSkippedOffset
const
nsTextFragment
*
aFrag
int32_t
aFragOffset
int32_t
aFragLen
nsAString
&
aOut
)
{
nsAutoString
fragString
;
char16_t
*
out
;
if
(
aStyle
-
>
mTextTransform
=
=
NS_STYLE_TEXT_TRANSFORM_NONE
)
{
aOut
.
SetLength
(
aOut
.
Length
(
)
+
aFragLen
)
;
out
=
aOut
.
EndWriting
(
)
-
aFragLen
;
}
else
{
fragString
.
SetLength
(
aFragLen
)
;
out
=
fragString
.
BeginWriting
(
)
;
}
for
(
int32_t
i
=
0
;
i
<
aFragLen
;
+
+
i
)
{
char16_t
ch
=
aFrag
-
>
CharAt
(
aFragOffset
+
i
)
;
if
(
(
ch
=
=
'
\
n
'
&
&
!
aStyle
-
>
NewlineIsSignificant
(
aFrame
)
)
|
|
(
ch
=
=
'
\
t
'
&
&
!
aStyle
-
>
TabIsSignificant
(
)
)
)
{
ch
=
'
'
;
}
out
[
i
]
=
ch
;
}
if
(
aStyle
-
>
mTextTransform
!
=
NS_STYLE_TEXT_TRANSFORM_NONE
)
{
MOZ_ASSERT
(
aTextRun
-
>
GetFlags2
(
)
&
nsTextFrameUtils
:
:
Flags
:
:
TEXT_IS_TRANSFORMED
)
;
if
(
aTextRun
-
>
GetFlags2
(
)
&
nsTextFrameUtils
:
:
Flags
:
:
TEXT_IS_TRANSFORMED
)
{
auto
transformedTextRun
=
static_cast
<
const
nsTransformedTextRun
*
>
(
aTextRun
)
;
nsAutoString
convertedString
;
AutoTArray
<
bool
50
>
charsToMergeArray
;
AutoTArray
<
bool
50
>
deletedCharsArray
;
nsCaseTransformTextRunFactory
:
:
TransformString
(
fragString
convertedString
false
nullptr
charsToMergeArray
deletedCharsArray
transformedTextRun
aSkippedOffset
)
;
aOut
.
Append
(
convertedString
)
;
}
else
{
aOut
.
Append
(
fragString
)
;
}
}
}
static
bool
LineEndsInHardLineBreak
(
nsTextFrame
*
aFrame
nsBlockFrame
*
aLineContainer
)
{
bool
foundValidLine
;
nsBlockInFlowLineIterator
iter
(
aLineContainer
aFrame
&
foundValidLine
)
;
if
(
!
foundValidLine
)
{
NS_ERROR
(
"
Invalid
line
!
"
)
;
return
true
;
}
return
!
iter
.
GetLine
(
)
-
>
IsLineWrapped
(
)
;
}
nsIFrame
:
:
RenderedText
nsTextFrame
:
:
GetRenderedText
(
uint32_t
aStartOffset
uint32_t
aEndOffset
TextOffsetType
aOffsetType
TrailingWhitespace
aTrimTrailingWhitespace
)
{
MOZ_ASSERT
(
aStartOffset
<
=
aEndOffset
"
bogus
offsets
"
)
;
MOZ_ASSERT
(
!
GetPrevContinuation
(
)
|
|
(
aOffsetType
=
=
TextOffsetType
:
:
OFFSETS_IN_CONTENT_TEXT
&
&
aStartOffset
>
=
(
uint32_t
)
GetContentOffset
(
)
&
&
aEndOffset
<
=
(
uint32_t
)
GetContentEnd
(
)
)
"
Must
be
called
on
first
-
in
-
flow
or
content
offsets
must
be
"
"
given
and
be
within
this
frame
.
"
)
;
RenderedText
result
;
nsBlockFrame
*
lineContainer
=
nullptr
;
nsTextFrame
*
textFrame
;
const
nsTextFragment
*
textFrag
=
mContent
-
>
GetText
(
)
;
uint32_t
offsetInRenderedString
=
0
;
bool
haveOffsets
=
false
;
Maybe
<
nsBlockFrame
:
:
AutoLineCursorSetup
>
autoLineCursor
;
for
(
textFrame
=
this
;
textFrame
;
textFrame
=
textFrame
-
>
GetNextContinuation
(
)
)
{
if
(
textFrame
-
>
GetStateBits
(
)
&
NS_FRAME_IS_DIRTY
)
{
break
;
}
gfxSkipCharsIterator
iter
=
textFrame
-
>
EnsureTextRun
(
nsTextFrame
:
:
eInflated
)
;
if
(
!
textFrame
-
>
mTextRun
)
{
break
;
}
gfxSkipCharsIterator
tmpIter
=
iter
;
bool
trimAfter
;
if
(
!
textFrame
-
>
IsAtEndOfLine
(
)
|
|
aTrimTrailingWhitespace
!
=
TrailingWhitespace
:
:
TRIM_TRAILING_WHITESPACE
)
{
trimAfter
=
false
;
}
else
if
(
nsBlockFrame
*
thisLc
=
do_QueryFrame
(
FindLineContainer
(
textFrame
)
)
)
{
if
(
thisLc
!
=
lineContainer
)
{
lineContainer
=
thisLc
;
autoLineCursor
.
reset
(
)
;
autoLineCursor
.
emplace
(
lineContainer
)
;
}
trimAfter
=
LineEndsInHardLineBreak
(
textFrame
lineContainer
)
;
}
else
{
trimAfter
=
true
;
}
TrimmedOffsets
trimmedOffsets
=
textFrame
-
>
GetTrimmedOffsets
(
textFrag
trimAfter
)
;
bool
trimmedSignificantNewline
=
trimmedOffsets
.
GetEnd
(
)
<
GetContentEnd
(
)
&
&
HasSignificantTerminalNewline
(
)
;
uint32_t
skippedToRenderedStringOffset
=
offsetInRenderedString
-
tmpIter
.
ConvertOriginalToSkipped
(
trimmedOffsets
.
mStart
)
;
uint32_t
nextOffsetInRenderedString
=
tmpIter
.
ConvertOriginalToSkipped
(
trimmedOffsets
.
GetEnd
(
)
)
+
(
trimmedSignificantNewline
?
1
:
0
)
+
skippedToRenderedStringOffset
;
if
(
aOffsetType
=
=
TextOffsetType
:
:
OFFSETS_IN_RENDERED_TEXT
)
{
if
(
nextOffsetInRenderedString
<
=
aStartOffset
)
{
offsetInRenderedString
=
nextOffsetInRenderedString
;
continue
;
}
if
(
!
haveOffsets
)
{
result
.
mOffsetWithinNodeText
=
tmpIter
.
ConvertSkippedToOriginal
(
aStartOffset
-
skippedToRenderedStringOffset
)
;
result
.
mOffsetWithinNodeRenderedText
=
aStartOffset
;
haveOffsets
=
true
;
}
if
(
offsetInRenderedString
>
=
aEndOffset
)
{
break
;
}
}
else
{
if
(
uint32_t
(
textFrame
-
>
GetContentEnd
(
)
)
<
=
aStartOffset
)
{
offsetInRenderedString
=
nextOffsetInRenderedString
;
continue
;
}
if
(
!
haveOffsets
)
{
result
.
mOffsetWithinNodeText
=
aStartOffset
;
int32_t
clamped
=
std
:
:
max
<
int32_t
>
(
aStartOffset
trimmedOffsets
.
mStart
)
;
result
.
mOffsetWithinNodeRenderedText
=
tmpIter
.
ConvertOriginalToSkipped
(
clamped
)
+
skippedToRenderedStringOffset
;
MOZ_ASSERT
(
result
.
mOffsetWithinNodeRenderedText
>
=
offsetInRenderedString
&
&
result
.
mOffsetWithinNodeRenderedText
<
=
INT32_MAX
"
Bad
offset
within
rendered
text
"
)
;
haveOffsets
=
true
;
}
if
(
uint32_t
(
textFrame
-
>
mContentOffset
)
>
=
aEndOffset
)
{
break
;
}
}
int32_t
startOffset
;
int32_t
endOffset
;
if
(
aOffsetType
=
=
TextOffsetType
:
:
OFFSETS_IN_RENDERED_TEXT
)
{
startOffset
=
tmpIter
.
ConvertSkippedToOriginal
(
aStartOffset
-
skippedToRenderedStringOffset
)
;
endOffset
=
tmpIter
.
ConvertSkippedToOriginal
(
aEndOffset
-
skippedToRenderedStringOffset
)
;
}
else
{
startOffset
=
aStartOffset
;
endOffset
=
std
:
:
min
<
uint32_t
>
(
INT32_MAX
aEndOffset
)
;
}
int32_t
origTrimmedOffsetsEnd
=
trimmedOffsets
.
GetEnd
(
)
;
trimmedOffsets
.
mStart
=
std
:
:
max
<
uint32_t
>
(
trimmedOffsets
.
mStart
startOffset
)
;
trimmedOffsets
.
mLength
=
std
:
:
min
<
uint32_t
>
(
origTrimmedOffsetsEnd
endOffset
)
-
trimmedOffsets
.
mStart
;
if
(
trimmedOffsets
.
mLength
<
=
0
)
{
offsetInRenderedString
=
nextOffsetInRenderedString
;
continue
;
}
const
nsStyleText
*
textStyle
=
textFrame
-
>
StyleText
(
)
;
iter
.
SetOriginalOffset
(
trimmedOffsets
.
mStart
)
;
while
(
iter
.
GetOriginalOffset
(
)
<
trimmedOffsets
.
GetEnd
(
)
)
{
int32_t
runLength
;
bool
isSkipped
=
iter
.
IsOriginalCharSkipped
(
&
runLength
)
;
runLength
=
std
:
:
min
(
runLength
trimmedOffsets
.
GetEnd
(
)
-
iter
.
GetOriginalOffset
(
)
)
;
if
(
isSkipped
)
{
for
(
int32_t
i
=
0
;
i
<
runLength
;
+
+
i
)
{
char16_t
ch
=
textFrag
-
>
CharAt
(
iter
.
GetOriginalOffset
(
)
+
i
)
;
if
(
ch
=
=
CH_SHY
)
{
result
.
mString
.
Append
(
ch
)
;
}
}
}
else
{
TransformChars
(
textFrame
textStyle
textFrame
-
>
mTextRun
iter
.
GetSkippedOffset
(
)
textFrag
iter
.
GetOriginalOffset
(
)
runLength
result
.
mString
)
;
}
iter
.
AdvanceOriginal
(
runLength
)
;
}
if
(
trimmedSignificantNewline
&
&
GetContentEnd
(
)
<
=
endOffset
)
{
result
.
mString
.
Append
(
'
\
n
'
)
;
}
offsetInRenderedString
=
nextOffsetInRenderedString
;
}
if
(
!
haveOffsets
)
{
result
.
mOffsetWithinNodeText
=
textFrag
-
>
GetLength
(
)
;
result
.
mOffsetWithinNodeRenderedText
=
offsetInRenderedString
;
}
return
result
;
}
bool
nsTextFrame
:
:
IsEmpty
(
)
{
NS_ASSERTION
(
!
(
mState
&
TEXT_IS_ONLY_WHITESPACE
)
|
|
!
(
mState
&
TEXT_ISNOT_ONLY_WHITESPACE
)
"
Invalid
state
"
)
;
const
nsStyleText
*
textStyle
=
StyleText
(
)
;
if
(
textStyle
-
>
WhiteSpaceIsSignificant
(
)
)
{
return
false
;
}
if
(
mState
&
TEXT_ISNOT_ONLY_WHITESPACE
)
{
return
false
;
}
if
(
mState
&
TEXT_IS_ONLY_WHITESPACE
)
{
return
true
;
}
bool
isEmpty
=
IsAllWhitespace
(
mContent
-
>
GetText
(
)
textStyle
-
>
mWhiteSpace
!
=
mozilla
:
:
StyleWhiteSpace
:
:
PreLine
)
;
AddStateBits
(
isEmpty
?
TEXT_IS_ONLY_WHITESPACE
:
TEXT_ISNOT_ONLY_WHITESPACE
)
;
return
isEmpty
;
}
#
ifdef
DEBUG_FRAME_DUMP
void
nsTextFrame
:
:
ToCString
(
nsCString
&
aBuf
int32_t
*
aTotalContentLength
)
const
{
const
nsTextFragment
*
frag
=
mContent
-
>
GetText
(
)
;
if
(
!
frag
)
{
return
;
}
*
aTotalContentLength
=
frag
-
>
GetLength
(
)
;
int32_t
contentLength
=
GetContentLength
(
)
;
if
(
0
=
=
contentLength
)
{
return
;
}
int32_t
fragOffset
=
GetContentOffset
(
)
;
int32_t
n
=
fragOffset
+
contentLength
;
while
(
fragOffset
<
n
)
{
char16_t
ch
=
frag
-
>
CharAt
(
fragOffset
+
+
)
;
if
(
ch
=
=
'
\
r
'
)
{
aBuf
.
AppendLiteral
(
"
\
\
r
"
)
;
}
else
if
(
ch
=
=
'
\
n
'
)
{
aBuf
.
AppendLiteral
(
"
\
\
n
"
)
;
}
else
if
(
ch
=
=
'
\
t
'
)
{
aBuf
.
AppendLiteral
(
"
\
\
t
"
)
;
}
else
if
(
(
ch
<
'
'
)
|
|
(
ch
>
=
127
)
)
{
aBuf
.
Append
(
nsPrintfCString
(
"
\
\
u
%
04x
"
ch
)
)
;
}
else
{
aBuf
.
Append
(
ch
)
;
}
}
}
nsresult
nsTextFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
MakeFrameName
(
NS_LITERAL_STRING
(
"
Text
"
)
aResult
)
;
int32_t
totalContentLength
;
nsAutoCString
tmp
;
ToCString
(
tmp
&
totalContentLength
)
;
tmp
.
SetLength
(
std
:
:
min
(
tmp
.
Length
(
)
50u
)
)
;
aResult
+
=
NS_LITERAL_STRING
(
"
\
"
"
)
+
NS_ConvertASCIItoUTF16
(
tmp
)
+
NS_LITERAL_STRING
(
"
\
"
"
)
;
return
NS_OK
;
}
void
nsTextFrame
:
:
List
(
FILE
*
out
const
char
*
aPrefix
uint32_t
aFlags
)
const
{
nsCString
str
;
ListGeneric
(
str
aPrefix
aFlags
)
;
str
+
=
nsPrintfCString
(
"
[
run
=
%
p
]
"
static_cast
<
void
*
>
(
mTextRun
)
)
;
bool
isComplete
=
uint32_t
(
GetContentEnd
(
)
)
=
=
GetContent
(
)
-
>
TextLength
(
)
;
str
+
=
nsPrintfCString
(
"
[
%
d
%
d
%
c
]
"
GetContentOffset
(
)
GetContentLength
(
)
isComplete
?
'
T
'
:
'
F
'
)
;
if
(
IsSelected
(
)
)
{
str
+
=
"
SELECTED
"
;
}
fprintf_stderr
(
out
"
%
s
\
n
"
str
.
get
(
)
)
;
}
#
endif
void
nsTextFrame
:
:
AdjustOffsetsForBidi
(
int32_t
aStart
int32_t
aEnd
)
{
AddStateBits
(
NS_FRAME_IS_BIDI
)
;
if
(
mContent
-
>
HasFlag
(
NS_HAS_FLOWLENGTH_PROPERTY
)
)
{
mContent
-
>
DeleteProperty
(
nsGkAtoms
:
:
flowlength
)
;
mContent
-
>
UnsetFlags
(
NS_HAS_FLOWLENGTH_PROPERTY
)
;
}
ClearTextRuns
(
)
;
nsTextFrame
*
prev
=
GetPrevContinuation
(
)
;
if
(
prev
)
{
int32_t
prevOffset
=
prev
-
>
GetContentOffset
(
)
;
aStart
=
std
:
:
max
(
aStart
prevOffset
)
;
aEnd
=
std
:
:
max
(
aEnd
prevOffset
)
;
prev
-
>
ClearTextRuns
(
)
;
}
mContentOffset
=
aStart
;
SetLength
(
aEnd
-
aStart
nullptr
0
)
;
}
bool
nsTextFrame
:
:
HasSignificantTerminalNewline
(
)
const
{
return
:
:
HasTerminalNewline
(
this
)
&
&
StyleText
(
)
-
>
NewlineIsSignificant
(
this
)
;
}
bool
nsTextFrame
:
:
IsAtEndOfLine
(
)
const
{
return
(
GetStateBits
(
)
&
TEXT_END_OF_LINE
)
!
=
0
;
}
nscoord
nsTextFrame
:
:
GetLogicalBaseline
(
WritingMode
aWM
)
const
{
if
(
!
aWM
.
IsOrthogonalTo
(
GetWritingMode
(
)
)
)
{
return
mAscent
;
}
nsIFrame
*
parent
=
GetParent
(
)
;
nsPoint
position
=
GetNormalPosition
(
)
;
nscoord
parentAscent
=
parent
-
>
GetLogicalBaseline
(
aWM
)
;
if
(
aWM
.
IsVerticalRL
(
)
)
{
nscoord
parentDescent
=
parent
-
>
GetSize
(
)
.
width
-
parentAscent
;
nscoord
descent
=
parentDescent
-
position
.
x
;
return
GetSize
(
)
.
width
-
descent
;
}
return
parentAscent
-
(
aWM
.
IsVertical
(
)
?
position
.
x
:
position
.
y
)
;
}
bool
nsTextFrame
:
:
HasAnyNoncollapsedCharacters
(
)
{
gfxSkipCharsIterator
iter
=
EnsureTextRun
(
nsTextFrame
:
:
eInflated
)
;
int32_t
offset
=
GetContentOffset
(
)
offsetEnd
=
GetContentEnd
(
)
;
int32_t
skippedOffset
=
iter
.
ConvertOriginalToSkipped
(
offset
)
;
int32_t
skippedOffsetEnd
=
iter
.
ConvertOriginalToSkipped
(
offsetEnd
)
;
return
skippedOffset
!
=
skippedOffsetEnd
;
}
bool
nsTextFrame
:
:
ComputeCustomOverflow
(
nsOverflowAreas
&
aOverflowAreas
)
{
if
(
GetStateBits
(
)
&
NS_FRAME_FIRST_REFLOW
)
{
return
true
;
}
nsIFrame
*
decorationsBlock
;
if
(
IsFloatingFirstLetterChild
(
)
)
{
decorationsBlock
=
GetParent
(
)
;
}
else
{
nsIFrame
*
f
=
this
;
for
(
;
;
)
{
nsBlockFrame
*
fBlock
=
nsLayoutUtils
:
:
GetAsBlock
(
f
)
;
if
(
fBlock
)
{
decorationsBlock
=
fBlock
;
break
;
}
f
=
f
-
>
GetParent
(
)
;
if
(
!
f
)
{
NS_ERROR
(
"
Couldn
'
t
find
any
block
ancestor
(
for
text
decorations
)
"
)
;
return
nsFrame
:
:
ComputeCustomOverflow
(
aOverflowAreas
)
;
}
}
}
aOverflowAreas
=
RecomputeOverflow
(
decorationsBlock
)
;
return
nsFrame
:
:
ComputeCustomOverflow
(
aOverflowAreas
)
;
}
NS_DECLARE_FRAME_PROPERTY_SMALL_VALUE
(
JustificationAssignmentProperty
int32_t
)
void
nsTextFrame
:
:
AssignJustificationGaps
(
const
mozilla
:
:
JustificationAssignment
&
aAssign
)
{
int32_t
encoded
=
(
aAssign
.
mGapsAtStart
<
<
8
)
|
aAssign
.
mGapsAtEnd
;
static_assert
(
sizeof
(
aAssign
)
=
=
1
"
The
encoding
might
be
broken
if
JustificationAssignment
"
"
is
larger
than
1
byte
"
)
;
SetProperty
(
JustificationAssignmentProperty
(
)
encoded
)
;
}
mozilla
:
:
JustificationAssignment
nsTextFrame
:
:
GetJustificationAssignment
(
)
const
{
int32_t
encoded
=
GetProperty
(
JustificationAssignmentProperty
(
)
)
;
mozilla
:
:
JustificationAssignment
result
;
result
.
mGapsAtStart
=
encoded
>
>
8
;
result
.
mGapsAtEnd
=
encoded
&
0xFF
;
return
result
;
}
uint32_t
nsTextFrame
:
:
CountGraphemeClusters
(
)
const
{
const
nsTextFragment
*
frag
=
GetContent
(
)
-
>
GetText
(
)
;
MOZ_ASSERT
(
frag
"
Text
frame
must
have
text
fragment
"
)
;
nsAutoString
content
;
frag
-
>
AppendTo
(
content
GetContentOffset
(
)
GetContentLength
(
)
)
;
return
unicode
:
:
CountGraphemeClusters
(
content
.
Data
(
)
content
.
Length
(
)
)
;
}
bool
nsTextFrame
:
:
HasNonSuppressedText
(
)
{
if
(
HasAnyStateBits
(
TEXT_ISNOT_ONLY_WHITESPACE
|
NS_FRAME_FIRST_REFLOW
|
NS_FRAME_IN_REFLOW
)
)
{
return
true
;
}
if
(
!
GetTextRun
(
nsTextFrame
:
:
eInflated
)
)
{
return
false
;
}
TrimmedOffsets
offsets
=
GetTrimmedOffsets
(
mContent
-
>
GetText
(
)
false
)
;
return
offsets
.
mLength
!
=
0
;
}
