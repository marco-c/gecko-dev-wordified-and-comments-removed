#
include
"
CSSAlignUtils
.
h
"
#
include
"
ReflowInput
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIFrameInlines
.
h
"
namespace
mozilla
{
StyleAlignFlags
CSSAlignUtils
:
:
UsedAlignmentForAbsPos
(
nsIFrame
*
aFrame
StyleAlignFlags
aFlags
LogicalAxis
aLogicalAxis
WritingMode
aCBWM
)
{
MOZ_ASSERT
(
aFrame
-
>
IsAbsolutelyPositioned
(
)
)
;
StyleAlignFlags
alignmentFlags
=
aFlags
&
StyleAlignFlags
:
:
FLAG_BITS
;
aFlags
&
=
~
StyleAlignFlags
:
:
FLAG_BITS
;
if
(
aFlags
=
=
StyleAlignFlags
:
:
NORMAL
)
{
aFlags
=
aFrame
-
>
IsReplaced
(
)
?
StyleAlignFlags
:
:
START
:
StyleAlignFlags
:
:
STRETCH
;
}
else
if
(
aFlags
=
=
StyleAlignFlags
:
:
FLEX_START
)
{
aFlags
=
StyleAlignFlags
:
:
START
;
}
else
if
(
aFlags
=
=
StyleAlignFlags
:
:
FLEX_END
)
{
aFlags
=
StyleAlignFlags
:
:
END
;
}
else
if
(
aFlags
=
=
StyleAlignFlags
:
:
LEFT
|
|
aFlags
=
=
StyleAlignFlags
:
:
RIGHT
)
{
if
(
aLogicalAxis
=
=
LogicalAxis
:
:
Inline
)
{
const
bool
isLeft
=
(
aFlags
=
=
StyleAlignFlags
:
:
LEFT
)
;
aFlags
=
(
isLeft
=
=
aCBWM
.
IsBidiLTR
(
)
)
?
StyleAlignFlags
:
:
START
:
StyleAlignFlags
:
:
END
;
}
else
{
aFlags
=
StyleAlignFlags
:
:
START
;
}
}
else
if
(
aFlags
=
=
StyleAlignFlags
:
:
BASELINE
)
{
aFlags
=
StyleAlignFlags
:
:
START
;
}
else
if
(
aFlags
=
=
StyleAlignFlags
:
:
LAST_BASELINE
)
{
aFlags
=
StyleAlignFlags
:
:
END
;
}
return
(
aFlags
|
alignmentFlags
)
;
}
static
nscoord
SpaceToFill
(
WritingMode
aWM
const
LogicalSize
&
aSize
nscoord
aMargin
LogicalAxis
aAxis
nscoord
aCBSize
)
{
nscoord
size
=
aSize
.
Size
(
aAxis
aWM
)
;
return
aCBSize
-
(
size
+
aMargin
)
;
}
nscoord
CSSAlignUtils
:
:
AlignJustifySelf
(
const
StyleAlignFlags
&
aAlignment
LogicalAxis
aAxis
AlignJustifyFlags
aFlags
nscoord
aBaselineAdjust
nscoord
aCBSize
const
ReflowInput
&
aRI
const
LogicalSize
&
aChildSize
const
Maybe
<
AnchorAlignInfo
>
&
aAnchorInfo
)
{
MOZ_ASSERT
(
aAlignment
!
=
StyleAlignFlags
:
:
AUTO
"
auto
values
should
have
resolved
already
"
)
;
MOZ_ASSERT
(
aAlignment
!
=
StyleAlignFlags
:
:
LEFT
&
&
aAlignment
!
=
StyleAlignFlags
:
:
RIGHT
"
caller
should
map
that
to
the
corresponding
START
/
END
"
)
;
const
bool
isSameSide
=
aFlags
.
contains
(
AlignJustifyFlag
:
:
SameSide
)
;
StyleAlignFlags
alignment
=
aAlignment
;
if
(
alignment
=
=
StyleAlignFlags
:
:
SELF_START
)
{
alignment
=
MOZ_LIKELY
(
isSameSide
)
?
StyleAlignFlags
:
:
START
:
StyleAlignFlags
:
:
END
;
}
else
if
(
alignment
=
=
StyleAlignFlags
:
:
SELF_END
)
{
alignment
=
MOZ_LIKELY
(
isSameSide
)
?
StyleAlignFlags
:
:
END
:
StyleAlignFlags
:
:
START
;
}
else
if
(
alignment
=
=
StyleAlignFlags
:
:
FLEX_START
)
{
alignment
=
StyleAlignFlags
:
:
START
;
}
else
if
(
alignment
=
=
StyleAlignFlags
:
:
FLEX_END
)
{
alignment
=
StyleAlignFlags
:
:
END
;
}
WritingMode
wm
=
aRI
.
GetWritingMode
(
)
;
const
LogicalMargin
margin
=
aFlags
.
contains
(
AlignJustifyFlag
:
:
AligningMarginBox
)
?
LogicalMargin
(
wm
)
:
aRI
.
ComputedLogicalMargin
(
wm
)
;
const
auto
startSide
=
MakeLogicalSide
(
aAxis
MOZ_LIKELY
(
isSameSide
)
?
LogicalEdge
:
:
Start
:
LogicalEdge
:
:
End
)
;
const
nscoord
marginStart
=
margin
.
Side
(
startSide
wm
)
;
const
auto
endSide
=
GetOppositeSide
(
startSide
)
;
const
nscoord
marginEnd
=
margin
.
Side
(
endSide
wm
)
;
bool
hasAutoMarginStart
;
bool
hasAutoMarginEnd
;
const
auto
*
styleMargin
=
aRI
.
mStyleMargin
;
const
auto
anchorResolutionParams
=
AnchorPosResolutionParams
:
:
From
(
&
aRI
)
;
if
(
aFlags
.
contains
(
AlignJustifyFlag
:
:
IgnoreAutoMargins
)
|
|
aFlags
.
contains
(
AlignJustifyFlag
:
:
AligningMarginBox
)
)
{
hasAutoMarginStart
=
hasAutoMarginEnd
=
false
;
}
else
if
(
aAxis
=
=
LogicalAxis
:
:
Block
)
{
hasAutoMarginStart
=
styleMargin
-
>
GetMargin
(
LogicalSide
:
:
BStart
wm
anchorResolutionParams
)
-
>
IsAuto
(
)
;
hasAutoMarginEnd
=
styleMargin
-
>
GetMargin
(
LogicalSide
:
:
BEnd
wm
anchorResolutionParams
)
-
>
IsAuto
(
)
;
}
else
{
hasAutoMarginStart
=
styleMargin
-
>
GetMargin
(
LogicalSide
:
:
IStart
wm
anchorResolutionParams
)
-
>
IsAuto
(
)
;
hasAutoMarginEnd
=
styleMargin
-
>
GetMargin
(
LogicalSide
:
:
IEnd
wm
anchorResolutionParams
)
-
>
IsAuto
(
)
;
}
if
(
(
MOZ_UNLIKELY
(
aFlags
.
contains
(
AlignJustifyFlag
:
:
OverflowSafe
)
)
&
&
alignment
!
=
StyleAlignFlags
:
:
START
)
|
|
hasAutoMarginStart
|
|
hasAutoMarginEnd
)
{
nscoord
space
=
SpaceToFill
(
wm
aChildSize
marginStart
+
marginEnd
aAxis
aCBSize
)
;
if
(
space
<
0
)
{
alignment
=
StyleAlignFlags
:
:
START
;
}
else
if
(
hasAutoMarginEnd
)
{
alignment
=
hasAutoMarginStart
?
StyleAlignFlags
:
:
CENTER
:
(
isSameSide
?
StyleAlignFlags
:
:
START
:
StyleAlignFlags
:
:
END
)
;
}
else
if
(
hasAutoMarginStart
)
{
alignment
=
isSameSide
?
StyleAlignFlags
:
:
END
:
StyleAlignFlags
:
:
START
;
}
}
nscoord
offset
=
0
;
if
(
alignment
=
=
StyleAlignFlags
:
:
BASELINE
|
|
alignment
=
=
StyleAlignFlags
:
:
LAST_BASELINE
)
{
const
bool
isFirstBaselineSharingGroup
=
!
aFlags
.
contains
(
AlignJustifyFlag
:
:
LastBaselineSharingGroup
)
;
if
(
MOZ_LIKELY
(
isFirstBaselineSharingGroup
)
)
{
offset
=
marginStart
+
aBaselineAdjust
;
}
else
{
nscoord
size
=
aChildSize
.
Size
(
aAxis
wm
)
;
offset
=
aCBSize
-
(
size
+
marginEnd
)
-
aBaselineAdjust
;
}
}
else
if
(
alignment
=
=
StyleAlignFlags
:
:
STRETCH
|
|
alignment
=
=
StyleAlignFlags
:
:
START
)
{
offset
=
marginStart
;
}
else
if
(
alignment
=
=
StyleAlignFlags
:
:
END
)
{
nscoord
size
=
aChildSize
.
Size
(
aAxis
wm
)
;
offset
=
aCBSize
-
(
size
+
marginEnd
)
;
}
else
if
(
alignment
=
=
StyleAlignFlags
:
:
ANCHOR_CENTER
&
&
aAnchorInfo
)
{
const
nscoord
anchorSize
=
aAnchorInfo
-
>
mAnchorSize
;
const
nscoord
anchorStart
=
aAnchorInfo
-
>
mAnchorStart
;
const
nscoord
size
=
aChildSize
.
Size
(
aAxis
wm
)
;
offset
=
anchorStart
+
(
anchorSize
-
size
+
marginStart
-
marginEnd
)
/
2
;
}
else
{
MOZ_ASSERT
(
alignment
=
=
StyleAlignFlags
:
:
CENTER
|
|
alignment
=
=
StyleAlignFlags
:
:
ANCHOR_CENTER
"
unknown
align
-
/
justify
-
self
value
"
)
;
nscoord
size
=
aChildSize
.
Size
(
aAxis
wm
)
;
offset
=
(
aCBSize
-
size
+
marginStart
-
marginEnd
)
/
2
;
}
return
offset
;
}
}
