#
include
"
CSSAlignUtils
.
h
"
#
include
"
ReflowInput
.
h
"
namespace
mozilla
{
static
nscoord
SpaceToFill
(
WritingMode
aWM
const
LogicalSize
&
aSize
nscoord
aMargin
LogicalAxis
aAxis
nscoord
aCBSize
)
{
nscoord
size
=
aSize
.
Size
(
aAxis
aWM
)
;
return
aCBSize
-
(
size
+
aMargin
)
;
}
nscoord
CSSAlignUtils
:
:
AlignJustifySelf
(
uint8_t
aAlignment
LogicalAxis
aAxis
AlignJustifyFlags
aFlags
nscoord
aBaselineAdjust
nscoord
aCBSize
const
ReflowInput
&
aRI
const
LogicalSize
&
aChildSize
)
{
MOZ_ASSERT
(
aAlignment
!
=
NS_STYLE_ALIGN_AUTO
"
auto
values
should
have
resolved
already
"
)
;
MOZ_ASSERT
(
aAlignment
!
=
NS_STYLE_ALIGN_LEFT
&
&
aAlignment
!
=
NS_STYLE_ALIGN_RIGHT
"
caller
should
map
that
to
the
corresponding
START
/
END
"
)
;
const
bool
isOverflowSafe
=
!
!
(
aFlags
&
AlignJustifyFlags
:
:
eOverflowSafe
)
;
const
bool
isSameSide
=
!
!
(
aFlags
&
AlignJustifyFlags
:
:
eSameSide
)
;
switch
(
aAlignment
)
{
case
NS_STYLE_ALIGN_SELF_START
:
aAlignment
=
MOZ_LIKELY
(
isSameSide
)
?
NS_STYLE_ALIGN_START
:
NS_STYLE_ALIGN_END
;
break
;
case
NS_STYLE_ALIGN_SELF_END
:
aAlignment
=
MOZ_LIKELY
(
isSameSide
)
?
NS_STYLE_ALIGN_END
:
NS_STYLE_ALIGN_START
;
break
;
case
NS_STYLE_ALIGN_FLEX_START
:
aAlignment
=
NS_STYLE_ALIGN_START
;
break
;
case
NS_STYLE_ALIGN_FLEX_END
:
aAlignment
=
NS_STYLE_ALIGN_END
;
break
;
}
const
LogicalMargin
margin
=
aRI
.
ComputedLogicalMargin
(
)
;
WritingMode
wm
=
aRI
.
GetWritingMode
(
)
;
nscoord
marginStart
marginEnd
;
if
(
aAxis
=
=
eLogicalAxisBlock
)
{
if
(
MOZ_LIKELY
(
isSameSide
)
)
{
marginStart
=
margin
.
BStart
(
wm
)
;
marginEnd
=
margin
.
BEnd
(
wm
)
;
}
else
{
marginStart
=
margin
.
BEnd
(
wm
)
;
marginEnd
=
margin
.
BStart
(
wm
)
;
}
}
else
{
if
(
MOZ_LIKELY
(
isSameSide
)
)
{
marginStart
=
margin
.
IStart
(
wm
)
;
marginEnd
=
margin
.
IEnd
(
wm
)
;
}
else
{
marginStart
=
margin
.
IEnd
(
wm
)
;
marginEnd
=
margin
.
IStart
(
wm
)
;
}
}
const
auto
&
styleMargin
=
aRI
.
mStyleMargin
-
>
mMargin
;
bool
hasAutoMarginStart
;
bool
hasAutoMarginEnd
;
if
(
aFlags
&
AlignJustifyFlags
:
:
eIgnoreAutoMargins
)
{
hasAutoMarginStart
=
hasAutoMarginEnd
=
false
;
}
else
if
(
aAxis
=
=
eLogicalAxisBlock
)
{
hasAutoMarginStart
=
styleMargin
.
GetBStart
(
wm
)
.
IsAuto
(
)
;
hasAutoMarginEnd
=
styleMargin
.
GetBEnd
(
wm
)
.
IsAuto
(
)
;
}
else
{
hasAutoMarginStart
=
styleMargin
.
GetIStart
(
wm
)
.
IsAuto
(
)
;
hasAutoMarginEnd
=
styleMargin
.
GetIEnd
(
wm
)
.
IsAuto
(
)
;
}
if
(
(
MOZ_UNLIKELY
(
isOverflowSafe
)
&
&
aAlignment
!
=
NS_STYLE_ALIGN_START
)
|
|
hasAutoMarginStart
|
|
hasAutoMarginEnd
)
{
nscoord
space
=
SpaceToFill
(
wm
aChildSize
marginStart
+
marginEnd
aAxis
aCBSize
)
;
if
(
space
<
0
)
{
aAlignment
=
NS_STYLE_ALIGN_START
;
}
else
if
(
hasAutoMarginEnd
)
{
aAlignment
=
hasAutoMarginStart
?
NS_STYLE_ALIGN_CENTER
:
(
isSameSide
?
NS_STYLE_ALIGN_START
:
NS_STYLE_ALIGN_END
)
;
}
else
if
(
hasAutoMarginStart
)
{
aAlignment
=
isSameSide
?
NS_STYLE_ALIGN_END
:
NS_STYLE_ALIGN_START
;
}
}
nscoord
offset
=
0
;
switch
(
aAlignment
)
{
case
NS_STYLE_ALIGN_BASELINE
:
case
NS_STYLE_ALIGN_LAST_BASELINE
:
if
(
MOZ_LIKELY
(
isSameSide
=
=
(
aAlignment
=
=
NS_STYLE_ALIGN_BASELINE
)
)
)
{
offset
=
marginStart
+
aBaselineAdjust
;
}
else
{
nscoord
size
=
aChildSize
.
Size
(
aAxis
wm
)
;
offset
=
aCBSize
-
(
size
+
marginEnd
)
-
aBaselineAdjust
;
}
break
;
case
NS_STYLE_ALIGN_STRETCH
:
MOZ_FALLTHROUGH
;
case
NS_STYLE_ALIGN_START
:
offset
=
marginStart
;
break
;
case
NS_STYLE_ALIGN_END
:
{
nscoord
size
=
aChildSize
.
Size
(
aAxis
wm
)
;
offset
=
aCBSize
-
(
size
+
marginEnd
)
;
break
;
}
case
NS_STYLE_ALIGN_CENTER
:
{
nscoord
size
=
aChildSize
.
Size
(
aAxis
wm
)
;
offset
=
(
aCBSize
-
size
+
marginStart
-
marginEnd
)
/
2
;
break
;
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unknown
align
-
/
justify
-
self
value
"
)
;
}
return
offset
;
}
}
