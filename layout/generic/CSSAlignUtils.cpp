#
include
"
CSSAlignUtils
.
h
"
#
include
"
ReflowInput
.
h
"
namespace
mozilla
{
static
nscoord
SpaceToFill
(
WritingMode
aWM
const
LogicalSize
&
aSize
nscoord
aMargin
LogicalAxis
aAxis
nscoord
aCBSize
)
{
nscoord
size
=
aSize
.
Size
(
aAxis
aWM
)
;
return
aCBSize
-
(
size
+
aMargin
)
;
}
nscoord
CSSAlignUtils
:
:
AlignJustifySelf
(
const
StyleAlignFlags
&
aAlignment
LogicalAxis
aAxis
AlignJustifyFlags
aFlags
nscoord
aBaselineAdjust
nscoord
aCBSize
const
ReflowInput
&
aRI
const
LogicalSize
&
aChildSize
)
{
MOZ_ASSERT
(
aAlignment
!
=
StyleAlignFlags
:
:
AUTO
"
auto
values
should
have
resolved
already
"
)
;
MOZ_ASSERT
(
aAlignment
!
=
StyleAlignFlags
:
:
LEFT
&
&
aAlignment
!
=
StyleAlignFlags
:
:
RIGHT
"
caller
should
map
that
to
the
corresponding
START
/
END
"
)
;
const
bool
isOverflowSafe
=
!
!
(
aFlags
&
AlignJustifyFlags
:
:
OverflowSafe
)
;
const
bool
isSameSide
=
!
!
(
aFlags
&
AlignJustifyFlags
:
:
SameSide
)
;
StyleAlignFlags
alignment
=
aAlignment
;
if
(
alignment
=
=
StyleAlignFlags
:
:
SELF_START
)
{
alignment
=
MOZ_LIKELY
(
isSameSide
)
?
StyleAlignFlags
:
:
START
:
StyleAlignFlags
:
:
END
;
}
else
if
(
alignment
=
=
StyleAlignFlags
:
:
SELF_END
)
{
alignment
=
MOZ_LIKELY
(
isSameSide
)
?
StyleAlignFlags
:
:
END
:
StyleAlignFlags
:
:
START
;
}
else
if
(
alignment
=
=
StyleAlignFlags
:
:
FLEX_START
)
{
alignment
=
StyleAlignFlags
:
:
START
;
}
else
if
(
alignment
=
=
StyleAlignFlags
:
:
FLEX_END
)
{
alignment
=
StyleAlignFlags
:
:
END
;
}
WritingMode
wm
=
aRI
.
GetWritingMode
(
)
;
const
LogicalMargin
margin
=
aRI
.
ComputedLogicalMargin
(
wm
)
;
const
auto
startSide
=
MakeLogicalSide
(
aAxis
MOZ_LIKELY
(
isSameSide
)
?
LogicalEdge
:
:
Start
:
LogicalEdge
:
:
End
)
;
const
nscoord
marginStart
=
margin
.
Side
(
startSide
wm
)
;
const
auto
endSide
=
GetOppositeSide
(
startSide
)
;
const
nscoord
marginEnd
=
margin
.
Side
(
endSide
wm
)
;
const
auto
&
styleMargin
=
aRI
.
mStyleMargin
-
>
mMargin
;
bool
hasAutoMarginStart
;
bool
hasAutoMarginEnd
;
if
(
aFlags
&
AlignJustifyFlags
:
:
IgnoreAutoMargins
)
{
hasAutoMarginStart
=
hasAutoMarginEnd
=
false
;
}
else
if
(
aAxis
=
=
LogicalAxis
:
:
Block
)
{
hasAutoMarginStart
=
styleMargin
.
GetBStart
(
wm
)
.
IsAuto
(
)
;
hasAutoMarginEnd
=
styleMargin
.
GetBEnd
(
wm
)
.
IsAuto
(
)
;
}
else
{
hasAutoMarginStart
=
styleMargin
.
GetIStart
(
wm
)
.
IsAuto
(
)
;
hasAutoMarginEnd
=
styleMargin
.
GetIEnd
(
wm
)
.
IsAuto
(
)
;
}
if
(
(
MOZ_UNLIKELY
(
isOverflowSafe
)
&
&
alignment
!
=
StyleAlignFlags
:
:
START
)
|
|
hasAutoMarginStart
|
|
hasAutoMarginEnd
)
{
nscoord
space
=
SpaceToFill
(
wm
aChildSize
marginStart
+
marginEnd
aAxis
aCBSize
)
;
if
(
space
<
0
)
{
alignment
=
StyleAlignFlags
:
:
START
;
}
else
if
(
hasAutoMarginEnd
)
{
alignment
=
hasAutoMarginStart
?
StyleAlignFlags
:
:
CENTER
:
(
isSameSide
?
StyleAlignFlags
:
:
START
:
StyleAlignFlags
:
:
END
)
;
}
else
if
(
hasAutoMarginStart
)
{
alignment
=
isSameSide
?
StyleAlignFlags
:
:
END
:
StyleAlignFlags
:
:
START
;
}
}
nscoord
offset
=
0
;
if
(
alignment
=
=
StyleAlignFlags
:
:
BASELINE
|
|
alignment
=
=
StyleAlignFlags
:
:
LAST_BASELINE
)
{
if
(
MOZ_LIKELY
(
isSameSide
=
=
(
alignment
=
=
StyleAlignFlags
:
:
BASELINE
)
)
)
{
offset
=
marginStart
+
aBaselineAdjust
;
}
else
{
nscoord
size
=
aChildSize
.
Size
(
aAxis
wm
)
;
offset
=
aCBSize
-
(
size
+
marginEnd
)
-
aBaselineAdjust
;
}
}
else
if
(
alignment
=
=
StyleAlignFlags
:
:
STRETCH
|
|
alignment
=
=
StyleAlignFlags
:
:
START
)
{
offset
=
marginStart
;
}
else
if
(
alignment
=
=
StyleAlignFlags
:
:
END
)
{
nscoord
size
=
aChildSize
.
Size
(
aAxis
wm
)
;
offset
=
aCBSize
-
(
size
+
marginEnd
)
;
}
else
if
(
alignment
=
=
StyleAlignFlags
:
:
CENTER
|
|
alignment
=
=
StyleAlignFlags
:
:
ANCHOR_CENTER
)
{
nscoord
size
=
aChildSize
.
Size
(
aAxis
wm
)
;
offset
=
(
aCBSize
-
size
+
marginStart
-
marginEnd
)
/
2
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
unknown
align
-
/
justify
-
self
value
"
)
;
}
return
offset
;
}
}
