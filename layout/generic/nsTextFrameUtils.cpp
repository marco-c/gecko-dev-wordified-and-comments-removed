#
include
"
nsTextFrameUtils
.
h
"
#
include
"
nsBidiUtils
.
h
"
#
include
"
nsCharTraits
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsStyleStruct
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
<
algorithm
>
using
namespace
mozilla
;
static
bool
IsDiscardable
(
char16_t
ch
uint32_t
*
aFlags
)
{
if
(
ch
=
=
CH_SHY
)
{
*
aFlags
|
=
nsTextFrameUtils
:
:
TEXT_HAS_SHY
;
return
true
;
}
return
IsBidiControl
(
ch
)
;
}
static
bool
IsDiscardable
(
uint8_t
ch
uint32_t
*
aFlags
)
{
if
(
ch
=
=
CH_SHY
)
{
*
aFlags
|
=
nsTextFrameUtils
:
:
TEXT_HAS_SHY
;
return
true
;
}
return
false
;
}
static
bool
IsSegmentBreak
(
char16_t
aCh
)
{
return
aCh
=
=
'
\
n
'
|
|
aCh
=
=
'
\
r
'
;
}
static
bool
IsSpaceOrTab
(
char16_t
aCh
)
{
return
aCh
=
=
'
'
|
|
aCh
=
=
'
\
t
'
;
}
static
bool
IsSpaceOrTabOrSegmentBreak
(
char16_t
aCh
)
{
return
IsSpaceOrTab
(
aCh
)
|
|
IsSegmentBreak
(
aCh
)
;
}
static
char16_t
*
TransformWhiteSpaces
(
const
char16_t
*
aText
uint32_t
aLength
uint32_t
aBegin
uint32_t
aEnd
bool
aHasSegmentBreak
bool
&
aInWhitespace
char16_t
*
aOutput
uint32_t
&
aFlags
nsTextFrameUtils
:
:
CompressionMode
aCompression
gfxSkipChars
*
aSkipChars
)
{
MOZ_ASSERT
(
aCompression
=
=
nsTextFrameUtils
:
:
COMPRESS_WHITESPACE
|
|
aCompression
=
=
nsTextFrameUtils
:
:
COMPRESS_WHITESPACE_NEWLINE
"
whitespaces
should
be
skippable
!
!
"
)
;
bool
isSegmentBreakSkippable
=
(
aBegin
>
0
&
&
IS_ZERO_WIDTH_SPACE
(
aText
[
aBegin
-
1
]
)
)
|
|
(
aEnd
<
aLength
&
&
IS_ZERO_WIDTH_SPACE
(
aText
[
aEnd
]
)
)
;
if
(
!
isSegmentBreakSkippable
&
&
aBegin
>
0
&
&
aEnd
<
aLength
)
{
uint32_t
ucs4before
;
uint32_t
ucs4after
;
if
(
aBegin
>
1
&
&
NS_IS_LOW_SURROGATE
(
aText
[
aBegin
-
1
]
)
&
&
NS_IS_HIGH_SURROGATE
(
aText
[
aBegin
-
2
]
)
)
{
ucs4before
=
SURROGATE_TO_UCS4
(
aText
[
aBegin
-
2
]
aText
[
aBegin
-
1
]
)
;
}
else
{
ucs4before
=
aText
[
aBegin
-
1
]
;
}
if
(
aEnd
+
1
<
aLength
&
&
NS_IS_HIGH_SURROGATE
(
aText
[
aEnd
]
)
&
&
NS_IS_LOW_SURROGATE
(
aText
[
aEnd
+
1
]
)
)
{
ucs4after
=
SURROGATE_TO_UCS4
(
aText
[
aEnd
]
aText
[
aEnd
+
1
]
)
;
}
else
{
ucs4after
=
aText
[
aEnd
]
;
}
isSegmentBreakSkippable
=
IsSegmentBreakSkipChar
(
ucs4before
)
&
&
IsSegmentBreakSkipChar
(
ucs4after
)
;
}
for
(
uint32_t
i
=
aBegin
;
i
<
aEnd
;
+
+
i
)
{
char16_t
ch
=
aText
[
i
]
;
bool
keepChar
=
false
;
bool
keepTransformedWhiteSpace
=
false
;
if
(
IsDiscardable
(
ch
&
aFlags
)
)
{
aSkipChars
-
>
SkipChar
(
)
;
continue
;
}
if
(
IsSpaceOrTab
(
ch
)
)
{
if
(
aHasSegmentBreak
)
{
aSkipChars
-
>
SkipChar
(
)
;
continue
;
}
if
(
aInWhitespace
)
{
aSkipChars
-
>
SkipChar
(
)
;
continue
;
}
else
{
keepTransformedWhiteSpace
=
true
;
}
}
else
{
if
(
aCompression
=
=
nsTextFrameUtils
:
:
COMPRESS_WHITESPACE
|
|
ch
=
=
'
\
r
'
)
{
keepChar
=
true
;
}
else
{
if
(
isSegmentBreakSkippable
|
|
aInWhitespace
)
{
aSkipChars
-
>
SkipChar
(
)
;
continue
;
}
isSegmentBreakSkippable
=
true
;
keepTransformedWhiteSpace
=
true
;
}
}
if
(
keepChar
)
{
*
aOutput
+
+
=
ch
;
aSkipChars
-
>
KeepChar
(
)
;
aInWhitespace
=
IsSpaceOrTab
(
ch
)
;
}
else
if
(
keepTransformedWhiteSpace
)
{
if
(
ch
!
=
'
'
)
{
aFlags
|
=
nsTextFrameUtils
:
:
TEXT_WAS_TRANSFORMED
;
}
*
aOutput
+
+
=
'
'
;
aSkipChars
-
>
KeepChar
(
)
;
aInWhitespace
=
true
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Should
'
ve
skipped
the
character
!
!
"
)
;
}
}
return
aOutput
;
}
char16_t
*
nsTextFrameUtils
:
:
TransformText
(
const
char16_t
*
aText
uint32_t
aLength
char16_t
*
aOutput
CompressionMode
aCompression
uint8_t
*
aIncomingFlags
gfxSkipChars
*
aSkipChars
uint32_t
*
aAnalysisFlags
)
{
uint32_t
flags
=
0
;
char16_t
*
outputStart
=
aOutput
;
bool
lastCharArabic
=
false
;
if
(
aCompression
=
=
COMPRESS_NONE
|
|
aCompression
=
=
COMPRESS_NONE_TRANSFORM_TO_SPACE
)
{
uint32_t
i
;
for
(
i
=
0
;
i
<
aLength
;
+
+
i
)
{
char16_t
ch
=
aText
[
i
]
;
if
(
IsDiscardable
(
ch
&
flags
)
)
{
aSkipChars
-
>
SkipChar
(
)
;
}
else
{
aSkipChars
-
>
KeepChar
(
)
;
if
(
ch
>
'
'
)
{
lastCharArabic
=
IS_ARABIC_CHAR
(
ch
)
;
}
else
if
(
aCompression
=
=
COMPRESS_NONE_TRANSFORM_TO_SPACE
)
{
if
(
ch
=
=
'
\
t
'
|
|
ch
=
=
'
\
n
'
)
{
ch
=
'
'
;
flags
|
=
TEXT_WAS_TRANSFORMED
;
}
}
else
{
if
(
ch
=
=
'
\
t
'
)
{
flags
|
=
TEXT_HAS_TAB
;
}
}
*
aOutput
+
+
=
ch
;
}
}
if
(
lastCharArabic
)
{
*
aIncomingFlags
|
=
INCOMING_ARABICCHAR
;
}
else
{
*
aIncomingFlags
&
=
~
INCOMING_ARABICCHAR
;
}
*
aIncomingFlags
&
=
~
INCOMING_WHITESPACE
;
}
else
{
bool
inWhitespace
=
(
*
aIncomingFlags
&
INCOMING_WHITESPACE
)
!
=
0
;
uint32_t
i
;
for
(
i
=
0
;
i
<
aLength
;
+
+
i
)
{
char16_t
ch
=
aText
[
i
]
;
if
(
IsSpaceOrTabOrSegmentBreak
(
ch
)
)
{
bool
keepLastSpace
=
false
;
bool
hasSegmentBreak
=
IsSegmentBreak
(
ch
)
;
uint32_t
countTrailingDiscardables
=
0
;
uint32_t
j
;
for
(
j
=
i
+
1
;
j
<
aLength
&
&
(
IsSpaceOrTabOrSegmentBreak
(
aText
[
j
]
)
|
|
IsDiscardable
(
aText
[
j
]
&
flags
)
)
;
j
+
+
)
{
if
(
IsSegmentBreak
(
aText
[
j
]
)
)
{
hasSegmentBreak
=
true
;
}
}
for
(
;
IsDiscardable
(
aText
[
j
-
1
]
&
flags
)
;
j
-
-
)
{
countTrailingDiscardables
+
+
;
}
if
(
aText
[
j
-
1
]
=
=
'
'
&
&
j
<
aLength
&
&
IsSpaceCombiningSequenceTail
(
&
aText
[
j
]
aLength
-
j
)
)
{
keepLastSpace
=
true
;
j
-
-
;
}
if
(
j
>
i
)
{
aOutput
=
TransformWhiteSpaces
(
aText
aLength
i
j
hasSegmentBreak
inWhitespace
aOutput
flags
aCompression
aSkipChars
)
;
}
if
(
keepLastSpace
)
{
keepLastSpace
=
false
;
*
aOutput
+
+
=
'
'
;
aSkipChars
-
>
KeepChar
(
)
;
lastCharArabic
=
false
;
j
+
+
;
}
for
(
;
countTrailingDiscardables
>
0
;
countTrailingDiscardables
-
-
)
{
aSkipChars
-
>
SkipChar
(
)
;
j
+
+
;
}
i
=
j
-
1
;
continue
;
}
if
(
IsDiscardable
(
ch
&
flags
)
)
{
aSkipChars
-
>
SkipChar
(
)
;
}
else
{
*
aOutput
+
+
=
ch
;
aSkipChars
-
>
KeepChar
(
)
;
}
lastCharArabic
=
IS_ARABIC_CHAR
(
ch
)
;
inWhitespace
=
false
;
}
if
(
lastCharArabic
)
{
*
aIncomingFlags
|
=
INCOMING_ARABICCHAR
;
}
else
{
*
aIncomingFlags
&
=
~
INCOMING_ARABICCHAR
;
}
if
(
inWhitespace
)
{
*
aIncomingFlags
|
=
INCOMING_WHITESPACE
;
}
else
{
*
aIncomingFlags
&
=
~
INCOMING_WHITESPACE
;
}
}
if
(
outputStart
+
aLength
!
=
aOutput
)
{
flags
|
=
TEXT_WAS_TRANSFORMED
;
}
*
aAnalysisFlags
=
flags
;
return
aOutput
;
}
uint8_t
*
nsTextFrameUtils
:
:
TransformText
(
const
uint8_t
*
aText
uint32_t
aLength
uint8_t
*
aOutput
CompressionMode
aCompression
uint8_t
*
aIncomingFlags
gfxSkipChars
*
aSkipChars
uint32_t
*
aAnalysisFlags
)
{
uint32_t
flags
=
0
;
uint8_t
*
outputStart
=
aOutput
;
if
(
aCompression
=
=
COMPRESS_NONE
|
|
aCompression
=
=
COMPRESS_NONE_TRANSFORM_TO_SPACE
)
{
uint32_t
i
;
for
(
i
=
0
;
i
<
aLength
;
+
+
i
)
{
uint8_t
ch
=
aText
[
i
]
;
if
(
IsDiscardable
(
ch
&
flags
)
)
{
aSkipChars
-
>
SkipChar
(
)
;
}
else
{
aSkipChars
-
>
KeepChar
(
)
;
if
(
aCompression
=
=
COMPRESS_NONE_TRANSFORM_TO_SPACE
)
{
if
(
ch
=
=
'
\
t
'
|
|
ch
=
=
'
\
n
'
)
{
ch
=
'
'
;
flags
|
=
TEXT_WAS_TRANSFORMED
;
}
}
else
{
if
(
ch
=
=
'
\
t
'
)
{
flags
|
=
TEXT_HAS_TAB
;
}
}
*
aOutput
+
+
=
ch
;
}
}
*
aIncomingFlags
&
=
~
(
INCOMING_ARABICCHAR
|
INCOMING_WHITESPACE
)
;
}
else
{
bool
inWhitespace
=
(
*
aIncomingFlags
&
INCOMING_WHITESPACE
)
!
=
0
;
uint32_t
i
;
for
(
i
=
0
;
i
<
aLength
;
+
+
i
)
{
uint8_t
ch
=
aText
[
i
]
;
bool
nowInWhitespace
=
ch
=
=
'
'
|
|
ch
=
=
'
\
t
'
|
|
(
ch
=
=
'
\
n
'
&
&
aCompression
=
=
COMPRESS_WHITESPACE_NEWLINE
)
;
if
(
!
nowInWhitespace
)
{
if
(
IsDiscardable
(
ch
&
flags
)
)
{
aSkipChars
-
>
SkipChar
(
)
;
nowInWhitespace
=
inWhitespace
;
}
else
{
*
aOutput
+
+
=
ch
;
aSkipChars
-
>
KeepChar
(
)
;
}
}
else
{
if
(
inWhitespace
)
{
aSkipChars
-
>
SkipChar
(
)
;
}
else
{
if
(
ch
!
=
'
'
)
{
flags
|
=
TEXT_WAS_TRANSFORMED
;
}
*
aOutput
+
+
=
'
'
;
aSkipChars
-
>
KeepChar
(
)
;
}
}
inWhitespace
=
nowInWhitespace
;
}
*
aIncomingFlags
&
=
~
INCOMING_ARABICCHAR
;
if
(
inWhitespace
)
{
*
aIncomingFlags
|
=
INCOMING_WHITESPACE
;
}
else
{
*
aIncomingFlags
&
=
~
INCOMING_WHITESPACE
;
}
}
if
(
outputStart
+
aLength
!
=
aOutput
)
{
flags
|
=
TEXT_WAS_TRANSFORMED
;
}
*
aAnalysisFlags
=
flags
;
return
aOutput
;
}
uint32_t
nsTextFrameUtils
:
:
ComputeApproximateLengthWithWhitespaceCompression
(
nsIContent
*
aContent
const
nsStyleText
*
aStyleText
)
{
const
nsTextFragment
*
frag
=
aContent
-
>
GetText
(
)
;
uint32_t
len
;
if
(
aStyleText
-
>
WhiteSpaceIsSignificant
(
)
)
{
len
=
frag
-
>
GetLength
(
)
;
}
else
{
bool
is2b
=
frag
-
>
Is2b
(
)
;
union
{
const
char
*
s1b
;
const
char16_t
*
s2b
;
}
u
;
if
(
is2b
)
{
u
.
s2b
=
frag
-
>
Get2b
(
)
;
}
else
{
u
.
s1b
=
frag
-
>
Get1b
(
)
;
}
bool
prevWS
=
true
;
len
=
0
;
for
(
uint32_t
i
=
0
i_end
=
frag
-
>
GetLength
(
)
;
i
<
i_end
;
+
+
i
)
{
char16_t
c
=
is2b
?
u
.
s2b
[
i
]
:
u
.
s1b
[
i
]
;
if
(
c
=
=
'
'
|
|
c
=
=
'
\
n
'
|
|
c
=
=
'
\
t
'
|
|
c
=
=
'
\
r
'
)
{
if
(
!
prevWS
)
{
+
+
len
;
}
prevWS
=
true
;
}
else
{
+
+
len
;
prevWS
=
false
;
}
}
}
return
len
;
}
bool
nsSkipCharsRunIterator
:
:
NextRun
(
)
{
do
{
if
(
mRunLength
)
{
mIterator
.
AdvanceOriginal
(
mRunLength
)
;
NS_ASSERTION
(
mRunLength
>
0
"
No
characters
in
run
(
initial
length
too
large
?
)
"
)
;
if
(
!
mSkipped
|
|
mLengthIncludesSkipped
)
{
mRemainingLength
-
=
mRunLength
;
}
}
if
(
!
mRemainingLength
)
return
false
;
int32_t
length
;
mSkipped
=
mIterator
.
IsOriginalCharSkipped
(
&
length
)
;
mRunLength
=
std
:
:
min
(
length
mRemainingLength
)
;
}
while
(
!
mVisitSkipped
&
&
mSkipped
)
;
return
true
;
}
