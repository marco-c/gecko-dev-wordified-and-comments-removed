#
include
"
nsImageFrame
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
mozilla
/
ComputedStyle
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Encoding
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
Helpers
.
h
"
#
include
"
mozilla
/
gfx
/
PathHelpers
.
h
"
#
include
"
mozilla
/
dom
/
HTMLImageElement
.
h
"
#
include
"
mozilla
/
dom
/
ResponsiveImageSelector
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderLayerManager
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsFontMetrics
.
h
"
#
include
"
nsIImageLoadingContent
.
h
"
#
include
"
nsImageLoadingContent
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCSSAnonBoxes
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsStyleCoord
.
h
"
#
include
"
nsStyleUtil
.
h
"
#
include
"
nsTransform2D
.
h
"
#
include
"
nsImageMap
.
h
"
#
include
"
nsIIOService
.
h
"
#
include
"
nsILoadGroup
.
h
"
#
include
"
nsISupportsPriority
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsCSSRendering
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
<
algorithm
>
#
ifdef
ACCESSIBILITY
#
include
"
nsAccessibilityService
.
h
"
#
endif
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
FrameLayerBuilder
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsIURIMutator
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
imgLoader
.
h
"
#
include
"
imgRequestProxy
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsBidiUtils
.
h
"
#
include
"
nsBidiPresUtils
.
h
"
#
include
"
gfxRect
.
h
"
#
include
"
ImageLayers
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
nsBlockFrame
.
h
"
#
include
"
nsStyleStructInlines
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
dom
/
Link
.
h
"
#
include
"
SVGImageContext
.
h
"
#
include
"
mozilla
/
dom
/
HTMLAnchorElement
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
image
;
using
namespace
mozilla
:
:
layers
;
#
define
ICON_SIZE
(
16
)
#
define
ICON_PADDING
(
3
)
#
define
ALT_BORDER_WIDTH
(
1
)
#
define
ALIGN_UNSET
uint8_t
(
-
1
)
StaticRefPtr
<
nsImageFrame
:
:
IconLoad
>
nsImageFrame
:
:
gIconLoad
;
nsIIOService
*
nsImageFrame
:
:
sIOService
;
static
bool
HaveSpecifiedSize
(
const
nsStylePosition
*
aStylePosition
)
{
return
aStylePosition
-
>
mWidth
.
IsCoordPercentCalcUnit
(
)
&
&
aStylePosition
-
>
mHeight
.
IsCoordPercentCalcUnit
(
)
;
}
inline
bool
HaveFixedSize
(
const
ReflowInput
&
aReflowInput
)
{
NS_ASSERTION
(
aReflowInput
.
mStylePosition
"
crappy
reflowInput
-
null
stylePosition
"
)
;
return
aReflowInput
.
mStylePosition
-
>
mHeight
.
ConvertsToLength
(
)
&
&
aReflowInput
.
mStylePosition
-
>
mWidth
.
ConvertsToLength
(
)
;
}
nsIFrame
*
NS_NewImageFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsImageFrame
(
aStyle
nsImageFrame
:
:
Kind
:
:
ImageElement
)
;
}
nsIFrame
*
NS_NewImageFrameForContentProperty
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsImageFrame
(
aStyle
nsImageFrame
:
:
Kind
:
:
NonGeneratedContentProperty
)
;
}
nsImageFrame
*
nsImageFrame
:
:
CreateContinuingFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
const
{
return
new
(
aPresShell
)
nsImageFrame
(
aStyle
mKind
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsImageFrame
)
nsImageFrame
:
:
nsImageFrame
(
ComputedStyle
*
aStyle
ClassID
aID
Kind
aKind
)
:
nsAtomicContainerFrame
(
aStyle
aID
)
mComputedSize
(
0
0
)
mIntrinsicRatio
(
0
0
)
mKind
(
aKind
)
mContentURLRequestRegistered
(
false
)
mDisplayingIcon
(
false
)
mFirstFrameComplete
(
false
)
mReflowCallbackPosted
(
false
)
mForceSyncDecoding
(
false
)
{
EnableVisibilityTracking
(
)
;
mIntrinsicSize
.
width
.
SetCoordValue
(
0
)
;
mIntrinsicSize
.
height
.
SetCoordValue
(
0
)
;
}
nsImageFrame
:
:
~
nsImageFrame
(
)
{
}
NS_QUERYFRAME_HEAD
(
nsImageFrame
)
NS_QUERYFRAME_ENTRY
(
nsImageFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsAtomicContainerFrame
)
#
ifdef
ACCESSIBILITY
a11y
:
:
AccType
nsImageFrame
:
:
AccessibleType
(
)
{
if
(
HasImageMap
(
)
)
{
return
a11y
:
:
eHTMLImageMapType
;
}
return
a11y
:
:
eImageType
;
}
#
endif
void
nsImageFrame
:
:
DisconnectMap
(
)
{
if
(
!
mImageMap
)
{
return
;
}
mImageMap
-
>
Destroy
(
)
;
mImageMap
=
nullptr
;
#
ifdef
ACCESSIBILITY
if
(
nsAccessibilityService
*
accService
=
GetAccService
(
)
)
{
accService
-
>
RecreateAccessible
(
PresShell
(
)
mContent
)
;
}
#
endif
}
void
nsImageFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
{
if
(
mReflowCallbackPosted
)
{
PresShell
(
)
-
>
CancelReflowCallback
(
this
)
;
mReflowCallbackPosted
=
false
;
}
DisconnectMap
(
)
;
MOZ_ASSERT
(
mListener
)
;
if
(
mKind
=
=
Kind
:
:
ImageElement
)
{
MOZ_ASSERT
(
!
mContentURLRequest
)
;
MOZ_ASSERT
(
!
mContentURLRequestRegistered
)
;
nsCOMPtr
<
nsIImageLoadingContent
>
imageLoader
=
do_QueryInterface
(
mContent
)
;
MOZ_ASSERT
(
imageLoader
)
;
imageLoader
-
>
FrameDestroyed
(
this
)
;
imageLoader
-
>
RemoveNativeObserver
(
mListener
)
;
}
else
{
if
(
mContentURLRequest
)
{
nsLayoutUtils
:
:
DeregisterImageRequest
(
PresContext
(
)
mContentURLRequest
&
mContentURLRequestRegistered
)
;
mContentURLRequest
-
>
Cancel
(
NS_BINDING_ABORTED
)
;
}
}
mListener
-
>
SetFrame
(
nullptr
)
;
mListener
=
nullptr
;
if
(
mDisplayingIcon
)
gIconLoad
-
>
RemoveIconObserver
(
this
)
;
nsAtomicContainerFrame
:
:
DestroyFrom
(
aDestructRoot
aPostDestroyData
)
;
}
void
nsImageFrame
:
:
DidSetComputedStyle
(
ComputedStyle
*
aOldComputedStyle
)
{
nsAtomicContainerFrame
:
:
DidSetComputedStyle
(
aOldComputedStyle
)
;
if
(
!
mImage
)
{
return
;
}
auto
newOrientation
=
StyleVisibility
(
)
-
>
mImageOrientation
;
bool
shouldUpdateOrientation
=
!
aOldComputedStyle
|
|
aOldComputedStyle
-
>
StyleVisibility
(
)
-
>
mImageOrientation
!
=
newOrientation
;
if
(
shouldUpdateOrientation
)
{
nsCOMPtr
<
imgIContainer
>
image
(
mImage
-
>
Unwrap
(
)
)
;
mImage
=
nsLayoutUtils
:
:
OrientImage
(
image
newOrientation
)
;
UpdateIntrinsicSize
(
mImage
)
;
UpdateIntrinsicRatio
(
mImage
)
;
}
}
static
bool
SizeIsAvailable
(
imgIRequest
*
aRequest
)
{
if
(
!
aRequest
)
{
return
false
;
}
uint32_t
imageStatus
=
0
;
nsresult
rv
=
aRequest
-
>
GetImageStatus
(
&
imageStatus
)
;
return
NS_SUCCEEDED
(
rv
)
&
&
(
imageStatus
&
imgIRequest
:
:
STATUS_SIZE_AVAILABLE
)
;
}
void
nsImageFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
MOZ_ASSERT_IF
(
aPrevInFlow
aPrevInFlow
-
>
Type
(
)
=
=
Type
(
)
&
&
static_cast
<
nsImageFrame
*
>
(
aPrevInFlow
)
-
>
mKind
=
=
mKind
)
;
nsAtomicContainerFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
mListener
=
new
nsImageListener
(
this
)
;
if
(
!
gIconLoad
)
LoadIcons
(
PresContext
(
)
)
;
if
(
mKind
=
=
Kind
:
:
ImageElement
)
{
nsCOMPtr
<
nsIImageLoadingContent
>
imageLoader
=
do_QueryInterface
(
aContent
)
;
MOZ_ASSERT
(
imageLoader
)
;
imageLoader
-
>
AddNativeObserver
(
mListener
)
;
imageLoader
-
>
FrameCreated
(
this
)
;
}
else
{
if
(
auto
*
proxy
=
StyleContent
(
)
-
>
ContentAt
(
0
)
.
GetImage
(
)
)
{
proxy
-
>
Clone
(
mListener
mContent
-
>
OwnerDoc
(
)
getter_AddRefs
(
mContentURLRequest
)
)
;
SetupForContentURLRequest
(
)
;
}
}
if
(
nsCOMPtr
<
imgIRequest
>
currentRequest
=
GetCurrentRequest
(
)
)
{
uint32_t
categoryToBoostPriority
=
imgIRequest
:
:
CATEGORY_FRAME_INIT
;
if
(
!
HaveSpecifiedSize
(
StylePosition
(
)
)
)
{
categoryToBoostPriority
|
=
imgIRequest
:
:
CATEGORY_SIZE_QUERY
;
}
currentRequest
-
>
BoostPriority
(
categoryToBoostPriority
)
;
}
}
void
nsImageFrame
:
:
SetupForContentURLRequest
(
)
{
MOZ_ASSERT
(
mKind
!
=
Kind
:
:
ImageElement
)
;
if
(
!
mContentURLRequest
)
{
return
;
}
uint32_t
status
=
0
;
nsresult
rv
=
mContentURLRequest
-
>
GetImageStatus
(
&
status
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
if
(
status
&
imgIRequest
:
:
STATUS_SIZE_AVAILABLE
)
{
nsCOMPtr
<
imgIContainer
>
image
;
mContentURLRequest
-
>
GetImage
(
getter_AddRefs
(
image
)
)
;
OnSizeAvailable
(
mContentURLRequest
image
)
;
}
if
(
status
&
imgIRequest
:
:
STATUS_FRAME_COMPLETE
)
{
mFirstFrameComplete
=
true
;
}
if
(
status
&
imgIRequest
:
:
STATUS_IS_ANIMATED
)
{
nsLayoutUtils
:
:
RegisterImageRequest
(
PresContext
(
)
mContentURLRequest
&
mContentURLRequestRegistered
)
;
}
}
static
void
ScaleIntrinsicSizeForDensity
(
nsIContent
&
aContent
nsSize
&
aSize
)
{
auto
*
image
=
HTMLImageElement
:
:
FromNode
(
aContent
)
;
if
(
!
image
)
{
return
;
}
ResponsiveImageSelector
*
selector
=
image
-
>
GetResponsiveImageSelector
(
)
;
if
(
!
selector
)
{
return
;
}
double
density
=
selector
-
>
GetSelectedImageDensity
(
)
;
MOZ_ASSERT
(
density
>
0
.
0
)
;
if
(
density
=
=
1
.
0
)
{
return
;
}
if
(
aSize
.
width
!
=
-
1
)
{
aSize
.
width
=
NSToCoordRound
(
double
(
aSize
.
width
)
/
density
)
;
}
if
(
aSize
.
height
!
=
-
1
)
{
aSize
.
height
=
NSToCoordRound
(
double
(
aSize
.
height
)
/
density
)
;
}
}
bool
nsImageFrame
:
:
UpdateIntrinsicSize
(
imgIContainer
*
aImage
)
{
MOZ_ASSERT
(
aImage
"
null
image
"
)
;
if
(
!
aImage
)
return
false
;
IntrinsicSize
oldIntrinsicSize
=
mIntrinsicSize
;
mIntrinsicSize
=
IntrinsicSize
(
)
;
nsSize
intrinsicSize
;
if
(
NS_SUCCEEDED
(
aImage
-
>
GetIntrinsicSize
(
&
intrinsicSize
)
)
)
{
if
(
mKind
=
=
Kind
:
:
ImageElement
)
{
ScaleIntrinsicSizeForDensity
(
*
mContent
intrinsicSize
)
;
}
if
(
intrinsicSize
.
width
!
=
-
1
)
mIntrinsicSize
.
width
.
SetCoordValue
(
intrinsicSize
.
width
)
;
if
(
intrinsicSize
.
height
!
=
-
1
)
mIntrinsicSize
.
height
.
SetCoordValue
(
intrinsicSize
.
height
)
;
}
else
{
mIntrinsicSize
.
width
.
SetCoordValue
(
0
)
;
mIntrinsicSize
.
height
.
SetCoordValue
(
0
)
;
}
return
mIntrinsicSize
!
=
oldIntrinsicSize
;
}
bool
nsImageFrame
:
:
UpdateIntrinsicRatio
(
imgIContainer
*
aImage
)
{
MOZ_ASSERT
(
aImage
"
null
image
"
)
;
if
(
!
aImage
)
return
false
;
nsSize
oldIntrinsicRatio
=
mIntrinsicRatio
;
if
(
NS_FAILED
(
aImage
-
>
GetIntrinsicRatio
(
&
mIntrinsicRatio
)
)
)
mIntrinsicRatio
.
SizeTo
(
0
0
)
;
return
mIntrinsicRatio
!
=
oldIntrinsicRatio
;
}
bool
nsImageFrame
:
:
GetSourceToDestTransform
(
nsTransform2D
&
aTransform
)
{
nsRect
constraintRect
(
GetInnerArea
(
)
.
TopLeft
(
)
mComputedSize
)
;
constraintRect
.
y
-
=
GetContinuationOffset
(
)
;
nsRect
destRect
=
nsLayoutUtils
:
:
ComputeObjectDestRect
(
constraintRect
mIntrinsicSize
mIntrinsicRatio
StylePosition
(
)
)
;
aTransform
.
SetToTranslate
(
float
(
destRect
.
x
)
float
(
destRect
.
y
)
)
;
nsSize
intrinsicSize
;
if
(
!
mImage
|
|
!
NS_SUCCEEDED
(
mImage
-
>
GetIntrinsicSize
(
&
intrinsicSize
)
)
|
|
intrinsicSize
.
IsEmpty
(
)
)
{
return
false
;
}
aTransform
.
SetScale
(
float
(
destRect
.
width
)
/
float
(
intrinsicSize
.
width
)
float
(
destRect
.
height
)
/
float
(
intrinsicSize
.
height
)
)
;
return
true
;
}
bool
nsImageFrame
:
:
IsPendingLoad
(
imgIRequest
*
aRequest
)
const
{
if
(
mKind
=
=
Kind
:
:
NonGeneratedContentProperty
)
{
MOZ_ASSERT
(
aRequest
=
=
mContentURLRequest
)
;
return
false
;
}
nsCOMPtr
<
nsIImageLoadingContent
>
imageLoader
(
do_QueryInterface
(
mContent
)
)
;
MOZ_ASSERT
(
imageLoader
)
;
int32_t
requestType
=
nsIImageLoadingContent
:
:
UNKNOWN_REQUEST
;
imageLoader
-
>
GetRequestType
(
aRequest
&
requestType
)
;
return
requestType
!
=
nsIImageLoadingContent
:
:
CURRENT_REQUEST
;
}
nsRect
nsImageFrame
:
:
SourceRectToDest
(
const
nsIntRect
&
aRect
)
{
nsRect
r
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
aRect
.
x
-
1
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
aRect
.
y
-
1
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
aRect
.
width
+
2
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
aRect
.
height
+
2
)
)
;
nsTransform2D
sourceToDest
;
if
(
!
GetSourceToDestTransform
(
sourceToDest
)
)
{
return
GetInnerArea
(
)
;
}
sourceToDest
.
TransformCoord
(
&
r
.
x
&
r
.
y
&
r
.
width
&
r
.
height
)
;
nscoord
scale
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
1
)
;
nscoord
right
=
r
.
x
+
r
.
width
;
nscoord
bottom
=
r
.
y
+
r
.
height
;
r
.
x
-
=
(
scale
+
(
r
.
x
%
scale
)
)
%
scale
;
r
.
y
-
=
(
scale
+
(
r
.
y
%
scale
)
)
%
scale
;
r
.
width
=
right
+
(
(
scale
-
(
right
%
scale
)
)
%
scale
)
-
r
.
x
;
r
.
height
=
bottom
+
(
(
scale
-
(
bottom
%
scale
)
)
%
scale
)
-
r
.
y
;
return
r
;
}
#
define
BAD_STATES
(
NS_EVENT_STATE_BROKEN
|
NS_EVENT_STATE_USERDISABLED
|
\
NS_EVENT_STATE_LOADING
)
#
define
IMAGE_OK
(
_state
_loadingOK
)
\
(
!
(
_state
)
.
HasAtLeastOneOfStates
(
BAD_STATES
)
|
|
\
(
!
(
_state
)
.
HasAtLeastOneOfStates
(
NS_EVENT_STATE_BROKEN
|
NS_EVENT_STATE_USERDISABLED
)
&
&
\
(
_state
)
.
HasState
(
NS_EVENT_STATE_LOADING
)
&
&
(
_loadingOK
)
)
)
bool
nsImageFrame
:
:
ShouldCreateImageFrameFor
(
Element
*
aElement
ComputedStyle
*
aComputedStyle
)
{
EventStates
state
=
aElement
-
>
State
(
)
;
if
(
IMAGE_OK
(
state
HaveSpecifiedSize
(
aComputedStyle
-
>
StylePosition
(
)
)
)
)
{
return
true
;
}
bool
useSizedBox
;
if
(
aComputedStyle
-
>
StyleUIReset
(
)
-
>
mForceBrokenImageIcon
)
{
useSizedBox
=
true
;
}
else
if
(
gIconLoad
&
&
gIconLoad
-
>
mPrefForceInlineAltText
)
{
useSizedBox
=
false
;
}
else
if
(
aElement
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
src
)
&
&
!
aElement
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
alt
)
&
&
!
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
object
)
&
&
!
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
input
)
)
{
useSizedBox
=
true
;
}
else
if
(
aElement
-
>
OwnerDoc
(
)
-
>
GetCompatibilityMode
(
)
!
=
eCompatibility_NavQuirks
)
{
useSizedBox
=
false
;
}
else
{
useSizedBox
=
HaveSpecifiedSize
(
aComputedStyle
-
>
StylePosition
(
)
)
;
}
return
useSizedBox
;
}
nsresult
nsImageFrame
:
:
Notify
(
imgIRequest
*
aRequest
int32_t
aType
const
nsIntRect
*
aRect
)
{
if
(
aType
=
=
imgINotificationObserver
:
:
SIZE_AVAILABLE
)
{
nsCOMPtr
<
imgIContainer
>
image
;
aRequest
-
>
GetImage
(
getter_AddRefs
(
image
)
)
;
return
OnSizeAvailable
(
aRequest
image
)
;
}
if
(
aType
=
=
imgINotificationObserver
:
:
FRAME_UPDATE
)
{
return
OnFrameUpdate
(
aRequest
aRect
)
;
}
if
(
aType
=
=
imgINotificationObserver
:
:
FRAME_COMPLETE
)
{
mFirstFrameComplete
=
true
;
}
if
(
aType
=
=
imgINotificationObserver
:
:
IS_ANIMATED
&
&
mKind
!
=
Kind
:
:
ImageElement
)
{
nsLayoutUtils
:
:
RegisterImageRequest
(
PresContext
(
)
mContentURLRequest
&
mContentURLRequestRegistered
)
;
}
if
(
aType
=
=
imgINotificationObserver
:
:
LOAD_COMPLETE
)
{
uint32_t
imgStatus
;
aRequest
-
>
GetImageStatus
(
&
imgStatus
)
;
nsresult
status
=
imgStatus
&
imgIRequest
:
:
STATUS_ERROR
?
NS_ERROR_FAILURE
:
NS_OK
;
return
OnLoadComplete
(
aRequest
status
)
;
}
return
NS_OK
;
}
nsresult
nsImageFrame
:
:
OnSizeAvailable
(
imgIRequest
*
aRequest
imgIContainer
*
aImage
)
{
if
(
!
aImage
)
{
return
NS_ERROR_INVALID_ARG
;
}
aImage
-
>
SetAnimationMode
(
PresContext
(
)
-
>
ImageAnimationMode
(
)
)
;
if
(
IsPendingLoad
(
aRequest
)
)
{
return
NS_OK
;
}
bool
intrinsicSizeChanged
=
false
;
if
(
SizeIsAvailable
(
aRequest
)
)
{
mImage
=
nsLayoutUtils
:
:
OrientImage
(
aImage
StyleVisibility
(
)
-
>
mImageOrientation
)
;
intrinsicSizeChanged
=
UpdateIntrinsicSize
(
mImage
)
;
intrinsicSizeChanged
=
UpdateIntrinsicRatio
(
mImage
)
|
|
intrinsicSizeChanged
;
}
else
{
mImage
=
mPrevImage
=
nullptr
;
mIntrinsicSize
.
width
.
SetCoordValue
(
0
)
;
mIntrinsicSize
.
height
.
SetCoordValue
(
0
)
;
mIntrinsicRatio
.
SizeTo
(
0
0
)
;
intrinsicSizeChanged
=
true
;
}
if
(
!
GotInitialReflow
(
)
)
{
return
NS_OK
;
}
MarkNeedsDisplayItemRebuild
(
)
;
if
(
intrinsicSizeChanged
)
{
if
(
!
(
mState
&
IMAGE_SIZECONSTRAINED
)
)
{
PresShell
(
)
-
>
FrameNeedsReflow
(
this
nsIPresShell
:
:
eStyleChange
NS_FRAME_IS_DIRTY
)
;
}
else
{
MaybeDecodeForPredictedSize
(
)
;
}
mPrevImage
=
nullptr
;
}
return
NS_OK
;
}
nsresult
nsImageFrame
:
:
OnFrameUpdate
(
imgIRequest
*
aRequest
const
nsIntRect
*
aRect
)
{
NS_ENSURE_ARG_POINTER
(
aRect
)
;
if
(
!
GotInitialReflow
(
)
)
{
return
NS_OK
;
}
if
(
mFirstFrameComplete
&
&
!
StyleVisibility
(
)
-
>
IsVisible
(
)
)
{
return
NS_OK
;
}
if
(
IsPendingLoad
(
aRequest
)
)
{
return
NS_OK
;
}
nsIntRect
layerInvalidRect
=
mImage
?
mImage
-
>
GetImageSpaceInvalidationRect
(
*
aRect
)
:
*
aRect
;
if
(
layerInvalidRect
.
IsEqualInterior
(
GetMaxSizedIntRect
(
)
)
)
{
InvalidateSelf
(
nullptr
nullptr
)
;
return
NS_OK
;
}
nsRect
frameInvalidRect
=
SourceRectToDest
(
layerInvalidRect
)
;
InvalidateSelf
(
&
layerInvalidRect
&
frameInvalidRect
)
;
return
NS_OK
;
}
void
nsImageFrame
:
:
InvalidateSelf
(
const
nsIntRect
*
aLayerInvalidRect
const
nsRect
*
aFrameInvalidRect
)
{
if
(
HasProperty
(
WebRenderUserDataProperty
:
:
Key
(
)
)
)
{
RefPtr
<
WebRenderFallbackData
>
data
=
GetWebRenderUserData
<
WebRenderFallbackData
>
(
this
static_cast
<
uint32_t
>
(
DisplayItemType
:
:
TYPE_IMAGE
)
)
;
if
(
data
)
{
data
-
>
SetInvalid
(
true
)
;
}
SchedulePaint
(
)
;
return
;
}
InvalidateLayer
(
DisplayItemType
:
:
TYPE_IMAGE
aLayerInvalidRect
aFrameInvalidRect
)
;
if
(
!
mFirstFrameComplete
)
{
InvalidateLayer
(
DisplayItemType
:
:
TYPE_ALT_FEEDBACK
aLayerInvalidRect
aFrameInvalidRect
)
;
}
}
nsresult
nsImageFrame
:
:
OnLoadComplete
(
imgIRequest
*
aRequest
nsresult
aStatus
)
{
NotifyNewCurrentRequest
(
aRequest
aStatus
)
;
return
NS_OK
;
}
void
nsImageFrame
:
:
ResponsiveContentDensityChanged
(
)
{
if
(
!
GotInitialReflow
(
)
)
{
return
;
}
if
(
!
mImage
)
{
return
;
}
if
(
!
UpdateIntrinsicSize
(
mImage
)
&
&
!
UpdateIntrinsicRatio
(
mImage
)
)
{
return
;
}
PresShell
(
)
-
>
FrameNeedsReflow
(
this
nsIPresShell
:
:
eStyleChange
NS_FRAME_IS_DIRTY
)
;
}
void
nsImageFrame
:
:
NotifyNewCurrentRequest
(
imgIRequest
*
aRequest
nsresult
aStatus
)
{
nsCOMPtr
<
imgIContainer
>
image
;
aRequest
-
>
GetImage
(
getter_AddRefs
(
image
)
)
;
NS_ASSERTION
(
image
|
|
NS_FAILED
(
aStatus
)
"
Successful
load
with
no
container
?
"
)
;
bool
intrinsicSizeChanged
=
true
;
if
(
NS_SUCCEEDED
(
aStatus
)
&
&
image
&
&
SizeIsAvailable
(
aRequest
)
)
{
mImage
=
nsLayoutUtils
:
:
OrientImage
(
image
StyleVisibility
(
)
-
>
mImageOrientation
)
;
intrinsicSizeChanged
=
UpdateIntrinsicSize
(
mImage
)
;
intrinsicSizeChanged
=
UpdateIntrinsicRatio
(
mImage
)
|
|
intrinsicSizeChanged
;
}
else
{
mImage
=
mPrevImage
=
nullptr
;
mIntrinsicSize
.
width
.
SetCoordValue
(
0
)
;
mIntrinsicSize
.
height
.
SetCoordValue
(
0
)
;
mIntrinsicRatio
.
SizeTo
(
0
0
)
;
}
if
(
GotInitialReflow
(
)
)
{
if
(
intrinsicSizeChanged
)
{
if
(
!
(
mState
&
IMAGE_SIZECONSTRAINED
)
)
{
PresShell
(
)
-
>
FrameNeedsReflow
(
this
nsIPresShell
:
:
eStyleChange
NS_FRAME_IS_DIRTY
)
;
}
else
{
MaybeDecodeForPredictedSize
(
)
;
}
mPrevImage
=
nullptr
;
}
InvalidateFrame
(
)
;
}
}
void
nsImageFrame
:
:
MaybeDecodeForPredictedSize
(
)
{
if
(
!
mImage
)
{
return
;
}
if
(
mComputedSize
.
IsEmpty
(
)
)
{
return
;
}
if
(
GetVisibility
(
)
!
=
Visibility
:
:
APPROXIMATELY_VISIBLE
)
{
return
;
}
nsIPresShell
*
presShell
=
PresContext
(
)
-
>
GetPresShell
(
)
;
LayoutDeviceToScreenScale2D
resolutionToScreen
(
presShell
-
>
GetCumulativeResolution
(
)
*
nsLayoutUtils
:
:
GetTransformToAncestorScaleExcludingAnimated
(
this
)
)
;
const
nsPoint
offset
=
GetOffsetToCrossDoc
(
nsLayoutUtils
:
:
GetReferenceFrame
(
this
)
)
;
const
nsRect
frameContentBox
=
GetInnerArea
(
)
+
offset
;
const
int32_t
factor
=
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
const
LayoutDeviceRect
destRect
=
LayoutDeviceRect
:
:
FromAppUnits
(
PredictedDestRect
(
frameContentBox
)
factor
)
;
const
ScreenSize
predictedScreenSize
=
destRect
.
Size
(
)
*
resolutionToScreen
;
const
ScreenIntSize
predictedScreenIntSize
=
RoundedToInt
(
predictedScreenSize
)
;
if
(
predictedScreenIntSize
.
IsEmpty
(
)
)
{
return
;
}
uint32_t
flags
=
imgIContainer
:
:
FLAG_HIGH_QUALITY_SCALING
|
imgIContainer
:
:
FLAG_ASYNC_NOTIFY
;
SamplingFilter
samplingFilter
=
nsLayoutUtils
:
:
GetSamplingFilterForFrame
(
this
)
;
gfxSize
gfxPredictedScreenSize
=
gfxSize
(
predictedScreenIntSize
.
width
predictedScreenIntSize
.
height
)
;
nsIntSize
predictedImageSize
=
mImage
-
>
OptimalImageSizeForDest
(
gfxPredictedScreenSize
imgIContainer
:
:
FRAME_CURRENT
samplingFilter
flags
)
;
mImage
-
>
RequestDecodeForSize
(
predictedImageSize
flags
)
;
}
nsRect
nsImageFrame
:
:
PredictedDestRect
(
const
nsRect
&
aFrameContentBox
)
{
nsRect
constraintRect
(
aFrameContentBox
.
TopLeft
(
)
mComputedSize
)
;
constraintRect
.
y
-
=
GetContinuationOffset
(
)
;
return
nsLayoutUtils
:
:
ComputeObjectDestRect
(
constraintRect
mIntrinsicSize
mIntrinsicRatio
StylePosition
(
)
)
;
}
void
nsImageFrame
:
:
EnsureIntrinsicSizeAndRatio
(
)
{
if
(
mIntrinsicSize
.
width
.
GetUnit
(
)
!
=
eStyleUnit_Coord
|
|
mIntrinsicSize
.
width
.
GetCoordValue
(
)
!
=
0
|
|
mIntrinsicSize
.
height
.
GetUnit
(
)
!
=
eStyleUnit_Coord
|
|
mIntrinsicSize
.
height
.
GetCoordValue
(
)
!
=
0
)
{
return
;
}
if
(
mImage
)
{
UpdateIntrinsicSize
(
mImage
)
;
UpdateIntrinsicRatio
(
mImage
)
;
return
;
}
const
bool
mayDisplayBrokenIcon
=
IsForNonGeneratedImageElement
(
)
;
if
(
!
mayDisplayBrokenIcon
)
{
return
;
}
bool
imageInvalid
=
false
;
if
(
nsCOMPtr
<
imgIRequest
>
currentRequest
=
GetCurrentRequest
(
)
)
{
uint32_t
imageStatus
;
imageInvalid
=
NS_SUCCEEDED
(
currentRequest
-
>
GetImageStatus
(
&
imageStatus
)
)
&
&
(
imageStatus
&
imgIRequest
:
:
STATUS_ERROR
)
;
}
else
{
MOZ_ASSERT
(
mKind
=
=
Kind
:
:
ImageElement
)
;
nsCOMPtr
<
nsIImageLoadingContent
>
loader
=
do_QueryInterface
(
mContent
)
;
MOZ_ASSERT
(
loader
)
;
int16_t
imageBlockingStatus
;
loader
-
>
GetImageBlockingStatus
(
&
imageBlockingStatus
)
;
imageInvalid
=
imageBlockingStatus
!
=
nsIContentPolicy
:
:
ACCEPT
;
}
if
(
imageInvalid
)
{
nscoord
edgeLengthToUse
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
ICON_SIZE
+
(
2
*
(
ICON_PADDING
+
ALT_BORDER_WIDTH
)
)
)
;
mIntrinsicSize
.
width
.
SetCoordValue
(
edgeLengthToUse
)
;
mIntrinsicSize
.
height
.
SetCoordValue
(
edgeLengthToUse
)
;
mIntrinsicRatio
.
SizeTo
(
1
1
)
;
}
}
LogicalSize
nsImageFrame
:
:
ComputeSize
(
gfxContext
*
aRenderingContext
WritingMode
aWM
const
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
LogicalSize
&
aMargin
const
LogicalSize
&
aBorder
const
LogicalSize
&
aPadding
ComputeSizeFlags
aFlags
)
{
EnsureIntrinsicSizeAndRatio
(
)
;
return
ComputeSizeWithIntrinsicDimensions
(
aRenderingContext
aWM
mIntrinsicSize
mIntrinsicRatio
aCBSize
aMargin
aBorder
aPadding
aFlags
)
;
}
nsRect
nsImageFrame
:
:
GetInnerArea
(
)
const
{
return
GetContentRectRelativeToSelf
(
)
;
}
Element
*
nsImageFrame
:
:
GetMapElement
(
)
const
{
nsCOMPtr
<
nsIImageLoadingContent
>
imageLoader
=
do_QueryInterface
(
mContent
)
;
return
imageLoader
?
static_cast
<
nsImageLoadingContent
*
>
(
imageLoader
.
get
(
)
)
-
>
FindImageMap
(
)
:
nullptr
;
}
nscoord
nsImageFrame
:
:
GetContinuationOffset
(
)
const
{
nscoord
offset
=
0
;
for
(
nsIFrame
*
f
=
GetPrevInFlow
(
)
;
f
;
f
=
f
-
>
GetPrevInFlow
(
)
)
{
offset
+
=
f
-
>
GetContentRect
(
)
.
height
;
}
NS_ASSERTION
(
offset
>
=
0
"
bogus
GetContentRect
"
)
;
return
offset
;
}
nscoord
nsImageFrame
:
:
GetMinISize
(
gfxContext
*
aRenderingContext
)
{
DebugOnly
<
nscoord
>
result
;
DISPLAY_MIN_WIDTH
(
this
result
)
;
EnsureIntrinsicSizeAndRatio
(
)
;
return
mIntrinsicSize
.
width
.
GetUnit
(
)
=
=
eStyleUnit_Coord
?
mIntrinsicSize
.
width
.
GetCoordValue
(
)
:
0
;
}
nscoord
nsImageFrame
:
:
GetPrefISize
(
gfxContext
*
aRenderingContext
)
{
DebugOnly
<
nscoord
>
result
;
DISPLAY_PREF_WIDTH
(
this
result
)
;
EnsureIntrinsicSizeAndRatio
(
)
;
return
mIntrinsicSize
.
width
.
GetUnit
(
)
=
=
eStyleUnit_Coord
?
mIntrinsicSize
.
width
.
GetCoordValue
(
)
:
0
;
}
IntrinsicSize
nsImageFrame
:
:
GetIntrinsicSize
(
)
{
return
mIntrinsicSize
;
}
nsSize
nsImageFrame
:
:
GetIntrinsicRatio
(
)
{
return
mIntrinsicRatio
;
}
void
nsImageFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aMetrics
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsImageFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aMetrics
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
NS_FRAME_TRACE
(
NS_FRAME_TRACE_CALLS
(
"
enter
nsImageFrame
:
:
Reflow
:
availSize
=
%
d
%
d
"
aReflowInput
.
AvailableWidth
(
)
aReflowInput
.
AvailableHeight
(
)
)
)
;
MOZ_ASSERT
(
mState
&
NS_FRAME_IN_REFLOW
"
frame
is
not
in
reflow
"
)
;
if
(
HaveFixedSize
(
aReflowInput
)
)
{
AddStateBits
(
IMAGE_SIZECONSTRAINED
)
;
}
else
{
RemoveStateBits
(
IMAGE_SIZECONSTRAINED
)
;
}
mComputedSize
=
nsSize
(
aReflowInput
.
ComputedWidth
(
)
aReflowInput
.
ComputedHeight
(
)
)
;
aMetrics
.
Width
(
)
=
mComputedSize
.
width
;
aMetrics
.
Height
(
)
=
mComputedSize
.
height
;
aMetrics
.
Width
(
)
+
=
aReflowInput
.
ComputedPhysicalBorderPadding
(
)
.
LeftRight
(
)
;
aMetrics
.
Height
(
)
+
=
aReflowInput
.
ComputedPhysicalBorderPadding
(
)
.
TopBottom
(
)
;
if
(
GetPrevInFlow
(
)
)
{
aMetrics
.
Width
(
)
=
GetPrevInFlow
(
)
-
>
GetSize
(
)
.
width
;
nscoord
y
=
GetContinuationOffset
(
)
;
aMetrics
.
Height
(
)
-
=
y
+
aReflowInput
.
ComputedPhysicalBorderPadding
(
)
.
top
;
aMetrics
.
Height
(
)
=
std
:
:
max
(
0
aMetrics
.
Height
(
)
)
;
}
uint32_t
loadStatus
=
imgIRequest
:
:
STATUS_NONE
;
if
(
nsCOMPtr
<
imgIRequest
>
currentRequest
=
GetCurrentRequest
(
)
)
{
currentRequest
-
>
GetImageStatus
(
&
loadStatus
)
;
}
if
(
aPresContext
-
>
IsPaginated
(
)
&
&
(
(
loadStatus
&
imgIRequest
:
:
STATUS_SIZE_AVAILABLE
)
|
|
(
mState
&
IMAGE_SIZECONSTRAINED
)
)
&
&
NS_UNCONSTRAINEDSIZE
!
=
aReflowInput
.
AvailableHeight
(
)
&
&
aMetrics
.
Height
(
)
>
aReflowInput
.
AvailableHeight
(
)
)
{
aMetrics
.
Height
(
)
=
std
:
:
max
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
1
)
aReflowInput
.
AvailableHeight
(
)
)
;
aStatus
.
SetIncomplete
(
)
;
}
aMetrics
.
SetOverflowAreasToDesiredBounds
(
)
;
EventStates
contentState
=
mContent
-
>
AsElement
(
)
-
>
State
(
)
;
bool
imageOK
=
IMAGE_OK
(
contentState
true
)
;
bool
haveSize
=
false
;
if
(
loadStatus
&
imgIRequest
:
:
STATUS_SIZE_AVAILABLE
)
{
haveSize
=
true
;
}
if
(
!
imageOK
|
|
!
haveSize
)
{
nsRect
altFeedbackSize
(
0
0
nsPresContext
:
:
CSSPixelsToAppUnits
(
ICON_SIZE
+
2
*
(
ICON_PADDING
+
ALT_BORDER_WIDTH
)
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
ICON_SIZE
+
2
*
(
ICON_PADDING
+
ALT_BORDER_WIDTH
)
)
)
;
static_assert
(
eOverflowType_LENGTH
=
=
2
"
Unknown
overflow
types
?
"
)
;
nsRect
&
visualOverflow
=
aMetrics
.
VisualOverflow
(
)
;
visualOverflow
.
UnionRect
(
visualOverflow
altFeedbackSize
)
;
}
else
{
MaybeDecodeForPredictedSize
(
)
;
}
FinishAndStoreOverflow
(
&
aMetrics
aReflowInput
.
mStyleDisplay
)
;
if
(
(
GetStateBits
(
)
&
NS_FRAME_FIRST_REFLOW
)
&
&
!
mReflowCallbackPosted
)
{
nsIPresShell
*
shell
=
PresShell
(
)
;
mReflowCallbackPosted
=
true
;
shell
-
>
PostReflowCallback
(
this
)
;
}
NS_FRAME_TRACE
(
NS_FRAME_TRACE_CALLS
(
"
exit
nsImageFrame
:
:
Reflow
:
size
=
%
d
%
d
"
aMetrics
.
Width
(
)
aMetrics
.
Height
(
)
)
)
;
NS_FRAME_SET_TRUNCATION
(
aStatus
aReflowInput
aMetrics
)
;
}
bool
nsImageFrame
:
:
ReflowFinished
(
)
{
mReflowCallbackPosted
=
false
;
UpdateVisibilitySynchronously
(
)
;
return
false
;
}
void
nsImageFrame
:
:
ReflowCallbackCanceled
(
)
{
mReflowCallbackPosted
=
false
;
}
nscoord
nsImageFrame
:
:
MeasureString
(
const
char16_t
*
aString
int32_t
aLength
nscoord
aMaxWidth
uint32_t
&
aMaxFit
gfxContext
&
aContext
nsFontMetrics
&
aFontMetrics
)
{
nscoord
totalWidth
=
0
;
aFontMetrics
.
SetTextRunRTL
(
false
)
;
nscoord
spaceWidth
=
aFontMetrics
.
SpaceWidth
(
)
;
aMaxFit
=
0
;
while
(
aLength
>
0
)
{
uint32_t
len
=
aLength
;
bool
trailingSpace
=
false
;
for
(
int32_t
i
=
0
;
i
<
aLength
;
i
+
+
)
{
if
(
dom
:
:
IsSpaceCharacter
(
aString
[
i
]
)
&
&
(
i
>
0
)
)
{
len
=
i
;
trailingSpace
=
true
;
break
;
}
}
nscoord
width
=
nsLayoutUtils
:
:
AppUnitWidthOfStringBidi
(
aString
len
this
aFontMetrics
aContext
)
;
bool
fits
=
(
totalWidth
+
width
)
<
=
aMaxWidth
;
if
(
fits
|
|
(
0
=
=
totalWidth
)
)
{
totalWidth
+
=
width
;
if
(
trailingSpace
)
{
if
(
(
totalWidth
+
spaceWidth
)
<
=
aMaxWidth
)
{
totalWidth
+
=
spaceWidth
;
}
else
{
fits
=
false
;
}
len
+
+
;
}
aMaxFit
+
=
len
;
aString
+
=
len
;
aLength
-
=
len
;
}
if
(
!
fits
)
{
break
;
}
}
return
totalWidth
;
}
void
nsImageFrame
:
:
DisplayAltText
(
nsPresContext
*
aPresContext
gfxContext
&
aRenderingContext
const
nsString
&
aAltText
const
nsRect
&
aRect
)
{
aRenderingContext
.
SetColor
(
Color
:
:
FromABGR
(
StyleColor
(
)
-
>
mColor
)
)
;
RefPtr
<
nsFontMetrics
>
fm
=
nsLayoutUtils
:
:
GetInflatedFontMetricsForFrame
(
this
)
;
nscoord
maxAscent
=
fm
-
>
MaxAscent
(
)
;
nscoord
maxDescent
=
fm
-
>
MaxDescent
(
)
;
nscoord
lineHeight
=
fm
-
>
MaxHeight
(
)
;
WritingMode
wm
=
GetWritingMode
(
)
;
bool
isVertical
=
wm
.
IsVertical
(
)
;
fm
-
>
SetVertical
(
isVertical
)
;
fm
-
>
SetTextOrientation
(
StyleVisibility
(
)
-
>
mTextOrientation
)
;
const
char16_t
*
str
=
aAltText
.
get
(
)
;
int32_t
strLen
=
aAltText
.
Length
(
)
;
nsPoint
pt
=
wm
.
IsVerticalRL
(
)
?
aRect
.
TopRight
(
)
-
nsPoint
(
lineHeight
0
)
:
aRect
.
TopLeft
(
)
;
nscoord
iSize
=
isVertical
?
aRect
.
height
:
aRect
.
width
;
if
(
!
aPresContext
-
>
BidiEnabled
(
)
&
&
HasRTLChars
(
aAltText
)
)
{
aPresContext
-
>
SetBidiEnabled
(
)
;
}
bool
firstLine
=
true
;
while
(
strLen
>
0
)
{
if
(
!
firstLine
)
{
if
(
(
!
isVertical
&
&
(
pt
.
y
+
maxDescent
)
>
=
aRect
.
YMost
(
)
)
|
|
(
wm
.
IsVerticalRL
(
)
&
&
(
pt
.
x
+
maxDescent
<
aRect
.
x
)
)
|
|
(
wm
.
IsVerticalLR
(
)
&
&
(
pt
.
x
+
maxDescent
>
=
aRect
.
XMost
(
)
)
)
)
{
break
;
}
}
uint32_t
maxFit
;
nscoord
strWidth
=
MeasureString
(
str
strLen
iSize
maxFit
aRenderingContext
*
fm
)
;
nsresult
rv
=
NS_ERROR_FAILURE
;
if
(
aPresContext
-
>
BidiEnabled
(
)
)
{
nsBidiDirection
dir
;
nscoord
x
y
;
if
(
isVertical
)
{
x
=
pt
.
x
+
maxDescent
;
if
(
wm
.
IsBidiLTR
(
)
)
{
y
=
aRect
.
y
;
dir
=
NSBIDI_LTR
;
}
else
{
y
=
aRect
.
YMost
(
)
-
strWidth
;
dir
=
NSBIDI_RTL
;
}
}
else
{
y
=
pt
.
y
+
maxAscent
;
if
(
wm
.
IsBidiLTR
(
)
)
{
x
=
aRect
.
x
;
dir
=
NSBIDI_LTR
;
}
else
{
x
=
aRect
.
XMost
(
)
-
strWidth
;
dir
=
NSBIDI_RTL
;
}
}
rv
=
nsBidiPresUtils
:
:
RenderText
(
str
maxFit
dir
aPresContext
aRenderingContext
aRenderingContext
.
GetDrawTarget
(
)
*
fm
x
y
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
nsLayoutUtils
:
:
DrawUniDirString
(
str
maxFit
isVertical
?
nsPoint
(
pt
.
x
+
maxDescent
pt
.
y
)
:
nsPoint
(
pt
.
x
pt
.
y
+
maxAscent
)
*
fm
aRenderingContext
)
;
}
str
+
=
maxFit
;
strLen
-
=
maxFit
;
if
(
wm
.
IsVerticalRL
(
)
)
{
pt
.
x
-
=
lineHeight
;
}
else
if
(
wm
.
IsVerticalLR
(
)
)
{
pt
.
x
+
=
lineHeight
;
}
else
{
pt
.
y
+
=
lineHeight
;
}
firstLine
=
false
;
}
}
struct
nsRecessedBorder
:
public
nsStyleBorder
{
nsRecessedBorder
(
nscoord
aBorderWidth
nsPresContext
*
aPresContext
)
:
nsStyleBorder
(
aPresContext
)
{
NS_FOR_CSS_SIDES
(
side
)
{
BorderColorFor
(
side
)
=
StyleComplexColor
:
:
FromColor
(
NS_RGB
(
0
0
0
)
)
;
mBorder
.
Side
(
side
)
=
aBorderWidth
;
SetBorderStyle
(
side
NS_STYLE_BORDER_STYLE_INSET
)
;
}
}
}
;
class
nsDisplayAltFeedback
:
public
nsDisplayItem
{
public
:
nsDisplayAltFeedback
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
:
nsDisplayItem
(
aBuilder
aFrame
)
{
}
virtual
nsDisplayItemGeometry
*
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
new
nsDisplayItemGenericImageGeometry
(
this
aBuilder
)
;
}
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
{
auto
geometry
=
static_cast
<
const
nsDisplayItemGenericImageGeometry
*
>
(
aGeometry
)
;
if
(
aBuilder
-
>
ShouldSyncDecodeImages
(
)
&
&
geometry
-
>
ShouldInvalidateToSyncDecodeImages
(
)
)
{
bool
snap
;
aInvalidRegion
-
>
Or
(
*
aInvalidRegion
GetBounds
(
aBuilder
&
snap
)
)
;
}
nsDisplayItem
:
:
ComputeInvalidationRegion
(
aBuilder
aGeometry
aInvalidRegion
)
;
}
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
{
*
aSnap
=
false
;
return
mFrame
-
>
GetVisualOverflowRectRelativeToSelf
(
)
+
ToReferenceFrame
(
)
;
}
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
{
uint32_t
flags
=
imgIContainer
:
:
FLAG_SYNC_DECODE
;
nsImageFrame
*
f
=
static_cast
<
nsImageFrame
*
>
(
mFrame
)
;
ImgDrawResult
result
=
f
-
>
DisplayAltFeedback
(
*
aCtx
GetPaintRect
(
)
ToReferenceFrame
(
)
flags
)
;
nsDisplayItemGenericImageGeometry
:
:
UpdateDrawResult
(
this
result
)
;
}
NS_DISPLAY_DECL_NAME
(
"
AltFeedback
"
TYPE_ALT_FEEDBACK
)
}
;
ImgDrawResult
nsImageFrame
:
:
DisplayAltFeedback
(
gfxContext
&
aRenderingContext
const
nsRect
&
aDirtyRect
nsPoint
aPt
uint32_t
aFlags
)
{
MOZ_ASSERT
(
gIconLoad
"
How
did
we
succeed
in
Init
then
?
"
)
;
bool
isLoading
=
IMAGE_OK
(
GetContent
(
)
-
>
AsElement
(
)
-
>
State
(
)
true
)
;
nsRect
inner
=
GetInnerArea
(
)
+
aPt
;
nscoord
borderEdgeWidth
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
ALT_BORDER_WIDTH
)
;
if
(
inner
.
IsEmpty
(
)
)
{
inner
.
SizeTo
(
2
*
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
ICON_SIZE
+
ICON_PADDING
+
ALT_BORDER_WIDTH
)
)
2
*
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
ICON_SIZE
+
ICON_PADDING
+
ALT_BORDER_WIDTH
)
)
)
;
}
if
(
(
inner
.
width
<
2
*
borderEdgeWidth
)
|
|
(
inner
.
height
<
2
*
borderEdgeWidth
)
)
{
return
ImgDrawResult
:
:
SUCCESS
;
}
if
(
!
isLoading
|
|
gIconLoad
-
>
mPrefShowLoadingPlaceholder
)
{
nsRecessedBorder
recessedBorder
(
borderEdgeWidth
PresContext
(
)
)
;
MOZ_ASSERT
(
recessedBorder
.
mBorderImageSource
.
GetType
(
)
=
=
eStyleImageType_Null
)
;
Unused
<
<
nsCSSRendering
:
:
PaintBorderWithStyleBorder
(
PresContext
(
)
aRenderingContext
this
inner
inner
recessedBorder
mComputedStyle
PaintBorderFlags
:
:
SYNC_DECODE_IMAGES
)
;
}
inner
.
Deflate
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
ICON_PADDING
+
ALT_BORDER_WIDTH
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
ICON_PADDING
+
ALT_BORDER_WIDTH
)
)
;
if
(
inner
.
IsEmpty
(
)
)
{
return
ImgDrawResult
:
:
SUCCESS
;
}
DrawTarget
*
drawTarget
=
aRenderingContext
.
GetDrawTarget
(
)
;
aRenderingContext
.
Save
(
)
;
aRenderingContext
.
Clip
(
NSRectToSnappedRect
(
inner
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
*
drawTarget
)
)
;
ImgDrawResult
result
=
ImgDrawResult
:
:
NOT_READY
;
if
(
!
gIconLoad
-
>
mPrefShowPlaceholders
|
|
(
isLoading
&
&
!
gIconLoad
-
>
mPrefShowLoadingPlaceholder
)
)
{
result
=
ImgDrawResult
:
:
SUCCESS
;
}
else
{
nscoord
size
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
ICON_SIZE
)
;
imgIRequest
*
request
=
isLoading
?
nsImageFrame
:
:
gIconLoad
-
>
mLoadingImage
:
nsImageFrame
:
:
gIconLoad
-
>
mBrokenImage
;
if
(
request
&
&
!
mDisplayingIcon
)
{
gIconLoad
-
>
AddIconObserver
(
this
)
;
mDisplayingIcon
=
true
;
}
WritingMode
wm
=
GetWritingMode
(
)
;
bool
flushRight
=
(
!
wm
.
IsVertical
(
)
&
&
!
wm
.
IsBidiLTR
(
)
)
|
|
wm
.
IsVerticalRL
(
)
;
uint32_t
imageStatus
=
0
;
if
(
request
)
request
-
>
GetImageStatus
(
&
imageStatus
)
;
if
(
imageStatus
&
imgIRequest
:
:
STATUS_LOAD_COMPLETE
&
&
!
(
imageStatus
&
imgIRequest
:
:
STATUS_ERROR
)
)
{
nsCOMPtr
<
imgIContainer
>
imgCon
;
request
-
>
GetImage
(
getter_AddRefs
(
imgCon
)
)
;
MOZ_ASSERT
(
imgCon
"
Load
complete
but
no
image
container
?
"
)
;
nsRect
dest
(
flushRight
?
inner
.
XMost
(
)
-
size
:
inner
.
x
inner
.
y
size
size
)
;
result
=
nsLayoutUtils
:
:
DrawSingleImage
(
aRenderingContext
PresContext
(
)
imgCon
nsLayoutUtils
:
:
GetSamplingFilterForFrame
(
this
)
dest
aDirtyRect
Nothing
(
)
aFlags
)
;
}
if
(
result
=
=
ImgDrawResult
:
:
NOT_READY
)
{
ColorPattern
color
(
ToDeviceColor
(
Color
(
1
.
f
0
.
f
0
.
f
1
.
f
)
)
)
;
nscoord
iconXPos
=
flushRight
?
inner
.
XMost
(
)
-
size
:
inner
.
x
;
nsRect
rect
(
iconXPos
inner
.
y
size
size
)
;
Rect
devPxRect
=
ToRect
(
nsLayoutUtils
:
:
RectToGfxRect
(
rect
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
)
;
drawTarget
-
>
StrokeRect
(
devPxRect
color
)
;
nscoord
twoPX
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
2
)
;
rect
=
nsRect
(
iconXPos
+
size
/
2
inner
.
y
+
size
/
2
size
/
2
-
twoPX
size
/
2
-
twoPX
)
;
devPxRect
=
ToRect
(
nsLayoutUtils
:
:
RectToGfxRect
(
rect
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
)
;
RefPtr
<
PathBuilder
>
builder
=
drawTarget
-
>
CreatePathBuilder
(
)
;
AppendEllipseToPath
(
builder
devPxRect
.
Center
(
)
devPxRect
.
Size
(
)
)
;
RefPtr
<
Path
>
ellipse
=
builder
-
>
Finish
(
)
;
drawTarget
-
>
Fill
(
ellipse
color
)
;
}
int32_t
paddedIconSize
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
ICON_SIZE
+
ICON_PADDING
)
;
if
(
wm
.
IsVertical
(
)
)
{
inner
.
y
+
=
paddedIconSize
;
inner
.
height
-
=
paddedIconSize
;
}
else
{
if
(
!
flushRight
)
{
inner
.
x
+
=
paddedIconSize
;
}
inner
.
width
-
=
paddedIconSize
;
}
}
if
(
!
inner
.
IsEmpty
(
)
)
{
nsAutoString
altText
;
nsCSSFrameConstructor
:
:
GetAlternateTextFor
(
mContent
-
>
AsElement
(
)
mContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
altText
)
;
DisplayAltText
(
PresContext
(
)
aRenderingContext
altText
inner
)
;
}
aRenderingContext
.
Restore
(
)
;
return
result
;
}
#
ifdef
DEBUG
static
void
PaintDebugImageMap
(
nsIFrame
*
aFrame
DrawTarget
*
aDrawTarget
const
nsRect
&
aDirtyRect
nsPoint
aPt
)
{
nsImageFrame
*
f
=
static_cast
<
nsImageFrame
*
>
(
aFrame
)
;
nsRect
inner
=
f
-
>
GetInnerArea
(
)
+
aPt
;
gfxPoint
devPixelOffset
=
nsLayoutUtils
:
:
PointToGfxPoint
(
inner
.
TopLeft
(
)
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
AutoRestoreTransform
autoRestoreTransform
(
aDrawTarget
)
;
aDrawTarget
-
>
SetTransform
(
aDrawTarget
-
>
GetTransform
(
)
.
PreTranslate
(
ToPoint
(
devPixelOffset
)
)
)
;
f
-
>
GetImageMap
(
)
-
>
Draw
(
aFrame
*
aDrawTarget
ColorPattern
(
ToDeviceColor
(
Color
(
0
.
f
0
.
f
0
.
f
1
.
f
)
)
)
)
;
}
#
endif
void
nsDisplayImage
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
uint32_t
flags
=
imgIContainer
:
:
FLAG_NONE
;
if
(
aBuilder
-
>
ShouldSyncDecodeImages
(
)
)
{
flags
|
=
imgIContainer
:
:
FLAG_SYNC_DECODE
;
}
if
(
aBuilder
-
>
IsPaintingToWindow
(
)
)
{
flags
|
=
imgIContainer
:
:
FLAG_HIGH_QUALITY_SCALING
;
}
ImgDrawResult
result
=
static_cast
<
nsImageFrame
*
>
(
mFrame
)
-
>
PaintImage
(
*
aCtx
ToReferenceFrame
(
)
GetPaintRect
(
)
mImage
flags
)
;
if
(
result
=
=
ImgDrawResult
:
:
NOT_READY
|
|
result
=
=
ImgDrawResult
:
:
INCOMPLETE
|
|
result
=
=
ImgDrawResult
:
:
TEMPORARY_ERROR
)
{
if
(
mPrevImage
)
{
result
=
static_cast
<
nsImageFrame
*
>
(
mFrame
)
-
>
PaintImage
(
*
aCtx
ToReferenceFrame
(
)
GetPaintRect
(
)
mPrevImage
flags
)
;
}
}
nsDisplayItemGenericImageGeometry
:
:
UpdateDrawResult
(
this
result
)
;
}
nsDisplayItemGeometry
*
nsDisplayImage
:
:
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
{
return
new
nsDisplayItemGenericImageGeometry
(
this
aBuilder
)
;
}
void
nsDisplayImage
:
:
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
{
auto
geometry
=
static_cast
<
const
nsDisplayItemGenericImageGeometry
*
>
(
aGeometry
)
;
if
(
aBuilder
-
>
ShouldSyncDecodeImages
(
)
&
&
geometry
-
>
ShouldInvalidateToSyncDecodeImages
(
)
)
{
bool
snap
;
aInvalidRegion
-
>
Or
(
*
aInvalidRegion
GetBounds
(
aBuilder
&
snap
)
)
;
}
nsDisplayImageContainer
:
:
ComputeInvalidationRegion
(
aBuilder
aGeometry
aInvalidRegion
)
;
}
already_AddRefed
<
imgIContainer
>
nsDisplayImage
:
:
GetImage
(
)
{
nsCOMPtr
<
imgIContainer
>
image
=
mImage
;
return
image
.
forget
(
)
;
}
nsRect
nsDisplayImage
:
:
GetDestRect
(
)
const
{
bool
snap
=
true
;
const
nsRect
frameContentBox
=
GetBounds
(
&
snap
)
;
nsImageFrame
*
imageFrame
=
static_cast
<
nsImageFrame
*
>
(
mFrame
)
;
return
imageFrame
-
>
PredictedDestRect
(
frameContentBox
)
;
}
LayerState
nsDisplayImage
:
:
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
{
if
(
!
nsDisplayItem
:
:
ForceActiveLayers
(
)
)
{
bool
animated
=
false
;
if
(
!
nsLayoutUtils
:
:
AnimatedImageLayersEnabled
(
)
|
|
mImage
-
>
GetType
(
)
!
=
imgIContainer
:
:
TYPE_RASTER
|
|
NS_FAILED
(
mImage
-
>
GetAnimated
(
&
animated
)
)
|
|
!
animated
)
{
if
(
!
aManager
-
>
IsCompositingCheap
(
)
|
|
!
nsLayoutUtils
:
:
GPUImageScalingEnabled
(
)
)
{
return
LAYER_NONE
;
}
}
if
(
!
animated
)
{
int32_t
imageWidth
;
int32_t
imageHeight
;
mImage
-
>
GetWidth
(
&
imageWidth
)
;
mImage
-
>
GetHeight
(
&
imageHeight
)
;
NS_ASSERTION
(
imageWidth
!
=
0
&
&
imageHeight
!
=
0
"
Invalid
image
size
!
"
)
;
const
int32_t
factor
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
const
LayoutDeviceRect
destRect
=
LayoutDeviceRect
:
:
FromAppUnits
(
GetDestRect
(
)
factor
)
;
const
LayerRect
destLayerRect
=
destRect
*
aParameters
.
Scale
(
)
;
const
gfxSize
scale
=
gfxSize
(
destLayerRect
.
width
/
imageWidth
destLayerRect
.
height
/
imageHeight
)
;
if
(
scale
.
width
=
=
1
.
0f
&
&
scale
.
height
=
=
1
.
0f
)
{
return
LAYER_NONE
;
}
if
(
destLayerRect
.
width
*
destLayerRect
.
height
<
64
*
64
)
{
return
LAYER_NONE
;
}
}
}
if
(
!
CanOptimizeToImageLayer
(
aManager
aBuilder
)
)
{
return
LAYER_NONE
;
}
nsImageFrame
*
f
=
static_cast
<
nsImageFrame
*
>
(
mFrame
)
;
if
(
f
-
>
HasImageMap
(
)
)
{
return
LAYER_NONE
;
}
return
LAYER_ACTIVE
;
}
nsRegion
nsDisplayImage
:
:
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
{
*
aSnap
=
false
;
if
(
mImage
&
&
mImage
-
>
WillDrawOpaqueNow
(
)
)
{
const
nsRect
frameContentBox
=
GetBounds
(
aSnap
)
;
return
GetDestRect
(
)
.
Intersect
(
frameContentBox
)
;
}
return
nsRegion
(
)
;
}
already_AddRefed
<
Layer
>
nsDisplayImage
:
:
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
{
uint32_t
flags
=
imgIContainer
:
:
FLAG_ASYNC_NOTIFY
;
if
(
aBuilder
-
>
ShouldSyncDecodeImages
(
)
)
{
flags
|
=
imgIContainer
:
:
FLAG_SYNC_DECODE
;
}
RefPtr
<
ImageContainer
>
container
=
mImage
-
>
GetImageContainer
(
aManager
flags
)
;
if
(
!
container
|
|
!
container
-
>
HasCurrentImage
(
)
)
{
return
nullptr
;
}
RefPtr
<
ImageLayer
>
layer
=
static_cast
<
ImageLayer
*
>
(
aManager
-
>
GetLayerBuilder
(
)
-
>
GetLeafLayerFor
(
aBuilder
this
)
)
;
if
(
!
layer
)
{
layer
=
aManager
-
>
CreateImageLayer
(
)
;
if
(
!
layer
)
return
nullptr
;
}
layer
-
>
SetContainer
(
container
)
;
ConfigureLayer
(
layer
aParameters
)
;
return
layer
.
forget
(
)
;
}
bool
nsDisplayImage
:
:
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
if
(
!
mImage
)
{
return
false
;
}
if
(
mFrame
-
>
IsImageFrame
(
)
)
{
nsImageFrame
*
f
=
static_cast
<
nsImageFrame
*
>
(
mFrame
)
;
if
(
f
-
>
HasImageMap
(
)
)
{
return
false
;
}
}
uint32_t
flags
=
imgIContainer
:
:
FLAG_ASYNC_NOTIFY
;
if
(
aDisplayListBuilder
-
>
IsPaintingToWindow
(
)
)
{
flags
|
=
imgIContainer
:
:
FLAG_HIGH_QUALITY_SCALING
;
}
if
(
aDisplayListBuilder
-
>
ShouldSyncDecodeImages
(
)
)
{
flags
|
=
imgIContainer
:
:
FLAG_SYNC_DECODE
;
}
const
int32_t
factor
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
const
LayoutDeviceRect
destRect
(
LayoutDeviceRect
:
:
FromAppUnits
(
GetDestRect
(
)
factor
)
)
;
Maybe
<
SVGImageContext
>
svgContext
;
IntSize
decodeSize
=
nsLayoutUtils
:
:
ComputeImageContainerDrawingParameters
(
mImage
mFrame
destRect
aSc
flags
svgContext
)
;
RefPtr
<
ImageContainer
>
container
=
mImage
-
>
GetImageContainerAtSize
(
aManager
decodeSize
svgContext
flags
)
;
if
(
!
container
)
{
return
false
;
}
aManager
-
>
CommandBuilder
(
)
.
PushImage
(
this
container
aBuilder
aResources
aSc
destRect
)
;
return
true
;
}
ImgDrawResult
nsImageFrame
:
:
PaintImage
(
gfxContext
&
aRenderingContext
nsPoint
aPt
const
nsRect
&
aDirtyRect
imgIContainer
*
aImage
uint32_t
aFlags
)
{
DrawTarget
*
drawTarget
=
aRenderingContext
.
GetDrawTarget
(
)
;
NS_ASSERTION
(
GetInnerArea
(
)
.
width
=
=
mComputedSize
.
width
"
bad
width
"
)
;
nsRect
constraintRect
(
aPt
+
GetInnerArea
(
)
.
TopLeft
(
)
mComputedSize
)
;
constraintRect
.
y
-
=
GetContinuationOffset
(
)
;
nsPoint
anchorPoint
;
nsRect
dest
=
nsLayoutUtils
:
:
ComputeObjectDestRect
(
constraintRect
mIntrinsicSize
mIntrinsicRatio
StylePosition
(
)
&
anchorPoint
)
;
uint32_t
flags
=
aFlags
;
if
(
mForceSyncDecoding
)
{
flags
|
=
imgIContainer
:
:
FLAG_SYNC_DECODE
;
}
Maybe
<
SVGImageContext
>
svgContext
;
SVGImageContext
:
:
MaybeStoreContextPaint
(
svgContext
this
aImage
)
;
ImgDrawResult
result
=
nsLayoutUtils
:
:
DrawSingleImage
(
aRenderingContext
PresContext
(
)
aImage
nsLayoutUtils
:
:
GetSamplingFilterForFrame
(
this
)
dest
aDirtyRect
svgContext
flags
&
anchorPoint
)
;
if
(
nsImageMap
*
map
=
GetImageMap
(
)
)
{
gfxPoint
devPixelOffset
=
nsLayoutUtils
:
:
PointToGfxPoint
(
dest
.
TopLeft
(
)
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
AutoRestoreTransform
autoRestoreTransform
(
drawTarget
)
;
drawTarget
-
>
SetTransform
(
drawTarget
-
>
GetTransform
(
)
.
PreTranslate
(
ToPoint
(
devPixelOffset
)
)
)
;
ColorPattern
white
(
ToDeviceColor
(
Color
(
1
.
f
1
.
f
1
.
f
1
.
f
)
)
)
;
map
-
>
Draw
(
this
*
drawTarget
white
)
;
ColorPattern
black
(
ToDeviceColor
(
Color
(
0
.
f
0
.
f
0
.
f
1
.
f
)
)
)
;
StrokeOptions
strokeOptions
;
nsLayoutUtils
:
:
InitDashPattern
(
strokeOptions
NS_STYLE_BORDER_STYLE_DOTTED
)
;
map
-
>
Draw
(
this
*
drawTarget
black
strokeOptions
)
;
}
if
(
result
=
=
ImgDrawResult
:
:
SUCCESS
)
{
mPrevImage
=
aImage
;
}
else
if
(
result
=
=
ImgDrawResult
:
:
BAD_IMAGE
)
{
mPrevImage
=
nullptr
;
}
return
result
;
}
already_AddRefed
<
imgIRequest
>
nsImageFrame
:
:
GetCurrentRequest
(
)
const
{
if
(
mKind
=
=
Kind
:
:
NonGeneratedContentProperty
)
{
return
do_AddRef
(
mContentURLRequest
)
;
}
MOZ_ASSERT
(
!
mContentURLRequest
)
;
nsCOMPtr
<
imgIRequest
>
request
;
nsCOMPtr
<
nsIImageLoadingContent
>
imageLoader
=
do_QueryInterface
(
mContent
)
;
MOZ_ASSERT
(
imageLoader
)
;
imageLoader
-
>
GetRequest
(
nsIImageLoadingContent
:
:
CURRENT_REQUEST
getter_AddRefs
(
request
)
)
;
return
request
.
forget
(
)
;
}
void
nsImageFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
if
(
!
IsVisibleForPainting
(
aBuilder
)
)
return
;
DisplayBorderBackgroundOutline
(
aBuilder
aLists
)
;
uint32_t
clipFlags
=
nsStyleUtil
:
:
ObjectPropsMightCauseOverflow
(
StylePosition
(
)
)
?
0
:
DisplayListClipState
:
:
ASSUME_DRAWING_RESTRICTED_TO_CONTENT_RECT
;
DisplayListClipState
:
:
AutoClipContainingBlockDescendantsToContentBox
clip
(
aBuilder
this
clipFlags
)
;
if
(
mComputedSize
.
width
!
=
0
&
&
mComputedSize
.
height
!
=
0
)
{
EventStates
contentState
=
mContent
-
>
AsElement
(
)
-
>
State
(
)
;
bool
imageOK
=
IMAGE_OK
(
contentState
true
)
;
nsCOMPtr
<
imgIRequest
>
currentRequest
=
GetCurrentRequest
(
)
;
if
(
!
imageOK
|
|
!
mImage
|
|
!
SizeIsAvailable
(
currentRequest
)
)
{
aLists
.
Content
(
)
-
>
AppendToTop
(
MakeDisplayItem
<
nsDisplayAltFeedback
>
(
aBuilder
this
)
)
;
if
(
currentRequest
)
{
uint32_t
status
=
0
;
currentRequest
-
>
GetImageStatus
(
&
status
)
;
if
(
!
(
status
&
imgIRequest
:
:
STATUS_DECODE_COMPLETE
)
)
{
MaybeDecodeForPredictedSize
(
)
;
}
if
(
!
(
status
&
imgIRequest
:
:
STATUS_LOAD_COMPLETE
)
)
{
currentRequest
-
>
BoostPriority
(
imgIRequest
:
:
CATEGORY_DISPLAY
)
;
}
}
}
else
{
aLists
.
Content
(
)
-
>
AppendToTop
(
MakeDisplayItem
<
nsDisplayImage
>
(
aBuilder
this
mImage
mPrevImage
)
)
;
if
(
mDisplayingIcon
)
{
gIconLoad
-
>
RemoveIconObserver
(
this
)
;
mDisplayingIcon
=
false
;
}
#
ifdef
DEBUG
if
(
GetShowFrameBorders
(
)
&
&
GetImageMap
(
)
)
{
aLists
.
Outlines
(
)
-
>
AppendToTop
(
MakeDisplayItem
<
nsDisplayGeneric
>
(
aBuilder
this
PaintDebugImageMap
"
DebugImageMap
"
DisplayItemType
:
:
TYPE_DEBUG_IMAGE_MAP
)
)
;
}
#
endif
}
}
if
(
ShouldDisplaySelection
(
)
)
{
DisplaySelectionOverlay
(
aBuilder
aLists
.
Content
(
)
nsISelectionDisplay
:
:
DISPLAY_IMAGES
)
;
}
}
bool
nsImageFrame
:
:
ShouldDisplaySelection
(
)
{
int16_t
displaySelection
=
PresShell
(
)
-
>
GetSelectionFlags
(
)
;
if
(
!
(
displaySelection
&
nsISelectionDisplay
:
:
DISPLAY_IMAGES
)
)
return
false
;
if
(
displaySelection
=
=
nsISelectionDisplay
:
:
DISPLAY_ALL
)
{
if
(
const
nsFrameSelection
*
frameSelection
=
GetConstFrameSelection
(
)
)
{
const
Selection
*
selection
=
frameSelection
-
>
GetSelection
(
SelectionType
:
:
eNormal
)
;
if
(
selection
&
&
selection
-
>
RangeCount
(
)
=
=
1
)
{
nsINode
*
parent
=
mContent
-
>
GetParent
(
)
;
int32_t
thisOffset
=
parent
-
>
ComputeIndexOf
(
mContent
)
;
nsRange
*
range
=
selection
-
>
GetRangeAt
(
0
)
;
if
(
range
-
>
GetStartContainer
(
)
=
=
parent
&
&
range
-
>
GetEndContainer
(
)
=
=
parent
&
&
static_cast
<
int32_t
>
(
range
-
>
StartOffset
(
)
)
=
=
thisOffset
&
&
static_cast
<
int32_t
>
(
range
-
>
EndOffset
(
)
)
=
=
thisOffset
+
1
)
{
return
false
;
}
}
}
}
return
true
;
}
nsImageMap
*
nsImageFrame
:
:
GetImageMap
(
)
{
if
(
!
mImageMap
)
{
if
(
nsIContent
*
map
=
GetMapElement
(
)
)
{
mImageMap
=
new
nsImageMap
(
)
;
mImageMap
-
>
Init
(
this
map
)
;
}
}
return
mImageMap
;
}
bool
nsImageFrame
:
:
IsServerImageMap
(
)
{
return
mContent
-
>
AsElement
(
)
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
ismap
)
;
}
void
nsImageFrame
:
:
TranslateEventCoords
(
const
nsPoint
&
aPoint
nsIntPoint
&
aResult
)
{
nscoord
x
=
aPoint
.
x
;
nscoord
y
=
aPoint
.
y
;
nsRect
inner
=
GetInnerArea
(
)
;
x
-
=
inner
.
x
;
y
-
=
inner
.
y
;
aResult
.
x
=
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
x
)
;
aResult
.
y
=
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
y
)
;
}
bool
nsImageFrame
:
:
GetAnchorHREFTargetAndNode
(
nsIURI
*
*
aHref
nsString
&
aTarget
nsIContent
*
*
aNode
)
{
bool
status
=
false
;
aTarget
.
Truncate
(
)
;
*
aHref
=
nullptr
;
*
aNode
=
nullptr
;
for
(
nsIContent
*
content
=
mContent
-
>
GetParent
(
)
;
content
;
content
=
content
-
>
GetParent
(
)
)
{
nsCOMPtr
<
dom
:
:
Link
>
link
(
do_QueryInterface
(
content
)
)
;
if
(
link
)
{
nsCOMPtr
<
nsIURI
>
href
=
content
-
>
GetHrefURI
(
)
;
if
(
href
)
{
href
.
forget
(
aHref
)
;
}
status
=
(
*
aHref
!
=
nullptr
)
;
RefPtr
<
HTMLAnchorElement
>
anchor
=
HTMLAnchorElement
:
:
FromNode
(
content
)
;
if
(
anchor
)
{
anchor
-
>
GetTarget
(
aTarget
)
;
}
NS_ADDREF
(
*
aNode
=
content
)
;
break
;
}
}
return
status
;
}
nsresult
nsImageFrame
:
:
GetContentForEvent
(
WidgetEvent
*
aEvent
nsIContent
*
*
aContent
)
{
NS_ENSURE_ARG_POINTER
(
aContent
)
;
nsIFrame
*
f
=
nsLayoutUtils
:
:
GetNonGeneratedAncestor
(
this
)
;
if
(
f
!
=
this
)
{
return
f
-
>
GetContentForEvent
(
aEvent
aContent
)
;
}
nsIContent
*
capturingContent
=
aEvent
-
>
HasMouseEventMessage
(
)
?
nsIPresShell
:
:
GetCapturingContent
(
)
:
nullptr
;
if
(
capturingContent
&
&
capturingContent
-
>
GetPrimaryFrame
(
)
=
=
this
)
{
*
aContent
=
capturingContent
;
NS_IF_ADDREF
(
*
aContent
)
;
return
NS_OK
;
}
if
(
nsImageMap
*
map
=
GetImageMap
(
)
)
{
nsIntPoint
p
;
TranslateEventCoords
(
nsLayoutUtils
:
:
GetEventCoordinatesRelativeTo
(
aEvent
this
)
p
)
;
nsCOMPtr
<
nsIContent
>
area
=
map
-
>
GetArea
(
p
.
x
p
.
y
)
;
if
(
area
)
{
area
.
forget
(
aContent
)
;
return
NS_OK
;
}
}
*
aContent
=
GetContent
(
)
;
NS_IF_ADDREF
(
*
aContent
)
;
return
NS_OK
;
}
nsresult
nsImageFrame
:
:
HandleEvent
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
{
NS_ENSURE_ARG_POINTER
(
aEventStatus
)
;
if
(
(
aEvent
-
>
mMessage
=
=
eMouseClick
&
&
aEvent
-
>
AsMouseEvent
(
)
-
>
button
=
=
WidgetMouseEvent
:
:
eLeftButton
)
|
|
aEvent
-
>
mMessage
=
=
eMouseMove
)
{
nsImageMap
*
map
=
GetImageMap
(
)
;
bool
isServerMap
=
IsServerImageMap
(
)
;
if
(
map
|
|
isServerMap
)
{
nsIntPoint
p
;
TranslateEventCoords
(
nsLayoutUtils
:
:
GetEventCoordinatesRelativeTo
(
aEvent
this
)
p
)
;
bool
inside
=
false
;
if
(
nullptr
!
=
map
)
{
inside
=
!
!
map
-
>
GetArea
(
p
.
x
p
.
y
)
;
}
if
(
!
inside
&
&
isServerMap
)
{
nsCOMPtr
<
nsIURI
>
uri
;
nsAutoString
target
;
nsCOMPtr
<
nsIContent
>
anchorNode
;
if
(
GetAnchorHREFTargetAndNode
(
getter_AddRefs
(
uri
)
target
getter_AddRefs
(
anchorNode
)
)
)
{
if
(
p
.
x
<
0
)
p
.
x
=
0
;
if
(
p
.
y
<
0
)
p
.
y
=
0
;
nsAutoCString
spec
;
nsresult
rv
=
uri
-
>
GetSpec
(
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
spec
+
=
nsPrintfCString
(
"
?
%
d
%
d
"
p
.
x
p
.
y
)
;
rv
=
NS_MutateURI
(
uri
)
.
SetSpec
(
spec
)
.
Finalize
(
uri
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
clicked
=
false
;
if
(
aEvent
-
>
mMessage
=
=
eMouseClick
&
&
!
aEvent
-
>
DefaultPrevented
(
)
)
{
*
aEventStatus
=
nsEventStatus_eConsumeDoDefault
;
clicked
=
true
;
}
nsContentUtils
:
:
TriggerLink
(
anchorNode
aPresContext
uri
target
clicked
true
)
;
}
}
}
}
return
nsAtomicContainerFrame
:
:
HandleEvent
(
aPresContext
aEvent
aEventStatus
)
;
}
nsresult
nsImageFrame
:
:
GetCursor
(
const
nsPoint
&
aPoint
nsIFrame
:
:
Cursor
&
aCursor
)
{
if
(
nsImageMap
*
map
=
GetImageMap
(
)
)
{
nsIntPoint
p
;
TranslateEventCoords
(
aPoint
p
)
;
nsCOMPtr
<
nsIContent
>
area
=
map
-
>
GetArea
(
p
.
x
p
.
y
)
;
if
(
area
)
{
RefPtr
<
ComputedStyle
>
areaStyle
=
PresShell
(
)
-
>
StyleSet
(
)
-
>
ResolveStyleFor
(
area
-
>
AsElement
(
)
Style
(
)
LazyComputeBehavior
:
:
Allow
)
;
FillCursorInformationFromStyle
(
areaStyle
-
>
StyleUserInterface
(
)
aCursor
)
;
if
(
NS_STYLE_CURSOR_AUTO
=
=
aCursor
.
mCursor
)
{
aCursor
.
mCursor
=
NS_STYLE_CURSOR_DEFAULT
;
}
return
NS_OK
;
}
}
return
nsFrame
:
:
GetCursor
(
aPoint
aCursor
)
;
}
nsresult
nsImageFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
nsresult
rv
=
nsAtomicContainerFrame
:
:
AttributeChanged
(
aNameSpaceID
aAttribute
aModType
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
nsGkAtoms
:
:
alt
=
=
aAttribute
)
{
PresShell
(
)
-
>
FrameNeedsReflow
(
this
nsIPresShell
:
:
eStyleChange
NS_FRAME_IS_DIRTY
)
;
}
return
NS_OK
;
}
void
nsImageFrame
:
:
OnVisibilityChange
(
Visibility
aNewVisibility
const
Maybe
<
OnNonvisible
>
&
aNonvisibleAction
)
{
if
(
mKind
=
=
Kind
:
:
ImageElement
)
{
nsCOMPtr
<
nsIImageLoadingContent
>
imageLoader
=
do_QueryInterface
(
mContent
)
;
imageLoader
-
>
OnVisibilityChange
(
aNewVisibility
aNonvisibleAction
)
;
}
if
(
aNewVisibility
=
=
Visibility
:
:
APPROXIMATELY_VISIBLE
)
{
MaybeDecodeForPredictedSize
(
)
;
}
nsAtomicContainerFrame
:
:
OnVisibilityChange
(
aNewVisibility
aNonvisibleAction
)
;
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
nsImageFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
NS_LITERAL_STRING
(
"
ImageFrame
"
)
aResult
)
;
}
void
nsImageFrame
:
:
List
(
FILE
*
out
const
char
*
aPrefix
uint32_t
aFlags
)
const
{
nsCString
str
;
ListGeneric
(
str
aPrefix
aFlags
)
;
if
(
nsCOMPtr
<
imgIRequest
>
currentRequest
=
GetCurrentRequest
(
)
)
{
nsCOMPtr
<
nsIURI
>
uri
;
currentRequest
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
nsAutoCString
uristr
;
uri
-
>
GetAsciiSpec
(
uristr
)
;
str
+
=
nsPrintfCString
(
"
[
src
=
%
s
]
"
uristr
.
get
(
)
)
;
}
fprintf_stderr
(
out
"
%
s
\
n
"
str
.
get
(
)
)
;
}
#
endif
nsIFrame
:
:
LogicalSides
nsImageFrame
:
:
GetLogicalSkipSides
(
const
ReflowInput
*
aReflowInput
)
const
{
if
(
MOZ_UNLIKELY
(
StyleBorder
(
)
-
>
mBoxDecorationBreak
=
=
StyleBoxDecorationBreak
:
:
Clone
)
)
{
return
LogicalSides
(
)
;
}
LogicalSides
skip
;
if
(
nullptr
!
=
GetPrevInFlow
(
)
)
{
skip
|
=
eLogicalSideBitsBStart
;
}
if
(
nullptr
!
=
GetNextInFlow
(
)
)
{
skip
|
=
eLogicalSideBitsBEnd
;
}
return
skip
;
}
nsresult
nsImageFrame
:
:
GetIntrinsicImageSize
(
nsSize
&
aSize
)
{
if
(
mIntrinsicSize
.
width
.
GetUnit
(
)
=
=
eStyleUnit_Coord
&
&
mIntrinsicSize
.
height
.
GetUnit
(
)
=
=
eStyleUnit_Coord
)
{
aSize
.
SizeTo
(
mIntrinsicSize
.
width
.
GetCoordValue
(
)
mIntrinsicSize
.
height
.
GetCoordValue
(
)
)
;
return
NS_OK
;
}
return
NS_ERROR_FAILURE
;
}
nsresult
nsImageFrame
:
:
LoadIcon
(
const
nsAString
&
aSpec
nsPresContext
*
aPresContext
imgRequestProxy
*
*
aRequest
)
{
nsresult
rv
=
NS_OK
;
MOZ_ASSERT
(
!
aSpec
.
IsEmpty
(
)
"
What
happened
?
?
"
)
;
if
(
!
sIOService
)
{
rv
=
CallGetService
(
NS_IOSERVICE_CONTRACTID
&
sIOService
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
nsCOMPtr
<
nsIURI
>
realURI
;
SpecToURI
(
aSpec
sIOService
getter_AddRefs
(
realURI
)
)
;
RefPtr
<
imgLoader
>
il
=
nsContentUtils
:
:
GetImgLoaderForDocument
(
aPresContext
-
>
Document
(
)
)
;
nsCOMPtr
<
nsILoadGroup
>
loadGroup
;
GetLoadGroup
(
aPresContext
getter_AddRefs
(
loadGroup
)
)
;
nsLoadFlags
loadFlags
=
nsIRequest
:
:
LOAD_NORMAL
;
nsContentPolicyType
contentPolicyType
=
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE
;
return
il
-
>
LoadImage
(
realURI
nullptr
nullptr
mozilla
:
:
net
:
:
RP_Unset
nullptr
0
loadGroup
gIconLoad
nullptr
nullptr
loadFlags
nullptr
contentPolicyType
EmptyString
(
)
false
aRequest
)
;
}
void
nsImageFrame
:
:
GetDocumentCharacterSet
(
nsACString
&
aCharset
)
const
{
if
(
mContent
)
{
NS_ASSERTION
(
mContent
-
>
GetComposedDoc
(
)
"
Frame
still
alive
after
content
removed
from
document
!
"
)
;
mContent
-
>
GetComposedDoc
(
)
-
>
GetDocumentCharacterSet
(
)
-
>
Name
(
aCharset
)
;
}
}
void
nsImageFrame
:
:
SpecToURI
(
const
nsAString
&
aSpec
nsIIOService
*
aIOService
nsIURI
*
*
aURI
)
{
nsCOMPtr
<
nsIURI
>
baseURI
;
if
(
mContent
)
{
baseURI
=
mContent
-
>
GetBaseURI
(
)
;
}
nsAutoCString
charset
;
GetDocumentCharacterSet
(
charset
)
;
NS_NewURI
(
aURI
aSpec
charset
.
IsEmpty
(
)
?
nullptr
:
charset
.
get
(
)
baseURI
aIOService
)
;
}
void
nsImageFrame
:
:
GetLoadGroup
(
nsPresContext
*
aPresContext
nsILoadGroup
*
*
aLoadGroup
)
{
if
(
!
aPresContext
)
return
;
MOZ_ASSERT
(
nullptr
!
=
aLoadGroup
"
null
OUT
parameter
pointer
"
)
;
nsIPresShell
*
shell
=
aPresContext
-
>
GetPresShell
(
)
;
if
(
!
shell
)
return
;
nsIDocument
*
doc
=
shell
-
>
GetDocument
(
)
;
if
(
!
doc
)
return
;
*
aLoadGroup
=
doc
-
>
GetDocumentLoadGroup
(
)
.
take
(
)
;
}
nsresult
nsImageFrame
:
:
LoadIcons
(
nsPresContext
*
aPresContext
)
{
NS_ASSERTION
(
!
gIconLoad
"
called
LoadIcons
twice
"
)
;
NS_NAMED_LITERAL_STRING
(
loadingSrc
"
resource
:
/
/
gre
-
resources
/
loading
-
image
.
png
"
)
;
NS_NAMED_LITERAL_STRING
(
brokenSrc
"
resource
:
/
/
gre
-
resources
/
broken
-
image
.
png
"
)
;
gIconLoad
=
new
IconLoad
(
)
;
nsresult
rv
;
rv
=
LoadIcon
(
loadingSrc
aPresContext
getter_AddRefs
(
gIconLoad
-
>
mLoadingImage
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
LoadIcon
(
brokenSrc
aPresContext
getter_AddRefs
(
gIconLoad
-
>
mBrokenImage
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
rv
;
}
NS_IMPL_ISUPPORTS
(
nsImageFrame
:
:
IconLoad
nsIObserver
imgINotificationObserver
)
static
const
char
*
kIconLoadPrefs
[
]
=
{
"
browser
.
display
.
force_inline_alttext
"
"
browser
.
display
.
show_image_placeholders
"
"
browser
.
display
.
show_loading_image_placeholder
"
nullptr
}
;
nsImageFrame
:
:
IconLoad
:
:
IconLoad
(
)
{
Preferences
:
:
AddStrongObservers
(
this
kIconLoadPrefs
)
;
GetPrefs
(
)
;
}
void
nsImageFrame
:
:
IconLoad
:
:
Shutdown
(
)
{
Preferences
:
:
RemoveObservers
(
this
kIconLoadPrefs
)
;
if
(
mLoadingImage
)
{
mLoadingImage
-
>
CancelAndForgetObserver
(
NS_ERROR_FAILURE
)
;
mLoadingImage
=
nullptr
;
}
if
(
mBrokenImage
)
{
mBrokenImage
-
>
CancelAndForgetObserver
(
NS_ERROR_FAILURE
)
;
mBrokenImage
=
nullptr
;
}
}
NS_IMETHODIMP
nsImageFrame
:
:
IconLoad
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
NS_ASSERTION
(
!
nsCRT
:
:
strcmp
(
aTopic
NS_PREFBRANCH_PREFCHANGE_TOPIC_ID
)
"
wrong
topic
"
)
;
#
ifdef
DEBUG
uint32_t
i
=
0
;
for
(
;
i
<
ArrayLength
(
kIconLoadPrefs
)
;
+
+
i
)
{
if
(
NS_ConvertASCIItoUTF16
(
kIconLoadPrefs
[
i
]
)
=
=
nsDependentString
(
aData
)
)
break
;
}
MOZ_ASSERT
(
i
<
ArrayLength
(
kIconLoadPrefs
)
)
;
#
endif
GetPrefs
(
)
;
return
NS_OK
;
}
void
nsImageFrame
:
:
IconLoad
:
:
GetPrefs
(
)
{
mPrefForceInlineAltText
=
Preferences
:
:
GetBool
(
"
browser
.
display
.
force_inline_alttext
"
)
;
mPrefShowPlaceholders
=
Preferences
:
:
GetBool
(
"
browser
.
display
.
show_image_placeholders
"
true
)
;
mPrefShowLoadingPlaceholder
=
Preferences
:
:
GetBool
(
"
browser
.
display
.
show_loading_image_placeholder
"
true
)
;
}
NS_IMETHODIMP
nsImageFrame
:
:
IconLoad
:
:
Notify
(
imgIRequest
*
aRequest
int32_t
aType
const
nsIntRect
*
aData
)
{
MOZ_ASSERT
(
aRequest
)
;
if
(
aType
!
=
imgINotificationObserver
:
:
LOAD_COMPLETE
&
&
aType
!
=
imgINotificationObserver
:
:
FRAME_UPDATE
)
{
return
NS_OK
;
}
if
(
aType
=
=
imgINotificationObserver
:
:
LOAD_COMPLETE
)
{
nsCOMPtr
<
imgIContainer
>
image
;
aRequest
-
>
GetImage
(
getter_AddRefs
(
image
)
)
;
if
(
!
image
)
{
return
NS_ERROR_FAILURE
;
}
int32_t
width
=
0
;
int32_t
height
=
0
;
image
-
>
GetWidth
(
&
width
)
;
image
-
>
GetHeight
(
&
height
)
;
image
-
>
RequestDecodeForSize
(
IntSize
(
width
height
)
imgIContainer
:
:
DECODE_FLAGS_DEFAULT
)
;
}
nsTObserverArray
<
nsImageFrame
*
>
:
:
ForwardIterator
iter
(
mIconObservers
)
;
nsImageFrame
*
frame
;
while
(
iter
.
HasMore
(
)
)
{
frame
=
iter
.
GetNext
(
)
;
frame
-
>
InvalidateFrame
(
)
;
}
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
nsImageListener
imgINotificationObserver
)
nsImageListener
:
:
nsImageListener
(
nsImageFrame
*
aFrame
)
:
mFrame
(
aFrame
)
{
}
nsImageListener
:
:
~
nsImageListener
(
)
=
default
;
NS_IMETHODIMP
nsImageListener
:
:
Notify
(
imgIRequest
*
aRequest
int32_t
aType
const
nsIntRect
*
aData
)
{
if
(
!
mFrame
)
return
NS_ERROR_FAILURE
;
return
mFrame
-
>
Notify
(
aRequest
aType
aData
)
;
}
static
bool
IsInAutoWidthTableCellForQuirk
(
nsIFrame
*
aFrame
)
{
if
(
eCompatibility_NavQuirks
!
=
aFrame
-
>
PresContext
(
)
-
>
CompatibilityMode
(
)
)
return
false
;
nsBlockFrame
*
ancestor
=
nsLayoutUtils
:
:
FindNearestBlockAncestor
(
aFrame
)
;
if
(
ancestor
-
>
Style
(
)
-
>
GetPseudo
(
)
=
=
nsCSSAnonBoxes
:
:
cellContent
)
{
nsFrame
*
grandAncestor
=
static_cast
<
nsFrame
*
>
(
ancestor
-
>
GetParent
(
)
)
;
return
grandAncestor
&
&
grandAncestor
-
>
StylePosition
(
)
-
>
mWidth
.
GetUnit
(
)
=
=
eStyleUnit_Auto
;
}
return
false
;
}
void
nsImageFrame
:
:
AddInlineMinISize
(
gfxContext
*
aRenderingContext
nsIFrame
:
:
InlineMinISizeData
*
aData
)
{
nscoord
isize
=
nsLayoutUtils
:
:
IntrinsicForContainer
(
aRenderingContext
this
nsLayoutUtils
:
:
MIN_ISIZE
)
;
bool
canBreak
=
!
IsInAutoWidthTableCellForQuirk
(
this
)
;
aData
-
>
DefaultAddInlineMinISize
(
this
isize
canBreak
)
;
}
