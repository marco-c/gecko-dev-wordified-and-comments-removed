#
include
"
nsImageFrame
.
h
"
#
include
"
TextDrawTarget
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
mozilla
/
intl
/
BidiEmbeddingLevel
.
h
"
#
include
"
mozilla
/
ComputedStyle
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Encoding
.
h
"
#
include
"
mozilla
/
HTMLEditor
.
h
"
#
include
"
mozilla
/
dom
/
ImageTracker
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
Helpers
.
h
"
#
include
"
mozilla
/
gfx
/
PathHelpers
.
h
"
#
include
"
mozilla
/
dom
/
GeneratedImageContent
.
h
"
#
include
"
mozilla
/
dom
/
HTMLAreaElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLImageElement
.
h
"
#
include
"
mozilla
/
dom
/
ResponsiveImageSelector
.
h
"
#
include
"
mozilla
/
image
/
WebRenderImageProvider
.
h
"
#
include
"
mozilla
/
layers
/
RenderRootStateManager
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderLayerManager
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
PresShellInlines
.
h
"
#
include
"
mozilla
/
StaticPrefs_image
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
mozilla
/
SVGImageContext
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsFontMetrics
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsIImageLoadingContent
.
h
"
#
include
"
nsImageLoadingContent
.
h
"
#
include
"
nsImageRenderer
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCSSAnonBoxes
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsStyleUtil
.
h
"
#
include
"
nsTransform2D
.
h
"
#
include
"
nsImageMap
.
h
"
#
include
"
nsILoadGroup
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsNetCID
.
h
"
#
include
"
nsCSSRendering
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
<
algorithm
>
#
ifdef
ACCESSIBILITY
#
include
"
nsAccessibilityService
.
h
"
#
endif
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsIURIMutator
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
imgLoader
.
h
"
#
include
"
imgRequestProxy
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsBidiUtils
.
h
"
#
include
"
nsBidiPresUtils
.
h
"
#
include
"
gfxRect
.
h
"
#
include
"
ImageRegion
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
nsBlockFrame
.
h
"
#
include
"
nsStyleStructInlines
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
dom
/
Link
.
h
"
#
include
"
mozilla
/
dom
/
HTMLAnchorElement
.
h
"
#
include
"
mozilla
/
dom
/
BrowserChild
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
image
;
using
namespace
mozilla
:
:
layers
;
using
mozilla
:
:
layout
:
:
TextDrawTarget
;
class
nsDisplayGradient
final
:
public
nsPaintedDisplayItem
{
public
:
nsDisplayGradient
(
nsDisplayListBuilder
*
aBuilder
nsImageFrame
*
aFrame
)
:
nsPaintedDisplayItem
(
aBuilder
aFrame
)
{
MOZ_COUNT_CTOR
(
nsDisplayGradient
)
;
}
~
nsDisplayGradient
(
)
final
{
MOZ_COUNT_DTOR
(
nsDisplayGradient
)
;
}
nsDisplayItemGeometry
*
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
final
{
return
new
nsDisplayItemGenericImageGeometry
(
this
aBuilder
)
;
}
nsRect
GetBounds
(
bool
*
aSnap
)
const
{
*
aSnap
=
true
;
return
Frame
(
)
-
>
GetContentRectRelativeToSelf
(
)
+
ToReferenceFrame
(
)
;
}
nsRect
GetBounds
(
nsDisplayListBuilder
*
bool
*
aSnap
)
const
final
{
return
GetBounds
(
aSnap
)
;
}
void
Paint
(
nsDisplayListBuilder
*
gfxContext
*
aCtx
)
final
;
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
const
StackingContextHelper
&
mozilla
:
:
layers
:
:
RenderRootStateManager
*
nsDisplayListBuilder
*
)
final
;
NS_DISPLAY_DECL_NAME
(
"
Gradient
"
TYPE_GRADIENT
)
}
;
void
nsDisplayGradient
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
auto
*
frame
=
static_cast
<
nsImageFrame
*
>
(
Frame
(
)
)
;
nsImageRenderer
imageRenderer
(
frame
frame
-
>
GetImageFromStyle
(
)
aBuilder
-
>
GetImageRendererFlags
(
)
)
;
nsSize
size
=
frame
-
>
GetSize
(
)
;
imageRenderer
.
SetPreferredSize
(
{
}
size
)
;
ImgDrawResult
result
;
if
(
!
imageRenderer
.
PrepareImage
(
)
)
{
result
=
imageRenderer
.
PrepareResult
(
)
;
}
else
{
nsRect
dest
(
ToReferenceFrame
(
)
size
)
;
result
=
imageRenderer
.
DrawLayer
(
frame
-
>
PresContext
(
)
*
aCtx
dest
dest
dest
.
TopLeft
(
)
GetPaintRect
(
aBuilder
aCtx
)
dest
.
Size
(
)
1
.
0f
)
;
}
nsDisplayItemGenericImageGeometry
:
:
UpdateDrawResult
(
this
result
)
;
}
bool
nsDisplayGradient
:
:
CreateWebRenderCommands
(
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
auto
*
frame
=
static_cast
<
nsImageFrame
*
>
(
Frame
(
)
)
;
nsImageRenderer
imageRenderer
(
frame
frame
-
>
GetImageFromStyle
(
)
aDisplayListBuilder
-
>
GetImageRendererFlags
(
)
)
;
nsSize
size
=
frame
-
>
GetSize
(
)
;
imageRenderer
.
SetPreferredSize
(
{
}
size
)
;
ImgDrawResult
result
;
if
(
!
imageRenderer
.
PrepareImage
(
)
)
{
result
=
imageRenderer
.
PrepareResult
(
)
;
}
else
{
nsRect
dest
(
ToReferenceFrame
(
)
size
)
;
result
=
imageRenderer
.
BuildWebRenderDisplayItemsForLayer
(
frame
-
>
PresContext
(
)
aBuilder
aResources
aSc
aManager
this
dest
dest
dest
.
TopLeft
(
)
dest
dest
.
Size
(
)
1
.
0f
)
;
if
(
result
=
=
ImgDrawResult
:
:
NOT_SUPPORTED
)
{
return
false
;
}
}
nsDisplayItemGenericImageGeometry
:
:
UpdateDrawResult
(
this
result
)
;
return
true
;
}
#
define
ICON_SIZE
(
16
)
#
define
ICON_PADDING
(
3
)
#
define
ALT_BORDER_WIDTH
(
1
)
#
define
ALIGN_UNSET
uint8_t
(
-
1
)
StaticRefPtr
<
nsImageFrame
:
:
IconLoad
>
nsImageFrame
:
:
gIconLoad
;
static
bool
HaveSpecifiedSize
(
const
nsStylePosition
*
aStylePosition
)
{
return
aStylePosition
-
>
mWidth
.
IsLengthPercentage
(
)
&
&
aStylePosition
-
>
mHeight
.
IsLengthPercentage
(
)
;
}
template
<
typename
SizeOrMaxSize
>
static
bool
DependsOnIntrinsicSize
(
const
SizeOrMaxSize
&
aMinOrMaxSize
)
{
auto
length
=
nsIFrame
:
:
ToExtremumLength
(
aMinOrMaxSize
)
;
if
(
!
length
)
{
return
false
;
}
switch
(
*
length
)
{
case
nsIFrame
:
:
ExtremumLength
:
:
MinContent
:
case
nsIFrame
:
:
ExtremumLength
:
:
MaxContent
:
case
nsIFrame
:
:
ExtremumLength
:
:
FitContent
:
case
nsIFrame
:
:
ExtremumLength
:
:
FitContentFunction
:
return
true
;
case
nsIFrame
:
:
ExtremumLength
:
:
MozAvailable
:
return
false
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
sizing
keyword
?
"
)
;
return
false
;
}
static
bool
SizeDependsOnIntrinsicSize
(
const
ReflowInput
&
aReflowInput
)
{
const
auto
&
position
=
*
aReflowInput
.
mStylePosition
;
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
return
!
position
.
mHeight
.
ConvertsToLength
(
)
|
|
!
position
.
mWidth
.
ConvertsToLength
(
)
|
|
DependsOnIntrinsicSize
(
position
.
MinISize
(
wm
)
)
|
|
DependsOnIntrinsicSize
(
position
.
MaxISize
(
wm
)
)
|
|
aReflowInput
.
mFrame
-
>
IsFlexItem
(
)
;
}
nsIFrame
*
NS_NewImageFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsImageFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
nsImageFrame
:
:
Kind
:
:
ImageElement
)
;
}
nsIFrame
*
NS_NewImageFrameForContentProperty
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsImageFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
nsImageFrame
:
:
Kind
:
:
ContentProperty
)
;
}
nsIFrame
*
NS_NewImageFrameForGeneratedContentIndex
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsImageFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
nsImageFrame
:
:
Kind
:
:
ContentPropertyAtIndex
)
;
}
nsIFrame
*
NS_NewImageFrameForListStyleImage
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsImageFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
nsImageFrame
:
:
Kind
:
:
ListStyleImage
)
;
}
bool
nsImageFrame
:
:
ShouldShowBrokenImageIcon
(
)
const
{
if
(
mKind
!
=
Kind
:
:
ImageElement
)
{
return
false
;
}
if
(
auto
*
image
=
HTMLImageElement
:
:
FromNode
(
mContent
)
)
{
const
nsAttrValue
*
alt
=
image
-
>
GetParsedAttr
(
nsGkAtoms
:
:
alt
)
;
if
(
alt
&
&
alt
-
>
IsEmptyString
(
)
)
{
return
false
;
}
}
if
(
nsCOMPtr
<
imgIRequest
>
currentRequest
=
GetCurrentRequest
(
)
)
{
uint32_t
imageStatus
;
return
NS_SUCCEEDED
(
currentRequest
-
>
GetImageStatus
(
&
imageStatus
)
)
&
&
(
imageStatus
&
imgIRequest
:
:
STATUS_ERROR
)
;
}
nsCOMPtr
<
nsIImageLoadingContent
>
imageLoader
=
do_QueryInterface
(
mContent
)
;
MOZ_ASSERT
(
imageLoader
)
;
nsCOMPtr
<
nsIURI
>
currentURI
=
imageLoader
-
>
GetCurrentURI
(
)
;
return
!
!
currentURI
;
}
nsImageFrame
*
nsImageFrame
:
:
CreateContinuingFrame
(
mozilla
:
:
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
const
{
return
new
(
aPresShell
)
nsImageFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
mKind
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsImageFrame
)
nsImageFrame
:
:
nsImageFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
ClassID
aID
Kind
aKind
)
:
nsAtomicContainerFrame
(
aStyle
aPresContext
aID
)
mComputedSize
(
0
0
)
mIntrinsicSize
(
0
0
)
mKind
(
aKind
)
mContentURLRequestRegistered
(
false
)
mDisplayingIcon
(
false
)
mFirstFrameComplete
(
false
)
mReflowCallbackPosted
(
false
)
mForceSyncDecoding
(
false
)
{
EnableVisibilityTracking
(
)
;
}
nsImageFrame
:
:
~
nsImageFrame
(
)
=
default
;
NS_QUERYFRAME_HEAD
(
nsImageFrame
)
NS_QUERYFRAME_ENTRY
(
nsImageFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsAtomicContainerFrame
)
#
ifdef
ACCESSIBILITY
a11y
:
:
AccType
nsImageFrame
:
:
AccessibleType
(
)
{
if
(
mKind
=
=
Kind
:
:
ListStyleImage
)
{
return
a11y
:
:
eNoType
;
}
if
(
HasImageMap
(
)
)
{
return
a11y
:
:
eHTMLImageMapType
;
}
return
a11y
:
:
eImageType
;
}
#
endif
void
nsImageFrame
:
:
DisconnectMap
(
)
{
if
(
!
mImageMap
)
{
return
;
}
mImageMap
-
>
Destroy
(
)
;
mImageMap
=
nullptr
;
#
ifdef
ACCESSIBILITY
if
(
nsAccessibilityService
*
accService
=
GetAccService
(
)
)
{
accService
-
>
RecreateAccessible
(
PresShell
(
)
mContent
)
;
}
#
endif
}
void
nsImageFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
{
if
(
mReflowCallbackPosted
)
{
PresShell
(
)
-
>
CancelReflowCallback
(
this
)
;
mReflowCallbackPosted
=
false
;
}
DisconnectMap
(
)
;
MOZ_ASSERT
(
mListener
)
;
if
(
mKind
=
=
Kind
:
:
ImageElement
)
{
MOZ_ASSERT
(
!
mContentURLRequest
)
;
MOZ_ASSERT
(
!
mContentURLRequestRegistered
)
;
nsCOMPtr
<
nsIImageLoadingContent
>
imageLoader
=
do_QueryInterface
(
mContent
)
;
MOZ_ASSERT
(
imageLoader
)
;
imageLoader
-
>
FrameDestroyed
(
this
)
;
imageLoader
-
>
RemoveNativeObserver
(
mListener
)
;
}
else
if
(
mContentURLRequest
)
{
PresContext
(
)
-
>
Document
(
)
-
>
ImageTracker
(
)
-
>
Remove
(
mContentURLRequest
)
;
nsLayoutUtils
:
:
DeregisterImageRequest
(
PresContext
(
)
mContentURLRequest
&
mContentURLRequestRegistered
)
;
mContentURLRequest
-
>
Cancel
(
NS_BINDING_ABORTED
)
;
}
mListener
-
>
SetFrame
(
nullptr
)
;
mListener
=
nullptr
;
if
(
mDisplayingIcon
)
gIconLoad
-
>
RemoveIconObserver
(
this
)
;
nsAtomicContainerFrame
:
:
DestroyFrom
(
aDestructRoot
aPostDestroyData
)
;
}
void
nsImageFrame
:
:
MaybeRecordContentUrlOnImageTelemetry
(
)
{
if
(
mKind
!
=
Kind
:
:
ImageElement
)
{
return
;
}
const
auto
&
content
=
*
StyleContent
(
)
;
if
(
content
.
ContentCount
(
)
!
=
1
)
{
return
;
}
const
auto
&
item
=
content
.
ContentAt
(
0
)
;
if
(
!
item
.
IsImage
(
)
)
{
return
;
}
PresContext
(
)
-
>
Document
(
)
-
>
SetUseCounter
(
eUseCounter_custom_ContentUrlOnImageContent
)
;
}
void
nsImageFrame
:
:
DidSetComputedStyle
(
ComputedStyle
*
aOldStyle
)
{
nsAtomicContainerFrame
:
:
DidSetComputedStyle
(
aOldStyle
)
;
MaybeRecordContentUrlOnImageTelemetry
(
)
;
if
(
IsForMarkerPseudo
(
)
)
{
mIntrinsicSize
=
IntrinsicSize
(
0
0
)
;
UpdateIntrinsicSize
(
)
;
}
auto
newOrientation
=
StyleVisibility
(
)
-
>
mImageOrientation
;
bool
shouldUpdateOrientation
=
mImage
&
&
(
!
aOldStyle
|
|
aOldStyle
-
>
StyleVisibility
(
)
-
>
mImageOrientation
!
=
newOrientation
)
;
if
(
shouldUpdateOrientation
)
{
nsCOMPtr
<
imgIContainer
>
image
(
mImage
-
>
Unwrap
(
)
)
;
mImage
=
nsLayoutUtils
:
:
OrientImage
(
image
newOrientation
)
;
UpdateIntrinsicSize
(
)
;
UpdateIntrinsicRatio
(
)
;
}
else
if
(
!
aOldStyle
|
|
aOldStyle
-
>
StylePosition
(
)
-
>
mAspectRatio
!
=
StylePosition
(
)
-
>
mAspectRatio
)
{
UpdateIntrinsicRatio
(
)
;
}
}
static
bool
SizeIsAvailable
(
imgIRequest
*
aRequest
)
{
if
(
!
aRequest
)
{
return
false
;
}
uint32_t
imageStatus
=
0
;
nsresult
rv
=
aRequest
-
>
GetImageStatus
(
&
imageStatus
)
;
return
NS_SUCCEEDED
(
rv
)
&
&
(
imageStatus
&
imgIRequest
:
:
STATUS_SIZE_AVAILABLE
)
;
}
const
StyleImage
*
nsImageFrame
:
:
GetImageFromStyle
(
)
const
{
if
(
mKind
=
=
Kind
:
:
ImageElement
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Don
'
t
call
me
"
)
;
return
nullptr
;
}
if
(
mKind
=
=
Kind
:
:
ListStyleImage
)
{
MOZ_ASSERT
(
GetParent
(
)
-
>
GetContent
(
)
-
>
IsGeneratedContentContainerForMarker
(
)
)
;
MOZ_ASSERT
(
mContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
mozgeneratedcontentimage
)
)
;
return
&
StyleList
(
)
-
>
mListStyleImage
;
}
uint32_t
contentIndex
=
0
;
const
nsStyleContent
*
styleContent
=
StyleContent
(
)
;
if
(
mKind
=
=
Kind
:
:
ContentPropertyAtIndex
)
{
MOZ_RELEASE_ASSERT
(
mContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
mozgeneratedcontentimage
)
)
;
contentIndex
=
static_cast
<
GeneratedImageContent
*
>
(
mContent
.
get
(
)
)
-
>
Index
(
)
;
nsIFrame
*
parent
=
GetParent
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
parent
-
>
GetContent
(
)
-
>
IsGeneratedContentContainerForMarker
(
)
|
|
parent
-
>
GetContent
(
)
-
>
IsGeneratedContentContainerForAfter
(
)
|
|
parent
-
>
GetContent
(
)
-
>
IsGeneratedContentContainerForBefore
(
)
)
;
nsIFrame
*
nonAnonymousParent
=
parent
;
while
(
nonAnonymousParent
-
>
Style
(
)
-
>
IsAnonBox
(
)
)
{
nonAnonymousParent
=
nonAnonymousParent
-
>
GetParent
(
)
;
}
MOZ_DIAGNOSTIC_ASSERT
(
parent
-
>
GetContent
(
)
=
=
nonAnonymousParent
-
>
GetContent
(
)
)
;
styleContent
=
nonAnonymousParent
-
>
StyleContent
(
)
;
}
MOZ_RELEASE_ASSERT
(
contentIndex
<
styleContent
-
>
ContentCount
(
)
)
;
auto
&
contentItem
=
styleContent
-
>
ContentAt
(
contentIndex
)
;
MOZ_RELEASE_ASSERT
(
contentItem
.
IsImage
(
)
)
;
return
&
contentItem
.
AsImage
(
)
;
}
void
nsImageFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
MOZ_ASSERT_IF
(
aPrevInFlow
aPrevInFlow
-
>
Type
(
)
=
=
Type
(
)
&
&
static_cast
<
nsImageFrame
*
>
(
aPrevInFlow
)
-
>
mKind
=
=
mKind
)
;
nsAtomicContainerFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
mListener
=
new
nsImageListener
(
this
)
;
if
(
!
gIconLoad
)
{
LoadIcons
(
PresContext
(
)
)
;
}
if
(
mKind
=
=
Kind
:
:
ImageElement
)
{
nsCOMPtr
<
nsIImageLoadingContent
>
imageLoader
=
do_QueryInterface
(
aContent
)
;
MOZ_ASSERT
(
imageLoader
)
;
imageLoader
-
>
AddNativeObserver
(
mListener
)
;
imageLoader
-
>
FrameCreated
(
this
)
;
}
else
{
const
StyleImage
*
image
=
GetImageFromStyle
(
)
;
MOZ_ASSERT
(
mKind
=
=
Kind
:
:
ListStyleImage
|
|
image
-
>
IsImageRequestType
(
)
"
Content
image
should
only
parse
url
(
)
type
"
)
;
if
(
image
-
>
IsImageRequestType
(
)
)
{
if
(
imgRequestProxy
*
proxy
=
image
-
>
GetImageRequest
(
)
)
{
proxy
-
>
Clone
(
mListener
PresContext
(
)
-
>
Document
(
)
getter_AddRefs
(
mContentURLRequest
)
)
;
SetupForContentURLRequest
(
)
;
}
}
}
if
(
nsCOMPtr
<
imgIRequest
>
currentRequest
=
GetCurrentRequest
(
)
)
{
uint32_t
categoryToBoostPriority
=
imgIRequest
:
:
CATEGORY_FRAME_INIT
;
if
(
!
HaveSpecifiedSize
(
StylePosition
(
)
)
)
{
categoryToBoostPriority
|
=
imgIRequest
:
:
CATEGORY_SIZE_QUERY
;
}
currentRequest
-
>
BoostPriority
(
categoryToBoostPriority
)
;
}
}
void
nsImageFrame
:
:
SetupForContentURLRequest
(
)
{
MOZ_ASSERT
(
mKind
!
=
Kind
:
:
ImageElement
)
;
if
(
!
mContentURLRequest
)
{
return
;
}
PresContext
(
)
-
>
Document
(
)
-
>
ImageTracker
(
)
-
>
Add
(
mContentURLRequest
)
;
uint32_t
status
=
0
;
nsresult
rv
=
mContentURLRequest
-
>
GetImageStatus
(
&
status
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
if
(
status
&
imgIRequest
:
:
STATUS_SIZE_AVAILABLE
)
{
nsCOMPtr
<
imgIContainer
>
image
;
mContentURLRequest
-
>
GetImage
(
getter_AddRefs
(
image
)
)
;
OnSizeAvailable
(
mContentURLRequest
image
)
;
}
if
(
status
&
imgIRequest
:
:
STATUS_FRAME_COMPLETE
)
{
mFirstFrameComplete
=
true
;
}
if
(
status
&
imgIRequest
:
:
STATUS_IS_ANIMATED
)
{
nsLayoutUtils
:
:
RegisterImageRequest
(
PresContext
(
)
mContentURLRequest
&
mContentURLRequestRegistered
)
;
}
}
static
void
ScaleIntrinsicSizeForDensity
(
IntrinsicSize
&
aSize
const
ImageResolution
&
aResolution
)
{
if
(
aSize
.
width
)
{
aResolution
.
ApplyXTo
(
aSize
.
width
.
ref
(
)
)
;
}
if
(
aSize
.
height
)
{
aResolution
.
ApplyYTo
(
aSize
.
height
.
ref
(
)
)
;
}
}
static
void
ScaleIntrinsicSizeForDensity
(
imgIContainer
*
aImage
nsIContent
&
aContent
IntrinsicSize
&
aSize
)
{
ImageResolution
resolution
=
aImage
-
>
GetResolution
(
)
;
if
(
auto
*
image
=
HTMLImageElement
:
:
FromNode
(
aContent
)
)
{
if
(
auto
*
selector
=
image
-
>
GetResponsiveImageSelector
(
)
)
{
resolution
.
ScaleBy
(
selector
-
>
GetSelectedImageDensity
(
)
)
;
}
}
ScaleIntrinsicSizeForDensity
(
aSize
resolution
)
;
}
static
nscoord
ListImageDefaultLength
(
const
nsImageFrame
&
aFrame
)
{
auto
*
pc
=
aFrame
.
PresContext
(
)
;
RefPtr
<
nsFontMetrics
>
fm
=
nsLayoutUtils
:
:
GetFontMetricsForComputedStyle
(
aFrame
.
Style
(
)
pc
)
;
auto
emAU
=
fm
-
>
GetThebesFontGroup
(
)
-
>
GetFirstValidFont
(
)
-
>
GetMetrics
(
fm
-
>
Orientation
(
)
)
.
emHeight
*
pc
-
>
AppUnitsPerDevPixel
(
)
;
return
std
:
:
max
(
NSToCoordRound
(
0
.
4f
*
emAU
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
1
)
)
;
}
static
IntrinsicSize
ComputeIntrinsicSize
(
imgIContainer
*
aImage
bool
aUseMappedRatio
nsImageFrame
:
:
Kind
aKind
const
nsImageFrame
&
aFrame
)
{
const
ComputedStyle
&
style
=
*
aFrame
.
Style
(
)
;
const
auto
containAxes
=
style
.
StyleDisplay
(
)
-
>
GetContainSizeAxes
(
)
;
if
(
containAxes
.
IsBoth
(
)
)
{
return
IntrinsicSize
(
0
0
)
;
}
nsSize
size
;
if
(
aImage
&
&
NS_SUCCEEDED
(
aImage
-
>
GetIntrinsicSize
(
&
size
)
)
)
{
IntrinsicSize
intrinsicSize
;
intrinsicSize
.
width
=
size
.
width
=
=
-
1
?
Nothing
(
)
:
Some
(
size
.
width
)
;
intrinsicSize
.
height
=
size
.
height
=
=
-
1
?
Nothing
(
)
:
Some
(
size
.
height
)
;
if
(
aKind
=
=
nsImageFrame
:
:
Kind
:
:
ListStyleImage
)
{
if
(
intrinsicSize
.
width
.
isNothing
(
)
|
|
intrinsicSize
.
height
.
isNothing
(
)
)
{
nscoord
defaultLength
=
ListImageDefaultLength
(
aFrame
)
;
if
(
intrinsicSize
.
width
.
isNothing
(
)
)
{
intrinsicSize
.
width
=
Some
(
defaultLength
)
;
}
if
(
intrinsicSize
.
height
.
isNothing
(
)
)
{
intrinsicSize
.
height
=
Some
(
defaultLength
)
;
}
}
}
if
(
aKind
=
=
nsImageFrame
:
:
Kind
:
:
ImageElement
)
{
ScaleIntrinsicSizeForDensity
(
aImage
*
aFrame
.
GetContent
(
)
intrinsicSize
)
;
}
else
{
ScaleIntrinsicSizeForDensity
(
intrinsicSize
aFrame
.
GetImageFromStyle
(
)
-
>
GetResolution
(
)
)
;
}
return
containAxes
.
ContainIntrinsicSize
(
intrinsicSize
aFrame
.
GetWritingMode
(
)
)
;
}
if
(
aKind
=
=
nsImageFrame
:
:
Kind
:
:
ListStyleImage
)
{
nscoord
defaultLength
=
ListImageDefaultLength
(
aFrame
)
;
return
containAxes
.
ContainIntrinsicSize
(
IntrinsicSize
(
defaultLength
defaultLength
)
aFrame
.
GetWritingMode
(
)
)
;
}
if
(
aFrame
.
ShouldShowBrokenImageIcon
(
)
)
{
nscoord
edgeLengthToUse
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
ICON_SIZE
+
(
2
*
(
ICON_PADDING
+
ALT_BORDER_WIDTH
)
)
)
;
return
containAxes
.
ContainIntrinsicSize
(
IntrinsicSize
(
edgeLengthToUse
edgeLengthToUse
)
aFrame
.
GetWritingMode
(
)
)
;
}
if
(
aUseMappedRatio
&
&
style
.
StylePosition
(
)
-
>
mAspectRatio
.
HasRatio
(
)
)
{
return
IntrinsicSize
(
)
;
}
return
IntrinsicSize
(
0
0
)
;
}
bool
nsImageFrame
:
:
ShouldUseMappedAspectRatio
(
)
const
{
if
(
mKind
!
=
Kind
:
:
ImageElement
)
{
return
true
;
}
nsCOMPtr
<
imgIRequest
>
currentRequest
=
GetCurrentRequest
(
)
;
if
(
currentRequest
)
{
return
true
;
}
auto
*
image
=
HTMLImageElement
:
:
FromNode
(
mContent
)
;
return
image
&
&
image
-
>
IsAwaitingLoadOrLazyLoading
(
)
;
}
bool
nsImageFrame
:
:
UpdateIntrinsicSize
(
)
{
IntrinsicSize
oldIntrinsicSize
=
mIntrinsicSize
;
mIntrinsicSize
=
ComputeIntrinsicSize
(
mImage
ShouldUseMappedAspectRatio
(
)
mKind
*
this
)
;
return
mIntrinsicSize
!
=
oldIntrinsicSize
;
}
static
AspectRatio
ComputeIntrinsicRatio
(
imgIContainer
*
aImage
bool
aUseMappedRatio
const
nsImageFrame
&
aFrame
)
{
const
ComputedStyle
&
style
=
*
aFrame
.
Style
(
)
;
if
(
style
.
StyleDisplay
(
)
-
>
GetContainSizeAxes
(
)
.
IsAny
(
)
)
{
return
AspectRatio
(
)
;
}
if
(
aImage
)
{
if
(
Maybe
<
AspectRatio
>
fromImage
=
aImage
-
>
GetIntrinsicRatio
(
)
)
{
return
*
fromImage
;
}
}
if
(
aUseMappedRatio
)
{
const
StyleAspectRatio
&
ratio
=
style
.
StylePosition
(
)
-
>
mAspectRatio
;
if
(
ratio
.
auto_
&
&
ratio
.
HasRatio
(
)
)
{
return
ratio
.
ratio
.
AsRatio
(
)
.
ToLayoutRatio
(
UseBoxSizing
:
:
Yes
)
;
}
}
if
(
aFrame
.
ShouldShowBrokenImageIcon
(
)
)
{
return
AspectRatio
(
1
.
0f
)
;
}
return
AspectRatio
(
)
;
}
bool
nsImageFrame
:
:
UpdateIntrinsicRatio
(
)
{
AspectRatio
oldIntrinsicRatio
=
mIntrinsicRatio
;
mIntrinsicRatio
=
ComputeIntrinsicRatio
(
mImage
ShouldUseMappedAspectRatio
(
)
*
this
)
;
return
mIntrinsicRatio
!
=
oldIntrinsicRatio
;
}
bool
nsImageFrame
:
:
GetSourceToDestTransform
(
nsTransform2D
&
aTransform
)
{
nsRect
constraintRect
(
GetContentRectRelativeToSelf
(
)
.
TopLeft
(
)
mComputedSize
)
;
constraintRect
.
y
-
=
GetContinuationOffset
(
)
;
nsRect
destRect
=
nsLayoutUtils
:
:
ComputeObjectDestRect
(
constraintRect
mIntrinsicSize
mIntrinsicRatio
StylePosition
(
)
)
;
aTransform
.
SetToTranslate
(
float
(
destRect
.
x
)
float
(
destRect
.
y
)
)
;
nsSize
intrinsicSize
;
if
(
!
mImage
|
|
!
NS_SUCCEEDED
(
mImage
-
>
GetIntrinsicSize
(
&
intrinsicSize
)
)
|
|
intrinsicSize
.
IsEmpty
(
)
)
{
return
false
;
}
aTransform
.
SetScale
(
float
(
destRect
.
width
)
/
float
(
intrinsicSize
.
width
)
float
(
destRect
.
height
)
/
float
(
intrinsicSize
.
height
)
)
;
return
true
;
}
bool
nsImageFrame
:
:
IsPendingLoad
(
imgIRequest
*
aRequest
)
const
{
if
(
mKind
!
=
Kind
:
:
ImageElement
)
{
MOZ_ASSERT
(
aRequest
=
=
mContentURLRequest
)
;
return
false
;
}
nsCOMPtr
<
nsIImageLoadingContent
>
imageLoader
(
do_QueryInterface
(
mContent
)
)
;
MOZ_ASSERT
(
imageLoader
)
;
int32_t
requestType
=
nsIImageLoadingContent
:
:
UNKNOWN_REQUEST
;
imageLoader
-
>
GetRequestType
(
aRequest
&
requestType
)
;
return
requestType
!
=
nsIImageLoadingContent
:
:
CURRENT_REQUEST
;
}
nsRect
nsImageFrame
:
:
SourceRectToDest
(
const
nsIntRect
&
aRect
)
{
nsRect
r
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
aRect
.
x
-
1
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
aRect
.
y
-
1
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
aRect
.
width
+
2
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
aRect
.
height
+
2
)
)
;
nsTransform2D
sourceToDest
;
if
(
!
GetSourceToDestTransform
(
sourceToDest
)
)
{
return
GetContentRectRelativeToSelf
(
)
;
}
sourceToDest
.
TransformCoord
(
&
r
.
x
&
r
.
y
&
r
.
width
&
r
.
height
)
;
nscoord
scale
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
1
)
;
nscoord
right
=
r
.
x
+
r
.
width
;
nscoord
bottom
=
r
.
y
+
r
.
height
;
r
.
x
-
=
(
scale
+
(
r
.
x
%
scale
)
)
%
scale
;
r
.
y
-
=
(
scale
+
(
r
.
y
%
scale
)
)
%
scale
;
r
.
width
=
right
+
(
(
scale
-
(
right
%
scale
)
)
%
scale
)
-
r
.
x
;
r
.
height
=
bottom
+
(
(
scale
-
(
bottom
%
scale
)
)
%
scale
)
-
r
.
y
;
return
r
;
}
static
bool
ImageOk
(
ElementState
aState
)
{
return
!
aState
.
HasState
(
ElementState
:
:
BROKEN
)
;
}
static
bool
HasAltText
(
const
Element
&
aElement
)
{
if
(
aElement
.
IsHTMLElement
(
nsGkAtoms
:
:
input
)
)
{
return
true
;
}
MOZ_ASSERT
(
aElement
.
IsHTMLElement
(
nsGkAtoms
:
:
img
)
)
;
return
aElement
.
HasNonEmptyAttr
(
nsGkAtoms
:
:
alt
)
;
}
bool
nsImageFrame
:
:
ShouldCreateImageFrameForContent
(
const
Element
&
aElement
const
ComputedStyle
&
aStyle
)
{
if
(
aElement
.
IsRootOfNativeAnonymousSubtree
(
)
)
{
return
false
;
}
const
auto
&
content
=
aStyle
.
StyleContent
(
)
-
>
mContent
;
if
(
!
content
.
IsItems
(
)
)
{
return
false
;
}
Span
<
const
StyleContentItem
>
items
=
content
.
AsItems
(
)
.
AsSpan
(
)
;
return
items
.
Length
(
)
=
=
1
&
&
items
[
0
]
.
IsImage
(
)
;
}
bool
nsImageFrame
:
:
ShouldCreateImageFrameFor
(
const
Element
&
aElement
const
ComputedStyle
&
aStyle
)
{
if
(
ShouldCreateImageFrameForContent
(
aElement
aStyle
)
)
{
return
false
;
}
if
(
ImageOk
(
aElement
.
State
(
)
)
)
{
return
true
;
}
if
(
aStyle
.
StyleUIReset
(
)
-
>
mMozForceBrokenImageIcon
)
{
return
true
;
}
if
(
gIconLoad
&
&
gIconLoad
-
>
mPrefForceInlineAltText
)
{
return
false
;
}
if
(
!
HasAltText
(
aElement
)
)
{
return
true
;
}
if
(
aElement
.
OwnerDoc
(
)
-
>
GetCompatibilityMode
(
)
=
=
eCompatibility_NavQuirks
)
{
return
HaveSpecifiedSize
(
aStyle
.
StylePosition
(
)
)
;
}
return
false
;
}
void
nsImageFrame
:
:
Notify
(
imgIRequest
*
aRequest
int32_t
aType
const
nsIntRect
*
aRect
)
{
if
(
aType
=
=
imgINotificationObserver
:
:
SIZE_AVAILABLE
)
{
nsCOMPtr
<
imgIContainer
>
image
;
aRequest
-
>
GetImage
(
getter_AddRefs
(
image
)
)
;
return
OnSizeAvailable
(
aRequest
image
)
;
}
if
(
aType
=
=
imgINotificationObserver
:
:
FRAME_UPDATE
)
{
return
OnFrameUpdate
(
aRequest
aRect
)
;
}
if
(
aType
=
=
imgINotificationObserver
:
:
FRAME_COMPLETE
)
{
mFirstFrameComplete
=
true
;
}
if
(
aType
=
=
imgINotificationObserver
:
:
IS_ANIMATED
&
&
mKind
!
=
Kind
:
:
ImageElement
)
{
nsLayoutUtils
:
:
RegisterImageRequest
(
PresContext
(
)
mContentURLRequest
&
mContentURLRequestRegistered
)
;
}
if
(
aType
=
=
imgINotificationObserver
:
:
LOAD_COMPLETE
)
{
uint32_t
imgStatus
;
aRequest
-
>
GetImageStatus
(
&
imgStatus
)
;
nsresult
status
=
imgStatus
&
imgIRequest
:
:
STATUS_ERROR
?
NS_ERROR_FAILURE
:
NS_OK
;
return
OnLoadComplete
(
aRequest
status
)
;
}
}
void
nsImageFrame
:
:
OnSizeAvailable
(
imgIRequest
*
aRequest
imgIContainer
*
aImage
)
{
if
(
!
aImage
)
{
return
;
}
aImage
-
>
SetAnimationMode
(
PresContext
(
)
-
>
ImageAnimationMode
(
)
)
;
if
(
IsPendingLoad
(
aRequest
)
)
{
return
;
}
UpdateImage
(
aRequest
aImage
)
;
}
void
nsImageFrame
:
:
UpdateImage
(
imgIRequest
*
aRequest
imgIContainer
*
aImage
)
{
MOZ_ASSERT
(
aRequest
)
;
if
(
SizeIsAvailable
(
aRequest
)
)
{
mImage
=
nsLayoutUtils
:
:
OrientImage
(
aImage
StyleVisibility
(
)
-
>
mImageOrientation
)
;
MOZ_ASSERT
(
mImage
)
;
}
else
{
mImage
=
mPrevImage
=
nullptr
;
if
(
mKind
=
=
Kind
:
:
ListStyleImage
)
{
auto
*
genContent
=
static_cast
<
GeneratedImageContent
*
>
(
GetContent
(
)
)
;
genContent
-
>
NotifyLoadFailed
(
)
;
return
;
}
}
bool
intrinsicSizeOrRatioChanged
=
[
&
]
{
bool
intrinsicSizeChanged
=
UpdateIntrinsicSize
(
)
;
bool
intrinsicRatioChanged
=
UpdateIntrinsicRatio
(
)
;
return
intrinsicSizeChanged
|
|
intrinsicRatioChanged
;
}
(
)
;
if
(
!
GotInitialReflow
(
)
)
{
return
;
}
InvalidateFrame
(
)
;
if
(
intrinsicSizeOrRatioChanged
)
{
if
(
!
(
mState
&
IMAGE_SIZECONSTRAINED
)
)
{
PresShell
(
)
-
>
FrameNeedsReflow
(
this
IntrinsicDirty
:
:
StyleChange
NS_FRAME_IS_DIRTY
)
;
}
else
if
(
PresShell
(
)
-
>
IsActive
(
)
)
{
MaybeDecodeForPredictedSize
(
)
;
}
}
}
void
nsImageFrame
:
:
OnFrameUpdate
(
imgIRequest
*
aRequest
const
nsIntRect
*
aRect
)
{
if
(
NS_WARN_IF
(
!
aRect
)
)
{
return
;
}
if
(
!
GotInitialReflow
(
)
)
{
return
;
}
if
(
mFirstFrameComplete
&
&
!
StyleVisibility
(
)
-
>
IsVisible
(
)
)
{
return
;
}
if
(
IsPendingLoad
(
aRequest
)
)
{
return
;
}
nsIntRect
layerInvalidRect
=
mImage
?
mImage
-
>
GetImageSpaceInvalidationRect
(
*
aRect
)
:
*
aRect
;
if
(
layerInvalidRect
.
IsEqualInterior
(
GetMaxSizedIntRect
(
)
)
)
{
InvalidateSelf
(
nullptr
nullptr
)
;
return
;
}
nsRect
frameInvalidRect
=
SourceRectToDest
(
layerInvalidRect
)
;
InvalidateSelf
(
&
layerInvalidRect
&
frameInvalidRect
)
;
}
void
nsImageFrame
:
:
InvalidateSelf
(
const
nsIntRect
*
aLayerInvalidRect
const
nsRect
*
aFrameInvalidRect
)
{
const
auto
type
=
DisplayItemType
:
:
TYPE_IMAGE
;
const
auto
providerId
=
mImage
?
mImage
-
>
GetProviderId
(
)
:
0
;
if
(
WebRenderUserData
:
:
ProcessInvalidateForImage
(
this
type
providerId
)
)
{
return
;
}
InvalidateLayer
(
type
aLayerInvalidRect
aFrameInvalidRect
)
;
if
(
!
mFirstFrameComplete
)
{
InvalidateLayer
(
DisplayItemType
:
:
TYPE_ALT_FEEDBACK
aLayerInvalidRect
aFrameInvalidRect
)
;
}
}
void
nsImageFrame
:
:
OnLoadComplete
(
imgIRequest
*
aRequest
nsresult
aStatus
)
{
NotifyNewCurrentRequest
(
aRequest
aStatus
)
;
}
void
nsImageFrame
:
:
ResponsiveContentDensityChanged
(
)
{
if
(
!
GotInitialReflow
(
)
)
{
return
;
}
if
(
!
mImage
)
{
return
;
}
if
(
!
UpdateIntrinsicSize
(
)
&
&
!
UpdateIntrinsicRatio
(
)
)
{
return
;
}
PresShell
(
)
-
>
FrameNeedsReflow
(
this
IntrinsicDirty
:
:
StyleChange
NS_FRAME_IS_DIRTY
)
;
}
void
nsImageFrame
:
:
NotifyNewCurrentRequest
(
imgIRequest
*
aRequest
nsresult
aStatus
)
{
nsCOMPtr
<
imgIContainer
>
image
;
aRequest
-
>
GetImage
(
getter_AddRefs
(
image
)
)
;
NS_ASSERTION
(
image
|
|
NS_FAILED
(
aStatus
)
"
Successful
load
with
no
container
?
"
)
;
UpdateImage
(
aRequest
image
)
;
}
void
nsImageFrame
:
:
MaybeDecodeForPredictedSize
(
)
{
if
(
!
mImage
)
{
return
;
}
if
(
mComputedSize
.
IsEmpty
(
)
)
{
return
;
}
if
(
GetVisibility
(
)
!
=
Visibility
:
:
ApproximatelyVisible
)
{
return
;
}
mozilla
:
:
PresShell
*
presShell
=
PresContext
(
)
-
>
PresShell
(
)
;
MatrixScales
scale
=
ScaleFactor
<
UnknownUnits
UnknownUnits
>
(
presShell
-
>
GetCumulativeResolution
(
)
)
*
nsLayoutUtils
:
:
GetTransformToAncestorScaleExcludingAnimated
(
this
)
;
auto
resolutionToScreen
=
ViewAs
<
LayoutDeviceToScreenScale2D
>
(
scale
)
;
if
(
BrowserChild
*
browserChild
=
BrowserChild
:
:
GetFrom
(
presShell
)
)
{
resolutionToScreen
=
resolutionToScreen
*
ViewAs
<
ScreenToScreenScale2D
>
(
browserChild
-
>
GetEffectsInfo
(
)
.
mRasterScale
)
;
}
const
nsPoint
offset
=
GetOffsetToCrossDoc
(
nsLayoutUtils
:
:
GetReferenceFrame
(
this
)
)
;
const
nsRect
frameContentBox
=
GetContentRectRelativeToSelf
(
)
+
offset
;
const
int32_t
factor
=
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
const
LayoutDeviceRect
destRect
=
LayoutDeviceRect
:
:
FromAppUnits
(
PredictedDestRect
(
frameContentBox
)
factor
)
;
const
ScreenSize
predictedScreenSize
=
destRect
.
Size
(
)
*
resolutionToScreen
;
const
ScreenIntSize
predictedScreenIntSize
=
RoundedToInt
(
predictedScreenSize
)
;
if
(
predictedScreenIntSize
.
IsEmpty
(
)
)
{
return
;
}
uint32_t
flags
=
imgIContainer
:
:
FLAG_HIGH_QUALITY_SCALING
|
imgIContainer
:
:
FLAG_ASYNC_NOTIFY
;
SamplingFilter
samplingFilter
=
nsLayoutUtils
:
:
GetSamplingFilterForFrame
(
this
)
;
gfxSize
gfxPredictedScreenSize
=
gfxSize
(
predictedScreenIntSize
.
width
predictedScreenIntSize
.
height
)
;
nsIntSize
predictedImageSize
=
mImage
-
>
OptimalImageSizeForDest
(
gfxPredictedScreenSize
imgIContainer
:
:
FRAME_CURRENT
samplingFilter
flags
)
;
mImage
-
>
RequestDecodeForSize
(
predictedImageSize
flags
)
;
}
nsRect
nsImageFrame
:
:
PredictedDestRect
(
const
nsRect
&
aFrameContentBox
)
{
nsRect
constraintRect
(
aFrameContentBox
.
TopLeft
(
)
mComputedSize
)
;
constraintRect
.
y
-
=
GetContinuationOffset
(
)
;
return
nsLayoutUtils
:
:
ComputeObjectDestRect
(
constraintRect
mIntrinsicSize
mIntrinsicRatio
StylePosition
(
)
)
;
}
bool
nsImageFrame
:
:
IsForMarkerPseudo
(
)
const
{
if
(
mKind
=
=
Kind
:
:
ImageElement
)
{
return
false
;
}
auto
*
subtreeRoot
=
GetContent
(
)
-
>
GetClosestNativeAnonymousSubtreeRoot
(
)
;
return
subtreeRoot
&
&
subtreeRoot
-
>
IsGeneratedContentContainerForMarker
(
)
;
}
void
nsImageFrame
:
:
EnsureIntrinsicSizeAndRatio
(
)
{
if
(
StyleDisplay
(
)
-
>
GetContainSizeAxes
(
)
.
IsBoth
(
)
)
{
mIntrinsicSize
=
IntrinsicSize
(
0
0
)
;
mIntrinsicRatio
=
AspectRatio
(
)
;
return
;
}
if
(
mIntrinsicSize
!
=
IntrinsicSize
(
0
0
)
&
&
!
IsForMarkerPseudo
(
)
)
{
return
;
}
UpdateIntrinsicSize
(
)
;
UpdateIntrinsicRatio
(
)
;
}
nsIFrame
:
:
SizeComputationResult
nsImageFrame
:
:
ComputeSize
(
gfxContext
*
aRenderingContext
WritingMode
aWM
const
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
LogicalSize
&
aMargin
const
LogicalSize
&
aBorderPadding
const
StyleSizeOverrides
&
aSizeOverrides
ComputeSizeFlags
aFlags
)
{
EnsureIntrinsicSizeAndRatio
(
)
;
return
{
ComputeSizeWithIntrinsicDimensions
(
aRenderingContext
aWM
mIntrinsicSize
GetAspectRatio
(
)
aCBSize
aMargin
aBorderPadding
aSizeOverrides
aFlags
)
AspectRatioUsage
:
:
None
}
;
}
Element
*
nsImageFrame
:
:
GetMapElement
(
)
const
{
nsCOMPtr
<
nsIImageLoadingContent
>
imageLoader
=
do_QueryInterface
(
mContent
)
;
return
imageLoader
?
static_cast
<
nsImageLoadingContent
*
>
(
imageLoader
.
get
(
)
)
-
>
FindImageMap
(
)
:
nullptr
;
}
nscoord
nsImageFrame
:
:
GetContinuationOffset
(
)
const
{
nscoord
offset
=
0
;
for
(
nsIFrame
*
f
=
GetPrevInFlow
(
)
;
f
;
f
=
f
-
>
GetPrevInFlow
(
)
)
{
offset
+
=
f
-
>
GetContentRect
(
)
.
height
;
}
NS_ASSERTION
(
offset
>
=
0
"
bogus
GetContentRect
"
)
;
return
offset
;
}
nscoord
nsImageFrame
:
:
GetMinISize
(
gfxContext
*
aRenderingContext
)
{
DebugOnly
<
nscoord
>
result
;
DISPLAY_MIN_INLINE_SIZE
(
this
result
)
;
EnsureIntrinsicSizeAndRatio
(
)
;
const
auto
&
iSize
=
GetWritingMode
(
)
.
IsVertical
(
)
?
mIntrinsicSize
.
height
:
mIntrinsicSize
.
width
;
return
iSize
.
valueOr
(
0
)
;
}
nscoord
nsImageFrame
:
:
GetPrefISize
(
gfxContext
*
aRenderingContext
)
{
DebugOnly
<
nscoord
>
result
;
DISPLAY_PREF_INLINE_SIZE
(
this
result
)
;
EnsureIntrinsicSizeAndRatio
(
)
;
const
auto
&
iSize
=
GetWritingMode
(
)
.
IsVertical
(
)
?
mIntrinsicSize
.
height
:
mIntrinsicSize
.
width
;
return
iSize
.
valueOr
(
0
)
;
}
void
nsImageFrame
:
:
ReflowChildren
(
nsPresContext
*
aPresContext
const
ReflowInput
&
aReflowInput
const
LogicalSize
&
aImageSize
)
{
for
(
nsIFrame
*
child
:
mFrames
)
{
ReflowOutput
childDesiredSize
(
aReflowInput
)
;
WritingMode
wm
=
GetWritingMode
(
)
;
MOZ_ASSERT
(
wm
=
=
child
-
>
GetWritingMode
(
)
"
We
don
'
t
expect
mismatched
writing
-
modes
in
content
we
control
"
)
;
nsReflowStatus
childStatus
;
LogicalPoint
childOffset
(
wm
)
;
ReflowInput
childReflowInput
(
aPresContext
aReflowInput
child
aImageSize
)
;
const
nsSize
containerSize
=
aImageSize
.
GetPhysicalSize
(
wm
)
;
ReflowChild
(
child
aPresContext
childDesiredSize
childReflowInput
wm
childOffset
containerSize
ReflowChildFlags
:
:
Default
childStatus
)
;
FinishReflowChild
(
child
aPresContext
childDesiredSize
&
childReflowInput
wm
childOffset
containerSize
ReflowChildFlags
:
:
Default
)
;
}
}
void
nsImageFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aMetrics
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsImageFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aMetrics
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
NS_FRAME_TRACE
(
NS_FRAME_TRACE_CALLS
(
"
enter
nsImageFrame
:
:
Reflow
:
availSize
=
%
d
%
d
"
aReflowInput
.
AvailableWidth
(
)
aReflowInput
.
AvailableHeight
(
)
)
)
;
MOZ_ASSERT
(
mState
&
NS_FRAME_IN_REFLOW
"
frame
is
not
in
reflow
"
)
;
if
(
!
SizeDependsOnIntrinsicSize
(
aReflowInput
)
)
{
AddStateBits
(
IMAGE_SIZECONSTRAINED
)
;
}
else
{
RemoveStateBits
(
IMAGE_SIZECONSTRAINED
)
;
}
mComputedSize
=
nsSize
(
aReflowInput
.
ComputedWidth
(
)
aReflowInput
.
ComputedHeight
(
)
)
;
aMetrics
.
Width
(
)
=
mComputedSize
.
width
;
aMetrics
.
Height
(
)
=
mComputedSize
.
height
;
aMetrics
.
Width
(
)
+
=
aReflowInput
.
ComputedPhysicalBorderPadding
(
)
.
LeftRight
(
)
;
aMetrics
.
Height
(
)
+
=
aReflowInput
.
ComputedPhysicalBorderPadding
(
)
.
TopBottom
(
)
;
if
(
GetPrevInFlow
(
)
)
{
aMetrics
.
Width
(
)
=
GetPrevInFlow
(
)
-
>
GetSize
(
)
.
width
;
nscoord
y
=
GetContinuationOffset
(
)
;
aMetrics
.
Height
(
)
-
=
y
+
aReflowInput
.
ComputedPhysicalBorderPadding
(
)
.
top
;
aMetrics
.
Height
(
)
=
std
:
:
max
(
0
aMetrics
.
Height
(
)
)
;
}
uint32_t
loadStatus
=
imgIRequest
:
:
STATUS_NONE
;
if
(
nsCOMPtr
<
imgIRequest
>
currentRequest
=
GetCurrentRequest
(
)
)
{
currentRequest
-
>
GetImageStatus
(
&
loadStatus
)
;
}
if
(
aPresContext
-
>
IsPaginated
(
)
&
&
(
(
loadStatus
&
imgIRequest
:
:
STATUS_SIZE_AVAILABLE
)
|
|
(
mState
&
IMAGE_SIZECONSTRAINED
)
)
&
&
NS_UNCONSTRAINEDSIZE
!
=
aReflowInput
.
AvailableHeight
(
)
&
&
aMetrics
.
Height
(
)
>
aReflowInput
.
AvailableHeight
(
)
)
{
aMetrics
.
Height
(
)
=
std
:
:
max
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
1
)
aReflowInput
.
AvailableHeight
(
)
)
;
aStatus
.
SetIncomplete
(
)
;
}
aMetrics
.
SetOverflowAreasToDesiredBounds
(
)
;
bool
imageOK
=
mKind
!
=
Kind
:
:
ImageElement
|
|
ImageOk
(
mContent
-
>
AsElement
(
)
-
>
State
(
)
)
;
bool
haveSize
=
false
;
if
(
loadStatus
&
imgIRequest
:
:
STATUS_SIZE_AVAILABLE
)
{
haveSize
=
true
;
}
if
(
!
imageOK
|
|
!
haveSize
)
{
nsRect
altFeedbackSize
(
0
0
nsPresContext
:
:
CSSPixelsToAppUnits
(
ICON_SIZE
+
2
*
(
ICON_PADDING
+
ALT_BORDER_WIDTH
)
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
ICON_SIZE
+
2
*
(
ICON_PADDING
+
ALT_BORDER_WIDTH
)
)
)
;
nsRect
&
inkOverflow
=
aMetrics
.
InkOverflow
(
)
;
inkOverflow
.
UnionRect
(
inkOverflow
altFeedbackSize
)
;
}
else
if
(
PresShell
(
)
-
>
IsActive
(
)
)
{
MaybeDecodeForPredictedSize
(
)
;
}
FinishAndStoreOverflow
(
&
aMetrics
aReflowInput
.
mStyleDisplay
)
;
ReflowChildren
(
aPresContext
aReflowInput
aMetrics
.
Size
(
GetWritingMode
(
)
)
)
;
if
(
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
&
&
!
mReflowCallbackPosted
)
{
mReflowCallbackPosted
=
true
;
PresShell
(
)
-
>
PostReflowCallback
(
this
)
;
}
NS_FRAME_TRACE
(
NS_FRAME_TRACE_CALLS
(
"
exit
nsImageFrame
:
:
Reflow
:
size
=
%
d
%
d
"
aMetrics
.
Width
(
)
aMetrics
.
Height
(
)
)
)
;
NS_FRAME_SET_TRUNCATION
(
aStatus
aReflowInput
aMetrics
)
;
}
bool
nsImageFrame
:
:
ReflowFinished
(
)
{
mReflowCallbackPosted
=
false
;
UpdateVisibilitySynchronously
(
)
;
return
false
;
}
void
nsImageFrame
:
:
ReflowCallbackCanceled
(
)
{
mReflowCallbackPosted
=
false
;
}
nscoord
nsImageFrame
:
:
MeasureString
(
const
char16_t
*
aString
int32_t
aLength
nscoord
aMaxWidth
uint32_t
&
aMaxFit
gfxContext
&
aContext
nsFontMetrics
&
aFontMetrics
)
{
nscoord
totalWidth
=
0
;
aFontMetrics
.
SetTextRunRTL
(
false
)
;
nscoord
spaceWidth
=
aFontMetrics
.
SpaceWidth
(
)
;
aMaxFit
=
0
;
while
(
aLength
>
0
)
{
uint32_t
len
=
aLength
;
bool
trailingSpace
=
false
;
for
(
int32_t
i
=
0
;
i
<
aLength
;
i
+
+
)
{
if
(
dom
:
:
IsSpaceCharacter
(
aString
[
i
]
)
&
&
(
i
>
0
)
)
{
len
=
i
;
trailingSpace
=
true
;
break
;
}
}
nscoord
width
=
nsLayoutUtils
:
:
AppUnitWidthOfStringBidi
(
aString
len
this
aFontMetrics
aContext
)
;
bool
fits
=
(
totalWidth
+
width
)
<
=
aMaxWidth
;
if
(
fits
|
|
(
0
=
=
totalWidth
)
)
{
totalWidth
+
=
width
;
if
(
trailingSpace
)
{
if
(
(
totalWidth
+
spaceWidth
)
<
=
aMaxWidth
)
{
totalWidth
+
=
spaceWidth
;
}
else
{
fits
=
false
;
}
len
+
+
;
}
aMaxFit
+
=
len
;
aString
+
=
len
;
aLength
-
=
len
;
}
if
(
!
fits
)
{
break
;
}
}
return
totalWidth
;
}
void
nsImageFrame
:
:
DisplayAltText
(
nsPresContext
*
aPresContext
gfxContext
&
aRenderingContext
const
nsString
&
aAltText
const
nsRect
&
aRect
)
{
aRenderingContext
.
SetColor
(
sRGBColor
:
:
FromABGR
(
StyleText
(
)
-
>
mColor
.
ToColor
(
)
)
)
;
RefPtr
<
nsFontMetrics
>
fm
=
nsLayoutUtils
:
:
GetInflatedFontMetricsForFrame
(
this
)
;
nscoord
maxAscent
=
fm
-
>
MaxAscent
(
)
;
nscoord
maxDescent
=
fm
-
>
MaxDescent
(
)
;
nscoord
lineHeight
=
fm
-
>
MaxHeight
(
)
;
WritingMode
wm
=
GetWritingMode
(
)
;
bool
isVertical
=
wm
.
IsVertical
(
)
;
fm
-
>
SetVertical
(
isVertical
)
;
fm
-
>
SetTextOrientation
(
StyleVisibility
(
)
-
>
mTextOrientation
)
;
const
char16_t
*
str
=
aAltText
.
get
(
)
;
int32_t
strLen
=
aAltText
.
Length
(
)
;
nsPoint
pt
=
wm
.
IsVerticalRL
(
)
?
aRect
.
TopRight
(
)
-
nsPoint
(
lineHeight
0
)
:
aRect
.
TopLeft
(
)
;
nscoord
iSize
=
isVertical
?
aRect
.
height
:
aRect
.
width
;
if
(
!
aPresContext
-
>
BidiEnabled
(
)
&
&
HasRTLChars
(
aAltText
)
)
{
aPresContext
-
>
SetBidiEnabled
(
)
;
}
bool
firstLine
=
true
;
while
(
strLen
>
0
)
{
if
(
!
firstLine
)
{
if
(
(
!
isVertical
&
&
(
pt
.
y
+
maxDescent
)
>
=
aRect
.
YMost
(
)
)
|
|
(
wm
.
IsVerticalRL
(
)
&
&
(
pt
.
x
+
maxDescent
<
aRect
.
x
)
)
|
|
(
wm
.
IsVerticalLR
(
)
&
&
(
pt
.
x
+
maxDescent
>
=
aRect
.
XMost
(
)
)
)
)
{
break
;
}
}
uint32_t
maxFit
;
nscoord
strWidth
=
MeasureString
(
str
strLen
iSize
maxFit
aRenderingContext
*
fm
)
;
nsresult
rv
=
NS_ERROR_FAILURE
;
if
(
aPresContext
-
>
BidiEnabled
(
)
)
{
mozilla
:
:
intl
:
:
BidiEmbeddingLevel
level
;
nscoord
x
y
;
if
(
isVertical
)
{
x
=
pt
.
x
+
maxDescent
;
if
(
wm
.
IsBidiLTR
(
)
)
{
y
=
aRect
.
y
;
level
=
mozilla
:
:
intl
:
:
BidiEmbeddingLevel
:
:
LTR
(
)
;
}
else
{
y
=
aRect
.
YMost
(
)
-
strWidth
;
level
=
mozilla
:
:
intl
:
:
BidiEmbeddingLevel
:
:
RTL
(
)
;
}
}
else
{
y
=
pt
.
y
+
maxAscent
;
if
(
wm
.
IsBidiLTR
(
)
)
{
x
=
aRect
.
x
;
level
=
mozilla
:
:
intl
:
:
BidiEmbeddingLevel
:
:
LTR
(
)
;
}
else
{
x
=
aRect
.
XMost
(
)
-
strWidth
;
level
=
mozilla
:
:
intl
:
:
BidiEmbeddingLevel
:
:
RTL
(
)
;
}
}
rv
=
nsBidiPresUtils
:
:
RenderText
(
str
maxFit
level
aPresContext
aRenderingContext
aRenderingContext
.
GetDrawTarget
(
)
*
fm
x
y
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
nsLayoutUtils
:
:
DrawUniDirString
(
str
maxFit
isVertical
?
nsPoint
(
pt
.
x
+
maxDescent
pt
.
y
)
:
nsPoint
(
pt
.
x
pt
.
y
+
maxAscent
)
*
fm
aRenderingContext
)
;
}
str
+
=
maxFit
;
strLen
-
=
maxFit
;
if
(
wm
.
IsVerticalRL
(
)
)
{
pt
.
x
-
=
lineHeight
;
}
else
if
(
wm
.
IsVerticalLR
(
)
)
{
pt
.
x
+
=
lineHeight
;
}
else
{
pt
.
y
+
=
lineHeight
;
}
firstLine
=
false
;
}
}
struct
nsRecessedBorder
:
public
nsStyleBorder
{
nsRecessedBorder
(
nscoord
aBorderWidth
nsPresContext
*
aPresContext
)
:
nsStyleBorder
(
*
aPresContext
-
>
Document
(
)
)
{
for
(
const
auto
side
:
mozilla
:
:
AllPhysicalSides
(
)
)
{
BorderColorFor
(
side
)
=
StyleColor
:
:
Black
(
)
;
mBorder
.
Side
(
side
)
=
aBorderWidth
;
SetBorderStyle
(
side
StyleBorderStyle
:
:
Inset
)
;
}
}
}
;
class
nsDisplayAltFeedback
final
:
public
nsPaintedDisplayItem
{
public
:
nsDisplayAltFeedback
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
:
nsPaintedDisplayItem
(
aBuilder
aFrame
)
{
}
nsDisplayItemGeometry
*
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
final
{
return
new
nsDisplayItemGenericImageGeometry
(
this
aBuilder
)
;
}
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
final
{
auto
geometry
=
static_cast
<
const
nsDisplayItemGenericImageGeometry
*
>
(
aGeometry
)
;
if
(
aBuilder
-
>
ShouldSyncDecodeImages
(
)
&
&
geometry
-
>
ShouldInvalidateToSyncDecodeImages
(
)
)
{
bool
snap
;
aInvalidRegion
-
>
Or
(
*
aInvalidRegion
GetBounds
(
aBuilder
&
snap
)
)
;
}
nsDisplayItem
:
:
ComputeInvalidationRegion
(
aBuilder
aGeometry
aInvalidRegion
)
;
}
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
final
{
*
aSnap
=
false
;
return
mFrame
-
>
InkOverflowRectRelativeToSelf
(
)
+
ToReferenceFrame
(
)
;
}
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
final
{
uint32_t
flags
=
imgIContainer
:
:
FLAG_SYNC_DECODE
;
nsImageFrame
*
f
=
static_cast
<
nsImageFrame
*
>
(
mFrame
)
;
ImgDrawResult
result
=
f
-
>
DisplayAltFeedback
(
*
aCtx
GetPaintRect
(
aBuilder
aCtx
)
ToReferenceFrame
(
)
flags
)
;
nsDisplayItemGenericImageGeometry
:
:
UpdateDrawResult
(
this
result
)
;
}
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
final
{
uint32_t
flags
=
imgIContainer
:
:
FLAG_ASYNC_NOTIFY
;
nsImageFrame
*
f
=
static_cast
<
nsImageFrame
*
>
(
mFrame
)
;
ImgDrawResult
result
=
f
-
>
DisplayAltFeedbackWithoutLayer
(
this
aBuilder
aResources
aSc
aManager
aDisplayListBuilder
ToReferenceFrame
(
)
flags
)
;
return
result
=
=
ImgDrawResult
:
:
SUCCESS
;
}
NS_DISPLAY_DECL_NAME
(
"
AltFeedback
"
TYPE_ALT_FEEDBACK
)
}
;
ImgDrawResult
nsImageFrame
:
:
DisplayAltFeedback
(
gfxContext
&
aRenderingContext
const
nsRect
&
aDirtyRect
nsPoint
aPt
uint32_t
aFlags
)
{
MOZ_ASSERT
(
gIconLoad
"
How
did
we
succeed
in
Init
then
?
"
)
;
bool
isLoading
=
mKind
!
=
Kind
:
:
ImageElement
|
|
ImageOk
(
mContent
-
>
AsElement
(
)
-
>
State
(
)
)
;
nsRect
inner
=
GetContentRectRelativeToSelf
(
)
+
aPt
;
nscoord
borderEdgeWidth
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
ALT_BORDER_WIDTH
)
;
if
(
inner
.
IsEmpty
(
)
)
{
inner
.
SizeTo
(
2
*
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
ICON_SIZE
+
ICON_PADDING
+
ALT_BORDER_WIDTH
)
)
2
*
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
ICON_SIZE
+
ICON_PADDING
+
ALT_BORDER_WIDTH
)
)
)
;
}
if
(
(
inner
.
width
<
2
*
borderEdgeWidth
)
|
|
(
inner
.
height
<
2
*
borderEdgeWidth
)
)
{
return
ImgDrawResult
:
:
SUCCESS
;
}
if
(
!
isLoading
|
|
gIconLoad
-
>
mPrefShowLoadingPlaceholder
)
{
nsRecessedBorder
recessedBorder
(
borderEdgeWidth
PresContext
(
)
)
;
MOZ_ASSERT
(
recessedBorder
.
mBorderImageSource
.
IsNone
(
)
)
;
Unused
<
<
nsCSSRendering
:
:
PaintBorderWithStyleBorder
(
PresContext
(
)
aRenderingContext
this
inner
inner
recessedBorder
mComputedStyle
PaintBorderFlags
:
:
SyncDecodeImages
)
;
}
inner
.
Deflate
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
ICON_PADDING
+
ALT_BORDER_WIDTH
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
ICON_PADDING
+
ALT_BORDER_WIDTH
)
)
;
if
(
inner
.
IsEmpty
(
)
)
{
return
ImgDrawResult
:
:
SUCCESS
;
}
DrawTarget
*
drawTarget
=
aRenderingContext
.
GetDrawTarget
(
)
;
aRenderingContext
.
Save
(
)
;
aRenderingContext
.
Clip
(
NSRectToSnappedRect
(
inner
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
*
drawTarget
)
)
;
ImgDrawResult
result
=
ImgDrawResult
:
:
NOT_READY
;
if
(
!
ShouldShowBrokenImageIcon
(
)
|
|
!
gIconLoad
-
>
mPrefShowPlaceholders
|
|
(
isLoading
&
&
!
gIconLoad
-
>
mPrefShowLoadingPlaceholder
)
)
{
result
=
ImgDrawResult
:
:
SUCCESS
;
}
else
{
nscoord
size
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
ICON_SIZE
)
;
imgIRequest
*
request
=
isLoading
?
nsImageFrame
:
:
gIconLoad
-
>
mLoadingImage
:
nsImageFrame
:
:
gIconLoad
-
>
mBrokenImage
;
if
(
request
&
&
!
mDisplayingIcon
)
{
gIconLoad
-
>
AddIconObserver
(
this
)
;
mDisplayingIcon
=
true
;
}
WritingMode
wm
=
GetWritingMode
(
)
;
bool
flushRight
=
wm
.
IsPhysicalRTL
(
)
;
uint32_t
imageStatus
=
0
;
if
(
request
)
request
-
>
GetImageStatus
(
&
imageStatus
)
;
if
(
imageStatus
&
imgIRequest
:
:
STATUS_LOAD_COMPLETE
&
&
!
(
imageStatus
&
imgIRequest
:
:
STATUS_ERROR
)
)
{
nsCOMPtr
<
imgIContainer
>
imgCon
;
request
-
>
GetImage
(
getter_AddRefs
(
imgCon
)
)
;
MOZ_ASSERT
(
imgCon
"
Load
complete
but
no
image
container
?
"
)
;
nsRect
dest
(
flushRight
?
inner
.
XMost
(
)
-
size
:
inner
.
x
inner
.
y
size
size
)
;
result
=
nsLayoutUtils
:
:
DrawSingleImage
(
aRenderingContext
PresContext
(
)
imgCon
nsLayoutUtils
:
:
GetSamplingFilterForFrame
(
this
)
dest
aDirtyRect
SVGImageContext
(
)
aFlags
)
;
}
if
(
result
=
=
ImgDrawResult
:
:
NOT_READY
)
{
ColorPattern
color
(
ToDeviceColor
(
sRGBColor
(
1
.
f
0
.
f
0
.
f
1
.
f
)
)
)
;
nscoord
iconXPos
=
flushRight
?
inner
.
XMost
(
)
-
size
:
inner
.
x
;
nsRect
rect
(
iconXPos
inner
.
y
size
size
)
;
Rect
devPxRect
=
ToRect
(
nsLayoutUtils
:
:
RectToGfxRect
(
rect
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
)
;
drawTarget
-
>
StrokeRect
(
devPxRect
color
)
;
nscoord
twoPX
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
2
)
;
rect
=
nsRect
(
iconXPos
+
size
/
2
inner
.
y
+
size
/
2
size
/
2
-
twoPX
size
/
2
-
twoPX
)
;
devPxRect
=
ToRect
(
nsLayoutUtils
:
:
RectToGfxRect
(
rect
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
)
;
RefPtr
<
PathBuilder
>
builder
=
drawTarget
-
>
CreatePathBuilder
(
)
;
AppendEllipseToPath
(
builder
devPxRect
.
Center
(
)
devPxRect
.
Size
(
)
)
;
RefPtr
<
Path
>
ellipse
=
builder
-
>
Finish
(
)
;
drawTarget
-
>
Fill
(
ellipse
color
)
;
}
int32_t
paddedIconSize
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
ICON_SIZE
+
ICON_PADDING
)
;
if
(
wm
.
IsVertical
(
)
)
{
inner
.
y
+
=
paddedIconSize
;
inner
.
height
-
=
paddedIconSize
;
}
else
{
if
(
!
flushRight
)
{
inner
.
x
+
=
paddedIconSize
;
}
inner
.
width
-
=
paddedIconSize
;
}
}
if
(
!
inner
.
IsEmpty
(
)
)
{
nsAutoString
altText
;
nsCSSFrameConstructor
:
:
GetAlternateTextFor
(
*
mContent
-
>
AsElement
(
)
altText
)
;
DisplayAltText
(
PresContext
(
)
aRenderingContext
altText
inner
)
;
}
aRenderingContext
.
Restore
(
)
;
return
result
;
}
ImgDrawResult
nsImageFrame
:
:
DisplayAltFeedbackWithoutLayer
(
nsDisplayItem
*
aItem
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
nsPoint
aPt
uint32_t
aFlags
)
{
MOZ_ASSERT
(
gIconLoad
"
How
did
we
succeed
in
Init
then
?
"
)
;
bool
isLoading
=
mKind
!
=
Kind
:
:
ImageElement
|
|
ImageOk
(
mContent
-
>
AsElement
(
)
-
>
State
(
)
)
;
nsRect
inner
=
GetContentRectRelativeToSelf
(
)
+
aPt
;
nscoord
borderEdgeWidth
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
ALT_BORDER_WIDTH
)
;
if
(
inner
.
IsEmpty
(
)
)
{
inner
.
SizeTo
(
2
*
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
ICON_SIZE
+
ICON_PADDING
+
ALT_BORDER_WIDTH
)
)
2
*
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
ICON_SIZE
+
ICON_PADDING
+
ALT_BORDER_WIDTH
)
)
)
;
}
if
(
(
inner
.
width
<
2
*
borderEdgeWidth
)
|
|
(
inner
.
height
<
2
*
borderEdgeWidth
)
)
{
return
ImgDrawResult
:
:
SUCCESS
;
}
bool
textDrawResult
=
true
;
class
AutoSaveRestore
{
public
:
explicit
AutoSaveRestore
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
bool
&
aTextDrawResult
)
:
mBuilder
(
aBuilder
)
mTextDrawResult
(
aTextDrawResult
)
{
mBuilder
.
Save
(
)
;
}
~
AutoSaveRestore
(
)
{
if
(
mTextDrawResult
)
{
mBuilder
.
ClearSave
(
)
;
}
else
{
mBuilder
.
Restore
(
)
;
}
}
private
:
mozilla
:
:
wr
:
:
DisplayListBuilder
&
mBuilder
;
bool
&
mTextDrawResult
;
}
;
AutoSaveRestore
autoSaveRestore
(
aBuilder
textDrawResult
)
;
if
(
!
isLoading
|
|
gIconLoad
-
>
mPrefShowLoadingPlaceholder
)
{
nsRecessedBorder
recessedBorder
(
borderEdgeWidth
PresContext
(
)
)
;
MOZ_ASSERT
(
recessedBorder
.
mBorderImageSource
.
IsNone
(
)
)
;
nsRect
rect
=
nsRect
(
aPt
GetSize
(
)
)
;
Unused
<
<
nsCSSRendering
:
:
CreateWebRenderCommandsForBorderWithStyleBorder
(
aItem
this
rect
aBuilder
aResources
aSc
aManager
aDisplayListBuilder
recessedBorder
)
;
}
inner
.
Deflate
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
ICON_PADDING
+
ALT_BORDER_WIDTH
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
ICON_PADDING
+
ALT_BORDER_WIDTH
)
)
;
if
(
inner
.
IsEmpty
(
)
)
{
return
ImgDrawResult
:
:
SUCCESS
;
}
LayoutDeviceRect
bounds
=
LayoutDeviceRect
:
:
FromAppUnits
(
inner
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
auto
wrBounds
=
wr
:
:
ToLayoutRect
(
bounds
)
;
if
(
ShouldShowBrokenImageIcon
(
)
&
&
gIconLoad
-
>
mPrefShowPlaceholders
&
&
(
!
isLoading
|
|
gIconLoad
-
>
mPrefShowLoadingPlaceholder
)
)
{
ImgDrawResult
result
=
ImgDrawResult
:
:
NOT_READY
;
nscoord
size
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
ICON_SIZE
)
;
imgIRequest
*
request
=
isLoading
?
nsImageFrame
:
:
gIconLoad
-
>
mLoadingImage
:
nsImageFrame
:
:
gIconLoad
-
>
mBrokenImage
;
if
(
request
&
&
!
mDisplayingIcon
)
{
gIconLoad
-
>
AddIconObserver
(
this
)
;
mDisplayingIcon
=
true
;
}
WritingMode
wm
=
GetWritingMode
(
)
;
const
bool
flushRight
=
wm
.
IsPhysicalRTL
(
)
;
uint32_t
imageStatus
=
0
;
if
(
request
)
request
-
>
GetImageStatus
(
&
imageStatus
)
;
if
(
imageStatus
&
imgIRequest
:
:
STATUS_LOAD_COMPLETE
&
&
!
(
imageStatus
&
imgIRequest
:
:
STATUS_ERROR
)
)
{
nsCOMPtr
<
imgIContainer
>
imgCon
;
request
-
>
GetImage
(
getter_AddRefs
(
imgCon
)
)
;
MOZ_ASSERT
(
imgCon
"
Load
complete
but
no
image
container
?
"
)
;
nsRect
dest
(
flushRight
?
inner
.
XMost
(
)
-
size
:
inner
.
x
inner
.
y
size
size
)
;
const
int32_t
factor
=
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
LayoutDeviceRect
destRect
(
LayoutDeviceRect
:
:
FromAppUnits
(
dest
factor
)
)
;
SVGImageContext
svgContext
;
Maybe
<
ImageIntRegion
>
region
;
IntSize
decodeSize
=
nsLayoutUtils
:
:
ComputeImageContainerDrawingParameters
(
imgCon
this
destRect
destRect
aSc
aFlags
svgContext
region
)
;
RefPtr
<
image
:
:
WebRenderImageProvider
>
provider
;
result
=
imgCon
-
>
GetImageProvider
(
aManager
-
>
LayerManager
(
)
decodeSize
svgContext
region
aFlags
getter_AddRefs
(
provider
)
)
;
if
(
provider
)
{
bool
wrResult
=
aManager
-
>
CommandBuilder
(
)
.
PushImageProvider
(
aItem
provider
result
aBuilder
aResources
destRect
bounds
)
;
result
&
=
wrResult
?
ImgDrawResult
:
:
SUCCESS
:
ImgDrawResult
:
:
NOT_READY
;
}
else
{
result
=
ImgDrawResult
:
:
NOT_READY
;
}
}
if
(
result
=
=
ImgDrawResult
:
:
NOT_READY
)
{
auto
color
=
wr
:
:
ColorF
{
1
.
0f
0
.
0f
0
.
0f
1
.
0f
}
;
bool
isBackfaceVisible
=
!
aItem
-
>
BackfaceIsHidden
(
)
;
nscoord
iconXPos
=
flushRight
?
inner
.
XMost
(
)
-
size
:
inner
.
x
;
nsRect
rect
(
iconXPos
inner
.
y
size
size
)
;
auto
devPxRect
=
LayoutDeviceRect
:
:
FromAppUnits
(
rect
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
auto
dest
=
wr
:
:
ToLayoutRect
(
devPxRect
)
;
auto
borderWidths
=
wr
:
:
ToBorderWidths
(
1
.
0
1
.
0
1
.
0
1
.
0
)
;
wr
:
:
BorderSide
side
=
{
color
wr
:
:
BorderStyle
:
:
Solid
}
;
wr
:
:
BorderSide
sides
[
4
]
=
{
side
side
side
side
}
;
Range
<
const
wr
:
:
BorderSide
>
sidesRange
(
sides
4
)
;
aBuilder
.
PushBorder
(
dest
wrBounds
isBackfaceVisible
borderWidths
sidesRange
wr
:
:
EmptyBorderRadius
(
)
)
;
nscoord
twoPX
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
2
)
;
rect
=
nsRect
(
iconXPos
+
size
/
2
inner
.
y
+
size
/
2
size
/
2
-
twoPX
size
/
2
-
twoPX
)
;
devPxRect
=
LayoutDeviceRect
:
:
FromAppUnits
(
rect
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
dest
=
wr
:
:
ToLayoutRect
(
devPxRect
)
;
aBuilder
.
PushRoundedRect
(
dest
wrBounds
isBackfaceVisible
color
)
;
}
int32_t
paddedIconSize
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
ICON_SIZE
+
ICON_PADDING
)
;
if
(
wm
.
IsVertical
(
)
)
{
inner
.
y
+
=
paddedIconSize
;
inner
.
height
-
=
paddedIconSize
;
}
else
{
if
(
!
flushRight
)
{
inner
.
x
+
=
paddedIconSize
;
}
inner
.
width
-
=
paddedIconSize
;
}
}
if
(
!
inner
.
IsEmpty
(
)
)
{
RefPtr
<
TextDrawTarget
>
textDrawer
=
new
TextDrawTarget
(
aBuilder
aResources
aSc
aManager
aItem
inner
true
)
;
RefPtr
<
gfxContext
>
captureCtx
=
gfxContext
:
:
CreateOrNull
(
textDrawer
)
;
nsAutoString
altText
;
nsCSSFrameConstructor
:
:
GetAlternateTextFor
(
*
mContent
-
>
AsElement
(
)
altText
)
;
DisplayAltText
(
PresContext
(
)
*
captureCtx
.
get
(
)
altText
inner
)
;
textDrawer
-
>
TerminateShadows
(
)
;
textDrawResult
=
!
textDrawer
-
>
CheckHasUnsupportedFeatures
(
)
;
}
return
textDrawResult
?
ImgDrawResult
:
:
SUCCESS
:
ImgDrawResult
:
:
NOT_READY
;
}
#
ifdef
DEBUG
static
void
PaintDebugImageMap
(
nsIFrame
*
aFrame
DrawTarget
*
aDrawTarget
const
nsRect
&
aDirtyRect
nsPoint
aPt
)
{
nsImageFrame
*
f
=
static_cast
<
nsImageFrame
*
>
(
aFrame
)
;
nsRect
inner
=
f
-
>
GetContentRectRelativeToSelf
(
)
+
aPt
;
gfxPoint
devPixelOffset
=
nsLayoutUtils
:
:
PointToGfxPoint
(
inner
.
TopLeft
(
)
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
AutoRestoreTransform
autoRestoreTransform
(
aDrawTarget
)
;
aDrawTarget
-
>
SetTransform
(
aDrawTarget
-
>
GetTransform
(
)
.
PreTranslate
(
ToPoint
(
devPixelOffset
)
)
)
;
f
-
>
GetImageMap
(
)
-
>
Draw
(
aFrame
*
aDrawTarget
ColorPattern
(
ToDeviceColor
(
sRGBColor
:
:
OpaqueBlack
(
)
)
)
)
;
}
#
endif
static
bool
OldImageHasDifferentRatio
(
const
nsImageFrame
&
aFrame
imgIContainer
&
aImage
imgIContainer
*
aPrevImage
)
{
if
(
!
aPrevImage
|
|
aPrevImage
=
=
&
aImage
)
{
return
false
;
}
if
(
aFrame
.
HasAnyStateBits
(
IMAGE_SIZECONSTRAINED
)
)
{
return
false
;
}
auto
currentRatio
=
aFrame
.
GetIntrinsicRatio
(
)
;
const
bool
hasRequest
=
true
;
#
ifdef
DEBUG
auto
currentRatioRecomputed
=
ComputeIntrinsicRatio
(
&
aImage
hasRequest
aFrame
)
;
MOZ_ASSERT
(
(
!
currentRatioRecomputed
&
&
aImage
.
GetIntrinsicRatio
(
)
=
=
Nothing
(
)
)
|
|
currentRatio
=
=
currentRatioRecomputed
"
aspect
-
ratio
got
out
of
sync
during
paint
?
How
?
"
)
;
#
endif
auto
oldRatio
=
ComputeIntrinsicRatio
(
aPrevImage
hasRequest
aFrame
)
;
return
oldRatio
!
=
currentRatio
;
}
void
nsDisplayImage
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
MOZ_ASSERT
(
mImage
)
;
auto
*
frame
=
static_cast
<
nsImageFrame
*
>
(
mFrame
)
;
const
bool
oldImageIsDifferent
=
OldImageHasDifferentRatio
(
*
frame
*
mImage
mPrevImage
)
;
uint32_t
flags
=
imgIContainer
:
:
FLAG_NONE
;
if
(
aBuilder
-
>
ShouldSyncDecodeImages
(
)
|
|
oldImageIsDifferent
|
|
frame
-
>
mForceSyncDecoding
)
{
flags
|
=
imgIContainer
:
:
FLAG_SYNC_DECODE
;
}
if
(
aBuilder
-
>
UseHighQualityScaling
(
)
)
{
flags
|
=
imgIContainer
:
:
FLAG_HIGH_QUALITY_SCALING
;
}
ImgDrawResult
result
=
frame
-
>
PaintImage
(
*
aCtx
ToReferenceFrame
(
)
GetPaintRect
(
aBuilder
aCtx
)
mImage
flags
)
;
if
(
result
=
=
ImgDrawResult
:
:
NOT_READY
|
|
result
=
=
ImgDrawResult
:
:
INCOMPLETE
|
|
result
=
=
ImgDrawResult
:
:
TEMPORARY_ERROR
)
{
if
(
mPrevImage
)
{
result
=
frame
-
>
PaintImage
(
*
aCtx
ToReferenceFrame
(
)
GetPaintRect
(
aBuilder
aCtx
)
mPrevImage
flags
)
;
}
}
nsDisplayItemGenericImageGeometry
:
:
UpdateDrawResult
(
this
result
)
;
}
nsDisplayItemGeometry
*
nsDisplayImage
:
:
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
{
return
new
nsDisplayItemGenericImageGeometry
(
this
aBuilder
)
;
}
void
nsDisplayImage
:
:
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
{
auto
geometry
=
static_cast
<
const
nsDisplayItemGenericImageGeometry
*
>
(
aGeometry
)
;
if
(
aBuilder
-
>
ShouldSyncDecodeImages
(
)
&
&
geometry
-
>
ShouldInvalidateToSyncDecodeImages
(
)
)
{
bool
snap
;
aInvalidRegion
-
>
Or
(
*
aInvalidRegion
GetBounds
(
aBuilder
&
snap
)
)
;
}
nsPaintedDisplayItem
:
:
ComputeInvalidationRegion
(
aBuilder
aGeometry
aInvalidRegion
)
;
}
nsRect
nsDisplayImage
:
:
GetDestRect
(
)
const
{
bool
snap
=
true
;
const
nsRect
frameContentBox
=
GetBounds
(
&
snap
)
;
nsImageFrame
*
imageFrame
=
static_cast
<
nsImageFrame
*
>
(
mFrame
)
;
return
imageFrame
-
>
PredictedDestRect
(
frameContentBox
)
;
}
nsRegion
nsDisplayImage
:
:
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
{
*
aSnap
=
false
;
if
(
mImage
&
&
mImage
-
>
WillDrawOpaqueNow
(
)
)
{
const
nsRect
frameContentBox
=
GetBounds
(
aSnap
)
;
return
GetDestRect
(
)
.
Intersect
(
frameContentBox
)
;
}
return
nsRegion
(
)
;
}
bool
nsDisplayImage
:
:
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
if
(
!
mImage
)
{
return
false
;
}
MOZ_ASSERT
(
mFrame
-
>
IsImageFrame
(
)
|
|
mFrame
-
>
IsImageControlFrame
(
)
)
;
auto
*
frame
=
static_cast
<
nsImageFrame
*
>
(
mFrame
)
;
if
(
frame
-
>
HasImageMap
(
)
)
{
return
false
;
}
const
bool
oldImageIsDifferent
=
OldImageHasDifferentRatio
(
*
frame
*
mImage
mPrevImage
)
;
uint32_t
flags
=
imgIContainer
:
:
FLAG_ASYNC_NOTIFY
;
if
(
aDisplayListBuilder
-
>
ShouldSyncDecodeImages
(
)
|
|
oldImageIsDifferent
|
|
frame
-
>
mForceSyncDecoding
)
{
flags
|
=
imgIContainer
:
:
FLAG_SYNC_DECODE
;
}
if
(
aDisplayListBuilder
-
>
UseHighQualityScaling
(
)
)
{
flags
|
=
imgIContainer
:
:
FLAG_HIGH_QUALITY_SCALING
;
}
if
(
StaticPrefs
:
:
image_svg_blob_image
(
)
&
&
mImage
-
>
GetType
(
)
=
=
imgIContainer
:
:
TYPE_VECTOR
)
{
flags
|
=
imgIContainer
:
:
FLAG_RECORD_BLOB
;
}
const
int32_t
factor
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
LayoutDeviceRect
destRect
(
LayoutDeviceRect
:
:
FromAppUnits
(
GetDestRect
(
)
factor
)
)
;
SVGImageContext
svgContext
;
Maybe
<
ImageIntRegion
>
region
;
IntSize
decodeSize
=
nsLayoutUtils
:
:
ComputeImageContainerDrawingParameters
(
mImage
mFrame
destRect
destRect
aSc
flags
svgContext
region
)
;
RefPtr
<
image
:
:
WebRenderImageProvider
>
provider
;
ImgDrawResult
drawResult
=
mImage
-
>
GetImageProvider
(
aManager
-
>
LayerManager
(
)
decodeSize
svgContext
region
flags
getter_AddRefs
(
provider
)
)
;
bool
updatePrevImage
=
false
;
switch
(
drawResult
)
{
case
ImgDrawResult
:
:
NOT_READY
:
case
ImgDrawResult
:
:
INCOMPLETE
:
case
ImgDrawResult
:
:
TEMPORARY_ERROR
:
if
(
mPrevImage
&
&
mPrevImage
!
=
mImage
)
{
uint32_t
prevFlags
=
flags
;
if
(
StaticPrefs
:
:
image_svg_blob_image
(
)
&
&
mPrevImage
-
>
GetType
(
)
=
=
imgIContainer
:
:
TYPE_VECTOR
)
{
prevFlags
|
=
imgIContainer
:
:
FLAG_RECORD_BLOB
;
}
else
{
prevFlags
&
=
~
imgIContainer
:
:
FLAG_RECORD_BLOB
;
}
RefPtr
<
image
:
:
WebRenderImageProvider
>
prevProvider
;
ImgDrawResult
prevDrawResult
=
mPrevImage
-
>
GetImageProvider
(
aManager
-
>
LayerManager
(
)
decodeSize
svgContext
region
prevFlags
getter_AddRefs
(
prevProvider
)
)
;
if
(
prevProvider
&
&
(
prevDrawResult
=
=
ImgDrawResult
:
:
SUCCESS
|
|
prevDrawResult
=
=
ImgDrawResult
:
:
WRONG_SIZE
)
)
{
drawResult
=
ImgDrawResult
:
:
WRONG_SIZE
;
provider
=
std
:
:
move
(
prevProvider
)
;
flags
=
prevFlags
;
break
;
}
updatePrevImage
=
true
;
}
break
;
case
ImgDrawResult
:
:
NOT_SUPPORTED
:
return
false
;
default
:
updatePrevImage
=
mPrevImage
!
=
mImage
;
break
;
}
if
(
updatePrevImage
)
{
mPrevImage
=
mImage
;
frame
-
>
mPrevImage
=
frame
-
>
mImage
;
}
aManager
-
>
CommandBuilder
(
)
.
PushImageProvider
(
this
provider
drawResult
aBuilder
aResources
destRect
destRect
)
;
nsDisplayItemGenericImageGeometry
:
:
UpdateDrawResult
(
this
drawResult
)
;
return
true
;
}
ImgDrawResult
nsImageFrame
:
:
PaintImage
(
gfxContext
&
aRenderingContext
nsPoint
aPt
const
nsRect
&
aDirtyRect
imgIContainer
*
aImage
uint32_t
aFlags
)
{
DrawTarget
*
drawTarget
=
aRenderingContext
.
GetDrawTarget
(
)
;
NS_ASSERTION
(
GetContentRectRelativeToSelf
(
)
.
width
=
=
mComputedSize
.
width
"
bad
width
"
)
;
nsRect
constraintRect
(
aPt
+
GetContentRectRelativeToSelf
(
)
.
TopLeft
(
)
mComputedSize
)
;
constraintRect
.
y
-
=
GetContinuationOffset
(
)
;
nsPoint
anchorPoint
;
nsRect
dest
=
nsLayoutUtils
:
:
ComputeObjectDestRect
(
constraintRect
mIntrinsicSize
mIntrinsicRatio
StylePosition
(
)
&
anchorPoint
)
;
SVGImageContext
svgContext
;
SVGImageContext
:
:
MaybeStoreContextPaint
(
svgContext
this
aImage
)
;
ImgDrawResult
result
=
nsLayoutUtils
:
:
DrawSingleImage
(
aRenderingContext
PresContext
(
)
aImage
nsLayoutUtils
:
:
GetSamplingFilterForFrame
(
this
)
dest
aDirtyRect
svgContext
aFlags
&
anchorPoint
)
;
if
(
nsImageMap
*
map
=
GetImageMap
(
)
)
{
gfxPoint
devPixelOffset
=
nsLayoutUtils
:
:
PointToGfxPoint
(
dest
.
TopLeft
(
)
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
AutoRestoreTransform
autoRestoreTransform
(
drawTarget
)
;
drawTarget
-
>
SetTransform
(
drawTarget
-
>
GetTransform
(
)
.
PreTranslate
(
ToPoint
(
devPixelOffset
)
)
)
;
ColorPattern
white
(
ToDeviceColor
(
sRGBColor
:
:
OpaqueWhite
(
)
)
)
;
map
-
>
Draw
(
this
*
drawTarget
white
)
;
ColorPattern
black
(
ToDeviceColor
(
sRGBColor
:
:
OpaqueBlack
(
)
)
)
;
StrokeOptions
strokeOptions
;
nsLayoutUtils
:
:
InitDashPattern
(
strokeOptions
StyleBorderStyle
:
:
Dotted
)
;
map
-
>
Draw
(
this
*
drawTarget
black
strokeOptions
)
;
}
if
(
result
=
=
ImgDrawResult
:
:
SUCCESS
)
{
mPrevImage
=
aImage
;
}
else
if
(
result
=
=
ImgDrawResult
:
:
BAD_IMAGE
)
{
mPrevImage
=
nullptr
;
}
return
result
;
}
already_AddRefed
<
imgIRequest
>
nsImageFrame
:
:
GetCurrentRequest
(
)
const
{
if
(
mKind
!
=
Kind
:
:
ImageElement
)
{
return
do_AddRef
(
mContentURLRequest
)
;
}
MOZ_ASSERT
(
!
mContentURLRequest
)
;
nsCOMPtr
<
imgIRequest
>
request
;
nsCOMPtr
<
nsIImageLoadingContent
>
imageLoader
=
do_QueryInterface
(
mContent
)
;
MOZ_ASSERT
(
imageLoader
)
;
imageLoader
-
>
GetRequest
(
nsIImageLoadingContent
:
:
CURRENT_REQUEST
getter_AddRefs
(
request
)
)
;
return
request
.
forget
(
)
;
}
void
nsImageFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
if
(
!
IsVisibleForPainting
(
)
)
{
return
;
}
DisplayBorderBackgroundOutline
(
aBuilder
aLists
)
;
if
(
IsContentHidden
(
)
)
{
DisplaySelectionOverlay
(
aBuilder
aLists
.
Content
(
)
nsISelectionDisplay
:
:
DISPLAY_IMAGES
)
;
return
;
}
uint32_t
clipFlags
=
nsStyleUtil
:
:
ObjectPropsMightCauseOverflow
(
StylePosition
(
)
)
?
0
:
DisplayListClipState
:
:
ASSUME_DRAWING_RESTRICTED_TO_CONTENT_RECT
;
DisplayListClipState
:
:
AutoClipContainingBlockDescendantsToContentBox
clip
(
aBuilder
this
clipFlags
)
;
if
(
mComputedSize
.
width
!
=
0
&
&
mComputedSize
.
height
!
=
0
)
{
bool
imageOK
=
mKind
!
=
Kind
:
:
ImageElement
|
|
ImageOk
(
mContent
-
>
AsElement
(
)
-
>
State
(
)
)
;
nsCOMPtr
<
imgIRequest
>
currentRequest
=
GetCurrentRequest
(
)
;
if
(
(
mKind
=
=
Kind
:
:
ImageElement
|
|
GetImageFromStyle
(
)
-
>
IsImageRequestType
(
)
)
&
&
(
!
imageOK
|
|
!
mImage
|
|
!
SizeIsAvailable
(
currentRequest
)
)
)
{
aLists
.
Content
(
)
-
>
AppendNewToTop
<
nsDisplayAltFeedback
>
(
aBuilder
this
)
;
if
(
currentRequest
)
{
uint32_t
status
=
0
;
currentRequest
-
>
GetImageStatus
(
&
status
)
;
if
(
!
(
status
&
imgIRequest
:
:
STATUS_DECODE_COMPLETE
)
)
{
MaybeDecodeForPredictedSize
(
)
;
}
if
(
!
(
status
&
imgIRequest
:
:
STATUS_LOAD_COMPLETE
)
)
{
currentRequest
-
>
BoostPriority
(
imgIRequest
:
:
CATEGORY_DISPLAY
)
;
}
}
}
else
{
if
(
mImage
)
{
aLists
.
Content
(
)
-
>
AppendNewToTop
<
nsDisplayImage
>
(
aBuilder
this
mImage
mPrevImage
)
;
}
else
if
(
mKind
!
=
Kind
:
:
ImageElement
)
{
aLists
.
Content
(
)
-
>
AppendNewToTop
<
nsDisplayGradient
>
(
aBuilder
this
)
;
}
if
(
mDisplayingIcon
)
{
gIconLoad
-
>
RemoveIconObserver
(
this
)
;
mDisplayingIcon
=
false
;
}
#
ifdef
DEBUG
if
(
GetShowFrameBorders
(
)
&
&
GetImageMap
(
)
)
{
aLists
.
Outlines
(
)
-
>
AppendNewToTop
<
nsDisplayGeneric
>
(
aBuilder
this
PaintDebugImageMap
"
DebugImageMap
"
DisplayItemType
:
:
TYPE_DEBUG_IMAGE_MAP
)
;
}
#
endif
}
}
if
(
ShouldDisplaySelection
(
)
)
{
DisplaySelectionOverlay
(
aBuilder
aLists
.
Content
(
)
nsISelectionDisplay
:
:
DISPLAY_IMAGES
)
;
}
BuildDisplayListForNonBlockChildren
(
aBuilder
aLists
)
;
}
bool
nsImageFrame
:
:
ShouldDisplaySelection
(
)
{
int16_t
displaySelection
=
PresShell
(
)
-
>
GetSelectionFlags
(
)
;
if
(
!
(
displaySelection
&
nsISelectionDisplay
:
:
DISPLAY_IMAGES
)
)
{
return
false
;
}
if
(
displaySelection
!
=
nsISelectionDisplay
:
:
DISPLAY_ALL
)
{
return
true
;
}
HTMLEditor
*
htmlEditor
=
nsContentUtils
:
:
GetHTMLEditor
(
PresContext
(
)
)
;
if
(
!
htmlEditor
)
{
return
true
;
}
return
htmlEditor
-
>
GetResizerTarget
(
)
!
=
mContent
;
}
nsImageMap
*
nsImageFrame
:
:
GetImageMap
(
)
{
if
(
!
mImageMap
)
{
if
(
nsIContent
*
map
=
GetMapElement
(
)
)
{
mImageMap
=
new
nsImageMap
(
)
;
mImageMap
-
>
Init
(
this
map
)
;
}
}
return
mImageMap
;
}
bool
nsImageFrame
:
:
IsServerImageMap
(
)
{
return
mContent
-
>
AsElement
(
)
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
ismap
)
;
}
CSSIntPoint
nsImageFrame
:
:
TranslateEventCoords
(
const
nsPoint
&
aPoint
)
{
const
nsRect
contentRect
=
GetContentRectRelativeToSelf
(
)
;
return
CSSPixel
:
:
FromAppUnitsRounded
(
aPoint
-
contentRect
.
TopLeft
(
)
)
;
}
bool
nsImageFrame
:
:
GetAnchorHREFTargetAndNode
(
nsIURI
*
*
aHref
nsString
&
aTarget
nsIContent
*
*
aNode
)
{
aTarget
.
Truncate
(
)
;
*
aHref
=
nullptr
;
*
aNode
=
nullptr
;
for
(
nsIContent
*
content
=
mContent
-
>
GetParent
(
)
;
content
;
content
=
content
-
>
GetParent
(
)
)
{
nsCOMPtr
<
dom
:
:
Link
>
link
=
do_QueryInterface
(
content
)
;
if
(
!
link
)
{
continue
;
}
if
(
nsCOMPtr
<
nsIURI
>
href
=
link
-
>
GetURI
(
)
)
{
href
.
forget
(
aHref
)
;
}
if
(
auto
*
anchor
=
HTMLAnchorElement
:
:
FromNode
(
content
)
)
{
anchor
-
>
GetTarget
(
aTarget
)
;
}
NS_ADDREF
(
*
aNode
=
content
)
;
return
*
aHref
!
=
nullptr
;
}
return
false
;
}
bool
nsImageFrame
:
:
IsLeafDynamic
(
)
const
{
if
(
mKind
!
=
Kind
:
:
ImageElement
)
{
return
true
;
}
const
auto
*
shadow
=
mContent
-
>
AsElement
(
)
-
>
GetShadowRoot
(
)
;
MOZ_ASSERT_IF
(
shadow
shadow
-
>
IsUAWidget
(
)
)
;
return
!
shadow
;
}
nsresult
nsImageFrame
:
:
GetContentForEvent
(
const
WidgetEvent
*
aEvent
nsIContent
*
*
aContent
)
{
NS_ENSURE_ARG_POINTER
(
aContent
)
;
nsIFrame
*
f
=
nsLayoutUtils
:
:
GetNonGeneratedAncestor
(
this
)
;
if
(
f
!
=
this
)
{
return
f
-
>
GetContentForEvent
(
aEvent
aContent
)
;
}
nsIContent
*
capturingContent
=
aEvent
-
>
HasMouseEventMessage
(
)
?
PresShell
:
:
GetCapturingContent
(
)
:
nullptr
;
if
(
capturingContent
&
&
capturingContent
-
>
GetPrimaryFrame
(
)
=
=
this
)
{
*
aContent
=
capturingContent
;
NS_IF_ADDREF
(
*
aContent
)
;
return
NS_OK
;
}
if
(
nsImageMap
*
map
=
GetImageMap
(
)
)
{
const
CSSIntPoint
p
=
TranslateEventCoords
(
nsLayoutUtils
:
:
GetEventCoordinatesRelativeTo
(
aEvent
RelativeTo
{
this
}
)
)
;
nsCOMPtr
<
nsIContent
>
area
=
map
-
>
GetArea
(
p
)
;
if
(
area
)
{
area
.
forget
(
aContent
)
;
return
NS_OK
;
}
}
*
aContent
=
GetContent
(
)
;
NS_IF_ADDREF
(
*
aContent
)
;
return
NS_OK
;
}
nsresult
nsImageFrame
:
:
HandleEvent
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
{
NS_ENSURE_ARG_POINTER
(
aEventStatus
)
;
if
(
(
aEvent
-
>
mMessage
=
=
eMouseClick
&
&
aEvent
-
>
AsMouseEvent
(
)
-
>
mButton
=
=
MouseButton
:
:
ePrimary
)
|
|
aEvent
-
>
mMessage
=
=
eMouseMove
)
{
nsImageMap
*
map
=
GetImageMap
(
)
;
bool
isServerMap
=
IsServerImageMap
(
)
;
if
(
map
|
|
isServerMap
)
{
CSSIntPoint
p
=
TranslateEventCoords
(
nsLayoutUtils
:
:
GetEventCoordinatesRelativeTo
(
aEvent
RelativeTo
{
this
}
)
)
;
const
bool
inside
=
map
&
&
map
-
>
GetArea
(
p
)
;
if
(
!
inside
&
&
isServerMap
)
{
nsCOMPtr
<
nsIURI
>
uri
;
nsAutoString
target
;
nsCOMPtr
<
nsIContent
>
anchorNode
;
if
(
GetAnchorHREFTargetAndNode
(
getter_AddRefs
(
uri
)
target
getter_AddRefs
(
anchorNode
)
)
)
{
if
(
p
.
x
<
0
)
p
.
x
=
0
;
if
(
p
.
y
<
0
)
p
.
y
=
0
;
nsAutoCString
spec
;
nsresult
rv
=
uri
-
>
GetSpec
(
spec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
spec
+
=
nsPrintfCString
(
"
?
%
d
%
d
"
p
.
x
p
.
y
)
;
rv
=
NS_MutateURI
(
uri
)
.
SetSpec
(
spec
)
.
Finalize
(
uri
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
bool
clicked
=
false
;
if
(
aEvent
-
>
mMessage
=
=
eMouseClick
&
&
!
aEvent
-
>
DefaultPrevented
(
)
)
{
*
aEventStatus
=
nsEventStatus_eConsumeDoDefault
;
clicked
=
true
;
}
nsContentUtils
:
:
TriggerLink
(
anchorNode
uri
target
clicked
true
)
;
}
}
}
}
return
nsAtomicContainerFrame
:
:
HandleEvent
(
aPresContext
aEvent
aEventStatus
)
;
}
Maybe
<
nsIFrame
:
:
Cursor
>
nsImageFrame
:
:
GetCursor
(
const
nsPoint
&
aPoint
)
{
nsImageMap
*
map
=
GetImageMap
(
)
;
if
(
!
map
)
{
return
nsIFrame
:
:
GetCursor
(
aPoint
)
;
}
const
CSSIntPoint
p
=
TranslateEventCoords
(
aPoint
)
;
HTMLAreaElement
*
area
=
map
-
>
GetArea
(
p
)
;
if
(
!
area
)
{
return
nsIFrame
:
:
GetCursor
(
aPoint
)
;
}
RefPtr
<
ComputedStyle
>
areaStyle
=
PresShell
(
)
-
>
StyleSet
(
)
-
>
ResolveStyleLazily
(
*
area
)
;
areaStyle
-
>
StartImageLoads
(
*
PresContext
(
)
-
>
Document
(
)
)
;
StyleCursorKind
kind
=
areaStyle
-
>
StyleUI
(
)
-
>
Cursor
(
)
.
keyword
;
if
(
kind
=
=
StyleCursorKind
:
:
Auto
)
{
kind
=
StyleCursorKind
:
:
Default
;
}
return
Some
(
Cursor
{
kind
AllowCustomCursorImage
:
:
Yes
std
:
:
move
(
areaStyle
)
}
)
;
}
nsresult
nsImageFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
nsresult
rv
=
nsAtomicContainerFrame
:
:
AttributeChanged
(
aNameSpaceID
aAttribute
aModType
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
if
(
nsGkAtoms
:
:
alt
=
=
aAttribute
)
{
PresShell
(
)
-
>
FrameNeedsReflow
(
this
IntrinsicDirty
:
:
StyleChange
NS_FRAME_IS_DIRTY
)
;
}
return
NS_OK
;
}
void
nsImageFrame
:
:
OnVisibilityChange
(
Visibility
aNewVisibility
const
Maybe
<
OnNonvisible
>
&
aNonvisibleAction
)
{
if
(
mKind
=
=
Kind
:
:
ImageElement
)
{
nsCOMPtr
<
nsIImageLoadingContent
>
imageLoader
=
do_QueryInterface
(
mContent
)
;
imageLoader
-
>
OnVisibilityChange
(
aNewVisibility
aNonvisibleAction
)
;
}
if
(
aNewVisibility
=
=
Visibility
:
:
ApproximatelyVisible
&
&
PresShell
(
)
-
>
IsActive
(
)
)
{
MaybeDecodeForPredictedSize
(
)
;
}
nsAtomicContainerFrame
:
:
OnVisibilityChange
(
aNewVisibility
aNonvisibleAction
)
;
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
nsImageFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
u
"
ImageFrame
"
_ns
aResult
)
;
}
void
nsImageFrame
:
:
List
(
FILE
*
out
const
char
*
aPrefix
ListFlags
aFlags
)
const
{
nsCString
str
;
ListGeneric
(
str
aPrefix
aFlags
)
;
if
(
nsCOMPtr
<
imgIRequest
>
currentRequest
=
GetCurrentRequest
(
)
)
{
nsCOMPtr
<
nsIURI
>
uri
;
currentRequest
-
>
GetURI
(
getter_AddRefs
(
uri
)
)
;
nsAutoCString
uristr
;
uri
-
>
GetAsciiSpec
(
uristr
)
;
str
+
=
nsPrintfCString
(
"
[
src
=
%
s
]
"
uristr
.
get
(
)
)
;
}
fprintf_stderr
(
out
"
%
s
\
n
"
str
.
get
(
)
)
;
}
#
endif
LogicalSides
nsImageFrame
:
:
GetLogicalSkipSides
(
)
const
{
LogicalSides
skip
(
mWritingMode
)
;
if
(
MOZ_UNLIKELY
(
StyleBorder
(
)
-
>
mBoxDecorationBreak
=
=
StyleBoxDecorationBreak
:
:
Clone
)
)
{
return
skip
;
}
if
(
GetPrevInFlow
(
)
)
{
skip
|
=
eLogicalSideBitsBStart
;
}
if
(
GetNextInFlow
(
)
)
{
skip
|
=
eLogicalSideBitsBEnd
;
}
return
skip
;
}
nsresult
nsImageFrame
:
:
LoadIcon
(
const
nsAString
&
aSpec
nsPresContext
*
aPresContext
imgRequestProxy
*
*
aRequest
)
{
MOZ_ASSERT
(
!
aSpec
.
IsEmpty
(
)
"
What
happened
?
?
"
)
;
nsCOMPtr
<
nsIURI
>
realURI
;
SpecToURI
(
aSpec
getter_AddRefs
(
realURI
)
)
;
RefPtr
<
imgLoader
>
il
=
nsContentUtils
:
:
GetImgLoaderForDocument
(
aPresContext
-
>
Document
(
)
)
;
nsCOMPtr
<
nsILoadGroup
>
loadGroup
;
GetLoadGroup
(
aPresContext
getter_AddRefs
(
loadGroup
)
)
;
nsLoadFlags
loadFlags
=
nsIRequest
:
:
LOAD_NORMAL
;
nsContentPolicyType
contentPolicyType
=
nsIContentPolicy
:
:
TYPE_INTERNAL_IMAGE
;
return
il
-
>
LoadImage
(
realURI
nullptr
nullptr
nullptr
0
loadGroup
gIconLoad
nullptr
nullptr
loadFlags
nullptr
contentPolicyType
u
"
"
_ns
false
false
aRequest
)
;
}
void
nsImageFrame
:
:
GetDocumentCharacterSet
(
nsACString
&
aCharset
)
const
{
if
(
mContent
)
{
NS_ASSERTION
(
mContent
-
>
GetComposedDoc
(
)
"
Frame
still
alive
after
content
removed
from
document
!
"
)
;
mContent
-
>
GetComposedDoc
(
)
-
>
GetDocumentCharacterSet
(
)
-
>
Name
(
aCharset
)
;
}
}
void
nsImageFrame
:
:
SpecToURI
(
const
nsAString
&
aSpec
nsIURI
*
*
aURI
)
{
nsIURI
*
baseURI
=
nullptr
;
if
(
mContent
)
{
baseURI
=
mContent
-
>
GetBaseURI
(
)
;
}
nsAutoCString
charset
;
GetDocumentCharacterSet
(
charset
)
;
NS_NewURI
(
aURI
aSpec
charset
.
IsEmpty
(
)
?
nullptr
:
charset
.
get
(
)
baseURI
)
;
}
void
nsImageFrame
:
:
GetLoadGroup
(
nsPresContext
*
aPresContext
nsILoadGroup
*
*
aLoadGroup
)
{
if
(
!
aPresContext
)
return
;
MOZ_ASSERT
(
nullptr
!
=
aLoadGroup
"
null
OUT
parameter
pointer
"
)
;
mozilla
:
:
PresShell
*
presShell
=
aPresContext
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
;
}
Document
*
doc
=
presShell
-
>
GetDocument
(
)
;
if
(
!
doc
)
{
return
;
}
*
aLoadGroup
=
doc
-
>
GetDocumentLoadGroup
(
)
.
take
(
)
;
}
nsresult
nsImageFrame
:
:
LoadIcons
(
nsPresContext
*
aPresContext
)
{
NS_ASSERTION
(
!
gIconLoad
"
called
LoadIcons
twice
"
)
;
constexpr
auto
loadingSrc
=
u
"
resource
:
/
/
gre
-
resources
/
loading
-
image
.
png
"
_ns
;
constexpr
auto
brokenSrc
=
u
"
resource
:
/
/
gre
-
resources
/
broken
-
image
.
png
"
_ns
;
gIconLoad
=
new
IconLoad
(
)
;
nsresult
rv
;
rv
=
LoadIcon
(
loadingSrc
aPresContext
getter_AddRefs
(
gIconLoad
-
>
mLoadingImage
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
rv
=
LoadIcon
(
brokenSrc
aPresContext
getter_AddRefs
(
gIconLoad
-
>
mBrokenImage
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
return
rv
;
}
NS_IMPL_ISUPPORTS
(
nsImageFrame
:
:
IconLoad
nsIObserver
imgINotificationObserver
)
static
const
char
*
kIconLoadPrefs
[
]
=
{
"
browser
.
display
.
force_inline_alttext
"
"
browser
.
display
.
show_image_placeholders
"
"
browser
.
display
.
show_loading_image_placeholder
"
nullptr
}
;
nsImageFrame
:
:
IconLoad
:
:
IconLoad
(
)
{
Preferences
:
:
AddStrongObservers
(
this
kIconLoadPrefs
)
;
GetPrefs
(
)
;
}
void
nsImageFrame
:
:
IconLoad
:
:
Shutdown
(
)
{
Preferences
:
:
RemoveObservers
(
this
kIconLoadPrefs
)
;
if
(
mLoadingImage
)
{
mLoadingImage
-
>
CancelAndForgetObserver
(
NS_ERROR_FAILURE
)
;
mLoadingImage
=
nullptr
;
}
if
(
mBrokenImage
)
{
mBrokenImage
-
>
CancelAndForgetObserver
(
NS_ERROR_FAILURE
)
;
mBrokenImage
=
nullptr
;
}
}
NS_IMETHODIMP
nsImageFrame
:
:
IconLoad
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
NS_ASSERTION
(
!
nsCRT
:
:
strcmp
(
aTopic
NS_PREFBRANCH_PREFCHANGE_TOPIC_ID
)
"
wrong
topic
"
)
;
#
ifdef
DEBUG
uint32_t
i
=
0
;
for
(
;
i
<
ArrayLength
(
kIconLoadPrefs
)
;
+
+
i
)
{
if
(
NS_ConvertASCIItoUTF16
(
kIconLoadPrefs
[
i
]
)
=
=
nsDependentString
(
aData
)
)
break
;
}
MOZ_ASSERT
(
i
<
ArrayLength
(
kIconLoadPrefs
)
)
;
#
endif
GetPrefs
(
)
;
return
NS_OK
;
}
void
nsImageFrame
:
:
IconLoad
:
:
GetPrefs
(
)
{
mPrefForceInlineAltText
=
Preferences
:
:
GetBool
(
"
browser
.
display
.
force_inline_alttext
"
)
;
mPrefShowPlaceholders
=
Preferences
:
:
GetBool
(
"
browser
.
display
.
show_image_placeholders
"
true
)
;
mPrefShowLoadingPlaceholder
=
Preferences
:
:
GetBool
(
"
browser
.
display
.
show_loading_image_placeholder
"
true
)
;
}
nsresult
nsImageFrame
:
:
RestartAnimation
(
)
{
nsCOMPtr
<
imgIRequest
>
currentRequest
=
GetCurrentRequest
(
)
;
if
(
currentRequest
)
{
bool
deregister
=
false
;
nsLayoutUtils
:
:
RegisterImageRequestIfAnimated
(
PresContext
(
)
currentRequest
&
deregister
)
;
}
return
NS_OK
;
}
nsresult
nsImageFrame
:
:
StopAnimation
(
)
{
nsCOMPtr
<
imgIRequest
>
currentRequest
=
GetCurrentRequest
(
)
;
if
(
currentRequest
)
{
bool
deregister
=
true
;
nsLayoutUtils
:
:
DeregisterImageRequest
(
PresContext
(
)
currentRequest
&
deregister
)
;
}
return
NS_OK
;
}
void
nsImageFrame
:
:
IconLoad
:
:
Notify
(
imgIRequest
*
aRequest
int32_t
aType
const
nsIntRect
*
aData
)
{
MOZ_ASSERT
(
aRequest
)
;
if
(
aType
!
=
imgINotificationObserver
:
:
LOAD_COMPLETE
&
&
aType
!
=
imgINotificationObserver
:
:
FRAME_UPDATE
)
{
return
;
}
if
(
aType
=
=
imgINotificationObserver
:
:
LOAD_COMPLETE
)
{
nsCOMPtr
<
imgIContainer
>
image
;
aRequest
-
>
GetImage
(
getter_AddRefs
(
image
)
)
;
if
(
!
image
)
{
return
;
}
int32_t
width
=
0
;
int32_t
height
=
0
;
image
-
>
GetWidth
(
&
width
)
;
image
-
>
GetHeight
(
&
height
)
;
image
-
>
RequestDecodeForSize
(
IntSize
(
width
height
)
imgIContainer
:
:
DECODE_FLAGS_DEFAULT
|
imgIContainer
:
:
FLAG_HIGH_QUALITY_SCALING
)
;
}
for
(
nsImageFrame
*
frame
:
mIconObservers
.
ForwardRange
(
)
)
{
frame
-
>
InvalidateFrame
(
)
;
}
}
NS_IMPL_ISUPPORTS
(
nsImageListener
imgINotificationObserver
)
nsImageListener
:
:
nsImageListener
(
nsImageFrame
*
aFrame
)
:
mFrame
(
aFrame
)
{
}
nsImageListener
:
:
~
nsImageListener
(
)
=
default
;
void
nsImageListener
:
:
Notify
(
imgIRequest
*
aRequest
int32_t
aType
const
nsIntRect
*
aData
)
{
if
(
!
mFrame
)
{
return
;
}
return
mFrame
-
>
Notify
(
aRequest
aType
aData
)
;
}
static
bool
IsInAutoWidthTableCellForQuirk
(
nsIFrame
*
aFrame
)
{
if
(
eCompatibility_NavQuirks
!
=
aFrame
-
>
PresContext
(
)
-
>
CompatibilityMode
(
)
)
return
false
;
nsBlockFrame
*
ancestor
=
nsLayoutUtils
:
:
FindNearestBlockAncestor
(
aFrame
)
;
if
(
ancestor
-
>
Style
(
)
-
>
GetPseudoType
(
)
=
=
PseudoStyleType
:
:
cellContent
)
{
nsIFrame
*
grandAncestor
=
static_cast
<
nsIFrame
*
>
(
ancestor
-
>
GetParent
(
)
)
;
return
grandAncestor
&
&
grandAncestor
-
>
StylePosition
(
)
-
>
mWidth
.
IsAuto
(
)
;
}
return
false
;
}
void
nsImageFrame
:
:
AddInlineMinISize
(
gfxContext
*
aRenderingContext
nsIFrame
:
:
InlineMinISizeData
*
aData
)
{
nscoord
isize
=
nsLayoutUtils
:
:
IntrinsicForContainer
(
aRenderingContext
this
IntrinsicISizeType
:
:
MinISize
)
;
bool
canBreak
=
!
IsInAutoWidthTableCellForQuirk
(
this
)
;
aData
-
>
DefaultAddInlineMinISize
(
this
isize
canBreak
)
;
}
