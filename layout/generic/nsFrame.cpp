#
include
"
nsFrame
.
h
"
#
include
<
stdarg
.
h
>
#
include
<
algorithm
>
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
ComputedStyle
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
dom
/
ElementInlines
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
#
include
"
mozilla
/
gfx
/
PathHelpers
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
StaticPrefs
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsFlexContainerFrame
.
h
"
#
include
"
nsFrameList
.
h
"
#
include
"
nsPlaceholderFrame
.
h
"
#
include
"
nsPluginFrame
.
h
"
#
include
"
nsIBaseWindow
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
nsCSSProps
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsCSSRendering
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsTableWrapperFrame
.
h
"
#
include
"
nsView
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
LayoutLogging
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
nsInlineFrame
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsCSSAnonBoxes
.
h
"
#
include
"
nsCSSClipPathInstance
.
h
"
#
include
"
nsFrameTraversal
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsITextControlFrame
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsIPercentBSizeObserver
.
h
"
#
include
"
nsStyleStructInlines
.
h
"
#
include
"
FrameLayerBuilder
.
h
"
#
include
"
ImageLayers
.
h
"
#
include
"
nsBidiPresUtils
.
h
"
#
include
"
RubyUtils
.
h
"
#
include
"
nsAnimationManager
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
imgIRequest
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsBoxLayoutState
.
h
"
#
include
"
nsBlockFrame
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsSVGIntegrationUtils
.
h
"
#
include
"
SVGObserverUtils
.
h
"
#
include
"
nsSVGMaskFrame
.
h
"
#
include
"
nsChangeHint
.
h
"
#
include
"
nsDeckFrame
.
h
"
#
include
"
nsSubDocumentFrame
.
h
"
#
include
"
SVGTextFrame
.
h
"
#
include
"
RetainedDisplayListBuilder
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
nsAbsoluteContainingBlock
.
h
"
#
include
"
StickyScrollContainer
.
h
"
#
include
"
nsFontInflationData
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsStyleChangeList
.
h
"
#
include
"
nsWindowSizes
.
h
"
#
include
"
mozilla
/
AsyncEventDispatcher
.
h
"
#
include
"
mozilla
/
EffectCompositor
.
h
"
#
include
"
mozilla
/
EffectSet
.
h
"
#
include
"
mozilla
/
EventListenerManager
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
mozilla
/
ServoStyleSetInlines
.
h
"
#
include
"
mozilla
/
css
/
ImageLoader
.
h
"
#
include
"
mozilla
/
dom
/
TouchEvent
.
h
"
#
include
"
mozilla
/
gfx
/
Tools
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderUserData
.
h
"
#
include
"
mozilla
/
layout
/
ScrollAnchorContainer
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
ActiveLayerTracker
.
h
"
#
include
"
nsITheme
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
css
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
layout
;
typedef
nsAbsoluteContainingBlock
:
:
AbsPosReflowFlags
AbsPosReflowFlags
;
const
mozilla
:
:
LayoutFrameType
nsIFrame
:
:
sLayoutFrameTypes
[
#
define
FRAME_ID
(
.
.
.
)
1
+
#
define
ABSTRACT_FRAME_ID
(
.
.
.
)
#
include
"
nsFrameIdList
.
h
"
#
undef
FRAME_ID
#
undef
ABSTRACT_FRAME_ID
0
]
=
{
#
define
FRAME_ID
(
class_
type_
.
.
.
)
mozilla
:
:
LayoutFrameType
:
:
type_
#
define
ABSTRACT_FRAME_ID
(
.
.
.
)
#
include
"
nsFrameIdList
.
h
"
#
undef
FRAME_ID
#
undef
ABSTRACT_FRAME_ID
}
;
const
nsIFrame
:
:
FrameClassBits
nsIFrame
:
:
sFrameClassBits
[
#
define
FRAME_ID
(
.
.
.
)
1
+
#
define
ABSTRACT_FRAME_ID
(
.
.
.
)
#
include
"
nsFrameIdList
.
h
"
#
undef
FRAME_ID
#
undef
ABSTRACT_FRAME_ID
0
]
=
{
#
define
Leaf
eFrameClassBitsLeaf
#
define
NotLeaf
eFrameClassBitsNone
#
define
DynamicLeaf
eFrameClassBitsDynamicLeaf
#
define
FRAME_ID
(
class_
type_
leaf_
.
.
.
)
leaf_
#
define
ABSTRACT_FRAME_ID
(
.
.
.
)
#
include
"
nsFrameIdList
.
h
"
#
undef
Leaf
#
undef
NotLeaf
#
undef
DynamicLeaf
#
undef
FRAME_ID
#
undef
ABSTRACT_FRAME_ID
}
;
struct
nsBoxLayoutMetrics
{
nsSize
mPrefSize
;
nsSize
mMinSize
;
nsSize
mMaxSize
;
nsSize
mBlockMinSize
;
nsSize
mBlockPrefSize
;
nscoord
mBlockAscent
;
nscoord
mFlex
;
nscoord
mAscent
;
nsSize
mLastSize
;
}
;
struct
nsContentAndOffset
{
nsIContent
*
mContent
;
int32_t
mOffset
;
}
;
#
define
SELECTION_DEBUG
0
#
define
FORCE_SELECTION_UPDATE
1
#
define
CALC_DEBUG
0
static
bool
IsReversedDirectionFrame
(
nsIFrame
*
aFrame
)
{
FrameBidiData
bidiData
=
aFrame
-
>
GetBidiData
(
)
;
return
!
IS_SAME_DIRECTION
(
bidiData
.
embeddingLevel
bidiData
.
baseLevel
)
;
}
#
include
"
nsILineIterator
.
h
"
#
include
"
prenv
.
h
"
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
BoxMetricsProperty
nsBoxLayoutMetrics
)
static
void
InitBoxMetrics
(
nsIFrame
*
aFrame
bool
aClear
)
{
if
(
aClear
)
{
aFrame
-
>
DeleteProperty
(
BoxMetricsProperty
(
)
)
;
}
nsBoxLayoutMetrics
*
metrics
=
new
nsBoxLayoutMetrics
(
)
;
aFrame
-
>
SetProperty
(
BoxMetricsProperty
(
)
metrics
)
;
static_cast
<
nsFrame
*
>
(
aFrame
)
-
>
nsFrame
:
:
MarkIntrinsicISizesDirty
(
)
;
metrics
-
>
mBlockAscent
=
0
;
metrics
-
>
mLastSize
.
SizeTo
(
0
0
)
;
}
template
<
typename
T
>
static
void
SetOrUpdateRectValuedProperty
(
nsIFrame
*
aFrame
FrameProperties
:
:
Descriptor
<
T
>
aProperty
const
nsRect
&
aNewValue
)
{
bool
found
;
nsRect
*
rectStorage
=
aFrame
-
>
GetProperty
(
aProperty
&
found
)
;
if
(
!
found
)
{
rectStorage
=
new
nsRect
(
aNewValue
)
;
aFrame
-
>
AddProperty
(
aProperty
rectStorage
)
;
}
else
{
*
rectStorage
=
aNewValue
;
}
}
static
bool
IsXULBoxWrapped
(
const
nsIFrame
*
aFrame
)
{
return
aFrame
-
>
GetParent
(
)
&
&
aFrame
-
>
GetParent
(
)
-
>
IsXULBoxFrame
(
)
&
&
!
aFrame
-
>
IsXULBoxFrame
(
)
;
}
void
nsReflowStatus
:
:
UpdateTruncated
(
const
ReflowInput
&
aReflowInput
const
ReflowOutput
&
aMetrics
)
{
const
WritingMode
containerWM
=
aMetrics
.
GetWritingMode
(
)
;
if
(
aReflowInput
.
GetWritingMode
(
)
.
IsOrthogonalTo
(
containerWM
)
)
{
mTruncated
=
false
;
}
else
if
(
aReflowInput
.
AvailableBSize
(
)
!
=
NS_UNCONSTRAINEDSIZE
&
&
aReflowInput
.
AvailableBSize
(
)
<
aMetrics
.
BSize
(
containerWM
)
&
&
!
aReflowInput
.
mFlags
.
mIsTopOfPage
)
{
mTruncated
=
true
;
}
else
{
mTruncated
=
false
;
}
}
void
nsIFrame
:
:
DestroyAnonymousContent
(
nsPresContext
*
aPresContext
already_AddRefed
<
nsIContent
>
&
&
aContent
)
{
if
(
nsCOMPtr
<
nsIContent
>
content
=
aContent
)
{
aPresContext
-
>
EventStateManager
(
)
-
>
NativeAnonymousContentRemoved
(
content
)
;
aPresContext
-
>
PresShell
(
)
-
>
NativeAnonymousContentRemoved
(
content
)
;
content
-
>
UnbindFromTree
(
)
;
}
}
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
nsReflowStatus
&
aStatus
)
{
char
complete
=
'
Y
'
;
if
(
aStatus
.
IsIncomplete
(
)
)
{
complete
=
'
N
'
;
}
else
if
(
aStatus
.
IsOverflowIncomplete
(
)
)
{
complete
=
'
O
'
;
}
char
brk
=
'
N
'
;
if
(
aStatus
.
IsInlineBreakBefore
(
)
)
{
brk
=
'
B
'
;
}
else
if
(
aStatus
.
IsInlineBreakAfter
(
)
)
{
brk
=
'
A
'
;
}
aStream
<
<
"
[
"
<
<
"
Complete
=
"
<
<
complete
<
<
"
"
<
<
"
NIF
=
"
<
<
(
aStatus
.
NextInFlowNeedsReflow
(
)
?
'
Y
'
:
'
N
'
)
<
<
"
"
<
<
"
Truncated
=
"
<
<
(
aStatus
.
IsTruncated
(
)
?
'
Y
'
:
'
N
'
)
<
<
"
"
<
<
"
Break
=
"
<
<
brk
<
<
"
"
<
<
"
FirstLetter
=
"
<
<
(
aStatus
.
FirstLetterComplete
(
)
?
'
Y
'
:
'
N
'
)
<
<
"
]
"
;
return
aStream
;
}
#
ifdef
DEBUG
static
bool
gShowFrameBorders
=
false
;
void
nsFrame
:
:
ShowFrameBorders
(
bool
aEnable
)
{
gShowFrameBorders
=
aEnable
;
}
bool
nsFrame
:
:
GetShowFrameBorders
(
)
{
return
gShowFrameBorders
;
}
static
bool
gShowEventTargetFrameBorder
=
false
;
void
nsFrame
:
:
ShowEventTargetFrameBorder
(
bool
aEnable
)
{
gShowEventTargetFrameBorder
=
aEnable
;
}
bool
nsFrame
:
:
GetShowEventTargetFrameBorder
(
)
{
return
gShowEventTargetFrameBorder
;
}
mozilla
:
:
LazyLogModule
nsFrame
:
:
sFrameLogModule
(
"
frame
"
)
;
#
endif
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
AbsoluteContainingBlockProperty
nsAbsoluteContainingBlock
)
bool
nsIFrame
:
:
HasAbsolutelyPositionedChildren
(
)
const
{
return
IsAbsoluteContainer
(
)
&
&
GetAbsoluteContainingBlock
(
)
-
>
HasAbsoluteFrames
(
)
;
}
nsAbsoluteContainingBlock
*
nsIFrame
:
:
GetAbsoluteContainingBlock
(
)
const
{
NS_ASSERTION
(
IsAbsoluteContainer
(
)
"
The
frame
is
not
marked
as
an
abspos
container
correctly
"
)
;
nsAbsoluteContainingBlock
*
absCB
=
GetProperty
(
AbsoluteContainingBlockProperty
(
)
)
;
NS_ASSERTION
(
absCB
"
The
frame
is
marked
as
an
abspos
container
but
doesn
'
t
have
"
"
the
property
"
)
;
return
absCB
;
}
void
nsIFrame
:
:
MarkAsAbsoluteContainingBlock
(
)
{
MOZ_ASSERT
(
GetStateBits
(
)
&
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
;
NS_ASSERTION
(
!
GetProperty
(
AbsoluteContainingBlockProperty
(
)
)
"
Already
has
an
abs
-
pos
containing
block
property
?
"
)
;
NS_ASSERTION
(
!
HasAnyStateBits
(
NS_FRAME_HAS_ABSPOS_CHILDREN
)
"
Already
has
NS_FRAME_HAS_ABSPOS_CHILDREN
state
bit
?
"
)
;
AddStateBits
(
NS_FRAME_HAS_ABSPOS_CHILDREN
)
;
SetProperty
(
AbsoluteContainingBlockProperty
(
)
new
nsAbsoluteContainingBlock
(
GetAbsoluteListID
(
)
)
)
;
}
void
nsIFrame
:
:
MarkAsNotAbsoluteContainingBlock
(
)
{
NS_ASSERTION
(
!
HasAbsolutelyPositionedChildren
(
)
"
Think
of
the
children
!
"
)
;
NS_ASSERTION
(
GetProperty
(
AbsoluteContainingBlockProperty
(
)
)
"
Should
have
an
abs
-
pos
containing
block
property
"
)
;
NS_ASSERTION
(
HasAnyStateBits
(
NS_FRAME_HAS_ABSPOS_CHILDREN
)
"
Should
have
NS_FRAME_HAS_ABSPOS_CHILDREN
state
bit
"
)
;
MOZ_ASSERT
(
HasAnyStateBits
(
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
)
;
RemoveStateBits
(
NS_FRAME_HAS_ABSPOS_CHILDREN
)
;
DeleteProperty
(
AbsoluteContainingBlockProperty
(
)
)
;
}
bool
nsIFrame
:
:
CheckAndClearPaintedState
(
)
{
bool
result
=
(
GetStateBits
(
)
&
NS_FRAME_PAINTED_THEBES
)
;
RemoveStateBits
(
NS_FRAME_PAINTED_THEBES
)
;
nsIFrame
:
:
ChildListIterator
lists
(
this
)
;
for
(
;
!
lists
.
IsDone
(
)
;
lists
.
Next
(
)
)
{
nsFrameList
:
:
Enumerator
childFrames
(
lists
.
CurrentList
(
)
)
;
for
(
;
!
childFrames
.
AtEnd
(
)
;
childFrames
.
Next
(
)
)
{
nsIFrame
*
child
=
childFrames
.
get
(
)
;
if
(
child
-
>
CheckAndClearPaintedState
(
)
)
{
result
=
true
;
}
}
}
return
result
;
}
bool
nsIFrame
:
:
CheckAndClearDisplayListState
(
)
{
bool
result
=
BuiltDisplayList
(
)
;
SetBuiltDisplayList
(
false
)
;
nsIFrame
:
:
ChildListIterator
lists
(
this
)
;
for
(
;
!
lists
.
IsDone
(
)
;
lists
.
Next
(
)
)
{
nsFrameList
:
:
Enumerator
childFrames
(
lists
.
CurrentList
(
)
)
;
for
(
;
!
childFrames
.
AtEnd
(
)
;
childFrames
.
Next
(
)
)
{
nsIFrame
*
child
=
childFrames
.
get
(
)
;
if
(
child
-
>
CheckAndClearDisplayListState
(
)
)
{
result
=
true
;
}
}
}
return
result
;
}
bool
nsIFrame
:
:
IsVisibleConsideringAncestors
(
uint32_t
aFlags
)
const
{
if
(
!
StyleVisibility
(
)
-
>
IsVisible
(
)
)
{
return
false
;
}
const
nsIFrame
*
frame
=
this
;
while
(
frame
)
{
nsView
*
view
=
frame
-
>
GetView
(
)
;
if
(
view
&
&
view
-
>
GetVisibility
(
)
=
=
nsViewVisibility_kHide
)
return
false
;
nsIFrame
*
parent
=
frame
-
>
GetParent
(
)
;
nsDeckFrame
*
deck
=
do_QueryFrame
(
parent
)
;
if
(
deck
)
{
if
(
deck
-
>
GetSelectedBox
(
)
!
=
frame
)
return
false
;
}
if
(
parent
)
{
frame
=
parent
;
}
else
{
parent
=
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
frame
)
;
if
(
!
parent
)
break
;
if
(
(
aFlags
&
nsIFrame
:
:
VISIBILITY_CROSS_CHROME_CONTENT_BOUNDARY
)
=
=
0
&
&
parent
-
>
PresContext
(
)
-
>
IsChrome
(
)
&
&
!
frame
-
>
PresContext
(
)
-
>
IsChrome
(
)
)
{
break
;
}
if
(
!
parent
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
)
return
false
;
frame
=
parent
;
}
}
return
true
;
}
void
nsIFrame
:
:
FindCloserFrameForSelection
(
const
nsPoint
&
aPoint
FrameWithDistance
*
aCurrentBestFrame
)
{
if
(
nsLayoutUtils
:
:
PointIsCloserToRect
(
aPoint
mRect
aCurrentBestFrame
-
>
mXDistance
aCurrentBestFrame
-
>
mYDistance
)
)
{
aCurrentBestFrame
-
>
mFrame
=
this
;
}
}
void
nsIFrame
:
:
ContentStatesChanged
(
mozilla
:
:
EventStates
aStates
)
{
}
AutoWeakFrame
:
:
AutoWeakFrame
(
const
WeakFrame
&
aOther
)
:
mPrev
(
nullptr
)
mFrame
(
nullptr
)
{
Init
(
aOther
.
GetFrame
(
)
)
;
}
void
AutoWeakFrame
:
:
Init
(
nsIFrame
*
aFrame
)
{
Clear
(
mFrame
?
mFrame
-
>
PresContext
(
)
-
>
GetPresShell
(
)
:
nullptr
)
;
mFrame
=
aFrame
;
if
(
mFrame
)
{
nsIPresShell
*
shell
=
mFrame
-
>
PresContext
(
)
-
>
GetPresShell
(
)
;
NS_WARNING_ASSERTION
(
shell
"
Null
PresShell
in
AutoWeakFrame
!
"
)
;
if
(
shell
)
{
shell
-
>
AddAutoWeakFrame
(
this
)
;
}
else
{
mFrame
=
nullptr
;
}
}
}
void
WeakFrame
:
:
Init
(
nsIFrame
*
aFrame
)
{
Clear
(
mFrame
?
mFrame
-
>
PresContext
(
)
-
>
GetPresShell
(
)
:
nullptr
)
;
mFrame
=
aFrame
;
if
(
mFrame
)
{
nsIPresShell
*
shell
=
mFrame
-
>
PresContext
(
)
-
>
GetPresShell
(
)
;
MOZ_ASSERT
(
shell
"
Null
PresShell
in
WeakFrame
!
"
)
;
if
(
shell
)
{
shell
-
>
AddWeakFrame
(
this
)
;
}
else
{
mFrame
=
nullptr
;
}
}
}
nsIFrame
*
NS_NewEmptyFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
nsFrame
:
:
nsFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
ClassID
aID
)
:
nsBox
(
aStyle
aPresContext
aID
)
{
MOZ_COUNT_CTOR
(
nsFrame
)
;
}
nsFrame
:
:
~
nsFrame
(
)
{
MOZ_COUNT_DTOR
(
nsFrame
)
;
MOZ_ASSERT
(
GetVisibility
(
)
!
=
Visibility
:
:
APPROXIMATELY_VISIBLE
"
Visible
nsFrame
is
being
destroyed
"
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsFrame
)
void
nsFrame
:
:
operator
delete
(
void
*
size_t
)
{
MOZ_CRASH
(
"
nsFrame
:
:
operator
delete
should
never
be
called
"
)
;
}
NS_QUERYFRAME_HEAD
(
nsFrame
)
NS_QUERYFRAME_ENTRY
(
nsIFrame
)
NS_QUERYFRAME_TAIL_INHERITANCE_ROOT
static
bool
IsFontSizeInflationContainer
(
nsIFrame
*
aFrame
const
nsStyleDisplay
*
aStyleDisplay
)
{
if
(
!
aFrame
-
>
GetParent
(
)
)
{
return
true
;
}
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
LayoutFrameType
frameType
=
aFrame
-
>
Type
(
)
;
bool
isInline
=
(
aFrame
-
>
GetDisplay
(
)
=
=
StyleDisplay
:
:
Inline
|
|
RubyUtils
:
:
IsRubyBox
(
frameType
)
|
|
(
aFrame
-
>
IsFloating
(
)
&
&
frameType
=
=
LayoutFrameType
:
:
Letter
)
|
|
(
aFrame
-
>
GetParent
(
)
-
>
GetContent
(
)
=
=
content
)
|
|
(
content
&
&
(
content
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
option
nsGkAtoms
:
:
optgroup
nsGkAtoms
:
:
select
)
|
|
content
-
>
IsInNativeAnonymousSubtree
(
)
)
)
)
&
&
!
(
aFrame
-
>
IsXULBoxFrame
(
)
&
&
aFrame
-
>
GetParent
(
)
-
>
IsXULBoxFrame
(
)
)
;
NS_ASSERTION
(
!
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eLineParticipant
)
|
|
isInline
|
|
aFrame
-
>
IsBrFrame
(
)
|
|
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eMathML
)
"
line
participants
must
not
be
containers
"
)
;
NS_ASSERTION
(
!
aFrame
-
>
IsBulletFrame
(
)
|
|
isInline
"
bullets
should
not
be
containers
"
)
;
return
!
isInline
;
}
void
nsFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
MOZ_ASSERT
(
nsQueryFrame
:
:
FrameIID
(
mClass
)
=
=
GetFrameId
(
)
)
;
MOZ_ASSERT
(
!
mContent
"
Double
-
initing
a
frame
?
"
)
;
NS_ASSERTION
(
IsFrameOfType
(
eDEBUGAllFrames
)
&
&
!
IsFrameOfType
(
eDEBUGNoFrames
)
"
IsFrameOfType
implementation
that
doesn
'
t
call
base
class
"
)
;
mContent
=
aContent
;
mParent
=
aParent
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mParent
|
|
PresShell
(
)
=
=
mParent
-
>
PresShell
(
)
)
;
if
(
aPrevInFlow
)
{
mWritingMode
=
aPrevInFlow
-
>
GetWritingMode
(
)
;
nsFrameState
state
=
aPrevInFlow
-
>
GetStateBits
(
)
;
AddStateBits
(
state
&
(
NS_FRAME_INDEPENDENT_SELECTION
|
NS_FRAME_PART_OF_IBSPLIT
|
NS_FRAME_MAY_BE_TRANSFORMED
|
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
)
;
}
else
{
mComputedStyle
-
>
StartImageLoads
(
*
PresContext
(
)
-
>
Document
(
)
)
;
PresContext
(
)
-
>
ConstructedFrame
(
)
;
}
if
(
GetParent
(
)
)
{
nsFrameState
state
=
GetParent
(
)
-
>
GetStateBits
(
)
;
AddStateBits
(
state
&
(
NS_FRAME_INDEPENDENT_SELECTION
|
NS_FRAME_GENERATED_CONTENT
|
NS_FRAME_IS_SVG_TEXT
|
NS_FRAME_IN_POPUP
|
NS_FRAME_IS_NONDISPLAY
)
)
;
if
(
HasAnyStateBits
(
NS_FRAME_IN_POPUP
)
&
&
TrackingVisibility
(
)
)
{
IncApproximateVisibleCount
(
)
;
}
}
if
(
aPrevInFlow
)
{
mMayHaveOpacityAnimation
=
aPrevInFlow
-
>
MayHaveOpacityAnimation
(
)
;
mMayHaveTransformAnimation
=
aPrevInFlow
-
>
MayHaveTransformAnimation
(
)
;
}
else
if
(
mContent
)
{
EffectSet
*
effectSet
=
EffectSet
:
:
GetEffectSet
(
this
)
;
if
(
effectSet
)
{
mMayHaveOpacityAnimation
=
effectSet
-
>
MayHaveOpacityAnimation
(
)
;
mMayHaveTransformAnimation
=
effectSet
-
>
MayHaveTransformAnimation
(
)
;
}
}
const
nsStyleDisplay
*
disp
=
StyleDisplay
(
)
;
if
(
disp
-
>
HasTransform
(
this
)
|
|
(
IsFrameOfType
(
eSupportsCSSTransforms
)
&
&
nsLayoutUtils
:
:
HasAnimationOfProperty
(
this
eCSSProperty_transform
)
)
)
{
AddStateBits
(
NS_FRAME_MAY_BE_TRANSFORMED
)
;
}
if
(
disp
-
>
mPosition
=
=
NS_STYLE_POSITION_STICKY
&
&
!
aPrevInFlow
&
&
!
(
mState
&
NS_FRAME_IS_NONDISPLAY
)
)
{
StickyScrollContainer
*
ssc
=
StickyScrollContainer
:
:
GetStickyScrollContainerForFrame
(
this
)
;
if
(
ssc
)
{
ssc
-
>
AddFrame
(
this
)
;
}
}
if
(
disp
-
>
IsContainLayout
(
)
&
&
disp
-
>
IsContainSize
(
)
&
&
IsFrameOfType
(
eSupportsContainLayoutAndPaint
)
)
{
AddStateBits
(
NS_FRAME_REFLOW_ROOT
)
;
}
if
(
nsLayoutUtils
:
:
FontSizeInflationEnabled
(
PresContext
(
)
)
|
|
!
GetParent
(
)
#
ifdef
DEBUG
|
|
true
#
endif
)
{
if
(
IsFontSizeInflationContainer
(
this
disp
)
)
{
AddStateBits
(
NS_FRAME_FONT_INFLATION_CONTAINER
)
;
if
(
!
GetParent
(
)
|
|
disp
-
>
IsFloating
(
this
)
|
|
disp
-
>
IsAbsolutelyPositioned
(
this
)
)
{
AddStateBits
(
NS_FRAME_FONT_INFLATION_FLOW_ROOT
)
;
}
}
NS_ASSERTION
(
GetParent
(
)
|
|
(
GetStateBits
(
)
&
NS_FRAME_FONT_INFLATION_CONTAINER
)
"
root
frame
should
always
be
a
container
"
)
;
}
if
(
PresShell
(
)
-
>
AssumeAllFramesVisible
(
)
&
&
TrackingVisibility
(
)
)
{
IncApproximateVisibleCount
(
)
;
}
DidSetComputedStyle
(
nullptr
)
;
if
(
:
:
IsXULBoxWrapped
(
this
)
)
:
:
InitBoxMetrics
(
this
false
)
;
if
(
!
IsPlaceholderFrame
(
)
)
{
UpdateVisibleDescendantsState
(
)
;
}
}
void
nsFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
{
NS_ASSERTION
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
destroy
called
on
frame
while
scripts
not
blocked
"
)
;
NS_ASSERTION
(
!
GetNextSibling
(
)
&
&
!
GetPrevSibling
(
)
"
Frames
should
be
removed
before
destruction
.
"
)
;
NS_ASSERTION
(
aDestructRoot
"
Must
specify
destruct
root
"
)
;
MOZ_ASSERT
(
!
HasAbsolutelyPositionedChildren
(
)
)
;
MOZ_ASSERT
(
!
HasAnyStateBits
(
NS_FRAME_PART_OF_IBSPLIT
)
"
NS_FRAME_PART_OF_IBSPLIT
set
on
non
-
nsContainerFrame
?
"
)
;
SVGObserverUtils
:
:
InvalidateDirectRenderingObservers
(
this
)
;
if
(
StyleDisplay
(
)
-
>
mPosition
=
=
NS_STYLE_POSITION_STICKY
)
{
StickyScrollContainer
*
ssc
=
StickyScrollContainer
:
:
GetStickyScrollContainerForFrame
(
this
)
;
if
(
ssc
)
{
ssc
-
>
RemoveFrame
(
this
)
;
}
}
nsPresContext
*
presContext
=
PresContext
(
)
;
nsIPresShell
*
shell
=
presContext
-
>
GetPresShell
(
)
;
if
(
mState
&
NS_FRAME_OUT_OF_FLOW
)
{
nsPlaceholderFrame
*
placeholder
=
GetPlaceholderFrame
(
)
;
NS_ASSERTION
(
!
placeholder
|
|
(
aDestructRoot
!
=
this
)
"
Don
'
t
call
Destroy
(
)
on
OOFs
call
Destroy
(
)
on
the
placeholder
.
"
)
;
NS_ASSERTION
(
!
placeholder
|
|
nsLayoutUtils
:
:
IsProperAncestorFrame
(
aDestructRoot
placeholder
)
"
Placeholder
relationship
should
have
been
torn
down
already
;
"
"
this
might
mean
we
have
a
stray
placeholder
in
the
tree
.
"
)
;
if
(
placeholder
)
{
placeholder
-
>
SetOutOfFlowFrame
(
nullptr
)
;
}
}
if
(
IsPrimaryFrame
(
)
)
{
ActiveLayerTracker
:
:
TransferActivityToContent
(
this
mContent
)
;
}
ScrollAnchorContainer
*
anchor
=
nullptr
;
if
(
IsScrollAnchor
(
&
anchor
)
)
{
anchor
-
>
InvalidateAnchor
(
)
;
}
if
(
HasCSSAnimations
(
)
|
|
HasCSSTransitions
(
)
|
|
EffectSet
:
:
GetEffectSet
(
this
)
)
{
RestyleManager
:
:
AnimationsWithDestroyedFrame
*
adf
=
presContext
-
>
RestyleManager
(
)
-
>
GetAnimationsWithDestroyedFrame
(
)
;
if
(
adf
)
{
adf
-
>
Put
(
mContent
mComputedStyle
)
;
}
}
DisableVisibilityTracking
(
)
;
PresContext
(
)
-
>
GetPresShell
(
)
-
>
RemoveFrameFromApproximatelyVisibleList
(
this
)
;
shell
-
>
NotifyDestroyingFrame
(
this
)
;
if
(
mState
&
NS_FRAME_EXTERNAL_REFERENCE
)
{
shell
-
>
ClearFrameRefs
(
this
)
;
}
nsView
*
view
=
GetView
(
)
;
if
(
view
)
{
view
-
>
SetFrame
(
nullptr
)
;
view
-
>
Destroy
(
)
;
}
if
(
IsPrimaryFrame
(
)
)
{
mContent
-
>
SetPrimaryFrame
(
nullptr
)
;
if
(
HasAnyStateBits
(
NS_FRAME_GENERATED_CONTENT
)
&
&
mContent
-
>
IsRootOfNativeAnonymousSubtree
(
)
)
{
aPostDestroyData
.
AddAnonymousContent
(
mContent
.
forget
(
)
)
;
}
}
DeleteAllProperties
(
)
;
nsQueryFrame
:
:
FrameIID
id
=
GetFrameId
(
)
;
this
-
>
~
nsFrame
(
)
;
#
ifdef
DEBUG
{
nsIFrame
*
rootFrame
=
shell
-
>
GetRootFrame
(
)
;
MOZ_ASSERT
(
rootFrame
)
;
if
(
this
!
=
rootFrame
)
{
const
RetainedDisplayListData
*
data
=
GetRetainedDisplayListData
(
rootFrame
)
;
const
bool
inModifiedList
=
data
&
&
(
data
-
>
GetFlags
(
this
)
&
RetainedDisplayListData
:
:
FrameFlags
:
:
Modified
)
;
MOZ_ASSERT
(
!
inModifiedList
"
A
dtor
added
this
frame
to
modified
frames
list
!
"
)
;
}
}
#
endif
shell
-
>
FreeFrame
(
id
this
)
;
}
nsresult
nsFrame
:
:
GetOffsets
(
int32_t
&
aStart
int32_t
&
aEnd
)
const
{
aStart
=
0
;
aEnd
=
0
;
return
NS_OK
;
}
static
void
CompareLayers
(
const
nsStyleImageLayers
*
aFirstLayers
const
nsStyleImageLayers
*
aSecondLayers
const
std
:
:
function
<
void
(
imgRequestProxy
*
aReq
)
>
&
aCallback
)
{
NS_FOR_VISIBLE_IMAGE_LAYERS_BACK_TO_FRONT
(
i
(
*
aFirstLayers
)
)
{
const
nsStyleImage
&
image
=
aFirstLayers
-
>
mLayers
[
i
]
.
mImage
;
if
(
image
.
GetType
(
)
!
=
eStyleImageType_Image
|
|
!
image
.
IsResolved
(
)
)
{
continue
;
}
if
(
!
aSecondLayers
|
|
i
>
=
aSecondLayers
-
>
mImageCount
|
|
(
!
aSecondLayers
-
>
mLayers
[
i
]
.
mImage
.
IsResolved
(
)
|
|
!
image
.
ImageDataEquals
(
aSecondLayers
-
>
mLayers
[
i
]
.
mImage
)
)
)
{
if
(
imgRequestProxy
*
req
=
image
.
GetImageData
(
)
)
{
aCallback
(
req
)
;
}
}
}
}
static
void
AddAndRemoveImageAssociations
(
nsFrame
*
aFrame
const
nsStyleImageLayers
*
aOldLayers
const
nsStyleImageLayers
*
aNewLayers
)
{
ImageLoader
*
imageLoader
=
aFrame
-
>
PresContext
(
)
-
>
Document
(
)
-
>
StyleImageLoader
(
)
;
if
(
aOldLayers
&
&
aFrame
-
>
HasImageRequest
(
)
)
{
CompareLayers
(
aOldLayers
aNewLayers
[
&
imageLoader
aFrame
]
(
imgRequestProxy
*
aReq
)
{
imageLoader
-
>
DisassociateRequestFromFrame
(
aReq
aFrame
)
;
}
)
;
}
CompareLayers
(
aNewLayers
aOldLayers
[
&
imageLoader
aFrame
]
(
imgRequestProxy
*
aReq
)
{
imageLoader
-
>
AssociateRequestToFrame
(
aReq
aFrame
0
)
;
}
)
;
}
void
nsIFrame
:
:
AddDisplayItem
(
nsDisplayItem
*
aItem
)
{
DisplayItemArray
*
items
=
GetProperty
(
DisplayItems
(
)
)
;
if
(
!
items
)
{
items
=
new
DisplayItemArray
(
)
;
AddProperty
(
DisplayItems
(
)
items
)
;
}
MOZ_DIAGNOSTIC_ASSERT
(
!
items
-
>
Contains
(
aItem
)
)
;
items
-
>
AppendElement
(
aItem
)
;
}
bool
nsIFrame
:
:
RemoveDisplayItem
(
nsDisplayItem
*
aItem
)
{
DisplayItemArray
*
items
=
GetProperty
(
DisplayItems
(
)
)
;
if
(
!
items
)
{
return
false
;
}
bool
result
=
items
-
>
RemoveElement
(
aItem
)
;
if
(
items
-
>
IsEmpty
(
)
)
{
DeleteProperty
(
DisplayItems
(
)
)
;
}
return
result
;
}
bool
nsIFrame
:
:
HasDisplayItems
(
)
{
DisplayItemArray
*
items
=
GetProperty
(
DisplayItems
(
)
)
;
return
items
!
=
nullptr
;
}
bool
nsIFrame
:
:
HasDisplayItem
(
nsDisplayItem
*
aItem
)
{
DisplayItemArray
*
items
=
GetProperty
(
DisplayItems
(
)
)
;
if
(
!
items
)
{
return
false
;
}
return
items
-
>
Contains
(
aItem
)
;
}
void
nsIFrame
:
:
RemoveDisplayItemDataForDeletion
(
)
{
FrameLayerBuilder
:
:
RemoveFrameFromLayerManager
(
this
DisplayItemData
(
)
)
;
DisplayItemData
(
)
.
Clear
(
)
;
DisplayItemArray
*
items
=
RemoveProperty
(
DisplayItems
(
)
)
;
if
(
items
)
{
for
(
nsDisplayItem
*
i
:
*
items
)
{
if
(
i
-
>
GetDependentFrame
(
)
=
=
this
&
&
!
i
-
>
HasDeletedFrame
(
)
)
{
i
-
>
Frame
(
)
-
>
MarkNeedsDisplayItemRebuild
(
)
;
}
i
-
>
RemoveFrame
(
this
)
;
}
delete
items
;
}
if
(
!
nsLayoutUtils
:
:
AreRetainedDisplayListsEnabled
(
)
)
{
return
;
}
const
bool
updateData
=
IsFrameModified
(
)
|
|
HasOverrideDirtyRegion
(
)
|
|
MayHaveWillChangeBudget
(
)
;
if
(
!
updateData
)
{
return
;
}
nsIFrame
*
rootFrame
=
PresShell
(
)
-
>
GetRootFrame
(
)
;
MOZ_ASSERT
(
rootFrame
)
;
RetainedDisplayListData
*
data
=
GetOrSetRetainedDisplayListData
(
rootFrame
)
;
if
(
MayHaveWillChangeBudget
(
)
)
{
data
-
>
Flags
(
this
)
=
RetainedDisplayListData
:
:
FrameFlags
:
:
HadWillChange
;
return
;
}
if
(
IsFrameModified
(
)
|
|
HasOverrideDirtyRegion
(
)
)
{
DebugOnly
<
bool
>
removed
=
data
-
>
Remove
(
this
)
;
MOZ_ASSERT
(
removed
"
Frame
had
flags
set
but
it
was
not
found
in
DisplayListData
!
"
)
;
}
}
void
nsIFrame
:
:
MarkNeedsDisplayItemRebuild
(
)
{
if
(
!
nsLayoutUtils
:
:
AreRetainedDisplayListsEnabled
(
)
|
|
IsFrameModified
(
)
|
|
HasAnyStateBits
(
NS_FRAME_IN_POPUP
)
)
{
return
;
}
if
(
Type
(
)
=
=
LayoutFrameType
:
:
Placeholder
)
{
nsIFrame
*
oof
=
static_cast
<
nsPlaceholderFrame
*
>
(
this
)
-
>
GetOutOfFlowFrame
(
)
;
if
(
oof
)
{
oof
-
>
MarkNeedsDisplayItemRebuild
(
)
;
}
return
;
}
if
(
!
nsLayoutUtils
:
:
DisplayRootHasRetainedDisplayListBuilder
(
this
)
)
{
return
;
}
nsIFrame
*
rootFrame
=
PresShell
(
)
-
>
GetRootFrame
(
)
;
MOZ_ASSERT
(
rootFrame
)
;
if
(
rootFrame
-
>
IsFrameModified
(
)
)
{
return
;
}
RetainedDisplayListData
*
data
=
GetOrSetRetainedDisplayListData
(
rootFrame
)
;
if
(
data
-
>
ModifiedFramesCount
(
)
>
gfxPrefs
:
:
LayoutRebuildFrameLimit
(
)
)
{
data
-
>
AddModifiedFrame
(
rootFrame
)
;
rootFrame
-
>
SetFrameIsModified
(
true
)
;
return
;
}
data
-
>
AddModifiedFrame
(
this
)
;
SetFrameIsModified
(
true
)
;
MOZ_ASSERT
(
PresContext
(
)
-
>
LayoutPhaseCount
(
eLayoutPhase_DisplayListBuilding
)
=
=
0
)
;
DisplayItemArray
*
items
=
GetProperty
(
DisplayItems
(
)
)
;
if
(
items
)
{
for
(
nsDisplayItem
*
i
:
*
items
)
{
if
(
i
-
>
HasDeletedFrame
(
)
|
|
i
-
>
Frame
(
)
=
=
this
)
{
continue
;
}
if
(
i
-
>
GetDependentFrame
(
)
=
=
this
)
{
i
-
>
Frame
(
)
-
>
MarkNeedsDisplayItemRebuild
(
)
;
}
}
}
}
void
nsFrame
:
:
DidSetComputedStyle
(
ComputedStyle
*
aOldComputedStyle
)
{
if
(
nsSVGUtils
:
:
IsInSVGTextSubtree
(
this
)
)
{
SVGTextFrame
*
svgTextFrame
=
static_cast
<
SVGTextFrame
*
>
(
nsLayoutUtils
:
:
GetClosestFrameOfType
(
this
LayoutFrameType
:
:
SVGText
)
)
;
nsIFrame
*
anonBlock
=
svgTextFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
anonBlock
&
&
!
(
anonBlock
-
>
GetStateBits
(
)
&
NS_FRAME_FIRST_REFLOW
)
&
&
(
svgTextFrame
-
>
GetStateBits
(
)
&
NS_FRAME_IS_NONDISPLAY
)
&
&
!
(
svgTextFrame
-
>
GetStateBits
(
)
&
NS_STATE_SVG_TEXT_IN_REFLOW
)
)
{
svgTextFrame
-
>
ScheduleReflowSVGNonDisplayText
(
nsIPresShell
:
:
eStyleChange
)
;
}
}
const
nsStyleImageLayers
*
oldLayers
=
aOldComputedStyle
?
&
aOldComputedStyle
-
>
StyleBackground
(
)
-
>
mImage
:
nullptr
;
const
nsStyleImageLayers
*
newLayers
=
&
StyleBackground
(
)
-
>
mImage
;
AddAndRemoveImageAssociations
(
this
oldLayers
newLayers
)
;
oldLayers
=
aOldComputedStyle
?
&
aOldComputedStyle
-
>
StyleSVGReset
(
)
-
>
mMask
:
nullptr
;
newLayers
=
&
StyleSVGReset
(
)
-
>
mMask
;
AddAndRemoveImageAssociations
(
this
oldLayers
newLayers
)
;
if
(
aOldComputedStyle
)
{
bool
needAnchorSuppression
=
false
;
nsMargin
oldValue
(
0
0
0
0
)
;
nsMargin
newValue
(
0
0
0
0
)
;
const
nsStyleMargin
*
oldMargin
=
aOldComputedStyle
-
>
StyleMargin
(
)
;
if
(
oldMargin
-
>
GetMargin
(
oldValue
)
)
{
if
(
!
StyleMargin
(
)
-
>
GetMargin
(
newValue
)
|
|
oldValue
!
=
newValue
)
{
if
(
!
HasProperty
(
UsedMarginProperty
(
)
)
)
{
AddProperty
(
UsedMarginProperty
(
)
new
nsMargin
(
oldValue
)
)
;
}
needAnchorSuppression
=
true
;
}
}
const
nsStylePadding
*
oldPadding
=
aOldComputedStyle
-
>
StylePadding
(
)
;
if
(
oldPadding
-
>
GetPadding
(
oldValue
)
)
{
if
(
!
StylePadding
(
)
-
>
GetPadding
(
newValue
)
|
|
oldValue
!
=
newValue
)
{
if
(
!
HasProperty
(
UsedPaddingProperty
(
)
)
)
{
AddProperty
(
UsedPaddingProperty
(
)
new
nsMargin
(
oldValue
)
)
;
}
needAnchorSuppression
=
true
;
}
}
const
nsStyleBorder
*
oldBorder
=
aOldComputedStyle
-
>
StyleBorder
(
)
;
oldValue
=
oldBorder
-
>
GetComputedBorder
(
)
;
newValue
=
StyleBorder
(
)
-
>
GetComputedBorder
(
)
;
if
(
oldValue
!
=
newValue
&
&
!
HasProperty
(
UsedBorderProperty
(
)
)
)
{
AddProperty
(
UsedBorderProperty
(
)
new
nsMargin
(
oldValue
)
)
;
}
const
nsStyleDisplay
*
oldDisp
=
aOldComputedStyle
-
>
StyleDisplay
(
)
;
if
(
oldDisp
-
>
mOverflowAnchor
!
=
StyleDisplay
(
)
-
>
mOverflowAnchor
)
{
if
(
auto
*
container
=
ScrollAnchorContainer
:
:
FindFor
(
this
)
)
{
container
-
>
InvalidateAnchor
(
)
;
}
if
(
nsIScrollableFrame
*
scrollableFrame
=
do_QueryFrame
(
this
)
)
{
scrollableFrame
-
>
Anchor
(
)
-
>
InvalidateAnchor
(
)
;
}
}
if
(
mInScrollAnchorChain
)
{
const
nsStylePosition
*
oldPosition
=
aOldComputedStyle
-
>
StylePosition
(
)
;
if
(
oldPosition
-
>
mOffset
!
=
StylePosition
(
)
-
>
mOffset
|
|
oldPosition
-
>
mWidth
!
=
StylePosition
(
)
-
>
mWidth
|
|
oldPosition
-
>
mMinWidth
!
=
StylePosition
(
)
-
>
mMinWidth
|
|
oldPosition
-
>
mMaxWidth
!
=
StylePosition
(
)
-
>
mMaxWidth
|
|
oldPosition
-
>
mHeight
!
=
StylePosition
(
)
-
>
mHeight
|
|
oldPosition
-
>
mMinHeight
!
=
StylePosition
(
)
-
>
mMinHeight
|
|
oldPosition
-
>
mMaxHeight
!
=
StylePosition
(
)
-
>
mMaxHeight
)
{
needAnchorSuppression
=
true
;
}
if
(
oldDisp
-
>
mPosition
!
=
StyleDisplay
(
)
-
>
mPosition
|
|
oldDisp
-
>
TransformChanged
(
*
StyleDisplay
(
)
)
)
{
needAnchorSuppression
=
true
;
}
}
if
(
mInScrollAnchorChain
&
&
needAnchorSuppression
)
{
ScrollAnchorContainer
:
:
FindFor
(
this
)
-
>
SuppressAdjustments
(
)
;
}
}
ImageLoader
*
imageLoader
=
PresContext
(
)
-
>
Document
(
)
-
>
StyleImageLoader
(
)
;
imgIRequest
*
oldBorderImage
=
aOldComputedStyle
?
aOldComputedStyle
-
>
StyleBorder
(
)
-
>
GetBorderImageRequest
(
)
:
nullptr
;
imgIRequest
*
newBorderImage
=
StyleBorder
(
)
-
>
GetBorderImageRequest
(
)
;
if
(
oldBorderImage
!
=
newBorderImage
)
{
if
(
oldBorderImage
&
&
HasImageRequest
(
)
)
{
imageLoader
-
>
DisassociateRequestFromFrame
(
oldBorderImage
this
)
;
}
if
(
newBorderImage
)
{
imageLoader
-
>
AssociateRequestToFrame
(
newBorderImage
this
0
)
;
}
}
imgIRequest
*
oldShapeImage
=
aOldComputedStyle
?
aOldComputedStyle
-
>
StyleDisplay
(
)
-
>
mShapeOutside
.
GetShapeImageData
(
)
:
nullptr
;
imgIRequest
*
newShapeImage
=
StyleDisplay
(
)
-
>
mShapeOutside
.
GetShapeImageData
(
)
;
if
(
oldShapeImage
!
=
newShapeImage
)
{
if
(
oldShapeImage
&
&
HasImageRequest
(
)
)
{
imageLoader
-
>
DisassociateRequestFromFrame
(
oldShapeImage
this
)
;
}
if
(
newShapeImage
)
{
imageLoader
-
>
AssociateRequestToFrame
(
newShapeImage
this
ImageLoader
:
:
REQUEST_REQUIRES_REFLOW
)
;
}
}
if
(
!
IsTextFrame
(
)
&
&
!
GetPrevContinuation
(
)
)
{
SVGObserverUtils
:
:
InitiateResourceDocLoads
(
this
)
;
}
if
(
StyleVisibility
(
)
-
>
mDirection
=
=
NS_STYLE_DIRECTION_RTL
)
{
PresContext
(
)
-
>
SetBidiEnabled
(
)
;
}
RemoveStateBits
(
NS_FRAME_SIMPLE_EVENT_REGIONS
|
NS_FRAME_SIMPLE_DISPLAYLIST
)
;
mMayHaveRoundedCorners
=
true
;
}
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
void
nsIFrame
:
:
AssertNewStyleIsSane
(
ComputedStyle
&
aNewStyle
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aNewStyle
.
GetPseudo
(
)
=
=
mComputedStyle
-
>
GetPseudo
(
)
|
|
(
mComputedStyle
-
>
GetPseudo
(
)
=
=
nsCSSPseudoElements
:
:
firstLine
(
)
&
&
aNewStyle
.
GetPseudo
(
)
=
=
nsCSSAnonBoxes
:
:
mozLineFrame
(
)
)
|
|
(
mComputedStyle
-
>
GetPseudo
(
)
=
=
nsCSSAnonBoxes
:
:
mozText
(
)
&
&
aNewStyle
.
GetPseudo
(
)
=
=
nsCSSAnonBoxes
:
:
firstLetterContinuation
(
)
)
|
|
(
mComputedStyle
-
>
GetPseudo
(
)
=
=
nsCSSAnonBoxes
:
:
firstLetterContinuation
(
)
&
&
aNewStyle
.
GetPseudo
(
)
=
=
nsCSSAnonBoxes
:
:
mozText
(
)
)
)
;
}
#
endif
void
nsIFrame
:
:
ReparentFrameViewTo
(
nsViewManager
*
aViewManager
nsView
*
aNewParentView
nsView
*
aOldParentView
)
{
if
(
HasView
(
)
)
{
#
ifdef
MOZ_XUL
if
(
IsMenuPopupFrame
(
)
)
{
return
;
}
#
endif
nsView
*
view
=
GetView
(
)
;
aViewManager
-
>
RemoveChild
(
view
)
;
nsView
*
insertBefore
=
nsLayoutUtils
:
:
FindSiblingViewFor
(
aNewParentView
this
)
;
aViewManager
-
>
InsertChild
(
aNewParentView
view
insertBefore
insertBefore
!
=
nullptr
)
;
}
else
if
(
GetStateBits
(
)
&
NS_FRAME_HAS_CHILD_WITH_VIEW
)
{
nsIFrame
:
:
ChildListIterator
lists
(
this
)
;
for
(
;
!
lists
.
IsDone
(
)
;
lists
.
Next
(
)
)
{
nsFrameList
:
:
Enumerator
childFrames
(
lists
.
CurrentList
(
)
)
;
for
(
;
!
childFrames
.
AtEnd
(
)
;
childFrames
.
Next
(
)
)
{
childFrames
.
get
(
)
-
>
ReparentFrameViewTo
(
aViewManager
aNewParentView
aOldParentView
)
;
}
}
}
}
void
nsIFrame
:
:
SyncFrameViewProperties
(
nsView
*
aView
)
{
if
(
!
aView
)
{
aView
=
GetView
(
)
;
if
(
!
aView
)
{
return
;
}
}
nsViewManager
*
vm
=
aView
-
>
GetViewManager
(
)
;
if
(
!
SupportsVisibilityHidden
(
)
)
{
ComputedStyle
*
sc
=
Style
(
)
;
vm
-
>
SetViewVisibility
(
aView
sc
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
?
nsViewVisibility_kShow
:
nsViewVisibility_kHide
)
;
}
int32_t
zIndex
=
0
;
bool
autoZIndex
=
false
;
if
(
IsAbsPosContainingBlock
(
)
)
{
ComputedStyle
*
sc
=
Style
(
)
;
const
nsStylePosition
*
position
=
sc
-
>
StylePosition
(
)
;
if
(
position
-
>
mZIndex
.
GetUnit
(
)
=
=
eStyleUnit_Integer
)
{
zIndex
=
position
-
>
mZIndex
.
GetIntValue
(
)
;
}
else
if
(
position
-
>
mZIndex
.
GetUnit
(
)
=
=
eStyleUnit_Auto
)
{
autoZIndex
=
true
;
}
}
else
{
autoZIndex
=
true
;
}
vm
-
>
SetViewZIndex
(
aView
autoZIndex
zIndex
)
;
}
void
nsFrame
:
:
CreateView
(
)
{
MOZ_ASSERT
(
!
HasView
(
)
)
;
nsView
*
parentView
=
GetParent
(
)
-
>
GetClosestView
(
)
;
MOZ_ASSERT
(
parentView
"
no
parent
with
view
"
)
;
nsViewManager
*
viewManager
=
parentView
-
>
GetViewManager
(
)
;
MOZ_ASSERT
(
viewManager
"
null
view
manager
"
)
;
nsView
*
view
=
viewManager
-
>
CreateView
(
GetRect
(
)
parentView
)
;
SyncFrameViewProperties
(
view
)
;
nsView
*
insertBefore
=
nsLayoutUtils
:
:
FindSiblingViewFor
(
parentView
this
)
;
viewManager
-
>
InsertChild
(
parentView
view
insertBefore
insertBefore
!
=
nullptr
)
;
ReparentFrameViewTo
(
viewManager
view
parentView
)
;
SetView
(
view
)
;
NS_FRAME_LOG
(
NS_FRAME_TRACE_CALLS
(
"
nsFrame
:
:
CreateView
:
frame
=
%
p
view
=
%
p
"
this
view
)
)
;
}
#
ifndef
_MSC_VER
const
nsIFrame
:
:
ChildListID
nsIFrame
:
:
kPrincipalList
;
const
nsIFrame
:
:
ChildListID
nsIFrame
:
:
kAbsoluteList
;
const
nsIFrame
:
:
ChildListID
nsIFrame
:
:
kBulletList
;
const
nsIFrame
:
:
ChildListID
nsIFrame
:
:
kCaptionList
;
const
nsIFrame
:
:
ChildListID
nsIFrame
:
:
kColGroupList
;
const
nsIFrame
:
:
ChildListID
nsIFrame
:
:
kExcessOverflowContainersList
;
const
nsIFrame
:
:
ChildListID
nsIFrame
:
:
kFixedList
;
const
nsIFrame
:
:
ChildListID
nsIFrame
:
:
kFloatList
;
const
nsIFrame
:
:
ChildListID
nsIFrame
:
:
kOverflowContainersList
;
const
nsIFrame
:
:
ChildListID
nsIFrame
:
:
kOverflowList
;
const
nsIFrame
:
:
ChildListID
nsIFrame
:
:
kOverflowOutOfFlowList
;
const
nsIFrame
:
:
ChildListID
nsIFrame
:
:
kPopupList
;
const
nsIFrame
:
:
ChildListID
nsIFrame
:
:
kPushedFloatsList
;
const
nsIFrame
:
:
ChildListID
nsIFrame
:
:
kSelectPopupList
;
const
nsIFrame
:
:
ChildListID
nsIFrame
:
:
kNoReflowPrincipalList
;
#
endif
nsMargin
nsIFrame
:
:
GetUsedMargin
(
)
const
{
nsMargin
margin
(
0
0
0
0
)
;
if
(
(
(
mState
&
NS_FRAME_FIRST_REFLOW
)
&
&
!
(
mState
&
NS_FRAME_IN_REFLOW
)
)
|
|
nsSVGUtils
:
:
IsInSVGTextSubtree
(
this
)
)
return
margin
;
nsMargin
*
m
=
GetProperty
(
UsedMarginProperty
(
)
)
;
if
(
m
)
{
margin
=
*
m
;
}
else
{
if
(
!
StyleMargin
(
)
-
>
GetMargin
(
margin
)
)
{
NS_ERROR
(
"
Returning
bogus
0
-
sized
margin
because
this
margin
"
"
depends
on
layout
&
isn
'
t
cached
!
"
)
;
}
}
return
margin
;
}
nsMargin
nsIFrame
:
:
GetUsedBorder
(
)
const
{
nsMargin
border
(
0
0
0
0
)
;
if
(
(
(
mState
&
NS_FRAME_FIRST_REFLOW
)
&
&
!
(
mState
&
NS_FRAME_IN_REFLOW
)
)
|
|
nsSVGUtils
:
:
IsInSVGTextSubtree
(
this
)
)
return
border
;
nsIFrame
*
mutable_this
=
const_cast
<
nsIFrame
*
>
(
this
)
;
const
nsStyleDisplay
*
disp
=
StyleDisplay
(
)
;
if
(
mutable_this
-
>
IsThemed
(
disp
)
)
{
nsPresContext
*
pc
=
PresContext
(
)
;
LayoutDeviceIntMargin
widgetBorder
=
pc
-
>
GetTheme
(
)
-
>
GetWidgetBorder
(
pc
-
>
DeviceContext
(
)
mutable_this
disp
-
>
mAppearance
)
;
border
=
LayoutDevicePixel
:
:
ToAppUnits
(
widgetBorder
pc
-
>
AppUnitsPerDevPixel
(
)
)
;
return
border
;
}
nsMargin
*
b
=
GetProperty
(
UsedBorderProperty
(
)
)
;
if
(
b
)
{
border
=
*
b
;
}
else
{
border
=
StyleBorder
(
)
-
>
GetComputedBorder
(
)
;
}
return
border
;
}
nsMargin
nsIFrame
:
:
GetUsedPadding
(
)
const
{
nsMargin
padding
(
0
0
0
0
)
;
if
(
(
(
mState
&
NS_FRAME_FIRST_REFLOW
)
&
&
!
(
mState
&
NS_FRAME_IN_REFLOW
)
)
|
|
nsSVGUtils
:
:
IsInSVGTextSubtree
(
this
)
)
return
padding
;
nsIFrame
*
mutable_this
=
const_cast
<
nsIFrame
*
>
(
this
)
;
const
nsStyleDisplay
*
disp
=
StyleDisplay
(
)
;
if
(
mutable_this
-
>
IsThemed
(
disp
)
)
{
nsPresContext
*
pc
=
PresContext
(
)
;
LayoutDeviceIntMargin
widgetPadding
;
if
(
pc
-
>
GetTheme
(
)
-
>
GetWidgetPadding
(
pc
-
>
DeviceContext
(
)
mutable_this
disp
-
>
mAppearance
&
widgetPadding
)
)
{
return
LayoutDevicePixel
:
:
ToAppUnits
(
widgetPadding
pc
-
>
AppUnitsPerDevPixel
(
)
)
;
}
}
nsMargin
*
p
=
GetProperty
(
UsedPaddingProperty
(
)
)
;
if
(
p
)
{
padding
=
*
p
;
}
else
{
if
(
!
StylePadding
(
)
-
>
GetPadding
(
padding
)
)
{
NS_ERROR
(
"
Returning
bogus
0
-
sized
padding
because
this
padding
"
"
depends
on
layout
&
isn
'
t
cached
!
"
)
;
}
}
return
padding
;
}
nsIFrame
:
:
Sides
nsIFrame
:
:
GetSkipSides
(
const
ReflowInput
*
aReflowInput
)
const
{
if
(
MOZ_UNLIKELY
(
StyleBorder
(
)
-
>
mBoxDecorationBreak
=
=
StyleBoxDecorationBreak
:
:
Clone
)
&
&
!
(
GetStateBits
(
)
&
NS_FRAME_IS_OVERFLOW_CONTAINER
)
)
{
return
Sides
(
)
;
}
WritingMode
writingMode
=
GetWritingMode
(
)
;
LogicalSides
logicalSkip
=
GetLogicalSkipSides
(
aReflowInput
)
;
Sides
skip
;
if
(
logicalSkip
.
BStart
(
)
)
{
if
(
writingMode
.
IsVertical
(
)
)
{
skip
|
=
writingMode
.
IsVerticalLR
(
)
?
eSideBitsLeft
:
eSideBitsRight
;
}
else
{
skip
|
=
eSideBitsTop
;
}
}
if
(
logicalSkip
.
BEnd
(
)
)
{
if
(
writingMode
.
IsVertical
(
)
)
{
skip
|
=
writingMode
.
IsVerticalLR
(
)
?
eSideBitsRight
:
eSideBitsLeft
;
}
else
{
skip
|
=
eSideBitsBottom
;
}
}
if
(
logicalSkip
.
IStart
(
)
)
{
if
(
writingMode
.
IsVertical
(
)
)
{
skip
|
=
eSideBitsTop
;
}
else
{
skip
|
=
writingMode
.
IsBidiLTR
(
)
?
eSideBitsLeft
:
eSideBitsRight
;
}
}
if
(
logicalSkip
.
IEnd
(
)
)
{
if
(
writingMode
.
IsVertical
(
)
)
{
skip
|
=
eSideBitsBottom
;
}
else
{
skip
|
=
writingMode
.
IsBidiLTR
(
)
?
eSideBitsRight
:
eSideBitsLeft
;
}
}
return
skip
;
}
nsRect
nsIFrame
:
:
GetPaddingRectRelativeToSelf
(
)
const
{
nsMargin
border
(
GetUsedBorder
(
)
)
;
border
.
ApplySkipSides
(
GetSkipSides
(
)
)
;
nsRect
r
(
0
0
mRect
.
width
mRect
.
height
)
;
r
.
Deflate
(
border
)
;
return
r
;
}
nsRect
nsIFrame
:
:
GetPaddingRect
(
)
const
{
return
GetPaddingRectRelativeToSelf
(
)
+
GetPosition
(
)
;
}
WritingMode
nsIFrame
:
:
WritingModeForLine
(
WritingMode
aSelfWM
nsIFrame
*
aSubFrame
)
const
{
MOZ_ASSERT
(
aSelfWM
=
=
GetWritingMode
(
)
)
;
WritingMode
writingMode
=
aSelfWM
;
if
(
StyleTextReset
(
)
-
>
mUnicodeBidi
&
NS_STYLE_UNICODE_BIDI_PLAINTEXT
)
{
nsBidiLevel
frameLevel
=
nsBidiPresUtils
:
:
GetFrameBaseLevel
(
aSubFrame
)
;
writingMode
.
SetDirectionFromBidiLevel
(
frameLevel
)
;
}
return
writingMode
;
}
nsRect
nsIFrame
:
:
GetMarginRectRelativeToSelf
(
)
const
{
nsMargin
m
=
GetUsedMargin
(
)
;
m
.
ApplySkipSides
(
GetSkipSides
(
)
)
;
nsRect
r
(
0
0
mRect
.
width
mRect
.
height
)
;
r
.
Inflate
(
m
)
;
return
r
;
}
bool
nsIFrame
:
:
IsTransformed
(
const
nsStyleDisplay
*
aStyleDisplay
)
const
{
return
IsCSSTransformed
(
aStyleDisplay
)
|
|
IsSVGTransformed
(
)
;
}
bool
nsIFrame
:
:
IsCSSTransformed
(
const
nsStyleDisplay
*
aStyleDisplay
)
const
{
MOZ_ASSERT
(
aStyleDisplay
=
=
StyleDisplay
(
)
)
;
return
(
(
mState
&
NS_FRAME_MAY_BE_TRANSFORMED
)
&
&
(
aStyleDisplay
-
>
HasTransform
(
this
)
|
|
HasAnimationOfTransform
(
)
)
)
;
}
bool
nsIFrame
:
:
HasAnimationOfTransform
(
)
const
{
return
IsPrimaryFrame
(
)
&
&
nsLayoutUtils
:
:
HasAnimationOfProperty
(
this
eCSSProperty_transform
)
&
&
IsFrameOfType
(
eSupportsCSSTransforms
)
;
}
bool
nsIFrame
:
:
ChildrenHavePerspective
(
const
nsStyleDisplay
*
aStyleDisplay
)
const
{
MOZ_ASSERT
(
aStyleDisplay
=
=
StyleDisplay
(
)
)
;
return
aStyleDisplay
-
>
HasPerspective
(
this
)
;
}
bool
nsIFrame
:
:
HasOpacityInternal
(
float
aThreshold
const
nsStyleDisplay
*
aStyleDisplay
const
nsStyleEffects
*
aStyleEffects
EffectSet
*
aEffectSet
)
const
{
MOZ_ASSERT
(
0
.
0
<
=
aThreshold
&
&
aThreshold
<
=
1
.
0
"
Invalid
argument
"
)
;
if
(
aStyleEffects
-
>
mOpacity
<
aThreshold
|
|
(
aStyleDisplay
-
>
mWillChangeBitField
&
NS_STYLE_WILL_CHANGE_OPACITY
)
)
{
return
true
;
}
if
(
!
mMayHaveOpacityAnimation
)
{
return
false
;
}
EffectSet
*
effects
=
aEffectSet
?
aEffectSet
:
EffectSet
:
:
GetEffectSet
(
this
)
;
if
(
!
effects
)
{
return
false
;
}
return
(
(
IsPrimaryFrame
(
)
|
|
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
this
)
-
>
IsPrimaryFrame
(
)
)
&
&
nsLayoutUtils
:
:
HasAnimationOfProperty
(
effects
eCSSProperty_opacity
)
)
;
}
bool
nsIFrame
:
:
IsSVGTransformed
(
gfx
:
:
Matrix
*
aOwnTransforms
gfx
:
:
Matrix
*
aFromParentTransforms
)
const
{
return
false
;
}
bool
nsIFrame
:
:
Extend3DContext
(
const
nsStyleDisplay
*
aStyleDisplay
const
nsStyleEffects
*
aStyleEffects
mozilla
:
:
EffectSet
*
aEffectSet
)
const
{
if
(
!
(
mState
&
NS_FRAME_MAY_BE_TRANSFORMED
)
)
{
return
false
;
}
const
nsStyleDisplay
*
disp
=
StyleDisplayWithOptionalParam
(
aStyleDisplay
)
;
if
(
disp
-
>
mTransformStyle
!
=
NS_STYLE_TRANSFORM_STYLE_PRESERVE_3D
|
|
!
IsFrameOfType
(
nsIFrame
:
:
eSupportsCSSTransforms
)
)
{
return
false
;
}
if
(
IsScrollFrame
(
)
)
{
return
false
;
}
const
nsStyleEffects
*
effects
=
StyleEffectsWithOptionalParam
(
aStyleEffects
)
;
if
(
HasOpacity
(
disp
effects
aEffectSet
)
)
{
return
false
;
}
return
!
nsFrame
:
:
ShouldApplyOverflowClipping
(
this
disp
)
&
&
!
GetClipPropClipRect
(
disp
effects
GetSize
(
)
)
&
&
!
nsSVGIntegrationUtils
:
:
UsingEffectsForFrame
(
this
)
;
}
bool
nsIFrame
:
:
Combines3DTransformWithAncestors
(
const
nsStyleDisplay
*
aStyleDisplay
)
const
{
MOZ_ASSERT
(
aStyleDisplay
=
=
StyleDisplay
(
)
)
;
nsIFrame
*
parent
=
GetClosestFlattenedTreeAncestorPrimaryFrame
(
)
;
if
(
!
parent
|
|
!
parent
-
>
Extend3DContext
(
)
)
{
return
false
;
}
return
IsCSSTransformed
(
aStyleDisplay
)
|
|
BackfaceIsHidden
(
aStyleDisplay
)
;
}
bool
nsIFrame
:
:
In3DContextAndBackfaceIsHidden
(
)
const
{
const
nsStyleDisplay
*
disp
=
StyleDisplay
(
)
;
return
BackfaceIsHidden
(
disp
)
&
&
Combines3DTransformWithAncestors
(
disp
)
;
}
bool
nsIFrame
:
:
HasPerspective
(
const
nsStyleDisplay
*
aStyleDisplay
)
const
{
MOZ_ASSERT
(
aStyleDisplay
=
=
StyleDisplay
(
)
)
;
if
(
!
IsTransformed
(
aStyleDisplay
)
)
{
return
false
;
}
nsIFrame
*
containingBlock
=
GetContainingBlock
(
SKIP_SCROLLED_FRAME
aStyleDisplay
)
;
if
(
!
containingBlock
)
{
return
false
;
}
return
containingBlock
-
>
ChildrenHavePerspective
(
)
;
}
nsRect
nsIFrame
:
:
GetContentRectRelativeToSelf
(
)
const
{
nsMargin
bp
(
GetUsedBorderAndPadding
(
)
)
;
bp
.
ApplySkipSides
(
GetSkipSides
(
)
)
;
nsRect
r
(
0
0
mRect
.
width
mRect
.
height
)
;
r
.
Deflate
(
bp
)
;
return
r
;
}
nsRect
nsIFrame
:
:
GetContentRect
(
)
const
{
return
GetContentRectRelativeToSelf
(
)
+
GetPosition
(
)
;
}
bool
nsIFrame
:
:
ComputeBorderRadii
(
const
nsStyleCorners
&
aBorderRadius
const
nsSize
&
aFrameSize
const
nsSize
&
aBorderArea
Sides
aSkipSides
nscoord
aRadii
[
8
]
)
{
NS_FOR_CSS_HALF_CORNERS
(
i
)
{
const
nsStyleCoord
c
=
aBorderRadius
.
Get
(
i
)
;
nscoord
axis
=
HalfCornerIsX
(
i
)
?
aFrameSize
.
width
:
aFrameSize
.
height
;
if
(
c
.
IsCoordPercentCalcUnit
(
)
)
{
aRadii
[
i
]
=
c
.
ComputeCoordPercentCalc
(
axis
)
;
if
(
aRadii
[
i
]
<
0
)
{
aRadii
[
i
]
=
0
;
}
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
ComputeBorderRadii
:
bad
unit
"
)
;
aRadii
[
i
]
=
0
;
}
}
if
(
aSkipSides
.
Top
(
)
)
{
aRadii
[
eCornerTopLeftX
]
=
0
;
aRadii
[
eCornerTopLeftY
]
=
0
;
aRadii
[
eCornerTopRightX
]
=
0
;
aRadii
[
eCornerTopRightY
]
=
0
;
}
if
(
aSkipSides
.
Right
(
)
)
{
aRadii
[
eCornerTopRightX
]
=
0
;
aRadii
[
eCornerTopRightY
]
=
0
;
aRadii
[
eCornerBottomRightX
]
=
0
;
aRadii
[
eCornerBottomRightY
]
=
0
;
}
if
(
aSkipSides
.
Bottom
(
)
)
{
aRadii
[
eCornerBottomRightX
]
=
0
;
aRadii
[
eCornerBottomRightY
]
=
0
;
aRadii
[
eCornerBottomLeftX
]
=
0
;
aRadii
[
eCornerBottomLeftY
]
=
0
;
}
if
(
aSkipSides
.
Left
(
)
)
{
aRadii
[
eCornerBottomLeftX
]
=
0
;
aRadii
[
eCornerBottomLeftY
]
=
0
;
aRadii
[
eCornerTopLeftX
]
=
0
;
aRadii
[
eCornerTopLeftY
]
=
0
;
}
bool
haveRadius
=
false
;
double
ratio
=
1
.
0f
;
NS_FOR_CSS_SIDES
(
side
)
{
uint32_t
hc1
=
SideToHalfCorner
(
side
false
true
)
;
uint32_t
hc2
=
SideToHalfCorner
(
side
true
true
)
;
nscoord
length
=
SideIsVertical
(
side
)
?
aBorderArea
.
height
:
aBorderArea
.
width
;
nscoord
sum
=
aRadii
[
hc1
]
+
aRadii
[
hc2
]
;
if
(
sum
)
haveRadius
=
true
;
if
(
length
<
sum
)
ratio
=
std
:
:
min
(
ratio
double
(
length
)
/
sum
)
;
}
if
(
ratio
<
1
.
0
)
{
NS_FOR_CSS_HALF_CORNERS
(
corner
)
{
aRadii
[
corner
]
*
=
ratio
;
}
}
return
haveRadius
;
}
void
nsIFrame
:
:
InsetBorderRadii
(
nscoord
aRadii
[
8
]
const
nsMargin
&
aOffsets
)
{
NS_FOR_CSS_SIDES
(
side
)
{
nscoord
offset
=
aOffsets
.
Side
(
side
)
;
uint32_t
hc1
=
SideToHalfCorner
(
side
false
false
)
;
uint32_t
hc2
=
SideToHalfCorner
(
side
true
false
)
;
aRadii
[
hc1
]
=
std
:
:
max
(
0
aRadii
[
hc1
]
-
offset
)
;
aRadii
[
hc2
]
=
std
:
:
max
(
0
aRadii
[
hc2
]
-
offset
)
;
}
}
void
nsIFrame
:
:
OutsetBorderRadii
(
nscoord
aRadii
[
8
]
const
nsMargin
&
aOffsets
)
{
auto
AdjustOffset
=
[
]
(
const
uint32_t
aRadius
const
nscoord
aOffset
)
{
if
(
aOffset
>
0
)
{
const
double
ratio
=
aRadius
/
double
(
aOffset
)
;
if
(
ratio
<
1
.
0
)
{
return
nscoord
(
aOffset
*
(
1
.
0
+
std
:
:
pow
(
ratio
-
1
3
)
)
)
;
}
}
return
aOffset
;
}
;
NS_FOR_CSS_SIDES
(
side
)
{
const
nscoord
offset
=
aOffsets
.
Side
(
side
)
;
const
uint32_t
hc1
=
SideToHalfCorner
(
side
false
false
)
;
const
uint32_t
hc2
=
SideToHalfCorner
(
side
true
false
)
;
if
(
aRadii
[
hc1
]
>
0
)
{
const
nscoord
offset1
=
AdjustOffset
(
aRadii
[
hc1
]
offset
)
;
aRadii
[
hc1
]
=
std
:
:
max
(
0
aRadii
[
hc1
]
+
offset1
)
;
}
if
(
aRadii
[
hc2
]
>
0
)
{
const
nscoord
offset2
=
AdjustOffset
(
aRadii
[
hc2
]
offset
)
;
aRadii
[
hc2
]
=
std
:
:
max
(
0
aRadii
[
hc2
]
+
offset2
)
;
}
}
}
bool
nsIFrame
:
:
GetBorderRadii
(
const
nsSize
&
aFrameSize
const
nsSize
&
aBorderArea
Sides
aSkipSides
nscoord
aRadii
[
8
]
)
const
{
if
(
!
mMayHaveRoundedCorners
)
{
memset
(
aRadii
0
sizeof
(
nscoord
)
*
8
)
;
return
false
;
}
if
(
IsThemed
(
)
)
{
NS_FOR_CSS_HALF_CORNERS
(
corner
)
{
aRadii
[
corner
]
=
0
;
}
return
false
;
}
const_cast
<
nsIFrame
*
>
(
this
)
-
>
mMayHaveRoundedCorners
=
ComputeBorderRadii
(
StyleBorder
(
)
-
>
mBorderRadius
aFrameSize
aBorderArea
aSkipSides
aRadii
)
;
return
mMayHaveRoundedCorners
;
}
bool
nsIFrame
:
:
GetBorderRadii
(
nscoord
aRadii
[
8
]
)
const
{
nsSize
sz
=
GetSize
(
)
;
return
GetBorderRadii
(
sz
sz
GetSkipSides
(
)
aRadii
)
;
}
bool
nsIFrame
:
:
GetMarginBoxBorderRadii
(
nscoord
aRadii
[
8
]
)
const
{
return
GetBoxBorderRadii
(
aRadii
GetUsedMargin
(
)
true
)
;
}
bool
nsIFrame
:
:
GetPaddingBoxBorderRadii
(
nscoord
aRadii
[
8
]
)
const
{
return
GetBoxBorderRadii
(
aRadii
GetUsedBorder
(
)
false
)
;
}
bool
nsIFrame
:
:
GetContentBoxBorderRadii
(
nscoord
aRadii
[
8
]
)
const
{
return
GetBoxBorderRadii
(
aRadii
GetUsedBorderAndPadding
(
)
false
)
;
}
bool
nsIFrame
:
:
GetBoxBorderRadii
(
nscoord
aRadii
[
8
]
nsMargin
aOffset
bool
aIsOutset
)
const
{
if
(
!
GetBorderRadii
(
aRadii
)
)
return
false
;
if
(
aIsOutset
)
{
OutsetBorderRadii
(
aRadii
aOffset
)
;
}
else
{
InsetBorderRadii
(
aRadii
aOffset
)
;
}
NS_FOR_CSS_HALF_CORNERS
(
corner
)
{
if
(
aRadii
[
corner
]
)
return
true
;
}
return
false
;
}
bool
nsIFrame
:
:
GetShapeBoxBorderRadii
(
nscoord
aRadii
[
8
]
)
const
{
switch
(
StyleDisplay
(
)
-
>
mShapeOutside
.
GetReferenceBox
(
)
)
{
case
StyleGeometryBox
:
:
NoBox
:
return
false
;
case
StyleGeometryBox
:
:
ContentBox
:
return
GetContentBoxBorderRadii
(
aRadii
)
;
case
StyleGeometryBox
:
:
PaddingBox
:
return
GetPaddingBoxBorderRadii
(
aRadii
)
;
case
StyleGeometryBox
:
:
BorderBox
:
return
GetBorderRadii
(
aRadii
)
;
case
StyleGeometryBox
:
:
MarginBox
:
return
GetMarginBoxBorderRadii
(
aRadii
)
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
box
value
"
)
;
return
false
;
}
}
ComputedStyle
*
nsFrame
:
:
GetAdditionalComputedStyle
(
int32_t
aIndex
)
const
{
MOZ_ASSERT
(
aIndex
>
=
0
"
invalid
index
number
"
)
;
return
nullptr
;
}
void
nsFrame
:
:
SetAdditionalComputedStyle
(
int32_t
aIndex
ComputedStyle
*
aComputedStyle
)
{
MOZ_ASSERT
(
aIndex
>
=
0
"
invalid
index
number
"
)
;
}
nscoord
nsFrame
:
:
GetLogicalBaseline
(
WritingMode
aWritingMode
)
const
{
NS_ASSERTION
(
!
NS_SUBTREE_DIRTY
(
this
)
"
frame
must
not
be
dirty
"
)
;
if
(
aWritingMode
.
IsLineInverted
(
)
)
{
return
-
GetLogicalUsedMargin
(
aWritingMode
)
.
BStart
(
aWritingMode
)
;
}
return
BSize
(
aWritingMode
)
+
GetLogicalUsedMargin
(
aWritingMode
)
.
BEnd
(
aWritingMode
)
;
}
const
nsFrameList
&
nsFrame
:
:
GetChildList
(
ChildListID
aListID
)
const
{
if
(
IsAbsoluteContainer
(
)
&
&
aListID
=
=
GetAbsoluteListID
(
)
)
{
return
GetAbsoluteContainingBlock
(
)
-
>
GetChildList
(
)
;
}
else
{
return
nsFrameList
:
:
EmptyList
(
)
;
}
}
void
nsFrame
:
:
GetChildLists
(
nsTArray
<
ChildList
>
*
aLists
)
const
{
if
(
IsAbsoluteContainer
(
)
)
{
nsFrameList
absoluteList
=
GetAbsoluteContainingBlock
(
)
-
>
GetChildList
(
)
;
absoluteList
.
AppendIfNonempty
(
aLists
GetAbsoluteListID
(
)
)
;
}
}
void
nsIFrame
:
:
GetCrossDocChildLists
(
nsTArray
<
ChildList
>
*
aLists
)
{
nsSubDocumentFrame
*
subdocumentFrame
=
do_QueryFrame
(
this
)
;
if
(
subdocumentFrame
)
{
nsIFrame
*
root
=
subdocumentFrame
-
>
GetSubdocumentRootFrame
(
)
;
if
(
root
)
{
aLists
-
>
AppendElement
(
nsIFrame
:
:
ChildList
(
nsFrameList
(
root
nsLayoutUtils
:
:
GetLastSibling
(
root
)
)
nsIFrame
:
:
kPrincipalList
)
)
;
}
}
GetChildLists
(
aLists
)
;
}
Visibility
nsIFrame
:
:
GetVisibility
(
)
const
{
if
(
!
(
GetStateBits
(
)
&
NS_FRAME_VISIBILITY_IS_TRACKED
)
)
{
return
Visibility
:
:
UNTRACKED
;
}
bool
isSet
=
false
;
uint32_t
visibleCount
=
GetProperty
(
VisibilityStateProperty
(
)
&
isSet
)
;
MOZ_ASSERT
(
isSet
"
Should
have
a
VisibilityStateProperty
value
"
"
if
NS_FRAME_VISIBILITY_IS_TRACKED
is
set
"
)
;
return
visibleCount
>
0
?
Visibility
:
:
APPROXIMATELY_VISIBLE
:
Visibility
:
:
APPROXIMATELY_NONVISIBLE
;
}
void
nsIFrame
:
:
UpdateVisibilitySynchronously
(
)
{
nsIPresShell
*
presShell
=
PresShell
(
)
;
if
(
!
presShell
)
{
return
;
}
if
(
presShell
-
>
AssumeAllFramesVisible
(
)
)
{
presShell
-
>
EnsureFrameInApproximatelyVisibleList
(
this
)
;
return
;
}
bool
visible
=
StyleVisibility
(
)
-
>
IsVisible
(
)
;
nsIFrame
*
f
=
GetParent
(
)
;
nsRect
rect
=
GetRectRelativeToSelf
(
)
;
nsIFrame
*
rectFrame
=
this
;
while
(
f
&
&
visible
)
{
nsIScrollableFrame
*
sf
=
do_QueryFrame
(
f
)
;
if
(
sf
)
{
nsRect
transformedRect
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
rectFrame
rect
f
)
;
if
(
!
sf
-
>
IsRectNearlyVisible
(
transformedRect
)
)
{
visible
=
false
;
break
;
}
rect
=
transformedRect
.
MoveInsideAndClamp
(
sf
-
>
GetScrollPortRect
(
)
)
;
rectFrame
=
f
;
}
nsIFrame
*
parent
=
f
-
>
GetParent
(
)
;
if
(
!
parent
)
{
parent
=
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
f
)
;
if
(
parent
&
&
parent
-
>
PresContext
(
)
-
>
IsChrome
(
)
)
{
break
;
}
}
f
=
parent
;
}
if
(
visible
)
{
presShell
-
>
EnsureFrameInApproximatelyVisibleList
(
this
)
;
}
else
{
presShell
-
>
RemoveFrameFromApproximatelyVisibleList
(
this
)
;
}
}
void
nsIFrame
:
:
EnableVisibilityTracking
(
)
{
if
(
GetStateBits
(
)
&
NS_FRAME_VISIBILITY_IS_TRACKED
)
{
return
;
}
MOZ_ASSERT
(
!
HasProperty
(
VisibilityStateProperty
(
)
)
"
Shouldn
'
t
have
a
VisibilityStateProperty
value
"
"
if
NS_FRAME_VISIBILITY_IS_TRACKED
is
not
set
"
)
;
AddStateBits
(
NS_FRAME_VISIBILITY_IS_TRACKED
)
;
SetProperty
(
VisibilityStateProperty
(
)
0
)
;
nsIPresShell
*
presShell
=
PresShell
(
)
;
if
(
!
presShell
)
{
return
;
}
presShell
-
>
ScheduleApproximateFrameVisibilityUpdateSoon
(
)
;
}
void
nsIFrame
:
:
DisableVisibilityTracking
(
)
{
if
(
!
(
GetStateBits
(
)
&
NS_FRAME_VISIBILITY_IS_TRACKED
)
)
{
return
;
}
bool
isSet
=
false
;
uint32_t
visibleCount
=
RemoveProperty
(
VisibilityStateProperty
(
)
&
isSet
)
;
MOZ_ASSERT
(
isSet
"
Should
have
a
VisibilityStateProperty
value
"
"
if
NS_FRAME_VISIBILITY_IS_TRACKED
is
set
"
)
;
RemoveStateBits
(
NS_FRAME_VISIBILITY_IS_TRACKED
)
;
if
(
visibleCount
=
=
0
)
{
return
;
}
OnVisibilityChange
(
Visibility
:
:
APPROXIMATELY_NONVISIBLE
)
;
}
void
nsIFrame
:
:
DecApproximateVisibleCount
(
const
Maybe
<
OnNonvisible
>
&
aNonvisibleAction
)
{
MOZ_ASSERT
(
GetStateBits
(
)
&
NS_FRAME_VISIBILITY_IS_TRACKED
)
;
bool
isSet
=
false
;
uint32_t
visibleCount
=
GetProperty
(
VisibilityStateProperty
(
)
&
isSet
)
;
MOZ_ASSERT
(
isSet
"
Should
have
a
VisibilityStateProperty
value
"
"
if
NS_FRAME_VISIBILITY_IS_TRACKED
is
set
"
)
;
MOZ_ASSERT
(
visibleCount
>
0
"
Frame
is
already
nonvisible
and
we
'
re
"
"
decrementing
its
visible
count
?
"
)
;
visibleCount
-
-
;
SetProperty
(
VisibilityStateProperty
(
)
visibleCount
)
;
if
(
visibleCount
>
0
)
{
return
;
}
OnVisibilityChange
(
Visibility
:
:
APPROXIMATELY_NONVISIBLE
aNonvisibleAction
)
;
}
void
nsIFrame
:
:
IncApproximateVisibleCount
(
)
{
MOZ_ASSERT
(
GetStateBits
(
)
&
NS_FRAME_VISIBILITY_IS_TRACKED
)
;
bool
isSet
=
false
;
uint32_t
visibleCount
=
GetProperty
(
VisibilityStateProperty
(
)
&
isSet
)
;
MOZ_ASSERT
(
isSet
"
Should
have
a
VisibilityStateProperty
value
"
"
if
NS_FRAME_VISIBILITY_IS_TRACKED
is
set
"
)
;
visibleCount
+
+
;
SetProperty
(
VisibilityStateProperty
(
)
visibleCount
)
;
if
(
visibleCount
>
1
)
{
return
;
}
OnVisibilityChange
(
Visibility
:
:
APPROXIMATELY_VISIBLE
)
;
}
void
nsIFrame
:
:
OnVisibilityChange
(
Visibility
aNewVisibility
const
Maybe
<
OnNonvisible
>
&
aNonvisibleAction
)
{
}
static
nsIFrame
*
GetActiveSelectionFrame
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
)
{
nsIContent
*
capturingContent
=
nsIPresShell
:
:
GetCapturingContent
(
)
;
if
(
capturingContent
)
{
nsIFrame
*
activeFrame
=
aPresContext
-
>
GetPrimaryFrameFor
(
capturingContent
)
;
return
activeFrame
?
activeFrame
:
aFrame
;
}
return
aFrame
;
}
int16_t
nsFrame
:
:
DisplaySelection
(
nsPresContext
*
aPresContext
bool
isOkToTurnOn
)
{
int16_t
selType
=
nsISelectionController
:
:
SELECTION_OFF
;
nsCOMPtr
<
nsISelectionController
>
selCon
;
nsresult
result
=
GetSelectionController
(
aPresContext
getter_AddRefs
(
selCon
)
)
;
if
(
NS_SUCCEEDED
(
result
)
&
&
selCon
)
{
result
=
selCon
-
>
GetDisplaySelection
(
&
selType
)
;
if
(
NS_SUCCEEDED
(
result
)
&
&
(
selType
!
=
nsISelectionController
:
:
SELECTION_OFF
)
)
{
if
(
!
IsSelectable
(
nullptr
)
)
{
selType
=
nsISelectionController
:
:
SELECTION_OFF
;
isOkToTurnOn
=
false
;
}
}
if
(
isOkToTurnOn
&
&
(
selType
=
=
nsISelectionController
:
:
SELECTION_OFF
)
)
{
selCon
-
>
SetDisplaySelection
(
nsISelectionController
:
:
SELECTION_ON
)
;
selType
=
nsISelectionController
:
:
SELECTION_ON
;
}
}
return
selType
;
}
class
nsDisplaySelectionOverlay
:
public
nsDisplayItem
{
public
:
nsDisplaySelectionOverlay
(
nsDisplayListBuilder
*
aBuilder
nsFrame
*
aFrame
int16_t
aSelectionValue
)
:
nsDisplayItem
(
aBuilder
aFrame
)
mSelectionValue
(
aSelectionValue
)
{
MOZ_COUNT_CTOR
(
nsDisplaySelectionOverlay
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplaySelectionOverlay
(
)
{
MOZ_COUNT_DTOR
(
nsDisplaySelectionOverlay
)
;
}
#
endif
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
;
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
NS_DISPLAY_DECL_NAME
(
"
SelectionOverlay
"
TYPE_SELECTION_OVERLAY
)
private
:
Color
ComputeColor
(
)
const
;
static
Color
ComputeColorFromSelectionStyle
(
ComputedStyle
&
)
;
static
Color
ApplyTransparencyIfNecessary
(
nscolor
)
;
int16_t
mSelectionValue
;
}
;
Color
nsDisplaySelectionOverlay
:
:
ApplyTransparencyIfNecessary
(
nscolor
aColor
)
{
if
(
NS_GET_A
(
aColor
)
!
=
255
)
{
return
ToDeviceColor
(
aColor
)
;
}
auto
color
=
Color
:
:
FromABGR
(
aColor
)
;
color
.
a
=
0
.
5
;
return
ToDeviceColor
(
color
)
;
}
Color
nsDisplaySelectionOverlay
:
:
ComputeColorFromSelectionStyle
(
ComputedStyle
&
aStyle
)
{
return
ApplyTransparencyIfNecessary
(
aStyle
.
GetVisitedDependentColor
(
&
nsStyleBackground
:
:
mBackgroundColor
)
)
;
}
Color
nsDisplaySelectionOverlay
:
:
ComputeColor
(
)
const
{
LookAndFeel
:
:
ColorID
colorID
;
if
(
mSelectionValue
=
=
nsISelectionController
:
:
SELECTION_ON
)
{
if
(
RefPtr
<
ComputedStyle
>
style
=
mFrame
-
>
ComputeSelectionStyle
(
)
)
{
return
ComputeColorFromSelectionStyle
(
*
style
)
;
}
colorID
=
LookAndFeel
:
:
eColorID_TextSelectBackground
;
}
else
if
(
mSelectionValue
=
=
nsISelectionController
:
:
SELECTION_ATTENTION
)
{
colorID
=
LookAndFeel
:
:
eColorID_TextSelectBackgroundAttention
;
}
else
{
colorID
=
LookAndFeel
:
:
eColorID_TextSelectBackgroundDisabled
;
}
return
ApplyTransparencyIfNecessary
(
LookAndFeel
:
:
GetColor
(
colorID
NS_RGB
(
255
255
255
)
)
)
;
}
void
nsDisplaySelectionOverlay
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
DrawTarget
&
aDrawTarget
=
*
aCtx
-
>
GetDrawTarget
(
)
;
ColorPattern
color
(
ComputeColor
(
)
)
;
nsIntRect
pxRect
=
GetPaintRect
(
)
.
ToOutsidePixels
(
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
Rect
rect
(
pxRect
.
x
pxRect
.
y
pxRect
.
width
pxRect
.
height
)
;
MaybeSnapToDevicePixels
(
rect
aDrawTarget
true
)
;
aDrawTarget
.
FillRect
(
rect
color
)
;
}
bool
nsDisplaySelectionOverlay
:
:
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
wr
:
:
LayoutRect
bounds
=
wr
:
:
ToRoundedLayoutRect
(
LayoutDeviceRect
:
:
FromAppUnits
(
nsRect
(
ToReferenceFrame
(
)
Frame
(
)
-
>
GetSize
(
)
)
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
)
;
aBuilder
.
PushRect
(
bounds
bounds
!
BackfaceIsHidden
(
)
wr
:
:
ToColorF
(
ComputeColor
(
)
)
)
;
return
true
;
}
static
Element
*
FindElementAncestorForMozSelection
(
nsIContent
*
aContent
)
{
NS_ENSURE_TRUE
(
aContent
nullptr
)
;
while
(
aContent
&
&
aContent
-
>
IsInNativeAnonymousSubtree
(
)
)
{
aContent
=
aContent
-
>
GetBindingParent
(
)
;
}
NS_ASSERTION
(
aContent
"
aContent
isn
'
t
in
non
-
anonymous
tree
?
"
)
;
while
(
aContent
&
&
!
aContent
-
>
IsElement
(
)
)
{
aContent
=
aContent
-
>
GetParent
(
)
;
}
return
aContent
?
aContent
-
>
AsElement
(
)
:
nullptr
;
}
already_AddRefed
<
ComputedStyle
>
nsIFrame
:
:
ComputeSelectionStyle
(
)
const
{
Element
*
element
=
FindElementAncestorForMozSelection
(
GetContent
(
)
)
;
if
(
!
element
)
{
return
nullptr
;
}
RefPtr
<
ComputedStyle
>
sc
=
PresContext
(
)
-
>
StyleSet
(
)
-
>
ProbePseudoElementStyle
(
*
element
CSSPseudoElementType
:
:
selection
Style
(
)
)
;
return
sc
.
forget
(
)
;
}
void
nsFrame
:
:
DisplaySelectionOverlay
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
uint16_t
aContentType
)
{
if
(
!
IsSelected
(
)
|
|
!
IsVisibleForPainting
(
)
)
{
return
;
}
int16_t
displaySelection
=
PresShell
(
)
-
>
GetSelectionFlags
(
)
;
if
(
!
(
displaySelection
&
aContentType
)
)
{
return
;
}
const
nsFrameSelection
*
frameSelection
=
GetConstFrameSelection
(
)
;
int16_t
selectionValue
=
frameSelection
-
>
GetDisplaySelection
(
)
;
if
(
selectionValue
<
=
nsISelectionController
:
:
SELECTION_HIDDEN
)
{
return
;
}
nsIContent
*
newContent
=
mContent
-
>
GetParent
(
)
;
int32_t
offset
=
0
;
if
(
newContent
)
{
offset
=
newContent
-
>
ComputeIndexOf
(
mContent
)
;
}
UniquePtr
<
SelectionDetails
>
details
=
frameSelection
-
>
LookUpSelection
(
newContent
offset
1
false
)
;
if
(
!
details
)
return
;
bool
normal
=
false
;
for
(
SelectionDetails
*
sd
=
details
.
get
(
)
;
sd
;
sd
=
sd
-
>
mNext
.
get
(
)
)
{
if
(
sd
-
>
mSelectionType
=
=
SelectionType
:
:
eNormal
)
{
normal
=
true
;
}
}
if
(
!
normal
&
&
aContentType
=
=
nsISelectionDisplay
:
:
DISPLAY_IMAGES
)
{
return
;
}
aList
-
>
AppendToTop
(
MakeDisplayItem
<
nsDisplaySelectionOverlay
>
(
aBuilder
this
selectionValue
)
)
;
}
void
nsFrame
:
:
DisplayOutlineUnconditional
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
if
(
!
StyleOutline
(
)
-
>
ShouldPaintOutline
(
)
)
{
return
;
}
aLists
.
Outlines
(
)
-
>
AppendToTop
(
MakeDisplayItem
<
nsDisplayOutline
>
(
aBuilder
this
)
)
;
}
void
nsFrame
:
:
DisplayOutline
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
if
(
!
IsVisibleForPainting
(
)
)
return
;
DisplayOutlineUnconditional
(
aBuilder
aLists
)
;
}
void
nsIFrame
:
:
DisplayCaret
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
)
{
if
(
!
IsVisibleForPainting
(
)
)
return
;
aList
-
>
AppendToTop
(
MakeDisplayItem
<
nsDisplayCaret
>
(
aBuilder
this
)
)
;
}
nscolor
nsIFrame
:
:
GetCaretColorAt
(
int32_t
aOffset
)
{
return
nsLayoutUtils
:
:
GetColor
(
this
&
nsStyleUI
:
:
mCaretColor
)
;
}
bool
nsFrame
:
:
DisplayBackgroundUnconditional
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
bool
aForceBackground
)
{
if
(
aBuilder
-
>
IsForEventDelivery
(
)
|
|
aForceBackground
|
|
!
StyleBackground
(
)
-
>
IsTransparent
(
this
)
|
|
StyleDisplay
(
)
-
>
HasAppearance
(
)
)
{
return
nsDisplayBackgroundImage
:
:
AppendBackgroundItemsToTop
(
aBuilder
this
GetRectRelativeToSelf
(
)
aLists
.
BorderBackground
(
)
)
;
}
return
false
;
}
void
nsFrame
:
:
DisplayBorderBackgroundOutline
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
bool
aForceBackground
)
{
if
(
!
IsVisibleForPainting
(
)
)
{
return
;
}
nsCSSShadowArray
*
shadows
=
StyleEffects
(
)
-
>
mBoxShadow
;
if
(
shadows
&
&
shadows
-
>
HasShadowWithInset
(
false
)
)
{
aLists
.
BorderBackground
(
)
-
>
AppendToTop
(
MakeDisplayItem
<
nsDisplayBoxShadowOuter
>
(
aBuilder
this
)
)
;
}
bool
bgIsThemed
=
DisplayBackgroundUnconditional
(
aBuilder
aLists
aForceBackground
)
;
if
(
shadows
&
&
shadows
-
>
HasShadowWithInset
(
true
)
)
{
aLists
.
BorderBackground
(
)
-
>
AppendToTop
(
MakeDisplayItem
<
nsDisplayBoxShadowInner
>
(
aBuilder
this
)
)
;
}
if
(
!
bgIsThemed
&
&
StyleBorder
(
)
-
>
HasBorder
(
)
)
{
aLists
.
BorderBackground
(
)
-
>
AppendToTop
(
MakeDisplayItem
<
nsDisplayBorder
>
(
aBuilder
this
)
)
;
}
DisplayOutlineUnconditional
(
aBuilder
aLists
)
;
}
inline
static
bool
IsSVGContentWithCSSClip
(
const
nsIFrame
*
aFrame
)
{
return
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_SVG_LAYOUT
)
&
&
aFrame
-
>
GetContent
(
)
-
>
IsAnyOfSVGElements
(
nsGkAtoms
:
:
svg
nsGkAtoms
:
:
foreignObject
)
;
}
Maybe
<
nsRect
>
nsIFrame
:
:
GetClipPropClipRect
(
const
nsStyleDisplay
*
aDisp
const
nsStyleEffects
*
aEffects
const
nsSize
&
aSize
)
const
{
if
(
!
(
aEffects
-
>
mClipFlags
&
NS_STYLE_CLIP_RECT
)
|
|
!
(
aDisp
-
>
IsAbsolutelyPositioned
(
this
)
|
|
IsSVGContentWithCSSClip
(
this
)
)
)
{
return
Nothing
(
)
;
}
nsRect
rect
=
aEffects
-
>
mClip
;
if
(
MOZ_LIKELY
(
StyleBorder
(
)
-
>
mBoxDecorationBreak
=
=
StyleBoxDecorationBreak
:
:
Slice
)
)
{
nscoord
y
=
0
;
for
(
nsIFrame
*
f
=
GetPrevContinuation
(
)
;
f
;
f
=
f
-
>
GetPrevContinuation
(
)
)
{
y
+
=
f
-
>
GetRect
(
)
.
height
;
}
rect
.
MoveBy
(
nsPoint
(
0
-
y
)
)
;
}
if
(
NS_STYLE_CLIP_RIGHT_AUTO
&
aEffects
-
>
mClipFlags
)
{
rect
.
width
=
aSize
.
width
-
rect
.
x
;
}
if
(
NS_STYLE_CLIP_BOTTOM_AUTO
&
aEffects
-
>
mClipFlags
)
{
rect
.
height
=
aSize
.
height
-
rect
.
y
;
}
return
Some
(
rect
)
;
}
static
bool
ApplyOverflowClipping
(
nsDisplayListBuilder
*
aBuilder
const
nsIFrame
*
aFrame
const
nsStyleDisplay
*
aDisp
DisplayListClipState
:
:
AutoClipMultiple
&
aClipState
)
{
if
(
!
nsFrame
:
:
ShouldApplyOverflowClipping
(
aFrame
aDisp
)
)
{
return
false
;
}
nsRect
clipRect
;
bool
haveRadii
=
false
;
nscoord
radii
[
8
]
;
auto
*
disp
=
aFrame
-
>
StyleDisplay
(
)
;
auto
wm
=
aFrame
-
>
GetWritingMode
(
)
;
bool
cbH
=
(
wm
.
IsVertical
(
)
?
disp
-
>
mOverflowClipBoxBlock
:
disp
-
>
mOverflowClipBoxInline
)
=
=
StyleOverflowClipBox
:
:
ContentBox
;
bool
cbV
=
(
wm
.
IsVertical
(
)
?
disp
-
>
mOverflowClipBoxInline
:
disp
-
>
mOverflowClipBoxBlock
)
=
=
StyleOverflowClipBox
:
:
ContentBox
;
nsMargin
bp
=
aFrame
-
>
GetUsedPadding
(
)
;
if
(
!
cbH
)
{
bp
.
left
=
bp
.
right
=
nscoord
(
0
)
;
}
if
(
!
cbV
)
{
bp
.
top
=
bp
.
bottom
=
nscoord
(
0
)
;
}
bp
+
=
aFrame
-
>
GetUsedBorder
(
)
;
bp
.
ApplySkipSides
(
aFrame
-
>
GetSkipSides
(
)
)
;
nsRect
rect
(
nsPoint
(
0
0
)
aFrame
-
>
GetSize
(
)
)
;
rect
.
Deflate
(
bp
)
;
clipRect
=
rect
+
aBuilder
-
>
ToReferenceFrame
(
aFrame
)
;
haveRadii
=
aFrame
-
>
GetBoxBorderRadii
(
radii
bp
false
)
;
aClipState
.
ClipContainingBlockDescendantsExtra
(
clipRect
haveRadii
?
radii
:
nullptr
)
;
return
true
;
}
#
ifdef
DEBUG
static
void
PaintDebugBorder
(
nsIFrame
*
aFrame
DrawTarget
*
aDrawTarget
const
nsRect
&
aDirtyRect
nsPoint
aPt
)
{
nsRect
r
(
aPt
aFrame
-
>
GetSize
(
)
)
;
int32_t
appUnitsPerDevPixel
=
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
Color
blueOrRed
(
aFrame
-
>
HasView
(
)
?
Color
(
0
.
f
0
.
f
1
.
f
1
.
f
)
:
Color
(
1
.
f
0
.
f
0
.
f
1
.
f
)
)
;
aDrawTarget
-
>
StrokeRect
(
NSRectToRect
(
r
appUnitsPerDevPixel
)
ColorPattern
(
ToDeviceColor
(
blueOrRed
)
)
)
;
}
static
void
PaintEventTargetBorder
(
nsIFrame
*
aFrame
DrawTarget
*
aDrawTarget
const
nsRect
&
aDirtyRect
nsPoint
aPt
)
{
nsRect
r
(
aPt
aFrame
-
>
GetSize
(
)
)
;
int32_t
appUnitsPerDevPixel
=
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
ColorPattern
purple
(
ToDeviceColor
(
Color
(
.
5f
0
.
f
.
5f
1
.
f
)
)
)
;
aDrawTarget
-
>
StrokeRect
(
NSRectToRect
(
r
appUnitsPerDevPixel
)
purple
)
;
}
static
void
DisplayDebugBorders
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
const
nsDisplayListSet
&
aLists
)
{
if
(
nsFrame
:
:
GetShowFrameBorders
(
)
&
&
!
aFrame
-
>
GetRect
(
)
.
IsEmpty
(
)
)
{
aLists
.
Outlines
(
)
-
>
AppendToTop
(
MakeDisplayItem
<
nsDisplayGeneric
>
(
aBuilder
aFrame
PaintDebugBorder
"
DebugBorder
"
DisplayItemType
:
:
TYPE_DEBUG_BORDER
)
)
;
}
if
(
nsFrame
:
:
GetShowEventTargetFrameBorder
(
)
&
&
aFrame
-
>
PresShell
(
)
-
>
GetDrawEventTargetFrame
(
)
=
=
aFrame
)
{
aLists
.
Outlines
(
)
-
>
AppendToTop
(
MakeDisplayItem
<
nsDisplayGeneric
>
(
aBuilder
aFrame
PaintEventTargetBorder
"
EventTargetBorder
"
DisplayItemType
:
:
TYPE_EVENT_TARGET_BORDER
)
)
;
}
}
#
endif
static
bool
IsScrollFrameActive
(
nsDisplayListBuilder
*
aBuilder
nsIScrollableFrame
*
aScrollableFrame
)
{
return
aScrollableFrame
&
&
aScrollableFrame
-
>
IsScrollingActive
(
aBuilder
)
;
}
static
bool
BuilderHasScrolledClip
(
nsDisplayListBuilder
*
aBuilder
)
{
const
DisplayItemClipChain
*
currentClip
=
aBuilder
-
>
ClipState
(
)
.
GetCurrentCombinedClipChain
(
aBuilder
)
;
if
(
!
currentClip
)
{
return
false
;
}
const
ActiveScrolledRoot
*
currentClipASR
=
currentClip
-
>
mASR
;
const
ActiveScrolledRoot
*
currentASR
=
aBuilder
-
>
CurrentActiveScrolledRoot
(
)
;
return
ActiveScrolledRoot
:
:
PickDescendant
(
currentClipASR
currentASR
)
!
=
currentASR
;
}
class
AutoSaveRestoreContainsBlendMode
{
nsDisplayListBuilder
&
mBuilder
;
bool
mSavedContainsBlendMode
;
public
:
explicit
AutoSaveRestoreContainsBlendMode
(
nsDisplayListBuilder
&
aBuilder
)
:
mBuilder
(
aBuilder
)
mSavedContainsBlendMode
(
aBuilder
.
ContainsBlendMode
(
)
)
{
}
~
AutoSaveRestoreContainsBlendMode
(
)
{
mBuilder
.
SetContainsBlendMode
(
mSavedContainsBlendMode
)
;
}
}
;
static
void
CheckForApzAwareEventHandlers
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
{
if
(
aBuilder
-
>
GetAncestorHasApzAwareEventHandler
(
)
)
{
return
;
}
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
!
content
)
{
return
;
}
if
(
content
-
>
IsNodeApzAware
(
)
)
{
aBuilder
-
>
SetAncestorHasApzAwareEventHandler
(
true
)
;
}
}
static
bool
FrameParticipatesIn3DContext
(
nsIFrame
*
aAncestor
nsIFrame
*
aDescendant
)
{
MOZ_ASSERT
(
aAncestor
!
=
aDescendant
)
;
MOZ_ASSERT
(
aAncestor
-
>
GetContent
(
)
!
=
aDescendant
-
>
GetContent
(
)
)
;
MOZ_ASSERT
(
aAncestor
-
>
Extend3DContext
(
)
)
;
nsIFrame
*
ancestor
=
aAncestor
-
>
FirstContinuation
(
)
;
MOZ_ASSERT
(
ancestor
-
>
IsPrimaryFrame
(
)
)
;
nsIFrame
*
frame
;
for
(
frame
=
aDescendant
-
>
GetClosestFlattenedTreeAncestorPrimaryFrame
(
)
;
frame
&
&
ancestor
!
=
frame
;
frame
=
frame
-
>
GetClosestFlattenedTreeAncestorPrimaryFrame
(
)
)
{
if
(
!
frame
-
>
Extend3DContext
(
)
)
{
return
false
;
}
}
MOZ_ASSERT
(
frame
=
=
ancestor
)
;
return
true
;
}
static
bool
ItemParticipatesIn3DContext
(
nsIFrame
*
aAncestor
nsDisplayItem
*
aItem
)
{
auto
type
=
aItem
-
>
GetType
(
)
;
if
(
type
=
=
DisplayItemType
:
:
TYPE_WRAP_LIST
&
&
aItem
-
>
GetChildren
(
)
-
>
Count
(
)
=
=
1
)
{
type
=
aItem
-
>
GetChildren
(
)
-
>
GetBottom
(
)
-
>
GetType
(
)
;
}
if
(
type
!
=
DisplayItemType
:
:
TYPE_TRANSFORM
&
&
type
!
=
DisplayItemType
:
:
TYPE_PERSPECTIVE
)
{
return
false
;
}
nsIFrame
*
transformFrame
=
aItem
-
>
Frame
(
)
;
if
(
aAncestor
-
>
GetContent
(
)
=
=
transformFrame
-
>
GetContent
(
)
)
{
return
true
;
}
return
FrameParticipatesIn3DContext
(
aAncestor
transformFrame
)
;
}
static
void
WrapSeparatorTransform
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aNonParticipants
nsDisplayList
*
aParticipants
int
aIndex
nsDisplayItem
*
*
aSeparator
)
{
if
(
aNonParticipants
-
>
IsEmpty
(
)
)
{
return
;
}
nsDisplayTransform
*
item
=
MakeDisplayItem
<
nsDisplayTransform
>
(
aBuilder
aFrame
aNonParticipants
aBuilder
-
>
GetVisibleRect
(
)
Matrix4x4
(
)
aIndex
)
;
if
(
*
aSeparator
=
=
nullptr
)
{
*
aSeparator
=
item
;
}
aParticipants
-
>
AppendToTop
(
item
)
;
}
static
Maybe
<
nsRect
>
ComputeClipForMaskItem
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aMaskedFrame
)
{
const
nsStyleSVGReset
*
svgReset
=
aMaskedFrame
-
>
StyleSVGReset
(
)
;
nsSVGUtils
:
:
MaskUsage
maskUsage
;
nsSVGUtils
:
:
DetermineMaskUsage
(
aMaskedFrame
false
maskUsage
)
;
nsPoint
offsetToUserSpace
=
nsLayoutUtils
:
:
ComputeOffsetToUserSpace
(
aBuilder
aMaskedFrame
)
;
int32_t
devPixelRatio
=
aMaskedFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
gfxPoint
devPixelOffsetToUserSpace
=
nsLayoutUtils
:
:
PointToGfxPoint
(
offsetToUserSpace
devPixelRatio
)
;
gfxMatrix
cssToDevMatrix
=
nsSVGUtils
:
:
GetCSSPxToDevPxMatrix
(
aMaskedFrame
)
;
nsPoint
toReferenceFrame
;
aBuilder
-
>
FindReferenceFrameFor
(
aMaskedFrame
&
toReferenceFrame
)
;
Maybe
<
gfxRect
>
combinedClip
;
if
(
maskUsage
.
shouldApplyBasicShapeOrPath
)
{
Rect
result
=
nsCSSClipPathInstance
:
:
GetBoundingRectForBasicShapeOrPathClip
(
aMaskedFrame
svgReset
-
>
mClipPath
)
;
combinedClip
=
Some
(
ThebesRect
(
result
)
)
;
}
else
if
(
maskUsage
.
shouldApplyClipPath
)
{
gfxRect
result
=
nsSVGUtils
:
:
GetBBox
(
aMaskedFrame
nsSVGUtils
:
:
eBBoxIncludeClipped
|
nsSVGUtils
:
:
eBBoxIncludeFill
|
nsSVGUtils
:
:
eBBoxIncludeMarkers
|
nsSVGUtils
:
:
eBBoxIncludeStroke
|
nsSVGUtils
:
:
eDoNotClipToBBoxOfContentInsideClipPath
)
;
combinedClip
=
Some
(
cssToDevMatrix
.
TransformBounds
(
result
)
)
;
}
else
{
nsRect
borderArea
(
toReferenceFrame
aMaskedFrame
-
>
GetSize
(
)
)
;
borderArea
-
=
offsetToUserSpace
;
nsRect
dirtyRect
(
nscoord_MIN
/
2
nscoord_MIN
/
2
nscoord_MAX
nscoord_MAX
)
;
nsIFrame
*
firstFrame
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
aMaskedFrame
)
;
nsTArray
<
nsSVGMaskFrame
*
>
maskFrames
;
SVGObserverUtils
:
:
GetAndObserveMasks
(
firstFrame
&
maskFrames
)
;
for
(
uint32_t
i
=
0
;
i
<
maskFrames
.
Length
(
)
;
+
+
i
)
{
gfxRect
clipArea
;
if
(
maskFrames
[
i
]
)
{
clipArea
=
maskFrames
[
i
]
-
>
GetMaskArea
(
aMaskedFrame
)
;
clipArea
=
cssToDevMatrix
.
TransformBounds
(
clipArea
)
;
}
else
{
const
auto
&
layer
=
svgReset
-
>
mMask
.
mLayers
[
i
]
;
if
(
layer
.
mClip
=
=
StyleGeometryBox
:
:
NoClip
)
{
return
Nothing
(
)
;
}
nsCSSRendering
:
:
ImageLayerClipState
clipState
;
nsCSSRendering
:
:
GetImageLayerClip
(
layer
aMaskedFrame
*
aMaskedFrame
-
>
StyleBorder
(
)
borderArea
dirtyRect
false
devPixelRatio
&
clipState
)
;
clipArea
=
clipState
.
mDirtyRectInDevPx
;
}
combinedClip
=
UnionMaybeRects
(
combinedClip
Some
(
clipArea
)
)
;
}
}
if
(
combinedClip
)
{
if
(
combinedClip
-
>
IsEmpty
(
)
)
{
return
Nothing
(
)
;
}
*
combinedClip
+
=
devPixelOffsetToUserSpace
;
combinedClip
-
>
RoundOut
(
)
;
nsRect
result
=
nsLayoutUtils
:
:
RoundGfxRectToAppRect
(
*
combinedClip
devPixelRatio
)
;
result
-
=
toReferenceFrame
;
return
Some
(
result
)
;
}
return
Nothing
(
)
;
}
struct
AutoCheckBuilder
{
explicit
AutoCheckBuilder
(
nsDisplayListBuilder
*
aBuilder
)
:
mBuilder
(
aBuilder
)
{
aBuilder
-
>
Check
(
)
;
}
~
AutoCheckBuilder
(
)
{
mBuilder
-
>
Check
(
)
;
}
nsDisplayListBuilder
*
mBuilder
;
}
;
struct
ContainerTracker
{
void
TrackContainer
(
nsDisplayItem
*
aContainer
)
{
MOZ_ASSERT
(
aContainer
)
;
if
(
!
mContainer
)
{
mContainer
=
aContainer
;
}
mCreatedContainer
=
true
;
}
void
ResetCreatedContainer
(
)
{
mCreatedContainer
=
false
;
}
nsDisplayItem
*
mContainer
=
nullptr
;
bool
mCreatedContainer
=
false
;
}
;
static
void
AddHitTestInfo
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
nsDisplayItem
*
aContainer
nsIFrame
*
aFrame
mozilla
:
:
UniquePtr
<
HitTestInfo
>
&
&
aHitTestInfo
)
{
nsDisplayHitTestInfoItem
*
hitTestItem
;
if
(
aContainer
)
{
MOZ_ASSERT
(
aContainer
-
>
IsHitTestItem
(
)
)
;
hitTestItem
=
static_cast
<
nsDisplayHitTestInfoItem
*
>
(
aContainer
)
;
hitTestItem
-
>
SetHitTestInfo
(
std
:
:
move
(
aHitTestInfo
)
)
;
}
else
{
hitTestItem
=
MakeDisplayItem
<
nsDisplayCompositorHitTestInfo
>
(
aBuilder
aFrame
std
:
:
move
(
aHitTestInfo
)
)
;
aList
-
>
AppendToBottom
(
hitTestItem
)
;
}
}
void
nsIFrame
:
:
BuildDisplayListForStackingContext
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
bool
*
aCreatedContainerItem
)
{
AutoCheckBuilder
check
(
aBuilder
)
;
if
(
GetStateBits
(
)
&
NS_FRAME_TOO_DEEP_IN_FRAME_TREE
)
return
;
if
(
IsFrameOfType
(
eReplaced
)
&
&
!
IsVisibleForPainting
(
)
)
return
;
const
nsStyleDisplay
*
disp
=
StyleDisplay
(
)
;
const
nsStyleEffects
*
effects
=
StyleEffects
(
)
;
EffectSet
*
effectSet
=
EffectSet
:
:
GetEffectSet
(
this
)
;
bool
needHitTestInfo
=
aBuilder
-
>
BuildCompositorHitTestInfo
(
)
&
&
StyleUI
(
)
-
>
GetEffectivePointerEvents
(
this
)
!
=
NS_STYLE_POINTER_EVENTS_NONE
;
bool
opacityItemForEventsAndPluginsOnly
=
false
;
if
(
effects
-
>
mOpacity
=
=
0
.
0
&
&
aBuilder
-
>
IsForPainting
(
)
&
&
!
(
disp
-
>
mWillChangeBitField
&
NS_STYLE_WILL_CHANGE_OPACITY
)
&
&
!
nsLayoutUtils
:
:
HasAnimationOfProperty
(
effectSet
eCSSProperty_opacity
)
)
{
if
(
needHitTestInfo
|
|
aBuilder
-
>
WillComputePluginGeometry
(
)
)
{
opacityItemForEventsAndPluginsOnly
=
true
;
}
else
{
return
;
}
}
if
(
disp
-
>
mWillChangeBitField
!
=
0
)
{
aBuilder
-
>
AddToWillChangeBudget
(
this
GetSize
(
)
)
;
}
nsRect
visibleRect
=
aBuilder
-
>
GetVisibleRect
(
)
;
nsRect
dirtyRect
=
aBuilder
-
>
GetDirtyRect
(
)
;
const
bool
useOpacity
=
HasVisualOpacity
(
disp
effects
effectSet
)
&
&
!
nsSVGUtils
:
:
CanOptimizeOpacity
(
this
)
;
const
bool
isTransformed
=
IsTransformed
(
disp
)
;
const
bool
hasPerspective
=
isTransformed
&
&
HasPerspective
(
disp
)
;
const
bool
extend3DContext
=
Extend3DContext
(
disp
effects
effectSet
)
;
const
bool
combines3DTransformWithAncestors
=
(
extend3DContext
|
|
isTransformed
)
&
&
Combines3DTransformWithAncestors
(
disp
)
;
Maybe
<
nsDisplayListBuilder
:
:
AutoPreserves3DContext
>
autoPreserves3DContext
;
if
(
extend3DContext
&
&
!
combines3DTransformWithAncestors
)
{
autoPreserves3DContext
.
emplace
(
aBuilder
)
;
aBuilder
-
>
SavePreserves3DRect
(
)
;
if
(
aBuilder
-
>
IsRetainingDisplayList
(
)
)
{
dirtyRect
=
visibleRect
;
aBuilder
-
>
SetDisablePartialUpdates
(
true
)
;
}
}
const
bool
useBlendMode
=
effects
-
>
mMixBlendMode
!
=
NS_STYLE_BLEND_NORMAL
;
if
(
useBlendMode
)
{
aBuilder
-
>
SetContainsBlendMode
(
true
)
;
}
AutoSaveRestoreContainsBlendMode
autoRestoreBlendMode
(
*
aBuilder
)
;
aBuilder
-
>
SetContainsBlendMode
(
false
)
;
nsRect
visibleRectOutsideTransform
=
visibleRect
;
bool
allowAsyncAnimation
=
false
;
bool
inTransform
=
aBuilder
-
>
IsInTransform
(
)
;
if
(
isTransformed
)
{
const
nsRect
overflow
=
GetVisualOverflowRectRelativeToSelf
(
)
;
nsDisplayTransform
:
:
PrerenderDecision
decision
=
nsDisplayTransform
:
:
ShouldPrerenderTransformedContent
(
aBuilder
this
&
dirtyRect
)
;
switch
(
decision
)
{
case
nsDisplayTransform
:
:
FullPrerender
:
allowAsyncAnimation
=
true
;
visibleRect
=
dirtyRect
;
break
;
case
nsDisplayTransform
:
:
PartialPrerender
:
allowAsyncAnimation
=
true
;
visibleRect
=
dirtyRect
;
MOZ_FALLTHROUGH
;
case
nsDisplayTransform
:
:
NoPrerender
:
if
(
overflow
.
IsEmpty
(
)
&
&
!
extend3DContext
)
{
return
;
}
if
(
combines3DTransformWithAncestors
)
{
visibleRect
=
dirtyRect
=
aBuilder
-
>
GetPreserves3DRect
(
)
;
}
nsRect
untransformedDirtyRect
;
if
(
nsDisplayTransform
:
:
UntransformRect
(
dirtyRect
overflow
this
&
untransformedDirtyRect
)
)
{
dirtyRect
=
untransformedDirtyRect
;
nsDisplayTransform
:
:
UntransformRect
(
visibleRect
overflow
this
&
visibleRect
)
;
}
else
{
dirtyRect
.
SetEmpty
(
)
;
visibleRect
.
SetEmpty
(
)
;
}
}
inTransform
=
true
;
}
else
if
(
IsFixedPosContainingBlock
(
)
)
{
visibleRect
.
IntersectRect
(
visibleRect
GetVisualOverflowRect
(
)
)
;
dirtyRect
.
IntersectRect
(
dirtyRect
GetVisualOverflowRect
(
)
)
;
}
bool
hasOverrideDirtyRect
=
false
;
if
(
HasOverrideDirtyRegion
(
)
&
&
!
aBuilder
-
>
InInvalidSubtree
(
)
&
&
!
IsFrameModified
(
)
)
{
nsDisplayListBuilder
:
:
DisplayListBuildingData
*
data
=
GetProperty
(
nsDisplayListBuilder
:
:
DisplayListBuildingRect
(
)
)
;
if
(
data
)
{
dirtyRect
=
data
-
>
mDirtyRect
.
Intersect
(
visibleRect
)
;
hasOverrideDirtyRect
=
true
;
}
}
bool
usingFilter
=
StyleEffects
(
)
-
>
HasFilters
(
)
;
bool
usingMask
=
nsSVGIntegrationUtils
:
:
UsingMaskOrClipPathForFrame
(
this
)
;
bool
usingSVGEffects
=
usingFilter
|
|
usingMask
;
nsRect
visibleRectOutsideSVGEffects
=
visibleRect
;
nsDisplayList
hoistedScrollInfoItemsStorage
;
if
(
usingSVGEffects
)
{
dirtyRect
=
nsSVGIntegrationUtils
:
:
GetRequiredSourceForInvalidArea
(
this
dirtyRect
)
;
visibleRect
=
nsSVGIntegrationUtils
:
:
GetRequiredSourceForInvalidArea
(
this
visibleRect
)
;
aBuilder
-
>
EnterSVGEffectsContents
(
&
hoistedScrollInfoItemsStorage
)
;
}
bool
useStickyPosition
=
disp
-
>
mPosition
=
=
NS_STYLE_POSITION_STICKY
&
&
IsScrollFrameActive
(
aBuilder
nsLayoutUtils
:
:
GetNearestScrollableFrame
(
GetParent
(
)
nsLayoutUtils
:
:
SCROLLABLE_SAME_DOC
|
nsLayoutUtils
:
:
SCROLLABLE_INCLUDE_HIDDEN
)
)
;
bool
useFixedPosition
=
disp
-
>
mPosition
=
=
NS_STYLE_POSITION_FIXED
&
&
(
nsLayoutUtils
:
:
IsFixedPosFrameInDisplayPort
(
this
)
|
|
BuilderHasScrolledClip
(
aBuilder
)
)
;
nsDisplayListBuilder
:
:
AutoBuildingDisplayList
buildingDisplayList
(
aBuilder
this
visibleRect
dirtyRect
isTransformed
)
;
enum
class
ContainerItemType
:
uint8_t
{
eNone
=
0
eOwnLayerIfNeeded
eBlendMode
eFixedPosition
eOwnLayerForTransformWithRoundedClip
ePerspective
eTransform
eSeparatorTransforms
eOpacity
eFilter
eBlendContainer
}
;
nsDisplayListBuilder
:
:
AutoContainerASRTracker
contASRTracker
(
aBuilder
)
;
auto
cssClip
=
GetClipPropClipRect
(
disp
effects
GetSize
(
)
)
;
auto
ApplyClipProp
=
[
&
]
(
DisplayListClipState
:
:
AutoSaveRestore
&
aClipState
)
{
if
(
!
cssClip
)
{
return
;
}
nsPoint
offset
=
aBuilder
-
>
GetCurrentFrameOffsetToReferenceFrame
(
)
;
aBuilder
-
>
IntersectDirtyRect
(
*
cssClip
)
;
aBuilder
-
>
IntersectVisibleRect
(
*
cssClip
)
;
aClipState
.
ClipContentDescendants
(
*
cssClip
+
offset
)
;
}
;
DisplayListClipState
:
:
AutoSaveRestore
untransformedCssClip
(
aBuilder
)
;
if
(
!
isTransformed
)
{
ApplyClipProp
(
untransformedCssClip
)
;
}
ContainerItemType
clipCapturedBy
=
ContainerItemType
:
:
eNone
;
if
(
useFixedPosition
)
{
clipCapturedBy
=
ContainerItemType
:
:
eFixedPosition
;
}
else
if
(
isTransformed
)
{
const
DisplayItemClipChain
*
currentClip
=
aBuilder
-
>
ClipState
(
)
.
GetCurrentCombinedClipChain
(
aBuilder
)
;
if
(
(
hasPerspective
|
|
extend3DContext
)
&
&
(
currentClip
&
&
currentClip
-
>
HasRoundedCorners
(
)
)
)
{
clipCapturedBy
=
ContainerItemType
:
:
eOwnLayerForTransformWithRoundedClip
;
}
else
if
(
hasPerspective
)
{
clipCapturedBy
=
ContainerItemType
:
:
ePerspective
;
}
else
{
clipCapturedBy
=
ContainerItemType
:
:
eTransform
;
}
}
else
if
(
usingFilter
)
{
clipCapturedBy
=
ContainerItemType
:
:
eFilter
;
}
DisplayListClipState
:
:
AutoSaveRestore
clipState
(
aBuilder
)
;
if
(
clipCapturedBy
!
=
ContainerItemType
:
:
eNone
)
{
clipState
.
Clear
(
)
;
}
DisplayListClipState
:
:
AutoSaveRestore
transformedCssClip
(
aBuilder
)
;
if
(
isTransformed
)
{
ApplyClipProp
(
transformedCssClip
)
;
}
mozilla
:
:
UniquePtr
<
HitTestInfo
>
hitTestInfo
;
nsDisplayListCollection
set
(
aBuilder
)
;
Maybe
<
nsRect
>
clipForMask
;
{
DisplayListClipState
:
:
AutoSaveRestore
nestedClipState
(
aBuilder
)
;
nsDisplayListBuilder
:
:
AutoInTransformSetter
inTransformSetter
(
aBuilder
inTransform
)
;
nsDisplayListBuilder
:
:
AutoEnterFilter
filterASRSetter
(
aBuilder
usingFilter
)
;
CheckForApzAwareEventHandlers
(
aBuilder
this
)
;
if
(
usingMask
)
{
clipForMask
=
ComputeClipForMaskItem
(
aBuilder
this
)
;
if
(
clipForMask
)
{
aBuilder
-
>
IntersectDirtyRect
(
*
clipForMask
)
;
aBuilder
-
>
IntersectVisibleRect
(
*
clipForMask
)
;
nestedClipState
.
ClipContentDescendants
(
*
clipForMask
+
aBuilder
-
>
GetCurrentFrameOffsetToReferenceFrame
(
)
)
;
}
}
if
(
extend3DContext
)
{
aBuilder
-
>
MarkPreserve3DFramesForDisplayList
(
this
)
;
}
aBuilder
-
>
AdjustWindowDraggingRegion
(
this
)
;
if
(
gfxVars
:
:
UseWebRender
(
)
)
{
aBuilder
-
>
BuildCompositorHitTestInfoIfNeeded
(
this
set
.
BorderBackground
(
)
true
)
;
}
else
{
CompositorHitTestInfo
info
=
aBuilder
-
>
BuildCompositorHitTestInfo
(
)
?
GetCompositorHitTestInfo
(
aBuilder
)
:
CompositorHitTestInvisibleToHit
;
if
(
info
!
=
CompositorHitTestInvisibleToHit
)
{
hitTestInfo
=
mozilla
:
:
MakeUnique
<
HitTestInfo
>
(
aBuilder
this
info
)
;
aBuilder
-
>
SetCompositorHitTestInfo
(
hitTestInfo
-
>
mArea
hitTestInfo
-
>
mFlags
)
;
}
}
MarkAbsoluteFramesForDisplayList
(
aBuilder
)
;
aBuilder
-
>
Check
(
)
;
BuildDisplayList
(
aBuilder
set
)
;
aBuilder
-
>
Check
(
)
;
aBuilder
-
>
DisplayCaret
(
this
set
.
Content
(
)
)
;
if
(
aBuilder
-
>
ContainsBlendMode
(
)
&
&
aBuilder
-
>
IsRetainingDisplayList
(
)
)
{
if
(
!
aBuilder
-
>
GetDirtyRect
(
)
.
Contains
(
aBuilder
-
>
GetVisibleRect
(
)
)
)
{
aBuilder
-
>
SetPartialBuildFailed
(
true
)
;
}
else
{
aBuilder
-
>
SetDisablePartialUpdates
(
true
)
;
}
}
}
if
(
aBuilder
-
>
IsBackgroundOnly
(
)
)
{
set
.
BlockBorderBackgrounds
(
)
-
>
DeleteAll
(
aBuilder
)
;
set
.
Floats
(
)
-
>
DeleteAll
(
aBuilder
)
;
set
.
Content
(
)
-
>
DeleteAll
(
aBuilder
)
;
set
.
PositionedDescendants
(
)
-
>
DeleteAll
(
aBuilder
)
;
set
.
Outlines
(
)
-
>
DeleteAll
(
aBuilder
)
;
}
if
(
hasOverrideDirtyRect
&
&
gfxPrefs
:
:
LayoutDisplayListShowArea
(
)
)
{
nsDisplaySolidColor
*
color
=
MakeDisplayItem
<
nsDisplaySolidColor
>
(
aBuilder
this
dirtyRect
+
aBuilder
-
>
GetCurrentFrameOffsetToReferenceFrame
(
)
NS_RGBA
(
255
0
0
64
)
false
)
;
color
-
>
SetOverrideZIndex
(
INT32_MAX
)
;
set
.
PositionedDescendants
(
)
-
>
AppendToTop
(
color
)
;
}
nsIContent
*
content
=
GetContent
(
)
;
if
(
!
content
)
{
content
=
PresContext
(
)
-
>
Document
(
)
-
>
GetRootElement
(
)
;
}
nsDisplayList
resultList
;
set
.
SerializeWithCorrectZOrder
(
&
resultList
content
)
;
#
ifdef
DEBUG
DisplayDebugBorders
(
aBuilder
this
set
)
;
#
endif
const
ActiveScrolledRoot
*
containerItemASR
=
contASRTracker
.
GetContainerASR
(
)
;
ContainerTracker
ct
;
if
(
aBuilder
-
>
ContainsBlendMode
(
)
)
{
DisplayListClipState
:
:
AutoSaveRestore
blendContainerClipState
(
aBuilder
)
;
resultList
.
AppendToTop
(
nsDisplayBlendContainer
:
:
CreateForMixBlendMode
(
aBuilder
this
&
resultList
containerItemASR
)
)
;
ct
.
TrackContainer
(
resultList
.
GetTop
(
)
)
;
}
if
(
usingSVGEffects
)
{
MOZ_ASSERT
(
usingFilter
|
|
usingMask
"
Beside
filter
&
mask
/
clip
-
path
what
else
effect
do
we
have
?
"
)
;
if
(
clipCapturedBy
=
=
ContainerItemType
:
:
eFilter
)
{
clipState
.
Restore
(
)
;
}
aBuilder
-
>
SetVisibleRect
(
visibleRectOutsideSVGEffects
)
;
if
(
usingFilter
&
&
!
aBuilder
-
>
IsForGenerateGlyphMask
(
)
)
{
resultList
.
AppendToTop
(
MakeDisplayItem
<
nsDisplayFilters
>
(
aBuilder
this
&
resultList
)
)
;
ct
.
TrackContainer
(
resultList
.
GetTop
(
)
)
;
}
if
(
usingMask
)
{
DisplayListClipState
:
:
AutoSaveRestore
maskClipState
(
aBuilder
)
;
const
ActiveScrolledRoot
*
maskASR
=
clipForMask
.
isSome
(
)
?
aBuilder
-
>
CurrentActiveScrolledRoot
(
)
:
containerItemASR
;
resultList
.
AppendToTop
(
MakeDisplayItem
<
nsDisplayMasksAndClipPaths
>
(
aBuilder
this
&
resultList
maskASR
)
)
;
ct
.
TrackContainer
(
resultList
.
GetTop
(
)
)
;
}
ct
.
ResetCreatedContainer
(
)
;
aBuilder
-
>
ExitSVGEffectsContents
(
)
;
resultList
.
AppendToTop
(
&
hoistedScrollInfoItemsStorage
)
;
}
if
(
useOpacity
)
{
DisplayListClipState
:
:
AutoSaveRestore
opacityClipState
(
aBuilder
)
;
const
bool
needsActiveOpacityLayer
=
nsDisplayOpacity
:
:
NeedsActiveLayer
(
aBuilder
this
)
;
resultList
.
AppendToTop
(
MakeDisplayItem
<
nsDisplayOpacity
>
(
aBuilder
this
&
resultList
containerItemASR
opacityItemForEventsAndPluginsOnly
needsActiveOpacityLayer
)
)
;
ct
.
TrackContainer
(
resultList
.
GetTop
(
)
)
;
}
if
(
isTransformed
&
&
extend3DContext
)
{
nsDisplayList
nonparticipants
;
nsDisplayList
participants
;
int
index
=
1
;
nsDisplayItem
*
separator
=
nullptr
;
while
(
nsDisplayItem
*
item
=
resultList
.
RemoveBottom
(
)
)
{
if
(
ItemParticipatesIn3DContext
(
this
item
)
&
&
!
item
-
>
GetClip
(
)
.
HasClip
(
)
)
{
WrapSeparatorTransform
(
aBuilder
this
&
nonparticipants
&
participants
index
+
+
&
separator
)
;
participants
.
AppendToTop
(
item
)
;
}
else
{
nonparticipants
.
AppendToTop
(
item
)
;
}
}
WrapSeparatorTransform
(
aBuilder
this
&
nonparticipants
&
participants
index
+
+
&
separator
)
;
if
(
separator
)
{
ct
.
TrackContainer
(
separator
)
;
}
resultList
.
AppendToTop
(
&
participants
)
;
}
if
(
isTransformed
)
{
transformedCssClip
.
Restore
(
)
;
if
(
clipCapturedBy
=
=
ContainerItemType
:
:
eTransform
)
{
clipState
.
Restore
(
)
;
}
aBuilder
-
>
SetVisibleRect
(
visibleRectOutsideTransform
)
;
nsPoint
toOuterReferenceFrame
;
const
nsIFrame
*
outerReferenceFrame
=
this
;
if
(
this
!
=
aBuilder
-
>
RootReferenceFrame
(
)
)
{
outerReferenceFrame
=
aBuilder
-
>
FindReferenceFrameFor
(
GetParent
(
)
&
toOuterReferenceFrame
)
;
}
buildingDisplayList
.
SetReferenceFrameAndCurrentOffset
(
outerReferenceFrame
GetOffsetToCrossDoc
(
outerReferenceFrame
)
)
;
nsDisplayTransform
*
transformItem
=
MakeDisplayItem
<
nsDisplayTransform
>
(
aBuilder
this
&
resultList
visibleRect
0
allowAsyncAnimation
)
;
resultList
.
AppendToTop
(
transformItem
)
;
ct
.
TrackContainer
(
transformItem
)
;
if
(
hasPerspective
)
{
if
(
clipCapturedBy
=
=
ContainerItemType
:
:
ePerspective
)
{
clipState
.
Restore
(
)
;
}
resultList
.
AppendToTop
(
MakeDisplayItem
<
nsDisplayPerspective
>
(
aBuilder
this
&
resultList
)
)
;
ct
.
TrackContainer
(
resultList
.
GetTop
(
)
)
;
}
}
if
(
clipCapturedBy
=
=
ContainerItemType
:
:
eOwnLayerForTransformWithRoundedClip
)
{
clipState
.
Restore
(
)
;
resultList
.
AppendToTop
(
MakeDisplayItem
<
nsDisplayOwnLayer
>
(
aBuilder
this
&
resultList
aBuilder
-
>
CurrentActiveScrolledRoot
(
)
nsDisplayOwnLayerFlags
:
:
eNone
ScrollbarData
{
}
false
)
)
;
ct
.
TrackContainer
(
resultList
.
GetTop
(
)
)
;
}
if
(
useFixedPosition
)
{
if
(
clipCapturedBy
=
=
ContainerItemType
:
:
eFixedPosition
)
{
clipState
.
Restore
(
)
;
}
const
ActiveScrolledRoot
*
fixedASR
=
ActiveScrolledRoot
:
:
PickAncestor
(
containerItemASR
aBuilder
-
>
CurrentActiveScrolledRoot
(
)
)
;
resultList
.
AppendToTop
(
MakeDisplayItem
<
nsDisplayFixedPosition
>
(
aBuilder
this
&
resultList
fixedASR
containerItemASR
)
)
;
ct
.
TrackContainer
(
resultList
.
GetTop
(
)
)
;
}
else
if
(
useStickyPosition
)
{
const
ActiveScrolledRoot
*
stickyASR
=
ActiveScrolledRoot
:
:
PickAncestor
(
containerItemASR
aBuilder
-
>
CurrentActiveScrolledRoot
(
)
)
;
resultList
.
AppendToTop
(
MakeDisplayItem
<
nsDisplayStickyPosition
>
(
aBuilder
this
&
resultList
stickyASR
aBuilder
-
>
CurrentActiveScrolledRoot
(
)
)
)
;
ct
.
TrackContainer
(
resultList
.
GetTop
(
)
)
;
}
if
(
useBlendMode
)
{
DisplayListClipState
:
:
AutoSaveRestore
blendModeClipState
(
aBuilder
)
;
resultList
.
AppendToTop
(
MakeDisplayItem
<
nsDisplayBlendMode
>
(
aBuilder
this
&
resultList
effects
-
>
mMixBlendMode
containerItemASR
)
)
;
ct
.
TrackContainer
(
resultList
.
GetTop
(
)
)
;
}
bool
createdOwnLayer
=
false
;
CreateOwnLayerIfNeeded
(
aBuilder
&
resultList
&
createdOwnLayer
)
;
if
(
createdOwnLayer
)
{
ct
.
TrackContainer
(
resultList
.
GetTop
(
)
)
;
}
if
(
aCreatedContainerItem
)
{
*
aCreatedContainerItem
=
ct
.
mCreatedContainer
;
}
if
(
hitTestInfo
)
{
MOZ_ASSERT
(
!
gfxVars
:
:
UseWebRender
(
)
)
;
AddHitTestInfo
(
aBuilder
&
resultList
ct
.
mContainer
this
std
:
:
move
(
hitTestInfo
)
)
;
}
aList
-
>
AppendToTop
(
&
resultList
)
;
}
static
nsDisplayItem
*
WrapInWrapList
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
const
ActiveScrolledRoot
*
aContainerASR
bool
aCanSkipWrapList
=
false
)
{
nsDisplayItem
*
item
=
aList
-
>
GetBottom
(
)
;
if
(
!
item
)
{
return
nullptr
;
}
if
(
aCanSkipWrapList
)
{
MOZ_ASSERT
(
!
item
-
>
GetAbove
(
)
)
;
aList
-
>
RemoveBottom
(
)
;
return
item
;
}
return
MakeDisplayItem
<
nsDisplayWrapList
>
(
aBuilder
aFrame
aList
aContainerASR
true
)
;
}
static
bool
DescendIntoChild
(
nsDisplayListBuilder
*
aBuilder
const
nsIFrame
*
aChild
const
nsRect
&
aVisible
const
nsRect
&
aDirty
)
{
if
(
aChild
-
>
GetStateBits
(
)
&
NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO
)
{
return
true
;
}
if
(
aChild
=
=
aBuilder
-
>
GetIgnoreScrollFrame
(
)
)
{
return
true
;
}
if
(
aChild
=
=
aBuilder
-
>
GetPresShellIgnoreScrollFrame
(
)
)
{
return
true
;
}
const
nsRect
overflow
=
aChild
-
>
GetVisualOverflowRect
(
)
;
if
(
aDirty
.
Intersects
(
overflow
)
)
{
return
true
;
}
if
(
aChild
-
>
ForceDescendIntoIfVisible
(
)
&
&
aVisible
.
Intersects
(
overflow
)
)
{
return
true
;
}
return
false
;
}
void
nsIFrame
:
:
BuildDisplayListForSimpleChild
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aChild
const
nsDisplayListSet
&
aLists
)
{
MOZ_ASSERT
(
aChild
-
>
Type
(
)
!
=
LayoutFrameType
:
:
Placeholder
)
;
MOZ_ASSERT
(
!
aBuilder
-
>
GetSelectedFramesOnly
(
)
&
&
!
aBuilder
-
>
GetIncludeAllOutOfFlows
(
)
"
It
should
be
held
for
painting
to
window
"
)
;
MOZ_ASSERT
(
aChild
-
>
GetStateBits
(
)
&
NS_FRAME_SIMPLE_DISPLAYLIST
)
;
const
nsPoint
offset
=
aChild
-
>
GetOffsetTo
(
this
)
;
const
nsRect
visible
=
aBuilder
-
>
GetVisibleRect
(
)
-
offset
;
const
nsRect
dirty
=
aBuilder
-
>
GetDirtyRect
(
)
-
offset
;
if
(
!
DescendIntoChild
(
aBuilder
aChild
visible
dirty
)
)
{
return
;
}
nsDisplayListBuilder
:
:
AutoBuildingDisplayList
buildingForChild
(
aBuilder
aChild
visible
dirty
false
)
;
CheckForApzAwareEventHandlers
(
aBuilder
aChild
)
;
aBuilder
-
>
BuildCompositorHitTestInfoIfNeeded
(
aChild
aLists
.
BorderBackground
(
)
buildingForChild
.
IsAnimatedGeometryRoot
(
)
)
;
aChild
-
>
MarkAbsoluteFramesForDisplayList
(
aBuilder
)
;
aBuilder
-
>
AdjustWindowDraggingRegion
(
aChild
)
;
aBuilder
-
>
Check
(
)
;
aChild
-
>
BuildDisplayList
(
aBuilder
aLists
)
;
aBuilder
-
>
Check
(
)
;
aBuilder
-
>
DisplayCaret
(
aChild
aLists
.
Content
(
)
)
;
#
ifdef
DEBUG
DisplayDebugBorders
(
aBuilder
aChild
aLists
)
;
#
endif
}
static
bool
ShouldSkipFrame
(
nsDisplayListBuilder
*
aBuilder
const
nsIFrame
*
aFrame
)
{
if
(
aBuilder
-
>
IsBackgroundOnly
(
)
)
{
return
true
;
}
if
(
aBuilder
-
>
IsForGenerateGlyphMask
(
)
&
&
(
!
aFrame
-
>
IsTextFrame
(
)
&
&
aFrame
-
>
IsLeaf
(
)
)
)
{
return
true
;
}
if
(
aBuilder
-
>
GetSelectedFramesOnly
(
)
&
&
(
aFrame
-
>
IsLeaf
(
)
&
&
!
aFrame
-
>
IsSelected
(
)
)
)
{
return
true
;
}
static
const
nsFrameState
skipFlags
=
(
NS_FRAME_TOO_DEEP_IN_FRAME_TREE
|
NS_FRAME_IS_NONDISPLAY
)
;
return
(
aFrame
-
>
GetStateBits
(
)
&
skipFlags
)
;
}
void
nsIFrame
:
:
BuildDisplayListForChild
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aChild
const
nsDisplayListSet
&
aLists
uint32_t
aFlags
)
{
AutoCheckBuilder
check
(
aBuilder
)
;
if
(
ShouldSkipFrame
(
aBuilder
aChild
)
)
{
return
;
}
nsIFrame
*
child
=
aChild
;
aBuilder
-
>
RemoveFromWillChangeBudget
(
child
)
;
const
bool
isPaintingToWindow
=
aBuilder
-
>
IsPaintingToWindow
(
)
;
const
bool
doingShortcut
=
isPaintingToWindow
&
&
(
child
-
>
GetStateBits
(
)
&
NS_FRAME_SIMPLE_DISPLAYLIST
)
&
&
!
(
child
-
>
MayHaveTransformAnimation
(
)
|
|
child
-
>
MayHaveOpacityAnimation
(
)
)
;
if
(
StaticPrefs
:
:
layout_css_scroll_anchoring_highlight
(
)
)
{
if
(
child
-
>
FirstContinuation
(
)
-
>
IsScrollAnchor
(
)
)
{
nsRect
bounds
=
child
-
>
GetContentRectRelativeToSelf
(
)
+
aBuilder
-
>
ToReferenceFrame
(
child
)
;
nsDisplaySolidColor
*
color
=
MakeDisplayItem
<
nsDisplaySolidColor
>
(
aBuilder
child
bounds
NS_RGBA
(
255
0
255
64
)
)
;
color
-
>
SetOverrideZIndex
(
INT32_MAX
)
;
aLists
.
PositionedDescendants
(
)
-
>
AppendToTop
(
color
)
;
}
}
if
(
doingShortcut
)
{
BuildDisplayListForSimpleChild
(
aBuilder
child
aLists
)
;
return
;
}
NS_ASSERTION
(
aBuilder
-
>
GetCurrentFrame
(
)
=
=
this
"
Wrong
coord
space
!
"
)
;
const
nsPoint
offset
=
child
-
>
GetOffsetTo
(
this
)
;
nsRect
visible
=
aBuilder
-
>
GetVisibleRect
(
)
-
offset
;
nsRect
dirty
=
aBuilder
-
>
GetDirtyRect
(
)
-
offset
;
nsDisplayListBuilder
:
:
OutOfFlowDisplayData
*
savedOutOfFlowData
=
nullptr
;
const
bool
isPlaceholder
=
child
-
>
IsPlaceholderFrame
(
)
;
if
(
isPlaceholder
)
{
nsPlaceholderFrame
*
placeholder
=
static_cast
<
nsPlaceholderFrame
*
>
(
child
)
;
if
(
placeholder
-
>
GetStateBits
(
)
&
PLACEHOLDER_FOR_TOPLAYER
)
{
return
;
}
child
=
placeholder
-
>
GetOutOfFlowFrame
(
)
;
NS_ASSERTION
(
child
"
No
out
of
flow
frame
?
"
)
;
if
(
child
)
{
aBuilder
-
>
RemoveFromWillChangeBudget
(
child
)
;
}
static
const
nsFrameState
skipFlags
=
(
NS_FRAME_IS_PUSHED_FLOAT
|
NS_FRAME_TOO_DEEP_IN_FRAME_TREE
|
NS_FRAME_IS_NONDISPLAY
)
;
if
(
!
child
|
|
(
child
-
>
GetStateBits
(
)
&
skipFlags
)
|
|
nsLayoutUtils
:
:
IsPopup
(
child
)
)
{
return
;
}
MOZ_ASSERT
(
child
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
;
savedOutOfFlowData
=
nsDisplayListBuilder
:
:
GetOutOfFlowData
(
child
)
;
if
(
aBuilder
-
>
GetIncludeAllOutOfFlows
(
)
)
{
visible
=
child
-
>
GetVisualOverflowRect
(
)
;
dirty
=
child
-
>
GetVisualOverflowRect
(
)
;
}
else
if
(
savedOutOfFlowData
)
{
visible
=
savedOutOfFlowData
-
>
GetVisibleRectForFrame
(
aBuilder
child
&
dirty
)
;
}
else
{
visible
.
SetEmpty
(
)
;
dirty
.
SetEmpty
(
)
;
}
}
NS_ASSERTION
(
!
child
-
>
IsPlaceholderFrame
(
)
"
Should
have
dealt
with
placeholders
already
"
)
;
if
(
!
DescendIntoChild
(
aBuilder
child
visible
dirty
)
)
{
return
;
}
const
bool
isSVG
=
child
-
>
GetStateBits
(
)
&
NS_FRAME_SVG_LAYOUT
;
bool
awayFromCommonPath
=
!
isPaintingToWindow
;
bool
pseudoStackingContext
=
(
aFlags
&
DISPLAY_CHILD_FORCE_PSEUDO_STACKING_CONTEXT
)
!
=
0
;
if
(
!
pseudoStackingContext
&
&
!
isSVG
&
&
(
aFlags
&
DISPLAY_CHILD_INLINE
)
&
&
!
child
-
>
IsFrameOfType
(
eLineParticipant
)
)
{
pseudoStackingContext
=
true
;
}
const
nsStyleDisplay
*
ourDisp
=
StyleDisplay
(
)
;
if
(
IsThemed
(
ourDisp
)
&
&
!
PresContext
(
)
-
>
GetTheme
(
)
-
>
WidgetIsContainer
(
ourDisp
-
>
mAppearance
)
)
return
;
if
(
isPaintingToWindow
&
&
child
-
>
TrackingVisibility
(
)
)
{
child
-
>
PresShell
(
)
-
>
EnsureFrameInApproximatelyVisibleList
(
child
)
;
awayFromCommonPath
=
true
;
}
child
-
>
SetBuiltDisplayList
(
true
)
;
const
nsStyleDisplay
*
disp
=
child
-
>
StyleDisplay
(
)
;
const
nsStyleEffects
*
effects
=
child
-
>
StyleEffects
(
)
;
const
nsStylePosition
*
pos
=
child
-
>
StylePosition
(
)
;
const
bool
isPositioned
=
disp
-
>
IsAbsPosContainingBlock
(
child
)
;
const
bool
isStackingContext
=
(
aFlags
&
DISPLAY_CHILD_FORCE_STACKING_CONTEXT
)
|
|
child
-
>
IsStackingContext
(
disp
pos
effects
isPositioned
)
;
if
(
pseudoStackingContext
|
|
isStackingContext
|
|
isPositioned
|
|
isPlaceholder
|
|
(
!
isSVG
&
&
disp
-
>
IsFloating
(
child
)
)
|
|
(
isSVG
&
&
(
effects
-
>
mClipFlags
&
NS_STYLE_CLIP_RECT
)
&
&
IsSVGContentWithCSSClip
(
child
)
)
)
{
pseudoStackingContext
=
true
;
awayFromCommonPath
=
true
;
}
NS_ASSERTION
(
!
isStackingContext
|
|
pseudoStackingContext
"
Stacking
contexts
must
also
be
pseudo
-
stacking
-
contexts
"
)
;
nsDisplayListBuilder
:
:
AutoBuildingDisplayList
buildingForChild
(
aBuilder
child
visible
dirty
)
;
DisplayListClipState
:
:
AutoClipMultiple
clipState
(
aBuilder
)
;
nsDisplayListBuilder
:
:
AutoCurrentActiveScrolledRootSetter
asrSetter
(
aBuilder
)
;
CheckForApzAwareEventHandlers
(
aBuilder
child
)
;
if
(
savedOutOfFlowData
)
{
aBuilder
-
>
SetBuildingInvisibleItems
(
false
)
;
clipState
.
SetClipChainForContainingBlockDescendants
(
savedOutOfFlowData
-
>
mContainingBlockClipChain
)
;
asrSetter
.
SetCurrentActiveScrolledRoot
(
savedOutOfFlowData
-
>
mContainingBlockActiveScrolledRoot
)
;
MOZ_ASSERT
(
awayFromCommonPath
"
It
is
impossible
when
savedOutOfFlowData
is
true
"
)
;
}
else
if
(
GetStateBits
(
)
&
NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO
&
&
isPlaceholder
)
{
NS_ASSERTION
(
visible
.
IsEmpty
(
)
"
should
have
empty
visible
rect
"
)
;
aBuilder
-
>
SetBuildingInvisibleItems
(
true
)
;
clipState
.
SetClipChainForContainingBlockDescendants
(
nullptr
)
;
}
nsIFrame
*
parent
=
child
-
>
GetParent
(
)
;
const
nsStyleDisplay
*
parentDisp
=
parent
=
=
this
?
ourDisp
:
parent
-
>
StyleDisplay
(
)
;
if
(
ApplyOverflowClipping
(
aBuilder
parent
parentDisp
clipState
)
)
{
awayFromCommonPath
=
true
;
}
nsDisplayList
list
;
nsDisplayList
extraPositionedDescendants
;
const
ActiveScrolledRoot
*
wrapListASR
;
bool
canSkipWrapList
=
false
;
if
(
isStackingContext
)
{
nsDisplayListBuilder
:
:
AutoContainerASRTracker
contASRTracker
(
aBuilder
)
;
child
-
>
BuildDisplayListForStackingContext
(
aBuilder
&
list
&
canSkipWrapList
)
;
wrapListASR
=
contASRTracker
.
GetContainerASR
(
)
;
if
(
aBuilder
-
>
GetCaretFrame
(
)
=
=
child
)
{
canSkipWrapList
=
false
;
}
}
else
{
Maybe
<
nsRect
>
clipPropClip
=
child
-
>
GetClipPropClipRect
(
disp
effects
child
-
>
GetSize
(
)
)
;
if
(
clipPropClip
)
{
aBuilder
-
>
IntersectVisibleRect
(
*
clipPropClip
)
;
aBuilder
-
>
IntersectDirtyRect
(
*
clipPropClip
)
;
clipState
.
ClipContentDescendants
(
*
clipPropClip
+
aBuilder
-
>
ToReferenceFrame
(
child
)
)
;
awayFromCommonPath
=
true
;
}
child
-
>
MarkAbsoluteFramesForDisplayList
(
aBuilder
)
;
const
bool
differentAGR
=
buildingForChild
.
IsAnimatedGeometryRoot
(
)
;
if
(
!
awayFromCommonPath
)
{
child
-
>
AddStateBits
(
NS_FRAME_SIMPLE_DISPLAYLIST
)
;
}
if
(
!
pseudoStackingContext
)
{
aBuilder
-
>
BuildCompositorHitTestInfoIfNeeded
(
child
aLists
.
BorderBackground
(
)
differentAGR
)
;
aBuilder
-
>
AdjustWindowDraggingRegion
(
child
)
;
aBuilder
-
>
Check
(
)
;
child
-
>
BuildDisplayList
(
aBuilder
aLists
)
;
aBuilder
-
>
Check
(
)
;
aBuilder
-
>
DisplayCaret
(
child
aLists
.
Content
(
)
)
;
#
ifdef
DEBUG
DisplayDebugBorders
(
aBuilder
child
aLists
)
;
#
endif
return
;
}
nsDisplayListCollection
pseudoStack
(
aBuilder
)
;
aBuilder
-
>
BuildCompositorHitTestInfoIfNeeded
(
child
pseudoStack
.
BorderBackground
(
)
differentAGR
|
|
isPositioned
)
;
aBuilder
-
>
AdjustWindowDraggingRegion
(
child
)
;
nsDisplayListBuilder
:
:
AutoContainerASRTracker
contASRTracker
(
aBuilder
)
;
aBuilder
-
>
Check
(
)
;
child
-
>
BuildDisplayList
(
aBuilder
pseudoStack
)
;
aBuilder
-
>
Check
(
)
;
if
(
aBuilder
-
>
DisplayCaret
(
child
pseudoStack
.
Content
(
)
)
)
{
canSkipWrapList
=
false
;
}
wrapListASR
=
contASRTracker
.
GetContainerASR
(
)
;
list
.
AppendToTop
(
pseudoStack
.
BorderBackground
(
)
)
;
list
.
AppendToTop
(
pseudoStack
.
BlockBorderBackgrounds
(
)
)
;
list
.
AppendToTop
(
pseudoStack
.
Floats
(
)
)
;
list
.
AppendToTop
(
pseudoStack
.
Content
(
)
)
;
list
.
AppendToTop
(
pseudoStack
.
Outlines
(
)
)
;
extraPositionedDescendants
.
AppendToTop
(
pseudoStack
.
PositionedDescendants
(
)
)
;
#
ifdef
DEBUG
DisplayDebugBorders
(
aBuilder
child
aLists
)
;
#
endif
}
buildingForChild
.
RestoreBuildingInvisibleItemsValue
(
)
;
if
(
isPositioned
|
|
isStackingContext
|
|
(
aFlags
&
DISPLAY_CHILD_FORCE_STACKING_CONTEXT
)
)
{
if
(
!
list
.
IsEmpty
(
)
)
{
nsDisplayItem
*
item
=
WrapInWrapList
(
aBuilder
child
&
list
wrapListASR
canSkipWrapList
)
;
if
(
isSVG
)
{
aLists
.
Content
(
)
-
>
AppendToTop
(
item
)
;
}
else
{
aLists
.
PositionedDescendants
(
)
-
>
AppendToTop
(
item
)
;
}
}
}
else
if
(
!
isSVG
&
&
disp
-
>
IsFloating
(
child
)
)
{
if
(
!
list
.
IsEmpty
(
)
)
{
aLists
.
Floats
(
)
-
>
AppendToTop
(
WrapInWrapList
(
aBuilder
child
&
list
wrapListASR
)
)
;
}
}
else
{
aLists
.
Content
(
)
-
>
AppendToTop
(
&
list
)
;
}
aLists
.
PositionedDescendants
(
)
-
>
AppendToTop
(
&
extraPositionedDescendants
)
;
}
void
nsIFrame
:
:
MarkAbsoluteFramesForDisplayList
(
nsDisplayListBuilder
*
aBuilder
)
{
if
(
IsAbsoluteContainer
(
)
)
{
aBuilder
-
>
MarkFramesForDisplayList
(
this
GetAbsoluteContainingBlock
(
)
-
>
GetChildList
(
)
)
;
}
}
nsresult
nsFrame
:
:
GetContentForEvent
(
WidgetEvent
*
aEvent
nsIContent
*
*
aContent
)
{
nsIFrame
*
f
=
nsLayoutUtils
:
:
GetNonGeneratedAncestor
(
this
)
;
*
aContent
=
f
-
>
GetContent
(
)
;
NS_IF_ADDREF
(
*
aContent
)
;
return
NS_OK
;
}
void
nsFrame
:
:
FireDOMEvent
(
const
nsAString
&
aDOMEventName
nsIContent
*
aContent
)
{
nsIContent
*
target
=
aContent
?
aContent
:
GetContent
(
)
;
if
(
target
)
{
RefPtr
<
AsyncEventDispatcher
>
asyncDispatcher
=
new
AsyncEventDispatcher
(
target
aDOMEventName
CanBubble
:
:
eYes
ChromeOnlyDispatch
:
:
eNo
)
;
DebugOnly
<
nsresult
>
rv
=
asyncDispatcher
-
>
PostDOMEvent
(
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
AsyncEventDispatcher
failed
to
dispatch
"
)
;
}
}
nsresult
nsFrame
:
:
HandleEvent
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
{
if
(
aEvent
-
>
mMessage
=
=
eMouseMove
)
{
return
HandleDrag
(
aPresContext
aEvent
aEventStatus
)
;
}
if
(
(
aEvent
-
>
mClass
=
=
eMouseEventClass
&
&
aEvent
-
>
AsMouseEvent
(
)
-
>
button
=
=
WidgetMouseEvent
:
:
eLeftButton
)
|
|
aEvent
-
>
mClass
=
=
eTouchEventClass
)
{
if
(
aEvent
-
>
mMessage
=
=
eMouseDown
|
|
aEvent
-
>
mMessage
=
=
eTouchStart
)
{
HandlePress
(
aPresContext
aEvent
aEventStatus
)
;
}
else
if
(
aEvent
-
>
mMessage
=
=
eMouseUp
|
|
aEvent
-
>
mMessage
=
=
eTouchEnd
)
{
HandleRelease
(
aPresContext
aEvent
aEventStatus
)
;
}
}
return
NS_OK
;
}
nsresult
nsFrame
:
:
GetDataForTableSelection
(
const
nsFrameSelection
*
aFrameSelection
nsIPresShell
*
aPresShell
WidgetMouseEvent
*
aMouseEvent
nsIContent
*
*
aParentContent
int32_t
*
aContentOffset
TableSelection
*
aTarget
)
{
if
(
!
aFrameSelection
|
|
!
aPresShell
|
|
!
aMouseEvent
|
|
!
aParentContent
|
|
!
aContentOffset
|
|
!
aTarget
)
return
NS_ERROR_NULL_POINTER
;
*
aParentContent
=
nullptr
;
*
aContentOffset
=
0
;
*
aTarget
=
TableSelection
:
:
None
;
int16_t
displaySelection
=
aPresShell
-
>
GetSelectionFlags
(
)
;
bool
selectingTableCells
=
aFrameSelection
-
>
GetTableCellSelection
(
)
;
bool
doTableSelection
=
displaySelection
=
=
nsISelectionDisplay
:
:
DISPLAY_ALL
&
&
selectingTableCells
&
&
(
aMouseEvent
-
>
mMessage
=
=
eMouseMove
|
|
(
aMouseEvent
-
>
mMessage
=
=
eMouseUp
&
&
aMouseEvent
-
>
button
=
=
WidgetMouseEvent
:
:
eLeftButton
)
|
|
aMouseEvent
-
>
IsShift
(
)
)
;
if
(
!
doTableSelection
)
{
#
ifdef
XP_MACOSX
doTableSelection
=
aMouseEvent
-
>
IsMeta
(
)
|
|
(
aMouseEvent
-
>
IsShift
(
)
&
&
selectingTableCells
)
;
#
else
doTableSelection
=
aMouseEvent
-
>
IsControl
(
)
|
|
(
aMouseEvent
-
>
IsShift
(
)
&
&
selectingTableCells
)
;
#
endif
}
if
(
!
doTableSelection
)
return
NS_OK
;
nsIFrame
*
frame
=
this
;
bool
foundCell
=
false
;
bool
foundTable
=
false
;
nsIContent
*
limiter
=
aFrameSelection
-
>
GetLimiter
(
)
;
if
(
limiter
&
&
nsContentUtils
:
:
ContentIsDescendantOf
(
limiter
GetContent
(
)
)
)
return
NS_OK
;
while
(
frame
)
{
nsITableCellLayout
*
cellElement
=
do_QueryFrame
(
frame
)
;
if
(
cellElement
)
{
foundCell
=
true
;
break
;
}
else
{
nsTableWrapperFrame
*
tableFrame
=
do_QueryFrame
(
frame
)
;
if
(
tableFrame
)
{
foundTable
=
true
;
break
;
}
else
{
frame
=
frame
-
>
GetParent
(
)
;
if
(
frame
&
&
frame
-
>
GetContent
(
)
=
=
limiter
)
break
;
}
}
}
if
(
!
foundCell
&
&
!
foundTable
)
return
NS_OK
;
nsIContent
*
tableOrCellContent
=
frame
-
>
GetContent
(
)
;
if
(
!
tableOrCellContent
)
return
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsIContent
>
parentContent
=
tableOrCellContent
-
>
GetParent
(
)
;
if
(
!
parentContent
)
return
NS_ERROR_FAILURE
;
int32_t
offset
=
parentContent
-
>
ComputeIndexOf
(
tableOrCellContent
)
;
if
(
offset
<
0
)
return
NS_ERROR_FAILURE
;
parentContent
.
forget
(
aParentContent
)
;
*
aContentOffset
=
offset
;
#
if
0
if
(
selectRow
)
*
aTarget
=
TableSelection
:
:
Row
;
else
if
(
selectColumn
)
*
aTarget
=
TableSelection
:
:
Column
;
else
#
endif
if
(
foundCell
)
*
aTarget
=
TableSelection
:
:
Cell
;
else
if
(
foundTable
)
*
aTarget
=
TableSelection
:
:
Table
;
return
NS_OK
;
}
static
bool
IsEditingHost
(
const
nsIFrame
*
aFrame
)
{
auto
*
element
=
nsGenericHTMLElement
:
:
FromNodeOrNull
(
aFrame
-
>
GetContent
(
)
)
;
return
element
&
&
element
-
>
IsEditableRoot
(
)
;
}
static
StyleUserSelect
UsedUserSelect
(
const
nsIFrame
*
aFrame
)
{
if
(
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_GENERATED_CONTENT
)
)
{
return
StyleUserSelect
:
:
None
;
}
auto
style
=
aFrame
-
>
StyleUIReset
(
)
-
>
mUserSelect
;
if
(
style
!
=
StyleUserSelect
:
:
Auto
)
{
return
style
;
}
if
(
IsEditingHost
(
aFrame
)
)
{
return
StyleUserSelect
:
:
Text
;
}
auto
*
parent
=
nsLayoutUtils
:
:
GetParentOrPlaceholderFor
(
aFrame
)
;
return
parent
?
UsedUserSelect
(
parent
)
:
StyleUserSelect
:
:
Text
;
}
bool
nsIFrame
:
:
IsSelectable
(
StyleUserSelect
*
aSelectStyle
)
const
{
auto
style
=
UsedUserSelect
(
this
)
;
if
(
aSelectStyle
)
{
*
aSelectStyle
=
style
;
}
return
style
!
=
StyleUserSelect
:
:
None
;
}
NS_IMETHODIMP
nsFrame
:
:
HandlePress
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
{
NS_ENSURE_ARG_POINTER
(
aEventStatus
)
;
if
(
nsEventStatus_eConsumeNoDefault
=
=
*
aEventStatus
)
{
return
NS_OK
;
}
NS_ENSURE_ARG_POINTER
(
aEvent
)
;
if
(
aEvent
-
>
mClass
=
=
eTouchEventClass
)
{
return
NS_OK
;
}
if
(
!
aPresContext
-
>
EventStateManager
(
)
-
>
EventStatusOK
(
aEvent
)
)
return
NS_OK
;
nsIPresShell
*
shell
=
aPresContext
-
>
GetPresShell
(
)
;
if
(
!
shell
)
return
NS_ERROR_FAILURE
;
int16_t
isEditor
=
shell
-
>
GetSelectionFlags
(
)
;
isEditor
=
isEditor
=
=
nsISelectionDisplay
:
:
DISPLAY_ALL
;
WidgetMouseEvent
*
mouseEvent
=
aEvent
-
>
AsMouseEvent
(
)
;
if
(
!
mouseEvent
-
>
IsAlt
(
)
)
{
for
(
nsIContent
*
content
=
mContent
;
content
;
content
=
content
-
>
GetParent
(
)
)
{
if
(
nsContentUtils
:
:
ContentIsDraggable
(
content
)
&
&
!
content
-
>
IsEditable
(
)
)
{
if
(
(
mRect
-
GetPosition
(
)
)
.
Contains
(
nsLayoutUtils
:
:
GetEventCoordinatesRelativeTo
(
mouseEvent
this
)
)
)
{
return
NS_OK
;
}
}
}
}
StyleUserSelect
selectStyle
;
if
(
!
IsSelectable
(
&
selectStyle
)
)
{
return
NS_OK
;
}
bool
useFrameSelection
=
(
selectStyle
=
=
StyleUserSelect
:
:
Text
)
;
if
(
!
nsIPresShell
:
:
GetCapturingContent
(
)
)
{
nsIScrollableFrame
*
scrollFrame
=
nsLayoutUtils
:
:
GetNearestScrollableFrame
(
this
nsLayoutUtils
:
:
SCROLLABLE_SAME_DOC
|
nsLayoutUtils
:
:
SCROLLABLE_INCLUDE_HIDDEN
)
;
if
(
scrollFrame
)
{
nsIFrame
*
capturingFrame
=
do_QueryFrame
(
scrollFrame
)
;
nsIPresShell
:
:
SetCapturingContent
(
capturingFrame
-
>
GetContent
(
)
CAPTURE_IGNOREALLOWED
)
;
}
}
const
nsFrameSelection
*
frameselection
=
nullptr
;
if
(
useFrameSelection
)
frameselection
=
GetConstFrameSelection
(
)
;
else
frameselection
=
shell
-
>
ConstFrameSelection
(
)
;
if
(
!
frameselection
|
|
frameselection
-
>
GetDisplaySelection
(
)
=
=
nsISelectionController
:
:
SELECTION_OFF
)
return
NS_OK
;
#
ifdef
XP_MACOSX
if
(
mouseEvent
-
>
IsControl
(
)
)
return
NS_OK
;
bool
control
=
mouseEvent
-
>
IsMeta
(
)
;
#
else
bool
control
=
mouseEvent
-
>
IsControl
(
)
;
#
endif
RefPtr
<
nsFrameSelection
>
fc
=
const_cast
<
nsFrameSelection
*
>
(
frameselection
)
;
if
(
mouseEvent
-
>
mClickCount
>
1
)
{
fc
-
>
SetDragState
(
true
)
;
fc
-
>
SetMouseDoubleDown
(
true
)
;
return
HandleMultiplePress
(
aPresContext
mouseEvent
aEventStatus
control
)
;
}
nsPoint
pt
=
nsLayoutUtils
:
:
GetEventCoordinatesRelativeTo
(
mouseEvent
this
)
;
ContentOffsets
offsets
=
GetContentOffsetsFromPoint
(
pt
SKIP_HIDDEN
)
;
if
(
!
offsets
.
content
)
return
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsIContent
>
parentContent
;
int32_t
contentOffset
;
TableSelection
target
;
nsresult
rv
;
rv
=
GetDataForTableSelection
(
frameselection
shell
mouseEvent
getter_AddRefs
(
parentContent
)
&
contentOffset
&
target
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
parentContent
)
{
fc
-
>
SetDragState
(
true
)
;
return
fc
-
>
HandleTableSelection
(
parentContent
contentOffset
target
mouseEvent
)
;
}
fc
-
>
SetDelayedCaretData
(
0
)
;
if
(
GetContent
(
)
&
&
GetContent
(
)
-
>
IsSelectionDescendant
(
)
)
{
bool
inSelection
=
false
;
UniquePtr
<
SelectionDetails
>
details
=
frameselection
-
>
LookUpSelection
(
offsets
.
content
0
offsets
.
EndOffset
(
)
false
)
;
for
(
SelectionDetails
*
curDetail
=
details
.
get
(
)
;
curDetail
;
curDetail
=
curDetail
-
>
mNext
.
get
(
)
)
{
if
(
curDetail
-
>
mSelectionType
!
=
SelectionType
:
:
eSpellCheck
&
&
curDetail
-
>
mSelectionType
!
=
SelectionType
:
:
eFind
&
&
curDetail
-
>
mSelectionType
!
=
SelectionType
:
:
eURLSecondary
&
&
curDetail
-
>
mSelectionType
!
=
SelectionType
:
:
eURLStrikeout
&
&
curDetail
-
>
mStart
<
=
offsets
.
StartOffset
(
)
&
&
offsets
.
EndOffset
(
)
<
=
curDetail
-
>
mEnd
)
{
inSelection
=
true
;
}
}
if
(
inSelection
)
{
fc
-
>
SetDragState
(
false
)
;
fc
-
>
SetDelayedCaretData
(
mouseEvent
)
;
return
NS_OK
;
}
}
fc
-
>
SetDragState
(
true
)
;
rv
=
fc
-
>
HandleClick
(
offsets
.
content
offsets
.
StartOffset
(
)
offsets
.
EndOffset
(
)
mouseEvent
-
>
IsShift
(
)
control
offsets
.
associate
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
offsets
.
offset
!
=
offsets
.
secondaryOffset
)
fc
-
>
MaintainSelection
(
)
;
if
(
isEditor
&
&
!
mouseEvent
-
>
IsShift
(
)
&
&
(
offsets
.
EndOffset
(
)
-
offsets
.
StartOffset
(
)
)
=
=
1
)
{
fc
-
>
SetDragState
(
false
)
;
}
return
rv
;
}
nsresult
nsFrame
:
:
SelectByTypeAtPoint
(
nsPresContext
*
aPresContext
const
nsPoint
&
aPoint
nsSelectionAmount
aBeginAmountType
nsSelectionAmount
aEndAmountType
uint32_t
aSelectFlags
)
{
NS_ENSURE_ARG_POINTER
(
aPresContext
)
;
if
(
DisplaySelection
(
aPresContext
)
=
=
nsISelectionController
:
:
SELECTION_OFF
)
return
NS_OK
;
ContentOffsets
offsets
=
GetContentOffsetsFromPoint
(
aPoint
SKIP_HIDDEN
)
;
if
(
!
offsets
.
content
)
return
NS_ERROR_FAILURE
;
int32_t
offset
;
const
nsFrameSelection
*
frameSelection
=
PresContext
(
)
-
>
GetPresShell
(
)
-
>
ConstFrameSelection
(
)
;
nsIFrame
*
theFrame
=
frameSelection
-
>
GetFrameForNodeOffset
(
offsets
.
content
offsets
.
offset
offsets
.
associate
&
offset
)
;
if
(
!
theFrame
)
return
NS_ERROR_FAILURE
;
nsFrame
*
frame
=
static_cast
<
nsFrame
*
>
(
theFrame
)
;
return
frame
-
>
PeekBackwardAndForward
(
aBeginAmountType
aEndAmountType
offset
aBeginAmountType
!
=
eSelectWord
aSelectFlags
)
;
}
NS_IMETHODIMP
nsFrame
:
:
HandleMultiplePress
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
bool
aControlHeld
)
{
NS_ENSURE_ARG_POINTER
(
aEvent
)
;
NS_ENSURE_ARG_POINTER
(
aEventStatus
)
;
if
(
nsEventStatus_eConsumeNoDefault
=
=
*
aEventStatus
|
|
DisplaySelection
(
aPresContext
)
=
=
nsISelectionController
:
:
SELECTION_OFF
)
{
return
NS_OK
;
}
nsSelectionAmount
beginAmount
endAmount
;
WidgetMouseEvent
*
mouseEvent
=
aEvent
-
>
AsMouseEvent
(
)
;
if
(
!
mouseEvent
)
{
return
NS_OK
;
}
if
(
mouseEvent
-
>
mClickCount
=
=
4
)
{
beginAmount
=
endAmount
=
eSelectParagraph
;
}
else
if
(
mouseEvent
-
>
mClickCount
=
=
3
)
{
if
(
Preferences
:
:
GetBool
(
"
browser
.
triple_click_selects_paragraph
"
)
)
{
beginAmount
=
endAmount
=
eSelectParagraph
;
}
else
{
beginAmount
=
eSelectBeginLine
;
endAmount
=
eSelectEndLine
;
}
}
else
if
(
mouseEvent
-
>
mClickCount
=
=
2
)
{
beginAmount
=
endAmount
=
eSelectWord
;
}
else
{
return
NS_OK
;
}
nsPoint
relPoint
=
nsLayoutUtils
:
:
GetEventCoordinatesRelativeTo
(
mouseEvent
this
)
;
return
SelectByTypeAtPoint
(
aPresContext
relPoint
beginAmount
endAmount
(
aControlHeld
?
SELECT_ACCUMULATE
:
0
)
)
;
}
nsresult
nsFrame
:
:
PeekBackwardAndForward
(
nsSelectionAmount
aAmountBack
nsSelectionAmount
aAmountForward
int32_t
aStartPos
bool
aJumpLines
uint32_t
aSelectFlags
)
{
nsIFrame
*
baseFrame
=
this
;
int32_t
baseOffset
=
aStartPos
;
nsresult
rv
;
if
(
aAmountBack
=
=
eSelectWord
)
{
nsPeekOffsetStruct
pos
(
eSelectCharacter
eDirNext
aStartPos
nsPoint
(
0
0
)
aJumpLines
true
false
false
false
)
;
rv
=
PeekOffset
(
&
pos
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
baseFrame
=
pos
.
mResultFrame
;
baseOffset
=
pos
.
mContentOffset
;
}
}
nsPeekOffsetStruct
startpos
(
aAmountBack
eDirPrevious
baseOffset
nsPoint
(
0
0
)
aJumpLines
true
false
false
false
)
;
rv
=
baseFrame
-
>
PeekOffset
(
&
startpos
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsPeekOffsetStruct
endpos
(
aAmountForward
eDirNext
aStartPos
nsPoint
(
0
0
)
aJumpLines
true
false
false
false
)
;
rv
=
PeekOffset
(
&
endpos
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
RefPtr
<
nsFrameSelection
>
frameSelection
=
GetFrameSelection
(
)
;
rv
=
frameSelection
-
>
HandleClick
(
startpos
.
mResultContent
startpos
.
mContentOffset
startpos
.
mContentOffset
false
(
aSelectFlags
&
SELECT_ACCUMULATE
)
CARET_ASSOCIATE_AFTER
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
frameSelection
-
>
HandleClick
(
endpos
.
mResultContent
endpos
.
mContentOffset
endpos
.
mContentOffset
true
false
CARET_ASSOCIATE_BEFORE
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
return
frameSelection
-
>
MaintainSelection
(
aAmountBack
)
;
}
NS_IMETHODIMP
nsFrame
:
:
HandleDrag
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
{
MOZ_ASSERT
(
aEvent
-
>
mClass
=
=
eMouseEventClass
"
HandleDrag
can
only
handle
mouse
event
"
)
;
RefPtr
<
nsFrameSelection
>
frameselection
=
GetFrameSelection
(
)
;
bool
mouseDown
=
frameselection
-
>
GetDragState
(
)
;
if
(
!
mouseDown
)
{
return
NS_OK
;
}
nsIFrame
*
scrollbar
=
nsLayoutUtils
:
:
GetClosestFrameOfType
(
this
LayoutFrameType
:
:
Scrollbar
)
;
if
(
!
scrollbar
)
{
if
(
DisplaySelection
(
aPresContext
)
=
=
nsISelectionController
:
:
SELECTION_OFF
)
{
return
NS_OK
;
}
}
frameselection
-
>
StopAutoScrollTimer
(
)
;
nsCOMPtr
<
nsIContent
>
parentContent
;
int32_t
contentOffset
;
TableSelection
target
;
WidgetMouseEvent
*
mouseEvent
=
aEvent
-
>
AsMouseEvent
(
)
;
nsCOMPtr
<
nsIPresShell
>
presShell
=
aPresContext
-
>
PresShell
(
)
;
nsresult
result
;
result
=
GetDataForTableSelection
(
frameselection
presShell
mouseEvent
getter_AddRefs
(
parentContent
)
&
contentOffset
&
target
)
;
AutoWeakFrame
weakThis
=
this
;
if
(
NS_SUCCEEDED
(
result
)
&
&
parentContent
)
{
frameselection
-
>
HandleTableSelection
(
parentContent
contentOffset
target
mouseEvent
)
;
}
else
{
nsPoint
pt
=
nsLayoutUtils
:
:
GetEventCoordinatesRelativeTo
(
mouseEvent
this
)
;
frameselection
-
>
HandleDrag
(
this
pt
)
;
}
if
(
!
weakThis
.
IsAlive
(
)
)
{
return
NS_OK
;
}
nsIScrollableFrame
*
scrollFrame
=
nsLayoutUtils
:
:
GetNearestScrollableFrame
(
this
nsLayoutUtils
:
:
SCROLLABLE_SAME_DOC
|
nsLayoutUtils
:
:
SCROLLABLE_INCLUDE_HIDDEN
)
;
if
(
scrollFrame
)
{
nsIFrame
*
capturingFrame
=
scrollFrame
-
>
GetScrolledFrame
(
)
;
if
(
capturingFrame
)
{
nsPoint
pt
=
nsLayoutUtils
:
:
GetEventCoordinatesRelativeTo
(
mouseEvent
capturingFrame
)
;
frameselection
-
>
StartAutoScrollTimer
(
capturingFrame
pt
30
)
;
}
}
return
NS_OK
;
}
static
nsresult
HandleFrameSelection
(
nsFrameSelection
*
aFrameSelection
nsIFrame
:
:
ContentOffsets
&
aOffsets
bool
aHandleTableSel
int32_t
aContentOffsetForTableSel
TableSelection
aTargetForTableSel
nsIContent
*
aParentContentForTableSel
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
{
if
(
!
aFrameSelection
)
{
return
NS_OK
;
}
nsresult
rv
=
NS_OK
;
if
(
nsEventStatus_eConsumeNoDefault
!
=
*
aEventStatus
)
{
if
(
!
aHandleTableSel
)
{
if
(
!
aOffsets
.
content
|
|
!
aFrameSelection
-
>
HasDelayedCaretData
(
)
)
{
return
NS_ERROR_FAILURE
;
}
aFrameSelection
-
>
SetDragState
(
true
)
;
rv
=
aFrameSelection
-
>
HandleClick
(
aOffsets
.
content
aOffsets
.
StartOffset
(
)
aOffsets
.
EndOffset
(
)
aFrameSelection
-
>
IsShiftDownInDelayedCaretData
(
)
false
aOffsets
.
associate
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
else
if
(
aParentContentForTableSel
)
{
aFrameSelection
-
>
SetDragState
(
false
)
;
rv
=
aFrameSelection
-
>
HandleTableSelection
(
aParentContentForTableSel
aContentOffsetForTableSel
aTargetForTableSel
aEvent
-
>
AsMouseEvent
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
aFrameSelection
-
>
SetDelayedCaretData
(
0
)
;
}
aFrameSelection
-
>
SetDragState
(
false
)
;
aFrameSelection
-
>
StopAutoScrollTimer
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsFrame
:
:
HandleRelease
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
{
if
(
aEvent
-
>
mClass
!
=
eMouseEventClass
)
{
return
NS_OK
;
}
nsIFrame
*
activeFrame
=
GetActiveSelectionFrame
(
aPresContext
this
)
;
nsCOMPtr
<
nsIContent
>
captureContent
=
nsIPresShell
:
:
GetCapturingContent
(
)
;
nsIPresShell
:
:
SetCapturingContent
(
nullptr
0
)
;
bool
selectionOff
=
(
DisplaySelection
(
aPresContext
)
=
=
nsISelectionController
:
:
SELECTION_OFF
)
;
RefPtr
<
nsFrameSelection
>
frameselection
;
ContentOffsets
offsets
;
nsCOMPtr
<
nsIContent
>
parentContent
;
int32_t
contentOffsetForTableSel
=
0
;
TableSelection
targetForTableSel
=
TableSelection
:
:
None
;
bool
handleTableSelection
=
true
;
if
(
!
selectionOff
)
{
frameselection
=
GetFrameSelection
(
)
;
if
(
nsEventStatus_eConsumeNoDefault
!
=
*
aEventStatus
&
&
frameselection
)
{
if
(
frameselection
-
>
MouseDownRecorded
(
)
)
{
nsPoint
pt
=
nsLayoutUtils
:
:
GetEventCoordinatesRelativeTo
(
aEvent
this
)
;
offsets
=
GetContentOffsetsFromPoint
(
pt
SKIP_HIDDEN
)
;
handleTableSelection
=
false
;
}
else
{
GetDataForTableSelection
(
frameselection
PresShell
(
)
aEvent
-
>
AsMouseEvent
(
)
getter_AddRefs
(
parentContent
)
&
contentOffsetForTableSel
&
targetForTableSel
)
;
}
}
}
RefPtr
<
nsFrameSelection
>
frameSelection
;
if
(
activeFrame
!
=
this
&
&
static_cast
<
nsFrame
*
>
(
activeFrame
)
-
>
DisplaySelection
(
activeFrame
-
>
PresContext
(
)
)
!
=
nsISelectionController
:
:
SELECTION_OFF
)
{
frameSelection
=
activeFrame
-
>
GetFrameSelection
(
)
;
}
if
(
!
frameSelection
&
&
captureContent
)
{
Document
*
doc
=
captureContent
-
>
GetUncomposedDoc
(
)
;
if
(
doc
)
{
nsIPresShell
*
capturingShell
=
doc
-
>
GetShell
(
)
;
if
(
capturingShell
&
&
capturingShell
!
=
PresContext
(
)
-
>
GetPresShell
(
)
)
{
frameSelection
=
capturingShell
-
>
FrameSelection
(
)
;
}
}
}
if
(
frameSelection
)
{
frameSelection
-
>
SetDragState
(
false
)
;
frameSelection
-
>
StopAutoScrollTimer
(
)
;
nsIScrollableFrame
*
scrollFrame
=
nsLayoutUtils
:
:
GetNearestScrollableFrame
(
this
nsLayoutUtils
:
:
SCROLLABLE_SAME_DOC
|
nsLayoutUtils
:
:
SCROLLABLE_INCLUDE_HIDDEN
)
;
if
(
scrollFrame
)
{
scrollFrame
-
>
ScrollSnap
(
)
;
}
}
return
selectionOff
?
NS_OK
:
HandleFrameSelection
(
frameselection
offsets
handleTableSelection
contentOffsetForTableSel
targetForTableSel
parentContent
aEvent
aEventStatus
)
;
}
struct
MOZ_STACK_CLASS
FrameContentRange
{
FrameContentRange
(
nsIContent
*
aContent
int32_t
aStart
int32_t
aEnd
)
:
content
(
aContent
)
start
(
aStart
)
end
(
aEnd
)
{
}
nsCOMPtr
<
nsIContent
>
content
;
int32_t
start
;
int32_t
end
;
}
;
static
FrameContentRange
GetRangeForFrame
(
nsIFrame
*
aFrame
)
{
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
!
content
)
{
NS_WARNING
(
"
Frame
has
no
content
"
)
;
return
FrameContentRange
(
nullptr
-
1
-
1
)
;
}
LayoutFrameType
type
=
aFrame
-
>
Type
(
)
;
if
(
type
=
=
LayoutFrameType
:
:
Text
)
{
int32_t
offset
offsetEnd
;
aFrame
-
>
GetOffsets
(
offset
offsetEnd
)
;
return
FrameContentRange
(
content
offset
offsetEnd
)
;
}
if
(
type
=
=
LayoutFrameType
:
:
Br
)
{
nsIContent
*
parent
=
content
-
>
GetParent
(
)
;
int32_t
beginOffset
=
parent
-
>
ComputeIndexOf
(
content
)
;
return
FrameContentRange
(
parent
beginOffset
beginOffset
)
;
}
while
(
content
-
>
IsRootOfAnonymousSubtree
(
)
)
{
content
=
content
-
>
GetParent
(
)
;
}
nsIContent
*
parent
=
content
-
>
GetParent
(
)
;
if
(
aFrame
-
>
IsBlockFrameOrSubclass
(
)
|
|
!
parent
)
{
return
FrameContentRange
(
content
0
content
-
>
GetChildCount
(
)
)
;
}
int32_t
index
=
parent
-
>
ComputeIndexOf
(
content
)
;
MOZ_ASSERT
(
index
>
=
0
)
;
return
FrameContentRange
(
parent
index
index
+
1
)
;
}
struct
FrameTarget
{
FrameTarget
(
nsIFrame
*
aFrame
bool
aFrameEdge
bool
aAfterFrame
)
:
frame
(
aFrame
)
frameEdge
(
aFrameEdge
)
afterFrame
(
aAfterFrame
)
{
}
static
FrameTarget
Null
(
)
{
return
FrameTarget
(
nullptr
false
false
)
;
}
bool
IsNull
(
)
{
return
!
frame
;
}
nsIFrame
*
frame
;
bool
frameEdge
;
bool
afterFrame
;
}
;
static
FrameTarget
GetSelectionClosestFrame
(
nsIFrame
*
aFrame
const
nsPoint
&
aPoint
uint32_t
aFlags
)
;
static
bool
SelfIsSelectable
(
nsIFrame
*
aFrame
uint32_t
aFlags
)
{
if
(
(
aFlags
&
nsIFrame
:
:
SKIP_HIDDEN
)
&
&
!
aFrame
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
)
{
return
false
;
}
return
!
aFrame
-
>
IsGeneratedContentFrame
(
)
&
&
aFrame
-
>
StyleUIReset
(
)
-
>
mUserSelect
!
=
StyleUserSelect
:
:
None
;
}
static
bool
SelectionDescendToKids
(
nsIFrame
*
aFrame
)
{
StyleUserSelect
style
=
aFrame
-
>
StyleUIReset
(
)
-
>
mUserSelect
;
nsIFrame
*
parent
=
aFrame
-
>
GetParent
(
)
;
return
!
aFrame
-
>
IsGeneratedContentFrame
(
)
&
&
style
!
=
StyleUserSelect
:
:
All
&
&
style
!
=
StyleUserSelect
:
:
None
&
&
(
(
parent
-
>
GetStateBits
(
)
&
NS_FRAME_INDEPENDENT_SELECTION
)
|
|
!
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_INDEPENDENT_SELECTION
)
)
;
}
static
FrameTarget
GetSelectionClosestFrameForChild
(
nsIFrame
*
aChild
const
nsPoint
&
aPoint
uint32_t
aFlags
)
{
nsIFrame
*
parent
=
aChild
-
>
GetParent
(
)
;
if
(
SelectionDescendToKids
(
aChild
)
)
{
nsPoint
pt
=
aPoint
-
aChild
-
>
GetOffsetTo
(
parent
)
;
return
GetSelectionClosestFrame
(
aChild
pt
aFlags
)
;
}
return
FrameTarget
(
aChild
false
false
)
;
}
static
FrameTarget
DrillDownToSelectionFrame
(
nsIFrame
*
aFrame
bool
aEndFrame
uint32_t
aFlags
)
{
if
(
SelectionDescendToKids
(
aFrame
)
)
{
nsIFrame
*
result
=
nullptr
;
nsIFrame
*
frame
=
aFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
!
aEndFrame
)
{
while
(
frame
&
&
(
!
SelfIsSelectable
(
frame
aFlags
)
|
|
frame
-
>
IsEmpty
(
)
)
)
frame
=
frame
-
>
GetNextSibling
(
)
;
if
(
frame
)
result
=
frame
;
}
else
{
while
(
frame
)
{
if
(
!
frame
-
>
IsEmpty
(
)
&
&
SelfIsSelectable
(
frame
aFlags
)
)
result
=
frame
;
frame
=
frame
-
>
GetNextSibling
(
)
;
}
}
if
(
result
)
return
DrillDownToSelectionFrame
(
result
aEndFrame
aFlags
)
;
}
return
FrameTarget
(
aFrame
true
aEndFrame
)
;
}
static
FrameTarget
GetSelectionClosestFrameForLine
(
nsBlockFrame
*
aParent
nsBlockFrame
:
:
LineIterator
aLine
const
nsPoint
&
aPoint
uint32_t
aFlags
)
{
if
(
aLine
=
=
aParent
-
>
LinesEnd
(
)
)
return
DrillDownToSelectionFrame
(
aParent
true
aFlags
)
;
nsIFrame
*
frame
=
aLine
-
>
mFirstChild
;
nsIFrame
*
closestFromIStart
=
nullptr
;
nsIFrame
*
closestFromIEnd
=
nullptr
;
nscoord
closestIStart
=
aLine
-
>
IStart
(
)
closestIEnd
=
aLine
-
>
IEnd
(
)
;
WritingMode
wm
=
aLine
-
>
mWritingMode
;
LogicalPoint
pt
(
wm
aPoint
aLine
-
>
mContainerSize
)
;
bool
canSkipBr
=
false
;
bool
lastFrameWasEditable
=
false
;
for
(
int32_t
n
=
aLine
-
>
GetChildCount
(
)
;
n
;
-
-
n
frame
=
frame
-
>
GetNextSibling
(
)
)
{
if
(
!
SelfIsSelectable
(
frame
aFlags
)
|
|
frame
-
>
IsEmpty
(
)
|
|
(
canSkipBr
&
&
frame
-
>
IsBrFrame
(
)
&
&
lastFrameWasEditable
=
=
frame
-
>
GetContent
(
)
-
>
IsEditable
(
)
)
)
{
continue
;
}
canSkipBr
=
true
;
lastFrameWasEditable
=
frame
-
>
GetContent
(
)
&
&
frame
-
>
GetContent
(
)
-
>
IsEditable
(
)
;
LogicalRect
frameRect
=
LogicalRect
(
wm
frame
-
>
GetRect
(
)
aLine
-
>
mContainerSize
)
;
if
(
pt
.
I
(
wm
)
>
=
frameRect
.
IStart
(
wm
)
)
{
if
(
pt
.
I
(
wm
)
<
frameRect
.
IEnd
(
wm
)
)
{
return
GetSelectionClosestFrameForChild
(
frame
aPoint
aFlags
)
;
}
if
(
frameRect
.
IEnd
(
wm
)
>
=
closestIStart
)
{
closestFromIStart
=
frame
;
closestIStart
=
frameRect
.
IEnd
(
wm
)
;
}
}
else
{
if
(
frameRect
.
IStart
(
wm
)
<
=
closestIEnd
)
{
closestFromIEnd
=
frame
;
closestIEnd
=
frameRect
.
IStart
(
wm
)
;
}
}
}
if
(
!
closestFromIStart
&
&
!
closestFromIEnd
)
{
return
FrameTarget
:
:
Null
(
)
;
}
if
(
closestFromIStart
&
&
(
!
closestFromIEnd
|
|
(
abs
(
pt
.
I
(
wm
)
-
closestIStart
)
<
=
abs
(
pt
.
I
(
wm
)
-
closestIEnd
)
)
)
)
{
return
GetSelectionClosestFrameForChild
(
closestFromIStart
aPoint
aFlags
)
;
}
return
GetSelectionClosestFrameForChild
(
closestFromIEnd
aPoint
aFlags
)
;
}
static
FrameTarget
GetSelectionClosestFrameForBlock
(
nsIFrame
*
aFrame
const
nsPoint
&
aPoint
uint32_t
aFlags
)
{
nsBlockFrame
*
bf
=
do_QueryFrame
(
aFrame
)
;
if
(
!
bf
)
return
FrameTarget
:
:
Null
(
)
;
nsBlockFrame
:
:
LineIterator
end
=
bf
-
>
LinesEnd
(
)
;
nsBlockFrame
:
:
LineIterator
curLine
=
bf
-
>
LinesBegin
(
)
;
nsBlockFrame
:
:
LineIterator
closestLine
=
end
;
if
(
curLine
!
=
end
)
{
WritingMode
wm
=
curLine
-
>
mWritingMode
;
LogicalPoint
pt
(
wm
aPoint
curLine
-
>
mContainerSize
)
;
do
{
nscoord
BCoord
=
pt
.
B
(
wm
)
-
curLine
-
>
BStart
(
)
;
nscoord
BSize
=
curLine
-
>
BSize
(
)
;
if
(
BCoord
>
=
0
&
&
BCoord
<
BSize
)
{
closestLine
=
curLine
;
break
;
}
if
(
BCoord
<
0
)
break
;
+
+
curLine
;
}
while
(
curLine
!
=
end
)
;
if
(
closestLine
=
=
end
)
{
nsBlockFrame
:
:
LineIterator
prevLine
=
curLine
.
prev
(
)
;
nsBlockFrame
:
:
LineIterator
nextLine
=
curLine
;
while
(
nextLine
!
=
end
&
&
nextLine
-
>
IsEmpty
(
)
)
+
+
nextLine
;
while
(
prevLine
!
=
end
&
&
prevLine
-
>
IsEmpty
(
)
)
-
-
prevLine
;
int32_t
dragOutOfFrame
=
Preferences
:
:
GetInt
(
"
browser
.
drag_out_of_frame_style
"
)
;
if
(
prevLine
=
=
end
)
{
if
(
dragOutOfFrame
=
=
1
|
|
nextLine
=
=
end
)
return
DrillDownToSelectionFrame
(
aFrame
false
aFlags
)
;
closestLine
=
nextLine
;
}
else
if
(
nextLine
=
=
end
)
{
if
(
dragOutOfFrame
=
=
1
)
return
DrillDownToSelectionFrame
(
aFrame
true
aFlags
)
;
closestLine
=
prevLine
;
}
else
{
if
(
pt
.
B
(
wm
)
-
prevLine
-
>
BEnd
(
)
<
nextLine
-
>
BStart
(
)
-
pt
.
B
(
wm
)
)
closestLine
=
prevLine
;
else
closestLine
=
nextLine
;
}
}
}
do
{
FrameTarget
target
=
GetSelectionClosestFrameForLine
(
bf
closestLine
aPoint
aFlags
)
;
if
(
!
target
.
IsNull
(
)
)
return
target
;
+
+
closestLine
;
}
while
(
closestLine
!
=
end
)
;
return
DrillDownToSelectionFrame
(
aFrame
true
aFlags
)
;
}
static
FrameTarget
GetSelectionClosestFrame
(
nsIFrame
*
aFrame
const
nsPoint
&
aPoint
uint32_t
aFlags
)
{
{
FrameTarget
target
=
GetSelectionClosestFrameForBlock
(
aFrame
aPoint
aFlags
)
;
if
(
!
target
.
IsNull
(
)
)
return
target
;
}
nsIFrame
*
kid
=
aFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
kid
)
{
nsIFrame
:
:
FrameWithDistance
closest
=
{
nullptr
nscoord_MAX
nscoord_MAX
}
;
for
(
;
kid
;
kid
=
kid
-
>
GetNextSibling
(
)
)
{
if
(
!
SelfIsSelectable
(
kid
aFlags
)
|
|
kid
-
>
IsEmpty
(
)
)
continue
;
kid
-
>
FindCloserFrameForSelection
(
aPoint
&
closest
)
;
}
if
(
closest
.
mFrame
)
{
if
(
nsSVGUtils
:
:
IsInSVGTextSubtree
(
closest
.
mFrame
)
)
return
FrameTarget
(
closest
.
mFrame
false
false
)
;
return
GetSelectionClosestFrameForChild
(
closest
.
mFrame
aPoint
aFlags
)
;
}
}
return
FrameTarget
(
aFrame
false
false
)
;
}
static
nsIFrame
:
:
ContentOffsets
OffsetsForSingleFrame
(
nsIFrame
*
aFrame
const
nsPoint
&
aPoint
)
{
nsIFrame
:
:
ContentOffsets
offsets
;
FrameContentRange
range
=
GetRangeForFrame
(
aFrame
)
;
offsets
.
content
=
range
.
content
;
if
(
aFrame
-
>
GetNextContinuation
(
)
|
|
aFrame
-
>
GetPrevContinuation
(
)
)
{
offsets
.
offset
=
range
.
start
;
offsets
.
secondaryOffset
=
range
.
end
;
offsets
.
associate
=
CARET_ASSOCIATE_AFTER
;
return
offsets
;
}
nsRect
rect
(
nsPoint
(
0
0
)
aFrame
-
>
GetSize
(
)
)
;
bool
isBlock
=
aFrame
-
>
GetDisplay
(
)
!
=
StyleDisplay
:
:
Inline
;
bool
isRtl
=
(
aFrame
-
>
StyleVisibility
(
)
-
>
mDirection
=
=
NS_STYLE_DIRECTION_RTL
)
;
if
(
(
isBlock
&
&
rect
.
y
<
aPoint
.
y
)
|
|
(
!
isBlock
&
&
(
(
isRtl
&
&
rect
.
x
+
rect
.
width
/
2
>
aPoint
.
x
)
|
|
(
!
isRtl
&
&
rect
.
x
+
rect
.
width
/
2
<
aPoint
.
x
)
)
)
)
{
offsets
.
offset
=
range
.
end
;
if
(
rect
.
Contains
(
aPoint
)
)
offsets
.
secondaryOffset
=
range
.
start
;
else
offsets
.
secondaryOffset
=
range
.
end
;
}
else
{
offsets
.
offset
=
range
.
start
;
if
(
rect
.
Contains
(
aPoint
)
)
offsets
.
secondaryOffset
=
range
.
end
;
else
offsets
.
secondaryOffset
=
range
.
start
;
}
offsets
.
associate
=
offsets
.
offset
=
=
range
.
start
?
CARET_ASSOCIATE_AFTER
:
CARET_ASSOCIATE_BEFORE
;
return
offsets
;
}
static
nsIFrame
*
AdjustFrameForSelectionStyles
(
nsIFrame
*
aFrame
)
{
nsIFrame
*
adjustedFrame
=
aFrame
;
for
(
nsIFrame
*
frame
=
aFrame
;
frame
;
frame
=
frame
-
>
GetParent
(
)
)
{
StyleUserSelect
userSelect
=
frame
-
>
StyleUIReset
(
)
-
>
mUserSelect
;
if
(
userSelect
!
=
StyleUserSelect
:
:
Auto
&
&
userSelect
!
=
StyleUserSelect
:
:
All
)
{
break
;
}
if
(
userSelect
=
=
StyleUserSelect
:
:
All
|
|
frame
-
>
IsGeneratedContentFrame
(
)
)
{
adjustedFrame
=
frame
;
}
}
return
adjustedFrame
;
}
nsIFrame
:
:
ContentOffsets
nsIFrame
:
:
GetContentOffsetsFromPoint
(
const
nsPoint
&
aPoint
uint32_t
aFlags
)
{
nsIFrame
*
adjustedFrame
;
if
(
aFlags
&
IGNORE_SELECTION_STYLE
)
{
adjustedFrame
=
this
;
}
else
{
adjustedFrame
=
AdjustFrameForSelectionStyles
(
this
)
;
if
(
adjustedFrame
-
>
StyleUIReset
(
)
-
>
mUserSelect
=
=
StyleUserSelect
:
:
All
)
{
nsPoint
adjustedPoint
=
aPoint
+
this
-
>
GetOffsetTo
(
adjustedFrame
)
;
return
OffsetsForSingleFrame
(
adjustedFrame
adjustedPoint
)
;
}
if
(
adjustedFrame
!
=
this
)
adjustedFrame
=
adjustedFrame
-
>
GetParent
(
)
;
}
nsPoint
adjustedPoint
=
aPoint
+
this
-
>
GetOffsetTo
(
adjustedFrame
)
;
FrameTarget
closest
=
GetSelectionClosestFrame
(
adjustedFrame
adjustedPoint
aFlags
)
;
if
(
closest
.
frameEdge
)
{
ContentOffsets
offsets
;
FrameContentRange
range
=
GetRangeForFrame
(
closest
.
frame
)
;
offsets
.
content
=
range
.
content
;
if
(
closest
.
afterFrame
)
offsets
.
offset
=
range
.
end
;
else
offsets
.
offset
=
range
.
start
;
offsets
.
secondaryOffset
=
offsets
.
offset
;
offsets
.
associate
=
offsets
.
offset
=
=
range
.
start
?
CARET_ASSOCIATE_AFTER
:
CARET_ASSOCIATE_BEFORE
;
return
offsets
;
}
nsPoint
pt
;
if
(
closest
.
frame
!
=
this
)
{
if
(
nsSVGUtils
:
:
IsInSVGTextSubtree
(
closest
.
frame
)
)
{
pt
=
nsLayoutUtils
:
:
TransformAncestorPointToFrame
(
closest
.
frame
aPoint
this
)
;
}
else
{
pt
=
aPoint
-
closest
.
frame
-
>
GetOffsetTo
(
this
)
;
}
}
else
{
pt
=
aPoint
;
}
return
static_cast
<
nsFrame
*
>
(
closest
.
frame
)
-
>
CalcContentOffsetsFromFramePoint
(
pt
)
;
}
nsIFrame
:
:
ContentOffsets
nsFrame
:
:
CalcContentOffsetsFromFramePoint
(
const
nsPoint
&
aPoint
)
{
return
OffsetsForSingleFrame
(
this
aPoint
)
;
}
void
nsIFrame
:
:
AssociateImage
(
const
nsStyleImage
&
aImage
nsPresContext
*
aPresContext
uint32_t
aImageLoaderFlags
)
{
if
(
aImage
.
GetType
(
)
!
=
eStyleImageType_Image
)
{
return
;
}
imgRequestProxy
*
req
=
aImage
.
GetImageData
(
)
;
if
(
!
req
)
{
return
;
}
mozilla
:
:
css
:
:
ImageLoader
*
loader
=
aPresContext
-
>
Document
(
)
-
>
StyleImageLoader
(
)
;
loader
-
>
AssociateRequestToFrame
(
req
this
aImageLoaderFlags
)
;
}
nsresult
nsFrame
:
:
GetCursor
(
const
nsPoint
&
aPoint
nsIFrame
:
:
Cursor
&
aCursor
)
{
FillCursorInformationFromStyle
(
StyleUI
(
)
aCursor
)
;
if
(
StyleCursorKind
:
:
Auto
=
=
aCursor
.
mCursor
)
{
aCursor
.
mCursor
=
(
mContent
&
&
mContent
-
>
IsEditable
(
)
)
?
StyleCursorKind
:
:
Text
:
StyleCursorKind
:
:
Default
;
}
if
(
StyleCursorKind
:
:
Text
=
=
aCursor
.
mCursor
&
&
GetWritingMode
(
)
.
IsVertical
(
)
)
{
aCursor
.
mCursor
=
StyleCursorKind
:
:
VerticalText
;
}
return
NS_OK
;
}
void
nsFrame
:
:
MarkIntrinsicISizesDirty
(
)
{
if
(
:
:
IsXULBoxWrapped
(
this
)
)
{
nsBoxLayoutMetrics
*
metrics
=
BoxMetrics
(
)
;
SizeNeedsRecalc
(
metrics
-
>
mPrefSize
)
;
SizeNeedsRecalc
(
metrics
-
>
mMinSize
)
;
SizeNeedsRecalc
(
metrics
-
>
mMaxSize
)
;
SizeNeedsRecalc
(
metrics
-
>
mBlockPrefSize
)
;
SizeNeedsRecalc
(
metrics
-
>
mBlockMinSize
)
;
CoordNeedsRecalc
(
metrics
-
>
mFlex
)
;
CoordNeedsRecalc
(
metrics
-
>
mAscent
)
;
}
auto
*
parentFrame
=
GetParent
(
)
;
if
(
parentFrame
&
&
parentFrame
-
>
IsFlexContainerFrame
(
)
)
{
nsFlexContainerFrame
:
:
MarkCachedFlexMeasurementsDirty
(
this
)
;
}
if
(
GetStateBits
(
)
&
NS_FRAME_FONT_INFLATION_FLOW_ROOT
)
{
nsFontInflationData
:
:
MarkFontInflationDataTextDirty
(
this
)
;
}
}
nscoord
nsFrame
:
:
GetMinISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
result
=
0
;
DISPLAY_MIN_INLINE_SIZE
(
this
result
)
;
return
result
;
}
nscoord
nsFrame
:
:
GetPrefISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
result
=
0
;
DISPLAY_PREF_INLINE_SIZE
(
this
result
)
;
return
result
;
}
void
nsFrame
:
:
AddInlineMinISize
(
gfxContext
*
aRenderingContext
nsIFrame
:
:
InlineMinISizeData
*
aData
)
{
nscoord
isize
=
nsLayoutUtils
:
:
IntrinsicForContainer
(
aRenderingContext
this
nsLayoutUtils
:
:
MIN_ISIZE
)
;
aData
-
>
DefaultAddInlineMinISize
(
this
isize
)
;
}
void
nsFrame
:
:
AddInlinePrefISize
(
gfxContext
*
aRenderingContext
nsIFrame
:
:
InlinePrefISizeData
*
aData
)
{
nscoord
isize
=
nsLayoutUtils
:
:
IntrinsicForContainer
(
aRenderingContext
this
nsLayoutUtils
:
:
PREF_ISIZE
)
;
aData
-
>
DefaultAddInlinePrefISize
(
isize
)
;
}
void
nsIFrame
:
:
InlineMinISizeData
:
:
DefaultAddInlineMinISize
(
nsIFrame
*
aFrame
nscoord
aISize
bool
aAllowBreak
)
{
auto
parent
=
aFrame
-
>
GetParent
(
)
;
MOZ_ASSERT
(
parent
"
Must
have
a
parent
if
we
get
here
!
"
)
;
const
bool
mayBreak
=
aAllowBreak
&
&
!
aFrame
-
>
CanContinueTextRun
(
)
&
&
!
parent
-
>
Style
(
)
-
>
ShouldSuppressLineBreak
(
)
&
&
parent
-
>
StyleText
(
)
-
>
WhiteSpaceCanWrap
(
parent
)
;
if
(
mayBreak
)
{
OptionallyBreak
(
)
;
}
mTrailingWhitespace
=
0
;
mSkipWhitespace
=
false
;
mCurrentLine
+
=
aISize
;
mAtStartOfLine
=
false
;
if
(
mayBreak
)
{
OptionallyBreak
(
)
;
}
}
void
nsIFrame
:
:
InlinePrefISizeData
:
:
DefaultAddInlinePrefISize
(
nscoord
aISize
)
{
mCurrentLine
=
NSCoordSaturatingAdd
(
mCurrentLine
aISize
)
;
mTrailingWhitespace
=
0
;
mSkipWhitespace
=
false
;
mLineIsEmpty
=
false
;
}
void
nsIFrame
:
:
InlineMinISizeData
:
:
ForceBreak
(
)
{
mCurrentLine
-
=
mTrailingWhitespace
;
mPrevLines
=
std
:
:
max
(
mPrevLines
mCurrentLine
)
;
mCurrentLine
=
mTrailingWhitespace
=
0
;
for
(
uint32_t
i
=
0
i_end
=
mFloats
.
Length
(
)
;
i
!
=
i_end
;
+
+
i
)
{
nscoord
float_min
=
mFloats
[
i
]
.
Width
(
)
;
if
(
float_min
>
mPrevLines
)
mPrevLines
=
float_min
;
}
mFloats
.
Clear
(
)
;
mSkipWhitespace
=
true
;
}
void
nsIFrame
:
:
InlineMinISizeData
:
:
OptionallyBreak
(
nscoord
aHyphenWidth
)
{
if
(
mCurrentLine
+
aHyphenWidth
<
0
|
|
mAtStartOfLine
)
return
;
mCurrentLine
+
=
aHyphenWidth
;
ForceBreak
(
)
;
}
void
nsIFrame
:
:
InlinePrefISizeData
:
:
ForceBreak
(
StyleClear
aBreakType
)
{
MOZ_ASSERT
(
aBreakType
=
=
StyleClear
:
:
None
|
|
aBreakType
=
=
StyleClear
:
:
Both
|
|
aBreakType
=
=
StyleClear
:
:
Left
|
|
aBreakType
=
=
StyleClear
:
:
Right
"
Must
be
a
physical
break
type
"
)
;
if
(
mFloats
.
Length
(
)
!
=
0
&
&
aBreakType
!
=
StyleClear
:
:
None
)
{
nscoord
floats_done
=
0
floats_cur_left
=
0
floats_cur_right
=
0
;
for
(
uint32_t
i
=
0
i_end
=
mFloats
.
Length
(
)
;
i
!
=
i_end
;
+
+
i
)
{
const
FloatInfo
&
floatInfo
=
mFloats
[
i
]
;
const
nsStyleDisplay
*
floatDisp
=
floatInfo
.
Frame
(
)
-
>
StyleDisplay
(
)
;
StyleClear
breakType
=
floatDisp
-
>
mBreakType
;
if
(
breakType
=
=
StyleClear
:
:
Left
|
|
breakType
=
=
StyleClear
:
:
Right
|
|
breakType
=
=
StyleClear
:
:
Both
)
{
nscoord
floats_cur
=
NSCoordSaturatingAdd
(
floats_cur_left
floats_cur_right
)
;
if
(
floats_cur
>
floats_done
)
{
floats_done
=
floats_cur
;
}
if
(
breakType
!
=
StyleClear
:
:
Right
)
{
floats_cur_left
=
0
;
}
if
(
breakType
!
=
StyleClear
:
:
Left
)
{
floats_cur_right
=
0
;
}
}
StyleFloat
floatStyle
=
floatDisp
-
>
mFloat
;
nscoord
&
floats_cur
=
floatStyle
=
=
StyleFloat
:
:
Left
?
floats_cur_left
:
floats_cur_right
;
nscoord
floatWidth
=
floatInfo
.
Width
(
)
;
floats_cur
=
NSCoordSaturatingAdd
(
floats_cur
std
:
:
max
(
0
floatWidth
)
)
;
}
nscoord
floats_cur
=
NSCoordSaturatingAdd
(
floats_cur_left
floats_cur_right
)
;
if
(
floats_cur
>
floats_done
)
floats_done
=
floats_cur
;
mCurrentLine
=
NSCoordSaturatingAdd
(
mCurrentLine
floats_done
)
;
if
(
aBreakType
=
=
StyleClear
:
:
Both
)
{
mFloats
.
Clear
(
)
;
}
else
{
nsTArray
<
FloatInfo
>
newFloats
;
MOZ_ASSERT
(
aBreakType
=
=
StyleClear
:
:
Left
|
|
aBreakType
=
=
StyleClear
:
:
Right
"
Other
values
should
have
been
handled
in
other
branches
"
)
;
StyleFloat
clearFloatType
=
aBreakType
=
=
StyleClear
:
:
Left
?
StyleFloat
:
:
Left
:
StyleFloat
:
:
Right
;
for
(
FloatInfo
&
floatInfo
:
Reversed
(
mFloats
)
)
{
const
nsStyleDisplay
*
floatDisp
=
floatInfo
.
Frame
(
)
-
>
StyleDisplay
(
)
;
if
(
floatDisp
-
>
mFloat
!
=
clearFloatType
)
{
newFloats
.
AppendElement
(
floatInfo
)
;
}
else
{
StyleClear
floatBreakType
=
floatDisp
-
>
mBreakType
;
if
(
floatBreakType
!
=
aBreakType
&
&
floatBreakType
!
=
StyleClear
:
:
None
)
{
break
;
}
}
}
newFloats
.
Reverse
(
)
;
mFloats
=
std
:
:
move
(
newFloats
)
;
}
}
mCurrentLine
=
NSCoordSaturatingSubtract
(
mCurrentLine
mTrailingWhitespace
nscoord_MAX
)
;
mPrevLines
=
std
:
:
max
(
mPrevLines
mCurrentLine
)
;
mCurrentLine
=
mTrailingWhitespace
=
0
;
mSkipWhitespace
=
true
;
mLineIsEmpty
=
true
;
}
static
nscoord
ResolveMargin
(
const
LengthPercentageOrAuto
&
aStyle
nscoord
aPercentageBasis
)
{
if
(
aStyle
.
IsAuto
(
)
)
{
return
nscoord
(
0
)
;
}
return
nsLayoutUtils
:
:
ResolveToLength
<
false
>
(
aStyle
.
AsLengthPercentage
(
)
aPercentageBasis
)
;
}
static
nscoord
ResolvePadding
(
const
LengthPercentage
&
aStyle
nscoord
aPercentageBasis
)
{
return
nsLayoutUtils
:
:
ResolveToLength
<
true
>
(
aStyle
aPercentageBasis
)
;
}
static
nsIFrame
:
:
IntrinsicISizeOffsetData
IntrinsicSizeOffsets
(
nsIFrame
*
aFrame
nscoord
aPercentageBasis
bool
aForISize
)
{
nsIFrame
:
:
IntrinsicISizeOffsetData
result
;
WritingMode
wm
=
aFrame
-
>
GetWritingMode
(
)
;
const
auto
&
margin
=
aFrame
-
>
StyleMargin
(
)
-
>
mMargin
;
bool
verticalAxis
=
aForISize
=
=
wm
.
IsVertical
(
)
;
if
(
verticalAxis
)
{
result
.
hMargin
+
=
ResolveMargin
(
margin
.
Get
(
eSideTop
)
aPercentageBasis
)
;
result
.
hMargin
+
=
ResolveMargin
(
margin
.
Get
(
eSideBottom
)
aPercentageBasis
)
;
}
else
{
result
.
hMargin
+
=
ResolveMargin
(
margin
.
Get
(
eSideLeft
)
aPercentageBasis
)
;
result
.
hMargin
+
=
ResolveMargin
(
margin
.
Get
(
eSideRight
)
aPercentageBasis
)
;
}
const
auto
&
padding
=
aFrame
-
>
StylePadding
(
)
-
>
mPadding
;
if
(
verticalAxis
)
{
result
.
hPadding
+
=
ResolvePadding
(
padding
.
Get
(
eSideTop
)
aPercentageBasis
)
;
result
.
hPadding
+
=
ResolvePadding
(
padding
.
Get
(
eSideBottom
)
aPercentageBasis
)
;
}
else
{
result
.
hPadding
+
=
ResolvePadding
(
padding
.
Get
(
eSideLeft
)
aPercentageBasis
)
;
result
.
hPadding
+
=
ResolvePadding
(
padding
.
Get
(
eSideRight
)
aPercentageBasis
)
;
}
const
nsStyleBorder
*
styleBorder
=
aFrame
-
>
StyleBorder
(
)
;
if
(
verticalAxis
)
{
result
.
hBorder
+
=
styleBorder
-
>
GetComputedBorderWidth
(
eSideTop
)
;
result
.
hBorder
+
=
styleBorder
-
>
GetComputedBorderWidth
(
eSideBottom
)
;
}
else
{
result
.
hBorder
+
=
styleBorder
-
>
GetComputedBorderWidth
(
eSideLeft
)
;
result
.
hBorder
+
=
styleBorder
-
>
GetComputedBorderWidth
(
eSideRight
)
;
}
const
nsStyleDisplay
*
disp
=
aFrame
-
>
StyleDisplay
(
)
;
if
(
aFrame
-
>
IsThemed
(
disp
)
)
{
nsPresContext
*
presContext
=
aFrame
-
>
PresContext
(
)
;
LayoutDeviceIntMargin
border
=
presContext
-
>
GetTheme
(
)
-
>
GetWidgetBorder
(
presContext
-
>
DeviceContext
(
)
aFrame
disp
-
>
mAppearance
)
;
result
.
hBorder
=
presContext
-
>
DevPixelsToAppUnits
(
verticalAxis
?
border
.
TopBottom
(
)
:
border
.
LeftRight
(
)
)
;
LayoutDeviceIntMargin
padding
;
if
(
presContext
-
>
GetTheme
(
)
-
>
GetWidgetPadding
(
presContext
-
>
DeviceContext
(
)
aFrame
disp
-
>
mAppearance
&
padding
)
)
{
result
.
hPadding
=
presContext
-
>
DevPixelsToAppUnits
(
verticalAxis
?
padding
.
TopBottom
(
)
:
padding
.
LeftRight
(
)
)
;
}
}
return
result
;
}
nsIFrame
:
:
IntrinsicISizeOffsetData
nsFrame
:
:
IntrinsicISizeOffsets
(
nscoord
aPercentageBasis
)
{
return
IntrinsicSizeOffsets
(
this
aPercentageBasis
true
)
;
}
nsIFrame
:
:
IntrinsicISizeOffsetData
nsIFrame
:
:
IntrinsicBSizeOffsets
(
nscoord
aPercentageBasis
)
{
return
IntrinsicSizeOffsets
(
this
aPercentageBasis
false
)
;
}
IntrinsicSize
nsFrame
:
:
GetIntrinsicSize
(
)
{
return
IntrinsicSize
(
)
;
}
nsSize
nsFrame
:
:
GetIntrinsicRatio
(
)
{
return
nsSize
(
0
0
)
;
}
LogicalSize
nsFrame
:
:
ComputeSize
(
gfxContext
*
aRenderingContext
WritingMode
aWM
const
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
LogicalSize
&
aMargin
const
LogicalSize
&
aBorder
const
LogicalSize
&
aPadding
ComputeSizeFlags
aFlags
)
{
MOZ_ASSERT
(
GetIntrinsicRatio
(
)
=
=
nsSize
(
0
0
)
"
Please
override
this
method
and
call
"
"
nsFrame
:
:
ComputeSizeWithIntrinsicDimensions
instead
.
"
)
;
LogicalSize
result
=
ComputeAutoSize
(
aRenderingContext
aWM
aCBSize
aAvailableISize
aMargin
aBorder
aPadding
aFlags
)
;
const
nsStylePosition
*
stylePos
=
StylePosition
(
)
;
LogicalSize
boxSizingAdjust
(
aWM
)
;
if
(
stylePos
-
>
mBoxSizing
=
=
StyleBoxSizing
:
:
Border
)
{
boxSizingAdjust
=
aBorder
+
aPadding
;
}
nscoord
boxSizingToMarginEdgeISize
=
aMargin
.
ISize
(
aWM
)
+
aBorder
.
ISize
(
aWM
)
+
aPadding
.
ISize
(
aWM
)
-
boxSizingAdjust
.
ISize
(
aWM
)
;
const
auto
*
inlineStyleCoord
=
&
stylePos
-
>
ISize
(
aWM
)
;
const
auto
*
blockStyleCoord
=
&
stylePos
-
>
BSize
(
aWM
)
;
auto
parentFrame
=
GetParent
(
)
;
auto
alignCB
=
parentFrame
;
bool
isGridItem
=
parentFrame
&
&
parentFrame
-
>
IsGridContainerFrame
(
)
&
&
!
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
;
if
(
parentFrame
&
&
parentFrame
-
>
IsTableWrapperFrame
(
)
&
&
IsTableFrame
(
)
)
{
auto
tableWrapper
=
GetParent
(
)
;
auto
grandParent
=
tableWrapper
-
>
GetParent
(
)
;
isGridItem
=
(
grandParent
-
>
IsGridContainerFrame
(
)
&
&
!
(
tableWrapper
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
)
;
if
(
isGridItem
)
{
alignCB
=
grandParent
;
}
}
bool
isFlexItem
=
parentFrame
&
&
parentFrame
-
>
IsFlexContainerFrame
(
)
&
&
!
parentFrame
-
>
HasAnyStateBits
(
NS_STATE_FLEX_IS_EMULATING_LEGACY_BOX
)
&
&
!
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
;
LogicalAxis
flexMainAxis
=
eLogicalAxisInline
;
if
(
isFlexItem
)
{
flexMainAxis
=
nsFlexContainerFrame
:
:
IsItemInlineAxisMainAxis
(
this
)
?
eLogicalAxisInline
:
eLogicalAxisBlock
;
const
auto
*
flexBasis
=
&
stylePos
-
>
mFlexBasis
;
auto
&
mainAxisCoord
=
(
flexMainAxis
=
=
eLogicalAxisInline
?
inlineStyleCoord
:
blockStyleCoord
)
;
if
(
nsFlexContainerFrame
:
:
IsUsedFlexBasisContent
(
*
flexBasis
*
mainAxisCoord
)
&
&
MOZ_LIKELY
(
!
IsTableWrapperFrame
(
)
)
)
{
static
const
StyleSize
maxContStyleCoord
(
StyleSize
:
:
ExtremumLength
(
StyleExtremumLength
:
:
MaxContent
)
)
;
mainAxisCoord
=
&
maxContStyleCoord
;
}
else
if
(
!
flexBasis
-
>
IsAuto
(
)
)
{
mainAxisCoord
=
&
flexBasis
-
>
AsSize
(
)
;
}
}
if
(
!
inlineStyleCoord
-
>
IsAuto
(
)
)
{
result
.
ISize
(
aWM
)
=
ComputeISizeValue
(
aRenderingContext
aCBSize
.
ISize
(
aWM
)
boxSizingAdjust
.
ISize
(
aWM
)
boxSizingToMarginEdgeISize
*
inlineStyleCoord
aFlags
)
;
}
else
if
(
MOZ_UNLIKELY
(
isGridItem
)
&
&
!
IS_TRUE_OVERFLOW_CONTAINER
(
this
)
)
{
bool
stretch
=
false
;
if
(
!
(
aFlags
&
nsIFrame
:
:
eShrinkWrap
)
&
&
!
StyleMargin
(
)
-
>
HasInlineAxisAuto
(
aWM
)
)
{
auto
inlineAxisAlignment
=
aWM
.
IsOrthogonalTo
(
alignCB
-
>
GetWritingMode
(
)
)
?
StylePosition
(
)
-
>
UsedAlignSelf
(
alignCB
-
>
Style
(
)
)
:
StylePosition
(
)
-
>
UsedJustifySelf
(
alignCB
-
>
Style
(
)
)
;
stretch
=
inlineAxisAlignment
=
=
NS_STYLE_ALIGN_NORMAL
|
|
inlineAxisAlignment
=
=
NS_STYLE_ALIGN_STRETCH
;
}
if
(
stretch
|
|
(
aFlags
&
ComputeSizeFlags
:
:
eIClampMarginBoxMinSize
)
)
{
auto
iSizeToFillCB
=
std
:
:
max
(
nscoord
(
0
)
aCBSize
.
ISize
(
aWM
)
-
aPadding
.
ISize
(
aWM
)
-
aBorder
.
ISize
(
aWM
)
-
aMargin
.
ISize
(
aWM
)
)
;
if
(
stretch
|
|
result
.
ISize
(
aWM
)
>
iSizeToFillCB
)
{
result
.
ISize
(
aWM
)
=
iSizeToFillCB
;
}
}
}
const
auto
&
maxISizeCoord
=
stylePos
-
>
MaxISize
(
aWM
)
;
nscoord
maxISize
=
NS_UNCONSTRAINEDSIZE
;
if
(
!
maxISizeCoord
.
IsNone
(
)
&
&
!
(
isFlexItem
&
&
flexMainAxis
=
=
eLogicalAxisInline
)
)
{
maxISize
=
ComputeISizeValue
(
aRenderingContext
aCBSize
.
ISize
(
aWM
)
boxSizingAdjust
.
ISize
(
aWM
)
boxSizingToMarginEdgeISize
maxISizeCoord
aFlags
)
;
result
.
ISize
(
aWM
)
=
std
:
:
min
(
maxISize
result
.
ISize
(
aWM
)
)
;
}
const
auto
&
minISizeCoord
=
stylePos
-
>
MinISize
(
aWM
)
;
nscoord
minISize
;
if
(
!
minISizeCoord
.
IsAuto
(
)
&
&
!
(
isFlexItem
&
&
flexMainAxis
=
=
eLogicalAxisInline
)
)
{
minISize
=
ComputeISizeValue
(
aRenderingContext
aCBSize
.
ISize
(
aWM
)
boxSizingAdjust
.
ISize
(
aWM
)
boxSizingToMarginEdgeISize
minISizeCoord
aFlags
)
;
}
else
if
(
MOZ_UNLIKELY
(
aFlags
&
eIApplyAutoMinSize
)
)
{
minISize
=
std
:
:
min
(
maxISize
GetMinISize
(
aRenderingContext
)
)
;
if
(
inlineStyleCoord
-
>
IsLengthPercentage
(
)
)
{
minISize
=
std
:
:
min
(
minISize
result
.
ISize
(
aWM
)
)
;
}
else
if
(
aFlags
&
eIClampMarginBoxMinSize
)
{
auto
maxMinISize
=
std
:
:
max
(
nscoord
(
0
)
aCBSize
.
ISize
(
aWM
)
-
aPadding
.
ISize
(
aWM
)
-
aBorder
.
ISize
(
aWM
)
-
aMargin
.
ISize
(
aWM
)
)
;
minISize
=
std
:
:
min
(
minISize
maxMinISize
)
;
}
}
else
{
minISize
=
0
;
}
result
.
ISize
(
aWM
)
=
std
:
:
max
(
minISize
result
.
ISize
(
aWM
)
)
;
if
(
!
(
aFlags
&
nsIFrame
:
:
eUseAutoBSize
)
)
{
if
(
!
nsLayoutUtils
:
:
IsAutoBSize
(
*
blockStyleCoord
aCBSize
.
BSize
(
aWM
)
)
)
{
result
.
BSize
(
aWM
)
=
nsLayoutUtils
:
:
ComputeBSizeValue
(
aCBSize
.
BSize
(
aWM
)
boxSizingAdjust
.
BSize
(
aWM
)
blockStyleCoord
-
>
AsLengthPercentage
(
)
)
;
}
else
if
(
MOZ_UNLIKELY
(
isGridItem
)
&
&
blockStyleCoord
-
>
BehavesLikeInitialValueOnBlockAxis
(
)
&
&
!
IS_TRUE_OVERFLOW_CONTAINER
(
this
)
)
{
auto
cbSize
=
aCBSize
.
BSize
(
aWM
)
;
if
(
cbSize
!
=
NS_AUTOHEIGHT
)
{
bool
stretch
=
false
;
if
(
!
StyleMargin
(
)
-
>
HasBlockAxisAuto
(
aWM
)
)
{
auto
blockAxisAlignment
=
!
aWM
.
IsOrthogonalTo
(
alignCB
-
>
GetWritingMode
(
)
)
?
StylePosition
(
)
-
>
UsedAlignSelf
(
alignCB
-
>
Style
(
)
)
:
StylePosition
(
)
-
>
UsedJustifySelf
(
alignCB
-
>
Style
(
)
)
;
stretch
=
blockAxisAlignment
=
=
NS_STYLE_ALIGN_NORMAL
|
|
blockAxisAlignment
=
=
NS_STYLE_ALIGN_STRETCH
;
}
if
(
stretch
|
|
(
aFlags
&
ComputeSizeFlags
:
:
eBClampMarginBoxMinSize
)
)
{
auto
bSizeToFillCB
=
std
:
:
max
(
nscoord
(
0
)
cbSize
-
aPadding
.
BSize
(
aWM
)
-
aBorder
.
BSize
(
aWM
)
-
aMargin
.
BSize
(
aWM
)
)
;
if
(
stretch
|
|
(
result
.
BSize
(
aWM
)
!
=
NS_AUTOHEIGHT
&
&
result
.
BSize
(
aWM
)
>
bSizeToFillCB
)
)
{
result
.
BSize
(
aWM
)
=
bSizeToFillCB
;
}
}
}
}
}
const
auto
&
maxBSizeCoord
=
stylePos
-
>
MaxBSize
(
aWM
)
;
if
(
result
.
BSize
(
aWM
)
!
=
NS_UNCONSTRAINEDSIZE
)
{
if
(
!
nsLayoutUtils
:
:
IsAutoBSize
(
maxBSizeCoord
aCBSize
.
BSize
(
aWM
)
)
&
&
!
(
isFlexItem
&
&
flexMainAxis
=
=
eLogicalAxisBlock
)
)
{
nscoord
maxBSize
=
nsLayoutUtils
:
:
ComputeBSizeValue
(
aCBSize
.
BSize
(
aWM
)
boxSizingAdjust
.
BSize
(
aWM
)
maxBSizeCoord
.
AsLengthPercentage
(
)
)
;
result
.
BSize
(
aWM
)
=
std
:
:
min
(
maxBSize
result
.
BSize
(
aWM
)
)
;
}
const
auto
&
minBSizeCoord
=
stylePos
-
>
MinBSize
(
aWM
)
;
if
(
!
nsLayoutUtils
:
:
IsAutoBSize
(
minBSizeCoord
aCBSize
.
BSize
(
aWM
)
)
&
&
!
(
isFlexItem
&
&
flexMainAxis
=
=
eLogicalAxisBlock
)
)
{
nscoord
minBSize
=
nsLayoutUtils
:
:
ComputeBSizeValue
(
aCBSize
.
BSize
(
aWM
)
boxSizingAdjust
.
BSize
(
aWM
)
minBSizeCoord
.
AsLengthPercentage
(
)
)
;
result
.
BSize
(
aWM
)
=
std
:
:
max
(
minBSize
result
.
BSize
(
aWM
)
)
;
}
}
const
nsStyleDisplay
*
disp
=
StyleDisplay
(
)
;
if
(
IsThemed
(
disp
)
)
{
LayoutDeviceIntSize
widget
;
bool
canOverride
=
true
;
nsPresContext
*
presContext
=
PresContext
(
)
;
presContext
-
>
GetTheme
(
)
-
>
GetMinimumWidgetSize
(
presContext
this
disp
-
>
mAppearance
&
widget
&
canOverride
)
;
LogicalSize
size
(
aWM
nsSize
(
presContext
-
>
DevPixelsToAppUnits
(
widget
.
width
)
presContext
-
>
DevPixelsToAppUnits
(
widget
.
height
)
)
)
;
size
.
ISize
(
aWM
)
-
=
aBorder
.
ISize
(
aWM
)
+
aPadding
.
ISize
(
aWM
)
;
size
.
BSize
(
aWM
)
-
=
aBorder
.
BSize
(
aWM
)
+
aPadding
.
BSize
(
aWM
)
;
if
(
size
.
BSize
(
aWM
)
>
result
.
BSize
(
aWM
)
|
|
!
canOverride
)
{
result
.
BSize
(
aWM
)
=
size
.
BSize
(
aWM
)
;
}
if
(
size
.
ISize
(
aWM
)
>
result
.
ISize
(
aWM
)
|
|
!
canOverride
)
{
result
.
ISize
(
aWM
)
=
size
.
ISize
(
aWM
)
;
}
}
result
.
ISize
(
aWM
)
=
std
:
:
max
(
0
result
.
ISize
(
aWM
)
)
;
result
.
BSize
(
aWM
)
=
std
:
:
max
(
0
result
.
BSize
(
aWM
)
)
;
return
result
;
}
LogicalSize
nsFrame
:
:
ComputeSizeWithIntrinsicDimensions
(
gfxContext
*
aRenderingContext
WritingMode
aWM
const
IntrinsicSize
&
aIntrinsicSize
nsSize
aIntrinsicRatio
const
LogicalSize
&
aCBSize
const
LogicalSize
&
aMargin
const
LogicalSize
&
aBorder
const
LogicalSize
&
aPadding
ComputeSizeFlags
aFlags
)
{
const
nsStylePosition
*
stylePos
=
StylePosition
(
)
;
const
auto
*
inlineStyleCoord
=
&
stylePos
-
>
ISize
(
aWM
)
;
const
auto
*
blockStyleCoord
=
&
stylePos
-
>
BSize
(
aWM
)
;
auto
*
parentFrame
=
GetParent
(
)
;
const
bool
isGridItem
=
parentFrame
&
&
parentFrame
-
>
IsGridContainerFrame
(
)
&
&
!
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
;
const
bool
isFlexItem
=
parentFrame
&
&
parentFrame
-
>
IsFlexContainerFrame
(
)
&
&
!
parentFrame
-
>
HasAnyStateBits
(
NS_STATE_FLEX_IS_EMULATING_LEGACY_BOX
)
&
&
!
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
;
LogicalAxis
flexMainAxis
=
eLogicalAxisInline
;
Maybe
<
StyleSize
>
imposedMainSizeStyleCoord
;
if
(
isFlexItem
)
{
flexMainAxis
=
nsFlexContainerFrame
:
:
IsItemInlineAxisMainAxis
(
this
)
?
eLogicalAxisInline
:
eLogicalAxisBlock
;
bool
didImposeMainSize
;
nscoord
imposedMainSize
=
GetProperty
(
nsIFrame
:
:
FlexItemMainSizeOverride
(
)
&
didImposeMainSize
)
;
if
(
didImposeMainSize
)
{
imposedMainSizeStyleCoord
=
Some
(
StyleSize
:
:
LengthPercentage
(
LengthPercentage
:
:
FromAppUnits
(
imposedMainSize
)
)
)
;
if
(
flexMainAxis
=
=
eLogicalAxisInline
)
{
inlineStyleCoord
=
imposedMainSizeStyleCoord
.
ptr
(
)
;
}
else
{
blockStyleCoord
=
imposedMainSizeStyleCoord
.
ptr
(
)
;
}
}
else
{
const
auto
*
flexBasis
=
&
stylePos
-
>
mFlexBasis
;
auto
&
mainAxisCoord
=
(
flexMainAxis
=
=
eLogicalAxisInline
?
inlineStyleCoord
:
blockStyleCoord
)
;
if
(
nsFlexContainerFrame
:
:
IsUsedFlexBasisContent
(
*
flexBasis
*
mainAxisCoord
)
)
{
static
const
StyleSize
autoSize
(
StyleSize
:
:
Auto
(
)
)
;
mainAxisCoord
=
&
autoSize
;
}
else
if
(
!
flexBasis
-
>
IsAuto
(
)
)
{
mainAxisCoord
=
&
flexBasis
-
>
AsSize
(
)
;
}
}
}
const
bool
isAutoISize
=
inlineStyleCoord
-
>
IsAuto
(
)
;
const
bool
isAutoBSize
=
nsLayoutUtils
:
:
IsAutoBSize
(
*
blockStyleCoord
aCBSize
.
BSize
(
aWM
)
)
;
LogicalSize
boxSizingAdjust
(
aWM
)
;
if
(
stylePos
-
>
mBoxSizing
=
=
StyleBoxSizing
:
:
Border
)
{
boxSizingAdjust
=
aBorder
+
aPadding
;
}
nscoord
boxSizingToMarginEdgeISize
=
aMargin
.
ISize
(
aWM
)
+
aBorder
.
ISize
(
aWM
)
+
aPadding
.
ISize
(
aWM
)
-
boxSizingAdjust
.
ISize
(
aWM
)
;
nscoord
iSize
minISize
maxISize
bSize
minBSize
maxBSize
;
enum
class
Stretch
{
eStretchPreservingRatio
eStretch
eNoStretch
}
;
const
auto
eStretchPreservingRatio
=
Stretch
:
:
eStretchPreservingRatio
;
const
auto
eStretch
=
Stretch
:
:
eStretch
;
const
auto
eNoStretch
=
Stretch
:
:
eNoStretch
;
Stretch
stretchI
=
eNoStretch
;
Stretch
stretchB
=
eNoStretch
;
const
bool
isVertical
=
aWM
.
IsVertical
(
)
;
const
nsStyleCoord
&
isizeCoord
=
isVertical
?
aIntrinsicSize
.
height
:
aIntrinsicSize
.
width
;
const
bool
hasIntrinsicISize
=
isizeCoord
.
GetUnit
(
)
=
=
eStyleUnit_Coord
;
nscoord
intrinsicISize
;
if
(
hasIntrinsicISize
)
{
intrinsicISize
=
std
:
:
max
(
nscoord
(
0
)
isizeCoord
.
GetCoordValue
(
)
)
;
}
else
{
NS_ASSERTION
(
isizeCoord
.
GetUnit
(
)
=
=
eStyleUnit_None
"
unexpected
unit
"
)
;
intrinsicISize
=
0
;
}
const
nsStyleCoord
&
bsizeCoord
=
isVertical
?
aIntrinsicSize
.
width
:
aIntrinsicSize
.
height
;
const
bool
hasIntrinsicBSize
=
bsizeCoord
.
GetUnit
(
)
=
=
eStyleUnit_Coord
;
nscoord
intrinsicBSize
;
if
(
hasIntrinsicBSize
)
{
intrinsicBSize
=
std
:
:
max
(
nscoord
(
0
)
bsizeCoord
.
GetCoordValue
(
)
)
;
}
else
{
NS_ASSERTION
(
bsizeCoord
.
GetUnit
(
)
=
=
eStyleUnit_None
"
unexpected
unit
"
)
;
intrinsicBSize
=
0
;
}
NS_ASSERTION
(
aIntrinsicRatio
.
width
>
=
0
&
&
aIntrinsicRatio
.
height
>
=
0
"
Intrinsic
ratio
has
a
negative
component
!
"
)
;
LogicalSize
logicalRatio
(
aWM
aIntrinsicRatio
)
;
if
(
!
isAutoISize
)
{
iSize
=
ComputeISizeValue
(
aRenderingContext
aCBSize
.
ISize
(
aWM
)
boxSizingAdjust
.
ISize
(
aWM
)
boxSizingToMarginEdgeISize
*
inlineStyleCoord
aFlags
)
;
}
else
if
(
MOZ_UNLIKELY
(
isGridItem
)
)
{
MOZ_ASSERT
(
!
IS_TRUE_OVERFLOW_CONTAINER
(
this
)
)
;
auto
cbSize
=
aCBSize
.
ISize
(
aWM
)
;
if
(
cbSize
!
=
NS_UNCONSTRAINEDSIZE
)
{
if
(
!
StyleMargin
(
)
-
>
HasInlineAxisAuto
(
aWM
)
)
{
auto
inlineAxisAlignment
=
aWM
.
IsOrthogonalTo
(
GetParent
(
)
-
>
GetWritingMode
(
)
)
?
stylePos
-
>
UsedAlignSelf
(
GetParent
(
)
-
>
Style
(
)
)
:
stylePos
-
>
UsedJustifySelf
(
GetParent
(
)
-
>
Style
(
)
)
;
if
(
(
inlineAxisAlignment
=
=
NS_STYLE_ALIGN_NORMAL
&
&
!
hasIntrinsicISize
&
&
!
(
logicalRatio
.
ISize
(
aWM
)
>
0
)
)
|
|
inlineAxisAlignment
=
=
NS_STYLE_ALIGN_STRETCH
)
{
stretchI
=
eStretch
;
}
}
if
(
stretchI
!
=
eNoStretch
|
|
(
aFlags
&
ComputeSizeFlags
:
:
eIClampMarginBoxMinSize
)
)
{
iSize
=
std
:
:
max
(
nscoord
(
0
)
cbSize
-
aPadding
.
ISize
(
aWM
)
-
aBorder
.
ISize
(
aWM
)
-
aMargin
.
ISize
(
aWM
)
)
;
}
}
else
{
aFlags
=
ComputeSizeFlags
(
aFlags
&
~
ComputeSizeFlags
:
:
eIClampMarginBoxMinSize
)
;
}
}
const
auto
&
maxISizeCoord
=
stylePos
-
>
MaxISize
(
aWM
)
;
if
(
!
maxISizeCoord
.
IsNone
(
)
&
&
!
(
isFlexItem
&
&
flexMainAxis
=
=
eLogicalAxisInline
)
)
{
maxISize
=
ComputeISizeValue
(
aRenderingContext
aCBSize
.
ISize
(
aWM
)
boxSizingAdjust
.
ISize
(
aWM
)
boxSizingToMarginEdgeISize
maxISizeCoord
aFlags
)
;
}
else
{
maxISize
=
nscoord_MAX
;
}
const
auto
&
minISizeCoord
=
stylePos
-
>
MinISize
(
aWM
)
;
if
(
!
minISizeCoord
.
IsAuto
(
)
&
&
!
(
isFlexItem
&
&
flexMainAxis
=
=
eLogicalAxisInline
)
)
{
minISize
=
ComputeISizeValue
(
aRenderingContext
aCBSize
.
ISize
(
aWM
)
boxSizingAdjust
.
ISize
(
aWM
)
boxSizingToMarginEdgeISize
minISizeCoord
aFlags
)
;
}
else
{
minISize
=
0
;
}
if
(
!
isAutoBSize
)
{
bSize
=
nsLayoutUtils
:
:
ComputeBSizeValue
(
aCBSize
.
BSize
(
aWM
)
boxSizingAdjust
.
BSize
(
aWM
)
blockStyleCoord
-
>
AsLengthPercentage
(
)
)
;
}
else
if
(
MOZ_UNLIKELY
(
isGridItem
)
)
{
MOZ_ASSERT
(
!
IS_TRUE_OVERFLOW_CONTAINER
(
this
)
)
;
auto
cbSize
=
aCBSize
.
BSize
(
aWM
)
;
if
(
cbSize
!
=
NS_AUTOHEIGHT
)
{
if
(
!
StyleMargin
(
)
-
>
HasBlockAxisAuto
(
aWM
)
)
{
auto
blockAxisAlignment
=
!
aWM
.
IsOrthogonalTo
(
GetParent
(
)
-
>
GetWritingMode
(
)
)
?
stylePos
-
>
UsedAlignSelf
(
GetParent
(
)
-
>
Style
(
)
)
:
stylePos
-
>
UsedJustifySelf
(
GetParent
(
)
-
>
Style
(
)
)
;
if
(
(
blockAxisAlignment
=
=
NS_STYLE_ALIGN_NORMAL
&
&
!
hasIntrinsicBSize
&
&
!
(
logicalRatio
.
BSize
(
aWM
)
>
0
)
)
|
|
blockAxisAlignment
=
=
NS_STYLE_ALIGN_STRETCH
)
{
stretchB
=
eStretch
;
}
}
if
(
stretchB
!
=
eNoStretch
|
|
(
aFlags
&
ComputeSizeFlags
:
:
eBClampMarginBoxMinSize
)
)
{
bSize
=
std
:
:
max
(
nscoord
(
0
)
cbSize
-
aPadding
.
BSize
(
aWM
)
-
aBorder
.
BSize
(
aWM
)
-
aMargin
.
BSize
(
aWM
)
)
;
}
}
else
{
aFlags
=
ComputeSizeFlags
(
aFlags
&
~
ComputeSizeFlags
:
:
eBClampMarginBoxMinSize
)
;
}
}
const
auto
&
maxBSizeCoord
=
stylePos
-
>
MaxBSize
(
aWM
)
;
if
(
!
nsLayoutUtils
:
:
IsAutoBSize
(
maxBSizeCoord
aCBSize
.
BSize
(
aWM
)
)
&
&
!
(
isFlexItem
&
&
flexMainAxis
=
=
eLogicalAxisBlock
)
)
{
maxBSize
=
nsLayoutUtils
:
:
ComputeBSizeValue
(
aCBSize
.
BSize
(
aWM
)
boxSizingAdjust
.
BSize
(
aWM
)
maxBSizeCoord
.
AsLengthPercentage
(
)
)
;
}
else
{
maxBSize
=
nscoord_MAX
;
}
const
auto
&
minBSizeCoord
=
stylePos
-
>
MinBSize
(
aWM
)
;
if
(
!
nsLayoutUtils
:
:
IsAutoBSize
(
minBSizeCoord
aCBSize
.
BSize
(
aWM
)
)
&
&
!
(
isFlexItem
&
&
flexMainAxis
=
=
eLogicalAxisBlock
)
)
{
minBSize
=
nsLayoutUtils
:
:
ComputeBSizeValue
(
aCBSize
.
BSize
(
aWM
)
boxSizingAdjust
.
BSize
(
aWM
)
minBSizeCoord
.
AsLengthPercentage
(
)
)
;
}
else
{
minBSize
=
0
;
}
NS_ASSERTION
(
aCBSize
.
ISize
(
aWM
)
!
=
NS_UNCONSTRAINEDSIZE
"
Our
containing
block
must
not
have
unconstrained
inline
-
size
!
"
)
;
if
(
isAutoISize
)
{
if
(
isAutoBSize
)
{
nscoord
tentISize
tentBSize
;
if
(
hasIntrinsicISize
)
{
tentISize
=
intrinsicISize
;
}
else
if
(
hasIntrinsicBSize
&
&
logicalRatio
.
BSize
(
aWM
)
>
0
)
{
tentISize
=
NSCoordMulDiv
(
intrinsicBSize
logicalRatio
.
ISize
(
aWM
)
logicalRatio
.
BSize
(
aWM
)
)
;
}
else
if
(
logicalRatio
.
ISize
(
aWM
)
>
0
)
{
tentISize
=
aCBSize
.
ISize
(
aWM
)
-
boxSizingToMarginEdgeISize
;
if
(
tentISize
<
0
)
tentISize
=
0
;
}
else
{
tentISize
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
300
)
;
}
if
(
(
aFlags
&
ComputeSizeFlags
:
:
eIClampMarginBoxMinSize
)
&
&
stretchI
!
=
eStretch
&
&
tentISize
>
iSize
)
{
stretchI
=
(
stretchB
=
=
eStretch
?
eStretch
:
eStretchPreservingRatio
)
;
}
if
(
hasIntrinsicBSize
)
{
tentBSize
=
intrinsicBSize
;
}
else
if
(
logicalRatio
.
ISize
(
aWM
)
>
0
)
{
tentBSize
=
NSCoordMulDiv
(
tentISize
logicalRatio
.
BSize
(
aWM
)
logicalRatio
.
ISize
(
aWM
)
)
;
}
else
{
tentBSize
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
150
)
;
}
if
(
(
aFlags
&
ComputeSizeFlags
:
:
eBClampMarginBoxMinSize
)
&
&
stretchB
!
=
eStretch
&
&
tentBSize
>
bSize
)
{
stretchB
=
(
stretchI
=
=
eStretch
?
eStretch
:
eStretchPreservingRatio
)
;
}
if
(
aIntrinsicRatio
!
=
nsSize
(
0
0
)
)
{
if
(
stretchI
=
=
eStretch
)
{
tentISize
=
iSize
;
if
(
stretchB
=
=
eStretch
)
{
tentBSize
=
bSize
;
}
else
if
(
stretchB
=
=
eStretchPreservingRatio
&
&
logicalRatio
.
ISize
(
aWM
)
>
0
)
{
tentBSize
=
NSCoordMulDiv
(
iSize
logicalRatio
.
BSize
(
aWM
)
logicalRatio
.
ISize
(
aWM
)
)
;
}
}
else
if
(
stretchB
=
=
eStretch
)
{
tentBSize
=
bSize
;
if
(
stretchI
=
=
eStretchPreservingRatio
&
&
logicalRatio
.
BSize
(
aWM
)
>
0
)
{
tentISize
=
NSCoordMulDiv
(
bSize
logicalRatio
.
ISize
(
aWM
)
logicalRatio
.
BSize
(
aWM
)
)
;
}
}
else
if
(
stretchI
=
=
eStretchPreservingRatio
)
{
tentISize
=
iSize
;
if
(
logicalRatio
.
ISize
(
aWM
)
>
0
)
{
tentBSize
=
NSCoordMulDiv
(
iSize
logicalRatio
.
BSize
(
aWM
)
logicalRatio
.
ISize
(
aWM
)
)
;
}
if
(
stretchB
=
=
eStretchPreservingRatio
&
&
tentBSize
>
bSize
)
{
tentBSize
=
bSize
;
if
(
logicalRatio
.
BSize
(
aWM
)
>
0
)
{
tentISize
=
NSCoordMulDiv
(
bSize
logicalRatio
.
ISize
(
aWM
)
logicalRatio
.
BSize
(
aWM
)
)
;
}
}
}
else
if
(
stretchB
=
=
eStretchPreservingRatio
)
{
tentBSize
=
bSize
;
if
(
logicalRatio
.
BSize
(
aWM
)
>
0
)
{
tentISize
=
NSCoordMulDiv
(
bSize
logicalRatio
.
ISize
(
aWM
)
logicalRatio
.
BSize
(
aWM
)
)
;
}
}
}
if
(
aIntrinsicRatio
!
=
nsSize
(
0
0
)
&
&
stretchI
!
=
eStretch
&
&
stretchB
!
=
eStretch
)
{
nsSize
autoSize
=
nsLayoutUtils
:
:
ComputeAutoSizeWithIntrinsicDimensions
(
minISize
minBSize
maxISize
maxBSize
tentISize
tentBSize
)
;
iSize
=
autoSize
.
width
;
bSize
=
autoSize
.
height
;
}
else
{
iSize
=
NS_CSS_MINMAX
(
tentISize
minISize
maxISize
)
;
bSize
=
NS_CSS_MINMAX
(
tentBSize
minBSize
maxBSize
)
;
}
}
else
{
bSize
=
NS_CSS_MINMAX
(
bSize
minBSize
maxBSize
)
;
if
(
stretchI
!
=
eStretch
)
{
if
(
logicalRatio
.
BSize
(
aWM
)
>
0
)
{
iSize
=
NSCoordMulDiv
(
bSize
logicalRatio
.
ISize
(
aWM
)
logicalRatio
.
BSize
(
aWM
)
)
;
}
else
if
(
hasIntrinsicISize
)
{
if
(
!
(
(
aFlags
&
ComputeSizeFlags
:
:
eIClampMarginBoxMinSize
)
&
&
intrinsicISize
>
iSize
)
)
{
iSize
=
intrinsicISize
;
}
}
else
{
iSize
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
300
)
;
}
}
iSize
=
NS_CSS_MINMAX
(
iSize
minISize
maxISize
)
;
}
}
else
{
if
(
isAutoBSize
)
{
iSize
=
NS_CSS_MINMAX
(
iSize
minISize
maxISize
)
;
if
(
stretchB
!
=
eStretch
)
{
if
(
logicalRatio
.
ISize
(
aWM
)
>
0
)
{
bSize
=
NSCoordMulDiv
(
iSize
logicalRatio
.
BSize
(
aWM
)
logicalRatio
.
ISize
(
aWM
)
)
;
}
else
if
(
hasIntrinsicBSize
)
{
if
(
!
(
(
aFlags
&
ComputeSizeFlags
:
:
eBClampMarginBoxMinSize
)
&
&
intrinsicBSize
>
bSize
)
)
{
bSize
=
intrinsicBSize
;
}
}
else
{
bSize
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
150
)
;
}
}
bSize
=
NS_CSS_MINMAX
(
bSize
minBSize
maxBSize
)
;
}
else
{
iSize
=
NS_CSS_MINMAX
(
iSize
minISize
maxISize
)
;
bSize
=
NS_CSS_MINMAX
(
bSize
minBSize
maxBSize
)
;
}
}
return
LogicalSize
(
aWM
iSize
bSize
)
;
}
nsRect
nsIFrame
:
:
ComputeTightBounds
(
DrawTarget
*
aDrawTarget
)
const
{
return
GetVisualOverflowRect
(
)
;
}
nsRect
nsFrame
:
:
ComputeSimpleTightBounds
(
DrawTarget
*
aDrawTarget
)
const
{
if
(
StyleOutline
(
)
-
>
ShouldPaintOutline
(
)
|
|
StyleBorder
(
)
-
>
HasBorder
(
)
|
|
!
StyleBackground
(
)
-
>
IsTransparent
(
this
)
|
|
StyleDisplay
(
)
-
>
HasAppearance
(
)
)
{
return
GetVisualOverflowRect
(
)
;
}
nsRect
r
(
0
0
0
0
)
;
ChildListIterator
lists
(
this
)
;
for
(
;
!
lists
.
IsDone
(
)
;
lists
.
Next
(
)
)
{
nsFrameList
:
:
Enumerator
childFrames
(
lists
.
CurrentList
(
)
)
;
for
(
;
!
childFrames
.
AtEnd
(
)
;
childFrames
.
Next
(
)
)
{
nsIFrame
*
child
=
childFrames
.
get
(
)
;
r
.
UnionRect
(
r
child
-
>
ComputeTightBounds
(
aDrawTarget
)
+
child
-
>
GetPosition
(
)
)
;
}
}
return
r
;
}
nsresult
nsIFrame
:
:
GetPrefWidthTightBounds
(
gfxContext
*
aContext
nscoord
*
aX
nscoord
*
aXMost
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
LogicalSize
nsFrame
:
:
ComputeAutoSize
(
gfxContext
*
aRenderingContext
WritingMode
aWM
const
mozilla
:
:
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
mozilla
:
:
LogicalSize
&
aMargin
const
mozilla
:
:
LogicalSize
&
aBorder
const
mozilla
:
:
LogicalSize
&
aPadding
ComputeSizeFlags
aFlags
)
{
LogicalSize
result
(
aWM
0xdeadbeef
NS_UNCONSTRAINEDSIZE
)
;
if
(
StylePosition
(
)
-
>
ISize
(
aWM
)
.
IsAuto
(
)
)
{
nscoord
availBased
=
aAvailableISize
-
aMargin
.
ISize
(
aWM
)
-
aBorder
.
ISize
(
aWM
)
-
aPadding
.
ISize
(
aWM
)
;
result
.
ISize
(
aWM
)
=
ShrinkWidthToFit
(
aRenderingContext
availBased
aFlags
)
;
}
return
result
;
}
nscoord
nsFrame
:
:
ShrinkWidthToFit
(
gfxContext
*
aRenderingContext
nscoord
aISizeInCB
ComputeSizeFlags
aFlags
)
{
AutoMaybeDisableFontInflation
an
(
this
)
;
nscoord
result
;
nscoord
minISize
=
GetMinISize
(
aRenderingContext
)
;
if
(
minISize
>
aISizeInCB
)
{
const
bool
clamp
=
aFlags
&
ComputeSizeFlags
:
:
eIClampMarginBoxMinSize
;
result
=
MOZ_UNLIKELY
(
clamp
)
?
aISizeInCB
:
minISize
;
}
else
{
nscoord
prefISize
=
GetPrefISize
(
aRenderingContext
)
;
if
(
prefISize
>
aISizeInCB
)
{
result
=
aISizeInCB
;
}
else
{
result
=
prefISize
;
}
}
return
result
;
}
nscoord
nsIFrame
:
:
ComputeISizeValue
(
gfxContext
*
aRenderingContext
nscoord
aContainingBlockISize
nscoord
aContentEdgeToBoxSizing
nscoord
aBoxSizingToMarginEdge
StyleExtremumLength
aSize
ComputeSizeFlags
aFlags
)
{
AutoMaybeDisableFontInflation
an
(
this
)
;
nscoord
result
;
switch
(
aSize
)
{
case
StyleExtremumLength
:
:
MaxContent
:
result
=
GetPrefISize
(
aRenderingContext
)
;
NS_ASSERTION
(
result
>
=
0
"
inline
-
size
less
than
zero
"
)
;
return
result
;
case
StyleExtremumLength
:
:
MinContent
:
result
=
GetMinISize
(
aRenderingContext
)
;
NS_ASSERTION
(
result
>
=
0
"
inline
-
size
less
than
zero
"
)
;
if
(
MOZ_UNLIKELY
(
aFlags
&
ComputeSizeFlags
:
:
eIClampMarginBoxMinSize
)
)
{
auto
available
=
aContainingBlockISize
-
(
aBoxSizingToMarginEdge
+
aContentEdgeToBoxSizing
)
;
result
=
std
:
:
min
(
available
result
)
;
}
return
result
;
case
StyleExtremumLength
:
:
MozFitContent
:
{
nscoord
pref
=
GetPrefISize
(
aRenderingContext
)
min
=
GetMinISize
(
aRenderingContext
)
fill
=
aContainingBlockISize
-
(
aBoxSizingToMarginEdge
+
aContentEdgeToBoxSizing
)
;
if
(
MOZ_UNLIKELY
(
aFlags
&
ComputeSizeFlags
:
:
eIClampMarginBoxMinSize
)
)
{
min
=
std
:
:
min
(
min
fill
)
;
}
result
=
std
:
:
max
(
min
std
:
:
min
(
pref
fill
)
)
;
NS_ASSERTION
(
result
>
=
0
"
inline
-
size
less
than
zero
"
)
;
return
result
;
}
case
StyleExtremumLength
:
:
MozAvailable
:
return
aContainingBlockISize
-
(
aBoxSizingToMarginEdge
+
aContentEdgeToBoxSizing
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
extremum
length
?
"
)
;
return
0
;
}
nscoord
nsIFrame
:
:
ComputeISizeValue
(
gfxContext
*
aRenderingContext
nscoord
aContainingBlockISize
nscoord
aContentEdgeToBoxSizing
nscoord
aBoxSizingToMarginEdge
const
LengthPercentage
&
aCoord
ComputeSizeFlags
aFlags
)
{
MOZ_ASSERT
(
aRenderingContext
"
non
-
null
rendering
context
expected
"
)
;
LAYOUT_WARN_IF_FALSE
(
aContainingBlockISize
!
=
NS_UNCONSTRAINEDSIZE
"
have
unconstrained
inline
-
size
;
this
should
only
result
from
"
"
very
large
sizes
not
attempts
at
intrinsic
inline
-
size
"
"
calculation
"
)
;
MOZ_ASSERT
(
aContainingBlockISize
>
=
0
"
inline
-
size
less
than
zero
"
)
;
nscoord
result
=
aCoord
.
Resolve
(
aContainingBlockISize
)
;
result
-
=
aContentEdgeToBoxSizing
;
return
std
:
:
max
(
0
result
)
;
}
void
nsFrame
:
:
DidReflow
(
nsPresContext
*
aPresContext
const
ReflowInput
*
aReflowInput
)
{
NS_FRAME_TRACE_MSG
(
NS_FRAME_TRACE_CALLS
(
"
nsFrame
:
:
DidReflow
"
)
)
;
SVGObserverUtils
:
:
InvalidateDirectRenderingObservers
(
this
SVGObserverUtils
:
:
INVALIDATE_REFLOW
)
;
RemoveStateBits
(
NS_FRAME_IN_REFLOW
|
NS_FRAME_FIRST_REFLOW
|
NS_FRAME_IS_DIRTY
|
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
if
(
aReflowInput
&
&
aReflowInput
-
>
mPercentBSizeObserver
&
&
!
GetPrevInFlow
(
)
)
{
const
auto
&
bsize
=
aReflowInput
-
>
mStylePosition
-
>
BSize
(
aReflowInput
-
>
GetWritingMode
(
)
)
;
if
(
bsize
.
HasPercent
(
)
)
{
aReflowInput
-
>
mPercentBSizeObserver
-
>
NotifyPercentBSize
(
*
aReflowInput
)
;
}
}
aPresContext
-
>
ReflowedFrame
(
)
;
}
void
nsFrame
:
:
FinishReflowWithAbsoluteFrames
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
bool
aConstrainBSize
)
{
ReflowAbsoluteFrames
(
aPresContext
aDesiredSize
aReflowInput
aStatus
aConstrainBSize
)
;
FinishAndStoreOverflow
(
&
aDesiredSize
aReflowInput
.
mStyleDisplay
)
;
}
void
nsFrame
:
:
ReflowAbsoluteFrames
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
bool
aConstrainBSize
)
{
if
(
HasAbsolutelyPositionedChildren
(
)
)
{
nsAbsoluteContainingBlock
*
absoluteContainer
=
GetAbsoluteContainingBlock
(
)
;
nsMargin
usedBorder
=
GetUsedBorder
(
)
;
nscoord
containingBlockWidth
=
std
:
:
max
(
0
aDesiredSize
.
Width
(
)
-
usedBorder
.
LeftRight
(
)
)
;
nscoord
containingBlockHeight
=
std
:
:
max
(
0
aDesiredSize
.
Height
(
)
-
usedBorder
.
TopBottom
(
)
)
;
nsContainerFrame
*
container
=
do_QueryFrame
(
this
)
;
NS_ASSERTION
(
container
"
Abs
-
pos
children
only
supported
on
container
frames
for
now
"
)
;
nsRect
containingBlock
(
0
0
containingBlockWidth
containingBlockHeight
)
;
AbsPosReflowFlags
flags
=
AbsPosReflowFlags
:
:
eCBWidthAndHeightChanged
;
if
(
aConstrainBSize
)
{
flags
|
=
AbsPosReflowFlags
:
:
eConstrainHeight
;
}
absoluteContainer
-
>
Reflow
(
container
aPresContext
aReflowInput
aStatus
containingBlock
flags
&
aDesiredSize
.
mOverflowAreas
)
;
}
}
void
nsFrame
:
:
PushDirtyBitToAbsoluteFrames
(
)
{
if
(
!
(
GetStateBits
(
)
&
NS_FRAME_IS_DIRTY
)
)
{
return
;
}
if
(
!
HasAbsolutelyPositionedChildren
(
)
)
{
return
;
}
GetAbsoluteContainingBlock
(
)
-
>
MarkAllFramesDirty
(
)
;
}
bool
nsFrame
:
:
CanContinueTextRun
(
)
const
{
return
false
;
}
void
nsFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsFrame
"
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
aDesiredSize
.
ClearSize
(
)
;
NS_FRAME_SET_TRUNCATION
(
aStatus
aReflowInput
aDesiredSize
)
;
}
bool
nsIFrame
:
:
IsContentDisabled
(
)
const
{
if
(
StyleUI
(
)
-
>
mUserInput
=
=
StyleUserInput
:
:
None
)
{
return
true
;
}
auto
*
element
=
nsGenericHTMLElement
:
:
FromNodeOrNull
(
GetContent
(
)
)
;
return
element
&
&
element
-
>
IsDisabled
(
)
;
}
nsresult
nsFrame
:
:
CharacterDataChanged
(
const
CharacterDataChangeInfo
&
)
{
MOZ_ASSERT_UNREACHABLE
(
"
should
only
be
called
for
text
frames
"
)
;
return
NS_OK
;
}
nsresult
nsFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
return
NS_OK
;
}
nsIFrame
*
nsFrame
:
:
GetPrevContinuation
(
)
const
{
return
nullptr
;
}
void
nsFrame
:
:
SetPrevContinuation
(
nsIFrame
*
aPrevContinuation
)
{
MOZ_ASSERT
(
false
"
not
splittable
"
)
;
}
nsIFrame
*
nsFrame
:
:
GetNextContinuation
(
)
const
{
return
nullptr
;
}
void
nsFrame
:
:
SetNextContinuation
(
nsIFrame
*
)
{
MOZ_ASSERT
(
false
"
not
splittable
"
)
;
}
nsIFrame
*
nsFrame
:
:
GetPrevInFlowVirtual
(
)
const
{
return
nullptr
;
}
void
nsFrame
:
:
SetPrevInFlow
(
nsIFrame
*
aPrevInFlow
)
{
MOZ_ASSERT
(
false
"
not
splittable
"
)
;
}
nsIFrame
*
nsFrame
:
:
GetNextInFlowVirtual
(
)
const
{
return
nullptr
;
}
void
nsFrame
:
:
SetNextInFlow
(
nsIFrame
*
)
{
MOZ_ASSERT
(
false
"
not
splittable
"
)
;
}
nsIFrame
*
nsIFrame
:
:
GetTailContinuation
(
)
{
nsIFrame
*
frame
=
this
;
while
(
frame
-
>
GetStateBits
(
)
&
NS_FRAME_IS_OVERFLOW_CONTAINER
)
{
frame
=
frame
-
>
GetPrevContinuation
(
)
;
NS_ASSERTION
(
frame
"
first
continuation
can
'
t
be
overflow
container
"
)
;
}
for
(
nsIFrame
*
next
=
frame
-
>
GetNextContinuation
(
)
;
next
&
&
!
(
next
-
>
GetStateBits
(
)
&
NS_FRAME_IS_OVERFLOW_CONTAINER
)
;
next
=
frame
-
>
GetNextContinuation
(
)
)
{
frame
=
next
;
}
MOZ_ASSERT
(
frame
"
illegal
state
in
continuation
chain
.
"
)
;
return
frame
;
}
void
nsIFrame
:
:
SetView
(
nsView
*
aView
)
{
if
(
aView
)
{
aView
-
>
SetFrame
(
this
)
;
#
ifdef
DEBUG
LayoutFrameType
frameType
=
Type
(
)
;
NS_ASSERTION
(
frameType
=
=
LayoutFrameType
:
:
SubDocument
|
|
frameType
=
=
LayoutFrameType
:
:
ListControl
|
|
frameType
=
=
LayoutFrameType
:
:
Object
|
|
frameType
=
=
LayoutFrameType
:
:
Viewport
|
|
frameType
=
=
LayoutFrameType
:
:
MenuPopup
"
Only
specific
frame
types
can
have
an
nsView
"
)
;
#
endif
SetViewInternal
(
aView
)
;
AddStateBits
(
NS_FRAME_HAS_VIEW
)
;
for
(
nsIFrame
*
f
=
GetParent
(
)
;
f
&
&
!
(
f
-
>
GetStateBits
(
)
&
NS_FRAME_HAS_CHILD_WITH_VIEW
)
;
f
=
f
-
>
GetParent
(
)
)
f
-
>
AddStateBits
(
NS_FRAME_HAS_CHILD_WITH_VIEW
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Destroying
a
view
while
the
frame
is
alive
?
"
)
;
RemoveStateBits
(
NS_FRAME_HAS_VIEW
)
;
SetViewInternal
(
nullptr
)
;
}
}
nsIFrame
*
nsIFrame
:
:
GetAncestorWithView
(
)
const
{
for
(
nsIFrame
*
f
=
GetParent
(
)
;
nullptr
!
=
f
;
f
=
f
-
>
GetParent
(
)
)
{
if
(
f
-
>
HasView
(
)
)
{
return
f
;
}
}
return
nullptr
;
}
template
<
nsPoint
(
nsIFrame
:
:
*
PositionGetter
)
(
)
const
>
static
nsPoint
OffsetCalculator
(
const
nsIFrame
*
aThis
const
nsIFrame
*
aOther
)
{
MOZ_ASSERT
(
aOther
"
Must
have
frame
for
destination
coordinate
system
!
"
)
;
NS_ASSERTION
(
aThis
-
>
PresContext
(
)
=
=
aOther
-
>
PresContext
(
)
"
GetOffsetTo
called
on
frames
in
different
documents
"
)
;
nsPoint
offset
(
0
0
)
;
const
nsIFrame
*
f
;
for
(
f
=
aThis
;
f
!
=
aOther
&
&
f
;
f
=
f
-
>
GetParent
(
)
)
{
offset
+
=
(
f
-
>
*
PositionGetter
)
(
)
;
}
if
(
f
!
=
aOther
)
{
while
(
aOther
)
{
offset
-
=
(
aOther
-
>
*
PositionGetter
)
(
)
;
aOther
=
aOther
-
>
GetParent
(
)
;
}
}
return
offset
;
}
nsPoint
nsIFrame
:
:
GetOffsetTo
(
const
nsIFrame
*
aOther
)
const
{
return
OffsetCalculator
<
&
nsIFrame
:
:
GetPosition
>
(
this
aOther
)
;
}
nsPoint
nsIFrame
:
:
GetOffsetToIgnoringScrolling
(
const
nsIFrame
*
aOther
)
const
{
return
OffsetCalculator
<
&
nsIFrame
:
:
GetPositionIgnoringScrolling
>
(
this
aOther
)
;
}
nsPoint
nsIFrame
:
:
GetOffsetToCrossDoc
(
const
nsIFrame
*
aOther
)
const
{
return
GetOffsetToCrossDoc
(
aOther
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
}
nsPoint
nsIFrame
:
:
GetOffsetToCrossDoc
(
const
nsIFrame
*
aOther
const
int32_t
aAPD
)
const
{
MOZ_ASSERT
(
aOther
"
Must
have
frame
for
destination
coordinate
system
!
"
)
;
NS_ASSERTION
(
PresContext
(
)
-
>
GetRootPresContext
(
)
=
=
aOther
-
>
PresContext
(
)
-
>
GetRootPresContext
(
)
"
trying
to
get
the
offset
between
frames
in
different
document
"
"
hierarchies
?
"
)
;
if
(
PresContext
(
)
-
>
GetRootPresContext
(
)
!
=
aOther
-
>
PresContext
(
)
-
>
GetRootPresContext
(
)
)
{
MOZ_CRASH
(
"
trying
to
get
the
offset
between
frames
in
different
"
"
document
hierarchies
?
"
)
;
}
const
nsIFrame
*
root
=
nullptr
;
nsPoint
offset
(
0
0
)
docOffset
(
0
0
)
;
const
nsIFrame
*
f
=
this
;
int32_t
currAPD
=
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
while
(
f
&
&
f
!
=
aOther
)
{
docOffset
+
=
f
-
>
GetPosition
(
)
;
nsIFrame
*
parent
=
f
-
>
GetParent
(
)
;
if
(
parent
)
{
f
=
parent
;
}
else
{
nsPoint
newOffset
(
0
0
)
;
root
=
f
;
f
=
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
f
&
newOffset
)
;
int32_t
newAPD
=
f
?
f
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
:
0
;
if
(
!
f
|
|
newAPD
!
=
currAPD
)
{
offset
+
=
docOffset
.
ScaleToOtherAppUnits
(
currAPD
aAPD
)
;
docOffset
.
x
=
docOffset
.
y
=
0
;
}
currAPD
=
newAPD
;
docOffset
+
=
newOffset
;
}
}
if
(
f
=
=
aOther
)
{
offset
+
=
docOffset
.
ScaleToOtherAppUnits
(
currAPD
aAPD
)
;
}
else
{
nsPoint
negOffset
=
aOther
-
>
GetOffsetToCrossDoc
(
root
aAPD
)
;
offset
-
=
negOffset
;
}
return
offset
;
}
CSSIntRect
nsIFrame
:
:
GetScreenRect
(
)
const
{
return
CSSIntRect
:
:
FromAppUnitsToNearest
(
GetScreenRectInAppUnits
(
)
)
;
}
nsRect
nsIFrame
:
:
GetScreenRectInAppUnits
(
)
const
{
nsPresContext
*
presContext
=
PresContext
(
)
;
nsIFrame
*
rootFrame
=
presContext
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
;
nsPoint
rootScreenPos
(
0
0
)
;
nsPoint
rootFrameOffsetInParent
(
0
0
)
;
nsIFrame
*
rootFrameParent
=
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
rootFrame
&
rootFrameOffsetInParent
)
;
if
(
rootFrameParent
)
{
nsRect
parentScreenRectAppUnits
=
rootFrameParent
-
>
GetScreenRectInAppUnits
(
)
;
nsPresContext
*
parentPresContext
=
rootFrameParent
-
>
PresContext
(
)
;
double
parentScale
=
double
(
presContext
-
>
AppUnitsPerDevPixel
(
)
)
/
parentPresContext
-
>
AppUnitsPerDevPixel
(
)
;
nsPoint
rootPt
=
parentScreenRectAppUnits
.
TopLeft
(
)
+
rootFrameOffsetInParent
;
rootScreenPos
.
x
=
NS_round
(
parentScale
*
rootPt
.
x
)
;
rootScreenPos
.
y
=
NS_round
(
parentScale
*
rootPt
.
y
)
;
}
else
{
nsCOMPtr
<
nsIWidget
>
rootWidget
;
presContext
-
>
PresShell
(
)
-
>
GetViewManager
(
)
-
>
GetRootWidget
(
getter_AddRefs
(
rootWidget
)
)
;
if
(
rootWidget
)
{
LayoutDeviceIntPoint
rootDevPx
=
rootWidget
-
>
WidgetToScreenOffset
(
)
;
rootScreenPos
.
x
=
presContext
-
>
DevPixelsToAppUnits
(
rootDevPx
.
x
)
;
rootScreenPos
.
y
=
presContext
-
>
DevPixelsToAppUnits
(
rootDevPx
.
y
)
;
}
}
return
nsRect
(
rootScreenPos
+
GetOffsetTo
(
rootFrame
)
GetSize
(
)
)
;
}
void
nsIFrame
:
:
GetOffsetFromView
(
nsPoint
&
aOffset
nsView
*
*
aView
)
const
{
MOZ_ASSERT
(
nullptr
!
=
aView
"
null
OUT
parameter
pointer
"
)
;
nsIFrame
*
frame
=
const_cast
<
nsIFrame
*
>
(
this
)
;
*
aView
=
nullptr
;
aOffset
.
MoveTo
(
0
0
)
;
do
{
aOffset
+
=
frame
-
>
GetPosition
(
)
;
frame
=
frame
-
>
GetParent
(
)
;
}
while
(
frame
&
&
!
frame
-
>
HasView
(
)
)
;
if
(
frame
)
{
*
aView
=
frame
-
>
GetView
(
)
;
}
}
nsIWidget
*
nsIFrame
:
:
GetNearestWidget
(
)
const
{
return
GetClosestView
(
)
-
>
GetNearestWidget
(
nullptr
)
;
}
nsIWidget
*
nsIFrame
:
:
GetNearestWidget
(
nsPoint
&
aOffset
)
const
{
nsPoint
offsetToView
;
nsPoint
offsetToWidget
;
nsIWidget
*
widget
=
GetClosestView
(
&
offsetToView
)
-
>
GetNearestWidget
(
&
offsetToWidget
)
;
aOffset
=
offsetToView
+
offsetToWidget
;
return
widget
;
}
Matrix4x4Flagged
nsIFrame
:
:
GetTransformMatrix
(
const
nsIFrame
*
aStopAtAncestor
nsIFrame
*
*
aOutAncestor
uint32_t
aFlags
)
const
{
MOZ_ASSERT
(
aOutAncestor
"
Need
a
place
to
put
the
ancestor
!
"
)
;
if
(
IsTransformed
(
)
)
{
NS_ASSERTION
(
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
this
)
"
Cannot
transform
the
viewport
frame
!
"
)
;
int32_t
scaleFactor
=
(
(
aFlags
&
IN_CSS_UNITS
)
?
AppUnitsPerCSSPixel
(
)
:
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
Matrix4x4
result
=
nsDisplayTransform
:
:
GetResultingTransformMatrix
(
this
nsPoint
(
0
0
)
scaleFactor
nsDisplayTransform
:
:
INCLUDE_PERSPECTIVE
|
nsDisplayTransform
:
:
OFFSET_BY_ORIGIN
nullptr
)
;
*
aOutAncestor
=
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
this
)
;
nsPoint
delta
=
GetOffsetToCrossDoc
(
*
aOutAncestor
)
;
result
.
PostTranslate
(
NSAppUnitsToFloatPixels
(
delta
.
x
scaleFactor
)
NSAppUnitsToFloatPixels
(
delta
.
y
scaleFactor
)
0
.
0f
)
;
return
result
;
}
if
(
nsLayoutUtils
:
:
IsPopup
(
this
)
&
&
IsListControlFrame
(
)
)
{
nsPresContext
*
presContext
=
PresContext
(
)
;
nsIFrame
*
docRootFrame
=
presContext
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
;
nsIWidget
*
widget
=
GetView
(
)
-
>
GetWidget
(
)
;
nsPresContext
*
rootPresContext
=
PresContext
(
)
-
>
GetRootPresContext
(
)
;
if
(
widget
&
&
rootPresContext
)
{
nsIWidget
*
toplevel
=
rootPresContext
-
>
GetNearestWidget
(
)
;
if
(
toplevel
)
{
LayoutDeviceIntRect
screenBounds
=
widget
-
>
GetClientBounds
(
)
;
LayoutDeviceIntRect
toplevelScreenBounds
=
toplevel
-
>
GetClientBounds
(
)
;
LayoutDeviceIntPoint
translation
=
screenBounds
.
TopLeft
(
)
-
toplevelScreenBounds
.
TopLeft
(
)
;
Matrix4x4
transformToTop
;
transformToTop
.
_41
=
translation
.
x
;
transformToTop
.
_42
=
translation
.
y
;
*
aOutAncestor
=
docRootFrame
;
Matrix4x4
docRootTransformToTop
=
nsLayoutUtils
:
:
GetTransformToAncestor
(
docRootFrame
nullptr
)
.
GetMatrix
(
)
;
if
(
docRootTransformToTop
.
IsSingular
(
)
)
{
NS_WARNING
(
"
Containing
document
is
invisible
we
can
'
t
compute
a
valid
"
"
transform
"
)
;
}
else
{
docRootTransformToTop
.
Invert
(
)
;
return
transformToTop
*
docRootTransformToTop
;
}
}
}
}
*
aOutAncestor
=
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
this
)
;
if
(
!
*
aOutAncestor
)
return
Matrix4x4
(
)
;
const
nsIFrame
*
current
=
this
;
while
(
!
(
*
aOutAncestor
)
-
>
IsTransformed
(
)
&
&
!
nsLayoutUtils
:
:
IsPopup
(
*
aOutAncestor
)
&
&
*
aOutAncestor
!
=
aStopAtAncestor
&
&
(
!
(
aFlags
&
STOP_AT_STACKING_CONTEXT_AND_DISPLAY_PORT
)
|
|
(
!
(
*
aOutAncestor
)
-
>
IsStackingContext
(
)
&
&
!
nsLayoutUtils
:
:
FrameHasDisplayPort
(
*
aOutAncestor
current
)
)
)
)
{
nsIFrame
*
parent
=
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
*
aOutAncestor
)
;
if
(
!
parent
)
break
;
current
=
*
aOutAncestor
;
*
aOutAncestor
=
parent
;
}
NS_ASSERTION
(
*
aOutAncestor
"
Somehow
ended
up
with
a
null
ancestor
.
.
.
?
"
)
;
nsPoint
delta
=
GetOffsetToCrossDoc
(
*
aOutAncestor
)
;
int32_t
scaleFactor
=
(
(
aFlags
&
IN_CSS_UNITS
)
?
AppUnitsPerCSSPixel
(
)
:
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
return
Matrix4x4
:
:
Translation
(
NSAppUnitsToFloatPixels
(
delta
.
x
scaleFactor
)
NSAppUnitsToFloatPixels
(
delta
.
y
scaleFactor
)
0
.
0f
)
;
}
static
void
InvalidateRenderingObservers
(
nsIFrame
*
aDisplayRoot
nsIFrame
*
aFrame
bool
aFrameChanged
=
true
)
{
MOZ_ASSERT
(
aDisplayRoot
=
=
nsLayoutUtils
:
:
GetDisplayRootFrame
(
aFrame
)
)
;
SVGObserverUtils
:
:
InvalidateDirectRenderingObservers
(
aFrame
)
;
nsIFrame
*
parent
=
aFrame
;
while
(
parent
!
=
aDisplayRoot
&
&
(
parent
=
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
parent
)
)
&
&
!
parent
-
>
HasAnyStateBits
(
NS_FRAME_DESCENDANT_NEEDS_PAINT
)
)
{
SVGObserverUtils
:
:
InvalidateDirectRenderingObservers
(
parent
)
;
}
if
(
!
aFrameChanged
)
{
return
;
}
aFrame
-
>
MarkNeedsDisplayItemRebuild
(
)
;
}
static
void
SchedulePaintInternal
(
nsIFrame
*
aDisplayRoot
nsIFrame
*
aFrame
nsIFrame
:
:
PaintType
aType
=
nsIFrame
:
:
PAINT_DEFAULT
)
{
MOZ_ASSERT
(
aDisplayRoot
=
=
nsLayoutUtils
:
:
GetDisplayRootFrame
(
aFrame
)
)
;
nsPresContext
*
pres
=
aDisplayRoot
-
>
PresContext
(
)
-
>
GetRootPresContext
(
)
;
if
(
!
pres
|
|
(
pres
-
>
Document
(
)
&
&
pres
-
>
Document
(
)
-
>
IsResourceDoc
(
)
)
)
{
return
;
}
if
(
!
pres
-
>
GetContainerWeak
(
)
)
{
NS_WARNING
(
"
Shouldn
'
t
call
SchedulePaint
in
a
detached
pres
context
"
)
;
return
;
}
pres
-
>
PresShell
(
)
-
>
ScheduleViewManagerFlush
(
aType
=
=
nsIFrame
:
:
PAINT_DELAYED_COMPRESS
?
nsIPresShell
:
:
PAINT_DELAYED_COMPRESS
:
nsIPresShell
:
:
PAINT_DEFAULT
)
;
if
(
aType
=
=
nsIFrame
:
:
PAINT_DELAYED_COMPRESS
)
{
return
;
}
if
(
aType
=
=
nsIFrame
:
:
PAINT_DEFAULT
)
{
aDisplayRoot
-
>
AddStateBits
(
NS_FRAME_UPDATE_LAYER_TREE
)
;
}
}
static
void
InvalidateFrameInternal
(
nsIFrame
*
aFrame
bool
aHasDisplayItem
bool
aRebuildDisplayItems
)
{
if
(
aHasDisplayItem
)
{
aFrame
-
>
AddStateBits
(
NS_FRAME_NEEDS_PAINT
)
;
}
if
(
aRebuildDisplayItems
)
{
aFrame
-
>
MarkNeedsDisplayItemRebuild
(
)
;
}
SVGObserverUtils
:
:
InvalidateDirectRenderingObservers
(
aFrame
)
;
bool
needsSchedulePaint
=
false
;
if
(
nsLayoutUtils
:
:
IsPopup
(
aFrame
)
)
{
needsSchedulePaint
=
true
;
}
else
{
nsIFrame
*
parent
=
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
aFrame
)
;
while
(
parent
&
&
!
parent
-
>
HasAnyStateBits
(
NS_FRAME_DESCENDANT_NEEDS_PAINT
)
)
{
if
(
aHasDisplayItem
&
&
!
parent
-
>
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
)
{
parent
-
>
AddStateBits
(
NS_FRAME_DESCENDANT_NEEDS_PAINT
)
;
}
SVGObserverUtils
:
:
InvalidateDirectRenderingObservers
(
parent
)
;
if
(
nsLayoutUtils
:
:
IsPopup
(
parent
)
)
{
needsSchedulePaint
=
true
;
break
;
}
parent
=
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
parent
)
;
}
if
(
!
parent
)
{
needsSchedulePaint
=
true
;
}
}
if
(
!
aHasDisplayItem
)
{
return
;
}
if
(
needsSchedulePaint
)
{
nsIFrame
*
displayRoot
=
nsLayoutUtils
:
:
GetDisplayRootFrame
(
aFrame
)
;
SchedulePaintInternal
(
displayRoot
aFrame
)
;
}
if
(
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_HAS_INVALID_RECT
)
)
{
aFrame
-
>
DeleteProperty
(
nsIFrame
:
:
InvalidationRect
(
)
)
;
aFrame
-
>
RemoveStateBits
(
NS_FRAME_HAS_INVALID_RECT
)
;
}
}
void
nsIFrame
:
:
InvalidateFrameSubtree
(
bool
aRebuildDisplayItems
)
{
InvalidateFrame
(
0
aRebuildDisplayItems
)
;
if
(
HasAnyStateBits
(
NS_FRAME_ALL_DESCENDANTS_NEED_PAINT
)
)
{
return
;
}
AddStateBits
(
NS_FRAME_ALL_DESCENDANTS_NEED_PAINT
)
;
AutoTArray
<
nsIFrame
:
:
ChildList
4
>
childListArray
;
GetCrossDocChildLists
(
&
childListArray
)
;
nsIFrame
:
:
ChildListArrayIterator
lists
(
childListArray
)
;
for
(
;
!
lists
.
IsDone
(
)
;
lists
.
Next
(
)
)
{
nsFrameList
:
:
Enumerator
childFrames
(
lists
.
CurrentList
(
)
)
;
for
(
;
!
childFrames
.
AtEnd
(
)
;
childFrames
.
Next
(
)
)
{
childFrames
.
get
(
)
-
>
InvalidateFrameSubtree
(
false
)
;
}
}
}
void
nsIFrame
:
:
ClearInvalidationStateBits
(
)
{
if
(
HasAnyStateBits
(
NS_FRAME_DESCENDANT_NEEDS_PAINT
)
)
{
AutoTArray
<
nsIFrame
:
:
ChildList
4
>
childListArray
;
GetCrossDocChildLists
(
&
childListArray
)
;
nsIFrame
:
:
ChildListArrayIterator
lists
(
childListArray
)
;
for
(
;
!
lists
.
IsDone
(
)
;
lists
.
Next
(
)
)
{
nsFrameList
:
:
Enumerator
childFrames
(
lists
.
CurrentList
(
)
)
;
for
(
;
!
childFrames
.
AtEnd
(
)
;
childFrames
.
Next
(
)
)
{
childFrames
.
get
(
)
-
>
ClearInvalidationStateBits
(
)
;
}
}
}
RemoveStateBits
(
NS_FRAME_NEEDS_PAINT
|
NS_FRAME_DESCENDANT_NEEDS_PAINT
|
NS_FRAME_ALL_DESCENDANTS_NEED_PAINT
)
;
}
void
nsIFrame
:
:
InvalidateFrame
(
uint32_t
aDisplayItemKey
bool
aRebuildDisplayItems
)
{
bool
hasDisplayItem
=
!
aDisplayItemKey
|
|
FrameLayerBuilder
:
:
HasRetainedDataFor
(
this
aDisplayItemKey
)
;
InvalidateFrameInternal
(
this
hasDisplayItem
aRebuildDisplayItems
)
;
}
void
nsIFrame
:
:
InvalidateFrameWithRect
(
const
nsRect
&
aRect
uint32_t
aDisplayItemKey
bool
aRebuildDisplayItems
)
{
if
(
aRect
.
IsEmpty
(
)
)
{
return
;
}
bool
hasDisplayItem
=
!
aDisplayItemKey
|
|
FrameLayerBuilder
:
:
HasRetainedDataFor
(
this
aDisplayItemKey
)
;
bool
alreadyInvalid
=
false
;
if
(
!
HasAnyStateBits
(
NS_FRAME_NEEDS_PAINT
)
)
{
InvalidateFrameInternal
(
this
hasDisplayItem
aRebuildDisplayItems
)
;
}
else
{
alreadyInvalid
=
true
;
}
if
(
!
hasDisplayItem
)
{
return
;
}
nsRect
*
rect
;
if
(
HasAnyStateBits
(
NS_FRAME_HAS_INVALID_RECT
)
)
{
rect
=
GetProperty
(
InvalidationRect
(
)
)
;
MOZ_ASSERT
(
rect
)
;
}
else
{
if
(
alreadyInvalid
)
{
return
;
}
rect
=
new
nsRect
(
)
;
AddProperty
(
InvalidationRect
(
)
rect
)
;
AddStateBits
(
NS_FRAME_HAS_INVALID_RECT
)
;
}
*
rect
=
rect
-
>
Union
(
aRect
)
;
}
uint8_t
nsIFrame
:
:
sLayerIsPrerenderedDataKey
;
static
bool
DoesLayerHaveOutOfDateFrameMetrics
(
Layer
*
aLayer
)
{
for
(
uint32_t
i
=
0
;
i
<
aLayer
-
>
GetScrollMetadataCount
(
)
;
i
+
+
)
{
const
FrameMetrics
&
metrics
=
aLayer
-
>
GetFrameMetrics
(
i
)
;
if
(
!
metrics
.
IsScrollable
(
)
)
{
continue
;
}
nsIScrollableFrame
*
scrollableFrame
=
nsLayoutUtils
:
:
FindScrollableFrameFor
(
metrics
.
GetScrollId
(
)
)
;
if
(
!
scrollableFrame
)
{
return
true
;
}
nsPoint
scrollPosition
=
scrollableFrame
-
>
GetScrollPosition
(
)
;
if
(
metrics
.
GetScrollOffset
(
)
!
=
CSSPoint
:
:
FromAppUnits
(
scrollPosition
)
)
{
return
true
;
}
}
return
false
;
}
static
bool
DoesLayerOrAncestorsHaveOutOfDateFrameMetrics
(
Layer
*
aLayer
)
{
for
(
Layer
*
layer
=
aLayer
;
layer
;
layer
=
layer
-
>
GetParent
(
)
)
{
if
(
DoesLayerHaveOutOfDateFrameMetrics
(
layer
)
)
{
return
true
;
}
}
return
false
;
}
bool
nsIFrame
:
:
TryUpdateTransformOnly
(
Layer
*
*
aLayerResult
)
{
if
(
nsLayoutUtils
:
:
AreRetainedDisplayListsEnabled
(
)
)
{
return
false
;
}
Layer
*
layer
=
FrameLayerBuilder
:
:
GetDedicatedLayer
(
this
DisplayItemType
:
:
TYPE_TRANSFORM
)
;
if
(
!
layer
|
|
!
layer
-
>
HasUserData
(
LayerIsPrerenderedDataKey
(
)
)
)
{
return
false
;
}
if
(
DoesLayerOrAncestorsHaveOutOfDateFrameMetrics
(
layer
)
)
{
return
false
;
}
gfx
:
:
Matrix4x4Flagged
transform3d
;
if
(
!
nsLayoutUtils
:
:
GetLayerTransformForFrame
(
this
&
transform3d
)
)
{
return
false
;
}
gfx
:
:
Matrix
transform
;
gfx
:
:
Matrix
previousTransform
;
static
const
gfx
:
:
Float
kError
=
0
.
0001f
;
if
(
!
transform3d
.
Is2D
(
&
transform
)
|
|
!
layer
-
>
GetBaseTransform
(
)
.
Is2D
(
&
previousTransform
)
|
|
!
gfx
:
:
FuzzyEqual
(
transform
.
_11
previousTransform
.
_11
kError
)
|
|
!
gfx
:
:
FuzzyEqual
(
transform
.
_22
previousTransform
.
_22
kError
)
|
|
!
gfx
:
:
FuzzyEqual
(
transform
.
_21
previousTransform
.
_21
kError
)
|
|
!
gfx
:
:
FuzzyEqual
(
transform
.
_12
previousTransform
.
_12
kError
)
)
{
return
false
;
}
layer
-
>
SetBaseTransformForNextTransaction
(
transform3d
.
GetMatrix
(
)
)
;
*
aLayerResult
=
layer
;
return
true
;
}
bool
nsIFrame
:
:
IsInvalid
(
nsRect
&
aRect
)
{
if
(
!
HasAnyStateBits
(
NS_FRAME_NEEDS_PAINT
)
)
{
return
false
;
}
if
(
HasAnyStateBits
(
NS_FRAME_HAS_INVALID_RECT
)
)
{
nsRect
*
rect
=
GetProperty
(
InvalidationRect
(
)
)
;
NS_ASSERTION
(
rect
"
Must
have
an
invalid
rect
if
NS_FRAME_HAS_INVALID_RECT
is
set
!
"
)
;
aRect
=
*
rect
;
}
else
{
aRect
.
SetEmpty
(
)
;
}
return
true
;
}
void
nsIFrame
:
:
SchedulePaint
(
PaintType
aType
bool
aFrameChanged
)
{
nsIFrame
*
displayRoot
=
nsLayoutUtils
:
:
GetDisplayRootFrame
(
this
)
;
InvalidateRenderingObservers
(
displayRoot
this
aFrameChanged
)
;
SchedulePaintInternal
(
displayRoot
this
aType
)
;
}
void
nsIFrame
:
:
SchedulePaintWithoutInvalidatingObservers
(
PaintType
aType
)
{
nsIFrame
*
displayRoot
=
nsLayoutUtils
:
:
GetDisplayRootFrame
(
this
)
;
SchedulePaintInternal
(
displayRoot
this
aType
)
;
}
Layer
*
nsIFrame
:
:
InvalidateLayer
(
DisplayItemType
aDisplayItemKey
const
nsIntRect
*
aDamageRect
const
nsRect
*
aFrameDamageRect
uint32_t
aFlags
)
{
NS_ASSERTION
(
aDisplayItemKey
>
DisplayItemType
:
:
TYPE_ZERO
"
Need
a
key
"
)
;
Layer
*
layer
=
FrameLayerBuilder
:
:
GetDedicatedLayer
(
this
aDisplayItemKey
)
;
nsIFrame
*
displayRoot
=
nsLayoutUtils
:
:
GetDisplayRootFrame
(
this
)
;
InvalidateRenderingObservers
(
displayRoot
this
)
;
if
(
(
aFlags
&
UPDATE_IS_ASYNC
)
&
&
WebRenderUserData
:
:
SupportsAsyncUpdate
(
this
)
)
{
return
nullptr
;
}
if
(
(
aFlags
&
UPDATE_IS_ASYNC
)
&
&
layer
&
&
layer
-
>
SupportsAsyncUpdate
(
)
)
{
return
layer
;
}
if
(
!
layer
)
{
if
(
aFrameDamageRect
&
&
aFrameDamageRect
-
>
IsEmpty
(
)
)
{
return
nullptr
;
}
DisplayItemType
displayItemKey
=
aDisplayItemKey
;
if
(
aDisplayItemKey
=
=
DisplayItemType
:
:
TYPE_PLUGIN
|
|
aDisplayItemKey
=
=
DisplayItemType
:
:
TYPE_REMOTE
)
{
displayItemKey
=
DisplayItemType
:
:
TYPE_ZERO
;
}
if
(
aFrameDamageRect
)
{
InvalidateFrameWithRect
(
*
aFrameDamageRect
static_cast
<
uint32_t
>
(
displayItemKey
)
)
;
}
else
{
InvalidateFrame
(
static_cast
<
uint32_t
>
(
displayItemKey
)
)
;
}
return
nullptr
;
}
if
(
aDamageRect
&
&
aDamageRect
-
>
IsEmpty
(
)
)
{
return
layer
;
}
if
(
aDamageRect
)
{
layer
-
>
AddInvalidRect
(
*
aDamageRect
)
;
}
else
{
layer
-
>
SetInvalidRectToVisibleRegion
(
)
;
}
SchedulePaintInternal
(
displayRoot
this
PAINT_COMPOSITE_ONLY
)
;
return
layer
;
}
static
nsRect
ComputeEffectsRect
(
nsIFrame
*
aFrame
const
nsRect
&
aOverflowRect
const
nsSize
&
aNewSize
)
{
nsRect
r
=
aOverflowRect
;
if
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_SVG_LAYOUT
)
{
if
(
aFrame
-
>
StyleEffects
(
)
-
>
HasFilters
(
)
)
{
SetOrUpdateRectValuedProperty
(
aFrame
nsIFrame
:
:
PreEffectsBBoxProperty
(
)
r
)
;
r
=
nsSVGUtils
:
:
GetPostFilterVisualOverflowRect
(
aFrame
aOverflowRect
)
;
}
return
r
;
}
r
.
UnionRect
(
r
nsLayoutUtils
:
:
GetBoxShadowRectForFrame
(
aFrame
aNewSize
)
)
;
const
nsStyleBorder
*
styleBorder
=
aFrame
-
>
StyleBorder
(
)
;
nsMargin
outsetMargin
=
styleBorder
-
>
GetImageOutset
(
)
;
if
(
outsetMargin
!
=
nsMargin
(
0
0
0
0
)
)
{
nsRect
outsetRect
(
nsPoint
(
0
0
)
aNewSize
)
;
outsetRect
.
Inflate
(
outsetMargin
)
;
r
.
UnionRect
(
r
outsetRect
)
;
}
if
(
nsSVGIntegrationUtils
:
:
UsingOverflowAffectingEffects
(
aFrame
)
)
{
SetOrUpdateRectValuedProperty
(
aFrame
nsIFrame
:
:
PreEffectsBBoxProperty
(
)
r
)
;
r
=
nsSVGIntegrationUtils
:
:
ComputePostEffectsVisualOverflowRect
(
aFrame
r
)
;
}
return
r
;
}
void
nsIFrame
:
:
MovePositionBy
(
const
nsPoint
&
aTranslation
)
{
nsPoint
position
=
GetNormalPosition
(
)
+
aTranslation
;
const
nsMargin
*
computedOffsets
=
nullptr
;
if
(
IsRelativelyPositioned
(
)
)
{
computedOffsets
=
GetProperty
(
nsIFrame
:
:
ComputedOffsetProperty
(
)
)
;
}
ReflowInput
:
:
ApplyRelativePositioning
(
this
computedOffsets
?
*
computedOffsets
:
nsMargin
(
)
&
position
)
;
SetPosition
(
position
)
;
}
nsRect
nsIFrame
:
:
GetNormalRect
(
)
const
{
nsPoint
*
normalPosition
=
GetProperty
(
NormalPositionProperty
(
)
)
;
if
(
normalPosition
)
{
return
nsRect
(
*
normalPosition
GetSize
(
)
)
;
}
return
GetRect
(
)
;
}
nsPoint
nsIFrame
:
:
GetPositionIgnoringScrolling
(
)
const
{
return
GetParent
(
)
?
GetParent
(
)
-
>
GetPositionOfChildIgnoringScrolling
(
this
)
:
GetPosition
(
)
;
}
nsRect
nsIFrame
:
:
GetOverflowRect
(
nsOverflowType
aType
)
const
{
MOZ_ASSERT
(
aType
=
=
eVisualOverflow
|
|
aType
=
=
eScrollableOverflow
"
unexpected
type
"
)
;
if
(
mOverflow
.
mType
=
=
NS_FRAME_OVERFLOW_LARGE
)
{
return
GetOverflowAreasProperty
(
)
-
>
Overflow
(
aType
)
;
}
if
(
aType
=
=
eVisualOverflow
&
&
mOverflow
.
mType
!
=
NS_FRAME_OVERFLOW_NONE
)
{
return
GetVisualOverflowFromDeltas
(
)
;
}
return
nsRect
(
nsPoint
(
0
0
)
GetSize
(
)
)
;
}
nsOverflowAreas
nsIFrame
:
:
GetOverflowAreas
(
)
const
{
if
(
mOverflow
.
mType
=
=
NS_FRAME_OVERFLOW_LARGE
)
{
return
*
GetOverflowAreasProperty
(
)
;
}
return
nsOverflowAreas
(
GetVisualOverflowFromDeltas
(
)
nsRect
(
nsPoint
(
0
0
)
GetSize
(
)
)
)
;
}
nsOverflowAreas
nsIFrame
:
:
GetOverflowAreasRelativeToSelf
(
)
const
{
if
(
IsTransformed
(
)
)
{
nsOverflowAreas
*
preTransformOverflows
=
GetProperty
(
PreTransformOverflowAreasProperty
(
)
)
;
if
(
preTransformOverflows
)
{
return
nsOverflowAreas
(
preTransformOverflows
-
>
VisualOverflow
(
)
preTransformOverflows
-
>
ScrollableOverflow
(
)
)
;
}
}
return
nsOverflowAreas
(
GetVisualOverflowRect
(
)
GetScrollableOverflowRect
(
)
)
;
}
nsRect
nsIFrame
:
:
GetScrollableOverflowRectRelativeToParent
(
)
const
{
return
GetScrollableOverflowRect
(
)
+
mRect
.
TopLeft
(
)
;
}
nsRect
nsIFrame
:
:
GetVisualOverflowRectRelativeToParent
(
)
const
{
return
GetVisualOverflowRect
(
)
+
mRect
.
TopLeft
(
)
;
}
nsRect
nsIFrame
:
:
GetScrollableOverflowRectRelativeToSelf
(
)
const
{
if
(
IsTransformed
(
)
)
{
nsOverflowAreas
*
preTransformOverflows
=
GetProperty
(
PreTransformOverflowAreasProperty
(
)
)
;
if
(
preTransformOverflows
)
return
preTransformOverflows
-
>
ScrollableOverflow
(
)
;
}
return
GetScrollableOverflowRect
(
)
;
}
nsRect
nsIFrame
:
:
GetVisualOverflowRectRelativeToSelf
(
)
const
{
if
(
IsTransformed
(
)
)
{
nsOverflowAreas
*
preTransformOverflows
=
GetProperty
(
PreTransformOverflowAreasProperty
(
)
)
;
if
(
preTransformOverflows
)
return
preTransformOverflows
-
>
VisualOverflow
(
)
;
}
return
GetVisualOverflowRect
(
)
;
}
nsRect
nsIFrame
:
:
GetPreEffectsVisualOverflowRect
(
)
const
{
nsRect
*
r
=
GetProperty
(
nsIFrame
:
:
PreEffectsBBoxProperty
(
)
)
;
return
r
?
*
r
:
GetVisualOverflowRectRelativeToSelf
(
)
;
}
bool
nsIFrame
:
:
UpdateOverflow
(
)
{
MOZ_ASSERT
(
FrameMaintainsOverflow
(
)
"
Non
-
display
SVG
do
not
maintain
visual
overflow
rects
"
)
;
nsRect
rect
(
nsPoint
(
0
0
)
GetSize
(
)
)
;
nsOverflowAreas
overflowAreas
(
rect
rect
)
;
if
(
!
ComputeCustomOverflow
(
overflowAreas
)
)
{
return
false
;
}
UnionChildOverflow
(
overflowAreas
)
;
if
(
FinishAndStoreOverflow
(
overflowAreas
GetSize
(
)
)
)
{
nsView
*
view
=
GetView
(
)
;
if
(
view
)
{
uint32_t
flags
=
GetXULLayoutFlags
(
)
;
if
(
(
flags
&
NS_FRAME_NO_SIZE_VIEW
)
=
=
0
)
{
nsViewManager
*
vm
=
view
-
>
GetViewManager
(
)
;
vm
-
>
ResizeView
(
view
overflowAreas
.
VisualOverflow
(
)
true
)
;
}
}
return
true
;
}
return
false
;
}
bool
nsFrame
:
:
ComputeCustomOverflow
(
nsOverflowAreas
&
aOverflowAreas
)
{
return
true
;
}
void
nsFrame
:
:
UnionChildOverflow
(
nsOverflowAreas
&
aOverflowAreas
)
{
if
(
!
DoesClipChildren
(
)
&
&
!
(
IsXULCollapsed
(
)
&
&
(
IsXULBoxFrame
(
)
|
|
:
:
IsXULBoxWrapped
(
this
)
)
)
)
{
nsLayoutUtils
:
:
UnionChildOverflow
(
this
aOverflowAreas
)
;
}
}
#
define
MAX_FRAME_DEPTH
(
MAX_REFLOW_DEPTH
+
4
)
bool
nsFrame
:
:
IsFrameTreeTooDeep
(
const
ReflowInput
&
aReflowInput
ReflowOutput
&
aMetrics
nsReflowStatus
&
aStatus
)
{
if
(
aReflowInput
.
mReflowDepth
>
MAX_FRAME_DEPTH
)
{
NS_WARNING
(
"
frame
tree
too
deep
;
setting
zero
size
and
returning
"
)
;
AddStateBits
(
NS_FRAME_TOO_DEEP_IN_FRAME_TREE
)
;
ClearOverflowRects
(
)
;
aMetrics
.
ClearSize
(
)
;
aMetrics
.
SetBlockStartAscent
(
0
)
;
aMetrics
.
mCarriedOutBEndMargin
.
Zero
(
)
;
aMetrics
.
mOverflowAreas
.
Clear
(
)
;
aStatus
.
Reset
(
)
;
if
(
GetNextInFlow
(
)
)
{
aStatus
.
SetIncomplete
(
)
;
}
return
true
;
}
RemoveStateBits
(
NS_FRAME_TOO_DEEP_IN_FRAME_TREE
)
;
return
false
;
}
bool
nsIFrame
:
:
IsBlockWrapper
(
)
const
{
nsAtom
*
pseudoType
=
Style
(
)
-
>
GetPseudo
(
)
;
return
(
pseudoType
=
=
nsCSSAnonBoxes
:
:
mozBlockInsideInlineWrapper
(
)
|
|
pseudoType
=
=
nsCSSAnonBoxes
:
:
buttonContent
(
)
|
|
pseudoType
=
=
nsCSSAnonBoxes
:
:
cellContent
(
)
)
;
}
bool
nsIFrame
:
:
IsBlockFrameOrSubclass
(
)
const
{
const
nsBlockFrame
*
thisAsBlock
=
do_QueryFrame
(
this
)
;
return
!
!
thisAsBlock
;
}
static
nsIFrame
*
GetNearestBlockContainer
(
nsIFrame
*
frame
)
{
while
(
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eLineParticipant
)
|
|
frame
-
>
IsBlockWrapper
(
)
|
|
frame
-
>
IsTableRowFrame
(
)
)
{
frame
=
frame
-
>
GetParent
(
)
;
NS_ASSERTION
(
frame
"
How
come
we
got
to
the
root
frame
without
seeing
a
containing
block
?
"
)
;
}
return
frame
;
}
nsIFrame
*
nsIFrame
:
:
GetContainingBlock
(
uint32_t
aFlags
const
nsStyleDisplay
*
aStyleDisplay
)
const
{
MOZ_ASSERT
(
aStyleDisplay
=
=
StyleDisplay
(
)
)
;
if
(
!
GetParent
(
)
)
{
return
nullptr
;
}
nsIFrame
*
f
;
if
(
IsAbsolutelyPositioned
(
aStyleDisplay
)
&
&
(
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
)
{
f
=
GetParent
(
)
;
}
else
{
f
=
GetNearestBlockContainer
(
GetParent
(
)
)
;
}
if
(
aFlags
&
SKIP_SCROLLED_FRAME
&
&
f
&
&
f
-
>
Style
(
)
-
>
GetPseudo
(
)
=
=
nsCSSAnonBoxes
:
:
scrolledContent
(
)
)
{
f
=
f
-
>
GetParent
(
)
;
}
return
f
;
}
#
ifdef
DEBUG_FRAME_DUMP
int32_t
nsFrame
:
:
ContentIndexInContainer
(
const
nsIFrame
*
aFrame
)
{
int32_t
result
=
-
1
;
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
content
)
{
nsIContent
*
parentContent
=
content
-
>
GetParent
(
)
;
if
(
parentContent
)
{
result
=
parentContent
-
>
ComputeIndexOf
(
content
)
;
}
}
return
result
;
}
void
DebugListFrameTree
(
nsIFrame
*
aFrame
)
{
(
(
nsFrame
*
)
aFrame
)
-
>
List
(
stderr
)
;
}
nsAutoCString
nsIFrame
:
:
ListTag
(
)
const
{
nsAutoString
tmp
;
GetFrameName
(
tmp
)
;
nsAutoCString
tag
;
tag
+
=
NS_ConvertUTF16toUTF8
(
tmp
)
;
tag
+
=
nsPrintfCString
(
"
%
p
"
static_cast
<
const
void
*
>
(
this
)
)
;
return
tag
;
}
void
nsIFrame
:
:
ListGeneric
(
nsACString
&
aTo
const
char
*
aPrefix
uint32_t
aFlags
)
const
{
aTo
+
=
aPrefix
;
aTo
+
=
ListTag
(
)
;
if
(
HasView
(
)
)
{
aTo
+
=
nsPrintfCString
(
"
[
view
=
%
p
]
"
static_cast
<
void
*
>
(
GetView
(
)
)
)
;
}
if
(
GetParent
(
)
)
{
aTo
+
=
nsPrintfCString
(
"
parent
=
%
p
"
static_cast
<
void
*
>
(
GetParent
(
)
)
)
;
}
if
(
GetNextSibling
(
)
)
{
aTo
+
=
nsPrintfCString
(
"
next
=
%
p
"
static_cast
<
void
*
>
(
GetNextSibling
(
)
)
)
;
}
if
(
GetPrevContinuation
(
)
)
{
bool
fluid
=
GetPrevInFlow
(
)
=
=
GetPrevContinuation
(
)
;
aTo
+
=
nsPrintfCString
(
"
prev
-
%
s
=
%
p
"
fluid
?
"
in
-
flow
"
:
"
continuation
"
static_cast
<
void
*
>
(
GetPrevContinuation
(
)
)
)
;
}
if
(
GetNextContinuation
(
)
)
{
bool
fluid
=
GetNextInFlow
(
)
=
=
GetNextContinuation
(
)
;
aTo
+
=
nsPrintfCString
(
"
next
-
%
s
=
%
p
"
fluid
?
"
in
-
flow
"
:
"
continuation
"
static_cast
<
void
*
>
(
GetNextContinuation
(
)
)
)
;
}
void
*
IBsibling
=
GetProperty
(
IBSplitSibling
(
)
)
;
if
(
IBsibling
)
{
aTo
+
=
nsPrintfCString
(
"
IBSplitSibling
=
%
p
"
IBsibling
)
;
}
void
*
IBprevsibling
=
GetProperty
(
IBSplitPrevSibling
(
)
)
;
if
(
IBprevsibling
)
{
aTo
+
=
nsPrintfCString
(
"
IBSplitPrevSibling
=
%
p
"
IBprevsibling
)
;
}
aTo
+
=
nsPrintfCString
(
"
{
%
d
%
d
%
d
%
d
}
"
mRect
.
x
mRect
.
y
mRect
.
width
mRect
.
height
)
;
mozilla
:
:
WritingMode
wm
=
GetWritingMode
(
)
;
if
(
wm
.
IsVertical
(
)
|
|
!
wm
.
IsBidiLTR
(
)
)
{
aTo
+
=
nsPrintfCString
(
"
wm
=
%
s
:
logical
size
=
{
%
d
%
d
}
"
wm
.
DebugString
(
)
ISize
(
)
BSize
(
)
)
;
}
nsIFrame
*
parent
=
GetParent
(
)
;
if
(
parent
)
{
WritingMode
pWM
=
parent
-
>
GetWritingMode
(
)
;
if
(
pWM
.
IsVertical
(
)
|
|
!
pWM
.
IsBidiLTR
(
)
)
{
nsSize
containerSize
=
parent
-
>
mRect
.
Size
(
)
;
LogicalRect
lr
(
pWM
mRect
containerSize
)
;
aTo
+
=
nsPrintfCString
(
"
parent
wm
=
%
s
cs
=
{
%
d
%
d
}
"
"
logicalRect
=
{
%
d
%
d
%
d
%
d
}
"
pWM
.
DebugString
(
)
containerSize
.
width
containerSize
.
height
lr
.
IStart
(
pWM
)
lr
.
BStart
(
pWM
)
lr
.
ISize
(
pWM
)
lr
.
BSize
(
pWM
)
)
;
}
}
nsIFrame
*
f
=
const_cast
<
nsIFrame
*
>
(
this
)
;
if
(
f
-
>
HasOverflowAreas
(
)
)
{
nsRect
vo
=
f
-
>
GetVisualOverflowRect
(
)
;
if
(
!
vo
.
IsEqualEdges
(
mRect
)
)
{
aTo
+
=
nsPrintfCString
(
"
vis
-
overflow
=
%
d
%
d
%
d
%
d
"
vo
.
x
vo
.
y
vo
.
width
vo
.
height
)
;
}
nsRect
so
=
f
-
>
GetScrollableOverflowRect
(
)
;
if
(
!
so
.
IsEqualEdges
(
mRect
)
)
{
aTo
+
=
nsPrintfCString
(
"
scr
-
overflow
=
%
d
%
d
%
d
%
d
"
so
.
x
so
.
y
so
.
width
so
.
height
)
;
}
}
if
(
0
!
=
mState
)
{
aTo
+
=
nsPrintfCString
(
"
[
state
=
%
016llx
]
"
(
unsigned
long
long
)
mState
)
;
}
if
(
HasProperty
(
BidiDataProperty
(
)
)
)
{
FrameBidiData
bidi
=
GetBidiData
(
)
;
aTo
+
=
nsPrintfCString
(
"
bidi
(
%
d
%
d
%
d
)
"
bidi
.
baseLevel
bidi
.
embeddingLevel
bidi
.
precedingControl
)
;
}
if
(
IsTransformed
(
)
)
{
aTo
+
=
nsPrintfCString
(
"
transformed
"
)
;
}
if
(
ChildrenHavePerspective
(
)
)
{
aTo
+
=
nsPrintfCString
(
"
perspective
"
)
;
}
if
(
Extend3DContext
(
)
)
{
aTo
+
=
nsPrintfCString
(
"
extend
-
3d
"
)
;
}
if
(
Combines3DTransformWithAncestors
(
)
)
{
aTo
+
=
nsPrintfCString
(
"
combines
-
3d
-
transform
-
with
-
ancestors
"
)
;
}
if
(
mContent
)
{
aTo
+
=
nsPrintfCString
(
"
[
content
=
%
p
]
"
static_cast
<
void
*
>
(
mContent
)
)
;
}
aTo
+
=
nsPrintfCString
(
"
[
cs
=
%
p
"
static_cast
<
void
*
>
(
mComputedStyle
)
)
;
if
(
mComputedStyle
)
{
nsAtom
*
pseudoTag
=
mComputedStyle
-
>
GetPseudo
(
)
;
if
(
pseudoTag
)
{
nsAutoString
atomString
;
pseudoTag
-
>
ToString
(
atomString
)
;
aTo
+
=
nsPrintfCString
(
"
%
s
"
NS_LossyConvertUTF16toASCII
(
atomString
)
.
get
(
)
)
;
}
}
aTo
+
=
"
]
"
;
}
void
nsIFrame
:
:
List
(
FILE
*
out
const
char
*
aPrefix
uint32_t
aFlags
)
const
{
nsCString
str
;
ListGeneric
(
str
aPrefix
aFlags
)
;
fprintf_stderr
(
out
"
%
s
\
n
"
str
.
get
(
)
)
;
}
nsresult
nsFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
NS_LITERAL_STRING
(
"
Frame
"
)
aResult
)
;
}
nsresult
nsFrame
:
:
MakeFrameName
(
const
nsAString
&
aType
nsAString
&
aResult
)
const
{
aResult
=
aType
;
if
(
mContent
&
&
!
mContent
-
>
IsText
(
)
)
{
nsAutoString
buf
;
mContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
-
>
ToString
(
buf
)
;
if
(
IsSubDocumentFrame
(
)
)
{
nsAutoString
src
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
src
src
)
;
buf
.
AppendLiteral
(
"
src
=
"
)
;
buf
.
Append
(
src
)
;
}
aResult
.
Append
(
'
(
'
)
;
aResult
.
Append
(
buf
)
;
aResult
.
Append
(
'
)
'
)
;
}
aResult
.
Append
(
'
(
'
)
;
aResult
.
AppendInt
(
ContentIndexInContainer
(
this
)
)
;
aResult
.
Append
(
'
)
'
)
;
return
NS_OK
;
}
void
nsIFrame
:
:
DumpFrameTree
(
)
const
{
RootFrameList
(
PresContext
(
)
stderr
)
;
}
void
nsIFrame
:
:
DumpFrameTreeLimited
(
)
const
{
List
(
stderr
)
;
}
void
nsIFrame
:
:
RootFrameList
(
nsPresContext
*
aPresContext
FILE
*
out
const
char
*
aPrefix
)
{
if
(
!
aPresContext
|
|
!
out
)
return
;
nsIPresShell
*
shell
=
aPresContext
-
>
GetPresShell
(
)
;
if
(
shell
)
{
nsIFrame
*
frame
=
shell
-
>
GetRootFrame
(
)
;
if
(
frame
)
{
frame
-
>
List
(
out
aPrefix
)
;
}
}
}
#
endif
bool
nsIFrame
:
:
IsVisibleForPainting
(
)
{
return
StyleVisibility
(
)
-
>
IsVisible
(
)
;
}
bool
nsIFrame
:
:
IsVisibleOrCollapsedForPainting
(
)
{
return
StyleVisibility
(
)
-
>
IsVisibleOrCollapsed
(
)
;
}
bool
nsFrame
:
:
IsEmpty
(
)
{
return
false
;
}
bool
nsIFrame
:
:
CachedIsEmpty
(
)
{
MOZ_ASSERT
(
!
(
GetStateBits
(
)
&
NS_FRAME_IS_DIRTY
)
"
Must
only
be
called
on
reflowed
lines
"
)
;
return
IsEmpty
(
)
;
}
bool
nsFrame
:
:
IsSelfEmpty
(
)
{
return
false
;
}
nsresult
nsFrame
:
:
GetSelectionController
(
nsPresContext
*
aPresContext
nsISelectionController
*
*
aSelCon
)
{
if
(
!
aPresContext
|
|
!
aSelCon
)
return
NS_ERROR_INVALID_ARG
;
nsIFrame
*
frame
=
this
;
while
(
frame
&
&
(
frame
-
>
GetStateBits
(
)
&
NS_FRAME_INDEPENDENT_SELECTION
)
)
{
nsITextControlFrame
*
tcf
=
do_QueryFrame
(
frame
)
;
if
(
tcf
)
{
return
tcf
-
>
GetOwnedSelectionController
(
aSelCon
)
;
}
frame
=
frame
-
>
GetParent
(
)
;
}
return
CallQueryInterface
(
aPresContext
-
>
GetPresShell
(
)
aSelCon
)
;
}
already_AddRefed
<
nsFrameSelection
>
nsIFrame
:
:
GetFrameSelection
(
)
{
RefPtr
<
nsFrameSelection
>
fs
=
const_cast
<
nsFrameSelection
*
>
(
GetConstFrameSelection
(
)
)
;
return
fs
.
forget
(
)
;
}
const
nsFrameSelection
*
nsIFrame
:
:
GetConstFrameSelection
(
)
const
{
nsIFrame
*
frame
=
const_cast
<
nsIFrame
*
>
(
this
)
;
while
(
frame
&
&
(
frame
-
>
GetStateBits
(
)
&
NS_FRAME_INDEPENDENT_SELECTION
)
)
{
nsITextControlFrame
*
tcf
=
do_QueryFrame
(
frame
)
;
if
(
tcf
)
{
return
tcf
-
>
GetOwnedFrameSelection
(
)
;
}
frame
=
frame
-
>
GetParent
(
)
;
}
return
PresShell
(
)
-
>
ConstFrameSelection
(
)
;
}
bool
nsIFrame
:
:
IsFrameSelected
(
)
const
{
NS_ASSERTION
(
!
GetContent
(
)
|
|
GetContent
(
)
-
>
IsSelectionDescendant
(
)
"
use
the
public
IsSelected
(
)
instead
"
)
;
return
nsRange
:
:
IsNodeSelected
(
GetContent
(
)
0
GetContent
(
)
-
>
GetChildCount
(
)
)
;
}
nsresult
nsFrame
:
:
GetPointFromOffset
(
int32_t
inOffset
nsPoint
*
outPoint
)
{
MOZ_ASSERT
(
outPoint
!
=
nullptr
"
Null
parameter
"
)
;
nsRect
contentRect
=
GetContentRectRelativeToSelf
(
)
;
nsPoint
pt
=
contentRect
.
TopLeft
(
)
;
if
(
mContent
)
{
nsIContent
*
newContent
=
mContent
-
>
GetParent
(
)
;
if
(
newContent
)
{
int32_t
newOffset
=
newContent
-
>
ComputeIndexOf
(
mContent
)
;
bool
hasBidiData
;
FrameBidiData
bidiData
=
GetProperty
(
BidiDataProperty
(
)
&
hasBidiData
)
;
bool
isRTL
=
hasBidiData
?
IS_LEVEL_RTL
(
bidiData
.
embeddingLevel
)
:
StyleVisibility
(
)
-
>
mDirection
=
=
NS_STYLE_DIRECTION_RTL
;
if
(
(
!
isRTL
&
&
inOffset
>
newOffset
)
|
|
(
isRTL
&
&
inOffset
<
=
newOffset
)
)
{
pt
=
contentRect
.
TopRight
(
)
;
}
}
}
*
outPoint
=
pt
;
return
NS_OK
;
}
nsresult
nsFrame
:
:
GetCharacterRectsInRange
(
int32_t
aInOffset
int32_t
aLength
nsTArray
<
nsRect
>
&
aOutRect
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
nsFrame
:
:
GetChildFrameContainingOffset
(
int32_t
inContentOffset
bool
inHint
int32_t
*
outFrameContentOffset
nsIFrame
*
*
outChildFrame
)
{
MOZ_ASSERT
(
outChildFrame
&
&
outFrameContentOffset
"
Null
parameter
"
)
;
*
outFrameContentOffset
=
(
int32_t
)
inHint
;
nsRect
rect
=
GetRect
(
)
;
if
(
!
rect
.
width
|
|
!
rect
.
height
)
{
nsIFrame
*
nextFlow
=
GetNextInFlow
(
)
;
if
(
nextFlow
)
return
nextFlow
-
>
GetChildFrameContainingOffset
(
inContentOffset
inHint
outFrameContentOffset
outChildFrame
)
;
}
*
outChildFrame
=
this
;
return
NS_OK
;
}
nsresult
nsFrame
:
:
GetNextPrevLineFromeBlockFrame
(
nsPresContext
*
aPresContext
nsPeekOffsetStruct
*
aPos
nsIFrame
*
aBlockFrame
int32_t
aLineStart
int8_t
aOutSideLimit
)
{
if
(
!
aBlockFrame
|
|
!
aPos
)
return
NS_ERROR_NULL_POINTER
;
aPos
-
>
mResultFrame
=
nullptr
;
aPos
-
>
mResultContent
=
nullptr
;
aPos
-
>
mAttach
=
aPos
-
>
mDirection
=
=
eDirNext
?
CARET_ASSOCIATE_AFTER
:
CARET_ASSOCIATE_BEFORE
;
nsAutoLineIterator
it
=
aBlockFrame
-
>
GetLineIterator
(
)
;
if
(
!
it
)
return
NS_ERROR_FAILURE
;
int32_t
searchingLine
=
aLineStart
;
int32_t
countLines
=
it
-
>
GetNumLines
(
)
;
if
(
aOutSideLimit
>
0
)
searchingLine
=
countLines
;
else
if
(
aOutSideLimit
<
0
)
searchingLine
=
-
1
;
else
if
(
(
aPos
-
>
mDirection
=
=
eDirPrevious
&
&
searchingLine
=
=
0
)
|
|
(
aPos
-
>
mDirection
=
=
eDirNext
&
&
searchingLine
>
=
(
countLines
-
1
)
)
)
{
return
NS_ERROR_FAILURE
;
}
int32_t
lineFrameCount
;
nsIFrame
*
resultFrame
=
nullptr
;
nsIFrame
*
farStoppingFrame
=
nullptr
;
nsIFrame
*
nearStoppingFrame
=
nullptr
;
nsIFrame
*
firstFrame
;
nsIFrame
*
lastFrame
;
nsRect
rect
;
bool
isBeforeFirstFrame
isAfterLastFrame
;
bool
found
=
false
;
nsresult
result
=
NS_OK
;
while
(
!
found
)
{
if
(
aPos
-
>
mDirection
=
=
eDirPrevious
)
searchingLine
-
-
;
else
searchingLine
+
+
;
if
(
(
aPos
-
>
mDirection
=
=
eDirPrevious
&
&
searchingLine
<
0
)
|
|
(
aPos
-
>
mDirection
=
=
eDirNext
&
&
searchingLine
>
=
countLines
)
)
{
return
NS_ERROR_FAILURE
;
}
result
=
it
-
>
GetLine
(
searchingLine
&
firstFrame
&
lineFrameCount
rect
)
;
if
(
!
lineFrameCount
)
continue
;
if
(
NS_SUCCEEDED
(
result
)
)
{
lastFrame
=
firstFrame
;
for
(
;
lineFrameCount
>
1
;
lineFrameCount
-
-
)
{
result
=
it
-
>
GetNextSiblingOnLine
(
lastFrame
searchingLine
)
;
if
(
NS_FAILED
(
result
)
|
|
!
lastFrame
)
{
NS_ERROR
(
"
GetLine
promised
more
frames
than
could
be
found
"
)
;
return
NS_ERROR_FAILURE
;
}
}
GetLastLeaf
(
aPresContext
&
lastFrame
)
;
if
(
aPos
-
>
mDirection
=
=
eDirNext
)
{
nearStoppingFrame
=
firstFrame
;
farStoppingFrame
=
lastFrame
;
}
else
{
nearStoppingFrame
=
lastFrame
;
farStoppingFrame
=
firstFrame
;
}
nsPoint
offset
;
nsView
*
view
;
aBlockFrame
-
>
GetOffsetFromView
(
offset
&
view
)
;
nsPoint
newDesiredPos
=
aPos
-
>
mDesiredPos
-
offset
;
result
=
it
-
>
FindFrameAt
(
searchingLine
newDesiredPos
&
resultFrame
&
isBeforeFirstFrame
&
isAfterLastFrame
)
;
if
(
NS_FAILED
(
result
)
)
continue
;
}
if
(
NS_SUCCEEDED
(
result
)
&
&
resultFrame
)
{
nsAutoLineIterator
newIt
=
resultFrame
-
>
GetLineIterator
(
)
;
if
(
newIt
)
{
aPos
-
>
mResultFrame
=
resultFrame
;
return
NS_OK
;
}
result
=
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsIFrameEnumerator
>
frameTraversal
;
result
=
NS_NewFrameTraversal
(
getter_AddRefs
(
frameTraversal
)
aPresContext
resultFrame
ePostOrder
false
aPos
-
>
mScrollViewStop
false
false
)
;
if
(
NS_FAILED
(
result
)
)
return
result
;
auto
FoundValidFrame
=
[
aPos
]
(
const
ContentOffsets
&
aOffsets
const
nsIFrame
*
aFrame
)
{
if
(
!
aOffsets
.
content
)
{
return
false
;
}
if
(
!
aFrame
-
>
IsSelectable
(
nullptr
)
)
{
return
false
;
}
if
(
aPos
-
>
mForceEditableRegion
&
&
!
aOffsets
.
content
-
>
IsEditable
(
)
)
{
return
false
;
}
return
true
;
}
;
nsIFrame
*
storeOldResultFrame
=
resultFrame
;
while
(
!
found
)
{
nsPoint
point
;
nsRect
tempRect
=
resultFrame
-
>
GetRect
(
)
;
nsPoint
offset
;
nsView
*
view
;
resultFrame
-
>
GetOffsetFromView
(
offset
&
view
)
;
if
(
!
view
)
{
return
NS_ERROR_FAILURE
;
}
if
(
resultFrame
-
>
GetWritingMode
(
)
.
IsVertical
(
)
)
{
point
.
y
=
aPos
-
>
mDesiredPos
.
y
;
point
.
x
=
tempRect
.
width
+
offset
.
x
;
}
else
{
point
.
y
=
tempRect
.
height
+
offset
.
y
;
point
.
x
=
aPos
-
>
mDesiredPos
.
x
;
}
nsIPresShell
*
shell
=
aPresContext
-
>
GetPresShell
(
)
;
if
(
!
shell
)
return
NS_ERROR_FAILURE
;
int16_t
isEditor
=
shell
-
>
GetSelectionFlags
(
)
;
isEditor
=
isEditor
=
=
nsISelectionDisplay
:
:
DISPLAY_ALL
;
if
(
isEditor
)
{
if
(
resultFrame
-
>
IsTableWrapperFrame
(
)
)
{
if
(
(
(
point
.
x
-
offset
.
x
+
tempRect
.
x
)
<
0
)
|
|
(
(
point
.
x
-
offset
.
x
+
tempRect
.
x
)
>
tempRect
.
width
)
)
{
nsIContent
*
content
=
resultFrame
-
>
GetContent
(
)
;
if
(
content
)
{
nsIContent
*
parent
=
content
-
>
GetParent
(
)
;
if
(
parent
)
{
aPos
-
>
mResultContent
=
parent
;
aPos
-
>
mContentOffset
=
parent
-
>
ComputeIndexOf
(
content
)
;
aPos
-
>
mAttach
=
CARET_ASSOCIATE_BEFORE
;
if
(
(
point
.
x
-
offset
.
x
+
tempRect
.
x
)
>
tempRect
.
width
)
{
aPos
-
>
mContentOffset
+
+
;
aPos
-
>
mAttach
=
CARET_ASSOCIATE_AFTER
;
}
aPos
-
>
mResultFrame
=
resultFrame
-
>
GetParent
(
)
;
return
NS_POSITION_BEFORE_TABLE
;
}
}
}
}
}
if
(
!
resultFrame
-
>
HasView
(
)
)
{
nsView
*
view
;
nsPoint
offset
;
resultFrame
-
>
GetOffsetFromView
(
offset
&
view
)
;
ContentOffsets
offsets
=
resultFrame
-
>
GetContentOffsetsFromPoint
(
point
-
offset
)
;
aPos
-
>
mResultContent
=
offsets
.
content
;
aPos
-
>
mContentOffset
=
offsets
.
offset
;
aPos
-
>
mAttach
=
offsets
.
associate
;
if
(
FoundValidFrame
(
offsets
resultFrame
)
)
{
found
=
true
;
break
;
}
}
if
(
aPos
-
>
mDirection
=
=
eDirPrevious
&
&
(
resultFrame
=
=
farStoppingFrame
)
)
break
;
if
(
aPos
-
>
mDirection
=
=
eDirNext
&
&
(
resultFrame
=
=
nearStoppingFrame
)
)
break
;
frameTraversal
-
>
Prev
(
)
;
resultFrame
=
frameTraversal
-
>
CurrentItem
(
)
;
if
(
!
resultFrame
)
return
NS_ERROR_FAILURE
;
}
if
(
!
found
)
{
resultFrame
=
storeOldResultFrame
;
result
=
NS_NewFrameTraversal
(
getter_AddRefs
(
frameTraversal
)
aPresContext
resultFrame
eLeaf
false
aPos
-
>
mScrollViewStop
false
false
)
;
}
while
(
!
found
)
{
nsPoint
point
=
aPos
-
>
mDesiredPos
;
nsView
*
view
;
nsPoint
offset
;
resultFrame
-
>
GetOffsetFromView
(
offset
&
view
)
;
ContentOffsets
offsets
=
resultFrame
-
>
GetContentOffsetsFromPoint
(
point
-
offset
)
;
aPos
-
>
mResultContent
=
offsets
.
content
;
aPos
-
>
mContentOffset
=
offsets
.
offset
;
aPos
-
>
mAttach
=
offsets
.
associate
;
if
(
FoundValidFrame
(
offsets
resultFrame
)
)
{
found
=
true
;
if
(
resultFrame
=
=
farStoppingFrame
)
aPos
-
>
mAttach
=
CARET_ASSOCIATE_BEFORE
;
else
aPos
-
>
mAttach
=
CARET_ASSOCIATE_AFTER
;
break
;
}
if
(
aPos
-
>
mDirection
=
=
eDirPrevious
&
&
(
resultFrame
=
=
nearStoppingFrame
)
)
break
;
if
(
aPos
-
>
mDirection
=
=
eDirNext
&
&
(
resultFrame
=
=
farStoppingFrame
)
)
break
;
frameTraversal
-
>
Next
(
)
;
nsIFrame
*
tempFrame
=
frameTraversal
-
>
CurrentItem
(
)
;
if
(
!
tempFrame
)
break
;
resultFrame
=
tempFrame
;
}
aPos
-
>
mResultFrame
=
resultFrame
;
}
else
{
aPos
-
>
mAmount
=
eSelectLine
;
aPos
-
>
mStartOffset
=
0
;
aPos
-
>
mAttach
=
aPos
-
>
mDirection
=
=
eDirNext
?
CARET_ASSOCIATE_BEFORE
:
CARET_ASSOCIATE_AFTER
;
if
(
aPos
-
>
mDirection
=
=
eDirPrevious
)
aPos
-
>
mStartOffset
=
-
1
;
return
aBlockFrame
-
>
PeekOffset
(
aPos
)
;
}
}
return
NS_OK
;
}
nsIFrame
:
:
CaretPosition
nsIFrame
:
:
GetExtremeCaretPosition
(
bool
aStart
)
{
CaretPosition
result
;
FrameTarget
targetFrame
=
DrillDownToSelectionFrame
(
this
!
aStart
0
)
;
FrameContentRange
range
=
GetRangeForFrame
(
targetFrame
.
frame
)
;
result
.
mResultContent
=
range
.
content
;
result
.
mContentOffset
=
aStart
?
range
.
start
:
range
.
end
;
return
result
;
}
static
nsContentAndOffset
FindBlockFrameOrBR
(
nsIFrame
*
aFrame
nsDirection
aDirection
)
{
nsContentAndOffset
result
;
result
.
mContent
=
nullptr
;
result
.
mOffset
=
0
;
if
(
aFrame
-
>
IsGeneratedContentFrame
(
)
)
return
result
;
nsIFormControlFrame
*
fcf
=
do_QueryFrame
(
aFrame
)
;
if
(
fcf
)
return
result
;
if
(
(
aFrame
-
>
IsBlockFrameOrSubclass
(
)
&
&
!
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_PART_OF_IBSPLIT
)
)
|
|
aFrame
-
>
IsBrFrame
(
)
)
{
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
result
.
mContent
=
content
-
>
GetParent
(
)
;
NS_ASSERTION
(
result
.
mContent
"
Unexpected
orphan
content
"
)
;
if
(
result
.
mContent
)
result
.
mOffset
=
result
.
mContent
-
>
ComputeIndexOf
(
content
)
+
(
aDirection
=
=
eDirPrevious
?
1
:
0
)
;
return
result
;
}
if
(
aFrame
-
>
HasSignificantTerminalNewline
(
)
)
{
int32_t
startOffset
endOffset
;
aFrame
-
>
GetOffsets
(
startOffset
endOffset
)
;
result
.
mContent
=
aFrame
-
>
GetContent
(
)
;
result
.
mOffset
=
endOffset
-
(
aDirection
=
=
eDirPrevious
?
0
:
1
)
;
return
result
;
}
if
(
aDirection
=
=
eDirPrevious
)
{
nsIFrame
*
child
=
aFrame
-
>
GetChildList
(
nsIFrame
:
:
kPrincipalList
)
.
LastChild
(
)
;
while
(
child
&
&
!
result
.
mContent
)
{
result
=
FindBlockFrameOrBR
(
child
aDirection
)
;
child
=
child
-
>
GetPrevSibling
(
)
;
}
}
else
{
nsIFrame
*
child
=
aFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
while
(
child
&
&
!
result
.
mContent
)
{
result
=
FindBlockFrameOrBR
(
child
aDirection
)
;
child
=
child
-
>
GetNextSibling
(
)
;
}
}
return
result
;
}
nsresult
nsIFrame
:
:
PeekOffsetParagraph
(
nsPeekOffsetStruct
*
aPos
)
{
nsIFrame
*
frame
=
this
;
nsContentAndOffset
blockFrameOrBR
;
blockFrameOrBR
.
mContent
=
nullptr
;
bool
reachedBlockAncestor
=
frame
-
>
IsBlockFrameOrSubclass
(
)
;
if
(
aPos
-
>
mDirection
=
=
eDirPrevious
)
{
while
(
!
reachedBlockAncestor
)
{
nsIFrame
*
parent
=
frame
-
>
GetParent
(
)
;
if
(
!
frame
-
>
mContent
|
|
!
frame
-
>
mContent
-
>
GetParent
(
)
)
{
reachedBlockAncestor
=
true
;
break
;
}
nsIFrame
*
sibling
=
frame
-
>
GetPrevSibling
(
)
;
while
(
sibling
&
&
!
blockFrameOrBR
.
mContent
)
{
blockFrameOrBR
=
FindBlockFrameOrBR
(
sibling
eDirPrevious
)
;
sibling
=
sibling
-
>
GetPrevSibling
(
)
;
}
if
(
blockFrameOrBR
.
mContent
)
{
aPos
-
>
mResultContent
=
blockFrameOrBR
.
mContent
;
aPos
-
>
mContentOffset
=
blockFrameOrBR
.
mOffset
;
break
;
}
frame
=
parent
;
reachedBlockAncestor
=
(
frame
&
&
frame
-
>
IsBlockFrameOrSubclass
(
)
)
;
}
if
(
reachedBlockAncestor
)
{
aPos
-
>
mResultContent
=
frame
-
>
GetContent
(
)
;
aPos
-
>
mContentOffset
=
0
;
}
}
else
{
while
(
!
reachedBlockAncestor
)
{
nsIFrame
*
parent
=
frame
-
>
GetParent
(
)
;
if
(
!
frame
-
>
mContent
|
|
!
frame
-
>
mContent
-
>
GetParent
(
)
)
{
reachedBlockAncestor
=
true
;
break
;
}
nsIFrame
*
sibling
=
frame
;
while
(
sibling
&
&
!
blockFrameOrBR
.
mContent
)
{
blockFrameOrBR
=
FindBlockFrameOrBR
(
sibling
eDirNext
)
;
sibling
=
sibling
-
>
GetNextSibling
(
)
;
}
if
(
blockFrameOrBR
.
mContent
)
{
aPos
-
>
mResultContent
=
blockFrameOrBR
.
mContent
;
aPos
-
>
mContentOffset
=
blockFrameOrBR
.
mOffset
;
break
;
}
frame
=
parent
;
reachedBlockAncestor
=
(
frame
&
&
frame
-
>
IsBlockFrameOrSubclass
(
)
)
;
}
if
(
reachedBlockAncestor
)
{
aPos
-
>
mResultContent
=
frame
-
>
GetContent
(
)
;
if
(
aPos
-
>
mResultContent
)
aPos
-
>
mContentOffset
=
aPos
-
>
mResultContent
-
>
GetChildCount
(
)
;
}
}
return
NS_OK
;
}
static
bool
IsMovingInFrameDirection
(
nsIFrame
*
frame
nsDirection
aDirection
bool
aVisual
)
{
bool
isReverseDirection
=
aVisual
&
&
IsReversedDirectionFrame
(
frame
)
;
return
aDirection
=
=
(
isReverseDirection
?
eDirPrevious
:
eDirNext
)
;
}
nsresult
nsIFrame
:
:
PeekOffset
(
nsPeekOffsetStruct
*
aPos
)
{
if
(
!
aPos
)
return
NS_ERROR_NULL_POINTER
;
nsresult
result
=
NS_ERROR_FAILURE
;
if
(
mState
&
NS_FRAME_IS_DIRTY
)
return
NS_ERROR_UNEXPECTED
;
FrameContentRange
range
=
GetRangeForFrame
(
this
)
;
int32_t
offset
=
aPos
-
>
mStartOffset
-
range
.
start
;
nsIFrame
*
current
=
this
;
switch
(
aPos
-
>
mAmount
)
{
case
eSelectCharacter
:
case
eSelectCluster
:
{
bool
eatingNonRenderableWS
=
false
;
nsIFrame
:
:
FrameSearchResult
peekSearchState
=
CONTINUE
;
bool
jumpedLine
=
false
;
bool
movedOverNonSelectableText
=
false
;
while
(
peekSearchState
!
=
FOUND
)
{
bool
movingInFrameDirection
=
IsMovingInFrameDirection
(
current
aPos
-
>
mDirection
aPos
-
>
mVisual
)
;
if
(
eatingNonRenderableWS
)
{
peekSearchState
=
current
-
>
PeekOffsetNoAmount
(
movingInFrameDirection
&
offset
)
;
}
else
{
PeekOffsetCharacterOptions
options
;
options
.
mRespectClusters
=
aPos
-
>
mAmount
=
=
eSelectCluster
;
peekSearchState
=
current
-
>
PeekOffsetCharacter
(
movingInFrameDirection
&
offset
options
)
;
}
movedOverNonSelectableText
|
=
(
peekSearchState
=
=
CONTINUE_UNSELECTABLE
)
;
if
(
peekSearchState
!
=
FOUND
)
{
bool
movedOverNonSelectable
=
false
;
result
=
current
-
>
GetFrameFromDirection
(
aPos
-
>
mDirection
aPos
-
>
mVisual
aPos
-
>
mJumpLines
aPos
-
>
mScrollViewStop
aPos
-
>
mForceEditableRegion
&
current
&
offset
&
jumpedLine
&
movedOverNonSelectable
)
;
if
(
NS_FAILED
(
result
)
)
return
result
;
if
(
jumpedLine
)
eatingNonRenderableWS
=
true
;
movedOverNonSelectableText
|
=
movedOverNonSelectable
;
}
if
(
peekSearchState
=
=
FOUND
&
&
movedOverNonSelectableText
&
&
!
aPos
-
>
mExtend
)
{
int32_t
start
end
;
current
-
>
GetOffsets
(
start
end
)
;
offset
=
aPos
-
>
mDirection
=
=
eDirNext
?
0
:
end
-
start
;
}
}
range
=
GetRangeForFrame
(
current
)
;
aPos
-
>
mResultFrame
=
current
;
aPos
-
>
mResultContent
=
range
.
content
;
aPos
-
>
mContentOffset
=
offset
<
0
?
range
.
end
:
range
.
start
+
offset
;
if
(
offset
<
0
&
&
jumpedLine
&
&
aPos
-
>
mDirection
=
=
eDirPrevious
&
&
current
-
>
HasSignificantTerminalNewline
(
)
)
{
-
-
aPos
-
>
mContentOffset
;
}
break
;
}
case
eSelectWordNoSpace
:
if
(
aPos
-
>
mDirection
=
=
eDirPrevious
)
{
aPos
-
>
mWordMovementType
=
eStartWord
;
}
else
{
aPos
-
>
mWordMovementType
=
eEndWord
;
}
MOZ_FALLTHROUGH
;
case
eSelectWord
:
{
bool
wordSelectEatSpace
;
if
(
aPos
-
>
mWordMovementType
!
=
eDefaultBehavior
)
{
wordSelectEatSpace
=
(
(
aPos
-
>
mWordMovementType
=
=
eEndWord
)
=
=
(
aPos
-
>
mDirection
=
=
eDirPrevious
)
)
;
}
else
{
wordSelectEatSpace
=
aPos
-
>
mDirection
=
=
eDirNext
&
&
Preferences
:
:
GetBool
(
"
layout
.
word_select
.
eat_space_to_next_word
"
)
;
}
PeekWordState
state
;
int32_t
offsetAdjustment
=
0
;
bool
done
=
false
;
while
(
!
done
)
{
bool
movingInFrameDirection
=
IsMovingInFrameDirection
(
current
aPos
-
>
mDirection
aPos
-
>
mVisual
)
;
done
=
current
-
>
PeekOffsetWord
(
movingInFrameDirection
wordSelectEatSpace
aPos
-
>
mIsKeyboardSelect
&
offset
&
state
)
=
=
FOUND
;
if
(
!
done
)
{
nsIFrame
*
nextFrame
;
int32_t
nextFrameOffset
;
bool
jumpedLine
movedOverNonSelectableText
;
result
=
current
-
>
GetFrameFromDirection
(
aPos
-
>
mDirection
aPos
-
>
mVisual
aPos
-
>
mJumpLines
aPos
-
>
mScrollViewStop
aPos
-
>
mForceEditableRegion
&
nextFrame
&
nextFrameOffset
&
jumpedLine
&
movedOverNonSelectableText
)
;
if
(
NS_FAILED
(
result
)
|
|
(
jumpedLine
&
&
!
wordSelectEatSpace
&
&
state
.
mSawBeforeType
)
)
{
done
=
true
;
if
(
jumpedLine
&
&
wordSelectEatSpace
&
&
current
-
>
HasSignificantTerminalNewline
(
)
)
{
offsetAdjustment
=
-
1
;
}
}
else
{
if
(
jumpedLine
)
{
state
.
mContext
.
Truncate
(
)
;
}
current
=
nextFrame
;
offset
=
nextFrameOffset
;
if
(
wordSelectEatSpace
&
&
jumpedLine
)
state
.
SetSawBeforeType
(
)
;
}
}
}
range
=
GetRangeForFrame
(
current
)
;
aPos
-
>
mResultFrame
=
current
;
aPos
-
>
mResultContent
=
range
.
content
;
aPos
-
>
mContentOffset
=
(
offset
<
0
?
range
.
end
:
range
.
start
+
offset
)
+
offsetAdjustment
;
break
;
}
case
eSelectLine
:
{
nsAutoLineIterator
iter
;
nsIFrame
*
blockFrame
=
this
;
while
(
NS_FAILED
(
result
)
)
{
int32_t
thisLine
=
nsFrame
:
:
GetLineNumber
(
blockFrame
aPos
-
>
mScrollViewStop
&
blockFrame
)
;
if
(
thisLine
<
0
)
return
NS_ERROR_FAILURE
;
iter
=
blockFrame
-
>
GetLineIterator
(
)
;
NS_ASSERTION
(
iter
"
GetLineNumber
(
)
succeeded
but
no
block
frame
?
"
)
;
result
=
NS_OK
;
int
edgeCase
=
0
;
bool
doneLooping
=
false
;
nsIFrame
*
lastFrame
=
this
;
do
{
result
=
nsFrame
:
:
GetNextPrevLineFromeBlockFrame
(
PresContext
(
)
aPos
blockFrame
thisLine
edgeCase
)
;
if
(
NS_SUCCEEDED
(
result
)
&
&
(
!
aPos
-
>
mResultFrame
|
|
aPos
-
>
mResultFrame
=
=
lastFrame
)
)
{
aPos
-
>
mResultFrame
=
nullptr
;
if
(
aPos
-
>
mDirection
=
=
eDirPrevious
)
thisLine
-
-
;
else
thisLine
+
+
;
}
else
doneLooping
=
true
;
lastFrame
=
aPos
-
>
mResultFrame
;
if
(
NS_SUCCEEDED
(
result
)
&
&
aPos
-
>
mResultFrame
&
&
blockFrame
!
=
aPos
-
>
mResultFrame
)
{
bool
searchTableBool
=
false
;
if
(
aPos
-
>
mResultFrame
-
>
IsTableWrapperFrame
(
)
|
|
aPos
-
>
mResultFrame
-
>
IsTableCellFrame
(
)
)
{
nsIFrame
*
frame
=
aPos
-
>
mResultFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
while
(
frame
)
{
iter
=
frame
-
>
GetLineIterator
(
)
;
if
(
iter
)
{
aPos
-
>
mResultFrame
=
frame
;
searchTableBool
=
true
;
result
=
NS_OK
;
break
;
}
result
=
NS_ERROR_FAILURE
;
frame
=
frame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
}
}
if
(
!
searchTableBool
)
{
iter
=
aPos
-
>
mResultFrame
-
>
GetLineIterator
(
)
;
result
=
iter
?
NS_OK
:
NS_ERROR_FAILURE
;
}
if
(
NS_SUCCEEDED
(
result
)
&
&
iter
)
{
doneLooping
=
false
;
if
(
aPos
-
>
mDirection
=
=
eDirPrevious
)
edgeCase
=
1
;
else
edgeCase
=
-
1
;
thisLine
=
0
;
blockFrame
=
aPos
-
>
mResultFrame
;
}
else
{
result
=
NS_OK
;
break
;
}
}
}
while
(
!
doneLooping
)
;
}
return
result
;
}
case
eSelectParagraph
:
return
PeekOffsetParagraph
(
aPos
)
;
case
eSelectBeginLine
:
case
eSelectEndLine
:
{
nsIFrame
*
blockFrame
=
AdjustFrameForSelectionStyles
(
this
)
;
int32_t
thisLine
=
nsFrame
:
:
GetLineNumber
(
blockFrame
aPos
-
>
mScrollViewStop
&
blockFrame
)
;
if
(
thisLine
<
0
)
return
NS_ERROR_FAILURE
;
nsAutoLineIterator
it
=
blockFrame
-
>
GetLineIterator
(
)
;
NS_ASSERTION
(
it
"
GetLineNumber
(
)
succeeded
but
no
block
frame
?
"
)
;
int32_t
lineFrameCount
;
nsIFrame
*
firstFrame
;
nsRect
usedRect
;
nsIFrame
*
baseFrame
=
nullptr
;
bool
endOfLine
=
(
eSelectEndLine
=
=
aPos
-
>
mAmount
)
;
if
(
aPos
-
>
mVisual
&
&
PresContext
(
)
-
>
BidiEnabled
(
)
)
{
bool
lineIsRTL
=
it
-
>
GetDirection
(
)
;
bool
isReordered
;
nsIFrame
*
lastFrame
;
result
=
it
-
>
CheckLineOrder
(
thisLine
&
isReordered
&
firstFrame
&
lastFrame
)
;
baseFrame
=
endOfLine
?
lastFrame
:
firstFrame
;
if
(
baseFrame
)
{
bool
frameIsRTL
=
(
nsBidiPresUtils
:
:
FrameDirection
(
baseFrame
)
=
=
NSBIDI_RTL
)
;
if
(
frameIsRTL
!
=
lineIsRTL
)
{
endOfLine
=
!
endOfLine
;
}
}
}
else
{
it
-
>
GetLine
(
thisLine
&
firstFrame
&
lineFrameCount
usedRect
)
;
nsIFrame
*
frame
=
firstFrame
;
bool
lastFrameWasEditable
=
false
;
for
(
int32_t
count
=
lineFrameCount
;
count
;
-
-
count
frame
=
frame
-
>
GetNextSibling
(
)
)
{
if
(
frame
-
>
IsGeneratedContentFrame
(
)
)
{
continue
;
}
if
(
endOfLine
&
&
lineFrameCount
>
1
&
&
frame
-
>
IsBrFrame
(
)
&
&
lastFrameWasEditable
=
=
frame
-
>
GetContent
(
)
-
>
IsEditable
(
)
)
{
continue
;
}
lastFrameWasEditable
=
frame
-
>
GetContent
(
)
&
&
frame
-
>
GetContent
(
)
-
>
IsEditable
(
)
;
baseFrame
=
frame
;
if
(
!
endOfLine
)
{
break
;
}
}
}
if
(
!
baseFrame
)
return
NS_ERROR_FAILURE
;
FrameTarget
targetFrame
=
DrillDownToSelectionFrame
(
baseFrame
endOfLine
0
)
;
FrameContentRange
range
=
GetRangeForFrame
(
targetFrame
.
frame
)
;
aPos
-
>
mResultContent
=
range
.
content
;
aPos
-
>
mContentOffset
=
endOfLine
?
range
.
end
:
range
.
start
;
if
(
endOfLine
&
&
targetFrame
.
frame
-
>
HasSignificantTerminalNewline
(
)
)
{
-
-
aPos
-
>
mContentOffset
;
}
aPos
-
>
mResultFrame
=
targetFrame
.
frame
;
aPos
-
>
mAttach
=
aPos
-
>
mContentOffset
=
=
range
.
start
?
CARET_ASSOCIATE_AFTER
:
CARET_ASSOCIATE_BEFORE
;
if
(
!
range
.
content
)
return
NS_ERROR_FAILURE
;
return
NS_OK
;
}
default
:
{
NS_ASSERTION
(
false
"
Invalid
amount
"
)
;
return
NS_ERROR_FAILURE
;
}
}
return
NS_OK
;
}
nsIFrame
:
:
FrameSearchResult
nsFrame
:
:
PeekOffsetNoAmount
(
bool
aForward
int32_t
*
aOffset
)
{
NS_ASSERTION
(
aOffset
&
&
*
aOffset
<
=
1
"
aOffset
out
of
range
"
)
;
return
FOUND
;
}
nsIFrame
:
:
FrameSearchResult
nsFrame
:
:
PeekOffsetCharacter
(
bool
aForward
int32_t
*
aOffset
PeekOffsetCharacterOptions
aOptions
)
{
NS_ASSERTION
(
aOffset
&
&
*
aOffset
<
=
1
"
aOffset
out
of
range
"
)
;
int32_t
startOffset
=
*
aOffset
;
if
(
startOffset
<
0
)
startOffset
=
1
;
if
(
aForward
=
=
(
startOffset
=
=
0
)
)
{
*
aOffset
=
1
-
startOffset
;
return
FOUND
;
}
return
CONTINUE
;
}
nsIFrame
:
:
FrameSearchResult
nsFrame
:
:
PeekOffsetWord
(
bool
aForward
bool
aWordSelectEatSpace
bool
aIsKeyboardSelect
int32_t
*
aOffset
PeekWordState
*
aState
)
{
NS_ASSERTION
(
aOffset
&
&
*
aOffset
<
=
1
"
aOffset
out
of
range
"
)
;
int32_t
startOffset
=
*
aOffset
;
aState
-
>
mContext
.
Truncate
(
)
;
if
(
startOffset
<
0
)
startOffset
=
1
;
if
(
aForward
=
=
(
startOffset
=
=
0
)
)
{
if
(
!
aState
-
>
mAtStart
)
{
if
(
aState
-
>
mLastCharWasPunctuation
)
{
if
(
BreakWordBetweenPunctuation
(
aState
aForward
false
false
aIsKeyboardSelect
)
)
return
FOUND
;
}
else
{
if
(
aWordSelectEatSpace
&
&
aState
-
>
mSawBeforeType
)
return
FOUND
;
}
}
*
aOffset
=
1
-
startOffset
;
aState
-
>
Update
(
false
false
)
;
if
(
!
aWordSelectEatSpace
)
aState
-
>
SetSawBeforeType
(
)
;
}
return
CONTINUE
;
}
bool
nsFrame
:
:
BreakWordBetweenPunctuation
(
const
PeekWordState
*
aState
bool
aForward
bool
aPunctAfter
bool
aWhitespaceAfter
bool
aIsKeyboardSelect
)
{
NS_ASSERTION
(
aPunctAfter
!
=
aState
-
>
mLastCharWasPunctuation
"
Call
this
only
at
punctuation
boundaries
"
)
;
if
(
aState
-
>
mLastCharWasWhitespace
)
{
return
true
;
}
if
(
!
Preferences
:
:
GetBool
(
"
layout
.
word_select
.
stop_at_punctuation
"
)
)
{
return
aWhitespaceAfter
;
}
if
(
!
aIsKeyboardSelect
)
{
return
true
;
}
bool
afterPunct
=
aForward
?
aState
-
>
mLastCharWasPunctuation
:
aPunctAfter
;
if
(
!
afterPunct
)
{
return
false
;
}
return
aState
-
>
mSeenNonPunctuationSinceWhitespace
;
}
nsresult
nsFrame
:
:
CheckVisibility
(
nsPresContext
*
int32_t
int32_t
bool
bool
*
bool
*
)
{
return
NS_ERROR_NOT_IMPLEMENTED
;
}
int32_t
nsFrame
:
:
GetLineNumber
(
nsIFrame
*
aFrame
bool
aLockScroll
nsIFrame
*
*
aContainingBlock
)
{
NS_ASSERTION
(
aFrame
"
null
aFrame
"
)
;
nsIFrame
*
blockFrame
=
aFrame
;
nsIFrame
*
thisBlock
;
nsAutoLineIterator
it
;
nsresult
result
=
NS_ERROR_FAILURE
;
while
(
NS_FAILED
(
result
)
&
&
blockFrame
)
{
thisBlock
=
blockFrame
;
if
(
thisBlock
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
{
if
(
thisBlock
-
>
GetStateBits
(
)
&
NS_FRAME_IS_OVERFLOW_CONTAINER
)
{
thisBlock
=
thisBlock
-
>
FirstInFlow
(
)
;
}
thisBlock
=
thisBlock
-
>
GetPlaceholderFrame
(
)
;
if
(
!
thisBlock
)
return
-
1
;
}
blockFrame
=
thisBlock
-
>
GetParent
(
)
;
result
=
NS_OK
;
if
(
blockFrame
)
{
if
(
aLockScroll
&
&
blockFrame
-
>
IsScrollFrame
(
)
)
return
-
1
;
it
=
blockFrame
-
>
GetLineIterator
(
)
;
if
(
!
it
)
result
=
NS_ERROR_FAILURE
;
}
}
if
(
!
blockFrame
|
|
!
it
)
return
-
1
;
if
(
aContainingBlock
)
*
aContainingBlock
=
blockFrame
;
return
it
-
>
FindLineContaining
(
thisBlock
)
;
}
nsresult
nsIFrame
:
:
GetFrameFromDirection
(
nsDirection
aDirection
bool
aVisual
bool
aJumpLines
bool
aScrollViewStop
bool
aForceEditableRegion
nsIFrame
*
*
aOutFrame
int32_t
*
aOutOffset
bool
*
aOutJumpedLine
bool
*
aOutMovedOverNonSelectableText
)
{
nsresult
result
;
if
(
!
aOutFrame
|
|
!
aOutOffset
|
|
!
aOutJumpedLine
)
return
NS_ERROR_NULL_POINTER
;
nsPresContext
*
presContext
=
PresContext
(
)
;
*
aOutFrame
=
nullptr
;
*
aOutOffset
=
0
;
*
aOutJumpedLine
=
false
;
*
aOutMovedOverNonSelectableText
=
false
;
bool
selectable
=
false
;
nsIFrame
*
traversedFrame
=
this
;
while
(
!
selectable
)
{
nsIFrame
*
blockFrame
;
int32_t
thisLine
=
nsFrame
:
:
GetLineNumber
(
traversedFrame
aScrollViewStop
&
blockFrame
)
;
if
(
thisLine
<
0
)
return
NS_ERROR_FAILURE
;
nsAutoLineIterator
it
=
blockFrame
-
>
GetLineIterator
(
)
;
NS_ASSERTION
(
it
"
GetLineNumber
(
)
succeeded
but
no
block
frame
?
"
)
;
bool
atLineEdge
;
nsIFrame
*
firstFrame
;
nsIFrame
*
lastFrame
;
if
(
aVisual
&
&
presContext
-
>
BidiEnabled
(
)
)
{
bool
lineIsRTL
=
it
-
>
GetDirection
(
)
;
bool
isReordered
;
result
=
it
-
>
CheckLineOrder
(
thisLine
&
isReordered
&
firstFrame
&
lastFrame
)
;
nsIFrame
*
*
framePtr
=
aDirection
=
=
eDirPrevious
?
&
firstFrame
:
&
lastFrame
;
if
(
*
framePtr
)
{
bool
frameIsRTL
=
(
nsBidiPresUtils
:
:
FrameDirection
(
*
framePtr
)
=
=
NSBIDI_RTL
)
;
if
(
(
frameIsRTL
=
=
lineIsRTL
)
=
=
(
aDirection
=
=
eDirPrevious
)
)
{
nsFrame
:
:
GetFirstLeaf
(
presContext
framePtr
)
;
}
else
{
nsFrame
:
:
GetLastLeaf
(
presContext
framePtr
)
;
}
atLineEdge
=
*
framePtr
=
=
traversedFrame
;
}
else
{
atLineEdge
=
true
;
}
}
else
{
nsRect
nonUsedRect
;
int32_t
lineFrameCount
;
result
=
it
-
>
GetLine
(
thisLine
&
firstFrame
&
lineFrameCount
nonUsedRect
)
;
if
(
NS_FAILED
(
result
)
)
return
result
;
if
(
aDirection
=
=
eDirPrevious
)
{
nsFrame
:
:
GetFirstLeaf
(
presContext
&
firstFrame
)
;
atLineEdge
=
firstFrame
=
=
traversedFrame
;
}
else
{
lastFrame
=
firstFrame
;
for
(
;
lineFrameCount
>
1
;
lineFrameCount
-
-
)
{
result
=
it
-
>
GetNextSiblingOnLine
(
lastFrame
thisLine
)
;
if
(
NS_FAILED
(
result
)
|
|
!
lastFrame
)
{
NS_ERROR
(
"
should
not
be
reached
nsFrame
"
)
;
return
NS_ERROR_FAILURE
;
}
}
nsFrame
:
:
GetLastLeaf
(
presContext
&
lastFrame
)
;
atLineEdge
=
lastFrame
=
=
traversedFrame
;
}
}
if
(
atLineEdge
)
{
*
aOutJumpedLine
=
true
;
if
(
!
aJumpLines
)
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIFrameEnumerator
>
frameTraversal
;
result
=
NS_NewFrameTraversal
(
getter_AddRefs
(
frameTraversal
)
presContext
traversedFrame
eLeaf
aVisual
&
&
presContext
-
>
BidiEnabled
(
)
aScrollViewStop
true
false
)
;
if
(
NS_FAILED
(
result
)
)
return
result
;
if
(
aDirection
=
=
eDirNext
)
frameTraversal
-
>
Next
(
)
;
else
frameTraversal
-
>
Prev
(
)
;
traversedFrame
=
frameTraversal
-
>
CurrentItem
(
)
;
if
(
!
traversedFrame
)
{
return
NS_ERROR_FAILURE
;
}
auto
IsSelectable
=
[
aForceEditableRegion
]
(
const
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
-
>
IsSelectable
(
nullptr
)
)
{
return
false
;
}
return
!
aForceEditableRegion
|
|
aFrame
-
>
GetContent
(
)
-
>
IsEditable
(
)
;
}
;
if
(
atLineEdge
&
&
aDirection
=
=
eDirPrevious
&
&
traversedFrame
-
>
IsBrFrame
(
)
)
{
bool
canSkipBr
=
false
;
for
(
nsIFrame
*
current
=
traversedFrame
-
>
GetPrevSibling
(
)
;
current
;
current
=
current
-
>
GetPrevSibling
(
)
)
{
if
(
IsSelectable
(
current
)
)
{
canSkipBr
=
true
;
break
;
}
}
if
(
canSkipBr
)
{
continue
;
}
}
selectable
=
IsSelectable
(
traversedFrame
)
;
if
(
!
selectable
)
{
*
aOutMovedOverNonSelectableText
=
true
;
}
}
*
aOutOffset
=
(
aDirection
=
=
eDirNext
)
?
0
:
-
1
;
if
(
aVisual
&
&
IsReversedDirectionFrame
(
traversedFrame
)
)
{
*
aOutOffset
=
-
1
-
*
aOutOffset
;
}
*
aOutFrame
=
traversedFrame
;
return
NS_OK
;
}
nsView
*
nsIFrame
:
:
GetClosestView
(
nsPoint
*
aOffset
)
const
{
nsPoint
offset
(
0
0
)
;
for
(
const
nsIFrame
*
f
=
this
;
f
;
f
=
f
-
>
GetParent
(
)
)
{
if
(
f
-
>
HasView
(
)
)
{
if
(
aOffset
)
*
aOffset
=
offset
;
return
f
-
>
GetView
(
)
;
}
offset
+
=
f
-
>
GetPosition
(
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
No
view
on
any
parent
?
How
did
that
happen
?
"
)
;
return
nullptr
;
}
void
nsFrame
:
:
ChildIsDirty
(
nsIFrame
*
aChild
)
{
MOZ_ASSERT_UNREACHABLE
(
"
should
never
be
called
on
a
frame
that
doesn
'
t
"
"
inherit
from
nsContainerFrame
"
)
;
}
#
ifdef
ACCESSIBILITY
a11y
:
:
AccType
nsFrame
:
:
AccessibleType
(
)
{
if
(
IsTableCaption
(
)
&
&
!
GetRect
(
)
.
IsEmpty
(
)
)
{
return
a11y
:
:
eHTMLCaptionType
;
}
return
a11y
:
:
eNoType
;
}
#
endif
bool
nsIFrame
:
:
ClearOverflowRects
(
)
{
if
(
mOverflow
.
mType
=
=
NS_FRAME_OVERFLOW_NONE
)
{
return
false
;
}
if
(
mOverflow
.
mType
=
=
NS_FRAME_OVERFLOW_LARGE
)
{
DeleteProperty
(
OverflowAreasProperty
(
)
)
;
}
mOverflow
.
mType
=
NS_FRAME_OVERFLOW_NONE
;
return
true
;
}
bool
nsIFrame
:
:
SetOverflowAreas
(
const
nsOverflowAreas
&
aOverflowAreas
)
{
if
(
mOverflow
.
mType
=
=
NS_FRAME_OVERFLOW_LARGE
)
{
nsOverflowAreas
*
overflow
=
GetOverflowAreasProperty
(
)
;
bool
changed
=
*
overflow
!
=
aOverflowAreas
;
*
overflow
=
aOverflowAreas
;
return
changed
;
}
const
nsRect
&
vis
=
aOverflowAreas
.
VisualOverflow
(
)
;
uint32_t
l
=
-
vis
.
x
t
=
-
vis
.
y
r
=
vis
.
XMost
(
)
-
mRect
.
width
b
=
vis
.
YMost
(
)
-
mRect
.
height
;
if
(
aOverflowAreas
.
ScrollableOverflow
(
)
.
IsEqualEdges
(
nsRect
(
nsPoint
(
0
0
)
GetSize
(
)
)
)
&
&
l
<
=
NS_FRAME_OVERFLOW_DELTA_MAX
&
&
t
<
=
NS_FRAME_OVERFLOW_DELTA_MAX
&
&
r
<
=
NS_FRAME_OVERFLOW_DELTA_MAX
&
&
b
<
=
NS_FRAME_OVERFLOW_DELTA_MAX
&
&
(
l
|
t
|
r
|
b
)
!
=
0
)
{
VisualDeltas
oldDeltas
=
mOverflow
.
mVisualDeltas
;
mOverflow
.
mVisualDeltas
.
mLeft
=
l
;
mOverflow
.
mVisualDeltas
.
mTop
=
t
;
mOverflow
.
mVisualDeltas
.
mRight
=
r
;
mOverflow
.
mVisualDeltas
.
mBottom
=
b
;
return
oldDeltas
!
=
mOverflow
.
mVisualDeltas
;
}
else
{
bool
changed
=
!
aOverflowAreas
.
ScrollableOverflow
(
)
.
IsEqualEdges
(
nsRect
(
nsPoint
(
0
0
)
GetSize
(
)
)
)
|
|
!
aOverflowAreas
.
VisualOverflow
(
)
.
IsEqualEdges
(
GetVisualOverflowFromDeltas
(
)
)
;
mOverflow
.
mType
=
NS_FRAME_OVERFLOW_LARGE
;
AddProperty
(
OverflowAreasProperty
(
)
new
nsOverflowAreas
(
aOverflowAreas
)
)
;
return
changed
;
}
}
static
nsRect
UnionBorderBoxes
(
nsIFrame
*
aFrame
bool
aApplyTransform
bool
&
aOutValid
const
nsSize
*
aSizeOverride
=
nullptr
const
nsOverflowAreas
*
aOverflowOverride
=
nullptr
)
{
const
nsRect
bounds
(
nsPoint
(
0
0
)
aSizeOverride
?
*
aSizeOverride
:
aFrame
-
>
GetSize
(
)
)
;
aOutValid
=
!
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_SVG_LAYOUT
)
|
|
!
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVGContainer
)
|
|
aFrame
-
>
IsSVGTextFrame
(
)
;
nsRect
u
;
if
(
!
aFrame
-
>
FrameMaintainsOverflow
(
)
)
{
return
u
;
}
bool
doTransform
=
aApplyTransform
&
&
aFrame
-
>
IsTransformed
(
)
;
if
(
doTransform
)
{
u
=
nsDisplayTransform
:
:
TransformRect
(
bounds
aFrame
&
bounds
)
;
}
else
{
u
=
bounds
;
}
if
(
aOverflowOverride
)
{
if
(
!
doTransform
&
&
bounds
.
IsEqualEdges
(
aOverflowOverride
-
>
VisualOverflow
(
)
)
&
&
bounds
.
IsEqualEdges
(
aOverflowOverride
-
>
ScrollableOverflow
(
)
)
)
{
return
u
;
}
}
else
{
if
(
!
doTransform
&
&
bounds
.
IsEqualEdges
(
aFrame
-
>
GetVisualOverflowRect
(
)
)
&
&
bounds
.
IsEqualEdges
(
aFrame
-
>
GetScrollableOverflowRect
(
)
)
)
{
return
u
;
}
}
const
nsStyleDisplay
*
disp
=
aFrame
-
>
StyleDisplay
(
)
;
LayoutFrameType
fType
=
aFrame
-
>
Type
(
)
;
if
(
nsFrame
:
:
ShouldApplyOverflowClipping
(
aFrame
disp
)
|
|
fType
=
=
LayoutFrameType
:
:
Scroll
|
|
fType
=
=
LayoutFrameType
:
:
ListControl
|
|
fType
=
=
LayoutFrameType
:
:
SVGOuterSVG
)
{
return
u
;
}
const
nsStyleEffects
*
effects
=
aFrame
-
>
StyleEffects
(
)
;
Maybe
<
nsRect
>
clipPropClipRect
=
aFrame
-
>
GetClipPropClipRect
(
disp
effects
bounds
.
Size
(
)
)
;
const
nsIFrame
:
:
ChildListIDs
skip
=
{
nsIFrame
:
:
kPopupList
nsIFrame
:
:
kSelectPopupList
nsIFrame
:
:
kAbsoluteList
nsIFrame
:
:
kFixedList
nsIFrame
:
:
kFloatList
}
;
for
(
nsIFrame
:
:
ChildListIterator
childLists
(
aFrame
)
;
!
childLists
.
IsDone
(
)
;
childLists
.
Next
(
)
)
{
if
(
skip
.
contains
(
childLists
.
CurrentID
(
)
)
)
{
continue
;
}
nsFrameList
children
=
childLists
.
CurrentList
(
)
;
for
(
nsFrameList
:
:
Enumerator
e
(
children
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
)
{
nsIFrame
*
child
=
e
.
get
(
)
;
if
(
child
-
>
IsPlaceholderFrame
(
)
)
{
continue
;
}
bool
validRect
=
true
;
nsRect
childRect
=
UnionBorderBoxes
(
child
true
validRect
)
+
child
-
>
GetPosition
(
)
;
if
(
!
validRect
)
{
continue
;
}
if
(
clipPropClipRect
)
{
childRect
.
IntersectRect
(
childRect
*
clipPropClipRect
)
;
}
if
(
doTransform
&
&
!
child
-
>
Combines3DTransformWithAncestors
(
)
)
{
childRect
=
nsDisplayTransform
:
:
TransformRect
(
childRect
aFrame
&
bounds
)
;
}
if
(
!
aOutValid
&
&
validRect
)
{
u
=
childRect
;
aOutValid
=
true
;
}
else
{
u
.
UnionRectEdges
(
u
childRect
)
;
}
}
}
return
u
;
}
static
void
ComputeAndIncludeOutlineArea
(
nsIFrame
*
aFrame
nsOverflowAreas
&
aOverflowAreas
const
nsSize
&
aNewSize
)
{
const
nsStyleOutline
*
outline
=
aFrame
-
>
StyleOutline
(
)
;
if
(
!
outline
-
>
ShouldPaintOutline
(
)
)
{
return
;
}
nsIFrame
*
frameForArea
=
aFrame
;
do
{
nsAtom
*
pseudoType
=
frameForArea
-
>
Style
(
)
-
>
GetPseudo
(
)
;
if
(
pseudoType
!
=
nsCSSAnonBoxes
:
:
mozBlockInsideInlineWrapper
(
)
)
break
;
frameForArea
=
frameForArea
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
NS_ASSERTION
(
frameForArea
"
anonymous
block
with
no
children
?
"
)
;
}
while
(
frameForArea
)
;
nsRect
innerRect
;
bool
validRect
;
if
(
frameForArea
=
=
aFrame
)
{
innerRect
=
UnionBorderBoxes
(
aFrame
false
validRect
&
aNewSize
&
aOverflowAreas
)
;
}
else
{
for
(
;
frameForArea
;
frameForArea
=
frameForArea
-
>
GetNextSibling
(
)
)
{
nsRect
r
(
UnionBorderBoxes
(
frameForArea
true
validRect
)
)
;
for
(
nsIFrame
*
f
=
frameForArea
*
parent
=
f
-
>
GetParent
(
)
;
;
f
=
parent
parent
=
f
-
>
GetParent
(
)
)
{
r
+
=
f
-
>
GetPosition
(
)
;
if
(
parent
=
=
aFrame
)
{
break
;
}
if
(
parent
-
>
IsTransformed
(
)
&
&
!
f
-
>
Combines3DTransformWithAncestors
(
)
)
{
r
=
nsDisplayTransform
:
:
TransformRect
(
r
parent
)
;
}
}
innerRect
.
UnionRect
(
innerRect
r
)
;
}
}
SetOrUpdateRectValuedProperty
(
aFrame
nsIFrame
:
:
OutlineInnerRectProperty
(
)
innerRect
)
;
const
nscoord
offset
=
outline
-
>
mOutlineOffset
;
nsRect
outerRect
(
innerRect
)
;
bool
useOutlineAuto
=
false
;
if
(
nsLayoutUtils
:
:
IsOutlineStyleAutoEnabled
(
)
)
{
useOutlineAuto
=
outline
-
>
mOutlineStyle
.
IsAuto
(
)
;
if
(
MOZ_UNLIKELY
(
useOutlineAuto
)
)
{
nsPresContext
*
presContext
=
aFrame
-
>
PresContext
(
)
;
nsITheme
*
theme
=
presContext
-
>
GetTheme
(
)
;
if
(
theme
&
&
theme
-
>
ThemeSupportsWidget
(
presContext
aFrame
StyleAppearance
:
:
FocusOutline
)
)
{
outerRect
.
Inflate
(
offset
)
;
theme
-
>
GetWidgetOverflow
(
presContext
-
>
DeviceContext
(
)
aFrame
StyleAppearance
:
:
FocusOutline
&
outerRect
)
;
}
else
{
useOutlineAuto
=
false
;
}
}
}
if
(
MOZ_LIKELY
(
!
useOutlineAuto
)
)
{
nscoord
width
=
outline
-
>
GetOutlineWidth
(
)
;
outerRect
.
Inflate
(
width
+
offset
)
;
}
nsRect
&
vo
=
aOverflowAreas
.
VisualOverflow
(
)
;
vo
.
UnionRectEdges
(
vo
innerRect
.
Union
(
outerRect
)
)
;
}
bool
nsIFrame
:
:
FinishAndStoreOverflow
(
nsOverflowAreas
&
aOverflowAreas
nsSize
aNewSize
nsSize
*
aOldSize
const
nsStyleDisplay
*
aStyleDisplay
)
{
MOZ_ASSERT
(
FrameMaintainsOverflow
(
)
"
Don
'
t
call
-
overflow
rects
not
maintained
on
these
SVG
frames
"
)
;
const
nsStyleDisplay
*
disp
=
StyleDisplayWithOptionalParam
(
aStyleDisplay
)
;
EffectSet
*
effectSet
=
EffectSet
:
:
GetEffectSet
(
this
)
;
bool
hasTransform
=
IsTransformed
(
disp
)
;
nsRect
bounds
(
nsPoint
(
0
0
)
aNewSize
)
;
if
(
hasTransform
|
|
Combines3DTransformWithAncestors
(
disp
)
)
{
if
(
!
aOverflowAreas
.
VisualOverflow
(
)
.
IsEqualEdges
(
bounds
)
|
|
!
aOverflowAreas
.
ScrollableOverflow
(
)
.
IsEqualEdges
(
bounds
)
)
{
nsOverflowAreas
*
initial
=
GetProperty
(
nsIFrame
:
:
InitialOverflowProperty
(
)
)
;
if
(
!
initial
)
{
AddProperty
(
nsIFrame
:
:
InitialOverflowProperty
(
)
new
nsOverflowAreas
(
aOverflowAreas
)
)
;
}
else
if
(
initial
!
=
&
aOverflowAreas
)
{
*
initial
=
aOverflowAreas
;
}
}
else
{
DeleteProperty
(
nsIFrame
:
:
InitialOverflowProperty
(
)
)
;
}
#
ifdef
DEBUG
SetProperty
(
nsIFrame
:
:
DebugInitialOverflowPropertyApplied
(
)
true
)
;
#
endif
}
else
{
#
ifdef
DEBUG
DeleteProperty
(
nsIFrame
:
:
DebugInitialOverflowPropertyApplied
(
)
)
;
#
endif
}
nsSize
oldSize
=
mRect
.
Size
(
)
;
bool
sizeChanged
=
(
(
aOldSize
?
*
aOldSize
:
oldSize
)
!
=
aNewSize
)
;
SetSize
(
aNewSize
false
)
;
const
bool
applyOverflowClipping
=
nsFrame
:
:
ShouldApplyOverflowClipping
(
this
disp
)
;
if
(
ChildrenHavePerspective
(
disp
)
&
&
sizeChanged
)
{
RecomputePerspectiveChildrenOverflow
(
this
)
;
if
(
!
applyOverflowClipping
)
{
aOverflowAreas
.
SetAllTo
(
bounds
)
;
DebugOnly
<
bool
>
ok
=
ComputeCustomOverflow
(
aOverflowAreas
)
;
MOZ_ASSERT
(
ok
"
FrameMaintainsOverflow
(
)
!
=
ComputeCustomOverflow
(
)
"
)
;
UnionChildOverflow
(
aOverflowAreas
)
;
}
}
NS_FOR_FRAME_OVERFLOW_TYPES
(
otype
)
{
DebugOnly
<
nsRect
*
>
r
=
&
aOverflowAreas
.
Overflow
(
otype
)
;
NS_ASSERTION
(
aNewSize
.
width
=
=
0
|
|
aNewSize
.
height
=
=
0
|
|
r
-
>
width
=
=
nscoord_MAX
|
|
r
-
>
height
=
=
nscoord_MAX
|
|
(
mState
&
NS_FRAME_SVG_LAYOUT
)
|
|
r
-
>
Contains
(
nsRect
(
nsPoint
(
0
0
)
aNewSize
)
)
"
Computed
overflow
area
must
contain
frame
bounds
"
)
;
}
NS_ASSERTION
(
(
disp
-
>
mOverflowY
=
=
StyleOverflow
:
:
MozHiddenUnscrollable
)
=
=
(
disp
-
>
mOverflowX
=
=
StyleOverflow
:
:
MozHiddenUnscrollable
)
"
If
one
overflow
is
clip
the
other
should
be
too
"
)
;
if
(
applyOverflowClipping
)
{
aOverflowAreas
.
SetAllTo
(
bounds
)
;
}
if
(
(
aNewSize
.
width
!
=
0
|
|
!
IsInlineFrame
(
)
)
&
&
!
(
GetStateBits
(
)
&
NS_FRAME_SVG_LAYOUT
)
)
{
NS_FOR_FRAME_OVERFLOW_TYPES
(
otype
)
{
nsRect
&
o
=
aOverflowAreas
.
Overflow
(
otype
)
;
o
.
UnionRectEdges
(
o
bounds
)
;
}
}
if
(
!
:
:
IsXULBoxWrapped
(
this
)
&
&
IsThemed
(
disp
)
)
{
nsRect
r
(
bounds
)
;
nsPresContext
*
presContext
=
PresContext
(
)
;
if
(
presContext
-
>
GetTheme
(
)
-
>
GetWidgetOverflow
(
presContext
-
>
DeviceContext
(
)
this
disp
-
>
mAppearance
&
r
)
)
{
nsRect
&
vo
=
aOverflowAreas
.
VisualOverflow
(
)
;
vo
.
UnionRectEdges
(
vo
r
)
;
}
}
ComputeAndIncludeOutlineArea
(
this
aOverflowAreas
aNewSize
)
;
aOverflowAreas
.
VisualOverflow
(
)
=
ComputeEffectsRect
(
this
aOverflowAreas
.
VisualOverflow
(
)
aNewSize
)
;
const
nsStyleEffects
*
effects
=
StyleEffects
(
)
;
Maybe
<
nsRect
>
clipPropClipRect
=
GetClipPropClipRect
(
disp
effects
aNewSize
)
;
if
(
clipPropClipRect
)
{
NS_FOR_FRAME_OVERFLOW_TYPES
(
otype
)
{
nsRect
&
o
=
aOverflowAreas
.
Overflow
(
otype
)
;
o
.
IntersectRect
(
o
*
clipPropClipRect
)
;
}
}
if
(
hasTransform
)
{
SetProperty
(
nsIFrame
:
:
PreTransformOverflowAreasProperty
(
)
new
nsOverflowAreas
(
aOverflowAreas
)
)
;
if
(
Combines3DTransformWithAncestors
(
disp
)
)
{
aOverflowAreas
.
SetAllTo
(
nsRect
(
)
)
;
}
else
{
NS_FOR_FRAME_OVERFLOW_TYPES
(
otype
)
{
nsRect
&
o
=
aOverflowAreas
.
Overflow
(
otype
)
;
o
=
nsDisplayTransform
:
:
TransformRect
(
o
this
)
;
}
if
(
Extend3DContext
(
disp
effects
effectSet
)
)
{
ComputePreserve3DChildrenOverflow
(
aOverflowAreas
)
;
}
}
}
else
{
DeleteProperty
(
nsIFrame
:
:
PreTransformOverflowAreasProperty
(
)
)
;
}
SetSize
(
oldSize
false
)
;
bool
anyOverflowChanged
;
if
(
aOverflowAreas
!
=
nsOverflowAreas
(
bounds
bounds
)
)
{
anyOverflowChanged
=
SetOverflowAreas
(
aOverflowAreas
)
;
}
else
{
anyOverflowChanged
=
ClearOverflowRects
(
)
;
}
if
(
anyOverflowChanged
)
{
SVGObserverUtils
:
:
InvalidateDirectRenderingObservers
(
this
)
;
}
return
anyOverflowChanged
;
}
void
nsIFrame
:
:
RecomputePerspectiveChildrenOverflow
(
const
nsIFrame
*
aStartFrame
)
{
nsIFrame
:
:
ChildListIterator
lists
(
this
)
;
for
(
;
!
lists
.
IsDone
(
)
;
lists
.
Next
(
)
)
{
nsFrameList
:
:
Enumerator
childFrames
(
lists
.
CurrentList
(
)
)
;
for
(
;
!
childFrames
.
AtEnd
(
)
;
childFrames
.
Next
(
)
)
{
nsIFrame
*
child
=
childFrames
.
get
(
)
;
if
(
!
child
-
>
FrameMaintainsOverflow
(
)
)
{
continue
;
}
if
(
child
-
>
HasPerspective
(
)
)
{
nsOverflowAreas
*
overflow
=
child
-
>
GetProperty
(
nsIFrame
:
:
InitialOverflowProperty
(
)
)
;
nsRect
bounds
(
nsPoint
(
0
0
)
child
-
>
GetSize
(
)
)
;
if
(
overflow
)
{
nsOverflowAreas
overflowCopy
=
*
overflow
;
child
-
>
FinishAndStoreOverflow
(
overflowCopy
bounds
.
Size
(
)
)
;
}
else
{
nsOverflowAreas
boundsOverflow
;
boundsOverflow
.
SetAllTo
(
bounds
)
;
child
-
>
FinishAndStoreOverflow
(
boundsOverflow
bounds
.
Size
(
)
)
;
}
}
else
if
(
child
-
>
GetContainingBlock
(
SKIP_SCROLLED_FRAME
)
=
=
aStartFrame
)
{
child
-
>
RecomputePerspectiveChildrenOverflow
(
aStartFrame
)
;
}
}
}
}
void
nsIFrame
:
:
ComputePreserve3DChildrenOverflow
(
nsOverflowAreas
&
aOverflowAreas
)
{
nsRect
childVisual
;
nsRect
childScrollable
;
nsIFrame
:
:
ChildListIterator
lists
(
this
)
;
for
(
;
!
lists
.
IsDone
(
)
;
lists
.
Next
(
)
)
{
nsFrameList
:
:
Enumerator
childFrames
(
lists
.
CurrentList
(
)
)
;
for
(
;
!
childFrames
.
AtEnd
(
)
;
childFrames
.
Next
(
)
)
{
nsIFrame
*
child
=
childFrames
.
get
(
)
;
const
nsStyleDisplay
*
childDisp
=
child
-
>
StyleDisplay
(
)
;
if
(
child
-
>
Combines3DTransformWithAncestors
(
childDisp
)
)
{
nsOverflowAreas
childOverflow
=
child
-
>
GetOverflowAreasRelativeToSelf
(
)
;
NS_FOR_FRAME_OVERFLOW_TYPES
(
otype
)
{
nsRect
&
o
=
childOverflow
.
Overflow
(
otype
)
;
o
=
nsDisplayTransform
:
:
TransformRect
(
o
child
)
;
}
aOverflowAreas
.
UnionWith
(
childOverflow
)
;
if
(
child
-
>
Extend3DContext
(
childDisp
child
-
>
StyleEffects
(
)
)
)
{
child
-
>
ComputePreserve3DChildrenOverflow
(
aOverflowAreas
)
;
}
}
}
}
}
bool
nsIFrame
:
:
IsScrollAnchor
(
ScrollAnchorContainer
*
*
aOutContainer
)
{
if
(
!
mInScrollAnchorChain
)
{
return
false
;
}
ScrollAnchorContainer
*
container
=
ScrollAnchorContainer
:
:
FindFor
(
this
)
;
if
(
container
-
>
AnchorNode
(
)
!
=
this
)
{
return
false
;
}
if
(
aOutContainer
)
{
*
aOutContainer
=
container
;
}
return
true
;
}
bool
nsIFrame
:
:
IsInScrollAnchorChain
(
)
const
{
return
mInScrollAnchorChain
;
}
void
nsIFrame
:
:
SetInScrollAnchorChain
(
bool
aInChain
)
{
mInScrollAnchorChain
=
aInChain
;
}
uint32_t
nsIFrame
:
:
GetDepthInFrameTree
(
)
const
{
uint32_t
result
=
0
;
for
(
nsContainerFrame
*
ancestor
=
GetParent
(
)
;
ancestor
;
ancestor
=
ancestor
-
>
GetParent
(
)
)
{
result
+
+
;
}
return
result
;
}
void
nsFrame
:
:
ConsiderChildOverflow
(
nsOverflowAreas
&
aOverflowAreas
nsIFrame
*
aChildFrame
)
{
if
(
StyleDisplay
(
)
-
>
IsContainLayout
(
)
&
&
IsFrameOfType
(
eSupportsContainLayoutAndPaint
)
)
{
nsRect
childVisual
=
aChildFrame
-
>
GetVisualOverflowRect
(
)
;
nsOverflowAreas
combined
=
nsOverflowAreas
(
childVisual
nsRect
(
)
)
;
aOverflowAreas
.
UnionWith
(
combined
+
aChildFrame
-
>
GetPosition
(
)
)
;
}
else
{
aOverflowAreas
.
UnionWith
(
aChildFrame
-
>
GetOverflowAreas
(
)
+
aChildFrame
-
>
GetPosition
(
)
)
;
}
}
bool
nsFrame
:
:
ShouldAvoidBreakInside
(
const
ReflowInput
&
aReflowInput
)
const
{
const
auto
*
disp
=
StyleDisplay
(
)
;
return
!
aReflowInput
.
mFlags
.
mIsTopOfPage
&
&
StyleBreakWithin
:
:
Avoid
=
=
disp
-
>
mBreakInside
&
&
!
(
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
&
&
IsAbsolutelyPositioned
(
disp
)
)
&
&
!
GetPrevInFlow
(
)
;
}
static
nsIFrame
*
GetIBSplitSiblingForAnonymousBlock
(
const
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
"
Must
have
a
non
-
null
frame
!
"
)
;
NS_ASSERTION
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_PART_OF_IBSPLIT
"
GetIBSplitSibling
should
only
be
called
on
ib
-
split
frames
"
)
;
nsAtom
*
type
=
aFrame
-
>
Style
(
)
-
>
GetPseudo
(
)
;
if
(
type
!
=
nsCSSAnonBoxes
:
:
mozBlockInsideInlineWrapper
(
)
)
{
return
nullptr
;
}
aFrame
=
aFrame
-
>
FirstContinuation
(
)
;
nsIFrame
*
ibSplitSibling
=
aFrame
-
>
GetProperty
(
nsIFrame
:
:
IBSplitPrevSibling
(
)
)
;
NS_ASSERTION
(
ibSplitSibling
"
Broken
frame
tree
?
"
)
;
return
ibSplitSibling
;
}
static
nsIFrame
*
GetCorrectedParent
(
const
nsIFrame
*
aFrame
)
{
nsIFrame
*
parent
=
aFrame
-
>
GetParent
(
)
;
if
(
!
parent
)
{
return
nullptr
;
}
if
(
aFrame
-
>
IsTableCaption
(
)
)
{
nsIFrame
*
innerTable
=
parent
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
!
innerTable
-
>
Style
(
)
-
>
GetPseudo
(
)
)
{
return
innerTable
;
}
}
nsAtom
*
pseudo
=
aFrame
-
>
Style
(
)
-
>
GetPseudo
(
)
;
if
(
pseudo
=
=
nsCSSAnonBoxes
:
:
tableWrapper
(
)
)
{
pseudo
=
aFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
-
>
Style
(
)
-
>
GetPseudo
(
)
;
}
if
(
pseudo
)
{
MOZ_ASSERT
(
aFrame
-
>
GetContent
(
)
)
;
Element
*
element
=
Element
:
:
FromNode
(
aFrame
-
>
GetContent
(
)
)
;
if
(
element
&
&
!
element
-
>
IsRootOfNativeAnonymousSubtree
(
)
&
&
element
-
>
GetPseudoElementType
(
)
=
=
aFrame
-
>
Style
(
)
-
>
GetPseudoType
(
)
)
{
while
(
parent
-
>
GetContent
(
)
&
&
!
parent
-
>
GetContent
(
)
-
>
IsRootOfAnonymousSubtree
(
)
)
{
parent
=
parent
-
>
GetInFlowParent
(
)
;
}
parent
=
parent
-
>
GetInFlowParent
(
)
;
}
}
return
nsFrame
:
:
CorrectStyleParentFrame
(
parent
pseudo
)
;
}
nsIFrame
*
nsFrame
:
:
CorrectStyleParentFrame
(
nsIFrame
*
aProspectiveParent
nsAtom
*
aChildPseudo
)
{
MOZ_ASSERT
(
aProspectiveParent
"
Must
have
a
prospective
parent
"
)
;
if
(
aChildPseudo
)
{
if
(
nsCSSAnonBoxes
:
:
IsNonInheritingAnonBox
(
aChildPseudo
)
)
{
return
nullptr
;
}
if
(
!
nsCSSAnonBoxes
:
:
IsNonElement
(
aChildPseudo
)
&
&
nsCSSAnonBoxes
:
:
IsAnonBox
(
aChildPseudo
)
)
{
NS_ASSERTION
(
aChildPseudo
!
=
nsCSSAnonBoxes
:
:
mozBlockInsideInlineWrapper
(
)
"
Should
have
dealt
with
kids
that
have
"
"
NS_FRAME_PART_OF_IBSPLIT
elsewhere
"
)
;
return
aProspectiveParent
;
}
}
nsIFrame
*
parent
=
aProspectiveParent
;
do
{
if
(
parent
-
>
GetStateBits
(
)
&
NS_FRAME_PART_OF_IBSPLIT
)
{
nsIFrame
*
sibling
=
GetIBSplitSiblingForAnonymousBlock
(
parent
)
;
if
(
sibling
)
{
parent
=
sibling
;
}
}
nsAtom
*
parentPseudo
=
parent
-
>
Style
(
)
-
>
GetPseudo
(
)
;
if
(
!
parentPseudo
|
|
(
!
nsCSSAnonBoxes
:
:
IsAnonBox
(
parentPseudo
)
&
&
aChildPseudo
!
=
nsGkAtoms
:
:
placeholderFrame
)
)
{
return
parent
;
}
parent
=
parent
-
>
GetInFlowParent
(
)
;
}
while
(
parent
)
;
if
(
aProspectiveParent
-
>
Style
(
)
-
>
GetPseudo
(
)
=
=
nsCSSAnonBoxes
:
:
viewportScroll
(
)
)
{
return
aProspectiveParent
;
}
NS_ASSERTION
(
aProspectiveParent
-
>
IsCanvasFrame
(
)
"
Should
have
found
a
parent
before
this
"
)
;
return
nullptr
;
}
ComputedStyle
*
nsFrame
:
:
DoGetParentComputedStyle
(
nsIFrame
*
*
aProviderFrame
)
const
{
*
aProviderFrame
=
nullptr
;
if
(
MOZ_LIKELY
(
mContent
)
)
{
Element
*
parentElement
=
mContent
-
>
GetFlattenedTreeParentElement
(
)
;
if
(
MOZ_LIKELY
(
parentElement
)
)
{
nsAtom
*
pseudo
=
Style
(
)
-
>
GetPseudo
(
)
;
if
(
!
pseudo
|
|
!
mContent
-
>
IsElement
(
)
|
|
(
!
nsCSSAnonBoxes
:
:
IsAnonBox
(
pseudo
)
&
&
IsPrimaryFrame
(
)
)
|
|
pseudo
=
=
nsCSSAnonBoxes
:
:
tableWrapper
(
)
)
{
if
(
Servo_Element_IsDisplayContents
(
parentElement
)
)
{
RefPtr
<
ComputedStyle
>
style
=
PresShell
(
)
-
>
StyleSet
(
)
-
>
ResolveServoStyle
(
*
parentElement
)
;
return
style
;
}
}
}
else
{
if
(
!
Style
(
)
-
>
GetPseudo
(
)
)
{
return
nullptr
;
}
}
}
if
(
!
(
mState
&
NS_FRAME_OUT_OF_FLOW
)
)
{
if
(
mState
&
NS_FRAME_PART_OF_IBSPLIT
)
{
nsIFrame
*
ibSplitSibling
=
GetIBSplitSiblingForAnonymousBlock
(
this
)
;
if
(
ibSplitSibling
)
{
return
(
*
aProviderFrame
=
ibSplitSibling
)
-
>
Style
(
)
;
}
}
*
aProviderFrame
=
GetCorrectedParent
(
this
)
;
return
*
aProviderFrame
?
(
*
aProviderFrame
)
-
>
Style
(
)
:
nullptr
;
}
nsPlaceholderFrame
*
placeholder
=
FirstInFlow
(
)
-
>
GetPlaceholderFrame
(
)
;
if
(
!
placeholder
)
{
MOZ_ASSERT_UNREACHABLE
(
"
no
placeholder
frame
for
out
-
of
-
flow
frame
"
)
;
*
aProviderFrame
=
GetCorrectedParent
(
this
)
;
return
*
aProviderFrame
?
(
*
aProviderFrame
)
-
>
Style
(
)
:
nullptr
;
}
return
placeholder
-
>
GetParentComputedStyleForOutOfFlow
(
aProviderFrame
)
;
}
void
nsFrame
:
:
GetLastLeaf
(
nsPresContext
*
aPresContext
nsIFrame
*
*
aFrame
)
{
if
(
!
aFrame
|
|
!
*
aFrame
)
return
;
nsIFrame
*
child
=
*
aFrame
;
while
(
1
)
{
child
=
child
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
!
child
)
return
;
nsIFrame
*
siblingFrame
;
nsIContent
*
content
;
while
(
(
siblingFrame
=
child
-
>
GetNextSibling
(
)
)
&
&
(
content
=
siblingFrame
-
>
GetContent
(
)
)
&
&
!
content
-
>
IsRootOfNativeAnonymousSubtree
(
)
)
child
=
siblingFrame
;
*
aFrame
=
child
;
}
}
void
nsFrame
:
:
GetFirstLeaf
(
nsPresContext
*
aPresContext
nsIFrame
*
*
aFrame
)
{
if
(
!
aFrame
|
|
!
*
aFrame
)
return
;
nsIFrame
*
child
=
*
aFrame
;
while
(
1
)
{
child
=
child
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
!
child
)
return
;
*
aFrame
=
child
;
}
}
bool
nsIFrame
:
:
IsFocusable
(
int32_t
*
aTabIndex
bool
aWithMouse
)
{
int32_t
tabIndex
=
-
1
;
if
(
aTabIndex
)
{
*
aTabIndex
=
-
1
;
}
bool
isFocusable
=
false
;
if
(
mContent
&
&
mContent
-
>
IsElement
(
)
&
&
IsVisibleConsideringAncestors
(
)
&
&
Style
(
)
-
>
GetPseudo
(
)
!
=
nsCSSAnonBoxes
:
:
anonymousFlexItem
(
)
&
&
Style
(
)
-
>
GetPseudo
(
)
!
=
nsCSSAnonBoxes
:
:
anonymousGridItem
(
)
)
{
const
nsStyleUI
*
ui
=
StyleUI
(
)
;
if
(
ui
-
>
mUserFocus
!
=
StyleUserFocus
:
:
Ignore
&
&
ui
-
>
mUserFocus
!
=
StyleUserFocus
:
:
None
)
{
tabIndex
=
0
;
}
isFocusable
=
mContent
-
>
IsFocusable
(
&
tabIndex
aWithMouse
)
;
if
(
!
isFocusable
&
&
!
aWithMouse
&
&
IsScrollFrame
(
)
&
&
mContent
-
>
IsHTMLElement
(
)
&
&
!
mContent
-
>
IsRootOfNativeAnonymousSubtree
(
)
&
&
mContent
-
>
GetParent
(
)
&
&
!
mContent
-
>
AsElement
(
)
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
tabindex
)
)
{
nsIScrollableFrame
*
scrollFrame
=
do_QueryFrame
(
this
)
;
if
(
scrollFrame
&
&
!
scrollFrame
-
>
GetScrollStyles
(
)
.
IsHiddenInBothDirections
(
)
&
&
!
scrollFrame
-
>
GetScrollRange
(
)
.
IsEqualEdges
(
nsRect
(
0
0
0
0
)
)
)
{
isFocusable
=
true
;
tabIndex
=
0
;
}
}
}
if
(
aTabIndex
)
{
*
aTabIndex
=
tabIndex
;
}
return
isFocusable
;
}
bool
nsIFrame
:
:
HasSignificantTerminalNewline
(
)
const
{
return
false
;
}
static
uint8_t
ConvertSVGDominantBaselineToVerticalAlign
(
uint8_t
aDominantBaseline
)
{
switch
(
aDominantBaseline
)
{
case
NS_STYLE_DOMINANT_BASELINE_HANGING
:
case
NS_STYLE_DOMINANT_BASELINE_TEXT_BEFORE_EDGE
:
return
NS_STYLE_VERTICAL_ALIGN_TEXT_TOP
;
case
NS_STYLE_DOMINANT_BASELINE_TEXT_AFTER_EDGE
:
case
NS_STYLE_DOMINANT_BASELINE_IDEOGRAPHIC
:
return
NS_STYLE_VERTICAL_ALIGN_TEXT_BOTTOM
;
case
NS_STYLE_DOMINANT_BASELINE_CENTRAL
:
case
NS_STYLE_DOMINANT_BASELINE_MIDDLE
:
case
NS_STYLE_DOMINANT_BASELINE_MATHEMATICAL
:
return
NS_STYLE_VERTICAL_ALIGN_MIDDLE
;
case
NS_STYLE_DOMINANT_BASELINE_AUTO
:
case
NS_STYLE_DOMINANT_BASELINE_ALPHABETIC
:
return
NS_STYLE_VERTICAL_ALIGN_BASELINE
;
case
NS_STYLE_DOMINANT_BASELINE_USE_SCRIPT
:
case
NS_STYLE_DOMINANT_BASELINE_NO_CHANGE
:
case
NS_STYLE_DOMINANT_BASELINE_RESET_SIZE
:
return
NS_STYLE_VERTICAL_ALIGN_BASELINE
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
aDominantBaseline
value
"
)
;
return
NS_STYLE_VERTICAL_ALIGN_BASELINE
;
}
}
uint8_t
nsIFrame
:
:
VerticalAlignEnum
(
)
const
{
if
(
nsSVGUtils
:
:
IsInSVGTextSubtree
(
this
)
)
{
uint8_t
dominantBaseline
;
for
(
const
nsIFrame
*
frame
=
this
;
frame
;
frame
=
frame
-
>
GetParent
(
)
)
{
dominantBaseline
=
frame
-
>
StyleSVGReset
(
)
-
>
mDominantBaseline
;
if
(
dominantBaseline
!
=
NS_STYLE_DOMINANT_BASELINE_AUTO
|
|
frame
-
>
IsSVGTextFrame
(
)
)
{
break
;
}
}
return
ConvertSVGDominantBaselineToVerticalAlign
(
dominantBaseline
)
;
}
const
nsStyleCoord
&
verticalAlign
=
StyleDisplay
(
)
-
>
mVerticalAlign
;
if
(
verticalAlign
.
GetUnit
(
)
=
=
eStyleUnit_Enumerated
)
{
return
verticalAlign
.
GetIntValue
(
)
;
}
return
eInvalidVerticalAlign
;
}
void
nsFrame
:
:
FillCursorInformationFromStyle
(
const
nsStyleUI
*
ui
nsIFrame
:
:
Cursor
&
aCursor
)
{
aCursor
.
mCursor
=
ui
-
>
mCursor
;
aCursor
.
mHaveHotspot
=
false
;
aCursor
.
mLoading
=
false
;
aCursor
.
mHotspotX
=
aCursor
.
mHotspotY
=
0
.
0f
;
for
(
const
nsCursorImage
&
item
:
ui
-
>
mCursorImages
)
{
uint32_t
status
;
imgRequestProxy
*
req
=
item
.
GetImage
(
)
;
if
(
!
req
|
|
NS_FAILED
(
req
-
>
GetImageStatus
(
&
status
)
)
)
{
continue
;
}
if
(
!
(
status
&
imgIRequest
:
:
STATUS_LOAD_COMPLETE
)
)
{
aCursor
.
mLoading
=
true
;
}
else
if
(
!
(
status
&
imgIRequest
:
:
STATUS_ERROR
)
)
{
req
-
>
GetImage
(
getter_AddRefs
(
aCursor
.
mContainer
)
)
;
aCursor
.
mHaveHotspot
=
item
.
mHaveHotspot
;
aCursor
.
mHotspotX
=
item
.
mHotspotX
;
aCursor
.
mHotspotY
=
item
.
mHotspotY
;
break
;
}
}
}
NS_IMETHODIMP
nsFrame
:
:
RefreshSizeCache
(
nsBoxLayoutState
&
aState
)
{
gfxContext
*
rendContext
=
aState
.
GetRenderingContext
(
)
;
if
(
rendContext
)
{
nsPresContext
*
presContext
=
aState
.
PresContext
(
)
;
nsBoxLayoutMetrics
*
metrics
=
BoxMetrics
(
)
;
if
(
!
DoesNeedRecalc
(
metrics
-
>
mBlockPrefSize
)
)
return
NS_OK
;
nsRect
rect
=
GetRect
(
)
;
nsMargin
bp
(
0
0
0
0
)
;
GetXULBorderAndPadding
(
bp
)
;
{
AutoMaybeDisableFontInflation
an
(
this
)
;
metrics
-
>
mBlockPrefSize
.
width
=
GetPrefISize
(
rendContext
)
+
bp
.
LeftRight
(
)
;
metrics
-
>
mBlockMinSize
.
width
=
GetMinISize
(
rendContext
)
+
bp
.
LeftRight
(
)
;
}
const
WritingMode
wm
=
aState
.
OuterReflowInput
(
)
?
aState
.
OuterReflowInput
(
)
-
>
GetWritingMode
(
)
:
GetWritingMode
(
)
;
ReflowOutput
desiredSize
(
wm
)
;
BoxReflow
(
aState
presContext
desiredSize
rendContext
rect
.
x
rect
.
y
metrics
-
>
mBlockPrefSize
.
width
NS_UNCONSTRAINEDSIZE
)
;
metrics
-
>
mBlockMinSize
.
height
=
0
;
nsAutoLineIterator
lines
=
GetLineIterator
(
)
;
if
(
lines
)
{
metrics
-
>
mBlockMinSize
.
height
=
0
;
int
count
=
0
;
nsIFrame
*
firstFrame
=
nullptr
;
int32_t
framesOnLine
;
nsRect
lineBounds
;
do
{
lines
-
>
GetLine
(
count
&
firstFrame
&
framesOnLine
lineBounds
)
;
if
(
lineBounds
.
height
>
metrics
-
>
mBlockMinSize
.
height
)
metrics
-
>
mBlockMinSize
.
height
=
lineBounds
.
height
;
count
+
+
;
}
while
(
firstFrame
)
;
}
else
{
metrics
-
>
mBlockMinSize
.
height
=
desiredSize
.
Height
(
)
;
}
metrics
-
>
mBlockPrefSize
.
height
=
metrics
-
>
mBlockMinSize
.
height
;
if
(
desiredSize
.
BlockStartAscent
(
)
=
=
ReflowOutput
:
:
ASK_FOR_BASELINE
)
{
if
(
!
nsLayoutUtils
:
:
GetFirstLineBaseline
(
wm
this
&
metrics
-
>
mBlockAscent
)
)
metrics
-
>
mBlockAscent
=
GetLogicalBaseline
(
wm
)
;
}
else
{
metrics
-
>
mBlockAscent
=
desiredSize
.
BlockStartAscent
(
)
;
}
#
ifdef
DEBUG_adaptor
printf
(
"
min
=
(
%
d
%
d
)
pref
=
(
%
d
%
d
)
ascent
=
%
d
\
n
"
metrics
-
>
mBlockMinSize
.
width
metrics
-
>
mBlockMinSize
.
height
metrics
-
>
mBlockPrefSize
.
width
metrics
-
>
mBlockPrefSize
.
height
metrics
-
>
mBlockAscent
)
;
#
endif
}
return
NS_OK
;
}
nsILineIterator
*
nsFrame
:
:
GetLineIterator
(
)
{
return
nullptr
;
}
nsSize
nsFrame
:
:
GetXULPrefSize
(
nsBoxLayoutState
&
aState
)
{
nsSize
size
(
0
0
)
;
DISPLAY_PREF_SIZE
(
this
size
)
;
nsBoxLayoutMetrics
*
metrics
=
BoxMetrics
(
)
;
if
(
!
DoesNeedRecalc
(
metrics
-
>
mPrefSize
)
)
{
size
=
metrics
-
>
mPrefSize
;
return
size
;
}
if
(
IsXULCollapsed
(
)
)
return
size
;
bool
widthSet
heightSet
;
bool
completelyRedefined
=
nsIFrame
:
:
AddXULPrefSize
(
this
size
widthSet
heightSet
)
;
if
(
!
completelyRedefined
)
{
RefreshSizeCache
(
aState
)
;
nsSize
blockSize
=
metrics
-
>
mBlockPrefSize
;
if
(
!
widthSet
)
size
.
width
=
blockSize
.
width
;
if
(
!
heightSet
)
size
.
height
=
blockSize
.
height
;
}
metrics
-
>
mPrefSize
=
size
;
return
size
;
}
nsSize
nsFrame
:
:
GetXULMinSize
(
nsBoxLayoutState
&
aState
)
{
nsSize
size
(
0
0
)
;
DISPLAY_MIN_SIZE
(
this
size
)
;
nsBoxLayoutMetrics
*
metrics
=
BoxMetrics
(
)
;
if
(
!
DoesNeedRecalc
(
metrics
-
>
mMinSize
)
)
{
size
=
metrics
-
>
mMinSize
;
return
size
;
}
if
(
IsXULCollapsed
(
)
)
return
size
;
bool
widthSet
heightSet
;
bool
completelyRedefined
=
nsIFrame
:
:
AddXULMinSize
(
aState
this
size
widthSet
heightSet
)
;
if
(
!
completelyRedefined
)
{
RefreshSizeCache
(
aState
)
;
nsSize
blockSize
=
metrics
-
>
mBlockMinSize
;
if
(
!
widthSet
)
size
.
width
=
blockSize
.
width
;
if
(
!
heightSet
)
size
.
height
=
blockSize
.
height
;
}
metrics
-
>
mMinSize
=
size
;
return
size
;
}
nsSize
nsFrame
:
:
GetXULMaxSize
(
nsBoxLayoutState
&
aState
)
{
nsSize
size
(
NS_INTRINSICSIZE
NS_INTRINSICSIZE
)
;
DISPLAY_MAX_SIZE
(
this
size
)
;
nsBoxLayoutMetrics
*
metrics
=
BoxMetrics
(
)
;
if
(
!
DoesNeedRecalc
(
metrics
-
>
mMaxSize
)
)
{
size
=
metrics
-
>
mMaxSize
;
return
size
;
}
if
(
IsXULCollapsed
(
)
)
return
size
;
size
=
nsBox
:
:
GetXULMaxSize
(
aState
)
;
metrics
-
>
mMaxSize
=
size
;
return
size
;
}
nscoord
nsFrame
:
:
GetXULFlex
(
)
{
nsBoxLayoutMetrics
*
metrics
=
BoxMetrics
(
)
;
if
(
!
DoesNeedRecalc
(
metrics
-
>
mFlex
)
)
return
metrics
-
>
mFlex
;
metrics
-
>
mFlex
=
nsBox
:
:
GetXULFlex
(
)
;
return
metrics
-
>
mFlex
;
}
nscoord
nsFrame
:
:
GetXULBoxAscent
(
nsBoxLayoutState
&
aState
)
{
nsBoxLayoutMetrics
*
metrics
=
BoxMetrics
(
)
;
if
(
!
DoesNeedRecalc
(
metrics
-
>
mAscent
)
)
return
metrics
-
>
mAscent
;
if
(
IsXULCollapsed
(
)
)
{
metrics
-
>
mAscent
=
0
;
}
else
{
RefreshSizeCache
(
aState
)
;
metrics
-
>
mAscent
=
metrics
-
>
mBlockAscent
;
}
return
metrics
-
>
mAscent
;
}
nsresult
nsFrame
:
:
DoXULLayout
(
nsBoxLayoutState
&
aState
)
{
nsRect
ourRect
(
mRect
)
;
gfxContext
*
rendContext
=
aState
.
GetRenderingContext
(
)
;
nsPresContext
*
presContext
=
aState
.
PresContext
(
)
;
WritingMode
ourWM
=
GetWritingMode
(
)
;
const
WritingMode
outerWM
=
aState
.
OuterReflowInput
(
)
?
aState
.
OuterReflowInput
(
)
-
>
GetWritingMode
(
)
:
ourWM
;
ReflowOutput
desiredSize
(
outerWM
)
;
LogicalSize
ourSize
=
GetLogicalSize
(
outerWM
)
;
if
(
rendContext
)
{
BoxReflow
(
aState
presContext
desiredSize
rendContext
ourRect
.
x
ourRect
.
y
ourRect
.
width
ourRect
.
height
)
;
if
(
IsXULCollapsed
(
)
)
{
SetSize
(
nsSize
(
0
0
)
)
;
}
else
{
if
(
desiredSize
.
ISize
(
outerWM
)
>
ourSize
.
ISize
(
outerWM
)
|
|
desiredSize
.
BSize
(
outerWM
)
>
ourSize
.
BSize
(
outerWM
)
)
{
#
ifdef
DEBUG_GROW
XULDumpBox
(
stdout
)
;
printf
(
"
GREW
from
(
%
d
%
d
)
-
>
(
%
d
%
d
)
\
n
"
ourSize
.
ISize
(
outerWM
)
ourSize
.
BSize
(
outerWM
)
desiredSize
.
ISize
(
outerWM
)
desiredSize
.
BSize
(
outerWM
)
)
;
#
endif
if
(
desiredSize
.
ISize
(
outerWM
)
>
ourSize
.
ISize
(
outerWM
)
)
{
ourSize
.
ISize
(
outerWM
)
=
desiredSize
.
ISize
(
outerWM
)
;
}
if
(
desiredSize
.
BSize
(
outerWM
)
>
ourSize
.
BSize
(
outerWM
)
)
{
ourSize
.
BSize
(
outerWM
)
=
desiredSize
.
BSize
(
outerWM
)
;
}
}
SetSize
(
ourSize
.
ConvertTo
(
ourWM
outerWM
)
)
;
}
}
LogicalSize
size
(
GetLogicalSize
(
outerWM
)
)
;
desiredSize
.
ISize
(
outerWM
)
=
size
.
ISize
(
outerWM
)
;
desiredSize
.
BSize
(
outerWM
)
=
size
.
BSize
(
outerWM
)
;
desiredSize
.
UnionOverflowAreasWithDesiredBounds
(
)
;
if
(
HasAbsolutelyPositionedChildren
(
)
)
{
ReflowInput
reflowInput
(
aState
.
PresContext
(
)
this
aState
.
GetRenderingContext
(
)
LogicalSize
(
ourWM
ISize
(
)
NS_UNCONSTRAINEDSIZE
)
ReflowInput
:
:
DUMMY_PARENT_REFLOW_STATE
)
;
AddStateBits
(
NS_FRAME_IN_REFLOW
)
;
nsReflowStatus
reflowStatus
;
ReflowAbsoluteFrames
(
aState
.
PresContext
(
)
desiredSize
reflowInput
reflowStatus
)
;
RemoveStateBits
(
NS_FRAME_IN_REFLOW
)
;
}
nsSize
oldSize
(
ourRect
.
Size
(
)
)
;
FinishAndStoreOverflow
(
desiredSize
.
mOverflowAreas
size
.
GetPhysicalSize
(
outerWM
)
&
oldSize
)
;
SyncLayout
(
aState
)
;
return
NS_OK
;
}
void
nsFrame
:
:
BoxReflow
(
nsBoxLayoutState
&
aState
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
gfxContext
*
aRenderingContext
nscoord
aX
nscoord
aY
nscoord
aWidth
nscoord
aHeight
bool
aMoveFrame
)
{
DO_GLOBAL_REFLOW_COUNT
(
"
nsBoxToBlockAdaptor
"
)
;
#
ifdef
DEBUG_REFLOW
nsAdaptorAddIndents
(
)
;
printf
(
"
Reflowing
:
"
)
;
mFrame
-
>
ListTag
(
stdout
)
;
printf
(
"
\
n
"
)
;
gIndent2
+
+
;
#
endif
nsBoxLayoutMetrics
*
metrics
=
BoxMetrics
(
)
;
if
(
MOZ_UNLIKELY
(
!
metrics
)
)
{
MOZ_RELEASE_ASSERT
(
!
XRE_IsContentProcess
(
)
"
Starting
XUL
BoxReflow
w
/
o
BoxMetrics
(
in
content
)
?
"
)
;
MOZ_ASSERT_UNREACHABLE
(
"
Starting
XUL
BoxReflow
w
/
o
BoxMetrics
?
"
)
;
return
;
}
nsReflowStatus
status
;
WritingMode
wm
=
aDesiredSize
.
GetWritingMode
(
)
;
bool
needsReflow
=
NS_SUBTREE_DIRTY
(
this
)
;
if
(
!
needsReflow
)
{
if
(
aWidth
!
=
NS_INTRINSICSIZE
&
&
aHeight
!
=
NS_INTRINSICSIZE
)
{
if
(
(
metrics
-
>
mLastSize
.
width
=
=
0
|
|
metrics
-
>
mLastSize
.
height
=
=
0
)
&
&
(
aWidth
=
=
0
|
|
aHeight
=
=
0
)
)
{
needsReflow
=
false
;
aDesiredSize
.
Width
(
)
=
aWidth
;
aDesiredSize
.
Height
(
)
=
aHeight
;
SetSize
(
aDesiredSize
.
Size
(
wm
)
.
ConvertTo
(
GetWritingMode
(
)
wm
)
)
;
}
else
{
aDesiredSize
.
Width
(
)
=
metrics
-
>
mLastSize
.
width
;
aDesiredSize
.
Height
(
)
=
metrics
-
>
mLastSize
.
height
;
if
(
metrics
-
>
mLastSize
.
width
=
=
aWidth
&
&
metrics
-
>
mLastSize
.
height
=
=
aHeight
)
needsReflow
=
false
;
else
needsReflow
=
true
;
}
}
else
{
needsReflow
=
true
;
}
}
if
(
needsReflow
)
{
aDesiredSize
.
ClearSize
(
)
;
nsMargin
margin
(
0
0
0
0
)
;
GetXULMargin
(
margin
)
;
nsSize
parentSize
(
aWidth
aHeight
)
;
if
(
parentSize
.
height
!
=
NS_INTRINSICSIZE
)
parentSize
.
height
+
=
margin
.
TopBottom
(
)
;
if
(
parentSize
.
width
!
=
NS_INTRINSICSIZE
)
parentSize
.
width
+
=
margin
.
LeftRight
(
)
;
nsIFrame
*
parentFrame
=
GetParent
(
)
;
WritingMode
parentWM
=
parentFrame
-
>
GetWritingMode
(
)
;
ReflowInput
parentReflowInput
(
aPresContext
parentFrame
aRenderingContext
LogicalSize
(
parentWM
parentSize
)
ReflowInput
:
:
DUMMY_PARENT_REFLOW_STATE
)
;
if
(
parentSize
.
width
!
=
NS_INTRINSICSIZE
)
parentReflowInput
.
SetComputedWidth
(
std
:
:
max
(
parentSize
.
width
0
)
)
;
if
(
parentSize
.
height
!
=
NS_INTRINSICSIZE
)
parentReflowInput
.
SetComputedHeight
(
std
:
:
max
(
parentSize
.
height
0
)
)
;
parentReflowInput
.
ComputedPhysicalMargin
(
)
.
SizeTo
(
0
0
0
0
)
;
parentFrame
-
>
GetXULPadding
(
parentReflowInput
.
ComputedPhysicalPadding
(
)
)
;
parentFrame
-
>
GetXULBorder
(
parentReflowInput
.
ComputedPhysicalBorderPadding
(
)
)
;
parentReflowInput
.
ComputedPhysicalBorderPadding
(
)
+
=
parentReflowInput
.
ComputedPhysicalPadding
(
)
;
const
ReflowInput
*
outerReflowInput
=
aState
.
OuterReflowInput
(
)
;
NS_ASSERTION
(
!
outerReflowInput
|
|
outerReflowInput
-
>
mFrame
!
=
this
"
in
and
out
of
XUL
on
a
single
frame
?
"
)
;
const
ReflowInput
*
parentRI
;
if
(
outerReflowInput
&
&
outerReflowInput
-
>
mFrame
=
=
parentFrame
)
{
parentRI
=
outerReflowInput
;
}
else
{
parentRI
=
&
parentReflowInput
;
}
WritingMode
wm
=
GetWritingMode
(
)
;
LogicalSize
logicalSize
(
wm
nsSize
(
aWidth
aHeight
)
)
;
logicalSize
.
BSize
(
wm
)
=
NS_INTRINSICSIZE
;
ReflowInput
reflowInput
(
aPresContext
*
parentRI
this
logicalSize
nullptr
ReflowInput
:
:
DUMMY_PARENT_REFLOW_STATE
)
;
reflowInput
.
mCBReflowInput
=
parentRI
;
reflowInput
.
mReflowDepth
=
aState
.
GetReflowDepth
(
)
;
if
(
aWidth
!
=
NS_INTRINSICSIZE
)
{
nscoord
computedWidth
=
aWidth
-
reflowInput
.
ComputedPhysicalBorderPadding
(
)
.
LeftRight
(
)
;
computedWidth
=
std
:
:
max
(
computedWidth
0
)
;
reflowInput
.
SetComputedWidth
(
computedWidth
)
;
}
if
(
!
IsFrameOfType
(
eBlockFrame
)
)
{
if
(
aHeight
!
=
NS_INTRINSICSIZE
)
{
nscoord
computedHeight
=
aHeight
-
reflowInput
.
ComputedPhysicalBorderPadding
(
)
.
TopBottom
(
)
;
computedHeight
=
std
:
:
max
(
computedHeight
0
)
;
reflowInput
.
SetComputedHeight
(
computedHeight
)
;
}
else
{
reflowInput
.
SetComputedHeight
(
ComputeSize
(
aRenderingContext
wm
logicalSize
logicalSize
.
ISize
(
wm
)
reflowInput
.
ComputedLogicalMargin
(
)
.
Size
(
wm
)
reflowInput
.
ComputedLogicalBorderPadding
(
)
.
Size
(
wm
)
-
reflowInput
.
ComputedLogicalPadding
(
)
.
Size
(
wm
)
reflowInput
.
ComputedLogicalPadding
(
)
.
Size
(
wm
)
ComputeSizeFlags
:
:
eDefault
)
.
Height
(
wm
)
)
;
}
}
if
(
metrics
-
>
mLastSize
.
width
!
=
aWidth
)
{
reflowInput
.
SetHResize
(
true
)
;
if
(
nsLayoutUtils
:
:
FontSizeInflationEnabled
(
aPresContext
)
)
{
AddStateBits
(
NS_FRAME_IS_DIRTY
)
;
}
}
if
(
metrics
-
>
mLastSize
.
height
!
=
aHeight
)
{
reflowInput
.
SetVResize
(
true
)
;
}
#
ifdef
DEBUG_REFLOW
nsAdaptorAddIndents
(
)
;
printf
(
"
Size
=
(
%
d
%
d
)
\
n
"
reflowInput
.
ComputedWidth
(
)
reflowInput
.
ComputedHeight
(
)
)
;
nsAdaptorAddIndents
(
)
;
nsAdaptorPrintReason
(
reflowInput
)
;
printf
(
"
\
n
"
)
;
#
endif
Reflow
(
aPresContext
aDesiredSize
reflowInput
status
)
;
NS_ASSERTION
(
status
.
IsComplete
(
)
"
bad
status
"
)
;
uint32_t
layoutFlags
=
aState
.
LayoutFlags
(
)
;
nsContainerFrame
:
:
FinishReflowChild
(
this
aPresContext
aDesiredSize
&
reflowInput
aX
aY
layoutFlags
|
NS_FRAME_NO_MOVE_FRAME
)
;
if
(
IsXULCollapsed
(
)
)
{
metrics
-
>
mAscent
=
0
;
}
else
{
if
(
aDesiredSize
.
BlockStartAscent
(
)
=
=
ReflowOutput
:
:
ASK_FOR_BASELINE
)
{
if
(
!
nsLayoutUtils
:
:
GetFirstLineBaseline
(
wm
this
&
metrics
-
>
mAscent
)
)
metrics
-
>
mAscent
=
GetLogicalBaseline
(
wm
)
;
}
else
metrics
-
>
mAscent
=
aDesiredSize
.
BlockStartAscent
(
)
;
}
}
else
{
aDesiredSize
.
SetBlockStartAscent
(
metrics
-
>
mBlockAscent
)
;
}
#
ifdef
DEBUG_REFLOW
if
(
aHeight
!
=
NS_INTRINSICSIZE
&
&
aDesiredSize
.
Height
(
)
!
=
aHeight
)
{
nsAdaptorAddIndents
(
)
;
printf
(
"
*
*
*
*
*
got
taller
!
*
*
*
*
*
\
n
"
)
;
}
if
(
aWidth
!
=
NS_INTRINSICSIZE
&
&
aDesiredSize
.
Width
(
)
!
=
aWidth
)
{
nsAdaptorAddIndents
(
)
;
printf
(
"
*
*
*
*
*
got
wider
!
*
*
*
*
*
*
\
n
"
)
;
}
#
endif
if
(
aWidth
=
=
NS_INTRINSICSIZE
)
aWidth
=
aDesiredSize
.
Width
(
)
;
if
(
aHeight
=
=
NS_INTRINSICSIZE
)
aHeight
=
aDesiredSize
.
Height
(
)
;
metrics
-
>
mLastSize
.
width
=
aDesiredSize
.
Width
(
)
;
metrics
-
>
mLastSize
.
height
=
aDesiredSize
.
Height
(
)
;
#
ifdef
DEBUG_REFLOW
gIndent2
-
-
;
#
endif
}
nsBoxLayoutMetrics
*
nsFrame
:
:
BoxMetrics
(
)
const
{
nsBoxLayoutMetrics
*
metrics
=
GetProperty
(
BoxMetricsProperty
(
)
)
;
NS_ASSERTION
(
metrics
"
A
box
layout
method
was
called
but
InitBoxMetrics
was
never
called
"
)
;
return
metrics
;
}
void
nsIFrame
:
:
UpdateStyleOfChildAnonBox
(
nsIFrame
*
aChildFrame
ServoRestyleState
&
aRestyleState
)
{
#
ifdef
DEBUG
nsIFrame
*
parent
=
aChildFrame
-
>
GetInFlowParent
(
)
;
if
(
aChildFrame
-
>
IsTableFrame
(
)
)
{
parent
=
parent
-
>
GetParent
(
)
;
}
if
(
parent
-
>
IsLineFrame
(
)
)
{
parent
=
parent
-
>
GetParent
(
)
;
}
MOZ_ASSERT
(
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
parent
)
=
=
this
"
This
should
only
be
used
for
children
!
"
)
;
#
endif
MOZ_ASSERT
(
!
GetContent
(
)
|
|
!
aChildFrame
-
>
GetContent
(
)
|
|
aChildFrame
-
>
GetContent
(
)
=
=
GetContent
(
)
"
What
content
node
is
it
a
frame
for
?
"
)
;
MOZ_ASSERT
(
!
aChildFrame
-
>
GetPrevContinuation
(
)
"
Only
first
continuations
should
end
up
here
"
)
;
nsAtom
*
pseudo
=
aChildFrame
-
>
Style
(
)
-
>
GetPseudo
(
)
;
MOZ_ASSERT
(
nsCSSAnonBoxes
:
:
IsAnonBox
(
pseudo
)
"
Child
is
not
an
anon
box
?
"
)
;
MOZ_ASSERT
(
!
nsCSSAnonBoxes
:
:
IsNonInheritingAnonBox
(
pseudo
)
"
Why
did
the
caller
bother
calling
us
?
"
)
;
RefPtr
<
ComputedStyle
>
newContext
=
aRestyleState
.
StyleSet
(
)
.
ResolveInheritingAnonymousBoxStyle
(
pseudo
Style
(
)
)
;
nsChangeHint
childHint
=
UpdateStyleOfOwnedChildFrame
(
aChildFrame
newContext
aRestyleState
)
;
ServoRestyleState
childrenState
(
*
aChildFrame
aRestyleState
childHint
ServoRestyleState
:
:
Type
:
:
InFlow
)
;
aChildFrame
-
>
UpdateStyleOfOwnedAnonBoxes
(
childrenState
)
;
if
(
aChildFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eBlockFrame
)
)
{
auto
block
=
static_cast
<
nsBlockFrame
*
>
(
aChildFrame
)
;
block
-
>
UpdatePseudoElementStyles
(
childrenState
)
;
}
}
nsChangeHint
nsIFrame
:
:
UpdateStyleOfOwnedChildFrame
(
nsIFrame
*
aChildFrame
ComputedStyle
*
aNewComputedStyle
ServoRestyleState
&
aRestyleState
const
Maybe
<
ComputedStyle
*
>
&
aContinuationComputedStyle
)
{
MOZ_ASSERT
(
!
aChildFrame
-
>
GetAdditionalComputedStyle
(
0
)
"
We
don
'
t
handle
additional
styles
here
"
)
;
uint32_t
equalStructs
;
nsChangeHint
childHint
=
aChildFrame
-
>
Style
(
)
-
>
CalcStyleDifference
(
*
aNewComputedStyle
&
equalStructs
)
;
if
(
!
aChildFrame
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
)
{
childHint
=
NS_RemoveSubsumedHints
(
childHint
aRestyleState
.
ChangesHandledFor
(
aChildFrame
)
)
;
}
if
(
childHint
)
{
if
(
childHint
&
nsChangeHint_ReconstructFrame
)
{
aRestyleState
.
ChangeList
(
)
.
PopChangesForContent
(
aChildFrame
-
>
GetContent
(
)
)
;
}
aRestyleState
.
ChangeList
(
)
.
AppendChange
(
aChildFrame
aChildFrame
-
>
GetContent
(
)
childHint
)
;
}
aChildFrame
-
>
SetComputedStyle
(
aNewComputedStyle
)
;
ComputedStyle
*
continuationStyle
=
aContinuationComputedStyle
?
*
aContinuationComputedStyle
:
aNewComputedStyle
;
for
(
nsIFrame
*
kid
=
aChildFrame
-
>
GetNextContinuation
(
)
;
kid
;
kid
=
kid
-
>
GetNextContinuation
(
)
)
{
MOZ_ASSERT
(
!
kid
-
>
GetAdditionalComputedStyle
(
0
)
)
;
kid
-
>
SetComputedStyle
(
continuationStyle
)
;
}
return
childHint
;
}
void
nsIFrame
:
:
AddInPopupStateBitToDescendants
(
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_IN_POPUP
)
&
&
aFrame
-
>
TrackingVisibility
(
)
)
{
aFrame
-
>
IncApproximateVisibleCount
(
)
;
}
aFrame
-
>
AddStateBits
(
NS_FRAME_IN_POPUP
)
;
AutoTArray
<
nsIFrame
:
:
ChildList
4
>
childListArray
;
aFrame
-
>
GetCrossDocChildLists
(
&
childListArray
)
;
nsIFrame
:
:
ChildListArrayIterator
lists
(
childListArray
)
;
for
(
;
!
lists
.
IsDone
(
)
;
lists
.
Next
(
)
)
{
nsFrameList
:
:
Enumerator
childFrames
(
lists
.
CurrentList
(
)
)
;
for
(
;
!
childFrames
.
AtEnd
(
)
;
childFrames
.
Next
(
)
)
{
AddInPopupStateBitToDescendants
(
childFrames
.
get
(
)
)
;
}
}
}
void
nsIFrame
:
:
RemoveInPopupStateBitFromDescendants
(
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_IN_POPUP
)
|
|
nsLayoutUtils
:
:
IsPopup
(
aFrame
)
)
{
return
;
}
aFrame
-
>
RemoveStateBits
(
NS_FRAME_IN_POPUP
)
;
if
(
aFrame
-
>
TrackingVisibility
(
)
)
{
aFrame
-
>
DecApproximateVisibleCount
(
)
;
}
AutoTArray
<
nsIFrame
:
:
ChildList
4
>
childListArray
;
aFrame
-
>
GetCrossDocChildLists
(
&
childListArray
)
;
nsIFrame
:
:
ChildListArrayIterator
lists
(
childListArray
)
;
for
(
;
!
lists
.
IsDone
(
)
;
lists
.
Next
(
)
)
{
nsFrameList
:
:
Enumerator
childFrames
(
lists
.
CurrentList
(
)
)
;
for
(
;
!
childFrames
.
AtEnd
(
)
;
childFrames
.
Next
(
)
)
{
RemoveInPopupStateBitFromDescendants
(
childFrames
.
get
(
)
)
;
}
}
}
void
nsIFrame
:
:
SetParent
(
nsContainerFrame
*
aParent
)
{
MOZ_ASSERT_IF
(
ParentIsWrapperAnonBox
(
)
aParent
-
>
Style
(
)
-
>
IsInheritingAnonBox
(
)
)
;
mParent
=
aParent
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mParent
|
|
PresShell
(
)
=
=
mParent
-
>
PresShell
(
)
)
;
if
(
:
:
IsXULBoxWrapped
(
this
)
)
{
:
:
InitBoxMetrics
(
this
true
)
;
}
else
{
}
if
(
GetStateBits
(
)
&
(
NS_FRAME_HAS_VIEW
|
NS_FRAME_HAS_CHILD_WITH_VIEW
)
)
{
for
(
nsIFrame
*
f
=
aParent
;
f
&
&
!
(
f
-
>
GetStateBits
(
)
&
NS_FRAME_HAS_CHILD_WITH_VIEW
)
;
f
=
f
-
>
GetParent
(
)
)
{
f
-
>
AddStateBits
(
NS_FRAME_HAS_CHILD_WITH_VIEW
)
;
}
}
if
(
HasAnyStateBits
(
NS_FRAME_CONTAINS_RELATIVE_BSIZE
)
)
{
for
(
nsIFrame
*
f
=
aParent
;
f
;
f
=
f
-
>
GetParent
(
)
)
{
if
(
f
-
>
HasAnyStateBits
(
NS_FRAME_CONTAINS_RELATIVE_BSIZE
)
)
{
break
;
}
f
-
>
AddStateBits
(
NS_FRAME_CONTAINS_RELATIVE_BSIZE
)
;
}
}
if
(
HasAnyStateBits
(
NS_FRAME_DESCENDANT_INTRINSIC_ISIZE_DEPENDS_ON_BSIZE
)
)
{
for
(
nsIFrame
*
f
=
aParent
;
f
;
f
=
f
-
>
GetParent
(
)
)
{
if
(
f
-
>
HasAnyStateBits
(
NS_FRAME_DESCENDANT_INTRINSIC_ISIZE_DEPENDS_ON_BSIZE
)
)
{
break
;
}
f
-
>
AddStateBits
(
NS_FRAME_DESCENDANT_INTRINSIC_ISIZE_DEPENDS_ON_BSIZE
)
;
}
}
if
(
HasInvalidFrameInSubtree
(
)
)
{
for
(
nsIFrame
*
f
=
aParent
;
f
&
&
!
f
-
>
HasAnyStateBits
(
NS_FRAME_DESCENDANT_NEEDS_PAINT
|
NS_FRAME_IS_NONDISPLAY
)
;
f
=
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
f
)
)
{
f
-
>
AddStateBits
(
NS_FRAME_DESCENDANT_NEEDS_PAINT
)
;
}
}
if
(
aParent
-
>
HasAnyStateBits
(
NS_FRAME_IN_POPUP
)
)
{
AddInPopupStateBitToDescendants
(
this
)
;
}
else
{
RemoveInPopupStateBitFromDescendants
(
this
)
;
}
if
(
aParent
-
>
HasAnyStateBits
(
NS_FRAME_ALL_DESCENDANTS_NEED_PAINT
)
)
{
InvalidateFrame
(
)
;
}
else
{
SchedulePaint
(
)
;
}
}
void
nsIFrame
:
:
CreateOwnLayerIfNeeded
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
bool
*
aCreatedContainerItem
)
{
if
(
GetContent
(
)
&
&
GetContent
(
)
-
>
IsXULElement
(
)
&
&
GetContent
(
)
-
>
AsElement
(
)
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
layer
)
)
{
aList
-
>
AppendToTop
(
MakeDisplayItem
<
nsDisplayOwnLayer
>
(
aBuilder
this
aList
aBuilder
-
>
CurrentActiveScrolledRoot
(
)
)
)
;
if
(
aCreatedContainerItem
)
{
*
aCreatedContainerItem
=
true
;
}
}
}
bool
nsIFrame
:
:
IsStackingContext
(
const
nsStyleDisplay
*
aStyleDisplay
const
nsStylePosition
*
aStylePosition
const
nsStyleEffects
*
aStyleEffects
bool
aIsPositioned
)
{
return
HasOpacity
(
aStyleDisplay
aStyleEffects
nullptr
)
|
|
IsTransformed
(
aStyleDisplay
)
|
|
(
IsFrameOfType
(
eSupportsContainLayoutAndPaint
)
&
&
(
aStyleDisplay
-
>
IsContainPaint
(
)
|
|
aStyleDisplay
-
>
IsContainLayout
(
)
)
)
|
|
ChildrenHavePerspective
(
aStyleDisplay
)
|
|
aStyleEffects
-
>
mMixBlendMode
!
=
NS_STYLE_BLEND_NORMAL
|
|
nsSVGIntegrationUtils
:
:
UsingEffectsForFrame
(
this
)
|
|
(
aIsPositioned
&
&
(
aStyleDisplay
-
>
IsPositionForcingStackingContext
(
)
|
|
aStylePosition
-
>
mZIndex
.
GetUnit
(
)
=
=
eStyleUnit_Integer
)
)
|
|
(
aStyleDisplay
-
>
mWillChangeBitField
&
NS_STYLE_WILL_CHANGE_STACKING_CONTEXT
)
|
|
aStyleDisplay
-
>
mIsolation
!
=
NS_STYLE_ISOLATION_AUTO
;
}
bool
nsIFrame
:
:
IsStackingContext
(
)
{
const
nsStyleDisplay
*
disp
=
StyleDisplay
(
)
;
const
bool
isPositioned
=
disp
-
>
IsAbsPosContainingBlock
(
this
)
;
return
IsStackingContext
(
disp
StylePosition
(
)
StyleEffects
(
)
isPositioned
)
;
}
static
bool
IsFrameScrolledOutOfView
(
const
nsIFrame
*
aTarget
const
nsRect
&
aTargetRect
const
nsIFrame
*
aParent
)
{
nsIScrollableFrame
*
scrollableFrame
=
nsLayoutUtils
:
:
GetNearestScrollableFrame
(
const_cast
<
nsIFrame
*
>
(
aParent
)
nsLayoutUtils
:
:
SCROLLABLE_FIXEDPOS_FINDS_ROOT
|
nsLayoutUtils
:
:
SCROLLABLE_INCLUDE_HIDDEN
)
;
if
(
!
scrollableFrame
)
{
return
false
;
}
nsIFrame
*
scrollableParent
=
do_QueryFrame
(
scrollableFrame
)
;
nsRect
scrollableRect
=
scrollableParent
-
>
GetVisualOverflowRectRelativeToSelf
(
)
;
if
(
scrollableRect
.
IsEmpty
(
)
)
{
return
true
;
}
nsRect
transformedRect
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
aTarget
aTargetRect
scrollableParent
)
;
if
(
transformedRect
.
IsEmpty
(
)
)
{
if
(
transformedRect
.
x
>
scrollableRect
.
XMost
(
)
|
|
transformedRect
.
y
>
scrollableRect
.
YMost
(
)
|
|
scrollableRect
.
x
>
transformedRect
.
XMost
(
)
|
|
scrollableRect
.
y
>
transformedRect
.
YMost
(
)
)
{
return
true
;
}
}
else
if
(
!
transformedRect
.
Intersects
(
scrollableRect
)
)
{
return
true
;
}
nsIFrame
*
parent
=
scrollableParent
-
>
GetParent
(
)
;
if
(
!
parent
)
{
return
false
;
}
return
IsFrameScrolledOutOfView
(
aTarget
aTargetRect
parent
)
;
}
bool
nsIFrame
:
:
IsScrolledOutOfView
(
)
const
{
nsRect
rect
=
GetVisualOverflowRectRelativeToSelf
(
)
;
return
IsFrameScrolledOutOfView
(
this
rect
this
)
;
}
gfx
:
:
Matrix
nsIFrame
:
:
ComputeWidgetTransform
(
)
{
const
nsStyleUIReset
*
uiReset
=
StyleUIReset
(
)
;
if
(
!
uiReset
-
>
mSpecifiedWindowTransform
)
{
return
gfx
:
:
Matrix
(
)
;
}
nsStyleTransformMatrix
:
:
TransformReferenceBox
refBox
;
refBox
.
Init
(
GetSize
(
)
)
;
nsPresContext
*
presContext
=
PresContext
(
)
;
int32_t
appUnitsPerDevPixel
=
presContext
-
>
AppUnitsPerDevPixel
(
)
;
gfx
:
:
Matrix4x4
matrix
=
nsStyleTransformMatrix
:
:
ReadTransforms
(
uiReset
-
>
mSpecifiedWindowTransform
-
>
mHead
refBox
float
(
appUnitsPerDevPixel
)
)
;
Point
transformOrigin
=
nsStyleTransformMatrix
:
:
Convert2DPosition
(
uiReset
-
>
mWindowTransformOrigin
refBox
appUnitsPerDevPixel
)
;
matrix
.
ChangeBasis
(
Point3D
(
transformOrigin
.
x
transformOrigin
.
y
0
)
)
;
gfx
:
:
Matrix
result2d
;
if
(
!
matrix
.
CanDraw2D
(
&
result2d
)
)
{
NS_WARNING
(
"
-
moz
-
window
-
transform
does
not
describe
a
2D
transform
"
"
but
only
2d
transforms
are
supported
"
)
;
return
gfx
:
:
Matrix
(
)
;
}
return
result2d
;
}
static
already_AddRefed
<
nsIWidget
>
GetWindowWidget
(
nsPresContext
*
aPresContext
)
{
nsCOMPtr
<
nsISupports
>
container
=
aPresContext
-
>
Document
(
)
-
>
GetContainer
(
)
;
nsCOMPtr
<
nsIBaseWindow
>
baseWindow
=
do_QueryInterface
(
container
)
;
if
(
!
baseWindow
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIWidget
>
mainWidget
;
baseWindow
-
>
GetMainWidget
(
getter_AddRefs
(
mainWidget
)
)
;
return
mainWidget
.
forget
(
)
;
}
void
nsIFrame
:
:
UpdateWidgetProperties
(
)
{
nsPresContext
*
presContext
=
PresContext
(
)
;
if
(
presContext
-
>
IsRoot
(
)
|
|
!
presContext
-
>
IsChrome
(
)
)
{
return
;
}
nsIFrame
*
rootFrame
=
presContext
-
>
FrameConstructor
(
)
-
>
GetRootElementStyleFrame
(
)
;
if
(
this
!
=
rootFrame
)
{
return
;
}
if
(
nsCOMPtr
<
nsIWidget
>
widget
=
GetWindowWidget
(
presContext
)
)
{
widget
-
>
SetWindowOpacity
(
StyleUIReset
(
)
-
>
mWindowOpacity
)
;
widget
-
>
SetWindowTransform
(
ComputeWidgetTransform
(
)
)
;
}
}
void
nsIFrame
:
:
DoUpdateStyleOfOwnedAnonBoxes
(
ServoRestyleState
&
aRestyleState
)
{
if
(
IsInlineFrame
(
)
)
{
if
(
(
GetStateBits
(
)
&
NS_FRAME_PART_OF_IBSPLIT
)
)
{
static_cast
<
nsInlineFrame
*
>
(
this
)
-
>
UpdateStyleOfOwnedAnonBoxesForIBSplit
(
aRestyleState
)
;
}
return
;
}
AutoTArray
<
OwnedAnonBox
4
>
frames
;
AppendDirectlyOwnedAnonBoxes
(
frames
)
;
for
(
OwnedAnonBox
&
box
:
frames
)
{
if
(
box
.
mUpdateStyleFn
)
{
box
.
mUpdateStyleFn
(
this
box
.
mAnonBoxFrame
aRestyleState
)
;
}
else
{
UpdateStyleOfChildAnonBox
(
box
.
mAnonBoxFrame
aRestyleState
)
;
}
}
}
void
nsIFrame
:
:
AppendDirectlyOwnedAnonBoxes
(
nsTArray
<
OwnedAnonBox
>
&
aResult
)
{
MOZ_ASSERT
(
!
(
GetStateBits
(
)
&
NS_FRAME_OWNS_ANON_BOXES
)
)
;
MOZ_ASSERT
(
false
"
Why
did
this
get
called
?
"
)
;
}
void
nsIFrame
:
:
DoAppendOwnedAnonBoxes
(
nsTArray
<
OwnedAnonBox
>
&
aResult
)
{
size_t
i
=
aResult
.
Length
(
)
;
AppendDirectlyOwnedAnonBoxes
(
aResult
)
;
while
(
i
<
aResult
.
Length
(
)
)
{
nsIFrame
*
f
=
aResult
[
i
]
.
mAnonBoxFrame
;
if
(
f
-
>
GetStateBits
(
)
&
NS_FRAME_OWNS_ANON_BOXES
)
{
f
-
>
AppendDirectlyOwnedAnonBoxes
(
aResult
)
;
}
+
+
i
;
}
}
nsIFrame
:
:
CaretPosition
:
:
CaretPosition
(
)
:
mContentOffset
(
0
)
{
}
nsIFrame
:
:
CaretPosition
:
:
~
CaretPosition
(
)
{
}
bool
nsFrame
:
:
HasCSSAnimations
(
)
{
auto
collection
=
AnimationCollection
<
CSSAnimation
>
:
:
GetAnimationCollection
(
this
)
;
return
collection
&
&
collection
-
>
mAnimations
.
Length
(
)
>
0
;
}
bool
nsFrame
:
:
HasCSSTransitions
(
)
{
auto
collection
=
AnimationCollection
<
CSSTransition
>
:
:
GetAnimationCollection
(
this
)
;
return
collection
&
&
collection
-
>
mAnimations
.
Length
(
)
>
0
;
}
void
nsIFrame
:
:
AddSizeOfExcludingThisForTree
(
nsWindowSizes
&
aSizes
)
const
{
aSizes
.
mLayoutFramePropertiesSize
+
=
mProperties
.
SizeOfExcludingThis
(
aSizes
.
mState
.
mMallocSizeOf
)
;
if
(
!
aSizes
.
mState
.
HaveSeenPtr
(
mComputedStyle
)
)
{
mComputedStyle
-
>
AddSizeOfIncludingThis
(
aSizes
&
aSizes
.
mLayoutComputedValuesNonDom
)
;
}
int32_t
index
=
0
;
while
(
auto
*
extra
=
GetAdditionalComputedStyle
(
index
+
+
)
)
{
if
(
!
aSizes
.
mState
.
HaveSeenPtr
(
extra
)
)
{
extra
-
>
AddSizeOfIncludingThis
(
aSizes
&
aSizes
.
mLayoutComputedValuesNonDom
)
;
}
}
FrameChildListIterator
iter
(
this
)
;
while
(
!
iter
.
IsDone
(
)
)
{
for
(
const
nsIFrame
*
f
:
iter
.
CurrentList
(
)
)
{
f
-
>
AddSizeOfExcludingThisForTree
(
aSizes
)
;
}
iter
.
Next
(
)
;
}
}
nsRect
nsIFrame
:
:
GetCompositorHitTestArea
(
nsDisplayListBuilder
*
aBuilder
)
{
nsRect
area
;
nsIScrollableFrame
*
scrollFrame
=
nsLayoutUtils
:
:
GetScrollableFrameFor
(
this
)
;
if
(
scrollFrame
)
{
area
=
GetScrollableOverflowRect
(
)
;
}
else
{
area
=
nsRect
(
nsPoint
(
0
0
)
GetSize
(
)
)
;
}
if
(
!
area
.
IsEmpty
(
)
)
{
return
area
+
aBuilder
-
>
ToReferenceFrame
(
this
)
;
}
return
area
;
}
CompositorHitTestInfo
nsIFrame
:
:
GetCompositorHitTestInfo
(
nsDisplayListBuilder
*
aBuilder
)
{
CompositorHitTestInfo
result
=
CompositorHitTestInvisibleToHit
;
if
(
aBuilder
-
>
IsInsidePointerEventsNoneDoc
(
)
)
{
return
result
;
}
if
(
!
GetParent
(
)
)
{
MOZ_ASSERT
(
IsViewportFrame
(
)
)
;
return
result
;
}
const
uint8_t
pointerEvents
=
StyleUI
(
)
-
>
GetEffectivePointerEvents
(
this
)
;
if
(
pointerEvents
=
=
NS_STYLE_POINTER_EVENTS_NONE
)
{
return
result
;
}
if
(
!
StyleVisibility
(
)
-
>
IsVisible
(
)
)
{
return
result
;
}
result
=
CompositorHitTestFlags
:
:
eVisibleToHitTest
;
if
(
aBuilder
-
>
IsBuildingNonLayerizedScrollbar
(
)
|
|
aBuilder
-
>
GetAncestorHasApzAwareEventHandler
(
)
)
{
result
+
=
CompositorHitTestFlags
:
:
eDispatchToContent
;
}
else
if
(
IsObjectFrame
(
)
)
{
nsPluginFrame
*
pluginFrame
=
do_QueryFrame
(
this
)
;
if
(
pluginFrame
&
&
pluginFrame
-
>
WantsToHandleWheelEventAsDefaultAction
(
)
)
{
result
+
=
CompositorHitTestFlags
:
:
eDispatchToContent
;
}
}
nsIDocShell
*
docShell
=
nullptr
;
if
(
PresShell
(
)
-
>
GetDocument
(
)
)
{
docShell
=
PresShell
(
)
-
>
GetDocument
(
)
-
>
GetDocShell
(
)
;
}
if
(
dom
:
:
TouchEvent
:
:
PrefEnabled
(
docShell
)
)
{
CompositorHitTestInfo
inheritedTouchAction
=
aBuilder
-
>
GetHitTestInfo
(
)
&
CompositorHitTestTouchActionMask
;
nsIFrame
*
touchActionFrame
=
this
;
if
(
nsIScrollableFrame
*
scrollFrame
=
nsLayoutUtils
:
:
GetScrollableFrameFor
(
this
)
)
{
touchActionFrame
=
do_QueryFrame
(
scrollFrame
)
;
CompositorHitTestInfo
panMask
(
CompositorHitTestFlags
:
:
eTouchActionPanXDisabled
CompositorHitTestFlags
:
:
eTouchActionPanYDisabled
)
;
inheritedTouchAction
-
=
panMask
;
}
result
+
=
inheritedTouchAction
;
const
uint32_t
touchAction
=
nsLayoutUtils
:
:
GetTouchActionFromFrame
(
touchActionFrame
)
;
if
(
touchAction
=
=
NS_STYLE_TOUCH_ACTION_AUTO
)
{
}
else
if
(
touchAction
&
NS_STYLE_TOUCH_ACTION_MANIPULATION
)
{
result
+
=
CompositorHitTestFlags
:
:
eTouchActionDoubleTapZoomDisabled
;
}
else
{
result
+
=
CompositorHitTestFlags
:
:
eTouchActionPinchZoomDisabled
;
result
+
=
CompositorHitTestFlags
:
:
eTouchActionDoubleTapZoomDisabled
;
if
(
!
(
touchAction
&
NS_STYLE_TOUCH_ACTION_PAN_X
)
)
{
result
+
=
CompositorHitTestFlags
:
:
eTouchActionPanXDisabled
;
}
if
(
!
(
touchAction
&
NS_STYLE_TOUCH_ACTION_PAN_Y
)
)
{
result
+
=
CompositorHitTestFlags
:
:
eTouchActionPanYDisabled
;
}
if
(
touchAction
&
NS_STYLE_TOUCH_ACTION_NONE
)
{
MOZ_ASSERT
(
result
.
contains
(
CompositorHitTestTouchActionMask
)
)
;
}
}
}
const
Maybe
<
ScrollDirection
>
scrollDirection
=
aBuilder
-
>
GetCurrentScrollbarDirection
(
)
;
if
(
scrollDirection
.
isSome
(
)
)
{
if
(
GetContent
(
)
-
>
IsXULElement
(
nsGkAtoms
:
:
thumb
)
)
{
const
bool
thumbGetsLayer
=
aBuilder
-
>
GetCurrentScrollbarTarget
(
)
!
=
layers
:
:
ScrollableLayerGuid
:
:
NULL_SCROLL_ID
;
if
(
thumbGetsLayer
)
{
result
+
=
CompositorHitTestFlags
:
:
eScrollbarThumb
;
}
else
{
result
+
=
CompositorHitTestFlags
:
:
eDispatchToContent
;
}
}
if
(
*
scrollDirection
=
=
ScrollDirection
:
:
eVertical
)
{
result
+
=
CompositorHitTestFlags
:
:
eScrollbarVertical
;
}
result
+
=
CompositorHitTestFlags
:
:
eScrollbar
;
}
return
result
;
}
static
bool
HasNoVisibleDescendants
(
const
nsIFrame
*
aFrame
)
{
for
(
nsIFrame
:
:
ChildListIterator
lists
(
aFrame
)
;
!
lists
.
IsDone
(
)
;
lists
.
Next
(
)
)
{
for
(
nsIFrame
*
f
:
lists
.
CurrentList
(
)
)
{
if
(
nsPlaceholderFrame
:
:
GetRealFrameFor
(
f
)
-
>
IsVisibleOrMayHaveVisibleDescendants
(
)
)
{
return
false
;
}
}
}
return
true
;
}
void
nsIFrame
:
:
UpdateVisibleDescendantsState
(
)
{
if
(
StyleVisibility
(
)
-
>
IsVisible
(
)
)
{
nsIFrame
*
ancestor
;
for
(
ancestor
=
GetInFlowParent
(
)
;
ancestor
&
&
!
ancestor
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
;
ancestor
=
ancestor
-
>
GetInFlowParent
(
)
)
{
ancestor
-
>
mAllDescendantsAreInvisible
=
false
;
}
}
else
{
mAllDescendantsAreInvisible
=
HasNoVisibleDescendants
(
this
)
;
}
}
#
ifdef
DEBUG_REFLOW
int32_t
gIndent2
=
0
;
void
nsAdaptorAddIndents
(
)
{
for
(
int32_t
i
=
0
;
i
<
gIndent2
;
i
+
+
)
{
printf
(
"
"
)
;
}
}
void
nsAdaptorPrintReason
(
ReflowInput
&
aReflowInput
)
{
char
*
reflowReasonString
;
switch
(
aReflowInput
.
reason
)
{
case
eReflowReason_Initial
:
reflowReasonString
=
"
initial
"
;
break
;
case
eReflowReason_Resize
:
reflowReasonString
=
"
resize
"
;
break
;
case
eReflowReason_Dirty
:
reflowReasonString
=
"
dirty
"
;
break
;
case
eReflowReason_StyleChange
:
reflowReasonString
=
"
stylechange
"
;
break
;
case
eReflowReason_Incremental
:
{
switch
(
aReflowInput
.
reflowCommand
-
>
Type
(
)
)
{
case
eReflowType_StyleChanged
:
reflowReasonString
=
"
incremental
(
StyleChanged
)
"
;
break
;
case
eReflowType_ReflowDirty
:
reflowReasonString
=
"
incremental
(
ReflowDirty
)
"
;
break
;
default
:
reflowReasonString
=
"
incremental
(
Unknown
)
"
;
}
}
break
;
default
:
reflowReasonString
=
"
unknown
"
;
break
;
}
printf
(
"
%
s
"
reflowReasonString
)
;
}
#
endif
#
ifdef
DEBUG
static
void
GetTagName
(
nsFrame
*
aFrame
nsIContent
*
aContent
int
aResultSize
char
*
aResult
)
{
if
(
aContent
)
{
snprintf
(
aResult
aResultSize
"
%
s
%
p
"
nsAtomCString
(
aContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
.
get
(
)
aFrame
)
;
}
else
{
snprintf
(
aResult
aResultSize
"
%
p
"
aFrame
)
;
}
}
void
nsFrame
:
:
Trace
(
const
char
*
aMethod
bool
aEnter
)
{
if
(
NS_FRAME_LOG_TEST
(
sFrameLogModule
NS_FRAME_TRACE_CALLS
)
)
{
char
tagbuf
[
40
]
;
GetTagName
(
this
mContent
sizeof
(
tagbuf
)
tagbuf
)
;
printf_stderr
(
"
%
s
:
%
s
%
s
"
tagbuf
aEnter
?
"
enter
"
:
"
exit
"
aMethod
)
;
}
}
void
nsFrame
:
:
Trace
(
const
char
*
aMethod
bool
aEnter
const
nsReflowStatus
&
aStatus
)
{
if
(
NS_FRAME_LOG_TEST
(
sFrameLogModule
NS_FRAME_TRACE_CALLS
)
)
{
char
tagbuf
[
40
]
;
GetTagName
(
this
mContent
sizeof
(
tagbuf
)
tagbuf
)
;
printf_stderr
(
"
%
s
:
%
s
%
s
status
=
%
scomplete
%
s
"
tagbuf
aEnter
?
"
enter
"
:
"
exit
"
aMethod
aStatus
.
IsIncomplete
(
)
?
"
not
"
:
"
"
(
aStatus
.
NextInFlowNeedsReflow
(
)
)
?
"
+
reflow
"
:
"
"
)
;
}
}
void
nsFrame
:
:
TraceMsg
(
const
char
*
aFormatString
.
.
.
)
{
if
(
NS_FRAME_LOG_TEST
(
sFrameLogModule
NS_FRAME_TRACE_CALLS
)
)
{
char
argbuf
[
200
]
;
va_list
ap
;
va_start
(
ap
aFormatString
)
;
VsprintfLiteral
(
argbuf
aFormatString
ap
)
;
va_end
(
ap
)
;
char
tagbuf
[
40
]
;
GetTagName
(
this
mContent
sizeof
(
tagbuf
)
tagbuf
)
;
printf_stderr
(
"
%
s
:
%
s
"
tagbuf
argbuf
)
;
}
}
void
nsFrame
:
:
VerifyDirtyBitSet
(
const
nsFrameList
&
aFrameList
)
{
for
(
nsFrameList
:
:
Enumerator
e
(
aFrameList
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
)
{
NS_ASSERTION
(
e
.
get
(
)
-
>
GetStateBits
(
)
&
NS_FRAME_IS_DIRTY
"
dirty
bit
not
set
"
)
;
}
}
#
ifdef
DEBUG
DR_cookie
:
:
DR_cookie
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
const
ReflowInput
&
aReflowInput
ReflowOutput
&
aMetrics
nsReflowStatus
&
aStatus
)
:
mPresContext
(
aPresContext
)
mFrame
(
aFrame
)
mReflowInput
(
aReflowInput
)
mMetrics
(
aMetrics
)
mStatus
(
aStatus
)
{
MOZ_COUNT_CTOR
(
DR_cookie
)
;
mValue
=
nsFrame
:
:
DisplayReflowEnter
(
aPresContext
mFrame
mReflowInput
)
;
}
DR_cookie
:
:
~
DR_cookie
(
)
{
MOZ_COUNT_DTOR
(
DR_cookie
)
;
nsFrame
:
:
DisplayReflowExit
(
mPresContext
mFrame
mMetrics
mStatus
mValue
)
;
}
DR_layout_cookie
:
:
DR_layout_cookie
(
nsIFrame
*
aFrame
)
:
mFrame
(
aFrame
)
{
MOZ_COUNT_CTOR
(
DR_layout_cookie
)
;
mValue
=
nsFrame
:
:
DisplayLayoutEnter
(
mFrame
)
;
}
DR_layout_cookie
:
:
~
DR_layout_cookie
(
)
{
MOZ_COUNT_DTOR
(
DR_layout_cookie
)
;
nsFrame
:
:
DisplayLayoutExit
(
mFrame
mValue
)
;
}
DR_intrinsic_inline_size_cookie
:
:
DR_intrinsic_inline_size_cookie
(
nsIFrame
*
aFrame
const
char
*
aType
nscoord
&
aResult
)
:
mFrame
(
aFrame
)
mType
(
aType
)
mResult
(
aResult
)
{
MOZ_COUNT_CTOR
(
DR_intrinsic_inline_size_cookie
)
;
mValue
=
nsFrame
:
:
DisplayIntrinsicISizeEnter
(
mFrame
mType
)
;
}
DR_intrinsic_inline_size_cookie
:
:
~
DR_intrinsic_inline_size_cookie
(
)
{
MOZ_COUNT_DTOR
(
DR_intrinsic_inline_size_cookie
)
;
nsFrame
:
:
DisplayIntrinsicISizeExit
(
mFrame
mType
mResult
mValue
)
;
}
DR_intrinsic_size_cookie
:
:
DR_intrinsic_size_cookie
(
nsIFrame
*
aFrame
const
char
*
aType
nsSize
&
aResult
)
:
mFrame
(
aFrame
)
mType
(
aType
)
mResult
(
aResult
)
{
MOZ_COUNT_CTOR
(
DR_intrinsic_size_cookie
)
;
mValue
=
nsFrame
:
:
DisplayIntrinsicSizeEnter
(
mFrame
mType
)
;
}
DR_intrinsic_size_cookie
:
:
~
DR_intrinsic_size_cookie
(
)
{
MOZ_COUNT_DTOR
(
DR_intrinsic_size_cookie
)
;
nsFrame
:
:
DisplayIntrinsicSizeExit
(
mFrame
mType
mResult
mValue
)
;
}
DR_init_constraints_cookie
:
:
DR_init_constraints_cookie
(
nsIFrame
*
aFrame
ReflowInput
*
aState
nscoord
aCBWidth
nscoord
aCBHeight
const
nsMargin
*
aMargin
const
nsMargin
*
aPadding
)
:
mFrame
(
aFrame
)
mState
(
aState
)
{
MOZ_COUNT_CTOR
(
DR_init_constraints_cookie
)
;
mValue
=
ReflowInput
:
:
DisplayInitConstraintsEnter
(
mFrame
mState
aCBWidth
aCBHeight
aMargin
aPadding
)
;
}
DR_init_constraints_cookie
:
:
~
DR_init_constraints_cookie
(
)
{
MOZ_COUNT_DTOR
(
DR_init_constraints_cookie
)
;
ReflowInput
:
:
DisplayInitConstraintsExit
(
mFrame
mState
mValue
)
;
}
DR_init_offsets_cookie
:
:
DR_init_offsets_cookie
(
nsIFrame
*
aFrame
SizeComputationInput
*
aState
nscoord
aPercentBasis
WritingMode
aCBWritingMode
const
nsMargin
*
aMargin
const
nsMargin
*
aPadding
)
:
mFrame
(
aFrame
)
mState
(
aState
)
{
MOZ_COUNT_CTOR
(
DR_init_offsets_cookie
)
;
mValue
=
SizeComputationInput
:
:
DisplayInitOffsetsEnter
(
mFrame
mState
aPercentBasis
aCBWritingMode
aMargin
aPadding
)
;
}
DR_init_offsets_cookie
:
:
~
DR_init_offsets_cookie
(
)
{
MOZ_COUNT_DTOR
(
DR_init_offsets_cookie
)
;
SizeComputationInput
:
:
DisplayInitOffsetsExit
(
mFrame
mState
mValue
)
;
}
DR_init_type_cookie
:
:
DR_init_type_cookie
(
nsIFrame
*
aFrame
ReflowInput
*
aState
)
:
mFrame
(
aFrame
)
mState
(
aState
)
{
MOZ_COUNT_CTOR
(
DR_init_type_cookie
)
;
mValue
=
ReflowInput
:
:
DisplayInitFrameTypeEnter
(
mFrame
mState
)
;
}
DR_init_type_cookie
:
:
~
DR_init_type_cookie
(
)
{
MOZ_COUNT_DTOR
(
DR_init_type_cookie
)
;
ReflowInput
:
:
DisplayInitFrameTypeExit
(
mFrame
mState
mValue
)
;
}
struct
DR_FrameTypeInfo
;
struct
DR_FrameTreeNode
;
struct
DR_Rule
;
struct
DR_State
{
DR_State
(
)
;
~
DR_State
(
)
;
void
Init
(
)
;
void
AddFrameTypeInfo
(
LayoutFrameType
aFrameType
const
char
*
aFrameNameAbbrev
const
char
*
aFrameName
)
;
DR_FrameTypeInfo
*
GetFrameTypeInfo
(
LayoutFrameType
aFrameType
)
;
DR_FrameTypeInfo
*
GetFrameTypeInfo
(
char
*
aFrameName
)
;
void
InitFrameTypeTable
(
)
;
DR_FrameTreeNode
*
CreateTreeNode
(
nsIFrame
*
aFrame
const
ReflowInput
*
aReflowInput
)
;
void
FindMatchingRule
(
DR_FrameTreeNode
&
aNode
)
;
bool
RuleMatches
(
DR_Rule
&
aRule
DR_FrameTreeNode
&
aNode
)
;
bool
GetToken
(
FILE
*
aFile
char
*
aBuf
size_t
aBufSize
)
;
DR_Rule
*
ParseRule
(
FILE
*
aFile
)
;
void
ParseRulesFile
(
)
;
void
AddRule
(
nsTArray
<
DR_Rule
*
>
&
aRules
DR_Rule
&
aRule
)
;
bool
IsWhiteSpace
(
int
c
)
;
bool
GetNumber
(
char
*
aBuf
int32_t
&
aNumber
)
;
void
PrettyUC
(
nscoord
aSize
char
*
aBuf
int
aBufSize
)
;
void
PrintMargin
(
const
char
*
tag
const
nsMargin
*
aMargin
)
;
void
DisplayFrameTypeInfo
(
nsIFrame
*
aFrame
int32_t
aIndent
)
;
void
DeleteTreeNode
(
DR_FrameTreeNode
&
aNode
)
;
bool
mInited
;
bool
mActive
;
int32_t
mCount
;
int32_t
mAssert
;
int32_t
mIndent
;
bool
mIndentUndisplayedFrames
;
bool
mDisplayPixelErrors
;
nsTArray
<
DR_Rule
*
>
mWildRules
;
nsTArray
<
DR_FrameTypeInfo
>
mFrameTypeTable
;
nsTArray
<
DR_FrameTreeNode
*
>
mFrameTreeLeaves
;
}
;
static
DR_State
*
DR_state
;
struct
DR_RulePart
{
explicit
DR_RulePart
(
LayoutFrameType
aFrameType
)
:
mFrameType
(
aFrameType
)
mNext
(
0
)
{
}
void
Destroy
(
)
;
LayoutFrameType
mFrameType
;
DR_RulePart
*
mNext
;
}
;
void
DR_RulePart
:
:
Destroy
(
)
{
if
(
mNext
)
{
mNext
-
>
Destroy
(
)
;
}
delete
this
;
}
struct
DR_Rule
{
DR_Rule
(
)
:
mLength
(
0
)
mTarget
(
nullptr
)
mDisplay
(
false
)
{
MOZ_COUNT_CTOR
(
DR_Rule
)
;
}
~
DR_Rule
(
)
{
if
(
mTarget
)
mTarget
-
>
Destroy
(
)
;
MOZ_COUNT_DTOR
(
DR_Rule
)
;
}
void
AddPart
(
LayoutFrameType
aFrameType
)
;
uint32_t
mLength
;
DR_RulePart
*
mTarget
;
bool
mDisplay
;
}
;
void
DR_Rule
:
:
AddPart
(
LayoutFrameType
aFrameType
)
{
DR_RulePart
*
newPart
=
new
DR_RulePart
(
aFrameType
)
;
newPart
-
>
mNext
=
mTarget
;
mTarget
=
newPart
;
mLength
+
+
;
}
struct
DR_FrameTypeInfo
{
DR_FrameTypeInfo
(
LayoutFrameType
aFrameType
const
char
*
aFrameNameAbbrev
const
char
*
aFrameName
)
;
~
DR_FrameTypeInfo
(
)
{
int32_t
numElements
;
numElements
=
mRules
.
Length
(
)
;
for
(
int32_t
i
=
numElements
-
1
;
i
>
=
0
;
i
-
-
)
{
delete
mRules
.
ElementAt
(
i
)
;
}
}
LayoutFrameType
mType
;
char
mNameAbbrev
[
16
]
;
char
mName
[
32
]
;
nsTArray
<
DR_Rule
*
>
mRules
;
private
:
DR_FrameTypeInfo
&
operator
=
(
const
DR_FrameTypeInfo
&
)
=
delete
;
}
;
DR_FrameTypeInfo
:
:
DR_FrameTypeInfo
(
LayoutFrameType
aFrameType
const
char
*
aFrameNameAbbrev
const
char
*
aFrameName
)
{
mType
=
aFrameType
;
PL_strncpyz
(
mNameAbbrev
aFrameNameAbbrev
sizeof
(
mNameAbbrev
)
)
;
PL_strncpyz
(
mName
aFrameName
sizeof
(
mName
)
)
;
}
struct
DR_FrameTreeNode
{
DR_FrameTreeNode
(
nsIFrame
*
aFrame
DR_FrameTreeNode
*
aParent
)
:
mFrame
(
aFrame
)
mParent
(
aParent
)
mDisplay
(
0
)
mIndent
(
0
)
{
MOZ_COUNT_CTOR
(
DR_FrameTreeNode
)
;
}
~
DR_FrameTreeNode
(
)
{
MOZ_COUNT_DTOR
(
DR_FrameTreeNode
)
;
}
nsIFrame
*
mFrame
;
DR_FrameTreeNode
*
mParent
;
bool
mDisplay
;
uint32_t
mIndent
;
}
;
DR_State
:
:
DR_State
(
)
:
mInited
(
false
)
mActive
(
false
)
mCount
(
0
)
mAssert
(
-
1
)
mIndent
(
0
)
mIndentUndisplayedFrames
(
false
)
mDisplayPixelErrors
(
false
)
{
MOZ_COUNT_CTOR
(
DR_State
)
;
}
void
DR_State
:
:
Init
(
)
{
char
*
env
=
PR_GetEnv
(
"
GECKO_DISPLAY_REFLOW_ASSERT
"
)
;
int32_t
num
;
if
(
env
)
{
if
(
GetNumber
(
env
num
)
)
mAssert
=
num
;
else
printf
(
"
GECKO_DISPLAY_REFLOW_ASSERT
-
invalid
value
=
%
s
"
env
)
;
}
env
=
PR_GetEnv
(
"
GECKO_DISPLAY_REFLOW_INDENT_START
"
)
;
if
(
env
)
{
if
(
GetNumber
(
env
num
)
)
mIndent
=
num
;
else
printf
(
"
GECKO_DISPLAY_REFLOW_INDENT_START
-
invalid
value
=
%
s
"
env
)
;
}
env
=
PR_GetEnv
(
"
GECKO_DISPLAY_REFLOW_INDENT_UNDISPLAYED_FRAMES
"
)
;
if
(
env
)
{
if
(
GetNumber
(
env
num
)
)
mIndentUndisplayedFrames
=
num
;
else
printf
(
"
GECKO_DISPLAY_REFLOW_INDENT_UNDISPLAYED_FRAMES
-
invalid
value
=
%
s
"
env
)
;
}
env
=
PR_GetEnv
(
"
GECKO_DISPLAY_REFLOW_FLAG_PIXEL_ERRORS
"
)
;
if
(
env
)
{
if
(
GetNumber
(
env
num
)
)
mDisplayPixelErrors
=
num
;
else
printf
(
"
GECKO_DISPLAY_REFLOW_FLAG_PIXEL_ERRORS
-
invalid
value
=
%
s
"
env
)
;
}
InitFrameTypeTable
(
)
;
ParseRulesFile
(
)
;
mInited
=
true
;
}
DR_State
:
:
~
DR_State
(
)
{
MOZ_COUNT_DTOR
(
DR_State
)
;
int32_t
numElements
i
;
numElements
=
mWildRules
.
Length
(
)
;
for
(
i
=
numElements
-
1
;
i
>
=
0
;
i
-
-
)
{
delete
mWildRules
.
ElementAt
(
i
)
;
}
numElements
=
mFrameTreeLeaves
.
Length
(
)
;
for
(
i
=
numElements
-
1
;
i
>
=
0
;
i
-
-
)
{
delete
mFrameTreeLeaves
.
ElementAt
(
i
)
;
}
}
bool
DR_State
:
:
GetNumber
(
char
*
aBuf
int32_t
&
aNumber
)
{
if
(
sscanf
(
aBuf
"
%
d
"
&
aNumber
)
>
0
)
return
true
;
else
return
false
;
}
bool
DR_State
:
:
IsWhiteSpace
(
int
c
)
{
return
(
c
=
=
'
'
)
|
|
(
c
=
=
'
\
t
'
)
|
|
(
c
=
=
'
\
n
'
)
|
|
(
c
=
=
'
\
r
'
)
;
}
bool
DR_State
:
:
GetToken
(
FILE
*
aFile
char
*
aBuf
size_t
aBufSize
)
{
bool
haveToken
=
false
;
aBuf
[
0
]
=
0
;
int
c
=
-
1
;
for
(
c
=
getc
(
aFile
)
;
(
c
>
0
)
&
&
IsWhiteSpace
(
c
)
;
c
=
getc
(
aFile
)
)
{
}
if
(
c
>
0
)
{
haveToken
=
true
;
aBuf
[
0
]
=
c
;
size_t
cX
;
for
(
cX
=
1
;
cX
+
1
<
aBufSize
;
cX
+
+
)
{
c
=
getc
(
aFile
)
;
if
(
c
<
0
)
{
ungetc
(
'
'
aFile
)
;
break
;
}
else
{
if
(
IsWhiteSpace
(
c
)
)
{
break
;
}
else
{
aBuf
[
cX
]
=
c
;
}
}
}
aBuf
[
cX
]
=
0
;
}
return
haveToken
;
}
DR_Rule
*
DR_State
:
:
ParseRule
(
FILE
*
aFile
)
{
char
buf
[
128
]
;
int32_t
doDisplay
;
DR_Rule
*
rule
=
nullptr
;
while
(
GetToken
(
aFile
buf
sizeof
(
buf
)
)
)
{
if
(
GetNumber
(
buf
doDisplay
)
)
{
if
(
rule
)
{
rule
-
>
mDisplay
=
!
!
doDisplay
;
break
;
}
else
{
printf
(
"
unexpected
token
-
%
s
\
n
"
buf
)
;
}
}
else
{
if
(
!
rule
)
{
rule
=
new
DR_Rule
;
}
if
(
strcmp
(
buf
"
*
"
)
=
=
0
)
{
rule
-
>
AddPart
(
LayoutFrameType
:
:
None
)
;
}
else
{
DR_FrameTypeInfo
*
info
=
GetFrameTypeInfo
(
buf
)
;
if
(
info
)
{
rule
-
>
AddPart
(
info
-
>
mType
)
;
}
else
{
printf
(
"
invalid
frame
type
-
%
s
\
n
"
buf
)
;
}
}
}
}
return
rule
;
}
void
DR_State
:
:
AddRule
(
nsTArray
<
DR_Rule
*
>
&
aRules
DR_Rule
&
aRule
)
{
int32_t
numRules
=
aRules
.
Length
(
)
;
for
(
int32_t
ruleX
=
0
;
ruleX
<
numRules
;
ruleX
+
+
)
{
DR_Rule
*
rule
=
aRules
.
ElementAt
(
ruleX
)
;
NS_ASSERTION
(
rule
"
program
error
"
)
;
if
(
aRule
.
mLength
>
rule
-
>
mLength
)
{
aRules
.
InsertElementAt
(
ruleX
&
aRule
)
;
return
;
}
}
aRules
.
AppendElement
(
&
aRule
)
;
}
static
Maybe
<
bool
>
ShouldLogReflow
(
const
char
*
processes
)
{
switch
(
processes
[
0
]
)
{
case
'
A
'
:
case
'
a
'
:
return
Some
(
true
)
;
case
'
P
'
:
case
'
p
'
:
return
Some
(
XRE_IsParentProcess
(
)
)
;
case
'
C
'
:
case
'
c
'
:
return
Some
(
XRE_IsContentProcess
(
)
)
;
default
:
return
Nothing
{
}
;
}
}
void
DR_State
:
:
ParseRulesFile
(
)
{
char
*
processes
=
PR_GetEnv
(
"
GECKO_DISPLAY_REFLOW_PROCESSES
"
)
;
if
(
processes
)
{
Maybe
<
bool
>
enableLog
=
ShouldLogReflow
(
processes
)
;
if
(
enableLog
.
isNothing
(
)
)
{
MOZ_CRASH
(
"
GECKO_DISPLAY_REFLOW_PROCESSES
:
[
a
]
ll
[
p
]
arent
[
c
]
ontent
"
)
;
}
else
if
(
enableLog
.
value
(
)
)
{
DR_Rule
*
rule
=
new
DR_Rule
;
rule
-
>
AddPart
(
LayoutFrameType
:
:
None
)
;
rule
-
>
mDisplay
=
true
;
AddRule
(
mWildRules
*
rule
)
;
mActive
=
true
;
}
return
;
}
char
*
path
=
PR_GetEnv
(
"
GECKO_DISPLAY_REFLOW_RULES_FILE
"
)
;
if
(
path
)
{
FILE
*
inFile
=
fopen
(
path
"
r
"
)
;
if
(
!
inFile
)
{
MOZ_CRASH
(
"
Failed
to
open
the
specified
rules
file
;
Try
-
-
setpref
"
"
security
.
sandbox
.
content
.
level
=
2
if
the
sandbox
is
at
cause
"
)
;
}
for
(
DR_Rule
*
rule
=
ParseRule
(
inFile
)
;
rule
;
rule
=
ParseRule
(
inFile
)
)
{
if
(
rule
-
>
mTarget
)
{
LayoutFrameType
fType
=
rule
-
>
mTarget
-
>
mFrameType
;
if
(
fType
!
=
LayoutFrameType
:
:
None
)
{
DR_FrameTypeInfo
*
info
=
GetFrameTypeInfo
(
fType
)
;
AddRule
(
info
-
>
mRules
*
rule
)
;
}
else
{
AddRule
(
mWildRules
*
rule
)
;
}
mActive
=
true
;
}
}
fclose
(
inFile
)
;
}
}
void
DR_State
:
:
AddFrameTypeInfo
(
LayoutFrameType
aFrameType
const
char
*
aFrameNameAbbrev
const
char
*
aFrameName
)
{
mFrameTypeTable
.
AppendElement
(
DR_FrameTypeInfo
(
aFrameType
aFrameNameAbbrev
aFrameName
)
)
;
}
DR_FrameTypeInfo
*
DR_State
:
:
GetFrameTypeInfo
(
LayoutFrameType
aFrameType
)
{
int32_t
numEntries
=
mFrameTypeTable
.
Length
(
)
;
NS_ASSERTION
(
numEntries
!
=
0
"
empty
FrameTypeTable
"
)
;
for
(
int32_t
i
=
0
;
i
<
numEntries
;
i
+
+
)
{
DR_FrameTypeInfo
&
info
=
mFrameTypeTable
.
ElementAt
(
i
)
;
if
(
info
.
mType
=
=
aFrameType
)
{
return
&
info
;
}
}
return
&
mFrameTypeTable
.
ElementAt
(
numEntries
-
1
)
;
}
DR_FrameTypeInfo
*
DR_State
:
:
GetFrameTypeInfo
(
char
*
aFrameName
)
{
int32_t
numEntries
=
mFrameTypeTable
.
Length
(
)
;
NS_ASSERTION
(
numEntries
!
=
0
"
empty
FrameTypeTable
"
)
;
for
(
int32_t
i
=
0
;
i
<
numEntries
;
i
+
+
)
{
DR_FrameTypeInfo
&
info
=
mFrameTypeTable
.
ElementAt
(
i
)
;
if
(
(
strcmp
(
aFrameName
info
.
mName
)
=
=
0
)
|
|
(
strcmp
(
aFrameName
info
.
mNameAbbrev
)
=
=
0
)
)
{
return
&
info
;
}
}
return
&
mFrameTypeTable
.
ElementAt
(
numEntries
-
1
)
;
}
void
DR_State
:
:
InitFrameTypeTable
(
)
{
AddFrameTypeInfo
(
LayoutFrameType
:
:
Block
"
block
"
"
block
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
Br
"
br
"
"
br
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
Bullet
"
bullet
"
"
bullet
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
ColorControl
"
color
"
"
colorControl
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
GfxButtonControl
"
button
"
"
gfxButtonControl
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
HTMLButtonControl
"
HTMLbutton
"
"
HTMLButtonControl
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
HTMLCanvas
"
HTMLCanvas
"
"
HTMLCanvas
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
SubDocument
"
subdoc
"
"
subDocument
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
Image
"
img
"
"
image
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
Inline
"
inline
"
"
inline
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
Letter
"
letter
"
"
letter
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
Line
"
line
"
"
line
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
ListControl
"
select
"
"
select
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
Object
"
obj
"
"
object
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
Page
"
page
"
"
page
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
Placeholder
"
place
"
"
placeholder
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
Canvas
"
canvas
"
"
canvas
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
Root
"
root
"
"
root
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
Scroll
"
scroll
"
"
scroll
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
TableCell
"
cell
"
"
tableCell
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
BCTableCell
"
bcCell
"
"
bcTableCell
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
TableCol
"
col
"
"
tableCol
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
TableColGroup
"
colG
"
"
tableColGroup
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
Table
"
tbl
"
"
table
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
TableWrapper
"
tblW
"
"
tableWrapper
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
TableRowGroup
"
rowG
"
"
tableRowGroup
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
TableRow
"
row
"
"
tableRow
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
TextInput
"
textCtl
"
"
textInput
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
Text
"
text
"
"
text
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
Viewport
"
VP
"
"
viewport
"
)
;
#
ifdef
MOZ_XUL
AddFrameTypeInfo
(
LayoutFrameType
:
:
XULLabel
"
XULLabel
"
"
XULLabel
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
Box
"
Box
"
"
Box
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
Slider
"
Slider
"
"
Slider
"
)
;
AddFrameTypeInfo
(
LayoutFrameType
:
:
PopupSet
"
PopupSet
"
"
PopupSet
"
)
;
#
endif
AddFrameTypeInfo
(
LayoutFrameType
:
:
None
"
unknown
"
"
unknown
"
)
;
}
void
DR_State
:
:
DisplayFrameTypeInfo
(
nsIFrame
*
aFrame
int32_t
aIndent
)
{
DR_FrameTypeInfo
*
frameTypeInfo
=
GetFrameTypeInfo
(
aFrame
-
>
Type
(
)
)
;
if
(
frameTypeInfo
)
{
for
(
int32_t
i
=
0
;
i
<
aIndent
;
i
+
+
)
{
printf
(
"
"
)
;
}
if
(
!
strcmp
(
frameTypeInfo
-
>
mNameAbbrev
"
unknown
"
)
)
{
if
(
aFrame
)
{
nsAutoString
name
;
aFrame
-
>
GetFrameName
(
name
)
;
printf
(
"
%
s
%
p
"
NS_LossyConvertUTF16toASCII
(
name
)
.
get
(
)
(
void
*
)
aFrame
)
;
}
else
{
printf
(
"
%
s
%
p
"
frameTypeInfo
-
>
mNameAbbrev
(
void
*
)
aFrame
)
;
}
}
else
{
printf
(
"
%
s
%
p
"
frameTypeInfo
-
>
mNameAbbrev
(
void
*
)
aFrame
)
;
}
}
}
bool
DR_State
:
:
RuleMatches
(
DR_Rule
&
aRule
DR_FrameTreeNode
&
aNode
)
{
NS_ASSERTION
(
aRule
.
mTarget
"
program
error
"
)
;
DR_RulePart
*
rulePart
;
DR_FrameTreeNode
*
parentNode
;
for
(
rulePart
=
aRule
.
mTarget
-
>
mNext
parentNode
=
aNode
.
mParent
;
rulePart
&
&
parentNode
;
rulePart
=
rulePart
-
>
mNext
parentNode
=
parentNode
-
>
mParent
)
{
if
(
rulePart
-
>
mFrameType
!
=
LayoutFrameType
:
:
None
)
{
if
(
parentNode
-
>
mFrame
)
{
if
(
rulePart
-
>
mFrameType
!
=
parentNode
-
>
mFrame
-
>
Type
(
)
)
{
return
false
;
}
}
else
NS_ASSERTION
(
false
"
program
error
"
)
;
}
}
return
true
;
}
void
DR_State
:
:
FindMatchingRule
(
DR_FrameTreeNode
&
aNode
)
{
if
(
!
aNode
.
mFrame
)
{
NS_ASSERTION
(
false
"
invalid
DR_FrameTreeNode
\
n
"
)
;
return
;
}
bool
matchingRule
=
false
;
DR_FrameTypeInfo
*
info
=
GetFrameTypeInfo
(
aNode
.
mFrame
-
>
Type
(
)
)
;
NS_ASSERTION
(
info
"
program
error
"
)
;
int32_t
numRules
=
info
-
>
mRules
.
Length
(
)
;
for
(
int32_t
ruleX
=
0
;
ruleX
<
numRules
;
ruleX
+
+
)
{
DR_Rule
*
rule
=
info
-
>
mRules
.
ElementAt
(
ruleX
)
;
if
(
rule
&
&
RuleMatches
(
*
rule
aNode
)
)
{
aNode
.
mDisplay
=
rule
-
>
mDisplay
;
matchingRule
=
true
;
break
;
}
}
if
(
!
matchingRule
)
{
int32_t
numWildRules
=
mWildRules
.
Length
(
)
;
for
(
int32_t
ruleX
=
0
;
ruleX
<
numWildRules
;
ruleX
+
+
)
{
DR_Rule
*
rule
=
mWildRules
.
ElementAt
(
ruleX
)
;
if
(
rule
&
&
RuleMatches
(
*
rule
aNode
)
)
{
aNode
.
mDisplay
=
rule
-
>
mDisplay
;
break
;
}
}
}
}
DR_FrameTreeNode
*
DR_State
:
:
CreateTreeNode
(
nsIFrame
*
aFrame
const
ReflowInput
*
aReflowInput
)
{
nsIFrame
*
parentFrame
;
if
(
aReflowInput
)
{
const
ReflowInput
*
parentRI
=
aReflowInput
-
>
mParentReflowInput
;
parentFrame
=
(
parentRI
)
?
parentRI
-
>
mFrame
:
nullptr
;
}
else
{
parentFrame
=
aFrame
-
>
GetParent
(
)
;
}
DR_FrameTreeNode
*
parentNode
=
nullptr
;
DR_FrameTreeNode
*
lastLeaf
=
nullptr
;
if
(
mFrameTreeLeaves
.
Length
(
)
)
lastLeaf
=
mFrameTreeLeaves
.
ElementAt
(
mFrameTreeLeaves
.
Length
(
)
-
1
)
;
if
(
lastLeaf
)
{
for
(
parentNode
=
lastLeaf
;
parentNode
&
&
(
parentNode
-
>
mFrame
!
=
parentFrame
)
;
parentNode
=
parentNode
-
>
mParent
)
{
}
}
DR_FrameTreeNode
*
newNode
=
new
DR_FrameTreeNode
(
aFrame
parentNode
)
;
FindMatchingRule
(
*
newNode
)
;
newNode
-
>
mIndent
=
mIndent
;
if
(
newNode
-
>
mDisplay
|
|
mIndentUndisplayedFrames
)
{
+
+
mIndent
;
}
if
(
lastLeaf
&
&
(
lastLeaf
=
=
parentNode
)
)
{
mFrameTreeLeaves
.
RemoveLastElement
(
)
;
}
mFrameTreeLeaves
.
AppendElement
(
newNode
)
;
mCount
+
+
;
return
newNode
;
}
void
DR_State
:
:
PrettyUC
(
nscoord
aSize
char
*
aBuf
int
aBufSize
)
{
if
(
NS_UNCONSTRAINEDSIZE
=
=
aSize
)
{
strcpy
(
aBuf
"
UC
"
)
;
}
else
{
if
(
(
nscoord
)
0xdeadbeefU
=
=
aSize
)
{
strcpy
(
aBuf
"
deadbeef
"
)
;
}
else
{
snprintf
(
aBuf
aBufSize
"
%
d
"
aSize
)
;
}
}
}
void
DR_State
:
:
PrintMargin
(
const
char
*
tag
const
nsMargin
*
aMargin
)
{
if
(
aMargin
)
{
char
t
[
16
]
r
[
16
]
b
[
16
]
l
[
16
]
;
PrettyUC
(
aMargin
-
>
top
t
16
)
;
PrettyUC
(
aMargin
-
>
right
r
16
)
;
PrettyUC
(
aMargin
-
>
bottom
b
16
)
;
PrettyUC
(
aMargin
-
>
left
l
16
)
;
printf
(
"
%
s
=
%
s
%
s
%
s
%
s
"
tag
t
r
b
l
)
;
}
else
{
printf
(
"
%
s
=
%
p
"
tag
(
void
*
)
aMargin
)
;
}
}
void
DR_State
:
:
DeleteTreeNode
(
DR_FrameTreeNode
&
aNode
)
{
mFrameTreeLeaves
.
RemoveElement
(
&
aNode
)
;
int32_t
numLeaves
=
mFrameTreeLeaves
.
Length
(
)
;
if
(
(
0
=
=
numLeaves
)
|
|
(
aNode
.
mParent
!
=
mFrameTreeLeaves
.
ElementAt
(
numLeaves
-
1
)
)
)
{
mFrameTreeLeaves
.
AppendElement
(
aNode
.
mParent
)
;
}
if
(
aNode
.
mDisplay
|
|
mIndentUndisplayedFrames
)
{
-
-
mIndent
;
}
delete
&
aNode
;
}
static
void
CheckPixelError
(
nscoord
aSize
int32_t
aPixelToTwips
)
{
if
(
NS_UNCONSTRAINEDSIZE
!
=
aSize
)
{
if
(
(
aSize
%
aPixelToTwips
)
>
0
)
{
printf
(
"
VALUE
%
d
is
not
a
whole
pixel
\
n
"
aSize
)
;
}
}
}
static
void
DisplayReflowEnterPrint
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
const
ReflowInput
&
aReflowInput
DR_FrameTreeNode
&
aTreeNode
bool
aChanged
)
{
if
(
aTreeNode
.
mDisplay
)
{
DR_state
-
>
DisplayFrameTypeInfo
(
aFrame
aTreeNode
.
mIndent
)
;
char
width
[
16
]
;
char
height
[
16
]
;
DR_state
-
>
PrettyUC
(
aReflowInput
.
AvailableWidth
(
)
width
16
)
;
DR_state
-
>
PrettyUC
(
aReflowInput
.
AvailableHeight
(
)
height
16
)
;
printf
(
"
Reflow
a
=
%
s
%
s
"
width
height
)
;
DR_state
-
>
PrettyUC
(
aReflowInput
.
ComputedWidth
(
)
width
16
)
;
DR_state
-
>
PrettyUC
(
aReflowInput
.
ComputedHeight
(
)
height
16
)
;
printf
(
"
c
=
%
s
%
s
"
width
height
)
;
if
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_IS_DIRTY
)
printf
(
"
dirty
"
)
;
if
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_HAS_DIRTY_CHILDREN
)
printf
(
"
dirty
-
children
"
)
;
if
(
aReflowInput
.
mFlags
.
mSpecialBSizeReflow
)
printf
(
"
special
-
bsize
"
)
;
if
(
aReflowInput
.
IsHResize
(
)
)
printf
(
"
h
-
resize
"
)
;
if
(
aReflowInput
.
IsVResize
(
)
)
printf
(
"
v
-
resize
"
)
;
nsIFrame
*
inFlow
=
aFrame
-
>
GetPrevInFlow
(
)
;
if
(
inFlow
)
{
printf
(
"
pif
=
%
p
"
(
void
*
)
inFlow
)
;
}
inFlow
=
aFrame
-
>
GetNextInFlow
(
)
;
if
(
inFlow
)
{
printf
(
"
nif
=
%
p
"
(
void
*
)
inFlow
)
;
}
if
(
aChanged
)
printf
(
"
CHANGED
\
n
"
)
;
else
printf
(
"
cnt
=
%
d
\
n
"
DR_state
-
>
mCount
)
;
if
(
DR_state
-
>
mDisplayPixelErrors
)
{
int32_t
d2a
=
aPresContext
-
>
AppUnitsPerDevPixel
(
)
;
CheckPixelError
(
aReflowInput
.
AvailableWidth
(
)
d2a
)
;
CheckPixelError
(
aReflowInput
.
AvailableHeight
(
)
d2a
)
;
CheckPixelError
(
aReflowInput
.
ComputedWidth
(
)
d2a
)
;
CheckPixelError
(
aReflowInput
.
ComputedHeight
(
)
d2a
)
;
}
}
}
void
*
nsFrame
:
:
DisplayReflowEnter
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
const
ReflowInput
&
aReflowInput
)
{
if
(
!
DR_state
-
>
mInited
)
DR_state
-
>
Init
(
)
;
if
(
!
DR_state
-
>
mActive
)
return
nullptr
;
NS_ASSERTION
(
aFrame
"
invalid
call
"
)
;
DR_FrameTreeNode
*
treeNode
=
DR_state
-
>
CreateTreeNode
(
aFrame
&
aReflowInput
)
;
if
(
treeNode
)
{
DisplayReflowEnterPrint
(
aPresContext
aFrame
aReflowInput
*
treeNode
false
)
;
}
return
treeNode
;
}
void
*
nsFrame
:
:
DisplayLayoutEnter
(
nsIFrame
*
aFrame
)
{
if
(
!
DR_state
-
>
mInited
)
DR_state
-
>
Init
(
)
;
if
(
!
DR_state
-
>
mActive
)
return
nullptr
;
NS_ASSERTION
(
aFrame
"
invalid
call
"
)
;
DR_FrameTreeNode
*
treeNode
=
DR_state
-
>
CreateTreeNode
(
aFrame
nullptr
)
;
if
(
treeNode
&
&
treeNode
-
>
mDisplay
)
{
DR_state
-
>
DisplayFrameTypeInfo
(
aFrame
treeNode
-
>
mIndent
)
;
printf
(
"
XULLayout
\
n
"
)
;
}
return
treeNode
;
}
void
*
nsFrame
:
:
DisplayIntrinsicISizeEnter
(
nsIFrame
*
aFrame
const
char
*
aType
)
{
if
(
!
DR_state
-
>
mInited
)
DR_state
-
>
Init
(
)
;
if
(
!
DR_state
-
>
mActive
)
return
nullptr
;
NS_ASSERTION
(
aFrame
"
invalid
call
"
)
;
DR_FrameTreeNode
*
treeNode
=
DR_state
-
>
CreateTreeNode
(
aFrame
nullptr
)
;
if
(
treeNode
&
&
treeNode
-
>
mDisplay
)
{
DR_state
-
>
DisplayFrameTypeInfo
(
aFrame
treeNode
-
>
mIndent
)
;
printf
(
"
Get
%
sISize
\
n
"
aType
)
;
}
return
treeNode
;
}
void
*
nsFrame
:
:
DisplayIntrinsicSizeEnter
(
nsIFrame
*
aFrame
const
char
*
aType
)
{
if
(
!
DR_state
-
>
mInited
)
DR_state
-
>
Init
(
)
;
if
(
!
DR_state
-
>
mActive
)
return
nullptr
;
NS_ASSERTION
(
aFrame
"
invalid
call
"
)
;
DR_FrameTreeNode
*
treeNode
=
DR_state
-
>
CreateTreeNode
(
aFrame
nullptr
)
;
if
(
treeNode
&
&
treeNode
-
>
mDisplay
)
{
DR_state
-
>
DisplayFrameTypeInfo
(
aFrame
treeNode
-
>
mIndent
)
;
printf
(
"
Get
%
sSize
\
n
"
aType
)
;
}
return
treeNode
;
}
void
nsFrame
:
:
DisplayReflowExit
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
ReflowOutput
&
aMetrics
const
nsReflowStatus
&
aStatus
void
*
aFrameTreeNode
)
{
if
(
!
DR_state
-
>
mActive
)
return
;
NS_ASSERTION
(
aFrame
"
DisplayReflowExit
-
invalid
call
"
)
;
if
(
!
aFrameTreeNode
)
return
;
DR_FrameTreeNode
*
treeNode
=
(
DR_FrameTreeNode
*
)
aFrameTreeNode
;
if
(
treeNode
-
>
mDisplay
)
{
DR_state
-
>
DisplayFrameTypeInfo
(
aFrame
treeNode
-
>
mIndent
)
;
char
width
[
16
]
;
char
height
[
16
]
;
char
x
[
16
]
;
char
y
[
16
]
;
DR_state
-
>
PrettyUC
(
aMetrics
.
Width
(
)
width
16
)
;
DR_state
-
>
PrettyUC
(
aMetrics
.
Height
(
)
height
16
)
;
printf
(
"
Reflow
d
=
%
s
%
s
"
width
height
)
;
if
(
!
aStatus
.
IsEmpty
(
)
)
{
printf
(
"
status
=
%
s
"
ToString
(
aStatus
)
.
c_str
(
)
)
;
}
if
(
aFrame
-
>
HasOverflowAreas
(
)
)
{
DR_state
-
>
PrettyUC
(
aMetrics
.
VisualOverflow
(
)
.
x
x
16
)
;
DR_state
-
>
PrettyUC
(
aMetrics
.
VisualOverflow
(
)
.
y
y
16
)
;
DR_state
-
>
PrettyUC
(
aMetrics
.
VisualOverflow
(
)
.
width
width
16
)
;
DR_state
-
>
PrettyUC
(
aMetrics
.
VisualOverflow
(
)
.
height
height
16
)
;
printf
(
"
vis
-
o
=
(
%
s
%
s
)
%
s
x
%
s
"
x
y
width
height
)
;
nsRect
storedOverflow
=
aFrame
-
>
GetVisualOverflowRect
(
)
;
DR_state
-
>
PrettyUC
(
storedOverflow
.
x
x
16
)
;
DR_state
-
>
PrettyUC
(
storedOverflow
.
y
y
16
)
;
DR_state
-
>
PrettyUC
(
storedOverflow
.
width
width
16
)
;
DR_state
-
>
PrettyUC
(
storedOverflow
.
height
height
16
)
;
printf
(
"
vis
-
sto
=
(
%
s
%
s
)
%
s
x
%
s
"
x
y
width
height
)
;
DR_state
-
>
PrettyUC
(
aMetrics
.
ScrollableOverflow
(
)
.
x
x
16
)
;
DR_state
-
>
PrettyUC
(
aMetrics
.
ScrollableOverflow
(
)
.
y
y
16
)
;
DR_state
-
>
PrettyUC
(
aMetrics
.
ScrollableOverflow
(
)
.
width
width
16
)
;
DR_state
-
>
PrettyUC
(
aMetrics
.
ScrollableOverflow
(
)
.
height
height
16
)
;
printf
(
"
scr
-
o
=
(
%
s
%
s
)
%
s
x
%
s
"
x
y
width
height
)
;
storedOverflow
=
aFrame
-
>
GetScrollableOverflowRect
(
)
;
DR_state
-
>
PrettyUC
(
storedOverflow
.
x
x
16
)
;
DR_state
-
>
PrettyUC
(
storedOverflow
.
y
y
16
)
;
DR_state
-
>
PrettyUC
(
storedOverflow
.
width
width
16
)
;
DR_state
-
>
PrettyUC
(
storedOverflow
.
height
height
16
)
;
printf
(
"
scr
-
sto
=
(
%
s
%
s
)
%
s
x
%
s
"
x
y
width
height
)
;
}
printf
(
"
\
n
"
)
;
if
(
DR_state
-
>
mDisplayPixelErrors
)
{
int32_t
d2a
=
aPresContext
-
>
AppUnitsPerDevPixel
(
)
;
CheckPixelError
(
aMetrics
.
Width
(
)
d2a
)
;
CheckPixelError
(
aMetrics
.
Height
(
)
d2a
)
;
}
}
DR_state
-
>
DeleteTreeNode
(
*
treeNode
)
;
}
void
nsFrame
:
:
DisplayLayoutExit
(
nsIFrame
*
aFrame
void
*
aFrameTreeNode
)
{
if
(
!
DR_state
-
>
mActive
)
return
;
NS_ASSERTION
(
aFrame
"
non
-
null
frame
required
"
)
;
if
(
!
aFrameTreeNode
)
return
;
DR_FrameTreeNode
*
treeNode
=
(
DR_FrameTreeNode
*
)
aFrameTreeNode
;
if
(
treeNode
-
>
mDisplay
)
{
DR_state
-
>
DisplayFrameTypeInfo
(
aFrame
treeNode
-
>
mIndent
)
;
nsRect
rect
=
aFrame
-
>
GetRect
(
)
;
printf
(
"
XULLayout
=
%
d
%
d
%
d
%
d
\
n
"
rect
.
x
rect
.
y
rect
.
width
rect
.
height
)
;
}
DR_state
-
>
DeleteTreeNode
(
*
treeNode
)
;
}
void
nsFrame
:
:
DisplayIntrinsicISizeExit
(
nsIFrame
*
aFrame
const
char
*
aType
nscoord
aResult
void
*
aFrameTreeNode
)
{
if
(
!
DR_state
-
>
mActive
)
return
;
NS_ASSERTION
(
aFrame
"
non
-
null
frame
required
"
)
;
if
(
!
aFrameTreeNode
)
return
;
DR_FrameTreeNode
*
treeNode
=
(
DR_FrameTreeNode
*
)
aFrameTreeNode
;
if
(
treeNode
-
>
mDisplay
)
{
DR_state
-
>
DisplayFrameTypeInfo
(
aFrame
treeNode
-
>
mIndent
)
;
char
iSize
[
16
]
;
DR_state
-
>
PrettyUC
(
aResult
iSize
16
)
;
printf
(
"
Get
%
sISize
=
%
s
\
n
"
aType
iSize
)
;
}
DR_state
-
>
DeleteTreeNode
(
*
treeNode
)
;
}
void
nsFrame
:
:
DisplayIntrinsicSizeExit
(
nsIFrame
*
aFrame
const
char
*
aType
nsSize
aResult
void
*
aFrameTreeNode
)
{
if
(
!
DR_state
-
>
mActive
)
return
;
NS_ASSERTION
(
aFrame
"
non
-
null
frame
required
"
)
;
if
(
!
aFrameTreeNode
)
return
;
DR_FrameTreeNode
*
treeNode
=
(
DR_FrameTreeNode
*
)
aFrameTreeNode
;
if
(
treeNode
-
>
mDisplay
)
{
DR_state
-
>
DisplayFrameTypeInfo
(
aFrame
treeNode
-
>
mIndent
)
;
char
width
[
16
]
;
char
height
[
16
]
;
DR_state
-
>
PrettyUC
(
aResult
.
width
width
16
)
;
DR_state
-
>
PrettyUC
(
aResult
.
height
height
16
)
;
printf
(
"
Get
%
sSize
=
%
s
%
s
\
n
"
aType
width
height
)
;
}
DR_state
-
>
DeleteTreeNode
(
*
treeNode
)
;
}
void
nsFrame
:
:
DisplayReflowStartup
(
)
{
DR_state
=
new
DR_State
(
)
;
}
void
nsFrame
:
:
DisplayReflowShutdown
(
)
{
delete
DR_state
;
DR_state
=
nullptr
;
}
void
DR_cookie
:
:
Change
(
)
const
{
DR_FrameTreeNode
*
treeNode
=
(
DR_FrameTreeNode
*
)
mValue
;
if
(
treeNode
&
&
treeNode
-
>
mDisplay
)
{
DisplayReflowEnterPrint
(
mPresContext
mFrame
mReflowInput
*
treeNode
true
)
;
}
}
void
*
ReflowInput
:
:
DisplayInitConstraintsEnter
(
nsIFrame
*
aFrame
ReflowInput
*
aState
nscoord
aContainingBlockWidth
nscoord
aContainingBlockHeight
const
nsMargin
*
aBorder
const
nsMargin
*
aPadding
)
{
MOZ_ASSERT
(
aFrame
"
non
-
null
frame
required
"
)
;
MOZ_ASSERT
(
aState
"
non
-
null
state
required
"
)
;
if
(
!
DR_state
-
>
mInited
)
DR_state
-
>
Init
(
)
;
if
(
!
DR_state
-
>
mActive
)
return
nullptr
;
DR_FrameTreeNode
*
treeNode
=
DR_state
-
>
CreateTreeNode
(
aFrame
aState
)
;
if
(
treeNode
&
&
treeNode
-
>
mDisplay
)
{
DR_state
-
>
DisplayFrameTypeInfo
(
aFrame
treeNode
-
>
mIndent
)
;
printf
(
"
InitConstraints
parent
=
%
p
"
(
void
*
)
aState
-
>
mParentReflowInput
)
;
char
width
[
16
]
;
char
height
[
16
]
;
DR_state
-
>
PrettyUC
(
aContainingBlockWidth
width
16
)
;
DR_state
-
>
PrettyUC
(
aContainingBlockHeight
height
16
)
;
printf
(
"
cb
=
%
s
%
s
"
width
height
)
;
DR_state
-
>
PrettyUC
(
aState
-
>
AvailableWidth
(
)
width
16
)
;
DR_state
-
>
PrettyUC
(
aState
-
>
AvailableHeight
(
)
height
16
)
;
printf
(
"
as
=
%
s
%
s
"
width
height
)
;
DR_state
-
>
PrintMargin
(
"
b
"
aBorder
)
;
DR_state
-
>
PrintMargin
(
"
p
"
aPadding
)
;
putchar
(
'
\
n
'
)
;
}
return
treeNode
;
}
void
ReflowInput
:
:
DisplayInitConstraintsExit
(
nsIFrame
*
aFrame
ReflowInput
*
aState
void
*
aValue
)
{
MOZ_ASSERT
(
aFrame
"
non
-
null
frame
required
"
)
;
MOZ_ASSERT
(
aState
"
non
-
null
state
required
"
)
;
if
(
!
DR_state
-
>
mActive
)
return
;
if
(
!
aValue
)
return
;
DR_FrameTreeNode
*
treeNode
=
(
DR_FrameTreeNode
*
)
aValue
;
if
(
treeNode
-
>
mDisplay
)
{
DR_state
-
>
DisplayFrameTypeInfo
(
aFrame
treeNode
-
>
mIndent
)
;
char
cmiw
[
16
]
cw
[
16
]
cmxw
[
16
]
cmih
[
16
]
ch
[
16
]
cmxh
[
16
]
;
DR_state
-
>
PrettyUC
(
aState
-
>
ComputedMinWidth
(
)
cmiw
16
)
;
DR_state
-
>
PrettyUC
(
aState
-
>
ComputedWidth
(
)
cw
16
)
;
DR_state
-
>
PrettyUC
(
aState
-
>
ComputedMaxWidth
(
)
cmxw
16
)
;
DR_state
-
>
PrettyUC
(
aState
-
>
ComputedMinHeight
(
)
cmih
16
)
;
DR_state
-
>
PrettyUC
(
aState
-
>
ComputedHeight
(
)
ch
16
)
;
DR_state
-
>
PrettyUC
(
aState
-
>
ComputedMaxHeight
(
)
cmxh
16
)
;
printf
(
"
InitConstraints
=
cw
=
(
%
s
<
=
%
s
<
=
%
s
)
ch
=
(
%
s
<
=
%
s
<
=
%
s
)
"
cmiw
cw
cmxw
cmih
ch
cmxh
)
;
DR_state
-
>
PrintMargin
(
"
co
"
&
aState
-
>
ComputedPhysicalOffsets
(
)
)
;
putchar
(
'
\
n
'
)
;
}
DR_state
-
>
DeleteTreeNode
(
*
treeNode
)
;
}
void
*
SizeComputationInput
:
:
DisplayInitOffsetsEnter
(
nsIFrame
*
aFrame
SizeComputationInput
*
aState
nscoord
aPercentBasis
WritingMode
aCBWritingMode
const
nsMargin
*
aBorder
const
nsMargin
*
aPadding
)
{
MOZ_ASSERT
(
aFrame
"
non
-
null
frame
required
"
)
;
MOZ_ASSERT
(
aState
"
non
-
null
state
required
"
)
;
if
(
!
DR_state
-
>
mInited
)
DR_state
-
>
Init
(
)
;
if
(
!
DR_state
-
>
mActive
)
return
nullptr
;
DR_FrameTreeNode
*
treeNode
=
DR_state
-
>
CreateTreeNode
(
aFrame
nullptr
)
;
if
(
treeNode
&
&
treeNode
-
>
mDisplay
)
{
DR_state
-
>
DisplayFrameTypeInfo
(
aFrame
treeNode
-
>
mIndent
)
;
char
pctBasisStr
[
16
]
;
DR_state
-
>
PrettyUC
(
aPercentBasis
pctBasisStr
16
)
;
printf
(
"
InitOffsets
pct_basis
=
%
s
"
pctBasisStr
)
;
DR_state
-
>
PrintMargin
(
"
b
"
aBorder
)
;
DR_state
-
>
PrintMargin
(
"
p
"
aPadding
)
;
putchar
(
'
\
n
'
)
;
}
return
treeNode
;
}
void
SizeComputationInput
:
:
DisplayInitOffsetsExit
(
nsIFrame
*
aFrame
SizeComputationInput
*
aState
void
*
aValue
)
{
MOZ_ASSERT
(
aFrame
"
non
-
null
frame
required
"
)
;
MOZ_ASSERT
(
aState
"
non
-
null
state
required
"
)
;
if
(
!
DR_state
-
>
mActive
)
return
;
if
(
!
aValue
)
return
;
DR_FrameTreeNode
*
treeNode
=
(
DR_FrameTreeNode
*
)
aValue
;
if
(
treeNode
-
>
mDisplay
)
{
DR_state
-
>
DisplayFrameTypeInfo
(
aFrame
treeNode
-
>
mIndent
)
;
printf
(
"
InitOffsets
=
"
)
;
DR_state
-
>
PrintMargin
(
"
m
"
&
aState
-
>
ComputedPhysicalMargin
(
)
)
;
DR_state
-
>
PrintMargin
(
"
p
"
&
aState
-
>
ComputedPhysicalPadding
(
)
)
;
DR_state
-
>
PrintMargin
(
"
p
+
b
"
&
aState
-
>
ComputedPhysicalBorderPadding
(
)
)
;
putchar
(
'
\
n
'
)
;
}
DR_state
-
>
DeleteTreeNode
(
*
treeNode
)
;
}
void
*
ReflowInput
:
:
DisplayInitFrameTypeEnter
(
nsIFrame
*
aFrame
ReflowInput
*
aState
)
{
MOZ_ASSERT
(
aFrame
"
non
-
null
frame
required
"
)
;
MOZ_ASSERT
(
aState
"
non
-
null
state
required
"
)
;
if
(
!
DR_state
-
>
mInited
)
DR_state
-
>
Init
(
)
;
if
(
!
DR_state
-
>
mActive
)
return
nullptr
;
return
DR_state
-
>
CreateTreeNode
(
aFrame
aState
)
;
}
void
ReflowInput
:
:
DisplayInitFrameTypeExit
(
nsIFrame
*
aFrame
ReflowInput
*
aState
void
*
aValue
)
{
MOZ_ASSERT
(
aFrame
"
non
-
null
frame
required
"
)
;
MOZ_ASSERT
(
aState
"
non
-
null
state
required
"
)
;
if
(
!
DR_state
-
>
mActive
)
return
;
if
(
!
aValue
)
return
;
DR_FrameTreeNode
*
treeNode
=
(
DR_FrameTreeNode
*
)
aValue
;
if
(
treeNode
-
>
mDisplay
)
{
DR_state
-
>
DisplayFrameTypeInfo
(
aFrame
treeNode
-
>
mIndent
)
;
printf
(
"
InitFrameType
"
)
;
const
nsStyleDisplay
*
disp
=
aState
-
>
mStyleDisplay
;
if
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
printf
(
"
out
-
of
-
flow
"
)
;
if
(
aFrame
-
>
GetPrevInFlow
(
)
)
printf
(
"
prev
-
in
-
flow
"
)
;
if
(
aFrame
-
>
IsAbsolutelyPositioned
(
)
)
printf
(
"
abspos
"
)
;
if
(
aFrame
-
>
IsFloating
(
)
)
printf
(
"
float
"
)
;
const
nsCSSKeyword
displayVal
=
nsCSSProps
:
:
ValueToKeywordEnum
(
disp
-
>
mDisplay
nsCSSProps
:
:
kDisplayKTable
)
;
if
(
displayVal
=
=
eCSSKeyword_UNKNOWN
)
printf
(
"
display
=
%
u
"
static_cast
<
uint32_t
>
(
disp
-
>
mDisplay
)
)
;
else
printf
(
"
display
=
%
s
"
nsCSSKeywords
:
:
GetStringValue
(
displayVal
)
.
get
(
)
)
;
const
char
*
const
cssFrameTypes
[
]
=
{
"
unknown
"
"
inline
"
"
block
"
"
floating
"
"
absolute
"
"
internal
-
table
"
}
;
nsCSSFrameType
bareType
=
NS_FRAME_GET_TYPE
(
aState
-
>
mFrameType
)
;
bool
repNoBlock
=
NS_FRAME_IS_REPLACED_NOBLOCK
(
aState
-
>
mFrameType
)
;
bool
repBlock
=
NS_FRAME_IS_REPLACED_CONTAINS_BLOCK
(
aState
-
>
mFrameType
)
;
if
(
bareType
>
=
ArrayLength
(
cssFrameTypes
)
)
{
printf
(
"
result
=
type
%
u
"
bareType
)
;
}
else
{
printf
(
"
result
=
%
s
"
cssFrameTypes
[
bareType
]
)
;
}
printf
(
"
%
s
%
s
\
n
"
repNoBlock
?
"
+
rep
"
:
"
"
repBlock
?
"
+
repBlk
"
:
"
"
)
;
}
DR_state
-
>
DeleteTreeNode
(
*
treeNode
)
;
}
#
endif
#
endif
