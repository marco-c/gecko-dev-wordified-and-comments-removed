#
include
"
nsPluginFrame
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxMatrix
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
ifdef
XP_WIN
#
include
"
mozilla
/
plugins
/
PluginMessageUtils
.
h
"
#
endif
#
include
"
nscore
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsWidgetsCID
.
h
"
#
include
"
nsView
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIPluginInstanceOwner
.
h
"
#
include
"
nsNPAPIPluginInstance
.
h
"
#
include
"
nsIDOMElement
.
h
"
#
include
"
npapi
.
h
"
#
include
"
nsIObjectLoadingContent
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsFrameManager
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
<
algorithm
>
#
include
"
nsIObjectFrame
.
h
"
#
include
"
nsPluginNativeWindow
.
h
"
#
include
"
FrameLayerBuilder
.
h
"
#
include
"
ImageLayers
.
h
"
#
include
"
nsPluginInstanceOwner
.
h
"
#
ifdef
XP_WIN
#
include
"
gfxWindowsNativeDrawing
.
h
"
#
include
"
gfxWindowsSurface
.
h
"
#
endif
#
include
"
Layers
.
h
"
#
include
"
ReadbackLayer
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderLayerManager
.
h
"
#
ifdef
ACCESSIBILITY
#
include
"
nsAccessibilityService
.
h
"
#
endif
#
include
"
mozilla
/
Logging
.
h
"
#
ifdef
XP_MACOSX
#
include
"
gfxQuartzNativeDrawing
.
h
"
#
include
"
mozilla
/
gfx
/
QuartzSupport
.
h
"
#
endif
#
ifdef
MOZ_X11
#
include
"
mozilla
/
X11Util
.
h
"
using
mozilla
:
:
DefaultXDisplay
;
#
endif
#
ifdef
XP_WIN
#
include
<
wtypes
.
h
>
#
include
<
winuser
.
h
>
#
endif
#
include
"
mozilla
/
dom
/
TabChild
.
h
"
#
ifdef
CreateEvent
#
undef
CreateEvent
#
endif
static
mozilla
:
:
LazyLogModule
sPluginFrameLog
(
"
nsPluginFrame
"
)
;
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
layers
;
class
PluginBackgroundSink
:
public
ReadbackSink
{
public
:
PluginBackgroundSink
(
nsPluginFrame
*
aFrame
uint64_t
aStartSequenceNumber
)
:
mLastSequenceNumber
(
aStartSequenceNumber
)
mFrame
(
aFrame
)
{
}
~
PluginBackgroundSink
(
)
override
{
if
(
mFrame
)
{
mFrame
-
>
mBackgroundSink
=
nullptr
;
}
}
void
SetUnknown
(
uint64_t
aSequenceNumber
)
override
{
if
(
!
AcceptUpdate
(
aSequenceNumber
)
)
return
;
mFrame
-
>
mInstanceOwner
-
>
SetBackgroundUnknown
(
)
;
}
already_AddRefed
<
DrawTarget
>
BeginUpdate
(
const
nsIntRect
&
aRect
uint64_t
aSequenceNumber
)
override
{
if
(
!
AcceptUpdate
(
aSequenceNumber
)
)
return
nullptr
;
return
mFrame
-
>
mInstanceOwner
-
>
BeginUpdateBackground
(
aRect
)
;
}
void
EndUpdate
(
const
nsIntRect
&
aRect
)
override
{
return
mFrame
-
>
mInstanceOwner
-
>
EndUpdateBackground
(
aRect
)
;
}
void
Destroy
(
)
{
mFrame
=
nullptr
;
}
protected
:
bool
AcceptUpdate
(
uint64_t
aSequenceNumber
)
{
if
(
aSequenceNumber
>
mLastSequenceNumber
&
&
mFrame
&
&
mFrame
-
>
mInstanceOwner
)
{
mLastSequenceNumber
=
aSequenceNumber
;
return
true
;
}
return
false
;
}
uint64_t
mLastSequenceNumber
;
nsPluginFrame
*
mFrame
;
}
;
nsPluginFrame
:
:
nsPluginFrame
(
nsStyleContext
*
aContext
)
:
nsFrame
(
aContext
kClassID
)
mInstanceOwner
(
nullptr
)
mOuterView
(
nullptr
)
mInnerView
(
nullptr
)
mBackgroundSink
(
nullptr
)
mReflowCallbackPosted
(
false
)
{
MOZ_LOG
(
sPluginFrameLog
LogLevel
:
:
Debug
(
"
Created
new
nsPluginFrame
%
p
\
n
"
this
)
)
;
}
nsPluginFrame
:
:
~
nsPluginFrame
(
)
{
MOZ_LOG
(
sPluginFrameLog
LogLevel
:
:
Debug
(
"
nsPluginFrame
%
p
deleted
\
n
"
this
)
)
;
}
NS_QUERYFRAME_HEAD
(
nsPluginFrame
)
NS_QUERYFRAME_ENTRY
(
nsPluginFrame
)
NS_QUERYFRAME_ENTRY
(
nsIObjectFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsFrame
)
#
ifdef
ACCESSIBILITY
a11y
:
:
AccType
nsPluginFrame
:
:
AccessibleType
(
)
{
return
a11y
:
:
ePluginType
;
}
#
ifdef
XP_WIN
NS_IMETHODIMP
nsPluginFrame
:
:
GetPluginPort
(
HWND
*
aPort
)
{
*
aPort
=
(
HWND
)
mInstanceOwner
-
>
GetPluginPort
(
)
;
return
NS_OK
;
}
#
endif
#
endif
void
nsPluginFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
MOZ_LOG
(
sPluginFrameLog
LogLevel
:
:
Debug
(
"
Initializing
nsPluginFrame
%
p
for
content
%
p
\
n
"
this
aContent
)
)
;
nsFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
CreateView
(
)
;
}
void
nsPluginFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestructRoot
)
{
if
(
mReflowCallbackPosted
)
{
PresContext
(
)
-
>
PresShell
(
)
-
>
CancelReflowCallback
(
this
)
;
}
mDidCompositeObserver
=
nullptr
;
nsCOMPtr
<
nsIObjectLoadingContent
>
objContent
(
do_QueryInterface
(
mContent
)
)
;
NS_ASSERTION
(
objContent
"
Why
not
an
object
loading
content
?
"
)
;
if
(
mInstanceOwner
)
{
mInstanceOwner
-
>
SetFrame
(
nullptr
)
;
}
objContent
-
>
HasNewFrame
(
nullptr
)
;
if
(
mBackgroundSink
)
{
mBackgroundSink
-
>
Destroy
(
)
;
}
nsFrame
:
:
DestroyFrom
(
aDestructRoot
)
;
}
void
nsPluginFrame
:
:
DidSetStyleContext
(
nsStyleContext
*
aOldStyleContext
)
{
if
(
HasView
(
)
)
{
nsView
*
view
=
GetView
(
)
;
nsViewManager
*
vm
=
view
-
>
GetViewManager
(
)
;
if
(
vm
)
{
nsViewVisibility
visibility
=
IsHidden
(
)
?
nsViewVisibility_kHide
:
nsViewVisibility_kShow
;
vm
-
>
SetViewVisibility
(
view
visibility
)
;
}
}
nsFrame
:
:
DidSetStyleContext
(
aOldStyleContext
)
;
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
nsPluginFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
NS_LITERAL_STRING
(
"
PluginFrame
"
)
aResult
)
;
}
#
endif
nsresult
nsPluginFrame
:
:
PrepForDrawing
(
nsIWidget
*
aWidget
)
{
mWidget
=
aWidget
;
nsView
*
view
=
GetView
(
)
;
NS_ASSERTION
(
view
"
Object
frames
must
have
views
"
)
;
if
(
!
view
)
{
return
NS_ERROR_FAILURE
;
}
nsViewManager
*
viewMan
=
view
-
>
GetViewManager
(
)
;
viewMan
-
>
SetViewVisibility
(
view
nsViewVisibility_kHide
)
;
nsView
*
parentWithView
;
nsPoint
origin
;
nsRect
r
(
0
0
mRect
.
width
mRect
.
height
)
;
GetOffsetFromView
(
origin
&
parentWithView
)
;
viewMan
-
>
ResizeView
(
view
r
)
;
viewMan
-
>
MoveViewTo
(
view
origin
.
x
origin
.
y
)
;
nsPresContext
*
presContext
=
PresContext
(
)
;
nsRootPresContext
*
rpc
=
presContext
-
>
GetRootPresContext
(
)
;
if
(
!
rpc
)
{
return
NS_ERROR_FAILURE
;
}
if
(
mWidget
)
{
nsIFrame
*
rootFrame
=
rpc
-
>
PresShell
(
)
-
>
FrameManager
(
)
-
>
GetRootFrame
(
)
;
nsIWidget
*
parentWidget
=
rootFrame
-
>
GetNearestWidget
(
)
;
if
(
!
parentWidget
|
|
nsLayoutUtils
:
:
GetDisplayRootFrame
(
this
)
!
=
rootFrame
)
{
return
NS_ERROR_FAILURE
;
}
if
(
mInnerView
)
{
if
(
mInnerView
-
>
GetWidget
(
)
)
{
MOZ_RELEASE_ASSERT
(
mInnerView
-
>
GetWidget
(
)
-
>
GetWidgetListener
(
)
=
=
nullptr
)
;
}
mInnerView
-
>
Destroy
(
)
;
mInnerView
=
nullptr
;
}
mInnerView
=
viewMan
-
>
CreateView
(
GetContentRectRelativeToSelf
(
)
view
)
;
if
(
!
mInnerView
)
{
NS_ERROR
(
"
Could
not
create
inner
view
"
)
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
viewMan
-
>
InsertChild
(
view
mInnerView
nullptr
true
)
;
mWidget
-
>
SetParent
(
parentWidget
)
;
mWidget
-
>
Enable
(
true
)
;
mWidget
-
>
Show
(
true
)
;
AutoTArray
<
nsIWidget
:
:
Configuration
1
>
configurations
;
nsIWidget
:
:
Configuration
*
configuration
=
configurations
.
AppendElement
(
)
;
nscoord
appUnitsPerDevPixel
=
presContext
-
>
AppUnitsPerDevPixel
(
)
;
configuration
-
>
mChild
=
mWidget
;
configuration
-
>
mBounds
.
width
=
NSAppUnitsToIntPixels
(
mRect
.
width
appUnitsPerDevPixel
)
;
configuration
-
>
mBounds
.
height
=
NSAppUnitsToIntPixels
(
mRect
.
height
appUnitsPerDevPixel
)
;
parentWidget
-
>
ConfigureChildren
(
configurations
)
;
mInnerView
-
>
AttachWidgetEventHandler
(
mWidget
)
;
#
ifdef
XP_MACOSX
if
(
parentWidget
=
=
GetNearestWidget
(
)
)
{
InvalidateFrame
(
)
;
}
#
endif
RegisterPluginForGeometryUpdates
(
)
;
for
(
nsIFrame
*
frame
=
this
;
frame
;
frame
=
frame
-
>
GetParent
(
)
)
{
nscolor
bgcolor
=
frame
-
>
GetVisitedDependentColor
(
&
nsStyleBackground
:
:
mBackgroundColor
)
;
if
(
NS_GET_A
(
bgcolor
)
>
0
)
{
mWidget
-
>
SetBackgroundColor
(
bgcolor
)
;
break
;
}
}
}
else
{
FixupWindow
(
GetContentRectRelativeToSelf
(
)
.
Size
(
)
)
;
RegisterPluginForGeometryUpdates
(
)
;
}
if
(
!
IsHidden
(
)
)
{
viewMan
-
>
SetViewVisibility
(
view
nsViewVisibility_kShow
)
;
}
#
ifdef
ACCESSIBILITY
nsAccessibilityService
*
accService
=
nsIPresShell
:
:
AccService
(
)
;
if
(
accService
)
{
accService
-
>
RecreateAccessible
(
PresContext
(
)
-
>
PresShell
(
)
mContent
)
;
}
#
endif
return
NS_OK
;
}
#
define
EMBED_DEF_WIDTH
240
#
define
EMBED_DEF_HEIGHT
200
nscoord
nsPluginFrame
:
:
GetMinISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
result
=
0
;
if
(
!
IsHidden
(
false
)
)
{
if
(
mContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
embed
)
)
{
bool
vertical
=
GetWritingMode
(
)
.
IsVertical
(
)
;
result
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
vertical
?
EMBED_DEF_HEIGHT
:
EMBED_DEF_WIDTH
)
;
}
}
DISPLAY_MIN_WIDTH
(
this
result
)
;
return
result
;
}
nscoord
nsPluginFrame
:
:
GetPrefISize
(
gfxContext
*
aRenderingContext
)
{
return
nsPluginFrame
:
:
GetMinISize
(
aRenderingContext
)
;
}
void
nsPluginFrame
:
:
GetWidgetConfiguration
(
nsTArray
<
nsIWidget
:
:
Configuration
>
*
aConfigurations
)
{
if
(
!
mWidget
)
{
return
;
}
if
(
!
mWidget
-
>
GetParent
(
)
)
{
NS_ERROR
(
"
Plugin
widgets
registered
for
geometry
updates
should
not
be
toplevel
"
)
;
return
;
}
nsIWidget
:
:
Configuration
*
configuration
=
aConfigurations
-
>
AppendElement
(
)
;
configuration
-
>
mChild
=
mWidget
;
configuration
-
>
mBounds
=
mNextConfigurationBounds
;
configuration
-
>
mClipRegion
=
mNextConfigurationClipRegion
;
#
if
defined
(
XP_WIN
)
|
|
defined
(
MOZ_WIDGET_GTK
)
if
(
XRE_IsContentProcess
(
)
)
{
configuration
-
>
mWindowID
=
(
uintptr_t
)
mWidget
-
>
GetNativeData
(
NS_NATIVE_PLUGIN_PORT
)
;
configuration
-
>
mVisible
=
mWidget
-
>
IsVisible
(
)
;
}
#
endif
}
void
nsPluginFrame
:
:
GetDesiredSize
(
nsPresContext
*
aPresContext
const
ReflowInput
&
aReflowInput
ReflowOutput
&
aMetrics
)
{
aMetrics
.
ClearSize
(
)
;
if
(
IsHidden
(
false
)
)
{
return
;
}
aMetrics
.
Width
(
)
=
aReflowInput
.
ComputedWidth
(
)
;
aMetrics
.
Height
(
)
=
aReflowInput
.
ComputedHeight
(
)
;
if
(
mContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
embed
)
)
{
if
(
aMetrics
.
Width
(
)
=
=
NS_UNCONSTRAINEDSIZE
)
{
aMetrics
.
Width
(
)
=
clamped
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
EMBED_DEF_WIDTH
)
aReflowInput
.
ComputedMinWidth
(
)
aReflowInput
.
ComputedMaxWidth
(
)
)
;
}
if
(
aMetrics
.
Height
(
)
=
=
NS_UNCONSTRAINEDSIZE
)
{
aMetrics
.
Height
(
)
=
clamped
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
EMBED_DEF_HEIGHT
)
aReflowInput
.
ComputedMinHeight
(
)
aReflowInput
.
ComputedMaxHeight
(
)
)
;
}
#
if
defined
(
MOZ_WIDGET_GTK
)
aMetrics
.
Height
(
)
=
std
:
:
min
(
aPresContext
-
>
DevPixelsToAppUnits
(
INT16_MAX
)
aMetrics
.
Height
(
)
)
;
aMetrics
.
Width
(
)
=
std
:
:
min
(
aPresContext
-
>
DevPixelsToAppUnits
(
INT16_MAX
)
aMetrics
.
Width
(
)
)
;
#
endif
}
if
(
aMetrics
.
Width
(
)
=
=
NS_UNCONSTRAINEDSIZE
)
{
aMetrics
.
Width
(
)
=
(
aReflowInput
.
ComputedMinWidth
(
)
!
=
NS_UNCONSTRAINEDSIZE
)
?
aReflowInput
.
ComputedMinWidth
(
)
:
0
;
}
if
(
aMetrics
.
Height
(
)
=
=
NS_UNCONSTRAINEDSIZE
)
{
aMetrics
.
Height
(
)
=
(
aReflowInput
.
ComputedMinHeight
(
)
!
=
NS_UNCONSTRAINEDSIZE
)
?
aReflowInput
.
ComputedMinHeight
(
)
:
0
;
}
}
void
nsPluginFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aMetrics
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsPluginFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aMetrics
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
GetDesiredSize
(
aPresContext
aReflowInput
aMetrics
)
;
aMetrics
.
SetOverflowAreasToDesiredBounds
(
)
;
FinishAndStoreOverflow
(
&
aMetrics
)
;
if
(
!
GetContent
(
)
-
>
IsDoneAddingChildren
(
)
)
{
return
;
}
if
(
aPresContext
-
>
Medium
(
)
=
=
nsGkAtoms
:
:
print
)
{
return
;
}
nsRect
r
(
0
0
aMetrics
.
Width
(
)
aMetrics
.
Height
(
)
)
;
r
.
Deflate
(
aReflowInput
.
ComputedPhysicalBorderPadding
(
)
)
;
if
(
mInnerView
)
{
nsViewManager
*
vm
=
mInnerView
-
>
GetViewManager
(
)
;
vm
-
>
MoveViewTo
(
mInnerView
r
.
x
r
.
y
)
;
vm
-
>
ResizeView
(
mInnerView
nsRect
(
nsPoint
(
0
0
)
r
.
Size
(
)
)
true
)
;
}
FixupWindow
(
r
.
Size
(
)
)
;
if
(
!
mReflowCallbackPosted
)
{
mReflowCallbackPosted
=
true
;
aPresContext
-
>
PresShell
(
)
-
>
PostReflowCallback
(
this
)
;
}
NS_FRAME_SET_TRUNCATION
(
aStatus
aReflowInput
aMetrics
)
;
}
bool
nsPluginFrame
:
:
ReflowFinished
(
)
{
mReflowCallbackPosted
=
false
;
CallSetWindow
(
)
;
return
true
;
}
void
nsPluginFrame
:
:
ReflowCallbackCanceled
(
)
{
mReflowCallbackPosted
=
false
;
}
void
nsPluginFrame
:
:
FixupWindow
(
const
nsSize
&
aSize
)
{
nsPresContext
*
presContext
=
PresContext
(
)
;
if
(
!
mInstanceOwner
)
return
;
NPWindow
*
window
;
mInstanceOwner
-
>
GetWindow
(
window
)
;
NS_ENSURE_TRUE_VOID
(
window
)
;
bool
windowless
=
(
window
-
>
type
=
=
NPWindowTypeDrawable
)
;
nsIntPoint
origin
=
GetWindowOriginInPixels
(
windowless
)
;
#
if
defined
(
XP_MACOSX
)
double
scaleFactor
=
1
.
0
;
if
(
NS_FAILED
(
mInstanceOwner
-
>
GetContentsScaleFactor
(
&
scaleFactor
)
)
)
{
scaleFactor
=
1
.
0
;
}
int
intScaleFactor
=
ceil
(
scaleFactor
)
;
window
-
>
x
=
origin
.
x
/
intScaleFactor
;
window
-
>
y
=
origin
.
y
/
intScaleFactor
;
window
-
>
width
=
presContext
-
>
AppUnitsToDevPixels
(
aSize
.
width
)
/
intScaleFactor
;
window
-
>
height
=
presContext
-
>
AppUnitsToDevPixels
(
aSize
.
height
)
/
intScaleFactor
;
#
else
window
-
>
x
=
origin
.
x
;
window
-
>
y
=
origin
.
y
;
window
-
>
width
=
presContext
-
>
AppUnitsToDevPixels
(
aSize
.
width
)
;
window
-
>
height
=
presContext
-
>
AppUnitsToDevPixels
(
aSize
.
height
)
;
#
endif
#
ifndef
XP_MACOSX
mInstanceOwner
-
>
UpdateWindowPositionAndClipRect
(
false
)
;
#
endif
NotifyPluginReflowObservers
(
)
;
}
nsresult
nsPluginFrame
:
:
CallSetWindow
(
bool
aCheckIsHidden
)
{
NPWindow
*
win
=
nullptr
;
nsresult
rv
=
NS_ERROR_FAILURE
;
RefPtr
<
nsNPAPIPluginInstance
>
pi
;
if
(
!
mInstanceOwner
|
|
NS_FAILED
(
rv
=
mInstanceOwner
-
>
GetInstance
(
getter_AddRefs
(
pi
)
)
)
|
|
!
pi
|
|
NS_FAILED
(
rv
=
mInstanceOwner
-
>
GetWindow
(
win
)
)
|
|
!
win
)
return
rv
;
nsPluginNativeWindow
*
window
=
(
nsPluginNativeWindow
*
)
win
;
if
(
aCheckIsHidden
&
&
IsHidden
(
)
)
return
NS_ERROR_FAILURE
;
RefPtr
<
nsPluginInstanceOwner
>
instanceOwnerRef
(
mInstanceOwner
)
;
#
ifdef
XP_MACOSX
mInstanceOwner
-
>
FixUpPluginWindow
(
nsPluginInstanceOwner
:
:
ePluginPaintEnable
)
;
if
(
!
instanceOwnerRef
-
>
GetFrame
(
)
)
{
return
NS_ERROR_FAILURE
;
}
#
endif
window
-
>
window
=
mInstanceOwner
-
>
GetPluginPort
(
)
;
nsPresContext
*
presContext
=
PresContext
(
)
;
nsRootPresContext
*
rootPC
=
presContext
-
>
GetRootPresContext
(
)
;
if
(
!
rootPC
)
return
NS_ERROR_FAILURE
;
int32_t
appUnitsPerDevPixel
=
presContext
-
>
AppUnitsPerDevPixel
(
)
;
nsIFrame
*
rootFrame
=
rootPC
-
>
PresShell
(
)
-
>
FrameManager
(
)
-
>
GetRootFrame
(
)
;
nsRect
bounds
=
GetContentRectRelativeToSelf
(
)
+
GetOffsetToCrossDoc
(
rootFrame
)
;
nsIntRect
intBounds
=
bounds
.
ToNearestPixels
(
appUnitsPerDevPixel
)
;
LayoutDeviceIntPoint
intOffset
=
GetRemoteTabChromeOffset
(
)
;
intBounds
.
x
+
=
intOffset
.
x
;
intBounds
.
y
+
=
intOffset
.
y
;
#
if
defined
(
XP_MACOSX
)
double
scaleFactor
=
1
.
0
;
if
(
NS_FAILED
(
instanceOwnerRef
-
>
GetContentsScaleFactor
(
&
scaleFactor
)
)
)
{
scaleFactor
=
1
.
0
;
}
size_t
intScaleFactor
=
ceil
(
scaleFactor
)
;
window
-
>
x
=
intBounds
.
x
/
intScaleFactor
;
window
-
>
y
=
intBounds
.
y
/
intScaleFactor
;
window
-
>
width
=
intBounds
.
width
/
intScaleFactor
;
window
-
>
height
=
intBounds
.
height
/
intScaleFactor
;
#
else
window
-
>
x
=
intBounds
.
x
;
window
-
>
y
=
intBounds
.
y
;
window
-
>
width
=
intBounds
.
width
;
window
-
>
height
=
intBounds
.
height
;
#
endif
instanceOwnerRef
-
>
ResolutionMayHaveChanged
(
)
;
if
(
instanceOwnerRef
-
>
UseAsyncRendering
(
)
)
{
rv
=
pi
-
>
AsyncSetWindow
(
window
)
;
}
else
{
rv
=
window
-
>
CallSetWindow
(
pi
)
;
}
instanceOwnerRef
-
>
ReleasePluginPort
(
window
-
>
window
)
;
return
rv
;
}
void
nsPluginFrame
:
:
RegisterPluginForGeometryUpdates
(
)
{
nsRootPresContext
*
rpc
=
PresContext
(
)
-
>
GetRootPresContext
(
)
;
NS_ASSERTION
(
rpc
"
We
should
have
a
root
pres
context
!
"
)
;
if
(
mRootPresContextRegisteredWith
=
=
rpc
|
|
!
rpc
)
{
return
;
}
if
(
mRootPresContextRegisteredWith
&
&
mRootPresContextRegisteredWith
!
=
rpc
)
{
UnregisterPluginForGeometryUpdates
(
)
;
}
mRootPresContextRegisteredWith
=
rpc
;
mRootPresContextRegisteredWith
-
>
RegisterPluginForGeometryUpdates
(
mContent
)
;
}
void
nsPluginFrame
:
:
UnregisterPluginForGeometryUpdates
(
)
{
if
(
!
mRootPresContextRegisteredWith
)
{
return
;
}
mRootPresContextRegisteredWith
-
>
UnregisterPluginForGeometryUpdates
(
mContent
)
;
mRootPresContextRegisteredWith
=
nullptr
;
}
void
nsPluginFrame
:
:
SetInstanceOwner
(
nsPluginInstanceOwner
*
aOwner
)
{
mInstanceOwner
=
aOwner
;
mDidCompositeObserver
=
nullptr
;
if
(
mInstanceOwner
)
{
return
;
}
UnregisterPluginForGeometryUpdates
(
)
;
if
(
mWidget
&
&
mInnerView
)
{
mInnerView
-
>
DetachWidgetEventHandler
(
mWidget
)
;
nsIWidget
*
parent
=
mWidget
-
>
GetParent
(
)
;
if
(
parent
)
{
nsTArray
<
nsIWidget
:
:
Configuration
>
configurations
;
nsIWidget
:
:
Configuration
*
configuration
=
configurations
.
AppendElement
(
)
;
configuration
-
>
mChild
=
mWidget
;
parent
-
>
ConfigureChildren
(
configurations
)
;
mWidget
-
>
Show
(
false
)
;
mWidget
-
>
Enable
(
false
)
;
mWidget
-
>
SetParent
(
nullptr
)
;
}
}
}
bool
nsPluginFrame
:
:
IsFocusable
(
int32_t
*
aTabIndex
bool
aWithMouse
)
{
if
(
aTabIndex
)
*
aTabIndex
=
-
1
;
return
nsFrame
:
:
IsFocusable
(
aTabIndex
aWithMouse
)
;
}
bool
nsPluginFrame
:
:
IsHidden
(
bool
aCheckVisibilityStyle
)
const
{
if
(
aCheckVisibilityStyle
)
{
if
(
!
StyleVisibility
(
)
-
>
IsVisibleOrCollapsed
(
)
)
return
true
;
}
if
(
mContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
embed
)
)
{
nsAutoString
hidden
;
if
(
mContent
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
hidden
hidden
)
&
&
(
hidden
.
IsEmpty
(
)
|
|
(
!
hidden
.
LowerCaseEqualsLiteral
(
"
false
"
)
&
&
!
hidden
.
LowerCaseEqualsLiteral
(
"
no
"
)
&
&
!
hidden
.
LowerCaseEqualsLiteral
(
"
off
"
)
)
)
)
{
return
true
;
}
}
return
false
;
}
mozilla
:
:
LayoutDeviceIntPoint
nsPluginFrame
:
:
GetRemoteTabChromeOffset
(
)
{
LayoutDeviceIntPoint
offset
;
if
(
XRE_IsContentProcess
(
)
)
{
if
(
nsPIDOMWindowOuter
*
window
=
GetContent
(
)
-
>
OwnerDoc
(
)
-
>
GetWindow
(
)
)
{
if
(
nsCOMPtr
<
nsPIDOMWindowOuter
>
topWindow
=
window
-
>
GetTop
(
)
)
{
dom
:
:
TabChild
*
tc
=
dom
:
:
TabChild
:
:
GetFrom
(
topWindow
)
;
if
(
tc
)
{
offset
+
=
tc
-
>
GetChromeDisplacement
(
)
;
}
}
}
}
return
offset
;
}
nsIntPoint
nsPluginFrame
:
:
GetWindowOriginInPixels
(
bool
aWindowless
)
{
nsView
*
parentWithView
;
nsPoint
origin
(
0
0
)
;
GetOffsetFromView
(
origin
&
parentWithView
)
;
if
(
aWindowless
&
&
parentWithView
)
{
nsPoint
offsetToWidget
;
parentWithView
-
>
GetNearestWidget
(
&
offsetToWidget
)
;
origin
+
=
offsetToWidget
;
}
origin
+
=
GetContentRectRelativeToSelf
(
)
.
TopLeft
(
)
;
nsIntPoint
pt
(
PresContext
(
)
-
>
AppUnitsToDevPixels
(
origin
.
x
)
PresContext
(
)
-
>
AppUnitsToDevPixels
(
origin
.
y
)
)
;
if
(
aWindowless
)
{
mozilla
:
:
LayoutDeviceIntPoint
lpt
=
GetRemoteTabChromeOffset
(
)
;
pt
+
=
nsIntPoint
(
lpt
.
x
lpt
.
y
)
;
}
return
pt
;
}
void
nsPluginFrame
:
:
DidReflow
(
nsPresContext
*
aPresContext
const
ReflowInput
*
aReflowInput
nsDidReflowStatus
aStatus
)
{
if
(
aStatus
=
=
nsDidReflowStatus
:
:
FINISHED
&
&
(
GetStateBits
(
)
&
NS_FRAME_FIRST_REFLOW
)
)
{
nsCOMPtr
<
nsIObjectLoadingContent
>
objContent
(
do_QueryInterface
(
mContent
)
)
;
NS_ASSERTION
(
objContent
"
Why
not
an
object
loading
content
?
"
)
;
objContent
-
>
HasNewFrame
(
this
)
;
}
nsFrame
:
:
DidReflow
(
aPresContext
aReflowInput
aStatus
)
;
if
(
aStatus
!
=
nsDidReflowStatus
:
:
FINISHED
)
return
;
if
(
HasView
(
)
)
{
nsView
*
view
=
GetView
(
)
;
nsViewManager
*
vm
=
view
-
>
GetViewManager
(
)
;
if
(
vm
)
vm
-
>
SetViewVisibility
(
view
IsHidden
(
)
?
nsViewVisibility_kHide
:
nsViewVisibility_kShow
)
;
}
}
void
nsPluginFrame
:
:
PaintPrintPlugin
(
nsIFrame
*
aFrame
gfxContext
*
aCtx
const
nsRect
&
aDirtyRect
nsPoint
aPt
)
{
nsPoint
pt
=
aPt
+
aFrame
-
>
GetContentRectRelativeToSelf
(
)
.
TopLeft
(
)
;
gfxPoint
devPixelPt
=
nsLayoutUtils
:
:
PointToGfxPoint
(
pt
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
gfxContextMatrixAutoSaveRestore
autoSR
(
aCtx
)
;
aCtx
-
>
SetMatrix
(
aCtx
-
>
CurrentMatrix
(
)
.
PreTranslate
(
devPixelPt
)
)
;
static_cast
<
nsPluginFrame
*
>
(
aFrame
)
-
>
PrintPlugin
(
*
aCtx
aDirtyRect
)
;
}
class
nsDisplayPluginReadback
:
public
nsDisplayItem
{
public
:
nsDisplayPluginReadback
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
:
nsDisplayItem
(
aBuilder
aFrame
)
{
MOZ_COUNT_CTOR
(
nsDisplayPluginReadback
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
~
nsDisplayPluginReadback
(
)
override
{
MOZ_COUNT_DTOR
(
nsDisplayPluginReadback
)
;
}
#
endif
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
NS_DISPLAY_DECL_NAME
(
"
PluginReadback
"
TYPE_PLUGIN_READBACK
)
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
{
return
static_cast
<
nsPluginFrame
*
>
(
mFrame
)
-
>
BuildLayer
(
aBuilder
aManager
this
aContainerParameters
)
;
}
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
{
return
LAYER_ACTIVE
;
}
}
;
static
nsRect
GetDisplayItemBounds
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItem
*
aItem
nsIFrame
*
aFrame
)
{
return
aFrame
-
>
GetContentRectRelativeToSelf
(
)
+
aItem
-
>
ToReferenceFrame
(
)
;
}
nsRect
nsDisplayPluginReadback
:
:
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
{
*
aSnap
=
false
;
return
GetDisplayItemBounds
(
aBuilder
this
mFrame
)
;
}
nsRect
nsDisplayPlugin
:
:
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
{
*
aSnap
=
true
;
return
GetDisplayItemBounds
(
aBuilder
this
mFrame
)
;
}
void
nsDisplayPlugin
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
nsPluginFrame
*
f
=
static_cast
<
nsPluginFrame
*
>
(
mFrame
)
;
bool
snap
;
f
-
>
PaintPlugin
(
aBuilder
*
aCtx
mVisibleRect
GetBounds
(
aBuilder
&
snap
)
)
;
}
static
nsRect
GetClippedBoundsIncludingAllScrollClips
(
nsDisplayItem
*
aItem
nsDisplayListBuilder
*
aBuilder
)
{
nsRect
r
=
aItem
-
>
GetClippedBounds
(
aBuilder
)
;
for
(
auto
*
sc
=
aItem
-
>
GetClipChain
(
)
;
sc
;
sc
=
sc
-
>
mParent
)
{
r
=
sc
-
>
mClip
.
ApplyNonRoundedIntersection
(
r
)
;
}
return
r
;
}
bool
nsDisplayPlugin
:
:
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
{
if
(
aBuilder
-
>
IsForPluginGeometry
(
)
)
{
nsPluginFrame
*
f
=
static_cast
<
nsPluginFrame
*
>
(
mFrame
)
;
if
(
!
aBuilder
-
>
IsInTransform
(
)
|
|
f
-
>
IsPaintedByGecko
(
)
)
{
nsRect
rAncestor
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
f
f
-
>
GetContentRectRelativeToSelf
(
)
ReferenceFrame
(
)
)
;
nscoord
appUnitsPerDevPixel
=
ReferenceFrame
(
)
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
f
-
>
mNextConfigurationBounds
=
LayoutDeviceIntRect
:
:
FromUnknownRect
(
rAncestor
.
ToNearestPixels
(
appUnitsPerDevPixel
)
)
;
nsRegion
visibleRegion
;
visibleRegion
.
And
(
*
aVisibleRegion
GetClippedBoundsIncludingAllScrollClips
(
this
aBuilder
)
)
;
visibleRegion
.
MoveBy
(
-
ToReferenceFrame
(
)
)
;
f
-
>
mNextConfigurationClipRegion
.
Clear
(
)
;
for
(
auto
iter
=
visibleRegion
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsRect
rAncestor
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
f
iter
.
Get
(
)
ReferenceFrame
(
)
)
;
LayoutDeviceIntRect
rPixels
=
LayoutDeviceIntRect
:
:
FromUnknownRect
(
rAncestor
.
ToNearestPixels
(
appUnitsPerDevPixel
)
)
-
f
-
>
mNextConfigurationBounds
.
TopLeft
(
)
;
if
(
!
rPixels
.
IsEmpty
(
)
)
{
f
-
>
mNextConfigurationClipRegion
.
AppendElement
(
rPixels
)
;
}
}
}
if
(
f
-
>
mInnerView
)
{
f
-
>
mInnerView
-
>
CalcWidgetBounds
(
eWindowType_plugin
)
;
}
}
return
nsDisplayItem
:
:
ComputeVisibility
(
aBuilder
aVisibleRegion
)
;
}
nsRegion
nsDisplayPlugin
:
:
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
{
*
aSnap
=
false
;
nsRegion
result
;
nsPluginFrame
*
f
=
static_cast
<
nsPluginFrame
*
>
(
mFrame
)
;
if
(
!
aBuilder
-
>
IsForPluginGeometry
(
)
)
{
nsIWidget
*
widget
=
f
-
>
GetWidget
(
)
;
if
(
widget
)
{
return
result
;
}
}
if
(
f
-
>
IsOpaque
(
)
)
{
nsRect
bounds
=
GetBounds
(
aBuilder
aSnap
)
;
if
(
aBuilder
-
>
IsForPluginGeometry
(
)
|
|
(
f
-
>
GetPaintedRect
(
this
)
+
ToReferenceFrame
(
)
)
.
Contains
(
bounds
)
)
{
result
=
bounds
;
}
}
return
result
;
}
bool
nsDisplayPlugin
:
:
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
nsTArray
<
WebRenderParentCommand
>
&
aParentCommands
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
return
static_cast
<
nsPluginFrame
*
>
(
mFrame
)
-
>
CreateWebRenderCommands
(
this
aBuilder
aResources
aSc
aManager
aDisplayListBuilder
)
;
}
nsresult
nsPluginFrame
:
:
PluginEventNotifier
:
:
Run
(
)
{
nsCOMPtr
<
nsIObserverService
>
obsSvc
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
obsSvc
-
>
NotifyObservers
(
nullptr
"
plugin
-
changed
-
event
"
mEventType
.
get
(
)
)
;
return
NS_OK
;
}
void
nsPluginFrame
:
:
NotifyPluginReflowObservers
(
)
{
nsContentUtils
:
:
AddScriptRunner
(
new
PluginEventNotifier
(
NS_LITERAL_STRING
(
"
reflow
"
)
)
)
;
}
void
nsPluginFrame
:
:
DidSetWidgetGeometry
(
)
{
#
if
defined
(
XP_MACOSX
)
if
(
mInstanceOwner
&
&
!
IsHidden
(
)
)
{
mInstanceOwner
-
>
FixUpPluginWindow
(
nsPluginInstanceOwner
:
:
ePluginPaintEnable
)
;
}
#
else
if
(
!
mWidget
&
&
mInstanceOwner
)
{
mInstanceOwner
-
>
UpdateWindowVisibility
(
nsLayoutUtils
:
:
IsPopup
(
nsLayoutUtils
:
:
GetDisplayRootFrame
(
this
)
)
|
|
!
mNextConfigurationBounds
.
IsEmpty
(
)
)
;
}
#
endif
}
bool
nsPluginFrame
:
:
IsOpaque
(
)
const
{
#
if
defined
(
XP_MACOSX
)
return
false
;
#
else
if
(
mInstanceOwner
&
&
mInstanceOwner
-
>
UseAsyncRendering
(
)
)
{
return
false
;
}
return
!
IsTransparentMode
(
)
;
#
endif
}
bool
nsPluginFrame
:
:
IsTransparentMode
(
)
const
{
#
if
defined
(
XP_MACOSX
)
return
false
;
#
else
if
(
!
mInstanceOwner
)
return
false
;
NPWindow
*
window
=
nullptr
;
mInstanceOwner
-
>
GetWindow
(
window
)
;
if
(
!
window
)
{
return
false
;
}
if
(
window
-
>
type
!
=
NPWindowTypeDrawable
)
return
false
;
nsresult
rv
;
RefPtr
<
nsNPAPIPluginInstance
>
pi
;
rv
=
mInstanceOwner
-
>
GetInstance
(
getter_AddRefs
(
pi
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
pi
)
return
false
;
bool
transparent
=
false
;
pi
-
>
IsTransparent
(
&
transparent
)
;
return
transparent
;
#
endif
}
void
nsPluginFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
if
(
!
IsVisibleOrCollapsedForPainting
(
aBuilder
)
)
return
;
DisplayBorderBackgroundOutline
(
aBuilder
aLists
)
;
nsPresContext
:
:
nsPresContextType
type
=
PresContext
(
)
-
>
Type
(
)
;
if
(
type
=
=
nsPresContext
:
:
eContext_PrintPreview
)
return
;
DO_GLOBAL_REFLOW_COUNT_DSP
(
"
nsPluginFrame
"
)
;
#
ifndef
XP_MACOSX
if
(
mWidget
&
&
aBuilder
-
>
IsInTransform
(
)
)
{
return
;
}
#
endif
if
(
aBuilder
-
>
IsForPainting
(
)
&
&
mInstanceOwner
)
{
mInstanceOwner
-
>
ResolutionMayHaveChanged
(
)
;
#
ifdef
XP_MACOSX
mInstanceOwner
-
>
WindowFocusMayHaveChanged
(
)
;
#
endif
if
(
mInstanceOwner
-
>
UseAsyncRendering
(
)
)
{
NPWindow
*
window
=
nullptr
;
mInstanceOwner
-
>
GetWindow
(
window
)
;
bool
isVisible
=
window
&
&
window
-
>
width
>
0
&
&
window
-
>
height
>
0
;
if
(
isVisible
&
&
aBuilder
-
>
ShouldSyncDecodeImages
(
)
)
{
#
ifndef
XP_MACOSX
mInstanceOwner
-
>
UpdateWindowVisibility
(
true
)
;
#
endif
}
mInstanceOwner
-
>
NotifyPaintWaiter
(
aBuilder
)
;
}
}
DisplayListClipState
:
:
AutoClipContainingBlockDescendantsToContentBox
clip
(
aBuilder
this
)
;
if
(
type
=
=
nsPresContext
:
:
eContext_Print
)
{
aLists
.
Content
(
)
-
>
AppendNewToTop
(
new
(
aBuilder
)
nsDisplayGeneric
(
aBuilder
this
PaintPrintPlugin
"
PrintPlugin
"
DisplayItemType
:
:
TYPE_PRINT_PLUGIN
)
)
;
}
else
{
LayerState
state
=
GetLayerState
(
aBuilder
nullptr
)
;
if
(
state
=
=
LAYER_INACTIVE
&
&
nsDisplayItem
:
:
ForceActiveLayers
(
)
)
{
state
=
LAYER_ACTIVE
;
}
if
(
aBuilder
-
>
IsPaintingToWindow
(
)
&
&
state
=
=
LAYER_ACTIVE
&
&
IsTransparentMode
(
)
)
{
aLists
.
Content
(
)
-
>
AppendNewToTop
(
new
(
aBuilder
)
nsDisplayPluginReadback
(
aBuilder
this
)
)
;
}
aLists
.
Content
(
)
-
>
AppendNewToTop
(
new
(
aBuilder
)
nsDisplayPlugin
(
aBuilder
this
)
)
;
}
}
void
nsPluginFrame
:
:
PrintPlugin
(
gfxContext
&
aRenderingContext
const
nsRect
&
aDirtyRect
)
{
nsCOMPtr
<
nsIObjectLoadingContent
>
obj
(
do_QueryInterface
(
mContent
)
)
;
if
(
!
obj
)
return
;
nsIFrame
*
frame
=
nullptr
;
obj
-
>
GetPrintFrame
(
&
frame
)
;
if
(
!
frame
)
return
;
nsPresContext
*
presContext
=
PresContext
(
)
;
nsIObjectFrame
*
objectFrame
=
do_QueryFrame
(
frame
)
;
if
(
!
objectFrame
)
objectFrame
=
GetNextObjectFrame
(
presContext
frame
)
;
if
(
!
objectFrame
)
return
;
RefPtr
<
nsNPAPIPluginInstance
>
pi
;
if
(
NS_FAILED
(
objectFrame
-
>
GetPluginInstance
(
getter_AddRefs
(
pi
)
)
)
|
|
!
pi
)
return
;
NPWindow
window
;
window
.
window
=
nullptr
;
NPPrint
npprint
;
npprint
.
mode
=
NP_EMBED
;
bool
windowless
=
false
;
pi
-
>
IsWindowless
(
&
windowless
)
;
window
.
type
=
windowless
?
NPWindowTypeDrawable
:
NPWindowTypeWindow
;
window
.
clipRect
.
bottom
=
0
;
window
.
clipRect
.
top
=
0
;
window
.
clipRect
.
left
=
0
;
window
.
clipRect
.
right
=
0
;
#
if
defined
(
XP_UNIX
)
|
|
defined
(
XP_MACOSX
)
(
void
)
window
;
(
void
)
npprint
;
#
elif
defined
(
XP_WIN
)
nsSize
contentSize
=
GetContentRectRelativeToSelf
(
)
.
Size
(
)
;
window
.
x
=
0
;
window
.
y
=
0
;
window
.
width
=
presContext
-
>
AppUnitsToDevPixels
(
contentSize
.
width
)
;
window
.
height
=
presContext
-
>
AppUnitsToDevPixels
(
contentSize
.
height
)
;
aRenderingContext
.
Save
(
)
;
aRenderingContext
.
NewPath
(
)
;
gfxRect
r
(
window
.
x
window
.
y
window
.
width
window
.
height
)
;
aRenderingContext
.
Rectangle
(
r
)
;
aRenderingContext
.
Clip
(
)
;
gfxWindowsNativeDrawing
nativeDraw
(
&
aRenderingContext
r
)
;
do
{
HDC
dc
=
nativeDraw
.
BeginNativeDrawing
(
)
;
if
(
!
dc
)
return
;
npprint
.
print
.
embedPrint
.
platformPrint
=
dc
;
npprint
.
print
.
embedPrint
.
window
=
window
;
pi
-
>
Print
(
&
npprint
)
;
nativeDraw
.
EndNativeDrawing
(
)
;
}
while
(
nativeDraw
.
ShouldRenderAgain
(
)
)
;
nativeDraw
.
PaintToContext
(
)
;
aRenderingContext
.
Restore
(
)
;
#
endif
nsDidReflowStatus
status
=
nsDidReflowStatus
:
:
FINISHED
;
frame
-
>
DidReflow
(
presContext
nullptr
status
)
;
}
nsRect
nsPluginFrame
:
:
GetPaintedRect
(
const
nsDisplayPlugin
*
aItem
)
const
{
if
(
!
mInstanceOwner
)
return
nsRect
(
)
;
nsRect
r
=
GetContentRectRelativeToSelf
(
)
;
if
(
!
mInstanceOwner
-
>
UseAsyncRendering
(
)
)
return
r
;
nsIntSize
size
=
mInstanceOwner
-
>
GetCurrentImageSize
(
)
;
nsPresContext
*
pc
=
PresContext
(
)
;
r
.
IntersectRect
(
r
nsRect
(
0
0
pc
-
>
DevPixelsToAppUnits
(
size
.
width
)
pc
-
>
DevPixelsToAppUnits
(
size
.
height
)
)
)
;
return
r
;
}
LayerState
nsPluginFrame
:
:
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
)
{
if
(
!
mInstanceOwner
)
return
LAYER_NONE
;
if
(
mInstanceOwner
-
>
NeedsScrollImageLayer
(
)
)
{
return
LAYER_ACTIVE
;
}
if
(
!
mInstanceOwner
-
>
UseAsyncRendering
(
)
)
{
return
LAYER_NONE
;
}
return
LAYER_ACTIVE_FORCE
;
}
class
PluginFrameDidCompositeObserver
final
:
public
DidCompositeObserver
{
public
:
PluginFrameDidCompositeObserver
(
nsPluginInstanceOwner
*
aOwner
LayerManager
*
aLayerManager
)
:
mInstanceOwner
(
aOwner
)
mLayerManager
(
aLayerManager
)
{
}
~
PluginFrameDidCompositeObserver
(
)
{
mLayerManager
-
>
RemoveDidCompositeObserver
(
this
)
;
}
void
DidComposite
(
)
override
{
mInstanceOwner
-
>
DidComposite
(
)
;
}
bool
IsValid
(
LayerManager
*
aLayerManager
)
{
return
aLayerManager
=
=
mLayerManager
;
}
private
:
nsPluginInstanceOwner
*
mInstanceOwner
;
RefPtr
<
LayerManager
>
mLayerManager
;
}
;
bool
nsPluginFrame
:
:
GetBounds
(
nsDisplayItem
*
aItem
IntSize
&
aSize
gfxRect
&
aRect
)
{
if
(
!
mInstanceOwner
)
return
false
;
NPWindow
*
window
=
nullptr
;
mInstanceOwner
-
>
GetWindow
(
window
)
;
if
(
!
window
)
return
false
;
if
(
window
-
>
width
<
=
0
|
|
window
-
>
height
<
=
0
)
return
false
;
#
if
defined
(
XP_MACOSX
)
double
scaleFactor
=
1
.
0
;
if
(
NS_FAILED
(
mInstanceOwner
-
>
GetContentsScaleFactor
(
&
scaleFactor
)
)
)
{
scaleFactor
=
1
.
0
;
}
size_t
intScaleFactor
=
ceil
(
scaleFactor
)
;
#
else
size_t
intScaleFactor
=
1
;
#
endif
aSize
=
IntSize
(
window
-
>
width
*
intScaleFactor
window
-
>
height
*
intScaleFactor
)
;
nsRect
area
=
GetContentRectRelativeToSelf
(
)
+
aItem
-
>
ToReferenceFrame
(
)
;
aRect
=
nsLayoutUtils
:
:
RectToGfxRect
(
area
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
aRect
.
Round
(
)
;
return
true
;
}
bool
nsPluginFrame
:
:
CreateWebRenderCommands
(
nsDisplayItem
*
aItem
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
IntSize
size
;
gfxRect
r
;
if
(
!
GetBounds
(
aItem
size
r
)
)
{
return
true
;
}
RefPtr
<
ImageContainer
>
container
;
container
=
mInstanceOwner
-
>
GetImageContainer
(
)
;
if
(
!
container
)
{
return
true
;
}
#
ifdef
XP_MACOSX
if
(
!
mInstanceOwner
-
>
UseAsyncRendering
(
)
)
{
mInstanceOwner
-
>
DoCocoaEventDrawRect
(
r
nullptr
)
;
}
#
endif
RefPtr
<
LayerManager
>
lm
=
aDisplayListBuilder
-
>
GetWidgetLayerManager
(
)
;
if
(
!
mDidCompositeObserver
|
|
!
mDidCompositeObserver
-
>
IsValid
(
lm
)
)
{
mDidCompositeObserver
=
MakeUnique
<
PluginFrameDidCompositeObserver
>
(
mInstanceOwner
lm
)
;
}
lm
-
>
AddDidCompositeObserver
(
mDidCompositeObserver
.
get
(
)
)
;
LayerRect
dest
(
r
.
x
r
.
y
size
.
width
size
.
height
)
;
return
aManager
-
>
PushImage
(
aItem
container
aBuilder
aResources
aSc
dest
)
;
}
already_AddRefed
<
Layer
>
nsPluginFrame
:
:
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
nsDisplayItem
*
aItem
const
ContainerLayerParameters
&
aContainerParameters
)
{
IntSize
size
;
gfxRect
r
;
if
(
!
GetBounds
(
aItem
size
r
)
)
{
return
nullptr
;
}
RefPtr
<
Layer
>
layer
=
(
aManager
-
>
GetLayerBuilder
(
)
-
>
GetLeafLayerFor
(
aBuilder
aItem
)
)
;
if
(
aItem
-
>
GetType
(
)
=
=
DisplayItemType
:
:
TYPE_PLUGIN
)
{
RefPtr
<
ImageContainer
>
container
;
container
=
mInstanceOwner
-
>
GetImageContainer
(
)
;
if
(
!
container
)
{
return
nullptr
;
}
if
(
!
layer
)
{
mInstanceOwner
-
>
NotifyPaintWaiter
(
aBuilder
)
;
layer
=
aManager
-
>
CreateImageLayer
(
)
;
if
(
!
layer
)
return
nullptr
;
}
NS_ASSERTION
(
layer
-
>
GetType
(
)
=
=
Layer
:
:
TYPE_IMAGE
"
Bad
layer
type
"
)
;
ImageLayer
*
imglayer
=
static_cast
<
ImageLayer
*
>
(
layer
.
get
(
)
)
;
#
ifdef
XP_MACOSX
if
(
!
mInstanceOwner
-
>
UseAsyncRendering
(
)
)
{
mInstanceOwner
-
>
DoCocoaEventDrawRect
(
r
nullptr
)
;
}
#
endif
imglayer
-
>
SetScaleToSize
(
size
ScaleMode
:
:
STRETCH
)
;
imglayer
-
>
SetContainer
(
container
)
;
SamplingFilter
samplingFilter
=
nsLayoutUtils
:
:
GetSamplingFilterForFrame
(
this
)
;
#
ifdef
MOZ_GFX_OPTIMIZE_MOBILE
if
(
!
aManager
-
>
IsCompositingCheap
(
)
)
{
samplingFilter
=
SamplingFilter
:
:
POINT
;
}
#
endif
imglayer
-
>
SetSamplingFilter
(
samplingFilter
)
;
layer
-
>
SetContentFlags
(
IsOpaque
(
)
?
Layer
:
:
CONTENT_OPAQUE
:
0
)
;
if
(
aBuilder
-
>
IsPaintingToWindow
(
)
&
&
aBuilder
-
>
GetWidgetLayerManager
(
)
&
&
(
aBuilder
-
>
GetWidgetLayerManager
(
)
-
>
GetBackendType
(
)
=
=
LayersBackend
:
:
LAYERS_CLIENT
|
|
aBuilder
-
>
GetWidgetLayerManager
(
)
-
>
GetBackendType
(
)
=
=
LayersBackend
:
:
LAYERS_WR
)
&
&
mInstanceOwner
-
>
UseAsyncRendering
(
)
)
{
RefPtr
<
LayerManager
>
lm
=
aBuilder
-
>
GetWidgetLayerManager
(
)
;
if
(
!
mDidCompositeObserver
|
|
!
mDidCompositeObserver
-
>
IsValid
(
lm
)
)
{
mDidCompositeObserver
=
MakeUnique
<
PluginFrameDidCompositeObserver
>
(
mInstanceOwner
lm
)
;
}
lm
-
>
AddDidCompositeObserver
(
mDidCompositeObserver
.
get
(
)
)
;
}
}
else
{
NS_ASSERTION
(
aItem
-
>
GetType
(
)
=
=
DisplayItemType
:
:
TYPE_PLUGIN_READBACK
"
Unknown
item
type
"
)
;
MOZ_ASSERT
(
!
IsOpaque
(
)
"
Opaque
plugins
don
'
t
use
backgrounds
"
)
;
if
(
!
layer
)
{
layer
=
aManager
-
>
CreateReadbackLayer
(
)
;
if
(
!
layer
)
return
nullptr
;
}
NS_ASSERTION
(
layer
-
>
GetType
(
)
=
=
Layer
:
:
TYPE_READBACK
"
Bad
layer
type
"
)
;
ReadbackLayer
*
readback
=
static_cast
<
ReadbackLayer
*
>
(
layer
.
get
(
)
)
;
if
(
readback
-
>
GetSize
(
)
!
=
size
)
{
readback
-
>
SetSink
(
nullptr
)
;
readback
-
>
SetSize
(
size
)
;
if
(
mBackgroundSink
)
{
mBackgroundSink
-
>
Destroy
(
)
;
}
mBackgroundSink
=
new
PluginBackgroundSink
(
this
readback
-
>
AllocateSequenceNumber
(
)
)
;
readback
-
>
SetSink
(
mBackgroundSink
)
;
}
}
gfxPoint
p
=
r
.
TopLeft
(
)
+
aContainerParameters
.
mOffset
;
Matrix
transform
=
Matrix
:
:
Translation
(
p
.
x
p
.
y
)
;
layer
-
>
SetBaseTransform
(
Matrix4x4
:
:
From2D
(
transform
)
)
;
return
layer
.
forget
(
)
;
}
void
nsPluginFrame
:
:
PaintPlugin
(
nsDisplayListBuilder
*
aBuilder
gfxContext
&
aRenderingContext
const
nsRect
&
aDirtyRect
const
nsRect
&
aPluginRect
)
{
#
if
defined
(
DEBUG
)
if
(
mInstanceOwner
)
{
NPWindow
*
window
=
nullptr
;
mInstanceOwner
-
>
GetWindow
(
window
)
;
MOZ_ASSERT
(
!
window
|
|
window
-
>
type
=
=
NPWindowTypeWindow
)
;
}
#
endif
}
nsresult
nsPluginFrame
:
:
HandleEvent
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
anEvent
nsEventStatus
*
anEventStatus
)
{
NS_ENSURE_ARG_POINTER
(
anEvent
)
;
NS_ENSURE_ARG_POINTER
(
anEventStatus
)
;
nsresult
rv
=
NS_OK
;
if
(
!
mInstanceOwner
)
return
NS_ERROR_NULL_POINTER
;
mInstanceOwner
-
>
ConsiderNewEventloopNestingLevel
(
)
;
if
(
anEvent
-
>
mMessage
=
=
ePluginActivate
)
{
nsIFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
nsCOMPtr
<
nsIDOMElement
>
elem
=
do_QueryInterface
(
GetContent
(
)
)
;
if
(
fm
&
&
elem
)
return
fm
-
>
SetFocus
(
elem
0
)
;
}
else
if
(
anEvent
-
>
mMessage
=
=
ePluginFocus
)
{
nsIFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
fm
)
{
nsCOMPtr
<
nsIContent
>
content
=
GetContent
(
)
;
return
fm
-
>
FocusPlugin
(
content
)
;
}
}
if
(
mInstanceOwner
-
>
SendNativeEvents
(
)
&
&
anEvent
-
>
IsNativeEventDelivererForPlugin
(
)
)
{
*
anEventStatus
=
mInstanceOwner
-
>
ProcessEvent
(
*
anEvent
)
;
return
rv
;
}
#
ifdef
XP_WIN
rv
=
nsFrame
:
:
HandleEvent
(
aPresContext
anEvent
anEventStatus
)
;
return
rv
;
#
endif
#
ifdef
XP_MACOSX
if
(
(
anEvent
-
>
mMessage
=
=
eMouseEnterIntoWidget
|
|
anEvent
-
>
mMessage
=
=
eWheel
)
&
&
mInstanceOwner
-
>
GetEventModel
(
)
=
=
NPEventModelCocoa
)
{
*
anEventStatus
=
mInstanceOwner
-
>
ProcessEvent
(
*
anEvent
)
;
return
rv
;
}
if
(
anEvent
-
>
mMessage
=
=
eMouseDown
)
{
nsIPresShell
:
:
SetCapturingContent
(
GetContent
(
)
CAPTURE_IGNOREALLOWED
)
;
}
#
endif
rv
=
nsFrame
:
:
HandleEvent
(
aPresContext
anEvent
anEventStatus
)
;
#
ifdef
XP_MACOSX
if
(
anEvent
-
>
mMessage
=
=
eMouseUp
)
{
nsIPresShell
:
:
SetCapturingContent
(
nullptr
0
)
;
}
#
endif
return
rv
;
}
void
nsPluginFrame
:
:
HandleWheelEventAsDefaultAction
(
WidgetWheelEvent
*
aWheelEvent
)
{
MOZ_ASSERT
(
WantsToHandleWheelEventAsDefaultAction
(
)
)
;
MOZ_ASSERT
(
!
aWheelEvent
-
>
DefaultPrevented
(
)
)
;
if
(
NS_WARN_IF
(
!
mInstanceOwner
)
|
|
NS_WARN_IF
(
aWheelEvent
-
>
mMessage
!
=
eWheel
)
)
{
return
;
}
if
(
NS_WARN_IF
(
!
!
aWheelEvent
-
>
mPluginEvent
)
)
{
return
;
}
mInstanceOwner
-
>
ProcessEvent
(
*
aWheelEvent
)
;
aWheelEvent
-
>
mViewPortIsOverscrolled
=
false
;
aWheelEvent
-
>
mOverflowDeltaX
=
0
;
aWheelEvent
-
>
mOverflowDeltaY
=
0
;
aWheelEvent
-
>
PreventDefault
(
)
;
}
bool
nsPluginFrame
:
:
WantsToHandleWheelEventAsDefaultAction
(
)
const
{
#
ifdef
XP_WIN
if
(
!
mInstanceOwner
)
{
return
false
;
}
NPWindow
*
window
=
nullptr
;
mInstanceOwner
-
>
GetWindow
(
window
)
;
return
window
-
>
type
=
=
NPWindowTypeDrawable
;
#
else
return
false
;
#
endif
}
nsresult
nsPluginFrame
:
:
GetPluginInstance
(
nsNPAPIPluginInstance
*
*
aPluginInstance
)
{
*
aPluginInstance
=
nullptr
;
if
(
!
mInstanceOwner
)
{
return
NS_OK
;
}
return
mInstanceOwner
-
>
GetInstance
(
aPluginInstance
)
;
}
nsresult
nsPluginFrame
:
:
GetCursor
(
const
nsPoint
&
aPoint
nsIFrame
:
:
Cursor
&
aCursor
)
{
if
(
!
mInstanceOwner
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
nsNPAPIPluginInstance
>
inst
;
mInstanceOwner
-
>
GetInstance
(
getter_AddRefs
(
inst
)
)
;
if
(
!
inst
)
{
return
NS_ERROR_FAILURE
;
}
bool
useDOMCursor
=
static_cast
<
nsNPAPIPluginInstance
*
>
(
inst
.
get
(
)
)
-
>
UsesDOMForCursor
(
)
;
if
(
!
useDOMCursor
)
{
return
NS_ERROR_FAILURE
;
}
return
nsFrame
:
:
GetCursor
(
aPoint
aCursor
)
;
}
void
nsPluginFrame
:
:
SetIsDocumentActive
(
bool
aIsActive
)
{
if
(
mInstanceOwner
)
{
mInstanceOwner
-
>
UpdateDocumentActiveState
(
aIsActive
)
;
}
}
nsIObjectFrame
*
nsPluginFrame
:
:
GetNextObjectFrame
(
nsPresContext
*
aPresContext
nsIFrame
*
aRoot
)
{
for
(
nsIFrame
*
child
:
aRoot
-
>
PrincipalChildList
(
)
)
{
nsIObjectFrame
*
outFrame
=
do_QueryFrame
(
child
)
;
if
(
outFrame
)
{
RefPtr
<
nsNPAPIPluginInstance
>
pi
;
outFrame
-
>
GetPluginInstance
(
getter_AddRefs
(
pi
)
)
;
if
(
pi
)
return
outFrame
;
}
outFrame
=
GetNextObjectFrame
(
aPresContext
child
)
;
if
(
outFrame
)
return
outFrame
;
}
return
nullptr
;
}
void
nsPluginFrame
:
:
BeginSwapDocShells
(
nsISupports
*
aSupports
void
*
)
{
NS_PRECONDITION
(
aSupports
"
"
)
;
nsCOMPtr
<
nsIContent
>
content
(
do_QueryInterface
(
aSupports
)
)
;
if
(
!
content
)
{
return
;
}
nsIObjectFrame
*
obj
=
do_QueryFrame
(
content
-
>
GetPrimaryFrame
(
)
)
;
if
(
!
obj
)
return
;
nsPluginFrame
*
objectFrame
=
static_cast
<
nsPluginFrame
*
>
(
obj
)
;
NS_ASSERTION
(
!
objectFrame
-
>
mWidget
|
|
objectFrame
-
>
mWidget
-
>
GetParent
(
)
"
Plugin
windows
must
not
be
toplevel
"
)
;
objectFrame
-
>
UnregisterPluginForGeometryUpdates
(
)
;
}
void
nsPluginFrame
:
:
EndSwapDocShells
(
nsISupports
*
aSupports
void
*
)
{
NS_PRECONDITION
(
aSupports
"
"
)
;
nsCOMPtr
<
nsIContent
>
content
(
do_QueryInterface
(
aSupports
)
)
;
if
(
!
content
)
{
return
;
}
nsIObjectFrame
*
obj
=
do_QueryFrame
(
content
-
>
GetPrimaryFrame
(
)
)
;
if
(
!
obj
)
return
;
nsPluginFrame
*
objectFrame
=
static_cast
<
nsPluginFrame
*
>
(
obj
)
;
nsRootPresContext
*
rootPC
=
objectFrame
-
>
PresContext
(
)
-
>
GetRootPresContext
(
)
;
NS_ASSERTION
(
rootPC
"
unable
to
register
the
plugin
frame
"
)
;
nsIWidget
*
widget
=
objectFrame
-
>
mWidget
;
if
(
widget
)
{
nsIWidget
*
parent
=
rootPC
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
-
>
GetNearestWidget
(
)
;
widget
-
>
SetParent
(
parent
)
;
AutoWeakFrame
weakFrame
(
objectFrame
)
;
objectFrame
-
>
CallSetWindow
(
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
;
}
}
if
(
objectFrame
-
>
mInstanceOwner
)
{
objectFrame
-
>
RegisterPluginForGeometryUpdates
(
)
;
}
}
nsIFrame
*
NS_NewObjectFrame
(
nsIPresShell
*
aPresShell
nsStyleContext
*
aContext
)
{
return
new
(
aPresShell
)
nsPluginFrame
(
aContext
)
;
}
bool
nsPluginFrame
:
:
IsPaintedByGecko
(
)
const
{
#
ifdef
XP_MACOSX
return
true
;
#
else
return
!
mWidget
;
#
endif
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsPluginFrame
)
