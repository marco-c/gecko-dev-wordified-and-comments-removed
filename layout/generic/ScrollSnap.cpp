#
include
"
ScrollSnap
.
h
"
#
include
"
FrameMetrics
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
nsLineLayout
.
h
"
namespace
mozilla
{
using
layers
:
:
ScrollSnapInfo
;
class
CalcSnapPoints
final
{
public
:
CalcSnapPoints
(
ScrollUnit
aUnit
ScrollSnapFlags
aSnapFlags
const
nsPoint
&
aDestination
const
nsPoint
&
aStartPos
)
;
void
AddHorizontalEdge
(
nscoord
aEdge
)
;
void
AddVerticalEdge
(
nscoord
aEdge
)
;
void
AddEdge
(
nscoord
aEdge
nscoord
aDestination
nscoord
aStartPos
nscoord
aScrollingDirection
nscoord
*
aBestEdge
nscoord
*
aSecondBestEdge
bool
*
aEdgeFound
)
;
nsPoint
GetBestEdge
(
)
const
;
nscoord
XDistanceBetweenBestAndSecondEdge
(
)
const
{
return
std
:
:
abs
(
NSCoordSaturatingSubtract
(
mSecondBestEdge
.
x
mBestEdge
.
x
nscoord_MAX
)
)
;
}
nscoord
YDistanceBetweenBestAndSecondEdge
(
)
const
{
return
std
:
:
abs
(
NSCoordSaturatingSubtract
(
mSecondBestEdge
.
y
mBestEdge
.
y
nscoord_MAX
)
)
;
}
const
nsPoint
&
Destination
(
)
const
{
return
mDestination
;
}
protected
:
ScrollUnit
mUnit
;
ScrollSnapFlags
mSnapFlags
;
nsPoint
mDestination
;
nsPoint
mStartPos
;
nsIntPoint
mScrollingDirection
;
nsPoint
mBestEdge
;
nsPoint
mSecondBestEdge
;
bool
mHorizontalEdgeFound
;
bool
mVerticalEdgeFound
;
}
;
CalcSnapPoints
:
:
CalcSnapPoints
(
ScrollUnit
aUnit
ScrollSnapFlags
aSnapFlags
const
nsPoint
&
aDestination
const
nsPoint
&
aStartPos
)
{
MOZ_ASSERT
(
aSnapFlags
!
=
ScrollSnapFlags
:
:
Disabled
)
;
mUnit
=
aUnit
;
mSnapFlags
=
aSnapFlags
;
mDestination
=
aDestination
;
mStartPos
=
aStartPos
;
nsPoint
direction
=
aDestination
-
aStartPos
;
mScrollingDirection
=
nsIntPoint
(
0
0
)
;
if
(
direction
.
x
<
0
)
{
mScrollingDirection
.
x
=
-
1
;
}
if
(
direction
.
x
>
0
)
{
mScrollingDirection
.
x
=
1
;
}
if
(
direction
.
y
<
0
)
{
mScrollingDirection
.
y
=
-
1
;
}
if
(
direction
.
y
>
0
)
{
mScrollingDirection
.
y
=
1
;
}
mBestEdge
=
aDestination
;
mSecondBestEdge
=
nsPoint
(
nscoord_MAX
nscoord_MAX
)
;
mHorizontalEdgeFound
=
false
;
mVerticalEdgeFound
=
false
;
}
nsPoint
CalcSnapPoints
:
:
GetBestEdge
(
)
const
{
return
nsPoint
(
mVerticalEdgeFound
?
mBestEdge
.
x
:
mStartPos
.
x
mHorizontalEdgeFound
?
mBestEdge
.
y
:
mStartPos
.
y
)
;
}
void
CalcSnapPoints
:
:
AddHorizontalEdge
(
nscoord
aEdge
)
{
AddEdge
(
aEdge
mDestination
.
y
mStartPos
.
y
mScrollingDirection
.
y
&
mBestEdge
.
y
&
mSecondBestEdge
.
y
&
mHorizontalEdgeFound
)
;
}
void
CalcSnapPoints
:
:
AddVerticalEdge
(
nscoord
aEdge
)
{
AddEdge
(
aEdge
mDestination
.
x
mStartPos
.
x
mScrollingDirection
.
x
&
mBestEdge
.
x
&
mSecondBestEdge
.
x
&
mVerticalEdgeFound
)
;
}
void
CalcSnapPoints
:
:
AddEdge
(
nscoord
aEdge
nscoord
aDestination
nscoord
aStartPos
nscoord
aScrollingDirection
nscoord
*
aBestEdge
nscoord
*
aSecondBestEdge
bool
*
aEdgeFound
)
{
if
(
mSnapFlags
&
ScrollSnapFlags
:
:
IntendedDirection
)
{
if
(
aScrollingDirection
=
=
0
|
|
(
aEdge
-
aStartPos
)
*
aScrollingDirection
<
=
0
)
{
return
;
}
}
if
(
!
*
aEdgeFound
)
{
*
aBestEdge
=
aEdge
;
*
aEdgeFound
=
true
;
return
;
}
const
bool
isOnOppositeSide
=
(
(
aEdge
-
aDestination
)
>
0
)
!
=
(
(
*
aBestEdge
-
aDestination
)
>
0
)
;
auto
updateBestEdges
=
[
&
]
(
bool
aIsCloserThanBest
bool
aIsCloserThanSecond
)
{
if
(
aIsCloserThanBest
)
{
if
(
isOnOppositeSide
)
{
*
aSecondBestEdge
=
*
aBestEdge
;
}
*
aBestEdge
=
aEdge
;
}
else
if
(
aIsCloserThanSecond
)
{
if
(
isOnOppositeSide
)
{
*
aSecondBestEdge
=
aEdge
;
}
}
}
;
if
(
mUnit
=
=
ScrollUnit
:
:
DEVICE_PIXELS
|
|
mUnit
=
=
ScrollUnit
:
:
LINES
|
|
mUnit
=
=
ScrollUnit
:
:
WHOLE
)
{
nscoord
distance
=
std
:
:
abs
(
aEdge
-
aDestination
)
;
updateBestEdges
(
distance
<
std
:
:
abs
(
*
aBestEdge
-
aDestination
)
distance
<
std
:
:
abs
(
NSCoordSaturatingSubtract
(
*
aSecondBestEdge
aDestination
nscoord_MAX
)
)
)
;
}
else
if
(
mUnit
=
=
ScrollUnit
:
:
PAGES
)
{
nscoord
overshoot
=
(
aEdge
-
aDestination
)
*
aScrollingDirection
;
nscoord
curOvershoot
=
(
*
aBestEdge
-
aDestination
)
*
aScrollingDirection
;
nscoord
secondOvershoot
=
NSCoordSaturatingSubtract
(
*
aSecondBestEdge
aDestination
nscoord_MAX
)
*
aScrollingDirection
;
if
(
overshoot
<
0
)
{
updateBestEdges
(
overshoot
>
curOvershoot
|
|
curOvershoot
>
=
0
overshoot
>
secondOvershoot
|
|
secondOvershoot
>
=
0
)
;
}
if
(
overshoot
>
0
)
{
updateBestEdges
(
overshoot
<
curOvershoot
overshoot
<
secondOvershoot
)
;
}
}
else
{
NS_ERROR
(
"
Invalid
scroll
mode
"
)
;
return
;
}
}
static
void
ProcessSnapPositions
(
CalcSnapPoints
&
aCalcSnapPoints
const
ScrollSnapInfo
&
aSnapInfo
)
{
for
(
const
auto
&
target
:
aSnapInfo
.
mSnapTargets
)
{
nsPoint
snapPoint
(
target
.
mSnapPositionX
?
*
target
.
mSnapPositionX
:
aCalcSnapPoints
.
Destination
(
)
.
x
target
.
mSnapPositionY
?
*
target
.
mSnapPositionY
:
aCalcSnapPoints
.
Destination
(
)
.
y
)
;
nsRect
snappedPort
=
nsRect
(
snapPoint
aSnapInfo
.
mSnapportSize
)
;
if
(
!
snappedPort
.
Intersects
(
target
.
mSnapArea
)
)
{
continue
;
}
if
(
target
.
mSnapPositionX
)
{
aCalcSnapPoints
.
AddVerticalEdge
(
*
target
.
mSnapPositionX
)
;
}
if
(
target
.
mSnapPositionY
)
{
aCalcSnapPoints
.
AddHorizontalEdge
(
*
target
.
mSnapPositionY
)
;
}
}
}
Maybe
<
nsPoint
>
ScrollSnapUtils
:
:
GetSnapPointForDestination
(
const
ScrollSnapInfo
&
aSnapInfo
ScrollUnit
aUnit
ScrollSnapFlags
aSnapFlags
const
nsRect
&
aScrollRange
const
nsPoint
&
aStartPos
const
nsPoint
&
aDestination
)
{
if
(
aSnapInfo
.
mScrollSnapStrictnessY
=
=
StyleScrollSnapStrictness
:
:
None
&
&
aSnapInfo
.
mScrollSnapStrictnessX
=
=
StyleScrollSnapStrictness
:
:
None
)
{
return
Nothing
(
)
;
}
if
(
!
aSnapInfo
.
HasSnapPositions
(
)
)
{
return
Nothing
(
)
;
}
CalcSnapPoints
calcSnapPoints
(
aUnit
aSnapFlags
aDestination
aStartPos
)
;
ProcessSnapPositions
(
calcSnapPoints
aSnapInfo
)
;
nsPoint
clampedDestination
=
aScrollRange
.
ClampPoint
(
aDestination
)
;
for
(
auto
range
:
aSnapInfo
.
mXRangeWiderThanSnapport
)
{
if
(
range
.
IsValid
(
clampedDestination
.
x
aSnapInfo
.
mSnapportSize
.
width
)
&
&
calcSnapPoints
.
XDistanceBetweenBestAndSecondEdge
(
)
>
aSnapInfo
.
mSnapportSize
.
width
)
{
calcSnapPoints
.
AddVerticalEdge
(
clampedDestination
.
x
)
;
break
;
}
}
for
(
auto
range
:
aSnapInfo
.
mYRangeWiderThanSnapport
)
{
if
(
range
.
IsValid
(
clampedDestination
.
y
aSnapInfo
.
mSnapportSize
.
height
)
&
&
calcSnapPoints
.
YDistanceBetweenBestAndSecondEdge
(
)
>
aSnapInfo
.
mSnapportSize
.
height
)
{
calcSnapPoints
.
AddHorizontalEdge
(
clampedDestination
.
y
)
;
break
;
}
}
bool
snapped
=
false
;
nsPoint
finalPos
=
calcSnapPoints
.
GetBestEdge
(
)
;
nscoord
proximityThreshold
=
StaticPrefs
:
:
layout_css_scroll_snap_proximity_threshold
(
)
;
proximityThreshold
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
proximityThreshold
)
;
if
(
aSnapInfo
.
mScrollSnapStrictnessY
=
=
StyleScrollSnapStrictness
:
:
Proximity
&
&
std
:
:
abs
(
aDestination
.
y
-
finalPos
.
y
)
>
proximityThreshold
)
{
finalPos
.
y
=
aDestination
.
y
;
}
else
{
snapped
=
true
;
}
if
(
aSnapInfo
.
mScrollSnapStrictnessX
=
=
StyleScrollSnapStrictness
:
:
Proximity
&
&
std
:
:
abs
(
aDestination
.
x
-
finalPos
.
x
)
>
proximityThreshold
)
{
finalPos
.
x
=
aDestination
.
x
;
}
else
{
snapped
=
true
;
}
return
snapped
?
Some
(
finalPos
)
:
Nothing
(
)
;
}
}
