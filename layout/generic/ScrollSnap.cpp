#
include
"
ScrollSnap
.
h
"
#
include
"
FrameMetrics
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
nsLineLayout
.
h
"
namespace
mozilla
{
using
layers
:
:
ScrollSnapInfo
;
class
CalcSnapPoints
final
{
public
:
CalcSnapPoints
(
nsIScrollableFrame
:
:
ScrollUnit
aUnit
const
nsPoint
&
aDestination
const
nsPoint
&
aStartPos
)
;
void
AddHorizontalEdge
(
nscoord
aEdge
)
;
void
AddVerticalEdge
(
nscoord
aEdge
)
;
void
AddEdge
(
nscoord
aEdge
nscoord
aDestination
nscoord
aStartPos
nscoord
aScrollingDirection
nscoord
*
aBestEdge
nscoord
*
aSecondBestEdge
bool
*
aEdgeFound
)
;
void
AddEdgeInterval
(
nscoord
aInterval
nscoord
aMinPos
nscoord
aMaxPos
nscoord
aOffset
nscoord
aDestination
nscoord
aStartPos
nscoord
aScrollingDirection
nscoord
*
aBestEdge
nscoord
*
aSecondBestEdge
bool
*
aEdgeFound
)
;
nsPoint
GetBestEdge
(
)
const
;
nscoord
XDistanceBetweenBestAndSecondEdge
(
)
const
{
return
std
:
:
abs
(
mBestEdge
.
x
-
mSecondBestEdge
.
x
)
;
}
nscoord
YDistanceBetweenBestAndSecondEdge
(
)
const
{
return
std
:
:
abs
(
mBestEdge
.
y
-
mSecondBestEdge
.
y
)
;
}
protected
:
nsIScrollableFrame
:
:
ScrollUnit
mUnit
;
nsPoint
mDestination
;
nsPoint
mStartPos
;
nsIntPoint
mScrollingDirection
;
nsPoint
mBestEdge
;
nsPoint
mSecondBestEdge
;
bool
mHorizontalEdgeFound
;
bool
mVerticalEdgeFound
;
}
;
CalcSnapPoints
:
:
CalcSnapPoints
(
nsIScrollableFrame
:
:
ScrollUnit
aUnit
const
nsPoint
&
aDestination
const
nsPoint
&
aStartPos
)
{
mUnit
=
aUnit
;
mDestination
=
aDestination
;
mStartPos
=
aStartPos
;
nsPoint
direction
=
aDestination
-
aStartPos
;
mScrollingDirection
=
nsIntPoint
(
0
0
)
;
if
(
direction
.
x
<
0
)
{
mScrollingDirection
.
x
=
-
1
;
}
if
(
direction
.
x
>
0
)
{
mScrollingDirection
.
x
=
1
;
}
if
(
direction
.
y
<
0
)
{
mScrollingDirection
.
y
=
-
1
;
}
if
(
direction
.
y
>
0
)
{
mScrollingDirection
.
y
=
1
;
}
mBestEdge
=
aDestination
;
mSecondBestEdge
=
nsPoint
(
nscoord_MAX
nscoord_MAX
)
;
mHorizontalEdgeFound
=
false
;
mVerticalEdgeFound
=
false
;
}
nsPoint
CalcSnapPoints
:
:
GetBestEdge
(
)
const
{
return
nsPoint
(
mVerticalEdgeFound
?
mBestEdge
.
x
:
mStartPos
.
x
mHorizontalEdgeFound
?
mBestEdge
.
y
:
mStartPos
.
y
)
;
}
void
CalcSnapPoints
:
:
AddHorizontalEdge
(
nscoord
aEdge
)
{
AddEdge
(
aEdge
mDestination
.
y
mStartPos
.
y
mScrollingDirection
.
y
&
mBestEdge
.
y
&
mSecondBestEdge
.
y
&
mHorizontalEdgeFound
)
;
}
void
CalcSnapPoints
:
:
AddVerticalEdge
(
nscoord
aEdge
)
{
AddEdge
(
aEdge
mDestination
.
x
mStartPos
.
x
mScrollingDirection
.
x
&
mBestEdge
.
x
&
mSecondBestEdge
.
x
&
mVerticalEdgeFound
)
;
}
void
CalcSnapPoints
:
:
AddEdge
(
nscoord
aEdge
nscoord
aDestination
nscoord
aStartPos
nscoord
aScrollingDirection
nscoord
*
aBestEdge
nscoord
*
aSecondBestEdge
bool
*
aEdgeFound
)
{
if
(
mUnit
!
=
nsIScrollableFrame
:
:
DEVICE_PIXELS
)
{
if
(
aScrollingDirection
=
=
0
)
{
return
;
}
if
(
mUnit
!
=
nsIScrollableFrame
:
:
WHOLE
)
{
nscoord
direction
=
(
aEdge
-
aStartPos
)
*
aScrollingDirection
;
if
(
direction
<
=
0
)
{
return
;
}
}
}
if
(
!
*
aEdgeFound
)
{
*
aBestEdge
=
aEdge
;
*
aEdgeFound
=
true
;
return
;
}
auto
updateBestEdges
=
[
&
]
(
bool
aIsCloserThanBest
bool
aIsCloserThanSecond
)
{
if
(
aIsCloserThanBest
)
{
*
aSecondBestEdge
=
*
aBestEdge
;
*
aBestEdge
=
aEdge
;
}
else
if
(
aIsCloserThanSecond
)
{
*
aSecondBestEdge
=
aEdge
;
}
}
;
if
(
mUnit
=
=
nsIScrollableFrame
:
:
DEVICE_PIXELS
|
|
mUnit
=
=
nsIScrollableFrame
:
:
LINES
)
{
nscoord
distance
=
std
:
:
abs
(
aEdge
-
aDestination
)
;
updateBestEdges
(
distance
<
std
:
:
abs
(
*
aBestEdge
-
aDestination
)
distance
<
std
:
:
abs
(
*
aSecondBestEdge
-
aDestination
)
)
;
}
else
if
(
mUnit
=
=
nsIScrollableFrame
:
:
PAGES
)
{
nscoord
overshoot
=
(
aEdge
-
aDestination
)
*
aScrollingDirection
;
nscoord
curOvershoot
=
(
*
aBestEdge
-
aDestination
)
*
aScrollingDirection
;
nscoord
secondOvershoot
=
(
*
aSecondBestEdge
-
aDestination
)
*
aScrollingDirection
;
if
(
overshoot
<
0
)
{
updateBestEdges
(
overshoot
>
curOvershoot
|
|
curOvershoot
>
=
0
overshoot
>
secondOvershoot
|
|
secondOvershoot
>
=
0
)
;
}
if
(
overshoot
>
0
)
{
updateBestEdges
(
overshoot
<
curOvershoot
overshoot
<
secondOvershoot
)
;
}
}
else
if
(
mUnit
=
=
nsIScrollableFrame
:
:
WHOLE
)
{
if
(
aScrollingDirection
>
0
)
{
updateBestEdges
(
aEdge
>
*
aBestEdge
aEdge
>
*
aSecondBestEdge
)
;
}
else
if
(
aScrollingDirection
<
0
)
{
updateBestEdges
(
aEdge
<
*
aBestEdge
aEdge
<
*
aSecondBestEdge
)
;
}
}
else
{
NS_ERROR
(
"
Invalid
scroll
mode
"
)
;
return
;
}
}
void
CalcSnapPoints
:
:
AddEdgeInterval
(
nscoord
aInterval
nscoord
aMinPos
nscoord
aMaxPos
nscoord
aOffset
nscoord
aDestination
nscoord
aStartPos
nscoord
aScrollingDirection
nscoord
*
aBestEdge
nscoord
*
aSecondBestEdge
bool
*
aEdgeFound
)
{
if
(
aInterval
=
=
0
)
{
return
;
}
nscoord
clamped
=
std
:
:
max
(
std
:
:
min
(
aDestination
aMaxPos
)
aMinPos
)
;
nscoord
r
=
(
clamped
+
aOffset
)
%
aInterval
;
if
(
r
<
aMinPos
)
{
r
+
=
aInterval
;
}
nscoord
edge
=
clamped
-
r
;
if
(
edge
>
=
aMinPos
&
&
edge
<
=
aMaxPos
)
{
AddEdge
(
edge
aDestination
aStartPos
aScrollingDirection
aBestEdge
aSecondBestEdge
aEdgeFound
)
;
}
edge
+
=
aInterval
;
if
(
edge
>
=
aMinPos
&
&
edge
<
=
aMaxPos
)
{
AddEdge
(
edge
aDestination
aStartPos
aScrollingDirection
aBestEdge
aSecondBestEdge
aEdgeFound
)
;
}
}
static
void
ProcessSnapPositions
(
CalcSnapPoints
&
aCalcSnapPoints
const
ScrollSnapInfo
&
aSnapInfo
)
{
for
(
auto
position
:
aSnapInfo
.
mSnapPositionX
)
{
aCalcSnapPoints
.
AddVerticalEdge
(
position
)
;
}
for
(
auto
position
:
aSnapInfo
.
mSnapPositionY
)
{
aCalcSnapPoints
.
AddHorizontalEdge
(
position
)
;
}
}
Maybe
<
nsPoint
>
ScrollSnapUtils
:
:
GetSnapPointForDestination
(
const
ScrollSnapInfo
&
aSnapInfo
nsIScrollableFrame
:
:
ScrollUnit
aUnit
const
nsRect
&
aScrollRange
const
nsPoint
&
aStartPos
const
nsPoint
&
aDestination
)
{
if
(
aSnapInfo
.
mScrollSnapStrictnessY
=
=
StyleScrollSnapStrictness
:
:
None
&
&
aSnapInfo
.
mScrollSnapStrictnessX
=
=
StyleScrollSnapStrictness
:
:
None
)
{
return
Nothing
(
)
;
}
if
(
!
aSnapInfo
.
HasSnapPositions
(
)
)
{
return
Nothing
(
)
;
}
CalcSnapPoints
calcSnapPoints
(
aUnit
aDestination
aStartPos
)
;
ProcessSnapPositions
(
calcSnapPoints
aSnapInfo
)
;
nsPoint
clampedDestination
=
aScrollRange
.
ClampPoint
(
aDestination
)
;
for
(
auto
range
:
aSnapInfo
.
mXRangeWiderThanSnapport
)
{
if
(
range
.
IsValid
(
clampedDestination
.
x
aSnapInfo
.
mSnapportSize
.
width
)
&
&
calcSnapPoints
.
XDistanceBetweenBestAndSecondEdge
(
)
>
aSnapInfo
.
mSnapportSize
.
width
)
{
calcSnapPoints
.
AddVerticalEdge
(
clampedDestination
.
x
)
;
break
;
}
}
for
(
auto
range
:
aSnapInfo
.
mYRangeWiderThanSnapport
)
{
if
(
range
.
IsValid
(
clampedDestination
.
y
aSnapInfo
.
mSnapportSize
.
height
)
&
&
calcSnapPoints
.
YDistanceBetweenBestAndSecondEdge
(
)
>
aSnapInfo
.
mSnapportSize
.
height
)
{
calcSnapPoints
.
AddHorizontalEdge
(
clampedDestination
.
y
)
;
break
;
}
}
bool
snapped
=
false
;
nsPoint
finalPos
=
calcSnapPoints
.
GetBestEdge
(
)
;
nscoord
proximityThreshold
=
StaticPrefs
:
:
layout_css_scroll_snap_proximity_threshold
(
)
;
proximityThreshold
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
proximityThreshold
)
;
if
(
aSnapInfo
.
mScrollSnapStrictnessY
=
=
StyleScrollSnapStrictness
:
:
Proximity
&
&
std
:
:
abs
(
aDestination
.
y
-
finalPos
.
y
)
>
proximityThreshold
)
{
finalPos
.
y
=
aDestination
.
y
;
}
else
{
snapped
=
true
;
}
if
(
aSnapInfo
.
mScrollSnapStrictnessX
=
=
StyleScrollSnapStrictness
:
:
Proximity
&
&
std
:
:
abs
(
aDestination
.
x
-
finalPos
.
x
)
>
proximityThreshold
)
{
finalPos
.
x
=
aDestination
.
x
;
}
else
{
snapped
=
true
;
}
return
snapped
?
Some
(
finalPos
)
:
Nothing
(
)
;
}
}
