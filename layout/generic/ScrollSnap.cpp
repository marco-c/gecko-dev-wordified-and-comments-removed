#
include
"
FrameMetrics
.
h
"
#
include
"
ScrollSnap
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
nsLineLayout
.
h
"
namespace
mozilla
{
using
layers
:
:
ScrollSnapInfo
;
class
SnappingEdgeCallback
{
public
:
virtual
void
AddHorizontalEdge
(
nscoord
aEdge
)
=
0
;
virtual
void
AddVerticalEdge
(
nscoord
aEdge
)
=
0
;
virtual
void
AddHorizontalEdgeInterval
(
const
nsRect
&
aScrollRange
nscoord
aInterval
nscoord
aOffset
)
=
0
;
virtual
void
AddVerticalEdgeInterval
(
const
nsRect
&
aScrollRange
nscoord
aInterval
nscoord
aOffset
)
=
0
;
}
;
class
CalcSnapPoints
:
public
SnappingEdgeCallback
{
public
:
CalcSnapPoints
(
nsIScrollableFrame
:
:
ScrollUnit
aUnit
const
nsPoint
&
aDestination
const
nsPoint
&
aStartPos
)
;
virtual
void
AddHorizontalEdge
(
nscoord
aEdge
)
override
;
virtual
void
AddVerticalEdge
(
nscoord
aEdge
)
override
;
virtual
void
AddHorizontalEdgeInterval
(
const
nsRect
&
aScrollRange
nscoord
aInterval
nscoord
aOffset
)
override
;
virtual
void
AddVerticalEdgeInterval
(
const
nsRect
&
aScrollRange
nscoord
aInterval
nscoord
aOffset
)
override
;
void
AddEdge
(
nscoord
aEdge
nscoord
aDestination
nscoord
aStartPos
nscoord
aScrollingDirection
nscoord
*
aBestEdge
bool
*
aEdgeFound
)
;
void
AddEdgeInterval
(
nscoord
aInterval
nscoord
aMinPos
nscoord
aMaxPos
nscoord
aOffset
nscoord
aDestination
nscoord
aStartPos
nscoord
aScrollingDirection
nscoord
*
aBestEdge
bool
*
aEdgeFound
)
;
nsPoint
GetBestEdge
(
)
const
;
protected
:
nsIScrollableFrame
:
:
ScrollUnit
mUnit
;
nsPoint
mDestination
;
nsPoint
mStartPos
;
nsIntPoint
mScrollingDirection
;
nsPoint
mBestEdge
;
bool
mHorizontalEdgeFound
;
bool
mVerticalEdgeFound
;
}
;
CalcSnapPoints
:
:
CalcSnapPoints
(
nsIScrollableFrame
:
:
ScrollUnit
aUnit
const
nsPoint
&
aDestination
const
nsPoint
&
aStartPos
)
{
mUnit
=
aUnit
;
mDestination
=
aDestination
;
mStartPos
=
aStartPos
;
nsPoint
direction
=
aDestination
-
aStartPos
;
mScrollingDirection
=
nsIntPoint
(
0
0
)
;
if
(
direction
.
x
<
0
)
{
mScrollingDirection
.
x
=
-
1
;
}
if
(
direction
.
x
>
0
)
{
mScrollingDirection
.
x
=
1
;
}
if
(
direction
.
y
<
0
)
{
mScrollingDirection
.
y
=
-
1
;
}
if
(
direction
.
y
>
0
)
{
mScrollingDirection
.
y
=
1
;
}
mBestEdge
=
aDestination
;
mHorizontalEdgeFound
=
false
;
mVerticalEdgeFound
=
false
;
}
nsPoint
CalcSnapPoints
:
:
GetBestEdge
(
)
const
{
return
nsPoint
(
mVerticalEdgeFound
?
mBestEdge
.
x
:
mStartPos
.
x
mHorizontalEdgeFound
?
mBestEdge
.
y
:
mStartPos
.
y
)
;
}
void
CalcSnapPoints
:
:
AddHorizontalEdge
(
nscoord
aEdge
)
{
AddEdge
(
aEdge
mDestination
.
y
mStartPos
.
y
mScrollingDirection
.
y
&
mBestEdge
.
y
&
mHorizontalEdgeFound
)
;
}
void
CalcSnapPoints
:
:
AddVerticalEdge
(
nscoord
aEdge
)
{
AddEdge
(
aEdge
mDestination
.
x
mStartPos
.
x
mScrollingDirection
.
x
&
mBestEdge
.
x
&
mVerticalEdgeFound
)
;
}
void
CalcSnapPoints
:
:
AddHorizontalEdgeInterval
(
const
nsRect
&
aScrollRange
nscoord
aInterval
nscoord
aOffset
)
{
AddEdgeInterval
(
aInterval
aScrollRange
.
y
aScrollRange
.
YMost
(
)
aOffset
mDestination
.
y
mStartPos
.
y
mScrollingDirection
.
y
&
mBestEdge
.
y
&
mHorizontalEdgeFound
)
;
}
void
CalcSnapPoints
:
:
AddVerticalEdgeInterval
(
const
nsRect
&
aScrollRange
nscoord
aInterval
nscoord
aOffset
)
{
AddEdgeInterval
(
aInterval
aScrollRange
.
x
aScrollRange
.
XMost
(
)
aOffset
mDestination
.
x
mStartPos
.
x
mScrollingDirection
.
x
&
mBestEdge
.
x
&
mVerticalEdgeFound
)
;
}
void
CalcSnapPoints
:
:
AddEdge
(
nscoord
aEdge
nscoord
aDestination
nscoord
aStartPos
nscoord
aScrollingDirection
nscoord
*
aBestEdge
bool
*
aEdgeFound
)
{
if
(
mUnit
!
=
nsIScrollableFrame
:
:
DEVICE_PIXELS
)
{
if
(
aScrollingDirection
=
=
0
)
{
return
;
}
if
(
mUnit
!
=
nsIScrollableFrame
:
:
WHOLE
)
{
nscoord
direction
=
(
aEdge
-
aStartPos
)
*
aScrollingDirection
;
if
(
direction
<
=
0
)
{
return
;
}
}
}
if
(
!
*
aEdgeFound
)
{
*
aBestEdge
=
aEdge
;
*
aEdgeFound
=
true
;
return
;
}
if
(
mUnit
=
=
nsIScrollableFrame
:
:
DEVICE_PIXELS
|
|
mUnit
=
=
nsIScrollableFrame
:
:
LINES
)
{
if
(
std
:
:
abs
(
aEdge
-
aDestination
)
<
std
:
:
abs
(
*
aBestEdge
-
aDestination
)
)
{
*
aBestEdge
=
aEdge
;
}
}
else
if
(
mUnit
=
=
nsIScrollableFrame
:
:
PAGES
)
{
nscoord
overshoot
=
(
aEdge
-
aDestination
)
*
aScrollingDirection
;
nscoord
curOvershoot
=
(
*
aBestEdge
-
aDestination
)
*
aScrollingDirection
;
if
(
overshoot
<
0
&
&
(
overshoot
>
curOvershoot
|
|
curOvershoot
>
=
0
)
)
{
*
aBestEdge
=
aEdge
;
}
if
(
overshoot
>
0
&
&
overshoot
<
curOvershoot
)
{
*
aBestEdge
=
aEdge
;
}
}
else
if
(
mUnit
=
=
nsIScrollableFrame
:
:
WHOLE
)
{
if
(
aScrollingDirection
>
0
&
&
aEdge
>
*
aBestEdge
)
{
*
aBestEdge
=
aEdge
;
}
else
if
(
aScrollingDirection
<
0
&
&
aEdge
<
*
aBestEdge
)
{
*
aBestEdge
=
aEdge
;
}
}
else
{
NS_ERROR
(
"
Invalid
scroll
mode
"
)
;
return
;
}
}
void
CalcSnapPoints
:
:
AddEdgeInterval
(
nscoord
aInterval
nscoord
aMinPos
nscoord
aMaxPos
nscoord
aOffset
nscoord
aDestination
nscoord
aStartPos
nscoord
aScrollingDirection
nscoord
*
aBestEdge
bool
*
aEdgeFound
)
{
if
(
aInterval
=
=
0
)
{
return
;
}
nscoord
clamped
=
std
:
:
max
(
std
:
:
min
(
aDestination
aMaxPos
)
aMinPos
)
;
nscoord
r
=
(
clamped
+
aOffset
)
%
aInterval
;
if
(
r
<
aMinPos
)
{
r
+
=
aInterval
;
}
nscoord
edge
=
clamped
-
r
;
if
(
edge
>
=
aMinPos
&
&
edge
<
=
aMaxPos
)
{
AddEdge
(
edge
aDestination
aStartPos
aScrollingDirection
aBestEdge
aEdgeFound
)
;
}
edge
+
=
aInterval
;
if
(
edge
>
=
aMinPos
&
&
edge
<
=
aMaxPos
)
{
AddEdge
(
edge
aDestination
aStartPos
aScrollingDirection
aBestEdge
aEdgeFound
)
;
}
}
static
void
ProcessScrollSnapCoordinates
(
SnappingEdgeCallback
&
aCallback
const
nsTArray
<
nsPoint
>
&
aScrollSnapCoordinates
const
nsPoint
&
aScrollSnapDestination
)
{
for
(
nsPoint
snapCoords
:
aScrollSnapCoordinates
)
{
snapCoords
-
=
aScrollSnapDestination
;
aCallback
.
AddVerticalEdge
(
snapCoords
.
x
)
;
aCallback
.
AddHorizontalEdge
(
snapCoords
.
y
)
;
}
}
Maybe
<
nsPoint
>
ScrollSnapUtils
:
:
GetSnapPointForDestination
(
const
ScrollSnapInfo
&
aSnapInfo
nsIScrollableFrame
:
:
ScrollUnit
aUnit
const
nsSize
&
aScrollPortSize
const
nsRect
&
aScrollRange
const
nsPoint
&
aStartPos
const
nsPoint
&
aDestination
)
{
if
(
aSnapInfo
.
mScrollSnapTypeY
=
=
NS_STYLE_SCROLL_SNAP_TYPE_NONE
&
&
aSnapInfo
.
mScrollSnapTypeX
=
=
NS_STYLE_SCROLL_SNAP_TYPE_NONE
)
{
return
Nothing
(
)
;
}
nsPoint
destPos
=
aSnapInfo
.
mScrollSnapDestination
;
CalcSnapPoints
calcSnapPoints
(
aUnit
aDestination
aStartPos
)
;
if
(
aSnapInfo
.
mScrollSnapIntervalX
.
isSome
(
)
)
{
nscoord
interval
=
aSnapInfo
.
mScrollSnapIntervalX
.
value
(
)
;
calcSnapPoints
.
AddVerticalEdgeInterval
(
aScrollRange
interval
destPos
.
x
)
;
}
if
(
aSnapInfo
.
mScrollSnapIntervalY
.
isSome
(
)
)
{
nscoord
interval
=
aSnapInfo
.
mScrollSnapIntervalY
.
value
(
)
;
calcSnapPoints
.
AddHorizontalEdgeInterval
(
aScrollRange
interval
destPos
.
y
)
;
}
ProcessScrollSnapCoordinates
(
calcSnapPoints
aSnapInfo
.
mScrollSnapCoordinates
destPos
)
;
bool
snapped
=
false
;
nsPoint
finalPos
=
calcSnapPoints
.
GetBestEdge
(
)
;
nscoord
proximityThreshold
=
Preferences
:
:
GetInt
(
"
layout
.
css
.
scroll
-
snap
.
proximity
-
threshold
"
0
)
;
proximityThreshold
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
proximityThreshold
)
;
if
(
aSnapInfo
.
mScrollSnapTypeY
=
=
NS_STYLE_SCROLL_SNAP_TYPE_PROXIMITY
&
&
std
:
:
abs
(
aDestination
.
y
-
finalPos
.
y
)
>
proximityThreshold
)
{
finalPos
.
y
=
aDestination
.
y
;
}
else
{
snapped
=
true
;
}
if
(
aSnapInfo
.
mScrollSnapTypeX
=
=
NS_STYLE_SCROLL_SNAP_TYPE_PROXIMITY
&
&
std
:
:
abs
(
aDestination
.
x
-
finalPos
.
x
)
>
proximityThreshold
)
{
finalPos
.
x
=
aDestination
.
x
;
}
else
{
snapped
=
true
;
}
return
snapped
?
Some
(
finalPos
)
:
Nothing
(
)
;
}
}
