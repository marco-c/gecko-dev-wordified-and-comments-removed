#
include
"
ScrollSnap
.
h
"
#
include
"
FrameMetrics
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
nsLineLayout
.
h
"
namespace
mozilla
{
using
layers
:
:
ScrollSnapInfo
;
class
CalcSnapPoints
final
{
public
:
CalcSnapPoints
(
ScrollUnit
aUnit
ScrollSnapFlags
aSnapFlags
const
nsPoint
&
aDestination
const
nsPoint
&
aStartPos
)
;
struct
SnapPosition
{
SnapPosition
(
)
=
default
;
SnapPosition
(
nscoord
aPosition
StyleScrollSnapStop
aScrollSnapStop
)
:
mPosition
(
aPosition
)
mScrollSnapStop
(
aScrollSnapStop
)
{
}
nscoord
mPosition
;
StyleScrollSnapStop
mScrollSnapStop
;
}
;
void
AddHorizontalEdge
(
const
SnapPosition
&
aEdge
)
;
void
AddVerticalEdge
(
const
SnapPosition
&
aEdge
)
;
struct
CandidateTracker
{
explicit
CandidateTracker
(
nscoord
aDestination
)
:
mBestEdge
(
SnapPosition
{
aDestination
StyleScrollSnapStop
:
:
Normal
}
)
{
mSecondBestEdge
=
SnapPosition
{
nscoord_MAX
StyleScrollSnapStop
:
:
Normal
}
;
mEdgeFound
=
false
;
}
SnapPosition
mBestEdge
;
SnapPosition
mSecondBestEdge
;
bool
mEdgeFound
;
}
;
void
AddEdge
(
const
SnapPosition
&
aEdge
nscoord
aDestination
nscoord
aStartPos
nscoord
aScrollingDirection
CandidateTracker
*
aCandidateTracker
)
;
nsPoint
GetBestEdge
(
)
const
;
nscoord
XDistanceBetweenBestAndSecondEdge
(
)
const
{
return
std
:
:
abs
(
NSCoordSaturatingSubtract
(
mTrackerOnX
.
mSecondBestEdge
.
mPosition
mTrackerOnX
.
mBestEdge
.
mPosition
nscoord_MAX
)
)
;
}
nscoord
YDistanceBetweenBestAndSecondEdge
(
)
const
{
return
std
:
:
abs
(
NSCoordSaturatingSubtract
(
mTrackerOnY
.
mSecondBestEdge
.
mPosition
mTrackerOnY
.
mBestEdge
.
mPosition
nscoord_MAX
)
)
;
}
const
nsPoint
&
Destination
(
)
const
{
return
mDestination
;
}
protected
:
ScrollUnit
mUnit
;
ScrollSnapFlags
mSnapFlags
;
nsPoint
mDestination
;
nsPoint
mStartPos
;
nsIntPoint
mScrollingDirection
;
CandidateTracker
mTrackerOnX
;
CandidateTracker
mTrackerOnY
;
}
;
CalcSnapPoints
:
:
CalcSnapPoints
(
ScrollUnit
aUnit
ScrollSnapFlags
aSnapFlags
const
nsPoint
&
aDestination
const
nsPoint
&
aStartPos
)
:
mUnit
(
aUnit
)
mSnapFlags
(
aSnapFlags
)
mDestination
(
aDestination
)
mStartPos
(
aStartPos
)
mTrackerOnX
(
aDestination
.
x
)
mTrackerOnY
(
aDestination
.
y
)
{
MOZ_ASSERT
(
aSnapFlags
!
=
ScrollSnapFlags
:
:
Disabled
)
;
nsPoint
direction
=
aDestination
-
aStartPos
;
mScrollingDirection
=
nsIntPoint
(
0
0
)
;
if
(
direction
.
x
<
0
)
{
mScrollingDirection
.
x
=
-
1
;
}
if
(
direction
.
x
>
0
)
{
mScrollingDirection
.
x
=
1
;
}
if
(
direction
.
y
<
0
)
{
mScrollingDirection
.
y
=
-
1
;
}
if
(
direction
.
y
>
0
)
{
mScrollingDirection
.
y
=
1
;
}
}
nsPoint
CalcSnapPoints
:
:
GetBestEdge
(
)
const
{
return
nsPoint
(
mTrackerOnX
.
mEdgeFound
?
mTrackerOnX
.
mBestEdge
.
mPosition
:
mStartPos
.
x
mTrackerOnY
.
mEdgeFound
?
mTrackerOnY
.
mBestEdge
.
mPosition
:
mStartPos
.
y
)
;
}
void
CalcSnapPoints
:
:
AddHorizontalEdge
(
const
SnapPosition
&
aEdge
)
{
AddEdge
(
aEdge
mDestination
.
y
mStartPos
.
y
mScrollingDirection
.
y
&
mTrackerOnY
)
;
}
void
CalcSnapPoints
:
:
AddVerticalEdge
(
const
SnapPosition
&
aEdge
)
{
AddEdge
(
aEdge
mDestination
.
x
mStartPos
.
x
mScrollingDirection
.
x
&
mTrackerOnX
)
;
}
void
CalcSnapPoints
:
:
AddEdge
(
const
SnapPosition
&
aEdge
nscoord
aDestination
nscoord
aStartPos
nscoord
aScrollingDirection
CandidateTracker
*
aCandidateTracker
)
{
if
(
mSnapFlags
&
ScrollSnapFlags
:
:
IntendedDirection
)
{
if
(
aScrollingDirection
=
=
0
|
|
(
aEdge
.
mPosition
-
aStartPos
)
*
aScrollingDirection
<
=
0
)
{
return
;
}
}
if
(
!
aCandidateTracker
-
>
mEdgeFound
)
{
aCandidateTracker
-
>
mBestEdge
=
aEdge
;
aCandidateTracker
-
>
mEdgeFound
=
true
;
return
;
}
auto
isPreferredStopAlways
=
[
&
]
(
const
SnapPosition
&
aSnapPosition
)
-
>
bool
{
MOZ_ASSERT
(
mSnapFlags
&
ScrollSnapFlags
:
:
IntendedDirection
)
;
return
aSnapPosition
.
mScrollSnapStop
=
=
StyleScrollSnapStop
:
:
Always
&
&
std
:
:
abs
(
aSnapPosition
.
mPosition
-
aStartPos
)
<
std
:
:
abs
(
aDestination
-
aStartPos
)
;
}
;
const
bool
isOnOppositeSide
=
(
(
aEdge
.
mPosition
-
aDestination
)
>
0
)
!
=
(
(
aCandidateTracker
-
>
mBestEdge
.
mPosition
-
aDestination
)
>
0
)
;
const
nscoord
distanceFromStart
=
aEdge
.
mPosition
-
aStartPos
;
const
nscoord
distanceFromDestination
=
aEdge
.
mPosition
-
aDestination
;
auto
updateBestEdges
=
[
&
]
(
bool
aIsCloserThanBest
bool
aIsCloserThanSecond
)
{
if
(
aIsCloserThanBest
)
{
if
(
mSnapFlags
&
ScrollSnapFlags
:
:
IntendedDirection
&
&
isPreferredStopAlways
(
aEdge
)
)
{
aCandidateTracker
-
>
mSecondBestEdge
=
aEdge
;
}
else
if
(
isOnOppositeSide
)
{
aCandidateTracker
-
>
mSecondBestEdge
=
aCandidateTracker
-
>
mBestEdge
;
}
aCandidateTracker
-
>
mBestEdge
=
aEdge
;
}
else
if
(
aIsCloserThanSecond
)
{
if
(
isOnOppositeSide
)
{
aCandidateTracker
-
>
mSecondBestEdge
=
aEdge
;
}
}
}
;
bool
isCandidateOfBest
=
false
;
bool
isCandidateOfSecondBest
=
false
;
switch
(
mUnit
)
{
case
ScrollUnit
:
:
DEVICE_PIXELS
:
case
ScrollUnit
:
:
LINES
:
case
ScrollUnit
:
:
WHOLE
:
{
isCandidateOfBest
=
std
:
:
abs
(
distanceFromDestination
)
<
std
:
:
abs
(
aCandidateTracker
-
>
mBestEdge
.
mPosition
-
aDestination
)
;
isCandidateOfSecondBest
=
std
:
:
abs
(
distanceFromDestination
)
<
std
:
:
abs
(
NSCoordSaturatingSubtract
(
aCandidateTracker
-
>
mSecondBestEdge
.
mPosition
aDestination
nscoord_MAX
)
)
;
break
;
}
case
ScrollUnit
:
:
PAGES
:
{
nscoord
overshoot
=
distanceFromDestination
*
aScrollingDirection
;
nscoord
curOvershoot
=
(
aCandidateTracker
-
>
mBestEdge
.
mPosition
-
aDestination
)
*
aScrollingDirection
;
nscoord
secondOvershoot
=
NSCoordSaturatingSubtract
(
aCandidateTracker
-
>
mSecondBestEdge
.
mPosition
aDestination
nscoord_MAX
)
*
aScrollingDirection
;
if
(
overshoot
<
0
)
{
isCandidateOfBest
=
overshoot
>
curOvershoot
|
|
curOvershoot
>
=
0
;
isCandidateOfSecondBest
=
overshoot
>
secondOvershoot
|
|
secondOvershoot
>
=
0
;
}
if
(
overshoot
>
0
)
{
isCandidateOfBest
=
overshoot
<
curOvershoot
;
isCandidateOfSecondBest
=
overshoot
<
secondOvershoot
;
}
}
}
if
(
mSnapFlags
&
ScrollSnapFlags
:
:
IntendedDirection
)
{
if
(
isPreferredStopAlways
(
aEdge
)
)
{
isCandidateOfBest
=
std
:
:
abs
(
distanceFromStart
)
<
std
:
:
abs
(
aCandidateTracker
-
>
mBestEdge
.
mPosition
-
aStartPos
)
;
}
else
if
(
isPreferredStopAlways
(
aCandidateTracker
-
>
mBestEdge
)
)
{
isCandidateOfBest
=
false
;
}
}
updateBestEdges
(
isCandidateOfBest
isCandidateOfSecondBest
)
;
}
static
void
ProcessSnapPositions
(
CalcSnapPoints
&
aCalcSnapPoints
const
ScrollSnapInfo
&
aSnapInfo
)
{
for
(
const
auto
&
target
:
aSnapInfo
.
mSnapTargets
)
{
nsPoint
snapPoint
(
target
.
mSnapPositionX
?
*
target
.
mSnapPositionX
:
aCalcSnapPoints
.
Destination
(
)
.
x
target
.
mSnapPositionY
?
*
target
.
mSnapPositionY
:
aCalcSnapPoints
.
Destination
(
)
.
y
)
;
nsRect
snappedPort
=
nsRect
(
snapPoint
aSnapInfo
.
mSnapportSize
)
;
if
(
!
snappedPort
.
Intersects
(
target
.
mSnapArea
)
)
{
continue
;
}
if
(
target
.
mSnapPositionX
&
&
aSnapInfo
.
mScrollSnapStrictnessX
!
=
StyleScrollSnapStrictness
:
:
None
)
{
aCalcSnapPoints
.
AddVerticalEdge
(
{
*
target
.
mSnapPositionX
target
.
mScrollSnapStop
}
)
;
}
if
(
target
.
mSnapPositionY
&
&
aSnapInfo
.
mScrollSnapStrictnessY
!
=
StyleScrollSnapStrictness
:
:
None
)
{
aCalcSnapPoints
.
AddHorizontalEdge
(
{
*
target
.
mSnapPositionY
target
.
mScrollSnapStop
}
)
;
}
}
}
Maybe
<
nsPoint
>
ScrollSnapUtils
:
:
GetSnapPointForDestination
(
const
ScrollSnapInfo
&
aSnapInfo
ScrollUnit
aUnit
ScrollSnapFlags
aSnapFlags
const
nsRect
&
aScrollRange
const
nsPoint
&
aStartPos
const
nsPoint
&
aDestination
)
{
if
(
aSnapInfo
.
mScrollSnapStrictnessY
=
=
StyleScrollSnapStrictness
:
:
None
&
&
aSnapInfo
.
mScrollSnapStrictnessX
=
=
StyleScrollSnapStrictness
:
:
None
)
{
return
Nothing
(
)
;
}
if
(
!
aSnapInfo
.
HasSnapPositions
(
)
)
{
return
Nothing
(
)
;
}
CalcSnapPoints
calcSnapPoints
(
aUnit
aSnapFlags
aDestination
aStartPos
)
;
ProcessSnapPositions
(
calcSnapPoints
aSnapInfo
)
;
nsPoint
clampedDestination
=
aScrollRange
.
ClampPoint
(
aDestination
)
;
for
(
auto
range
:
aSnapInfo
.
mXRangeWiderThanSnapport
)
{
if
(
range
.
IsValid
(
clampedDestination
.
x
aSnapInfo
.
mSnapportSize
.
width
)
&
&
calcSnapPoints
.
XDistanceBetweenBestAndSecondEdge
(
)
>
aSnapInfo
.
mSnapportSize
.
width
)
{
calcSnapPoints
.
AddVerticalEdge
(
CalcSnapPoints
:
:
SnapPosition
{
clampedDestination
.
x
StyleScrollSnapStop
:
:
Normal
}
)
;
break
;
}
}
for
(
auto
range
:
aSnapInfo
.
mYRangeWiderThanSnapport
)
{
if
(
range
.
IsValid
(
clampedDestination
.
y
aSnapInfo
.
mSnapportSize
.
height
)
&
&
calcSnapPoints
.
YDistanceBetweenBestAndSecondEdge
(
)
>
aSnapInfo
.
mSnapportSize
.
height
)
{
calcSnapPoints
.
AddHorizontalEdge
(
CalcSnapPoints
:
:
SnapPosition
{
clampedDestination
.
y
StyleScrollSnapStop
:
:
Normal
}
)
;
break
;
}
}
bool
snapped
=
false
;
nsPoint
finalPos
=
calcSnapPoints
.
GetBestEdge
(
)
;
nscoord
proximityThreshold
=
StaticPrefs
:
:
layout_css_scroll_snap_proximity_threshold
(
)
;
proximityThreshold
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
proximityThreshold
)
;
if
(
aSnapInfo
.
mScrollSnapStrictnessY
=
=
StyleScrollSnapStrictness
:
:
Proximity
&
&
std
:
:
abs
(
aDestination
.
y
-
finalPos
.
y
)
>
proximityThreshold
)
{
finalPos
.
y
=
aDestination
.
y
;
}
else
{
snapped
=
true
;
}
if
(
aSnapInfo
.
mScrollSnapStrictnessX
=
=
StyleScrollSnapStrictness
:
:
Proximity
&
&
std
:
:
abs
(
aDestination
.
x
-
finalPos
.
x
)
>
proximityThreshold
)
{
finalPos
.
x
=
aDestination
.
x
;
}
else
{
snapped
=
true
;
}
return
snapped
?
Some
(
finalPos
)
:
Nothing
(
)
;
}
}
