#
include
"
ScrollSnap
.
h
"
#
include
"
FrameMetrics
.
h
"
#
include
"
mozilla
/
ScrollContainerFrame
.
h
"
#
include
"
mozilla
/
ScrollSnapInfo
.
h
"
#
include
"
mozilla
/
ServoStyleConsts
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
namespace
mozilla
{
class
CalcSnapPoints
final
{
using
SnapTarget
=
ScrollSnapInfo
:
:
SnapTarget
;
public
:
CalcSnapPoints
(
ScrollUnit
aUnit
ScrollSnapFlags
aSnapFlags
const
nsPoint
&
aDestination
const
nsPoint
&
aStartPos
)
;
struct
SnapPosition
:
public
SnapTarget
{
SnapPosition
(
const
SnapTarget
&
aSnapTarget
nscoord
aPosition
nscoord
aDistanceOnOtherAxis
)
:
SnapTarget
(
aSnapTarget
)
mPosition
(
aPosition
)
mDistanceOnOtherAxis
(
aDistanceOnOtherAxis
)
{
}
nscoord
mPosition
;
nscoord
mDistanceOnOtherAxis
;
}
;
void
AddHorizontalEdge
(
const
SnapTarget
&
aTarget
)
;
void
AddVerticalEdge
(
const
SnapTarget
&
aTarget
)
;
struct
CandidateTracker
{
nscoord
mSecondBestEdge
=
nscoord_MAX
;
AutoTArray
<
ScrollSnapTargetId
1
>
mTargetIds
;
AutoTArray
<
SnapPosition
1
>
mBestEdges
;
bool
EdgeFound
(
)
const
{
return
!
mBestEdges
.
IsEmpty
(
)
;
}
}
;
void
AddEdge
(
const
SnapPosition
&
aEdge
nscoord
aDestination
nscoord
aStartPos
nscoord
aScrollingDirection
CandidateTracker
*
aCandidateTracker
)
;
SnapDestination
GetBestEdge
(
const
nsSize
&
aSnapportSize
)
const
;
nscoord
XDistanceBetweenBestAndSecondEdge
(
)
const
{
return
std
:
:
abs
(
NSCoordSaturatingSubtract
(
mTrackerOnX
.
mSecondBestEdge
mTrackerOnX
.
EdgeFound
(
)
?
mTrackerOnX
.
mBestEdges
[
0
]
.
mPosition
:
mDestination
.
x
nscoord_MAX
)
)
;
}
nscoord
YDistanceBetweenBestAndSecondEdge
(
)
const
{
return
std
:
:
abs
(
NSCoordSaturatingSubtract
(
mTrackerOnY
.
mSecondBestEdge
mTrackerOnY
.
EdgeFound
(
)
?
mTrackerOnY
.
mBestEdges
[
0
]
.
mPosition
:
mDestination
.
y
nscoord_MAX
)
)
;
}
const
nsPoint
&
Destination
(
)
const
{
return
mDestination
;
}
protected
:
ScrollUnit
mUnit
;
ScrollSnapFlags
mSnapFlags
;
nsPoint
mDestination
;
nsPoint
mStartPos
;
nsIntPoint
mScrollingDirection
;
CandidateTracker
mTrackerOnX
;
CandidateTracker
mTrackerOnY
;
}
;
CalcSnapPoints
:
:
CalcSnapPoints
(
ScrollUnit
aUnit
ScrollSnapFlags
aSnapFlags
const
nsPoint
&
aDestination
const
nsPoint
&
aStartPos
)
:
mUnit
(
aUnit
)
mSnapFlags
(
aSnapFlags
)
mDestination
(
aDestination
)
mStartPos
(
aStartPos
)
{
MOZ_ASSERT
(
aSnapFlags
!
=
ScrollSnapFlags
:
:
Disabled
)
;
nsPoint
direction
=
aDestination
-
aStartPos
;
mScrollingDirection
=
nsIntPoint
(
0
0
)
;
if
(
direction
.
x
<
0
)
{
mScrollingDirection
.
x
=
-
1
;
}
if
(
direction
.
x
>
0
)
{
mScrollingDirection
.
x
=
1
;
}
if
(
direction
.
y
<
0
)
{
mScrollingDirection
.
y
=
-
1
;
}
if
(
direction
.
y
>
0
)
{
mScrollingDirection
.
y
=
1
;
}
}
SnapDestination
CalcSnapPoints
:
:
GetBestEdge
(
const
nsSize
&
aSnapportSize
)
const
{
if
(
mTrackerOnX
.
EdgeFound
(
)
&
&
mTrackerOnY
.
EdgeFound
(
)
)
{
nsPoint
bestCandidate
(
mTrackerOnX
.
mBestEdges
[
0
]
.
mPosition
mTrackerOnY
.
mBestEdges
[
0
]
.
mPosition
)
;
nsRect
snappedPort
=
nsRect
(
bestCandidate
aSnapportSize
)
;
AutoTArray
<
ScrollSnapTargetId
1
>
visibleTargetIdsOnX
;
nscoord
minimumDistanceOnY
=
nscoord_MAX
;
size_t
minimumXIndex
=
0
;
AutoTArray
<
ScrollSnapTargetId
1
>
minimumDistanceTargetIdsOnX
;
for
(
size_t
i
=
0
;
i
<
mTrackerOnX
.
mBestEdges
.
Length
(
)
;
i
+
+
)
{
const
auto
&
targetX
=
mTrackerOnX
.
mBestEdges
[
i
]
;
if
(
targetX
.
mSnapArea
.
Intersects
(
snappedPort
)
)
{
visibleTargetIdsOnX
.
AppendElement
(
targetX
.
mTargetId
)
;
}
if
(
targetX
.
mDistanceOnOtherAxis
<
minimumDistanceOnY
)
{
minimumDistanceOnY
=
targetX
.
mDistanceOnOtherAxis
;
minimumXIndex
=
i
;
minimumDistanceTargetIdsOnX
=
AutoTArray
<
ScrollSnapTargetId
1
>
{
targetX
.
mTargetId
}
;
}
else
if
(
minimumDistanceOnY
!
=
nscoord_MAX
&
&
targetX
.
mDistanceOnOtherAxis
=
=
minimumDistanceOnY
)
{
minimumDistanceTargetIdsOnX
.
AppendElement
(
targetX
.
mTargetId
)
;
}
}
AutoTArray
<
ScrollSnapTargetId
1
>
visibleTargetIdsOnY
;
nscoord
minimumDistanceOnX
=
nscoord_MAX
;
size_t
minimumYIndex
=
0
;
AutoTArray
<
ScrollSnapTargetId
1
>
minimumDistanceTargetIdsOnY
;
for
(
size_t
i
=
0
;
i
<
mTrackerOnY
.
mBestEdges
.
Length
(
)
;
i
+
+
)
{
const
auto
&
targetY
=
mTrackerOnY
.
mBestEdges
[
i
]
;
if
(
targetY
.
mSnapArea
.
Intersects
(
snappedPort
)
)
{
visibleTargetIdsOnY
.
AppendElement
(
targetY
.
mTargetId
)
;
}
if
(
targetY
.
mDistanceOnOtherAxis
<
minimumDistanceOnX
)
{
minimumDistanceOnX
=
targetY
.
mDistanceOnOtherAxis
;
minimumYIndex
=
i
;
minimumDistanceTargetIdsOnY
=
AutoTArray
<
ScrollSnapTargetId
1
>
{
targetY
.
mTargetId
}
;
}
else
if
(
minimumDistanceOnX
!
=
nscoord_MAX
&
&
targetY
.
mDistanceOnOtherAxis
=
=
minimumDistanceOnX
)
{
minimumDistanceTargetIdsOnY
.
AppendElement
(
targetY
.
mTargetId
)
;
}
}
if
(
!
visibleTargetIdsOnX
.
IsEmpty
(
)
&
&
!
visibleTargetIdsOnY
.
IsEmpty
(
)
)
{
return
SnapDestination
{
bestCandidate
ScrollSnapTargetIds
{
visibleTargetIdsOnX
visibleTargetIdsOnY
}
}
;
}
if
(
(
minimumDistanceOnX
=
=
nscoord_MAX
)
&
&
minimumDistanceOnY
!
=
nscoord_MAX
)
{
bestCandidate
.
y
=
*
mTrackerOnX
.
mBestEdges
[
minimumXIndex
]
.
mSnapPoint
.
mY
;
return
SnapDestination
{
bestCandidate
ScrollSnapTargetIds
{
minimumDistanceTargetIdsOnX
minimumDistanceTargetIdsOnX
}
}
;
}
if
(
minimumDistanceOnX
!
=
nscoord_MAX
&
&
minimumDistanceOnY
=
=
nscoord_MAX
)
{
bestCandidate
.
x
=
*
mTrackerOnY
.
mBestEdges
[
minimumYIndex
]
.
mSnapPoint
.
mX
;
return
SnapDestination
{
bestCandidate
ScrollSnapTargetIds
{
minimumDistanceTargetIdsOnY
minimumDistanceTargetIdsOnY
}
}
;
}
if
(
minimumDistanceOnX
!
=
nscoord_MAX
&
&
minimumDistanceOnY
!
=
nscoord_MAX
)
{
if
(
hypotf
(
NSCoordToFloat
(
mDestination
.
x
-
mTrackerOnX
.
mBestEdges
[
0
]
.
mPosition
)
NSCoordToFloat
(
minimumDistanceOnY
)
)
<
hypotf
(
NSCoordToFloat
(
minimumDistanceOnX
)
NSCoordToFloat
(
mDestination
.
y
-
mTrackerOnY
.
mBestEdges
[
0
]
.
mPosition
)
)
)
{
bestCandidate
.
y
=
*
mTrackerOnX
.
mBestEdges
[
minimumXIndex
]
.
mSnapPoint
.
mY
;
}
else
{
bestCandidate
.
x
=
*
mTrackerOnY
.
mBestEdges
[
minimumYIndex
]
.
mSnapPoint
.
mX
;
}
return
SnapDestination
{
bestCandidate
ScrollSnapTargetIds
{
minimumDistanceTargetIdsOnX
minimumDistanceTargetIdsOnY
}
}
;
}
MOZ_ASSERT_UNREACHABLE
(
"
There
'
s
at
least
one
candidate
on
either
axis
"
)
;
}
return
SnapDestination
{
nsPoint
(
mTrackerOnX
.
EdgeFound
(
)
?
mTrackerOnX
.
mBestEdges
[
0
]
.
mPosition
:
!
(
mSnapFlags
&
ScrollSnapFlags
:
:
IntendedDirection
)
?
mDestination
.
x
:
mStartPos
.
x
mTrackerOnY
.
EdgeFound
(
)
?
mTrackerOnY
.
mBestEdges
[
0
]
.
mPosition
:
!
(
mSnapFlags
&
ScrollSnapFlags
:
:
IntendedDirection
)
?
mDestination
.
y
:
mStartPos
.
y
)
ScrollSnapTargetIds
{
mTrackerOnX
.
mTargetIds
mTrackerOnY
.
mTargetIds
}
}
;
}
void
CalcSnapPoints
:
:
AddHorizontalEdge
(
const
SnapTarget
&
aTarget
)
{
MOZ_ASSERT
(
aTarget
.
mSnapPoint
.
mY
)
;
AddEdge
(
SnapPosition
{
aTarget
*
aTarget
.
mSnapPoint
.
mY
aTarget
.
mSnapPoint
.
mX
?
std
:
:
abs
(
mDestination
.
x
-
*
aTarget
.
mSnapPoint
.
mX
)
:
nscoord_MAX
}
mDestination
.
y
mStartPos
.
y
mScrollingDirection
.
y
&
mTrackerOnY
)
;
}
void
CalcSnapPoints
:
:
AddVerticalEdge
(
const
SnapTarget
&
aTarget
)
{
MOZ_ASSERT
(
aTarget
.
mSnapPoint
.
mX
)
;
AddEdge
(
SnapPosition
{
aTarget
*
aTarget
.
mSnapPoint
.
mX
aTarget
.
mSnapPoint
.
mY
?
std
:
:
abs
(
mDestination
.
y
-
*
aTarget
.
mSnapPoint
.
mY
)
:
nscoord_MAX
}
mDestination
.
x
mStartPos
.
x
mScrollingDirection
.
x
&
mTrackerOnX
)
;
}
void
CalcSnapPoints
:
:
AddEdge
(
const
SnapPosition
&
aEdge
nscoord
aDestination
nscoord
aStartPos
nscoord
aScrollingDirection
CandidateTracker
*
aCandidateTracker
)
{
if
(
mSnapFlags
&
ScrollSnapFlags
:
:
IntendedDirection
)
{
if
(
aScrollingDirection
=
=
0
|
|
(
aEdge
.
mPosition
-
aStartPos
)
*
aScrollingDirection
<
=
0
)
{
return
;
}
}
if
(
!
aCandidateTracker
-
>
EdgeFound
(
)
)
{
aCandidateTracker
-
>
mBestEdges
=
AutoTArray
<
SnapPosition
1
>
{
aEdge
}
;
aCandidateTracker
-
>
mTargetIds
=
AutoTArray
<
ScrollSnapTargetId
1
>
{
aEdge
.
mTargetId
}
;
return
;
}
auto
isPreferredStopAlways
=
[
&
]
(
const
SnapPosition
&
aSnapPosition
)
-
>
bool
{
MOZ_ASSERT
(
mSnapFlags
&
ScrollSnapFlags
:
:
IntendedDirection
)
;
return
aSnapPosition
.
mScrollSnapStop
=
=
StyleScrollSnapStop
:
:
Always
&
&
std
:
:
abs
(
aSnapPosition
.
mPosition
-
aStartPos
)
<
std
:
:
abs
(
aDestination
-
aStartPos
)
;
}
;
const
bool
isOnOppositeSide
=
(
(
aEdge
.
mPosition
-
aDestination
)
>
0
)
!
=
(
(
aCandidateTracker
-
>
mBestEdges
[
0
]
.
mPosition
-
aDestination
)
>
0
)
;
const
nscoord
distanceFromStart
=
aEdge
.
mPosition
-
aStartPos
;
const
nscoord
distanceFromDestination
=
aEdge
.
mPosition
-
aDestination
;
auto
updateBestEdges
=
[
&
]
(
bool
aIsCloserThanBest
bool
aIsCloserThanSecond
)
{
if
(
aIsCloserThanBest
)
{
if
(
mSnapFlags
&
ScrollSnapFlags
:
:
IntendedDirection
&
&
isPreferredStopAlways
(
aEdge
)
)
{
aCandidateTracker
-
>
mSecondBestEdge
=
aEdge
.
mPosition
;
}
else
if
(
isOnOppositeSide
)
{
aCandidateTracker
-
>
mSecondBestEdge
=
aCandidateTracker
-
>
mBestEdges
[
0
]
.
mPosition
;
}
aCandidateTracker
-
>
mBestEdges
=
AutoTArray
<
SnapPosition
1
>
{
aEdge
}
;
aCandidateTracker
-
>
mTargetIds
=
AutoTArray
<
ScrollSnapTargetId
1
>
{
aEdge
.
mTargetId
}
;
}
else
{
if
(
aEdge
.
mPosition
=
=
aCandidateTracker
-
>
mBestEdges
[
0
]
.
mPosition
)
{
aCandidateTracker
-
>
mTargetIds
.
AppendElement
(
aEdge
.
mTargetId
)
;
aCandidateTracker
-
>
mBestEdges
.
AppendElement
(
aEdge
)
;
}
if
(
aIsCloserThanSecond
&
&
isOnOppositeSide
)
{
aCandidateTracker
-
>
mSecondBestEdge
=
aEdge
.
mPosition
;
}
}
}
;
bool
isCandidateOfBest
=
false
;
bool
isCandidateOfSecondBest
=
false
;
switch
(
mUnit
)
{
case
ScrollUnit
:
:
DEVICE_PIXELS
:
case
ScrollUnit
:
:
LINES
:
case
ScrollUnit
:
:
WHOLE
:
{
isCandidateOfBest
=
std
:
:
abs
(
distanceFromDestination
)
<
std
:
:
abs
(
aCandidateTracker
-
>
mBestEdges
[
0
]
.
mPosition
-
aDestination
)
;
isCandidateOfSecondBest
=
std
:
:
abs
(
distanceFromDestination
)
<
std
:
:
abs
(
NSCoordSaturatingSubtract
(
aCandidateTracker
-
>
mSecondBestEdge
aDestination
nscoord_MAX
)
)
;
break
;
}
case
ScrollUnit
:
:
PAGES
:
{
nscoord
overshoot
=
distanceFromDestination
*
aScrollingDirection
;
nscoord
curOvershoot
=
(
aCandidateTracker
-
>
mBestEdges
[
0
]
.
mPosition
-
aDestination
)
*
aScrollingDirection
;
nscoord
secondOvershoot
=
NSCoordSaturatingSubtract
(
aCandidateTracker
-
>
mSecondBestEdge
aDestination
nscoord_MAX
)
*
aScrollingDirection
;
if
(
overshoot
<
0
)
{
isCandidateOfBest
=
overshoot
>
curOvershoot
|
|
curOvershoot
>
=
0
;
isCandidateOfSecondBest
=
overshoot
>
secondOvershoot
|
|
secondOvershoot
>
=
0
;
}
if
(
overshoot
>
0
)
{
isCandidateOfBest
=
overshoot
<
curOvershoot
;
isCandidateOfSecondBest
=
overshoot
<
secondOvershoot
;
}
}
}
if
(
mSnapFlags
&
ScrollSnapFlags
:
:
IntendedDirection
)
{
if
(
isPreferredStopAlways
(
aEdge
)
)
{
isCandidateOfBest
=
std
:
:
abs
(
distanceFromStart
)
<
std
:
:
abs
(
aCandidateTracker
-
>
mBestEdges
[
0
]
.
mPosition
-
aStartPos
)
;
}
else
if
(
isPreferredStopAlways
(
aCandidateTracker
-
>
mBestEdges
[
0
]
)
)
{
isCandidateOfBest
=
false
;
}
}
updateBestEdges
(
isCandidateOfBest
isCandidateOfSecondBest
)
;
}
static
void
ProcessSnapPositions
(
CalcSnapPoints
&
aCalcSnapPoints
const
ScrollSnapInfo
&
aSnapInfo
)
{
aSnapInfo
.
ForEachValidTargetFor
(
aCalcSnapPoints
.
Destination
(
)
[
&
]
(
const
auto
&
aTarget
)
-
>
bool
{
if
(
aTarget
.
mSnapPoint
.
mX
&
&
aSnapInfo
.
mScrollSnapStrictnessX
!
=
StyleScrollSnapStrictness
:
:
None
)
{
aCalcSnapPoints
.
AddVerticalEdge
(
aTarget
)
;
}
if
(
aTarget
.
mSnapPoint
.
mY
&
&
aSnapInfo
.
mScrollSnapStrictnessY
!
=
StyleScrollSnapStrictness
:
:
None
)
{
aCalcSnapPoints
.
AddHorizontalEdge
(
aTarget
)
;
}
return
true
;
}
)
;
}
Maybe
<
SnapDestination
>
ScrollSnapUtils
:
:
GetSnapPointForDestination
(
const
ScrollSnapInfo
&
aSnapInfo
ScrollUnit
aUnit
ScrollSnapFlags
aSnapFlags
const
nsRect
&
aScrollRange
const
nsPoint
&
aStartPos
const
nsPoint
&
aDestination
)
{
if
(
aSnapInfo
.
mScrollSnapStrictnessY
=
=
StyleScrollSnapStrictness
:
:
None
&
&
aSnapInfo
.
mScrollSnapStrictnessX
=
=
StyleScrollSnapStrictness
:
:
None
)
{
return
Nothing
(
)
;
}
if
(
!
aSnapInfo
.
HasSnapPositions
(
)
)
{
return
Nothing
(
)
;
}
CalcSnapPoints
calcSnapPoints
(
aUnit
aSnapFlags
aDestination
aStartPos
)
;
ProcessSnapPositions
(
calcSnapPoints
aSnapInfo
)
;
nsPoint
clampedDestination
=
aScrollRange
.
ClampPoint
(
aDestination
)
;
for
(
auto
range
:
aSnapInfo
.
mXRangeWiderThanSnapport
)
{
if
(
range
.
IsValid
(
clampedDestination
.
x
aSnapInfo
.
mSnapportSize
.
width
)
&
&
calcSnapPoints
.
XDistanceBetweenBestAndSecondEdge
(
)
>
aSnapInfo
.
mSnapportSize
.
width
)
{
calcSnapPoints
.
AddVerticalEdge
(
ScrollSnapInfo
:
:
SnapTarget
{
Some
(
clampedDestination
.
x
)
Nothing
(
)
range
.
mSnapArea
StyleScrollSnapStop
:
:
Normal
range
.
mTargetId
}
)
;
break
;
}
}
for
(
auto
range
:
aSnapInfo
.
mYRangeWiderThanSnapport
)
{
if
(
range
.
IsValid
(
clampedDestination
.
y
aSnapInfo
.
mSnapportSize
.
height
)
&
&
calcSnapPoints
.
YDistanceBetweenBestAndSecondEdge
(
)
>
aSnapInfo
.
mSnapportSize
.
height
)
{
calcSnapPoints
.
AddHorizontalEdge
(
ScrollSnapInfo
:
:
SnapTarget
{
Nothing
(
)
Some
(
clampedDestination
.
y
)
range
.
mSnapArea
StyleScrollSnapStop
:
:
Normal
range
.
mTargetId
}
)
;
break
;
}
}
bool
snapped
=
false
;
auto
finalPos
=
calcSnapPoints
.
GetBestEdge
(
aSnapInfo
.
mSnapportSize
)
;
constexpr
float
proximityRatio
=
0
.
3
;
if
(
aSnapInfo
.
mScrollSnapStrictnessY
=
=
StyleScrollSnapStrictness
:
:
Proximity
&
&
std
:
:
abs
(
aDestination
.
y
-
finalPos
.
mPosition
.
y
)
>
aSnapInfo
.
mSnapportSize
.
height
*
proximityRatio
)
{
finalPos
.
mPosition
.
y
=
aDestination
.
y
;
}
else
if
(
aSnapInfo
.
mScrollSnapStrictnessY
!
=
StyleScrollSnapStrictness
:
:
None
&
&
aDestination
.
y
!
=
finalPos
.
mPosition
.
y
)
{
snapped
=
true
;
}
if
(
aSnapInfo
.
mScrollSnapStrictnessX
=
=
StyleScrollSnapStrictness
:
:
Proximity
&
&
std
:
:
abs
(
aDestination
.
x
-
finalPos
.
mPosition
.
x
)
>
aSnapInfo
.
mSnapportSize
.
width
*
proximityRatio
)
{
finalPos
.
mPosition
.
x
=
aDestination
.
x
;
}
else
if
(
aSnapInfo
.
mScrollSnapStrictnessX
!
=
StyleScrollSnapStrictness
:
:
None
&
&
aDestination
.
x
!
=
finalPos
.
mPosition
.
x
)
{
snapped
=
true
;
}
return
snapped
?
Some
(
finalPos
)
:
Nothing
(
)
;
}
ScrollSnapTargetId
ScrollSnapUtils
:
:
GetTargetIdFor
(
const
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
&
&
aFrame
-
>
GetContent
(
)
)
;
return
ScrollSnapTargetId
{
reinterpret_cast
<
uintptr_t
>
(
aFrame
-
>
GetContent
(
)
)
}
;
}
static
std
:
:
pair
<
Maybe
<
nscoord
>
Maybe
<
nscoord
>
>
GetCandidateInLastTargets
(
const
ScrollSnapInfo
&
aSnapInfo
const
nsPoint
&
aCurrentPosition
const
UniquePtr
<
ScrollSnapTargetIds
>
&
aLastSnapTargetIds
const
nsIContent
*
aFocusedContent
)
{
ScrollSnapTargetId
targetIdForFocusedContent
=
ScrollSnapTargetId
:
:
None
;
if
(
aFocusedContent
&
&
aFocusedContent
-
>
GetPrimaryFrame
(
)
)
{
targetIdForFocusedContent
=
ScrollSnapUtils
:
:
GetTargetIdFor
(
aFocusedContent
-
>
GetPrimaryFrame
(
)
)
;
}
const
ScrollSnapInfo
:
:
SnapTarget
*
focusedTarget
=
nullptr
;
Maybe
<
nscoord
>
x
y
;
aSnapInfo
.
ForEachValidTargetFor
(
aCurrentPosition
[
&
]
(
const
auto
&
aTarget
)
-
>
bool
{
if
(
aTarget
.
mSnapPoint
.
mX
&
&
aSnapInfo
.
mScrollSnapStrictnessX
!
=
StyleScrollSnapStrictness
:
:
None
)
{
if
(
aLastSnapTargetIds
-
>
mIdsOnX
.
Contains
(
aTarget
.
mTargetId
)
)
{
if
(
targetIdForFocusedContent
=
=
aTarget
.
mTargetId
)
{
if
(
(
y
&
&
!
aTarget
.
mSnapArea
.
Intersects
(
nsRect
(
nsPoint
(
*
aTarget
.
mSnapPoint
.
mX
*
y
)
aSnapInfo
.
mSnapportSize
)
)
)
)
{
y
.
reset
(
)
;
}
focusedTarget
=
&
aTarget
;
x
=
aTarget
.
mSnapPoint
.
mX
;
}
if
(
!
x
)
{
if
(
!
y
|
|
(
y
&
&
aTarget
.
mSnapArea
.
Intersects
(
nsRect
(
nsPoint
(
*
aTarget
.
mSnapPoint
.
mX
*
y
)
aSnapInfo
.
mSnapportSize
)
)
)
)
{
x
=
aTarget
.
mSnapPoint
.
mX
;
}
}
}
}
if
(
aTarget
.
mSnapPoint
.
mY
&
&
aSnapInfo
.
mScrollSnapStrictnessY
!
=
StyleScrollSnapStrictness
:
:
None
)
{
if
(
aLastSnapTargetIds
-
>
mIdsOnY
.
Contains
(
aTarget
.
mTargetId
)
)
{
if
(
targetIdForFocusedContent
=
=
aTarget
.
mTargetId
)
{
NS_ASSERTION
(
!
focusedTarget
|
|
focusedTarget
=
=
&
aTarget
"
If
the
focused
target
has
been
found
on
X
axis
the
"
"
target
should
be
same
"
)
;
if
(
!
focusedTarget
&
&
(
x
&
&
!
aTarget
.
mSnapArea
.
Intersects
(
nsRect
(
nsPoint
(
*
x
*
aTarget
.
mSnapPoint
.
mY
)
aSnapInfo
.
mSnapportSize
)
)
)
)
{
x
.
reset
(
)
;
}
focusedTarget
=
&
aTarget
;
y
=
aTarget
.
mSnapPoint
.
mY
;
}
if
(
!
y
)
{
if
(
!
x
|
|
(
x
&
&
aTarget
.
mSnapArea
.
Intersects
(
nsRect
(
nsPoint
(
*
x
*
aTarget
.
mSnapPoint
.
mY
)
aSnapInfo
.
mSnapportSize
)
)
)
)
{
y
=
aTarget
.
mSnapPoint
.
mY
;
}
}
}
}
if
(
x
&
&
y
&
&
(
targetIdForFocusedContent
=
=
ScrollSnapTargetId
:
:
None
|
|
focusedTarget
)
)
{
return
false
;
}
return
true
;
}
)
;
return
{
x
y
}
;
}
Maybe
<
SnapDestination
>
ScrollSnapUtils
:
:
GetSnapPointForResnap
(
const
ScrollSnapInfo
&
aSnapInfo
const
nsRect
&
aScrollRange
const
nsPoint
&
aCurrentPosition
const
UniquePtr
<
ScrollSnapTargetIds
>
&
aLastSnapTargetIds
const
nsIContent
*
aFocusedContent
)
{
if
(
!
aLastSnapTargetIds
)
{
return
GetSnapPointForDestination
(
aSnapInfo
ScrollUnit
:
:
DEVICE_PIXELS
ScrollSnapFlags
:
:
IntendedEndPosition
aScrollRange
aCurrentPosition
aCurrentPosition
)
;
}
auto
[
x
y
]
=
GetCandidateInLastTargets
(
aSnapInfo
aCurrentPosition
aLastSnapTargetIds
aFocusedContent
)
;
if
(
!
x
&
&
!
y
)
{
return
GetSnapPointForDestination
(
aSnapInfo
ScrollUnit
:
:
DEVICE_PIXELS
ScrollSnapFlags
:
:
IntendedEndPosition
aScrollRange
aCurrentPosition
aCurrentPosition
)
;
}
if
(
!
x
|
|
!
y
)
{
nsPoint
newPosition
=
nsPoint
(
x
?
*
x
:
aCurrentPosition
.
x
y
?
*
y
:
aCurrentPosition
.
y
)
;
CalcSnapPoints
calcSnapPoints
(
ScrollUnit
:
:
DEVICE_PIXELS
ScrollSnapFlags
:
:
IntendedEndPosition
newPosition
newPosition
)
;
aSnapInfo
.
ForEachValidTargetFor
(
newPosition
[
&
&
x
=
x
&
y
=
y
]
(
const
auto
&
aTarget
)
-
>
bool
{
if
(
!
x
&
&
aTarget
.
mSnapPoint
.
mX
&
&
aSnapInfo
.
mScrollSnapStrictnessX
!
=
StyleScrollSnapStrictness
:
:
None
)
{
calcSnapPoints
.
AddVerticalEdge
(
aTarget
)
;
}
if
(
!
y
&
&
aTarget
.
mSnapPoint
.
mY
&
&
aSnapInfo
.
mScrollSnapStrictnessY
!
=
StyleScrollSnapStrictness
:
:
None
)
{
calcSnapPoints
.
AddHorizontalEdge
(
aTarget
)
;
}
return
true
;
}
)
;
auto
finalPos
=
calcSnapPoints
.
GetBestEdge
(
aSnapInfo
.
mSnapportSize
)
;
if
(
!
x
)
{
x
=
Some
(
finalPos
.
mPosition
.
x
)
;
}
if
(
!
y
)
{
y
=
Some
(
finalPos
.
mPosition
.
y
)
;
}
}
SnapDestination
snapTarget
{
nsPoint
(
*
x
*
y
)
}
;
aSnapInfo
.
ForEachValidTargetFor
(
snapTarget
.
mPosition
[
&
&
x
=
x
&
y
=
y
]
(
const
auto
&
aTarget
)
-
>
bool
{
if
(
aTarget
.
mSnapPoint
.
mX
&
&
aSnapInfo
.
mScrollSnapStrictnessX
!
=
StyleScrollSnapStrictness
:
:
None
&
&
aTarget
.
mSnapPoint
.
mX
=
=
x
)
{
snapTarget
.
mTargetIds
.
mIdsOnX
.
AppendElement
(
aTarget
.
mTargetId
)
;
}
if
(
aTarget
.
mSnapPoint
.
mY
&
&
aSnapInfo
.
mScrollSnapStrictnessY
!
=
StyleScrollSnapStrictness
:
:
None
&
&
aTarget
.
mSnapPoint
.
mY
=
=
y
)
{
snapTarget
.
mTargetIds
.
mIdsOnY
.
AppendElement
(
aTarget
.
mTargetId
)
;
}
return
true
;
}
)
;
return
Some
(
snapTarget
)
;
}
void
ScrollSnapUtils
:
:
PostPendingResnapIfNeededFor
(
nsIFrame
*
aFrame
)
{
ScrollSnapTargetId
id
=
GetTargetIdFor
(
aFrame
)
;
if
(
id
=
=
ScrollSnapTargetId
:
:
None
)
{
return
;
}
if
(
ScrollContainerFrame
*
sf
=
nsLayoutUtils
:
:
GetNearestScrollContainerFrame
(
aFrame
nsLayoutUtils
:
:
SCROLLABLE_SAME_DOC
|
nsLayoutUtils
:
:
SCROLLABLE_INCLUDE_HIDDEN
)
)
{
sf
-
>
PostPendingResnapIfNeeded
(
aFrame
)
;
}
}
void
ScrollSnapUtils
:
:
PostPendingResnapFor
(
nsIFrame
*
aFrame
)
{
if
(
ScrollContainerFrame
*
sf
=
nsLayoutUtils
:
:
GetNearestScrollContainerFrame
(
aFrame
nsLayoutUtils
:
:
SCROLLABLE_SAME_DOC
|
nsLayoutUtils
:
:
SCROLLABLE_INCLUDE_HIDDEN
)
)
{
sf
-
>
PostPendingResnap
(
)
;
}
}
bool
ScrollSnapUtils
:
:
NeedsToRespectTargetWritingMode
(
const
nsSize
&
aSnapAreaSize
const
nsSize
&
aSnapportSize
)
{
return
aSnapAreaSize
.
width
>
aSnapportSize
.
width
|
|
aSnapAreaSize
.
height
>
aSnapportSize
.
height
;
}
static
nsRect
InflateByScrollMargin
(
const
nsRect
&
aTargetRect
const
nsMargin
&
aScrollMargin
const
nsRect
&
aScrolledRect
)
{
nsRect
result
=
aTargetRect
;
result
.
Inflate
(
aScrollMargin
)
;
return
result
.
Intersect
(
aScrolledRect
)
;
}
nsRect
ScrollSnapUtils
:
:
GetSnapAreaFor
(
const
nsIFrame
*
aFrame
const
nsIFrame
*
aScrolledFrame
const
nsRect
&
aScrolledRect
)
{
nsRect
targetRect
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
aFrame
aFrame
-
>
GetRectRelativeToSelf
(
)
aScrolledFrame
)
;
nsMargin
scrollMargin
=
aFrame
-
>
StyleMargin
(
)
-
>
GetScrollMargin
(
)
;
return
InflateByScrollMargin
(
targetRect
scrollMargin
aScrolledRect
)
;
}
}
