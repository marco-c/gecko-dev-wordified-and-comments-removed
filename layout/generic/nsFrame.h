#
ifndef
nsFrame_h___
#
define
nsFrame_h___
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
ReflowInput
.
h
"
#
include
"
nsHTMLParts
.
h
"
#
include
"
nsISelectionDisplay
.
h
"
namespace
mozilla
{
enum
class
TableSelectionMode
:
uint32_t
;
class
PresShell
;
}
#
define
NS_FRAME_TRACE_CALLS
0x1
#
define
NS_FRAME_TRACE_PUSH_PULL
0x2
#
define
NS_FRAME_TRACE_CHILD_REFLOW
0x4
#
define
NS_FRAME_TRACE_NEW_FRAMES
0x8
#
define
NS_FRAME_LOG_TEST
(
_lm
_bit
)
\
(
int
(
(
(
mozilla
:
:
LogModule
*
)
_lm
)
-
>
Level
(
)
)
&
(
_bit
)
)
#
ifdef
DEBUG
#
define
NS_FRAME_LOG
(
_bit
_args
)
\
PR_BEGIN_MACRO
\
if
(
NS_FRAME_LOG_TEST
(
nsFrame
:
:
sFrameLogModule
_bit
)
)
{
\
printf_stderr
_args
;
\
}
\
PR_END_MACRO
#
else
#
define
NS_FRAME_LOG
(
_bit
_args
)
#
endif
#
ifdef
DEBUG
#
define
NS_FRAME_TRACE_IN
(
_method
)
Trace
(
_method
true
)
#
define
NS_FRAME_TRACE_OUT
(
_method
)
Trace
(
_method
false
)
#
define
NS_FRAME_TRACE
(
_bit
_args
)
\
PR_BEGIN_MACRO
\
if
(
NS_FRAME_LOG_TEST
(
nsFrame
:
:
sFrameLogModule
_bit
)
)
{
\
TraceMsg
_args
;
\
}
\
PR_END_MACRO
#
define
NS_FRAME_TRACE_REFLOW_IN
(
_method
)
Trace
(
_method
true
)
#
define
NS_FRAME_TRACE_REFLOW_OUT
(
_method
_status
)
\
Trace
(
_method
false
_status
)
#
else
#
define
NS_FRAME_TRACE
(
_bits
_args
)
#
define
NS_FRAME_TRACE_IN
(
_method
)
#
define
NS_FRAME_TRACE_OUT
(
_method
)
#
define
NS_FRAME_TRACE_REFLOW_IN
(
_method
)
#
define
NS_FRAME_TRACE_REFLOW_OUT
(
_method
_status
)
#
endif
#
define
NS_DECL_FRAMEARENA_HELPERS
(
class
)
\
NS_DECL_QUERYFRAME_TARGET
(
class
)
\
static
constexpr
nsIFrame
:
:
ClassID
kClassID
=
nsIFrame
:
:
ClassID
:
:
class
#
#
_id
;
\
void
*
operator
new
(
size_t
mozilla
:
:
PresShell
*
)
MOZ_MUST_OVERRIDE
;
\
nsQueryFrame
:
:
FrameIID
GetFrameId
(
)
const
override
MOZ_MUST_OVERRIDE
{
\
return
nsQueryFrame
:
:
class
#
#
_id
;
\
}
#
define
NS_IMPL_FRAMEARENA_HELPERS
(
class
)
\
void
*
class
:
:
operator
new
(
size_t
sz
mozilla
:
:
PresShell
*
aShell
)
{
\
return
aShell
-
>
AllocateFrame
(
nsQueryFrame
:
:
class
#
#
_id
sz
)
;
\
}
#
define
NS_DECL_ABSTRACT_FRAME
(
class
)
\
void
*
operator
new
(
size_t
mozilla
:
:
PresShell
*
)
MOZ_MUST_OVERRIDE
=
delete
;
\
nsQueryFrame
:
:
FrameIID
GetFrameId
(
)
const
override
MOZ_MUST_OVERRIDE
=
0
;
struct
nsBoxLayoutMetrics
;
struct
nsRect
;
class
nsFrame
:
public
nsIFrame
{
public
:
friend
nsIFrame
*
NS_NewEmptyFrame
(
mozilla
:
:
PresShell
*
aShell
ComputedStyle
*
aStyle
)
;
private
:
void
*
operator
new
(
size_t
sz
)
noexcept
(
true
)
;
protected
:
void
operator
delete
(
void
*
aPtr
size_t
sz
)
;
public
:
NS_DECL_QUERYFRAME
NS_DECL_QUERYFRAME_TARGET
(
nsFrame
)
virtual
nsQueryFrame
:
:
FrameIID
GetFrameId
(
)
const
MOZ_MUST_OVERRIDE
{
return
kFrameIID
;
}
void
*
operator
new
(
size_t
mozilla
:
:
PresShell
*
)
MOZ_MUST_OVERRIDE
;
void
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
override
;
void
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
override
;
static
nsresult
GetNextPrevLineFromeBlockFrame
(
nsPresContext
*
aPresContext
nsPeekOffsetStruct
*
aPos
nsIFrame
*
aBlockFrame
int32_t
aLineStart
int8_t
aOutSideLimit
)
;
mozilla
:
:
LogicalSize
ComputeSizeWithIntrinsicDimensions
(
gfxContext
*
aRenderingContext
mozilla
:
:
WritingMode
aWM
const
mozilla
:
:
IntrinsicSize
&
aIntrinsicSize
const
mozilla
:
:
AspectRatio
&
aIntrinsicRatio
const
mozilla
:
:
LogicalSize
&
aCBSize
const
mozilla
:
:
LogicalSize
&
aMargin
const
mozilla
:
:
LogicalSize
&
aBorder
const
mozilla
:
:
LogicalSize
&
aPadding
ComputeSizeFlags
aFlags
)
;
nsRect
ComputeSimpleTightBounds
(
mozilla
:
:
gfx
:
:
DrawTarget
*
aDrawTarget
)
const
;
void
DidReflow
(
nsPresContext
*
aPresContext
const
ReflowInput
*
aReflowInput
)
override
;
void
ReflowAbsoluteFrames
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
bool
aConstrainBSize
=
true
)
;
void
FinishReflowWithAbsoluteFrames
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
bool
aConstrainBSize
=
true
)
;
void
PushDirtyBitToAbsoluteFrames
(
)
;
nsresult
PeekBackwardAndForward
(
nsSelectionAmount
aAmountBack
nsSelectionAmount
aAmountForward
int32_t
aStartPos
bool
aJumpLines
uint32_t
aSelectFlags
)
;
virtual
ContentOffsets
CalcContentOffsetsFromFramePoint
(
const
nsPoint
&
aPoint
)
;
nsSize
GetXULPrefSize
(
nsBoxLayoutState
&
aBoxLayoutState
)
override
;
nsSize
GetXULMinSize
(
nsBoxLayoutState
&
aBoxLayoutState
)
override
;
nsSize
GetXULMaxSize
(
nsBoxLayoutState
&
aBoxLayoutState
)
override
;
nscoord
GetXULFlex
(
)
override
;
nscoord
GetXULBoxAscent
(
nsBoxLayoutState
&
aBoxLayoutState
)
override
;
bool
IsFrameTreeTooDeep
(
const
ReflowInput
&
aReflowInput
ReflowOutput
&
aMetrics
nsReflowStatus
&
aStatus
)
;
void
ConsiderChildOverflow
(
nsOverflowAreas
&
aOverflowAreas
nsIFrame
*
aChildFrame
)
;
bool
ShouldAvoidBreakInside
(
const
ReflowInput
&
aReflowInput
)
const
;
#
ifdef
DEBUG
void
Trace
(
const
char
*
aMethod
bool
aEnter
)
;
void
Trace
(
const
char
*
aMethod
bool
aEnter
const
nsReflowStatus
&
aStatus
)
;
void
TraceMsg
(
const
char
*
fmt
.
.
.
)
MOZ_FORMAT_PRINTF
(
2
3
)
;
static
void
VerifyDirtyBitSet
(
const
nsFrameList
&
aFrameList
)
;
static
void
*
DisplayReflowEnter
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
const
ReflowInput
&
aReflowInput
)
;
static
void
*
DisplayLayoutEnter
(
nsIFrame
*
aFrame
)
;
static
void
*
DisplayIntrinsicISizeEnter
(
nsIFrame
*
aFrame
const
char
*
aType
)
;
static
void
*
DisplayIntrinsicSizeEnter
(
nsIFrame
*
aFrame
const
char
*
aType
)
;
static
void
DisplayReflowExit
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
ReflowOutput
&
aMetrics
const
nsReflowStatus
&
aStatus
void
*
aFrameTreeNode
)
;
static
void
DisplayLayoutExit
(
nsIFrame
*
aFrame
void
*
aFrameTreeNode
)
;
static
void
DisplayIntrinsicISizeExit
(
nsIFrame
*
aFrame
const
char
*
aType
nscoord
aResult
void
*
aFrameTreeNode
)
;
static
void
DisplayIntrinsicSizeExit
(
nsIFrame
*
aFrame
const
char
*
aType
nsSize
aResult
void
*
aFrameTreeNode
)
;
static
void
DisplayReflowStartup
(
)
;
static
void
DisplayReflowShutdown
(
)
;
#
endif
bool
DisplayBackgroundUnconditional
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
bool
aForceBackground
)
;
void
DisplayBorderBackgroundOutline
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
bool
aForceBackground
=
false
)
;
void
DisplayOutlineUnconditional
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
;
void
DisplayOutline
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
;
void
DisplayInsetBoxShadowUnconditional
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
)
;
void
DisplayInsetBoxShadow
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
)
;
void
DisplayOutsetBoxShadowUnconditional
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
)
;
void
DisplayOutsetBoxShadow
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
)
;
static
nsIFrame
*
CorrectStyleParentFrame
(
nsIFrame
*
aProspectiveParent
mozilla
:
:
PseudoStyleType
aChildPseudo
)
;
protected
:
nsFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
ClassID
aID
)
;
explicit
nsFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
:
nsFrame
(
aStyle
aPresContext
ClassID
:
:
nsFrame_id
)
{
}
virtual
~
nsFrame
(
)
;
void
DisplaySelectionOverlay
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
uint16_t
aContentType
=
nsISelectionDisplay
:
:
DISPLAY_FRAMES
)
;
public
:
void
CreateView
(
)
;
static
void
GetLastLeaf
(
nsPresContext
*
aPresContext
nsIFrame
*
*
aFrame
)
;
static
void
GetFirstLeaf
(
nsPresContext
*
aPresContext
nsIFrame
*
*
aFrame
)
;
static
int32_t
GetLineNumber
(
nsIFrame
*
aFrame
bool
aLockScroll
nsIFrame
*
*
aContainingBlock
=
nullptr
)
;
static
bool
ShouldApplyOverflowClipping
(
const
nsIFrame
*
aFrame
const
nsStyleDisplay
*
aDisp
)
{
MOZ_ASSERT
(
aDisp
=
=
aFrame
-
>
StyleDisplay
(
)
"
Wong
display
struct
"
)
;
if
(
MOZ_UNLIKELY
(
aDisp
-
>
mOverflowX
=
=
mozilla
:
:
StyleOverflow
:
:
MozHiddenUnscrollable
&
&
!
aFrame
-
>
IsListControlFrame
(
)
)
)
{
return
true
;
}
if
(
aDisp
-
>
IsContainPaint
(
)
&
&
!
aFrame
-
>
IsScrollFrame
(
)
&
&
aFrame
-
>
IsFrameOfType
(
eSupportsContainLayoutAndPaint
)
)
{
return
true
;
}
if
(
aDisp
-
>
mOverflowX
=
=
mozilla
:
:
StyleOverflow
:
:
Hidden
&
&
aDisp
-
>
mOverflowY
=
=
mozilla
:
:
StyleOverflow
:
:
Hidden
)
{
mozilla
:
:
LayoutFrameType
type
=
aFrame
-
>
Type
(
)
;
if
(
type
=
=
mozilla
:
:
LayoutFrameType
:
:
Table
|
|
type
=
=
mozilla
:
:
LayoutFrameType
:
:
TableCell
|
|
type
=
=
mozilla
:
:
LayoutFrameType
:
:
SVGOuterSVG
|
|
type
=
=
mozilla
:
:
LayoutFrameType
:
:
SVGInnerSVG
|
|
type
=
=
mozilla
:
:
LayoutFrameType
:
:
SVGSymbol
|
|
type
=
=
mozilla
:
:
LayoutFrameType
:
:
SVGForeignObject
)
{
return
true
;
}
if
(
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eReplacedContainsBlock
)
)
{
if
(
type
=
=
mozilla
:
:
LayoutFrameType
:
:
TextInput
)
{
return
false
;
}
return
true
;
}
}
if
(
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_SVG_LAYOUT
)
)
{
return
false
;
}
return
(
aFrame
-
>
GetStateBits
(
)
&
NS_BLOCK_CLIP_PAGINATED_OVERFLOW
)
!
=
0
&
&
aFrame
-
>
PresContext
(
)
-
>
IsPaginated
(
)
&
&
aFrame
-
>
IsBlockFrame
(
)
;
}
protected
:
NS_IMETHOD
DoXULLayout
(
nsBoxLayoutState
&
aBoxLayoutState
)
override
;
void
FireDOMEvent
(
const
nsAString
&
aDOMEventName
nsIContent
*
aContent
=
nullptr
)
;
private
:
void
BoxReflow
(
nsBoxLayoutState
&
aState
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
gfxContext
*
aRenderingContext
nscoord
aX
nscoord
aY
nscoord
aWidth
nscoord
aHeight
bool
aMoveFrame
=
true
)
;
NS_IMETHODIMP
RefreshSizeCache
(
nsBoxLayoutState
&
aState
)
;
bool
HasCSSAnimations
(
)
;
bool
HasCSSTransitions
(
)
;
public
:
#
ifdef
DEBUG_FRAME_DUMP
nsresult
GetFrameName
(
nsAString
&
aResult
)
const
override
;
nsresult
MakeFrameName
(
const
nsAString
&
aKind
nsAString
&
aResult
)
const
;
static
int32_t
ContentIndexInContainer
(
const
nsIFrame
*
aFrame
)
;
#
endif
#
ifdef
DEBUG
static
mozilla
:
:
LazyLogModule
sFrameLogModule
;
static
void
ShowFrameBorders
(
bool
aEnable
)
;
static
bool
GetShowFrameBorders
(
)
;
static
void
ShowEventTargetFrameBorder
(
bool
aEnable
)
;
static
bool
GetShowEventTargetFrameBorder
(
)
;
#
endif
static
void
PrintDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayList
&
aList
bool
aDumpHtml
=
false
)
{
std
:
:
stringstream
ss
;
PrintDisplayList
(
aBuilder
aList
ss
aDumpHtml
)
;
fprintf_stderr
(
stderr
"
%
s
"
ss
.
str
(
)
.
c_str
(
)
)
;
}
static
void
PrintDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayList
&
aList
std
:
:
stringstream
&
aStream
bool
aDumpHtml
=
false
)
;
static
void
PrintDisplayItem
(
nsDisplayListBuilder
*
aBuilder
nsDisplayItem
*
aItem
std
:
:
stringstream
&
aStream
uint32_t
aIndent
=
0
bool
aDumpSublist
=
false
bool
aDumpHtml
=
false
)
;
static
void
PrintDisplayListSet
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aList
std
:
:
stringstream
&
aStream
bool
aDumpHtml
=
false
)
;
}
;
#
ifdef
DEBUG
struct
DR_cookie
{
DR_cookie
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
const
mozilla
:
:
ReflowInput
&
aReflowInput
mozilla
:
:
ReflowOutput
&
aMetrics
nsReflowStatus
&
aStatus
)
;
~
DR_cookie
(
)
;
void
Change
(
)
const
;
nsPresContext
*
mPresContext
;
nsIFrame
*
mFrame
;
const
mozilla
:
:
ReflowInput
&
mReflowInput
;
mozilla
:
:
ReflowOutput
&
mMetrics
;
nsReflowStatus
&
mStatus
;
void
*
mValue
;
}
;
struct
DR_layout_cookie
{
explicit
DR_layout_cookie
(
nsIFrame
*
aFrame
)
;
~
DR_layout_cookie
(
)
;
nsIFrame
*
mFrame
;
void
*
mValue
;
}
;
struct
DR_intrinsic_inline_size_cookie
{
DR_intrinsic_inline_size_cookie
(
nsIFrame
*
aFrame
const
char
*
aType
nscoord
&
aResult
)
;
~
DR_intrinsic_inline_size_cookie
(
)
;
nsIFrame
*
mFrame
;
const
char
*
mType
;
nscoord
&
mResult
;
void
*
mValue
;
}
;
struct
DR_intrinsic_size_cookie
{
DR_intrinsic_size_cookie
(
nsIFrame
*
aFrame
const
char
*
aType
nsSize
&
aResult
)
;
~
DR_intrinsic_size_cookie
(
)
;
nsIFrame
*
mFrame
;
const
char
*
mType
;
nsSize
&
mResult
;
void
*
mValue
;
}
;
struct
DR_init_constraints_cookie
{
DR_init_constraints_cookie
(
nsIFrame
*
aFrame
mozilla
:
:
ReflowInput
*
aState
nscoord
aCBWidth
nscoord
aCBHeight
const
nsMargin
*
aBorder
const
nsMargin
*
aPadding
)
;
~
DR_init_constraints_cookie
(
)
;
nsIFrame
*
mFrame
;
mozilla
:
:
ReflowInput
*
mState
;
void
*
mValue
;
}
;
struct
DR_init_offsets_cookie
{
DR_init_offsets_cookie
(
nsIFrame
*
aFrame
mozilla
:
:
SizeComputationInput
*
aState
nscoord
aPercentBasis
mozilla
:
:
WritingMode
aCBWritingMode
const
nsMargin
*
aBorder
const
nsMargin
*
aPadding
)
;
~
DR_init_offsets_cookie
(
)
;
nsIFrame
*
mFrame
;
mozilla
:
:
SizeComputationInput
*
mState
;
void
*
mValue
;
}
;
struct
DR_init_type_cookie
{
DR_init_type_cookie
(
nsIFrame
*
aFrame
mozilla
:
:
ReflowInput
*
aState
)
;
~
DR_init_type_cookie
(
)
;
nsIFrame
*
mFrame
;
mozilla
:
:
ReflowInput
*
mState
;
void
*
mValue
;
}
;
#
define
DISPLAY_REFLOW
(
dr_pres_context
dr_frame
dr_rf_state
\
dr_rf_metrics
dr_rf_status
)
\
DR_cookie
dr_cookie
(
dr_pres_context
dr_frame
dr_rf_state
dr_rf_metrics
\
dr_rf_status
)
;
#
define
DISPLAY_REFLOW_CHANGE
(
)
dr_cookie
.
Change
(
)
;
#
define
DISPLAY_LAYOUT
(
dr_frame
)
DR_layout_cookie
dr_cookie
(
dr_frame
)
;
#
define
DISPLAY_MIN_INLINE_SIZE
(
dr_frame
dr_result
)
\
DR_intrinsic_inline_size_cookie
dr_cookie
(
dr_frame
"
Min
"
dr_result
)
#
define
DISPLAY_PREF_INLINE_SIZE
(
dr_frame
dr_result
)
\
DR_intrinsic_inline_size_cookie
dr_cookie
(
dr_frame
"
Pref
"
dr_result
)
#
define
DISPLAY_PREF_SIZE
(
dr_frame
dr_result
)
\
DR_intrinsic_size_cookie
dr_cookie
(
dr_frame
"
Pref
"
dr_result
)
#
define
DISPLAY_MIN_SIZE
(
dr_frame
dr_result
)
\
DR_intrinsic_size_cookie
dr_cookie
(
dr_frame
"
Min
"
dr_result
)
#
define
DISPLAY_MAX_SIZE
(
dr_frame
dr_result
)
\
DR_intrinsic_size_cookie
dr_cookie
(
dr_frame
"
Max
"
dr_result
)
#
define
DISPLAY_INIT_CONSTRAINTS
(
dr_frame
dr_state
dr_cbw
dr_cbh
dr_bdr
\
dr_pad
)
\
DR_init_constraints_cookie
dr_cookie
(
dr_frame
dr_state
dr_cbw
dr_cbh
\
dr_bdr
dr_pad
)
#
define
DISPLAY_INIT_OFFSETS
(
dr_frame
dr_state
dr_pb
dr_cbwm
dr_bdr
\
dr_pad
)
\
DR_init_offsets_cookie
dr_cookie
(
dr_frame
dr_state
dr_pb
dr_cbwm
\
dr_bdr
dr_pad
)
#
define
DISPLAY_INIT_TYPE
(
dr_frame
dr_result
)
\
DR_init_type_cookie
dr_cookie
(
dr_frame
dr_result
)
#
else
#
define
DISPLAY_REFLOW
(
dr_pres_context
dr_frame
dr_rf_state
\
dr_rf_metrics
dr_rf_status
)
#
define
DISPLAY_REFLOW_CHANGE
(
)
#
define
DISPLAY_LAYOUT
(
dr_frame
)
PR_BEGIN_MACRO
PR_END_MACRO
#
define
DISPLAY_MIN_INLINE_SIZE
(
dr_frame
dr_result
)
\
PR_BEGIN_MACRO
PR_END_MACRO
#
define
DISPLAY_PREF_INLINE_SIZE
(
dr_frame
dr_result
)
\
PR_BEGIN_MACRO
PR_END_MACRO
#
define
DISPLAY_PREF_SIZE
(
dr_frame
dr_result
)
PR_BEGIN_MACRO
PR_END_MACRO
#
define
DISPLAY_MIN_SIZE
(
dr_frame
dr_result
)
PR_BEGIN_MACRO
PR_END_MACRO
#
define
DISPLAY_MAX_SIZE
(
dr_frame
dr_result
)
PR_BEGIN_MACRO
PR_END_MACRO
#
define
DISPLAY_INIT_CONSTRAINTS
(
dr_frame
dr_state
dr_cbw
dr_cbh
dr_bdr
\
dr_pad
)
\
PR_BEGIN_MACRO
PR_END_MACRO
#
define
DISPLAY_INIT_OFFSETS
(
dr_frame
dr_state
dr_pb
dr_cbwm
dr_bdr
\
dr_pad
)
\
PR_BEGIN_MACRO
PR_END_MACRO
#
define
DISPLAY_INIT_TYPE
(
dr_frame
dr_result
)
PR_BEGIN_MACRO
PR_END_MACRO
#
endif
#
endif
