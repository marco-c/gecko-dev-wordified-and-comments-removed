#
ifndef
nsFrame_h___
#
define
nsFrame_h___
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
nsBox
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
mozilla
/
ReflowInput
.
h
"
#
include
"
nsHTMLParts
.
h
"
#
include
"
nsISelectionDisplay
.
h
"
#
define
NS_FRAME_TRACE_CALLS
0x1
#
define
NS_FRAME_TRACE_PUSH_PULL
0x2
#
define
NS_FRAME_TRACE_CHILD_REFLOW
0x4
#
define
NS_FRAME_TRACE_NEW_FRAMES
0x8
#
define
NS_FRAME_LOG_TEST
(
_lm
_bit
)
(
int
(
(
(
mozilla
:
:
LogModule
*
)
_lm
)
-
>
Level
(
)
)
&
(
_bit
)
)
#
ifdef
DEBUG
#
define
NS_FRAME_LOG
(
_bit
_args
)
\
PR_BEGIN_MACRO
\
if
(
NS_FRAME_LOG_TEST
(
nsFrame
:
:
sFrameLogModule
_bit
)
)
{
\
printf_stderr
_args
;
\
}
\
PR_END_MACRO
#
else
#
define
NS_FRAME_LOG
(
_bit
_args
)
#
endif
#
ifdef
DEBUG
#
define
NS_FRAME_TRACE_IN
(
_method
)
Trace
(
_method
true
)
#
define
NS_FRAME_TRACE_OUT
(
_method
)
Trace
(
_method
false
)
#
define
NS_FRAME_TRACE_MSG
(
_bit
_args
)
\
PR_BEGIN_MACRO
\
if
(
NS_FRAME_LOG_TEST
(
nsFrame
:
:
sFrameLogModule
_bit
)
)
{
\
TraceMsg
_args
;
\
}
\
PR_END_MACRO
#
define
NS_FRAME_TRACE
(
_bit
_args
)
\
PR_BEGIN_MACRO
\
if
(
NS_FRAME_LOG_TEST
(
nsFrame
:
:
sFrameLogModule
_bit
)
)
{
\
TraceMsg
_args
;
\
}
\
PR_END_MACRO
#
define
NS_FRAME_TRACE_REFLOW_IN
(
_method
)
Trace
(
_method
true
)
#
define
NS_FRAME_TRACE_REFLOW_OUT
(
_method
_status
)
\
Trace
(
_method
false
_status
)
#
else
#
define
NS_FRAME_TRACE
(
_bits
_args
)
#
define
NS_FRAME_TRACE_IN
(
_method
)
#
define
NS_FRAME_TRACE_OUT
(
_method
)
#
define
NS_FRAME_TRACE_MSG
(
_bits
_args
)
#
define
NS_FRAME_TRACE_REFLOW_IN
(
_method
)
#
define
NS_FRAME_TRACE_REFLOW_OUT
(
_method
_status
)
#
endif
#
define
NS_DECL_FRAMEARENA_HELPERS
(
class
)
\
NS_DECL_QUERYFRAME_TARGET
(
class
)
\
static
constexpr
nsIFrame
:
:
ClassID
kClassID
=
nsIFrame
:
:
ClassID
:
:
class
#
#
_id
;
\
void
*
operator
new
(
size_t
nsIPresShell
*
)
MOZ_MUST_OVERRIDE
;
\
nsQueryFrame
:
:
FrameIID
GetFrameId
(
)
override
MOZ_MUST_OVERRIDE
{
\
return
nsQueryFrame
:
:
class
#
#
_id
;
\
}
#
define
NS_IMPL_FRAMEARENA_HELPERS
(
class
)
\
void
*
class
:
:
operator
new
(
size_t
sz
nsIPresShell
*
aShell
)
\
{
return
aShell
-
>
AllocateFrame
(
nsQueryFrame
:
:
class
#
#
_id
sz
)
;
}
\
#
define
NS_DECL_ABSTRACT_FRAME
(
class
)
\
void
*
operator
new
(
size_t
nsIPresShell
*
)
MOZ_MUST_OVERRIDE
=
delete
;
\
virtual
nsQueryFrame
:
:
FrameIID
GetFrameId
(
)
override
MOZ_MUST_OVERRIDE
=
0
;
struct
nsBoxLayoutMetrics
;
struct
nsRect
;
class
nsFrame
:
public
nsBox
{
public
:
friend
nsIFrame
*
NS_NewEmptyFrame
(
nsIPresShell
*
aShell
nsStyleContext
*
aContext
)
;
private
:
void
*
operator
new
(
size_t
sz
)
CPP_THROW_NEW
;
protected
:
void
operator
delete
(
void
*
aPtr
size_t
sz
)
;
public
:
NS_DECL_QUERYFRAME
NS_DECL_QUERYFRAME_TARGET
(
nsFrame
)
virtual
nsQueryFrame
:
:
FrameIID
GetFrameId
(
)
MOZ_MUST_OVERRIDE
{
return
kFrameIID
;
}
void
*
operator
new
(
size_t
nsIPresShell
*
)
MOZ_MUST_OVERRIDE
;
void
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
override
;
void
DestroyFrom
(
nsIFrame
*
aDestructRoot
)
override
;
nsStyleContext
*
GetAdditionalStyleContext
(
int32_t
aIndex
)
const
override
;
void
SetAdditionalStyleContext
(
int32_t
aIndex
nsStyleContext
*
aStyleContext
)
override
;
nscoord
GetLogicalBaseline
(
mozilla
:
:
WritingMode
aWritingMode
)
const
override
;
const
nsFrameList
&
GetChildList
(
ChildListID
aListID
)
const
override
;
void
GetChildLists
(
nsTArray
<
ChildList
>
*
aLists
)
const
override
;
nsresult
HandleEvent
(
nsPresContext
*
aPresContext
mozilla
:
:
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
override
;
nsresult
GetContentForEvent
(
mozilla
:
:
WidgetEvent
*
aEvent
nsIContent
*
*
aContent
)
override
;
nsresult
GetCursor
(
const
nsPoint
&
aPoint
nsIFrame
:
:
Cursor
&
aCursor
)
override
;
nsresult
GetPointFromOffset
(
int32_t
inOffset
nsPoint
*
outPoint
)
override
;
nsresult
GetCharacterRectsInRange
(
int32_t
aInOffset
int32_t
aLength
nsTArray
<
nsRect
>
&
aOutRect
)
override
;
nsresult
GetChildFrameContainingOffset
(
int32_t
inContentOffset
bool
inHint
int32_t
*
outFrameContentOffset
nsIFrame
*
*
outChildFrame
)
override
;
static
nsresult
GetNextPrevLineFromeBlockFrame
(
nsPresContext
*
aPresContext
nsPeekOffsetStruct
*
aPos
nsIFrame
*
aBlockFrame
int32_t
aLineStart
int8_t
aOutSideLimit
)
;
nsresult
CharacterDataChanged
(
CharacterDataChangeInfo
*
aInfo
)
override
;
nsresult
AttributeChanged
(
int32_t
aNameSpaceID
nsIAtom
*
aAttribute
int32_t
aModType
)
override
;
nsSplittableType
GetSplittableType
(
)
const
override
;
nsIFrame
*
GetPrevContinuation
(
)
const
override
;
void
SetPrevContinuation
(
nsIFrame
*
)
override
;
nsIFrame
*
GetNextContinuation
(
)
const
override
;
void
SetNextContinuation
(
nsIFrame
*
)
override
;
nsIFrame
*
GetPrevInFlowVirtual
(
)
const
override
;
void
SetPrevInFlow
(
nsIFrame
*
)
override
;
nsIFrame
*
GetNextInFlowVirtual
(
)
const
override
;
void
SetNextInFlow
(
nsIFrame
*
)
override
;
nsresult
GetSelectionController
(
nsPresContext
*
aPresContext
nsISelectionController
*
*
aSelCon
)
override
;
FrameSearchResult
PeekOffsetNoAmount
(
bool
aForward
int32_t
*
aOffset
)
override
;
FrameSearchResult
PeekOffsetCharacter
(
bool
aForward
int32_t
*
aOffset
PeekOffsetCharacterOptions
aOptions
=
PeekOffsetCharacterOptions
(
)
)
override
;
FrameSearchResult
PeekOffsetWord
(
bool
aForward
bool
aWordSelectEatSpace
bool
aIsKeyboardSelect
int32_t
*
aOffset
PeekWordState
*
aState
)
override
;
bool
BreakWordBetweenPunctuation
(
const
PeekWordState
*
aState
bool
aForward
bool
aPunctAfter
bool
aWhitespaceAfter
bool
aIsKeyboardSelect
)
;
nsresult
CheckVisibility
(
nsPresContext
*
aContext
int32_t
aStartIndex
int32_t
aEndIndex
bool
aRecurse
bool
*
aFinished
bool
*
_retval
)
override
;
nsresult
GetOffsets
(
int32_t
&
aStart
int32_t
&
aEnd
)
const
override
;
void
ChildIsDirty
(
nsIFrame
*
aChild
)
override
;
#
ifdef
ACCESSIBILITY
mozilla
:
:
a11y
:
:
AccType
AccessibleType
(
)
override
;
#
endif
nsStyleContext
*
GetParentStyleContext
(
nsIFrame
*
*
aProviderFrame
)
const
override
{
return
DoGetParentStyleContext
(
aProviderFrame
)
;
}
nsStyleContext
*
DoGetParentStyleContext
(
nsIFrame
*
*
aProviderFrame
)
const
;
bool
IsEmpty
(
)
override
;
bool
IsSelfEmpty
(
)
override
;
void
MarkIntrinsicISizesDirty
(
)
override
;
nscoord
GetMinISize
(
gfxContext
*
aRenderingContext
)
override
;
nscoord
GetPrefISize
(
gfxContext
*
aRenderingContext
)
override
;
void
AddInlineMinISize
(
gfxContext
*
aRenderingContext
InlineMinISizeData
*
aData
)
override
;
void
AddInlinePrefISize
(
gfxContext
*
aRenderingContext
InlinePrefISizeData
*
aData
)
override
;
IntrinsicISizeOffsetData
IntrinsicISizeOffsets
(
)
override
;
mozilla
:
:
IntrinsicSize
GetIntrinsicSize
(
)
override
;
nsSize
GetIntrinsicRatio
(
)
override
;
mozilla
:
:
LogicalSize
ComputeSize
(
gfxContext
*
aRenderingContext
mozilla
:
:
WritingMode
aWM
const
mozilla
:
:
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
mozilla
:
:
LogicalSize
&
aMargin
const
mozilla
:
:
LogicalSize
&
aBorder
const
mozilla
:
:
LogicalSize
&
aPadding
ComputeSizeFlags
aFlags
)
override
;
mozilla
:
:
LogicalSize
ComputeSizeWithIntrinsicDimensions
(
gfxContext
*
aRenderingContext
mozilla
:
:
WritingMode
aWM
const
mozilla
:
:
IntrinsicSize
&
aIntrinsicSize
nsSize
aIntrinsicRatio
const
mozilla
:
:
LogicalSize
&
aCBSize
const
mozilla
:
:
LogicalSize
&
aMargin
const
mozilla
:
:
LogicalSize
&
aBorder
const
mozilla
:
:
LogicalSize
&
aPadding
ComputeSizeFlags
aFlags
)
;
nsRect
ComputeSimpleTightBounds
(
mozilla
:
:
gfx
:
:
DrawTarget
*
aDrawTarget
)
const
;
virtual
mozilla
:
:
LogicalSize
ComputeAutoSize
(
gfxContext
*
aRenderingContext
mozilla
:
:
WritingMode
aWM
const
mozilla
:
:
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
mozilla
:
:
LogicalSize
&
aMargin
const
mozilla
:
:
LogicalSize
&
aBorder
const
mozilla
:
:
LogicalSize
&
aPadding
ComputeSizeFlags
aFlags
)
;
nscoord
ShrinkWidthToFit
(
gfxContext
*
aRenderingContext
nscoord
aISizeInCB
ComputeSizeFlags
aFlags
)
;
void
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
override
;
void
DidReflow
(
nsPresContext
*
aPresContext
const
ReflowInput
*
aReflowInput
nsDidReflowStatus
aStatus
)
override
;
void
ReflowAbsoluteFrames
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
bool
aConstrainBSize
=
true
)
;
void
FinishReflowWithAbsoluteFrames
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
bool
aConstrainBSize
=
true
)
;
void
PushDirtyBitToAbsoluteFrames
(
)
;
bool
CanContinueTextRun
(
)
const
override
;
bool
ComputeCustomOverflow
(
nsOverflowAreas
&
aOverflowAreas
)
override
;
void
UnionChildOverflow
(
nsOverflowAreas
&
aOverflowAreas
)
override
;
NS_IMETHOD
HandlePress
(
nsPresContext
*
aPresContext
mozilla
:
:
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
;
NS_IMETHOD
HandleMultiplePress
(
nsPresContext
*
aPresContext
mozilla
:
:
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
bool
aControlHeld
)
;
NS_IMETHOD
HandleDrag
(
nsPresContext
*
aPresContext
mozilla
:
:
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
;
NS_IMETHOD
HandleRelease
(
nsPresContext
*
aPresContext
mozilla
:
:
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
;
enum
{
SELECT_ACCUMULATE
=
0x01
}
;
nsresult
PeekBackwardAndForward
(
nsSelectionAmount
aAmountBack
nsSelectionAmount
aAmountForward
int32_t
aStartPos
bool
aJumpLines
uint32_t
aSelectFlags
)
;
nsresult
SelectByTypeAtPoint
(
nsPresContext
*
aPresContext
const
nsPoint
&
aPoint
nsSelectionAmount
aBeginAmountType
nsSelectionAmount
aEndAmountType
uint32_t
aSelectFlags
)
;
virtual
ContentOffsets
CalcContentOffsetsFromFramePoint
(
nsPoint
aPoint
)
;
nsSize
GetXULPrefSize
(
nsBoxLayoutState
&
aBoxLayoutState
)
override
;
nsSize
GetXULMinSize
(
nsBoxLayoutState
&
aBoxLayoutState
)
override
;
nsSize
GetXULMaxSize
(
nsBoxLayoutState
&
aBoxLayoutState
)
override
;
nscoord
GetXULFlex
(
)
override
;
nscoord
GetXULBoxAscent
(
nsBoxLayoutState
&
aBoxLayoutState
)
override
;
bool
ComputesOwnOverflowArea
(
)
override
{
return
true
;
}
bool
IsFrameTreeTooDeep
(
const
ReflowInput
&
aReflowInput
ReflowOutput
&
aMetrics
nsReflowStatus
&
aStatus
)
;
void
ConsiderChildOverflow
(
nsOverflowAreas
&
aOverflowAreas
nsIFrame
*
aChildFrame
)
;
bool
ShouldAvoidBreakInside
(
const
ReflowInput
&
aReflowInput
)
const
{
return
!
aReflowInput
.
mFlags
.
mIsTopOfPage
&
&
NS_STYLE_PAGE_BREAK_AVOID
=
=
StyleDisplay
(
)
-
>
mBreakInside
&
&
!
GetPrevInFlow
(
)
;
}
#
ifdef
DEBUG
void
Trace
(
const
char
*
aMethod
bool
aEnter
)
;
void
Trace
(
const
char
*
aMethod
bool
aEnter
const
nsReflowStatus
&
aStatus
)
;
void
TraceMsg
(
const
char
*
fmt
.
.
.
)
MOZ_FORMAT_PRINTF
(
2
3
)
;
static
void
VerifyDirtyBitSet
(
const
nsFrameList
&
aFrameList
)
;
static
void
XMLQuote
(
nsString
&
aString
)
;
virtual
void
DumpBaseRegressionData
(
nsPresContext
*
aPresContext
FILE
*
out
int32_t
aIndent
)
;
static
void
*
DisplayReflowEnter
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
const
ReflowInput
&
aReflowInput
)
;
static
void
*
DisplayLayoutEnter
(
nsIFrame
*
aFrame
)
;
static
void
*
DisplayIntrinsicISizeEnter
(
nsIFrame
*
aFrame
const
char
*
aType
)
;
static
void
*
DisplayIntrinsicSizeEnter
(
nsIFrame
*
aFrame
const
char
*
aType
)
;
static
void
DisplayReflowExit
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
ReflowOutput
&
aMetrics
const
nsReflowStatus
&
aStatus
void
*
aFrameTreeNode
)
;
static
void
DisplayLayoutExit
(
nsIFrame
*
aFrame
void
*
aFrameTreeNode
)
;
static
void
DisplayIntrinsicISizeExit
(
nsIFrame
*
aFrame
const
char
*
aType
nscoord
aResult
void
*
aFrameTreeNode
)
;
static
void
DisplayIntrinsicSizeExit
(
nsIFrame
*
aFrame
const
char
*
aType
nsSize
aResult
void
*
aFrameTreeNode
)
;
static
void
DisplayReflowStartup
(
)
;
static
void
DisplayReflowShutdown
(
)
;
#
endif
bool
DisplayBackgroundUnconditional
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
bool
aForceBackground
)
;
void
DisplayBorderBackgroundOutline
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
bool
aForceBackground
=
false
)
;
void
DisplayOutlineUnconditional
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
;
void
DisplayOutline
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
;
static
nsIFrame
*
CorrectStyleParentFrame
(
nsIFrame
*
aProspectiveParent
nsIAtom
*
aChildPseudo
)
;
protected
:
nsFrame
(
nsStyleContext
*
aContext
ClassID
aID
)
;
explicit
nsFrame
(
nsStyleContext
*
aContext
)
:
nsFrame
(
aContext
ClassID
:
:
nsFrame_id
)
{
}
virtual
~
nsFrame
(
)
;
void
DisplaySelectionOverlay
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
uint16_t
aContentType
=
nsISelectionDisplay
:
:
DISPLAY_FRAMES
)
;
int16_t
DisplaySelection
(
nsPresContext
*
aPresContext
bool
isOkToTurnOn
=
false
)
;
void
DidSetStyleContext
(
nsStyleContext
*
aOldStyleContext
)
override
;
public
:
void
CreateView
(
)
;
static
void
GetLastLeaf
(
nsPresContext
*
aPresContext
nsIFrame
*
*
aFrame
)
;
static
void
GetFirstLeaf
(
nsPresContext
*
aPresContext
nsIFrame
*
*
aFrame
)
;
static
int32_t
GetLineNumber
(
nsIFrame
*
aFrame
bool
aLockScroll
nsIFrame
*
*
aContainingBlock
=
nullptr
)
;
static
bool
ShouldApplyOverflowClipping
(
const
nsIFrame
*
aFrame
const
nsStyleDisplay
*
aDisp
)
{
if
(
MOZ_UNLIKELY
(
aDisp
-
>
mOverflowX
=
=
NS_STYLE_OVERFLOW_CLIP
&
&
!
aFrame
-
>
IsListControlFrame
(
)
)
)
{
return
true
;
}
if
(
aDisp
-
>
mOverflowX
=
=
NS_STYLE_OVERFLOW_HIDDEN
&
&
aDisp
-
>
mOverflowY
=
=
NS_STYLE_OVERFLOW_HIDDEN
)
{
mozilla
:
:
LayoutFrameType
type
=
aFrame
-
>
Type
(
)
;
if
(
type
=
=
mozilla
:
:
LayoutFrameType
:
:
Table
|
|
type
=
=
mozilla
:
:
LayoutFrameType
:
:
TableCell
|
|
type
=
=
mozilla
:
:
LayoutFrameType
:
:
BCTableCell
|
|
type
=
=
mozilla
:
:
LayoutFrameType
:
:
SVGOuterSVG
|
|
type
=
=
mozilla
:
:
LayoutFrameType
:
:
SVGInnerSVG
|
|
type
=
=
mozilla
:
:
LayoutFrameType
:
:
SVGSymbol
|
|
type
=
=
mozilla
:
:
LayoutFrameType
:
:
SVGForeignObject
)
{
return
true
;
}
if
(
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eReplacedContainsBlock
)
)
{
if
(
type
=
=
mozilla
:
:
LayoutFrameType
:
:
TextInput
)
{
return
false
;
}
return
true
;
}
}
if
(
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_SVG_LAYOUT
)
)
{
return
false
;
}
return
(
aFrame
-
>
GetStateBits
(
)
&
NS_BLOCK_CLIP_PAGINATED_OVERFLOW
)
!
=
0
&
&
aFrame
-
>
PresContext
(
)
-
>
IsPaginated
(
)
&
&
aFrame
-
>
IsBlockFrame
(
)
;
}
nsILineIterator
*
GetLineIterator
(
)
override
;
protected
:
NS_IMETHOD
GetDataForTableSelection
(
const
nsFrameSelection
*
aFrameSelection
nsIPresShell
*
aPresShell
mozilla
:
:
WidgetMouseEvent
*
aMouseEvent
nsIContent
*
*
aParentContent
int32_t
*
aContentOffset
int32_t
*
aTarget
)
;
static
void
FillCursorInformationFromStyle
(
const
nsStyleUserInterface
*
ui
nsIFrame
:
:
Cursor
&
aCursor
)
;
NS_IMETHOD
DoXULLayout
(
nsBoxLayoutState
&
aBoxLayoutState
)
override
;
#
ifdef
DEBUG_LAYOUT
void
GetBoxName
(
nsAutoString
&
aName
)
override
;
#
endif
nsBoxLayoutMetrics
*
BoxMetrics
(
)
const
;
void
FireDOMEvent
(
const
nsAString
&
aDOMEventName
nsIContent
*
aContent
=
nullptr
)
;
private
:
void
BoxReflow
(
nsBoxLayoutState
&
aState
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
gfxContext
*
aRenderingContext
nscoord
aX
nscoord
aY
nscoord
aWidth
nscoord
aHeight
bool
aMoveFrame
=
true
)
;
NS_IMETHODIMP
RefreshSizeCache
(
nsBoxLayoutState
&
aState
)
;
bool
HasCSSAnimations
(
)
;
bool
HasCSSTransitions
(
)
;
#
ifdef
DEBUG_FRAME_DUMP
public
:
nsresult
GetFrameName
(
nsAString
&
aResult
)
const
override
;
nsresult
MakeFrameName
(
const
nsAString
&
aKind
nsAString
&
aResult
)
const
;
static
int32_t
ContentIndexInContainer
(
const
nsIFrame
*
aFrame
)
;
#
endif
#
ifdef
DEBUG
public
:
nsFrameState
GetDebugStateBits
(
)
const
override
;
nsresult
DumpRegressionData
(
nsPresContext
*
aPresContext
FILE
*
out
int32_t
aIndent
)
override
;
static
bool
GetVerifyStyleTreeEnable
(
)
;
static
void
SetVerifyStyleTreeEnable
(
bool
aEnabled
)
;
static
mozilla
:
:
LazyLogModule
sFrameLogModule
;
static
void
ShowFrameBorders
(
bool
aEnable
)
;
static
bool
GetShowFrameBorders
(
)
;
static
void
ShowEventTargetFrameBorder
(
bool
aEnable
)
;
static
bool
GetShowEventTargetFrameBorder
(
)
;
#
endif
public
:
static
void
PrintDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayList
&
aList
bool
aDumpHtml
=
false
)
{
std
:
:
stringstream
ss
;
PrintDisplayList
(
aBuilder
aList
ss
aDumpHtml
)
;
fprintf_stderr
(
stderr
"
%
s
"
ss
.
str
(
)
.
c_str
(
)
)
;
}
static
void
PrintDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayList
&
aList
std
:
:
stringstream
&
aStream
bool
aDumpHtml
=
false
)
;
static
void
PrintDisplayListSet
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aList
std
:
:
stringstream
&
aStream
bool
aDumpHtml
=
false
)
;
}
;
#
ifdef
DEBUG
struct
DR_cookie
{
DR_cookie
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
const
mozilla
:
:
ReflowInput
&
aReflowInput
mozilla
:
:
ReflowOutput
&
aMetrics
nsReflowStatus
&
aStatus
)
;
~
DR_cookie
(
)
;
void
Change
(
)
const
;
nsPresContext
*
mPresContext
;
nsIFrame
*
mFrame
;
const
mozilla
:
:
ReflowInput
&
mReflowInput
;
mozilla
:
:
ReflowOutput
&
mMetrics
;
nsReflowStatus
&
mStatus
;
void
*
mValue
;
}
;
struct
DR_layout_cookie
{
explicit
DR_layout_cookie
(
nsIFrame
*
aFrame
)
;
~
DR_layout_cookie
(
)
;
nsIFrame
*
mFrame
;
void
*
mValue
;
}
;
struct
DR_intrinsic_width_cookie
{
DR_intrinsic_width_cookie
(
nsIFrame
*
aFrame
const
char
*
aType
nscoord
&
aResult
)
;
~
DR_intrinsic_width_cookie
(
)
;
nsIFrame
*
mFrame
;
const
char
*
mType
;
nscoord
&
mResult
;
void
*
mValue
;
}
;
struct
DR_intrinsic_size_cookie
{
DR_intrinsic_size_cookie
(
nsIFrame
*
aFrame
const
char
*
aType
nsSize
&
aResult
)
;
~
DR_intrinsic_size_cookie
(
)
;
nsIFrame
*
mFrame
;
const
char
*
mType
;
nsSize
&
mResult
;
void
*
mValue
;
}
;
struct
DR_init_constraints_cookie
{
DR_init_constraints_cookie
(
nsIFrame
*
aFrame
mozilla
:
:
ReflowInput
*
aState
nscoord
aCBWidth
nscoord
aCBHeight
const
nsMargin
*
aBorder
const
nsMargin
*
aPadding
)
;
~
DR_init_constraints_cookie
(
)
;
nsIFrame
*
mFrame
;
mozilla
:
:
ReflowInput
*
mState
;
void
*
mValue
;
}
;
struct
DR_init_offsets_cookie
{
DR_init_offsets_cookie
(
nsIFrame
*
aFrame
mozilla
:
:
SizeComputationInput
*
aState
const
mozilla
:
:
LogicalSize
&
aPercentBasis
mozilla
:
:
WritingMode
aCBWritingMode
const
nsMargin
*
aBorder
const
nsMargin
*
aPadding
)
;
~
DR_init_offsets_cookie
(
)
;
nsIFrame
*
mFrame
;
mozilla
:
:
SizeComputationInput
*
mState
;
void
*
mValue
;
}
;
struct
DR_init_type_cookie
{
DR_init_type_cookie
(
nsIFrame
*
aFrame
mozilla
:
:
ReflowInput
*
aState
)
;
~
DR_init_type_cookie
(
)
;
nsIFrame
*
mFrame
;
mozilla
:
:
ReflowInput
*
mState
;
void
*
mValue
;
}
;
#
define
DISPLAY_REFLOW
(
dr_pres_context
dr_frame
dr_rf_state
dr_rf_metrics
dr_rf_status
)
\
DR_cookie
dr_cookie
(
dr_pres_context
dr_frame
dr_rf_state
dr_rf_metrics
dr_rf_status
)
;
#
define
DISPLAY_REFLOW_CHANGE
(
)
\
dr_cookie
.
Change
(
)
;
#
define
DISPLAY_LAYOUT
(
dr_frame
)
\
DR_layout_cookie
dr_cookie
(
dr_frame
)
;
#
define
DISPLAY_MIN_WIDTH
(
dr_frame
dr_result
)
\
DR_intrinsic_width_cookie
dr_cookie
(
dr_frame
"
Min
"
dr_result
)
#
define
DISPLAY_PREF_WIDTH
(
dr_frame
dr_result
)
\
DR_intrinsic_width_cookie
dr_cookie
(
dr_frame
"
Pref
"
dr_result
)
#
define
DISPLAY_PREF_SIZE
(
dr_frame
dr_result
)
\
DR_intrinsic_size_cookie
dr_cookie
(
dr_frame
"
Pref
"
dr_result
)
#
define
DISPLAY_MIN_SIZE
(
dr_frame
dr_result
)
\
DR_intrinsic_size_cookie
dr_cookie
(
dr_frame
"
Min
"
dr_result
)
#
define
DISPLAY_MAX_SIZE
(
dr_frame
dr_result
)
\
DR_intrinsic_size_cookie
dr_cookie
(
dr_frame
"
Max
"
dr_result
)
#
define
DISPLAY_INIT_CONSTRAINTS
(
dr_frame
dr_state
dr_cbw
dr_cbh
\
dr_bdr
dr_pad
)
\
DR_init_constraints_cookie
dr_cookie
(
dr_frame
dr_state
dr_cbw
dr_cbh
\
dr_bdr
dr_pad
)
#
define
DISPLAY_INIT_OFFSETS
(
dr_frame
dr_state
dr_pb
dr_cbwm
dr_bdr
\
dr_pad
)
\
DR_init_offsets_cookie
dr_cookie
(
dr_frame
dr_state
dr_pb
dr_cbwm
\
dr_bdr
dr_pad
)
#
define
DISPLAY_INIT_TYPE
(
dr_frame
dr_result
)
\
DR_init_type_cookie
dr_cookie
(
dr_frame
dr_result
)
#
else
#
define
DISPLAY_REFLOW
(
dr_pres_context
dr_frame
dr_rf_state
dr_rf_metrics
dr_rf_status
)
#
define
DISPLAY_REFLOW_CHANGE
(
)
#
define
DISPLAY_LAYOUT
(
dr_frame
)
PR_BEGIN_MACRO
PR_END_MACRO
#
define
DISPLAY_MIN_WIDTH
(
dr_frame
dr_result
)
PR_BEGIN_MACRO
PR_END_MACRO
#
define
DISPLAY_PREF_WIDTH
(
dr_frame
dr_result
)
PR_BEGIN_MACRO
PR_END_MACRO
#
define
DISPLAY_PREF_SIZE
(
dr_frame
dr_result
)
PR_BEGIN_MACRO
PR_END_MACRO
#
define
DISPLAY_MIN_SIZE
(
dr_frame
dr_result
)
PR_BEGIN_MACRO
PR_END_MACRO
#
define
DISPLAY_MAX_SIZE
(
dr_frame
dr_result
)
PR_BEGIN_MACRO
PR_END_MACRO
#
define
DISPLAY_INIT_CONSTRAINTS
(
dr_frame
dr_state
dr_cbw
dr_cbh
\
dr_bdr
dr_pad
)
\
PR_BEGIN_MACRO
PR_END_MACRO
#
define
DISPLAY_INIT_OFFSETS
(
dr_frame
dr_state
dr_pb
dr_cbwm
dr_bdr
\
dr_pad
)
\
PR_BEGIN_MACRO
PR_END_MACRO
#
define
DISPLAY_INIT_TYPE
(
dr_frame
dr_result
)
PR_BEGIN_MACRO
PR_END_MACRO
#
endif
#
define
ENSURE_TRUE
(
x
)
\
PR_BEGIN_MACRO
\
if
(
!
(
x
)
)
{
\
NS_WARNING
(
"
ENSURE_TRUE
(
"
#
x
"
)
failed
"
)
;
\
return
;
\
}
\
PR_END_MACRO
#
endif
