#
ifndef
mozilla_AspectRatio_h
#
define
mozilla_AspectRatio_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
gfx
/
BaseSize
.
h
"
#
include
"
nsCoord
.
h
"
#
include
<
algorithm
>
#
include
<
limits
>
namespace
IPC
{
template
<
typename
T
>
struct
ParamTraits
;
}
namespace
mozilla
{
enum
LogicalAxis
:
uint8_t
;
class
LogicalSize
;
class
WritingMode
;
enum
class
UseBoxSizing
:
uint8_t
{
No
Yes
}
;
struct
AspectRatio
{
friend
struct
IPC
:
:
ParamTraits
<
mozilla
:
:
AspectRatio
>
;
AspectRatio
(
)
=
default
;
explicit
AspectRatio
(
float
aRatio
UseBoxSizing
aUseBoxSizing
=
UseBoxSizing
:
:
No
)
:
mRatio
(
std
:
:
max
(
aRatio
0
.
0f
)
)
mUseBoxSizing
(
aUseBoxSizing
)
{
}
static
AspectRatio
FromSize
(
float
aWidth
float
aHeight
UseBoxSizing
aUseBoxSizing
=
UseBoxSizing
:
:
No
)
{
if
(
aWidth
=
=
0
.
0f
|
|
aHeight
=
=
0
.
0f
)
{
return
AspectRatio
(
)
;
}
return
AspectRatio
(
aWidth
/
aHeight
aUseBoxSizing
)
;
}
template
<
typename
T
typename
Sub
>
static
AspectRatio
FromSize
(
const
gfx
:
:
BaseSize
<
T
Sub
>
&
aSize
)
{
return
FromSize
(
aSize
.
Width
(
)
aSize
.
Height
(
)
)
;
}
explicit
operator
bool
(
)
const
{
return
mRatio
!
=
0
.
0f
;
}
nscoord
ApplyTo
(
nscoord
aCoord
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
*
this
)
;
return
NSCoordSaturatingNonnegativeMultiply
(
aCoord
mRatio
)
;
}
float
ApplyToFloat
(
float
aFloat
)
const
{
MOZ_DIAGNOSTIC_ASSERT
(
*
this
)
;
return
mRatio
*
aFloat
;
}
[
[
nodiscard
]
]
AspectRatio
Inverted
(
)
const
{
if
(
!
*
this
)
{
return
AspectRatio
(
)
;
}
return
AspectRatio
(
std
:
:
max
(
std
:
:
numeric_limits
<
float
>
:
:
epsilon
(
)
1
.
0f
/
mRatio
)
mUseBoxSizing
)
;
}
[
[
nodiscard
]
]
inline
AspectRatio
ConvertToWritingMode
(
const
WritingMode
&
aWM
)
const
;
[
[
nodiscard
]
]
nscoord
ComputeRatioDependentSize
(
LogicalAxis
aRatioDependentAxis
const
WritingMode
&
aWM
nscoord
aRatioDeterminingSize
const
LogicalSize
&
aContentBoxSizeToBoxSizingAdjust
)
const
;
bool
operator
=
=
(
const
AspectRatio
&
aOther
)
const
{
return
mRatio
=
=
aOther
.
mRatio
&
&
mUseBoxSizing
=
=
aOther
.
mUseBoxSizing
;
}
bool
operator
!
=
(
const
AspectRatio
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
bool
operator
<
(
const
AspectRatio
&
aOther
)
const
{
MOZ_ASSERT
(
mUseBoxSizing
=
=
aOther
.
mUseBoxSizing
"
Do
not
compare
AspectRatio
if
their
mUseBoxSizing
are
different
.
"
)
;
return
mRatio
<
aOther
.
mRatio
;
}
private
:
float
mRatio
=
0
.
0f
;
UseBoxSizing
mUseBoxSizing
=
UseBoxSizing
:
:
No
;
}
;
}
#
endif
