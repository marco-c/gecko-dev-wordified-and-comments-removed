#
ifndef
BlockReflowState_h
#
define
BlockReflowState_h
#
include
<
tuple
>
#
include
"
mozilla
/
ReflowInput
.
h
"
#
include
"
nsFloatManager
.
h
"
#
include
"
nsLineBox
.
h
"
class
nsBlockFrame
;
class
nsFrameList
;
class
nsOverflowContinuationTracker
;
namespace
mozilla
{
class
BlockReflowState
{
using
BandInfoType
=
nsFloatManager
:
:
BandInfoType
;
using
ShapeType
=
nsFloatManager
:
:
ShapeType
;
struct
Flags
{
Flags
(
)
:
mIsBStartMarginRoot
(
false
)
mIsBEndMarginRoot
(
false
)
mShouldApplyBStartMargin
(
false
)
mHasLineAdjacentToTop
(
false
)
mBlockNeedsFloatManager
(
false
)
mIsLineLayoutEmpty
(
false
)
mIsFloatListInBlockPropertyTable
(
false
)
mCanHaveOverflowMarkers
(
false
)
{
}
bool
mIsBStartMarginRoot
:
1
;
bool
mIsBEndMarginRoot
:
1
;
bool
mShouldApplyBStartMargin
:
1
;
bool
mHasLineAdjacentToTop
:
1
;
bool
mBlockNeedsFloatManager
:
1
;
bool
mIsLineLayoutEmpty
:
1
;
bool
mIsFloatListInBlockPropertyTable
:
1
;
bool
mCanHaveOverflowMarkers
:
1
;
}
;
public
:
BlockReflowState
(
const
ReflowInput
&
aReflowInput
nsPresContext
*
aPresContext
nsBlockFrame
*
aFrame
bool
aBStartMarginRoot
bool
aBEndMarginRoot
bool
aBlockNeedsFloatManager
const
nscoord
aConsumedBSize
const
nscoord
aEffectiveContentBoxBSize
)
;
nsFlowAreaRect
GetFloatAvailableSpace
(
)
const
{
return
GetFloatAvailableSpace
(
mBCoord
)
;
}
nsFlowAreaRect
GetFloatAvailableSpaceForPlacingFloat
(
nscoord
aBCoord
)
const
{
return
GetFloatAvailableSpaceWithState
(
aBCoord
ShapeType
:
:
Margin
nullptr
)
;
}
nsFlowAreaRect
GetFloatAvailableSpace
(
nscoord
aBCoord
)
const
{
return
GetFloatAvailableSpaceWithState
(
aBCoord
ShapeType
:
:
ShapeOutside
nullptr
)
;
}
nsFlowAreaRect
GetFloatAvailableSpaceWithState
(
nscoord
aBCoord
ShapeType
aShapeType
nsFloatManager
:
:
SavedState
*
aState
)
const
;
nsFlowAreaRect
GetFloatAvailableSpaceForBSize
(
nscoord
aBCoord
nscoord
aBSize
nsFloatManager
:
:
SavedState
*
aState
)
const
;
bool
AddFloat
(
nsLineLayout
*
aLineLayout
nsIFrame
*
aFloat
nscoord
aAvailableISize
)
;
bool
FlowAndPlaceFloat
(
nsIFrame
*
aFloat
)
;
void
PlaceBelowCurrentLineFloats
(
nsLineBox
*
aLine
)
;
enum
class
ClearFloatsResult
:
uint8_t
{
BCoordNoChange
BCoordAdvanced
FloatsPushedOrSplit
}
;
std
:
:
tuple
<
nscoord
ClearFloatsResult
>
ClearFloats
(
nscoord
aBCoord
StyleClear
aBreakType
nsIFrame
*
aFloatAvoidingBlock
=
nullptr
)
;
nsFloatManager
*
FloatManager
(
)
const
{
MOZ_ASSERT
(
mReflowInput
.
mFloatManager
"
Float
manager
should
be
valid
during
the
lifetime
of
"
"
BlockReflowState
!
"
)
;
return
mReflowInput
.
mFloatManager
;
}
bool
AdvanceToNextBand
(
const
LogicalRect
&
aFloatAvailableSpace
nscoord
*
aBCoord
)
const
{
WritingMode
wm
=
mReflowInput
.
GetWritingMode
(
)
;
if
(
aFloatAvailableSpace
.
BSize
(
wm
)
>
0
)
{
*
aBCoord
+
=
aFloatAvailableSpace
.
BSize
(
wm
)
;
}
else
{
if
(
mReflowInput
.
AvailableHeight
(
)
!
=
NS_UNCONSTRAINEDSIZE
)
{
return
false
;
}
MOZ_ASSERT_UNREACHABLE
(
"
avail
space
rect
with
zero
height
!
"
)
;
*
aBCoord
+
=
1
;
}
return
true
;
}
bool
FloatAvoidingBlockFitsInAvailSpace
(
nsIFrame
*
aFloatAvoidingBlock
const
nsFlowAreaRect
&
aFloatAvailableSpace
)
const
;
bool
IsAdjacentWithBStart
(
)
const
{
return
mBCoord
=
=
ContentBStart
(
)
;
}
const
LogicalMargin
&
BorderPadding
(
)
const
{
return
mBorderPadding
;
}
void
ReconstructMarginBefore
(
nsLineList
:
:
iterator
aLine
)
;
void
ComputeFloatAvoidingOffsets
(
nsIFrame
*
aFloatAvoidingBlock
const
LogicalRect
&
aFloatAvailableSpace
nscoord
&
aIStartResult
nscoord
&
aIEndResult
)
const
;
LogicalRect
ComputeBlockAvailSpace
(
nsIFrame
*
aFrame
const
nsFlowAreaRect
&
aFloatAvailableSpace
bool
aBlockAvoidsFloats
)
;
void
RecoverStateFrom
(
nsLineList
:
:
iterator
aLine
nscoord
aDeltaBCoord
)
;
void
AdvanceToNextLine
(
)
{
if
(
mFlags
.
mIsLineLayoutEmpty
)
{
mFlags
.
mIsLineLayoutEmpty
=
false
;
}
else
{
mLineNumber
+
+
;
}
}
nsBlockFrame
*
mBlock
;
nsPresContext
*
mPresContext
;
const
ReflowInput
&
mReflowInput
;
nscoord
mFloatManagerI
mFloatManagerB
;
nsReflowStatus
mReflowStatus
;
nsFloatManager
:
:
SavedState
mFloatManagerStateBefore
;
LogicalRect
mContentArea
;
nscoord
ContentIStart
(
)
const
{
return
mContentArea
.
IStart
(
mReflowInput
.
GetWritingMode
(
)
)
;
}
nscoord
ContentISize
(
)
const
{
return
mContentArea
.
ISize
(
mReflowInput
.
GetWritingMode
(
)
)
;
}
nscoord
ContentIEnd
(
)
const
{
return
mContentArea
.
IEnd
(
mReflowInput
.
GetWritingMode
(
)
)
;
}
nscoord
ContentBStart
(
)
const
{
return
mContentArea
.
BStart
(
mReflowInput
.
GetWritingMode
(
)
)
;
}
nscoord
ContentBSize
(
)
const
{
return
mContentArea
.
BSize
(
mReflowInput
.
GetWritingMode
(
)
)
;
}
nscoord
ContentBEnd
(
)
const
{
NS_ASSERTION
(
ContentBSize
(
)
!
=
NS_UNCONSTRAINEDSIZE
"
ContentBSize
(
)
is
unconstrained
so
ContentBEnd
(
)
may
overflow
.
"
)
;
return
mContentArea
.
BEnd
(
mReflowInput
.
GetWritingMode
(
)
)
;
}
LogicalSize
ContentSize
(
WritingMode
aWM
)
const
{
WritingMode
wm
=
mReflowInput
.
GetWritingMode
(
)
;
return
mContentArea
.
Size
(
wm
)
.
ConvertTo
(
aWM
wm
)
;
}
nsSize
mContainerSize
;
const
nsSize
&
ContainerSize
(
)
const
{
return
mContainerSize
;
}
nsFrameList
*
mPushedFloats
;
void
SetupPushedFloatList
(
)
;
void
AppendPushedFloatChain
(
nsIFrame
*
aFloatCont
)
;
nsOverflowContinuationTracker
*
mOverflowTracker
;
nsLineList
:
:
iterator
mCurrentLine
;
nsLineList
:
:
iterator
mLineAdjacentToTop
;
nscoord
mBCoord
;
LogicalMargin
mBorderPadding
;
OverflowAreas
mFloatOverflowAreas
;
nsFloatCacheFreeList
mFloatCacheFreeList
;
nsIFrame
*
mPrevChild
;
nsCollapsingMargin
mPrevBEndMargin
;
nsBlockFrame
*
mNextInFlow
;
nsFloatCacheFreeList
mCurrentLineFloats
;
nsFloatCacheFreeList
mBelowCurrentLineFloats
;
nsTArray
<
nsIFrame
*
>
mNoWrapFloats
;
nscoord
mMinLineHeight
;
int32_t
mLineNumber
;
Flags
mFlags
;
StyleClear
mFloatBreakType
;
const
nscoord
mConsumedBSize
;
Maybe
<
nscoord
>
mLineBSize
;
private
:
bool
CanPlaceFloat
(
nscoord
aFloatISize
const
nsFlowAreaRect
&
aFloatAvailableSpace
)
;
void
PushFloatPastBreak
(
nsIFrame
*
aFloat
)
;
void
RecoverFloats
(
nsLineList
:
:
iterator
aLine
nscoord
aDeltaBCoord
)
;
}
;
}
;
#
endif
