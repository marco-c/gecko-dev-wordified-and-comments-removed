#
include
"
nsPageSequenceFrame
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
PrintedSheetFrame
.
h
"
#
include
"
mozilla
/
dom
/
HTMLCanvasElement
.
h
"
#
include
"
mozilla
/
StaticPresData
.
h
"
#
include
"
DateTimeFormat
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDeviceContext
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsIPrintSettings
.
h
"
#
include
"
nsPageFrame
.
h
"
#
include
"
nsSubDocumentFrame
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsHTMLCanvasFrame
.
h
"
#
include
"
nsICanvasRenderingContextInternal
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
<
algorithm
>
#
include
<
limits
>
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
mozilla
:
:
LazyLogModule
gLayoutPrintingLog
(
"
printing
-
layout
"
)
;
#
define
PR_PL
(
_p1
)
MOZ_LOG
(
gLayoutPrintingLog
mozilla
:
:
LogLevel
:
:
Debug
_p1
)
nsPageSequenceFrame
*
NS_NewPageSequenceFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsPageSequenceFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsPageSequenceFrame
)
static
const
nsPagesPerSheetInfo
kSupportedPagesPerSheet
[
]
=
{
{
1
1
}
{
4
2
}
{
9
3
}
{
16
4
}
}
;
inline
void
SanityCheckPagesPerSheetInfo
(
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
ArrayLength
(
kSupportedPagesPerSheet
)
>
0
"
Should
have
at
least
one
pages
-
per
-
sheet
option
.
"
)
;
MOZ_ASSERT
(
kSupportedPagesPerSheet
[
0
]
.
mNumPages
=
=
1
"
The
0th
index
is
reserved
for
default
1
-
page
-
per
-
sheet
entry
"
)
;
uint16_t
prevInfoPPS
=
0
;
for
(
const
auto
&
info
:
kSupportedPagesPerSheet
)
{
MOZ_ASSERT
(
info
.
mNumPages
>
prevInfoPPS
"
page
count
field
should
be
positive
&
monotonically
increase
"
)
;
MOZ_ASSERT
(
info
.
mLargerNumTracks
>
0
"
page
grid
has
to
have
a
positive
number
of
tracks
"
)
;
MOZ_ASSERT
(
info
.
mNumPages
%
info
.
mLargerNumTracks
=
=
0
"
page
count
field
should
be
evenly
divisible
by
"
"
the
given
track
-
count
"
)
;
prevInfoPPS
=
info
.
mNumPages
;
}
#
endif
}
const
nsPagesPerSheetInfo
&
nsPagesPerSheetInfo
:
:
LookupInfo
(
int32_t
aPPS
)
{
SanityCheckPagesPerSheetInfo
(
)
;
for
(
const
auto
&
info
:
kSupportedPagesPerSheet
)
{
if
(
aPPS
=
=
info
.
mNumPages
)
{
return
info
;
}
}
NS_WARNING
(
"
Unsupported
pages
-
per
-
sheet
value
"
)
;
return
kSupportedPagesPerSheet
[
0
]
;
}
const
nsPagesPerSheetInfo
*
nsSharedPageData
:
:
PagesPerSheetInfo
(
)
{
if
(
mPagesPerSheetInfo
)
{
return
mPagesPerSheetInfo
;
}
int32_t
pagesPerSheet
;
if
(
!
mPrintSettings
|
|
NS_FAILED
(
mPrintSettings
-
>
GetNumPagesPerSheet
(
&
pagesPerSheet
)
)
)
{
pagesPerSheet
=
1
;
}
mPagesPerSheetInfo
=
&
nsPagesPerSheetInfo
:
:
LookupInfo
(
pagesPerSheet
)
;
return
mPagesPerSheetInfo
;
}
nsPageSequenceFrame
:
:
nsPageSequenceFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
:
nsContainerFrame
(
aStyle
aPresContext
kClassID
)
mMaxSheetSize
(
mWritingMode
)
mScrollportSize
(
mWritingMode
)
mCalledBeginPage
(
false
)
mCurrentCanvasListSetup
(
false
)
{
mPageData
=
MakeUnique
<
nsSharedPageData
>
(
)
;
mPageData
-
>
mHeadFootFont
=
*
PresContext
(
)
-
>
Document
(
)
-
>
GetFontPrefsForLang
(
aStyle
-
>
StyleFont
(
)
-
>
mLanguage
)
-
>
GetDefaultFont
(
StyleGenericFontFamily
:
:
Serif
)
;
mPageData
-
>
mHeadFootFont
.
size
=
Length
:
:
FromPixels
(
CSSPixel
:
:
FromPoints
(
10
.
0f
)
)
;
mPageData
-
>
mPrintSettings
=
aPresContext
-
>
GetPrintSettings
(
)
;
MOZ_RELEASE_ASSERT
(
mPageData
-
>
mPrintSettings
"
How
?
"
)
;
SetPageNumberFormat
(
"
pagenumber
"
"
%
1
d
"
true
)
;
SetPageNumberFormat
(
"
pageofpages
"
"
%
1
d
of
%
2
d
"
false
)
;
}
nsPageSequenceFrame
:
:
~
nsPageSequenceFrame
(
)
{
ResetPrintCanvasList
(
)
;
}
NS_QUERYFRAME_HEAD
(
nsPageSequenceFrame
)
NS_QUERYFRAME_ENTRY
(
nsPageSequenceFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsContainerFrame
)
float
nsPageSequenceFrame
:
:
GetPrintPreviewScale
(
)
const
{
nsPresContext
*
pc
=
PresContext
(
)
;
float
scale
=
pc
-
>
GetPrintPreviewScaleForSequenceFrame
(
)
;
WritingMode
wm
=
GetWritingMode
(
)
;
if
(
pc
-
>
IsScreen
(
)
&
&
MOZ_LIKELY
(
mScrollportSize
.
ISize
(
wm
)
>
0
&
&
mScrollportSize
.
BSize
(
wm
)
>
0
)
)
{
nscoord
scaledISize
=
NSToCoordCeil
(
mMaxSheetSize
.
ISize
(
wm
)
*
scale
)
;
if
(
scaledISize
>
mScrollportSize
.
ISize
(
wm
)
)
{
scale
*
=
float
(
mScrollportSize
.
ISize
(
wm
)
)
/
float
(
scaledISize
)
;
}
if
(
MOZ_LIKELY
(
mScrollportSize
.
BSize
(
wm
)
!
=
NS_UNCONSTRAINEDSIZE
)
)
{
nscoord
scaledBSize
=
NSToCoordCeil
(
mMaxSheetSize
.
BSize
(
wm
)
*
scale
)
;
if
(
scaledBSize
>
mScrollportSize
.
BSize
(
wm
)
)
{
scale
*
=
float
(
mScrollportSize
.
BSize
(
wm
)
)
/
float
(
scaledBSize
)
;
}
}
}
return
scale
;
}
void
nsPageSequenceFrame
:
:
PopulateReflowOutput
(
ReflowOutput
&
aReflowOutput
const
ReflowInput
&
aReflowInput
)
{
float
scale
=
GetPrintPreviewScale
(
)
;
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
nscoord
iSize
=
wm
.
IsVertical
(
)
?
mSize
.
Height
(
)
:
mSize
.
Width
(
)
;
nscoord
bSize
=
wm
.
IsVertical
(
)
?
mSize
.
Width
(
)
:
mSize
.
Height
(
)
;
aReflowOutput
.
ISize
(
wm
)
=
std
:
:
max
(
NSToCoordFloor
(
iSize
*
scale
)
aReflowInput
.
AvailableISize
(
)
)
;
aReflowOutput
.
BSize
(
wm
)
=
std
:
:
max
(
NSToCoordFloor
(
bSize
*
scale
)
aReflowInput
.
ComputedBSize
(
)
)
;
aReflowOutput
.
SetOverflowAreasToDesiredBounds
(
)
;
}
nscoord
nsPageSequenceFrame
:
:
ComputeCenteringMargin
(
nscoord
aContainerContentBoxWidth
nscoord
aChildPaddingBoxWidth
const
nsMargin
&
aChildPhysicalMargin
)
{
nscoord
childMarginBoxWidth
=
aChildPaddingBoxWidth
+
aChildPhysicalMargin
.
LeftRight
(
)
;
float
scale
=
GetPrintPreviewScale
(
)
;
nscoord
scaledChildMarginBoxWidth
=
NSToCoordRound
(
childMarginBoxWidth
*
scale
)
;
nscoord
scaledExtraSpace
=
aContainerContentBoxWidth
-
scaledChildMarginBoxWidth
;
if
(
scaledExtraSpace
<
=
0
)
{
return
0
;
}
return
NSToCoordRound
(
scaledExtraSpace
*
0
.
5
/
scale
)
;
}
uint32_t
nsPageSequenceFrame
:
:
GetPagesInFirstSheet
(
)
const
{
nsIFrame
*
firstSheet
=
mFrames
.
FirstChild
(
)
;
if
(
!
firstSheet
)
{
return
0
;
}
MOZ_DIAGNOSTIC_ASSERT
(
firstSheet
-
>
IsPrintedSheetFrame
(
)
)
;
return
static_cast
<
PrintedSheetFrame
*
>
(
firstSheet
)
-
>
GetNumPages
(
)
;
}
void
nsPageSequenceFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aReflowOutput
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
MOZ_ASSERT
(
aPresContext
-
>
IsRootPaginatedDocument
(
)
"
A
Page
Sequence
is
only
for
real
pages
"
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsPageSequenceFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aReflowOutput
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
NS_FRAME_TRACE_REFLOW_IN
(
"
nsPageSequenceFrame
:
:
Reflow
"
)
;
auto
CenterPages
=
[
&
]
{
for
(
nsIFrame
*
child
:
mFrames
)
{
nsMargin
pageCSSMargin
=
child
-
>
GetUsedMargin
(
)
;
nscoord
centeringMargin
=
ComputeCenteringMargin
(
aReflowInput
.
ComputedWidth
(
)
child
-
>
GetRect
(
)
.
Width
(
)
pageCSSMargin
)
;
nscoord
newX
=
pageCSSMargin
.
left
+
centeringMargin
;
child
-
>
MovePositionBy
(
nsPoint
(
newX
-
child
-
>
GetNormalPosition
(
)
.
x
0
)
)
;
}
}
;
if
(
aPresContext
-
>
IsScreen
(
)
)
{
mScrollportSize
=
aReflowInput
.
ComputedSize
(
)
;
}
if
(
!
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
)
{
PopulateReflowOutput
(
aReflowOutput
aReflowInput
)
;
FinishAndStoreOverflow
(
&
aReflowOutput
)
;
if
(
GetSize
(
)
!
=
aReflowOutput
.
PhysicalSize
(
)
)
{
CenterPages
(
)
;
}
return
;
}
nsIntMargin
unwriteableTwips
=
mPageData
-
>
mPrintSettings
-
>
GetUnwriteableMarginInTwips
(
)
;
nsIntMargin
edgeTwips
=
mPageData
-
>
mPrintSettings
-
>
GetEdgeInTwips
(
)
;
int32_t
threeInches
=
NS_INCHES_TO_INT_TWIPS
(
3
.
0
)
;
edgeTwips
.
EnsureAtMost
(
nsIntMargin
(
threeInches
threeInches
threeInches
threeInches
)
)
;
edgeTwips
.
EnsureAtLeast
(
unwriteableTwips
)
;
mPageData
-
>
mEdgePaperMargin
=
nsPresContext
:
:
CSSTwipsToAppUnits
(
edgeTwips
)
;
mPageData
-
>
mPrintSettings
-
>
GetPageRanges
(
mPageData
-
>
mPageRanges
)
;
nscoord
y
=
0
;
nscoord
maxInflatedSheetWidth
=
0
;
nscoord
maxInflatedSheetHeight
=
0
;
for
(
nsIFrame
*
kidFrame
:
mFrames
)
{
MOZ_ASSERT
(
kidFrame
-
>
IsPrintedSheetFrame
(
)
"
we
'
re
only
expecting
PrintedSheetFrame
as
children
"
)
;
auto
*
sheet
=
static_cast
<
PrintedSheetFrame
*
>
(
kidFrame
)
;
sheet
-
>
SetSharedPageData
(
mPageData
.
get
(
)
)
;
ReflowInput
kidReflowInput
(
aPresContext
aReflowInput
kidFrame
LogicalSize
(
kidFrame
-
>
GetWritingMode
(
)
aPresContext
-
>
GetPageSize
(
)
)
)
;
ReflowOutput
kidReflowOutput
(
kidReflowInput
)
;
nsReflowStatus
status
;
kidReflowInput
.
SetComputedISize
(
kidReflowInput
.
AvailableISize
(
)
)
;
PR_PL
(
(
"
AV
ISize
:
%
d
BSize
:
%
d
\
n
"
kidReflowInput
.
AvailableISize
(
)
kidReflowInput
.
AvailableBSize
(
)
)
)
;
nsMargin
pageCSSMargin
=
kidReflowInput
.
ComputedPhysicalMargin
(
)
;
y
+
=
pageCSSMargin
.
top
;
nscoord
x
=
pageCSSMargin
.
left
;
ReflowChild
(
kidFrame
aPresContext
kidReflowOutput
kidReflowInput
x
y
ReflowChildFlags
:
:
Default
status
)
;
FinishReflowChild
(
kidFrame
aPresContext
kidReflowOutput
&
kidReflowInput
x
y
ReflowChildFlags
:
:
Default
)
;
y
+
=
kidReflowOutput
.
Height
(
)
;
y
+
=
pageCSSMargin
.
bottom
;
maxInflatedSheetWidth
=
std
:
:
max
(
maxInflatedSheetWidth
kidReflowOutput
.
Width
(
)
+
pageCSSMargin
.
LeftRight
(
)
)
;
maxInflatedSheetHeight
=
std
:
:
max
(
maxInflatedSheetHeight
kidReflowOutput
.
Height
(
)
+
pageCSSMargin
.
TopBottom
(
)
)
;
nsIFrame
*
kidNextInFlow
=
kidFrame
-
>
GetNextInFlow
(
)
;
if
(
status
.
IsFullyComplete
(
)
)
{
NS_ASSERTION
(
!
kidNextInFlow
"
bad
child
flow
list
"
)
;
}
else
if
(
!
kidNextInFlow
)
{
nsIFrame
*
continuingSheet
=
PresShell
(
)
-
>
FrameConstructor
(
)
-
>
CreateContinuingFrame
(
kidFrame
this
)
;
mFrames
.
InsertFrame
(
nullptr
kidFrame
continuingSheet
)
;
}
}
nsAutoString
formattedDateString
;
PRTime
now
=
PR_Now
(
)
;
if
(
NS_SUCCEEDED
(
DateTimeFormat
:
:
FormatPRTime
(
kDateFormatShort
kTimeFormatShort
now
formattedDateString
)
)
)
{
SetDateTimeStr
(
formattedDateString
)
;
}
mSize
=
nsSize
(
maxInflatedSheetWidth
y
)
;
if
(
aPresContext
-
>
IsScreen
(
)
)
{
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
mMaxSheetSize
=
LogicalSize
(
wm
nsSize
(
maxInflatedSheetWidth
maxInflatedSheetHeight
)
)
;
}
PopulateReflowOutput
(
aReflowOutput
aReflowInput
)
;
FinishAndStoreOverflow
(
&
aReflowOutput
)
;
CenterPages
(
)
;
NS_FRAME_TRACE_REFLOW_OUT
(
"
nsPageSequenceFrame
:
:
Reflow
"
aStatus
)
;
NS_FRAME_SET_TRUNCATION
(
aStatus
aReflowInput
aReflowOutput
)
;
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
nsPageSequenceFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
u
"
PageSequence
"
_ns
aResult
)
;
}
#
endif
void
nsPageSequenceFrame
:
:
SetPageNumberFormat
(
const
char
*
aPropName
const
char
*
aDefPropVal
bool
aPageNumOnly
)
{
nsAutoString
pageNumberFormat
;
nsresult
rv
=
nsContentUtils
:
:
GetLocalizedString
(
nsContentUtils
:
:
ePRINTING_PROPERTIES
aPropName
pageNumberFormat
)
;
if
(
NS_FAILED
(
rv
)
)
{
pageNumberFormat
.
AssignASCII
(
aDefPropVal
)
;
}
SetPageNumberFormat
(
pageNumberFormat
aPageNumOnly
)
;
}
nsresult
nsPageSequenceFrame
:
:
StartPrint
(
nsPresContext
*
aPresContext
nsIPrintSettings
*
aPrintSettings
const
nsAString
&
aDocTitle
const
nsAString
&
aDocURL
)
{
NS_ENSURE_ARG_POINTER
(
aPresContext
)
;
NS_ENSURE_ARG_POINTER
(
aPrintSettings
)
;
if
(
!
mPageData
-
>
mPrintSettings
)
{
mPageData
-
>
mPrintSettings
=
aPrintSettings
;
}
if
(
!
aDocTitle
.
IsEmpty
(
)
)
{
mPageData
-
>
mDocTitle
=
aDocTitle
;
}
if
(
!
aDocURL
.
IsEmpty
(
)
)
{
mPageData
-
>
mDocURL
=
aDocURL
;
}
mCurrentSheetIdx
=
0
;
return
NS_OK
;
}
static
void
GetPrintCanvasElementsInFrame
(
nsIFrame
*
aFrame
nsTArray
<
RefPtr
<
HTMLCanvasElement
>
>
*
aArr
)
{
if
(
!
aFrame
)
{
return
;
}
for
(
const
auto
&
childList
:
aFrame
-
>
ChildLists
(
)
)
{
for
(
nsIFrame
*
child
:
childList
.
mList
)
{
nsHTMLCanvasFrame
*
canvasFrame
=
do_QueryFrame
(
child
)
;
if
(
canvasFrame
)
{
HTMLCanvasElement
*
canvas
=
HTMLCanvasElement
:
:
FromNodeOrNull
(
canvasFrame
-
>
GetContent
(
)
)
;
if
(
canvas
&
&
canvas
-
>
GetMozPrintCallback
(
)
)
{
aArr
-
>
AppendElement
(
canvas
)
;
continue
;
}
}
if
(
!
child
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
)
{
nsSubDocumentFrame
*
subdocumentFrame
=
do_QueryFrame
(
child
)
;
if
(
subdocumentFrame
)
{
nsIFrame
*
root
=
subdocumentFrame
-
>
GetSubdocumentRootFrame
(
)
;
child
=
root
;
}
}
GetPrintCanvasElementsInFrame
(
child
aArr
)
;
}
}
}
nsIFrame
*
nsPageSequenceFrame
:
:
GetCurrentSheetFrame
(
)
{
uint32_t
i
=
0
;
for
(
nsIFrame
*
child
:
mFrames
)
{
if
(
i
=
=
mCurrentSheetIdx
)
{
return
child
;
}
+
+
i
;
}
return
nullptr
;
}
nsresult
nsPageSequenceFrame
:
:
PrePrintNextSheet
(
nsITimerCallback
*
aCallback
bool
*
aDone
)
{
nsIFrame
*
currentSheet
=
GetCurrentSheetFrame
(
)
;
if
(
!
currentSheet
)
{
*
aDone
=
true
;
return
NS_ERROR_FAILURE
;
}
if
(
!
PresContext
(
)
-
>
IsRootPaginatedDocument
(
)
)
{
*
aDone
=
true
;
return
NS_OK
;
}
if
(
!
mCurrentCanvasListSetup
)
{
mCurrentCanvasListSetup
=
true
;
GetPrintCanvasElementsInFrame
(
currentSheet
&
mCurrentCanvasList
)
;
if
(
!
mCurrentCanvasList
.
IsEmpty
(
)
)
{
nsresult
rv
=
NS_OK
;
nsDeviceContext
*
dc
=
PresContext
(
)
-
>
DeviceContext
(
)
;
PR_PL
(
(
"
\
n
"
)
)
;
PR_PL
(
(
"
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
BeginPage
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
\
n
"
)
)
;
rv
=
dc
-
>
BeginPage
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mCalledBeginPage
=
true
;
RefPtr
<
gfxContext
>
renderingContext
=
dc
-
>
CreateRenderingContext
(
)
;
NS_ENSURE_TRUE
(
renderingContext
NS_ERROR_OUT_OF_MEMORY
)
;
DrawTarget
*
drawTarget
=
renderingContext
-
>
GetDrawTarget
(
)
;
if
(
NS_WARN_IF
(
!
drawTarget
)
)
{
return
NS_ERROR_FAILURE
;
}
for
(
HTMLCanvasElement
*
canvas
:
Reversed
(
mCurrentCanvasList
)
)
{
nsIntSize
size
=
canvas
-
>
GetSize
(
)
;
RefPtr
<
DrawTarget
>
canvasTarget
=
drawTarget
-
>
CreateSimilarDrawTarget
(
size
drawTarget
-
>
GetFormat
(
)
)
;
if
(
!
canvasTarget
)
{
continue
;
}
nsICanvasRenderingContextInternal
*
ctx
=
canvas
-
>
GetCurrentContext
(
)
;
if
(
!
ctx
)
{
continue
;
}
ctx
-
>
InitializeWithDrawTarget
(
nullptr
WrapNotNull
(
canvasTarget
)
)
;
AutoWeakFrame
weakFrame
=
this
;
canvas
-
>
DispatchPrintCallback
(
aCallback
)
;
NS_ENSURE_STATE
(
weakFrame
.
IsAlive
(
)
)
;
}
}
}
uint32_t
doneCounter
=
0
;
for
(
HTMLCanvasElement
*
canvas
:
mCurrentCanvasList
)
{
if
(
canvas
-
>
IsPrintCallbackDone
(
)
)
{
doneCounter
+
+
;
}
}
*
aDone
=
doneCounter
=
=
mCurrentCanvasList
.
Length
(
)
;
return
NS_OK
;
}
void
nsPageSequenceFrame
:
:
ResetPrintCanvasList
(
)
{
for
(
int32_t
i
=
mCurrentCanvasList
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
HTMLCanvasElement
*
canvas
=
mCurrentCanvasList
[
i
]
;
canvas
-
>
ResetPrintCallback
(
)
;
}
mCurrentCanvasList
.
Clear
(
)
;
mCurrentCanvasListSetup
=
false
;
}
nsresult
nsPageSequenceFrame
:
:
PrintNextSheet
(
)
{
nsIFrame
*
currentSheetFrame
=
GetCurrentSheetFrame
(
)
;
if
(
!
currentSheetFrame
)
{
return
NS_ERROR_FAILURE
;
}
nsresult
rv
=
NS_OK
;
nsDeviceContext
*
dc
=
PresContext
(
)
-
>
DeviceContext
(
)
;
if
(
PresContext
(
)
-
>
IsRootPaginatedDocument
(
)
)
{
if
(
!
mCalledBeginPage
)
{
PR_PL
(
(
"
\
n
"
)
)
;
PR_PL
(
(
"
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
BeginPage
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
\
n
"
)
)
;
rv
=
dc
-
>
BeginPage
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
}
PR_PL
(
(
"
SeqFr
:
:
PrintNextSheet
-
>
%
p
SheetIdx
:
%
d
"
currentSheetFrame
mCurrentSheetIdx
)
)
;
RefPtr
<
gfxContext
>
gCtx
=
dc
-
>
CreateRenderingContext
(
)
;
NS_ENSURE_TRUE
(
gCtx
NS_ERROR_OUT_OF_MEMORY
)
;
nsRect
drawingRect
(
nsPoint
(
0
0
)
currentSheetFrame
-
>
GetSize
(
)
)
;
nsRegion
drawingRegion
(
drawingRect
)
;
nsLayoutUtils
:
:
PaintFrame
(
gCtx
currentSheetFrame
drawingRegion
NS_RGBA
(
0
0
0
0
)
nsDisplayListBuilderMode
:
:
Painting
nsLayoutUtils
:
:
PaintFrameFlags
:
:
SyncDecodeImages
)
;
return
rv
;
}
nsresult
nsPageSequenceFrame
:
:
DoPageEnd
(
)
{
nsresult
rv
=
NS_OK
;
if
(
PresContext
(
)
-
>
IsRootPaginatedDocument
(
)
)
{
PR_PL
(
(
"
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
End
Page
(
DoPageEnd
)
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
*
\
n
"
)
)
;
rv
=
PresContext
(
)
-
>
DeviceContext
(
)
-
>
EndPage
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
ResetPrintCanvasList
(
)
;
mCalledBeginPage
=
false
;
mCurrentSheetIdx
+
+
;
return
rv
;
}
gfx
:
:
Matrix4x4
ComputePageSequenceTransform
(
nsIFrame
*
aFrame
float
aAppUnitsPerPixel
)
{
MOZ_ASSERT
(
aFrame
-
>
IsPageSequenceFrame
(
)
)
;
float
scale
=
static_cast
<
nsPageSequenceFrame
*
>
(
aFrame
)
-
>
GetPrintPreviewScale
(
)
;
return
gfx
:
:
Matrix4x4
:
:
Scaling
(
scale
scale
1
)
;
}
void
nsPageSequenceFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
aBuilder
-
>
SetInPageSequence
(
true
)
;
aBuilder
-
>
SetDisablePartialUpdates
(
true
)
;
DisplayBorderBackgroundOutline
(
aBuilder
aLists
)
;
nsDisplayList
content
;
{
DisplayListClipState
:
:
AutoSaveRestore
clipState
(
aBuilder
)
;
clipState
.
Clear
(
)
;
nsIFrame
*
child
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
nsRect
visible
=
aBuilder
-
>
GetVisibleRect
(
)
;
visible
.
ScaleInverseRoundOut
(
GetPrintPreviewScale
(
)
)
;
while
(
child
)
{
if
(
child
-
>
InkOverflowRectRelativeToParent
(
)
.
Intersects
(
visible
)
)
{
nsDisplayListBuilder
:
:
AutoBuildingDisplayList
buildingForChild
(
aBuilder
child
visible
-
child
-
>
GetPosition
(
)
visible
-
child
-
>
GetPosition
(
)
)
;
child
-
>
BuildDisplayListForStackingContext
(
aBuilder
&
content
)
;
aBuilder
-
>
ResetMarkedFramesForDisplayList
(
this
)
;
}
child
=
child
-
>
GetNextSibling
(
)
;
}
}
content
.
AppendNewToTop
<
nsDisplayTransform
>
(
aBuilder
this
&
content
content
.
GetBuildingRect
(
)
:
:
ComputePageSequenceTransform
)
;
aLists
.
Content
(
)
-
>
AppendToTop
(
&
content
)
;
aBuilder
-
>
SetInPageSequence
(
false
)
;
}
void
nsPageSequenceFrame
:
:
SetPageNumberFormat
(
const
nsAString
&
aFormatStr
bool
aForPageNumOnly
)
{
NS_ASSERTION
(
mPageData
!
=
nullptr
"
mPageData
string
cannot
be
null
!
"
)
;
if
(
aForPageNumOnly
)
{
mPageData
-
>
mPageNumFormat
=
aFormatStr
;
}
else
{
mPageData
-
>
mPageNumAndTotalsFormat
=
aFormatStr
;
}
}
void
nsPageSequenceFrame
:
:
SetDateTimeStr
(
const
nsAString
&
aDateTimeStr
)
{
NS_ASSERTION
(
mPageData
!
=
nullptr
"
mPageData
string
cannot
be
null
!
"
)
;
mPageData
-
>
mDateTimeStr
=
aDateTimeStr
;
}
void
nsPageSequenceFrame
:
:
AppendDirectlyOwnedAnonBoxes
(
nsTArray
<
OwnedAnonBox
>
&
aResult
)
{
MOZ_ASSERT
(
mFrames
.
FirstChild
(
)
&
&
mFrames
.
FirstChild
(
)
-
>
IsPrintedSheetFrame
(
)
"
nsPageSequenceFrame
must
have
a
PrintedSheetFrame
child
"
)
;
aResult
.
AppendElement
(
mFrames
.
FirstChild
(
)
)
;
}
