#
ifndef
nsFrameSelection_h___
#
define
nsFrameSelection_h___
#
include
<
stdint
.
h
>
#
include
"
mozilla
/
intl
/
BidiEmbeddingLevel
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
EnumSet
.
h
"
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
Result
.
h
"
#
include
"
mozilla
/
TextRange
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsISelectionListener
.
h
"
#
include
"
nsITableCellLayout
.
h
"
#
include
"
WordMovementType
.
h
"
#
include
"
CaretAssociationHint
.
h
"
#
include
"
nsBidiPresUtils
.
h
"
class
nsRange
;
#
define
BIDI_LEVEL_UNDEFINED
mozilla
:
:
intl
:
:
BidiEmbeddingLevel
(
0x80
)
struct
SelectionDetails
{
SelectionDetails
(
)
:
mStart
(
)
mEnd
(
)
mSelectionType
(
mozilla
:
:
SelectionType
:
:
eInvalid
)
{
MOZ_COUNT_CTOR
(
SelectionDetails
)
;
}
MOZ_COUNTED_DTOR
(
SelectionDetails
)
int32_t
mStart
;
int32_t
mEnd
;
mozilla
:
:
SelectionType
mSelectionType
;
RefPtr
<
const
nsAtom
>
mHighlightName
;
mozilla
:
:
TextRangeStyle
mTextRangeStyle
;
mozilla
:
:
UniquePtr
<
SelectionDetails
>
mNext
;
}
;
struct
SelectionCustomColors
{
#
ifdef
NS_BUILD_REFCNT_LOGGING
MOZ_COUNTED_DEFAULT_CTOR
(
SelectionCustomColors
)
MOZ_COUNTED_DTOR
(
SelectionCustomColors
)
#
endif
mozilla
:
:
Maybe
<
nscolor
>
mForegroundColor
;
mozilla
:
:
Maybe
<
nscolor
>
mBackgroundColor
;
mozilla
:
:
Maybe
<
nscolor
>
mAltForegroundColor
;
mozilla
:
:
Maybe
<
nscolor
>
mAltBackgroundColor
;
}
;
namespace
mozilla
{
class
PresShell
;
}
namespace
mozilla
{
enum
class
PeekOffsetOption
:
uint8_t
{
JumpLines
PreserveSpaces
ScrollViewStop
IsKeyboardSelect
Visual
Extend
ForceEditableRegion
AllowContentInDifferentNativeAnonymousSubtreeRoot
}
;
using
PeekOffsetOptions
=
EnumSet
<
PeekOffsetOption
>
;
struct
MOZ_STACK_CLASS
PeekOffsetStruct
{
PeekOffsetStruct
(
nsSelectionAmount
aAmount
nsDirection
aDirection
int32_t
aStartOffset
nsPoint
aDesiredCaretPos
const
PeekOffsetOptions
aOptions
EWordMovementType
aWordMovementType
=
eDefaultBehavior
)
;
nsSelectionAmount
mAmount
;
const
nsDirection
mDirection
;
int32_t
mStartOffset
;
const
nsPoint
mDesiredCaretPos
;
EWordMovementType
mWordMovementType
;
PeekOffsetOptions
mOptions
;
nsCOMPtr
<
nsIContent
>
mResultContent
;
nsIFrame
*
mResultFrame
;
int32_t
mContentOffset
;
CaretAssociationHint
mAttach
;
}
;
}
struct
nsPrevNextBidiLevels
{
void
SetData
(
nsIFrame
*
aFrameBefore
nsIFrame
*
aFrameAfter
mozilla
:
:
intl
:
:
BidiEmbeddingLevel
aLevelBefore
mozilla
:
:
intl
:
:
BidiEmbeddingLevel
aLevelAfter
)
{
mFrameBefore
=
aFrameBefore
;
mFrameAfter
=
aFrameAfter
;
mLevelBefore
=
aLevelBefore
;
mLevelAfter
=
aLevelAfter
;
}
nsIFrame
*
mFrameBefore
;
nsIFrame
*
mFrameAfter
;
mozilla
:
:
intl
:
:
BidiEmbeddingLevel
mLevelBefore
;
mozilla
:
:
intl
:
:
BidiEmbeddingLevel
mLevelAfter
;
}
;
namespace
mozilla
{
class
SelectionChangeEventDispatcher
;
namespace
dom
{
class
Highlight
;
class
Selection
;
}
enum
class
TableSelectionMode
:
uint32_t
{
None
Cell
Row
Column
Table
AllCells
}
;
}
class
nsIScrollableFrame
;
class
nsFrameSelection
final
{
public
:
typedef
mozilla
:
:
CaretAssociationHint
CaretAssociateHint
;
NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING
(
nsFrameSelection
)
NS_DECL_CYCLE_COLLECTION_NATIVE_CLASS
(
nsFrameSelection
)
enum
class
FocusMode
{
kExtendSelection
kCollapseToNewPoint
kMultiRangeSelection
}
;
MOZ_CAN_RUN_SCRIPT
nsresult
HandleClick
(
nsIContent
*
aNewFocus
uint32_t
aContentOffset
uint32_t
aContentEndOffset
FocusMode
aFocusMode
CaretAssociateHint
aHint
)
;
public
:
void
SetIsDoubleClickSelection
(
bool
aIsDoubleClickSelection
)
{
mIsDoubleClickSelection
=
aIsDoubleClickSelection
;
}
[
[
nodiscard
]
]
bool
IsDoubleClickSelection
(
)
const
{
return
mIsDoubleClickSelection
;
}
MOZ_CAN_RUN_SCRIPT
void
HandleDrag
(
nsIFrame
*
aFrame
const
nsPoint
&
aPoint
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
HandleTableSelection
(
nsINode
*
aParentContent
int32_t
aContentOffset
mozilla
:
:
TableSelectionMode
aTarget
mozilla
:
:
WidgetMouseEvent
*
aMouseEvent
)
;
nsresult
SelectCellElement
(
nsIContent
*
aCell
)
;
public
:
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
RemoveCellsFromSelection
(
nsIContent
*
aTable
int32_t
aStartRowIndex
int32_t
aStartColumnIndex
int32_t
aEndRowIndex
int32_t
aEndColumnIndex
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
RestrictCellsToSelection
(
nsIContent
*
aTable
int32_t
aStartRowIndex
int32_t
aStartColumnIndex
int32_t
aEndRowIndex
int32_t
aEndColumnIndex
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
StartAutoScrollTimer
(
nsIFrame
*
aFrame
const
nsPoint
&
aPoint
uint32_t
aDelay
)
;
void
StopAutoScrollTimer
(
)
;
mozilla
:
:
UniquePtr
<
SelectionDetails
>
LookUpSelection
(
nsIContent
*
aContent
int32_t
aContentOffset
int32_t
aContentLength
bool
aSlowCheck
)
const
;
MOZ_CAN_RUN_SCRIPT
void
SetDragState
(
bool
aState
)
;
bool
GetDragState
(
)
const
{
return
mDragState
;
}
bool
IsInTableSelectionMode
(
)
const
{
return
mTableSelection
.
mMode
!
=
mozilla
:
:
TableSelectionMode
:
:
None
;
}
void
ClearTableCellSelection
(
)
{
mTableSelection
.
mMode
=
mozilla
:
:
TableSelectionMode
:
:
None
;
}
mozilla
:
:
dom
:
:
Selection
*
GetSelection
(
mozilla
:
:
SelectionType
aSelectionType
)
const
;
MOZ_CAN_RUN_SCRIPT
void
AddHighlightSelection
(
const
nsAtom
*
aHighlightName
const
mozilla
:
:
dom
:
:
Highlight
&
aHighlight
)
;
MOZ_CAN_RUN_SCRIPT
void
RemoveHighlightSelection
(
const
nsAtom
*
aHighlightName
)
;
MOZ_CAN_RUN_SCRIPT
void
AddHighlightSelectionRange
(
const
nsAtom
*
aHighlightName
const
mozilla
:
:
dom
:
:
Highlight
&
aHighlight
mozilla
:
:
dom
:
:
AbstractRange
&
aRange
)
;
MOZ_CAN_RUN_SCRIPT
void
RemoveHighlightSelectionRange
(
const
nsAtom
*
aHighlightName
mozilla
:
:
dom
:
:
AbstractRange
&
aRange
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
ScrollSelectionIntoView
(
mozilla
:
:
SelectionType
aSelectionType
SelectionRegion
aRegion
int16_t
aFlags
)
const
;
nsresult
RepaintSelection
(
mozilla
:
:
SelectionType
aSelectionType
)
;
bool
IsValidSelectionPoint
(
nsINode
*
aNode
)
const
;
static
bool
AdjustFrameForLineStart
(
nsIFrame
*
&
aFrame
int32_t
&
aFrameOffset
)
;
static
nsIFrame
*
GetFrameForNodeOffset
(
nsIContent
*
aNode
int32_t
aOffset
CaretAssociateHint
aHint
int32_t
*
aReturnOffset
)
;
nsIFrame
*
GetFrameToPageSelect
(
)
const
;
enum
class
SelectionIntoView
{
IfChanged
Yes
}
;
MOZ_CAN_RUN_SCRIPT
nsresult
PageMove
(
bool
aForward
bool
aExtend
nsIFrame
*
aFrame
SelectionIntoView
aSelectionIntoView
)
;
void
SetHint
(
CaretAssociateHint
aHintRight
)
{
mCaret
.
mHint
=
aHintRight
;
}
CaretAssociateHint
GetHint
(
)
const
{
return
mCaret
.
mHint
;
}
void
SetCaretBidiLevelAndMaybeSchedulePaint
(
mozilla
:
:
intl
:
:
BidiEmbeddingLevel
aLevel
)
;
mozilla
:
:
intl
:
:
BidiEmbeddingLevel
GetCaretBidiLevel
(
)
const
;
void
UndefineCaretBidiLevel
(
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
PhysicalMove
(
int16_t
aDirection
int16_t
aAmount
bool
aExtend
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
CharacterMove
(
bool
aForward
bool
aExtend
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
WordMove
(
bool
aForward
bool
aExtend
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
LineMove
(
bool
aForward
bool
aExtend
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
IntraLineMove
(
bool
aForward
bool
aExtend
)
;
template
<
typename
RangeType
>
MOZ_CAN_RUN_SCRIPT
mozilla
:
:
Result
<
RefPtr
<
RangeType
>
nsresult
>
CreateRangeExtendedToNextGraphemeClusterBoundary
(
)
{
return
CreateRangeExtendedToSomewhere
<
RangeType
>
(
eDirNext
eSelectCluster
eLogical
)
;
}
template
<
typename
RangeType
>
MOZ_CAN_RUN_SCRIPT
mozilla
:
:
Result
<
RefPtr
<
RangeType
>
nsresult
>
CreateRangeExtendedToPreviousCharacterBoundary
(
)
{
return
CreateRangeExtendedToSomewhere
<
RangeType
>
(
eDirPrevious
eSelectCharacter
eLogical
)
;
}
template
<
typename
RangeType
>
MOZ_CAN_RUN_SCRIPT
mozilla
:
:
Result
<
RefPtr
<
RangeType
>
nsresult
>
CreateRangeExtendedToNextWordBoundary
(
)
{
return
CreateRangeExtendedToSomewhere
<
RangeType
>
(
eDirNext
eSelectWord
eLogical
)
;
}
template
<
typename
RangeType
>
MOZ_CAN_RUN_SCRIPT
mozilla
:
:
Result
<
RefPtr
<
RangeType
>
nsresult
>
CreateRangeExtendedToPreviousWordBoundary
(
)
{
return
CreateRangeExtendedToSomewhere
<
RangeType
>
(
eDirPrevious
eSelectWord
eLogical
)
;
}
template
<
typename
RangeType
>
MOZ_CAN_RUN_SCRIPT
mozilla
:
:
Result
<
RefPtr
<
RangeType
>
nsresult
>
CreateRangeExtendedToPreviousHardLineBreak
(
)
{
return
CreateRangeExtendedToSomewhere
<
RangeType
>
(
eDirPrevious
eSelectBeginLine
eLogical
)
;
}
template
<
typename
RangeType
>
MOZ_CAN_RUN_SCRIPT
mozilla
:
:
Result
<
RefPtr
<
RangeType
>
nsresult
>
CreateRangeExtendedToNextHardLineBreak
(
)
{
return
CreateRangeExtendedToSomewhere
<
RangeType
>
(
eDirNext
eSelectEndLine
eLogical
)
;
}
void
SetDisplaySelection
(
int16_t
aState
)
{
mDisplaySelection
=
aState
;
}
int16_t
GetDisplaySelection
(
)
const
{
return
mDisplaySelection
;
}
void
SetDelayedCaretData
(
mozilla
:
:
WidgetMouseEvent
*
aMouseEvent
)
;
bool
HasDelayedCaretData
(
)
const
{
return
mDelayedMouseEvent
.
mIsValid
;
}
bool
IsShiftDownInDelayedCaretData
(
)
const
{
NS_ASSERTION
(
mDelayedMouseEvent
.
mIsValid
"
No
valid
delayed
caret
data
"
)
;
return
mDelayedMouseEvent
.
mIsShift
;
}
uint32_t
GetClickCountInDelayedCaretData
(
)
const
{
NS_ASSERTION
(
mDelayedMouseEvent
.
mIsValid
"
No
valid
delayed
caret
data
"
)
;
return
mDelayedMouseEvent
.
mClickCount
;
}
bool
MouseDownRecorded
(
)
const
{
return
!
GetDragState
(
)
&
&
HasDelayedCaretData
(
)
&
&
GetClickCountInDelayedCaretData
(
)
<
2
;
}
nsIContent
*
GetLimiter
(
)
const
{
return
mLimiters
.
mLimiter
;
}
nsIContent
*
GetAncestorLimiter
(
)
const
{
return
mLimiters
.
mAncestorLimiter
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
SetAncestorLimiter
(
nsIContent
*
aLimiter
)
;
nsPrevNextBidiLevels
GetPrevNextBidiLevels
(
nsIContent
*
aNode
uint32_t
aContentOffset
bool
aJumpLines
)
const
;
nsresult
GetFrameFromLevel
(
nsIFrame
*
aFrameIn
nsDirection
aDirection
mozilla
:
:
intl
:
:
BidiEmbeddingLevel
aBidiLevel
nsIFrame
*
*
aFrameOut
)
const
;
nsresult
MaintainSelection
(
nsSelectionAmount
aAmount
=
eSelectNoAmount
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
ConstrainFrameAndPointToAnchorSubtree
(
nsIFrame
*
aFrame
const
nsPoint
&
aPoint
nsIFrame
*
*
aRetFrame
nsPoint
&
aRetPoint
)
const
;
nsFrameSelection
(
mozilla
:
:
PresShell
*
aPresShell
nsIContent
*
aLimiter
bool
aAccessibleCaretEnabled
)
;
void
StartBatchChanges
(
const
char
*
aRequesterFuncName
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
EndBatchChanges
(
const
char
*
aRequesterFuncName
int16_t
aReasons
=
nsISelectionListener
:
:
NO_REASON
)
;
mozilla
:
:
PresShell
*
GetPresShell
(
)
const
{
return
mPresShell
;
}
void
DisconnectFromPresShell
(
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
ClearNormalSelection
(
)
;
static
nsITableCellLayout
*
GetCellLayout
(
const
nsIContent
*
aCellContent
)
;
private
:
~
nsFrameSelection
(
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
TakeFocus
(
nsIContent
&
aNewFocus
uint32_t
aContentOffset
uint32_t
aContentEndOffset
CaretAssociateHint
aHint
FocusMode
aFocusMode
)
;
void
BidiLevelFromMove
(
mozilla
:
:
PresShell
*
aPresShell
nsIContent
*
aNode
uint32_t
aContentOffset
nsSelectionAmount
aAmount
CaretAssociateHint
aHint
)
;
void
BidiLevelFromClick
(
nsIContent
*
aNewFocus
uint32_t
aContentOffset
)
;
static
nsPrevNextBidiLevels
GetPrevNextBidiLevels
(
nsIContent
*
aNode
uint32_t
aContentOffset
CaretAssociateHint
aHint
bool
aJumpLines
)
;
void
SetChangeReasons
(
int16_t
aReasons
)
{
mSelectionChangeReasons
=
aReasons
;
}
void
AddChangeReasons
(
int16_t
aReasons
)
{
mSelectionChangeReasons
|
=
aReasons
;
}
int16_t
PopChangeReasons
(
)
{
int16_t
retval
=
mSelectionChangeReasons
;
mSelectionChangeReasons
=
nsISelectionListener
:
:
NO_REASON
;
return
retval
;
}
nsSelectionAmount
GetCaretMoveAmount
(
)
{
return
mCaretMoveAmount
;
}
bool
IsUserSelectionReason
(
)
const
{
return
(
mSelectionChangeReasons
&
(
nsISelectionListener
:
:
DRAG_REASON
|
nsISelectionListener
:
:
MOUSEDOWN_REASON
|
nsISelectionListener
:
:
MOUSEUP_REASON
|
nsISelectionListener
:
:
KEYPRESS_REASON
)
)
!
=
nsISelectionListener
:
:
NO_REASON
;
}
friend
class
mozilla
:
:
dom
:
:
Selection
;
friend
class
mozilla
:
:
SelectionChangeEventDispatcher
;
friend
struct
mozilla
:
:
AutoPrepareFocusRange
;
enum
CaretMovementStyle
{
eLogical
eVisual
eUsePrefStyle
}
;
MOZ_CAN_RUN_SCRIPT
nsresult
MoveCaret
(
nsDirection
aDirection
bool
aContinueSelection
nsSelectionAmount
aAmount
CaretMovementStyle
aMovementStyle
)
;
mozilla
:
:
Result
<
mozilla
:
:
PeekOffsetStruct
nsresult
>
PeekOffsetForCaretMove
(
nsDirection
aDirection
bool
aContinueSelection
const
nsSelectionAmount
aAmount
CaretMovementStyle
aMovementStyle
const
nsPoint
&
aDesiredCaretPos
)
const
;
template
<
typename
RangeType
>
MOZ_CAN_RUN_SCRIPT
mozilla
:
:
Result
<
RefPtr
<
RangeType
>
nsresult
>
CreateRangeExtendedToSomewhere
(
nsDirection
aDirection
const
nsSelectionAmount
aAmount
CaretMovementStyle
aMovementStyle
)
;
static
mozilla
:
:
Result
<
bool
nsresult
>
IsIntraLineCaretMove
(
nsSelectionAmount
aAmount
)
{
switch
(
aAmount
)
{
case
eSelectCharacter
:
case
eSelectCluster
:
case
eSelectWord
:
case
eSelectWordNoSpace
:
case
eSelectBeginLine
:
case
eSelectEndLine
:
return
true
;
case
eSelectLine
:
return
false
;
default
:
return
mozilla
:
:
Err
(
NS_ERROR_FAILURE
)
;
}
}
void
InvalidateDesiredCaretPos
(
)
;
bool
IsBatching
(
)
const
{
return
mBatching
.
mCounter
>
0
;
}
void
SetChangesDuringBatchingFlag
(
)
{
MOZ_ASSERT
(
mBatching
.
mCounter
>
0
)
;
mBatching
.
mChangesDuringBatching
=
true
;
}
MOZ_CAN_RUN_SCRIPT
nsresult
NotifySelectionListeners
(
mozilla
:
:
SelectionType
aSelectionType
)
;
static
nsresult
GetCellIndexes
(
const
nsIContent
*
aCell
int32_t
&
aRowIndex
int32_t
&
aColIndex
)
;
static
nsIContent
*
GetFirstCellNodeInRange
(
const
nsRange
*
aRange
)
;
static
nsIContent
*
IsInSameTable
(
const
nsIContent
*
aContent1
const
nsIContent
*
aContent2
)
;
static
nsIContent
*
GetParentTable
(
const
nsIContent
*
aCellNode
)
;
RefPtr
<
mozilla
:
:
dom
:
:
Selection
>
mDomSelections
[
sizeof
(
mozilla
:
:
kPresentSelectionTypes
)
/
sizeof
(
mozilla
:
:
SelectionType
)
]
;
nsTHashMap
<
RefPtr
<
const
nsAtom
>
RefPtr
<
mozilla
:
:
dom
:
:
Selection
>
>
mHighlightSelections
;
struct
TableSelection
{
nsRange
*
GetFirstCellRange
(
const
mozilla
:
:
dom
:
:
Selection
&
aNormalSelection
)
;
nsRange
*
GetNextCellRange
(
const
mozilla
:
:
dom
:
:
Selection
&
aNormalSelection
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
HandleSelection
(
nsINode
*
aParentContent
int32_t
aContentOffset
mozilla
:
:
TableSelectionMode
aTarget
mozilla
:
:
WidgetMouseEvent
*
aMouseEvent
bool
aDragState
mozilla
:
:
dom
:
:
Selection
&
aNormalSelection
)
;
static
nsINode
*
IsContentInActivelyEditableTableCell
(
nsPresContext
*
aContext
nsIContent
*
aContent
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
SelectBlockOfCells
(
nsIContent
*
aStartCell
nsIContent
*
aEndCell
mozilla
:
:
dom
:
:
Selection
&
aNormalSelection
)
;
nsresult
SelectRowOrColumn
(
nsIContent
*
aCellContent
mozilla
:
:
dom
:
:
Selection
&
aNormalSelection
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
UnselectCells
(
const
nsIContent
*
aTable
int32_t
aStartRowIndex
int32_t
aStartColumnIndex
int32_t
aEndRowIndex
int32_t
aEndColumnIndex
bool
aRemoveOutsideOfCellRange
mozilla
:
:
dom
:
:
Selection
&
aNormalSelection
)
;
nsCOMPtr
<
nsINode
>
mClosestInclusiveTableCellAncestor
;
nsCOMPtr
<
nsIContent
>
mStartSelectedCell
;
nsCOMPtr
<
nsIContent
>
mEndSelectedCell
;
nsCOMPtr
<
nsIContent
>
mAppendStartSelectedCell
;
nsCOMPtr
<
nsIContent
>
mUnselectCellOnMouseUp
;
mozilla
:
:
TableSelectionMode
mMode
=
mozilla
:
:
TableSelectionMode
:
:
None
;
int32_t
mSelectedCellIndex
=
0
;
bool
mDragSelectingCells
=
false
;
private
:
struct
MOZ_STACK_CLASS
FirstAndLastCell
{
nsCOMPtr
<
nsIContent
>
mFirst
;
nsCOMPtr
<
nsIContent
>
mLast
;
}
;
mozilla
:
:
Result
<
FirstAndLastCell
nsresult
>
FindFirstAndLastCellOfRowOrColumn
(
const
nsIContent
&
aCellContent
)
const
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
HandleDragSelecting
(
mozilla
:
:
TableSelectionMode
aTarget
nsIContent
*
aChildContent
const
mozilla
:
:
WidgetMouseEvent
*
aMouseEvent
mozilla
:
:
dom
:
:
Selection
&
aNormalSelection
)
;
[
[
nodiscard
]
]
MOZ_CAN_RUN_SCRIPT
nsresult
HandleMouseUpOrDown
(
mozilla
:
:
TableSelectionMode
aTarget
bool
aDragState
nsIContent
*
aChildContent
nsINode
*
aParentContent
int32_t
aContentOffset
const
mozilla
:
:
WidgetMouseEvent
*
aMouseEvent
mozilla
:
:
dom
:
:
Selection
&
aNormalSelection
)
;
class
MOZ_STACK_CLASS
RowAndColumnRelation
;
}
;
TableSelection
mTableSelection
;
struct
MaintainedRange
{
MOZ_CAN_RUN_SCRIPT
void
AdjustNormalSelection
(
const
nsIContent
*
aContent
int32_t
aOffset
mozilla
:
:
dom
:
:
Selection
&
aNormalSelection
)
const
;
void
AdjustContentOffsets
(
nsIFrame
:
:
ContentOffsets
&
aOffsets
bool
aScrollViewStop
)
const
;
void
MaintainAnchorFocusRange
(
const
mozilla
:
:
dom
:
:
Selection
&
aNormalSelection
nsSelectionAmount
aAmount
)
;
RefPtr
<
nsRange
>
mRange
;
nsSelectionAmount
mAmount
=
eSelectNoAmount
;
}
;
MaintainedRange
mMaintainedRange
;
struct
Batching
{
uint32_t
mCounter
=
0
;
bool
mChangesDuringBatching
=
false
;
}
;
Batching
mBatching
;
struct
Limiters
{
nsCOMPtr
<
nsIContent
>
mLimiter
;
nsCOMPtr
<
nsIContent
>
mAncestorLimiter
;
}
;
Limiters
mLimiters
;
mozilla
:
:
PresShell
*
mPresShell
=
nullptr
;
int16_t
mSelectionChangeReasons
=
nsISelectionListener
:
:
NO_REASON
;
int16_t
mDisplaySelection
=
nsISelectionController
:
:
SELECTION_OFF
;
nsSelectionAmount
mCaretMoveAmount
=
eSelectNoAmount
;
struct
Caret
{
CaretAssociateHint
mHint
=
mozilla
:
:
CARET_ASSOCIATE_BEFORE
;
mozilla
:
:
intl
:
:
BidiEmbeddingLevel
mBidiLevel
=
BIDI_LEVEL_UNDEFINED
;
bool
IsVisualMovement
(
bool
aContinueSelection
CaretMovementStyle
aMovementStyle
)
const
;
}
;
Caret
mCaret
;
mozilla
:
:
intl
:
:
BidiEmbeddingLevel
mKbdBidiLevel
=
mozilla
:
:
intl
:
:
BidiEmbeddingLevel
:
:
LTR
(
)
;
class
DesiredCaretPos
{
public
:
nsresult
FetchPos
(
nsPoint
&
aDesiredCaretPos
const
mozilla
:
:
PresShell
&
aPresShell
mozilla
:
:
dom
:
:
Selection
&
aNormalSelection
)
const
;
void
Set
(
const
nsPoint
&
aPos
)
;
void
Invalidate
(
)
;
bool
mIsSet
=
false
;
private
:
nsPoint
mValue
;
}
;
DesiredCaretPos
mDesiredCaretPos
;
struct
DelayedMouseEvent
{
bool
mIsValid
=
false
;
bool
mIsShift
=
false
;
uint32_t
mClickCount
=
0
;
}
;
DelayedMouseEvent
mDelayedMouseEvent
;
bool
mDragState
=
false
;
bool
mAccessibleCaretEnabled
=
false
;
bool
mIsDoubleClickSelection
{
false
}
;
}
;
class
MOZ_STACK_CLASS
AutoFrameSelectionBatcher
{
public
:
explicit
AutoFrameSelectionBatcher
(
const
char
*
aFunctionName
size_t
aEstimatedSize
=
1
)
:
mFunctionName
(
aFunctionName
)
{
mFrameSelections
.
SetCapacity
(
aEstimatedSize
)
;
}
~
AutoFrameSelectionBatcher
(
)
{
for
(
const
auto
&
frameSelection
:
mFrameSelections
)
{
frameSelection
-
>
EndBatchChanges
(
mFunctionName
)
;
}
}
void
AddFrameSelection
(
nsFrameSelection
*
aFrameSelection
)
{
if
(
!
aFrameSelection
)
{
return
;
}
aFrameSelection
-
>
StartBatchChanges
(
mFunctionName
)
;
mFrameSelections
.
AppendElement
(
aFrameSelection
)
;
}
private
:
const
char
*
mFunctionName
;
AutoTArray
<
RefPtr
<
nsFrameSelection
>
1
>
mFrameSelections
;
}
;
#
endif
