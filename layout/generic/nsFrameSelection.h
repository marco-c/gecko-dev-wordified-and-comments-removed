#
ifndef
nsFrameSelection_h___
#
define
nsFrameSelection_h___
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
TextRange
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsISelectionListener
.
h
"
#
include
"
nsITableCellLayout
.
h
"
#
include
"
WordMovementType
.
h
"
#
include
"
CaretAssociationHint
.
h
"
#
include
"
nsBidiPresUtils
.
h
"
class
nsRange
;
#
define
BIDI_LEVEL_UNDEFINED
0x80
struct
SelectionDetails
{
SelectionDetails
(
)
:
mStart
(
)
mEnd
(
)
mSelectionType
(
mozilla
:
:
SelectionType
:
:
eInvalid
)
{
MOZ_COUNT_CTOR
(
SelectionDetails
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
~
SelectionDetails
(
)
{
MOZ_COUNT_DTOR
(
SelectionDetails
)
;
}
#
endif
int32_t
mStart
;
int32_t
mEnd
;
mozilla
:
:
SelectionType
mSelectionType
;
mozilla
:
:
TextRangeStyle
mTextRangeStyle
;
mozilla
:
:
UniquePtr
<
SelectionDetails
>
mNext
;
}
;
struct
SelectionCustomColors
{
#
ifdef
NS_BUILD_REFCNT_LOGGING
SelectionCustomColors
(
)
{
MOZ_COUNT_CTOR
(
SelectionCustomColors
)
;
}
~
SelectionCustomColors
(
)
{
MOZ_COUNT_DTOR
(
SelectionCustomColors
)
;
}
#
endif
mozilla
:
:
Maybe
<
nscolor
>
mForegroundColor
;
mozilla
:
:
Maybe
<
nscolor
>
mBackgroundColor
;
mozilla
:
:
Maybe
<
nscolor
>
mAltForegroundColor
;
mozilla
:
:
Maybe
<
nscolor
>
mAltBackgroundColor
;
}
;
class
nsIPresShell
;
struct
MOZ_STACK_CLASS
nsPeekOffsetStruct
{
nsPeekOffsetStruct
(
nsSelectionAmount
aAmount
nsDirection
aDirection
int32_t
aStartOffset
nsPoint
aDesiredPos
bool
aJumpLines
bool
aScrollViewStop
bool
aIsKeyboardSelect
bool
aVisual
bool
aExtend
mozilla
:
:
EWordMovementType
aWordMovementType
=
mozilla
:
:
eDefaultBehavior
)
;
nsSelectionAmount
mAmount
;
nsDirection
mDirection
;
int32_t
mStartOffset
;
nsPoint
mDesiredPos
;
mozilla
:
:
EWordMovementType
mWordMovementType
;
bool
mJumpLines
;
bool
mScrollViewStop
;
bool
mIsKeyboardSelect
;
bool
mVisual
;
bool
mExtend
;
nsCOMPtr
<
nsIContent
>
mResultContent
;
nsIFrame
*
mResultFrame
;
int32_t
mContentOffset
;
mozilla
:
:
CaretAssociationHint
mAttach
;
}
;
struct
nsPrevNextBidiLevels
{
void
SetData
(
nsIFrame
*
aFrameBefore
nsIFrame
*
aFrameAfter
nsBidiLevel
aLevelBefore
nsBidiLevel
aLevelAfter
)
{
mFrameBefore
=
aFrameBefore
;
mFrameAfter
=
aFrameAfter
;
mLevelBefore
=
aLevelBefore
;
mLevelAfter
=
aLevelAfter
;
}
nsIFrame
*
mFrameBefore
;
nsIFrame
*
mFrameAfter
;
nsBidiLevel
mLevelBefore
;
nsBidiLevel
mLevelAfter
;
}
;
namespace
mozilla
{
namespace
dom
{
class
Selection
;
class
SelectionChangeListener
;
}
enum
class
TableSelection
:
uint32_t
{
None
Cell
Row
Column
Table
AllCells
}
;
}
class
nsIScrollableFrame
;
class
nsFrameSelection
final
{
public
:
typedef
mozilla
:
:
CaretAssociationHint
CaretAssociateHint
;
NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING
(
nsFrameSelection
)
NS_DECL_CYCLE_COLLECTION_NATIVE_CLASS
(
nsFrameSelection
)
void
Init
(
nsIPresShell
*
aShell
nsIContent
*
aLimiter
bool
aAccessibleCaretEnabled
)
;
nsresult
HandleClick
(
nsIContent
*
aNewFocus
uint32_t
aContentOffset
uint32_t
aContentEndOffset
bool
aContinueSelection
bool
aMultipleSelection
CaretAssociateHint
aHint
)
;
void
HandleDrag
(
nsIFrame
*
aFrame
const
nsPoint
&
aPoint
)
;
nsresult
HandleTableSelection
(
nsINode
*
aParentContent
int32_t
aContentOffset
mozilla
:
:
TableSelection
aTarget
mozilla
:
:
WidgetMouseEvent
*
aMouseEvent
)
;
nsresult
SelectCellElement
(
nsIContent
*
aCell
)
;
nsresult
AddCellsToSelection
(
nsIContent
*
aTable
int32_t
aStartRowIndex
int32_t
aStartColumnIndex
int32_t
aEndRowIndex
int32_t
aEndColumnIndex
)
;
nsresult
RemoveCellsFromSelection
(
nsIContent
*
aTable
int32_t
aStartRowIndex
int32_t
aStartColumnIndex
int32_t
aEndRowIndex
int32_t
aEndColumnIndex
)
;
nsresult
RestrictCellsToSelection
(
nsIContent
*
aTable
int32_t
aStartRowIndex
int32_t
aStartColumnIndex
int32_t
aEndRowIndex
int32_t
aEndColumnIndex
)
;
nsresult
StartAutoScrollTimer
(
nsIFrame
*
aFrame
const
nsPoint
&
aPoint
uint32_t
aDelay
)
;
void
StopAutoScrollTimer
(
)
;
mozilla
:
:
UniquePtr
<
SelectionDetails
>
LookUpSelection
(
nsIContent
*
aContent
int32_t
aContentOffset
int32_t
aContentLength
bool
aSlowCheck
)
const
;
void
SetDragState
(
bool
aState
)
;
bool
GetDragState
(
)
const
{
return
mDragState
;
}
bool
GetTableCellSelection
(
)
const
{
return
mSelectingTableCellMode
!
=
mozilla
:
:
TableSelection
:
:
None
;
}
void
ClearTableCellSelection
(
)
{
mSelectingTableCellMode
=
mozilla
:
:
TableSelection
:
:
None
;
}
mozilla
:
:
dom
:
:
Selection
*
GetSelection
(
mozilla
:
:
SelectionType
aSelectionType
)
const
;
nsresult
ScrollSelectionIntoView
(
mozilla
:
:
SelectionType
aSelectionType
SelectionRegion
aRegion
int16_t
aFlags
)
const
;
nsresult
RepaintSelection
(
mozilla
:
:
SelectionType
aSelectionType
)
;
nsIFrame
*
GetFrameForNodeOffset
(
nsIContent
*
aNode
int32_t
aOffset
CaretAssociateHint
aHint
int32_t
*
aReturnOffset
)
const
;
void
CommonPageMove
(
bool
aForward
bool
aExtend
nsIScrollableFrame
*
aScrollableFrame
)
;
void
SetHint
(
CaretAssociateHint
aHintRight
)
{
mHint
=
aHintRight
;
}
CaretAssociateHint
GetHint
(
)
const
{
return
mHint
;
}
void
SetCaretBidiLevel
(
nsBidiLevel
aLevel
)
;
nsBidiLevel
GetCaretBidiLevel
(
)
const
;
void
UndefineCaretBidiLevel
(
)
;
nsresult
PhysicalMove
(
int16_t
aDirection
int16_t
aAmount
bool
aExtend
)
;
nsresult
CharacterMove
(
bool
aForward
bool
aExtend
)
;
nsresult
CharacterExtendForDelete
(
)
;
nsresult
CharacterExtendForBackspace
(
)
;
nsresult
WordMove
(
bool
aForward
bool
aExtend
)
;
nsresult
WordExtendForDelete
(
bool
aForward
)
;
nsresult
LineMove
(
bool
aForward
bool
aExtend
)
;
nsresult
IntraLineMove
(
bool
aForward
bool
aExtend
)
;
nsresult
SelectAll
(
)
;
void
SetDisplaySelection
(
int16_t
aState
)
{
mDisplaySelection
=
aState
;
}
int16_t
GetDisplaySelection
(
)
const
{
return
mDisplaySelection
;
}
void
SetDelayedCaretData
(
mozilla
:
:
WidgetMouseEvent
*
aMouseEvent
)
;
bool
HasDelayedCaretData
(
)
{
return
mDelayedMouseEventValid
;
}
bool
IsShiftDownInDelayedCaretData
(
)
{
NS_ASSERTION
(
mDelayedMouseEventValid
"
No
valid
delayed
caret
data
"
)
;
return
mDelayedMouseEventIsShift
;
}
uint32_t
GetClickCountInDelayedCaretData
(
)
{
NS_ASSERTION
(
mDelayedMouseEventValid
"
No
valid
delayed
caret
data
"
)
;
return
mDelayedMouseEventClickCount
;
}
bool
MouseDownRecorded
(
)
{
return
!
GetDragState
(
)
&
&
HasDelayedCaretData
(
)
&
&
GetClickCountInDelayedCaretData
(
)
<
2
;
}
nsIContent
*
GetLimiter
(
)
const
{
return
mLimiter
;
}
nsIContent
*
GetAncestorLimiter
(
)
const
{
return
mAncestorLimiter
;
}
void
SetAncestorLimiter
(
nsIContent
*
aLimiter
)
;
void
SetMouseDoubleDown
(
bool
aDoubleDown
)
{
mMouseDoubleDownState
=
aDoubleDown
;
}
bool
GetMouseDoubleDown
(
)
const
{
return
mMouseDoubleDownState
;
}
nsPrevNextBidiLevels
GetPrevNextBidiLevels
(
nsIContent
*
aNode
uint32_t
aContentOffset
bool
aJumpLines
)
const
;
nsresult
GetFrameFromLevel
(
nsIFrame
*
aFrameIn
nsDirection
aDirection
nsBidiLevel
aBidiLevel
nsIFrame
*
*
aFrameOut
)
const
;
nsresult
MaintainSelection
(
nsSelectionAmount
aAmount
=
eSelectNoAmount
)
;
nsresult
ConstrainFrameAndPointToAnchorSubtree
(
nsIFrame
*
aFrame
const
nsPoint
&
aPoint
nsIFrame
*
*
aRetFrame
nsPoint
&
aRetPoint
)
;
nsFrameSelection
(
)
;
void
StartBatchChanges
(
)
;
void
EndBatchChanges
(
int16_t
aReason
=
nsISelectionListener
:
:
NO_REASON
)
;
nsresult
DeleteFromDocument
(
)
;
nsIPresShell
*
GetShell
(
)
const
{
return
mShell
;
}
void
DisconnectFromPresShell
(
)
;
nsresult
ClearNormalSelection
(
)
;
private
:
~
nsFrameSelection
(
)
;
nsresult
TakeFocus
(
nsIContent
*
aNewFocus
uint32_t
aContentOffset
uint32_t
aContentEndOffset
CaretAssociateHint
aHint
bool
aContinueSelection
bool
aMultipleSelection
)
;
void
BidiLevelFromMove
(
nsIPresShell
*
aPresShell
nsIContent
*
aNode
uint32_t
aContentOffset
nsSelectionAmount
aAmount
CaretAssociateHint
aHint
)
;
void
BidiLevelFromClick
(
nsIContent
*
aNewFocus
uint32_t
aContentOffset
)
;
nsPrevNextBidiLevels
GetPrevNextBidiLevels
(
nsIContent
*
aNode
uint32_t
aContentOffset
CaretAssociateHint
aHint
bool
aJumpLines
)
const
;
bool
AdjustForMaintainedSelection
(
nsIContent
*
aContent
int32_t
aOffset
)
;
void
PostReason
(
int16_t
aReason
)
{
mSelectionChangeReason
=
aReason
;
}
int16_t
PopReason
(
)
{
int16_t
retval
=
mSelectionChangeReason
;
mSelectionChangeReason
=
nsISelectionListener
:
:
NO_REASON
;
return
retval
;
}
bool
IsUserSelectionReason
(
)
const
{
return
(
mSelectionChangeReason
&
(
nsISelectionListener
:
:
DRAG_REASON
|
nsISelectionListener
:
:
MOUSEDOWN_REASON
|
nsISelectionListener
:
:
MOUSEUP_REASON
|
nsISelectionListener
:
:
KEYPRESS_REASON
)
)
!
=
nsISelectionListener
:
:
NO_REASON
;
}
friend
class
mozilla
:
:
dom
:
:
Selection
;
friend
class
mozilla
:
:
dom
:
:
SelectionChangeListener
;
friend
struct
mozilla
:
:
AutoPrepareFocusRange
;
#
ifdef
DEBUG
void
printSelection
(
)
;
#
endif
void
ResizeBuffer
(
uint32_t
aNewBufSize
)
;
enum
CaretMovementStyle
{
eLogical
eVisual
eUsePrefStyle
}
;
nsresult
MoveCaret
(
nsDirection
aDirection
bool
aContinueSelection
nsSelectionAmount
aAmount
CaretMovementStyle
aMovementStyle
)
;
nsresult
FetchDesiredPos
(
nsPoint
&
aDesiredPos
)
;
void
InvalidateDesiredPos
(
)
;
void
SetDesiredPos
(
nsPoint
aPos
)
;
uint32_t
GetBatching
(
)
const
{
return
mBatching
;
}
bool
GetNotifyFrames
(
)
const
{
return
mNotifyFrames
;
}
void
SetDirty
(
bool
aDirty
=
true
)
{
if
(
mBatching
)
mChangesDuringBatching
=
aDirty
;
}
nsresult
NotifySelectionListeners
(
mozilla
:
:
SelectionType
aSelectionType
)
;
nsresult
UpdateSelectionCacheOnRepaintSelection
(
mozilla
:
:
dom
:
:
Selection
*
aSel
)
;
nsITableCellLayout
*
GetCellLayout
(
nsIContent
*
aCellContent
)
const
;
nsresult
SelectBlockOfCells
(
nsIContent
*
aStartNode
nsIContent
*
aEndNode
)
;
nsresult
SelectRowOrColumn
(
nsIContent
*
aCellContent
mozilla
:
:
TableSelection
aTarget
)
;
nsresult
UnselectCells
(
nsIContent
*
aTable
int32_t
aStartRowIndex
int32_t
aStartColumnIndex
int32_t
aEndRowIndex
int32_t
aEndColumnIndex
bool
aRemoveOutsideOfCellRange
)
;
nsresult
GetCellIndexes
(
nsIContent
*
aCell
int32_t
&
aRowIndex
int32_t
&
aColIndex
)
;
nsRange
*
GetFirstCellRange
(
)
;
nsRange
*
GetNextCellRange
(
)
;
nsIContent
*
GetFirstCellNodeInRange
(
nsRange
*
aRange
)
const
;
nsIContent
*
IsInSameTable
(
nsIContent
*
aContent1
nsIContent
*
aContent2
)
const
;
nsIContent
*
GetParentTable
(
nsIContent
*
aCellNode
)
const
;
nsresult
CreateAndAddRange
(
nsINode
*
aContainer
int32_t
aOffset
)
;
RefPtr
<
mozilla
:
:
dom
:
:
Selection
>
mDomSelections
[
sizeof
(
mozilla
:
:
kPresentSelectionTypes
)
/
sizeof
(
mozilla
:
:
SelectionType
)
]
;
nsCOMPtr
<
nsINode
>
mCellParent
;
nsCOMPtr
<
nsIContent
>
mStartSelectedCell
;
nsCOMPtr
<
nsIContent
>
mEndSelectedCell
;
nsCOMPtr
<
nsIContent
>
mAppendStartSelectedCell
;
nsCOMPtr
<
nsIContent
>
mUnselectCellOnMouseUp
;
mozilla
:
:
TableSelection
mSelectingTableCellMode
=
mozilla
:
:
TableSelection
:
:
None
;
int32_t
mSelectedCellIndex
=
0
;
RefPtr
<
nsRange
>
mMaintainRange
;
nsSelectionAmount
mMaintainedAmount
=
eSelectNoAmount
;
int32_t
mBatching
=
0
;
nsCOMPtr
<
nsIContent
>
mLimiter
;
nsCOMPtr
<
nsIContent
>
mAncestorLimiter
;
nsIPresShell
*
mShell
=
nullptr
;
int16_t
mSelectionChangeReason
=
nsISelectionListener
:
:
NO_REASON
;
int16_t
mDisplaySelection
=
nsISelectionController
:
:
SELECTION_OFF
;
CaretAssociateHint
mHint
=
mozilla
:
:
CARET_ASSOCIATE_BEFORE
;
nsBidiLevel
mCaretBidiLevel
=
BIDI_LEVEL_UNDEFINED
;
nsBidiLevel
mKbdBidiLevel
=
NSBIDI_LTR
;
nsPoint
mDesiredPos
;
bool
mDelayedMouseEventValid
=
false
;
uint32_t
mDelayedMouseEventClickCount
=
0
;
bool
mDelayedMouseEventIsShift
=
false
;
bool
mChangesDuringBatching
=
false
;
bool
mNotifyFrames
=
true
;
bool
mDragSelectingCells
=
false
;
bool
mDragState
=
false
;
bool
mMouseDoubleDownState
=
false
;
bool
mDesiredPosSet
=
false
;
bool
mAccessibleCaretEnabled
=
false
;
int8_t
mCaretMovementStyle
=
0
;
static
bool
sSelectionEventsEnabled
;
static
bool
sSelectionEventsOnTextControlsEnabled
;
}
;
#
endif
