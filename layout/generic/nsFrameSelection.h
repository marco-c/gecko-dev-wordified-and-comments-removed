#
ifndef
nsFrameSelection_h___
#
define
nsFrameSelection_h___
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
TextRange
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsISelectionListener
.
h
"
#
include
"
nsITableCellLayout
.
h
"
#
include
"
WordMovementType
.
h
"
#
include
"
CaretAssociationHint
.
h
"
#
include
"
nsBidiPresUtils
.
h
"
class
nsRange
;
#
define
BIDI_LEVEL_UNDEFINED
0x80
struct
SelectionDetails
{
SelectionDetails
(
)
:
mStart
(
)
mEnd
(
)
mSelectionType
(
mozilla
:
:
SelectionType
:
:
eInvalid
)
{
MOZ_COUNT_CTOR
(
SelectionDetails
)
;
}
MOZ_COUNTED_DTOR
(
SelectionDetails
)
int32_t
mStart
;
int32_t
mEnd
;
mozilla
:
:
SelectionType
mSelectionType
;
mozilla
:
:
TextRangeStyle
mTextRangeStyle
;
mozilla
:
:
UniquePtr
<
SelectionDetails
>
mNext
;
}
;
struct
SelectionCustomColors
{
#
ifdef
NS_BUILD_REFCNT_LOGGING
MOZ_COUNTED_DEFAULT_CTOR
(
SelectionCustomColors
)
MOZ_COUNTED_DTOR
(
SelectionCustomColors
)
#
endif
mozilla
:
:
Maybe
<
nscolor
>
mForegroundColor
;
mozilla
:
:
Maybe
<
nscolor
>
mBackgroundColor
;
mozilla
:
:
Maybe
<
nscolor
>
mAltForegroundColor
;
mozilla
:
:
Maybe
<
nscolor
>
mAltBackgroundColor
;
}
;
namespace
mozilla
{
class
PresShell
;
}
struct
MOZ_STACK_CLASS
nsPeekOffsetStruct
{
enum
class
ForceEditableRegion
{
No
Yes
}
;
nsPeekOffsetStruct
(
nsSelectionAmount
aAmount
nsDirection
aDirection
int32_t
aStartOffset
nsPoint
aDesiredPos
bool
aJumpLines
bool
aScrollViewStop
bool
aIsKeyboardSelect
bool
aVisual
bool
aExtend
ForceEditableRegion
=
ForceEditableRegion
:
:
No
mozilla
:
:
EWordMovementType
aWordMovementType
=
mozilla
:
:
eDefaultBehavior
bool
aTrimSpaces
=
true
)
;
nsSelectionAmount
mAmount
;
nsDirection
mDirection
;
int32_t
mStartOffset
;
nsPoint
mDesiredPos
;
mozilla
:
:
EWordMovementType
mWordMovementType
;
bool
mJumpLines
;
bool
mTrimSpaces
;
bool
mScrollViewStop
;
bool
mIsKeyboardSelect
;
bool
mVisual
;
bool
mExtend
;
const
bool
mForceEditableRegion
;
nsCOMPtr
<
nsIContent
>
mResultContent
;
nsIFrame
*
mResultFrame
;
int32_t
mContentOffset
;
mozilla
:
:
CaretAssociationHint
mAttach
;
}
;
struct
nsPrevNextBidiLevels
{
void
SetData
(
nsIFrame
*
aFrameBefore
nsIFrame
*
aFrameAfter
nsBidiLevel
aLevelBefore
nsBidiLevel
aLevelAfter
)
{
mFrameBefore
=
aFrameBefore
;
mFrameAfter
=
aFrameAfter
;
mLevelBefore
=
aLevelBefore
;
mLevelAfter
=
aLevelAfter
;
}
nsIFrame
*
mFrameBefore
;
nsIFrame
*
mFrameAfter
;
nsBidiLevel
mLevelBefore
;
nsBidiLevel
mLevelAfter
;
}
;
namespace
mozilla
{
class
SelectionChangeEventDispatcher
;
namespace
dom
{
class
Selection
;
}
enum
class
TableSelectionMode
:
uint32_t
{
None
Cell
Row
Column
Table
AllCells
}
;
}
class
nsIScrollableFrame
;
class
nsFrameSelection
final
{
public
:
typedef
mozilla
:
:
CaretAssociationHint
CaretAssociateHint
;
NS_INLINE_DECL_CYCLE_COLLECTING_NATIVE_REFCOUNTING
(
nsFrameSelection
)
NS_DECL_CYCLE_COLLECTION_NATIVE_CLASS
(
nsFrameSelection
)
enum
class
FocusMode
{
kExtendSelection
kCollapseToNewPoint
kMultiRangeSelection
}
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
HandleClick
(
nsIContent
*
aNewFocus
uint32_t
aContentOffset
uint32_t
aContentEndOffset
FocusMode
aFocusMode
CaretAssociateHint
aHint
)
;
void
HandleDrag
(
nsIFrame
*
aFrame
const
nsPoint
&
aPoint
)
;
nsresult
HandleTableSelection
(
nsINode
*
aParentContent
int32_t
aContentOffset
mozilla
:
:
TableSelectionMode
aTarget
mozilla
:
:
WidgetMouseEvent
*
aMouseEvent
)
;
nsresult
SelectCellElement
(
nsIContent
*
aCell
)
;
public
:
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
RemoveCellsFromSelection
(
nsIContent
*
aTable
int32_t
aStartRowIndex
int32_t
aStartColumnIndex
int32_t
aEndRowIndex
int32_t
aEndColumnIndex
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
RestrictCellsToSelection
(
nsIContent
*
aTable
int32_t
aStartRowIndex
int32_t
aStartColumnIndex
int32_t
aEndRowIndex
int32_t
aEndColumnIndex
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
StartAutoScrollTimer
(
nsIFrame
*
aFrame
const
nsPoint
&
aPoint
uint32_t
aDelay
)
;
void
StopAutoScrollTimer
(
)
;
mozilla
:
:
UniquePtr
<
SelectionDetails
>
LookUpSelection
(
nsIContent
*
aContent
int32_t
aContentOffset
int32_t
aContentLength
bool
aSlowCheck
)
const
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
SetDragState
(
bool
aState
)
;
bool
GetDragState
(
)
const
{
return
mDragState
;
}
bool
GetTableCellSelection
(
)
const
{
return
mTableSelection
.
mMode
!
=
mozilla
:
:
TableSelectionMode
:
:
None
;
}
void
ClearTableCellSelection
(
)
{
mTableSelection
.
mMode
=
mozilla
:
:
TableSelectionMode
:
:
None
;
}
mozilla
:
:
dom
:
:
Selection
*
GetSelection
(
mozilla
:
:
SelectionType
aSelectionType
)
const
;
nsresult
ScrollSelectionIntoView
(
mozilla
:
:
SelectionType
aSelectionType
SelectionRegion
aRegion
int16_t
aFlags
)
const
;
nsresult
RepaintSelection
(
mozilla
:
:
SelectionType
aSelectionType
)
;
bool
IsValidSelectionPoint
(
nsINode
*
aNode
)
const
;
static
nsIFrame
*
GetFrameForNodeOffset
(
nsIContent
*
aNode
int32_t
aOffset
CaretAssociateHint
aHint
int32_t
*
aReturnOffset
)
;
nsIFrame
*
GetFrameToPageSelect
(
)
const
;
enum
class
SelectionIntoView
{
IfChanged
Yes
}
;
MOZ_CAN_RUN_SCRIPT
nsresult
PageMove
(
bool
aForward
bool
aExtend
nsIFrame
*
aFrame
SelectionIntoView
aSelectionIntoView
)
;
void
SetHint
(
CaretAssociateHint
aHintRight
)
{
mCaret
.
mHint
=
aHintRight
;
}
CaretAssociateHint
GetHint
(
)
const
{
return
mCaret
.
mHint
;
}
void
SetCaretBidiLevel
(
nsBidiLevel
aLevel
)
;
nsBidiLevel
GetCaretBidiLevel
(
)
const
;
void
UndefineCaretBidiLevel
(
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
PhysicalMove
(
int16_t
aDirection
int16_t
aAmount
bool
aExtend
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
CharacterMove
(
bool
aForward
bool
aExtend
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
CharacterExtendForDelete
(
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
CharacterExtendForBackspace
(
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
WordMove
(
bool
aForward
bool
aExtend
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
WordExtendForDelete
(
bool
aForward
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
LineMove
(
bool
aForward
bool
aExtend
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
IntraLineMove
(
bool
aForward
bool
aExtend
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
SelectAll
(
)
;
void
SetDisplaySelection
(
int16_t
aState
)
{
mDisplaySelection
=
aState
;
}
int16_t
GetDisplaySelection
(
)
const
{
return
mDisplaySelection
;
}
void
SetDelayedCaretData
(
mozilla
:
:
WidgetMouseEvent
*
aMouseEvent
)
;
bool
HasDelayedCaretData
(
)
{
return
mDelayedMouseEvent
.
mIsValid
;
}
bool
IsShiftDownInDelayedCaretData
(
)
{
NS_ASSERTION
(
mDelayedMouseEvent
.
mIsValid
"
No
valid
delayed
caret
data
"
)
;
return
mDelayedMouseEvent
.
mIsShift
;
}
uint32_t
GetClickCountInDelayedCaretData
(
)
{
NS_ASSERTION
(
mDelayedMouseEvent
.
mIsValid
"
No
valid
delayed
caret
data
"
)
;
return
mDelayedMouseEvent
.
mClickCount
;
}
bool
MouseDownRecorded
(
)
{
return
!
GetDragState
(
)
&
&
HasDelayedCaretData
(
)
&
&
GetClickCountInDelayedCaretData
(
)
<
2
;
}
nsIContent
*
GetLimiter
(
)
const
{
return
mLimiters
.
mLimiter
;
}
nsIContent
*
GetAncestorLimiter
(
)
const
{
return
mLimiters
.
mAncestorLimiter
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
SetAncestorLimiter
(
nsIContent
*
aLimiter
)
;
nsPrevNextBidiLevels
GetPrevNextBidiLevels
(
nsIContent
*
aNode
uint32_t
aContentOffset
bool
aJumpLines
)
const
;
nsresult
GetFrameFromLevel
(
nsIFrame
*
aFrameIn
nsDirection
aDirection
nsBidiLevel
aBidiLevel
nsIFrame
*
*
aFrameOut
)
const
;
nsresult
MaintainSelection
(
nsSelectionAmount
aAmount
=
eSelectNoAmount
)
;
nsresult
ConstrainFrameAndPointToAnchorSubtree
(
nsIFrame
*
aFrame
const
nsPoint
&
aPoint
nsIFrame
*
*
aRetFrame
nsPoint
&
aRetPoint
)
const
;
nsFrameSelection
(
mozilla
:
:
PresShell
*
aPresShell
nsIContent
*
aLimiter
bool
aAccessibleCaretEnabled
)
;
void
StartBatchChanges
(
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
EndBatchChanges
(
int16_t
aReasons
=
nsISelectionListener
:
:
NO_REASON
)
;
mozilla
:
:
PresShell
*
GetPresShell
(
)
const
{
return
mPresShell
;
}
void
DisconnectFromPresShell
(
)
;
nsresult
ClearNormalSelection
(
)
;
static
nsITableCellLayout
*
GetCellLayout
(
nsIContent
*
aCellContent
)
;
private
:
~
nsFrameSelection
(
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
TakeFocus
(
nsIContent
*
aNewFocus
uint32_t
aContentOffset
uint32_t
aContentEndOffset
CaretAssociateHint
aHint
FocusMode
aFocusMode
)
;
void
BidiLevelFromMove
(
mozilla
:
:
PresShell
*
aPresShell
nsIContent
*
aNode
uint32_t
aContentOffset
nsSelectionAmount
aAmount
CaretAssociateHint
aHint
)
;
void
BidiLevelFromClick
(
nsIContent
*
aNewFocus
uint32_t
aContentOffset
)
;
static
nsPrevNextBidiLevels
GetPrevNextBidiLevels
(
nsIContent
*
aNode
uint32_t
aContentOffset
CaretAssociateHint
aHint
bool
aJumpLines
)
;
void
SetChangeReasons
(
int16_t
aReasons
)
{
mSelectionChangeReasons
=
aReasons
;
}
void
AddChangeReasons
(
int16_t
aReasons
)
{
mSelectionChangeReasons
|
=
aReasons
;
}
int16_t
PopChangeReasons
(
)
{
int16_t
retval
=
mSelectionChangeReasons
;
mSelectionChangeReasons
=
nsISelectionListener
:
:
NO_REASON
;
return
retval
;
}
bool
IsUserSelectionReason
(
)
const
{
return
(
mSelectionChangeReasons
&
(
nsISelectionListener
:
:
DRAG_REASON
|
nsISelectionListener
:
:
MOUSEDOWN_REASON
|
nsISelectionListener
:
:
MOUSEUP_REASON
|
nsISelectionListener
:
:
KEYPRESS_REASON
)
)
!
=
nsISelectionListener
:
:
NO_REASON
;
}
friend
class
mozilla
:
:
dom
:
:
Selection
;
friend
class
mozilla
:
:
SelectionChangeEventDispatcher
;
friend
struct
mozilla
:
:
AutoPrepareFocusRange
;
enum
CaretMovementStyle
{
eLogical
eVisual
eUsePrefStyle
}
;
MOZ_CAN_RUN_SCRIPT
nsresult
MoveCaret
(
nsDirection
aDirection
bool
aContinueSelection
nsSelectionAmount
aAmount
CaretMovementStyle
aMovementStyle
)
;
nsresult
FetchDesiredPos
(
nsPoint
&
aDesiredPos
)
;
void
InvalidateDesiredPos
(
)
;
void
SetDesiredPos
(
nsPoint
aPos
)
;
bool
IsBatching
(
)
const
{
return
mBatching
.
mCounter
>
0
;
}
void
SetChangesDuringBatchingFlag
(
)
{
MOZ_ASSERT
(
mBatching
.
mCounter
>
0
)
;
mBatching
.
mChangesDuringBatching
=
true
;
}
MOZ_CAN_RUN_SCRIPT
nsresult
NotifySelectionListeners
(
mozilla
:
:
SelectionType
aSelectionType
)
;
static
nsresult
GetCellIndexes
(
nsIContent
*
aCell
int32_t
&
aRowIndex
int32_t
&
aColIndex
)
;
static
nsIContent
*
GetFirstCellNodeInRange
(
const
nsRange
*
aRange
)
;
static
nsIContent
*
IsInSameTable
(
nsIContent
*
aContent1
nsIContent
*
aContent2
)
;
static
nsIContent
*
GetParentTable
(
nsIContent
*
aCellNode
)
;
RefPtr
<
mozilla
:
:
dom
:
:
Selection
>
mDomSelections
[
sizeof
(
mozilla
:
:
kPresentSelectionTypes
)
/
sizeof
(
mozilla
:
:
SelectionType
)
]
;
struct
TableSelection
{
nsRange
*
GetFirstCellRange
(
const
mozilla
:
:
dom
:
:
Selection
&
aNormalSelection
)
;
nsRange
*
GetNextCellRange
(
const
mozilla
:
:
dom
:
:
Selection
&
aNormalSelection
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
HandleSelection
(
nsINode
*
aParentContent
int32_t
aContentOffset
mozilla
:
:
TableSelectionMode
aTarget
mozilla
:
:
WidgetMouseEvent
*
aMouseEvent
bool
aDragState
mozilla
:
:
dom
:
:
Selection
&
aNormalSelection
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
SelectBlockOfCells
(
nsIContent
*
aStartCell
nsIContent
*
aEndCell
mozilla
:
:
dom
:
:
Selection
&
aNormalSelection
)
;
nsresult
SelectRowOrColumn
(
nsIContent
*
aCellContent
mozilla
:
:
dom
:
:
Selection
&
aNormalSelection
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
UnselectCells
(
nsIContent
*
aTable
int32_t
aStartRowIndex
int32_t
aStartColumnIndex
int32_t
aEndRowIndex
int32_t
aEndColumnIndex
bool
aRemoveOutsideOfCellRange
mozilla
:
:
dom
:
:
Selection
&
aNormalSelection
)
;
nsCOMPtr
<
nsINode
>
mCellParent
;
nsCOMPtr
<
nsIContent
>
mStartSelectedCell
;
nsCOMPtr
<
nsIContent
>
mEndSelectedCell
;
nsCOMPtr
<
nsIContent
>
mAppendStartSelectedCell
;
nsCOMPtr
<
nsIContent
>
mUnselectCellOnMouseUp
;
mozilla
:
:
TableSelectionMode
mMode
=
mozilla
:
:
TableSelectionMode
:
:
None
;
int32_t
mSelectedCellIndex
=
0
;
bool
mDragSelectingCells
=
false
;
}
;
TableSelection
mTableSelection
;
struct
MaintainedRange
{
bool
AdjustNormalSelection
(
const
nsIContent
*
aContent
int32_t
aOffset
mozilla
:
:
dom
:
:
Selection
&
aNormalSelection
)
const
;
void
AdjustContentOffsets
(
nsIFrame
:
:
ContentOffsets
&
aOffsets
bool
aScrollViewStop
)
const
;
void
MaintainAnchorFocusRange
(
const
mozilla
:
:
dom
:
:
Selection
&
aNormalSelection
nsSelectionAmount
aAmount
)
;
RefPtr
<
nsRange
>
mRange
;
nsSelectionAmount
mAmount
=
eSelectNoAmount
;
}
;
MaintainedRange
mMaintainedRange
;
struct
Batching
{
uint32_t
mCounter
=
0
;
bool
mChangesDuringBatching
=
false
;
}
;
Batching
mBatching
;
struct
Limiters
{
nsCOMPtr
<
nsIContent
>
mLimiter
;
nsCOMPtr
<
nsIContent
>
mAncestorLimiter
;
}
;
Limiters
mLimiters
;
mozilla
:
:
PresShell
*
mPresShell
=
nullptr
;
int16_t
mSelectionChangeReasons
=
nsISelectionListener
:
:
NO_REASON
;
int16_t
mDisplaySelection
=
nsISelectionController
:
:
SELECTION_OFF
;
struct
Caret
{
CaretAssociateHint
mHint
=
mozilla
:
:
CARET_ASSOCIATE_BEFORE
;
nsBidiLevel
mBidiLevel
=
BIDI_LEVEL_UNDEFINED
;
int8_t
mMovementStyle
=
0
;
}
;
Caret
mCaret
;
nsBidiLevel
mKbdBidiLevel
=
NSBIDI_LTR
;
struct
DesiredPos
{
nsPoint
mValue
;
bool
mIsSet
=
false
;
}
;
DesiredPos
mDesiredPos
;
struct
DelayedMouseEvent
{
bool
mIsValid
=
false
;
bool
mIsShift
=
false
;
uint32_t
mClickCount
=
0
;
}
;
DelayedMouseEvent
mDelayedMouseEvent
;
bool
mDragState
=
false
;
bool
mAccessibleCaretEnabled
=
false
;
static
bool
sSelectionEventsOnTextControlsEnabled
;
}
;
#
endif
