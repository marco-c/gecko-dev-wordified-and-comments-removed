#
include
"
nsFlexContainerFrame
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCSSAnonBoxes
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsPlaceholderFrame
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsRenderingContext
.
h
"
#
include
"
nsStyleContext
.
h
"
#
include
"
mozilla
/
CSSOrderAwareFrameIterator
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
<
algorithm
>
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
WritingModes
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
layout
;
typedef
nsFlexContainerFrame
:
:
FlexItem
FlexItem
;
typedef
nsFlexContainerFrame
:
:
FlexLine
FlexLine
;
typedef
nsFlexContainerFrame
:
:
FlexboxAxisTracker
FlexboxAxisTracker
;
typedef
nsFlexContainerFrame
:
:
StrutInfo
StrutInfo
;
typedef
nsFlexContainerFrame
:
:
CachedMeasuringReflowResult
CachedMeasuringReflowResult
;
static
mozilla
:
:
LazyLogModule
gFlexContainerLog
(
"
nsFlexContainerFrame
"
)
;
enum
AxisOrientationType
{
eAxis_LR
eAxis_RL
eAxis_TB
eAxis_BT
eNumAxisOrientationTypes
}
;
enum
AxisEdgeType
{
eAxisEdge_Start
eAxisEdge_End
eNumAxisEdges
}
;
static
const
mozilla
:
:
Side
kAxisOrientationToSidesMap
[
eNumAxisOrientationTypes
]
[
eNumAxisEdges
]
=
{
{
eSideLeft
eSideRight
}
{
eSideRight
eSideLeft
}
{
eSideTop
eSideBottom
}
{
eSideBottom
eSideTop
}
}
;
static
inline
bool
IsDisplayValueLegacyBox
(
const
nsStyleDisplay
*
aStyleDisp
)
{
return
aStyleDisp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
WebkitBox
|
|
aStyleDisp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
WebkitInlineBox
;
}
static
bool
IsLegacyBox
(
const
nsIFrame
*
aFlexContainer
)
{
MOZ_ASSERT
(
aFlexContainer
-
>
GetType
(
)
=
=
nsGkAtoms
:
:
flexContainerFrame
"
only
flex
containers
may
be
passed
to
this
function
"
)
;
return
aFlexContainer
-
>
HasAnyStateBits
(
NS_STATE_FLEX_IS_LEGACY_WEBKIT_BOX
)
;
}
static
CSSOrderAwareFrameIterator
:
:
OrderingProperty
OrderingPropertyForIter
(
const
nsFlexContainerFrame
*
aFlexContainer
)
{
return
IsLegacyBox
(
aFlexContainer
)
?
CSSOrderAwareFrameIterator
:
:
OrderingProperty
:
:
eUseBoxOrdinalGroup
:
CSSOrderAwareFrameIterator
:
:
OrderingProperty
:
:
eUseOrder
;
}
static
uint8_t
ConvertLegacyStyleToAlignItems
(
const
nsStyleXUL
*
aStyleXUL
)
{
switch
(
aStyleXUL
-
>
mBoxAlign
)
{
case
StyleBoxAlign
:
:
Stretch
:
return
NS_STYLE_ALIGN_STRETCH
;
case
StyleBoxAlign
:
:
Start
:
return
NS_STYLE_ALIGN_FLEX_START
;
case
StyleBoxAlign
:
:
Center
:
return
NS_STYLE_ALIGN_CENTER
;
case
StyleBoxAlign
:
:
Baseline
:
return
NS_STYLE_ALIGN_BASELINE
;
case
StyleBoxAlign
:
:
End
:
return
NS_STYLE_ALIGN_FLEX_END
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
mBoxAlign
enum
value
"
)
;
return
NS_STYLE_ALIGN_STRETCH
;
}
static
uint8_t
ConvertLegacyStyleToJustifyContent
(
const
nsStyleXUL
*
aStyleXUL
)
{
switch
(
aStyleXUL
-
>
mBoxPack
)
{
case
StyleBoxPack
:
:
Start
:
return
NS_STYLE_ALIGN_FLEX_START
;
case
StyleBoxPack
:
:
Center
:
return
NS_STYLE_ALIGN_CENTER
;
case
StyleBoxPack
:
:
End
:
return
NS_STYLE_ALIGN_FLEX_END
;
case
StyleBoxPack
:
:
Justify
:
return
NS_STYLE_ALIGN_SPACE_BETWEEN
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
mBoxPack
enum
value
"
)
;
return
NS_STYLE_ALIGN_FLEX_START
;
}
static
inline
bool
AxisGrowsInPositiveDirection
(
AxisOrientationType
aAxis
)
{
return
eAxis_LR
=
=
aAxis
|
|
eAxis_TB
=
=
aAxis
;
}
static
inline
AxisOrientationType
GetReverseAxis
(
AxisOrientationType
aAxis
)
{
AxisOrientationType
reversedAxis
;
if
(
aAxis
%
2
=
=
0
)
{
reversedAxis
=
AxisOrientationType
(
aAxis
+
1
)
;
}
else
{
reversedAxis
=
AxisOrientationType
(
aAxis
-
1
)
;
}
MOZ_ASSERT
(
reversedAxis
>
=
eAxis_LR
&
&
reversedAxis
<
=
eAxis_BT
)
;
return
reversedAxis
;
}
static
nscoord
PhysicalCoordFromFlexRelativeCoord
(
nscoord
aFlexRelativeCoord
nscoord
aContainerSize
AxisOrientationType
aAxis
)
{
if
(
AxisGrowsInPositiveDirection
(
aAxis
)
)
{
return
aFlexRelativeCoord
;
}
return
aContainerSize
-
aFlexRelativeCoord
;
}
#
define
GET_MAIN_COMPONENT
(
axisTracker_
width_
height_
)
\
(
axisTracker_
)
.
IsMainAxisHorizontal
(
)
?
(
width_
)
:
(
height_
)
#
define
GET_CROSS_COMPONENT
(
axisTracker_
width_
height_
)
\
(
axisTracker_
)
.
IsCrossAxisHorizontal
(
)
?
(
width_
)
:
(
height_
)
#
define
GET_MAIN_COMPONENT_LOGICAL
(
axisTracker_
wm_
isize_
bsize_
)
\
wm_
.
IsOrthogonalTo
(
axisTracker_
.
GetWritingMode
(
)
)
!
=
\
(
axisTracker_
)
.
IsRowOriented
(
)
?
(
isize_
)
:
(
bsize_
)
#
define
GET_CROSS_COMPONENT_LOGICAL
(
axisTracker_
wm_
isize_
bsize_
)
\
wm_
.
IsOrthogonalTo
(
axisTracker_
.
GetWritingMode
(
)
)
!
=
\
(
axisTracker_
)
.
IsRowOriented
(
)
?
(
bsize_
)
:
(
isize_
)
enum
AxisTrackerFlags
{
eNoFlags
=
0x0
eAllowBottomToTopChildOrdering
=
0x1
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
AxisTrackerFlags
)
class
MOZ_STACK_CLASS
nsFlexContainerFrame
:
:
FlexboxAxisTracker
{
public
:
FlexboxAxisTracker
(
const
nsFlexContainerFrame
*
aFlexContainer
const
WritingMode
&
aWM
AxisTrackerFlags
aFlags
=
eNoFlags
)
;
AxisOrientationType
GetMainAxis
(
)
const
{
return
mMainAxis
;
}
AxisOrientationType
GetCrossAxis
(
)
const
{
return
mCrossAxis
;
}
bool
IsMainAxisHorizontal
(
)
const
{
return
mIsRowOriented
!
=
mWM
.
IsVertical
(
)
;
}
bool
IsCrossAxisHorizontal
(
)
const
{
return
!
IsMainAxisHorizontal
(
)
;
}
WritingMode
GetWritingMode
(
)
const
{
return
mWM
;
}
bool
IsMainAxisReversed
(
)
const
{
return
mIsMainAxisReversed
;
}
bool
IsCrossAxisReversed
(
)
const
{
return
mIsCrossAxisReversed
;
}
bool
IsRowOriented
(
)
const
{
return
mIsRowOriented
;
}
bool
IsColumnOriented
(
)
const
{
return
!
mIsRowOriented
;
}
nscoord
GetMainComponent
(
const
nsSize
&
aSize
)
const
{
return
GET_MAIN_COMPONENT
(
*
this
aSize
.
width
aSize
.
height
)
;
}
int32_t
GetMainComponent
(
const
LayoutDeviceIntSize
&
aIntSize
)
const
{
return
GET_MAIN_COMPONENT
(
*
this
aIntSize
.
width
aIntSize
.
height
)
;
}
nscoord
GetCrossComponent
(
const
nsSize
&
aSize
)
const
{
return
GET_CROSS_COMPONENT
(
*
this
aSize
.
width
aSize
.
height
)
;
}
int32_t
GetCrossComponent
(
const
LayoutDeviceIntSize
&
aIntSize
)
const
{
return
GET_CROSS_COMPONENT
(
*
this
aIntSize
.
width
aIntSize
.
height
)
;
}
nscoord
GetMarginSizeInMainAxis
(
const
nsMargin
&
aMargin
)
const
{
return
IsMainAxisHorizontal
(
)
?
aMargin
.
LeftRight
(
)
:
aMargin
.
TopBottom
(
)
;
}
nscoord
GetMarginSizeInCrossAxis
(
const
nsMargin
&
aMargin
)
const
{
return
IsCrossAxisHorizontal
(
)
?
aMargin
.
LeftRight
(
)
:
aMargin
.
TopBottom
(
)
;
}
const
nsStyleCoord
&
ComputedCrossSize
(
const
nsIFrame
*
aFrame
)
const
{
const
nsStylePosition
*
stylePos
=
aFrame
-
>
StylePosition
(
)
;
return
IsCrossAxisHorizontal
(
)
?
stylePos
-
>
mWidth
:
stylePos
-
>
mHeight
;
}
LogicalPoint
LogicalPointFromFlexRelativePoint
(
nscoord
aMainCoord
nscoord
aCrossCoord
nscoord
aContainerMainSize
nscoord
aContainerCrossSize
)
const
{
nscoord
logicalCoordInMainAxis
=
mIsMainAxisReversed
?
aContainerMainSize
-
aMainCoord
:
aMainCoord
;
nscoord
logicalCoordInCrossAxis
=
mIsCrossAxisReversed
?
aContainerCrossSize
-
aCrossCoord
:
aCrossCoord
;
return
mIsRowOriented
?
LogicalPoint
(
mWM
logicalCoordInMainAxis
logicalCoordInCrossAxis
)
:
LogicalPoint
(
mWM
logicalCoordInCrossAxis
logicalCoordInMainAxis
)
;
}
LogicalSize
LogicalSizeFromFlexRelativeSizes
(
nscoord
aMainSize
nscoord
aCrossSize
)
const
{
return
mIsRowOriented
?
LogicalSize
(
mWM
aMainSize
aCrossSize
)
:
LogicalSize
(
mWM
aCrossSize
aMainSize
)
;
}
bool
AreAxesInternallyReversed
(
)
const
{
return
mAreAxesInternallyReversed
;
}
private
:
FlexboxAxisTracker
(
const
FlexboxAxisTracker
&
)
=
delete
;
FlexboxAxisTracker
&
operator
=
(
const
FlexboxAxisTracker
&
)
=
delete
;
void
InitAxesFromLegacyProps
(
const
nsFlexContainerFrame
*
aFlexContainer
)
;
void
InitAxesFromModernProps
(
const
nsFlexContainerFrame
*
aFlexContainer
)
;
AxisOrientationType
mMainAxis
;
AxisOrientationType
mCrossAxis
;
const
WritingMode
mWM
;
bool
mIsRowOriented
;
bool
mIsMainAxisReversed
;
bool
mIsCrossAxisReversed
;
bool
mAreAxesInternallyReversed
;
}
;
class
nsFlexContainerFrame
:
:
FlexItem
:
public
LinkedListElement
<
FlexItem
>
{
public
:
FlexItem
(
ReflowInput
&
aFlexItemReflowInput
float
aFlexGrow
float
aFlexShrink
nscoord
aMainBaseSize
nscoord
aMainMinSize
nscoord
aMainMaxSize
nscoord
aTentativeCrossSize
nscoord
aCrossMinSize
nscoord
aCrossMaxSize
const
FlexboxAxisTracker
&
aAxisTracker
)
;
FlexItem
(
nsIFrame
*
aChildFrame
nscoord
aCrossSize
WritingMode
aContainerWM
)
;
nsIFrame
*
Frame
(
)
const
{
return
mFrame
;
}
nscoord
GetFlexBaseSize
(
)
const
{
return
mFlexBaseSize
;
}
nscoord
GetMainMinSize
(
)
const
{
MOZ_ASSERT
(
!
mNeedsMinSizeAutoResolution
"
Someone
'
s
using
an
unresolved
'
auto
'
main
min
-
size
"
)
;
return
mMainMinSize
;
}
nscoord
GetMainMaxSize
(
)
const
{
return
mMainMaxSize
;
}
nscoord
GetMainSize
(
)
const
{
return
mMainSize
;
}
nscoord
GetMainPosition
(
)
const
{
return
mMainPosn
;
}
nscoord
GetCrossMinSize
(
)
const
{
return
mCrossMinSize
;
}
nscoord
GetCrossMaxSize
(
)
const
{
return
mCrossMaxSize
;
}
nscoord
GetCrossSize
(
)
const
{
return
mCrossSize
;
}
nscoord
GetCrossPosition
(
)
const
{
return
mCrossPosn
;
}
nscoord
ResolvedAscent
(
bool
aUseFirstBaseline
)
const
{
if
(
mAscent
=
=
ReflowOutput
:
:
ASK_FOR_BASELINE
)
{
bool
found
=
aUseFirstBaseline
?
nsLayoutUtils
:
:
GetFirstLineBaseline
(
mWM
mFrame
&
mAscent
)
:
nsLayoutUtils
:
:
GetLastLineBaseline
(
mWM
mFrame
&
mAscent
)
;
if
(
!
found
)
{
mAscent
=
mFrame
-
>
SynthesizeBaselineBOffsetFromBorderBox
(
mWM
BaselineSharingGroup
:
:
eFirst
)
;
}
}
return
mAscent
;
}
nscoord
GetOuterMainSize
(
AxisOrientationType
aMainAxis
)
const
{
return
mMainSize
+
GetMarginBorderPaddingSizeInAxis
(
aMainAxis
)
;
}
nscoord
GetOuterCrossSize
(
AxisOrientationType
aCrossAxis
)
const
{
return
mCrossSize
+
GetMarginBorderPaddingSizeInAxis
(
aCrossAxis
)
;
}
nscoord
GetBaselineOffsetFromOuterCrossEdge
(
AxisEdgeType
aEdge
const
FlexboxAxisTracker
&
aAxisTracker
bool
aUseFirstLineBaseline
)
const
;
float
GetShareOfWeightSoFar
(
)
const
{
return
mShareOfWeightSoFar
;
}
bool
IsFrozen
(
)
const
{
return
mIsFrozen
;
}
bool
HadMinViolation
(
)
const
{
return
mHadMinViolation
;
}
bool
HadMaxViolation
(
)
const
{
return
mHadMaxViolation
;
}
bool
HadMeasuringReflow
(
)
const
{
return
mHadMeasuringReflow
;
}
bool
IsStretched
(
)
const
{
return
mIsStretched
;
}
bool
NeedsMinSizeAutoResolution
(
)
const
{
return
mNeedsMinSizeAutoResolution
;
}
bool
IsStrut
(
)
const
{
return
mIsStrut
;
}
WritingMode
GetWritingMode
(
)
const
{
return
mWM
;
}
uint8_t
GetAlignSelf
(
)
const
{
return
mAlignSelf
;
}
float
GetFlexFactor
(
bool
aIsUsingFlexGrow
)
{
MOZ_ASSERT
(
!
IsFrozen
(
)
"
shouldn
'
t
need
flex
factor
after
item
is
frozen
"
)
;
return
aIsUsingFlexGrow
?
mFlexGrow
:
mFlexShrink
;
}
float
GetWeight
(
bool
aIsUsingFlexGrow
)
{
MOZ_ASSERT
(
!
IsFrozen
(
)
"
shouldn
'
t
need
weight
after
item
is
frozen
"
)
;
if
(
aIsUsingFlexGrow
)
{
return
mFlexGrow
;
}
if
(
mFlexBaseSize
=
=
0
)
{
return
0
.
0f
;
}
return
mFlexShrink
*
mFlexBaseSize
;
}
const
nsSize
&
IntrinsicRatio
(
)
const
{
return
mIntrinsicRatio
;
}
bool
HasIntrinsicRatio
(
)
const
{
return
mIntrinsicRatio
!
=
nsSize
(
)
;
}
const
nsMargin
&
GetMargin
(
)
const
{
return
mMargin
;
}
nscoord
GetMarginComponentForSide
(
mozilla
:
:
Side
aSide
)
const
{
return
mMargin
.
Side
(
aSide
)
;
}
nscoord
GetMarginSizeInAxis
(
AxisOrientationType
aAxis
)
const
{
mozilla
:
:
Side
startSide
=
kAxisOrientationToSidesMap
[
aAxis
]
[
eAxisEdge_Start
]
;
mozilla
:
:
Side
endSide
=
kAxisOrientationToSidesMap
[
aAxis
]
[
eAxisEdge_End
]
;
return
GetMarginComponentForSide
(
startSide
)
+
GetMarginComponentForSide
(
endSide
)
;
}
const
nsMargin
&
GetBorderPadding
(
)
const
{
return
mBorderPadding
;
}
nscoord
GetBorderPaddingComponentForSide
(
mozilla
:
:
Side
aSide
)
const
{
return
mBorderPadding
.
Side
(
aSide
)
;
}
nscoord
GetBorderPaddingSizeInAxis
(
AxisOrientationType
aAxis
)
const
{
mozilla
:
:
Side
startSide
=
kAxisOrientationToSidesMap
[
aAxis
]
[
eAxisEdge_Start
]
;
mozilla
:
:
Side
endSide
=
kAxisOrientationToSidesMap
[
aAxis
]
[
eAxisEdge_End
]
;
return
GetBorderPaddingComponentForSide
(
startSide
)
+
GetBorderPaddingComponentForSide
(
endSide
)
;
}
nscoord
GetMarginBorderPaddingSizeInAxis
(
AxisOrientationType
aAxis
)
const
{
return
GetMarginSizeInAxis
(
aAxis
)
+
GetBorderPaddingSizeInAxis
(
aAxis
)
;
}
void
UpdateMainMinSize
(
nscoord
aNewMinSize
)
{
NS_ASSERTION
(
aNewMinSize
>
=
0
"
How
did
we
end
up
with
a
negative
min
-
size
?
"
)
;
MOZ_ASSERT
(
mMainMaxSize
>
=
aNewMinSize
"
Should
only
use
this
function
for
resolving
min
-
size
:
auto
"
"
and
main
max
-
size
should
be
an
upper
-
bound
for
resolved
val
"
)
;
MOZ_ASSERT
(
mNeedsMinSizeAutoResolution
&
&
(
mMainMinSize
=
=
0
|
|
mFrame
-
>
IsThemed
(
mFrame
-
>
StyleDisplay
(
)
)
)
"
Should
only
use
this
function
for
resolving
min
-
size
:
auto
"
"
so
we
shouldn
'
t
already
have
a
nonzero
min
-
size
established
"
"
(
unless
it
'
s
a
themed
-
widget
-
imposed
minimum
size
)
"
)
;
if
(
aNewMinSize
>
mMainMinSize
)
{
mMainMinSize
=
aNewMinSize
;
mMainSize
=
std
:
:
max
(
mMainSize
aNewMinSize
)
;
}
mNeedsMinSizeAutoResolution
=
false
;
}
void
SetFlexBaseSizeAndMainSize
(
nscoord
aNewFlexBaseSize
)
{
MOZ_ASSERT
(
!
mIsFrozen
|
|
mFlexBaseSize
=
=
NS_INTRINSICSIZE
"
flex
base
size
shouldn
'
t
change
after
we
'
re
frozen
"
"
(
unless
we
'
re
just
resolving
an
intrinsic
size
)
"
)
;
mFlexBaseSize
=
aNewFlexBaseSize
;
mMainSize
=
NS_CSS_MINMAX
(
mFlexBaseSize
mMainMinSize
mMainMaxSize
)
;
}
void
SetMainSize
(
nscoord
aNewMainSize
)
{
MOZ_ASSERT
(
!
mIsFrozen
"
main
size
shouldn
'
t
change
after
we
'
re
frozen
"
)
;
mMainSize
=
aNewMainSize
;
}
void
SetShareOfWeightSoFar
(
float
aNewShare
)
{
MOZ_ASSERT
(
!
mIsFrozen
|
|
aNewShare
=
=
0
.
0f
"
shouldn
'
t
be
giving
this
item
any
share
of
the
weight
"
"
after
it
'
s
frozen
"
)
;
mShareOfWeightSoFar
=
aNewShare
;
}
void
Freeze
(
)
{
mIsFrozen
=
true
;
}
void
SetHadMinViolation
(
)
{
MOZ_ASSERT
(
!
mIsFrozen
"
shouldn
'
t
be
changing
main
size
&
having
violations
"
"
after
we
'
re
frozen
"
)
;
mHadMinViolation
=
true
;
}
void
SetHadMaxViolation
(
)
{
MOZ_ASSERT
(
!
mIsFrozen
"
shouldn
'
t
be
changing
main
size
&
having
violations
"
"
after
we
'
re
frozen
"
)
;
mHadMaxViolation
=
true
;
}
void
ClearViolationFlags
(
)
{
mHadMinViolation
=
mHadMaxViolation
=
false
;
}
void
SetMainPosition
(
nscoord
aPosn
)
{
MOZ_ASSERT
(
mIsFrozen
"
main
size
should
be
resolved
before
this
"
)
;
mMainPosn
=
aPosn
;
}
void
SetCrossSize
(
nscoord
aCrossSize
)
{
MOZ_ASSERT
(
!
mIsStretched
"
Cross
size
shouldn
'
t
be
modified
after
it
'
s
been
stretched
"
)
;
mCrossSize
=
aCrossSize
;
}
void
SetCrossPosition
(
nscoord
aPosn
)
{
MOZ_ASSERT
(
mIsFrozen
"
main
size
should
be
resolved
before
this
"
)
;
mCrossPosn
=
aPosn
;
}
void
SetAscent
(
nscoord
aAscent
)
const
{
mAscent
=
aAscent
;
}
void
SetHadMeasuringReflow
(
)
{
mHadMeasuringReflow
=
true
;
}
void
SetIsStretched
(
)
{
MOZ_ASSERT
(
mIsFrozen
"
main
size
should
be
resolved
before
this
"
)
;
mIsStretched
=
true
;
}
void
SetMarginComponentForSide
(
mozilla
:
:
Side
aSide
nscoord
aLength
)
{
MOZ_ASSERT
(
mIsFrozen
"
main
size
should
be
resolved
before
this
"
)
;
mMargin
.
Side
(
aSide
)
=
aLength
;
}
void
ResolveStretchedCrossSize
(
nscoord
aLineCrossSize
const
FlexboxAxisTracker
&
aAxisTracker
)
;
uint32_t
GetNumAutoMarginsInAxis
(
AxisOrientationType
aAxis
)
const
;
bool
CanMainSizeInfluenceCrossSize
(
const
FlexboxAxisTracker
&
aAxisTracker
)
const
;
protected
:
void
CheckForMinSizeAuto
(
const
ReflowInput
&
aFlexItemReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
)
;
nsIFrame
*
const
mFrame
;
const
float
mFlexGrow
;
const
float
mFlexShrink
;
const
nsSize
mIntrinsicRatio
;
const
nsMargin
mBorderPadding
;
nsMargin
mMargin
;
nscoord
mFlexBaseSize
;
nscoord
mMainMinSize
;
nscoord
mMainMaxSize
;
const
nscoord
mCrossMinSize
;
const
nscoord
mCrossMaxSize
;
nscoord
mMainSize
;
nscoord
mMainPosn
;
nscoord
mCrossSize
;
nscoord
mCrossPosn
;
mutable
nscoord
mAscent
;
float
mShareOfWeightSoFar
;
bool
mIsFrozen
;
bool
mHadMinViolation
;
bool
mHadMaxViolation
;
bool
mHadMeasuringReflow
;
bool
mIsStretched
;
bool
mIsStrut
;
bool
mNeedsMinSizeAutoResolution
;
const
WritingMode
mWM
;
uint8_t
mAlignSelf
;
}
;
class
nsFlexContainerFrame
:
:
FlexLine
:
public
LinkedListElement
<
FlexLine
>
{
public
:
FlexLine
(
)
:
mNumItems
(
0
)
mNumFrozenItems
(
0
)
mTotalInnerHypotheticalMainSize
(
0
)
mTotalOuterHypotheticalMainSize
(
0
)
mLineCrossSize
(
0
)
mFirstBaselineOffset
(
nscoord_MIN
)
mLastBaselineOffset
(
nscoord_MIN
)
{
}
nscoord
GetTotalOuterHypotheticalMainSize
(
)
const
{
return
mTotalOuterHypotheticalMainSize
;
}
FlexItem
*
GetFirstItem
(
)
{
MOZ_ASSERT
(
mItems
.
isEmpty
(
)
=
=
(
mNumItems
=
=
0
)
"
mNumItems
bookkeeping
is
off
"
)
;
return
mItems
.
getFirst
(
)
;
}
const
FlexItem
*
GetFirstItem
(
)
const
{
MOZ_ASSERT
(
mItems
.
isEmpty
(
)
=
=
(
mNumItems
=
=
0
)
"
mNumItems
bookkeeping
is
off
"
)
;
return
mItems
.
getFirst
(
)
;
}
FlexItem
*
GetLastItem
(
)
{
MOZ_ASSERT
(
mItems
.
isEmpty
(
)
=
=
(
mNumItems
=
=
0
)
"
mNumItems
bookkeeping
is
off
"
)
;
return
mItems
.
getLast
(
)
;
}
const
FlexItem
*
GetLastItem
(
)
const
{
MOZ_ASSERT
(
mItems
.
isEmpty
(
)
=
=
(
mNumItems
=
=
0
)
"
mNumItems
bookkeeping
is
off
"
)
;
return
mItems
.
getLast
(
)
;
}
bool
IsEmpty
(
)
const
{
MOZ_ASSERT
(
mItems
.
isEmpty
(
)
=
=
(
mNumItems
=
=
0
)
"
mNumItems
bookkeeping
is
off
"
)
;
return
mItems
.
isEmpty
(
)
;
}
uint32_t
NumItems
(
)
const
{
MOZ_ASSERT
(
mItems
.
isEmpty
(
)
=
=
(
mNumItems
=
=
0
)
"
mNumItems
bookkeeping
is
off
"
)
;
return
mNumItems
;
}
void
AddItem
(
FlexItem
*
aItem
bool
aShouldInsertAtFront
nscoord
aItemInnerHypotheticalMainSize
nscoord
aItemOuterHypotheticalMainSize
)
{
if
(
aShouldInsertAtFront
)
{
mItems
.
insertFront
(
aItem
)
;
}
else
{
mItems
.
insertBack
(
aItem
)
;
}
mNumItems
+
+
;
if
(
aItem
-
>
IsFrozen
(
)
)
{
mNumFrozenItems
+
+
;
}
mTotalInnerHypotheticalMainSize
+
=
aItemInnerHypotheticalMainSize
;
mTotalOuterHypotheticalMainSize
+
=
aItemOuterHypotheticalMainSize
;
}
void
ComputeCrossSizeAndBaseline
(
const
FlexboxAxisTracker
&
aAxisTracker
)
;
nscoord
GetLineCrossSize
(
)
const
{
return
mLineCrossSize
;
}
void
SetLineCrossSize
(
nscoord
aLineCrossSize
)
{
mLineCrossSize
=
aLineCrossSize
;
}
nscoord
GetFirstBaselineOffset
(
)
const
{
return
mFirstBaselineOffset
;
}
nscoord
GetLastBaselineOffset
(
)
const
{
return
mLastBaselineOffset
;
}
void
ResolveFlexibleLengths
(
nscoord
aFlexContainerMainSize
)
;
void
PositionItemsInMainAxis
(
uint8_t
aJustifyContent
nscoord
aContentBoxMainSize
const
FlexboxAxisTracker
&
aAxisTracker
)
;
void
PositionItemsInCrossAxis
(
nscoord
aLineStartPosition
const
FlexboxAxisTracker
&
aAxisTracker
)
;
friend
class
AutoFlexLineListClearer
;
private
:
void
FreezeItemsEarly
(
bool
aIsUsingFlexGrow
)
;
void
FreezeOrRestoreEachFlexibleSize
(
const
nscoord
aTotalViolation
bool
aIsFinalIteration
)
;
LinkedList
<
FlexItem
>
mItems
;
uint32_t
mNumItems
;
uint32_t
mNumFrozenItems
;
nscoord
mTotalInnerHypotheticalMainSize
;
nscoord
mTotalOuterHypotheticalMainSize
;
nscoord
mLineCrossSize
;
nscoord
mFirstBaselineOffset
;
nscoord
mLastBaselineOffset
;
}
;
struct
nsFlexContainerFrame
:
:
StrutInfo
{
StrutInfo
(
uint32_t
aItemIdx
nscoord
aStrutCrossSize
)
:
mItemIdx
(
aItemIdx
)
mStrutCrossSize
(
aStrutCrossSize
)
{
}
uint32_t
mItemIdx
;
nscoord
mStrutCrossSize
;
}
;
static
void
BuildStrutInfoFromCollapsedItems
(
const
FlexLine
*
aFirstLine
nsTArray
<
StrutInfo
>
&
aStruts
)
{
MOZ_ASSERT
(
aFirstLine
"
null
first
line
pointer
"
)
;
MOZ_ASSERT
(
aStruts
.
IsEmpty
(
)
"
We
should
only
build
up
StrutInfo
once
per
reflow
so
"
"
aStruts
should
be
empty
when
this
is
called
"
)
;
uint32_t
itemIdxInContainer
=
0
;
for
(
const
FlexLine
*
line
=
aFirstLine
;
line
;
line
=
line
-
>
getNext
(
)
)
{
for
(
const
FlexItem
*
item
=
line
-
>
GetFirstItem
(
)
;
item
;
item
=
item
-
>
getNext
(
)
)
{
if
(
NS_STYLE_VISIBILITY_COLLAPSE
=
=
item
-
>
Frame
(
)
-
>
StyleVisibility
(
)
-
>
mVisible
)
{
aStruts
.
AppendElement
(
StrutInfo
(
itemIdxInContainer
line
-
>
GetLineCrossSize
(
)
)
)
;
}
itemIdxInContainer
+
+
;
}
}
}
uint8_t
SimplifyAlignOrJustifyContentForOneItem
(
uint16_t
aAlignmentVal
bool
aIsAlign
)
{
uint16_t
specified
=
aAlignmentVal
&
NS_STYLE_ALIGN_ALL_BITS
;
specified
&
=
~
NS_STYLE_ALIGN_FLAG_BITS
;
if
(
specified
=
=
NS_STYLE_ALIGN_NORMAL
)
{
specified
=
NS_STYLE_ALIGN_STRETCH
;
}
if
(
!
aIsAlign
&
&
specified
=
=
NS_STYLE_ALIGN_STRETCH
)
{
return
NS_STYLE_ALIGN_FLEX_START
;
}
uint16_t
explicitFallback
=
aAlignmentVal
>
>
NS_STYLE_ALIGN_ALL_SHIFT
;
if
(
explicitFallback
)
{
explicitFallback
&
=
~
NS_STYLE_ALIGN_FLAG_BITS
;
return
explicitFallback
;
}
switch
(
specified
)
{
case
NS_STYLE_ALIGN_SPACE_BETWEEN
:
return
NS_STYLE_ALIGN_START
;
case
NS_STYLE_ALIGN_SPACE_AROUND
:
case
NS_STYLE_ALIGN_SPACE_EVENLY
:
return
NS_STYLE_ALIGN_CENTER
;
default
:
return
specified
;
}
}
uint16_t
nsFlexContainerFrame
:
:
CSSAlignmentForAbsPosChild
(
const
ReflowInput
&
aChildRI
LogicalAxis
aLogicalAxis
)
const
{
WritingMode
wm
=
GetWritingMode
(
)
;
const
FlexboxAxisTracker
axisTracker
(
this
wm
AxisTrackerFlags
:
:
eAllowBottomToTopChildOrdering
)
;
const
bool
isMainAxis
=
(
axisTracker
.
IsRowOriented
(
)
=
=
(
aLogicalAxis
=
=
eLogicalAxisInline
)
)
;
const
nsStylePosition
*
containerStylePos
=
StylePosition
(
)
;
const
bool
isAxisReversed
=
isMainAxis
?
axisTracker
.
IsMainAxisReversed
(
)
:
axisTracker
.
IsCrossAxisReversed
(
)
;
uint8_t
alignment
;
if
(
isMainAxis
)
{
alignment
=
SimplifyAlignOrJustifyContentForOneItem
(
containerStylePos
-
>
mJustifyContent
false
)
;
}
else
{
const
uint8_t
alignContent
=
SimplifyAlignOrJustifyContentForOneItem
(
containerStylePos
-
>
mAlignContent
true
)
;
if
(
NS_STYLE_FLEX_WRAP_NOWRAP
!
=
containerStylePos
-
>
mFlexWrap
&
&
alignContent
!
=
NS_STYLE_ALIGN_STRETCH
)
{
alignment
=
alignContent
;
}
else
{
alignment
=
aChildRI
.
mStylePosition
-
>
UsedAlignSelf
(
StyleContext
(
)
)
;
alignment
&
=
~
NS_STYLE_ALIGN_FLAG_BITS
;
if
(
alignment
=
=
NS_STYLE_ALIGN_NORMAL
)
{
alignment
=
aChildRI
.
mFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eReplaced
)
?
NS_STYLE_ALIGN_START
:
NS_STYLE_ALIGN_STRETCH
;
}
}
}
if
(
alignment
=
=
NS_STYLE_ALIGN_FLEX_START
)
{
alignment
=
isAxisReversed
?
NS_STYLE_ALIGN_END
:
NS_STYLE_ALIGN_START
;
}
else
if
(
alignment
=
=
NS_STYLE_ALIGN_FLEX_END
)
{
alignment
=
isAxisReversed
?
NS_STYLE_ALIGN_START
:
NS_STYLE_ALIGN_END
;
}
else
if
(
alignment
=
=
NS_STYLE_ALIGN_LEFT
|
|
alignment
=
=
NS_STYLE_ALIGN_RIGHT
)
{
if
(
aLogicalAxis
=
=
eLogicalAxisInline
)
{
const
bool
isLeft
=
(
alignment
=
=
NS_STYLE_ALIGN_LEFT
)
;
alignment
=
(
isLeft
=
=
wm
.
IsBidiLTR
(
)
)
?
NS_STYLE_ALIGN_START
:
NS_STYLE_ALIGN_END
;
}
else
{
alignment
=
NS_STYLE_ALIGN_START
;
}
}
else
if
(
alignment
=
=
NS_STYLE_ALIGN_BASELINE
)
{
alignment
=
NS_STYLE_ALIGN_START
;
}
else
if
(
alignment
=
=
NS_STYLE_ALIGN_LAST_BASELINE
)
{
alignment
=
NS_STYLE_ALIGN_END
;
}
return
alignment
;
}
bool
nsFlexContainerFrame
:
:
IsHorizontal
(
)
{
const
FlexboxAxisTracker
axisTracker
(
this
GetWritingMode
(
)
)
;
return
axisTracker
.
IsMainAxisHorizontal
(
)
;
}
UniquePtr
<
FlexItem
>
nsFlexContainerFrame
:
:
GenerateFlexItemForChild
(
nsPresContext
*
aPresContext
nsIFrame
*
aChildFrame
const
ReflowInput
&
aParentReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
)
{
ReflowInput
childRI
(
aPresContext
aParentReflowInput
aChildFrame
aParentReflowInput
.
ComputedSize
(
aChildFrame
-
>
GetWritingMode
(
)
)
)
;
float
flexGrow
flexShrink
;
if
(
IsLegacyBox
(
this
)
)
{
flexGrow
=
flexShrink
=
aChildFrame
-
>
StyleXUL
(
)
-
>
mBoxFlex
;
}
else
{
const
nsStylePosition
*
stylePos
=
aChildFrame
-
>
StylePosition
(
)
;
flexGrow
=
stylePos
-
>
mFlexGrow
;
flexShrink
=
stylePos
-
>
mFlexShrink
;
}
WritingMode
childWM
=
childRI
.
GetWritingMode
(
)
;
nscoord
flexBaseSize
=
GET_MAIN_COMPONENT_LOGICAL
(
aAxisTracker
childWM
childRI
.
ComputedISize
(
)
childRI
.
ComputedBSize
(
)
)
;
nscoord
mainMinSize
=
GET_MAIN_COMPONENT_LOGICAL
(
aAxisTracker
childWM
childRI
.
ComputedMinISize
(
)
childRI
.
ComputedMinBSize
(
)
)
;
nscoord
mainMaxSize
=
GET_MAIN_COMPONENT_LOGICAL
(
aAxisTracker
childWM
childRI
.
ComputedMaxISize
(
)
childRI
.
ComputedMaxBSize
(
)
)
;
MOZ_ASSERT
(
mainMinSize
<
=
mainMaxSize
"
min
size
is
larger
than
max
size
"
)
;
nscoord
tentativeCrossSize
=
GET_CROSS_COMPONENT_LOGICAL
(
aAxisTracker
childWM
childRI
.
ComputedISize
(
)
childRI
.
ComputedBSize
(
)
)
;
nscoord
crossMinSize
=
GET_CROSS_COMPONENT_LOGICAL
(
aAxisTracker
childWM
childRI
.
ComputedMinISize
(
)
childRI
.
ComputedMinBSize
(
)
)
;
nscoord
crossMaxSize
=
GET_CROSS_COMPONENT_LOGICAL
(
aAxisTracker
childWM
childRI
.
ComputedMaxISize
(
)
childRI
.
ComputedMaxBSize
(
)
)
;
bool
isFixedSizeWidget
=
false
;
const
nsStyleDisplay
*
disp
=
aChildFrame
-
>
StyleDisplay
(
)
;
if
(
aChildFrame
-
>
IsThemed
(
disp
)
)
{
LayoutDeviceIntSize
widgetMinSize
;
bool
canOverride
=
true
;
aPresContext
-
>
GetTheme
(
)
-
>
GetMinimumWidgetSize
(
aPresContext
aChildFrame
disp
-
>
UsedAppearance
(
)
&
widgetMinSize
&
canOverride
)
;
nscoord
widgetMainMinSize
=
aPresContext
-
>
DevPixelsToAppUnits
(
aAxisTracker
.
GetMainComponent
(
widgetMinSize
)
)
;
nscoord
widgetCrossMinSize
=
aPresContext
-
>
DevPixelsToAppUnits
(
aAxisTracker
.
GetCrossComponent
(
widgetMinSize
)
)
;
nsMargin
&
bp
=
childRI
.
ComputedPhysicalBorderPadding
(
)
;
widgetMainMinSize
=
std
:
:
max
(
widgetMainMinSize
-
aAxisTracker
.
GetMarginSizeInMainAxis
(
bp
)
0
)
;
widgetCrossMinSize
=
std
:
:
max
(
widgetCrossMinSize
-
aAxisTracker
.
GetMarginSizeInCrossAxis
(
bp
)
0
)
;
if
(
!
canOverride
)
{
flexBaseSize
=
mainMinSize
=
mainMaxSize
=
widgetMainMinSize
;
tentativeCrossSize
=
crossMinSize
=
crossMaxSize
=
widgetCrossMinSize
;
isFixedSizeWidget
=
true
;
}
else
{
mainMinSize
=
std
:
:
max
(
mainMinSize
widgetMainMinSize
)
;
mainMaxSize
=
std
:
:
max
(
mainMaxSize
widgetMainMinSize
)
;
if
(
tentativeCrossSize
!
=
NS_INTRINSICSIZE
)
{
tentativeCrossSize
=
std
:
:
max
(
tentativeCrossSize
widgetCrossMinSize
)
;
}
crossMinSize
=
std
:
:
max
(
crossMinSize
widgetCrossMinSize
)
;
crossMaxSize
=
std
:
:
max
(
crossMaxSize
widgetCrossMinSize
)
;
}
}
auto
item
=
MakeUnique
<
FlexItem
>
(
childRI
flexGrow
flexShrink
flexBaseSize
mainMinSize
mainMaxSize
tentativeCrossSize
crossMinSize
crossMaxSize
aAxisTracker
)
;
if
(
isFixedSizeWidget
|
|
(
flexGrow
=
=
0
.
0f
&
&
flexShrink
=
=
0
.
0f
)
)
{
item
-
>
Freeze
(
)
;
}
ResolveAutoFlexBasisAndMinSize
(
aPresContext
*
item
childRI
aAxisTracker
)
;
return
item
;
}
static
bool
IsCrossSizeDefinite
(
const
ReflowInput
&
aItemReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
)
{
const
nsStylePosition
*
pos
=
aItemReflowInput
.
mStylePosition
;
if
(
aAxisTracker
.
IsCrossAxisHorizontal
(
)
)
{
return
pos
-
>
mWidth
.
GetUnit
(
)
!
=
eStyleUnit_Auto
;
}
nscoord
cbHeight
=
aItemReflowInput
.
mCBReflowInput
-
>
ComputedHeight
(
)
;
return
!
nsLayoutUtils
:
:
IsAutoHeight
(
pos
-
>
mHeight
cbHeight
)
;
}
static
nscoord
CrossSizeToUseWithRatio
(
const
FlexItem
&
aFlexItem
const
ReflowInput
&
aItemReflowInput
bool
aMinSizeFallback
const
FlexboxAxisTracker
&
aAxisTracker
)
{
if
(
aFlexItem
.
IsStretched
(
)
)
{
return
aFlexItem
.
GetCrossSize
(
)
;
}
if
(
IsCrossSizeDefinite
(
aItemReflowInput
aAxisTracker
)
)
{
return
GET_CROSS_COMPONENT_LOGICAL
(
aAxisTracker
aFlexItem
.
GetWritingMode
(
)
aItemReflowInput
.
ComputedISize
(
)
aItemReflowInput
.
ComputedBSize
(
)
)
;
}
if
(
aMinSizeFallback
)
{
return
GET_CROSS_COMPONENT_LOGICAL
(
aAxisTracker
aFlexItem
.
GetWritingMode
(
)
aItemReflowInput
.
ComputedMinISize
(
)
aItemReflowInput
.
ComputedMinBSize
(
)
)
;
}
return
NS_AUTOHEIGHT
;
}
static
nscoord
MainSizeFromAspectRatio
(
nscoord
aCrossSize
const
nsSize
&
aIntrinsicRatio
const
FlexboxAxisTracker
&
aAxisTracker
)
{
MOZ_ASSERT
(
aAxisTracker
.
GetCrossComponent
(
aIntrinsicRatio
)
!
=
0
"
Invalid
ratio
;
will
divide
by
0
!
Caller
should
'
ve
checked
.
.
.
"
)
;
if
(
aAxisTracker
.
IsCrossAxisHorizontal
(
)
)
{
return
NSCoordMulDiv
(
aCrossSize
aIntrinsicRatio
.
height
aIntrinsicRatio
.
width
)
;
}
return
NSCoordMulDiv
(
aCrossSize
aIntrinsicRatio
.
width
aIntrinsicRatio
.
height
)
;
}
static
nscoord
PartiallyResolveAutoMinSize
(
const
FlexItem
&
aFlexItem
const
ReflowInput
&
aItemReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
)
{
MOZ_ASSERT
(
aFlexItem
.
NeedsMinSizeAutoResolution
(
)
"
only
call
for
FlexItems
that
need
min
-
size
auto
resolution
"
)
;
nscoord
minMainSize
=
nscoord_MAX
;
if
(
eStyleUnit_Auto
=
=
aItemReflowInput
.
mStylePosition
-
>
mFlexBasis
.
GetUnit
(
)
&
&
aFlexItem
.
GetFlexBaseSize
(
)
!
=
NS_AUTOHEIGHT
)
{
minMainSize
=
std
:
:
min
(
minMainSize
aFlexItem
.
GetFlexBaseSize
(
)
)
;
}
nscoord
maxSize
=
GET_MAIN_COMPONENT_LOGICAL
(
aAxisTracker
aFlexItem
.
GetWritingMode
(
)
aItemReflowInput
.
ComputedMaxISize
(
)
aItemReflowInput
.
ComputedMaxBSize
(
)
)
;
if
(
maxSize
!
=
NS_UNCONSTRAINEDSIZE
)
{
minMainSize
=
std
:
:
min
(
minMainSize
maxSize
)
;
}
if
(
aAxisTracker
.
GetCrossComponent
(
aFlexItem
.
IntrinsicRatio
(
)
)
!
=
0
)
{
const
bool
useMinSizeIfCrossSizeIsIndefinite
=
true
;
nscoord
crossSizeToUseWithRatio
=
CrossSizeToUseWithRatio
(
aFlexItem
aItemReflowInput
useMinSizeIfCrossSizeIsIndefinite
aAxisTracker
)
;
nscoord
minMainSizeFromRatio
=
MainSizeFromAspectRatio
(
crossSizeToUseWithRatio
aFlexItem
.
IntrinsicRatio
(
)
aAxisTracker
)
;
minMainSize
=
std
:
:
min
(
minMainSize
minMainSizeFromRatio
)
;
}
return
minMainSize
;
}
static
bool
ResolveAutoFlexBasisFromRatio
(
FlexItem
&
aFlexItem
const
ReflowInput
&
aItemReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
)
{
MOZ_ASSERT
(
NS_AUTOHEIGHT
=
=
aFlexItem
.
GetFlexBaseSize
(
)
"
Should
only
be
called
to
resolve
an
'
auto
'
flex
-
basis
"
)
;
if
(
aAxisTracker
.
GetCrossComponent
(
aFlexItem
.
IntrinsicRatio
(
)
)
!
=
0
)
{
const
bool
useMinSizeIfCrossSizeIsIndefinite
=
false
;
nscoord
crossSizeToUseWithRatio
=
CrossSizeToUseWithRatio
(
aFlexItem
aItemReflowInput
useMinSizeIfCrossSizeIsIndefinite
aAxisTracker
)
;
if
(
crossSizeToUseWithRatio
!
=
NS_AUTOHEIGHT
)
{
nscoord
mainSizeFromRatio
=
MainSizeFromAspectRatio
(
crossSizeToUseWithRatio
aFlexItem
.
IntrinsicRatio
(
)
aAxisTracker
)
;
aFlexItem
.
SetFlexBaseSizeAndMainSize
(
mainSizeFromRatio
)
;
return
true
;
}
}
return
false
;
}
void
nsFlexContainerFrame
:
:
ResolveAutoFlexBasisAndMinSize
(
nsPresContext
*
aPresContext
FlexItem
&
aFlexItem
const
ReflowInput
&
aItemReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
)
{
const
bool
isMainSizeAuto
=
(
!
aAxisTracker
.
IsMainAxisHorizontal
(
)
&
&
NS_AUTOHEIGHT
=
=
aFlexItem
.
GetFlexBaseSize
(
)
)
;
const
bool
isMainMinSizeAuto
=
aFlexItem
.
NeedsMinSizeAutoResolution
(
)
;
if
(
!
isMainSizeAuto
&
&
!
isMainMinSizeAuto
)
{
return
;
}
const
ReflowInput
*
flexContainerRI
=
aItemReflowInput
.
mParentReflowInput
;
MOZ_ASSERT
(
flexContainerRI
"
flex
item
'
s
reflow
state
should
have
ptr
to
container
'
s
state
"
)
;
if
(
NS_STYLE_FLEX_WRAP_NOWRAP
=
=
flexContainerRI
-
>
mStylePosition
-
>
mFlexWrap
)
{
nscoord
containerCrossSize
=
GET_CROSS_COMPONENT_LOGICAL
(
aAxisTracker
aAxisTracker
.
GetWritingMode
(
)
flexContainerRI
-
>
ComputedISize
(
)
flexContainerRI
-
>
ComputedBSize
(
)
)
;
if
(
aAxisTracker
.
IsCrossAxisHorizontal
(
)
|
|
containerCrossSize
!
=
NS_AUTOHEIGHT
)
{
aFlexItem
.
ResolveStretchedCrossSize
(
containerCrossSize
aAxisTracker
)
;
}
}
nscoord
resolvedMinSize
;
bool
minSizeNeedsToMeasureContent
=
false
;
if
(
isMainMinSizeAuto
)
{
resolvedMinSize
=
PartiallyResolveAutoMinSize
(
aFlexItem
aItemReflowInput
aAxisTracker
)
;
if
(
resolvedMinSize
>
0
&
&
aAxisTracker
.
GetCrossComponent
(
aFlexItem
.
IntrinsicRatio
(
)
)
=
=
0
)
{
minSizeNeedsToMeasureContent
=
true
;
}
}
bool
flexBasisNeedsToMeasureContent
=
false
;
if
(
isMainSizeAuto
)
{
if
(
!
ResolveAutoFlexBasisFromRatio
(
aFlexItem
aItemReflowInput
aAxisTracker
)
)
{
flexBasisNeedsToMeasureContent
=
true
;
}
}
if
(
minSizeNeedsToMeasureContent
|
|
flexBasisNeedsToMeasureContent
)
{
if
(
aAxisTracker
.
IsMainAxisHorizontal
(
)
)
{
if
(
minSizeNeedsToMeasureContent
)
{
nscoord
frameMinISize
=
aFlexItem
.
Frame
(
)
-
>
GetMinISize
(
aItemReflowInput
.
mRenderingContext
)
;
resolvedMinSize
=
std
:
:
min
(
resolvedMinSize
frameMinISize
)
;
}
NS_ASSERTION
(
!
flexBasisNeedsToMeasureContent
"
flex
-
basis
:
auto
should
have
been
resolved
in
the
"
"
reflow
state
for
horizontal
flexbox
.
It
shouldn
'
t
need
"
"
special
handling
here
"
)
;
}
else
{
bool
forceVerticalResizeForMeasuringReflow
=
!
aFlexItem
.
IsFrozen
(
)
|
|
!
flexBasisNeedsToMeasureContent
;
nscoord
contentHeight
=
MeasureFlexItemContentHeight
(
aPresContext
aFlexItem
forceVerticalResizeForMeasuringReflow
*
flexContainerRI
)
;
if
(
minSizeNeedsToMeasureContent
)
{
resolvedMinSize
=
std
:
:
min
(
resolvedMinSize
contentHeight
)
;
}
if
(
flexBasisNeedsToMeasureContent
)
{
aFlexItem
.
SetFlexBaseSizeAndMainSize
(
contentHeight
)
;
}
}
}
if
(
isMainMinSizeAuto
)
{
aFlexItem
.
UpdateMainMinSize
(
resolvedMinSize
)
;
}
}
class
nsFlexContainerFrame
:
:
CachedMeasuringReflowResult
{
const
LogicalSize
mAvailableSize
;
const
nscoord
mComputedHeight
;
const
nscoord
mHeight
;
const
nscoord
mAscent
;
public
:
CachedMeasuringReflowResult
(
const
ReflowInput
&
aReflowInput
const
ReflowOutput
&
aDesiredSize
)
:
mAvailableSize
(
aReflowInput
.
AvailableSize
(
)
)
mComputedHeight
(
aReflowInput
.
ComputedHeight
(
)
)
mHeight
(
aDesiredSize
.
Height
(
)
)
mAscent
(
aDesiredSize
.
BlockStartAscent
(
)
)
{
}
bool
IsValidFor
(
const
ReflowInput
&
aReflowInput
)
const
{
return
mAvailableSize
=
=
aReflowInput
.
AvailableSize
(
)
&
&
mComputedHeight
=
=
aReflowInput
.
ComputedHeight
(
)
;
}
nscoord
Height
(
)
const
{
return
mHeight
;
}
nscoord
Ascent
(
)
const
{
return
mAscent
;
}
}
;
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
CachedFlexMeasuringReflow
CachedMeasuringReflowResult
)
;
const
CachedMeasuringReflowResult
&
nsFlexContainerFrame
:
:
MeasureAscentAndHeightForFlexItem
(
FlexItem
&
aItem
nsPresContext
*
aPresContext
ReflowInput
&
aChildReflowInput
)
{
const
FrameProperties
props
=
aItem
.
Frame
(
)
-
>
Properties
(
)
;
if
(
const
auto
*
cachedResult
=
props
.
Get
(
CachedFlexMeasuringReflow
(
)
)
)
{
if
(
cachedResult
-
>
IsValidFor
(
aChildReflowInput
)
)
{
return
*
cachedResult
;
}
}
ReflowOutput
childDesiredSize
(
aChildReflowInput
)
;
nsReflowStatus
childReflowStatus
;
const
uint32_t
flags
=
NS_FRAME_NO_MOVE_FRAME
;
ReflowChild
(
aItem
.
Frame
(
)
aPresContext
childDesiredSize
aChildReflowInput
0
0
flags
childReflowStatus
)
;
aItem
.
SetHadMeasuringReflow
(
)
;
MOZ_ASSERT
(
childReflowStatus
.
IsComplete
(
)
"
We
gave
flex
item
unconstrained
available
height
so
it
"
"
should
be
complete
"
)
;
FinishReflowChild
(
aItem
.
Frame
(
)
aPresContext
childDesiredSize
&
aChildReflowInput
0
0
flags
)
;
auto
result
=
new
CachedMeasuringReflowResult
(
aChildReflowInput
childDesiredSize
)
;
props
.
Set
(
CachedFlexMeasuringReflow
(
)
result
)
;
return
*
result
;
}
void
nsFlexContainerFrame
:
:
MarkIntrinsicISizesDirty
(
)
{
for
(
nsIFrame
*
childFrame
:
mFrames
)
{
childFrame
-
>
Properties
(
)
.
Delete
(
CachedFlexMeasuringReflow
(
)
)
;
}
nsContainerFrame
:
:
MarkIntrinsicISizesDirty
(
)
;
}
nscoord
nsFlexContainerFrame
:
:
MeasureFlexItemContentHeight
(
nsPresContext
*
aPresContext
FlexItem
&
aFlexItem
bool
aForceVerticalResizeForMeasuringReflow
const
ReflowInput
&
aParentReflowInput
)
{
WritingMode
wm
=
aFlexItem
.
Frame
(
)
-
>
GetWritingMode
(
)
;
LogicalSize
availSize
=
aParentReflowInput
.
ComputedSize
(
wm
)
;
availSize
.
BSize
(
wm
)
=
NS_UNCONSTRAINEDSIZE
;
ReflowInput
childRIForMeasuringHeight
(
aPresContext
aParentReflowInput
aFlexItem
.
Frame
(
)
availSize
nullptr
ReflowInput
:
:
CALLER_WILL_INIT
)
;
childRIForMeasuringHeight
.
mFlags
.
mIsFlexContainerMeasuringHeight
=
true
;
childRIForMeasuringHeight
.
Init
(
aPresContext
)
;
if
(
aFlexItem
.
IsStretched
(
)
)
{
childRIForMeasuringHeight
.
SetComputedWidth
(
aFlexItem
.
GetCrossSize
(
)
)
;
childRIForMeasuringHeight
.
SetHResize
(
true
)
;
}
if
(
aForceVerticalResizeForMeasuringReflow
)
{
childRIForMeasuringHeight
.
SetVResize
(
true
)
;
}
const
CachedMeasuringReflowResult
&
reflowResult
=
MeasureAscentAndHeightForFlexItem
(
aFlexItem
aPresContext
childRIForMeasuringHeight
)
;
aFlexItem
.
SetAscent
(
reflowResult
.
Ascent
(
)
)
;
nscoord
childDesiredHeight
=
reflowResult
.
Height
(
)
-
childRIForMeasuringHeight
.
ComputedPhysicalBorderPadding
(
)
.
TopBottom
(
)
;
return
std
:
:
max
(
0
childDesiredHeight
)
;
}
FlexItem
:
:
FlexItem
(
ReflowInput
&
aFlexItemReflowInput
float
aFlexGrow
float
aFlexShrink
nscoord
aFlexBaseSize
nscoord
aMainMinSize
nscoord
aMainMaxSize
nscoord
aTentativeCrossSize
nscoord
aCrossMinSize
nscoord
aCrossMaxSize
const
FlexboxAxisTracker
&
aAxisTracker
)
:
mFrame
(
aFlexItemReflowInput
.
mFrame
)
mFlexGrow
(
aFlexGrow
)
mFlexShrink
(
aFlexShrink
)
mIntrinsicRatio
(
mFrame
-
>
GetIntrinsicRatio
(
)
)
mBorderPadding
(
aFlexItemReflowInput
.
ComputedPhysicalBorderPadding
(
)
)
mMargin
(
aFlexItemReflowInput
.
ComputedPhysicalMargin
(
)
)
mMainMinSize
(
aMainMinSize
)
mMainMaxSize
(
aMainMaxSize
)
mCrossMinSize
(
aCrossMinSize
)
mCrossMaxSize
(
aCrossMaxSize
)
mMainPosn
(
0
)
mCrossSize
(
aTentativeCrossSize
)
mCrossPosn
(
0
)
mAscent
(
0
)
mShareOfWeightSoFar
(
0
.
0f
)
mIsFrozen
(
false
)
mHadMinViolation
(
false
)
mHadMaxViolation
(
false
)
mHadMeasuringReflow
(
false
)
mIsStretched
(
false
)
mIsStrut
(
false
)
mWM
(
aFlexItemReflowInput
.
GetWritingMode
(
)
)
{
MOZ_ASSERT
(
mFrame
"
expecting
a
non
-
null
child
frame
"
)
;
MOZ_ASSERT
(
mFrame
-
>
GetType
(
)
!
=
nsGkAtoms
:
:
placeholderFrame
"
placeholder
frames
should
not
be
treated
as
flex
items
"
)
;
MOZ_ASSERT
(
!
(
mFrame
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
"
out
-
of
-
flow
frames
should
not
be
treated
as
flex
items
"
)
;
const
ReflowInput
*
containerRS
=
aFlexItemReflowInput
.
mParentReflowInput
;
if
(
IsLegacyBox
(
containerRS
-
>
mFrame
)
)
{
const
nsStyleXUL
*
containerStyleXUL
=
containerRS
-
>
mFrame
-
>
StyleXUL
(
)
;
mAlignSelf
=
ConvertLegacyStyleToAlignItems
(
containerStyleXUL
)
;
}
else
{
mAlignSelf
=
aFlexItemReflowInput
.
mStylePosition
-
>
UsedAlignSelf
(
containerRS
-
>
mFrame
-
>
StyleContext
(
)
)
;
if
(
MOZ_LIKELY
(
mAlignSelf
=
=
NS_STYLE_ALIGN_NORMAL
)
)
{
mAlignSelf
=
NS_STYLE_ALIGN_STRETCH
;
}
mAlignSelf
&
=
~
NS_STYLE_ALIGN_FLAG_BITS
;
}
SetFlexBaseSizeAndMainSize
(
aFlexBaseSize
)
;
CheckForMinSizeAuto
(
aFlexItemReflowInput
aAxisTracker
)
;
#
ifdef
DEBUG
{
const
nsStyleSides
&
styleMargin
=
aFlexItemReflowInput
.
mStyleMargin
-
>
mMargin
;
NS_FOR_CSS_SIDES
(
side
)
{
if
(
styleMargin
.
GetUnit
(
side
)
=
=
eStyleUnit_Auto
)
{
MOZ_ASSERT
(
GetMarginComponentForSide
(
side
)
=
=
0
"
Someone
else
tried
to
resolve
our
auto
margin
"
)
;
}
}
}
#
endif
if
(
aAxisTracker
.
IsRowOriented
(
)
=
=
aAxisTracker
.
GetWritingMode
(
)
.
IsOrthogonalTo
(
mWM
)
)
{
if
(
mAlignSelf
=
=
NS_STYLE_ALIGN_BASELINE
)
{
mAlignSelf
=
NS_STYLE_ALIGN_FLEX_START
;
}
else
if
(
mAlignSelf
=
=
NS_STYLE_ALIGN_LAST_BASELINE
)
{
mAlignSelf
=
NS_STYLE_ALIGN_FLEX_END
;
}
}
}
FlexItem
:
:
FlexItem
(
nsIFrame
*
aChildFrame
nscoord
aCrossSize
WritingMode
aContainerWM
)
:
mFrame
(
aChildFrame
)
mFlexGrow
(
0
.
0f
)
mFlexShrink
(
0
.
0f
)
mIntrinsicRatio
(
)
mFlexBaseSize
(
0
)
mMainMinSize
(
0
)
mMainMaxSize
(
0
)
mCrossMinSize
(
0
)
mCrossMaxSize
(
0
)
mMainSize
(
0
)
mMainPosn
(
0
)
mCrossSize
(
aCrossSize
)
mCrossPosn
(
0
)
mAscent
(
0
)
mShareOfWeightSoFar
(
0
.
0f
)
mIsFrozen
(
true
)
mHadMinViolation
(
false
)
mHadMaxViolation
(
false
)
mHadMeasuringReflow
(
false
)
mIsStretched
(
false
)
mIsStrut
(
true
)
mNeedsMinSizeAutoResolution
(
false
)
mWM
(
aContainerWM
)
mAlignSelf
(
NS_STYLE_ALIGN_FLEX_START
)
{
MOZ_ASSERT
(
mFrame
"
expecting
a
non
-
null
child
frame
"
)
;
MOZ_ASSERT
(
NS_STYLE_VISIBILITY_COLLAPSE
=
=
mFrame
-
>
StyleVisibility
(
)
-
>
mVisible
"
Should
only
make
struts
for
children
with
'
visibility
:
collapse
'
"
)
;
MOZ_ASSERT
(
mFrame
-
>
GetType
(
)
!
=
nsGkAtoms
:
:
placeholderFrame
"
placeholder
frames
should
not
be
treated
as
flex
items
"
)
;
MOZ_ASSERT
(
!
(
mFrame
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
"
out
-
of
-
flow
frames
should
not
be
treated
as
flex
items
"
)
;
}
void
FlexItem
:
:
CheckForMinSizeAuto
(
const
ReflowInput
&
aFlexItemReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
)
{
const
nsStylePosition
*
pos
=
aFlexItemReflowInput
.
mStylePosition
;
const
nsStyleDisplay
*
disp
=
aFlexItemReflowInput
.
mStyleDisplay
;
const
nsStyleCoord
&
minSize
=
GET_MAIN_COMPONENT
(
aAxisTracker
pos
-
>
mMinWidth
pos
-
>
mMinHeight
)
;
const
uint8_t
overflowVal
=
GET_MAIN_COMPONENT
(
aAxisTracker
disp
-
>
mOverflowX
disp
-
>
mOverflowY
)
;
mNeedsMinSizeAutoResolution
=
(
minSize
.
GetUnit
(
)
=
=
eStyleUnit_Auto
&
&
overflowVal
=
=
NS_STYLE_OVERFLOW_VISIBLE
)
;
}
nscoord
FlexItem
:
:
GetBaselineOffsetFromOuterCrossEdge
(
AxisEdgeType
aEdge
const
FlexboxAxisTracker
&
aAxisTracker
bool
aUseFirstLineBaseline
)
const
{
MOZ_ASSERT
(
!
aAxisTracker
.
IsCrossAxisHorizontal
(
)
"
Only
expecting
to
be
doing
baseline
computations
when
the
"
"
cross
axis
is
vertical
"
)
;
AxisOrientationType
crossAxis
=
aAxisTracker
.
GetCrossAxis
(
)
;
mozilla
:
:
Side
sideToMeasureFrom
=
kAxisOrientationToSidesMap
[
crossAxis
]
[
aEdge
]
;
nscoord
marginTopToBaseline
=
ResolvedAscent
(
aUseFirstLineBaseline
)
+
mMargin
.
top
;
if
(
sideToMeasureFrom
=
=
eSideTop
)
{
return
marginTopToBaseline
;
}
MOZ_ASSERT
(
sideToMeasureFrom
=
=
eSideBottom
"
We
already
checked
that
we
'
re
dealing
with
a
vertical
axis
and
"
"
we
'
re
not
using
the
top
side
so
that
only
leaves
the
bottom
.
.
.
"
)
;
return
GetOuterCrossSize
(
crossAxis
)
-
marginTopToBaseline
;
}
uint32_t
FlexItem
:
:
GetNumAutoMarginsInAxis
(
AxisOrientationType
aAxis
)
const
{
uint32_t
numAutoMargins
=
0
;
const
nsStyleSides
&
styleMargin
=
mFrame
-
>
StyleMargin
(
)
-
>
mMargin
;
for
(
uint32_t
i
=
0
;
i
<
eNumAxisEdges
;
i
+
+
)
{
mozilla
:
:
Side
side
=
kAxisOrientationToSidesMap
[
aAxis
]
[
i
]
;
if
(
styleMargin
.
GetUnit
(
side
)
=
=
eStyleUnit_Auto
)
{
numAutoMargins
+
+
;
}
}
MOZ_ASSERT
(
numAutoMargins
<
=
2
"
We
'
re
just
looking
at
one
item
along
one
dimension
so
we
"
"
should
only
have
examined
2
margins
"
)
;
return
numAutoMargins
;
}
bool
FlexItem
:
:
CanMainSizeInfluenceCrossSize
(
const
FlexboxAxisTracker
&
aAxisTracker
)
const
{
if
(
mIsStretched
)
{
return
false
;
}
if
(
mIsStrut
)
{
return
false
;
}
if
(
HasIntrinsicRatio
(
)
)
{
return
true
;
}
if
(
aAxisTracker
.
IsCrossAxisHorizontal
(
)
)
{
return
false
;
}
return
true
;
}
class
MOZ_STACK_CLASS
PositionTracker
{
public
:
inline
nscoord
GetPosition
(
)
const
{
return
mPosition
;
}
inline
AxisOrientationType
GetAxis
(
)
const
{
return
mAxis
;
}
void
EnterMargin
(
const
nsMargin
&
aMargin
)
{
mozilla
:
:
Side
side
=
kAxisOrientationToSidesMap
[
mAxis
]
[
eAxisEdge_Start
]
;
mPosition
+
=
aMargin
.
Side
(
side
)
;
}
void
ExitMargin
(
const
nsMargin
&
aMargin
)
{
mozilla
:
:
Side
side
=
kAxisOrientationToSidesMap
[
mAxis
]
[
eAxisEdge_End
]
;
mPosition
+
=
aMargin
.
Side
(
side
)
;
}
void
EnterChildFrame
(
nscoord
aChildFrameSize
)
{
if
(
mIsAxisReversed
)
{
mPosition
+
=
aChildFrameSize
;
}
}
void
ExitChildFrame
(
nscoord
aChildFrameSize
)
{
if
(
!
mIsAxisReversed
)
{
mPosition
+
=
aChildFrameSize
;
}
}
protected
:
PositionTracker
(
AxisOrientationType
aAxis
bool
aIsAxisReversed
)
:
mPosition
(
0
)
mAxis
(
aAxis
)
mIsAxisReversed
(
aIsAxisReversed
)
{
}
PositionTracker
(
const
PositionTracker
&
)
=
delete
;
PositionTracker
&
operator
=
(
const
PositionTracker
&
)
=
delete
;
nscoord
mPosition
;
const
AxisOrientationType
mAxis
;
const
bool
mIsAxisReversed
;
}
;
class
MOZ_STACK_CLASS
MainAxisPositionTracker
:
public
PositionTracker
{
public
:
MainAxisPositionTracker
(
const
FlexboxAxisTracker
&
aAxisTracker
const
FlexLine
*
aLine
uint8_t
aJustifyContent
nscoord
aContentBoxMainSize
)
;
~
MainAxisPositionTracker
(
)
{
MOZ_ASSERT
(
mNumPackingSpacesRemaining
=
=
0
"
miscounted
the
number
of
packing
spaces
"
)
;
MOZ_ASSERT
(
mNumAutoMarginsInMainAxis
=
=
0
"
miscounted
the
number
of
auto
margins
"
)
;
}
void
TraversePackingSpace
(
)
;
void
ResolveAutoMarginsInMainAxis
(
FlexItem
&
aItem
)
;
private
:
nscoord
mPackingSpaceRemaining
;
uint32_t
mNumAutoMarginsInMainAxis
;
uint32_t
mNumPackingSpacesRemaining
;
uint8_t
mJustifyContent
;
}
;
class
MOZ_STACK_CLASS
CrossAxisPositionTracker
:
public
PositionTracker
{
public
:
CrossAxisPositionTracker
(
FlexLine
*
aFirstLine
const
ReflowInput
&
aReflowInput
nscoord
aContentBoxCrossSize
bool
aIsCrossSizeDefinite
const
FlexboxAxisTracker
&
aAxisTracker
)
;
void
TraversePackingSpace
(
)
;
void
TraverseLine
(
FlexLine
&
aLine
)
{
mPosition
+
=
aLine
.
GetLineCrossSize
(
)
;
}
private
:
void
EnterMargin
(
const
nsMargin
&
aMargin
)
=
delete
;
void
ExitMargin
(
const
nsMargin
&
aMargin
)
=
delete
;
void
EnterChildFrame
(
nscoord
aChildFrameSize
)
=
delete
;
void
ExitChildFrame
(
nscoord
aChildFrameSize
)
=
delete
;
nscoord
mPackingSpaceRemaining
;
uint32_t
mNumPackingSpacesRemaining
;
uint8_t
mAlignContent
;
}
;
class
MOZ_STACK_CLASS
SingleLineCrossAxisPositionTracker
:
public
PositionTracker
{
public
:
explicit
SingleLineCrossAxisPositionTracker
(
const
FlexboxAxisTracker
&
aAxisTracker
)
;
void
ResolveAutoMarginsInCrossAxis
(
const
FlexLine
&
aLine
FlexItem
&
aItem
)
;
void
EnterAlignPackingSpace
(
const
FlexLine
&
aLine
const
FlexItem
&
aItem
const
FlexboxAxisTracker
&
aAxisTracker
)
;
inline
void
ResetPosition
(
)
{
mPosition
=
0
;
}
}
;
NS_QUERYFRAME_HEAD
(
nsFlexContainerFrame
)
NS_QUERYFRAME_ENTRY
(
nsFlexContainerFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsContainerFrame
)
NS_IMPL_FRAMEARENA_HELPERS
(
nsFlexContainerFrame
)
nsContainerFrame
*
NS_NewFlexContainerFrame
(
nsIPresShell
*
aPresShell
nsStyleContext
*
aContext
)
{
return
new
(
aPresShell
)
nsFlexContainerFrame
(
aContext
)
;
}
nsFlexContainerFrame
:
:
~
nsFlexContainerFrame
(
)
{
}
void
nsFlexContainerFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
nsContainerFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
const
nsStyleDisplay
*
styleDisp
=
StyleContext
(
)
-
>
StyleDisplay
(
)
;
bool
isLegacyBox
=
IsDisplayValueLegacyBox
(
styleDisp
)
;
if
(
!
isLegacyBox
&
&
styleDisp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
Block
)
{
nsStyleContext
*
parentStyleContext
=
GetParent
(
)
-
>
StyleContext
(
)
;
NS_ASSERTION
(
parentStyleContext
&
&
(
mStyleContext
-
>
GetPseudo
(
)
=
=
nsCSSAnonBoxes
:
:
buttonContent
|
|
mStyleContext
-
>
GetPseudo
(
)
=
=
nsCSSAnonBoxes
:
:
scrolledContent
)
"
The
only
way
a
nsFlexContainerFrame
can
have
'
display
:
block
'
"
"
should
be
if
it
'
s
the
inner
part
of
a
scrollable
or
button
"
"
element
"
)
;
isLegacyBox
=
IsDisplayValueLegacyBox
(
parentStyleContext
-
>
StyleDisplay
(
)
)
;
}
if
(
isLegacyBox
)
{
AddStateBits
(
NS_STATE_FLEX_IS_LEGACY_WEBKIT_BOX
)
;
}
}
nsIAtom
*
nsFlexContainerFrame
:
:
GetType
(
)
const
{
return
nsGkAtoms
:
:
flexContainerFrame
;
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
nsFlexContainerFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
NS_LITERAL_STRING
(
"
FlexContainer
"
)
aResult
)
;
}
#
endif
nscoord
nsFlexContainerFrame
:
:
GetLogicalBaseline
(
mozilla
:
:
WritingMode
aWM
)
const
{
NS_ASSERTION
(
mBaselineFromLastReflow
!
=
NS_INTRINSIC_WIDTH_UNKNOWN
"
baseline
has
not
been
set
"
)
;
if
(
HasAnyStateBits
(
NS_STATE_FLEX_SYNTHESIZE_BASELINE
)
)
{
return
nsContainerFrame
:
:
GetLogicalBaseline
(
aWM
)
;
}
return
mBaselineFromLastReflow
;
}
uint32_t
GetDisplayFlagsForFlexItem
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
-
>
IsFlexItem
(
)
"
Should
only
be
called
on
flex
items
"
)
;
const
nsStylePosition
*
pos
=
aFrame
-
>
StylePosition
(
)
;
if
(
pos
-
>
mZIndex
.
GetUnit
(
)
=
=
eStyleUnit_Integer
)
{
return
nsIFrame
:
:
DISPLAY_CHILD_FORCE_STACKING_CONTEXT
;
}
return
nsIFrame
:
:
DISPLAY_CHILD_FORCE_PSEUDO_STACKING_CONTEXT
;
}
void
nsFlexContainerFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aDirtyRect
const
nsDisplayListSet
&
aLists
)
{
DisplayBorderBackgroundOutline
(
aBuilder
aLists
)
;
nsDisplayListSet
childLists
(
aLists
aLists
.
BlockBorderBackgrounds
(
)
)
;
typedef
CSSOrderAwareFrameIterator
:
:
OrderState
OrderState
;
OrderState
orderState
=
HasAnyStateBits
(
NS_STATE_FLEX_CHILDREN_REORDERED
)
?
OrderState
:
:
eKnownUnordered
:
OrderState
:
:
eKnownOrdered
;
CSSOrderAwareFrameIterator
iter
(
this
kPrincipalList
CSSOrderAwareFrameIterator
:
:
eIncludeAll
orderState
OrderingPropertyForIter
(
this
)
)
;
for
(
;
!
iter
.
AtEnd
(
)
;
iter
.
Next
(
)
)
{
nsIFrame
*
childFrame
=
*
iter
;
BuildDisplayListForChild
(
aBuilder
childFrame
aDirtyRect
childLists
GetDisplayFlagsForFlexItem
(
childFrame
)
)
;
}
}
void
FlexLine
:
:
FreezeItemsEarly
(
bool
aIsUsingFlexGrow
)
{
uint32_t
numUnfrozenItemsToBeSeen
=
mNumItems
-
mNumFrozenItems
;
for
(
FlexItem
*
item
=
mItems
.
getFirst
(
)
;
numUnfrozenItemsToBeSeen
>
0
;
item
=
item
-
>
getNext
(
)
)
{
MOZ_ASSERT
(
item
"
numUnfrozenItemsToBeSeen
says
items
remain
to
be
seen
"
)
;
if
(
!
item
-
>
IsFrozen
(
)
)
{
numUnfrozenItemsToBeSeen
-
-
;
bool
shouldFreeze
=
(
0
.
0f
=
=
item
-
>
GetFlexFactor
(
aIsUsingFlexGrow
)
)
;
if
(
!
shouldFreeze
)
{
if
(
aIsUsingFlexGrow
)
{
if
(
item
-
>
GetFlexBaseSize
(
)
>
item
-
>
GetMainSize
(
)
)
{
shouldFreeze
=
true
;
}
}
else
{
if
(
item
-
>
GetFlexBaseSize
(
)
<
item
-
>
GetMainSize
(
)
)
{
shouldFreeze
=
true
;
}
}
}
if
(
shouldFreeze
)
{
item
-
>
Freeze
(
)
;
mNumFrozenItems
+
+
;
}
}
}
}
void
FlexLine
:
:
FreezeOrRestoreEachFlexibleSize
(
const
nscoord
aTotalViolation
bool
aIsFinalIteration
)
{
enum
FreezeType
{
eFreezeEverything
eFreezeMinViolations
eFreezeMaxViolations
}
;
FreezeType
freezeType
;
if
(
aTotalViolation
=
=
0
)
{
freezeType
=
eFreezeEverything
;
}
else
if
(
aTotalViolation
>
0
)
{
freezeType
=
eFreezeMinViolations
;
}
else
{
freezeType
=
eFreezeMaxViolations
;
}
uint32_t
numUnfrozenItemsToBeSeen
=
mNumItems
-
mNumFrozenItems
;
for
(
FlexItem
*
item
=
mItems
.
getFirst
(
)
;
numUnfrozenItemsToBeSeen
>
0
;
item
=
item
-
>
getNext
(
)
)
{
MOZ_ASSERT
(
item
"
numUnfrozenItemsToBeSeen
says
items
remain
to
be
seen
"
)
;
if
(
!
item
-
>
IsFrozen
(
)
)
{
numUnfrozenItemsToBeSeen
-
-
;
MOZ_ASSERT
(
!
item
-
>
HadMinViolation
(
)
|
|
!
item
-
>
HadMaxViolation
(
)
"
Can
have
either
min
or
max
violation
but
not
both
"
)
;
if
(
eFreezeEverything
=
=
freezeType
|
|
(
eFreezeMinViolations
=
=
freezeType
&
&
item
-
>
HadMinViolation
(
)
)
|
|
(
eFreezeMaxViolations
=
=
freezeType
&
&
item
-
>
HadMaxViolation
(
)
)
)
{
MOZ_ASSERT
(
item
-
>
GetMainSize
(
)
>
=
item
-
>
GetMainMinSize
(
)
"
Freezing
item
at
a
size
below
its
minimum
"
)
;
MOZ_ASSERT
(
item
-
>
GetMainSize
(
)
<
=
item
-
>
GetMainMaxSize
(
)
"
Freezing
item
at
a
size
above
its
maximum
"
)
;
item
-
>
Freeze
(
)
;
mNumFrozenItems
+
+
;
}
else
if
(
MOZ_UNLIKELY
(
aIsFinalIteration
)
)
{
NS_ERROR
(
"
Final
iteration
still
has
unfrozen
items
this
shouldn
'
t
"
"
happen
unless
there
was
nscoord
under
/
overflow
.
"
)
;
item
-
>
Freeze
(
)
;
mNumFrozenItems
+
+
;
}
item
-
>
ClearViolationFlags
(
)
;
}
}
}
void
FlexLine
:
:
ResolveFlexibleLengths
(
nscoord
aFlexContainerMainSize
)
{
MOZ_LOG
(
gFlexContainerLog
LogLevel
:
:
Debug
(
"
ResolveFlexibleLengths
\
n
"
)
)
;
const
bool
isUsingFlexGrow
=
(
mTotalOuterHypotheticalMainSize
<
aFlexContainerMainSize
)
;
FreezeItemsEarly
(
isUsingFlexGrow
)
;
if
(
mNumFrozenItems
=
=
mNumItems
)
{
return
;
}
MOZ_ASSERT
(
!
IsEmpty
(
)
"
empty
lines
should
take
the
early
-
return
above
"
)
;
nscoord
spaceReservedForMarginBorderPadding
=
mTotalOuterHypotheticalMainSize
-
mTotalInnerHypotheticalMainSize
;
nscoord
spaceAvailableForFlexItemsContentBoxes
=
aFlexContainerMainSize
-
spaceReservedForMarginBorderPadding
;
nscoord
origAvailableFreeSpace
;
bool
isOrigAvailFreeSpaceInitialized
=
false
;
for
(
uint32_t
iterationCounter
=
0
;
iterationCounter
<
mNumItems
;
iterationCounter
+
+
)
{
nscoord
availableFreeSpace
=
spaceAvailableForFlexItemsContentBoxes
;
for
(
FlexItem
*
item
=
mItems
.
getFirst
(
)
;
item
;
item
=
item
-
>
getNext
(
)
)
{
if
(
!
item
-
>
IsFrozen
(
)
)
{
item
-
>
SetMainSize
(
item
-
>
GetFlexBaseSize
(
)
)
;
}
availableFreeSpace
-
=
item
-
>
GetMainSize
(
)
;
}
MOZ_LOG
(
gFlexContainerLog
LogLevel
:
:
Debug
(
"
available
free
space
=
%
d
\
n
"
availableFreeSpace
)
)
;
NS_ASSERTION
(
(
isUsingFlexGrow
&
&
availableFreeSpace
>
=
0
)
|
|
(
!
isUsingFlexGrow
&
&
availableFreeSpace
<
=
0
)
"
availableFreeSpace
'
s
sign
should
match
isUsingFlexGrow
"
)
;
if
(
availableFreeSpace
!
=
0
)
{
if
(
!
isOrigAvailFreeSpaceInitialized
)
{
origAvailableFreeSpace
=
availableFreeSpace
;
isOrigAvailFreeSpaceInitialized
=
true
;
}
float
weightSum
=
0
.
0f
;
float
flexFactorSum
=
0
.
0f
;
float
largestWeight
=
0
.
0f
;
uint32_t
numItemsWithLargestWeight
=
0
;
uint32_t
numUnfrozenItemsToBeSeen
=
mNumItems
-
mNumFrozenItems
;
for
(
FlexItem
*
item
=
mItems
.
getFirst
(
)
;
numUnfrozenItemsToBeSeen
>
0
;
item
=
item
-
>
getNext
(
)
)
{
MOZ_ASSERT
(
item
"
numUnfrozenItemsToBeSeen
says
items
remain
to
be
seen
"
)
;
if
(
!
item
-
>
IsFrozen
(
)
)
{
numUnfrozenItemsToBeSeen
-
-
;
float
curWeight
=
item
-
>
GetWeight
(
isUsingFlexGrow
)
;
float
curFlexFactor
=
item
-
>
GetFlexFactor
(
isUsingFlexGrow
)
;
MOZ_ASSERT
(
curWeight
>
=
0
.
0f
"
weights
are
non
-
negative
"
)
;
MOZ_ASSERT
(
curFlexFactor
>
=
0
.
0f
"
flex
factors
are
non
-
negative
"
)
;
weightSum
+
=
curWeight
;
flexFactorSum
+
=
curFlexFactor
;
if
(
IsFinite
(
weightSum
)
)
{
if
(
curWeight
=
=
0
.
0f
)
{
item
-
>
SetShareOfWeightSoFar
(
0
.
0f
)
;
}
else
{
item
-
>
SetShareOfWeightSoFar
(
curWeight
/
weightSum
)
;
}
}
if
(
curWeight
>
largestWeight
)
{
largestWeight
=
curWeight
;
numItemsWithLargestWeight
=
1
;
}
else
if
(
curWeight
=
=
largestWeight
)
{
numItemsWithLargestWeight
+
+
;
}
}
}
if
(
weightSum
!
=
0
.
0f
)
{
MOZ_ASSERT
(
flexFactorSum
!
=
0
.
0f
"
flex
factor
sum
can
'
t
be
0
if
a
weighted
sum
"
"
of
its
components
(
weightSum
)
is
nonzero
"
)
;
if
(
flexFactorSum
<
1
.
0f
)
{
nscoord
totalDesiredPortionOfOrigFreeSpace
=
NSToCoordRound
(
origAvailableFreeSpace
*
flexFactorSum
)
;
MOZ_ASSERT
(
totalDesiredPortionOfOrigFreeSpace
=
=
0
|
|
(
(
totalDesiredPortionOfOrigFreeSpace
>
0
)
=
=
(
availableFreeSpace
>
0
)
)
"
When
we
reduce
available
free
space
for
flex
factors
<
1
"
"
we
shouldn
'
t
change
the
sign
of
the
free
space
.
.
.
"
)
;
if
(
availableFreeSpace
>
0
)
{
availableFreeSpace
=
std
:
:
min
(
availableFreeSpace
totalDesiredPortionOfOrigFreeSpace
)
;
}
else
{
availableFreeSpace
=
std
:
:
max
(
availableFreeSpace
totalDesiredPortionOfOrigFreeSpace
)
;
}
}
MOZ_LOG
(
gFlexContainerLog
LogLevel
:
:
Debug
(
"
Distributing
available
space
:
"
)
)
;
numUnfrozenItemsToBeSeen
=
mNumItems
-
mNumFrozenItems
;
for
(
FlexItem
*
item
=
mItems
.
getLast
(
)
;
numUnfrozenItemsToBeSeen
>
0
;
item
=
item
-
>
getPrevious
(
)
)
{
MOZ_ASSERT
(
item
"
numUnfrozenItemsToBeSeen
says
items
remain
to
be
seen
"
)
;
if
(
!
item
-
>
IsFrozen
(
)
)
{
numUnfrozenItemsToBeSeen
-
-
;
nscoord
sizeDelta
=
0
;
if
(
IsFinite
(
weightSum
)
)
{
float
myShareOfRemainingSpace
=
item
-
>
GetShareOfWeightSoFar
(
)
;
MOZ_ASSERT
(
myShareOfRemainingSpace
>
=
0
.
0f
&
&
myShareOfRemainingSpace
<
=
1
.
0f
"
my
share
should
be
nonnegative
fractional
amount
"
)
;
if
(
myShareOfRemainingSpace
=
=
1
.
0f
)
{
sizeDelta
=
availableFreeSpace
;
}
else
if
(
myShareOfRemainingSpace
>
0
.
0f
)
{
sizeDelta
=
NSToCoordRound
(
availableFreeSpace
*
myShareOfRemainingSpace
)
;
}
}
else
if
(
item
-
>
GetWeight
(
isUsingFlexGrow
)
=
=
largestWeight
)
{
sizeDelta
=
NSToCoordRound
(
availableFreeSpace
/
float
(
numItemsWithLargestWeight
)
)
;
numItemsWithLargestWeight
-
-
;
}
availableFreeSpace
-
=
sizeDelta
;
item
-
>
SetMainSize
(
item
-
>
GetMainSize
(
)
+
sizeDelta
)
;
MOZ_LOG
(
gFlexContainerLog
LogLevel
:
:
Debug
(
"
child
%
p
receives
%
d
for
a
total
of
%
d
\
n
"
item
sizeDelta
item
-
>
GetMainSize
(
)
)
)
;
}
}
}
}
nscoord
totalViolation
=
0
;
MOZ_LOG
(
gFlexContainerLog
LogLevel
:
:
Debug
(
"
Checking
for
violations
:
"
)
)
;
uint32_t
numUnfrozenItemsToBeSeen
=
mNumItems
-
mNumFrozenItems
;
for
(
FlexItem
*
item
=
mItems
.
getFirst
(
)
;
numUnfrozenItemsToBeSeen
>
0
;
item
=
item
-
>
getNext
(
)
)
{
MOZ_ASSERT
(
item
"
numUnfrozenItemsToBeSeen
says
items
remain
to
be
seen
"
)
;
if
(
!
item
-
>
IsFrozen
(
)
)
{
numUnfrozenItemsToBeSeen
-
-
;
if
(
item
-
>
GetMainSize
(
)
<
item
-
>
GetMainMinSize
(
)
)
{
totalViolation
+
=
item
-
>
GetMainMinSize
(
)
-
item
-
>
GetMainSize
(
)
;
item
-
>
SetMainSize
(
item
-
>
GetMainMinSize
(
)
)
;
item
-
>
SetHadMinViolation
(
)
;
}
else
if
(
item
-
>
GetMainSize
(
)
>
item
-
>
GetMainMaxSize
(
)
)
{
totalViolation
+
=
item
-
>
GetMainMaxSize
(
)
-
item
-
>
GetMainSize
(
)
;
item
-
>
SetMainSize
(
item
-
>
GetMainMaxSize
(
)
)
;
item
-
>
SetHadMaxViolation
(
)
;
}
}
}
FreezeOrRestoreEachFlexibleSize
(
totalViolation
iterationCounter
+
1
=
=
mNumItems
)
;
MOZ_LOG
(
gFlexContainerLog
LogLevel
:
:
Debug
(
"
Total
violation
:
%
d
\
n
"
totalViolation
)
)
;
if
(
mNumFrozenItems
=
=
mNumItems
)
{
break
;
}
MOZ_ASSERT
(
totalViolation
!
=
0
"
Zero
violation
should
'
ve
made
us
freeze
all
items
&
break
"
)
;
}
#
ifdef
DEBUG
MOZ_ASSERT
(
mNumFrozenItems
=
=
mNumItems
"
All
items
should
be
frozen
"
)
;
for
(
const
FlexItem
*
item
=
mItems
.
getFirst
(
)
;
item
;
item
=
item
-
>
getNext
(
)
)
{
MOZ_ASSERT
(
item
-
>
IsFrozen
(
)
"
All
items
should
be
frozen
"
)
;
}
#
endif
}
MainAxisPositionTracker
:
:
MainAxisPositionTracker
(
const
FlexboxAxisTracker
&
aAxisTracker
const
FlexLine
*
aLine
uint8_t
aJustifyContent
nscoord
aContentBoxMainSize
)
:
PositionTracker
(
aAxisTracker
.
GetMainAxis
(
)
aAxisTracker
.
IsMainAxisReversed
(
)
)
mPackingSpaceRemaining
(
aContentBoxMainSize
)
mNumAutoMarginsInMainAxis
(
0
)
mNumPackingSpacesRemaining
(
0
)
mJustifyContent
(
aJustifyContent
)
{
if
(
mJustifyContent
=
=
NS_STYLE_JUSTIFY_NORMAL
|
|
mJustifyContent
=
=
NS_STYLE_JUSTIFY_STRETCH
)
{
mJustifyContent
=
NS_STYLE_JUSTIFY_FLEX_START
;
}
mJustifyContent
&
=
~
NS_STYLE_JUSTIFY_FLAG_BITS
;
for
(
const
FlexItem
*
item
=
aLine
-
>
GetFirstItem
(
)
;
item
;
item
=
item
-
>
getNext
(
)
)
{
mPackingSpaceRemaining
-
=
item
-
>
GetOuterMainSize
(
mAxis
)
;
mNumAutoMarginsInMainAxis
+
=
item
-
>
GetNumAutoMarginsInAxis
(
mAxis
)
;
}
if
(
mPackingSpaceRemaining
<
=
0
)
{
mNumAutoMarginsInMainAxis
=
0
;
}
if
(
mPackingSpaceRemaining
<
0
)
{
if
(
mJustifyContent
=
=
NS_STYLE_JUSTIFY_SPACE_BETWEEN
)
{
mJustifyContent
=
NS_STYLE_JUSTIFY_FLEX_START
;
}
else
if
(
mJustifyContent
=
=
NS_STYLE_JUSTIFY_SPACE_AROUND
|
|
mJustifyContent
=
=
NS_STYLE_JUSTIFY_SPACE_EVENLY
)
{
mJustifyContent
=
NS_STYLE_JUSTIFY_CENTER
;
}
}
if
(
mJustifyContent
=
=
NS_STYLE_JUSTIFY_LEFT
|
|
mJustifyContent
=
=
NS_STYLE_JUSTIFY_RIGHT
)
{
if
(
aAxisTracker
.
IsColumnOriented
(
)
)
{
mJustifyContent
=
NS_STYLE_JUSTIFY_START
;
}
else
{
const
bool
isLTR
=
aAxisTracker
.
GetWritingMode
(
)
.
IsBidiLTR
(
)
;
const
bool
isJustifyLeft
=
(
mJustifyContent
=
=
NS_STYLE_JUSTIFY_LEFT
)
;
mJustifyContent
=
(
isJustifyLeft
=
=
isLTR
)
?
NS_STYLE_JUSTIFY_START
:
NS_STYLE_JUSTIFY_END
;
}
}
if
(
mJustifyContent
=
=
NS_STYLE_JUSTIFY_START
)
{
mJustifyContent
=
NS_STYLE_JUSTIFY_FLEX_START
;
}
else
if
(
mJustifyContent
=
=
NS_STYLE_JUSTIFY_END
)
{
mJustifyContent
=
NS_STYLE_JUSTIFY_FLEX_END
;
}
if
(
aAxisTracker
.
AreAxesInternallyReversed
(
)
)
{
if
(
mJustifyContent
=
=
NS_STYLE_JUSTIFY_FLEX_START
)
{
mJustifyContent
=
NS_STYLE_JUSTIFY_FLEX_END
;
}
else
if
(
mJustifyContent
=
=
NS_STYLE_JUSTIFY_FLEX_END
)
{
mJustifyContent
=
NS_STYLE_JUSTIFY_FLEX_START
;
}
}
if
(
mNumAutoMarginsInMainAxis
=
=
0
&
&
mPackingSpaceRemaining
!
=
0
&
&
!
aLine
-
>
IsEmpty
(
)
)
{
switch
(
mJustifyContent
)
{
case
NS_STYLE_JUSTIFY_BASELINE
:
case
NS_STYLE_JUSTIFY_LAST_BASELINE
:
NS_WARNING
(
"
NYI
:
justify
-
content
:
left
/
right
/
baseline
/
last
baseline
"
)
;
MOZ_FALLTHROUGH
;
case
NS_STYLE_JUSTIFY_FLEX_START
:
break
;
case
NS_STYLE_JUSTIFY_FLEX_END
:
mPosition
+
=
mPackingSpaceRemaining
;
break
;
case
NS_STYLE_JUSTIFY_CENTER
:
mPosition
+
=
mPackingSpaceRemaining
/
2
;
break
;
case
NS_STYLE_JUSTIFY_SPACE_BETWEEN
:
case
NS_STYLE_JUSTIFY_SPACE_AROUND
:
case
NS_STYLE_JUSTIFY_SPACE_EVENLY
:
nsFlexContainerFrame
:
:
CalculatePackingSpace
(
aLine
-
>
NumItems
(
)
mJustifyContent
&
mPosition
&
mNumPackingSpacesRemaining
&
mPackingSpaceRemaining
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
justify
-
content
value
"
)
;
}
}
MOZ_ASSERT
(
mNumPackingSpacesRemaining
=
=
0
|
|
mNumAutoMarginsInMainAxis
=
=
0
"
extra
space
should
either
go
to
packing
space
or
to
"
"
auto
margins
but
not
to
both
"
)
;
}
void
MainAxisPositionTracker
:
:
ResolveAutoMarginsInMainAxis
(
FlexItem
&
aItem
)
{
if
(
mNumAutoMarginsInMainAxis
)
{
const
nsStyleSides
&
styleMargin
=
aItem
.
Frame
(
)
-
>
StyleMargin
(
)
-
>
mMargin
;
for
(
uint32_t
i
=
0
;
i
<
eNumAxisEdges
;
i
+
+
)
{
mozilla
:
:
Side
side
=
kAxisOrientationToSidesMap
[
mAxis
]
[
i
]
;
if
(
styleMargin
.
GetUnit
(
side
)
=
=
eStyleUnit_Auto
)
{
nscoord
curAutoMarginSize
=
mPackingSpaceRemaining
/
mNumAutoMarginsInMainAxis
;
MOZ_ASSERT
(
aItem
.
GetMarginComponentForSide
(
side
)
=
=
0
"
Expecting
auto
margins
to
have
value
'
0
'
before
we
"
"
resolve
them
"
)
;
aItem
.
SetMarginComponentForSide
(
side
curAutoMarginSize
)
;
mNumAutoMarginsInMainAxis
-
-
;
mPackingSpaceRemaining
-
=
curAutoMarginSize
;
}
}
}
}
void
MainAxisPositionTracker
:
:
TraversePackingSpace
(
)
{
if
(
mNumPackingSpacesRemaining
)
{
MOZ_ASSERT
(
mJustifyContent
=
=
NS_STYLE_JUSTIFY_SPACE_BETWEEN
|
|
mJustifyContent
=
=
NS_STYLE_JUSTIFY_SPACE_AROUND
|
|
mJustifyContent
=
=
NS_STYLE_JUSTIFY_SPACE_EVENLY
"
mNumPackingSpacesRemaining
only
applies
for
"
"
space
-
between
/
space
-
around
/
space
-
evenly
"
)
;
MOZ_ASSERT
(
mPackingSpaceRemaining
>
=
0
"
ran
out
of
packing
space
earlier
than
we
expected
"
)
;
nscoord
curPackingSpace
=
mPackingSpaceRemaining
/
mNumPackingSpacesRemaining
;
mPosition
+
=
curPackingSpace
;
mNumPackingSpacesRemaining
-
-
;
mPackingSpaceRemaining
-
=
curPackingSpace
;
}
}
CrossAxisPositionTracker
:
:
CrossAxisPositionTracker
(
FlexLine
*
aFirstLine
const
ReflowInput
&
aReflowInput
nscoord
aContentBoxCrossSize
bool
aIsCrossSizeDefinite
const
FlexboxAxisTracker
&
aAxisTracker
)
:
PositionTracker
(
aAxisTracker
.
GetCrossAxis
(
)
aAxisTracker
.
IsCrossAxisReversed
(
)
)
mPackingSpaceRemaining
(
0
)
mNumPackingSpacesRemaining
(
0
)
mAlignContent
(
aReflowInput
.
mStylePosition
-
>
mAlignContent
)
{
MOZ_ASSERT
(
aFirstLine
"
null
first
line
pointer
"
)
;
if
(
mAlignContent
=
=
NS_STYLE_ALIGN_NORMAL
)
{
mAlignContent
=
NS_STYLE_ALIGN_STRETCH
;
}
mAlignContent
&
=
~
NS_STYLE_ALIGN_FLAG_BITS
;
const
bool
isSingleLine
=
NS_STYLE_FLEX_WRAP_NOWRAP
=
=
aReflowInput
.
mStylePosition
-
>
mFlexWrap
;
if
(
isSingleLine
)
{
MOZ_ASSERT
(
!
aFirstLine
-
>
getNext
(
)
"
If
we
'
re
styled
as
single
-
line
we
should
only
have
1
line
"
)
;
if
(
aIsCrossSizeDefinite
)
{
aFirstLine
-
>
SetLineCrossSize
(
aContentBoxCrossSize
)
;
return
;
}
aFirstLine
-
>
SetLineCrossSize
(
NS_CSS_MINMAX
(
aFirstLine
-
>
GetLineCrossSize
(
)
aReflowInput
.
ComputedMinBSize
(
)
aReflowInput
.
ComputedMaxBSize
(
)
)
)
;
}
mPackingSpaceRemaining
=
aContentBoxCrossSize
;
uint32_t
numLines
=
0
;
for
(
FlexLine
*
line
=
aFirstLine
;
line
;
line
=
line
-
>
getNext
(
)
)
{
mPackingSpaceRemaining
-
=
line
-
>
GetLineCrossSize
(
)
;
numLines
+
+
;
}
if
(
mPackingSpaceRemaining
<
0
)
{
if
(
mAlignContent
=
=
NS_STYLE_ALIGN_SPACE_BETWEEN
|
|
mAlignContent
=
=
NS_STYLE_ALIGN_STRETCH
)
{
mAlignContent
=
NS_STYLE_ALIGN_FLEX_START
;
}
else
if
(
mAlignContent
=
=
NS_STYLE_ALIGN_SPACE_AROUND
|
|
mAlignContent
=
=
NS_STYLE_ALIGN_SPACE_EVENLY
)
{
mAlignContent
=
NS_STYLE_ALIGN_CENTER
;
}
}
if
(
mAlignContent
=
=
NS_STYLE_ALIGN_LEFT
|
|
mAlignContent
=
=
NS_STYLE_ALIGN_RIGHT
)
{
if
(
aAxisTracker
.
IsRowOriented
(
)
)
{
mAlignContent
=
NS_STYLE_ALIGN_START
;
}
else
{
const
bool
isLTR
=
aAxisTracker
.
GetWritingMode
(
)
.
IsBidiLTR
(
)
;
const
bool
isAlignLeft
=
(
mAlignContent
=
=
NS_STYLE_ALIGN_LEFT
)
;
mAlignContent
=
(
isAlignLeft
=
=
isLTR
)
?
NS_STYLE_ALIGN_START
:
NS_STYLE_ALIGN_END
;
}
}
if
(
mAlignContent
=
=
NS_STYLE_ALIGN_START
)
{
mAlignContent
=
NS_STYLE_ALIGN_FLEX_START
;
}
else
if
(
mAlignContent
=
=
NS_STYLE_ALIGN_END
)
{
mAlignContent
=
NS_STYLE_ALIGN_FLEX_END
;
}
if
(
aAxisTracker
.
AreAxesInternallyReversed
(
)
)
{
if
(
mAlignContent
=
=
NS_STYLE_ALIGN_FLEX_START
)
{
mAlignContent
=
NS_STYLE_ALIGN_FLEX_END
;
}
else
if
(
mAlignContent
=
=
NS_STYLE_ALIGN_FLEX_END
)
{
mAlignContent
=
NS_STYLE_ALIGN_FLEX_START
;
}
}
if
(
mPackingSpaceRemaining
!
=
0
)
{
switch
(
mAlignContent
)
{
case
NS_STYLE_ALIGN_SELF_START
:
case
NS_STYLE_ALIGN_SELF_END
:
case
NS_STYLE_ALIGN_BASELINE
:
case
NS_STYLE_ALIGN_LAST_BASELINE
:
NS_WARNING
(
"
NYI
:
align
-
items
/
align
-
self
:
left
/
right
/
self
-
start
/
self
-
end
/
baseline
/
last
baseline
"
)
;
MOZ_FALLTHROUGH
;
case
NS_STYLE_ALIGN_FLEX_START
:
break
;
case
NS_STYLE_ALIGN_FLEX_END
:
mPosition
+
=
mPackingSpaceRemaining
;
break
;
case
NS_STYLE_ALIGN_CENTER
:
mPosition
+
=
mPackingSpaceRemaining
/
2
;
break
;
case
NS_STYLE_ALIGN_SPACE_BETWEEN
:
case
NS_STYLE_ALIGN_SPACE_AROUND
:
case
NS_STYLE_ALIGN_SPACE_EVENLY
:
nsFlexContainerFrame
:
:
CalculatePackingSpace
(
numLines
mAlignContent
&
mPosition
&
mNumPackingSpacesRemaining
&
mPackingSpaceRemaining
)
;
break
;
case
NS_STYLE_ALIGN_STRETCH
:
{
MOZ_ASSERT
(
mPackingSpaceRemaining
>
0
"
negative
packing
space
should
make
us
use
'
flex
-
start
'
"
"
instead
of
'
stretch
'
(
and
we
shouldn
'
t
bother
with
this
"
"
code
if
we
have
0
packing
space
)
"
)
;
uint32_t
numLinesLeft
=
numLines
;
for
(
FlexLine
*
line
=
aFirstLine
;
line
;
line
=
line
-
>
getNext
(
)
)
{
MOZ_ASSERT
(
numLinesLeft
>
0
"
miscalculated
num
lines
"
)
;
nscoord
shareOfExtraSpace
=
mPackingSpaceRemaining
/
numLinesLeft
;
nscoord
newSize
=
line
-
>
GetLineCrossSize
(
)
+
shareOfExtraSpace
;
line
-
>
SetLineCrossSize
(
newSize
)
;
mPackingSpaceRemaining
-
=
shareOfExtraSpace
;
numLinesLeft
-
-
;
}
MOZ_ASSERT
(
numLinesLeft
=
=
0
"
miscalculated
num
lines
"
)
;
break
;
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
align
-
content
value
"
)
;
}
}
}
void
CrossAxisPositionTracker
:
:
TraversePackingSpace
(
)
{
if
(
mNumPackingSpacesRemaining
)
{
MOZ_ASSERT
(
mAlignContent
=
=
NS_STYLE_ALIGN_SPACE_BETWEEN
|
|
mAlignContent
=
=
NS_STYLE_ALIGN_SPACE_AROUND
|
|
mAlignContent
=
=
NS_STYLE_ALIGN_SPACE_EVENLY
"
mNumPackingSpacesRemaining
only
applies
for
"
"
space
-
between
/
space
-
around
/
space
-
evenly
"
)
;
MOZ_ASSERT
(
mPackingSpaceRemaining
>
=
0
"
ran
out
of
packing
space
earlier
than
we
expected
"
)
;
nscoord
curPackingSpace
=
mPackingSpaceRemaining
/
mNumPackingSpacesRemaining
;
mPosition
+
=
curPackingSpace
;
mNumPackingSpacesRemaining
-
-
;
mPackingSpaceRemaining
-
=
curPackingSpace
;
}
}
SingleLineCrossAxisPositionTracker
:
:
SingleLineCrossAxisPositionTracker
(
const
FlexboxAxisTracker
&
aAxisTracker
)
:
PositionTracker
(
aAxisTracker
.
GetCrossAxis
(
)
aAxisTracker
.
IsCrossAxisReversed
(
)
)
{
}
void
FlexLine
:
:
ComputeCrossSizeAndBaseline
(
const
FlexboxAxisTracker
&
aAxisTracker
)
{
nscoord
crossStartToFurthestFirstBaseline
=
nscoord_MIN
;
nscoord
crossEndToFurthestFirstBaseline
=
nscoord_MIN
;
nscoord
crossStartToFurthestLastBaseline
=
nscoord_MIN
;
nscoord
crossEndToFurthestLastBaseline
=
nscoord_MIN
;
nscoord
largestOuterCrossSize
=
0
;
for
(
const
FlexItem
*
item
=
mItems
.
getFirst
(
)
;
item
;
item
=
item
-
>
getNext
(
)
)
{
nscoord
curOuterCrossSize
=
item
-
>
GetOuterCrossSize
(
aAxisTracker
.
GetCrossAxis
(
)
)
;
if
(
(
item
-
>
GetAlignSelf
(
)
=
=
NS_STYLE_ALIGN_BASELINE
|
|
item
-
>
GetAlignSelf
(
)
=
=
NS_STYLE_ALIGN_LAST_BASELINE
)
&
&
item
-
>
GetNumAutoMarginsInAxis
(
aAxisTracker
.
GetCrossAxis
(
)
)
=
=
0
)
{
const
bool
useFirst
=
(
item
-
>
GetAlignSelf
(
)
=
=
NS_STYLE_ALIGN_BASELINE
)
;
nscoord
crossStartToBaseline
=
item
-
>
GetBaselineOffsetFromOuterCrossEdge
(
eAxisEdge_Start
aAxisTracker
useFirst
)
;
nscoord
crossEndToBaseline
=
curOuterCrossSize
-
crossStartToBaseline
;
if
(
useFirst
)
{
crossStartToFurthestFirstBaseline
=
std
:
:
max
(
crossStartToFurthestFirstBaseline
crossStartToBaseline
)
;
crossEndToFurthestFirstBaseline
=
std
:
:
max
(
crossEndToFurthestFirstBaseline
crossEndToBaseline
)
;
}
else
{
crossStartToFurthestLastBaseline
=
std
:
:
max
(
crossStartToFurthestLastBaseline
crossStartToBaseline
)
;
crossEndToFurthestLastBaseline
=
std
:
:
max
(
crossEndToFurthestLastBaseline
crossEndToBaseline
)
;
}
}
else
{
largestOuterCrossSize
=
std
:
:
max
(
largestOuterCrossSize
curOuterCrossSize
)
;
}
}
mFirstBaselineOffset
=
aAxisTracker
.
AreAxesInternallyReversed
(
)
?
crossEndToFurthestFirstBaseline
:
crossStartToFurthestFirstBaseline
;
mLastBaselineOffset
=
aAxisTracker
.
AreAxesInternallyReversed
(
)
?
crossStartToFurthestLastBaseline
:
crossEndToFurthestLastBaseline
;
mLineCrossSize
=
std
:
:
max
(
std
:
:
max
(
crossStartToFurthestFirstBaseline
+
crossEndToFurthestFirstBaseline
crossStartToFurthestLastBaseline
+
crossEndToFurthestLastBaseline
)
largestOuterCrossSize
)
;
}
void
FlexItem
:
:
ResolveStretchedCrossSize
(
nscoord
aLineCrossSize
const
FlexboxAxisTracker
&
aAxisTracker
)
{
AxisOrientationType
crossAxis
=
aAxisTracker
.
GetCrossAxis
(
)
;
if
(
mAlignSelf
!
=
NS_STYLE_ALIGN_STRETCH
|
|
GetNumAutoMarginsInAxis
(
crossAxis
)
!
=
0
|
|
eStyleUnit_Auto
!
=
aAxisTracker
.
ComputedCrossSize
(
mFrame
)
.
GetUnit
(
)
)
{
return
;
}
if
(
mIsStretched
)
{
return
;
}
nscoord
stretchedSize
=
aLineCrossSize
-
GetMarginBorderPaddingSizeInAxis
(
crossAxis
)
;
stretchedSize
=
NS_CSS_MINMAX
(
stretchedSize
mCrossMinSize
mCrossMaxSize
)
;
SetCrossSize
(
stretchedSize
)
;
mIsStretched
=
true
;
}
void
SingleLineCrossAxisPositionTracker
:
:
ResolveAutoMarginsInCrossAxis
(
const
FlexLine
&
aLine
FlexItem
&
aItem
)
{
nscoord
spaceForAutoMargins
=
aLine
.
GetLineCrossSize
(
)
-
aItem
.
GetOuterCrossSize
(
mAxis
)
;
if
(
spaceForAutoMargins
<
=
0
)
{
return
;
}
uint32_t
numAutoMargins
=
aItem
.
GetNumAutoMarginsInAxis
(
mAxis
)
;
if
(
numAutoMargins
=
=
0
)
{
return
;
}
const
nsStyleSides
&
styleMargin
=
aItem
.
Frame
(
)
-
>
StyleMargin
(
)
-
>
mMargin
;
for
(
uint32_t
i
=
0
;
i
<
eNumAxisEdges
;
i
+
+
)
{
mozilla
:
:
Side
side
=
kAxisOrientationToSidesMap
[
mAxis
]
[
i
]
;
if
(
styleMargin
.
GetUnit
(
side
)
=
=
eStyleUnit_Auto
)
{
MOZ_ASSERT
(
aItem
.
GetMarginComponentForSide
(
side
)
=
=
0
"
Expecting
auto
margins
to
have
value
'
0
'
before
we
"
"
update
them
"
)
;
nscoord
curAutoMarginSize
=
spaceForAutoMargins
/
numAutoMargins
;
aItem
.
SetMarginComponentForSide
(
side
curAutoMarginSize
)
;
numAutoMargins
-
-
;
spaceForAutoMargins
-
=
curAutoMarginSize
;
}
}
}
void
SingleLineCrossAxisPositionTracker
:
:
EnterAlignPackingSpace
(
const
FlexLine
&
aLine
const
FlexItem
&
aItem
const
FlexboxAxisTracker
&
aAxisTracker
)
{
if
(
aItem
.
GetNumAutoMarginsInAxis
(
mAxis
)
)
{
return
;
}
uint8_t
alignSelf
=
aItem
.
GetAlignSelf
(
)
;
if
(
alignSelf
=
=
NS_STYLE_ALIGN_STRETCH
)
{
alignSelf
=
NS_STYLE_ALIGN_FLEX_START
;
}
if
(
alignSelf
=
=
NS_STYLE_ALIGN_LEFT
|
|
alignSelf
=
=
NS_STYLE_ALIGN_RIGHT
)
{
if
(
aAxisTracker
.
IsRowOriented
(
)
)
{
alignSelf
=
NS_STYLE_ALIGN_START
;
}
else
{
const
bool
isLTR
=
aAxisTracker
.
GetWritingMode
(
)
.
IsBidiLTR
(
)
;
const
bool
isAlignLeft
=
(
alignSelf
=
=
NS_STYLE_ALIGN_LEFT
)
;
alignSelf
=
(
isAlignLeft
=
=
isLTR
)
?
NS_STYLE_ALIGN_START
:
NS_STYLE_ALIGN_END
;
}
}
if
(
alignSelf
=
=
NS_STYLE_ALIGN_START
)
{
alignSelf
=
NS_STYLE_ALIGN_FLEX_START
;
}
else
if
(
alignSelf
=
=
NS_STYLE_ALIGN_END
)
{
alignSelf
=
NS_STYLE_ALIGN_FLEX_END
;
}
if
(
aAxisTracker
.
AreAxesInternallyReversed
(
)
)
{
if
(
alignSelf
=
=
NS_STYLE_ALIGN_FLEX_START
)
{
alignSelf
=
NS_STYLE_ALIGN_FLEX_END
;
}
else
if
(
alignSelf
=
=
NS_STYLE_ALIGN_FLEX_END
)
{
alignSelf
=
NS_STYLE_ALIGN_FLEX_START
;
}
}
switch
(
alignSelf
)
{
case
NS_STYLE_ALIGN_SELF_START
:
case
NS_STYLE_ALIGN_SELF_END
:
NS_WARNING
(
"
NYI
:
align
-
items
/
align
-
self
:
left
/
right
/
self
-
start
/
self
-
end
"
)
;
MOZ_FALLTHROUGH
;
case
NS_STYLE_ALIGN_FLEX_START
:
break
;
case
NS_STYLE_ALIGN_FLEX_END
:
mPosition
+
=
aLine
.
GetLineCrossSize
(
)
-
aItem
.
GetOuterCrossSize
(
mAxis
)
;
break
;
case
NS_STYLE_ALIGN_CENTER
:
mPosition
+
=
(
aLine
.
GetLineCrossSize
(
)
-
aItem
.
GetOuterCrossSize
(
mAxis
)
)
/
2
;
break
;
case
NS_STYLE_ALIGN_BASELINE
:
case
NS_STYLE_ALIGN_LAST_BASELINE
:
{
const
bool
useFirst
=
(
alignSelf
=
=
NS_STYLE_ALIGN_BASELINE
)
;
AxisEdgeType
baselineAlignEdge
=
aAxisTracker
.
AreAxesInternallyReversed
(
)
=
=
useFirst
?
eAxisEdge_End
:
eAxisEdge_Start
;
nscoord
itemBaselineOffset
=
aItem
.
GetBaselineOffsetFromOuterCrossEdge
(
baselineAlignEdge
aAxisTracker
useFirst
)
;
nscoord
lineBaselineOffset
=
useFirst
?
aLine
.
GetFirstBaselineOffset
(
)
:
aLine
.
GetLastBaselineOffset
(
)
;
NS_ASSERTION
(
lineBaselineOffset
>
=
itemBaselineOffset
"
failed
at
finding
largest
baseline
offset
"
)
;
nscoord
baselineDiff
=
lineBaselineOffset
-
itemBaselineOffset
;
if
(
aAxisTracker
.
AreAxesInternallyReversed
(
)
=
=
useFirst
)
{
mPosition
+
=
aLine
.
GetLineCrossSize
(
)
-
aItem
.
GetOuterCrossSize
(
mAxis
)
;
mPosition
-
=
baselineDiff
;
}
else
{
mPosition
+
=
baselineDiff
;
}
break
;
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
align
-
self
value
"
)
;
break
;
}
}
static
inline
AxisOrientationType
InlineDirToAxisOrientation
(
WritingMode
:
:
InlineDir
aInlineDir
)
{
switch
(
aInlineDir
)
{
case
WritingMode
:
:
eInlineLTR
:
return
eAxis_LR
;
case
WritingMode
:
:
eInlineRTL
:
return
eAxis_RL
;
case
WritingMode
:
:
eInlineTTB
:
return
eAxis_TB
;
case
WritingMode
:
:
eInlineBTT
:
return
eAxis_BT
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unhandled
InlineDir
"
)
;
return
eAxis_LR
;
}
static
inline
AxisOrientationType
BlockDirToAxisOrientation
(
WritingMode
:
:
BlockDir
aBlockDir
)
{
switch
(
aBlockDir
)
{
case
WritingMode
:
:
eBlockLR
:
return
eAxis_LR
;
case
WritingMode
:
:
eBlockRL
:
return
eAxis_RL
;
case
WritingMode
:
:
eBlockTB
:
return
eAxis_TB
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unhandled
BlockDir
"
)
;
return
eAxis_TB
;
}
FlexboxAxisTracker
:
:
FlexboxAxisTracker
(
const
nsFlexContainerFrame
*
aFlexContainer
const
WritingMode
&
aWM
AxisTrackerFlags
aFlags
)
:
mWM
(
aWM
)
mAreAxesInternallyReversed
(
false
)
{
if
(
IsLegacyBox
(
aFlexContainer
)
)
{
InitAxesFromLegacyProps
(
aFlexContainer
)
;
}
else
{
InitAxesFromModernProps
(
aFlexContainer
)
;
}
static
bool
sPreventBottomToTopChildOrdering
=
true
;
if
(
!
(
aFlags
&
AxisTrackerFlags
:
:
eAllowBottomToTopChildOrdering
)
&
&
sPreventBottomToTopChildOrdering
)
{
if
(
eAxis_BT
=
=
mMainAxis
|
|
eAxis_BT
=
=
mCrossAxis
)
{
mMainAxis
=
GetReverseAxis
(
mMainAxis
)
;
mCrossAxis
=
GetReverseAxis
(
mCrossAxis
)
;
mAreAxesInternallyReversed
=
true
;
mIsMainAxisReversed
=
!
mIsMainAxisReversed
;
mIsCrossAxisReversed
=
!
mIsCrossAxisReversed
;
}
}
}
void
FlexboxAxisTracker
:
:
InitAxesFromLegacyProps
(
const
nsFlexContainerFrame
*
aFlexContainer
)
{
const
nsStyleXUL
*
styleXUL
=
aFlexContainer
-
>
StyleXUL
(
)
;
const
bool
boxOrientIsVertical
=
(
styleXUL
-
>
mBoxOrient
=
=
StyleBoxOrient
:
:
Vertical
)
;
const
bool
wmIsVertical
=
mWM
.
IsVertical
(
)
;
mIsRowOriented
=
(
boxOrientIsVertical
=
=
wmIsVertical
)
;
if
(
boxOrientIsVertical
)
{
mMainAxis
=
eAxis_TB
;
mCrossAxis
=
eAxis_LR
;
}
else
{
mMainAxis
=
eAxis_LR
;
mCrossAxis
=
eAxis_TB
;
}
if
(
!
mWM
.
IsBidiLTR
(
)
)
{
AxisOrientationType
&
axisToFlip
=
mIsRowOriented
?
mMainAxis
:
mCrossAxis
;
axisToFlip
=
GetReverseAxis
(
axisToFlip
)
;
}
if
(
styleXUL
-
>
mBoxDirection
=
=
StyleBoxDirection
:
:
Reverse
)
{
mMainAxis
=
GetReverseAxis
(
mMainAxis
)
;
mIsMainAxisReversed
=
true
;
}
else
{
mIsMainAxisReversed
=
false
;
}
mIsCrossAxisReversed
=
false
;
}
void
FlexboxAxisTracker
:
:
InitAxesFromModernProps
(
const
nsFlexContainerFrame
*
aFlexContainer
)
{
const
nsStylePosition
*
stylePos
=
aFlexContainer
-
>
StylePosition
(
)
;
uint32_t
flexDirection
=
stylePos
-
>
mFlexDirection
;
AxisOrientationType
inlineDimension
=
InlineDirToAxisOrientation
(
mWM
.
GetInlineDir
(
)
)
;
AxisOrientationType
blockDimension
=
BlockDirToAxisOrientation
(
mWM
.
GetBlockDir
(
)
)
;
switch
(
flexDirection
)
{
case
NS_STYLE_FLEX_DIRECTION_ROW
:
mMainAxis
=
inlineDimension
;
mIsRowOriented
=
true
;
mIsMainAxisReversed
=
false
;
break
;
case
NS_STYLE_FLEX_DIRECTION_ROW_REVERSE
:
mMainAxis
=
GetReverseAxis
(
inlineDimension
)
;
mIsRowOriented
=
true
;
mIsMainAxisReversed
=
true
;
break
;
case
NS_STYLE_FLEX_DIRECTION_COLUMN
:
mMainAxis
=
blockDimension
;
mIsRowOriented
=
false
;
mIsMainAxisReversed
=
false
;
break
;
case
NS_STYLE_FLEX_DIRECTION_COLUMN_REVERSE
:
mMainAxis
=
GetReverseAxis
(
blockDimension
)
;
mIsRowOriented
=
false
;
mIsMainAxisReversed
=
true
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
flex
-
direction
value
"
)
;
}
if
(
flexDirection
=
=
NS_STYLE_FLEX_DIRECTION_COLUMN
|
|
flexDirection
=
=
NS_STYLE_FLEX_DIRECTION_COLUMN_REVERSE
)
{
mCrossAxis
=
inlineDimension
;
}
else
{
mCrossAxis
=
blockDimension
;
}
if
(
stylePos
-
>
mFlexWrap
=
=
NS_STYLE_FLEX_WRAP_WRAP_REVERSE
)
{
mCrossAxis
=
GetReverseAxis
(
mCrossAxis
)
;
mIsCrossAxisReversed
=
true
;
}
else
{
mIsCrossAxisReversed
=
false
;
}
}
static
FlexLine
*
AddNewFlexLineToList
(
LinkedList
<
FlexLine
>
&
aLines
bool
aShouldInsertAtFront
)
{
FlexLine
*
newLine
=
new
FlexLine
(
)
;
if
(
aShouldInsertAtFront
)
{
aLines
.
insertFront
(
newLine
)
;
}
else
{
aLines
.
insertBack
(
newLine
)
;
}
return
newLine
;
}
void
nsFlexContainerFrame
:
:
GenerateFlexLines
(
nsPresContext
*
aPresContext
const
ReflowInput
&
aReflowInput
nscoord
aContentBoxMainSize
nscoord
aAvailableBSizeForContent
const
nsTArray
<
StrutInfo
>
&
aStruts
const
FlexboxAxisTracker
&
aAxisTracker
nsTArray
<
nsIFrame
*
>
&
aPlaceholders
LinkedList
<
FlexLine
>
&
aLines
)
{
MOZ_ASSERT
(
aLines
.
isEmpty
(
)
"
Expecting
outparam
to
start
out
empty
"
)
;
const
bool
isSingleLine
=
NS_STYLE_FLEX_WRAP_NOWRAP
=
=
aReflowInput
.
mStylePosition
-
>
mFlexWrap
;
const
bool
shouldInsertAtFront
=
aAxisTracker
.
AreAxesInternallyReversed
(
)
;
FlexLine
*
curLine
=
AddNewFlexLineToList
(
aLines
shouldInsertAtFront
)
;
nscoord
wrapThreshold
;
if
(
isSingleLine
)
{
wrapThreshold
=
NS_UNCONSTRAINEDSIZE
;
}
else
{
wrapThreshold
=
aContentBoxMainSize
;
if
(
wrapThreshold
=
=
NS_UNCONSTRAINEDSIZE
)
{
const
nscoord
flexContainerMaxMainSize
=
GET_MAIN_COMPONENT_LOGICAL
(
aAxisTracker
aAxisTracker
.
GetWritingMode
(
)
aReflowInput
.
ComputedMaxISize
(
)
aReflowInput
.
ComputedMaxBSize
(
)
)
;
wrapThreshold
=
flexContainerMaxMainSize
;
}
if
(
aAxisTracker
.
IsColumnOriented
(
)
&
&
aAvailableBSizeForContent
!
=
NS_UNCONSTRAINEDSIZE
)
{
wrapThreshold
=
std
:
:
min
(
wrapThreshold
aAvailableBSizeForContent
)
;
}
}
uint32_t
nextStrutIdx
=
0
;
uint32_t
itemIdxInContainer
=
0
;
CSSOrderAwareFrameIterator
iter
(
this
kPrincipalList
CSSOrderAwareFrameIterator
:
:
eIncludeAll
CSSOrderAwareFrameIterator
:
:
eUnknownOrder
OrderingPropertyForIter
(
this
)
)
;
if
(
iter
.
ItemsAreAlreadyInOrder
(
)
)
{
RemoveStateBits
(
NS_STATE_FLEX_CHILDREN_REORDERED
)
;
}
else
{
AddStateBits
(
NS_STATE_FLEX_CHILDREN_REORDERED
)
;
}
for
(
;
!
iter
.
AtEnd
(
)
;
iter
.
Next
(
)
)
{
nsIFrame
*
childFrame
=
*
iter
;
if
(
childFrame
-
>
GetType
(
)
=
=
nsGkAtoms
:
:
placeholderFrame
)
{
aPlaceholders
.
AppendElement
(
childFrame
)
;
continue
;
}
if
(
!
isSingleLine
&
&
!
curLine
-
>
IsEmpty
(
)
&
&
childFrame
-
>
StyleDisplay
(
)
-
>
mBreakBefore
)
{
curLine
=
AddNewFlexLineToList
(
aLines
shouldInsertAtFront
)
;
}
UniquePtr
<
FlexItem
>
item
;
if
(
nextStrutIdx
<
aStruts
.
Length
(
)
&
&
aStruts
[
nextStrutIdx
]
.
mItemIdx
=
=
itemIdxInContainer
)
{
item
=
MakeUnique
<
FlexItem
>
(
childFrame
aStruts
[
nextStrutIdx
]
.
mStrutCrossSize
aReflowInput
.
GetWritingMode
(
)
)
;
nextStrutIdx
+
+
;
}
else
{
item
=
GenerateFlexItemForChild
(
aPresContext
childFrame
aReflowInput
aAxisTracker
)
;
}
nscoord
itemInnerHypotheticalMainSize
=
item
-
>
GetMainSize
(
)
;
nscoord
itemOuterHypotheticalMainSize
=
item
-
>
GetOuterMainSize
(
aAxisTracker
.
GetMainAxis
(
)
)
;
if
(
wrapThreshold
!
=
NS_UNCONSTRAINEDSIZE
&
&
!
curLine
-
>
IsEmpty
(
)
&
&
wrapThreshold
<
(
curLine
-
>
GetTotalOuterHypotheticalMainSize
(
)
+
itemOuterHypotheticalMainSize
)
)
{
curLine
=
AddNewFlexLineToList
(
aLines
shouldInsertAtFront
)
;
}
curLine
-
>
AddItem
(
item
.
release
(
)
shouldInsertAtFront
itemInnerHypotheticalMainSize
itemOuterHypotheticalMainSize
)
;
if
(
!
isSingleLine
&
&
childFrame
-
>
GetNextSibling
(
)
&
&
childFrame
-
>
StyleDisplay
(
)
-
>
mBreakAfter
)
{
curLine
=
AddNewFlexLineToList
(
aLines
shouldInsertAtFront
)
;
}
itemIdxInContainer
+
+
;
}
}
nscoord
nsFlexContainerFrame
:
:
GetMainSizeFromReflowInput
(
const
ReflowInput
&
aReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
)
{
if
(
aAxisTracker
.
IsRowOriented
(
)
)
{
NS_WARNING_ASSERTION
(
aReflowInput
.
ComputedISize
(
)
!
=
NS_UNCONSTRAINEDSIZE
"
Unconstrained
inline
size
;
this
should
only
result
from
huge
sizes
"
"
(
not
intrinsic
sizing
w
/
orthogonal
flows
)
"
)
;
return
aReflowInput
.
ComputedISize
(
)
;
}
return
GetEffectiveComputedBSize
(
aReflowInput
)
;
}
static
nscoord
GetLargestLineMainSize
(
const
FlexLine
*
aFirstLine
)
{
nscoord
largestLineOuterSize
=
0
;
for
(
const
FlexLine
*
line
=
aFirstLine
;
line
;
line
=
line
-
>
getNext
(
)
)
{
largestLineOuterSize
=
std
:
:
max
(
largestLineOuterSize
line
-
>
GetTotalOuterHypotheticalMainSize
(
)
)
;
}
return
largestLineOuterSize
;
}
static
nscoord
ResolveFlexContainerMainSize
(
const
ReflowInput
&
aReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
nscoord
aTentativeMainSize
nscoord
aAvailableBSizeForContent
const
FlexLine
*
aFirstLine
nsReflowStatus
&
aStatus
)
{
MOZ_ASSERT
(
aFirstLine
"
null
first
line
pointer
"
)
;
if
(
aAxisTracker
.
IsRowOriented
(
)
)
{
return
aTentativeMainSize
;
}
if
(
aTentativeMainSize
!
=
NS_INTRINSICSIZE
)
{
if
(
aAvailableBSizeForContent
=
=
NS_UNCONSTRAINEDSIZE
|
|
aTentativeMainSize
<
aAvailableBSizeForContent
)
{
return
aTentativeMainSize
;
}
aStatus
.
SetIncomplete
(
)
;
nscoord
largestLineOuterSize
=
GetLargestLineMainSize
(
aFirstLine
)
;
if
(
largestLineOuterSize
<
=
aAvailableBSizeForContent
)
{
return
aAvailableBSizeForContent
;
}
return
std
:
:
min
(
aTentativeMainSize
largestLineOuterSize
)
;
}
nscoord
largestLineOuterSize
=
GetLargestLineMainSize
(
aFirstLine
)
;
return
NS_CSS_MINMAX
(
largestLineOuterSize
aReflowInput
.
ComputedMinBSize
(
)
aReflowInput
.
ComputedMaxBSize
(
)
)
;
}
nscoord
nsFlexContainerFrame
:
:
ComputeCrossSize
(
const
ReflowInput
&
aReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
nscoord
aSumLineCrossSizes
nscoord
aAvailableBSizeForContent
bool
*
aIsDefinite
nsReflowStatus
&
aStatus
)
{
MOZ_ASSERT
(
aIsDefinite
"
outparam
pointer
must
be
non
-
null
"
)
;
if
(
aAxisTracker
.
IsColumnOriented
(
)
)
{
NS_WARNING_ASSERTION
(
aReflowInput
.
ComputedISize
(
)
!
=
NS_UNCONSTRAINEDSIZE
"
Unconstrained
inline
size
;
this
should
only
result
from
huge
sizes
"
"
(
not
intrinsic
sizing
w
/
orthogonal
flows
)
"
)
;
*
aIsDefinite
=
true
;
return
aReflowInput
.
ComputedISize
(
)
;
}
nscoord
effectiveComputedBSize
=
GetEffectiveComputedBSize
(
aReflowInput
)
;
if
(
effectiveComputedBSize
!
=
NS_INTRINSICSIZE
)
{
*
aIsDefinite
=
true
;
if
(
aAvailableBSizeForContent
=
=
NS_UNCONSTRAINEDSIZE
|
|
effectiveComputedBSize
<
aAvailableBSizeForContent
)
{
return
effectiveComputedBSize
;
}
aStatus
.
SetIncomplete
(
)
;
if
(
aSumLineCrossSizes
<
=
aAvailableBSizeForContent
)
{
return
aAvailableBSizeForContent
;
}
return
std
:
:
min
(
effectiveComputedBSize
aSumLineCrossSizes
)
;
}
*
aIsDefinite
=
false
;
return
NS_CSS_MINMAX
(
aSumLineCrossSizes
aReflowInput
.
ComputedMinBSize
(
)
aReflowInput
.
ComputedMaxBSize
(
)
)
;
}
void
FlexLine
:
:
PositionItemsInMainAxis
(
uint8_t
aJustifyContent
nscoord
aContentBoxMainSize
const
FlexboxAxisTracker
&
aAxisTracker
)
{
MainAxisPositionTracker
mainAxisPosnTracker
(
aAxisTracker
this
aJustifyContent
aContentBoxMainSize
)
;
for
(
FlexItem
*
item
=
mItems
.
getFirst
(
)
;
item
;
item
=
item
-
>
getNext
(
)
)
{
nscoord
itemMainBorderBoxSize
=
item
-
>
GetMainSize
(
)
+
item
-
>
GetBorderPaddingSizeInAxis
(
mainAxisPosnTracker
.
GetAxis
(
)
)
;
mainAxisPosnTracker
.
ResolveAutoMarginsInMainAxis
(
*
item
)
;
mainAxisPosnTracker
.
EnterMargin
(
item
-
>
GetMargin
(
)
)
;
mainAxisPosnTracker
.
EnterChildFrame
(
itemMainBorderBoxSize
)
;
item
-
>
SetMainPosition
(
mainAxisPosnTracker
.
GetPosition
(
)
)
;
mainAxisPosnTracker
.
ExitChildFrame
(
itemMainBorderBoxSize
)
;
mainAxisPosnTracker
.
ExitMargin
(
item
-
>
GetMargin
(
)
)
;
mainAxisPosnTracker
.
TraversePackingSpace
(
)
;
}
}
static
nscoord
ComputePhysicalAscentFromFlexRelativeAscent
(
nscoord
aFlexRelativeAscent
nscoord
aContentBoxCrossSize
const
ReflowInput
&
aReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
)
{
return
aReflowInput
.
ComputedPhysicalBorderPadding
(
)
.
top
+
PhysicalCoordFromFlexRelativeCoord
(
aFlexRelativeAscent
aContentBoxCrossSize
aAxisTracker
.
GetCrossAxis
(
)
)
;
}
void
nsFlexContainerFrame
:
:
SizeItemInCrossAxis
(
nsPresContext
*
aPresContext
const
FlexboxAxisTracker
&
aAxisTracker
ReflowInput
&
aChildReflowInput
FlexItem
&
aItem
)
{
if
(
aAxisTracker
.
IsCrossAxisHorizontal
(
)
)
{
MOZ_ASSERT
(
aItem
.
HasIntrinsicRatio
(
)
"
For
now
caller
'
s
CanMainSizeInfluenceCrossSize
check
should
"
"
only
allow
us
to
get
here
for
items
with
intrinsic
ratio
"
)
;
aItem
.
SetCrossSize
(
aChildReflowInput
.
ComputedWidth
(
)
)
;
return
;
}
MOZ_ASSERT
(
!
aItem
.
HadMeasuringReflow
(
)
"
We
shouldn
'
t
need
more
than
one
measuring
reflow
"
)
;
if
(
aItem
.
GetAlignSelf
(
)
=
=
NS_STYLE_ALIGN_STRETCH
)
{
aChildReflowInput
.
SetVResize
(
true
)
;
}
const
CachedMeasuringReflowResult
&
reflowResult
=
MeasureAscentAndHeightForFlexItem
(
aItem
aPresContext
aChildReflowInput
)
;
nscoord
crossAxisBorderPadding
=
aItem
.
GetBorderPadding
(
)
.
TopBottom
(
)
;
if
(
reflowResult
.
Height
(
)
<
crossAxisBorderPadding
)
{
NS_WARNING_ASSERTION
(
!
aItem
.
Frame
(
)
-
>
GetType
(
)
"
Child
should
at
least
request
space
for
border
/
padding
"
)
;
aItem
.
SetCrossSize
(
0
)
;
}
else
{
aItem
.
SetCrossSize
(
reflowResult
.
Height
(
)
-
crossAxisBorderPadding
)
;
}
aItem
.
SetAscent
(
reflowResult
.
Ascent
(
)
)
;
}
void
FlexLine
:
:
PositionItemsInCrossAxis
(
nscoord
aLineStartPosition
const
FlexboxAxisTracker
&
aAxisTracker
)
{
SingleLineCrossAxisPositionTracker
lineCrossAxisPosnTracker
(
aAxisTracker
)
;
for
(
FlexItem
*
item
=
mItems
.
getFirst
(
)
;
item
;
item
=
item
-
>
getNext
(
)
)
{
item
-
>
ResolveStretchedCrossSize
(
mLineCrossSize
aAxisTracker
)
;
lineCrossAxisPosnTracker
.
ResolveAutoMarginsInCrossAxis
(
*
this
*
item
)
;
nscoord
itemCrossBorderBoxSize
=
item
-
>
GetCrossSize
(
)
+
item
-
>
GetBorderPaddingSizeInAxis
(
aAxisTracker
.
GetCrossAxis
(
)
)
;
lineCrossAxisPosnTracker
.
EnterAlignPackingSpace
(
*
this
*
item
aAxisTracker
)
;
lineCrossAxisPosnTracker
.
EnterMargin
(
item
-
>
GetMargin
(
)
)
;
lineCrossAxisPosnTracker
.
EnterChildFrame
(
itemCrossBorderBoxSize
)
;
item
-
>
SetCrossPosition
(
aLineStartPosition
+
lineCrossAxisPosnTracker
.
GetPosition
(
)
)
;
lineCrossAxisPosnTracker
.
ResetPosition
(
)
;
}
}
void
nsFlexContainerFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsFlexContainerFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aDesiredSize
aStatus
)
;
MOZ_LOG
(
gFlexContainerLog
LogLevel
:
:
Debug
(
"
Reflow
(
)
for
nsFlexContainerFrame
%
p
\
n
"
this
)
)
;
if
(
IsFrameTreeTooDeep
(
aReflowInput
aDesiredSize
aStatus
)
)
{
return
;
}
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
const
nsStylePosition
*
stylePos
=
StylePosition
(
)
;
const
nsStyleCoord
&
bsize
=
stylePos
-
>
BSize
(
wm
)
;
if
(
bsize
.
HasPercent
(
)
|
|
(
StyleDisplay
(
)
-
>
IsAbsolutelyPositionedStyle
(
)
&
&
eStyleUnit_Auto
=
=
bsize
.
GetUnit
(
)
&
&
eStyleUnit_Auto
!
=
stylePos
-
>
mOffset
.
GetBStartUnit
(
wm
)
&
&
eStyleUnit_Auto
!
=
stylePos
-
>
mOffset
.
GetBEndUnit
(
wm
)
)
)
{
AddStateBits
(
NS_FRAME_CONTAINS_RELATIVE_BSIZE
)
;
}
RenumberList
(
)
;
const
FlexboxAxisTracker
axisTracker
(
this
aReflowInput
.
GetWritingMode
(
)
)
;
nscoord
availableBSizeForContent
=
aReflowInput
.
AvailableBSize
(
)
;
if
(
availableBSizeForContent
!
=
NS_UNCONSTRAINEDSIZE
&
&
!
(
GetLogicalSkipSides
(
&
aReflowInput
)
.
BStart
(
)
)
)
{
availableBSizeForContent
-
=
aReflowInput
.
ComputedLogicalBorderPadding
(
)
.
BStart
(
wm
)
;
availableBSizeForContent
=
std
:
:
max
(
availableBSizeForContent
0
)
;
}
nscoord
contentBoxMainSize
=
GetMainSizeFromReflowInput
(
aReflowInput
axisTracker
)
;
AutoTArray
<
StrutInfo
1
>
struts
;
DoFlexLayout
(
aPresContext
aDesiredSize
aReflowInput
aStatus
contentBoxMainSize
availableBSizeForContent
struts
axisTracker
)
;
if
(
!
struts
.
IsEmpty
(
)
)
{
DoFlexLayout
(
aPresContext
aDesiredSize
aReflowInput
aStatus
contentBoxMainSize
availableBSizeForContent
struts
axisTracker
)
;
}
}
class
MOZ_RAII
AutoFlexLineListClearer
{
public
:
explicit
AutoFlexLineListClearer
(
LinkedList
<
FlexLine
>
&
aLines
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mLines
(
aLines
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
}
~
AutoFlexLineListClearer
(
)
{
while
(
FlexLine
*
line
=
mLines
.
popFirst
(
)
)
{
while
(
FlexItem
*
item
=
line
-
>
mItems
.
popFirst
(
)
)
{
delete
item
;
}
delete
line
;
}
}
private
:
LinkedList
<
FlexLine
>
&
mLines
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
MOZ_RAII
AutoFlexItemMainSizeOverride
final
{
public
:
explicit
AutoFlexItemMainSizeOverride
(
FlexItem
&
aItem
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mItemProps
(
aItem
.
Frame
(
)
-
>
Properties
(
)
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
MOZ_ASSERT
(
!
mItemProps
.
Has
(
nsIFrame
:
:
FlexItemMainSizeOverride
(
)
)
"
FlexItemMainSizeOverride
prop
shouldn
'
t
be
set
already
;
"
"
it
should
only
be
set
temporarily
(
&
not
recursively
)
"
)
;
NS_ASSERTION
(
aItem
.
HasIntrinsicRatio
(
)
"
This
should
only
be
needed
for
items
with
an
aspect
ratio
"
)
;
mItemProps
.
Set
(
nsIFrame
:
:
FlexItemMainSizeOverride
(
)
aItem
.
GetMainSize
(
)
)
;
}
~
AutoFlexItemMainSizeOverride
(
)
{
mItemProps
.
Remove
(
nsIFrame
:
:
FlexItemMainSizeOverride
(
)
)
;
}
private
:
const
FrameProperties
mItemProps
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
void
nsFlexContainerFrame
:
:
CalculatePackingSpace
(
uint32_t
aNumThingsToPack
uint8_t
aAlignVal
nscoord
*
aFirstSubjectOffset
uint32_t
*
aNumPackingSpacesRemaining
nscoord
*
aPackingSpaceRemaining
)
{
MOZ_ASSERT
(
NS_STYLE_ALIGN_SPACE_BETWEEN
=
=
NS_STYLE_JUSTIFY_SPACE_BETWEEN
&
&
NS_STYLE_ALIGN_SPACE_AROUND
=
=
NS_STYLE_JUSTIFY_SPACE_AROUND
&
&
NS_STYLE_ALIGN_SPACE_EVENLY
=
=
NS_STYLE_JUSTIFY_SPACE_EVENLY
"
CalculatePackingSpace
assumes
that
NS_STYLE_ALIGN_SPACE
and
"
"
NS_STYLE_JUSTIFY_SPACE
constants
are
interchangeable
"
)
;
MOZ_ASSERT
(
aAlignVal
=
=
NS_STYLE_ALIGN_SPACE_BETWEEN
|
|
aAlignVal
=
=
NS_STYLE_ALIGN_SPACE_AROUND
|
|
aAlignVal
=
=
NS_STYLE_ALIGN_SPACE_EVENLY
"
Unexpected
alignment
value
"
)
;
MOZ_ASSERT
(
*
aPackingSpaceRemaining
>
=
0
"
Should
not
be
called
with
negative
packing
space
"
)
;
MOZ_ASSERT
(
aNumThingsToPack
>
=
1
"
Should
not
be
called
with
less
than
1
thing
to
pack
"
)
;
*
aNumPackingSpacesRemaining
=
aNumThingsToPack
-
1
;
if
(
aAlignVal
=
=
NS_STYLE_ALIGN_SPACE_BETWEEN
)
{
return
;
}
size_t
numPackingSpacesForEdges
=
aAlignVal
=
=
NS_STYLE_JUSTIFY_SPACE_AROUND
?
1
:
2
;
nscoord
packingSpaceSize
=
*
aPackingSpaceRemaining
/
(
*
aNumPackingSpacesRemaining
+
numPackingSpacesForEdges
)
;
nscoord
totalEdgePackingSpace
=
numPackingSpacesForEdges
*
packingSpaceSize
;
*
aFirstSubjectOffset
+
=
totalEdgePackingSpace
/
2
;
*
aPackingSpaceRemaining
-
=
totalEdgePackingSpace
;
}
void
nsFlexContainerFrame
:
:
DoFlexLayout
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
nscoord
aContentBoxMainSize
nscoord
aAvailableBSizeForContent
nsTArray
<
StrutInfo
>
&
aStruts
const
FlexboxAxisTracker
&
aAxisTracker
)
{
aStatus
.
Reset
(
)
;
LinkedList
<
FlexLine
>
lines
;
nsTArray
<
nsIFrame
*
>
placeholderKids
;
AutoFlexLineListClearer
cleanupLines
(
lines
)
;
GenerateFlexLines
(
aPresContext
aReflowInput
aContentBoxMainSize
aAvailableBSizeForContent
aStruts
aAxisTracker
placeholderKids
lines
)
;
if
(
lines
.
getFirst
(
)
-
>
IsEmpty
(
)
&
&
!
lines
.
getFirst
(
)
-
>
getNext
(
)
)
{
AddStateBits
(
NS_STATE_FLEX_SYNTHESIZE_BASELINE
)
;
}
else
{
RemoveStateBits
(
NS_STATE_FLEX_SYNTHESIZE_BASELINE
)
;
}
aContentBoxMainSize
=
ResolveFlexContainerMainSize
(
aReflowInput
aAxisTracker
aContentBoxMainSize
aAvailableBSizeForContent
lines
.
getFirst
(
)
aStatus
)
;
for
(
FlexLine
*
line
=
lines
.
getFirst
(
)
;
line
;
line
=
line
-
>
getNext
(
)
)
{
line
-
>
ResolveFlexibleLengths
(
aContentBoxMainSize
)
;
}
nscoord
sumLineCrossSizes
=
0
;
for
(
FlexLine
*
line
=
lines
.
getFirst
(
)
;
line
;
line
=
line
-
>
getNext
(
)
)
{
for
(
FlexItem
*
item
=
line
-
>
GetFirstItem
(
)
;
item
;
item
=
item
-
>
getNext
(
)
)
{
if
(
item
-
>
CanMainSizeInfluenceCrossSize
(
aAxisTracker
)
)
{
Maybe
<
AutoFlexItemMainSizeOverride
>
sizeOverride
;
if
(
item
-
>
HasIntrinsicRatio
(
)
)
{
sizeOverride
.
emplace
(
*
item
)
;
}
WritingMode
wm
=
item
-
>
Frame
(
)
-
>
GetWritingMode
(
)
;
LogicalSize
availSize
=
aReflowInput
.
ComputedSize
(
wm
)
;
availSize
.
BSize
(
wm
)
=
NS_UNCONSTRAINEDSIZE
;
ReflowInput
childReflowInput
(
aPresContext
aReflowInput
item
-
>
Frame
(
)
availSize
)
;
if
(
!
sizeOverride
)
{
if
(
aAxisTracker
.
IsMainAxisHorizontal
(
)
)
{
childReflowInput
.
SetComputedWidth
(
item
-
>
GetMainSize
(
)
)
;
}
else
{
childReflowInput
.
SetComputedHeight
(
item
-
>
GetMainSize
(
)
)
;
}
}
SizeItemInCrossAxis
(
aPresContext
aAxisTracker
childReflowInput
*
item
)
;
}
}
line
-
>
ComputeCrossSizeAndBaseline
(
aAxisTracker
)
;
sumLineCrossSizes
+
=
line
-
>
GetLineCrossSize
(
)
;
}
bool
isCrossSizeDefinite
;
const
nscoord
contentBoxCrossSize
=
ComputeCrossSize
(
aReflowInput
aAxisTracker
sumLineCrossSizes
aAvailableBSizeForContent
&
isCrossSizeDefinite
aStatus
)
;
CrossAxisPositionTracker
crossAxisPosnTracker
(
lines
.
getFirst
(
)
aReflowInput
contentBoxCrossSize
isCrossSizeDefinite
aAxisTracker
)
;
if
(
aStruts
.
IsEmpty
(
)
)
{
BuildStrutInfoFromCollapsedItems
(
lines
.
getFirst
(
)
aStruts
)
;
if
(
!
aStruts
.
IsEmpty
(
)
)
{
return
;
}
}
nscoord
flexContainerAscent
;
if
(
!
aAxisTracker
.
AreAxesInternallyReversed
(
)
)
{
nscoord
firstLineBaselineOffset
=
lines
.
getFirst
(
)
-
>
GetFirstBaselineOffset
(
)
;
if
(
firstLineBaselineOffset
=
=
nscoord_MIN
)
{
flexContainerAscent
=
nscoord_MIN
;
}
else
{
flexContainerAscent
=
ComputePhysicalAscentFromFlexRelativeAscent
(
crossAxisPosnTracker
.
GetPosition
(
)
+
firstLineBaselineOffset
contentBoxCrossSize
aReflowInput
aAxisTracker
)
;
}
}
const
auto
justifyContent
=
IsLegacyBox
(
aReflowInput
.
mFrame
)
?
ConvertLegacyStyleToJustifyContent
(
StyleXUL
(
)
)
:
aReflowInput
.
mStylePosition
-
>
mJustifyContent
;
for
(
FlexLine
*
line
=
lines
.
getFirst
(
)
;
line
;
line
=
line
-
>
getNext
(
)
)
{
line
-
>
PositionItemsInMainAxis
(
justifyContent
aContentBoxMainSize
aAxisTracker
)
;
line
-
>
PositionItemsInCrossAxis
(
crossAxisPosnTracker
.
GetPosition
(
)
aAxisTracker
)
;
crossAxisPosnTracker
.
TraverseLine
(
*
line
)
;
crossAxisPosnTracker
.
TraversePackingSpace
(
)
;
}
if
(
aAxisTracker
.
AreAxesInternallyReversed
(
)
)
{
nscoord
lastLineBaselineOffset
=
lines
.
getLast
(
)
-
>
GetFirstBaselineOffset
(
)
;
if
(
lastLineBaselineOffset
=
=
nscoord_MIN
)
{
flexContainerAscent
=
nscoord_MIN
;
}
else
{
flexContainerAscent
=
ComputePhysicalAscentFromFlexRelativeAscent
(
crossAxisPosnTracker
.
GetPosition
(
)
-
lastLineBaselineOffset
contentBoxCrossSize
aReflowInput
aAxisTracker
)
;
}
}
WritingMode
flexWM
=
aReflowInput
.
GetWritingMode
(
)
;
LogicalMargin
containerBP
=
aReflowInput
.
ComputedLogicalBorderPadding
(
)
;
const
nscoord
blockEndContainerBP
=
containerBP
.
BEnd
(
flexWM
)
;
const
LogicalSides
skipSides
=
GetLogicalSkipSides
(
&
aReflowInput
)
|
LogicalSides
(
eLogicalSideBitsBEnd
)
;
containerBP
.
ApplySkipSides
(
skipSides
)
;
const
LogicalPoint
containerContentBoxOrigin
(
flexWM
containerBP
.
IStart
(
flexWM
)
containerBP
.
BStart
(
flexWM
)
)
;
LogicalSize
logSize
=
aAxisTracker
.
LogicalSizeFromFlexRelativeSizes
(
aContentBoxMainSize
contentBoxCrossSize
)
;
logSize
+
=
aReflowInput
.
ComputedLogicalBorderPadding
(
)
.
Size
(
flexWM
)
;
nsSize
containerSize
=
logSize
.
GetPhysicalSize
(
flexWM
)
;
const
FlexItem
*
const
firstItem
=
aAxisTracker
.
AreAxesInternallyReversed
(
)
?
lines
.
getLast
(
)
-
>
GetLastItem
(
)
:
lines
.
getFirst
(
)
-
>
GetFirstItem
(
)
;
for
(
const
FlexLine
*
line
=
lines
.
getFirst
(
)
;
line
;
line
=
line
-
>
getNext
(
)
)
{
for
(
const
FlexItem
*
item
=
line
-
>
GetFirstItem
(
)
;
item
;
item
=
item
-
>
getNext
(
)
)
{
LogicalPoint
framePos
=
aAxisTracker
.
LogicalPointFromFlexRelativePoint
(
item
-
>
GetMainPosition
(
)
item
-
>
GetCrossPosition
(
)
aContentBoxMainSize
contentBoxCrossSize
)
;
framePos
+
=
containerContentBoxOrigin
;
const
nscoord
itemNormalBPos
=
framePos
.
B
(
flexWM
)
;
bool
itemNeedsReflow
=
true
;
if
(
item
-
>
HadMeasuringReflow
(
)
)
{
LogicalSize
finalFlexItemCBSize
=
aAxisTracker
.
LogicalSizeFromFlexRelativeSizes
(
item
-
>
GetMainSize
(
)
item
-
>
GetCrossSize
(
)
)
;
if
(
finalFlexItemCBSize
=
=
LogicalSize
(
flexWM
item
-
>
Frame
(
)
-
>
GetContentRectRelativeToSelf
(
)
.
Size
(
)
)
)
{
if
(
!
(
item
-
>
Frame
(
)
-
>
GetStateBits
(
)
&
NS_FRAME_CONTAINS_RELATIVE_BSIZE
)
)
{
itemNeedsReflow
=
false
;
MoveFlexItemToFinalPosition
(
aReflowInput
*
item
framePos
containerSize
)
;
}
}
}
if
(
itemNeedsReflow
)
{
ReflowFlexItem
(
aPresContext
aAxisTracker
aReflowInput
*
item
framePos
containerSize
)
;
}
if
(
item
=
=
firstItem
&
&
flexContainerAscent
=
=
nscoord_MIN
)
{
flexContainerAscent
=
itemNormalBPos
+
item
-
>
ResolvedAscent
(
true
)
;
}
}
}
if
(
!
placeholderKids
.
IsEmpty
(
)
)
{
ReflowPlaceholders
(
aPresContext
aReflowInput
placeholderKids
containerContentBoxOrigin
containerSize
)
;
}
LogicalSize
desiredSizeInFlexWM
=
aAxisTracker
.
LogicalSizeFromFlexRelativeSizes
(
aContentBoxMainSize
contentBoxCrossSize
)
;
desiredSizeInFlexWM
.
ISize
(
flexWM
)
+
=
containerBP
.
IStartEnd
(
flexWM
)
;
desiredSizeInFlexWM
.
BSize
(
flexWM
)
+
=
containerBP
.
BStartEnd
(
flexWM
)
;
if
(
flexContainerAscent
=
=
nscoord_MIN
)
{
NS_WARNING_ASSERTION
(
lines
.
getFirst
(
)
-
>
IsEmpty
(
)
"
Have
flex
items
but
didn
'
t
get
an
ascent
-
that
'
s
odd
(
or
there
are
"
"
just
gigantic
sizes
involved
)
"
)
;
flexContainerAscent
=
desiredSizeInFlexWM
.
BSize
(
flexWM
)
;
}
if
(
HasAnyStateBits
(
NS_STATE_FLEX_SYNTHESIZE_BASELINE
)
)
{
aDesiredSize
.
SetBlockStartAscent
(
ReflowOutput
:
:
ASK_FOR_BASELINE
)
;
}
else
{
aDesiredSize
.
SetBlockStartAscent
(
flexContainerAscent
)
;
}
if
(
aStatus
.
IsComplete
(
)
)
{
nscoord
desiredBSizeWithBEndBP
=
desiredSizeInFlexWM
.
BSize
(
flexWM
)
+
blockEndContainerBP
;
if
(
aReflowInput
.
AvailableBSize
(
)
=
=
NS_UNCONSTRAINEDSIZE
|
|
desiredSizeInFlexWM
.
BSize
(
flexWM
)
=
=
0
|
|
desiredBSizeWithBEndBP
<
=
aReflowInput
.
AvailableBSize
(
)
|
|
aReflowInput
.
ComputedBSize
(
)
=
=
NS_INTRINSICSIZE
)
{
desiredSizeInFlexWM
.
BSize
(
flexWM
)
=
desiredBSizeWithBEndBP
;
}
else
{
aStatus
.
SetIncomplete
(
)
;
}
}
mBaselineFromLastReflow
=
flexContainerAscent
;
mLastBaselineFromLastReflow
=
lines
.
getLast
(
)
-
>
GetLastBaselineOffset
(
)
;
if
(
mLastBaselineFromLastReflow
=
=
nscoord_MIN
)
{
mLastBaselineFromLastReflow
=
desiredSizeInFlexWM
.
BSize
(
flexWM
)
-
flexContainerAscent
;
}
aDesiredSize
.
SetSize
(
flexWM
desiredSizeInFlexWM
)
;
aDesiredSize
.
SetOverflowAreasToDesiredBounds
(
)
;
for
(
nsIFrame
*
childFrame
:
mFrames
)
{
ConsiderChildOverflow
(
aDesiredSize
.
mOverflowAreas
childFrame
)
;
}
FinishReflowWithAbsoluteFrames
(
aPresContext
aDesiredSize
aReflowInput
aStatus
)
;
NS_FRAME_SET_TRUNCATION
(
aStatus
aReflowInput
aDesiredSize
)
}
void
nsFlexContainerFrame
:
:
MoveFlexItemToFinalPosition
(
const
ReflowInput
&
aReflowInput
const
FlexItem
&
aItem
LogicalPoint
&
aFramePos
const
nsSize
&
aContainerSize
)
{
WritingMode
outerWM
=
aReflowInput
.
GetWritingMode
(
)
;
LogicalMargin
logicalOffsets
(
outerWM
)
;
if
(
NS_STYLE_POSITION_RELATIVE
=
=
aItem
.
Frame
(
)
-
>
StyleDisplay
(
)
-
>
mPosition
)
{
FrameProperties
props
=
aItem
.
Frame
(
)
-
>
Properties
(
)
;
nsMargin
*
cachedOffsets
=
props
.
Get
(
nsIFrame
:
:
ComputedOffsetProperty
(
)
)
;
MOZ_ASSERT
(
cachedOffsets
"
relpos
previously
-
reflowed
frame
should
'
ve
cached
its
offsets
"
)
;
logicalOffsets
=
LogicalMargin
(
outerWM
*
cachedOffsets
)
;
}
ReflowInput
:
:
ApplyRelativePositioning
(
aItem
.
Frame
(
)
outerWM
logicalOffsets
&
aFramePos
aContainerSize
)
;
aItem
.
Frame
(
)
-
>
SetPosition
(
outerWM
aFramePos
aContainerSize
)
;
PositionFrameView
(
aItem
.
Frame
(
)
)
;
PositionChildViews
(
aItem
.
Frame
(
)
)
;
}
void
nsFlexContainerFrame
:
:
ReflowFlexItem
(
nsPresContext
*
aPresContext
const
FlexboxAxisTracker
&
aAxisTracker
const
ReflowInput
&
aReflowInput
const
FlexItem
&
aItem
LogicalPoint
&
aFramePos
const
nsSize
&
aContainerSize
)
{
WritingMode
outerWM
=
aReflowInput
.
GetWritingMode
(
)
;
WritingMode
wm
=
aItem
.
Frame
(
)
-
>
GetWritingMode
(
)
;
LogicalSize
availSize
=
aReflowInput
.
ComputedSize
(
wm
)
;
availSize
.
BSize
(
wm
)
=
NS_UNCONSTRAINEDSIZE
;
ReflowInput
childReflowInput
(
aPresContext
aReflowInput
aItem
.
Frame
(
)
availSize
)
;
bool
didOverrideComputedWidth
=
false
;
bool
didOverrideComputedHeight
=
false
;
if
(
aAxisTracker
.
IsMainAxisHorizontal
(
)
)
{
childReflowInput
.
SetComputedWidth
(
aItem
.
GetMainSize
(
)
)
;
didOverrideComputedWidth
=
true
;
}
else
{
childReflowInput
.
SetComputedHeight
(
aItem
.
GetMainSize
(
)
)
;
didOverrideComputedHeight
=
true
;
}
if
(
aItem
.
IsStretched
(
)
|
|
aItem
.
HasIntrinsicRatio
(
)
)
{
if
(
aAxisTracker
.
IsCrossAxisHorizontal
(
)
)
{
childReflowInput
.
SetComputedWidth
(
aItem
.
GetCrossSize
(
)
)
;
didOverrideComputedWidth
=
true
;
}
else
{
childReflowInput
.
SetComputedHeight
(
aItem
.
GetCrossSize
(
)
)
;
didOverrideComputedHeight
=
true
;
}
}
if
(
aItem
.
IsStretched
(
)
&
&
!
aAxisTracker
.
IsCrossAxisHorizontal
(
)
)
{
aItem
.
Frame
(
)
-
>
AddStateBits
(
NS_FRAME_CONTAINS_RELATIVE_BSIZE
)
;
}
if
(
aItem
.
HadMeasuringReflow
(
)
)
{
if
(
didOverrideComputedWidth
)
{
childReflowInput
.
SetHResize
(
true
)
;
}
if
(
didOverrideComputedHeight
)
{
childReflowInput
.
SetVResize
(
true
)
;
}
}
ReflowOutput
childDesiredSize
(
childReflowInput
)
;
nsReflowStatus
childReflowStatus
;
ReflowChild
(
aItem
.
Frame
(
)
aPresContext
childDesiredSize
childReflowInput
outerWM
aFramePos
aContainerSize
0
childReflowStatus
)
;
MOZ_ASSERT
(
childReflowStatus
.
IsComplete
(
)
"
We
gave
flex
item
unconstrained
available
height
so
it
"
"
should
be
complete
"
)
;
LogicalMargin
offsets
=
childReflowInput
.
ComputedLogicalOffsets
(
)
.
ConvertTo
(
outerWM
wm
)
;
ReflowInput
:
:
ApplyRelativePositioning
(
aItem
.
Frame
(
)
outerWM
offsets
&
aFramePos
aContainerSize
)
;
FinishReflowChild
(
aItem
.
Frame
(
)
aPresContext
childDesiredSize
&
childReflowInput
outerWM
aFramePos
aContainerSize
0
)
;
aItem
.
SetAscent
(
childDesiredSize
.
BlockStartAscent
(
)
)
;
}
void
nsFlexContainerFrame
:
:
ReflowPlaceholders
(
nsPresContext
*
aPresContext
const
ReflowInput
&
aReflowInput
nsTArray
<
nsIFrame
*
>
&
aPlaceholders
const
LogicalPoint
&
aContentBoxOrigin
const
nsSize
&
aContainerSize
)
{
WritingMode
outerWM
=
aReflowInput
.
GetWritingMode
(
)
;
for
(
nsIFrame
*
placeholder
:
aPlaceholders
)
{
MOZ_ASSERT
(
placeholder
-
>
GetType
(
)
=
=
nsGkAtoms
:
:
placeholderFrame
"
placeholders
array
should
only
contain
placeholder
frames
"
)
;
WritingMode
wm
=
placeholder
-
>
GetWritingMode
(
)
;
LogicalSize
availSize
=
aReflowInput
.
ComputedSize
(
wm
)
;
ReflowInput
childReflowInput
(
aPresContext
aReflowInput
placeholder
availSize
)
;
ReflowOutput
childDesiredSize
(
childReflowInput
)
;
nsReflowStatus
childReflowStatus
;
ReflowChild
(
placeholder
aPresContext
childDesiredSize
childReflowInput
outerWM
aContentBoxOrigin
aContainerSize
0
childReflowStatus
)
;
FinishReflowChild
(
placeholder
aPresContext
childDesiredSize
&
childReflowInput
outerWM
aContentBoxOrigin
aContainerSize
0
)
;
placeholder
-
>
AddStateBits
(
PLACEHOLDER_STATICPOS_NEEDS_CSSALIGN
)
;
}
}
nscoord
nsFlexContainerFrame
:
:
GetMinISize
(
nsRenderingContext
*
aRenderingContext
)
{
nscoord
minISize
=
0
;
DISPLAY_MIN_WIDTH
(
this
minISize
)
;
RenumberList
(
)
;
const
nsStylePosition
*
stylePos
=
StylePosition
(
)
;
const
FlexboxAxisTracker
axisTracker
(
this
GetWritingMode
(
)
)
;
for
(
nsIFrame
*
childFrame
:
mFrames
)
{
nscoord
childMinISize
=
nsLayoutUtils
:
:
IntrinsicForContainer
(
aRenderingContext
childFrame
nsLayoutUtils
:
:
MIN_ISIZE
)
;
if
(
axisTracker
.
IsRowOriented
(
)
&
&
NS_STYLE_FLEX_WRAP_NOWRAP
=
=
stylePos
-
>
mFlexWrap
)
{
minISize
+
=
childMinISize
;
}
else
{
minISize
=
std
:
:
max
(
minISize
childMinISize
)
;
}
}
return
minISize
;
}
nscoord
nsFlexContainerFrame
:
:
GetPrefISize
(
nsRenderingContext
*
aRenderingContext
)
{
nscoord
prefISize
=
0
;
DISPLAY_PREF_WIDTH
(
this
prefISize
)
;
RenumberList
(
)
;
const
FlexboxAxisTracker
axisTracker
(
this
GetWritingMode
(
)
)
;
for
(
nsIFrame
*
childFrame
:
mFrames
)
{
nscoord
childPrefISize
=
nsLayoutUtils
:
:
IntrinsicForContainer
(
aRenderingContext
childFrame
nsLayoutUtils
:
:
PREF_ISIZE
)
;
if
(
axisTracker
.
IsRowOriented
(
)
)
{
prefISize
+
=
childPrefISize
;
}
else
{
prefISize
=
std
:
:
max
(
prefISize
childPrefISize
)
;
}
}
return
prefISize
;
}
