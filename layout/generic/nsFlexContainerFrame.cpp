#
include
"
nsFlexContainerFrame
.
h
"
#
include
"
nsBlockFrame
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCSSAnonBoxes
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsPlaceholderFrame
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
mozilla
/
ComputedStyle
.
h
"
#
include
"
mozilla
/
CSSOrderAwareFrameIterator
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
<
algorithm
>
#
include
"
gfxContext
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
WritingModes
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
layout
;
typedef
nsFlexContainerFrame
:
:
FlexItem
FlexItem
;
typedef
nsFlexContainerFrame
:
:
FlexLine
FlexLine
;
typedef
nsFlexContainerFrame
:
:
FlexboxAxisTracker
FlexboxAxisTracker
;
typedef
nsFlexContainerFrame
:
:
StrutInfo
StrutInfo
;
typedef
nsFlexContainerFrame
:
:
CachedMeasuringReflowResult
CachedMeasuringReflowResult
;
typedef
nsLayoutUtils
:
:
IntrinsicISizeType
IntrinsicISizeType
;
static
mozilla
:
:
LazyLogModule
gFlexContainerLog
(
"
FlexContainer
"
)
;
#
define
FLEX_LOG
(
.
.
.
)
\
MOZ_LOG
(
gFlexContainerLog
LogLevel
:
:
Debug
(
__VA_ARGS__
)
)
;
static
inline
bool
IsDisplayValueLegacyBox
(
const
nsStyleDisplay
*
aStyleDisp
)
{
return
aStyleDisp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
WebkitBox
|
|
aStyleDisp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
WebkitInlineBox
|
|
aStyleDisp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
MozBox
|
|
aStyleDisp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
MozInlineBox
;
}
static
bool
IsLegacyBox
(
const
nsIFrame
*
aFlexContainer
)
{
MOZ_ASSERT
(
aFlexContainer
-
>
IsFlexContainerFrame
(
)
"
only
flex
containers
may
be
passed
to
this
function
"
)
;
return
aFlexContainer
-
>
HasAnyStateBits
(
NS_STATE_FLEX_IS_EMULATING_LEGACY_BOX
)
;
}
static
CSSOrderAwareFrameIterator
:
:
OrderingProperty
OrderingPropertyForIter
(
const
nsFlexContainerFrame
*
aFlexContainer
)
{
return
IsLegacyBox
(
aFlexContainer
)
?
CSSOrderAwareFrameIterator
:
:
OrderingProperty
:
:
eUseBoxOrdinalGroup
:
CSSOrderAwareFrameIterator
:
:
OrderingProperty
:
:
eUseOrder
;
}
static
StyleAlignFlags
ConvertLegacyStyleToAlignItems
(
const
nsStyleXUL
*
aStyleXUL
)
{
switch
(
aStyleXUL
-
>
mBoxAlign
)
{
case
StyleBoxAlign
:
:
Stretch
:
return
StyleAlignFlags
:
:
STRETCH
;
case
StyleBoxAlign
:
:
Start
:
return
StyleAlignFlags
:
:
FLEX_START
;
case
StyleBoxAlign
:
:
Center
:
return
StyleAlignFlags
:
:
CENTER
;
case
StyleBoxAlign
:
:
Baseline
:
return
StyleAlignFlags
:
:
BASELINE
;
case
StyleBoxAlign
:
:
End
:
return
StyleAlignFlags
:
:
FLEX_END
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
mBoxAlign
enum
value
"
)
;
return
StyleAlignFlags
:
:
STRETCH
;
}
static
StyleContentDistribution
ConvertLegacyStyleToJustifyContent
(
const
nsStyleXUL
*
aStyleXUL
)
{
switch
(
aStyleXUL
-
>
mBoxPack
)
{
case
StyleBoxPack
:
:
Start
:
return
{
StyleAlignFlags
:
:
FLEX_START
}
;
case
StyleBoxPack
:
:
Center
:
return
{
StyleAlignFlags
:
:
CENTER
}
;
case
StyleBoxPack
:
:
End
:
return
{
StyleAlignFlags
:
:
FLEX_END
}
;
case
StyleBoxPack
:
:
Justify
:
return
{
StyleAlignFlags
:
:
SPACE_BETWEEN
}
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
mBoxPack
enum
value
"
)
;
return
{
StyleAlignFlags
:
:
FLEX_START
}
;
}
static
nsIFrame
*
GetFirstNonAnonBoxDescendant
(
nsIFrame
*
aFrame
)
{
while
(
aFrame
)
{
if
(
!
aFrame
-
>
Style
(
)
-
>
IsAnonBox
(
)
|
|
nsCSSAnonBoxes
:
:
IsNonElement
(
aFrame
-
>
Style
(
)
-
>
GetPseudoType
(
)
)
)
{
break
;
}
if
(
MOZ_UNLIKELY
(
aFrame
-
>
IsTableWrapperFrame
(
)
)
)
{
nsIFrame
*
captionDescendant
=
GetFirstNonAnonBoxDescendant
(
aFrame
-
>
GetChildList
(
kCaptionList
)
.
FirstChild
(
)
)
;
if
(
captionDescendant
)
{
return
captionDescendant
;
}
}
else
if
(
MOZ_UNLIKELY
(
aFrame
-
>
IsTableFrame
(
)
)
)
{
nsIFrame
*
colgroupDescendant
=
GetFirstNonAnonBoxDescendant
(
aFrame
-
>
GetChildList
(
kColGroupList
)
.
FirstChild
(
)
)
;
if
(
colgroupDescendant
)
{
return
colgroupDescendant
;
}
}
aFrame
=
aFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
}
return
aFrame
;
}
static
nscoord
PhysicalCoordFromFlexRelativeCoord
(
nscoord
aFlexRelativeCoord
nscoord
aContainerSize
mozilla
:
:
Side
aStartSide
)
{
if
(
aStartSide
=
=
eSideLeft
|
|
aStartSide
=
=
eSideTop
)
{
return
aFlexRelativeCoord
;
}
return
aContainerSize
-
aFlexRelativeCoord
;
}
static
nscoord
AddChecked
(
nscoord
aFirst
nscoord
aSecond
)
{
CheckedInt
<
nscoord
>
checkedResult
=
CheckedInt
<
nscoord
>
(
aFirst
)
+
aSecond
;
return
checkedResult
.
isValid
(
)
?
checkedResult
.
value
(
)
:
nscoord_MAX
;
}
static
inline
bool
IsAutoOrEnumOnBSize
(
const
StyleSize
&
aSize
bool
aIsInline
)
{
return
aSize
.
IsAuto
(
)
|
|
(
!
aIsInline
&
&
aSize
.
IsExtremumLength
(
)
)
;
}
#
define
GET_MAIN_COMPONENT_LOGICAL
(
axisTracker_
wm_
isize_
bsize_
)
\
wm_
.
IsOrthogonalTo
(
axisTracker_
.
GetWritingMode
(
)
)
!
=
\
(
axisTracker_
)
.
IsRowOriented
(
)
\
?
(
isize_
)
\
:
(
bsize_
)
#
define
GET_CROSS_COMPONENT_LOGICAL
(
axisTracker_
wm_
isize_
bsize_
)
\
wm_
.
IsOrthogonalTo
(
axisTracker_
.
GetWritingMode
(
)
)
!
=
\
(
axisTracker_
)
.
IsRowOriented
(
)
\
?
(
bsize_
)
\
:
(
isize_
)
enum
AxisTrackerFlags
{
eNoFlags
=
0x0
eAllowBottomToTopChildOrdering
=
0x1
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
AxisTrackerFlags
)
class
MOZ_STACK_CLASS
nsFlexContainerFrame
:
:
FlexboxAxisTracker
{
public
:
FlexboxAxisTracker
(
const
nsFlexContainerFrame
*
aFlexContainer
const
WritingMode
&
aWM
AxisTrackerFlags
aFlags
=
eNoFlags
)
;
LogicalAxis
MainAxis
(
)
const
{
return
mMainAxis
;
}
LogicalAxis
CrossAxis
(
)
const
{
return
GetOrthogonalAxis
(
mMainAxis
)
;
}
LogicalSide
MainAxisStartSide
(
)
const
;
LogicalSide
MainAxisEndSide
(
)
const
{
return
GetOppositeSide
(
MainAxisStartSide
(
)
)
;
}
LogicalSide
CrossAxisStartSide
(
)
const
;
LogicalSide
CrossAxisEndSide
(
)
const
{
return
GetOppositeSide
(
CrossAxisStartSide
(
)
)
;
}
mozilla
:
:
Side
MainAxisPhysicalStartSide
(
)
const
{
return
mWM
.
PhysicalSide
(
MainAxisStartSide
(
)
)
;
}
mozilla
:
:
Side
MainAxisPhysicalEndSide
(
)
const
{
return
mWM
.
PhysicalSide
(
MainAxisEndSide
(
)
)
;
}
mozilla
:
:
Side
CrossAxisPhysicalStartSide
(
)
const
{
return
mWM
.
PhysicalSide
(
CrossAxisStartSide
(
)
)
;
}
mozilla
:
:
Side
CrossAxisPhysicalEndSide
(
)
const
{
return
mWM
.
PhysicalSide
(
CrossAxisEndSide
(
)
)
;
}
WritingMode
GetWritingMode
(
)
const
{
return
mWM
;
}
bool
IsMainAxisReversed
(
)
const
{
return
mIsMainAxisReversed
;
}
bool
IsCrossAxisReversed
(
)
const
{
return
mIsCrossAxisReversed
;
}
bool
IsRowOriented
(
)
const
{
return
mIsRowOriented
;
}
bool
IsColumnOriented
(
)
const
{
return
!
mIsRowOriented
;
}
nscoord
MainComponent
(
const
LogicalSize
&
aSize
)
const
{
return
IsRowOriented
(
)
?
aSize
.
ISize
(
mWM
)
:
aSize
.
BSize
(
mWM
)
;
}
int32_t
MainComponent
(
const
LayoutDeviceIntSize
&
aIntSize
)
const
{
return
IsMainAxisHorizontal
(
)
?
aIntSize
.
width
:
aIntSize
.
height
;
}
nscoord
CrossComponent
(
const
LogicalSize
&
aSize
)
const
{
return
IsRowOriented
(
)
?
aSize
.
BSize
(
mWM
)
:
aSize
.
ISize
(
mWM
)
;
}
int32_t
CrossComponent
(
const
LayoutDeviceIntSize
&
aIntSize
)
const
{
return
IsMainAxisHorizontal
(
)
?
aIntSize
.
height
:
aIntSize
.
width
;
}
nscoord
MarginSizeInMainAxis
(
const
LogicalMargin
&
aMargin
)
const
{
return
IsRowOriented
(
)
?
aMargin
.
IStartEnd
(
mWM
)
:
aMargin
.
BStartEnd
(
mWM
)
;
}
nscoord
MarginSizeInCrossAxis
(
const
LogicalMargin
&
aMargin
)
const
{
return
IsRowOriented
(
)
?
aMargin
.
BStartEnd
(
mWM
)
:
aMargin
.
IStartEnd
(
mWM
)
;
}
LogicalPoint
LogicalPointFromFlexRelativePoint
(
nscoord
aMainCoord
nscoord
aCrossCoord
nscoord
aContainerMainSize
nscoord
aContainerCrossSize
)
const
{
nscoord
logicalCoordInMainAxis
=
mIsMainAxisReversed
?
aContainerMainSize
-
aMainCoord
:
aMainCoord
;
nscoord
logicalCoordInCrossAxis
=
mIsCrossAxisReversed
?
aContainerCrossSize
-
aCrossCoord
:
aCrossCoord
;
return
mIsRowOriented
?
LogicalPoint
(
mWM
logicalCoordInMainAxis
logicalCoordInCrossAxis
)
:
LogicalPoint
(
mWM
logicalCoordInCrossAxis
logicalCoordInMainAxis
)
;
}
LogicalSize
LogicalSizeFromFlexRelativeSizes
(
nscoord
aMainSize
nscoord
aCrossSize
)
const
{
return
mIsRowOriented
?
LogicalSize
(
mWM
aMainSize
aCrossSize
)
:
LogicalSize
(
mWM
aCrossSize
aMainSize
)
;
}
bool
AreAxesInternallyReversed
(
)
const
{
return
mAreAxesInternallyReversed
;
}
bool
IsMainAxisHorizontal
(
)
const
{
return
mIsRowOriented
!
=
mWM
.
IsVertical
(
)
;
}
FlexboxAxisTracker
(
const
FlexboxAxisTracker
&
)
=
delete
;
FlexboxAxisTracker
&
operator
=
(
const
FlexboxAxisTracker
&
)
=
delete
;
private
:
void
InitAxesFromLegacyProps
(
const
nsFlexContainerFrame
*
aFlexContainer
)
;
void
InitAxesFromModernProps
(
const
nsFlexContainerFrame
*
aFlexContainer
)
;
LogicalAxis
mMainAxis
=
eLogicalAxisInline
;
const
WritingMode
mWM
;
bool
mIsRowOriented
=
true
;
bool
mIsMainAxisReversed
=
false
;
bool
mIsCrossAxisReversed
=
false
;
bool
mAreAxesInternallyReversed
=
false
;
}
;
class
nsFlexContainerFrame
:
:
FlexItem
:
public
LinkedListElement
<
FlexItem
>
{
public
:
FlexItem
(
ReflowInput
&
aFlexItemReflowInput
float
aFlexGrow
float
aFlexShrink
nscoord
aMainBaseSize
nscoord
aMainMinSize
nscoord
aMainMaxSize
nscoord
aTentativeCrossSize
nscoord
aCrossMinSize
nscoord
aCrossMaxSize
const
FlexboxAxisTracker
&
aAxisTracker
)
;
FlexItem
(
nsIFrame
*
aChildFrame
nscoord
aCrossSize
WritingMode
aContainerWM
)
;
nsIFrame
*
Frame
(
)
const
{
return
mFrame
;
}
nscoord
FlexBaseSize
(
)
const
{
return
mFlexBaseSize
;
}
nscoord
MainMinSize
(
)
const
{
MOZ_ASSERT
(
!
mNeedsMinSizeAutoResolution
"
Someone
'
s
using
an
unresolved
'
auto
'
main
min
-
size
"
)
;
return
mMainMinSize
;
}
nscoord
MainMaxSize
(
)
const
{
return
mMainMaxSize
;
}
nscoord
MainSize
(
)
const
{
return
mMainSize
;
}
nscoord
MainPosition
(
)
const
{
return
mMainPosn
;
}
nscoord
CrossMinSize
(
)
const
{
return
mCrossMinSize
;
}
nscoord
CrossMaxSize
(
)
const
{
return
mCrossMaxSize
;
}
nscoord
CrossSize
(
)
const
{
return
mCrossSize
;
}
nscoord
CrossPosition
(
)
const
{
return
mCrossPosn
;
}
nscoord
ResolvedAscent
(
bool
aUseFirstBaseline
)
const
{
if
(
mAscent
=
=
ReflowOutput
:
:
ASK_FOR_BASELINE
)
{
bool
found
=
aUseFirstBaseline
?
nsLayoutUtils
:
:
GetFirstLineBaseline
(
mWM
mFrame
&
mAscent
)
:
nsLayoutUtils
:
:
GetLastLineBaseline
(
mWM
mFrame
&
mAscent
)
;
if
(
!
found
)
{
mAscent
=
mFrame
-
>
SynthesizeBaselineBOffsetFromBorderBox
(
mWM
BaselineSharingGroup
:
:
First
)
;
}
}
return
mAscent
;
}
nscoord
OuterMainSize
(
)
const
{
return
mMainSize
+
MarginBorderPaddingSizeInMainAxis
(
)
;
}
nscoord
OuterCrossSize
(
)
const
{
return
mCrossSize
+
MarginBorderPaddingSizeInCrossAxis
(
)
;
}
nscoord
BaselineOffsetFromOuterCrossEdge
(
mozilla
:
:
Side
aStartSide
const
FlexboxAxisTracker
&
aAxisTracker
bool
aUseFirstLineBaseline
)
const
;
float
ShareOfWeightSoFar
(
)
const
{
return
mShareOfWeightSoFar
;
}
bool
IsFrozen
(
)
const
{
return
mIsFrozen
;
}
bool
HadMinViolation
(
)
const
{
MOZ_ASSERT
(
!
mIsFrozen
"
min
violation
has
no
meaning
for
frozen
items
.
"
)
;
return
mHadMinViolation
;
}
bool
HadMaxViolation
(
)
const
{
MOZ_ASSERT
(
!
mIsFrozen
"
max
violation
has
no
meaning
for
frozen
items
.
"
)
;
return
mHadMaxViolation
;
}
bool
WasMinClamped
(
)
const
{
MOZ_ASSERT
(
mIsFrozen
"
min
clamping
has
no
meaning
for
unfrozen
items
.
"
)
;
return
mHadMinViolation
;
}
bool
WasMaxClamped
(
)
const
{
MOZ_ASSERT
(
mIsFrozen
"
max
clamping
has
no
meaning
for
unfrozen
items
.
"
)
;
return
mHadMaxViolation
;
}
bool
HadMeasuringReflow
(
)
const
{
return
mHadMeasuringReflow
;
}
bool
IsCrossSizeAuto
(
)
const
;
bool
IsStretched
(
)
const
{
return
mIsStretched
;
}
bool
NeedsMinSizeAutoResolution
(
)
const
{
return
mNeedsMinSizeAutoResolution
;
}
bool
HasAnyAutoMargin
(
)
const
{
return
mHasAnyAutoMargin
;
}
bool
IsStrut
(
)
const
{
return
mIsStrut
;
}
LogicalAxis
MainAxis
(
)
const
{
return
mMainAxis
;
}
LogicalAxis
CrossAxis
(
)
const
{
return
GetOrthogonalAxis
(
mMainAxis
)
;
}
bool
IsInlineAxisMainAxis
(
)
const
{
return
mIsInlineAxisMainAxis
;
}
bool
IsInlineAxisCrossAxis
(
)
const
{
return
!
mIsInlineAxisMainAxis
;
}
bool
IsBlockAxisMainAxis
(
)
const
{
return
!
mIsInlineAxisMainAxis
;
}
bool
IsBlockAxisCrossAxis
(
)
const
{
return
mIsInlineAxisMainAxis
;
}
WritingMode
GetWritingMode
(
)
const
{
return
mWM
;
}
StyleAlignSelf
AlignSelf
(
)
const
{
return
mAlignSelf
;
}
StyleAlignFlags
AlignSelfFlags
(
)
const
{
return
mAlignSelfFlags
;
}
float
GetFlexFactor
(
bool
aIsUsingFlexGrow
)
{
MOZ_ASSERT
(
!
IsFrozen
(
)
"
shouldn
'
t
need
flex
factor
after
item
is
frozen
"
)
;
return
aIsUsingFlexGrow
?
mFlexGrow
:
mFlexShrink
;
}
float
GetWeight
(
bool
aIsUsingFlexGrow
)
{
MOZ_ASSERT
(
!
IsFrozen
(
)
"
shouldn
'
t
need
weight
after
item
is
frozen
"
)
;
if
(
aIsUsingFlexGrow
)
{
return
mFlexGrow
;
}
if
(
mFlexBaseSize
=
=
0
)
{
return
0
.
0f
;
}
return
mFlexShrink
*
mFlexBaseSize
;
}
bool
TreatBSizeAsIndefinite
(
)
const
{
return
mTreatBSizeAsIndefinite
;
}
const
AspectRatio
&
IntrinsicRatio
(
)
const
{
return
mIntrinsicRatio
;
}
bool
HasIntrinsicRatio
(
)
const
{
return
!
!
mIntrinsicRatio
;
}
LogicalMargin
Margin
(
)
const
{
return
mMargin
;
}
nsMargin
PhysicalMargin
(
)
const
{
return
mMargin
.
GetPhysicalMargin
(
mCBWM
)
;
}
nscoord
GetMarginComponentForSide
(
LogicalSide
aSide
)
const
{
return
mMargin
.
Side
(
aSide
mCBWM
)
;
}
nscoord
MarginSizeInMainAxis
(
)
const
{
return
mMargin
.
StartEnd
(
MainAxis
(
)
mCBWM
)
;
}
nscoord
MarginSizeInCrossAxis
(
)
const
{
return
mMargin
.
StartEnd
(
CrossAxis
(
)
mCBWM
)
;
}
nscoord
BorderPaddingSizeInMainAxis
(
)
const
{
return
mBorderPadding
.
StartEnd
(
MainAxis
(
)
mCBWM
)
;
}
nscoord
BorderPaddingSizeInCrossAxis
(
)
const
{
return
mBorderPadding
.
StartEnd
(
CrossAxis
(
)
mCBWM
)
;
}
nscoord
MarginBorderPaddingSizeInMainAxis
(
)
const
{
return
MarginSizeInMainAxis
(
)
+
BorderPaddingSizeInMainAxis
(
)
;
}
nscoord
MarginBorderPaddingSizeInCrossAxis
(
)
const
{
return
MarginSizeInCrossAxis
(
)
+
BorderPaddingSizeInCrossAxis
(
)
;
}
void
UpdateMainMinSize
(
nscoord
aNewMinSize
)
{
NS_ASSERTION
(
aNewMinSize
>
=
0
"
How
did
we
end
up
with
a
negative
min
-
size
?
"
)
;
MOZ_ASSERT
(
mMainMaxSize
>
=
aNewMinSize
"
Should
only
use
this
function
for
resolving
min
-
size
:
auto
"
"
and
main
max
-
size
should
be
an
upper
-
bound
for
resolved
val
"
)
;
MOZ_ASSERT
(
mNeedsMinSizeAutoResolution
&
&
(
mMainMinSize
=
=
0
|
|
mFrame
-
>
IsThemed
(
mFrame
-
>
StyleDisplay
(
)
)
)
"
Should
only
use
this
function
for
resolving
min
-
size
:
auto
"
"
so
we
shouldn
'
t
already
have
a
nonzero
min
-
size
established
"
"
(
unless
it
'
s
a
themed
-
widget
-
imposed
minimum
size
)
"
)
;
if
(
aNewMinSize
>
mMainMinSize
)
{
mMainMinSize
=
aNewMinSize
;
mMainSize
=
std
:
:
max
(
mMainSize
aNewMinSize
)
;
}
mNeedsMinSizeAutoResolution
=
false
;
}
void
SetFlexBaseSizeAndMainSize
(
nscoord
aNewFlexBaseSize
)
{
MOZ_ASSERT
(
!
mIsFrozen
|
|
mFlexBaseSize
=
=
NS_UNCONSTRAINEDSIZE
"
flex
base
size
shouldn
'
t
change
after
we
'
re
frozen
"
"
(
unless
we
'
re
just
resolving
an
intrinsic
size
)
"
)
;
mFlexBaseSize
=
aNewFlexBaseSize
;
mMainSize
=
NS_CSS_MINMAX
(
mFlexBaseSize
mMainMinSize
mMainMaxSize
)
;
}
void
SetMainSize
(
nscoord
aNewMainSize
)
{
MOZ_ASSERT
(
!
mIsFrozen
"
main
size
shouldn
'
t
change
after
we
'
re
frozen
"
)
;
mMainSize
=
aNewMainSize
;
}
void
SetShareOfWeightSoFar
(
float
aNewShare
)
{
MOZ_ASSERT
(
!
mIsFrozen
|
|
aNewShare
=
=
0
.
0f
"
shouldn
'
t
be
giving
this
item
any
share
of
the
weight
"
"
after
it
'
s
frozen
"
)
;
mShareOfWeightSoFar
=
aNewShare
;
}
void
Freeze
(
)
{
mIsFrozen
=
true
;
mHadMinViolation
=
false
;
mHadMaxViolation
=
false
;
}
void
SetHadMinViolation
(
)
{
MOZ_ASSERT
(
!
mIsFrozen
"
shouldn
'
t
be
changing
main
size
&
having
violations
"
"
after
we
'
re
frozen
"
)
;
mHadMinViolation
=
true
;
}
void
SetHadMaxViolation
(
)
{
MOZ_ASSERT
(
!
mIsFrozen
"
shouldn
'
t
be
changing
main
size
&
having
violations
"
"
after
we
'
re
frozen
"
)
;
mHadMaxViolation
=
true
;
}
void
ClearViolationFlags
(
)
{
MOZ_ASSERT
(
!
mIsFrozen
"
shouldn
'
t
be
altering
violation
flags
after
we
'
re
"
"
frozen
"
)
;
mHadMinViolation
=
mHadMaxViolation
=
false
;
}
void
SetWasMinClamped
(
)
{
MOZ_ASSERT
(
!
mHadMinViolation
&
&
!
mHadMaxViolation
"
only
clamp
once
"
)
;
MOZ_ASSERT
(
mIsFrozen
"
shouldn
'
t
set
clamping
state
when
we
are
unfrozen
"
)
;
mHadMinViolation
=
true
;
}
void
SetWasMaxClamped
(
)
{
MOZ_ASSERT
(
!
mHadMinViolation
&
&
!
mHadMaxViolation
"
only
clamp
once
"
)
;
MOZ_ASSERT
(
mIsFrozen
"
shouldn
'
t
set
clamping
state
when
we
are
unfrozen
"
)
;
mHadMaxViolation
=
true
;
}
void
SetMainPosition
(
nscoord
aPosn
)
{
MOZ_ASSERT
(
mIsFrozen
"
main
size
should
be
resolved
before
this
"
)
;
mMainPosn
=
aPosn
;
}
void
SetCrossSize
(
nscoord
aCrossSize
)
{
MOZ_ASSERT
(
!
mIsStretched
"
Cross
size
shouldn
'
t
be
modified
after
it
'
s
been
stretched
"
)
;
mCrossSize
=
aCrossSize
;
}
void
SetCrossPosition
(
nscoord
aPosn
)
{
MOZ_ASSERT
(
mIsFrozen
"
main
size
should
be
resolved
before
this
"
)
;
mCrossPosn
=
aPosn
;
}
void
SetAscent
(
nscoord
aAscent
)
const
{
mAscent
=
aAscent
;
}
void
SetHadMeasuringReflow
(
)
{
mHadMeasuringReflow
=
true
;
}
void
SetIsStretched
(
)
{
MOZ_ASSERT
(
mIsFrozen
"
main
size
should
be
resolved
before
this
"
)
;
mIsStretched
=
true
;
}
void
SetMarginComponentForSide
(
LogicalSide
aSide
nscoord
aLength
)
{
MOZ_ASSERT
(
mIsFrozen
"
main
size
should
be
resolved
before
this
"
)
;
mMargin
.
Side
(
aSide
mCBWM
)
=
aLength
;
}
void
ResolveStretchedCrossSize
(
nscoord
aLineCrossSize
)
;
uint32_t
NumAutoMarginsInMainAxis
(
)
const
{
return
NumAutoMarginsInAxis
(
MainAxis
(
)
)
;
}
;
uint32_t
NumAutoMarginsInCrossAxis
(
)
const
{
return
NumAutoMarginsInAxis
(
CrossAxis
(
)
)
;
}
;
bool
CanMainSizeInfluenceCrossSize
(
const
FlexboxAxisTracker
&
aAxisTracker
)
const
;
nsBlockFrame
*
BlockFrame
(
)
const
;
protected
:
void
CheckForMinSizeAuto
(
const
ReflowInput
&
aFlexItemReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
)
;
uint32_t
NumAutoMarginsInAxis
(
LogicalAxis
aAxis
)
const
;
nsIFrame
*
const
mFrame
=
nullptr
;
const
float
mFlexGrow
=
0
.
0f
;
const
float
mFlexShrink
=
0
.
0f
;
const
AspectRatio
mIntrinsicRatio
;
const
WritingMode
mWM
;
const
WritingMode
mCBWM
;
const
LogicalAxis
mMainAxis
=
eLogicalAxisInline
;
const
LogicalMargin
mBorderPadding
;
LogicalMargin
mMargin
;
nscoord
mFlexBaseSize
=
0
;
nscoord
mMainMinSize
=
0
;
nscoord
mMainMaxSize
=
0
;
const
nscoord
mCrossMinSize
=
0
;
const
nscoord
mCrossMaxSize
=
0
;
nscoord
mMainSize
=
0
;
nscoord
mMainPosn
=
0
;
nscoord
mCrossSize
=
0
;
nscoord
mCrossPosn
=
0
;
mutable
nscoord
mAscent
=
0
;
float
mShareOfWeightSoFar
=
0
.
0f
;
bool
mIsFrozen
=
false
;
bool
mHadMinViolation
=
false
;
bool
mHadMaxViolation
=
false
;
bool
mHadMeasuringReflow
=
false
;
bool
mIsStretched
=
false
;
bool
mIsStrut
=
false
;
const
bool
mIsInlineAxisMainAxis
=
true
;
bool
mNeedsMinSizeAutoResolution
=
false
;
bool
mTreatBSizeAsIndefinite
=
false
;
bool
mHasAnyAutoMargin
=
false
;
StyleAlignSelf
mAlignSelf
{
StyleAlignFlags
:
:
AUTO
}
;
StyleAlignFlags
mAlignSelfFlags
{
0
}
;
}
;
class
nsFlexContainerFrame
:
:
FlexLine
:
public
LinkedListElement
<
FlexLine
>
{
public
:
explicit
FlexLine
(
nscoord
aMainGapSize
)
:
mMainGapSize
(
aMainGapSize
)
{
}
nscoord
SumOfGaps
(
)
const
{
return
mNumItems
>
0
?
(
mNumItems
-
1
)
*
mMainGapSize
:
0
;
}
nscoord
TotalOuterHypotheticalMainSize
(
)
const
{
return
mTotalOuterHypotheticalMainSize
;
}
FlexItem
*
GetFirstItem
(
)
{
MOZ_ASSERT
(
mItems
.
isEmpty
(
)
=
=
(
mNumItems
=
=
0
)
"
mNumItems
bookkeeping
is
off
"
)
;
return
mItems
.
getFirst
(
)
;
}
const
FlexItem
*
GetFirstItem
(
)
const
{
MOZ_ASSERT
(
mItems
.
isEmpty
(
)
=
=
(
mNumItems
=
=
0
)
"
mNumItems
bookkeeping
is
off
"
)
;
return
mItems
.
getFirst
(
)
;
}
FlexItem
*
GetLastItem
(
)
{
MOZ_ASSERT
(
mItems
.
isEmpty
(
)
=
=
(
mNumItems
=
=
0
)
"
mNumItems
bookkeeping
is
off
"
)
;
return
mItems
.
getLast
(
)
;
}
const
FlexItem
*
GetLastItem
(
)
const
{
MOZ_ASSERT
(
mItems
.
isEmpty
(
)
=
=
(
mNumItems
=
=
0
)
"
mNumItems
bookkeeping
is
off
"
)
;
return
mItems
.
getLast
(
)
;
}
bool
IsEmpty
(
)
const
{
MOZ_ASSERT
(
mItems
.
isEmpty
(
)
=
=
(
mNumItems
=
=
0
)
"
mNumItems
bookkeeping
is
off
"
)
;
return
mItems
.
isEmpty
(
)
;
}
uint32_t
NumItems
(
)
const
{
MOZ_ASSERT
(
mItems
.
isEmpty
(
)
=
=
(
mNumItems
=
=
0
)
"
mNumItems
bookkeeping
is
off
"
)
;
return
mNumItems
;
}
void
AddItem
(
FlexItem
*
aItem
bool
aShouldInsertAtFront
nscoord
aItemInnerHypotheticalMainSize
nscoord
aItemOuterHypotheticalMainSize
)
{
if
(
aShouldInsertAtFront
)
{
mItems
.
insertFront
(
aItem
)
;
}
else
{
mItems
.
insertBack
(
aItem
)
;
}
mNumItems
+
+
;
if
(
aItem
-
>
IsFrozen
(
)
)
{
mNumFrozenItems
+
+
;
}
nscoord
itemMBP
=
aItemOuterHypotheticalMainSize
-
aItemInnerHypotheticalMainSize
;
mTotalItemMBP
=
AddChecked
(
mTotalItemMBP
itemMBP
)
;
mTotalOuterHypotheticalMainSize
=
AddChecked
(
mTotalOuterHypotheticalMainSize
aItemOuterHypotheticalMainSize
)
;
if
(
mNumItems
>
=
2
)
{
mTotalOuterHypotheticalMainSize
=
AddChecked
(
mTotalOuterHypotheticalMainSize
mMainGapSize
)
;
}
}
void
ComputeCrossSizeAndBaseline
(
const
FlexboxAxisTracker
&
aAxisTracker
)
;
nscoord
LineCrossSize
(
)
const
{
return
mLineCrossSize
;
}
void
SetLineCrossSize
(
nscoord
aLineCrossSize
)
{
mLineCrossSize
=
aLineCrossSize
;
}
nscoord
FirstBaselineOffset
(
)
const
{
return
mFirstBaselineOffset
;
}
nscoord
LastBaselineOffset
(
)
const
{
return
mLastBaselineOffset
;
}
nscoord
MainGapSize
(
)
const
{
return
mMainGapSize
;
}
inline
void
SetMainGapSize
(
nscoord
aNewSize
)
{
mMainGapSize
=
aNewSize
;
}
void
ResolveFlexibleLengths
(
nscoord
aFlexContainerMainSize
ComputedFlexLineInfo
*
aLineInfo
)
;
void
PositionItemsInMainAxis
(
const
StyleContentDistribution
&
aJustifyContent
nscoord
aContentBoxMainSize
const
FlexboxAxisTracker
&
aAxisTracker
)
;
void
PositionItemsInCrossAxis
(
nscoord
aLineStartPosition
const
FlexboxAxisTracker
&
aAxisTracker
)
;
private
:
void
FreezeItemsEarly
(
bool
aIsUsingFlexGrow
ComputedFlexLineInfo
*
aLineInfo
)
;
void
FreezeOrRestoreEachFlexibleSize
(
const
nscoord
aTotalViolation
bool
aIsFinalIteration
)
;
AutoCleanLinkedList
<
FlexItem
>
mItems
;
uint32_t
mNumItems
=
0
;
uint32_t
mNumFrozenItems
=
0
;
nscoord
mTotalItemMBP
=
0
;
nscoord
mTotalOuterHypotheticalMainSize
=
0
;
nscoord
mLineCrossSize
=
0
;
nscoord
mFirstBaselineOffset
=
nscoord_MIN
;
nscoord
mLastBaselineOffset
=
nscoord_MIN
;
nscoord
mMainGapSize
=
0
;
}
;
struct
nsFlexContainerFrame
:
:
StrutInfo
{
StrutInfo
(
uint32_t
aItemIdx
nscoord
aStrutCrossSize
)
:
mItemIdx
(
aItemIdx
)
mStrutCrossSize
(
aStrutCrossSize
)
{
}
uint32_t
mItemIdx
;
nscoord
mStrutCrossSize
;
}
;
static
void
BuildStrutInfoFromCollapsedItems
(
const
FlexLine
*
aFirstLine
nsTArray
<
StrutInfo
>
&
aStruts
)
{
MOZ_ASSERT
(
aFirstLine
"
null
first
line
pointer
"
)
;
MOZ_ASSERT
(
aStruts
.
IsEmpty
(
)
"
We
should
only
build
up
StrutInfo
once
per
reflow
so
"
"
aStruts
should
be
empty
when
this
is
called
"
)
;
uint32_t
itemIdxInContainer
=
0
;
for
(
const
FlexLine
*
line
=
aFirstLine
;
line
;
line
=
line
-
>
getNext
(
)
)
{
for
(
const
FlexItem
*
item
=
line
-
>
GetFirstItem
(
)
;
item
;
item
=
item
-
>
getNext
(
)
)
{
if
(
StyleVisibility
:
:
Collapse
=
=
item
-
>
Frame
(
)
-
>
StyleVisibility
(
)
-
>
mVisible
)
{
aStruts
.
AppendElement
(
StrutInfo
(
itemIdxInContainer
line
-
>
LineCrossSize
(
)
)
)
;
}
itemIdxInContainer
+
+
;
}
}
}
static
mozilla
:
:
StyleAlignFlags
SimplifyAlignOrJustifyContentForOneItem
(
const
StyleContentDistribution
&
aAlignmentVal
bool
aIsAlign
)
{
StyleAlignFlags
specified
=
aAlignmentVal
.
primary
;
specified
&
=
~
StyleAlignFlags
:
:
FLAG_BITS
;
if
(
specified
=
=
StyleAlignFlags
:
:
NORMAL
)
{
specified
=
StyleAlignFlags
:
:
STRETCH
;
}
if
(
!
aIsAlign
&
&
specified
=
=
StyleAlignFlags
:
:
STRETCH
)
{
return
StyleAlignFlags
:
:
FLEX_START
;
}
if
(
specified
=
=
StyleAlignFlags
:
:
SPACE_BETWEEN
)
{
return
StyleAlignFlags
:
:
START
;
}
if
(
specified
=
=
StyleAlignFlags
:
:
SPACE_AROUND
|
|
specified
=
=
StyleAlignFlags
:
:
SPACE_EVENLY
)
{
return
StyleAlignFlags
:
:
CENTER
;
}
return
specified
;
}
StyleAlignFlags
nsFlexContainerFrame
:
:
CSSAlignmentForAbsPosChild
(
const
ReflowInput
&
aChildRI
LogicalAxis
aLogicalAxis
)
const
{
WritingMode
wm
=
GetWritingMode
(
)
;
const
FlexboxAxisTracker
axisTracker
(
this
wm
AxisTrackerFlags
:
:
eAllowBottomToTopChildOrdering
)
;
const
bool
isMainAxis
=
(
axisTracker
.
IsRowOriented
(
)
=
=
(
aLogicalAxis
=
=
eLogicalAxisInline
)
)
;
const
nsStylePosition
*
containerStylePos
=
StylePosition
(
)
;
const
bool
isAxisReversed
=
isMainAxis
?
axisTracker
.
IsMainAxisReversed
(
)
:
axisTracker
.
IsCrossAxisReversed
(
)
;
StyleAlignFlags
alignment
{
0
}
;
StyleAlignFlags
alignmentFlags
{
0
}
;
if
(
isMainAxis
)
{
alignment
=
SimplifyAlignOrJustifyContentForOneItem
(
containerStylePos
-
>
mJustifyContent
false
)
;
}
else
{
const
StyleAlignFlags
alignContent
=
SimplifyAlignOrJustifyContentForOneItem
(
containerStylePos
-
>
mAlignContent
true
)
;
if
(
StyleFlexWrap
:
:
Nowrap
!
=
containerStylePos
-
>
mFlexWrap
&
&
alignContent
!
=
StyleAlignFlags
:
:
STRETCH
)
{
alignment
=
alignContent
;
}
else
{
alignment
=
aChildRI
.
mStylePosition
-
>
UsedAlignSelf
(
Style
(
)
)
.
_0
;
alignmentFlags
=
alignment
&
StyleAlignFlags
:
:
FLAG_BITS
;
alignment
&
=
~
StyleAlignFlags
:
:
FLAG_BITS
;
if
(
alignment
=
=
StyleAlignFlags
:
:
NORMAL
)
{
alignment
=
aChildRI
.
mFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eReplaced
)
?
StyleAlignFlags
:
:
START
:
StyleAlignFlags
:
:
STRETCH
;
}
}
}
if
(
alignment
=
=
StyleAlignFlags
:
:
FLEX_START
)
{
alignment
=
isAxisReversed
?
StyleAlignFlags
:
:
END
:
StyleAlignFlags
:
:
START
;
}
else
if
(
alignment
=
=
StyleAlignFlags
:
:
FLEX_END
)
{
alignment
=
isAxisReversed
?
StyleAlignFlags
:
:
START
:
StyleAlignFlags
:
:
END
;
}
else
if
(
alignment
=
=
StyleAlignFlags
:
:
LEFT
|
|
alignment
=
=
StyleAlignFlags
:
:
RIGHT
)
{
if
(
aLogicalAxis
=
=
eLogicalAxisInline
)
{
const
bool
isLeft
=
(
alignment
=
=
StyleAlignFlags
:
:
LEFT
)
;
alignment
=
(
isLeft
=
=
wm
.
IsBidiLTR
(
)
)
?
StyleAlignFlags
:
:
START
:
StyleAlignFlags
:
:
END
;
}
else
{
alignment
=
StyleAlignFlags
:
:
START
;
}
}
else
if
(
alignment
=
=
StyleAlignFlags
:
:
BASELINE
)
{
alignment
=
StyleAlignFlags
:
:
START
;
}
else
if
(
alignment
=
=
StyleAlignFlags
:
:
LAST_BASELINE
)
{
alignment
=
StyleAlignFlags
:
:
END
;
}
return
(
alignment
|
alignmentFlags
)
;
}
UniquePtr
<
FlexItem
>
nsFlexContainerFrame
:
:
GenerateFlexItemForChild
(
nsPresContext
*
aPresContext
nsIFrame
*
aChildFrame
const
ReflowInput
&
aParentReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
bool
aHasLineClampEllipsis
)
{
ReflowInput
childRI
(
aPresContext
aParentReflowInput
aChildFrame
aParentReflowInput
.
ComputedSize
(
aChildFrame
-
>
GetWritingMode
(
)
)
)
;
childRI
.
mFlags
.
mInsideLineClamp
=
GetLineClampValue
(
)
!
=
0
;
float
flexGrow
flexShrink
;
if
(
IsLegacyBox
(
this
)
)
{
if
(
GetLineClampValue
(
)
!
=
0
)
{
flexGrow
=
flexShrink
=
0
;
}
else
{
flexGrow
=
flexShrink
=
aChildFrame
-
>
StyleXUL
(
)
-
>
mBoxFlex
;
}
}
else
{
const
nsStylePosition
*
stylePos
=
aChildFrame
-
>
StylePosition
(
)
;
flexGrow
=
stylePos
-
>
mFlexGrow
;
flexShrink
=
stylePos
-
>
mFlexShrink
;
}
WritingMode
childWM
=
childRI
.
GetWritingMode
(
)
;
nscoord
flexBaseSize
=
GET_MAIN_COMPONENT_LOGICAL
(
aAxisTracker
childWM
childRI
.
ComputedISize
(
)
childRI
.
ComputedBSize
(
)
)
;
nscoord
mainMinSize
=
GET_MAIN_COMPONENT_LOGICAL
(
aAxisTracker
childWM
childRI
.
ComputedMinISize
(
)
childRI
.
ComputedMinBSize
(
)
)
;
nscoord
mainMaxSize
=
GET_MAIN_COMPONENT_LOGICAL
(
aAxisTracker
childWM
childRI
.
ComputedMaxISize
(
)
childRI
.
ComputedMaxBSize
(
)
)
;
MOZ_ASSERT
(
mainMinSize
<
=
mainMaxSize
"
min
size
is
larger
than
max
size
"
)
;
nscoord
tentativeCrossSize
=
GET_CROSS_COMPONENT_LOGICAL
(
aAxisTracker
childWM
childRI
.
ComputedISize
(
)
childRI
.
ComputedBSize
(
)
)
;
nscoord
crossMinSize
=
GET_CROSS_COMPONENT_LOGICAL
(
aAxisTracker
childWM
childRI
.
ComputedMinISize
(
)
childRI
.
ComputedMinBSize
(
)
)
;
nscoord
crossMaxSize
=
GET_CROSS_COMPONENT_LOGICAL
(
aAxisTracker
childWM
childRI
.
ComputedMaxISize
(
)
childRI
.
ComputedMaxBSize
(
)
)
;
bool
isFixedSizeWidget
=
false
;
const
nsStyleDisplay
*
disp
=
aChildFrame
-
>
StyleDisplay
(
)
;
if
(
aChildFrame
-
>
IsThemed
(
disp
)
)
{
LayoutDeviceIntSize
widgetMinSize
;
bool
canOverride
=
true
;
aPresContext
-
>
GetTheme
(
)
-
>
GetMinimumWidgetSize
(
aPresContext
aChildFrame
disp
-
>
mAppearance
&
widgetMinSize
&
canOverride
)
;
nscoord
widgetMainMinSize
=
aPresContext
-
>
DevPixelsToAppUnits
(
aAxisTracker
.
MainComponent
(
widgetMinSize
)
)
;
nscoord
widgetCrossMinSize
=
aPresContext
-
>
DevPixelsToAppUnits
(
aAxisTracker
.
CrossComponent
(
widgetMinSize
)
)
;
const
LogicalMargin
bpInChildWM
=
childRI
.
ComputedLogicalBorderPadding
(
)
;
const
LogicalMargin
bpInFlexWM
=
bpInChildWM
.
ConvertTo
(
aAxisTracker
.
GetWritingMode
(
)
childWM
)
;
widgetMainMinSize
-
=
aAxisTracker
.
MarginSizeInMainAxis
(
bpInFlexWM
)
;
widgetCrossMinSize
-
=
aAxisTracker
.
MarginSizeInCrossAxis
(
bpInFlexWM
)
;
widgetMainMinSize
=
std
:
:
max
(
0
widgetMainMinSize
)
;
widgetCrossMinSize
=
std
:
:
max
(
0
widgetCrossMinSize
)
;
if
(
!
canOverride
)
{
flexBaseSize
=
mainMinSize
=
mainMaxSize
=
widgetMainMinSize
;
tentativeCrossSize
=
crossMinSize
=
crossMaxSize
=
widgetCrossMinSize
;
isFixedSizeWidget
=
true
;
}
else
{
mainMinSize
=
std
:
:
max
(
mainMinSize
widgetMainMinSize
)
;
mainMaxSize
=
std
:
:
max
(
mainMaxSize
widgetMainMinSize
)
;
if
(
tentativeCrossSize
!
=
NS_UNCONSTRAINEDSIZE
)
{
tentativeCrossSize
=
std
:
:
max
(
tentativeCrossSize
widgetCrossMinSize
)
;
}
crossMinSize
=
std
:
:
max
(
crossMinSize
widgetCrossMinSize
)
;
crossMaxSize
=
std
:
:
max
(
crossMaxSize
widgetCrossMinSize
)
;
}
}
auto
item
=
MakeUnique
<
FlexItem
>
(
childRI
flexGrow
flexShrink
flexBaseSize
mainMinSize
mainMaxSize
tentativeCrossSize
crossMinSize
crossMaxSize
aAxisTracker
)
;
if
(
isFixedSizeWidget
|
|
(
flexGrow
=
=
0
.
0f
&
&
flexShrink
=
=
0
.
0f
)
)
{
item
-
>
Freeze
(
)
;
if
(
flexBaseSize
<
mainMinSize
)
{
item
-
>
SetWasMinClamped
(
)
;
}
else
if
(
flexBaseSize
>
mainMaxSize
)
{
item
-
>
SetWasMaxClamped
(
)
;
}
}
ResolveAutoFlexBasisAndMinSize
(
aPresContext
*
item
childRI
aAxisTracker
aHasLineClampEllipsis
)
;
return
item
;
}
static
bool
IsCrossSizeDefinite
(
const
ReflowInput
&
aItemReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
)
{
const
nsStylePosition
*
pos
=
aItemReflowInput
.
mStylePosition
;
const
WritingMode
containerWM
=
aAxisTracker
.
GetWritingMode
(
)
;
if
(
aAxisTracker
.
IsColumnOriented
(
)
)
{
return
!
pos
-
>
ISize
(
containerWM
)
.
IsAuto
(
)
;
}
nscoord
cbBSize
=
aItemReflowInput
.
mCBReflowInput
-
>
ComputedBSize
(
)
;
return
!
nsLayoutUtils
:
:
IsAutoBSize
(
pos
-
>
BSize
(
containerWM
)
cbBSize
)
;
}
static
nscoord
CrossSizeToUseWithRatio
(
const
FlexItem
&
aFlexItem
const
ReflowInput
&
aItemReflowInput
bool
aMinSizeFallback
const
FlexboxAxisTracker
&
aAxisTracker
)
{
if
(
aFlexItem
.
IsStretched
(
)
)
{
return
aFlexItem
.
CrossSize
(
)
;
}
if
(
IsCrossSizeDefinite
(
aItemReflowInput
aAxisTracker
)
)
{
return
GET_CROSS_COMPONENT_LOGICAL
(
aAxisTracker
aFlexItem
.
GetWritingMode
(
)
aItemReflowInput
.
ComputedISize
(
)
aItemReflowInput
.
ComputedBSize
(
)
)
;
}
if
(
aMinSizeFallback
)
{
return
GET_CROSS_COMPONENT_LOGICAL
(
aAxisTracker
aFlexItem
.
GetWritingMode
(
)
aItemReflowInput
.
ComputedMinISize
(
)
aItemReflowInput
.
ComputedMinBSize
(
)
)
;
}
return
NS_UNCONSTRAINEDSIZE
;
}
static
nscoord
MainSizeFromAspectRatio
(
nscoord
aCrossSize
const
AspectRatio
&
aIntrinsicRatio
const
FlexboxAxisTracker
&
aAxisTracker
)
{
MOZ_ASSERT
(
aIntrinsicRatio
"
Invalid
ratio
;
will
divide
by
0
!
Caller
should
'
ve
checked
.
.
.
"
)
;
AspectRatio
ratio
=
aAxisTracker
.
IsMainAxisHorizontal
(
)
?
aIntrinsicRatio
:
aIntrinsicRatio
.
Inverted
(
)
;
return
ratio
.
ApplyTo
(
aCrossSize
)
;
}
static
nscoord
PartiallyResolveAutoMinSize
(
const
FlexItem
&
aFlexItem
const
ReflowInput
&
aItemReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
)
{
MOZ_ASSERT
(
aFlexItem
.
NeedsMinSizeAutoResolution
(
)
"
only
call
for
FlexItems
that
need
min
-
size
auto
resolution
"
)
;
nscoord
minMainSize
=
nscoord_MAX
;
if
(
aItemReflowInput
.
mStylePosition
-
>
mFlexBasis
.
IsAuto
(
)
&
&
aFlexItem
.
FlexBaseSize
(
)
!
=
NS_UNCONSTRAINEDSIZE
)
{
minMainSize
=
std
:
:
min
(
minMainSize
aFlexItem
.
FlexBaseSize
(
)
)
;
}
nscoord
maxSize
=
GET_MAIN_COMPONENT_LOGICAL
(
aAxisTracker
aFlexItem
.
GetWritingMode
(
)
aItemReflowInput
.
ComputedMaxISize
(
)
aItemReflowInput
.
ComputedMaxBSize
(
)
)
;
if
(
maxSize
!
=
NS_UNCONSTRAINEDSIZE
)
{
minMainSize
=
std
:
:
min
(
minMainSize
maxSize
)
;
}
if
(
aFlexItem
.
IntrinsicRatio
(
)
)
{
const
bool
useMinSizeIfCrossSizeIsIndefinite
=
true
;
nscoord
crossSizeToUseWithRatio
=
CrossSizeToUseWithRatio
(
aFlexItem
aItemReflowInput
useMinSizeIfCrossSizeIsIndefinite
aAxisTracker
)
;
nscoord
minMainSizeFromRatio
=
MainSizeFromAspectRatio
(
crossSizeToUseWithRatio
aFlexItem
.
IntrinsicRatio
(
)
aAxisTracker
)
;
minMainSize
=
std
:
:
min
(
minMainSize
minMainSizeFromRatio
)
;
}
return
minMainSize
;
}
static
bool
ResolveAutoFlexBasisFromRatio
(
FlexItem
&
aFlexItem
const
ReflowInput
&
aItemReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
)
{
MOZ_ASSERT
(
NS_UNCONSTRAINEDSIZE
=
=
aFlexItem
.
FlexBaseSize
(
)
"
Should
only
be
called
to
resolve
an
'
auto
'
flex
-
basis
"
)
;
if
(
aFlexItem
.
IntrinsicRatio
(
)
)
{
const
bool
useMinSizeIfCrossSizeIsIndefinite
=
false
;
nscoord
crossSizeToUseWithRatio
=
CrossSizeToUseWithRatio
(
aFlexItem
aItemReflowInput
useMinSizeIfCrossSizeIsIndefinite
aAxisTracker
)
;
if
(
crossSizeToUseWithRatio
!
=
NS_UNCONSTRAINEDSIZE
)
{
nscoord
mainSizeFromRatio
=
MainSizeFromAspectRatio
(
crossSizeToUseWithRatio
aFlexItem
.
IntrinsicRatio
(
)
aAxisTracker
)
;
aFlexItem
.
SetFlexBaseSizeAndMainSize
(
mainSizeFromRatio
)
;
return
true
;
}
}
return
false
;
}
void
nsFlexContainerFrame
:
:
ResolveAutoFlexBasisAndMinSize
(
nsPresContext
*
aPresContext
FlexItem
&
aFlexItem
const
ReflowInput
&
aItemReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
bool
aHasLineClampEllipsis
)
{
const
bool
isMainSizeAuto
=
(
!
aFlexItem
.
IsInlineAxisMainAxis
(
)
&
&
NS_UNCONSTRAINEDSIZE
=
=
aFlexItem
.
FlexBaseSize
(
)
)
;
const
bool
isMainMinSizeAuto
=
aFlexItem
.
NeedsMinSizeAutoResolution
(
)
;
if
(
!
isMainSizeAuto
&
&
!
isMainMinSizeAuto
)
{
return
;
}
const
ReflowInput
*
flexContainerRI
=
aItemReflowInput
.
mParentReflowInput
;
MOZ_ASSERT
(
flexContainerRI
"
flex
item
'
s
reflow
input
should
have
ptr
to
container
'
s
state
"
)
;
if
(
StyleFlexWrap
:
:
Nowrap
=
=
flexContainerRI
-
>
mStylePosition
-
>
mFlexWrap
)
{
nscoord
containerCrossSize
=
GET_CROSS_COMPONENT_LOGICAL
(
aAxisTracker
aAxisTracker
.
GetWritingMode
(
)
flexContainerRI
-
>
ComputedISize
(
)
flexContainerRI
-
>
ComputedBSize
(
)
)
;
if
(
aAxisTracker
.
IsColumnOriented
(
)
|
|
containerCrossSize
!
=
NS_UNCONSTRAINEDSIZE
)
{
aFlexItem
.
ResolveStretchedCrossSize
(
containerCrossSize
)
;
}
}
nscoord
resolvedMinSize
;
bool
minSizeNeedsToMeasureContent
=
false
;
if
(
isMainMinSizeAuto
)
{
resolvedMinSize
=
PartiallyResolveAutoMinSize
(
aFlexItem
aItemReflowInput
aAxisTracker
)
;
if
(
resolvedMinSize
>
0
&
&
!
aFlexItem
.
IntrinsicRatio
(
)
)
{
minSizeNeedsToMeasureContent
=
true
;
}
}
bool
flexBasisNeedsToMeasureContent
=
false
;
if
(
isMainSizeAuto
)
{
if
(
!
ResolveAutoFlexBasisFromRatio
(
aFlexItem
aItemReflowInput
aAxisTracker
)
)
{
flexBasisNeedsToMeasureContent
=
true
;
}
}
if
(
minSizeNeedsToMeasureContent
|
|
flexBasisNeedsToMeasureContent
)
{
if
(
aFlexItem
.
IsInlineAxisMainAxis
(
)
)
{
if
(
minSizeNeedsToMeasureContent
)
{
nscoord
frameMinISize
=
aFlexItem
.
Frame
(
)
-
>
GetMinISize
(
aItemReflowInput
.
mRenderingContext
)
;
resolvedMinSize
=
std
:
:
min
(
resolvedMinSize
frameMinISize
)
;
}
NS_ASSERTION
(
!
flexBasisNeedsToMeasureContent
"
flex
-
basis
:
auto
should
have
been
resolved
in
the
"
"
reflow
input
for
horizontal
flexbox
.
It
shouldn
'
t
need
"
"
special
handling
here
"
)
;
}
else
{
bool
forceBResizeForMeasuringReflow
=
!
aFlexItem
.
IsFrozen
(
)
|
|
!
flexBasisNeedsToMeasureContent
;
nscoord
contentBSize
=
MeasureFlexItemContentBSize
(
aPresContext
aFlexItem
forceBResizeForMeasuringReflow
aHasLineClampEllipsis
*
flexContainerRI
)
;
if
(
minSizeNeedsToMeasureContent
)
{
resolvedMinSize
=
std
:
:
min
(
resolvedMinSize
contentBSize
)
;
}
if
(
flexBasisNeedsToMeasureContent
)
{
aFlexItem
.
SetFlexBaseSizeAndMainSize
(
contentBSize
)
;
}
}
}
if
(
isMainMinSizeAuto
)
{
aFlexItem
.
UpdateMainMinSize
(
resolvedMinSize
)
;
}
}
class
nsFlexContainerFrame
:
:
CachedMeasuringReflowResult
{
struct
Key
{
const
LogicalSize
mComputedSize
;
const
nscoord
mComputedMinBSize
;
const
nscoord
mComputedMaxBSize
;
const
nscoord
mAvailableBSize
;
explicit
Key
(
const
ReflowInput
&
aRI
)
:
mComputedSize
(
aRI
.
ComputedSize
(
)
)
mComputedMinBSize
(
aRI
.
ComputedMinBSize
(
)
)
mComputedMaxBSize
(
aRI
.
ComputedMaxBSize
(
)
)
mAvailableBSize
(
aRI
.
AvailableBSize
(
)
)
{
}
bool
operator
=
=
(
const
Key
&
aOther
)
const
{
return
mComputedSize
=
=
aOther
.
mComputedSize
&
&
mComputedMinBSize
=
=
aOther
.
mComputedMinBSize
&
&
mComputedMaxBSize
=
=
aOther
.
mComputedMaxBSize
&
&
mAvailableBSize
=
=
aOther
.
mAvailableBSize
;
}
}
;
const
Key
mKey
;
const
nscoord
mBSize
;
const
nscoord
mAscent
;
public
:
CachedMeasuringReflowResult
(
const
ReflowInput
&
aReflowInput
const
ReflowOutput
&
aDesiredSize
)
:
mKey
(
aReflowInput
)
mBSize
(
aDesiredSize
.
BSize
(
aReflowInput
.
GetWritingMode
(
)
)
)
mAscent
(
aDesiredSize
.
BlockStartAscent
(
)
)
{
}
bool
IsValidFor
(
const
ReflowInput
&
aReflowInput
)
const
{
return
mKey
=
=
Key
(
aReflowInput
)
;
}
nscoord
BSize
(
)
const
{
return
mBSize
;
}
nscoord
Ascent
(
)
const
{
return
mAscent
;
}
}
;
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
CachedFlexMeasuringReflow
CachedMeasuringReflowResult
)
;
void
nsFlexContainerFrame
:
:
MarkCachedFlexMeasurementsDirty
(
nsIFrame
*
aItemFrame
)
{
aItemFrame
-
>
DeleteProperty
(
CachedFlexMeasuringReflow
(
)
)
;
}
const
CachedMeasuringReflowResult
&
nsFlexContainerFrame
:
:
MeasureAscentAndBSizeForFlexItem
(
FlexItem
&
aItem
nsPresContext
*
aPresContext
ReflowInput
&
aChildReflowInput
)
{
if
(
const
auto
*
cachedResult
=
aItem
.
Frame
(
)
-
>
GetProperty
(
CachedFlexMeasuringReflow
(
)
)
)
{
if
(
cachedResult
-
>
IsValidFor
(
aChildReflowInput
)
)
{
return
*
cachedResult
;
}
FLEX_LOG
(
"
[
perf
]
MeasureAscentAndBSizeForFlexItem
rejected
cached
value
"
)
;
}
else
{
FLEX_LOG
(
"
[
perf
]
MeasureAscentAndBSizeForFlexItem
didn
'
t
have
a
cached
value
"
)
;
}
ReflowOutput
childDesiredSize
(
aChildReflowInput
)
;
nsReflowStatus
childReflowStatus
;
const
ReflowChildFlags
flags
=
ReflowChildFlags
:
:
NoMoveFrame
;
ReflowChild
(
aItem
.
Frame
(
)
aPresContext
childDesiredSize
aChildReflowInput
0
0
flags
childReflowStatus
)
;
aItem
.
SetHadMeasuringReflow
(
)
;
MOZ_ASSERT
(
childReflowStatus
.
IsComplete
(
)
"
We
gave
flex
item
unconstrained
available
height
so
it
"
"
should
be
complete
"
)
;
FinishReflowChild
(
aItem
.
Frame
(
)
aPresContext
childDesiredSize
&
aChildReflowInput
0
0
flags
)
;
auto
result
=
new
CachedMeasuringReflowResult
(
aChildReflowInput
childDesiredSize
)
;
aItem
.
Frame
(
)
-
>
SetProperty
(
CachedFlexMeasuringReflow
(
)
result
)
;
return
*
result
;
}
void
nsFlexContainerFrame
:
:
MarkIntrinsicISizesDirty
(
)
{
mCachedMinISize
=
NS_INTRINSIC_ISIZE_UNKNOWN
;
mCachedPrefISize
=
NS_INTRINSIC_ISIZE_UNKNOWN
;
nsContainerFrame
:
:
MarkIntrinsicISizesDirty
(
)
;
}
nscoord
nsFlexContainerFrame
:
:
MeasureFlexItemContentBSize
(
nsPresContext
*
aPresContext
FlexItem
&
aFlexItem
bool
aForceBResizeForMeasuringReflow
bool
aHasLineClampEllipsis
const
ReflowInput
&
aParentReflowInput
)
{
WritingMode
wm
=
aFlexItem
.
Frame
(
)
-
>
GetWritingMode
(
)
;
LogicalSize
availSize
=
aParentReflowInput
.
ComputedSize
(
wm
)
;
availSize
.
BSize
(
wm
)
=
NS_UNCONSTRAINEDSIZE
;
ReflowInput
childRIForMeasuringBSize
(
aPresContext
aParentReflowInput
aFlexItem
.
Frame
(
)
availSize
Nothing
(
)
ReflowInput
:
:
CALLER_WILL_INIT
)
;
childRIForMeasuringBSize
.
mFlags
.
mIsFlexContainerMeasuringBSize
=
true
;
childRIForMeasuringBSize
.
mFlags
.
mInsideLineClamp
=
GetLineClampValue
(
)
!
=
0
;
childRIForMeasuringBSize
.
mFlags
.
mApplyLineClamp
=
childRIForMeasuringBSize
.
mFlags
.
mInsideLineClamp
|
|
aHasLineClampEllipsis
;
childRIForMeasuringBSize
.
Init
(
aPresContext
)
;
if
(
aFlexItem
.
IsStretched
(
)
)
{
childRIForMeasuringBSize
.
SetComputedISize
(
aFlexItem
.
CrossSize
(
)
)
;
childRIForMeasuringBSize
.
SetIResize
(
true
)
;
}
if
(
aForceBResizeForMeasuringReflow
)
{
childRIForMeasuringBSize
.
SetBResize
(
true
)
;
childRIForMeasuringBSize
.
mFlags
.
mIsBResizeForPercentages
=
true
;
}
const
CachedMeasuringReflowResult
&
reflowResult
=
MeasureAscentAndBSizeForFlexItem
(
aFlexItem
aPresContext
childRIForMeasuringBSize
)
;
aFlexItem
.
SetAscent
(
reflowResult
.
Ascent
(
)
)
;
nscoord
childDesiredBSize
=
reflowResult
.
BSize
(
)
-
childRIForMeasuringBSize
.
ComputedLogicalBorderPadding
(
)
.
BStartEnd
(
wm
)
;
return
std
:
:
max
(
0
childDesiredBSize
)
;
}
FlexItem
:
:
FlexItem
(
ReflowInput
&
aFlexItemReflowInput
float
aFlexGrow
float
aFlexShrink
nscoord
aFlexBaseSize
nscoord
aMainMinSize
nscoord
aMainMaxSize
nscoord
aTentativeCrossSize
nscoord
aCrossMinSize
nscoord
aCrossMaxSize
const
FlexboxAxisTracker
&
aAxisTracker
)
:
mFrame
(
aFlexItemReflowInput
.
mFrame
)
mFlexGrow
(
aFlexGrow
)
mFlexShrink
(
aFlexShrink
)
mIntrinsicRatio
(
mFrame
-
>
GetIntrinsicRatio
(
)
)
mWM
(
aFlexItemReflowInput
.
GetWritingMode
(
)
)
mCBWM
(
aAxisTracker
.
GetWritingMode
(
)
)
mMainAxis
(
aAxisTracker
.
MainAxis
(
)
)
mBorderPadding
(
aFlexItemReflowInput
.
ComputedLogicalBorderPadding
(
)
.
ConvertTo
(
mCBWM
mWM
)
)
mMargin
(
aFlexItemReflowInput
.
ComputedLogicalMargin
(
)
.
ConvertTo
(
mCBWM
mWM
)
)
mMainMinSize
(
aMainMinSize
)
mMainMaxSize
(
aMainMaxSize
)
mCrossMinSize
(
aCrossMinSize
)
mCrossMaxSize
(
aCrossMaxSize
)
mCrossSize
(
aTentativeCrossSize
)
mIsInlineAxisMainAxis
(
aAxisTracker
.
IsRowOriented
(
)
!
=
aAxisTracker
.
GetWritingMode
(
)
.
IsOrthogonalTo
(
mWM
)
)
{
MOZ_ASSERT
(
mFrame
"
expecting
a
non
-
null
child
frame
"
)
;
MOZ_ASSERT
(
!
mFrame
-
>
IsPlaceholderFrame
(
)
"
placeholder
frames
should
not
be
treated
as
flex
items
"
)
;
MOZ_ASSERT
(
!
(
mFrame
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
"
out
-
of
-
flow
frames
should
not
be
treated
as
flex
items
"
)
;
MOZ_ASSERT
(
mIsInlineAxisMainAxis
=
=
nsFlexContainerFrame
:
:
IsItemInlineAxisMainAxis
(
mFrame
)
"
public
API
should
be
consistent
with
internal
state
(
about
"
"
whether
flex
item
'
s
inline
axis
is
flex
container
'
s
main
axis
)
"
)
;
const
ReflowInput
*
containerRS
=
aFlexItemReflowInput
.
mParentReflowInput
;
if
(
IsLegacyBox
(
containerRS
-
>
mFrame
)
)
{
const
nsStyleXUL
*
containerStyleXUL
=
containerRS
-
>
mFrame
-
>
StyleXUL
(
)
;
mAlignSelf
=
{
ConvertLegacyStyleToAlignItems
(
containerStyleXUL
)
}
;
mAlignSelfFlags
=
{
0
}
;
}
else
{
mAlignSelf
=
aFlexItemReflowInput
.
mStylePosition
-
>
UsedAlignSelf
(
containerRS
-
>
mFrame
-
>
Style
(
)
)
;
if
(
MOZ_LIKELY
(
mAlignSelf
.
_0
=
=
StyleAlignFlags
:
:
NORMAL
)
)
{
mAlignSelf
=
{
StyleAlignFlags
:
:
STRETCH
}
;
}
mAlignSelfFlags
=
mAlignSelf
.
_0
&
StyleAlignFlags
:
:
FLAG_BITS
;
mAlignSelf
.
_0
&
=
~
StyleAlignFlags
:
:
FLAG_BITS
;
}
if
(
mIsInlineAxisMainAxis
)
{
mTreatBSizeAsIndefinite
=
false
;
}
else
{
if
(
aAxisTracker
.
IsRowOriented
(
)
|
|
(
containerRS
-
>
ComputedBSize
(
)
!
=
NS_UNCONSTRAINEDSIZE
&
&
!
containerRS
-
>
mFlags
.
mTreatBSizeAsIndefinite
)
)
{
mTreatBSizeAsIndefinite
=
false
;
}
else
if
(
aFlexBaseSize
!
=
NS_UNCONSTRAINEDSIZE
)
{
mTreatBSizeAsIndefinite
=
false
;
}
else
{
mTreatBSizeAsIndefinite
=
true
;
}
}
SetFlexBaseSizeAndMainSize
(
aFlexBaseSize
)
;
CheckForMinSizeAuto
(
aFlexItemReflowInput
aAxisTracker
)
;
const
nsStyleMargin
*
styleMargin
=
aFlexItemReflowInput
.
mStyleMargin
;
mHasAnyAutoMargin
=
styleMargin
-
>
HasInlineAxisAuto
(
mCBWM
)
|
|
styleMargin
-
>
HasBlockAxisAuto
(
mCBWM
)
;
#
ifdef
DEBUG
{
for
(
const
auto
side
:
AllLogicalSides
(
)
)
{
if
(
styleMargin
-
>
mMargin
.
Get
(
mCBWM
side
)
.
IsAuto
(
)
)
{
MOZ_ASSERT
(
GetMarginComponentForSide
(
side
)
=
=
0
"
Someone
else
tried
to
resolve
our
auto
margin
"
)
;
}
}
}
#
endif
if
(
!
IsBlockAxisCrossAxis
(
)
)
{
if
(
mAlignSelf
.
_0
=
=
StyleAlignFlags
:
:
BASELINE
)
{
mAlignSelf
=
{
StyleAlignFlags
:
:
FLEX_START
}
;
}
else
if
(
mAlignSelf
.
_0
=
=
StyleAlignFlags
:
:
LAST_BASELINE
)
{
mAlignSelf
=
{
StyleAlignFlags
:
:
FLEX_END
}
;
}
}
}
FlexItem
:
:
FlexItem
(
nsIFrame
*
aChildFrame
nscoord
aCrossSize
WritingMode
aContainerWM
)
:
mFrame
(
aChildFrame
)
mWM
(
aContainerWM
)
mCBWM
(
aContainerWM
)
mBorderPadding
(
mCBWM
)
mMargin
(
mCBWM
)
mCrossSize
(
aCrossSize
)
mIsFrozen
(
true
)
mIsStrut
(
true
)
mAlignSelf
(
{
StyleAlignFlags
:
:
FLEX_START
}
)
{
MOZ_ASSERT
(
mFrame
"
expecting
a
non
-
null
child
frame
"
)
;
MOZ_ASSERT
(
StyleVisibility
:
:
Collapse
=
=
mFrame
-
>
StyleVisibility
(
)
-
>
mVisible
"
Should
only
make
struts
for
children
with
'
visibility
:
collapse
'
"
)
;
MOZ_ASSERT
(
!
mFrame
-
>
IsPlaceholderFrame
(
)
"
placeholder
frames
should
not
be
treated
as
flex
items
"
)
;
MOZ_ASSERT
(
!
(
mFrame
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
"
out
-
of
-
flow
frames
should
not
be
treated
as
flex
items
"
)
;
}
void
FlexItem
:
:
CheckForMinSizeAuto
(
const
ReflowInput
&
aFlexItemReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
)
{
const
nsStylePosition
*
pos
=
aFlexItemReflowInput
.
mStylePosition
;
const
nsStyleDisplay
*
disp
=
aFlexItemReflowInput
.
mStyleDisplay
;
const
auto
&
mainMinSize
=
aAxisTracker
.
IsRowOriented
(
)
?
pos
-
>
MinISize
(
aAxisTracker
.
GetWritingMode
(
)
)
:
pos
-
>
MinBSize
(
aAxisTracker
.
GetWritingMode
(
)
)
;
mNeedsMinSizeAutoResolution
=
IsAutoOrEnumOnBSize
(
mainMinSize
IsInlineAxisMainAxis
(
)
)
&
&
!
disp
-
>
IsScrollableOverflow
(
)
;
}
nscoord
FlexItem
:
:
BaselineOffsetFromOuterCrossEdge
(
mozilla
:
:
Side
aStartSide
const
FlexboxAxisTracker
&
aAxisTracker
bool
aUseFirstLineBaseline
)
const
{
MOZ_ASSERT
(
IsBlockAxisCrossAxis
(
)
"
Only
expecting
to
be
doing
baseline
computations
when
the
"
"
cross
axis
is
the
block
axis
"
)
;
mozilla
:
:
Side
itemBlockStartSide
=
mWM
.
PhysicalSide
(
eLogicalSideBStart
)
;
nscoord
marginBStartToBaseline
=
ResolvedAscent
(
aUseFirstLineBaseline
)
+
PhysicalMargin
(
)
.
Side
(
itemBlockStartSide
)
;
return
(
aStartSide
=
=
itemBlockStartSide
)
?
marginBStartToBaseline
:
OuterCrossSize
(
)
-
marginBStartToBaseline
;
}
bool
FlexItem
:
:
IsCrossSizeAuto
(
)
const
{
const
nsStylePosition
*
stylePos
=
mFrame
-
>
StylePosition
(
)
;
return
IsInlineAxisCrossAxis
(
)
?
stylePos
-
>
ISize
(
mWM
)
.
IsAuto
(
)
:
stylePos
-
>
BSize
(
mWM
)
.
IsAuto
(
)
;
}
uint32_t
FlexItem
:
:
NumAutoMarginsInAxis
(
LogicalAxis
aAxis
)
const
{
uint32_t
numAutoMargins
=
0
;
const
auto
&
styleMargin
=
mFrame
-
>
StyleMargin
(
)
-
>
mMargin
;
for
(
const
auto
edge
:
{
eLogicalEdgeStart
eLogicalEdgeEnd
}
)
{
const
auto
side
=
MakeLogicalSide
(
aAxis
edge
)
;
if
(
styleMargin
.
Get
(
mCBWM
side
)
.
IsAuto
(
)
)
{
numAutoMargins
+
+
;
}
}
MOZ_ASSERT
(
numAutoMargins
<
=
2
"
We
'
re
just
looking
at
one
item
along
one
dimension
so
we
"
"
should
only
have
examined
2
margins
"
)
;
return
numAutoMargins
;
}
bool
FlexItem
:
:
CanMainSizeInfluenceCrossSize
(
const
FlexboxAxisTracker
&
aAxisTracker
)
const
{
if
(
mIsStretched
)
{
return
false
;
}
if
(
mIsStrut
)
{
return
false
;
}
if
(
HasIntrinsicRatio
(
)
)
{
return
true
;
}
if
(
IsInlineAxisCrossAxis
(
)
)
{
if
(
mFrame
-
>
IsBlockFrame
(
)
|
|
mFrame
-
>
IsTableWrapperFrame
(
)
)
{
return
false
;
}
}
return
true
;
}
class
MOZ_STACK_CLASS
PositionTracker
{
public
:
inline
nscoord
Position
(
)
const
{
return
mPosition
;
}
inline
LogicalAxis
Axis
(
)
const
{
return
mAxis
;
}
inline
LogicalSide
StartSide
(
)
{
return
MakeLogicalSide
(
mAxis
mIsAxisReversed
?
eLogicalEdgeEnd
:
eLogicalEdgeStart
)
;
}
inline
LogicalSide
EndSide
(
)
{
return
MakeLogicalSide
(
mAxis
mIsAxisReversed
?
eLogicalEdgeStart
:
eLogicalEdgeEnd
)
;
}
void
EnterMargin
(
const
LogicalMargin
&
aMargin
)
{
mPosition
+
=
aMargin
.
Side
(
StartSide
(
)
mWM
)
;
}
void
ExitMargin
(
const
LogicalMargin
&
aMargin
)
{
mPosition
+
=
aMargin
.
Side
(
EndSide
(
)
mWM
)
;
}
void
EnterChildFrame
(
nscoord
aChildFrameSize
)
{
if
(
mIsAxisReversed
)
{
mPosition
+
=
aChildFrameSize
;
}
}
void
ExitChildFrame
(
nscoord
aChildFrameSize
)
{
if
(
!
mIsAxisReversed
)
{
mPosition
+
=
aChildFrameSize
;
}
}
PositionTracker
(
const
PositionTracker
&
)
=
delete
;
PositionTracker
&
operator
=
(
const
PositionTracker
&
)
=
delete
;
protected
:
PositionTracker
(
WritingMode
aWM
LogicalAxis
aAxis
bool
aIsAxisReversed
)
:
mWM
(
aWM
)
mAxis
(
aAxis
)
mIsAxisReversed
(
aIsAxisReversed
)
{
}
nscoord
mPosition
=
0
;
const
WritingMode
mWM
;
const
LogicalAxis
mAxis
=
eLogicalAxisInline
;
const
bool
mIsAxisReversed
=
false
;
}
;
class
MOZ_STACK_CLASS
MainAxisPositionTracker
:
public
PositionTracker
{
public
:
MainAxisPositionTracker
(
const
FlexboxAxisTracker
&
aAxisTracker
const
FlexLine
*
aLine
const
StyleContentDistribution
&
aJustifyContent
nscoord
aContentBoxMainSize
)
;
~
MainAxisPositionTracker
(
)
{
MOZ_ASSERT
(
mNumPackingSpacesRemaining
=
=
0
"
miscounted
the
number
of
packing
spaces
"
)
;
MOZ_ASSERT
(
mNumAutoMarginsInMainAxis
=
=
0
"
miscounted
the
number
of
auto
margins
"
)
;
}
void
TraverseGap
(
nscoord
aGapSize
)
{
mPosition
+
=
aGapSize
;
}
void
TraversePackingSpace
(
)
;
void
ResolveAutoMarginsInMainAxis
(
FlexItem
&
aItem
)
;
private
:
nscoord
mPackingSpaceRemaining
=
0
;
uint32_t
mNumAutoMarginsInMainAxis
=
0
;
uint32_t
mNumPackingSpacesRemaining
=
0
;
StyleContentDistribution
mJustifyContent
=
{
StyleAlignFlags
:
:
AUTO
}
;
}
;
class
MOZ_STACK_CLASS
CrossAxisPositionTracker
:
public
PositionTracker
{
public
:
CrossAxisPositionTracker
(
FlexLine
*
aFirstLine
const
ReflowInput
&
aReflowInput
nscoord
aContentBoxCrossSize
bool
aIsCrossSizeDefinite
const
FlexboxAxisTracker
&
aAxisTracker
const
nscoord
aCrossGapSize
)
;
void
TraverseGap
(
)
{
mPosition
+
=
mCrossGapSize
;
}
void
TraversePackingSpace
(
)
;
void
TraverseLine
(
FlexLine
&
aLine
)
{
mPosition
+
=
aLine
.
LineCrossSize
(
)
;
}
inline
void
SetCrossGapSize
(
nscoord
aNewSize
)
{
mCrossGapSize
=
aNewSize
;
}
void
EnterMargin
(
const
LogicalMargin
&
aMargin
)
=
delete
;
void
ExitMargin
(
const
LogicalMargin
&
aMargin
)
=
delete
;
void
EnterChildFrame
(
nscoord
aChildFrameSize
)
=
delete
;
void
ExitChildFrame
(
nscoord
aChildFrameSize
)
=
delete
;
private
:
nscoord
mPackingSpaceRemaining
=
0
;
uint32_t
mNumPackingSpacesRemaining
=
0
;
StyleContentDistribution
mAlignContent
=
{
StyleAlignFlags
:
:
AUTO
}
;
nscoord
mCrossGapSize
=
0
;
}
;
class
MOZ_STACK_CLASS
SingleLineCrossAxisPositionTracker
:
public
PositionTracker
{
public
:
explicit
SingleLineCrossAxisPositionTracker
(
const
FlexboxAxisTracker
&
aAxisTracker
)
;
void
ResolveAutoMarginsInCrossAxis
(
const
FlexLine
&
aLine
FlexItem
&
aItem
)
;
void
EnterAlignPackingSpace
(
const
FlexLine
&
aLine
const
FlexItem
&
aItem
const
FlexboxAxisTracker
&
aAxisTracker
)
;
inline
void
ResetPosition
(
)
{
mPosition
=
0
;
}
}
;
NS_QUERYFRAME_HEAD
(
nsFlexContainerFrame
)
NS_QUERYFRAME_ENTRY
(
nsFlexContainerFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsContainerFrame
)
NS_IMPL_FRAMEARENA_HELPERS
(
nsFlexContainerFrame
)
nsContainerFrame
*
NS_NewFlexContainerFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsFlexContainerFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
nsFlexContainerFrame
:
:
~
nsFlexContainerFrame
(
)
{
}
void
nsFlexContainerFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
nsContainerFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
if
(
GetStateBits
(
)
&
NS_FRAME_FONT_INFLATION_CONTAINER
)
{
AddStateBits
(
NS_FRAME_FONT_INFLATION_FLOW_ROOT
)
;
}
const
nsStyleDisplay
*
styleDisp
=
Style
(
)
-
>
StyleDisplay
(
)
;
bool
isLegacyBox
=
IsDisplayValueLegacyBox
(
styleDisp
)
;
if
(
!
isLegacyBox
&
&
styleDisp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
Block
)
{
ComputedStyle
*
parentComputedStyle
=
GetParent
(
)
-
>
Style
(
)
;
NS_ASSERTION
(
Style
(
)
-
>
GetPseudoType
(
)
=
=
PseudoStyleType
:
:
buttonContent
|
|
Style
(
)
-
>
GetPseudoType
(
)
=
=
PseudoStyleType
:
:
scrolledContent
"
The
only
way
a
nsFlexContainerFrame
can
have
'
display
:
block
'
"
"
should
be
if
it
'
s
the
inner
part
of
a
scrollable
or
button
"
"
element
"
)
;
isLegacyBox
=
IsDisplayValueLegacyBox
(
parentComputedStyle
-
>
StyleDisplay
(
)
)
;
}
if
(
isLegacyBox
)
{
AddStateBits
(
NS_STATE_FLEX_IS_EMULATING_LEGACY_BOX
)
;
}
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
nsFlexContainerFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
NS_LITERAL_STRING
(
"
FlexContainer
"
)
aResult
)
;
}
#
endif
nscoord
nsFlexContainerFrame
:
:
GetLogicalBaseline
(
mozilla
:
:
WritingMode
aWM
)
const
{
NS_ASSERTION
(
mBaselineFromLastReflow
!
=
NS_INTRINSIC_ISIZE_UNKNOWN
"
baseline
has
not
been
set
"
)
;
if
(
HasAnyStateBits
(
NS_STATE_FLEX_SYNTHESIZE_BASELINE
)
)
{
return
nsContainerFrame
:
:
GetLogicalBaseline
(
aWM
)
;
}
return
mBaselineFromLastReflow
;
}
static
uint32_t
GetDisplayFlagsForFlexItem
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
-
>
IsFlexItem
(
)
"
Should
only
be
called
on
flex
items
"
)
;
const
nsStylePosition
*
pos
=
aFrame
-
>
StylePosition
(
)
;
if
(
pos
-
>
mZIndex
.
IsInteger
(
)
)
{
return
nsIFrame
:
:
DISPLAY_CHILD_FORCE_STACKING_CONTEXT
;
}
return
nsIFrame
:
:
DISPLAY_CHILD_FORCE_PSEUDO_STACKING_CONTEXT
;
}
void
nsFlexContainerFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
nsDisplayListCollection
tempLists
(
aBuilder
)
;
DisplayBorderBackgroundOutline
(
aBuilder
tempLists
)
;
nsDisplayListSet
childLists
(
tempLists
tempLists
.
BlockBorderBackgrounds
(
)
)
;
typedef
CSSOrderAwareFrameIterator
:
:
OrderState
OrderState
;
OrderState
orderState
=
HasAnyStateBits
(
NS_STATE_FLEX_NORMAL_FLOW_CHILDREN_IN_CSS_ORDER
)
?
OrderState
:
:
eKnownOrdered
:
OrderState
:
:
eKnownUnordered
;
CSSOrderAwareFrameIterator
iter
(
this
kPrincipalList
CSSOrderAwareFrameIterator
:
:
eIncludeAll
orderState
OrderingPropertyForIter
(
this
)
)
;
for
(
;
!
iter
.
AtEnd
(
)
;
iter
.
Next
(
)
)
{
nsIFrame
*
childFrame
=
*
iter
;
BuildDisplayListForChild
(
aBuilder
childFrame
childLists
GetDisplayFlagsForFlexItem
(
childFrame
)
)
;
}
wr
:
:
RenderRoot
renderRoot
=
gfxUtils
:
:
GetRenderRootForFrame
(
this
)
.
valueOr
(
wr
:
:
RenderRoot
:
:
Default
)
;
if
(
renderRoot
=
=
wr
:
:
RenderRoot
:
:
Default
)
{
tempLists
.
MoveTo
(
aLists
)
;
return
;
}
MOZ_ASSERT
(
!
XRE_IsContentProcess
(
)
)
;
nsDisplayListBuilder
:
:
AutoContainerASRTracker
contASRTracker
(
aBuilder
)
;
nsDisplayList
masterList
;
masterList
.
AppendToTop
(
tempLists
.
BorderBackground
(
)
)
;
masterList
.
AppendToTop
(
tempLists
.
BlockBorderBackgrounds
(
)
)
;
masterList
.
AppendToTop
(
tempLists
.
Floats
(
)
)
;
masterList
.
AppendToTop
(
tempLists
.
Content
(
)
)
;
masterList
.
AppendToTop
(
tempLists
.
PositionedDescendants
(
)
)
;
masterList
.
AppendToTop
(
tempLists
.
Outlines
(
)
)
;
const
ActiveScrolledRoot
*
ownLayerASR
=
contASRTracker
.
GetContainerASR
(
)
;
aLists
.
Content
(
)
-
>
AppendNewToTop
<
nsDisplayRenderRoot
>
(
aBuilder
this
&
masterList
ownLayerASR
renderRoot
)
;
}
void
FlexLine
:
:
FreezeItemsEarly
(
bool
aIsUsingFlexGrow
ComputedFlexLineInfo
*
aLineInfo
)
{
uint32_t
numUnfrozenItemsToBeSeen
=
mNumItems
-
mNumFrozenItems
;
for
(
FlexItem
*
item
=
mItems
.
getFirst
(
)
;
numUnfrozenItemsToBeSeen
>
0
;
item
=
item
-
>
getNext
(
)
)
{
MOZ_ASSERT
(
item
"
numUnfrozenItemsToBeSeen
says
items
remain
to
be
seen
"
)
;
if
(
!
item
-
>
IsFrozen
(
)
)
{
numUnfrozenItemsToBeSeen
-
-
;
bool
shouldFreeze
=
(
0
.
0f
=
=
item
-
>
GetFlexFactor
(
aIsUsingFlexGrow
)
)
;
if
(
!
shouldFreeze
)
{
if
(
aIsUsingFlexGrow
)
{
if
(
item
-
>
FlexBaseSize
(
)
>
item
-
>
MainSize
(
)
)
{
shouldFreeze
=
true
;
}
}
else
{
if
(
item
-
>
FlexBaseSize
(
)
<
item
-
>
MainSize
(
)
)
{
shouldFreeze
=
true
;
}
}
}
if
(
shouldFreeze
)
{
item
-
>
Freeze
(
)
;
if
(
item
-
>
FlexBaseSize
(
)
<
item
-
>
MainSize
(
)
)
{
item
-
>
SetWasMinClamped
(
)
;
}
else
if
(
item
-
>
FlexBaseSize
(
)
>
item
-
>
MainSize
(
)
)
{
item
-
>
SetWasMaxClamped
(
)
;
}
mNumFrozenItems
+
+
;
}
}
}
}
void
FlexLine
:
:
FreezeOrRestoreEachFlexibleSize
(
const
nscoord
aTotalViolation
bool
aIsFinalIteration
)
{
enum
FreezeType
{
eFreezeEverything
eFreezeMinViolations
eFreezeMaxViolations
}
;
FreezeType
freezeType
;
if
(
aTotalViolation
=
=
0
)
{
freezeType
=
eFreezeEverything
;
}
else
if
(
aTotalViolation
>
0
)
{
freezeType
=
eFreezeMinViolations
;
}
else
{
freezeType
=
eFreezeMaxViolations
;
}
uint32_t
numUnfrozenItemsToBeSeen
=
mNumItems
-
mNumFrozenItems
;
for
(
FlexItem
*
item
=
mItems
.
getFirst
(
)
;
numUnfrozenItemsToBeSeen
>
0
;
item
=
item
-
>
getNext
(
)
)
{
MOZ_ASSERT
(
item
"
numUnfrozenItemsToBeSeen
says
items
remain
to
be
seen
"
)
;
if
(
!
item
-
>
IsFrozen
(
)
)
{
numUnfrozenItemsToBeSeen
-
-
;
MOZ_ASSERT
(
!
item
-
>
HadMinViolation
(
)
|
|
!
item
-
>
HadMaxViolation
(
)
"
Can
have
either
min
or
max
violation
but
not
both
"
)
;
bool
hadMinViolation
=
item
-
>
HadMinViolation
(
)
;
bool
hadMaxViolation
=
item
-
>
HadMaxViolation
(
)
;
if
(
eFreezeEverything
=
=
freezeType
|
|
(
eFreezeMinViolations
=
=
freezeType
&
&
hadMinViolation
)
|
|
(
eFreezeMaxViolations
=
=
freezeType
&
&
hadMaxViolation
)
)
{
MOZ_ASSERT
(
item
-
>
MainSize
(
)
>
=
item
-
>
MainMinSize
(
)
"
Freezing
item
at
a
size
below
its
minimum
"
)
;
MOZ_ASSERT
(
item
-
>
MainSize
(
)
<
=
item
-
>
MainMaxSize
(
)
"
Freezing
item
at
a
size
above
its
maximum
"
)
;
item
-
>
Freeze
(
)
;
if
(
hadMinViolation
)
{
item
-
>
SetWasMinClamped
(
)
;
}
else
if
(
hadMaxViolation
)
{
item
-
>
SetWasMaxClamped
(
)
;
}
mNumFrozenItems
+
+
;
}
else
if
(
MOZ_UNLIKELY
(
aIsFinalIteration
)
)
{
NS_ERROR
(
"
Final
iteration
still
has
unfrozen
items
this
shouldn
'
t
"
"
happen
unless
there
was
nscoord
under
/
overflow
.
"
)
;
item
-
>
Freeze
(
)
;
mNumFrozenItems
+
+
;
}
if
(
!
item
-
>
IsFrozen
(
)
)
{
item
-
>
ClearViolationFlags
(
)
;
}
}
}
}
void
FlexLine
:
:
ResolveFlexibleLengths
(
nscoord
aFlexContainerMainSize
ComputedFlexLineInfo
*
aLineInfo
)
{
FLEX_LOG
(
"
ResolveFlexibleLengths
"
)
;
if
(
aLineInfo
)
{
uint32_t
itemIndex
=
0
;
for
(
FlexItem
*
item
=
mItems
.
getFirst
(
)
;
item
;
item
=
item
-
>
getNext
(
)
+
+
itemIndex
)
{
aLineInfo
-
>
mItems
[
itemIndex
]
.
mMainBaseSize
=
item
-
>
FlexBaseSize
(
)
;
aLineInfo
-
>
mItems
[
itemIndex
]
.
mMainDeltaSize
=
0
;
}
}
const
bool
isUsingFlexGrow
=
(
mTotalOuterHypotheticalMainSize
<
aFlexContainerMainSize
)
;
if
(
aLineInfo
)
{
aLineInfo
-
>
mGrowthState
=
isUsingFlexGrow
?
mozilla
:
:
dom
:
:
FlexLineGrowthState
:
:
Growing
:
mozilla
:
:
dom
:
:
FlexLineGrowthState
:
:
Shrinking
;
}
FreezeItemsEarly
(
isUsingFlexGrow
aLineInfo
)
;
if
(
(
mNumFrozenItems
=
=
mNumItems
)
&
&
!
aLineInfo
)
{
return
;
}
MOZ_ASSERT
(
!
IsEmpty
(
)
|
|
aLineInfo
"
empty
lines
should
take
the
early
-
return
above
"
)
;
nscoord
spaceAvailableForFlexItemsContentBoxes
=
aFlexContainerMainSize
-
(
mTotalItemMBP
+
SumOfGaps
(
)
)
;
nscoord
origAvailableFreeSpace
;
bool
isOrigAvailFreeSpaceInitialized
=
false
;
for
(
uint32_t
iterationCounter
=
0
;
iterationCounter
<
mNumItems
;
iterationCounter
+
+
)
{
nscoord
availableFreeSpace
=
spaceAvailableForFlexItemsContentBoxes
;
for
(
FlexItem
*
item
=
mItems
.
getFirst
(
)
;
item
;
item
=
item
-
>
getNext
(
)
)
{
if
(
!
item
-
>
IsFrozen
(
)
)
{
item
-
>
SetMainSize
(
item
-
>
FlexBaseSize
(
)
)
;
}
availableFreeSpace
-
=
item
-
>
MainSize
(
)
;
}
FLEX_LOG
(
"
available
free
space
=
%
d
"
availableFreeSpace
)
;
NS_ASSERTION
(
(
isUsingFlexGrow
&
&
availableFreeSpace
>
=
0
)
|
|
(
!
isUsingFlexGrow
&
&
availableFreeSpace
<
=
0
)
"
availableFreeSpace
'
s
sign
should
match
isUsingFlexGrow
"
)
;
if
(
availableFreeSpace
!
=
0
)
{
if
(
!
isOrigAvailFreeSpaceInitialized
)
{
origAvailableFreeSpace
=
availableFreeSpace
;
isOrigAvailFreeSpaceInitialized
=
true
;
}
float
weightSum
=
0
.
0f
;
float
flexFactorSum
=
0
.
0f
;
float
largestWeight
=
0
.
0f
;
uint32_t
numItemsWithLargestWeight
=
0
;
uint32_t
numUnfrozenItemsToBeSeen
=
mNumItems
-
mNumFrozenItems
;
for
(
FlexItem
*
item
=
mItems
.
getFirst
(
)
;
numUnfrozenItemsToBeSeen
>
0
;
item
=
item
-
>
getNext
(
)
)
{
MOZ_ASSERT
(
item
"
numUnfrozenItemsToBeSeen
says
items
remain
to
be
seen
"
)
;
if
(
!
item
-
>
IsFrozen
(
)
)
{
numUnfrozenItemsToBeSeen
-
-
;
float
curWeight
=
item
-
>
GetWeight
(
isUsingFlexGrow
)
;
float
curFlexFactor
=
item
-
>
GetFlexFactor
(
isUsingFlexGrow
)
;
MOZ_ASSERT
(
curWeight
>
=
0
.
0f
"
weights
are
non
-
negative
"
)
;
MOZ_ASSERT
(
curFlexFactor
>
=
0
.
0f
"
flex
factors
are
non
-
negative
"
)
;
weightSum
+
=
curWeight
;
flexFactorSum
+
=
curFlexFactor
;
if
(
IsFinite
(
weightSum
)
)
{
if
(
curWeight
=
=
0
.
0f
)
{
item
-
>
SetShareOfWeightSoFar
(
0
.
0f
)
;
}
else
{
item
-
>
SetShareOfWeightSoFar
(
curWeight
/
weightSum
)
;
}
}
if
(
curWeight
>
largestWeight
)
{
largestWeight
=
curWeight
;
numItemsWithLargestWeight
=
1
;
}
else
if
(
curWeight
=
=
largestWeight
)
{
numItemsWithLargestWeight
+
+
;
}
}
}
if
(
weightSum
!
=
0
.
0f
)
{
MOZ_ASSERT
(
flexFactorSum
!
=
0
.
0f
"
flex
factor
sum
can
'
t
be
0
if
a
weighted
sum
"
"
of
its
components
(
weightSum
)
is
nonzero
"
)
;
if
(
flexFactorSum
<
1
.
0f
)
{
nscoord
totalDesiredPortionOfOrigFreeSpace
=
NSToCoordRound
(
origAvailableFreeSpace
*
flexFactorSum
)
;
NS_ASSERTION
(
totalDesiredPortionOfOrigFreeSpace
=
=
0
|
|
(
(
totalDesiredPortionOfOrigFreeSpace
>
0
)
=
=
(
availableFreeSpace
>
0
)
)
"
When
we
reduce
available
free
space
for
flex
"
"
factors
<
1
we
shouldn
'
t
change
the
sign
of
the
"
"
free
space
.
.
.
"
)
;
if
(
availableFreeSpace
>
0
)
{
availableFreeSpace
=
std
:
:
min
(
availableFreeSpace
totalDesiredPortionOfOrigFreeSpace
)
;
}
else
{
availableFreeSpace
=
std
:
:
max
(
availableFreeSpace
totalDesiredPortionOfOrigFreeSpace
)
;
}
}
FLEX_LOG
(
"
Distributing
available
space
:
"
)
;
numUnfrozenItemsToBeSeen
=
mNumItems
-
mNumFrozenItems
;
for
(
FlexItem
*
item
=
mItems
.
getLast
(
)
;
numUnfrozenItemsToBeSeen
>
0
;
item
=
item
-
>
getPrevious
(
)
)
{
MOZ_ASSERT
(
item
"
numUnfrozenItemsToBeSeen
says
items
remain
to
be
seen
"
)
;
if
(
!
item
-
>
IsFrozen
(
)
)
{
numUnfrozenItemsToBeSeen
-
-
;
nscoord
sizeDelta
=
0
;
if
(
IsFinite
(
weightSum
)
)
{
float
myShareOfRemainingSpace
=
item
-
>
ShareOfWeightSoFar
(
)
;
MOZ_ASSERT
(
myShareOfRemainingSpace
>
=
0
.
0f
&
&
myShareOfRemainingSpace
<
=
1
.
0f
"
my
share
should
be
nonnegative
fractional
amount
"
)
;
if
(
myShareOfRemainingSpace
=
=
1
.
0f
)
{
sizeDelta
=
availableFreeSpace
;
}
else
if
(
myShareOfRemainingSpace
>
0
.
0f
)
{
sizeDelta
=
NSToCoordRound
(
availableFreeSpace
*
myShareOfRemainingSpace
)
;
}
}
else
if
(
item
-
>
GetWeight
(
isUsingFlexGrow
)
=
=
largestWeight
)
{
sizeDelta
=
NSToCoordRound
(
availableFreeSpace
/
float
(
numItemsWithLargestWeight
)
)
;
numItemsWithLargestWeight
-
-
;
}
availableFreeSpace
-
=
sizeDelta
;
item
-
>
SetMainSize
(
item
-
>
MainSize
(
)
+
sizeDelta
)
;
FLEX_LOG
(
"
child
%
p
receives
%
d
for
a
total
of
%
d
"
item
sizeDelta
item
-
>
MainSize
(
)
)
;
}
}
if
(
aLineInfo
)
{
uint32_t
itemIndex
=
0
;
for
(
FlexItem
*
item
=
mItems
.
getFirst
(
)
;
item
;
item
=
item
-
>
getNext
(
)
+
+
itemIndex
)
{
if
(
!
item
-
>
IsFrozen
(
)
)
{
nscoord
deltaSize
=
item
-
>
MainSize
(
)
-
aLineInfo
-
>
mItems
[
itemIndex
]
.
mMainBaseSize
;
aLineInfo
-
>
mItems
[
itemIndex
]
.
mMainDeltaSize
=
deltaSize
;
}
}
}
}
}
nscoord
totalViolation
=
0
;
FLEX_LOG
(
"
Checking
for
violations
:
"
)
;
uint32_t
numUnfrozenItemsToBeSeen
=
mNumItems
-
mNumFrozenItems
;
for
(
FlexItem
*
item
=
mItems
.
getFirst
(
)
;
numUnfrozenItemsToBeSeen
>
0
;
item
=
item
-
>
getNext
(
)
)
{
MOZ_ASSERT
(
item
"
numUnfrozenItemsToBeSeen
says
items
remain
to
be
seen
"
)
;
if
(
!
item
-
>
IsFrozen
(
)
)
{
numUnfrozenItemsToBeSeen
-
-
;
if
(
item
-
>
MainSize
(
)
<
item
-
>
MainMinSize
(
)
)
{
totalViolation
+
=
item
-
>
MainMinSize
(
)
-
item
-
>
MainSize
(
)
;
item
-
>
SetMainSize
(
item
-
>
MainMinSize
(
)
)
;
item
-
>
SetHadMinViolation
(
)
;
}
else
if
(
item
-
>
MainSize
(
)
>
item
-
>
MainMaxSize
(
)
)
{
totalViolation
+
=
item
-
>
MainMaxSize
(
)
-
item
-
>
MainSize
(
)
;
item
-
>
SetMainSize
(
item
-
>
MainMaxSize
(
)
)
;
item
-
>
SetHadMaxViolation
(
)
;
}
}
}
FreezeOrRestoreEachFlexibleSize
(
totalViolation
iterationCounter
+
1
=
=
mNumItems
)
;
FLEX_LOG
(
"
Total
violation
:
%
d
"
totalViolation
)
;
if
(
mNumFrozenItems
=
=
mNumItems
)
{
break
;
}
MOZ_ASSERT
(
totalViolation
!
=
0
"
Zero
violation
should
'
ve
made
us
freeze
all
items
&
break
"
)
;
}
#
ifdef
DEBUG
MOZ_ASSERT
(
mNumFrozenItems
=
=
mNumItems
"
All
items
should
be
frozen
"
)
;
for
(
const
FlexItem
*
item
=
mItems
.
getFirst
(
)
;
item
;
item
=
item
-
>
getNext
(
)
)
{
MOZ_ASSERT
(
item
-
>
IsFrozen
(
)
"
All
items
should
be
frozen
"
)
;
}
#
endif
}
MainAxisPositionTracker
:
:
MainAxisPositionTracker
(
const
FlexboxAxisTracker
&
aAxisTracker
const
FlexLine
*
aLine
const
StyleContentDistribution
&
aJustifyContent
nscoord
aContentBoxMainSize
)
:
PositionTracker
(
aAxisTracker
.
GetWritingMode
(
)
aAxisTracker
.
MainAxis
(
)
aAxisTracker
.
IsMainAxisReversed
(
)
)
mPackingSpaceRemaining
(
aContentBoxMainSize
)
mJustifyContent
(
aJustifyContent
)
{
StyleAlignFlags
justifyContentFlags
=
mJustifyContent
.
primary
&
StyleAlignFlags
:
:
FLAG_BITS
;
mJustifyContent
.
primary
&
=
~
StyleAlignFlags
:
:
FLAG_BITS
;
if
(
mJustifyContent
.
primary
=
=
StyleAlignFlags
:
:
NORMAL
|
|
mJustifyContent
.
primary
=
=
StyleAlignFlags
:
:
STRETCH
)
{
mJustifyContent
.
primary
=
StyleAlignFlags
:
:
FLEX_START
;
}
for
(
const
FlexItem
*
item
=
aLine
-
>
GetFirstItem
(
)
;
item
;
item
=
item
-
>
getNext
(
)
)
{
mPackingSpaceRemaining
-
=
item
-
>
OuterMainSize
(
)
;
mNumAutoMarginsInMainAxis
+
=
item
-
>
NumAutoMarginsInMainAxis
(
)
;
}
mPackingSpaceRemaining
-
=
aLine
-
>
SumOfGaps
(
)
;
if
(
mPackingSpaceRemaining
<
=
0
)
{
mNumAutoMarginsInMainAxis
=
0
;
if
(
justifyContentFlags
&
StyleAlignFlags
:
:
SAFE
)
{
mJustifyContent
.
primary
=
StyleAlignFlags
:
:
START
;
}
}
if
(
mPackingSpaceRemaining
<
0
|
|
aLine
-
>
NumItems
(
)
=
=
1
)
{
if
(
mJustifyContent
.
primary
=
=
StyleAlignFlags
:
:
SPACE_BETWEEN
)
{
mJustifyContent
.
primary
=
StyleAlignFlags
:
:
FLEX_START
;
}
else
if
(
mJustifyContent
.
primary
=
=
StyleAlignFlags
:
:
SPACE_AROUND
|
|
mJustifyContent
.
primary
=
=
StyleAlignFlags
:
:
SPACE_EVENLY
)
{
mJustifyContent
.
primary
=
StyleAlignFlags
:
:
CENTER
;
}
}
if
(
aAxisTracker
.
AreAxesInternallyReversed
(
)
)
{
if
(
mJustifyContent
.
primary
=
=
StyleAlignFlags
:
:
FLEX_START
)
{
mJustifyContent
.
primary
=
StyleAlignFlags
:
:
FLEX_END
;
}
else
if
(
mJustifyContent
.
primary
=
=
StyleAlignFlags
:
:
FLEX_END
)
{
mJustifyContent
.
primary
=
StyleAlignFlags
:
:
FLEX_START
;
}
}
if
(
mJustifyContent
.
primary
=
=
StyleAlignFlags
:
:
LEFT
|
|
mJustifyContent
.
primary
=
=
StyleAlignFlags
:
:
RIGHT
)
{
if
(
aAxisTracker
.
IsColumnOriented
(
)
)
{
mJustifyContent
.
primary
=
StyleAlignFlags
:
:
START
;
}
else
{
const
bool
isLTR
=
aAxisTracker
.
GetWritingMode
(
)
.
IsBidiLTR
(
)
;
const
bool
isJustifyLeft
=
(
mJustifyContent
.
primary
=
=
StyleAlignFlags
:
:
LEFT
)
;
mJustifyContent
.
primary
=
(
isJustifyLeft
=
=
isLTR
)
?
StyleAlignFlags
:
:
START
:
StyleAlignFlags
:
:
END
;
}
}
if
(
mJustifyContent
.
primary
=
=
StyleAlignFlags
:
:
START
)
{
mJustifyContent
.
primary
=
aAxisTracker
.
IsMainAxisReversed
(
)
?
StyleAlignFlags
:
:
FLEX_END
:
StyleAlignFlags
:
:
FLEX_START
;
}
else
if
(
mJustifyContent
.
primary
=
=
StyleAlignFlags
:
:
END
)
{
mJustifyContent
.
primary
=
aAxisTracker
.
IsMainAxisReversed
(
)
?
StyleAlignFlags
:
:
FLEX_START
:
StyleAlignFlags
:
:
FLEX_END
;
}
if
(
mNumAutoMarginsInMainAxis
=
=
0
&
&
mPackingSpaceRemaining
!
=
0
&
&
!
aLine
-
>
IsEmpty
(
)
)
{
if
(
mJustifyContent
.
primary
=
=
StyleAlignFlags
:
:
FLEX_START
)
{
}
else
if
(
mJustifyContent
.
primary
=
=
StyleAlignFlags
:
:
FLEX_END
)
{
mPosition
+
=
mPackingSpaceRemaining
;
}
else
if
(
mJustifyContent
.
primary
=
=
StyleAlignFlags
:
:
CENTER
)
{
mPosition
+
=
mPackingSpaceRemaining
/
2
;
}
else
if
(
mJustifyContent
.
primary
=
=
StyleAlignFlags
:
:
SPACE_BETWEEN
|
|
mJustifyContent
.
primary
=
=
StyleAlignFlags
:
:
SPACE_AROUND
|
|
mJustifyContent
.
primary
=
=
StyleAlignFlags
:
:
SPACE_EVENLY
)
{
nsFlexContainerFrame
:
:
CalculatePackingSpace
(
aLine
-
>
NumItems
(
)
mJustifyContent
&
mPosition
&
mNumPackingSpacesRemaining
&
mPackingSpaceRemaining
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
justify
-
content
value
"
)
;
}
}
MOZ_ASSERT
(
mNumPackingSpacesRemaining
=
=
0
|
|
mNumAutoMarginsInMainAxis
=
=
0
"
extra
space
should
either
go
to
packing
space
or
to
"
"
auto
margins
but
not
to
both
"
)
;
}
void
MainAxisPositionTracker
:
:
ResolveAutoMarginsInMainAxis
(
FlexItem
&
aItem
)
{
if
(
mNumAutoMarginsInMainAxis
)
{
const
auto
&
styleMargin
=
aItem
.
Frame
(
)
-
>
StyleMargin
(
)
-
>
mMargin
;
for
(
const
auto
side
:
{
StartSide
(
)
EndSide
(
)
}
)
{
if
(
styleMargin
.
Get
(
mWM
side
)
.
IsAuto
(
)
)
{
nscoord
curAutoMarginSize
=
mPackingSpaceRemaining
/
mNumAutoMarginsInMainAxis
;
MOZ_ASSERT
(
aItem
.
GetMarginComponentForSide
(
side
)
=
=
0
"
Expecting
auto
margins
to
have
value
'
0
'
before
we
"
"
resolve
them
"
)
;
aItem
.
SetMarginComponentForSide
(
side
curAutoMarginSize
)
;
mNumAutoMarginsInMainAxis
-
-
;
mPackingSpaceRemaining
-
=
curAutoMarginSize
;
}
}
}
}
void
MainAxisPositionTracker
:
:
TraversePackingSpace
(
)
{
if
(
mNumPackingSpacesRemaining
)
{
MOZ_ASSERT
(
mJustifyContent
.
primary
=
=
StyleAlignFlags
:
:
SPACE_BETWEEN
|
|
mJustifyContent
.
primary
=
=
StyleAlignFlags
:
:
SPACE_AROUND
|
|
mJustifyContent
.
primary
=
=
StyleAlignFlags
:
:
SPACE_EVENLY
"
mNumPackingSpacesRemaining
only
applies
for
"
"
space
-
between
/
space
-
around
/
space
-
evenly
"
)
;
MOZ_ASSERT
(
mPackingSpaceRemaining
>
=
0
"
ran
out
of
packing
space
earlier
than
we
expected
"
)
;
nscoord
curPackingSpace
=
mPackingSpaceRemaining
/
mNumPackingSpacesRemaining
;
mPosition
+
=
curPackingSpace
;
mNumPackingSpacesRemaining
-
-
;
mPackingSpaceRemaining
-
=
curPackingSpace
;
}
}
CrossAxisPositionTracker
:
:
CrossAxisPositionTracker
(
FlexLine
*
aFirstLine
const
ReflowInput
&
aReflowInput
nscoord
aContentBoxCrossSize
bool
aIsCrossSizeDefinite
const
FlexboxAxisTracker
&
aAxisTracker
const
nscoord
aCrossGapSize
)
:
PositionTracker
(
aAxisTracker
.
GetWritingMode
(
)
aAxisTracker
.
CrossAxis
(
)
aAxisTracker
.
IsCrossAxisReversed
(
)
)
mAlignContent
(
aReflowInput
.
mStylePosition
-
>
mAlignContent
)
mCrossGapSize
(
aCrossGapSize
)
{
MOZ_ASSERT
(
aFirstLine
"
null
first
line
pointer
"
)
;
StyleAlignFlags
alignContentFlags
=
mAlignContent
.
primary
&
StyleAlignFlags
:
:
FLAG_BITS
;
mAlignContent
.
primary
&
=
~
StyleAlignFlags
:
:
FLAG_BITS
;
if
(
mAlignContent
.
primary
=
=
StyleAlignFlags
:
:
NORMAL
)
{
mAlignContent
.
primary
=
StyleAlignFlags
:
:
STRETCH
;
}
const
bool
isSingleLine
=
StyleFlexWrap
:
:
Nowrap
=
=
aReflowInput
.
mStylePosition
-
>
mFlexWrap
;
if
(
isSingleLine
)
{
MOZ_ASSERT
(
!
aFirstLine
-
>
getNext
(
)
"
If
we
'
re
styled
as
single
-
line
we
should
only
have
1
line
"
)
;
if
(
aIsCrossSizeDefinite
)
{
aFirstLine
-
>
SetLineCrossSize
(
aContentBoxCrossSize
)
;
return
;
}
aFirstLine
-
>
SetLineCrossSize
(
NS_CSS_MINMAX
(
aFirstLine
-
>
LineCrossSize
(
)
aReflowInput
.
ComputedMinBSize
(
)
aReflowInput
.
ComputedMaxBSize
(
)
)
)
;
}
mPackingSpaceRemaining
=
aContentBoxCrossSize
;
uint32_t
numLines
=
0
;
for
(
FlexLine
*
line
=
aFirstLine
;
line
;
line
=
line
-
>
getNext
(
)
)
{
mPackingSpaceRemaining
-
=
line
-
>
LineCrossSize
(
)
;
numLines
+
+
;
}
MOZ_ASSERT
(
numLines
>
=
1
"
GenerateFlexLines
should
'
ve
produced
at
least
1
line
"
)
;
mPackingSpaceRemaining
-
=
aCrossGapSize
*
(
numLines
-
1
)
;
if
(
(
alignContentFlags
&
StyleAlignFlags
:
:
SAFE
)
&
&
mPackingSpaceRemaining
<
0
)
{
mAlignContent
.
primary
=
StyleAlignFlags
:
:
START
;
}
if
(
mPackingSpaceRemaining
<
0
&
&
mAlignContent
.
primary
=
=
StyleAlignFlags
:
:
STRETCH
)
{
mAlignContent
.
primary
=
StyleAlignFlags
:
:
FLEX_START
;
}
else
if
(
mPackingSpaceRemaining
<
0
|
|
numLines
=
=
1
)
{
if
(
mAlignContent
.
primary
=
=
StyleAlignFlags
:
:
SPACE_BETWEEN
)
{
mAlignContent
.
primary
=
StyleAlignFlags
:
:
FLEX_START
;
}
else
if
(
mAlignContent
.
primary
=
=
StyleAlignFlags
:
:
SPACE_AROUND
|
|
mAlignContent
.
primary
=
=
StyleAlignFlags
:
:
SPACE_EVENLY
)
{
mAlignContent
.
primary
=
StyleAlignFlags
:
:
CENTER
;
}
}
if
(
aAxisTracker
.
AreAxesInternallyReversed
(
)
)
{
if
(
mAlignContent
.
primary
=
=
StyleAlignFlags
:
:
FLEX_START
)
{
mAlignContent
.
primary
=
StyleAlignFlags
:
:
FLEX_END
;
}
else
if
(
mAlignContent
.
primary
=
=
StyleAlignFlags
:
:
FLEX_END
)
{
mAlignContent
.
primary
=
StyleAlignFlags
:
:
FLEX_START
;
}
}
if
(
mAlignContent
.
primary
=
=
StyleAlignFlags
:
:
START
)
{
mAlignContent
.
primary
=
aAxisTracker
.
IsCrossAxisReversed
(
)
?
StyleAlignFlags
:
:
FLEX_END
:
StyleAlignFlags
:
:
FLEX_START
;
}
else
if
(
mAlignContent
.
primary
=
=
StyleAlignFlags
:
:
END
)
{
mAlignContent
.
primary
=
aAxisTracker
.
IsCrossAxisReversed
(
)
?
StyleAlignFlags
:
:
FLEX_START
:
StyleAlignFlags
:
:
FLEX_END
;
}
if
(
mPackingSpaceRemaining
!
=
0
)
{
if
(
mAlignContent
.
primary
=
=
StyleAlignFlags
:
:
BASELINE
|
|
mAlignContent
.
primary
=
=
StyleAlignFlags
:
:
LAST_BASELINE
)
{
NS_WARNING
(
"
NYI
:
"
"
align
-
items
/
align
-
self
:
left
/
right
/
self
-
start
/
self
-
end
/
baseline
/
"
"
last
baseline
"
)
;
}
else
if
(
mAlignContent
.
primary
=
=
StyleAlignFlags
:
:
FLEX_START
)
{
}
else
if
(
mAlignContent
.
primary
=
=
StyleAlignFlags
:
:
FLEX_END
)
{
mPosition
+
=
mPackingSpaceRemaining
;
}
else
if
(
mAlignContent
.
primary
=
=
StyleAlignFlags
:
:
CENTER
)
{
mPosition
+
=
mPackingSpaceRemaining
/
2
;
}
else
if
(
mAlignContent
.
primary
=
=
StyleAlignFlags
:
:
SPACE_BETWEEN
|
|
mAlignContent
.
primary
=
=
StyleAlignFlags
:
:
SPACE_AROUND
|
|
mAlignContent
.
primary
=
=
StyleAlignFlags
:
:
SPACE_EVENLY
)
{
nsFlexContainerFrame
:
:
CalculatePackingSpace
(
numLines
mAlignContent
&
mPosition
&
mNumPackingSpacesRemaining
&
mPackingSpaceRemaining
)
;
}
else
if
(
mAlignContent
.
primary
=
=
StyleAlignFlags
:
:
STRETCH
)
{
MOZ_ASSERT
(
mPackingSpaceRemaining
>
0
"
negative
packing
space
should
make
us
use
'
flex
-
start
'
"
"
instead
of
'
stretch
'
(
and
we
shouldn
'
t
bother
with
this
"
"
code
if
we
have
0
packing
space
)
"
)
;
uint32_t
numLinesLeft
=
numLines
;
for
(
FlexLine
*
line
=
aFirstLine
;
line
;
line
=
line
-
>
getNext
(
)
)
{
MOZ_ASSERT
(
numLinesLeft
>
0
"
miscalculated
num
lines
"
)
;
nscoord
shareOfExtraSpace
=
mPackingSpaceRemaining
/
numLinesLeft
;
nscoord
newSize
=
line
-
>
LineCrossSize
(
)
+
shareOfExtraSpace
;
line
-
>
SetLineCrossSize
(
newSize
)
;
mPackingSpaceRemaining
-
=
shareOfExtraSpace
;
numLinesLeft
-
-
;
}
MOZ_ASSERT
(
numLinesLeft
=
=
0
"
miscalculated
num
lines
"
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
align
-
content
value
"
)
;
}
}
}
void
CrossAxisPositionTracker
:
:
TraversePackingSpace
(
)
{
if
(
mNumPackingSpacesRemaining
)
{
MOZ_ASSERT
(
mAlignContent
.
primary
=
=
StyleAlignFlags
:
:
SPACE_BETWEEN
|
|
mAlignContent
.
primary
=
=
StyleAlignFlags
:
:
SPACE_AROUND
|
|
mAlignContent
.
primary
=
=
StyleAlignFlags
:
:
SPACE_EVENLY
"
mNumPackingSpacesRemaining
only
applies
for
"
"
space
-
between
/
space
-
around
/
space
-
evenly
"
)
;
MOZ_ASSERT
(
mPackingSpaceRemaining
>
=
0
"
ran
out
of
packing
space
earlier
than
we
expected
"
)
;
nscoord
curPackingSpace
=
mPackingSpaceRemaining
/
mNumPackingSpacesRemaining
;
mPosition
+
=
curPackingSpace
;
mNumPackingSpacesRemaining
-
-
;
mPackingSpaceRemaining
-
=
curPackingSpace
;
}
}
SingleLineCrossAxisPositionTracker
:
:
SingleLineCrossAxisPositionTracker
(
const
FlexboxAxisTracker
&
aAxisTracker
)
:
PositionTracker
(
aAxisTracker
.
GetWritingMode
(
)
aAxisTracker
.
CrossAxis
(
)
aAxisTracker
.
IsCrossAxisReversed
(
)
)
{
}
void
FlexLine
:
:
ComputeCrossSizeAndBaseline
(
const
FlexboxAxisTracker
&
aAxisTracker
)
{
nscoord
crossStartToFurthestFirstBaseline
=
nscoord_MIN
;
nscoord
crossEndToFurthestFirstBaseline
=
nscoord_MIN
;
nscoord
crossStartToFurthestLastBaseline
=
nscoord_MIN
;
nscoord
crossEndToFurthestLastBaseline
=
nscoord_MIN
;
nscoord
largestOuterCrossSize
=
0
;
for
(
const
FlexItem
*
item
=
mItems
.
getFirst
(
)
;
item
;
item
=
item
-
>
getNext
(
)
)
{
nscoord
curOuterCrossSize
=
item
-
>
OuterCrossSize
(
)
;
if
(
(
item
-
>
AlignSelf
(
)
.
_0
=
=
StyleAlignFlags
:
:
BASELINE
|
|
item
-
>
AlignSelf
(
)
.
_0
=
=
StyleAlignFlags
:
:
LAST_BASELINE
)
&
&
item
-
>
NumAutoMarginsInCrossAxis
(
)
=
=
0
)
{
const
bool
useFirst
=
(
item
-
>
AlignSelf
(
)
.
_0
=
=
StyleAlignFlags
:
:
BASELINE
)
;
nscoord
crossStartToBaseline
=
item
-
>
BaselineOffsetFromOuterCrossEdge
(
aAxisTracker
.
CrossAxisPhysicalStartSide
(
)
aAxisTracker
useFirst
)
;
nscoord
crossEndToBaseline
=
curOuterCrossSize
-
crossStartToBaseline
;
if
(
useFirst
)
{
crossStartToFurthestFirstBaseline
=
std
:
:
max
(
crossStartToFurthestFirstBaseline
crossStartToBaseline
)
;
crossEndToFurthestFirstBaseline
=
std
:
:
max
(
crossEndToFurthestFirstBaseline
crossEndToBaseline
)
;
}
else
{
crossStartToFurthestLastBaseline
=
std
:
:
max
(
crossStartToFurthestLastBaseline
crossStartToBaseline
)
;
crossEndToFurthestLastBaseline
=
std
:
:
max
(
crossEndToFurthestLastBaseline
crossEndToBaseline
)
;
}
}
else
{
largestOuterCrossSize
=
std
:
:
max
(
largestOuterCrossSize
curOuterCrossSize
)
;
}
}
mFirstBaselineOffset
=
aAxisTracker
.
AreAxesInternallyReversed
(
)
?
crossEndToFurthestFirstBaseline
:
crossStartToFurthestFirstBaseline
;
mLastBaselineOffset
=
aAxisTracker
.
AreAxesInternallyReversed
(
)
?
crossStartToFurthestLastBaseline
:
crossEndToFurthestLastBaseline
;
mLineCrossSize
=
std
:
:
max
(
std
:
:
max
(
crossStartToFurthestFirstBaseline
+
crossEndToFurthestFirstBaseline
crossStartToFurthestLastBaseline
+
crossEndToFurthestLastBaseline
)
largestOuterCrossSize
)
;
}
void
FlexItem
:
:
ResolveStretchedCrossSize
(
nscoord
aLineCrossSize
)
{
if
(
mAlignSelf
.
_0
!
=
StyleAlignFlags
:
:
STRETCH
|
|
NumAutoMarginsInCrossAxis
(
)
!
=
0
|
|
!
IsCrossSizeAuto
(
)
)
{
return
;
}
if
(
mIsStretched
)
{
return
;
}
nscoord
stretchedSize
=
aLineCrossSize
-
MarginBorderPaddingSizeInCrossAxis
(
)
;
stretchedSize
=
NS_CSS_MINMAX
(
stretchedSize
mCrossMinSize
mCrossMaxSize
)
;
SetCrossSize
(
stretchedSize
)
;
mIsStretched
=
true
;
}
static
nsBlockFrame
*
FindFlexItemBlockFrame
(
nsIFrame
*
aFrame
)
{
if
(
nsBlockFrame
*
block
=
do_QueryFrame
(
aFrame
)
)
{
return
block
;
}
for
(
nsIFrame
*
f
:
aFrame
-
>
PrincipalChildList
(
)
)
{
if
(
nsBlockFrame
*
block
=
FindFlexItemBlockFrame
(
f
)
)
{
return
block
;
}
}
return
nullptr
;
}
nsBlockFrame
*
FlexItem
:
:
BlockFrame
(
)
const
{
return
FindFlexItemBlockFrame
(
Frame
(
)
)
;
}
void
SingleLineCrossAxisPositionTracker
:
:
ResolveAutoMarginsInCrossAxis
(
const
FlexLine
&
aLine
FlexItem
&
aItem
)
{
nscoord
spaceForAutoMargins
=
aLine
.
LineCrossSize
(
)
-
aItem
.
OuterCrossSize
(
)
;
if
(
spaceForAutoMargins
<
=
0
)
{
return
;
}
uint32_t
numAutoMargins
=
aItem
.
NumAutoMarginsInCrossAxis
(
)
;
if
(
numAutoMargins
=
=
0
)
{
return
;
}
const
auto
&
styleMargin
=
aItem
.
Frame
(
)
-
>
StyleMargin
(
)
-
>
mMargin
;
for
(
const
auto
side
:
{
StartSide
(
)
EndSide
(
)
}
)
{
if
(
styleMargin
.
Get
(
mWM
side
)
.
IsAuto
(
)
)
{
MOZ_ASSERT
(
aItem
.
GetMarginComponentForSide
(
side
)
=
=
0
"
Expecting
auto
margins
to
have
value
'
0
'
before
we
"
"
update
them
"
)
;
nscoord
curAutoMarginSize
=
spaceForAutoMargins
/
numAutoMargins
;
aItem
.
SetMarginComponentForSide
(
side
curAutoMarginSize
)
;
numAutoMargins
-
-
;
spaceForAutoMargins
-
=
curAutoMarginSize
;
}
}
}
void
SingleLineCrossAxisPositionTracker
:
:
EnterAlignPackingSpace
(
const
FlexLine
&
aLine
const
FlexItem
&
aItem
const
FlexboxAxisTracker
&
aAxisTracker
)
{
if
(
aItem
.
NumAutoMarginsInCrossAxis
(
)
)
{
return
;
}
StyleAlignFlags
alignSelf
=
aItem
.
AlignSelf
(
)
.
_0
;
if
(
alignSelf
=
=
StyleAlignFlags
:
:
STRETCH
)
{
alignSelf
=
StyleAlignFlags
:
:
FLEX_START
;
}
if
(
aAxisTracker
.
AreAxesInternallyReversed
(
)
)
{
if
(
alignSelf
=
=
StyleAlignFlags
:
:
FLEX_START
)
{
alignSelf
=
StyleAlignFlags
:
:
FLEX_END
;
}
else
if
(
alignSelf
=
=
StyleAlignFlags
:
:
FLEX_END
)
{
alignSelf
=
StyleAlignFlags
:
:
FLEX_START
;
}
}
if
(
alignSelf
=
=
StyleAlignFlags
:
:
SELF_START
|
|
alignSelf
=
=
StyleAlignFlags
:
:
SELF_END
)
{
const
LogicalAxis
logCrossAxis
=
aAxisTracker
.
IsRowOriented
(
)
?
eLogicalAxisBlock
:
eLogicalAxisInline
;
const
WritingMode
cWM
=
aAxisTracker
.
GetWritingMode
(
)
;
const
bool
sameStart
=
cWM
.
ParallelAxisStartsOnSameSide
(
logCrossAxis
aItem
.
GetWritingMode
(
)
)
;
alignSelf
=
sameStart
=
=
(
alignSelf
=
=
StyleAlignFlags
:
:
SELF_START
)
?
StyleAlignFlags
:
:
START
:
StyleAlignFlags
:
:
END
;
}
if
(
alignSelf
=
=
StyleAlignFlags
:
:
START
)
{
alignSelf
=
aAxisTracker
.
IsCrossAxisReversed
(
)
?
StyleAlignFlags
:
:
FLEX_END
:
StyleAlignFlags
:
:
FLEX_START
;
}
else
if
(
alignSelf
=
=
StyleAlignFlags
:
:
END
)
{
alignSelf
=
aAxisTracker
.
IsCrossAxisReversed
(
)
?
StyleAlignFlags
:
:
FLEX_START
:
StyleAlignFlags
:
:
FLEX_END
;
}
if
(
aLine
.
LineCrossSize
(
)
<
aItem
.
OuterCrossSize
(
)
&
&
(
aItem
.
AlignSelfFlags
(
)
&
StyleAlignFlags
:
:
SAFE
)
)
{
alignSelf
=
StyleAlignFlags
:
:
FLEX_START
;
}
if
(
alignSelf
=
=
StyleAlignFlags
:
:
FLEX_START
)
{
}
else
if
(
alignSelf
=
=
StyleAlignFlags
:
:
FLEX_END
)
{
mPosition
+
=
aLine
.
LineCrossSize
(
)
-
aItem
.
OuterCrossSize
(
)
;
}
else
if
(
alignSelf
=
=
StyleAlignFlags
:
:
CENTER
)
{
mPosition
+
=
(
aLine
.
LineCrossSize
(
)
-
aItem
.
OuterCrossSize
(
)
)
/
2
;
}
else
if
(
alignSelf
=
=
StyleAlignFlags
:
:
BASELINE
|
|
alignSelf
=
=
StyleAlignFlags
:
:
LAST_BASELINE
)
{
const
bool
useFirst
=
(
alignSelf
=
=
StyleAlignFlags
:
:
BASELINE
)
;
const
mozilla
:
:
Side
baselineAlignStartSide
=
aAxisTracker
.
AreAxesInternallyReversed
(
)
=
=
useFirst
?
aAxisTracker
.
CrossAxisPhysicalEndSide
(
)
:
aAxisTracker
.
CrossAxisPhysicalStartSide
(
)
;
nscoord
itemBaselineOffset
=
aItem
.
BaselineOffsetFromOuterCrossEdge
(
baselineAlignStartSide
aAxisTracker
useFirst
)
;
nscoord
lineBaselineOffset
=
useFirst
?
aLine
.
FirstBaselineOffset
(
)
:
aLine
.
LastBaselineOffset
(
)
;
NS_ASSERTION
(
lineBaselineOffset
>
=
itemBaselineOffset
"
failed
at
finding
largest
baseline
offset
"
)
;
nscoord
baselineDiff
=
lineBaselineOffset
-
itemBaselineOffset
;
if
(
aAxisTracker
.
AreAxesInternallyReversed
(
)
=
=
useFirst
)
{
mPosition
+
=
aLine
.
LineCrossSize
(
)
-
aItem
.
OuterCrossSize
(
)
;
mPosition
-
=
baselineDiff
;
}
else
{
mPosition
+
=
baselineDiff
;
}
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
align
-
self
value
"
)
;
}
}
FlexboxAxisTracker
:
:
FlexboxAxisTracker
(
const
nsFlexContainerFrame
*
aFlexContainer
const
WritingMode
&
aWM
AxisTrackerFlags
aFlags
)
:
mWM
(
aWM
)
{
if
(
IsLegacyBox
(
aFlexContainer
)
)
{
InitAxesFromLegacyProps
(
aFlexContainer
)
;
}
else
{
InitAxesFromModernProps
(
aFlexContainer
)
;
}
static
bool
sPreventBottomToTopChildOrdering
=
true
;
if
(
!
(
aFlags
&
AxisTrackerFlags
:
:
eAllowBottomToTopChildOrdering
)
&
&
sPreventBottomToTopChildOrdering
)
{
if
(
MainAxisPhysicalStartSide
(
)
=
=
eSideBottom
|
|
CrossAxisPhysicalStartSide
(
)
=
=
eSideBottom
)
{
mAreAxesInternallyReversed
=
true
;
mIsMainAxisReversed
=
!
mIsMainAxisReversed
;
mIsCrossAxisReversed
=
!
mIsCrossAxisReversed
;
}
}
}
void
FlexboxAxisTracker
:
:
InitAxesFromLegacyProps
(
const
nsFlexContainerFrame
*
aFlexContainer
)
{
const
nsStyleXUL
*
styleXUL
=
aFlexContainer
-
>
StyleXUL
(
)
;
const
bool
boxOrientIsVertical
=
(
styleXUL
-
>
mBoxOrient
=
=
StyleBoxOrient
:
:
Vertical
)
;
const
bool
wmIsVertical
=
mWM
.
IsVertical
(
)
;
mIsRowOriented
=
(
boxOrientIsVertical
=
=
wmIsVertical
)
;
mMainAxis
=
mIsRowOriented
?
eLogicalAxisInline
:
eLogicalAxisBlock
;
if
(
styleXUL
-
>
mBoxDirection
=
=
StyleBoxDirection
:
:
Reverse
)
{
mIsMainAxisReversed
=
true
;
}
else
{
mIsMainAxisReversed
=
false
;
}
mIsCrossAxisReversed
=
false
;
}
void
FlexboxAxisTracker
:
:
InitAxesFromModernProps
(
const
nsFlexContainerFrame
*
aFlexContainer
)
{
const
nsStylePosition
*
stylePos
=
aFlexContainer
-
>
StylePosition
(
)
;
StyleFlexDirection
flexDirection
=
stylePos
-
>
mFlexDirection
;
switch
(
flexDirection
)
{
case
StyleFlexDirection
:
:
Row
:
mMainAxis
=
eLogicalAxisInline
;
mIsRowOriented
=
true
;
mIsMainAxisReversed
=
false
;
break
;
case
StyleFlexDirection
:
:
RowReverse
:
mMainAxis
=
eLogicalAxisInline
;
mIsRowOriented
=
true
;
mIsMainAxisReversed
=
true
;
break
;
case
StyleFlexDirection
:
:
Column
:
mMainAxis
=
eLogicalAxisBlock
;
mIsRowOriented
=
false
;
mIsMainAxisReversed
=
false
;
break
;
case
StyleFlexDirection
:
:
ColumnReverse
:
mMainAxis
=
eLogicalAxisBlock
;
mIsRowOriented
=
false
;
mIsMainAxisReversed
=
true
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
flex
-
direction
value
"
)
;
}
if
(
stylePos
-
>
mFlexWrap
=
=
StyleFlexWrap
:
:
WrapReverse
)
{
mIsCrossAxisReversed
=
true
;
}
else
{
mIsCrossAxisReversed
=
false
;
}
}
LogicalSide
FlexboxAxisTracker
:
:
MainAxisStartSide
(
)
const
{
return
MakeLogicalSide
(
MainAxis
(
)
mIsMainAxisReversed
?
eLogicalEdgeEnd
:
eLogicalEdgeStart
)
;
}
LogicalSide
FlexboxAxisTracker
:
:
CrossAxisStartSide
(
)
const
{
return
MakeLogicalSide
(
CrossAxis
(
)
mIsCrossAxisReversed
?
eLogicalEdgeEnd
:
eLogicalEdgeStart
)
;
}
static
FlexLine
*
AddNewFlexLineToList
(
LinkedList
<
FlexLine
>
&
aLines
bool
aShouldInsertAtFront
nscoord
aMainGapSize
)
{
FlexLine
*
newLine
=
new
FlexLine
(
aMainGapSize
)
;
if
(
aShouldInsertAtFront
)
{
aLines
.
insertFront
(
newLine
)
;
}
else
{
aLines
.
insertBack
(
newLine
)
;
}
return
newLine
;
}
bool
nsFlexContainerFrame
:
:
ShouldUseMozBoxCollapseBehavior
(
const
nsStyleDisplay
*
aThisStyleDisp
)
{
MOZ_ASSERT
(
StyleDisplay
(
)
=
=
aThisStyleDisp
"
wrong
StyleDisplay
passed
in
"
)
;
if
(
!
IsLegacyBox
(
this
)
)
{
return
false
;
}
if
(
aThisStyleDisp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
MozBox
|
|
aThisStyleDisp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
MozInlineBox
)
{
return
true
;
}
auto
pseudoType
=
Style
(
)
-
>
GetPseudoType
(
)
;
if
(
pseudoType
=
=
PseudoStyleType
:
:
scrolledContent
|
|
pseudoType
=
=
PseudoStyleType
:
:
buttonContent
)
{
const
nsStyleDisplay
*
disp
=
GetParent
(
)
-
>
StyleDisplay
(
)
;
if
(
disp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
MozBox
|
|
disp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
MozInlineBox
)
{
return
true
;
}
}
return
false
;
}
void
nsFlexContainerFrame
:
:
GenerateFlexLines
(
nsPresContext
*
aPresContext
const
ReflowInput
&
aReflowInput
nscoord
aContentBoxMainSize
nscoord
aAvailableBSizeForContent
const
nsTArray
<
StrutInfo
>
&
aStruts
const
FlexboxAxisTracker
&
aAxisTracker
nscoord
aMainGapSize
bool
aHasLineClampEllipsis
nsTArray
<
nsIFrame
*
>
&
aPlaceholders
LinkedList
<
FlexLine
>
&
aLines
)
{
MOZ_ASSERT
(
aLines
.
isEmpty
(
)
"
Expecting
outparam
to
start
out
empty
"
)
;
const
bool
isSingleLine
=
StyleFlexWrap
:
:
Nowrap
=
=
aReflowInput
.
mStylePosition
-
>
mFlexWrap
;
const
bool
shouldInsertAtFront
=
aAxisTracker
.
AreAxesInternallyReversed
(
)
;
FlexLine
*
curLine
=
AddNewFlexLineToList
(
aLines
shouldInsertAtFront
aMainGapSize
)
;
nscoord
wrapThreshold
;
if
(
isSingleLine
)
{
wrapThreshold
=
NS_UNCONSTRAINEDSIZE
;
}
else
{
wrapThreshold
=
aContentBoxMainSize
;
if
(
wrapThreshold
=
=
NS_UNCONSTRAINEDSIZE
)
{
const
nscoord
flexContainerMaxMainSize
=
GET_MAIN_COMPONENT_LOGICAL
(
aAxisTracker
aAxisTracker
.
GetWritingMode
(
)
aReflowInput
.
ComputedMaxISize
(
)
aReflowInput
.
ComputedMaxBSize
(
)
)
;
wrapThreshold
=
flexContainerMaxMainSize
;
}
if
(
aAxisTracker
.
IsColumnOriented
(
)
&
&
aAvailableBSizeForContent
!
=
NS_UNCONSTRAINEDSIZE
)
{
wrapThreshold
=
std
:
:
min
(
wrapThreshold
aAvailableBSizeForContent
)
;
}
}
uint32_t
nextStrutIdx
=
0
;
uint32_t
itemIdxInContainer
=
0
;
CSSOrderAwareFrameIterator
iter
(
this
kPrincipalList
CSSOrderAwareFrameIterator
:
:
eIncludeAll
CSSOrderAwareFrameIterator
:
:
eUnknownOrder
OrderingPropertyForIter
(
this
)
)
;
if
(
iter
.
ItemsAreAlreadyInOrder
(
)
)
{
AddStateBits
(
NS_STATE_FLEX_NORMAL_FLOW_CHILDREN_IN_CSS_ORDER
)
;
}
else
{
RemoveStateBits
(
NS_STATE_FLEX_NORMAL_FLOW_CHILDREN_IN_CSS_ORDER
)
;
}
const
bool
useMozBoxCollapseBehavior
=
ShouldUseMozBoxCollapseBehavior
(
aReflowInput
.
mStyleDisplay
)
;
for
(
;
!
iter
.
AtEnd
(
)
;
iter
.
Next
(
)
)
{
nsIFrame
*
childFrame
=
*
iter
;
if
(
childFrame
-
>
IsPlaceholderFrame
(
)
)
{
aPlaceholders
.
AppendElement
(
childFrame
)
;
continue
;
}
if
(
!
isSingleLine
&
&
!
curLine
-
>
IsEmpty
(
)
&
&
childFrame
-
>
StyleDisplay
(
)
-
>
BreakBefore
(
)
)
{
curLine
=
AddNewFlexLineToList
(
aLines
shouldInsertAtFront
aMainGapSize
)
;
}
UniquePtr
<
FlexItem
>
item
;
if
(
useMozBoxCollapseBehavior
&
&
(
StyleVisibility
:
:
Collapse
=
=
childFrame
-
>
StyleVisibility
(
)
-
>
mVisible
)
)
{
item
=
MakeUnique
<
FlexItem
>
(
childFrame
0
aReflowInput
.
GetWritingMode
(
)
)
;
}
else
if
(
nextStrutIdx
<
aStruts
.
Length
(
)
&
&
aStruts
[
nextStrutIdx
]
.
mItemIdx
=
=
itemIdxInContainer
)
{
item
=
MakeUnique
<
FlexItem
>
(
childFrame
aStruts
[
nextStrutIdx
]
.
mStrutCrossSize
aReflowInput
.
GetWritingMode
(
)
)
;
nextStrutIdx
+
+
;
}
else
{
item
=
GenerateFlexItemForChild
(
aPresContext
childFrame
aReflowInput
aAxisTracker
aHasLineClampEllipsis
)
;
}
nscoord
itemInnerHypotheticalMainSize
=
item
-
>
MainSize
(
)
;
nscoord
itemOuterHypotheticalMainSize
=
item
-
>
OuterMainSize
(
)
;
if
(
wrapThreshold
!
=
NS_UNCONSTRAINEDSIZE
&
&
!
curLine
-
>
IsEmpty
(
)
)
{
nscoord
newOuterSize
=
AddChecked
(
curLine
-
>
TotalOuterHypotheticalMainSize
(
)
itemOuterHypotheticalMainSize
)
;
newOuterSize
=
AddChecked
(
newOuterSize
aMainGapSize
)
;
if
(
newOuterSize
=
=
nscoord_MAX
|
|
newOuterSize
>
wrapThreshold
)
{
curLine
=
AddNewFlexLineToList
(
aLines
shouldInsertAtFront
aMainGapSize
)
;
}
}
curLine
-
>
AddItem
(
item
.
release
(
)
shouldInsertAtFront
itemInnerHypotheticalMainSize
itemOuterHypotheticalMainSize
)
;
if
(
!
isSingleLine
&
&
childFrame
-
>
GetNextSibling
(
)
&
&
childFrame
-
>
StyleDisplay
(
)
-
>
BreakAfter
(
)
)
{
curLine
=
AddNewFlexLineToList
(
aLines
shouldInsertAtFront
aMainGapSize
)
;
}
itemIdxInContainer
+
+
;
}
}
nscoord
nsFlexContainerFrame
:
:
GetMainSizeFromReflowInput
(
const
ReflowInput
&
aReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
)
{
if
(
aAxisTracker
.
IsRowOriented
(
)
)
{
NS_WARNING_ASSERTION
(
aReflowInput
.
ComputedISize
(
)
!
=
NS_UNCONSTRAINEDSIZE
"
Unconstrained
inline
size
;
this
should
only
result
from
huge
sizes
"
"
(
not
intrinsic
sizing
w
/
orthogonal
flows
)
"
)
;
return
aReflowInput
.
ComputedISize
(
)
;
}
return
GetEffectiveComputedBSize
(
aReflowInput
)
;
}
static
nscoord
GetLargestLineMainSize
(
const
FlexLine
*
aFirstLine
)
{
nscoord
largestLineOuterSize
=
0
;
for
(
const
FlexLine
*
line
=
aFirstLine
;
line
;
line
=
line
-
>
getNext
(
)
)
{
largestLineOuterSize
=
std
:
:
max
(
largestLineOuterSize
line
-
>
TotalOuterHypotheticalMainSize
(
)
)
;
}
return
largestLineOuterSize
;
}
static
bool
FrameHasRelativeBSizeDependency
(
nsIFrame
*
aFrame
)
{
if
(
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_CONTAINS_RELATIVE_BSIZE
)
)
{
return
true
;
}
for
(
nsIFrame
:
:
ChildListIterator
childLists
(
aFrame
)
;
!
childLists
.
IsDone
(
)
;
childLists
.
Next
(
)
)
{
for
(
nsIFrame
*
childFrame
:
childLists
.
CurrentList
(
)
)
{
if
(
childFrame
-
>
HasAnyStateBits
(
NS_FRAME_CONTAINS_RELATIVE_BSIZE
)
)
{
return
true
;
}
}
}
return
false
;
}
static
nscoord
ResolveFlexContainerMainSize
(
const
ReflowInput
&
aReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
nscoord
aTentativeMainSize
nscoord
aAvailableBSizeForContent
const
FlexLine
*
aFirstLine
nsReflowStatus
&
aStatus
)
{
MOZ_ASSERT
(
aFirstLine
"
null
first
line
pointer
"
)
;
if
(
aAxisTracker
.
IsRowOriented
(
)
)
{
return
aTentativeMainSize
;
}
if
(
aTentativeMainSize
!
=
NS_UNCONSTRAINEDSIZE
)
{
if
(
aAvailableBSizeForContent
=
=
NS_UNCONSTRAINEDSIZE
|
|
aTentativeMainSize
<
aAvailableBSizeForContent
)
{
return
aTentativeMainSize
;
}
aStatus
.
SetIncomplete
(
)
;
nscoord
largestLineOuterSize
=
GetLargestLineMainSize
(
aFirstLine
)
;
if
(
largestLineOuterSize
<
=
aAvailableBSizeForContent
)
{
return
aAvailableBSizeForContent
;
}
return
std
:
:
min
(
aTentativeMainSize
largestLineOuterSize
)
;
}
if
(
aReflowInput
.
mStyleDisplay
-
>
IsContainSize
(
)
)
{
return
aReflowInput
.
ComputedMinBSize
(
)
;
}
nscoord
largestLineOuterSize
=
GetLargestLineMainSize
(
aFirstLine
)
;
return
NS_CSS_MINMAX
(
largestLineOuterSize
aReflowInput
.
ComputedMinBSize
(
)
aReflowInput
.
ComputedMaxBSize
(
)
)
;
}
nscoord
nsFlexContainerFrame
:
:
ComputeCrossSize
(
const
ReflowInput
&
aReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
nscoord
aSumLineCrossSizes
nscoord
aAvailableBSizeForContent
bool
*
aIsDefinite
nsReflowStatus
&
aStatus
)
{
MOZ_ASSERT
(
aIsDefinite
"
outparam
pointer
must
be
non
-
null
"
)
;
if
(
aAxisTracker
.
IsColumnOriented
(
)
)
{
NS_WARNING_ASSERTION
(
aReflowInput
.
ComputedISize
(
)
!
=
NS_UNCONSTRAINEDSIZE
"
Unconstrained
inline
size
;
this
should
only
result
from
huge
sizes
"
"
(
not
intrinsic
sizing
w
/
orthogonal
flows
)
"
)
;
*
aIsDefinite
=
true
;
return
aReflowInput
.
ComputedISize
(
)
;
}
nscoord
effectiveComputedBSize
=
GetEffectiveComputedBSize
(
aReflowInput
)
;
if
(
effectiveComputedBSize
!
=
NS_UNCONSTRAINEDSIZE
)
{
*
aIsDefinite
=
true
;
if
(
aAvailableBSizeForContent
=
=
NS_UNCONSTRAINEDSIZE
|
|
effectiveComputedBSize
<
aAvailableBSizeForContent
)
{
return
effectiveComputedBSize
;
}
aStatus
.
SetIncomplete
(
)
;
if
(
aSumLineCrossSizes
<
=
aAvailableBSizeForContent
)
{
return
aAvailableBSizeForContent
;
}
return
std
:
:
min
(
effectiveComputedBSize
aSumLineCrossSizes
)
;
}
if
(
aReflowInput
.
mStyleDisplay
-
>
IsContainSize
(
)
)
{
*
aIsDefinite
=
true
;
return
aReflowInput
.
ComputedMinBSize
(
)
;
}
*
aIsDefinite
=
false
;
return
NS_CSS_MINMAX
(
aSumLineCrossSizes
aReflowInput
.
ComputedMinBSize
(
)
aReflowInput
.
ComputedMaxBSize
(
)
)
;
}
void
FlexLine
:
:
PositionItemsInMainAxis
(
const
StyleContentDistribution
&
aJustifyContent
nscoord
aContentBoxMainSize
const
FlexboxAxisTracker
&
aAxisTracker
)
{
MainAxisPositionTracker
mainAxisPosnTracker
(
aAxisTracker
this
aJustifyContent
aContentBoxMainSize
)
;
for
(
FlexItem
*
item
=
mItems
.
getFirst
(
)
;
item
;
item
=
item
-
>
getNext
(
)
)
{
nscoord
itemMainBorderBoxSize
=
item
-
>
MainSize
(
)
+
item
-
>
BorderPaddingSizeInMainAxis
(
)
;
mainAxisPosnTracker
.
ResolveAutoMarginsInMainAxis
(
*
item
)
;
mainAxisPosnTracker
.
EnterMargin
(
item
-
>
Margin
(
)
)
;
mainAxisPosnTracker
.
EnterChildFrame
(
itemMainBorderBoxSize
)
;
item
-
>
SetMainPosition
(
mainAxisPosnTracker
.
Position
(
)
)
;
mainAxisPosnTracker
.
ExitChildFrame
(
itemMainBorderBoxSize
)
;
mainAxisPosnTracker
.
ExitMargin
(
item
-
>
Margin
(
)
)
;
mainAxisPosnTracker
.
TraversePackingSpace
(
)
;
if
(
item
-
>
getNext
(
)
)
{
mainAxisPosnTracker
.
TraverseGap
(
mMainGapSize
)
;
}
}
}
static
nscoord
ComputePhysicalAscentFromFlexRelativeAscent
(
nscoord
aFlexRelativeAscent
nscoord
aContentBoxCrossSize
const
ReflowInput
&
aReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
)
{
return
aReflowInput
.
ComputedPhysicalBorderPadding
(
)
.
top
+
PhysicalCoordFromFlexRelativeCoord
(
aFlexRelativeAscent
aContentBoxCrossSize
aAxisTracker
.
CrossAxisPhysicalStartSide
(
)
)
;
}
void
nsFlexContainerFrame
:
:
SizeItemInCrossAxis
(
nsPresContext
*
aPresContext
ReflowInput
&
aChildReflowInput
FlexItem
&
aItem
)
{
if
(
aItem
.
IsInlineAxisCrossAxis
(
)
)
{
aItem
.
SetCrossSize
(
aChildReflowInput
.
ComputedISize
(
)
)
;
return
;
}
MOZ_ASSERT
(
!
aItem
.
HadMeasuringReflow
(
)
"
We
shouldn
'
t
need
more
than
one
measuring
reflow
"
)
;
if
(
aItem
.
AlignSelf
(
)
.
_0
=
=
StyleAlignFlags
:
:
STRETCH
)
{
aChildReflowInput
.
SetBResize
(
true
)
;
aChildReflowInput
.
mFlags
.
mIsBResizeForPercentages
=
true
;
}
const
CachedMeasuringReflowResult
&
reflowResult
=
MeasureAscentAndBSizeForFlexItem
(
aItem
aPresContext
aChildReflowInput
)
;
nscoord
crossAxisBorderPadding
=
aItem
.
BorderPaddingSizeInCrossAxis
(
)
;
if
(
reflowResult
.
BSize
(
)
<
crossAxisBorderPadding
)
{
NS_WARNING_ASSERTION
(
aItem
.
Frame
(
)
-
>
Type
(
)
=
=
LayoutFrameType
:
:
None
"
Child
should
at
least
request
space
for
border
/
padding
"
)
;
aItem
.
SetCrossSize
(
0
)
;
}
else
{
aItem
.
SetCrossSize
(
reflowResult
.
BSize
(
)
-
crossAxisBorderPadding
)
;
}
aItem
.
SetAscent
(
reflowResult
.
Ascent
(
)
)
;
}
void
FlexLine
:
:
PositionItemsInCrossAxis
(
nscoord
aLineStartPosition
const
FlexboxAxisTracker
&
aAxisTracker
)
{
SingleLineCrossAxisPositionTracker
lineCrossAxisPosnTracker
(
aAxisTracker
)
;
for
(
FlexItem
*
item
=
mItems
.
getFirst
(
)
;
item
;
item
=
item
-
>
getNext
(
)
)
{
item
-
>
ResolveStretchedCrossSize
(
mLineCrossSize
)
;
lineCrossAxisPosnTracker
.
ResolveAutoMarginsInCrossAxis
(
*
this
*
item
)
;
nscoord
itemCrossBorderBoxSize
=
item
-
>
CrossSize
(
)
+
item
-
>
BorderPaddingSizeInCrossAxis
(
)
;
lineCrossAxisPosnTracker
.
EnterAlignPackingSpace
(
*
this
*
item
aAxisTracker
)
;
lineCrossAxisPosnTracker
.
EnterMargin
(
item
-
>
Margin
(
)
)
;
lineCrossAxisPosnTracker
.
EnterChildFrame
(
itemCrossBorderBoxSize
)
;
item
-
>
SetCrossPosition
(
aLineStartPosition
+
lineCrossAxisPosnTracker
.
Position
(
)
)
;
lineCrossAxisPosnTracker
.
ResetPosition
(
)
;
}
}
void
nsFlexContainerFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsFlexContainerFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aDesiredSize
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
FLEX_LOG
(
"
Reflow
(
)
for
nsFlexContainerFrame
%
p
"
this
)
;
if
(
IsFrameTreeTooDeep
(
aReflowInput
aDesiredSize
aStatus
)
)
{
return
;
}
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
const
nsStylePosition
*
stylePos
=
StylePosition
(
)
;
const
auto
&
bsize
=
stylePos
-
>
BSize
(
wm
)
;
if
(
bsize
.
HasPercent
(
)
|
|
(
StyleDisplay
(
)
-
>
IsAbsolutelyPositionedStyle
(
)
&
&
(
bsize
.
IsAuto
(
)
|
|
bsize
.
IsExtremumLength
(
)
)
&
&
!
stylePos
-
>
mOffset
.
GetBStart
(
wm
)
.
IsAuto
(
)
&
&
!
stylePos
-
>
mOffset
.
GetBEnd
(
wm
)
.
IsAuto
(
)
)
)
{
AddStateBits
(
NS_FRAME_CONTAINS_RELATIVE_BSIZE
)
;
}
bool
hasLineClampEllipsis
=
HasAnyStateBits
(
NS_STATE_FLEX_HAS_LINE_CLAMP_ELLIPSIS
)
;
RemoveStateBits
(
NS_STATE_FLEX_HAS_LINE_CLAMP_ELLIPSIS
)
;
const
FlexboxAxisTracker
axisTracker
(
this
aReflowInput
.
GetWritingMode
(
)
)
;
CreateOrClearFlexContainerInfo
(
)
;
nscoord
availableBSizeForContent
=
aReflowInput
.
AvailableBSize
(
)
;
if
(
availableBSizeForContent
!
=
NS_UNCONSTRAINEDSIZE
&
&
!
(
GetLogicalSkipSides
(
&
aReflowInput
)
.
BStart
(
)
)
)
{
availableBSizeForContent
-
=
aReflowInput
.
ComputedLogicalBorderPadding
(
)
.
BStart
(
wm
)
;
availableBSizeForContent
=
std
:
:
max
(
availableBSizeForContent
0
)
;
}
nscoord
contentBoxMainSize
=
GetMainSizeFromReflowInput
(
aReflowInput
axisTracker
)
;
nscoord
mainGapSize
;
nscoord
crossGapSize
;
if
(
axisTracker
.
IsRowOriented
(
)
)
{
mainGapSize
=
nsLayoutUtils
:
:
ResolveGapToLength
(
stylePos
-
>
mColumnGap
contentBoxMainSize
)
;
crossGapSize
=
nsLayoutUtils
:
:
ResolveGapToLength
(
stylePos
-
>
mRowGap
GetEffectiveComputedBSize
(
aReflowInput
)
)
;
}
else
{
mainGapSize
=
nsLayoutUtils
:
:
ResolveGapToLength
(
stylePos
-
>
mRowGap
contentBoxMainSize
)
;
NS_WARNING_ASSERTION
(
aReflowInput
.
ComputedISize
(
)
!
=
NS_UNCONSTRAINEDSIZE
"
Unconstrained
inline
size
;
this
should
only
result
"
"
from
huge
sizes
(
not
intrinsic
sizing
w
/
orthogonal
"
"
flows
)
"
)
;
crossGapSize
=
nsLayoutUtils
:
:
ResolveGapToLength
(
stylePos
-
>
mColumnGap
aReflowInput
.
ComputedISize
(
)
)
;
}
AutoTArray
<
StrutInfo
1
>
struts
;
DoFlexLayout
(
aPresContext
aDesiredSize
aReflowInput
aStatus
contentBoxMainSize
availableBSizeForContent
struts
axisTracker
mainGapSize
crossGapSize
hasLineClampEllipsis
)
;
if
(
!
struts
.
IsEmpty
(
)
)
{
aStatus
.
Reset
(
)
;
DoFlexLayout
(
aPresContext
aDesiredSize
aReflowInput
aStatus
contentBoxMainSize
availableBSizeForContent
struts
axisTracker
mainGapSize
crossGapSize
hasLineClampEllipsis
)
;
}
}
class
MOZ_RAII
AutoFlexItemMainSizeOverride
final
{
public
:
explicit
AutoFlexItemMainSizeOverride
(
FlexItem
&
aItem
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
:
mItemFrame
(
aItem
.
Frame
(
)
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
MOZ_ASSERT
(
!
mItemFrame
-
>
HasProperty
(
nsIFrame
:
:
FlexItemMainSizeOverride
(
)
)
"
FlexItemMainSizeOverride
prop
shouldn
'
t
be
set
already
;
"
"
it
should
only
be
set
temporarily
(
&
not
recursively
)
"
)
;
NS_ASSERTION
(
aItem
.
HasIntrinsicRatio
(
)
"
This
should
only
be
needed
for
items
with
an
aspect
ratio
"
)
;
nscoord
mainSizeOverrideVal
=
aItem
.
MainSize
(
)
;
if
(
aItem
.
Frame
(
)
-
>
StylePosition
(
)
-
>
mBoxSizing
=
=
StyleBoxSizing
:
:
Border
)
{
mainSizeOverrideVal
+
=
aItem
.
BorderPaddingSizeInMainAxis
(
)
;
}
mItemFrame
-
>
SetProperty
(
nsIFrame
:
:
FlexItemMainSizeOverride
(
)
mainSizeOverrideVal
)
;
}
~
AutoFlexItemMainSizeOverride
(
)
{
mItemFrame
-
>
RemoveProperty
(
nsIFrame
:
:
FlexItemMainSizeOverride
(
)
)
;
}
private
:
nsIFrame
*
mItemFrame
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
void
nsFlexContainerFrame
:
:
CalculatePackingSpace
(
uint32_t
aNumThingsToPack
const
StyleContentDistribution
&
aAlignVal
nscoord
*
aFirstSubjectOffset
uint32_t
*
aNumPackingSpacesRemaining
nscoord
*
aPackingSpaceRemaining
)
{
StyleAlignFlags
val
=
aAlignVal
.
primary
;
MOZ_ASSERT
(
val
=
=
StyleAlignFlags
:
:
SPACE_BETWEEN
|
|
val
=
=
StyleAlignFlags
:
:
SPACE_AROUND
|
|
val
=
=
StyleAlignFlags
:
:
SPACE_EVENLY
"
Unexpected
alignment
value
"
)
;
MOZ_ASSERT
(
*
aPackingSpaceRemaining
>
=
0
"
Should
not
be
called
with
negative
packing
space
"
)
;
MOZ_ASSERT
(
aNumThingsToPack
>
1
"
Should
not
be
called
unless
there
'
s
more
than
1
thing
to
pack
"
)
;
*
aNumPackingSpacesRemaining
=
aNumThingsToPack
-
1
;
if
(
val
=
=
StyleAlignFlags
:
:
SPACE_BETWEEN
)
{
return
;
}
size_t
numPackingSpacesForEdges
=
val
=
=
StyleAlignFlags
:
:
SPACE_AROUND
?
1
:
2
;
nscoord
packingSpaceSize
=
*
aPackingSpaceRemaining
/
(
*
aNumPackingSpacesRemaining
+
numPackingSpacesForEdges
)
;
nscoord
totalEdgePackingSpace
=
numPackingSpacesForEdges
*
packingSpaceSize
;
*
aFirstSubjectOffset
+
=
totalEdgePackingSpace
/
2
;
*
aPackingSpaceRemaining
-
=
totalEdgePackingSpace
;
}
void
nsFlexContainerFrame
:
:
CreateOrClearFlexContainerInfo
(
)
{
if
(
!
HasAnyStateBits
(
NS_STATE_FLEX_GENERATE_COMPUTED_VALUES
)
)
{
return
;
}
ComputedFlexContainerInfo
*
info
=
GetProperty
(
FlexContainerInfo
(
)
)
;
if
(
info
)
{
info
-
>
mLines
.
Clear
(
)
;
}
else
{
info
=
new
ComputedFlexContainerInfo
(
)
;
SetProperty
(
FlexContainerInfo
(
)
info
)
;
}
}
void
nsFlexContainerFrame
:
:
CreateFlexLineAndFlexItemInfo
(
ComputedFlexContainerInfo
&
aContainerInfo
const
mozilla
:
:
LinkedList
<
FlexLine
>
&
aLines
)
{
for
(
const
FlexLine
*
line
=
aLines
.
getFirst
(
)
;
line
;
line
=
line
-
>
getNext
(
)
)
{
ComputedFlexLineInfo
*
lineInfo
=
aContainerInfo
.
mLines
.
AppendElement
(
)
;
for
(
const
FlexItem
*
item
=
line
-
>
GetFirstItem
(
)
;
item
;
item
=
item
-
>
getNext
(
)
)
{
nsIFrame
*
frame
=
item
-
>
Frame
(
)
;
nsIFrame
*
targetFrame
=
GetFirstNonAnonBoxDescendant
(
frame
)
;
nsIContent
*
content
=
targetFrame
-
>
GetContent
(
)
;
while
(
content
&
&
content
-
>
TextIsOnlyWhitespace
(
)
)
{
targetFrame
=
targetFrame
-
>
GetNextSibling
(
)
;
if
(
targetFrame
)
{
content
=
targetFrame
-
>
GetContent
(
)
;
}
else
{
content
=
nullptr
;
}
}
ComputedFlexItemInfo
*
itemInfo
=
lineInfo
-
>
mItems
.
AppendElement
(
)
;
itemInfo
-
>
mNode
=
content
;
}
}
}
void
nsFlexContainerFrame
:
:
ComputeFlexDirections
(
ComputedFlexContainerInfo
&
aContainerInfo
const
FlexboxAxisTracker
&
aAxisTracker
)
{
auto
ConvertPhysicalStartSideToFlexPhysicalDirection
=
[
]
(
mozilla
:
:
Side
aStartSide
)
{
switch
(
aStartSide
)
{
case
eSideLeft
:
return
dom
:
:
FlexPhysicalDirection
:
:
Horizontal_lr
;
case
eSideRight
:
return
dom
:
:
FlexPhysicalDirection
:
:
Horizontal_rl
;
case
eSideTop
:
return
dom
:
:
FlexPhysicalDirection
:
:
Vertical_tb
;
case
eSideBottom
:
return
dom
:
:
FlexPhysicalDirection
:
:
Vertical_bt
;
}
MOZ_ASSERT_UNREACHABLE
(
"
We
should
handle
all
sides
!
"
)
;
return
dom
:
:
FlexPhysicalDirection
:
:
Horizontal_lr
;
}
;
aContainerInfo
.
mMainAxisDirection
=
ConvertPhysicalStartSideToFlexPhysicalDirection
(
aAxisTracker
.
AreAxesInternallyReversed
(
)
?
aAxisTracker
.
MainAxisPhysicalEndSide
(
)
:
aAxisTracker
.
MainAxisPhysicalStartSide
(
)
)
;
aContainerInfo
.
mCrossAxisDirection
=
ConvertPhysicalStartSideToFlexPhysicalDirection
(
aAxisTracker
.
AreAxesInternallyReversed
(
)
?
aAxisTracker
.
CrossAxisPhysicalEndSide
(
)
:
aAxisTracker
.
CrossAxisPhysicalStartSide
(
)
)
;
}
void
nsFlexContainerFrame
:
:
UpdateFlexLineAndItemInfo
(
ComputedFlexContainerInfo
&
aContainerInfo
const
mozilla
:
:
LinkedList
<
FlexLine
>
&
aLines
)
{
uint32_t
lineIndex
=
0
;
for
(
const
FlexLine
*
line
=
aLines
.
getFirst
(
)
;
line
;
line
=
line
-
>
getNext
(
)
+
+
lineIndex
)
{
ComputedFlexLineInfo
&
lineInfo
=
aContainerInfo
.
mLines
[
lineIndex
]
;
lineInfo
.
mCrossSize
=
line
-
>
LineCrossSize
(
)
;
lineInfo
.
mFirstBaselineOffset
=
line
-
>
FirstBaselineOffset
(
)
;
lineInfo
.
mLastBaselineOffset
=
line
-
>
LastBaselineOffset
(
)
;
uint32_t
itemIndex
=
0
;
for
(
const
FlexItem
*
item
=
line
-
>
GetFirstItem
(
)
;
item
;
item
=
item
-
>
getNext
(
)
+
+
itemIndex
)
{
ComputedFlexItemInfo
&
itemInfo
=
lineInfo
.
mItems
[
itemIndex
]
;
itemInfo
.
mFrameRect
=
item
-
>
Frame
(
)
-
>
GetRect
(
)
;
itemInfo
.
mMainMinSize
=
item
-
>
MainMinSize
(
)
;
itemInfo
.
mMainMaxSize
=
item
-
>
MainMaxSize
(
)
;
itemInfo
.
mCrossMinSize
=
item
-
>
CrossMinSize
(
)
;
itemInfo
.
mCrossMaxSize
=
item
-
>
CrossMaxSize
(
)
;
itemInfo
.
mClampState
=
item
-
>
WasMinClamped
(
)
?
mozilla
:
:
dom
:
:
FlexItemClampState
:
:
Clamped_to_min
:
(
item
-
>
WasMaxClamped
(
)
?
mozilla
:
:
dom
:
:
FlexItemClampState
:
:
Clamped_to_max
:
mozilla
:
:
dom
:
:
FlexItemClampState
:
:
Unclamped
)
;
}
}
}
nsFlexContainerFrame
*
nsFlexContainerFrame
:
:
GetFlexFrameWithComputedInfo
(
nsIFrame
*
aFrame
)
{
auto
GetFlexContainerFrame
=
[
]
(
nsIFrame
*
aFrame
)
{
nsFlexContainerFrame
*
flexFrame
=
nullptr
;
if
(
aFrame
)
{
nsIFrame
*
contentFrame
=
aFrame
-
>
GetContentInsertionFrame
(
)
;
if
(
contentFrame
&
&
(
contentFrame
-
>
IsFlexContainerFrame
(
)
)
)
{
flexFrame
=
static_cast
<
nsFlexContainerFrame
*
>
(
contentFrame
)
;
}
}
return
flexFrame
;
}
;
nsFlexContainerFrame
*
flexFrame
=
GetFlexContainerFrame
(
aFrame
)
;
if
(
flexFrame
)
{
bool
reflowNeeded
=
!
flexFrame
-
>
HasProperty
(
FlexContainerInfo
(
)
)
;
if
(
reflowNeeded
)
{
AutoWeakFrame
weakFrameRef
(
aFrame
)
;
RefPtr
<
mozilla
:
:
PresShell
>
presShell
=
flexFrame
-
>
PresShell
(
)
;
flexFrame
-
>
AddStateBits
(
NS_STATE_FLEX_GENERATE_COMPUTED_VALUES
)
;
presShell
-
>
FrameNeedsReflow
(
flexFrame
IntrinsicDirty
:
:
Resize
NS_FRAME_IS_DIRTY
)
;
presShell
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
if
(
!
weakFrameRef
.
IsAlive
(
)
)
{
return
nullptr
;
}
flexFrame
=
GetFlexContainerFrame
(
weakFrameRef
.
GetFrame
(
)
)
;
NS_WARNING_ASSERTION
(
!
flexFrame
|
|
flexFrame
-
>
HasProperty
(
FlexContainerInfo
(
)
)
"
The
state
bit
should
'
ve
made
our
forced
-
reflow
"
"
generate
a
FlexContainerInfo
object
"
)
;
}
}
return
flexFrame
;
}
bool
nsFlexContainerFrame
:
:
IsItemInlineAxisMainAxis
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
&
&
aFrame
-
>
IsFlexItem
(
)
"
expecting
arg
to
be
a
flex
item
"
)
;
const
WritingMode
flexItemWM
=
aFrame
-
>
GetWritingMode
(
)
;
const
nsIFrame
*
flexContainer
=
aFrame
-
>
GetParent
(
)
;
if
(
IsLegacyBox
(
flexContainer
)
)
{
bool
boxOrientIsVertical
=
(
flexContainer
-
>
StyleXUL
(
)
-
>
mBoxOrient
=
=
StyleBoxOrient
:
:
Vertical
)
;
return
flexItemWM
.
IsVertical
(
)
=
=
boxOrientIsVertical
;
}
bool
itemInlineAxisIsParallelToParent
=
!
flexItemWM
.
IsOrthogonalTo
(
flexContainer
-
>
GetWritingMode
(
)
)
;
auto
flexDirection
=
flexContainer
-
>
StylePosition
(
)
-
>
mFlexDirection
;
bool
flexContainerIsRowOriented
=
flexDirection
=
=
StyleFlexDirection
:
:
Row
|
|
flexDirection
=
=
StyleFlexDirection
:
:
RowReverse
;
return
flexContainerIsRowOriented
=
=
itemInlineAxisIsParallelToParent
;
}
bool
nsFlexContainerFrame
:
:
IsUsedFlexBasisContent
(
const
StyleFlexBasis
&
aFlexBasis
const
StyleSize
&
aMainSize
)
{
if
(
aFlexBasis
.
IsContent
(
)
)
{
return
true
;
}
return
aFlexBasis
.
IsAuto
(
)
&
&
aMainSize
.
IsAuto
(
)
;
}
void
nsFlexContainerFrame
:
:
DoFlexLayout
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
nscoord
aContentBoxMainSize
nscoord
aAvailableBSizeForContent
nsTArray
<
StrutInfo
>
&
aStruts
const
FlexboxAxisTracker
&
aAxisTracker
nscoord
aMainGapSize
nscoord
aCrossGapSize
bool
aHasLineClampEllipsis
)
{
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
AutoCleanLinkedList
<
FlexLine
>
lines
;
nsTArray
<
nsIFrame
*
>
placeholderKids
;
GenerateFlexLines
(
aPresContext
aReflowInput
aContentBoxMainSize
aAvailableBSizeForContent
aStruts
aAxisTracker
aMainGapSize
aHasLineClampEllipsis
placeholderKids
lines
)
;
if
(
(
lines
.
getFirst
(
)
-
>
IsEmpty
(
)
&
&
!
lines
.
getFirst
(
)
-
>
getNext
(
)
)
|
|
aReflowInput
.
mStyleDisplay
-
>
IsContainLayout
(
)
)
{
AddStateBits
(
NS_STATE_FLEX_SYNTHESIZE_BASELINE
)
;
}
else
{
RemoveStateBits
(
NS_STATE_FLEX_SYNTHESIZE_BASELINE
)
;
}
ComputedFlexContainerInfo
*
containerInfo
=
nullptr
;
if
(
HasAnyStateBits
(
NS_STATE_FLEX_GENERATE_COMPUTED_VALUES
)
)
{
containerInfo
=
GetProperty
(
FlexContainerInfo
(
)
)
;
MOZ_ASSERT
(
containerInfo
"
:
:
Reflow
(
)
should
have
created
container
info
.
"
)
;
if
(
!
aStruts
.
IsEmpty
(
)
)
{
containerInfo
-
>
mLines
.
Clear
(
)
;
}
else
{
MOZ_ASSERT
(
containerInfo
-
>
mLines
.
IsEmpty
(
)
"
Shouldn
'
t
have
lines
yet
.
"
)
;
}
CreateFlexLineAndFlexItemInfo
(
*
containerInfo
lines
)
;
ComputeFlexDirections
(
*
containerInfo
aAxisTracker
)
;
}
aContentBoxMainSize
=
ResolveFlexContainerMainSize
(
aReflowInput
aAxisTracker
aContentBoxMainSize
aAvailableBSizeForContent
lines
.
getFirst
(
)
aStatus
)
;
uint32_t
lineIndex
=
0
;
for
(
FlexLine
*
line
=
lines
.
getFirst
(
)
;
line
;
line
=
line
-
>
getNext
(
)
+
+
lineIndex
)
{
ComputedFlexLineInfo
*
lineInfo
=
containerInfo
?
&
containerInfo
-
>
mLines
[
lineIndex
]
:
nullptr
;
line
-
>
ResolveFlexibleLengths
(
aContentBoxMainSize
lineInfo
)
;
}
nscoord
sumLineCrossSizes
=
0
;
for
(
FlexLine
*
line
=
lines
.
getFirst
(
)
;
line
;
line
=
line
-
>
getNext
(
)
)
{
for
(
FlexItem
*
item
=
line
-
>
GetFirstItem
(
)
;
item
;
item
=
item
-
>
getNext
(
)
)
{
if
(
item
-
>
CanMainSizeInfluenceCrossSize
(
aAxisTracker
)
)
{
Maybe
<
AutoFlexItemMainSizeOverride
>
sizeOverride
;
if
(
item
-
>
HasIntrinsicRatio
(
)
)
{
sizeOverride
.
emplace
(
*
item
)
;
}
WritingMode
wm
=
item
-
>
Frame
(
)
-
>
GetWritingMode
(
)
;
LogicalSize
availSize
=
aReflowInput
.
ComputedSize
(
wm
)
;
availSize
.
BSize
(
wm
)
=
NS_UNCONSTRAINEDSIZE
;
ReflowInput
childReflowInput
(
aPresContext
aReflowInput
item
-
>
Frame
(
)
availSize
)
;
childReflowInput
.
mFlags
.
mInsideLineClamp
=
GetLineClampValue
(
)
!
=
0
;
if
(
!
sizeOverride
)
{
if
(
item
-
>
IsInlineAxisMainAxis
(
)
)
{
childReflowInput
.
SetComputedISize
(
item
-
>
MainSize
(
)
)
;
}
else
{
childReflowInput
.
SetComputedBSize
(
item
-
>
MainSize
(
)
)
;
if
(
item
-
>
TreatBSizeAsIndefinite
(
)
)
{
childReflowInput
.
mFlags
.
mTreatBSizeAsIndefinite
=
true
;
}
}
}
SizeItemInCrossAxis
(
aPresContext
childReflowInput
*
item
)
;
}
}
line
-
>
ComputeCrossSizeAndBaseline
(
aAxisTracker
)
;
sumLineCrossSizes
+
=
line
-
>
LineCrossSize
(
)
;
if
(
line
-
>
getNext
(
)
)
{
sumLineCrossSizes
+
=
aCrossGapSize
;
}
}
bool
isCrossSizeDefinite
;
const
nscoord
contentBoxCrossSize
=
ComputeCrossSize
(
aReflowInput
aAxisTracker
sumLineCrossSizes
aAvailableBSizeForContent
&
isCrossSizeDefinite
aStatus
)
;
CrossAxisPositionTracker
crossAxisPosnTracker
(
lines
.
getFirst
(
)
aReflowInput
contentBoxCrossSize
isCrossSizeDefinite
aAxisTracker
aCrossGapSize
)
;
if
(
aStruts
.
IsEmpty
(
)
&
&
!
ShouldUseMozBoxCollapseBehavior
(
aReflowInput
.
mStyleDisplay
)
)
{
BuildStrutInfoFromCollapsedItems
(
lines
.
getFirst
(
)
aStruts
)
;
if
(
!
aStruts
.
IsEmpty
(
)
)
{
return
;
}
}
nscoord
flexContainerAscent
;
if
(
!
aAxisTracker
.
AreAxesInternallyReversed
(
)
)
{
nscoord
firstLineBaselineOffset
=
lines
.
getFirst
(
)
-
>
FirstBaselineOffset
(
)
;
if
(
firstLineBaselineOffset
=
=
nscoord_MIN
)
{
flexContainerAscent
=
nscoord_MIN
;
}
else
{
flexContainerAscent
=
ComputePhysicalAscentFromFlexRelativeAscent
(
crossAxisPosnTracker
.
Position
(
)
+
firstLineBaselineOffset
contentBoxCrossSize
aReflowInput
aAxisTracker
)
;
}
}
const
auto
justifyContent
=
IsLegacyBox
(
aReflowInput
.
mFrame
)
?
ConvertLegacyStyleToJustifyContent
(
StyleXUL
(
)
)
:
aReflowInput
.
mStylePosition
-
>
mJustifyContent
;
if
(
aReflowInput
.
ComputedBSize
(
)
=
=
NS_UNCONSTRAINEDSIZE
&
&
aReflowInput
.
mStylePosition
-
>
mRowGap
.
IsLengthPercentage
(
)
&
&
aReflowInput
.
mStylePosition
-
>
mRowGap
.
AsLengthPercentage
(
)
.
HasPercent
(
)
)
{
bool
rowIsCross
=
aAxisTracker
.
IsRowOriented
(
)
;
nscoord
newBlockGapSize
=
nsLayoutUtils
:
:
ResolveGapToLength
(
aReflowInput
.
mStylePosition
-
>
mRowGap
rowIsCross
?
contentBoxCrossSize
:
aContentBoxMainSize
)
;
if
(
rowIsCross
)
{
crossAxisPosnTracker
.
SetCrossGapSize
(
newBlockGapSize
)
;
}
else
{
for
(
FlexLine
*
line
=
lines
.
getFirst
(
)
;
line
;
line
=
line
-
>
getNext
(
)
+
+
lineIndex
)
{
line
-
>
SetMainGapSize
(
newBlockGapSize
)
;
}
}
}
lineIndex
=
0
;
for
(
FlexLine
*
line
=
lines
.
getFirst
(
)
;
line
;
line
=
line
-
>
getNext
(
)
+
+
lineIndex
)
{
line
-
>
PositionItemsInMainAxis
(
justifyContent
aContentBoxMainSize
aAxisTracker
)
;
if
(
MOZ_UNLIKELY
(
containerInfo
)
)
{
ComputedFlexLineInfo
&
lineInfo
=
containerInfo
-
>
mLines
[
lineIndex
]
;
lineInfo
.
mCrossStart
=
crossAxisPosnTracker
.
Position
(
)
;
}
line
-
>
PositionItemsInCrossAxis
(
crossAxisPosnTracker
.
Position
(
)
aAxisTracker
)
;
crossAxisPosnTracker
.
TraverseLine
(
*
line
)
;
crossAxisPosnTracker
.
TraversePackingSpace
(
)
;
if
(
line
-
>
getNext
(
)
)
{
crossAxisPosnTracker
.
TraverseGap
(
)
;
}
}
if
(
aAxisTracker
.
AreAxesInternallyReversed
(
)
)
{
nscoord
lastLineBaselineOffset
=
lines
.
getLast
(
)
-
>
FirstBaselineOffset
(
)
;
if
(
lastLineBaselineOffset
=
=
nscoord_MIN
)
{
flexContainerAscent
=
nscoord_MIN
;
}
else
{
flexContainerAscent
=
ComputePhysicalAscentFromFlexRelativeAscent
(
crossAxisPosnTracker
.
Position
(
)
-
lastLineBaselineOffset
contentBoxCrossSize
aReflowInput
aAxisTracker
)
;
}
}
WritingMode
flexWM
=
aReflowInput
.
GetWritingMode
(
)
;
LogicalMargin
containerBP
=
aReflowInput
.
ComputedLogicalBorderPadding
(
)
;
const
nscoord
blockEndContainerBP
=
containerBP
.
BEnd
(
flexWM
)
;
const
LogicalSides
skipSides
=
GetLogicalSkipSides
(
&
aReflowInput
)
|
LogicalSides
(
eLogicalSideBitsBEnd
)
;
containerBP
.
ApplySkipSides
(
skipSides
)
;
const
LogicalPoint
containerContentBoxOrigin
(
flexWM
containerBP
.
IStart
(
flexWM
)
containerBP
.
BStart
(
flexWM
)
)
;
LogicalSize
logSize
=
aAxisTracker
.
LogicalSizeFromFlexRelativeSizes
(
aContentBoxMainSize
contentBoxCrossSize
)
;
logSize
+
=
aReflowInput
.
ComputedLogicalBorderPadding
(
)
.
Size
(
flexWM
)
;
nsSize
containerSize
=
logSize
.
GetPhysicalSize
(
flexWM
)
;
const
FlexItem
*
const
firstItem
=
aAxisTracker
.
AreAxesInternallyReversed
(
)
?
lines
.
getLast
(
)
-
>
GetLastItem
(
)
:
lines
.
getFirst
(
)
-
>
GetFirstItem
(
)
;
for
(
const
FlexLine
*
line
=
lines
.
getFirst
(
)
;
line
;
line
=
line
-
>
getNext
(
)
)
{
for
(
const
FlexItem
*
item
=
line
-
>
GetFirstItem
(
)
;
item
;
item
=
item
-
>
getNext
(
)
)
{
LogicalPoint
framePos
=
aAxisTracker
.
LogicalPointFromFlexRelativePoint
(
item
-
>
MainPosition
(
)
item
-
>
CrossPosition
(
)
aContentBoxMainSize
contentBoxCrossSize
)
;
framePos
+
=
containerContentBoxOrigin
;
const
nscoord
itemNormalBPos
=
framePos
.
B
(
flexWM
)
;
bool
itemNeedsReflow
=
true
;
if
(
item
-
>
HadMeasuringReflow
(
)
)
{
LogicalSize
finalFlexItemCBSize
=
aAxisTracker
.
LogicalSizeFromFlexRelativeSizes
(
item
-
>
MainSize
(
)
item
-
>
CrossSize
(
)
)
;
if
(
finalFlexItemCBSize
=
=
LogicalSize
(
flexWM
item
-
>
Frame
(
)
-
>
GetContentRectRelativeToSelf
(
)
.
Size
(
)
)
)
{
if
(
!
FrameHasRelativeBSizeDependency
(
item
-
>
Frame
(
)
)
)
{
itemNeedsReflow
=
false
;
MoveFlexItemToFinalPosition
(
aReflowInput
*
item
framePos
containerSize
)
;
}
}
if
(
itemNeedsReflow
)
{
FLEX_LOG
(
"
[
perf
]
Flex
item
needed
both
a
measuring
reflow
and
a
final
"
"
reflow
"
)
;
}
}
if
(
itemNeedsReflow
)
{
ReflowFlexItem
(
aPresContext
aAxisTracker
aReflowInput
*
item
framePos
containerSize
aHasLineClampEllipsis
)
;
}
if
(
!
itemNeedsReflow
&
&
aHasLineClampEllipsis
&
&
GetLineClampValue
(
)
=
=
0
)
{
item
-
>
BlockFrame
(
)
-
>
ClearLineClampEllipsis
(
)
;
}
if
(
item
-
>
HasAnyAutoMargin
(
)
)
{
nsMargin
*
propValue
=
item
-
>
Frame
(
)
-
>
GetProperty
(
nsIFrame
:
:
UsedMarginProperty
(
)
)
;
if
(
propValue
)
{
*
propValue
=
item
-
>
PhysicalMargin
(
)
;
}
}
if
(
item
=
=
firstItem
&
&
flexContainerAscent
=
=
nscoord_MIN
)
{
flexContainerAscent
=
itemNormalBPos
+
item
-
>
ResolvedAscent
(
true
)
;
}
}
}
if
(
!
placeholderKids
.
IsEmpty
(
)
)
{
ReflowPlaceholders
(
aPresContext
aReflowInput
placeholderKids
containerContentBoxOrigin
containerSize
)
;
}
LogicalSize
desiredSizeInFlexWM
=
aAxisTracker
.
LogicalSizeFromFlexRelativeSizes
(
aContentBoxMainSize
contentBoxCrossSize
)
;
desiredSizeInFlexWM
.
ISize
(
flexWM
)
+
=
containerBP
.
IStartEnd
(
flexWM
)
;
desiredSizeInFlexWM
.
BSize
(
flexWM
)
+
=
containerBP
.
BStartEnd
(
flexWM
)
;
if
(
flexContainerAscent
=
=
nscoord_MIN
)
{
NS_WARNING_ASSERTION
(
lines
.
getFirst
(
)
-
>
IsEmpty
(
)
"
Have
flex
items
but
didn
'
t
get
an
ascent
-
that
'
s
odd
(
or
there
are
"
"
just
gigantic
sizes
involved
)
"
)
;
flexContainerAscent
=
desiredSizeInFlexWM
.
BSize
(
flexWM
)
;
}
if
(
HasAnyStateBits
(
NS_STATE_FLEX_SYNTHESIZE_BASELINE
)
)
{
aDesiredSize
.
SetBlockStartAscent
(
ReflowOutput
:
:
ASK_FOR_BASELINE
)
;
}
else
{
aDesiredSize
.
SetBlockStartAscent
(
flexContainerAscent
)
;
}
if
(
aStatus
.
IsComplete
(
)
)
{
nscoord
desiredBSizeWithBEndBP
=
desiredSizeInFlexWM
.
BSize
(
flexWM
)
+
blockEndContainerBP
;
if
(
aReflowInput
.
AvailableBSize
(
)
=
=
NS_UNCONSTRAINEDSIZE
|
|
desiredSizeInFlexWM
.
BSize
(
flexWM
)
=
=
0
|
|
desiredBSizeWithBEndBP
<
=
aReflowInput
.
AvailableBSize
(
)
|
|
aReflowInput
.
ComputedBSize
(
)
=
=
NS_UNCONSTRAINEDSIZE
)
{
desiredSizeInFlexWM
.
BSize
(
flexWM
)
=
desiredBSizeWithBEndBP
;
}
else
{
aStatus
.
SetIncomplete
(
)
;
}
}
mBaselineFromLastReflow
=
flexContainerAscent
;
mLastBaselineFromLastReflow
=
lines
.
getLast
(
)
-
>
LastBaselineOffset
(
)
;
if
(
mLastBaselineFromLastReflow
=
=
nscoord_MIN
)
{
mLastBaselineFromLastReflow
=
desiredSizeInFlexWM
.
BSize
(
flexWM
)
-
flexContainerAscent
;
}
aDesiredSize
.
SetSize
(
flexWM
desiredSizeInFlexWM
)
;
aDesiredSize
.
SetOverflowAreasToDesiredBounds
(
)
;
for
(
nsIFrame
*
childFrame
:
mFrames
)
{
ConsiderChildOverflow
(
aDesiredSize
.
mOverflowAreas
childFrame
)
;
}
FinishReflowWithAbsoluteFrames
(
aPresContext
aDesiredSize
aReflowInput
aStatus
)
;
NS_FRAME_SET_TRUNCATION
(
aStatus
aReflowInput
aDesiredSize
)
if
(
MOZ_UNLIKELY
(
containerInfo
)
)
{
UpdateFlexLineAndItemInfo
(
*
containerInfo
lines
)
;
}
}
void
nsFlexContainerFrame
:
:
MoveFlexItemToFinalPosition
(
const
ReflowInput
&
aReflowInput
const
FlexItem
&
aItem
LogicalPoint
&
aFramePos
const
nsSize
&
aContainerSize
)
{
WritingMode
outerWM
=
aReflowInput
.
GetWritingMode
(
)
;
LogicalMargin
logicalOffsets
(
outerWM
)
;
if
(
NS_STYLE_POSITION_RELATIVE
=
=
aItem
.
Frame
(
)
-
>
StyleDisplay
(
)
-
>
mPosition
)
{
nsMargin
*
cachedOffsets
=
aItem
.
Frame
(
)
-
>
GetProperty
(
nsIFrame
:
:
ComputedOffsetProperty
(
)
)
;
MOZ_ASSERT
(
cachedOffsets
"
relpos
previously
-
reflowed
frame
should
'
ve
cached
its
offsets
"
)
;
logicalOffsets
=
LogicalMargin
(
outerWM
*
cachedOffsets
)
;
}
ReflowInput
:
:
ApplyRelativePositioning
(
aItem
.
Frame
(
)
outerWM
logicalOffsets
&
aFramePos
aContainerSize
)
;
aItem
.
Frame
(
)
-
>
SetPosition
(
outerWM
aFramePos
aContainerSize
)
;
PositionFrameView
(
aItem
.
Frame
(
)
)
;
PositionChildViews
(
aItem
.
Frame
(
)
)
;
}
void
nsFlexContainerFrame
:
:
ReflowFlexItem
(
nsPresContext
*
aPresContext
const
FlexboxAxisTracker
&
aAxisTracker
const
ReflowInput
&
aReflowInput
const
FlexItem
&
aItem
LogicalPoint
&
aFramePos
const
nsSize
&
aContainerSize
bool
aHasLineClampEllipsis
)
{
WritingMode
outerWM
=
aReflowInput
.
GetWritingMode
(
)
;
WritingMode
wm
=
aItem
.
Frame
(
)
-
>
GetWritingMode
(
)
;
LogicalSize
availSize
=
aReflowInput
.
ComputedSize
(
wm
)
;
availSize
.
BSize
(
wm
)
=
NS_UNCONSTRAINEDSIZE
;
ReflowInput
childReflowInput
(
aPresContext
aReflowInput
aItem
.
Frame
(
)
availSize
)
;
childReflowInput
.
mFlags
.
mInsideLineClamp
=
GetLineClampValue
(
)
!
=
0
;
childReflowInput
.
mFlags
.
mApplyLineClamp
=
!
childReflowInput
.
mFlags
.
mInsideLineClamp
&
&
aHasLineClampEllipsis
;
bool
didOverrideComputedISize
=
false
;
bool
didOverrideComputedBSize
=
false
;
if
(
aItem
.
IsInlineAxisMainAxis
(
)
)
{
childReflowInput
.
SetComputedISize
(
aItem
.
MainSize
(
)
)
;
didOverrideComputedISize
=
true
;
}
else
{
childReflowInput
.
SetComputedBSize
(
aItem
.
MainSize
(
)
)
;
didOverrideComputedBSize
=
true
;
if
(
aItem
.
TreatBSizeAsIndefinite
(
)
)
{
childReflowInput
.
mFlags
.
mTreatBSizeAsIndefinite
=
true
;
}
}
if
(
aItem
.
IsStretched
(
)
|
|
aItem
.
HasIntrinsicRatio
(
)
)
{
if
(
aItem
.
IsInlineAxisCrossAxis
(
)
)
{
childReflowInput
.
SetComputedISize
(
aItem
.
CrossSize
(
)
)
;
didOverrideComputedISize
=
true
;
}
else
{
childReflowInput
.
SetComputedBSize
(
aItem
.
CrossSize
(
)
)
;
didOverrideComputedBSize
=
true
;
}
}
if
(
aItem
.
IsStretched
(
)
&
&
aItem
.
IsBlockAxisCrossAxis
(
)
)
{
aItem
.
Frame
(
)
-
>
AddStateBits
(
NS_FRAME_CONTAINS_RELATIVE_BSIZE
)
;
}
if
(
aItem
.
HadMeasuringReflow
(
)
)
{
if
(
didOverrideComputedISize
)
{
childReflowInput
.
SetIResize
(
true
)
;
}
if
(
didOverrideComputedBSize
)
{
childReflowInput
.
SetBResize
(
true
)
;
childReflowInput
.
mFlags
.
mIsBResizeForPercentages
=
true
;
}
}
ReflowOutput
childDesiredSize
(
childReflowInput
)
;
nsReflowStatus
childReflowStatus
;
ReflowChild
(
aItem
.
Frame
(
)
aPresContext
childDesiredSize
childReflowInput
outerWM
aFramePos
aContainerSize
ReflowChildFlags
:
:
Default
childReflowStatus
)
;
MOZ_ASSERT
(
childReflowStatus
.
IsComplete
(
)
"
We
gave
flex
item
unconstrained
available
height
so
it
"
"
should
be
complete
"
)
;
aItem
.
Frame
(
)
-
>
SetSize
(
outerWM
childDesiredSize
.
Size
(
wm
)
.
ConvertTo
(
outerWM
wm
)
)
;
LogicalMargin
offsets
=
childReflowInput
.
ComputedLogicalOffsets
(
)
.
ConvertTo
(
outerWM
wm
)
;
ReflowInput
:
:
ApplyRelativePositioning
(
aItem
.
Frame
(
)
outerWM
offsets
&
aFramePos
aContainerSize
)
;
FinishReflowChild
(
aItem
.
Frame
(
)
aPresContext
childDesiredSize
&
childReflowInput
outerWM
aFramePos
aContainerSize
ReflowChildFlags
:
:
Default
)
;
aItem
.
SetAscent
(
childDesiredSize
.
BlockStartAscent
(
)
)
;
}
void
nsFlexContainerFrame
:
:
ReflowPlaceholders
(
nsPresContext
*
aPresContext
const
ReflowInput
&
aReflowInput
nsTArray
<
nsIFrame
*
>
&
aPlaceholders
const
LogicalPoint
&
aContentBoxOrigin
const
nsSize
&
aContainerSize
)
{
WritingMode
outerWM
=
aReflowInput
.
GetWritingMode
(
)
;
for
(
nsIFrame
*
placeholder
:
aPlaceholders
)
{
MOZ_ASSERT
(
placeholder
-
>
IsPlaceholderFrame
(
)
"
placeholders
array
should
only
contain
placeholder
frames
"
)
;
WritingMode
wm
=
placeholder
-
>
GetWritingMode
(
)
;
LogicalSize
availSize
=
aReflowInput
.
ComputedSize
(
wm
)
;
ReflowInput
childReflowInput
(
aPresContext
aReflowInput
placeholder
availSize
)
;
ReflowOutput
childDesiredSize
(
childReflowInput
)
;
nsReflowStatus
childReflowStatus
;
ReflowChild
(
placeholder
aPresContext
childDesiredSize
childReflowInput
outerWM
aContentBoxOrigin
aContainerSize
ReflowChildFlags
:
:
Default
childReflowStatus
)
;
FinishReflowChild
(
placeholder
aPresContext
childDesiredSize
&
childReflowInput
outerWM
aContentBoxOrigin
aContainerSize
ReflowChildFlags
:
:
Default
)
;
placeholder
-
>
AddStateBits
(
PLACEHOLDER_STATICPOS_NEEDS_CSSALIGN
)
;
}
}
nscoord
nsFlexContainerFrame
:
:
IntrinsicISize
(
gfxContext
*
aRenderingContext
IntrinsicISizeType
aType
)
{
nscoord
containerISize
=
0
;
const
nsStylePosition
*
stylePos
=
StylePosition
(
)
;
const
FlexboxAxisTracker
axisTracker
(
this
GetWritingMode
(
)
)
;
nscoord
mainGapSize
;
if
(
axisTracker
.
IsRowOriented
(
)
)
{
mainGapSize
=
nsLayoutUtils
:
:
ResolveGapToLength
(
stylePos
-
>
mColumnGap
NS_UNCONSTRAINEDSIZE
)
;
}
else
{
mainGapSize
=
nsLayoutUtils
:
:
ResolveGapToLength
(
stylePos
-
>
mRowGap
NS_UNCONSTRAINEDSIZE
)
;
}
const
bool
useMozBoxCollapseBehavior
=
ShouldUseMozBoxCollapseBehavior
(
StyleDisplay
(
)
)
;
bool
onFirstChild
=
true
;
for
(
nsIFrame
*
childFrame
:
mFrames
)
{
if
(
!
useMozBoxCollapseBehavior
|
|
(
StyleVisibility
:
:
Collapse
!
=
childFrame
-
>
StyleVisibility
(
)
-
>
mVisible
)
)
{
nscoord
childISize
=
nsLayoutUtils
:
:
IntrinsicForContainer
(
aRenderingContext
childFrame
aType
)
;
bool
isSingleLine
=
(
StyleFlexWrap
:
:
Nowrap
=
=
stylePos
-
>
mFlexWrap
)
;
if
(
axisTracker
.
IsRowOriented
(
)
&
&
(
isSingleLine
|
|
aType
=
=
nsLayoutUtils
:
:
PREF_ISIZE
)
)
{
containerISize
+
=
childISize
;
if
(
!
onFirstChild
)
{
containerISize
+
=
mainGapSize
;
}
onFirstChild
=
false
;
}
else
{
containerISize
=
std
:
:
max
(
containerISize
childISize
)
;
}
}
}
return
containerISize
;
}
nscoord
nsFlexContainerFrame
:
:
GetMinISize
(
gfxContext
*
aRenderingContext
)
{
DISPLAY_MIN_INLINE_SIZE
(
this
mCachedMinISize
)
;
if
(
mCachedMinISize
=
=
NS_INTRINSIC_ISIZE_UNKNOWN
)
{
mCachedMinISize
=
StyleDisplay
(
)
-
>
IsContainSize
(
)
?
0
:
IntrinsicISize
(
aRenderingContext
nsLayoutUtils
:
:
MIN_ISIZE
)
;
}
return
mCachedMinISize
;
}
nscoord
nsFlexContainerFrame
:
:
GetPrefISize
(
gfxContext
*
aRenderingContext
)
{
DISPLAY_PREF_INLINE_SIZE
(
this
mCachedPrefISize
)
;
if
(
mCachedPrefISize
=
=
NS_INTRINSIC_ISIZE_UNKNOWN
)
{
mCachedPrefISize
=
StyleDisplay
(
)
-
>
IsContainSize
(
)
?
0
:
IntrinsicISize
(
aRenderingContext
nsLayoutUtils
:
:
PREF_ISIZE
)
;
}
return
mCachedPrefISize
;
}
uint32_t
nsFlexContainerFrame
:
:
GetLineClampValue
(
)
const
{
if
(
!
HasAnyStateBits
(
NS_STATE_FLEX_IS_EMULATING_LEGACY_BOX
)
|
|
StyleXUL
(
)
-
>
mBoxOrient
!
=
StyleBoxOrient
:
:
Vertical
)
{
return
0
;
}
return
StyleDisplay
(
)
-
>
mLineClamp
;
}
