#
include
"
nsFlexContainerFrame
.
h
"
#
include
<
algorithm
>
#
include
"
gfxContext
.
h
"
#
include
"
mozilla
/
ComputedStyle
.
h
"
#
include
"
mozilla
/
CSSOrderAwareFrameIterator
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
WritingModes
.
h
"
#
include
"
nsBlockFrame
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCSSAnonBoxes
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsFieldSetFrame
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsPlaceholderFrame
.
h
"
#
include
"
nsPresContext
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
layout
;
using
FlexItem
=
nsFlexContainerFrame
:
:
FlexItem
;
using
FlexLine
=
nsFlexContainerFrame
:
:
FlexLine
;
using
FlexboxAxisTracker
=
nsFlexContainerFrame
:
:
FlexboxAxisTracker
;
using
StrutInfo
=
nsFlexContainerFrame
:
:
StrutInfo
;
using
CachedBAxisMeasurement
=
nsFlexContainerFrame
:
:
CachedBAxisMeasurement
;
static
mozilla
:
:
LazyLogModule
gFlexContainerLog
(
"
FlexContainer
"
)
;
#
define
FLEX_LOG
(
.
.
.
)
\
MOZ_LOG
(
gFlexContainerLog
LogLevel
:
:
Debug
(
__VA_ARGS__
)
)
;
#
define
FLEX_LOGV
(
.
.
.
)
\
MOZ_LOG
(
gFlexContainerLog
LogLevel
:
:
Verbose
(
__VA_ARGS__
)
)
;
static
inline
bool
IsDisplayValueLegacyBox
(
const
nsStyleDisplay
*
aStyleDisp
)
{
return
aStyleDisp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
WebkitBox
|
|
aStyleDisp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
WebkitInlineBox
|
|
aStyleDisp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
MozBox
|
|
aStyleDisp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
MozInlineBox
;
}
static
bool
IsLegacyBox
(
const
nsIFrame
*
aFlexContainer
)
{
MOZ_ASSERT
(
aFlexContainer
-
>
IsFlexContainerFrame
(
)
"
only
flex
containers
may
be
passed
to
this
function
"
)
;
return
aFlexContainer
-
>
HasAnyStateBits
(
NS_STATE_FLEX_IS_EMULATING_LEGACY_BOX
)
;
}
static
CSSOrderAwareFrameIterator
:
:
OrderState
OrderStateForIter
(
const
nsFlexContainerFrame
*
aFlexContainer
)
{
return
aFlexContainer
-
>
HasAnyStateBits
(
NS_STATE_FLEX_NORMAL_FLOW_CHILDREN_IN_CSS_ORDER
)
?
CSSOrderAwareFrameIterator
:
:
OrderState
:
:
eKnownOrdered
:
CSSOrderAwareFrameIterator
:
:
OrderState
:
:
eKnownUnordered
;
}
static
CSSOrderAwareFrameIterator
:
:
OrderingProperty
OrderingPropertyForIter
(
const
nsFlexContainerFrame
*
aFlexContainer
)
{
return
IsLegacyBox
(
aFlexContainer
)
?
CSSOrderAwareFrameIterator
:
:
OrderingProperty
:
:
eUseBoxOrdinalGroup
:
CSSOrderAwareFrameIterator
:
:
OrderingProperty
:
:
eUseOrder
;
}
static
StyleAlignFlags
ConvertLegacyStyleToAlignItems
(
const
nsStyleXUL
*
aStyleXUL
)
{
switch
(
aStyleXUL
-
>
mBoxAlign
)
{
case
StyleBoxAlign
:
:
Stretch
:
return
StyleAlignFlags
:
:
STRETCH
;
case
StyleBoxAlign
:
:
Start
:
return
StyleAlignFlags
:
:
FLEX_START
;
case
StyleBoxAlign
:
:
Center
:
return
StyleAlignFlags
:
:
CENTER
;
case
StyleBoxAlign
:
:
Baseline
:
return
StyleAlignFlags
:
:
BASELINE
;
case
StyleBoxAlign
:
:
End
:
return
StyleAlignFlags
:
:
FLEX_END
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
mBoxAlign
enum
value
"
)
;
return
StyleAlignFlags
:
:
STRETCH
;
}
static
StyleContentDistribution
ConvertLegacyStyleToJustifyContent
(
const
nsStyleXUL
*
aStyleXUL
)
{
switch
(
aStyleXUL
-
>
mBoxPack
)
{
case
StyleBoxPack
:
:
Start
:
return
{
StyleAlignFlags
:
:
FLEX_START
}
;
case
StyleBoxPack
:
:
Center
:
return
{
StyleAlignFlags
:
:
CENTER
}
;
case
StyleBoxPack
:
:
End
:
return
{
StyleAlignFlags
:
:
FLEX_END
}
;
case
StyleBoxPack
:
:
Justify
:
return
{
StyleAlignFlags
:
:
SPACE_BETWEEN
}
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unrecognized
mBoxPack
enum
value
"
)
;
return
{
StyleAlignFlags
:
:
FLEX_START
}
;
}
static
nscoord
PhysicalCoordFromFlexRelativeCoord
(
nscoord
aFlexRelativeCoord
nscoord
aContainerSize
mozilla
:
:
Side
aStartSide
)
{
if
(
aStartSide
=
=
eSideLeft
|
|
aStartSide
=
=
eSideTop
)
{
return
aFlexRelativeCoord
;
}
return
aContainerSize
-
aFlexRelativeCoord
;
}
static
nscoord
AddChecked
(
nscoord
aFirst
nscoord
aSecond
)
{
CheckedInt
<
nscoord
>
checkedResult
=
CheckedInt
<
nscoord
>
(
aFirst
)
+
aSecond
;
return
checkedResult
.
isValid
(
)
?
checkedResult
.
value
(
)
:
nscoord_MAX
;
}
static
inline
bool
IsAutoOrEnumOnBSize
(
const
StyleSize
&
aSize
bool
aIsInline
)
{
return
aSize
.
IsAuto
(
)
|
|
(
!
aIsInline
&
&
aSize
.
IsExtremumLength
(
)
)
;
}
#
define
GET_MAIN_COMPONENT_LOGICAL
(
axisTracker_
wm_
isize_
bsize_
)
\
wm_
.
IsOrthogonalTo
(
(
axisTracker_
)
.
GetWritingMode
(
)
)
!
=
\
(
axisTracker_
)
.
IsRowOriented
(
)
\
?
(
isize_
)
\
:
(
bsize_
)
#
define
GET_CROSS_COMPONENT_LOGICAL
(
axisTracker_
wm_
isize_
bsize_
)
\
wm_
.
IsOrthogonalTo
(
(
axisTracker_
)
.
GetWritingMode
(
)
)
!
=
\
(
axisTracker_
)
.
IsRowOriented
(
)
\
?
(
bsize_
)
\
:
(
isize_
)
class
MOZ_STACK_CLASS
nsFlexContainerFrame
:
:
FlexboxAxisTracker
{
public
:
explicit
FlexboxAxisTracker
(
const
nsFlexContainerFrame
*
aFlexContainer
)
;
LogicalAxis
MainAxis
(
)
const
{
return
IsRowOriented
(
)
?
eLogicalAxisInline
:
eLogicalAxisBlock
;
}
LogicalAxis
CrossAxis
(
)
const
{
return
IsRowOriented
(
)
?
eLogicalAxisBlock
:
eLogicalAxisInline
;
}
LogicalSide
MainAxisStartSide
(
)
const
;
LogicalSide
MainAxisEndSide
(
)
const
{
return
GetOppositeSide
(
MainAxisStartSide
(
)
)
;
}
LogicalSide
CrossAxisStartSide
(
)
const
;
LogicalSide
CrossAxisEndSide
(
)
const
{
return
GetOppositeSide
(
CrossAxisStartSide
(
)
)
;
}
mozilla
:
:
Side
MainAxisPhysicalStartSide
(
)
const
{
return
mWM
.
PhysicalSide
(
MainAxisStartSide
(
)
)
;
}
mozilla
:
:
Side
MainAxisPhysicalEndSide
(
)
const
{
return
mWM
.
PhysicalSide
(
MainAxisEndSide
(
)
)
;
}
mozilla
:
:
Side
CrossAxisPhysicalStartSide
(
)
const
{
return
mWM
.
PhysicalSide
(
CrossAxisStartSide
(
)
)
;
}
mozilla
:
:
Side
CrossAxisPhysicalEndSide
(
)
const
{
return
mWM
.
PhysicalSide
(
CrossAxisEndSide
(
)
)
;
}
WritingMode
GetWritingMode
(
)
const
{
return
mWM
;
}
bool
IsMainAxisReversed
(
)
const
{
return
mAxisInfo
.
mIsMainAxisReversed
;
}
bool
IsCrossAxisReversed
(
)
const
{
return
mAxisInfo
.
mIsCrossAxisReversed
;
}
bool
IsRowOriented
(
)
const
{
return
mAxisInfo
.
mIsRowOriented
;
}
bool
IsColumnOriented
(
)
const
{
return
!
IsRowOriented
(
)
;
}
nscoord
MainComponent
(
const
LogicalSize
&
aSize
)
const
{
return
IsRowOriented
(
)
?
aSize
.
ISize
(
mWM
)
:
aSize
.
BSize
(
mWM
)
;
}
int32_t
MainComponent
(
const
LayoutDeviceIntSize
&
aIntSize
)
const
{
return
IsMainAxisHorizontal
(
)
?
aIntSize
.
width
:
aIntSize
.
height
;
}
nscoord
CrossComponent
(
const
LogicalSize
&
aSize
)
const
{
return
IsRowOriented
(
)
?
aSize
.
BSize
(
mWM
)
:
aSize
.
ISize
(
mWM
)
;
}
int32_t
CrossComponent
(
const
LayoutDeviceIntSize
&
aIntSize
)
const
{
return
IsMainAxisHorizontal
(
)
?
aIntSize
.
height
:
aIntSize
.
width
;
}
nscoord
MarginSizeInMainAxis
(
const
LogicalMargin
&
aMargin
)
const
{
return
IsRowOriented
(
)
?
aMargin
.
IStartEnd
(
mWM
)
:
aMargin
.
BStartEnd
(
mWM
)
;
}
nscoord
MarginSizeInCrossAxis
(
const
LogicalMargin
&
aMargin
)
const
{
return
IsRowOriented
(
)
?
aMargin
.
BStartEnd
(
mWM
)
:
aMargin
.
IStartEnd
(
mWM
)
;
}
LogicalPoint
LogicalPointFromFlexRelativePoint
(
nscoord
aMainCoord
nscoord
aCrossCoord
nscoord
aContainerMainSize
nscoord
aContainerCrossSize
)
const
{
nscoord
logicalCoordInMainAxis
=
IsMainAxisReversed
(
)
?
aContainerMainSize
-
aMainCoord
:
aMainCoord
;
nscoord
logicalCoordInCrossAxis
=
IsCrossAxisReversed
(
)
?
aContainerCrossSize
-
aCrossCoord
:
aCrossCoord
;
return
IsRowOriented
(
)
?
LogicalPoint
(
mWM
logicalCoordInMainAxis
logicalCoordInCrossAxis
)
:
LogicalPoint
(
mWM
logicalCoordInCrossAxis
logicalCoordInMainAxis
)
;
}
LogicalSize
LogicalSizeFromFlexRelativeSizes
(
nscoord
aMainSize
nscoord
aCrossSize
)
const
{
return
IsRowOriented
(
)
?
LogicalSize
(
mWM
aMainSize
aCrossSize
)
:
LogicalSize
(
mWM
aCrossSize
aMainSize
)
;
}
bool
IsMainAxisHorizontal
(
)
const
{
return
IsRowOriented
(
)
!
=
mWM
.
IsVertical
(
)
;
}
FlexboxAxisTracker
(
const
FlexboxAxisTracker
&
)
=
delete
;
FlexboxAxisTracker
&
operator
=
(
const
FlexboxAxisTracker
&
)
=
delete
;
private
:
const
WritingMode
mWM
;
const
FlexboxAxisInfo
mAxisInfo
;
}
;
class
nsFlexContainerFrame
:
:
FlexItem
final
{
public
:
FlexItem
(
ReflowInput
&
aFlexItemReflowInput
float
aFlexGrow
float
aFlexShrink
nscoord
aFlexBaseSize
nscoord
aMainMinSize
nscoord
aMainMaxSize
nscoord
aTentativeCrossSize
nscoord
aCrossMinSize
nscoord
aCrossMaxSize
const
FlexboxAxisTracker
&
aAxisTracker
)
;
FlexItem
(
nsIFrame
*
aChildFrame
nscoord
aCrossSize
WritingMode
aContainerWM
const
FlexboxAxisTracker
&
aAxisTracker
)
;
FlexItem
CloneFor
(
nsIFrame
*
const
aContinuation
)
const
{
MOZ_ASSERT
(
Frame
(
)
=
=
aContinuation
-
>
FirstInFlow
(
)
"
aContinuation
should
be
in
aItem
'
s
continuation
chain
!
"
)
;
FlexItem
item
(
*
this
)
;
item
.
mFrame
=
aContinuation
;
return
item
;
}
nsIFrame
*
Frame
(
)
const
{
return
mFrame
;
}
nscoord
FlexBaseSize
(
)
const
{
return
mFlexBaseSize
;
}
nscoord
MainMinSize
(
)
const
{
MOZ_ASSERT
(
!
mNeedsMinSizeAutoResolution
"
Someone
'
s
using
an
unresolved
'
auto
'
main
min
-
size
"
)
;
return
mMainMinSize
;
}
nscoord
MainMaxSize
(
)
const
{
return
mMainMaxSize
;
}
nscoord
MainSize
(
)
const
{
return
mMainSize
;
}
nscoord
MainPosition
(
)
const
{
return
mMainPosn
;
}
nscoord
CrossMinSize
(
)
const
{
return
mCrossMinSize
;
}
nscoord
CrossMaxSize
(
)
const
{
return
mCrossMaxSize
;
}
nscoord
CrossSize
(
)
const
{
return
mCrossSize
;
}
nscoord
CrossPosition
(
)
const
{
return
mCrossPosn
;
}
nscoord
ResolvedAscent
(
bool
aUseFirstBaseline
)
const
{
if
(
mAscent
=
=
ReflowOutput
:
:
ASK_FOR_BASELINE
)
{
bool
found
=
aUseFirstBaseline
?
nsLayoutUtils
:
:
GetFirstLineBaseline
(
mWM
mFrame
&
mAscent
)
:
nsLayoutUtils
:
:
GetLastLineBaseline
(
mWM
mFrame
&
mAscent
)
;
if
(
!
found
)
{
mAscent
=
mFrame
-
>
SynthesizeBaselineBOffsetFromBorderBox
(
mWM
BaselineSharingGroup
:
:
First
)
;
}
}
return
mAscent
;
}
nscoord
OuterMainSize
(
)
const
{
return
mMainSize
+
MarginBorderPaddingSizeInMainAxis
(
)
;
}
nscoord
OuterCrossSize
(
)
const
{
return
mCrossSize
+
MarginBorderPaddingSizeInCrossAxis
(
)
;
}
nscoord
BaselineOffsetFromOuterCrossEdge
(
mozilla
:
:
Side
aStartSide
bool
aUseFirstLineBaseline
)
const
;
float
ShareOfWeightSoFar
(
)
const
{
return
mShareOfWeightSoFar
;
}
bool
IsFrozen
(
)
const
{
return
mIsFrozen
;
}
bool
HadMinViolation
(
)
const
{
MOZ_ASSERT
(
!
mIsFrozen
"
min
violation
has
no
meaning
for
frozen
items
.
"
)
;
return
mHadMinViolation
;
}
bool
HadMaxViolation
(
)
const
{
MOZ_ASSERT
(
!
mIsFrozen
"
max
violation
has
no
meaning
for
frozen
items
.
"
)
;
return
mHadMaxViolation
;
}
bool
WasMinClamped
(
)
const
{
MOZ_ASSERT
(
mIsFrozen
"
min
clamping
has
no
meaning
for
unfrozen
items
.
"
)
;
return
mHadMinViolation
;
}
bool
WasMaxClamped
(
)
const
{
MOZ_ASSERT
(
mIsFrozen
"
max
clamping
has
no
meaning
for
unfrozen
items
.
"
)
;
return
mHadMaxViolation
;
}
bool
HadMeasuringReflow
(
)
const
{
return
mHadMeasuringReflow
;
}
bool
IsCrossSizeAuto
(
)
const
;
bool
IsStretched
(
)
const
{
return
mIsStretched
;
}
bool
NeedsMinSizeAutoResolution
(
)
const
{
return
mNeedsMinSizeAutoResolution
;
}
bool
HasAnyAutoMargin
(
)
const
{
return
mHasAnyAutoMargin
;
}
bool
IsStrut
(
)
const
{
return
mIsStrut
;
}
LogicalAxis
MainAxis
(
)
const
{
return
mMainAxis
;
}
LogicalAxis
CrossAxis
(
)
const
{
return
GetOrthogonalAxis
(
mMainAxis
)
;
}
bool
IsInlineAxisMainAxis
(
)
const
{
return
mIsInlineAxisMainAxis
;
}
bool
IsInlineAxisCrossAxis
(
)
const
{
return
!
mIsInlineAxisMainAxis
;
}
bool
IsBlockAxisMainAxis
(
)
const
{
return
!
mIsInlineAxisMainAxis
;
}
bool
IsBlockAxisCrossAxis
(
)
const
{
return
mIsInlineAxisMainAxis
;
}
WritingMode
GetWritingMode
(
)
const
{
return
mWM
;
}
StyleAlignSelf
AlignSelf
(
)
const
{
return
mAlignSelf
;
}
StyleAlignFlags
AlignSelfFlags
(
)
const
{
return
mAlignSelfFlags
;
}
float
GetFlexFactor
(
bool
aIsUsingFlexGrow
)
{
MOZ_ASSERT
(
!
IsFrozen
(
)
"
shouldn
'
t
need
flex
factor
after
item
is
frozen
"
)
;
return
aIsUsingFlexGrow
?
mFlexGrow
:
mFlexShrink
;
}
float
GetWeight
(
bool
aIsUsingFlexGrow
)
{
MOZ_ASSERT
(
!
IsFrozen
(
)
"
shouldn
'
t
need
weight
after
item
is
frozen
"
)
;
if
(
aIsUsingFlexGrow
)
{
return
mFlexGrow
;
}
if
(
mFlexBaseSize
=
=
0
)
{
return
0
.
0f
;
}
return
mFlexShrink
*
mFlexBaseSize
;
}
bool
TreatBSizeAsIndefinite
(
)
const
{
return
mTreatBSizeAsIndefinite
;
}
const
AspectRatio
&
IntrinsicRatio
(
)
const
{
return
mIntrinsicRatio
;
}
bool
HasIntrinsicRatio
(
)
const
{
return
!
!
mIntrinsicRatio
;
}
LogicalMargin
Margin
(
)
const
{
return
mMargin
;
}
nsMargin
PhysicalMargin
(
)
const
{
return
mMargin
.
GetPhysicalMargin
(
mCBWM
)
;
}
nscoord
GetMarginComponentForSide
(
LogicalSide
aSide
)
const
{
return
mMargin
.
Side
(
aSide
mCBWM
)
;
}
nscoord
MarginSizeInMainAxis
(
)
const
{
return
mMargin
.
StartEnd
(
MainAxis
(
)
mCBWM
)
;
}
nscoord
MarginSizeInCrossAxis
(
)
const
{
return
mMargin
.
StartEnd
(
CrossAxis
(
)
mCBWM
)
;
}
LogicalMargin
BorderPadding
(
)
const
{
return
mBorderPadding
;
}
nscoord
BorderPaddingSizeInMainAxis
(
)
const
{
return
mBorderPadding
.
StartEnd
(
MainAxis
(
)
mCBWM
)
;
}
nscoord
BorderPaddingSizeInCrossAxis
(
)
const
{
return
mBorderPadding
.
StartEnd
(
CrossAxis
(
)
mCBWM
)
;
}
nscoord
MarginBorderPaddingSizeInMainAxis
(
)
const
{
return
MarginSizeInMainAxis
(
)
+
BorderPaddingSizeInMainAxis
(
)
;
}
nscoord
MarginBorderPaddingSizeInCrossAxis
(
)
const
{
return
MarginSizeInCrossAxis
(
)
+
BorderPaddingSizeInCrossAxis
(
)
;
}
void
UpdateMainMinSize
(
nscoord
aNewMinSize
)
{
NS_ASSERTION
(
aNewMinSize
>
=
0
"
How
did
we
end
up
with
a
negative
min
-
size
?
"
)
;
MOZ_ASSERT
(
mMainMaxSize
>
=
aNewMinSize
"
Should
only
use
this
function
for
resolving
min
-
size
:
auto
"
"
and
main
max
-
size
should
be
an
upper
-
bound
for
resolved
val
"
)
;
MOZ_ASSERT
(
mNeedsMinSizeAutoResolution
&
&
(
mMainMinSize
=
=
0
|
|
mFrame
-
>
IsThemed
(
mFrame
-
>
StyleDisplay
(
)
)
)
"
Should
only
use
this
function
for
resolving
min
-
size
:
auto
"
"
so
we
shouldn
'
t
already
have
a
nonzero
min
-
size
established
"
"
(
unless
it
'
s
a
themed
-
widget
-
imposed
minimum
size
)
"
)
;
if
(
aNewMinSize
>
mMainMinSize
)
{
mMainMinSize
=
aNewMinSize
;
mMainSize
=
std
:
:
max
(
mMainSize
aNewMinSize
)
;
}
mNeedsMinSizeAutoResolution
=
false
;
}
void
SetFlexBaseSizeAndMainSize
(
nscoord
aNewFlexBaseSize
)
{
MOZ_ASSERT
(
!
mIsFrozen
|
|
mFlexBaseSize
=
=
NS_UNCONSTRAINEDSIZE
"
flex
base
size
shouldn
'
t
change
after
we
'
re
frozen
"
"
(
unless
we
'
re
just
resolving
an
intrinsic
size
)
"
)
;
mFlexBaseSize
=
aNewFlexBaseSize
;
mMainSize
=
NS_CSS_MINMAX
(
mFlexBaseSize
mMainMinSize
mMainMaxSize
)
;
}
void
SetMainSize
(
nscoord
aNewMainSize
)
{
MOZ_ASSERT
(
!
mIsFrozen
"
main
size
shouldn
'
t
change
after
we
'
re
frozen
"
)
;
mMainSize
=
aNewMainSize
;
}
void
SetShareOfWeightSoFar
(
float
aNewShare
)
{
MOZ_ASSERT
(
!
mIsFrozen
|
|
aNewShare
=
=
0
.
0f
"
shouldn
'
t
be
giving
this
item
any
share
of
the
weight
"
"
after
it
'
s
frozen
"
)
;
mShareOfWeightSoFar
=
aNewShare
;
}
void
Freeze
(
)
{
mIsFrozen
=
true
;
mHadMinViolation
=
false
;
mHadMaxViolation
=
false
;
}
void
SetHadMinViolation
(
)
{
MOZ_ASSERT
(
!
mIsFrozen
"
shouldn
'
t
be
changing
main
size
&
having
violations
"
"
after
we
'
re
frozen
"
)
;
mHadMinViolation
=
true
;
}
void
SetHadMaxViolation
(
)
{
MOZ_ASSERT
(
!
mIsFrozen
"
shouldn
'
t
be
changing
main
size
&
having
violations
"
"
after
we
'
re
frozen
"
)
;
mHadMaxViolation
=
true
;
}
void
ClearViolationFlags
(
)
{
MOZ_ASSERT
(
!
mIsFrozen
"
shouldn
'
t
be
altering
violation
flags
after
we
'
re
"
"
frozen
"
)
;
mHadMinViolation
=
mHadMaxViolation
=
false
;
}
void
SetWasMinClamped
(
)
{
MOZ_ASSERT
(
!
mHadMinViolation
&
&
!
mHadMaxViolation
"
only
clamp
once
"
)
;
MOZ_ASSERT
(
mIsFrozen
"
shouldn
'
t
set
clamping
state
when
we
are
unfrozen
"
)
;
mHadMinViolation
=
true
;
}
void
SetWasMaxClamped
(
)
{
MOZ_ASSERT
(
!
mHadMinViolation
&
&
!
mHadMaxViolation
"
only
clamp
once
"
)
;
MOZ_ASSERT
(
mIsFrozen
"
shouldn
'
t
set
clamping
state
when
we
are
unfrozen
"
)
;
mHadMaxViolation
=
true
;
}
void
SetMainPosition
(
nscoord
aPosn
)
{
MOZ_ASSERT
(
mIsFrozen
"
main
size
should
be
resolved
before
this
"
)
;
mMainPosn
=
aPosn
;
}
void
SetCrossSize
(
nscoord
aCrossSize
)
{
MOZ_ASSERT
(
!
mIsStretched
"
Cross
size
shouldn
'
t
be
modified
after
it
'
s
been
stretched
"
)
;
mCrossSize
=
aCrossSize
;
}
void
SetCrossPosition
(
nscoord
aPosn
)
{
MOZ_ASSERT
(
mIsFrozen
"
main
size
should
be
resolved
before
this
"
)
;
mCrossPosn
=
aPosn
;
}
void
SetAscent
(
nscoord
aAscent
)
const
{
mAscent
=
aAscent
;
}
void
SetHadMeasuringReflow
(
)
{
mHadMeasuringReflow
=
true
;
}
void
SetIsStretched
(
)
{
MOZ_ASSERT
(
mIsFrozen
"
main
size
should
be
resolved
before
this
"
)
;
mIsStretched
=
true
;
}
void
SetMarginComponentForSide
(
LogicalSide
aSide
nscoord
aLength
)
{
MOZ_ASSERT
(
mIsFrozen
"
main
size
should
be
resolved
before
this
"
)
;
mMargin
.
Side
(
aSide
mCBWM
)
=
aLength
;
}
void
ResolveStretchedCrossSize
(
nscoord
aLineCrossSize
)
;
uint32_t
NumAutoMarginsInMainAxis
(
)
const
{
return
NumAutoMarginsInAxis
(
MainAxis
(
)
)
;
}
;
uint32_t
NumAutoMarginsInCrossAxis
(
)
const
{
return
NumAutoMarginsInAxis
(
CrossAxis
(
)
)
;
}
;
bool
CanMainSizeInfluenceCrossSize
(
)
const
;
bool
NeedsFinalReflow
(
const
nscoord
aAvailableBSizeForItem
)
const
;
nsBlockFrame
*
BlockFrame
(
)
const
;
protected
:
void
CheckForMinSizeAuto
(
const
ReflowInput
&
aFlexItemReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
)
;
uint32_t
NumAutoMarginsInAxis
(
LogicalAxis
aAxis
)
const
;
nsIFrame
*
mFrame
=
nullptr
;
float
mFlexGrow
=
0
.
0f
;
float
mFlexShrink
=
0
.
0f
;
AspectRatio
mIntrinsicRatio
;
WritingMode
mWM
;
WritingMode
mCBWM
;
LogicalAxis
mMainAxis
;
LogicalMargin
mBorderPadding
;
LogicalMargin
mMargin
;
nscoord
mFlexBaseSize
=
0
;
nscoord
mMainMinSize
=
0
;
nscoord
mMainMaxSize
=
0
;
nscoord
mCrossMinSize
=
0
;
nscoord
mCrossMaxSize
=
0
;
nscoord
mMainSize
=
0
;
nscoord
mMainPosn
=
0
;
nscoord
mCrossSize
=
0
;
nscoord
mCrossPosn
=
0
;
mutable
nscoord
mAscent
=
ReflowOutput
:
:
ASK_FOR_BASELINE
;
float
mShareOfWeightSoFar
=
0
.
0f
;
bool
mIsFrozen
=
false
;
bool
mHadMinViolation
=
false
;
bool
mHadMaxViolation
=
false
;
bool
mHadMeasuringReflow
=
false
;
bool
mIsStretched
=
false
;
bool
mIsStrut
=
false
;
bool
mIsInlineAxisMainAxis
=
true
;
bool
mNeedsMinSizeAutoResolution
=
false
;
bool
mTreatBSizeAsIndefinite
=
false
;
bool
mHasAnyAutoMargin
=
false
;
StyleAlignSelf
mAlignSelf
{
StyleAlignFlags
:
:
AUTO
}
;
StyleAlignFlags
mAlignSelfFlags
{
0
}
;
}
;
class
nsFlexContainerFrame
:
:
FlexLine
final
{
public
:
explicit
FlexLine
(
nscoord
aMainGapSize
)
:
mMainGapSize
(
aMainGapSize
)
{
}
nscoord
SumOfGaps
(
)
const
{
return
NumItems
(
)
>
0
?
(
NumItems
(
)
-
1
)
*
mMainGapSize
:
0
;
}
nscoord
TotalOuterHypotheticalMainSize
(
)
const
{
return
mTotalOuterHypotheticalMainSize
;
}
FlexItem
&
FirstItem
(
)
{
return
mItems
[
0
]
;
}
const
FlexItem
&
FirstItem
(
)
const
{
return
mItems
[
0
]
;
}
FlexItem
&
LastItem
(
)
{
return
mItems
.
LastElement
(
)
;
}
const
FlexItem
&
LastItem
(
)
const
{
return
mItems
.
LastElement
(
)
;
}
bool
IsEmpty
(
)
const
{
return
mItems
.
IsEmpty
(
)
;
}
uint32_t
NumItems
(
)
const
{
return
mItems
.
Length
(
)
;
}
nsTArray
<
FlexItem
>
&
Items
(
)
{
return
mItems
;
}
const
nsTArray
<
FlexItem
>
&
Items
(
)
const
{
return
mItems
;
}
void
AddLastItemToMainSizeTotals
(
)
{
const
FlexItem
&
lastItem
=
Items
(
)
.
LastElement
(
)
;
if
(
lastItem
.
IsFrozen
(
)
)
{
mNumFrozenItems
+
+
;
}
mTotalItemMBP
=
AddChecked
(
mTotalItemMBP
lastItem
.
MarginBorderPaddingSizeInMainAxis
(
)
)
;
mTotalOuterHypotheticalMainSize
=
AddChecked
(
mTotalOuterHypotheticalMainSize
lastItem
.
OuterMainSize
(
)
)
;
if
(
NumItems
(
)
>
=
2
)
{
mTotalOuterHypotheticalMainSize
=
AddChecked
(
mTotalOuterHypotheticalMainSize
mMainGapSize
)
;
}
}
void
ComputeCrossSizeAndBaseline
(
const
FlexboxAxisTracker
&
aAxisTracker
)
;
nscoord
LineCrossSize
(
)
const
{
return
mLineCrossSize
;
}
void
SetLineCrossSize
(
nscoord
aLineCrossSize
)
{
mLineCrossSize
=
aLineCrossSize
;
}
nscoord
FirstBaselineOffset
(
)
const
{
return
mFirstBaselineOffset
;
}
nscoord
LastBaselineOffset
(
)
const
{
return
mLastBaselineOffset
;
}
nscoord
MainGapSize
(
)
const
{
return
mMainGapSize
;
}
void
ResolveFlexibleLengths
(
nscoord
aFlexContainerMainSize
ComputedFlexLineInfo
*
aLineInfo
)
;
void
PositionItemsInMainAxis
(
const
StyleContentDistribution
&
aJustifyContent
nscoord
aContentBoxMainSize
const
FlexboxAxisTracker
&
aAxisTracker
)
;
void
PositionItemsInCrossAxis
(
nscoord
aLineStartPosition
const
FlexboxAxisTracker
&
aAxisTracker
)
;
private
:
void
FreezeItemsEarly
(
bool
aIsUsingFlexGrow
ComputedFlexLineInfo
*
aLineInfo
)
;
void
FreezeOrRestoreEachFlexibleSize
(
const
nscoord
aTotalViolation
bool
aIsFinalIteration
)
;
nsTArray
<
FlexItem
>
mItems
;
uint32_t
mNumFrozenItems
=
0
;
nscoord
mTotalItemMBP
=
0
;
nscoord
mTotalOuterHypotheticalMainSize
=
0
;
nscoord
mLineCrossSize
=
0
;
nscoord
mFirstBaselineOffset
=
nscoord_MIN
;
nscoord
mLastBaselineOffset
=
nscoord_MIN
;
const
nscoord
mMainGapSize
;
}
;
struct
nsFlexContainerFrame
:
:
StrutInfo
{
StrutInfo
(
uint32_t
aItemIdx
nscoord
aStrutCrossSize
)
:
mItemIdx
(
aItemIdx
)
mStrutCrossSize
(
aStrutCrossSize
)
{
}
uint32_t
mItemIdx
;
nscoord
mStrutCrossSize
;
}
;
struct
nsFlexContainerFrame
:
:
SharedFlexData
{
nsTArray
<
FlexLine
>
mLines
;
nscoord
mContentBoxMainSize
=
NS_UNCONSTRAINEDSIZE
;
nscoord
mContentBoxCrossSize
=
NS_UNCONSTRAINEDSIZE
;
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
Prop
SharedFlexData
)
}
;
class
nsFlexContainerFrame
:
:
FlexItemIterator
final
{
public
:
explicit
FlexItemIterator
(
const
nsTArray
<
FlexLine
>
&
aLines
)
:
mLineIter
(
aLines
.
begin
(
)
)
mLineIterEnd
(
aLines
.
end
(
)
)
mItemIter
(
mLineIter
-
>
Items
(
)
.
begin
(
)
)
mItemIterEnd
(
mLineIter
-
>
Items
(
)
.
end
(
)
)
{
MOZ_ASSERT
(
mLineIter
!
=
mLineIterEnd
"
Flex
container
should
have
at
least
one
FlexLine
!
"
)
;
if
(
mItemIter
=
=
mItemIterEnd
)
{
+
+
mLineIter
;
MOZ_ASSERT
(
AtEnd
(
)
)
;
}
}
void
Next
(
)
{
MOZ_ASSERT
(
!
AtEnd
(
)
)
;
+
+
mItemIter
;
if
(
mItemIter
=
=
mItemIterEnd
)
{
+
+
mLineIter
;
if
(
mLineIter
!
=
mLineIterEnd
)
{
mItemIter
=
mLineIter
-
>
Items
(
)
.
begin
(
)
;
mItemIterEnd
=
mLineIter
-
>
Items
(
)
.
end
(
)
;
MOZ_ASSERT
(
mItemIter
!
=
mItemIterEnd
"
Why
do
we
have
a
FlexLine
with
no
FlexItem
?
"
)
;
}
}
}
bool
AtEnd
(
)
const
{
MOZ_ASSERT
(
(
mLineIter
=
=
mLineIterEnd
&
&
mItemIter
=
=
mItemIterEnd
)
|
|
(
mLineIter
!
=
mLineIterEnd
&
&
mItemIter
!
=
mItemIterEnd
)
"
Line
&
item
iterators
should
agree
on
whether
we
'
re
at
the
end
!
"
)
;
return
mLineIter
=
=
mLineIterEnd
;
}
const
FlexItem
&
operator
*
(
)
const
{
MOZ_ASSERT
(
!
AtEnd
(
)
)
;
return
mItemIter
.
operator
*
(
)
;
}
const
FlexItem
*
operator
-
>
(
)
const
{
MOZ_ASSERT
(
!
AtEnd
(
)
)
;
return
mItemIter
.
operator
-
>
(
)
;
}
private
:
nsTArray
<
FlexLine
>
:
:
const_iterator
mLineIter
;
nsTArray
<
FlexLine
>
:
:
const_iterator
mLineIterEnd
;
nsTArray
<
FlexItem
>
:
:
const_iterator
mItemIter
;
nsTArray
<
FlexItem
>
:
:
const_iterator
mItemIterEnd
;
}
;
static
void
BuildStrutInfoFromCollapsedItems
(
const
nsTArray
<
FlexLine
>
&
aLines
nsTArray
<
StrutInfo
>
&
aStruts
)
{
MOZ_ASSERT
(
aStruts
.
IsEmpty
(
)
"
We
should
only
build
up
StrutInfo
once
per
reflow
so
"
"
aStruts
should
be
empty
when
this
is
called
"
)
;
uint32_t
itemIdxInContainer
=
0
;
for
(
const
FlexLine
&
line
:
aLines
)
{
for
(
const
FlexItem
&
item
:
line
.
Items
(
)
)
{
if
(
StyleVisibility
:
:
Collapse
=
=
item
.
Frame
(
)
-
>
StyleVisibility
(
)
-
>
mVisible
)
{
aStruts
.
AppendElement
(
StrutInfo
(
itemIdxInContainer
line
.
LineCrossSize
(
)
)
)
;
}
itemIdxInContainer
+
+
;
}
}
}
static
mozilla
:
:
StyleAlignFlags
SimplifyAlignOrJustifyContentForOneItem
(
const
StyleContentDistribution
&
aAlignmentVal
bool
aIsAlign
)
{
StyleAlignFlags
specified
=
aAlignmentVal
.
primary
;
specified
&
=
~
StyleAlignFlags
:
:
FLAG_BITS
;
if
(
specified
=
=
StyleAlignFlags
:
:
NORMAL
)
{
specified
=
StyleAlignFlags
:
:
STRETCH
;
}
if
(
!
aIsAlign
&
&
specified
=
=
StyleAlignFlags
:
:
STRETCH
)
{
return
StyleAlignFlags
:
:
FLEX_START
;
}
if
(
specified
=
=
StyleAlignFlags
:
:
SPACE_BETWEEN
)
{
return
StyleAlignFlags
:
:
START
;
}
if
(
specified
=
=
StyleAlignFlags
:
:
SPACE_AROUND
|
|
specified
=
=
StyleAlignFlags
:
:
SPACE_EVENLY
)
{
return
StyleAlignFlags
:
:
CENTER
;
}
return
specified
;
}
bool
nsFlexContainerFrame
:
:
DrainSelfOverflowList
(
)
{
return
DrainAndMergeSelfOverflowList
(
)
;
}
void
nsFlexContainerFrame
:
:
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
{
NoteNewChildren
(
aListID
aFrameList
)
;
nsContainerFrame
:
:
AppendFrames
(
aListID
aFrameList
)
;
}
void
nsFlexContainerFrame
:
:
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
const
nsLineList
:
:
iterator
*
aPrevFrameLine
nsFrameList
&
aFrameList
)
{
NoteNewChildren
(
aListID
aFrameList
)
;
nsContainerFrame
:
:
InsertFrames
(
aListID
aPrevFrame
aPrevFrameLine
aFrameList
)
;
}
void
nsFlexContainerFrame
:
:
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
{
MOZ_ASSERT
(
aListID
=
=
kPrincipalList
"
unexpected
child
list
"
)
;
#
ifdef
DEBUG
SetDidPushItemsBitIfNeeded
(
aListID
aOldFrame
)
;
#
endif
nsContainerFrame
:
:
RemoveFrame
(
aListID
aOldFrame
)
;
}
StyleAlignFlags
nsFlexContainerFrame
:
:
CSSAlignmentForAbsPosChild
(
const
ReflowInput
&
aChildRI
LogicalAxis
aLogicalAxis
)
const
{
const
FlexboxAxisTracker
axisTracker
(
this
)
;
const
bool
isMainAxis
=
(
axisTracker
.
IsRowOriented
(
)
=
=
(
aLogicalAxis
=
=
eLogicalAxisInline
)
)
;
const
nsStylePosition
*
containerStylePos
=
StylePosition
(
)
;
const
bool
isAxisReversed
=
isMainAxis
?
axisTracker
.
IsMainAxisReversed
(
)
:
axisTracker
.
IsCrossAxisReversed
(
)
;
StyleAlignFlags
alignment
{
0
}
;
StyleAlignFlags
alignmentFlags
{
0
}
;
if
(
isMainAxis
)
{
alignment
=
SimplifyAlignOrJustifyContentForOneItem
(
containerStylePos
-
>
mJustifyContent
false
)
;
}
else
{
const
StyleAlignFlags
alignContent
=
SimplifyAlignOrJustifyContentForOneItem
(
containerStylePos
-
>
mAlignContent
true
)
;
if
(
StyleFlexWrap
:
:
Nowrap
!
=
containerStylePos
-
>
mFlexWrap
&
&
alignContent
!
=
StyleAlignFlags
:
:
STRETCH
)
{
alignment
=
alignContent
;
}
else
{
alignment
=
aChildRI
.
mStylePosition
-
>
UsedAlignSelf
(
Style
(
)
)
.
_0
;
alignmentFlags
=
alignment
&
StyleAlignFlags
:
:
FLAG_BITS
;
alignment
&
=
~
StyleAlignFlags
:
:
FLAG_BITS
;
if
(
alignment
=
=
StyleAlignFlags
:
:
NORMAL
)
{
alignment
=
aChildRI
.
mFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eReplaced
)
?
StyleAlignFlags
:
:
START
:
StyleAlignFlags
:
:
STRETCH
;
}
}
}
if
(
alignment
=
=
StyleAlignFlags
:
:
FLEX_START
)
{
alignment
=
isAxisReversed
?
StyleAlignFlags
:
:
END
:
StyleAlignFlags
:
:
START
;
}
else
if
(
alignment
=
=
StyleAlignFlags
:
:
FLEX_END
)
{
alignment
=
isAxisReversed
?
StyleAlignFlags
:
:
START
:
StyleAlignFlags
:
:
END
;
}
else
if
(
alignment
=
=
StyleAlignFlags
:
:
LEFT
|
|
alignment
=
=
StyleAlignFlags
:
:
RIGHT
)
{
if
(
aLogicalAxis
=
=
eLogicalAxisInline
)
{
const
bool
isLeft
=
(
alignment
=
=
StyleAlignFlags
:
:
LEFT
)
;
alignment
=
(
isLeft
=
=
GetWritingMode
(
)
.
IsBidiLTR
(
)
)
?
StyleAlignFlags
:
:
START
:
StyleAlignFlags
:
:
END
;
}
else
{
alignment
=
StyleAlignFlags
:
:
START
;
}
}
else
if
(
alignment
=
=
StyleAlignFlags
:
:
BASELINE
)
{
alignment
=
StyleAlignFlags
:
:
START
;
}
else
if
(
alignment
=
=
StyleAlignFlags
:
:
LAST_BASELINE
)
{
alignment
=
StyleAlignFlags
:
:
END
;
}
return
(
alignment
|
alignmentFlags
)
;
}
FlexItem
*
nsFlexContainerFrame
:
:
GenerateFlexItemForChild
(
FlexLine
&
aLine
nsIFrame
*
aChildFrame
const
ReflowInput
&
aParentReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
bool
aHasLineClampEllipsis
)
{
ReflowInput
childRI
(
PresContext
(
)
aParentReflowInput
aChildFrame
aParentReflowInput
.
ComputedSize
(
aChildFrame
-
>
GetWritingMode
(
)
)
)
;
childRI
.
mFlags
.
mInsideLineClamp
=
GetLineClampValue
(
)
!
=
0
;
float
flexGrow
flexShrink
;
if
(
IsLegacyBox
(
this
)
)
{
if
(
GetLineClampValue
(
)
!
=
0
)
{
flexGrow
=
flexShrink
=
0
;
}
else
{
flexGrow
=
flexShrink
=
aChildFrame
-
>
StyleXUL
(
)
-
>
mBoxFlex
;
}
}
else
{
const
nsStylePosition
*
stylePos
=
aChildFrame
-
>
StylePosition
(
)
;
flexGrow
=
stylePos
-
>
mFlexGrow
;
flexShrink
=
stylePos
-
>
mFlexShrink
;
}
WritingMode
childWM
=
childRI
.
GetWritingMode
(
)
;
nscoord
flexBaseSize
=
GET_MAIN_COMPONENT_LOGICAL
(
aAxisTracker
childWM
childRI
.
ComputedISize
(
)
childRI
.
ComputedBSize
(
)
)
;
nscoord
mainMinSize
=
GET_MAIN_COMPONENT_LOGICAL
(
aAxisTracker
childWM
childRI
.
ComputedMinISize
(
)
childRI
.
ComputedMinBSize
(
)
)
;
nscoord
mainMaxSize
=
GET_MAIN_COMPONENT_LOGICAL
(
aAxisTracker
childWM
childRI
.
ComputedMaxISize
(
)
childRI
.
ComputedMaxBSize
(
)
)
;
MOZ_ASSERT
(
mainMinSize
<
=
mainMaxSize
"
min
size
is
larger
than
max
size
"
)
;
nscoord
tentativeCrossSize
=
GET_CROSS_COMPONENT_LOGICAL
(
aAxisTracker
childWM
childRI
.
ComputedISize
(
)
childRI
.
ComputedBSize
(
)
)
;
nscoord
crossMinSize
=
GET_CROSS_COMPONENT_LOGICAL
(
aAxisTracker
childWM
childRI
.
ComputedMinISize
(
)
childRI
.
ComputedMinBSize
(
)
)
;
nscoord
crossMaxSize
=
GET_CROSS_COMPONENT_LOGICAL
(
aAxisTracker
childWM
childRI
.
ComputedMaxISize
(
)
childRI
.
ComputedMaxBSize
(
)
)
;
bool
isFixedSizeWidget
=
false
;
const
nsStyleDisplay
*
disp
=
aChildFrame
-
>
StyleDisplay
(
)
;
if
(
aChildFrame
-
>
IsThemed
(
disp
)
)
{
LayoutDeviceIntSize
widgetMinSize
;
bool
canOverride
=
true
;
PresContext
(
)
-
>
Theme
(
)
-
>
GetMinimumWidgetSize
(
PresContext
(
)
aChildFrame
disp
-
>
EffectiveAppearance
(
)
&
widgetMinSize
&
canOverride
)
;
nscoord
widgetMainMinSize
=
PresContext
(
)
-
>
DevPixelsToAppUnits
(
aAxisTracker
.
MainComponent
(
widgetMinSize
)
)
;
nscoord
widgetCrossMinSize
=
PresContext
(
)
-
>
DevPixelsToAppUnits
(
aAxisTracker
.
CrossComponent
(
widgetMinSize
)
)
;
const
LogicalMargin
bpInChildWM
=
childRI
.
ComputedLogicalBorderPadding
(
)
;
const
LogicalMargin
bpInFlexWM
=
bpInChildWM
.
ConvertTo
(
aAxisTracker
.
GetWritingMode
(
)
childWM
)
;
widgetMainMinSize
-
=
aAxisTracker
.
MarginSizeInMainAxis
(
bpInFlexWM
)
;
widgetCrossMinSize
-
=
aAxisTracker
.
MarginSizeInCrossAxis
(
bpInFlexWM
)
;
widgetMainMinSize
=
std
:
:
max
(
0
widgetMainMinSize
)
;
widgetCrossMinSize
=
std
:
:
max
(
0
widgetCrossMinSize
)
;
if
(
!
canOverride
)
{
flexBaseSize
=
mainMinSize
=
mainMaxSize
=
widgetMainMinSize
;
tentativeCrossSize
=
crossMinSize
=
crossMaxSize
=
widgetCrossMinSize
;
isFixedSizeWidget
=
true
;
}
else
{
mainMinSize
=
std
:
:
max
(
mainMinSize
widgetMainMinSize
)
;
mainMaxSize
=
std
:
:
max
(
mainMaxSize
widgetMainMinSize
)
;
if
(
tentativeCrossSize
!
=
NS_UNCONSTRAINEDSIZE
)
{
tentativeCrossSize
=
std
:
:
max
(
tentativeCrossSize
widgetCrossMinSize
)
;
}
crossMinSize
=
std
:
:
max
(
crossMinSize
widgetCrossMinSize
)
;
crossMaxSize
=
std
:
:
max
(
crossMaxSize
widgetCrossMinSize
)
;
}
}
FlexItem
*
item
=
aLine
.
Items
(
)
.
EmplaceBack
(
childRI
flexGrow
flexShrink
flexBaseSize
mainMinSize
mainMaxSize
tentativeCrossSize
crossMinSize
crossMaxSize
aAxisTracker
)
;
if
(
isFixedSizeWidget
|
|
(
flexGrow
=
=
0
.
0f
&
&
flexShrink
=
=
0
.
0f
)
)
{
item
-
>
Freeze
(
)
;
if
(
flexBaseSize
<
mainMinSize
)
{
item
-
>
SetWasMinClamped
(
)
;
}
else
if
(
flexBaseSize
>
mainMaxSize
)
{
item
-
>
SetWasMaxClamped
(
)
;
}
}
ResolveAutoFlexBasisAndMinSize
(
*
item
childRI
aAxisTracker
aHasLineClampEllipsis
)
;
return
item
;
}
static
bool
IsCrossSizeDefinite
(
const
ReflowInput
&
aItemReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
)
{
const
nsStylePosition
*
pos
=
aItemReflowInput
.
mStylePosition
;
const
WritingMode
containerWM
=
aAxisTracker
.
GetWritingMode
(
)
;
if
(
aAxisTracker
.
IsColumnOriented
(
)
)
{
return
!
pos
-
>
ISize
(
containerWM
)
.
IsAuto
(
)
;
}
nscoord
cbBSize
=
aItemReflowInput
.
mCBReflowInput
-
>
ComputedBSize
(
)
;
return
!
nsLayoutUtils
:
:
IsAutoBSize
(
pos
-
>
BSize
(
containerWM
)
cbBSize
)
;
}
static
nscoord
SpecifiedCrossSizeIfDefinite
(
const
FlexItem
&
aFlexItem
const
ReflowInput
&
aItemReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
)
{
if
(
aFlexItem
.
IsStretched
(
)
)
{
return
aFlexItem
.
CrossSize
(
)
;
}
if
(
IsCrossSizeDefinite
(
aItemReflowInput
aAxisTracker
)
)
{
return
aFlexItem
.
CrossSize
(
)
;
}
return
NS_UNCONSTRAINEDSIZE
;
}
static
nscoord
MainSizeFromAspectRatio
(
nscoord
aCrossSize
const
AspectRatio
&
aIntrinsicRatio
const
FlexboxAxisTracker
&
aAxisTracker
)
{
MOZ_ASSERT
(
aIntrinsicRatio
"
Invalid
ratio
;
will
divide
by
0
!
Caller
should
'
ve
checked
.
.
.
"
)
;
AspectRatio
ratio
=
aAxisTracker
.
IsMainAxisHorizontal
(
)
?
aIntrinsicRatio
:
aIntrinsicRatio
.
Inverted
(
)
;
return
ratio
.
ApplyTo
(
aCrossSize
)
;
}
static
nscoord
ClampMainSizeViaCrossAxisConstraints
(
nscoord
aMainSize
const
FlexItem
&
aFlexItem
const
FlexboxAxisTracker
&
aAxisTracker
)
{
MOZ_ASSERT
(
aFlexItem
.
HasIntrinsicRatio
(
)
"
Caller
should
'
ve
checked
the
ratio
is
valid
!
"
)
;
const
auto
&
aspectRatio
=
aFlexItem
.
IntrinsicRatio
(
)
;
const
nscoord
mainMinSizeFromRatio
=
MainSizeFromAspectRatio
(
aFlexItem
.
CrossMinSize
(
)
aspectRatio
aAxisTracker
)
;
nscoord
clampedMainSize
=
std
:
:
max
(
aMainSize
mainMinSizeFromRatio
)
;
if
(
aFlexItem
.
CrossMaxSize
(
)
!
=
NS_UNCONSTRAINEDSIZE
)
{
const
nscoord
mainMaxSizeFromRatio
=
MainSizeFromAspectRatio
(
aFlexItem
.
CrossMaxSize
(
)
aspectRatio
aAxisTracker
)
;
clampedMainSize
=
std
:
:
min
(
clampedMainSize
mainMaxSizeFromRatio
)
;
}
return
clampedMainSize
;
}
static
nscoord
PartiallyResolveAutoMinSize
(
const
FlexItem
&
aFlexItem
const
ReflowInput
&
aItemReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
)
{
MOZ_ASSERT
(
aFlexItem
.
NeedsMinSizeAutoResolution
(
)
"
only
call
for
FlexItems
that
need
min
-
size
auto
resolution
"
)
;
const
auto
itemWM
=
aFlexItem
.
GetWritingMode
(
)
;
const
auto
cbWM
=
aAxisTracker
.
GetWritingMode
(
)
;
const
auto
cbSize
=
aItemReflowInput
.
mContainingBlockSize
.
ConvertTo
(
cbWM
itemWM
)
;
const
auto
&
mainStyleSize
=
aItemReflowInput
.
mStylePosition
-
>
Size
(
aAxisTracker
.
MainAxis
(
)
cbWM
)
;
const
auto
boxSizingAdjust
=
aItemReflowInput
.
mStylePosition
-
>
mBoxSizing
=
=
StyleBoxSizing
:
:
Border
?
aFlexItem
.
BorderPadding
(
)
.
Size
(
cbWM
)
:
LogicalSize
(
cbWM
)
;
nscoord
specifiedSizeSuggestion
=
nscoord_MAX
;
if
(
aAxisTracker
.
IsRowOriented
(
)
)
{
if
(
mainStyleSize
.
IsLengthPercentage
(
)
)
{
specifiedSizeSuggestion
=
aFlexItem
.
Frame
(
)
-
>
ComputeISizeValue
(
cbSize
.
ISize
(
cbWM
)
boxSizingAdjust
.
ISize
(
cbWM
)
mainStyleSize
.
AsLengthPercentage
(
)
)
;
}
}
else
{
if
(
!
nsLayoutUtils
:
:
IsAutoBSize
(
mainStyleSize
cbSize
.
BSize
(
cbWM
)
)
)
{
specifiedSizeSuggestion
=
nsLayoutUtils
:
:
ComputeBSizeValue
(
cbSize
.
BSize
(
cbWM
)
boxSizingAdjust
.
BSize
(
cbWM
)
mainStyleSize
.
AsLengthPercentage
(
)
)
;
}
}
if
(
specifiedSizeSuggestion
!
=
nscoord_MAX
)
{
if
(
aFlexItem
.
MainMaxSize
(
)
!
=
NS_UNCONSTRAINEDSIZE
)
{
specifiedSizeSuggestion
=
std
:
:
min
(
specifiedSizeSuggestion
aFlexItem
.
MainMaxSize
(
)
)
;
}
FLEX_LOGV
(
"
Specified
size
suggestion
:
%
d
"
specifiedSizeSuggestion
)
;
return
specifiedSizeSuggestion
;
}
nscoord
transferredSizeSuggestion
=
nscoord_MAX
;
if
(
aFlexItem
.
HasIntrinsicRatio
(
)
)
{
const
nscoord
crossSize
=
SpecifiedCrossSizeIfDefinite
(
aFlexItem
aItemReflowInput
aAxisTracker
)
;
if
(
crossSize
!
=
NS_UNCONSTRAINEDSIZE
)
{
transferredSizeSuggestion
=
MainSizeFromAspectRatio
(
crossSize
aFlexItem
.
IntrinsicRatio
(
)
aAxisTracker
)
;
}
transferredSizeSuggestion
=
ClampMainSizeViaCrossAxisConstraints
(
transferredSizeSuggestion
aFlexItem
aAxisTracker
)
;
}
FLEX_LOGV
(
"
Transferred
size
suggestion
:
%
d
"
transferredSizeSuggestion
)
;
return
transferredSizeSuggestion
;
}
static
bool
ResolveAutoFlexBasisFromRatio
(
FlexItem
&
aFlexItem
const
ReflowInput
&
aItemReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
)
{
MOZ_ASSERT
(
NS_UNCONSTRAINEDSIZE
=
=
aFlexItem
.
FlexBaseSize
(
)
"
Should
only
be
called
to
resolve
an
'
auto
'
flex
-
basis
"
)
;
if
(
aFlexItem
.
IntrinsicRatio
(
)
)
{
const
nscoord
crossSize
=
SpecifiedCrossSizeIfDefinite
(
aFlexItem
aItemReflowInput
aAxisTracker
)
;
if
(
crossSize
!
=
NS_UNCONSTRAINEDSIZE
)
{
nscoord
mainSizeFromRatio
=
MainSizeFromAspectRatio
(
crossSize
aFlexItem
.
IntrinsicRatio
(
)
aAxisTracker
)
;
aFlexItem
.
SetFlexBaseSizeAndMainSize
(
mainSizeFromRatio
)
;
return
true
;
}
}
return
false
;
}
void
nsFlexContainerFrame
:
:
ResolveAutoFlexBasisAndMinSize
(
FlexItem
&
aFlexItem
const
ReflowInput
&
aItemReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
bool
aHasLineClampEllipsis
)
{
const
bool
isMainSizeAuto
=
(
!
aFlexItem
.
IsInlineAxisMainAxis
(
)
&
&
NS_UNCONSTRAINEDSIZE
=
=
aFlexItem
.
FlexBaseSize
(
)
)
;
const
bool
isMainMinSizeAuto
=
aFlexItem
.
NeedsMinSizeAutoResolution
(
)
;
if
(
!
isMainSizeAuto
&
&
!
isMainMinSizeAuto
)
{
return
;
}
FLEX_LOGV
(
"
Resolving
auto
main
size
or
main
min
size
for
flex
item
%
p
"
aFlexItem
.
Frame
(
)
)
;
const
ReflowInput
*
flexContainerRI
=
aItemReflowInput
.
mParentReflowInput
;
MOZ_ASSERT
(
flexContainerRI
"
flex
item
'
s
reflow
input
should
have
ptr
to
container
'
s
state
"
)
;
if
(
StyleFlexWrap
:
:
Nowrap
=
=
flexContainerRI
-
>
mStylePosition
-
>
mFlexWrap
)
{
nscoord
containerCrossSize
=
GET_CROSS_COMPONENT_LOGICAL
(
aAxisTracker
aAxisTracker
.
GetWritingMode
(
)
flexContainerRI
-
>
ComputedISize
(
)
flexContainerRI
-
>
ComputedBSize
(
)
)
;
if
(
aAxisTracker
.
IsColumnOriented
(
)
|
|
containerCrossSize
!
=
NS_UNCONSTRAINEDSIZE
)
{
aFlexItem
.
ResolveStretchedCrossSize
(
containerCrossSize
)
;
}
}
nscoord
resolvedMinSize
;
bool
minSizeNeedsToMeasureContent
=
false
;
if
(
isMainMinSizeAuto
)
{
resolvedMinSize
=
PartiallyResolveAutoMinSize
(
aFlexItem
aItemReflowInput
aAxisTracker
)
;
if
(
resolvedMinSize
>
0
)
{
minSizeNeedsToMeasureContent
=
true
;
}
}
bool
flexBasisNeedsToMeasureContent
=
false
;
if
(
isMainSizeAuto
)
{
if
(
!
ResolveAutoFlexBasisFromRatio
(
aFlexItem
aItemReflowInput
aAxisTracker
)
)
{
flexBasisNeedsToMeasureContent
=
true
;
}
}
if
(
minSizeNeedsToMeasureContent
|
|
flexBasisNeedsToMeasureContent
)
{
nscoord
contentSizeSuggestion
=
nscoord_MAX
;
if
(
aFlexItem
.
IsInlineAxisMainAxis
(
)
)
{
if
(
minSizeNeedsToMeasureContent
)
{
contentSizeSuggestion
=
aFlexItem
.
Frame
(
)
-
>
GetMinISize
(
aItemReflowInput
.
mRenderingContext
)
;
}
NS_ASSERTION
(
!
flexBasisNeedsToMeasureContent
"
flex
-
basis
:
auto
should
have
been
resolved
in
the
"
"
reflow
input
for
horizontal
flexbox
.
It
shouldn
'
t
need
"
"
special
handling
here
"
)
;
}
else
{
bool
forceBResizeForMeasuringReflow
=
!
aFlexItem
.
IsFrozen
(
)
|
|
!
flexBasisNeedsToMeasureContent
;
nscoord
contentBSize
=
MeasureFlexItemContentBSize
(
aFlexItem
forceBResizeForMeasuringReflow
aHasLineClampEllipsis
*
flexContainerRI
)
;
if
(
minSizeNeedsToMeasureContent
)
{
contentSizeSuggestion
=
contentBSize
;
}
if
(
flexBasisNeedsToMeasureContent
)
{
aFlexItem
.
SetFlexBaseSizeAndMainSize
(
contentBSize
)
;
}
}
if
(
minSizeNeedsToMeasureContent
)
{
if
(
aFlexItem
.
IntrinsicRatio
(
)
)
{
contentSizeSuggestion
=
ClampMainSizeViaCrossAxisConstraints
(
contentSizeSuggestion
aFlexItem
aAxisTracker
)
;
}
if
(
aFlexItem
.
MainMaxSize
(
)
!
=
NS_UNCONSTRAINEDSIZE
)
{
contentSizeSuggestion
=
std
:
:
min
(
contentSizeSuggestion
aFlexItem
.
MainMaxSize
(
)
)
;
}
FLEX_LOGV
(
"
Content
size
suggestion
:
%
d
"
contentSizeSuggestion
)
;
resolvedMinSize
=
std
:
:
min
(
resolvedMinSize
contentSizeSuggestion
)
;
}
}
if
(
isMainMinSizeAuto
)
{
aFlexItem
.
UpdateMainMinSize
(
resolvedMinSize
)
;
}
}
class
nsFlexContainerFrame
:
:
CachedBAxisMeasurement
{
struct
Key
{
const
LogicalSize
mComputedSize
;
const
nscoord
mComputedMinBSize
;
const
nscoord
mComputedMaxBSize
;
const
nscoord
mAvailableBSize
;
explicit
Key
(
const
ReflowInput
&
aRI
)
:
mComputedSize
(
aRI
.
ComputedSize
(
)
)
mComputedMinBSize
(
aRI
.
ComputedMinBSize
(
)
)
mComputedMaxBSize
(
aRI
.
ComputedMaxBSize
(
)
)
mAvailableBSize
(
aRI
.
AvailableBSize
(
)
)
{
}
bool
operator
=
=
(
const
Key
&
aOther
)
const
{
return
mComputedSize
=
=
aOther
.
mComputedSize
&
&
mComputedMinBSize
=
=
aOther
.
mComputedMinBSize
&
&
mComputedMaxBSize
=
=
aOther
.
mComputedMaxBSize
&
&
mAvailableBSize
=
=
aOther
.
mAvailableBSize
;
}
}
;
const
Key
mKey
;
nscoord
mBSize
;
const
nscoord
mAscent
;
public
:
CachedBAxisMeasurement
(
const
ReflowInput
&
aReflowInput
const
ReflowOutput
&
aReflowOutput
)
:
mKey
(
aReflowInput
)
mAscent
(
aReflowOutput
.
BlockStartAscent
(
)
)
{
WritingMode
itemWM
=
aReflowInput
.
GetWritingMode
(
)
;
nscoord
borderBoxBSize
=
aReflowOutput
.
BSize
(
itemWM
)
;
mBSize
=
borderBoxBSize
-
aReflowInput
.
ComputedLogicalBorderPadding
(
)
.
BStartEnd
(
itemWM
)
;
mBSize
=
std
:
:
max
(
0
mBSize
)
;
}
bool
IsValidFor
(
const
ReflowInput
&
aReflowInput
)
const
{
return
mKey
=
=
Key
(
aReflowInput
)
;
}
nscoord
BSize
(
)
const
{
return
mBSize
;
}
nscoord
Ascent
(
)
const
{
return
mAscent
;
}
}
;
enum
class
FlexItemReflowType
{
Measuring
Final
}
;
class
nsFlexContainerFrame
:
:
CachedFlexItemData
{
public
:
CachedFlexItemData
(
const
ReflowInput
&
aReflowInput
const
ReflowOutput
&
aReflowOutput
FlexItemReflowType
aType
)
{
if
(
aType
=
=
FlexItemReflowType
:
:
Measuring
)
{
mBAxisMeasurement
.
emplace
(
aReflowInput
aReflowOutput
)
;
}
else
{
UpdateFinalReflowSize
(
aReflowInput
aReflowOutput
)
;
}
}
void
UpdateFinalReflowSize
(
const
ReflowInput
&
aReflowInput
const
ReflowOutput
&
aReflowOutput
)
{
auto
wm
=
aReflowInput
.
GetWritingMode
(
)
;
mFinalReflowSize
.
reset
(
)
;
mFinalReflowSize
.
emplace
(
aReflowOutput
.
Size
(
wm
)
-
aReflowInput
.
ComputedLogicalBorderPadding
(
)
.
Size
(
wm
)
)
;
mLastReflowTreatedBSizeAsIndefinite
=
aReflowInput
.
mFlags
.
mTreatBSizeAsIndefinite
;
}
void
UpdateFinalReflowSize
(
const
FlexItem
&
aItem
const
LogicalSize
&
aSize
)
{
MOZ_ASSERT
(
!
mFinalReflowSize
"
This
version
of
the
method
is
only
intended
to
be
called
when
"
"
the
most
recent
reflow
was
a
'
measuring
reflow
'
;
and
that
"
"
should
have
cleared
out
mFinalReflowSize
"
)
;
mFinalReflowSize
.
reset
(
)
;
mFinalReflowSize
.
emplace
(
aSize
)
;
mLastReflowTreatedBSizeAsIndefinite
=
aItem
.
TreatBSizeAsIndefinite
(
)
;
}
Maybe
<
CachedBAxisMeasurement
>
mBAxisMeasurement
;
Maybe
<
LogicalSize
>
mFinalReflowSize
;
bool
mLastReflowTreatedBSizeAsIndefinite
=
false
;
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
Prop
CachedFlexItemData
)
}
;
void
nsFlexContainerFrame
:
:
MarkCachedFlexMeasurementsDirty
(
nsIFrame
*
aItemFrame
)
{
MOZ_ASSERT
(
aItemFrame
-
>
IsFlexItem
(
)
)
;
if
(
auto
*
cache
=
aItemFrame
-
>
GetProperty
(
CachedFlexItemData
:
:
Prop
(
)
)
)
{
cache
-
>
mBAxisMeasurement
.
reset
(
)
;
cache
-
>
mFinalReflowSize
.
reset
(
)
;
}
}
const
CachedBAxisMeasurement
&
nsFlexContainerFrame
:
:
MeasureAscentAndBSizeForFlexItem
(
FlexItem
&
aItem
ReflowInput
&
aChildReflowInput
)
{
auto
*
cachedData
=
aItem
.
Frame
(
)
-
>
GetProperty
(
CachedFlexItemData
:
:
Prop
(
)
)
;
if
(
cachedData
&
&
cachedData
-
>
mBAxisMeasurement
)
{
if
(
cachedData
-
>
mBAxisMeasurement
-
>
IsValidFor
(
aChildReflowInput
)
)
{
return
*
(
cachedData
-
>
mBAxisMeasurement
)
;
}
FLEX_LOG
(
"
[
perf
]
MeasureAscentAndBSizeForFlexItem
rejected
cached
value
"
)
;
}
else
{
FLEX_LOG
(
"
[
perf
]
MeasureAscentAndBSizeForFlexItem
didn
'
t
have
a
cached
value
"
)
;
}
ReflowOutput
childReflowOutput
(
aChildReflowInput
)
;
nsReflowStatus
childReflowStatus
;
const
ReflowChildFlags
flags
=
ReflowChildFlags
:
:
NoMoveFrame
;
const
WritingMode
outerWM
=
GetWritingMode
(
)
;
const
LogicalPoint
dummyPosition
(
outerWM
)
;
const
nsSize
dummyContainerSize
;
ReflowChild
(
aItem
.
Frame
(
)
PresContext
(
)
childReflowOutput
aChildReflowInput
outerWM
dummyPosition
dummyContainerSize
flags
childReflowStatus
)
;
aItem
.
SetHadMeasuringReflow
(
)
;
MOZ_ASSERT
(
childReflowStatus
.
IsComplete
(
)
"
We
gave
flex
item
unconstrained
available
block
-
size
so
it
"
"
should
be
complete
"
)
;
FinishReflowChild
(
aItem
.
Frame
(
)
PresContext
(
)
childReflowOutput
&
aChildReflowInput
outerWM
dummyPosition
dummyContainerSize
flags
)
;
if
(
cachedData
)
{
cachedData
-
>
mBAxisMeasurement
.
reset
(
)
;
cachedData
-
>
mBAxisMeasurement
.
emplace
(
aChildReflowInput
childReflowOutput
)
;
cachedData
-
>
mFinalReflowSize
.
reset
(
)
;
}
else
{
cachedData
=
new
CachedFlexItemData
(
aChildReflowInput
childReflowOutput
FlexItemReflowType
:
:
Measuring
)
;
aItem
.
Frame
(
)
-
>
SetProperty
(
CachedFlexItemData
:
:
Prop
(
)
cachedData
)
;
}
return
*
(
cachedData
-
>
mBAxisMeasurement
)
;
}
void
nsFlexContainerFrame
:
:
MarkIntrinsicISizesDirty
(
)
{
mCachedMinISize
=
NS_INTRINSIC_ISIZE_UNKNOWN
;
mCachedPrefISize
=
NS_INTRINSIC_ISIZE_UNKNOWN
;
nsContainerFrame
:
:
MarkIntrinsicISizesDirty
(
)
;
}
nscoord
nsFlexContainerFrame
:
:
MeasureFlexItemContentBSize
(
FlexItem
&
aFlexItem
bool
aForceBResizeForMeasuringReflow
bool
aHasLineClampEllipsis
const
ReflowInput
&
aParentReflowInput
)
{
WritingMode
wm
=
aFlexItem
.
Frame
(
)
-
>
GetWritingMode
(
)
;
LogicalSize
availSize
=
aParentReflowInput
.
ComputedSize
(
wm
)
;
availSize
.
BSize
(
wm
)
=
NS_UNCONSTRAINEDSIZE
;
ReflowInput
childRIForMeasuringBSize
(
PresContext
(
)
aParentReflowInput
aFlexItem
.
Frame
(
)
availSize
Nothing
(
)
ReflowInput
:
:
InitFlag
:
:
CallerWillInit
)
;
childRIForMeasuringBSize
.
mFlags
.
mIsFlexContainerMeasuringBSize
=
true
;
childRIForMeasuringBSize
.
mFlags
.
mInsideLineClamp
=
GetLineClampValue
(
)
!
=
0
;
childRIForMeasuringBSize
.
mFlags
.
mApplyLineClamp
=
childRIForMeasuringBSize
.
mFlags
.
mInsideLineClamp
|
|
aHasLineClampEllipsis
;
childRIForMeasuringBSize
.
Init
(
PresContext
(
)
)
;
if
(
aFlexItem
.
IsStretched
(
)
)
{
childRIForMeasuringBSize
.
SetComputedISize
(
aFlexItem
.
CrossSize
(
)
)
;
childRIForMeasuringBSize
.
SetIResize
(
true
)
;
}
if
(
aForceBResizeForMeasuringReflow
)
{
childRIForMeasuringBSize
.
SetBResize
(
true
)
;
childRIForMeasuringBSize
.
mFlags
.
mIsBResizeForPercentages
=
true
;
}
const
CachedBAxisMeasurement
&
measurement
=
MeasureAscentAndBSizeForFlexItem
(
aFlexItem
childRIForMeasuringBSize
)
;
aFlexItem
.
SetAscent
(
measurement
.
Ascent
(
)
)
;
return
measurement
.
BSize
(
)
;
}
FlexItem
:
:
FlexItem
(
ReflowInput
&
aFlexItemReflowInput
float
aFlexGrow
float
aFlexShrink
nscoord
aFlexBaseSize
nscoord
aMainMinSize
nscoord
aMainMaxSize
nscoord
aTentativeCrossSize
nscoord
aCrossMinSize
nscoord
aCrossMaxSize
const
FlexboxAxisTracker
&
aAxisTracker
)
:
mFrame
(
aFlexItemReflowInput
.
mFrame
)
mFlexGrow
(
aFlexGrow
)
mFlexShrink
(
aFlexShrink
)
mIntrinsicRatio
(
mFrame
-
>
GetAspectRatio
(
)
)
mWM
(
aFlexItemReflowInput
.
GetWritingMode
(
)
)
mCBWM
(
aAxisTracker
.
GetWritingMode
(
)
)
mMainAxis
(
aAxisTracker
.
MainAxis
(
)
)
mBorderPadding
(
aFlexItemReflowInput
.
ComputedLogicalBorderPadding
(
)
.
ConvertTo
(
mCBWM
mWM
)
)
mMargin
(
aFlexItemReflowInput
.
ComputedLogicalMargin
(
)
.
ConvertTo
(
mCBWM
mWM
)
)
mMainMinSize
(
aMainMinSize
)
mMainMaxSize
(
aMainMaxSize
)
mCrossMinSize
(
aCrossMinSize
)
mCrossMaxSize
(
aCrossMaxSize
)
mCrossSize
(
aTentativeCrossSize
)
mIsInlineAxisMainAxis
(
aAxisTracker
.
IsRowOriented
(
)
!
=
aAxisTracker
.
GetWritingMode
(
)
.
IsOrthogonalTo
(
mWM
)
)
{
MOZ_ASSERT
(
mFrame
"
expecting
a
non
-
null
child
frame
"
)
;
MOZ_ASSERT
(
!
mFrame
-
>
IsPlaceholderFrame
(
)
"
placeholder
frames
should
not
be
treated
as
flex
items
"
)
;
MOZ_ASSERT
(
!
mFrame
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
"
out
-
of
-
flow
frames
should
not
be
treated
as
flex
items
"
)
;
MOZ_ASSERT
(
mIsInlineAxisMainAxis
=
=
nsFlexContainerFrame
:
:
IsItemInlineAxisMainAxis
(
mFrame
)
"
public
API
should
be
consistent
with
internal
state
(
about
"
"
whether
flex
item
'
s
inline
axis
is
flex
container
'
s
main
axis
)
"
)
;
const
ReflowInput
*
containerRS
=
aFlexItemReflowInput
.
mParentReflowInput
;
if
(
IsLegacyBox
(
containerRS
-
>
mFrame
)
)
{
const
nsStyleXUL
*
containerStyleXUL
=
containerRS
-
>
mFrame
-
>
StyleXUL
(
)
;
mAlignSelf
=
{
ConvertLegacyStyleToAlignItems
(
containerStyleXUL
)
}
;
mAlignSelfFlags
=
{
0
}
;
}
else
{
mAlignSelf
=
aFlexItemReflowInput
.
mStylePosition
-
>
UsedAlignSelf
(
containerRS
-
>
mFrame
-
>
Style
(
)
)
;
if
(
MOZ_LIKELY
(
mAlignSelf
.
_0
=
=
StyleAlignFlags
:
:
NORMAL
)
)
{
mAlignSelf
=
{
StyleAlignFlags
:
:
STRETCH
}
;
}
mAlignSelfFlags
=
mAlignSelf
.
_0
&
StyleAlignFlags
:
:
FLAG_BITS
;
mAlignSelf
.
_0
&
=
~
StyleAlignFlags
:
:
FLAG_BITS
;
}
if
(
mIsInlineAxisMainAxis
)
{
mTreatBSizeAsIndefinite
=
false
;
}
else
{
if
(
aAxisTracker
.
IsRowOriented
(
)
|
|
(
containerRS
-
>
ComputedBSize
(
)
!
=
NS_UNCONSTRAINEDSIZE
&
&
!
containerRS
-
>
mFlags
.
mTreatBSizeAsIndefinite
)
)
{
mTreatBSizeAsIndefinite
=
false
;
}
else
if
(
aFlexBaseSize
!
=
NS_UNCONSTRAINEDSIZE
)
{
mTreatBSizeAsIndefinite
=
false
;
}
else
{
mTreatBSizeAsIndefinite
=
true
;
}
}
SetFlexBaseSizeAndMainSize
(
aFlexBaseSize
)
;
CheckForMinSizeAuto
(
aFlexItemReflowInput
aAxisTracker
)
;
const
nsStyleMargin
*
styleMargin
=
aFlexItemReflowInput
.
mStyleMargin
;
mHasAnyAutoMargin
=
styleMargin
-
>
HasInlineAxisAuto
(
mCBWM
)
|
|
styleMargin
-
>
HasBlockAxisAuto
(
mCBWM
)
;
#
ifdef
DEBUG
{
for
(
const
auto
side
:
AllLogicalSides
(
)
)
{
if
(
styleMargin
-
>
mMargin
.
Get
(
mCBWM
side
)
.
IsAuto
(
)
)
{
MOZ_ASSERT
(
GetMarginComponentForSide
(
side
)
=
=
0
"
Someone
else
tried
to
resolve
our
auto
margin
"
)
;
}
}
}
#
endif
if
(
!
IsBlockAxisCrossAxis
(
)
)
{
if
(
mAlignSelf
.
_0
=
=
StyleAlignFlags
:
:
BASELINE
)
{
mAlignSelf
=
{
StyleAlignFlags
:
:
FLEX_START
}
;
}
else
if
(
mAlignSelf
.
_0
=
=
StyleAlignFlags
:
:
LAST_BASELINE
)
{
mAlignSelf
=
{
StyleAlignFlags
:
:
FLEX_END
}
;
}
}
}
FlexItem
:
:
FlexItem
(
nsIFrame
*
aChildFrame
nscoord
aCrossSize
WritingMode
aContainerWM
const
FlexboxAxisTracker
&
aAxisTracker
)
:
mFrame
(
aChildFrame
)
mWM
(
aContainerWM
)
mCBWM
(
aContainerWM
)
mMainAxis
(
aAxisTracker
.
MainAxis
(
)
)
mBorderPadding
(
mCBWM
)
mMargin
(
mCBWM
)
mCrossSize
(
aCrossSize
)
mIsFrozen
(
true
)
mIsStrut
(
true
)
mAlignSelf
(
{
StyleAlignFlags
:
:
FLEX_START
}
)
{
MOZ_ASSERT
(
mFrame
"
expecting
a
non
-
null
child
frame
"
)
;
MOZ_ASSERT
(
StyleVisibility
:
:
Collapse
=
=
mFrame
-
>
StyleVisibility
(
)
-
>
mVisible
"
Should
only
make
struts
for
children
with
'
visibility
:
collapse
'
"
)
;
MOZ_ASSERT
(
!
mFrame
-
>
IsPlaceholderFrame
(
)
"
placeholder
frames
should
not
be
treated
as
flex
items
"
)
;
MOZ_ASSERT
(
!
mFrame
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
"
out
-
of
-
flow
frames
should
not
be
treated
as
flex
items
"
)
;
}
void
FlexItem
:
:
CheckForMinSizeAuto
(
const
ReflowInput
&
aFlexItemReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
)
{
const
nsStylePosition
*
pos
=
aFlexItemReflowInput
.
mStylePosition
;
const
nsStyleDisplay
*
disp
=
aFlexItemReflowInput
.
mStyleDisplay
;
const
auto
&
mainMinSize
=
aAxisTracker
.
IsRowOriented
(
)
?
pos
-
>
MinISize
(
aAxisTracker
.
GetWritingMode
(
)
)
:
pos
-
>
MinBSize
(
aAxisTracker
.
GetWritingMode
(
)
)
;
mNeedsMinSizeAutoResolution
=
IsAutoOrEnumOnBSize
(
mainMinSize
IsInlineAxisMainAxis
(
)
)
&
&
!
disp
-
>
IsScrollableOverflow
(
)
;
}
nscoord
FlexItem
:
:
BaselineOffsetFromOuterCrossEdge
(
mozilla
:
:
Side
aStartSide
bool
aUseFirstLineBaseline
)
const
{
MOZ_ASSERT
(
IsBlockAxisCrossAxis
(
)
"
Only
expecting
to
be
doing
baseline
computations
when
the
"
"
cross
axis
is
the
block
axis
"
)
;
mozilla
:
:
Side
itemBlockStartSide
=
mWM
.
PhysicalSide
(
eLogicalSideBStart
)
;
nscoord
marginBStartToBaseline
=
ResolvedAscent
(
aUseFirstLineBaseline
)
+
PhysicalMargin
(
)
.
Side
(
itemBlockStartSide
)
;
return
(
aStartSide
=
=
itemBlockStartSide
)
?
marginBStartToBaseline
:
OuterCrossSize
(
)
-
marginBStartToBaseline
;
}
bool
FlexItem
:
:
IsCrossSizeAuto
(
)
const
{
const
nsStylePosition
*
stylePos
=
mFrame
-
>
StylePosition
(
)
;
return
IsInlineAxisCrossAxis
(
)
?
stylePos
-
>
ISize
(
mWM
)
.
IsAuto
(
)
:
stylePos
-
>
BSize
(
mWM
)
.
IsAuto
(
)
;
}
uint32_t
FlexItem
:
:
NumAutoMarginsInAxis
(
LogicalAxis
aAxis
)
const
{
uint32_t
numAutoMargins
=
0
;
const
auto
&
styleMargin
=
mFrame
-
>
StyleMargin
(
)
-
>
mMargin
;
for
(
const
auto
edge
:
{
eLogicalEdgeStart
eLogicalEdgeEnd
}
)
{
const
auto
side
=
MakeLogicalSide
(
aAxis
edge
)
;
if
(
styleMargin
.
Get
(
mCBWM
side
)
.
IsAuto
(
)
)
{
numAutoMargins
+
+
;
}
}
MOZ_ASSERT
(
numAutoMargins
<
=
2
"
We
'
re
just
looking
at
one
item
along
one
dimension
so
we
"
"
should
only
have
examined
2
margins
"
)
;
return
numAutoMargins
;
}
bool
FlexItem
:
:
CanMainSizeInfluenceCrossSize
(
)
const
{
if
(
mIsStretched
)
{
return
false
;
}
if
(
mIsStrut
)
{
return
false
;
}
if
(
HasIntrinsicRatio
(
)
)
{
return
true
;
}
if
(
IsInlineAxisCrossAxis
(
)
)
{
if
(
mFrame
-
>
IsBlockFrame
(
)
|
|
mFrame
-
>
IsTableWrapperFrame
(
)
)
{
return
false
;
}
}
return
true
;
}
static
bool
FrameHasRelativeBSizeDependency
(
nsIFrame
*
aFrame
)
{
if
(
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_CONTAINS_RELATIVE_BSIZE
)
)
{
return
true
;
}
for
(
const
auto
&
childList
:
aFrame
-
>
ChildLists
(
)
)
{
for
(
nsIFrame
*
childFrame
:
childList
.
mList
)
{
if
(
childFrame
-
>
HasAnyStateBits
(
NS_FRAME_CONTAINS_RELATIVE_BSIZE
)
)
{
return
true
;
}
}
}
return
false
;
}
bool
FlexItem
:
:
NeedsFinalReflow
(
const
nscoord
aAvailableBSizeForItem
)
const
{
MOZ_ASSERT
(
aAvailableBSizeForItem
=
=
NS_UNCONSTRAINEDSIZE
|
|
aAvailableBSizeForItem
>
0
"
We
can
only
handle
unconstrained
or
positive
available
block
-
size
.
"
)
;
if
(
mFrame
-
>
GetPrevInFlow
(
)
)
{
FLEX_LOG
(
"
[
frag
]
Flex
item
%
p
needed
a
final
reflow
due
to
being
a
continuation
"
mFrame
)
;
return
true
;
}
if
(
aAvailableBSizeForItem
!
=
NS_UNCONSTRAINEDSIZE
)
{
FLEX_LOG
(
"
[
frag
]
Flex
item
%
p
needed
both
a
measuring
reflow
and
a
final
"
"
reflow
due
to
constrained
available
block
-
size
"
mFrame
)
;
return
true
;
}
const
LogicalSize
finalSize
=
mIsInlineAxisMainAxis
?
LogicalSize
(
mWM
mMainSize
mCrossSize
)
:
LogicalSize
(
mWM
mCrossSize
mMainSize
)
;
if
(
HadMeasuringReflow
(
)
)
{
if
(
finalSize
!
=
mFrame
-
>
ContentSize
(
mWM
)
)
{
FLEX_LOG
(
"
[
perf
]
Flex
item
%
p
needed
both
a
measuring
reflow
and
a
final
"
"
reflow
due
to
measured
size
disagreeing
with
final
size
"
mFrame
)
;
return
true
;
}
if
(
FrameHasRelativeBSizeDependency
(
mFrame
)
)
{
FLEX_LOG
(
"
[
perf
]
Flex
item
%
p
needed
both
a
measuring
reflow
and
a
final
"
"
reflow
due
to
BSize
potentially
becoming
definite
"
mFrame
)
;
return
true
;
}
if
(
auto
*
cache
=
mFrame
-
>
GetProperty
(
CachedFlexItemData
:
:
Prop
(
)
)
)
{
cache
-
>
UpdateFinalReflowSize
(
*
this
finalSize
)
;
}
return
false
;
}
if
(
mFrame
-
>
IsSubtreeDirty
(
)
)
{
FLEX_LOG
(
"
[
perf
]
Flex
item
%
p
needed
a
final
reflow
due
to
its
subtree
"
"
being
dirty
"
mFrame
)
;
return
true
;
}
auto
*
cache
=
mFrame
-
>
GetProperty
(
CachedFlexItemData
:
:
Prop
(
)
)
;
if
(
!
cache
|
|
!
cache
-
>
mFinalReflowSize
)
{
FLEX_LOG
(
"
[
perf
]
Flex
item
%
p
needed
a
final
reflow
due
to
lacking
a
"
"
cached
mFinalReflowSize
(
maybe
cache
was
cleared
)
"
mFrame
)
;
return
true
;
}
if
(
*
cache
-
>
mFinalReflowSize
!
=
finalSize
)
{
FLEX_LOG
(
"
[
perf
]
Flex
item
%
p
needed
a
final
reflow
due
to
having
a
"
"
different
content
box
size
vs
.
its
most
recent
final
reflow
"
mFrame
)
;
return
true
;
}
if
(
cache
-
>
mLastReflowTreatedBSizeAsIndefinite
!
=
mTreatBSizeAsIndefinite
&
&
FrameHasRelativeBSizeDependency
(
mFrame
)
)
{
FLEX_LOG
(
"
[
perf
]
Flex
item
%
p
needed
a
final
reflow
due
to
having
"
"
its
BSize
change
definiteness
&
having
a
rel
-
BSize
child
"
mFrame
)
;
return
true
;
}
return
false
;
}
class
MOZ_STACK_CLASS
PositionTracker
{
public
:
inline
nscoord
Position
(
)
const
{
return
mPosition
;
}
inline
LogicalAxis
Axis
(
)
const
{
return
mAxis
;
}
inline
LogicalSide
StartSide
(
)
{
return
MakeLogicalSide
(
mAxis
mIsAxisReversed
?
eLogicalEdgeEnd
:
eLogicalEdgeStart
)
;
}
inline
LogicalSide
EndSide
(
)
{
return
MakeLogicalSide
(
mAxis
mIsAxisReversed
?
eLogicalEdgeStart
:
eLogicalEdgeEnd
)
;
}
void
EnterMargin
(
const
LogicalMargin
&
aMargin
)
{
mPosition
+
=
aMargin
.
Side
(
StartSide
(
)
mWM
)
;
}
void
ExitMargin
(
const
LogicalMargin
&
aMargin
)
{
mPosition
+
=
aMargin
.
Side
(
EndSide
(
)
mWM
)
;
}
void
EnterChildFrame
(
nscoord
aChildFrameSize
)
{
if
(
mIsAxisReversed
)
{
mPosition
+
=
aChildFrameSize
;
}
}
void
ExitChildFrame
(
nscoord
aChildFrameSize
)
{
if
(
!
mIsAxisReversed
)
{
mPosition
+
=
aChildFrameSize
;
}
}
PositionTracker
(
const
PositionTracker
&
)
=
delete
;
PositionTracker
&
operator
=
(
const
PositionTracker
&
)
=
delete
;
protected
:
PositionTracker
(
WritingMode
aWM
LogicalAxis
aAxis
bool
aIsAxisReversed
)
:
mWM
(
aWM
)
mAxis
(
aAxis
)
mIsAxisReversed
(
aIsAxisReversed
)
{
}
nscoord
mPosition
=
0
;
const
WritingMode
mWM
;
const
LogicalAxis
mAxis
=
eLogicalAxisInline
;
const
bool
mIsAxisReversed
=
false
;
}
;
class
MOZ_STACK_CLASS
MainAxisPositionTracker
:
public
PositionTracker
{
public
:
MainAxisPositionTracker
(
const
FlexboxAxisTracker
&
aAxisTracker
const
FlexLine
*
aLine
const
StyleContentDistribution
&
aJustifyContent
nscoord
aContentBoxMainSize
)
;
~
MainAxisPositionTracker
(
)
{
MOZ_ASSERT
(
mNumPackingSpacesRemaining
=
=
0
"
miscounted
the
number
of
packing
spaces
"
)
;
MOZ_ASSERT
(
mNumAutoMarginsInMainAxis
=
=
0
"
miscounted
the
number
of
auto
margins
"
)
;
}
void
TraverseGap
(
nscoord
aGapSize
)
{
mPosition
+
=
aGapSize
;
}
void
TraversePackingSpace
(
)
;
void
ResolveAutoMarginsInMainAxis
(
FlexItem
&
aItem
)
;
private
:
nscoord
mPackingSpaceRemaining
=
0
;
uint32_t
mNumAutoMarginsInMainAxis
=
0
;
uint32_t
mNumPackingSpacesRemaining
=
0
;
StyleContentDistribution
mJustifyContent
=
{
StyleAlignFlags
:
:
AUTO
}
;
}
;
class
MOZ_STACK_CLASS
CrossAxisPositionTracker
:
public
PositionTracker
{
public
:
CrossAxisPositionTracker
(
nsTArray
<
FlexLine
>
&
aLines
const
ReflowInput
&
aReflowInput
nscoord
aContentBoxCrossSize
bool
aIsCrossSizeDefinite
const
FlexboxAxisTracker
&
aAxisTracker
const
nscoord
aCrossGapSize
)
;
void
TraverseGap
(
)
{
mPosition
+
=
mCrossGapSize
;
}
void
TraversePackingSpace
(
)
;
void
TraverseLine
(
FlexLine
&
aLine
)
{
mPosition
+
=
aLine
.
LineCrossSize
(
)
;
}
void
EnterMargin
(
const
LogicalMargin
&
aMargin
)
=
delete
;
void
ExitMargin
(
const
LogicalMargin
&
aMargin
)
=
delete
;
void
EnterChildFrame
(
nscoord
aChildFrameSize
)
=
delete
;
void
ExitChildFrame
(
nscoord
aChildFrameSize
)
=
delete
;
private
:
nscoord
mPackingSpaceRemaining
=
0
;
uint32_t
mNumPackingSpacesRemaining
=
0
;
StyleContentDistribution
mAlignContent
=
{
StyleAlignFlags
:
:
AUTO
}
;
const
nscoord
mCrossGapSize
;
}
;
class
MOZ_STACK_CLASS
SingleLineCrossAxisPositionTracker
:
public
PositionTracker
{
public
:
explicit
SingleLineCrossAxisPositionTracker
(
const
FlexboxAxisTracker
&
aAxisTracker
)
;
void
ResolveAutoMarginsInCrossAxis
(
const
FlexLine
&
aLine
FlexItem
&
aItem
)
;
void
EnterAlignPackingSpace
(
const
FlexLine
&
aLine
const
FlexItem
&
aItem
const
FlexboxAxisTracker
&
aAxisTracker
)
;
inline
void
ResetPosition
(
)
{
mPosition
=
0
;
}
}
;
NS_QUERYFRAME_HEAD
(
nsFlexContainerFrame
)
NS_QUERYFRAME_ENTRY
(
nsFlexContainerFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsContainerFrame
)
NS_IMPL_FRAMEARENA_HELPERS
(
nsFlexContainerFrame
)
NS_DECLARE_FRAME_PROPERTY_SMALL_VALUE
(
SumOfChildrenBlockSizeProperty
nscoord
)
nsContainerFrame
*
NS_NewFlexContainerFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsFlexContainerFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
nsFlexContainerFrame
:
:
~
nsFlexContainerFrame
(
)
=
default
;
void
nsFlexContainerFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
nsContainerFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
if
(
HasAnyStateBits
(
NS_FRAME_FONT_INFLATION_CONTAINER
)
)
{
AddStateBits
(
NS_FRAME_FONT_INFLATION_FLOW_ROOT
)
;
}
const
nsStyleDisplay
*
styleDisp
=
Style
(
)
-
>
StyleDisplay
(
)
;
bool
isLegacyBox
=
IsDisplayValueLegacyBox
(
styleDisp
)
;
if
(
!
isLegacyBox
&
&
styleDisp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
Block
)
{
ComputedStyle
*
parentComputedStyle
=
GetParent
(
)
-
>
Style
(
)
;
NS_ASSERTION
(
Style
(
)
-
>
GetPseudoType
(
)
=
=
PseudoStyleType
:
:
buttonContent
|
|
Style
(
)
-
>
GetPseudoType
(
)
=
=
PseudoStyleType
:
:
scrolledContent
"
The
only
way
a
nsFlexContainerFrame
can
have
'
display
:
block
'
"
"
should
be
if
it
'
s
the
inner
part
of
a
scrollable
or
button
"
"
element
"
)
;
isLegacyBox
=
IsDisplayValueLegacyBox
(
parentComputedStyle
-
>
StyleDisplay
(
)
)
;
}
if
(
isLegacyBox
)
{
AddStateBits
(
NS_STATE_FLEX_IS_EMULATING_LEGACY_BOX
)
;
}
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
nsFlexContainerFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
u
"
FlexContainer
"
_ns
aResult
)
;
}
#
endif
nscoord
nsFlexContainerFrame
:
:
GetLogicalBaseline
(
mozilla
:
:
WritingMode
aWM
)
const
{
NS_ASSERTION
(
mBaselineFromLastReflow
!
=
NS_INTRINSIC_ISIZE_UNKNOWN
"
baseline
has
not
been
set
"
)
;
if
(
HasAnyStateBits
(
NS_STATE_FLEX_SYNTHESIZE_BASELINE
)
)
{
return
nsContainerFrame
:
:
GetLogicalBaseline
(
aWM
)
;
}
return
mBaselineFromLastReflow
;
}
void
nsFlexContainerFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
nsDisplayListCollection
tempLists
(
aBuilder
)
;
DisplayBorderBackgroundOutline
(
aBuilder
tempLists
)
;
if
(
GetPrevInFlow
(
)
)
{
DisplayOverflowContainers
(
aBuilder
tempLists
)
;
}
nsDisplayListSet
childLists
(
tempLists
tempLists
.
BlockBorderBackgrounds
(
)
)
;
CSSOrderAwareFrameIterator
iter
(
this
kPrincipalList
CSSOrderAwareFrameIterator
:
:
eIncludeAll
OrderStateForIter
(
this
)
OrderingPropertyForIter
(
this
)
)
;
for
(
;
!
iter
.
AtEnd
(
)
;
iter
.
Next
(
)
)
{
nsIFrame
*
childFrame
=
*
iter
;
BuildDisplayListForChild
(
aBuilder
childFrame
childLists
childFrame
-
>
DisplayFlagForFlexOrGridItem
(
)
)
;
}
tempLists
.
MoveTo
(
aLists
)
;
}
void
FlexLine
:
:
FreezeItemsEarly
(
bool
aIsUsingFlexGrow
ComputedFlexLineInfo
*
aLineInfo
)
{
uint32_t
numUnfrozenItemsToBeSeen
=
NumItems
(
)
-
mNumFrozenItems
;
for
(
FlexItem
&
item
:
Items
(
)
)
{
if
(
numUnfrozenItemsToBeSeen
=
=
0
)
{
break
;
}
if
(
!
item
.
IsFrozen
(
)
)
{
numUnfrozenItemsToBeSeen
-
-
;
bool
shouldFreeze
=
(
0
.
0f
=
=
item
.
GetFlexFactor
(
aIsUsingFlexGrow
)
)
;
if
(
!
shouldFreeze
)
{
if
(
aIsUsingFlexGrow
)
{
if
(
item
.
FlexBaseSize
(
)
>
item
.
MainSize
(
)
)
{
shouldFreeze
=
true
;
}
}
else
{
if
(
item
.
FlexBaseSize
(
)
<
item
.
MainSize
(
)
)
{
shouldFreeze
=
true
;
}
}
}
if
(
shouldFreeze
)
{
item
.
Freeze
(
)
;
if
(
item
.
FlexBaseSize
(
)
<
item
.
MainSize
(
)
)
{
item
.
SetWasMinClamped
(
)
;
}
else
if
(
item
.
FlexBaseSize
(
)
>
item
.
MainSize
(
)
)
{
item
.
SetWasMaxClamped
(
)
;
}
mNumFrozenItems
+
+
;
}
}
}
MOZ_ASSERT
(
numUnfrozenItemsToBeSeen
=
=
0
"
miscounted
frozen
items
?
"
)
;
}
void
FlexLine
:
:
FreezeOrRestoreEachFlexibleSize
(
const
nscoord
aTotalViolation
bool
aIsFinalIteration
)
{
enum
FreezeType
{
eFreezeEverything
eFreezeMinViolations
eFreezeMaxViolations
}
;
FreezeType
freezeType
;
if
(
aTotalViolation
=
=
0
)
{
freezeType
=
eFreezeEverything
;
}
else
if
(
aTotalViolation
>
0
)
{
freezeType
=
eFreezeMinViolations
;
}
else
{
freezeType
=
eFreezeMaxViolations
;
}
uint32_t
numUnfrozenItemsToBeSeen
=
NumItems
(
)
-
mNumFrozenItems
;
for
(
FlexItem
&
item
:
Items
(
)
)
{
if
(
numUnfrozenItemsToBeSeen
=
=
0
)
{
break
;
}
if
(
!
item
.
IsFrozen
(
)
)
{
numUnfrozenItemsToBeSeen
-
-
;
MOZ_ASSERT
(
!
item
.
HadMinViolation
(
)
|
|
!
item
.
HadMaxViolation
(
)
"
Can
have
either
min
or
max
violation
but
not
both
"
)
;
bool
hadMinViolation
=
item
.
HadMinViolation
(
)
;
bool
hadMaxViolation
=
item
.
HadMaxViolation
(
)
;
if
(
eFreezeEverything
=
=
freezeType
|
|
(
eFreezeMinViolations
=
=
freezeType
&
&
hadMinViolation
)
|
|
(
eFreezeMaxViolations
=
=
freezeType
&
&
hadMaxViolation
)
)
{
MOZ_ASSERT
(
item
.
MainSize
(
)
>
=
item
.
MainMinSize
(
)
"
Freezing
item
at
a
size
below
its
minimum
"
)
;
MOZ_ASSERT
(
item
.
MainSize
(
)
<
=
item
.
MainMaxSize
(
)
"
Freezing
item
at
a
size
above
its
maximum
"
)
;
item
.
Freeze
(
)
;
if
(
hadMinViolation
)
{
item
.
SetWasMinClamped
(
)
;
}
else
if
(
hadMaxViolation
)
{
item
.
SetWasMaxClamped
(
)
;
}
mNumFrozenItems
+
+
;
}
else
if
(
MOZ_UNLIKELY
(
aIsFinalIteration
)
)
{
NS_ERROR
(
"
Final
iteration
still
has
unfrozen
items
this
shouldn
'
t
"
"
happen
unless
there
was
nscoord
under
/
overflow
.
"
)
;
item
.
Freeze
(
)
;
mNumFrozenItems
+
+
;
}
if
(
!
item
.
IsFrozen
(
)
)
{
item
.
ClearViolationFlags
(
)
;
}
}
}
MOZ_ASSERT
(
numUnfrozenItemsToBeSeen
=
=
0
"
miscounted
frozen
items
?
"
)
;
}
void
FlexLine
:
:
ResolveFlexibleLengths
(
nscoord
aFlexContainerMainSize
ComputedFlexLineInfo
*
aLineInfo
)
{
FLEX_LOG
(
"
ResolveFlexibleLengths
"
)
;
if
(
aLineInfo
)
{
uint32_t
itemIndex
=
0
;
for
(
FlexItem
&
item
:
Items
(
)
)
{
aLineInfo
-
>
mItems
[
itemIndex
]
.
mMainBaseSize
=
item
.
FlexBaseSize
(
)
;
aLineInfo
-
>
mItems
[
itemIndex
]
.
mMainDeltaSize
=
0
;
+
+
itemIndex
;
}
}
const
bool
isUsingFlexGrow
=
(
mTotalOuterHypotheticalMainSize
<
aFlexContainerMainSize
)
;
if
(
aLineInfo
)
{
aLineInfo
-
>
mGrowthState
=
isUsingFlexGrow
?
mozilla
:
:
dom
:
:
FlexLineGrowthState
:
:
Growing
:
mozilla
:
:
dom
:
:
FlexLineGrowthState
:
:
Shrinking
;
}
FreezeItemsEarly
(
isUsingFlexGrow
aLineInfo
)
;
if
(
(
mNumFrozenItems
=
=
NumItems
(
)
)
&
&
!
aLineInfo
)
{
return
;
}
MOZ_ASSERT
(
!
IsEmpty
(
)
|
|
aLineInfo
"
empty
lines
should
take
the
early
-
return
above
"
)
;
nscoord
spaceAvailableForFlexItemsContentBoxes
=
aFlexContainerMainSize
-
(
mTotalItemMBP
+
SumOfGaps
(
)
)
;
nscoord
origAvailableFreeSpace
;
bool
isOrigAvailFreeSpaceInitialized
=
false
;
for
(
uint32_t
iterationCounter
=
0
;
iterationCounter
<
NumItems
(
)
;
iterationCounter
+
+
)
{
nscoord
availableFreeSpace
=
spaceAvailableForFlexItemsContentBoxes
;
for
(
FlexItem
&
item
:
Items
(
)
)
{
if
(
!
item
.
IsFrozen
(
)
)
{
item
.
SetMainSize
(
item
.
FlexBaseSize
(
)
)
;
}
availableFreeSpace
-
=
item
.
MainSize
(
)
;
}
FLEX_LOG
(
"
available
free
space
=
%
d
"
availableFreeSpace
)
;
NS_ASSERTION
(
(
isUsingFlexGrow
&
&
availableFreeSpace
>
=
0
)
|
|
(
!
isUsingFlexGrow
&
&
availableFreeSpace
<
=
0
)
"
availableFreeSpace
'
s
sign
should
match
isUsingFlexGrow
"
)
;
if
(
availableFreeSpace
!
=
0
)
{
if
(
!
isOrigAvailFreeSpaceInitialized
)
{
origAvailableFreeSpace
=
availableFreeSpace
;
isOrigAvailFreeSpaceInitialized
=
true
;
}
float
weightSum
=
0
.
0f
;
float
flexFactorSum
=
0
.
0f
;
float
largestWeight
=
0
.
0f
;
uint32_t
numItemsWithLargestWeight
=
0
;
uint32_t
numUnfrozenItemsToBeSeen
=
NumItems
(
)
-
mNumFrozenItems
;
for
(
FlexItem
&
item
:
Items
(
)
)
{
if
(
numUnfrozenItemsToBeSeen
=
=
0
)
{
break
;
}
if
(
!
item
.
IsFrozen
(
)
)
{
numUnfrozenItemsToBeSeen
-
-
;
float
curWeight
=
item
.
GetWeight
(
isUsingFlexGrow
)
;
float
curFlexFactor
=
item
.
GetFlexFactor
(
isUsingFlexGrow
)
;
MOZ_ASSERT
(
curWeight
>
=
0
.
0f
"
weights
are
non
-
negative
"
)
;
MOZ_ASSERT
(
curFlexFactor
>
=
0
.
0f
"
flex
factors
are
non
-
negative
"
)
;
weightSum
+
=
curWeight
;
flexFactorSum
+
=
curFlexFactor
;
if
(
IsFinite
(
weightSum
)
)
{
if
(
curWeight
=
=
0
.
0f
)
{
item
.
SetShareOfWeightSoFar
(
0
.
0f
)
;
}
else
{
item
.
SetShareOfWeightSoFar
(
curWeight
/
weightSum
)
;
}
}
if
(
curWeight
>
largestWeight
)
{
largestWeight
=
curWeight
;
numItemsWithLargestWeight
=
1
;
}
else
if
(
curWeight
=
=
largestWeight
)
{
numItemsWithLargestWeight
+
+
;
}
}
}
MOZ_ASSERT
(
numUnfrozenItemsToBeSeen
=
=
0
"
miscounted
frozen
items
?
"
)
;
if
(
weightSum
!
=
0
.
0f
)
{
MOZ_ASSERT
(
flexFactorSum
!
=
0
.
0f
"
flex
factor
sum
can
'
t
be
0
if
a
weighted
sum
"
"
of
its
components
(
weightSum
)
is
nonzero
"
)
;
if
(
flexFactorSum
<
1
.
0f
)
{
nscoord
totalDesiredPortionOfOrigFreeSpace
=
NSToCoordRound
(
origAvailableFreeSpace
*
flexFactorSum
)
;
NS_ASSERTION
(
totalDesiredPortionOfOrigFreeSpace
=
=
0
|
|
(
(
totalDesiredPortionOfOrigFreeSpace
>
0
)
=
=
(
availableFreeSpace
>
0
)
)
"
When
we
reduce
available
free
space
for
flex
"
"
factors
<
1
we
shouldn
'
t
change
the
sign
of
the
"
"
free
space
.
.
.
"
)
;
if
(
availableFreeSpace
>
0
)
{
availableFreeSpace
=
std
:
:
min
(
availableFreeSpace
totalDesiredPortionOfOrigFreeSpace
)
;
}
else
{
availableFreeSpace
=
std
:
:
max
(
availableFreeSpace
totalDesiredPortionOfOrigFreeSpace
)
;
}
}
FLEX_LOG
(
"
Distributing
available
space
:
"
)
;
numUnfrozenItemsToBeSeen
=
NumItems
(
)
-
mNumFrozenItems
;
for
(
FlexItem
&
item
:
Reversed
(
Items
(
)
)
)
{
if
(
numUnfrozenItemsToBeSeen
=
=
0
)
{
break
;
}
if
(
!
item
.
IsFrozen
(
)
)
{
numUnfrozenItemsToBeSeen
-
-
;
nscoord
sizeDelta
=
0
;
if
(
IsFinite
(
weightSum
)
)
{
float
myShareOfRemainingSpace
=
item
.
ShareOfWeightSoFar
(
)
;
MOZ_ASSERT
(
myShareOfRemainingSpace
>
=
0
.
0f
&
&
myShareOfRemainingSpace
<
=
1
.
0f
"
my
share
should
be
nonnegative
fractional
amount
"
)
;
if
(
myShareOfRemainingSpace
=
=
1
.
0f
)
{
sizeDelta
=
availableFreeSpace
;
}
else
if
(
myShareOfRemainingSpace
>
0
.
0f
)
{
sizeDelta
=
NSToCoordRound
(
availableFreeSpace
*
myShareOfRemainingSpace
)
;
}
}
else
if
(
item
.
GetWeight
(
isUsingFlexGrow
)
=
=
largestWeight
)
{
sizeDelta
=
NSToCoordRound
(
availableFreeSpace
/
float
(
numItemsWithLargestWeight
)
)
;
numItemsWithLargestWeight
-
-
;
}
availableFreeSpace
-
=
sizeDelta
;
item
.
SetMainSize
(
item
.
MainSize
(
)
+
sizeDelta
)
;
FLEX_LOG
(
"
child
%
p
receives
%
d
for
a
total
of
%
d
"
&
item
sizeDelta
item
.
MainSize
(
)
)
;
}
}
MOZ_ASSERT
(
numUnfrozenItemsToBeSeen
=
=
0
"
miscounted
frozen
items
?
"
)
;
if
(
aLineInfo
)
{
uint32_t
itemIndex
=
0
;
for
(
FlexItem
&
item
:
Items
(
)
)
{
if
(
!
item
.
IsFrozen
(
)
)
{
nscoord
deltaSize
=
item
.
MainSize
(
)
-
aLineInfo
-
>
mItems
[
itemIndex
]
.
mMainBaseSize
;
aLineInfo
-
>
mItems
[
itemIndex
]
.
mMainDeltaSize
=
deltaSize
;
}
+
+
itemIndex
;
}
}
}
}
nscoord
totalViolation
=
0
;
FLEX_LOG
(
"
Checking
for
violations
:
"
)
;
uint32_t
numUnfrozenItemsToBeSeen
=
NumItems
(
)
-
mNumFrozenItems
;
for
(
FlexItem
&
item
:
Items
(
)
)
{
if
(
numUnfrozenItemsToBeSeen
=
=
0
)
{
break
;
}
if
(
!
item
.
IsFrozen
(
)
)
{
numUnfrozenItemsToBeSeen
-
-
;
if
(
item
.
MainSize
(
)
<
item
.
MainMinSize
(
)
)
{
totalViolation
+
=
item
.
MainMinSize
(
)
-
item
.
MainSize
(
)
;
item
.
SetMainSize
(
item
.
MainMinSize
(
)
)
;
item
.
SetHadMinViolation
(
)
;
}
else
if
(
item
.
MainSize
(
)
>
item
.
MainMaxSize
(
)
)
{
totalViolation
+
=
item
.
MainMaxSize
(
)
-
item
.
MainSize
(
)
;
item
.
SetMainSize
(
item
.
MainMaxSize
(
)
)
;
item
.
SetHadMaxViolation
(
)
;
}
}
}
MOZ_ASSERT
(
numUnfrozenItemsToBeSeen
=
=
0
"
miscounted
frozen
items
?
"
)
;
FreezeOrRestoreEachFlexibleSize
(
totalViolation
iterationCounter
+
1
=
=
NumItems
(
)
)
;
FLEX_LOG
(
"
Total
violation
:
%
d
"
totalViolation
)
;
if
(
mNumFrozenItems
=
=
NumItems
(
)
)
{
break
;
}
MOZ_ASSERT
(
totalViolation
!
=
0
"
Zero
violation
should
'
ve
made
us
freeze
all
items
&
break
"
)
;
}
#
ifdef
DEBUG
MOZ_ASSERT
(
mNumFrozenItems
=
=
NumItems
(
)
"
All
items
should
be
frozen
"
)
;
for
(
const
FlexItem
&
item
:
Items
(
)
)
{
MOZ_ASSERT
(
item
.
IsFrozen
(
)
"
All
items
should
be
frozen
"
)
;
}
#
endif
}
MainAxisPositionTracker
:
:
MainAxisPositionTracker
(
const
FlexboxAxisTracker
&
aAxisTracker
const
FlexLine
*
aLine
const
StyleContentDistribution
&
aJustifyContent
nscoord
aContentBoxMainSize
)
:
PositionTracker
(
aAxisTracker
.
GetWritingMode
(
)
aAxisTracker
.
MainAxis
(
)
aAxisTracker
.
IsMainAxisReversed
(
)
)
mPackingSpaceRemaining
(
aContentBoxMainSize
)
mJustifyContent
(
aJustifyContent
)
{
StyleAlignFlags
justifyContentFlags
=
mJustifyContent
.
primary
&
StyleAlignFlags
:
:
FLAG_BITS
;
mJustifyContent
.
primary
&
=
~
StyleAlignFlags
:
:
FLAG_BITS
;
if
(
mJustifyContent
.
primary
=
=
StyleAlignFlags
:
:
NORMAL
|
|
mJustifyContent
.
primary
=
=
StyleAlignFlags
:
:
STRETCH
)
{
mJustifyContent
.
primary
=
StyleAlignFlags
:
:
FLEX_START
;
}
for
(
const
FlexItem
&
item
:
aLine
-
>
Items
(
)
)
{
mPackingSpaceRemaining
-
=
item
.
OuterMainSize
(
)
;
mNumAutoMarginsInMainAxis
+
=
item
.
NumAutoMarginsInMainAxis
(
)
;
}
mPackingSpaceRemaining
-
=
aLine
-
>
SumOfGaps
(
)
;
if
(
mPackingSpaceRemaining
<
=
0
)
{
mNumAutoMarginsInMainAxis
=
0
;
if
(
justifyContentFlags
&
StyleAlignFlags
:
:
SAFE
)
{
mJustifyContent
.
primary
=
StyleAlignFlags
:
:
START
;
}
}
if
(
mPackingSpaceRemaining
<
0
|
|
aLine
-
>
NumItems
(
)
=
=
1
)
{
if
(
mJustifyContent
.
primary
=
=
StyleAlignFlags
:
:
SPACE_BETWEEN
)
{
mJustifyContent
.
primary
=
StyleAlignFlags
:
:
FLEX_START
;
}
else
if
(
mJustifyContent
.
primary
=
=
StyleAlignFlags
:
:
SPACE_AROUND
|
|
mJustifyContent
.
primary
=
=
StyleAlignFlags
:
:
SPACE_EVENLY
)
{
mJustifyContent
.
primary
=
StyleAlignFlags
:
:
CENTER
;
}
}
if
(
mJustifyContent
.
primary
=
=
StyleAlignFlags
:
:
LEFT
|
|
mJustifyContent
.
primary
=
=
StyleAlignFlags
:
:
RIGHT
)
{
if
(
aAxisTracker
.
IsColumnOriented
(
)
)
{
mJustifyContent
.
primary
=
StyleAlignFlags
:
:
START
;
}
else
{
const
bool
isLTR
=
aAxisTracker
.
GetWritingMode
(
)
.
IsBidiLTR
(
)
;
const
bool
isJustifyLeft
=
(
mJustifyContent
.
primary
=
=
StyleAlignFlags
:
:
LEFT
)
;
mJustifyContent
.
primary
=
(
isJustifyLeft
=
=
isLTR
)
?
StyleAlignFlags
:
:
START
:
StyleAlignFlags
:
:
END
;
}
}
if
(
mJustifyContent
.
primary
=
=
StyleAlignFlags
:
:
START
)
{
mJustifyContent
.
primary
=
aAxisTracker
.
IsMainAxisReversed
(
)
?
StyleAlignFlags
:
:
FLEX_END
:
StyleAlignFlags
:
:
FLEX_START
;
}
else
if
(
mJustifyContent
.
primary
=
=
StyleAlignFlags
:
:
END
)
{
mJustifyContent
.
primary
=
aAxisTracker
.
IsMainAxisReversed
(
)
?
StyleAlignFlags
:
:
FLEX_START
:
StyleAlignFlags
:
:
FLEX_END
;
}
if
(
mNumAutoMarginsInMainAxis
=
=
0
&
&
mPackingSpaceRemaining
!
=
0
&
&
!
aLine
-
>
IsEmpty
(
)
)
{
if
(
mJustifyContent
.
primary
=
=
StyleAlignFlags
:
:
FLEX_START
)
{
}
else
if
(
mJustifyContent
.
primary
=
=
StyleAlignFlags
:
:
FLEX_END
)
{
mPosition
+
=
mPackingSpaceRemaining
;
}
else
if
(
mJustifyContent
.
primary
=
=
StyleAlignFlags
:
:
CENTER
)
{
mPosition
+
=
mPackingSpaceRemaining
/
2
;
}
else
if
(
mJustifyContent
.
primary
=
=
StyleAlignFlags
:
:
SPACE_BETWEEN
|
|
mJustifyContent
.
primary
=
=
StyleAlignFlags
:
:
SPACE_AROUND
|
|
mJustifyContent
.
primary
=
=
StyleAlignFlags
:
:
SPACE_EVENLY
)
{
nsFlexContainerFrame
:
:
CalculatePackingSpace
(
aLine
-
>
NumItems
(
)
mJustifyContent
&
mPosition
&
mNumPackingSpacesRemaining
&
mPackingSpaceRemaining
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
justify
-
content
value
"
)
;
}
}
MOZ_ASSERT
(
mNumPackingSpacesRemaining
=
=
0
|
|
mNumAutoMarginsInMainAxis
=
=
0
"
extra
space
should
either
go
to
packing
space
or
to
"
"
auto
margins
but
not
to
both
"
)
;
}
void
MainAxisPositionTracker
:
:
ResolveAutoMarginsInMainAxis
(
FlexItem
&
aItem
)
{
if
(
mNumAutoMarginsInMainAxis
)
{
const
auto
&
styleMargin
=
aItem
.
Frame
(
)
-
>
StyleMargin
(
)
-
>
mMargin
;
for
(
const
auto
side
:
{
StartSide
(
)
EndSide
(
)
}
)
{
if
(
styleMargin
.
Get
(
mWM
side
)
.
IsAuto
(
)
)
{
nscoord
curAutoMarginSize
=
mPackingSpaceRemaining
/
mNumAutoMarginsInMainAxis
;
MOZ_ASSERT
(
aItem
.
GetMarginComponentForSide
(
side
)
=
=
0
"
Expecting
auto
margins
to
have
value
'
0
'
before
we
"
"
resolve
them
"
)
;
aItem
.
SetMarginComponentForSide
(
side
curAutoMarginSize
)
;
mNumAutoMarginsInMainAxis
-
-
;
mPackingSpaceRemaining
-
=
curAutoMarginSize
;
}
}
}
}
void
MainAxisPositionTracker
:
:
TraversePackingSpace
(
)
{
if
(
mNumPackingSpacesRemaining
)
{
MOZ_ASSERT
(
mJustifyContent
.
primary
=
=
StyleAlignFlags
:
:
SPACE_BETWEEN
|
|
mJustifyContent
.
primary
=
=
StyleAlignFlags
:
:
SPACE_AROUND
|
|
mJustifyContent
.
primary
=
=
StyleAlignFlags
:
:
SPACE_EVENLY
"
mNumPackingSpacesRemaining
only
applies
for
"
"
space
-
between
/
space
-
around
/
space
-
evenly
"
)
;
MOZ_ASSERT
(
mPackingSpaceRemaining
>
=
0
"
ran
out
of
packing
space
earlier
than
we
expected
"
)
;
nscoord
curPackingSpace
=
mPackingSpaceRemaining
/
mNumPackingSpacesRemaining
;
mPosition
+
=
curPackingSpace
;
mNumPackingSpacesRemaining
-
-
;
mPackingSpaceRemaining
-
=
curPackingSpace
;
}
}
CrossAxisPositionTracker
:
:
CrossAxisPositionTracker
(
nsTArray
<
FlexLine
>
&
aLines
const
ReflowInput
&
aReflowInput
nscoord
aContentBoxCrossSize
bool
aIsCrossSizeDefinite
const
FlexboxAxisTracker
&
aAxisTracker
const
nscoord
aCrossGapSize
)
:
PositionTracker
(
aAxisTracker
.
GetWritingMode
(
)
aAxisTracker
.
CrossAxis
(
)
aAxisTracker
.
IsCrossAxisReversed
(
)
)
mAlignContent
(
aReflowInput
.
mStylePosition
-
>
mAlignContent
)
mCrossGapSize
(
aCrossGapSize
)
{
StyleAlignFlags
alignContentFlags
=
mAlignContent
.
primary
&
StyleAlignFlags
:
:
FLAG_BITS
;
mAlignContent
.
primary
&
=
~
StyleAlignFlags
:
:
FLAG_BITS
;
if
(
mAlignContent
.
primary
=
=
StyleAlignFlags
:
:
NORMAL
)
{
mAlignContent
.
primary
=
StyleAlignFlags
:
:
STRETCH
;
}
const
bool
isSingleLine
=
StyleFlexWrap
:
:
Nowrap
=
=
aReflowInput
.
mStylePosition
-
>
mFlexWrap
;
if
(
isSingleLine
)
{
MOZ_ASSERT
(
aLines
.
Length
(
)
=
=
1
"
If
we
'
re
styled
as
single
-
line
we
should
only
have
1
line
"
)
;
if
(
aIsCrossSizeDefinite
)
{
aLines
[
0
]
.
SetLineCrossSize
(
aContentBoxCrossSize
)
;
return
;
}
aLines
[
0
]
.
SetLineCrossSize
(
NS_CSS_MINMAX
(
aLines
[
0
]
.
LineCrossSize
(
)
aReflowInput
.
ComputedMinBSize
(
)
aReflowInput
.
ComputedMaxBSize
(
)
)
)
;
}
mPackingSpaceRemaining
=
aContentBoxCrossSize
;
uint32_t
numLines
=
0
;
for
(
FlexLine
&
line
:
aLines
)
{
mPackingSpaceRemaining
-
=
line
.
LineCrossSize
(
)
;
numLines
+
+
;
}
MOZ_ASSERT
(
numLines
>
=
1
"
GenerateFlexLines
should
'
ve
produced
at
least
1
line
"
)
;
mPackingSpaceRemaining
-
=
aCrossGapSize
*
(
numLines
-
1
)
;
if
(
(
alignContentFlags
&
StyleAlignFlags
:
:
SAFE
)
&
&
mPackingSpaceRemaining
<
0
)
{
mAlignContent
.
primary
=
StyleAlignFlags
:
:
START
;
}
if
(
mPackingSpaceRemaining
<
0
&
&
mAlignContent
.
primary
=
=
StyleAlignFlags
:
:
STRETCH
)
{
mAlignContent
.
primary
=
StyleAlignFlags
:
:
FLEX_START
;
}
else
if
(
mPackingSpaceRemaining
<
0
|
|
numLines
=
=
1
)
{
if
(
mAlignContent
.
primary
=
=
StyleAlignFlags
:
:
SPACE_BETWEEN
)
{
mAlignContent
.
primary
=
StyleAlignFlags
:
:
FLEX_START
;
}
else
if
(
mAlignContent
.
primary
=
=
StyleAlignFlags
:
:
SPACE_AROUND
|
|
mAlignContent
.
primary
=
=
StyleAlignFlags
:
:
SPACE_EVENLY
)
{
mAlignContent
.
primary
=
StyleAlignFlags
:
:
CENTER
;
}
}
if
(
mAlignContent
.
primary
=
=
StyleAlignFlags
:
:
START
)
{
mAlignContent
.
primary
=
aAxisTracker
.
IsCrossAxisReversed
(
)
?
StyleAlignFlags
:
:
FLEX_END
:
StyleAlignFlags
:
:
FLEX_START
;
}
else
if
(
mAlignContent
.
primary
=
=
StyleAlignFlags
:
:
END
)
{
mAlignContent
.
primary
=
aAxisTracker
.
IsCrossAxisReversed
(
)
?
StyleAlignFlags
:
:
FLEX_START
:
StyleAlignFlags
:
:
FLEX_END
;
}
if
(
mPackingSpaceRemaining
!
=
0
)
{
if
(
mAlignContent
.
primary
=
=
StyleAlignFlags
:
:
BASELINE
|
|
mAlignContent
.
primary
=
=
StyleAlignFlags
:
:
LAST_BASELINE
)
{
NS_WARNING
(
"
NYI
:
"
"
align
-
items
/
align
-
self
:
left
/
right
/
self
-
start
/
self
-
end
/
baseline
/
"
"
last
baseline
"
)
;
}
else
if
(
mAlignContent
.
primary
=
=
StyleAlignFlags
:
:
FLEX_START
)
{
}
else
if
(
mAlignContent
.
primary
=
=
StyleAlignFlags
:
:
FLEX_END
)
{
mPosition
+
=
mPackingSpaceRemaining
;
}
else
if
(
mAlignContent
.
primary
=
=
StyleAlignFlags
:
:
CENTER
)
{
mPosition
+
=
mPackingSpaceRemaining
/
2
;
}
else
if
(
mAlignContent
.
primary
=
=
StyleAlignFlags
:
:
SPACE_BETWEEN
|
|
mAlignContent
.
primary
=
=
StyleAlignFlags
:
:
SPACE_AROUND
|
|
mAlignContent
.
primary
=
=
StyleAlignFlags
:
:
SPACE_EVENLY
)
{
nsFlexContainerFrame
:
:
CalculatePackingSpace
(
numLines
mAlignContent
&
mPosition
&
mNumPackingSpacesRemaining
&
mPackingSpaceRemaining
)
;
}
else
if
(
mAlignContent
.
primary
=
=
StyleAlignFlags
:
:
STRETCH
)
{
MOZ_ASSERT
(
mPackingSpaceRemaining
>
0
"
negative
packing
space
should
make
us
use
'
flex
-
start
'
"
"
instead
of
'
stretch
'
(
and
we
shouldn
'
t
bother
with
this
"
"
code
if
we
have
0
packing
space
)
"
)
;
uint32_t
numLinesLeft
=
numLines
;
for
(
FlexLine
&
line
:
aLines
)
{
MOZ_ASSERT
(
numLinesLeft
>
0
"
miscalculated
num
lines
"
)
;
nscoord
shareOfExtraSpace
=
mPackingSpaceRemaining
/
numLinesLeft
;
nscoord
newSize
=
line
.
LineCrossSize
(
)
+
shareOfExtraSpace
;
line
.
SetLineCrossSize
(
newSize
)
;
mPackingSpaceRemaining
-
=
shareOfExtraSpace
;
numLinesLeft
-
-
;
}
MOZ_ASSERT
(
numLinesLeft
=
=
0
"
miscalculated
num
lines
"
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
align
-
content
value
"
)
;
}
}
}
void
CrossAxisPositionTracker
:
:
TraversePackingSpace
(
)
{
if
(
mNumPackingSpacesRemaining
)
{
MOZ_ASSERT
(
mAlignContent
.
primary
=
=
StyleAlignFlags
:
:
SPACE_BETWEEN
|
|
mAlignContent
.
primary
=
=
StyleAlignFlags
:
:
SPACE_AROUND
|
|
mAlignContent
.
primary
=
=
StyleAlignFlags
:
:
SPACE_EVENLY
"
mNumPackingSpacesRemaining
only
applies
for
"
"
space
-
between
/
space
-
around
/
space
-
evenly
"
)
;
MOZ_ASSERT
(
mPackingSpaceRemaining
>
=
0
"
ran
out
of
packing
space
earlier
than
we
expected
"
)
;
nscoord
curPackingSpace
=
mPackingSpaceRemaining
/
mNumPackingSpacesRemaining
;
mPosition
+
=
curPackingSpace
;
mNumPackingSpacesRemaining
-
-
;
mPackingSpaceRemaining
-
=
curPackingSpace
;
}
}
SingleLineCrossAxisPositionTracker
:
:
SingleLineCrossAxisPositionTracker
(
const
FlexboxAxisTracker
&
aAxisTracker
)
:
PositionTracker
(
aAxisTracker
.
GetWritingMode
(
)
aAxisTracker
.
CrossAxis
(
)
aAxisTracker
.
IsCrossAxisReversed
(
)
)
{
}
void
FlexLine
:
:
ComputeCrossSizeAndBaseline
(
const
FlexboxAxisTracker
&
aAxisTracker
)
{
nscoord
crossStartToFurthestFirstBaseline
=
nscoord_MIN
;
nscoord
crossEndToFurthestFirstBaseline
=
nscoord_MIN
;
nscoord
crossStartToFurthestLastBaseline
=
nscoord_MIN
;
nscoord
crossEndToFurthestLastBaseline
=
nscoord_MIN
;
nscoord
largestOuterCrossSize
=
0
;
for
(
const
FlexItem
&
item
:
Items
(
)
)
{
nscoord
curOuterCrossSize
=
item
.
OuterCrossSize
(
)
;
if
(
(
item
.
AlignSelf
(
)
.
_0
=
=
StyleAlignFlags
:
:
BASELINE
|
|
item
.
AlignSelf
(
)
.
_0
=
=
StyleAlignFlags
:
:
LAST_BASELINE
)
&
&
item
.
NumAutoMarginsInCrossAxis
(
)
=
=
0
)
{
const
bool
useFirst
=
(
item
.
AlignSelf
(
)
.
_0
=
=
StyleAlignFlags
:
:
BASELINE
)
;
nscoord
crossStartToBaseline
=
item
.
BaselineOffsetFromOuterCrossEdge
(
aAxisTracker
.
CrossAxisPhysicalStartSide
(
)
useFirst
)
;
nscoord
crossEndToBaseline
=
curOuterCrossSize
-
crossStartToBaseline
;
if
(
useFirst
)
{
crossStartToFurthestFirstBaseline
=
std
:
:
max
(
crossStartToFurthestFirstBaseline
crossStartToBaseline
)
;
crossEndToFurthestFirstBaseline
=
std
:
:
max
(
crossEndToFurthestFirstBaseline
crossEndToBaseline
)
;
}
else
{
crossStartToFurthestLastBaseline
=
std
:
:
max
(
crossStartToFurthestLastBaseline
crossStartToBaseline
)
;
crossEndToFurthestLastBaseline
=
std
:
:
max
(
crossEndToFurthestLastBaseline
crossEndToBaseline
)
;
}
}
else
{
largestOuterCrossSize
=
std
:
:
max
(
largestOuterCrossSize
curOuterCrossSize
)
;
}
}
mFirstBaselineOffset
=
crossStartToFurthestFirstBaseline
;
mLastBaselineOffset
=
crossEndToFurthestLastBaseline
;
mLineCrossSize
=
std
:
:
max
(
std
:
:
max
(
crossStartToFurthestFirstBaseline
+
crossEndToFurthestFirstBaseline
crossStartToFurthestLastBaseline
+
crossEndToFurthestLastBaseline
)
largestOuterCrossSize
)
;
}
void
FlexItem
:
:
ResolveStretchedCrossSize
(
nscoord
aLineCrossSize
)
{
if
(
mAlignSelf
.
_0
!
=
StyleAlignFlags
:
:
STRETCH
|
|
NumAutoMarginsInCrossAxis
(
)
!
=
0
|
|
!
IsCrossSizeAuto
(
)
)
{
return
;
}
if
(
mIsStretched
)
{
return
;
}
nscoord
stretchedSize
=
aLineCrossSize
-
MarginBorderPaddingSizeInCrossAxis
(
)
;
stretchedSize
=
NS_CSS_MINMAX
(
stretchedSize
mCrossMinSize
mCrossMaxSize
)
;
SetCrossSize
(
stretchedSize
)
;
mIsStretched
=
true
;
}
static
nsBlockFrame
*
FindFlexItemBlockFrame
(
nsIFrame
*
aFrame
)
{
if
(
nsBlockFrame
*
block
=
do_QueryFrame
(
aFrame
)
)
{
return
block
;
}
for
(
nsIFrame
*
f
:
aFrame
-
>
PrincipalChildList
(
)
)
{
if
(
nsBlockFrame
*
block
=
FindFlexItemBlockFrame
(
f
)
)
{
return
block
;
}
}
return
nullptr
;
}
nsBlockFrame
*
FlexItem
:
:
BlockFrame
(
)
const
{
return
FindFlexItemBlockFrame
(
Frame
(
)
)
;
}
void
SingleLineCrossAxisPositionTracker
:
:
ResolveAutoMarginsInCrossAxis
(
const
FlexLine
&
aLine
FlexItem
&
aItem
)
{
nscoord
spaceForAutoMargins
=
aLine
.
LineCrossSize
(
)
-
aItem
.
OuterCrossSize
(
)
;
if
(
spaceForAutoMargins
<
=
0
)
{
return
;
}
uint32_t
numAutoMargins
=
aItem
.
NumAutoMarginsInCrossAxis
(
)
;
if
(
numAutoMargins
=
=
0
)
{
return
;
}
const
auto
&
styleMargin
=
aItem
.
Frame
(
)
-
>
StyleMargin
(
)
-
>
mMargin
;
for
(
const
auto
side
:
{
StartSide
(
)
EndSide
(
)
}
)
{
if
(
styleMargin
.
Get
(
mWM
side
)
.
IsAuto
(
)
)
{
MOZ_ASSERT
(
aItem
.
GetMarginComponentForSide
(
side
)
=
=
0
"
Expecting
auto
margins
to
have
value
'
0
'
before
we
"
"
update
them
"
)
;
nscoord
curAutoMarginSize
=
spaceForAutoMargins
/
numAutoMargins
;
aItem
.
SetMarginComponentForSide
(
side
curAutoMarginSize
)
;
numAutoMargins
-
-
;
spaceForAutoMargins
-
=
curAutoMarginSize
;
}
}
}
void
SingleLineCrossAxisPositionTracker
:
:
EnterAlignPackingSpace
(
const
FlexLine
&
aLine
const
FlexItem
&
aItem
const
FlexboxAxisTracker
&
aAxisTracker
)
{
if
(
aItem
.
NumAutoMarginsInCrossAxis
(
)
)
{
return
;
}
StyleAlignFlags
alignSelf
=
aItem
.
AlignSelf
(
)
.
_0
;
if
(
alignSelf
=
=
StyleAlignFlags
:
:
STRETCH
)
{
alignSelf
=
StyleAlignFlags
:
:
FLEX_START
;
}
if
(
alignSelf
=
=
StyleAlignFlags
:
:
SELF_START
|
|
alignSelf
=
=
StyleAlignFlags
:
:
SELF_END
)
{
const
LogicalAxis
logCrossAxis
=
aAxisTracker
.
IsRowOriented
(
)
?
eLogicalAxisBlock
:
eLogicalAxisInline
;
const
WritingMode
cWM
=
aAxisTracker
.
GetWritingMode
(
)
;
const
bool
sameStart
=
cWM
.
ParallelAxisStartsOnSameSide
(
logCrossAxis
aItem
.
GetWritingMode
(
)
)
;
alignSelf
=
sameStart
=
=
(
alignSelf
=
=
StyleAlignFlags
:
:
SELF_START
)
?
StyleAlignFlags
:
:
START
:
StyleAlignFlags
:
:
END
;
}
if
(
alignSelf
=
=
StyleAlignFlags
:
:
START
)
{
alignSelf
=
aAxisTracker
.
IsCrossAxisReversed
(
)
?
StyleAlignFlags
:
:
FLEX_END
:
StyleAlignFlags
:
:
FLEX_START
;
}
else
if
(
alignSelf
=
=
StyleAlignFlags
:
:
END
)
{
alignSelf
=
aAxisTracker
.
IsCrossAxisReversed
(
)
?
StyleAlignFlags
:
:
FLEX_START
:
StyleAlignFlags
:
:
FLEX_END
;
}
if
(
aLine
.
LineCrossSize
(
)
<
aItem
.
OuterCrossSize
(
)
&
&
(
aItem
.
AlignSelfFlags
(
)
&
StyleAlignFlags
:
:
SAFE
)
)
{
alignSelf
=
StyleAlignFlags
:
:
FLEX_START
;
}
if
(
alignSelf
=
=
StyleAlignFlags
:
:
FLEX_START
)
{
}
else
if
(
alignSelf
=
=
StyleAlignFlags
:
:
FLEX_END
)
{
mPosition
+
=
aLine
.
LineCrossSize
(
)
-
aItem
.
OuterCrossSize
(
)
;
}
else
if
(
alignSelf
=
=
StyleAlignFlags
:
:
CENTER
)
{
mPosition
+
=
(
aLine
.
LineCrossSize
(
)
-
aItem
.
OuterCrossSize
(
)
)
/
2
;
}
else
if
(
alignSelf
=
=
StyleAlignFlags
:
:
BASELINE
|
|
alignSelf
=
=
StyleAlignFlags
:
:
LAST_BASELINE
)
{
const
bool
useFirst
=
(
alignSelf
=
=
StyleAlignFlags
:
:
BASELINE
)
;
const
mozilla
:
:
Side
baselineAlignStartSide
=
useFirst
?
aAxisTracker
.
CrossAxisPhysicalStartSide
(
)
:
aAxisTracker
.
CrossAxisPhysicalEndSide
(
)
;
nscoord
itemBaselineOffset
=
aItem
.
BaselineOffsetFromOuterCrossEdge
(
baselineAlignStartSide
useFirst
)
;
nscoord
lineBaselineOffset
=
useFirst
?
aLine
.
FirstBaselineOffset
(
)
:
aLine
.
LastBaselineOffset
(
)
;
NS_ASSERTION
(
lineBaselineOffset
>
=
itemBaselineOffset
"
failed
at
finding
largest
baseline
offset
"
)
;
nscoord
baselineDiff
=
lineBaselineOffset
-
itemBaselineOffset
;
if
(
useFirst
)
{
mPosition
+
=
baselineDiff
;
}
else
{
mPosition
+
=
aLine
.
LineCrossSize
(
)
-
aItem
.
OuterCrossSize
(
)
;
mPosition
-
=
baselineDiff
;
}
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
align
-
self
value
"
)
;
}
}
FlexboxAxisInfo
:
:
FlexboxAxisInfo
(
const
nsIFrame
*
aFlexContainer
)
{
MOZ_ASSERT
(
aFlexContainer
&
&
aFlexContainer
-
>
IsFlexContainerFrame
(
)
"
Only
flex
containers
may
be
passed
to
this
constructor
!
"
)
;
if
(
IsLegacyBox
(
aFlexContainer
)
)
{
InitAxesFromLegacyProps
(
aFlexContainer
)
;
}
else
{
InitAxesFromModernProps
(
aFlexContainer
)
;
}
}
void
FlexboxAxisInfo
:
:
InitAxesFromLegacyProps
(
const
nsIFrame
*
aFlexContainer
)
{
const
nsStyleXUL
*
styleXUL
=
aFlexContainer
-
>
StyleXUL
(
)
;
const
bool
boxOrientIsVertical
=
(
styleXUL
-
>
mBoxOrient
=
=
StyleBoxOrient
:
:
Vertical
)
;
const
bool
wmIsVertical
=
aFlexContainer
-
>
GetWritingMode
(
)
.
IsVertical
(
)
;
mIsRowOriented
=
(
boxOrientIsVertical
=
=
wmIsVertical
)
;
mIsMainAxisReversed
=
styleXUL
-
>
mBoxDirection
=
=
StyleBoxDirection
:
:
Reverse
;
mIsCrossAxisReversed
=
false
;
}
void
FlexboxAxisInfo
:
:
InitAxesFromModernProps
(
const
nsIFrame
*
aFlexContainer
)
{
const
nsStylePosition
*
stylePos
=
aFlexContainer
-
>
StylePosition
(
)
;
StyleFlexDirection
flexDirection
=
stylePos
-
>
mFlexDirection
;
switch
(
flexDirection
)
{
case
StyleFlexDirection
:
:
Row
:
mIsRowOriented
=
true
;
mIsMainAxisReversed
=
false
;
break
;
case
StyleFlexDirection
:
:
RowReverse
:
mIsRowOriented
=
true
;
mIsMainAxisReversed
=
true
;
break
;
case
StyleFlexDirection
:
:
Column
:
mIsRowOriented
=
false
;
mIsMainAxisReversed
=
false
;
break
;
case
StyleFlexDirection
:
:
ColumnReverse
:
mIsRowOriented
=
false
;
mIsMainAxisReversed
=
true
;
break
;
}
mIsCrossAxisReversed
=
stylePos
-
>
mFlexWrap
=
=
StyleFlexWrap
:
:
WrapReverse
;
}
FlexboxAxisTracker
:
:
FlexboxAxisTracker
(
const
nsFlexContainerFrame
*
aFlexContainer
)
:
mWM
(
aFlexContainer
-
>
GetWritingMode
(
)
)
mAxisInfo
(
aFlexContainer
)
{
}
LogicalSide
FlexboxAxisTracker
:
:
MainAxisStartSide
(
)
const
{
return
MakeLogicalSide
(
MainAxis
(
)
IsMainAxisReversed
(
)
?
eLogicalEdgeEnd
:
eLogicalEdgeStart
)
;
}
LogicalSide
FlexboxAxisTracker
:
:
CrossAxisStartSide
(
)
const
{
return
MakeLogicalSide
(
CrossAxis
(
)
IsCrossAxisReversed
(
)
?
eLogicalEdgeEnd
:
eLogicalEdgeStart
)
;
}
bool
nsFlexContainerFrame
:
:
ShouldUseMozBoxCollapseBehavior
(
const
nsStyleDisplay
*
aFlexStyleDisp
)
{
MOZ_ASSERT
(
StyleDisplay
(
)
=
=
aFlexStyleDisp
"
wrong
StyleDisplay
passed
in
"
)
;
if
(
!
IsLegacyBox
(
this
)
)
{
return
false
;
}
if
(
aFlexStyleDisp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
MozBox
|
|
aFlexStyleDisp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
MozInlineBox
)
{
return
true
;
}
auto
pseudoType
=
Style
(
)
-
>
GetPseudoType
(
)
;
if
(
pseudoType
=
=
PseudoStyleType
:
:
scrolledContent
|
|
pseudoType
=
=
PseudoStyleType
:
:
buttonContent
)
{
const
nsStyleDisplay
*
disp
=
GetParent
(
)
-
>
StyleDisplay
(
)
;
if
(
disp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
MozBox
|
|
disp
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
MozInlineBox
)
{
return
true
;
}
}
return
false
;
}
void
nsFlexContainerFrame
:
:
GenerateFlexLines
(
const
ReflowInput
&
aReflowInput
nscoord
aContentBoxMainSize
const
nsTArray
<
StrutInfo
>
&
aStruts
const
FlexboxAxisTracker
&
aAxisTracker
nscoord
aMainGapSize
bool
aHasLineClampEllipsis
nsTArray
<
nsIFrame
*
>
&
aPlaceholders
nsTArray
<
FlexLine
>
&
aLines
)
{
MOZ_ASSERT
(
aLines
.
IsEmpty
(
)
"
Expecting
outparam
to
start
out
empty
"
)
;
auto
ConstructNewFlexLine
=
[
&
aLines
aMainGapSize
]
(
)
{
return
aLines
.
EmplaceBack
(
aMainGapSize
)
;
}
;
const
bool
isSingleLine
=
StyleFlexWrap
:
:
Nowrap
=
=
aReflowInput
.
mStylePosition
-
>
mFlexWrap
;
FlexLine
*
curLine
=
ConstructNewFlexLine
(
)
;
nscoord
wrapThreshold
;
if
(
isSingleLine
)
{
wrapThreshold
=
NS_UNCONSTRAINEDSIZE
;
}
else
{
wrapThreshold
=
aContentBoxMainSize
;
if
(
wrapThreshold
=
=
NS_UNCONSTRAINEDSIZE
)
{
const
nscoord
flexContainerMaxMainSize
=
GET_MAIN_COMPONENT_LOGICAL
(
aAxisTracker
aAxisTracker
.
GetWritingMode
(
)
aReflowInput
.
ComputedMaxISize
(
)
aReflowInput
.
ComputedMaxBSize
(
)
)
;
wrapThreshold
=
flexContainerMaxMainSize
;
}
}
uint32_t
nextStrutIdx
=
0
;
uint32_t
itemIdxInContainer
=
0
;
CSSOrderAwareFrameIterator
iter
(
this
kPrincipalList
CSSOrderAwareFrameIterator
:
:
eIncludeAll
CSSOrderAwareFrameIterator
:
:
eUnknownOrder
OrderingPropertyForIter
(
this
)
)
;
AddOrRemoveStateBits
(
NS_STATE_FLEX_NORMAL_FLOW_CHILDREN_IN_CSS_ORDER
iter
.
ItemsAreAlreadyInOrder
(
)
)
;
bool
prevItemRequestedBreakAfter
=
false
;
const
bool
useMozBoxCollapseBehavior
=
ShouldUseMozBoxCollapseBehavior
(
aReflowInput
.
mStyleDisplay
)
;
for
(
;
!
iter
.
AtEnd
(
)
;
iter
.
Next
(
)
)
{
nsIFrame
*
childFrame
=
*
iter
;
if
(
childFrame
-
>
IsPlaceholderFrame
(
)
)
{
aPlaceholders
.
AppendElement
(
childFrame
)
;
continue
;
}
if
(
!
isSingleLine
&
&
!
curLine
-
>
IsEmpty
(
)
&
&
(
prevItemRequestedBreakAfter
|
|
childFrame
-
>
StyleDisplay
(
)
-
>
BreakBefore
(
)
)
)
{
curLine
=
ConstructNewFlexLine
(
)
;
prevItemRequestedBreakAfter
=
false
;
}
if
(
useMozBoxCollapseBehavior
&
&
(
StyleVisibility
:
:
Collapse
=
=
childFrame
-
>
StyleVisibility
(
)
-
>
mVisible
)
)
{
curLine
-
>
Items
(
)
.
EmplaceBack
(
childFrame
0
aReflowInput
.
GetWritingMode
(
)
aAxisTracker
)
;
}
else
if
(
nextStrutIdx
<
aStruts
.
Length
(
)
&
&
aStruts
[
nextStrutIdx
]
.
mItemIdx
=
=
itemIdxInContainer
)
{
curLine
-
>
Items
(
)
.
EmplaceBack
(
childFrame
aStruts
[
nextStrutIdx
]
.
mStrutCrossSize
aReflowInput
.
GetWritingMode
(
)
aAxisTracker
)
;
nextStrutIdx
+
+
;
}
else
{
GenerateFlexItemForChild
(
*
curLine
childFrame
aReflowInput
aAxisTracker
aHasLineClampEllipsis
)
;
}
if
(
wrapThreshold
!
=
NS_UNCONSTRAINEDSIZE
&
&
curLine
-
>
Items
(
)
.
Length
(
)
>
1
)
{
nscoord
newOuterSize
=
AddChecked
(
curLine
-
>
TotalOuterHypotheticalMainSize
(
)
curLine
-
>
Items
(
)
.
LastElement
(
)
.
OuterMainSize
(
)
)
;
newOuterSize
=
AddChecked
(
newOuterSize
aMainGapSize
)
;
if
(
newOuterSize
=
=
nscoord_MAX
|
|
newOuterSize
>
wrapThreshold
)
{
curLine
=
ConstructNewFlexLine
(
)
;
FlexLine
&
prevLine
=
aLines
[
aLines
.
Length
(
)
-
2
]
;
curLine
-
>
Items
(
)
.
AppendElement
(
prevLine
.
Items
(
)
.
PopLastElement
(
)
)
;
}
}
curLine
-
>
AddLastItemToMainSizeTotals
(
)
;
if
(
!
isSingleLine
&
&
childFrame
-
>
StyleDisplay
(
)
-
>
BreakAfter
(
)
)
{
prevItemRequestedBreakAfter
=
true
;
}
itemIdxInContainer
+
+
;
}
}
void
nsFlexContainerFrame
:
:
GenerateFlexLines
(
const
SharedFlexData
&
aData
nsTArray
<
FlexLine
>
&
aLines
)
{
MOZ_ASSERT
(
GetPrevInFlow
(
)
"
This
should
be
called
by
non
-
first
-
in
-
flows
!
"
)
;
aLines
.
AppendElement
(
FlexLine
(
0
)
)
;
AddOrRemoveStateBits
(
NS_STATE_FLEX_NORMAL_FLOW_CHILDREN_IN_CSS_ORDER
GetPrevInFlow
(
)
-
>
HasAnyStateBits
(
NS_STATE_FLEX_NORMAL_FLOW_CHILDREN_IN_CSS_ORDER
)
)
;
CSSOrderAwareFrameIterator
iter
(
this
kPrincipalList
CSSOrderAwareFrameIterator
:
:
eSkipPlaceholders
OrderStateForIter
(
this
)
OrderingPropertyForIter
(
this
)
)
;
FlexItemIterator
itemIter
(
aData
.
mLines
)
;
for
(
;
!
iter
.
AtEnd
(
)
;
iter
.
Next
(
)
)
{
nsIFrame
*
const
child
=
*
iter
;
nsIFrame
*
const
childFirstInFlow
=
child
-
>
FirstInFlow
(
)
;
MOZ_ASSERT
(
!
itemIter
.
AtEnd
(
)
"
Why
can
'
t
we
find
FlexItem
for
our
child
frame
?
"
)
;
for
(
;
!
itemIter
.
AtEnd
(
)
;
itemIter
.
Next
(
)
)
{
if
(
itemIter
-
>
Frame
(
)
=
=
childFirstInFlow
)
{
aLines
[
0
]
.
Items
(
)
.
AppendElement
(
itemIter
-
>
CloneFor
(
child
)
)
;
itemIter
.
Next
(
)
;
break
;
}
}
}
}
nscoord
nsFlexContainerFrame
:
:
GetMainSizeFromReflowInput
(
const
ReflowInput
&
aReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
)
{
if
(
aAxisTracker
.
IsRowOriented
(
)
)
{
NS_WARNING_ASSERTION
(
aReflowInput
.
ComputedISize
(
)
!
=
NS_UNCONSTRAINEDSIZE
"
Unconstrained
inline
size
;
this
should
only
result
from
huge
sizes
"
"
(
not
intrinsic
sizing
w
/
orthogonal
flows
)
"
)
;
return
aReflowInput
.
ComputedISize
(
)
;
}
return
GetEffectiveComputedBSize
(
aReflowInput
)
;
}
static
nscoord
GetLargestLineMainSize
(
nsTArray
<
FlexLine
>
&
aLines
)
{
nscoord
largestLineOuterSize
=
0
;
for
(
const
FlexLine
&
line
:
aLines
)
{
largestLineOuterSize
=
std
:
:
max
(
largestLineOuterSize
line
.
TotalOuterHypotheticalMainSize
(
)
)
;
}
return
largestLineOuterSize
;
}
nscoord
nsFlexContainerFrame
:
:
ComputeMainSize
(
const
ReflowInput
&
aReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
nscoord
aTentativeMainSize
nsTArray
<
FlexLine
>
&
aLines
)
const
{
if
(
aAxisTracker
.
IsRowOriented
(
)
)
{
return
aTentativeMainSize
;
}
if
(
aTentativeMainSize
!
=
NS_UNCONSTRAINEDSIZE
)
{
return
aTentativeMainSize
;
}
if
(
aReflowInput
.
mStyleDisplay
-
>
IsContainSize
(
)
)
{
return
aReflowInput
.
ComputedMinBSize
(
)
;
}
nscoord
largestLineOuterSize
=
GetLargestLineMainSize
(
aLines
)
;
return
NS_CSS_MINMAX
(
largestLineOuterSize
aReflowInput
.
ComputedMinBSize
(
)
aReflowInput
.
ComputedMaxBSize
(
)
)
;
}
nscoord
nsFlexContainerFrame
:
:
ComputeCrossSize
(
const
ReflowInput
&
aReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
nscoord
aSumLineCrossSizes
bool
*
aIsDefinite
)
const
{
MOZ_ASSERT
(
aIsDefinite
"
outparam
pointer
must
be
non
-
null
"
)
;
if
(
aAxisTracker
.
IsColumnOriented
(
)
)
{
NS_WARNING_ASSERTION
(
aReflowInput
.
ComputedISize
(
)
!
=
NS_UNCONSTRAINEDSIZE
"
Unconstrained
inline
size
;
this
should
only
result
from
huge
sizes
"
"
(
not
intrinsic
sizing
w
/
orthogonal
flows
)
"
)
;
*
aIsDefinite
=
true
;
return
aReflowInput
.
ComputedISize
(
)
;
}
nscoord
effectiveComputedBSize
=
GetEffectiveComputedBSize
(
aReflowInput
)
;
if
(
effectiveComputedBSize
!
=
NS_UNCONSTRAINEDSIZE
)
{
*
aIsDefinite
=
true
;
return
effectiveComputedBSize
;
}
if
(
aReflowInput
.
mStyleDisplay
-
>
IsContainSize
(
)
)
{
*
aIsDefinite
=
true
;
return
aReflowInput
.
ComputedMinBSize
(
)
;
}
*
aIsDefinite
=
false
;
return
NS_CSS_MINMAX
(
aSumLineCrossSizes
aReflowInput
.
ComputedMinBSize
(
)
aReflowInput
.
ComputedMaxBSize
(
)
)
;
}
LogicalSize
nsFlexContainerFrame
:
:
ComputeAvailableSizeForItems
(
const
ReflowInput
&
aReflowInput
const
mozilla
:
:
LogicalMargin
&
aBorderPadding
)
const
{
const
WritingMode
wm
=
GetWritingMode
(
)
;
nscoord
availableBSize
=
aReflowInput
.
AvailableBSize
(
)
;
if
(
availableBSize
!
=
NS_UNCONSTRAINEDSIZE
)
{
availableBSize
-
=
aBorderPadding
.
BStart
(
wm
)
;
if
(
aReflowInput
.
mStyleBorder
-
>
mBoxDecorationBreak
=
=
StyleBoxDecorationBreak
:
:
Clone
)
{
availableBSize
-
=
aBorderPadding
.
BEnd
(
wm
)
;
}
availableBSize
=
std
:
:
max
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
1
)
availableBSize
)
;
}
return
LogicalSize
(
wm
aReflowInput
.
ComputedISize
(
)
availableBSize
)
;
}
void
FlexLine
:
:
PositionItemsInMainAxis
(
const
StyleContentDistribution
&
aJustifyContent
nscoord
aContentBoxMainSize
const
FlexboxAxisTracker
&
aAxisTracker
)
{
MainAxisPositionTracker
mainAxisPosnTracker
(
aAxisTracker
this
aJustifyContent
aContentBoxMainSize
)
;
for
(
FlexItem
&
item
:
Items
(
)
)
{
nscoord
itemMainBorderBoxSize
=
item
.
MainSize
(
)
+
item
.
BorderPaddingSizeInMainAxis
(
)
;
mainAxisPosnTracker
.
ResolveAutoMarginsInMainAxis
(
item
)
;
mainAxisPosnTracker
.
EnterMargin
(
item
.
Margin
(
)
)
;
mainAxisPosnTracker
.
EnterChildFrame
(
itemMainBorderBoxSize
)
;
item
.
SetMainPosition
(
mainAxisPosnTracker
.
Position
(
)
)
;
mainAxisPosnTracker
.
ExitChildFrame
(
itemMainBorderBoxSize
)
;
mainAxisPosnTracker
.
ExitMargin
(
item
.
Margin
(
)
)
;
mainAxisPosnTracker
.
TraversePackingSpace
(
)
;
if
(
&
item
!
=
&
Items
(
)
.
LastElement
(
)
)
{
mainAxisPosnTracker
.
TraverseGap
(
mMainGapSize
)
;
}
}
}
static
nscoord
ComputePhysicalAscentFromFlexRelativeAscent
(
nscoord
aFlexRelativeAscent
nscoord
aContentBoxCrossSize
const
ReflowInput
&
aReflowInput
const
FlexboxAxisTracker
&
aAxisTracker
)
{
return
aReflowInput
.
ComputedPhysicalBorderPadding
(
)
.
top
+
PhysicalCoordFromFlexRelativeCoord
(
aFlexRelativeAscent
aContentBoxCrossSize
aAxisTracker
.
CrossAxisPhysicalStartSide
(
)
)
;
}
void
nsFlexContainerFrame
:
:
SizeItemInCrossAxis
(
ReflowInput
&
aChildReflowInput
FlexItem
&
aItem
)
{
if
(
aItem
.
IsInlineAxisCrossAxis
(
)
)
{
aItem
.
SetCrossSize
(
aChildReflowInput
.
ComputedISize
(
)
)
;
return
;
}
MOZ_ASSERT
(
!
aItem
.
HadMeasuringReflow
(
)
"
We
shouldn
'
t
need
more
than
one
measuring
reflow
"
)
;
if
(
aItem
.
AlignSelf
(
)
.
_0
=
=
StyleAlignFlags
:
:
STRETCH
)
{
aChildReflowInput
.
SetBResize
(
true
)
;
aChildReflowInput
.
mFlags
.
mIsBResizeForPercentages
=
true
;
}
const
CachedBAxisMeasurement
&
measurement
=
MeasureAscentAndBSizeForFlexItem
(
aItem
aChildReflowInput
)
;
aItem
.
SetCrossSize
(
measurement
.
BSize
(
)
)
;
aItem
.
SetAscent
(
measurement
.
Ascent
(
)
)
;
}
void
FlexLine
:
:
PositionItemsInCrossAxis
(
nscoord
aLineStartPosition
const
FlexboxAxisTracker
&
aAxisTracker
)
{
SingleLineCrossAxisPositionTracker
lineCrossAxisPosnTracker
(
aAxisTracker
)
;
for
(
FlexItem
&
item
:
Items
(
)
)
{
item
.
ResolveStretchedCrossSize
(
mLineCrossSize
)
;
lineCrossAxisPosnTracker
.
ResolveAutoMarginsInCrossAxis
(
*
this
item
)
;
nscoord
itemCrossBorderBoxSize
=
item
.
CrossSize
(
)
+
item
.
BorderPaddingSizeInCrossAxis
(
)
;
lineCrossAxisPosnTracker
.
EnterAlignPackingSpace
(
*
this
item
aAxisTracker
)
;
lineCrossAxisPosnTracker
.
EnterMargin
(
item
.
Margin
(
)
)
;
lineCrossAxisPosnTracker
.
EnterChildFrame
(
itemCrossBorderBoxSize
)
;
item
.
SetCrossPosition
(
aLineStartPosition
+
lineCrossAxisPosnTracker
.
Position
(
)
)
;
lineCrossAxisPosnTracker
.
ResetPosition
(
)
;
}
}
void
nsFlexContainerFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aReflowOutput
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsFlexContainerFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aReflowOutput
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
MOZ_ASSERT
(
aPresContext
=
=
PresContext
(
)
)
;
FLEX_LOG
(
"
Reflow
(
)
for
nsFlexContainerFrame
%
p
"
this
)
;
if
(
IsFrameTreeTooDeep
(
aReflowInput
aReflowOutput
aStatus
)
)
{
return
;
}
NormalizeChildLists
(
)
;
#
ifdef
DEBUG
mDidPushItemsBitMayLie
=
false
;
SanityCheckChildListsBeforeReflow
(
)
;
#
endif
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
const
nsStylePosition
*
stylePos
=
StylePosition
(
)
;
const
auto
&
bsize
=
stylePos
-
>
BSize
(
wm
)
;
if
(
bsize
.
HasPercent
(
)
|
|
(
StyleDisplay
(
)
-
>
IsAbsolutelyPositionedStyle
(
)
&
&
(
bsize
.
IsAuto
(
)
|
|
bsize
.
IsExtremumLength
(
)
)
&
&
!
stylePos
-
>
mOffset
.
GetBStart
(
wm
)
.
IsAuto
(
)
&
&
!
stylePos
-
>
mOffset
.
GetBEnd
(
wm
)
.
IsAuto
(
)
)
)
{
AddStateBits
(
NS_FRAME_CONTAINS_RELATIVE_BSIZE
)
;
}
bool
hasLineClampEllipsis
=
HasAnyStateBits
(
NS_STATE_FLEX_HAS_LINE_CLAMP_ELLIPSIS
)
;
RemoveStateBits
(
NS_STATE_FLEX_HAS_LINE_CLAMP_ELLIPSIS
)
;
const
FlexboxAxisTracker
axisTracker
(
this
)
;
ComputedFlexContainerInfo
*
containerInfo
=
CreateOrClearFlexContainerInfo
(
)
;
LogicalMargin
borderPadding
=
aReflowInput
.
ComputedLogicalBorderPadding
(
)
.
ApplySkipSides
(
PreReflowBlockLevelLogicalSkipSides
(
)
)
;
const
LogicalSize
availableSizeForItems
=
ComputeAvailableSizeForItems
(
aReflowInput
borderPadding
)
;
nscoord
contentBoxMainSize
=
GetMainSizeFromReflowInput
(
aReflowInput
axisTracker
)
;
nscoord
contentBoxCrossSize
;
nscoord
flexContainerAscent
;
nscoord
mainGapSize
;
nscoord
crossGapSize
;
if
(
axisTracker
.
IsRowOriented
(
)
)
{
mainGapSize
=
nsLayoutUtils
:
:
ResolveGapToLength
(
stylePos
-
>
mColumnGap
contentBoxMainSize
)
;
crossGapSize
=
nsLayoutUtils
:
:
ResolveGapToLength
(
stylePos
-
>
mRowGap
GetEffectiveComputedBSize
(
aReflowInput
)
)
;
}
else
{
mainGapSize
=
nsLayoutUtils
:
:
ResolveGapToLength
(
stylePos
-
>
mRowGap
contentBoxMainSize
)
;
NS_WARNING_ASSERTION
(
aReflowInput
.
ComputedISize
(
)
!
=
NS_UNCONSTRAINEDSIZE
"
Unconstrained
inline
size
;
this
should
only
result
"
"
from
huge
sizes
(
not
intrinsic
sizing
w
/
orthogonal
"
"
flows
)
"
)
;
crossGapSize
=
nsLayoutUtils
:
:
ResolveGapToLength
(
stylePos
-
>
mColumnGap
aReflowInput
.
ComputedISize
(
)
)
;
}
AutoTArray
<
FlexLine
1
>
lines
;
AutoTArray
<
StrutInfo
1
>
struts
;
AutoTArray
<
nsIFrame
*
1
>
placeholders
;
if
(
!
GetPrevInFlow
(
)
)
{
DoFlexLayout
(
aReflowInput
contentBoxMainSize
contentBoxCrossSize
flexContainerAscent
lines
struts
placeholders
axisTracker
mainGapSize
crossGapSize
hasLineClampEllipsis
containerInfo
)
;
if
(
!
struts
.
IsEmpty
(
)
)
{
lines
.
Clear
(
)
;
placeholders
.
Clear
(
)
;
DoFlexLayout
(
aReflowInput
contentBoxMainSize
contentBoxCrossSize
flexContainerAscent
lines
struts
placeholders
axisTracker
mainGapSize
crossGapSize
hasLineClampEllipsis
containerInfo
)
;
}
}
else
{
auto
*
data
=
FirstInFlow
(
)
-
>
GetProperty
(
SharedFlexData
:
:
Prop
(
)
)
;
MOZ_ASSERT
(
data
"
SharedFlexData
should
be
set
by
our
first
-
in
-
flow
!
"
)
;
GenerateFlexLines
(
*
data
lines
)
;
contentBoxMainSize
=
data
-
>
mContentBoxMainSize
;
contentBoxCrossSize
=
data
-
>
mContentBoxCrossSize
;
}
const
LogicalSize
contentBoxSize
=
axisTracker
.
LogicalSizeFromFlexRelativeSizes
(
contentBoxMainSize
contentBoxCrossSize
)
;
const
nscoord
consumedBSize
=
ConsumedBSize
(
wm
)
;
const
nscoord
effectiveContentBSize
=
contentBoxSize
.
BSize
(
wm
)
-
consumedBSize
;
const
bool
mayNeedNextInFlow
=
effectiveContentBSize
>
availableSizeForItems
.
BSize
(
wm
)
;
if
(
mayNeedNextInFlow
)
{
if
(
aReflowInput
.
mStyleBorder
-
>
mBoxDecorationBreak
=
=
StyleBoxDecorationBreak
:
:
Slice
)
{
borderPadding
.
BEnd
(
wm
)
=
0
;
}
}
const
auto
*
prevInFlow
=
static_cast
<
nsFlexContainerFrame
*
>
(
GetPrevInFlow
(
)
)
;
nsOverflowAreas
ocBounds
;
nsReflowStatus
ocStatus
;
nscoord
sumOfChildrenBlockSize
;
if
(
prevInFlow
)
{
ReflowOverflowContainerChildren
(
aPresContext
aReflowInput
ocBounds
ReflowChildFlags
:
:
Default
ocStatus
MergeSortedFrameListsFor
)
;
sumOfChildrenBlockSize
=
prevInFlow
-
>
GetProperty
(
SumOfChildrenBlockSizeProperty
(
)
)
;
}
else
{
sumOfChildrenBlockSize
=
0
;
}
const
auto
[
maxBlockEndEdgeOfChildren
areChildrenComplete
]
=
ReflowChildren
(
aReflowInput
contentBoxMainSize
contentBoxCrossSize
availableSizeForItems
borderPadding
sumOfChildrenBlockSize
flexContainerAscent
lines
placeholders
axisTracker
hasLineClampEllipsis
)
;
sumOfChildrenBlockSize
+
=
std
:
:
max
(
maxBlockEndEdgeOfChildren
-
borderPadding
.
BStart
(
wm
)
availableSizeForItems
.
BSize
(
wm
)
)
;
PopulateReflowOutput
(
aReflowOutput
aReflowInput
aStatus
contentBoxSize
borderPadding
consumedBSize
mayNeedNextInFlow
maxBlockEndEdgeOfChildren
areChildrenComplete
flexContainerAscent
lines
axisTracker
)
;
aReflowOutput
.
mOverflowAreas
.
UnionWith
(
ocBounds
)
;
aStatus
.
MergeCompletionStatusFrom
(
ocStatus
)
;
FinishReflowWithAbsoluteFrames
(
PresContext
(
)
aReflowOutput
aReflowInput
aStatus
)
;
NS_FRAME_SET_TRUNCATION
(
aStatus
aReflowInput
aReflowOutput
)
if
(
MOZ_UNLIKELY
(
containerInfo
)
)
{
UpdateFlexLineAndItemInfo
(
*
containerInfo
lines
)
;
}
if
(
!
GetPrevInFlow
(
)
)
{
SharedFlexData
*
data
=
GetProperty
(
SharedFlexData
:
:
Prop
(
)
)
;
if
(
!
aStatus
.
IsFullyComplete
(
)
)
{
if
(
!
data
)
{
data
=
new
SharedFlexData
;
SetProperty
(
SharedFlexData
:
:
Prop
(
)
data
)
;
}
data
-
>
mLines
=
std
:
:
move
(
lines
)
;
data
-
>
mContentBoxMainSize
=
contentBoxMainSize
;
data
-
>
mContentBoxCrossSize
=
contentBoxCrossSize
;
SetProperty
(
SumOfChildrenBlockSizeProperty
(
)
sumOfChildrenBlockSize
)
;
}
else
if
(
data
)
{
RemoveProperty
(
SharedFlexData
:
:
Prop
(
)
)
;
RemoveProperty
(
SumOfChildrenBlockSizeProperty
(
)
)
;
}
}
else
{
SetProperty
(
SumOfChildrenBlockSizeProperty
(
)
sumOfChildrenBlockSize
)
;
}
}
class
MOZ_RAII
AutoFlexItemMainSizeOverride
final
{
public
:
explicit
AutoFlexItemMainSizeOverride
(
FlexItem
&
aItem
)
:
mItemFrame
(
aItem
.
Frame
(
)
)
{
MOZ_ASSERT
(
!
mItemFrame
-
>
HasProperty
(
nsIFrame
:
:
FlexItemMainSizeOverride
(
)
)
"
FlexItemMainSizeOverride
prop
shouldn
'
t
be
set
already
;
"
"
it
should
only
be
set
temporarily
(
&
not
recursively
)
"
)
;
NS_ASSERTION
(
aItem
.
HasIntrinsicRatio
(
)
"
This
should
only
be
needed
for
items
with
an
aspect
ratio
"
)
;
nscoord
mainSizeOverrideVal
=
aItem
.
MainSize
(
)
;
if
(
aItem
.
Frame
(
)
-
>
StylePosition
(
)
-
>
mBoxSizing
=
=
StyleBoxSizing
:
:
Border
)
{
mainSizeOverrideVal
+
=
aItem
.
BorderPaddingSizeInMainAxis
(
)
;
}
mItemFrame
-
>
SetProperty
(
nsIFrame
:
:
FlexItemMainSizeOverride
(
)
mainSizeOverrideVal
)
;
}
~
AutoFlexItemMainSizeOverride
(
)
{
mItemFrame
-
>
RemoveProperty
(
nsIFrame
:
:
FlexItemMainSizeOverride
(
)
)
;
}
private
:
nsIFrame
*
mItemFrame
;
}
;
void
nsFlexContainerFrame
:
:
CalculatePackingSpace
(
uint32_t
aNumThingsToPack
const
StyleContentDistribution
&
aAlignVal
nscoord
*
aFirstSubjectOffset
uint32_t
*
aNumPackingSpacesRemaining
nscoord
*
aPackingSpaceRemaining
)
{
StyleAlignFlags
val
=
aAlignVal
.
primary
;
MOZ_ASSERT
(
val
=
=
StyleAlignFlags
:
:
SPACE_BETWEEN
|
|
val
=
=
StyleAlignFlags
:
:
SPACE_AROUND
|
|
val
=
=
StyleAlignFlags
:
:
SPACE_EVENLY
"
Unexpected
alignment
value
"
)
;
MOZ_ASSERT
(
*
aPackingSpaceRemaining
>
=
0
"
Should
not
be
called
with
negative
packing
space
"
)
;
MOZ_ASSERT
(
aNumThingsToPack
>
1
"
Should
not
be
called
unless
there
'
s
more
than
1
thing
to
pack
"
)
;
*
aNumPackingSpacesRemaining
=
aNumThingsToPack
-
1
;
if
(
val
=
=
StyleAlignFlags
:
:
SPACE_BETWEEN
)
{
return
;
}
size_t
numPackingSpacesForEdges
=
val
=
=
StyleAlignFlags
:
:
SPACE_AROUND
?
1
:
2
;
nscoord
packingSpaceSize
=
*
aPackingSpaceRemaining
/
(
*
aNumPackingSpacesRemaining
+
numPackingSpacesForEdges
)
;
nscoord
totalEdgePackingSpace
=
numPackingSpacesForEdges
*
packingSpaceSize
;
*
aFirstSubjectOffset
+
=
totalEdgePackingSpace
/
2
;
*
aPackingSpaceRemaining
-
=
totalEdgePackingSpace
;
}
ComputedFlexContainerInfo
*
nsFlexContainerFrame
:
:
CreateOrClearFlexContainerInfo
(
)
{
if
(
!
ShouldGenerateComputedInfo
(
)
)
{
return
nullptr
;
}
ComputedFlexContainerInfo
*
info
=
GetProperty
(
FlexContainerInfo
(
)
)
;
if
(
info
)
{
info
-
>
mLines
.
Clear
(
)
;
}
else
{
info
=
new
ComputedFlexContainerInfo
(
)
;
SetProperty
(
FlexContainerInfo
(
)
info
)
;
}
return
info
;
}
void
nsFlexContainerFrame
:
:
CreateFlexLineAndFlexItemInfo
(
ComputedFlexContainerInfo
&
aContainerInfo
const
nsTArray
<
FlexLine
>
&
aLines
)
{
for
(
const
FlexLine
&
line
:
aLines
)
{
ComputedFlexLineInfo
*
lineInfo
=
aContainerInfo
.
mLines
.
AppendElement
(
)
;
for
(
const
FlexItem
&
item
:
line
.
Items
(
)
)
{
nsIFrame
*
frame
=
item
.
Frame
(
)
;
nsIFrame
*
targetFrame
=
GetFirstNonAnonBoxInSubtree
(
frame
)
;
nsIContent
*
content
=
targetFrame
-
>
GetContent
(
)
;
while
(
content
&
&
content
-
>
TextIsOnlyWhitespace
(
)
)
{
targetFrame
=
targetFrame
-
>
GetNextSibling
(
)
;
if
(
targetFrame
)
{
content
=
targetFrame
-
>
GetContent
(
)
;
}
else
{
content
=
nullptr
;
}
}
ComputedFlexItemInfo
*
itemInfo
=
lineInfo
-
>
mItems
.
AppendElement
(
)
;
itemInfo
-
>
mNode
=
content
;
}
}
}
void
nsFlexContainerFrame
:
:
ComputeFlexDirections
(
ComputedFlexContainerInfo
&
aContainerInfo
const
FlexboxAxisTracker
&
aAxisTracker
)
{
auto
ConvertPhysicalStartSideToFlexPhysicalDirection
=
[
]
(
mozilla
:
:
Side
aStartSide
)
{
switch
(
aStartSide
)
{
case
eSideLeft
:
return
dom
:
:
FlexPhysicalDirection
:
:
Horizontal_lr
;
case
eSideRight
:
return
dom
:
:
FlexPhysicalDirection
:
:
Horizontal_rl
;
case
eSideTop
:
return
dom
:
:
FlexPhysicalDirection
:
:
Vertical_tb
;
case
eSideBottom
:
return
dom
:
:
FlexPhysicalDirection
:
:
Vertical_bt
;
}
MOZ_ASSERT_UNREACHABLE
(
"
We
should
handle
all
sides
!
"
)
;
return
dom
:
:
FlexPhysicalDirection
:
:
Horizontal_lr
;
}
;
aContainerInfo
.
mMainAxisDirection
=
ConvertPhysicalStartSideToFlexPhysicalDirection
(
aAxisTracker
.
MainAxisPhysicalStartSide
(
)
)
;
aContainerInfo
.
mCrossAxisDirection
=
ConvertPhysicalStartSideToFlexPhysicalDirection
(
aAxisTracker
.
CrossAxisPhysicalStartSide
(
)
)
;
}
void
nsFlexContainerFrame
:
:
UpdateFlexLineAndItemInfo
(
ComputedFlexContainerInfo
&
aContainerInfo
const
nsTArray
<
FlexLine
>
&
aLines
)
{
uint32_t
lineIndex
=
0
;
for
(
const
FlexLine
&
line
:
aLines
)
{
ComputedFlexLineInfo
&
lineInfo
=
aContainerInfo
.
mLines
[
lineIndex
]
;
lineInfo
.
mCrossSize
=
line
.
LineCrossSize
(
)
;
lineInfo
.
mFirstBaselineOffset
=
line
.
FirstBaselineOffset
(
)
;
lineInfo
.
mLastBaselineOffset
=
line
.
LastBaselineOffset
(
)
;
uint32_t
itemIndex
=
0
;
for
(
const
FlexItem
&
item
:
line
.
Items
(
)
)
{
ComputedFlexItemInfo
&
itemInfo
=
lineInfo
.
mItems
[
itemIndex
]
;
itemInfo
.
mFrameRect
=
item
.
Frame
(
)
-
>
GetRect
(
)
;
itemInfo
.
mMainMinSize
=
item
.
MainMinSize
(
)
;
itemInfo
.
mMainMaxSize
=
item
.
MainMaxSize
(
)
;
itemInfo
.
mCrossMinSize
=
item
.
CrossMinSize
(
)
;
itemInfo
.
mCrossMaxSize
=
item
.
CrossMaxSize
(
)
;
itemInfo
.
mClampState
=
item
.
WasMinClamped
(
)
?
mozilla
:
:
dom
:
:
FlexItemClampState
:
:
Clamped_to_min
:
(
item
.
WasMaxClamped
(
)
?
mozilla
:
:
dom
:
:
FlexItemClampState
:
:
Clamped_to_max
:
mozilla
:
:
dom
:
:
FlexItemClampState
:
:
Unclamped
)
;
+
+
itemIndex
;
}
+
+
lineIndex
;
}
}
nsFlexContainerFrame
*
nsFlexContainerFrame
:
:
GetFlexFrameWithComputedInfo
(
nsIFrame
*
aFrame
)
{
auto
GetFlexContainerFrame
=
[
]
(
nsIFrame
*
aFrame
)
{
nsFlexContainerFrame
*
flexFrame
=
nullptr
;
if
(
aFrame
)
{
nsIFrame
*
inner
=
aFrame
;
if
(
MOZ_UNLIKELY
(
aFrame
-
>
IsFieldSetFrame
(
)
)
)
{
inner
=
static_cast
<
nsFieldSetFrame
*
>
(
aFrame
)
-
>
GetInner
(
)
;
}
nsIFrame
*
insertionFrame
=
inner
?
inner
-
>
GetContentInsertionFrame
(
)
:
nullptr
;
nsIFrame
*
possibleFlexFrame
=
insertionFrame
?
insertionFrame
:
aFrame
;
flexFrame
=
possibleFlexFrame
-
>
IsFlexContainerFrame
(
)
?
static_cast
<
nsFlexContainerFrame
*
>
(
possibleFlexFrame
)
:
nullptr
;
}
return
flexFrame
;
}
;
nsFlexContainerFrame
*
flexFrame
=
GetFlexContainerFrame
(
aFrame
)
;
if
(
flexFrame
)
{
bool
reflowNeeded
=
!
flexFrame
-
>
HasProperty
(
FlexContainerInfo
(
)
)
;
if
(
reflowNeeded
)
{
AutoWeakFrame
weakFrameRef
(
aFrame
)
;
RefPtr
<
mozilla
:
:
PresShell
>
presShell
=
flexFrame
-
>
PresShell
(
)
;
flexFrame
-
>
SetShouldGenerateComputedInfo
(
true
)
;
presShell
-
>
FrameNeedsReflow
(
flexFrame
IntrinsicDirty
:
:
Resize
NS_FRAME_IS_DIRTY
)
;
presShell
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
if
(
!
weakFrameRef
.
IsAlive
(
)
)
{
return
nullptr
;
}
flexFrame
=
GetFlexContainerFrame
(
weakFrameRef
.
GetFrame
(
)
)
;
NS_WARNING_ASSERTION
(
!
flexFrame
|
|
flexFrame
-
>
HasProperty
(
FlexContainerInfo
(
)
)
"
The
state
bit
should
'
ve
made
our
forced
-
reflow
"
"
generate
a
FlexContainerInfo
object
"
)
;
}
}
return
flexFrame
;
}
bool
nsFlexContainerFrame
:
:
IsItemInlineAxisMainAxis
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
&
&
aFrame
-
>
IsFlexItem
(
)
"
expecting
arg
to
be
a
flex
item
"
)
;
const
WritingMode
flexItemWM
=
aFrame
-
>
GetWritingMode
(
)
;
const
nsIFrame
*
flexContainer
=
aFrame
-
>
GetParent
(
)
;
if
(
IsLegacyBox
(
flexContainer
)
)
{
bool
boxOrientIsVertical
=
(
flexContainer
-
>
StyleXUL
(
)
-
>
mBoxOrient
=
=
StyleBoxOrient
:
:
Vertical
)
;
return
flexItemWM
.
IsVertical
(
)
=
=
boxOrientIsVertical
;
}
bool
itemInlineAxisIsParallelToParent
=
!
flexItemWM
.
IsOrthogonalTo
(
flexContainer
-
>
GetWritingMode
(
)
)
;
auto
flexDirection
=
flexContainer
-
>
StylePosition
(
)
-
>
mFlexDirection
;
bool
flexContainerIsRowOriented
=
flexDirection
=
=
StyleFlexDirection
:
:
Row
|
|
flexDirection
=
=
StyleFlexDirection
:
:
RowReverse
;
return
flexContainerIsRowOriented
=
=
itemInlineAxisIsParallelToParent
;
}
bool
nsFlexContainerFrame
:
:
IsUsedFlexBasisContent
(
const
StyleFlexBasis
&
aFlexBasis
const
StyleSize
&
aMainSize
)
{
if
(
aFlexBasis
.
IsContent
(
)
)
{
return
true
;
}
return
aFlexBasis
.
IsAuto
(
)
&
&
aMainSize
.
IsAuto
(
)
;
}
void
nsFlexContainerFrame
:
:
DoFlexLayout
(
const
ReflowInput
&
aReflowInput
nscoord
&
aContentBoxMainSize
nscoord
&
aContentBoxCrossSize
nscoord
&
aFlexContainerAscent
nsTArray
<
FlexLine
>
&
aLines
nsTArray
<
StrutInfo
>
&
aStruts
nsTArray
<
nsIFrame
*
>
&
aPlaceholders
const
FlexboxAxisTracker
&
aAxisTracker
nscoord
aMainGapSize
nscoord
aCrossGapSize
bool
aHasLineClampEllipsis
ComputedFlexContainerInfo
*
const
aContainerInfo
)
{
MOZ_ASSERT
(
aLines
.
IsEmpty
(
)
"
Caller
should
pass
an
empty
array
for
lines
!
"
)
;
MOZ_ASSERT
(
aPlaceholders
.
IsEmpty
(
)
"
Caller
should
pass
an
empty
array
for
placeholders
!
"
)
;
GenerateFlexLines
(
aReflowInput
aContentBoxMainSize
aStruts
aAxisTracker
aMainGapSize
aHasLineClampEllipsis
aPlaceholders
aLines
)
;
if
(
(
aLines
.
Length
(
)
=
=
1
&
&
aLines
[
0
]
.
IsEmpty
(
)
)
|
|
aReflowInput
.
mStyleDisplay
-
>
IsContainLayout
(
)
)
{
AddStateBits
(
NS_STATE_FLEX_SYNTHESIZE_BASELINE
)
;
}
else
{
RemoveStateBits
(
NS_STATE_FLEX_SYNTHESIZE_BASELINE
)
;
}
if
(
aContainerInfo
)
{
MOZ_ASSERT
(
ShouldGenerateComputedInfo
(
)
"
We
should
only
have
the
info
struct
if
"
"
ShouldGenerateComputedInfo
(
)
is
true
!
"
)
;
if
(
!
aStruts
.
IsEmpty
(
)
)
{
aContainerInfo
-
>
mLines
.
Clear
(
)
;
}
else
{
MOZ_ASSERT
(
aContainerInfo
-
>
mLines
.
IsEmpty
(
)
"
Shouldn
'
t
have
lines
yet
.
"
)
;
}
CreateFlexLineAndFlexItemInfo
(
*
aContainerInfo
aLines
)
;
ComputeFlexDirections
(
*
aContainerInfo
aAxisTracker
)
;
}
aContentBoxMainSize
=
ComputeMainSize
(
aReflowInput
aAxisTracker
aContentBoxMainSize
aLines
)
;
uint32_t
lineIndex
=
0
;
for
(
FlexLine
&
line
:
aLines
)
{
ComputedFlexLineInfo
*
lineInfo
=
aContainerInfo
?
&
aContainerInfo
-
>
mLines
[
lineIndex
]
:
nullptr
;
line
.
ResolveFlexibleLengths
(
aContentBoxMainSize
lineInfo
)
;
+
+
lineIndex
;
}
nscoord
sumLineCrossSizes
=
aCrossGapSize
*
(
aLines
.
Length
(
)
-
1
)
;
for
(
FlexLine
&
line
:
aLines
)
{
for
(
FlexItem
&
item
:
line
.
Items
(
)
)
{
if
(
item
.
CanMainSizeInfluenceCrossSize
(
)
)
{
Maybe
<
AutoFlexItemMainSizeOverride
>
sizeOverride
;
if
(
item
.
HasIntrinsicRatio
(
)
)
{
sizeOverride
.
emplace
(
item
)
;
}
WritingMode
wm
=
item
.
Frame
(
)
-
>
GetWritingMode
(
)
;
LogicalSize
availSize
=
aReflowInput
.
ComputedSize
(
wm
)
;
availSize
.
BSize
(
wm
)
=
NS_UNCONSTRAINEDSIZE
;
ReflowInput
childReflowInput
(
PresContext
(
)
aReflowInput
item
.
Frame
(
)
availSize
)
;
childReflowInput
.
mFlags
.
mInsideLineClamp
=
GetLineClampValue
(
)
!
=
0
;
if
(
!
sizeOverride
)
{
if
(
item
.
IsInlineAxisMainAxis
(
)
)
{
childReflowInput
.
SetComputedISize
(
item
.
MainSize
(
)
)
;
}
else
{
childReflowInput
.
SetComputedBSize
(
item
.
MainSize
(
)
)
;
if
(
item
.
TreatBSizeAsIndefinite
(
)
)
{
childReflowInput
.
mFlags
.
mTreatBSizeAsIndefinite
=
true
;
}
}
}
SizeItemInCrossAxis
(
childReflowInput
item
)
;
}
}
line
.
ComputeCrossSizeAndBaseline
(
aAxisTracker
)
;
sumLineCrossSizes
+
=
line
.
LineCrossSize
(
)
;
}
bool
isCrossSizeDefinite
;
aContentBoxCrossSize
=
ComputeCrossSize
(
aReflowInput
aAxisTracker
sumLineCrossSizes
&
isCrossSizeDefinite
)
;
CrossAxisPositionTracker
crossAxisPosnTracker
(
aLines
aReflowInput
aContentBoxCrossSize
isCrossSizeDefinite
aAxisTracker
aCrossGapSize
)
;
if
(
aStruts
.
IsEmpty
(
)
&
&
!
ShouldUseMozBoxCollapseBehavior
(
aReflowInput
.
mStyleDisplay
)
)
{
BuildStrutInfoFromCollapsedItems
(
aLines
aStruts
)
;
if
(
!
aStruts
.
IsEmpty
(
)
)
{
return
;
}
}
if
(
nscoord
firstLineBaselineOffset
=
aLines
[
0
]
.
FirstBaselineOffset
(
)
;
firstLineBaselineOffset
=
=
nscoord_MIN
)
{
aFlexContainerAscent
=
nscoord_MIN
;
}
else
{
aFlexContainerAscent
=
ComputePhysicalAscentFromFlexRelativeAscent
(
crossAxisPosnTracker
.
Position
(
)
+
firstLineBaselineOffset
aContentBoxCrossSize
aReflowInput
aAxisTracker
)
;
}
const
auto
justifyContent
=
IsLegacyBox
(
aReflowInput
.
mFrame
)
?
ConvertLegacyStyleToJustifyContent
(
StyleXUL
(
)
)
:
aReflowInput
.
mStylePosition
-
>
mJustifyContent
;
lineIndex
=
0
;
for
(
FlexLine
&
line
:
aLines
)
{
line
.
PositionItemsInMainAxis
(
justifyContent
aContentBoxMainSize
aAxisTracker
)
;
if
(
MOZ_UNLIKELY
(
aContainerInfo
)
)
{
ComputedFlexLineInfo
&
lineInfo
=
aContainerInfo
-
>
mLines
[
lineIndex
]
;
lineInfo
.
mCrossStart
=
crossAxisPosnTracker
.
Position
(
)
;
}
line
.
PositionItemsInCrossAxis
(
crossAxisPosnTracker
.
Position
(
)
aAxisTracker
)
;
crossAxisPosnTracker
.
TraverseLine
(
line
)
;
crossAxisPosnTracker
.
TraversePackingSpace
(
)
;
if
(
&
line
!
=
&
aLines
.
LastElement
(
)
)
{
crossAxisPosnTracker
.
TraverseGap
(
)
;
}
+
+
lineIndex
;
}
}
std
:
:
tuple
<
nscoord
bool
>
nsFlexContainerFrame
:
:
ReflowChildren
(
const
ReflowInput
&
aReflowInput
const
nscoord
aContentBoxMainSize
const
nscoord
aContentBoxCrossSize
const
LogicalSize
&
aAvailableSizeForItems
const
LogicalMargin
&
aBorderPadding
const
nscoord
aSumOfPrevInFlowsChildrenBlockSize
nscoord
&
aFlexContainerAscent
nsTArray
<
FlexLine
>
&
aLines
nsTArray
<
nsIFrame
*
>
&
aPlaceholders
const
FlexboxAxisTracker
&
aAxisTracker
bool
aHasLineClampEllipsis
)
{
WritingMode
flexWM
=
aReflowInput
.
GetWritingMode
(
)
;
const
LogicalPoint
containerContentBoxOrigin
(
flexWM
aBorderPadding
.
IStart
(
flexWM
)
aBorderPadding
.
BStart
(
flexWM
)
)
;
LogicalSize
logSize
=
aAxisTracker
.
LogicalSizeFromFlexRelativeSizes
(
aContentBoxMainSize
aContentBoxCrossSize
)
;
logSize
+
=
aBorderPadding
.
Size
(
flexWM
)
;
nsSize
containerSize
=
logSize
.
GetPhysicalSize
(
flexWM
)
;
const
FlexItem
*
firstItem
=
aLines
[
0
]
.
IsEmpty
(
)
?
nullptr
:
&
aLines
[
0
]
.
FirstItem
(
)
;
nscoord
maxBlockEndEdgeOfChildren
=
containerContentBoxOrigin
.
B
(
flexWM
)
;
FrameHashtable
pushedItems
;
FrameHashtable
incompleteItems
;
FrameHashtable
overflowIncompleteItems
;
for
(
const
FlexLine
&
line
:
aLines
)
{
for
(
const
FlexItem
&
item
:
line
.
Items
(
)
)
{
LogicalPoint
framePos
=
aAxisTracker
.
LogicalPointFromFlexRelativePoint
(
item
.
MainPosition
(
)
item
.
CrossPosition
(
)
aContentBoxMainSize
aContentBoxCrossSize
)
;
if
(
item
.
Frame
(
)
-
>
GetPrevInFlow
(
)
)
{
framePos
.
B
(
flexWM
)
=
0
;
}
else
{
framePos
.
B
(
flexWM
)
-
=
aSumOfPrevInFlowsChildrenBlockSize
;
}
const
nscoord
availableBSizeForItem
=
aAvailableSizeForItems
.
BSize
(
flexWM
)
=
=
NS_UNCONSTRAINEDSIZE
?
NS_UNCONSTRAINEDSIZE
:
aAvailableSizeForItems
.
BSize
(
flexWM
)
-
framePos
.
B
(
flexWM
)
;
framePos
+
=
containerContentBoxOrigin
;
const
nscoord
itemNormalBPos
=
framePos
.
B
(
flexWM
)
;
const
bool
childBPosExceedAvailableSpaceBEnd
=
availableBSizeForItem
!
=
NS_UNCONSTRAINEDSIZE
&
&
availableBSizeForItem
<
=
0
;
if
(
childBPosExceedAvailableSpaceBEnd
)
{
FLEX_LOG
(
"
[
frag
]
Flex
item
%
p
needed
to
be
pushed
to
container
'
s
"
"
next
-
in
-
flow
due
to
position
below
available
space
'
s
block
-
end
"
item
.
Frame
(
)
)
;
pushedItems
.
PutEntry
(
item
.
Frame
(
)
)
;
}
else
if
(
item
.
NeedsFinalReflow
(
availableBSizeForItem
)
)
{
const
WritingMode
itemWM
=
item
.
GetWritingMode
(
)
;
const
auto
availableSize
=
LogicalSize
(
flexWM
aAvailableSizeForItems
.
ISize
(
flexWM
)
availableBSizeForItem
)
.
ConvertTo
(
itemWM
flexWM
)
;
const
nsReflowStatus
childReflowStatus
=
ReflowFlexItem
(
aAxisTracker
aReflowInput
item
framePos
availableSize
containerSize
aHasLineClampEllipsis
)
;
if
(
childReflowStatus
.
IsIncomplete
(
)
)
{
incompleteItems
.
PutEntry
(
item
.
Frame
(
)
)
;
}
else
if
(
childReflowStatus
.
IsOverflowIncomplete
(
)
)
{
overflowIncompleteItems
.
PutEntry
(
item
.
Frame
(
)
)
;
}
}
else
{
MoveFlexItemToFinalPosition
(
aReflowInput
item
framePos
containerSize
)
;
if
(
aHasLineClampEllipsis
&
&
GetLineClampValue
(
)
=
=
0
)
{
item
.
BlockFrame
(
)
-
>
ClearLineClampEllipsis
(
)
;
}
}
if
(
!
childBPosExceedAvailableSpaceBEnd
)
{
maxBlockEndEdgeOfChildren
=
std
:
:
max
(
maxBlockEndEdgeOfChildren
itemNormalBPos
+
item
.
Frame
(
)
-
>
BSize
(
flexWM
)
)
;
}
if
(
item
.
HasAnyAutoMargin
(
)
)
{
nsMargin
*
propValue
=
item
.
Frame
(
)
-
>
GetProperty
(
nsIFrame
:
:
UsedMarginProperty
(
)
)
;
if
(
propValue
)
{
*
propValue
=
item
.
PhysicalMargin
(
)
;
}
}
if
(
&
item
=
=
firstItem
&
&
aFlexContainerAscent
=
=
nscoord_MIN
)
{
aFlexContainerAscent
=
itemNormalBPos
+
item
.
ResolvedAscent
(
true
)
;
}
}
}
if
(
!
aPlaceholders
.
IsEmpty
(
)
)
{
ReflowPlaceholders
(
aReflowInput
aPlaceholders
containerContentBoxOrigin
containerSize
)
;
}
const
bool
anyChildIncomplete
=
PushIncompleteChildren
(
pushedItems
incompleteItems
overflowIncompleteItems
)
;
if
(
!
pushedItems
.
IsEmpty
(
)
)
{
AddStateBits
(
NS_STATE_FLEX_DID_PUSH_ITEMS
)
;
}
return
{
maxBlockEndEdgeOfChildren
anyChildIncomplete
}
;
}
void
nsFlexContainerFrame
:
:
PopulateReflowOutput
(
ReflowOutput
&
aReflowOutput
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
const
LogicalSize
&
aContentBoxSize
const
LogicalMargin
&
aBorderPadding
const
nscoord
aConsumedBSize
const
bool
aMayNeedNextInFlow
const
nscoord
aMaxBlockEndEdgeOfChildren
const
bool
aAnyChildIncomplete
nscoord
aFlexContainerAscent
nsTArray
<
FlexLine
>
&
aLines
const
FlexboxAxisTracker
&
aAxisTracker
)
{
const
WritingMode
flexWM
=
aReflowInput
.
GetWritingMode
(
)
;
LogicalSize
desiredSizeInFlexWM
(
flexWM
)
;
desiredSizeInFlexWM
.
ISize
(
flexWM
)
=
aContentBoxSize
.
ISize
(
flexWM
)
+
aBorderPadding
.
IStartEnd
(
flexWM
)
;
const
nscoord
effectiveContentBSizeWithBStartBP
=
aContentBoxSize
.
BSize
(
flexWM
)
-
aConsumedBSize
+
aBorderPadding
.
BStart
(
flexWM
)
;
nscoord
blockEndContainerBP
=
aBorderPadding
.
BEnd
(
flexWM
)
;
if
(
aMayNeedNextInFlow
)
{
bool
isStatusIncomplete
=
true
;
const
nscoord
availableBSizeMinusBEndBP
=
aReflowInput
.
AvailableBSize
(
)
-
aBorderPadding
.
BEnd
(
flexWM
)
;
if
(
aMaxBlockEndEdgeOfChildren
<
=
availableBSizeMinusBEndBP
)
{
desiredSizeInFlexWM
.
BSize
(
flexWM
)
=
availableBSizeMinusBEndBP
;
}
else
{
desiredSizeInFlexWM
.
BSize
(
flexWM
)
=
std
:
:
min
(
effectiveContentBSizeWithBStartBP
aMaxBlockEndEdgeOfChildren
)
;
if
(
aMaxBlockEndEdgeOfChildren
>
=
effectiveContentBSizeWithBStartBP
)
{
isStatusIncomplete
=
false
;
if
(
aReflowInput
.
mStyleBorder
-
>
mBoxDecorationBreak
=
=
StyleBoxDecorationBreak
:
:
Slice
)
{
blockEndContainerBP
=
aReflowInput
.
ComputedLogicalBorderPadding
(
)
.
BEnd
(
flexWM
)
;
}
}
}
if
(
isStatusIncomplete
)
{
aStatus
.
SetIncomplete
(
)
;
}
}
else
{
desiredSizeInFlexWM
.
BSize
(
flexWM
)
=
effectiveContentBSizeWithBStartBP
;
}
if
(
aFlexContainerAscent
=
=
nscoord_MIN
)
{
NS_WARNING_ASSERTION
(
aLines
[
0
]
.
IsEmpty
(
)
"
Have
flex
items
but
didn
'
t
get
an
ascent
-
that
'
s
odd
(
or
there
are
"
"
just
gigantic
sizes
involved
)
"
)
;
aFlexContainerAscent
=
desiredSizeInFlexWM
.
BSize
(
flexWM
)
;
}
if
(
HasAnyStateBits
(
NS_STATE_FLEX_SYNTHESIZE_BASELINE
)
)
{
aReflowOutput
.
SetBlockStartAscent
(
ReflowOutput
:
:
ASK_FOR_BASELINE
)
;
}
else
{
aReflowOutput
.
SetBlockStartAscent
(
aFlexContainerAscent
)
;
}
const
nscoord
effectiveContentBSizeWithBStartEndBP
=
desiredSizeInFlexWM
.
BSize
(
flexWM
)
+
blockEndContainerBP
;
if
(
aReflowInput
.
AvailableBSize
(
)
!
=
NS_UNCONSTRAINEDSIZE
&
&
effectiveContentBSizeWithBStartEndBP
>
aReflowInput
.
AvailableBSize
(
)
&
&
desiredSizeInFlexWM
.
BSize
(
flexWM
)
!
=
0
&
&
aReflowInput
.
ComputedBSize
(
)
!
=
NS_UNCONSTRAINEDSIZE
)
{
aStatus
.
SetIncomplete
(
)
;
if
(
aReflowInput
.
mStyleBorder
-
>
mBoxDecorationBreak
=
=
StyleBoxDecorationBreak
:
:
Slice
)
{
blockEndContainerBP
=
0
;
}
}
desiredSizeInFlexWM
.
BSize
(
flexWM
)
+
=
blockEndContainerBP
;
if
(
aStatus
.
IsComplete
(
)
&
&
aAnyChildIncomplete
)
{
aStatus
.
SetOverflowIncomplete
(
)
;
aStatus
.
SetNextInFlowNeedsReflow
(
)
;
}
mBaselineFromLastReflow
=
aFlexContainerAscent
;
mLastBaselineFromLastReflow
=
aLines
.
LastElement
(
)
.
LastBaselineOffset
(
)
;
if
(
mLastBaselineFromLastReflow
=
=
nscoord_MIN
)
{
mLastBaselineFromLastReflow
=
desiredSizeInFlexWM
.
BSize
(
flexWM
)
-
aFlexContainerAscent
;
}
aReflowOutput
.
SetSize
(
flexWM
desiredSizeInFlexWM
)
;
aReflowOutput
.
SetOverflowAreasToDesiredBounds
(
)
;
for
(
nsIFrame
*
childFrame
:
mFrames
)
{
ConsiderChildOverflow
(
aReflowOutput
.
mOverflowAreas
childFrame
)
;
}
}
void
nsFlexContainerFrame
:
:
MoveFlexItemToFinalPosition
(
const
ReflowInput
&
aReflowInput
const
FlexItem
&
aItem
LogicalPoint
&
aFramePos
const
nsSize
&
aContainerSize
)
{
WritingMode
outerWM
=
aReflowInput
.
GetWritingMode
(
)
;
LogicalMargin
logicalOffsets
(
outerWM
)
;
if
(
StylePositionProperty
:
:
Relative
=
=
aItem
.
Frame
(
)
-
>
StyleDisplay
(
)
-
>
mPosition
)
{
nsMargin
*
cachedOffsets
=
aItem
.
Frame
(
)
-
>
GetProperty
(
nsIFrame
:
:
ComputedOffsetProperty
(
)
)
;
MOZ_ASSERT
(
cachedOffsets
"
relpos
previously
-
reflowed
frame
should
'
ve
cached
its
offsets
"
)
;
logicalOffsets
=
LogicalMargin
(
outerWM
*
cachedOffsets
)
;
}
ReflowInput
:
:
ApplyRelativePositioning
(
aItem
.
Frame
(
)
outerWM
logicalOffsets
&
aFramePos
aContainerSize
)
;
aItem
.
Frame
(
)
-
>
SetPosition
(
outerWM
aFramePos
aContainerSize
)
;
PositionFrameView
(
aItem
.
Frame
(
)
)
;
PositionChildViews
(
aItem
.
Frame
(
)
)
;
}
nsReflowStatus
nsFlexContainerFrame
:
:
ReflowFlexItem
(
const
FlexboxAxisTracker
&
aAxisTracker
const
ReflowInput
&
aReflowInput
const
FlexItem
&
aItem
LogicalPoint
&
aFramePos
const
LogicalSize
&
aAvailableSize
const
nsSize
&
aContainerSize
bool
aHasLineClampEllipsis
)
{
WritingMode
outerWM
=
aReflowInput
.
GetWritingMode
(
)
;
ReflowInput
childReflowInput
(
PresContext
(
)
aReflowInput
aItem
.
Frame
(
)
aAvailableSize
)
;
childReflowInput
.
mFlags
.
mInsideLineClamp
=
GetLineClampValue
(
)
!
=
0
;
childReflowInput
.
mFlags
.
mApplyLineClamp
=
!
childReflowInput
.
mFlags
.
mInsideLineClamp
&
&
aHasLineClampEllipsis
;
bool
didOverrideComputedISize
=
false
;
bool
didOverrideComputedBSize
=
false
;
if
(
aItem
.
IsInlineAxisMainAxis
(
)
)
{
childReflowInput
.
SetComputedISize
(
aItem
.
MainSize
(
)
)
;
didOverrideComputedISize
=
true
;
}
else
{
childReflowInput
.
SetComputedBSize
(
aItem
.
MainSize
(
)
)
;
didOverrideComputedBSize
=
true
;
if
(
aItem
.
TreatBSizeAsIndefinite
(
)
)
{
childReflowInput
.
mFlags
.
mTreatBSizeAsIndefinite
=
true
;
}
}
if
(
aItem
.
IsStretched
(
)
|
|
aItem
.
HasIntrinsicRatio
(
)
)
{
if
(
aItem
.
IsInlineAxisCrossAxis
(
)
)
{
childReflowInput
.
SetComputedISize
(
aItem
.
CrossSize
(
)
)
;
didOverrideComputedISize
=
true
;
}
else
{
childReflowInput
.
SetComputedBSize
(
aItem
.
CrossSize
(
)
)
;
didOverrideComputedBSize
=
true
;
}
}
if
(
aItem
.
IsStretched
(
)
&
&
aItem
.
IsBlockAxisCrossAxis
(
)
)
{
aItem
.
Frame
(
)
-
>
AddStateBits
(
NS_FRAME_CONTAINS_RELATIVE_BSIZE
)
;
}
if
(
aItem
.
HadMeasuringReflow
(
)
)
{
if
(
didOverrideComputedISize
)
{
childReflowInput
.
SetIResize
(
true
)
;
}
if
(
didOverrideComputedBSize
)
{
childReflowInput
.
SetBResize
(
true
)
;
childReflowInput
.
mFlags
.
mIsBResizeForPercentages
=
true
;
}
}
ReflowOutput
childReflowOutput
(
childReflowInput
)
;
nsReflowStatus
childReflowStatus
;
ReflowChild
(
aItem
.
Frame
(
)
PresContext
(
)
childReflowOutput
childReflowInput
outerWM
aFramePos
aContainerSize
ReflowChildFlags
:
:
Default
childReflowStatus
)
;
FinishReflowChild
(
aItem
.
Frame
(
)
PresContext
(
)
childReflowOutput
&
childReflowInput
outerWM
aFramePos
aContainerSize
ReflowChildFlags
:
:
ApplyRelativePositioning
)
;
aItem
.
SetAscent
(
childReflowOutput
.
BlockStartAscent
(
)
)
;
if
(
auto
*
cached
=
aItem
.
Frame
(
)
-
>
GetProperty
(
CachedFlexItemData
:
:
Prop
(
)
)
)
{
cached
-
>
UpdateFinalReflowSize
(
childReflowInput
childReflowOutput
)
;
}
else
{
cached
=
new
CachedFlexItemData
(
childReflowInput
childReflowOutput
FlexItemReflowType
:
:
Final
)
;
aItem
.
Frame
(
)
-
>
SetProperty
(
CachedFlexItemData
:
:
Prop
(
)
cached
)
;
}
return
childReflowStatus
;
}
void
nsFlexContainerFrame
:
:
ReflowPlaceholders
(
const
ReflowInput
&
aReflowInput
nsTArray
<
nsIFrame
*
>
&
aPlaceholders
const
LogicalPoint
&
aContentBoxOrigin
const
nsSize
&
aContainerSize
)
{
WritingMode
outerWM
=
aReflowInput
.
GetWritingMode
(
)
;
for
(
nsIFrame
*
placeholder
:
aPlaceholders
)
{
MOZ_ASSERT
(
placeholder
-
>
IsPlaceholderFrame
(
)
"
placeholders
array
should
only
contain
placeholder
frames
"
)
;
WritingMode
wm
=
placeholder
-
>
GetWritingMode
(
)
;
LogicalSize
availSize
=
aReflowInput
.
ComputedSize
(
wm
)
;
ReflowInput
childReflowInput
(
PresContext
(
)
aReflowInput
placeholder
availSize
)
;
ReflowOutput
childReflowOutput
(
childReflowInput
)
;
nsReflowStatus
childReflowStatus
;
ReflowChild
(
placeholder
PresContext
(
)
childReflowOutput
childReflowInput
outerWM
aContentBoxOrigin
aContainerSize
ReflowChildFlags
:
:
Default
childReflowStatus
)
;
FinishReflowChild
(
placeholder
PresContext
(
)
childReflowOutput
&
childReflowInput
outerWM
aContentBoxOrigin
aContainerSize
ReflowChildFlags
:
:
Default
)
;
placeholder
-
>
AddStateBits
(
PLACEHOLDER_STATICPOS_NEEDS_CSSALIGN
)
;
}
}
nscoord
nsFlexContainerFrame
:
:
IntrinsicISize
(
gfxContext
*
aRenderingContext
IntrinsicISizeType
aType
)
{
nscoord
containerISize
=
0
;
const
nsStylePosition
*
stylePos
=
StylePosition
(
)
;
const
FlexboxAxisTracker
axisTracker
(
this
)
;
nscoord
mainGapSize
;
if
(
axisTracker
.
IsRowOriented
(
)
)
{
mainGapSize
=
nsLayoutUtils
:
:
ResolveGapToLength
(
stylePos
-
>
mColumnGap
NS_UNCONSTRAINEDSIZE
)
;
}
else
{
mainGapSize
=
nsLayoutUtils
:
:
ResolveGapToLength
(
stylePos
-
>
mRowGap
NS_UNCONSTRAINEDSIZE
)
;
}
const
bool
useMozBoxCollapseBehavior
=
ShouldUseMozBoxCollapseBehavior
(
StyleDisplay
(
)
)
;
bool
onFirstChild
=
true
;
for
(
nsIFrame
*
childFrame
:
mFrames
)
{
if
(
childFrame
-
>
IsPlaceholderFrame
(
)
)
{
continue
;
}
if
(
!
useMozBoxCollapseBehavior
|
|
(
StyleVisibility
:
:
Collapse
!
=
childFrame
-
>
StyleVisibility
(
)
-
>
mVisible
)
)
{
nscoord
childISize
=
nsLayoutUtils
:
:
IntrinsicForContainer
(
aRenderingContext
childFrame
aType
)
;
bool
isSingleLine
=
(
StyleFlexWrap
:
:
Nowrap
=
=
stylePos
-
>
mFlexWrap
)
;
if
(
axisTracker
.
IsRowOriented
(
)
&
&
(
isSingleLine
|
|
aType
=
=
nsLayoutUtils
:
:
PREF_ISIZE
)
)
{
containerISize
+
=
childISize
;
if
(
!
onFirstChild
)
{
containerISize
+
=
mainGapSize
;
}
onFirstChild
=
false
;
}
else
{
containerISize
=
std
:
:
max
(
containerISize
childISize
)
;
}
}
}
return
containerISize
;
}
nscoord
nsFlexContainerFrame
:
:
GetMinISize
(
gfxContext
*
aRenderingContext
)
{
DISPLAY_MIN_INLINE_SIZE
(
this
mCachedMinISize
)
;
if
(
mCachedMinISize
=
=
NS_INTRINSIC_ISIZE_UNKNOWN
)
{
mCachedMinISize
=
StyleDisplay
(
)
-
>
IsContainSize
(
)
?
0
:
IntrinsicISize
(
aRenderingContext
nsLayoutUtils
:
:
MIN_ISIZE
)
;
}
return
mCachedMinISize
;
}
nscoord
nsFlexContainerFrame
:
:
GetPrefISize
(
gfxContext
*
aRenderingContext
)
{
DISPLAY_PREF_INLINE_SIZE
(
this
mCachedPrefISize
)
;
if
(
mCachedPrefISize
=
=
NS_INTRINSIC_ISIZE_UNKNOWN
)
{
mCachedPrefISize
=
StyleDisplay
(
)
-
>
IsContainSize
(
)
?
0
:
IntrinsicISize
(
aRenderingContext
nsLayoutUtils
:
:
PREF_ISIZE
)
;
}
return
mCachedPrefISize
;
}
uint32_t
nsFlexContainerFrame
:
:
GetLineClampValue
(
)
const
{
if
(
!
HasAnyStateBits
(
NS_STATE_FLEX_IS_EMULATING_LEGACY_BOX
)
|
|
StyleXUL
(
)
-
>
mBoxOrient
!
=
StyleBoxOrient
:
:
Vertical
)
{
return
0
;
}
return
StyleDisplay
(
)
-
>
mLineClamp
;
}
