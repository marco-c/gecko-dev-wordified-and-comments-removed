#
ifndef
nsGridContainerFrame_h___
#
define
nsGridContainerFrame_h___
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsTHashtable
.
h
"
nsContainerFrame
*
NS_NewGridContainerFrame
(
nsIPresShell
*
aPresShell
nsStyleContext
*
aContext
)
;
namespace
mozilla
{
struct
ComputedGridTrackInfo
{
ComputedGridTrackInfo
(
uint32_t
aNumLeadingImplicitTracks
uint32_t
aNumExplicitTracks
nsTArray
<
nscoord
>
&
&
aSizes
)
:
mNumLeadingImplicitTracks
(
aNumLeadingImplicitTracks
)
mNumExplicitTracks
(
aNumExplicitTracks
)
mSizes
(
aSizes
)
{
}
uint32_t
mNumLeadingImplicitTracks
;
uint32_t
mNumExplicitTracks
;
nsTArray
<
nscoord
>
mSizes
;
}
;
}
class
nsGridContainerFrame
final
:
public
nsContainerFrame
{
public
:
NS_DECL_FRAMEARENA_HELPERS
NS_DECL_QUERYFRAME_TARGET
(
nsGridContainerFrame
)
NS_DECL_QUERYFRAME
typedef
mozilla
:
:
ComputedGridTrackInfo
ComputedGridTrackInfo
;
void
Reflow
(
nsPresContext
*
aPresContext
nsHTMLReflowMetrics
&
aDesiredSize
const
nsHTMLReflowState
&
aReflowState
nsReflowStatus
&
aStatus
)
override
;
nscoord
GetMinISize
(
nsRenderingContext
*
aRenderingContext
)
override
;
nscoord
GetPrefISize
(
nsRenderingContext
*
aRenderingContext
)
override
;
void
MarkIntrinsicISizesDirty
(
)
override
;
nsIAtom
*
GetType
(
)
const
override
;
bool
IsFrameOfType
(
uint32_t
aFlags
)
const
override
{
return
nsContainerFrame
:
:
IsFrameOfType
(
aFlags
&
~
nsIFrame
:
:
eCanContainOverflowContainers
)
;
}
void
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aDirtyRect
const
nsDisplayListSet
&
aLists
)
override
;
#
ifdef
DEBUG_FRAME_DUMP
nsresult
GetFrameName
(
nsAString
&
aResult
)
const
override
;
#
endif
bool
DrainSelfOverflowList
(
)
override
;
void
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
override
;
void
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
aFrameList
)
override
;
void
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
override
;
#
ifdef
DEBUG
void
SetInitialChildList
(
ChildListID
aListID
nsFrameList
&
aChildList
)
override
;
#
endif
static
const
nsRect
&
GridItemCB
(
nsIFrame
*
aChild
)
;
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
GridItemContainingBlockRect
nsRect
)
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
GridColTrackInfo
ComputedGridTrackInfo
)
const
ComputedGridTrackInfo
*
GetComputedTemplateColumns
(
)
{
return
Properties
(
)
.
Get
(
GridColTrackInfo
(
)
)
;
}
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
GridRowTrackInfo
ComputedGridTrackInfo
)
const
ComputedGridTrackInfo
*
GetComputedTemplateRows
(
)
{
return
Properties
(
)
.
Get
(
GridRowTrackInfo
(
)
)
;
}
struct
TrackSize
;
protected
:
static
const
uint32_t
kAutoLine
;
static
const
uint32_t
kTranslatedMaxLine
;
typedef
mozilla
:
:
LogicalPoint
LogicalPoint
;
typedef
mozilla
:
:
LogicalRect
LogicalRect
;
typedef
mozilla
:
:
LogicalSize
LogicalSize
;
typedef
mozilla
:
:
WritingMode
WritingMode
;
typedef
mozilla
:
:
css
:
:
GridNamedArea
GridNamedArea
;
typedef
mozilla
:
:
layout
:
:
AutoFrameListPtr
AutoFrameListPtr
;
typedef
nsLayoutUtils
:
:
IntrinsicISizeType
IntrinsicISizeType
;
struct
Grid
;
struct
GridArea
;
class
GridItemCSSOrderIterator
;
struct
GridItemInfo
;
struct
GridReflowState
;
class
LineNameMap
;
struct
LineRange
;
struct
SharedGridData
;
struct
TrackSizingFunctions
;
struct
Tracks
;
struct
TranslatedLineRange
;
friend
nsContainerFrame
*
NS_NewGridContainerFrame
(
nsIPresShell
*
aPresShell
nsStyleContext
*
aContext
)
;
explicit
nsGridContainerFrame
(
nsStyleContext
*
aContext
)
:
nsContainerFrame
(
aContext
)
mCachedMinISize
(
NS_INTRINSIC_WIDTH_UNKNOWN
)
mCachedPrefISize
(
NS_INTRINSIC_WIDTH_UNKNOWN
)
{
}
typedef
nsTHashtable
<
nsStringHashKey
>
ImplicitNamedAreas
;
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
ImplicitNamedAreasProperty
ImplicitNamedAreas
)
void
InitImplicitNamedAreas
(
const
nsStylePosition
*
aStyle
)
;
void
AddImplicitNamedAreas
(
const
nsTArray
<
nsTArray
<
nsString
>
>
&
aLineNameLists
)
;
ImplicitNamedAreas
*
GetImplicitNamedAreas
(
)
const
{
return
Properties
(
)
.
Get
(
ImplicitNamedAreasProperty
(
)
)
;
}
nscoord
ReflowChildren
(
GridReflowState
&
aState
const
LogicalRect
&
aContentArea
nsHTMLReflowMetrics
&
aDesiredSize
nsReflowStatus
&
aStatus
)
;
nscoord
IntrinsicISize
(
nsRenderingContext
*
aRenderingContext
IntrinsicISizeType
aConstraint
)
;
void
NoteNewChildren
(
ChildListID
aListID
const
nsFrameList
&
aFrameList
)
;
void
MergeSortedOverflow
(
nsFrameList
&
aList
)
;
void
MergeSortedExcessOverflowContainers
(
nsFrameList
&
aList
)
;
#
ifdef
DEBUG
void
SanityCheckGridItemsBeforeReflow
(
)
const
;
#
endif
private
:
struct
Fragmentainer
{
nscoord
mToFragmentainerEnd
;
bool
mIsTopOfPage
;
bool
mCanBreakAtStart
;
bool
mCanBreakAtEnd
;
bool
mIsAutoBSize
;
}
;
mozilla
:
:
Maybe
<
nsGridContainerFrame
:
:
Fragmentainer
>
GetNearestFragmentainer
(
const
GridReflowState
&
aState
)
const
;
nscoord
ReflowInFragmentainer
(
GridReflowState
&
aState
const
LogicalRect
&
aContentArea
nsHTMLReflowMetrics
&
aDesiredSize
nsReflowStatus
&
aStatus
Fragmentainer
&
aFragmentainer
const
nsSize
&
aContainerSize
)
;
nscoord
ReflowRowsInFragmentainer
(
GridReflowState
&
aState
const
LogicalRect
&
aContentArea
nsHTMLReflowMetrics
&
aDesiredSize
nsReflowStatus
&
aStatus
Fragmentainer
&
aFragmentainer
const
nsSize
&
aContainerSize
const
nsTArray
<
const
GridItemInfo
*
>
&
aItems
uint32_t
aStartRow
uint32_t
aEndRow
nscoord
aBSize
nscoord
aAvailableSize
)
;
void
ReflowInFlowChild
(
nsIFrame
*
aChild
const
GridItemInfo
*
aGridItemInfo
nsSize
aContainerSize
mozilla
:
:
Maybe
<
nscoord
>
aStretchBSize
const
Fragmentainer
*
aFragmentainer
const
GridReflowState
&
aState
const
LogicalRect
&
aContentArea
nsHTMLReflowMetrics
&
aDesiredSize
nsReflowStatus
&
aStatus
)
;
nscoord
mCachedMinISize
;
nscoord
mCachedPrefISize
;
#
ifdef
DEBUG
bool
mDidPushItemsBitMayLie
;
#
endif
}
;
#
endif
