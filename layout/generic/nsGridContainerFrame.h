#
ifndef
nsGridContainerFrame_h___
#
define
nsGridContainerFrame_h___
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsTHashtable
.
h
"
nsContainerFrame
*
NS_NewGridContainerFrame
(
nsIPresShell
*
aPresShell
nsStyleContext
*
aContext
)
;
class
nsGridContainerFrame
final
:
public
nsContainerFrame
{
public
:
NS_DECL_FRAMEARENA_HELPERS
NS_DECL_QUERYFRAME_TARGET
(
nsGridContainerFrame
)
NS_DECL_QUERYFRAME
void
Reflow
(
nsPresContext
*
aPresContext
nsHTMLReflowMetrics
&
aDesiredSize
const
nsHTMLReflowState
&
aReflowState
nsReflowStatus
&
aStatus
)
override
;
nscoord
GetMinISize
(
nsRenderingContext
*
aRenderingContext
)
override
;
nscoord
GetPrefISize
(
nsRenderingContext
*
aRenderingContext
)
override
;
void
MarkIntrinsicISizesDirty
(
)
override
;
virtual
nsIAtom
*
GetType
(
)
const
override
;
void
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aDirtyRect
const
nsDisplayListSet
&
aLists
)
override
;
#
ifdef
DEBUG_FRAME_DUMP
virtual
nsresult
GetFrameName
(
nsAString
&
aResult
)
const
override
;
#
endif
static
const
nsRect
&
GridItemCB
(
nsIFrame
*
aChild
)
;
struct
TrackSize
{
void
Initialize
(
nscoord
aPercentageBasis
const
nsStyleCoord
&
aMinCoord
const
nsStyleCoord
&
aMaxCoord
)
;
bool
IsFrozen
(
)
const
{
return
mState
&
eFrozen
;
}
#
ifdef
DEBUG
void
Dump
(
)
const
;
#
endif
enum
StateBits
:
uint16_t
{
eAutoMinSizing
=
0x1
eMinContentMinSizing
=
0x2
eMaxContentMinSizing
=
0x4
eMinOrMaxContentMinSizing
=
eMinContentMinSizing
|
eMaxContentMinSizing
eIntrinsicMinSizing
=
eMinOrMaxContentMinSizing
|
eAutoMinSizing
eFlexMinSizing
=
0x8
eAutoMaxSizing
=
0x10
eMinContentMaxSizing
=
0x20
eMaxContentMaxSizing
=
0x40
eAutoOrMaxContentMaxSizing
=
eAutoMaxSizing
|
eMaxContentMaxSizing
eIntrinsicMaxSizing
=
eAutoOrMaxContentMaxSizing
|
eMinContentMaxSizing
eFlexMaxSizing
=
0x80
eFrozen
=
0x100
eSkipGrowUnlimited1
=
0x200
eSkipGrowUnlimited2
=
0x400
eSkipGrowUnlimited
=
eSkipGrowUnlimited1
|
eSkipGrowUnlimited2
}
;
nscoord
mBase
;
nscoord
mLimit
;
nscoord
mPosition
;
StateBits
mState
;
}
;
NS_DECLARE_FRAME_PROPERTY
(
GridItemContainingBlockRect
DeleteValue
<
nsRect
>
)
NS_DECLARE_FRAME_PROPERTY
(
GridColTrackSizes
DeleteValue
<
nsTArray
<
nscoord
>
>
)
const
nsTArray
<
nscoord
>
*
GetComputedTemplateColumns
(
)
{
return
static_cast
<
nsTArray
<
nscoord
>
*
>
(
Properties
(
)
.
Get
(
GridColTrackSizes
(
)
)
)
;
}
NS_DECLARE_FRAME_PROPERTY
(
GridRowTrackSizes
DeleteValue
<
nsTArray
<
nscoord
>
>
)
const
nsTArray
<
nscoord
>
*
GetComputedTemplateRows
(
)
{
return
static_cast
<
nsTArray
<
nscoord
>
*
>
(
Properties
(
)
.
Get
(
GridRowTrackSizes
(
)
)
)
;
}
uint32_t
NumImplicitLeadingCols
(
)
const
{
return
mExplicitGridOffsetCol
;
}
uint32_t
NumImplicitLeadingRows
(
)
const
{
return
mExplicitGridOffsetRow
;
}
uint32_t
NumExplicitCols
(
)
const
{
return
mExplicitGridColEnd
-
1
;
}
uint32_t
NumExplicitRows
(
)
const
{
return
mExplicitGridRowEnd
-
1
;
}
protected
:
static
const
uint32_t
kAutoLine
;
static
const
uint32_t
kTranslatedMaxLine
;
typedef
mozilla
:
:
LogicalPoint
LogicalPoint
;
typedef
mozilla
:
:
LogicalRect
LogicalRect
;
typedef
mozilla
:
:
LogicalSize
LogicalSize
;
typedef
mozilla
:
:
WritingMode
WritingMode
;
typedef
mozilla
:
:
css
:
:
GridNamedArea
GridNamedArea
;
typedef
nsLayoutUtils
:
:
IntrinsicISizeType
IntrinsicISizeType
;
class
GridItemCSSOrderIterator
;
struct
TrackSizingFunctions
;
struct
Tracks
;
struct
GridReflowState
;
class
LineNameMap
;
friend
nsContainerFrame
*
NS_NewGridContainerFrame
(
nsIPresShell
*
aPresShell
nsStyleContext
*
aContext
)
;
explicit
nsGridContainerFrame
(
nsStyleContext
*
aContext
)
:
nsContainerFrame
(
aContext
)
mCachedMinISize
(
NS_INTRINSIC_WIDTH_UNKNOWN
)
mCachedPrefISize
(
NS_INTRINSIC_WIDTH_UNKNOWN
)
{
}
struct
LineRange
{
LineRange
(
int32_t
aStart
int32_t
aEnd
)
:
mUntranslatedStart
(
aStart
)
mUntranslatedEnd
(
aEnd
)
{
#
ifdef
DEBUG
if
(
!
IsAutoAuto
(
)
)
{
if
(
IsAuto
(
)
)
{
MOZ_ASSERT
(
aEnd
>
=
nsStyleGridLine
:
:
kMinLine
&
&
aEnd
<
=
nsStyleGridLine
:
:
kMaxLine
"
invalid
span
"
)
;
}
else
{
MOZ_ASSERT
(
aStart
>
=
nsStyleGridLine
:
:
kMinLine
&
&
aStart
<
=
nsStyleGridLine
:
:
kMaxLine
"
invalid
start
line
"
)
;
MOZ_ASSERT
(
aEnd
=
=
int32_t
(
kAutoLine
)
|
|
(
aEnd
>
=
nsStyleGridLine
:
:
kMinLine
&
&
aEnd
<
=
nsStyleGridLine
:
:
kMaxLine
)
"
invalid
end
line
"
)
;
}
}
#
endif
}
bool
IsAutoAuto
(
)
const
{
return
mStart
=
=
kAutoLine
&
&
mEnd
=
=
kAutoLine
;
}
bool
IsAuto
(
)
const
{
return
mStart
=
=
kAutoLine
;
}
bool
IsDefinite
(
)
const
{
return
mStart
!
=
kAutoLine
;
}
uint32_t
Extent
(
)
const
{
MOZ_ASSERT
(
mEnd
!
=
kAutoLine
"
Extent
is
undefined
for
abs
.
pos
.
'
auto
'
"
)
;
if
(
IsAuto
(
)
)
{
MOZ_ASSERT
(
mEnd
>
=
1
&
&
mEnd
<
uint32_t
(
nsStyleGridLine
:
:
kMaxLine
)
"
invalid
span
"
)
;
return
mEnd
;
}
return
mEnd
-
mStart
;
}
void
ResolveAutoPosition
(
uint32_t
aStart
uint32_t
aExplicitGridOffset
)
{
MOZ_ASSERT
(
IsAuto
(
)
"
Why
call
me
?
"
)
;
mStart
=
aStart
;
mEnd
+
=
aStart
;
uint32_t
translatedMax
=
aExplicitGridOffset
+
nsStyleGridLine
:
:
kMaxLine
;
if
(
MOZ_UNLIKELY
(
mStart
>
=
translatedMax
)
)
{
mEnd
=
translatedMax
;
mStart
=
mEnd
-
1
;
}
else
if
(
MOZ_UNLIKELY
(
mEnd
>
translatedMax
)
)
{
mEnd
=
translatedMax
;
}
}
void
AdjustForRemovedTracks
(
const
nsTArray
<
uint32_t
>
&
aNumRemovedTracks
)
{
MOZ_ASSERT
(
mStart
!
=
kAutoLine
"
invalid
resolved
line
for
a
grid
item
"
)
;
MOZ_ASSERT
(
mEnd
!
=
kAutoLine
"
invalid
resolved
line
for
a
grid
item
"
)
;
uint32_t
numRemovedTracks
=
aNumRemovedTracks
[
mStart
]
;
MOZ_ASSERT
(
numRemovedTracks
=
=
aNumRemovedTracks
[
mEnd
]
"
tracks
that
a
grid
item
spans
can
'
t
be
removed
"
)
;
mStart
-
=
numRemovedTracks
;
mEnd
-
=
numRemovedTracks
;
}
void
AdjustAbsPosForRemovedTracks
(
const
nsTArray
<
uint32_t
>
&
aNumRemovedTracks
)
{
if
(
mStart
!
=
nsGridContainerFrame
:
:
kAutoLine
)
{
mStart
-
=
aNumRemovedTracks
[
mStart
]
;
}
if
(
mEnd
!
=
nsGridContainerFrame
:
:
kAutoLine
)
{
MOZ_ASSERT
(
mStart
=
=
nsGridContainerFrame
:
:
kAutoLine
|
|
mEnd
>
mStart
"
invalid
line
range
"
)
;
mEnd
-
=
aNumRemovedTracks
[
mEnd
]
;
}
if
(
mStart
=
=
mEnd
)
{
mEnd
=
nsGridContainerFrame
:
:
kAutoLine
;
}
}
uint32_t
HypotheticalEnd
(
)
const
{
return
mEnd
;
}
void
ToPositionAndLength
(
const
nsTArray
<
TrackSize
>
&
aTrackSizes
nscoord
*
aPos
nscoord
*
aLength
)
const
;
nscoord
ToLength
(
const
nsTArray
<
TrackSize
>
&
aTrackSizes
)
const
;
void
ToPositionAndLengthForAbsPos
(
const
nsTArray
<
TrackSize
>
&
aTrackSizes
nscoord
aGridOrigin
nscoord
*
aPos
nscoord
*
aLength
)
const
;
union
{
uint32_t
mStart
;
int32_t
mUntranslatedStart
;
}
;
union
{
uint32_t
mEnd
;
int32_t
mUntranslatedEnd
;
}
;
protected
:
LineRange
(
)
{
}
}
;
struct
TranslatedLineRange
:
public
LineRange
{
TranslatedLineRange
(
uint32_t
aStart
uint32_t
aEnd
)
{
MOZ_ASSERT
(
aStart
<
aEnd
&
&
aEnd
<
=
kTranslatedMaxLine
)
;
mStart
=
aStart
;
mEnd
=
aEnd
;
}
}
;
static
int32_t
AutoIfOutside
(
int32_t
aLine
int32_t
aMin
int32_t
aMax
)
{
MOZ_ASSERT
(
aMin
<
=
aMax
)
;
if
(
aLine
<
aMin
|
|
aLine
>
aMax
)
{
return
kAutoLine
;
}
return
aLine
;
}
struct
GridArea
{
GridArea
(
const
LineRange
&
aCols
const
LineRange
&
aRows
)
:
mCols
(
aCols
)
mRows
(
aRows
)
{
}
bool
IsDefinite
(
)
const
{
return
mCols
.
IsDefinite
(
)
&
&
mRows
.
IsDefinite
(
)
;
}
LineRange
mCols
;
LineRange
mRows
;
}
;
struct
CellMap
{
struct
Cell
{
Cell
(
)
:
mIsOccupied
(
false
)
{
}
bool
mIsOccupied
:
1
;
}
;
void
Fill
(
const
GridArea
&
aGridArea
)
;
void
ClearOccupied
(
)
;
uint32_t
IsEmptyCol
(
uint32_t
aCol
)
const
{
for
(
auto
&
row
:
mCells
)
{
if
(
aCol
<
row
.
Length
(
)
&
&
row
[
aCol
]
.
mIsOccupied
)
{
return
false
;
}
}
return
true
;
}
uint32_t
IsEmptyRow
(
uint32_t
aRow
)
const
{
if
(
aRow
>
=
mCells
.
Length
(
)
)
{
return
true
;
}
for
(
const
Cell
&
cell
:
mCells
[
aRow
]
)
{
if
(
cell
.
mIsOccupied
)
{
return
false
;
}
}
return
true
;
}
#
if
DEBUG
void
Dump
(
)
const
;
#
endif
nsTArray
<
nsTArray
<
Cell
>
>
mCells
;
}
;
struct
GridItemInfo
{
explicit
GridItemInfo
(
const
GridArea
&
aArea
)
:
mArea
(
aArea
)
{
mIsFlexing
[
0
]
=
false
;
mIsFlexing
[
1
]
=
false
;
}
GridArea
mArea
;
bool
mIsFlexing
[
2
]
;
static_assert
(
mozilla
:
:
eLogicalAxisBlock
=
=
0
"
unexpected
index
value
"
)
;
static_assert
(
mozilla
:
:
eLogicalAxisInline
=
=
1
"
unexpected
index
value
"
)
;
#
ifdef
DEBUG
nsIFrame
*
mFrame
;
#
endif
}
;
enum
LineRangeSide
{
eLineRangeSideStart
eLineRangeSideEnd
}
;
int32_t
ResolveLine
(
const
nsStyleGridLine
&
aLine
int32_t
aNth
uint32_t
aFromIndex
const
LineNameMap
&
aNameMap
uint32_t
GridNamedArea
:
:
*
aAreaStart
uint32_t
GridNamedArea
:
:
*
aAreaEnd
uint32_t
aExplicitGridEnd
LineRangeSide
aEdge
const
nsStylePosition
*
aStyle
)
;
LineRange
ResolveLineRange
(
const
nsStyleGridLine
&
aStart
const
nsStyleGridLine
&
aEnd
const
LineNameMap
&
aNameMap
uint32_t
GridNamedArea
:
:
*
aAreaStart
uint32_t
GridNamedArea
:
:
*
aAreaEnd
uint32_t
aExplicitGridEnd
const
nsStylePosition
*
aStyle
)
;
LineRange
ResolveAbsPosLineRange
(
const
nsStyleGridLine
&
aStart
const
nsStyleGridLine
&
aEnd
const
LineNameMap
&
aNameMap
uint32_t
GridNamedArea
:
:
*
aAreaStart
uint32_t
GridNamedArea
:
:
*
aAreaEnd
uint32_t
aExplicitGridEnd
int32_t
aGridStart
int32_t
aGridEnd
const
nsStylePosition
*
aStyle
)
;
GridArea
PlaceDefinite
(
nsIFrame
*
aChild
const
LineNameMap
&
aColLineNameMap
const
LineNameMap
&
aRowLineNameMap
const
nsStylePosition
*
aStyle
)
;
void
PlaceAutoCol
(
uint32_t
aStartCol
GridArea
*
aArea
)
const
;
uint32_t
FindAutoCol
(
uint32_t
aStartCol
uint32_t
aLockedRow
const
GridArea
*
aArea
)
const
;
void
PlaceAutoRow
(
uint32_t
aStartRow
GridArea
*
aArea
)
const
;
uint32_t
FindAutoRow
(
uint32_t
aLockedCol
uint32_t
aStartRow
const
GridArea
*
aArea
)
const
;
void
PlaceAutoAutoInRowOrder
(
uint32_t
aStartCol
uint32_t
aStartRow
GridArea
*
aArea
)
const
;
void
PlaceAutoAutoInColOrder
(
uint32_t
aStartCol
uint32_t
aStartRow
GridArea
*
aArea
)
const
;
GridArea
PlaceAbsPos
(
nsIFrame
*
aChild
const
LineNameMap
&
aColLineNameMap
const
LineNameMap
&
aRowLineNameMap
const
nsStylePosition
*
aStyle
)
;
void
PlaceGridItems
(
GridReflowState
&
aState
const
LogicalSize
&
aComputedMinSize
const
LogicalSize
&
aComputedSize
const
LogicalSize
&
aComputedMaxSize
)
;
void
PlaceGridItems
(
GridReflowState
&
aState
const
LineNameMap
&
aColLineNameMap
const
LineNameMap
&
aRowLineNameMap
)
;
void
InflateGridFor
(
const
GridArea
&
aArea
)
{
mGridColEnd
=
std
:
:
max
(
mGridColEnd
aArea
.
mCols
.
HypotheticalEnd
(
)
)
;
mGridRowEnd
=
std
:
:
max
(
mGridRowEnd
aArea
.
mRows
.
HypotheticalEnd
(
)
)
;
MOZ_ASSERT
(
mGridColEnd
<
=
kTranslatedMaxLine
&
&
mGridRowEnd
<
=
kTranslatedMaxLine
)
;
}
void
CalculateTrackSizes
(
GridReflowState
&
aState
const
mozilla
:
:
LogicalSize
&
aContentBox
IntrinsicISizeType
aConstraint
)
;
typedef
std
:
:
pair
<
int32_t
int32_t
>
LinePair
;
LinePair
ResolveLineRangeHelper
(
const
nsStyleGridLine
&
aStart
const
nsStyleGridLine
&
aEnd
const
LineNameMap
&
aNameMap
uint32_t
GridNamedArea
:
:
*
aAreaStart
uint32_t
GridNamedArea
:
:
*
aAreaEnd
uint32_t
aExplicitGridEnd
const
nsStylePosition
*
aStyle
)
;
NS_DECLARE_FRAME_PROPERTY
(
ImplicitNamedAreasProperty
DeleteValue
<
ImplicitNamedAreas
>
)
void
InitImplicitNamedAreas
(
const
nsStylePosition
*
aStyle
)
;
void
AddImplicitNamedAreas
(
const
nsTArray
<
nsTArray
<
nsString
>
>
&
aLineNameLists
)
;
typedef
nsTHashtable
<
nsStringHashKey
>
ImplicitNamedAreas
;
ImplicitNamedAreas
*
GetImplicitNamedAreas
(
)
const
{
return
static_cast
<
ImplicitNamedAreas
*
>
(
Properties
(
)
.
Get
(
ImplicitNamedAreasProperty
(
)
)
)
;
}
bool
HasImplicitNamedArea
(
const
nsString
&
aName
)
const
{
ImplicitNamedAreas
*
areas
=
GetImplicitNamedAreas
(
)
;
return
areas
&
&
areas
-
>
Contains
(
aName
)
;
}
LogicalRect
ContainingBlockFor
(
const
GridReflowState
&
aState
const
GridArea
&
aArea
)
const
;
LogicalRect
ContainingBlockForAbsPos
(
const
GridReflowState
&
aState
const
GridArea
&
aArea
const
LogicalPoint
&
aGridOrigin
const
LogicalRect
&
aGridCB
)
const
;
void
ReflowChildren
(
GridReflowState
&
aState
const
LogicalRect
&
aContentArea
nsHTMLReflowMetrics
&
aDesiredSize
nsReflowStatus
&
aStatus
)
;
nscoord
IntrinsicISize
(
nsRenderingContext
*
aRenderingContext
IntrinsicISizeType
aConstraint
)
;
#
ifdef
DEBUG
void
SanityCheckAnonymousGridItems
(
)
const
;
#
endif
private
:
nsTArray
<
GridItemInfo
>
mGridItems
;
nsTArray
<
GridItemInfo
>
mAbsPosItems
;
CellMap
mCellMap
;
uint32_t
mExplicitGridColEnd
;
uint32_t
mExplicitGridRowEnd
;
uint32_t
mGridColEnd
;
uint32_t
mGridRowEnd
;
uint32_t
mExplicitGridOffsetCol
;
uint32_t
mExplicitGridOffsetRow
;
nscoord
mCachedMinISize
;
nscoord
mCachedPrefISize
;
bool
mIsNormalFlowInCSSOrder
:
1
;
}
;
namespace
mozilla
{
template
<
>
struct
IsPod
<
nsGridContainerFrame
:
:
TrackSize
>
:
TrueType
{
}
;
}
#
endif
