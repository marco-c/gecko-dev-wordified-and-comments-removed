#
ifndef
nsGridContainerFrame_h___
#
define
nsGridContainerFrame_h___
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsTHashtable
.
h
"
nsContainerFrame
*
NS_NewGridContainerFrame
(
nsIPresShell
*
aPresShell
nsStyleContext
*
aContext
)
;
namespace
mozilla
{
struct
ComputedGridTrackInfo
{
ComputedGridTrackInfo
(
uint32_t
aNumLeadingImplicitTracks
uint32_t
aNumExplicitTracks
nsTArray
<
nscoord
>
&
&
aSizes
)
:
mNumLeadingImplicitTracks
(
aNumLeadingImplicitTracks
)
mNumExplicitTracks
(
aNumExplicitTracks
)
mSizes
(
aSizes
)
{
}
uint32_t
mNumLeadingImplicitTracks
;
uint32_t
mNumExplicitTracks
;
nsTArray
<
nscoord
>
mSizes
;
}
;
}
class
nsGridContainerFrame
final
:
public
nsContainerFrame
{
public
:
NS_DECL_FRAMEARENA_HELPERS
NS_DECL_QUERYFRAME_TARGET
(
nsGridContainerFrame
)
NS_DECL_QUERYFRAME
void
Reflow
(
nsPresContext
*
aPresContext
nsHTMLReflowMetrics
&
aDesiredSize
const
nsHTMLReflowState
&
aReflowState
nsReflowStatus
&
aStatus
)
override
;
nscoord
GetMinISize
(
nsRenderingContext
*
aRenderingContext
)
override
;
nscoord
GetPrefISize
(
nsRenderingContext
*
aRenderingContext
)
override
;
void
MarkIntrinsicISizesDirty
(
)
override
;
virtual
nsIAtom
*
GetType
(
)
const
override
;
void
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aDirtyRect
const
nsDisplayListSet
&
aLists
)
override
;
#
ifdef
DEBUG_FRAME_DUMP
virtual
nsresult
GetFrameName
(
nsAString
&
aResult
)
const
override
;
#
endif
static
const
nsRect
&
GridItemCB
(
nsIFrame
*
aChild
)
;
struct
TrackSize
{
void
Initialize
(
nscoord
aPercentageBasis
const
nsStyleCoord
&
aMinCoord
const
nsStyleCoord
&
aMaxCoord
)
;
bool
IsFrozen
(
)
const
{
return
mState
&
eFrozen
;
}
#
ifdef
DEBUG
void
Dump
(
)
const
;
#
endif
enum
StateBits
:
uint16_t
{
eAutoMinSizing
=
0x1
eMinContentMinSizing
=
0x2
eMaxContentMinSizing
=
0x4
eMinOrMaxContentMinSizing
=
eMinContentMinSizing
|
eMaxContentMinSizing
eIntrinsicMinSizing
=
eMinOrMaxContentMinSizing
|
eAutoMinSizing
eFlexMinSizing
=
0x8
eAutoMaxSizing
=
0x10
eMinContentMaxSizing
=
0x20
eMaxContentMaxSizing
=
0x40
eAutoOrMaxContentMaxSizing
=
eAutoMaxSizing
|
eMaxContentMaxSizing
eIntrinsicMaxSizing
=
eAutoOrMaxContentMaxSizing
|
eMinContentMaxSizing
eFlexMaxSizing
=
0x80
eFrozen
=
0x100
eSkipGrowUnlimited1
=
0x200
eSkipGrowUnlimited2
=
0x400
eSkipGrowUnlimited
=
eSkipGrowUnlimited1
|
eSkipGrowUnlimited2
}
;
nscoord
mBase
;
nscoord
mLimit
;
nscoord
mPosition
;
StateBits
mState
;
}
;
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
GridItemContainingBlockRect
nsRect
)
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
GridColTrackInfo
ComputedGridTrackInfo
)
const
ComputedGridTrackInfo
*
GetComputedTemplateColumns
(
)
{
return
Properties
(
)
.
Get
(
GridColTrackInfo
(
)
)
;
}
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
GridRowTrackInfo
ComputedGridTrackInfo
)
const
ComputedGridTrackInfo
*
GetComputedTemplateRows
(
)
{
return
Properties
(
)
.
Get
(
GridRowTrackInfo
(
)
)
;
}
protected
:
static
const
uint32_t
kAutoLine
;
static
const
uint32_t
kTranslatedMaxLine
;
typedef
mozilla
:
:
LogicalPoint
LogicalPoint
;
typedef
mozilla
:
:
LogicalRect
LogicalRect
;
typedef
mozilla
:
:
LogicalSize
LogicalSize
;
typedef
mozilla
:
:
WritingMode
WritingMode
;
typedef
mozilla
:
:
css
:
:
GridNamedArea
GridNamedArea
;
typedef
nsLayoutUtils
:
:
IntrinsicISizeType
IntrinsicISizeType
;
class
GridItemCSSOrderIterator
;
struct
Grid
;
struct
TrackSizingFunctions
;
struct
Tracks
;
struct
GridReflowState
;
class
LineNameMap
;
friend
nsContainerFrame
*
NS_NewGridContainerFrame
(
nsIPresShell
*
aPresShell
nsStyleContext
*
aContext
)
;
explicit
nsGridContainerFrame
(
nsStyleContext
*
aContext
)
:
nsContainerFrame
(
aContext
)
mCachedMinISize
(
NS_INTRINSIC_WIDTH_UNKNOWN
)
mCachedPrefISize
(
NS_INTRINSIC_WIDTH_UNKNOWN
)
{
}
struct
LineRange
{
LineRange
(
int32_t
aStart
int32_t
aEnd
)
:
mUntranslatedStart
(
aStart
)
mUntranslatedEnd
(
aEnd
)
{
#
ifdef
DEBUG
if
(
!
IsAutoAuto
(
)
)
{
if
(
IsAuto
(
)
)
{
MOZ_ASSERT
(
aEnd
>
=
nsStyleGridLine
:
:
kMinLine
&
&
aEnd
<
=
nsStyleGridLine
:
:
kMaxLine
"
invalid
span
"
)
;
}
else
{
MOZ_ASSERT
(
aStart
>
=
nsStyleGridLine
:
:
kMinLine
&
&
aStart
<
=
nsStyleGridLine
:
:
kMaxLine
"
invalid
start
line
"
)
;
MOZ_ASSERT
(
aEnd
=
=
int32_t
(
kAutoLine
)
|
|
(
aEnd
>
=
nsStyleGridLine
:
:
kMinLine
&
&
aEnd
<
=
nsStyleGridLine
:
:
kMaxLine
)
"
invalid
end
line
"
)
;
}
}
#
endif
}
bool
IsAutoAuto
(
)
const
{
return
mStart
=
=
kAutoLine
&
&
mEnd
=
=
kAutoLine
;
}
bool
IsAuto
(
)
const
{
return
mStart
=
=
kAutoLine
;
}
bool
IsDefinite
(
)
const
{
return
mStart
!
=
kAutoLine
;
}
uint32_t
Extent
(
)
const
{
MOZ_ASSERT
(
mEnd
!
=
kAutoLine
"
Extent
is
undefined
for
abs
.
pos
.
'
auto
'
"
)
;
if
(
IsAuto
(
)
)
{
MOZ_ASSERT
(
mEnd
>
=
1
&
&
mEnd
<
uint32_t
(
nsStyleGridLine
:
:
kMaxLine
)
"
invalid
span
"
)
;
return
mEnd
;
}
return
mEnd
-
mStart
;
}
void
ResolveAutoPosition
(
uint32_t
aStart
uint32_t
aExplicitGridOffset
)
{
MOZ_ASSERT
(
IsAuto
(
)
"
Why
call
me
?
"
)
;
mStart
=
aStart
;
mEnd
+
=
aStart
;
uint32_t
translatedMax
=
aExplicitGridOffset
+
nsStyleGridLine
:
:
kMaxLine
;
if
(
MOZ_UNLIKELY
(
mStart
>
=
translatedMax
)
)
{
mEnd
=
translatedMax
;
mStart
=
mEnd
-
1
;
}
else
if
(
MOZ_UNLIKELY
(
mEnd
>
translatedMax
)
)
{
mEnd
=
translatedMax
;
}
}
void
AdjustForRemovedTracks
(
const
nsTArray
<
uint32_t
>
&
aNumRemovedTracks
)
{
MOZ_ASSERT
(
mStart
!
=
kAutoLine
"
invalid
resolved
line
for
a
grid
item
"
)
;
MOZ_ASSERT
(
mEnd
!
=
kAutoLine
"
invalid
resolved
line
for
a
grid
item
"
)
;
uint32_t
numRemovedTracks
=
aNumRemovedTracks
[
mStart
]
;
MOZ_ASSERT
(
numRemovedTracks
=
=
aNumRemovedTracks
[
mEnd
]
"
tracks
that
a
grid
item
spans
can
'
t
be
removed
"
)
;
mStart
-
=
numRemovedTracks
;
mEnd
-
=
numRemovedTracks
;
}
void
AdjustAbsPosForRemovedTracks
(
const
nsTArray
<
uint32_t
>
&
aNumRemovedTracks
)
{
if
(
mStart
!
=
nsGridContainerFrame
:
:
kAutoLine
)
{
mStart
-
=
aNumRemovedTracks
[
mStart
]
;
}
if
(
mEnd
!
=
nsGridContainerFrame
:
:
kAutoLine
)
{
MOZ_ASSERT
(
mStart
=
=
nsGridContainerFrame
:
:
kAutoLine
|
|
mEnd
>
mStart
"
invalid
line
range
"
)
;
mEnd
-
=
aNumRemovedTracks
[
mEnd
]
;
}
if
(
mStart
=
=
mEnd
)
{
mEnd
=
nsGridContainerFrame
:
:
kAutoLine
;
}
}
uint32_t
HypotheticalEnd
(
)
const
{
return
mEnd
;
}
void
ToPositionAndLength
(
const
nsTArray
<
TrackSize
>
&
aTrackSizes
nscoord
*
aPos
nscoord
*
aLength
)
const
;
nscoord
ToLength
(
const
nsTArray
<
TrackSize
>
&
aTrackSizes
)
const
;
void
ToPositionAndLengthForAbsPos
(
const
Tracks
&
aTracks
nscoord
aGridOrigin
nscoord
*
aPos
nscoord
*
aLength
)
const
;
union
{
uint32_t
mStart
;
int32_t
mUntranslatedStart
;
}
;
union
{
uint32_t
mEnd
;
int32_t
mUntranslatedEnd
;
}
;
protected
:
LineRange
(
)
{
}
}
;
struct
TranslatedLineRange
:
public
LineRange
{
TranslatedLineRange
(
uint32_t
aStart
uint32_t
aEnd
)
{
MOZ_ASSERT
(
aStart
<
aEnd
&
&
aEnd
<
=
kTranslatedMaxLine
)
;
mStart
=
aStart
;
mEnd
=
aEnd
;
}
}
;
static
int32_t
AutoIfOutside
(
int32_t
aLine
int32_t
aMin
int32_t
aMax
)
{
MOZ_ASSERT
(
aMin
<
=
aMax
)
;
if
(
aLine
<
aMin
|
|
aLine
>
aMax
)
{
return
kAutoLine
;
}
return
aLine
;
}
struct
GridArea
{
GridArea
(
const
LineRange
&
aCols
const
LineRange
&
aRows
)
:
mCols
(
aCols
)
mRows
(
aRows
)
{
}
bool
IsDefinite
(
)
const
{
return
mCols
.
IsDefinite
(
)
&
&
mRows
.
IsDefinite
(
)
;
}
LineRange
mCols
;
LineRange
mRows
;
}
;
struct
GridItemInfo
{
explicit
GridItemInfo
(
const
GridArea
&
aArea
)
:
mArea
(
aArea
)
{
mIsFlexing
[
0
]
=
false
;
mIsFlexing
[
1
]
=
false
;
}
GridArea
mArea
;
bool
mIsFlexing
[
2
]
;
static_assert
(
mozilla
:
:
eLogicalAxisBlock
=
=
0
"
unexpected
index
value
"
)
;
static_assert
(
mozilla
:
:
eLogicalAxisInline
=
=
1
"
unexpected
index
value
"
)
;
#
ifdef
DEBUG
nsIFrame
*
mFrame
;
#
endif
}
;
typedef
nsTHashtable
<
nsStringHashKey
>
ImplicitNamedAreas
;
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
ImplicitNamedAreasProperty
ImplicitNamedAreas
)
void
InitImplicitNamedAreas
(
const
nsStylePosition
*
aStyle
)
;
void
AddImplicitNamedAreas
(
const
nsTArray
<
nsTArray
<
nsString
>
>
&
aLineNameLists
)
;
ImplicitNamedAreas
*
GetImplicitNamedAreas
(
)
const
{
return
Properties
(
)
.
Get
(
ImplicitNamedAreasProperty
(
)
)
;
}
void
ReflowChildren
(
GridReflowState
&
aState
const
LogicalRect
&
aContentArea
nsHTMLReflowMetrics
&
aDesiredSize
nsReflowStatus
&
aStatus
)
;
nscoord
IntrinsicISize
(
nsRenderingContext
*
aRenderingContext
IntrinsicISizeType
aConstraint
)
;
#
ifdef
DEBUG
void
SanityCheckAnonymousGridItems
(
)
const
;
#
endif
private
:
nscoord
mCachedMinISize
;
nscoord
mCachedPrefISize
;
bool
mIsNormalFlowInCSSOrder
:
1
;
}
;
namespace
mozilla
{
template
<
>
struct
IsPod
<
nsGridContainerFrame
:
:
TrackSize
>
:
TrueType
{
}
;
}
#
endif
