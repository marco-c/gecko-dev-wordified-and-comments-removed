#
ifndef
nsGridContainerFrame_h___
#
define
nsGridContainerFrame_h___
#
include
"
mozilla
/
CSSOrderAwareFrameIterator
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
HashTable
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsILineIterator
.
h
"
namespace
mozilla
{
class
PresShell
;
}
nsContainerFrame
*
NS_NewGridContainerFrame
(
mozilla
:
:
PresShell
*
aPresShell
mozilla
:
:
ComputedStyle
*
aStyle
)
;
namespace
mozilla
{
struct
ComputedGridTrackInfo
{
ComputedGridTrackInfo
(
uint32_t
aNumLeadingImplicitTracks
uint32_t
aNumExplicitTracks
uint32_t
aStartFragmentTrack
uint32_t
aEndFragmentTrack
nsTArray
<
nscoord
>
&
&
aPositions
nsTArray
<
nscoord
>
&
&
aSizes
nsTArray
<
uint32_t
>
&
&
aStates
nsTArray
<
bool
>
&
&
aRemovedRepeatTracks
uint32_t
aRepeatFirstTrack
nsTArray
<
nsTArray
<
StyleCustomIdent
>
>
&
&
aResolvedLineNames
bool
aIsSubgrid
bool
aIsMasonry
)
:
mNumLeadingImplicitTracks
(
aNumLeadingImplicitTracks
)
mNumExplicitTracks
(
aNumExplicitTracks
)
mStartFragmentTrack
(
aStartFragmentTrack
)
mEndFragmentTrack
(
aEndFragmentTrack
)
mPositions
(
std
:
:
move
(
aPositions
)
)
mSizes
(
std
:
:
move
(
aSizes
)
)
mStates
(
std
:
:
move
(
aStates
)
)
mRemovedRepeatTracks
(
std
:
:
move
(
aRemovedRepeatTracks
)
)
mResolvedLineNames
(
std
:
:
move
(
aResolvedLineNames
)
)
mRepeatFirstTrack
(
aRepeatFirstTrack
)
mIsSubgrid
(
aIsSubgrid
)
mIsMasonry
(
aIsMasonry
)
{
}
uint32_t
mNumLeadingImplicitTracks
;
uint32_t
mNumExplicitTracks
;
uint32_t
mStartFragmentTrack
;
uint32_t
mEndFragmentTrack
;
nsTArray
<
nscoord
>
mPositions
;
nsTArray
<
nscoord
>
mSizes
;
nsTArray
<
uint32_t
>
mStates
;
nsTArray
<
bool
>
mRemovedRepeatTracks
;
nsTArray
<
nsTArray
<
StyleCustomIdent
>
>
mResolvedLineNames
;
uint32_t
mRepeatFirstTrack
;
bool
mIsSubgrid
;
bool
mIsMasonry
;
}
;
struct
ComputedGridLineInfo
{
explicit
ComputedGridLineInfo
(
nsTArray
<
nsTArray
<
RefPtr
<
nsAtom
>
>
>
&
&
aNames
const
nsTArray
<
RefPtr
<
nsAtom
>
>
&
aNamesBefore
const
nsTArray
<
RefPtr
<
nsAtom
>
>
&
aNamesAfter
nsTArray
<
RefPtr
<
nsAtom
>
>
&
&
aNamesFollowingRepeat
)
:
mNames
(
std
:
:
move
(
aNames
)
)
mNamesBefore
(
aNamesBefore
.
Clone
(
)
)
mNamesAfter
(
aNamesAfter
.
Clone
(
)
)
mNamesFollowingRepeat
(
std
:
:
move
(
aNamesFollowingRepeat
)
)
{
}
nsTArray
<
nsTArray
<
RefPtr
<
nsAtom
>
>
>
mNames
;
nsTArray
<
RefPtr
<
nsAtom
>
>
mNamesBefore
;
nsTArray
<
RefPtr
<
nsAtom
>
>
mNamesAfter
;
nsTArray
<
RefPtr
<
nsAtom
>
>
mNamesFollowingRepeat
;
}
;
}
class
nsGridContainerFrame
final
:
public
nsContainerFrame
public
nsILineIterator
{
public
:
NS_DECL_FRAMEARENA_HELPERS
(
nsGridContainerFrame
)
NS_DECL_QUERYFRAME
using
ComputedGridTrackInfo
=
mozilla
:
:
ComputedGridTrackInfo
;
using
ComputedGridLineInfo
=
mozilla
:
:
ComputedGridLineInfo
;
using
LogicalAxis
=
mozilla
:
:
LogicalAxis
;
using
BaselineSharingGroup
=
mozilla
:
:
BaselineSharingGroup
;
using
NamedArea
=
mozilla
:
:
StyleNamedArea
;
template
<
typename
T
>
using
PerBaseline
=
mozilla
:
:
EnumeratedArray
<
BaselineSharingGroup
BaselineSharingGroup
(
2
)
T
>
;
template
<
typename
T
>
using
PerLogicalAxis
=
mozilla
:
:
EnumeratedArray
<
LogicalAxis
LogicalAxis
(
2
)
T
>
;
void
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
override
;
void
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
override
;
void
DidSetComputedStyle
(
ComputedStyle
*
aOldStyle
)
override
;
nscoord
GetMinISize
(
gfxContext
*
aRenderingContext
)
override
;
nscoord
GetPrefISize
(
gfxContext
*
aRenderingContext
)
override
;
void
MarkIntrinsicISizesDirty
(
)
override
;
bool
IsFrameOfType
(
uint32_t
aFlags
)
const
override
{
return
nsContainerFrame
:
:
IsFrameOfType
(
aFlags
&
~
nsIFrame
:
:
eCanContainOverflowContainers
)
;
}
void
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
override
;
nscoord
GetLogicalBaseline
(
mozilla
:
:
WritingMode
aWM
)
const
override
{
if
(
HasAnyStateBits
(
NS_STATE_GRID_SYNTHESIZE_BASELINE
)
)
{
return
nsContainerFrame
:
:
GetLogicalBaseline
(
aWM
)
;
}
nscoord
b
;
GetBBaseline
(
BaselineSharingGroup
:
:
First
&
b
)
;
return
b
;
}
bool
GetVerticalAlignBaseline
(
mozilla
:
:
WritingMode
aWM
nscoord
*
aBaseline
)
const
override
{
return
GetNaturalBaselineBOffset
(
aWM
BaselineSharingGroup
:
:
First
aBaseline
)
;
}
bool
GetNaturalBaselineBOffset
(
mozilla
:
:
WritingMode
aWM
BaselineSharingGroup
aBaselineGroup
nscoord
*
aBaseline
)
const
override
{
if
(
StyleDisplay
(
)
-
>
IsContainLayout
(
)
|
|
HasAnyStateBits
(
NS_STATE_GRID_SYNTHESIZE_BASELINE
)
)
{
return
false
;
}
return
GetBBaseline
(
aBaselineGroup
aBaseline
)
;
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
GetFrameName
(
nsAString
&
aResult
)
const
override
;
void
ExtraContainerFrameInfo
(
nsACString
&
aTo
)
const
override
;
#
endif
bool
DrainSelfOverflowList
(
)
override
;
void
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
override
;
void
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
const
nsLineList
:
:
iterator
*
aPrevFrameLine
nsFrameList
&
aFrameList
)
override
;
void
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
override
;
mozilla
:
:
StyleAlignFlags
CSSAlignmentForAbsPosChild
(
const
ReflowInput
&
aChildRI
LogicalAxis
aLogicalAxis
)
const
override
;
#
ifdef
DEBUG
void
SetInitialChildList
(
ChildListID
aListID
nsFrameList
&
&
aChildList
)
override
;
#
endif
static
const
nsRect
&
GridItemCB
(
nsIFrame
*
aChild
)
;
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
GridItemContainingBlockRect
nsRect
)
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
GridColTrackInfo
ComputedGridTrackInfo
)
const
ComputedGridTrackInfo
*
GetComputedTemplateColumns
(
)
{
const
ComputedGridTrackInfo
*
info
=
GetProperty
(
GridColTrackInfo
(
)
)
;
MOZ_ASSERT
(
info
"
Property
generation
wasn
'
t
requested
.
"
)
;
return
info
;
}
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
GridRowTrackInfo
ComputedGridTrackInfo
)
const
ComputedGridTrackInfo
*
GetComputedTemplateRows
(
)
{
const
ComputedGridTrackInfo
*
info
=
GetProperty
(
GridRowTrackInfo
(
)
)
;
MOZ_ASSERT
(
info
"
Property
generation
wasn
'
t
requested
.
"
)
;
return
info
;
}
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
GridColumnLineInfo
ComputedGridLineInfo
)
const
ComputedGridLineInfo
*
GetComputedTemplateColumnLines
(
)
{
const
ComputedGridLineInfo
*
info
=
GetProperty
(
GridColumnLineInfo
(
)
)
;
MOZ_ASSERT
(
info
"
Property
generation
wasn
'
t
requested
.
"
)
;
return
info
;
}
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
GridRowLineInfo
ComputedGridLineInfo
)
const
ComputedGridLineInfo
*
GetComputedTemplateRowLines
(
)
{
const
ComputedGridLineInfo
*
info
=
GetProperty
(
GridRowLineInfo
(
)
)
;
MOZ_ASSERT
(
info
"
Property
generation
wasn
'
t
requested
.
"
)
;
return
info
;
}
struct
AtomKey
{
RefPtr
<
nsAtom
>
mKey
;
explicit
AtomKey
(
nsAtom
*
aAtom
)
:
mKey
(
aAtom
)
{
}
using
Lookup
=
nsAtom
*
;
static
mozilla
:
:
HashNumber
hash
(
const
Lookup
&
aKey
)
{
return
aKey
-
>
hash
(
)
;
}
static
bool
match
(
const
AtomKey
&
aFirst
const
Lookup
&
aSecond
)
{
return
aFirst
.
mKey
=
=
aSecond
;
}
}
;
using
ImplicitNamedAreas
=
mozilla
:
:
HashMap
<
AtomKey
NamedArea
AtomKey
>
;
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
ImplicitNamedAreasProperty
ImplicitNamedAreas
)
ImplicitNamedAreas
*
GetImplicitNamedAreas
(
)
const
{
return
GetProperty
(
ImplicitNamedAreasProperty
(
)
)
;
}
using
ExplicitNamedAreas
=
mozilla
:
:
StyleOwnedSlice
<
NamedArea
>
;
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
ExplicitNamedAreasProperty
ExplicitNamedAreas
)
ExplicitNamedAreas
*
GetExplicitNamedAreas
(
)
const
{
return
GetProperty
(
ExplicitNamedAreasProperty
(
)
)
;
}
using
nsContainerFrame
:
:
IsMasonry
;
bool
IsMasonry
(
)
const
{
return
HasAnyStateBits
(
NS_STATE_GRID_IS_ROW_MASONRY
|
NS_STATE_GRID_IS_COL_MASONRY
)
;
}
bool
IsSubgrid
(
LogicalAxis
aAxis
)
const
{
return
HasAnyStateBits
(
aAxis
=
=
mozilla
:
:
eLogicalAxisBlock
?
NS_STATE_GRID_IS_ROW_SUBGRID
:
NS_STATE_GRID_IS_COL_SUBGRID
)
;
}
bool
IsColSubgrid
(
)
const
{
return
IsSubgrid
(
mozilla
:
:
eLogicalAxisInline
)
;
}
bool
IsRowSubgrid
(
)
const
{
return
IsSubgrid
(
mozilla
:
:
eLogicalAxisBlock
)
;
}
bool
IsSubgrid
(
)
const
{
return
HasAnyStateBits
(
NS_STATE_GRID_IS_ROW_SUBGRID
|
NS_STATE_GRID_IS_COL_SUBGRID
)
;
}
bool
HasSubgridItems
(
LogicalAxis
aAxis
)
const
{
return
HasAnyStateBits
(
aAxis
=
=
mozilla
:
:
eLogicalAxisBlock
?
NS_STATE_GRID_HAS_ROW_SUBGRID_ITEM
:
NS_STATE_GRID_HAS_COL_SUBGRID_ITEM
)
;
}
bool
HasSubgridItems
(
)
const
{
return
HasAnyStateBits
(
NS_STATE_GRID_HAS_ROW_SUBGRID_ITEM
|
NS_STATE_GRID_HAS_COL_SUBGRID_ITEM
)
;
}
static
nsGridContainerFrame
*
GetGridContainerFrame
(
nsIFrame
*
aFrame
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
static
nsGridContainerFrame
*
GetGridFrameWithComputedInfo
(
nsIFrame
*
aFrame
)
;
struct
Subgrid
;
struct
UsedTrackSizes
;
struct
TrackSize
;
struct
GridItemInfo
;
struct
GridReflowInput
;
struct
FindItemInGridOrderResult
{
const
GridItemInfo
*
mItem
;
bool
mIsInEdgeTrack
;
}
;
nsGridContainerFrame
*
ParentGridContainerForSubgrid
(
)
const
;
enum
class
SizingConstraint
{
MinContent
MaxContent
NoConstraint
}
;
protected
:
typedef
mozilla
:
:
LogicalPoint
LogicalPoint
;
typedef
mozilla
:
:
LogicalRect
LogicalRect
;
typedef
mozilla
:
:
LogicalSize
LogicalSize
;
typedef
mozilla
:
:
WritingMode
WritingMode
;
struct
Grid
;
struct
GridArea
;
class
LineNameMap
;
struct
LineRange
;
struct
SharedGridData
;
struct
SubgridFallbackTrackSizingFunctions
;
struct
TrackSizingFunctions
;
struct
Tracks
;
struct
TranslatedLineRange
;
friend
nsContainerFrame
*
NS_NewGridContainerFrame
(
mozilla
:
:
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
explicit
nsGridContainerFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
:
nsContainerFrame
(
aStyle
aPresContext
kClassID
)
mCachedMinISize
(
NS_INTRINSIC_ISIZE_UNKNOWN
)
mCachedPrefISize
(
NS_INTRINSIC_ISIZE_UNKNOWN
)
{
for
(
auto
&
perAxisBaseline
:
mBaseline
)
{
for
(
auto
&
baseline
:
perAxisBaseline
)
{
baseline
=
NS_INTRINSIC_ISIZE_UNKNOWN
;
}
}
}
void
InitImplicitNamedAreas
(
const
nsStylePosition
*
aStyle
)
;
using
LineNameList
=
const
mozilla
:
:
StyleOwnedSlice
<
mozilla
:
:
StyleCustomIdent
>
;
void
AddImplicitNamedAreas
(
mozilla
:
:
Span
<
LineNameList
>
)
;
nscoord
ReflowChildren
(
GridReflowInput
&
aState
const
LogicalRect
&
aContentArea
const
nsSize
&
aContainerSize
ReflowOutput
&
aDesiredSize
nsReflowStatus
&
aStatus
)
;
nscoord
IntrinsicISize
(
gfxContext
*
aRenderingContext
mozilla
:
:
IntrinsicISizeType
aConstraint
)
;
bool
GetBBaseline
(
BaselineSharingGroup
aBaselineGroup
nscoord
*
aResult
)
const
{
*
aResult
=
mBaseline
[
mozilla
:
:
eLogicalAxisBlock
]
[
aBaselineGroup
]
;
return
true
;
}
bool
GetIBaseline
(
BaselineSharingGroup
aBaselineGroup
nscoord
*
aResult
)
const
{
*
aResult
=
mBaseline
[
mozilla
:
:
eLogicalAxisInline
]
[
aBaselineGroup
]
;
return
true
;
}
enum
BaselineSet
:
uint32_t
{
eNone
=
0x0
eFirst
=
0x1
eLast
=
0x2
eBoth
=
eFirst
|
eLast
}
;
void
CalculateBaselines
(
BaselineSet
aBaselineSet
mozilla
:
:
CSSOrderAwareFrameIterator
*
aIter
const
nsTArray
<
GridItemInfo
>
*
aGridItems
const
Tracks
&
aTracks
uint32_t
aFragmentStartTrack
uint32_t
aFirstExcludedTrack
WritingMode
aWM
const
nsSize
&
aCBPhysicalSize
nscoord
aCBBorderPaddingStart
nscoord
aCBBorderPaddingStartEnd
nscoord
aCBSize
)
;
nscoord
SynthesizeBaseline
(
const
FindItemInGridOrderResult
&
aItem
LogicalAxis
aAxis
BaselineSharingGroup
aGroup
const
nsSize
&
aCBPhysicalSize
nscoord
aCBSize
WritingMode
aCBWM
)
;
static
FindItemInGridOrderResult
FindFirstItemInGridOrder
(
mozilla
:
:
CSSOrderAwareFrameIterator
&
aIter
const
nsTArray
<
GridItemInfo
>
&
aGridItems
LineRange
GridArea
:
:
*
aMajor
LineRange
GridArea
:
:
*
aMinor
uint32_t
aFragmentStartTrack
)
;
static
FindItemInGridOrderResult
FindLastItemInGridOrder
(
mozilla
:
:
ReverseCSSOrderAwareFrameIterator
&
aIter
const
nsTArray
<
GridItemInfo
>
&
aGridItems
LineRange
GridArea
:
:
*
aMajor
LineRange
GridArea
:
:
*
aMinor
uint32_t
aFragmentStartTrack
uint32_t
aFirstExcludedTrack
)
;
void
UpdateSubgridFrameState
(
)
;
nsFrameState
ComputeSelfSubgridMasonryBits
(
)
const
;
bool
WillHaveAtLeastOneTrackInAxis
(
LogicalAxis
aAxis
)
const
;
private
:
struct
Fragmentainer
{
nscoord
mToFragmentainerEnd
;
bool
mIsTopOfPage
;
bool
mCanBreakAtStart
;
bool
mCanBreakAtEnd
;
bool
mIsAutoBSize
;
}
;
mozilla
:
:
Maybe
<
nsGridContainerFrame
:
:
Fragmentainer
>
GetNearestFragmentainer
(
const
GridReflowInput
&
aState
)
const
;
nscoord
ReflowInFragmentainer
(
GridReflowInput
&
aState
const
LogicalRect
&
aContentArea
ReflowOutput
&
aDesiredSize
nsReflowStatus
&
aStatus
Fragmentainer
&
aFragmentainer
const
nsSize
&
aContainerSize
)
;
nscoord
ReflowRowsInFragmentainer
(
GridReflowInput
&
aState
const
LogicalRect
&
aContentArea
ReflowOutput
&
aDesiredSize
nsReflowStatus
&
aStatus
Fragmentainer
&
aFragmentainer
const
nsSize
&
aContainerSize
const
nsTArray
<
const
GridItemInfo
*
>
&
aItems
uint32_t
aStartRow
uint32_t
aEndRow
nscoord
aBSize
nscoord
aAvailableSize
)
;
void
ReflowInFlowChild
(
nsIFrame
*
aChild
const
GridItemInfo
*
aGridItemInfo
nsSize
aContainerSize
const
mozilla
:
:
Maybe
<
nscoord
>
&
aStretchBSize
const
Fragmentainer
*
aFragmentainer
const
GridReflowInput
&
aState
const
LogicalRect
&
aContentArea
ReflowOutput
&
aDesiredSize
nsReflowStatus
&
aStatus
)
;
nscoord
MasonryLayout
(
GridReflowInput
&
aState
const
LogicalRect
&
aContentArea
SizingConstraint
aConstraint
ReflowOutput
&
aDesiredSize
nsReflowStatus
&
aStatus
Fragmentainer
*
aFragmentainer
const
nsSize
&
aContainerSize
)
;
UsedTrackSizes
*
GetUsedTrackSizes
(
)
const
;
void
StoreUsedTrackSizes
(
LogicalAxis
aAxis
const
nsTArray
<
TrackSize
>
&
aSizes
)
;
nscoord
mCachedMinISize
;
nscoord
mCachedPrefISize
;
PerLogicalAxis
<
PerBaseline
<
nscoord
>
>
mBaseline
;
public
:
class
CachedBAxisMeasurement
{
public
:
NS_DECLARE_FRAME_PROPERTY_SMALL_VALUE
(
Prop
CachedBAxisMeasurement
)
CachedBAxisMeasurement
(
const
nsIFrame
*
aFrame
const
LogicalSize
&
aCBSize
const
nscoord
aBSize
)
:
mKey
(
aFrame
aCBSize
)
mBSize
(
aBSize
)
{
}
CachedBAxisMeasurement
(
)
=
default
;
bool
IsValidFor
(
const
nsIFrame
*
aFrame
const
LogicalSize
&
aCBSize
)
const
{
if
(
aFrame
-
>
IsSubtreeDirty
(
)
)
{
return
false
;
}
if
(
!
CanCacheMeasurement
(
aFrame
aCBSize
)
)
{
return
false
;
}
return
mKey
=
=
Key
(
aFrame
aCBSize
)
;
}
static
bool
CanCacheMeasurement
(
const
nsIFrame
*
aFrame
const
LogicalSize
&
aCBSize
)
{
return
Key
:
:
CanHash
(
aFrame
aCBSize
)
;
}
nscoord
BSize
(
)
const
{
return
mBSize
;
}
void
Update
(
const
nsIFrame
*
aFrame
const
LogicalSize
&
aCBSize
const
nscoord
aBSize
)
{
MOZ_ASSERT
(
CanCacheMeasurement
(
aFrame
aCBSize
)
)
;
mKey
.
mHashKey
=
Key
:
:
GenerateHash
(
aFrame
aCBSize
)
;
mBSize
=
aBSize
;
}
private
:
struct
Key
{
uint32_t
mHashKey
;
Key
(
)
=
default
;
Key
(
const
nsIFrame
*
aFrame
const
LogicalSize
&
aCBSize
)
{
MOZ_ASSERT
(
CanHash
(
aFrame
aCBSize
)
)
;
mHashKey
=
GenerateHash
(
aFrame
aCBSize
)
;
}
void
UpdateHash
(
const
nsIFrame
*
aFrame
const
LogicalSize
&
aCBSize
)
{
MOZ_ASSERT
(
CanHash
(
aFrame
aCBSize
)
)
;
mHashKey
=
GenerateHash
(
aFrame
aCBSize
)
;
}
static
uint32_t
GenerateHash
(
const
nsIFrame
*
aFrame
const
LogicalSize
&
aCBSize
)
{
MOZ_ASSERT
(
CanHash
(
aFrame
aCBSize
)
)
;
nscoord
gridAreaISize
=
aCBSize
.
ISize
(
aFrame
-
>
GetWritingMode
(
)
)
;
nscoord
bBaselinePaddingProperty
=
abs
(
aFrame
-
>
GetProperty
(
nsIFrame
:
:
BBaselinePadProperty
(
)
)
)
;
uint_fast8_t
bitsNeededForISize
=
mozilla
:
:
FloorLog2
(
gridAreaISize
)
+
1
;
return
(
gridAreaISize
<
<
(
32
-
bitsNeededForISize
)
)
|
bBaselinePaddingProperty
;
}
static
bool
CanHash
(
const
nsIFrame
*
aFrame
const
LogicalSize
&
aCBSize
)
{
uint_fast8_t
bitsNeededForISize
=
mozilla
:
:
FloorLog2
(
aCBSize
.
ISize
(
aFrame
-
>
GetWritingMode
(
)
)
)
+
1
;
uint_fast8_t
bitsNeededForBBaselinePadding
=
mozilla
:
:
FloorLog2
(
abs
(
aFrame
-
>
GetProperty
(
nsIFrame
:
:
BBaselinePadProperty
(
)
)
)
)
+
1
;
return
bitsNeededForISize
+
bitsNeededForBBaselinePadding
<
=
32
;
}
bool
operator
=
=
(
const
Key
&
aOther
)
const
{
return
mHashKey
=
=
aOther
.
mHashKey
;
}
}
;
Key
mKey
;
nscoord
mBSize
;
}
;
bool
CanProvideLineIterator
(
)
const
final
{
return
true
;
}
nsILineIterator
*
GetLineIterator
(
)
final
{
return
this
;
}
int32_t
GetNumLines
(
)
const
final
;
bool
IsLineIteratorFlowRTL
(
)
final
;
mozilla
:
:
Result
<
LineInfo
nsresult
>
GetLine
(
int32_t
aLineNumber
)
final
;
int32_t
FindLineContaining
(
nsIFrame
*
aFrame
int32_t
aStartLine
=
0
)
final
;
NS_IMETHOD
FindFrameAt
(
int32_t
aLineNumber
nsPoint
aPos
nsIFrame
*
*
aFrameFound
bool
*
aPosIsBeforeFirstFrame
bool
*
aPosIsAfterLastFrame
)
final
;
NS_IMETHOD
CheckLineOrder
(
int32_t
aLine
bool
*
aIsReordered
nsIFrame
*
*
aFirstVisual
nsIFrame
*
*
aLastVisual
)
final
;
}
;
#
endif
