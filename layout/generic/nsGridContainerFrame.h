#
ifndef
nsGridContainerFrame_h___
#
define
nsGridContainerFrame_h___
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
"
mozilla
/
HashTable
.
h
"
#
include
"
nsContainerFrame
.
h
"
namespace
mozilla
{
class
PresShell
;
}
nsContainerFrame
*
NS_NewGridContainerFrame
(
mozilla
:
:
PresShell
*
aPresShell
mozilla
:
:
ComputedStyle
*
aStyle
)
;
namespace
mozilla
{
template
<
typename
Iterator
>
class
CSSOrderAwareFrameIteratorT
;
typedef
CSSOrderAwareFrameIteratorT
<
nsFrameList
:
:
iterator
>
CSSOrderAwareFrameIterator
;
typedef
CSSOrderAwareFrameIteratorT
<
nsFrameList
:
:
reverse_iterator
>
ReverseCSSOrderAwareFrameIterator
;
struct
ComputedGridTrackInfo
{
ComputedGridTrackInfo
(
uint32_t
aNumLeadingImplicitTracks
uint32_t
aNumExplicitTracks
uint32_t
aStartFragmentTrack
uint32_t
aEndFragmentTrack
nsTArray
<
nscoord
>
&
&
aPositions
nsTArray
<
nscoord
>
&
&
aSizes
nsTArray
<
uint32_t
>
&
&
aStates
nsTArray
<
bool
>
&
&
aRemovedRepeatTracks
uint32_t
aRepeatFirstTrack
)
:
mNumLeadingImplicitTracks
(
aNumLeadingImplicitTracks
)
mNumExplicitTracks
(
aNumExplicitTracks
)
mStartFragmentTrack
(
aStartFragmentTrack
)
mEndFragmentTrack
(
aEndFragmentTrack
)
mPositions
(
aPositions
)
mSizes
(
aSizes
)
mStates
(
aStates
)
mRemovedRepeatTracks
(
aRemovedRepeatTracks
)
mRepeatFirstTrack
(
aRepeatFirstTrack
)
{
}
uint32_t
mNumLeadingImplicitTracks
;
uint32_t
mNumExplicitTracks
;
uint32_t
mStartFragmentTrack
;
uint32_t
mEndFragmentTrack
;
nsTArray
<
nscoord
>
mPositions
;
nsTArray
<
nscoord
>
mSizes
;
nsTArray
<
uint32_t
>
mStates
;
nsTArray
<
bool
>
mRemovedRepeatTracks
;
uint32_t
mRepeatFirstTrack
;
}
;
struct
ComputedGridLineInfo
{
explicit
ComputedGridLineInfo
(
nsTArray
<
nsTArray
<
RefPtr
<
nsAtom
>
>
>
&
&
aNames
const
nsTArray
<
RefPtr
<
nsAtom
>
>
&
aNamesBefore
const
nsTArray
<
RefPtr
<
nsAtom
>
>
&
aNamesAfter
nsTArray
<
RefPtr
<
nsAtom
>
>
&
&
aNamesFollowingRepeat
)
:
mNames
(
aNames
)
mNamesBefore
(
aNamesBefore
)
mNamesAfter
(
aNamesAfter
)
mNamesFollowingRepeat
(
aNamesFollowingRepeat
)
{
}
nsTArray
<
nsTArray
<
RefPtr
<
nsAtom
>
>
>
mNames
;
nsTArray
<
RefPtr
<
nsAtom
>
>
mNamesBefore
;
nsTArray
<
RefPtr
<
nsAtom
>
>
mNamesAfter
;
nsTArray
<
RefPtr
<
nsAtom
>
>
mNamesFollowingRepeat
;
}
;
}
class
nsGridContainerFrame
final
:
public
nsContainerFrame
{
public
:
NS_DECL_FRAMEARENA_HELPERS
(
nsGridContainerFrame
)
NS_DECL_QUERYFRAME
using
ComputedGridTrackInfo
=
mozilla
:
:
ComputedGridTrackInfo
;
using
ComputedGridLineInfo
=
mozilla
:
:
ComputedGridLineInfo
;
using
LogicalAxis
=
mozilla
:
:
LogicalAxis
;
using
BaselineSharingGroup
=
mozilla
:
:
BaselineSharingGroup
;
using
NamedArea
=
mozilla
:
:
StyleNamedArea
;
template
<
typename
T
>
using
PerBaseline
=
mozilla
:
:
EnumeratedArray
<
BaselineSharingGroup
BaselineSharingGroup
(
2
)
T
>
;
template
<
typename
T
>
using
PerLogicalAxis
=
mozilla
:
:
EnumeratedArray
<
LogicalAxis
LogicalAxis
(
2
)
T
>
;
void
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
override
;
void
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
override
;
void
DidSetComputedStyle
(
ComputedStyle
*
aOldStyle
)
override
;
nscoord
GetMinISize
(
gfxContext
*
aRenderingContext
)
override
;
nscoord
GetPrefISize
(
gfxContext
*
aRenderingContext
)
override
;
void
MarkIntrinsicISizesDirty
(
)
override
;
bool
IsFrameOfType
(
uint32_t
aFlags
)
const
override
{
return
nsContainerFrame
:
:
IsFrameOfType
(
aFlags
&
~
nsIFrame
:
:
eCanContainOverflowContainers
)
;
}
void
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
override
;
nscoord
GetLogicalBaseline
(
mozilla
:
:
WritingMode
aWM
)
const
override
{
if
(
HasAnyStateBits
(
NS_STATE_GRID_SYNTHESIZE_BASELINE
)
)
{
return
nsContainerFrame
:
:
GetLogicalBaseline
(
aWM
)
;
}
nscoord
b
;
GetBBaseline
(
BaselineSharingGroup
:
:
First
&
b
)
;
return
b
;
}
bool
GetVerticalAlignBaseline
(
mozilla
:
:
WritingMode
aWM
nscoord
*
aBaseline
)
const
override
{
return
GetNaturalBaselineBOffset
(
aWM
BaselineSharingGroup
:
:
First
aBaseline
)
;
}
bool
GetNaturalBaselineBOffset
(
mozilla
:
:
WritingMode
aWM
BaselineSharingGroup
aBaselineGroup
nscoord
*
aBaseline
)
const
override
{
if
(
HasAnyStateBits
(
NS_STATE_GRID_SYNTHESIZE_BASELINE
)
)
{
return
false
;
}
return
GetBBaseline
(
aBaselineGroup
aBaseline
)
;
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
GetFrameName
(
nsAString
&
aResult
)
const
override
;
#
endif
bool
DrainSelfOverflowList
(
)
override
;
void
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
override
;
void
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
const
nsLineList
:
:
iterator
*
aPrevFrameLine
nsFrameList
&
aFrameList
)
override
;
void
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
override
;
uint16_t
CSSAlignmentForAbsPosChild
(
const
ReflowInput
&
aChildRI
LogicalAxis
aLogicalAxis
)
const
override
;
#
ifdef
DEBUG
void
SetInitialChildList
(
ChildListID
aListID
nsFrameList
&
aChildList
)
override
;
#
endif
static
const
nsRect
&
GridItemCB
(
nsIFrame
*
aChild
)
;
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
GridItemContainingBlockRect
nsRect
)
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
GridColTrackInfo
ComputedGridTrackInfo
)
const
ComputedGridTrackInfo
*
GetComputedTemplateColumns
(
)
{
const
ComputedGridTrackInfo
*
info
=
GetProperty
(
GridColTrackInfo
(
)
)
;
MOZ_ASSERT
(
info
"
Property
generation
wasn
'
t
requested
.
"
)
;
return
info
;
}
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
GridRowTrackInfo
ComputedGridTrackInfo
)
const
ComputedGridTrackInfo
*
GetComputedTemplateRows
(
)
{
const
ComputedGridTrackInfo
*
info
=
GetProperty
(
GridRowTrackInfo
(
)
)
;
MOZ_ASSERT
(
info
"
Property
generation
wasn
'
t
requested
.
"
)
;
return
info
;
}
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
GridColumnLineInfo
ComputedGridLineInfo
)
const
ComputedGridLineInfo
*
GetComputedTemplateColumnLines
(
)
{
const
ComputedGridLineInfo
*
info
=
GetProperty
(
GridColumnLineInfo
(
)
)
;
MOZ_ASSERT
(
info
"
Property
generation
wasn
'
t
requested
.
"
)
;
return
info
;
}
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
GridRowLineInfo
ComputedGridLineInfo
)
const
ComputedGridLineInfo
*
GetComputedTemplateRowLines
(
)
{
const
ComputedGridLineInfo
*
info
=
GetProperty
(
GridRowLineInfo
(
)
)
;
MOZ_ASSERT
(
info
"
Property
generation
wasn
'
t
requested
.
"
)
;
return
info
;
}
struct
AtomKey
{
RefPtr
<
nsAtom
>
mKey
;
explicit
AtomKey
(
nsAtom
*
aAtom
)
:
mKey
(
aAtom
)
{
}
using
Lookup
=
nsAtom
*
;
static
mozilla
:
:
HashNumber
hash
(
const
Lookup
&
aKey
)
{
return
aKey
-
>
hash
(
)
;
}
static
bool
match
(
const
AtomKey
&
aFirst
const
Lookup
&
aSecond
)
{
return
aFirst
.
mKey
=
=
aSecond
;
}
}
;
using
ImplicitNamedAreas
=
mozilla
:
:
HashMap
<
AtomKey
NamedArea
AtomKey
>
;
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
ImplicitNamedAreasProperty
ImplicitNamedAreas
)
ImplicitNamedAreas
*
GetImplicitNamedAreas
(
)
const
{
return
GetProperty
(
ImplicitNamedAreasProperty
(
)
)
;
}
using
ExplicitNamedAreas
=
mozilla
:
:
StyleOwnedSlice
<
NamedArea
>
;
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
ExplicitNamedAreasProperty
ExplicitNamedAreas
)
ExplicitNamedAreas
*
GetExplicitNamedAreas
(
)
const
{
return
GetProperty
(
ExplicitNamedAreasProperty
(
)
)
;
}
bool
IsSubgrid
(
LogicalAxis
aAxis
)
const
{
return
HasAnyStateBits
(
aAxis
=
=
mozilla
:
:
eLogicalAxisBlock
?
NS_STATE_GRID_IS_ROW_SUBGRID
:
NS_STATE_GRID_IS_COL_SUBGRID
)
;
}
bool
IsColSubgrid
(
)
const
{
return
IsSubgrid
(
mozilla
:
:
eLogicalAxisInline
)
;
}
bool
IsRowSubgrid
(
)
const
{
return
IsSubgrid
(
mozilla
:
:
eLogicalAxisBlock
)
;
}
bool
IsSubgrid
(
)
const
{
return
HasAnyStateBits
(
NS_STATE_GRID_IS_ROW_SUBGRID
|
NS_STATE_GRID_IS_COL_SUBGRID
)
;
}
bool
HasSubgridItems
(
LogicalAxis
aAxis
)
const
{
return
HasAnyStateBits
(
aAxis
=
=
mozilla
:
:
eLogicalAxisBlock
?
NS_STATE_GRID_HAS_ROW_SUBGRID_ITEM
:
NS_STATE_GRID_HAS_COL_SUBGRID_ITEM
)
;
}
bool
HasSubgridItems
(
)
const
{
return
HasAnyStateBits
(
NS_STATE_GRID_HAS_ROW_SUBGRID_ITEM
|
NS_STATE_GRID_HAS_COL_SUBGRID_ITEM
)
;
}
static
nsGridContainerFrame
*
GetGridContainerFrame
(
nsIFrame
*
aFrame
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
static
nsGridContainerFrame
*
GetGridFrameWithComputedInfo
(
nsIFrame
*
aFrame
)
;
struct
Subgrid
;
struct
UsedTrackSizes
;
struct
TrackSize
;
struct
GridItemInfo
;
struct
GridReflowInput
;
struct
FindItemInGridOrderResult
{
const
GridItemInfo
*
mItem
;
bool
mIsInEdgeTrack
;
}
;
nsGridContainerFrame
*
ParentGridContainerForSubgrid
(
)
const
;
protected
:
typedef
mozilla
:
:
LogicalPoint
LogicalPoint
;
typedef
mozilla
:
:
LogicalRect
LogicalRect
;
typedef
mozilla
:
:
LogicalSize
LogicalSize
;
typedef
mozilla
:
:
CSSOrderAwareFrameIterator
CSSOrderAwareFrameIterator
;
typedef
mozilla
:
:
ReverseCSSOrderAwareFrameIterator
ReverseCSSOrderAwareFrameIterator
;
typedef
mozilla
:
:
WritingMode
WritingMode
;
typedef
mozilla
:
:
layout
:
:
AutoFrameListPtr
AutoFrameListPtr
;
typedef
nsLayoutUtils
:
:
IntrinsicISizeType
IntrinsicISizeType
;
struct
Grid
;
struct
GridArea
;
class
LineNameMap
;
struct
LineRange
;
struct
SharedGridData
;
struct
SubgridFallbackTrackSizingFunctions
;
struct
TrackSizingFunctions
;
struct
Tracks
;
struct
TranslatedLineRange
;
friend
nsContainerFrame
*
NS_NewGridContainerFrame
(
mozilla
:
:
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
explicit
nsGridContainerFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
:
nsContainerFrame
(
aStyle
aPresContext
kClassID
)
mCachedMinISize
(
NS_INTRINSIC_ISIZE_UNKNOWN
)
mCachedPrefISize
(
NS_INTRINSIC_ISIZE_UNKNOWN
)
{
for
(
auto
&
perAxisBaseline
:
mBaseline
)
{
for
(
auto
&
baseline
:
perAxisBaseline
)
{
baseline
=
NS_INTRINSIC_ISIZE_UNKNOWN
;
}
}
}
void
InitImplicitNamedAreas
(
const
nsStylePosition
*
aStyle
)
;
void
AddImplicitNamedAreas
(
const
nsTArray
<
nsTArray
<
RefPtr
<
nsAtom
>
>
>
&
aLineNameLists
)
;
void
NormalizeChildLists
(
)
;
nscoord
ReflowChildren
(
GridReflowInput
&
aState
const
LogicalRect
&
aContentArea
ReflowOutput
&
aDesiredSize
nsReflowStatus
&
aStatus
)
;
nscoord
IntrinsicISize
(
gfxContext
*
aRenderingContext
IntrinsicISizeType
aConstraint
)
;
void
NoteNewChildren
(
ChildListID
aListID
const
nsFrameList
&
aFrameList
)
;
void
MergeSortedOverflow
(
nsFrameList
&
aList
)
;
void
MergeSortedExcessOverflowContainers
(
nsFrameList
&
aList
)
;
bool
GetBBaseline
(
BaselineSharingGroup
aBaselineGroup
nscoord
*
aResult
)
const
{
*
aResult
=
mBaseline
[
mozilla
:
:
eLogicalAxisBlock
]
[
aBaselineGroup
]
;
return
true
;
}
bool
GetIBaseline
(
BaselineSharingGroup
aBaselineGroup
nscoord
*
aResult
)
const
{
*
aResult
=
mBaseline
[
mozilla
:
:
eLogicalAxisInline
]
[
aBaselineGroup
]
;
return
true
;
}
enum
BaselineSet
:
uint32_t
{
eNone
=
0x0
eFirst
=
0x1
eLast
=
0x2
eBoth
=
eFirst
|
eLast
}
;
void
CalculateBaselines
(
BaselineSet
aBaselineSet
CSSOrderAwareFrameIterator
*
aIter
const
nsTArray
<
GridItemInfo
>
*
aGridItems
const
Tracks
&
aTracks
uint32_t
aFragmentStartTrack
uint32_t
aFirstExcludedTrack
WritingMode
aWM
const
nsSize
&
aCBPhysicalSize
nscoord
aCBBorderPaddingStart
nscoord
aCBBorderPaddingStartEnd
nscoord
aCBSize
)
;
nscoord
SynthesizeBaseline
(
const
FindItemInGridOrderResult
&
aItem
LogicalAxis
aAxis
BaselineSharingGroup
aGroup
const
nsSize
&
aCBPhysicalSize
nscoord
aCBSize
WritingMode
aCBWM
)
;
static
FindItemInGridOrderResult
FindFirstItemInGridOrder
(
CSSOrderAwareFrameIterator
&
aIter
const
nsTArray
<
GridItemInfo
>
&
aGridItems
LineRange
GridArea
:
:
*
aMajor
LineRange
GridArea
:
:
*
aMinor
uint32_t
aFragmentStartTrack
)
;
static
FindItemInGridOrderResult
FindLastItemInGridOrder
(
ReverseCSSOrderAwareFrameIterator
&
aIter
const
nsTArray
<
GridItemInfo
>
&
aGridItems
LineRange
GridArea
:
:
*
aMajor
LineRange
GridArea
:
:
*
aMinor
uint32_t
aFragmentStartTrack
uint32_t
aFirstExcludedTrack
)
;
#
ifdef
DEBUG
void
SanityCheckGridItemsBeforeReflow
(
)
const
;
#
endif
void
UpdateSubgridFrameState
(
)
;
nsFrameState
ComputeSelfSubgridBits
(
)
const
;
private
:
struct
Fragmentainer
{
nscoord
mToFragmentainerEnd
;
bool
mIsTopOfPage
;
bool
mCanBreakAtStart
;
bool
mCanBreakAtEnd
;
bool
mIsAutoBSize
;
}
;
mozilla
:
:
Maybe
<
nsGridContainerFrame
:
:
Fragmentainer
>
GetNearestFragmentainer
(
const
GridReflowInput
&
aState
)
const
;
nscoord
ReflowInFragmentainer
(
GridReflowInput
&
aState
const
LogicalRect
&
aContentArea
ReflowOutput
&
aDesiredSize
nsReflowStatus
&
aStatus
Fragmentainer
&
aFragmentainer
const
nsSize
&
aContainerSize
)
;
nscoord
ReflowRowsInFragmentainer
(
GridReflowInput
&
aState
const
LogicalRect
&
aContentArea
ReflowOutput
&
aDesiredSize
nsReflowStatus
&
aStatus
Fragmentainer
&
aFragmentainer
const
nsSize
&
aContainerSize
const
nsTArray
<
const
GridItemInfo
*
>
&
aItems
uint32_t
aStartRow
uint32_t
aEndRow
nscoord
aBSize
nscoord
aAvailableSize
)
;
void
ReflowInFlowChild
(
nsIFrame
*
aChild
const
GridItemInfo
*
aGridItemInfo
nsSize
aContainerSize
const
mozilla
:
:
Maybe
<
nscoord
>
&
aStretchBSize
const
Fragmentainer
*
aFragmentainer
const
GridReflowInput
&
aState
const
LogicalRect
&
aContentArea
ReflowOutput
&
aDesiredSize
nsReflowStatus
&
aStatus
)
;
UsedTrackSizes
*
GetUsedTrackSizes
(
)
const
;
void
StoreUsedTrackSizes
(
LogicalAxis
aAxis
const
nsTArray
<
TrackSize
>
&
aSizes
)
;
nscoord
mCachedMinISize
;
nscoord
mCachedPrefISize
;
PerLogicalAxis
<
PerBaseline
<
nscoord
>
>
mBaseline
;
#
ifdef
DEBUG
bool
mDidPushItemsBitMayLie
{
false
}
;
#
endif
}
;
#
endif
