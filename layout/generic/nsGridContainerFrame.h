#
ifndef
nsGridContainerFrame_h___
#
define
nsGridContainerFrame_h___
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsTHashtable
.
h
"
nsContainerFrame
*
NS_NewGridContainerFrame
(
nsIPresShell
*
aPresShell
nsStyleContext
*
aContext
)
;
namespace
mozilla
{
struct
ComputedGridTrackInfo
{
ComputedGridTrackInfo
(
uint32_t
aNumLeadingImplicitTracks
uint32_t
aNumExplicitTracks
uint32_t
aStartFragmentTrack
uint32_t
aEndFragmentTrack
nsTArray
<
nscoord
>
&
&
aPositions
nsTArray
<
nscoord
>
&
&
aSizes
nsTArray
<
uint32_t
>
&
&
aStates
nsTArray
<
bool
>
&
&
aRemovedRepeatTracks
uint32_t
aRepeatFirstTrack
)
:
mNumLeadingImplicitTracks
(
aNumLeadingImplicitTracks
)
mNumExplicitTracks
(
aNumExplicitTracks
)
mStartFragmentTrack
(
aStartFragmentTrack
)
mEndFragmentTrack
(
aEndFragmentTrack
)
mPositions
(
aPositions
)
mSizes
(
aSizes
)
mStates
(
aStates
)
mRemovedRepeatTracks
(
aRemovedRepeatTracks
)
mRepeatFirstTrack
(
aRepeatFirstTrack
)
{
}
uint32_t
mNumLeadingImplicitTracks
;
uint32_t
mNumExplicitTracks
;
uint32_t
mStartFragmentTrack
;
uint32_t
mEndFragmentTrack
;
nsTArray
<
nscoord
>
mPositions
;
nsTArray
<
nscoord
>
mSizes
;
nsTArray
<
uint32_t
>
mStates
;
nsTArray
<
bool
>
mRemovedRepeatTracks
;
uint32_t
mRepeatFirstTrack
;
}
;
struct
ComputedGridLineInfo
{
explicit
ComputedGridLineInfo
(
nsTArray
<
nsTArray
<
nsString
>
>
&
&
aNames
const
nsTArray
<
nsString
>
&
aNamesBefore
const
nsTArray
<
nsString
>
&
aNamesAfter
)
:
mNames
(
aNames
)
mNamesBefore
(
aNamesBefore
)
mNamesAfter
(
aNamesAfter
)
{
}
nsTArray
<
nsTArray
<
nsString
>
>
mNames
;
nsTArray
<
nsString
>
mNamesBefore
;
nsTArray
<
nsString
>
mNamesAfter
;
}
;
}
class
nsGridContainerFrame
final
:
public
nsContainerFrame
{
public
:
NS_DECL_FRAMEARENA_HELPERS
NS_DECL_QUERYFRAME_TARGET
(
nsGridContainerFrame
)
NS_DECL_QUERYFRAME
typedef
mozilla
:
:
ComputedGridTrackInfo
ComputedGridTrackInfo
;
typedef
mozilla
:
:
ComputedGridLineInfo
ComputedGridLineInfo
;
void
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
override
;
nscoord
GetMinISize
(
nsRenderingContext
*
aRenderingContext
)
override
;
nscoord
GetPrefISize
(
nsRenderingContext
*
aRenderingContext
)
override
;
void
MarkIntrinsicISizesDirty
(
)
override
;
nsIAtom
*
GetType
(
)
const
override
;
bool
IsFrameOfType
(
uint32_t
aFlags
)
const
override
{
return
nsContainerFrame
:
:
IsFrameOfType
(
aFlags
&
~
nsIFrame
:
:
eCanContainOverflowContainers
)
;
}
void
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aDirtyRect
const
nsDisplayListSet
&
aLists
)
override
;
#
ifdef
DEBUG_FRAME_DUMP
nsresult
GetFrameName
(
nsAString
&
aResult
)
const
override
;
#
endif
bool
DrainSelfOverflowList
(
)
override
;
void
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
override
;
void
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
aFrameList
)
override
;
void
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
override
;
#
ifdef
DEBUG
void
SetInitialChildList
(
ChildListID
aListID
nsFrameList
&
aChildList
)
override
;
#
endif
static
const
nsRect
&
GridItemCB
(
nsIFrame
*
aChild
)
;
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
GridItemContainingBlockRect
nsRect
)
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
GridColTrackInfo
ComputedGridTrackInfo
)
const
ComputedGridTrackInfo
*
GetComputedTemplateColumns
(
)
{
const
ComputedGridTrackInfo
*
info
=
Properties
(
)
.
Get
(
GridColTrackInfo
(
)
)
;
MOZ_ASSERT
(
info
"
Property
generation
wasn
'
t
requested
.
"
)
;
return
info
;
}
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
GridRowTrackInfo
ComputedGridTrackInfo
)
const
ComputedGridTrackInfo
*
GetComputedTemplateRows
(
)
{
const
ComputedGridTrackInfo
*
info
=
Properties
(
)
.
Get
(
GridRowTrackInfo
(
)
)
;
MOZ_ASSERT
(
info
"
Property
generation
wasn
'
t
requested
.
"
)
;
return
info
;
}
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
GridColumnLineInfo
ComputedGridLineInfo
)
const
ComputedGridLineInfo
*
GetComputedTemplateColumnLines
(
)
{
const
ComputedGridLineInfo
*
info
=
Properties
(
)
.
Get
(
GridColumnLineInfo
(
)
)
;
MOZ_ASSERT
(
info
"
Property
generation
wasn
'
t
requested
.
"
)
;
return
info
;
}
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
GridRowLineInfo
ComputedGridLineInfo
)
const
ComputedGridLineInfo
*
GetComputedTemplateRowLines
(
)
{
const
ComputedGridLineInfo
*
info
=
Properties
(
)
.
Get
(
GridRowLineInfo
(
)
)
;
MOZ_ASSERT
(
info
"
Property
generation
wasn
'
t
requested
.
"
)
;
return
info
;
}
typedef
nsBaseHashtable
<
nsStringHashKey
mozilla
:
:
css
:
:
GridNamedArea
mozilla
:
:
css
:
:
GridNamedArea
>
ImplicitNamedAreas
;
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
ImplicitNamedAreasProperty
ImplicitNamedAreas
)
ImplicitNamedAreas
*
GetImplicitNamedAreas
(
)
const
{
return
Properties
(
)
.
Get
(
ImplicitNamedAreasProperty
(
)
)
;
}
typedef
nsTArray
<
mozilla
:
:
css
:
:
GridNamedArea
>
ExplicitNamedAreas
;
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
ExplicitNamedAreasProperty
ExplicitNamedAreas
)
ExplicitNamedAreas
*
GetExplicitNamedAreas
(
)
const
{
return
Properties
(
)
.
Get
(
ExplicitNamedAreasProperty
(
)
)
;
}
static
nsGridContainerFrame
*
GetGridFrameWithComputedInfo
(
nsIFrame
*
aFrame
)
;
struct
TrackSize
;
struct
GridItemInfo
;
struct
GridReflowInput
;
template
<
typename
Iterator
>
class
GridItemCSSOrderIteratorT
;
typedef
GridItemCSSOrderIteratorT
<
nsFrameList
:
:
iterator
>
GridItemCSSOrderIterator
;
typedef
GridItemCSSOrderIteratorT
<
nsFrameList
:
:
reverse_iterator
>
ReverseGridItemCSSOrderIterator
;
struct
FindItemInGridOrderResult
{
const
GridItemInfo
*
mItem
;
bool
mIsInEdgeTrack
;
}
;
protected
:
static
const
uint32_t
kAutoLine
;
static
const
uint32_t
kTranslatedMaxLine
;
typedef
mozilla
:
:
LogicalPoint
LogicalPoint
;
typedef
mozilla
:
:
LogicalRect
LogicalRect
;
typedef
mozilla
:
:
LogicalSize
LogicalSize
;
typedef
mozilla
:
:
WritingMode
WritingMode
;
typedef
mozilla
:
:
css
:
:
GridNamedArea
GridNamedArea
;
typedef
mozilla
:
:
layout
:
:
AutoFrameListPtr
AutoFrameListPtr
;
typedef
nsLayoutUtils
:
:
IntrinsicISizeType
IntrinsicISizeType
;
struct
Grid
;
struct
GridArea
;
class
LineNameMap
;
struct
LineRange
;
struct
SharedGridData
;
struct
TrackSizingFunctions
;
struct
Tracks
;
struct
TranslatedLineRange
;
friend
nsContainerFrame
*
NS_NewGridContainerFrame
(
nsIPresShell
*
aPresShell
nsStyleContext
*
aContext
)
;
explicit
nsGridContainerFrame
(
nsStyleContext
*
aContext
)
:
nsContainerFrame
(
aContext
)
mCachedMinISize
(
NS_INTRINSIC_WIDTH_UNKNOWN
)
mCachedPrefISize
(
NS_INTRINSIC_WIDTH_UNKNOWN
)
{
}
void
InitImplicitNamedAreas
(
const
nsStylePosition
*
aStyle
)
;
void
AddImplicitNamedAreas
(
const
nsTArray
<
nsTArray
<
nsString
>
>
&
aLineNameLists
)
;
nscoord
ReflowChildren
(
GridReflowInput
&
aState
const
LogicalRect
&
aContentArea
ReflowOutput
&
aDesiredSize
nsReflowStatus
&
aStatus
)
;
nscoord
IntrinsicISize
(
nsRenderingContext
*
aRenderingContext
IntrinsicISizeType
aConstraint
)
;
void
NoteNewChildren
(
ChildListID
aListID
const
nsFrameList
&
aFrameList
)
;
void
MergeSortedOverflow
(
nsFrameList
&
aList
)
;
void
MergeSortedExcessOverflowContainers
(
nsFrameList
&
aList
)
;
static
FindItemInGridOrderResult
FindFirstItemInGridOrder
(
GridItemCSSOrderIterator
&
aIter
const
nsTArray
<
GridItemInfo
>
&
aGridItems
LineRange
GridArea
:
:
*
aMajor
LineRange
GridArea
:
:
*
aMinor
uint32_t
aFragmentStartTrack
)
;
static
FindItemInGridOrderResult
FindLastItemInGridOrder
(
ReverseGridItemCSSOrderIterator
&
aIter
const
nsTArray
<
GridItemInfo
>
&
aGridItems
LineRange
GridArea
:
:
*
aMajor
LineRange
GridArea
:
:
*
aMinor
uint32_t
aFragmentStartTrack
uint32_t
aFirstExcludedTrack
)
;
#
ifdef
DEBUG
void
SanityCheckGridItemsBeforeReflow
(
)
const
;
#
endif
private
:
struct
Fragmentainer
{
nscoord
mToFragmentainerEnd
;
bool
mIsTopOfPage
;
bool
mCanBreakAtStart
;
bool
mCanBreakAtEnd
;
bool
mIsAutoBSize
;
}
;
mozilla
:
:
Maybe
<
nsGridContainerFrame
:
:
Fragmentainer
>
GetNearestFragmentainer
(
const
GridReflowInput
&
aState
)
const
;
nscoord
ReflowInFragmentainer
(
GridReflowInput
&
aState
const
LogicalRect
&
aContentArea
ReflowOutput
&
aDesiredSize
nsReflowStatus
&
aStatus
Fragmentainer
&
aFragmentainer
const
nsSize
&
aContainerSize
)
;
nscoord
ReflowRowsInFragmentainer
(
GridReflowInput
&
aState
const
LogicalRect
&
aContentArea
ReflowOutput
&
aDesiredSize
nsReflowStatus
&
aStatus
Fragmentainer
&
aFragmentainer
const
nsSize
&
aContainerSize
const
nsTArray
<
const
GridItemInfo
*
>
&
aItems
uint32_t
aStartRow
uint32_t
aEndRow
nscoord
aBSize
nscoord
aAvailableSize
)
;
void
ReflowInFlowChild
(
nsIFrame
*
aChild
const
GridItemInfo
*
aGridItemInfo
nsSize
aContainerSize
mozilla
:
:
Maybe
<
nscoord
>
aStretchBSize
const
Fragmentainer
*
aFragmentainer
const
GridReflowInput
&
aState
const
LogicalRect
&
aContentArea
ReflowOutput
&
aDesiredSize
nsReflowStatus
&
aStatus
)
;
nscoord
mCachedMinISize
;
nscoord
mCachedPrefISize
;
#
ifdef
DEBUG
bool
mDidPushItemsBitMayLie
;
#
endif
}
;
#
endif
