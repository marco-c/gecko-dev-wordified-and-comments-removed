#
ifndef
nsFloatManager_h_
#
define
nsFloatManager_h_
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
WritingModes
.
h
"
#
include
"
nsCoord
.
h
"
#
include
"
nsFrameList
.
h
"
#
include
"
nsIntervalSet
.
h
"
#
include
"
nsPoint
.
h
"
#
include
"
nsTArray
.
h
"
class
nsIPresShell
;
class
nsIFrame
;
class
nsPresContext
;
namespace
mozilla
{
struct
ReflowInput
;
class
StyleBasicShape
;
}
struct
nsFlowAreaRect
{
mozilla
:
:
LogicalRect
mRect
;
bool
mHasFloats
;
nsFlowAreaRect
(
mozilla
:
:
WritingMode
aWritingMode
nscoord
aICoord
nscoord
aBCoord
nscoord
aISize
nscoord
aBSize
bool
aHasFloats
)
:
mRect
(
aWritingMode
aICoord
aBCoord
aISize
aBSize
)
mHasFloats
(
aHasFloats
)
{
}
}
;
#
define
NS_FLOAT_MANAGER_CACHE_SIZE
64
class
nsFloatManager
{
public
:
explicit
nsFloatManager
(
nsIPresShell
*
aPresShell
mozilla
:
:
WritingMode
aWM
)
;
~
nsFloatManager
(
)
;
void
*
operator
new
(
size_t
aSize
)
CPP_THROW_NEW
;
void
operator
delete
(
void
*
aPtr
size_t
aSize
)
;
static
void
Shutdown
(
)
;
static
mozilla
:
:
LogicalRect
GetRegionFor
(
mozilla
:
:
WritingMode
aWM
nsIFrame
*
aFloatFrame
const
nsSize
&
aContainerSize
)
;
static
mozilla
:
:
LogicalRect
CalculateRegionFor
(
mozilla
:
:
WritingMode
aWM
nsIFrame
*
aFloatFrame
const
mozilla
:
:
LogicalMargin
&
aMargin
const
nsSize
&
aContainerSize
)
;
static
void
StoreRegionFor
(
mozilla
:
:
WritingMode
aWM
nsIFrame
*
aFloat
const
mozilla
:
:
LogicalRect
&
aRegion
const
nsSize
&
aContainerSize
)
;
struct
SavedState
{
explicit
SavedState
(
)
{
}
private
:
uint32_t
mFloatInfoCount
;
nscoord
mLineLeft
mBlockStart
;
bool
mPushedLeftFloatPastBreak
;
bool
mPushedRightFloatPastBreak
;
bool
mSplitLeftFloatAcrossBreak
;
bool
mSplitRightFloatAcrossBreak
;
friend
class
nsFloatManager
;
}
;
void
Translate
(
nscoord
aLineLeft
nscoord
aBlockStart
)
{
mLineLeft
+
=
aLineLeft
;
mBlockStart
+
=
aBlockStart
;
}
void
GetTranslation
(
nscoord
&
aLineLeft
nscoord
&
aBlockStart
)
const
{
aLineLeft
=
mLineLeft
;
aBlockStart
=
mBlockStart
;
}
enum
class
BandInfoType
{
BandFromPoint
WidthWithinHeight
}
;
enum
class
ShapeType
{
Margin
ShapeOutside
}
;
nsFlowAreaRect
GetFlowArea
(
mozilla
:
:
WritingMode
aWM
nscoord
aBCoord
nscoord
aBSize
BandInfoType
aBandInfoType
ShapeType
aShapeType
mozilla
:
:
LogicalRect
aContentArea
SavedState
*
aState
const
nsSize
&
aContainerSize
)
const
;
void
AddFloat
(
nsIFrame
*
aFloatFrame
const
mozilla
:
:
LogicalRect
&
aMarginRect
mozilla
:
:
WritingMode
aWM
const
nsSize
&
aContainerSize
)
;
void
SetPushedLeftFloatPastBreak
(
)
{
mPushedLeftFloatPastBreak
=
true
;
}
void
SetPushedRightFloatPastBreak
(
)
{
mPushedRightFloatPastBreak
=
true
;
}
void
SetSplitLeftFloatAcrossBreak
(
)
{
mSplitLeftFloatAcrossBreak
=
true
;
}
void
SetSplitRightFloatAcrossBreak
(
)
{
mSplitRightFloatAcrossBreak
=
true
;
}
nsresult
RemoveTrailingRegions
(
nsIFrame
*
aFrameList
)
;
bool
HasAnyFloats
(
)
const
{
return
!
mFloats
.
IsEmpty
(
)
;
}
bool
HasFloatDamage
(
)
const
{
return
!
mFloatDamage
.
IsEmpty
(
)
;
}
void
IncludeInDamage
(
nscoord
aIntervalBegin
nscoord
aIntervalEnd
)
{
mFloatDamage
.
IncludeInterval
(
aIntervalBegin
+
mBlockStart
aIntervalEnd
+
mBlockStart
)
;
}
bool
IntersectsDamage
(
nscoord
aIntervalBegin
nscoord
aIntervalEnd
)
const
{
return
mFloatDamage
.
Intersects
(
aIntervalBegin
+
mBlockStart
aIntervalEnd
+
mBlockStart
)
;
}
void
PushState
(
SavedState
*
aState
)
;
void
PopState
(
SavedState
*
aState
)
;
nscoord
GetLowestFloatTop
(
)
const
;
enum
{
DONT_CLEAR_PUSHED_FLOATS
=
(
1
<
<
0
)
}
;
nscoord
ClearFloats
(
nscoord
aBCoord
mozilla
:
:
StyleClear
aBreakType
uint32_t
aFlags
=
0
)
const
;
bool
ClearContinues
(
mozilla
:
:
StyleClear
aBreakType
)
const
;
void
AssertStateMatches
(
SavedState
*
aState
)
const
{
NS_ASSERTION
(
aState
-
>
mLineLeft
=
=
mLineLeft
&
&
aState
-
>
mBlockStart
=
=
mBlockStart
&
&
aState
-
>
mPushedLeftFloatPastBreak
=
=
mPushedLeftFloatPastBreak
&
&
aState
-
>
mPushedRightFloatPastBreak
=
=
mPushedRightFloatPastBreak
&
&
aState
-
>
mSplitLeftFloatAcrossBreak
=
=
mSplitLeftFloatAcrossBreak
&
&
aState
-
>
mSplitRightFloatAcrossBreak
=
=
mSplitRightFloatAcrossBreak
&
&
aState
-
>
mFloatInfoCount
=
=
mFloats
.
Length
(
)
"
float
manager
state
should
match
saved
state
"
)
;
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
List
(
FILE
*
out
)
const
;
#
endif
private
:
class
ShapeInfo
{
public
:
virtual
~
ShapeInfo
(
)
{
}
virtual
nscoord
LineLeft
(
const
nscoord
aBStart
const
nscoord
aBEnd
)
const
=
0
;
virtual
nscoord
LineRight
(
const
nscoord
aBStart
const
nscoord
aBEnd
)
const
=
0
;
virtual
nscoord
BStart
(
)
const
=
0
;
virtual
nscoord
BEnd
(
)
const
=
0
;
virtual
bool
IsEmpty
(
)
const
=
0
;
virtual
void
Translate
(
nscoord
aLineLeft
nscoord
aBlockStart
)
=
0
;
static
mozilla
:
:
LogicalRect
ComputeShapeBoxRect
(
const
mozilla
:
:
StyleShapeSource
&
aShapeOutside
nsIFrame
*
const
aFrame
const
mozilla
:
:
LogicalRect
&
aMarginRect
mozilla
:
:
WritingMode
aWM
)
;
static
nsRect
ConvertToFloatLogical
(
const
mozilla
:
:
LogicalRect
&
aRect
mozilla
:
:
WritingMode
aWM
const
nsSize
&
aContainerSize
)
{
return
nsRect
(
aRect
.
LineLeft
(
aWM
aContainerSize
)
aRect
.
BStart
(
aWM
)
aRect
.
ISize
(
aWM
)
aRect
.
BSize
(
aWM
)
)
;
}
static
mozilla
:
:
UniquePtr
<
ShapeInfo
>
CreateShapeBox
(
nsIFrame
*
const
aFrame
const
mozilla
:
:
LogicalRect
&
aShapeBoxRect
mozilla
:
:
WritingMode
aWM
const
nsSize
&
aContainerSize
)
;
static
mozilla
:
:
UniquePtr
<
ShapeInfo
>
CreateInset
(
const
mozilla
:
:
UniquePtr
<
mozilla
:
:
StyleBasicShape
>
&
aBasicShape
const
mozilla
:
:
LogicalRect
&
aShapeBoxRect
mozilla
:
:
WritingMode
aWM
const
nsSize
&
aContainerSize
)
;
static
mozilla
:
:
UniquePtr
<
ShapeInfo
>
CreateCircleOrEllipse
(
const
mozilla
:
:
UniquePtr
<
mozilla
:
:
StyleBasicShape
>
&
aBasicShape
const
mozilla
:
:
LogicalRect
&
aShapeBoxRect
mozilla
:
:
WritingMode
aWM
const
nsSize
&
aContainerSize
)
;
static
mozilla
:
:
UniquePtr
<
ShapeInfo
>
CreatePolygon
(
const
mozilla
:
:
UniquePtr
<
mozilla
:
:
StyleBasicShape
>
&
aBasicShape
const
mozilla
:
:
LogicalRect
&
aShapeBoxRect
mozilla
:
:
WritingMode
aWM
const
nsSize
&
aContainerSize
)
;
protected
:
static
nscoord
ComputeEllipseLineInterceptDiff
(
const
nscoord
aShapeBoxBStart
const
nscoord
aShapeBoxBEnd
const
nscoord
aBStartCornerRadiusL
const
nscoord
aBStartCornerRadiusB
const
nscoord
aBEndCornerRadiusL
const
nscoord
aBEndCornerRadiusB
const
nscoord
aBandBStart
const
nscoord
aBandBEnd
)
;
static
nscoord
XInterceptAtY
(
const
nscoord
aY
const
nscoord
aRadiusX
const
nscoord
aRadiusY
)
;
static
nsPoint
ConvertToFloatLogical
(
const
nsPoint
&
aPoint
mozilla
:
:
WritingMode
aWM
const
nsSize
&
aContainerSize
)
;
static
mozilla
:
:
UniquePtr
<
nscoord
[
]
>
ConvertToFloatLogical
(
const
nscoord
aRadii
[
8
]
mozilla
:
:
WritingMode
aWM
)
;
}
;
class
RoundedBoxShapeInfo
final
:
public
ShapeInfo
{
public
:
RoundedBoxShapeInfo
(
const
nsRect
&
aRect
mozilla
:
:
UniquePtr
<
nscoord
[
]
>
aRadii
)
:
mRect
(
aRect
)
mRadii
(
Move
(
aRadii
)
)
{
}
nscoord
LineLeft
(
const
nscoord
aBStart
const
nscoord
aBEnd
)
const
override
;
nscoord
LineRight
(
const
nscoord
aBStart
const
nscoord
aBEnd
)
const
override
;
nscoord
BStart
(
)
const
override
{
return
mRect
.
y
;
}
nscoord
BEnd
(
)
const
override
{
return
mRect
.
YMost
(
)
;
}
bool
IsEmpty
(
)
const
override
{
return
mRect
.
IsEmpty
(
)
;
}
;
void
Translate
(
nscoord
aLineLeft
nscoord
aBlockStart
)
override
{
mRect
.
MoveBy
(
aLineLeft
aBlockStart
)
;
}
private
:
nsRect
mRect
;
mozilla
:
:
UniquePtr
<
nscoord
[
]
>
mRadii
;
}
;
class
EllipseShapeInfo
final
:
public
ShapeInfo
{
public
:
EllipseShapeInfo
(
const
nsPoint
&
aCenter
const
nsSize
&
aRadii
)
:
mCenter
(
aCenter
)
mRadii
(
aRadii
)
{
}
nscoord
LineLeft
(
const
nscoord
aBStart
const
nscoord
aBEnd
)
const
override
;
nscoord
LineRight
(
const
nscoord
aBStart
const
nscoord
aBEnd
)
const
override
;
nscoord
BStart
(
)
const
override
{
return
mCenter
.
y
-
mRadii
.
height
;
}
nscoord
BEnd
(
)
const
override
{
return
mCenter
.
y
+
mRadii
.
height
;
}
bool
IsEmpty
(
)
const
override
{
return
mRadii
.
IsEmpty
(
)
;
}
;
void
Translate
(
nscoord
aLineLeft
nscoord
aBlockStart
)
override
{
mCenter
.
MoveBy
(
aLineLeft
aBlockStart
)
;
}
private
:
nsPoint
mCenter
;
nsSize
mRadii
;
}
;
class
PolygonShapeInfo
final
:
public
ShapeInfo
{
public
:
explicit
PolygonShapeInfo
(
nsTArray
<
nsPoint
>
&
&
aVertices
)
;
nscoord
LineLeft
(
const
nscoord
aBStart
const
nscoord
aBEnd
)
const
override
;
nscoord
LineRight
(
const
nscoord
aBStart
const
nscoord
aBEnd
)
const
override
;
nscoord
BStart
(
)
const
override
{
return
mBStart
;
}
nscoord
BEnd
(
)
const
override
{
return
mBEnd
;
}
bool
IsEmpty
(
)
const
override
{
return
mEmpty
;
}
void
Translate
(
nscoord
aLineLeft
nscoord
aBlockStart
)
override
;
private
:
nscoord
ComputeLineIntercept
(
const
nscoord
aBStart
const
nscoord
aBEnd
nscoord
(
*
aCompareOp
)
(
std
:
:
initializer_list
<
nscoord
>
)
const
nscoord
aLineInterceptInitialValue
)
const
;
static
nscoord
XInterceptAtY
(
const
nscoord
aY
const
nsPoint
&
aP1
const
nsPoint
&
aP2
)
;
nsTArray
<
nsPoint
>
mVertices
;
bool
mEmpty
=
false
;
nscoord
mBStart
=
nscoord_MAX
;
nscoord
mBEnd
=
nscoord_MIN
;
}
;
struct
FloatInfo
{
nsIFrame
*
const
mFrame
;
nscoord
mLeftBEnd
mRightBEnd
;
FloatInfo
(
nsIFrame
*
aFrame
nscoord
aLineLeft
nscoord
aBlockStart
const
mozilla
:
:
LogicalRect
&
aMarginRect
mozilla
:
:
WritingMode
aWM
const
nsSize
&
aContainerSize
)
;
nscoord
LineLeft
(
)
const
{
return
mRect
.
x
;
}
nscoord
LineRight
(
)
const
{
return
mRect
.
XMost
(
)
;
}
nscoord
ISize
(
)
const
{
return
mRect
.
width
;
}
nscoord
BStart
(
)
const
{
return
mRect
.
y
;
}
nscoord
BEnd
(
)
const
{
return
mRect
.
YMost
(
)
;
}
nscoord
BSize
(
)
const
{
return
mRect
.
height
;
}
bool
IsEmpty
(
)
const
{
return
mRect
.
IsEmpty
(
)
;
}
nscoord
LineLeft
(
ShapeType
aShapeType
const
nscoord
aBStart
const
nscoord
aBEnd
)
const
;
nscoord
LineRight
(
ShapeType
aShapeType
const
nscoord
aBStart
const
nscoord
aBEnd
)
const
;
nscoord
BStart
(
ShapeType
aShapeType
)
const
;
nscoord
BEnd
(
ShapeType
aShapeType
)
const
;
bool
IsEmpty
(
ShapeType
aShapeType
)
const
;
#
ifdef
NS_BUILD_REFCNT_LOGGING
FloatInfo
(
FloatInfo
&
&
aOther
)
;
~
FloatInfo
(
)
;
#
endif
nsRect
mRect
;
mozilla
:
:
UniquePtr
<
ShapeInfo
>
mShapeInfo
;
}
;
#
ifdef
DEBUG
mozilla
:
:
WritingMode
mWritingMode
;
#
endif
nscoord
mLineLeft
mBlockStart
;
AutoTArray
<
FloatInfo
11
>
mFloats
;
nsIntervalSet
mFloatDamage
;
bool
mPushedLeftFloatPastBreak
;
bool
mPushedRightFloatPastBreak
;
bool
mSplitLeftFloatAcrossBreak
;
bool
mSplitRightFloatAcrossBreak
;
static
int32_t
sCachedFloatManagerCount
;
static
void
*
sCachedFloatManagers
[
NS_FLOAT_MANAGER_CACHE_SIZE
]
;
nsFloatManager
(
const
nsFloatManager
&
)
=
delete
;
void
operator
=
(
const
nsFloatManager
&
)
=
delete
;
}
;
class
nsAutoFloatManager
{
using
ReflowInput
=
mozilla
:
:
ReflowInput
;
public
:
explicit
nsAutoFloatManager
(
ReflowInput
&
aReflowInput
)
:
mReflowInput
(
aReflowInput
)
mOld
(
nullptr
)
{
}
~
nsAutoFloatManager
(
)
;
void
CreateFloatManager
(
nsPresContext
*
aPresContext
)
;
protected
:
ReflowInput
&
mReflowInput
;
mozilla
:
:
UniquePtr
<
nsFloatManager
>
mNew
;
nsFloatManager
*
mOld
;
}
;
#
endif
