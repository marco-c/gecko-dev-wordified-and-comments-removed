#
include
"
nsViewportFrame
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsSubDocumentFrame
.
h
"
#
include
"
nsCanvasFrame
.
h
"
#
include
"
nsAbsoluteContainingBlock
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
nsIMozBrowserFrame
.
h
"
using
namespace
mozilla
;
typedef
nsAbsoluteContainingBlock
:
:
AbsPosReflowFlags
AbsPosReflowFlags
;
ViewportFrame
*
NS_NewViewportFrame
(
nsIPresShell
*
aPresShell
nsStyleContext
*
aContext
)
{
return
new
(
aPresShell
)
ViewportFrame
(
aContext
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
ViewportFrame
)
NS_QUERYFRAME_HEAD
(
ViewportFrame
)
NS_QUERYFRAME_ENTRY
(
ViewportFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsContainerFrame
)
void
ViewportFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
nsContainerFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
nsIFrame
*
parent
=
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
this
)
;
if
(
parent
)
{
nsFrameState
state
=
parent
-
>
GetStateBits
(
)
;
mState
|
=
state
&
(
NS_FRAME_IN_POPUP
)
;
}
}
void
ViewportFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aDirtyRect
const
nsDisplayListSet
&
aLists
)
{
PROFILER_LABEL
(
"
ViewportFrame
"
"
BuildDisplayList
"
js
:
:
ProfileEntry
:
:
Category
:
:
GRAPHICS
)
;
if
(
nsIFrame
*
kid
=
mFrames
.
FirstChild
(
)
)
{
BuildDisplayListForChild
(
aBuilder
kid
aDirtyRect
aLists
)
;
}
nsDisplayList
topLayerList
;
BuildDisplayListForTopLayer
(
aBuilder
&
topLayerList
)
;
if
(
!
topLayerList
.
IsEmpty
(
)
)
{
nsDisplayWrapList
*
wrapList
=
new
(
aBuilder
)
nsDisplayWrapList
(
aBuilder
this
&
topLayerList
)
;
wrapList
-
>
SetOverrideZIndex
(
std
:
:
numeric_limits
<
decltype
(
wrapList
-
>
ZIndex
(
)
)
>
:
:
max
(
)
)
;
aLists
.
PositionedDescendants
(
)
-
>
AppendNewToTop
(
wrapList
)
;
}
}
#
ifdef
DEBUG
static
bool
ShouldInTopLayerForFullscreen
(
Element
*
aElement
)
{
if
(
!
aElement
-
>
GetParent
(
)
)
{
return
false
;
}
nsCOMPtr
<
nsIMozBrowserFrame
>
browserFrame
=
do_QueryInterface
(
aElement
)
;
if
(
browserFrame
&
&
browserFrame
-
>
GetReallyIsBrowserOrApp
(
)
)
{
return
false
;
}
return
true
;
}
#
endif
static
void
BuildDisplayListForTopLayerFrame
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
)
{
nsRect
dirty
;
DisplayListClipState
:
:
AutoClipMultiple
clipState
(
aBuilder
)
;
nsDisplayListBuilder
:
:
OutOfFlowDisplayData
*
savedOutOfFlowData
=
nsDisplayListBuilder
:
:
GetOutOfFlowData
(
aFrame
)
;
if
(
savedOutOfFlowData
)
{
dirty
=
savedOutOfFlowData
-
>
mDirtyRect
;
clipState
.
SetClipForContainingBlockDescendants
(
&
savedOutOfFlowData
-
>
mContainingBlockClip
)
;
clipState
.
SetScrollClipForContainingBlockDescendants
(
aBuilder
savedOutOfFlowData
-
>
mContainingBlockScrollClip
)
;
}
nsDisplayList
list
;
aFrame
-
>
BuildDisplayListForStackingContext
(
aBuilder
dirty
&
list
)
;
aList
-
>
AppendToTop
(
&
list
)
;
}
void
ViewportFrame
:
:
BuildDisplayListForTopLayer
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
)
{
nsIDocument
*
doc
=
PresContext
(
)
-
>
Document
(
)
;
nsTArray
<
Element
*
>
fullscreenStack
=
doc
-
>
GetFullscreenStack
(
)
;
for
(
Element
*
elem
:
fullscreenStack
)
{
if
(
nsIFrame
*
frame
=
elem
-
>
GetPrimaryFrame
(
)
)
{
if
(
frame
-
>
StyleDisplay
(
)
-
>
mTopLayer
=
=
NS_STYLE_TOP_LAYER_NONE
)
{
MOZ_ASSERT
(
!
aBuilder
-
>
IsForPainting
(
)
|
|
!
ShouldInTopLayerForFullscreen
(
elem
)
)
;
continue
;
}
MOZ_ASSERT
(
ShouldInTopLayerForFullscreen
(
elem
)
)
;
if
(
!
(
frame
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
)
{
MOZ_ASSERT
(
!
elem
-
>
GetParent
(
)
-
>
IsHTMLElement
(
)
"
HTML
element
"
"
should
always
be
out
-
of
-
flow
if
in
the
top
layer
"
)
;
continue
;
}
if
(
nsIFrame
*
backdropPh
=
frame
-
>
GetChildList
(
kBackdropList
)
.
FirstChild
(
)
)
{
MOZ_ASSERT
(
backdropPh
-
>
GetType
(
)
=
=
nsGkAtoms
:
:
placeholderFrame
)
;
nsIFrame
*
backdropFrame
=
static_cast
<
nsPlaceholderFrame
*
>
(
backdropPh
)
-
>
GetOutOfFlowFrame
(
)
;
MOZ_ASSERT
(
backdropFrame
)
;
BuildDisplayListForTopLayerFrame
(
aBuilder
backdropFrame
aList
)
;
}
BuildDisplayListForTopLayerFrame
(
aBuilder
frame
aList
)
;
}
}
nsIPresShell
*
shell
=
PresContext
(
)
-
>
PresShell
(
)
;
if
(
nsCanvasFrame
*
canvasFrame
=
shell
-
>
GetCanvasFrame
(
)
)
{
if
(
Element
*
container
=
canvasFrame
-
>
GetCustomContentContainer
(
)
)
{
if
(
nsIFrame
*
frame
=
container
-
>
GetPrimaryFrame
(
)
)
{
BuildDisplayListForTopLayerFrame
(
aBuilder
frame
aList
)
;
}
}
}
}
#
ifdef
DEBUG
void
ViewportFrame
:
:
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
{
NS_ASSERTION
(
aListID
=
=
kPrincipalList
"
unexpected
child
list
"
)
;
NS_ASSERTION
(
GetChildList
(
aListID
)
.
IsEmpty
(
)
"
Shouldn
'
t
have
any
kids
!
"
)
;
nsContainerFrame
:
:
AppendFrames
(
aListID
aFrameList
)
;
}
void
ViewportFrame
:
:
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
aFrameList
)
{
NS_ASSERTION
(
aListID
=
=
kPrincipalList
"
unexpected
child
list
"
)
;
NS_ASSERTION
(
GetChildList
(
aListID
)
.
IsEmpty
(
)
"
Shouldn
'
t
have
any
kids
!
"
)
;
nsContainerFrame
:
:
InsertFrames
(
aListID
aPrevFrame
aFrameList
)
;
}
void
ViewportFrame
:
:
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
{
NS_ASSERTION
(
aListID
=
=
kPrincipalList
"
unexpected
child
list
"
)
;
nsContainerFrame
:
:
RemoveFrame
(
aListID
aOldFrame
)
;
}
#
endif
nscoord
ViewportFrame
:
:
GetMinISize
(
nsRenderingContext
*
aRenderingContext
)
{
nscoord
result
;
DISPLAY_MIN_WIDTH
(
this
result
)
;
if
(
mFrames
.
IsEmpty
(
)
)
result
=
0
;
else
result
=
mFrames
.
FirstChild
(
)
-
>
GetMinISize
(
aRenderingContext
)
;
return
result
;
}
nscoord
ViewportFrame
:
:
GetPrefISize
(
nsRenderingContext
*
aRenderingContext
)
{
nscoord
result
;
DISPLAY_PREF_WIDTH
(
this
result
)
;
if
(
mFrames
.
IsEmpty
(
)
)
result
=
0
;
else
result
=
mFrames
.
FirstChild
(
)
-
>
GetPrefISize
(
aRenderingContext
)
;
return
result
;
}
nsPoint
ViewportFrame
:
:
AdjustReflowStateForScrollbars
(
ReflowInput
*
aReflowState
)
const
{
nsIFrame
*
kidFrame
=
mFrames
.
FirstChild
(
)
;
nsIScrollableFrame
*
scrollingFrame
=
do_QueryFrame
(
kidFrame
)
;
if
(
scrollingFrame
)
{
WritingMode
wm
=
aReflowState
-
>
GetWritingMode
(
)
;
LogicalMargin
scrollbars
(
wm
scrollingFrame
-
>
GetActualScrollbarSizes
(
)
)
;
aReflowState
-
>
SetComputedISize
(
aReflowState
-
>
ComputedISize
(
)
-
scrollbars
.
IStartEnd
(
wm
)
)
;
aReflowState
-
>
AvailableISize
(
)
-
=
scrollbars
.
IStartEnd
(
wm
)
;
aReflowState
-
>
SetComputedBSizeWithoutResettingResizeFlags
(
aReflowState
-
>
ComputedBSize
(
)
-
scrollbars
.
BStartEnd
(
wm
)
)
;
return
nsPoint
(
scrollbars
.
Left
(
wm
)
scrollbars
.
Top
(
wm
)
)
;
}
return
nsPoint
(
0
0
)
;
}
nsRect
ViewportFrame
:
:
AdjustReflowStateAsContainingBlock
(
ReflowInput
*
aReflowState
)
const
{
#
ifdef
DEBUG
nsPoint
offset
=
#
endif
AdjustReflowStateForScrollbars
(
aReflowState
)
;
NS_ASSERTION
(
GetAbsoluteContainingBlock
(
)
-
>
GetChildList
(
)
.
IsEmpty
(
)
|
|
(
offset
.
x
=
=
0
&
&
offset
.
y
=
=
0
)
"
We
don
'
t
handle
correct
positioning
of
fixed
frames
with
"
"
scrollbars
in
odd
positions
"
)
;
nsRect
rect
(
0
0
aReflowState
-
>
ComputedWidth
(
)
aReflowState
-
>
ComputedHeight
(
)
)
;
nsIPresShell
*
ps
=
PresContext
(
)
-
>
PresShell
(
)
;
if
(
ps
-
>
IsScrollPositionClampingScrollPortSizeSet
(
)
)
{
rect
.
SizeTo
(
ps
-
>
GetScrollPositionClampingScrollPortSize
(
)
)
;
}
return
rect
;
}
void
ViewportFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
nsHTMLReflowMetrics
&
aDesiredSize
const
ReflowInput
&
aReflowState
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
ViewportFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowState
aDesiredSize
aStatus
)
;
NS_FRAME_TRACE_REFLOW_IN
(
"
ViewportFrame
:
:
Reflow
"
)
;
aStatus
=
NS_FRAME_COMPLETE
;
AddStateBits
(
NS_FRAME_CONTAINS_RELATIVE_BSIZE
)
;
SetSize
(
nsSize
(
aReflowState
.
ComputedWidth
(
)
aReflowState
.
ComputedHeight
(
)
)
)
;
nscoord
kidBSize
=
0
;
WritingMode
wm
=
aReflowState
.
GetWritingMode
(
)
;
if
(
mFrames
.
NotEmpty
(
)
)
{
if
(
aReflowState
.
ShouldReflowAllKids
(
)
|
|
aReflowState
.
IsBResize
(
)
|
|
NS_SUBTREE_DIRTY
(
mFrames
.
FirstChild
(
)
)
)
{
nsIFrame
*
kidFrame
=
mFrames
.
FirstChild
(
)
;
nsHTMLReflowMetrics
kidDesiredSize
(
aReflowState
)
;
WritingMode
wm
=
kidFrame
-
>
GetWritingMode
(
)
;
LogicalSize
availableSpace
=
aReflowState
.
AvailableSize
(
wm
)
;
ReflowInput
kidReflowState
(
aPresContext
aReflowState
kidFrame
availableSpace
)
;
kidReflowState
.
SetComputedBSize
(
aReflowState
.
ComputedBSize
(
)
)
;
ReflowChild
(
kidFrame
aPresContext
kidDesiredSize
kidReflowState
0
0
0
aStatus
)
;
kidBSize
=
kidDesiredSize
.
BSize
(
wm
)
;
FinishReflowChild
(
kidFrame
aPresContext
kidDesiredSize
nullptr
0
0
0
)
;
}
else
{
kidBSize
=
LogicalSize
(
wm
mFrames
.
FirstChild
(
)
-
>
GetSize
(
)
)
.
BSize
(
wm
)
;
}
}
NS_ASSERTION
(
aReflowState
.
AvailableISize
(
)
!
=
NS_UNCONSTRAINEDSIZE
"
shouldn
'
t
happen
anymore
"
)
;
LogicalSize
maxSize
(
wm
aReflowState
.
AvailableISize
(
)
aReflowState
.
ComputedBSize
(
)
!
=
NS_UNCONSTRAINEDSIZE
?
aReflowState
.
ComputedBSize
(
)
:
kidBSize
)
;
aDesiredSize
.
SetSize
(
wm
maxSize
)
;
aDesiredSize
.
SetOverflowAreasToDesiredBounds
(
)
;
if
(
HasAbsolutelyPositionedChildren
(
)
)
{
ReflowInput
reflowState
(
aReflowState
)
;
if
(
reflowState
.
AvailableBSize
(
)
=
=
NS_UNCONSTRAINEDSIZE
)
{
reflowState
.
AvailableBSize
(
)
=
maxSize
.
BSize
(
wm
)
;
NS_ASSERTION
(
reflowState
.
ComputedPhysicalBorderPadding
(
)
=
=
nsMargin
(
0
0
0
0
)
"
Viewports
can
'
t
have
border
/
padding
"
)
;
reflowState
.
SetComputedBSize
(
maxSize
.
BSize
(
wm
)
)
;
}
nsRect
rect
=
AdjustReflowStateAsContainingBlock
(
&
reflowState
)
;
nsOverflowAreas
*
overflowAreas
=
&
aDesiredSize
.
mOverflowAreas
;
nsIScrollableFrame
*
rootScrollFrame
=
aPresContext
-
>
PresShell
(
)
-
>
GetRootScrollFrameAsScrollable
(
)
;
if
(
rootScrollFrame
&
&
!
rootScrollFrame
-
>
IsIgnoringViewportClipping
(
)
)
{
overflowAreas
=
nullptr
;
}
AbsPosReflowFlags
flags
=
AbsPosReflowFlags
:
:
eCBWidthAndHeightChanged
;
GetAbsoluteContainingBlock
(
)
-
>
Reflow
(
this
aPresContext
reflowState
aStatus
rect
flags
overflowAreas
)
;
}
if
(
mFrames
.
NotEmpty
(
)
)
{
ConsiderChildOverflow
(
aDesiredSize
.
mOverflowAreas
mFrames
.
FirstChild
(
)
)
;
}
if
(
GetStateBits
(
)
&
NS_FRAME_IS_DIRTY
)
{
InvalidateFrame
(
)
;
}
bool
overflowChanged
=
FinishAndStoreOverflow
(
&
aDesiredSize
)
;
if
(
overflowChanged
)
{
nsSubDocumentFrame
*
container
=
static_cast
<
nsSubDocumentFrame
*
>
(
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
this
)
)
;
if
(
container
&
&
!
container
-
>
ShouldClipSubdocument
(
)
)
{
container
-
>
PresContext
(
)
-
>
PresShell
(
)
-
>
FrameNeedsReflow
(
container
nsIPresShell
:
:
eResize
NS_FRAME_IS_DIRTY
)
;
}
}
NS_FRAME_TRACE_REFLOW_OUT
(
"
ViewportFrame
:
:
Reflow
"
aStatus
)
;
NS_FRAME_SET_TRUNCATION
(
aStatus
aReflowState
aDesiredSize
)
;
}
bool
ViewportFrame
:
:
ComputeCustomOverflow
(
nsOverflowAreas
&
aOverflowAreas
)
{
nsIScrollableFrame
*
rootScrollFrame
=
PresContext
(
)
-
>
PresShell
(
)
-
>
GetRootScrollFrameAsScrollable
(
)
;
if
(
rootScrollFrame
&
&
!
rootScrollFrame
-
>
IsIgnoringViewportClipping
(
)
)
{
return
false
;
}
return
nsContainerFrame
:
:
ComputeCustomOverflow
(
aOverflowAreas
)
;
}
nsIAtom
*
ViewportFrame
:
:
GetType
(
)
const
{
return
nsGkAtoms
:
:
viewportFrame
;
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
ViewportFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
NS_LITERAL_STRING
(
"
Viewport
"
)
aResult
)
;
}
#
endif
