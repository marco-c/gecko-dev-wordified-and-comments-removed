#
include
"
nsCanvasFrame
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
ComputedStyle
.
h
"
#
include
"
mozilla
/
dom
/
AnonymousContent
.
h
"
#
include
"
mozilla
/
layers
/
RenderRootStateManager
.
h
"
#
include
"
mozilla
/
layers
/
StackingContextHelper
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
ScrollContainerFrame
.
h
"
#
include
"
mozilla
/
StaticPrefs_browser
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsContentCreatorFunctions
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
nsCSSRendering
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsFrameManager
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsPresContext
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
layout
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
layers
;
nsCanvasFrame
*
NS_NewCanvasFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsCanvasFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
nsIPopupContainer
*
nsIPopupContainer
:
:
GetPopupContainer
(
PresShell
*
aPresShell
)
{
return
aPresShell
?
aPresShell
-
>
GetCanvasFrame
(
)
:
nullptr
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsCanvasFrame
)
NS_QUERYFRAME_HEAD
(
nsCanvasFrame
)
NS_QUERYFRAME_ENTRY
(
nsCanvasFrame
)
NS_QUERYFRAME_ENTRY
(
nsIAnonymousContentCreator
)
NS_QUERYFRAME_ENTRY
(
nsIPopupContainer
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsContainerFrame
)
void
nsCanvasFrame
:
:
ShowCustomContentContainer
(
)
{
if
(
mCustomContentContainer
)
{
mCustomContentContainer
-
>
UnsetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
hidden
true
)
;
}
}
void
nsCanvasFrame
:
:
HideCustomContentContainer
(
)
{
if
(
mCustomContentContainer
)
{
mCustomContentContainer
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
hidden
u
"
true
"
_ns
true
)
;
}
}
void
InsertAnonymousContentInContainer
(
Document
&
aDoc
Element
&
aContainer
)
{
if
(
!
aContainer
.
IsInComposedDoc
(
)
|
|
aDoc
.
GetAnonymousContents
(
)
.
IsEmpty
(
)
)
{
return
;
}
for
(
RefPtr
<
AnonymousContent
>
&
anonContent
:
aDoc
.
GetAnonymousContents
(
)
)
{
if
(
nsCOMPtr
<
nsINode
>
parent
=
anonContent
-
>
Host
(
)
-
>
GetParentNode
(
)
)
{
MOZ_ASSERT
(
parent
!
=
&
aContainer
)
;
MOZ_ASSERT
(
parent
-
>
IsElement
(
)
)
;
MOZ_ASSERT
(
parent
-
>
AsElement
(
)
-
>
IsRootOfNativeAnonymousSubtree
(
)
)
;
MOZ_ASSERT
(
!
parent
-
>
IsInComposedDoc
(
)
)
;
MOZ_ASSERT
(
!
parent
-
>
GetParentNode
(
)
)
;
parent
-
>
RemoveChildNode
(
anonContent
-
>
Host
(
)
true
)
;
}
aContainer
.
AppendChildTo
(
anonContent
-
>
Host
(
)
true
IgnoreErrors
(
)
)
;
}
aDoc
.
FlushPendingNotifications
(
FlushType
:
:
Frames
)
;
}
nsresult
nsCanvasFrame
:
:
CreateAnonymousContent
(
nsTArray
<
ContentInfo
>
&
aElements
)
{
MOZ_ASSERT
(
!
mCustomContentContainer
)
;
if
(
!
mContent
)
{
return
NS_OK
;
}
Document
*
doc
=
mContent
-
>
OwnerDoc
(
)
;
mCustomContentContainer
=
doc
-
>
CreateHTMLElement
(
nsGkAtoms
:
:
div
)
;
#
ifdef
DEBUG
mCustomContentContainer
-
>
SetProperty
(
nsGkAtoms
:
:
restylableAnonymousNode
reinterpret_cast
<
void
*
>
(
true
)
)
;
#
endif
mCustomContentContainer
-
>
SetProperty
(
nsGkAtoms
:
:
docLevelNativeAnonymousContent
reinterpret_cast
<
void
*
>
(
true
)
)
;
mCustomContentContainer
-
>
SetIsNativeAnonymousRoot
(
)
;
aElements
.
AppendElement
(
mCustomContentContainer
)
;
mCustomContentContainer
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
role
u
"
presentation
"
_ns
false
)
;
mCustomContentContainer
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_class
u
"
moz
-
custom
-
content
-
container
"
_ns
false
)
;
if
(
doc
-
>
GetAnonymousContents
(
)
.
IsEmpty
(
)
)
{
HideCustomContentContainer
(
)
;
}
else
{
nsContentUtils
:
:
AddScriptRunner
(
NS_NewRunnableFunction
(
"
InsertAnonymousContentInContainer
"
[
doc
=
RefPtr
{
doc
}
container
=
RefPtr
{
mCustomContentContainer
.
get
(
)
}
]
{
InsertAnonymousContentInContainer
(
*
doc
*
container
)
;
}
)
)
;
}
if
(
XRE_IsParentProcess
(
)
&
&
doc
-
>
NodePrincipal
(
)
-
>
IsSystemPrincipal
(
)
)
{
nsNodeInfoManager
*
nodeInfoManager
=
doc
-
>
NodeInfoManager
(
)
;
RefPtr
<
NodeInfo
>
nodeInfo
=
nodeInfoManager
-
>
GetNodeInfo
(
nsGkAtoms
:
:
tooltip
nullptr
kNameSpaceID_XUL
nsINode
:
:
ELEMENT_NODE
)
;
nsresult
rv
=
NS_NewXULElement
(
getter_AddRefs
(
mTooltipContent
)
nodeInfo
.
forget
(
)
dom
:
:
NOT_FROM_PARSER
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mTooltipContent
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_default
u
"
true
"
_ns
false
)
;
mTooltipContent
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
page
u
"
true
"
_ns
false
)
;
mTooltipContent
-
>
SetProperty
(
nsGkAtoms
:
:
docLevelNativeAnonymousContent
reinterpret_cast
<
void
*
>
(
true
)
)
;
aElements
.
AppendElement
(
mTooltipContent
)
;
}
#
ifdef
DEBUG
for
(
auto
&
element
:
aElements
)
{
MOZ_ASSERT
(
element
.
mContent
-
>
GetProperty
(
nsGkAtoms
:
:
docLevelNativeAnonymousContent
)
"
NAC
from
the
canvas
frame
needs
to
be
document
-
level
otherwise
"
"
it
(
1
)
inherits
from
the
document
which
is
unexpected
and
(
2
)
"
"
StyleChildrenIterator
won
'
t
be
able
to
find
it
properly
"
)
;
}
#
endif
return
NS_OK
;
}
void
nsCanvasFrame
:
:
AppendAnonymousContentTo
(
nsTArray
<
nsIContent
*
>
&
aElements
uint32_t
aFilter
)
{
if
(
mCustomContentContainer
)
{
aElements
.
AppendElement
(
mCustomContentContainer
)
;
}
if
(
mTooltipContent
)
{
aElements
.
AppendElement
(
mTooltipContent
)
;
}
}
void
nsCanvasFrame
:
:
Destroy
(
DestroyContext
&
aContext
)
{
if
(
ScrollContainerFrame
*
sf
=
PresShell
(
)
-
>
GetRootScrollContainerFrame
(
)
)
{
sf
-
>
RemoveScrollPositionListener
(
this
)
;
}
aContext
.
AddAnonymousContent
(
mCustomContentContainer
.
forget
(
)
)
;
if
(
mTooltipContent
)
{
aContext
.
AddAnonymousContent
(
mTooltipContent
.
forget
(
)
)
;
}
nsContainerFrame
:
:
Destroy
(
aContext
)
;
}
void
nsCanvasFrame
:
:
ScrollPositionWillChange
(
nscoord
aX
nscoord
aY
)
{
if
(
mDoPaintFocus
)
{
mDoPaintFocus
=
false
;
PresShell
(
)
-
>
GetRootFrame
(
)
-
>
InvalidateFrameSubtree
(
)
;
}
}
NS_IMETHODIMP
nsCanvasFrame
:
:
SetHasFocus
(
bool
aHasFocus
)
{
if
(
mDoPaintFocus
!
=
aHasFocus
)
{
mDoPaintFocus
=
aHasFocus
;
PresShell
(
)
-
>
GetRootFrame
(
)
-
>
InvalidateFrameSubtree
(
)
;
if
(
!
mAddedScrollPositionListener
)
{
if
(
ScrollContainerFrame
*
sf
=
PresShell
(
)
-
>
GetRootScrollContainerFrame
(
)
)
{
sf
-
>
AddScrollPositionListener
(
this
)
;
mAddedScrollPositionListener
=
true
;
}
}
}
return
NS_OK
;
}
void
nsCanvasFrame
:
:
SetInitialChildList
(
ChildListID
aListID
nsFrameList
&
&
aChildList
)
{
NS_ASSERTION
(
aListID
!
=
FrameChildListID
:
:
Principal
|
|
aChildList
.
IsEmpty
(
)
|
|
aChildList
.
OnlyChild
(
)
"
Primary
child
list
can
have
at
most
one
frame
in
it
"
)
;
nsContainerFrame
:
:
SetInitialChildList
(
aListID
std
:
:
move
(
aChildList
)
)
;
}
void
nsCanvasFrame
:
:
AppendFrames
(
ChildListID
aListID
nsFrameList
&
&
aFrameList
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
aListID
=
=
FrameChildListID
:
:
Principal
"
unexpected
child
list
"
)
;
if
(
!
mFrames
.
IsEmpty
(
)
)
{
for
(
nsIFrame
*
f
:
aFrameList
)
{
MOZ_ASSERT
(
f
-
>
GetContent
(
)
-
>
IsInNativeAnonymousSubtree
(
)
"
invalid
child
list
"
)
;
}
}
nsIFrame
:
:
VerifyDirtyBitSet
(
aFrameList
)
;
#
endif
nsContainerFrame
:
:
AppendFrames
(
aListID
std
:
:
move
(
aFrameList
)
)
;
}
void
nsCanvasFrame
:
:
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
const
nsLineList
:
:
iterator
*
aPrevFrameLine
nsFrameList
&
&
aFrameList
)
{
MOZ_ASSERT
(
!
aPrevFrame
"
unexpected
previous
sibling
frame
"
)
;
AppendFrames
(
aListID
std
:
:
move
(
aFrameList
)
)
;
}
#
ifdef
DEBUG
void
nsCanvasFrame
:
:
RemoveFrame
(
DestroyContext
&
aContext
ChildListID
aListID
nsIFrame
*
aOldFrame
)
{
MOZ_ASSERT
(
aListID
=
=
FrameChildListID
:
:
Principal
"
unexpected
child
list
"
)
;
nsContainerFrame
:
:
RemoveFrame
(
aContext
aListID
aOldFrame
)
;
}
#
endif
nsRect
nsCanvasFrame
:
:
CanvasArea
(
)
const
{
nsRect
result
(
InkOverflowRect
(
)
)
;
if
(
ScrollContainerFrame
*
scrollContainerFrame
=
do_QueryFrame
(
GetParent
(
)
)
)
{
nsRect
portRect
=
scrollContainerFrame
-
>
GetScrollPortRect
(
)
;
result
.
UnionRect
(
result
nsRect
(
nsPoint
(
0
0
)
portRect
.
Size
(
)
)
)
;
}
return
result
;
}
Element
*
nsCanvasFrame
:
:
GetDefaultTooltip
(
)
{
return
mTooltipContent
;
}
void
nsDisplayCanvasBackgroundColor
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
nsCanvasFrame
*
frame
=
static_cast
<
nsCanvasFrame
*
>
(
mFrame
)
;
nsPoint
offset
=
ToReferenceFrame
(
)
;
nsRect
bgClipRect
=
frame
-
>
CanvasArea
(
)
+
offset
;
if
(
NS_GET_A
(
mColor
)
>
0
)
{
DrawTarget
*
drawTarget
=
aCtx
-
>
GetDrawTarget
(
)
;
int32_t
appUnitsPerDevPixel
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
Rect
devPxRect
=
NSRectToSnappedRect
(
bgClipRect
appUnitsPerDevPixel
*
drawTarget
)
;
drawTarget
-
>
FillRect
(
devPxRect
ColorPattern
(
ToDeviceColor
(
mColor
)
)
)
;
}
}
bool
nsDisplayCanvasBackgroundColor
:
:
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
nsCanvasFrame
*
frame
=
static_cast
<
nsCanvasFrame
*
>
(
mFrame
)
;
nsPoint
offset
=
ToReferenceFrame
(
)
;
nsRect
bgClipRect
=
frame
-
>
CanvasArea
(
)
+
offset
;
int32_t
appUnitsPerDevPixel
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
LayoutDeviceRect
rect
=
LayoutDeviceRect
:
:
FromAppUnits
(
bgClipRect
appUnitsPerDevPixel
)
;
wr
:
:
LayoutRect
r
=
wr
:
:
ToLayoutRect
(
rect
)
;
aBuilder
.
PushRect
(
r
r
!
BackfaceIsHidden
(
)
false
false
wr
:
:
ToColorF
(
ToDeviceColor
(
mColor
)
)
)
;
return
true
;
}
void
nsDisplayCanvasBackgroundColor
:
:
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
{
aStream
<
<
"
(
rgba
"
<
<
(
int
)
NS_GET_R
(
mColor
)
<
<
"
"
<
<
(
int
)
NS_GET_G
(
mColor
)
<
<
"
"
<
<
(
int
)
NS_GET_B
(
mColor
)
<
<
"
"
<
<
(
int
)
NS_GET_A
(
mColor
)
<
<
"
)
"
;
}
void
nsDisplayCanvasBackgroundImage
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
nsCanvasFrame
*
frame
=
static_cast
<
nsCanvasFrame
*
>
(
mFrame
)
;
nsPoint
offset
=
ToReferenceFrame
(
)
;
nsRect
bgClipRect
=
frame
-
>
CanvasArea
(
)
+
offset
;
PaintInternal
(
aBuilder
aCtx
GetPaintRect
(
aBuilder
aCtx
)
&
bgClipRect
)
;
}
bool
nsDisplayCanvasBackgroundImage
:
:
IsSingleFixedPositionImage
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aClipRect
gfxRect
*
aDestRect
)
{
if
(
!
mBackgroundStyle
)
return
false
;
if
(
mBackgroundStyle
-
>
StyleBackground
(
)
-
>
mImage
.
mLayers
.
Length
(
)
!
=
1
)
return
false
;
nsPresContext
*
presContext
=
mFrame
-
>
PresContext
(
)
;
uint32_t
flags
=
aBuilder
-
>
GetBackgroundPaintFlags
(
)
;
nsRect
borderArea
=
nsRect
(
ToReferenceFrame
(
)
mFrame
-
>
GetSize
(
)
)
;
const
nsStyleImageLayers
:
:
Layer
&
layer
=
mBackgroundStyle
-
>
StyleBackground
(
)
-
>
mImage
.
mLayers
[
mLayer
]
;
if
(
layer
.
mAttachment
!
=
StyleImageLayerAttachment
:
:
Fixed
)
return
false
;
nsBackgroundLayerState
state
=
nsCSSRendering
:
:
PrepareImageLayer
(
presContext
mFrame
flags
borderArea
aClipRect
layer
)
;
if
(
!
mIsRasterImage
)
return
false
;
int32_t
appUnitsPerDevPixel
=
presContext
-
>
AppUnitsPerDevPixel
(
)
;
*
aDestRect
=
nsLayoutUtils
:
:
RectToGfxRect
(
state
.
mFillArea
appUnitsPerDevPixel
)
;
return
true
;
}
void
nsDisplayCanvasThemedBackground
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
nsCanvasFrame
*
frame
=
static_cast
<
nsCanvasFrame
*
>
(
mFrame
)
;
nsPoint
offset
=
ToReferenceFrame
(
)
;
nsRect
bgClipRect
=
frame
-
>
CanvasArea
(
)
+
offset
;
PaintInternal
(
aBuilder
aCtx
GetPaintRect
(
aBuilder
aCtx
)
&
bgClipRect
)
;
}
class
nsDisplayCanvasFocus
:
public
nsPaintedDisplayItem
{
public
:
nsDisplayCanvasFocus
(
nsDisplayListBuilder
*
aBuilder
nsCanvasFrame
*
aFrame
)
:
nsPaintedDisplayItem
(
aBuilder
aFrame
)
{
MOZ_COUNT_CTOR
(
nsDisplayCanvasFocus
)
;
}
MOZ_COUNTED_DTOR_OVERRIDE
(
nsDisplayCanvasFocus
)
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
{
*
aSnap
=
false
;
nsCanvasFrame
*
frame
=
static_cast
<
nsCanvasFrame
*
>
(
mFrame
)
;
return
frame
-
>
CanvasArea
(
)
+
ToReferenceFrame
(
)
;
}
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
{
nsCanvasFrame
*
frame
=
static_cast
<
nsCanvasFrame
*
>
(
mFrame
)
;
frame
-
>
PaintFocus
(
aCtx
-
>
GetDrawTarget
(
)
ToReferenceFrame
(
)
)
;
}
NS_DISPLAY_DECL_NAME
(
"
CanvasFocus
"
TYPE_CANVAS_FOCUS
)
}
;
void
nsCanvasFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
if
(
GetPrevInFlow
(
)
)
{
DisplayOverflowContainers
(
aBuilder
aLists
)
;
}
if
(
IsVisibleForPainting
(
)
)
{
ComputedStyle
*
bg
=
nullptr
;
nsIFrame
*
dependentFrame
=
nullptr
;
bool
isThemed
=
IsThemed
(
)
;
if
(
!
isThemed
)
{
dependentFrame
=
nsCSSRendering
:
:
FindBackgroundFrame
(
this
)
;
if
(
dependentFrame
)
{
bg
=
dependentFrame
-
>
Style
(
)
;
if
(
dependentFrame
=
=
this
)
{
dependentFrame
=
nullptr
;
}
}
}
if
(
isThemed
)
{
aLists
.
BorderBackground
(
)
-
>
AppendNewToTop
<
nsDisplayCanvasThemedBackground
>
(
aBuilder
this
)
;
return
;
}
if
(
!
bg
)
{
return
;
}
const
ActiveScrolledRoot
*
asr
=
aBuilder
-
>
CurrentActiveScrolledRoot
(
)
;
bool
needBlendContainer
=
false
;
nsDisplayListBuilder
:
:
AutoContainerASRTracker
contASRTracker
(
aBuilder
)
;
const
bool
suppressBackgroundImage
=
[
&
]
{
if
(
!
ComputeShouldPaintBackground
(
)
.
mImage
)
{
return
true
;
}
if
(
PresContext
(
)
-
>
ForcingColors
(
)
&
&
StaticPrefs
:
:
browser_display_suppress_canvas_background_image_on_forced_colors
(
)
)
{
return
true
;
}
return
false
;
}
(
)
;
nsDisplayList
layerItems
(
aBuilder
)
;
const
nsStyleImageLayers
&
layers
=
bg
-
>
StyleBackground
(
)
-
>
mImage
;
NS_FOR_VISIBLE_IMAGE_LAYERS_BACK_TO_FRONT
(
i
layers
)
{
if
(
layers
.
mLayers
[
i
]
.
mImage
.
IsNone
(
)
|
|
suppressBackgroundImage
)
{
continue
;
}
if
(
layers
.
mLayers
[
i
]
.
mBlendMode
!
=
StyleBlend
:
:
Normal
)
{
needBlendContainer
=
true
;
}
nsRect
bgRect
=
GetRectRelativeToSelf
(
)
+
aBuilder
-
>
ToReferenceFrame
(
this
)
;
const
ActiveScrolledRoot
*
thisItemASR
=
asr
;
nsDisplayList
thisItemList
(
aBuilder
)
;
nsDisplayBackgroundImage
:
:
InitData
bgData
=
nsDisplayBackgroundImage
:
:
GetInitData
(
aBuilder
this
i
bgRect
bg
)
;
if
(
bgData
.
shouldFixToViewport
)
{
auto
*
displayData
=
aBuilder
-
>
GetCurrentFixedBackgroundDisplayData
(
)
;
nsDisplayListBuilder
:
:
AutoBuildingDisplayList
buildingDisplayList
(
aBuilder
this
aBuilder
-
>
GetVisibleRect
(
)
aBuilder
-
>
GetDirtyRect
(
)
)
;
DisplayListClipState
:
:
AutoSaveRestore
clipState
(
aBuilder
)
;
nsDisplayListBuilder
:
:
AutoCurrentActiveScrolledRootSetter
asrSetter
(
aBuilder
)
;
if
(
displayData
)
{
const
nsPoint
offset
=
GetOffsetTo
(
PresShell
(
)
-
>
GetRootFrame
(
)
)
;
aBuilder
-
>
SetVisibleRect
(
displayData
-
>
mVisibleRect
+
offset
)
;
aBuilder
-
>
SetDirtyRect
(
displayData
-
>
mDirtyRect
+
offset
)
;
clipState
.
SetClipChainForContainingBlockDescendants
(
displayData
-
>
mContainingBlockClipChain
)
;
asrSetter
.
SetCurrentActiveScrolledRoot
(
displayData
-
>
mContainingBlockActiveScrolledRoot
)
;
asrSetter
.
SetCurrentScrollParentId
(
displayData
-
>
mScrollParentId
)
;
thisItemASR
=
displayData
-
>
mContainingBlockActiveScrolledRoot
;
}
nsDisplayCanvasBackgroundImage
*
bgItem
=
nullptr
;
{
DisplayListClipState
:
:
AutoSaveRestore
bgImageClip
(
aBuilder
)
;
bgImageClip
.
Clear
(
)
;
bgItem
=
MakeDisplayItemWithIndex
<
nsDisplayCanvasBackgroundImage
>
(
aBuilder
this
i
bgData
)
;
if
(
bgItem
)
{
bgItem
-
>
SetDependentFrame
(
aBuilder
dependentFrame
)
;
}
}
if
(
bgItem
)
{
thisItemList
.
AppendToTop
(
nsDisplayFixedPosition
:
:
CreateForFixedBackground
(
aBuilder
this
nullptr
bgItem
i
asr
)
)
;
}
}
else
{
nsDisplayCanvasBackgroundImage
*
bgItem
=
MakeDisplayItemWithIndex
<
nsDisplayCanvasBackgroundImage
>
(
aBuilder
this
i
bgData
)
;
if
(
bgItem
)
{
bgItem
-
>
SetDependentFrame
(
aBuilder
dependentFrame
)
;
thisItemList
.
AppendToTop
(
bgItem
)
;
}
}
if
(
layers
.
mLayers
[
i
]
.
mBlendMode
!
=
StyleBlend
:
:
Normal
)
{
DisplayListClipState
:
:
AutoSaveRestore
blendClip
(
aBuilder
)
;
thisItemList
.
AppendNewToTopWithIndex
<
nsDisplayBlendMode
>
(
aBuilder
this
i
+
1
&
thisItemList
layers
.
mLayers
[
i
]
.
mBlendMode
thisItemASR
true
)
;
}
layerItems
.
AppendToTop
(
&
thisItemList
)
;
}
bool
hasFixedBottomLayer
=
layers
.
mImageCount
>
0
&
&
layers
.
mLayers
[
0
]
.
mAttachment
=
=
StyleImageLayerAttachment
:
:
Fixed
;
nsDisplayList
list
(
aBuilder
)
;
if
(
!
hasFixedBottomLayer
|
|
needBlendContainer
)
{
list
.
AppendNewToTop
<
nsDisplayCanvasBackgroundColor
>
(
aBuilder
this
)
;
}
list
.
AppendToTop
(
&
layerItems
)
;
if
(
needBlendContainer
)
{
const
ActiveScrolledRoot
*
containerASR
=
contASRTracker
.
GetContainerASR
(
)
;
DisplayListClipState
:
:
AutoSaveRestore
blendContainerClip
(
aBuilder
)
;
list
.
AppendToTop
(
nsDisplayBlendContainer
:
:
CreateForBackgroundBlendMode
(
aBuilder
this
nullptr
&
list
containerASR
)
)
;
}
aLists
.
BorderBackground
(
)
-
>
AppendToTop
(
&
list
)
;
}
for
(
nsIFrame
*
kid
:
PrincipalChildList
(
)
)
{
BuildDisplayListForChild
(
aBuilder
kid
aLists
)
;
}
if
(
!
mDoPaintFocus
)
return
;
if
(
!
StyleVisibility
(
)
-
>
IsVisible
(
)
)
return
;
aLists
.
Outlines
(
)
-
>
AppendNewToTop
<
nsDisplayCanvasFocus
>
(
aBuilder
this
)
;
}
void
nsCanvasFrame
:
:
PaintFocus
(
DrawTarget
*
aDrawTarget
nsPoint
aPt
)
{
nsRect
focusRect
(
aPt
GetSize
(
)
)
;
if
(
ScrollContainerFrame
*
scrollContainerFrame
=
do_QueryFrame
(
GetParent
(
)
)
)
{
nsRect
portRect
=
scrollContainerFrame
-
>
GetScrollPortRect
(
)
;
focusRect
.
width
=
portRect
.
width
;
focusRect
.
height
=
portRect
.
height
;
focusRect
.
MoveBy
(
scrollContainerFrame
-
>
GetScrollPosition
(
)
)
;
}
nsIFrame
*
root
=
mFrames
.
FirstChild
(
)
;
const
auto
*
text
=
root
?
root
-
>
StyleText
(
)
:
StyleText
(
)
;
nsCSSRendering
:
:
PaintFocus
(
PresContext
(
)
aDrawTarget
focusRect
text
-
>
mColor
.
ToColor
(
)
)
;
}
nscoord
nsCanvasFrame
:
:
IntrinsicISize
(
const
IntrinsicSizeInput
&
aInput
IntrinsicISizeType
aType
)
{
return
mFrames
.
IsEmpty
(
)
?
0
:
mFrames
.
FirstChild
(
)
-
>
IntrinsicISize
(
aInput
aType
)
;
}
void
nsCanvasFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsCanvasFrame
"
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
NS_FRAME_TRACE_REFLOW_IN
(
"
nsCanvasFrame
:
:
Reflow
"
)
;
nsCanvasFrame
*
prevCanvasFrame
=
static_cast
<
nsCanvasFrame
*
>
(
GetPrevInFlow
(
)
)
;
if
(
prevCanvasFrame
)
{
AutoFrameListPtr
overflow
(
aPresContext
prevCanvasFrame
-
>
StealOverflowFrames
(
)
)
;
if
(
overflow
)
{
NS_ASSERTION
(
overflow
-
>
OnlyChild
(
)
"
must
have
doc
root
as
canvas
frame
'
s
only
child
"
)
;
nsContainerFrame
:
:
ReparentFrameViewList
(
*
overflow
prevCanvasFrame
this
)
;
mFrames
.
InsertFrames
(
this
nullptr
std
:
:
move
(
*
overflow
)
)
;
}
}
SetSize
(
aReflowInput
.
ComputedPhysicalSize
(
)
)
;
const
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
aDesiredSize
.
SetSize
(
wm
aReflowInput
.
ComputedSize
(
)
)
;
if
(
aReflowInput
.
ComputedBSize
(
)
=
=
NS_UNCONSTRAINEDSIZE
)
{
aDesiredSize
.
BSize
(
wm
)
=
nscoord
(
0
)
;
}
aDesiredSize
.
SetOverflowAreasToDesiredBounds
(
)
;
nsIFrame
*
nextKid
=
nullptr
;
for
(
auto
*
kidFrame
=
mFrames
.
FirstChild
(
)
;
kidFrame
;
kidFrame
=
nextKid
)
{
nextKid
=
kidFrame
-
>
GetNextSibling
(
)
;
ReflowOutput
kidDesiredSize
(
aReflowInput
)
;
bool
kidDirty
=
kidFrame
-
>
HasAnyStateBits
(
NS_FRAME_IS_DIRTY
)
;
WritingMode
kidWM
=
kidFrame
-
>
GetWritingMode
(
)
;
auto
availableSize
=
aReflowInput
.
AvailableSize
(
kidWM
)
;
nscoord
bOffset
=
0
;
nscoord
canvasBSizeSum
=
0
;
if
(
prevCanvasFrame
&
&
availableSize
.
BSize
(
kidWM
)
!
=
NS_UNCONSTRAINEDSIZE
&
&
!
kidFrame
-
>
IsPlaceholderFrame
(
)
&
&
StaticPrefs
:
:
layout_display_list_improve_fragmentation
(
)
)
{
for
(
auto
*
pif
=
prevCanvasFrame
;
pif
;
pif
=
static_cast
<
nsCanvasFrame
*
>
(
pif
-
>
GetPrevInFlow
(
)
)
)
{
canvasBSizeSum
+
=
pif
-
>
BSize
(
kidWM
)
;
auto
*
pifChild
=
pif
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
pifChild
)
{
nscoord
layoutOverflow
=
pifChild
-
>
BSize
(
kidWM
)
-
canvasBSizeSum
;
if
(
layoutOverflow
<
0
)
{
LogicalRect
so
(
kidWM
pifChild
-
>
ScrollableOverflowRect
(
)
pifChild
-
>
GetSize
(
)
)
;
layoutOverflow
=
so
.
BEnd
(
kidWM
)
-
canvasBSizeSum
;
}
bOffset
=
std
:
:
max
(
bOffset
layoutOverflow
)
;
}
}
availableSize
.
BSize
(
kidWM
)
-
=
bOffset
;
}
if
(
MOZ_LIKELY
(
availableSize
.
BSize
(
kidWM
)
>
0
)
)
{
ReflowInput
kidReflowInput
(
aPresContext
aReflowInput
kidFrame
availableSize
)
;
if
(
aReflowInput
.
IsBResizeForWM
(
kidReflowInput
.
GetWritingMode
(
)
)
&
&
kidFrame
-
>
HasAnyStateBits
(
NS_FRAME_CONTAINS_RELATIVE_BSIZE
)
)
{
kidReflowInput
.
SetBResize
(
true
)
;
}
nsSize
containerSize
=
aReflowInput
.
ComputedPhysicalSize
(
)
;
LogicalMargin
margin
=
kidReflowInput
.
ComputedLogicalMargin
(
kidWM
)
;
LogicalPoint
kidPt
(
kidWM
margin
.
IStart
(
kidWM
)
margin
.
BStart
(
kidWM
)
)
;
(
kidWM
.
IsOrthogonalTo
(
wm
)
?
kidPt
.
I
(
kidWM
)
:
kidPt
.
B
(
kidWM
)
)
+
=
bOffset
;
nsReflowStatus
kidStatus
;
ReflowChild
(
kidFrame
aPresContext
kidDesiredSize
kidReflowInput
kidWM
kidPt
containerSize
ReflowChildFlags
:
:
Default
kidStatus
)
;
FinishReflowChild
(
kidFrame
aPresContext
kidDesiredSize
&
kidReflowInput
kidWM
kidPt
containerSize
ReflowChildFlags
:
:
ApplyRelativePositioning
)
;
if
(
!
kidStatus
.
IsFullyComplete
(
)
)
{
nsIFrame
*
nextFrame
=
kidFrame
-
>
GetNextInFlow
(
)
;
NS_ASSERTION
(
nextFrame
|
|
kidStatus
.
NextInFlowNeedsReflow
(
)
"
If
it
'
s
incomplete
and
has
no
nif
yet
it
must
flag
a
"
"
nif
reflow
.
"
)
;
if
(
!
nextFrame
)
{
nextFrame
=
aPresContext
-
>
PresShell
(
)
-
>
FrameConstructor
(
)
-
>
CreateContinuingFrame
(
kidFrame
this
)
;
SetOverflowFrames
(
nsFrameList
(
nextFrame
nextFrame
)
)
;
}
if
(
kidStatus
.
IsOverflowIncomplete
(
)
)
{
nextFrame
-
>
AddStateBits
(
NS_FRAME_IS_OVERFLOW_CONTAINER
)
;
}
}
aStatus
.
MergeCompletionStatusFrom
(
kidStatus
)
;
if
(
kidDirty
)
{
nsIFrame
*
viewport
=
PresShell
(
)
-
>
GetRootFrame
(
)
;
viewport
-
>
InvalidateFrame
(
)
;
}
if
(
aReflowInput
.
ComputedBSize
(
)
=
=
NS_UNCONSTRAINEDSIZE
&
&
!
kidFrame
-
>
IsPlaceholderFrame
(
)
)
{
LogicalSize
finalSize
=
aReflowInput
.
ComputedSize
(
)
;
finalSize
.
BSize
(
wm
)
=
nsPresContext
:
:
RoundUpAppUnitsToCSSPixel
(
kidFrame
-
>
GetLogicalSize
(
wm
)
.
BSize
(
wm
)
+
kidReflowInput
.
ComputedLogicalMargin
(
wm
)
.
BStartEnd
(
wm
)
)
;
aDesiredSize
.
SetSize
(
wm
finalSize
)
;
aDesiredSize
.
SetOverflowAreasToDesiredBounds
(
)
;
}
aDesiredSize
.
mOverflowAreas
.
UnionWith
(
kidDesiredSize
.
mOverflowAreas
+
kidFrame
-
>
GetPosition
(
)
)
;
}
else
if
(
kidFrame
-
>
IsPlaceholderFrame
(
)
)
{
}
else
{
mFrames
.
RemoveFrame
(
kidFrame
)
;
SetOverflowFrames
(
nsFrameList
(
kidFrame
kidFrame
)
)
;
aStatus
.
SetIncomplete
(
)
;
}
}
if
(
prevCanvasFrame
)
{
ReflowOverflowContainerChildren
(
aPresContext
aReflowInput
aDesiredSize
.
mOverflowAreas
ReflowChildFlags
:
:
Default
aStatus
)
;
}
FinishReflowWithAbsoluteFrames
(
aPresContext
aDesiredSize
aReflowInput
aStatus
)
;
NS_FRAME_TRACE_REFLOW_OUT
(
"
nsCanvasFrame
:
:
Reflow
"
aStatus
)
;
}
nsresult
nsCanvasFrame
:
:
GetContentForEvent
(
const
WidgetEvent
*
aEvent
nsIContent
*
*
aContent
)
{
NS_ENSURE_ARG_POINTER
(
aContent
)
;
nsresult
rv
=
nsIFrame
:
:
GetContentForEvent
(
aEvent
aContent
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
*
aContent
)
{
nsIFrame
*
kid
=
mFrames
.
FirstChild
(
)
;
if
(
kid
)
{
rv
=
kid
-
>
GetContentForEvent
(
aEvent
aContent
)
;
}
}
return
rv
;
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
nsCanvasFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
u
"
Canvas
"
_ns
aResult
)
;
}
#
endif
