#
include
"
nsCanvasFrame
.
h
"
#
include
"
AccessibleCaretEventHub
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsCSSRendering
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsStyleContext
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
nsFrameManager
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
mozilla
/
dom
/
AnonymousContent
.
h
"
#
include
"
mozilla
/
layers
/
StackingContextHelper
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderLayerManager
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
ifdef
DEBUG_CANVAS_FOCUS
#
include
"
nsIDocShell
.
h
"
#
endif
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
layout
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
layers
;
nsCanvasFrame
*
NS_NewCanvasFrame
(
nsIPresShell
*
aPresShell
nsStyleContext
*
aContext
)
{
return
new
(
aPresShell
)
nsCanvasFrame
(
aContext
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsCanvasFrame
)
NS_QUERYFRAME_HEAD
(
nsCanvasFrame
)
NS_QUERYFRAME_ENTRY
(
nsCanvasFrame
)
NS_QUERYFRAME_ENTRY
(
nsIAnonymousContentCreator
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsContainerFrame
)
void
nsCanvasFrame
:
:
ShowCustomContentContainer
(
)
{
if
(
mCustomContentContainer
)
{
mCustomContentContainer
-
>
UnsetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
hidden
true
)
;
}
}
void
nsCanvasFrame
:
:
HideCustomContentContainer
(
)
{
if
(
mCustomContentContainer
)
{
mCustomContentContainer
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
hidden
NS_LITERAL_STRING
(
"
true
"
)
true
)
;
}
}
nsresult
nsCanvasFrame
:
:
CreateAnonymousContent
(
nsTArray
<
ContentInfo
>
&
aElements
)
{
if
(
!
mContent
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIDocument
>
doc
=
mContent
-
>
OwnerDoc
(
)
;
nsresult
rv
=
NS_OK
;
mCustomContentContainer
=
doc
-
>
CreateHTMLElement
(
nsGkAtoms
:
:
div
)
;
#
ifdef
DEBUG
mCustomContentContainer
-
>
SetProperty
(
nsGkAtoms
:
:
restylableAnonymousNode
reinterpret_cast
<
void
*
>
(
true
)
)
;
#
endif
aElements
.
AppendElement
(
mCustomContentContainer
)
;
rv
=
mCustomContentContainer
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_class
NS_LITERAL_STRING
(
"
moz
-
custom
-
content
-
container
"
)
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
size_t
len
=
doc
-
>
GetAnonymousContents
(
)
.
Length
(
)
;
for
(
size_t
i
=
0
;
i
<
len
;
+
+
i
)
{
nsCOMPtr
<
Element
>
node
=
doc
-
>
GetAnonymousContents
(
)
[
i
]
-
>
GetContentNode
(
)
;
mCustomContentContainer
-
>
AppendChildTo
(
node
-
>
AsContent
(
)
true
)
;
}
if
(
len
=
=
0
)
{
HideCustomContentContainer
(
)
;
}
RefPtr
<
AccessibleCaretEventHub
>
eventHub
=
PresContext
(
)
-
>
GetPresShell
(
)
-
>
GetAccessibleCaretEventHub
(
)
;
if
(
eventHub
)
{
eventHub
-
>
Init
(
)
;
}
return
NS_OK
;
}
void
nsCanvasFrame
:
:
AppendAnonymousContentTo
(
nsTArray
<
nsIContent
*
>
&
aElements
uint32_t
aFilter
)
{
if
(
mCustomContentContainer
)
{
aElements
.
AppendElement
(
mCustomContentContainer
)
;
}
}
void
nsCanvasFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestructRoot
)
{
nsIScrollableFrame
*
sf
=
PresContext
(
)
-
>
GetPresShell
(
)
-
>
GetRootScrollFrameAsScrollable
(
)
;
if
(
sf
)
{
sf
-
>
RemoveScrollPositionListener
(
this
)
;
}
if
(
mCustomContentContainer
)
{
nsCOMPtr
<
nsIDocument
>
doc
=
mContent
-
>
OwnerDoc
(
)
;
ErrorResult
rv
;
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
AnonymousContent
>
>
&
docAnonContents
=
doc
-
>
GetAnonymousContents
(
)
;
for
(
size_t
i
=
0
len
=
docAnonContents
.
Length
(
)
;
i
<
len
;
+
+
i
)
{
AnonymousContent
*
content
=
docAnonContents
[
i
]
;
nsCOMPtr
<
nsINode
>
clonedElement
=
content
-
>
GetContentNode
(
)
-
>
CloneNode
(
true
rv
)
;
content
-
>
SetContentNode
(
clonedElement
-
>
AsElement
(
)
)
;
}
}
DestroyAnonymousContent
(
mCustomContentContainer
.
forget
(
)
)
;
nsContainerFrame
:
:
DestroyFrom
(
aDestructRoot
)
;
}
void
nsCanvasFrame
:
:
ScrollPositionWillChange
(
nscoord
aX
nscoord
aY
)
{
if
(
mDoPaintFocus
)
{
mDoPaintFocus
=
false
;
PresContext
(
)
-
>
FrameManager
(
)
-
>
GetRootFrame
(
)
-
>
InvalidateFrameSubtree
(
)
;
}
}
NS_IMETHODIMP
nsCanvasFrame
:
:
SetHasFocus
(
bool
aHasFocus
)
{
if
(
mDoPaintFocus
!
=
aHasFocus
)
{
mDoPaintFocus
=
aHasFocus
;
PresContext
(
)
-
>
FrameManager
(
)
-
>
GetRootFrame
(
)
-
>
InvalidateFrameSubtree
(
)
;
if
(
!
mAddedScrollPositionListener
)
{
nsIScrollableFrame
*
sf
=
PresContext
(
)
-
>
GetPresShell
(
)
-
>
GetRootScrollFrameAsScrollable
(
)
;
if
(
sf
)
{
sf
-
>
AddScrollPositionListener
(
this
)
;
mAddedScrollPositionListener
=
true
;
}
}
}
return
NS_OK
;
}
void
nsCanvasFrame
:
:
SetInitialChildList
(
ChildListID
aListID
nsFrameList
&
aChildList
)
{
NS_ASSERTION
(
aListID
!
=
kPrincipalList
|
|
aChildList
.
IsEmpty
(
)
|
|
aChildList
.
OnlyChild
(
)
"
Primary
child
list
can
have
at
most
one
frame
in
it
"
)
;
nsContainerFrame
:
:
SetInitialChildList
(
aListID
aChildList
)
;
MaybePropagateRootElementWritingMode
(
)
;
}
void
nsCanvasFrame
:
:
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
aListID
=
=
kPrincipalList
"
unexpected
child
list
"
)
;
if
(
!
mFrames
.
IsEmpty
(
)
)
{
for
(
nsFrameList
:
:
Enumerator
e
(
aFrameList
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
)
{
MOZ_ASSERT
(
e
.
get
(
)
-
>
GetContent
(
)
-
>
IsInNativeAnonymousSubtree
(
)
"
invalid
child
list
"
)
;
}
}
nsFrame
:
:
VerifyDirtyBitSet
(
aFrameList
)
;
#
endif
nsContainerFrame
:
:
AppendFrames
(
aListID
aFrameList
)
;
MaybePropagateRootElementWritingMode
(
)
;
}
void
nsCanvasFrame
:
:
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
aFrameList
)
{
MOZ_ASSERT
(
!
aPrevFrame
"
unexpected
previous
sibling
frame
"
)
;
AppendFrames
(
aListID
aFrameList
)
;
MaybePropagateRootElementWritingMode
(
)
;
}
#
ifdef
DEBUG
void
nsCanvasFrame
:
:
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
{
MOZ_ASSERT
(
aListID
=
=
kPrincipalList
"
unexpected
child
list
"
)
;
nsContainerFrame
:
:
RemoveFrame
(
aListID
aOldFrame
)
;
}
#
endif
nsRect
nsCanvasFrame
:
:
CanvasArea
(
)
const
{
nsRect
result
(
GetVisualOverflowRect
(
)
)
;
nsIScrollableFrame
*
scrollableFrame
=
do_QueryFrame
(
GetParent
(
)
)
;
if
(
scrollableFrame
)
{
nsRect
portRect
=
scrollableFrame
-
>
GetScrollPortRect
(
)
;
result
.
UnionRect
(
result
nsRect
(
nsPoint
(
0
0
)
portRect
.
Size
(
)
)
)
;
}
return
result
;
}
void
nsDisplayCanvasBackgroundColor
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
nsCanvasFrame
*
frame
=
static_cast
<
nsCanvasFrame
*
>
(
mFrame
)
;
nsPoint
offset
=
ToReferenceFrame
(
)
;
nsRect
bgClipRect
=
frame
-
>
CanvasArea
(
)
+
offset
;
if
(
NS_GET_A
(
mColor
)
>
0
)
{
DrawTarget
*
drawTarget
=
aCtx
-
>
GetDrawTarget
(
)
;
int32_t
appUnitsPerDevPixel
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
Rect
devPxRect
=
NSRectToSnappedRect
(
bgClipRect
appUnitsPerDevPixel
*
drawTarget
)
;
drawTarget
-
>
FillRect
(
devPxRect
ColorPattern
(
ToDeviceColor
(
mColor
)
)
)
;
}
}
already_AddRefed
<
Layer
>
nsDisplayCanvasBackgroundColor
:
:
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
{
if
(
NS_GET_A
(
mColor
)
=
=
0
)
{
return
nullptr
;
}
if
(
aManager
-
>
GetBackendType
(
)
=
=
layers
:
:
LayersBackend
:
:
LAYERS_WR
)
{
return
BuildDisplayItemLayer
(
aBuilder
aManager
aContainerParameters
)
;
}
RefPtr
<
ColorLayer
>
layer
=
static_cast
<
ColorLayer
*
>
(
aManager
-
>
GetLayerBuilder
(
)
-
>
GetLeafLayerFor
(
aBuilder
this
)
)
;
if
(
!
layer
)
{
layer
=
aManager
-
>
CreateColorLayer
(
)
;
if
(
!
layer
)
{
return
nullptr
;
}
}
layer
-
>
SetColor
(
ToDeviceColor
(
mColor
)
)
;
nsCanvasFrame
*
frame
=
static_cast
<
nsCanvasFrame
*
>
(
mFrame
)
;
nsPoint
offset
=
ToReferenceFrame
(
)
;
nsRect
bgClipRect
=
frame
-
>
CanvasArea
(
)
+
offset
;
int32_t
appUnitsPerDevPixel
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
layer
-
>
SetBounds
(
bgClipRect
.
ToNearestPixels
(
appUnitsPerDevPixel
)
)
;
layer
-
>
SetBaseTransform
(
gfx
:
:
Matrix4x4
:
:
Translation
(
aContainerParameters
.
mOffset
.
x
aContainerParameters
.
mOffset
.
y
0
)
)
;
return
layer
.
forget
(
)
;
}
bool
nsDisplayCanvasBackgroundColor
:
:
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
WebRenderLayerManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
ContainerLayerParameters
parameter
;
if
(
GetLayerState
(
aDisplayListBuilder
aManager
parameter
)
!
=
LAYER_ACTIVE
)
{
return
false
;
}
nsCanvasFrame
*
frame
=
static_cast
<
nsCanvasFrame
*
>
(
mFrame
)
;
nsPoint
offset
=
ToReferenceFrame
(
)
;
nsRect
bgClipRect
=
frame
-
>
CanvasArea
(
)
+
offset
;
int32_t
appUnitsPerDevPixel
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
LayoutDeviceRect
rect
=
LayoutDeviceRect
:
:
FromAppUnits
(
bgClipRect
appUnitsPerDevPixel
)
;
wr
:
:
LayoutRect
transformedRect
=
aSc
.
ToRelativeLayoutRect
(
rect
)
;
aBuilder
.
PushRect
(
transformedRect
transformedRect
!
BackfaceIsHidden
(
)
wr
:
:
ToColorF
(
ToDeviceColor
(
mColor
)
)
)
;
return
true
;
}
#
ifdef
MOZ_DUMP_PAINTING
void
nsDisplayCanvasBackgroundColor
:
:
WriteDebugInfo
(
std
:
:
stringstream
&
aStream
)
{
aStream
<
<
"
(
rgba
"
<
<
(
int
)
NS_GET_R
(
mColor
)
<
<
"
"
<
<
(
int
)
NS_GET_G
(
mColor
)
<
<
"
"
<
<
(
int
)
NS_GET_B
(
mColor
)
<
<
"
"
<
<
(
int
)
NS_GET_A
(
mColor
)
<
<
"
)
"
;
}
#
endif
#
ifndef
MOZ_GFX_OPTIMIZE_MOBILE
static
void
BlitSurface
(
DrawTarget
*
aDest
const
gfxRect
&
aRect
DrawTarget
*
aSource
)
{
RefPtr
<
SourceSurface
>
source
=
aSource
-
>
Snapshot
(
)
;
aDest
-
>
DrawSurface
(
source
Rect
(
aRect
.
x
aRect
.
y
aRect
.
width
aRect
.
height
)
Rect
(
0
0
aRect
.
width
aRect
.
height
)
)
;
}
#
endif
void
nsDisplayCanvasBackgroundImage
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
nsCanvasFrame
*
frame
=
static_cast
<
nsCanvasFrame
*
>
(
mFrame
)
;
nsPoint
offset
=
ToReferenceFrame
(
)
;
nsRect
bgClipRect
=
frame
-
>
CanvasArea
(
)
+
offset
;
#
ifndef
MOZ_GFX_OPTIMIZE_MOBILE
RefPtr
<
gfxContext
>
dest
=
aCtx
;
gfxRect
destRect
;
if
(
IsSingleFixedPositionImage
(
aBuilder
bgClipRect
&
destRect
)
&
&
aBuilder
-
>
IsPaintingToWindow
(
)
&
&
!
aBuilder
-
>
IsCompositingCheap
(
)
&
&
!
dest
-
>
CurrentMatrix
(
)
.
HasNonIntegerTranslation
(
)
)
{
destRect
.
Round
(
)
;
RefPtr
<
DrawTarget
>
dt
=
Frame
(
)
-
>
GetProperty
(
nsIFrame
:
:
CachedBackgroundImageDT
(
)
)
;
DrawTarget
*
destDT
=
dest
-
>
GetDrawTarget
(
)
;
if
(
dt
)
{
BlitSurface
(
destDT
destRect
dt
)
;
return
;
}
dt
=
destDT
-
>
CreateSimilarDrawTarget
(
IntSize
:
:
Ceil
(
destRect
.
width
destRect
.
height
)
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
dt
&
&
dt
-
>
IsValid
(
)
)
{
RefPtr
<
gfxContext
>
ctx
=
gfxContext
:
:
CreateOrNull
(
dt
)
;
MOZ_ASSERT
(
ctx
)
;
ctx
-
>
SetMatrix
(
ctx
-
>
CurrentMatrix
(
)
.
PreTranslate
(
-
destRect
.
x
-
destRect
.
y
)
)
;
PaintInternal
(
aBuilder
ctx
bgClipRect
&
bgClipRect
)
;
BlitSurface
(
dest
-
>
GetDrawTarget
(
)
destRect
dt
)
;
frame
-
>
SetProperty
(
nsIFrame
:
:
CachedBackgroundImageDT
(
)
dt
.
forget
(
)
.
take
(
)
)
;
return
;
}
}
#
endif
PaintInternal
(
aBuilder
aCtx
mVisibleRect
&
bgClipRect
)
;
}
bool
nsDisplayCanvasBackgroundImage
:
:
IsSingleFixedPositionImage
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aClipRect
gfxRect
*
aDestRect
)
{
if
(
!
mBackgroundStyle
)
return
false
;
if
(
mBackgroundStyle
-
>
mImage
.
mLayers
.
Length
(
)
!
=
1
)
return
false
;
nsPresContext
*
presContext
=
mFrame
-
>
PresContext
(
)
;
uint32_t
flags
=
aBuilder
-
>
GetBackgroundPaintFlags
(
)
;
nsRect
borderArea
=
nsRect
(
ToReferenceFrame
(
)
mFrame
-
>
GetSize
(
)
)
;
const
nsStyleImageLayers
:
:
Layer
&
layer
=
mBackgroundStyle
-
>
mImage
.
mLayers
[
mLayer
]
;
if
(
layer
.
mAttachment
!
=
NS_STYLE_IMAGELAYER_ATTACHMENT_FIXED
)
return
false
;
nsBackgroundLayerState
state
=
nsCSSRendering
:
:
PrepareImageLayer
(
presContext
mFrame
flags
borderArea
aClipRect
layer
)
;
if
(
!
mIsRasterImage
)
return
false
;
int32_t
appUnitsPerDevPixel
=
presContext
-
>
AppUnitsPerDevPixel
(
)
;
*
aDestRect
=
nsLayoutUtils
:
:
RectToGfxRect
(
state
.
mFillArea
appUnitsPerDevPixel
)
;
return
true
;
}
void
nsDisplayCanvasThemedBackground
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
nsCanvasFrame
*
frame
=
static_cast
<
nsCanvasFrame
*
>
(
mFrame
)
;
nsPoint
offset
=
ToReferenceFrame
(
)
;
nsRect
bgClipRect
=
frame
-
>
CanvasArea
(
)
+
offset
;
PaintInternal
(
aBuilder
aCtx
mVisibleRect
&
bgClipRect
)
;
}
class
nsDisplayCanvasFocus
:
public
nsDisplayItem
{
public
:
nsDisplayCanvasFocus
(
nsDisplayListBuilder
*
aBuilder
nsCanvasFrame
*
aFrame
)
:
nsDisplayItem
(
aBuilder
aFrame
)
{
MOZ_COUNT_CTOR
(
nsDisplayCanvasFocus
)
;
}
virtual
~
nsDisplayCanvasFocus
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayCanvasFocus
)
;
}
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
{
*
aSnap
=
false
;
nsCanvasFrame
*
frame
=
static_cast
<
nsCanvasFrame
*
>
(
mFrame
)
;
return
frame
-
>
CanvasArea
(
)
+
ToReferenceFrame
(
)
;
}
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
{
nsCanvasFrame
*
frame
=
static_cast
<
nsCanvasFrame
*
>
(
mFrame
)
;
frame
-
>
PaintFocus
(
aCtx
-
>
GetDrawTarget
(
)
ToReferenceFrame
(
)
)
;
}
NS_DISPLAY_DECL_NAME
(
"
CanvasFocus
"
TYPE_CANVAS_FOCUS
)
}
;
void
nsCanvasFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
if
(
GetPrevInFlow
(
)
)
{
DisplayOverflowContainers
(
aBuilder
aLists
)
;
}
if
(
IsVisibleForPainting
(
aBuilder
)
)
{
nsStyleContext
*
bgSC
;
const
nsStyleBackground
*
bg
=
nullptr
;
bool
isThemed
=
IsThemed
(
)
;
if
(
!
isThemed
&
&
nsCSSRendering
:
:
FindBackground
(
this
&
bgSC
)
)
{
bg
=
bgSC
-
>
StyleBackground
(
)
;
}
aLists
.
BorderBackground
(
)
-
>
AppendNewToTop
(
new
(
aBuilder
)
nsDisplayCanvasBackgroundColor
(
aBuilder
this
)
)
;
if
(
isThemed
)
{
aLists
.
BorderBackground
(
)
-
>
AppendNewToTop
(
new
(
aBuilder
)
nsDisplayCanvasThemedBackground
(
aBuilder
this
)
)
;
return
;
}
if
(
!
bg
)
{
return
;
}
const
ActiveScrolledRoot
*
asr
=
aBuilder
-
>
CurrentActiveScrolledRoot
(
)
;
bool
needBlendContainer
=
false
;
nsDisplayListBuilder
:
:
AutoContainerASRTracker
contASRTracker
(
aBuilder
)
;
const
nsStyleImageLayers
&
layers
=
bg
-
>
mImage
;
NS_FOR_VISIBLE_IMAGE_LAYERS_BACK_TO_FRONT
(
i
layers
)
{
if
(
layers
.
mLayers
[
i
]
.
mImage
.
IsEmpty
(
)
)
{
continue
;
}
if
(
layers
.
mLayers
[
i
]
.
mBlendMode
!
=
NS_STYLE_BLEND_NORMAL
)
{
needBlendContainer
=
true
;
}
nsRect
bgRect
=
GetRectRelativeToSelf
(
)
+
aBuilder
-
>
ToReferenceFrame
(
this
)
;
const
ActiveScrolledRoot
*
thisItemASR
=
asr
;
nsDisplayList
thisItemList
;
nsDisplayBackgroundImage
:
:
InitData
bgData
=
nsDisplayBackgroundImage
:
:
GetInitData
(
aBuilder
this
i
bgRect
bg
nsDisplayBackgroundImage
:
:
LayerizeFixed
:
:
ALWAYS_LAYERIZE_FIXED_BACKGROUND
)
;
if
(
bgData
.
shouldFixToViewport
)
{
auto
*
displayData
=
aBuilder
-
>
GetCurrentFixedBackgroundDisplayData
(
)
;
nsDisplayListBuilder
:
:
AutoBuildingDisplayList
buildingDisplayList
(
aBuilder
this
aBuilder
-
>
GetDirtyRect
(
)
false
)
;
DisplayListClipState
:
:
AutoSaveRestore
clipState
(
aBuilder
)
;
nsDisplayListBuilder
:
:
AutoCurrentActiveScrolledRootSetter
asrSetter
(
aBuilder
)
;
if
(
displayData
)
{
nsPoint
offset
=
GetOffsetTo
(
PresContext
(
)
-
>
GetPresShell
(
)
-
>
GetRootFrame
(
)
)
;
aBuilder
-
>
SetDirtyRect
(
displayData
-
>
mDirtyRect
+
offset
)
;
clipState
.
SetClipChainForContainingBlockDescendants
(
displayData
-
>
mContainingBlockClipChain
)
;
asrSetter
.
SetCurrentActiveScrolledRoot
(
displayData
-
>
mContainingBlockActiveScrolledRoot
)
;
thisItemASR
=
displayData
-
>
mContainingBlockActiveScrolledRoot
;
}
nsDisplayCanvasBackgroundImage
*
bgItem
=
nullptr
;
{
DisplayListClipState
:
:
AutoSaveRestore
bgImageClip
(
aBuilder
)
;
bgImageClip
.
Clear
(
)
;
bgItem
=
new
(
aBuilder
)
nsDisplayCanvasBackgroundImage
(
bgData
)
;
}
thisItemList
.
AppendNewToTop
(
nsDisplayFixedPosition
:
:
CreateForFixedBackground
(
aBuilder
this
bgItem
i
)
)
;
}
else
{
thisItemList
.
AppendNewToTop
(
new
(
aBuilder
)
nsDisplayCanvasBackgroundImage
(
bgData
)
)
;
}
if
(
layers
.
mLayers
[
i
]
.
mBlendMode
!
=
NS_STYLE_BLEND_NORMAL
)
{
DisplayListClipState
:
:
AutoSaveRestore
blendClip
(
aBuilder
)
;
blendClip
.
ClearUpToASR
(
thisItemASR
)
;
thisItemList
.
AppendNewToTop
(
new
(
aBuilder
)
nsDisplayBlendMode
(
aBuilder
this
&
thisItemList
layers
.
mLayers
[
i
]
.
mBlendMode
thisItemASR
i
+
1
)
)
;
}
aLists
.
BorderBackground
(
)
-
>
AppendToTop
(
&
thisItemList
)
;
}
if
(
needBlendContainer
)
{
const
ActiveScrolledRoot
*
containerASR
=
contASRTracker
.
GetContainerASR
(
)
;
DisplayListClipState
:
:
AutoSaveRestore
blendContainerClip
(
aBuilder
)
;
blendContainerClip
.
ClearUpToASR
(
containerASR
)
;
aLists
.
BorderBackground
(
)
-
>
AppendNewToTop
(
nsDisplayBlendContainer
:
:
CreateForBackgroundBlendMode
(
aBuilder
this
aLists
.
BorderBackground
(
)
containerASR
)
)
;
}
}
for
(
nsIFrame
*
kid
:
PrincipalChildList
(
)
)
{
BuildDisplayListForChild
(
aBuilder
kid
aLists
)
;
}
#
ifdef
DEBUG_CANVAS_FOCUS
nsCOMPtr
<
nsIContent
>
focusContent
;
aPresContext
-
>
EventStateManager
(
)
-
>
GetFocusedContent
(
getter_AddRefs
(
focusContent
)
)
;
bool
hasFocus
=
false
;
nsCOMPtr
<
nsISupports
>
container
;
aPresContext
-
>
GetContainer
(
getter_AddRefs
(
container
)
)
;
nsCOMPtr
<
nsIDocShell
>
docShell
(
do_QueryInterface
(
container
)
)
;
if
(
docShell
)
{
docShell
-
>
GetHasFocus
(
&
hasFocus
)
;
nsRect
dirty
=
aBuilder
-
>
GetDirtyRect
(
)
;
printf
(
"
%
p
-
nsCanvasFrame
:
:
Paint
R
:
%
d
%
d
%
d
%
d
DR
:
%
d
%
d
%
d
%
d
\
n
"
this
mRect
.
x
mRect
.
y
mRect
.
width
mRect
.
height
dirty
.
x
dirty
.
y
dirty
.
width
dirty
.
height
)
;
}
printf
(
"
%
p
-
Focus
:
%
s
c
:
%
p
DoPaint
:
%
s
\
n
"
docShell
.
get
(
)
hasFocus
?
"
Y
"
:
"
N
"
focusContent
.
get
(
)
mDoPaintFocus
?
"
Y
"
:
"
N
"
)
;
#
endif
if
(
!
mDoPaintFocus
)
return
;
if
(
!
StyleVisibility
(
)
-
>
IsVisible
(
)
)
return
;
aLists
.
Outlines
(
)
-
>
AppendNewToTop
(
new
(
aBuilder
)
nsDisplayCanvasFocus
(
aBuilder
this
)
)
;
}
void
nsCanvasFrame
:
:
PaintFocus
(
DrawTarget
*
aDrawTarget
nsPoint
aPt
)
{
nsRect
focusRect
(
aPt
GetSize
(
)
)
;
nsIScrollableFrame
*
scrollableFrame
=
do_QueryFrame
(
GetParent
(
)
)
;
if
(
scrollableFrame
)
{
nsRect
portRect
=
scrollableFrame
-
>
GetScrollPortRect
(
)
;
focusRect
.
width
=
portRect
.
width
;
focusRect
.
height
=
portRect
.
height
;
focusRect
.
MoveBy
(
scrollableFrame
-
>
GetScrollPosition
(
)
)
;
}
nsIFrame
*
root
=
mFrames
.
FirstChild
(
)
;
const
nsStyleColor
*
color
=
root
?
root
-
>
StyleColor
(
)
:
StyleColor
(
)
;
if
(
!
color
)
{
NS_ERROR
(
"
current
color
cannot
be
found
"
)
;
return
;
}
nsCSSRendering
:
:
PaintFocus
(
PresContext
(
)
aDrawTarget
focusRect
color
-
>
mColor
)
;
}
nscoord
nsCanvasFrame
:
:
GetMinISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
result
;
DISPLAY_MIN_WIDTH
(
this
result
)
;
if
(
mFrames
.
IsEmpty
(
)
)
result
=
0
;
else
result
=
mFrames
.
FirstChild
(
)
-
>
GetMinISize
(
aRenderingContext
)
;
return
result
;
}
nscoord
nsCanvasFrame
:
:
GetPrefISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
result
;
DISPLAY_PREF_WIDTH
(
this
result
)
;
if
(
mFrames
.
IsEmpty
(
)
)
result
=
0
;
else
result
=
mFrames
.
FirstChild
(
)
-
>
GetPrefISize
(
aRenderingContext
)
;
return
result
;
}
void
nsCanvasFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsCanvasFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aDesiredSize
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
NS_FRAME_TRACE_REFLOW_IN
(
"
nsCanvasFrame
:
:
Reflow
"
)
;
nsCanvasFrame
*
prevCanvasFrame
=
static_cast
<
nsCanvasFrame
*
>
(
GetPrevInFlow
(
)
)
;
if
(
prevCanvasFrame
)
{
AutoFrameListPtr
overflow
(
aPresContext
prevCanvasFrame
-
>
StealOverflowFrames
(
)
)
;
if
(
overflow
)
{
NS_ASSERTION
(
overflow
-
>
OnlyChild
(
)
"
must
have
doc
root
as
canvas
frame
'
s
only
child
"
)
;
nsContainerFrame
:
:
ReparentFrameViewList
(
*
overflow
prevCanvasFrame
this
)
;
mFrames
.
InsertFrames
(
this
nullptr
*
overflow
)
;
}
}
SetSize
(
nsSize
(
aReflowInput
.
ComputedWidth
(
)
aReflowInput
.
ComputedHeight
(
)
)
)
;
ReflowOutput
kidDesiredSize
(
aReflowInput
)
;
if
(
mFrames
.
IsEmpty
(
)
)
{
aDesiredSize
.
Width
(
)
=
aDesiredSize
.
Height
(
)
=
0
;
}
else
{
nsIFrame
*
kidFrame
=
mFrames
.
FirstChild
(
)
;
bool
kidDirty
=
(
kidFrame
-
>
GetStateBits
(
)
&
NS_FRAME_IS_DIRTY
)
!
=
0
;
ReflowInput
kidReflowInput
(
aPresContext
aReflowInput
kidFrame
aReflowInput
.
AvailableSize
(
kidFrame
-
>
GetWritingMode
(
)
)
)
;
if
(
aReflowInput
.
IsBResizeForWM
(
kidReflowInput
.
GetWritingMode
(
)
)
&
&
(
kidFrame
-
>
GetStateBits
(
)
&
NS_FRAME_CONTAINS_RELATIVE_BSIZE
)
)
{
kidReflowInput
.
SetBResize
(
true
)
;
}
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
WritingMode
kidWM
=
kidReflowInput
.
GetWritingMode
(
)
;
nsSize
containerSize
=
aReflowInput
.
ComputedPhysicalSize
(
)
;
LogicalMargin
margin
=
kidReflowInput
.
ComputedLogicalMargin
(
)
;
LogicalPoint
kidPt
(
kidWM
margin
.
IStart
(
kidWM
)
margin
.
BStart
(
kidWM
)
)
;
kidReflowInput
.
ApplyRelativePositioning
(
&
kidPt
containerSize
)
;
ReflowChild
(
kidFrame
aPresContext
kidDesiredSize
kidReflowInput
kidWM
kidPt
containerSize
0
aStatus
)
;
FinishReflowChild
(
kidFrame
aPresContext
kidDesiredSize
&
kidReflowInput
kidWM
kidPt
containerSize
0
)
;
if
(
!
aStatus
.
IsFullyComplete
(
)
)
{
nsIFrame
*
nextFrame
=
kidFrame
-
>
GetNextInFlow
(
)
;
NS_ASSERTION
(
nextFrame
|
|
aStatus
.
NextInFlowNeedsReflow
(
)
"
If
it
'
s
incomplete
and
has
no
nif
yet
it
must
flag
a
nif
reflow
.
"
)
;
if
(
!
nextFrame
)
{
nextFrame
=
aPresContext
-
>
PresShell
(
)
-
>
FrameConstructor
(
)
-
>
CreateContinuingFrame
(
aPresContext
kidFrame
this
)
;
SetOverflowFrames
(
nsFrameList
(
nextFrame
nextFrame
)
)
;
}
if
(
aStatus
.
IsOverflowIncomplete
(
)
)
{
nextFrame
-
>
AddStateBits
(
NS_FRAME_IS_OVERFLOW_CONTAINER
)
;
}
}
if
(
kidDirty
)
{
nsIFrame
*
viewport
=
PresContext
(
)
-
>
GetPresShell
(
)
-
>
GetRootFrame
(
)
;
viewport
-
>
InvalidateFrame
(
)
;
}
LogicalSize
finalSize
(
wm
)
;
finalSize
.
ISize
(
wm
)
=
aReflowInput
.
ComputedISize
(
)
;
if
(
aReflowInput
.
ComputedBSize
(
)
=
=
NS_UNCONSTRAINEDSIZE
)
{
finalSize
.
BSize
(
wm
)
=
kidFrame
-
>
GetLogicalSize
(
wm
)
.
BSize
(
wm
)
+
kidReflowInput
.
ComputedLogicalMargin
(
)
.
BStartEnd
(
wm
)
;
}
else
{
finalSize
.
BSize
(
wm
)
=
aReflowInput
.
ComputedBSize
(
)
;
}
aDesiredSize
.
SetSize
(
wm
finalSize
)
;
aDesiredSize
.
SetOverflowAreasToDesiredBounds
(
)
;
aDesiredSize
.
mOverflowAreas
.
UnionWith
(
kidDesiredSize
.
mOverflowAreas
+
kidFrame
-
>
GetPosition
(
)
)
;
}
if
(
prevCanvasFrame
)
{
ReflowOverflowContainerChildren
(
aPresContext
aReflowInput
aDesiredSize
.
mOverflowAreas
0
aStatus
)
;
}
FinishReflowWithAbsoluteFrames
(
aPresContext
aDesiredSize
aReflowInput
aStatus
)
;
NS_FRAME_TRACE_REFLOW_OUT
(
"
nsCanvasFrame
:
:
Reflow
"
aStatus
)
;
NS_FRAME_SET_TRUNCATION
(
aStatus
aReflowInput
aDesiredSize
)
;
}
nsresult
nsCanvasFrame
:
:
GetContentForEvent
(
WidgetEvent
*
aEvent
nsIContent
*
*
aContent
)
{
NS_ENSURE_ARG_POINTER
(
aContent
)
;
nsresult
rv
=
nsFrame
:
:
GetContentForEvent
(
aEvent
aContent
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
*
aContent
)
{
nsIFrame
*
kid
=
mFrames
.
FirstChild
(
)
;
if
(
kid
)
{
rv
=
kid
-
>
GetContentForEvent
(
aEvent
aContent
)
;
}
}
return
rv
;
}
void
nsCanvasFrame
:
:
MaybePropagateRootElementWritingMode
(
)
{
nsIFrame
*
child
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
child
&
&
child
-
>
GetContent
(
)
&
&
child
-
>
GetContent
(
)
=
=
PresContext
(
)
-
>
Document
(
)
-
>
GetRootElement
(
)
)
{
nsIFrame
*
childPrimary
=
child
-
>
GetContent
(
)
-
>
GetPrimaryFrame
(
)
;
PropagateRootElementWritingMode
(
childPrimary
-
>
GetWritingMode
(
)
)
;
}
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
nsCanvasFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
NS_LITERAL_STRING
(
"
Canvas
"
)
aResult
)
;
}
#
endif
