#
ifndef
nsPluginFrame_h___
#
define
nsPluginFrame_h___
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsIObjectFrame
.
h
"
#
include
"
nsFrame
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsIReflowCallback
.
h
"
#
include
"
Units
.
h
"
#
include
"
mozilla
/
layers
/
StackingContextHelper
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderAPI
.
h
"
#
ifdef
XP_WIN
#
include
<
windows
.
h
>
#
undef
GetMessage
#
undef
CreateEvent
#
undef
GetClassName
#
undef
GetBinaryType
#
undef
RemoveDirectory
#
undef
LoadIcon
#
undef
LoadImage
#
undef
GetObject
#
endif
class
nsPresContext
;
class
nsRootPresContext
;
class
nsDisplayPlugin
;
class
PluginBackgroundSink
;
class
nsPluginInstanceOwner
;
namespace
mozilla
{
namespace
layers
{
class
ImageContainer
;
class
Layer
;
class
LayerManager
;
}
}
class
PluginFrameDidCompositeObserver
;
class
nsPluginFrame
final
:
public
nsFrame
public
nsIObjectFrame
public
nsIReflowCallback
{
public
:
typedef
mozilla
:
:
LayerState
LayerState
;
typedef
mozilla
:
:
LayoutDeviceIntPoint
LayoutDeviceIntPoint
;
typedef
mozilla
:
:
LayoutDeviceIntRect
LayoutDeviceIntRect
;
typedef
mozilla
:
:
LayoutDeviceIntRegion
LayoutDeviceIntRegion
;
typedef
mozilla
:
:
layers
:
:
Layer
Layer
;
typedef
mozilla
:
:
layers
:
:
LayerManager
LayerManager
;
typedef
mozilla
:
:
layers
:
:
ImageContainer
ImageContainer
;
typedef
mozilla
:
:
layers
:
:
StackingContextHelper
StackingContextHelper
;
typedef
mozilla
:
:
layers
:
:
RenderRootStateManager
RenderRootStateManager
;
typedef
mozilla
:
:
layers
:
:
WebRenderParentCommand
WebRenderParentCommand
;
typedef
mozilla
:
:
ContainerLayerParameters
ContainerLayerParameters
;
NS_DECL_FRAMEARENA_HELPERS
(
nsPluginFrame
)
NS_DECL_QUERYFRAME
friend
nsIFrame
*
NS_NewObjectFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
virtual
void
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
override
;
virtual
nscoord
GetMinISize
(
gfxContext
*
aRenderingContext
)
override
;
virtual
nscoord
GetPrefISize
(
gfxContext
*
aRenderingContext
)
override
;
virtual
void
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
override
;
virtual
void
DidReflow
(
nsPresContext
*
aPresContext
const
ReflowInput
*
aReflowInput
)
override
;
virtual
void
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
override
;
virtual
nsresult
HandleEvent
(
nsPresContext
*
aPresContext
mozilla
:
:
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
override
;
virtual
bool
IsFrameOfType
(
uint32_t
aFlags
)
const
override
{
return
nsFrame
:
:
IsFrameOfType
(
aFlags
&
~
(
nsIFrame
:
:
eReplaced
|
nsIFrame
:
:
eReplacedSizing
)
)
;
}
#
ifdef
DEBUG_FRAME_DUMP
virtual
nsresult
GetFrameName
(
nsAString
&
aResult
)
const
override
;
#
endif
virtual
void
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
override
;
virtual
void
DidSetComputedStyle
(
ComputedStyle
*
aOldComputedStyle
)
override
;
nsNPAPIPluginInstance
*
GetPluginInstance
(
)
override
;
virtual
void
SetIsDocumentActive
(
bool
aIsActive
)
override
;
virtual
nsresult
GetCursor
(
const
nsPoint
&
aPoint
nsIFrame
:
:
Cursor
&
aCursor
)
override
;
void
SetEmptyWidgetConfiguration
(
)
{
mNextConfigurationBounds
=
LayoutDeviceIntRect
(
0
0
0
0
)
;
mNextConfigurationClipRegion
.
Clear
(
)
;
}
void
GetWidgetConfiguration
(
nsTArray
<
nsIWidget
:
:
Configuration
>
*
aConfigurations
)
;
LayoutDeviceIntRect
GetWidgetlessClipRect
(
)
{
return
RegionFromArray
(
mNextConfigurationClipRegion
)
.
GetBounds
(
)
;
}
void
DidSetWidgetGeometry
(
)
;
#
ifdef
ACCESSIBILITY
virtual
mozilla
:
:
a11y
:
:
AccType
AccessibleType
(
)
override
;
#
ifdef
XP_WIN
NS_IMETHOD
GetPluginPort
(
HWND
*
aPort
)
;
#
endif
#
endif
nsresult
PrepForDrawing
(
nsIWidget
*
aWidget
)
;
static
nsIObjectFrame
*
GetNextObjectFrame
(
nsPresContext
*
aPresContext
nsIFrame
*
aRoot
)
;
virtual
bool
ReflowFinished
(
)
override
;
virtual
void
ReflowCallbackCanceled
(
)
override
;
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
nsDisplayItem
*
aItem
const
ContainerLayerParameters
&
aContainerParameters
)
;
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
)
;
nsRect
GetPaintedRect
(
const
nsDisplayPlugin
*
aItem
)
const
;
static
void
BeginSwapDocShells
(
nsISupports
*
aSupports
void
*
)
;
static
void
EndSwapDocShells
(
nsISupports
*
aSupports
void
*
)
;
nsIWidget
*
GetWidget
(
)
override
{
if
(
!
mInnerView
)
{
return
nullptr
;
}
return
mWidget
;
}
void
FixupWindow
(
const
nsSize
&
aSize
)
;
nsresult
CallSetWindow
(
bool
aCheckIsHidden
=
true
)
;
void
SetInstanceOwner
(
nsPluginInstanceOwner
*
aOwner
)
;
void
HandleWheelEventAsDefaultAction
(
mozilla
:
:
WidgetWheelEvent
*
aEvent
)
;
bool
WantsToHandleWheelEventAsDefaultAction
(
)
const
;
bool
CreateWebRenderCommands
(
nsDisplayItem
*
aItem
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
;
protected
:
explicit
nsPluginFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
;
virtual
~
nsPluginFrame
(
)
;
void
GetDesiredSize
(
nsPresContext
*
aPresContext
const
ReflowInput
&
aReflowInput
ReflowOutput
&
aDesiredSize
)
;
bool
IsFocusable
(
int32_t
*
aTabIndex
=
nullptr
bool
aWithMouse
=
false
)
override
;
bool
IsHidden
(
bool
aCheckVisibilityStyle
=
true
)
const
;
bool
IsOpaque
(
)
const
;
bool
IsTransparentMode
(
)
const
;
bool
IsPaintedByGecko
(
)
const
;
nsIntPoint
GetWindowOriginInPixels
(
bool
aWindowless
)
;
LayoutDeviceIntPoint
GetRemoteTabChromeOffset
(
)
;
static
void
PaintPrintPlugin
(
nsIFrame
*
aFrame
gfxContext
*
aRenderingContext
const
nsRect
&
aDirtyRect
nsPoint
aPt
)
;
void
PrintPlugin
(
gfxContext
&
aRenderingContext
const
nsRect
&
aDirtyRect
)
;
void
PaintPlugin
(
nsDisplayListBuilder
*
aBuilder
gfxContext
&
aRenderingContext
const
nsRect
&
aDirtyRect
const
nsRect
&
aPluginRect
)
;
void
NotifyPluginReflowObservers
(
)
;
friend
class
nsPluginInstanceOwner
;
friend
class
nsDisplayPlugin
;
friend
class
PluginBackgroundSink
;
nsView
*
GetViewInternal
(
)
const
override
{
return
mOuterView
;
}
void
SetViewInternal
(
nsView
*
aView
)
override
{
mOuterView
=
aView
;
}
bool
GetBounds
(
nsDisplayItem
*
aItem
mozilla
:
:
gfx
:
:
IntSize
&
aSize
gfxRect
&
aRect
)
;
private
:
void
RegisterPluginForGeometryUpdates
(
)
;
void
UnregisterPluginForGeometryUpdates
(
)
;
static
const
LayoutDeviceIntRegion
RegionFromArray
(
const
nsTArray
<
LayoutDeviceIntRect
>
&
aRects
)
{
LayoutDeviceIntRegion
region
;
for
(
uint32_t
i
=
0
;
i
<
aRects
.
Length
(
)
;
+
+
i
)
{
region
.
Or
(
region
aRects
[
i
]
)
;
}
return
region
;
}
class
PluginEventNotifier
:
public
mozilla
:
:
Runnable
{
public
:
explicit
PluginEventNotifier
(
const
nsString
&
aEventType
)
:
mozilla
:
:
Runnable
(
"
nsPluginFrame
:
:
PluginEventNotifier
"
)
mEventType
(
aEventType
)
{
}
NS_IMETHOD
Run
(
)
override
;
private
:
nsString
mEventType
;
}
;
nsPluginInstanceOwner
*
mInstanceOwner
;
nsView
*
mOuterView
;
nsView
*
mInnerView
;
nsCOMPtr
<
nsIWidget
>
mWidget
;
nsIntRect
mWindowlessRect
;
PluginBackgroundSink
*
mBackgroundSink
;
LayoutDeviceIntRect
mNextConfigurationBounds
;
nsTArray
<
LayoutDeviceIntRect
>
mNextConfigurationClipRegion
;
bool
mReflowCallbackPosted
;
RefPtr
<
nsRootPresContext
>
mRootPresContextRegisteredWith
;
mozilla
:
:
UniquePtr
<
PluginFrameDidCompositeObserver
>
mDidCompositeObserver
;
}
;
class
nsDisplayPluginGeometry
:
public
nsDisplayItemGenericGeometry
{
public
:
nsDisplayPluginGeometry
(
nsDisplayItem
*
aItem
nsDisplayListBuilder
*
aBuilder
)
:
nsDisplayItemGenericGeometry
(
aItem
aBuilder
)
{
}
virtual
bool
InvalidateForSyncDecodeImages
(
)
const
override
{
return
true
;
}
}
;
class
nsDisplayPlugin
final
:
public
nsDisplayItem
{
public
:
nsDisplayPlugin
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
:
nsDisplayItem
(
aBuilder
aFrame
)
{
MOZ_COUNT_CTOR
(
nsDisplayPlugin
)
;
aBuilder
-
>
SetContainsPluginItem
(
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayPlugin
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayPlugin
)
;
}
#
endif
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
nsRegion
GetOpaqueRegion
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
;
virtual
bool
ComputeVisibility
(
nsDisplayListBuilder
*
aBuilder
nsRegion
*
aVisibleRegion
)
override
;
NS_DISPLAY_DECL_NAME
(
"
Plugin
"
TYPE_PLUGIN
)
virtual
already_AddRefed
<
Layer
>
BuildLayer
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aContainerParameters
)
override
{
return
static_cast
<
nsPluginFrame
*
>
(
mFrame
)
-
>
BuildLayer
(
aBuilder
aManager
this
aContainerParameters
)
;
}
virtual
LayerState
GetLayerState
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
ContainerLayerParameters
&
aParameters
)
override
{
return
static_cast
<
nsPluginFrame
*
>
(
mFrame
)
-
>
GetLayerState
(
aBuilder
aManager
)
;
}
virtual
nsDisplayItemGeometry
*
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
new
nsDisplayPluginGeometry
(
this
aBuilder
)
;
}
virtual
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
}
;
#
endif
