#
ifndef
nsRubyTextContainerFrame_h___
#
define
nsRubyTextContainerFrame_h___
#
include
"
nsBlockFrame
.
h
"
nsContainerFrame
*
NS_NewRubyTextContainerFrame
(
nsIPresShell
*
aPresShell
mozilla
:
:
ComputedStyle
*
aStyle
)
;
class
nsRubyTextContainerFrame
final
:
public
nsContainerFrame
{
public
:
NS_DECL_FRAMEARENA_HELPERS
(
nsRubyTextContainerFrame
)
NS_DECL_QUERYFRAME
virtual
bool
IsFrameOfType
(
uint32_t
aFlags
)
const
override
;
virtual
void
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
override
;
#
ifdef
DEBUG_FRAME_DUMP
virtual
nsresult
GetFrameName
(
nsAString
&
aResult
)
const
override
;
#
endif
virtual
void
SetInitialChildList
(
ChildListID
aListID
nsFrameList
&
aChildList
)
override
;
virtual
void
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
override
;
virtual
void
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
aFrameList
)
override
;
virtual
void
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
override
;
bool
IsSpanContainer
(
)
const
{
return
GetStateBits
(
)
&
NS_RUBY_TEXT_CONTAINER_IS_SPAN
;
}
protected
:
friend
nsContainerFrame
*
NS_NewRubyTextContainerFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
explicit
nsRubyTextContainerFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
:
nsContainerFrame
(
aStyle
aPresContext
kClassID
)
mISize
(
0
)
{
}
void
UpdateSpanFlag
(
)
;
friend
class
nsRubyBaseContainerFrame
;
void
SetISize
(
nscoord
aISize
)
{
mISize
=
aISize
;
}
nscoord
mISize
;
}
;
#
endif
