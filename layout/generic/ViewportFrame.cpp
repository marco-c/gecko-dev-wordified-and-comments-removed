#
include
"
mozilla
/
ViewportFrame
.
h
"
#
include
"
mozilla
/
ComputedStyleInlines
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsSubDocumentFrame
.
h
"
#
include
"
nsCanvasFrame
.
h
"
#
include
"
nsAbsoluteContainingBlock
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
nsIMozBrowserFrame
.
h
"
#
include
"
nsPlaceholderFrame
.
h
"
using
namespace
mozilla
;
typedef
nsAbsoluteContainingBlock
:
:
AbsPosReflowFlags
AbsPosReflowFlags
;
ViewportFrame
*
NS_NewViewportFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
ViewportFrame
(
aStyle
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
ViewportFrame
)
NS_QUERYFRAME_HEAD
(
ViewportFrame
)
NS_QUERYFRAME_ENTRY
(
ViewportFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsContainerFrame
)
void
ViewportFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
nsContainerFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
nsIFrame
*
parent
=
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
this
)
;
if
(
parent
)
{
nsFrameState
state
=
parent
-
>
GetStateBits
(
)
;
AddStateBits
(
state
&
(
NS_FRAME_IN_POPUP
)
)
;
}
}
void
ViewportFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
AUTO_PROFILER_LABEL
(
"
ViewportFrame
:
:
BuildDisplayList
"
GRAPHICS
)
;
if
(
nsIFrame
*
kid
=
mFrames
.
FirstChild
(
)
)
{
BuildDisplayListForChild
(
aBuilder
kid
aLists
)
;
}
nsDisplayList
topLayerList
;
BuildDisplayListForTopLayer
(
aBuilder
&
topLayerList
)
;
if
(
!
topLayerList
.
IsEmpty
(
)
)
{
nsDisplayWrapList
*
wrapList
=
MakeDisplayItem
<
nsDisplayWrapList
>
(
aBuilder
this
&
topLayerList
)
;
wrapList
-
>
SetOverrideZIndex
(
std
:
:
numeric_limits
<
decltype
(
wrapList
-
>
ZIndex
(
)
)
>
:
:
max
(
)
)
;
aLists
.
PositionedDescendants
(
)
-
>
AppendToTop
(
wrapList
)
;
}
}
#
ifdef
DEBUG
static
bool
ShouldInTopLayerForFullscreen
(
Element
*
aElement
)
{
if
(
!
aElement
-
>
GetParent
(
)
)
{
return
false
;
}
nsCOMPtr
<
nsIMozBrowserFrame
>
browserFrame
=
do_QueryInterface
(
aElement
)
;
if
(
browserFrame
&
&
browserFrame
-
>
GetReallyIsBrowser
(
)
)
{
return
false
;
}
return
true
;
}
#
endif
static
void
BuildDisplayListForTopLayerFrame
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
)
{
nsRect
visible
;
nsRect
dirty
;
DisplayListClipState
:
:
AutoClipMultiple
clipState
(
aBuilder
)
;
nsDisplayListBuilder
:
:
AutoCurrentActiveScrolledRootSetter
asrSetter
(
aBuilder
)
;
nsDisplayListBuilder
:
:
OutOfFlowDisplayData
*
savedOutOfFlowData
=
nsDisplayListBuilder
:
:
GetOutOfFlowData
(
aFrame
)
;
if
(
savedOutOfFlowData
)
{
visible
=
savedOutOfFlowData
-
>
GetVisibleRectForFrame
(
aBuilder
aFrame
&
dirty
)
;
clipState
.
SetClipChainForContainingBlockDescendants
(
savedOutOfFlowData
-
>
mCombinedClipChain
)
;
clipState
.
ClipContainingBlockDescendantsExtra
(
visible
+
aBuilder
-
>
ToReferenceFrame
(
aFrame
)
nullptr
)
;
asrSetter
.
SetCurrentActiveScrolledRoot
(
savedOutOfFlowData
-
>
mContainingBlockActiveScrolledRoot
)
;
}
nsDisplayListBuilder
:
:
AutoBuildingDisplayList
buildingForChild
(
aBuilder
aFrame
visible
dirty
aBuilder
-
>
IsAtRootOfPseudoStackingContext
(
)
)
;
nsDisplayList
list
;
aFrame
-
>
BuildDisplayListForStackingContext
(
aBuilder
&
list
)
;
aList
-
>
AppendToTop
(
&
list
)
;
}
void
ViewportFrame
:
:
BuildDisplayListForTopLayer
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
)
{
nsTArray
<
Element
*
>
fullscreenStack
=
PresContext
(
)
-
>
Document
(
)
-
>
GetFullscreenStack
(
)
;
for
(
Element
*
elem
:
fullscreenStack
)
{
if
(
nsIFrame
*
frame
=
elem
-
>
GetPrimaryFrame
(
)
)
{
if
(
frame
-
>
StyleDisplay
(
)
-
>
mTopLayer
=
=
NS_STYLE_TOP_LAYER_NONE
)
{
MOZ_ASSERT
(
!
aBuilder
-
>
IsForPainting
(
)
|
|
!
ShouldInTopLayerForFullscreen
(
elem
)
)
;
continue
;
}
MOZ_ASSERT
(
ShouldInTopLayerForFullscreen
(
elem
)
)
;
if
(
!
(
frame
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
)
{
MOZ_ASSERT
(
!
elem
-
>
GetParent
(
)
-
>
IsHTMLElement
(
)
"
HTML
element
should
always
be
out
-
of
-
flow
if
in
the
top
"
"
layer
"
)
;
continue
;
}
if
(
nsIFrame
*
backdropPh
=
frame
-
>
GetChildList
(
kBackdropList
)
.
FirstChild
(
)
)
{
MOZ_ASSERT
(
backdropPh
-
>
IsPlaceholderFrame
(
)
)
;
MOZ_ASSERT
(
!
backdropPh
-
>
GetNextSibling
(
)
"
more
than
one
:
:
backdrop
?
"
)
;
MOZ_ASSERT
(
backdropPh
-
>
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
"
did
you
intend
to
reflow
:
:
backdrop
placeholders
?
"
)
;
nsIFrame
*
backdropFrame
=
static_cast
<
nsPlaceholderFrame
*
>
(
backdropPh
)
-
>
GetOutOfFlowFrame
(
)
;
MOZ_ASSERT
(
backdropFrame
)
;
BuildDisplayListForTopLayerFrame
(
aBuilder
backdropFrame
aList
)
;
}
BuildDisplayListForTopLayerFrame
(
aBuilder
frame
aList
)
;
}
}
nsIPresShell
*
shell
=
PresShell
(
)
;
if
(
nsCanvasFrame
*
canvasFrame
=
shell
-
>
GetCanvasFrame
(
)
)
{
if
(
Element
*
container
=
canvasFrame
-
>
GetCustomContentContainer
(
)
)
{
if
(
nsIFrame
*
frame
=
container
-
>
GetPrimaryFrame
(
)
)
{
MOZ_ASSERT
(
frame
-
>
StyleDisplay
(
)
-
>
mTopLayer
!
=
NS_STYLE_TOP_LAYER_NONE
"
ua
.
css
should
ensure
this
"
)
;
MOZ_ASSERT
(
frame
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
;
BuildDisplayListForTopLayerFrame
(
aBuilder
frame
aList
)
;
}
}
}
}
#
ifdef
DEBUG
void
ViewportFrame
:
:
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
{
NS_ASSERTION
(
aListID
=
=
kPrincipalList
"
unexpected
child
list
"
)
;
NS_ASSERTION
(
GetChildList
(
aListID
)
.
IsEmpty
(
)
"
Shouldn
'
t
have
any
kids
!
"
)
;
nsContainerFrame
:
:
AppendFrames
(
aListID
aFrameList
)
;
}
void
ViewportFrame
:
:
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
aFrameList
)
{
NS_ASSERTION
(
aListID
=
=
kPrincipalList
"
unexpected
child
list
"
)
;
NS_ASSERTION
(
GetChildList
(
aListID
)
.
IsEmpty
(
)
"
Shouldn
'
t
have
any
kids
!
"
)
;
nsContainerFrame
:
:
InsertFrames
(
aListID
aPrevFrame
aFrameList
)
;
}
void
ViewportFrame
:
:
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
{
NS_ASSERTION
(
aListID
=
=
kPrincipalList
"
unexpected
child
list
"
)
;
nsContainerFrame
:
:
RemoveFrame
(
aListID
aOldFrame
)
;
}
#
endif
nscoord
ViewportFrame
:
:
GetMinISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
result
;
DISPLAY_MIN_INLINE_SIZE
(
this
result
)
;
if
(
mFrames
.
IsEmpty
(
)
)
result
=
0
;
else
result
=
mFrames
.
FirstChild
(
)
-
>
GetMinISize
(
aRenderingContext
)
;
return
result
;
}
nscoord
ViewportFrame
:
:
GetPrefISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
result
;
DISPLAY_PREF_INLINE_SIZE
(
this
result
)
;
if
(
mFrames
.
IsEmpty
(
)
)
result
=
0
;
else
result
=
mFrames
.
FirstChild
(
)
-
>
GetPrefISize
(
aRenderingContext
)
;
return
result
;
}
nsPoint
ViewportFrame
:
:
AdjustReflowInputForScrollbars
(
ReflowInput
*
aReflowInput
)
const
{
nsIFrame
*
kidFrame
=
mFrames
.
FirstChild
(
)
;
nsIScrollableFrame
*
scrollingFrame
=
do_QueryFrame
(
kidFrame
)
;
if
(
scrollingFrame
)
{
WritingMode
wm
=
aReflowInput
-
>
GetWritingMode
(
)
;
LogicalMargin
scrollbars
(
wm
scrollingFrame
-
>
GetActualScrollbarSizes
(
)
)
;
aReflowInput
-
>
SetComputedISize
(
aReflowInput
-
>
ComputedISize
(
)
-
scrollbars
.
IStartEnd
(
wm
)
)
;
aReflowInput
-
>
AvailableISize
(
)
-
=
scrollbars
.
IStartEnd
(
wm
)
;
aReflowInput
-
>
SetComputedBSizeWithoutResettingResizeFlags
(
aReflowInput
-
>
ComputedBSize
(
)
-
scrollbars
.
BStartEnd
(
wm
)
)
;
return
nsPoint
(
scrollbars
.
Left
(
wm
)
scrollbars
.
Top
(
wm
)
)
;
}
return
nsPoint
(
0
0
)
;
}
nsRect
ViewportFrame
:
:
AdjustReflowInputAsContainingBlock
(
ReflowInput
*
aReflowInput
)
const
{
#
ifdef
DEBUG
nsPoint
offset
=
#
endif
AdjustReflowInputForScrollbars
(
aReflowInput
)
;
NS_ASSERTION
(
GetAbsoluteContainingBlock
(
)
-
>
GetChildList
(
)
.
IsEmpty
(
)
|
|
(
offset
.
x
=
=
0
&
&
offset
.
y
=
=
0
)
"
We
don
'
t
handle
correct
positioning
of
fixed
frames
with
"
"
scrollbars
in
odd
positions
"
)
;
nsRect
rect
(
0
0
aReflowInput
-
>
ComputedWidth
(
)
aReflowInput
-
>
ComputedHeight
(
)
)
;
nsIPresShell
*
ps
=
PresShell
(
)
;
if
(
ps
-
>
IsVisualViewportSizeSet
(
)
&
&
rect
.
Size
(
)
<
ps
-
>
GetVisualViewportSize
(
)
)
{
rect
.
SizeTo
(
ps
-
>
GetVisualViewportSize
(
)
)
;
}
return
rect
;
}
void
ViewportFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
ViewportFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aDesiredSize
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
NS_FRAME_TRACE_REFLOW_IN
(
"
ViewportFrame
:
:
Reflow
"
)
;
AddStateBits
(
NS_FRAME_CONTAINS_RELATIVE_BSIZE
)
;
SetSize
(
nsSize
(
aReflowInput
.
ComputedWidth
(
)
aReflowInput
.
ComputedHeight
(
)
)
)
;
nscoord
kidBSize
=
0
;
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
if
(
mFrames
.
NotEmpty
(
)
)
{
if
(
aReflowInput
.
ShouldReflowAllKids
(
)
|
|
aReflowInput
.
IsBResize
(
)
|
|
NS_SUBTREE_DIRTY
(
mFrames
.
FirstChild
(
)
)
)
{
nsIFrame
*
kidFrame
=
mFrames
.
FirstChild
(
)
;
ReflowOutput
kidDesiredSize
(
aReflowInput
)
;
WritingMode
wm
=
kidFrame
-
>
GetWritingMode
(
)
;
LogicalSize
availableSpace
=
aReflowInput
.
AvailableSize
(
wm
)
;
ReflowInput
kidReflowInput
(
aPresContext
aReflowInput
kidFrame
availableSpace
)
;
kidReflowInput
.
SetComputedBSize
(
aReflowInput
.
ComputedBSize
(
)
)
;
ReflowChild
(
kidFrame
aPresContext
kidDesiredSize
kidReflowInput
0
0
0
aStatus
)
;
kidBSize
=
kidDesiredSize
.
BSize
(
wm
)
;
FinishReflowChild
(
kidFrame
aPresContext
kidDesiredSize
nullptr
0
0
0
)
;
}
else
{
kidBSize
=
LogicalSize
(
wm
mFrames
.
FirstChild
(
)
-
>
GetSize
(
)
)
.
BSize
(
wm
)
;
}
}
NS_ASSERTION
(
aReflowInput
.
AvailableISize
(
)
!
=
NS_UNCONSTRAINEDSIZE
"
shouldn
'
t
happen
anymore
"
)
;
LogicalSize
maxSize
(
wm
aReflowInput
.
AvailableISize
(
)
aReflowInput
.
ComputedBSize
(
)
!
=
NS_UNCONSTRAINEDSIZE
?
aReflowInput
.
ComputedBSize
(
)
:
kidBSize
)
;
aDesiredSize
.
SetSize
(
wm
maxSize
)
;
aDesiredSize
.
SetOverflowAreasToDesiredBounds
(
)
;
if
(
HasAbsolutelyPositionedChildren
(
)
)
{
ReflowInput
reflowInput
(
aReflowInput
)
;
if
(
reflowInput
.
AvailableBSize
(
)
=
=
NS_UNCONSTRAINEDSIZE
)
{
reflowInput
.
AvailableBSize
(
)
=
maxSize
.
BSize
(
wm
)
;
NS_ASSERTION
(
reflowInput
.
ComputedPhysicalBorderPadding
(
)
=
=
nsMargin
(
0
0
0
0
)
"
Viewports
can
'
t
have
border
/
padding
"
)
;
reflowInput
.
SetComputedBSize
(
maxSize
.
BSize
(
wm
)
)
;
}
nsRect
rect
=
AdjustReflowInputAsContainingBlock
(
&
reflowInput
)
;
AbsPosReflowFlags
flags
=
AbsPosReflowFlags
:
:
eCBWidthAndHeightChanged
;
GetAbsoluteContainingBlock
(
)
-
>
Reflow
(
this
aPresContext
reflowInput
aStatus
rect
flags
nullptr
)
;
}
if
(
mFrames
.
NotEmpty
(
)
)
{
ConsiderChildOverflow
(
aDesiredSize
.
mOverflowAreas
mFrames
.
FirstChild
(
)
)
;
}
if
(
GetStateBits
(
)
&
NS_FRAME_IS_DIRTY
)
{
InvalidateFrame
(
)
;
}
FinishAndStoreOverflow
(
&
aDesiredSize
)
;
NS_FRAME_TRACE_REFLOW_OUT
(
"
ViewportFrame
:
:
Reflow
"
aStatus
)
;
NS_FRAME_SET_TRUNCATION
(
aStatus
aReflowInput
aDesiredSize
)
;
}
void
ViewportFrame
:
:
UpdateStyle
(
ServoRestyleState
&
aRestyleState
)
{
nsAtom
*
pseudo
=
Style
(
)
-
>
GetPseudo
(
)
;
RefPtr
<
ComputedStyle
>
newStyle
=
aRestyleState
.
StyleSet
(
)
.
ResolveInheritingAnonymousBoxStyle
(
pseudo
nullptr
)
;
MOZ_ASSERT
(
!
GetNextContinuation
(
)
"
Viewport
has
continuations
?
"
)
;
SetComputedStyle
(
newStyle
)
;
UpdateStyleOfOwnedAnonBoxes
(
aRestyleState
)
;
}
void
ViewportFrame
:
:
AppendDirectlyOwnedAnonBoxes
(
nsTArray
<
OwnedAnonBox
>
&
aResult
)
{
if
(
mFrames
.
NotEmpty
(
)
)
{
aResult
.
AppendElement
(
mFrames
.
FirstChild
(
)
)
;
}
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
ViewportFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
NS_LITERAL_STRING
(
"
Viewport
"
)
aResult
)
;
}
#
endif
