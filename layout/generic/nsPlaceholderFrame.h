#
ifndef
nsPlaceholderFrame_h___
#
define
nsPlaceholderFrame_h___
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
nsFrame
.
h
"
#
include
"
nsGkAtoms
.
h
"
namespace
mozilla
{
class
PresShell
;
}
class
nsPlaceholderFrame
;
nsPlaceholderFrame
*
NS_NewPlaceholderFrame
(
mozilla
:
:
PresShell
*
aPresShell
mozilla
:
:
ComputedStyle
*
aStyle
nsFrameState
aTypeBits
)
;
#
define
PLACEHOLDER_TYPE_MASK
\
(
PLACEHOLDER_FOR_FLOAT
|
PLACEHOLDER_FOR_ABSPOS
|
PLACEHOLDER_FOR_FIXEDPOS
|
\
PLACEHOLDER_FOR_POPUP
|
PLACEHOLDER_FOR_TOPLAYER
)
class
nsPlaceholderFrame
final
:
public
nsFrame
{
public
:
NS_DECL_FRAMEARENA_HELPERS
(
nsPlaceholderFrame
)
#
ifdef
DEBUG
NS_DECL_QUERYFRAME
#
endif
friend
nsPlaceholderFrame
*
NS_NewPlaceholderFrame
(
mozilla
:
:
PresShell
*
aPresShell
ComputedStyle
*
aStyle
nsFrameState
aTypeBits
)
;
nsPlaceholderFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
nsFrameState
aTypeBits
)
:
nsFrame
(
aStyle
aPresContext
kClassID
)
mOutOfFlowFrame
(
nullptr
)
{
MOZ_ASSERT
(
aTypeBits
=
=
PLACEHOLDER_FOR_FLOAT
|
|
aTypeBits
=
=
PLACEHOLDER_FOR_ABSPOS
|
|
aTypeBits
=
=
PLACEHOLDER_FOR_FIXEDPOS
|
|
aTypeBits
=
=
PLACEHOLDER_FOR_POPUP
|
|
aTypeBits
=
=
(
PLACEHOLDER_FOR_TOPLAYER
|
PLACEHOLDER_FOR_ABSPOS
)
|
|
aTypeBits
=
=
(
PLACEHOLDER_FOR_TOPLAYER
|
PLACEHOLDER_FOR_FIXEDPOS
)
"
Unexpected
type
bit
"
)
;
AddStateBits
(
aTypeBits
)
;
}
nsIFrame
*
GetOutOfFlowFrame
(
)
const
{
return
mOutOfFlowFrame
;
}
void
SetOutOfFlowFrame
(
nsIFrame
*
aFrame
)
{
NS_ASSERTION
(
!
aFrame
|
|
!
aFrame
-
>
GetPrevContinuation
(
)
"
OOF
must
be
first
continuation
"
)
;
mOutOfFlowFrame
=
aFrame
;
}
virtual
void
AddInlineMinISize
(
gfxContext
*
aRenderingContext
InlineMinISizeData
*
aData
)
override
;
virtual
void
AddInlinePrefISize
(
gfxContext
*
aRenderingContext
InlinePrefISizeData
*
aData
)
override
;
virtual
nsSize
GetXULMinSize
(
nsBoxLayoutState
&
aBoxLayoutState
)
override
;
virtual
nsSize
GetXULPrefSize
(
nsBoxLayoutState
&
aBoxLayoutState
)
override
;
virtual
nsSize
GetXULMaxSize
(
nsBoxLayoutState
&
aBoxLayoutState
)
override
;
virtual
void
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
override
;
virtual
void
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
override
;
#
if
defined
(
DEBUG
)
|
|
(
defined
(
MOZ_REFLOW_PERF_DSP
)
&
&
defined
(
MOZ_REFLOW_PERF
)
)
virtual
void
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
override
;
#
endif
#
ifdef
DEBUG_FRAME_DUMP
void
List
(
FILE
*
out
=
stderr
const
char
*
aPrefix
=
"
"
ListFlags
aFlags
=
ListFlags
(
)
)
const
override
;
virtual
nsresult
GetFrameName
(
nsAString
&
aResult
)
const
override
;
#
endif
virtual
bool
IsEmpty
(
)
override
{
return
true
;
}
virtual
bool
IsSelfEmpty
(
)
override
{
return
true
;
}
virtual
bool
CanContinueTextRun
(
)
const
override
;
void
SetLineIsEmptySoFar
(
bool
aValue
)
{
AddOrRemoveStateBits
(
PLACEHOLDER_LINE_IS_EMPTY_SO_FAR
aValue
)
;
AddStateBits
(
PLACEHOLDER_HAVE_LINE_IS_EMPTY_SO_FAR
)
;
}
bool
GetLineIsEmptySoFar
(
bool
*
aResult
)
const
{
bool
haveValue
=
HasAnyStateBits
(
PLACEHOLDER_HAVE_LINE_IS_EMPTY_SO_FAR
)
;
if
(
haveValue
)
{
*
aResult
=
HasAnyStateBits
(
PLACEHOLDER_LINE_IS_EMPTY_SO_FAR
)
;
}
return
haveValue
;
}
void
ForgetLineIsEmptySoFar
(
)
{
RemoveStateBits
(
PLACEHOLDER_HAVE_LINE_IS_EMPTY_SO_FAR
)
;
}
#
ifdef
ACCESSIBILITY
virtual
mozilla
:
:
a11y
:
:
AccType
AccessibleType
(
)
override
{
nsIFrame
*
realFrame
=
GetRealFrameForPlaceholder
(
this
)
;
return
realFrame
?
realFrame
-
>
AccessibleType
(
)
:
nsFrame
:
:
AccessibleType
(
)
;
}
#
endif
ComputedStyle
*
GetParentComputedStyleForOutOfFlow
(
nsIFrame
*
*
aProviderFrame
)
const
;
ComputedStyle
*
GetLayoutParentStyleForOutOfFlow
(
nsIFrame
*
*
aProviderFrame
)
const
;
bool
RenumberFrameAndDescendants
(
int32_t
*
aOrdinal
int32_t
aDepth
int32_t
aIncrement
bool
aForCounting
)
override
{
return
mOutOfFlowFrame
-
>
RenumberFrameAndDescendants
(
aOrdinal
aDepth
aIncrement
aForCounting
)
;
}
static
nsIFrame
*
GetRealFrameFor
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
"
Must
have
a
frame
to
work
with
"
)
;
if
(
aFrame
-
>
IsPlaceholderFrame
(
)
)
{
return
GetRealFrameForPlaceholder
(
aFrame
)
;
}
return
aFrame
;
}
static
nsIFrame
*
GetRealFrameForPlaceholder
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
-
>
IsPlaceholderFrame
(
)
"
Must
have
placeholder
frame
as
input
"
)
;
nsIFrame
*
outOfFlow
=
static_cast
<
nsPlaceholderFrame
*
>
(
aFrame
)
-
>
GetOutOfFlowFrame
(
)
;
NS_ASSERTION
(
outOfFlow
"
Null
out
-
of
-
flow
for
placeholder
?
"
)
;
return
outOfFlow
;
}
protected
:
nsIFrame
*
mOutOfFlowFrame
;
}
;
#
endif
