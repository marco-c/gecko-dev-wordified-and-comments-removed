#
ifndef
BlockReflowInput_h
#
define
BlockReflowInput_h
#
include
"
nsFloatManager
.
h
"
#
include
"
nsLineBox
.
h
"
#
include
"
mozilla
/
ReflowInput
.
h
"
class
nsBlockFrame
;
class
nsFrameList
;
class
nsOverflowContinuationTracker
;
#
define
BRS_UNCONSTRAINEDBSIZE
0x00000001
#
define
BRS_ISBSTARTMARGINROOT
0x00000002
#
define
BRS_ISBENDMARGINROOT
0x00000004
#
define
BRS_APPLYBSTARTMARGIN
0x00000008
#
define
BRS_ISFIRSTINFLOW
0x00000010
#
define
BRS_HAVELINEADJACENTTOTOP
0x00000020
#
define
BRS_FLOAT_MGR
0x00000040
#
define
BRS_LINE_LAYOUT_EMPTY
0x00000080
#
define
BRS_ISOVERFLOWCONTAINER
0x00000100
#
define
BRS_PROPTABLE_FLOATCLIST
0x00000200
#
define
BRS_FLOAT_FRAGMENTS_INSIDE_COLUMN_ENABLED
0x00000400
#
define
BRS_LASTFLAG
BRS_FLOAT_FRAGMENTS_INSIDE_COLUMN_ENABLED
namespace
mozilla
{
class
BlockReflowInput
{
using
ReflowInput
=
mozilla
:
:
ReflowInput
;
public
:
BlockReflowInput
(
const
ReflowInput
&
aReflowInput
nsPresContext
*
aPresContext
nsBlockFrame
*
aFrame
bool
aBStartMarginRoot
bool
aBEndMarginRoot
bool
aBlockNeedsFloatManager
nscoord
aConsumedBSize
=
NS_INTRINSICSIZE
)
;
nsFlowAreaRect
GetFloatAvailableSpace
(
)
const
{
return
GetFloatAvailableSpace
(
mBCoord
)
;
}
nsFlowAreaRect
GetFloatAvailableSpace
(
nscoord
aBCoord
)
const
{
return
GetFloatAvailableSpaceWithState
(
aBCoord
nullptr
)
;
}
nsFlowAreaRect
GetFloatAvailableSpaceWithState
(
nscoord
aBCoord
nsFloatManager
:
:
SavedState
*
aState
)
const
;
nsFlowAreaRect
GetFloatAvailableSpaceForBSize
(
nscoord
aBCoord
nscoord
aBSize
nsFloatManager
:
:
SavedState
*
aState
)
const
;
bool
AddFloat
(
nsLineLayout
*
aLineLayout
nsIFrame
*
aFloat
nscoord
aAvailableISize
)
;
bool
FlowAndPlaceFloat
(
nsIFrame
*
aFloat
)
;
void
PlaceBelowCurrentLineFloats
(
nsFloatCacheFreeList
&
aFloats
nsLineBox
*
aLine
)
;
nscoord
ClearFloats
(
nscoord
aBCoord
uint8_t
aBreakType
nsIFrame
*
aReplacedBlock
=
nullptr
uint32_t
aFlags
=
0
)
;
bool
AdvanceToNextBand
(
const
mozilla
:
:
LogicalRect
&
aFloatAvailableSpace
nscoord
*
aBCoord
)
const
{
mozilla
:
:
WritingMode
wm
=
mReflowInput
.
GetWritingMode
(
)
;
if
(
aFloatAvailableSpace
.
BSize
(
wm
)
>
0
)
{
*
aBCoord
+
=
aFloatAvailableSpace
.
BSize
(
wm
)
;
}
else
{
if
(
mReflowInput
.
AvailableHeight
(
)
!
=
NS_UNCONSTRAINEDSIZE
)
{
return
false
;
}
NS_NOTREACHED
(
"
avail
space
rect
with
zero
height
!
"
)
;
*
aBCoord
+
=
1
;
}
return
true
;
}
bool
ReplacedBlockFitsInAvailSpace
(
nsIFrame
*
aReplacedBlock
const
nsFlowAreaRect
&
aFloatAvailableSpace
)
const
;
bool
IsAdjacentWithTop
(
)
const
{
return
mBCoord
=
=
mBorderPadding
.
BStart
(
mReflowInput
.
GetWritingMode
(
)
)
;
}
const
mozilla
:
:
LogicalMargin
&
BorderPadding
(
)
const
{
return
mBorderPadding
;
}
nscoord
GetConsumedBSize
(
)
;
void
ReconstructMarginBefore
(
nsLineList
:
:
iterator
aLine
)
;
void
ComputeReplacedBlockOffsetsForFloats
(
nsIFrame
*
aFrame
const
mozilla
:
:
LogicalRect
&
aFloatAvailableSpace
nscoord
&
aIStartResult
nscoord
&
aIEndResult
)
const
;
void
ComputeBlockAvailSpace
(
nsIFrame
*
aFrame
const
nsStyleDisplay
*
aDisplay
const
nsFlowAreaRect
&
aFloatAvailableSpace
bool
aBlockAvoidsFloats
mozilla
:
:
LogicalRect
&
aResult
)
;
void
RecoverStateFrom
(
nsLineList
:
:
iterator
aLine
nscoord
aDeltaBCoord
)
;
void
AdvanceToNextLine
(
)
{
if
(
GetFlag
(
BRS_LINE_LAYOUT_EMPTY
)
)
{
SetFlag
(
BRS_LINE_LAYOUT_EMPTY
false
)
;
}
else
{
mLineNumber
+
+
;
}
}
nsBlockFrame
*
mBlock
;
nsPresContext
*
mPresContext
;
const
ReflowInput
&
mReflowInput
;
nsFloatManager
*
mFloatManager
;
nscoord
mFloatManagerI
mFloatManagerB
;
nsReflowStatus
mReflowStatus
;
nsFloatManager
:
:
SavedState
mFloatManagerStateBefore
;
nscoord
mBEndEdge
;
mozilla
:
:
LogicalRect
mContentArea
;
nscoord
ContentIStart
(
)
const
{
return
mContentArea
.
IStart
(
mReflowInput
.
GetWritingMode
(
)
)
;
}
nscoord
ContentISize
(
)
const
{
return
mContentArea
.
ISize
(
mReflowInput
.
GetWritingMode
(
)
)
;
}
nscoord
ContentIEnd
(
)
const
{
return
mContentArea
.
IEnd
(
mReflowInput
.
GetWritingMode
(
)
)
;
}
nscoord
ContentBStart
(
)
const
{
return
mContentArea
.
BStart
(
mReflowInput
.
GetWritingMode
(
)
)
;
}
nscoord
ContentBSize
(
)
const
{
return
mContentArea
.
BSize
(
mReflowInput
.
GetWritingMode
(
)
)
;
}
nscoord
ContentBEnd
(
)
const
{
return
mContentArea
.
BEnd
(
mReflowInput
.
GetWritingMode
(
)
)
;
}
mozilla
:
:
LogicalSize
ContentSize
(
mozilla
:
:
WritingMode
aWM
)
const
{
mozilla
:
:
WritingMode
wm
=
mReflowInput
.
GetWritingMode
(
)
;
return
mContentArea
.
Size
(
wm
)
.
ConvertTo
(
aWM
wm
)
;
}
nsSize
mContainerSize
;
const
nsSize
&
ContainerSize
(
)
const
{
return
mContainerSize
;
}
nsFrameList
*
mPushedFloats
;
void
SetupPushedFloatList
(
)
;
void
AppendPushedFloatChain
(
nsIFrame
*
aFloatCont
)
;
nsOverflowContinuationTracker
*
mOverflowTracker
;
nsLineList
:
:
iterator
mCurrentLine
;
nsLineList
:
:
iterator
mLineAdjacentToTop
;
nscoord
mBCoord
;
mozilla
:
:
LogicalMargin
mBorderPadding
;
nsOverflowAreas
mFloatOverflowAreas
;
nsFloatCacheFreeList
mFloatCacheFreeList
;
nsIFrame
*
mPrevChild
;
nsCollapsingMargin
mPrevBEndMargin
;
nsBlockFrame
*
mNextInFlow
;
nsFloatCacheFreeList
mCurrentLineFloats
;
nsFloatCacheFreeList
mBelowCurrentLineFloats
;
nscoord
mMinLineHeight
;
int32_t
mLineNumber
;
int16_t
mFlags
;
uint8_t
mFloatBreakType
;
nscoord
mConsumedBSize
;
void
SetFlag
(
uint32_t
aFlag
bool
aValue
)
{
NS_ASSERTION
(
aFlag
<
=
BRS_LASTFLAG
"
bad
flag
"
)
;
if
(
aValue
)
{
mFlags
|
=
aFlag
;
}
else
{
mFlags
&
=
~
aFlag
;
}
}
bool
GetFlag
(
uint32_t
aFlag
)
const
{
NS_ASSERTION
(
aFlag
<
=
BRS_LASTFLAG
"
bad
flag
"
)
;
return
!
!
(
mFlags
&
aFlag
)
;
}
private
:
bool
CanPlaceFloat
(
nscoord
aFloatISize
const
nsFlowAreaRect
&
aFloatAvailableSpace
)
;
void
PushFloatPastBreak
(
nsIFrame
*
aFloat
)
;
void
RecoverFloats
(
nsLineList
:
:
iterator
aLine
nscoord
aDeltaBCoord
)
;
}
;
}
;
#
endif
