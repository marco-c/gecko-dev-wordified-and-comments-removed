#
ifndef
nsInlineFrame_h___
#
define
nsInlineFrame_h___
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
nsContainerFrame
.
h
"
class
nsLineLayout
;
namespace
mozilla
{
class
PresShell
;
}
class
nsInlineFrame
:
public
nsContainerFrame
{
public
:
NS_DECL_QUERYFRAME
NS_DECL_FRAMEARENA_HELPERS
(
nsInlineFrame
)
friend
nsInlineFrame
*
NS_NewInlineFrame
(
mozilla
:
:
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
virtual
void
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
override
;
#
ifdef
ACCESSIBILITY
virtual
mozilla
:
:
a11y
:
:
AccType
AccessibleType
(
)
override
;
#
endif
#
ifdef
DEBUG_FRAME_DUMP
virtual
nsresult
GetFrameName
(
nsAString
&
aResult
)
const
override
;
#
endif
virtual
bool
IsFrameOfType
(
uint32_t
aFlags
)
const
override
{
if
(
aFlags
&
(
eSupportsCSSTransforms
|
eSupportsContainLayoutAndPaint
)
)
{
return
false
;
}
return
nsContainerFrame
:
:
IsFrameOfType
(
aFlags
&
~
(
nsIFrame
:
:
eBidiInlineContainer
|
nsIFrame
:
:
eLineParticipant
)
)
;
}
virtual
void
InvalidateFrame
(
uint32_t
aDisplayItemKey
=
0
bool
aRebuildDisplayItems
=
true
)
override
;
virtual
void
InvalidateFrameWithRect
(
const
nsRect
&
aRect
uint32_t
aDisplayItemKey
=
0
bool
aRebuildDisplayItems
=
true
)
override
;
virtual
bool
IsEmpty
(
)
override
;
virtual
bool
IsSelfEmpty
(
)
override
;
virtual
FrameSearchResult
PeekOffsetCharacter
(
bool
aForward
int32_t
*
aOffset
PeekOffsetCharacterOptions
aOptions
=
PeekOffsetCharacterOptions
(
)
)
override
;
virtual
void
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
override
;
void
StealFrame
(
nsIFrame
*
aChild
)
override
;
virtual
void
AddInlineMinISize
(
gfxContext
*
aRenderingContext
InlineMinISizeData
*
aData
)
override
;
virtual
void
AddInlinePrefISize
(
gfxContext
*
aRenderingContext
InlinePrefISizeData
*
aData
)
override
;
SizeComputationResult
ComputeSize
(
gfxContext
*
aRenderingContext
mozilla
:
:
WritingMode
aWM
const
mozilla
:
:
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
mozilla
:
:
LogicalSize
&
aMargin
const
mozilla
:
:
LogicalSize
&
aBorderPadding
mozilla
:
:
ComputeSizeFlags
aFlags
)
override
;
virtual
nsRect
ComputeTightBounds
(
DrawTarget
*
aDrawTarget
)
const
override
;
virtual
void
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
override
;
virtual
nsresult
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
override
;
virtual
bool
CanContinueTextRun
(
)
const
override
;
virtual
void
PullOverflowsFromPrevInFlow
(
)
override
;
virtual
nscoord
GetLogicalBaseline
(
mozilla
:
:
WritingMode
aWritingMode
)
const
override
;
virtual
bool
DrainSelfOverflowList
(
)
override
;
bool
IsFirst
(
)
const
{
return
HasAnyStateBits
(
NS_INLINE_FRAME_BIDI_VISUAL_STATE_IS_SET
)
?
HasAnyStateBits
(
NS_INLINE_FRAME_BIDI_VISUAL_IS_FIRST
)
:
!
GetPrevInFlow
(
)
;
}
bool
IsLast
(
)
const
{
return
HasAnyStateBits
(
NS_INLINE_FRAME_BIDI_VISUAL_STATE_IS_SET
)
?
HasAnyStateBits
(
NS_INLINE_FRAME_BIDI_VISUAL_IS_LAST
)
:
!
GetNextInFlow
(
)
;
}
void
UpdateStyleOfOwnedAnonBoxesForIBSplit
(
mozilla
:
:
ServoRestyleState
&
aRestyleState
)
;
protected
:
struct
InlineReflowInput
{
nsIFrame
*
mPrevFrame
;
nsInlineFrame
*
mNextInFlow
;
nsIFrame
*
mLineContainer
;
nsLineLayout
*
mLineLayout
;
bool
mSetParentPointer
;
InlineReflowInput
(
)
{
mPrevFrame
=
nullptr
;
mNextInFlow
=
nullptr
;
mLineContainer
=
nullptr
;
mLineLayout
=
nullptr
;
mSetParentPointer
=
false
;
}
}
;
nsInlineFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
ClassID
aID
)
:
nsContainerFrame
(
aStyle
aPresContext
aID
)
mBaseline
(
NS_INTRINSIC_ISIZE_UNKNOWN
)
{
}
LogicalSides
GetLogicalSkipSides
(
const
Maybe
<
SkipSidesDuringReflow
>
&
)
const
override
;
void
ReflowFrames
(
nsPresContext
*
aPresContext
const
ReflowInput
&
aReflowInput
InlineReflowInput
&
rs
ReflowOutput
&
aMetrics
nsReflowStatus
&
aStatus
)
;
void
ReflowInlineFrame
(
nsPresContext
*
aPresContext
const
ReflowInput
&
aReflowInput
InlineReflowInput
&
rs
nsIFrame
*
aFrame
nsReflowStatus
&
aStatus
)
;
static
bool
HasFramesToPull
(
nsInlineFrame
*
aNextInFlow
)
;
virtual
nsIFrame
*
PullOneFrame
(
nsPresContext
*
InlineReflowInput
&
)
;
virtual
void
PushFrames
(
nsPresContext
*
aPresContext
nsIFrame
*
aFromChild
nsIFrame
*
aPrevSibling
InlineReflowInput
&
aState
)
;
private
:
explicit
nsInlineFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
:
nsInlineFrame
(
aStyle
aPresContext
kClassID
)
{
}
bool
DrainSelfOverflowListInternal
(
bool
aInFirstLine
)
;
protected
:
nscoord
mBaseline
;
}
;
class
nsFirstLineFrame
final
:
public
nsInlineFrame
{
public
:
NS_DECL_FRAMEARENA_HELPERS
(
nsFirstLineFrame
)
friend
nsFirstLineFrame
*
NS_NewFirstLineFrame
(
mozilla
:
:
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
#
ifdef
DEBUG_FRAME_DUMP
virtual
nsresult
GetFrameName
(
nsAString
&
aResult
)
const
override
;
#
endif
virtual
void
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
override
;
virtual
void
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
override
;
virtual
void
PullOverflowsFromPrevInFlow
(
)
override
;
virtual
bool
DrainSelfOverflowList
(
)
override
;
protected
:
explicit
nsFirstLineFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
:
nsInlineFrame
(
aStyle
aPresContext
kClassID
)
{
}
nsIFrame
*
PullOneFrame
(
nsPresContext
*
InlineReflowInput
&
)
override
;
}
;
#
endif
