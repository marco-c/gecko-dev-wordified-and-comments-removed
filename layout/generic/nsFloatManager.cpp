#
include
"
nsFloatManager
.
h
"
#
include
<
algorithm
>
#
include
<
initializer_list
>
#
include
"
mozilla
/
ReflowInput
.
h
"
#
include
"
mozilla
/
ShapeUtils
.
h
"
#
include
"
nsBlockFrame
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsMemory
.
h
"
using
namespace
mozilla
;
int32_t
nsFloatManager
:
:
sCachedFloatManagerCount
=
0
;
void
*
nsFloatManager
:
:
sCachedFloatManagers
[
NS_FLOAT_MANAGER_CACHE_SIZE
]
;
static
void
*
PSArenaAllocCB
(
size_t
aSize
void
*
aClosure
)
{
return
static_cast
<
nsIPresShell
*
>
(
aClosure
)
-
>
AllocateMisc
(
aSize
)
;
}
static
void
PSArenaFreeCB
(
size_t
aSize
void
*
aPtr
void
*
aClosure
)
{
static_cast
<
nsIPresShell
*
>
(
aClosure
)
-
>
FreeMisc
(
aSize
aPtr
)
;
}
nsFloatManager
:
:
nsFloatManager
(
nsIPresShell
*
aPresShell
mozilla
:
:
WritingMode
aWM
)
:
#
ifdef
DEBUG
mWritingMode
(
aWM
)
#
endif
mLineLeft
(
0
)
mBlockStart
(
0
)
mFloatDamage
(
PSArenaAllocCB
PSArenaFreeCB
aPresShell
)
mPushedLeftFloatPastBreak
(
false
)
mPushedRightFloatPastBreak
(
false
)
mSplitLeftFloatAcrossBreak
(
false
)
mSplitRightFloatAcrossBreak
(
false
)
{
MOZ_COUNT_CTOR
(
nsFloatManager
)
;
}
nsFloatManager
:
:
~
nsFloatManager
(
)
{
MOZ_COUNT_DTOR
(
nsFloatManager
)
;
}
void
*
nsFloatManager
:
:
operator
new
(
size_t
aSize
)
CPP_THROW_NEW
{
if
(
sCachedFloatManagerCount
>
0
)
{
return
sCachedFloatManagers
[
-
-
sCachedFloatManagerCount
]
;
}
return
moz_xmalloc
(
aSize
)
;
}
void
nsFloatManager
:
:
operator
delete
(
void
*
aPtr
size_t
aSize
)
{
if
(
!
aPtr
)
return
;
if
(
sCachedFloatManagerCount
<
NS_FLOAT_MANAGER_CACHE_SIZE
&
&
sCachedFloatManagerCount
>
=
0
)
{
sCachedFloatManagers
[
sCachedFloatManagerCount
+
+
]
=
aPtr
;
return
;
}
free
(
aPtr
)
;
}
void
nsFloatManager
:
:
Shutdown
(
)
{
int32_t
i
;
for
(
i
=
0
;
i
<
sCachedFloatManagerCount
;
i
+
+
)
{
void
*
floatManager
=
sCachedFloatManagers
[
i
]
;
if
(
floatManager
)
free
(
floatManager
)
;
}
sCachedFloatManagerCount
=
-
1
;
}
#
define
CHECK_BLOCK_AND_LINE_DIR
(
aWM
)
\
NS_ASSERTION
(
(
aWM
)
.
GetBlockDir
(
)
=
=
mWritingMode
.
GetBlockDir
(
)
&
&
\
(
aWM
)
.
IsLineInverted
(
)
=
=
mWritingMode
.
IsLineInverted
(
)
\
"
incompatible
writing
modes
"
)
nsFlowAreaRect
nsFloatManager
:
:
GetFlowArea
(
WritingMode
aWM
nscoord
aBCoord
nscoord
aBSize
BandInfoType
aBandInfoType
ShapeType
aShapeType
LogicalRect
aContentArea
SavedState
*
aState
const
nsSize
&
aContainerSize
)
const
{
CHECK_BLOCK_AND_LINE_DIR
(
aWM
)
;
NS_ASSERTION
(
aBSize
>
=
0
"
unexpected
max
block
size
"
)
;
NS_ASSERTION
(
aContentArea
.
ISize
(
aWM
)
>
=
0
"
unexpected
content
area
inline
size
"
)
;
nscoord
blockStart
=
aBCoord
+
mBlockStart
;
if
(
blockStart
<
nscoord_MIN
)
{
NS_WARNING
(
"
bad
value
"
)
;
blockStart
=
nscoord_MIN
;
}
uint32_t
floatCount
;
if
(
aState
)
{
floatCount
=
aState
-
>
mFloatInfoCount
;
MOZ_ASSERT
(
floatCount
<
=
mFloats
.
Length
(
)
"
bad
state
"
)
;
}
else
{
floatCount
=
mFloats
.
Length
(
)
;
}
if
(
floatCount
=
=
0
|
|
(
mFloats
[
floatCount
-
1
]
.
mLeftBEnd
<
=
blockStart
&
&
mFloats
[
floatCount
-
1
]
.
mRightBEnd
<
=
blockStart
)
)
{
return
nsFlowAreaRect
(
aWM
aContentArea
.
IStart
(
aWM
)
aBCoord
aContentArea
.
ISize
(
aWM
)
aBSize
false
)
;
}
nscoord
blockEnd
;
if
(
aBSize
=
=
nscoord_MAX
)
{
NS_WARNING_ASSERTION
(
aBandInfoType
=
=
BandInfoType
:
:
BandFromPoint
"
bad
height
"
)
;
blockEnd
=
nscoord_MAX
;
}
else
{
blockEnd
=
blockStart
+
aBSize
;
if
(
blockEnd
<
blockStart
|
|
blockEnd
>
nscoord_MAX
)
{
NS_WARNING
(
"
bad
value
"
)
;
blockEnd
=
nscoord_MAX
;
}
}
nscoord
lineLeft
=
mLineLeft
+
aContentArea
.
LineLeft
(
aWM
aContainerSize
)
;
nscoord
lineRight
=
mLineLeft
+
aContentArea
.
LineRight
(
aWM
aContainerSize
)
;
if
(
lineRight
<
lineLeft
)
{
NS_WARNING
(
"
bad
value
"
)
;
lineRight
=
lineLeft
;
}
bool
haveFloats
=
false
;
for
(
uint32_t
i
=
floatCount
;
i
>
0
;
-
-
i
)
{
const
FloatInfo
&
fi
=
mFloats
[
i
-
1
]
;
if
(
fi
.
mLeftBEnd
<
=
blockStart
&
&
fi
.
mRightBEnd
<
=
blockStart
)
{
break
;
}
if
(
fi
.
IsEmpty
(
aShapeType
)
)
{
continue
;
}
nscoord
floatBStart
=
fi
.
BStart
(
aShapeType
)
;
nscoord
floatBEnd
=
fi
.
BEnd
(
aShapeType
)
;
if
(
blockStart
<
floatBStart
&
&
aBandInfoType
=
=
BandInfoType
:
:
BandFromPoint
)
{
if
(
floatBStart
<
blockEnd
)
{
blockEnd
=
floatBStart
;
}
}
else
if
(
blockStart
<
floatBEnd
&
&
(
floatBStart
<
blockEnd
|
|
(
floatBStart
=
=
blockEnd
&
&
blockStart
=
=
blockEnd
)
)
)
{
StyleFloat
floatStyle
=
fi
.
mFrame
-
>
StyleDisplay
(
)
-
>
PhysicalFloats
(
aWM
)
;
const
nscoord
bandBlockEnd
=
aBandInfoType
=
=
BandInfoType
:
:
BandFromPoint
?
blockStart
:
blockEnd
;
if
(
floatStyle
=
=
StyleFloat
:
:
Left
)
{
nscoord
lineRightEdge
=
fi
.
LineRight
(
aShapeType
blockStart
bandBlockEnd
)
;
if
(
lineRightEdge
>
lineLeft
)
{
lineLeft
=
lineRightEdge
;
haveFloats
=
true
;
}
}
else
{
nscoord
lineLeftEdge
=
fi
.
LineLeft
(
aShapeType
blockStart
bandBlockEnd
)
;
if
(
lineLeftEdge
<
lineRight
)
{
lineRight
=
lineLeftEdge
;
haveFloats
=
true
;
}
}
if
(
floatBEnd
<
blockEnd
&
&
aBandInfoType
=
=
BandInfoType
:
:
BandFromPoint
)
{
blockEnd
=
floatBEnd
;
}
}
}
nscoord
blockSize
=
(
blockEnd
=
=
nscoord_MAX
)
?
nscoord_MAX
:
(
blockEnd
-
blockStart
)
;
nscoord
inlineStart
=
aWM
.
IsBidiLTR
(
)
?
lineLeft
-
mLineLeft
:
mLineLeft
-
lineRight
+
LogicalSize
(
aWM
aContainerSize
)
.
ISize
(
aWM
)
;
return
nsFlowAreaRect
(
aWM
inlineStart
blockStart
-
mBlockStart
lineRight
-
lineLeft
blockSize
haveFloats
)
;
}
void
nsFloatManager
:
:
AddFloat
(
nsIFrame
*
aFloatFrame
const
LogicalRect
&
aMarginRect
WritingMode
aWM
const
nsSize
&
aContainerSize
)
{
CHECK_BLOCK_AND_LINE_DIR
(
aWM
)
;
NS_ASSERTION
(
aMarginRect
.
ISize
(
aWM
)
>
=
0
"
negative
inline
size
!
"
)
;
NS_ASSERTION
(
aMarginRect
.
BSize
(
aWM
)
>
=
0
"
negative
block
size
!
"
)
;
FloatInfo
info
(
aFloatFrame
mLineLeft
mBlockStart
aMarginRect
aWM
aContainerSize
)
;
if
(
HasAnyFloats
(
)
)
{
FloatInfo
&
tail
=
mFloats
[
mFloats
.
Length
(
)
-
1
]
;
info
.
mLeftBEnd
=
tail
.
mLeftBEnd
;
info
.
mRightBEnd
=
tail
.
mRightBEnd
;
}
else
{
info
.
mLeftBEnd
=
nscoord_MIN
;
info
.
mRightBEnd
=
nscoord_MIN
;
}
StyleFloat
floatStyle
=
aFloatFrame
-
>
StyleDisplay
(
)
-
>
PhysicalFloats
(
aWM
)
;
MOZ_ASSERT
(
floatStyle
=
=
StyleFloat
:
:
Left
|
|
floatStyle
=
=
StyleFloat
:
:
Right
"
Unexpected
float
style
!
"
)
;
nscoord
&
sideBEnd
=
floatStyle
=
=
StyleFloat
:
:
Left
?
info
.
mLeftBEnd
:
info
.
mRightBEnd
;
nscoord
thisBEnd
=
info
.
BEnd
(
)
;
if
(
thisBEnd
>
sideBEnd
)
sideBEnd
=
thisBEnd
;
mFloats
.
AppendElement
(
Move
(
info
)
)
;
}
LogicalRect
nsFloatManager
:
:
CalculateRegionFor
(
WritingMode
aWM
nsIFrame
*
aFloat
const
LogicalMargin
&
aMargin
const
nsSize
&
aContainerSize
)
{
LogicalRect
region
(
aWM
nsRect
(
aFloat
-
>
GetNormalPosition
(
)
aFloat
-
>
GetSize
(
)
)
aContainerSize
)
;
region
.
Inflate
(
aWM
aMargin
)
;
if
(
region
.
ISize
(
aWM
)
<
0
)
{
const
nsStyleDisplay
*
display
=
aFloat
-
>
StyleDisplay
(
)
;
StyleFloat
floatStyle
=
display
-
>
PhysicalFloats
(
aWM
)
;
if
(
(
StyleFloat
:
:
Left
=
=
floatStyle
)
=
=
aWM
.
IsBidiLTR
(
)
)
{
region
.
IStart
(
aWM
)
=
region
.
IEnd
(
aWM
)
;
}
region
.
ISize
(
aWM
)
=
0
;
}
if
(
region
.
BSize
(
aWM
)
<
0
)
{
region
.
BSize
(
aWM
)
=
0
;
}
return
region
;
}
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
FloatRegionProperty
nsMargin
)
LogicalRect
nsFloatManager
:
:
GetRegionFor
(
WritingMode
aWM
nsIFrame
*
aFloat
const
nsSize
&
aContainerSize
)
{
LogicalRect
region
=
aFloat
-
>
GetLogicalRect
(
aWM
aContainerSize
)
;
void
*
storedRegion
=
aFloat
-
>
Properties
(
)
.
Get
(
FloatRegionProperty
(
)
)
;
if
(
storedRegion
)
{
nsMargin
margin
=
*
static_cast
<
nsMargin
*
>
(
storedRegion
)
;
region
.
Inflate
(
aWM
LogicalMargin
(
aWM
margin
)
)
;
}
return
region
;
}
void
nsFloatManager
:
:
StoreRegionFor
(
WritingMode
aWM
nsIFrame
*
aFloat
const
LogicalRect
&
aRegion
const
nsSize
&
aContainerSize
)
{
nsRect
region
=
aRegion
.
GetPhysicalRect
(
aWM
aContainerSize
)
;
nsRect
rect
=
aFloat
-
>
GetRect
(
)
;
FrameProperties
props
=
aFloat
-
>
Properties
(
)
;
if
(
region
.
IsEqualEdges
(
rect
)
)
{
props
.
Delete
(
FloatRegionProperty
(
)
)
;
}
else
{
nsMargin
*
storedMargin
=
props
.
Get
(
FloatRegionProperty
(
)
)
;
if
(
!
storedMargin
)
{
storedMargin
=
new
nsMargin
(
)
;
props
.
Set
(
FloatRegionProperty
(
)
storedMargin
)
;
}
*
storedMargin
=
region
-
rect
;
}
}
nsresult
nsFloatManager
:
:
RemoveTrailingRegions
(
nsIFrame
*
aFrameList
)
{
if
(
!
aFrameList
)
{
return
NS_OK
;
}
nsTHashtable
<
nsPtrHashKey
<
nsIFrame
>
>
frameSet
(
1
)
;
for
(
nsIFrame
*
f
=
aFrameList
;
f
;
f
=
f
-
>
GetNextSibling
(
)
)
{
frameSet
.
PutEntry
(
f
)
;
}
uint32_t
newLength
=
mFloats
.
Length
(
)
;
while
(
newLength
>
0
)
{
if
(
!
frameSet
.
Contains
(
mFloats
[
newLength
-
1
]
.
mFrame
)
)
{
break
;
}
-
-
newLength
;
}
mFloats
.
TruncateLength
(
newLength
)
;
#
ifdef
DEBUG
for
(
uint32_t
i
=
0
;
i
<
mFloats
.
Length
(
)
;
+
+
i
)
{
NS_ASSERTION
(
!
frameSet
.
Contains
(
mFloats
[
i
]
.
mFrame
)
"
Frame
region
deletion
was
requested
but
we
couldn
'
t
delete
it
"
)
;
}
#
endif
return
NS_OK
;
}
void
nsFloatManager
:
:
PushState
(
SavedState
*
aState
)
{
NS_PRECONDITION
(
aState
"
Need
a
place
to
save
state
"
)
;
aState
-
>
mLineLeft
=
mLineLeft
;
aState
-
>
mBlockStart
=
mBlockStart
;
aState
-
>
mPushedLeftFloatPastBreak
=
mPushedLeftFloatPastBreak
;
aState
-
>
mPushedRightFloatPastBreak
=
mPushedRightFloatPastBreak
;
aState
-
>
mSplitLeftFloatAcrossBreak
=
mSplitLeftFloatAcrossBreak
;
aState
-
>
mSplitRightFloatAcrossBreak
=
mSplitRightFloatAcrossBreak
;
aState
-
>
mFloatInfoCount
=
mFloats
.
Length
(
)
;
}
void
nsFloatManager
:
:
PopState
(
SavedState
*
aState
)
{
NS_PRECONDITION
(
aState
"
No
state
to
restore
?
"
)
;
mLineLeft
=
aState
-
>
mLineLeft
;
mBlockStart
=
aState
-
>
mBlockStart
;
mPushedLeftFloatPastBreak
=
aState
-
>
mPushedLeftFloatPastBreak
;
mPushedRightFloatPastBreak
=
aState
-
>
mPushedRightFloatPastBreak
;
mSplitLeftFloatAcrossBreak
=
aState
-
>
mSplitLeftFloatAcrossBreak
;
mSplitRightFloatAcrossBreak
=
aState
-
>
mSplitRightFloatAcrossBreak
;
NS_ASSERTION
(
aState
-
>
mFloatInfoCount
<
=
mFloats
.
Length
(
)
"
somebody
misused
PushState
/
PopState
"
)
;
mFloats
.
TruncateLength
(
aState
-
>
mFloatInfoCount
)
;
}
nscoord
nsFloatManager
:
:
GetLowestFloatTop
(
)
const
{
if
(
mPushedLeftFloatPastBreak
|
|
mPushedRightFloatPastBreak
)
{
return
nscoord_MAX
;
}
if
(
!
HasAnyFloats
(
)
)
{
return
nscoord_MIN
;
}
return
mFloats
[
mFloats
.
Length
(
)
-
1
]
.
BStart
(
)
-
mBlockStart
;
}
#
ifdef
DEBUG_FRAME_DUMP
void
DebugListFloatManager
(
const
nsFloatManager
*
aFloatManager
)
{
aFloatManager
-
>
List
(
stdout
)
;
}
nsresult
nsFloatManager
:
:
List
(
FILE
*
out
)
const
{
if
(
!
HasAnyFloats
(
)
)
return
NS_OK
;
for
(
uint32_t
i
=
0
;
i
<
mFloats
.
Length
(
)
;
+
+
i
)
{
const
FloatInfo
&
fi
=
mFloats
[
i
]
;
fprintf_stderr
(
out
"
Float
%
u
:
frame
=
%
p
rect
=
{
%
d
%
d
%
d
%
d
}
BEnd
=
{
l
:
%
d
r
:
%
d
}
\
n
"
i
static_cast
<
void
*
>
(
fi
.
mFrame
)
fi
.
LineLeft
(
)
fi
.
BStart
(
)
fi
.
ISize
(
)
fi
.
BSize
(
)
fi
.
mLeftBEnd
fi
.
mRightBEnd
)
;
}
return
NS_OK
;
}
#
endif
nscoord
nsFloatManager
:
:
ClearFloats
(
nscoord
aBCoord
StyleClear
aBreakType
uint32_t
aFlags
)
const
{
if
(
!
(
aFlags
&
DONT_CLEAR_PUSHED_FLOATS
)
&
&
ClearContinues
(
aBreakType
)
)
{
return
nscoord_MAX
;
}
if
(
!
HasAnyFloats
(
)
)
{
return
aBCoord
;
}
nscoord
blockEnd
=
aBCoord
+
mBlockStart
;
const
FloatInfo
&
tail
=
mFloats
[
mFloats
.
Length
(
)
-
1
]
;
switch
(
aBreakType
)
{
case
StyleClear
:
:
Both
:
blockEnd
=
std
:
:
max
(
blockEnd
tail
.
mLeftBEnd
)
;
blockEnd
=
std
:
:
max
(
blockEnd
tail
.
mRightBEnd
)
;
break
;
case
StyleClear
:
:
Left
:
blockEnd
=
std
:
:
max
(
blockEnd
tail
.
mLeftBEnd
)
;
break
;
case
StyleClear
:
:
Right
:
blockEnd
=
std
:
:
max
(
blockEnd
tail
.
mRightBEnd
)
;
break
;
default
:
break
;
}
blockEnd
-
=
mBlockStart
;
return
blockEnd
;
}
bool
nsFloatManager
:
:
ClearContinues
(
StyleClear
aBreakType
)
const
{
return
(
(
mPushedLeftFloatPastBreak
|
|
mSplitLeftFloatAcrossBreak
)
&
&
(
aBreakType
=
=
StyleClear
:
:
Both
|
|
aBreakType
=
=
StyleClear
:
:
Left
)
)
|
|
(
(
mPushedRightFloatPastBreak
|
|
mSplitRightFloatAcrossBreak
)
&
&
(
aBreakType
=
=
StyleClear
:
:
Both
|
|
aBreakType
=
=
StyleClear
:
:
Right
)
)
;
}
nscoord
nsFloatManager
:
:
RoundedBoxShapeInfo
:
:
LineLeft
(
const
nscoord
aBStart
const
nscoord
aBEnd
)
const
{
if
(
!
mRadii
)
{
return
mRect
.
x
;
}
nscoord
lineLeftDiff
=
ComputeEllipseLineInterceptDiff
(
mRect
.
y
mRect
.
YMost
(
)
mRadii
[
eCornerTopLeftX
]
mRadii
[
eCornerTopLeftY
]
mRadii
[
eCornerBottomLeftX
]
mRadii
[
eCornerBottomLeftY
]
aBStart
aBEnd
)
;
return
mRect
.
x
+
lineLeftDiff
;
}
nscoord
nsFloatManager
:
:
RoundedBoxShapeInfo
:
:
LineRight
(
const
nscoord
aBStart
const
nscoord
aBEnd
)
const
{
if
(
!
mRadii
)
{
return
mRect
.
XMost
(
)
;
}
nscoord
lineRightDiff
=
ComputeEllipseLineInterceptDiff
(
mRect
.
y
mRect
.
YMost
(
)
mRadii
[
eCornerTopRightX
]
mRadii
[
eCornerTopRightY
]
mRadii
[
eCornerBottomRightX
]
mRadii
[
eCornerBottomRightY
]
aBStart
aBEnd
)
;
return
mRect
.
XMost
(
)
-
lineRightDiff
;
}
nscoord
nsFloatManager
:
:
EllipseShapeInfo
:
:
LineLeft
(
const
nscoord
aBStart
const
nscoord
aBEnd
)
const
{
nscoord
lineLeftDiff
=
ComputeEllipseLineInterceptDiff
(
BStart
(
)
BEnd
(
)
mRadii
.
width
mRadii
.
height
mRadii
.
width
mRadii
.
height
aBStart
aBEnd
)
;
return
mCenter
.
x
-
mRadii
.
width
+
lineLeftDiff
;
}
nscoord
nsFloatManager
:
:
EllipseShapeInfo
:
:
LineRight
(
const
nscoord
aBStart
const
nscoord
aBEnd
)
const
{
nscoord
lineRightDiff
=
ComputeEllipseLineInterceptDiff
(
BStart
(
)
BEnd
(
)
mRadii
.
width
mRadii
.
height
mRadii
.
width
mRadii
.
height
aBStart
aBEnd
)
;
return
mCenter
.
x
+
mRadii
.
width
-
lineRightDiff
;
}
nsFloatManager
:
:
PolygonShapeInfo
:
:
PolygonShapeInfo
(
nsTArray
<
nsPoint
>
&
&
aVertices
)
:
mVertices
(
aVertices
)
{
if
(
mVertices
.
Length
(
)
<
3
)
{
mEmpty
=
true
;
return
;
}
auto
Determinant
=
[
]
(
const
nsPoint
&
aP0
const
nsPoint
&
aP1
)
{
return
aP0
.
x
*
aP1
.
y
-
aP0
.
y
*
aP1
.
x
;
}
;
bool
isEntirelyCollinear
=
true
;
const
nsPoint
&
p0
=
mVertices
[
0
]
;
const
nsPoint
&
p1
=
mVertices
[
1
]
;
for
(
size_t
i
=
2
;
i
<
mVertices
.
Length
(
)
;
+
+
i
)
{
const
nsPoint
&
p2
=
mVertices
[
i
]
;
if
(
Determinant
(
p2
-
p0
p1
-
p0
)
!
=
0
)
{
isEntirelyCollinear
=
false
;
break
;
}
}
if
(
isEntirelyCollinear
)
{
mEmpty
=
true
;
return
;
}
for
(
const
nsPoint
&
vertex
:
mVertices
)
{
mBStart
=
std
:
:
min
(
mBStart
vertex
.
y
)
;
mBEnd
=
std
:
:
max
(
mBEnd
vertex
.
y
)
;
}
}
nscoord
nsFloatManager
:
:
PolygonShapeInfo
:
:
LineLeft
(
const
nscoord
aBStart
const
nscoord
aBEnd
)
const
{
MOZ_ASSERT
(
!
mEmpty
"
Shouldn
'
t
be
called
if
the
polygon
encloses
no
area
.
"
)
;
return
ComputeLineIntercept
(
aBStart
aBEnd
std
:
:
min
<
nscoord
>
nscoord_MAX
)
;
}
nscoord
nsFloatManager
:
:
PolygonShapeInfo
:
:
LineRight
(
const
nscoord
aBStart
const
nscoord
aBEnd
)
const
{
MOZ_ASSERT
(
!
mEmpty
"
Shouldn
'
t
be
called
if
the
polygon
encloses
no
area
.
"
)
;
return
ComputeLineIntercept
(
aBStart
aBEnd
std
:
:
max
<
nscoord
>
nscoord_MIN
)
;
}
nscoord
nsFloatManager
:
:
PolygonShapeInfo
:
:
ComputeLineIntercept
(
const
nscoord
aBStart
const
nscoord
aBEnd
nscoord
(
*
aCompareOp
)
(
std
:
:
initializer_list
<
nscoord
>
)
const
nscoord
aLineInterceptInitialValue
)
const
{
MOZ_ASSERT
(
aBStart
<
=
aBEnd
"
The
band
'
s
block
start
is
greater
than
its
block
end
?
"
)
;
const
size_t
len
=
mVertices
.
Length
(
)
;
nscoord
lineIntercept
=
aLineInterceptInitialValue
;
for
(
size_t
i
=
0
;
i
<
len
;
+
+
i
)
{
const
nsPoint
*
smallYVertex
=
&
mVertices
[
i
]
;
const
nsPoint
*
bigYVertex
=
&
mVertices
[
(
i
+
1
)
%
len
]
;
if
(
smallYVertex
-
>
y
>
bigYVertex
-
>
y
)
{
std
:
:
swap
(
smallYVertex
bigYVertex
)
;
}
if
(
aBStart
>
=
bigYVertex
-
>
y
|
|
aBEnd
<
=
smallYVertex
-
>
y
|
|
smallYVertex
-
>
y
=
=
bigYVertex
-
>
y
)
{
continue
;
}
nscoord
bStartLineIntercept
=
aBStart
<
=
smallYVertex
-
>
y
?
smallYVertex
-
>
x
:
XInterceptAtY
(
aBStart
*
smallYVertex
*
bigYVertex
)
;
nscoord
bEndLineIntercept
=
aBEnd
>
=
bigYVertex
-
>
y
?
bigYVertex
-
>
x
:
XInterceptAtY
(
aBEnd
*
smallYVertex
*
bigYVertex
)
;
lineIntercept
=
aCompareOp
(
{
lineIntercept
bStartLineIntercept
bEndLineIntercept
}
)
;
}
return
lineIntercept
;
}
void
nsFloatManager
:
:
PolygonShapeInfo
:
:
Translate
(
nscoord
aLineLeft
nscoord
aBlockStart
)
{
for
(
nsPoint
&
vertex
:
mVertices
)
{
vertex
.
MoveBy
(
aLineLeft
aBlockStart
)
;
}
mBStart
+
=
aBlockStart
;
mBEnd
+
=
aBlockStart
;
}
nscoord
nsFloatManager
:
:
PolygonShapeInfo
:
:
XInterceptAtY
(
const
nscoord
aY
const
nsPoint
&
aP1
const
nsPoint
&
aP2
)
{
MOZ_ASSERT
(
aP1
.
y
<
=
aY
&
&
aY
<
=
aP2
.
y
"
This
function
won
'
t
work
if
the
horizontal
line
at
aY
and
"
"
the
line
segment
(
aP1
aP2
)
do
not
intersect
!
"
)
;
MOZ_ASSERT
(
aP1
.
y
!
=
aP2
.
y
"
A
horizontal
line
segment
results
in
dividing
by
zero
error
!
"
)
;
return
aP1
.
x
+
(
aY
-
aP1
.
y
)
*
(
aP2
.
x
-
aP1
.
x
)
/
(
aP2
.
y
-
aP1
.
y
)
;
}
nsFloatManager
:
:
FloatInfo
:
:
FloatInfo
(
nsIFrame
*
aFrame
nscoord
aLineLeft
nscoord
aBlockStart
const
LogicalRect
&
aMarginRect
WritingMode
aWM
const
nsSize
&
aContainerSize
)
:
mFrame
(
aFrame
)
mRect
(
ShapeInfo
:
:
ConvertToFloatLogical
(
aMarginRect
aWM
aContainerSize
)
+
nsPoint
(
aLineLeft
aBlockStart
)
)
{
MOZ_COUNT_CTOR
(
nsFloatManager
:
:
FloatInfo
)
;
const
StyleShapeSource
&
shapeOutside
=
mFrame
-
>
StyleDisplay
(
)
-
>
mShapeOutside
;
if
(
shapeOutside
.
GetType
(
)
=
=
StyleShapeSourceType
:
:
None
)
{
return
;
}
if
(
shapeOutside
.
GetType
(
)
=
=
StyleShapeSourceType
:
:
URL
)
{
return
;
}
LogicalRect
shapeBoxRect
=
ShapeInfo
:
:
ComputeShapeBoxRect
(
shapeOutside
mFrame
aMarginRect
aWM
)
;
if
(
shapeOutside
.
GetType
(
)
=
=
StyleShapeSourceType
:
:
Box
)
{
mShapeInfo
=
ShapeInfo
:
:
CreateShapeBox
(
mFrame
shapeBoxRect
aWM
aContainerSize
)
;
}
else
if
(
shapeOutside
.
GetType
(
)
=
=
StyleShapeSourceType
:
:
Shape
)
{
StyleBasicShape
*
const
basicShape
=
shapeOutside
.
GetBasicShape
(
)
;
switch
(
basicShape
-
>
GetShapeType
(
)
)
{
case
StyleBasicShapeType
:
:
Polygon
:
mShapeInfo
=
ShapeInfo
:
:
CreatePolygon
(
basicShape
shapeBoxRect
aWM
aContainerSize
)
;
break
;
case
StyleBasicShapeType
:
:
Circle
:
case
StyleBasicShapeType
:
:
Ellipse
:
mShapeInfo
=
ShapeInfo
:
:
CreateCircleOrEllipse
(
basicShape
shapeBoxRect
aWM
aContainerSize
)
;
break
;
case
StyleBasicShapeType
:
:
Inset
:
mShapeInfo
=
ShapeInfo
:
:
CreateInset
(
basicShape
shapeBoxRect
aWM
aContainerSize
)
;
break
;
}
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
StyleShapeSourceType
!
"
)
;
}
MOZ_ASSERT
(
mShapeInfo
"
All
shape
-
outside
values
except
none
should
have
mShapeInfo
!
"
)
;
mShapeInfo
-
>
Translate
(
aLineLeft
aBlockStart
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
nsFloatManager
:
:
FloatInfo
:
:
FloatInfo
(
FloatInfo
&
&
aOther
)
:
mFrame
(
Move
(
aOther
.
mFrame
)
)
mLeftBEnd
(
Move
(
aOther
.
mLeftBEnd
)
)
mRightBEnd
(
Move
(
aOther
.
mRightBEnd
)
)
mRect
(
Move
(
aOther
.
mRect
)
)
mShapeInfo
(
Move
(
aOther
.
mShapeInfo
)
)
{
MOZ_COUNT_CTOR
(
nsFloatManager
:
:
FloatInfo
)
;
}
nsFloatManager
:
:
FloatInfo
:
:
~
FloatInfo
(
)
{
MOZ_COUNT_DTOR
(
nsFloatManager
:
:
FloatInfo
)
;
}
#
endif
nscoord
nsFloatManager
:
:
FloatInfo
:
:
LineLeft
(
ShapeType
aShapeType
const
nscoord
aBStart
const
nscoord
aBEnd
)
const
{
if
(
aShapeType
=
=
ShapeType
:
:
Margin
)
{
return
LineLeft
(
)
;
}
MOZ_ASSERT
(
aShapeType
=
=
ShapeType
:
:
ShapeOutside
)
;
if
(
!
mShapeInfo
)
{
return
LineLeft
(
)
;
}
return
std
:
:
max
(
LineLeft
(
)
mShapeInfo
-
>
LineLeft
(
aBStart
aBEnd
)
)
;
}
nscoord
nsFloatManager
:
:
FloatInfo
:
:
LineRight
(
ShapeType
aShapeType
const
nscoord
aBStart
const
nscoord
aBEnd
)
const
{
if
(
aShapeType
=
=
ShapeType
:
:
Margin
)
{
return
LineRight
(
)
;
}
MOZ_ASSERT
(
aShapeType
=
=
ShapeType
:
:
ShapeOutside
)
;
if
(
!
mShapeInfo
)
{
return
LineRight
(
)
;
}
return
std
:
:
min
(
LineRight
(
)
mShapeInfo
-
>
LineRight
(
aBStart
aBEnd
)
)
;
}
nscoord
nsFloatManager
:
:
FloatInfo
:
:
BStart
(
ShapeType
aShapeType
)
const
{
if
(
aShapeType
=
=
ShapeType
:
:
Margin
)
{
return
BStart
(
)
;
}
MOZ_ASSERT
(
aShapeType
=
=
ShapeType
:
:
ShapeOutside
)
;
if
(
!
mShapeInfo
)
{
return
BStart
(
)
;
}
return
std
:
:
max
(
BStart
(
)
mShapeInfo
-
>
BStart
(
)
)
;
}
nscoord
nsFloatManager
:
:
FloatInfo
:
:
BEnd
(
ShapeType
aShapeType
)
const
{
if
(
aShapeType
=
=
ShapeType
:
:
Margin
)
{
return
BEnd
(
)
;
}
MOZ_ASSERT
(
aShapeType
=
=
ShapeType
:
:
ShapeOutside
)
;
if
(
!
mShapeInfo
)
{
return
BEnd
(
)
;
}
return
std
:
:
min
(
BEnd
(
)
mShapeInfo
-
>
BEnd
(
)
)
;
}
bool
nsFloatManager
:
:
FloatInfo
:
:
IsEmpty
(
ShapeType
aShapeType
)
const
{
if
(
aShapeType
=
=
ShapeType
:
:
Margin
)
{
return
IsEmpty
(
)
;
}
MOZ_ASSERT
(
aShapeType
=
=
ShapeType
:
:
ShapeOutside
)
;
if
(
!
mShapeInfo
)
{
return
IsEmpty
(
)
;
}
return
mShapeInfo
-
>
IsEmpty
(
)
;
}
LogicalRect
nsFloatManager
:
:
ShapeInfo
:
:
ComputeShapeBoxRect
(
const
StyleShapeSource
&
aShapeOutside
nsIFrame
*
const
aFrame
const
mozilla
:
:
LogicalRect
&
aMarginRect
mozilla
:
:
WritingMode
aWM
)
{
LogicalRect
rect
=
aMarginRect
;
switch
(
aShapeOutside
.
GetReferenceBox
(
)
)
{
case
StyleGeometryBox
:
:
ContentBox
:
rect
.
Deflate
(
aWM
aFrame
-
>
GetLogicalUsedPadding
(
aWM
)
)
;
MOZ_FALLTHROUGH
;
case
StyleGeometryBox
:
:
PaddingBox
:
rect
.
Deflate
(
aWM
aFrame
-
>
GetLogicalUsedBorder
(
aWM
)
)
;
MOZ_FALLTHROUGH
;
case
StyleGeometryBox
:
:
BorderBox
:
rect
.
Deflate
(
aWM
aFrame
-
>
GetLogicalUsedMargin
(
aWM
)
)
;
break
;
case
StyleGeometryBox
:
:
MarginBox
:
break
;
case
StyleGeometryBox
:
:
NoBox
:
default
:
MOZ_ASSERT
(
aShapeOutside
.
GetType
(
)
!
=
StyleShapeSourceType
:
:
Box
"
Box
source
type
must
have
<
shape
-
box
>
specified
!
"
)
;
break
;
}
return
rect
;
}
UniquePtr
<
nsFloatManager
:
:
ShapeInfo
>
nsFloatManager
:
:
ShapeInfo
:
:
CreateShapeBox
(
nsIFrame
*
const
aFrame
const
LogicalRect
&
aShapeBoxRect
WritingMode
aWM
const
nsSize
&
aContainerSize
)
{
nsRect
logicalShapeBoxRect
=
ConvertToFloatLogical
(
aShapeBoxRect
aWM
aContainerSize
)
;
nscoord
physicalRadii
[
8
]
;
bool
hasRadii
=
aFrame
-
>
GetShapeBoxBorderRadii
(
physicalRadii
)
;
if
(
!
hasRadii
)
{
return
MakeUnique
<
RoundedBoxShapeInfo
>
(
logicalShapeBoxRect
UniquePtr
<
nscoord
[
]
>
(
)
)
;
}
return
MakeUnique
<
RoundedBoxShapeInfo
>
(
logicalShapeBoxRect
ConvertToFloatLogical
(
physicalRadii
aWM
)
)
;
}
UniquePtr
<
nsFloatManager
:
:
ShapeInfo
>
nsFloatManager
:
:
ShapeInfo
:
:
CreateInset
(
const
StyleBasicShape
*
aBasicShape
const
LogicalRect
&
aShapeBoxRect
WritingMode
aWM
const
nsSize
&
aContainerSize
)
{
nsRect
physicalShapeBoxRect
=
aShapeBoxRect
.
GetPhysicalRect
(
aWM
aContainerSize
)
;
nsRect
insetRect
=
ShapeUtils
:
:
ComputeInsetRect
(
aBasicShape
physicalShapeBoxRect
)
;
nsRect
logicalInsetRect
=
ConvertToFloatLogical
(
LogicalRect
(
aWM
insetRect
aContainerSize
)
aWM
aContainerSize
)
;
nscoord
physicalRadii
[
8
]
;
bool
hasRadii
=
ShapeUtils
:
:
ComputeInsetRadii
(
aBasicShape
insetRect
physicalShapeBoxRect
physicalRadii
)
;
if
(
!
hasRadii
)
{
return
MakeUnique
<
RoundedBoxShapeInfo
>
(
logicalInsetRect
UniquePtr
<
nscoord
[
]
>
(
)
)
;
}
return
MakeUnique
<
RoundedBoxShapeInfo
>
(
logicalInsetRect
ConvertToFloatLogical
(
physicalRadii
aWM
)
)
;
}
UniquePtr
<
nsFloatManager
:
:
ShapeInfo
>
nsFloatManager
:
:
ShapeInfo
:
:
CreateCircleOrEllipse
(
const
StyleBasicShape
*
aBasicShape
const
LogicalRect
&
aShapeBoxRect
WritingMode
aWM
const
nsSize
&
aContainerSize
)
{
nsRect
physicalShapeBoxRect
=
aShapeBoxRect
.
GetPhysicalRect
(
aWM
aContainerSize
)
;
nsPoint
physicalCenter
=
ShapeUtils
:
:
ComputeCircleOrEllipseCenter
(
aBasicShape
physicalShapeBoxRect
)
;
nsPoint
logicalCenter
=
ConvertToFloatLogical
(
physicalCenter
aWM
aContainerSize
)
;
nsSize
radii
;
StyleBasicShapeType
type
=
aBasicShape
-
>
GetShapeType
(
)
;
if
(
type
=
=
StyleBasicShapeType
:
:
Circle
)
{
nscoord
radius
=
ShapeUtils
:
:
ComputeCircleRadius
(
aBasicShape
physicalCenter
physicalShapeBoxRect
)
;
radii
=
nsSize
(
radius
radius
)
;
}
else
{
MOZ_ASSERT
(
type
=
=
StyleBasicShapeType
:
:
Ellipse
)
;
nsSize
physicalRadii
=
ShapeUtils
:
:
ComputeEllipseRadii
(
aBasicShape
physicalCenter
physicalShapeBoxRect
)
;
LogicalSize
logicalRadii
(
aWM
physicalRadii
)
;
radii
=
nsSize
(
logicalRadii
.
ISize
(
aWM
)
logicalRadii
.
BSize
(
aWM
)
)
;
}
return
MakeUnique
<
EllipseShapeInfo
>
(
logicalCenter
radii
)
;
}
UniquePtr
<
nsFloatManager
:
:
ShapeInfo
>
nsFloatManager
:
:
ShapeInfo
:
:
CreatePolygon
(
const
StyleBasicShape
*
aBasicShape
const
LogicalRect
&
aShapeBoxRect
WritingMode
aWM
const
nsSize
&
aContainerSize
)
{
nsRect
physicalShapeBoxRect
=
aShapeBoxRect
.
GetPhysicalRect
(
aWM
aContainerSize
)
;
nsTArray
<
nsPoint
>
vertices
=
ShapeUtils
:
:
ComputePolygonVertices
(
aBasicShape
physicalShapeBoxRect
)
;
for
(
nsPoint
&
vertex
:
vertices
)
{
vertex
=
ConvertToFloatLogical
(
vertex
aWM
aContainerSize
)
;
}
return
MakeUnique
<
PolygonShapeInfo
>
(
Move
(
vertices
)
)
;
}
nscoord
nsFloatManager
:
:
ShapeInfo
:
:
ComputeEllipseLineInterceptDiff
(
const
nscoord
aShapeBoxBStart
const
nscoord
aShapeBoxBEnd
const
nscoord
aBStartCornerRadiusL
const
nscoord
aBStartCornerRadiusB
const
nscoord
aBEndCornerRadiusL
const
nscoord
aBEndCornerRadiusB
const
nscoord
aBandBStart
const
nscoord
aBandBEnd
)
{
NS_ASSERTION
(
aShapeBoxBStart
<
=
aShapeBoxBEnd
"
Bad
shape
box
coordinates
!
"
)
;
NS_ASSERTION
(
aBandBStart
<
=
aBandBEnd
"
Bad
band
coordinates
!
"
)
;
nscoord
lineDiff
=
0
;
if
(
aBStartCornerRadiusB
>
0
&
&
aBandBEnd
>
=
aShapeBoxBStart
&
&
aBandBEnd
<
=
aShapeBoxBStart
+
aBStartCornerRadiusB
)
{
nscoord
b
=
aBStartCornerRadiusB
-
(
aBandBEnd
-
aShapeBoxBStart
)
;
nscoord
lineIntercept
=
XInterceptAtY
(
b
aBStartCornerRadiusL
aBStartCornerRadiusB
)
;
lineDiff
=
aBStartCornerRadiusL
-
lineIntercept
;
}
else
if
(
aBEndCornerRadiusB
>
0
&
&
aBandBStart
>
=
aShapeBoxBEnd
-
aBEndCornerRadiusB
&
&
aBandBStart
<
=
aShapeBoxBEnd
)
{
nscoord
b
=
aBEndCornerRadiusB
-
(
aShapeBoxBEnd
-
aBandBStart
)
;
nscoord
lineIntercept
=
XInterceptAtY
(
b
aBEndCornerRadiusL
aBEndCornerRadiusB
)
;
lineDiff
=
aBEndCornerRadiusL
-
lineIntercept
;
}
return
lineDiff
;
}
nscoord
nsFloatManager
:
:
ShapeInfo
:
:
XInterceptAtY
(
const
nscoord
aY
const
nscoord
aRadiusX
const
nscoord
aRadiusY
)
{
MOZ_ASSERT
(
aRadiusY
>
0
)
;
return
aRadiusX
*
std
:
:
sqrt
(
1
-
(
aY
*
aY
)
/
double
(
aRadiusY
*
aRadiusY
)
)
;
}
nsPoint
nsFloatManager
:
:
ShapeInfo
:
:
ConvertToFloatLogical
(
const
nsPoint
&
aPoint
WritingMode
aWM
const
nsSize
&
aContainerSize
)
{
LogicalPoint
logicalPoint
(
aWM
aPoint
aContainerSize
)
;
return
nsPoint
(
logicalPoint
.
LineRelative
(
aWM
aContainerSize
)
logicalPoint
.
B
(
aWM
)
)
;
}
UniquePtr
<
nscoord
[
]
>
nsFloatManager
:
:
ShapeInfo
:
:
ConvertToFloatLogical
(
const
nscoord
aRadii
[
8
]
WritingMode
aWM
)
{
UniquePtr
<
nscoord
[
]
>
logicalRadii
(
new
nscoord
[
8
]
)
;
Side
lineLeftSide
=
aWM
.
PhysicalSide
(
aWM
.
LogicalSideForLineRelativeDir
(
eLineRelativeDirLeft
)
)
;
logicalRadii
[
eCornerTopLeftX
]
=
aRadii
[
SideToHalfCorner
(
lineLeftSide
true
false
)
]
;
logicalRadii
[
eCornerTopLeftY
]
=
aRadii
[
SideToHalfCorner
(
lineLeftSide
true
true
)
]
;
logicalRadii
[
eCornerBottomLeftX
]
=
aRadii
[
SideToHalfCorner
(
lineLeftSide
false
false
)
]
;
logicalRadii
[
eCornerBottomLeftY
]
=
aRadii
[
SideToHalfCorner
(
lineLeftSide
false
true
)
]
;
Side
lineRightSide
=
aWM
.
PhysicalSide
(
aWM
.
LogicalSideForLineRelativeDir
(
eLineRelativeDirRight
)
)
;
logicalRadii
[
eCornerTopRightX
]
=
aRadii
[
SideToHalfCorner
(
lineRightSide
false
false
)
]
;
logicalRadii
[
eCornerTopRightY
]
=
aRadii
[
SideToHalfCorner
(
lineRightSide
false
true
)
]
;
logicalRadii
[
eCornerBottomRightX
]
=
aRadii
[
SideToHalfCorner
(
lineRightSide
true
false
)
]
;
logicalRadii
[
eCornerBottomRightY
]
=
aRadii
[
SideToHalfCorner
(
lineRightSide
true
true
)
]
;
if
(
aWM
.
IsLineInverted
(
)
)
{
std
:
:
swap
(
logicalRadii
[
eCornerTopLeftX
]
logicalRadii
[
eCornerBottomLeftX
]
)
;
std
:
:
swap
(
logicalRadii
[
eCornerTopLeftY
]
logicalRadii
[
eCornerBottomLeftY
]
)
;
std
:
:
swap
(
logicalRadii
[
eCornerTopRightX
]
logicalRadii
[
eCornerBottomRightX
]
)
;
std
:
:
swap
(
logicalRadii
[
eCornerTopRightY
]
logicalRadii
[
eCornerBottomRightY
]
)
;
}
return
logicalRadii
;
}
nsAutoFloatManager
:
:
~
nsAutoFloatManager
(
)
{
if
(
mNew
)
{
#
ifdef
DEBUG
if
(
nsBlockFrame
:
:
gNoisyFloatManager
)
{
printf
(
"
restoring
old
float
manager
%
p
\
n
"
mOld
)
;
}
#
endif
mReflowInput
.
mFloatManager
=
mOld
;
#
ifdef
DEBUG
if
(
nsBlockFrame
:
:
gNoisyFloatManager
)
{
if
(
mOld
)
{
mReflowInput
.
mFrame
-
>
ListTag
(
stdout
)
;
printf
(
"
:
float
manager
%
p
after
reflow
\
n
"
mOld
)
;
mOld
-
>
List
(
stdout
)
;
}
}
#
endif
}
}
void
nsAutoFloatManager
:
:
CreateFloatManager
(
nsPresContext
*
aPresContext
)
{
MOZ_ASSERT
(
!
mNew
"
Redundant
call
to
CreateFloatManager
!
"
)
;
mNew
=
MakeUnique
<
nsFloatManager
>
(
aPresContext
-
>
PresShell
(
)
mReflowInput
.
GetWritingMode
(
)
)
;
#
ifdef
DEBUG
if
(
nsBlockFrame
:
:
gNoisyFloatManager
)
{
printf
(
"
constructed
new
float
manager
%
p
(
replacing
%
p
)
\
n
"
mNew
.
get
(
)
mReflowInput
.
mFloatManager
)
;
}
#
endif
mOld
=
mReflowInput
.
mFloatManager
;
mReflowInput
.
mFloatManager
=
mNew
.
get
(
)
;
}
