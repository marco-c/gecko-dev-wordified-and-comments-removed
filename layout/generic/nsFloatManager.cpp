#
include
"
nsFloatManager
.
h
"
#
include
<
algorithm
>
#
include
"
mozilla
/
ReflowInput
.
h
"
#
include
"
nsBlockFrame
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsMemory
.
h
"
using
namespace
mozilla
;
int32_t
nsFloatManager
:
:
sCachedFloatManagerCount
=
0
;
void
*
nsFloatManager
:
:
sCachedFloatManagers
[
NS_FLOAT_MANAGER_CACHE_SIZE
]
;
static
void
*
PSArenaAllocCB
(
size_t
aSize
void
*
aClosure
)
{
return
static_cast
<
nsIPresShell
*
>
(
aClosure
)
-
>
AllocateMisc
(
aSize
)
;
}
static
void
PSArenaFreeCB
(
size_t
aSize
void
*
aPtr
void
*
aClosure
)
{
static_cast
<
nsIPresShell
*
>
(
aClosure
)
-
>
FreeMisc
(
aSize
aPtr
)
;
}
nsFloatManager
:
:
nsFloatManager
(
nsIPresShell
*
aPresShell
mozilla
:
:
WritingMode
aWM
)
:
#
ifdef
DEBUG
mWritingMode
(
aWM
)
#
endif
mLineLeft
(
0
)
mBlockStart
(
0
)
mFloatDamage
(
PSArenaAllocCB
PSArenaFreeCB
aPresShell
)
mPushedLeftFloatPastBreak
(
false
)
mPushedRightFloatPastBreak
(
false
)
mSplitLeftFloatAcrossBreak
(
false
)
mSplitRightFloatAcrossBreak
(
false
)
{
MOZ_COUNT_CTOR
(
nsFloatManager
)
;
}
nsFloatManager
:
:
~
nsFloatManager
(
)
{
MOZ_COUNT_DTOR
(
nsFloatManager
)
;
}
void
*
nsFloatManager
:
:
operator
new
(
size_t
aSize
)
CPP_THROW_NEW
{
if
(
sCachedFloatManagerCount
>
0
)
{
return
sCachedFloatManagers
[
-
-
sCachedFloatManagerCount
]
;
}
return
moz_xmalloc
(
aSize
)
;
}
void
nsFloatManager
:
:
operator
delete
(
void
*
aPtr
size_t
aSize
)
{
if
(
!
aPtr
)
return
;
if
(
sCachedFloatManagerCount
<
NS_FLOAT_MANAGER_CACHE_SIZE
&
&
sCachedFloatManagerCount
>
=
0
)
{
sCachedFloatManagers
[
sCachedFloatManagerCount
+
+
]
=
aPtr
;
return
;
}
free
(
aPtr
)
;
}
void
nsFloatManager
:
:
Shutdown
(
)
{
int32_t
i
;
for
(
i
=
0
;
i
<
sCachedFloatManagerCount
;
i
+
+
)
{
void
*
floatManager
=
sCachedFloatManagers
[
i
]
;
if
(
floatManager
)
free
(
floatManager
)
;
}
sCachedFloatManagerCount
=
-
1
;
}
#
define
CHECK_BLOCK_DIR
(
aWM
)
\
NS_ASSERTION
(
(
aWM
)
.
GetBlockDir
(
)
=
=
mWritingMode
.
GetBlockDir
(
)
\
"
incompatible
writing
modes
"
)
nsFlowAreaRect
nsFloatManager
:
:
GetFlowArea
(
WritingMode
aWM
nscoord
aBCoord
nscoord
aBSize
BandInfoType
aBandInfoType
ShapeType
aShapeType
LogicalRect
aContentArea
SavedState
*
aState
const
nsSize
&
aContainerSize
)
const
{
CHECK_BLOCK_DIR
(
aWM
)
;
NS_ASSERTION
(
aBSize
>
=
0
"
unexpected
max
block
size
"
)
;
NS_ASSERTION
(
aContentArea
.
ISize
(
aWM
)
>
=
0
"
unexpected
content
area
inline
size
"
)
;
nscoord
blockStart
=
aBCoord
+
mBlockStart
;
if
(
blockStart
<
nscoord_MIN
)
{
NS_WARNING
(
"
bad
value
"
)
;
blockStart
=
nscoord_MIN
;
}
uint32_t
floatCount
;
if
(
aState
)
{
floatCount
=
aState
-
>
mFloatInfoCount
;
MOZ_ASSERT
(
floatCount
<
=
mFloats
.
Length
(
)
"
bad
state
"
)
;
}
else
{
floatCount
=
mFloats
.
Length
(
)
;
}
if
(
floatCount
=
=
0
|
|
(
mFloats
[
floatCount
-
1
]
.
mLeftBEnd
<
=
blockStart
&
&
mFloats
[
floatCount
-
1
]
.
mRightBEnd
<
=
blockStart
)
)
{
return
nsFlowAreaRect
(
aWM
aContentArea
.
IStart
(
aWM
)
aBCoord
aContentArea
.
ISize
(
aWM
)
aBSize
false
)
;
}
nscoord
blockEnd
;
if
(
aBSize
=
=
nscoord_MAX
)
{
NS_WARNING_ASSERTION
(
aBandInfoType
=
=
BandInfoType
:
:
BandFromPoint
"
bad
height
"
)
;
blockEnd
=
nscoord_MAX
;
}
else
{
blockEnd
=
blockStart
+
aBSize
;
if
(
blockEnd
<
blockStart
|
|
blockEnd
>
nscoord_MAX
)
{
NS_WARNING
(
"
bad
value
"
)
;
blockEnd
=
nscoord_MAX
;
}
}
nscoord
lineLeft
=
mLineLeft
+
aContentArea
.
LineLeft
(
aWM
aContainerSize
)
;
nscoord
lineRight
=
mLineLeft
+
aContentArea
.
LineRight
(
aWM
aContainerSize
)
;
if
(
lineRight
<
lineLeft
)
{
NS_WARNING
(
"
bad
value
"
)
;
lineRight
=
lineLeft
;
}
bool
haveFloats
=
false
;
for
(
uint32_t
i
=
floatCount
;
i
>
0
;
-
-
i
)
{
const
FloatInfo
&
fi
=
mFloats
[
i
-
1
]
;
if
(
fi
.
mLeftBEnd
<
=
blockStart
&
&
fi
.
mRightBEnd
<
=
blockStart
)
{
break
;
}
if
(
fi
.
IsEmpty
(
)
)
{
continue
;
}
nscoord
floatBStart
=
fi
.
BStart
(
aShapeType
)
;
nscoord
floatBEnd
=
fi
.
BEnd
(
aShapeType
)
;
if
(
blockStart
<
floatBStart
&
&
aBandInfoType
=
=
BandInfoType
:
:
BandFromPoint
)
{
if
(
floatBStart
<
blockEnd
)
{
blockEnd
=
floatBStart
;
}
}
else
if
(
blockStart
<
floatBEnd
&
&
(
floatBStart
<
blockEnd
|
|
(
floatBStart
=
=
blockEnd
&
&
blockStart
=
=
blockEnd
)
)
)
{
StyleFloat
floatStyle
=
fi
.
mFrame
-
>
StyleDisplay
(
)
-
>
PhysicalFloats
(
aWM
)
;
const
nscoord
bandBlockEnd
=
aBandInfoType
=
=
BandInfoType
:
:
BandFromPoint
?
blockStart
:
blockEnd
;
if
(
floatStyle
=
=
StyleFloat
:
:
Left
)
{
nscoord
lineRightEdge
=
fi
.
LineRight
(
aWM
aShapeType
blockStart
bandBlockEnd
)
;
if
(
lineRightEdge
>
lineLeft
)
{
lineLeft
=
lineRightEdge
;
haveFloats
=
true
;
}
}
else
{
nscoord
lineLeftEdge
=
fi
.
LineLeft
(
aWM
aShapeType
blockStart
bandBlockEnd
)
;
if
(
lineLeftEdge
<
lineRight
)
{
lineRight
=
lineLeftEdge
;
haveFloats
=
true
;
}
}
if
(
floatBEnd
<
blockEnd
&
&
aBandInfoType
=
=
BandInfoType
:
:
BandFromPoint
)
{
blockEnd
=
floatBEnd
;
}
}
}
nscoord
blockSize
=
(
blockEnd
=
=
nscoord_MAX
)
?
nscoord_MAX
:
(
blockEnd
-
blockStart
)
;
nscoord
inlineStart
=
aWM
.
IsBidiLTR
(
)
?
lineLeft
-
mLineLeft
:
mLineLeft
-
lineRight
+
LogicalSize
(
aWM
aContainerSize
)
.
ISize
(
aWM
)
;
return
nsFlowAreaRect
(
aWM
inlineStart
blockStart
-
mBlockStart
lineRight
-
lineLeft
blockSize
haveFloats
)
;
}
nsresult
nsFloatManager
:
:
AddFloat
(
nsIFrame
*
aFloatFrame
const
LogicalRect
&
aMarginRect
WritingMode
aWM
const
nsSize
&
aContainerSize
)
{
CHECK_BLOCK_DIR
(
aWM
)
;
NS_ASSERTION
(
aMarginRect
.
ISize
(
aWM
)
>
=
0
"
negative
inline
size
!
"
)
;
NS_ASSERTION
(
aMarginRect
.
BSize
(
aWM
)
>
=
0
"
negative
block
size
!
"
)
;
FloatInfo
info
(
aFloatFrame
mLineLeft
mBlockStart
aMarginRect
aWM
aContainerSize
)
;
if
(
HasAnyFloats
(
)
)
{
FloatInfo
&
tail
=
mFloats
[
mFloats
.
Length
(
)
-
1
]
;
info
.
mLeftBEnd
=
tail
.
mLeftBEnd
;
info
.
mRightBEnd
=
tail
.
mRightBEnd
;
}
else
{
info
.
mLeftBEnd
=
nscoord_MIN
;
info
.
mRightBEnd
=
nscoord_MIN
;
}
StyleFloat
floatStyle
=
aFloatFrame
-
>
StyleDisplay
(
)
-
>
PhysicalFloats
(
aWM
)
;
MOZ_ASSERT
(
floatStyle
=
=
StyleFloat
:
:
Left
|
|
floatStyle
=
=
StyleFloat
:
:
Right
"
Unexpected
float
style
!
"
)
;
nscoord
&
sideBEnd
=
floatStyle
=
=
StyleFloat
:
:
Left
?
info
.
mLeftBEnd
:
info
.
mRightBEnd
;
nscoord
thisBEnd
=
info
.
BEnd
(
)
;
if
(
thisBEnd
>
sideBEnd
)
sideBEnd
=
thisBEnd
;
if
(
!
mFloats
.
AppendElement
(
info
)
)
return
NS_ERROR_OUT_OF_MEMORY
;
return
NS_OK
;
}
LogicalRect
nsFloatManager
:
:
CalculateRegionFor
(
WritingMode
aWM
nsIFrame
*
aFloat
const
LogicalMargin
&
aMargin
const
nsSize
&
aContainerSize
)
{
LogicalRect
region
(
aWM
nsRect
(
aFloat
-
>
GetNormalPosition
(
)
aFloat
-
>
GetSize
(
)
)
aContainerSize
)
;
region
.
Inflate
(
aWM
aMargin
)
;
if
(
region
.
ISize
(
aWM
)
<
0
)
{
const
nsStyleDisplay
*
display
=
aFloat
-
>
StyleDisplay
(
)
;
StyleFloat
floatStyle
=
display
-
>
PhysicalFloats
(
aWM
)
;
if
(
(
StyleFloat
:
:
Left
=
=
floatStyle
)
=
=
aWM
.
IsBidiLTR
(
)
)
{
region
.
IStart
(
aWM
)
=
region
.
IEnd
(
aWM
)
;
}
region
.
ISize
(
aWM
)
=
0
;
}
if
(
region
.
BSize
(
aWM
)
<
0
)
{
region
.
BSize
(
aWM
)
=
0
;
}
return
region
;
}
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
FloatRegionProperty
nsMargin
)
LogicalRect
nsFloatManager
:
:
GetRegionFor
(
WritingMode
aWM
nsIFrame
*
aFloat
const
nsSize
&
aContainerSize
)
{
LogicalRect
region
=
aFloat
-
>
GetLogicalRect
(
aWM
aContainerSize
)
;
void
*
storedRegion
=
aFloat
-
>
Properties
(
)
.
Get
(
FloatRegionProperty
(
)
)
;
if
(
storedRegion
)
{
nsMargin
margin
=
*
static_cast
<
nsMargin
*
>
(
storedRegion
)
;
region
.
Inflate
(
aWM
LogicalMargin
(
aWM
margin
)
)
;
}
return
region
;
}
void
nsFloatManager
:
:
StoreRegionFor
(
WritingMode
aWM
nsIFrame
*
aFloat
const
LogicalRect
&
aRegion
const
nsSize
&
aContainerSize
)
{
nsRect
region
=
aRegion
.
GetPhysicalRect
(
aWM
aContainerSize
)
;
nsRect
rect
=
aFloat
-
>
GetRect
(
)
;
FrameProperties
props
=
aFloat
-
>
Properties
(
)
;
if
(
region
.
IsEqualEdges
(
rect
)
)
{
props
.
Delete
(
FloatRegionProperty
(
)
)
;
}
else
{
nsMargin
*
storedMargin
=
props
.
Get
(
FloatRegionProperty
(
)
)
;
if
(
!
storedMargin
)
{
storedMargin
=
new
nsMargin
(
)
;
props
.
Set
(
FloatRegionProperty
(
)
storedMargin
)
;
}
*
storedMargin
=
region
-
rect
;
}
}
nsresult
nsFloatManager
:
:
RemoveTrailingRegions
(
nsIFrame
*
aFrameList
)
{
if
(
!
aFrameList
)
{
return
NS_OK
;
}
nsTHashtable
<
nsPtrHashKey
<
nsIFrame
>
>
frameSet
(
1
)
;
for
(
nsIFrame
*
f
=
aFrameList
;
f
;
f
=
f
-
>
GetNextSibling
(
)
)
{
frameSet
.
PutEntry
(
f
)
;
}
uint32_t
newLength
=
mFloats
.
Length
(
)
;
while
(
newLength
>
0
)
{
if
(
!
frameSet
.
Contains
(
mFloats
[
newLength
-
1
]
.
mFrame
)
)
{
break
;
}
-
-
newLength
;
}
mFloats
.
TruncateLength
(
newLength
)
;
#
ifdef
DEBUG
for
(
uint32_t
i
=
0
;
i
<
mFloats
.
Length
(
)
;
+
+
i
)
{
NS_ASSERTION
(
!
frameSet
.
Contains
(
mFloats
[
i
]
.
mFrame
)
"
Frame
region
deletion
was
requested
but
we
couldn
'
t
delete
it
"
)
;
}
#
endif
return
NS_OK
;
}
void
nsFloatManager
:
:
PushState
(
SavedState
*
aState
)
{
NS_PRECONDITION
(
aState
"
Need
a
place
to
save
state
"
)
;
aState
-
>
mLineLeft
=
mLineLeft
;
aState
-
>
mBlockStart
=
mBlockStart
;
aState
-
>
mPushedLeftFloatPastBreak
=
mPushedLeftFloatPastBreak
;
aState
-
>
mPushedRightFloatPastBreak
=
mPushedRightFloatPastBreak
;
aState
-
>
mSplitLeftFloatAcrossBreak
=
mSplitLeftFloatAcrossBreak
;
aState
-
>
mSplitRightFloatAcrossBreak
=
mSplitRightFloatAcrossBreak
;
aState
-
>
mFloatInfoCount
=
mFloats
.
Length
(
)
;
}
void
nsFloatManager
:
:
PopState
(
SavedState
*
aState
)
{
NS_PRECONDITION
(
aState
"
No
state
to
restore
?
"
)
;
mLineLeft
=
aState
-
>
mLineLeft
;
mBlockStart
=
aState
-
>
mBlockStart
;
mPushedLeftFloatPastBreak
=
aState
-
>
mPushedLeftFloatPastBreak
;
mPushedRightFloatPastBreak
=
aState
-
>
mPushedRightFloatPastBreak
;
mSplitLeftFloatAcrossBreak
=
aState
-
>
mSplitLeftFloatAcrossBreak
;
mSplitRightFloatAcrossBreak
=
aState
-
>
mSplitRightFloatAcrossBreak
;
NS_ASSERTION
(
aState
-
>
mFloatInfoCount
<
=
mFloats
.
Length
(
)
"
somebody
misused
PushState
/
PopState
"
)
;
mFloats
.
TruncateLength
(
aState
-
>
mFloatInfoCount
)
;
}
nscoord
nsFloatManager
:
:
GetLowestFloatTop
(
)
const
{
if
(
mPushedLeftFloatPastBreak
|
|
mPushedRightFloatPastBreak
)
{
return
nscoord_MAX
;
}
if
(
!
HasAnyFloats
(
)
)
{
return
nscoord_MIN
;
}
return
mFloats
[
mFloats
.
Length
(
)
-
1
]
.
BStart
(
)
-
mBlockStart
;
}
#
ifdef
DEBUG_FRAME_DUMP
void
DebugListFloatManager
(
const
nsFloatManager
*
aFloatManager
)
{
aFloatManager
-
>
List
(
stdout
)
;
}
nsresult
nsFloatManager
:
:
List
(
FILE
*
out
)
const
{
if
(
!
HasAnyFloats
(
)
)
return
NS_OK
;
for
(
uint32_t
i
=
0
;
i
<
mFloats
.
Length
(
)
;
+
+
i
)
{
const
FloatInfo
&
fi
=
mFloats
[
i
]
;
fprintf_stderr
(
out
"
Float
%
u
:
frame
=
%
p
rect
=
{
%
d
%
d
%
d
%
d
}
BEnd
=
{
l
:
%
d
r
:
%
d
}
\
n
"
i
static_cast
<
void
*
>
(
fi
.
mFrame
)
fi
.
LineLeft
(
)
fi
.
BStart
(
)
fi
.
ISize
(
)
fi
.
BSize
(
)
fi
.
mLeftBEnd
fi
.
mRightBEnd
)
;
}
return
NS_OK
;
}
#
endif
nscoord
nsFloatManager
:
:
ClearFloats
(
nscoord
aBCoord
StyleClear
aBreakType
uint32_t
aFlags
)
const
{
if
(
!
(
aFlags
&
DONT_CLEAR_PUSHED_FLOATS
)
&
&
ClearContinues
(
aBreakType
)
)
{
return
nscoord_MAX
;
}
if
(
!
HasAnyFloats
(
)
)
{
return
aBCoord
;
}
nscoord
blockEnd
=
aBCoord
+
mBlockStart
;
const
FloatInfo
&
tail
=
mFloats
[
mFloats
.
Length
(
)
-
1
]
;
switch
(
aBreakType
)
{
case
StyleClear
:
:
Both
:
blockEnd
=
std
:
:
max
(
blockEnd
tail
.
mLeftBEnd
)
;
blockEnd
=
std
:
:
max
(
blockEnd
tail
.
mRightBEnd
)
;
break
;
case
StyleClear
:
:
Left
:
blockEnd
=
std
:
:
max
(
blockEnd
tail
.
mLeftBEnd
)
;
break
;
case
StyleClear
:
:
Right
:
blockEnd
=
std
:
:
max
(
blockEnd
tail
.
mRightBEnd
)
;
break
;
default
:
break
;
}
blockEnd
-
=
mBlockStart
;
return
blockEnd
;
}
bool
nsFloatManager
:
:
ClearContinues
(
StyleClear
aBreakType
)
const
{
return
(
(
mPushedLeftFloatPastBreak
|
|
mSplitLeftFloatAcrossBreak
)
&
&
(
aBreakType
=
=
StyleClear
:
:
Both
|
|
aBreakType
=
=
StyleClear
:
:
Left
)
)
|
|
(
(
mPushedRightFloatPastBreak
|
|
mSplitRightFloatAcrossBreak
)
&
&
(
aBreakType
=
=
StyleClear
:
:
Both
|
|
aBreakType
=
=
StyleClear
:
:
Right
)
)
;
}
nsFloatManager
:
:
FloatInfo
:
:
FloatInfo
(
nsIFrame
*
aFrame
nscoord
aLineLeft
nscoord
aBlockStart
const
LogicalRect
&
aMarginRect
WritingMode
aWM
const
nsSize
&
aContainerSize
)
:
mFrame
(
aFrame
)
mRect
(
aMarginRect
.
LineLeft
(
aWM
aContainerSize
)
+
aLineLeft
aMarginRect
.
BStart
(
aWM
)
+
aBlockStart
aMarginRect
.
ISize
(
aWM
)
aMarginRect
.
BSize
(
aWM
)
)
{
MOZ_COUNT_CTOR
(
nsFloatManager
:
:
FloatInfo
)
;
const
StyleShapeOutside
&
shapeOutside
=
mFrame
-
>
StyleDisplay
(
)
-
>
mShapeOutside
;
if
(
shapeOutside
.
GetType
(
)
=
=
StyleShapeSourceType
:
:
Box
)
{
LogicalRect
rect
=
aMarginRect
;
switch
(
shapeOutside
.
GetReferenceBox
(
)
)
{
case
StyleShapeOutsideShapeBox
:
:
Content
:
rect
.
Deflate
(
aWM
mFrame
-
>
GetLogicalUsedPadding
(
aWM
)
)
;
MOZ_FALLTHROUGH
;
case
StyleShapeOutsideShapeBox
:
:
Padding
:
rect
.
Deflate
(
aWM
mFrame
-
>
GetLogicalUsedBorder
(
aWM
)
)
;
MOZ_FALLTHROUGH
;
case
StyleShapeOutsideShapeBox
:
:
Border
:
rect
.
Deflate
(
aWM
mFrame
-
>
GetLogicalUsedMargin
(
aWM
)
)
;
break
;
case
StyleShapeOutsideShapeBox
:
:
Margin
:
break
;
case
StyleShapeOutsideShapeBox
:
:
NoBox
:
MOZ_ASSERT_UNREACHABLE
(
"
Why
don
'
t
we
have
a
shape
-
box
?
"
)
;
break
;
}
mShapeBoxRect
.
emplace
(
rect
.
LineLeft
(
aWM
aContainerSize
)
+
aLineLeft
rect
.
BStart
(
aWM
)
+
aBlockStart
rect
.
ISize
(
aWM
)
rect
.
BSize
(
aWM
)
)
;
}
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
nsFloatManager
:
:
FloatInfo
:
:
FloatInfo
(
const
FloatInfo
&
aOther
)
:
mFrame
(
aOther
.
mFrame
)
mLeftBEnd
(
aOther
.
mLeftBEnd
)
mRightBEnd
(
aOther
.
mRightBEnd
)
mRect
(
aOther
.
mRect
)
mShapeBoxRect
(
aOther
.
mShapeBoxRect
)
{
MOZ_COUNT_CTOR
(
nsFloatManager
:
:
FloatInfo
)
;
}
nsFloatManager
:
:
FloatInfo
:
:
~
FloatInfo
(
)
{
MOZ_COUNT_DTOR
(
nsFloatManager
:
:
FloatInfo
)
;
}
#
endif
nscoord
nsFloatManager
:
:
FloatInfo
:
:
LineLeft
(
WritingMode
aWM
ShapeType
aShapeType
const
nscoord
aBStart
const
nscoord
aBEnd
)
const
{
if
(
aShapeType
=
=
ShapeType
:
:
Margin
)
{
return
LineLeft
(
)
;
}
MOZ_ASSERT
(
aShapeType
=
=
ShapeType
:
:
ShapeOutside
)
;
const
StyleShapeOutside
&
shapeOutside
=
mFrame
-
>
StyleDisplay
(
)
-
>
mShapeOutside
;
if
(
shapeOutside
.
GetType
(
)
=
=
StyleShapeSourceType
:
:
None
)
{
return
LineLeft
(
)
;
}
if
(
shapeOutside
.
GetType
(
)
=
=
StyleShapeSourceType
:
:
Box
)
{
nscoord
radii
[
8
]
;
bool
hasRadii
=
mFrame
-
>
GetShapeBoxBorderRadii
(
radii
)
;
if
(
!
hasRadii
)
{
return
ShapeBoxRect
(
)
.
x
;
}
mozilla
:
:
Side
lineLeftSide
=
aWM
.
PhysicalSide
(
aWM
.
LogicalSideForLineRelativeDir
(
eLineRelativeDirLeft
)
)
;
nscoord
blockStartCornerRadiusL
=
radii
[
NS_SIDE_TO_HALF_CORNER
(
lineLeftSide
true
false
)
]
;
nscoord
blockStartCornerRadiusB
=
radii
[
NS_SIDE_TO_HALF_CORNER
(
lineLeftSide
true
true
)
]
;
nscoord
blockEndCornerRadiusL
=
radii
[
NS_SIDE_TO_HALF_CORNER
(
lineLeftSide
false
false
)
]
;
nscoord
blockEndCornerRadiusB
=
radii
[
NS_SIDE_TO_HALF_CORNER
(
lineLeftSide
false
true
)
]
;
if
(
aWM
.
IsLineInverted
(
)
)
{
std
:
:
swap
(
blockStartCornerRadiusL
blockEndCornerRadiusL
)
;
std
:
:
swap
(
blockStartCornerRadiusB
blockEndCornerRadiusB
)
;
}
nscoord
lineLeftDiff
=
ComputeEllipseXInterceptDiff
(
ShapeBoxRect
(
)
.
y
ShapeBoxRect
(
)
.
YMost
(
)
blockStartCornerRadiusL
blockStartCornerRadiusB
blockEndCornerRadiusL
blockEndCornerRadiusB
aBStart
aBEnd
)
;
return
ShapeBoxRect
(
)
.
x
+
lineLeftDiff
;
}
return
LineLeft
(
)
;
}
nscoord
nsFloatManager
:
:
FloatInfo
:
:
LineRight
(
WritingMode
aWM
ShapeType
aShapeType
const
nscoord
aBStart
const
nscoord
aBEnd
)
const
{
if
(
aShapeType
=
=
ShapeType
:
:
Margin
)
{
return
LineRight
(
)
;
}
MOZ_ASSERT
(
aShapeType
=
=
ShapeType
:
:
ShapeOutside
)
;
const
StyleShapeOutside
&
shapeOutside
=
mFrame
-
>
StyleDisplay
(
)
-
>
mShapeOutside
;
if
(
shapeOutside
.
GetType
(
)
=
=
StyleShapeSourceType
:
:
None
)
{
return
LineRight
(
)
;
}
if
(
shapeOutside
.
GetType
(
)
=
=
StyleShapeSourceType
:
:
Box
)
{
nscoord
radii
[
8
]
;
bool
hasRadii
=
mFrame
-
>
GetShapeBoxBorderRadii
(
radii
)
;
if
(
!
hasRadii
)
{
return
ShapeBoxRect
(
)
.
XMost
(
)
;
}
mozilla
:
:
Side
lineRightSide
=
aWM
.
PhysicalSide
(
aWM
.
LogicalSideForLineRelativeDir
(
eLineRelativeDirRight
)
)
;
nscoord
blockStartCornerRadiusL
=
radii
[
NS_SIDE_TO_HALF_CORNER
(
lineRightSide
false
false
)
]
;
nscoord
blockStartCornerRadiusB
=
radii
[
NS_SIDE_TO_HALF_CORNER
(
lineRightSide
false
true
)
]
;
nscoord
blockEndCornerRadiusL
=
radii
[
NS_SIDE_TO_HALF_CORNER
(
lineRightSide
true
false
)
]
;
nscoord
blockEndCornerRadiusB
=
radii
[
NS_SIDE_TO_HALF_CORNER
(
lineRightSide
true
true
)
]
;
if
(
aWM
.
IsLineInverted
(
)
)
{
std
:
:
swap
(
blockStartCornerRadiusL
blockEndCornerRadiusL
)
;
std
:
:
swap
(
blockStartCornerRadiusB
blockEndCornerRadiusB
)
;
}
nscoord
lineRightDiff
=
ComputeEllipseXInterceptDiff
(
ShapeBoxRect
(
)
.
y
ShapeBoxRect
(
)
.
YMost
(
)
blockStartCornerRadiusL
blockStartCornerRadiusB
blockEndCornerRadiusL
blockEndCornerRadiusB
aBStart
aBEnd
)
;
return
ShapeBoxRect
(
)
.
XMost
(
)
-
lineRightDiff
;
}
return
LineRight
(
)
;
}
nscoord
nsFloatManager
:
:
FloatInfo
:
:
ComputeEllipseXInterceptDiff
(
const
nscoord
aShapeBoxY
const
nscoord
aShapeBoxYMost
const
nscoord
aTopCornerRadiusX
const
nscoord
aTopCornerRadiusY
const
nscoord
aBottomCornerRadiusX
const
nscoord
aBottomCornerRadiusY
const
nscoord
aBandY
const
nscoord
aBandYMost
)
{
NS_ASSERTION
(
aShapeBoxY
<
=
aShapeBoxYMost
"
Bad
shape
box
coordinates
!
"
)
;
NS_ASSERTION
(
aBandY
<
=
aBandYMost
"
Bad
band
coordinates
!
"
)
;
nscoord
xDiff
=
0
;
if
(
aTopCornerRadiusY
>
0
&
&
aBandYMost
>
=
aShapeBoxY
&
&
aBandYMost
<
=
aShapeBoxY
+
aTopCornerRadiusY
)
{
nscoord
y
=
aTopCornerRadiusY
-
(
aBandYMost
-
aShapeBoxY
)
;
nscoord
xIntercept
=
XInterceptAtY
(
y
aTopCornerRadiusX
aTopCornerRadiusY
)
;
xDiff
=
aTopCornerRadiusX
-
xIntercept
;
}
else
if
(
aBottomCornerRadiusY
>
0
&
&
aBandY
>
=
aShapeBoxYMost
-
aBottomCornerRadiusY
&
&
aBandY
<
=
aShapeBoxYMost
)
{
nscoord
y
=
aBottomCornerRadiusY
-
(
aShapeBoxYMost
-
aBandY
)
;
nscoord
xIntercept
=
XInterceptAtY
(
y
aBottomCornerRadiusX
aBottomCornerRadiusY
)
;
xDiff
=
aBottomCornerRadiusX
-
xIntercept
;
}
return
xDiff
;
}
nscoord
nsFloatManager
:
:
FloatInfo
:
:
XInterceptAtY
(
const
nscoord
aY
const
nscoord
aRadiusX
const
nscoord
aRadiusY
)
{
MOZ_ASSERT
(
aRadiusY
>
0
)
;
return
aRadiusX
*
std
:
:
sqrt
(
1
-
(
aY
*
aY
)
/
double
(
aRadiusY
*
aRadiusY
)
)
;
}
nsAutoFloatManager
:
:
~
nsAutoFloatManager
(
)
{
if
(
mNew
)
{
#
ifdef
DEBUG
if
(
nsBlockFrame
:
:
gNoisyFloatManager
)
{
printf
(
"
restoring
old
float
manager
%
p
\
n
"
mOld
)
;
}
#
endif
mReflowInput
.
mFloatManager
=
mOld
;
#
ifdef
DEBUG
if
(
nsBlockFrame
:
:
gNoisyFloatManager
)
{
if
(
mOld
)
{
mReflowInput
.
mFrame
-
>
ListTag
(
stdout
)
;
printf
(
"
:
float
manager
%
p
after
reflow
\
n
"
mOld
)
;
mOld
-
>
List
(
stdout
)
;
}
}
#
endif
delete
mNew
;
}
}
void
nsAutoFloatManager
:
:
CreateFloatManager
(
nsPresContext
*
aPresContext
)
{
mNew
=
new
nsFloatManager
(
aPresContext
-
>
PresShell
(
)
mReflowInput
.
GetWritingMode
(
)
)
;
#
ifdef
DEBUG
if
(
nsBlockFrame
:
:
gNoisyFloatManager
)
{
printf
(
"
constructed
new
float
manager
%
p
(
replacing
%
p
)
\
n
"
mNew
mReflowInput
.
mFloatManager
)
;
}
#
endif
mOld
=
mReflowInput
.
mFloatManager
;
mReflowInput
.
mFloatManager
=
mNew
;
}
