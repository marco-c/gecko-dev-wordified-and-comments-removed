#
include
"
nsPresContext
.
h
"
#
include
"
nsPresContextInlines
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
if
defined
(
MOZ_WIDGET_ANDROID
)
#
include
"
mozilla
/
AsyncEventDispatcher
.
h
"
#
endif
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Encoding
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
PresShellInlines
.
h
"
#
include
"
base
/
basictypes
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsIContentViewer
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
include
"
nsIPrintSettings
.
h
"
#
include
"
nsLanguageAtomService
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsHTMLDocument
.
h
"
#
include
"
nsIWeakReferenceUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
SurfaceCacheUtils
.
h
"
#
include
"
nsMediaFeatures
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
nsFontFaceLoader
.
h
"
#
include
"
mozilla
/
AnimationEventDispatcher
.
h
"
#
include
"
mozilla
/
EffectCompositor
.
h
"
#
include
"
mozilla
/
EventListenerManager
.
h
"
#
include
"
prenv
.
h
"
#
include
"
nsPluginFrame
.
h
"
#
include
"
nsTransitionManager
.
h
"
#
include
"
nsAnimationManager
.
h
"
#
include
"
CounterStyleManager
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
nsIMessageManager
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBodyElement
.
h
"
#
include
"
mozilla
/
dom
/
MediaQueryList
.
h
"
#
include
"
mozilla
/
SMILAnimationController
.
h
"
#
include
"
mozilla
/
css
/
ImageLoader
.
h
"
#
include
"
mozilla
/
dom
/
PBrowserParent
.
h
"
#
include
"
mozilla
/
dom
/
BrowserChild
.
h
"
#
include
"
mozilla
/
dom
/
BrowserParent
.
h
"
#
include
"
nsRefreshDriver
.
h
"
#
include
"
Layers
.
h
"
#
include
"
LayerUserData
.
h
"
#
include
"
ClientLayerManager
.
h
"
#
include
"
mozilla
/
dom
/
NotifyPaintEvent
.
h
"
#
include
"
nsIDOMChromeWindow
.
h
"
#
include
"
nsFrameLoader
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsPIWindowRoot
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
gfxTextRun
.
h
"
#
include
"
nsFontFaceUtils
.
h
"
#
include
"
nsLayoutStylesheetCache
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
mozilla
/
StaticPrefs_zoom
.
h
"
#
include
"
mozilla
/
StyleSheet
.
h
"
#
include
"
mozilla
/
StyleSheetInlines
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
dom
/
Performance
.
h
"
#
include
"
mozilla
/
dom
/
PerformanceTiming
.
h
"
#
include
"
mozilla
/
layers
/
APZThreadUtils
.
h
"
#
include
"
MobileViewportManager
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
nsIImageLoadingContent
.
h
"
#
include
"
nsBidiUtils
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsBidi
.
h
"
#
include
"
mozilla
/
dom
/
URL
.
h
"
#
include
"
mozilla
/
ServoCSSParser
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
layers
;
uint8_t
gNotifySubDocInvalidationData
;
class
ContainerLayerPresContext
:
public
LayerUserData
{
public
:
nsPresContext
*
mPresContext
;
}
;
bool
nsPresContext
:
:
IsDOMPaintEventPending
(
)
{
if
(
!
mTransactions
.
IsEmpty
(
)
)
{
return
true
;
}
nsRootPresContext
*
drpc
=
GetRootPresContext
(
)
;
if
(
drpc
&
&
drpc
-
>
mRefreshDriver
-
>
ViewManagerFlushIsPending
(
)
)
{
NotifyInvalidation
(
drpc
-
>
mRefreshDriver
-
>
LastTransactionId
(
)
.
Next
(
)
nsRect
(
0
0
0
0
)
)
;
return
true
;
}
return
false
;
}
void
nsPresContext
:
:
ForceReflowForFontInfoUpdate
(
)
{
DeviceContext
(
)
-
>
FlushFontCache
(
)
;
if
(
Document
(
)
-
>
GetFonts
(
)
)
{
Document
(
)
-
>
GetFonts
(
)
-
>
GetUserFontSet
(
)
-
>
ForgetLocalFaces
(
)
;
}
PreferenceChanged
(
"
font
.
internaluseonly
.
changed
"
)
;
}
static
bool
IsVisualCharset
(
NotNull
<
const
Encoding
*
>
aCharset
)
{
return
aCharset
=
=
ISO_8859_8_ENCODING
;
}
nsPresContext
:
:
nsPresContext
(
dom
:
:
Document
*
aDocument
nsPresContextType
aType
)
:
mType
(
aType
)
mPresShell
(
nullptr
)
mDocument
(
aDocument
)
mMedium
(
aType
=
=
eContext_Galley
?
nsGkAtoms
:
:
screen
:
nsGkAtoms
:
:
print
)
mInflationDisabledForShrinkWrap
(
false
)
mSystemFontScale
(
1
.
0
)
mTextZoom
(
1
.
0
)
mEffectiveTextZoom
(
1
.
0
)
mFullZoom
(
1
.
0
)
mLastFontInflationScreenSize
(
gfxSize
(
-
1
.
0
-
1
.
0
)
)
mCurAppUnitsPerDevPixel
(
0
)
mAutoQualityMinFontSizePixelsPref
(
0
)
mDynamicToolbarMaxHeight
(
0
)
mPageSize
(
-
1
-
1
)
mPageScale
(
0
.
0
)
mPPScale
(
1
.
0f
)
mViewportScrollOverrideElement
(
nullptr
)
mViewportScrollStyles
(
StyleOverflow
:
:
Auto
StyleOverflow
:
:
Auto
)
mExistThrottledUpdates
(
false
)
mImageAnimationModePref
(
imgIContainer
:
:
kNormalAnimMode
)
mInterruptChecksToSkip
(
0
)
mNextFrameRateMultiplier
(
0
)
mElementsRestyled
(
0
)
mFramesConstructed
(
0
)
mFramesReflowed
(
0
)
mInteractionTimeEnabled
(
true
)
mHasPendingInterrupt
(
false
)
mPendingInterruptFromTest
(
false
)
mInterruptsEnabled
(
false
)
mSendAfterPaintToContent
(
false
)
mDrawImageBackground
(
true
)
mDrawColorBackground
(
true
)
mPaginated
(
aType
!
=
eContext_Galley
)
mCanPaginatedScroll
(
false
)
mDoScaledTwips
(
true
)
mIsRootPaginatedDocument
(
false
)
mPrefBidiDirection
(
false
)
mPrefScrollbarSide
(
0
)
mPendingSysColorChanged
(
false
)
mPendingThemeChanged
(
false
)
mPendingUIResolutionChanged
(
false
)
mPrefChangePendingNeedsReflow
(
false
)
mPostedPrefChangedRunnable
(
false
)
mIsGlyph
(
false
)
mUsesRootEMUnits
(
false
)
mUsesExChUnits
(
false
)
mCounterStylesDirty
(
true
)
mFontFeatureValuesDirty
(
true
)
mSuppressResizeReflow
(
false
)
mIsVisual
(
false
)
mPaintFlashing
(
false
)
mPaintFlashingInitialized
(
false
)
mHasWarnedAboutPositionedTableParts
(
false
)
mHasWarnedAboutTooLargeDashedOrDottedRadius
(
false
)
mQuirkSheetAdded
(
false
)
mHadNonBlankPaint
(
false
)
mHadContentfulPaint
(
false
)
mHadContentfulPaintComposite
(
false
)
#
ifdef
DEBUG
mInitialized
(
false
)
#
endif
{
#
ifdef
DEBUG
PodZero
(
&
mLayoutPhaseCount
)
;
#
endif
if
(
!
IsDynamic
(
)
)
{
mImageAnimationMode
=
imgIContainer
:
:
kDontAnimMode
;
mNeverAnimate
=
true
;
}
else
{
mImageAnimationMode
=
imgIContainer
:
:
kNormalAnimMode
;
mNeverAnimate
=
false
;
}
NS_ASSERTION
(
mDocument
"
Null
document
"
)
;
if
(
MOZ_LOG_TEST
(
gfxPlatform
:
:
GetLog
(
eGfxLog_textperf
)
LogLevel
:
:
Warning
)
)
{
mTextPerf
=
MakeUnique
<
gfxTextPerfMetrics
>
(
)
;
}
if
(
Preferences
:
:
GetBool
(
GFX_MISSING_FONTS_NOTIFY_PREF
)
)
{
mMissingFonts
=
MakeUnique
<
gfxMissingFontRecorder
>
(
)
;
}
}
static
const
char
*
gExactCallbackPrefs
[
]
=
{
"
browser
.
underline_anchors
"
"
browser
.
anchor_color
"
"
browser
.
active_color
"
"
browser
.
visited_color
"
"
image
.
animation_mode
"
"
dom
.
send_after_paint_to_content
"
"
layout
.
css
.
dpi
"
"
layout
.
css
.
devPixelsPerPx
"
"
nglayout
.
debug
.
paint_flashing
"
"
nglayout
.
debug
.
paint_flashing_chrome
"
"
intl
.
accept_languages
"
nullptr
}
;
static
const
char
*
gPrefixCallbackPrefs
[
]
=
{
"
font
.
"
"
browser
.
display
.
"
"
bidi
.
"
"
gfx
.
font_rendering
.
"
nullptr
}
;
void
nsPresContext
:
:
Destroy
(
)
{
if
(
mEventManager
)
{
mEventManager
-
>
NotifyDestroyPresContext
(
this
)
;
mEventManager
-
>
SetPresContext
(
nullptr
)
;
mEventManager
=
nullptr
;
}
Preferences
:
:
UnregisterPrefixCallbacks
(
nsPresContext
:
:
PreferenceChanged
gPrefixCallbackPrefs
this
)
;
Preferences
:
:
UnregisterCallbacks
(
nsPresContext
:
:
PreferenceChanged
gExactCallbackPrefs
this
)
;
mRefreshDriver
=
nullptr
;
}
nsPresContext
:
:
~
nsPresContext
(
)
{
MOZ_ASSERT
(
!
mPresShell
"
Presshell
forgot
to
clear
our
mPresShell
pointer
"
)
;
DetachPresShell
(
)
;
Destroy
(
)
;
}
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
nsPresContext
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsPresContext
)
NS_IMPL_CYCLE_COLLECTING_RELEASE_WITH_LAST_RELEASE
(
nsPresContext
LastRelease
(
)
)
void
nsPresContext
:
:
LastRelease
(
)
{
if
(
mMissingFonts
)
{
mMissingFonts
-
>
Clear
(
)
;
}
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
nsPresContext
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
nsPresContext
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAnimationEventDispatcher
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDocument
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mEffectCompositor
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mEventManager
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mPrintSettings
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
nsPresContext
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mAnimationEventDispatcher
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDocument
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDeviceContext
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mEffectCompositor
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mPrintSettings
)
;
tmp
-
>
Destroy
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
static
bool
sNoTheme
=
false
;
static
bool
sLookAndFeelChanged
;
static
bool
sThemeChanged
;
bool
nsPresContext
:
:
IsChrome
(
)
const
{
return
Document
(
)
-
>
IsInChromeDocShell
(
)
;
}
void
nsPresContext
:
:
GetUserPreferences
(
)
{
if
(
!
GetPresShell
(
)
)
{
return
;
}
mAutoQualityMinFontSizePixelsPref
=
Preferences
:
:
GetInt
(
"
browser
.
display
.
auto_quality_min_font_size
"
)
;
PreferenceSheet
:
:
EnsureInitialized
(
)
;
mSendAfterPaintToContent
=
Preferences
:
:
GetBool
(
"
dom
.
send_after_paint_to_content
"
mSendAfterPaintToContent
)
;
mPrefScrollbarSide
=
Preferences
:
:
GetInt
(
"
layout
.
scrollbar
.
side
"
)
;
Document
(
)
-
>
SetMayNeedFontPrefsUpdate
(
)
;
nsAutoCString
animatePref
;
Preferences
:
:
GetCString
(
"
image
.
animation_mode
"
animatePref
)
;
if
(
animatePref
.
EqualsLiteral
(
"
normal
"
)
)
mImageAnimationModePref
=
imgIContainer
:
:
kNormalAnimMode
;
else
if
(
animatePref
.
EqualsLiteral
(
"
none
"
)
)
mImageAnimationModePref
=
imgIContainer
:
:
kDontAnimMode
;
else
if
(
animatePref
.
EqualsLiteral
(
"
once
"
)
)
mImageAnimationModePref
=
imgIContainer
:
:
kLoopOnceAnimMode
;
else
mImageAnimationModePref
=
imgIContainer
:
:
kNormalAnimMode
;
uint32_t
bidiOptions
=
GetBidi
(
)
;
int32_t
prefInt
=
Preferences
:
:
GetInt
(
IBMBIDI_TEXTDIRECTION_STR
GET_BIDI_OPTION_DIRECTION
(
bidiOptions
)
)
;
SET_BIDI_OPTION_DIRECTION
(
bidiOptions
prefInt
)
;
mPrefBidiDirection
=
prefInt
;
prefInt
=
Preferences
:
:
GetInt
(
IBMBIDI_TEXTTYPE_STR
GET_BIDI_OPTION_TEXTTYPE
(
bidiOptions
)
)
;
SET_BIDI_OPTION_TEXTTYPE
(
bidiOptions
prefInt
)
;
prefInt
=
Preferences
:
:
GetInt
(
IBMBIDI_NUMERAL_STR
GET_BIDI_OPTION_NUMERAL
(
bidiOptions
)
)
;
SET_BIDI_OPTION_NUMERAL
(
bidiOptions
prefInt
)
;
SetBidi
(
bidiOptions
)
;
}
void
nsPresContext
:
:
InvalidatePaintedLayers
(
)
{
if
(
!
mPresShell
)
{
return
;
}
if
(
nsIFrame
*
rootFrame
=
mPresShell
-
>
GetRootFrame
(
)
)
{
rootFrame
-
>
InvalidateFrameSubtree
(
)
;
}
}
void
nsPresContext
:
:
AppUnitsPerDevPixelChanged
(
)
{
int32_t
oldAppUnitsPerDevPixel
=
mCurAppUnitsPerDevPixel
;
InvalidatePaintedLayers
(
)
;
if
(
mDeviceContext
)
{
mDeviceContext
-
>
FlushFontCache
(
)
;
}
MediaFeatureValuesChanged
(
{
RestyleHint
:
:
RecascadeSubtree
(
)
NS_STYLE_HINT_REFLOW
MediaFeatureChangeReason
:
:
ResolutionChange
}
)
;
mCurAppUnitsPerDevPixel
=
mDeviceContext
-
>
AppUnitsPerDevPixel
(
)
;
if
(
IsRootContentDocumentCrossProcess
(
)
)
{
AdjustSizeForViewportUnits
(
)
;
}
if
(
mPresShell
)
{
if
(
nsIFrame
*
frame
=
mPresShell
-
>
GetRootFrame
(
)
)
{
frame
=
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
frame
)
;
if
(
frame
)
{
int32_t
parentAPD
=
frame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
if
(
(
parentAPD
=
=
oldAppUnitsPerDevPixel
)
!
=
(
parentAPD
=
=
mCurAppUnitsPerDevPixel
)
)
{
frame
-
>
InvalidateFrame
(
)
;
}
}
}
}
}
void
nsPresContext
:
:
PreferenceChanged
(
const
char
*
aPrefName
void
*
aSelf
)
{
static_cast
<
nsPresContext
*
>
(
aSelf
)
-
>
PreferenceChanged
(
aPrefName
)
;
}
void
nsPresContext
:
:
PreferenceChanged
(
const
char
*
aPrefName
)
{
nsDependentCString
prefName
(
aPrefName
)
;
if
(
prefName
.
EqualsLiteral
(
"
layout
.
css
.
dpi
"
)
|
|
prefName
.
EqualsLiteral
(
"
layout
.
css
.
devPixelsPerPx
"
)
)
{
int32_t
oldAppUnitsPerDevPixel
=
mDeviceContext
-
>
AppUnitsPerDevPixel
(
)
;
Unused
<
<
mDeviceContext
-
>
CheckDPIChange
(
)
;
if
(
mPresShell
)
{
OwningNonNull
<
mozilla
:
:
PresShell
>
presShell
(
*
mPresShell
)
;
nscoord
oldWidthAppUnits
oldHeightAppUnits
;
RefPtr
<
nsViewManager
>
vm
=
presShell
-
>
GetViewManager
(
)
;
if
(
!
vm
)
{
return
;
}
vm
-
>
GetWindowDimensions
(
&
oldWidthAppUnits
&
oldHeightAppUnits
)
;
float
oldWidthDevPixels
=
oldWidthAppUnits
/
oldAppUnitsPerDevPixel
;
float
oldHeightDevPixels
=
oldHeightAppUnits
/
oldAppUnitsPerDevPixel
;
AppUnitsPerDevPixelChanged
(
)
;
nscoord
width
=
NSToCoordRound
(
oldWidthDevPixels
*
AppUnitsPerDevPixel
(
)
)
;
nscoord
height
=
NSToCoordRound
(
oldHeightDevPixels
*
AppUnitsPerDevPixel
(
)
)
;
vm
-
>
SetWindowDimensions
(
width
height
)
;
}
return
;
}
if
(
prefName
.
EqualsLiteral
(
GFX_MISSING_FONTS_NOTIFY_PREF
)
)
{
if
(
Preferences
:
:
GetBool
(
GFX_MISSING_FONTS_NOTIFY_PREF
)
)
{
if
(
!
mMissingFonts
)
{
mMissingFonts
=
MakeUnique
<
gfxMissingFontRecorder
>
(
)
;
mPrefChangePendingNeedsReflow
=
true
;
}
}
else
{
if
(
mMissingFonts
)
{
mMissingFonts
-
>
Clear
(
)
;
}
mMissingFonts
=
nullptr
;
}
}
if
(
StringBeginsWith
(
prefName
NS_LITERAL_CSTRING
(
"
font
.
"
)
)
|
|
prefName
.
EqualsLiteral
(
"
intl
.
accept_languages
"
)
)
{
mPrefChangePendingNeedsReflow
=
true
;
}
if
(
StringBeginsWith
(
prefName
NS_LITERAL_CSTRING
(
"
bidi
.
"
)
)
)
{
mPrefChangePendingNeedsReflow
=
true
;
}
if
(
StringBeginsWith
(
prefName
NS_LITERAL_CSTRING
(
"
gfx
.
font_rendering
.
"
)
)
)
{
mPrefChangePendingNeedsReflow
=
true
;
}
nsLayoutStylesheetCache
:
:
InvalidatePreferenceSheets
(
)
;
PreferenceSheet
:
:
Refresh
(
)
;
DispatchPrefChangedRunnableIfNeeded
(
)
;
if
(
prefName
.
EqualsLiteral
(
"
nglayout
.
debug
.
paint_flashing
"
)
|
|
prefName
.
EqualsLiteral
(
"
nglayout
.
debug
.
paint_flashing_chrome
"
)
)
{
mPaintFlashingInitialized
=
false
;
return
;
}
}
void
nsPresContext
:
:
DispatchPrefChangedRunnableIfNeeded
(
)
{
if
(
mPostedPrefChangedRunnable
)
{
return
;
}
nsCOMPtr
<
nsIRunnable
>
runnable
=
NewRunnableMethod
(
"
nsPresContext
:
:
UpdateAfterPreferencesChanged
"
this
&
nsPresContext
:
:
UpdateAfterPreferencesChanged
)
;
nsresult
rv
=
Document
(
)
-
>
Dispatch
(
TaskCategory
:
:
Other
runnable
.
forget
(
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mPostedPrefChangedRunnable
=
true
;
}
}
void
nsPresContext
:
:
UpdateAfterPreferencesChanged
(
)
{
mPostedPrefChangedRunnable
=
false
;
if
(
!
mPresShell
)
{
return
;
}
if
(
mDocument
-
>
IsInChromeDocShell
(
)
)
{
return
;
}
StaticPresData
:
:
Get
(
)
-
>
InvalidateFontPrefs
(
)
;
GetUserPreferences
(
)
;
mPresShell
-
>
UpdatePreferenceStyles
(
)
;
InvalidatePaintedLayers
(
)
;
mDeviceContext
-
>
FlushFontCache
(
)
;
nsChangeHint
hint
=
nsChangeHint
(
0
)
;
if
(
mPrefChangePendingNeedsReflow
)
{
hint
|
=
NS_STYLE_HINT_REFLOW
;
}
RebuildAllStyleData
(
hint
RestyleHint
:
:
RestyleSubtree
(
)
)
;
}
nsresult
nsPresContext
:
:
Init
(
nsDeviceContext
*
aDeviceContext
)
{
NS_ASSERTION
(
!
mInitialized
"
attempt
to
reinit
pres
context
"
)
;
NS_ENSURE_ARG
(
aDeviceContext
)
;
mDeviceContext
=
aDeviceContext
;
Element
*
root
=
mDocument
-
>
GetRootElement
(
)
;
if
(
root
&
&
root
-
>
HasServoData
(
)
)
{
RestyleManager
:
:
ClearServoDataFromSubtree
(
root
)
;
}
if
(
mDeviceContext
-
>
SetFullZoom
(
mFullZoom
)
)
mDeviceContext
-
>
FlushFontCache
(
)
;
mCurAppUnitsPerDevPixel
=
mDeviceContext
-
>
AppUnitsPerDevPixel
(
)
;
mEventManager
=
new
mozilla
:
:
EventStateManager
(
)
;
mAnimationEventDispatcher
=
new
mozilla
:
:
AnimationEventDispatcher
(
this
)
;
mEffectCompositor
=
new
mozilla
:
:
EffectCompositor
(
this
)
;
mTransitionManager
=
MakeUnique
<
nsTransitionManager
>
(
this
)
;
mAnimationManager
=
MakeUnique
<
nsAnimationManager
>
(
this
)
;
if
(
mDocument
-
>
GetDisplayDocument
(
)
)
{
NS_ASSERTION
(
mDocument
-
>
GetDisplayDocument
(
)
-
>
GetPresContext
(
)
"
Why
are
we
being
initialized
?
"
)
;
mRefreshDriver
=
mDocument
-
>
GetDisplayDocument
(
)
-
>
GetPresContext
(
)
-
>
RefreshDriver
(
)
;
}
else
{
dom
:
:
Document
*
parent
=
mDocument
-
>
GetInProcessParentDocument
(
)
;
NS_ASSERTION
(
!
parent
|
|
mDocument
-
>
IsStaticDocument
(
)
|
|
parent
-
>
GetPresShell
(
)
"
How
did
we
end
up
with
a
presshell
if
our
parent
doesn
'
t
"
"
have
one
?
"
)
;
if
(
parent
&
&
parent
-
>
GetPresContext
(
)
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
ourItem
=
mDocument
-
>
GetDocShell
(
)
;
if
(
ourItem
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
parentItem
;
ourItem
-
>
GetInProcessSameTypeParent
(
getter_AddRefs
(
parentItem
)
)
;
if
(
parentItem
)
{
Element
*
containingElement
=
parent
-
>
FindContentForSubDocument
(
mDocument
)
;
if
(
!
containingElement
-
>
IsXULElement
(
)
|
|
!
containingElement
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
forceOwnRefreshDriver
)
)
{
mRefreshDriver
=
parent
-
>
GetPresContext
(
)
-
>
RefreshDriver
(
)
;
}
}
}
}
if
(
!
mRefreshDriver
)
{
mRefreshDriver
=
new
nsRefreshDriver
(
this
)
;
if
(
XRE_IsContentProcess
(
)
)
{
mRefreshDriver
-
>
InitializeTimer
(
)
;
}
}
}
Preferences
:
:
RegisterPrefixCallbacks
(
nsPresContext
:
:
PreferenceChanged
gPrefixCallbackPrefs
this
)
;
Preferences
:
:
RegisterCallbacks
(
nsPresContext
:
:
PreferenceChanged
gExactCallbackPrefs
this
)
;
nsresult
rv
=
mEventManager
-
>
Init
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mEventManager
-
>
SetPresContext
(
this
)
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
if
(
IsRootContentDocumentCrossProcess
(
)
)
{
if
(
BrowserChild
*
browserChild
=
BrowserChild
:
:
GetFrom
(
mDocument
-
>
GetDocShell
(
)
)
)
{
mDynamicToolbarMaxHeight
=
browserChild
-
>
GetDynamicToolbarMaxHeight
(
)
;
}
}
#
endif
#
ifdef
DEBUG
mInitialized
=
true
;
#
endif
return
NS_OK
;
}
void
nsPresContext
:
:
AttachPresShell
(
mozilla
:
:
PresShell
*
aPresShell
)
{
MOZ_ASSERT
(
!
mPresShell
)
;
mPresShell
=
aPresShell
;
mRestyleManager
=
MakeUnique
<
mozilla
:
:
RestyleManager
>
(
this
)
;
mCounterStyleManager
=
new
mozilla
:
:
CounterStyleManager
(
this
)
;
dom
:
:
Document
*
doc
=
mPresShell
-
>
GetDocument
(
)
;
MOZ_ASSERT
(
doc
)
;
mDocument
=
doc
;
GetUserPreferences
(
)
;
nsIURI
*
docURI
=
doc
-
>
GetDocumentURI
(
)
;
if
(
IsDynamic
(
)
&
&
docURI
)
{
if
(
!
docURI
-
>
SchemeIs
(
"
chrome
"
)
&
&
!
docURI
-
>
SchemeIs
(
"
resource
"
)
)
mImageAnimationMode
=
mImageAnimationModePref
;
else
mImageAnimationMode
=
imgIContainer
:
:
kNormalAnimMode
;
}
UpdateCharSet
(
doc
-
>
GetDocumentCharacterSet
(
)
)
;
}
void
nsPresContext
:
:
DetachPresShell
(
)
{
if
(
mCounterStyleManager
)
{
mCounterStyleManager
-
>
Disconnect
(
)
;
mCounterStyleManager
=
nullptr
;
}
mPresShell
=
nullptr
;
if
(
mAnimationEventDispatcher
)
{
mAnimationEventDispatcher
-
>
Disconnect
(
)
;
mAnimationEventDispatcher
=
nullptr
;
}
if
(
mEffectCompositor
)
{
mEffectCompositor
-
>
Disconnect
(
)
;
mEffectCompositor
=
nullptr
;
}
if
(
mTransitionManager
)
{
mTransitionManager
-
>
Disconnect
(
)
;
mTransitionManager
=
nullptr
;
}
if
(
mAnimationManager
)
{
mAnimationManager
-
>
Disconnect
(
)
;
mAnimationManager
=
nullptr
;
}
if
(
mRestyleManager
)
{
mRestyleManager
-
>
Disconnect
(
)
;
mRestyleManager
=
nullptr
;
}
if
(
mRefreshDriver
&
&
mRefreshDriver
-
>
GetPresContext
(
)
=
=
this
)
{
mRefreshDriver
-
>
Disconnect
(
)
;
}
if
(
IsRoot
(
)
)
{
nsRootPresContext
*
thisRoot
=
static_cast
<
nsRootPresContext
*
>
(
this
)
;
thisRoot
-
>
CancelApplyPluginGeometryTimer
(
)
;
}
}
void
nsPresContext
:
:
DoChangeCharSet
(
NotNull
<
const
Encoding
*
>
aCharSet
)
{
UpdateCharSet
(
aCharSet
)
;
mDeviceContext
-
>
FlushFontCache
(
)
;
RebuildAllStyleData
(
NS_STYLE_HINT_REFLOW
RestyleHint
:
:
RecascadeSubtree
(
)
)
;
}
void
nsPresContext
:
:
UpdateCharSet
(
NotNull
<
const
Encoding
*
>
aCharSet
)
{
switch
(
GET_BIDI_OPTION_TEXTTYPE
(
GetBidi
(
)
)
)
{
case
IBMBIDI_TEXTTYPE_LOGICAL
:
SetVisualMode
(
false
)
;
break
;
case
IBMBIDI_TEXTTYPE_VISUAL
:
SetVisualMode
(
true
)
;
break
;
case
IBMBIDI_TEXTTYPE_CHARSET
:
default
:
SetVisualMode
(
IsVisualCharset
(
aCharSet
)
)
;
}
}
void
nsPresContext
:
:
DispatchCharSetChange
(
NotNull
<
const
Encoding
*
>
aEncoding
)
{
DoChangeCharSet
(
aEncoding
)
;
}
nsPresContext
*
nsPresContext
:
:
GetParentPresContext
(
)
{
mozilla
:
:
PresShell
*
presShell
=
GetPresShell
(
)
;
if
(
presShell
)
{
nsViewManager
*
viewManager
=
presShell
-
>
GetViewManager
(
)
;
if
(
viewManager
)
{
nsView
*
view
=
viewManager
-
>
GetRootView
(
)
;
if
(
view
)
{
view
=
view
-
>
GetParent
(
)
;
if
(
view
)
{
view
=
view
-
>
GetParent
(
)
;
if
(
view
)
{
nsIFrame
*
f
=
view
-
>
GetFrame
(
)
;
if
(
f
)
{
return
f
-
>
PresContext
(
)
;
}
}
}
}
}
}
return
nullptr
;
}
nsPresContext
*
nsPresContext
:
:
GetToplevelContentDocumentPresContext
(
)
{
if
(
IsChrome
(
)
)
return
nullptr
;
nsPresContext
*
pc
=
this
;
for
(
;
;
)
{
nsPresContext
*
parent
=
pc
-
>
GetParentPresContext
(
)
;
if
(
!
parent
|
|
parent
-
>
IsChrome
(
)
)
return
pc
;
pc
=
parent
;
}
}
nsIWidget
*
nsPresContext
:
:
GetNearestWidget
(
nsPoint
*
aOffset
)
{
NS_ENSURE_TRUE
(
mPresShell
nullptr
)
;
nsViewManager
*
vm
=
mPresShell
-
>
GetViewManager
(
)
;
NS_ENSURE_TRUE
(
vm
nullptr
)
;
nsView
*
rootView
=
vm
-
>
GetRootView
(
)
;
NS_ENSURE_TRUE
(
rootView
nullptr
)
;
return
rootView
-
>
GetNearestWidget
(
aOffset
)
;
}
nsIWidget
*
nsPresContext
:
:
GetRootWidget
(
)
const
{
NS_ENSURE_TRUE
(
mPresShell
nullptr
)
;
nsViewManager
*
vm
=
mPresShell
-
>
GetViewManager
(
)
;
if
(
!
vm
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIWidget
>
widget
;
vm
-
>
GetRootWidget
(
getter_AddRefs
(
widget
)
)
;
return
widget
.
get
(
)
;
}
nsRootPresContext
*
nsPresContext
:
:
GetRootPresContext
(
)
{
nsPresContext
*
pc
=
this
;
for
(
;
;
)
{
nsPresContext
*
parent
=
pc
-
>
GetParentPresContext
(
)
;
if
(
!
parent
)
break
;
pc
=
parent
;
}
return
pc
-
>
IsRoot
(
)
?
static_cast
<
nsRootPresContext
*
>
(
pc
)
:
nullptr
;
}
static
void
SetImgAnimModeOnImgReq
(
imgIRequest
*
aImgReq
uint16_t
aMode
)
{
if
(
aImgReq
)
{
nsCOMPtr
<
imgIContainer
>
imgCon
;
aImgReq
-
>
GetImage
(
getter_AddRefs
(
imgCon
)
)
;
if
(
imgCon
)
{
imgCon
-
>
SetAnimationMode
(
aMode
)
;
}
}
}
void
nsPresContext
:
:
SetImgAnimations
(
nsIContent
*
aParent
uint16_t
aMode
)
{
nsCOMPtr
<
nsIImageLoadingContent
>
imgContent
(
do_QueryInterface
(
aParent
)
)
;
if
(
imgContent
)
{
nsCOMPtr
<
imgIRequest
>
imgReq
;
imgContent
-
>
GetRequest
(
nsIImageLoadingContent
:
:
CURRENT_REQUEST
getter_AddRefs
(
imgReq
)
)
;
SetImgAnimModeOnImgReq
(
imgReq
aMode
)
;
}
for
(
nsIContent
*
childContent
=
aParent
-
>
GetFirstChild
(
)
;
childContent
;
childContent
=
childContent
-
>
GetNextSibling
(
)
)
{
SetImgAnimations
(
childContent
aMode
)
;
}
}
void
nsPresContext
:
:
SetSMILAnimations
(
dom
:
:
Document
*
aDoc
uint16_t
aNewMode
uint16_t
aOldMode
)
{
if
(
aDoc
-
>
HasAnimationController
(
)
)
{
SMILAnimationController
*
controller
=
aDoc
-
>
GetAnimationController
(
)
;
switch
(
aNewMode
)
{
case
imgIContainer
:
:
kNormalAnimMode
:
case
imgIContainer
:
:
kLoopOnceAnimMode
:
if
(
aOldMode
=
=
imgIContainer
:
:
kDontAnimMode
)
controller
-
>
Resume
(
SMILTimeContainer
:
:
PAUSE_USERPREF
)
;
break
;
case
imgIContainer
:
:
kDontAnimMode
:
if
(
aOldMode
!
=
imgIContainer
:
:
kDontAnimMode
)
controller
-
>
Pause
(
SMILTimeContainer
:
:
PAUSE_USERPREF
)
;
break
;
}
}
}
void
nsPresContext
:
:
SetImageAnimationMode
(
uint16_t
aMode
)
{
NS_ASSERTION
(
aMode
=
=
imgIContainer
:
:
kNormalAnimMode
|
|
aMode
=
=
imgIContainer
:
:
kDontAnimMode
|
|
aMode
=
=
imgIContainer
:
:
kLoopOnceAnimMode
"
Wrong
Animation
Mode
is
being
set
!
"
)
;
if
(
!
IsDynamic
(
)
)
return
;
if
(
mPresShell
)
{
dom
:
:
Document
*
doc
=
mPresShell
-
>
GetDocument
(
)
;
if
(
doc
)
{
doc
-
>
StyleImageLoader
(
)
-
>
SetAnimationMode
(
aMode
)
;
Element
*
rootElement
=
doc
-
>
GetRootElement
(
)
;
if
(
rootElement
)
{
SetImgAnimations
(
rootElement
aMode
)
;
}
SetSMILAnimations
(
doc
aMode
mImageAnimationMode
)
;
}
}
mImageAnimationMode
=
aMode
;
}
void
nsPresContext
:
:
UpdateEffectiveTextZoom
(
)
{
float
newZoom
=
mSystemFontScale
*
mTextZoom
;
float
minZoom
=
StaticPrefs
:
:
zoom_minPercent
(
)
/
100
.
0f
;
float
maxZoom
=
StaticPrefs
:
:
zoom_maxPercent
(
)
/
100
.
0f
;
if
(
newZoom
<
minZoom
)
{
newZoom
=
minZoom
;
}
else
if
(
newZoom
>
maxZoom
)
{
newZoom
=
maxZoom
;
}
mEffectiveTextZoom
=
newZoom
;
MediaFeatureValuesChanged
(
{
RestyleHint
:
:
RecascadeSubtree
(
)
NS_STYLE_HINT_REFLOW
MediaFeatureChangeReason
:
:
ZoomChange
}
)
;
}
float
nsPresContext
:
:
GetDeviceFullZoom
(
)
{
return
mDeviceContext
-
>
GetFullZoom
(
)
;
}
void
nsPresContext
:
:
SetFullZoom
(
float
aZoom
)
{
if
(
!
mPresShell
|
|
mFullZoom
=
=
aZoom
)
{
return
;
}
nscoord
oldWidthAppUnits
oldHeightAppUnits
;
mPresShell
-
>
GetViewManager
(
)
-
>
GetWindowDimensions
(
&
oldWidthAppUnits
&
oldHeightAppUnits
)
;
float
oldWidthDevPixels
=
oldWidthAppUnits
/
float
(
mCurAppUnitsPerDevPixel
)
;
float
oldHeightDevPixels
=
oldHeightAppUnits
/
float
(
mCurAppUnitsPerDevPixel
)
;
mDeviceContext
-
>
SetFullZoom
(
aZoom
)
;
NS_ASSERTION
(
!
mSuppressResizeReflow
"
two
zooms
happening
at
the
same
time
?
impossible
!
"
)
;
mSuppressResizeReflow
=
true
;
mFullZoom
=
aZoom
;
AppUnitsPerDevPixelChanged
(
)
;
mPresShell
-
>
GetViewManager
(
)
-
>
SetWindowDimensions
(
NSToCoordRound
(
oldWidthDevPixels
*
AppUnitsPerDevPixel
(
)
)
NSToCoordRound
(
oldHeightDevPixels
*
AppUnitsPerDevPixel
(
)
)
)
;
mSuppressResizeReflow
=
false
;
}
void
nsPresContext
:
:
SetOverrideDPPX
(
float
aDPPX
)
{
if
(
aDPPX
=
=
GetOverrideDPPX
(
)
)
{
return
;
}
mMediaEmulationData
.
mDPPX
=
aDPPX
;
MediaFeatureValuesChanged
(
{
MediaFeatureChangeReason
:
:
ResolutionChange
}
)
;
}
void
nsPresContext
:
:
SetOverridePrefersColorScheme
(
const
Maybe
<
StylePrefersColorScheme
>
&
aOverride
)
{
if
(
GetOverridePrefersColorScheme
(
)
=
=
aOverride
)
{
return
;
}
mMediaEmulationData
.
mPrefersColorScheme
=
aOverride
;
MediaFeatureValuesChanged
(
{
MediaFeatureChangeReason
:
:
SystemMetricsChange
}
)
;
}
gfxSize
nsPresContext
:
:
ScreenSizeInchesForFontInflation
(
bool
*
aChanged
)
{
if
(
aChanged
)
{
*
aChanged
=
false
;
}
nsDeviceContext
*
dx
=
DeviceContext
(
)
;
nsRect
clientRect
;
dx
-
>
GetClientRect
(
clientRect
)
;
float
unitsPerInch
=
dx
-
>
AppUnitsPerPhysicalInch
(
)
;
gfxSize
deviceSizeInches
(
float
(
clientRect
.
width
)
/
unitsPerInch
float
(
clientRect
.
height
)
/
unitsPerInch
)
;
if
(
mLastFontInflationScreenSize
=
=
gfxSize
(
-
1
.
0
-
1
.
0
)
)
{
mLastFontInflationScreenSize
=
deviceSizeInches
;
}
if
(
deviceSizeInches
!
=
mLastFontInflationScreenSize
&
&
aChanged
)
{
*
aChanged
=
true
;
mLastFontInflationScreenSize
=
deviceSizeInches
;
}
return
deviceSizeInches
;
}
static
bool
CheckOverflow
(
const
ComputedStyle
*
aComputedStyle
ScrollStyles
*
aStyles
)
{
if
(
!
aComputedStyle
)
{
return
false
;
}
const
nsStyleDisplay
*
display
=
aComputedStyle
-
>
StyleDisplay
(
)
;
if
(
display
-
>
mDisplay
=
=
StyleDisplay
:
:
None
|
|
display
-
>
mDisplay
=
=
StyleDisplay
:
:
Contents
)
{
return
false
;
}
if
(
display
-
>
mOverflowX
=
=
StyleOverflow
:
:
Visible
)
{
MOZ_ASSERT
(
display
-
>
mOverflowY
=
=
StyleOverflow
:
:
Visible
)
;
return
false
;
}
if
(
display
-
>
mOverflowX
=
=
StyleOverflow
:
:
MozHiddenUnscrollable
)
{
*
aStyles
=
ScrollStyles
(
StyleOverflow
:
:
Hidden
StyleOverflow
:
:
Hidden
)
;
}
else
{
*
aStyles
=
ScrollStyles
(
*
display
)
;
}
return
true
;
}
static
Element
*
GetPropagatedScrollStylesForViewport
(
nsPresContext
*
aPresContext
ScrollStyles
*
aStyles
)
{
Document
*
document
=
aPresContext
-
>
Document
(
)
;
Element
*
docElement
=
document
-
>
GetRootElement
(
)
;
if
(
!
docElement
)
{
return
nullptr
;
}
const
auto
*
rootStyle
=
Servo_Element_GetMaybeOutOfDateStyle
(
docElement
)
;
if
(
CheckOverflow
(
rootStyle
aStyles
)
)
{
return
docElement
;
}
if
(
!
document
-
>
IsHTMLOrXHTML
(
)
|
|
!
docElement
-
>
IsHTMLElement
(
)
)
{
return
nullptr
;
}
Element
*
bodyElement
=
document
-
>
AsHTMLDocument
(
)
-
>
GetBodyElement
(
)
;
if
(
!
bodyElement
)
{
return
nullptr
;
}
MOZ_ASSERT
(
bodyElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
"
GetBodyElement
returned
something
bogus
"
)
;
const
auto
*
bodyStyle
=
Servo_Element_GetMaybeOutOfDateStyle
(
bodyElement
)
;
if
(
CheckOverflow
(
bodyStyle
aStyles
)
)
{
return
bodyElement
;
}
return
nullptr
;
}
Element
*
nsPresContext
:
:
UpdateViewportScrollStylesOverride
(
)
{
mViewportScrollStyles
=
ScrollStyles
(
StyleOverflow
:
:
Auto
StyleOverflow
:
:
Auto
)
;
mViewportScrollOverrideElement
=
nullptr
;
if
(
!
IsPaginated
(
)
)
{
mViewportScrollOverrideElement
=
GetPropagatedScrollStylesForViewport
(
this
&
mViewportScrollStyles
)
;
}
dom
:
:
Document
*
document
=
Document
(
)
;
if
(
Element
*
fullscreenElement
=
document
-
>
GetFullscreenElement
(
)
)
{
if
(
fullscreenElement
!
=
document
-
>
GetRootElement
(
)
&
&
fullscreenElement
!
=
mViewportScrollOverrideElement
)
{
mViewportScrollStyles
=
ScrollStyles
(
StyleOverflow
:
:
Hidden
StyleOverflow
:
:
Hidden
)
;
}
}
return
mViewportScrollOverrideElement
;
}
bool
nsPresContext
:
:
ElementWouldPropagateScrollStyles
(
const
Element
&
aElement
)
{
MOZ_ASSERT
(
IsPaginated
(
)
"
Should
only
be
called
on
paginated
contexts
"
)
;
if
(
aElement
.
GetParent
(
)
&
&
!
aElement
.
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
return
false
;
}
ScrollStyles
dummy
(
StyleOverflow
:
:
Auto
StyleOverflow
:
:
Auto
)
;
return
GetPropagatedScrollStylesForViewport
(
this
&
dummy
)
=
=
&
aElement
;
}
nsISupports
*
nsPresContext
:
:
GetContainerWeak
(
)
const
{
return
GetDocShell
(
)
;
}
nsIDocShell
*
nsPresContext
:
:
GetDocShell
(
)
const
{
return
mDocument
-
>
GetDocShell
(
)
;
}
bool
nsPresContext
:
:
BidiEnabled
(
)
const
{
return
Document
(
)
-
>
GetBidiEnabled
(
)
;
}
void
nsPresContext
:
:
SetBidiEnabled
(
)
const
{
Document
(
)
-
>
SetBidiEnabled
(
)
;
}
void
nsPresContext
:
:
SetBidi
(
uint32_t
aSource
)
{
if
(
aSource
=
=
GetBidi
(
)
)
{
return
;
}
Document
(
)
-
>
SetBidiOptions
(
aSource
)
;
if
(
IBMBIDI_TEXTDIRECTION_RTL
=
=
GET_BIDI_OPTION_DIRECTION
(
aSource
)
|
|
IBMBIDI_NUMERAL_HINDI
=
=
GET_BIDI_OPTION_NUMERAL
(
aSource
)
)
{
SetBidiEnabled
(
)
;
}
if
(
IBMBIDI_TEXTTYPE_VISUAL
=
=
GET_BIDI_OPTION_TEXTTYPE
(
aSource
)
)
{
SetVisualMode
(
true
)
;
}
else
if
(
IBMBIDI_TEXTTYPE_LOGICAL
=
=
GET_BIDI_OPTION_TEXTTYPE
(
aSource
)
)
{
SetVisualMode
(
false
)
;
}
else
{
SetVisualMode
(
IsVisualCharset
(
Document
(
)
-
>
GetDocumentCharacterSet
(
)
)
)
;
}
}
uint32_t
nsPresContext
:
:
GetBidi
(
)
const
{
return
Document
(
)
-
>
GetBidiOptions
(
)
;
}
void
nsPresContext
:
:
RecordInteractionTime
(
InteractionType
aType
const
TimeStamp
&
aTimeStamp
)
{
if
(
!
mInteractionTimeEnabled
|
|
aTimeStamp
.
IsNull
(
)
)
{
return
;
}
TimeStamp
nsPresContext
:
:
*
interactionTimes
[
]
=
{
&
nsPresContext
:
:
mFirstClickTime
&
nsPresContext
:
:
mFirstKeyTime
&
nsPresContext
:
:
mFirstMouseMoveTime
&
nsPresContext
:
:
mFirstScrollTime
}
;
Telemetry
:
:
HistogramID
histogramIds
[
]
=
{
Telemetry
:
:
TIME_TO_FIRST_CLICK_MS
Telemetry
:
:
TIME_TO_FIRST_KEY_INPUT_MS
Telemetry
:
:
TIME_TO_FIRST_MOUSE_MOVE_MS
Telemetry
:
:
TIME_TO_FIRST_SCROLL_MS
}
;
TimeStamp
&
interactionTime
=
this
-
>
*
(
interactionTimes
[
static_cast
<
uint32_t
>
(
aType
)
]
)
;
if
(
!
interactionTime
.
IsNull
(
)
)
{
return
;
}
nsPresContext
*
topContentPresContext
=
GetToplevelContentDocumentPresContext
(
)
;
if
(
!
topContentPresContext
)
{
interactionTime
=
TimeStamp
:
:
Now
(
)
;
return
;
}
if
(
topContentPresContext
-
>
mFirstNonBlankPaintTime
.
IsNull
(
)
|
|
topContentPresContext
-
>
mFirstNonBlankPaintTime
>
aTimeStamp
)
{
return
;
}
bool
isFirstInteraction
=
true
;
for
(
TimeStamp
nsPresContext
:
:
*
memberPtr
:
interactionTimes
)
{
TimeStamp
&
timeStamp
=
this
-
>
*
(
memberPtr
)
;
if
(
!
timeStamp
.
IsNull
(
)
)
{
isFirstInteraction
=
false
;
break
;
}
}
interactionTime
=
TimeStamp
:
:
Now
(
)
;
if
(
this
=
=
topContentPresContext
)
{
if
(
Telemetry
:
:
CanRecordExtended
(
)
)
{
double
millis
=
(
interactionTime
-
mFirstNonBlankPaintTime
)
.
ToMilliseconds
(
)
;
Telemetry
:
:
Accumulate
(
histogramIds
[
static_cast
<
uint32_t
>
(
aType
)
]
millis
)
;
if
(
isFirstInteraction
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
TIME_TO_FIRST_INTERACTION_MS
millis
)
;
}
}
}
else
{
topContentPresContext
-
>
RecordInteractionTime
(
aType
aTimeStamp
)
;
}
}
nsITheme
*
nsPresContext
:
:
GetTheme
(
)
{
if
(
!
sNoTheme
&
&
!
mTheme
)
{
mTheme
=
do_GetNativeTheme
(
)
;
if
(
!
mTheme
)
sNoTheme
=
true
;
}
return
mTheme
;
}
void
nsPresContext
:
:
ThemeChanged
(
)
{
if
(
!
mPendingThemeChanged
)
{
sLookAndFeelChanged
=
true
;
sThemeChanged
=
true
;
nsCOMPtr
<
nsIRunnable
>
ev
=
NewRunnableMethod
(
"
nsPresContext
:
:
ThemeChangedInternal
"
this
&
nsPresContext
:
:
ThemeChangedInternal
)
;
nsresult
rv
=
Document
(
)
-
>
Dispatch
(
TaskCategory
:
:
Other
ev
.
forget
(
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mPendingThemeChanged
=
true
;
}
}
}
static
bool
NotifyThemeChanged
(
BrowserParent
*
aBrowserParent
void
*
aArg
)
{
aBrowserParent
-
>
ThemeChanged
(
)
;
return
false
;
}
void
nsPresContext
:
:
ThemeChangedInternal
(
)
{
mPendingThemeChanged
=
false
;
if
(
mTheme
&
&
sThemeChanged
)
{
mTheme
-
>
ThemeChanged
(
)
;
sThemeChanged
=
false
;
}
if
(
sLookAndFeelChanged
)
{
LookAndFeel
:
:
Refresh
(
)
;
sLookAndFeelChanged
=
false
;
image
:
:
SurfaceCacheUtils
:
:
DiscardAll
(
)
;
}
RefreshSystemMetrics
(
)
;
PreferenceSheet
:
:
Refresh
(
)
;
if
(
nsPIDOMWindowOuter
*
window
=
mDocument
-
>
GetWindow
(
)
)
{
nsContentUtils
:
:
CallOnAllRemoteChildren
(
window
NotifyThemeChanged
nullptr
)
;
}
}
void
nsPresContext
:
:
SysColorChanged
(
)
{
if
(
!
mPendingSysColorChanged
)
{
sLookAndFeelChanged
=
true
;
nsCOMPtr
<
nsIRunnable
>
ev
=
NewRunnableMethod
(
"
nsPresContext
:
:
SysColorChangedInternal
"
this
&
nsPresContext
:
:
SysColorChangedInternal
)
;
nsresult
rv
=
Document
(
)
-
>
Dispatch
(
TaskCategory
:
:
Other
ev
.
forget
(
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mPendingSysColorChanged
=
true
;
}
}
}
void
nsPresContext
:
:
SysColorChangedInternal
(
)
{
mPendingSysColorChanged
=
false
;
if
(
sLookAndFeelChanged
)
{
LookAndFeel
:
:
Refresh
(
)
;
sLookAndFeelChanged
=
false
;
}
RefreshSystemMetrics
(
)
;
PreferenceSheet
:
:
Refresh
(
)
;
RebuildAllStyleData
(
nsChangeHint
(
0
)
RestyleHint
{
0
}
)
;
}
void
nsPresContext
:
:
RefreshSystemMetrics
(
)
{
nsMediaFeatures
:
:
FreeSystemMetrics
(
)
;
MediaFeatureValuesChangedAllDocuments
(
{
RestyleHint
:
:
RecascadeSubtree
(
)
NS_STYLE_HINT_REFLOW
MediaFeatureChangeReason
:
:
SystemMetricsChange
}
)
;
}
void
nsPresContext
:
:
UIResolutionChanged
(
)
{
if
(
!
mPendingUIResolutionChanged
)
{
nsCOMPtr
<
nsIRunnable
>
ev
=
NewRunnableMethod
(
"
nsPresContext
:
:
UIResolutionChangedInternal
"
this
&
nsPresContext
:
:
UIResolutionChangedInternal
)
;
nsresult
rv
=
Document
(
)
-
>
Dispatch
(
TaskCategory
:
:
Other
ev
.
forget
(
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mPendingUIResolutionChanged
=
true
;
}
}
}
void
nsPresContext
:
:
UIResolutionChangedSync
(
)
{
if
(
!
mPendingUIResolutionChanged
)
{
mPendingUIResolutionChanged
=
true
;
UIResolutionChangedInternalScale
(
0
.
0
)
;
}
}
bool
nsPresContext
:
:
UIResolutionChangedSubdocumentCallback
(
dom
:
:
Document
*
aDocument
void
*
aData
)
{
nsPresContext
*
pc
=
aDocument
-
>
GetPresContext
(
)
;
if
(
pc
)
{
double
scale
=
*
static_cast
<
double
*
>
(
aData
)
;
pc
-
>
UIResolutionChangedInternalScale
(
scale
)
;
}
return
true
;
}
static
void
NotifyTabUIResolutionChanged
(
nsIRemoteTab
*
aTab
void
*
aArg
)
{
aTab
-
>
NotifyResolutionChanged
(
)
;
}
static
void
NotifyChildrenUIResolutionChanged
(
nsPIDOMWindowOuter
*
aWindow
)
{
nsCOMPtr
<
Document
>
doc
=
aWindow
-
>
GetExtantDoc
(
)
;
RefPtr
<
nsPIWindowRoot
>
topLevelWin
=
nsContentUtils
:
:
GetWindowRoot
(
doc
)
;
if
(
!
topLevelWin
)
{
return
;
}
topLevelWin
-
>
EnumerateBrowsers
(
NotifyTabUIResolutionChanged
nullptr
)
;
}
void
nsPresContext
:
:
UIResolutionChangedInternal
(
)
{
UIResolutionChangedInternalScale
(
0
.
0
)
;
}
void
nsPresContext
:
:
UIResolutionChangedInternalScale
(
double
aScale
)
{
mPendingUIResolutionChanged
=
false
;
mDeviceContext
-
>
CheckDPIChange
(
&
aScale
)
;
if
(
mCurAppUnitsPerDevPixel
!
=
mDeviceContext
-
>
AppUnitsPerDevPixel
(
)
)
{
AppUnitsPerDevPixelChanged
(
)
;
}
if
(
nsPIDOMWindowOuter
*
window
=
mDocument
-
>
GetWindow
(
)
)
{
NotifyChildrenUIResolutionChanged
(
window
)
;
}
mDocument
-
>
EnumerateSubDocuments
(
UIResolutionChangedSubdocumentCallback
&
aScale
)
;
}
void
nsPresContext
:
:
EmulateMedium
(
nsAtom
*
aMediaType
)
{
MOZ_ASSERT
(
!
aMediaType
|
|
aMediaType
-
>
IsAsciiLowercase
(
)
)
;
RefPtr
<
const
nsAtom
>
oldMedium
=
Medium
(
)
;
mMediaEmulationData
.
mMedium
=
aMediaType
;
if
(
Medium
(
)
!
=
oldMedium
)
{
MediaFeatureValuesChanged
(
{
MediaFeatureChangeReason
:
:
MediumChange
}
)
;
}
}
void
nsPresContext
:
:
ContentLanguageChanged
(
)
{
PostRebuildAllStyleDataEvent
(
nsChangeHint
(
0
)
RestyleHint
:
:
RecascadeSubtree
(
)
)
;
}
void
nsPresContext
:
:
MediaFeatureValuesChanged
(
const
MediaFeatureChange
&
aChange
)
{
if
(
mPresShell
)
{
mPresShell
-
>
EnsureStyleFlush
(
)
;
}
if
(
!
mPendingMediaFeatureValuesChange
)
{
mPendingMediaFeatureValuesChange
.
emplace
(
aChange
)
;
return
;
}
*
mPendingMediaFeatureValuesChange
|
=
aChange
;
}
void
nsPresContext
:
:
RebuildAllStyleData
(
nsChangeHint
aExtraHint
RestyleHint
aRestyleHint
)
{
if
(
!
mPresShell
)
{
return
;
}
mUsesRootEMUnits
=
false
;
mUsesExChUnits
=
false
;
mDocument
-
>
MarkUserFontSetDirty
(
)
;
MarkCounterStylesDirty
(
)
;
MarkFontFeatureValuesDirty
(
)
;
RestyleManager
(
)
-
>
RebuildAllStyleData
(
aExtraHint
aRestyleHint
)
;
}
void
nsPresContext
:
:
PostRebuildAllStyleDataEvent
(
nsChangeHint
aExtraHint
RestyleHint
aRestyleHint
)
{
if
(
!
mPresShell
)
{
return
;
}
RestyleManager
(
)
-
>
PostRebuildAllStyleDataEvent
(
aExtraHint
aRestyleHint
)
;
}
static
bool
MediaFeatureValuesChangedAllDocumentsCallback
(
Document
*
aDocument
void
*
aChange
)
{
auto
*
change
=
static_cast
<
const
MediaFeatureChange
*
>
(
aChange
)
;
if
(
nsPresContext
*
pc
=
aDocument
-
>
GetPresContext
(
)
)
{
pc
-
>
MediaFeatureValuesChangedAllDocuments
(
*
change
)
;
}
return
true
;
}
void
nsPresContext
:
:
MediaFeatureValuesChangedAllDocuments
(
const
MediaFeatureChange
&
aChange
)
{
MediaFeatureValuesChanged
(
aChange
)
;
mDocument
-
>
EnumerateSubDocuments
(
MediaFeatureValuesChangedAllDocumentsCallback
const_cast
<
MediaFeatureChange
*
>
(
&
aChange
)
)
;
}
void
nsPresContext
:
:
FlushPendingMediaFeatureValuesChanged
(
)
{
if
(
!
mPendingMediaFeatureValuesChange
)
{
return
;
}
MediaFeatureChange
change
=
*
mPendingMediaFeatureValuesChange
;
mPendingMediaFeatureValuesChange
.
reset
(
)
;
if
(
mPresShell
)
{
change
.
mRestyleHint
|
=
mPresShell
-
>
StyleSet
(
)
-
>
MediumFeaturesChanged
(
change
.
mReason
)
;
}
if
(
change
.
mRestyleHint
|
|
change
.
mChangeHint
)
{
RebuildAllStyleData
(
change
.
mChangeHint
change
.
mRestyleHint
)
;
}
if
(
!
mPresShell
|
|
!
mPresShell
-
>
DidInitialize
(
)
)
{
return
;
}
if
(
mDocument
-
>
IsBeingUsedAsImage
(
)
)
{
MOZ_ASSERT
(
mDocument
-
>
MediaQueryLists
(
)
.
isEmpty
(
)
)
;
return
;
}
mDocument
-
>
NotifyMediaFeatureValuesChanged
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
;
if
(
mDocument
-
>
MediaQueryLists
(
)
.
isEmpty
(
)
)
{
return
;
}
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
MediaQueryList
>
>
localMediaQueryLists
;
for
(
MediaQueryList
*
mql
=
mDocument
-
>
MediaQueryLists
(
)
.
getFirst
(
)
;
mql
;
mql
=
static_cast
<
LinkedListElement
<
MediaQueryList
>
*
>
(
mql
)
-
>
getNext
(
)
)
{
localMediaQueryLists
.
AppendElement
(
mql
)
;
}
for
(
const
auto
&
mql
:
localMediaQueryLists
)
{
nsAutoMicroTask
mt
;
mql
-
>
MaybeNotify
(
)
;
}
}
static
bool
NotifyTabSizeModeChanged
(
BrowserParent
*
aTab
void
*
aArg
)
{
nsSizeMode
*
sizeMode
=
static_cast
<
nsSizeMode
*
>
(
aArg
)
;
aTab
-
>
SizeModeChanged
(
*
sizeMode
)
;
return
false
;
}
void
nsPresContext
:
:
SizeModeChanged
(
nsSizeMode
aSizeMode
)
{
if
(
nsPIDOMWindowOuter
*
window
=
mDocument
-
>
GetWindow
(
)
)
{
nsContentUtils
:
:
CallOnAllRemoteChildren
(
window
NotifyTabSizeModeChanged
&
aSizeMode
)
;
}
MediaFeatureValuesChangedAllDocuments
(
{
MediaFeatureChangeReason
:
:
SizeModeChange
}
)
;
}
nsCompatibility
nsPresContext
:
:
CompatibilityMode
(
)
const
{
return
Document
(
)
-
>
GetCompatibilityMode
(
)
;
}
void
nsPresContext
:
:
SetPaginatedScrolling
(
bool
aPaginated
)
{
if
(
mType
=
=
eContext_PrintPreview
|
|
mType
=
=
eContext_PageLayout
)
mCanPaginatedScroll
=
aPaginated
;
}
void
nsPresContext
:
:
SetPrintSettings
(
nsIPrintSettings
*
aPrintSettings
)
{
if
(
mMedium
=
=
nsGkAtoms
:
:
print
)
mPrintSettings
=
aPrintSettings
;
}
bool
nsPresContext
:
:
EnsureVisible
(
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
(
GetDocShell
(
)
)
;
if
(
!
docShell
)
{
return
false
;
}
nsCOMPtr
<
nsIContentViewer
>
cv
;
docShell
-
>
GetContentViewer
(
getter_AddRefs
(
cv
)
)
;
if
(
!
cv
|
|
cv
-
>
GetPresContext
(
)
!
=
this
)
{
return
false
;
}
nsresult
result
=
cv
-
>
Show
(
)
;
return
NS_SUCCEEDED
(
result
)
;
}
#
ifdef
MOZ_REFLOW_PERF
void
nsPresContext
:
:
CountReflows
(
const
char
*
aName
nsIFrame
*
aFrame
)
{
if
(
mPresShell
)
{
mPresShell
-
>
CountReflows
(
aName
aFrame
)
;
}
}
#
endif
bool
nsPresContext
:
:
HasAuthorSpecifiedRules
(
const
nsIFrame
*
aFrame
uint32_t
aRuleTypeMask
)
const
{
Element
*
elem
=
aFrame
-
>
GetContent
(
)
-
>
AsElement
(
)
;
if
(
elem
-
>
GetPseudoElementType
(
)
!
=
PseudoStyleType
:
:
NotPseudo
)
{
MOZ_ASSERT
(
elem
-
>
GetParent
(
)
"
Pseudo
element
has
no
parent
element
?
"
)
;
elem
=
elem
-
>
GetParent
(
)
-
>
AsElement
(
)
;
}
if
(
MOZ_UNLIKELY
(
!
elem
-
>
HasServoData
(
)
)
)
{
return
false
;
}
if
(
aFrame
-
>
Style
(
)
-
>
IsAnonBox
(
)
)
{
return
false
;
}
auto
*
set
=
PresShell
(
)
-
>
StyleSet
(
)
-
>
RawSet
(
)
;
return
Servo_HasAuthorSpecifiedRules
(
set
aFrame
-
>
Style
(
)
elem
aRuleTypeMask
)
;
}
gfxUserFontSet
*
nsPresContext
:
:
GetUserFontSet
(
)
{
return
mDocument
-
>
GetUserFontSet
(
)
;
}
void
nsPresContext
:
:
UserFontSetUpdated
(
gfxUserFontEntry
*
aUpdatedFont
)
{
if
(
!
mPresShell
)
{
return
;
}
if
(
!
aUpdatedFont
)
{
auto
hint
=
UsesExChUnits
(
)
?
RestyleHint
:
:
RecascadeSubtree
(
)
:
RestyleHint
{
0
}
;
PostRebuildAllStyleDataEvent
(
NS_STYLE_HINT_REFLOW
hint
)
;
return
;
}
if
(
nsIFrame
*
root
=
mPresShell
-
>
GetRootFrame
(
)
)
{
nsFontFaceUtils
:
:
MarkDirtyForFontChange
(
root
aUpdatedFont
)
;
}
}
class
CounterStyleCleaner
final
:
public
nsAPostRefreshObserver
{
public
:
CounterStyleCleaner
(
nsRefreshDriver
*
aRefreshDriver
CounterStyleManager
*
aCounterStyleManager
)
:
mRefreshDriver
(
aRefreshDriver
)
mCounterStyleManager
(
aCounterStyleManager
)
{
}
virtual
~
CounterStyleCleaner
(
)
{
}
void
DidRefresh
(
)
final
{
mRefreshDriver
-
>
RemovePostRefreshObserver
(
this
)
;
mCounterStyleManager
-
>
CleanRetiredStyles
(
)
;
delete
this
;
}
private
:
RefPtr
<
nsRefreshDriver
>
mRefreshDriver
;
RefPtr
<
CounterStyleManager
>
mCounterStyleManager
;
}
;
void
nsPresContext
:
:
FlushCounterStyles
(
)
{
if
(
!
mPresShell
)
{
return
;
}
if
(
mCounterStyleManager
-
>
IsInitial
(
)
)
{
return
;
}
if
(
mCounterStylesDirty
)
{
bool
changed
=
mCounterStyleManager
-
>
NotifyRuleChanged
(
)
;
if
(
changed
)
{
PresShell
(
)
-
>
NotifyCounterStylesAreDirty
(
)
;
PostRebuildAllStyleDataEvent
(
NS_STYLE_HINT_REFLOW
RestyleHint
{
0
}
)
;
RefreshDriver
(
)
-
>
AddPostRefreshObserver
(
new
CounterStyleCleaner
(
RefreshDriver
(
)
mCounterStyleManager
)
)
;
}
mCounterStylesDirty
=
false
;
}
}
void
nsPresContext
:
:
MarkCounterStylesDirty
(
)
{
if
(
mCounterStyleManager
-
>
IsInitial
(
)
)
{
return
;
}
mCounterStylesDirty
=
true
;
}
void
nsPresContext
:
:
NotifyMissingFonts
(
)
{
if
(
mMissingFonts
)
{
mMissingFonts
-
>
Flush
(
)
;
}
}
void
nsPresContext
:
:
EnsureSafeToHandOutCSSRules
(
)
{
if
(
!
mPresShell
-
>
StyleSet
(
)
-
>
EnsureUniqueInnerOnCSSSheets
(
)
)
{
return
;
}
RebuildAllStyleData
(
nsChangeHint
(
0
)
RestyleHint
:
:
RestyleSubtree
(
)
)
;
}
void
nsPresContext
:
:
FireDOMPaintEvent
(
nsTArray
<
nsRect
>
*
aList
TransactionId
aTransactionId
mozilla
:
:
TimeStamp
aTimeStamp
)
{
nsPIDOMWindowInner
*
ourWindow
=
mDocument
-
>
GetInnerWindow
(
)
;
if
(
!
ourWindow
)
return
;
nsCOMPtr
<
EventTarget
>
dispatchTarget
=
do_QueryInterface
(
ourWindow
)
;
nsCOMPtr
<
EventTarget
>
eventTarget
=
dispatchTarget
;
if
(
!
IsChrome
(
)
&
&
!
mSendAfterPaintToContent
)
{
dispatchTarget
=
ourWindow
-
>
GetParentTarget
(
)
;
if
(
!
dispatchTarget
)
{
return
;
}
}
if
(
aTimeStamp
.
IsNull
(
)
)
{
aTimeStamp
=
mozilla
:
:
TimeStamp
:
:
Now
(
)
;
}
DOMHighResTimeStamp
timeStamp
=
0
;
if
(
ourWindow
)
{
mozilla
:
:
dom
:
:
Performance
*
perf
=
ourWindow
-
>
GetPerformance
(
)
;
if
(
perf
)
{
timeStamp
=
perf
-
>
GetDOMTiming
(
)
-
>
TimeStampToDOMHighRes
(
aTimeStamp
)
;
}
}
RefPtr
<
NotifyPaintEvent
>
event
=
NS_NewDOMNotifyPaintEvent
(
eventTarget
this
nullptr
eAfterPaint
aList
uint64_t
(
aTransactionId
)
timeStamp
)
;
event
-
>
SetTarget
(
eventTarget
)
;
event
-
>
SetTrusted
(
true
)
;
EventDispatcher
:
:
DispatchDOMEvent
(
dispatchTarget
nullptr
static_cast
<
Event
*
>
(
event
)
this
nullptr
)
;
}
static
bool
MayHavePaintEventListenerSubdocumentCallback
(
Document
*
aDocument
void
*
aData
)
{
bool
*
result
=
static_cast
<
bool
*
>
(
aData
)
;
nsPresContext
*
pc
=
aDocument
-
>
GetPresContext
(
)
;
if
(
pc
)
{
*
result
=
pc
-
>
MayHavePaintEventListenerInSubDocument
(
)
;
return
!
*
result
;
}
return
true
;
}
static
bool
MayHavePaintEventListener
(
nsPIDOMWindowInner
*
aInnerWindow
)
{
if
(
!
aInnerWindow
)
return
false
;
if
(
aInnerWindow
-
>
HasPaintEventListeners
(
)
)
return
true
;
EventTarget
*
parentTarget
=
aInnerWindow
-
>
GetParentTarget
(
)
;
if
(
!
parentTarget
)
return
false
;
EventListenerManager
*
manager
=
nullptr
;
if
(
(
manager
=
parentTarget
-
>
GetExistingListenerManager
(
)
)
&
&
manager
-
>
MayHavePaintEventListener
(
)
)
{
return
true
;
}
nsCOMPtr
<
nsINode
>
node
;
if
(
parentTarget
!
=
aInnerWindow
-
>
GetChromeEventHandler
(
)
)
{
nsCOMPtr
<
nsIInProcessContentFrameMessageManager
>
mm
=
do_QueryInterface
(
parentTarget
)
;
if
(
mm
)
{
node
=
mm
-
>
GetOwnerContent
(
)
;
}
}
if
(
!
node
)
{
node
=
do_QueryInterface
(
parentTarget
)
;
}
if
(
node
)
return
MayHavePaintEventListener
(
node
-
>
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
)
;
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
parentTarget
)
;
if
(
window
)
return
MayHavePaintEventListener
(
window
)
;
nsCOMPtr
<
nsPIWindowRoot
>
root
=
do_QueryInterface
(
parentTarget
)
;
EventTarget
*
browserChildGlobal
;
return
root
&
&
(
browserChildGlobal
=
root
-
>
GetParentTarget
(
)
)
&
&
(
manager
=
browserChildGlobal
-
>
GetExistingListenerManager
(
)
)
&
&
manager
-
>
MayHavePaintEventListener
(
)
;
}
bool
nsPresContext
:
:
MayHavePaintEventListener
(
)
{
return
:
:
MayHavePaintEventListener
(
mDocument
-
>
GetInnerWindow
(
)
)
;
}
bool
nsPresContext
:
:
MayHavePaintEventListenerInSubDocument
(
)
{
if
(
MayHavePaintEventListener
(
)
)
{
return
true
;
}
bool
result
=
false
;
mDocument
-
>
EnumerateSubDocuments
(
MayHavePaintEventListenerSubdocumentCallback
&
result
)
;
return
result
;
}
void
nsPresContext
:
:
NotifyInvalidation
(
TransactionId
aTransactionId
const
nsIntRect
&
aRect
)
{
nsIntRect
clampedRect
=
nsIntRect
:
:
MaxIntRect
(
)
;
clampedRect
.
ScaleInverseRoundIn
(
AppUnitsPerDevPixel
(
)
)
;
clampedRect
=
clampedRect
.
Intersect
(
aRect
)
;
nsRect
rect
(
DevPixelsToAppUnits
(
clampedRect
.
x
)
DevPixelsToAppUnits
(
clampedRect
.
y
)
DevPixelsToAppUnits
(
clampedRect
.
width
)
DevPixelsToAppUnits
(
clampedRect
.
height
)
)
;
NotifyInvalidation
(
aTransactionId
rect
)
;
}
nsPresContext
:
:
TransactionInvalidations
*
nsPresContext
:
:
GetInvalidations
(
TransactionId
aTransactionId
)
{
for
(
TransactionInvalidations
&
t
:
mTransactions
)
{
if
(
t
.
mTransactionId
=
=
aTransactionId
)
{
return
&
t
;
}
}
return
nullptr
;
}
void
nsPresContext
:
:
NotifyInvalidation
(
TransactionId
aTransactionId
const
nsRect
&
aRect
)
{
MOZ_ASSERT
(
GetContainerWeak
(
)
"
Invalidation
in
detached
pres
context
"
)
;
nsPresContext
*
pc
;
for
(
pc
=
this
;
pc
;
pc
=
pc
-
>
GetParentPresContext
(
)
)
{
TransactionInvalidations
*
transaction
=
pc
-
>
GetInvalidations
(
aTransactionId
)
;
if
(
transaction
)
{
break
;
}
else
{
transaction
=
pc
-
>
mTransactions
.
AppendElement
(
)
;
transaction
-
>
mTransactionId
=
aTransactionId
;
}
}
TransactionInvalidations
*
transaction
=
GetInvalidations
(
aTransactionId
)
;
MOZ_ASSERT
(
transaction
)
;
transaction
-
>
mInvalidations
.
AppendElement
(
aRect
)
;
}
void
nsPresContext
:
:
NotifySubDocInvalidation
(
ContainerLayer
*
aContainer
const
nsIntRegion
*
aRegion
)
{
ContainerLayerPresContext
*
data
=
static_cast
<
ContainerLayerPresContext
*
>
(
aContainer
-
>
GetUserData
(
&
gNotifySubDocInvalidationData
)
)
;
if
(
!
data
)
{
return
;
}
TransactionId
transactionId
=
aContainer
-
>
Manager
(
)
-
>
GetLastTransactionId
(
)
;
IntRect
visibleBounds
=
aContainer
-
>
GetVisibleRegion
(
)
.
GetBounds
(
)
.
ToUnknownRect
(
)
;
if
(
!
aRegion
)
{
IntRect
rect
(
IntPoint
(
0
0
)
visibleBounds
.
Size
(
)
)
;
data
-
>
mPresContext
-
>
NotifyInvalidation
(
transactionId
rect
)
;
return
;
}
nsIntPoint
topLeft
=
visibleBounds
.
TopLeft
(
)
;
for
(
auto
iter
=
aRegion
-
>
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsIntRect
rect
(
iter
.
Get
(
)
)
;
rect
.
MoveBy
(
-
topLeft
)
;
data
-
>
mPresContext
-
>
NotifyInvalidation
(
transactionId
rect
)
;
}
}
void
nsPresContext
:
:
SetNotifySubDocInvalidationData
(
ContainerLayer
*
aContainer
)
{
ContainerLayerPresContext
*
pres
=
new
ContainerLayerPresContext
;
pres
-
>
mPresContext
=
this
;
aContainer
-
>
SetUserData
(
&
gNotifySubDocInvalidationData
pres
)
;
}
void
nsPresContext
:
:
ClearNotifySubDocInvalidationData
(
ContainerLayer
*
aContainer
)
{
aContainer
-
>
SetUserData
(
&
gNotifySubDocInvalidationData
nullptr
)
;
}
struct
NotifyDidPaintSubdocumentCallbackClosure
{
TransactionId
mTransactionId
;
const
mozilla
:
:
TimeStamp
&
mTimeStamp
;
}
;
bool
nsPresContext
:
:
NotifyDidPaintSubdocumentCallback
(
dom
:
:
Document
*
aDocument
void
*
aData
)
{
NotifyDidPaintSubdocumentCallbackClosure
*
closure
=
static_cast
<
NotifyDidPaintSubdocumentCallbackClosure
*
>
(
aData
)
;
nsPresContext
*
pc
=
aDocument
-
>
GetPresContext
(
)
;
if
(
pc
)
{
pc
-
>
NotifyDidPaintForSubtree
(
closure
-
>
mTransactionId
closure
-
>
mTimeStamp
)
;
}
return
true
;
}
bool
nsPresContext
:
:
NotifyRevokingDidPaintSubdocumentCallback
(
dom
:
:
Document
*
aDocument
void
*
aData
)
{
NotifyDidPaintSubdocumentCallbackClosure
*
closure
=
static_cast
<
NotifyDidPaintSubdocumentCallbackClosure
*
>
(
aData
)
;
nsPresContext
*
pc
=
aDocument
-
>
GetPresContext
(
)
;
if
(
pc
)
{
pc
-
>
NotifyRevokingDidPaint
(
closure
-
>
mTransactionId
)
;
}
return
true
;
}
class
DelayedFireDOMPaintEvent
:
public
Runnable
{
public
:
DelayedFireDOMPaintEvent
(
nsPresContext
*
aPresContext
nsTArray
<
nsRect
>
*
aList
TransactionId
aTransactionId
const
mozilla
:
:
TimeStamp
&
aTimeStamp
=
mozilla
:
:
TimeStamp
(
)
)
:
mozilla
:
:
Runnable
(
"
DelayedFireDOMPaintEvent
"
)
mPresContext
(
aPresContext
)
mTransactionId
(
aTransactionId
)
mTimeStamp
(
aTimeStamp
)
{
MOZ_ASSERT
(
mPresContext
-
>
GetContainerWeak
(
)
"
DOMPaintEvent
requested
for
a
detached
pres
context
"
)
;
mList
.
SwapElements
(
*
aList
)
;
}
NS_IMETHOD
Run
(
)
override
{
if
(
mPresContext
-
>
GetContainerWeak
(
)
)
{
mPresContext
-
>
FireDOMPaintEvent
(
&
mList
mTransactionId
mTimeStamp
)
;
}
return
NS_OK
;
}
RefPtr
<
nsPresContext
>
mPresContext
;
TransactionId
mTransactionId
;
const
mozilla
:
:
TimeStamp
mTimeStamp
;
nsTArray
<
nsRect
>
mList
;
}
;
void
nsPresContext
:
:
NotifyRevokingDidPaint
(
TransactionId
aTransactionId
)
{
if
(
(
IsRoot
(
)
|
|
!
PresShell
(
)
-
>
IsVisible
(
)
)
&
&
mTransactions
.
IsEmpty
(
)
)
{
return
;
}
TransactionInvalidations
*
transaction
=
nullptr
;
for
(
auto
&
t
:
mTransactions
)
{
if
(
t
.
mTransactionId
=
=
aTransactionId
)
{
transaction
=
&
t
;
break
;
}
}
if
(
!
transaction
)
{
return
;
}
if
(
mTransactions
.
Length
(
)
=
=
1
)
{
nsCOMPtr
<
nsIRunnable
>
ev
=
new
DelayedFireDOMPaintEvent
(
this
&
transaction
-
>
mInvalidations
transaction
-
>
mTransactionId
mozilla
:
:
TimeStamp
(
)
)
;
nsContentUtils
:
:
AddScriptRunner
(
ev
)
;
mTransactions
.
RemoveElementAt
(
0
)
;
}
else
{
transaction
-
>
mIsWaitingForPreviousTransaction
=
true
;
}
NotifyDidPaintSubdocumentCallbackClosure
closure
=
{
aTransactionId
mozilla
:
:
TimeStamp
(
)
}
;
mDocument
-
>
EnumerateSubDocuments
(
nsPresContext
:
:
NotifyRevokingDidPaintSubdocumentCallback
&
closure
)
;
}
void
nsPresContext
:
:
NotifyDidPaintForSubtree
(
TransactionId
aTransactionId
const
mozilla
:
:
TimeStamp
&
aTimeStamp
)
{
if
(
mFirstContentfulPaintTransactionId
&
&
!
mHadContentfulPaintComposite
)
{
if
(
aTransactionId
>
=
*
mFirstContentfulPaintTransactionId
)
{
mHadContentfulPaintComposite
=
true
;
RefPtr
<
nsDOMNavigationTiming
>
timing
=
mDocument
-
>
GetNavigationTiming
(
)
;
if
(
timing
)
{
timing
-
>
NotifyContentfulPaintForRootContentDocument
(
aTimeStamp
)
;
}
}
}
if
(
IsRoot
(
)
&
&
mTransactions
.
IsEmpty
(
)
)
{
return
;
}
if
(
!
PresShell
(
)
-
>
IsVisible
(
)
&
&
mTransactions
.
IsEmpty
(
)
)
{
return
;
}
bool
sent
=
false
;
uint32_t
i
=
0
;
while
(
i
<
mTransactions
.
Length
(
)
)
{
if
(
mTransactions
[
i
]
.
mTransactionId
<
=
aTransactionId
)
{
if
(
!
mTransactions
[
i
]
.
mInvalidations
.
IsEmpty
(
)
)
{
nsCOMPtr
<
nsIRunnable
>
ev
=
new
DelayedFireDOMPaintEvent
(
this
&
mTransactions
[
i
]
.
mInvalidations
mTransactions
[
i
]
.
mTransactionId
aTimeStamp
)
;
nsContentUtils
:
:
AddScriptRunner
(
ev
)
;
sent
=
true
;
}
mTransactions
.
RemoveElementAt
(
i
)
;
}
else
{
if
(
sent
&
&
mTransactions
[
i
]
.
mIsWaitingForPreviousTransaction
)
{
nsCOMPtr
<
nsIRunnable
>
ev
=
new
DelayedFireDOMPaintEvent
(
this
&
mTransactions
[
i
]
.
mInvalidations
mTransactions
[
i
]
.
mTransactionId
aTimeStamp
)
;
nsContentUtils
:
:
AddScriptRunner
(
ev
)
;
sent
=
true
;
mTransactions
.
RemoveElementAt
(
i
)
;
continue
;
}
i
+
+
;
}
}
if
(
!
sent
)
{
nsTArray
<
nsRect
>
dummy
;
nsCOMPtr
<
nsIRunnable
>
ev
=
new
DelayedFireDOMPaintEvent
(
this
&
dummy
aTransactionId
aTimeStamp
)
;
nsContentUtils
:
:
AddScriptRunner
(
ev
)
;
}
NotifyDidPaintSubdocumentCallbackClosure
closure
=
{
aTransactionId
aTimeStamp
}
;
mDocument
-
>
EnumerateSubDocuments
(
nsPresContext
:
:
NotifyDidPaintSubdocumentCallback
&
closure
)
;
}
already_AddRefed
<
nsITimer
>
nsPresContext
:
:
CreateTimer
(
nsTimerCallbackFunc
aCallback
const
char
*
aName
uint32_t
aDelay
)
{
nsCOMPtr
<
nsITimer
>
timer
;
NS_NewTimerWithFuncCallback
(
getter_AddRefs
(
timer
)
aCallback
this
aDelay
nsITimer
:
:
TYPE_ONE_SHOT
aName
Document
(
)
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
)
;
return
timer
.
forget
(
)
;
}
static
bool
sGotInterruptEnv
=
false
;
enum
InterruptMode
{
ModeRandom
ModeCounter
ModeEvent
}
;
static
InterruptMode
sInterruptMode
=
ModeEvent
;
#
ifndef
XP_WIN
static
uint32_t
sInterruptSeed
=
1
;
#
endif
static
uint32_t
sInterruptMaxCounter
=
10
;
static
uint32_t
sInterruptCounter
;
static
uint32_t
sInterruptChecksToSkip
=
200
;
static
TimeDuration
sInterruptTimeout
;
static
void
GetInterruptEnv
(
)
{
char
*
ev
=
PR_GetEnv
(
"
GECKO_REFLOW_INTERRUPT_MODE
"
)
;
if
(
ev
)
{
#
ifndef
XP_WIN
if
(
PL_strcasecmp
(
ev
"
random
"
)
=
=
0
)
{
ev
=
PR_GetEnv
(
"
GECKO_REFLOW_INTERRUPT_SEED
"
)
;
if
(
ev
)
{
sInterruptSeed
=
atoi
(
ev
)
;
}
srandom
(
sInterruptSeed
)
;
sInterruptMode
=
ModeRandom
;
}
else
#
endif
if
(
PL_strcasecmp
(
ev
"
counter
"
)
=
=
0
)
{
ev
=
PR_GetEnv
(
"
GECKO_REFLOW_INTERRUPT_FREQUENCY
"
)
;
if
(
ev
)
{
sInterruptMaxCounter
=
atoi
(
ev
)
;
}
sInterruptCounter
=
0
;
sInterruptMode
=
ModeCounter
;
}
}
ev
=
PR_GetEnv
(
"
GECKO_REFLOW_INTERRUPT_CHECKS_TO_SKIP
"
)
;
if
(
ev
)
{
sInterruptChecksToSkip
=
atoi
(
ev
)
;
}
ev
=
PR_GetEnv
(
"
GECKO_REFLOW_MIN_NOINTERRUPT_DURATION
"
)
;
int
duration_ms
=
ev
?
atoi
(
ev
)
:
100
;
sInterruptTimeout
=
TimeDuration
:
:
FromMilliseconds
(
duration_ms
)
;
}
bool
nsPresContext
:
:
HavePendingInputEvent
(
)
{
switch
(
sInterruptMode
)
{
#
ifndef
XP_WIN
case
ModeRandom
:
return
(
random
(
)
&
1
)
;
#
endif
case
ModeCounter
:
if
(
sInterruptCounter
<
sInterruptMaxCounter
)
{
+
+
sInterruptCounter
;
return
false
;
}
sInterruptCounter
=
0
;
return
true
;
default
:
case
ModeEvent
:
{
nsIFrame
*
f
=
PresShell
(
)
-
>
GetRootFrame
(
)
;
if
(
f
)
{
nsIWidget
*
w
=
f
-
>
GetNearestWidget
(
)
;
if
(
w
)
{
return
w
-
>
HasPendingInputEvent
(
)
;
}
}
return
false
;
}
}
}
bool
nsPresContext
:
:
HasPendingRestyleOrReflow
(
)
{
mozilla
:
:
PresShell
*
presShell
=
PresShell
(
)
;
return
presShell
-
>
NeedStyleFlush
(
)
|
|
presShell
-
>
HasPendingReflow
(
)
;
}
void
nsPresContext
:
:
ReflowStarted
(
bool
aInterruptible
)
{
#
ifdef
NOISY_INTERRUPTIBLE_REFLOW
if
(
!
aInterruptible
)
{
printf
(
"
STARTING
NONINTERRUPTIBLE
REFLOW
\
n
"
)
;
}
#
endif
mInterruptsEnabled
=
aInterruptible
&
&
!
IsPaginated
(
)
&
&
StaticPrefs
:
:
layout_interruptible_reflow_enabled
(
)
;
mHasPendingInterrupt
=
false
;
mInterruptChecksToSkip
=
sInterruptChecksToSkip
;
if
(
mInterruptsEnabled
)
{
mReflowStartTime
=
TimeStamp
:
:
Now
(
)
;
}
}
bool
nsPresContext
:
:
CheckForInterrupt
(
nsIFrame
*
aFrame
)
{
if
(
mHasPendingInterrupt
)
{
mPresShell
-
>
FrameNeedsToContinueReflow
(
aFrame
)
;
return
true
;
}
if
(
!
sGotInterruptEnv
)
{
sGotInterruptEnv
=
true
;
GetInterruptEnv
(
)
;
}
if
(
!
mInterruptsEnabled
)
{
return
false
;
}
if
(
mInterruptChecksToSkip
>
0
)
{
-
-
mInterruptChecksToSkip
;
return
false
;
}
mInterruptChecksToSkip
=
sInterruptChecksToSkip
;
mHasPendingInterrupt
=
TimeStamp
:
:
Now
(
)
-
mReflowStartTime
>
sInterruptTimeout
&
&
HavePendingInputEvent
(
)
&
&
!
IsChrome
(
)
;
if
(
mPendingInterruptFromTest
)
{
mPendingInterruptFromTest
=
false
;
mHasPendingInterrupt
=
true
;
}
if
(
mHasPendingInterrupt
)
{
#
ifdef
NOISY_INTERRUPTIBLE_REFLOW
printf
(
"
*
*
*
DETECTED
pending
interrupt
(
time
=
%
lld
)
\
n
"
PR_Now
(
)
)
;
#
endif
mPresShell
-
>
FrameNeedsToContinueReflow
(
aFrame
)
;
}
return
mHasPendingInterrupt
;
}
nsIFrame
*
nsPresContext
:
:
GetPrimaryFrameFor
(
nsIContent
*
aContent
)
{
MOZ_ASSERT
(
aContent
"
Don
'
t
do
that
"
)
;
if
(
GetPresShell
(
)
&
&
GetPresShell
(
)
-
>
GetDocument
(
)
=
=
aContent
-
>
GetComposedDoc
(
)
)
{
return
aContent
-
>
GetPrimaryFrame
(
)
;
}
return
nullptr
;
}
size_t
nsPresContext
:
:
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
0
;
}
bool
nsPresContext
:
:
IsRootContentDocument
(
)
const
{
return
IsRootContentDocumentInProcess
(
)
;
}
bool
nsPresContext
:
:
IsRootContentDocumentInProcess
(
)
const
{
if
(
mDocument
-
>
IsResourceDoc
(
)
)
{
return
false
;
}
if
(
IsChrome
(
)
)
{
return
false
;
}
nsView
*
view
=
PresShell
(
)
-
>
GetViewManager
(
)
-
>
GetRootView
(
)
;
if
(
!
view
)
{
return
false
;
}
view
=
view
-
>
GetParent
(
)
;
if
(
!
view
)
{
return
true
;
}
view
=
view
-
>
GetParent
(
)
;
if
(
!
view
)
{
return
true
;
}
nsIFrame
*
f
=
view
-
>
GetFrame
(
)
;
return
(
f
&
&
f
-
>
PresContext
(
)
-
>
IsChrome
(
)
)
;
}
bool
nsPresContext
:
:
IsRootContentDocumentCrossProcess
(
)
const
{
if
(
mDocument
-
>
IsResourceDoc
(
)
)
{
return
false
;
}
return
mDocument
-
>
IsTopLevelContentDocument
(
)
;
}
void
nsPresContext
:
:
NotifyNonBlankPaint
(
)
{
MOZ_ASSERT
(
!
mHadNonBlankPaint
)
;
mHadNonBlankPaint
=
true
;
if
(
IsRootContentDocument
(
)
)
{
RefPtr
<
nsDOMNavigationTiming
>
timing
=
mDocument
-
>
GetNavigationTiming
(
)
;
if
(
timing
)
{
timing
-
>
NotifyNonBlankPaintForRootContentDocument
(
)
;
}
mFirstNonBlankPaintTime
=
TimeStamp
:
:
Now
(
)
;
}
}
void
nsPresContext
:
:
NotifyContentfulPaint
(
)
{
if
(
!
mHadContentfulPaint
)
{
mHadContentfulPaint
=
true
;
if
(
IsRootContentDocument
(
)
)
{
if
(
nsRootPresContext
*
rootPresContext
=
GetRootPresContext
(
)
)
{
mFirstContentfulPaintTransactionId
=
Some
(
rootPresContext
-
>
mRefreshDriver
-
>
LastTransactionId
(
)
.
Next
(
)
)
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
(
new
AsyncEventDispatcher
(
mDocument
NS_LITERAL_STRING
(
"
MozFirstContentfulPaint
"
)
CanBubble
:
:
eYes
ChromeOnlyDispatch
:
:
eYes
)
)
-
>
PostDOMEvent
(
)
;
#
endif
}
}
}
}
void
nsPresContext
:
:
NotifyDOMContentFlushed
(
)
{
NS_ENSURE_TRUE_VOID
(
mPresShell
)
;
if
(
IsRootContentDocument
(
)
)
{
RefPtr
<
nsDOMNavigationTiming
>
timing
=
mDocument
-
>
GetNavigationTiming
(
)
;
if
(
timing
)
{
timing
-
>
NotifyDOMContentFlushedForRootContentDocument
(
)
;
}
}
}
bool
nsPresContext
:
:
GetPaintFlashing
(
)
const
{
if
(
!
mPaintFlashingInitialized
)
{
bool
pref
=
Preferences
:
:
GetBool
(
"
nglayout
.
debug
.
paint_flashing
"
)
;
if
(
!
pref
&
&
IsChrome
(
)
)
{
pref
=
Preferences
:
:
GetBool
(
"
nglayout
.
debug
.
paint_flashing_chrome
"
)
;
}
mPaintFlashing
=
pref
;
mPaintFlashingInitialized
=
true
;
}
return
mPaintFlashing
;
}
nscoord
nsPresContext
:
:
GfxUnitsToAppUnits
(
gfxFloat
aGfxUnits
)
const
{
return
mDeviceContext
-
>
GfxUnitsToAppUnits
(
aGfxUnits
)
;
}
gfxFloat
nsPresContext
:
:
AppUnitsToGfxUnits
(
nscoord
aAppUnits
)
const
{
return
mDeviceContext
-
>
AppUnitsToGfxUnits
(
aAppUnits
)
;
}
nscoord
nsPresContext
:
:
PhysicalMillimetersToAppUnits
(
float
aMM
)
const
{
float
inches
=
aMM
/
MM_PER_INCH_FLOAT
;
return
NSToCoordFloorClamped
(
inches
*
float
(
DeviceContext
(
)
-
>
AppUnitsPerPhysicalInch
(
)
)
)
;
}
bool
nsPresContext
:
:
IsDeviceSizePageSize
(
)
{
nsIDocShell
*
docShell
=
GetDocShell
(
)
;
return
docShell
&
&
docShell
-
>
GetDeviceSizeIsPageSize
(
)
;
}
uint64_t
nsPresContext
:
:
GetRestyleGeneration
(
)
const
{
if
(
!
mRestyleManager
)
{
return
0
;
}
return
mRestyleManager
-
>
GetRestyleGeneration
(
)
;
}
uint64_t
nsPresContext
:
:
GetUndisplayedRestyleGeneration
(
)
const
{
if
(
!
mRestyleManager
)
{
return
0
;
}
return
mRestyleManager
-
>
GetUndisplayedRestyleGeneration
(
)
;
}
nsBidi
&
nsPresContext
:
:
GetBidiEngine
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mBidiEngine
)
{
mBidiEngine
.
reset
(
new
nsBidi
(
)
)
;
}
return
*
mBidiEngine
;
}
void
nsPresContext
:
:
FlushFontFeatureValues
(
)
{
if
(
!
mPresShell
)
{
return
;
}
if
(
mFontFeatureValuesDirty
)
{
ServoStyleSet
*
styleSet
=
mPresShell
-
>
StyleSet
(
)
;
mFontFeatureValuesLookup
=
styleSet
-
>
BuildFontFeatureValueSet
(
)
;
mFontFeatureValuesDirty
=
false
;
}
}
void
nsPresContext
:
:
SetVisibleArea
(
const
nsRect
&
r
)
{
if
(
!
r
.
IsEqualEdges
(
mVisibleArea
)
)
{
mVisibleArea
=
r
;
mSizeForViewportUnits
=
mVisibleArea
.
Size
(
)
;
if
(
IsRootContentDocumentCrossProcess
(
)
)
{
AdjustSizeForViewportUnits
(
)
;
}
if
(
!
IsPaginated
(
)
)
{
MediaFeatureValuesChanged
(
{
mozilla
:
:
MediaFeatureChangeReason
:
:
ViewportChange
}
)
;
}
}
}
void
nsPresContext
:
:
SetDynamicToolbarMaxHeight
(
ScreenIntCoord
aHeight
)
{
MOZ_ASSERT
(
IsRootContentDocumentCrossProcess
(
)
)
;
if
(
mDynamicToolbarMaxHeight
=
=
aHeight
)
{
return
;
}
mDynamicToolbarMaxHeight
=
aHeight
;
AdjustSizeForViewportUnits
(
)
;
if
(
RefPtr
<
mozilla
:
:
PresShell
>
presShell
=
mPresShell
)
{
nscoord
currentWidth
currentHeight
;
presShell
-
>
GetViewManager
(
)
-
>
GetWindowDimensions
(
&
currentWidth
&
currentHeight
)
;
presShell
-
>
ResizeReflow
(
currentWidth
currentHeight
ResizeReflowOptions
:
:
NoOption
)
;
}
}
void
nsPresContext
:
:
AdjustSizeForViewportUnits
(
)
{
MOZ_ASSERT
(
IsRootContentDocumentCrossProcess
(
)
)
;
if
(
mVisibleArea
.
height
=
=
NS_UNCONSTRAINEDSIZE
)
{
return
;
}
if
(
MOZ_UNLIKELY
(
mVisibleArea
.
height
+
NSIntPixelsToAppUnits
(
mDynamicToolbarMaxHeight
mCurAppUnitsPerDevPixel
)
>
nscoord_MAX
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
The
dynamic
toolbar
max
height
is
probably
wrong
"
)
;
return
;
}
mSizeForViewportUnits
.
height
=
mVisibleArea
.
height
+
NSIntPixelsToAppUnits
(
mDynamicToolbarMaxHeight
mCurAppUnitsPerDevPixel
)
;
}
void
nsPresContext
:
:
UpdateDynamicToolbarOffset
(
ScreenIntCoord
aOffset
)
{
MOZ_ASSERT
(
IsRootContentDocumentCrossProcess
(
)
)
;
if
(
!
mPresShell
)
{
return
;
}
if
(
!
HasDynamicToolbar
(
)
)
{
return
;
}
MOZ_ASSERT
(
-
mDynamicToolbarMaxHeight
<
=
aOffset
&
&
aOffset
<
=
0
)
;
}
#
ifdef
DEBUG
void
nsPresContext
:
:
ValidatePresShellAndDocumentReleation
(
)
const
{
NS_ASSERTION
(
!
mPresShell
|
|
!
mPresShell
-
>
GetDocument
(
)
|
|
mPresShell
-
>
GetDocument
(
)
=
=
mDocument
"
nsPresContext
doesn
'
t
have
the
same
document
as
nsPresShell
!
"
)
;
}
#
endif
nsRootPresContext
:
:
nsRootPresContext
(
dom
:
:
Document
*
aDocument
nsPresContextType
aType
)
:
nsPresContext
(
aDocument
aType
)
{
}
nsRootPresContext
:
:
~
nsRootPresContext
(
)
{
NS_ASSERTION
(
mRegisteredPlugins
.
Count
(
)
=
=
0
"
All
plugins
should
have
been
unregistered
"
)
;
CancelApplyPluginGeometryTimer
(
)
;
}
void
nsRootPresContext
:
:
RegisterPluginForGeometryUpdates
(
nsIContent
*
aPlugin
)
{
mRegisteredPlugins
.
PutEntry
(
aPlugin
)
;
}
void
nsRootPresContext
:
:
UnregisterPluginForGeometryUpdates
(
nsIContent
*
aPlugin
)
{
mRegisteredPlugins
.
RemoveEntry
(
aPlugin
)
;
}
void
nsRootPresContext
:
:
ComputePluginGeometryUpdates
(
nsIFrame
*
aFrame
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
)
{
if
(
mRegisteredPlugins
.
Count
(
)
=
=
0
)
{
return
;
}
for
(
auto
iter
=
mRegisteredPlugins
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
f
=
static_cast
<
nsPluginFrame
*
>
(
iter
.
Get
(
)
-
>
GetKey
(
)
-
>
GetPrimaryFrame
(
)
)
;
if
(
!
f
)
{
NS_WARNING
(
"
Null
frame
in
ComputePluginGeometryUpdates
"
)
;
continue
;
}
if
(
!
nsLayoutUtils
:
:
IsAncestorFrameCrossDoc
(
aFrame
f
)
)
{
continue
;
}
f
-
>
SetEmptyWidgetConfiguration
(
)
;
}
if
(
aBuilder
)
{
MOZ_ASSERT
(
aList
)
;
nsIFrame
*
rootFrame
=
mPresShell
-
>
GetRootFrame
(
)
;
if
(
rootFrame
&
&
aBuilder
-
>
ContainsPluginItem
(
)
)
{
aBuilder
-
>
SetForPluginGeometry
(
true
)
;
aBuilder
-
>
SetAllowMergingAndFlattening
(
false
)
;
nsRegion
region
=
rootFrame
-
>
GetVisualOverflowRectRelativeToSelf
(
)
;
aList
-
>
ComputeVisibilityForRoot
(
aBuilder
&
region
)
;
aBuilder
-
>
SetForPluginGeometry
(
false
)
;
}
}
#
ifdef
XP_MACOSX
ApplyPluginGeometryUpdates
(
)
;
#
else
if
(
XRE_IsParentProcess
(
)
)
{
InitApplyPluginGeometryTimer
(
)
;
}
#
endif
}
static
void
ApplyPluginGeometryUpdatesCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
{
static_cast
<
nsRootPresContext
*
>
(
aClosure
)
-
>
ApplyPluginGeometryUpdates
(
)
;
}
void
nsRootPresContext
:
:
InitApplyPluginGeometryTimer
(
)
{
if
(
mApplyPluginGeometryTimer
)
{
return
;
}
mApplyPluginGeometryTimer
=
CreateTimer
(
ApplyPluginGeometryUpdatesCallback
"
ApplyPluginGeometryUpdatesCallback
"
nsRefreshDriver
:
:
DefaultInterval
(
)
*
2
)
;
}
void
nsRootPresContext
:
:
CancelApplyPluginGeometryTimer
(
)
{
if
(
mApplyPluginGeometryTimer
)
{
mApplyPluginGeometryTimer
-
>
Cancel
(
)
;
mApplyPluginGeometryTimer
=
nullptr
;
}
}
#
ifndef
XP_MACOSX
static
bool
HasOverlap
(
const
LayoutDeviceIntPoint
&
aOffset1
const
nsTArray
<
LayoutDeviceIntRect
>
&
aClipRects1
const
LayoutDeviceIntPoint
&
aOffset2
const
nsTArray
<
LayoutDeviceIntRect
>
&
aClipRects2
)
{
LayoutDeviceIntPoint
offsetDelta
=
aOffset1
-
aOffset2
;
for
(
uint32_t
i
=
0
;
i
<
aClipRects1
.
Length
(
)
;
+
+
i
)
{
for
(
uint32_t
j
=
0
;
j
<
aClipRects2
.
Length
(
)
;
+
+
j
)
{
if
(
(
aClipRects1
[
i
]
+
offsetDelta
)
.
Intersects
(
aClipRects2
[
j
]
)
)
{
return
true
;
}
}
}
return
false
;
}
static
void
SortConfigurations
(
nsTArray
<
nsIWidget
:
:
Configuration
>
*
aConfigurations
)
{
if
(
aConfigurations
-
>
Length
(
)
>
10
)
{
return
;
}
nsTArray
<
nsIWidget
:
:
Configuration
>
pluginsToMove
;
pluginsToMove
.
SwapElements
(
*
aConfigurations
)
;
while
(
!
pluginsToMove
.
IsEmpty
(
)
)
{
uint32_t
i
;
for
(
i
=
0
;
i
+
1
<
pluginsToMove
.
Length
(
)
;
+
+
i
)
{
nsIWidget
:
:
Configuration
*
config
=
&
pluginsToMove
[
i
]
;
bool
foundOverlap
=
false
;
for
(
uint32_t
j
=
0
;
j
<
pluginsToMove
.
Length
(
)
;
+
+
j
)
{
if
(
i
=
=
j
)
continue
;
LayoutDeviceIntRect
bounds
=
pluginsToMove
[
j
]
.
mChild
-
>
GetBounds
(
)
;
AutoTArray
<
LayoutDeviceIntRect
1
>
clipRects
;
pluginsToMove
[
j
]
.
mChild
-
>
GetWindowClipRegion
(
&
clipRects
)
;
if
(
HasOverlap
(
bounds
.
TopLeft
(
)
clipRects
config
-
>
mBounds
.
TopLeft
(
)
config
-
>
mClipRegion
)
)
{
foundOverlap
=
true
;
break
;
}
}
if
(
!
foundOverlap
)
break
;
}
aConfigurations
-
>
AppendElement
(
pluginsToMove
[
i
]
)
;
pluginsToMove
.
RemoveElementAt
(
i
)
;
}
}
static
void
PluginGetGeometryUpdate
(
nsTHashtable
<
nsRefPtrHashKey
<
nsIContent
>
>
&
aPlugins
nsTArray
<
nsIWidget
:
:
Configuration
>
*
aConfigurations
)
{
for
(
auto
iter
=
aPlugins
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
f
=
static_cast
<
nsPluginFrame
*
>
(
iter
.
Get
(
)
-
>
GetKey
(
)
-
>
GetPrimaryFrame
(
)
)
;
if
(
!
f
)
{
NS_WARNING
(
"
Null
frame
in
PluginGeometryUpdate
"
)
;
continue
;
}
f
-
>
GetWidgetConfiguration
(
aConfigurations
)
;
}
}
#
endif
static
void
PluginDidSetGeometry
(
nsTHashtable
<
nsRefPtrHashKey
<
nsIContent
>
>
&
aPlugins
)
{
for
(
auto
iter
=
aPlugins
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
f
=
static_cast
<
nsPluginFrame
*
>
(
iter
.
Get
(
)
-
>
GetKey
(
)
-
>
GetPrimaryFrame
(
)
)
;
if
(
!
f
)
{
NS_WARNING
(
"
Null
frame
in
PluginDidSetGeometry
"
)
;
continue
;
}
f
-
>
DidSetWidgetGeometry
(
)
;
}
}
void
nsRootPresContext
:
:
ApplyPluginGeometryUpdates
(
)
{
#
ifndef
XP_MACOSX
CancelApplyPluginGeometryTimer
(
)
;
nsTArray
<
nsIWidget
:
:
Configuration
>
configurations
;
PluginGetGeometryUpdate
(
mRegisteredPlugins
&
configurations
)
;
if
(
!
configurations
.
IsEmpty
(
)
)
{
nsIWidget
*
widget
=
configurations
[
0
]
.
mChild
-
>
GetParent
(
)
;
NS_ASSERTION
(
widget
"
Plugins
must
have
a
parent
window
"
)
;
SortConfigurations
(
&
configurations
)
;
widget
-
>
ConfigureChildren
(
configurations
)
;
}
#
endif
PluginDidSetGeometry
(
mRegisteredPlugins
)
;
}
void
nsRootPresContext
:
:
CollectPluginGeometryUpdates
(
LayerManager
*
aLayerManager
)
{
#
ifndef
XP_MACOSX
NS_ASSERTION
(
aLayerManager
"
layer
manager
is
invalid
!
"
)
;
mozilla
:
:
layers
:
:
ClientLayerManager
*
clm
=
aLayerManager
-
>
AsClientLayerManager
(
)
;
nsTArray
<
nsIWidget
:
:
Configuration
>
configurations
;
if
(
!
mRegisteredPlugins
.
Count
(
)
&
&
clm
)
{
clm
-
>
StorePluginWidgetConfigurations
(
configurations
)
;
return
;
}
PluginGetGeometryUpdate
(
mRegisteredPlugins
&
configurations
)
;
if
(
configurations
.
IsEmpty
(
)
)
{
PluginDidSetGeometry
(
mRegisteredPlugins
)
;
return
;
}
SortConfigurations
(
&
configurations
)
;
if
(
clm
)
{
clm
-
>
StorePluginWidgetConfigurations
(
configurations
)
;
}
PluginDidSetGeometry
(
mRegisteredPlugins
)
;
#
endif
}
void
nsRootPresContext
:
:
AddWillPaintObserver
(
nsIRunnable
*
aRunnable
)
{
if
(
!
mWillPaintFallbackEvent
.
IsPending
(
)
)
{
mWillPaintFallbackEvent
=
new
RunWillPaintObservers
(
this
)
;
Document
(
)
-
>
Dispatch
(
TaskCategory
:
:
Other
do_AddRef
(
mWillPaintFallbackEvent
)
)
;
}
mWillPaintObservers
.
AppendElement
(
aRunnable
)
;
}
void
nsRootPresContext
:
:
FlushWillPaintObservers
(
)
{
mWillPaintFallbackEvent
=
nullptr
;
nsTArray
<
nsCOMPtr
<
nsIRunnable
>
>
observers
;
observers
.
SwapElements
(
mWillPaintObservers
)
;
for
(
uint32_t
i
=
0
;
i
<
observers
.
Length
(
)
;
+
+
i
)
{
observers
[
i
]
-
>
Run
(
)
;
}
}
size_t
nsRootPresContext
:
:
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
nsPresContext
:
:
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
