#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
Encoding
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
base
/
basictypes
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsIPresShellInlines
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsIContentViewer
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
mozilla
/
StyleSetHandle
.
h
"
#
include
"
mozilla
/
StyleSetHandleInlines
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIDocumentInlines
.
h
"
#
include
"
nsIPrintSettings
.
h
"
#
include
"
nsLanguageAtomService
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsIDOMHTMLDocument
.
h
"
#
include
"
nsHTMLDocument
.
h
"
#
include
"
nsIDOMHTMLElement
.
h
"
#
include
"
nsIWeakReferenceUtils
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsFrameManager
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
mozilla
/
GeckoRestyleManager
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
mozilla
/
RestyleManagerInlines
.
h
"
#
include
"
SurfaceCacheUtils
.
h
"
#
include
"
nsMediaFeatures
.
h
"
#
include
"
nsRuleNode
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
nsCSSRules
.
h
"
#
include
"
nsFontFaceLoader
.
h
"
#
include
"
mozilla
/
EffectCompositor
.
h
"
#
include
"
mozilla
/
EventListenerManager
.
h
"
#
include
"
prenv
.
h
"
#
include
"
nsPluginFrame
.
h
"
#
include
"
nsTransitionManager
.
h
"
#
include
"
nsAnimationManager
.
h
"
#
include
"
CounterStyleManager
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
nsIMessageManager
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBodyElement
.
h
"
#
include
"
mozilla
/
dom
/
MediaQueryList
.
h
"
#
include
"
nsSMILAnimationController
.
h
"
#
include
"
mozilla
/
css
/
ImageLoader
.
h
"
#
include
"
mozilla
/
dom
/
PBrowserParent
.
h
"
#
include
"
mozilla
/
dom
/
TabChild
.
h
"
#
include
"
mozilla
/
dom
/
TabParent
.
h
"
#
include
"
nsRefreshDriver
.
h
"
#
include
"
Layers
.
h
"
#
include
"
LayerUserData
.
h
"
#
include
"
ClientLayerManager
.
h
"
#
include
"
mozilla
/
dom
/
NotifyPaintEvent
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
nsIDOMChromeWindow
.
h
"
#
include
"
nsFrameLoader
.
h
"
#
include
"
mozilla
/
dom
/
FontFaceSet
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsPIWindowRoot
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
gfxTextRun
.
h
"
#
include
"
nsFontFaceUtils
.
h
"
#
include
"
nsLayoutStylesheetCache
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
mozilla
/
StyleSheet
.
h
"
#
include
"
mozilla
/
StyleSheetInlines
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
dom
/
Performance
.
h
"
#
include
"
mozilla
/
dom
/
PerformanceTiming
.
h
"
#
include
"
mozilla
/
layers
/
APZThreadUtils
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
nsIImageLoadingContent
.
h
"
#
include
"
nsCSSParser
.
h
"
#
include
"
nsBidiUtils
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsBidi
.
h
"
#
include
"
mozilla
/
dom
/
URL
.
h
"
#
include
"
mozilla
/
ServoCSSParser
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
layers
;
uint8_t
gNotifySubDocInvalidationData
;
constexpr
char
kUseStandinsForNativeColors
[
]
=
"
ui
.
use_standins_for_native_colors
"
;
class
ContainerLayerPresContext
:
public
LayerUserData
{
public
:
nsPresContext
*
mPresContext
;
}
;
namespace
{
class
CharSetChangingRunnable
:
public
Runnable
{
public
:
CharSetChangingRunnable
(
nsPresContext
*
aPresContext
NotNull
<
const
Encoding
*
>
aCharSet
)
:
Runnable
(
"
CharSetChangingRunnable
"
)
mPresContext
(
aPresContext
)
mCharSet
(
aCharSet
)
{
}
NS_IMETHOD
Run
(
)
override
{
mPresContext
-
>
DoChangeCharSet
(
mCharSet
)
;
return
NS_OK
;
}
private
:
RefPtr
<
nsPresContext
>
mPresContext
;
NotNull
<
const
Encoding
*
>
mCharSet
;
}
;
}
nscolor
nsPresContext
:
:
MakeColorPref
(
const
nsString
&
aColor
)
{
bool
ok
;
nscolor
result
;
ServoStyleSet
*
servoStyleSet
=
mShell
&
&
mShell
-
>
StyleSet
(
)
?
mShell
-
>
StyleSet
(
)
-
>
GetAsServo
(
)
:
nullptr
;
if
(
servoStyleSet
)
{
ok
=
ServoCSSParser
:
:
ComputeColor
(
servoStyleSet
NS_RGB
(
0
0
0
)
aColor
&
result
)
;
}
else
{
nsCSSParser
parser
;
nsCSSValue
value
;
ok
=
parser
.
ParseColorString
(
aColor
nullptr
0
value
)
&
&
nsRuleNode
:
:
ComputeColor
(
value
this
nullptr
result
)
;
}
if
(
!
ok
)
{
result
=
NS_RGB
(
0
0
0
)
;
}
return
result
;
}
bool
nsPresContext
:
:
IsDOMPaintEventPending
(
)
{
if
(
mFireAfterPaintEvents
)
{
return
true
;
}
nsRootPresContext
*
drpc
=
GetRootPresContext
(
)
;
if
(
drpc
&
&
drpc
-
>
mRefreshDriver
-
>
ViewManagerFlushIsPending
(
)
)
{
NotifyInvalidation
(
drpc
-
>
mRefreshDriver
-
>
LastTransactionId
(
)
+
1
nsRect
(
0
0
0
0
)
)
;
NS_ASSERTION
(
mFireAfterPaintEvents
"
Why
aren
'
t
we
planning
to
fire
the
event
?
"
)
;
return
true
;
}
return
false
;
}
void
nsPresContext
:
:
PrefChangedCallback
(
const
char
*
aPrefName
void
*
instance_data
)
{
RefPtr
<
nsPresContext
>
presContext
=
static_cast
<
nsPresContext
*
>
(
instance_data
)
;
NS_ASSERTION
(
nullptr
!
=
presContext
"
bad
instance
data
"
)
;
if
(
nullptr
!
=
presContext
)
{
presContext
-
>
PreferenceChanged
(
aPrefName
)
;
}
}
void
nsPresContext
:
:
PrefChangedUpdateTimerCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
{
nsPresContext
*
presContext
=
(
nsPresContext
*
)
aClosure
;
NS_ASSERTION
(
presContext
!
=
nullptr
"
bad
instance
data
"
)
;
if
(
presContext
)
presContext
-
>
UpdateAfterPreferencesChanged
(
)
;
}
static
bool
IsVisualCharset
(
NotNull
<
const
Encoding
*
>
aCharset
)
{
return
aCharset
=
=
ISO_8859_8_ENCODING
;
}
nsPresContext
:
:
nsPresContext
(
nsIDocument
*
aDocument
nsPresContextType
aType
)
:
mType
(
aType
)
mShell
(
nullptr
)
mDocument
(
aDocument
)
mMedium
(
aType
=
=
eContext_Galley
?
nsGkAtoms
:
:
screen
:
nsGkAtoms
:
:
print
)
mMediaEmulated
(
mMedium
)
mLinkHandler
(
nullptr
)
mInflationDisabledForShrinkWrap
(
false
)
mBaseMinFontSize
(
0
)
mSystemFontScale
(
1
.
0
)
mTextZoom
(
1
.
0
)
mEffectiveTextZoom
(
1
.
0
)
mFullZoom
(
1
.
0
)
mOverrideDPPX
(
0
.
0
)
mLastFontInflationScreenSize
(
gfxSize
(
-
1
.
0
-
1
.
0
)
)
mCurAppUnitsPerDevPixel
(
0
)
mAutoQualityMinFontSizePixelsPref
(
0
)
mLastResizeEventVisibleArea
(
nsRect
(
nscoord_MIN
nscoord_MIN
NS_UNCONSTRAINEDSIZE
NS_UNCONSTRAINEDSIZE
)
)
mPageSize
(
-
1
-
1
)
mPageScale
(
0
.
0
)
mPPScale
(
1
.
0f
)
mDefaultColor
(
NS_RGBA
(
0
0
0
0
)
)
mBackgroundColor
(
NS_RGB
(
0xFF
0xFF
0xFF
)
)
mLinkColor
(
NS_RGB
(
0x00
0x00
0xEE
)
)
mActiveLinkColor
(
NS_RGB
(
0xEE
0x00
0x00
)
)
mVisitedLinkColor
(
NS_RGB
(
0x55
0x1A
0x8B
)
)
mFocusBackgroundColor
(
mBackgroundColor
)
mFocusTextColor
(
mDefaultColor
)
mBodyTextColor
(
mDefaultColor
)
mViewportScrollbarOverrideElement
(
nullptr
)
mViewportStyleScrollbar
(
NS_STYLE_OVERFLOW_AUTO
NS_STYLE_OVERFLOW_AUTO
)
mFocusRingWidth
(
1
)
mExistThrottledUpdates
(
false
)
mImageAnimationModePref
(
imgIContainer
:
:
kNormalAnimMode
)
mFontGroupCacheDirty
(
true
)
mInterruptChecksToSkip
(
0
)
mElementsRestyled
(
0
)
mFramesConstructed
(
0
)
mFramesReflowed
(
0
)
mInteractionTimeEnabled
(
true
)
mTelemetryScrollLastY
(
0
)
mTelemetryScrollMaxY
(
0
)
mTelemetryScrollTotalY
(
0
)
mHasPendingInterrupt
(
false
)
mPendingInterruptFromTest
(
false
)
mInterruptsEnabled
(
false
)
mUseDocumentFonts
(
true
)
mUseDocumentColors
(
true
)
mUnderlineLinks
(
true
)
mSendAfterPaintToContent
(
false
)
mUseFocusColors
(
false
)
mFocusRingOnAnything
(
false
)
mFocusRingStyle
(
false
)
mDrawImageBackground
(
true
)
mDrawColorBackground
(
true
)
mIsRenderingOnlySelection
(
false
)
mPaginated
(
aType
!
=
eContext_Galley
)
mCanPaginatedScroll
(
false
)
mDoScaledTwips
(
true
)
mIsRootPaginatedDocument
(
false
)
mPrefBidiDirection
(
false
)
mPrefScrollbarSide
(
0
)
mPendingSysColorChanged
(
false
)
mPendingThemeChanged
(
false
)
mPendingUIResolutionChanged
(
false
)
mPendingMediaFeatureValuesChanged
(
false
)
mPrefChangePendingNeedsReflow
(
false
)
mIsEmulatingMedia
(
false
)
mIsGlyph
(
false
)
mUsesRootEMUnits
(
false
)
mUsesExChUnits
(
false
)
mPendingViewportChange
(
false
)
mCounterStylesDirty
(
true
)
mPostedFlushCounterStyles
(
false
)
mFontFeatureValuesDirty
(
true
)
mPostedFlushFontFeatureValues
(
false
)
mSuppressResizeReflow
(
false
)
mIsVisual
(
false
)
mFireAfterPaintEvents
(
false
)
mIsChrome
(
false
)
mIsChromeOriginImage
(
false
)
mPaintFlashing
(
false
)
mPaintFlashingInitialized
(
false
)
mHasWarnedAboutPositionedTableParts
(
false
)
mHasWarnedAboutTooLargeDashedOrDottedRadius
(
false
)
mQuirkSheetAdded
(
false
)
mNeedsPrefUpdate
(
false
)
mHadNonBlankPaint
(
false
)
#
ifdef
RESTYLE_LOGGING
mRestyleLoggingEnabled
(
false
)
#
endif
#
ifdef
DEBUG
mInitialized
(
false
)
#
endif
{
PodZero
(
&
mBorderWidthTable
)
;
#
ifdef
DEBUG
PodZero
(
&
mLayoutPhaseCount
)
;
#
endif
if
(
!
IsDynamic
(
)
)
{
mImageAnimationMode
=
imgIContainer
:
:
kDontAnimMode
;
mNeverAnimate
=
true
;
}
else
{
mImageAnimationMode
=
imgIContainer
:
:
kNormalAnimMode
;
mNeverAnimate
=
false
;
}
NS_ASSERTION
(
mDocument
"
Null
document
"
)
;
if
(
MOZ_LOG_TEST
(
gfxPlatform
:
:
GetLog
(
eGfxLog_textperf
)
LogLevel
:
:
Warning
)
)
{
mTextPerf
=
new
gfxTextPerfMetrics
(
)
;
}
if
(
Preferences
:
:
GetBool
(
GFX_MISSING_FONTS_NOTIFY_PREF
)
)
{
mMissingFonts
=
new
gfxMissingFontRecorder
(
)
;
}
}
void
nsPresContext
:
:
Destroy
(
)
{
if
(
mEventManager
)
{
mEventManager
-
>
NotifyDestroyPresContext
(
this
)
;
mEventManager
-
>
SetPresContext
(
nullptr
)
;
mEventManager
=
nullptr
;
}
if
(
mPrefChangedTimer
)
{
mPrefChangedTimer
-
>
Cancel
(
)
;
mPrefChangedTimer
=
nullptr
;
}
Preferences
:
:
UnregisterPrefixCallback
(
nsPresContext
:
:
PrefChangedCallback
"
font
.
"
this
)
;
Preferences
:
:
UnregisterPrefixCallback
(
nsPresContext
:
:
PrefChangedCallback
"
browser
.
display
.
"
this
)
;
Preferences
:
:
UnregisterCallback
(
nsPresContext
:
:
PrefChangedCallback
"
browser
.
underline_anchors
"
this
)
;
Preferences
:
:
UnregisterCallback
(
nsPresContext
:
:
PrefChangedCallback
"
browser
.
anchor_color
"
this
)
;
Preferences
:
:
UnregisterCallback
(
nsPresContext
:
:
PrefChangedCallback
"
browser
.
active_color
"
this
)
;
Preferences
:
:
UnregisterCallback
(
nsPresContext
:
:
PrefChangedCallback
"
browser
.
visited_color
"
this
)
;
Preferences
:
:
UnregisterCallback
(
nsPresContext
:
:
PrefChangedCallback
"
image
.
animation_mode
"
this
)
;
Preferences
:
:
UnregisterPrefixCallback
(
nsPresContext
:
:
PrefChangedCallback
"
bidi
.
"
this
)
;
Preferences
:
:
UnregisterCallback
(
nsPresContext
:
:
PrefChangedCallback
"
dom
.
send_after_paint_to_content
"
this
)
;
Preferences
:
:
UnregisterPrefixCallback
(
nsPresContext
:
:
PrefChangedCallback
"
gfx
.
font_rendering
.
"
this
)
;
Preferences
:
:
UnregisterCallback
(
nsPresContext
:
:
PrefChangedCallback
"
layout
.
css
.
dpi
"
this
)
;
Preferences
:
:
UnregisterCallback
(
nsPresContext
:
:
PrefChangedCallback
"
layout
.
css
.
devPixelsPerPx
"
this
)
;
Preferences
:
:
UnregisterCallback
(
nsPresContext
:
:
PrefChangedCallback
"
nglayout
.
debug
.
paint_flashing
"
this
)
;
Preferences
:
:
UnregisterCallback
(
nsPresContext
:
:
PrefChangedCallback
"
nglayout
.
debug
.
paint_flashing_chrome
"
this
)
;
Preferences
:
:
UnregisterCallback
(
nsPresContext
:
:
PrefChangedCallback
kUseStandinsForNativeColors
this
)
;
Preferences
:
:
UnregisterCallback
(
nsPresContext
:
:
PrefChangedCallback
"
intl
.
accept_languages
"
this
)
;
mRefreshDriver
=
nullptr
;
}
nsPresContext
:
:
~
nsPresContext
(
)
{
NS_PRECONDITION
(
!
mShell
"
Presshell
forgot
to
clear
our
mShell
pointer
"
)
;
DetachShell
(
)
;
Destroy
(
)
;
}
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
nsPresContext
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsPresContext
)
NS_IMPL_CYCLE_COLLECTING_RELEASE_WITH_LAST_RELEASE
(
nsPresContext
LastRelease
(
)
)
void
nsPresContext
:
:
LastRelease
(
)
{
if
(
IsRoot
(
)
)
{
static_cast
<
nsRootPresContext
*
>
(
this
)
-
>
CancelAllDidPaintTimers
(
)
;
}
if
(
mMissingFonts
)
{
mMissingFonts
-
>
Clear
(
)
;
}
}
NS_IMPL_CYCLE_COLLECTION_CLASS
(
nsPresContext
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
nsPresContext
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mAnimationManager
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mDocument
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mEffectCompositor
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mEventManager
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mPrintSettings
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mPrefChangedTimer
)
;
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
nsPresContext
)
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mAnimationManager
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDocument
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mDeviceContext
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mEffectCompositor
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mPrintSettings
)
;
tmp
-
>
Destroy
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
static
bool
sNoTheme
=
false
;
static
bool
sLookAndFeelChanged
;
static
bool
sThemeChanged
;
void
nsPresContext
:
:
GetDocumentColorPreferences
(
)
{
gfxPrefs
:
:
GetSingleton
(
)
;
int32_t
useAccessibilityTheme
=
0
;
bool
usePrefColors
=
true
;
bool
isChromeDocShell
=
false
;
static
int32_t
sDocumentColorsSetting
;
static
bool
sDocumentColorsSettingPrefCached
=
false
;
static
bool
sUseStandinsForNativeColors
=
false
;
if
(
!
sDocumentColorsSettingPrefCached
)
{
sDocumentColorsSettingPrefCached
=
true
;
Preferences
:
:
AddIntVarCache
(
&
sDocumentColorsSetting
"
browser
.
display
.
document_color_use
"
0
)
;
Preferences
:
:
AddBoolVarCache
(
&
sUseStandinsForNativeColors
kUseStandinsForNativeColors
)
;
}
nsIDocument
*
doc
=
mDocument
-
>
GetDisplayDocument
(
)
;
if
(
doc
&
&
doc
-
>
GetDocShell
(
)
)
{
isChromeDocShell
=
nsIDocShellTreeItem
:
:
typeChrome
=
=
doc
-
>
GetDocShell
(
)
-
>
ItemType
(
)
;
}
else
{
nsCOMPtr
<
nsIDocShellTreeItem
>
docShell
(
mContainer
)
;
if
(
docShell
)
{
isChromeDocShell
=
nsIDocShellTreeItem
:
:
typeChrome
=
=
docShell
-
>
ItemType
(
)
;
}
}
mIsChromeOriginImage
=
mDocument
-
>
IsBeingUsedAsImage
(
)
&
&
IsChromeURI
(
mDocument
-
>
GetDocumentURI
(
)
)
;
if
(
isChromeDocShell
|
|
mIsChromeOriginImage
)
{
usePrefColors
=
false
;
}
else
{
useAccessibilityTheme
=
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
eIntID_UseAccessibilityTheme
0
)
;
usePrefColors
=
!
useAccessibilityTheme
;
}
if
(
usePrefColors
)
{
usePrefColors
=
!
Preferences
:
:
GetBool
(
"
browser
.
display
.
use_system_colors
"
false
)
;
}
if
(
sUseStandinsForNativeColors
)
{
mDefaultColor
=
LookAndFeel
:
:
GetColorUsingStandins
(
LookAndFeel
:
:
eColorID_windowtext
NS_RGB
(
0x00
0x00
0x00
)
)
;
mBackgroundColor
=
LookAndFeel
:
:
GetColorUsingStandins
(
LookAndFeel
:
:
eColorID_window
NS_RGB
(
0xff
0xff
0xff
)
)
;
}
else
if
(
usePrefColors
)
{
nsAutoString
colorStr
;
Preferences
:
:
GetString
(
"
browser
.
display
.
foreground_color
"
colorStr
)
;
if
(
!
colorStr
.
IsEmpty
(
)
)
{
mDefaultColor
=
MakeColorPref
(
colorStr
)
;
}
colorStr
.
Truncate
(
)
;
Preferences
:
:
GetString
(
"
browser
.
display
.
background_color
"
colorStr
)
;
if
(
!
colorStr
.
IsEmpty
(
)
)
{
mBackgroundColor
=
MakeColorPref
(
colorStr
)
;
}
}
else
{
mDefaultColor
=
LookAndFeel
:
:
GetColor
(
LookAndFeel
:
:
eColorID_WindowForeground
NS_RGB
(
0x00
0x00
0x00
)
)
;
mBackgroundColor
=
LookAndFeel
:
:
GetColor
(
LookAndFeel
:
:
eColorID_WindowBackground
NS_RGB
(
0xFF
0xFF
0xFF
)
)
;
}
mBackgroundColor
=
NS_ComposeColors
(
NS_RGB
(
0xFF
0xFF
0xFF
)
mBackgroundColor
)
;
if
(
sDocumentColorsSetting
=
=
1
|
|
mDocument
-
>
IsBeingUsedAsImage
(
)
)
{
mUseDocumentColors
=
true
;
}
else
if
(
sDocumentColorsSetting
=
=
2
)
{
mUseDocumentColors
=
isChromeDocShell
|
|
mIsChromeOriginImage
;
}
else
{
MOZ_ASSERT
(
!
useAccessibilityTheme
|
|
!
(
isChromeDocShell
|
|
mIsChromeOriginImage
)
"
The
accessibility
theme
should
only
be
on
for
non
-
chrome
"
)
;
mUseDocumentColors
=
!
useAccessibilityTheme
;
}
}
void
nsPresContext
:
:
GetUserPreferences
(
)
{
if
(
!
GetPresShell
(
)
)
{
return
;
}
mAutoQualityMinFontSizePixelsPref
=
Preferences
:
:
GetInt
(
"
browser
.
display
.
auto_quality_min_font_size
"
)
;
GetDocumentColorPreferences
(
)
;
mSendAfterPaintToContent
=
Preferences
:
:
GetBool
(
"
dom
.
send_after_paint_to_content
"
mSendAfterPaintToContent
)
;
mUnderlineLinks
=
Preferences
:
:
GetBool
(
"
browser
.
underline_anchors
"
mUnderlineLinks
)
;
nsAutoString
colorStr
;
Preferences
:
:
GetString
(
"
browser
.
anchor_color
"
colorStr
)
;
if
(
!
colorStr
.
IsEmpty
(
)
)
{
mLinkColor
=
MakeColorPref
(
colorStr
)
;
}
colorStr
.
Truncate
(
)
;
Preferences
:
:
GetString
(
"
browser
.
active_color
"
colorStr
)
;
if
(
!
colorStr
.
IsEmpty
(
)
)
{
mActiveLinkColor
=
MakeColorPref
(
colorStr
)
;
}
colorStr
.
Truncate
(
)
;
Preferences
:
:
GetString
(
"
browser
.
visited_color
"
colorStr
)
;
if
(
!
colorStr
.
IsEmpty
(
)
)
{
mVisitedLinkColor
=
MakeColorPref
(
colorStr
)
;
}
mUseFocusColors
=
Preferences
:
:
GetBool
(
"
browser
.
display
.
use_focus_colors
"
mUseFocusColors
)
;
mFocusTextColor
=
mDefaultColor
;
mFocusBackgroundColor
=
mBackgroundColor
;
colorStr
.
Truncate
(
)
;
Preferences
:
:
GetString
(
"
browser
.
display
.
focus_text_color
"
colorStr
)
;
if
(
!
colorStr
.
IsEmpty
(
)
)
{
mFocusTextColor
=
MakeColorPref
(
colorStr
)
;
}
colorStr
.
Truncate
(
)
;
Preferences
:
:
GetString
(
"
browser
.
display
.
focus_background_color
"
colorStr
)
;
if
(
!
colorStr
.
IsEmpty
(
)
)
{
mFocusBackgroundColor
=
MakeColorPref
(
colorStr
)
;
}
mFocusRingWidth
=
Preferences
:
:
GetInt
(
"
browser
.
display
.
focus_ring_width
"
mFocusRingWidth
)
;
mFocusRingOnAnything
=
Preferences
:
:
GetBool
(
"
browser
.
display
.
focus_ring_on_anything
"
mFocusRingOnAnything
)
;
mFocusRingStyle
=
Preferences
:
:
GetInt
(
"
browser
.
display
.
focus_ring_style
"
mFocusRingStyle
)
;
mBodyTextColor
=
mDefaultColor
;
mUseDocumentFonts
=
Preferences
:
:
GetInt
(
"
browser
.
display
.
use_document_fonts
"
)
!
=
0
;
mPrefScrollbarSide
=
Preferences
:
:
GetInt
(
"
layout
.
scrollbar
.
side
"
)
;
mLangGroupFontPrefs
.
Reset
(
)
;
mFontGroupCacheDirty
=
true
;
StaticPresData
:
:
Get
(
)
-
>
ResetCachedFontPrefs
(
)
;
nsAutoCString
animatePref
;
Preferences
:
:
GetCString
(
"
image
.
animation_mode
"
animatePref
)
;
if
(
animatePref
.
EqualsLiteral
(
"
normal
"
)
)
mImageAnimationModePref
=
imgIContainer
:
:
kNormalAnimMode
;
else
if
(
animatePref
.
EqualsLiteral
(
"
none
"
)
)
mImageAnimationModePref
=
imgIContainer
:
:
kDontAnimMode
;
else
if
(
animatePref
.
EqualsLiteral
(
"
once
"
)
)
mImageAnimationModePref
=
imgIContainer
:
:
kLoopOnceAnimMode
;
else
mImageAnimationModePref
=
imgIContainer
:
:
kNormalAnimMode
;
uint32_t
bidiOptions
=
GetBidi
(
)
;
int32_t
prefInt
=
Preferences
:
:
GetInt
(
IBMBIDI_TEXTDIRECTION_STR
GET_BIDI_OPTION_DIRECTION
(
bidiOptions
)
)
;
SET_BIDI_OPTION_DIRECTION
(
bidiOptions
prefInt
)
;
mPrefBidiDirection
=
prefInt
;
prefInt
=
Preferences
:
:
GetInt
(
IBMBIDI_TEXTTYPE_STR
GET_BIDI_OPTION_TEXTTYPE
(
bidiOptions
)
)
;
SET_BIDI_OPTION_TEXTTYPE
(
bidiOptions
prefInt
)
;
prefInt
=
Preferences
:
:
GetInt
(
IBMBIDI_NUMERAL_STR
GET_BIDI_OPTION_NUMERAL
(
bidiOptions
)
)
;
SET_BIDI_OPTION_NUMERAL
(
bidiOptions
prefInt
)
;
SetBidi
(
bidiOptions
)
;
}
void
nsPresContext
:
:
InvalidatePaintedLayers
(
)
{
if
(
!
mShell
)
return
;
nsIFrame
*
rootFrame
=
mShell
-
>
FrameManager
(
)
-
>
GetRootFrame
(
)
;
if
(
rootFrame
)
{
rootFrame
-
>
InvalidateFrameSubtree
(
)
;
}
}
void
nsPresContext
:
:
AppUnitsPerDevPixelChanged
(
)
{
InvalidatePaintedLayers
(
)
;
if
(
mDeviceContext
)
{
mDeviceContext
-
>
FlushFontCache
(
)
;
}
if
(
HasCachedStyleData
(
)
)
{
MediaFeatureValuesChanged
(
eRestyle_ForceDescendants
NS_STYLE_HINT_REFLOW
)
;
}
mCurAppUnitsPerDevPixel
=
AppUnitsPerDevPixel
(
)
;
}
void
nsPresContext
:
:
PreferenceChanged
(
const
char
*
aPrefName
)
{
nsDependentCString
prefName
(
aPrefName
)
;
if
(
prefName
.
EqualsLiteral
(
"
layout
.
css
.
dpi
"
)
|
|
prefName
.
EqualsLiteral
(
"
layout
.
css
.
devPixelsPerPx
"
)
)
{
int32_t
oldAppUnitsPerDevPixel
=
AppUnitsPerDevPixel
(
)
;
if
(
mDeviceContext
-
>
CheckDPIChange
(
)
&
&
mShell
)
{
nsCOMPtr
<
nsIPresShell
>
shell
=
mShell
;
nscoord
oldWidthAppUnits
oldHeightAppUnits
;
RefPtr
<
nsViewManager
>
vm
=
shell
-
>
GetViewManager
(
)
;
if
(
!
vm
)
{
return
;
}
vm
-
>
GetWindowDimensions
(
&
oldWidthAppUnits
&
oldHeightAppUnits
)
;
float
oldWidthDevPixels
=
oldWidthAppUnits
/
oldAppUnitsPerDevPixel
;
float
oldHeightDevPixels
=
oldHeightAppUnits
/
oldAppUnitsPerDevPixel
;
nscoord
width
=
NSToCoordRound
(
oldWidthDevPixels
*
AppUnitsPerDevPixel
(
)
)
;
nscoord
height
=
NSToCoordRound
(
oldHeightDevPixels
*
AppUnitsPerDevPixel
(
)
)
;
vm
-
>
SetWindowDimensions
(
width
height
)
;
AppUnitsPerDevPixelChanged
(
)
;
}
return
;
}
if
(
prefName
.
EqualsLiteral
(
GFX_MISSING_FONTS_NOTIFY_PREF
)
)
{
if
(
Preferences
:
:
GetBool
(
GFX_MISSING_FONTS_NOTIFY_PREF
)
)
{
if
(
!
mMissingFonts
)
{
mMissingFonts
=
new
gfxMissingFontRecorder
(
)
;
mPrefChangePendingNeedsReflow
=
true
;
}
}
else
{
if
(
mMissingFonts
)
{
mMissingFonts
-
>
Clear
(
)
;
}
mMissingFonts
=
nullptr
;
}
}
if
(
StringBeginsWith
(
prefName
NS_LITERAL_CSTRING
(
"
font
.
"
)
)
|
|
prefName
.
EqualsLiteral
(
"
intl
.
accept_languages
"
)
)
{
mPrefChangePendingNeedsReflow
=
true
;
}
if
(
StringBeginsWith
(
prefName
NS_LITERAL_CSTRING
(
"
bidi
.
"
)
)
)
{
mPrefChangePendingNeedsReflow
=
true
;
}
if
(
StringBeginsWith
(
prefName
NS_LITERAL_CSTRING
(
"
gfx
.
font_rendering
.
"
)
)
)
{
mPrefChangePendingNeedsReflow
=
true
;
}
if
(
!
mPrefChangedTimer
)
{
nsLayoutStylesheetCache
:
:
InvalidatePreferenceSheets
(
)
;
mPrefChangedTimer
=
CreateTimer
(
PrefChangedUpdateTimerCallback
"
PrefChangedUpdateTimerCallback
"
0
)
;
if
(
!
mPrefChangedTimer
)
{
return
;
}
}
if
(
prefName
.
EqualsLiteral
(
"
nglayout
.
debug
.
paint_flashing
"
)
|
|
prefName
.
EqualsLiteral
(
"
nglayout
.
debug
.
paint_flashing_chrome
"
)
)
{
mPaintFlashingInitialized
=
false
;
return
;
}
}
void
nsPresContext
:
:
UpdateAfterPreferencesChanged
(
)
{
mPrefChangedTimer
=
nullptr
;
if
(
!
mContainer
)
{
mNeedsPrefUpdate
=
true
;
return
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
docShell
(
mContainer
)
;
if
(
docShell
&
&
nsIDocShellTreeItem
:
:
typeChrome
=
=
docShell
-
>
ItemType
(
)
)
{
return
;
}
GetUserPreferences
(
)
;
if
(
mShell
)
{
mShell
-
>
UpdatePreferenceStyles
(
)
;
}
InvalidatePaintedLayers
(
)
;
mDeviceContext
-
>
FlushFontCache
(
)
;
nsChangeHint
hint
=
nsChangeHint
(
0
)
;
if
(
mPrefChangePendingNeedsReflow
)
{
hint
|
=
NS_STYLE_HINT_REFLOW
;
}
RebuildAllStyleData
(
hint
eRestyle_Subtree
)
;
}
nsresult
nsPresContext
:
:
Init
(
nsDeviceContext
*
aDeviceContext
)
{
NS_ASSERTION
(
!
mInitialized
"
attempt
to
reinit
pres
context
"
)
;
NS_ENSURE_ARG
(
aDeviceContext
)
;
mDeviceContext
=
aDeviceContext
;
if
(
mDocument
-
>
IsStyledByServo
(
)
)
{
Element
*
root
=
mDocument
-
>
GetRootElement
(
)
;
if
(
root
&
&
root
-
>
HasServoData
(
)
)
{
ServoRestyleManager
:
:
ClearServoDataFromSubtree
(
root
)
;
}
}
if
(
mDeviceContext
-
>
SetFullZoom
(
mFullZoom
)
)
mDeviceContext
-
>
FlushFontCache
(
)
;
mCurAppUnitsPerDevPixel
=
AppUnitsPerDevPixel
(
)
;
mEventManager
=
new
mozilla
:
:
EventStateManager
(
)
;
mEffectCompositor
=
new
mozilla
:
:
EffectCompositor
(
this
)
;
mTransitionManager
=
new
nsTransitionManager
(
this
)
;
mAnimationManager
=
new
nsAnimationManager
(
this
)
;
if
(
mDocument
-
>
GetDisplayDocument
(
)
)
{
NS_ASSERTION
(
mDocument
-
>
GetDisplayDocument
(
)
-
>
GetShell
(
)
&
&
mDocument
-
>
GetDisplayDocument
(
)
-
>
GetShell
(
)
-
>
GetPresContext
(
)
"
Why
are
we
being
initialized
?
"
)
;
mRefreshDriver
=
mDocument
-
>
GetDisplayDocument
(
)
-
>
GetShell
(
)
-
>
GetPresContext
(
)
-
>
RefreshDriver
(
)
;
}
else
{
nsIDocument
*
parent
=
mDocument
-
>
GetParentDocument
(
)
;
NS_ASSERTION
(
!
parent
|
|
mDocument
-
>
IsStaticDocument
(
)
|
|
parent
-
>
GetShell
(
)
"
How
did
we
end
up
with
a
presshell
if
our
parent
doesn
'
t
"
"
have
one
?
"
)
;
if
(
parent
&
&
parent
-
>
GetShell
(
)
)
{
NS_ASSERTION
(
parent
-
>
GetShell
(
)
-
>
GetPresContext
(
)
"
How
did
we
get
a
presshell
?
"
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
ourItem
=
mDocument
-
>
GetDocShell
(
)
;
if
(
ourItem
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
parentItem
;
ourItem
-
>
GetSameTypeParent
(
getter_AddRefs
(
parentItem
)
)
;
if
(
parentItem
)
{
Element
*
containingElement
=
parent
-
>
FindContentForSubDocument
(
mDocument
)
;
if
(
!
containingElement
-
>
IsXULElement
(
)
|
|
!
containingElement
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
forceOwnRefreshDriver
)
)
{
mRefreshDriver
=
parent
-
>
GetShell
(
)
-
>
GetPresContext
(
)
-
>
RefreshDriver
(
)
;
}
}
}
}
if
(
!
mRefreshDriver
)
{
mRefreshDriver
=
new
nsRefreshDriver
(
this
)
;
}
}
mLangService
=
nsLanguageAtomService
:
:
GetService
(
)
;
Preferences
:
:
RegisterPrefixCallback
(
nsPresContext
:
:
PrefChangedCallback
"
font
.
"
this
)
;
Preferences
:
:
RegisterPrefixCallback
(
nsPresContext
:
:
PrefChangedCallback
"
browser
.
display
.
"
this
)
;
Preferences
:
:
RegisterCallback
(
nsPresContext
:
:
PrefChangedCallback
"
browser
.
underline_anchors
"
this
)
;
Preferences
:
:
RegisterCallback
(
nsPresContext
:
:
PrefChangedCallback
"
browser
.
anchor_color
"
this
)
;
Preferences
:
:
RegisterCallback
(
nsPresContext
:
:
PrefChangedCallback
"
browser
.
active_color
"
this
)
;
Preferences
:
:
RegisterCallback
(
nsPresContext
:
:
PrefChangedCallback
"
browser
.
visited_color
"
this
)
;
Preferences
:
:
RegisterCallback
(
nsPresContext
:
:
PrefChangedCallback
"
image
.
animation_mode
"
this
)
;
Preferences
:
:
RegisterPrefixCallback
(
nsPresContext
:
:
PrefChangedCallback
"
bidi
.
"
this
)
;
Preferences
:
:
RegisterCallback
(
nsPresContext
:
:
PrefChangedCallback
"
dom
.
send_after_paint_to_content
"
this
)
;
Preferences
:
:
RegisterPrefixCallback
(
nsPresContext
:
:
PrefChangedCallback
"
gfx
.
font_rendering
.
"
this
)
;
Preferences
:
:
RegisterCallback
(
nsPresContext
:
:
PrefChangedCallback
"
layout
.
css
.
dpi
"
this
)
;
Preferences
:
:
RegisterCallback
(
nsPresContext
:
:
PrefChangedCallback
"
layout
.
css
.
devPixelsPerPx
"
this
)
;
Preferences
:
:
RegisterCallback
(
nsPresContext
:
:
PrefChangedCallback
"
nglayout
.
debug
.
paint_flashing
"
this
)
;
Preferences
:
:
RegisterCallback
(
nsPresContext
:
:
PrefChangedCallback
"
nglayout
.
debug
.
paint_flashing_chrome
"
this
)
;
Preferences
:
:
RegisterCallback
(
nsPresContext
:
:
PrefChangedCallback
kUseStandinsForNativeColors
this
)
;
Preferences
:
:
RegisterCallback
(
nsPresContext
:
:
PrefChangedCallback
"
intl
.
accept_languages
"
this
)
;
nsresult
rv
=
mEventManager
-
>
Init
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mEventManager
-
>
SetPresContext
(
this
)
;
#
ifdef
RESTYLE_LOGGING
mRestyleLoggingEnabled
=
GeckoRestyleManager
:
:
RestyleLoggingInitiallyEnabled
(
)
;
#
endif
#
ifdef
DEBUG
mInitialized
=
true
;
#
endif
return
NS_OK
;
}
void
nsPresContext
:
:
AttachShell
(
nsIPresShell
*
aShell
StyleBackendType
aBackendType
)
{
MOZ_ASSERT
(
!
mShell
)
;
mShell
=
aShell
;
if
(
aBackendType
=
=
StyleBackendType
:
:
Servo
)
{
mRestyleManager
=
new
ServoRestyleManager
(
this
)
;
}
else
{
mRestyleManager
=
new
GeckoRestyleManager
(
this
)
;
}
mCounterStyleManager
=
new
mozilla
:
:
CounterStyleManager
(
this
)
;
nsIDocument
*
doc
=
mShell
-
>
GetDocument
(
)
;
NS_ASSERTION
(
doc
"
expect
document
here
"
)
;
if
(
doc
)
{
mDocument
=
doc
;
}
GetUserPreferences
(
)
;
if
(
doc
)
{
nsIURI
*
docURI
=
doc
-
>
GetDocumentURI
(
)
;
if
(
IsDynamic
(
)
&
&
docURI
)
{
bool
isChrome
=
false
;
bool
isRes
=
false
;
docURI
-
>
SchemeIs
(
"
chrome
"
&
isChrome
)
;
docURI
-
>
SchemeIs
(
"
resource
"
&
isRes
)
;
if
(
!
isChrome
&
&
!
isRes
)
mImageAnimationMode
=
mImageAnimationModePref
;
else
mImageAnimationMode
=
imgIContainer
:
:
kNormalAnimMode
;
}
UpdateCharSet
(
doc
-
>
GetDocumentCharacterSet
(
)
)
;
}
}
void
nsPresContext
:
:
DetachShell
(
)
{
if
(
mCounterStyleManager
)
{
mCounterStyleManager
-
>
Disconnect
(
)
;
mCounterStyleManager
=
nullptr
;
}
mShell
=
nullptr
;
if
(
mEffectCompositor
)
{
mEffectCompositor
-
>
Disconnect
(
)
;
mEffectCompositor
=
nullptr
;
}
if
(
mTransitionManager
)
{
mTransitionManager
-
>
Disconnect
(
)
;
mTransitionManager
=
nullptr
;
}
if
(
mAnimationManager
)
{
mAnimationManager
-
>
Disconnect
(
)
;
mAnimationManager
=
nullptr
;
}
if
(
mRestyleManager
)
{
mRestyleManager
-
>
Disconnect
(
)
;
mRestyleManager
=
nullptr
;
}
if
(
mRefreshDriver
&
&
mRefreshDriver
-
>
GetPresContext
(
)
=
=
this
)
{
mRefreshDriver
-
>
Disconnect
(
)
;
}
if
(
IsRoot
(
)
)
{
nsRootPresContext
*
thisRoot
=
static_cast
<
nsRootPresContext
*
>
(
this
)
;
thisRoot
-
>
CancelApplyPluginGeometryTimer
(
)
;
thisRoot
-
>
CancelAllDidPaintTimers
(
)
;
}
}
void
nsPresContext
:
:
DoChangeCharSet
(
NotNull
<
const
Encoding
*
>
aCharSet
)
{
UpdateCharSet
(
aCharSet
)
;
mDeviceContext
-
>
FlushFontCache
(
)
;
RebuildAllStyleData
(
NS_STYLE_HINT_REFLOW
mDocument
-
>
IsStyledByServo
(
)
?
eRestyle_ForceDescendants
:
nsRestyleHint
(
0
)
)
;
}
void
nsPresContext
:
:
UpdateCharSet
(
NotNull
<
const
Encoding
*
>
aCharSet
)
{
mLanguage
=
mLangService
-
>
LookupCharSet
(
aCharSet
)
;
if
(
mLanguage
=
=
nsGkAtoms
:
:
Unicode
)
{
mLanguage
=
mLangService
-
>
GetLocaleLanguage
(
)
;
}
mLangGroupFontPrefs
.
Reset
(
)
;
mFontGroupCacheDirty
=
true
;
switch
(
GET_BIDI_OPTION_TEXTTYPE
(
GetBidi
(
)
)
)
{
case
IBMBIDI_TEXTTYPE_LOGICAL
:
SetVisualMode
(
false
)
;
break
;
case
IBMBIDI_TEXTTYPE_VISUAL
:
SetVisualMode
(
true
)
;
break
;
case
IBMBIDI_TEXTTYPE_CHARSET
:
default
:
SetVisualMode
(
IsVisualCharset
(
aCharSet
)
)
;
}
}
void
nsPresContext
:
:
DispatchCharSetChange
(
NotNull
<
const
Encoding
*
>
aEncoding
)
{
RefPtr
<
CharSetChangingRunnable
>
runnable
=
new
CharSetChangingRunnable
(
this
aEncoding
)
;
Document
(
)
-
>
Dispatch
(
TaskCategory
:
:
Other
runnable
.
forget
(
)
)
;
}
nsPresContext
*
nsPresContext
:
:
GetParentPresContext
(
)
{
nsIPresShell
*
shell
=
GetPresShell
(
)
;
if
(
shell
)
{
nsViewManager
*
viewManager
=
shell
-
>
GetViewManager
(
)
;
if
(
viewManager
)
{
nsView
*
view
=
viewManager
-
>
GetRootView
(
)
;
if
(
view
)
{
view
=
view
-
>
GetParent
(
)
;
if
(
view
)
{
view
=
view
-
>
GetParent
(
)
;
if
(
view
)
{
nsIFrame
*
f
=
view
-
>
GetFrame
(
)
;
if
(
f
)
{
return
f
-
>
PresContext
(
)
;
}
}
}
}
}
}
return
nullptr
;
}
nsPresContext
*
nsPresContext
:
:
GetToplevelContentDocumentPresContext
(
)
{
if
(
IsChrome
(
)
)
return
nullptr
;
nsPresContext
*
pc
=
this
;
for
(
;
;
)
{
nsPresContext
*
parent
=
pc
-
>
GetParentPresContext
(
)
;
if
(
!
parent
|
|
parent
-
>
IsChrome
(
)
)
return
pc
;
pc
=
parent
;
}
}
nsIWidget
*
nsPresContext
:
:
GetNearestWidget
(
nsPoint
*
aOffset
)
{
NS_ENSURE_TRUE
(
mShell
nullptr
)
;
nsIFrame
*
frame
=
mShell
-
>
GetRootFrame
(
)
;
NS_ENSURE_TRUE
(
frame
nullptr
)
;
return
frame
-
>
GetView
(
)
-
>
GetNearestWidget
(
aOffset
)
;
}
nsIWidget
*
nsPresContext
:
:
GetRootWidget
(
)
{
NS_ENSURE_TRUE
(
mShell
nullptr
)
;
nsViewManager
*
vm
=
mShell
-
>
GetViewManager
(
)
;
if
(
!
vm
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIWidget
>
widget
;
vm
-
>
GetRootWidget
(
getter_AddRefs
(
widget
)
)
;
return
widget
.
get
(
)
;
}
nsRootPresContext
*
nsPresContext
:
:
GetRootPresContext
(
)
{
nsPresContext
*
pc
=
this
;
for
(
;
;
)
{
nsPresContext
*
parent
=
pc
-
>
GetParentPresContext
(
)
;
if
(
!
parent
)
break
;
pc
=
parent
;
}
return
pc
-
>
IsRoot
(
)
?
static_cast
<
nsRootPresContext
*
>
(
pc
)
:
nullptr
;
}
void
nsPresContext
:
:
CompatibilityModeChanged
(
)
{
if
(
!
mShell
)
{
return
;
}
nsIDocument
*
doc
=
mShell
-
>
GetDocument
(
)
;
if
(
!
doc
)
{
return
;
}
StyleSetHandle
styleSet
=
mShell
-
>
StyleSet
(
)
;
if
(
styleSet
-
>
IsServo
(
)
)
{
styleSet
-
>
AsServo
(
)
-
>
CompatibilityModeChanged
(
)
;
}
if
(
doc
-
>
IsSVGDocument
(
)
)
{
return
;
}
bool
needsQuirkSheet
=
CompatibilityMode
(
)
=
=
eCompatibility_NavQuirks
;
if
(
mQuirkSheetAdded
=
=
needsQuirkSheet
)
{
return
;
}
auto
cache
=
nsLayoutStylesheetCache
:
:
For
(
styleSet
-
>
BackendType
(
)
)
;
StyleSheet
*
sheet
=
cache
-
>
QuirkSheet
(
)
;
if
(
needsQuirkSheet
)
{
DebugOnly
<
nsresult
>
rv
=
styleSet
-
>
AppendStyleSheet
(
SheetType
:
:
Agent
sheet
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
failed
to
insert
quirk
.
css
"
)
;
}
else
{
DebugOnly
<
nsresult
>
rv
=
styleSet
-
>
RemoveStyleSheet
(
SheetType
:
:
Agent
sheet
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
failed
to
remove
quirk
.
css
"
)
;
}
mQuirkSheetAdded
=
needsQuirkSheet
;
}
static
void
SetImgAnimModeOnImgReq
(
imgIRequest
*
aImgReq
uint16_t
aMode
)
{
if
(
aImgReq
)
{
nsCOMPtr
<
imgIContainer
>
imgCon
;
aImgReq
-
>
GetImage
(
getter_AddRefs
(
imgCon
)
)
;
if
(
imgCon
)
{
imgCon
-
>
SetAnimationMode
(
aMode
)
;
}
}
}
void
nsPresContext
:
:
SetImgAnimations
(
nsIContent
*
aParent
uint16_t
aMode
)
{
nsCOMPtr
<
nsIImageLoadingContent
>
imgContent
(
do_QueryInterface
(
aParent
)
)
;
if
(
imgContent
)
{
nsCOMPtr
<
imgIRequest
>
imgReq
;
imgContent
-
>
GetRequest
(
nsIImageLoadingContent
:
:
CURRENT_REQUEST
getter_AddRefs
(
imgReq
)
)
;
SetImgAnimModeOnImgReq
(
imgReq
aMode
)
;
}
uint32_t
count
=
aParent
-
>
GetChildCount
(
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
SetImgAnimations
(
aParent
-
>
GetChildAt
(
i
)
aMode
)
;
}
}
void
nsPresContext
:
:
SetSMILAnimations
(
nsIDocument
*
aDoc
uint16_t
aNewMode
uint16_t
aOldMode
)
{
if
(
aDoc
-
>
HasAnimationController
(
)
)
{
nsSMILAnimationController
*
controller
=
aDoc
-
>
GetAnimationController
(
)
;
switch
(
aNewMode
)
{
case
imgIContainer
:
:
kNormalAnimMode
:
case
imgIContainer
:
:
kLoopOnceAnimMode
:
if
(
aOldMode
=
=
imgIContainer
:
:
kDontAnimMode
)
controller
-
>
Resume
(
nsSMILTimeContainer
:
:
PAUSE_USERPREF
)
;
break
;
case
imgIContainer
:
:
kDontAnimMode
:
if
(
aOldMode
!
=
imgIContainer
:
:
kDontAnimMode
)
controller
-
>
Pause
(
nsSMILTimeContainer
:
:
PAUSE_USERPREF
)
;
break
;
}
}
}
void
nsPresContext
:
:
SetImageAnimationMode
(
uint16_t
aMode
)
{
NS_ASSERTION
(
aMode
=
=
imgIContainer
:
:
kNormalAnimMode
|
|
aMode
=
=
imgIContainer
:
:
kDontAnimMode
|
|
aMode
=
=
imgIContainer
:
:
kLoopOnceAnimMode
"
Wrong
Animation
Mode
is
being
set
!
"
)
;
if
(
!
IsDynamic
(
)
)
return
;
if
(
mShell
!
=
nullptr
)
{
nsIDocument
*
doc
=
mShell
-
>
GetDocument
(
)
;
if
(
doc
)
{
doc
-
>
StyleImageLoader
(
)
-
>
SetAnimationMode
(
aMode
)
;
Element
*
rootElement
=
doc
-
>
GetRootElement
(
)
;
if
(
rootElement
)
{
SetImgAnimations
(
rootElement
aMode
)
;
}
SetSMILAnimations
(
doc
aMode
mImageAnimationMode
)
;
}
}
mImageAnimationMode
=
aMode
;
}
already_AddRefed
<
nsAtom
>
nsPresContext
:
:
GetContentLanguage
(
)
const
{
nsAutoString
language
;
Document
(
)
-
>
GetContentLanguage
(
language
)
;
language
.
StripWhitespace
(
)
;
if
(
!
language
.
IsEmpty
(
)
&
&
!
language
.
Contains
(
char16_t
(
'
'
)
)
)
{
return
NS_Atomize
(
language
)
;
}
return
nullptr
;
}
void
nsPresContext
:
:
UpdateEffectiveTextZoom
(
)
{
float
newZoom
=
mSystemFontScale
*
mTextZoom
;
float
minZoom
=
nsLayoutUtils
:
:
MinZoom
(
)
;
float
maxZoom
=
nsLayoutUtils
:
:
MaxZoom
(
)
;
if
(
newZoom
<
minZoom
)
{
newZoom
=
minZoom
;
}
else
if
(
newZoom
>
maxZoom
)
{
newZoom
=
maxZoom
;
}
mEffectiveTextZoom
=
newZoom
;
if
(
mDocument
-
>
IsStyledByServo
(
)
|
|
HasCachedStyleData
(
)
)
{
MediaFeatureValuesChanged
(
eRestyle_ForceDescendants
NS_STYLE_HINT_REFLOW
)
;
}
}
float
nsPresContext
:
:
GetDeviceFullZoom
(
)
{
return
mDeviceContext
-
>
GetFullZoom
(
)
;
}
void
nsPresContext
:
:
SetFullZoom
(
float
aZoom
)
{
if
(
!
mShell
|
|
mFullZoom
=
=
aZoom
)
{
return
;
}
nscoord
oldWidthAppUnits
oldHeightAppUnits
;
mShell
-
>
GetViewManager
(
)
-
>
GetWindowDimensions
(
&
oldWidthAppUnits
&
oldHeightAppUnits
)
;
float
oldWidthDevPixels
=
oldWidthAppUnits
/
float
(
mCurAppUnitsPerDevPixel
)
;
float
oldHeightDevPixels
=
oldHeightAppUnits
/
float
(
mCurAppUnitsPerDevPixel
)
;
mDeviceContext
-
>
SetFullZoom
(
aZoom
)
;
NS_ASSERTION
(
!
mSuppressResizeReflow
"
two
zooms
happening
at
the
same
time
?
impossible
!
"
)
;
mSuppressResizeReflow
=
true
;
mFullZoom
=
aZoom
;
mShell
-
>
GetViewManager
(
)
-
>
SetWindowDimensions
(
NSToCoordRound
(
oldWidthDevPixels
*
AppUnitsPerDevPixel
(
)
)
NSToCoordRound
(
oldHeightDevPixels
*
AppUnitsPerDevPixel
(
)
)
)
;
AppUnitsPerDevPixelChanged
(
)
;
mSuppressResizeReflow
=
false
;
}
void
nsPresContext
:
:
SetOverrideDPPX
(
float
aDPPX
)
{
if
(
aDPPX
!
=
mOverrideDPPX
)
{
mOverrideDPPX
=
aDPPX
;
if
(
HasCachedStyleData
(
)
)
{
MediaFeatureValuesChanged
(
nsRestyleHint
(
0
)
nsChangeHint
(
0
)
)
;
}
}
}
gfxSize
nsPresContext
:
:
ScreenSizeInchesForFontInflation
(
bool
*
aChanged
)
{
if
(
aChanged
)
{
*
aChanged
=
false
;
}
nsDeviceContext
*
dx
=
DeviceContext
(
)
;
nsRect
clientRect
;
dx
-
>
GetClientRect
(
clientRect
)
;
float
unitsPerInch
=
dx
-
>
AppUnitsPerPhysicalInch
(
)
;
gfxSize
deviceSizeInches
(
float
(
clientRect
.
width
)
/
unitsPerInch
float
(
clientRect
.
height
)
/
unitsPerInch
)
;
if
(
mLastFontInflationScreenSize
=
=
gfxSize
(
-
1
.
0
-
1
.
0
)
)
{
mLastFontInflationScreenSize
=
deviceSizeInches
;
}
if
(
deviceSizeInches
!
=
mLastFontInflationScreenSize
&
&
aChanged
)
{
*
aChanged
=
true
;
mLastFontInflationScreenSize
=
deviceSizeInches
;
}
return
deviceSizeInches
;
}
static
bool
CheckOverflow
(
const
nsStyleDisplay
*
aDisplay
ScrollbarStyles
*
aStyles
)
{
if
(
aDisplay
-
>
mOverflowX
=
=
NS_STYLE_OVERFLOW_VISIBLE
&
&
aDisplay
-
>
mScrollBehavior
=
=
NS_STYLE_SCROLL_BEHAVIOR_AUTO
&
&
aDisplay
-
>
mScrollSnapTypeX
=
=
NS_STYLE_SCROLL_SNAP_TYPE_NONE
&
&
aDisplay
-
>
mScrollSnapTypeY
=
=
NS_STYLE_SCROLL_SNAP_TYPE_NONE
&
&
aDisplay
-
>
mScrollSnapPointsX
=
=
nsStyleCoord
(
eStyleUnit_None
)
&
&
aDisplay
-
>
mScrollSnapPointsY
=
=
nsStyleCoord
(
eStyleUnit_None
)
&
&
!
aDisplay
-
>
mScrollSnapDestination
.
mXPosition
.
mHasPercent
&
&
!
aDisplay
-
>
mScrollSnapDestination
.
mYPosition
.
mHasPercent
&
&
aDisplay
-
>
mScrollSnapDestination
.
mXPosition
.
mLength
=
=
0
&
&
aDisplay
-
>
mScrollSnapDestination
.
mYPosition
.
mLength
=
=
0
)
{
return
false
;
}
if
(
aDisplay
-
>
mOverflowX
=
=
NS_STYLE_OVERFLOW_CLIP
)
{
*
aStyles
=
ScrollbarStyles
(
NS_STYLE_OVERFLOW_HIDDEN
NS_STYLE_OVERFLOW_HIDDEN
aDisplay
)
;
}
else
{
*
aStyles
=
ScrollbarStyles
(
aDisplay
)
;
}
return
true
;
}
static
Element
*
GetPropagatedScrollbarStylesForViewport
(
nsPresContext
*
aPresContext
ScrollbarStyles
*
aStyles
)
{
nsIDocument
*
document
=
aPresContext
-
>
Document
(
)
;
Element
*
docElement
=
document
-
>
GetRootElement
(
)
;
if
(
!
docElement
)
{
return
nullptr
;
}
StyleSetHandle
styleSet
=
aPresContext
-
>
StyleSet
(
)
;
RefPtr
<
nsStyleContext
>
rootStyle
=
styleSet
-
>
ResolveStyleFor
(
docElement
nullptr
LazyComputeBehavior
:
:
Allow
)
;
if
(
CheckOverflow
(
rootStyle
-
>
StyleDisplay
(
)
aStyles
)
)
{
return
docElement
;
}
nsHTMLDocument
*
htmlDoc
=
document
-
>
AsHTMLDocument
(
)
;
if
(
!
htmlDoc
|
|
!
docElement
-
>
IsHTMLElement
(
)
)
{
return
nullptr
;
}
Element
*
bodyElement
=
htmlDoc
-
>
GetBodyElement
(
)
;
if
(
!
bodyElement
)
{
return
nullptr
;
}
MOZ_ASSERT
(
bodyElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
"
GetBodyElement
returned
something
bogus
"
)
;
RefPtr
<
nsStyleContext
>
bodyStyle
=
styleSet
-
>
ResolveStyleFor
(
bodyElement
rootStyle
LazyComputeBehavior
:
:
Allow
)
;
if
(
CheckOverflow
(
bodyStyle
-
>
StyleDisplay
(
)
aStyles
)
)
{
return
bodyElement
;
}
return
nullptr
;
}
Element
*
nsPresContext
:
:
UpdateViewportScrollbarStylesOverride
(
)
{
mViewportStyleScrollbar
=
ScrollbarStyles
(
NS_STYLE_OVERFLOW_AUTO
NS_STYLE_OVERFLOW_AUTO
)
;
mViewportScrollbarOverrideElement
=
nullptr
;
if
(
!
IsPaginated
(
)
)
{
mViewportScrollbarOverrideElement
=
GetPropagatedScrollbarStylesForViewport
(
this
&
mViewportStyleScrollbar
)
;
}
nsIDocument
*
document
=
Document
(
)
;
if
(
Element
*
fullscreenElement
=
document
-
>
GetFullscreenElement
(
)
)
{
if
(
fullscreenElement
!
=
document
-
>
GetRootElement
(
)
&
&
fullscreenElement
!
=
mViewportScrollbarOverrideElement
)
{
mViewportStyleScrollbar
=
ScrollbarStyles
(
NS_STYLE_OVERFLOW_HIDDEN
NS_STYLE_OVERFLOW_HIDDEN
)
;
}
}
return
mViewportScrollbarOverrideElement
;
}
bool
nsPresContext
:
:
ElementWouldPropagateScrollbarStyles
(
Element
*
aElement
)
{
MOZ_ASSERT
(
IsPaginated
(
)
"
Should
only
be
called
on
paginated
contexts
"
)
;
if
(
aElement
-
>
GetParent
(
)
&
&
!
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
return
false
;
}
ScrollbarStyles
dummy
(
NS_STYLE_OVERFLOW_AUTO
NS_STYLE_OVERFLOW_AUTO
)
;
return
GetPropagatedScrollbarStylesForViewport
(
this
&
dummy
)
=
=
aElement
;
}
void
nsPresContext
:
:
SetContainer
(
nsIDocShell
*
aDocShell
)
{
if
(
aDocShell
)
{
NS_ASSERTION
(
!
(
mContainer
&
&
mNeedsPrefUpdate
)
"
Should
only
need
pref
update
if
mContainer
is
null
.
"
)
;
mContainer
=
static_cast
<
nsDocShell
*
>
(
aDocShell
)
;
if
(
mNeedsPrefUpdate
)
{
if
(
!
mPrefChangedTimer
)
{
mPrefChangedTimer
=
CreateTimer
(
PrefChangedUpdateTimerCallback
"
PrefChangedUpdateTimerCallback
"
0
)
;
}
mNeedsPrefUpdate
=
false
;
}
}
else
{
mContainer
=
WeakPtr
<
nsDocShell
>
(
)
;
}
UpdateIsChrome
(
)
;
if
(
mContainer
)
{
GetDocumentColorPreferences
(
)
;
}
}
nsISupports
*
nsPresContext
:
:
GetContainerWeak
(
)
const
{
return
static_cast
<
nsIDocShell
*
>
(
mContainer
)
;
}
nsIDocShell
*
nsPresContext
:
:
GetDocShell
(
)
const
{
return
mContainer
;
}
void
nsPresContext
:
:
Detach
(
)
{
SetContainer
(
nullptr
)
;
SetLinkHandler
(
nullptr
)
;
}
bool
nsPresContext
:
:
BidiEnabled
(
)
const
{
return
Document
(
)
-
>
GetBidiEnabled
(
)
;
}
void
nsPresContext
:
:
SetBidiEnabled
(
)
const
{
if
(
mShell
)
{
nsIDocument
*
doc
=
mShell
-
>
GetDocument
(
)
;
if
(
doc
)
{
doc
-
>
SetBidiEnabled
(
)
;
}
}
}
void
nsPresContext
:
:
SetBidi
(
uint32_t
aSource
)
{
if
(
aSource
=
=
GetBidi
(
)
)
{
return
;
}
Document
(
)
-
>
SetBidiOptions
(
aSource
)
;
if
(
IBMBIDI_TEXTDIRECTION_RTL
=
=
GET_BIDI_OPTION_DIRECTION
(
aSource
)
|
|
IBMBIDI_NUMERAL_HINDI
=
=
GET_BIDI_OPTION_NUMERAL
(
aSource
)
)
{
SetBidiEnabled
(
)
;
}
if
(
IBMBIDI_TEXTTYPE_VISUAL
=
=
GET_BIDI_OPTION_TEXTTYPE
(
aSource
)
)
{
SetVisualMode
(
true
)
;
}
else
if
(
IBMBIDI_TEXTTYPE_LOGICAL
=
=
GET_BIDI_OPTION_TEXTTYPE
(
aSource
)
)
{
SetVisualMode
(
false
)
;
}
else
{
nsIDocument
*
doc
=
mShell
-
>
GetDocument
(
)
;
if
(
doc
)
{
SetVisualMode
(
IsVisualCharset
(
doc
-
>
GetDocumentCharacterSet
(
)
)
)
;
}
}
}
uint32_t
nsPresContext
:
:
GetBidi
(
)
const
{
return
Document
(
)
-
>
GetBidiOptions
(
)
;
}
bool
nsPresContext
:
:
IsTopLevelWindowInactive
(
)
{
return
Document
(
)
-
>
IsTopLevelWindowInactive
(
)
;
}
void
nsPresContext
:
:
RecordInteractionTime
(
InteractionType
aType
const
TimeStamp
&
aTimeStamp
)
{
if
(
!
mInteractionTimeEnabled
|
|
aTimeStamp
.
IsNull
(
)
)
{
return
;
}
TimeStamp
nsPresContext
:
:
*
interactionTimes
[
]
=
{
&
nsPresContext
:
:
mFirstClickTime
&
nsPresContext
:
:
mFirstKeyTime
&
nsPresContext
:
:
mFirstMouseMoveTime
&
nsPresContext
:
:
mFirstScrollTime
}
;
Telemetry
:
:
HistogramID
histogramIds
[
]
=
{
Telemetry
:
:
TIME_TO_FIRST_CLICK_MS
Telemetry
:
:
TIME_TO_FIRST_KEY_INPUT_MS
Telemetry
:
:
TIME_TO_FIRST_MOUSE_MOVE_MS
Telemetry
:
:
TIME_TO_FIRST_SCROLL_MS
}
;
TimeStamp
&
interactionTime
=
this
-
>
*
(
interactionTimes
[
static_cast
<
uint32_t
>
(
aType
)
]
)
;
if
(
!
interactionTime
.
IsNull
(
)
)
{
return
;
}
nsPresContext
*
topContentPresContext
=
GetToplevelContentDocumentPresContext
(
)
;
if
(
!
topContentPresContext
)
{
interactionTime
=
TimeStamp
:
:
Now
(
)
;
return
;
}
if
(
topContentPresContext
-
>
mFirstNonBlankPaintTime
.
IsNull
(
)
|
|
topContentPresContext
-
>
mFirstNonBlankPaintTime
>
aTimeStamp
)
{
return
;
}
bool
isFirstInteraction
=
true
;
for
(
TimeStamp
nsPresContext
:
:
*
memberPtr
:
interactionTimes
)
{
TimeStamp
&
timeStamp
=
this
-
>
*
(
memberPtr
)
;
if
(
!
timeStamp
.
IsNull
(
)
)
{
isFirstInteraction
=
false
;
break
;
}
}
interactionTime
=
TimeStamp
:
:
Now
(
)
;
if
(
this
=
=
topContentPresContext
)
{
if
(
Telemetry
:
:
CanRecordExtended
(
)
)
{
double
millis
=
(
interactionTime
-
mFirstNonBlankPaintTime
)
.
ToMilliseconds
(
)
;
Telemetry
:
:
Accumulate
(
histogramIds
[
static_cast
<
uint32_t
>
(
aType
)
]
millis
)
;
if
(
isFirstInteraction
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
TIME_TO_FIRST_INTERACTION_MS
millis
)
;
}
}
}
else
{
topContentPresContext
-
>
RecordInteractionTime
(
aType
aTimeStamp
)
;
}
}
nsITheme
*
nsPresContext
:
:
GetTheme
(
)
{
if
(
!
sNoTheme
&
&
!
mTheme
)
{
mTheme
=
do_GetService
(
"
mozilla
.
org
/
chrome
/
chrome
-
native
-
theme
;
1
"
)
;
if
(
!
mTheme
)
sNoTheme
=
true
;
}
return
mTheme
;
}
void
nsPresContext
:
:
ThemeChanged
(
)
{
if
(
!
mPendingThemeChanged
)
{
sLookAndFeelChanged
=
true
;
sThemeChanged
=
true
;
nsCOMPtr
<
nsIRunnable
>
ev
=
NewRunnableMethod
(
"
nsPresContext
:
:
ThemeChangedInternal
"
this
&
nsPresContext
:
:
ThemeChangedInternal
)
;
nsresult
rv
=
Document
(
)
-
>
Dispatch
(
TaskCategory
:
:
Other
ev
.
forget
(
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mPendingThemeChanged
=
true
;
}
}
}
static
bool
NotifyThemeChanged
(
TabParent
*
aTabParent
void
*
aArg
)
{
aTabParent
-
>
ThemeChanged
(
)
;
return
false
;
}
void
nsPresContext
:
:
ThemeChangedInternal
(
)
{
mPendingThemeChanged
=
false
;
if
(
mTheme
&
&
sThemeChanged
)
{
mTheme
-
>
ThemeChanged
(
)
;
sThemeChanged
=
false
;
}
if
(
sLookAndFeelChanged
)
{
LookAndFeel
:
:
Refresh
(
)
;
sLookAndFeelChanged
=
false
;
image
:
:
SurfaceCacheUtils
:
:
DiscardAll
(
)
;
}
RefreshSystemMetrics
(
)
;
nsContentUtils
:
:
CallOnAllRemoteChildren
(
mDocument
-
>
GetWindow
(
)
NotifyThemeChanged
nullptr
)
;
}
void
nsPresContext
:
:
SysColorChanged
(
)
{
if
(
!
mPendingSysColorChanged
)
{
sLookAndFeelChanged
=
true
;
nsCOMPtr
<
nsIRunnable
>
ev
=
NewRunnableMethod
(
"
nsPresContext
:
:
SysColorChangedInternal
"
this
&
nsPresContext
:
:
SysColorChangedInternal
)
;
nsresult
rv
=
Document
(
)
-
>
Dispatch
(
TaskCategory
:
:
Other
ev
.
forget
(
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mPendingSysColorChanged
=
true
;
}
}
}
void
nsPresContext
:
:
SysColorChangedInternal
(
)
{
mPendingSysColorChanged
=
false
;
if
(
sLookAndFeelChanged
)
{
LookAndFeel
:
:
Refresh
(
)
;
sLookAndFeelChanged
=
false
;
}
RefreshSystemMetrics
(
)
;
GetDocumentColorPreferences
(
)
;
RebuildAllStyleData
(
nsChangeHint
(
0
)
nsRestyleHint
(
0
)
)
;
}
void
nsPresContext
:
:
RefreshSystemMetrics
(
)
{
nsMediaFeatures
:
:
FreeSystemMetrics
(
)
;
MediaFeatureValuesChanged
(
eRestyle_ForceDescendants
NS_STYLE_HINT_REFLOW
)
;
}
void
nsPresContext
:
:
UIResolutionChanged
(
)
{
if
(
!
mPendingUIResolutionChanged
)
{
nsCOMPtr
<
nsIRunnable
>
ev
=
NewRunnableMethod
(
"
nsPresContext
:
:
UIResolutionChangedInternal
"
this
&
nsPresContext
:
:
UIResolutionChangedInternal
)
;
nsresult
rv
=
Document
(
)
-
>
Dispatch
(
TaskCategory
:
:
Other
ev
.
forget
(
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mPendingUIResolutionChanged
=
true
;
}
}
}
void
nsPresContext
:
:
UIResolutionChangedSync
(
)
{
if
(
!
mPendingUIResolutionChanged
)
{
mPendingUIResolutionChanged
=
true
;
UIResolutionChangedInternalScale
(
0
.
0
)
;
}
}
bool
nsPresContext
:
:
UIResolutionChangedSubdocumentCallback
(
nsIDocument
*
aDocument
void
*
aData
)
{
nsIPresShell
*
shell
=
aDocument
-
>
GetShell
(
)
;
if
(
shell
)
{
nsPresContext
*
pc
=
shell
-
>
GetPresContext
(
)
;
if
(
pc
)
{
double
scale
=
*
static_cast
<
double
*
>
(
aData
)
;
pc
-
>
UIResolutionChangedInternalScale
(
scale
)
;
}
}
return
true
;
}
static
void
NotifyTabUIResolutionChanged
(
TabParent
*
aTab
void
*
aArg
)
{
aTab
-
>
UIResolutionChanged
(
)
;
}
static
void
NotifyChildrenUIResolutionChanged
(
nsPIDOMWindowOuter
*
aWindow
)
{
nsCOMPtr
<
nsIDocument
>
doc
=
aWindow
-
>
GetExtantDoc
(
)
;
RefPtr
<
nsPIWindowRoot
>
topLevelWin
=
nsContentUtils
:
:
GetWindowRoot
(
doc
)
;
if
(
!
topLevelWin
)
{
return
;
}
topLevelWin
-
>
EnumerateBrowsers
(
NotifyTabUIResolutionChanged
nullptr
)
;
}
void
nsPresContext
:
:
UIResolutionChangedInternal
(
)
{
UIResolutionChangedInternalScale
(
0
.
0
)
;
}
void
nsPresContext
:
:
UIResolutionChangedInternalScale
(
double
aScale
)
{
mPendingUIResolutionChanged
=
false
;
mDeviceContext
-
>
CheckDPIChange
(
&
aScale
)
;
if
(
mCurAppUnitsPerDevPixel
!
=
AppUnitsPerDevPixel
(
)
)
{
AppUnitsPerDevPixelChanged
(
)
;
}
if
(
nsPIDOMWindowOuter
*
window
=
mDocument
-
>
GetWindow
(
)
)
{
NotifyChildrenUIResolutionChanged
(
window
)
;
}
mDocument
-
>
EnumerateSubDocuments
(
UIResolutionChangedSubdocumentCallback
&
aScale
)
;
}
void
nsPresContext
:
:
EmulateMedium
(
const
nsAString
&
aMediaType
)
{
nsAtom
*
previousMedium
=
Medium
(
)
;
mIsEmulatingMedia
=
true
;
nsAutoString
mediaType
;
nsContentUtils
:
:
ASCIIToLower
(
aMediaType
mediaType
)
;
mMediaEmulated
=
NS_Atomize
(
mediaType
)
;
if
(
mMediaEmulated
!
=
previousMedium
&
&
mShell
)
{
MediaFeatureValuesChanged
(
nsRestyleHint
(
0
)
nsChangeHint
(
0
)
)
;
}
}
void
nsPresContext
:
:
StopEmulatingMedium
(
)
{
nsAtom
*
previousMedium
=
Medium
(
)
;
mIsEmulatingMedia
=
false
;
if
(
Medium
(
)
!
=
previousMedium
)
{
MediaFeatureValuesChanged
(
nsRestyleHint
(
0
)
nsChangeHint
(
0
)
)
;
}
}
void
nsPresContext
:
:
ForceCacheLang
(
nsAtom
*
aLanguage
)
{
GetDefaultFont
(
kPresContext_DefaultVariableFont_ID
aLanguage
)
;
mLanguagesUsed
.
PutEntry
(
aLanguage
)
;
}
void
nsPresContext
:
:
CacheAllLangs
(
)
{
if
(
mFontGroupCacheDirty
)
{
RefPtr
<
nsAtom
>
thisLang
=
nsStyleFont
:
:
GetLanguage
(
this
)
;
GetDefaultFont
(
kPresContext_DefaultVariableFont_ID
thisLang
.
get
(
)
)
;
GetDefaultFont
(
kPresContext_DefaultVariableFont_ID
nsGkAtoms
:
:
x_math
)
;
GetDefaultFont
(
kPresContext_DefaultVariableFont_ID
nsGkAtoms
:
:
Unicode
)
;
for
(
auto
iter
=
mLanguagesUsed
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
GetDefaultFont
(
kPresContext_DefaultVariableFont_ID
iter
.
Get
(
)
-
>
GetKey
(
)
)
;
}
}
mFontGroupCacheDirty
=
false
;
}
void
nsPresContext
:
:
RebuildAllStyleData
(
nsChangeHint
aExtraHint
nsRestyleHint
aRestyleHint
)
{
if
(
!
mShell
)
{
return
;
}
mUsesRootEMUnits
=
false
;
mUsesExChUnits
=
false
;
if
(
nsStyleSet
*
styleSet
=
mShell
-
>
StyleSet
(
)
-
>
GetAsGecko
(
)
)
{
styleSet
-
>
SetUsesViewportUnits
(
false
)
;
}
mDocument
-
>
RebuildUserFontSet
(
)
;
RebuildCounterStyles
(
)
;
RebuildFontFeatureValues
(
)
;
RestyleManager
(
)
-
>
RebuildAllStyleData
(
aExtraHint
aRestyleHint
)
;
}
void
nsPresContext
:
:
PostRebuildAllStyleDataEvent
(
nsChangeHint
aExtraHint
nsRestyleHint
aRestyleHint
)
{
if
(
!
mShell
)
{
return
;
}
RestyleManager
(
)
-
>
PostRebuildAllStyleDataEvent
(
aExtraHint
aRestyleHint
)
;
}
struct
MediaFeatureHints
{
nsRestyleHint
restyleHint
;
nsChangeHint
changeHint
;
}
;
static
bool
MediaFeatureValuesChangedAllDocumentsCallback
(
nsIDocument
*
aDocument
void
*
aHints
)
{
MediaFeatureHints
*
hints
=
static_cast
<
MediaFeatureHints
*
>
(
aHints
)
;
if
(
nsIPresShell
*
shell
=
aDocument
-
>
GetShell
(
)
)
{
if
(
nsPresContext
*
pc
=
shell
-
>
GetPresContext
(
)
)
{
pc
-
>
MediaFeatureValuesChangedAllDocuments
(
hints
-
>
restyleHint
hints
-
>
changeHint
)
;
}
}
return
true
;
}
void
nsPresContext
:
:
MediaFeatureValuesChangedAllDocuments
(
nsRestyleHint
aRestyleHint
nsChangeHint
aChangeHint
)
{
MediaFeatureValuesChanged
(
aRestyleHint
aChangeHint
)
;
MediaFeatureHints
hints
=
{
aRestyleHint
aChangeHint
}
;
mDocument
-
>
EnumerateSubDocuments
(
MediaFeatureValuesChangedAllDocumentsCallback
&
hints
)
;
}
void
nsPresContext
:
:
MediaFeatureValuesChanged
(
nsRestyleHint
aRestyleHint
nsChangeHint
aChangeHint
)
{
mPendingMediaFeatureValuesChanged
=
false
;
if
(
mShell
)
{
aRestyleHint
|
=
mShell
-
>
StyleSet
(
)
-
>
MediumFeaturesChanged
(
mPendingViewportChange
)
;
}
if
(
aRestyleHint
|
|
aChangeHint
)
{
RebuildAllStyleData
(
aChangeHint
aRestyleHint
)
;
}
mPendingViewportChange
=
false
;
if
(
!
mShell
|
|
!
mShell
-
>
DidInitialize
(
)
)
{
return
;
}
if
(
mDocument
-
>
IsBeingUsedAsImage
(
)
)
{
MOZ_ASSERT
(
mDocument
-
>
MediaQueryLists
(
)
.
isEmpty
(
)
)
;
return
;
}
mDocument
-
>
NotifyMediaFeatureValuesChanged
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
;
if
(
!
mDocument
-
>
MediaQueryLists
(
)
.
isEmpty
(
)
)
{
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
MediaQueryList
>
>
localMediaQueryLists
;
for
(
auto
*
mql
:
mDocument
-
>
MediaQueryLists
(
)
)
{
localMediaQueryLists
.
AppendElement
(
mql
)
;
}
for
(
const
auto
&
mql
:
localMediaQueryLists
)
{
nsAutoMicroTask
mt
;
mql
-
>
MaybeNotify
(
)
;
}
}
}
void
nsPresContext
:
:
PostMediaFeatureValuesChangedEvent
(
)
{
if
(
!
mPendingMediaFeatureValuesChanged
&
&
mShell
)
{
nsCOMPtr
<
nsIRunnable
>
ev
=
NewRunnableMethod
(
"
nsPresContext
:
:
HandleMediaFeatureValuesChangedEvent
"
this
&
nsPresContext
:
:
HandleMediaFeatureValuesChangedEvent
)
;
nsresult
rv
=
Document
(
)
-
>
Dispatch
(
TaskCategory
:
:
Other
ev
.
forget
(
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mPendingMediaFeatureValuesChanged
=
true
;
mShell
-
>
SetNeedStyleFlush
(
)
;
}
}
}
void
nsPresContext
:
:
HandleMediaFeatureValuesChangedEvent
(
)
{
if
(
mPendingMediaFeatureValuesChanged
&
&
mShell
)
{
MediaFeatureValuesChanged
(
nsRestyleHint
(
0
)
)
;
}
}
static
bool
NotifyTabSizeModeChanged
(
TabParent
*
aTab
void
*
aArg
)
{
nsSizeMode
*
sizeMode
=
static_cast
<
nsSizeMode
*
>
(
aArg
)
;
aTab
-
>
SizeModeChanged
(
*
sizeMode
)
;
return
false
;
}
void
nsPresContext
:
:
SizeModeChanged
(
nsSizeMode
aSizeMode
)
{
if
(
HasCachedStyleData
(
)
)
{
nsContentUtils
:
:
CallOnAllRemoteChildren
(
mDocument
-
>
GetWindow
(
)
NotifyTabSizeModeChanged
&
aSizeMode
)
;
MediaFeatureValuesChangedAllDocuments
(
nsRestyleHint
(
0
)
)
;
}
}
nsCompatibility
nsPresContext
:
:
CompatibilityMode
(
)
const
{
return
Document
(
)
-
>
GetCompatibilityMode
(
)
;
}
void
nsPresContext
:
:
SetPaginatedScrolling
(
bool
aPaginated
)
{
if
(
mType
=
=
eContext_PrintPreview
|
|
mType
=
=
eContext_PageLayout
)
mCanPaginatedScroll
=
aPaginated
;
}
void
nsPresContext
:
:
SetPrintSettings
(
nsIPrintSettings
*
aPrintSettings
)
{
if
(
mMedium
=
=
nsGkAtoms
:
:
print
)
mPrintSettings
=
aPrintSettings
;
}
bool
nsPresContext
:
:
EnsureVisible
(
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
(
mContainer
)
;
if
(
docShell
)
{
nsCOMPtr
<
nsIContentViewer
>
cv
;
docShell
-
>
GetContentViewer
(
getter_AddRefs
(
cv
)
)
;
if
(
cv
)
{
RefPtr
<
nsPresContext
>
currentPresContext
;
cv
-
>
GetPresContext
(
getter_AddRefs
(
currentPresContext
)
)
;
if
(
currentPresContext
=
=
this
)
{
nsresult
result
=
cv
-
>
Show
(
)
;
if
(
NS_SUCCEEDED
(
result
)
)
{
return
true
;
}
}
}
}
return
false
;
}
#
ifdef
MOZ_REFLOW_PERF
void
nsPresContext
:
:
CountReflows
(
const
char
*
aName
nsIFrame
*
aFrame
)
{
if
(
mShell
)
{
mShell
-
>
CountReflows
(
aName
aFrame
)
;
}
}
#
endif
void
nsPresContext
:
:
UpdateIsChrome
(
)
{
mIsChrome
=
mContainer
&
&
nsIDocShellTreeItem
:
:
typeChrome
=
=
mContainer
-
>
ItemType
(
)
;
}
bool
nsPresContext
:
:
HasAuthorSpecifiedRules
(
const
nsIFrame
*
aFrame
uint32_t
aRuleTypeMask
)
const
{
if
(
auto
*
geckoStyleContext
=
aFrame
-
>
StyleContext
(
)
-
>
GetAsGecko
(
)
)
{
return
nsRuleNode
:
:
HasAuthorSpecifiedRules
(
geckoStyleContext
aRuleTypeMask
UseDocumentColors
(
)
)
;
}
Element
*
elem
=
aFrame
-
>
GetContent
(
)
-
>
AsElement
(
)
;
if
(
elem
-
>
GetPseudoElementType
(
)
!
=
CSSPseudoElementType
:
:
NotPseudo
)
{
MOZ_ASSERT
(
elem
-
>
GetParent
(
)
"
Pseudo
element
has
no
parent
element
?
"
)
;
elem
=
elem
-
>
GetParent
(
)
-
>
AsElement
(
)
;
}
if
(
MOZ_UNLIKELY
(
!
elem
-
>
HasServoData
(
)
)
)
{
return
false
;
}
nsStyleContext
*
styleContext
=
aFrame
-
>
StyleContext
(
)
;
CSSPseudoElementType
pseudoType
=
styleContext
-
>
GetPseudoType
(
)
;
if
(
pseudoType
=
=
CSSPseudoElementType
:
:
InheritingAnonBox
|
|
pseudoType
=
=
CSSPseudoElementType
:
:
NonInheritingAnonBox
)
{
return
false
;
}
return
Servo_HasAuthorSpecifiedRules
(
styleContext
-
>
AsServo
(
)
elem
pseudoType
aRuleTypeMask
UseDocumentColors
(
)
)
;
}
gfxUserFontSet
*
nsPresContext
:
:
GetUserFontSet
(
bool
aFlushUserFontSet
)
{
return
mDocument
-
>
GetUserFontSet
(
aFlushUserFontSet
)
;
}
void
nsPresContext
:
:
UserFontSetUpdated
(
gfxUserFontEntry
*
aUpdatedFont
)
{
if
(
!
mShell
)
return
;
if
(
!
aUpdatedFont
)
{
PostRebuildAllStyleDataEvent
(
NS_STYLE_HINT_REFLOW
eRestyle_ForceDescendants
)
;
return
;
}
if
(
UsesExChUnits
(
)
)
{
PostRebuildAllStyleDataEvent
(
nsChangeHint
(
0
)
eRestyle_ForceDescendants
)
;
}
nsIFrame
*
root
=
mShell
-
>
GetRootFrame
(
)
;
if
(
root
)
{
nsFontFaceUtils
:
:
MarkDirtyForFontChange
(
root
aUpdatedFont
)
;
}
}
class
CounterStyleCleaner
:
public
nsAPostRefreshObserver
{
public
:
CounterStyleCleaner
(
nsRefreshDriver
*
aRefreshDriver
CounterStyleManager
*
aCounterStyleManager
)
:
mRefreshDriver
(
aRefreshDriver
)
mCounterStyleManager
(
aCounterStyleManager
)
{
}
virtual
~
CounterStyleCleaner
(
)
{
}
void
DidRefresh
(
)
final
{
mRefreshDriver
-
>
RemovePostRefreshObserver
(
this
)
;
mCounterStyleManager
-
>
CleanRetiredStyles
(
)
;
delete
this
;
}
private
:
RefPtr
<
nsRefreshDriver
>
mRefreshDriver
;
RefPtr
<
CounterStyleManager
>
mCounterStyleManager
;
}
;
void
nsPresContext
:
:
FlushCounterStyles
(
)
{
if
(
!
mShell
)
{
return
;
}
if
(
mCounterStyleManager
-
>
IsInitial
(
)
)
{
return
;
}
if
(
mCounterStylesDirty
)
{
bool
changed
=
mCounterStyleManager
-
>
NotifyRuleChanged
(
)
;
if
(
changed
)
{
PresShell
(
)
-
>
NotifyCounterStylesAreDirty
(
)
;
PostRebuildAllStyleDataEvent
(
NS_STYLE_HINT_REFLOW
eRestyle_ForceDescendants
)
;
RefreshDriver
(
)
-
>
AddPostRefreshObserver
(
new
CounterStyleCleaner
(
RefreshDriver
(
)
mCounterStyleManager
)
)
;
}
mCounterStylesDirty
=
false
;
}
}
void
nsPresContext
:
:
RebuildCounterStyles
(
)
{
if
(
mCounterStyleManager
-
>
IsInitial
(
)
)
{
return
;
}
mCounterStylesDirty
=
true
;
if
(
mShell
)
{
mShell
-
>
SetNeedStyleFlush
(
)
;
}
if
(
!
mPostedFlushCounterStyles
)
{
nsCOMPtr
<
nsIRunnable
>
ev
=
NewRunnableMethod
(
"
nsPresContext
:
:
HandleRebuildCounterStyles
"
this
&
nsPresContext
:
:
HandleRebuildCounterStyles
)
;
nsresult
rv
=
Document
(
)
-
>
Dispatch
(
TaskCategory
:
:
Other
ev
.
forget
(
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mPostedFlushCounterStyles
=
true
;
}
}
}
void
nsPresContext
:
:
NotifyMissingFonts
(
)
{
if
(
mMissingFonts
)
{
mMissingFonts
-
>
Flush
(
)
;
}
}
void
nsPresContext
:
:
EnsureSafeToHandOutCSSRules
(
)
{
if
(
!
mShell
-
>
StyleSet
(
)
-
>
EnsureUniqueInnerOnCSSSheets
(
)
)
{
return
;
}
RebuildAllStyleData
(
nsChangeHint
(
0
)
eRestyle_Subtree
)
;
}
void
nsPresContext
:
:
FireDOMPaintEvent
(
nsTArray
<
nsRect
>
*
aList
uint64_t
aTransactionId
mozilla
:
:
TimeStamp
aTimeStamp
)
{
nsPIDOMWindowInner
*
ourWindow
=
mDocument
-
>
GetInnerWindow
(
)
;
if
(
!
ourWindow
)
return
;
nsCOMPtr
<
EventTarget
>
dispatchTarget
=
do_QueryInterface
(
ourWindow
)
;
nsCOMPtr
<
EventTarget
>
eventTarget
=
dispatchTarget
;
if
(
!
IsChrome
(
)
&
&
!
mSendAfterPaintToContent
)
{
dispatchTarget
=
do_QueryInterface
(
ourWindow
-
>
GetParentTarget
(
)
)
;
if
(
!
dispatchTarget
)
{
return
;
}
}
if
(
aTimeStamp
.
IsNull
(
)
)
{
aTimeStamp
=
mozilla
:
:
TimeStamp
:
:
Now
(
)
;
}
DOMHighResTimeStamp
timeStamp
=
0
;
if
(
ourWindow
)
{
mozilla
:
:
dom
:
:
Performance
*
perf
=
ourWindow
-
>
GetPerformance
(
)
;
if
(
perf
)
{
timeStamp
=
perf
-
>
GetDOMTiming
(
)
-
>
TimeStampToDOMHighRes
(
aTimeStamp
)
;
}
}
RefPtr
<
NotifyPaintEvent
>
event
=
NS_NewDOMNotifyPaintEvent
(
eventTarget
this
nullptr
eAfterPaint
aList
aTransactionId
timeStamp
)
;
event
-
>
SetTarget
(
eventTarget
)
;
event
-
>
SetTrusted
(
true
)
;
EventDispatcher
:
:
DispatchDOMEvent
(
dispatchTarget
nullptr
static_cast
<
Event
*
>
(
event
)
this
nullptr
)
;
}
static
bool
MayHavePaintEventListenerSubdocumentCallback
(
nsIDocument
*
aDocument
void
*
aData
)
{
bool
*
result
=
static_cast
<
bool
*
>
(
aData
)
;
nsIPresShell
*
shell
=
aDocument
-
>
GetShell
(
)
;
if
(
shell
)
{
nsPresContext
*
pc
=
shell
-
>
GetPresContext
(
)
;
if
(
pc
)
{
*
result
=
pc
-
>
MayHavePaintEventListenerInSubDocument
(
)
;
return
!
*
result
;
}
}
return
true
;
}
static
bool
MayHavePaintEventListener
(
nsPIDOMWindowInner
*
aInnerWindow
)
{
if
(
!
aInnerWindow
)
return
false
;
if
(
aInnerWindow
-
>
HasPaintEventListeners
(
)
)
return
true
;
EventTarget
*
parentTarget
=
aInnerWindow
-
>
GetParentTarget
(
)
;
if
(
!
parentTarget
)
return
false
;
EventListenerManager
*
manager
=
nullptr
;
if
(
(
manager
=
parentTarget
-
>
GetExistingListenerManager
(
)
)
&
&
manager
-
>
MayHavePaintEventListener
(
)
)
{
return
true
;
}
nsCOMPtr
<
nsINode
>
node
;
if
(
parentTarget
!
=
aInnerWindow
-
>
GetChromeEventHandler
(
)
)
{
nsCOMPtr
<
nsIInProcessContentFrameMessageManager
>
mm
=
do_QueryInterface
(
parentTarget
)
;
if
(
mm
)
{
node
=
mm
-
>
GetOwnerContent
(
)
;
}
}
if
(
!
node
)
{
node
=
do_QueryInterface
(
parentTarget
)
;
}
if
(
node
)
return
MayHavePaintEventListener
(
node
-
>
OwnerDoc
(
)
-
>
GetInnerWindow
(
)
)
;
nsCOMPtr
<
nsPIDOMWindowInner
>
window
=
do_QueryInterface
(
parentTarget
)
;
if
(
window
)
return
MayHavePaintEventListener
(
window
)
;
nsCOMPtr
<
nsPIWindowRoot
>
root
=
do_QueryInterface
(
parentTarget
)
;
EventTarget
*
tabChildGlobal
;
return
root
&
&
(
tabChildGlobal
=
root
-
>
GetParentTarget
(
)
)
&
&
(
manager
=
tabChildGlobal
-
>
GetExistingListenerManager
(
)
)
&
&
manager
-
>
MayHavePaintEventListener
(
)
;
}
bool
nsPresContext
:
:
MayHavePaintEventListener
(
)
{
return
:
:
MayHavePaintEventListener
(
mDocument
-
>
GetInnerWindow
(
)
)
;
}
bool
nsPresContext
:
:
MayHavePaintEventListenerInSubDocument
(
)
{
if
(
MayHavePaintEventListener
(
)
)
{
return
true
;
}
bool
result
=
false
;
mDocument
-
>
EnumerateSubDocuments
(
MayHavePaintEventListenerSubdocumentCallback
&
result
)
;
return
result
;
}
void
nsPresContext
:
:
NotifyInvalidation
(
uint64_t
aTransactionId
const
nsIntRect
&
aRect
)
{
nsIntRect
clampedRect
=
nsIntRect
:
:
MaxIntRect
(
)
;
clampedRect
.
ScaleInverseRoundIn
(
AppUnitsPerDevPixel
(
)
)
;
clampedRect
=
clampedRect
.
Intersect
(
aRect
)
;
nsRect
rect
(
DevPixelsToAppUnits
(
clampedRect
.
x
)
DevPixelsToAppUnits
(
clampedRect
.
y
)
DevPixelsToAppUnits
(
clampedRect
.
width
)
DevPixelsToAppUnits
(
clampedRect
.
height
)
)
;
NotifyInvalidation
(
aTransactionId
rect
)
;
}
void
nsPresContext
:
:
NotifyInvalidation
(
uint64_t
aTransactionId
const
nsRect
&
aRect
)
{
MOZ_ASSERT
(
GetContainerWeak
(
)
"
Invalidation
in
detached
pres
context
"
)
;
nsPresContext
*
pc
;
for
(
pc
=
this
;
pc
;
pc
=
pc
-
>
GetParentPresContext
(
)
)
{
if
(
pc
-
>
mFireAfterPaintEvents
)
break
;
pc
-
>
mFireAfterPaintEvents
=
true
;
}
if
(
!
pc
)
{
nsRootPresContext
*
rpc
=
GetRootPresContext
(
)
;
if
(
rpc
)
{
rpc
-
>
EnsureEventualDidPaintEvent
(
aTransactionId
)
;
}
}
TransactionInvalidations
*
transaction
=
nullptr
;
for
(
TransactionInvalidations
&
t
:
mTransactions
)
{
if
(
t
.
mTransactionId
=
=
aTransactionId
)
{
transaction
=
&
t
;
break
;
}
}
if
(
!
transaction
)
{
transaction
=
mTransactions
.
AppendElement
(
)
;
transaction
-
>
mTransactionId
=
aTransactionId
;
}
transaction
-
>
mInvalidations
.
AppendElement
(
aRect
)
;
}
void
nsPresContext
:
:
NotifySubDocInvalidation
(
ContainerLayer
*
aContainer
const
nsIntRegion
*
aRegion
)
{
ContainerLayerPresContext
*
data
=
static_cast
<
ContainerLayerPresContext
*
>
(
aContainer
-
>
GetUserData
(
&
gNotifySubDocInvalidationData
)
)
;
if
(
!
data
)
{
return
;
}
uint64_t
transactionId
=
aContainer
-
>
Manager
(
)
-
>
GetLastTransactionId
(
)
;
IntRect
visibleBounds
=
aContainer
-
>
GetVisibleRegion
(
)
.
GetBounds
(
)
.
ToUnknownRect
(
)
;
if
(
!
aRegion
)
{
IntRect
rect
(
IntPoint
(
0
0
)
visibleBounds
.
Size
(
)
)
;
data
-
>
mPresContext
-
>
NotifyInvalidation
(
transactionId
rect
)
;
return
;
}
nsIntPoint
topLeft
=
visibleBounds
.
TopLeft
(
)
;
for
(
auto
iter
=
aRegion
-
>
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsIntRect
rect
(
iter
.
Get
(
)
)
;
rect
.
MoveBy
(
-
topLeft
)
;
data
-
>
mPresContext
-
>
NotifyInvalidation
(
transactionId
rect
)
;
}
}
void
nsPresContext
:
:
SetNotifySubDocInvalidationData
(
ContainerLayer
*
aContainer
)
{
ContainerLayerPresContext
*
pres
=
new
ContainerLayerPresContext
;
pres
-
>
mPresContext
=
this
;
aContainer
-
>
SetUserData
(
&
gNotifySubDocInvalidationData
pres
)
;
}
void
nsPresContext
:
:
ClearNotifySubDocInvalidationData
(
ContainerLayer
*
aContainer
)
{
aContainer
-
>
SetUserData
(
&
gNotifySubDocInvalidationData
nullptr
)
;
}
struct
NotifyDidPaintSubdocumentCallbackClosure
{
uint64_t
mTransactionId
;
const
mozilla
:
:
TimeStamp
&
mTimeStamp
;
bool
mNeedsAnotherDidPaintNotification
;
}
;
bool
nsPresContext
:
:
NotifyDidPaintSubdocumentCallback
(
nsIDocument
*
aDocument
void
*
aData
)
{
NotifyDidPaintSubdocumentCallbackClosure
*
closure
=
static_cast
<
NotifyDidPaintSubdocumentCallbackClosure
*
>
(
aData
)
;
nsIPresShell
*
shell
=
aDocument
-
>
GetShell
(
)
;
if
(
shell
)
{
nsPresContext
*
pc
=
shell
-
>
GetPresContext
(
)
;
if
(
pc
)
{
pc
-
>
NotifyDidPaintForSubtree
(
closure
-
>
mTransactionId
closure
-
>
mTimeStamp
)
;
if
(
pc
-
>
mFireAfterPaintEvents
)
{
closure
-
>
mNeedsAnotherDidPaintNotification
=
true
;
}
}
}
return
true
;
}
class
DelayedFireDOMPaintEvent
:
public
Runnable
{
public
:
DelayedFireDOMPaintEvent
(
nsPresContext
*
aPresContext
nsTArray
<
nsRect
>
*
aList
uint64_t
aTransactionId
const
mozilla
:
:
TimeStamp
&
aTimeStamp
=
mozilla
:
:
TimeStamp
(
)
)
:
mozilla
:
:
Runnable
(
"
DelayedFireDOMPaintEvent
"
)
mPresContext
(
aPresContext
)
mTransactionId
(
aTransactionId
)
mTimeStamp
(
aTimeStamp
)
{
MOZ_ASSERT
(
mPresContext
-
>
GetContainerWeak
(
)
"
DOMPaintEvent
requested
for
a
detached
pres
context
"
)
;
mList
.
SwapElements
(
*
aList
)
;
}
NS_IMETHOD
Run
(
)
override
{
if
(
mPresContext
-
>
GetContainerWeak
(
)
)
{
mPresContext
-
>
FireDOMPaintEvent
(
&
mList
mTransactionId
mTimeStamp
)
;
}
return
NS_OK
;
}
RefPtr
<
nsPresContext
>
mPresContext
;
uint64_t
mTransactionId
;
const
mozilla
:
:
TimeStamp
mTimeStamp
;
nsTArray
<
nsRect
>
mList
;
}
;
void
nsPresContext
:
:
NotifyDidPaintForSubtree
(
uint64_t
aTransactionId
const
mozilla
:
:
TimeStamp
&
aTimeStamp
)
{
if
(
IsRoot
(
)
)
{
static_cast
<
nsRootPresContext
*
>
(
this
)
-
>
CancelDidPaintTimers
(
aTransactionId
)
;
if
(
!
mFireAfterPaintEvents
)
{
return
;
}
}
if
(
!
PresShell
(
)
-
>
IsVisible
(
)
&
&
!
mFireAfterPaintEvents
)
{
return
;
}
bool
sent
=
false
;
uint32_t
i
=
0
;
while
(
i
<
mTransactions
.
Length
(
)
)
{
if
(
mTransactions
[
i
]
.
mTransactionId
<
=
aTransactionId
)
{
nsCOMPtr
<
nsIRunnable
>
ev
=
new
DelayedFireDOMPaintEvent
(
this
&
mTransactions
[
i
]
.
mInvalidations
mTransactions
[
i
]
.
mTransactionId
aTimeStamp
)
;
nsContentUtils
:
:
AddScriptRunner
(
ev
)
;
sent
=
true
;
mTransactions
.
RemoveElementAt
(
i
)
;
}
else
{
i
+
+
;
}
}
if
(
!
sent
)
{
nsTArray
<
nsRect
>
dummy
;
nsCOMPtr
<
nsIRunnable
>
ev
=
new
DelayedFireDOMPaintEvent
(
this
&
dummy
aTransactionId
aTimeStamp
)
;
nsContentUtils
:
:
AddScriptRunner
(
ev
)
;
}
NotifyDidPaintSubdocumentCallbackClosure
closure
=
{
aTransactionId
aTimeStamp
false
}
;
mDocument
-
>
EnumerateSubDocuments
(
nsPresContext
:
:
NotifyDidPaintSubdocumentCallback
&
closure
)
;
if
(
!
closure
.
mNeedsAnotherDidPaintNotification
&
&
mTransactions
.
IsEmpty
(
)
)
{
mFireAfterPaintEvents
=
false
;
}
}
bool
nsPresContext
:
:
HasCachedStyleData
(
)
{
if
(
!
mShell
)
{
return
false
;
}
nsStyleSet
*
styleSet
=
mShell
-
>
StyleSet
(
)
-
>
GetAsGecko
(
)
;
if
(
!
styleSet
)
{
return
mShell
-
>
DidInitialize
(
)
;
}
return
styleSet
-
>
HasCachedStyleData
(
)
;
}
already_AddRefed
<
nsITimer
>
nsPresContext
:
:
CreateTimer
(
nsTimerCallbackFunc
aCallback
const
char
*
aName
uint32_t
aDelay
)
{
nsCOMPtr
<
nsITimer
>
timer
;
NS_NewTimerWithFuncCallback
(
getter_AddRefs
(
timer
)
aCallback
this
aDelay
nsITimer
:
:
TYPE_ONE_SHOT
aName
Document
(
)
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
)
;
return
timer
.
forget
(
)
;
}
static
bool
sGotInterruptEnv
=
false
;
enum
InterruptMode
{
ModeRandom
ModeCounter
ModeEvent
}
;
static
InterruptMode
sInterruptMode
=
ModeEvent
;
#
ifndef
XP_WIN
static
uint32_t
sInterruptSeed
=
1
;
#
endif
static
uint32_t
sInterruptMaxCounter
=
10
;
static
uint32_t
sInterruptCounter
;
static
uint32_t
sInterruptChecksToSkip
=
200
;
static
TimeDuration
sInterruptTimeout
;
static
void
GetInterruptEnv
(
)
{
char
*
ev
=
PR_GetEnv
(
"
GECKO_REFLOW_INTERRUPT_MODE
"
)
;
if
(
ev
)
{
#
ifndef
XP_WIN
if
(
PL_strcasecmp
(
ev
"
random
"
)
=
=
0
)
{
ev
=
PR_GetEnv
(
"
GECKO_REFLOW_INTERRUPT_SEED
"
)
;
if
(
ev
)
{
sInterruptSeed
=
atoi
(
ev
)
;
}
srandom
(
sInterruptSeed
)
;
sInterruptMode
=
ModeRandom
;
}
else
#
endif
if
(
PL_strcasecmp
(
ev
"
counter
"
)
=
=
0
)
{
ev
=
PR_GetEnv
(
"
GECKO_REFLOW_INTERRUPT_FREQUENCY
"
)
;
if
(
ev
)
{
sInterruptMaxCounter
=
atoi
(
ev
)
;
}
sInterruptCounter
=
0
;
sInterruptMode
=
ModeCounter
;
}
}
ev
=
PR_GetEnv
(
"
GECKO_REFLOW_INTERRUPT_CHECKS_TO_SKIP
"
)
;
if
(
ev
)
{
sInterruptChecksToSkip
=
atoi
(
ev
)
;
}
ev
=
PR_GetEnv
(
"
GECKO_REFLOW_MIN_NOINTERRUPT_DURATION
"
)
;
int
duration_ms
=
ev
?
atoi
(
ev
)
:
100
;
sInterruptTimeout
=
TimeDuration
:
:
FromMilliseconds
(
duration_ms
)
;
}
bool
nsPresContext
:
:
HavePendingInputEvent
(
)
{
switch
(
sInterruptMode
)
{
#
ifndef
XP_WIN
case
ModeRandom
:
return
(
random
(
)
&
1
)
;
#
endif
case
ModeCounter
:
if
(
sInterruptCounter
<
sInterruptMaxCounter
)
{
+
+
sInterruptCounter
;
return
false
;
}
sInterruptCounter
=
0
;
return
true
;
default
:
case
ModeEvent
:
{
nsIFrame
*
f
=
PresShell
(
)
-
>
GetRootFrame
(
)
;
if
(
f
)
{
nsIWidget
*
w
=
f
-
>
GetNearestWidget
(
)
;
if
(
w
)
{
return
w
-
>
HasPendingInputEvent
(
)
;
}
}
return
false
;
}
}
}
void
nsPresContext
:
:
NotifyFontFaceSetOnRefresh
(
)
{
FontFaceSet
*
set
=
mDocument
-
>
GetFonts
(
)
;
if
(
set
)
{
set
-
>
DidRefresh
(
)
;
}
}
bool
nsPresContext
:
:
HasPendingRestyleOrReflow
(
)
{
nsIPresShell
*
shell
=
PresShell
(
)
;
return
shell
-
>
NeedStyleFlush
(
)
|
|
shell
-
>
HasPendingReflow
(
)
;
}
void
nsPresContext
:
:
ReflowStarted
(
bool
aInterruptible
)
{
#
ifdef
NOISY_INTERRUPTIBLE_REFLOW
if
(
!
aInterruptible
)
{
printf
(
"
STARTING
NONINTERRUPTIBLE
REFLOW
\
n
"
)
;
}
#
endif
mInterruptsEnabled
=
aInterruptible
&
&
!
IsPaginated
(
)
&
&
nsLayoutUtils
:
:
InterruptibleReflowEnabled
(
)
;
mHasPendingInterrupt
=
false
;
mInterruptChecksToSkip
=
sInterruptChecksToSkip
;
if
(
mInterruptsEnabled
)
{
mReflowStartTime
=
TimeStamp
:
:
Now
(
)
;
}
}
bool
nsPresContext
:
:
CheckForInterrupt
(
nsIFrame
*
aFrame
)
{
if
(
mHasPendingInterrupt
)
{
mShell
-
>
FrameNeedsToContinueReflow
(
aFrame
)
;
return
true
;
}
if
(
!
sGotInterruptEnv
)
{
sGotInterruptEnv
=
true
;
GetInterruptEnv
(
)
;
}
if
(
!
mInterruptsEnabled
)
{
return
false
;
}
if
(
mInterruptChecksToSkip
>
0
)
{
-
-
mInterruptChecksToSkip
;
return
false
;
}
mInterruptChecksToSkip
=
sInterruptChecksToSkip
;
mHasPendingInterrupt
=
TimeStamp
:
:
Now
(
)
-
mReflowStartTime
>
sInterruptTimeout
&
&
HavePendingInputEvent
(
)
&
&
!
IsChrome
(
)
;
if
(
mPendingInterruptFromTest
)
{
mPendingInterruptFromTest
=
false
;
mHasPendingInterrupt
=
true
;
}
if
(
mHasPendingInterrupt
)
{
#
ifdef
NOISY_INTERRUPTIBLE_REFLOW
printf
(
"
*
*
*
DETECTED
pending
interrupt
(
time
=
%
lld
)
\
n
"
PR_Now
(
)
)
;
#
endif
mShell
-
>
FrameNeedsToContinueReflow
(
aFrame
)
;
}
return
mHasPendingInterrupt
;
}
nsIFrame
*
nsPresContext
:
:
GetPrimaryFrameFor
(
nsIContent
*
aContent
)
{
NS_PRECONDITION
(
aContent
"
Don
'
t
do
that
"
)
;
if
(
GetPresShell
(
)
&
&
GetPresShell
(
)
-
>
GetDocument
(
)
=
=
aContent
-
>
GetComposedDoc
(
)
)
{
return
aContent
-
>
GetPrimaryFrame
(
)
;
}
return
nullptr
;
}
size_t
nsPresContext
:
:
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
mLangGroupFontPrefs
.
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
bool
nsPresContext
:
:
IsRootContentDocument
(
)
const
{
if
(
mDocument
-
>
IsResourceDoc
(
)
)
{
return
false
;
}
if
(
IsChrome
(
)
)
{
return
false
;
}
nsView
*
view
=
PresShell
(
)
-
>
GetViewManager
(
)
-
>
GetRootView
(
)
;
if
(
!
view
)
{
return
false
;
}
view
=
view
-
>
GetParent
(
)
;
if
(
!
view
)
{
return
true
;
}
view
=
view
-
>
GetParent
(
)
;
if
(
!
view
)
{
return
true
;
}
nsIFrame
*
f
=
view
-
>
GetFrame
(
)
;
return
(
f
&
&
f
-
>
PresContext
(
)
-
>
IsChrome
(
)
)
;
}
void
nsPresContext
:
:
NotifyNonBlankPaint
(
)
{
MOZ_ASSERT
(
!
mHadNonBlankPaint
)
;
mHadNonBlankPaint
=
true
;
if
(
IsRootContentDocument
(
)
)
{
RefPtr
<
nsDOMNavigationTiming
>
timing
=
mDocument
-
>
GetNavigationTiming
(
)
;
if
(
timing
)
{
timing
-
>
NotifyNonBlankPaintForRootContentDocument
(
)
;
}
mFirstNonBlankPaintTime
=
TimeStamp
:
:
Now
(
)
;
}
}
bool
nsPresContext
:
:
GetPaintFlashing
(
)
const
{
if
(
!
mPaintFlashingInitialized
)
{
bool
pref
=
Preferences
:
:
GetBool
(
"
nglayout
.
debug
.
paint_flashing
"
)
;
if
(
!
pref
&
&
IsChrome
(
)
)
{
pref
=
Preferences
:
:
GetBool
(
"
nglayout
.
debug
.
paint_flashing_chrome
"
)
;
}
mPaintFlashing
=
pref
;
mPaintFlashingInitialized
=
true
;
}
return
mPaintFlashing
;
}
int32_t
nsPresContext
:
:
AppUnitsPerDevPixel
(
)
const
{
return
mDeviceContext
-
>
AppUnitsPerDevPixel
(
)
;
}
nscoord
nsPresContext
:
:
GfxUnitsToAppUnits
(
gfxFloat
aGfxUnits
)
const
{
return
mDeviceContext
-
>
GfxUnitsToAppUnits
(
aGfxUnits
)
;
}
gfxFloat
nsPresContext
:
:
AppUnitsToGfxUnits
(
nscoord
aAppUnits
)
const
{
return
mDeviceContext
-
>
AppUnitsToGfxUnits
(
aAppUnits
)
;
}
nscoord
nsPresContext
:
:
PhysicalMillimetersToAppUnits
(
float
aMM
)
const
{
float
inches
=
aMM
/
MM_PER_INCH_FLOAT
;
return
NSToCoordFloorClamped
(
inches
*
float
(
DeviceContext
(
)
-
>
AppUnitsPerPhysicalInch
(
)
)
)
;
}
bool
nsPresContext
:
:
IsDeviceSizePageSize
(
)
{
bool
isDeviceSizePageSize
=
false
;
nsCOMPtr
<
nsIDocShell
>
docShell
(
mContainer
)
;
if
(
docShell
)
{
isDeviceSizePageSize
=
docShell
-
>
GetDeviceSizeIsPageSize
(
)
;
}
return
isDeviceSizePageSize
;
}
uint64_t
nsPresContext
:
:
GetRestyleGeneration
(
)
const
{
if
(
!
mRestyleManager
)
{
return
0
;
}
return
mRestyleManager
-
>
GetRestyleGeneration
(
)
;
}
uint64_t
nsPresContext
:
:
GetUndisplayedRestyleGeneration
(
)
const
{
if
(
!
mRestyleManager
)
{
return
0
;
}
return
mRestyleManager
-
>
GetUndisplayedRestyleGeneration
(
)
;
}
nsBidi
&
nsPresContext
:
:
GetBidiEngine
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mBidiEngine
)
{
mBidiEngine
.
reset
(
new
nsBidi
(
)
)
;
}
return
*
mBidiEngine
;
}
void
nsPresContext
:
:
FlushFontFeatureValues
(
)
{
if
(
!
mShell
)
{
return
;
}
if
(
mFontFeatureValuesDirty
)
{
StyleSetHandle
styleSet
=
mShell
-
>
StyleSet
(
)
;
mFontFeatureValuesLookup
=
styleSet
-
>
BuildFontFeatureValueSet
(
)
;
mFontFeatureValuesDirty
=
false
;
}
}
void
nsPresContext
:
:
RebuildFontFeatureValues
(
)
{
if
(
!
mShell
)
{
return
;
}
mFontFeatureValuesDirty
=
true
;
mShell
-
>
SetNeedStyleFlush
(
)
;
if
(
!
mPostedFlushFontFeatureValues
)
{
nsCOMPtr
<
nsIRunnable
>
ev
=
NewRunnableMethod
(
"
nsPresContext
:
:
HandleRebuildFontFeatureValues
"
this
&
nsPresContext
:
:
HandleRebuildFontFeatureValues
)
;
nsresult
rv
=
Document
(
)
-
>
Dispatch
(
TaskCategory
:
:
Other
ev
.
forget
(
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mPostedFlushFontFeatureValues
=
true
;
}
}
}
nsRootPresContext
:
:
nsRootPresContext
(
nsIDocument
*
aDocument
nsPresContextType
aType
)
:
nsPresContext
(
aDocument
aType
)
mDOMGeneration
(
0
)
{
}
nsRootPresContext
:
:
~
nsRootPresContext
(
)
{
NS_ASSERTION
(
mRegisteredPlugins
.
Count
(
)
=
=
0
"
All
plugins
should
have
been
unregistered
"
)
;
CancelAllDidPaintTimers
(
)
;
CancelApplyPluginGeometryTimer
(
)
;
}
void
nsRootPresContext
:
:
Detach
(
)
{
CancelAllDidPaintTimers
(
)
;
nsPresContext
:
:
Detach
(
)
;
}
void
nsRootPresContext
:
:
RegisterPluginForGeometryUpdates
(
nsIContent
*
aPlugin
)
{
mRegisteredPlugins
.
PutEntry
(
aPlugin
)
;
}
void
nsRootPresContext
:
:
UnregisterPluginForGeometryUpdates
(
nsIContent
*
aPlugin
)
{
mRegisteredPlugins
.
RemoveEntry
(
aPlugin
)
;
}
void
nsRootPresContext
:
:
ComputePluginGeometryUpdates
(
nsIFrame
*
aFrame
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
)
{
if
(
mRegisteredPlugins
.
Count
(
)
=
=
0
)
{
return
;
}
for
(
auto
iter
=
mRegisteredPlugins
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
f
=
static_cast
<
nsPluginFrame
*
>
(
iter
.
Get
(
)
-
>
GetKey
(
)
-
>
GetPrimaryFrame
(
)
)
;
if
(
!
f
)
{
NS_WARNING
(
"
Null
frame
in
ComputePluginGeometryUpdates
"
)
;
continue
;
}
if
(
!
nsLayoutUtils
:
:
IsAncestorFrameCrossDoc
(
aFrame
f
)
)
{
continue
;
}
f
-
>
SetEmptyWidgetConfiguration
(
)
;
}
if
(
aBuilder
)
{
MOZ_ASSERT
(
aList
)
;
nsIFrame
*
rootFrame
=
FrameManager
(
)
-
>
GetRootFrame
(
)
;
if
(
rootFrame
&
&
aBuilder
-
>
ContainsPluginItem
(
)
)
{
aBuilder
-
>
SetForPluginGeometry
(
true
)
;
aBuilder
-
>
SetAllowMergingAndFlattening
(
false
)
;
nsRegion
region
=
rootFrame
-
>
GetVisualOverflowRectRelativeToSelf
(
)
;
aList
-
>
ComputeVisibilityForRoot
(
aBuilder
&
region
)
;
aBuilder
-
>
SetForPluginGeometry
(
false
)
;
}
}
#
ifdef
XP_MACOSX
ApplyPluginGeometryUpdates
(
)
;
#
else
if
(
XRE_IsParentProcess
(
)
)
{
InitApplyPluginGeometryTimer
(
)
;
}
#
endif
}
static
void
ApplyPluginGeometryUpdatesCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
{
static_cast
<
nsRootPresContext
*
>
(
aClosure
)
-
>
ApplyPluginGeometryUpdates
(
)
;
}
void
nsRootPresContext
:
:
InitApplyPluginGeometryTimer
(
)
{
if
(
mApplyPluginGeometryTimer
)
{
return
;
}
mApplyPluginGeometryTimer
=
CreateTimer
(
ApplyPluginGeometryUpdatesCallback
"
ApplyPluginGeometryUpdatesCallback
"
nsRefreshDriver
:
:
DefaultInterval
(
)
*
2
)
;
}
void
nsRootPresContext
:
:
CancelApplyPluginGeometryTimer
(
)
{
if
(
mApplyPluginGeometryTimer
)
{
mApplyPluginGeometryTimer
-
>
Cancel
(
)
;
mApplyPluginGeometryTimer
=
nullptr
;
}
}
#
ifndef
XP_MACOSX
static
bool
HasOverlap
(
const
LayoutDeviceIntPoint
&
aOffset1
const
nsTArray
<
LayoutDeviceIntRect
>
&
aClipRects1
const
LayoutDeviceIntPoint
&
aOffset2
const
nsTArray
<
LayoutDeviceIntRect
>
&
aClipRects2
)
{
LayoutDeviceIntPoint
offsetDelta
=
aOffset1
-
aOffset2
;
for
(
uint32_t
i
=
0
;
i
<
aClipRects1
.
Length
(
)
;
+
+
i
)
{
for
(
uint32_t
j
=
0
;
j
<
aClipRects2
.
Length
(
)
;
+
+
j
)
{
if
(
(
aClipRects1
[
i
]
+
offsetDelta
)
.
Intersects
(
aClipRects2
[
j
]
)
)
{
return
true
;
}
}
}
return
false
;
}
static
void
SortConfigurations
(
nsTArray
<
nsIWidget
:
:
Configuration
>
*
aConfigurations
)
{
if
(
aConfigurations
-
>
Length
(
)
>
10
)
{
return
;
}
nsTArray
<
nsIWidget
:
:
Configuration
>
pluginsToMove
;
pluginsToMove
.
SwapElements
(
*
aConfigurations
)
;
while
(
!
pluginsToMove
.
IsEmpty
(
)
)
{
uint32_t
i
;
for
(
i
=
0
;
i
+
1
<
pluginsToMove
.
Length
(
)
;
+
+
i
)
{
nsIWidget
:
:
Configuration
*
config
=
&
pluginsToMove
[
i
]
;
bool
foundOverlap
=
false
;
for
(
uint32_t
j
=
0
;
j
<
pluginsToMove
.
Length
(
)
;
+
+
j
)
{
if
(
i
=
=
j
)
continue
;
LayoutDeviceIntRect
bounds
=
pluginsToMove
[
j
]
.
mChild
-
>
GetBounds
(
)
;
AutoTArray
<
LayoutDeviceIntRect
1
>
clipRects
;
pluginsToMove
[
j
]
.
mChild
-
>
GetWindowClipRegion
(
&
clipRects
)
;
if
(
HasOverlap
(
bounds
.
TopLeft
(
)
clipRects
config
-
>
mBounds
.
TopLeft
(
)
config
-
>
mClipRegion
)
)
{
foundOverlap
=
true
;
break
;
}
}
if
(
!
foundOverlap
)
break
;
}
aConfigurations
-
>
AppendElement
(
pluginsToMove
[
i
]
)
;
pluginsToMove
.
RemoveElementAt
(
i
)
;
}
}
static
void
PluginGetGeometryUpdate
(
nsTHashtable
<
nsRefPtrHashKey
<
nsIContent
>
>
&
aPlugins
nsTArray
<
nsIWidget
:
:
Configuration
>
*
aConfigurations
)
{
for
(
auto
iter
=
aPlugins
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
f
=
static_cast
<
nsPluginFrame
*
>
(
iter
.
Get
(
)
-
>
GetKey
(
)
-
>
GetPrimaryFrame
(
)
)
;
if
(
!
f
)
{
NS_WARNING
(
"
Null
frame
in
PluginGeometryUpdate
"
)
;
continue
;
}
f
-
>
GetWidgetConfiguration
(
aConfigurations
)
;
}
}
#
endif
static
void
PluginDidSetGeometry
(
nsTHashtable
<
nsRefPtrHashKey
<
nsIContent
>
>
&
aPlugins
)
{
for
(
auto
iter
=
aPlugins
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
f
=
static_cast
<
nsPluginFrame
*
>
(
iter
.
Get
(
)
-
>
GetKey
(
)
-
>
GetPrimaryFrame
(
)
)
;
if
(
!
f
)
{
NS_WARNING
(
"
Null
frame
in
PluginDidSetGeometry
"
)
;
continue
;
}
f
-
>
DidSetWidgetGeometry
(
)
;
}
}
void
nsRootPresContext
:
:
ApplyPluginGeometryUpdates
(
)
{
#
ifndef
XP_MACOSX
CancelApplyPluginGeometryTimer
(
)
;
nsTArray
<
nsIWidget
:
:
Configuration
>
configurations
;
PluginGetGeometryUpdate
(
mRegisteredPlugins
&
configurations
)
;
if
(
!
configurations
.
IsEmpty
(
)
)
{
nsIWidget
*
widget
=
configurations
[
0
]
.
mChild
-
>
GetParent
(
)
;
NS_ASSERTION
(
widget
"
Plugins
must
have
a
parent
window
"
)
;
SortConfigurations
(
&
configurations
)
;
widget
-
>
ConfigureChildren
(
configurations
)
;
}
#
endif
PluginDidSetGeometry
(
mRegisteredPlugins
)
;
}
void
nsRootPresContext
:
:
CollectPluginGeometryUpdates
(
LayerManager
*
aLayerManager
)
{
#
ifndef
XP_MACOSX
NS_ASSERTION
(
aLayerManager
"
layer
manager
is
invalid
!
"
)
;
mozilla
:
:
layers
:
:
ClientLayerManager
*
clm
=
aLayerManager
-
>
AsClientLayerManager
(
)
;
nsTArray
<
nsIWidget
:
:
Configuration
>
configurations
;
if
(
!
mRegisteredPlugins
.
Count
(
)
&
&
clm
)
{
clm
-
>
StorePluginWidgetConfigurations
(
configurations
)
;
return
;
}
PluginGetGeometryUpdate
(
mRegisteredPlugins
&
configurations
)
;
if
(
configurations
.
IsEmpty
(
)
)
{
PluginDidSetGeometry
(
mRegisteredPlugins
)
;
return
;
}
SortConfigurations
(
&
configurations
)
;
if
(
clm
)
{
clm
-
>
StorePluginWidgetConfigurations
(
configurations
)
;
}
PluginDidSetGeometry
(
mRegisteredPlugins
)
;
#
endif
}
void
nsRootPresContext
:
:
EnsureEventualDidPaintEvent
(
uint64_t
aTransactionId
)
{
for
(
NotifyDidPaintTimer
&
t
:
mNotifyDidPaintTimers
)
{
if
(
t
.
mTransactionId
=
=
aTransactionId
)
{
return
;
}
}
nsCOMPtr
<
nsITimer
>
timer
;
RefPtr
<
nsRootPresContext
>
self
=
this
;
nsresult
rv
=
NS_NewTimerWithCallback
(
getter_AddRefs
(
timer
)
NewNamedTimerCallback
(
[
self
aTransactionId
]
(
)
{
nsAutoScriptBlocker
blockScripts
;
self
-
>
NotifyDidPaintForSubtree
(
aTransactionId
)
;
}
"
NotifyDidPaintForSubtree
"
)
100
nsITimer
:
:
TYPE_ONE_SHOT
Document
(
)
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
NotifyDidPaintTimer
*
t
=
mNotifyDidPaintTimers
.
AppendElement
(
)
;
t
-
>
mTransactionId
=
aTransactionId
;
t
-
>
mTimer
=
timer
;
}
}
void
nsRootPresContext
:
:
CancelDidPaintTimers
(
uint64_t
aTransactionId
)
{
uint32_t
i
=
0
;
while
(
i
<
mNotifyDidPaintTimers
.
Length
(
)
)
{
if
(
mNotifyDidPaintTimers
[
i
]
.
mTransactionId
<
=
aTransactionId
)
{
mNotifyDidPaintTimers
[
i
]
.
mTimer
-
>
Cancel
(
)
;
mNotifyDidPaintTimers
.
RemoveElementAt
(
i
)
;
}
else
{
i
+
+
;
}
}
}
void
nsRootPresContext
:
:
CancelAllDidPaintTimers
(
)
{
for
(
uint32_t
i
=
0
;
i
<
mNotifyDidPaintTimers
.
Length
(
)
;
i
+
+
)
{
mNotifyDidPaintTimers
[
i
]
.
mTimer
-
>
Cancel
(
)
;
}
mNotifyDidPaintTimers
.
Clear
(
)
;
}
void
nsRootPresContext
:
:
AddWillPaintObserver
(
nsIRunnable
*
aRunnable
)
{
if
(
!
mWillPaintFallbackEvent
.
IsPending
(
)
)
{
mWillPaintFallbackEvent
=
new
RunWillPaintObservers
(
this
)
;
Document
(
)
-
>
Dispatch
(
TaskCategory
:
:
Other
do_AddRef
(
mWillPaintFallbackEvent
)
)
;
}
mWillPaintObservers
.
AppendElement
(
aRunnable
)
;
}
void
nsRootPresContext
:
:
FlushWillPaintObservers
(
)
{
mWillPaintFallbackEvent
=
nullptr
;
nsTArray
<
nsCOMPtr
<
nsIRunnable
>
>
observers
;
observers
.
SwapElements
(
mWillPaintObservers
)
;
for
(
uint32_t
i
=
0
;
i
<
observers
.
Length
(
)
;
+
+
i
)
{
observers
[
i
]
-
>
Run
(
)
;
}
}
size_t
nsRootPresContext
:
:
SizeOfExcludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
return
nsPresContext
:
:
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
