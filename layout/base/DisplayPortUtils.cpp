#
include
"
DisplayPortUtils
.
h
"
#
include
"
FrameMetrics
.
h
"
#
include
"
Layers
.
h
"
#
include
"
mozilla
/
dom
/
BrowserChild
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
layers
/
APZCCallbackHelper
.
h
"
#
include
"
mozilla
/
layers
/
APZPublicUtils
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
LayersMessageUtils
.
h
"
#
include
"
mozilla
/
layers
/
PAPZ
.
h
"
#
include
"
mozilla
/
layers
/
RepaintRequest
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
StaticPrefs_layers
.
h
"
#
include
"
nsDeckFrame
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsPlaceholderFrame
.
h
"
#
include
"
nsSubDocumentFrame
.
h
"
#
include
"
RetainedDisplayListBuilder
.
h
"
#
include
"
WindowRenderer
.
h
"
#
include
<
ostream
>
namespace
mozilla
{
using
gfx
:
:
gfxVars
;
using
gfx
:
:
IntSize
;
using
layers
:
:
APZCCallbackHelper
;
using
layers
:
:
FrameMetrics
;
using
layers
:
:
LayerManager
;
using
layers
:
:
RepaintRequest
;
using
layers
:
:
ScrollableLayerGuid
;
typedef
ScrollableLayerGuid
:
:
ViewID
ViewID
;
static
LazyLogModule
sDisplayportLog
(
"
apz
.
displayport
"
)
;
DisplayPortMargins
DisplayPortMargins
:
:
FromAPZ
(
const
ScreenMargin
&
aMargins
const
CSSPoint
&
aVisualOffset
const
CSSPoint
&
aLayoutOffset
const
CSSToScreenScale2D
&
aScale
)
{
return
DisplayPortMargins
{
aMargins
aVisualOffset
aLayoutOffset
aScale
}
;
}
CSSToScreenScale2D
ComputeDisplayportScale
(
nsIScrollableFrame
*
aScrollFrame
)
{
if
(
!
aScrollFrame
)
{
return
CSSToScreenScale2D
(
1
.
0
1
.
0
)
;
}
nsIFrame
*
frame
=
do_QueryFrame
(
aScrollFrame
)
;
MOZ_ASSERT
(
frame
)
;
nsPresContext
*
presContext
=
frame
-
>
PresContext
(
)
;
PresShell
*
presShell
=
presContext
-
>
PresShell
(
)
;
return
presContext
-
>
CSSToDevPixelScale
(
)
*
LayoutDeviceToLayerScale
(
presShell
-
>
GetCumulativeResolution
(
)
)
*
LayerToParentLayerScale
(
1
.
0
)
*
nsLayoutUtils
:
:
GetTransformToAncestorScaleCrossProcessForFrameMetrics
(
frame
)
;
}
DisplayPortMargins
DisplayPortMargins
:
:
ForScrollFrame
(
nsIScrollableFrame
*
aScrollFrame
const
ScreenMargin
&
aMargins
const
Maybe
<
CSSToScreenScale2D
>
&
aScale
)
{
CSSPoint
visualOffset
;
CSSPoint
layoutOffset
;
if
(
aScrollFrame
)
{
nsIFrame
*
scrollFrame
=
do_QueryFrame
(
aScrollFrame
)
;
PresShell
*
presShell
=
scrollFrame
-
>
PresShell
(
)
;
layoutOffset
=
CSSPoint
:
:
FromAppUnits
(
aScrollFrame
-
>
GetScrollPosition
(
)
)
;
if
(
aScrollFrame
-
>
IsRootScrollFrameOfDocument
(
)
&
&
presShell
-
>
IsVisualViewportOffsetSet
(
)
)
{
visualOffset
=
CSSPoint
:
:
FromAppUnits
(
presShell
-
>
GetVisualViewportOffset
(
)
)
;
}
else
{
visualOffset
=
layoutOffset
;
}
}
return
DisplayPortMargins
{
aMargins
visualOffset
layoutOffset
aScale
.
valueOrFrom
(
[
&
]
{
return
ComputeDisplayportScale
(
aScrollFrame
)
;
}
)
}
;
}
DisplayPortMargins
DisplayPortMargins
:
:
ForContent
(
nsIContent
*
aContent
const
ScreenMargin
&
aMargins
)
{
return
ForScrollFrame
(
aContent
?
nsLayoutUtils
:
:
FindScrollableFrameFor
(
aContent
)
:
nullptr
aMargins
Nothing
(
)
)
;
}
ScreenMargin
DisplayPortMargins
:
:
GetRelativeToLayoutViewport
(
ContentGeometryType
aGeometryType
nsIScrollableFrame
*
aScrollableFrame
)
const
{
CSSPoint
scrollDeltaCss
=
ComputeAsyncTranslation
(
aGeometryType
aScrollableFrame
)
;
ScreenPoint
scrollDelta
=
scrollDeltaCss
*
mScale
;
ScreenMargin
margins
=
mMargins
;
margins
.
left
-
=
scrollDelta
.
x
;
margins
.
right
+
=
scrollDelta
.
x
;
margins
.
top
-
=
scrollDelta
.
y
;
margins
.
bottom
+
=
scrollDelta
.
y
;
return
margins
;
}
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aOs
const
DisplayPortMargins
&
aMargins
)
{
if
(
aMargins
.
mVisualOffset
=
=
CSSPoint
(
)
&
&
aMargins
.
mLayoutOffset
=
=
CSSPoint
(
)
)
{
aOs
<
<
aMargins
.
mMargins
;
}
else
{
aOs
<
<
"
{
"
<
<
aMargins
.
mMargins
<
<
"
"
<
<
aMargins
.
mVisualOffset
<
<
"
"
<
<
aMargins
.
mLayoutOffset
<
<
"
}
"
;
}
return
aOs
;
}
CSSPoint
DisplayPortMargins
:
:
ComputeAsyncTranslation
(
ContentGeometryType
aGeometryType
nsIScrollableFrame
*
aScrollableFrame
)
const
{
if
(
aGeometryType
=
=
ContentGeometryType
:
:
Scrolled
)
{
return
mVisualOffset
-
mLayoutOffset
;
}
if
(
!
aScrollableFrame
)
{
return
CSSPoint
(
)
;
}
MOZ_ASSERT
(
aScrollableFrame
-
>
IsRootScrollFrameOfDocument
(
)
)
;
nsIFrame
*
scrollFrame
=
do_QueryFrame
(
aScrollableFrame
)
;
if
(
!
scrollFrame
-
>
PresShell
(
)
-
>
IsVisualViewportSizeSet
(
)
)
{
return
CSSPoint
(
)
;
}
const
CSSRect
visualViewport
{
mVisualOffset
CSSSize
:
:
FromAppUnits
(
scrollFrame
-
>
PresShell
(
)
-
>
GetVisualViewportSize
(
)
)
}
;
const
CSSRect
scrollableRect
=
CSSRect
:
:
FromAppUnits
(
nsLayoutUtils
:
:
CalculateExpandedScrollableRect
(
scrollFrame
)
)
;
CSSRect
asyncLayoutViewport
{
mLayoutOffset
CSSSize
:
:
FromAppUnits
(
aScrollableFrame
-
>
GetScrollPortRect
(
)
.
Size
(
)
)
}
;
FrameMetrics
:
:
KeepLayoutViewportEnclosingVisualViewport
(
visualViewport
scrollableRect
asyncLayoutViewport
)
;
return
mVisualOffset
-
asyncLayoutViewport
.
TopLeft
(
)
;
}
static
nsRect
ApplyRectMultiplier
(
nsRect
aRect
float
aMultiplier
)
{
if
(
aMultiplier
=
=
1
.
0f
)
{
return
aRect
;
}
float
newWidth
=
aRect
.
width
*
aMultiplier
;
float
newHeight
=
aRect
.
height
*
aMultiplier
;
float
newX
=
aRect
.
x
-
(
(
newWidth
-
aRect
.
width
)
/
2
.
0f
)
;
float
newY
=
aRect
.
y
-
(
(
newHeight
-
aRect
.
height
)
/
2
.
0f
)
;
return
nsRect
(
ceil
(
newX
)
ceil
(
newY
)
floor
(
newWidth
)
floor
(
newHeight
)
)
;
}
static
nsRect
GetDisplayPortFromRectData
(
nsIContent
*
aContent
DisplayPortPropertyData
*
aRectData
float
aMultiplier
)
{
return
ApplyRectMultiplier
(
aRectData
-
>
mRect
aMultiplier
)
;
}
static
nsRect
GetDisplayPortFromMarginsData
(
nsIContent
*
aContent
DisplayPortMarginsPropertyData
*
aMarginsData
float
aMultiplier
const
DisplayPortOptions
&
aOptions
)
{
nsRect
base
;
if
(
nsRect
*
baseData
=
static_cast
<
nsRect
*
>
(
aContent
-
>
GetProperty
(
nsGkAtoms
:
:
DisplayPortBase
)
)
)
{
base
=
*
baseData
;
}
else
{
}
nsIFrame
*
frame
=
nsLayoutUtils
:
:
GetScrollFrameFromContent
(
aContent
)
;
if
(
!
frame
)
{
NS_WARNING
(
"
Attempting
to
get
a
displayport
from
a
content
with
no
primary
"
"
frame
!
"
)
;
return
base
;
}
bool
isRoot
=
false
;
if
(
aContent
-
>
OwnerDoc
(
)
-
>
GetRootElement
(
)
=
=
aContent
)
{
isRoot
=
true
;
}
nsIScrollableFrame
*
scrollableFrame
=
frame
-
>
GetScrollTargetFrame
(
)
;
nsPoint
scrollPos
;
if
(
scrollableFrame
)
{
scrollPos
=
scrollableFrame
-
>
GetScrollPosition
(
)
;
}
nsPresContext
*
presContext
=
frame
-
>
PresContext
(
)
;
int32_t
auPerDevPixel
=
presContext
-
>
AppUnitsPerDevPixel
(
)
;
LayoutDeviceToScreenScale2D
res
=
LayoutDeviceToParentLayerScale
(
presContext
-
>
PresShell
(
)
-
>
GetCumulativeResolution
(
)
)
*
nsLayoutUtils
:
:
GetTransformToAncestorScaleCrossProcessForFrameMetrics
(
frame
)
;
nsRect
expandedScrollableRect
=
nsLayoutUtils
:
:
CalculateExpandedScrollableRect
(
frame
)
;
if
(
res
=
=
LayoutDeviceToScreenScale2D
(
0
0
)
)
{
return
base
.
MoveInsideAndClamp
(
expandedScrollableRect
-
scrollPos
)
;
}
LayoutDeviceToScreenScale2D
parentRes
=
res
;
if
(
isRoot
)
{
float
localRes
=
presContext
-
>
PresShell
(
)
-
>
GetResolution
(
)
;
parentRes
.
xScale
/
=
localRes
;
parentRes
.
yScale
/
=
localRes
;
}
ScreenRect
screenRect
=
LayoutDeviceRect
:
:
FromAppUnits
(
base
auPerDevPixel
)
*
parentRes
;
ScreenSize
alignment
;
PresShell
*
presShell
=
presContext
-
>
PresShell
(
)
;
MOZ_ASSERT
(
presShell
)
;
ScreenMargin
margins
=
aMarginsData
-
>
mMargins
.
GetRelativeToLayoutViewport
(
aOptions
.
mGeometryType
scrollableFrame
)
;
if
(
presShell
-
>
IsDisplayportSuppressed
(
)
|
|
aContent
-
>
GetProperty
(
nsGkAtoms
:
:
MinimalDisplayPort
)
)
{
alignment
=
ScreenSize
(
1
1
)
;
}
else
{
IntSize
multiplier
=
layers
:
:
apz
:
:
GetDisplayportAlignmentMultiplier
(
screenRect
.
Size
(
)
)
;
alignment
=
ScreenSize
(
128
*
multiplier
.
width
128
*
multiplier
.
height
)
;
}
if
(
alignment
.
width
=
=
0
)
{
alignment
.
width
=
128
;
}
if
(
alignment
.
height
=
=
0
)
{
alignment
.
height
=
128
;
}
screenRect
.
Inflate
(
margins
)
;
ScreenPoint
scrollPosScreen
=
LayoutDevicePoint
:
:
FromAppUnits
(
scrollPos
auPerDevPixel
)
*
res
;
screenRect
+
=
scrollPosScreen
;
float
x
=
alignment
.
width
*
floor
(
screenRect
.
x
/
alignment
.
width
)
;
float
y
=
alignment
.
height
*
floor
(
screenRect
.
y
/
alignment
.
height
)
;
float
w
=
alignment
.
width
*
ceil
(
screenRect
.
width
/
alignment
.
width
+
1
)
;
float
h
=
alignment
.
height
*
ceil
(
screenRect
.
height
/
alignment
.
height
+
1
)
;
screenRect
=
ScreenRect
(
x
y
w
h
)
;
screenRect
-
=
scrollPosScreen
;
nsRect
result
=
LayoutDeviceRect
:
:
ToAppUnits
(
screenRect
/
res
auPerDevPixel
)
;
if
(
margins
!
=
ScreenMargin
(
)
)
{
result
=
ApplyRectMultiplier
(
result
aMultiplier
)
;
}
result
=
result
.
MoveInsideAndClamp
(
expandedScrollableRect
-
scrollPos
)
;
return
result
;
}
static
bool
GetDisplayPortData
(
nsIContent
*
aContent
DisplayPortPropertyData
*
*
aOutRectData
DisplayPortMarginsPropertyData
*
*
aOutMarginsData
)
{
MOZ_ASSERT
(
aOutRectData
&
&
aOutMarginsData
)
;
*
aOutRectData
=
static_cast
<
DisplayPortPropertyData
*
>
(
aContent
-
>
GetProperty
(
nsGkAtoms
:
:
DisplayPort
)
)
;
*
aOutMarginsData
=
static_cast
<
DisplayPortMarginsPropertyData
*
>
(
aContent
-
>
GetProperty
(
nsGkAtoms
:
:
DisplayPortMargins
)
)
;
if
(
!
*
aOutRectData
&
&
!
*
aOutMarginsData
)
{
return
false
;
}
if
(
*
aOutRectData
&
&
*
aOutMarginsData
)
{
if
(
(
*
aOutRectData
)
-
>
mPriority
>
(
*
aOutMarginsData
)
-
>
mPriority
)
{
*
aOutMarginsData
=
nullptr
;
}
else
{
*
aOutRectData
=
nullptr
;
}
}
NS_ASSERTION
(
(
*
aOutRectData
=
=
nullptr
)
!
=
(
*
aOutMarginsData
=
=
nullptr
)
"
Only
one
of
aOutRectData
or
aOutMarginsData
should
be
set
!
"
)
;
return
true
;
}
static
bool
GetWasDisplayPortPainted
(
nsIContent
*
aContent
)
{
DisplayPortPropertyData
*
rectData
=
nullptr
;
DisplayPortMarginsPropertyData
*
marginsData
=
nullptr
;
if
(
!
GetDisplayPortData
(
aContent
&
rectData
&
marginsData
)
)
{
return
false
;
}
return
rectData
?
rectData
-
>
mPainted
:
marginsData
-
>
mPainted
;
}
bool
DisplayPortUtils
:
:
IsMissingDisplayPortBaseRect
(
nsIContent
*
aContent
)
{
DisplayPortPropertyData
*
rectData
=
nullptr
;
DisplayPortMarginsPropertyData
*
marginsData
=
nullptr
;
if
(
GetDisplayPortData
(
aContent
&
rectData
&
marginsData
)
&
&
marginsData
)
{
return
!
aContent
-
>
GetProperty
(
nsGkAtoms
:
:
DisplayPortBase
)
;
}
return
false
;
}
static
void
TranslateFromScrollPortToScrollFrame
(
nsIContent
*
aContent
nsRect
*
aRect
)
{
MOZ_ASSERT
(
aRect
)
;
if
(
nsIScrollableFrame
*
scrollableFrame
=
nsLayoutUtils
:
:
FindScrollableFrameFor
(
aContent
)
)
{
*
aRect
+
=
scrollableFrame
-
>
GetScrollPortRect
(
)
.
TopLeft
(
)
;
}
}
static
bool
GetDisplayPortImpl
(
nsIContent
*
aContent
nsRect
*
aResult
float
aMultiplier
const
DisplayPortOptions
&
aOptions
)
{
DisplayPortPropertyData
*
rectData
=
nullptr
;
DisplayPortMarginsPropertyData
*
marginsData
=
nullptr
;
if
(
!
GetDisplayPortData
(
aContent
&
rectData
&
marginsData
)
)
{
return
false
;
}
nsIFrame
*
frame
=
aContent
-
>
GetPrimaryFrame
(
)
;
if
(
frame
&
&
!
frame
-
>
PresShell
(
)
-
>
AsyncPanZoomEnabled
(
)
)
{
return
false
;
}
if
(
!
aResult
)
{
return
true
;
}
bool
isDisplayportSuppressed
=
false
;
if
(
frame
)
{
nsPresContext
*
presContext
=
frame
-
>
PresContext
(
)
;
MOZ_ASSERT
(
presContext
)
;
PresShell
*
presShell
=
presContext
-
>
PresShell
(
)
;
MOZ_ASSERT
(
presShell
)
;
isDisplayportSuppressed
=
presShell
-
>
IsDisplayportSuppressed
(
)
;
}
nsRect
result
;
if
(
rectData
)
{
result
=
GetDisplayPortFromRectData
(
aContent
rectData
aMultiplier
)
;
}
else
if
(
isDisplayportSuppressed
|
|
nsLayoutUtils
:
:
ShouldDisableApzForElement
(
aContent
)
|
|
aContent
-
>
GetProperty
(
nsGkAtoms
:
:
MinimalDisplayPort
)
)
{
DisplayPortMarginsPropertyData
noMargins
=
*
marginsData
;
noMargins
.
mMargins
.
mMargins
=
ScreenMargin
(
)
;
result
=
GetDisplayPortFromMarginsData
(
aContent
&
noMargins
aMultiplier
aOptions
)
;
}
else
{
result
=
GetDisplayPortFromMarginsData
(
aContent
marginsData
aMultiplier
aOptions
)
;
}
if
(
aOptions
.
mRelativeTo
=
=
DisplayportRelativeTo
:
:
ScrollFrame
)
{
TranslateFromScrollPortToScrollFrame
(
aContent
&
result
)
;
}
*
aResult
=
result
;
return
true
;
}
bool
DisplayPortUtils
:
:
GetDisplayPort
(
nsIContent
*
aContent
nsRect
*
aResult
const
DisplayPortOptions
&
aOptions
)
{
float
multiplier
=
StaticPrefs
:
:
layers_low_precision_buffer
(
)
?
1
.
0f
/
StaticPrefs
:
:
layers_low_precision_resolution
(
)
:
1
.
0f
;
return
GetDisplayPortImpl
(
aContent
aResult
multiplier
aOptions
)
;
}
bool
DisplayPortUtils
:
:
HasDisplayPort
(
nsIContent
*
aContent
)
{
return
GetDisplayPort
(
aContent
nullptr
)
;
}
bool
DisplayPortUtils
:
:
HasPaintedDisplayPort
(
nsIContent
*
aContent
)
{
DisplayPortPropertyData
*
rectData
=
nullptr
;
DisplayPortMarginsPropertyData
*
marginsData
=
nullptr
;
GetDisplayPortData
(
aContent
&
rectData
&
marginsData
)
;
if
(
rectData
)
{
return
rectData
-
>
mPainted
;
}
if
(
marginsData
)
{
return
marginsData
-
>
mPainted
;
}
return
false
;
}
void
DisplayPortUtils
:
:
MarkDisplayPortAsPainted
(
nsIContent
*
aContent
)
{
DisplayPortPropertyData
*
rectData
=
nullptr
;
DisplayPortMarginsPropertyData
*
marginsData
=
nullptr
;
GetDisplayPortData
(
aContent
&
rectData
&
marginsData
)
;
MOZ_ASSERT
(
rectData
|
|
marginsData
"
MarkDisplayPortAsPainted
should
only
be
called
for
an
element
"
"
with
a
displayport
"
)
;
if
(
rectData
)
{
rectData
-
>
mPainted
=
true
;
}
if
(
marginsData
)
{
marginsData
-
>
mPainted
=
true
;
}
}
bool
DisplayPortUtils
:
:
HasNonMinimalDisplayPort
(
nsIContent
*
aContent
)
{
return
HasDisplayPort
(
aContent
)
&
&
!
aContent
-
>
GetProperty
(
nsGkAtoms
:
:
MinimalDisplayPort
)
;
}
bool
DisplayPortUtils
:
:
HasNonMinimalNonZeroDisplayPort
(
nsIContent
*
aContent
)
{
if
(
!
HasDisplayPort
(
aContent
)
)
{
return
false
;
}
if
(
aContent
-
>
GetProperty
(
nsGkAtoms
:
:
MinimalDisplayPort
)
)
{
return
false
;
}
DisplayPortMarginsPropertyData
*
currentData
=
static_cast
<
DisplayPortMarginsPropertyData
*
>
(
aContent
-
>
GetProperty
(
nsGkAtoms
:
:
DisplayPortMargins
)
)
;
if
(
!
currentData
)
{
return
true
;
}
if
(
currentData
-
>
mMargins
.
mMargins
!
=
ScreenMargin
(
)
)
{
return
true
;
}
return
false
;
}
bool
DisplayPortUtils
:
:
GetDisplayPortForVisibilityTesting
(
nsIContent
*
aContent
nsRect
*
aResult
)
{
MOZ_ASSERT
(
aResult
)
;
return
GetDisplayPortImpl
(
aContent
aResult
1
.
0f
DisplayPortOptions
(
)
.
With
(
DisplayportRelativeTo
:
:
ScrollFrame
)
)
;
}
void
DisplayPortUtils
:
:
InvalidateForDisplayPortChange
(
nsIContent
*
aContent
bool
aHadDisplayPort
const
nsRect
&
aOldDisplayPort
const
nsRect
&
aNewDisplayPort
RepaintMode
aRepaintMode
)
{
if
(
aRepaintMode
!
=
RepaintMode
:
:
Repaint
)
{
return
;
}
bool
changed
=
!
aHadDisplayPort
|
|
!
aOldDisplayPort
.
IsEqualEdges
(
aNewDisplayPort
)
;
nsIFrame
*
frame
=
nsLayoutUtils
:
:
GetScrollFrameFromContent
(
aContent
)
;
if
(
frame
)
{
frame
=
do_QueryFrame
(
frame
-
>
GetScrollTargetFrame
(
)
)
;
}
if
(
changed
&
&
frame
)
{
frame
-
>
SchedulePaint
(
)
;
if
(
!
nsLayoutUtils
:
:
AreRetainedDisplayListsEnabled
(
)
|
|
!
nsLayoutUtils
:
:
DisplayRootHasRetainedDisplayListBuilder
(
frame
)
)
{
return
;
}
bool
found
;
nsRect
*
rect
=
frame
-
>
GetProperty
(
nsDisplayListBuilder
:
:
DisplayListBuildingDisplayPortRect
(
)
&
found
)
;
if
(
!
found
)
{
rect
=
new
nsRect
(
)
;
frame
-
>
AddProperty
(
nsDisplayListBuilder
:
:
DisplayListBuildingDisplayPortRect
(
)
rect
)
;
frame
-
>
SetHasOverrideDirtyRegion
(
true
)
;
nsIFrame
*
rootFrame
=
frame
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
;
MOZ_ASSERT
(
rootFrame
)
;
RetainedDisplayListData
*
data
=
GetOrSetRetainedDisplayListData
(
rootFrame
)
;
data
-
>
Flags
(
frame
)
+
=
RetainedDisplayListData
:
:
FrameFlag
:
:
HasProps
;
}
else
{
MOZ_ASSERT
(
rect
"
this
property
should
only
store
non
-
null
values
"
)
;
}
if
(
aHadDisplayPort
)
{
nsRegion
newRegion
(
aNewDisplayPort
)
;
newRegion
.
SubOut
(
aOldDisplayPort
)
;
rect
-
>
UnionRect
(
*
rect
newRegion
.
GetBounds
(
)
)
;
}
else
{
rect
-
>
UnionRect
(
*
rect
aNewDisplayPort
)
;
}
}
}
bool
DisplayPortUtils
:
:
SetDisplayPortMargins
(
nsIContent
*
aContent
PresShell
*
aPresShell
const
DisplayPortMargins
&
aMargins
ClearMinimalDisplayPortProperty
aClearMinimalDisplayPortProperty
uint32_t
aPriority
RepaintMode
aRepaintMode
)
{
MOZ_ASSERT
(
aContent
)
;
MOZ_ASSERT
(
aContent
-
>
GetComposedDoc
(
)
=
=
aPresShell
-
>
GetDocument
(
)
)
;
DisplayPortMarginsPropertyData
*
currentData
=
static_cast
<
DisplayPortMarginsPropertyData
*
>
(
aContent
-
>
GetProperty
(
nsGkAtoms
:
:
DisplayPortMargins
)
)
;
if
(
currentData
&
&
currentData
-
>
mPriority
>
aPriority
)
{
return
false
;
}
if
(
currentData
&
&
currentData
-
>
mMargins
.
mVisualOffset
!
=
CSSPoint
(
)
&
&
aMargins
.
mVisualOffset
=
=
CSSPoint
(
)
)
{
MOZ_LOG
(
sDisplayportLog
LogLevel
:
:
Warning
(
"
Dropping
visual
offset
%
s
"
ToString
(
currentData
-
>
mMargins
.
mVisualOffset
)
.
c_str
(
)
)
)
;
}
nsIFrame
*
scrollFrame
=
nsLayoutUtils
:
:
GetScrollFrameFromContent
(
aContent
)
;
nsRect
oldDisplayPort
;
bool
hadDisplayPort
=
false
;
bool
wasPainted
=
GetWasDisplayPortPainted
(
aContent
)
;
if
(
scrollFrame
)
{
hadDisplayPort
=
GetDisplayPort
(
aContent
&
oldDisplayPort
)
;
}
aContent
-
>
SetProperty
(
nsGkAtoms
:
:
DisplayPortMargins
new
DisplayPortMarginsPropertyData
(
aMargins
aPriority
wasPainted
)
nsINode
:
:
DeleteProperty
<
DisplayPortMarginsPropertyData
>
)
;
if
(
aClearMinimalDisplayPortProperty
=
=
ClearMinimalDisplayPortProperty
:
:
Yes
)
{
if
(
MOZ_LOG_TEST
(
sDisplayportLog
LogLevel
:
:
Debug
)
&
&
aContent
-
>
GetProperty
(
nsGkAtoms
:
:
MinimalDisplayPort
)
)
{
mozilla
:
:
layers
:
:
ScrollableLayerGuid
:
:
ViewID
viewID
=
mozilla
:
:
layers
:
:
ScrollableLayerGuid
:
:
NULL_SCROLL_ID
;
nsLayoutUtils
:
:
FindIDFor
(
aContent
&
viewID
)
;
MOZ_LOG
(
sDisplayportLog
LogLevel
:
:
Debug
(
"
SetDisplayPortMargins
removing
MinimalDisplayPort
prop
on
"
"
scrollId
=
%
"
PRIu64
"
\
n
"
viewID
)
)
;
}
aContent
-
>
RemoveProperty
(
nsGkAtoms
:
:
MinimalDisplayPort
)
;
}
nsIScrollableFrame
*
scrollableFrame
=
scrollFrame
?
scrollFrame
-
>
GetScrollTargetFrame
(
)
:
nullptr
;
if
(
!
scrollableFrame
)
{
return
true
;
}
nsRect
newDisplayPort
;
DebugOnly
<
bool
>
hasDisplayPort
=
GetDisplayPort
(
aContent
&
newDisplayPort
)
;
MOZ_ASSERT
(
hasDisplayPort
)
;
if
(
MOZ_LOG_TEST
(
sDisplayportLog
LogLevel
:
:
Debug
)
)
{
mozilla
:
:
layers
:
:
ScrollableLayerGuid
:
:
ViewID
viewID
=
mozilla
:
:
layers
:
:
ScrollableLayerGuid
:
:
NULL_SCROLL_ID
;
nsLayoutUtils
:
:
FindIDFor
(
aContent
&
viewID
)
;
if
(
!
hadDisplayPort
)
{
MOZ_LOG
(
sDisplayportLog
LogLevel
:
:
Debug
(
"
SetDisplayPortMargins
%
s
on
scrollId
=
%
"
PRIu64
"
newDp
=
%
s
\
n
"
ToString
(
aMargins
)
.
c_str
(
)
viewID
ToString
(
newDisplayPort
)
.
c_str
(
)
)
)
;
}
else
{
MOZ_LOG
(
sDisplayportLog
LogLevel
:
:
Verbose
(
"
SetDisplayPortMargins
%
s
on
scrollId
=
%
"
PRIu64
"
newDp
=
%
s
\
n
"
ToString
(
aMargins
)
.
c_str
(
)
viewID
ToString
(
newDisplayPort
)
.
c_str
(
)
)
)
;
}
}
InvalidateForDisplayPortChange
(
aContent
hadDisplayPort
oldDisplayPort
newDisplayPort
aRepaintMode
)
;
scrollableFrame
-
>
TriggerDisplayPortExpiration
(
)
;
hadDisplayPort
=
scrollableFrame
-
>
GetDisplayPortAtLastApproximateFrameVisibilityUpdate
(
&
oldDisplayPort
)
;
bool
needVisibilityUpdate
=
!
hadDisplayPort
;
if
(
!
needVisibilityUpdate
)
{
if
(
(
newDisplayPort
.
width
>
2
*
oldDisplayPort
.
width
)
|
|
(
oldDisplayPort
.
width
>
2
*
newDisplayPort
.
width
)
|
|
(
newDisplayPort
.
height
>
2
*
oldDisplayPort
.
height
)
|
|
(
oldDisplayPort
.
height
>
2
*
newDisplayPort
.
height
)
)
{
needVisibilityUpdate
=
true
;
}
}
if
(
!
needVisibilityUpdate
)
{
if
(
nsRect
*
baseData
=
static_cast
<
nsRect
*
>
(
aContent
-
>
GetProperty
(
nsGkAtoms
:
:
DisplayPortBase
)
)
)
{
nsRect
base
=
*
baseData
;
if
(
(
std
:
:
abs
(
newDisplayPort
.
X
(
)
-
oldDisplayPort
.
X
(
)
)
>
base
.
width
)
|
|
(
std
:
:
abs
(
newDisplayPort
.
XMost
(
)
-
oldDisplayPort
.
XMost
(
)
)
>
base
.
width
)
|
|
(
std
:
:
abs
(
newDisplayPort
.
Y
(
)
-
oldDisplayPort
.
Y
(
)
)
>
base
.
height
)
|
|
(
std
:
:
abs
(
newDisplayPort
.
YMost
(
)
-
oldDisplayPort
.
YMost
(
)
)
>
base
.
height
)
)
{
needVisibilityUpdate
=
true
;
}
}
}
if
(
needVisibilityUpdate
)
{
aPresShell
-
>
ScheduleApproximateFrameVisibilityUpdateNow
(
)
;
}
return
true
;
}
void
DisplayPortUtils
:
:
SetDisplayPortBase
(
nsIContent
*
aContent
const
nsRect
&
aBase
)
{
if
(
MOZ_LOG_TEST
(
sDisplayportLog
LogLevel
:
:
Verbose
)
)
{
ViewID
viewId
=
nsLayoutUtils
:
:
FindOrCreateIDFor
(
aContent
)
;
MOZ_LOG
(
sDisplayportLog
LogLevel
:
:
Verbose
(
"
Setting
base
rect
%
s
for
scrollId
=
%
"
PRIu64
"
\
n
"
ToString
(
aBase
)
.
c_str
(
)
viewId
)
)
;
}
aContent
-
>
SetProperty
(
nsGkAtoms
:
:
DisplayPortBase
new
nsRect
(
aBase
)
nsINode
:
:
DeleteProperty
<
nsRect
>
)
;
}
void
DisplayPortUtils
:
:
SetDisplayPortBaseIfNotSet
(
nsIContent
*
aContent
const
nsRect
&
aBase
)
{
if
(
!
aContent
-
>
GetProperty
(
nsGkAtoms
:
:
DisplayPortBase
)
)
{
SetDisplayPortBase
(
aContent
aBase
)
;
}
}
void
DisplayPortUtils
:
:
RemoveDisplayPort
(
nsIContent
*
aContent
)
{
aContent
-
>
RemoveProperty
(
nsGkAtoms
:
:
DisplayPort
)
;
aContent
-
>
RemoveProperty
(
nsGkAtoms
:
:
DisplayPortMargins
)
;
}
bool
DisplayPortUtils
:
:
ViewportHasDisplayPort
(
nsPresContext
*
aPresContext
)
{
nsIFrame
*
rootScrollFrame
=
aPresContext
-
>
PresShell
(
)
-
>
GetRootScrollFrame
(
)
;
return
rootScrollFrame
&
&
HasDisplayPort
(
rootScrollFrame
-
>
GetContent
(
)
)
;
}
bool
DisplayPortUtils
:
:
IsFixedPosFrameInDisplayPort
(
const
nsIFrame
*
aFrame
)
{
nsIFrame
*
parent
=
aFrame
-
>
GetParent
(
)
;
if
(
!
parent
|
|
parent
-
>
GetParent
(
)
|
|
aFrame
-
>
StyleDisplay
(
)
-
>
mPosition
!
=
StylePositionProperty
:
:
Fixed
)
{
return
false
;
}
return
ViewportHasDisplayPort
(
aFrame
-
>
PresContext
(
)
)
;
}
bool
DisplayPortUtils
:
:
FrameHasDisplayPort
(
nsIFrame
*
aFrame
const
nsIFrame
*
aScrolledFrame
)
{
if
(
!
aFrame
-
>
GetContent
(
)
|
|
!
HasDisplayPort
(
aFrame
-
>
GetContent
(
)
)
)
{
return
false
;
}
nsIScrollableFrame
*
sf
=
do_QueryFrame
(
aFrame
)
;
if
(
sf
)
{
if
(
aScrolledFrame
&
&
aScrolledFrame
!
=
sf
-
>
GetScrolledFrame
(
)
)
{
return
false
;
}
return
true
;
}
return
false
;
}
bool
DisplayPortUtils
:
:
CalculateAndSetDisplayPortMargins
(
nsIScrollableFrame
*
aScrollFrame
RepaintMode
aRepaintMode
)
{
nsIFrame
*
frame
=
do_QueryFrame
(
aScrollFrame
)
;
MOZ_ASSERT
(
frame
)
;
nsIContent
*
content
=
frame
-
>
GetContent
(
)
;
MOZ_ASSERT
(
content
)
;
FrameMetrics
metrics
=
nsLayoutUtils
:
:
CalculateBasicFrameMetrics
(
aScrollFrame
)
;
ScreenMargin
displayportMargins
=
layers
:
:
apz
:
:
CalculatePendingDisplayPort
(
metrics
ParentLayerPoint
(
0
.
0f
0
.
0f
)
)
;
PresShell
*
presShell
=
frame
-
>
PresContext
(
)
-
>
GetPresShell
(
)
;
DisplayPortMargins
margins
=
DisplayPortMargins
:
:
ForScrollFrame
(
aScrollFrame
displayportMargins
Some
(
metrics
.
DisplayportPixelsPerCSSPixel
(
)
)
)
;
return
SetDisplayPortMargins
(
content
presShell
margins
ClearMinimalDisplayPortProperty
:
:
Yes
0
aRepaintMode
)
;
}
bool
DisplayPortUtils
:
:
MaybeCreateDisplayPort
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aScrollFrame
RepaintMode
aRepaintMode
)
{
nsIContent
*
content
=
aScrollFrame
-
>
GetContent
(
)
;
nsIScrollableFrame
*
scrollableFrame
=
do_QueryFrame
(
aScrollFrame
)
;
if
(
!
content
|
|
!
scrollableFrame
)
{
return
false
;
}
bool
haveDisplayPort
=
HasNonMinimalNonZeroDisplayPort
(
content
)
;
if
(
aBuilder
-
>
IsPaintingToWindow
(
)
&
&
nsLayoutUtils
:
:
AsyncPanZoomEnabled
(
aScrollFrame
)
&
&
!
aBuilder
-
>
HaveScrollableDisplayPort
(
)
&
&
scrollableFrame
-
>
WantAsyncScroll
(
)
)
{
if
(
!
haveDisplayPort
)
{
ViewID
viewId
=
nsLayoutUtils
:
:
FindOrCreateIDFor
(
content
)
;
MOZ_LOG
(
sDisplayportLog
LogLevel
:
:
Debug
(
"
Setting
DP
on
first
-
encountered
scrollId
=
%
"
PRIu64
"
\
n
"
viewId
)
)
;
CalculateAndSetDisplayPortMargins
(
scrollableFrame
aRepaintMode
)
;
#
ifdef
DEBUG
haveDisplayPort
=
HasNonMinimalDisplayPort
(
content
)
;
MOZ_ASSERT
(
haveDisplayPort
"
should
have
a
displayport
after
having
just
set
it
"
)
;
#
endif
}
aBuilder
-
>
SetHaveScrollableDisplayPort
(
)
;
return
true
;
}
return
false
;
}
void
DisplayPortUtils
:
:
SetZeroMarginDisplayPortOnAsyncScrollableAncestors
(
nsIFrame
*
aFrame
)
{
nsIFrame
*
frame
=
aFrame
;
while
(
frame
)
{
frame
=
nsLayoutUtils
:
:
GetParentOrPlaceholderForCrossDoc
(
frame
)
;
if
(
!
frame
)
{
break
;
}
nsIScrollableFrame
*
scrollAncestor
=
nsLayoutUtils
:
:
GetAsyncScrollableAncestorFrame
(
frame
)
;
if
(
!
scrollAncestor
)
{
break
;
}
frame
=
do_QueryFrame
(
scrollAncestor
)
;
MOZ_ASSERT
(
frame
)
;
MOZ_ASSERT
(
scrollAncestor
-
>
WantAsyncScroll
(
)
|
|
frame
-
>
PresShell
(
)
-
>
GetRootScrollFrame
(
)
=
=
frame
)
;
if
(
nsLayoutUtils
:
:
AsyncPanZoomEnabled
(
frame
)
&
&
!
HasDisplayPort
(
frame
-
>
GetContent
(
)
)
)
{
SetDisplayPortMargins
(
frame
-
>
GetContent
(
)
frame
-
>
PresShell
(
)
DisplayPortMargins
:
:
Empty
(
frame
-
>
GetContent
(
)
)
ClearMinimalDisplayPortProperty
:
:
No
0
RepaintMode
:
:
Repaint
)
;
}
}
}
bool
DisplayPortUtils
:
:
MaybeCreateDisplayPortInFirstScrollFrameEncountered
(
nsIFrame
*
aFrame
nsDisplayListBuilder
*
aBuilder
)
{
nsIScrollableFrame
*
sf
=
do_QueryFrame
(
aFrame
)
;
if
(
sf
)
{
if
(
MaybeCreateDisplayPort
(
aBuilder
aFrame
RepaintMode
:
:
Repaint
)
)
{
return
true
;
}
}
if
(
aFrame
-
>
IsPlaceholderFrame
(
)
)
{
nsPlaceholderFrame
*
placeholder
=
static_cast
<
nsPlaceholderFrame
*
>
(
aFrame
)
;
if
(
MaybeCreateDisplayPortInFirstScrollFrameEncountered
(
placeholder
-
>
GetOutOfFlowFrame
(
)
aBuilder
)
)
{
return
true
;
}
}
if
(
aFrame
-
>
IsSubDocumentFrame
(
)
)
{
PresShell
*
presShell
=
static_cast
<
nsSubDocumentFrame
*
>
(
aFrame
)
-
>
GetSubdocumentPresShellForPainting
(
0
)
;
nsIFrame
*
root
=
presShell
?
presShell
-
>
GetRootFrame
(
)
:
nullptr
;
if
(
root
)
{
if
(
MaybeCreateDisplayPortInFirstScrollFrameEncountered
(
root
aBuilder
)
)
{
return
true
;
}
}
}
if
(
aFrame
-
>
IsDeckFrame
(
)
)
{
nsIFrame
*
child
=
static_cast
<
nsDeckFrame
*
>
(
aFrame
)
-
>
GetSelectedBox
(
)
;
if
(
child
)
{
return
MaybeCreateDisplayPortInFirstScrollFrameEncountered
(
child
aBuilder
)
;
}
}
for
(
nsIFrame
*
child
:
aFrame
-
>
PrincipalChildList
(
)
)
{
if
(
MaybeCreateDisplayPortInFirstScrollFrameEncountered
(
child
aBuilder
)
)
{
return
true
;
}
}
return
false
;
}
void
DisplayPortUtils
:
:
ExpireDisplayPortOnAsyncScrollableAncestor
(
nsIFrame
*
aFrame
)
{
nsIFrame
*
frame
=
aFrame
;
while
(
frame
)
{
frame
=
nsLayoutUtils
:
:
GetCrossDocParentFrameInProcess
(
frame
)
;
if
(
!
frame
)
{
break
;
}
nsIScrollableFrame
*
scrollAncestor
=
nsLayoutUtils
:
:
GetAsyncScrollableAncestorFrame
(
frame
)
;
if
(
!
scrollAncestor
)
{
break
;
}
frame
=
do_QueryFrame
(
scrollAncestor
)
;
MOZ_ASSERT
(
frame
)
;
if
(
!
frame
)
{
break
;
}
MOZ_ASSERT
(
scrollAncestor
-
>
WantAsyncScroll
(
)
|
|
frame
-
>
PresShell
(
)
-
>
GetRootScrollFrame
(
)
=
=
frame
)
;
if
(
HasDisplayPort
(
frame
-
>
GetContent
(
)
)
)
{
scrollAncestor
-
>
TriggerDisplayPortExpiration
(
)
;
break
;
}
}
}
Maybe
<
nsRect
>
DisplayPortUtils
:
:
GetRootDisplayportBase
(
PresShell
*
aPresShell
)
{
DebugOnly
<
nsPresContext
*
>
pc
=
aPresShell
-
>
GetPresContext
(
)
;
MOZ_ASSERT
(
pc
"
this
function
should
be
called
after
PresShell
:
:
Init
"
)
;
MOZ_ASSERT
(
pc
-
>
IsRootContentDocumentCrossProcess
(
)
|
|
!
pc
-
>
GetParentPresContext
(
)
)
;
dom
:
:
BrowserChild
*
browserChild
=
dom
:
:
BrowserChild
:
:
GetFrom
(
aPresShell
)
;
if
(
browserChild
&
&
!
browserChild
-
>
IsTopLevel
(
)
)
{
return
browserChild
-
>
GetVisibleRect
(
)
;
}
nsIFrame
*
frame
=
aPresShell
-
>
GetRootScrollFrame
(
)
;
if
(
!
frame
)
{
frame
=
aPresShell
-
>
GetRootFrame
(
)
;
}
nsRect
baseRect
;
if
(
frame
)
{
baseRect
=
nsRect
(
nsPoint
(
0
0
)
nsLayoutUtils
:
:
CalculateCompositionSizeForFrame
(
frame
)
)
;
}
else
{
baseRect
=
nsRect
(
nsPoint
(
0
0
)
aPresShell
-
>
GetPresContext
(
)
-
>
GetVisibleArea
(
)
.
Size
(
)
)
;
}
return
Some
(
baseRect
)
;
}
}
