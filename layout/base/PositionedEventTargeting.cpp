#
include
"
PositionedEventTargeting
.
h
"
#
include
"
mozilla
/
EventListenerManager
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
dom
/
MouseEventBinding
.
h
"
#
include
"
nsFrameList
.
h
"
#
include
"
nsHTMLParts
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsFontMetrics
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nsDeviceContext
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
<
algorithm
>
#
include
"
LayersLogging
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
static
mozilla
:
:
LazyLogModule
sEvtTgtLog
(
"
event
.
retarget
"
)
;
#
define
PET_LOG
(
.
.
.
)
MOZ_LOG
(
sEvtTgtLog
LogLevel
:
:
Debug
(
__VA_ARGS__
)
)
namespace
mozilla
{
struct
EventRadiusPrefs
{
uint32_t
mVisitedWeight
;
uint32_t
mSideRadii
[
4
]
;
bool
mEnabled
;
bool
mRegistered
;
bool
mTouchOnly
;
bool
mRepositionEventCoords
;
}
;
static
EventRadiusPrefs
sMouseEventRadiusPrefs
;
static
EventRadiusPrefs
sTouchEventRadiusPrefs
;
static
const
EventRadiusPrefs
*
GetPrefsFor
(
EventClassID
aEventClassID
)
{
EventRadiusPrefs
*
prefs
=
nullptr
;
const
char
*
prefBranch
=
nullptr
;
if
(
aEventClassID
=
=
eTouchEventClass
)
{
prefBranch
=
"
touch
"
;
prefs
=
&
sTouchEventRadiusPrefs
;
}
else
if
(
aEventClassID
=
=
eMouseEventClass
)
{
prefBranch
=
"
mouse
"
;
prefs
=
&
sMouseEventRadiusPrefs
;
}
else
{
return
nullptr
;
}
if
(
!
prefs
-
>
mRegistered
)
{
prefs
-
>
mRegistered
=
true
;
nsPrintfCString
enabledPref
(
"
ui
.
%
s
.
radius
.
enabled
"
prefBranch
)
;
Preferences
:
:
AddBoolVarCache
(
&
prefs
-
>
mEnabled
enabledPref
false
)
;
nsPrintfCString
visitedWeightPref
(
"
ui
.
%
s
.
radius
.
visitedWeight
"
prefBranch
)
;
Preferences
:
:
AddUintVarCache
(
&
prefs
-
>
mVisitedWeight
visitedWeightPref
100
)
;
static
const
char
prefNames
[
4
]
[
9
]
=
{
"
topmm
"
"
rightmm
"
"
bottommm
"
"
leftmm
"
}
;
for
(
int32_t
i
=
0
;
i
<
4
;
+
+
i
)
{
nsPrintfCString
radiusPref
(
"
ui
.
%
s
.
radius
.
%
s
"
prefBranch
prefNames
[
i
]
)
;
Preferences
:
:
AddUintVarCache
(
&
prefs
-
>
mSideRadii
[
i
]
radiusPref
0
)
;
}
if
(
aEventClassID
=
=
eMouseEventClass
)
{
Preferences
:
:
AddBoolVarCache
(
&
prefs
-
>
mTouchOnly
"
ui
.
mouse
.
radius
.
inputSource
.
touchOnly
"
true
)
;
}
else
{
prefs
-
>
mTouchOnly
=
false
;
}
nsPrintfCString
repositionPref
(
"
ui
.
%
s
.
radius
.
reposition
"
prefBranch
)
;
Preferences
:
:
AddBoolVarCache
(
&
prefs
-
>
mRepositionEventCoords
repositionPref
false
)
;
}
return
prefs
;
}
static
bool
HasMouseListener
(
nsIContent
*
aContent
)
{
if
(
EventListenerManager
*
elm
=
aContent
-
>
GetExistingListenerManager
(
)
)
{
return
elm
-
>
HasListenersFor
(
nsGkAtoms
:
:
onclick
)
|
|
elm
-
>
HasListenersFor
(
nsGkAtoms
:
:
onmousedown
)
|
|
elm
-
>
HasListenersFor
(
nsGkAtoms
:
:
onmouseup
)
;
}
return
false
;
}
static
bool
HasTouchListener
(
nsIContent
*
aContent
)
{
EventListenerManager
*
elm
=
aContent
-
>
GetExistingListenerManager
(
)
;
if
(
!
elm
)
{
return
false
;
}
if
(
!
StaticPrefs
:
:
dom_w3c_touch_events_enabled
(
)
)
{
return
false
;
}
return
elm
-
>
HasListenersFor
(
nsGkAtoms
:
:
ontouchstart
)
|
|
elm
-
>
HasListenersFor
(
nsGkAtoms
:
:
ontouchend
)
;
}
static
bool
IsDescendant
(
nsIFrame
*
aFrame
nsIContent
*
aAncestor
nsAutoString
*
aLabelTargetId
)
{
for
(
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
content
;
content
=
content
-
>
GetFlattenedTreeParent
(
)
)
{
if
(
aLabelTargetId
&
&
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
label
)
)
{
content
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_for
*
aLabelTargetId
)
;
}
if
(
content
=
=
aAncestor
)
{
return
true
;
}
}
return
false
;
}
static
nsIContent
*
GetClickableAncestor
(
nsIFrame
*
aFrame
nsAtom
*
stopAt
=
nullptr
nsAutoString
*
aLabelTargetId
=
nullptr
)
{
for
(
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
content
;
content
=
content
-
>
GetFlattenedTreeParent
(
)
)
{
if
(
stopAt
&
&
content
-
>
IsHTMLElement
(
stopAt
)
)
{
break
;
}
if
(
HasTouchListener
(
content
)
|
|
HasMouseListener
(
content
)
)
{
return
content
;
}
if
(
content
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
button
nsGkAtoms
:
:
input
nsGkAtoms
:
:
select
nsGkAtoms
:
:
textarea
)
)
{
return
content
;
}
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
label
)
)
{
if
(
aLabelTargetId
)
{
content
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_for
*
aLabelTargetId
)
;
}
return
content
;
}
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
iframe
)
&
&
content
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
mozbrowser
nsGkAtoms
:
:
_true
eIgnoreCase
)
&
&
content
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
remote
nsGkAtoms
:
:
_true
eIgnoreCase
)
)
{
return
content
;
}
if
(
content
-
>
IsAnyOfXULElements
(
nsGkAtoms
:
:
button
nsGkAtoms
:
:
checkbox
nsGkAtoms
:
:
radio
nsGkAtoms
:
:
menu
nsGkAtoms
:
:
menuitem
nsGkAtoms
:
:
menulist
nsGkAtoms
:
:
scrollbarbutton
nsGkAtoms
:
:
resizer
)
)
{
return
content
;
}
static
Element
:
:
AttrValuesArray
clickableRoles
[
]
=
{
nsGkAtoms
:
:
button
nsGkAtoms
:
:
key
nullptr
}
;
if
(
content
-
>
IsElement
(
)
&
&
content
-
>
AsElement
(
)
-
>
FindAttrValueIn
(
kNameSpaceID_None
nsGkAtoms
:
:
role
clickableRoles
eIgnoreCase
)
>
=
0
)
{
return
content
;
}
if
(
content
-
>
IsEditable
(
)
)
{
return
content
;
}
nsCOMPtr
<
nsIURI
>
linkURI
;
if
(
content
-
>
IsLink
(
getter_AddRefs
(
linkURI
)
)
)
{
return
content
;
}
}
return
nullptr
;
}
static
nscoord
AppUnitsFromMM
(
nsIFrame
*
aFrame
uint32_t
aMM
)
{
nsPresContext
*
pc
=
aFrame
-
>
PresContext
(
)
;
PresShell
*
presShell
=
pc
-
>
PresShell
(
)
;
float
result
=
float
(
aMM
)
*
(
pc
-
>
DeviceContext
(
)
-
>
AppUnitsPerPhysicalInch
(
)
/
MM_PER_INCH_FLOAT
)
;
result
=
result
/
presShell
-
>
GetResolution
(
)
;
return
NSToCoordRound
(
result
)
;
}
static
nsRect
ClipToFrame
(
nsIFrame
*
aRootFrame
nsIFrame
*
aFrame
nsRect
&
aRect
)
{
nsRect
bound
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
aFrame
nsRect
(
nsPoint
(
0
0
)
aFrame
-
>
GetSize
(
)
)
aRootFrame
)
;
nsRect
result
=
bound
.
Intersect
(
aRect
)
;
return
result
;
}
static
nsRect
GetTargetRect
(
nsIFrame
*
aRootFrame
const
nsPoint
&
aPointRelativeToRootFrame
nsIFrame
*
aRestrictToDescendants
const
EventRadiusPrefs
*
aPrefs
uint32_t
aFlags
)
{
nsMargin
m
(
AppUnitsFromMM
(
aRootFrame
aPrefs
-
>
mSideRadii
[
0
]
)
AppUnitsFromMM
(
aRootFrame
aPrefs
-
>
mSideRadii
[
1
]
)
AppUnitsFromMM
(
aRootFrame
aPrefs
-
>
mSideRadii
[
2
]
)
AppUnitsFromMM
(
aRootFrame
aPrefs
-
>
mSideRadii
[
3
]
)
)
;
nsRect
r
(
aPointRelativeToRootFrame
nsSize
(
0
0
)
)
;
r
.
Inflate
(
m
)
;
if
(
!
(
aFlags
&
INPUT_IGNORE_ROOT_SCROLL_FRAME
)
)
{
r
=
ClipToFrame
(
aRootFrame
aRestrictToDescendants
r
)
;
}
return
r
;
}
static
float
ComputeDistanceFromRect
(
const
nsPoint
&
aPoint
const
nsRect
&
aRect
)
{
nscoord
dx
=
std
:
:
max
(
0
std
:
:
max
(
aRect
.
x
-
aPoint
.
x
aPoint
.
x
-
aRect
.
XMost
(
)
)
)
;
nscoord
dy
=
std
:
:
max
(
0
std
:
:
max
(
aRect
.
y
-
aPoint
.
y
aPoint
.
y
-
aRect
.
YMost
(
)
)
)
;
return
float
(
NS_hypot
(
dx
dy
)
)
;
}
static
float
ComputeDistanceFromRegion
(
const
nsPoint
&
aPoint
const
nsRegion
&
aRegion
)
{
MOZ_ASSERT
(
!
aRegion
.
IsEmpty
(
)
"
can
'
t
compute
distance
between
point
and
empty
region
"
)
;
float
minDist
=
-
1
;
for
(
auto
iter
=
aRegion
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
float
dist
=
ComputeDistanceFromRect
(
aPoint
iter
.
Get
(
)
)
;
if
(
dist
<
minDist
|
|
minDist
<
0
)
{
minDist
=
dist
;
}
}
return
minDist
;
}
static
void
SubtractFromExposedRegion
(
nsRegion
*
aExposedRegion
const
nsRegion
&
aRegion
)
{
if
(
aRegion
.
IsEmpty
(
)
)
return
;
nsRegion
tmp
;
tmp
.
Sub
(
*
aExposedRegion
aRegion
)
;
if
(
tmp
.
GetNumRects
(
)
<
=
15
|
|
tmp
.
Area
(
)
<
=
aExposedRegion
-
>
Area
(
)
/
2
)
{
*
aExposedRegion
=
tmp
;
}
}
static
nsIFrame
*
GetClosest
(
nsIFrame
*
aRoot
const
nsPoint
&
aPointRelativeToRootFrame
const
nsRect
&
aTargetRect
const
EventRadiusPrefs
*
aPrefs
nsIFrame
*
aRestrictToDescendants
nsIContent
*
aClickableAncestor
nsTArray
<
nsIFrame
*
>
&
aCandidates
)
{
nsIFrame
*
bestTarget
=
nullptr
;
float
bestDistance
=
1e6f
;
nsRegion
exposedRegion
(
aTargetRect
)
;
for
(
uint32_t
i
=
0
;
i
<
aCandidates
.
Length
(
)
;
+
+
i
)
{
nsIFrame
*
f
=
aCandidates
[
i
]
;
bool
preservesAxisAlignedRectangles
=
false
;
nsRect
borderBox
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
f
nsRect
(
nsPoint
(
0
0
)
f
-
>
GetSize
(
)
)
aRoot
&
preservesAxisAlignedRectangles
)
;
PET_LOG
(
"
Checking
candidate
%
p
with
border
box
%
s
\
n
"
f
mozilla
:
:
layers
:
:
Stringify
(
borderBox
)
.
c_str
(
)
)
;
nsRegion
region
;
region
.
And
(
exposedRegion
borderBox
)
;
if
(
region
.
IsEmpty
(
)
)
{
PET_LOG
(
"
candidate
%
p
had
empty
hit
region
\
n
"
f
)
;
continue
;
}
if
(
preservesAxisAlignedRectangles
)
{
SubtractFromExposedRegion
(
&
exposedRegion
region
)
;
}
nsAutoString
labelTargetId
;
if
(
aClickableAncestor
&
&
!
IsDescendant
(
f
aClickableAncestor
&
labelTargetId
)
)
{
PET_LOG
(
"
candidate
%
p
is
not
a
descendant
of
required
ancestor
\
n
"
f
)
;
continue
;
}
nsIContent
*
clickableContent
=
GetClickableAncestor
(
f
nsGkAtoms
:
:
body
&
labelTargetId
)
;
if
(
!
aClickableAncestor
&
&
!
clickableContent
)
{
PET_LOG
(
"
candidate
%
p
was
not
clickable
\
n
"
f
)
;
continue
;
}
if
(
bestTarget
&
&
nsLayoutUtils
:
:
IsProperAncestorFrameCrossDoc
(
f
bestTarget
aRoot
)
)
{
PET_LOG
(
"
candidate
%
p
was
ancestor
for
bestTarget
%
p
\
n
"
f
bestTarget
)
;
continue
;
}
if
(
!
aClickableAncestor
&
&
!
nsLayoutUtils
:
:
IsAncestorFrameCrossDoc
(
aRestrictToDescendants
f
aRoot
)
)
{
PET_LOG
(
"
candidate
%
p
was
not
descendant
of
restrictroot
%
p
\
n
"
f
aRestrictToDescendants
)
;
continue
;
}
float
distance
=
ComputeDistanceFromRegion
(
aPointRelativeToRootFrame
region
)
;
nsIContent
*
content
=
f
-
>
GetContent
(
)
;
if
(
content
&
&
content
-
>
IsElement
(
)
&
&
content
-
>
AsElement
(
)
-
>
State
(
)
.
HasState
(
EventStates
(
NS_EVENT_STATE_VISITED
)
)
)
{
distance
*
=
aPrefs
-
>
mVisitedWeight
/
100
.
0f
;
}
if
(
distance
<
bestDistance
)
{
PET_LOG
(
"
candidate
%
p
is
the
new
best
\
n
"
f
)
;
bestDistance
=
distance
;
bestTarget
=
f
;
}
}
return
bestTarget
;
}
nsIFrame
*
FindFrameTargetedByInputEvent
(
WidgetGUIEvent
*
aEvent
nsIFrame
*
aRootFrame
const
nsPoint
&
aPointRelativeToRootFrame
uint32_t
aFlags
)
{
using
FrameForPointOption
=
nsLayoutUtils
:
:
FrameForPointOption
;
EnumSet
<
FrameForPointOption
>
options
;
if
(
aFlags
&
INPUT_IGNORE_ROOT_SCROLL_FRAME
)
{
options
+
=
FrameForPointOption
:
:
IgnoreRootScrollFrame
;
}
nsIFrame
*
target
=
nsLayoutUtils
:
:
GetFrameForPoint
(
aRootFrame
aPointRelativeToRootFrame
options
)
;
PET_LOG
(
"
Found
initial
target
%
p
for
event
class
%
s
message
%
s
point
%
s
"
"
relative
to
root
frame
%
p
\
n
"
target
ToChar
(
aEvent
-
>
mClass
)
ToChar
(
aEvent
-
>
mMessage
)
mozilla
:
:
layers
:
:
Stringify
(
aPointRelativeToRootFrame
)
.
c_str
(
)
aRootFrame
)
;
const
EventRadiusPrefs
*
prefs
=
GetPrefsFor
(
aEvent
-
>
mClass
)
;
if
(
!
prefs
|
|
!
prefs
-
>
mEnabled
)
{
PET_LOG
(
"
Retargeting
disabled
\
n
"
)
;
return
target
;
}
nsIContent
*
clickableAncestor
=
nullptr
;
if
(
target
)
{
clickableAncestor
=
GetClickableAncestor
(
target
nsGkAtoms
:
:
body
)
;
if
(
clickableAncestor
)
{
PET_LOG
(
"
Target
%
p
is
clickable
\
n
"
target
)
;
clickableAncestor
=
target
-
>
GetContent
(
)
;
}
}
if
(
aEvent
-
>
mClass
=
=
eMouseEventClass
&
&
prefs
-
>
mTouchOnly
&
&
aEvent
-
>
AsMouseEvent
(
)
-
>
mInputSource
!
=
MouseEvent_Binding
:
:
MOZ_SOURCE_TOUCH
)
{
PET_LOG
(
"
Mouse
input
event
is
not
from
a
touch
source
\
n
"
)
;
return
target
;
}
nsIFrame
*
restrictToDescendants
=
target
?
target
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
:
aRootFrame
;
nsRect
targetRect
=
GetTargetRect
(
aRootFrame
aPointRelativeToRootFrame
restrictToDescendants
prefs
aFlags
)
;
PET_LOG
(
"
Expanded
point
to
target
rect
%
s
\
n
"
mozilla
:
:
layers
:
:
Stringify
(
targetRect
)
.
c_str
(
)
)
;
AutoTArray
<
nsIFrame
*
8
>
candidates
;
nsresult
rv
=
nsLayoutUtils
:
:
GetFramesForArea
(
aRootFrame
targetRect
candidates
options
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
target
;
}
nsIFrame
*
closestClickable
=
GetClosest
(
aRootFrame
aPointRelativeToRootFrame
targetRect
prefs
restrictToDescendants
clickableAncestor
candidates
)
;
if
(
closestClickable
)
{
target
=
closestClickable
;
}
PET_LOG
(
"
Final
target
is
%
p
\
n
"
target
)
;
#
ifdef
DEBUG_FRAME_DUMP
if
(
MOZ_LOG_TEST
(
sEvtTgtLog
LogLevel
:
:
Verbose
)
)
{
aRootFrame
-
>
DumpFrameTree
(
)
;
}
#
endif
if
(
!
target
|
|
!
prefs
-
>
mRepositionEventCoords
)
{
return
target
;
}
nsPoint
point
=
aPointRelativeToRootFrame
;
if
(
nsLayoutUtils
:
:
TRANSFORM_SUCCEEDED
!
=
nsLayoutUtils
:
:
TransformPoint
(
aRootFrame
target
point
)
)
{
return
target
;
}
point
=
target
-
>
GetRectRelativeToSelf
(
)
.
ClampPoint
(
point
)
;
if
(
nsLayoutUtils
:
:
TRANSFORM_SUCCEEDED
!
=
nsLayoutUtils
:
:
TransformPoint
(
target
aRootFrame
point
)
)
{
return
target
;
}
nsView
*
view
=
aRootFrame
-
>
GetView
(
)
;
if
(
!
view
)
{
return
target
;
}
LayoutDeviceIntPoint
widgetPoint
=
nsLayoutUtils
:
:
TranslateViewToWidget
(
aRootFrame
-
>
PresContext
(
)
view
point
aEvent
-
>
mWidget
)
;
if
(
widgetPoint
.
x
!
=
NS_UNCONSTRAINEDSIZE
)
{
aEvent
-
>
mRefPoint
=
widgetPoint
;
}
return
target
;
}
}
