#
include
"
PositionedEventTargeting
.
h
"
#
include
"
mozilla
/
EventListenerManager
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
StaticPrefs_ui
.
h
"
#
include
"
mozilla
/
dom
/
MouseEventBinding
.
h
"
#
include
"
nsFrameList
.
h
"
#
include
"
nsHTMLParts
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsFontMetrics
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nsDeviceContext
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
<
algorithm
>
#
include
"
LayersLogging
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
static
mozilla
:
:
LazyLogModule
sEvtTgtLog
(
"
event
.
retarget
"
)
;
#
define
PET_LOG
(
.
.
.
)
MOZ_LOG
(
sEvtTgtLog
LogLevel
:
:
Debug
(
__VA_ARGS__
)
)
namespace
mozilla
{
struct
EventRadiusPrefs
{
bool
mEnabled
;
uint32_t
mVisitedWeight
;
uint32_t
mRadiusTopmm
;
uint32_t
mRadiusRightmm
;
uint32_t
mRadiusBottommm
;
uint32_t
mRadiusLeftmm
;
bool
mTouchOnly
;
bool
mReposition
;
explicit
EventRadiusPrefs
(
EventClassID
aEventClassID
)
{
if
(
aEventClassID
=
=
eTouchEventClass
)
{
mEnabled
=
StaticPrefs
:
:
ui_touch_radius_enabled
(
)
;
mVisitedWeight
=
StaticPrefs
:
:
ui_touch_radius_visitedWeight
(
)
;
mRadiusTopmm
=
StaticPrefs
:
:
ui_touch_radius_topmm
(
)
;
mRadiusRightmm
=
StaticPrefs
:
:
ui_touch_radius_rightmm
(
)
;
mRadiusBottommm
=
StaticPrefs
:
:
ui_touch_radius_bottommm
(
)
;
mRadiusLeftmm
=
StaticPrefs
:
:
ui_touch_radius_leftmm
(
)
;
mTouchOnly
=
false
;
mReposition
=
false
;
}
else
if
(
aEventClassID
=
=
eMouseEventClass
)
{
mEnabled
=
StaticPrefs
:
:
ui_mouse_radius_enabled
(
)
;
mVisitedWeight
=
StaticPrefs
:
:
ui_mouse_radius_visitedWeight
(
)
;
mRadiusTopmm
=
StaticPrefs
:
:
ui_mouse_radius_topmm
(
)
;
mRadiusRightmm
=
StaticPrefs
:
:
ui_mouse_radius_rightmm
(
)
;
mRadiusBottommm
=
StaticPrefs
:
:
ui_mouse_radius_bottommm
(
)
;
mRadiusLeftmm
=
StaticPrefs
:
:
ui_mouse_radius_leftmm
(
)
;
mTouchOnly
=
StaticPrefs
:
:
ui_mouse_radius_inputSource_touchOnly
(
)
;
mReposition
=
StaticPrefs
:
:
ui_mouse_radius_reposition
(
)
;
}
else
{
mEnabled
=
false
;
mVisitedWeight
=
0
;
mRadiusTopmm
=
0
;
mRadiusRightmm
=
0
;
mRadiusBottommm
=
0
;
mRadiusLeftmm
=
0
;
mTouchOnly
=
false
;
mReposition
=
false
;
}
}
}
;
static
bool
HasMouseListener
(
nsIContent
*
aContent
)
{
if
(
EventListenerManager
*
elm
=
aContent
-
>
GetExistingListenerManager
(
)
)
{
return
elm
-
>
HasListenersFor
(
nsGkAtoms
:
:
onclick
)
|
|
elm
-
>
HasListenersFor
(
nsGkAtoms
:
:
onmousedown
)
|
|
elm
-
>
HasListenersFor
(
nsGkAtoms
:
:
onmouseup
)
;
}
return
false
;
}
static
bool
HasTouchListener
(
nsIContent
*
aContent
)
{
EventListenerManager
*
elm
=
aContent
-
>
GetExistingListenerManager
(
)
;
if
(
!
elm
)
{
return
false
;
}
if
(
!
StaticPrefs
:
:
dom_w3c_touch_events_enabled
(
)
)
{
return
false
;
}
return
elm
-
>
HasListenersFor
(
nsGkAtoms
:
:
ontouchstart
)
|
|
elm
-
>
HasListenersFor
(
nsGkAtoms
:
:
ontouchend
)
;
}
static
bool
HasPointerListener
(
nsIContent
*
aContent
)
{
EventListenerManager
*
elm
=
aContent
-
>
GetExistingListenerManager
(
)
;
if
(
!
elm
)
{
return
false
;
}
if
(
!
StaticPrefs
:
:
dom_w3c_pointer_events_enabled
(
)
)
{
return
false
;
}
return
elm
-
>
HasListenersFor
(
nsGkAtoms
:
:
onpointerdown
)
|
|
elm
-
>
HasListenersFor
(
nsGkAtoms
:
:
onpointerup
)
;
}
static
bool
IsDescendant
(
nsIFrame
*
aFrame
nsIContent
*
aAncestor
nsAutoString
*
aLabelTargetId
)
{
for
(
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
content
;
content
=
content
-
>
GetFlattenedTreeParent
(
)
)
{
if
(
aLabelTargetId
&
&
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
label
)
)
{
content
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_for
*
aLabelTargetId
)
;
}
if
(
content
=
=
aAncestor
)
{
return
true
;
}
}
return
false
;
}
static
nsIContent
*
GetClickableAncestor
(
nsIFrame
*
aFrame
nsAtom
*
stopAt
=
nullptr
nsAutoString
*
aLabelTargetId
=
nullptr
)
{
if
(
aFrame
-
>
StyleUI
(
)
-
>
mCursor
.
keyword
=
=
StyleCursorKind
:
:
Pointer
)
{
return
aFrame
-
>
GetContent
(
)
;
}
for
(
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
content
;
content
=
content
-
>
GetFlattenedTreeParent
(
)
)
{
if
(
stopAt
&
&
content
-
>
IsHTMLElement
(
stopAt
)
)
{
break
;
}
if
(
HasTouchListener
(
content
)
|
|
HasMouseListener
(
content
)
|
|
HasPointerListener
(
content
)
)
{
return
content
;
}
if
(
content
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
button
nsGkAtoms
:
:
input
nsGkAtoms
:
:
select
nsGkAtoms
:
:
textarea
)
)
{
return
content
;
}
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
label
)
)
{
if
(
aLabelTargetId
)
{
content
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_for
*
aLabelTargetId
)
;
}
return
content
;
}
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
iframe
)
&
&
content
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
mozbrowser
nsGkAtoms
:
:
_true
eIgnoreCase
)
&
&
content
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
remote
nsGkAtoms
:
:
_true
eIgnoreCase
)
)
{
return
content
;
}
if
(
content
-
>
IsAnyOfXULElements
(
nsGkAtoms
:
:
button
nsGkAtoms
:
:
checkbox
nsGkAtoms
:
:
radio
nsGkAtoms
:
:
menu
nsGkAtoms
:
:
menuitem
nsGkAtoms
:
:
menulist
nsGkAtoms
:
:
scrollbarbutton
nsGkAtoms
:
:
resizer
)
)
{
return
content
;
}
static
Element
:
:
AttrValuesArray
clickableRoles
[
]
=
{
nsGkAtoms
:
:
button
nsGkAtoms
:
:
key
nullptr
}
;
if
(
content
-
>
IsElement
(
)
&
&
content
-
>
AsElement
(
)
-
>
FindAttrValueIn
(
kNameSpaceID_None
nsGkAtoms
:
:
role
clickableRoles
eIgnoreCase
)
>
=
0
)
{
return
content
;
}
if
(
content
-
>
IsEditable
(
)
)
{
return
content
;
}
nsCOMPtr
<
nsIURI
>
linkURI
;
if
(
content
-
>
IsLink
(
getter_AddRefs
(
linkURI
)
)
)
{
return
content
;
}
}
return
nullptr
;
}
static
nscoord
AppUnitsFromMM
(
RelativeTo
aFrame
uint32_t
aMM
)
{
nsPresContext
*
pc
=
aFrame
.
mFrame
-
>
PresContext
(
)
;
float
result
=
float
(
aMM
)
*
(
pc
-
>
DeviceContext
(
)
-
>
AppUnitsPerPhysicalInch
(
)
/
MM_PER_INCH_FLOAT
)
;
if
(
aFrame
.
mViewportType
=
=
ViewportType
:
:
Layout
)
{
PresShell
*
presShell
=
pc
-
>
PresShell
(
)
;
result
=
result
/
presShell
-
>
GetResolution
(
)
;
}
return
NSToCoordRound
(
result
)
;
}
static
nsRect
ClipToFrame
(
RelativeTo
aRootFrame
const
nsIFrame
*
aFrame
nsRect
&
aRect
)
{
nsRect
bound
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
aFrame
nsRect
(
nsPoint
(
0
0
)
aFrame
-
>
GetSize
(
)
)
aRootFrame
)
;
nsRect
result
=
bound
.
Intersect
(
aRect
)
;
return
result
;
}
static
nsRect
GetTargetRect
(
RelativeTo
aRootFrame
const
nsPoint
&
aPointRelativeToRootFrame
const
nsIFrame
*
aRestrictToDescendants
const
EventRadiusPrefs
&
aPrefs
uint32_t
aFlags
)
{
nsMargin
m
(
AppUnitsFromMM
(
aRootFrame
aPrefs
.
mRadiusTopmm
)
AppUnitsFromMM
(
aRootFrame
aPrefs
.
mRadiusRightmm
)
AppUnitsFromMM
(
aRootFrame
aPrefs
.
mRadiusBottommm
)
AppUnitsFromMM
(
aRootFrame
aPrefs
.
mRadiusLeftmm
)
)
;
nsRect
r
(
aPointRelativeToRootFrame
nsSize
(
0
0
)
)
;
r
.
Inflate
(
m
)
;
if
(
!
(
aFlags
&
INPUT_IGNORE_ROOT_SCROLL_FRAME
)
)
{
r
=
ClipToFrame
(
aRootFrame
aRestrictToDescendants
r
)
;
}
return
r
;
}
static
float
ComputeDistanceFromRect
(
const
nsPoint
&
aPoint
const
nsRect
&
aRect
)
{
nscoord
dx
=
std
:
:
max
(
0
std
:
:
max
(
aRect
.
x
-
aPoint
.
x
aPoint
.
x
-
aRect
.
XMost
(
)
)
)
;
nscoord
dy
=
std
:
:
max
(
0
std
:
:
max
(
aRect
.
y
-
aPoint
.
y
aPoint
.
y
-
aRect
.
YMost
(
)
)
)
;
return
float
(
NS_hypot
(
dx
dy
)
)
;
}
static
float
ComputeDistanceFromRegion
(
const
nsPoint
&
aPoint
const
nsRegion
&
aRegion
)
{
MOZ_ASSERT
(
!
aRegion
.
IsEmpty
(
)
"
can
'
t
compute
distance
between
point
and
empty
region
"
)
;
float
minDist
=
-
1
;
for
(
auto
iter
=
aRegion
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
float
dist
=
ComputeDistanceFromRect
(
aPoint
iter
.
Get
(
)
)
;
if
(
dist
<
minDist
|
|
minDist
<
0
)
{
minDist
=
dist
;
}
}
return
minDist
;
}
static
void
SubtractFromExposedRegion
(
nsRegion
*
aExposedRegion
const
nsRegion
&
aRegion
)
{
if
(
aRegion
.
IsEmpty
(
)
)
{
return
;
}
nsRegion
tmp
;
tmp
.
Sub
(
*
aExposedRegion
aRegion
)
;
if
(
tmp
.
GetNumRects
(
)
<
=
15
|
|
tmp
.
Area
(
)
<
=
aExposedRegion
-
>
Area
(
)
/
2
)
{
*
aExposedRegion
=
tmp
;
}
}
static
nsIFrame
*
GetClosest
(
RelativeTo
aRoot
const
nsPoint
&
aPointRelativeToRootFrame
const
nsRect
&
aTargetRect
const
EventRadiusPrefs
&
aPrefs
const
nsIFrame
*
aRestrictToDescendants
nsIContent
*
aClickableAncestor
nsTArray
<
nsIFrame
*
>
&
aCandidates
)
{
nsIFrame
*
bestTarget
=
nullptr
;
float
bestDistance
=
1e6f
;
nsRegion
exposedRegion
(
aTargetRect
)
;
for
(
uint32_t
i
=
0
;
i
<
aCandidates
.
Length
(
)
;
+
+
i
)
{
nsIFrame
*
f
=
aCandidates
[
i
]
;
bool
preservesAxisAlignedRectangles
=
false
;
nsRect
borderBox
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
f
nsRect
(
nsPoint
(
0
0
)
f
-
>
GetSize
(
)
)
aRoot
&
preservesAxisAlignedRectangles
)
;
PET_LOG
(
"
Checking
candidate
%
p
with
border
box
%
s
\
n
"
f
mozilla
:
:
layers
:
:
Stringify
(
borderBox
)
.
c_str
(
)
)
;
nsRegion
region
;
region
.
And
(
exposedRegion
borderBox
)
;
if
(
region
.
IsEmpty
(
)
)
{
PET_LOG
(
"
candidate
%
p
had
empty
hit
region
\
n
"
f
)
;
continue
;
}
if
(
preservesAxisAlignedRectangles
)
{
SubtractFromExposedRegion
(
&
exposedRegion
region
)
;
}
nsAutoString
labelTargetId
;
if
(
aClickableAncestor
&
&
!
IsDescendant
(
f
aClickableAncestor
&
labelTargetId
)
)
{
PET_LOG
(
"
candidate
%
p
is
not
a
descendant
of
required
ancestor
\
n
"
f
)
;
continue
;
}
nsIContent
*
clickableContent
=
GetClickableAncestor
(
f
nsGkAtoms
:
:
body
&
labelTargetId
)
;
if
(
!
aClickableAncestor
&
&
!
clickableContent
)
{
PET_LOG
(
"
candidate
%
p
was
not
clickable
\
n
"
f
)
;
continue
;
}
if
(
bestTarget
&
&
nsLayoutUtils
:
:
IsProperAncestorFrameCrossDoc
(
f
bestTarget
aRoot
.
mFrame
)
)
{
PET_LOG
(
"
candidate
%
p
was
ancestor
for
bestTarget
%
p
\
n
"
f
bestTarget
)
;
continue
;
}
if
(
!
aClickableAncestor
&
&
!
nsLayoutUtils
:
:
IsAncestorFrameCrossDoc
(
aRestrictToDescendants
f
aRoot
.
mFrame
)
)
{
PET_LOG
(
"
candidate
%
p
was
not
descendant
of
restrictroot
%
p
\
n
"
f
aRestrictToDescendants
)
;
continue
;
}
float
distance
=
ComputeDistanceFromRegion
(
aPointRelativeToRootFrame
region
)
;
nsIContent
*
content
=
f
-
>
GetContent
(
)
;
if
(
content
&
&
content
-
>
IsElement
(
)
&
&
content
-
>
AsElement
(
)
-
>
State
(
)
.
HasState
(
EventStates
(
NS_EVENT_STATE_VISITED
)
)
)
{
distance
*
=
aPrefs
.
mVisitedWeight
/
100
.
0f
;
}
if
(
distance
<
bestDistance
)
{
PET_LOG
(
"
candidate
%
p
is
the
new
best
\
n
"
f
)
;
bestDistance
=
distance
;
bestTarget
=
f
;
}
}
return
bestTarget
;
}
nsIFrame
*
FindFrameTargetedByInputEvent
(
WidgetGUIEvent
*
aEvent
RelativeTo
aRootFrame
const
nsPoint
&
aPointRelativeToRootFrame
uint32_t
aFlags
)
{
using
FrameForPointOption
=
nsLayoutUtils
:
:
FrameForPointOption
;
EnumSet
<
FrameForPointOption
>
options
;
if
(
aFlags
&
INPUT_IGNORE_ROOT_SCROLL_FRAME
)
{
options
+
=
FrameForPointOption
:
:
IgnoreRootScrollFrame
;
}
nsIFrame
*
target
=
nsLayoutUtils
:
:
GetFrameForPoint
(
aRootFrame
aPointRelativeToRootFrame
options
)
;
PET_LOG
(
"
Found
initial
target
%
p
for
event
class
%
s
message
%
s
point
%
s
"
"
relative
to
root
frame
%
s
\
n
"
target
ToChar
(
aEvent
-
>
mClass
)
ToChar
(
aEvent
-
>
mMessage
)
mozilla
:
:
layers
:
:
Stringify
(
aPointRelativeToRootFrame
)
.
c_str
(
)
ToString
(
aRootFrame
)
.
c_str
(
)
)
;
EventRadiusPrefs
prefs
(
aEvent
-
>
mClass
)
;
if
(
!
prefs
.
mEnabled
|
|
EventRetargetSuppression
:
:
IsActive
(
)
)
{
PET_LOG
(
"
Retargeting
disabled
\
n
"
)
;
return
target
;
}
nsIContent
*
clickableAncestor
=
nullptr
;
if
(
target
)
{
clickableAncestor
=
GetClickableAncestor
(
target
nsGkAtoms
:
:
body
)
;
if
(
clickableAncestor
)
{
PET_LOG
(
"
Target
%
p
is
clickable
\
n
"
target
)
;
clickableAncestor
=
target
-
>
GetContent
(
)
;
}
}
if
(
aEvent
-
>
mClass
=
=
eMouseEventClass
&
&
prefs
.
mTouchOnly
&
&
aEvent
-
>
AsMouseEvent
(
)
-
>
mInputSource
!
=
MouseEvent_Binding
:
:
MOZ_SOURCE_TOUCH
)
{
PET_LOG
(
"
Mouse
input
event
is
not
from
a
touch
source
\
n
"
)
;
return
target
;
}
const
nsIFrame
*
restrictToDescendants
=
target
?
target
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
:
aRootFrame
.
mFrame
;
nsRect
targetRect
=
GetTargetRect
(
aRootFrame
aPointRelativeToRootFrame
restrictToDescendants
prefs
aFlags
)
;
PET_LOG
(
"
Expanded
point
to
target
rect
%
s
\
n
"
mozilla
:
:
layers
:
:
Stringify
(
targetRect
)
.
c_str
(
)
)
;
AutoTArray
<
nsIFrame
*
8
>
candidates
;
nsresult
rv
=
nsLayoutUtils
:
:
GetFramesForArea
(
aRootFrame
targetRect
candidates
options
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
target
;
}
nsIFrame
*
closestClickable
=
GetClosest
(
aRootFrame
aPointRelativeToRootFrame
targetRect
prefs
restrictToDescendants
clickableAncestor
candidates
)
;
if
(
closestClickable
)
{
target
=
closestClickable
;
}
PET_LOG
(
"
Final
target
is
%
p
\
n
"
target
)
;
#
ifdef
DEBUG_FRAME_DUMP
if
(
MOZ_LOG_TEST
(
sEvtTgtLog
LogLevel
:
:
Verbose
)
)
{
aRootFrame
.
mFrame
-
>
DumpFrameTree
(
)
;
}
#
endif
if
(
!
target
|
|
!
prefs
.
mReposition
)
{
return
target
;
}
nsPoint
point
=
aPointRelativeToRootFrame
;
if
(
nsLayoutUtils
:
:
TRANSFORM_SUCCEEDED
!
=
nsLayoutUtils
:
:
TransformPoint
(
aRootFrame
RelativeTo
{
target
}
point
)
)
{
return
target
;
}
point
=
target
-
>
GetRectRelativeToSelf
(
)
.
ClampPoint
(
point
)
;
if
(
nsLayoutUtils
:
:
TRANSFORM_SUCCEEDED
!
=
nsLayoutUtils
:
:
TransformPoint
(
RelativeTo
{
target
}
aRootFrame
point
)
)
{
return
target
;
}
nsView
*
view
=
aRootFrame
.
mFrame
-
>
GetView
(
)
;
if
(
!
view
)
{
return
target
;
}
LayoutDeviceIntPoint
widgetPoint
=
nsLayoutUtils
:
:
TranslateViewToWidget
(
aRootFrame
.
mFrame
-
>
PresContext
(
)
view
point
aRootFrame
.
mViewportType
aEvent
-
>
mWidget
)
;
if
(
widgetPoint
.
x
!
=
NS_UNCONSTRAINEDSIZE
)
{
aEvent
-
>
mRefPoint
=
widgetPoint
;
}
return
target
;
}
uint32_t
EventRetargetSuppression
:
:
sSuppressionCount
=
0
;
EventRetargetSuppression
:
:
EventRetargetSuppression
(
)
{
sSuppressionCount
+
+
;
}
EventRetargetSuppression
:
:
~
EventRetargetSuppression
(
)
{
sSuppressionCount
-
-
;
}
bool
EventRetargetSuppression
:
:
IsActive
(
)
{
return
sSuppressionCount
>
0
;
}
}
