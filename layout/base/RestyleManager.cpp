#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
mozilla
/
RestyleManagerInlines
.
h
"
#
include
"
Layers
.
h
"
#
include
"
LayerAnimationInfo
.
h
"
#
include
"
mozilla
/
StyleSetHandleInlines
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIPresShellInlines
.
h
"
#
include
"
nsStyleUtil
.
h
"
#
include
"
StickyScrollContainer
.
h
"
#
include
"
mozilla
/
EffectSet
.
h
"
#
include
"
mozilla
/
ViewportFrame
.
h
"
#
include
"
SVGTextFrame
.
h
"
#
include
"
ActiveLayerTracker
.
h
"
#
include
"
nsSVGIntegrationUtils
.
h
"
namespace
mozilla
{
RestyleManager
:
:
RestyleManager
(
StyleBackendType
aType
nsPresContext
*
aPresContext
)
:
mPresContext
(
aPresContext
)
mRestyleGeneration
(
1
)
mUndisplayedRestyleGeneration
(
1
)
mHoverGeneration
(
0
)
mType
(
aType
)
mInStyleRefresh
(
false
)
mAnimationGeneration
(
0
)
{
MOZ_ASSERT
(
mPresContext
)
;
}
void
RestyleManager
:
:
ContentInserted
(
nsINode
*
aContainer
nsIContent
*
aChild
)
{
RestyleForInsertOrChange
(
aContainer
aChild
)
;
}
void
RestyleManager
:
:
ContentAppended
(
nsIContent
*
aContainer
nsIContent
*
aFirstNewContent
)
{
RestyleForAppend
(
aContainer
aFirstNewContent
)
;
}
void
RestyleManager
:
:
RestyleForEmptyChange
(
Element
*
aContainer
)
{
nsRestyleHint
hint
=
eRestyle_Subtree
;
nsIContent
*
grandparent
=
aContainer
-
>
GetParent
(
)
;
if
(
grandparent
&
&
(
grandparent
-
>
GetFlags
(
)
&
NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS
)
)
{
hint
=
nsRestyleHint
(
hint
|
eRestyle_LaterSiblings
)
;
}
PostRestyleEvent
(
aContainer
hint
nsChangeHint
(
0
)
)
;
}
void
RestyleManager
:
:
RestyleForAppend
(
nsIContent
*
aContainer
nsIContent
*
aFirstNewContent
)
{
if
(
!
aContainer
-
>
IsElement
(
)
)
{
return
;
}
Element
*
container
=
aContainer
-
>
AsElement
(
)
;
#
ifdef
DEBUG
{
for
(
nsIContent
*
cur
=
aFirstNewContent
;
cur
;
cur
=
cur
-
>
GetNextSibling
(
)
)
{
NS_ASSERTION
(
!
cur
-
>
IsRootOfAnonymousSubtree
(
)
"
anonymous
nodes
should
not
be
in
child
lists
"
)
;
}
}
#
endif
uint32_t
selectorFlags
=
container
-
>
GetFlags
(
)
&
(
NODE_ALL_SELECTOR_FLAGS
&
~
NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS
)
;
if
(
selectorFlags
=
=
0
)
return
;
if
(
selectorFlags
&
NODE_HAS_EMPTY_SELECTOR
)
{
bool
wasEmpty
=
true
;
for
(
nsIContent
*
cur
=
container
-
>
GetFirstChild
(
)
;
cur
!
=
aFirstNewContent
;
cur
=
cur
-
>
GetNextSibling
(
)
)
{
if
(
nsStyleUtil
:
:
IsSignificantChild
(
cur
true
false
)
)
{
wasEmpty
=
false
;
break
;
}
}
if
(
wasEmpty
)
{
RestyleForEmptyChange
(
container
)
;
return
;
}
}
if
(
selectorFlags
&
NODE_HAS_SLOW_SELECTOR
)
{
PostRestyleEvent
(
container
eRestyle_Subtree
nsChangeHint
(
0
)
)
;
return
;
}
if
(
selectorFlags
&
NODE_HAS_EDGE_CHILD_SELECTOR
)
{
for
(
nsIContent
*
cur
=
aFirstNewContent
-
>
GetPreviousSibling
(
)
;
cur
;
cur
=
cur
-
>
GetPreviousSibling
(
)
)
{
if
(
cur
-
>
IsElement
(
)
)
{
PostRestyleEvent
(
cur
-
>
AsElement
(
)
eRestyle_Subtree
nsChangeHint
(
0
)
)
;
break
;
}
}
}
}
static
void
RestyleSiblingsStartingWith
(
RestyleManager
*
aRestyleManager
nsIContent
*
aStartingSibling
)
{
for
(
nsIContent
*
sibling
=
aStartingSibling
;
sibling
;
sibling
=
sibling
-
>
GetNextSibling
(
)
)
{
if
(
sibling
-
>
IsElement
(
)
)
{
aRestyleManager
-
>
PostRestyleEvent
(
sibling
-
>
AsElement
(
)
nsRestyleHint
(
eRestyle_Subtree
|
eRestyle_LaterSiblings
)
nsChangeHint
(
0
)
)
;
break
;
}
}
}
void
RestyleManager
:
:
RestyleForInsertOrChange
(
nsINode
*
aContainer
nsIContent
*
aChild
)
{
if
(
!
aContainer
-
>
IsElement
(
)
)
{
return
;
}
Element
*
container
=
aContainer
-
>
AsElement
(
)
;
NS_ASSERTION
(
!
aChild
-
>
IsRootOfAnonymousSubtree
(
)
"
anonymous
nodes
should
not
be
in
child
lists
"
)
;
uint32_t
selectorFlags
=
container
-
>
GetFlags
(
)
&
NODE_ALL_SELECTOR_FLAGS
;
if
(
selectorFlags
=
=
0
)
return
;
if
(
selectorFlags
&
NODE_HAS_EMPTY_SELECTOR
)
{
bool
wasEmpty
=
true
;
for
(
nsIContent
*
child
=
container
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
=
=
aChild
)
continue
;
if
(
nsStyleUtil
:
:
IsSignificantChild
(
child
true
false
)
)
{
wasEmpty
=
false
;
break
;
}
}
if
(
wasEmpty
)
{
RestyleForEmptyChange
(
container
)
;
return
;
}
}
if
(
selectorFlags
&
NODE_HAS_SLOW_SELECTOR
)
{
PostRestyleEvent
(
container
eRestyle_Subtree
nsChangeHint
(
0
)
)
;
return
;
}
if
(
selectorFlags
&
NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS
)
{
RestyleSiblingsStartingWith
(
this
aChild
-
>
GetNextSibling
(
)
)
;
}
if
(
selectorFlags
&
NODE_HAS_EDGE_CHILD_SELECTOR
)
{
bool
passedChild
=
false
;
for
(
nsIContent
*
content
=
container
-
>
GetFirstChild
(
)
;
content
;
content
=
content
-
>
GetNextSibling
(
)
)
{
if
(
content
=
=
aChild
)
{
passedChild
=
true
;
continue
;
}
if
(
content
-
>
IsElement
(
)
)
{
if
(
passedChild
)
{
PostRestyleEvent
(
content
-
>
AsElement
(
)
eRestyle_Subtree
nsChangeHint
(
0
)
)
;
}
break
;
}
}
passedChild
=
false
;
for
(
nsIContent
*
content
=
container
-
>
GetLastChild
(
)
;
content
;
content
=
content
-
>
GetPreviousSibling
(
)
)
{
if
(
content
=
=
aChild
)
{
passedChild
=
true
;
continue
;
}
if
(
content
-
>
IsElement
(
)
)
{
if
(
passedChild
)
{
PostRestyleEvent
(
content
-
>
AsElement
(
)
eRestyle_Subtree
nsChangeHint
(
0
)
)
;
}
break
;
}
}
}
}
void
RestyleManager
:
:
ContentRemoved
(
nsINode
*
aContainer
nsIContent
*
aOldChild
nsIContent
*
aFollowingSibling
)
{
if
(
!
aContainer
-
>
IsElement
(
)
)
{
return
;
}
Element
*
container
=
aContainer
-
>
AsElement
(
)
;
if
(
aOldChild
-
>
IsRootOfAnonymousSubtree
(
)
)
{
MOZ_ASSERT
(
aOldChild
-
>
GetProperty
(
nsGkAtoms
:
:
restylableAnonymousNode
)
"
anonymous
nodes
should
not
be
in
child
lists
(
bug
439258
)
"
)
;
}
uint32_t
selectorFlags
=
container
-
>
GetFlags
(
)
&
NODE_ALL_SELECTOR_FLAGS
;
if
(
selectorFlags
=
=
0
)
return
;
if
(
selectorFlags
&
NODE_HAS_EMPTY_SELECTOR
)
{
bool
isEmpty
=
true
;
for
(
nsIContent
*
child
=
container
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
nsStyleUtil
:
:
IsSignificantChild
(
child
true
false
)
)
{
isEmpty
=
false
;
break
;
}
}
if
(
isEmpty
)
{
RestyleForEmptyChange
(
container
)
;
return
;
}
}
if
(
selectorFlags
&
NODE_HAS_SLOW_SELECTOR
)
{
PostRestyleEvent
(
container
eRestyle_Subtree
nsChangeHint
(
0
)
)
;
return
;
}
if
(
selectorFlags
&
NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS
)
{
RestyleSiblingsStartingWith
(
this
aFollowingSibling
)
;
}
if
(
selectorFlags
&
NODE_HAS_EDGE_CHILD_SELECTOR
)
{
bool
reachedFollowingSibling
=
false
;
for
(
nsIContent
*
content
=
container
-
>
GetFirstChild
(
)
;
content
;
content
=
content
-
>
GetNextSibling
(
)
)
{
if
(
content
=
=
aFollowingSibling
)
{
reachedFollowingSibling
=
true
;
}
if
(
content
-
>
IsElement
(
)
)
{
if
(
reachedFollowingSibling
)
{
PostRestyleEvent
(
content
-
>
AsElement
(
)
eRestyle_Subtree
nsChangeHint
(
0
)
)
;
}
break
;
}
}
reachedFollowingSibling
=
(
aFollowingSibling
=
=
nullptr
)
;
for
(
nsIContent
*
content
=
container
-
>
GetLastChild
(
)
;
content
;
content
=
content
-
>
GetPreviousSibling
(
)
)
{
if
(
content
-
>
IsElement
(
)
)
{
if
(
reachedFollowingSibling
)
{
PostRestyleEvent
(
content
-
>
AsElement
(
)
eRestyle_Subtree
nsChangeHint
(
0
)
)
;
}
break
;
}
if
(
content
=
=
aFollowingSibling
)
{
reachedFollowingSibling
=
true
;
}
}
}
}
void
RestyleManager
:
:
ContentStateChangedInternal
(
Element
*
aElement
EventStates
aStateMask
nsChangeHint
*
aOutChangeHint
)
{
MOZ_ASSERT
(
!
mInStyleRefresh
)
;
MOZ_ASSERT
(
aOutChangeHint
)
;
*
aOutChangeHint
=
nsChangeHint
(
0
)
;
nsIFrame
*
primaryFrame
=
aElement
-
>
GetPrimaryFrame
(
)
;
if
(
primaryFrame
)
{
if
(
!
primaryFrame
-
>
IsGeneratedContentFrame
(
)
&
&
aStateMask
.
HasAtLeastOneOfStates
(
NS_EVENT_STATE_BROKEN
|
NS_EVENT_STATE_USERDISABLED
|
NS_EVENT_STATE_SUPPRESSED
|
NS_EVENT_STATE_LOADING
)
)
{
*
aOutChangeHint
=
nsChangeHint_ReconstructFrame
;
}
else
{
uint8_t
app
=
primaryFrame
-
>
StyleDisplay
(
)
-
>
mAppearance
;
if
(
app
)
{
nsITheme
*
theme
=
PresContext
(
)
-
>
GetTheme
(
)
;
if
(
theme
&
&
theme
-
>
ThemeSupportsWidget
(
PresContext
(
)
primaryFrame
app
)
)
{
bool
repaint
=
false
;
theme
-
>
WidgetStateChanged
(
primaryFrame
app
nullptr
&
repaint
nullptr
)
;
if
(
repaint
)
{
*
aOutChangeHint
|
=
nsChangeHint_RepaintFrame
;
}
}
}
}
primaryFrame
-
>
ContentStatesChanged
(
aStateMask
)
;
}
if
(
aStateMask
.
HasState
(
NS_EVENT_STATE_VISITED
)
)
{
*
aOutChangeHint
|
=
nsChangeHint_RepaintFrame
;
}
}
nsCString
RestyleManager
:
:
RestyleHintToString
(
nsRestyleHint
aHint
)
{
nsCString
result
;
bool
any
=
false
;
const
char
*
names
[
]
=
{
"
Self
"
"
SomeDescendants
"
"
Subtree
"
"
LaterSiblings
"
"
CSSTransitions
"
"
CSSAnimations
"
"
StyleAttribute
"
"
StyleAttribute_Animations
"
"
Force
"
"
ForceDescendants
"
}
;
uint32_t
hint
=
aHint
&
(
(
1
<
<
ArrayLength
(
names
)
)
-
1
)
;
uint32_t
rest
=
aHint
&
~
(
(
1
<
<
ArrayLength
(
names
)
)
-
1
)
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
names
)
;
i
+
+
)
{
if
(
hint
&
(
1
<
<
i
)
)
{
if
(
any
)
{
result
.
AppendLiteral
(
"
|
"
)
;
}
result
.
AppendPrintf
(
"
eRestyle_
%
s
"
names
[
i
]
)
;
any
=
true
;
}
}
if
(
rest
)
{
if
(
any
)
{
result
.
AppendLiteral
(
"
|
"
)
;
}
result
.
AppendPrintf
(
"
0x
%
0x
"
rest
)
;
}
else
{
if
(
!
any
)
{
result
.
AppendLiteral
(
"
0
"
)
;
}
}
return
result
;
}
#
ifdef
DEBUG
nsCString
RestyleManager
:
:
ChangeHintToString
(
nsChangeHint
aHint
)
{
nsCString
result
;
bool
any
=
false
;
const
char
*
names
[
]
=
{
"
RepaintFrame
"
"
NeedReflow
"
"
ClearAncestorIntrinsics
"
"
ClearDescendantIntrinsics
"
"
NeedDirtyReflow
"
"
SyncFrameView
"
"
UpdateCursor
"
"
UpdateEffects
"
"
UpdateOpacityLayer
"
"
UpdateTransformLayer
"
"
ReconstructFrame
"
"
UpdateOverflow
"
"
UpdateSubtreeOverflow
"
"
UpdatePostTransformOverflow
"
"
UpdateParentOverflow
"
"
ChildrenOnlyTransform
"
"
RecomputePosition
"
"
UpdateContainingBlock
"
"
BorderStyleNoneChange
"
"
UpdateTextPath
"
"
SchedulePaint
"
"
NeutralChange
"
"
InvalidateRenderingObservers
"
"
ReflowChangesSizeOrPosition
"
"
UpdateComputedBSize
"
"
UpdateUsesOpacity
"
"
UpdateBackgroundPosition
"
"
AddOrRemoveTransform
"
"
CSSOverflowChange
"
"
UpdateWidgetProperties
"
"
UpdateTableCellSpans
"
"
VisibilityChange
"
}
;
static_assert
(
nsChangeHint_AllHints
=
=
static_cast
<
uint32_t
>
(
(
1ull
<
<
ArrayLength
(
names
)
)
-
1
)
"
Name
list
doesn
'
t
match
change
hints
.
"
)
;
uint32_t
hint
=
aHint
&
static_cast
<
uint32_t
>
(
(
1ull
<
<
ArrayLength
(
names
)
)
-
1
)
;
uint32_t
rest
=
aHint
&
~
static_cast
<
uint32_t
>
(
(
1ull
<
<
ArrayLength
(
names
)
)
-
1
)
;
if
(
(
hint
&
NS_STYLE_HINT_REFLOW
)
=
=
NS_STYLE_HINT_REFLOW
)
{
result
.
AppendLiteral
(
"
NS_STYLE_HINT_REFLOW
"
)
;
hint
=
hint
&
~
NS_STYLE_HINT_REFLOW
;
any
=
true
;
}
else
if
(
(
hint
&
nsChangeHint_AllReflowHints
)
=
=
nsChangeHint_AllReflowHints
)
{
result
.
AppendLiteral
(
"
nsChangeHint_AllReflowHints
"
)
;
hint
=
hint
&
~
nsChangeHint_AllReflowHints
;
any
=
true
;
}
else
if
(
(
hint
&
NS_STYLE_HINT_VISUAL
)
=
=
NS_STYLE_HINT_VISUAL
)
{
result
.
AppendLiteral
(
"
NS_STYLE_HINT_VISUAL
"
)
;
hint
=
hint
&
~
NS_STYLE_HINT_VISUAL
;
any
=
true
;
}
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
names
)
;
i
+
+
)
{
if
(
hint
&
(
1u
<
<
i
)
)
{
if
(
any
)
{
result
.
AppendLiteral
(
"
|
"
)
;
}
result
.
AppendPrintf
(
"
nsChangeHint_
%
s
"
names
[
i
]
)
;
any
=
true
;
}
}
if
(
rest
)
{
if
(
any
)
{
result
.
AppendLiteral
(
"
|
"
)
;
}
result
.
AppendPrintf
(
"
0x
%
0x
"
rest
)
;
}
else
{
if
(
!
any
)
{
result
.
AppendLiteral
(
"
nsChangeHint
(
0
)
"
)
;
}
}
return
result
;
}
#
endif
#
ifdef
DEBUG
static
bool
gInApplyRenderingChangeToTree
=
false
;
#
endif
#
ifdef
DEBUG
#
ifdef
MOZ_OLD_STYLE
static
void
DumpContext
(
nsIFrame
*
aFrame
nsStyleContext
*
aContext
)
{
if
(
aFrame
)
{
fputs
(
"
frame
:
"
stdout
)
;
nsAutoString
name
;
aFrame
-
>
GetFrameName
(
name
)
;
fputs
(
NS_LossyConvertUTF16toASCII
(
name
)
.
get
(
)
stdout
)
;
fprintf
(
stdout
"
(
%
p
)
"
static_cast
<
void
*
>
(
aFrame
)
)
;
}
if
(
aContext
)
{
fprintf
(
stdout
"
style
:
%
p
"
static_cast
<
void
*
>
(
aContext
)
)
;
nsAtom
*
pseudoTag
=
aContext
-
>
GetPseudo
(
)
;
if
(
pseudoTag
)
{
nsAutoString
buffer
;
pseudoTag
-
>
ToString
(
buffer
)
;
fputs
(
NS_LossyConvertUTF16toASCII
(
buffer
)
.
get
(
)
stdout
)
;
fputs
(
"
"
stdout
)
;
}
fputs
(
"
{
}
\
n
"
stdout
)
;
}
}
static
void
VerifySameTree
(
GeckoStyleContext
*
aContext1
GeckoStyleContext
*
aContext2
)
{
GeckoStyleContext
*
top1
=
aContext1
;
GeckoStyleContext
*
top2
=
aContext2
;
GeckoStyleContext
*
parent
;
for
(
;
;
)
{
parent
=
top1
-
>
GetParent
(
)
;
if
(
!
parent
)
break
;
top1
=
parent
;
}
for
(
;
;
)
{
parent
=
top2
-
>
GetParent
(
)
;
if
(
!
parent
)
break
;
top2
=
parent
;
}
NS_ASSERTION
(
top1
=
=
top2
"
Style
contexts
are
not
in
the
same
style
context
tree
"
)
;
}
static
void
VerifyContextParent
(
nsIFrame
*
aFrame
GeckoStyleContext
*
aContext
GeckoStyleContext
*
aParentContext
)
{
if
(
!
aContext
)
{
aContext
=
aFrame
-
>
StyleContext
(
)
-
>
AsGecko
(
)
;
}
if
(
!
aParentContext
)
{
nsIFrame
*
providerFrame
;
nsStyleContext
*
parent
=
aFrame
-
>
GetParentStyleContext
(
&
providerFrame
)
;
aParentContext
=
parent
?
parent
-
>
AsGecko
(
)
:
nullptr
;
}
NS_ASSERTION
(
aContext
"
Failure
to
get
required
contexts
"
)
;
GeckoStyleContext
*
actualParentContext
=
aContext
-
>
GetParent
(
)
;
if
(
aParentContext
)
{
if
(
aParentContext
!
=
actualParentContext
)
{
DumpContext
(
aFrame
aContext
)
;
if
(
aContext
=
=
aParentContext
)
{
NS_ERROR
(
"
Using
parent
'
s
style
context
"
)
;
}
else
{
NS_ERROR
(
"
Wrong
parent
style
context
"
)
;
fputs
(
"
Wrong
parent
style
context
:
"
stdout
)
;
DumpContext
(
nullptr
actualParentContext
)
;
fputs
(
"
should
be
using
:
"
stdout
)
;
DumpContext
(
nullptr
aParentContext
)
;
VerifySameTree
(
actualParentContext
aParentContext
)
;
fputs
(
"
\
n
"
stdout
)
;
}
}
}
else
{
if
(
actualParentContext
)
{
NS_ERROR
(
"
Have
parent
context
and
shouldn
'
t
"
)
;
DumpContext
(
aFrame
aContext
)
;
fputs
(
"
Has
parent
context
:
"
stdout
)
;
DumpContext
(
nullptr
actualParentContext
)
;
fputs
(
"
Should
be
null
\
n
\
n
"
stdout
)
;
}
}
GeckoStyleContext
*
childStyleIfVisited
=
aContext
-
>
GetStyleIfVisited
(
)
;
if
(
childStyleIfVisited
&
&
!
(
(
childStyleIfVisited
-
>
RuleNode
(
)
!
=
aContext
-
>
RuleNode
(
)
&
&
childStyleIfVisited
-
>
GetParent
(
)
=
=
aContext
-
>
GetParent
(
)
)
|
|
childStyleIfVisited
-
>
GetParent
(
)
=
=
aContext
-
>
GetParent
(
)
-
>
GetStyleIfVisited
(
)
)
)
{
NS_ERROR
(
"
Visited
style
has
wrong
parent
"
)
;
DumpContext
(
aFrame
aContext
)
;
fputs
(
"
\
n
"
stdout
)
;
}
}
static
void
VerifyStyleTree
(
nsIFrame
*
aFrame
)
{
GeckoStyleContext
*
context
=
aFrame
-
>
StyleContext
(
)
-
>
AsGecko
(
)
;
VerifyContextParent
(
aFrame
context
nullptr
)
;
nsIFrame
:
:
ChildListIterator
lists
(
aFrame
)
;
for
(
;
!
lists
.
IsDone
(
)
;
lists
.
Next
(
)
)
{
for
(
nsIFrame
*
child
:
lists
.
CurrentList
(
)
)
{
if
(
!
(
child
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
)
{
if
(
child
-
>
IsPlaceholderFrame
(
)
)
{
nsIFrame
*
outOfFlowFrame
=
nsPlaceholderFrame
:
:
GetRealFrameForPlaceholder
(
child
)
;
do
{
VerifyStyleTree
(
outOfFlowFrame
)
;
}
while
(
(
outOfFlowFrame
=
outOfFlowFrame
-
>
GetNextContinuation
(
)
)
)
;
VerifyContextParent
(
child
nullptr
nullptr
)
;
}
else
{
VerifyStyleTree
(
child
)
;
}
}
}
}
int32_t
contextIndex
=
0
;
for
(
nsStyleContext
*
extraContext
;
(
extraContext
=
aFrame
-
>
GetAdditionalStyleContext
(
contextIndex
)
)
;
+
+
contextIndex
)
{
VerifyContextParent
(
aFrame
extraContext
-
>
AsGecko
(
)
context
)
;
}
}
#
endif
void
RestyleManager
:
:
DebugVerifyStyleTree
(
nsIFrame
*
aFrame
)
{
if
(
IsServo
(
)
)
{
return
;
}
#
ifdef
MOZ_OLD_STYLE
if
(
aFrame
)
{
VerifyStyleTree
(
aFrame
)
;
}
#
else
MOZ_CRASH
(
"
old
style
system
disabled
"
)
;
#
endif
}
#
endif
static
void
SyncViewsAndInvalidateDescendants
(
nsIFrame
*
aFrame
nsChangeHint
aChange
)
;
static
void
StyleChangeReflow
(
nsIFrame
*
aFrame
nsChangeHint
aHint
)
;
static
nsIFrame
*
GetFrameForChildrenOnlyTransformHint
(
nsIFrame
*
aFrame
)
{
if
(
aFrame
-
>
IsViewportFrame
(
)
)
{
aFrame
=
aFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
}
aFrame
=
aFrame
-
>
GetContent
(
)
-
>
GetPrimaryFrame
(
)
;
if
(
aFrame
-
>
IsSVGOuterSVGFrame
(
)
)
{
aFrame
=
aFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
MOZ_ASSERT
(
aFrame
-
>
IsSVGOuterSVGAnonChildFrame
(
)
"
Where
is
the
nsSVGOuterSVGFrame
'
s
anon
child
?
?
"
)
;
}
MOZ_ASSERT
(
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
|
nsIFrame
:
:
eSVGContainer
)
"
Children
-
only
transforms
only
expected
on
SVG
frames
"
)
;
return
aFrame
;
}
bool
RecomputePosition
(
nsIFrame
*
aFrame
)
{
if
(
aFrame
-
>
IsTableFrame
(
)
)
{
return
true
;
}
const
nsStyleDisplay
*
display
=
aFrame
-
>
StyleDisplay
(
)
;
if
(
display
-
>
mPosition
=
=
NS_STYLE_POSITION_STATIC
)
{
return
true
;
}
if
(
aFrame
-
>
HasView
(
)
|
|
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_HAS_CHILD_WITH_VIEW
)
)
{
StyleChangeReflow
(
aFrame
nsChangeHint_NeedReflow
)
;
return
false
;
}
if
(
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
)
{
nsIFrame
*
ph
=
aFrame
-
>
GetPlaceholderFrame
(
)
;
if
(
ph
&
&
ph
-
>
HasAnyStateBits
(
PLACEHOLDER_STATICPOS_NEEDS_CSSALIGN
)
)
{
StyleChangeReflow
(
aFrame
nsChangeHint_NeedReflow
)
;
return
false
;
}
}
aFrame
-
>
SchedulePaint
(
)
;
if
(
display
-
>
IsRelativelyPositionedStyle
(
)
)
{
if
(
display
-
>
mPosition
=
=
NS_STYLE_POSITION_STICKY
)
{
nsIFrame
*
firstContinuation
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
aFrame
)
;
StickyScrollContainer
:
:
ComputeStickyOffsets
(
firstContinuation
)
;
StickyScrollContainer
*
ssc
=
StickyScrollContainer
:
:
GetStickyScrollContainerForFrame
(
firstContinuation
)
;
if
(
ssc
)
{
ssc
-
>
PositionContinuations
(
firstContinuation
)
;
}
}
else
{
MOZ_ASSERT
(
NS_STYLE_POSITION_RELATIVE
=
=
display
-
>
mPosition
"
Unexpected
type
of
positioning
"
)
;
for
(
nsIFrame
*
cont
=
aFrame
;
cont
;
cont
=
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
cont
)
)
{
nsIFrame
*
cb
=
cont
-
>
GetContainingBlock
(
)
;
nsMargin
newOffsets
;
WritingMode
wm
=
cb
-
>
GetWritingMode
(
)
;
const
LogicalSize
size
(
wm
cb
-
>
GetContentRectRelativeToSelf
(
)
.
Size
(
)
)
;
ReflowInput
:
:
ComputeRelativeOffsets
(
wm
cont
size
newOffsets
)
;
NS_ASSERTION
(
newOffsets
.
left
=
=
-
newOffsets
.
right
&
&
newOffsets
.
top
=
=
-
newOffsets
.
bottom
"
ComputeRelativeOffsets
should
return
valid
results
"
)
;
bool
hasProperty
;
nsPoint
normalPosition
=
cont
-
>
GetNormalPosition
(
&
hasProperty
)
;
if
(
!
hasProperty
)
{
cont
-
>
AddProperty
(
nsIFrame
:
:
NormalPositionProperty
(
)
new
nsPoint
(
normalPosition
)
)
;
}
cont
-
>
SetPosition
(
normalPosition
+
nsPoint
(
newOffsets
.
left
newOffsets
.
top
)
)
;
}
}
return
true
;
}
RefPtr
<
gfxContext
>
rc
=
aFrame
-
>
PresShell
(
)
-
>
CreateReferenceRenderingContext
(
)
;
nsIFrame
*
parentFrame
=
aFrame
-
>
GetParent
(
)
;
WritingMode
parentWM
=
parentFrame
-
>
GetWritingMode
(
)
;
WritingMode
frameWM
=
aFrame
-
>
GetWritingMode
(
)
;
LogicalSize
parentSize
=
parentFrame
-
>
GetLogicalSize
(
)
;
nsFrameState
savedState
=
parentFrame
-
>
GetStateBits
(
)
;
ReflowInput
parentReflowInput
(
aFrame
-
>
PresContext
(
)
parentFrame
rc
parentSize
)
;
parentFrame
-
>
RemoveStateBits
(
~
nsFrameState
(
0
)
)
;
parentFrame
-
>
AddStateBits
(
savedState
)
;
Maybe
<
ReflowInput
>
cbReflowInput
;
nsIFrame
*
cbFrame
=
parentFrame
-
>
GetContainingBlock
(
)
;
if
(
cbFrame
&
&
(
aFrame
-
>
GetContainingBlock
(
)
!
=
parentFrame
|
|
parentFrame
-
>
IsTableFrame
(
)
)
)
{
LogicalSize
cbSize
=
cbFrame
-
>
GetLogicalSize
(
)
;
cbReflowInput
.
emplace
(
cbFrame
-
>
PresContext
(
)
cbFrame
rc
cbSize
)
;
cbReflowInput
-
>
ComputedPhysicalMargin
(
)
=
cbFrame
-
>
GetUsedMargin
(
)
;
cbReflowInput
-
>
ComputedPhysicalPadding
(
)
=
cbFrame
-
>
GetUsedPadding
(
)
;
cbReflowInput
-
>
ComputedPhysicalBorderPadding
(
)
=
cbFrame
-
>
GetUsedBorderAndPadding
(
)
;
parentReflowInput
.
mCBReflowInput
=
cbReflowInput
.
ptr
(
)
;
}
NS_WARNING_ASSERTION
(
parentSize
.
ISize
(
parentWM
)
!
=
NS_INTRINSICSIZE
&
&
parentSize
.
BSize
(
parentWM
)
!
=
NS_INTRINSICSIZE
"
parentSize
should
be
valid
"
)
;
parentReflowInput
.
SetComputedISize
(
std
:
:
max
(
parentSize
.
ISize
(
parentWM
)
0
)
)
;
parentReflowInput
.
SetComputedBSize
(
std
:
:
max
(
parentSize
.
BSize
(
parentWM
)
0
)
)
;
parentReflowInput
.
ComputedPhysicalMargin
(
)
.
SizeTo
(
0
0
0
0
)
;
parentReflowInput
.
ComputedPhysicalPadding
(
)
=
parentFrame
-
>
GetUsedPadding
(
)
;
parentReflowInput
.
ComputedPhysicalBorderPadding
(
)
=
parentFrame
-
>
GetUsedBorderAndPadding
(
)
;
LogicalSize
availSize
=
parentSize
.
ConvertTo
(
frameWM
parentWM
)
;
availSize
.
BSize
(
frameWM
)
=
NS_INTRINSICSIZE
;
ViewportFrame
*
viewport
=
do_QueryFrame
(
parentFrame
)
;
nsSize
cbSize
=
viewport
?
viewport
-
>
AdjustReflowInputAsContainingBlock
(
&
parentReflowInput
)
.
Size
(
)
:
aFrame
-
>
GetContainingBlock
(
)
-
>
GetSize
(
)
;
const
nsMargin
&
parentBorder
=
parentReflowInput
.
mStyleBorder
-
>
GetComputedBorder
(
)
;
cbSize
-
=
nsSize
(
parentBorder
.
LeftRight
(
)
parentBorder
.
TopBottom
(
)
)
;
LogicalSize
lcbSize
(
frameWM
cbSize
)
;
ReflowInput
reflowInput
(
aFrame
-
>
PresContext
(
)
parentReflowInput
aFrame
availSize
&
lcbSize
)
;
nsSize
computedSize
(
reflowInput
.
ComputedWidth
(
)
reflowInput
.
ComputedHeight
(
)
)
;
computedSize
.
width
+
=
reflowInput
.
ComputedPhysicalBorderPadding
(
)
.
LeftRight
(
)
;
if
(
computedSize
.
height
!
=
NS_INTRINSICSIZE
)
{
computedSize
.
height
+
=
reflowInput
.
ComputedPhysicalBorderPadding
(
)
.
TopBottom
(
)
;
}
nsSize
size
=
aFrame
-
>
GetSize
(
)
;
if
(
computedSize
.
width
=
=
size
.
width
&
&
(
computedSize
.
height
=
=
NS_INTRINSICSIZE
|
|
computedSize
.
height
=
=
size
.
height
)
)
{
if
(
NS_AUTOOFFSET
=
=
reflowInput
.
ComputedPhysicalOffsets
(
)
.
left
)
{
reflowInput
.
ComputedPhysicalOffsets
(
)
.
left
=
cbSize
.
width
-
reflowInput
.
ComputedPhysicalOffsets
(
)
.
right
-
reflowInput
.
ComputedPhysicalMargin
(
)
.
right
-
size
.
width
-
reflowInput
.
ComputedPhysicalMargin
(
)
.
left
;
}
if
(
NS_AUTOOFFSET
=
=
reflowInput
.
ComputedPhysicalOffsets
(
)
.
top
)
{
reflowInput
.
ComputedPhysicalOffsets
(
)
.
top
=
cbSize
.
height
-
reflowInput
.
ComputedPhysicalOffsets
(
)
.
bottom
-
reflowInput
.
ComputedPhysicalMargin
(
)
.
bottom
-
size
.
height
-
reflowInput
.
ComputedPhysicalMargin
(
)
.
top
;
}
nsPoint
pos
(
parentBorder
.
left
+
reflowInput
.
ComputedPhysicalOffsets
(
)
.
left
+
reflowInput
.
ComputedPhysicalMargin
(
)
.
left
parentBorder
.
top
+
reflowInput
.
ComputedPhysicalOffsets
(
)
.
top
+
reflowInput
.
ComputedPhysicalMargin
(
)
.
top
)
;
aFrame
-
>
SetPosition
(
pos
)
;
return
true
;
}
StyleChangeReflow
(
aFrame
nsChangeHint_NeedReflow
)
;
return
false
;
}
static
bool
HasBoxAncestor
(
nsIFrame
*
aFrame
)
{
for
(
nsIFrame
*
f
=
aFrame
;
f
;
f
=
f
-
>
GetParent
(
)
)
{
if
(
f
-
>
IsXULBoxFrame
(
)
)
{
return
true
;
}
}
return
false
;
}
static
bool
FrameHasPositionedPlaceholderDescendants
(
nsIFrame
*
aFrame
uint32_t
aPositionMask
)
{
MOZ_ASSERT
(
aPositionMask
&
(
1
<
<
NS_STYLE_POSITION_FIXED
)
)
;
for
(
nsIFrame
:
:
ChildListIterator
lists
(
aFrame
)
;
!
lists
.
IsDone
(
)
;
lists
.
Next
(
)
)
{
for
(
nsIFrame
*
f
:
lists
.
CurrentList
(
)
)
{
if
(
f
-
>
IsPlaceholderFrame
(
)
)
{
nsIFrame
*
outOfFlow
=
nsPlaceholderFrame
:
:
GetRealFrameForPlaceholder
(
f
)
;
NS_ASSERTION
(
!
nsSVGUtils
:
:
IsInSVGTextSubtree
(
outOfFlow
)
"
SVG
text
frames
can
'
t
be
out
of
flow
"
)
;
if
(
aPositionMask
&
(
1
<
<
outOfFlow
-
>
StyleDisplay
(
)
-
>
mPosition
)
)
{
return
true
;
}
}
uint32_t
positionMask
=
aPositionMask
;
if
(
FrameHasPositionedPlaceholderDescendants
(
f
positionMask
)
)
{
return
true
;
}
}
}
return
false
;
}
static
bool
NeedToReframeForAddingOrRemovingTransform
(
nsIFrame
*
aFrame
)
{
static_assert
(
0
<
=
NS_STYLE_POSITION_ABSOLUTE
&
&
NS_STYLE_POSITION_ABSOLUTE
<
32
"
Style
constant
out
of
range
"
)
;
static_assert
(
0
<
=
NS_STYLE_POSITION_FIXED
&
&
NS_STYLE_POSITION_FIXED
<
32
"
Style
constant
out
of
range
"
)
;
uint32_t
positionMask
;
if
(
aFrame
-
>
IsAbsolutelyPositioned
(
)
|
|
aFrame
-
>
IsRelativelyPositioned
(
)
)
{
positionMask
=
1
<
<
NS_STYLE_POSITION_FIXED
;
}
else
{
positionMask
=
(
1
<
<
NS_STYLE_POSITION_FIXED
)
|
(
1
<
<
NS_STYLE_POSITION_ABSOLUTE
)
;
}
for
(
nsIFrame
*
f
=
aFrame
;
f
;
f
=
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
f
)
)
{
if
(
FrameHasPositionedPlaceholderDescendants
(
f
positionMask
)
)
{
return
true
;
}
}
return
false
;
}
static
void
DoApplyRenderingChangeToTree
(
nsIFrame
*
aFrame
nsChangeHint
aChange
)
{
NS_PRECONDITION
(
gInApplyRenderingChangeToTree
"
should
only
be
called
within
ApplyRenderingChangeToTree
"
)
;
for
(
;
aFrame
;
aFrame
=
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
aFrame
)
)
{
SyncViewsAndInvalidateDescendants
(
aFrame
nsChangeHint
(
aChange
&
(
nsChangeHint_RepaintFrame
|
nsChangeHint_SyncFrameView
|
nsChangeHint_UpdateOpacityLayer
|
nsChangeHint_SchedulePaint
)
)
)
;
bool
needInvalidatingPaint
=
false
;
if
(
aChange
&
nsChangeHint_RepaintFrame
)
{
needInvalidatingPaint
=
true
;
aFrame
-
>
InvalidateFrameSubtree
(
)
;
if
(
(
aChange
&
nsChangeHint_UpdateEffects
)
&
&
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
&
&
!
(
aFrame
-
>
GetStateBits
(
)
&
NS_STATE_IS_OUTER_SVG
)
)
{
nsSVGUtils
:
:
ScheduleReflowSVG
(
aFrame
)
;
}
}
if
(
aChange
&
nsChangeHint_UpdateTextPath
)
{
if
(
nsSVGUtils
:
:
IsInSVGTextSubtree
(
aFrame
)
)
{
NS_ASSERTION
(
aFrame
-
>
GetContent
(
)
-
>
IsSVGElement
(
nsGkAtoms
:
:
textPath
)
"
expected
frame
for
a
<
textPath
>
element
"
)
;
nsIFrame
*
text
=
nsLayoutUtils
:
:
GetClosestFrameOfType
(
aFrame
LayoutFrameType
:
:
SVGText
)
;
NS_ASSERTION
(
text
"
expected
to
find
an
ancestor
SVGTextFrame
"
)
;
static_cast
<
SVGTextFrame
*
>
(
text
)
-
>
NotifyGlyphMetricsChange
(
)
;
}
else
{
MOZ_ASSERT
(
false
"
unexpected
frame
got
nsChangeHint_UpdateTextPath
"
)
;
}
}
if
(
aChange
&
nsChangeHint_UpdateOpacityLayer
)
{
needInvalidatingPaint
=
true
;
ActiveLayerTracker
:
:
NotifyRestyle
(
aFrame
eCSSProperty_opacity
)
;
if
(
nsSVGIntegrationUtils
:
:
UsingEffectsForFrame
(
aFrame
)
)
{
aFrame
-
>
InvalidateFrameSubtree
(
)
;
}
}
if
(
(
aChange
&
nsChangeHint_UpdateTransformLayer
)
&
&
aFrame
-
>
IsTransformed
(
)
)
{
ActiveLayerTracker
:
:
NotifyRestyle
(
aFrame
eCSSProperty_transform
)
;
if
(
!
needInvalidatingPaint
)
{
Layer
*
layer
;
needInvalidatingPaint
|
=
!
aFrame
-
>
TryUpdateTransformOnly
(
&
layer
)
;
if
(
!
needInvalidatingPaint
)
{
MOZ_ASSERT
(
layer
"
this
can
'
t
happen
if
there
'
s
no
layer
"
)
;
nsDisplayListBuilder
:
:
AddAnimationsAndTransitionsToLayer
(
layer
nullptr
nullptr
aFrame
eCSSProperty_transform
)
;
}
}
}
if
(
aChange
&
nsChangeHint_ChildrenOnlyTransform
)
{
needInvalidatingPaint
=
true
;
nsIFrame
*
childFrame
=
GetFrameForChildrenOnlyTransformHint
(
aFrame
)
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
for
(
;
childFrame
;
childFrame
=
childFrame
-
>
GetNextSibling
(
)
)
{
ActiveLayerTracker
:
:
NotifyRestyle
(
childFrame
eCSSProperty_transform
)
;
}
}
if
(
aChange
&
nsChangeHint_SchedulePaint
)
{
needInvalidatingPaint
=
true
;
}
aFrame
-
>
SchedulePaint
(
needInvalidatingPaint
?
nsIFrame
:
:
PAINT_DEFAULT
:
nsIFrame
:
:
PAINT_COMPOSITE_ONLY
)
;
}
}
static
void
SyncViewsAndInvalidateDescendants
(
nsIFrame
*
aFrame
nsChangeHint
aChange
)
{
NS_PRECONDITION
(
gInApplyRenderingChangeToTree
"
should
only
be
called
within
ApplyRenderingChangeToTree
"
)
;
NS_ASSERTION
(
nsChangeHint_size_t
(
aChange
)
=
=
(
aChange
&
(
nsChangeHint_RepaintFrame
|
nsChangeHint_SyncFrameView
|
nsChangeHint_UpdateOpacityLayer
|
nsChangeHint_SchedulePaint
)
)
"
Invalid
change
flag
"
)
;
if
(
aChange
&
nsChangeHint_SyncFrameView
)
{
aFrame
-
>
SyncFrameViewProperties
(
)
;
}
nsIFrame
:
:
ChildListIterator
lists
(
aFrame
)
;
for
(
;
!
lists
.
IsDone
(
)
;
lists
.
Next
(
)
)
{
for
(
nsIFrame
*
child
:
lists
.
CurrentList
(
)
)
{
if
(
!
(
child
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
)
{
if
(
child
-
>
IsPlaceholderFrame
(
)
)
{
nsIFrame
*
outOfFlowFrame
=
nsPlaceholderFrame
:
:
GetRealFrameForPlaceholder
(
child
)
;
DoApplyRenderingChangeToTree
(
outOfFlowFrame
aChange
)
;
}
else
if
(
lists
.
CurrentID
(
)
=
=
nsIFrame
:
:
kPopupList
)
{
DoApplyRenderingChangeToTree
(
child
aChange
)
;
}
else
{
SyncViewsAndInvalidateDescendants
(
child
aChange
)
;
}
}
}
}
}
static
void
ApplyRenderingChangeToTree
(
nsIPresShell
*
aPresShell
nsIFrame
*
aFrame
nsChangeHint
aChange
)
{
NS_ASSERTION
(
!
(
aChange
&
nsChangeHint_UpdateTransformLayer
)
|
|
aFrame
-
>
IsTransformed
(
)
|
|
aFrame
-
>
StyleDisplay
(
)
-
>
HasTransformStyle
(
)
"
Unexpected
UpdateTransformLayer
hint
"
)
;
if
(
aPresShell
-
>
IsPaintingSuppressed
(
)
)
{
aChange
&
=
~
nsChangeHint_RepaintFrame
;
if
(
!
aChange
)
{
return
;
}
}
#
ifdef
DEBUG
gInApplyRenderingChangeToTree
=
true
;
#
endif
if
(
aChange
&
nsChangeHint_RepaintFrame
)
{
nsStyleContext
*
bgSC
;
nsIFrame
*
propagatedFrame
=
aFrame
;
while
(
!
nsCSSRendering
:
:
FindBackground
(
propagatedFrame
&
bgSC
)
)
{
propagatedFrame
=
propagatedFrame
-
>
GetParent
(
)
;
NS_ASSERTION
(
aFrame
"
root
frame
must
paint
"
)
;
}
if
(
propagatedFrame
!
=
aFrame
)
{
DoApplyRenderingChangeToTree
(
propagatedFrame
nsChangeHint_RepaintFrame
)
;
aChange
&
=
~
nsChangeHint_RepaintFrame
;
if
(
!
aChange
)
{
return
;
}
}
}
DoApplyRenderingChangeToTree
(
aFrame
aChange
)
;
#
ifdef
DEBUG
gInApplyRenderingChangeToTree
=
false
;
#
endif
}
static
void
AddSubtreeToOverflowTracker
(
nsIFrame
*
aFrame
OverflowChangedTracker
&
aOverflowChangedTracker
)
{
if
(
aFrame
-
>
FrameMaintainsOverflow
(
)
)
{
aOverflowChangedTracker
.
AddFrame
(
aFrame
OverflowChangedTracker
:
:
CHILDREN_CHANGED
)
;
}
nsIFrame
:
:
ChildListIterator
lists
(
aFrame
)
;
for
(
;
!
lists
.
IsDone
(
)
;
lists
.
Next
(
)
)
{
for
(
nsIFrame
*
child
:
lists
.
CurrentList
(
)
)
{
AddSubtreeToOverflowTracker
(
child
aOverflowChangedTracker
)
;
}
}
}
static
void
StyleChangeReflow
(
nsIFrame
*
aFrame
nsChangeHint
aHint
)
{
nsIPresShell
:
:
IntrinsicDirty
dirtyType
;
if
(
aHint
&
nsChangeHint_ClearDescendantIntrinsics
)
{
NS_ASSERTION
(
aHint
&
nsChangeHint_ClearAncestorIntrinsics
"
Please
read
the
comments
in
nsChangeHint
.
h
"
)
;
NS_ASSERTION
(
aHint
&
nsChangeHint_NeedDirtyReflow
"
ClearDescendantIntrinsics
requires
NeedDirtyReflow
"
)
;
dirtyType
=
nsIPresShell
:
:
eStyleChange
;
}
else
if
(
(
aHint
&
nsChangeHint_UpdateComputedBSize
)
&
&
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_DESCENDANT_INTRINSIC_ISIZE_DEPENDS_ON_BSIZE
)
)
{
dirtyType
=
nsIPresShell
:
:
eStyleChange
;
}
else
if
(
aHint
&
nsChangeHint_ClearAncestorIntrinsics
)
{
dirtyType
=
nsIPresShell
:
:
eTreeChange
;
}
else
if
(
(
aHint
&
nsChangeHint_UpdateComputedBSize
)
&
&
HasBoxAncestor
(
aFrame
)
)
{
dirtyType
=
nsIPresShell
:
:
eTreeChange
;
}
else
{
dirtyType
=
nsIPresShell
:
:
eResize
;
}
nsFrameState
dirtyBits
;
if
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_FIRST_REFLOW
)
{
dirtyBits
=
nsFrameState
(
0
)
;
}
else
if
(
(
aHint
&
nsChangeHint_NeedDirtyReflow
)
|
|
dirtyType
=
=
nsIPresShell
:
:
eStyleChange
)
{
dirtyBits
=
NS_FRAME_IS_DIRTY
;
}
else
{
dirtyBits
=
NS_FRAME_HAS_DIRTY_CHILDREN
;
}
if
(
dirtyType
=
=
nsIPresShell
:
:
eResize
&
&
!
dirtyBits
)
return
;
nsIPresShell
:
:
ReflowRootHandling
rootHandling
;
if
(
aHint
&
nsChangeHint_ReflowChangesSizeOrPosition
)
{
rootHandling
=
nsIPresShell
:
:
ePositionOrSizeChange
;
}
else
{
rootHandling
=
nsIPresShell
:
:
eNoPositionOrSizeChange
;
}
do
{
aFrame
-
>
PresShell
(
)
-
>
FrameNeedsReflow
(
aFrame
dirtyType
dirtyBits
rootHandling
)
;
aFrame
=
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
aFrame
)
;
}
while
(
aFrame
)
;
}
static
nsIContent
*
NextSiblingWhichMayHaveFrame
(
nsIContent
*
aContent
)
{
for
(
nsIContent
*
next
=
aContent
-
>
GetNextSibling
(
)
;
next
;
next
=
next
-
>
GetNextSibling
(
)
)
{
if
(
next
-
>
IsElement
(
)
|
|
next
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
{
return
next
;
}
}
return
nullptr
;
}
void
RestyleManager
:
:
ProcessRestyledFrames
(
nsStyleChangeList
&
aChangeList
)
{
NS_ASSERTION
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
Someone
forgot
a
script
blocker
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mDestroyedFrames
"
ProcessRestyledFrames
recursion
"
)
;
if
(
aChangeList
.
IsEmpty
(
)
)
{
return
;
}
typedef
decltype
(
mDestroyedFrames
)
DestroyedFramesT
;
class
MOZ_RAII
MaybeClearDestroyedFrames
{
private
:
DestroyedFramesT
&
mDestroyedFramesRef
;
const
bool
mResetOnDestruction
;
public
:
explicit
MaybeClearDestroyedFrames
(
DestroyedFramesT
&
aTarget
)
:
mDestroyedFramesRef
(
aTarget
)
mResetOnDestruction
(
!
aTarget
)
{
}
~
MaybeClearDestroyedFrames
(
)
{
if
(
mResetOnDestruction
)
{
mDestroyedFramesRef
.
reset
(
nullptr
)
;
}
}
}
;
MaybeClearDestroyedFrames
maybeClear
(
mDestroyedFrames
)
;
if
(
!
mDestroyedFrames
)
{
mDestroyedFrames
=
MakeUnique
<
nsTHashtable
<
nsPtrHashKey
<
const
nsIFrame
>
>
>
(
)
;
}
AUTO_PROFILER_LABEL
(
"
RestyleManager
:
:
ProcessRestyledFrames
"
CSS
)
;
nsPresContext
*
presContext
=
PresContext
(
)
;
nsCSSFrameConstructor
*
frameConstructor
=
presContext
-
>
FrameConstructor
(
)
;
for
(
nsStyleChangeData
&
data
:
aChangeList
)
{
if
(
data
.
mHint
&
nsChangeHint_CSSOverflowChange
)
{
data
.
mHint
&
=
~
nsChangeHint_CSSOverflowChange
;
bool
doReconstruct
=
true
;
if
(
data
.
mContent
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
body
nsGkAtoms
:
:
html
)
)
{
nsIContent
*
prevOverrideNode
=
presContext
-
>
GetViewportScrollbarStylesOverrideElement
(
)
;
nsIContent
*
newOverrideNode
=
presContext
-
>
UpdateViewportScrollbarStylesOverride
(
)
;
if
(
data
.
mContent
=
=
prevOverrideNode
|
|
data
.
mContent
=
=
newOverrideNode
)
{
if
(
!
prevOverrideNode
|
|
!
newOverrideNode
|
|
prevOverrideNode
=
=
newOverrideNode
)
{
data
.
mHint
|
=
(
nsChangeHint_ReflowHintsForISizeChange
|
nsChangeHint_ReflowHintsForBSizeChange
)
;
doReconstruct
=
false
;
}
}
}
if
(
doReconstruct
)
{
data
.
mHint
|
=
nsChangeHint_ReconstructFrame
;
}
}
}
bool
didUpdateCursor
=
false
;
for
(
size_t
i
=
0
;
i
<
aChangeList
.
Length
(
)
;
+
+
i
)
{
size_t
lazyRangeStart
=
i
;
while
(
i
<
aChangeList
.
Length
(
)
&
&
aChangeList
[
i
]
.
mContent
&
&
aChangeList
[
i
]
.
mContent
-
>
HasFlag
(
NODE_NEEDS_FRAME
)
&
&
(
i
=
=
lazyRangeStart
|
|
NextSiblingWhichMayHaveFrame
(
aChangeList
[
i
-
1
]
.
mContent
)
=
=
aChangeList
[
i
]
.
mContent
)
)
{
MOZ_ASSERT
(
aChangeList
[
i
]
.
mHint
&
nsChangeHint_ReconstructFrame
)
;
MOZ_ASSERT
(
!
aChangeList
[
i
]
.
mFrame
)
;
+
+
i
;
}
if
(
i
!
=
lazyRangeStart
)
{
nsIContent
*
start
=
aChangeList
[
lazyRangeStart
]
.
mContent
;
nsIContent
*
end
=
NextSiblingWhichMayHaveFrame
(
aChangeList
[
i
-
1
]
.
mContent
)
;
nsIContent
*
container
=
start
-
>
GetParent
(
)
;
MOZ_ASSERT
(
container
)
;
if
(
!
end
)
{
frameConstructor
-
>
ContentAppended
(
container
start
nsCSSFrameConstructor
:
:
InsertionKind
:
:
Sync
)
;
}
else
{
frameConstructor
-
>
ContentRangeInserted
(
container
start
end
nullptr
nsCSSFrameConstructor
:
:
InsertionKind
:
:
Sync
)
;
}
}
for
(
size_t
j
=
lazyRangeStart
;
j
<
i
;
+
+
j
)
{
MOZ_ASSERT
(
!
aChangeList
[
j
]
.
mContent
-
>
GetPrimaryFrame
(
)
|
|
!
aChangeList
[
j
]
.
mContent
-
>
HasFlag
(
NODE_NEEDS_FRAME
)
)
;
}
if
(
i
=
=
aChangeList
.
Length
(
)
)
{
break
;
}
const
nsStyleChangeData
&
data
=
aChangeList
[
i
]
;
nsIFrame
*
frame
=
data
.
mFrame
;
nsIContent
*
content
=
data
.
mContent
;
nsChangeHint
hint
=
data
.
mHint
;
bool
didReflowThisFrame
=
false
;
NS_ASSERTION
(
!
(
hint
&
nsChangeHint_AllReflowHints
)
|
|
(
hint
&
nsChangeHint_NeedReflow
)
"
Reflow
hint
bits
set
without
actually
asking
for
a
reflow
"
)
;
if
(
frame
&
&
mDestroyedFrames
-
>
Contains
(
frame
)
)
{
continue
;
}
if
(
frame
&
&
frame
-
>
GetContent
(
)
!
=
content
)
{
frame
=
nullptr
;
if
(
!
(
hint
&
nsChangeHint_ReconstructFrame
)
)
{
continue
;
}
}
if
(
(
hint
&
nsChangeHint_UpdateContainingBlock
)
&
&
frame
&
&
!
(
hint
&
nsChangeHint_ReconstructFrame
)
)
{
if
(
NeedToReframeForAddingOrRemovingTransform
(
frame
)
|
|
frame
-
>
IsFieldSetFrame
(
)
|
|
frame
-
>
GetContentInsertionFrame
(
)
!
=
frame
)
{
hint
|
=
nsChangeHint_ReconstructFrame
;
}
else
{
for
(
nsIFrame
*
cont
=
frame
;
cont
;
cont
=
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
cont
)
)
{
if
(
cont
-
>
IsAbsPosContainingBlock
(
)
)
{
if
(
!
cont
-
>
IsAbsoluteContainer
(
)
&
&
(
cont
-
>
GetStateBits
(
)
&
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
)
{
cont
-
>
MarkAsAbsoluteContainingBlock
(
)
;
}
}
else
{
if
(
cont
-
>
IsAbsoluteContainer
(
)
)
{
if
(
cont
-
>
HasAbsolutelyPositionedChildren
(
)
)
{
NS_WARNING
(
"
skipping
removal
of
absolute
containing
block
"
)
;
}
else
{
cont
-
>
MarkAsNotAbsoluteContainingBlock
(
)
;
}
}
}
}
}
}
if
(
(
hint
&
nsChangeHint_AddOrRemoveTransform
)
&
&
frame
&
&
!
(
hint
&
nsChangeHint_ReconstructFrame
)
)
{
for
(
nsIFrame
*
cont
=
frame
;
cont
;
cont
=
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
cont
)
)
{
if
(
cont
-
>
StyleDisplay
(
)
-
>
HasTransform
(
cont
)
)
{
cont
-
>
AddStateBits
(
NS_FRAME_MAY_BE_TRANSFORMED
)
;
}
}
}
if
(
hint
&
nsChangeHint_ReconstructFrame
)
{
frameConstructor
-
>
RecreateFramesForContent
(
content
nsCSSFrameConstructor
:
:
InsertionKind
:
:
Sync
)
;
}
else
{
NS_ASSERTION
(
frame
"
This
shouldn
'
t
happen
"
)
;
if
(
!
frame
-
>
FrameMaintainsOverflow
(
)
)
{
hint
&
=
~
(
nsChangeHint_UpdateOverflow
|
nsChangeHint_ChildrenOnlyTransform
|
nsChangeHint_UpdatePostTransformOverflow
|
nsChangeHint_UpdateParentOverflow
)
;
}
if
(
!
(
frame
-
>
GetStateBits
(
)
&
NS_FRAME_MAY_BE_TRANSFORMED
)
)
{
hint
&
=
~
nsChangeHint_UpdatePostTransformOverflow
;
}
if
(
hint
&
nsChangeHint_AddOrRemoveTransform
)
{
hint
&
=
~
nsChangeHint_UpdateTransformLayer
;
}
if
(
hint
&
nsChangeHint_UpdateEffects
)
{
for
(
nsIFrame
*
cont
=
frame
;
cont
;
cont
=
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
cont
)
)
{
SVGObserverUtils
:
:
UpdateEffects
(
cont
)
;
}
}
if
(
(
hint
&
nsChangeHint_InvalidateRenderingObservers
)
|
|
(
(
hint
&
nsChangeHint_UpdateOpacityLayer
)
&
&
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
&
&
!
(
frame
-
>
GetStateBits
(
)
&
NS_STATE_IS_OUTER_SVG
)
)
)
{
SVGObserverUtils
:
:
InvalidateRenderingObservers
(
frame
)
;
frame
-
>
SchedulePaint
(
)
;
}
if
(
hint
&
nsChangeHint_NeedReflow
)
{
StyleChangeReflow
(
frame
hint
)
;
didReflowThisFrame
=
true
;
}
if
(
(
hint
&
nsChangeHint_UpdateOpacityLayer
)
&
&
nsSVGUtils
:
:
CanOptimizeOpacity
(
frame
)
&
&
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVGGeometry
)
)
{
hint
&
=
~
nsChangeHint_UpdateOpacityLayer
;
hint
|
=
nsChangeHint_RepaintFrame
;
}
if
(
(
hint
&
nsChangeHint_UpdateUsesOpacity
)
&
&
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eTablePart
)
)
{
NS_ASSERTION
(
hint
&
nsChangeHint_UpdateOpacityLayer
"
should
only
return
UpdateUsesOpacity
hint
"
"
when
also
returning
UpdateOpacityLayer
hint
"
)
;
hint
&
=
~
nsChangeHint_UpdateOpacityLayer
;
hint
|
=
nsChangeHint_RepaintFrame
;
}
if
(
(
hint
&
nsChangeHint_UpdateUsesOpacity
)
&
&
frame
-
>
StyleDisplay
(
)
-
>
mTransformStyle
=
=
NS_STYLE_TRANSFORM_STYLE_PRESERVE_3D
)
{
hint
|
=
nsChangeHint_UpdateSubtreeOverflow
;
}
if
(
hint
&
nsChangeHint_UpdateBackgroundPosition
)
{
hint
|
=
nsChangeHint_SchedulePaint
;
if
(
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eTablePart
)
|
|
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eMathML
)
)
{
hint
|
=
nsChangeHint_RepaintFrame
;
}
}
if
(
hint
&
(
nsChangeHint_RepaintFrame
|
nsChangeHint_SyncFrameView
|
nsChangeHint_UpdateOpacityLayer
|
nsChangeHint_UpdateTransformLayer
|
nsChangeHint_ChildrenOnlyTransform
|
nsChangeHint_SchedulePaint
)
)
{
ApplyRenderingChangeToTree
(
presContext
-
>
PresShell
(
)
frame
hint
)
;
}
if
(
(
hint
&
nsChangeHint_RecomputePosition
)
&
&
!
didReflowThisFrame
)
{
ActiveLayerTracker
:
:
NotifyOffsetRestyle
(
frame
)
;
if
(
!
RecomputePosition
(
frame
)
)
{
didReflowThisFrame
=
true
;
}
}
NS_ASSERTION
(
!
(
hint
&
nsChangeHint_ChildrenOnlyTransform
)
|
|
(
hint
&
nsChangeHint_UpdateOverflow
)
"
nsChangeHint_UpdateOverflow
should
be
passed
too
"
)
;
if
(
!
didReflowThisFrame
&
&
(
hint
&
(
nsChangeHint_UpdateOverflow
|
nsChangeHint_UpdatePostTransformOverflow
|
nsChangeHint_UpdateParentOverflow
|
nsChangeHint_UpdateSubtreeOverflow
)
)
)
{
if
(
hint
&
nsChangeHint_UpdateSubtreeOverflow
)
{
for
(
nsIFrame
*
cont
=
frame
;
cont
;
cont
=
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
cont
)
)
{
AddSubtreeToOverflowTracker
(
cont
mOverflowChangedTracker
)
;
}
hint
&
=
~
(
nsChangeHint_UpdateOverflow
|
nsChangeHint_UpdatePostTransformOverflow
)
;
}
if
(
hint
&
nsChangeHint_ChildrenOnlyTransform
)
{
nsIFrame
*
hintFrame
=
GetFrameForChildrenOnlyTransformHint
(
frame
)
;
nsIFrame
*
childFrame
=
hintFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
NS_ASSERTION
(
!
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
frame
)
"
SVG
frames
should
not
have
continuations
"
"
or
ib
-
split
siblings
"
)
;
NS_ASSERTION
(
!
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
hintFrame
)
"
SVG
frames
should
not
have
continuations
"
"
or
ib
-
split
siblings
"
)
;
for
(
;
childFrame
;
childFrame
=
childFrame
-
>
GetNextSibling
(
)
)
{
MOZ_ASSERT
(
childFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
"
Not
expecting
non
-
SVG
children
"
)
;
if
(
!
(
childFrame
-
>
GetStateBits
(
)
&
(
NS_FRAME_IS_DIRTY
|
NS_FRAME_HAS_DIRTY_CHILDREN
)
)
)
{
mOverflowChangedTracker
.
AddFrame
(
childFrame
OverflowChangedTracker
:
:
CHILDREN_CHANGED
)
;
}
NS_ASSERTION
(
!
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
childFrame
)
"
SVG
frames
should
not
have
continuations
"
"
or
ib
-
split
siblings
"
)
;
NS_ASSERTION
(
childFrame
-
>
GetParent
(
)
=
=
hintFrame
"
SVG
child
frame
not
expected
to
have
different
parent
"
)
;
}
}
if
(
!
(
frame
-
>
GetStateBits
(
)
&
(
NS_FRAME_IS_DIRTY
|
NS_FRAME_HAS_DIRTY_CHILDREN
)
)
)
{
if
(
hint
&
(
nsChangeHint_UpdateOverflow
|
nsChangeHint_UpdatePostTransformOverflow
)
)
{
OverflowChangedTracker
:
:
ChangeKind
changeKind
;
if
(
hint
&
nsChangeHint_UpdateOverflow
)
{
changeKind
=
OverflowChangedTracker
:
:
CHILDREN_CHANGED
;
}
else
{
changeKind
=
OverflowChangedTracker
:
:
TRANSFORM_CHANGED
;
}
for
(
nsIFrame
*
cont
=
frame
;
cont
;
cont
=
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
cont
)
)
{
mOverflowChangedTracker
.
AddFrame
(
cont
changeKind
)
;
}
}
if
(
hint
&
nsChangeHint_UpdateParentOverflow
)
{
MOZ_ASSERT
(
frame
-
>
GetParent
(
)
"
shouldn
'
t
get
style
hints
for
the
root
frame
"
)
;
for
(
nsIFrame
*
cont
=
frame
;
cont
;
cont
=
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
cont
)
)
{
mOverflowChangedTracker
.
AddFrame
(
cont
-
>
GetParent
(
)
OverflowChangedTracker
:
:
CHILDREN_CHANGED
)
;
}
}
}
}
if
(
(
hint
&
nsChangeHint_UpdateCursor
)
&
&
!
didUpdateCursor
)
{
presContext
-
>
PresShell
(
)
-
>
SynthesizeMouseMove
(
false
)
;
didUpdateCursor
=
true
;
}
if
(
hint
&
nsChangeHint_UpdateWidgetProperties
)
{
frame
-
>
UpdateWidgetProperties
(
)
;
}
if
(
hint
&
nsChangeHint_UpdateTableCellSpans
)
{
frameConstructor
-
>
UpdateTableCellSpans
(
content
)
;
}
if
(
hint
&
nsChangeHint_VisibilityChange
)
{
frame
-
>
UpdateVisibleDescendantsState
(
)
;
}
}
}
#
ifdef
DEBUG
for
(
const
nsStyleChangeData
&
data
:
aChangeList
)
{
if
(
data
.
mContent
)
{
nsIFrame
*
frame
=
data
.
mContent
-
>
GetPrimaryFrame
(
)
;
if
(
frame
)
{
DebugVerifyStyleTree
(
frame
)
;
}
}
else
if
(
!
data
.
mFrame
|
|
!
data
.
mFrame
-
>
IsViewportFrame
(
)
)
{
NS_WARNING
(
"
Unable
to
test
style
tree
integrity
-
-
no
content
node
"
"
(
and
not
a
viewport
frame
)
"
)
;
}
}
#
endif
aChangeList
.
Clear
(
)
;
}
uint64_t
RestyleManager
:
:
GetAnimationGenerationForFrame
(
nsIFrame
*
aFrame
)
{
EffectSet
*
effectSet
=
EffectSet
:
:
GetEffectSet
(
aFrame
)
;
return
effectSet
?
effectSet
-
>
GetAnimationGeneration
(
)
:
0
;
}
void
RestyleManager
:
:
IncrementAnimationGeneration
(
)
{
if
(
IsGecko
(
)
)
{
#
ifdef
MOZ_OLD_STYLE
if
(
AsGecko
(
)
-
>
IsProcessingRestyles
(
)
)
{
return
;
}
#
else
MOZ_CRASH
(
"
old
style
system
disabled
"
)
;
#
endif
}
else
{
if
(
mInStyleRefresh
)
{
return
;
}
}
+
+
mAnimationGeneration
;
}
void
RestyleManager
:
:
AddLayerChangesForAnimation
(
nsIFrame
*
aFrame
nsIContent
*
aContent
nsStyleChangeList
&
aChangeListToProcess
)
{
if
(
!
aFrame
|
|
!
aContent
)
{
return
;
}
uint64_t
frameGeneration
=
RestyleManager
:
:
GetAnimationGenerationForFrame
(
aFrame
)
;
nsChangeHint
hint
=
nsChangeHint
(
0
)
;
for
(
const
LayerAnimationInfo
:
:
Record
&
layerInfo
:
LayerAnimationInfo
:
:
sRecords
)
{
layers
:
:
Layer
*
layer
=
FrameLayerBuilder
:
:
GetDedicatedLayer
(
aFrame
layerInfo
.
mLayerType
)
;
if
(
layer
&
&
frameGeneration
!
=
layer
-
>
GetAnimationGeneration
(
)
)
{
if
(
layerInfo
.
mLayerType
=
=
DisplayItemType
:
:
TYPE_TRANSFORM
&
&
!
aFrame
-
>
StyleDisplay
(
)
-
>
HasTransformStyle
(
)
)
{
continue
;
}
hint
|
=
layerInfo
.
mChangeHint
;
}
if
(
!
layer
&
&
nsLayoutUtils
:
:
HasEffectiveAnimation
(
aFrame
layerInfo
.
mProperty
)
)
{
hint
|
=
layerInfo
.
mChangeHint
;
}
}
if
(
hint
)
{
aChangeListToProcess
.
AppendChange
(
aFrame
aContent
hint
)
;
}
}
RestyleManager
:
:
AnimationsWithDestroyedFrame
:
:
AnimationsWithDestroyedFrame
(
RestyleManager
*
aRestyleManager
)
:
mRestyleManager
(
aRestyleManager
)
mRestorePointer
(
mRestyleManager
-
>
mAnimationsWithDestroyedFrame
)
{
MOZ_ASSERT
(
!
mRestyleManager
-
>
mAnimationsWithDestroyedFrame
"
shouldn
'
t
construct
recursively
"
)
;
mRestyleManager
-
>
mAnimationsWithDestroyedFrame
=
this
;
}
void
RestyleManager
:
:
AnimationsWithDestroyedFrame
:
:
StopAnimationsForElementsWithoutFrames
(
)
{
StopAnimationsWithoutFrame
(
mContents
CSSPseudoElementType
:
:
NotPseudo
)
;
StopAnimationsWithoutFrame
(
mBeforeContents
CSSPseudoElementType
:
:
before
)
;
StopAnimationsWithoutFrame
(
mAfterContents
CSSPseudoElementType
:
:
after
)
;
}
void
RestyleManager
:
:
AnimationsWithDestroyedFrame
:
:
StopAnimationsWithoutFrame
(
nsTArray
<
RefPtr
<
nsIContent
>
>
&
aArray
CSSPseudoElementType
aPseudoType
)
{
nsAnimationManager
*
animationManager
=
mRestyleManager
-
>
PresContext
(
)
-
>
AnimationManager
(
)
;
nsTransitionManager
*
transitionManager
=
mRestyleManager
-
>
PresContext
(
)
-
>
TransitionManager
(
)
;
for
(
nsIContent
*
content
:
aArray
)
{
if
(
aPseudoType
=
=
CSSPseudoElementType
:
:
NotPseudo
)
{
if
(
content
-
>
GetPrimaryFrame
(
)
)
{
continue
;
}
}
else
if
(
aPseudoType
=
=
CSSPseudoElementType
:
:
before
)
{
if
(
nsLayoutUtils
:
:
GetBeforeFrame
(
content
)
)
{
continue
;
}
}
else
if
(
aPseudoType
=
=
CSSPseudoElementType
:
:
after
)
{
if
(
nsLayoutUtils
:
:
GetAfterFrame
(
content
)
)
{
continue
;
}
}
dom
:
:
Element
*
element
=
content
-
>
AsElement
(
)
;
animationManager
-
>
StopAnimationsForElement
(
element
aPseudoType
)
;
transitionManager
-
>
StopAnimationsForElement
(
element
aPseudoType
)
;
EffectSet
*
effectSet
=
EffectSet
:
:
GetEffectSet
(
element
aPseudoType
)
;
if
(
effectSet
)
{
for
(
KeyframeEffectReadOnly
*
effect
:
*
effectSet
)
{
effect
-
>
ResetIsRunningOnCompositor
(
)
;
}
}
}
}
}
