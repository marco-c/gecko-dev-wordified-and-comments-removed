#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
mozilla
/
AutoRestyleTimelineMarker
.
h
"
#
include
"
mozilla
/
AutoTimelineMarker
.
h
"
#
include
"
mozilla
/
ComputedStyle
.
h
"
#
include
"
mozilla
/
ComputedStyleInlines
.
h
"
#
include
"
mozilla
/
DocumentStyleRootIterator
.
h
"
#
include
"
mozilla
/
EffectSet
.
h
"
#
include
"
mozilla
/
GeckoBindings
.
h
"
#
include
"
mozilla
/
LayerAnimationInfo
.
h
"
#
include
"
mozilla
/
layers
/
AnimationInfo
.
h
"
#
include
"
mozilla
/
layout
/
ScrollAnchorContainer
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
PresShellInlines
.
h
"
#
include
"
mozilla
/
ProfilerLabels
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
mozilla
/
ServoStyleSetInlines
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
mozilla
/
SVGIntegrationUtils
.
h
"
#
include
"
mozilla
/
SVGObserverUtils
.
h
"
#
include
"
mozilla
/
SVGTextFrame
.
h
"
#
include
"
mozilla
/
SVGUtils
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
ViewportFrame
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
dom
/
ChildIterator
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
include
"
mozilla
/
dom
/
ElementInlines
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBodyElement
.
h
"
#
include
"
Layers
.
h
"
#
include
"
ScrollSnap
.
h
"
#
include
"
nsAnimationManager
.
h
"
#
include
"
nsBlockFrame
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
nsCSSRendering
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsImageFrame
.
h
"
#
include
"
nsPlaceholderFrame
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsRefreshDriver
.
h
"
#
include
"
nsStyleChangeList
.
h
"
#
include
"
nsStyleUtil
.
h
"
#
include
"
nsTransitionManager
.
h
"
#
include
"
StickyScrollContainer
.
h
"
#
include
"
ActiveLayerTracker
.
h
"
#
ifdef
ACCESSIBILITY
#
include
"
nsAccessibilityService
.
h
"
#
endif
using
mozilla
:
:
layers
:
:
AnimationInfo
;
using
mozilla
:
:
layout
:
:
ScrollAnchorContainer
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
layers
;
namespace
mozilla
{
RestyleManager
:
:
RestyleManager
(
nsPresContext
*
aPresContext
)
:
mPresContext
(
aPresContext
)
mRestyleGeneration
(
1
)
mUndisplayedRestyleGeneration
(
1
)
mInStyleRefresh
(
false
)
mAnimationGeneration
(
0
)
{
MOZ_ASSERT
(
mPresContext
)
;
}
void
RestyleManager
:
:
ContentInserted
(
nsIContent
*
aChild
)
{
MOZ_ASSERT
(
aChild
-
>
GetParentNode
(
)
)
;
RestyleForInsertOrChange
(
aChild
)
;
}
void
RestyleManager
:
:
ContentAppended
(
nsIContent
*
aFirstNewContent
)
{
MOZ_ASSERT
(
aFirstNewContent
-
>
GetParent
(
)
)
;
if
(
!
aFirstNewContent
-
>
GetParentNode
(
)
-
>
IsElement
(
)
)
{
return
;
}
Element
*
container
=
aFirstNewContent
-
>
GetParentNode
(
)
-
>
AsElement
(
)
;
#
ifdef
DEBUG
{
for
(
nsIContent
*
cur
=
aFirstNewContent
;
cur
;
cur
=
cur
-
>
GetNextSibling
(
)
)
{
NS_ASSERTION
(
!
cur
-
>
IsRootOfNativeAnonymousSubtree
(
)
"
anonymous
nodes
should
not
be
in
child
lists
"
)
;
}
}
#
endif
uint32_t
selectorFlags
=
container
-
>
GetFlags
(
)
&
(
NODE_ALL_SELECTOR_FLAGS
&
~
NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS
)
;
if
(
selectorFlags
=
=
0
)
return
;
if
(
selectorFlags
&
NODE_HAS_EMPTY_SELECTOR
)
{
bool
wasEmpty
=
true
;
for
(
nsIContent
*
cur
=
container
-
>
GetFirstChild
(
)
;
cur
!
=
aFirstNewContent
;
cur
=
cur
-
>
GetNextSibling
(
)
)
{
if
(
nsStyleUtil
:
:
IsSignificantChild
(
cur
false
)
)
{
wasEmpty
=
false
;
break
;
}
}
if
(
wasEmpty
)
{
RestyleForEmptyChange
(
container
)
;
return
;
}
}
if
(
selectorFlags
&
NODE_HAS_SLOW_SELECTOR
)
{
PostRestyleEvent
(
container
RestyleHint
:
:
RestyleSubtree
(
)
nsChangeHint
(
0
)
)
;
return
;
}
if
(
selectorFlags
&
NODE_HAS_EDGE_CHILD_SELECTOR
)
{
for
(
nsIContent
*
cur
=
aFirstNewContent
-
>
GetPreviousSibling
(
)
;
cur
;
cur
=
cur
-
>
GetPreviousSibling
(
)
)
{
if
(
cur
-
>
IsElement
(
)
)
{
PostRestyleEvent
(
cur
-
>
AsElement
(
)
RestyleHint
:
:
RestyleSubtree
(
)
nsChangeHint
(
0
)
)
;
break
;
}
}
}
}
static
void
RestyleSiblingsStartingWith
(
RestyleManager
&
aRM
nsIContent
*
aStartingSibling
)
{
for
(
nsIContent
*
sibling
=
aStartingSibling
;
sibling
;
sibling
=
sibling
-
>
GetNextSibling
(
)
)
{
if
(
auto
*
element
=
Element
:
:
FromNode
(
sibling
)
)
{
aRM
.
PostRestyleEvent
(
element
RestyleHint
:
:
RestyleSubtree
(
)
nsChangeHint
(
0
)
)
;
}
}
}
void
RestyleManager
:
:
RestyleForEmptyChange
(
Element
*
aContainer
)
{
PostRestyleEvent
(
aContainer
RestyleHint
:
:
RestyleSubtree
(
)
nsChangeHint
(
0
)
)
;
nsIContent
*
grandparent
=
aContainer
-
>
GetParent
(
)
;
if
(
!
grandparent
|
|
!
(
grandparent
-
>
GetFlags
(
)
&
NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS
)
)
{
return
;
}
RestyleSiblingsStartingWith
(
*
this
aContainer
-
>
GetNextSibling
(
)
)
;
}
void
RestyleManager
:
:
MaybeRestyleForEdgeChildChange
(
Element
*
aContainer
nsIContent
*
aChangedChild
)
{
MOZ_ASSERT
(
aContainer
-
>
GetFlags
(
)
&
NODE_HAS_EDGE_CHILD_SELECTOR
)
;
MOZ_ASSERT
(
aChangedChild
-
>
GetParent
(
)
=
=
aContainer
)
;
bool
passedChild
=
false
;
for
(
nsIContent
*
content
=
aContainer
-
>
GetFirstChild
(
)
;
content
;
content
=
content
-
>
GetNextSibling
(
)
)
{
if
(
content
=
=
aChangedChild
)
{
passedChild
=
true
;
continue
;
}
if
(
content
-
>
IsElement
(
)
)
{
if
(
passedChild
)
{
PostRestyleEvent
(
content
-
>
AsElement
(
)
RestyleHint
:
:
RestyleSubtree
(
)
nsChangeHint
(
0
)
)
;
}
break
;
}
}
passedChild
=
false
;
for
(
nsIContent
*
content
=
aContainer
-
>
GetLastChild
(
)
;
content
;
content
=
content
-
>
GetPreviousSibling
(
)
)
{
if
(
content
=
=
aChangedChild
)
{
passedChild
=
true
;
continue
;
}
if
(
content
-
>
IsElement
(
)
)
{
if
(
passedChild
)
{
PostRestyleEvent
(
content
-
>
AsElement
(
)
RestyleHint
:
:
RestyleSubtree
(
)
nsChangeHint
(
0
)
)
;
}
break
;
}
}
}
template
<
typename
CharT
>
bool
WhitespaceOnly
(
const
CharT
*
aBuffer
size_t
aUpTo
)
{
for
(
auto
index
:
IntegerRange
(
aUpTo
)
)
{
if
(
!
dom
:
:
IsSpaceCharacter
(
aBuffer
[
index
]
)
)
{
return
false
;
}
}
return
true
;
}
template
<
typename
CharT
>
bool
WhitespaceOnlyChangedOnAppend
(
const
CharT
*
aBuffer
size_t
aOldLength
size_t
aNewLength
)
{
MOZ_ASSERT
(
aOldLength
<
=
aNewLength
)
;
if
(
!
WhitespaceOnly
(
aBuffer
aOldLength
)
)
{
return
false
;
}
return
!
WhitespaceOnly
(
aBuffer
+
aOldLength
aNewLength
-
aOldLength
)
;
}
static
bool
HasAnySignificantSibling
(
Element
*
aContainer
nsIContent
*
aChild
)
{
MOZ_ASSERT
(
aChild
-
>
GetParent
(
)
=
=
aContainer
)
;
for
(
nsIContent
*
child
=
aContainer
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
=
=
aChild
)
{
continue
;
}
if
(
nsStyleUtil
:
:
IsSignificantChild
(
child
false
)
)
{
return
true
;
}
}
return
false
;
}
void
RestyleManager
:
:
CharacterDataChanged
(
nsIContent
*
aContent
const
CharacterDataChangeInfo
&
aInfo
)
{
nsINode
*
parent
=
aContent
-
>
GetParentNode
(
)
;
MOZ_ASSERT
(
parent
"
How
were
we
notified
of
a
stray
node
?
"
)
;
uint32_t
slowSelectorFlags
=
parent
-
>
GetFlags
(
)
&
NODE_ALL_SELECTOR_FLAGS
;
if
(
!
(
slowSelectorFlags
&
(
NODE_HAS_EMPTY_SELECTOR
|
NODE_HAS_EDGE_CHILD_SELECTOR
)
)
)
{
return
;
}
if
(
!
aContent
-
>
IsText
(
)
)
{
return
;
}
if
(
MOZ_UNLIKELY
(
!
parent
-
>
IsElement
(
)
)
)
{
MOZ_ASSERT
(
parent
-
>
IsShadowRoot
(
)
)
;
return
;
}
if
(
MOZ_UNLIKELY
(
aContent
-
>
IsRootOfNativeAnonymousSubtree
(
)
)
)
{
return
;
}
if
(
!
aInfo
.
mAppend
)
{
RestyleForInsertOrChange
(
aContent
)
;
return
;
}
const
nsTextFragment
*
text
=
&
aContent
-
>
AsText
(
)
-
>
TextFragment
(
)
;
const
size_t
oldLength
=
aInfo
.
mChangeStart
;
const
size_t
newLength
=
text
-
>
GetLength
(
)
;
const
bool
emptyChanged
=
!
oldLength
&
&
newLength
;
const
bool
whitespaceOnlyChanged
=
text
-
>
Is2b
(
)
?
WhitespaceOnlyChangedOnAppend
(
text
-
>
Get2b
(
)
oldLength
newLength
)
:
WhitespaceOnlyChangedOnAppend
(
text
-
>
Get1b
(
)
oldLength
newLength
)
;
if
(
!
emptyChanged
&
&
!
whitespaceOnlyChanged
)
{
return
;
}
if
(
slowSelectorFlags
&
NODE_HAS_EMPTY_SELECTOR
)
{
if
(
!
HasAnySignificantSibling
(
parent
-
>
AsElement
(
)
aContent
)
)
{
RestyleForEmptyChange
(
parent
-
>
AsElement
(
)
)
;
return
;
}
}
if
(
slowSelectorFlags
&
NODE_HAS_EDGE_CHILD_SELECTOR
)
{
MaybeRestyleForEdgeChildChange
(
parent
-
>
AsElement
(
)
aContent
)
;
}
}
void
RestyleManager
:
:
RestyleForInsertOrChange
(
nsIContent
*
aChild
)
{
nsINode
*
parentNode
=
aChild
-
>
GetParentNode
(
)
;
MOZ_ASSERT
(
parentNode
)
;
if
(
!
parentNode
-
>
IsElement
(
)
)
{
return
;
}
Element
*
container
=
parentNode
-
>
AsElement
(
)
;
NS_ASSERTION
(
!
aChild
-
>
IsRootOfNativeAnonymousSubtree
(
)
"
anonymous
nodes
should
not
be
in
child
lists
"
)
;
uint32_t
selectorFlags
=
container
-
>
GetFlags
(
)
&
NODE_ALL_SELECTOR_FLAGS
;
if
(
selectorFlags
=
=
0
)
return
;
if
(
selectorFlags
&
NODE_HAS_EMPTY_SELECTOR
)
{
const
bool
wasEmpty
=
!
HasAnySignificantSibling
(
container
aChild
)
;
if
(
wasEmpty
)
{
RestyleForEmptyChange
(
container
)
;
return
;
}
}
if
(
selectorFlags
&
NODE_HAS_SLOW_SELECTOR
)
{
PostRestyleEvent
(
container
RestyleHint
:
:
RestyleSubtree
(
)
nsChangeHint
(
0
)
)
;
return
;
}
if
(
selectorFlags
&
NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS
)
{
RestyleSiblingsStartingWith
(
*
this
aChild
-
>
GetNextSibling
(
)
)
;
}
if
(
selectorFlags
&
NODE_HAS_EDGE_CHILD_SELECTOR
)
{
MaybeRestyleForEdgeChildChange
(
container
aChild
)
;
}
}
void
RestyleManager
:
:
ContentRemoved
(
nsIContent
*
aOldChild
nsIContent
*
aFollowingSibling
)
{
MOZ_ASSERT
(
aOldChild
-
>
GetParentNode
(
)
)
;
if
(
aOldChild
-
>
IsElement
(
)
)
{
RestyleManager
:
:
ClearServoDataFromSubtree
(
aOldChild
-
>
AsElement
(
)
)
;
}
if
(
!
aOldChild
-
>
GetParentNode
(
)
-
>
IsElement
(
)
)
{
return
;
}
Element
*
container
=
aOldChild
-
>
GetParentNode
(
)
-
>
AsElement
(
)
;
if
(
aOldChild
-
>
IsRootOfNativeAnonymousSubtree
(
)
)
{
MOZ_ASSERT
(
aOldChild
-
>
GetProperty
(
nsGkAtoms
:
:
restylableAnonymousNode
)
"
anonymous
nodes
should
not
be
in
child
lists
(
bug
439258
)
"
)
;
}
uint32_t
selectorFlags
=
container
-
>
GetFlags
(
)
&
NODE_ALL_SELECTOR_FLAGS
;
if
(
selectorFlags
=
=
0
)
return
;
if
(
selectorFlags
&
NODE_HAS_EMPTY_SELECTOR
)
{
bool
isEmpty
=
true
;
for
(
nsIContent
*
child
=
container
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
nsStyleUtil
:
:
IsSignificantChild
(
child
false
)
)
{
isEmpty
=
false
;
break
;
}
}
if
(
isEmpty
)
{
RestyleForEmptyChange
(
container
)
;
return
;
}
}
if
(
selectorFlags
&
NODE_HAS_SLOW_SELECTOR
)
{
PostRestyleEvent
(
container
RestyleHint
:
:
RestyleSubtree
(
)
nsChangeHint
(
0
)
)
;
return
;
}
if
(
selectorFlags
&
NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS
)
{
RestyleSiblingsStartingWith
(
*
this
aFollowingSibling
)
;
}
if
(
selectorFlags
&
NODE_HAS_EDGE_CHILD_SELECTOR
)
{
bool
reachedFollowingSibling
=
false
;
for
(
nsIContent
*
content
=
container
-
>
GetFirstChild
(
)
;
content
;
content
=
content
-
>
GetNextSibling
(
)
)
{
if
(
content
=
=
aFollowingSibling
)
{
reachedFollowingSibling
=
true
;
}
if
(
content
-
>
IsElement
(
)
)
{
if
(
reachedFollowingSibling
)
{
PostRestyleEvent
(
content
-
>
AsElement
(
)
RestyleHint
:
:
RestyleSubtree
(
)
nsChangeHint
(
0
)
)
;
}
break
;
}
}
reachedFollowingSibling
=
(
aFollowingSibling
=
=
nullptr
)
;
for
(
nsIContent
*
content
=
container
-
>
GetLastChild
(
)
;
content
;
content
=
content
-
>
GetPreviousSibling
(
)
)
{
if
(
content
-
>
IsElement
(
)
)
{
if
(
reachedFollowingSibling
)
{
PostRestyleEvent
(
content
-
>
AsElement
(
)
RestyleHint
:
:
RestyleSubtree
(
)
nsChangeHint
(
0
)
)
;
}
break
;
}
if
(
content
=
=
aFollowingSibling
)
{
reachedFollowingSibling
=
true
;
}
}
}
}
static
bool
StateChangeMayAffectFrame
(
const
Element
&
aElement
const
nsIFrame
&
aFrame
ElementState
aStates
)
{
const
bool
brokenChanged
=
aStates
.
HasState
(
ElementState
:
:
BROKEN
)
;
if
(
aFrame
.
IsGeneratedContentFrame
(
)
)
{
if
(
aElement
.
IsHTMLElement
(
nsGkAtoms
:
:
mozgeneratedcontentimage
)
)
{
return
brokenChanged
;
}
return
false
;
}
const
bool
loadingChanged
=
aStates
.
HasState
(
ElementState
:
:
LOADING
)
;
if
(
!
brokenChanged
&
&
!
loadingChanged
)
{
return
false
;
}
if
(
aElement
.
IsHTMLElement
(
nsGkAtoms
:
:
img
)
)
{
return
brokenChanged
;
}
if
(
aElement
.
IsSVGElement
(
nsGkAtoms
:
:
image
)
)
{
return
false
;
}
return
brokenChanged
|
|
loadingChanged
;
}
static
nsChangeHint
ChangeForContentStateChange
(
const
Element
&
aElement
ElementState
aStateMask
)
{
auto
changeHint
=
nsChangeHint
(
0
)
;
if
(
nsIFrame
*
primaryFrame
=
aElement
.
GetPrimaryFrame
(
)
)
{
if
(
StateChangeMayAffectFrame
(
aElement
*
primaryFrame
aStateMask
)
)
{
return
nsChangeHint_ReconstructFrame
;
}
StyleAppearance
appearance
=
primaryFrame
-
>
StyleDisplay
(
)
-
>
EffectiveAppearance
(
)
;
if
(
appearance
!
=
StyleAppearance
:
:
None
)
{
nsPresContext
*
pc
=
primaryFrame
-
>
PresContext
(
)
;
nsITheme
*
theme
=
pc
-
>
Theme
(
)
;
if
(
theme
-
>
ThemeSupportsWidget
(
pc
primaryFrame
appearance
)
)
{
bool
repaint
=
false
;
theme
-
>
WidgetStateChanged
(
primaryFrame
appearance
nullptr
&
repaint
nullptr
)
;
if
(
repaint
)
{
changeHint
|
=
nsChangeHint_RepaintFrame
;
}
}
}
primaryFrame
-
>
ElementStateChanged
(
aStateMask
)
;
}
if
(
aStateMask
.
HasState
(
ElementState
:
:
VISITED
)
)
{
changeHint
|
=
nsChangeHint_RepaintFrame
;
}
if
(
aStateMask
.
HasState
(
ElementState
:
:
REVEALED
)
)
{
changeHint
|
=
NS_STYLE_HINT_REFLOW
;
}
return
changeHint
;
}
#
ifdef
DEBUG
nsCString
RestyleManager
:
:
ChangeHintToString
(
nsChangeHint
aHint
)
{
nsCString
result
;
bool
any
=
false
;
const
char
*
names
[
]
=
{
"
RepaintFrame
"
"
NeedReflow
"
"
ClearAncestorIntrinsics
"
"
ClearDescendantIntrinsics
"
"
NeedDirtyReflow
"
"
UpdateCursor
"
"
UpdateEffects
"
"
UpdateOpacityLayer
"
"
UpdateTransformLayer
"
"
ReconstructFrame
"
"
UpdateOverflow
"
"
UpdateSubtreeOverflow
"
"
UpdatePostTransformOverflow
"
"
UpdateParentOverflow
"
"
ChildrenOnlyTransform
"
"
RecomputePosition
"
"
UpdateContainingBlock
"
"
BorderStyleNoneChange
"
"
SchedulePaint
"
"
NeutralChange
"
"
InvalidateRenderingObservers
"
"
ReflowChangesSizeOrPosition
"
"
UpdateComputedBSize
"
"
UpdateUsesOpacity
"
"
UpdateBackgroundPosition
"
"
AddOrRemoveTransform
"
"
ScrollbarChange
"
"
UpdateTableCellSpans
"
"
VisibilityChange
"
}
;
static_assert
(
nsChangeHint_AllHints
=
=
static_cast
<
uint32_t
>
(
(
1ull
<
<
ArrayLength
(
names
)
)
-
1
)
"
Name
list
doesn
'
t
match
change
hints
.
"
)
;
uint32_t
hint
=
aHint
&
static_cast
<
uint32_t
>
(
(
1ull
<
<
ArrayLength
(
names
)
)
-
1
)
;
uint32_t
rest
=
aHint
&
~
static_cast
<
uint32_t
>
(
(
1ull
<
<
ArrayLength
(
names
)
)
-
1
)
;
if
(
(
hint
&
NS_STYLE_HINT_REFLOW
)
=
=
NS_STYLE_HINT_REFLOW
)
{
result
.
AppendLiteral
(
"
NS_STYLE_HINT_REFLOW
"
)
;
hint
=
hint
&
~
NS_STYLE_HINT_REFLOW
;
any
=
true
;
}
else
if
(
(
hint
&
nsChangeHint_AllReflowHints
)
=
=
nsChangeHint_AllReflowHints
)
{
result
.
AppendLiteral
(
"
nsChangeHint_AllReflowHints
"
)
;
hint
=
hint
&
~
nsChangeHint_AllReflowHints
;
any
=
true
;
}
else
if
(
(
hint
&
NS_STYLE_HINT_VISUAL
)
=
=
NS_STYLE_HINT_VISUAL
)
{
result
.
AppendLiteral
(
"
NS_STYLE_HINT_VISUAL
"
)
;
hint
=
hint
&
~
NS_STYLE_HINT_VISUAL
;
any
=
true
;
}
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
names
)
;
i
+
+
)
{
if
(
hint
&
(
1u
<
<
i
)
)
{
if
(
any
)
{
result
.
AppendLiteral
(
"
|
"
)
;
}
result
.
AppendPrintf
(
"
nsChangeHint_
%
s
"
names
[
i
]
)
;
any
=
true
;
}
}
if
(
rest
)
{
if
(
any
)
{
result
.
AppendLiteral
(
"
|
"
)
;
}
result
.
AppendPrintf
(
"
0x
%
0x
"
rest
)
;
}
else
{
if
(
!
any
)
{
result
.
AppendLiteral
(
"
nsChangeHint
(
0
)
"
)
;
}
}
return
result
;
}
#
endif
#
ifdef
DEBUG
static
bool
gInApplyRenderingChangeToTree
=
false
;
#
endif
static
void
SyncViewsAndInvalidateDescendants
(
nsIFrame
*
nsChangeHint
)
;
static
void
StyleChangeReflow
(
nsIFrame
*
aFrame
nsChangeHint
aHint
)
;
static
nsIFrame
*
GetFrameForChildrenOnlyTransformHint
(
nsIFrame
*
aFrame
)
{
if
(
aFrame
-
>
IsViewportFrame
(
)
)
{
aFrame
=
aFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
}
aFrame
=
aFrame
-
>
GetContent
(
)
-
>
GetPrimaryFrame
(
)
;
if
(
aFrame
-
>
IsSVGOuterSVGFrame
(
)
)
{
aFrame
=
aFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
MOZ_ASSERT
(
aFrame
-
>
IsSVGOuterSVGAnonChildFrame
(
)
"
Where
is
the
SVGOuterSVGFrame
'
s
anon
child
?
?
"
)
;
}
MOZ_ASSERT
(
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
|
nsIFrame
:
:
eSVGContainer
)
"
Children
-
only
transforms
only
expected
on
SVG
frames
"
)
;
return
aFrame
;
}
static
bool
RecomputePosition
(
nsIFrame
*
aFrame
)
{
if
(
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
|
NS_FRAME_IS_DIRTY
)
)
{
return
true
;
}
if
(
aFrame
-
>
IsTableFrame
(
)
)
{
return
true
;
}
const
nsStyleDisplay
*
display
=
aFrame
-
>
StyleDisplay
(
)
;
if
(
display
-
>
mPosition
=
=
StylePositionProperty
:
:
Static
)
{
return
true
;
}
if
(
aFrame
-
>
HasView
(
)
|
|
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_HAS_CHILD_WITH_VIEW
)
)
{
return
false
;
}
if
(
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
)
{
if
(
aFrame
-
>
HasIntrinsicKeywordForBSize
(
)
)
{
WritingMode
wm
=
aFrame
-
>
GetWritingMode
(
)
;
const
auto
*
styleMargin
=
aFrame
-
>
StyleMargin
(
)
;
if
(
styleMargin
-
>
HasBlockAxisAuto
(
wm
)
)
{
return
false
;
}
}
nsIFrame
*
ph
=
aFrame
-
>
GetPlaceholderFrame
(
)
;
if
(
ph
&
&
ph
-
>
HasAnyStateBits
(
PLACEHOLDER_STATICPOS_NEEDS_CSSALIGN
)
)
{
return
false
;
}
}
if
(
aFrame
-
>
DescendantMayDependOnItsStaticPosition
(
)
)
{
return
false
;
}
aFrame
-
>
SchedulePaint
(
)
;
auto
postPendingScrollAnchorOrResnap
=
[
]
(
nsIFrame
*
frame
)
{
if
(
frame
-
>
IsInScrollAnchorChain
(
)
)
{
ScrollAnchorContainer
*
container
=
ScrollAnchorContainer
:
:
FindFor
(
frame
)
;
frame
-
>
PresShell
(
)
-
>
PostPendingScrollAnchorAdjustment
(
container
)
;
}
ScrollSnapUtils
:
:
PostPendingResnapIfNeededFor
(
frame
)
;
}
;
if
(
display
-
>
IsRelativelyOrStickyPositionedStyle
(
)
)
{
if
(
aFrame
-
>
IsGridItem
(
)
)
{
return
false
;
}
if
(
display
-
>
mPosition
=
=
StylePositionProperty
:
:
Sticky
)
{
nsIFrame
*
firstContinuation
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
aFrame
)
;
StickyScrollContainer
:
:
ComputeStickyOffsets
(
firstContinuation
)
;
StickyScrollContainer
*
ssc
=
StickyScrollContainer
:
:
GetStickyScrollContainerForFrame
(
firstContinuation
)
;
if
(
ssc
)
{
ssc
-
>
PositionContinuations
(
firstContinuation
)
;
}
}
else
{
MOZ_ASSERT
(
display
-
>
IsRelativelyPositionedStyle
(
)
"
Unexpected
type
of
positioning
"
)
;
for
(
nsIFrame
*
cont
=
aFrame
;
cont
;
cont
=
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
cont
)
)
{
nsIFrame
*
cb
=
cont
-
>
GetContainingBlock
(
)
;
WritingMode
wm
=
cb
-
>
GetWritingMode
(
)
;
const
LogicalSize
cbSize
=
cb
-
>
ContentSize
(
)
;
const
LogicalMargin
newLogicalOffsets
=
ReflowInput
:
:
ComputeRelativeOffsets
(
wm
cont
cbSize
)
;
const
nsMargin
newOffsets
=
newLogicalOffsets
.
GetPhysicalMargin
(
wm
)
;
bool
hasProperty
;
nsPoint
normalPosition
=
cont
-
>
GetNormalPosition
(
&
hasProperty
)
;
if
(
!
hasProperty
)
{
cont
-
>
AddProperty
(
nsIFrame
:
:
NormalPositionProperty
(
)
normalPosition
)
;
}
cont
-
>
SetPosition
(
normalPosition
+
nsPoint
(
newOffsets
.
left
newOffsets
.
top
)
)
;
}
}
postPendingScrollAnchorOrResnap
(
aFrame
)
;
return
true
;
}
RefPtr
<
gfxContext
>
rc
=
aFrame
-
>
PresShell
(
)
-
>
CreateReferenceRenderingContext
(
)
;
nsIFrame
*
parentFrame
=
aFrame
-
>
GetParent
(
)
;
WritingMode
parentWM
=
parentFrame
-
>
GetWritingMode
(
)
;
WritingMode
frameWM
=
aFrame
-
>
GetWritingMode
(
)
;
LogicalSize
parentSize
=
parentFrame
-
>
GetLogicalSize
(
)
;
nsFrameState
savedState
=
parentFrame
-
>
GetStateBits
(
)
;
ReflowInput
parentReflowInput
(
aFrame
-
>
PresContext
(
)
parentFrame
rc
parentSize
)
;
parentFrame
-
>
RemoveStateBits
(
~
nsFrameState
(
0
)
)
;
parentFrame
-
>
AddStateBits
(
savedState
)
;
Maybe
<
ReflowInput
>
cbReflowInput
;
nsIFrame
*
cbFrame
=
parentFrame
-
>
GetContainingBlock
(
)
;
if
(
cbFrame
&
&
(
aFrame
-
>
GetContainingBlock
(
)
!
=
parentFrame
|
|
parentFrame
-
>
IsTableFrame
(
)
)
)
{
const
auto
cbWM
=
cbFrame
-
>
GetWritingMode
(
)
;
LogicalSize
cbSize
=
cbFrame
-
>
GetLogicalSize
(
)
;
cbReflowInput
.
emplace
(
cbFrame
-
>
PresContext
(
)
cbFrame
rc
cbSize
)
;
cbReflowInput
-
>
SetComputedLogicalMargin
(
cbWM
cbFrame
-
>
GetLogicalUsedMargin
(
cbWM
)
)
;
cbReflowInput
-
>
SetComputedLogicalPadding
(
cbWM
cbFrame
-
>
GetLogicalUsedPadding
(
cbWM
)
)
;
cbReflowInput
-
>
SetComputedLogicalBorderPadding
(
cbWM
cbFrame
-
>
GetLogicalUsedBorderAndPadding
(
cbWM
)
)
;
parentReflowInput
.
mCBReflowInput
=
cbReflowInput
.
ptr
(
)
;
}
NS_WARNING_ASSERTION
(
parentSize
.
ISize
(
parentWM
)
!
=
NS_UNCONSTRAINEDSIZE
&
&
parentSize
.
BSize
(
parentWM
)
!
=
NS_UNCONSTRAINEDSIZE
"
parentSize
should
be
valid
"
)
;
parentReflowInput
.
SetComputedISize
(
std
:
:
max
(
parentSize
.
ISize
(
parentWM
)
0
)
)
;
parentReflowInput
.
SetComputedBSize
(
std
:
:
max
(
parentSize
.
BSize
(
parentWM
)
0
)
)
;
parentReflowInput
.
SetComputedLogicalMargin
(
parentWM
LogicalMargin
(
parentWM
)
)
;
parentReflowInput
.
SetComputedLogicalPadding
(
parentWM
parentFrame
-
>
GetLogicalUsedPadding
(
parentWM
)
)
;
parentReflowInput
.
SetComputedLogicalBorderPadding
(
parentWM
parentFrame
-
>
GetLogicalUsedBorderAndPadding
(
parentWM
)
)
;
LogicalSize
availSize
=
parentSize
.
ConvertTo
(
frameWM
parentWM
)
;
availSize
.
BSize
(
frameWM
)
=
NS_UNCONSTRAINEDSIZE
;
ViewportFrame
*
viewport
=
do_QueryFrame
(
parentFrame
)
;
nsSize
cbSize
=
viewport
?
viewport
-
>
AdjustReflowInputAsContainingBlock
(
&
parentReflowInput
)
.
Size
(
)
:
aFrame
-
>
GetContainingBlock
(
)
-
>
GetSize
(
)
;
const
nsMargin
&
parentBorder
=
parentReflowInput
.
mStyleBorder
-
>
GetComputedBorder
(
)
;
cbSize
-
=
nsSize
(
parentBorder
.
LeftRight
(
)
parentBorder
.
TopBottom
(
)
)
;
LogicalSize
lcbSize
(
frameWM
cbSize
)
;
ReflowInput
reflowInput
(
aFrame
-
>
PresContext
(
)
parentReflowInput
aFrame
availSize
Some
(
lcbSize
)
)
;
nscoord
computedISize
=
reflowInput
.
ComputedISize
(
)
;
nscoord
computedBSize
=
reflowInput
.
ComputedBSize
(
)
;
const
auto
frameBP
=
reflowInput
.
ComputedLogicalBorderPadding
(
frameWM
)
;
computedISize
+
=
frameBP
.
IStartEnd
(
frameWM
)
;
if
(
computedBSize
!
=
NS_UNCONSTRAINEDSIZE
)
{
computedBSize
+
=
frameBP
.
BStartEnd
(
frameWM
)
;
}
LogicalSize
logicalSize
=
aFrame
-
>
GetLogicalSize
(
frameWM
)
;
nsSize
size
=
aFrame
-
>
GetSize
(
)
;
if
(
computedISize
=
=
logicalSize
.
ISize
(
frameWM
)
&
&
(
computedBSize
=
=
NS_UNCONSTRAINEDSIZE
|
|
computedBSize
=
=
logicalSize
.
BSize
(
frameWM
)
)
)
{
const
nsMargin
offset
=
reflowInput
.
ComputedPhysicalOffsets
(
)
;
const
nsMargin
margin
=
reflowInput
.
ComputedPhysicalMargin
(
)
;
nscoord
left
=
offset
.
left
;
if
(
left
=
=
NS_AUTOOFFSET
)
{
left
=
cbSize
.
width
-
offset
.
right
-
margin
.
right
-
size
.
width
-
margin
.
left
;
}
nscoord
top
=
offset
.
top
;
if
(
top
=
=
NS_AUTOOFFSET
)
{
top
=
cbSize
.
height
-
offset
.
bottom
-
margin
.
bottom
-
size
.
height
-
margin
.
top
;
}
nsPoint
pos
(
parentBorder
.
left
+
left
+
margin
.
left
parentBorder
.
top
+
top
+
margin
.
top
)
;
aFrame
-
>
SetPosition
(
pos
)
;
postPendingScrollAnchorOrResnap
(
aFrame
)
;
return
true
;
}
return
false
;
}
static
bool
HasBoxAncestor
(
nsIFrame
*
aFrame
)
{
for
(
nsIFrame
*
f
=
aFrame
;
f
;
f
=
f
-
>
GetParent
(
)
)
{
if
(
f
-
>
IsXULBoxFrame
(
)
)
{
return
true
;
}
}
return
false
;
}
static
bool
ContainingBlockChangeAffectsDescendants
(
nsIFrame
*
aPossiblyChangingContainingBlock
nsIFrame
*
aFrame
bool
aIsAbsPosContainingBlock
bool
aIsFixedPosContainingBlock
)
{
MOZ_ASSERT_IF
(
aIsFixedPosContainingBlock
aIsAbsPosContainingBlock
)
;
for
(
const
auto
&
childList
:
aFrame
-
>
ChildLists
(
)
)
{
for
(
nsIFrame
*
f
:
childList
.
mList
)
{
if
(
f
-
>
IsPlaceholderFrame
(
)
)
{
nsIFrame
*
outOfFlow
=
nsPlaceholderFrame
:
:
GetRealFrameForPlaceholder
(
f
)
;
NS_ASSERTION
(
!
SVGUtils
:
:
IsInSVGTextSubtree
(
outOfFlow
)
"
SVG
text
frames
can
'
t
be
out
of
flow
"
)
;
auto
*
display
=
outOfFlow
-
>
StyleDisplay
(
)
;
if
(
display
-
>
IsAbsolutelyPositionedStyle
(
)
)
{
const
bool
isContainingBlock
=
aIsFixedPosContainingBlock
|
|
(
aIsAbsPosContainingBlock
&
&
display
-
>
mPosition
=
=
StylePositionProperty
:
:
Absolute
)
;
nsIFrame
*
parent
=
outOfFlow
-
>
GetParent
(
)
-
>
FirstContinuation
(
)
;
if
(
isContainingBlock
)
{
if
(
parent
!
=
aPossiblyChangingContainingBlock
&
&
nsLayoutUtils
:
:
IsProperAncestorFrame
(
parent
aPossiblyChangingContainingBlock
)
)
{
return
true
;
}
}
else
{
if
(
parent
=
=
aPossiblyChangingContainingBlock
)
{
return
true
;
}
}
}
}
if
(
ContainingBlockChangeAffectsDescendants
(
aPossiblyChangingContainingBlock
f
aIsAbsPosContainingBlock
aIsFixedPosContainingBlock
)
)
{
return
true
;
}
}
}
return
false
;
}
static
nsIFrame
*
ContainingBlockForFrame
(
nsIFrame
*
aFrame
)
{
if
(
aFrame
-
>
IsFieldSetFrame
(
)
)
{
return
nullptr
;
}
nsIFrame
*
insertionFrame
=
aFrame
-
>
GetContentInsertionFrame
(
)
;
if
(
insertionFrame
=
=
aFrame
)
{
return
insertionFrame
;
}
if
(
aFrame
-
>
IsScrollFrame
(
)
)
{
return
insertionFrame
;
}
if
(
aFrame
-
>
IsComboboxControlFrame
(
)
|
|
aFrame
-
>
IsHTMLButtonControlFrame
(
)
)
{
return
aFrame
;
}
return
nullptr
;
}
static
bool
NeedToReframeToUpdateContainingBlock
(
nsIFrame
*
aFrame
nsIFrame
*
aMaybeChangingCB
)
{
const
bool
isFixedContainingBlock
=
aFrame
-
>
IsFixedPosContainingBlock
(
)
;
MOZ_ASSERT_IF
(
isFixedContainingBlock
aFrame
-
>
IsAbsPosContainingBlock
(
)
)
;
const
bool
isAbsPosContainingBlock
=
isFixedContainingBlock
|
|
aFrame
-
>
IsAbsPosContainingBlock
(
)
;
for
(
nsIFrame
*
f
=
aFrame
;
f
;
f
=
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
f
)
)
{
if
(
ContainingBlockChangeAffectsDescendants
(
aMaybeChangingCB
f
isAbsPosContainingBlock
isFixedContainingBlock
)
)
{
return
true
;
}
}
return
false
;
}
static
void
DoApplyRenderingChangeToTree
(
nsIFrame
*
aFrame
nsChangeHint
aChange
)
{
MOZ_ASSERT
(
gInApplyRenderingChangeToTree
"
should
only
be
called
within
ApplyRenderingChangeToTree
"
)
;
for
(
;
aFrame
;
aFrame
=
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
aFrame
)
)
{
SyncViewsAndInvalidateDescendants
(
aFrame
nsChangeHint
(
aChange
&
(
nsChangeHint_RepaintFrame
|
nsChangeHint_UpdateOpacityLayer
|
nsChangeHint_SchedulePaint
)
)
)
;
bool
needInvalidatingPaint
=
false
;
if
(
aChange
&
nsChangeHint_RepaintFrame
)
{
needInvalidatingPaint
=
true
;
aFrame
-
>
InvalidateFrameSubtree
(
)
;
if
(
(
aChange
&
nsChangeHint_UpdateEffects
)
&
&
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
&
&
!
aFrame
-
>
IsSVGOuterSVGFrame
(
)
)
{
SVGUtils
:
:
ScheduleReflowSVG
(
aFrame
)
;
}
ActiveLayerTracker
:
:
NotifyNeedsRepaint
(
aFrame
)
;
}
if
(
aChange
&
nsChangeHint_UpdateOpacityLayer
)
{
needInvalidatingPaint
=
true
;
ActiveLayerTracker
:
:
NotifyRestyle
(
aFrame
eCSSProperty_opacity
)
;
if
(
SVGIntegrationUtils
:
:
UsingEffectsForFrame
(
aFrame
)
)
{
aFrame
-
>
InvalidateFrameSubtree
(
)
;
}
}
if
(
(
aChange
&
nsChangeHint_UpdateTransformLayer
)
&
&
aFrame
-
>
IsTransformed
(
)
)
{
ActiveLayerTracker
:
:
NotifyRestyle
(
aFrame
eCSSProperty_transform
)
;
needInvalidatingPaint
=
true
;
}
if
(
aChange
&
nsChangeHint_ChildrenOnlyTransform
)
{
needInvalidatingPaint
=
true
;
nsIFrame
*
childFrame
=
GetFrameForChildrenOnlyTransformHint
(
aFrame
)
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
for
(
;
childFrame
;
childFrame
=
childFrame
-
>
GetNextSibling
(
)
)
{
ActiveLayerTracker
:
:
NotifyRestyle
(
childFrame
eCSSProperty_transform
)
;
}
}
if
(
aChange
&
nsChangeHint_SchedulePaint
)
{
needInvalidatingPaint
=
true
;
}
aFrame
-
>
SchedulePaint
(
needInvalidatingPaint
?
nsIFrame
:
:
PAINT_DEFAULT
:
nsIFrame
:
:
PAINT_COMPOSITE_ONLY
)
;
}
}
static
void
SyncViewsAndInvalidateDescendants
(
nsIFrame
*
aFrame
nsChangeHint
aChange
)
{
MOZ_ASSERT
(
gInApplyRenderingChangeToTree
"
should
only
be
called
within
ApplyRenderingChangeToTree
"
)
;
NS_ASSERTION
(
nsChangeHint_size_t
(
aChange
)
=
=
(
aChange
&
(
nsChangeHint_RepaintFrame
|
nsChangeHint_UpdateOpacityLayer
|
nsChangeHint_SchedulePaint
)
)
"
Invalid
change
flag
"
)
;
aFrame
-
>
SyncFrameViewProperties
(
)
;
for
(
const
auto
&
[
list
listID
]
:
aFrame
-
>
ChildLists
(
)
)
{
for
(
nsIFrame
*
child
:
list
)
{
if
(
!
child
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
)
{
if
(
child
-
>
IsPlaceholderFrame
(
)
)
{
nsIFrame
*
outOfFlowFrame
=
nsPlaceholderFrame
:
:
GetRealFrameForPlaceholder
(
child
)
;
DoApplyRenderingChangeToTree
(
outOfFlowFrame
aChange
)
;
}
else
if
(
listID
=
=
nsIFrame
:
:
kPopupList
)
{
DoApplyRenderingChangeToTree
(
child
aChange
)
;
}
else
{
SyncViewsAndInvalidateDescendants
(
child
aChange
)
;
}
}
}
}
}
static
void
ApplyRenderingChangeToTree
(
PresShell
*
aPresShell
nsIFrame
*
aFrame
nsChangeHint
aChange
)
{
NS_ASSERTION
(
!
(
aChange
&
nsChangeHint_UpdateTransformLayer
)
|
|
aFrame
-
>
IsTransformed
(
)
|
|
aFrame
-
>
StyleDisplay
(
)
-
>
HasTransformStyle
(
)
"
Unexpected
UpdateTransformLayer
hint
"
)
;
if
(
aPresShell
-
>
IsPaintingSuppressed
(
)
)
{
aChange
&
=
~
nsChangeHint_RepaintFrame
;
if
(
!
aChange
)
{
return
;
}
}
#
ifdef
DEBUG
gInApplyRenderingChangeToTree
=
true
;
#
endif
if
(
aChange
&
nsChangeHint_RepaintFrame
)
{
if
(
aFrame
-
>
IsPrimaryFrameOfRootOrBodyElement
(
)
)
{
nsIFrame
*
rootFrame
=
aPresShell
-
>
GetRootFrame
(
)
;
MOZ_ASSERT
(
rootFrame
"
No
root
frame
?
"
)
;
DoApplyRenderingChangeToTree
(
rootFrame
nsChangeHint_RepaintFrame
)
;
aChange
&
=
~
nsChangeHint_RepaintFrame
;
if
(
!
aChange
)
{
return
;
}
}
}
DoApplyRenderingChangeToTree
(
aFrame
aChange
)
;
#
ifdef
DEBUG
gInApplyRenderingChangeToTree
=
false
;
#
endif
}
static
void
AddSubtreeToOverflowTracker
(
nsIFrame
*
aFrame
OverflowChangedTracker
&
aOverflowChangedTracker
)
{
if
(
aFrame
-
>
FrameMaintainsOverflow
(
)
)
{
aOverflowChangedTracker
.
AddFrame
(
aFrame
OverflowChangedTracker
:
:
CHILDREN_CHANGED
)
;
}
for
(
const
auto
&
childList
:
aFrame
-
>
ChildLists
(
)
)
{
for
(
nsIFrame
*
child
:
childList
.
mList
)
{
AddSubtreeToOverflowTracker
(
child
aOverflowChangedTracker
)
;
}
}
}
static
void
StyleChangeReflow
(
nsIFrame
*
aFrame
nsChangeHint
aHint
)
{
IntrinsicDirty
dirtyType
;
if
(
aHint
&
nsChangeHint_ClearDescendantIntrinsics
)
{
NS_ASSERTION
(
aHint
&
nsChangeHint_ClearAncestorIntrinsics
"
Please
read
the
comments
in
nsChangeHint
.
h
"
)
;
NS_ASSERTION
(
aHint
&
nsChangeHint_NeedDirtyReflow
"
ClearDescendantIntrinsics
requires
NeedDirtyReflow
"
)
;
dirtyType
=
IntrinsicDirty
:
:
StyleChange
;
}
else
if
(
(
aHint
&
nsChangeHint_UpdateComputedBSize
)
&
&
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_DESCENDANT_INTRINSIC_ISIZE_DEPENDS_ON_BSIZE
)
)
{
dirtyType
=
IntrinsicDirty
:
:
StyleChange
;
}
else
if
(
aHint
&
nsChangeHint_ClearAncestorIntrinsics
)
{
dirtyType
=
IntrinsicDirty
:
:
TreeChange
;
}
else
if
(
(
aHint
&
nsChangeHint_UpdateComputedBSize
)
&
&
HasBoxAncestor
(
aFrame
)
)
{
dirtyType
=
IntrinsicDirty
:
:
TreeChange
;
}
else
{
dirtyType
=
IntrinsicDirty
:
:
Resize
;
}
if
(
aHint
&
nsChangeHint_UpdateComputedBSize
)
{
aFrame
-
>
SetHasBSizeChange
(
true
)
;
}
nsFrameState
dirtyBits
;
if
(
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
)
{
dirtyBits
=
nsFrameState
(
0
)
;
}
else
if
(
(
aHint
&
nsChangeHint_NeedDirtyReflow
)
|
|
dirtyType
=
=
IntrinsicDirty
:
:
StyleChange
)
{
dirtyBits
=
NS_FRAME_IS_DIRTY
;
}
else
{
dirtyBits
=
NS_FRAME_HAS_DIRTY_CHILDREN
;
}
if
(
dirtyType
=
=
IntrinsicDirty
:
:
Resize
&
&
!
dirtyBits
)
return
;
ReflowRootHandling
rootHandling
;
if
(
aHint
&
nsChangeHint_ReflowChangesSizeOrPosition
)
{
rootHandling
=
ReflowRootHandling
:
:
PositionOrSizeChange
;
}
else
{
rootHandling
=
ReflowRootHandling
:
:
NoPositionOrSizeChange
;
}
do
{
aFrame
-
>
PresShell
(
)
-
>
FrameNeedsReflow
(
aFrame
dirtyType
dirtyBits
rootHandling
)
;
aFrame
=
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
aFrame
)
;
}
while
(
aFrame
)
;
}
static
nsIContent
*
NextSiblingWhichMayHaveFrame
(
nsIContent
*
aContent
)
{
for
(
nsIContent
*
next
=
aContent
-
>
GetNextSibling
(
)
;
next
;
next
=
next
-
>
GetNextSibling
(
)
)
{
if
(
next
-
>
IsElement
(
)
|
|
next
-
>
IsText
(
)
)
{
return
next
;
}
}
return
nullptr
;
}
static
inline
bool
CanSkipOverflowUpdates
(
const
nsIFrame
*
aFrame
)
{
return
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_IS_DIRTY
|
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
}
static
inline
void
TryToDealWithScrollbarChange
(
nsChangeHint
&
aHint
nsIContent
*
aContent
nsIFrame
*
aFrame
nsPresContext
*
aPc
)
{
if
(
!
(
aHint
&
nsChangeHint_ScrollbarChange
)
)
{
return
;
}
aHint
&
=
~
nsChangeHint_ScrollbarChange
;
if
(
aHint
&
nsChangeHint_ReconstructFrame
)
{
return
;
}
MOZ_ASSERT
(
aFrame
"
If
we
'
re
not
reframing
we
ought
to
have
a
frame
"
)
;
const
bool
isRoot
=
aContent
-
>
IsInUncomposedDoc
(
)
&
&
!
aContent
-
>
GetParent
(
)
;
if
(
isRoot
|
|
aContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
Element
*
prevOverride
=
aPc
-
>
GetViewportScrollStylesOverrideElement
(
)
;
Element
*
newOverride
=
aPc
-
>
UpdateViewportScrollStylesOverride
(
)
;
const
auto
ProvidesScrollbarStyles
=
[
&
]
(
nsIContent
*
aOverride
)
{
if
(
aOverride
)
{
return
aOverride
=
=
aContent
;
}
return
isRoot
;
}
;
if
(
ProvidesScrollbarStyles
(
prevOverride
)
|
|
ProvidesScrollbarStyles
(
newOverride
)
)
{
if
(
!
prevOverride
|
|
!
newOverride
|
|
prevOverride
=
=
newOverride
)
{
if
(
nsIScrollableFrame
*
sf
=
do_QueryFrame
(
aFrame
)
)
{
sf
-
>
MarkScrollbarsDirtyForReflow
(
)
;
}
else
if
(
nsIScrollableFrame
*
sf
=
aPc
-
>
PresShell
(
)
-
>
GetRootScrollFrameAsScrollable
(
)
)
{
sf
-
>
MarkScrollbarsDirtyForReflow
(
)
;
}
aHint
|
=
nsChangeHint_ReflowHintsForScrollbarChange
;
}
else
{
aHint
|
=
nsChangeHint_ReconstructFrame
;
}
return
;
}
}
const
bool
scrollable
=
aFrame
-
>
StyleDisplay
(
)
-
>
IsScrollableOverflow
(
)
;
if
(
nsIScrollableFrame
*
sf
=
do_QueryFrame
(
aFrame
)
)
{
if
(
scrollable
&
&
sf
-
>
HasAllNeededScrollbars
(
)
)
{
sf
-
>
MarkScrollbarsDirtyForReflow
(
)
;
aHint
|
=
nsChangeHint_ReflowHintsForScrollbarChange
;
return
;
}
}
else
if
(
!
scrollable
)
{
return
;
}
aHint
|
=
nsChangeHint_ReconstructFrame
;
}
static
void
TryToHandleContainingBlockChange
(
nsChangeHint
&
aHint
nsIFrame
*
aFrame
)
{
if
(
!
(
aHint
&
nsChangeHint_UpdateContainingBlock
)
)
{
return
;
}
if
(
aHint
&
nsChangeHint_ReconstructFrame
)
{
return
;
}
MOZ_ASSERT
(
aFrame
"
If
we
'
re
not
reframing
we
ought
to
have
a
frame
"
)
;
nsIFrame
*
containingBlock
=
ContainingBlockForFrame
(
aFrame
)
;
if
(
!
containingBlock
|
|
NeedToReframeToUpdateContainingBlock
(
aFrame
containingBlock
)
)
{
aHint
|
=
nsChangeHint_ReconstructFrame
;
return
;
}
const
bool
isCb
=
aFrame
-
>
IsAbsPosContainingBlock
(
)
;
for
(
nsIFrame
*
cont
=
containingBlock
;
cont
;
cont
=
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
cont
)
)
{
if
(
isCb
)
{
if
(
!
cont
-
>
IsAbsoluteContainer
(
)
&
&
cont
-
>
HasAnyStateBits
(
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
)
{
cont
-
>
MarkAsAbsoluteContainingBlock
(
)
;
}
}
else
if
(
cont
-
>
IsAbsoluteContainer
(
)
)
{
if
(
cont
-
>
HasAbsolutelyPositionedChildren
(
)
)
{
NS_WARNING
(
"
skipping
removal
of
absolute
containing
block
"
)
;
}
else
{
cont
-
>
MarkAsNotAbsoluteContainingBlock
(
)
;
}
}
}
}
void
RestyleManager
:
:
ProcessRestyledFrames
(
nsStyleChangeList
&
aChangeList
)
{
NS_ASSERTION
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
Someone
forgot
a
script
blocker
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mDestroyedFrames
"
ProcessRestyledFrames
recursion
"
)
;
if
(
aChangeList
.
IsEmpty
(
)
)
{
return
;
}
typedef
decltype
(
mDestroyedFrames
)
DestroyedFramesT
;
class
MOZ_RAII
MaybeClearDestroyedFrames
{
private
:
DestroyedFramesT
&
mDestroyedFramesRef
;
const
bool
mResetOnDestruction
;
public
:
explicit
MaybeClearDestroyedFrames
(
DestroyedFramesT
&
aTarget
)
:
mDestroyedFramesRef
(
aTarget
)
mResetOnDestruction
(
!
aTarget
)
{
}
~
MaybeClearDestroyedFrames
(
)
{
if
(
mResetOnDestruction
)
{
mDestroyedFramesRef
.
reset
(
nullptr
)
;
}
}
}
;
MaybeClearDestroyedFrames
maybeClear
(
mDestroyedFrames
)
;
if
(
!
mDestroyedFrames
)
{
mDestroyedFrames
=
MakeUnique
<
nsTHashSet
<
const
nsIFrame
*
>
>
(
)
;
}
AUTO_PROFILER_LABEL
(
"
RestyleManager
:
:
ProcessRestyledFrames
"
LAYOUT
)
;
nsPresContext
*
presContext
=
PresContext
(
)
;
nsCSSFrameConstructor
*
frameConstructor
=
presContext
-
>
FrameConstructor
(
)
;
bool
didUpdateCursor
=
false
;
for
(
size_t
i
=
0
;
i
<
aChangeList
.
Length
(
)
;
+
+
i
)
{
size_t
lazyRangeStart
=
i
;
while
(
i
<
aChangeList
.
Length
(
)
&
&
aChangeList
[
i
]
.
mContent
&
&
aChangeList
[
i
]
.
mContent
-
>
HasFlag
(
NODE_NEEDS_FRAME
)
&
&
(
i
=
=
lazyRangeStart
|
|
NextSiblingWhichMayHaveFrame
(
aChangeList
[
i
-
1
]
.
mContent
)
=
=
aChangeList
[
i
]
.
mContent
)
)
{
MOZ_ASSERT
(
aChangeList
[
i
]
.
mHint
&
nsChangeHint_ReconstructFrame
)
;
MOZ_ASSERT
(
!
aChangeList
[
i
]
.
mFrame
)
;
+
+
i
;
}
if
(
i
!
=
lazyRangeStart
)
{
nsIContent
*
start
=
aChangeList
[
lazyRangeStart
]
.
mContent
;
nsIContent
*
end
=
NextSiblingWhichMayHaveFrame
(
aChangeList
[
i
-
1
]
.
mContent
)
;
if
(
!
end
)
{
frameConstructor
-
>
ContentAppended
(
start
nsCSSFrameConstructor
:
:
InsertionKind
:
:
Sync
)
;
}
else
{
frameConstructor
-
>
ContentRangeInserted
(
start
end
nsCSSFrameConstructor
:
:
InsertionKind
:
:
Sync
)
;
}
}
for
(
size_t
j
=
lazyRangeStart
;
j
<
i
;
+
+
j
)
{
MOZ_ASSERT
(
!
aChangeList
[
j
]
.
mContent
-
>
GetPrimaryFrame
(
)
|
|
!
aChangeList
[
j
]
.
mContent
-
>
HasFlag
(
NODE_NEEDS_FRAME
)
)
;
}
if
(
i
=
=
aChangeList
.
Length
(
)
)
{
break
;
}
const
nsStyleChangeData
&
data
=
aChangeList
[
i
]
;
nsIFrame
*
frame
=
data
.
mFrame
;
nsIContent
*
content
=
data
.
mContent
;
nsChangeHint
hint
=
data
.
mHint
;
bool
didReflowThisFrame
=
false
;
NS_ASSERTION
(
!
(
hint
&
nsChangeHint_AllReflowHints
)
|
|
(
hint
&
nsChangeHint_NeedReflow
)
"
Reflow
hint
bits
set
without
actually
asking
for
a
reflow
"
)
;
if
(
frame
&
&
mDestroyedFrames
-
>
Contains
(
frame
)
)
{
continue
;
}
if
(
frame
&
&
frame
-
>
GetContent
(
)
!
=
content
)
{
frame
=
nullptr
;
if
(
!
(
hint
&
nsChangeHint_ReconstructFrame
)
)
{
continue
;
}
}
TryToDealWithScrollbarChange
(
hint
content
frame
presContext
)
;
TryToHandleContainingBlockChange
(
hint
frame
)
;
if
(
hint
&
nsChangeHint_ReconstructFrame
)
{
frameConstructor
-
>
RecreateFramesForContent
(
content
nsCSSFrameConstructor
:
:
InsertionKind
:
:
Sync
)
;
continue
;
}
MOZ_ASSERT
(
frame
"
This
shouldn
'
t
happen
"
)
;
if
(
hint
&
nsChangeHint_AddOrRemoveTransform
)
{
for
(
nsIFrame
*
cont
=
frame
;
cont
;
cont
=
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
cont
)
)
{
if
(
cont
-
>
StyleDisplay
(
)
-
>
HasTransform
(
cont
)
)
{
cont
-
>
AddStateBits
(
NS_FRAME_MAY_BE_TRANSFORMED
)
;
}
}
}
if
(
!
frame
-
>
FrameMaintainsOverflow
(
)
)
{
hint
&
=
~
(
nsChangeHint_UpdateOverflow
|
nsChangeHint_ChildrenOnlyTransform
|
nsChangeHint_UpdatePostTransformOverflow
|
nsChangeHint_UpdateParentOverflow
|
nsChangeHint_UpdateSubtreeOverflow
)
;
}
if
(
!
frame
-
>
HasAnyStateBits
(
NS_FRAME_MAY_BE_TRANSFORMED
)
)
{
hint
&
=
~
(
nsChangeHint_UpdatePostTransformOverflow
|
nsChangeHint_UpdateTransformLayer
)
;
}
if
(
hint
&
nsChangeHint_AddOrRemoveTransform
)
{
hint
&
=
~
nsChangeHint_UpdateTransformLayer
;
}
if
(
(
hint
&
nsChangeHint_UpdateEffects
)
&
&
frame
=
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
frame
)
)
{
SVGObserverUtils
:
:
UpdateEffects
(
frame
)
;
}
if
(
(
hint
&
nsChangeHint_InvalidateRenderingObservers
)
|
|
(
(
hint
&
nsChangeHint_UpdateOpacityLayer
)
&
&
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
&
&
!
frame
-
>
IsSVGOuterSVGFrame
(
)
)
)
{
SVGObserverUtils
:
:
InvalidateRenderingObservers
(
frame
)
;
frame
-
>
SchedulePaint
(
)
;
}
if
(
hint
&
nsChangeHint_NeedReflow
)
{
StyleChangeReflow
(
frame
hint
)
;
didReflowThisFrame
=
true
;
}
if
(
(
hint
&
nsChangeHint_UpdateOpacityLayer
)
&
&
SVGUtils
:
:
CanOptimizeOpacity
(
frame
)
)
{
hint
&
=
~
nsChangeHint_UpdateOpacityLayer
;
hint
|
=
nsChangeHint_RepaintFrame
;
}
if
(
(
hint
&
nsChangeHint_UpdateUsesOpacity
)
&
&
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eTablePart
)
)
{
NS_ASSERTION
(
hint
&
nsChangeHint_UpdateOpacityLayer
"
should
only
return
UpdateUsesOpacity
hint
"
"
when
also
returning
UpdateOpacityLayer
hint
"
)
;
hint
&
=
~
nsChangeHint_UpdateOpacityLayer
;
hint
|
=
nsChangeHint_RepaintFrame
;
}
if
(
(
hint
&
nsChangeHint_UpdateUsesOpacity
)
&
&
frame
-
>
StyleDisplay
(
)
-
>
mTransformStyle
=
=
StyleTransformStyle
:
:
Preserve3d
)
{
hint
|
=
nsChangeHint_UpdateSubtreeOverflow
;
}
if
(
hint
&
nsChangeHint_UpdateBackgroundPosition
)
{
hint
|
=
nsChangeHint_SchedulePaint
;
if
(
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eTablePart
)
|
|
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eMathML
)
)
{
hint
|
=
nsChangeHint_RepaintFrame
;
}
}
if
(
hint
&
(
nsChangeHint_RepaintFrame
|
nsChangeHint_UpdateOpacityLayer
|
nsChangeHint_UpdateTransformLayer
|
nsChangeHint_ChildrenOnlyTransform
|
nsChangeHint_SchedulePaint
)
)
{
ApplyRenderingChangeToTree
(
presContext
-
>
PresShell
(
)
frame
hint
)
;
}
if
(
(
hint
&
nsChangeHint_RecomputePosition
)
&
&
!
didReflowThisFrame
)
{
if
(
!
RecomputePosition
(
frame
)
)
{
StyleChangeReflow
(
frame
nsChangeHint_NeedReflow
|
nsChangeHint_ReflowChangesSizeOrPosition
)
;
didReflowThisFrame
=
true
;
}
}
NS_ASSERTION
(
!
(
hint
&
nsChangeHint_ChildrenOnlyTransform
)
|
|
(
hint
&
nsChangeHint_UpdateOverflow
)
"
nsChangeHint_UpdateOverflow
should
be
passed
too
"
)
;
if
(
!
didReflowThisFrame
&
&
(
hint
&
(
nsChangeHint_UpdateOverflow
|
nsChangeHint_UpdatePostTransformOverflow
|
nsChangeHint_UpdateParentOverflow
|
nsChangeHint_UpdateSubtreeOverflow
)
)
)
{
if
(
hint
&
nsChangeHint_UpdateSubtreeOverflow
)
{
for
(
nsIFrame
*
cont
=
frame
;
cont
;
cont
=
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
cont
)
)
{
AddSubtreeToOverflowTracker
(
cont
mOverflowChangedTracker
)
;
}
hint
&
=
~
(
nsChangeHint_UpdateOverflow
|
nsChangeHint_UpdatePostTransformOverflow
)
;
}
if
(
hint
&
nsChangeHint_ChildrenOnlyTransform
)
{
nsIFrame
*
hintFrame
=
GetFrameForChildrenOnlyTransformHint
(
frame
)
;
NS_ASSERTION
(
!
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
frame
)
"
SVG
frames
should
not
have
continuations
"
"
or
ib
-
split
siblings
"
)
;
NS_ASSERTION
(
!
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
hintFrame
)
"
SVG
frames
should
not
have
continuations
"
"
or
ib
-
split
siblings
"
)
;
if
(
hintFrame
-
>
IsSVGOuterSVGAnonChildFrame
(
)
)
{
if
(
!
CanSkipOverflowUpdates
(
hintFrame
)
)
{
mOverflowChangedTracker
.
AddFrame
(
hintFrame
OverflowChangedTracker
:
:
CHILDREN_CHANGED
)
;
}
}
else
{
nsIFrame
*
childFrame
=
hintFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
for
(
;
childFrame
;
childFrame
=
childFrame
-
>
GetNextSibling
(
)
)
{
MOZ_ASSERT
(
childFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
"
Not
expecting
non
-
SVG
children
"
)
;
if
(
!
CanSkipOverflowUpdates
(
childFrame
)
)
{
mOverflowChangedTracker
.
AddFrame
(
childFrame
OverflowChangedTracker
:
:
CHILDREN_CHANGED
)
;
}
NS_ASSERTION
(
!
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
childFrame
)
"
SVG
frames
should
not
have
continuations
"
"
or
ib
-
split
siblings
"
)
;
NS_ASSERTION
(
childFrame
-
>
GetParent
(
)
=
=
hintFrame
"
SVG
child
frame
not
expected
to
have
different
parent
"
)
;
}
}
}
if
(
!
CanSkipOverflowUpdates
(
frame
)
)
{
if
(
hint
&
(
nsChangeHint_UpdateOverflow
|
nsChangeHint_UpdatePostTransformOverflow
)
)
{
OverflowChangedTracker
:
:
ChangeKind
changeKind
;
if
(
hint
&
nsChangeHint_UpdateOverflow
)
{
changeKind
=
OverflowChangedTracker
:
:
CHILDREN_CHANGED
;
}
else
{
changeKind
=
OverflowChangedTracker
:
:
TRANSFORM_CHANGED
;
}
for
(
nsIFrame
*
cont
=
frame
;
cont
;
cont
=
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
cont
)
)
{
mOverflowChangedTracker
.
AddFrame
(
cont
changeKind
)
;
}
}
if
(
hint
&
nsChangeHint_UpdateParentOverflow
)
{
MOZ_ASSERT
(
frame
-
>
GetParent
(
)
"
shouldn
'
t
get
style
hints
for
the
root
frame
"
)
;
for
(
nsIFrame
*
cont
=
frame
;
cont
;
cont
=
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
cont
)
)
{
mOverflowChangedTracker
.
AddFrame
(
cont
-
>
GetParent
(
)
OverflowChangedTracker
:
:
CHILDREN_CHANGED
)
;
}
}
}
}
if
(
(
hint
&
nsChangeHint_UpdateCursor
)
&
&
!
didUpdateCursor
)
{
presContext
-
>
PresShell
(
)
-
>
SynthesizeMouseMove
(
false
)
;
didUpdateCursor
=
true
;
}
if
(
hint
&
nsChangeHint_UpdateTableCellSpans
)
{
frameConstructor
-
>
UpdateTableCellSpans
(
content
)
;
}
if
(
hint
&
nsChangeHint_VisibilityChange
)
{
frame
-
>
UpdateVisibleDescendantsState
(
)
;
}
}
aChangeList
.
Clear
(
)
;
FlushOverflowChangedTracker
(
)
;
}
uint64_t
RestyleManager
:
:
GetAnimationGenerationForFrame
(
nsIFrame
*
aStyleFrame
)
{
EffectSet
*
effectSet
=
EffectSet
:
:
GetEffectSetForStyleFrame
(
aStyleFrame
)
;
return
effectSet
?
effectSet
-
>
GetAnimationGeneration
(
)
:
0
;
}
void
RestyleManager
:
:
IncrementAnimationGeneration
(
)
{
if
(
!
mInStyleRefresh
)
{
+
+
mAnimationGeneration
;
}
}
void
RestyleManager
:
:
AddLayerChangesForAnimation
(
nsIFrame
*
aStyleFrame
nsIFrame
*
aPrimaryFrame
Element
*
aElement
nsChangeHint
aHintForThisFrame
nsStyleChangeList
&
aChangeListToProcess
)
{
MOZ_ASSERT
(
aElement
)
;
MOZ_ASSERT
(
!
!
aStyleFrame
=
=
!
!
aPrimaryFrame
)
;
if
(
!
aStyleFrame
)
{
return
;
}
uint64_t
frameGeneration
=
RestyleManager
:
:
GetAnimationGenerationForFrame
(
aStyleFrame
)
;
Maybe
<
nsCSSPropertyIDSet
>
effectiveAnimationProperties
;
nsChangeHint
hint
=
nsChangeHint
(
0
)
;
auto
maybeApplyChangeHint
=
[
&
]
(
const
Maybe
<
uint64_t
>
&
aGeneration
DisplayItemType
aDisplayItemType
)
-
>
bool
{
if
(
aGeneration
&
&
frameGeneration
!
=
*
aGeneration
)
{
if
(
aDisplayItemType
=
=
DisplayItemType
:
:
TYPE_TRANSFORM
&
&
!
aStyleFrame
-
>
StyleDisplay
(
)
-
>
HasTransformStyle
(
)
)
{
if
(
!
(
NS_IsHintSubset
(
nsChangeHint_ComprehensiveAddOrRemoveTransform
aHintForThisFrame
)
)
)
{
hint
|
=
nsChangeHint_ComprehensiveAddOrRemoveTransform
;
}
return
true
;
}
hint
|
=
LayerAnimationInfo
:
:
GetChangeHintFor
(
aDisplayItemType
)
;
}
if
(
!
aGeneration
)
{
nsChangeHint
hintForDisplayItem
=
LayerAnimationInfo
:
:
GetChangeHintFor
(
aDisplayItemType
)
;
if
(
NS_IsHintSubset
(
hintForDisplayItem
aHintForThisFrame
)
)
{
return
true
;
}
if
(
!
effectiveAnimationProperties
)
{
effectiveAnimationProperties
.
emplace
(
nsLayoutUtils
:
:
GetAnimationPropertiesForCompositor
(
aStyleFrame
)
)
;
}
const
nsCSSPropertyIDSet
&
propertiesForDisplayItem
=
LayerAnimationInfo
:
:
GetCSSPropertiesFor
(
aDisplayItemType
)
;
if
(
effectiveAnimationProperties
-
>
Intersects
(
propertiesForDisplayItem
)
)
{
hint
|
=
hintForDisplayItem
;
}
}
return
true
;
}
;
AnimationInfo
:
:
EnumerateGenerationOnFrame
(
aStyleFrame
aElement
LayerAnimationInfo
:
:
sDisplayItemTypes
maybeApplyChangeHint
)
;
if
(
hint
)
{
aChangeListToProcess
.
AppendChange
(
aPrimaryFrame
aElement
hint
)
;
}
}
RestyleManager
:
:
AnimationsWithDestroyedFrame
:
:
AnimationsWithDestroyedFrame
(
RestyleManager
*
aRestyleManager
)
:
mRestyleManager
(
aRestyleManager
)
mRestorePointer
(
mRestyleManager
-
>
mAnimationsWithDestroyedFrame
)
{
MOZ_ASSERT
(
!
mRestyleManager
-
>
mAnimationsWithDestroyedFrame
"
shouldn
'
t
construct
recursively
"
)
;
mRestyleManager
-
>
mAnimationsWithDestroyedFrame
=
this
;
}
void
RestyleManager
:
:
AnimationsWithDestroyedFrame
:
:
StopAnimationsForElementsWithoutFrames
(
)
{
StopAnimationsWithoutFrame
(
mContents
PseudoStyleType
:
:
NotPseudo
)
;
StopAnimationsWithoutFrame
(
mBeforeContents
PseudoStyleType
:
:
before
)
;
StopAnimationsWithoutFrame
(
mAfterContents
PseudoStyleType
:
:
after
)
;
StopAnimationsWithoutFrame
(
mMarkerContents
PseudoStyleType
:
:
marker
)
;
}
void
RestyleManager
:
:
AnimationsWithDestroyedFrame
:
:
StopAnimationsWithoutFrame
(
nsTArray
<
RefPtr
<
nsIContent
>
>
&
aArray
PseudoStyleType
aPseudoType
)
{
nsAnimationManager
*
animationManager
=
mRestyleManager
-
>
PresContext
(
)
-
>
AnimationManager
(
)
;
nsTransitionManager
*
transitionManager
=
mRestyleManager
-
>
PresContext
(
)
-
>
TransitionManager
(
)
;
for
(
nsIContent
*
content
:
aArray
)
{
if
(
aPseudoType
=
=
PseudoStyleType
:
:
NotPseudo
)
{
if
(
content
-
>
GetPrimaryFrame
(
)
)
{
continue
;
}
}
else
if
(
aPseudoType
=
=
PseudoStyleType
:
:
before
)
{
if
(
nsLayoutUtils
:
:
GetBeforeFrame
(
content
)
)
{
continue
;
}
}
else
if
(
aPseudoType
=
=
PseudoStyleType
:
:
after
)
{
if
(
nsLayoutUtils
:
:
GetAfterFrame
(
content
)
)
{
continue
;
}
}
else
if
(
aPseudoType
=
=
PseudoStyleType
:
:
marker
)
{
if
(
nsLayoutUtils
:
:
GetMarkerFrame
(
content
)
)
{
continue
;
}
}
dom
:
:
Element
*
element
=
content
-
>
AsElement
(
)
;
animationManager
-
>
StopAnimationsForElement
(
element
aPseudoType
)
;
transitionManager
-
>
StopAnimationsForElement
(
element
aPseudoType
)
;
EffectSet
*
effectSet
=
EffectSet
:
:
GetEffectSet
(
element
aPseudoType
)
;
if
(
effectSet
)
{
for
(
KeyframeEffect
*
effect
:
*
effectSet
)
{
effect
-
>
ResetIsRunningOnCompositor
(
)
;
}
}
}
}
#
ifdef
DEBUG
static
bool
IsAnonBox
(
const
nsIFrame
*
aFrame
)
{
return
aFrame
-
>
Style
(
)
-
>
IsAnonBox
(
)
;
}
static
const
nsIFrame
*
FirstContinuationOrPartOfIBSplit
(
const
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
)
{
return
nullptr
;
}
return
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
aFrame
)
;
}
static
const
nsIFrame
*
ExpectedOwnerForChild
(
const
nsIFrame
*
aFrame
)
{
const
nsIFrame
*
parent
=
aFrame
-
>
GetParent
(
)
;
if
(
aFrame
-
>
IsTableFrame
(
)
)
{
MOZ_ASSERT
(
parent
-
>
IsTableWrapperFrame
(
)
)
;
parent
=
parent
-
>
GetParent
(
)
;
}
if
(
IsAnonBox
(
aFrame
)
&
&
!
aFrame
-
>
IsTextFrame
(
)
)
{
if
(
parent
-
>
IsLineFrame
(
)
)
{
parent
=
parent
-
>
GetParent
(
)
;
}
return
parent
-
>
IsViewportFrame
(
)
?
nullptr
:
FirstContinuationOrPartOfIBSplit
(
parent
)
;
}
if
(
aFrame
-
>
IsLineFrame
(
)
)
{
return
parent
;
}
if
(
aFrame
-
>
IsLetterFrame
(
)
)
{
if
(
parent
-
>
IsLineFrame
(
)
)
{
parent
=
parent
-
>
GetParent
(
)
;
}
return
FirstContinuationOrPartOfIBSplit
(
parent
)
;
}
if
(
parent
-
>
IsLetterFrame
(
)
)
{
parent
=
parent
-
>
GetParent
(
)
;
}
parent
=
FirstContinuationOrPartOfIBSplit
(
parent
)
;
while
(
parent
&
&
(
IsAnonBox
(
parent
)
|
|
parent
-
>
IsLineFrame
(
)
)
)
{
auto
pseudo
=
parent
-
>
Style
(
)
-
>
GetPseudoType
(
)
;
if
(
pseudo
=
=
PseudoStyleType
:
:
tableWrapper
)
{
const
nsIFrame
*
tableFrame
=
parent
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
MOZ_ASSERT
(
tableFrame
-
>
IsTableFrame
(
)
)
;
parent
=
IsAnonBox
(
tableFrame
)
?
parent
-
>
GetParent
(
)
:
tableFrame
;
}
else
{
parent
=
parent
-
>
GetInFlowParent
(
)
;
}
parent
=
FirstContinuationOrPartOfIBSplit
(
parent
)
;
}
return
parent
;
}
static
bool
IsInReplicatedFixedPosTree
(
const
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
-
>
PresContext
(
)
-
>
IsPaginated
(
)
)
{
return
false
;
}
for
(
;
aFrame
;
aFrame
=
aFrame
-
>
GetParent
(
)
)
{
if
(
aFrame
-
>
StyleDisplay
(
)
-
>
mPosition
=
=
StylePositionProperty
:
:
Fixed
&
&
!
aFrame
-
>
FirstContinuation
(
)
-
>
IsPrimaryFrame
(
)
&
&
nsLayoutUtils
:
:
IsReallyFixedPos
(
aFrame
)
)
{
return
true
;
}
}
return
true
;
}
void
ServoRestyleState
:
:
AssertOwner
(
const
ServoRestyleState
&
aParent
)
const
{
MOZ_ASSERT
(
mOwner
)
;
MOZ_ASSERT
(
!
mOwner
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
)
;
MOZ_ASSERT
(
!
mOwner
-
>
IsColumnSpanInMulticolSubtree
(
)
)
;
if
(
aParent
.
mOwner
)
{
const
nsIFrame
*
owner
=
ExpectedOwnerForChild
(
mOwner
)
;
if
(
owner
!
=
aParent
.
mOwner
&
&
!
IsInReplicatedFixedPosTree
(
mOwner
)
)
{
MOZ_ASSERT
(
IsAnonBox
(
owner
)
"
Should
only
have
expected
owner
weirdness
when
anon
boxes
"
"
are
involved
"
)
;
bool
found
=
false
;
for
(
;
owner
;
owner
=
ExpectedOwnerForChild
(
owner
)
)
{
if
(
owner
=
=
aParent
.
mOwner
)
{
found
=
true
;
break
;
}
}
MOZ_ASSERT
(
found
"
Must
have
aParent
.
mOwner
on
our
expected
owner
chain
"
)
;
}
}
}
nsChangeHint
ServoRestyleState
:
:
ChangesHandledFor
(
const
nsIFrame
*
aFrame
)
const
{
if
(
!
mOwner
)
{
MOZ_ASSERT
(
!
mChangesHandled
)
;
return
mChangesHandled
;
}
MOZ_ASSERT
(
mOwner
=
=
ExpectedOwnerForChild
(
aFrame
)
|
|
IsInReplicatedFixedPosTree
(
aFrame
)
"
Missed
some
frame
in
the
hierarchy
?
"
)
;
return
mChangesHandled
;
}
#
endif
void
ServoRestyleState
:
:
AddPendingWrapperRestyle
(
nsIFrame
*
aWrapperFrame
)
{
MOZ_ASSERT
(
aWrapperFrame
-
>
Style
(
)
-
>
IsWrapperAnonBox
(
)
"
All
our
wrappers
are
anon
boxes
and
why
would
we
restyle
"
"
non
-
inheriting
ones
?
"
)
;
MOZ_ASSERT
(
aWrapperFrame
-
>
Style
(
)
-
>
IsInheritingAnonBox
(
)
"
All
our
wrappers
are
anon
boxes
and
why
would
we
restyle
"
"
non
-
inheriting
ones
?
"
)
;
MOZ_ASSERT
(
aWrapperFrame
-
>
Style
(
)
-
>
GetPseudoType
(
)
!
=
PseudoStyleType
:
:
cellContent
"
Someone
should
be
using
TableAwareParentFor
"
)
;
MOZ_ASSERT
(
aWrapperFrame
-
>
Style
(
)
-
>
GetPseudoType
(
)
!
=
PseudoStyleType
:
:
tableWrapper
"
Someone
should
be
using
TableAwareParentFor
"
)
;
aWrapperFrame
=
aWrapperFrame
-
>
FirstContinuation
(
)
;
nsIFrame
*
last
=
mPendingWrapperRestyles
.
SafeLastElement
(
nullptr
)
;
if
(
last
=
=
aWrapperFrame
)
{
return
;
}
if
(
aWrapperFrame
-
>
ParentIsWrapperAnonBox
(
)
)
{
AddPendingWrapperRestyle
(
TableAwareParentFor
(
aWrapperFrame
)
)
;
}
if
(
mPendingWrapperRestyles
.
AppendElement
(
aWrapperFrame
fallible
)
)
{
aWrapperFrame
-
>
SetIsWrapperAnonBoxNeedingRestyle
(
true
)
;
}
}
void
ServoRestyleState
:
:
ProcessWrapperRestyles
(
nsIFrame
*
aParentFrame
)
{
size_t
i
=
mPendingWrapperRestyleOffset
;
while
(
i
<
mPendingWrapperRestyles
.
Length
(
)
)
{
i
+
=
ProcessMaybeNestedWrapperRestyle
(
aParentFrame
i
)
;
}
mPendingWrapperRestyles
.
TruncateLength
(
mPendingWrapperRestyleOffset
)
;
}
size_t
ServoRestyleState
:
:
ProcessMaybeNestedWrapperRestyle
(
nsIFrame
*
aParent
size_t
aIndex
)
{
MOZ_ASSERT
(
aIndex
<
mPendingWrapperRestyles
.
Length
(
)
)
;
nsIFrame
*
cur
=
mPendingWrapperRestyles
[
aIndex
]
;
MOZ_ASSERT
(
cur
-
>
Style
(
)
-
>
IsWrapperAnonBox
(
)
)
;
nsIFrame
*
parent
=
cur
-
>
GetParent
(
)
;
if
(
cur
-
>
IsTableFrame
(
)
)
{
MOZ_ASSERT
(
parent
-
>
IsTableWrapperFrame
(
)
)
;
parent
=
parent
-
>
GetParent
(
)
;
}
if
(
parent
-
>
IsLineFrame
(
)
)
{
parent
=
parent
-
>
GetParent
(
)
;
}
MOZ_ASSERT
(
FirstContinuationOrPartOfIBSplit
(
parent
)
=
=
aParent
|
|
(
parent
-
>
Style
(
)
-
>
IsInheritingAnonBox
(
)
&
&
parent
-
>
GetContent
(
)
=
=
aParent
-
>
GetContent
(
)
)
)
;
Maybe
<
ServoRestyleState
>
parentRestyleState
;
nsIFrame
*
parentForRestyle
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
parent
)
;
if
(
parentForRestyle
!
=
aParent
)
{
parentRestyleState
.
emplace
(
*
parentForRestyle
*
this
nsChangeHint_Empty
Type
:
:
InFlow
)
;
}
ServoRestyleState
&
curRestyleState
=
parentRestyleState
?
*
parentRestyleState
:
*
this
;
if
(
cur
-
>
IsWrapperAnonBoxNeedingRestyle
(
)
)
{
parentForRestyle
-
>
UpdateStyleOfChildAnonBox
(
cur
curRestyleState
)
;
cur
-
>
SetIsWrapperAnonBoxNeedingRestyle
(
false
)
;
}
size_t
numProcessed
=
1
;
if
(
aIndex
+
1
<
mPendingWrapperRestyles
.
Length
(
)
)
{
nsIFrame
*
next
=
mPendingWrapperRestyles
[
aIndex
+
1
]
;
if
(
TableAwareParentFor
(
next
)
=
=
cur
&
&
next
-
>
IsWrapperAnonBoxNeedingRestyle
(
)
)
{
ServoRestyleState
childState
(
*
cur
curRestyleState
nsChangeHint_Empty
Type
:
:
InFlow
false
)
;
numProcessed
+
=
childState
.
ProcessMaybeNestedWrapperRestyle
(
cur
aIndex
+
1
)
;
}
}
return
numProcessed
;
}
nsIFrame
*
ServoRestyleState
:
:
TableAwareParentFor
(
const
nsIFrame
*
aChild
)
{
if
(
aChild
-
>
IsTableFrame
(
)
)
{
aChild
=
aChild
-
>
GetParent
(
)
;
MOZ_ASSERT
(
aChild
-
>
IsTableWrapperFrame
(
)
)
;
}
nsIFrame
*
parent
=
aChild
-
>
GetParent
(
)
;
if
(
parent
-
>
Style
(
)
-
>
GetPseudoType
(
)
=
=
PseudoStyleType
:
:
cellContent
)
{
parent
=
parent
-
>
GetParent
(
)
;
}
else
if
(
parent
-
>
IsTableWrapperFrame
(
)
)
{
MOZ_ASSERT
(
aChild
-
>
StyleDisplay
(
)
-
>
mDisplay
=
=
StyleDisplay
:
:
TableCaption
)
;
parent
=
parent
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
}
return
parent
;
}
void
RestyleManager
:
:
PostRestyleEvent
(
Element
*
aElement
RestyleHint
aRestyleHint
nsChangeHint
aMinChangeHint
)
{
MOZ_ASSERT
(
!
(
aMinChangeHint
&
nsChangeHint_NeutralChange
)
"
Didn
'
t
expect
explicit
change
hints
to
be
neutral
!
"
)
;
if
(
MOZ_UNLIKELY
(
IsDisconnected
(
)
)
|
|
MOZ_UNLIKELY
(
PresContext
(
)
-
>
PresShell
(
)
-
>
IsDestroying
(
)
)
)
{
return
;
}
MOZ_ASSERT
(
!
ServoStyleSet
:
:
IsInServoTraversal
(
)
)
;
if
(
!
aRestyleHint
&
&
!
aMinChangeHint
)
{
return
;
}
if
(
aRestyleHint
)
{
if
(
!
(
aRestyleHint
&
RestyleHint
:
:
ForAnimations
(
)
)
)
{
mHaveNonAnimationRestyles
=
true
;
}
IncrementUndisplayedRestyleGeneration
(
)
;
}
if
(
mReentrantChanges
&
&
!
aRestyleHint
)
{
mReentrantChanges
-
>
AppendElement
(
ReentrantChange
{
aElement
aMinChangeHint
}
)
;
return
;
}
if
(
aRestyleHint
|
|
aMinChangeHint
)
{
Servo_NoteExplicitHints
(
aElement
aRestyleHint
aMinChangeHint
)
;
}
}
void
RestyleManager
:
:
PostRestyleEventForAnimations
(
Element
*
aElement
PseudoStyleType
aPseudoType
RestyleHint
aRestyleHint
)
{
Element
*
elementToRestyle
=
EffectCompositor
:
:
GetElementToRestyle
(
aElement
aPseudoType
)
;
if
(
!
elementToRestyle
)
{
return
;
}
AutoRestyleTimelineMarker
marker
(
mPresContext
-
>
GetDocShell
(
)
true
)
;
Servo_NoteExplicitHints
(
elementToRestyle
aRestyleHint
nsChangeHint
(
0
)
)
;
}
void
RestyleManager
:
:
RebuildAllStyleData
(
nsChangeHint
aExtraHint
RestyleHint
aRestyleHint
)
{
if
(
aRestyleHint
.
DefinitelyRecascadesAllSubtree
(
)
)
{
StyleSet
(
)
-
>
ClearCachedStyleData
(
)
;
}
DocumentStyleRootIterator
iter
(
mPresContext
-
>
Document
(
)
)
;
while
(
Element
*
root
=
iter
.
GetNextStyleRoot
(
)
)
{
PostRestyleEvent
(
root
aRestyleHint
aExtraHint
)
;
}
}
void
RestyleManager
:
:
ClearServoDataFromSubtree
(
Element
*
aElement
IncludeRoot
aIncludeRoot
)
{
if
(
aElement
-
>
HasServoData
(
)
)
{
StyleChildrenIterator
it
(
aElement
)
;
for
(
nsIContent
*
n
=
it
.
GetNextChild
(
)
;
n
;
n
=
it
.
GetNextChild
(
)
)
{
if
(
n
-
>
IsElement
(
)
)
{
ClearServoDataFromSubtree
(
n
-
>
AsElement
(
)
IncludeRoot
:
:
Yes
)
;
}
}
}
if
(
MOZ_LIKELY
(
aIncludeRoot
=
=
IncludeRoot
:
:
Yes
)
)
{
aElement
-
>
ClearServoData
(
)
;
MOZ_ASSERT
(
!
aElement
-
>
HasAnyOfFlags
(
Element
:
:
kAllServoDescendantBits
|
NODE_NEEDS_FRAME
)
)
;
MOZ_ASSERT
(
aElement
!
=
aElement
-
>
OwnerDoc
(
)
-
>
GetServoRestyleRoot
(
)
)
;
}
}
void
RestyleManager
:
:
ClearRestyleStateFromSubtree
(
Element
*
aElement
)
{
if
(
aElement
-
>
HasAnyOfFlags
(
Element
:
:
kAllServoDescendantBits
)
)
{
StyleChildrenIterator
it
(
aElement
)
;
for
(
nsIContent
*
n
=
it
.
GetNextChild
(
)
;
n
;
n
=
it
.
GetNextChild
(
)
)
{
if
(
n
-
>
IsElement
(
)
)
{
ClearRestyleStateFromSubtree
(
n
-
>
AsElement
(
)
)
;
}
}
}
bool
wasRestyled
;
Unused
<
<
Servo_TakeChangeHint
(
aElement
&
wasRestyled
)
;
aElement
-
>
UnsetFlags
(
Element
:
:
kAllServoDescendantBits
)
;
}
struct
RestyleManager
:
:
TextPostTraversalState
{
public
:
TextPostTraversalState
(
Element
&
aParentElement
ComputedStyle
*
aParentContext
bool
aDisplayContentsParentStyleChanged
ServoRestyleState
&
aParentRestyleState
)
:
mParentElement
(
aParentElement
)
mParentContext
(
aParentContext
)
mParentRestyleState
(
aParentRestyleState
)
mStyle
(
nullptr
)
mShouldPostHints
(
aDisplayContentsParentStyleChanged
)
mShouldComputeHints
(
aDisplayContentsParentStyleChanged
)
mComputedHint
(
nsChangeHint_Empty
)
{
}
nsStyleChangeList
&
ChangeList
(
)
{
return
mParentRestyleState
.
ChangeList
(
)
;
}
ComputedStyle
&
ComputeStyle
(
nsIContent
*
aTextNode
)
{
if
(
!
mStyle
)
{
mStyle
=
mParentRestyleState
.
StyleSet
(
)
.
ResolveStyleForText
(
aTextNode
&
ParentStyle
(
)
)
;
}
MOZ_ASSERT
(
mStyle
)
;
return
*
mStyle
;
}
void
ComputeHintIfNeeded
(
nsIContent
*
aContent
nsIFrame
*
aTextFrame
ComputedStyle
&
aNewStyle
)
{
MOZ_ASSERT
(
aTextFrame
)
;
MOZ_ASSERT
(
aNewStyle
.
GetPseudoType
(
)
=
=
PseudoStyleType
:
:
mozText
)
;
if
(
MOZ_LIKELY
(
!
mShouldPostHints
)
)
{
return
;
}
ComputedStyle
*
oldStyle
=
aTextFrame
-
>
Style
(
)
;
MOZ_ASSERT
(
oldStyle
-
>
GetPseudoType
(
)
=
=
PseudoStyleType
:
:
mozText
)
;
if
(
mShouldComputeHints
)
{
mShouldComputeHints
=
false
;
uint32_t
equalStructs
;
mComputedHint
=
oldStyle
-
>
CalcStyleDifference
(
aNewStyle
&
equalStructs
)
;
mComputedHint
=
NS_RemoveSubsumedHints
(
mComputedHint
mParentRestyleState
.
ChangesHandledFor
(
aTextFrame
)
)
;
}
if
(
mComputedHint
)
{
mParentRestyleState
.
ChangeList
(
)
.
AppendChange
(
aTextFrame
aContent
mComputedHint
)
;
}
}
private
:
ComputedStyle
&
ParentStyle
(
)
{
if
(
!
mParentContext
)
{
mLazilyResolvedParentContext
=
ServoStyleSet
:
:
ResolveServoStyle
(
mParentElement
)
;
mParentContext
=
mLazilyResolvedParentContext
;
}
return
*
mParentContext
;
}
Element
&
mParentElement
;
ComputedStyle
*
mParentContext
;
RefPtr
<
ComputedStyle
>
mLazilyResolvedParentContext
;
ServoRestyleState
&
mParentRestyleState
;
RefPtr
<
ComputedStyle
>
mStyle
;
bool
mShouldPostHints
;
bool
mShouldComputeHints
;
nsChangeHint
mComputedHint
;
}
;
static
void
UpdateBackdropIfNeeded
(
nsIFrame
*
aFrame
ServoStyleSet
&
aStyleSet
nsStyleChangeList
&
aChangeList
)
{
const
nsStyleDisplay
*
display
=
aFrame
-
>
Style
(
)
-
>
StyleDisplay
(
)
;
if
(
display
-
>
mTopLayer
!
=
StyleTopLayer
:
:
Top
)
{
return
;
}
MOZ_ASSERT
(
display
-
>
IsAbsolutelyPositionedStyle
(
)
)
;
nsIFrame
*
backdropPlaceholder
=
aFrame
-
>
GetChildList
(
nsIFrame
:
:
kBackdropList
)
.
FirstChild
(
)
;
if
(
!
backdropPlaceholder
)
{
return
;
}
MOZ_ASSERT
(
backdropPlaceholder
-
>
IsPlaceholderFrame
(
)
)
;
nsIFrame
*
backdropFrame
=
nsPlaceholderFrame
:
:
GetRealFrameForPlaceholder
(
backdropPlaceholder
)
;
MOZ_ASSERT
(
backdropFrame
-
>
IsBackdropFrame
(
)
)
;
MOZ_ASSERT
(
backdropFrame
-
>
Style
(
)
-
>
GetPseudoType
(
)
=
=
PseudoStyleType
:
:
backdrop
)
;
RefPtr
<
ComputedStyle
>
newStyle
=
aStyleSet
.
ResolvePseudoElementStyle
(
*
aFrame
-
>
GetContent
(
)
-
>
AsElement
(
)
PseudoStyleType
:
:
backdrop
aFrame
-
>
Style
(
)
)
;
MOZ_ASSERT
(
backdropFrame
-
>
GetParent
(
)
-
>
IsViewportFrame
(
)
|
|
backdropFrame
-
>
GetParent
(
)
-
>
IsCanvasFrame
(
)
)
;
nsTArray
<
nsIFrame
*
>
wrappersToRestyle
;
nsTArray
<
RefPtr
<
Element
>
>
anchorsToSuppress
;
ServoRestyleState
state
(
aStyleSet
aChangeList
wrappersToRestyle
anchorsToSuppress
)
;
nsIFrame
:
:
UpdateStyleOfOwnedChildFrame
(
backdropFrame
newStyle
state
)
;
MOZ_ASSERT
(
anchorsToSuppress
.
IsEmpty
(
)
)
;
}
static
void
UpdateFirstLetterIfNeeded
(
nsIFrame
*
aFrame
ServoRestyleState
&
aRestyleState
)
{
MOZ_ASSERT
(
!
aFrame
-
>
IsBlockFrameOrSubclass
(
)
"
You
'
re
probably
duplicating
work
with
UpdatePseudoElementStyles
!
"
)
;
if
(
!
aFrame
-
>
HasFirstLetterChild
(
)
)
{
return
;
}
nsIFrame
*
block
=
aFrame
-
>
GetParent
(
)
;
while
(
!
block
-
>
IsBlockFrameOrSubclass
(
)
)
{
block
=
block
-
>
GetParent
(
)
;
}
static_cast
<
nsBlockFrame
*
>
(
block
-
>
FirstContinuation
(
)
)
-
>
UpdateFirstLetterStyle
(
aRestyleState
)
;
}
static
void
UpdateOneAdditionalComputedStyle
(
nsIFrame
*
aFrame
uint32_t
aIndex
ComputedStyle
&
aOldContext
ServoRestyleState
&
aRestyleState
)
{
auto
pseudoType
=
aOldContext
.
GetPseudoType
(
)
;
MOZ_ASSERT
(
pseudoType
!
=
PseudoStyleType
:
:
NotPseudo
)
;
MOZ_ASSERT
(
!
nsCSSPseudoElements
:
:
PseudoElementSupportsUserActionState
(
pseudoType
)
)
;
RefPtr
<
ComputedStyle
>
newStyle
=
aRestyleState
.
StyleSet
(
)
.
ResolvePseudoElementStyle
(
*
aFrame
-
>
GetContent
(
)
-
>
AsElement
(
)
pseudoType
aFrame
-
>
Style
(
)
)
;
uint32_t
equalStructs
;
nsChangeHint
childHint
=
aOldContext
.
CalcStyleDifference
(
*
newStyle
&
equalStructs
)
;
if
(
!
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
&
&
!
aFrame
-
>
IsColumnSpanInMulticolSubtree
(
)
)
{
childHint
=
NS_RemoveSubsumedHints
(
childHint
aRestyleState
.
ChangesHandledFor
(
aFrame
)
)
;
}
if
(
childHint
)
{
if
(
childHint
&
nsChangeHint_ReconstructFrame
)
{
aRestyleState
.
ChangeList
(
)
.
PopChangesForContent
(
aFrame
-
>
GetContent
(
)
)
;
}
aRestyleState
.
ChangeList
(
)
.
AppendChange
(
aFrame
aFrame
-
>
GetContent
(
)
childHint
)
;
}
aFrame
-
>
SetAdditionalComputedStyle
(
aIndex
newStyle
)
;
}
static
void
UpdateAdditionalComputedStyles
(
nsIFrame
*
aFrame
ServoRestyleState
&
aRestyleState
)
{
MOZ_ASSERT
(
aFrame
)
;
MOZ_ASSERT
(
aFrame
-
>
GetContent
(
)
&
&
aFrame
-
>
GetContent
(
)
-
>
IsElement
(
)
)
;
uint32_t
index
=
0
;
while
(
auto
*
oldStyle
=
aFrame
-
>
GetAdditionalComputedStyle
(
index
)
)
{
UpdateOneAdditionalComputedStyle
(
aFrame
index
+
+
*
oldStyle
aRestyleState
)
;
}
}
static
void
UpdateFramePseudoElementStyles
(
nsIFrame
*
aFrame
ServoRestyleState
&
aRestyleState
)
{
if
(
nsBlockFrame
*
blockFrame
=
do_QueryFrame
(
aFrame
)
)
{
blockFrame
-
>
UpdatePseudoElementStyles
(
aRestyleState
)
;
}
else
{
UpdateFirstLetterIfNeeded
(
aFrame
aRestyleState
)
;
}
UpdateBackdropIfNeeded
(
aFrame
aRestyleState
.
StyleSet
(
)
aRestyleState
.
ChangeList
(
)
)
;
}
enum
class
ServoPostTraversalFlags
:
uint32_t
{
Empty
=
0
ParentWasRestyled
=
1
<
<
0
SkipA11yNotifications
=
1
<
<
1
SendA11yNotificationsIfShown
=
1
<
<
2
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
ServoPostTraversalFlags
)
static
ServoPostTraversalFlags
SendA11yNotifications
(
nsPresContext
*
aPresContext
Element
*
aElement
ComputedStyle
*
aOldComputedStyle
ComputedStyle
*
aNewComputedStyle
ServoPostTraversalFlags
aFlags
)
{
using
Flags
=
ServoPostTraversalFlags
;
MOZ_ASSERT
(
!
(
aFlags
&
Flags
:
:
SkipA11yNotifications
)
|
|
!
(
aFlags
&
Flags
:
:
SendA11yNotificationsIfShown
)
"
The
two
a11y
flags
should
never
be
set
together
"
)
;
#
ifdef
ACCESSIBILITY
nsAccessibilityService
*
accService
=
GetAccService
(
)
;
if
(
!
accService
)
{
return
Flags
:
:
Empty
;
}
if
(
aFlags
&
Flags
:
:
SkipA11yNotifications
)
{
return
Flags
:
:
SkipA11yNotifications
;
}
bool
needsNotify
=
false
;
bool
isVisible
=
aNewComputedStyle
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
;
if
(
aFlags
&
Flags
:
:
SendA11yNotificationsIfShown
)
{
if
(
!
isVisible
)
{
return
Flags
:
:
SendA11yNotificationsIfShown
;
}
needsNotify
=
true
;
}
else
{
bool
wasVisible
=
aOldComputedStyle
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
;
needsNotify
=
wasVisible
!
=
isVisible
;
}
if
(
needsNotify
)
{
PresShell
*
presShell
=
aPresContext
-
>
PresShell
(
)
;
if
(
isVisible
)
{
accService
-
>
ContentRangeInserted
(
presShell
aElement
aElement
-
>
GetNextSibling
(
)
)
;
return
Flags
:
:
SkipA11yNotifications
;
}
accService
-
>
ContentRemoved
(
presShell
aElement
)
;
return
Flags
:
:
SendA11yNotificationsIfShown
;
}
#
endif
return
Flags
:
:
Empty
;
}
bool
RestyleManager
:
:
ProcessPostTraversal
(
Element
*
aElement
ServoRestyleState
&
aRestyleState
ServoPostTraversalFlags
aFlags
)
{
nsIFrame
*
styleFrame
=
nsLayoutUtils
:
:
GetStyleFrame
(
aElement
)
;
nsIFrame
*
primaryFrame
=
aElement
-
>
GetPrimaryFrame
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aElement
-
>
HasServoData
(
)
"
Element
without
Servo
data
on
a
post
-
traversal
?
How
?
"
)
;
const
bool
isOutOfFlow
=
primaryFrame
&
&
primaryFrame
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
;
const
bool
isColumnSpan
=
primaryFrame
&
&
primaryFrame
-
>
IsColumnSpanInMulticolSubtree
(
)
;
bool
wasRestyled
;
nsChangeHint
changeHint
=
static_cast
<
nsChangeHint
>
(
Servo_TakeChangeHint
(
aElement
&
wasRestyled
)
)
;
RefPtr
<
ComputedStyle
>
upToDateStyleIfRestyled
=
wasRestyled
?
ServoStyleSet
:
:
ResolveServoStyle
(
*
aElement
)
:
nullptr
;
if
(
styleFrame
&
&
styleFrame
-
>
GetContent
(
)
!
=
aElement
)
{
MOZ_ASSERT
(
static_cast
<
nsImageFrame
*
>
(
do_QueryFrame
(
styleFrame
)
)
)
;
styleFrame
=
nullptr
;
}
if
(
aElement
-
>
HasFlag
(
NODE_NEEDS_FRAME
)
)
{
changeHint
|
=
nsChangeHint_ReconstructFrame
;
MOZ_ASSERT
(
!
styleFrame
)
;
}
if
(
styleFrame
)
{
MOZ_ASSERT
(
primaryFrame
)
;
nsIFrame
*
maybeAnonBoxChild
;
if
(
isOutOfFlow
)
{
maybeAnonBoxChild
=
primaryFrame
-
>
GetPlaceholderFrame
(
)
;
}
else
{
maybeAnonBoxChild
=
primaryFrame
;
if
(
!
isColumnSpan
)
{
changeHint
=
NS_RemoveSubsumedHints
(
changeHint
aRestyleState
.
ChangesHandledFor
(
styleFrame
)
)
;
}
}
if
(
(
aFlags
&
ServoPostTraversalFlags
:
:
ParentWasRestyled
)
&
&
maybeAnonBoxChild
-
>
ParentIsWrapperAnonBox
(
)
)
{
aRestyleState
.
AddPendingWrapperRestyle
(
ServoRestyleState
:
:
TableAwareParentFor
(
maybeAnonBoxChild
)
)
;
}
if
(
wasRestyled
&
&
styleFrame
-
>
StyleDisplay
(
)
-
>
IsListItem
(
)
&
&
styleFrame
-
>
IsBlockFrameOrSubclass
(
)
&
&
!
nsLayoutUtils
:
:
GetMarkerPseudo
(
aElement
)
)
{
RefPtr
<
ComputedStyle
>
pseudoStyle
=
aRestyleState
.
StyleSet
(
)
.
ProbePseudoElementStyle
(
*
aElement
PseudoStyleType
:
:
marker
upToDateStyleIfRestyled
)
;
if
(
pseudoStyle
)
{
changeHint
|
=
nsChangeHint_ReconstructFrame
;
}
}
}
if
(
(
styleFrame
|
|
(
changeHint
&
nsChangeHint_ReconstructFrame
)
)
&
&
changeHint
)
{
aRestyleState
.
ChangeList
(
)
.
AppendChange
(
styleFrame
aElement
changeHint
)
;
}
if
(
changeHint
&
nsChangeHint_ReconstructFrame
)
{
if
(
wasRestyled
&
&
StaticPrefs
:
:
layout_css_scroll_anchoring_suppressions_enabled
(
)
)
{
const
bool
wasAbsPos
=
styleFrame
&
&
styleFrame
-
>
StyleDisplay
(
)
-
>
IsAbsolutelyPositionedStyle
(
)
;
auto
*
newDisp
=
upToDateStyleIfRestyled
-
>
StyleDisplay
(
)
;
if
(
wasAbsPos
!
=
newDisp
-
>
IsAbsolutelyPositionedStyle
(
)
)
{
aRestyleState
.
AddPendingScrollAnchorSuppression
(
aElement
)
;
}
}
ClearRestyleStateFromSubtree
(
aElement
)
;
return
true
;
}
RefPtr
<
ComputedStyle
>
oldOrDisplayContentsStyle
=
styleFrame
?
styleFrame
-
>
Style
(
)
:
nullptr
;
MOZ_ASSERT
(
!
(
styleFrame
&
&
Servo_Element_IsDisplayContents
(
aElement
)
)
"
display
:
contents
node
has
a
frame
yet
we
didn
'
t
reframe
it
"
"
above
?
"
)
;
const
bool
isDisplayContents
=
!
styleFrame
&
&
aElement
-
>
HasServoData
(
)
&
&
Servo_Element_IsDisplayContents
(
aElement
)
;
if
(
isDisplayContents
)
{
oldOrDisplayContentsStyle
=
ServoStyleSet
:
:
ResolveServoStyle
(
*
aElement
)
;
}
Maybe
<
ServoRestyleState
>
thisFrameRestyleState
;
if
(
styleFrame
)
{
auto
type
=
isOutOfFlow
|
|
isColumnSpan
?
ServoRestyleState
:
:
Type
:
:
OutOfFlow
:
ServoRestyleState
:
:
Type
:
:
InFlow
;
thisFrameRestyleState
.
emplace
(
*
styleFrame
aRestyleState
changeHint
type
)
;
}
ServoRestyleState
&
childrenRestyleState
=
thisFrameRestyleState
?
*
thisFrameRestyleState
:
aRestyleState
;
ComputedStyle
*
upToDateStyle
=
wasRestyled
?
upToDateStyleIfRestyled
:
oldOrDisplayContentsStyle
;
ServoPostTraversalFlags
childrenFlags
=
wasRestyled
?
ServoPostTraversalFlags
:
:
ParentWasRestyled
:
ServoPostTraversalFlags
:
:
Empty
;
if
(
wasRestyled
&
&
oldOrDisplayContentsStyle
)
{
MOZ_ASSERT
(
styleFrame
|
|
isDisplayContents
)
;
for
(
nsIFrame
*
f
=
styleFrame
;
f
;
f
=
f
-
>
GetNextContinuation
(
)
)
{
MOZ_ASSERT_IF
(
f
!
=
styleFrame
!
f
-
>
GetAdditionalComputedStyle
(
0
)
)
;
f
-
>
SetComputedStyle
(
upToDateStyle
)
;
}
if
(
styleFrame
)
{
UpdateAdditionalComputedStyles
(
styleFrame
aRestyleState
)
;
}
if
(
!
aElement
-
>
GetParent
(
)
)
{
ViewportFrame
*
viewport
=
do_QueryFrame
(
mPresContext
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
)
;
if
(
viewport
)
{
viewport
-
>
UpdateStyle
(
aRestyleState
)
;
}
}
AddLayerChangesForAnimation
(
styleFrame
primaryFrame
aElement
changeHint
aRestyleState
.
ChangeList
(
)
)
;
childrenFlags
|
=
SendA11yNotifications
(
mPresContext
aElement
oldOrDisplayContentsStyle
upToDateStyle
aFlags
)
;
}
const
bool
traverseElementChildren
=
aElement
-
>
HasAnyOfFlags
(
Element
:
:
kAllServoDescendantBits
)
;
const
bool
traverseTextChildren
=
wasRestyled
|
|
aElement
-
>
HasFlag
(
NODE_DESCENDANTS_NEED_FRAMES
)
;
bool
recreatedAnyContext
=
wasRestyled
;
if
(
traverseElementChildren
|
|
traverseTextChildren
)
{
StyleChildrenIterator
it
(
aElement
)
;
TextPostTraversalState
textState
(
*
aElement
upToDateStyle
isDisplayContents
&
&
wasRestyled
childrenRestyleState
)
;
for
(
nsIContent
*
n
=
it
.
GetNextChild
(
)
;
n
;
n
=
it
.
GetNextChild
(
)
)
{
if
(
traverseElementChildren
&
&
n
-
>
IsElement
(
)
)
{
recreatedAnyContext
|
=
ProcessPostTraversal
(
n
-
>
AsElement
(
)
childrenRestyleState
childrenFlags
)
;
}
else
if
(
traverseTextChildren
&
&
n
-
>
IsText
(
)
)
{
recreatedAnyContext
|
=
ProcessPostTraversalForText
(
n
textState
childrenRestyleState
childrenFlags
)
;
}
}
}
if
(
styleFrame
)
{
if
(
wasRestyled
)
{
styleFrame
-
>
UpdateStyleOfOwnedAnonBoxes
(
childrenRestyleState
)
;
}
childrenRestyleState
.
ProcessWrapperRestyles
(
styleFrame
)
;
if
(
wasRestyled
)
{
UpdateFramePseudoElementStyles
(
styleFrame
childrenRestyleState
)
;
}
else
if
(
traverseElementChildren
&
&
styleFrame
-
>
IsBlockFrameOrSubclass
(
)
)
{
nsIFrame
*
firstLineFrame
=
static_cast
<
nsBlockFrame
*
>
(
styleFrame
)
-
>
GetFirstLineFrame
(
)
;
if
(
firstLineFrame
)
{
for
(
nsIFrame
*
kid
:
firstLineFrame
-
>
PrincipalChildList
(
)
)
{
ReparentComputedStyleForFirstLine
(
kid
)
;
}
}
}
}
aElement
-
>
UnsetFlags
(
Element
:
:
kAllServoDescendantBits
)
;
return
recreatedAnyContext
;
}
bool
RestyleManager
:
:
ProcessPostTraversalForText
(
nsIContent
*
aTextNode
TextPostTraversalState
&
aPostTraversalState
ServoRestyleState
&
aRestyleState
ServoPostTraversalFlags
aFlags
)
{
if
(
aTextNode
-
>
HasFlag
(
NODE_NEEDS_FRAME
)
)
{
aPostTraversalState
.
ChangeList
(
)
.
AppendChange
(
nullptr
aTextNode
nsChangeHint_ReconstructFrame
)
;
return
true
;
}
nsIFrame
*
primaryFrame
=
aTextNode
-
>
GetPrimaryFrame
(
)
;
if
(
!
primaryFrame
)
{
return
false
;
}
if
(
(
aFlags
&
ServoPostTraversalFlags
:
:
ParentWasRestyled
)
&
&
primaryFrame
-
>
ParentIsWrapperAnonBox
(
)
)
{
aRestyleState
.
AddPendingWrapperRestyle
(
ServoRestyleState
:
:
TableAwareParentFor
(
primaryFrame
)
)
;
}
ComputedStyle
&
newStyle
=
aPostTraversalState
.
ComputeStyle
(
aTextNode
)
;
aPostTraversalState
.
ComputeHintIfNeeded
(
aTextNode
primaryFrame
newStyle
)
;
for
(
nsIFrame
*
f
=
primaryFrame
;
f
;
f
=
f
-
>
GetNextContinuation
(
)
)
{
f
-
>
SetComputedStyle
(
&
newStyle
)
;
}
return
true
;
}
void
RestyleManager
:
:
ClearSnapshots
(
)
{
for
(
auto
iter
=
mSnapshots
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
iter
.
Key
(
)
-
>
UnsetFlags
(
ELEMENT_HAS_SNAPSHOT
|
ELEMENT_HANDLED_SNAPSHOT
)
;
iter
.
Remove
(
)
;
}
}
ServoElementSnapshot
&
RestyleManager
:
:
SnapshotFor
(
Element
&
aElement
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mInStyleRefresh
)
;
MOZ_ASSERT
(
aElement
.
HasServoData
(
)
)
;
MOZ_ASSERT
(
!
aElement
.
HasFlag
(
ELEMENT_HANDLED_SNAPSHOT
)
)
;
ServoElementSnapshot
*
snapshot
=
mSnapshots
.
GetOrInsertNew
(
&
aElement
aElement
)
;
aElement
.
SetFlags
(
ELEMENT_HAS_SNAPSHOT
)
;
aElement
.
NoteDirtyForServo
(
)
;
return
*
snapshot
;
}
void
RestyleManager
:
:
DoProcessPendingRestyles
(
ServoTraversalFlags
aFlags
)
{
nsPresContext
*
presContext
=
PresContext
(
)
;
PresShell
*
presShell
=
presContext
-
>
PresShell
(
)
;
MOZ_ASSERT
(
presContext
-
>
Document
(
)
"
No
document
?
Pshaw
!
"
)
;
MOZ_ASSERT
(
(
aFlags
&
ServoTraversalFlags
:
:
FlushThrottledAnimations
)
|
|
!
presContext
-
>
HasPendingMediaQueryUpdates
(
)
"
Someone
forgot
to
update
media
queries
?
"
)
;
MOZ_ASSERT
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
Missing
a
script
blocker
!
"
)
;
MOZ_RELEASE_ASSERT
(
!
mInStyleRefresh
"
Reentrant
call
?
"
)
;
if
(
MOZ_UNLIKELY
(
!
presShell
-
>
DidInitialize
(
)
)
)
{
return
;
}
PresShell
:
:
AutoAssertNoFlush
noReentrantFlush
(
*
presShell
)
;
AnimationsWithDestroyedFrame
animationsWithDestroyedFrame
(
this
)
;
ServoStyleSet
*
styleSet
=
StyleSet
(
)
;
Document
*
doc
=
presContext
-
>
Document
(
)
;
presContext
-
>
RefreshDriver
(
)
-
>
MostRecentRefresh
(
)
;
{
presContext
-
>
UpdateContainerQueryStyles
(
)
;
presContext
-
>
FinishedContainerQueryUpdate
(
)
;
}
mInStyleRefresh
=
true
;
if
(
mHaveNonAnimationRestyles
)
{
+
+
mAnimationGeneration
;
}
if
(
mRestyleForCSSRuleChanges
)
{
aFlags
|
=
ServoTraversalFlags
:
:
ForCSSRuleChanges
;
}
while
(
styleSet
-
>
StyleDocument
(
aFlags
)
)
{
ClearSnapshots
(
)
;
presContext
-
>
PresShell
(
)
-
>
FlushPendingScrollAnchorSelections
(
)
;
nsStyleChangeList
currentChanges
;
bool
anyStyleChanged
=
false
;
nsTArray
<
RefPtr
<
Element
>
>
anchorsToSuppress
;
{
AutoRestyleTimelineMarker
marker
(
presContext
-
>
GetDocShell
(
)
false
)
;
DocumentStyleRootIterator
iter
(
doc
-
>
GetServoRestyleRoot
(
)
)
;
while
(
Element
*
root
=
iter
.
GetNextStyleRoot
(
)
)
{
nsTArray
<
nsIFrame
*
>
wrappersToRestyle
;
ServoRestyleState
state
(
*
styleSet
currentChanges
wrappersToRestyle
anchorsToSuppress
)
;
ServoPostTraversalFlags
flags
=
ServoPostTraversalFlags
:
:
Empty
;
anyStyleChanged
|
=
ProcessPostTraversal
(
root
state
flags
)
;
}
for
(
Element
*
element
:
anchorsToSuppress
)
{
if
(
nsIFrame
*
frame
=
element
-
>
GetPrimaryFrame
(
)
)
{
if
(
auto
*
container
=
ScrollAnchorContainer
:
:
FindFor
(
frame
)
)
{
container
-
>
SuppressAdjustments
(
)
;
}
}
}
}
doc
-
>
ClearServoRestyleRoot
(
)
;
ClearSnapshots
(
)
;
{
AutoTimelineMarker
marker
(
presContext
-
>
GetDocShell
(
)
"
StylesApplyChanges
"
)
;
ReentrantChangeList
newChanges
;
mReentrantChanges
=
&
newChanges
;
while
(
!
currentChanges
.
IsEmpty
(
)
)
{
ProcessRestyledFrames
(
currentChanges
)
;
MOZ_ASSERT
(
currentChanges
.
IsEmpty
(
)
)
;
for
(
ReentrantChange
&
change
:
newChanges
)
{
if
(
!
(
change
.
mHint
&
nsChangeHint_ReconstructFrame
)
&
&
!
change
.
mContent
-
>
GetPrimaryFrame
(
)
)
{
continue
;
}
currentChanges
.
AppendChange
(
change
.
mContent
-
>
GetPrimaryFrame
(
)
change
.
mContent
change
.
mHint
)
;
}
newChanges
.
Clear
(
)
;
}
mReentrantChanges
=
nullptr
;
}
for
(
Element
*
element
:
anchorsToSuppress
)
{
if
(
nsIFrame
*
frame
=
element
-
>
GetPrimaryFrame
(
)
)
{
if
(
auto
*
container
=
ScrollAnchorContainer
:
:
FindFor
(
frame
)
)
{
container
-
>
SuppressAdjustments
(
)
;
}
}
}
if
(
anyStyleChanged
)
{
IncrementRestyleGeneration
(
)
;
}
mInStyleRefresh
=
false
;
presContext
-
>
UpdateContainerQueryStyles
(
)
;
mInStyleRefresh
=
true
;
}
doc
-
>
ClearServoRestyleRoot
(
)
;
presContext
-
>
FinishedContainerQueryUpdate
(
)
;
ClearSnapshots
(
)
;
styleSet
-
>
AssertTreeIsClean
(
)
;
mHaveNonAnimationRestyles
=
false
;
mRestyleForCSSRuleChanges
=
false
;
mInStyleRefresh
=
false
;
styleSet
-
>
MaybeGCRuleTree
(
)
;
MOZ_ASSERT
(
mAnimationsWithDestroyedFrame
)
;
mAnimationsWithDestroyedFrame
-
>
StopAnimationsForElementsWithoutFrames
(
)
;
}
#
ifdef
DEBUG
static
void
VerifyFlatTree
(
const
nsIContent
&
aContent
)
{
StyleChildrenIterator
iter
(
&
aContent
)
;
for
(
auto
*
content
=
iter
.
GetNextChild
(
)
;
content
;
content
=
iter
.
GetNextChild
(
)
)
{
MOZ_ASSERT
(
content
-
>
GetFlattenedTreeParentNodeForStyle
(
)
=
=
&
aContent
)
;
VerifyFlatTree
(
*
content
)
;
}
}
#
endif
void
RestyleManager
:
:
ProcessPendingRestyles
(
)
{
AUTO_PROFILER_LABEL_RELEVANT_FOR_JS
(
"
Styles
"
LAYOUT
)
;
#
ifdef
DEBUG
if
(
auto
*
root
=
mPresContext
-
>
Document
(
)
-
>
GetRootElement
(
)
)
{
VerifyFlatTree
(
*
root
)
;
}
#
endif
DoProcessPendingRestyles
(
ServoTraversalFlags
:
:
Empty
)
;
}
void
RestyleManager
:
:
ProcessAllPendingAttributeAndStateInvalidations
(
)
{
if
(
mSnapshots
.
IsEmpty
(
)
)
{
return
;
}
for
(
const
auto
&
key
:
mSnapshots
.
Keys
(
)
)
{
if
(
key
-
>
HasFlag
(
ELEMENT_HAS_SNAPSHOT
)
)
{
Servo_ProcessInvalidations
(
StyleSet
(
)
-
>
RawSet
(
)
key
&
mSnapshots
)
;
}
}
ClearSnapshots
(
)
;
}
void
RestyleManager
:
:
UpdateOnlyAnimationStyles
(
)
{
bool
doCSS
=
PresContext
(
)
-
>
EffectCompositor
(
)
-
>
HasPendingStyleUpdates
(
)
;
if
(
!
doCSS
)
{
return
;
}
DoProcessPendingRestyles
(
ServoTraversalFlags
:
:
FlushThrottledAnimations
)
;
}
void
RestyleManager
:
:
ElementStateChanged
(
Element
*
aElement
ElementState
aChangedBits
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mInStyleRefresh
)
;
const
ElementState
kVisitedAndUnvisited
=
ElementState
:
:
VISITED
|
ElementState
:
:
UNVISITED
;
if
(
aChangedBits
.
HasAllStates
(
kVisitedAndUnvisited
)
)
{
if
(
!
Gecko_VisitedStylesEnabled
(
aElement
-
>
OwnerDoc
(
)
)
|
|
StaticPrefs
:
:
layout_css_always_repaint_on_unvisited
(
)
)
{
aChangedBits
&
=
~
kVisitedAndUnvisited
;
if
(
aChangedBits
.
IsEmpty
(
)
)
{
return
;
}
}
}
if
(
auto
changeHint
=
ChangeForContentStateChange
(
*
aElement
aChangedBits
)
)
{
Servo_NoteExplicitHints
(
aElement
RestyleHint
{
0
}
changeHint
)
;
}
if
(
!
aChangedBits
.
HasAtLeastOneOfStates
(
ElementState
:
:
DIR_STATES
)
&
&
!
StyleSet
(
)
-
>
HasStateDependency
(
*
aElement
aChangedBits
)
)
{
return
;
}
IncrementUndisplayedRestyleGeneration
(
)
;
if
(
!
aElement
-
>
HasServoData
(
)
)
{
return
;
}
ServoElementSnapshot
&
snapshot
=
SnapshotFor
(
*
aElement
)
;
ElementState
previousState
=
aElement
-
>
StyleState
(
)
^
aChangedBits
;
snapshot
.
AddState
(
previousState
)
;
}
static
inline
bool
AttributeInfluencesOtherPseudoClassState
(
const
Element
&
aElement
const
nsAtom
*
aAttribute
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
mozbrowser
)
{
return
aElement
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
iframe
nsGkAtoms
:
:
frame
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
border
)
{
return
aElement
.
IsHTMLElement
(
nsGkAtoms
:
:
table
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
multiple
|
|
aAttribute
=
=
nsGkAtoms
:
:
size
)
{
return
aElement
.
IsHTMLElement
(
nsGkAtoms
:
:
select
)
;
}
return
false
;
}
static
inline
bool
NeedToRecordAttrChange
(
const
ServoStyleSet
&
aStyleSet
const
Element
&
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
bool
*
aInfluencesOtherPseudoClassState
)
{
*
aInfluencesOtherPseudoClassState
=
AttributeInfluencesOtherPseudoClassState
(
aElement
aAttribute
)
;
if
(
*
aInfluencesOtherPseudoClassState
)
{
return
true
;
}
if
(
aNameSpaceID
=
=
kNameSpaceID_None
&
&
(
aAttribute
=
=
nsGkAtoms
:
:
id
|
|
aAttribute
=
=
nsGkAtoms
:
:
_class
)
)
{
return
true
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
lang
)
{
return
true
;
}
return
aStyleSet
.
MightHaveAttributeDependency
(
aElement
aAttribute
)
;
}
void
RestyleManager
:
:
AttributeWillChange
(
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
TakeSnapshotForAttributeChange
(
*
aElement
aNameSpaceID
aAttribute
)
;
}
void
RestyleManager
:
:
ClassAttributeWillBeChangedBySMIL
(
Element
*
aElement
)
{
TakeSnapshotForAttributeChange
(
*
aElement
kNameSpaceID_None
nsGkAtoms
:
:
_class
)
;
}
void
RestyleManager
:
:
TakeSnapshotForAttributeChange
(
Element
&
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mInStyleRefresh
)
;
if
(
!
aElement
.
HasServoData
(
)
)
{
return
;
}
bool
influencesOtherPseudoClassState
;
if
(
!
NeedToRecordAttrChange
(
*
StyleSet
(
)
aElement
aNameSpaceID
aAttribute
&
influencesOtherPseudoClassState
)
)
{
return
;
}
IncrementUndisplayedRestyleGeneration
(
)
;
mHaveNonAnimationRestyles
=
true
;
ServoElementSnapshot
&
snapshot
=
SnapshotFor
(
aElement
)
;
snapshot
.
AddAttrs
(
aElement
aNameSpaceID
aAttribute
)
;
if
(
influencesOtherPseudoClassState
)
{
snapshot
.
AddOtherPseudoClassState
(
aElement
)
;
}
}
static
inline
bool
AttributeChangeRequiresSubtreeRestyle
(
const
Element
&
aElement
nsAtom
*
aAttr
)
{
if
(
aAttr
=
=
nsGkAtoms
:
:
cellpadding
)
{
return
aElement
.
IsHTMLElement
(
nsGkAtoms
:
:
table
)
;
}
if
(
aAttr
=
=
nsGkAtoms
:
:
exportparts
)
{
return
!
!
aElement
.
GetShadowRoot
(
)
;
}
return
aAttr
=
=
nsGkAtoms
:
:
lang
;
}
void
RestyleManager
:
:
AttributeChanged
(
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
const
nsAttrValue
*
aOldValue
)
{
MOZ_ASSERT
(
!
mInStyleRefresh
)
;
auto
changeHint
=
nsChangeHint
(
0
)
;
auto
restyleHint
=
RestyleHint
{
0
}
;
changeHint
|
=
aElement
-
>
GetAttributeChangeHint
(
aAttribute
aModType
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
style
)
{
restyleHint
|
=
RestyleHint
:
:
RESTYLE_STYLE_ATTRIBUTE
;
}
else
if
(
AttributeChangeRequiresSubtreeRestyle
(
*
aElement
aAttribute
)
)
{
restyleHint
|
=
RestyleHint
:
:
RestyleSubtree
(
)
;
}
else
if
(
aElement
-
>
IsAttributeMapped
(
aAttribute
)
)
{
restyleHint
|
=
RestyleHint
:
:
RESTYLE_SELF
;
}
else
if
(
aElement
-
>
IsInShadowTree
(
)
&
&
aAttribute
=
=
nsGkAtoms
:
:
part
)
{
restyleHint
|
=
RestyleHint
:
:
RESTYLE_SELF
;
}
if
(
nsIFrame
*
primaryFrame
=
aElement
-
>
GetPrimaryFrame
(
)
)
{
StyleAppearance
appearance
=
primaryFrame
-
>
StyleDisplay
(
)
-
>
EffectiveAppearance
(
)
;
if
(
appearance
!
=
StyleAppearance
:
:
None
)
{
nsITheme
*
theme
=
PresContext
(
)
-
>
Theme
(
)
;
if
(
theme
-
>
ThemeSupportsWidget
(
PresContext
(
)
primaryFrame
appearance
)
)
{
bool
repaint
=
false
;
theme
-
>
WidgetStateChanged
(
primaryFrame
appearance
aAttribute
&
repaint
aOldValue
)
;
if
(
repaint
)
{
changeHint
|
=
nsChangeHint_RepaintFrame
;
}
}
}
primaryFrame
-
>
AttributeChanged
(
aNameSpaceID
aAttribute
aModType
)
;
}
if
(
restyleHint
|
|
changeHint
)
{
Servo_NoteExplicitHints
(
aElement
restyleHint
changeHint
)
;
}
if
(
restyleHint
)
{
IncrementUndisplayedRestyleGeneration
(
)
;
mHaveNonAnimationRestyles
=
true
;
}
}
void
RestyleManager
:
:
ReparentComputedStyleForFirstLine
(
nsIFrame
*
aFrame
)
{
#
ifdef
DEBUG
{
nsIFrame
*
f
=
aFrame
-
>
GetParent
(
)
;
while
(
f
&
&
!
f
-
>
IsLineFrame
(
)
)
{
f
=
f
-
>
GetParent
(
)
;
}
MOZ_ASSERT
(
f
"
Must
have
found
a
first
-
line
frame
"
)
;
}
#
endif
DoReparentComputedStyleForFirstLine
(
aFrame
*
StyleSet
(
)
)
;
}
void
RestyleManager
:
:
DoReparentComputedStyleForFirstLine
(
nsIFrame
*
aFrame
ServoStyleSet
&
aStyleSet
)
{
if
(
aFrame
-
>
IsBackdropFrame
(
)
)
{
return
;
}
if
(
aFrame
-
>
IsPlaceholderFrame
(
)
)
{
nsIFrame
*
outOfFlow
=
nsPlaceholderFrame
:
:
GetRealFrameForPlaceholder
(
aFrame
)
;
MOZ_ASSERT
(
outOfFlow
"
no
out
-
of
-
flow
frame
"
)
;
for
(
;
outOfFlow
;
outOfFlow
=
outOfFlow
-
>
GetNextContinuation
(
)
)
{
DoReparentComputedStyleForFirstLine
(
outOfFlow
aStyleSet
)
;
}
}
nsIFrame
*
providerFrame
;
ComputedStyle
*
newParentStyle
=
aFrame
-
>
GetParentComputedStyle
(
&
providerFrame
)
;
bool
isChild
=
providerFrame
&
&
providerFrame
-
>
GetParent
(
)
=
=
aFrame
;
nsIFrame
*
providerChild
=
nullptr
;
if
(
isChild
)
{
DoReparentComputedStyleForFirstLine
(
providerFrame
aStyleSet
)
;
newParentStyle
=
providerFrame
-
>
Style
(
)
;
providerChild
=
providerFrame
;
MOZ_ASSERT
(
!
providerFrame
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
"
Out
of
flow
provider
?
"
)
;
}
if
(
!
newParentStyle
)
{
MOZ_ASSERT
(
aFrame
-
>
Style
(
)
-
>
IsNonInheritingAnonBox
(
)
"
Why
did
this
frame
not
end
up
with
a
parent
context
?
"
)
;
ReparentFrameDescendants
(
aFrame
providerChild
aStyleSet
)
;
return
;
}
bool
isElement
=
aFrame
-
>
GetContent
(
)
-
>
IsElement
(
)
;
ComputedStyle
*
oldStyle
=
aFrame
-
>
Style
(
)
;
Element
*
ourElement
=
oldStyle
-
>
GetPseudoType
(
)
=
=
PseudoStyleType
:
:
NotPseudo
&
&
isElement
?
aFrame
-
>
GetContent
(
)
-
>
AsElement
(
)
:
nullptr
;
ComputedStyle
*
newParent
=
newParentStyle
;
ComputedStyle
*
newParentIgnoringFirstLine
;
if
(
newParent
-
>
GetPseudoType
(
)
=
=
PseudoStyleType
:
:
firstLine
)
{
MOZ_ASSERT
(
providerFrame
&
&
providerFrame
-
>
GetParent
(
)
-
>
IsBlockFrameOrSubclass
(
)
"
How
could
we
get
a
:
:
first
-
line
parent
style
without
having
"
"
a
:
:
first
-
line
provider
frame
?
"
)
;
nsIFrame
*
blockFrame
=
providerFrame
-
>
GetParent
(
)
;
nsIFrame
*
correctedFrame
=
nsIFrame
:
:
CorrectStyleParentFrame
(
blockFrame
oldStyle
-
>
GetPseudoType
(
)
)
;
newParentIgnoringFirstLine
=
correctedFrame
-
>
Style
(
)
;
}
else
{
newParentIgnoringFirstLine
=
newParent
;
}
if
(
!
providerFrame
)
{
if
(
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
)
{
aFrame
-
>
FirstContinuation
(
)
-
>
GetPlaceholderFrame
(
)
-
>
GetLayoutParentStyleForOutOfFlow
(
&
providerFrame
)
;
}
else
{
providerFrame
=
nsIFrame
:
:
CorrectStyleParentFrame
(
aFrame
-
>
GetParent
(
)
oldStyle
-
>
GetPseudoType
(
)
)
;
}
}
ComputedStyle
*
layoutParent
=
providerFrame
-
>
Style
(
)
;
RefPtr
<
ComputedStyle
>
newStyle
=
aStyleSet
.
ReparentComputedStyle
(
oldStyle
newParent
newParentIgnoringFirstLine
layoutParent
ourElement
)
;
aFrame
-
>
SetComputedStyle
(
newStyle
)
;
if
(
isElement
)
{
uint32_t
index
=
0
;
while
(
auto
*
oldAdditionalStyle
=
aFrame
-
>
GetAdditionalComputedStyle
(
index
)
)
{
RefPtr
<
ComputedStyle
>
newAdditionalContext
=
aStyleSet
.
ReparentComputedStyle
(
oldAdditionalStyle
newStyle
newStyle
newStyle
nullptr
)
;
aFrame
-
>
SetAdditionalComputedStyle
(
index
newAdditionalContext
)
;
+
+
index
;
}
}
ReparentFrameDescendants
(
aFrame
providerChild
aStyleSet
)
;
}
void
RestyleManager
:
:
ReparentFrameDescendants
(
nsIFrame
*
aFrame
nsIFrame
*
aProviderChild
ServoStyleSet
&
aStyleSet
)
{
if
(
aFrame
-
>
GetContent
(
)
-
>
IsElement
(
)
&
&
!
aFrame
-
>
GetContent
(
)
-
>
AsElement
(
)
-
>
HasServoData
(
)
)
{
return
;
}
for
(
const
auto
&
childList
:
aFrame
-
>
ChildLists
(
)
)
{
for
(
nsIFrame
*
child
:
childList
.
mList
)
{
if
(
!
child
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
&
&
child
!
=
aProviderChild
)
{
DoReparentComputedStyleForFirstLine
(
child
aStyleSet
)
;
}
}
}
}
}
