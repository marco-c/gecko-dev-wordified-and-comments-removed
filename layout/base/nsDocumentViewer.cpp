#
include
"
gfxContext
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
mozilla
/
StaticPrefs_print
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nscore
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIDocumentViewer
.
h
"
#
include
"
nsIDocumentViewerPrint
.
h
"
#
include
"
nsIScreen
.
h
"
#
include
"
mozilla
/
dom
/
AutoSuppressEventHandlingAndSuspend
.
h
"
#
include
"
mozilla
/
dom
/
BrowsingContext
.
h
"
#
include
"
mozilla
/
dom
/
BeforeUnloadEvent
.
h
"
#
include
"
mozilla
/
dom
/
PopupBlocker
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
include
"
mozilla
/
dom
/
DocGroup
.
h
"
#
include
"
mozilla
/
widget
/
Screen
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIWritablePropertyBag2
.
h
"
#
include
"
nsSubDocumentFrame
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsStubMutationObserver
.
h
"
#
include
"
nsISelectionListener
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsContentUtils
.
h
"
#
ifdef
ACCESSIBILITY
#
include
"
mozilla
/
a11y
/
DocAccessible
.
h
"
#
endif
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
Encoding
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
SpinEventLoopUntil
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
StaticPrefs_javascript
.
h
"
#
include
"
mozilla
/
StaticPrefs_fission
.
h
"
#
include
"
mozilla
/
StaticPrefs_print
.
h
"
#
include
"
mozilla
/
StyleSheet
.
h
"
#
include
"
mozilla
/
StyleSheetInlines
.
h
"
#
include
"
mozilla
/
Try
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsView
.
h
"
#
include
"
nsPageSequenceFrame
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIDocumentViewerEdit
.
h
"
#
include
"
mozilla
/
css
/
Loader
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsIBaseWindow
.
h
"
#
include
"
nsILayoutHistoryState
.
h
"
#
include
"
nsCharsetSource
.
h
"
#
include
"
mozilla
/
ReflowInput
.
h
"
#
include
"
nsIImageLoadingContent
.
h
"
#
include
"
nsCopySupport
.
h
"
#
include
"
nsXULPopupManager
.
h
"
#
include
"
nsIClipboardHelper
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsGlobalWindowInner
.
h
"
#
include
"
nsGlobalWindowOuter
.
h
"
#
include
"
nsDOMNavigationTiming
.
h
"
#
include
"
nsPIWindowRoot
.
h
"
#
include
"
nsJSEnvironment
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsStyleSheetService
.
h
"
#
include
"
nsILoadContext
.
h
"
#
include
"
mozilla
/
ThrottledEventQueue
.
h
"
#
include
"
nsIPromptCollection
.
h
"
#
include
"
nsIPromptService
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
nsSandboxFlags
.
h
"
#
ifdef
NS_PRINTING
#
include
"
nsIWebBrowserPrint
.
h
"
#
include
"
nsPrintJob
.
h
"
#
include
"
nsDeviceContextSpecProxy
.
h
"
#
include
"
nsIPrintSettings
.
h
"
#
include
"
nsIPrintSettingsService
.
h
"
#
include
"
nsISimpleEnumerator
.
h
"
#
endif
#
include
"
nsIDOMEventListener
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
nsISHEntry
.
h
"
#
include
"
nsISHistory
.
h
"
#
include
"
nsIWebNavigation
.
h
"
#
include
"
mozilla
/
dom
/
XMLHttpRequestMainThread
.
h
"
#
include
<
stdio
.
h
>
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
dom
/
ScriptLoader
.
h
"
#
include
"
mozilla
/
dom
/
WindowGlobalChild
.
h
"
namespace
mozilla
{
namespace
dom
{
class
PrintPreviewResultInfo
;
}
}
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
mozilla
:
:
layout
:
:
RemotePrintJobChild
;
using
PrintPreviewResolver
=
std
:
:
function
<
void
(
const
mozilla
:
:
dom
:
:
PrintPreviewResultInfo
&
)
>
;
#
include
"
LayoutLogging
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
extern
mozilla
:
:
LazyLogModule
gPageCacheLog
;
#
ifdef
NS_PRINTING
mozilla
:
:
LazyLogModule
gPrintingLog
(
"
printing
"
)
;
#
define
PR_PL
(
_p1
)
MOZ_LOG
(
gPrintingLog
mozilla
:
:
LogLevel
:
:
Debug
_p1
)
;
#
endif
#
define
PRT_YESNO
(
_p
)
(
(
_p
)
?
"
YES
"
:
"
NO
"
)
class
nsDocumentViewer
;
class
nsDocViewerSelectionListener
final
:
public
nsISelectionListener
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSISELECTIONLISTENER
explicit
nsDocViewerSelectionListener
(
nsDocumentViewer
*
aDocViewer
)
:
mDocViewer
(
aDocViewer
)
mSelectionWasCollapsed
(
true
)
{
}
void
Disconnect
(
)
{
mDocViewer
=
nullptr
;
}
protected
:
virtual
~
nsDocViewerSelectionListener
(
)
=
default
;
nsDocumentViewer
*
mDocViewer
;
bool
mSelectionWasCollapsed
;
}
;
class
nsDocViewerFocusListener
final
:
public
nsIDOMEventListener
{
public
:
explicit
nsDocViewerFocusListener
(
nsDocumentViewer
*
aDocViewer
)
:
mDocViewer
(
aDocViewer
)
{
}
NS_DECL_ISUPPORTS
NS_DECL_NSIDOMEVENTLISTENER
void
Disconnect
(
)
{
mDocViewer
=
nullptr
;
}
protected
:
virtual
~
nsDocViewerFocusListener
(
)
=
default
;
nsDocumentViewer
*
mDocViewer
;
}
;
namespace
viewer_detail
{
class
BFCachePreventionObserver
final
:
public
nsStubMutationObserver
{
public
:
explicit
BFCachePreventionObserver
(
Document
*
aDocument
)
:
mDocument
(
aDocument
)
{
}
NS_DECL_ISUPPORTS
NS_DECL_NSIMUTATIONOBSERVER_CHARACTERDATACHANGED
NS_DECL_NSIMUTATIONOBSERVER_ATTRIBUTECHANGED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTAPPENDED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTINSERTED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTREMOVED
NS_DECL_NSIMUTATIONOBSERVER_NODEWILLBEDESTROYED
void
Disconnect
(
)
;
private
:
~
BFCachePreventionObserver
(
)
=
default
;
void
MutationHappened
(
)
;
Document
*
mDocument
;
}
;
NS_IMPL_ISUPPORTS
(
BFCachePreventionObserver
nsIMutationObserver
)
void
BFCachePreventionObserver
:
:
CharacterDataChanged
(
nsIContent
*
aContent
const
CharacterDataChangeInfo
&
)
{
if
(
aContent
-
>
IsInNativeAnonymousSubtree
(
)
)
{
return
;
}
MutationHappened
(
)
;
}
void
BFCachePreventionObserver
:
:
AttributeChanged
(
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
const
nsAttrValue
*
aOldValue
)
{
if
(
aElement
-
>
IsInNativeAnonymousSubtree
(
)
)
{
return
;
}
MutationHappened
(
)
;
}
void
BFCachePreventionObserver
:
:
ContentAppended
(
nsIContent
*
aFirstNewContent
)
{
if
(
aFirstNewContent
-
>
IsInNativeAnonymousSubtree
(
)
)
{
return
;
}
MutationHappened
(
)
;
}
void
BFCachePreventionObserver
:
:
ContentInserted
(
nsIContent
*
aChild
)
{
if
(
aChild
-
>
IsInNativeAnonymousSubtree
(
)
)
{
return
;
}
MutationHappened
(
)
;
}
void
BFCachePreventionObserver
:
:
ContentRemoved
(
nsIContent
*
aChild
nsIContent
*
aPreviousSibling
)
{
if
(
aChild
-
>
IsInNativeAnonymousSubtree
(
)
)
{
return
;
}
MutationHappened
(
)
;
}
void
BFCachePreventionObserver
:
:
NodeWillBeDestroyed
(
nsINode
*
aNode
)
{
mDocument
=
nullptr
;
}
void
BFCachePreventionObserver
:
:
Disconnect
(
)
{
if
(
mDocument
)
{
mDocument
-
>
RemoveMutationObserver
(
this
)
;
mDocument
=
nullptr
;
}
}
void
BFCachePreventionObserver
:
:
MutationHappened
(
)
{
MOZ_ASSERT
(
mDocument
"
How
can
we
not
have
a
document
but
be
getting
notified
for
mutations
?
"
)
;
mDocument
-
>
DisallowBFCaching
(
)
;
Disconnect
(
)
;
}
}
using
viewer_detail
:
:
BFCachePreventionObserver
;
class
nsDocumentViewer
final
:
public
nsIDocumentViewer
public
nsIDocumentViewerEdit
public
nsIDocumentViewerPrint
#
ifdef
NS_PRINTING
public
nsIWebBrowserPrint
#
endif
{
friend
class
nsDocViewerSelectionListener
;
friend
class
nsPagePrintTimer
;
friend
class
nsPrintJob
;
public
:
nsDocumentViewer
(
)
;
NS_DECL_ISUPPORTS
NS_DECL_NSIDOCUMENTVIEWER
NS_DECL_NSIDOCUMENTVIEWEREDIT
#
ifdef
NS_PRINTING
NS_DECL_NSIWEBBROWSERPRINT
#
endif
NS_DECL_NSIDOCUMENTVIEWERPRINT
protected
:
virtual
~
nsDocumentViewer
(
)
;
private
:
nsresult
MakeWindow
(
const
nsSize
&
aSize
nsView
*
aContainerView
)
;
nsresult
CreateDeviceContext
(
nsView
*
aContainerView
)
;
nsresult
InitInternal
(
nsIWidget
*
aParentWidget
nsISupports
*
aState
mozilla
:
:
dom
:
:
WindowGlobalChild
*
aActor
const
nsIntRect
&
aBounds
bool
aDoCreation
bool
aNeedMakeCX
=
true
bool
aForceSetNewDocument
=
true
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
InitPresentationStuff
(
bool
aDoInitialReflow
)
;
already_AddRefed
<
nsINode
>
GetPopupNode
(
)
;
already_AddRefed
<
nsINode
>
GetPopupLinkNode
(
)
;
already_AddRefed
<
nsIImageLoadingContent
>
GetPopupImageNode
(
)
;
void
PrepareToStartLoad
(
void
)
;
nsresult
SyncParentSubDocMap
(
)
;
void
RemoveFocusListener
(
)
;
void
ReinitializeFocusListener
(
)
;
mozilla
:
:
dom
:
:
Selection
*
GetDocumentSelection
(
)
;
void
DestroyPresShell
(
)
;
void
DestroyPresContext
(
)
;
void
InvalidatePotentialSubDocDisplayItem
(
)
;
bool
ShouldAttachToTopLevel
(
)
;
std
:
:
tuple
<
const
nsIFrame
*
int32_t
>
GetCurrentSheetFrameAndNumber
(
)
const
;
protected
:
nsViewManager
*
GetViewManager
(
)
;
void
DetachFromTopLevelWidget
(
)
;
WeakPtr
<
nsDocShell
>
mContainer
;
RefPtr
<
nsDeviceContext
>
mDeviceContext
;
nsCOMPtr
<
Document
>
mDocument
;
nsCOMPtr
<
nsIWidget
>
mWindow
;
RefPtr
<
nsViewManager
>
mViewManager
;
RefPtr
<
nsPresContext
>
mPresContext
;
RefPtr
<
PresShell
>
mPresShell
;
RefPtr
<
nsDocViewerSelectionListener
>
mSelectionListener
;
RefPtr
<
nsDocViewerFocusListener
>
mFocusListener
;
nsCOMPtr
<
nsIDocumentViewer
>
mPreviousViewer
;
nsCOMPtr
<
nsISHEntry
>
mSHEntry
;
RefPtr
<
BFCachePreventionObserver
>
mBFCachePreventionObserver
;
nsIWidget
*
mParentWidget
;
bool
mAttachedToParent
;
nsIntRect
mBounds
;
int16_t
mNumURLStarts
;
int16_t
mDestroyBlockedCount
;
unsigned
mStopped
:
1
;
unsigned
mLoaded
:
1
;
unsigned
mDeferredWindowClose
:
1
;
unsigned
mIsSticky
:
1
;
unsigned
mInPermitUnload
:
1
;
unsigned
mInPermitUnloadPrompt
:
1
;
#
ifdef
NS_PRINTING
unsigned
mClosingWhilePrinting
:
1
;
unsigned
mCloseWindowAfterPrint
:
1
;
#
if
NS_PRINT_PREVIEW
RefPtr
<
nsPrintJob
>
mPrintJob
;
#
endif
#
endif
int32_t
mReloadEncodingSource
;
const
Encoding
*
mReloadEncoding
;
bool
mIsPageMode
;
bool
mInitializedForPrintPreview
;
bool
mHidden
;
}
;
class
nsDocumentShownDispatcher
:
public
Runnable
{
public
:
explicit
nsDocumentShownDispatcher
(
nsCOMPtr
<
Document
>
aDocument
)
:
Runnable
(
"
nsDocumentShownDispatcher
"
)
mDocument
(
aDocument
)
{
}
NS_IMETHOD
Run
(
)
override
;
private
:
nsCOMPtr
<
Document
>
mDocument
;
}
;
already_AddRefed
<
nsIDocumentViewer
>
NS_NewDocumentViewer
(
)
{
RefPtr
<
nsDocumentViewer
>
viewer
=
new
nsDocumentViewer
(
)
;
return
viewer
.
forget
(
)
;
}
void
nsDocumentViewer
:
:
PrepareToStartLoad
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
GetIsPrintPreview
(
)
"
Print
preview
tab
should
never
navigate
"
)
;
mStopped
=
false
;
mLoaded
=
false
;
mAttachedToParent
=
false
;
mDeferredWindowClose
=
false
;
#
ifdef
NS_PRINTING
mClosingWhilePrinting
=
false
;
if
(
mPrintJob
)
{
mPrintJob
-
>
Destroy
(
)
;
mPrintJob
=
nullptr
;
}
#
endif
}
nsDocumentViewer
:
:
nsDocumentViewer
(
)
:
mParentWidget
(
nullptr
)
mAttachedToParent
(
false
)
mNumURLStarts
(
0
)
mDestroyBlockedCount
(
0
)
mStopped
(
false
)
mLoaded
(
false
)
mDeferredWindowClose
(
false
)
mIsSticky
(
true
)
mInPermitUnload
(
false
)
mInPermitUnloadPrompt
(
false
)
#
ifdef
NS_PRINTING
mClosingWhilePrinting
(
false
)
mCloseWindowAfterPrint
(
false
)
#
endif
mReloadEncodingSource
(
kCharsetUninitialized
)
mReloadEncoding
(
nullptr
)
mIsPageMode
(
false
)
mInitializedForPrintPreview
(
false
)
mHidden
(
false
)
{
PrepareToStartLoad
(
)
;
}
NS_IMPL_ADDREF
(
nsDocumentViewer
)
NS_IMPL_RELEASE
(
nsDocumentViewer
)
NS_INTERFACE_MAP_BEGIN
(
nsDocumentViewer
)
NS_INTERFACE_MAP_ENTRY
(
nsIDocumentViewer
)
NS_INTERFACE_MAP_ENTRY
(
nsIDocumentViewerEdit
)
NS_INTERFACE_MAP_ENTRY
(
nsIDocumentViewerPrint
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIDocumentViewer
)
#
ifdef
NS_PRINTING
NS_INTERFACE_MAP_ENTRY
(
nsIWebBrowserPrint
)
#
endif
NS_INTERFACE_MAP_END
nsDocumentViewer
:
:
~
nsDocumentViewer
(
)
{
if
(
mDocument
)
{
Close
(
nullptr
)
;
mDocument
-
>
Destroy
(
)
;
}
#
ifdef
NS_PRINTING
if
(
mPrintJob
)
{
mPrintJob
-
>
Destroy
(
)
;
mPrintJob
=
nullptr
;
}
#
endif
MOZ_RELEASE_ASSERT
(
mDestroyBlockedCount
=
=
0
)
;
NS_ASSERTION
(
!
mPresShell
&
&
!
mPresContext
"
User
did
not
call
nsIDocumentViewer
:
:
Destroy
"
)
;
if
(
mPresShell
|
|
mPresContext
)
{
mSHEntry
=
nullptr
;
Destroy
(
)
;
}
if
(
mSelectionListener
)
{
mSelectionListener
-
>
Disconnect
(
)
;
}
RemoveFocusListener
(
)
;
}
void
nsDocumentViewer
:
:
LoadStart
(
Document
*
aDocument
)
{
MOZ_ASSERT
(
aDocument
)
;
if
(
!
mDocument
)
{
mDocument
=
aDocument
;
}
}
void
nsDocumentViewer
:
:
RemoveFocusListener
(
)
{
if
(
RefPtr
<
nsDocViewerFocusListener
>
oldListener
=
std
:
:
move
(
mFocusListener
)
)
{
oldListener
-
>
Disconnect
(
)
;
if
(
mDocument
)
{
mDocument
-
>
RemoveEventListener
(
u
"
focus
"
_ns
oldListener
false
)
;
mDocument
-
>
RemoveEventListener
(
u
"
blur
"
_ns
oldListener
false
)
;
}
}
}
void
nsDocumentViewer
:
:
ReinitializeFocusListener
(
)
{
RemoveFocusListener
(
)
;
mFocusListener
=
new
nsDocViewerFocusListener
(
this
)
;
if
(
mDocument
)
{
mDocument
-
>
AddEventListener
(
u
"
focus
"
_ns
mFocusListener
false
false
)
;
mDocument
-
>
AddEventListener
(
u
"
blur
"
_ns
mFocusListener
false
false
)
;
}
}
nsresult
nsDocumentViewer
:
:
SyncParentSubDocMap
(
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
(
mContainer
)
;
if
(
!
docShell
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
pwin
(
docShell
-
>
GetWindow
(
)
)
;
if
(
!
mDocument
|
|
!
pwin
)
{
return
NS_OK
;
}
nsCOMPtr
<
Element
>
element
=
pwin
-
>
GetFrameElementInternal
(
)
;
if
(
!
element
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
parent
;
docShell
-
>
GetInProcessParent
(
getter_AddRefs
(
parent
)
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
parent_win
=
parent
?
parent
-
>
GetWindow
(
)
:
nullptr
;
if
(
!
parent_win
)
{
return
NS_OK
;
}
nsCOMPtr
<
Document
>
parent_doc
=
parent_win
-
>
GetDoc
(
)
;
if
(
!
parent_doc
)
{
return
NS_OK
;
}
if
(
mDocument
&
&
parent_doc
-
>
GetSubDocumentFor
(
element
)
!
=
mDocument
&
&
parent_doc
-
>
EventHandlingSuppressed
(
)
)
{
mDocument
-
>
SuppressEventHandling
(
parent_doc
-
>
EventHandlingSuppressed
(
)
)
;
}
return
parent_doc
-
>
SetSubDocumentFor
(
element
mDocument
)
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
SetContainer
(
nsIDocShell
*
aContainer
)
{
mContainer
=
static_cast
<
nsDocShell
*
>
(
aContainer
)
;
return
SyncParentSubDocMap
(
)
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetContainer
(
nsIDocShell
*
*
aResult
)
{
NS_ENSURE_ARG_POINTER
(
aResult
)
;
nsCOMPtr
<
nsIDocShell
>
container
(
mContainer
)
;
container
.
swap
(
*
aResult
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
Init
(
nsIWidget
*
aParentWidget
const
nsIntRect
&
aBounds
WindowGlobalChild
*
aActor
)
{
return
InitInternal
(
aParentWidget
nullptr
aActor
aBounds
true
)
;
}
nsresult
nsDocumentViewer
:
:
InitPresentationStuff
(
bool
aDoInitialReflow
)
{
MOZ_ASSERT
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
InitPresentationStuff
must
only
be
called
when
scripts
are
"
"
blocked
"
)
;
#
ifdef
NS_PRINTING
if
(
mPrintJob
)
{
return
NS_OK
;
}
#
endif
NS_ASSERTION
(
!
mPresShell
"
Someone
should
have
destroyed
the
presshell
!
"
)
;
nsCOMPtr
<
Document
>
doc
=
mDocument
;
RefPtr
<
nsPresContext
>
presContext
=
mPresContext
;
RefPtr
<
nsViewManager
>
viewManager
=
mViewManager
;
mPresShell
=
doc
-
>
CreatePresShell
(
presContext
viewManager
)
;
if
(
!
mPresShell
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aDoInitialReflow
)
{
mDocument
-
>
FlushPendingNotifications
(
FlushType
:
:
ContentAndNotify
)
;
}
mPresShell
-
>
BeginObservingDocument
(
)
;
{
int32_t
p2a
=
mPresContext
-
>
AppUnitsPerDevPixel
(
)
;
MOZ_ASSERT
(
p2a
=
=
mPresContext
-
>
DeviceContext
(
)
-
>
AppUnitsPerDevPixelAtUnitFullZoom
(
)
)
;
nscoord
width
=
p2a
*
mBounds
.
width
;
nscoord
height
=
p2a
*
mBounds
.
height
;
mViewManager
-
>
SetWindowDimensions
(
width
height
)
;
mPresContext
-
>
SetVisibleArea
(
nsRect
(
0
0
width
height
)
)
;
mPresContext
-
>
RecomputeBrowsingContextDependentData
(
)
;
}
if
(
mWindow
&
&
mDocument
-
>
IsTopLevelContentDocument
(
)
)
{
ScreenIntMargin
windowSafeAreaInsets
;
LayoutDeviceIntRect
windowRect
=
mWindow
-
>
GetScreenBounds
(
)
;
nsCOMPtr
<
nsIScreen
>
screen
=
mWindow
-
>
GetWidgetScreen
(
)
;
if
(
screen
)
{
windowSafeAreaInsets
=
nsContentUtils
:
:
GetWindowSafeAreaInsets
(
screen
mWindow
-
>
GetSafeAreaInsets
(
)
windowRect
)
;
}
mPresContext
-
>
SetSafeAreaInsets
(
windowSafeAreaInsets
)
;
}
if
(
aDoInitialReflow
)
{
RefPtr
<
PresShell
>
presShell
=
mPresShell
;
presShell
-
>
Initialize
(
)
;
}
if
(
!
mSelectionListener
)
{
mSelectionListener
=
new
nsDocViewerSelectionListener
(
this
)
;
}
RefPtr
<
mozilla
:
:
dom
:
:
Selection
>
selection
=
GetDocumentSelection
(
)
;
if
(
!
selection
)
{
return
NS_ERROR_FAILURE
;
}
selection
-
>
AddSelectionListener
(
mSelectionListener
)
;
ReinitializeFocusListener
(
)
;
if
(
aDoInitialReflow
&
&
mDocument
)
{
nsCOMPtr
<
Document
>
document
=
mDocument
;
document
-
>
ScrollToRef
(
)
;
}
return
NS_OK
;
}
static
nsPresContext
*
CreatePresContext
(
Document
*
aDocument
nsPresContext
:
:
nsPresContextType
aType
nsView
*
aContainerView
)
{
if
(
aContainerView
)
{
return
new
nsPresContext
(
aDocument
aType
)
;
}
return
new
nsRootPresContext
(
aDocument
aType
)
;
}
nsresult
nsDocumentViewer
:
:
InitInternal
(
nsIWidget
*
aParentWidget
nsISupports
*
aState
WindowGlobalChild
*
aActor
const
nsIntRect
&
aBounds
bool
aDoCreation
bool
aNeedMakeCX
bool
aForceSetNewDocument
)
{
nsAutoScriptBlocker
blockScripts
;
mParentWidget
=
aParentWidget
;
mBounds
=
aBounds
;
nsresult
rv
=
NS_OK
;
NS_ENSURE_TRUE
(
mDocument
NS_ERROR_NULL_POINTER
)
;
nsView
*
containerView
=
FindContainerView
(
)
;
bool
makeCX
=
false
;
if
(
aDoCreation
)
{
nsresult
rv
=
CreateDeviceContext
(
containerView
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
mPresContext
&
&
(
aParentWidget
|
|
containerView
|
|
mDocument
-
>
IsBeingUsedAsImage
(
)
|
|
(
mDocument
-
>
GetDisplayDocument
(
)
&
&
mDocument
-
>
GetDisplayDocument
(
)
-
>
GetPresShell
(
)
)
)
)
{
if
(
mIsPageMode
)
{
}
else
{
mPresContext
=
CreatePresContext
(
mDocument
nsPresContext
:
:
eContext_Galley
containerView
)
;
}
NS_ENSURE_TRUE
(
mPresContext
NS_ERROR_OUT_OF_MEMORY
)
;
nsresult
rv
=
mPresContext
-
>
Init
(
mDeviceContext
)
;
if
(
NS_FAILED
(
rv
)
)
{
mPresContext
=
nullptr
;
return
rv
;
}
#
if
defined
(
NS_PRINTING
)
&
&
defined
(
NS_PRINT_PREVIEW
)
makeCX
=
!
GetIsPrintPreview
(
)
&
&
aNeedMakeCX
;
#
else
makeCX
=
true
;
#
endif
}
if
(
mPresContext
)
{
rv
=
MakeWindow
(
nsSize
(
mPresContext
-
>
DevPixelsToAppUnits
(
aBounds
.
width
)
mPresContext
-
>
DevPixelsToAppUnits
(
aBounds
.
height
)
)
containerView
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
Hide
(
)
;
#
ifdef
NS_PRINT_PREVIEW
if
(
mIsPageMode
)
{
double
pageWidth
=
0
pageHeight
=
0
;
mPresContext
-
>
GetPrintSettings
(
)
-
>
GetEffectivePageSize
(
&
pageWidth
&
pageHeight
)
;
mPresContext
-
>
SetPageSize
(
nsSize
(
mPresContext
-
>
CSSTwipsToAppUnits
(
NSToIntFloor
(
pageWidth
)
)
mPresContext
-
>
CSSTwipsToAppUnits
(
NSToIntFloor
(
pageHeight
)
)
)
)
;
mPresContext
-
>
SetIsRootPaginatedDocument
(
true
)
;
mPresContext
-
>
SetPageScale
(
1
.
0f
)
;
}
#
endif
}
else
{
if
(
mPreviousViewer
)
{
mPreviousViewer
-
>
Destroy
(
)
;
mPreviousViewer
=
nullptr
;
}
}
}
nsCOMPtr
<
nsIInterfaceRequestor
>
requestor
(
mContainer
)
;
if
(
requestor
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
do_GetInterface
(
requestor
)
;
if
(
window
)
{
nsCOMPtr
<
Document
>
curDoc
=
window
-
>
GetExtantDoc
(
)
;
if
(
aForceSetNewDocument
|
|
curDoc
!
=
mDocument
)
{
rv
=
window
-
>
SetNewDocument
(
mDocument
aState
false
aActor
)
;
if
(
NS_FAILED
(
rv
)
)
{
Destroy
(
)
;
return
rv
;
}
}
}
}
if
(
aDoCreation
&
&
mPresContext
)
{
rv
=
InitPresentationStuff
(
!
makeCX
)
;
}
return
rv
;
}
void
nsDocumentViewer
:
:
SetNavigationTiming
(
nsDOMNavigationTiming
*
timing
)
{
NS_ASSERTION
(
mDocument
"
Must
have
a
document
to
set
navigation
timing
.
"
)
;
if
(
mDocument
)
{
mDocument
-
>
SetNavigationTiming
(
timing
)
;
}
}
NS_IMETHODIMP
nsDocumentViewer
:
:
LoadComplete
(
nsresult
aStatus
)
{
RefPtr
<
nsDocumentViewer
>
kungFuDeathGrip
(
this
)
;
if
(
mPresShell
&
&
!
mStopped
)
{
RefPtr
<
PresShell
>
presShell
=
mPresShell
;
presShell
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
}
nsresult
rv
=
NS_OK
;
NS_ENSURE_TRUE
(
mDocument
NS_ERROR_NOT_AVAILABLE
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
mDocument
-
>
GetWindow
(
)
;
mLoaded
=
true
;
bool
restoring
=
false
;
if
(
window
&
&
(
NS_SUCCEEDED
(
aStatus
)
|
|
aStatus
=
=
NS_ERROR_PARSED_DATA_CACHED
)
)
{
nsEventStatus
status
=
nsEventStatus_eIgnore
;
WidgetEvent
event
(
true
eLoad
)
;
event
.
mFlags
.
mBubbles
=
false
;
event
.
mFlags
.
mCancelable
=
false
;
event
.
mTarget
=
mDocument
;
RefPtr
<
nsDocShell
>
docShell
=
nsDocShell
:
:
Cast
(
window
-
>
GetDocShell
(
)
)
;
NS_ENSURE_TRUE
(
docShell
NS_ERROR_UNEXPECTED
)
;
restoring
=
(
mDocument
-
>
GetReadyStateEnum
(
)
=
=
Document
:
:
READYSTATE_COMPLETE
)
;
if
(
!
restoring
)
{
NS_ASSERTION
(
mDocument
-
>
GetReadyStateEnum
(
)
=
=
Document
:
:
READYSTATE_INTERACTIVE
|
|
(
mDocument
-
>
GetReadyStateEnum
(
)
=
=
Document
:
:
READYSTATE_UNINITIALIZED
&
&
NS_IsAboutBlank
(
mDocument
-
>
GetDocumentURI
(
)
)
)
"
Bad
readystate
"
)
;
#
ifdef
DEBUG
bool
docShellThinksWeAreRestoring
;
docShell
-
>
GetRestoringDocument
(
&
docShellThinksWeAreRestoring
)
;
MOZ_ASSERT
(
!
docShellThinksWeAreRestoring
"
How
can
docshell
think
we
are
restoring
if
we
don
'
t
have
a
"
"
READYSTATE_COMPLETE
document
?
"
)
;
#
endif
nsCOMPtr
<
Document
>
d
=
mDocument
;
mDocument
-
>
SetReadyStateInternal
(
Document
:
:
READYSTATE_COMPLETE
)
;
RefPtr
<
nsDOMNavigationTiming
>
timing
(
d
-
>
GetNavigationTiming
(
)
)
;
if
(
timing
)
{
timing
-
>
NotifyLoadEventStart
(
)
;
}
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
nsIPrincipal
*
principal
=
d
-
>
NodePrincipal
(
)
;
os
-
>
NotifyObservers
(
ToSupports
(
d
)
principal
-
>
IsSystemPrincipal
(
)
?
"
chrome
-
document
-
loaded
"
:
"
content
-
document
-
loaded
"
nullptr
)
;
}
nsPIDOMWindowInner
*
innerWindow
=
window
-
>
GetCurrentInnerWindow
(
)
;
d
-
>
SetLoadEventFiring
(
true
)
;
RefPtr
<
nsPresContext
>
presContext
=
mPresContext
;
EventDispatcher
:
:
Dispatch
(
MOZ_KnownLive
(
nsGlobalWindowOuter
:
:
Cast
(
window
)
)
presContext
&
event
nullptr
&
status
)
;
d
-
>
SetLoadEventFiring
(
false
)
;
if
(
timing
)
{
timing
-
>
NotifyLoadEventEnd
(
)
;
}
if
(
innerWindow
)
{
innerWindow
-
>
QueuePerformanceNavigationTiming
(
)
;
}
}
}
else
{
if
(
aStatus
=
=
NS_BINDING_ABORTED
&
&
mDocument
)
{
mDocument
-
>
NotifyAbortedLoad
(
)
;
}
}
if
(
mDocument
&
&
mDocument
-
>
IsCurrentActiveDocument
(
)
&
&
aStatus
!
=
NS_BINDING_ABORTED
)
{
window
=
mDocument
-
>
GetWindow
(
)
;
if
(
window
)
{
nsIDocShell
*
docShell
=
window
-
>
GetDocShell
(
)
;
bool
isInUnload
;
if
(
docShell
&
&
NS_SUCCEEDED
(
docShell
-
>
GetIsInUnload
(
&
isInUnload
)
)
&
&
!
isInUnload
)
{
mDocument
-
>
OnPageShow
(
restoring
nullptr
)
;
}
}
}
if
(
!
mStopped
)
{
if
(
mDocument
)
{
nsCOMPtr
<
Document
>
document
=
mDocument
;
document
-
>
ScrollToRef
(
)
;
}
if
(
mPresShell
)
{
RefPtr
<
PresShell
>
presShell
=
mPresShell
;
presShell
-
>
UnsuppressPainting
(
)
;
if
(
mPresShell
)
{
mPresShell
-
>
LoadComplete
(
)
;
}
}
}
if
(
mDocument
&
&
!
restoring
)
{
mDocument
-
>
LoadEventFired
(
)
;
}
nsJSContext
:
:
PokeGC
(
JS
:
:
GCReason
:
:
LOAD_END
mDocument
?
mDocument
-
>
GetWrapperPreserveColor
(
)
:
nullptr
)
;
#
ifdef
NS_PRINTING
if
(
window
)
{
auto
*
outerWin
=
nsGlobalWindowOuter
:
:
Cast
(
window
)
;
outerWin
-
>
StopDelayingPrintingUntilAfterLoad
(
)
;
if
(
outerWin
-
>
DelayedPrintUntilAfterLoad
(
)
)
{
if
(
RefPtr
inner
=
nsGlobalWindowInner
:
:
Cast
(
window
-
>
GetCurrentInnerWindow
(
)
)
)
{
inner
-
>
Print
(
IgnoreErrors
(
)
)
;
}
if
(
outerWin
-
>
DelayedCloseForPrinting
(
)
)
{
outerWin
-
>
Close
(
)
;
}
}
else
{
MOZ_ASSERT
(
!
outerWin
-
>
DelayedCloseForPrinting
(
)
)
;
}
}
#
endif
return
rv
;
}
bool
nsDocumentViewer
:
:
GetLoadCompleted
(
)
{
return
mLoaded
;
}
bool
nsDocumentViewer
:
:
GetIsStopped
(
)
{
return
mStopped
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
PermitUnload
(
PermitUnloadAction
aAction
bool
*
aPermitUnload
)
{
RefPtr
<
nsDocumentViewer
>
kungFuDeathGrip
(
this
)
;
if
(
StaticPrefs
:
:
dom_disable_beforeunload
(
)
)
{
aAction
=
eDontPromptAndUnload
;
}
*
aPermitUnload
=
true
;
NS_ENSURE_STATE
(
mContainer
)
;
RefPtr
<
BrowsingContext
>
bc
=
mContainer
-
>
GetBrowsingContext
(
)
;
if
(
!
bc
)
{
return
NS_OK
;
}
IgnoreOpensDuringUnload
ignoreOpens
(
mDocument
)
;
bool
foundBlocker
=
false
;
bool
foundOOPListener
=
false
;
bc
-
>
PreOrderWalk
(
[
&
]
(
BrowsingContext
*
aBC
)
{
if
(
!
aBC
-
>
IsInProcess
(
)
)
{
WindowContext
*
wc
=
aBC
-
>
GetCurrentWindowContext
(
)
;
if
(
wc
&
&
wc
-
>
HasBeforeUnload
(
)
)
{
foundOOPListener
=
true
;
}
}
else
if
(
aBC
-
>
GetDocShell
(
)
)
{
nsCOMPtr
<
nsIDocumentViewer
>
viewer
(
aBC
-
>
GetDocShell
(
)
-
>
GetDocViewer
(
)
)
;
if
(
viewer
&
&
viewer
-
>
DispatchBeforeUnload
(
)
=
=
eRequestBlockNavigation
)
{
foundBlocker
=
true
;
}
}
}
)
;
if
(
!
foundOOPListener
)
{
if
(
!
foundBlocker
)
{
return
NS_OK
;
}
if
(
aAction
!
=
ePrompt
)
{
*
aPermitUnload
=
aAction
=
=
eDontPromptAndUnload
;
return
NS_OK
;
}
}
RefPtr
<
WindowGlobalChild
>
wgc
(
mDocument
?
mDocument
-
>
GetWindowGlobalChild
(
)
:
nullptr
)
;
if
(
!
wgc
)
{
return
NS_OK
;
}
nsAutoSyncOperation
sync
(
mDocument
SyncOperationBehavior
:
:
eSuspendInput
)
;
AutoSuppressEventHandlingAndSuspend
seh
(
bc
-
>
Group
(
)
)
;
mInPermitUnloadPrompt
=
true
;
bool
done
=
false
;
wgc
-
>
SendCheckPermitUnload
(
foundBlocker
aAction
[
&
]
(
bool
aPermit
)
{
done
=
true
;
*
aPermitUnload
=
aPermit
;
}
[
&
]
(
auto
)
{
done
=
true
;
*
aPermitUnload
=
false
;
}
)
;
SpinEventLoopUntil
(
"
nsDocumentViewer
:
:
PermitUnload
"
_ns
[
&
]
(
)
{
return
done
;
}
)
;
mInPermitUnloadPrompt
=
false
;
return
NS_OK
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
PermitUnloadResult
nsDocumentViewer
:
:
DispatchBeforeUnload
(
)
{
AutoDontWarnAboutSyncXHR
disableSyncXHRWarning
;
if
(
!
mDocument
|
|
mInPermitUnload
|
|
mInPermitUnloadPrompt
|
|
!
mContainer
)
{
return
eAllowNavigation
;
}
RefPtr
<
nsGlobalWindowOuter
>
window
=
nsGlobalWindowOuter
:
:
Cast
(
mDocument
-
>
GetWindow
(
)
)
;
if
(
!
window
)
{
NS_WARNING
(
"
window
not
set
for
document
!
"
)
;
return
eAllowNavigation
;
}
NS_ASSERTION
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
This
is
unsafe
"
)
;
IgnoreOpensDuringUnload
ignoreOpens
(
mDocument
)
;
nsPresContext
*
presContext
=
mDocument
-
>
GetPresContext
(
)
;
RefPtr
<
BeforeUnloadEvent
>
event
=
new
BeforeUnloadEvent
(
mDocument
presContext
nullptr
)
;
event
-
>
InitEvent
(
u
"
beforeunload
"
_ns
false
true
)
;
event
-
>
SetTarget
(
mDocument
)
;
event
-
>
SetTrusted
(
true
)
;
RefPtr
<
nsDocumentViewer
>
kungFuDeathGrip
(
this
)
;
{
AutoPopupStatePusher
popupStatePusher
(
PopupBlocker
:
:
openAbused
true
)
;
RefPtr
<
BrowsingContext
>
bc
=
mContainer
-
>
GetBrowsingContext
(
)
;
NS_ASSERTION
(
bc
"
should
have
a
browsing
context
in
document
viewer
"
)
;
nsGlobalWindowOuter
:
:
TemporarilyDisableDialogs
disableDialogs
(
bc
)
;
Document
:
:
PageUnloadingEventTimeStamp
timestamp
(
mDocument
)
;
mInPermitUnload
=
true
;
RefPtr
<
nsPresContext
>
presContext
=
mPresContext
;
EventDispatcher
:
:
DispatchDOMEvent
(
window
nullptr
event
presContext
nullptr
)
;
mInPermitUnload
=
false
;
}
nsAutoString
text
;
event
-
>
GetReturnValue
(
text
)
;
if
(
window
-
>
AreDialogsEnabled
(
)
&
&
mDocument
&
&
!
(
mDocument
-
>
GetSandboxFlags
(
)
&
SANDBOXED_MODALS
)
&
&
(
!
StaticPrefs
:
:
dom_require_user_interaction_for_beforeunload
(
)
|
|
mDocument
-
>
UserHasInteracted
(
)
)
&
&
(
event
-
>
WidgetEventPtr
(
)
-
>
DefaultPrevented
(
)
|
|
!
text
.
IsEmpty
(
)
)
)
{
return
eRequestBlockNavigation
;
}
return
eAllowNavigation
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetBeforeUnloadFiring
(
bool
*
aInEvent
)
{
*
aInEvent
=
mInPermitUnload
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetInPermitUnload
(
bool
*
aInEvent
)
{
*
aInEvent
=
mInPermitUnloadPrompt
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
PageHide
(
bool
aIsUnload
)
{
AutoDontWarnAboutSyncXHR
disableSyncXHRWarning
;
mHidden
=
true
;
if
(
!
mDocument
)
{
return
NS_ERROR_NULL_POINTER
;
}
if
(
aIsUnload
)
{
nsJSContext
:
:
PokeGC
(
JS
:
:
GCReason
:
:
PAGE_HIDE
mDocument
-
>
GetWrapperPreserveColor
(
)
TimeDuration
:
:
FromMilliseconds
(
StaticPrefs
:
:
javascript_options_gc_delay
(
)
*
2
)
)
;
}
mDocument
-
>
OnPageHide
(
!
aIsUnload
nullptr
)
;
NS_ENSURE_STATE
(
mDocument
)
;
nsPIDOMWindowOuter
*
window
=
mDocument
-
>
GetWindow
(
)
;
if
(
window
)
window
-
>
PageHidden
(
)
;
if
(
aIsUnload
)
{
NS_ENSURE_STATE
(
mDocument
)
;
RefPtr
<
nsPIDOMWindowOuter
>
window
=
mDocument
-
>
GetWindow
(
)
;
if
(
!
window
)
{
NS_WARNING
(
"
window
not
set
for
document
!
"
)
;
return
NS_ERROR_NULL_POINTER
;
}
IgnoreOpensDuringUnload
ignoreOpens
(
mDocument
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
WidgetEvent
event
(
true
eUnload
)
;
event
.
mFlags
.
mBubbles
=
false
;
event
.
mTarget
=
mDocument
;
AutoPopupStatePusher
popupStatePusher
(
PopupBlocker
:
:
openAbused
true
)
;
Document
:
:
PageUnloadingEventTimeStamp
timestamp
(
mDocument
)
;
RefPtr
<
nsPresContext
>
presContext
=
mPresContext
;
EventDispatcher
:
:
Dispatch
(
MOZ_KnownLive
(
nsGlobalWindowOuter
:
:
Cast
(
window
)
)
presContext
&
event
nullptr
&
status
)
;
}
nsContentUtils
:
:
HidePopupsInDocument
(
mDocument
)
;
return
NS_OK
;
}
static
void
AttachContainerRecurse
(
nsIDocShell
*
aShell
)
{
nsCOMPtr
<
nsIDocumentViewer
>
viewer
;
aShell
-
>
GetDocViewer
(
getter_AddRefs
(
viewer
)
)
;
if
(
viewer
)
{
viewer
-
>
SetIsHidden
(
false
)
;
Document
*
doc
=
viewer
-
>
GetDocument
(
)
;
if
(
doc
)
{
doc
-
>
SetContainer
(
static_cast
<
nsDocShell
*
>
(
aShell
)
)
;
}
if
(
PresShell
*
presShell
=
viewer
-
>
GetPresShell
(
)
)
{
presShell
-
>
SetForwardingContainer
(
WeakPtr
<
nsDocShell
>
(
)
)
;
}
}
int32_t
childCount
;
aShell
-
>
GetInProcessChildCount
(
&
childCount
)
;
for
(
int32_t
i
=
0
;
i
<
childCount
;
+
+
i
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
childItem
;
aShell
-
>
GetInProcessChildAt
(
i
getter_AddRefs
(
childItem
)
)
;
nsCOMPtr
<
nsIDocShell
>
shell
=
do_QueryInterface
(
childItem
)
;
AttachContainerRecurse
(
shell
)
;
}
}
NS_IMETHODIMP
nsDocumentViewer
:
:
Open
(
nsISupports
*
aState
nsISHEntry
*
aSHEntry
)
{
NS_ENSURE_TRUE
(
mPresShell
NS_ERROR_NOT_INITIALIZED
)
;
if
(
mDocument
)
{
mDocument
-
>
SetContainer
(
mContainer
)
;
}
nsresult
rv
=
InitInternal
(
mParentWidget
aState
nullptr
mBounds
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mHidden
=
false
;
if
(
mPresShell
)
mPresShell
-
>
SetForwardingContainer
(
WeakPtr
<
nsDocShell
>
(
)
)
;
if
(
aSHEntry
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
item
;
int32_t
itemIndex
=
0
;
while
(
NS_SUCCEEDED
(
aSHEntry
-
>
ChildShellAt
(
itemIndex
+
+
getter_AddRefs
(
item
)
)
)
&
&
item
)
{
nsCOMPtr
<
nsIDocShell
>
shell
=
do_QueryInterface
(
item
)
;
AttachContainerRecurse
(
shell
)
;
}
}
SyncParentSubDocMap
(
)
;
ReinitializeFocusListener
(
)
;
PrepareToStartLoad
(
)
;
if
(
nsIWidget
:
:
UsePuppetWidgets
(
)
&
&
mPresContext
&
&
ShouldAttachToTopLevel
(
)
)
{
DetachFromTopLevelWidget
(
)
;
nsViewManager
*
vm
=
GetViewManager
(
)
;
MOZ_ASSERT
(
vm
"
no
view
manager
"
)
;
nsView
*
v
=
vm
-
>
GetRootView
(
)
;
MOZ_ASSERT
(
v
"
no
root
view
"
)
;
MOZ_ASSERT
(
mParentWidget
"
no
mParentWidget
to
set
"
)
;
v
-
>
AttachToTopLevelWidget
(
mParentWidget
)
;
mAttachedToParent
=
true
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
Close
(
nsISHEntry
*
aSHEntry
)
{
mSHEntry
=
aSHEntry
;
if
(
!
mDocument
)
return
NS_OK
;
if
(
mSHEntry
)
{
if
(
mBFCachePreventionObserver
)
{
mBFCachePreventionObserver
-
>
Disconnect
(
)
;
}
mBFCachePreventionObserver
=
new
BFCachePreventionObserver
(
mDocument
)
;
mDocument
-
>
AddMutationObserver
(
mBFCachePreventionObserver
)
;
}
#
ifdef
NS_PRINTING
if
(
mPrintJob
&
&
!
mClosingWhilePrinting
)
{
mClosingWhilePrinting
=
true
;
}
else
#
endif
{
mDocument
-
>
SetScriptGlobalObject
(
nullptr
)
;
if
(
!
mSHEntry
&
&
mDocument
)
mDocument
-
>
RemovedFromDocShell
(
)
;
}
RemoveFocusListener
(
)
;
return
NS_OK
;
}
static
void
DetachContainerRecurse
(
nsIDocShell
*
aShell
)
{
aShell
-
>
SynchronizeLayoutHistoryState
(
)
;
nsCOMPtr
<
nsIDocumentViewer
>
viewer
;
aShell
-
>
GetDocViewer
(
getter_AddRefs
(
viewer
)
)
;
if
(
viewer
)
{
if
(
Document
*
doc
=
viewer
-
>
GetDocument
(
)
)
{
doc
-
>
SetContainer
(
nullptr
)
;
}
if
(
PresShell
*
presShell
=
viewer
-
>
GetPresShell
(
)
)
{
auto
weakShell
=
static_cast
<
nsDocShell
*
>
(
aShell
)
;
presShell
-
>
SetForwardingContainer
(
weakShell
)
;
}
}
int32_t
childCount
;
aShell
-
>
GetInProcessChildCount
(
&
childCount
)
;
for
(
int32_t
i
=
0
;
i
<
childCount
;
+
+
i
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
childItem
;
aShell
-
>
GetInProcessChildAt
(
i
getter_AddRefs
(
childItem
)
)
;
nsCOMPtr
<
nsIDocShell
>
shell
=
do_QueryInterface
(
childItem
)
;
DetachContainerRecurse
(
shell
)
;
}
}
NS_IMETHODIMP
nsDocumentViewer
:
:
Destroy
(
)
{
if
(
mDestroyBlockedCount
!
=
0
)
{
return
NS_OK
;
}
#
ifdef
NS_PRINTING
if
(
mPrintJob
&
&
mPrintJob
-
>
CheckBeforeDestroy
(
)
)
{
return
NS_OK
;
}
#
endif
if
(
mBFCachePreventionObserver
)
{
mBFCachePreventionObserver
-
>
Disconnect
(
)
;
mBFCachePreventionObserver
=
nullptr
;
}
if
(
mSHEntry
&
&
mDocument
&
&
!
mDocument
-
>
IsBFCachingAllowed
(
)
)
{
MOZ_LOG
(
gPageCacheLog
LogLevel
:
:
Debug
(
"
BFCache
not
allowed
dropping
SHEntry
"
)
)
;
nsCOMPtr
<
nsISHEntry
>
shEntry
=
std
:
:
move
(
mSHEntry
)
;
shEntry
-
>
SetDocumentViewer
(
nullptr
)
;
shEntry
-
>
SyncPresentationState
(
)
;
}
if
(
mSHEntry
)
{
if
(
mPresShell
)
mPresShell
-
>
Freeze
(
)
;
mSHEntry
-
>
SetSticky
(
mIsSticky
)
;
mIsSticky
=
true
;
if
(
mPresShell
)
{
nsViewManager
*
vm
=
mPresShell
-
>
GetViewManager
(
)
;
if
(
vm
)
{
nsView
*
rootView
=
vm
-
>
GetRootView
(
)
;
if
(
rootView
)
{
nsView
*
rootViewParent
=
rootView
-
>
GetParent
(
)
;
if
(
rootViewParent
)
{
nsView
*
subdocview
=
rootViewParent
-
>
GetParent
(
)
;
if
(
subdocview
)
{
nsIFrame
*
f
=
subdocview
-
>
GetFrame
(
)
;
if
(
f
)
{
nsSubDocumentFrame
*
s
=
do_QueryFrame
(
f
)
;
if
(
s
)
{
s
-
>
ClearDisplayItems
(
)
;
}
}
}
nsViewManager
*
parentVM
=
rootViewParent
-
>
GetViewManager
(
)
;
if
(
parentVM
)
{
parentVM
-
>
RemoveChild
(
rootView
)
;
}
}
}
}
}
Hide
(
)
;
if
(
mDocument
)
{
mDocument
-
>
Sanitize
(
)
;
}
nsCOMPtr
<
nsISHEntry
>
shEntry
=
std
:
:
move
(
mSHEntry
)
;
MOZ_LOG
(
gPageCacheLog
LogLevel
:
:
Debug
(
"
Storing
content
viewer
into
cache
entry
"
)
)
;
shEntry
-
>
SetDocumentViewer
(
this
)
;
shEntry
-
>
SyncPresentationState
(
)
;
#
ifdef
ACCESSIBILITY
if
(
mPresShell
)
{
a11y
:
:
DocAccessible
*
docAcc
=
mPresShell
-
>
GetDocAccessible
(
)
;
if
(
docAcc
)
{
docAcc
-
>
Shutdown
(
)
;
}
}
#
endif
if
(
mDocument
)
{
mDocument
-
>
SetContainer
(
nullptr
)
;
}
if
(
mPresShell
)
{
mPresShell
-
>
SetForwardingContainer
(
mContainer
)
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
item
;
int32_t
itemIndex
=
0
;
while
(
NS_SUCCEEDED
(
shEntry
-
>
ChildShellAt
(
itemIndex
+
+
getter_AddRefs
(
item
)
)
)
&
&
item
)
{
nsCOMPtr
<
nsIDocShell
>
shell
=
do_QueryInterface
(
item
)
;
DetachContainerRecurse
(
shell
)
;
}
return
NS_OK
;
}
nsAutoScriptBlocker
scriptBlocker
;
if
(
mPresShell
)
{
DestroyPresShell
(
)
;
}
if
(
mDocument
)
{
mDocument
-
>
Destroy
(
)
;
mDocument
=
nullptr
;
}
#
ifdef
NS_PRINTING
if
(
mPrintJob
)
{
RefPtr
<
nsPrintJob
>
printJob
=
std
:
:
move
(
mPrintJob
)
;
#
ifdef
NS_PRINT_PREVIEW
if
(
printJob
-
>
CreatedForPrintPreview
(
)
)
{
printJob
-
>
FinishPrintPreview
(
)
;
}
#
endif
printJob
-
>
Destroy
(
)
;
MOZ_ASSERT
(
!
mPrintJob
"
mPrintJob
shouldn
'
t
be
recreated
while
destroying
it
"
)
;
}
#
endif
if
(
mPreviousViewer
)
{
mPreviousViewer
-
>
Destroy
(
)
;
mPreviousViewer
=
nullptr
;
}
mDeviceContext
=
nullptr
;
if
(
mPresContext
)
{
DestroyPresContext
(
)
;
}
mWindow
=
nullptr
;
mViewManager
=
nullptr
;
mContainer
=
WeakPtr
<
nsDocShell
>
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
Stop
(
void
)
{
NS_ASSERTION
(
mDocument
"
Stop
called
too
early
or
too
late
"
)
;
if
(
mDocument
)
{
mDocument
-
>
StopDocumentLoad
(
)
;
}
mStopped
=
true
;
if
(
!
mLoaded
&
&
mPresShell
)
{
RefPtr
<
PresShell
>
presShell
=
mPresShell
;
presShell
-
>
UnsuppressPainting
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetDOMDocument
(
Document
*
*
aResult
)
{
NS_ENSURE_TRUE
(
mDocument
NS_ERROR_NOT_AVAILABLE
)
;
nsCOMPtr
<
Document
>
document
=
mDocument
;
document
.
forget
(
aResult
)
;
return
NS_OK
;
}
Document
*
nsDocumentViewer
:
:
GetDocument
(
)
{
return
mDocument
;
}
nsresult
nsDocumentViewer
:
:
SetDocument
(
Document
*
aDocument
)
{
if
(
!
aDocument
)
return
NS_ERROR_NULL_POINTER
;
return
SetDocumentInternal
(
aDocument
false
)
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
SetDocumentInternal
(
Document
*
aDocument
bool
aForceReuseInnerWindow
)
{
MOZ_ASSERT
(
aDocument
)
;
aDocument
-
>
SetContainer
(
mContainer
)
;
if
(
mDocument
!
=
aDocument
)
{
if
(
aForceReuseInnerWindow
)
{
aDocument
-
>
SetNavigationTiming
(
mDocument
-
>
GetNavigationTiming
(
)
)
;
}
if
(
mDocument
&
&
(
mDocument
-
>
IsStaticDocument
(
)
|
|
aDocument
-
>
IsStaticDocument
(
)
)
)
{
nsContentUtils
:
:
AddScriptRunner
(
NewRunnableMethod
(
"
Document
:
:
Destroy
"
mDocument
&
Document
:
:
Destroy
)
)
;
}
if
(
!
aDocument
-
>
IsStaticDocument
(
)
)
{
nsCOMPtr
<
nsIDocShell
>
node
(
mContainer
)
;
if
(
node
)
{
int32_t
count
;
node
-
>
GetInProcessChildCount
(
&
count
)
;
for
(
int32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
child
;
node
-
>
GetInProcessChildAt
(
0
getter_AddRefs
(
child
)
)
;
node
-
>
RemoveChild
(
child
)
;
}
}
}
mDocument
=
aDocument
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
mContainer
?
mContainer
-
>
GetWindow
(
)
:
nullptr
;
if
(
window
)
{
nsresult
rv
=
window
-
>
SetNewDocument
(
aDocument
nullptr
aForceReuseInnerWindow
)
;
if
(
NS_FAILED
(
rv
)
)
{
Destroy
(
)
;
return
rv
;
}
}
}
nsresult
rv
=
SyncParentSubDocMap
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoScriptBlocker
scriptBlocker
;
if
(
mPresShell
)
{
DestroyPresShell
(
)
;
}
if
(
mPresContext
)
{
DestroyPresContext
(
)
;
mWindow
=
nullptr
;
rv
=
InitInternal
(
mParentWidget
nullptr
nullptr
mBounds
true
true
false
)
;
}
return
rv
;
}
PresShell
*
nsDocumentViewer
:
:
GetPresShell
(
)
{
return
mPresShell
;
}
nsPresContext
*
nsDocumentViewer
:
:
GetPresContext
(
)
{
return
mPresContext
;
}
nsViewManager
*
nsDocumentViewer
:
:
GetViewManager
(
)
{
return
mViewManager
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetBounds
(
nsIntRect
&
aResult
)
{
NS_ENSURE_TRUE
(
mDocument
NS_ERROR_NOT_AVAILABLE
)
;
aResult
=
mBounds
;
return
NS_OK
;
}
nsIDocumentViewer
*
nsDocumentViewer
:
:
GetPreviousViewer
(
)
{
return
mPreviousViewer
;
}
void
nsDocumentViewer
:
:
SetPreviousViewer
(
nsIDocumentViewer
*
aViewer
)
{
if
(
aViewer
)
{
NS_ASSERTION
(
!
mPreviousViewer
"
can
'
t
set
previous
viewer
when
there
already
is
one
"
)
;
nsCOMPtr
<
nsIDocumentViewer
>
prevViewer
=
aViewer
-
>
GetPreviousViewer
(
)
;
if
(
prevViewer
)
{
aViewer
-
>
SetPreviousViewer
(
nullptr
)
;
aViewer
-
>
Destroy
(
)
;
return
SetPreviousViewer
(
prevViewer
)
;
}
}
mPreviousViewer
=
aViewer
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
SetBoundsWithFlags
(
const
nsIntRect
&
aBounds
uint32_t
aFlags
)
{
NS_ENSURE_TRUE
(
mDocument
NS_ERROR_NOT_AVAILABLE
)
;
bool
boundsChanged
=
!
mBounds
.
IsEqualEdges
(
aBounds
)
;
mBounds
=
aBounds
;
if
(
mWindow
&
&
!
mAttachedToParent
)
{
mWindow
-
>
Resize
(
aBounds
.
x
aBounds
.
y
aBounds
.
width
aBounds
.
height
false
)
;
}
else
if
(
mPresContext
&
&
mViewManager
)
{
if
(
mPresContext
-
>
DeviceContext
(
)
-
>
CheckDPIChange
(
)
)
{
mPresContext
-
>
UIResolutionChangedSync
(
)
;
}
int32_t
p2a
=
mPresContext
-
>
AppUnitsPerDevPixel
(
)
;
nscoord
width
=
NSIntPixelsToAppUnits
(
mBounds
.
width
p2a
)
;
nscoord
height
=
NSIntPixelsToAppUnits
(
mBounds
.
height
p2a
)
;
nsView
*
rootView
=
mViewManager
-
>
GetRootView
(
)
;
if
(
boundsChanged
&
&
rootView
)
{
nsRect
viewDims
=
rootView
-
>
GetDimensions
(
)
;
if
(
viewDims
.
width
=
=
width
&
&
viewDims
.
height
=
=
height
)
{
nsIFrame
*
f
=
rootView
-
>
GetFrame
(
)
;
if
(
f
)
{
f
-
>
InvalidateFrame
(
)
;
}
}
}
mViewManager
-
>
SetWindowDimensions
(
width
height
!
!
(
aFlags
&
nsIDocumentViewer
:
:
eDelayResize
)
)
;
}
if
(
mPreviousViewer
)
{
nsCOMPtr
<
nsIDocumentViewer
>
previousViewer
=
mPreviousViewer
;
previousViewer
-
>
SetBounds
(
aBounds
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
SetBounds
(
const
nsIntRect
&
aBounds
)
{
return
SetBoundsWithFlags
(
aBounds
0
)
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
Move
(
int32_t
aX
int32_t
aY
)
{
NS_ENSURE_TRUE
(
mDocument
NS_ERROR_NOT_AVAILABLE
)
;
mBounds
.
MoveTo
(
aX
aY
)
;
if
(
mWindow
)
{
mWindow
-
>
Move
(
aX
aY
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
Show
(
)
{
NS_ENSURE_TRUE
(
mDocument
NS_ERROR_NOT_AVAILABLE
)
;
if
(
mPreviousViewer
)
{
nsCOMPtr
<
nsIDocumentViewer
>
prevViewer
(
mPreviousViewer
)
;
mPreviousViewer
=
nullptr
;
prevViewer
-
>
Destroy
(
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
treeItem
(
mContainer
)
;
if
(
treeItem
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
root
;
treeItem
-
>
GetInProcessSameTypeRootTreeItem
(
getter_AddRefs
(
root
)
)
;
nsCOMPtr
<
nsIWebNavigation
>
webNav
=
do_QueryInterface
(
root
)
;
RefPtr
<
ChildSHistory
>
history
=
webNav
-
>
GetSessionHistory
(
)
;
if
(
!
mozilla
:
:
SessionHistoryInParent
(
)
&
&
history
)
{
int32_t
prevIndex
loadedIndex
;
nsCOMPtr
<
nsIDocShell
>
docShell
=
do_QueryInterface
(
treeItem
)
;
docShell
-
>
GetPreviousEntryIndex
(
&
prevIndex
)
;
docShell
-
>
GetLoadedEntryIndex
(
&
loadedIndex
)
;
MOZ_LOG
(
gPageCacheLog
LogLevel
:
:
Verbose
(
"
About
to
evict
content
viewers
:
prev
=
%
d
loaded
=
%
d
"
prevIndex
loadedIndex
)
)
;
history
-
>
LegacySHistory
(
)
-
>
EvictOutOfRangeDocumentViewers
(
loadedIndex
)
;
}
}
}
if
(
mWindow
)
{
if
(
!
mAttachedToParent
)
{
mWindow
-
>
Show
(
true
)
;
}
}
nsCOMPtr
<
Document
>
document
=
mDocument
;
if
(
mDocument
&
&
!
mPresShell
)
{
nsAutoScriptBlocker
scriptBlocker
;
NS_ASSERTION
(
!
mWindow
"
Window
already
created
but
no
presshell
?
"
)
;
nsCOMPtr
<
nsIBaseWindow
>
base_win
(
mContainer
)
;
if
(
base_win
)
{
base_win
-
>
GetParentWidget
(
&
mParentWidget
)
;
if
(
mParentWidget
)
{
mParentWidget
-
>
Release
(
)
;
}
}
nsView
*
containerView
=
FindContainerView
(
)
;
nsresult
rv
=
CreateDeviceContext
(
containerView
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ASSERTION
(
!
mPresContext
"
Shouldn
'
t
have
a
prescontext
if
we
have
no
shell
!
"
)
;
mPresContext
=
CreatePresContext
(
mDocument
nsPresContext
:
:
eContext_Galley
containerView
)
;
NS_ENSURE_TRUE
(
mPresContext
NS_ERROR_OUT_OF_MEMORY
)
;
rv
=
mPresContext
-
>
Init
(
mDeviceContext
)
;
if
(
NS_FAILED
(
rv
)
)
{
mPresContext
=
nullptr
;
return
rv
;
}
rv
=
MakeWindow
(
nsSize
(
mPresContext
-
>
DevPixelsToAppUnits
(
mBounds
.
width
)
mPresContext
-
>
DevPixelsToAppUnits
(
mBounds
.
height
)
)
containerView
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
mPresContext
)
{
Hide
(
)
;
rv
=
InitPresentationStuff
(
mDocument
-
>
MayStartLayout
(
)
)
;
}
if
(
mPresShell
)
{
RefPtr
<
PresShell
>
presShell
=
mPresShell
;
presShell
-
>
UnsuppressPainting
(
)
;
}
}
RefPtr
<
nsDocumentShownDispatcher
>
event
=
new
nsDocumentShownDispatcher
(
document
)
;
document
-
>
Dispatch
(
event
.
forget
(
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
Hide
(
)
{
if
(
!
mAttachedToParent
&
&
mWindow
)
{
mWindow
-
>
Show
(
false
)
;
}
if
(
!
mPresShell
)
return
NS_OK
;
NS_ASSERTION
(
mPresContext
"
Can
'
t
have
a
presshell
and
no
prescontext
!
"
)
;
if
(
mPreviousViewer
)
{
mPreviousViewer
-
>
Destroy
(
)
;
mPreviousViewer
=
nullptr
;
}
if
(
mIsSticky
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
(
mContainer
)
;
if
(
docShell
)
{
#
ifdef
DEBUG
nsCOMPtr
<
nsIDocumentViewer
>
currentViewer
;
docShell
-
>
GetDocViewer
(
getter_AddRefs
(
currentViewer
)
)
;
MOZ_ASSERT
(
currentViewer
=
=
this
)
;
#
endif
nsCOMPtr
<
nsILayoutHistoryState
>
layoutState
;
mPresShell
-
>
CaptureHistoryState
(
getter_AddRefs
(
layoutState
)
)
;
}
nsAutoScriptBlocker
scriptBlocker
;
DestroyPresShell
(
)
;
DestroyPresContext
(
)
;
mViewManager
=
nullptr
;
mWindow
=
nullptr
;
mDeviceContext
=
nullptr
;
mParentWidget
=
nullptr
;
nsCOMPtr
<
nsIBaseWindow
>
base_win
(
mContainer
)
;
if
(
base_win
&
&
!
mAttachedToParent
)
{
base_win
-
>
SetParentWidget
(
nullptr
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetSticky
(
bool
*
aSticky
)
{
*
aSticky
=
mIsSticky
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
SetSticky
(
bool
aSticky
)
{
mIsSticky
=
aSticky
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
ClearHistoryEntry
(
)
{
if
(
mDocument
)
{
nsJSContext
:
:
PokeGC
(
JS
:
:
GCReason
:
:
PAGE_HIDE
mDocument
-
>
GetWrapperPreserveColor
(
)
TimeDuration
:
:
FromMilliseconds
(
StaticPrefs
:
:
javascript_options_gc_delay
(
)
*
2
)
)
;
}
mSHEntry
=
nullptr
;
return
NS_OK
;
}
nsresult
nsDocumentViewer
:
:
MakeWindow
(
const
nsSize
&
aSize
nsView
*
aContainerView
)
{
if
(
GetIsPrintPreview
(
)
)
{
return
NS_OK
;
}
bool
shouldAttach
=
ShouldAttachToTopLevel
(
)
;
if
(
shouldAttach
)
{
DetachFromTopLevelWidget
(
)
;
}
mViewManager
=
new
nsViewManager
(
)
;
nsDeviceContext
*
dx
=
mPresContext
-
>
DeviceContext
(
)
;
nsresult
rv
=
mViewManager
-
>
Init
(
dx
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsRect
tbounds
(
nsPoint
(
0
0
)
aSize
)
;
nsView
*
view
=
mViewManager
-
>
CreateView
(
tbounds
aContainerView
)
;
if
(
!
view
)
return
NS_ERROR_OUT_OF_MEMORY
;
if
(
!
mDocument
-
>
IsResourceDoc
(
)
&
&
(
mParentWidget
|
|
!
aContainerView
)
)
{
widget
:
:
InitData
initData
;
widget
:
:
InitData
*
initDataPtr
;
if
(
!
mParentWidget
)
{
initDataPtr
=
&
initData
;
initData
.
mWindowType
=
widget
:
:
WindowType
:
:
Invisible
;
}
else
{
initDataPtr
=
nullptr
;
}
if
(
shouldAttach
)
{
rv
=
view
-
>
AttachToTopLevelWidget
(
mParentWidget
)
;
mAttachedToParent
=
true
;
}
else
if
(
!
aContainerView
&
&
mParentWidget
)
{
rv
=
view
-
>
CreateWidgetForParent
(
mParentWidget
initDataPtr
true
false
)
;
}
else
{
rv
=
view
-
>
CreateWidget
(
initDataPtr
true
false
)
;
}
if
(
NS_FAILED
(
rv
)
)
return
rv
;
}
mViewManager
-
>
SetRootView
(
view
)
;
mWindow
=
view
-
>
GetWidget
(
)
;
return
rv
;
}
void
nsDocumentViewer
:
:
DetachFromTopLevelWidget
(
)
{
if
(
mViewManager
)
{
nsView
*
oldView
=
mViewManager
-
>
GetRootView
(
)
;
if
(
oldView
&
&
oldView
-
>
IsAttachedToTopLevel
(
)
)
{
oldView
-
>
DetachFromTopLevelWidget
(
)
;
}
}
mAttachedToParent
=
false
;
}
nsView
*
nsDocumentViewer
:
:
FindContainerView
(
)
{
if
(
!
mContainer
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
(
mContainer
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
pwin
(
docShell
-
>
GetWindow
(
)
)
;
if
(
!
pwin
)
{
return
nullptr
;
}
nsCOMPtr
<
Element
>
containerElement
=
pwin
-
>
GetFrameElementInternal
(
)
;
if
(
!
containerElement
)
{
return
nullptr
;
}
nsIFrame
*
subdocFrame
=
containerElement
-
>
GetPrimaryFrame
(
)
;
if
(
!
subdocFrame
)
{
LAYOUT_WARNING
(
"
Subdocument
container
has
no
frame
"
)
;
return
nullptr
;
}
if
(
!
subdocFrame
-
>
IsSubDocumentFrame
(
)
)
{
NS_WARNING_ASSERTION
(
subdocFrame
-
>
Type
(
)
=
=
LayoutFrameType
:
:
None
"
Subdocument
container
has
non
-
subdocument
frame
"
)
;
return
nullptr
;
}
NS_ASSERTION
(
subdocFrame
-
>
GetView
(
)
"
Subdoc
frames
must
have
views
"
)
;
return
static_cast
<
nsSubDocumentFrame
*
>
(
subdocFrame
)
-
>
EnsureInnerView
(
)
;
}
nsresult
nsDocumentViewer
:
:
CreateDeviceContext
(
nsView
*
aContainerView
)
{
MOZ_ASSERT
(
!
mPresShell
&
&
!
mWindow
"
This
will
screw
up
our
existing
presentation
"
)
;
MOZ_ASSERT
(
mDocument
"
Gotta
have
a
document
here
"
)
;
Document
*
doc
=
mDocument
-
>
GetDisplayDocument
(
)
;
if
(
doc
)
{
NS_ASSERTION
(
!
aContainerView
"
External
resource
document
embedded
somewhere
?
"
)
;
nsPresContext
*
ctx
=
doc
-
>
GetPresContext
(
)
;
if
(
ctx
)
{
mDeviceContext
=
ctx
-
>
DeviceContext
(
)
;
return
NS_OK
;
}
}
nsIWidget
*
widget
=
nullptr
;
if
(
aContainerView
)
{
widget
=
aContainerView
-
>
GetNearestWidget
(
nullptr
)
;
}
if
(
!
widget
)
{
widget
=
mParentWidget
;
}
if
(
widget
)
{
widget
=
widget
-
>
GetTopLevelWidget
(
)
;
}
mDeviceContext
=
new
nsDeviceContext
(
)
;
mDeviceContext
-
>
Init
(
widget
)
;
return
NS_OK
;
}
mozilla
:
:
dom
:
:
Selection
*
nsDocumentViewer
:
:
GetDocumentSelection
(
)
{
if
(
!
mPresShell
)
{
return
nullptr
;
}
return
mPresShell
-
>
GetCurrentSelection
(
SelectionType
:
:
eNormal
)
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
NS_IMETHODIMP
nsDocumentViewer
:
:
ClearSelection
(
)
{
RefPtr
<
mozilla
:
:
dom
:
:
Selection
>
selection
=
GetDocumentSelection
(
)
;
if
(
!
selection
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
rv
;
selection
-
>
CollapseToStart
(
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
NS_IMETHODIMP
nsDocumentViewer
:
:
SelectAll
(
)
{
RefPtr
<
mozilla
:
:
dom
:
:
Selection
>
selection
=
GetDocumentSelection
(
)
;
if
(
!
selection
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
mDocument
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsINode
>
bodyNode
;
if
(
mDocument
-
>
IsHTMLOrXHTML
(
)
)
{
bodyNode
=
mDocument
-
>
GetBody
(
)
;
}
else
{
bodyNode
=
mDocument
-
>
GetRootElement
(
)
;
}
if
(
!
bodyNode
)
return
NS_ERROR_FAILURE
;
ErrorResult
err
;
selection
-
>
RemoveAllRanges
(
err
)
;
if
(
err
.
Failed
(
)
)
{
return
err
.
StealNSResult
(
)
;
}
mozilla
:
:
dom
:
:
Selection
:
:
AutoUserInitiated
userSelection
(
selection
)
;
selection
-
>
SelectAllChildren
(
*
bodyNode
err
)
;
return
err
.
StealNSResult
(
)
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
CopySelection
(
)
{
RefPtr
<
PresShell
>
presShell
=
mPresShell
;
nsCopySupport
:
:
FireClipboardEvent
(
eCopy
nsIClipboard
:
:
kGlobalClipboard
presShell
nullptr
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
CopyLinkLocation
(
)
{
NS_ENSURE_TRUE
(
mPresShell
NS_ERROR_NOT_INITIALIZED
)
;
nsCOMPtr
<
nsINode
>
node
=
GetPopupLinkNode
(
)
;
NS_ENSURE_TRUE
(
node
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
dom
:
:
Element
>
elm
(
do_QueryInterface
(
node
)
)
;
NS_ENSURE_TRUE
(
elm
NS_ERROR_FAILURE
)
;
nsAutoString
locationText
;
nsContentUtils
:
:
GetLinkLocation
(
elm
locationText
)
;
if
(
locationText
.
IsEmpty
(
)
)
return
NS_ERROR_FAILURE
;
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIClipboardHelper
>
clipboard
(
do_GetService
(
"
mozilla
.
org
/
widget
/
clipboardhelper
;
1
"
&
rv
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
clipboard
-
>
CopyString
(
locationText
mDocument
-
>
GetWindowContext
(
)
)
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
CopyImage
(
int32_t
aCopyFlags
)
{
NS_ENSURE_TRUE
(
mPresShell
NS_ERROR_NOT_INITIALIZED
)
;
nsCOMPtr
<
nsIImageLoadingContent
>
node
=
GetPopupImageNode
(
)
;
NS_ENSURE_TRUE
(
node
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsILoadContext
>
loadContext
(
mContainer
)
;
return
nsCopySupport
:
:
ImageCopy
(
node
loadContext
aCopyFlags
mDocument
-
>
GetWindowContext
(
)
)
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetCopyable
(
bool
*
aCopyable
)
{
NS_ENSURE_ARG_POINTER
(
aCopyable
)
;
*
aCopyable
=
nsCopySupport
:
:
CanCopy
(
mDocument
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetContents
(
const
char
*
mimeType
bool
selectionOnly
nsAString
&
aOutValue
)
{
aOutValue
.
Truncate
(
)
;
NS_ENSURE_TRUE
(
mPresShell
NS_ERROR_NOT_INITIALIZED
)
;
NS_ENSURE_TRUE
(
mDocument
NS_ERROR_NOT_INITIALIZED
)
;
RefPtr
<
Selection
>
sel
;
if
(
selectionOnly
)
{
sel
=
nsCopySupport
:
:
GetSelectionForCopy
(
mDocument
)
;
NS_ENSURE_TRUE
(
sel
NS_ERROR_FAILURE
)
;
if
(
NS_WARN_IF
(
sel
-
>
IsCollapsed
(
)
)
)
{
return
NS_OK
;
}
}
return
nsCopySupport
:
:
GetContents
(
nsDependentCString
(
mimeType
)
0
sel
mDocument
aOutValue
)
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetCanGetContents
(
bool
*
aCanGetContents
)
{
NS_ENSURE_ARG_POINTER
(
aCanGetContents
)
;
*
aCanGetContents
=
false
;
NS_ENSURE_STATE
(
mDocument
)
;
*
aCanGetContents
=
nsCopySupport
:
:
CanCopy
(
mDocument
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
SetCommandNode
(
nsINode
*
aNode
)
{
Document
*
document
=
GetDocument
(
)
;
NS_ENSURE_STATE
(
document
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
(
document
-
>
GetWindow
(
)
)
;
NS_ENSURE_TRUE
(
window
NS_ERROR_NOT_AVAILABLE
)
;
nsCOMPtr
<
nsPIWindowRoot
>
root
=
window
-
>
GetTopWindowRoot
(
)
;
NS_ENSURE_STATE
(
root
)
;
root
-
>
SetPopupNode
(
aNode
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetDeviceFullZoomForTest
(
float
*
aDeviceFullZoom
)
{
NS_ENSURE_ARG_POINTER
(
aDeviceFullZoom
)
;
nsPresContext
*
pc
=
GetPresContext
(
)
;
*
aDeviceFullZoom
=
pc
?
pc
-
>
GetDeviceFullZoom
(
)
:
1
.
0
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
SetAuthorStyleDisabled
(
bool
aStyleDisabled
)
{
if
(
mPresShell
)
{
mPresShell
-
>
SetAuthorStyleDisabled
(
aStyleDisabled
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetAuthorStyleDisabled
(
bool
*
aStyleDisabled
)
{
if
(
mPresShell
)
{
*
aStyleDisabled
=
mPresShell
-
>
GetAuthorStyleDisabled
(
)
;
}
else
{
*
aStyleDisabled
=
false
;
}
return
NS_OK
;
}
NS_IMETHODIMP_
(
const
Encoding
*
)
nsDocumentViewer
:
:
GetReloadEncodingAndSource
(
int32_t
*
aSource
)
{
*
aSource
=
mReloadEncodingSource
;
if
(
kCharsetUninitialized
=
=
mReloadEncodingSource
)
{
return
nullptr
;
}
return
mReloadEncoding
;
}
NS_IMETHODIMP_
(
void
)
nsDocumentViewer
:
:
SetReloadEncodingAndSource
(
const
Encoding
*
aEncoding
int32_t
aSource
)
{
MOZ_ASSERT
(
aSource
=
=
kCharsetUninitialized
|
|
(
aSource
>
=
kCharsetFromFinalAutoDetectionWouldHaveBeenUTF8InitialWasASCII
&
&
aSource
<
=
kCharsetFromFinalAutoDetectionWouldNotHaveBeenUTF8DependedOnTLDInitialWasASCII
)
|
|
aSource
=
=
kCharsetFromFinalUserForcedAutoDetection
)
;
mReloadEncoding
=
aEncoding
;
mReloadEncodingSource
=
aSource
;
}
NS_IMETHODIMP_
(
void
)
nsDocumentViewer
:
:
ForgetReloadEncoding
(
)
{
mReloadEncoding
=
nullptr
;
mReloadEncodingSource
=
kCharsetUninitialized
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
NS_IMETHODIMP
nsDocumentViewer
:
:
GetContentSize
(
int32_t
aMaxWidth
int32_t
aMaxHeight
int32_t
aPrefWidth
int32_t
*
aWidth
int32_t
*
aHeight
)
{
NS_ENSURE_STATE
(
mContainer
)
;
RefPtr
<
BrowsingContext
>
bc
=
mContainer
-
>
GetBrowsingContext
(
)
;
NS_ENSURE_TRUE
(
bc
NS_ERROR_NOT_AVAILABLE
)
;
NS_ENSURE_TRUE
(
bc
-
>
IsTop
(
)
NS_ERROR_FAILURE
)
;
if
(
aMaxWidth
>
0
)
{
aMaxWidth
=
CSSPixel
:
:
ToAppUnits
(
aMaxWidth
)
;
}
else
{
aMaxWidth
=
NS_UNCONSTRAINEDSIZE
;
}
if
(
aMaxHeight
>
0
)
{
aMaxHeight
=
CSSPixel
:
:
ToAppUnits
(
aMaxHeight
)
;
}
else
{
aMaxHeight
=
NS_UNCONSTRAINEDSIZE
;
}
if
(
aPrefWidth
>
0
)
{
aPrefWidth
=
CSSPixel
:
:
ToAppUnits
(
aPrefWidth
)
;
}
else
{
aPrefWidth
=
0
;
}
RefPtr
<
PresShell
>
presShell
=
GetPresShell
(
)
;
NS_ENSURE_TRUE
(
presShell
NS_ERROR_FAILURE
)
;
mDocument
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
nsIFrame
*
root
=
presShell
-
>
GetRootFrame
(
)
;
NS_ENSURE_TRUE
(
root
NS_ERROR_FAILURE
)
;
WritingMode
wm
=
root
-
>
GetWritingMode
(
)
;
nscoord
prefISize
;
{
const
auto
&
constraints
=
presShell
-
>
GetWindowSizeConstraints
(
)
;
aMaxHeight
=
std
:
:
min
(
aMaxHeight
constraints
.
mMaxSize
.
height
)
;
aMaxWidth
=
std
:
:
min
(
aMaxWidth
constraints
.
mMaxSize
.
width
)
;
UniquePtr
<
gfxContext
>
rcx
(
presShell
-
>
CreateReferenceRenderingContext
(
)
)
;
const
nscoord
minISize
=
wm
.
IsVertical
(
)
?
constraints
.
mMinSize
.
height
:
constraints
.
mMinSize
.
width
;
const
nscoord
maxISize
=
wm
.
IsVertical
(
)
?
aMaxHeight
:
aMaxWidth
;
if
(
aPrefWidth
)
{
prefISize
=
std
:
:
max
(
root
-
>
GetMinISize
(
rcx
.
get
(
)
)
aPrefWidth
)
;
}
else
{
prefISize
=
root
-
>
GetPrefISize
(
rcx
.
get
(
)
)
;
}
prefISize
=
nsPresContext
:
:
RoundUpAppUnitsToCSSPixel
(
std
:
:
max
(
minISize
std
:
:
min
(
prefISize
maxISize
)
)
)
;
}
NS_ENSURE_TRUE
(
prefISize
!
=
NS_UNCONSTRAINEDSIZE
NS_ERROR_FAILURE
)
;
nscoord
height
=
wm
.
IsVertical
(
)
?
prefISize
:
aMaxHeight
;
nscoord
width
=
wm
.
IsVertical
(
)
?
aMaxWidth
:
prefISize
;
presShell
-
>
ResizeReflow
(
width
height
ResizeReflowOptions
:
:
BSizeLimit
)
;
RefPtr
<
nsPresContext
>
presContext
=
GetPresContext
(
)
;
NS_ENSURE_TRUE
(
presContext
NS_ERROR_FAILURE
)
;
nsRect
shellArea
=
presContext
-
>
GetVisibleArea
(
)
;
NS_ENSURE_TRUE
(
shellArea
.
width
!
=
NS_UNCONSTRAINEDSIZE
&
&
shellArea
.
height
!
=
NS_UNCONSTRAINEDSIZE
NS_ERROR_FAILURE
)
;
*
aWidth
=
std
:
:
ceil
(
CSSPixel
:
:
FromAppUnits
(
shellArea
.
width
)
)
;
*
aHeight
=
std
:
:
ceil
(
CSSPixel
:
:
FromAppUnits
(
shellArea
.
height
)
)
;
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
nsDocViewerSelectionListener
nsISelectionListener
)
already_AddRefed
<
nsINode
>
nsDocumentViewer
:
:
GetPopupNode
(
)
{
Document
*
document
=
GetDocument
(
)
;
NS_ENSURE_TRUE
(
document
nullptr
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
(
document
-
>
GetWindow
(
)
)
;
NS_ENSURE_TRUE
(
window
nullptr
)
;
if
(
window
)
{
nsCOMPtr
<
nsPIWindowRoot
>
root
=
window
-
>
GetTopWindowRoot
(
)
;
NS_ENSURE_TRUE
(
root
nullptr
)
;
nsCOMPtr
<
nsINode
>
node
=
root
-
>
GetPopupNode
(
)
;
if
(
!
node
)
{
nsPIDOMWindowOuter
*
rootWindow
=
root
-
>
GetWindow
(
)
;
if
(
rootWindow
)
{
nsCOMPtr
<
Document
>
rootDoc
=
rootWindow
-
>
GetExtantDoc
(
)
;
if
(
rootDoc
)
{
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
pm
)
{
node
=
pm
-
>
GetLastTriggerPopupNode
(
rootDoc
)
;
}
}
}
}
return
node
.
forget
(
)
;
}
return
nullptr
;
}
already_AddRefed
<
nsINode
>
nsDocumentViewer
:
:
GetPopupLinkNode
(
)
{
nsCOMPtr
<
nsINode
>
node
=
GetPopupNode
(
)
;
while
(
node
)
{
if
(
const
auto
*
element
=
Element
:
:
FromNode
(
*
node
)
)
{
if
(
element
-
>
IsLink
(
)
)
{
return
node
.
forget
(
)
;
}
}
node
=
node
-
>
GetParentNode
(
)
;
}
return
nullptr
;
}
already_AddRefed
<
nsIImageLoadingContent
>
nsDocumentViewer
:
:
GetPopupImageNode
(
)
{
nsCOMPtr
<
nsINode
>
node
=
GetPopupNode
(
)
;
nsCOMPtr
<
nsIImageLoadingContent
>
img
=
do_QueryInterface
(
node
)
;
return
img
.
forget
(
)
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetInLink
(
bool
*
aInLink
)
{
#
ifdef
DEBUG_dr
printf
(
"
dr
:
:
nsDocumentViewer
:
:
GetInLink
\
n
"
)
;
#
endif
NS_ENSURE_ARG_POINTER
(
aInLink
)
;
*
aInLink
=
false
;
nsCOMPtr
<
nsINode
>
node
=
GetPopupLinkNode
(
)
;
if
(
!
node
)
{
return
NS_ERROR_FAILURE
;
}
*
aInLink
=
true
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetInImage
(
bool
*
aInImage
)
{
#
ifdef
DEBUG_dr
printf
(
"
dr
:
:
nsDocumentViewer
:
:
GetInImage
\
n
"
)
;
#
endif
NS_ENSURE_ARG_POINTER
(
aInImage
)
;
*
aInImage
=
false
;
nsCOMPtr
<
nsIImageLoadingContent
>
node
=
GetPopupImageNode
(
)
;
if
(
!
node
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIURI
>
uri
;
node
-
>
GetCurrentURI
(
getter_AddRefs
(
uri
)
)
;
if
(
uri
)
{
*
aInImage
=
true
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocViewerSelectionListener
:
:
NotifySelectionChanged
(
Document
*
Selection
*
int16_t
aReason
int32_t
aAmount
)
{
if
(
!
mDocViewer
)
{
return
NS_OK
;
}
RefPtr
<
mozilla
:
:
dom
:
:
Selection
>
selection
=
mDocViewer
-
>
GetDocumentSelection
(
)
;
if
(
!
selection
)
{
return
NS_ERROR_FAILURE
;
}
Document
*
theDoc
=
mDocViewer
-
>
GetDocument
(
)
;
if
(
!
theDoc
)
return
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
domWindow
=
theDoc
-
>
GetWindow
(
)
;
if
(
!
domWindow
)
return
NS_ERROR_FAILURE
;
bool
selectionCollapsed
=
selection
-
>
IsCollapsed
(
)
;
if
(
mSelectionWasCollapsed
!
=
selectionCollapsed
)
{
domWindow
-
>
UpdateCommands
(
u
"
select
"
_ns
)
;
mSelectionWasCollapsed
=
selectionCollapsed
;
}
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
nsDocViewerFocusListener
nsIDOMEventListener
)
nsresult
nsDocViewerFocusListener
:
:
HandleEvent
(
Event
*
aEvent
)
{
NS_ENSURE_STATE
(
mDocViewer
)
;
RefPtr
<
PresShell
>
presShell
=
mDocViewer
-
>
GetPresShell
(
)
;
NS_ENSURE_TRUE
(
presShell
NS_ERROR_FAILURE
)
;
RefPtr
<
nsFrameSelection
>
selection
=
presShell
-
>
GetLastFocusedFrameSelection
(
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_FAILURE
)
;
auto
selectionStatus
=
selection
-
>
GetDisplaySelection
(
)
;
nsAutoString
eventType
;
aEvent
-
>
GetType
(
eventType
)
;
if
(
eventType
.
EqualsLiteral
(
"
focus
"
)
)
{
if
(
selectionStatus
=
=
nsISelectionController
:
:
SELECTION_DISABLED
|
|
selectionStatus
=
=
nsISelectionController
:
:
SELECTION_HIDDEN
)
{
selection
-
>
SetDisplaySelection
(
nsISelectionController
:
:
SELECTION_ON
)
;
selection
-
>
RepaintSelection
(
SelectionType
:
:
eNormal
)
;
}
if
(
selection
!
=
presShell
-
>
ConstFrameSelection
(
)
)
{
RefPtr
<
Document
>
doc
=
presShell
-
>
GetDocument
(
)
;
const
bool
selectionMatchesFocus
=
selection
-
>
GetLimiter
(
)
&
&
selection
-
>
GetLimiter
(
)
-
>
GetChromeOnlyAccessSubtreeRootParent
(
)
=
=
doc
-
>
GetUnretargetedFocusedContent
(
)
;
if
(
NS_WARN_IF
(
!
selectionMatchesFocus
)
)
{
presShell
-
>
FrameSelectionWillLoseFocus
(
*
selection
)
;
presShell
-
>
SelectionWillTakeFocus
(
)
;
}
}
}
else
{
MOZ_ASSERT
(
eventType
.
EqualsLiteral
(
"
blur
"
)
"
Unexpected
event
type
"
)
;
if
(
selectionStatus
=
=
nsISelectionController
:
:
SELECTION_ON
|
|
selectionStatus
=
=
nsISelectionController
:
:
SELECTION_ATTENTION
)
{
selection
-
>
SetDisplaySelection
(
nsISelectionController
:
:
SELECTION_DISABLED
)
;
selection
-
>
RepaintSelection
(
SelectionType
:
:
eNormal
)
;
}
}
return
NS_OK
;
}
#
ifdef
NS_PRINTING
NS_IMETHODIMP
nsDocumentViewer
:
:
Print
(
nsIPrintSettings
*
aPrintSettings
RemotePrintJobChild
*
aRemotePrintJob
nsIWebProgressListener
*
aWebProgressListener
)
{
if
(
NS_WARN_IF
(
!
mContainer
)
)
{
PR_PL
(
(
"
Container
was
destroyed
yet
we
are
still
trying
to
use
it
!
"
)
)
;
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
!
mDocument
)
|
|
NS_WARN_IF
(
!
mDeviceContext
)
)
{
PR_PL
(
(
"
Can
'
t
Print
without
a
document
and
a
device
context
"
)
)
;
return
NS_ERROR_FAILURE
;
}
if
(
NS_WARN_IF
(
mPrintJob
&
&
mPrintJob
-
>
GetIsPrinting
(
)
)
)
{
nsresult
rv
=
NS_ERROR_NOT_AVAILABLE
;
RefPtr
<
nsPrintJob
>
(
mPrintJob
)
-
>
FirePrintingErrorEvent
(
rv
)
;
return
rv
;
}
OnDonePrinting
(
)
;
RefPtr
<
nsPrintJob
>
printJob
=
new
nsPrintJob
(
*
this
*
mContainer
*
mDocument
float
(
AppUnitsPerCSSInch
(
)
)
/
float
(
mDeviceContext
-
>
AppUnitsPerDevPixel
(
)
)
)
;
mPrintJob
=
printJob
;
nsresult
rv
=
printJob
-
>
Print
(
*
mDocument
aPrintSettings
aRemotePrintJob
aWebProgressListener
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
OnDonePrinting
(
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
PrintPreview
(
nsIPrintSettings
*
aPrintSettings
nsIWebProgressListener
*
aWebProgressListener
PrintPreviewResolver
&
&
aCallback
)
{
#
ifdef
NS_PRINT_PREVIEW
RefPtr
<
Document
>
doc
=
mDocument
.
get
(
)
;
NS_ENSURE_STATE
(
doc
)
;
if
(
NS_WARN_IF
(
GetIsPrinting
(
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
(
mContainer
)
;
if
(
NS_WARN_IF
(
!
docShell
)
|
|
NS_WARN_IF
(
!
mDeviceContext
)
)
{
PR_PL
(
(
"
Can
'
t
Print
Preview
without
device
context
and
docshell
"
)
)
;
return
NS_ERROR_FAILURE
;
}
NS_ENSURE_STATE
(
!
GetIsPrinting
(
)
)
;
NS_ENSURE_STATE
(
mContainer
)
;
NS_ENSURE_STATE
(
mDeviceContext
)
;
OnDonePrinting
(
)
;
RefPtr
<
nsPrintJob
>
printJob
=
new
nsPrintJob
(
*
this
*
mContainer
*
doc
float
(
AppUnitsPerCSSInch
(
)
)
/
float
(
mDeviceContext
-
>
AppUnitsPerDevPixel
(
)
)
)
;
mPrintJob
=
printJob
;
nsresult
rv
=
printJob
-
>
PrintPreview
(
*
doc
aPrintSettings
aWebProgressListener
std
:
:
move
(
aCallback
)
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
OnDonePrinting
(
)
;
}
return
rv
;
#
else
return
NS_ERROR_FAILURE
;
#
endif
}
static
const
nsIFrame
*
GetTargetPageFrame
(
int32_t
aTargetPageNum
nsPageSequenceFrame
*
aSequenceFrame
)
{
MOZ_ASSERT
(
aTargetPageNum
>
0
&
&
aTargetPageNum
<
=
aSequenceFrame
-
>
PrincipalChildList
(
)
.
GetLength
(
)
)
;
return
aSequenceFrame
-
>
PrincipalChildList
(
)
.
FrameAt
(
aTargetPageNum
-
1
)
;
}
static
nscoord
ScrollPositionForFrame
(
const
nsIFrame
*
aFrame
nsIScrollableFrame
*
aScrollable
float
aPreviewScale
)
{
return
nscoord
(
aPreviewScale
*
aFrame
-
>
GetRect
(
)
.
Center
(
)
.
y
-
float
(
aScrollable
-
>
GetScrollPortRect
(
)
.
height
)
/
2
.
0f
)
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
PrintPreviewScrollToPage
(
int16_t
aType
int32_t
aPageNum
)
{
if
(
!
GetIsPrintPreview
(
)
|
|
mPrintJob
-
>
GetIsCreatingPrintPreview
(
)
)
return
NS_ERROR_FAILURE
;
nsIScrollableFrame
*
sf
=
mPresShell
-
>
GetRootScrollFrameAsScrollable
(
)
;
if
(
!
sf
)
return
NS_OK
;
auto
[
seqFrame
sheetCount
]
=
mPrintJob
-
>
GetSeqFrameAndCountSheets
(
)
;
Unused
<
<
sheetCount
;
if
(
!
seqFrame
)
{
return
NS_ERROR_FAILURE
;
}
float
previewScale
=
seqFrame
-
>
GetPrintPreviewScale
(
)
;
nsPoint
dest
=
sf
-
>
GetScrollPosition
(
)
;
switch
(
aType
)
{
case
nsIWebBrowserPrint
:
:
PRINTPREVIEW_HOME
:
dest
.
y
=
0
;
break
;
case
nsIWebBrowserPrint
:
:
PRINTPREVIEW_END
:
dest
.
y
=
sf
-
>
GetScrollRange
(
)
.
YMost
(
)
;
break
;
case
nsIWebBrowserPrint
:
:
PRINTPREVIEW_PREV_PAGE
:
case
nsIWebBrowserPrint
:
:
PRINTPREVIEW_NEXT_PAGE
:
{
auto
[
currentFrame
currentSheetNumber
]
=
GetCurrentSheetFrameAndNumber
(
)
;
Unused
<
<
currentSheetNumber
;
if
(
!
currentFrame
)
{
return
NS_OK
;
}
const
nsIFrame
*
targetFrame
=
nullptr
;
if
(
aType
=
=
nsIWebBrowserPrint
:
:
PRINTPREVIEW_PREV_PAGE
)
{
targetFrame
=
currentFrame
-
>
GetPrevInFlow
(
)
;
}
else
{
targetFrame
=
currentFrame
-
>
GetNextInFlow
(
)
;
}
if
(
!
targetFrame
)
{
return
NS_OK
;
}
dest
.
y
=
ScrollPositionForFrame
(
targetFrame
sf
previewScale
)
;
break
;
}
case
nsIWebBrowserPrint
:
:
PRINTPREVIEW_GOTO_PAGENUM
:
{
if
(
aPageNum
<
=
0
|
|
aPageNum
>
sheetCount
)
{
return
NS_ERROR_INVALID_ARG
;
}
const
nsIFrame
*
targetFrame
=
GetTargetPageFrame
(
aPageNum
seqFrame
)
;
MOZ_ASSERT
(
targetFrame
)
;
dest
.
y
=
ScrollPositionForFrame
(
targetFrame
sf
previewScale
)
;
break
;
}
default
:
return
NS_ERROR_INVALID_ARG
;
break
;
}
sf
-
>
ScrollTo
(
dest
ScrollMode
:
:
Instant
)
;
return
NS_OK
;
}
std
:
:
tuple
<
const
nsIFrame
*
int32_t
>
nsDocumentViewer
:
:
GetCurrentSheetFrameAndNumber
(
)
const
{
MOZ_ASSERT
(
mPrintJob
)
;
MOZ_ASSERT
(
GetIsPrintPreview
(
)
&
&
!
mPrintJob
-
>
GetIsCreatingPrintPreview
(
)
)
;
auto
[
seqFrame
sheetCount
]
=
mPrintJob
-
>
GetSeqFrameAndCountSheets
(
)
;
Unused
<
<
sheetCount
;
if
(
!
seqFrame
)
{
return
{
nullptr
0
}
;
}
nsIScrollableFrame
*
sf
=
mPresShell
-
>
GetRootScrollFrameAsScrollable
(
)
;
if
(
!
sf
)
{
return
{
seqFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
1
}
;
}
nsPoint
currentScrollPosition
=
sf
-
>
GetScrollPosition
(
)
;
float
halfwayPoint
=
currentScrollPosition
.
y
+
float
(
sf
-
>
GetScrollPortRect
(
)
.
height
)
/
2
.
0f
;
float
lastDistanceFromHalfwayPoint
=
std
:
:
numeric_limits
<
float
>
:
:
max
(
)
;
int32_t
sheetNumber
=
0
;
const
nsIFrame
*
currentSheet
=
nullptr
;
float
previewScale
=
seqFrame
-
>
GetPrintPreviewScale
(
)
;
for
(
const
nsIFrame
*
sheetFrame
:
seqFrame
-
>
PrincipalChildList
(
)
)
{
nsRect
sheetRect
=
sheetFrame
-
>
GetRect
(
)
;
sheetNumber
+
+
;
currentSheet
=
sheetFrame
;
float
bottomOfSheet
=
sheetRect
.
YMost
(
)
*
previewScale
;
if
(
bottomOfSheet
<
halfwayPoint
)
{
lastDistanceFromHalfwayPoint
=
halfwayPoint
-
bottomOfSheet
;
continue
;
}
float
topOfSheet
=
sheetRect
.
Y
(
)
*
previewScale
;
if
(
topOfSheet
<
=
halfwayPoint
)
{
break
;
}
if
(
(
topOfSheet
-
halfwayPoint
)
>
=
lastDistanceFromHalfwayPoint
)
{
sheetNumber
-
-
;
MOZ_ASSERT
(
sheetNumber
>
0
)
;
currentSheet
=
currentSheet
-
>
GetPrevInFlow
(
)
;
MOZ_ASSERT
(
currentSheet
)
;
}
break
;
}
MOZ_ASSERT
(
sheetNumber
<
=
sheetCount
)
;
return
{
currentSheet
sheetNumber
}
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetPrintPreviewCurrentPageNumber
(
int32_t
*
aNumber
)
{
NS_ENSURE_ARG_POINTER
(
aNumber
)
;
NS_ENSURE_TRUE
(
mPrintJob
NS_ERROR_FAILURE
)
;
if
(
!
GetIsPrintPreview
(
)
|
|
mPrintJob
-
>
GetIsCreatingPrintPreview
(
)
)
{
return
NS_ERROR_FAILURE
;
}
auto
[
currentFrame
currentSheetNumber
]
=
GetCurrentSheetFrameAndNumber
(
)
;
Unused
<
<
currentFrame
;
if
(
!
currentSheetNumber
)
{
return
NS_ERROR_FAILURE
;
}
*
aNumber
=
currentSheetNumber
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetDoingPrint
(
bool
*
aDoingPrint
)
{
NS_ENSURE_ARG_POINTER
(
aDoingPrint
)
;
*
aDoingPrint
=
mPrintJob
?
mPrintJob
-
>
CreatedForPrintPreview
(
)
:
false
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetDoingPrintPreview
(
bool
*
aDoingPrintPreview
)
{
NS_ENSURE_ARG_POINTER
(
aDoingPrintPreview
)
;
*
aDoingPrintPreview
=
mPrintJob
?
mPrintJob
-
>
CreatedForPrintPreview
(
)
:
false
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetCloseWindowAfterPrint
(
bool
*
aCloseWindowAfterPrint
)
{
NS_ENSURE_ARG_POINTER
(
aCloseWindowAfterPrint
)
;
*
aCloseWindowAfterPrint
=
mCloseWindowAfterPrint
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
SetCloseWindowAfterPrint
(
bool
aCloseWindowAfterPrint
)
{
mCloseWindowAfterPrint
=
aCloseWindowAfterPrint
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
ExitPrintPreview
(
)
{
NS_ENSURE_TRUE
(
mPrintJob
NS_ERROR_FAILURE
)
;
if
(
GetIsPrinting
(
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
GetIsPrintPreview
(
)
)
{
NS_ERROR
(
"
Wow
we
should
never
get
here
!
"
)
;
return
NS_OK
;
}
#
ifdef
NS_PRINT_PREVIEW
mPrintJob
-
>
Destroy
(
)
;
mPrintJob
=
nullptr
;
#
endif
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetRawNumPages
(
int32_t
*
aRawNumPages
)
{
NS_ENSURE_ARG_POINTER
(
aRawNumPages
)
;
NS_ENSURE_TRUE
(
mPrintJob
NS_ERROR_FAILURE
)
;
*
aRawNumPages
=
mPrintJob
-
>
GetRawNumPages
(
)
;
return
*
aRawNumPages
>
0
?
NS_OK
:
NS_ERROR_FAILURE
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetPrintPreviewNumPages
(
int32_t
*
aPrintPreviewNumPages
)
{
NS_ENSURE_ARG_POINTER
(
aPrintPreviewNumPages
)
;
NS_ENSURE_TRUE
(
mPrintJob
NS_ERROR_FAILURE
)
;
*
aPrintPreviewNumPages
=
mPrintJob
-
>
GetPrintPreviewNumSheets
(
)
;
return
*
aPrintPreviewNumPages
>
0
?
NS_OK
:
NS_ERROR_FAILURE
;
}
#
endif
bool
nsDocumentViewer
:
:
ShouldAttachToTopLevel
(
)
{
if
(
!
mParentWidget
)
{
return
false
;
}
if
(
nsIWidget
:
:
UsePuppetWidgets
(
)
)
{
return
true
;
}
#
ifdef
XP_MACOSX
return
false
;
#
else
#
ifdef
DEBUG
nsIWidgetListener
*
parentListener
=
mParentWidget
-
>
GetWidgetListener
(
)
;
MOZ_ASSERT
(
!
parentListener
|
|
!
parentListener
-
>
GetView
(
)
"
Expect
a
top
level
widget
"
)
;
#
endif
return
true
;
#
endif
}
bool
nsDocumentViewer
:
:
GetIsPrinting
(
)
const
{
#
ifdef
NS_PRINTING
if
(
mPrintJob
)
{
return
mPrintJob
-
>
GetIsPrinting
(
)
;
}
#
endif
return
false
;
}
bool
nsDocumentViewer
:
:
GetIsPrintPreview
(
)
const
{
#
ifdef
NS_PRINTING
return
mPrintJob
&
&
mPrintJob
-
>
CreatedForPrintPreview
(
)
;
#
else
return
false
;
#
endif
}
void
nsDocumentViewer
:
:
SetIsPrintPreview
(
bool
aIsPrintPreview
)
{
nsAutoScriptBlocker
scriptBlocker
;
if
(
!
aIsPrintPreview
)
{
InvalidatePotentialSubDocDisplayItem
(
)
;
if
(
mPresShell
)
{
DestroyPresShell
(
)
;
}
mWindow
=
nullptr
;
mViewManager
=
nullptr
;
mPresContext
=
nullptr
;
mPresShell
=
nullptr
;
}
}
void
nsDocumentViewer
:
:
IncrementDestroyBlockedCount
(
)
{
+
+
mDestroyBlockedCount
;
}
void
nsDocumentViewer
:
:
DecrementDestroyBlockedCount
(
)
{
-
-
mDestroyBlockedCount
;
}
void
nsDocumentViewer
:
:
OnDonePrinting
(
)
{
#
if
defined
(
NS_PRINTING
)
&
&
defined
(
NS_PRINT_PREVIEW
)
if
(
mPrintJob
)
{
RefPtr
<
nsPrintJob
>
printJob
=
std
:
:
move
(
mPrintJob
)
;
if
(
GetIsPrintPreview
(
)
)
{
printJob
-
>
DestroyPrintingData
(
)
;
}
else
{
printJob
-
>
Destroy
(
)
;
}
#
ifdef
ANDROID
bool
closeWindowAfterPrint
=
!
printJob
-
>
CreatedForPrintPreview
(
)
;
#
else
bool
closeWindowAfterPrint
=
GetCloseWindowAfterPrint
(
)
;
#
endif
if
(
closeWindowAfterPrint
)
{
if
(
mContainer
)
{
if
(
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
=
mContainer
-
>
GetWindow
(
)
)
{
win
-
>
Close
(
)
;
}
}
}
else
if
(
mClosingWhilePrinting
)
{
if
(
mDocument
)
{
mDocument
-
>
Destroy
(
)
;
mDocument
=
nullptr
;
}
mClosingWhilePrinting
=
false
;
}
}
#
endif
}
NS_IMETHODIMP
nsDocumentViewer
:
:
SetPrintSettingsForSubdocument
(
nsIPrintSettings
*
aPrintSettings
RemotePrintJobChild
*
aRemotePrintJob
)
{
#
ifdef
NS_PRINTING
{
nsAutoScriptBlocker
scriptBlocker
;
if
(
mPresShell
)
{
DestroyPresShell
(
)
;
}
if
(
mPresContext
)
{
DestroyPresContext
(
)
;
}
MOZ_ASSERT
(
!
mPresContext
)
;
MOZ_ASSERT
(
!
mPresShell
)
;
if
(
MOZ_UNLIKELY
(
!
mDocument
)
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
RefPtr
<
nsDeviceContextSpecProxy
>
devspec
=
new
nsDeviceContextSpecProxy
(
aRemotePrintJob
)
;
nsresult
rv
=
devspec
-
>
Init
(
aPrintSettings
true
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mDeviceContext
=
new
nsDeviceContext
(
)
;
rv
=
mDeviceContext
-
>
InitForPrinting
(
devspec
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mPresContext
=
CreatePresContext
(
mDocument
nsPresContext
:
:
eContext_PrintPreview
FindContainerView
(
)
)
;
mPresContext
-
>
SetPrintSettings
(
aPrintSettings
)
;
rv
=
mPresContext
-
>
Init
(
mDeviceContext
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
MakeWindow
(
nsSize
(
mPresContext
-
>
DevPixelsToAppUnits
(
mBounds
.
width
)
mPresContext
-
>
DevPixelsToAppUnits
(
mBounds
.
height
)
)
FindContainerView
(
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
MOZ_TRY
(
InitPresentationStuff
(
true
)
)
;
}
RefPtr
<
PresShell
>
shell
=
mPresShell
;
shell
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
#
endif
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
SetPageModeForTesting
(
bool
aPageMode
nsIPrintSettings
*
aPrintSettings
)
{
mIsPageMode
=
aPageMode
;
nsAutoScriptBlocker
scriptBlocker
;
if
(
mPresShell
)
{
DestroyPresShell
(
)
;
}
if
(
mPresContext
)
{
DestroyPresContext
(
)
;
}
mViewManager
=
nullptr
;
mWindow
=
nullptr
;
NS_ENSURE_STATE
(
mDocument
)
;
if
(
aPageMode
)
{
mPresContext
=
CreatePresContext
(
mDocument
nsPresContext
:
:
eContext_PageLayout
FindContainerView
(
)
)
;
NS_ENSURE_TRUE
(
mPresContext
NS_ERROR_OUT_OF_MEMORY
)
;
mPresContext
-
>
SetPaginatedScrolling
(
true
)
;
mPresContext
-
>
SetPrintSettings
(
aPrintSettings
)
;
nsresult
rv
=
mPresContext
-
>
Init
(
mDeviceContext
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
NS_ENSURE_SUCCESS
(
InitInternal
(
mParentWidget
nullptr
nullptr
mBounds
true
false
false
)
NS_ERROR_FAILURE
)
;
Show
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetHistoryEntry
(
nsISHEntry
*
*
aHistoryEntry
)
{
NS_IF_ADDREF
(
*
aHistoryEntry
=
mSHEntry
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetIsTabModalPromptAllowed
(
bool
*
aAllowed
)
{
*
aAllowed
=
!
mHidden
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetIsHidden
(
bool
*
aHidden
)
{
*
aHidden
=
mHidden
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
SetIsHidden
(
bool
aHidden
)
{
mHidden
=
aHidden
;
return
NS_OK
;
}
void
nsDocumentViewer
:
:
DestroyPresShell
(
)
{
MOZ_ASSERT
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
DestroyPresShell
must
only
be
called
when
scripts
are
blocked
"
)
;
mPresShell
-
>
EndObservingDocument
(
)
;
RefPtr
<
mozilla
:
:
dom
:
:
Selection
>
selection
=
GetDocumentSelection
(
)
;
if
(
selection
&
&
mSelectionListener
)
selection
-
>
RemoveSelectionListener
(
mSelectionListener
)
;
mPresShell
-
>
Destroy
(
)
;
mPresShell
=
nullptr
;
}
void
nsDocumentViewer
:
:
InvalidatePotentialSubDocDisplayItem
(
)
{
if
(
mViewManager
)
{
if
(
nsView
*
rootView
=
mViewManager
-
>
GetRootView
(
)
)
{
if
(
nsView
*
rootViewParent
=
rootView
-
>
GetParent
(
)
)
{
if
(
nsView
*
subdocview
=
rootViewParent
-
>
GetParent
(
)
)
{
if
(
nsIFrame
*
f
=
subdocview
-
>
GetFrame
(
)
)
{
if
(
nsSubDocumentFrame
*
s
=
do_QueryFrame
(
f
)
)
{
s
-
>
MarkNeedsDisplayItemRebuild
(
)
;
}
}
}
}
}
}
}
void
nsDocumentViewer
:
:
DestroyPresContext
(
)
{
InvalidatePotentialSubDocDisplayItem
(
)
;
mPresContext
=
nullptr
;
}
void
nsDocumentViewer
:
:
SetPrintPreviewPresentation
(
nsViewManager
*
aViewManager
nsPresContext
*
aPresContext
PresShell
*
aPresShell
)
{
nsAutoScriptBlocker
scriptBlocker
;
if
(
mPresShell
)
{
DestroyPresShell
(
)
;
}
mWindow
=
nullptr
;
mViewManager
=
aViewManager
;
mPresContext
=
aPresContext
;
mPresShell
=
aPresShell
;
if
(
ShouldAttachToTopLevel
(
)
)
{
DetachFromTopLevelWidget
(
)
;
nsView
*
rootView
=
mViewManager
-
>
GetRootView
(
)
;
rootView
-
>
AttachToTopLevelWidget
(
mParentWidget
)
;
mAttachedToParent
=
true
;
}
}
NS_IMETHODIMP
nsDocumentShownDispatcher
:
:
Run
(
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
NotifyObservers
(
ToSupports
(
mDocument
)
"
document
-
shown
"
nullptr
)
;
}
return
NS_OK
;
}
