#
include
"
gfxContext
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
nscore
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentViewer
.
h
"
#
include
"
nsIDocumentViewerPrint
.
h
"
#
include
"
mozilla
/
dom
/
BeforeUnloadEvent
.
h
"
#
include
"
mozilla
/
dom
/
PopupBlocker
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIWritablePropertyBag2
.
h
"
#
include
"
nsSubDocumentFrame
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsStubMutationObserver
.
h
"
#
include
"
nsILinkHandler
.
h
"
#
include
"
nsISelectionListener
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsLayoutStylesheetCache
.
h
"
#
ifdef
ACCESSIBILITY
#
include
"
mozilla
/
a11y
/
DocAccessible
.
h
"
#
endif
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
Encoding
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
mozilla
/
StyleSheet
.
h
"
#
include
"
mozilla
/
StyleSheetInlines
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsView
.
h
"
#
include
"
nsIPageSequenceFrame
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsIContentViewerEdit
.
h
"
#
include
"
mozilla
/
css
/
Loader
.
h
"
#
include
"
nsIInterfaceRequestor
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsIBaseWindow
.
h
"
#
include
"
nsILayoutHistoryState
.
h
"
#
include
"
nsCharsetSource
.
h
"
#
include
"
mozilla
/
ReflowInput
.
h
"
#
include
"
nsIImageLoadingContent
.
h
"
#
include
"
nsCopySupport
.
h
"
#
ifdef
MOZ_XUL
#
include
"
nsXULPopupManager
.
h
"
#
endif
#
include
"
nsIClipboardHelper
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsGlobalWindow
.
h
"
#
include
"
nsDOMNavigationTiming
.
h
"
#
include
"
nsPIWindowRoot
.
h
"
#
include
"
nsJSEnvironment
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsStyleSheetService
.
h
"
#
include
"
nsILoadContext
.
h
"
#
include
"
nsIPrompt
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
nsSandboxFlags
.
h
"
#
include
"
mozilla
/
DocLoadingTimelineMarker
.
h
"
#
ifdef
NS_PRINTING
#
include
"
nsIWebBrowserPrint
.
h
"
#
include
"
nsPrintJob
.
h
"
#
include
"
nsIPrintSettings
.
h
"
#
include
"
nsIPrintSettingsService
.
h
"
#
include
"
nsISimpleEnumerator
.
h
"
#
include
"
nsIPluginDocument
.
h
"
#
endif
#
include
"
nsIDOMEventListener
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
nsISHEntry
.
h
"
#
include
"
nsISHistory
.
h
"
#
include
"
nsIWebNavigation
.
h
"
#
include
"
mozilla
/
dom
/
XMLHttpRequestMainThread
.
h
"
#
include
<
stdio
.
h
>
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
dom
/
ScriptLoader
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
#
define
BEFOREUNLOAD_DISABLED_PREFNAME
"
dom
.
disable_beforeunload
"
#
define
BEFOREUNLOAD_REQUIRES_INTERACTION_PREFNAME
\
"
dom
.
require_user_interaction_for_beforeunload
"
#
include
"
LayoutLogging
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
ifdef
NS_PRINTING
static
mozilla
:
:
LazyLogModule
gPrintingLog
(
"
printing
"
)
;
#
define
PR_PL
(
_p1
)
MOZ_LOG
(
gPrintingLog
mozilla
:
:
LogLevel
:
:
Debug
_p1
)
;
#
endif
#
define
PRT_YESNO
(
_p
)
(
(
_p
)
?
"
YES
"
:
"
NO
"
)
class
nsDocumentViewer
;
namespace
mozilla
{
class
AutoPrintEventDispatcher
;
}
class
nsDocViewerSelectionListener
final
:
public
nsISelectionListener
{
public
:
NS_DECL_ISUPPORTS
NS_DECL_NSISELECTIONLISTENER
nsDocViewerSelectionListener
(
)
:
mDocViewer
(
nullptr
)
mSelectionWasCollapsed
(
true
)
{
}
nsresult
Init
(
nsDocumentViewer
*
aDocViewer
)
;
void
Disconnect
(
)
{
mDocViewer
=
nullptr
;
}
protected
:
virtual
~
nsDocViewerSelectionListener
(
)
{
}
nsDocumentViewer
*
mDocViewer
;
bool
mSelectionWasCollapsed
;
}
;
class
nsDocViewerFocusListener
final
:
public
nsIDOMEventListener
{
public
:
nsDocViewerFocusListener
(
)
;
NS_DECL_ISUPPORTS
NS_DECL_NSIDOMEVENTLISTENER
nsresult
Init
(
nsDocumentViewer
*
aDocViewer
)
;
void
Disconnect
(
)
{
mDocViewer
=
nullptr
;
}
protected
:
virtual
~
nsDocViewerFocusListener
(
)
;
private
:
nsDocumentViewer
*
mDocViewer
;
}
;
namespace
viewer_detail
{
class
BFCachePreventionObserver
final
:
public
nsStubMutationObserver
{
public
:
explicit
BFCachePreventionObserver
(
Document
*
aDocument
)
:
mDocument
(
aDocument
)
{
}
NS_DECL_ISUPPORTS
NS_DECL_NSIMUTATIONOBSERVER_CHARACTERDATACHANGED
NS_DECL_NSIMUTATIONOBSERVER_ATTRIBUTECHANGED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTAPPENDED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTINSERTED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTREMOVED
NS_DECL_NSIMUTATIONOBSERVER_NODEWILLBEDESTROYED
void
Disconnect
(
)
;
private
:
~
BFCachePreventionObserver
(
)
=
default
;
void
MutationHappened
(
)
;
Document
*
mDocument
;
}
;
NS_IMPL_ISUPPORTS
(
BFCachePreventionObserver
nsIMutationObserver
)
void
BFCachePreventionObserver
:
:
CharacterDataChanged
(
nsIContent
*
aContent
const
CharacterDataChangeInfo
&
)
{
MutationHappened
(
)
;
}
void
BFCachePreventionObserver
:
:
AttributeChanged
(
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
const
nsAttrValue
*
aOldValue
)
{
MutationHappened
(
)
;
}
void
BFCachePreventionObserver
:
:
ContentAppended
(
nsIContent
*
aFirstNewContent
)
{
MutationHappened
(
)
;
}
void
BFCachePreventionObserver
:
:
ContentInserted
(
nsIContent
*
aChild
)
{
MutationHappened
(
)
;
}
void
BFCachePreventionObserver
:
:
ContentRemoved
(
nsIContent
*
aChild
nsIContent
*
aPreviousSibling
)
{
MutationHappened
(
)
;
}
void
BFCachePreventionObserver
:
:
NodeWillBeDestroyed
(
const
nsINode
*
aNode
)
{
mDocument
=
nullptr
;
}
void
BFCachePreventionObserver
:
:
Disconnect
(
)
{
if
(
mDocument
)
{
mDocument
-
>
RemoveMutationObserver
(
this
)
;
mDocument
=
nullptr
;
}
}
void
BFCachePreventionObserver
:
:
MutationHappened
(
)
{
MOZ_ASSERT
(
mDocument
"
How
can
we
not
have
a
document
but
be
getting
notified
for
mutations
?
"
)
;
mDocument
-
>
DisallowBFCaching
(
)
;
Disconnect
(
)
;
}
}
using
viewer_detail
:
:
BFCachePreventionObserver
;
class
nsDocumentViewer
final
:
public
nsIContentViewer
public
nsIContentViewerEdit
public
nsIDocumentViewerPrint
#
ifdef
NS_PRINTING
public
nsIWebBrowserPrint
#
endif
{
friend
class
nsDocViewerSelectionListener
;
friend
class
nsPagePrintTimer
;
friend
class
nsPrintJob
;
public
:
nsDocumentViewer
(
)
;
NS_DECL_ISUPPORTS
NS_DECL_NSICONTENTVIEWER
NS_DECL_NSICONTENTVIEWEREDIT
#
ifdef
NS_PRINTING
NS_DECL_NSIWEBBROWSERPRINT
#
endif
typedef
void
(
*
CallChildFunc
)
(
nsIContentViewer
*
aViewer
void
*
aClosure
)
;
void
CallChildren
(
CallChildFunc
aFunc
void
*
aClosure
)
;
NS_DECL_NSIDOCUMENTVIEWERPRINT
protected
:
virtual
~
nsDocumentViewer
(
)
;
private
:
nsresult
MakeWindow
(
const
nsSize
&
aSize
nsView
*
aContainerView
)
;
nsresult
CreateDeviceContext
(
nsView
*
aContainerView
)
;
nsresult
InitInternal
(
nsIWidget
*
aParentWidget
nsISupports
*
aState
const
nsIntRect
&
aBounds
bool
aDoCreation
bool
aNeedMakeCX
=
true
bool
aForceSetNewDocument
=
true
)
;
nsresult
InitPresentationStuff
(
bool
aDoInitialReflow
)
;
already_AddRefed
<
nsINode
>
GetPopupNode
(
)
;
already_AddRefed
<
nsINode
>
GetPopupLinkNode
(
)
;
already_AddRefed
<
nsIImageLoadingContent
>
GetPopupImageNode
(
)
;
nsresult
GetContentSizeInternal
(
int32_t
*
aWidth
int32_t
*
aHeight
nscoord
aMaxWidth
nscoord
aMaxHeight
)
;
void
PrepareToStartLoad
(
void
)
;
nsresult
SyncParentSubDocMap
(
)
;
mozilla
:
:
dom
:
:
Selection
*
GetDocumentSelection
(
)
;
void
DestroyPresShell
(
)
;
void
DestroyPresContext
(
)
;
#
ifdef
NS_PRINTING
void
SetIsPrintingInDocShellTree
(
nsIDocShellTreeItem
*
aParentNode
bool
aIsPrintingOrPP
bool
aStartAtTop
)
;
#
endif
void
ReturnToGalleyPresentation
(
)
;
bool
ShouldAttachToTopLevel
(
)
;
protected
:
nsViewManager
*
GetViewManager
(
)
;
void
DetachFromTopLevelWidget
(
)
;
WeakPtr
<
nsDocShell
>
mContainer
;
nsWeakPtr
mTopContainerWhilePrinting
;
RefPtr
<
nsDeviceContext
>
mDeviceContext
;
nsCOMPtr
<
Document
>
mDocument
;
nsCOMPtr
<
nsIWidget
>
mWindow
;
RefPtr
<
nsViewManager
>
mViewManager
;
RefPtr
<
nsPresContext
>
mPresContext
;
nsCOMPtr
<
nsIPresShell
>
mPresShell
;
RefPtr
<
nsDocViewerSelectionListener
>
mSelectionListener
;
RefPtr
<
nsDocViewerFocusListener
>
mFocusListener
;
nsCOMPtr
<
nsIContentViewer
>
mPreviousViewer
;
nsCOMPtr
<
nsISHEntry
>
mSHEntry
;
RefPtr
<
BFCachePreventionObserver
>
mBFCachePreventionObserver
;
nsIWidget
*
mParentWidget
;
bool
mAttachedToParent
;
nsIntRect
mBounds
;
float
mTextZoom
;
float
mPageZoom
;
float
mOverrideDPPX
;
int16_t
mNumURLStarts
;
int16_t
mDestroyBlockedCount
;
unsigned
mStopped
:
1
;
unsigned
mLoaded
:
1
;
unsigned
mDeferredWindowClose
:
1
;
unsigned
mIsSticky
:
1
;
unsigned
mInPermitUnload
:
1
;
unsigned
mInPermitUnloadPrompt
:
1
;
#
ifdef
NS_PRINTING
unsigned
mClosingWhilePrinting
:
1
;
#
if
NS_PRINT_PREVIEW
unsigned
mPrintPreviewZoomed
:
1
;
unsigned
mPrintIsPending
:
1
;
unsigned
mPrintDocIsFullyLoaded
:
1
;
nsCOMPtr
<
nsIPrintSettings
>
mCachedPrintSettings
;
nsCOMPtr
<
nsIWebProgressListener
>
mCachedPrintWebProgressListner
;
RefPtr
<
nsPrintJob
>
mPrintJob
;
float
mOriginalPrintPreviewScale
;
float
mPrintPreviewZoom
;
UniquePtr
<
AutoPrintEventDispatcher
>
mAutoBeforeAndAfterPrint
;
#
endif
#
endif
int32_t
mHintCharsetSource
;
const
Encoding
*
mHintCharset
;
const
Encoding
*
mForceCharacterSet
;
bool
mIsPageMode
;
bool
mInitializedForPrintPreview
;
bool
mHidden
;
}
;
namespace
mozilla
{
class
AutoPrintEventDispatcher
{
public
:
explicit
AutoPrintEventDispatcher
(
Document
*
aTop
)
:
mTop
(
aTop
)
{
DispatchEventToWindowTree
(
NS_LITERAL_STRING
(
"
beforeprint
"
)
)
;
}
~
AutoPrintEventDispatcher
(
)
{
DispatchEventToWindowTree
(
NS_LITERAL_STRING
(
"
afterprint
"
)
)
;
}
private
:
void
DispatchEventToWindowTree
(
const
nsAString
&
aEvent
)
{
nsTArray
<
nsCOMPtr
<
Document
>
>
targets
;
CollectDocuments
(
mTop
&
targets
)
;
for
(
nsCOMPtr
<
Document
>
&
doc
:
targets
)
{
nsContentUtils
:
:
DispatchTrustedEvent
(
doc
doc
-
>
GetWindow
(
)
aEvent
CanBubble
:
:
eNo
Cancelable
:
:
eNo
nullptr
)
;
}
}
static
bool
CollectDocuments
(
Document
*
aDocument
void
*
aData
)
{
if
(
aDocument
)
{
static_cast
<
nsTArray
<
nsCOMPtr
<
Document
>
>
*
>
(
aData
)
-
>
AppendElement
(
aDocument
)
;
aDocument
-
>
EnumerateSubDocuments
(
CollectDocuments
aData
)
;
}
return
true
;
}
nsCOMPtr
<
Document
>
mTop
;
}
;
}
class
nsDocumentShownDispatcher
:
public
Runnable
{
public
:
explicit
nsDocumentShownDispatcher
(
nsCOMPtr
<
Document
>
aDocument
)
:
Runnable
(
"
nsDocumentShownDispatcher
"
)
mDocument
(
aDocument
)
{
}
NS_IMETHOD
Run
(
)
override
;
private
:
nsCOMPtr
<
Document
>
mDocument
;
}
;
already_AddRefed
<
nsIContentViewer
>
NS_NewContentViewer
(
)
{
RefPtr
<
nsDocumentViewer
>
viewer
=
new
nsDocumentViewer
(
)
;
return
viewer
.
forget
(
)
;
}
void
nsDocumentViewer
:
:
PrepareToStartLoad
(
)
{
mStopped
=
false
;
mLoaded
=
false
;
mAttachedToParent
=
false
;
mDeferredWindowClose
=
false
;
#
ifdef
NS_PRINTING
mPrintIsPending
=
false
;
mPrintDocIsFullyLoaded
=
false
;
mClosingWhilePrinting
=
false
;
if
(
mPrintJob
)
{
mPrintJob
-
>
Destroy
(
)
;
mPrintJob
=
nullptr
;
#
ifdef
NS_PRINT_PREVIEW
SetIsPrintPreview
(
false
)
;
#
endif
}
#
endif
}
nsDocumentViewer
:
:
nsDocumentViewer
(
)
:
mParentWidget
(
nullptr
)
mAttachedToParent
(
false
)
mTextZoom
(
1
.
0
)
mPageZoom
(
1
.
0
)
mOverrideDPPX
(
0
.
0
)
mNumURLStarts
(
0
)
mDestroyBlockedCount
(
0
)
mStopped
(
false
)
mLoaded
(
false
)
mDeferredWindowClose
(
false
)
mIsSticky
(
true
)
mInPermitUnload
(
false
)
mInPermitUnloadPrompt
(
false
)
#
ifdef
NS_PRINTING
mClosingWhilePrinting
(
false
)
#
if
NS_PRINT_PREVIEW
mPrintPreviewZoomed
(
false
)
mPrintIsPending
(
false
)
mPrintDocIsFullyLoaded
(
false
)
mOriginalPrintPreviewScale
(
0
.
0
)
mPrintPreviewZoom
(
1
.
0
)
#
endif
#
endif
mHintCharsetSource
(
kCharsetUninitialized
)
mHintCharset
(
nullptr
)
mForceCharacterSet
(
nullptr
)
mIsPageMode
(
false
)
mInitializedForPrintPreview
(
false
)
mHidden
(
false
)
{
PrepareToStartLoad
(
)
;
}
NS_IMPL_ADDREF
(
nsDocumentViewer
)
NS_IMPL_RELEASE
(
nsDocumentViewer
)
NS_INTERFACE_MAP_BEGIN
(
nsDocumentViewer
)
NS_INTERFACE_MAP_ENTRY
(
nsIContentViewer
)
NS_INTERFACE_MAP_ENTRY
(
nsIContentViewerEdit
)
NS_INTERFACE_MAP_ENTRY
(
nsIDocumentViewerPrint
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsIContentViewer
)
#
ifdef
NS_PRINTING
NS_INTERFACE_MAP_ENTRY
(
nsIWebBrowserPrint
)
#
endif
NS_INTERFACE_MAP_END
nsDocumentViewer
:
:
~
nsDocumentViewer
(
)
{
if
(
mDocument
)
{
Close
(
nullptr
)
;
mDocument
-
>
Destroy
(
)
;
}
if
(
mPrintJob
)
{
mPrintJob
-
>
Destroy
(
)
;
mPrintJob
=
nullptr
;
}
MOZ_RELEASE_ASSERT
(
mDestroyBlockedCount
=
=
0
)
;
NS_ASSERTION
(
!
mPresShell
&
&
!
mPresContext
"
User
did
not
call
nsIContentViewer
:
:
Destroy
"
)
;
if
(
mPresShell
|
|
mPresContext
)
{
mSHEntry
=
nullptr
;
Destroy
(
)
;
}
if
(
mSelectionListener
)
{
mSelectionListener
-
>
Disconnect
(
)
;
}
if
(
mFocusListener
)
{
mFocusListener
-
>
Disconnect
(
)
;
}
}
void
nsDocumentViewer
:
:
LoadStart
(
Document
*
aDocument
)
{
MOZ_ASSERT
(
aDocument
)
;
if
(
!
mDocument
)
{
mDocument
=
aDocument
;
}
}
nsresult
nsDocumentViewer
:
:
SyncParentSubDocMap
(
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
(
mContainer
)
;
if
(
!
docShell
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
pwin
(
docShell
-
>
GetWindow
(
)
)
;
if
(
!
mDocument
|
|
!
pwin
)
{
return
NS_OK
;
}
nsCOMPtr
<
Element
>
element
=
pwin
-
>
GetFrameElementInternal
(
)
;
if
(
!
element
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
parent
;
docShell
-
>
GetParent
(
getter_AddRefs
(
parent
)
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
parent_win
=
parent
?
parent
-
>
GetWindow
(
)
:
nullptr
;
if
(
!
parent_win
)
{
return
NS_OK
;
}
nsCOMPtr
<
Document
>
parent_doc
=
parent_win
-
>
GetDoc
(
)
;
if
(
!
parent_doc
)
{
return
NS_OK
;
}
if
(
mDocument
&
&
parent_doc
-
>
GetSubDocumentFor
(
element
)
!
=
mDocument
&
&
parent_doc
-
>
EventHandlingSuppressed
(
)
)
{
mDocument
-
>
SuppressEventHandling
(
parent_doc
-
>
EventHandlingSuppressed
(
)
)
;
}
return
parent_doc
-
>
SetSubDocumentFor
(
element
mDocument
)
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
SetContainer
(
nsIDocShell
*
aContainer
)
{
mContainer
=
static_cast
<
nsDocShell
*
>
(
aContainer
)
;
if
(
mPresContext
)
{
mPresContext
-
>
SetContainer
(
mContainer
)
;
}
return
SyncParentSubDocMap
(
)
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetContainer
(
nsIDocShell
*
*
aResult
)
{
NS_ENSURE_ARG_POINTER
(
aResult
)
;
nsCOMPtr
<
nsIDocShell
>
container
(
mContainer
)
;
container
.
swap
(
*
aResult
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
Init
(
nsIWidget
*
aParentWidget
const
nsIntRect
&
aBounds
)
{
return
InitInternal
(
aParentWidget
nullptr
aBounds
true
)
;
}
nsresult
nsDocumentViewer
:
:
InitPresentationStuff
(
bool
aDoInitialReflow
)
{
MOZ_ASSERT
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
InitPresentationStuff
must
only
be
called
when
scripts
are
"
"
blocked
"
)
;
if
(
GetIsPrintPreview
(
)
)
return
NS_OK
;
NS_ASSERTION
(
!
mPresShell
"
Someone
should
have
destroyed
the
presshell
!
"
)
;
UniquePtr
<
ServoStyleSet
>
styleSet
=
CreateStyleSet
(
mDocument
)
;
mPresShell
=
mDocument
-
>
CreateShell
(
mPresContext
mViewManager
std
:
:
move
(
styleSet
)
)
;
if
(
!
mPresShell
)
{
return
NS_ERROR_FAILURE
;
}
if
(
aDoInitialReflow
)
{
mDocument
-
>
FlushPendingNotifications
(
FlushType
:
:
ContentAndNotify
)
;
}
mPresShell
-
>
BeginObservingDocument
(
)
;
int32_t
p2a
=
mPresContext
-
>
AppUnitsPerDevPixel
(
)
;
MOZ_ASSERT
(
p2a
=
=
mPresContext
-
>
DeviceContext
(
)
-
>
AppUnitsPerDevPixelAtUnitFullZoom
(
)
)
;
{
nscoord
width
=
p2a
*
mBounds
.
width
;
nscoord
height
=
p2a
*
mBounds
.
height
;
mViewManager
-
>
SetWindowDimensions
(
width
height
)
;
mPresContext
-
>
SetVisibleArea
(
nsRect
(
0
0
width
height
)
)
;
mPresContext
-
>
SetTextZoom
(
mTextZoom
)
;
mPresContext
-
>
SetFullZoom
(
mPageZoom
)
;
mPresContext
-
>
SetOverrideDPPX
(
mOverrideDPPX
)
;
}
p2a
=
mPresContext
-
>
AppUnitsPerDevPixel
(
)
;
if
(
aDoInitialReflow
)
{
nsCOMPtr
<
nsIPresShell
>
shell
=
mPresShell
;
shell
-
>
Initialize
(
)
;
}
if
(
!
mSelectionListener
)
{
nsDocViewerSelectionListener
*
selectionListener
=
new
nsDocViewerSelectionListener
(
)
;
selectionListener
-
>
Init
(
this
)
;
mSelectionListener
=
selectionListener
;
}
RefPtr
<
mozilla
:
:
dom
:
:
Selection
>
selection
=
GetDocumentSelection
(
)
;
if
(
!
selection
)
{
return
NS_ERROR_FAILURE
;
}
selection
-
>
AddSelectionListener
(
mSelectionListener
)
;
RefPtr
<
nsDocViewerFocusListener
>
oldFocusListener
=
mFocusListener
;
if
(
oldFocusListener
)
{
oldFocusListener
-
>
Disconnect
(
)
;
}
nsDocViewerFocusListener
*
focusListener
=
new
nsDocViewerFocusListener
(
)
;
focusListener
-
>
Init
(
this
)
;
mFocusListener
=
focusListener
;
if
(
mDocument
)
{
mDocument
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
focus
"
)
mFocusListener
false
false
)
;
mDocument
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
blur
"
)
mFocusListener
false
false
)
;
if
(
oldFocusListener
)
{
mDocument
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
focus
"
)
oldFocusListener
false
)
;
mDocument
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
blur
"
)
oldFocusListener
false
)
;
}
}
if
(
aDoInitialReflow
&
&
mDocument
)
{
mDocument
-
>
ScrollToRef
(
)
;
}
return
NS_OK
;
}
static
nsPresContext
*
CreatePresContext
(
Document
*
aDocument
nsPresContext
:
:
nsPresContextType
aType
nsView
*
aContainerView
)
{
if
(
aContainerView
)
return
new
nsPresContext
(
aDocument
aType
)
;
return
new
nsRootPresContext
(
aDocument
aType
)
;
}
nsresult
nsDocumentViewer
:
:
InitInternal
(
nsIWidget
*
aParentWidget
nsISupports
*
aState
const
nsIntRect
&
aBounds
bool
aDoCreation
bool
aNeedMakeCX
bool
aForceSetNewDocument
)
{
if
(
mIsPageMode
)
{
aForceSetNewDocument
=
false
;
}
nsAutoScriptBlocker
blockScripts
;
mParentWidget
=
aParentWidget
;
mBounds
=
aBounds
;
nsresult
rv
=
NS_OK
;
NS_ENSURE_TRUE
(
mDocument
NS_ERROR_NULL_POINTER
)
;
nsView
*
containerView
=
FindContainerView
(
)
;
bool
makeCX
=
false
;
if
(
aDoCreation
)
{
nsresult
rv
=
CreateDeviceContext
(
containerView
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
mPresContext
&
&
(
aParentWidget
|
|
containerView
|
|
mDocument
-
>
IsBeingUsedAsImage
(
)
|
|
(
mDocument
-
>
GetDisplayDocument
(
)
&
&
mDocument
-
>
GetDisplayDocument
(
)
-
>
GetShell
(
)
)
)
)
{
if
(
mIsPageMode
)
{
}
else
{
mPresContext
=
CreatePresContext
(
mDocument
nsPresContext
:
:
eContext_Galley
containerView
)
;
}
NS_ENSURE_TRUE
(
mPresContext
NS_ERROR_OUT_OF_MEMORY
)
;
nsresult
rv
=
mPresContext
-
>
Init
(
mDeviceContext
)
;
if
(
NS_FAILED
(
rv
)
)
{
mPresContext
=
nullptr
;
return
rv
;
}
#
if
defined
(
NS_PRINTING
)
&
&
defined
(
NS_PRINT_PREVIEW
)
makeCX
=
!
GetIsPrintPreview
(
)
&
&
aNeedMakeCX
;
#
else
makeCX
=
true
;
#
endif
}
if
(
mPresContext
)
{
rv
=
MakeWindow
(
nsSize
(
mPresContext
-
>
DevPixelsToAppUnits
(
aBounds
.
width
)
mPresContext
-
>
DevPixelsToAppUnits
(
aBounds
.
height
)
)
containerView
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
Hide
(
)
;
#
ifdef
NS_PRINT_PREVIEW
if
(
mIsPageMode
)
{
double
pageWidth
=
0
pageHeight
=
0
;
mPresContext
-
>
GetPrintSettings
(
)
-
>
GetEffectivePageSize
(
&
pageWidth
&
pageHeight
)
;
mPresContext
-
>
SetPageSize
(
nsSize
(
mPresContext
-
>
CSSTwipsToAppUnits
(
NSToIntFloor
(
pageWidth
)
)
mPresContext
-
>
CSSTwipsToAppUnits
(
NSToIntFloor
(
pageHeight
)
)
)
)
;
mPresContext
-
>
SetIsRootPaginatedDocument
(
true
)
;
mPresContext
-
>
SetPageScale
(
1
.
0f
)
;
}
#
endif
}
else
{
if
(
mPreviousViewer
)
{
mPreviousViewer
-
>
Destroy
(
)
;
mPreviousViewer
=
nullptr
;
}
}
}
nsCOMPtr
<
nsIInterfaceRequestor
>
requestor
(
mContainer
)
;
if
(
requestor
)
{
if
(
mPresContext
)
{
nsCOMPtr
<
nsILinkHandler
>
linkHandler
;
requestor
-
>
GetInterface
(
NS_GET_IID
(
nsILinkHandler
)
getter_AddRefs
(
linkHandler
)
)
;
mPresContext
-
>
SetContainer
(
mContainer
)
;
mPresContext
-
>
SetLinkHandler
(
linkHandler
)
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
do_GetInterface
(
requestor
)
;
if
(
window
)
{
nsCOMPtr
<
Document
>
curDoc
=
window
-
>
GetExtantDoc
(
)
;
if
(
aForceSetNewDocument
|
|
curDoc
!
=
mDocument
)
{
rv
=
window
-
>
SetNewDocument
(
mDocument
aState
false
)
;
if
(
NS_FAILED
(
rv
)
)
{
Destroy
(
)
;
return
rv
;
}
}
}
}
if
(
aDoCreation
&
&
mPresContext
)
{
rv
=
InitPresentationStuff
(
!
makeCX
)
;
}
return
rv
;
}
void
nsDocumentViewer
:
:
SetNavigationTiming
(
nsDOMNavigationTiming
*
timing
)
{
NS_ASSERTION
(
mDocument
"
Must
have
a
document
to
set
navigation
timing
.
"
)
;
if
(
mDocument
)
{
mDocument
-
>
SetNavigationTiming
(
timing
)
;
}
}
NS_IMETHODIMP
nsDocumentViewer
:
:
LoadComplete
(
nsresult
aStatus
)
{
RefPtr
<
nsDocumentViewer
>
kungFuDeathGrip
(
this
)
;
if
(
mPresShell
&
&
!
mStopped
)
{
nsCOMPtr
<
nsIPresShell
>
shell
=
mPresShell
;
shell
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
}
nsresult
rv
=
NS_OK
;
NS_ENSURE_TRUE
(
mDocument
NS_ERROR_NOT_AVAILABLE
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
mDocument
-
>
GetWindow
(
)
;
mLoaded
=
true
;
bool
restoring
=
false
;
if
(
window
&
&
(
NS_SUCCEEDED
(
aStatus
)
|
|
aStatus
=
=
NS_ERROR_PARSED_DATA_CACHED
)
)
{
nsEventStatus
status
=
nsEventStatus_eIgnore
;
WidgetEvent
event
(
true
eLoad
)
;
event
.
mFlags
.
mBubbles
=
false
;
event
.
mFlags
.
mCancelable
=
false
;
event
.
mTarget
=
mDocument
;
nsIDocShell
*
docShell
=
window
-
>
GetDocShell
(
)
;
NS_ENSURE_TRUE
(
docShell
NS_ERROR_UNEXPECTED
)
;
restoring
=
(
mDocument
-
>
GetReadyStateEnum
(
)
=
=
Document
:
:
READYSTATE_COMPLETE
)
;
if
(
!
restoring
)
{
NS_ASSERTION
(
mDocument
-
>
IsXULDocument
(
)
|
|
mDocument
-
>
GetReadyStateEnum
(
)
=
=
Document
:
:
READYSTATE_INTERACTIVE
|
|
(
mDocument
-
>
GetReadyStateEnum
(
)
=
=
Document
:
:
READYSTATE_UNINITIALIZED
&
&
NS_IsAboutBlank
(
mDocument
-
>
GetDocumentURI
(
)
)
)
"
Bad
readystate
"
)
;
#
ifdef
DEBUG
bool
docShellThinksWeAreRestoring
;
docShell
-
>
GetRestoringDocument
(
&
docShellThinksWeAreRestoring
)
;
MOZ_ASSERT
(
!
docShellThinksWeAreRestoring
"
How
can
docshell
think
we
are
restoring
if
we
don
'
t
have
a
"
"
READYSTATE_COMPLETE
document
?
"
)
;
#
endif
nsCOMPtr
<
Document
>
d
=
mDocument
;
mDocument
-
>
SetReadyStateInternal
(
Document
:
:
READYSTATE_COMPLETE
)
;
RefPtr
<
nsDOMNavigationTiming
>
timing
(
d
-
>
GetNavigationTiming
(
)
)
;
if
(
timing
)
{
timing
-
>
NotifyLoadEventStart
(
)
;
}
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
nsIPrincipal
*
principal
=
d
-
>
NodePrincipal
(
)
;
os
-
>
NotifyObservers
(
ToSupports
(
d
)
nsContentUtils
:
:
IsSystemPrincipal
(
principal
)
?
"
chrome
-
document
-
loaded
"
:
"
content
-
document
-
loaded
"
nullptr
)
;
}
RefPtr
<
TimelineConsumers
>
timelines
=
TimelineConsumers
:
:
Get
(
)
;
if
(
timelines
&
&
timelines
-
>
HasConsumer
(
docShell
)
)
{
timelines
-
>
AddMarkerForDocShell
(
docShell
MakeUnique
<
DocLoadingTimelineMarker
>
(
"
document
:
:
Load
"
)
)
;
}
EventDispatcher
:
:
Dispatch
(
window
mPresContext
&
event
nullptr
&
status
)
;
if
(
timing
)
{
timing
-
>
NotifyLoadEventEnd
(
)
;
}
nsPIDOMWindowInner
*
innerWindow
=
window
-
>
GetCurrentInnerWindow
(
)
;
if
(
innerWindow
)
{
innerWindow
-
>
QueuePerformanceNavigationTiming
(
)
;
}
}
}
else
{
}
if
(
mDocument
)
{
window
=
mDocument
-
>
GetWindow
(
)
;
if
(
window
)
{
nsIDocShell
*
docShell
=
window
-
>
GetDocShell
(
)
;
bool
isInUnload
;
if
(
docShell
&
&
NS_SUCCEEDED
(
docShell
-
>
GetIsInUnload
(
&
isInUnload
)
)
&
&
!
isInUnload
)
{
mDocument
-
>
OnPageShow
(
restoring
nullptr
)
;
}
}
}
if
(
!
mStopped
)
{
if
(
mDocument
)
{
mDocument
-
>
ScrollToRef
(
)
;
}
if
(
mPresShell
)
{
nsCOMPtr
<
nsIPresShell
>
shell
(
mPresShell
)
;
shell
-
>
UnsuppressPainting
(
)
;
if
(
mPresShell
)
{
mPresShell
-
>
LoadComplete
(
)
;
}
}
}
if
(
mDocument
&
&
mDocument
-
>
ScriptLoader
(
)
)
{
mDocument
-
>
ScriptLoader
(
)
-
>
LoadEventFired
(
)
;
}
nsJSContext
:
:
PokeGC
(
JS
:
:
GCReason
:
:
LOAD_END
mDocument
?
mDocument
-
>
GetWrapperPreserveColor
(
)
:
nullptr
)
;
#
ifdef
NS_PRINTING
if
(
mPrintIsPending
)
{
mPrintIsPending
=
false
;
mPrintDocIsFullyLoaded
=
true
;
Print
(
mCachedPrintSettings
mCachedPrintWebProgressListner
)
;
mCachedPrintSettings
=
nullptr
;
mCachedPrintWebProgressListner
=
nullptr
;
}
#
endif
return
rv
;
}
bool
nsDocumentViewer
:
:
GetLoadCompleted
(
)
{
return
mLoaded
;
}
bool
nsDocumentViewer
:
:
GetIsStopped
(
)
{
return
mStopped
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
PermitUnload
(
uint32_t
aPermitUnloadFlags
bool
*
aPermitUnload
)
{
return
PermitUnloadInternal
(
&
aPermitUnloadFlags
aPermitUnload
)
;
}
nsresult
nsDocumentViewer
:
:
PermitUnloadInternal
(
uint32_t
*
aPermitUnloadFlags
bool
*
aPermitUnload
)
{
AutoDontWarnAboutSyncXHR
disableSyncXHRWarning
;
nsresult
rv
=
NS_OK
;
*
aPermitUnload
=
true
;
if
(
!
mDocument
|
|
mInPermitUnload
|
|
mInPermitUnloadPrompt
)
{
return
NS_OK
;
}
static
bool
sIsBeforeUnloadDisabled
;
static
bool
sBeforeUnloadRequiresInteraction
;
static
bool
sBeforeUnloadPrefsCached
=
false
;
if
(
!
sBeforeUnloadPrefsCached
)
{
sBeforeUnloadPrefsCached
=
true
;
Preferences
:
:
AddBoolVarCache
(
&
sIsBeforeUnloadDisabled
BEFOREUNLOAD_DISABLED_PREFNAME
)
;
Preferences
:
:
AddBoolVarCache
(
&
sBeforeUnloadRequiresInteraction
BEFOREUNLOAD_REQUIRES_INTERACTION_PREFNAME
)
;
}
nsPIDOMWindowOuter
*
window
=
mDocument
-
>
GetWindow
(
)
;
if
(
!
window
)
{
NS_WARNING
(
"
window
not
set
for
document
!
"
)
;
return
NS_OK
;
}
NS_ASSERTION
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
This
is
unsafe
"
)
;
IgnoreOpensDuringUnload
ignoreOpens
(
mDocument
)
;
nsPresContext
*
presContext
=
mDocument
-
>
GetPresContext
(
)
;
RefPtr
<
BeforeUnloadEvent
>
event
=
new
BeforeUnloadEvent
(
mDocument
presContext
nullptr
)
;
event
-
>
InitEvent
(
NS_LITERAL_STRING
(
"
beforeunload
"
)
false
true
)
;
event
-
>
SetTarget
(
mDocument
)
;
event
-
>
SetTrusted
(
true
)
;
RefPtr
<
nsDocumentViewer
>
kungFuDeathGrip
(
this
)
;
bool
dialogsAreEnabled
=
false
;
{
nsAutoPopupStatePusher
popupStatePusher
(
PopupBlocker
:
:
openAbused
true
)
;
nsGlobalWindowOuter
*
globalWindow
=
nsGlobalWindowOuter
:
:
Cast
(
window
)
;
dialogsAreEnabled
=
globalWindow
-
>
AreDialogsEnabled
(
)
;
nsGlobalWindowOuter
:
:
TemporarilyDisableDialogs
disableDialogs
(
globalWindow
)
;
Document
:
:
PageUnloadingEventTimeStamp
timestamp
(
mDocument
)
;
mInPermitUnload
=
true
;
EventDispatcher
:
:
DispatchDOMEvent
(
window
nullptr
event
mPresContext
nullptr
)
;
mInPermitUnload
=
false
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
(
mContainer
)
;
nsAutoString
text
;
event
-
>
GetReturnValue
(
text
)
;
if
(
sIsBeforeUnloadDisabled
)
{
*
aPermitUnloadFlags
=
eDontPromptAndUnload
;
}
if
(
*
aPermitUnloadFlags
!
=
eDontPromptAndUnload
&
&
dialogsAreEnabled
&
&
mDocument
&
&
!
(
mDocument
-
>
GetSandboxFlags
(
)
&
SANDBOXED_MODALS
)
&
&
(
!
sBeforeUnloadRequiresInteraction
|
|
mDocument
-
>
UserHasInteracted
(
)
)
&
&
(
event
-
>
WidgetEventPtr
(
)
-
>
DefaultPrevented
(
)
|
|
!
text
.
IsEmpty
(
)
)
)
{
if
(
*
aPermitUnloadFlags
=
=
eDontPromptAndDontUnload
)
{
*
aPermitUnload
=
false
;
return
NS_OK
;
}
nsCOMPtr
<
nsIPrompt
>
prompt
=
do_GetInterface
(
docShell
)
;
if
(
prompt
)
{
nsCOMPtr
<
nsIWritablePropertyBag2
>
promptBag
=
do_QueryInterface
(
prompt
)
;
if
(
promptBag
)
{
bool
isTabModalPromptAllowed
;
GetIsTabModalPromptAllowed
(
&
isTabModalPromptAllowed
)
;
promptBag
-
>
SetPropertyAsBool
(
NS_LITERAL_STRING
(
"
allowTabModal
"
)
isTabModalPromptAllowed
)
;
}
nsAutoString
title
message
stayLabel
leaveLabel
;
rv
=
nsContentUtils
:
:
GetLocalizedString
(
nsContentUtils
:
:
eDOM_PROPERTIES
"
OnBeforeUnloadTitle
"
title
)
;
nsresult
tmp
=
nsContentUtils
:
:
GetLocalizedString
(
nsContentUtils
:
:
eDOM_PROPERTIES
"
OnBeforeUnloadMessage
"
message
)
;
if
(
NS_FAILED
(
tmp
)
)
{
rv
=
tmp
;
}
tmp
=
nsContentUtils
:
:
GetLocalizedString
(
nsContentUtils
:
:
eDOM_PROPERTIES
"
OnBeforeUnloadLeaveButton
"
leaveLabel
)
;
if
(
NS_FAILED
(
tmp
)
)
{
rv
=
tmp
;
}
tmp
=
nsContentUtils
:
:
GetLocalizedString
(
nsContentUtils
:
:
eDOM_PROPERTIES
"
OnBeforeUnloadStayButton
"
stayLabel
)
;
if
(
NS_FAILED
(
tmp
)
)
{
rv
=
tmp
;
}
if
(
NS_FAILED
(
rv
)
)
{
NS_ERROR
(
"
Failed
to
get
strings
from
dom
.
properties
!
"
)
;
return
NS_OK
;
}
bool
dummy
=
false
;
int32_t
buttonPressed
=
0
;
uint32_t
buttonFlags
=
(
nsIPrompt
:
:
BUTTON_POS_0_DEFAULT
|
(
nsIPrompt
:
:
BUTTON_TITLE_IS_STRING
*
nsIPrompt
:
:
BUTTON_POS_0
)
|
(
nsIPrompt
:
:
BUTTON_TITLE_IS_STRING
*
nsIPrompt
:
:
BUTTON_POS_1
)
)
;
nsAutoSyncOperation
sync
(
mDocument
)
;
mInPermitUnloadPrompt
=
true
;
mozilla
:
:
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
ONBEFOREUNLOAD_PROMPT_COUNT
1
)
;
rv
=
prompt
-
>
ConfirmEx
(
title
.
get
(
)
message
.
get
(
)
buttonFlags
leaveLabel
.
get
(
)
stayLabel
.
get
(
)
nullptr
nullptr
&
dummy
&
buttonPressed
)
;
mInPermitUnloadPrompt
=
false
;
if
(
NS_FAILED
(
rv
)
)
{
mozilla
:
:
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
ONBEFOREUNLOAD_PROMPT_ACTION
2
)
;
*
aPermitUnload
=
false
;
return
NS_OK
;
}
*
aPermitUnload
=
(
buttonPressed
=
=
0
)
;
mozilla
:
:
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
ONBEFOREUNLOAD_PROMPT_ACTION
(
*
aPermitUnload
?
1
:
0
)
)
;
if
(
*
aPermitUnload
)
{
*
aPermitUnloadFlags
=
eDontPromptAndUnload
;
}
}
}
if
(
docShell
)
{
int32_t
childCount
;
docShell
-
>
GetChildCount
(
&
childCount
)
;
for
(
int32_t
i
=
0
;
i
<
childCount
&
&
*
aPermitUnload
;
+
+
i
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
item
;
docShell
-
>
GetChildAt
(
i
getter_AddRefs
(
item
)
)
;
nsCOMPtr
<
nsIDocShell
>
docShell
(
do_QueryInterface
(
item
)
)
;
if
(
docShell
)
{
nsCOMPtr
<
nsIContentViewer
>
cv
;
docShell
-
>
GetContentViewer
(
getter_AddRefs
(
cv
)
)
;
if
(
cv
)
{
cv
-
>
PermitUnloadInternal
(
aPermitUnloadFlags
aPermitUnload
)
;
}
}
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetBeforeUnloadFiring
(
bool
*
aInEvent
)
{
*
aInEvent
=
mInPermitUnload
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetInPermitUnload
(
bool
*
aInEvent
)
{
*
aInEvent
=
mInPermitUnloadPrompt
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
PageHide
(
bool
aIsUnload
)
{
AutoDontWarnAboutSyncXHR
disableSyncXHRWarning
;
mHidden
=
true
;
if
(
!
mDocument
)
{
return
NS_ERROR_NULL_POINTER
;
}
if
(
aIsUnload
)
{
nsJSContext
:
:
PokeGC
(
JS
:
:
GCReason
:
:
PAGE_HIDE
mDocument
-
>
GetWrapperPreserveColor
(
)
NS_GC_DELAY
*
2
)
;
}
mDocument
-
>
OnPageHide
(
!
aIsUnload
nullptr
)
;
NS_ENSURE_STATE
(
mDocument
)
;
nsPIDOMWindowOuter
*
window
=
mDocument
-
>
GetWindow
(
)
;
if
(
window
)
window
-
>
PageHidden
(
)
;
if
(
aIsUnload
)
{
NS_ENSURE_STATE
(
mDocument
)
;
nsPIDOMWindowOuter
*
window
=
mDocument
-
>
GetWindow
(
)
;
if
(
!
window
)
{
NS_WARNING
(
"
window
not
set
for
document
!
"
)
;
return
NS_ERROR_NULL_POINTER
;
}
IgnoreOpensDuringUnload
ignoreOpens
(
mDocument
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
WidgetEvent
event
(
true
eUnload
)
;
event
.
mFlags
.
mBubbles
=
false
;
event
.
mTarget
=
mDocument
;
nsAutoPopupStatePusher
popupStatePusher
(
PopupBlocker
:
:
openAbused
true
)
;
Document
:
:
PageUnloadingEventTimeStamp
timestamp
(
mDocument
)
;
EventDispatcher
:
:
Dispatch
(
window
mPresContext
&
event
nullptr
&
status
)
;
}
#
ifdef
MOZ_XUL
nsContentUtils
:
:
HidePopupsInDocument
(
mDocument
)
;
#
endif
return
NS_OK
;
}
static
void
AttachContainerRecurse
(
nsIDocShell
*
aShell
)
{
nsCOMPtr
<
nsIContentViewer
>
viewer
;
aShell
-
>
GetContentViewer
(
getter_AddRefs
(
viewer
)
)
;
if
(
viewer
)
{
viewer
-
>
SetIsHidden
(
false
)
;
Document
*
doc
=
viewer
-
>
GetDocument
(
)
;
if
(
doc
)
{
doc
-
>
SetContainer
(
static_cast
<
nsDocShell
*
>
(
aShell
)
)
;
}
RefPtr
<
nsPresContext
>
pc
=
viewer
-
>
GetPresContext
(
)
;
if
(
pc
)
{
pc
-
>
SetContainer
(
static_cast
<
nsDocShell
*
>
(
aShell
)
)
;
nsCOMPtr
<
nsILinkHandler
>
handler
=
do_QueryInterface
(
aShell
)
;
pc
-
>
SetLinkHandler
(
handler
)
;
}
nsCOMPtr
<
nsIPresShell
>
presShell
=
viewer
-
>
GetPresShell
(
)
;
if
(
presShell
)
{
presShell
-
>
SetForwardingContainer
(
WeakPtr
<
nsDocShell
>
(
)
)
;
}
}
int32_t
childCount
;
aShell
-
>
GetChildCount
(
&
childCount
)
;
for
(
int32_t
i
=
0
;
i
<
childCount
;
+
+
i
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
childItem
;
aShell
-
>
GetChildAt
(
i
getter_AddRefs
(
childItem
)
)
;
nsCOMPtr
<
nsIDocShell
>
shell
=
do_QueryInterface
(
childItem
)
;
AttachContainerRecurse
(
shell
)
;
}
}
NS_IMETHODIMP
nsDocumentViewer
:
:
Open
(
nsISupports
*
aState
nsISHEntry
*
aSHEntry
)
{
NS_ENSURE_TRUE
(
mPresShell
NS_ERROR_NOT_INITIALIZED
)
;
if
(
mDocument
)
mDocument
-
>
SetContainer
(
mContainer
)
;
nsresult
rv
=
InitInternal
(
mParentWidget
aState
mBounds
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
mHidden
=
false
;
if
(
mPresShell
)
mPresShell
-
>
SetForwardingContainer
(
WeakPtr
<
nsDocShell
>
(
)
)
;
if
(
aSHEntry
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
item
;
int32_t
itemIndex
=
0
;
while
(
NS_SUCCEEDED
(
aSHEntry
-
>
ChildShellAt
(
itemIndex
+
+
getter_AddRefs
(
item
)
)
)
&
&
item
)
{
nsCOMPtr
<
nsIDocShell
>
shell
=
do_QueryInterface
(
item
)
;
AttachContainerRecurse
(
shell
)
;
}
}
SyncParentSubDocMap
(
)
;
if
(
mFocusListener
&
&
mDocument
)
{
mFocusListener
-
>
Init
(
this
)
;
mDocument
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
focus
"
)
mFocusListener
false
false
)
;
mDocument
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
blur
"
)
mFocusListener
false
false
)
;
}
PrepareToStartLoad
(
)
;
if
(
nsIWidget
:
:
UsePuppetWidgets
(
)
&
&
mPresContext
&
&
ShouldAttachToTopLevel
(
)
)
{
DetachFromTopLevelWidget
(
)
;
nsViewManager
*
vm
=
GetViewManager
(
)
;
MOZ_ASSERT
(
vm
"
no
view
manager
"
)
;
nsView
*
v
=
vm
-
>
GetRootView
(
)
;
MOZ_ASSERT
(
v
"
no
root
view
"
)
;
MOZ_ASSERT
(
mParentWidget
"
no
mParentWidget
to
set
"
)
;
v
-
>
AttachToTopLevelWidget
(
mParentWidget
)
;
mAttachedToParent
=
true
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
Close
(
nsISHEntry
*
aSHEntry
)
{
mSHEntry
=
aSHEntry
;
if
(
!
mDocument
)
return
NS_OK
;
if
(
mSHEntry
)
{
if
(
mBFCachePreventionObserver
)
{
mBFCachePreventionObserver
-
>
Disconnect
(
)
;
}
mBFCachePreventionObserver
=
new
BFCachePreventionObserver
(
mDocument
)
;
mDocument
-
>
AddMutationObserver
(
mBFCachePreventionObserver
)
;
}
#
if
defined
(
NS_PRINTING
)
&
&
defined
(
NS_PRINT_PREVIEW
)
if
(
GetIsPrintPreview
(
)
&
&
mPrintJob
)
{
mPrintJob
-
>
TurnScriptingOn
(
true
)
;
}
#
endif
#
ifdef
NS_PRINTING
if
(
mPrintJob
&
&
!
mClosingWhilePrinting
)
{
mClosingWhilePrinting
=
true
;
}
else
#
endif
{
mDocument
-
>
SetScriptGlobalObject
(
nullptr
)
;
if
(
!
mSHEntry
&
&
mDocument
)
mDocument
-
>
RemovedFromDocShell
(
)
;
}
if
(
mFocusListener
)
{
mFocusListener
-
>
Disconnect
(
)
;
if
(
mDocument
)
{
mDocument
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
focus
"
)
mFocusListener
false
)
;
mDocument
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
blur
"
)
mFocusListener
false
)
;
}
}
return
NS_OK
;
}
static
void
DetachContainerRecurse
(
nsIDocShell
*
aShell
)
{
nsCOMPtr
<
nsIContentViewer
>
viewer
;
aShell
-
>
GetContentViewer
(
getter_AddRefs
(
viewer
)
)
;
if
(
viewer
)
{
Document
*
doc
=
viewer
-
>
GetDocument
(
)
;
if
(
doc
)
{
doc
-
>
SetContainer
(
nullptr
)
;
}
RefPtr
<
nsPresContext
>
pc
=
viewer
-
>
GetPresContext
(
)
;
if
(
pc
)
{
pc
-
>
Detach
(
)
;
}
nsCOMPtr
<
nsIPresShell
>
presShell
=
viewer
-
>
GetPresShell
(
)
;
if
(
presShell
)
{
auto
weakShell
=
static_cast
<
nsDocShell
*
>
(
aShell
)
;
presShell
-
>
SetForwardingContainer
(
weakShell
)
;
}
}
int32_t
childCount
;
aShell
-
>
GetChildCount
(
&
childCount
)
;
for
(
int32_t
i
=
0
;
i
<
childCount
;
+
+
i
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
childItem
;
aShell
-
>
GetChildAt
(
i
getter_AddRefs
(
childItem
)
)
;
nsCOMPtr
<
nsIDocShell
>
shell
=
do_QueryInterface
(
childItem
)
;
DetachContainerRecurse
(
shell
)
;
}
}
NS_IMETHODIMP
nsDocumentViewer
:
:
Destroy
(
)
{
NS_ASSERTION
(
mDocument
"
No
document
in
Destroy
(
)
!
"
)
;
if
(
mDestroyBlockedCount
!
=
0
)
{
return
NS_OK
;
}
#
ifdef
NS_PRINTING
if
(
mPrintJob
)
{
if
(
mPrintJob
-
>
CheckBeforeDestroy
(
)
)
{
return
NS_OK
;
}
}
mAutoBeforeAndAfterPrint
=
nullptr
;
#
endif
if
(
mBFCachePreventionObserver
)
{
mBFCachePreventionObserver
-
>
Disconnect
(
)
;
mBFCachePreventionObserver
=
nullptr
;
}
if
(
mSHEntry
&
&
mDocument
&
&
!
mDocument
-
>
IsBFCachingAllowed
(
)
)
{
nsCOMPtr
<
nsISHEntry
>
shEntry
=
mSHEntry
.
forget
(
)
;
shEntry
-
>
SetContentViewer
(
nullptr
)
;
shEntry
-
>
SyncPresentationState
(
)
;
}
if
(
mSHEntry
)
{
if
(
mPresShell
)
mPresShell
-
>
Freeze
(
)
;
mSHEntry
-
>
SetSticky
(
mIsSticky
)
;
mIsSticky
=
true
;
if
(
mPresShell
)
{
nsViewManager
*
vm
=
mPresShell
-
>
GetViewManager
(
)
;
if
(
vm
)
{
nsView
*
rootView
=
vm
-
>
GetRootView
(
)
;
if
(
rootView
)
{
nsView
*
rootViewParent
=
rootView
-
>
GetParent
(
)
;
if
(
rootViewParent
)
{
nsViewManager
*
parentVM
=
rootViewParent
-
>
GetViewManager
(
)
;
if
(
parentVM
)
{
parentVM
-
>
RemoveChild
(
rootView
)
;
}
}
}
}
}
Hide
(
)
;
if
(
mDocument
)
{
mDocument
-
>
Sanitize
(
)
;
}
nsCOMPtr
<
nsISHEntry
>
shEntry
=
mSHEntry
.
forget
(
)
;
shEntry
-
>
SetContentViewer
(
this
)
;
shEntry
-
>
SyncPresentationState
(
)
;
#
ifdef
ACCESSIBILITY
if
(
mPresShell
)
{
a11y
:
:
DocAccessible
*
docAcc
=
mPresShell
-
>
GetDocAccessible
(
)
;
if
(
docAcc
)
{
docAcc
-
>
Shutdown
(
)
;
}
}
#
endif
if
(
mDocument
)
{
mDocument
-
>
SetContainer
(
nullptr
)
;
}
if
(
mPresContext
)
{
mPresContext
-
>
Detach
(
)
;
}
if
(
mPresShell
)
{
mPresShell
-
>
SetForwardingContainer
(
mContainer
)
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
item
;
int32_t
itemIndex
=
0
;
while
(
NS_SUCCEEDED
(
shEntry
-
>
ChildShellAt
(
itemIndex
+
+
getter_AddRefs
(
item
)
)
)
&
&
item
)
{
nsCOMPtr
<
nsIDocShell
>
shell
=
do_QueryInterface
(
item
)
;
DetachContainerRecurse
(
shell
)
;
}
return
NS_OK
;
}
nsAutoScriptBlocker
scriptBlocker
;
if
(
mPresShell
)
{
DestroyPresShell
(
)
;
}
if
(
mDocument
)
{
mDocument
-
>
Destroy
(
)
;
mDocument
=
nullptr
;
}
#
ifdef
NS_PRINTING
if
(
mPrintJob
)
{
RefPtr
<
nsPrintJob
>
printJob
=
std
:
:
move
(
mPrintJob
)
;
#
ifdef
NS_PRINT_PREVIEW
bool
doingPrintPreview
;
printJob
-
>
GetDoingPrintPreview
(
&
doingPrintPreview
)
;
if
(
doingPrintPreview
)
{
printJob
-
>
FinishPrintPreview
(
)
;
}
#
endif
printJob
-
>
Destroy
(
)
;
MOZ_ASSERT
(
!
mPrintJob
"
mPrintJob
shouldn
'
t
be
recreated
while
destroying
it
"
)
;
}
#
endif
if
(
mPreviousViewer
)
{
mPreviousViewer
-
>
Destroy
(
)
;
mPreviousViewer
=
nullptr
;
}
mDeviceContext
=
nullptr
;
if
(
mPresContext
)
{
DestroyPresContext
(
)
;
}
mWindow
=
nullptr
;
mViewManager
=
nullptr
;
mContainer
=
WeakPtr
<
nsDocShell
>
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
Stop
(
void
)
{
NS_ASSERTION
(
mDocument
"
Stop
called
too
early
or
too
late
"
)
;
if
(
mDocument
)
{
mDocument
-
>
StopDocumentLoad
(
)
;
}
if
(
!
mHidden
&
&
(
mLoaded
|
|
mStopped
)
&
&
mPresContext
&
&
!
mSHEntry
)
mPresContext
-
>
SetImageAnimationMode
(
imgIContainer
:
:
kDontAnimMode
)
;
mStopped
=
true
;
if
(
!
mLoaded
&
&
mPresShell
)
{
nsCOMPtr
<
nsIPresShell
>
shell
(
mPresShell
)
;
shell
-
>
UnsuppressPainting
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetDOMDocument
(
Document
*
*
aResult
)
{
NS_ENSURE_TRUE
(
mDocument
NS_ERROR_NOT_AVAILABLE
)
;
nsCOMPtr
<
Document
>
document
=
mDocument
;
document
.
forget
(
aResult
)
;
return
NS_OK
;
}
Document
*
nsDocumentViewer
:
:
GetDocument
(
)
{
return
mDocument
;
}
nsresult
nsDocumentViewer
:
:
SetDocument
(
Document
*
aDocument
)
{
if
(
!
aDocument
)
return
NS_ERROR_NULL_POINTER
;
return
SetDocumentInternal
(
aDocument
false
)
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
SetDocumentInternal
(
Document
*
aDocument
bool
aForceReuseInnerWindow
)
{
MOZ_ASSERT
(
aDocument
)
;
aDocument
-
>
SetContainer
(
mContainer
)
;
if
(
mDocument
!
=
aDocument
)
{
if
(
aForceReuseInnerWindow
)
{
aDocument
-
>
SetNavigationTiming
(
mDocument
-
>
GetNavigationTiming
(
)
)
;
}
if
(
mDocument
-
>
IsStaticDocument
(
)
)
{
mDocument
-
>
Destroy
(
)
;
}
if
(
!
aDocument
-
>
IsStaticDocument
(
)
)
{
nsCOMPtr
<
nsIDocShell
>
node
(
mContainer
)
;
if
(
node
)
{
int32_t
count
;
node
-
>
GetChildCount
(
&
count
)
;
for
(
int32_t
i
=
0
;
i
<
count
;
+
+
i
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
child
;
node
-
>
GetChildAt
(
0
getter_AddRefs
(
child
)
)
;
node
-
>
RemoveChild
(
child
)
;
}
}
}
mDocument
=
aDocument
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
mContainer
?
mContainer
-
>
GetWindow
(
)
:
nullptr
;
if
(
window
)
{
nsresult
rv
=
window
-
>
SetNewDocument
(
aDocument
nullptr
aForceReuseInnerWindow
)
;
if
(
NS_FAILED
(
rv
)
)
{
Destroy
(
)
;
return
rv
;
}
}
}
nsresult
rv
=
SyncParentSubDocMap
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsAutoScriptBlocker
scriptBlocker
;
if
(
mPresShell
)
{
DestroyPresShell
(
)
;
}
if
(
mPresContext
)
{
DestroyPresContext
(
)
;
mWindow
=
nullptr
;
rv
=
InitInternal
(
mParentWidget
nullptr
mBounds
true
true
false
)
;
}
return
rv
;
}
nsIPresShell
*
nsDocumentViewer
:
:
GetPresShell
(
)
{
return
mPresShell
;
}
nsPresContext
*
nsDocumentViewer
:
:
GetPresContext
(
)
{
return
mPresContext
;
}
nsViewManager
*
nsDocumentViewer
:
:
GetViewManager
(
)
{
return
mViewManager
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetBounds
(
nsIntRect
&
aResult
)
{
NS_ENSURE_TRUE
(
mDocument
NS_ERROR_NOT_AVAILABLE
)
;
aResult
=
mBounds
;
return
NS_OK
;
}
nsIContentViewer
*
nsDocumentViewer
:
:
GetPreviousViewer
(
)
{
return
mPreviousViewer
;
}
void
nsDocumentViewer
:
:
SetPreviousViewer
(
nsIContentViewer
*
aViewer
)
{
if
(
aViewer
)
{
NS_ASSERTION
(
!
mPreviousViewer
"
can
'
t
set
previous
viewer
when
there
already
is
one
"
)
;
nsCOMPtr
<
nsIContentViewer
>
prevViewer
=
aViewer
-
>
GetPreviousViewer
(
)
;
if
(
prevViewer
)
{
aViewer
-
>
SetPreviousViewer
(
nullptr
)
;
aViewer
-
>
Destroy
(
)
;
return
SetPreviousViewer
(
prevViewer
)
;
}
}
mPreviousViewer
=
aViewer
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
SetBoundsWithFlags
(
const
nsIntRect
&
aBounds
uint32_t
aFlags
)
{
NS_ENSURE_TRUE
(
mDocument
NS_ERROR_NOT_AVAILABLE
)
;
mBounds
=
aBounds
;
if
(
mWindow
&
&
!
mAttachedToParent
)
{
mWindow
-
>
Resize
(
aBounds
.
x
aBounds
.
y
aBounds
.
width
aBounds
.
height
false
)
;
}
else
if
(
mPresContext
&
&
mViewManager
)
{
if
(
mPresContext
-
>
DeviceContext
(
)
-
>
CheckDPIChange
(
)
)
{
mPresContext
-
>
UIResolutionChanged
(
)
;
}
int32_t
p2a
=
mPresContext
-
>
AppUnitsPerDevPixel
(
)
;
mViewManager
-
>
SetWindowDimensions
(
NSIntPixelsToAppUnits
(
mBounds
.
width
p2a
)
NSIntPixelsToAppUnits
(
mBounds
.
height
p2a
)
!
!
(
aFlags
&
nsIContentViewer
:
:
eDelayResize
)
)
;
}
if
(
mPreviousViewer
)
{
nsCOMPtr
<
nsIContentViewer
>
previousViewer
=
mPreviousViewer
;
previousViewer
-
>
SetBounds
(
aBounds
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
SetBounds
(
const
nsIntRect
&
aBounds
)
{
return
SetBoundsWithFlags
(
aBounds
0
)
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
Move
(
int32_t
aX
int32_t
aY
)
{
NS_ENSURE_TRUE
(
mDocument
NS_ERROR_NOT_AVAILABLE
)
;
mBounds
.
MoveTo
(
aX
aY
)
;
if
(
mWindow
)
{
mWindow
-
>
Move
(
aX
aY
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
Show
(
void
)
{
NS_ENSURE_TRUE
(
mDocument
NS_ERROR_NOT_AVAILABLE
)
;
if
(
mPreviousViewer
)
{
nsCOMPtr
<
nsIContentViewer
>
prevViewer
(
mPreviousViewer
)
;
mPreviousViewer
=
nullptr
;
prevViewer
-
>
Destroy
(
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
treeItem
(
mContainer
)
;
if
(
treeItem
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
root
;
treeItem
-
>
GetSameTypeRootTreeItem
(
getter_AddRefs
(
root
)
)
;
nsCOMPtr
<
nsIWebNavigation
>
webNav
=
do_QueryInterface
(
root
)
;
RefPtr
<
ChildSHistory
>
history
=
webNav
-
>
GetSessionHistory
(
)
;
if
(
history
)
{
int32_t
prevIndex
loadedIndex
;
nsCOMPtr
<
nsIDocShell
>
docShell
=
do_QueryInterface
(
treeItem
)
;
docShell
-
>
GetPreviousEntryIndex
(
&
prevIndex
)
;
docShell
-
>
GetLoadedEntryIndex
(
&
loadedIndex
)
;
#
ifdef
DEBUG_PAGE_CACHE
printf
(
"
About
to
evict
content
viewers
:
prev
=
%
d
loaded
=
%
d
\
n
"
prevIndex
loadedIndex
)
;
#
endif
history
-
>
LegacySHistory
(
)
-
>
EvictOutOfRangeContentViewers
(
loadedIndex
)
;
}
}
}
if
(
mWindow
)
{
if
(
!
mAttachedToParent
)
{
mWindow
-
>
Show
(
true
)
;
}
}
nsCOMPtr
<
Document
>
document
=
mDocument
;
if
(
mDocument
&
&
!
mPresShell
)
{
nsAutoScriptBlocker
scriptBlocker
;
NS_ASSERTION
(
!
mWindow
"
Window
already
created
but
no
presshell
?
"
)
;
nsCOMPtr
<
nsIBaseWindow
>
base_win
(
mContainer
)
;
if
(
base_win
)
{
base_win
-
>
GetParentWidget
(
&
mParentWidget
)
;
if
(
mParentWidget
)
{
mParentWidget
-
>
Release
(
)
;
}
}
nsView
*
containerView
=
FindContainerView
(
)
;
nsresult
rv
=
CreateDeviceContext
(
containerView
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ASSERTION
(
!
mPresContext
"
Shouldn
'
t
have
a
prescontext
if
we
have
no
shell
!
"
)
;
mPresContext
=
CreatePresContext
(
mDocument
nsPresContext
:
:
eContext_Galley
containerView
)
;
NS_ENSURE_TRUE
(
mPresContext
NS_ERROR_OUT_OF_MEMORY
)
;
rv
=
mPresContext
-
>
Init
(
mDeviceContext
)
;
if
(
NS_FAILED
(
rv
)
)
{
mPresContext
=
nullptr
;
return
rv
;
}
rv
=
MakeWindow
(
nsSize
(
mPresContext
-
>
DevPixelsToAppUnits
(
mBounds
.
width
)
mPresContext
-
>
DevPixelsToAppUnits
(
mBounds
.
height
)
)
containerView
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
if
(
mPresContext
&
&
base_win
)
{
nsCOMPtr
<
nsILinkHandler
>
linkHandler
(
do_GetInterface
(
base_win
)
)
;
if
(
linkHandler
)
{
mPresContext
-
>
SetLinkHandler
(
linkHandler
)
;
}
mPresContext
-
>
SetContainer
(
mContainer
)
;
}
if
(
mPresContext
)
{
Hide
(
)
;
rv
=
InitPresentationStuff
(
mDocument
-
>
MayStartLayout
(
)
)
;
}
if
(
mPresShell
)
{
nsCOMPtr
<
nsIPresShell
>
shell
(
mPresShell
)
;
shell
-
>
UnsuppressPainting
(
)
;
}
}
RefPtr
<
nsDocumentShownDispatcher
>
event
=
new
nsDocumentShownDispatcher
(
document
)
;
document
-
>
Dispatch
(
TaskCategory
:
:
Other
event
.
forget
(
)
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
Hide
(
void
)
{
if
(
!
mAttachedToParent
&
&
mWindow
)
{
mWindow
-
>
Show
(
false
)
;
}
if
(
!
mPresShell
)
return
NS_OK
;
NS_ASSERTION
(
mPresContext
"
Can
'
t
have
a
presshell
and
no
prescontext
!
"
)
;
if
(
mPreviousViewer
)
{
mPreviousViewer
-
>
Destroy
(
)
;
mPreviousViewer
=
nullptr
;
}
if
(
mIsSticky
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
(
mContainer
)
;
if
(
docShell
)
{
#
ifdef
DEBUG
nsCOMPtr
<
nsIContentViewer
>
currentViewer
;
docShell
-
>
GetContentViewer
(
getter_AddRefs
(
currentViewer
)
)
;
MOZ_ASSERT
(
currentViewer
=
=
this
)
;
#
endif
nsCOMPtr
<
nsILayoutHistoryState
>
layoutState
;
mPresShell
-
>
CaptureHistoryState
(
getter_AddRefs
(
layoutState
)
)
;
}
nsAutoScriptBlocker
scriptBlocker
;
DestroyPresShell
(
)
;
DestroyPresContext
(
)
;
mViewManager
=
nullptr
;
mWindow
=
nullptr
;
mDeviceContext
=
nullptr
;
mParentWidget
=
nullptr
;
nsCOMPtr
<
nsIBaseWindow
>
base_win
(
mContainer
)
;
if
(
base_win
&
&
!
mAttachedToParent
)
{
base_win
-
>
SetParentWidget
(
nullptr
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetSticky
(
bool
*
aSticky
)
{
*
aSticky
=
mIsSticky
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
SetSticky
(
bool
aSticky
)
{
mIsSticky
=
aSticky
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
RequestWindowClose
(
bool
*
aCanClose
)
{
#
ifdef
NS_PRINTING
if
(
mPrintIsPending
|
|
(
mPrintJob
&
&
mPrintJob
-
>
GetIsPrinting
(
)
)
)
{
*
aCanClose
=
false
;
mDeferredWindowClose
=
true
;
}
else
#
endif
*
aCanClose
=
true
;
return
NS_OK
;
}
UniquePtr
<
ServoStyleSet
>
nsDocumentViewer
:
:
CreateStyleSet
(
Document
*
aDocument
)
{
auto
cache
=
nsLayoutStylesheetCache
:
:
Singleton
(
)
;
nsStyleSheetService
*
sheetService
=
nsStyleSheetService
:
:
GetInstance
(
)
;
auto
styleSet
=
MakeUnique
<
ServoStyleSet
>
(
)
;
for
(
StyleSheet
*
sheet
:
*
sheetService
-
>
UserStyleSheets
(
)
)
{
styleSet
-
>
AppendStyleSheet
(
SheetType
:
:
User
sheet
)
;
}
StyleSheet
*
sheet
=
nsContentUtils
:
:
IsInChromeDocshell
(
aDocument
)
?
cache
-
>
GetUserChromeSheet
(
)
:
cache
-
>
GetUserContentSheet
(
)
;
if
(
sheet
)
{
styleSet
-
>
AppendStyleSheet
(
SheetType
:
:
User
sheet
)
;
}
styleSet
-
>
AppendStyleSheet
(
SheetType
:
:
Agent
cache
-
>
UASheet
(
)
)
;
if
(
MOZ_LIKELY
(
mDocument
-
>
NodeInfoManager
(
)
-
>
MathMLEnabled
(
)
)
)
{
styleSet
-
>
AppendStyleSheet
(
SheetType
:
:
Agent
cache
-
>
MathMLSheet
(
)
)
;
}
if
(
MOZ_LIKELY
(
mDocument
-
>
NodeInfoManager
(
)
-
>
SVGEnabled
(
)
)
)
{
styleSet
-
>
AppendStyleSheet
(
SheetType
:
:
Agent
cache
-
>
SVGSheet
(
)
)
;
}
styleSet
-
>
AppendStyleSheet
(
SheetType
:
:
Agent
cache
-
>
HTMLSheet
(
)
)
;
if
(
nsLayoutUtils
:
:
ShouldUseNoFramesSheet
(
aDocument
)
)
{
styleSet
-
>
AppendStyleSheet
(
SheetType
:
:
Agent
cache
-
>
NoFramesSheet
(
)
)
;
}
if
(
nsLayoutUtils
:
:
ShouldUseNoScriptSheet
(
aDocument
)
)
{
styleSet
-
>
AppendStyleSheet
(
SheetType
:
:
Agent
cache
-
>
NoScriptSheet
(
)
)
;
}
styleSet
-
>
AppendStyleSheet
(
SheetType
:
:
Agent
cache
-
>
CounterStylesSheet
(
)
)
;
styleSet
-
>
AppendStyleSheet
(
SheetType
:
:
Agent
cache
-
>
MinimalXULSheet
(
)
)
;
if
(
aDocument
-
>
LoadsFullXULStyleSheetUpFront
(
)
)
{
styleSet
-
>
AppendStyleSheet
(
SheetType
:
:
Agent
cache
-
>
XULSheet
(
)
)
;
}
styleSet
-
>
AppendStyleSheet
(
SheetType
:
:
Agent
cache
-
>
FormsSheet
(
)
)
;
styleSet
-
>
AppendStyleSheet
(
SheetType
:
:
Agent
cache
-
>
ScrollbarsSheet
(
)
)
;
styleSet
-
>
AppendStyleSheet
(
SheetType
:
:
Agent
cache
-
>
PluginProblemSheet
(
)
)
;
for
(
StyleSheet
*
sheet
:
*
sheetService
-
>
AgentStyleSheets
(
)
)
{
styleSet
-
>
AppendStyleSheet
(
SheetType
:
:
Agent
sheet
)
;
}
return
styleSet
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
ClearHistoryEntry
(
)
{
if
(
mDocument
)
{
nsJSContext
:
:
PokeGC
(
JS
:
:
GCReason
:
:
PAGE_HIDE
mDocument
-
>
GetWrapperPreserveColor
(
)
NS_GC_DELAY
*
2
)
;
}
mSHEntry
=
nullptr
;
return
NS_OK
;
}
nsresult
nsDocumentViewer
:
:
MakeWindow
(
const
nsSize
&
aSize
nsView
*
aContainerView
)
{
if
(
GetIsPrintPreview
(
)
)
return
NS_OK
;
bool
shouldAttach
=
ShouldAttachToTopLevel
(
)
;
if
(
shouldAttach
)
{
DetachFromTopLevelWidget
(
)
;
}
mViewManager
=
new
nsViewManager
(
)
;
nsDeviceContext
*
dx
=
mPresContext
-
>
DeviceContext
(
)
;
nsresult
rv
=
mViewManager
-
>
Init
(
dx
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nsRect
tbounds
(
nsPoint
(
0
0
)
aSize
)
;
nsView
*
view
=
mViewManager
-
>
CreateView
(
tbounds
aContainerView
)
;
if
(
!
view
)
return
NS_ERROR_OUT_OF_MEMORY
;
if
(
!
mDocument
-
>
IsResourceDoc
(
)
&
&
(
mParentWidget
|
|
!
aContainerView
)
)
{
nsWidgetInitData
initData
;
nsWidgetInitData
*
initDataPtr
;
if
(
!
mParentWidget
)
{
initDataPtr
=
&
initData
;
initData
.
mWindowType
=
eWindowType_invisible
;
}
else
{
initDataPtr
=
nullptr
;
}
if
(
shouldAttach
)
{
rv
=
view
-
>
AttachToTopLevelWidget
(
mParentWidget
)
;
mAttachedToParent
=
true
;
}
else
if
(
!
aContainerView
&
&
mParentWidget
)
{
rv
=
view
-
>
CreateWidgetForParent
(
mParentWidget
initDataPtr
true
false
)
;
}
else
{
rv
=
view
-
>
CreateWidget
(
initDataPtr
true
false
)
;
}
if
(
NS_FAILED
(
rv
)
)
return
rv
;
}
mViewManager
-
>
SetRootView
(
view
)
;
mWindow
=
view
-
>
GetWidget
(
)
;
return
rv
;
}
void
nsDocumentViewer
:
:
DetachFromTopLevelWidget
(
)
{
if
(
mViewManager
)
{
nsView
*
oldView
=
mViewManager
-
>
GetRootView
(
)
;
if
(
oldView
&
&
oldView
-
>
IsAttachedToTopLevel
(
)
)
{
oldView
-
>
DetachFromTopLevelWidget
(
)
;
}
}
mAttachedToParent
=
false
;
}
nsView
*
nsDocumentViewer
:
:
FindContainerView
(
)
{
if
(
!
mContainer
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
(
mContainer
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
pwin
(
docShell
-
>
GetWindow
(
)
)
;
if
(
!
pwin
)
{
return
nullptr
;
}
nsCOMPtr
<
Element
>
containerElement
=
pwin
-
>
GetFrameElementInternal
(
)
;
if
(
!
containerElement
)
{
return
nullptr
;
}
nsIFrame
*
subdocFrame
=
nsLayoutUtils
:
:
GetRealPrimaryFrameFor
(
containerElement
)
;
if
(
!
subdocFrame
)
{
LAYOUT_WARNING
(
"
Subdocument
container
has
no
frame
"
)
;
return
nullptr
;
}
if
(
!
subdocFrame
-
>
IsSubDocumentFrame
(
)
)
{
NS_WARNING_ASSERTION
(
subdocFrame
-
>
Type
(
)
=
=
LayoutFrameType
:
:
None
"
Subdocument
container
has
non
-
subdocument
frame
"
)
;
return
nullptr
;
}
NS_ASSERTION
(
subdocFrame
-
>
GetView
(
)
"
Subdoc
frames
must
have
views
"
)
;
return
static_cast
<
nsSubDocumentFrame
*
>
(
subdocFrame
)
-
>
EnsureInnerView
(
)
;
}
nsresult
nsDocumentViewer
:
:
CreateDeviceContext
(
nsView
*
aContainerView
)
{
MOZ_ASSERT
(
!
mPresShell
&
&
!
mWindow
"
This
will
screw
up
our
existing
presentation
"
)
;
MOZ_ASSERT
(
mDocument
"
Gotta
have
a
document
here
"
)
;
Document
*
doc
=
mDocument
-
>
GetDisplayDocument
(
)
;
if
(
doc
)
{
NS_ASSERTION
(
!
aContainerView
"
External
resource
document
embedded
somewhere
?
"
)
;
nsPresContext
*
ctx
=
doc
-
>
GetPresContext
(
)
;
if
(
ctx
)
{
mDeviceContext
=
ctx
-
>
DeviceContext
(
)
;
return
NS_OK
;
}
}
nsIWidget
*
widget
=
nullptr
;
if
(
aContainerView
)
{
widget
=
aContainerView
-
>
GetNearestWidget
(
nullptr
)
;
}
if
(
!
widget
)
{
widget
=
mParentWidget
;
}
if
(
widget
)
{
widget
=
widget
-
>
GetTopLevelWidget
(
)
;
}
mDeviceContext
=
new
nsDeviceContext
(
)
;
mDeviceContext
-
>
Init
(
widget
)
;
return
NS_OK
;
}
mozilla
:
:
dom
:
:
Selection
*
nsDocumentViewer
:
:
GetDocumentSelection
(
)
{
if
(
!
mPresShell
)
{
return
nullptr
;
}
return
mPresShell
-
>
GetCurrentSelection
(
SelectionType
:
:
eNormal
)
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
ClearSelection
(
)
{
RefPtr
<
mozilla
:
:
dom
:
:
Selection
>
selection
=
GetDocumentSelection
(
)
;
if
(
!
selection
)
{
return
NS_ERROR_FAILURE
;
}
ErrorResult
rv
;
selection
-
>
CollapseToStart
(
rv
)
;
return
rv
.
StealNSResult
(
)
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
SelectAll
(
)
{
RefPtr
<
mozilla
:
:
dom
:
:
Selection
>
selection
=
GetDocumentSelection
(
)
;
if
(
!
selection
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
mDocument
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsINode
>
bodyNode
;
if
(
mDocument
-
>
IsHTMLOrXHTML
(
)
)
{
bodyNode
=
mDocument
-
>
GetBody
(
)
;
}
else
{
bodyNode
=
mDocument
-
>
GetRootElement
(
)
;
}
if
(
!
bodyNode
)
return
NS_ERROR_FAILURE
;
ErrorResult
err
;
selection
-
>
RemoveAllRanges
(
err
)
;
if
(
err
.
Failed
(
)
)
{
return
err
.
StealNSResult
(
)
;
}
mozilla
:
:
dom
:
:
Selection
:
:
AutoUserInitiated
userSelection
(
selection
)
;
selection
-
>
SelectAllChildren
(
*
bodyNode
err
)
;
return
err
.
StealNSResult
(
)
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
CopySelection
(
)
{
nsCopySupport
:
:
FireClipboardEvent
(
eCopy
nsIClipboard
:
:
kGlobalClipboard
mPresShell
nullptr
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
CopyLinkLocation
(
)
{
NS_ENSURE_TRUE
(
mPresShell
NS_ERROR_NOT_INITIALIZED
)
;
nsCOMPtr
<
nsINode
>
node
=
GetPopupLinkNode
(
)
;
NS_ENSURE_TRUE
(
node
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
dom
:
:
Element
>
elm
(
do_QueryInterface
(
node
)
)
;
NS_ENSURE_TRUE
(
elm
NS_ERROR_FAILURE
)
;
nsAutoString
locationText
;
nsContentUtils
:
:
GetLinkLocation
(
elm
locationText
)
;
if
(
locationText
.
IsEmpty
(
)
)
return
NS_ERROR_FAILURE
;
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIClipboardHelper
>
clipboard
(
do_GetService
(
"
mozilla
.
org
/
widget
/
clipboardhelper
;
1
"
&
rv
)
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
clipboard
-
>
CopyString
(
locationText
)
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
CopyImage
(
int32_t
aCopyFlags
)
{
NS_ENSURE_TRUE
(
mPresShell
NS_ERROR_NOT_INITIALIZED
)
;
nsCOMPtr
<
nsIImageLoadingContent
>
node
=
GetPopupImageNode
(
)
;
NS_ENSURE_TRUE
(
node
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsILoadContext
>
loadContext
(
mContainer
)
;
return
nsCopySupport
:
:
ImageCopy
(
node
loadContext
aCopyFlags
)
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetCopyable
(
bool
*
aCopyable
)
{
NS_ENSURE_ARG_POINTER
(
aCopyable
)
;
*
aCopyable
=
nsCopySupport
:
:
CanCopy
(
mDocument
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetContents
(
const
char
*
mimeType
bool
selectionOnly
nsAString
&
aOutValue
)
{
aOutValue
.
Truncate
(
)
;
NS_ENSURE_TRUE
(
mPresShell
NS_ERROR_NOT_INITIALIZED
)
;
NS_ENSURE_TRUE
(
mDocument
NS_ERROR_NOT_INITIALIZED
)
;
RefPtr
<
Selection
>
sel
;
if
(
selectionOnly
)
{
nsCopySupport
:
:
GetSelectionForCopy
(
mDocument
getter_AddRefs
(
sel
)
)
;
NS_ENSURE_TRUE
(
sel
NS_ERROR_FAILURE
)
;
if
(
sel
-
>
IsCollapsed
(
)
)
{
return
NS_OK
;
}
}
return
nsCopySupport
:
:
GetContents
(
nsDependentCString
(
mimeType
)
0
sel
mDocument
aOutValue
)
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetCanGetContents
(
bool
*
aCanGetContents
)
{
NS_ENSURE_ARG_POINTER
(
aCanGetContents
)
;
*
aCanGetContents
=
false
;
NS_ENSURE_STATE
(
mDocument
)
;
*
aCanGetContents
=
nsCopySupport
:
:
CanCopy
(
mDocument
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
SetCommandNode
(
nsINode
*
aNode
)
{
Document
*
document
=
GetDocument
(
)
;
NS_ENSURE_STATE
(
document
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
(
document
-
>
GetWindow
(
)
)
;
NS_ENSURE_TRUE
(
window
NS_ERROR_NOT_AVAILABLE
)
;
nsCOMPtr
<
nsPIWindowRoot
>
root
=
window
-
>
GetTopWindowRoot
(
)
;
NS_ENSURE_STATE
(
root
)
;
root
-
>
SetPopupNode
(
aNode
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
ScrollToNode
(
nsINode
*
aNode
)
{
NS_ENSURE_ARG
(
aNode
)
;
NS_ENSURE_TRUE
(
mDocument
NS_ERROR_NOT_AVAILABLE
)
;
nsCOMPtr
<
nsIPresShell
>
presShell
=
GetPresShell
(
)
;
nsCOMPtr
<
nsIContent
>
content
(
do_QueryInterface
(
aNode
)
)
;
NS_ENSURE_TRUE
(
content
NS_ERROR_FAILURE
)
;
NS_ENSURE_SUCCESS
(
presShell
-
>
ScrollContentIntoView
(
content
nsIPresShell
:
:
ScrollAxis
(
nsIPresShell
:
:
SCROLL_TOP
nsIPresShell
:
:
SCROLL_ALWAYS
)
nsIPresShell
:
:
ScrollAxis
(
)
nsIPresShell
:
:
SCROLL_OVERFLOW_HIDDEN
)
NS_ERROR_FAILURE
)
;
return
NS_OK
;
}
void
nsDocumentViewer
:
:
CallChildren
(
CallChildFunc
aFunc
void
*
aClosure
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
(
mContainer
)
;
if
(
docShell
)
{
int32_t
i
;
int32_t
n
;
docShell
-
>
GetChildCount
(
&
n
)
;
for
(
i
=
0
;
i
<
n
;
i
+
+
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
child
;
docShell
-
>
GetChildAt
(
i
getter_AddRefs
(
child
)
)
;
nsCOMPtr
<
nsIDocShell
>
childAsShell
(
do_QueryInterface
(
child
)
)
;
NS_ASSERTION
(
childAsShell
"
null
child
in
docshell
"
)
;
if
(
childAsShell
)
{
nsCOMPtr
<
nsIContentViewer
>
childCV
;
childAsShell
-
>
GetContentViewer
(
getter_AddRefs
(
childCV
)
)
;
if
(
childCV
)
{
(
*
aFunc
)
(
childCV
aClosure
)
;
}
}
}
}
}
static
void
ChangeChildPaintingEnabled
(
nsIContentViewer
*
aChild
void
*
aClosure
)
{
bool
*
enablePainting
=
(
bool
*
)
aClosure
;
if
(
*
enablePainting
)
{
aChild
-
>
ResumePainting
(
)
;
}
else
{
aChild
-
>
PausePainting
(
)
;
}
}
struct
ZoomInfo
{
float
mZoom
;
}
;
static
void
SetChildTextZoom
(
nsIContentViewer
*
aChild
void
*
aClosure
)
{
struct
ZoomInfo
*
ZoomInfo
=
(
struct
ZoomInfo
*
)
aClosure
;
aChild
-
>
SetTextZoom
(
ZoomInfo
-
>
mZoom
)
;
}
static
void
SetChildFullZoom
(
nsIContentViewer
*
aChild
void
*
aClosure
)
{
struct
ZoomInfo
*
ZoomInfo
=
(
struct
ZoomInfo
*
)
aClosure
;
aChild
-
>
SetFullZoom
(
ZoomInfo
-
>
mZoom
)
;
}
static
void
SetChildOverrideDPPX
(
nsIContentViewer
*
aChild
void
*
aClosure
)
{
struct
ZoomInfo
*
ZoomInfo
=
(
struct
ZoomInfo
*
)
aClosure
;
aChild
-
>
SetOverrideDPPX
(
ZoomInfo
-
>
mZoom
)
;
}
static
bool
SetExtResourceTextZoom
(
Document
*
aDocument
void
*
aClosure
)
{
nsPresContext
*
ctxt
=
aDocument
-
>
GetPresContext
(
)
;
if
(
ctxt
)
{
struct
ZoomInfo
*
ZoomInfo
=
static_cast
<
struct
ZoomInfo
*
>
(
aClosure
)
;
ctxt
-
>
SetTextZoom
(
ZoomInfo
-
>
mZoom
)
;
}
return
true
;
}
static
bool
SetExtResourceFullZoom
(
Document
*
aDocument
void
*
aClosure
)
{
nsPresContext
*
ctxt
=
aDocument
-
>
GetPresContext
(
)
;
if
(
ctxt
)
{
struct
ZoomInfo
*
ZoomInfo
=
static_cast
<
struct
ZoomInfo
*
>
(
aClosure
)
;
ctxt
-
>
SetFullZoom
(
ZoomInfo
-
>
mZoom
)
;
}
return
true
;
}
static
bool
SetExtResourceOverrideDPPX
(
Document
*
aDocument
void
*
aClosure
)
{
nsPresContext
*
ctxt
=
aDocument
-
>
GetPresContext
(
)
;
if
(
ctxt
)
{
struct
ZoomInfo
*
ZoomInfo
=
static_cast
<
struct
ZoomInfo
*
>
(
aClosure
)
;
ctxt
-
>
SetOverrideDPPX
(
ZoomInfo
-
>
mZoom
)
;
}
return
true
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
SetTextZoom
(
float
aTextZoom
)
{
if
(
!
mDocument
)
{
return
NS_ERROR_FAILURE
;
}
if
(
GetIsPrintPreview
(
)
)
{
return
NS_OK
;
}
bool
textZoomChange
=
(
mTextZoom
!
=
aTextZoom
)
;
mTextZoom
=
aTextZoom
;
struct
ZoomInfo
ZoomInfo
=
{
aTextZoom
}
;
CallChildren
(
SetChildTextZoom
&
ZoomInfo
)
;
nsPresContext
*
pc
=
GetPresContext
(
)
;
if
(
pc
&
&
aTextZoom
!
=
mPresContext
-
>
TextZoom
(
)
)
{
pc
-
>
SetTextZoom
(
aTextZoom
)
;
}
mDocument
-
>
EnumerateExternalResources
(
SetExtResourceTextZoom
&
ZoomInfo
)
;
if
(
textZoomChange
)
{
nsContentUtils
:
:
DispatchChromeEvent
(
mDocument
ToSupports
(
mDocument
)
NS_LITERAL_STRING
(
"
TextZoomChange
"
)
CanBubble
:
:
eYes
Cancelable
:
:
eYes
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetTextZoom
(
float
*
aTextZoom
)
{
NS_ENSURE_ARG_POINTER
(
aTextZoom
)
;
nsPresContext
*
pc
=
GetPresContext
(
)
;
*
aTextZoom
=
pc
?
pc
-
>
TextZoom
(
)
:
1
.
0f
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetEffectiveTextZoom
(
float
*
aEffectiveTextZoom
)
{
NS_ENSURE_ARG_POINTER
(
aEffectiveTextZoom
)
;
nsPresContext
*
pc
=
GetPresContext
(
)
;
*
aEffectiveTextZoom
=
pc
?
pc
-
>
EffectiveTextZoom
(
)
:
1
.
0f
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
SetFullZoom
(
float
aFullZoom
)
{
#
ifdef
NS_PRINT_PREVIEW
if
(
GetIsPrintPreview
(
)
)
{
nsPresContext
*
pc
=
GetPresContext
(
)
;
NS_ENSURE_TRUE
(
pc
NS_OK
)
;
nsCOMPtr
<
nsIPresShell
>
shell
=
pc
-
>
GetPresShell
(
)
;
NS_ENSURE_TRUE
(
shell
NS_OK
)
;
if
(
!
mPrintPreviewZoomed
)
{
mOriginalPrintPreviewScale
=
pc
-
>
GetPrintPreviewScale
(
)
;
mPrintPreviewZoomed
=
true
;
}
mPrintPreviewZoom
=
aFullZoom
;
pc
-
>
SetPrintPreviewScale
(
aFullZoom
*
mOriginalPrintPreviewScale
)
;
nsIPageSequenceFrame
*
pf
=
shell
-
>
GetPageSequenceFrame
(
)
;
if
(
pf
)
{
nsIFrame
*
f
=
do_QueryFrame
(
pf
)
;
shell
-
>
FrameNeedsReflow
(
f
nsIPresShell
:
:
eResize
NS_FRAME_IS_DIRTY
)
;
}
nsIFrame
*
rootFrame
=
shell
-
>
GetRootFrame
(
)
;
if
(
rootFrame
)
{
rootFrame
-
>
InvalidateFrame
(
)
;
}
return
NS_OK
;
}
#
endif
if
(
!
mDocument
)
{
return
NS_ERROR_FAILURE
;
}
bool
fullZoomChange
=
(
mPageZoom
!
=
aFullZoom
)
;
mPageZoom
=
aFullZoom
;
struct
ZoomInfo
ZoomInfo
=
{
aFullZoom
}
;
CallChildren
(
SetChildFullZoom
&
ZoomInfo
)
;
nsPresContext
*
pc
=
GetPresContext
(
)
;
if
(
pc
)
{
pc
-
>
SetFullZoom
(
aFullZoom
)
;
}
mDocument
-
>
EnumerateExternalResources
(
SetExtResourceFullZoom
&
ZoomInfo
)
;
if
(
fullZoomChange
)
{
nsContentUtils
:
:
DispatchChromeEvent
(
mDocument
ToSupports
(
mDocument
)
NS_LITERAL_STRING
(
"
FullZoomChange
"
)
CanBubble
:
:
eYes
Cancelable
:
:
eYes
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetFullZoom
(
float
*
aFullZoom
)
{
NS_ENSURE_ARG_POINTER
(
aFullZoom
)
;
#
ifdef
NS_PRINT_PREVIEW
if
(
GetIsPrintPreview
(
)
)
{
*
aFullZoom
=
mPrintPreviewZoom
;
return
NS_OK
;
}
#
endif
nsPresContext
*
pc
=
GetPresContext
(
)
;
*
aFullZoom
=
pc
?
pc
-
>
GetFullZoom
(
)
:
mPageZoom
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetDeviceFullZoom
(
float
*
aDeviceFullZoom
)
{
NS_ENSURE_ARG_POINTER
(
aDeviceFullZoom
)
;
#
ifdef
NS_PRINT_PREVIEW
if
(
GetIsPrintPreview
(
)
)
{
*
aDeviceFullZoom
=
mPrintPreviewZoom
;
return
NS_OK
;
}
#
endif
nsPresContext
*
pc
=
GetPresContext
(
)
;
*
aDeviceFullZoom
=
pc
?
pc
-
>
GetDeviceFullZoom
(
)
:
mPageZoom
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
SetOverrideDPPX
(
float
aDPPX
)
{
if
(
!
mDocument
)
{
return
NS_ERROR_FAILURE
;
}
mOverrideDPPX
=
aDPPX
;
struct
ZoomInfo
ZoomInfo
=
{
aDPPX
}
;
CallChildren
(
SetChildOverrideDPPX
&
ZoomInfo
)
;
nsPresContext
*
pc
=
GetPresContext
(
)
;
if
(
pc
)
{
pc
-
>
SetOverrideDPPX
(
aDPPX
)
;
}
mDocument
-
>
EnumerateExternalResources
(
SetExtResourceOverrideDPPX
&
ZoomInfo
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetOverrideDPPX
(
float
*
aDPPX
)
{
NS_ENSURE_ARG_POINTER
(
aDPPX
)
;
nsPresContext
*
pc
=
GetPresContext
(
)
;
*
aDPPX
=
pc
?
pc
-
>
GetOverrideDPPX
(
)
:
mOverrideDPPX
;
return
NS_OK
;
}
static
void
SetChildAuthorStyleDisabled
(
nsIContentViewer
*
aChild
void
*
aClosure
)
{
bool
styleDisabled
=
*
static_cast
<
bool
*
>
(
aClosure
)
;
aChild
-
>
SetAuthorStyleDisabled
(
styleDisabled
)
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
SetAuthorStyleDisabled
(
bool
aStyleDisabled
)
{
if
(
mPresShell
)
{
mPresShell
-
>
SetAuthorStyleDisabled
(
aStyleDisabled
)
;
}
CallChildren
(
SetChildAuthorStyleDisabled
&
aStyleDisabled
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetAuthorStyleDisabled
(
bool
*
aStyleDisabled
)
{
if
(
mPresShell
)
{
*
aStyleDisabled
=
mPresShell
-
>
GetAuthorStyleDisabled
(
)
;
}
else
{
*
aStyleDisabled
=
false
;
}
return
NS_OK
;
}
static
bool
ExtResourceEmulateMedium
(
Document
*
aDocument
void
*
aClosure
)
{
nsPresContext
*
ctxt
=
aDocument
-
>
GetPresContext
(
)
;
if
(
ctxt
)
{
const
nsAString
*
mediaType
=
static_cast
<
nsAString
*
>
(
aClosure
)
;
ctxt
-
>
EmulateMedium
(
*
mediaType
)
;
}
return
true
;
}
static
void
ChildEmulateMedium
(
nsIContentViewer
*
aChild
void
*
aClosure
)
{
const
nsAString
*
mediaType
=
static_cast
<
nsAString
*
>
(
aClosure
)
;
aChild
-
>
EmulateMedium
(
*
mediaType
)
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
EmulateMedium
(
const
nsAString
&
aMediaType
)
{
if
(
mPresContext
)
{
mPresContext
-
>
EmulateMedium
(
aMediaType
)
;
}
CallChildren
(
ChildEmulateMedium
const_cast
<
nsAString
*
>
(
&
aMediaType
)
)
;
if
(
mDocument
)
{
mDocument
-
>
EnumerateExternalResources
(
ExtResourceEmulateMedium
const_cast
<
nsAString
*
>
(
&
aMediaType
)
)
;
}
return
NS_OK
;
}
static
bool
ExtResourceStopEmulatingMedium
(
Document
*
aDocument
void
*
aClosure
)
{
nsPresContext
*
ctxt
=
aDocument
-
>
GetPresContext
(
)
;
if
(
ctxt
)
{
ctxt
-
>
StopEmulatingMedium
(
)
;
}
return
true
;
}
static
void
ChildStopEmulatingMedium
(
nsIContentViewer
*
aChild
void
*
aClosure
)
{
aChild
-
>
StopEmulatingMedium
(
)
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
StopEmulatingMedium
(
)
{
if
(
mPresContext
)
{
mPresContext
-
>
StopEmulatingMedium
(
)
;
}
CallChildren
(
ChildStopEmulatingMedium
nullptr
)
;
if
(
mDocument
)
{
mDocument
-
>
EnumerateExternalResources
(
ExtResourceStopEmulatingMedium
nullptr
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetForceCharacterSet
(
nsACString
&
aForceCharacterSet
)
{
auto
encoding
=
nsDocumentViewer
:
:
GetForceCharset
(
)
;
if
(
encoding
)
{
encoding
-
>
Name
(
aForceCharacterSet
)
;
}
else
{
aForceCharacterSet
.
Truncate
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP_
(
const
Encoding
*
)
nsDocumentViewer
:
:
GetForceCharset
(
)
{
return
mForceCharacterSet
;
}
static
void
SetChildForceCharacterSet
(
nsIContentViewer
*
aChild
void
*
aClosure
)
{
auto
encoding
=
static_cast
<
const
Encoding
*
>
(
aClosure
)
;
aChild
-
>
SetForceCharset
(
encoding
)
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
SetForceCharacterSet
(
const
nsACString
&
aForceCharacterSet
)
{
const
Encoding
*
encoding
=
nullptr
;
if
(
!
aForceCharacterSet
.
IsEmpty
(
)
)
{
if
(
!
(
encoding
=
Encoding
:
:
ForLabel
(
aForceCharacterSet
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
}
nsDocumentViewer
:
:
SetForceCharset
(
encoding
)
;
return
NS_OK
;
}
NS_IMETHODIMP_
(
void
)
nsDocumentViewer
:
:
SetForceCharset
(
const
Encoding
*
aEncoding
)
{
mForceCharacterSet
=
aEncoding
;
CallChildren
(
SetChildForceCharacterSet
(
void
*
)
aEncoding
)
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetHintCharacterSet
(
nsACString
&
aHintCharacterSet
)
{
auto
encoding
=
nsDocumentViewer
:
:
GetHintCharset
(
)
;
if
(
encoding
)
{
encoding
-
>
Name
(
aHintCharacterSet
)
;
}
else
{
aHintCharacterSet
.
Truncate
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP_
(
const
Encoding
*
)
nsDocumentViewer
:
:
GetHintCharset
(
)
{
if
(
kCharsetUninitialized
=
=
mHintCharsetSource
)
{
return
nullptr
;
}
return
mHintCharset
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetHintCharacterSetSource
(
int32_t
*
aHintCharacterSetSource
)
{
NS_ENSURE_ARG_POINTER
(
aHintCharacterSetSource
)
;
*
aHintCharacterSetSource
=
mHintCharsetSource
;
return
NS_OK
;
}
static
void
SetChildHintCharacterSetSource
(
nsIContentViewer
*
aChild
void
*
aClosure
)
{
aChild
-
>
SetHintCharacterSetSource
(
NS_PTR_TO_INT32
(
aClosure
)
)
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
SetHintCharacterSetSource
(
int32_t
aHintCharacterSetSource
)
{
mHintCharsetSource
=
aHintCharacterSetSource
;
CallChildren
(
SetChildHintCharacterSetSource
NS_INT32_TO_PTR
(
aHintCharacterSetSource
)
)
;
return
NS_OK
;
}
static
void
SetChildHintCharacterSet
(
nsIContentViewer
*
aChild
void
*
aClosure
)
{
auto
encoding
=
static_cast
<
const
Encoding
*
>
(
aClosure
)
;
aChild
-
>
SetHintCharset
(
encoding
)
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
SetHintCharacterSet
(
const
nsACString
&
aHintCharacterSet
)
{
const
Encoding
*
encoding
=
nullptr
;
if
(
!
aHintCharacterSet
.
IsEmpty
(
)
)
{
if
(
!
(
encoding
=
Encoding
:
:
ForLabel
(
aHintCharacterSet
)
)
)
{
return
NS_ERROR_INVALID_ARG
;
}
}
nsDocumentViewer
:
:
SetHintCharset
(
encoding
)
;
return
NS_OK
;
}
NS_IMETHODIMP_
(
void
)
nsDocumentViewer
:
:
SetHintCharset
(
const
Encoding
*
aEncoding
)
{
mHintCharset
=
aEncoding
;
CallChildren
(
SetChildHintCharacterSet
(
void
*
)
aEncoding
)
;
}
static
void
AppendChildSubtree
(
nsIContentViewer
*
aChild
void
*
aClosure
)
{
nsTArray
<
nsCOMPtr
<
nsIContentViewer
>
>
&
array
=
*
static_cast
<
nsTArray
<
nsCOMPtr
<
nsIContentViewer
>
>
*
>
(
aClosure
)
;
aChild
-
>
AppendSubtree
(
array
)
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
AppendSubtree
(
nsTArray
<
nsCOMPtr
<
nsIContentViewer
>
>
&
aArray
)
{
aArray
.
AppendElement
(
this
)
;
CallChildren
(
AppendChildSubtree
&
aArray
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
PausePainting
(
)
{
bool
enablePaint
=
false
;
CallChildren
(
ChangeChildPaintingEnabled
&
enablePaint
)
;
nsIPresShell
*
presShell
=
GetPresShell
(
)
;
if
(
presShell
)
{
presShell
-
>
PausePainting
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
ResumePainting
(
)
{
bool
enablePaint
=
true
;
CallChildren
(
ChangeChildPaintingEnabled
&
enablePaint
)
;
nsIPresShell
*
presShell
=
GetPresShell
(
)
;
if
(
presShell
)
{
presShell
-
>
ResumePainting
(
)
;
}
return
NS_OK
;
}
nsresult
nsDocumentViewer
:
:
GetContentSizeInternal
(
int32_t
*
aWidth
int32_t
*
aHeight
nscoord
aMaxWidth
nscoord
aMaxHeight
)
{
NS_ENSURE_TRUE
(
mDocument
NS_ERROR_NOT_AVAILABLE
)
;
nsCOMPtr
<
nsIPresShell
>
presShell
=
GetPresShell
(
)
;
NS_ENSURE_TRUE
(
presShell
NS_ERROR_FAILURE
)
;
mDocument
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
nsIFrame
*
root
=
presShell
-
>
GetRootFrame
(
)
;
NS_ENSURE_TRUE
(
root
NS_ERROR_FAILURE
)
;
nscoord
prefWidth
;
{
RefPtr
<
gfxContext
>
rcx
(
presShell
-
>
CreateReferenceRenderingContext
(
)
)
;
prefWidth
=
root
-
>
GetPrefISize
(
rcx
)
;
}
if
(
prefWidth
>
aMaxWidth
)
{
prefWidth
=
aMaxWidth
;
}
nsresult
rv
=
presShell
-
>
ResizeReflow
(
prefWidth
aMaxHeight
0
0
nsIPresShell
:
:
ResizeReflowOptions
:
:
eBSizeLimit
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
RefPtr
<
nsPresContext
>
presContext
=
GetPresContext
(
)
;
NS_ENSURE_TRUE
(
presContext
NS_ERROR_FAILURE
)
;
nsRect
shellArea
=
presContext
-
>
GetVisibleArea
(
)
;
NS_ENSURE_TRUE
(
shellArea
.
width
!
=
NS_UNCONSTRAINEDSIZE
&
&
shellArea
.
height
!
=
NS_UNCONSTRAINEDSIZE
NS_ERROR_FAILURE
)
;
*
aWidth
=
presContext
-
>
AppUnitsToDevPixels
(
shellArea
.
width
)
;
*
aHeight
=
presContext
-
>
AppUnitsToDevPixels
(
shellArea
.
height
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetContentSize
(
int32_t
*
aWidth
int32_t
*
aHeight
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
docShellAsItem
(
mContainer
)
;
NS_ENSURE_TRUE
(
docShellAsItem
NS_ERROR_NOT_AVAILABLE
)
;
nsCOMPtr
<
nsIDocShellTreeItem
>
docShellParent
;
docShellAsItem
-
>
GetSameTypeParent
(
getter_AddRefs
(
docShellParent
)
)
;
NS_ENSURE_TRUE
(
!
docShellParent
NS_ERROR_FAILURE
)
;
return
GetContentSizeInternal
(
aWidth
aHeight
NS_UNCONSTRAINEDSIZE
NS_UNCONSTRAINEDSIZE
)
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetContentSizeConstrained
(
int32_t
aMaxWidth
int32_t
aMaxHeight
int32_t
*
aWidth
int32_t
*
aHeight
)
{
RefPtr
<
nsPresContext
>
presContext
=
GetPresContext
(
)
;
NS_ENSURE_TRUE
(
presContext
NS_ERROR_FAILURE
)
;
nscoord
maxWidth
=
NS_UNCONSTRAINEDSIZE
;
nscoord
maxHeight
=
NS_UNCONSTRAINEDSIZE
;
if
(
aMaxWidth
>
0
)
{
maxWidth
=
presContext
-
>
DevPixelsToAppUnits
(
aMaxWidth
)
;
}
if
(
aMaxHeight
>
0
)
{
maxHeight
=
presContext
-
>
DevPixelsToAppUnits
(
aMaxHeight
)
;
}
return
GetContentSizeInternal
(
aWidth
aHeight
maxWidth
maxHeight
)
;
}
NS_IMPL_ISUPPORTS
(
nsDocViewerSelectionListener
nsISelectionListener
)
nsresult
nsDocViewerSelectionListener
:
:
Init
(
nsDocumentViewer
*
aDocViewer
)
{
mDocViewer
=
aDocViewer
;
return
NS_OK
;
}
already_AddRefed
<
nsINode
>
nsDocumentViewer
:
:
GetPopupNode
(
)
{
Document
*
document
=
GetDocument
(
)
;
NS_ENSURE_TRUE
(
document
nullptr
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
(
document
-
>
GetWindow
(
)
)
;
NS_ENSURE_TRUE
(
window
nullptr
)
;
if
(
window
)
{
nsCOMPtr
<
nsPIWindowRoot
>
root
=
window
-
>
GetTopWindowRoot
(
)
;
NS_ENSURE_TRUE
(
root
nullptr
)
;
nsCOMPtr
<
nsINode
>
node
=
root
-
>
GetPopupNode
(
)
;
#
ifdef
MOZ_XUL
if
(
!
node
)
{
nsPIDOMWindowOuter
*
rootWindow
=
root
-
>
GetWindow
(
)
;
if
(
rootWindow
)
{
nsCOMPtr
<
Document
>
rootDoc
=
rootWindow
-
>
GetExtantDoc
(
)
;
if
(
rootDoc
)
{
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
pm
)
{
node
=
pm
-
>
GetLastTriggerPopupNode
(
rootDoc
)
;
}
}
}
}
#
endif
return
node
.
forget
(
)
;
}
return
nullptr
;
}
already_AddRefed
<
nsINode
>
nsDocumentViewer
:
:
GetPopupLinkNode
(
)
{
nsCOMPtr
<
nsINode
>
node
=
GetPopupNode
(
)
;
while
(
node
)
{
nsCOMPtr
<
nsIContent
>
content
(
do_QueryInterface
(
node
)
)
;
if
(
content
)
{
nsCOMPtr
<
nsIURI
>
hrefURI
=
content
-
>
GetHrefURI
(
)
;
if
(
hrefURI
)
{
return
node
.
forget
(
)
;
}
}
node
=
node
-
>
GetParentNode
(
)
;
}
return
nullptr
;
}
already_AddRefed
<
nsIImageLoadingContent
>
nsDocumentViewer
:
:
GetPopupImageNode
(
)
{
nsCOMPtr
<
nsINode
>
node
=
GetPopupNode
(
)
;
nsCOMPtr
<
nsIImageLoadingContent
>
img
=
do_QueryInterface
(
node
)
;
return
img
.
forget
(
)
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetInLink
(
bool
*
aInLink
)
{
#
ifdef
DEBUG_dr
printf
(
"
dr
:
:
nsDocumentViewer
:
:
GetInLink
\
n
"
)
;
#
endif
NS_ENSURE_ARG_POINTER
(
aInLink
)
;
*
aInLink
=
false
;
nsCOMPtr
<
nsINode
>
node
=
GetPopupLinkNode
(
)
;
if
(
!
node
)
{
return
NS_ERROR_FAILURE
;
}
*
aInLink
=
true
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetInImage
(
bool
*
aInImage
)
{
#
ifdef
DEBUG_dr
printf
(
"
dr
:
:
nsDocumentViewer
:
:
GetInImage
\
n
"
)
;
#
endif
NS_ENSURE_ARG_POINTER
(
aInImage
)
;
*
aInImage
=
false
;
nsCOMPtr
<
nsIImageLoadingContent
>
node
=
GetPopupImageNode
(
)
;
if
(
!
node
)
{
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIURI
>
uri
;
node
-
>
GetCurrentURI
(
getter_AddRefs
(
uri
)
)
;
if
(
uri
)
{
*
aInImage
=
true
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocViewerSelectionListener
:
:
NotifySelectionChanged
(
Document
*
Selection
*
int16_t
aReason
)
{
if
(
!
mDocViewer
)
{
return
NS_OK
;
}
RefPtr
<
mozilla
:
:
dom
:
:
Selection
>
selection
=
mDocViewer
-
>
GetDocumentSelection
(
)
;
if
(
!
selection
)
{
return
NS_ERROR_FAILURE
;
}
Document
*
theDoc
=
mDocViewer
-
>
GetDocument
(
)
;
if
(
!
theDoc
)
return
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
domWindow
=
theDoc
-
>
GetWindow
(
)
;
if
(
!
domWindow
)
return
NS_ERROR_FAILURE
;
bool
selectionCollapsed
=
selection
-
>
IsCollapsed
(
)
;
if
(
mSelectionWasCollapsed
!
=
selectionCollapsed
)
{
domWindow
-
>
UpdateCommands
(
NS_LITERAL_STRING
(
"
select
"
)
selection
aReason
)
;
mSelectionWasCollapsed
=
selectionCollapsed
;
}
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
nsDocViewerFocusListener
nsIDOMEventListener
)
nsDocViewerFocusListener
:
:
nsDocViewerFocusListener
(
)
:
mDocViewer
(
nullptr
)
{
}
nsDocViewerFocusListener
:
:
~
nsDocViewerFocusListener
(
)
{
}
nsresult
nsDocViewerFocusListener
:
:
HandleEvent
(
Event
*
aEvent
)
{
NS_ENSURE_STATE
(
mDocViewer
)
;
nsCOMPtr
<
nsIPresShell
>
shell
=
mDocViewer
-
>
GetPresShell
(
)
;
NS_ENSURE_TRUE
(
shell
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsISelectionController
>
selCon
=
do_QueryInterface
(
shell
)
;
int16_t
selectionStatus
;
selCon
-
>
GetDisplaySelection
(
&
selectionStatus
)
;
nsAutoString
eventType
;
aEvent
-
>
GetType
(
eventType
)
;
if
(
eventType
.
EqualsLiteral
(
"
focus
"
)
)
{
if
(
selectionStatus
=
=
nsISelectionController
:
:
SELECTION_DISABLED
|
|
selectionStatus
=
=
nsISelectionController
:
:
SELECTION_HIDDEN
)
{
selCon
-
>
SetDisplaySelection
(
nsISelectionController
:
:
SELECTION_ON
)
;
selCon
-
>
RepaintSelection
(
nsISelectionController
:
:
SELECTION_NORMAL
)
;
}
}
else
{
MOZ_ASSERT
(
eventType
.
EqualsLiteral
(
"
blur
"
)
"
Unexpected
event
type
"
)
;
if
(
selectionStatus
=
=
nsISelectionController
:
:
SELECTION_ON
|
|
selectionStatus
=
=
nsISelectionController
:
:
SELECTION_ATTENTION
)
{
selCon
-
>
SetDisplaySelection
(
nsISelectionController
:
:
SELECTION_DISABLED
)
;
selCon
-
>
RepaintSelection
(
nsISelectionController
:
:
SELECTION_NORMAL
)
;
}
}
return
NS_OK
;
}
nsresult
nsDocViewerFocusListener
:
:
Init
(
nsDocumentViewer
*
aDocViewer
)
{
mDocViewer
=
aDocViewer
;
return
NS_OK
;
}
#
ifdef
NS_PRINTING
NS_IMETHODIMP
nsDocumentViewer
:
:
Print
(
nsIPrintSettings
*
aPrintSettings
nsIWebProgressListener
*
aWebProgressListener
)
{
if
(
mDocument
&
&
mDocument
-
>
IsXULDocument
(
)
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
mContainer
)
{
PR_PL
(
(
"
Container
was
destroyed
yet
we
are
still
trying
to
use
it
!
"
)
)
;
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
(
mContainer
)
;
NS_ENSURE_STATE
(
docShell
)
;
auto
busyFlags
=
docShell
-
>
GetBusyFlags
(
)
;
if
(
busyFlags
!
=
nsIDocShell
:
:
BUSY_FLAGS_NONE
&
&
busyFlags
&
nsIDocShell
:
:
BUSY_FLAGS_PAGE_LOADING
&
&
!
mPrintDocIsFullyLoaded
)
{
if
(
!
mPrintIsPending
)
{
mCachedPrintSettings
=
aPrintSettings
;
mCachedPrintWebProgressListner
=
aWebProgressListener
;
mPrintIsPending
=
true
;
}
PR_PL
(
(
"
Printing
Stopped
-
document
is
still
busy
!
"
)
)
;
return
NS_ERROR_GFX_PRINTER_DOC_IS_BUSY
;
}
if
(
!
mDocument
|
|
!
mDeviceContext
)
{
PR_PL
(
(
"
Can
'
t
Print
without
a
document
and
a
device
context
"
)
)
;
return
NS_ERROR_FAILURE
;
}
nsresult
rv
;
if
(
GetIsPrinting
(
)
)
{
rv
=
NS_ERROR_NOT_AVAILABLE
;
if
(
mPrintJob
)
{
mPrintJob
-
>
FirePrintingErrorEvent
(
rv
)
;
}
return
rv
;
}
MOZ_ASSERT
(
!
mAutoBeforeAndAfterPrint
"
We
don
'
t
want
to
dispatch
nested
beforeprint
/
afterprint
"
)
;
auto
autoBeforeAndAfterPrint
=
MakeUnique
<
AutoPrintEventDispatcher
>
(
mDocument
)
;
NS_ENSURE_STATE
(
!
GetIsPrinting
(
)
)
;
nsCOMPtr
<
nsIPluginDocument
>
pDoc
(
do_QueryInterface
(
mDocument
)
)
;
if
(
pDoc
)
return
pDoc
-
>
Print
(
)
;
RefPtr
<
nsPrintJob
>
printJob
=
mPrintJob
;
if
(
!
printJob
)
{
NS_ENSURE_STATE
(
mDeviceContext
)
;
printJob
=
new
nsPrintJob
(
)
;
rv
=
printJob
-
>
Initialize
(
this
mContainer
mDocument
float
(
AppUnitsPerCSSInch
(
)
)
/
float
(
mDeviceContext
-
>
AppUnitsPerDevPixel
(
)
)
/
mPageZoom
)
;
if
(
NS_FAILED
(
rv
)
)
{
printJob
-
>
Destroy
(
)
;
return
rv
;
}
mPrintJob
=
printJob
;
}
if
(
printJob
-
>
HasPrintCallbackCanvas
(
)
)
{
mAutoBeforeAndAfterPrint
=
std
:
:
move
(
autoBeforeAndAfterPrint
)
;
}
dom
:
:
Element
*
root
=
mDocument
-
>
GetRootElement
(
)
;
if
(
root
&
&
root
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
mozdisallowselectionprint
)
)
{
printJob
-
>
SetDisallowSelectionPrint
(
true
)
;
}
rv
=
printJob
-
>
Print
(
aPrintSettings
aWebProgressListener
)
;
if
(
NS_FAILED
(
rv
)
)
{
OnDonePrinting
(
)
;
}
return
rv
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
PrintPreview
(
nsIPrintSettings
*
aPrintSettings
mozIDOMWindowProxy
*
aChildDOMWin
nsIWebProgressListener
*
aWebProgressListener
)
{
#
if
defined
(
NS_PRINTING
)
&
&
defined
(
NS_PRINT_PREVIEW
)
MOZ_ASSERT
(
IsInitializedForPrintPreview
(
)
"
For
print
preview
nsIWebBrowserPrint
must
be
from
"
"
docshell
.
printPreview
!
"
)
;
NS_ENSURE_ARG_POINTER
(
aChildDOMWin
)
;
nsresult
rv
=
NS_OK
;
if
(
GetIsPrinting
(
)
)
{
nsPrintJob
:
:
CloseProgressDialog
(
aWebProgressListener
)
;
return
NS_ERROR_FAILURE
;
}
if
(
mDocument
&
&
mDocument
-
>
IsXULDocument
(
)
)
{
nsPrintJob
:
:
CloseProgressDialog
(
aWebProgressListener
)
;
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
(
mContainer
)
;
if
(
!
docShell
|
|
!
mDeviceContext
)
{
PR_PL
(
(
"
Can
'
t
Print
Preview
without
device
context
and
docshell
"
)
)
;
return
NS_ERROR_FAILURE
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
do_QueryInterface
(
aChildDOMWin
)
;
MOZ_ASSERT
(
window
)
;
nsCOMPtr
<
Document
>
doc
=
window
-
>
GetDoc
(
)
;
NS_ENSURE_STATE
(
doc
)
;
UniquePtr
<
AutoPrintEventDispatcher
>
autoBeforeAndAfterPrint
;
if
(
!
mAutoBeforeAndAfterPrint
)
{
autoBeforeAndAfterPrint
=
MakeUnique
<
AutoPrintEventDispatcher
>
(
doc
)
;
}
NS_ENSURE_STATE
(
!
GetIsPrinting
(
)
)
;
NS_ENSURE_STATE
(
mContainer
)
;
NS_ENSURE_STATE
(
mDeviceContext
)
;
RefPtr
<
nsPrintJob
>
printJob
=
mPrintJob
;
if
(
!
printJob
)
{
printJob
=
new
nsPrintJob
(
)
;
rv
=
printJob
-
>
Initialize
(
this
mContainer
doc
float
(
AppUnitsPerCSSInch
(
)
)
/
float
(
mDeviceContext
-
>
AppUnitsPerDevPixel
(
)
)
/
mPageZoom
)
;
if
(
NS_FAILED
(
rv
)
)
{
printJob
-
>
Destroy
(
)
;
return
rv
;
}
mPrintJob
=
printJob
;
}
if
(
autoBeforeAndAfterPrint
&
&
printJob
-
>
HasPrintCallbackCanvas
(
)
)
{
mAutoBeforeAndAfterPrint
=
std
:
:
move
(
autoBeforeAndAfterPrint
)
;
}
dom
:
:
Element
*
root
=
doc
-
>
GetRootElement
(
)
;
if
(
root
&
&
root
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
mozdisallowselectionprint
)
)
{
PR_PL
(
(
"
PrintPreview
:
found
mozdisallowselectionprint
"
)
)
;
printJob
-
>
SetDisallowSelectionPrint
(
true
)
;
}
rv
=
printJob
-
>
PrintPreview
(
aPrintSettings
aChildDOMWin
aWebProgressListener
)
;
mPrintPreviewZoomed
=
false
;
if
(
NS_FAILED
(
rv
)
)
{
OnDonePrinting
(
)
;
}
return
rv
;
#
else
return
NS_ERROR_FAILURE
;
#
endif
}
NS_IMETHODIMP
nsDocumentViewer
:
:
PrintPreviewNavigate
(
int16_t
aType
int32_t
aPageNum
)
{
if
(
!
GetIsPrintPreview
(
)
|
|
mPrintJob
-
>
GetIsCreatingPrintPreview
(
)
)
return
NS_ERROR_FAILURE
;
nsIScrollableFrame
*
sf
=
mPrintJob
-
>
GetPrintPreviewPresShell
(
)
-
>
GetRootScrollFrameAsScrollable
(
)
;
if
(
!
sf
)
return
NS_OK
;
if
(
aType
=
=
nsIWebBrowserPrint
:
:
PRINTPREVIEW_HOME
|
|
(
aType
=
=
nsIWebBrowserPrint
:
:
PRINTPREVIEW_GOTO_PAGENUM
&
&
aPageNum
=
=
1
)
)
{
sf
-
>
ScrollTo
(
nsPoint
(
0
0
)
nsIScrollableFrame
:
:
INSTANT
)
;
return
NS_OK
;
}
nsIFrame
*
seqFrame
=
nullptr
;
int32_t
pageCount
=
0
;
if
(
NS_FAILED
(
mPrintJob
-
>
GetSeqFrameAndCountPages
(
seqFrame
pageCount
)
)
)
{
return
NS_ERROR_FAILURE
;
}
nsPoint
pt
=
sf
-
>
GetScrollPosition
(
)
;
int32_t
pageNum
=
1
;
nsIFrame
*
fndPageFrame
=
nullptr
;
nsIFrame
*
currentPage
=
nullptr
;
if
(
aType
=
=
nsIWebBrowserPrint
:
:
PRINTPREVIEW_END
)
{
aType
=
nsIWebBrowserPrint
:
:
PRINTPREVIEW_GOTO_PAGENUM
;
aPageNum
=
pageCount
;
}
for
(
nsIFrame
*
pageFrame
:
seqFrame
-
>
PrincipalChildList
(
)
)
{
nsRect
pageRect
=
pageFrame
-
>
GetRect
(
)
;
if
(
pageRect
.
Contains
(
pageRect
.
x
pt
.
y
)
)
{
currentPage
=
pageFrame
;
}
if
(
pageNum
=
=
aPageNum
)
{
fndPageFrame
=
pageFrame
;
break
;
}
pageNum
+
+
;
}
if
(
aType
=
=
nsIWebBrowserPrint
:
:
PRINTPREVIEW_PREV_PAGE
)
{
if
(
currentPage
)
{
fndPageFrame
=
currentPage
-
>
GetPrevInFlow
(
)
;
if
(
!
fndPageFrame
)
{
return
NS_OK
;
}
}
else
{
return
NS_OK
;
}
}
else
if
(
aType
=
=
nsIWebBrowserPrint
:
:
PRINTPREVIEW_NEXT_PAGE
)
{
if
(
currentPage
)
{
fndPageFrame
=
currentPage
-
>
GetNextInFlow
(
)
;
if
(
!
fndPageFrame
)
{
return
NS_OK
;
}
}
else
{
return
NS_OK
;
}
}
else
{
if
(
aPageNum
<
0
|
|
aPageNum
>
pageCount
)
{
return
NS_OK
;
}
}
if
(
fndPageFrame
)
{
nscoord
newYPosn
=
nscoord
(
mPrintJob
-
>
GetPrintPreviewScale
(
)
*
fndPageFrame
-
>
GetPosition
(
)
.
y
)
;
sf
-
>
ScrollTo
(
nsPoint
(
pt
.
x
newYPosn
)
nsIScrollableFrame
:
:
INSTANT
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetGlobalPrintSettings
(
nsIPrintSettings
*
*
aGlobalPrintSettings
)
{
return
nsPrintJob
:
:
GetGlobalPrintSettings
(
aGlobalPrintSettings
)
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetDoingPrint
(
bool
*
aDoingPrint
)
{
NS_ENSURE_ARG_POINTER
(
aDoingPrint
)
;
*
aDoingPrint
=
false
;
if
(
mPrintJob
)
{
return
mPrintJob
-
>
GetDoingPrintPreview
(
aDoingPrint
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetDoingPrintPreview
(
bool
*
aDoingPrintPreview
)
{
NS_ENSURE_ARG_POINTER
(
aDoingPrintPreview
)
;
*
aDoingPrintPreview
=
false
;
if
(
mPrintJob
)
{
return
mPrintJob
-
>
GetDoingPrintPreview
(
aDoingPrintPreview
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetCurrentPrintSettings
(
nsIPrintSettings
*
*
aCurrentPrintSettings
)
{
NS_ENSURE_ARG_POINTER
(
aCurrentPrintSettings
)
;
*
aCurrentPrintSettings
=
nullptr
;
NS_ENSURE_TRUE
(
mPrintJob
NS_ERROR_FAILURE
)
;
return
mPrintJob
-
>
GetCurrentPrintSettings
(
aCurrentPrintSettings
)
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
Cancel
(
)
{
NS_ENSURE_TRUE
(
mPrintJob
NS_ERROR_FAILURE
)
;
return
mPrintJob
-
>
Cancelled
(
)
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
ExitPrintPreview
(
)
{
if
(
GetIsPrinting
(
)
)
return
NS_ERROR_FAILURE
;
NS_ENSURE_TRUE
(
mPrintJob
NS_ERROR_FAILURE
)
;
if
(
GetIsPrintPreview
(
)
)
{
ReturnToGalleyPresentation
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
EnumerateDocumentNames
(
uint32_t
*
aCount
char16_t
*
*
*
aResult
)
{
#
ifdef
NS_PRINTING
NS_ENSURE_ARG
(
aCount
)
;
NS_ENSURE_ARG_POINTER
(
aResult
)
;
NS_ENSURE_TRUE
(
mPrintJob
NS_ERROR_FAILURE
)
;
return
mPrintJob
-
>
EnumerateDocumentNames
(
aCount
aResult
)
;
#
else
return
NS_ERROR_FAILURE
;
#
endif
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetIsFramesetFrameSelected
(
bool
*
aIsFramesetFrameSelected
)
{
#
ifdef
NS_PRINTING
*
aIsFramesetFrameSelected
=
false
;
NS_ENSURE_TRUE
(
mPrintJob
NS_ERROR_FAILURE
)
;
return
mPrintJob
-
>
GetIsFramesetFrameSelected
(
aIsFramesetFrameSelected
)
;
#
else
return
NS_ERROR_FAILURE
;
#
endif
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetPrintPreviewNumPages
(
int32_t
*
aPrintPreviewNumPages
)
{
#
ifdef
NS_PRINTING
NS_ENSURE_ARG_POINTER
(
aPrintPreviewNumPages
)
;
NS_ENSURE_TRUE
(
mPrintJob
NS_ERROR_FAILURE
)
;
return
mPrintJob
-
>
GetPrintPreviewNumPages
(
aPrintPreviewNumPages
)
;
#
else
return
NS_ERROR_FAILURE
;
#
endif
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetIsFramesetDocument
(
bool
*
aIsFramesetDocument
)
{
#
ifdef
NS_PRINTING
*
aIsFramesetDocument
=
false
;
NS_ENSURE_TRUE
(
mPrintJob
NS_ERROR_FAILURE
)
;
return
mPrintJob
-
>
GetIsFramesetDocument
(
aIsFramesetDocument
)
;
#
else
return
NS_ERROR_FAILURE
;
#
endif
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetIsIFrameSelected
(
bool
*
aIsIFrameSelected
)
{
#
ifdef
NS_PRINTING
*
aIsIFrameSelected
=
false
;
NS_ENSURE_TRUE
(
mPrintJob
NS_ERROR_FAILURE
)
;
return
mPrintJob
-
>
GetIsIFrameSelected
(
aIsIFrameSelected
)
;
#
else
return
NS_ERROR_FAILURE
;
#
endif
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetIsRangeSelection
(
bool
*
aIsRangeSelection
)
{
#
ifdef
NS_PRINTING
*
aIsRangeSelection
=
false
;
NS_ENSURE_TRUE
(
mPrintJob
NS_ERROR_FAILURE
)
;
return
mPrintJob
-
>
GetIsRangeSelection
(
aIsRangeSelection
)
;
#
else
return
NS_ERROR_FAILURE
;
#
endif
}
void
nsDocumentViewer
:
:
SetIsPrintingInDocShellTree
(
nsIDocShellTreeItem
*
aParentNode
bool
aIsPrintingOrPP
bool
aStartAtTop
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
parentItem
(
aParentNode
)
;
if
(
aStartAtTop
)
{
if
(
aIsPrintingOrPP
)
{
while
(
parentItem
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
parent
;
parentItem
-
>
GetSameTypeParent
(
getter_AddRefs
(
parent
)
)
;
if
(
!
parent
)
{
break
;
}
parentItem
=
parent
;
}
mTopContainerWhilePrinting
=
do_GetWeakReference
(
parentItem
)
;
}
else
{
parentItem
=
do_QueryReferent
(
mTopContainerWhilePrinting
)
;
}
}
nsCOMPtr
<
nsIDocShell
>
viewerContainer
=
do_QueryInterface
(
parentItem
)
;
if
(
viewerContainer
)
{
viewerContainer
-
>
SetIsPrinting
(
aIsPrintingOrPP
)
;
}
if
(
!
aParentNode
)
{
return
;
}
int32_t
n
;
aParentNode
-
>
GetChildCount
(
&
n
)
;
for
(
int32_t
i
=
0
;
i
<
n
;
i
+
+
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
child
;
aParentNode
-
>
GetChildAt
(
i
getter_AddRefs
(
child
)
)
;
NS_ASSERTION
(
child
"
child
isn
'
t
nsIDocShell
"
)
;
if
(
child
)
{
SetIsPrintingInDocShellTree
(
child
aIsPrintingOrPP
false
)
;
}
}
}
#
endif
bool
nsDocumentViewer
:
:
ShouldAttachToTopLevel
(
)
{
if
(
!
mParentWidget
)
return
false
;
nsCOMPtr
<
nsIDocShellTreeItem
>
containerItem
(
mContainer
)
;
if
(
!
containerItem
)
return
false
;
if
(
nsIWidget
:
:
UsePuppetWidgets
(
)
)
return
true
;
#
if
defined
(
XP_WIN
)
|
|
defined
(
MOZ_WIDGET_GTK
)
|
|
\
defined
(
MOZ_WIDGET_ANDROID
)
|
|
defined
(
MOZ_WIDGET_UIKIT
)
nsWindowType
winType
=
mParentWidget
-
>
WindowType
(
)
;
if
(
(
winType
=
=
eWindowType_toplevel
|
|
winType
=
=
eWindowType_dialog
|
|
winType
=
=
eWindowType_invisible
)
&
&
containerItem
-
>
ItemType
(
)
=
=
nsIDocShellTreeItem
:
:
typeChrome
)
{
return
true
;
}
#
endif
return
false
;
}
bool
nsDocumentViewer
:
:
GetIsPrinting
(
)
{
#
ifdef
NS_PRINTING
if
(
mPrintJob
)
{
return
mPrintJob
-
>
GetIsPrinting
(
)
;
}
#
endif
return
false
;
}
void
nsDocumentViewer
:
:
SetIsPrinting
(
bool
aIsPrinting
)
{
#
ifdef
NS_PRINTING
nsCOMPtr
<
nsIDocShell
>
docShell
(
mContainer
)
;
if
(
docShell
|
|
!
aIsPrinting
)
{
SetIsPrintingInDocShellTree
(
docShell
aIsPrinting
true
)
;
}
else
{
NS_WARNING
(
"
Did
you
close
a
window
before
printing
?
"
)
;
}
if
(
!
aIsPrinting
)
{
mAutoBeforeAndAfterPrint
=
nullptr
;
}
#
endif
}
bool
nsDocumentViewer
:
:
GetIsPrintPreview
(
)
{
#
ifdef
NS_PRINTING
if
(
mPrintJob
)
{
return
mPrintJob
-
>
GetIsPrintPreview
(
)
;
}
#
endif
return
false
;
}
void
nsDocumentViewer
:
:
SetIsPrintPreview
(
bool
aIsPrintPreview
)
{
#
ifdef
NS_PRINTING
nsCOMPtr
<
nsIDocShell
>
docShell
(
mContainer
)
;
if
(
docShell
|
|
!
aIsPrintPreview
)
{
SetIsPrintingInDocShellTree
(
docShell
aIsPrintPreview
true
)
;
}
if
(
!
aIsPrintPreview
)
{
mAutoBeforeAndAfterPrint
=
nullptr
;
}
#
endif
nsAutoScriptBlocker
scriptBlocker
;
if
(
!
aIsPrintPreview
)
{
if
(
mPresShell
)
{
DestroyPresShell
(
)
;
}
mWindow
=
nullptr
;
mViewManager
=
nullptr
;
mPresContext
=
nullptr
;
mPresShell
=
nullptr
;
}
}
void
nsDocumentViewer
:
:
IncrementDestroyBlockedCount
(
)
{
+
+
mDestroyBlockedCount
;
}
void
nsDocumentViewer
:
:
DecrementDestroyBlockedCount
(
)
{
-
-
mDestroyBlockedCount
;
}
#
if
defined
(
NS_PRINTING
)
&
&
defined
(
NS_PRINT_PREVIEW
)
static
void
ResetFocusState
(
nsIDocShell
*
aDocShell
)
{
nsIFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
!
fm
)
return
;
nsCOMPtr
<
nsISimpleEnumerator
>
docShellEnumerator
;
aDocShell
-
>
GetDocShellEnumerator
(
nsIDocShellTreeItem
:
:
typeContent
nsIDocShell
:
:
ENUMERATE_FORWARDS
getter_AddRefs
(
docShellEnumerator
)
)
;
nsCOMPtr
<
nsISupports
>
currentContainer
;
bool
hasMoreDocShells
;
while
(
NS_SUCCEEDED
(
docShellEnumerator
-
>
HasMoreElements
(
&
hasMoreDocShells
)
)
&
&
hasMoreDocShells
)
{
docShellEnumerator
-
>
GetNext
(
getter_AddRefs
(
currentContainer
)
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
=
do_GetInterface
(
currentContainer
)
;
if
(
win
)
fm
-
>
ClearFocus
(
win
)
;
}
}
#
endif
void
nsDocumentViewer
:
:
ReturnToGalleyPresentation
(
)
{
#
if
defined
(
NS_PRINTING
)
&
&
defined
(
NS_PRINT_PREVIEW
)
if
(
!
GetIsPrintPreview
(
)
)
{
NS_ERROR
(
"
Wow
we
should
never
get
here
!
"
)
;
return
;
}
SetIsPrintPreview
(
false
)
;
mPrintJob
-
>
TurnScriptingOn
(
true
)
;
mPrintJob
-
>
Destroy
(
)
;
mPrintJob
=
nullptr
;
nsCOMPtr
<
nsIDocShell
>
docShell
(
mContainer
)
;
ResetFocusState
(
docShell
)
;
SetTextZoom
(
mTextZoom
)
;
SetFullZoom
(
mPageZoom
)
;
SetOverrideDPPX
(
mOverrideDPPX
)
;
Show
(
)
;
#
endif
}
void
nsDocumentViewer
:
:
OnDonePrinting
(
)
{
#
if
defined
(
NS_PRINTING
)
&
&
defined
(
NS_PRINT_PREVIEW
)
if
(
mPrintJob
)
{
RefPtr
<
nsPrintJob
>
printJob
=
mPrintJob
;
if
(
GetIsPrintPreview
(
)
)
{
printJob
-
>
DestroyPrintingData
(
)
;
}
else
{
mPrintJob
=
nullptr
;
printJob
-
>
Destroy
(
)
;
}
if
(
mDeferredWindowClose
)
{
mDeferredWindowClose
=
false
;
if
(
mContainer
)
{
if
(
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
=
mContainer
-
>
GetWindow
(
)
)
{
win
-
>
Close
(
)
;
}
}
}
else
if
(
mClosingWhilePrinting
)
{
if
(
mDocument
)
{
mDocument
-
>
Destroy
(
)
;
mDocument
=
nullptr
;
}
mClosingWhilePrinting
=
false
;
}
}
#
endif
}
NS_IMETHODIMP
nsDocumentViewer
:
:
SetPageMode
(
bool
aPageMode
nsIPrintSettings
*
aPrintSettings
)
{
mIsPageMode
=
aPageMode
;
nsAutoScriptBlocker
scriptBlocker
;
if
(
mPresShell
)
{
DestroyPresShell
(
)
;
}
if
(
mPresContext
)
{
DestroyPresContext
(
)
;
}
mViewManager
=
nullptr
;
mWindow
=
nullptr
;
NS_ENSURE_STATE
(
mDocument
)
;
if
(
aPageMode
)
{
mPresContext
=
CreatePresContext
(
mDocument
nsPresContext
:
:
eContext_PageLayout
FindContainerView
(
)
)
;
NS_ENSURE_TRUE
(
mPresContext
NS_ERROR_OUT_OF_MEMORY
)
;
mPresContext
-
>
SetPaginatedScrolling
(
true
)
;
mPresContext
-
>
SetPrintSettings
(
aPrintSettings
)
;
nsresult
rv
=
mPresContext
-
>
Init
(
mDeviceContext
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
NS_ENSURE_SUCCESS
(
InitInternal
(
mParentWidget
nullptr
mBounds
true
false
)
NS_ERROR_FAILURE
)
;
Show
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetHistoryEntry
(
nsISHEntry
*
*
aHistoryEntry
)
{
NS_IF_ADDREF
(
*
aHistoryEntry
=
mSHEntry
)
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetIsTabModalPromptAllowed
(
bool
*
aAllowed
)
{
*
aAllowed
=
!
mHidden
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
GetIsHidden
(
bool
*
aHidden
)
{
*
aHidden
=
mHidden
;
return
NS_OK
;
}
NS_IMETHODIMP
nsDocumentViewer
:
:
SetIsHidden
(
bool
aHidden
)
{
mHidden
=
aHidden
;
return
NS_OK
;
}
void
nsDocumentViewer
:
:
DestroyPresShell
(
)
{
MOZ_ASSERT
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
DestroyPresShell
must
only
be
called
when
scripts
are
blocked
"
)
;
mPresShell
-
>
EndObservingDocument
(
)
;
RefPtr
<
mozilla
:
:
dom
:
:
Selection
>
selection
=
GetDocumentSelection
(
)
;
if
(
selection
&
&
mSelectionListener
)
selection
-
>
RemoveSelectionListener
(
mSelectionListener
)
;
mPresShell
-
>
Destroy
(
)
;
mPresShell
=
nullptr
;
}
void
nsDocumentViewer
:
:
DestroyPresContext
(
)
{
mPresContext
-
>
Detach
(
)
;
mPresContext
=
nullptr
;
}
bool
nsDocumentViewer
:
:
IsInitializedForPrintPreview
(
)
{
return
mInitializedForPrintPreview
;
}
void
nsDocumentViewer
:
:
InitializeForPrintPreview
(
)
{
mInitializedForPrintPreview
=
true
;
}
void
nsDocumentViewer
:
:
SetPrintPreviewPresentation
(
nsViewManager
*
aViewManager
nsPresContext
*
aPresContext
nsIPresShell
*
aPresShell
)
{
nsAutoScriptBlocker
scriptBlocker
;
if
(
mPresShell
)
{
DestroyPresShell
(
)
;
}
mWindow
=
nullptr
;
mViewManager
=
aViewManager
;
mPresContext
=
aPresContext
;
mPresShell
=
aPresShell
;
if
(
ShouldAttachToTopLevel
(
)
)
{
DetachFromTopLevelWidget
(
)
;
nsView
*
rootView
=
mViewManager
-
>
GetRootView
(
)
;
rootView
-
>
AttachToTopLevelWidget
(
mParentWidget
)
;
mAttachedToParent
=
true
;
}
}
NS_IMETHODIMP
nsDocumentShownDispatcher
:
:
Run
(
)
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
NotifyObservers
(
ToSupports
(
mDocument
)
"
document
-
shown
"
nullptr
)
;
}
return
NS_OK
;
}
