#
ifndef
nsIPresShell_h___
#
define
nsIPresShell_h___
#
include
"
mozilla
/
ArenaObjectID
.
h
"
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
mozilla
/
FlushType
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
StyleSetHandle
.
h
"
#
include
"
mozilla
/
StyleSheet
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
gfxPoint
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsQueryFrame
.
h
"
#
include
"
nsCoord
.
h
"
#
include
"
nsColor
.
h
"
#
include
"
nsFrameManagerBase
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsRegionFwd
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
<
stdio
.
h
>
#
include
"
nsChangeHint
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsPresArena
.
h
"
#
include
"
nsIImageLoadingContent
.
h
"
#
include
"
nsMargin
.
h
"
#
include
"
nsFrameState
.
h
"
#
include
"
Units
.
h
"
#
ifdef
MOZ_B2G
#
include
"
nsIHardwareKeyHandler
.
h
"
#
endif
class
nsDocShell
;
class
nsIDocument
;
class
nsIFrame
;
class
nsPresContext
;
class
nsViewManager
;
class
nsView
;
class
nsRenderingContext
;
class
nsIPageSequenceFrame
;
class
nsCanvasFrame
;
class
nsAString
;
class
nsCaret
;
namespace
mozilla
{
class
AccessibleCaretEventHub
;
class
CSSStyleSheet
;
}
class
nsFrameSelection
;
class
nsFrameManager
;
class
nsILayoutHistoryState
;
class
nsIReflowCallback
;
class
nsIDOMNode
;
class
nsCSSFrameConstructor
;
class
nsISelection
;
template
<
class
E
>
class
nsCOMArray
;
class
nsWeakFrame
;
class
nsIScrollableFrame
;
class
gfxContext
;
class
nsIDOMEvent
;
class
nsDisplayList
;
class
nsDisplayListBuilder
;
class
nsPIDOMWindowOuter
;
struct
nsPoint
;
class
nsINode
;
struct
nsRect
;
class
nsRegion
;
class
nsRefreshDriver
;
class
nsARefreshObserver
;
class
nsAPostRefreshObserver
;
#
ifdef
ACCESSIBILITY
class
nsAccessibilityService
;
namespace
mozilla
{
namespace
a11y
{
class
DocAccessible
;
}
}
#
endif
struct
nsArenaMemoryStats
;
class
nsITimer
;
namespace
mozilla
{
class
EventStates
;
namespace
dom
{
class
Element
;
class
Touch
;
class
Selection
;
class
ShadowRoot
;
}
namespace
layers
{
class
LayerManager
;
}
namespace
gfx
{
class
SourceSurface
;
}
}
#
define
CAPTURE_IGNOREALLOWED
1
#
define
CAPTURE_RETARGETTOELEMENT
2
#
define
CAPTURE_PREVENTDRAG
4
#
define
CAPTURE_POINTERLOCK
8
typedef
struct
CapturingContentInfo
{
bool
mAllowed
;
bool
mPointerLock
;
bool
mRetargetToElement
;
bool
mPreventDrag
;
mozilla
:
:
StaticRefPtr
<
nsIContent
>
mContent
;
}
CapturingContentInfo
;
#
define
NS_IPRESSHELL_IID
\
{
0xa75573d6
0x34c8
0x4485
\
{
0x8f
0xb7
0xed
0xcb
0x6f
0xc7
0x0e
0x12
}
}
#
define
VERIFY_REFLOW_ON
0x01
#
define
VERIFY_REFLOW_NOISY
0x02
#
define
VERIFY_REFLOW_ALL
0x04
#
define
VERIFY_REFLOW_DUMP_COMMANDS
0x08
#
define
VERIFY_REFLOW_NOISY_RC
0x10
#
define
VERIFY_REFLOW_REALLY_NOISY_RC
0x20
#
define
VERIFY_REFLOW_DURING_RESIZE_REFLOW
0x40
#
undef
NOISY_INTERRUPTIBLE_REFLOW
enum
nsRectVisibility
{
nsRectVisibility_kVisible
nsRectVisibility_kAboveViewport
nsRectVisibility_kBelowViewport
nsRectVisibility_kLeftOfViewport
nsRectVisibility_kRightOfViewport
}
;
class
nsIPresShell
:
public
nsISupports
{
public
:
NS_DECLARE_STATIC_IID_ACCESSOR
(
NS_IPRESSHELL_IID
)
protected
:
typedef
mozilla
:
:
layers
:
:
LayerManager
LayerManager
;
typedef
mozilla
:
:
gfx
:
:
SourceSurface
SourceSurface
;
enum
eRenderFlag
{
STATE_IGNORING_VIEWPORT_SCROLLING
=
0x1
STATE_DRAWWINDOW_NOT_FLUSHING
=
0x2
}
;
typedef
uint8_t
RenderFlags
;
public
:
nsIPresShell
(
)
;
virtual
void
Destroy
(
)
=
0
;
bool
IsDestroying
(
)
{
return
mIsDestroying
;
}
void
*
AllocateFrame
(
nsQueryFrame
:
:
FrameIID
aID
size_t
aSize
)
{
void
*
result
=
mFrameArena
.
AllocateByFrameID
(
aID
aSize
)
;
RecordAlloc
(
result
)
;
return
result
;
}
void
FreeFrame
(
nsQueryFrame
:
:
FrameIID
aID
void
*
aPtr
)
{
RecordFree
(
aPtr
)
;
if
(
!
mIsDestroying
)
mFrameArena
.
FreeByFrameID
(
aID
aPtr
)
;
}
void
*
AllocateByObjectID
(
mozilla
:
:
ArenaObjectID
aID
size_t
aSize
)
{
void
*
result
=
mFrameArena
.
AllocateByObjectID
(
aID
aSize
)
;
RecordAlloc
(
result
)
;
return
result
;
}
void
FreeByObjectID
(
mozilla
:
:
ArenaObjectID
aID
void
*
aPtr
)
{
RecordFree
(
aPtr
)
;
if
(
!
mIsDestroying
)
mFrameArena
.
FreeByObjectID
(
aID
aPtr
)
;
}
void
*
AllocateMisc
(
size_t
aSize
)
{
void
*
result
=
mFrameArena
.
AllocateBySize
(
aSize
)
;
RecordAlloc
(
result
)
;
return
result
;
}
void
FreeMisc
(
size_t
aSize
void
*
aPtr
)
{
RecordFree
(
aPtr
)
;
if
(
!
mIsDestroying
)
mFrameArena
.
FreeBySize
(
aSize
aPtr
)
;
}
template
<
typename
T
>
void
RegisterArenaRefPtr
(
mozilla
:
:
ArenaRefPtr
<
T
>
*
aPtr
)
{
mFrameArena
.
RegisterArenaRefPtr
(
aPtr
)
;
}
template
<
typename
T
>
void
DeregisterArenaRefPtr
(
mozilla
:
:
ArenaRefPtr
<
T
>
*
aPtr
)
{
mFrameArena
.
DeregisterArenaRefPtr
(
aPtr
)
;
}
void
ClearArenaRefPtrs
(
mozilla
:
:
ArenaObjectID
aObjectID
)
{
mFrameArena
.
ClearArenaRefPtrs
(
aObjectID
)
;
}
nsIDocument
*
GetDocument
(
)
const
{
return
mDocument
;
}
nsPresContext
*
GetPresContext
(
)
const
{
return
mPresContext
;
}
nsViewManager
*
GetViewManager
(
)
const
{
return
mViewManager
;
}
nsRefreshDriver
*
GetRefreshDriver
(
)
const
;
#
ifdef
ACCESSIBILITY
mozilla
:
:
a11y
:
:
DocAccessible
*
GetDocAccessible
(
)
const
{
return
mDocAccessible
;
}
void
SetDocAccessible
(
mozilla
:
:
a11y
:
:
DocAccessible
*
aDocAccessible
)
{
mDocAccessible
=
aDocAccessible
;
}
#
endif
#
ifdef
MOZILLA_INTERNAL_API
mozilla
:
:
StyleSetHandle
StyleSet
(
)
const
{
return
mStyleSet
;
}
nsCSSFrameConstructor
*
FrameConstructor
(
)
const
{
return
mFrameConstructor
;
}
nsFrameManager
*
FrameManager
(
)
const
{
return
reinterpret_cast
<
nsFrameManager
*
>
(
const_cast
<
nsIPresShell
*
>
(
this
)
-
>
mFrameManager
)
;
}
#
endif
void
SetAuthorStyleDisabled
(
bool
aDisabled
)
;
bool
GetAuthorStyleDisabled
(
)
const
;
void
RestyleForCSSRuleChanges
(
)
;
virtual
void
UpdatePreferenceStyles
(
)
=
0
;
already_AddRefed
<
nsFrameSelection
>
FrameSelection
(
)
;
const
nsFrameSelection
*
ConstFrameSelection
(
)
const
{
return
mSelection
;
}
virtual
void
BeginObservingDocument
(
)
=
0
;
virtual
void
EndObservingDocument
(
)
=
0
;
bool
DidInitialize
(
)
const
{
return
mDidInitialize
;
}
virtual
nsresult
Initialize
(
nscoord
aWidth
nscoord
aHeight
)
=
0
;
virtual
nsresult
ResizeReflow
(
nscoord
aWidth
nscoord
aHeight
nscoord
aOldWidth
=
0
nscoord
aOldHeight
=
0
)
=
0
;
virtual
nsresult
ResizeReflowIgnoreOverride
(
nscoord
aWidth
nscoord
aHeight
nscoord
aOldWidth
nscoord
aOldHeight
)
=
0
;
virtual
bool
GetIsViewportOverridden
(
)
=
0
;
virtual
bool
IsLayoutFlushObserver
(
)
=
0
;
virtual
void
LoadComplete
(
)
=
0
;
virtual
nsIFrame
*
GetRootFrameExternal
(
)
const
;
nsIFrame
*
GetRootFrame
(
)
const
{
#
ifdef
MOZILLA_INTERNAL_API
return
mFrameManager
-
>
GetRootFrame
(
)
;
#
else
return
GetRootFrameExternal
(
)
;
#
endif
}
nsIFrame
*
GetRootScrollFrame
(
)
const
;
nsIScrollableFrame
*
GetRootScrollFrameAsScrollable
(
)
const
;
virtual
nsIScrollableFrame
*
GetRootScrollFrameAsScrollableExternal
(
)
const
;
enum
ScrollDirection
{
eHorizontal
eVertical
eEither
}
;
nsIScrollableFrame
*
GetFrameToScrollAsScrollable
(
ScrollDirection
aDirection
)
;
virtual
nsIPageSequenceFrame
*
GetPageSequenceFrame
(
)
const
=
0
;
virtual
nsCanvasFrame
*
GetCanvasFrame
(
)
const
=
0
;
virtual
nsIFrame
*
GetPlaceholderFrameFor
(
nsIFrame
*
aFrame
)
const
=
0
;
enum
IntrinsicDirty
{
eResize
eTreeChange
eStyleChange
}
;
enum
ReflowRootHandling
{
ePositionOrSizeChange
eNoPositionOrSizeChange
eInferFromBitToAdd
}
;
virtual
void
FrameNeedsReflow
(
nsIFrame
*
aFrame
IntrinsicDirty
aIntrinsicDirty
nsFrameState
aBitToAdd
ReflowRootHandling
aRootHandling
=
eInferFromBitToAdd
)
=
0
;
virtual
void
MarkFixedFramesForReflow
(
IntrinsicDirty
aIntrinsicDirty
)
;
virtual
void
FrameNeedsToContinueReflow
(
nsIFrame
*
aFrame
)
=
0
;
virtual
void
CancelAllPendingReflows
(
)
=
0
;
virtual
void
NotifyCounterStylesAreDirty
(
)
=
0
;
virtual
void
DestroyFramesFor
(
nsIContent
*
aContent
nsIContent
*
*
aDestroyedFramesFor
)
=
0
;
virtual
void
CreateFramesFor
(
nsIContent
*
aContent
)
=
0
;
virtual
nsresult
RecreateFramesFor
(
nsIContent
*
aContent
)
=
0
;
void
PostRecreateFramesFor
(
mozilla
:
:
dom
:
:
Element
*
aElement
)
;
void
RestyleForAnimation
(
mozilla
:
:
dom
:
:
Element
*
aElement
nsRestyleHint
aHint
)
;
virtual
void
RecordShadowStyleChange
(
mozilla
:
:
dom
:
:
ShadowRoot
*
aShadowRoot
)
=
0
;
virtual
bool
IsSafeToFlush
(
)
const
=
0
;
virtual
void
FlushPendingNotifications
(
mozilla
:
:
FlushType
aType
)
=
0
;
virtual
void
FlushPendingNotifications
(
mozilla
:
:
ChangesToFlush
aType
)
=
0
;
bool
NeedFlush
(
mozilla
:
:
FlushType
aType
)
const
{
MOZ_ASSERT
(
aType
>
=
mozilla
:
:
FlushType
:
:
Style
)
;
return
mNeedStyleFlush
|
|
(
mNeedLayoutFlush
&
&
aType
>
=
mozilla
:
:
FlushType
:
:
InterruptibleLayout
)
|
|
aType
>
=
mozilla
:
:
FlushType
:
:
Display
|
|
mInFlush
;
}
inline
void
SetNeedStyleFlush
(
)
;
inline
void
SetNeedLayoutFlush
(
)
;
bool
NeedStyleFlush
(
)
{
return
mNeedStyleFlush
;
}
virtual
nsresult
PostReflowCallback
(
nsIReflowCallback
*
aCallback
)
=
0
;
virtual
void
CancelReflowCallback
(
nsIReflowCallback
*
aCallback
)
=
0
;
virtual
void
ClearFrameRefs
(
nsIFrame
*
aFrame
)
=
0
;
virtual
already_AddRefed
<
gfxContext
>
CreateReferenceRenderingContext
(
)
=
0
;
virtual
nsresult
GoToAnchor
(
const
nsAString
&
aAnchorName
bool
aScroll
uint32_t
aAdditionalScrollFlags
=
0
)
=
0
;
virtual
nsresult
ScrollToAnchor
(
)
=
0
;
enum
{
SCROLL_TOP
=
0
SCROLL_BOTTOM
=
100
SCROLL_LEFT
=
0
SCROLL_RIGHT
=
100
SCROLL_CENTER
=
50
SCROLL_MINIMUM
=
-
1
}
;
enum
WhenToScroll
{
SCROLL_ALWAYS
SCROLL_IF_NOT_VISIBLE
SCROLL_IF_NOT_FULLY_VISIBLE
}
;
typedef
struct
ScrollAxis
{
int16_t
mWhereToScroll
;
WhenToScroll
mWhenToScroll
:
8
;
bool
mOnlyIfPerceivedScrollableDirection
:
1
;
explicit
ScrollAxis
(
int16_t
aWhere
=
SCROLL_MINIMUM
WhenToScroll
aWhen
=
SCROLL_IF_NOT_FULLY_VISIBLE
bool
aOnlyIfPerceivedScrollableDirection
=
false
)
:
mWhereToScroll
(
aWhere
)
mWhenToScroll
(
aWhen
)
mOnlyIfPerceivedScrollableDirection
(
aOnlyIfPerceivedScrollableDirection
)
{
}
}
ScrollAxis
;
virtual
nsresult
ScrollContentIntoView
(
nsIContent
*
aContent
ScrollAxis
aVertical
ScrollAxis
aHorizontal
uint32_t
aFlags
)
=
0
;
enum
{
SCROLL_FIRST_ANCESTOR_ONLY
=
0x01
SCROLL_OVERFLOW_HIDDEN
=
0x02
SCROLL_NO_PARENT_FRAMES
=
0x04
SCROLL_SMOOTH
=
0x08
SCROLL_SMOOTH_AUTO
=
0x10
}
;
virtual
bool
ScrollFrameRectIntoView
(
nsIFrame
*
aFrame
const
nsRect
&
aRect
ScrollAxis
aVertical
ScrollAxis
aHorizontal
uint32_t
aFlags
)
=
0
;
virtual
nsRectVisibility
GetRectVisibility
(
nsIFrame
*
aFrame
const
nsRect
&
aRect
nscoord
aMinTwips
)
const
=
0
;
virtual
void
SetIgnoreFrameDestruction
(
bool
aIgnore
)
=
0
;
virtual
void
NotifyDestroyingFrame
(
nsIFrame
*
aFrame
)
=
0
;
virtual
already_AddRefed
<
mozilla
:
:
AccessibleCaretEventHub
>
GetAccessibleCaretEventHub
(
)
const
=
0
;
virtual
already_AddRefed
<
nsCaret
>
GetCaret
(
)
const
=
0
;
virtual
void
SetCaret
(
nsCaret
*
aNewCaret
)
=
0
;
virtual
void
RestoreCaret
(
)
=
0
;
NS_IMETHOD
SetSelectionFlags
(
int16_t
aInEnable
)
=
0
;
int16_t
GetSelectionFlags
(
)
const
{
return
mSelectionFlags
;
}
virtual
mozilla
:
:
dom
:
:
Selection
*
GetCurrentSelection
(
mozilla
:
:
SelectionType
aSelectionType
)
=
0
;
virtual
already_AddRefed
<
nsISelectionController
>
GetSelectionControllerForFocusedContent
(
nsIContent
*
*
aFocusedContent
=
nullptr
)
=
0
;
virtual
nsresult
HandleEventWithTarget
(
mozilla
:
:
WidgetEvent
*
aEvent
nsIFrame
*
aFrame
nsIContent
*
aContent
nsEventStatus
*
aStatus
)
=
0
;
virtual
nsresult
HandleDOMEventWithTarget
(
nsIContent
*
aTargetContent
mozilla
:
:
WidgetEvent
*
aEvent
nsEventStatus
*
aStatus
)
=
0
;
virtual
nsresult
HandleDOMEventWithTarget
(
nsIContent
*
aTargetContent
nsIDOMEvent
*
aEvent
nsEventStatus
*
aStatus
)
=
0
;
virtual
bool
CanDispatchEvent
(
const
mozilla
:
:
WidgetGUIEvent
*
aEvent
=
nullptr
)
const
=
0
;
virtual
nsIFrame
*
GetEventTargetFrame
(
)
=
0
;
virtual
already_AddRefed
<
nsIContent
>
GetEventTargetContent
(
mozilla
:
:
WidgetEvent
*
aEvent
)
=
0
;
virtual
nsresult
CaptureHistoryState
(
nsILayoutHistoryState
*
*
aLayoutHistoryState
)
=
0
;
bool
IsReflowLocked
(
)
const
{
return
mIsReflowing
;
}
bool
IsPaintingSuppressed
(
)
const
{
return
mPaintingSuppressed
;
}
virtual
void
PausePainting
(
)
=
0
;
virtual
void
ResumePainting
(
)
=
0
;
virtual
void
UnsuppressPainting
(
)
=
0
;
void
DisableThemeSupport
(
)
{
mIsThemeSupportDisabled
=
true
;
}
bool
IsThemeSupportEnabled
(
)
const
{
return
!
mIsThemeSupportDisabled
;
}
virtual
nsresult
GetAgentStyleSheets
(
nsTArray
<
RefPtr
<
mozilla
:
:
StyleSheet
>
>
&
aSheets
)
=
0
;
virtual
nsresult
SetAgentStyleSheets
(
const
nsTArray
<
RefPtr
<
mozilla
:
:
StyleSheet
>
>
&
aSheets
)
=
0
;
virtual
nsresult
AddOverrideStyleSheet
(
mozilla
:
:
StyleSheet
*
aSheet
)
=
0
;
virtual
nsresult
RemoveOverrideStyleSheet
(
mozilla
:
:
StyleSheet
*
aSheet
)
=
0
;
virtual
nsresult
ReconstructFrames
(
)
=
0
;
virtual
void
ContentStateChanged
(
nsIDocument
*
aDocument
nsIContent
*
aContent
mozilla
:
:
EventStates
aStateMask
)
=
0
;
static
bool
GetVerifyReflowEnable
(
)
;
static
void
SetVerifyReflowEnable
(
bool
aEnabled
)
;
virtual
nsIFrame
*
GetAbsoluteContainingBlock
(
nsIFrame
*
aFrame
)
;
#
ifdef
MOZ_REFLOW_PERF
virtual
void
DumpReflows
(
)
=
0
;
virtual
void
CountReflows
(
const
char
*
aName
nsIFrame
*
aFrame
)
=
0
;
virtual
void
PaintCount
(
const
char
*
aName
nsRenderingContext
*
aRenderingContext
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
const
nsPoint
&
aOffset
uint32_t
aColor
)
=
0
;
virtual
void
SetPaintFrameCount
(
bool
aOn
)
=
0
;
virtual
bool
IsPaintingFrameCounts
(
)
=
0
;
#
endif
#
ifdef
DEBUG
virtual
void
ListStyleContexts
(
FILE
*
out
int32_t
aIndent
=
0
)
=
0
;
virtual
void
ListStyleSheets
(
FILE
*
out
int32_t
aIndent
=
0
)
=
0
;
virtual
void
VerifyStyleTree
(
)
=
0
;
#
endif
#
ifdef
ACCESSIBILITY
static
bool
IsAccessibilityActive
(
)
;
static
nsAccessibilityService
*
AccService
(
)
;
#
endif
virtual
void
Freeze
(
)
=
0
;
bool
IsFrozen
(
)
{
return
mFrozen
;
}
virtual
void
Thaw
(
)
=
0
;
virtual
void
FireOrClearDelayedEvents
(
bool
aFireEvents
)
=
0
;
void
SetForwardingContainer
(
const
mozilla
:
:
WeakPtr
<
nsDocShell
>
&
aContainer
)
;
enum
{
RENDER_IS_UNTRUSTED
=
0x01
RENDER_IGNORE_VIEWPORT_SCROLLING
=
0x02
RENDER_CARET
=
0x04
RENDER_USE_WIDGET_LAYERS
=
0x08
RENDER_ASYNC_DECODE_IMAGES
=
0x10
RENDER_DOCUMENT_RELATIVE
=
0x20
RENDER_DRAWWINDOW_NOT_FLUSHING
=
0x40
}
;
virtual
nsresult
RenderDocument
(
const
nsRect
&
aRect
uint32_t
aFlags
nscolor
aBackgroundColor
gfxContext
*
aRenderedContext
)
=
0
;
enum
{
RENDER_IS_IMAGE
=
0x100
RENDER_AUTO_SCALE
=
0x80
}
;
virtual
already_AddRefed
<
mozilla
:
:
gfx
:
:
SourceSurface
>
RenderNode
(
nsIDOMNode
*
aNode
nsIntRegion
*
aRegion
const
mozilla
:
:
LayoutDeviceIntPoint
aPoint
mozilla
:
:
LayoutDeviceIntRect
*
aScreenRect
uint32_t
aFlags
)
=
0
;
virtual
already_AddRefed
<
mozilla
:
:
gfx
:
:
SourceSurface
>
RenderSelection
(
nsISelection
*
aSelection
const
mozilla
:
:
LayoutDeviceIntPoint
aPoint
mozilla
:
:
LayoutDeviceIntRect
*
aScreenRect
uint32_t
aFlags
)
=
0
;
void
AddWeakFrameInternal
(
nsWeakFrame
*
aWeakFrame
)
;
virtual
void
AddWeakFrameExternal
(
nsWeakFrame
*
aWeakFrame
)
;
void
AddWeakFrame
(
nsWeakFrame
*
aWeakFrame
)
{
#
ifdef
MOZILLA_INTERNAL_API
AddWeakFrameInternal
(
aWeakFrame
)
;
#
else
AddWeakFrameExternal
(
aWeakFrame
)
;
#
endif
}
void
RemoveWeakFrameInternal
(
nsWeakFrame
*
aWeakFrame
)
;
virtual
void
RemoveWeakFrameExternal
(
nsWeakFrame
*
aWeakFrame
)
;
void
RemoveWeakFrame
(
nsWeakFrame
*
aWeakFrame
)
{
#
ifdef
MOZILLA_INTERNAL_API
RemoveWeakFrameInternal
(
aWeakFrame
)
;
#
else
RemoveWeakFrameExternal
(
aWeakFrame
)
;
#
endif
}
#
ifdef
DEBUG
nsIFrame
*
GetDrawEventTargetFrame
(
)
{
return
mDrawEventTargetFrame
;
}
#
endif
virtual
void
DisableNonTestMouseEvents
(
bool
aDisable
)
=
0
;
void
SetCanvasBackground
(
nscolor
aColor
)
{
mCanvasBackgroundColor
=
aColor
;
}
nscolor
GetCanvasBackground
(
)
{
return
mCanvasBackgroundColor
;
}
virtual
void
UpdateCanvasBackground
(
)
=
0
;
enum
{
FORCE_DRAW
=
0x01
}
;
virtual
void
AddCanvasBackgroundColorItem
(
nsDisplayListBuilder
&
aBuilder
nsDisplayList
&
aList
nsIFrame
*
aFrame
const
nsRect
&
aBounds
nscolor
aBackstopColor
=
NS_RGBA
(
0
0
0
0
)
uint32_t
aFlags
=
0
)
=
0
;
virtual
void
AddPrintPreviewBackgroundItem
(
nsDisplayListBuilder
&
aBuilder
nsDisplayList
&
aList
nsIFrame
*
aFrame
const
nsRect
&
aBounds
)
=
0
;
virtual
nscolor
ComputeBackstopColor
(
nsView
*
aDisplayRoot
)
=
0
;
void
ObserveNativeAnonMutationsForPrint
(
bool
aObserve
)
{
mObservesMutationsForPrint
=
aObserve
;
}
bool
ObservesNativeAnonMutationsForPrint
(
)
{
return
mObservesMutationsForPrint
;
}
virtual
nsresult
SetIsActive
(
bool
aIsActive
)
=
0
;
bool
IsActive
(
)
{
return
mIsActive
;
}
static
CapturingContentInfo
gCaptureInfo
;
class
PointerCaptureInfo
final
{
public
:
nsCOMPtr
<
nsIContent
>
mPendingContent
;
nsCOMPtr
<
nsIContent
>
mOverrideContent
;
explicit
PointerCaptureInfo
(
nsIContent
*
aPendingContent
)
:
mPendingContent
(
aPendingContent
)
{
MOZ_COUNT_CTOR
(
PointerCaptureInfo
)
;
}
~
PointerCaptureInfo
(
)
{
MOZ_COUNT_DTOR
(
PointerCaptureInfo
)
;
}
bool
Empty
(
)
{
return
!
(
mPendingContent
|
|
mOverrideContent
)
;
}
}
;
class
PointerInfo
final
{
public
:
uint16_t
mPointerType
;
bool
mActiveState
;
bool
mPrimaryState
;
bool
mPreventMouseEventByContent
;
explicit
PointerInfo
(
bool
aActiveState
uint16_t
aPointerType
bool
aPrimaryState
)
:
mPointerType
(
aPointerType
)
mActiveState
(
aActiveState
)
mPrimaryState
(
aPrimaryState
)
mPreventMouseEventByContent
(
false
)
{
}
}
;
static
void
DispatchGotOrLostPointerCaptureEvent
(
bool
aIsGotCapture
uint32_t
aPointerId
uint16_t
aPointerType
bool
aIsPrimary
nsIContent
*
aCaptureTarget
)
;
static
PointerCaptureInfo
*
GetPointerCaptureInfo
(
uint32_t
aPointerId
)
;
static
void
SetPointerCapturingContent
(
uint32_t
aPointerId
nsIContent
*
aContent
)
;
static
void
ReleasePointerCapturingContent
(
uint32_t
aPointerId
)
;
static
nsIContent
*
GetPointerCapturingContent
(
uint32_t
aPointerId
)
;
static
void
CheckPointerCaptureState
(
uint32_t
aPointerId
uint16_t
aPointerType
bool
aIsPrimary
)
;
static
bool
GetPointerInfo
(
uint32_t
aPointerId
bool
&
aActiveState
)
;
static
uint16_t
GetPointerType
(
uint32_t
aPointerId
)
;
static
bool
GetPointerPrimaryState
(
uint32_t
aPointerId
)
;
static
void
SetCapturingContent
(
nsIContent
*
aContent
uint8_t
aFlags
)
;
static
nsIContent
*
GetCapturingContent
(
)
{
return
gCaptureInfo
.
mContent
;
}
static
void
AllowMouseCapture
(
bool
aAllowed
)
{
gCaptureInfo
.
mAllowed
=
aAllowed
;
}
static
bool
IsMouseCapturePreventingDrag
(
)
{
return
gCaptureInfo
.
mPreventDrag
&
&
gCaptureInfo
.
mContent
;
}
uint64_t
GetPaintCount
(
)
{
return
mPaintCount
;
}
void
IncrementPaintCount
(
)
{
+
+
mPaintCount
;
}
virtual
already_AddRefed
<
nsPIDOMWindowOuter
>
GetRootWindow
(
)
=
0
;
virtual
LayerManager
*
GetLayerManager
(
)
=
0
;
virtual
bool
AsyncPanZoomEnabled
(
)
=
0
;
virtual
void
SetIgnoreViewportScrolling
(
bool
aIgnore
)
=
0
;
bool
IgnoringViewportScrolling
(
)
const
{
return
mRenderFlags
&
STATE_IGNORING_VIEWPORT_SCROLLING
;
}
virtual
nsresult
SetResolution
(
float
aResolution
)
=
0
;
float
GetResolution
(
)
const
{
return
mResolution
.
valueOr
(
1
.
0
)
;
}
virtual
float
GetCumulativeResolution
(
)
=
0
;
virtual
float
GetCumulativeNonRootScaleResolution
(
)
=
0
;
bool
IsResolutionSet
(
)
{
return
mResolution
.
isSome
(
)
;
}
virtual
nsresult
SetResolutionAndScaleTo
(
float
aResolution
)
=
0
;
virtual
bool
ScaleToResolution
(
)
const
=
0
;
virtual
void
SetRestoreResolution
(
float
aResolution
mozilla
:
:
LayoutDeviceIntSize
aDisplaySize
)
=
0
;
bool
InDrawWindowNotFlushing
(
)
const
{
return
mRenderFlags
&
STATE_DRAWWINDOW_NOT_FLUSHING
;
}
void
SetIsFirstPaint
(
bool
aIsFirstPaint
)
{
mIsFirstPaint
=
aIsFirstPaint
;
}
bool
GetIsFirstPaint
(
)
const
{
return
mIsFirstPaint
;
}
uint32_t
GetPresShellId
(
)
{
return
mPresShellId
;
}
virtual
void
SynthesizeMouseMove
(
bool
aFromScroll
)
=
0
;
enum
PaintFlags
{
PAINT_LAYERS
=
0x01
PAINT_COMPOSITE
=
0x02
PAINT_SYNC_DECODE_IMAGES
=
0x04
}
;
virtual
void
Paint
(
nsView
*
aViewToPaint
const
nsRegion
&
aDirtyRegion
uint32_t
aFlags
)
=
0
;
virtual
nsresult
HandleEvent
(
nsIFrame
*
aFrame
mozilla
:
:
WidgetGUIEvent
*
aEvent
bool
aDontRetargetEvents
nsEventStatus
*
aEventStatus
nsIContent
*
*
aTargetContent
=
nullptr
)
=
0
;
virtual
bool
ShouldIgnoreInvalidation
(
)
=
0
;
virtual
void
WillPaint
(
)
=
0
;
virtual
void
WillPaintWindow
(
)
=
0
;
virtual
void
DidPaintWindow
(
)
=
0
;
enum
PaintType
{
PAINT_DEFAULT
PAINT_DELAYED_COMPRESS
}
;
virtual
void
ScheduleViewManagerFlush
(
PaintType
aType
=
PAINT_DEFAULT
)
=
0
;
virtual
void
ClearMouseCaptureOnView
(
nsView
*
aView
)
=
0
;
virtual
bool
IsVisible
(
)
=
0
;
virtual
void
DispatchSynthMouseMove
(
mozilla
:
:
WidgetGUIEvent
*
aEvent
bool
aFlushOnHoverChange
)
=
0
;
virtual
void
AddSizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
nsArenaMemoryStats
*
aArenaObjectsSize
size_t
*
aPresShellSize
size_t
*
aStyleSetsSize
size_t
*
aTextRunsSize
size_t
*
aPresContextSize
)
=
0
;
uint32_t
FontSizeInflationEmPerLine
(
)
const
{
return
mFontSizeInflationEmPerLine
;
}
uint32_t
FontSizeInflationMinTwips
(
)
const
{
return
mFontSizeInflationMinTwips
;
}
uint32_t
FontSizeInflationLineThreshold
(
)
const
{
return
mFontSizeInflationLineThreshold
;
}
bool
FontSizeInflationForceEnabled
(
)
const
{
return
mFontSizeInflationForceEnabled
;
}
bool
FontSizeInflationDisabledInMasterProcess
(
)
const
{
return
mFontSizeInflationDisabledInMasterProcess
;
}
bool
FontSizeInflationEnabled
(
)
;
void
NotifyFontSizeInflationEnabledIsDirty
(
)
{
mFontSizeInflationEnabledIsDirty
=
true
;
}
virtual
void
AddInvalidateHiddenPresShellObserver
(
nsRefreshDriver
*
aDriver
)
=
0
;
void
InvalidatePresShellIfHidden
(
)
;
void
CancelInvalidatePresShellIfHidden
(
)
;
virtual
void
ScheduleApproximateFrameVisibilityUpdateSoon
(
)
=
0
;
virtual
void
ScheduleApproximateFrameVisibilityUpdateNow
(
)
=
0
;
virtual
void
RebuildApproximateFrameVisibilityDisplayList
(
const
nsDisplayList
&
aList
)
=
0
;
virtual
void
RebuildApproximateFrameVisibility
(
nsRect
*
aRect
=
nullptr
bool
aRemoveOnly
=
false
)
=
0
;
virtual
void
EnsureFrameInApproximatelyVisibleList
(
nsIFrame
*
aFrame
)
=
0
;
virtual
void
RemoveFrameFromApproximatelyVisibleList
(
nsIFrame
*
aFrame
)
=
0
;
virtual
bool
AssumeAllFramesVisible
(
)
=
0
;
nsresult
HasRuleProcessorUsedByMultipleStyleSets
(
uint32_t
aSheetType
bool
*
aRetVal
)
;
protected
:
virtual
bool
AddRefreshObserverExternal
(
nsARefreshObserver
*
aObserver
mozilla
:
:
FlushType
aFlushType
)
;
bool
AddRefreshObserverInternal
(
nsARefreshObserver
*
aObserver
mozilla
:
:
FlushType
aFlushType
)
;
virtual
bool
RemoveRefreshObserverExternal
(
nsARefreshObserver
*
aObserver
mozilla
:
:
FlushType
aFlushType
)
;
bool
RemoveRefreshObserverInternal
(
nsARefreshObserver
*
aObserver
mozilla
:
:
FlushType
aFlushType
)
;
void
RecomputeFontSizeInflationEnabled
(
)
;
void
RecordAlloc
(
void
*
aPtr
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
!
mAllocatedPointers
.
Contains
(
aPtr
)
)
;
mAllocatedPointers
.
PutEntry
(
aPtr
)
;
#
endif
}
void
RecordFree
(
void
*
aPtr
)
{
#
ifdef
DEBUG
MOZ_ASSERT
(
mAllocatedPointers
.
Contains
(
aPtr
)
)
;
mAllocatedPointers
.
RemoveEntry
(
aPtr
)
;
#
endif
}
public
:
bool
AddRefreshObserver
(
nsARefreshObserver
*
aObserver
mozilla
:
:
FlushType
aFlushType
)
{
#
ifdef
MOZILLA_INTERNAL_API
return
AddRefreshObserverInternal
(
aObserver
aFlushType
)
;
#
else
return
AddRefreshObserverExternal
(
aObserver
aFlushType
)
;
#
endif
}
bool
RemoveRefreshObserver
(
nsARefreshObserver
*
aObserver
mozilla
:
:
FlushType
aFlushType
)
{
#
ifdef
MOZILLA_INTERNAL_API
return
RemoveRefreshObserverInternal
(
aObserver
aFlushType
)
;
#
else
return
RemoveRefreshObserverExternal
(
aObserver
aFlushType
)
;
#
endif
}
virtual
bool
AddPostRefreshObserver
(
nsAPostRefreshObserver
*
aObserver
)
;
virtual
bool
RemovePostRefreshObserver
(
nsAPostRefreshObserver
*
aObserver
)
;
static
void
InitializeStatics
(
)
;
static
void
ReleaseStatics
(
)
;
static
void
ClearMouseCapture
(
nsIFrame
*
aFrame
)
;
void
SetScrollPositionClampingScrollPortSize
(
nscoord
aWidth
nscoord
aHeight
)
;
bool
IsScrollPositionClampingScrollPortSizeSet
(
)
{
return
mScrollPositionClampingScrollPortSizeSet
;
}
nsSize
GetScrollPositionClampingScrollPortSize
(
)
{
NS_ASSERTION
(
mScrollPositionClampingScrollPortSizeSet
"
asking
for
scroll
port
when
its
not
set
?
"
)
;
return
mScrollPositionClampingScrollPortSize
;
}
virtual
void
WindowSizeMoveDone
(
)
=
0
;
virtual
void
SysColorChanged
(
)
=
0
;
virtual
void
ThemeChanged
(
)
=
0
;
virtual
void
BackingScaleFactorChanged
(
)
=
0
;
bool
IsNeverPainting
(
)
{
return
mIsNeverPainting
;
}
void
SetNeverPainting
(
bool
aNeverPainting
)
{
mIsNeverPainting
=
aNeverPainting
;
}
bool
HasPendingReflow
(
)
const
{
return
mReflowScheduled
|
|
mReflowContinueTimer
;
}
void
SyncWindowProperties
(
nsView
*
aView
)
;
virtual
nsIDocument
*
GetPrimaryContentDocument
(
)
=
0
;
protected
:
friend
class
nsRefreshDriver
;
nsCOMPtr
<
nsIDocument
>
mDocument
;
RefPtr
<
nsPresContext
>
mPresContext
;
mozilla
:
:
StyleSetHandle
mStyleSet
;
nsCSSFrameConstructor
*
mFrameConstructor
;
nsViewManager
*
mViewManager
;
nsPresArena
mFrameArena
;
RefPtr
<
nsFrameSelection
>
mSelection
;
nsFrameManagerBase
*
mFrameManager
;
mozilla
:
:
WeakPtr
<
nsDocShell
>
mForwardingContainer
;
nsRefreshDriver
*
MOZ_UNSAFE_REF
(
"
These
two
objects
hold
weak
references
"
"
to
each
other
and
the
validity
of
this
"
"
member
is
ensured
by
the
logic
in
nsIPresShell
.
"
)
mHiddenInvalidationObserverRefreshDriver
;
#
ifdef
ACCESSIBILITY
mozilla
:
:
a11y
:
:
DocAccessible
*
mDocAccessible
;
#
endif
nsCOMPtr
<
nsITimer
>
mReflowContinueTimer
;
#
ifdef
DEBUG
nsIFrame
*
mDrawEventTargetFrame
;
nsTHashtable
<
nsPtrHashKey
<
void
>
>
mAllocatedPointers
;
#
endif
uint64_t
mPaintCount
;
nsSize
mScrollPositionClampingScrollPortSize
;
nsWeakFrame
*
mWeakFrames
;
nscolor
mCanvasBackgroundColor
;
mozilla
:
:
Maybe
<
float
>
mResolution
;
int16_t
mSelectionFlags
;
RenderFlags
mRenderFlags
;
bool
mStylesHaveChanged
:
1
;
bool
mDidInitialize
:
1
;
bool
mIsDestroying
:
1
;
bool
mIsReflowing
:
1
;
bool
mPaintingSuppressed
:
1
;
bool
mIsThemeSupportDisabled
:
1
;
bool
mIsActive
:
1
;
bool
mFrozen
:
1
;
bool
mIsFirstPaint
:
1
;
bool
mObservesMutationsForPrint
:
1
;
bool
mReflowScheduled
:
1
;
bool
mSuppressInterruptibleReflows
:
1
;
bool
mScrollPositionClampingScrollPortSizeSet
:
1
;
bool
mNeedLayoutFlush
:
1
;
bool
mNeedStyleFlush
:
1
;
uint32_t
mPresShellId
;
AutoTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
Element
>
1
>
mChangedScopeStyleRoots
;
static
nsIContent
*
gKeyDownTarget
;
uint32_t
mFontSizeInflationEmPerLine
;
uint32_t
mFontSizeInflationMinTwips
;
uint32_t
mFontSizeInflationLineThreshold
;
bool
mFontSizeInflationForceEnabled
;
bool
mFontSizeInflationDisabledInMasterProcess
;
bool
mFontSizeInflationEnabled
;
bool
mPaintingIsFrozen
;
bool
mFontSizeInflationEnabledIsDirty
;
bool
mIsNeverPainting
;
bool
mInFlush
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
nsIPresShell
NS_IPRESSHELL_IID
)
#
endif
