#
ifndef
nsIPresShell_h___
#
define
nsIPresShell_h___
#
include
"
mozilla
/
ArenaObjectID
.
h
"
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
mozilla
/
FlushType
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
ScrollTypes
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
StyleSheet
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
FrameMetrics
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
gfxPoint
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsISupports
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsQueryFrame
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsCoord
.
h
"
#
include
"
nsColor
.
h
"
#
include
"
nsFrameManager
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsRegionFwd
.
h
"
#
include
<
stdio
.
h
>
#
include
"
nsChangeHint
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsPresArena
.
h
"
#
include
"
nsIImageLoadingContent
.
h
"
#
include
"
nsMargin
.
h
"
#
include
"
nsFrameState
.
h
"
#
include
"
nsStubDocumentObserver
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
Units
.
h
"
#
ifdef
MOZ_REFLOW_PERF
class
ReflowCountMgr
;
#
endif
class
gfxContext
;
struct
nsCallbackEventRequest
;
class
nsDocShell
;
class
nsIFrame
;
class
nsPresContext
;
class
nsWindowSizes
;
class
nsViewManager
;
class
nsView
;
class
nsIPageSequenceFrame
;
class
nsCanvasFrame
;
class
nsCaret
;
namespace
mozilla
{
class
AccessibleCaretEventHub
;
class
OverflowChangedTracker
;
class
StyleSheet
;
}
class
nsFrameSelection
;
class
nsFrameManager
;
class
nsILayoutHistoryState
;
class
nsIReflowCallback
;
class
nsCSSFrameConstructor
;
template
<
class
E
>
class
nsCOMArray
;
class
AutoWeakFrame
;
class
MobileViewportManager
;
class
WeakFrame
;
class
nsIScrollableFrame
;
class
nsDisplayList
;
class
nsDisplayListBuilder
;
class
nsPIDOMWindowOuter
;
struct
nsPoint
;
class
nsINode
;
struct
nsRect
;
class
nsRegion
;
class
nsRefreshDriver
;
class
nsAutoCauseReflowNotifier
;
class
nsARefreshObserver
;
class
nsAPostRefreshObserver
;
#
ifdef
ACCESSIBILITY
class
nsAccessibilityService
;
namespace
mozilla
{
namespace
a11y
{
class
DocAccessible
;
}
}
#
endif
class
nsITimer
;
namespace
mozilla
{
class
EventStates
;
namespace
dom
{
class
Element
;
class
Event
;
class
Document
;
class
HTMLSlotElement
;
class
Touch
;
class
Selection
;
class
ShadowRoot
;
}
namespace
layout
{
class
ScrollAnchorContainer
;
}
namespace
layers
{
class
LayerManager
;
}
namespace
gfx
{
class
SourceSurface
;
}
}
#
define
CAPTURE_IGNOREALLOWED
1
#
define
CAPTURE_RETARGETTOELEMENT
2
#
define
CAPTURE_PREVENTDRAG
4
#
define
CAPTURE_POINTERLOCK
8
typedef
struct
CapturingContentInfo
{
bool
mAllowed
;
bool
mPointerLock
;
bool
mRetargetToElement
;
bool
mPreventDrag
;
mozilla
:
:
StaticRefPtr
<
nsIContent
>
mContent
;
}
CapturingContentInfo
;
#
define
NS_IPRESSHELL_IID
\
{
\
0xb7b89561
0x4f03
0x44b3
{
\
0x9a
0xfa
0xb4
0x7e
0x7f
0x31
0x3f
0xfb
\
}
\
}
#
define
VERIFY_REFLOW_ON
0x01
#
define
VERIFY_REFLOW_NOISY
0x02
#
define
VERIFY_REFLOW_ALL
0x04
#
define
VERIFY_REFLOW_DUMP_COMMANDS
0x08
#
define
VERIFY_REFLOW_NOISY_RC
0x10
#
define
VERIFY_REFLOW_REALLY_NOISY_RC
0x20
#
define
VERIFY_REFLOW_DURING_RESIZE_REFLOW
0x40
#
undef
NOISY_INTERRUPTIBLE_REFLOW
enum
nsRectVisibility
{
nsRectVisibility_kVisible
nsRectVisibility_kAboveViewport
nsRectVisibility_kBelowViewport
nsRectVisibility_kLeftOfViewport
nsRectVisibility_kRightOfViewport
}
;
class
nsIPresShell
:
public
nsStubDocumentObserver
{
public
:
NS_DECLARE_STATIC_IID_ACCESSOR
(
NS_IPRESSHELL_IID
)
protected
:
typedef
mozilla
:
:
dom
:
:
Document
Document
;
typedef
mozilla
:
:
layers
:
:
FrameMetrics
FrameMetrics
;
typedef
mozilla
:
:
layers
:
:
LayerManager
LayerManager
;
typedef
mozilla
:
:
gfx
:
:
SourceSurface
SourceSurface
;
enum
eRenderFlag
{
STATE_IGNORING_VIEWPORT_SCROLLING
=
0x1
STATE_DRAWWINDOW_NOT_FLUSHING
=
0x2
}
;
typedef
uint8_t
RenderFlags
;
public
:
nsIPresShell
(
)
;
virtual
void
Destroy
(
)
=
0
;
bool
IsDestroying
(
)
{
return
mIsDestroying
;
}
void
*
AllocateFrame
(
nsQueryFrame
:
:
FrameIID
aID
size_t
aSize
)
{
void
*
result
=
mFrameArena
.
AllocateByFrameID
(
aID
aSize
)
;
RecordAlloc
(
result
)
;
return
result
;
}
void
FreeFrame
(
nsQueryFrame
:
:
FrameIID
aID
void
*
aPtr
)
{
RecordFree
(
aPtr
)
;
if
(
!
mIsDestroying
)
mFrameArena
.
FreeByFrameID
(
aID
aPtr
)
;
}
void
*
AllocateByObjectID
(
mozilla
:
:
ArenaObjectID
aID
size_t
aSize
)
{
void
*
result
=
mFrameArena
.
AllocateByObjectID
(
aID
aSize
)
;
RecordAlloc
(
result
)
;
return
result
;
}
void
FreeByObjectID
(
mozilla
:
:
ArenaObjectID
aID
void
*
aPtr
)
{
RecordFree
(
aPtr
)
;
if
(
!
mIsDestroying
)
mFrameArena
.
FreeByObjectID
(
aID
aPtr
)
;
}
Document
*
GetDocument
(
)
const
{
return
mDocument
;
}
nsPresContext
*
GetPresContext
(
)
const
{
return
mPresContext
;
}
nsViewManager
*
GetViewManager
(
)
const
{
return
mViewManager
;
}
nsRefreshDriver
*
GetRefreshDriver
(
)
const
;
#
ifdef
ACCESSIBILITY
mozilla
:
:
a11y
:
:
DocAccessible
*
GetDocAccessible
(
)
const
{
return
mDocAccessible
;
}
void
SetDocAccessible
(
mozilla
:
:
a11y
:
:
DocAccessible
*
aDocAccessible
)
{
mDocAccessible
=
aDocAccessible
;
}
#
endif
inline
mozilla
:
:
ServoStyleSet
*
StyleSet
(
)
const
;
nsCSSFrameConstructor
*
FrameConstructor
(
)
const
{
return
mFrameConstructor
.
get
(
)
;
}
void
SetAuthorStyleDisabled
(
bool
aDisabled
)
;
bool
GetAuthorStyleDisabled
(
)
const
;
void
ApplicableStylesChanged
(
)
;
void
UpdatePreferenceStyles
(
)
;
already_AddRefed
<
nsFrameSelection
>
FrameSelection
(
)
;
const
nsFrameSelection
*
ConstFrameSelection
(
)
const
{
return
mSelection
;
}
void
BeginObservingDocument
(
)
;
void
EndObservingDocument
(
)
;
bool
IsObservingDocument
(
)
const
{
return
mIsObservingDocument
;
}
bool
DidInitialize
(
)
const
{
return
mDidInitialize
;
}
virtual
nsresult
Initialize
(
)
=
0
;
enum
class
ResizeReflowOptions
:
uint32_t
{
eBSizeExact
eBSizeLimit
}
;
virtual
nsresult
ResizeReflow
(
nscoord
aWidth
nscoord
aHeight
nscoord
aOldWidth
=
0
nscoord
aOldHeight
=
0
ResizeReflowOptions
aOptions
=
ResizeReflowOptions
:
:
eBSizeExact
)
=
0
;
virtual
nsresult
ResizeReflowIgnoreOverride
(
nscoord
aWidth
nscoord
aHeight
nscoord
aOldWidth
nscoord
aOldHeight
ResizeReflowOptions
aOptions
=
ResizeReflowOptions
:
:
eBSizeExact
)
=
0
;
virtual
bool
GetIsViewportOverridden
(
)
=
0
;
virtual
void
UpdateViewportOverridden
(
bool
aAfterInitialization
)
=
0
;
virtual
RefPtr
<
MobileViewportManager
>
GetMobileViewportManager
(
)
const
=
0
;
virtual
bool
IsLayoutFlushObserver
(
)
=
0
;
virtual
void
LoadComplete
(
)
=
0
;
nsIFrame
*
GetRootFrame
(
)
const
{
return
mFrameManager
-
>
GetRootFrame
(
)
;
}
nsIFrame
*
GetRootScrollFrame
(
)
const
;
nsIScrollableFrame
*
GetRootScrollFrameAsScrollable
(
)
const
;
already_AddRefed
<
nsIContent
>
GetContentForScrolling
(
)
const
;
already_AddRefed
<
nsIContent
>
GetSelectedContentForScrolling
(
)
const
;
enum
ScrollDirection
{
eHorizontal
eVertical
eEither
}
;
nsIScrollableFrame
*
GetScrollableFrameToScrollForContent
(
nsIContent
*
aContent
ScrollDirection
aDirection
)
;
nsIScrollableFrame
*
GetScrollableFrameToScroll
(
ScrollDirection
aDirection
)
;
nsIScrollableFrame
*
GetNearestScrollableFrame
(
nsIFrame
*
aFrame
ScrollDirection
aDirection
)
;
nsIPageSequenceFrame
*
GetPageSequenceFrame
(
)
const
;
nsCanvasFrame
*
GetCanvasFrame
(
)
const
;
void
PostPendingScrollAnchorSelection
(
mozilla
:
:
layout
:
:
ScrollAnchorContainer
*
aContainer
)
;
void
FlushPendingScrollAnchorSelections
(
)
;
void
PostPendingScrollAnchorAdjustment
(
mozilla
:
:
layout
:
:
ScrollAnchorContainer
*
aContainer
)
;
enum
IntrinsicDirty
{
eResize
eTreeChange
eStyleChange
}
;
enum
ReflowRootHandling
{
ePositionOrSizeChange
eNoPositionOrSizeChange
eInferFromBitToAdd
}
;
void
FrameNeedsReflow
(
nsIFrame
*
aFrame
IntrinsicDirty
aIntrinsicDirty
nsFrameState
aBitToAdd
ReflowRootHandling
aRootHandling
=
eInferFromBitToAdd
)
;
void
MarkFixedFramesForReflow
(
IntrinsicDirty
aIntrinsicDirty
)
;
void
FrameNeedsToContinueReflow
(
nsIFrame
*
aFrame
)
;
void
CancelAllPendingReflows
(
)
;
void
NotifyCounterStylesAreDirty
(
)
;
bool
FrameIsAncestorOfDirtyRoot
(
nsIFrame
*
aFrame
)
const
;
void
DestroyFramesForAndRestyle
(
mozilla
:
:
dom
:
:
Element
*
aElement
)
;
void
SlotAssignmentWillChange
(
mozilla
:
:
dom
:
:
Element
&
aElement
mozilla
:
:
dom
:
:
HTMLSlotElement
*
aOldSlot
mozilla
:
:
dom
:
:
HTMLSlotElement
*
aNewSlot
)
;
void
PostRecreateFramesFor
(
mozilla
:
:
dom
:
:
Element
*
)
;
void
RestyleForAnimation
(
mozilla
:
:
dom
:
:
Element
*
mozilla
:
:
RestyleHint
)
;
void
RecordShadowStyleChange
(
mozilla
:
:
dom
:
:
ShadowRoot
&
aShadowRoot
)
;
bool
IsSafeToFlush
(
)
const
;
void
NotifyFontFaceSetOnRefresh
(
)
;
void
FlushPendingNotifications
(
mozilla
:
:
FlushType
aType
)
{
if
(
!
NeedFlush
(
aType
)
)
{
return
;
}
DoFlushPendingNotifications
(
aType
)
;
}
void
FlushPendingNotifications
(
mozilla
:
:
ChangesToFlush
aType
)
{
if
(
!
NeedFlush
(
aType
.
mFlushType
)
)
{
return
;
}
DoFlushPendingNotifications
(
aType
)
;
}
protected
:
virtual
void
DoFlushPendingNotifications
(
mozilla
:
:
FlushType
aType
)
=
0
;
virtual
void
DoFlushPendingNotifications
(
mozilla
:
:
ChangesToFlush
aType
)
=
0
;
public
:
bool
NeedFlush
(
mozilla
:
:
FlushType
aType
)
const
{
MOZ_ASSERT
(
aType
>
=
mozilla
:
:
FlushType
:
:
Style
)
;
return
mNeedStyleFlush
|
|
(
mNeedLayoutFlush
&
&
aType
>
=
mozilla
:
:
FlushType
:
:
InterruptibleLayout
)
|
|
aType
>
=
mozilla
:
:
FlushType
:
:
Display
|
|
mNeedThrottledAnimationFlush
|
|
mInFlush
;
}
inline
void
EnsureStyleFlush
(
)
;
inline
void
SetNeedStyleFlush
(
)
;
inline
void
SetNeedLayoutFlush
(
)
;
inline
void
SetNeedThrottledAnimationFlush
(
)
;
void
StopObservingRefreshDriver
(
)
;
void
StartObservingRefreshDriver
(
)
;
bool
ObservingStyleFlushes
(
)
const
{
return
mObservingStyleFlushes
;
}
bool
ObservingLayoutFlushes
(
)
const
{
return
mObservingLayoutFlushes
;
}
void
ObserveStyleFlushes
(
)
{
if
(
!
ObservingStyleFlushes
(
)
)
DoObserveStyleFlushes
(
)
;
}
bool
NeedStyleFlush
(
)
const
{
return
mNeedStyleFlush
;
}
bool
NeedLayoutFlush
(
)
const
{
return
mNeedLayoutFlush
;
}
nsresult
PostReflowCallback
(
nsIReflowCallback
*
aCallback
)
;
void
CancelReflowCallback
(
nsIReflowCallback
*
aCallback
)
;
void
HandlePostedReflowCallbacks
(
bool
aInterruptible
)
;
void
ScheduleBeforeFirstPaint
(
)
;
void
UnsuppressAndInvalidate
(
)
;
void
ClearFrameRefs
(
nsIFrame
*
aFrame
)
;
already_AddRefed
<
gfxContext
>
CreateReferenceRenderingContext
(
)
;
nsresult
GoToAnchor
(
const
nsAString
&
aAnchorName
bool
aScroll
uint32_t
aAdditionalScrollFlags
=
0
)
;
nsresult
ScrollToAnchor
(
)
;
enum
{
SCROLL_TOP
=
0
SCROLL_BOTTOM
=
100
SCROLL_LEFT
=
0
SCROLL_RIGHT
=
100
SCROLL_CENTER
=
50
SCROLL_MINIMUM
=
-
1
}
;
enum
WhenToScroll
{
SCROLL_ALWAYS
SCROLL_IF_NOT_VISIBLE
SCROLL_IF_NOT_FULLY_VISIBLE
}
;
typedef
struct
ScrollAxis
{
int16_t
mWhereToScroll
;
WhenToScroll
mWhenToScroll
:
8
;
bool
mOnlyIfPerceivedScrollableDirection
:
1
;
explicit
ScrollAxis
(
int16_t
aWhere
=
SCROLL_MINIMUM
WhenToScroll
aWhen
=
SCROLL_IF_NOT_FULLY_VISIBLE
bool
aOnlyIfPerceivedScrollableDirection
=
false
)
:
mWhereToScroll
(
aWhere
)
mWhenToScroll
(
aWhen
)
mOnlyIfPerceivedScrollableDirection
(
aOnlyIfPerceivedScrollableDirection
)
{
}
}
ScrollAxis
;
nsresult
ScrollContentIntoView
(
nsIContent
*
aContent
ScrollAxis
aVertical
ScrollAxis
aHorizontal
uint32_t
aFlags
)
;
enum
{
SCROLL_FIRST_ANCESTOR_ONLY
=
0x01
SCROLL_OVERFLOW_HIDDEN
=
0x02
SCROLL_NO_PARENT_FRAMES
=
0x04
SCROLL_SMOOTH
=
0x08
SCROLL_SMOOTH_AUTO
=
0x10
}
;
bool
ScrollFrameRectIntoView
(
nsIFrame
*
aFrame
const
nsRect
&
aRect
ScrollAxis
aVertical
ScrollAxis
aHorizontal
uint32_t
aFlags
)
;
virtual
nsRectVisibility
GetRectVisibility
(
nsIFrame
*
aFrame
const
nsRect
&
aRect
nscoord
aMinTwips
)
const
=
0
;
void
SetIgnoreFrameDestruction
(
bool
aIgnore
)
;
void
NotifyDestroyingFrame
(
nsIFrame
*
aFrame
)
;
already_AddRefed
<
mozilla
:
:
AccessibleCaretEventHub
>
GetAccessibleCaretEventHub
(
)
const
;
already_AddRefed
<
nsCaret
>
GetCaret
(
)
const
;
void
SetCaret
(
nsCaret
*
aNewCaret
)
;
void
RestoreCaret
(
)
;
NS_IMETHOD
SetSelectionFlags
(
int16_t
aInEnable
)
=
0
;
int16_t
GetSelectionFlags
(
)
const
{
return
mSelectionFlags
;
}
virtual
mozilla
:
:
dom
:
:
Selection
*
GetCurrentSelection
(
mozilla
:
:
SelectionType
aSelectionType
)
=
0
;
virtual
already_AddRefed
<
nsISelectionController
>
GetSelectionControllerForFocusedContent
(
nsIContent
*
*
aFocusedContent
=
nullptr
)
=
0
;
virtual
nsresult
HandleEventWithTarget
(
mozilla
:
:
WidgetEvent
*
aEvent
nsIFrame
*
aFrame
nsIContent
*
aContent
nsEventStatus
*
aStatus
bool
aIsHandlingNativeEvent
=
false
nsIContent
*
*
aTargetContent
=
nullptr
nsIContent
*
aOverrideClickTarget
=
nullptr
)
=
0
;
virtual
nsresult
HandleDOMEventWithTarget
(
nsIContent
*
aTargetContent
mozilla
:
:
WidgetEvent
*
aEvent
nsEventStatus
*
aStatus
)
=
0
;
virtual
nsresult
HandleDOMEventWithTarget
(
nsIContent
*
aTargetContent
mozilla
:
:
dom
:
:
Event
*
aEvent
nsEventStatus
*
aStatus
)
=
0
;
virtual
bool
CanDispatchEvent
(
const
mozilla
:
:
WidgetGUIEvent
*
aEvent
=
nullptr
)
const
=
0
;
nsIFrame
*
GetCurrentEventFrame
(
)
;
already_AddRefed
<
nsIContent
>
GetEventTargetContent
(
mozilla
:
:
WidgetEvent
*
aEvent
)
;
virtual
nsresult
CaptureHistoryState
(
nsILayoutHistoryState
*
*
aLayoutHistoryState
)
=
0
;
bool
IsReflowLocked
(
)
const
{
return
mIsReflowing
;
}
bool
IsPaintingSuppressed
(
)
const
{
return
mPaintingSuppressed
;
}
virtual
void
PausePainting
(
)
=
0
;
virtual
void
ResumePainting
(
)
=
0
;
virtual
void
UnsuppressPainting
(
)
=
0
;
virtual
nsresult
GetAgentStyleSheets
(
nsTArray
<
RefPtr
<
mozilla
:
:
StyleSheet
>
>
&
aSheets
)
=
0
;
virtual
nsresult
SetAgentStyleSheets
(
const
nsTArray
<
RefPtr
<
mozilla
:
:
StyleSheet
>
>
&
aSheets
)
=
0
;
virtual
nsresult
AddOverrideStyleSheet
(
mozilla
:
:
StyleSheet
*
aSheet
)
=
0
;
virtual
nsresult
RemoveOverrideStyleSheet
(
mozilla
:
:
StyleSheet
*
aSheet
)
=
0
;
virtual
void
ReconstructFrames
(
)
=
0
;
virtual
void
ContentStateChanged
(
Document
*
aDocument
nsIContent
*
aContent
mozilla
:
:
EventStates
aStateMask
)
override
=
0
;
static
bool
GetVerifyReflowEnable
(
)
;
static
void
SetVerifyReflowEnable
(
bool
aEnabled
)
;
nsIFrame
*
GetAbsoluteContainingBlock
(
nsIFrame
*
aFrame
)
;
#
ifdef
MOZ_REFLOW_PERF
virtual
void
DumpReflows
(
)
=
0
;
virtual
void
CountReflows
(
const
char
*
aName
nsIFrame
*
aFrame
)
=
0
;
virtual
void
PaintCount
(
const
char
*
aName
gfxContext
*
aRenderingContext
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
const
nsPoint
&
aOffset
uint32_t
aColor
)
=
0
;
virtual
void
SetPaintFrameCount
(
bool
aOn
)
=
0
;
virtual
bool
IsPaintingFrameCounts
(
)
=
0
;
#
endif
#
ifdef
DEBUG
virtual
void
ListComputedStyles
(
FILE
*
out
int32_t
aIndent
=
0
)
=
0
;
virtual
void
ListStyleSheets
(
FILE
*
out
int32_t
aIndent
=
0
)
=
0
;
#
endif
#
ifdef
ACCESSIBILITY
static
bool
IsAccessibilityActive
(
)
;
static
nsAccessibilityService
*
AccService
(
)
;
#
endif
virtual
void
Freeze
(
)
=
0
;
bool
IsFrozen
(
)
{
return
mFrozen
;
}
virtual
void
Thaw
(
)
=
0
;
virtual
void
FireOrClearDelayedEvents
(
bool
aFireEvents
)
=
0
;
void
SetForwardingContainer
(
const
mozilla
:
:
WeakPtr
<
nsDocShell
>
&
aContainer
)
;
enum
{
RENDER_IS_UNTRUSTED
=
0x01
RENDER_IGNORE_VIEWPORT_SCROLLING
=
0x02
RENDER_CARET
=
0x04
RENDER_USE_WIDGET_LAYERS
=
0x08
RENDER_ASYNC_DECODE_IMAGES
=
0x10
RENDER_DOCUMENT_RELATIVE
=
0x20
RENDER_DRAWWINDOW_NOT_FLUSHING
=
0x40
}
;
virtual
nsresult
RenderDocument
(
const
nsRect
&
aRect
uint32_t
aFlags
nscolor
aBackgroundColor
gfxContext
*
aRenderedContext
)
=
0
;
enum
{
RENDER_IS_IMAGE
=
0x100
RENDER_AUTO_SCALE
=
0x80
}
;
virtual
already_AddRefed
<
mozilla
:
:
gfx
:
:
SourceSurface
>
RenderNode
(
nsINode
*
aNode
const
mozilla
:
:
Maybe
<
mozilla
:
:
CSSIntRegion
>
&
aRegion
const
mozilla
:
:
LayoutDeviceIntPoint
aPoint
mozilla
:
:
LayoutDeviceIntRect
*
aScreenRect
uint32_t
aFlags
)
=
0
;
virtual
already_AddRefed
<
mozilla
:
:
gfx
:
:
SourceSurface
>
RenderSelection
(
mozilla
:
:
dom
:
:
Selection
*
aSelection
const
mozilla
:
:
LayoutDeviceIntPoint
aPoint
mozilla
:
:
LayoutDeviceIntRect
*
aScreenRect
uint32_t
aFlags
)
=
0
;
void
AddAutoWeakFrame
(
AutoWeakFrame
*
aWeakFrame
)
;
void
AddWeakFrame
(
WeakFrame
*
aWeakFrame
)
;
void
RemoveAutoWeakFrame
(
AutoWeakFrame
*
aWeakFrame
)
;
void
RemoveWeakFrame
(
WeakFrame
*
aWeakFrame
)
;
#
ifdef
DEBUG
nsIFrame
*
GetDrawEventTargetFrame
(
)
{
return
mDrawEventTargetFrame
;
}
#
endif
virtual
void
DisableNonTestMouseEvents
(
bool
aDisable
)
=
0
;
void
SetCanvasBackground
(
nscolor
aColor
)
{
mCanvasBackgroundColor
=
aColor
;
}
nscolor
GetCanvasBackground
(
)
{
return
mCanvasBackgroundColor
;
}
virtual
void
UpdateCanvasBackground
(
)
=
0
;
enum
{
FORCE_DRAW
=
0x01
ADD_FOR_SUBDOC
=
0x02
APPEND_UNSCROLLED_ONLY
=
0x04
}
;
virtual
void
AddCanvasBackgroundColorItem
(
nsDisplayListBuilder
&
aBuilder
nsDisplayList
&
aList
nsIFrame
*
aFrame
const
nsRect
&
aBounds
nscolor
aBackstopColor
=
NS_RGBA
(
0
0
0
0
)
uint32_t
aFlags
=
0
)
=
0
;
virtual
void
AddPrintPreviewBackgroundItem
(
nsDisplayListBuilder
&
aBuilder
nsDisplayList
&
aList
nsIFrame
*
aFrame
const
nsRect
&
aBounds
)
=
0
;
virtual
nscolor
ComputeBackstopColor
(
nsView
*
aDisplayRoot
)
=
0
;
void
ObserveNativeAnonMutationsForPrint
(
bool
aObserve
)
{
mObservesMutationsForPrint
=
aObserve
;
}
bool
ObservesNativeAnonMutationsForPrint
(
)
{
return
mObservesMutationsForPrint
;
}
virtual
nsresult
SetIsActive
(
bool
aIsActive
)
=
0
;
bool
IsActive
(
)
{
return
mIsActive
;
}
static
CapturingContentInfo
gCaptureInfo
;
static
void
SetCapturingContent
(
nsIContent
*
aContent
uint8_t
aFlags
)
;
static
nsIContent
*
GetCapturingContent
(
)
{
return
gCaptureInfo
.
mContent
;
}
static
void
AllowMouseCapture
(
bool
aAllowed
)
{
gCaptureInfo
.
mAllowed
=
aAllowed
;
}
static
bool
IsMouseCapturePreventingDrag
(
)
{
return
gCaptureInfo
.
mPreventDrag
&
&
gCaptureInfo
.
mContent
;
}
uint64_t
GetPaintCount
(
)
{
return
mPaintCount
;
}
void
IncrementPaintCount
(
)
{
+
+
mPaintCount
;
}
virtual
already_AddRefed
<
nsPIDOMWindowOuter
>
GetRootWindow
(
)
=
0
;
virtual
already_AddRefed
<
nsPIDOMWindowOuter
>
GetFocusedDOMWindowInOurWindow
(
)
=
0
;
already_AddRefed
<
nsIContent
>
GetFocusedContentInOurWindow
(
)
const
;
virtual
LayerManager
*
GetLayerManager
(
)
=
0
;
virtual
bool
AsyncPanZoomEnabled
(
)
=
0
;
virtual
void
SetIgnoreViewportScrolling
(
bool
aIgnore
)
=
0
;
bool
IgnoringViewportScrolling
(
)
const
{
return
mRenderFlags
&
STATE_IGNORING_VIEWPORT_SCROLLING
;
}
enum
class
ChangeOrigin
:
uint8_t
{
eApz
eMainThread
}
;
virtual
nsresult
SetResolutionAndScaleTo
(
float
aResolution
ChangeOrigin
aOrigin
)
=
0
;
float
GetResolution
(
)
const
{
return
mResolution
.
valueOr
(
1
.
0
)
;
}
virtual
float
GetCumulativeResolution
(
)
=
0
;
bool
IsResolutionUpdated
(
)
const
{
return
mResolutionUpdated
;
}
void
SetResolutionUpdated
(
bool
aUpdated
)
{
mResolutionUpdated
=
aUpdated
;
}
bool
IsResolutionUpdatedByApz
(
)
const
{
return
mResolutionUpdatedByApz
;
}
virtual
float
GetCumulativeNonRootScaleResolution
(
)
=
0
;
virtual
void
SetRestoreResolution
(
float
aResolution
mozilla
:
:
LayoutDeviceIntSize
aDisplaySize
)
=
0
;
bool
InDrawWindowNotFlushing
(
)
const
{
return
mRenderFlags
&
STATE_DRAWWINDOW_NOT_FLUSHING
;
}
void
SetIsFirstPaint
(
bool
aIsFirstPaint
)
{
mIsFirstPaint
=
aIsFirstPaint
;
}
bool
GetIsFirstPaint
(
)
const
{
return
mIsFirstPaint
;
}
uint32_t
GetPresShellId
(
)
{
return
mPresShellId
;
}
virtual
void
SynthesizeMouseMove
(
bool
aFromScroll
)
=
0
;
enum
PaintFlags
{
PAINT_LAYERS
=
0x01
PAINT_COMPOSITE
=
0x02
PAINT_SYNC_DECODE_IMAGES
=
0x04
}
;
virtual
void
Paint
(
nsView
*
aViewToPaint
const
nsRegion
&
aDirtyRegion
uint32_t
aFlags
)
=
0
;
MOZ_CAN_RUN_SCRIPT
virtual
nsresult
HandleEvent
(
nsIFrame
*
aFrame
mozilla
:
:
WidgetGUIEvent
*
aEvent
bool
aDontRetargetEvents
nsEventStatus
*
aEventStatus
)
=
0
;
virtual
bool
ShouldIgnoreInvalidation
(
)
=
0
;
virtual
void
WillPaint
(
)
=
0
;
virtual
void
WillPaintWindow
(
)
=
0
;
virtual
void
DidPaintWindow
(
)
=
0
;
enum
PaintType
{
PAINT_DEFAULT
PAINT_DELAYED_COMPRESS
}
;
virtual
void
ScheduleViewManagerFlush
(
PaintType
aType
=
PAINT_DEFAULT
)
=
0
;
virtual
void
ClearMouseCaptureOnView
(
nsView
*
aView
)
=
0
;
virtual
bool
IsVisible
(
)
=
0
;
MOZ_CAN_RUN_SCRIPT
void
DispatchSynthMouseMove
(
mozilla
:
:
WidgetGUIEvent
*
aEvent
)
;
virtual
void
SuppressDisplayport
(
bool
aEnabled
)
=
0
;
virtual
void
RespectDisplayportSuppression
(
bool
aEnabled
)
=
0
;
virtual
bool
IsDisplayportSuppressed
(
)
=
0
;
virtual
void
AddSizeOfIncludingThis
(
nsWindowSizes
&
aWindowSizes
)
const
=
0
;
uint32_t
FontSizeInflationEmPerLine
(
)
const
{
return
mFontSizeInflationEmPerLine
;
}
uint32_t
FontSizeInflationMinTwips
(
)
const
{
return
mFontSizeInflationMinTwips
;
}
uint32_t
FontSizeInflationLineThreshold
(
)
const
{
return
mFontSizeInflationLineThreshold
;
}
bool
FontSizeInflationForceEnabled
(
)
const
{
return
mFontSizeInflationForceEnabled
;
}
bool
FontSizeInflationDisabledInMasterProcess
(
)
const
{
return
mFontSizeInflationDisabledInMasterProcess
;
}
bool
FontSizeInflationEnabled
(
)
const
{
return
mFontSizeInflationEnabled
;
}
void
RecomputeFontSizeInflationEnabled
(
)
;
bool
IsReflowInterrupted
(
)
const
{
return
mWasLastReflowInterrupted
;
}
bool
SuppressInterruptibleReflows
(
)
const
{
return
mWasLastReflowInterrupted
;
}
virtual
void
ScheduleApproximateFrameVisibilityUpdateSoon
(
)
=
0
;
virtual
void
ScheduleApproximateFrameVisibilityUpdateNow
(
)
=
0
;
virtual
void
RebuildApproximateFrameVisibilityDisplayList
(
const
nsDisplayList
&
aList
)
=
0
;
virtual
void
RebuildApproximateFrameVisibility
(
nsRect
*
aRect
=
nullptr
bool
aRemoveOnly
=
false
)
=
0
;
virtual
void
EnsureFrameInApproximatelyVisibleList
(
nsIFrame
*
aFrame
)
=
0
;
virtual
void
RemoveFrameFromApproximatelyVisibleList
(
nsIFrame
*
aFrame
)
=
0
;
virtual
bool
AssumeAllFramesVisible
(
)
=
0
;
nsresult
HasRuleProcessorUsedByMultipleStyleSets
(
uint32_t
aSheetType
bool
*
aRetVal
)
;
virtual
bool
HasHandledUserInput
(
)
const
=
0
;
virtual
void
FireResizeEvent
(
)
=
0
;
void
NativeAnonymousContentRemoved
(
nsIContent
*
aAnonContent
)
;
virtual
void
SetKeyPressEventModel
(
uint16_t
aKeyPressEventModel
)
=
0
;
protected
:
void
DoObserveStyleFlushes
(
)
;
void
DoObserveLayoutFlushes
(
)
;
bool
DetermineFontSizeInflationState
(
)
;
void
RecordAlloc
(
void
*
aPtr
)
{
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
MOZ_DIAGNOSTIC_ASSERT
(
!
mAllocatedPointers
.
Contains
(
aPtr
)
)
;
mAllocatedPointers
.
PutEntry
(
aPtr
)
;
#
endif
}
void
RecordFree
(
void
*
aPtr
)
{
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
MOZ_DIAGNOSTIC_ASSERT
(
mAllocatedPointers
.
Contains
(
aPtr
)
)
;
mAllocatedPointers
.
RemoveEntry
(
aPtr
)
;
#
endif
}
void
PushCurrentEventInfo
(
nsIFrame
*
aFrame
nsIContent
*
aContent
)
;
void
PopCurrentEventInfo
(
)
;
nsIContent
*
GetCurrentEventContent
(
)
;
public
:
bool
AddRefreshObserver
(
nsARefreshObserver
*
aObserver
mozilla
:
:
FlushType
aFlushType
)
;
bool
RemoveRefreshObserver
(
nsARefreshObserver
*
aObserver
mozilla
:
:
FlushType
aFlushType
)
;
bool
AddPostRefreshObserver
(
nsAPostRefreshObserver
*
aObserver
)
;
bool
RemovePostRefreshObserver
(
nsAPostRefreshObserver
*
aObserver
)
;
static
void
ClearMouseCapture
(
nsIFrame
*
aFrame
)
;
void
SetVisualViewportSize
(
nscoord
aWidth
nscoord
aHeight
)
;
void
ResetVisualViewportSize
(
)
;
bool
IsVisualViewportSizeSet
(
)
{
return
mVisualViewportSizeSet
;
}
nsSize
GetVisualViewportSize
(
)
{
NS_ASSERTION
(
mVisualViewportSizeSet
"
asking
for
visual
viewport
size
when
its
not
set
?
"
)
;
return
mVisualViewportSize
;
}
void
CompleteChangeToVisualViewportSize
(
)
;
bool
SetVisualViewportOffset
(
const
nsPoint
&
aScrollOffset
const
nsPoint
&
aPrevLayoutScrollPos
)
;
nsPoint
GetVisualViewportOffset
(
)
const
{
return
mVisualViewportOffset
.
valueOr
(
nsPoint
(
)
)
;
}
bool
IsVisualViewportOffsetSet
(
)
const
{
return
mVisualViewportOffset
.
isSome
(
)
;
}
nsPoint
GetVisualViewportOffsetRelativeToLayoutViewport
(
)
const
;
struct
VisualScrollUpdate
{
nsPoint
mVisualScrollOffset
;
FrameMetrics
:
:
ScrollOffsetUpdateType
mUpdateType
;
}
;
void
ScrollToVisual
(
const
nsPoint
&
aVisualViewportOffset
FrameMetrics
:
:
ScrollOffsetUpdateType
aUpdateType
mozilla
:
:
ScrollMode
aMode
)
;
void
ClearPendingVisualScrollUpdate
(
)
{
mPendingVisualScrollUpdate
=
mozilla
:
:
Nothing
(
)
;
}
const
mozilla
:
:
Maybe
<
VisualScrollUpdate
>
&
GetPendingVisualScrollUpdate
(
)
const
{
return
mPendingVisualScrollUpdate
;
}
nsPoint
GetLayoutViewportOffset
(
)
const
;
nsSize
GetLayoutViewportSize
(
)
const
;
virtual
void
WindowSizeMoveDone
(
)
=
0
;
virtual
void
SysColorChanged
(
)
=
0
;
virtual
void
ThemeChanged
(
)
=
0
;
virtual
void
BackingScaleFactorChanged
(
)
=
0
;
bool
IsNeverPainting
(
)
{
return
mIsNeverPainting
;
}
void
SetNeverPainting
(
bool
aNeverPainting
)
{
mIsNeverPainting
=
aNeverPainting
;
}
bool
HasPendingReflow
(
)
const
{
return
mObservingLayoutFlushes
|
|
mReflowContinueTimer
;
}
void
SyncWindowProperties
(
nsView
*
aView
)
;
virtual
Document
*
GetPrimaryContentDocument
(
)
=
0
;
void
NotifyStyleSheetServiceSheetAdded
(
mozilla
:
:
StyleSheet
*
aSheet
uint32_t
aSheetType
)
;
void
NotifyStyleSheetServiceSheetRemoved
(
mozilla
:
:
StyleSheet
*
aSheet
uint32_t
aSheetType
)
;
struct
MOZ_RAII
AutoAssertNoFlush
{
explicit
AutoAssertNoFlush
(
nsIPresShell
&
aShell
)
:
mShell
(
aShell
)
mOldForbidden
(
mShell
.
mForbiddenToFlush
)
{
mShell
.
mForbiddenToFlush
=
true
;
}
~
AutoAssertNoFlush
(
)
{
mShell
.
mForbiddenToFlush
=
mOldForbidden
;
}
nsIPresShell
&
mShell
;
const
bool
mOldForbidden
;
}
;
protected
:
friend
class
nsRefreshDriver
;
friend
class
:
:
nsAutoCauseReflowNotifier
;
void
WillCauseReflow
(
)
;
void
DidCauseReflow
(
)
;
void
CancelPostedReflowCallbacks
(
)
;
void
FlushPendingScrollAnchorAdjustments
(
)
;
void
SetPendingVisualScrollUpdate
(
const
nsPoint
&
aVisualViewportOffset
FrameMetrics
:
:
ScrollOffsetUpdateType
aUpdateType
)
;
#
ifdef
DEBUG
bool
VerifyIncrementalReflow
(
)
;
void
DoVerifyReflow
(
)
;
void
VerifyHasDirtyRootAncestor
(
nsIFrame
*
aFrame
)
;
void
ShowEventTargetDebug
(
)
;
bool
mInVerifyReflow
=
false
;
nsIFrame
*
mCurrentReflowRoot
=
nullptr
;
#
endif
#
ifdef
MOZ_REFLOW_PERF
mozilla
:
:
UniquePtr
<
ReflowCountMgr
>
mReflowCountMgr
;
#
endif
void
DoScrollContentIntoView
(
)
;
void
AddUserSheet
(
mozilla
:
:
StyleSheet
*
)
;
void
AddAgentSheet
(
mozilla
:
:
StyleSheet
*
)
;
void
AddAuthorSheet
(
mozilla
:
:
StyleSheet
*
)
;
void
RemoveSheet
(
mozilla
:
:
SheetType
mozilla
:
:
StyleSheet
*
)
;
void
RemovePreferenceStyles
(
)
;
void
WillDoReflow
(
)
;
struct
ScrollIntoViewData
{
ScrollAxis
mContentScrollVAxis
;
ScrollAxis
mContentScrollHAxis
;
uint32_t
mContentToScrollToFlags
;
}
;
static
mozilla
:
:
LazyLogModule
gLog
;
DOMHighResTimeStamp
GetPerformanceNowUnclamped
(
)
;
void
DidDoReflow
(
bool
aInterruptible
)
;
bool
ProcessReflowCommands
(
bool
aInterruptible
)
;
static
void
sReflowContinueCallback
(
nsITimer
*
aTimer
void
*
aPresShell
)
;
bool
ScheduleReflowOffTimer
(
)
;
void
MaybeScheduleReflow
(
)
;
void
ScheduleReflow
(
)
;
bool
DoReflow
(
nsIFrame
*
aFrame
bool
aInterruptible
mozilla
:
:
OverflowChangedTracker
*
aOverflowTracker
)
;
RefPtr
<
Document
>
mDocument
;
RefPtr
<
nsPresContext
>
mPresContext
;
RefPtr
<
mozilla
:
:
StyleSheet
>
mPrefStyleSheet
;
mozilla
:
:
UniquePtr
<
nsCSSFrameConstructor
>
mFrameConstructor
;
nsViewManager
*
mViewManager
;
nsPresArena
<
8192
>
mFrameArena
;
RefPtr
<
nsFrameSelection
>
mSelection
;
RefPtr
<
nsCaret
>
mCaret
;
RefPtr
<
nsCaret
>
mOriginalCaret
;
RefPtr
<
mozilla
:
:
AccessibleCaretEventHub
>
mAccessibleCaretEventHub
;
nsFrameManager
*
mFrameManager
;
mozilla
:
:
WeakPtr
<
nsDocShell
>
mForwardingContainer
;
#
ifdef
ACCESSIBILITY
mozilla
:
:
a11y
:
:
DocAccessible
*
mDocAccessible
;
#
endif
DOMHighResTimeStamp
mLastReflowStart
{
0
.
0
}
;
nsCOMPtr
<
nsITimer
>
mReflowContinueTimer
;
#
ifdef
DEBUG
nsIFrame
*
mDrawEventTargetFrame
=
nullptr
;
#
endif
#
ifdef
MOZ_DIAGNOSTIC_ASSERT_ENABLED
nsTHashtable
<
nsPtrHashKey
<
void
>
>
mAllocatedPointers
;
#
endif
nsCOMPtr
<
nsIContent
>
mLastAnchorScrolledTo
;
nsCOMPtr
<
nsIContent
>
mContentToScrollTo
;
nscoord
mLastAnchorScrollPositionY
=
0
;
uint64_t
mPaintCount
;
nsSize
mVisualViewportSize
;
mozilla
:
:
Maybe
<
nsPoint
>
mVisualViewportOffset
;
mozilla
:
:
Maybe
<
VisualScrollUpdate
>
mPendingVisualScrollUpdate
;
AutoWeakFrame
*
mAutoWeakFrames
;
nsTHashtable
<
nsPtrHashKey
<
WeakFrame
>
>
mWeakFrames
;
class
DirtyRootsList
{
public
:
void
Add
(
nsIFrame
*
aFrame
)
;
void
Remove
(
nsIFrame
*
aFrame
)
;
nsIFrame
*
PopShallowestRoot
(
)
;
void
Clear
(
)
;
bool
Contains
(
nsIFrame
*
aFrame
)
const
;
bool
IsEmpty
(
)
const
;
bool
FrameIsAncestorOfDirtyRoot
(
nsIFrame
*
aFrame
)
const
;
private
:
struct
FrameAndDepth
{
nsIFrame
*
mFrame
;
const
uint32_t
mDepth
;
operator
nsIFrame
*
(
)
const
{
return
mFrame
;
}
class
CompareByReverseDepth
{
public
:
bool
Equals
(
const
FrameAndDepth
&
aA
const
FrameAndDepth
&
aB
)
const
{
return
aA
.
mDepth
=
=
aB
.
mDepth
;
}
bool
LessThan
(
const
FrameAndDepth
&
aA
const
FrameAndDepth
&
aB
)
const
{
return
aA
.
mDepth
>
aB
.
mDepth
;
}
}
;
}
;
nsTArray
<
FrameAndDepth
>
mList
;
}
;
DirtyRootsList
mDirtyRoots
;
#
ifdef
MOZ_GECKO_PROFILER
UniqueProfilerBacktrace
mStyleCause
;
UniqueProfilerBacktrace
mReflowCause
;
#
endif
nscolor
mCanvasBackgroundColor
;
mozilla
:
:
Maybe
<
float
>
mResolution
;
int16_t
mSelectionFlags
;
uint16_t
mChangeNestCount
;
RenderFlags
mRenderFlags
;
bool
mDidInitialize
:
1
;
bool
mIsDestroying
:
1
;
bool
mIsReflowing
:
1
;
bool
mIsObservingDocument
:
1
;
bool
mForbiddenToFlush
:
1
;
bool
mIsDocumentGone
:
1
;
bool
mHaveShutDown
:
1
;
bool
mPaintingSuppressed
:
1
;
bool
mLastRootReflowHadUnconstrainedBSize
:
1
;
bool
mShouldUnsuppressPainting
:
1
;
bool
mIgnoreFrameDestruction
:
1
;
bool
mIsActive
:
1
;
bool
mFrozen
:
1
;
bool
mIsFirstPaint
:
1
;
bool
mObservesMutationsForPrint
:
1
;
bool
mWasLastReflowInterrupted
:
1
;
bool
mVisualViewportSizeSet
:
1
;
bool
mNeedLayoutFlush
:
1
;
bool
mNeedStyleFlush
:
1
;
bool
mObservingStyleFlushes
:
1
;
bool
mObservingLayoutFlushes
:
1
;
bool
mResizeEventPending
:
1
;
bool
mNeedThrottledAnimationFlush
:
1
;
bool
mFontSizeInflationForceEnabled
:
1
;
bool
mFontSizeInflationDisabledInMasterProcess
:
1
;
bool
mFontSizeInflationEnabled
:
1
;
bool
mPaintingIsFrozen
:
1
;
bool
mIsNeverPainting
:
1
;
bool
mResolutionUpdated
:
1
;
bool
mResolutionUpdatedByApz
:
1
;
uint32_t
mPresShellId
;
uint32_t
mFontSizeInflationEmPerLine
;
uint32_t
mFontSizeInflationMinTwips
;
uint32_t
mFontSizeInflationLineThreshold
;
bool
mInFlush
;
nsIFrame
*
mCurrentEventFrame
;
nsCOMPtr
<
nsIContent
>
mCurrentEventContent
;
nsTArray
<
nsIFrame
*
>
mCurrentEventFrameStack
;
nsCOMArray
<
nsIContent
>
mCurrentEventContentStack
;
nsTHashtable
<
nsPtrHashKey
<
nsIFrame
>
>
mFramesToDirty
;
nsTHashtable
<
nsPtrHashKey
<
nsIScrollableFrame
>
>
mPendingScrollAnchorSelection
;
nsTHashtable
<
nsPtrHashKey
<
nsIScrollableFrame
>
>
mPendingScrollAnchorAdjustment
;
nsCallbackEventRequest
*
mFirstCallbackEventRequest
=
nullptr
;
nsCallbackEventRequest
*
mLastCallbackEventRequest
=
nullptr
;
}
;
NS_DEFINE_STATIC_IID_ACCESSOR
(
nsIPresShell
NS_IPRESSHELL_IID
)
#
endif
