#
include
"
mozilla
/
StaticPresData
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
nsPresContext
.
h
"
namespace
mozilla
{
static
StaticPresData
*
sSingleton
=
nullptr
;
void
StaticPresData
:
:
Init
(
)
{
MOZ_ASSERT
(
!
sSingleton
)
;
sSingleton
=
new
StaticPresData
(
)
;
}
void
StaticPresData
:
:
Shutdown
(
)
{
MOZ_ASSERT
(
sSingleton
)
;
delete
sSingleton
;
sSingleton
=
nullptr
;
}
StaticPresData
*
StaticPresData
:
:
Get
(
)
{
MOZ_ASSERT
(
sSingleton
)
;
return
sSingleton
;
}
StaticPresData
:
:
StaticPresData
(
)
{
mLangService
=
nsLanguageAtomService
:
:
GetService
(
)
;
mBorderWidthTable
[
NS_STYLE_BORDER_WIDTH_THIN
]
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
1
)
;
mBorderWidthTable
[
NS_STYLE_BORDER_WIDTH_MEDIUM
]
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
3
)
;
mBorderWidthTable
[
NS_STYLE_BORDER_WIDTH_THICK
]
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
5
)
;
}
#
define
MAKE_FONT_PREF_KEY
(
_pref
_s0
_s1
)
\
_pref
.
Assign
(
_s0
)
;
\
_pref
.
Append
(
_s1
)
;
static
const
char
*
const
kGenericFont
[
]
=
{
"
.
variable
.
"
"
.
fixed
.
"
"
.
serif
.
"
"
.
sans
-
serif
.
"
"
.
monospace
.
"
"
.
cursive
.
"
"
.
fantasy
.
"
}
;
enum
{
eDefaultFont_Variable
eDefaultFont_Fixed
eDefaultFont_Serif
eDefaultFont_SansSerif
eDefaultFont_Monospace
eDefaultFont_Cursive
eDefaultFont_Fantasy
eDefaultFont_COUNT
}
;
void
LangGroupFontPrefs
:
:
Initialize
(
nsIAtom
*
aLangGroupAtom
)
{
mLangGroup
=
aLangGroupAtom
;
nsAutoCString
langGroup
;
aLangGroupAtom
-
>
ToUTF8String
(
langGroup
)
;
mDefaultVariableFont
.
size
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
16
)
;
mDefaultFixedFont
.
size
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
13
)
;
nsAutoCString
pref
;
enum
{
eUnit_unknown
=
-
1
eUnit_px
eUnit_pt
}
;
int32_t
unit
=
eUnit_px
;
nsAdoptingCString
cvalue
=
Preferences
:
:
GetCString
(
"
font
.
size
.
unit
"
)
;
if
(
!
cvalue
.
IsEmpty
(
)
)
{
if
(
cvalue
.
EqualsLiteral
(
"
px
"
)
)
{
unit
=
eUnit_px
;
}
else
if
(
cvalue
.
EqualsLiteral
(
"
pt
"
)
)
{
unit
=
eUnit_pt
;
}
else
{
NS_WARNING
(
"
unexpected
font
-
size
unit
-
-
expected
:
'
px
'
or
'
pt
'
"
)
;
unit
=
eUnit_unknown
;
}
}
MAKE_FONT_PREF_KEY
(
pref
"
font
.
minimum
-
size
.
"
langGroup
)
;
int32_t
size
=
Preferences
:
:
GetInt
(
pref
.
get
(
)
)
;
if
(
unit
=
=
eUnit_px
)
{
mMinimumFontSize
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
size
)
;
}
else
if
(
unit
=
=
eUnit_pt
)
{
mMinimumFontSize
=
nsPresContext
:
:
CSSPointsToAppUnits
(
size
)
;
}
nsFont
*
fontTypes
[
]
=
{
&
mDefaultVariableFont
&
mDefaultFixedFont
&
mDefaultSerifFont
&
mDefaultSansSerifFont
&
mDefaultMonospaceFont
&
mDefaultCursiveFont
&
mDefaultFantasyFont
}
;
static_assert
(
MOZ_ARRAY_LENGTH
(
fontTypes
)
=
=
eDefaultFont_COUNT
"
FontTypes
array
count
is
not
correct
"
)
;
nsAutoCString
generic_dot_langGroup
;
for
(
uint32_t
eType
=
0
;
eType
<
ArrayLength
(
fontTypes
)
;
+
+
eType
)
{
generic_dot_langGroup
.
Assign
(
kGenericFont
[
eType
]
)
;
generic_dot_langGroup
.
Append
(
langGroup
)
;
nsFont
*
font
=
fontTypes
[
eType
]
;
if
(
eType
=
=
eDefaultFont_Variable
)
{
MAKE_FONT_PREF_KEY
(
pref
"
font
.
name
.
variable
.
"
langGroup
)
;
nsAdoptingString
value
=
Preferences
:
:
GetString
(
pref
.
get
(
)
)
;
if
(
!
value
.
IsEmpty
(
)
)
{
FontFamilyName
defaultVariableName
=
FontFamilyName
:
:
Convert
(
value
)
;
FontFamilyType
defaultType
=
defaultVariableName
.
mType
;
NS_ASSERTION
(
defaultType
=
=
eFamily_serif
|
|
defaultType
=
=
eFamily_sans_serif
"
default
type
must
be
serif
or
sans
-
serif
"
)
;
mDefaultVariableFont
.
fontlist
=
FontFamilyList
(
defaultType
)
;
}
else
{
MAKE_FONT_PREF_KEY
(
pref
"
font
.
default
.
"
langGroup
)
;
value
=
Preferences
:
:
GetString
(
pref
.
get
(
)
)
;
if
(
!
value
.
IsEmpty
(
)
)
{
FontFamilyName
defaultVariableName
=
FontFamilyName
:
:
Convert
(
value
)
;
FontFamilyType
defaultType
=
defaultVariableName
.
mType
;
NS_ASSERTION
(
defaultType
=
=
eFamily_serif
|
|
defaultType
=
=
eFamily_sans_serif
"
default
type
must
be
serif
or
sans
-
serif
"
)
;
mDefaultVariableFont
.
fontlist
=
FontFamilyList
(
defaultType
)
;
}
}
}
else
{
if
(
eType
=
=
eDefaultFont_Monospace
)
{
mDefaultMonospaceFont
.
size
=
mDefaultFixedFont
.
size
;
}
else
if
(
eType
!
=
eDefaultFont_Fixed
)
{
font
-
>
size
=
mDefaultVariableFont
.
size
;
}
}
MAKE_FONT_PREF_KEY
(
pref
"
font
.
size
"
generic_dot_langGroup
)
;
size
=
Preferences
:
:
GetInt
(
pref
.
get
(
)
)
;
if
(
size
>
0
)
{
if
(
unit
=
=
eUnit_px
)
{
font
-
>
size
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
size
)
;
}
else
if
(
unit
=
=
eUnit_pt
)
{
font
-
>
size
=
nsPresContext
:
:
CSSPointsToAppUnits
(
size
)
;
}
}
MAKE_FONT_PREF_KEY
(
pref
"
font
.
size
-
adjust
"
generic_dot_langGroup
)
;
cvalue
=
Preferences
:
:
GetCString
(
pref
.
get
(
)
)
;
if
(
!
cvalue
.
IsEmpty
(
)
)
{
font
-
>
sizeAdjust
=
(
float
)
atof
(
cvalue
.
get
(
)
)
;
}
#
ifdef
DEBUG_rbs
printf
(
"
%
s
Family
-
list
:
%
s
size
:
%
d
sizeAdjust
:
%
.
2f
\
n
"
generic_dot_langGroup
.
get
(
)
NS_ConvertUTF16toUTF8
(
font
-
>
name
)
.
get
(
)
font
-
>
size
font
-
>
sizeAdjust
)
;
#
endif
}
}
nsIAtom
*
StaticPresData
:
:
GetLangGroup
(
nsIAtom
*
aLanguage
bool
*
aNeedsToCache
)
const
{
nsIAtom
*
langGroupAtom
=
nullptr
;
langGroupAtom
=
mLangService
-
>
GetLanguageGroup
(
aLanguage
aNeedsToCache
)
;
if
(
!
langGroupAtom
)
{
langGroupAtom
=
nsGkAtoms
:
:
x_western
;
}
return
langGroupAtom
;
}
already_AddRefed
<
nsIAtom
>
StaticPresData
:
:
GetUncachedLangGroup
(
nsIAtom
*
aLanguage
)
const
{
nsCOMPtr
<
nsIAtom
>
langGroupAtom
=
mLangService
-
>
GetUncachedLanguageGroup
(
aLanguage
)
;
if
(
!
langGroupAtom
)
{
langGroupAtom
=
nsGkAtoms
:
:
x_western
;
}
return
langGroupAtom
.
forget
(
)
;
}
const
LangGroupFontPrefs
*
StaticPresData
:
:
GetFontPrefsForLangHelper
(
nsIAtom
*
aLanguage
const
LangGroupFontPrefs
*
aPrefs
bool
*
aNeedsToCache
)
const
{
MOZ_ASSERT
(
aLanguage
)
;
MOZ_ASSERT
(
mLangService
)
;
MOZ_ASSERT
(
aPrefs
)
;
nsIAtom
*
langGroupAtom
=
GetLangGroup
(
aLanguage
aNeedsToCache
)
;
if
(
aNeedsToCache
&
&
*
aNeedsToCache
)
{
return
nullptr
;
}
LangGroupFontPrefs
*
prefs
=
const_cast
<
LangGroupFontPrefs
*
>
(
aPrefs
)
;
if
(
prefs
-
>
mLangGroup
)
{
DebugOnly
<
uint32_t
>
count
=
0
;
for
(
;
;
)
{
NS_ASSERTION
(
+
+
count
<
35
"
Lang
group
count
exceeded
!
!
!
"
)
;
if
(
prefs
-
>
mLangGroup
=
=
langGroupAtom
)
{
return
prefs
;
}
if
(
!
prefs
-
>
mNext
)
{
break
;
}
prefs
=
prefs
-
>
mNext
;
}
if
(
aNeedsToCache
)
{
*
aNeedsToCache
=
true
;
return
nullptr
;
}
AssertIsMainThreadOrServoLangFontPrefsCacheLocked
(
)
;
prefs
=
prefs
-
>
mNext
=
new
LangGroupFontPrefs
;
}
if
(
aNeedsToCache
)
{
*
aNeedsToCache
=
true
;
return
nullptr
;
}
AssertIsMainThreadOrServoLangFontPrefsCacheLocked
(
)
;
prefs
-
>
Initialize
(
langGroupAtom
)
;
return
prefs
;
}
const
nsFont
*
StaticPresData
:
:
GetDefaultFontHelper
(
uint8_t
aFontID
nsIAtom
*
aLanguage
const
LangGroupFontPrefs
*
aPrefs
)
const
{
MOZ_ASSERT
(
aLanguage
)
;
MOZ_ASSERT
(
aPrefs
)
;
const
nsFont
*
font
;
switch
(
aFontID
)
{
case
kPresContext_DefaultVariableFont_ID
:
font
=
&
aPrefs
-
>
mDefaultVariableFont
;
break
;
case
kPresContext_DefaultFixedFont_ID
:
font
=
&
aPrefs
-
>
mDefaultFixedFont
;
break
;
case
kGenericFont_serif
:
font
=
&
aPrefs
-
>
mDefaultSerifFont
;
break
;
case
kGenericFont_sans_serif
:
font
=
&
aPrefs
-
>
mDefaultSansSerifFont
;
break
;
case
kGenericFont_monospace
:
font
=
&
aPrefs
-
>
mDefaultMonospaceFont
;
break
;
case
kGenericFont_cursive
:
font
=
&
aPrefs
-
>
mDefaultCursiveFont
;
break
;
case
kGenericFont_fantasy
:
font
=
&
aPrefs
-
>
mDefaultFantasyFont
;
break
;
default
:
font
=
nullptr
;
NS_ERROR
(
"
invalid
arg
"
)
;
break
;
}
return
font
;
}
}
