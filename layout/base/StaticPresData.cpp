#
include
"
mozilla
/
StaticPresData
.
h
"
#
include
"
gfxFontFeatures
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
mozilla
/
ServoUtils
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
nsPresContext
.
h
"
namespace
mozilla
{
static
StaticAutoPtr
<
StaticPresData
>
sSingleton
;
void
StaticPresData
:
:
Init
(
)
{
MOZ_ASSERT
(
!
sSingleton
)
;
sSingleton
=
new
StaticPresData
(
)
;
}
void
StaticPresData
:
:
Shutdown
(
)
{
MOZ_ASSERT
(
sSingleton
)
;
sSingleton
=
nullptr
;
}
StaticPresData
*
StaticPresData
:
:
Get
(
)
{
MOZ_ASSERT
(
sSingleton
)
;
return
sSingleton
;
}
StaticPresData
:
:
StaticPresData
(
)
{
mLangService
=
nsLanguageAtomService
:
:
GetService
(
)
;
}
#
define
MAKE_FONT_PREF_KEY
(
_pref
_s0
_s1
)
\
_pref
.
Assign
(
_s0
)
;
\
_pref
.
Append
(
_s1
)
;
static
const
char
*
const
kGenericFont
[
]
=
{
"
.
variable
.
"
"
.
serif
.
"
"
.
sans
-
serif
.
"
"
.
monospace
.
"
"
.
cursive
.
"
"
.
fantasy
.
"
"
.
system
-
ui
.
"
}
;
enum
class
DefaultFont
{
Variable
=
0
Serif
SansSerif
Monospace
Cursive
Fantasy
SystemUi
COUNT
}
;
void
LangGroupFontPrefs
:
:
Initialize
(
nsStaticAtom
*
aLangGroupAtom
)
{
mLangGroup
=
aLangGroupAtom
;
nsAutoCString
langGroup
;
aLangGroupAtom
-
>
ToUTF8String
(
langGroup
)
;
mDefaultVariableFont
.
size
=
Length
:
:
FromPixels
(
16
.
0f
)
;
mDefaultMonospaceFont
.
size
=
Length
:
:
FromPixels
(
13
.
0f
)
;
nsAutoCString
pref
;
MAKE_FONT_PREF_KEY
(
pref
"
font
.
minimum
-
size
.
"
langGroup
)
;
int32_t
size
=
Preferences
:
:
GetInt
(
pref
.
get
(
)
)
;
mMinimumFontSize
=
Length
:
:
FromPixels
(
size
)
;
nsFont
*
fontTypes
[
]
=
{
&
mDefaultVariableFont
&
mDefaultSerifFont
&
mDefaultSansSerifFont
&
mDefaultMonospaceFont
&
mDefaultCursiveFont
&
mDefaultFantasyFont
&
mDefaultSystemUiFont
}
;
static_assert
(
MOZ_ARRAY_LENGTH
(
fontTypes
)
=
=
size_t
(
DefaultFont
:
:
COUNT
)
"
FontTypes
array
count
is
not
correct
"
)
;
nsAutoCString
generic_dot_langGroup
;
for
(
auto
type
:
MakeEnumeratedRange
(
DefaultFont
:
:
COUNT
)
)
{
generic_dot_langGroup
.
Assign
(
kGenericFont
[
size_t
(
type
)
]
)
;
generic_dot_langGroup
.
Append
(
langGroup
)
;
nsFont
*
font
=
fontTypes
[
size_t
(
type
)
]
;
if
(
type
=
=
DefaultFont
:
:
Variable
)
{
MAKE_FONT_PREF_KEY
(
pref
"
font
.
name
.
variable
.
"
langGroup
)
;
nsAutoCString
value
;
Preferences
:
:
GetCString
(
pref
.
get
(
)
value
)
;
if
(
value
.
IsEmpty
(
)
)
{
MAKE_FONT_PREF_KEY
(
pref
"
font
.
default
.
"
langGroup
)
;
Preferences
:
:
GetCString
(
pref
.
get
(
)
value
)
;
}
if
(
!
value
.
IsEmpty
(
)
)
{
auto
defaultVariableName
=
StyleSingleFontFamily
:
:
Parse
(
value
)
;
auto
defaultType
=
defaultVariableName
.
IsGeneric
(
)
?
defaultVariableName
.
AsGeneric
(
)
:
StyleGenericFontFamily
:
:
None
;
NS_ASSERTION
(
defaultType
=
=
StyleGenericFontFamily
:
:
Serif
|
|
defaultType
=
=
StyleGenericFontFamily
:
:
SansSerif
"
default
type
must
be
serif
or
sans
-
serif
"
)
;
mDefaultVariableFont
.
family
.
families
.
fallback
=
defaultType
;
}
}
else
{
if
(
type
!
=
DefaultFont
:
:
Monospace
)
{
font
-
>
size
=
mDefaultVariableFont
.
size
;
}
}
MAKE_FONT_PREF_KEY
(
pref
"
font
.
size
"
generic_dot_langGroup
)
;
size
=
Preferences
:
:
GetInt
(
pref
.
get
(
)
)
;
if
(
size
>
0
)
{
font
-
>
size
=
Length
:
:
FromPixels
(
size
)
;
}
MAKE_FONT_PREF_KEY
(
pref
"
font
.
size
-
adjust
"
generic_dot_langGroup
)
;
nsAutoCString
cvalue
;
Preferences
:
:
GetCString
(
pref
.
get
(
)
cvalue
)
;
if
(
!
cvalue
.
IsEmpty
(
)
)
{
font
-
>
sizeAdjust
=
StyleFontSizeAdjust
:
:
ExHeight
(
(
float
)
atof
(
cvalue
.
get
(
)
)
)
;
}
#
ifdef
DEBUG_rbs
printf
(
"
%
s
Family
-
list
:
%
s
size
:
%
d
sizeAdjust
:
%
.
2f
\
n
"
generic_dot_langGroup
.
get
(
)
NS_ConvertUTF16toUTF8
(
font
-
>
name
)
.
get
(
)
font
-
>
size
font
-
>
sizeAdjust
)
;
#
endif
}
}
nsStaticAtom
*
StaticPresData
:
:
GetLangGroup
(
nsAtom
*
aLanguage
bool
*
aNeedsToCache
)
const
{
nsStaticAtom
*
langGroupAtom
=
mLangService
-
>
GetLanguageGroup
(
aLanguage
aNeedsToCache
)
;
return
langGroupAtom
?
langGroupAtom
:
nsGkAtoms
:
:
x_western
;
}
nsStaticAtom
*
StaticPresData
:
:
GetUncachedLangGroup
(
nsAtom
*
aLanguage
)
const
{
nsStaticAtom
*
langGroupAtom
=
mLangService
-
>
GetUncachedLanguageGroup
(
aLanguage
)
;
return
langGroupAtom
?
langGroupAtom
:
nsGkAtoms
:
:
x_western
;
}
const
LangGroupFontPrefs
*
StaticPresData
:
:
GetFontPrefsForLang
(
nsAtom
*
aLanguage
bool
*
aNeedsToCache
)
{
MOZ_ASSERT
(
aLanguage
)
;
MOZ_ASSERT
(
mLangService
)
;
nsStaticAtom
*
langGroupAtom
=
GetLangGroup
(
aLanguage
aNeedsToCache
)
;
if
(
aNeedsToCache
&
&
*
aNeedsToCache
)
{
return
nullptr
;
}
if
(
!
aNeedsToCache
)
{
AssertIsMainThreadOrServoFontMetricsLocked
(
)
;
}
LangGroupFontPrefs
*
prefs
=
&
mLangGroupFontPrefs
;
if
(
prefs
-
>
mLangGroup
)
{
DebugOnly
<
uint32_t
>
count
=
0
;
for
(
;
;
)
{
if
(
prefs
-
>
mLangGroup
=
=
langGroupAtom
)
{
return
prefs
;
}
if
(
!
prefs
-
>
mNext
)
{
break
;
}
prefs
=
prefs
-
>
mNext
.
get
(
)
;
}
if
(
aNeedsToCache
)
{
*
aNeedsToCache
=
true
;
return
nullptr
;
}
prefs
-
>
mNext
=
MakeUnique
<
LangGroupFontPrefs
>
(
)
;
prefs
=
prefs
-
>
mNext
.
get
(
)
;
}
if
(
aNeedsToCache
)
{
*
aNeedsToCache
=
true
;
return
nullptr
;
}
AssertIsMainThreadOrServoFontMetricsLocked
(
)
;
prefs
-
>
Initialize
(
langGroupAtom
)
;
return
prefs
;
}
}
