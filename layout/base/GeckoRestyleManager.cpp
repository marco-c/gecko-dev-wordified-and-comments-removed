#
include
"
mozilla
/
GeckoRestyleManager
.
h
"
#
include
<
algorithm
>
#
include
"
gfxContext
.
h
"
#
include
"
mozilla
/
EffectSet
.
h
"
#
include
"
mozilla
/
GeckoStyleContext
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
ViewportFrame
.
h
"
#
include
"
mozilla
/
css
/
StyleRule
.
h
"
#
include
"
mozilla
/
dom
/
MutationEventBinding
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
AnimationCommon
.
h
"
#
include
"
FrameLayerBuilder
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsStyleChangeList
.
h
"
#
include
"
nsRuleProcessorData
.
h
"
#
include
"
nsStyleContextInlines
.
h
"
#
include
"
nsStyleSet
.
h
"
#
include
"
nsStyleUtil
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
SVGObserverUtils
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsCSSRendering
.
h
"
#
include
"
nsAnimationManager
.
h
"
#
include
"
nsTransitionManager
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsSVGIntegrationUtils
.
h
"
#
include
"
nsCSSAnonBoxes
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsPlaceholderFrame
.
h
"
#
include
"
nsBlockFrame
.
h
"
#
include
"
SVGTextFrame
.
h
"
#
include
"
StickyScrollContainer
.
h
"
#
include
"
nsIRootBox
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
ActiveLayerTracker
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
RestyleTrackerInlines
.
h
"
#
include
"
nsSMILAnimationController
.
h
"
#
include
"
nsCSSRuleProcessor
.
h
"
#
include
"
ChildIterator
.
h
"
#
ifdef
ACCESSIBILITY
#
include
"
nsAccessibilityService
.
h
"
#
endif
namespace
mozilla
{
using
namespace
layers
;
using
namespace
dom
;
#
define
LOG_RESTYLE_CONTINUE
(
reason_
.
.
.
)
\
LOG_RESTYLE
(
"
continuing
restyle
since
"
reason_
#
#
__VA_ARGS__
)
#
ifdef
RESTYLE_LOGGING
static
nsCString
FrameTagToString
(
const
nsIFrame
*
aFrame
)
{
nsCString
result
;
aFrame
-
>
ListTag
(
result
)
;
return
result
;
}
static
nsCString
ElementTagToString
(
dom
:
:
Element
*
aElement
)
{
nsCString
result
;
nsDependentAtomString
buf
(
aElement
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
;
result
.
AppendPrintf
(
"
(
%
s
%
p
)
"
NS_ConvertUTF16toUTF8
(
buf
)
.
get
(
)
aElement
)
;
return
result
;
}
#
endif
GeckoRestyleManager
:
:
GeckoRestyleManager
(
nsPresContext
*
aPresContext
)
:
RestyleManager
(
StyleBackendType
:
:
Gecko
aPresContext
)
mDoRebuildAllStyleData
(
false
)
mInRebuildAllStyleData
(
false
)
mSkipAnimationRules
(
false
)
mHavePendingNonAnimationRestyles
(
false
)
mRebuildAllExtraHint
(
nsChangeHint
(
0
)
)
mRebuildAllRestyleHint
(
nsRestyleHint
(
0
)
)
mReframingStyleContexts
(
nullptr
)
mPendingRestyles
(
ELEMENT_HAS_PENDING_RESTYLE
|
ELEMENT_IS_POTENTIAL_RESTYLE_ROOT
|
ELEMENT_IS_CONDITIONAL_RESTYLE_ANCESTOR
)
mIsProcessingRestyles
(
false
)
#
ifdef
RESTYLE_LOGGING
mLoggingDepth
(
0
)
#
endif
{
mPendingRestyles
.
Init
(
this
)
;
}
static
nsIFrame
*
GetNearestAncestorFrame
(
nsIContent
*
aContent
)
{
nsIFrame
*
ancestorFrame
=
nullptr
;
for
(
nsIContent
*
ancestor
=
aContent
-
>
GetParent
(
)
;
ancestor
&
&
!
ancestorFrame
;
ancestor
=
ancestor
-
>
GetParent
(
)
)
{
ancestorFrame
=
ancestor
-
>
GetPrimaryFrame
(
)
;
}
return
ancestorFrame
;
}
static
nsIFrame
*
GetNextBlockInInlineSibling
(
nsIFrame
*
aFrame
)
{
NS_ASSERTION
(
!
aFrame
-
>
GetPrevContinuation
(
)
"
must
start
with
the
first
continuation
"
)
;
if
(
!
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_PART_OF_IBSPLIT
)
)
{
return
nullptr
;
}
return
aFrame
-
>
GetProperty
(
nsIFrame
:
:
IBSplitSibling
(
)
)
;
}
static
nsIFrame
*
GetNextContinuationWithSameStyle
(
nsIFrame
*
aFrame
GeckoStyleContext
*
aOldStyleContext
bool
*
aHaveMoreContinuations
=
nullptr
)
{
nsIFrame
*
nextContinuation
=
aFrame
-
>
GetNextContinuation
(
)
;
if
(
!
nextContinuation
&
&
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_PART_OF_IBSPLIT
)
)
{
nextContinuation
=
aFrame
-
>
FirstContinuation
(
)
-
>
GetProperty
(
nsIFrame
:
:
IBSplitSibling
(
)
)
;
if
(
nextContinuation
)
{
nextContinuation
=
nextContinuation
-
>
GetProperty
(
nsIFrame
:
:
IBSplitSibling
(
)
)
;
}
}
if
(
!
nextContinuation
)
{
return
nullptr
;
}
NS_ASSERTION
(
nextContinuation
-
>
GetContent
(
)
=
=
aFrame
-
>
GetContent
(
)
"
unexpected
content
mismatch
"
)
;
GeckoStyleContext
*
nextStyle
=
nextContinuation
-
>
StyleContext
(
)
-
>
AsGecko
(
)
;
if
(
nextStyle
!
=
aOldStyleContext
)
{
NS_ASSERTION
(
aOldStyleContext
-
>
GetPseudo
(
)
!
=
nextStyle
-
>
GetPseudo
(
)
|
|
aOldStyleContext
-
>
GetParent
(
)
!
=
nextStyle
-
>
GetParent
(
)
"
continuations
should
have
the
same
style
context
"
)
;
nextContinuation
=
nullptr
;
if
(
aHaveMoreContinuations
)
{
*
aHaveMoreContinuations
=
true
;
}
}
return
nextContinuation
;
}
void
GeckoRestyleManager
:
:
RestyleElement
(
Element
*
aElement
nsIFrame
*
aPrimaryFrame
nsChangeHint
aMinHint
RestyleTracker
&
aRestyleTracker
nsRestyleHint
aRestyleHint
const
RestyleHintData
&
aRestyleHintData
)
{
MOZ_ASSERT
(
mReframingStyleContexts
"
should
have
rsc
"
)
;
NS_ASSERTION
(
aPrimaryFrame
=
=
aElement
-
>
GetPrimaryFrame
(
)
"
frame
/
content
mismatch
"
)
;
if
(
aPrimaryFrame
&
&
aPrimaryFrame
-
>
GetContent
(
)
!
=
aElement
)
{
aPrimaryFrame
=
nullptr
;
}
NS_ASSERTION
(
!
aPrimaryFrame
|
|
aPrimaryFrame
-
>
GetContent
(
)
=
=
aElement
"
frame
/
content
mismatch
"
)
;
if
(
PresContext
(
)
-
>
UsesRootEMUnits
(
)
&
&
aPrimaryFrame
&
&
!
mInRebuildAllStyleData
)
{
GeckoStyleContext
*
oldContext
=
aPrimaryFrame
-
>
StyleContext
(
)
-
>
AsGecko
(
)
;
if
(
!
oldContext
-
>
GetParent
(
)
)
{
RefPtr
<
GeckoStyleContext
>
newContext
=
StyleSet
(
)
-
>
ResolveStyleFor
(
aElement
nullptr
)
;
if
(
oldContext
-
>
StyleFont
(
)
-
>
mFont
.
size
!
=
newContext
-
>
StyleFont
(
)
-
>
mFont
.
size
)
{
mRebuildAllRestyleHint
|
=
aRestyleHint
;
if
(
aRestyleHint
&
eRestyle_SomeDescendants
)
{
mRebuildAllRestyleHint
|
=
eRestyle_Subtree
;
}
mRebuildAllExtraHint
|
=
aMinHint
;
StartRebuildAllStyleData
(
aRestyleTracker
)
;
return
;
}
}
}
if
(
aMinHint
&
nsChangeHint_ReconstructFrame
)
{
FrameConstructor
(
)
-
>
RecreateFramesForContent
(
aElement
nsCSSFrameConstructor
:
:
InsertionKind
:
:
Sync
)
;
}
else
if
(
aPrimaryFrame
)
{
ComputeAndProcessStyleChange
(
aPrimaryFrame
aMinHint
aRestyleTracker
aRestyleHint
aRestyleHintData
)
;
}
else
if
(
aRestyleHint
&
~
eRestyle_LaterSiblings
)
{
nsStyleContext
*
newContext
=
FrameConstructor
(
)
-
>
MaybeRecreateFramesForElement
(
aElement
)
;
if
(
newContext
&
&
newContext
-
>
StyleDisplay
(
)
-
>
mDisplay
=
=
StyleDisplay
:
:
Contents
)
{
ComputeAndProcessStyleChange
(
newContext
-
>
AsGecko
(
)
aElement
aMinHint
aRestyleTracker
aRestyleHint
aRestyleHintData
)
;
}
}
}
GeckoRestyleManager
:
:
ReframingStyleContexts
:
:
ReframingStyleContexts
(
GeckoRestyleManager
*
aRestyleManager
)
:
mRestyleManager
(
aRestyleManager
)
mRestorePointer
(
mRestyleManager
-
>
mReframingStyleContexts
)
{
MOZ_ASSERT
(
!
mRestyleManager
-
>
mReframingStyleContexts
"
shouldn
'
t
construct
recursively
"
)
;
mRestyleManager
-
>
mReframingStyleContexts
=
this
;
}
GeckoRestyleManager
:
:
ReframingStyleContexts
:
:
~
ReframingStyleContexts
(
)
{
mRestyleManager
-
>
PresContext
(
)
-
>
FrameConstructor
(
)
-
>
CreateNeededFrames
(
)
;
}
static
inline
dom
:
:
Element
*
ElementForStyleContext
(
nsIContent
*
aParentContent
nsIFrame
*
aFrame
CSSPseudoElementType
aPseudoType
)
;
void
GeckoRestyleManager
:
:
ContentStateChanged
(
nsIContent
*
aContent
EventStates
aStateMask
)
{
MOZ_ASSERT
(
!
mInStyleRefresh
)
;
if
(
!
aContent
-
>
IsElement
(
)
)
{
return
;
}
Element
*
aElement
=
aContent
-
>
AsElement
(
)
;
nsChangeHint
changeHint
;
ContentStateChangedInternal
(
aElement
aStateMask
&
changeHint
)
;
nsIFrame
*
primaryFrame
=
aElement
-
>
GetPrimaryFrame
(
)
;
CSSPseudoElementType
pseudoType
=
CSSPseudoElementType
:
:
NotPseudo
;
if
(
primaryFrame
)
{
pseudoType
=
primaryFrame
-
>
StyleContext
(
)
-
>
GetPseudoType
(
)
;
}
nsStyleSet
*
styleSet
=
PresContext
(
)
-
>
StyleSet
(
)
-
>
AsGecko
(
)
;
MOZ_ASSERT
(
styleSet
)
;
nsRestyleHint
restyleHint
;
if
(
pseudoType
>
=
CSSPseudoElementType
:
:
Count
)
{
restyleHint
=
styleSet
-
>
HasStateDependentStyle
(
aElement
aStateMask
)
;
}
else
if
(
nsCSSPseudoElements
:
:
PseudoElementSupportsUserActionState
(
pseudoType
)
)
{
Element
*
ancestor
=
ElementForStyleContext
(
nullptr
primaryFrame
pseudoType
)
;
restyleHint
=
styleSet
-
>
HasStateDependentStyle
(
ancestor
pseudoType
aElement
aStateMask
)
;
}
else
{
restyleHint
=
nsRestyleHint
(
0
)
;
}
if
(
aStateMask
.
HasState
(
NS_EVENT_STATE_HOVER
)
&
&
restyleHint
!
=
0
)
{
IncrementHoverGeneration
(
)
;
}
PostRestyleEvent
(
aElement
restyleHint
changeHint
)
;
}
void
GeckoRestyleManager
:
:
AttributeWillChange
(
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
const
nsAttrValue
*
aNewValue
)
{
MOZ_ASSERT
(
!
mInStyleRefresh
)
;
RestyleHintData
rsdata
;
nsRestyleHint
rshint
=
StyleSet
(
)
-
>
HasAttributeDependentStyle
(
aElement
aNameSpaceID
aAttribute
aModType
false
aNewValue
rsdata
)
;
PostRestyleEvent
(
aElement
rshint
nsChangeHint
(
0
)
&
rsdata
)
;
}
void
GeckoRestyleManager
:
:
AttributeChanged
(
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
const
nsAttrValue
*
aOldValue
)
{
MOZ_ASSERT
(
!
mInStyleRefresh
)
;
nsCOMPtr
<
nsIPresShell
>
shell
=
PresContext
(
)
-
>
GetPresShell
(
)
;
mozilla
:
:
Unused
<
<
shell
;
nsIFrame
*
primaryFrame
=
aElement
-
>
GetPrimaryFrame
(
)
;
#
if
0
NS_FRAME_LOG
(
NS_FRAME_TRACE_CALLS
(
"
RestyleManager
:
:
AttributeChanged
:
content
=
%
p
[
%
s
]
frame
=
%
p
"
aContent
ContentTag
(
aElement
0
)
frame
)
)
;
#
endif
nsChangeHint
hint
=
aElement
-
>
GetAttributeChangeHint
(
aAttribute
aModType
)
;
bool
reframe
=
(
hint
&
nsChangeHint_ReconstructFrame
)
!
=
0
;
#
ifdef
MOZ_XUL
if
(
!
primaryFrame
&
&
!
reframe
)
{
int32_t
namespaceID
;
nsAtom
*
tag
=
PresContext
(
)
-
>
Document
(
)
-
>
BindingManager
(
)
-
>
ResolveTag
(
aElement
&
namespaceID
)
;
if
(
namespaceID
=
=
kNameSpaceID_XUL
&
&
(
tag
=
=
nsGkAtoms
:
:
listitem
|
|
tag
=
=
nsGkAtoms
:
:
listcell
)
)
return
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
tooltiptext
|
|
aAttribute
=
=
nsGkAtoms
:
:
tooltip
)
{
nsIRootBox
*
rootBox
=
nsIRootBox
:
:
GetRootBox
(
PresContext
(
)
-
>
GetPresShell
(
)
)
;
if
(
rootBox
)
{
if
(
aModType
=
=
MutationEventBinding
:
:
REMOVAL
)
rootBox
-
>
RemoveTooltipSupport
(
aElement
)
;
if
(
aModType
=
=
MutationEventBinding
:
:
ADDITION
)
rootBox
-
>
AddTooltipSupport
(
aElement
)
;
}
}
#
endif
if
(
primaryFrame
)
{
const
nsStyleDisplay
*
disp
=
primaryFrame
-
>
StyleDisplay
(
)
;
if
(
disp
-
>
mAppearance
)
{
nsITheme
*
theme
=
PresContext
(
)
-
>
GetTheme
(
)
;
if
(
theme
&
&
theme
-
>
ThemeSupportsWidget
(
PresContext
(
)
primaryFrame
disp
-
>
mAppearance
)
)
{
bool
repaint
=
false
;
theme
-
>
WidgetStateChanged
(
primaryFrame
disp
-
>
mAppearance
aAttribute
&
repaint
aOldValue
)
;
if
(
repaint
)
hint
|
=
nsChangeHint_RepaintFrame
;
}
}
primaryFrame
-
>
AttributeChanged
(
aNameSpaceID
aAttribute
aModType
)
;
}
RestyleHintData
rsdata
;
nsRestyleHint
rshint
=
StyleSet
(
)
-
>
HasAttributeDependentStyle
(
aElement
aNameSpaceID
aAttribute
aModType
true
aOldValue
rsdata
)
;
PostRestyleEvent
(
aElement
rshint
hint
&
rsdata
)
;
}
void
GeckoRestyleManager
:
:
RebuildAllStyleData
(
nsChangeHint
aExtraHint
nsRestyleHint
aRestyleHint
)
{
NS_ASSERTION
(
!
(
aExtraHint
&
nsChangeHint_ReconstructFrame
)
"
Should
not
reconstruct
the
root
of
the
frame
tree
.
"
"
Use
ReconstructDocElementHierarchy
instead
.
"
)
;
MOZ_ASSERT
(
!
(
aRestyleHint
&
~
(
eRestyle_Subtree
|
eRestyle_ForceDescendants
)
)
"
the
only
bits
allowed
in
aRestyleHint
are
eRestyle_Subtree
and
"
"
eRestyle_ForceDescendants
"
)
;
mRebuildAllExtraHint
|
=
aExtraHint
;
mRebuildAllRestyleHint
|
=
aRestyleHint
;
nsCOMPtr
<
nsIPresShell
>
presShell
=
PresContext
(
)
-
>
GetPresShell
(
)
;
if
(
!
presShell
|
|
!
presShell
-
>
GetRootFrame
(
)
)
{
mDoRebuildAllStyleData
=
false
;
return
;
}
RefPtr
<
nsViewManager
>
vm
=
presShell
-
>
GetViewManager
(
)
;
mozilla
:
:
Unused
<
<
vm
;
presShell
-
>
GetDocument
(
)
-
>
FlushPendingNotifications
(
FlushType
:
:
ContentAndNotify
)
;
nsAutoScriptBlocker
scriptBlocker
;
mDoRebuildAllStyleData
=
true
;
ProcessPendingRestyles
(
)
;
}
void
GeckoRestyleManager
:
:
StartRebuildAllStyleData
(
RestyleTracker
&
aRestyleTracker
)
{
MOZ_ASSERT
(
mIsProcessingRestyles
)
;
nsIFrame
*
rootFrame
=
PresContext
(
)
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
;
if
(
!
rootFrame
)
{
return
;
}
mInRebuildAllStyleData
=
true
;
nsresult
rv
=
StyleSet
(
)
-
>
BeginReconstruct
(
)
;
if
(
NS_FAILED
(
rv
)
)
{
MOZ_CRASH
(
"
unable
to
rebuild
style
data
"
)
;
}
nsRestyleHint
restyleHint
=
mRebuildAllRestyleHint
;
nsChangeHint
changeHint
=
mRebuildAllExtraHint
;
mRebuildAllExtraHint
=
nsChangeHint
(
0
)
;
mRebuildAllRestyleHint
=
nsRestyleHint
(
0
)
;
restyleHint
|
=
eRestyle_ForceDescendants
;
if
(
!
(
restyleHint
&
eRestyle_Subtree
)
&
&
(
restyleHint
&
~
(
eRestyle_Force
|
eRestyle_ForceDescendants
)
)
)
{
Element
*
root
=
PresContext
(
)
-
>
Document
(
)
-
>
GetRootElement
(
)
;
if
(
root
)
{
aRestyleTracker
.
AddPendingRestyle
(
root
restyleHint
nsChangeHint
(
0
)
)
;
}
restyleHint
=
nsRestyleHint
(
0
)
;
}
ComputeAndProcessStyleChange
(
rootFrame
changeHint
aRestyleTracker
restyleHint
RestyleHintData
(
)
)
;
}
void
GeckoRestyleManager
:
:
FinishRebuildAllStyleData
(
)
{
MOZ_ASSERT
(
mInRebuildAllStyleData
"
bad
caller
"
)
;
StyleSet
(
)
-
>
EndReconstruct
(
)
;
mInRebuildAllStyleData
=
false
;
}
void
GeckoRestyleManager
:
:
ProcessPendingRestyles
(
)
{
NS_PRECONDITION
(
PresContext
(
)
-
>
Document
(
)
"
No
document
?
Pshaw
!
"
)
;
NS_PRECONDITION
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
Missing
a
script
blocker
!
"
)
;
MOZ_ASSERT
(
!
PresContext
(
)
-
>
HasPendingMediaQueryUpdates
(
)
|
|
mDoRebuildAllStyleData
"
Someone
forgot
to
update
media
queries
?
"
)
;
PresContext
(
)
-
>
FrameConstructor
(
)
-
>
CreateNeededFrames
(
)
;
MOZ_ASSERT
(
!
mIsProcessingRestyles
"
Nesting
calls
to
ProcessPendingRestyles
?
"
)
;
mIsProcessingRestyles
=
true
;
bool
haveNonAnimation
=
mHavePendingNonAnimationRestyles
|
|
mDoRebuildAllStyleData
;
if
(
haveNonAnimation
)
{
+
+
mAnimationGeneration
;
UpdateOnlyAnimationStyles
(
)
;
}
else
{
PresContext
(
)
-
>
TransitionManager
(
)
-
>
SetInAnimationOnlyStyleUpdate
(
true
)
;
}
ProcessRestyles
(
mPendingRestyles
)
;
if
(
!
haveNonAnimation
)
{
PresContext
(
)
-
>
TransitionManager
(
)
-
>
SetInAnimationOnlyStyleUpdate
(
false
)
;
}
mIsProcessingRestyles
=
false
;
NS_ASSERTION
(
haveNonAnimation
|
|
!
mHavePendingNonAnimationRestyles
"
should
not
have
added
restyles
"
)
;
mHavePendingNonAnimationRestyles
=
false
;
if
(
mDoRebuildAllStyleData
)
{
ProcessPendingRestyles
(
)
;
NS_ASSERTION
(
!
mDoRebuildAllStyleData
"
repeatedly
setting
mDoRebuildAllStyleData
?
"
)
;
}
MOZ_ASSERT
(
!
mInRebuildAllStyleData
"
should
have
called
FinishRebuildAllStyleData
"
)
;
}
void
GeckoRestyleManager
:
:
BeginProcessingRestyles
(
RestyleTracker
&
aRestyleTracker
)
{
mInStyleRefresh
=
true
;
if
(
ShouldStartRebuildAllFor
(
aRestyleTracker
)
)
{
mDoRebuildAllStyleData
=
false
;
StartRebuildAllStyleData
(
aRestyleTracker
)
;
}
}
void
GeckoRestyleManager
:
:
EndProcessingRestyles
(
)
{
FlushOverflowChangedTracker
(
)
;
MOZ_ASSERT
(
mAnimationsWithDestroyedFrame
)
;
mAnimationsWithDestroyedFrame
-
>
StopAnimationsForElementsWithoutFrames
(
)
;
mInStyleRefresh
=
false
;
if
(
mInRebuildAllStyleData
)
{
FinishRebuildAllStyleData
(
)
;
}
#
ifdef
DEBUG
PresContext
(
)
-
>
PresShell
(
)
-
>
VerifyStyleTree
(
)
;
#
endif
}
void
GeckoRestyleManager
:
:
UpdateOnlyAnimationStyles
(
)
{
bool
doCSS
=
PresContext
(
)
-
>
EffectCompositor
(
)
-
>
HasPendingStyleUpdates
(
)
;
nsIDocument
*
document
=
PresContext
(
)
-
>
Document
(
)
;
nsSMILAnimationController
*
animationController
=
document
-
>
HasAnimationController
(
)
?
document
-
>
GetAnimationController
(
)
:
nullptr
;
bool
doSMIL
=
animationController
&
&
animationController
-
>
MightHavePendingStyleUpdates
(
)
;
if
(
!
doCSS
&
&
!
doSMIL
)
{
return
;
}
nsTransitionManager
*
transitionManager
=
PresContext
(
)
-
>
TransitionManager
(
)
;
transitionManager
-
>
SetInAnimationOnlyStyleUpdate
(
true
)
;
RestyleTracker
tracker
(
ELEMENT_HAS_PENDING_ANIMATION_ONLY_RESTYLE
|
ELEMENT_IS_POTENTIAL_ANIMATION_ONLY_RESTYLE_ROOT
)
;
tracker
.
Init
(
this
)
;
if
(
doCSS
)
{
PresContext
(
)
-
>
EffectCompositor
(
)
-
>
AddStyleUpdatesTo
(
tracker
)
;
}
if
(
doSMIL
)
{
animationController
-
>
AddStyleUpdatesTo
(
tracker
)
;
}
ProcessRestyles
(
tracker
)
;
transitionManager
-
>
SetInAnimationOnlyStyleUpdate
(
false
)
;
}
void
GeckoRestyleManager
:
:
PostRestyleEventInternal
(
)
{
nsIPresShell
*
presShell
=
PresContext
(
)
-
>
PresShell
(
)
;
if
(
!
mInStyleRefresh
)
{
presShell
-
>
ObserveStyleFlushes
(
)
;
}
presShell
-
>
SetNeedStyleFlush
(
)
;
}
void
GeckoRestyleManager
:
:
PostRestyleEvent
(
Element
*
aElement
nsRestyleHint
aRestyleHint
nsChangeHint
aMinChangeHint
const
RestyleHintData
*
aRestyleHintData
)
{
if
(
MOZ_UNLIKELY
(
IsDisconnected
(
)
)
|
|
MOZ_UNLIKELY
(
PresContext
(
)
-
>
PresShell
(
)
-
>
IsDestroying
(
)
)
)
{
return
;
}
if
(
aRestyleHint
=
=
0
&
&
!
aMinChangeHint
)
{
return
;
}
mPendingRestyles
.
AddPendingRestyle
(
aElement
aRestyleHint
aMinChangeHint
aRestyleHintData
)
;
if
(
aRestyleHint
&
~
eRestyle_AllHintsWithAnimations
)
{
mHavePendingNonAnimationRestyles
=
true
;
}
PostRestyleEventInternal
(
)
;
}
void
GeckoRestyleManager
:
:
PostRebuildAllStyleDataEvent
(
nsChangeHint
aExtraHint
nsRestyleHint
aRestyleHint
)
{
NS_ASSERTION
(
!
(
aExtraHint
&
nsChangeHint_ReconstructFrame
)
"
Should
not
reconstruct
the
root
of
the
frame
tree
.
"
"
Use
ReconstructDocElementHierarchy
instead
.
"
)
;
MOZ_ASSERT
(
!
(
aRestyleHint
&
eRestyle_SomeDescendants
)
"
PostRebuildAllStyleDataEvent
does
not
handle
"
"
eRestyle_SomeDescendants
"
)
;
mDoRebuildAllStyleData
=
true
;
mRebuildAllExtraHint
|
=
aExtraHint
;
mRebuildAllRestyleHint
|
=
aRestyleHint
;
PostRestyleEventInternal
(
)
;
}
bool
GeckoRestyleManager
:
:
TryInitiatingTransition
(
nsPresContext
*
aPresContext
nsIContent
*
aContent
GeckoStyleContext
*
aOldStyleContext
RefPtr
<
GeckoStyleContext
>
*
aNewStyleContext
)
{
if
(
!
aContent
|
|
!
aContent
-
>
IsElement
(
)
)
{
return
false
;
}
RefPtr
<
GeckoStyleContext
>
sc
=
*
aNewStyleContext
;
aPresContext
-
>
TransitionManager
(
)
-
>
StyleContextChanged
(
aContent
-
>
AsElement
(
)
aOldStyleContext
aNewStyleContext
)
;
return
*
aNewStyleContext
!
=
sc
;
}
static
dom
:
:
Element
*
ElementForStyleContext
(
nsIContent
*
aParentContent
nsIFrame
*
aFrame
CSSPseudoElementType
aPseudoType
)
{
NS_PRECONDITION
(
aPseudoType
=
=
CSSPseudoElementType
:
:
NotPseudo
|
|
aPseudoType
=
=
CSSPseudoElementType
:
:
InheritingAnonBox
|
|
aPseudoType
=
=
CSSPseudoElementType
:
:
NonInheritingAnonBox
|
|
aPseudoType
<
CSSPseudoElementType
:
:
Count
"
Unexpected
pseudo
"
)
;
if
(
aPseudoType
=
=
CSSPseudoElementType
:
:
NotPseudo
)
{
return
aFrame
-
>
GetContent
(
)
-
>
AsElement
(
)
;
}
if
(
aPseudoType
=
=
CSSPseudoElementType
:
:
InheritingAnonBox
|
|
aPseudoType
=
=
CSSPseudoElementType
:
:
NonInheritingAnonBox
)
{
return
nullptr
;
}
if
(
aPseudoType
=
=
CSSPseudoElementType
:
:
firstLetter
)
{
NS_ASSERTION
(
aFrame
-
>
IsLetterFrame
(
)
"
firstLetter
pseudoTag
without
a
nsFirstLetterFrame
"
)
;
nsBlockFrame
*
block
=
nsBlockFrame
:
:
GetNearestAncestorBlock
(
aFrame
)
;
return
block
-
>
GetContent
(
)
-
>
AsElement
(
)
;
}
if
(
aPseudoType
=
=
CSSPseudoElementType
:
:
mozColorSwatch
)
{
MOZ_ASSERT
(
aFrame
-
>
GetParent
(
)
&
&
aFrame
-
>
GetParent
(
)
-
>
GetParent
(
)
"
Color
swatch
frame
should
have
a
parent
&
grandparent
"
)
;
nsIFrame
*
grandparentFrame
=
aFrame
-
>
GetParent
(
)
-
>
GetParent
(
)
;
MOZ_ASSERT
(
grandparentFrame
-
>
IsColorControlFrame
(
)
"
Color
swatch
'
s
grandparent
should
be
nsColorControlFrame
"
)
;
return
grandparentFrame
-
>
GetContent
(
)
-
>
AsElement
(
)
;
}
if
(
aPseudoType
=
=
CSSPseudoElementType
:
:
mozNumberText
|
|
aPseudoType
=
=
CSSPseudoElementType
:
:
mozNumberWrapper
|
|
aPseudoType
=
=
CSSPseudoElementType
:
:
mozNumberSpinBox
|
|
aPseudoType
=
=
CSSPseudoElementType
:
:
mozNumberSpinUp
|
|
aPseudoType
=
=
CSSPseudoElementType
:
:
mozNumberSpinDown
)
{
nsIFrame
*
f
=
aFrame
-
>
GetParent
(
)
;
MOZ_ASSERT
(
f
)
;
while
(
!
f
-
>
IsNumberControlFrame
(
)
)
{
f
=
f
-
>
GetParent
(
)
;
MOZ_ASSERT
(
f
)
;
}
return
f
-
>
GetContent
(
)
-
>
AsElement
(
)
;
}
Element
*
frameElement
=
aFrame
-
>
GetContent
(
)
-
>
AsElement
(
)
;
if
(
frameElement
-
>
IsNativeAnonymous
(
)
)
{
Element
*
originatingElement
=
nsContentUtils
:
:
GetClosestNonNativeAnonymousAncestor
(
frameElement
)
;
if
(
originatingElement
)
{
return
originatingElement
;
}
}
if
(
aParentContent
)
{
return
aParentContent
-
>
AsElement
(
)
;
}
MOZ_ASSERT
(
aFrame
-
>
GetContent
(
)
-
>
GetParent
(
)
"
should
not
have
got
here
for
the
root
element
"
)
;
return
aFrame
-
>
GetContent
(
)
-
>
GetParent
(
)
-
>
AsElement
(
)
;
}
static
dom
:
:
Element
*
PseudoElementForStyleContext
(
nsIFrame
*
aFrame
CSSPseudoElementType
aPseudoType
)
{
if
(
aPseudoType
>
=
CSSPseudoElementType
:
:
Count
)
{
return
nullptr
;
}
if
(
nsCSSPseudoElements
:
:
PseudoElementSupportsStyleAttribute
(
aPseudoType
)
|
|
nsCSSPseudoElements
:
:
PseudoElementSupportsUserActionState
(
aPseudoType
)
)
{
return
aFrame
-
>
GetContent
(
)
-
>
AsElement
(
)
;
}
return
nullptr
;
}
static
nsIFrame
*
GetPrevContinuationWithPossiblySameStyle
(
nsIFrame
*
aFrame
)
{
nsIFrame
*
prevContinuation
=
aFrame
-
>
GetPrevContinuation
(
)
;
if
(
!
prevContinuation
&
&
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_PART_OF_IBSPLIT
)
)
{
prevContinuation
=
aFrame
-
>
GetProperty
(
nsIFrame
:
:
IBSplitPrevSibling
(
)
)
;
if
(
prevContinuation
)
{
prevContinuation
=
prevContinuation
-
>
GetProperty
(
nsIFrame
:
:
IBSplitPrevSibling
(
)
)
;
}
}
NS_ASSERTION
(
!
prevContinuation
|
|
prevContinuation
-
>
GetContent
(
)
=
=
aFrame
-
>
GetContent
(
)
"
unexpected
content
mismatch
"
)
;
return
prevContinuation
;
}
static
nsIFrame
*
GetPrevContinuationWithSameStyle
(
nsIFrame
*
aFrame
)
{
nsIFrame
*
prevContinuation
=
GetPrevContinuationWithPossiblySameStyle
(
aFrame
)
;
if
(
!
prevContinuation
)
{
return
nullptr
;
}
GeckoStyleContext
*
prevStyle
=
prevContinuation
-
>
StyleContext
(
)
-
>
AsGecko
(
)
;
GeckoStyleContext
*
selfStyle
=
aFrame
-
>
StyleContext
(
)
-
>
AsGecko
(
)
;
if
(
prevStyle
!
=
selfStyle
)
{
NS_ASSERTION
(
prevStyle
-
>
GetPseudo
(
)
!
=
selfStyle
-
>
GetPseudo
(
)
|
|
prevStyle
-
>
GetParent
(
)
!
=
selfStyle
-
>
GetParent
(
)
"
continuations
should
have
the
same
style
context
"
)
;
prevContinuation
=
nullptr
;
}
return
prevContinuation
;
}
nsresult
GeckoRestyleManager
:
:
ReparentStyleContext
(
nsIFrame
*
aFrame
)
{
LayoutFrameType
frameType
=
aFrame
-
>
Type
(
)
;
if
(
frameType
=
=
LayoutFrameType
:
:
Placeholder
)
{
nsIFrame
*
outOfFlow
=
nsPlaceholderFrame
:
:
GetRealFrameForPlaceholder
(
aFrame
)
;
NS_ASSERTION
(
outOfFlow
"
no
out
-
of
-
flow
frame
"
)
;
do
{
ReparentStyleContext
(
outOfFlow
)
;
}
while
(
(
outOfFlow
=
outOfFlow
-
>
GetNextContinuation
(
)
)
)
;
}
else
if
(
frameType
=
=
LayoutFrameType
:
:
Backdrop
)
{
return
NS_OK
;
}
GeckoStyleContext
*
oldContext
=
aFrame
-
>
StyleContext
(
)
-
>
AsGecko
(
)
;
RefPtr
<
GeckoStyleContext
>
newContext
;
nsIFrame
*
providerFrame
;
nsStyleContext
*
newParentContext
=
aFrame
-
>
GetParentStyleContext
(
&
providerFrame
)
;
bool
isChild
=
providerFrame
&
&
providerFrame
-
>
GetParent
(
)
=
=
aFrame
;
nsIFrame
*
providerChild
=
nullptr
;
if
(
isChild
)
{
ReparentStyleContext
(
providerFrame
)
;
newParentContext
=
providerFrame
-
>
StyleContext
(
)
;
providerChild
=
providerFrame
;
}
#
ifdef
DEBUG
{
nsIFrame
*
nextContinuation
=
aFrame
-
>
GetNextContinuation
(
)
;
if
(
nextContinuation
)
{
GeckoStyleContext
*
nextContinuationContext
=
nextContinuation
-
>
StyleContext
(
)
-
>
AsGecko
(
)
;
NS_ASSERTION
(
oldContext
=
=
nextContinuationContext
|
|
oldContext
-
>
GetPseudo
(
)
!
=
nextContinuationContext
-
>
GetPseudo
(
)
|
|
oldContext
-
>
GetParent
(
)
!
=
nextContinuationContext
-
>
GetParent
(
)
"
continuations
should
have
the
same
style
context
"
)
;
}
}
#
endif
if
(
!
newParentContext
&
&
!
oldContext
-
>
GetParent
(
)
)
{
MOZ_ASSERT
(
aFrame
-
>
StyleContext
(
)
-
>
IsNonInheritingAnonBox
(
)
"
Why
did
this
frame
not
end
up
with
a
parent
context
?
"
)
;
ReparentFrameDescendants
(
aFrame
providerChild
)
;
return
NS_OK
;
}
NS_ASSERTION
(
newParentContext
"
Reparenting
something
that
has
no
usable
"
"
parent
?
Shouldn
'
t
happen
!
"
)
;
nsIFrame
*
prevContinuation
=
GetPrevContinuationWithPossiblySameStyle
(
aFrame
)
;
GeckoStyleContext
*
prevContinuationContext
;
bool
copyFromContinuation
=
prevContinuation
&
&
(
prevContinuationContext
=
prevContinuation
-
>
StyleContext
(
)
-
>
AsGecko
(
)
)
-
>
GetPseudo
(
)
=
=
oldContext
-
>
GetPseudo
(
)
&
&
prevContinuationContext
-
>
GetParent
(
)
=
=
newParentContext
;
if
(
copyFromContinuation
)
{
newContext
=
prevContinuationContext
;
}
else
{
nsIFrame
*
parentFrame
=
aFrame
-
>
GetParent
(
)
;
Element
*
element
=
ElementForStyleContext
(
parentFrame
?
parentFrame
-
>
GetContent
(
)
:
nullptr
aFrame
oldContext
-
>
GetPseudoType
(
)
)
;
newContext
=
StyleSet
(
)
-
>
ReparentStyleContext
(
oldContext
newParentContext
-
>
AsGecko
(
)
element
)
;
}
if
(
newContext
)
{
if
(
newContext
!
=
oldContext
)
{
#
if
0
if
(
!
copyFromContinuation
)
{
TryInitiatingTransition
(
mPresContext
aFrame
-
>
GetContent
(
)
oldContext
&
newContext
)
;
}
#
endif
if
(
!
copyFromContinuation
)
{
newContext
-
>
AsGecko
(
)
-
>
EnsureSameStructsCached
(
oldContext
)
;
}
aFrame
-
>
SetStyleContext
(
newContext
)
;
ReparentFrameDescendants
(
aFrame
providerChild
)
;
if
(
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_PART_OF_IBSPLIT
)
&
&
!
aFrame
-
>
GetPrevContinuation
(
)
)
{
nsIFrame
*
sib
=
aFrame
-
>
GetProperty
(
nsIFrame
:
:
IBSplitSibling
(
)
)
;
if
(
sib
)
{
ReparentStyleContext
(
sib
)
;
}
}
int32_t
contextIndex
=
0
;
for
(
nsStyleContext
*
oldExtraContext
;
(
oldExtraContext
=
aFrame
-
>
GetAdditionalStyleContext
(
contextIndex
)
)
;
+
+
contextIndex
)
{
RefPtr
<
GeckoStyleContext
>
newExtraContext
;
newExtraContext
=
StyleSet
(
)
-
>
ReparentStyleContext
(
oldExtraContext
-
>
AsGecko
(
)
newContext
nullptr
)
;
if
(
newExtraContext
)
{
if
(
newExtraContext
!
=
oldExtraContext
)
{
newContext
-
>
AsGecko
(
)
-
>
EnsureSameStructsCached
(
oldContext
)
;
}
aFrame
-
>
SetAdditionalStyleContext
(
contextIndex
newExtraContext
)
;
}
}
#
ifdef
DEBUG
DebugVerifyStyleTree
(
aFrame
)
;
#
endif
}
}
return
NS_OK
;
}
void
GeckoRestyleManager
:
:
ReparentFrameDescendants
(
nsIFrame
*
aFrame
nsIFrame
*
aProviderChild
)
{
nsIFrame
:
:
ChildListIterator
lists
(
aFrame
)
;
for
(
;
!
lists
.
IsDone
(
)
;
lists
.
Next
(
)
)
{
for
(
nsIFrame
*
child
:
lists
.
CurrentList
(
)
)
{
if
(
!
(
child
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
&
&
child
!
=
aProviderChild
)
{
#
ifdef
DEBUG
if
(
child
-
>
IsPlaceholderFrame
(
)
)
{
nsIFrame
*
outOfFlowFrame
=
nsPlaceholderFrame
:
:
GetRealFrameForPlaceholder
(
child
)
;
NS_ASSERTION
(
outOfFlowFrame
"
no
out
-
of
-
flow
frame
"
)
;
NS_ASSERTION
(
outOfFlowFrame
!
=
aProviderChild
"
Out
of
flow
provider
?
"
)
;
}
#
endif
ReparentStyleContext
(
child
)
;
}
}
}
}
ElementRestyler
:
:
ElementRestyler
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
nsStyleChangeList
*
aChangeList
nsChangeHint
aHintsHandledByAncestors
RestyleTracker
&
aRestyleTracker
nsTArray
<
nsCSSSelector
*
>
&
aSelectorsForDescendants
TreeMatchContext
&
aTreeMatchContext
nsTArray
<
nsIContent
*
>
&
aVisibleKidsOfHiddenElement
nsTArray
<
ContextToClear
>
&
aContextsToClear
nsTArray
<
RefPtr
<
GeckoStyleContext
>
>
&
aSwappedStructOwners
)
:
mPresContext
(
aPresContext
)
mFrame
(
aFrame
)
mParentContent
(
nullptr
)
mContent
(
mFrame
-
>
GetContent
(
)
?
mFrame
-
>
GetContent
(
)
:
mParentContent
)
mChangeList
(
aChangeList
)
mHintsHandledByAncestors
(
aHintsHandledByAncestors
)
mHintsHandledBySelf
(
nsChangeHint
(
0
)
)
mRestyleTracker
(
aRestyleTracker
)
mSelectorsForDescendants
(
aSelectorsForDescendants
)
mTreeMatchContext
(
aTreeMatchContext
)
mResolvedChild
(
nullptr
)
mContextsToClear
(
aContextsToClear
)
mSwappedStructOwners
(
aSwappedStructOwners
)
mIsRootOfRestyle
(
true
)
#
ifdef
ACCESSIBILITY
mDesiredA11yNotifications
(
eSendAllNotifications
)
mKidsDesiredA11yNotifications
(
mDesiredA11yNotifications
)
mOurA11yNotification
(
eDontNotify
)
mVisibleKidsOfHiddenElement
(
aVisibleKidsOfHiddenElement
)
#
endif
#
ifdef
RESTYLE_LOGGING
mLoggingDepth
(
aRestyleTracker
.
LoggingDepth
(
)
+
1
)
#
endif
{
MOZ_ASSERT
(
!
mContent
|
|
!
mContent
-
>
IsStyledByServo
(
)
)
;
MOZ_ASSERT
(
!
(
mHintsHandledByAncestors
&
nsChangeHint_ReconstructFrame
)
"
why
restyle
descendants
if
we
are
reconstructing
the
frame
for
"
"
an
ancestor
?
"
)
;
}
ElementRestyler
:
:
ElementRestyler
(
const
ElementRestyler
&
aParentRestyler
nsIFrame
*
aFrame
uint32_t
aConstructorFlags
)
:
mPresContext
(
aParentRestyler
.
mPresContext
)
mFrame
(
aFrame
)
mParentContent
(
aParentRestyler
.
mContent
)
mContent
(
mFrame
-
>
GetContent
(
)
?
mFrame
-
>
GetContent
(
)
:
mParentContent
)
mChangeList
(
aParentRestyler
.
mChangeList
)
mHintsHandledByAncestors
(
(
aParentRestyler
.
mHintsHandledByAncestors
|
aParentRestyler
.
mHintsHandledBySelf
)
&
(
(
aConstructorFlags
&
FOR_OUT_OF_FLOW_CHILD
)
?
~
nsChangeHint_AllReflowHints
:
~
nsChangeHint
(
0
)
)
)
mHintsHandledBySelf
(
nsChangeHint
(
0
)
)
mRestyleTracker
(
aParentRestyler
.
mRestyleTracker
)
mSelectorsForDescendants
(
aParentRestyler
.
mSelectorsForDescendants
)
mTreeMatchContext
(
aParentRestyler
.
mTreeMatchContext
)
mResolvedChild
(
nullptr
)
mContextsToClear
(
aParentRestyler
.
mContextsToClear
)
mSwappedStructOwners
(
aParentRestyler
.
mSwappedStructOwners
)
mIsRootOfRestyle
(
false
)
#
ifdef
ACCESSIBILITY
mDesiredA11yNotifications
(
aParentRestyler
.
mKidsDesiredA11yNotifications
)
mKidsDesiredA11yNotifications
(
mDesiredA11yNotifications
)
mOurA11yNotification
(
eDontNotify
)
mVisibleKidsOfHiddenElement
(
aParentRestyler
.
mVisibleKidsOfHiddenElement
)
#
endif
#
ifdef
RESTYLE_LOGGING
mLoggingDepth
(
aParentRestyler
.
mLoggingDepth
+
1
)
#
endif
{
MOZ_ASSERT
(
!
mContent
|
|
!
mContent
-
>
IsStyledByServo
(
)
)
;
MOZ_ASSERT
(
!
(
mHintsHandledByAncestors
&
nsChangeHint_ReconstructFrame
)
"
why
restyle
descendants
if
we
are
reconstructing
the
frame
for
"
"
an
ancestor
?
"
)
;
}
ElementRestyler
:
:
ElementRestyler
(
ParentContextFromChildFrame
const
ElementRestyler
&
aParentRestyler
nsIFrame
*
aFrame
)
:
mPresContext
(
aParentRestyler
.
mPresContext
)
mFrame
(
aFrame
)
mParentContent
(
aParentRestyler
.
mParentContent
)
mContent
(
mFrame
-
>
GetContent
(
)
?
mFrame
-
>
GetContent
(
)
:
mParentContent
)
mChangeList
(
aParentRestyler
.
mChangeList
)
mHintsHandledByAncestors
(
aParentRestyler
.
mHintsHandledByAncestors
|
aParentRestyler
.
mHintsHandledBySelf
)
mHintsHandledBySelf
(
nsChangeHint
(
0
)
)
mRestyleTracker
(
aParentRestyler
.
mRestyleTracker
)
mSelectorsForDescendants
(
aParentRestyler
.
mSelectorsForDescendants
)
mTreeMatchContext
(
aParentRestyler
.
mTreeMatchContext
)
mResolvedChild
(
nullptr
)
mContextsToClear
(
aParentRestyler
.
mContextsToClear
)
mSwappedStructOwners
(
aParentRestyler
.
mSwappedStructOwners
)
mIsRootOfRestyle
(
false
)
#
ifdef
ACCESSIBILITY
mDesiredA11yNotifications
(
aParentRestyler
.
mDesiredA11yNotifications
)
mKidsDesiredA11yNotifications
(
mDesiredA11yNotifications
)
mOurA11yNotification
(
eDontNotify
)
mVisibleKidsOfHiddenElement
(
aParentRestyler
.
mVisibleKidsOfHiddenElement
)
#
endif
#
ifdef
RESTYLE_LOGGING
mLoggingDepth
(
aParentRestyler
.
mLoggingDepth
+
1
)
#
endif
{
MOZ_ASSERT
(
!
mContent
|
|
!
mContent
-
>
IsStyledByServo
(
)
)
;
}
ElementRestyler
:
:
ElementRestyler
(
nsPresContext
*
aPresContext
nsIContent
*
aContent
nsStyleChangeList
*
aChangeList
nsChangeHint
aHintsHandledByAncestors
RestyleTracker
&
aRestyleTracker
nsTArray
<
nsCSSSelector
*
>
&
aSelectorsForDescendants
TreeMatchContext
&
aTreeMatchContext
nsTArray
<
nsIContent
*
>
&
aVisibleKidsOfHiddenElement
nsTArray
<
ContextToClear
>
&
aContextsToClear
nsTArray
<
RefPtr
<
GeckoStyleContext
>
>
&
aSwappedStructOwners
)
:
mPresContext
(
aPresContext
)
mFrame
(
nullptr
)
mParentContent
(
nullptr
)
mContent
(
aContent
)
mChangeList
(
aChangeList
)
mHintsHandledByAncestors
(
aHintsHandledByAncestors
)
mHintsHandledBySelf
(
nsChangeHint
(
0
)
)
mRestyleTracker
(
aRestyleTracker
)
mSelectorsForDescendants
(
aSelectorsForDescendants
)
mTreeMatchContext
(
aTreeMatchContext
)
mResolvedChild
(
nullptr
)
mContextsToClear
(
aContextsToClear
)
mSwappedStructOwners
(
aSwappedStructOwners
)
mIsRootOfRestyle
(
true
)
#
ifdef
ACCESSIBILITY
mDesiredA11yNotifications
(
eSendAllNotifications
)
mKidsDesiredA11yNotifications
(
mDesiredA11yNotifications
)
mOurA11yNotification
(
eDontNotify
)
mVisibleKidsOfHiddenElement
(
aVisibleKidsOfHiddenElement
)
#
endif
{
MOZ_ASSERT
(
!
(
mHintsHandledByAncestors
&
nsChangeHint_ReconstructFrame
)
"
why
restyle
descendants
if
we
are
reconstructing
the
frame
for
"
"
an
ancestor
?
"
)
;
}
void
ElementRestyler
:
:
CaptureChange
(
GeckoStyleContext
*
aOldContext
GeckoStyleContext
*
aNewContext
nsChangeHint
aChangeToAssume
uint32_t
*
aEqualStructs
uint32_t
*
aSamePointerStructs
)
{
static_assert
(
nsStyleStructID_Length
<
=
32
"
aEqualStructs
is
not
big
enough
"
)
;
NS_ASSERTION
(
aOldContext
-
>
GetPseudo
(
)
=
=
aNewContext
-
>
GetPseudo
(
)
"
old
and
new
style
contexts
should
have
the
same
pseudo
"
)
;
NS_ASSERTION
(
aOldContext
-
>
GetPseudoType
(
)
=
=
aNewContext
-
>
GetPseudoType
(
)
"
old
and
new
style
contexts
should
have
the
same
pseudo
"
)
;
nsChangeHint
ourChange
=
aOldContext
-
>
CalcStyleDifference
(
aNewContext
aEqualStructs
aSamePointerStructs
)
;
NS_ASSERTION
(
!
(
ourChange
&
nsChangeHint_AllReflowHints
)
|
|
(
ourChange
&
nsChangeHint_NeedReflow
)
"
Reflow
hint
bits
set
without
actually
asking
for
a
reflow
"
)
;
LOG_RESTYLE
(
"
CaptureChange
ourChange
=
%
s
aChangeToAssume
=
%
s
"
GeckoRestyleManager
:
:
ChangeHintToString
(
ourChange
)
.
get
(
)
GeckoRestyleManager
:
:
ChangeHintToString
(
aChangeToAssume
)
.
get
(
)
)
;
LOG_RESTYLE_INDENT
(
)
;
if
(
(
ourChange
&
nsChangeHint_UpdateEffects
)
&
&
mContent
&
&
!
mContent
-
>
IsElement
(
)
)
{
ourChange
&
=
~
nsChangeHint_UpdateEffects
;
}
ourChange
|
=
aChangeToAssume
;
nsChangeHint
changeToAppend
=
NS_RemoveSubsumedHints
(
ourChange
mHintsHandledByAncestors
)
;
if
(
!
NS_IsHintSubset
(
changeToAppend
mHintsHandledBySelf
)
)
{
mHintsHandledBySelf
|
=
changeToAppend
;
if
(
!
(
ourChange
&
nsChangeHint_ReconstructFrame
)
|
|
mContent
)
{
LOG_RESTYLE
(
"
appending
change
%
s
"
RestyleManager
:
:
ChangeHintToString
(
changeToAppend
)
.
get
(
)
)
;
mChangeList
-
>
AppendChange
(
mFrame
mContent
changeToAppend
)
;
}
else
{
LOG_RESTYLE
(
"
ignoring
ReconstructFrame
change
with
no
content
"
)
;
}
}
else
{
LOG_RESTYLE
(
"
change
has
already
been
handled
"
)
;
}
}
class
MOZ_RAII
AutoSelectorArrayTruncater
final
{
public
:
explicit
AutoSelectorArrayTruncater
(
nsTArray
<
nsCSSSelector
*
>
&
aSelectorsForDescendants
)
:
mSelectorsForDescendants
(
aSelectorsForDescendants
)
mOriginalLength
(
aSelectorsForDescendants
.
Length
(
)
)
{
}
~
AutoSelectorArrayTruncater
(
)
{
mSelectorsForDescendants
.
TruncateLength
(
mOriginalLength
)
;
}
private
:
nsTArray
<
nsCSSSelector
*
>
&
mSelectorsForDescendants
;
size_t
mOriginalLength
;
}
;
void
ElementRestyler
:
:
ConditionallyRestyleChildren
(
)
{
MOZ_ASSERT
(
mContent
=
=
mFrame
-
>
GetContent
(
)
)
;
if
(
!
mContent
-
>
IsElement
(
)
|
|
mSelectorsForDescendants
.
IsEmpty
(
)
)
{
return
;
}
Element
*
element
=
mContent
-
>
AsElement
(
)
;
LOG_RESTYLE
(
"
traversing
descendants
of
frame
%
s
(
with
element
%
s
)
to
"
"
propagate
eRestyle_SomeDescendants
for
these
%
d
selectors
:
"
FrameTagToString
(
mFrame
)
.
get
(
)
ElementTagToString
(
element
)
.
get
(
)
int
(
mSelectorsForDescendants
.
Length
(
)
)
)
;
LOG_RESTYLE_INDENT
(
)
;
#
ifdef
RESTYLE_LOGGING
for
(
nsCSSSelector
*
sel
:
mSelectorsForDescendants
)
{
LOG_RESTYLE
(
"
%
s
"
sel
-
>
RestrictedSelectorToString
(
)
.
get
(
)
)
;
}
#
endif
Element
*
restyleRoot
=
mRestyleTracker
.
FindClosestRestyleRoot
(
element
)
;
ConditionallyRestyleChildren
(
mFrame
restyleRoot
)
;
}
void
ElementRestyler
:
:
ConditionallyRestyleChildren
(
nsIFrame
*
aFrame
Element
*
aRestyleRoot
)
{
MOZ_ASSERT
(
aFrame
-
>
GetContent
(
)
)
;
MOZ_ASSERT
(
aFrame
-
>
GetContent
(
)
-
>
IsElement
(
)
)
;
MOZ_ASSERT
(
!
aFrame
-
>
GetContent
(
)
-
>
IsStyledByServo
(
)
)
;
ConditionallyRestyleUndisplayedDescendants
(
aFrame
aRestyleRoot
)
;
ConditionallyRestyleContentChildren
(
aFrame
aRestyleRoot
)
;
}
void
ElementRestyler
:
:
ConditionallyRestyleContentChildren
(
nsIFrame
*
aFrame
Element
*
aRestyleRoot
)
{
MOZ_ASSERT
(
aFrame
-
>
GetContent
(
)
)
;
MOZ_ASSERT
(
aFrame
-
>
GetContent
(
)
-
>
IsElement
(
)
)
;
MOZ_ASSERT
(
!
aFrame
-
>
GetContent
(
)
-
>
IsStyledByServo
(
)
)
;
if
(
aFrame
-
>
GetContent
(
)
-
>
HasFlag
(
mRestyleTracker
.
RootBit
(
)
)
)
{
aRestyleRoot
=
aFrame
-
>
GetContent
(
)
-
>
AsElement
(
)
;
}
for
(
nsIFrame
*
f
=
aFrame
;
f
;
f
=
GetNextContinuationWithSameStyle
(
f
f
-
>
StyleContext
(
)
-
>
AsGecko
(
)
)
)
{
nsIFrame
:
:
ChildListIterator
lists
(
f
)
;
for
(
;
!
lists
.
IsDone
(
)
;
lists
.
Next
(
)
)
{
for
(
nsIFrame
*
child
:
lists
.
CurrentList
(
)
)
{
if
(
!
(
child
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
&
&
!
GetPrevContinuationWithSameStyle
(
child
)
)
{
if
(
child
-
>
IsPlaceholderFrame
(
)
)
{
nsIFrame
*
outOfFlowFrame
=
nsPlaceholderFrame
:
:
GetRealFrameForPlaceholder
(
child
)
;
do
{
if
(
GetPrevContinuationWithSameStyle
(
outOfFlowFrame
)
)
{
continue
;
}
if
(
!
ConditionallyRestyle
(
outOfFlowFrame
aRestyleRoot
)
)
{
ConditionallyRestyleChildren
(
outOfFlowFrame
aRestyleRoot
)
;
}
}
while
(
(
outOfFlowFrame
=
outOfFlowFrame
-
>
GetNextContinuation
(
)
)
)
;
}
else
{
if
(
child
!
=
mResolvedChild
)
{
if
(
!
ConditionallyRestyle
(
child
aRestyleRoot
)
)
{
ConditionallyRestyleChildren
(
child
aRestyleRoot
)
;
}
}
}
}
}
}
}
}
void
ElementRestyler
:
:
ConditionallyRestyleUndisplayedDescendants
(
nsIFrame
*
aFrame
Element
*
aRestyleRoot
)
{
nsIContent
*
undisplayedParent
;
if
(
MustCheckUndisplayedContent
(
aFrame
undisplayedParent
)
)
{
DoConditionallyRestyleUndisplayedDescendants
(
undisplayedParent
aRestyleRoot
)
;
}
}
void
ElementRestyler
:
:
DoConditionallyRestyleUndisplayedDescendants
(
nsIContent
*
aParent
Element
*
aRestyleRoot
)
{
nsCSSFrameConstructor
*
fc
=
mPresContext
-
>
FrameConstructor
(
)
;
UndisplayedNode
*
nodes
=
fc
-
>
GetAllRegisteredDisplayNoneStylesIn
(
aParent
)
;
ConditionallyRestyleUndisplayedNodes
(
nodes
aParent
StyleDisplay
:
:
None
aRestyleRoot
)
;
nodes
=
fc
-
>
GetAllRegisteredDisplayContentsStylesIn
(
aParent
)
;
ConditionallyRestyleUndisplayedNodes
(
nodes
aParent
StyleDisplay
:
:
Contents
aRestyleRoot
)
;
}
void
ElementRestyler
:
:
ConditionallyRestyleUndisplayedNodes
(
UndisplayedNode
*
aUndisplayed
nsIContent
*
aUndisplayedParent
const
StyleDisplay
aDisplay
Element
*
aRestyleRoot
)
{
MOZ_ASSERT
(
aDisplay
=
=
StyleDisplay
:
:
None
|
|
aDisplay
=
=
StyleDisplay
:
:
Contents
)
;
if
(
!
aUndisplayed
)
{
return
;
}
if
(
aUndisplayedParent
&
&
aUndisplayedParent
-
>
IsElement
(
)
&
&
aUndisplayedParent
-
>
HasFlag
(
mRestyleTracker
.
RootBit
(
)
)
)
{
MOZ_ASSERT
(
!
aUndisplayedParent
-
>
IsStyledByServo
(
)
)
;
aRestyleRoot
=
aUndisplayedParent
-
>
AsElement
(
)
;
}
for
(
UndisplayedNode
*
undisplayed
=
aUndisplayed
;
undisplayed
;
undisplayed
=
undisplayed
-
>
getNext
(
)
)
{
if
(
!
undisplayed
-
>
mContent
-
>
IsElement
(
)
)
{
continue
;
}
Element
*
element
=
undisplayed
-
>
mContent
-
>
AsElement
(
)
;
if
(
!
ConditionallyRestyle
(
element
aRestyleRoot
)
)
{
if
(
aDisplay
=
=
StyleDisplay
:
:
None
)
{
ConditionallyRestyleContentDescendants
(
element
aRestyleRoot
)
;
}
else
{
DoConditionallyRestyleUndisplayedDescendants
(
element
aRestyleRoot
)
;
}
}
}
}
void
ElementRestyler
:
:
ConditionallyRestyleContentDescendants
(
Element
*
aElement
Element
*
aRestyleRoot
)
{
MOZ_ASSERT
(
!
aElement
-
>
IsStyledByServo
(
)
)
;
if
(
aElement
-
>
HasFlag
(
mRestyleTracker
.
RootBit
(
)
)
)
{
aRestyleRoot
=
aElement
;
}
FlattenedChildIterator
it
(
aElement
)
;
for
(
nsIContent
*
n
=
it
.
GetNextChild
(
)
;
n
;
n
=
it
.
GetNextChild
(
)
)
{
if
(
n
-
>
IsElement
(
)
)
{
Element
*
e
=
n
-
>
AsElement
(
)
;
if
(
!
ConditionallyRestyle
(
e
aRestyleRoot
)
)
{
ConditionallyRestyleContentDescendants
(
e
aRestyleRoot
)
;
}
}
}
}
bool
ElementRestyler
:
:
ConditionallyRestyle
(
nsIFrame
*
aFrame
Element
*
aRestyleRoot
)
{
MOZ_ASSERT
(
aFrame
-
>
GetContent
(
)
)
;
if
(
!
aFrame
-
>
GetContent
(
)
-
>
IsElement
(
)
)
{
return
true
;
}
return
ConditionallyRestyle
(
aFrame
-
>
GetContent
(
)
-
>
AsElement
(
)
aRestyleRoot
)
;
}
bool
ElementRestyler
:
:
ConditionallyRestyle
(
Element
*
aElement
Element
*
aRestyleRoot
)
{
MOZ_ASSERT
(
!
aElement
-
>
IsStyledByServo
(
)
)
;
LOG_RESTYLE
(
"
considering
element
%
s
for
eRestyle_SomeDescendants
"
ElementTagToString
(
aElement
)
.
get
(
)
)
;
LOG_RESTYLE_INDENT
(
)
;
if
(
aElement
-
>
HasFlag
(
mRestyleTracker
.
RootBit
(
)
)
)
{
aRestyleRoot
=
aElement
;
}
if
(
mRestyleTracker
.
HasRestyleData
(
aElement
)
)
{
nsRestyleHint
rshint
=
eRestyle_SomeDescendants
;
if
(
SelectorMatchesForRestyle
(
aElement
)
)
{
LOG_RESTYLE
(
"
element
has
existing
restyle
data
and
matches
a
selector
"
)
;
rshint
|
=
eRestyle_Self
;
}
else
{
LOG_RESTYLE
(
"
element
has
existing
restyle
data
but
doesn
'
t
match
selectors
"
)
;
}
RestyleHintData
data
;
data
.
mSelectorsForDescendants
=
mSelectorsForDescendants
;
mRestyleTracker
.
AddPendingRestyle
(
aElement
rshint
nsChangeHint
(
0
)
&
data
Some
(
aRestyleRoot
)
)
;
return
true
;
}
if
(
SelectorMatchesForRestyle
(
aElement
)
)
{
LOG_RESTYLE
(
"
element
has
no
restyle
data
but
matches
a
selector
"
)
;
RestyleHintData
data
;
data
.
mSelectorsForDescendants
=
mSelectorsForDescendants
;
mRestyleTracker
.
AddPendingRestyle
(
aElement
eRestyle_Self
|
eRestyle_SomeDescendants
nsChangeHint
(
0
)
&
data
Some
(
aRestyleRoot
)
)
;
return
true
;
}
return
false
;
}
bool
ElementRestyler
:
:
MustCheckUndisplayedContent
(
nsIFrame
*
aFrame
nsIContent
*
&
aUndisplayedParent
)
{
if
(
aFrame
-
>
StyleContext
(
)
-
>
GetPseudo
(
)
)
{
aUndisplayedParent
=
nullptr
;
return
aFrame
=
=
mPresContext
-
>
FrameConstructor
(
)
-
>
GetDocElementContainingBlock
(
)
;
}
aUndisplayedParent
=
aFrame
-
>
GetContent
(
)
;
return
!
!
aUndisplayedParent
;
}
bool
ElementRestyler
:
:
MoveStyleContextsForContentChildren
(
nsIFrame
*
aParent
GeckoStyleContext
*
aOldContext
nsTArray
<
GeckoStyleContext
*
>
&
aContextsToMove
)
{
nsIFrame
:
:
ChildListIterator
lists
(
aParent
)
;
for
(
;
!
lists
.
IsDone
(
)
;
lists
.
Next
(
)
)
{
for
(
nsIFrame
*
child
:
lists
.
CurrentList
(
)
)
{
if
(
child
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
{
return
false
;
}
if
(
GetPrevContinuationWithSameStyle
(
child
)
)
{
continue
;
}
if
(
child
-
>
IsPlaceholderFrame
(
)
)
{
return
false
;
}
GeckoStyleContext
*
sc
=
child
-
>
StyleContext
(
)
-
>
AsGecko
(
)
;
if
(
sc
-
>
GetParent
(
)
!
=
aOldContext
)
{
return
false
;
}
LayoutFrameType
type
=
child
-
>
Type
(
)
;
if
(
type
=
=
LayoutFrameType
:
:
Letter
|
|
type
=
=
LayoutFrameType
:
:
Line
)
{
return
false
;
}
if
(
sc
-
>
HasChildThatUsesGrandancestorStyle
(
)
)
{
return
false
;
}
nsAtom
*
pseudoTag
=
sc
-
>
GetPseudo
(
)
;
if
(
pseudoTag
&
&
!
nsCSSAnonBoxes
:
:
IsNonElement
(
pseudoTag
)
)
{
return
false
;
}
aContextsToMove
.
AppendElement
(
sc
)
;
}
}
return
true
;
}
bool
ElementRestyler
:
:
MoveStyleContextsForChildren
(
GeckoStyleContext
*
aOldContext
)
{
nsIContent
*
undisplayedParent
;
if
(
MustCheckUndisplayedContent
(
mFrame
undisplayedParent
)
)
{
nsCSSFrameConstructor
*
fc
=
mPresContext
-
>
FrameConstructor
(
)
;
if
(
fc
-
>
GetAllRegisteredDisplayNoneStylesIn
(
undisplayedParent
)
|
|
fc
-
>
GetAllRegisteredDisplayContentsStylesIn
(
undisplayedParent
)
)
{
return
false
;
}
}
nsTArray
<
GeckoStyleContext
*
>
contextsToMove
;
MOZ_ASSERT
(
!
MustReframeForBeforePseudo
(
)
"
shouldn
'
t
need
to
reframe
:
:
before
as
we
would
have
had
"
"
eRestyle_Subtree
and
wouldn
'
t
get
in
here
"
)
;
DebugOnly
<
nsIFrame
*
>
lastContinuation
;
for
(
nsIFrame
*
f
=
mFrame
;
f
;
f
=
GetNextContinuationWithSameStyle
(
f
f
-
>
StyleContext
(
)
-
>
AsGecko
(
)
)
)
{
lastContinuation
=
f
;
if
(
!
MoveStyleContextsForContentChildren
(
f
aOldContext
contextsToMove
)
)
{
return
false
;
}
}
MOZ_ASSERT
(
!
MustReframeForAfterPseudo
(
lastContinuation
)
"
shouldn
'
t
need
to
reframe
:
:
after
as
we
would
have
had
"
"
eRestyle_Subtree
and
wouldn
'
t
get
in
here
"
)
;
GeckoStyleContext
*
newParent
=
mFrame
-
>
StyleContext
(
)
-
>
AsGecko
(
)
;
for
(
GeckoStyleContext
*
child
:
contextsToMove
)
{
if
(
child
-
>
GetParent
(
)
!
=
newParent
)
{
child
-
>
MoveTo
(
newParent
)
;
}
}
return
true
;
}
void
ElementRestyler
:
:
Restyle
(
nsRestyleHint
aRestyleHint
)
{
NS_ASSERTION
(
mFrame
-
>
GetContent
(
)
|
|
!
mParentContent
|
|
!
mParentContent
-
>
GetParent
(
)
"
frame
must
have
content
(
unless
at
the
top
of
the
tree
)
"
)
;
MOZ_ASSERT
(
mPresContext
=
=
mFrame
-
>
PresContext
(
)
"
pres
contexts
match
"
)
;
NS_ASSERTION
(
!
GetPrevContinuationWithSameStyle
(
mFrame
)
"
should
not
be
trying
to
restyle
this
frame
separately
"
)
;
MOZ_ASSERT
(
!
(
aRestyleHint
&
eRestyle_LaterSiblings
)
"
eRestyle_LaterSiblings
must
not
be
part
of
aRestyleHint
"
)
;
AutoDisplayContentsAncestorPusher
adcp
(
mTreeMatchContext
mPresContext
mFrame
-
>
GetContent
(
)
?
mFrame
-
>
GetContent
(
)
-
>
GetParent
(
)
:
nullptr
)
;
AutoSelectorArrayTruncater
asat
(
mSelectorsForDescendants
)
;
nsTArray
<
RefPtr
<
Element
>
>
descendants
;
nsRestyleHint
hintToRestore
=
nsRestyleHint
(
0
)
;
RestyleHintData
hintDataToRestore
;
if
(
mContent
&
&
mContent
-
>
IsElement
(
)
&
&
mContent
-
>
GetPrimaryFrame
(
)
=
=
mFrame
)
{
mContent
-
>
OwnerDoc
(
)
-
>
FlushPendingLinkUpdates
(
)
;
nsAutoPtr
<
RestyleTracker
:
:
RestyleData
>
restyleData
;
if
(
mRestyleTracker
.
GetRestyleData
(
mContent
-
>
AsElement
(
)
restyleData
)
)
{
nsChangeHint
changeToAppend
=
NS_RemoveSubsumedHints
(
restyleData
-
>
mChangeHint
mHintsHandledByAncestors
)
;
if
(
!
NS_IsHintSubset
(
changeToAppend
mHintsHandledBySelf
)
)
{
mHintsHandledBySelf
|
=
changeToAppend
;
mChangeList
-
>
AppendChange
(
mFrame
mContent
changeToAppend
)
;
}
mSelectorsForDescendants
.
AppendElements
(
restyleData
-
>
mRestyleHintData
.
mSelectorsForDescendants
)
;
hintToRestore
=
restyleData
-
>
mRestyleHint
;
hintDataToRestore
=
Move
(
restyleData
-
>
mRestyleHintData
)
;
aRestyleHint
=
nsRestyleHint
(
aRestyleHint
|
restyleData
-
>
mRestyleHint
)
;
descendants
.
SwapElements
(
restyleData
-
>
mDescendants
)
;
}
}
nsRestyleHint
childRestyleHint
=
nsRestyleHint
(
aRestyleHint
&
(
eRestyle_SomeDescendants
|
eRestyle_Subtree
|
eRestyle_ForceDescendants
)
)
;
RefPtr
<
GeckoStyleContext
>
oldContext
=
mFrame
-
>
StyleContext
(
)
-
>
AsGecko
(
)
;
nsTArray
<
SwapInstruction
>
swaps
;
RestyleResult
result
=
RestyleResult
:
:
eNone
;
uint32_t
swappedStructs
=
0
;
nsRestyleHint
thisRestyleHint
=
aRestyleHint
;
bool
haveMoreContinuations
=
false
;
for
(
nsIFrame
*
f
=
mFrame
;
f
;
)
{
RestyleResult
thisResult
=
RestyleSelf
(
f
thisRestyleHint
&
swappedStructs
swaps
)
;
if
(
thisResult
!
=
RestyleResult
:
:
eStop
)
{
thisRestyleHint
=
nsRestyleHint
(
thisRestyleHint
|
eRestyle_Force
)
;
if
(
result
=
=
RestyleResult
:
:
eStop
)
{
result
=
thisResult
;
f
=
mFrame
;
continue
;
}
}
if
(
thisResult
>
result
)
{
result
=
thisResult
;
}
f
=
GetNextContinuationWithSameStyle
(
f
oldContext
&
haveMoreContinuations
)
;
}
RestyleManager
:
:
AddLayerChangesForAnimation
(
mFrame
mContent
*
mChangeList
)
;
if
(
haveMoreContinuations
&
&
hintToRestore
)
{
mRestyleTracker
.
AddPendingRestyleToTable
(
mContent
-
>
AsElement
(
)
hintToRestore
nsChangeHint
(
0
)
)
;
}
if
(
result
=
=
RestyleResult
:
:
eStop
)
{
MOZ_ASSERT
(
mFrame
-
>
StyleContext
(
)
=
=
oldContext
"
frame
should
have
been
left
with
its
old
style
context
"
)
;
nsIFrame
*
unused
;
GeckoStyleContext
*
newParent
=
mFrame
-
>
GetParentStyleContext
(
&
unused
)
-
>
AsGecko
(
)
;
if
(
oldContext
-
>
GetParent
(
)
!
=
newParent
)
{
LOG_RESTYLE
(
"
moving
style
context
%
p
from
old
parent
%
p
to
new
parent
%
p
"
oldContext
.
get
(
)
oldContext
-
>
GetParent
(
)
newParent
)
;
mSwappedStructOwners
.
AppendElement
(
newParent
)
;
oldContext
-
>
MoveTo
(
newParent
)
;
}
if
(
!
(
mHintsHandledBySelf
&
nsChangeHint_ReconstructFrame
)
)
{
InitializeAccessibilityNotifications
(
mFrame
-
>
StyleContext
(
)
)
;
SendAccessibilityNotifications
(
)
;
}
mRestyleTracker
.
AddRestyleRootsIfAwaitingRestyle
(
descendants
)
;
if
(
aRestyleHint
&
eRestyle_SomeDescendants
)
{
ConditionallyRestyleChildren
(
)
;
}
return
;
}
if
(
result
=
=
RestyleResult
:
:
eStopWithStyleChange
&
&
!
(
mHintsHandledBySelf
&
nsChangeHint_ReconstructFrame
)
)
{
MOZ_ASSERT
(
mFrame
-
>
StyleContext
(
)
!
=
oldContext
"
RestyleResult
:
:
eStopWithStyleChange
should
only
be
returned
"
"
if
we
got
a
new
style
context
or
we
will
reconstruct
"
)
;
MOZ_ASSERT
(
swappedStructs
=
=
0
"
should
have
ensured
we
didn
'
t
swap
structs
when
"
"
returning
RestyleResult
:
:
eStopWithStyleChange
"
)
;
const
bool
canStop
=
MoveStyleContextsForChildren
(
oldContext
)
;
if
(
canStop
)
{
if
(
!
(
mHintsHandledBySelf
&
nsChangeHint_ReconstructFrame
)
)
{
InitializeAccessibilityNotifications
(
mFrame
-
>
StyleContext
(
)
)
;
SendAccessibilityNotifications
(
)
;
}
mRestyleTracker
.
AddRestyleRootsIfAwaitingRestyle
(
descendants
)
;
if
(
aRestyleHint
&
eRestyle_SomeDescendants
)
{
ConditionallyRestyleChildren
(
)
;
}
return
;
}
for
(
SwapInstruction
&
swap
:
swaps
)
{
LOG_RESTYLE
(
"
swapping
style
structs
between
%
p
and
%
p
"
swap
.
mOldContext
.
get
(
)
swap
.
mNewContext
.
get
(
)
)
;
swap
.
mOldContext
-
>
AsGecko
(
)
-
>
SwapStyleData
(
swap
.
mNewContext
-
>
AsGecko
(
)
swap
.
mStructsToSwap
)
;
swappedStructs
|
=
swap
.
mStructsToSwap
;
}
swaps
.
Clear
(
)
;
}
if
(
!
swappedStructs
)
{
oldContext
=
nullptr
;
}
if
(
result
=
=
RestyleResult
:
:
eContinueAndForceDescendants
)
{
childRestyleHint
=
nsRestyleHint
(
childRestyleHint
|
eRestyle_ForceDescendants
)
;
}
if
(
!
(
mHintsHandledBySelf
&
nsChangeHint_ReconstructFrame
)
)
{
RestyleChildren
(
childRestyleHint
)
;
}
if
(
oldContext
&
&
!
oldContext
-
>
HasSingleReference
(
)
)
{
oldContext
-
>
SetIneligibleForSharing
(
)
;
ContextToClear
*
toClear
=
mContextsToClear
.
AppendElement
(
)
;
toClear
-
>
mStyleContext
=
Move
(
oldContext
)
;
toClear
-
>
mStructs
=
swappedStructs
;
}
mRestyleTracker
.
AddRestyleRootsIfAwaitingRestyle
(
descendants
)
;
}
void
ElementRestyler
:
:
ComputeRestyleResultFromFrame
(
nsIFrame
*
aSelf
RestyleResult
&
aRestyleResult
bool
&
aCanStopWithStyleChange
)
{
if
(
aSelf
-
>
GetAdditionalStyleContext
(
0
)
)
{
LOG_RESTYLE_CONTINUE
(
"
there
are
additional
style
contexts
"
)
;
aRestyleResult
=
RestyleResult
:
:
eContinue
;
aCanStopWithStyleChange
=
false
;
return
;
}
if
(
aSelf
-
>
GetContent
(
)
&
&
aSelf
-
>
GetContent
(
)
-
>
IsNativeAnonymous
(
)
)
{
LOG_RESTYLE_CONTINUE
(
"
native
anonymous
content
"
)
;
aRestyleResult
=
RestyleResult
:
:
eContinue
;
aCanStopWithStyleChange
=
false
;
return
;
}
LayoutFrameType
type
=
aSelf
-
>
Type
(
)
;
if
(
type
=
=
LayoutFrameType
:
:
Letter
)
{
LOG_RESTYLE_CONTINUE
(
"
frame
is
a
letter
frame
"
)
;
aRestyleResult
=
RestyleResult
:
:
eContinue
;
aCanStopWithStyleChange
=
false
;
return
;
}
if
(
type
=
=
LayoutFrameType
:
:
Line
)
{
LOG_RESTYLE_CONTINUE
(
"
frame
is
a
line
frame
"
)
;
aRestyleResult
=
RestyleResult
:
:
eContinue
;
aCanStopWithStyleChange
=
false
;
return
;
}
GeckoStyleContext
*
oldContext
=
aSelf
-
>
StyleContext
(
)
-
>
AsGecko
(
)
;
if
(
oldContext
-
>
HasChildThatUsesGrandancestorStyle
(
)
)
{
LOG_RESTYLE_CONTINUE
(
"
the
old
context
uses
grandancestor
style
"
)
;
aRestyleResult
=
RestyleResult
:
:
eContinue
;
aCanStopWithStyleChange
=
false
;
return
;
}
if
(
oldContext
-
>
GetStyleIfVisited
(
)
)
{
LOG_RESTYLE_CONTINUE
(
"
the
old
style
context
has
StyleIfVisited
"
)
;
aRestyleResult
=
RestyleResult
:
:
eContinue
;
aCanStopWithStyleChange
=
false
;
return
;
}
GeckoStyleContext
*
parentContext
=
oldContext
-
>
GetParent
(
)
;
if
(
parentContext
&
&
parentContext
-
>
GetStyleIfVisited
(
)
)
{
LOG_RESTYLE_CONTINUE
(
"
the
old
style
context
'
s
parent
has
StyleIfVisited
"
)
;
aRestyleResult
=
RestyleResult
:
:
eContinue
;
aCanStopWithStyleChange
=
false
;
return
;
}
nsAtom
*
pseudoTag
=
oldContext
-
>
GetPseudo
(
)
;
if
(
pseudoTag
&
&
!
nsCSSAnonBoxes
:
:
IsNonElement
(
pseudoTag
)
)
{
LOG_RESTYLE_CONTINUE
(
"
the
old
style
context
is
for
a
pseudo
"
)
;
aRestyleResult
=
RestyleResult
:
:
eContinue
;
aCanStopWithStyleChange
=
false
;
return
;
}
nsIFrame
*
parent
=
mFrame
-
>
GetParent
(
)
;
if
(
parent
)
{
nsAtom
*
parentPseudoTag
=
parent
-
>
StyleContext
(
)
-
>
GetPseudo
(
)
;
if
(
parentPseudoTag
&
&
parentPseudoTag
!
=
nsCSSAnonBoxes
:
:
firstLetterContinuation
)
{
MOZ_ASSERT
(
parentPseudoTag
!
=
nsCSSAnonBoxes
:
:
mozText
"
Style
of
text
node
should
not
be
parent
of
anything
"
)
;
MOZ_ASSERT
(
parentPseudoTag
!
=
nsCSSAnonBoxes
:
:
oofPlaceholder
"
Style
of
placeholder
should
not
be
parent
of
anything
"
)
;
LOG_RESTYLE_CONTINUE
(
"
the
old
style
context
'
s
parent
is
for
a
pseudo
"
)
;
aRestyleResult
=
RestyleResult
:
:
eContinue
;
}
}
}
void
ElementRestyler
:
:
ComputeRestyleResultFromNewContext
(
nsIFrame
*
aSelf
GeckoStyleContext
*
aNewContext
RestyleResult
&
aRestyleResult
bool
&
aCanStopWithStyleChange
)
{
if
(
aRestyleResult
=
=
RestyleResult
:
:
eContinue
&
&
!
aCanStopWithStyleChange
)
{
return
;
}
if
(
aNewContext
-
>
GetStyleIfVisited
(
)
)
{
LOG_RESTYLE_CONTINUE
(
"
the
new
style
context
has
StyleIfVisited
"
)
;
aRestyleResult
=
RestyleResult
:
:
eContinue
;
aCanStopWithStyleChange
=
false
;
return
;
}
GeckoStyleContext
*
oldContext
=
aSelf
-
>
StyleContext
(
)
-
>
AsGecko
(
)
;
if
(
oldContext
-
>
IsLinkContext
(
)
!
=
aNewContext
-
>
IsLinkContext
(
)
|
|
oldContext
-
>
RelevantLinkVisited
(
)
!
=
aNewContext
-
>
RelevantLinkVisited
(
)
|
|
oldContext
-
>
GetPseudo
(
)
!
=
aNewContext
-
>
GetPseudo
(
)
|
|
oldContext
-
>
GetPseudoType
(
)
!
=
aNewContext
-
>
GetPseudoType
(
)
)
{
LOG_RESTYLE_CONTINUE
(
"
the
old
and
new
style
contexts
have
different
link
/
"
"
visited
/
pseudo
"
)
;
aRestyleResult
=
RestyleResult
:
:
eContinue
;
aCanStopWithStyleChange
=
false
;
return
;
}
if
(
oldContext
-
>
RuleNode
(
)
!
=
aNewContext
-
>
RuleNode
(
)
)
{
LOG_RESTYLE_CONTINUE
(
"
the
old
and
new
style
contexts
have
different
"
"
rulenodes
"
)
;
aRestyleResult
=
RestyleResult
:
:
eContinue
;
if
(
!
aCanStopWithStyleChange
)
{
return
;
}
}
if
(
auto
*
position
=
oldContext
-
>
PeekStylePosition
(
)
)
{
const
bool
wasLegacyJustifyItems
=
position
-
>
mJustifyItems
&
NS_STYLE_JUSTIFY_LEGACY
;
const
auto
newJustifyItems
=
aNewContext
-
>
StylePosition
(
)
-
>
mJustifyItems
;
const
bool
isLegacyJustifyItems
=
newJustifyItems
&
NS_STYLE_JUSTIFY_LEGACY
;
if
(
wasLegacyJustifyItems
!
=
isLegacyJustifyItems
|
|
(
wasLegacyJustifyItems
&
&
position
-
>
mJustifyItems
!
=
newJustifyItems
)
)
{
LOG_RESTYLE_CONTINUE
(
"
legacy
justify
-
items
changed
between
old
and
new
"
"
style
contexts
"
)
;
aRestyleResult
=
RestyleResult
:
:
eContinue
;
aCanStopWithStyleChange
=
false
;
return
;
}
}
if
(
oldContext
-
>
HasTextDecorationLines
(
)
!
=
aNewContext
-
>
HasTextDecorationLines
(
)
)
{
LOG_RESTYLE_CONTINUE
(
"
NS_STYLE_HAS_TEXT_DECORATION_LINES
differs
between
old
"
"
and
new
style
contexts
"
)
;
aRestyleResult
=
RestyleResult
:
:
eContinue
;
aCanStopWithStyleChange
=
false
;
return
;
}
if
(
oldContext
-
>
HasPseudoElementData
(
)
!
=
aNewContext
-
>
HasPseudoElementData
(
)
)
{
LOG_RESTYLE_CONTINUE
(
"
NS_STYLE_HAS_PSEUDO_ELEMENT_DATA
differs
between
old
"
"
and
new
style
contexts
"
)
;
aRestyleResult
=
RestyleResult
:
:
eContinue
;
aCanStopWithStyleChange
=
false
;
return
;
}
if
(
oldContext
-
>
ShouldSuppressLineBreak
(
)
!
=
aNewContext
-
>
ShouldSuppressLineBreak
(
)
)
{
LOG_RESTYLE_CONTINUE
(
"
NS_STYLE_SUPPRESS_LINEBREAK
differs
"
"
between
old
and
new
style
contexts
"
)
;
aRestyleResult
=
RestyleResult
:
:
eContinue
;
aCanStopWithStyleChange
=
false
;
return
;
}
if
(
oldContext
-
>
IsInDisplayNoneSubtree
(
)
!
=
aNewContext
-
>
IsInDisplayNoneSubtree
(
)
)
{
LOG_RESTYLE_CONTINUE
(
"
NS_STYLE_IN_DISPLAY_NONE_SUBTREE
differs
between
old
"
"
and
new
style
contexts
"
)
;
aRestyleResult
=
RestyleResult
:
:
eContinue
;
aCanStopWithStyleChange
=
false
;
return
;
}
if
(
oldContext
-
>
IsTextCombined
(
)
!
=
aNewContext
-
>
IsTextCombined
(
)
)
{
LOG_RESTYLE_CONTINUE
(
"
NS_STYLE_IS_TEXT_COMBINED
differs
between
"
"
old
and
new
style
contexts
"
)
;
aRestyleResult
=
RestyleResult
:
:
eContinue
;
aCanStopWithStyleChange
=
false
;
return
;
}
}
bool
ElementRestyler
:
:
SelectorMatchesForRestyle
(
Element
*
aElement
)
{
if
(
!
aElement
)
{
return
false
;
}
for
(
nsCSSSelector
*
selector
:
mSelectorsForDescendants
)
{
if
(
nsCSSRuleProcessor
:
:
RestrictedSelectorMatches
(
aElement
selector
mTreeMatchContext
)
)
{
return
true
;
}
}
return
false
;
}
bool
ElementRestyler
:
:
MustRestyleSelf
(
nsRestyleHint
aRestyleHint
Element
*
aElement
)
{
return
(
aRestyleHint
&
(
eRestyle_Self
|
eRestyle_Subtree
)
)
|
|
(
(
aRestyleHint
&
eRestyle_SomeDescendants
)
&
&
SelectorMatchesForRestyle
(
aElement
)
)
;
}
bool
ElementRestyler
:
:
CanReparentStyleContext
(
nsRestyleHint
aRestyleHint
)
{
return
!
(
aRestyleHint
&
~
(
eRestyle_Force
|
eRestyle_ForceDescendants
|
eRestyle_SomeDescendants
)
)
&
&
!
StyleSet
(
)
-
>
IsInRuleTreeReconstruct
(
)
;
}
static
bool
CommonInheritedStyleData
(
nsRuleNode
*
aRuleNode1
nsRuleNode
*
aRuleNode2
)
{
if
(
aRuleNode1
=
=
aRuleNode2
)
{
return
true
;
}
nsRuleNode
*
n1
=
aRuleNode1
-
>
GetParent
(
)
;
nsRuleNode
*
n2
=
aRuleNode2
-
>
GetParent
(
)
;
if
(
n1
=
=
n2
)
{
if
(
aRuleNode1
-
>
GetRule
(
)
&
&
aRuleNode1
-
>
GetRule
(
)
-
>
MightMapInheritedStyleData
(
)
)
{
return
false
;
}
if
(
aRuleNode2
-
>
GetRule
(
)
&
&
aRuleNode2
-
>
GetRule
(
)
-
>
MightMapInheritedStyleData
(
)
)
{
return
false
;
}
return
true
;
}
int
d1
=
0
d2
=
0
;
while
(
n1
)
{
+
+
d1
;
n1
=
n1
-
>
GetParent
(
)
;
}
while
(
n2
)
{
+
+
d2
;
n2
=
n2
-
>
GetParent
(
)
;
}
if
(
d2
>
d1
)
{
std
:
:
swap
(
d1
d2
)
;
std
:
:
swap
(
aRuleNode1
aRuleNode2
)
;
}
n1
=
aRuleNode1
;
n2
=
aRuleNode2
;
while
(
d1
>
d2
)
{
nsIStyleRule
*
rule
=
n1
-
>
GetRule
(
)
;
MOZ_ASSERT
(
rule
"
non
-
root
rule
node
should
have
a
rule
"
)
;
if
(
rule
-
>
MightMapInheritedStyleData
(
)
)
{
return
false
;
}
n1
=
n1
-
>
GetParent
(
)
;
-
-
d1
;
}
while
(
n1
!
=
n2
)
{
MOZ_ASSERT
(
n1
)
;
MOZ_ASSERT
(
n2
)
;
if
(
n1
-
>
GetRule
(
)
&
&
n1
-
>
GetRule
(
)
-
>
MightMapInheritedStyleData
(
)
)
{
return
false
;
}
if
(
n2
-
>
GetRule
(
)
&
&
n2
-
>
GetRule
(
)
-
>
MightMapInheritedStyleData
(
)
)
{
return
false
;
}
n1
=
n1
-
>
GetParent
(
)
;
n2
=
n2
-
>
GetParent
(
)
;
}
return
true
;
}
ElementRestyler
:
:
RestyleResult
ElementRestyler
:
:
RestyleSelf
(
nsIFrame
*
aSelf
nsRestyleHint
aRestyleHint
uint32_t
*
aSwappedStructs
nsTArray
<
SwapInstruction
>
&
aSwaps
)
{
MOZ_ASSERT
(
!
(
aRestyleHint
&
eRestyle_LaterSiblings
)
"
eRestyle_LaterSiblings
must
not
be
part
of
aRestyleHint
"
)
;
LOG_RESTYLE
(
"
RestyleSelf
%
s
aRestyleHint
=
%
s
"
FrameTagToString
(
aSelf
)
.
get
(
)
RestyleManager
:
:
RestyleHintToString
(
aRestyleHint
)
.
get
(
)
)
;
LOG_RESTYLE_INDENT
(
)
;
RestyleResult
result
=
RestyleResult
:
:
eStop
;
bool
canStopWithStyleChange
=
true
;
if
(
aRestyleHint
&
~
eRestyle_SomeDescendants
)
{
result
=
RestyleResult
:
:
eContinue
;
if
(
aRestyleHint
&
(
eRestyle_Subtree
|
eRestyle_Force
|
eRestyle_ForceDescendants
)
)
{
canStopWithStyleChange
=
false
;
}
}
if
(
!
mIsRootOfRestyle
)
{
canStopWithStyleChange
=
false
;
}
ComputeRestyleResultFromFrame
(
aSelf
result
canStopWithStyleChange
)
;
nsChangeHint
assumeDifferenceHint
=
nsChangeHint
(
0
)
;
RefPtr
<
GeckoStyleContext
>
oldContext
=
aSelf
-
>
StyleContext
(
)
-
>
AsGecko
(
)
;
nsStyleSet
*
styleSet
=
StyleSet
(
)
;
#
ifdef
ACCESSIBILITY
mWasFrameVisible
=
nsIPresShell
:
:
IsAccessibilityActive
(
)
?
oldContext
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
:
false
;
#
endif
nsAtom
*
const
pseudoTag
=
oldContext
-
>
GetPseudo
(
)
;
const
CSSPseudoElementType
pseudoType
=
oldContext
-
>
GetPseudoType
(
)
;
nsIFrame
*
providerFrame
;
nsStyleContext
*
parentContext_
=
aSelf
-
>
GetParentStyleContext
(
&
providerFrame
)
;
bool
isChild
=
providerFrame
&
&
providerFrame
-
>
GetParent
(
)
=
=
aSelf
;
if
(
isChild
)
{
MOZ_ASSERT
(
providerFrame
-
>
GetContent
(
)
=
=
aSelf
-
>
GetContent
(
)
"
Postcondition
for
GetParentStyleContext
(
)
violated
.
"
"
That
means
we
need
to
add
the
current
element
to
the
"
"
ancestor
filter
.
"
)
;
LOG_RESTYLE
(
"
resolving
child
provider
frame
"
)
;
ElementRestyler
providerRestyler
(
PARENT_CONTEXT_FROM_CHILD_FRAME
*
this
providerFrame
)
;
providerRestyler
.
Restyle
(
aRestyleHint
)
;
assumeDifferenceHint
=
providerRestyler
.
HintsHandledForFrame
(
)
;
parentContext_
=
providerFrame
-
>
StyleContext
(
)
;
mResolvedChild
=
providerFrame
;
LOG_RESTYLE_CONTINUE
(
"
we
had
a
provider
frame
"
)
;
result
=
RestyleResult
:
:
eContinue
;
canStopWithStyleChange
=
false
;
}
auto
*
parentContext
=
parentContext_
?
parentContext_
-
>
AsGecko
(
)
:
nullptr
;
LOG_RESTYLE
(
"
parentContext
=
%
p
"
parentContext
)
;
RefPtr
<
GeckoStyleContext
>
newContext
;
nsIFrame
*
prevContinuation
=
GetPrevContinuationWithPossiblySameStyle
(
aSelf
)
;
GeckoStyleContext
*
prevContinuationContext
;
bool
copyFromContinuation
=
prevContinuation
&
&
(
prevContinuationContext
=
prevContinuation
-
>
StyleContext
(
)
-
>
AsGecko
(
)
)
-
>
GetPseudo
(
)
=
=
oldContext
-
>
GetPseudo
(
)
&
&
prevContinuationContext
-
>
GetParent
(
)
=
=
parentContext
;
if
(
copyFromContinuation
)
{
LOG_RESTYLE
(
"
using
previous
continuation
'
s
context
"
)
;
newContext
=
prevContinuationContext
;
}
else
if
(
pseudoTag
=
=
nsCSSAnonBoxes
:
:
mozText
)
{
MOZ_ASSERT
(
aSelf
-
>
IsTextFrame
(
)
)
;
newContext
=
styleSet
-
>
ResolveStyleForText
(
aSelf
-
>
GetContent
(
)
parentContext
)
;
}
else
if
(
pseudoTag
=
=
nsCSSAnonBoxes
:
:
firstLetterContinuation
)
{
newContext
=
styleSet
-
>
ResolveStyleForFirstLetterContinuation
(
parentContext
)
;
}
else
if
(
pseudoTag
=
=
nsCSSAnonBoxes
:
:
oofPlaceholder
)
{
newContext
=
styleSet
-
>
ResolveStyleForPlaceholder
(
)
;
}
else
if
(
pseudoType
=
=
CSSPseudoElementType
:
:
NonInheritingAnonBox
)
{
newContext
=
styleSet
-
>
ResolveNonInheritingAnonymousBoxStyle
(
pseudoTag
)
;
}
else
{
Element
*
element
=
ElementForStyleContext
(
mParentContent
aSelf
pseudoType
)
;
if
(
!
MustRestyleSelf
(
aRestyleHint
element
)
)
{
if
(
CanReparentStyleContext
(
aRestyleHint
)
)
{
LOG_RESTYLE
(
"
reparenting
style
context
"
)
;
newContext
=
styleSet
-
>
ReparentStyleContext
(
oldContext
parentContext
element
)
;
}
else
{
Element
*
pseudoElement
=
PseudoElementForStyleContext
(
aSelf
pseudoType
)
;
MOZ_ASSERT
(
!
element
|
|
element
!
=
pseudoElement
"
pseudo
-
element
for
selector
matching
should
be
"
"
the
anonymous
content
node
that
we
create
"
"
not
the
real
element
"
)
;
LOG_RESTYLE
(
"
resolving
style
with
replacement
"
)
;
nsRestyleHint
rshint
=
aRestyleHint
&
~
eRestyle_SomeDescendants
;
newContext
=
styleSet
-
>
ResolveStyleWithReplacement
(
element
pseudoElement
parentContext
oldContext
rshint
)
;
}
}
else
if
(
pseudoType
=
=
CSSPseudoElementType
:
:
InheritingAnonBox
)
{
newContext
=
styleSet
-
>
ResolveInheritingAnonymousBoxStyle
(
pseudoTag
parentContext
)
;
}
else
{
if
(
pseudoTag
)
{
if
(
pseudoTag
=
=
nsCSSPseudoElements
:
:
before
|
|
pseudoTag
=
=
nsCSSPseudoElements
:
:
after
)
{
newContext
=
styleSet
-
>
ProbePseudoElementStyle
(
element
pseudoType
parentContext
mTreeMatchContext
)
;
if
(
!
newContext
)
{
mHintsHandledBySelf
|
=
nsChangeHint_ReconstructFrame
;
mChangeList
-
>
AppendChange
(
aSelf
element
nsChangeHint_ReconstructFrame
)
;
newContext
=
oldContext
;
#
ifdef
DEBUG
if
(
oldContext
-
>
GetParent
(
)
!
=
parentContext
)
{
oldContext
-
>
AddStyleBit
(
NS_STYLE_IS_GOING_AWAY
)
;
}
#
endif
}
}
else
{
NS_ASSERTION
(
pseudoType
<
CSSPseudoElementType
:
:
Count
"
Unexpected
pseudo
type
"
)
;
Element
*
pseudoElement
=
PseudoElementForStyleContext
(
aSelf
pseudoType
)
;
MOZ_ASSERT
(
element
!
=
pseudoElement
"
pseudo
-
element
for
selector
matching
should
be
"
"
the
anonymous
content
node
that
we
create
"
"
not
the
real
element
"
)
;
newContext
=
styleSet
-
>
ResolvePseudoElementStyle
(
element
pseudoType
parentContext
pseudoElement
)
;
}
}
else
{
NS_ASSERTION
(
aSelf
-
>
GetContent
(
)
"
non
pseudo
-
element
frame
without
content
node
"
)
;
TreeMatchContext
:
:
AutoParentDisplayBasedStyleFixupSkipper
parentDisplayBasedFixupSkipper
(
mTreeMatchContext
element
-
>
IsRootOfNativeAnonymousSubtree
(
)
)
;
newContext
=
styleSet
-
>
ResolveStyleFor
(
element
parentContext
mTreeMatchContext
)
;
}
}
}
MOZ_ASSERT
(
newContext
)
;
if
(
!
parentContext
)
{
if
(
oldContext
-
>
RuleNode
(
)
=
=
newContext
-
>
RuleNode
(
)
&
&
oldContext
-
>
IsLinkContext
(
)
=
=
newContext
-
>
IsLinkContext
(
)
&
&
oldContext
-
>
RelevantLinkVisited
(
)
=
=
newContext
-
>
RelevantLinkVisited
(
)
)
{
LOG_RESTYLE
(
"
restyling
root
and
keeping
old
context
"
)
;
LOG_RESTYLE_IF
(
this
result
!
=
RestyleResult
:
:
eContinue
"
continuing
restyle
since
this
is
the
root
"
)
;
newContext
=
oldContext
;
result
=
RestyleResult
:
:
eContinue
;
canStopWithStyleChange
=
false
;
}
}
LOG_RESTYLE
(
"
oldContext
=
%
p
newContext
=
%
p
%
s
"
oldContext
.
get
(
)
newContext
.
get
(
)
oldContext
=
=
newContext
?
(
const
char
*
)
"
(
same
)
"
:
(
const
char
*
)
"
"
)
;
if
(
newContext
!
=
oldContext
)
{
if
(
oldContext
-
>
IsShared
(
)
)
{
LOG_RESTYLE_CONTINUE
(
"
the
old
style
context
is
shared
"
)
;
result
=
RestyleResult
:
:
eContinue
;
if
(
!
CommonInheritedStyleData
(
oldContext
-
>
RuleNode
(
)
newContext
-
>
RuleNode
(
)
)
)
{
canStopWithStyleChange
=
false
;
}
}
ComputeRestyleResultFromNewContext
(
aSelf
newContext
result
canStopWithStyleChange
)
;
uint32_t
equalStructs
=
0
;
uint32_t
samePointerStructs
=
0
;
if
(
copyFromContinuation
)
{
if
(
result
=
=
RestyleResult
:
:
eStop
)
{
oldContext
-
>
CalcStyleDifference
(
newContext
&
equalStructs
&
samePointerStructs
)
;
if
(
equalStructs
!
=
NS_STYLE_INHERIT_MASK
)
{
LOG_RESTYLE_CONTINUE
(
"
there
is
different
style
data
:
%
s
"
GeckoRestyleManager
:
:
StructNamesToString
(
~
equalStructs
&
NS_STYLE_INHERIT_MASK
)
.
get
(
)
)
;
result
=
RestyleResult
:
:
eContinue
;
}
}
}
else
{
bool
changedStyle
=
GeckoRestyleManager
:
:
TryInitiatingTransition
(
mPresContext
aSelf
-
>
GetContent
(
)
oldContext
&
newContext
)
;
if
(
changedStyle
)
{
LOG_RESTYLE_CONTINUE
(
"
TryInitiatingTransition
changed
the
new
style
"
"
context
"
)
;
result
=
RestyleResult
:
:
eContinue
;
canStopWithStyleChange
=
false
;
}
CaptureChange
(
oldContext
newContext
assumeDifferenceHint
&
equalStructs
&
samePointerStructs
)
;
if
(
equalStructs
!
=
NS_STYLE_INHERIT_MASK
)
{
LOG_RESTYLE_CONTINUE
(
"
there
is
different
style
data
:
%
s
"
GeckoRestyleManager
:
:
StructNamesToString
(
~
equalStructs
&
NS_STYLE_INHERIT_MASK
)
.
get
(
)
)
;
result
=
RestyleResult
:
:
eContinue
;
}
}
if
(
canStopWithStyleChange
)
{
if
(
(
samePointerStructs
&
NS_STYLE_INHERITED_STRUCT_MASK
)
!
=
NS_STYLE_INHERITED_STRUCT_MASK
)
{
LOG_RESTYLE
(
"
can
'
t
return
RestyleResult
:
:
eStopWithStyleChange
since
"
"
there
is
different
inherited
data
"
)
;
canStopWithStyleChange
=
false
;
}
else
if
(
(
samePointerStructs
&
NS_STYLE_RESET_STRUCT_MASK
)
!
=
NS_STYLE_RESET_STRUCT_MASK
&
&
oldContext
-
>
HasChildThatUsesResetStyle
(
)
)
{
LOG_RESTYLE
(
"
can
'
t
return
RestyleResult
:
:
eStopWithStyleChange
since
"
"
there
is
different
reset
data
and
descendants
use
it
"
)
;
canStopWithStyleChange
=
false
;
}
}
if
(
result
=
=
RestyleResult
:
:
eStop
)
{
for
(
nsStyleStructID
sid
=
nsStyleStructID
(
0
)
;
sid
<
nsStyleStructID_Length
;
sid
=
nsStyleStructID
(
sid
+
1
)
)
{
if
(
oldContext
-
>
HasCachedDependentStyleData
(
sid
)
&
&
!
(
samePointerStructs
&
nsCachedStyleData
:
:
GetBitForSID
(
sid
)
)
)
{
LOG_RESTYLE_CONTINUE
(
"
there
are
different
struct
pointers
"
)
;
result
=
RestyleResult
:
:
eContinue
;
break
;
}
}
}
if
(
canStopWithStyleChange
)
{
LOG_RESTYLE
(
"
converting
%
s
into
RestyleResult
:
:
eStopWithStyleChange
"
RestyleResultToString
(
result
)
.
get
(
)
)
;
result
=
RestyleResult
:
:
eStopWithStyleChange
;
}
if
(
aRestyleHint
&
eRestyle_ForceDescendants
)
{
result
=
RestyleResult
:
:
eContinueAndForceDescendants
;
}
if
(
!
(
mHintsHandledBySelf
&
nsChangeHint_ReconstructFrame
)
)
{
if
(
result
!
=
RestyleResult
:
:
eStop
)
{
if
(
copyFromContinuation
)
{
LOG_RESTYLE
(
"
not
swapping
style
structs
since
we
copied
from
a
"
"
continuation
"
)
;
}
else
if
(
oldContext
-
>
IsShared
(
)
&
&
newContext
-
>
IsShared
(
)
)
{
LOG_RESTYLE
(
"
not
swapping
style
structs
since
both
old
and
contexts
"
"
are
shared
"
)
;
}
else
if
(
oldContext
-
>
IsShared
(
)
)
{
LOG_RESTYLE
(
"
not
swapping
style
structs
since
the
old
context
is
"
"
shared
"
)
;
}
else
if
(
newContext
-
>
IsShared
(
)
)
{
LOG_RESTYLE
(
"
not
swapping
style
structs
since
the
new
context
is
"
"
shared
"
)
;
}
else
{
if
(
result
=
=
RestyleResult
:
:
eStopWithStyleChange
)
{
LOG_RESTYLE
(
"
recording
a
style
struct
swap
between
%
p
and
%
p
to
"
"
do
if
RestyleResult
:
:
eStopWithStyleChange
fails
"
oldContext
.
get
(
)
newContext
.
get
(
)
)
;
SwapInstruction
*
swap
=
aSwaps
.
AppendElement
(
)
;
swap
-
>
mOldContext
=
oldContext
;
swap
-
>
mNewContext
=
newContext
;
swap
-
>
mStructsToSwap
=
equalStructs
;
}
else
{
LOG_RESTYLE
(
"
swapping
style
structs
between
%
p
and
%
p
"
oldContext
.
get
(
)
newContext
.
get
(
)
)
;
oldContext
-
>
AsGecko
(
)
-
>
SwapStyleData
(
newContext
-
>
AsGecko
(
)
equalStructs
)
;
*
aSwappedStructs
|
=
equalStructs
;
}
#
ifdef
RESTYLE_LOGGING
uint32_t
structs
=
GeckoRestyleManager
:
:
StructsToLog
(
)
&
equalStructs
;
if
(
structs
)
{
LOG_RESTYLE_INDENT
(
)
;
LOG_RESTYLE
(
"
old
style
context
now
has
:
%
s
"
oldContext
-
>
AsGecko
(
)
-
>
GetCachedStyleDataAsString
(
structs
)
.
get
(
)
)
;
LOG_RESTYLE
(
"
new
style
context
now
has
:
%
s
"
newContext
-
>
AsGecko
(
)
-
>
GetCachedStyleDataAsString
(
structs
)
.
get
(
)
)
;
}
#
endif
}
LOG_RESTYLE
(
"
setting
new
style
context
"
)
;
aSelf
-
>
SetStyleContext
(
newContext
)
;
}
}
else
{
LOG_RESTYLE
(
"
not
setting
new
style
context
since
we
'
ll
reframe
"
)
;
mSwappedStructOwners
.
AppendElement
(
newContext
-
>
GetParent
(
)
)
;
}
}
else
{
if
(
aRestyleHint
&
eRestyle_ForceDescendants
)
{
result
=
RestyleResult
:
:
eContinueAndForceDescendants
;
}
}
oldContext
=
nullptr
;
int32_t
contextIndex
=
0
;
for
(
nsStyleContext
*
oldExtraContext
;
(
oldExtraContext
=
aSelf
-
>
GetAdditionalStyleContext
(
contextIndex
)
)
;
+
+
contextIndex
)
{
LOG_RESTYLE
(
"
extra
context
%
d
"
contextIndex
)
;
LOG_RESTYLE_INDENT
(
)
;
RefPtr
<
GeckoStyleContext
>
newExtraContext
;
nsAtom
*
const
extraPseudoTag
=
oldExtraContext
-
>
GetPseudo
(
)
;
const
CSSPseudoElementType
extraPseudoType
=
oldExtraContext
-
>
GetPseudoType
(
)
;
NS_ASSERTION
(
extraPseudoTag
&
&
!
nsCSSAnonBoxes
:
:
IsNonElement
(
extraPseudoTag
)
"
extra
style
context
is
not
pseudo
element
"
)
;
Element
*
element
=
(
extraPseudoType
!
=
CSSPseudoElementType
:
:
InheritingAnonBox
&
&
extraPseudoType
!
=
CSSPseudoElementType
:
:
NonInheritingAnonBox
)
?
mContent
-
>
AsElement
(
)
:
nullptr
;
if
(
extraPseudoType
=
=
CSSPseudoElementType
:
:
NonInheritingAnonBox
)
{
newExtraContext
=
styleSet
-
>
ResolveNonInheritingAnonymousBoxStyle
(
extraPseudoTag
)
;
}
else
if
(
!
MustRestyleSelf
(
aRestyleHint
element
)
)
{
if
(
CanReparentStyleContext
(
aRestyleHint
)
)
{
newExtraContext
=
styleSet
-
>
ReparentStyleContext
(
oldExtraContext
-
>
AsGecko
(
)
newContext
element
)
;
}
else
{
Element
*
pseudoElement
=
PseudoElementForStyleContext
(
aSelf
extraPseudoType
)
;
MOZ_ASSERT
(
!
element
|
|
element
!
=
pseudoElement
"
pseudo
-
element
for
selector
matching
should
be
"
"
the
anonymous
content
node
that
we
create
"
"
not
the
real
element
"
)
;
newExtraContext
=
styleSet
-
>
ResolveStyleWithReplacement
(
element
pseudoElement
newContext
oldExtraContext
-
>
AsGecko
(
)
nsRestyleHint
(
0
)
)
;
}
}
else
if
(
extraPseudoType
=
=
CSSPseudoElementType
:
:
InheritingAnonBox
)
{
newExtraContext
=
styleSet
-
>
ResolveInheritingAnonymousBoxStyle
(
extraPseudoTag
newContext
)
;
}
else
{
NS_ASSERTION
(
extraPseudoType
<
CSSPseudoElementType
:
:
Count
"
Unexpected
type
"
)
;
newExtraContext
=
styleSet
-
>
ResolvePseudoElementStyle
(
mContent
-
>
AsElement
(
)
extraPseudoType
newContext
nullptr
)
;
}
MOZ_ASSERT
(
newExtraContext
)
;
LOG_RESTYLE
(
"
newExtraContext
=
%
p
"
newExtraContext
.
get
(
)
)
;
if
(
oldExtraContext
!
=
newExtraContext
)
{
uint32_t
equalStructs
;
uint32_t
samePointerStructs
;
CaptureChange
(
oldExtraContext
-
>
AsGecko
(
)
newExtraContext
assumeDifferenceHint
&
equalStructs
&
samePointerStructs
)
;
if
(
!
(
mHintsHandledBySelf
&
nsChangeHint_ReconstructFrame
)
)
{
LOG_RESTYLE
(
"
setting
new
extra
style
context
"
)
;
aSelf
-
>
SetAdditionalStyleContext
(
contextIndex
newExtraContext
)
;
}
else
{
LOG_RESTYLE
(
"
not
setting
new
extra
style
context
since
we
'
ll
reframe
"
)
;
}
}
}
LOG_RESTYLE
(
"
returning
%
s
"
RestyleResultToString
(
result
)
.
get
(
)
)
;
return
result
;
}
void
ElementRestyler
:
:
RestyleChildren
(
nsRestyleHint
aChildRestyleHint
)
{
MOZ_ASSERT
(
!
(
mHintsHandledBySelf
&
nsChangeHint_ReconstructFrame
)
"
No
need
to
do
this
if
we
'
re
planning
to
reframe
already
.
"
)
;
bool
mightReframePseudos
=
aChildRestyleHint
&
eRestyle_Subtree
;
RestyleUndisplayedDescendants
(
aChildRestyleHint
)
;
if
(
!
(
mHintsHandledBySelf
&
nsChangeHint_ReconstructFrame
)
&
&
mightReframePseudos
)
{
MaybeReframeForBeforePseudo
(
)
;
}
nsIFrame
*
lastContinuation
;
if
(
!
(
mHintsHandledBySelf
&
nsChangeHint_ReconstructFrame
)
)
{
InitializeAccessibilityNotifications
(
mFrame
-
>
StyleContext
(
)
)
;
for
(
nsIFrame
*
f
=
mFrame
;
f
;
f
=
GetNextContinuationWithSameStyle
(
f
f
-
>
StyleContext
(
)
-
>
AsGecko
(
)
)
)
{
lastContinuation
=
f
;
RestyleContentChildren
(
f
aChildRestyleHint
)
;
}
SendAccessibilityNotifications
(
)
;
}
if
(
!
(
mHintsHandledBySelf
&
nsChangeHint_ReconstructFrame
)
&
&
mightReframePseudos
)
{
MaybeReframeForAfterPseudo
(
lastContinuation
)
;
}
}
void
ElementRestyler
:
:
RestyleChildrenOfDisplayContentsElement
(
nsIFrame
*
aParentFrame
GeckoStyleContext
*
aNewContext
nsChangeHint
aMinHint
RestyleTracker
&
aRestyleTracker
nsRestyleHint
aRestyleHint
const
RestyleHintData
&
aRestyleHintData
)
{
MOZ_ASSERT
(
!
(
mHintsHandledBySelf
&
nsChangeHint_ReconstructFrame
)
"
why
call
me
?
"
)
;
const
bool
mightReframePseudos
=
aRestyleHint
&
eRestyle_Subtree
;
DoRestyleUndisplayedDescendants
(
nsRestyleHint
(
0
)
mContent
aNewContext
)
;
if
(
!
(
mHintsHandledBySelf
&
nsChangeHint_ReconstructFrame
)
&
&
mightReframePseudos
)
{
MaybeReframeForPseudo
(
CSSPseudoElementType
:
:
before
aParentFrame
nullptr
mContent
aNewContext
)
;
}
if
(
!
(
mHintsHandledBySelf
&
nsChangeHint_ReconstructFrame
)
&
&
mightReframePseudos
)
{
MaybeReframeForPseudo
(
CSSPseudoElementType
:
:
after
aParentFrame
nullptr
mContent
aNewContext
)
;
}
if
(
!
(
mHintsHandledBySelf
&
nsChangeHint_ReconstructFrame
)
)
{
InitializeAccessibilityNotifications
(
aNewContext
)
;
nsIFrame
:
:
ChildListIterator
lists
(
aParentFrame
)
;
for
(
;
!
lists
.
IsDone
(
)
;
lists
.
Next
(
)
)
{
for
(
nsIFrame
*
f
:
lists
.
CurrentList
(
)
)
{
if
(
nsContentUtils
:
:
ContentIsDescendantOf
(
f
-
>
GetContent
(
)
mContent
)
&
&
!
f
-
>
GetPrevContinuation
(
)
)
{
if
(
!
(
f
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
)
{
ComputeStyleChangeFor
(
f
mChangeList
aMinHint
aRestyleTracker
aRestyleHint
aRestyleHintData
mContextsToClear
mSwappedStructOwners
)
;
}
}
}
}
}
if
(
!
(
mHintsHandledBySelf
&
nsChangeHint_ReconstructFrame
)
)
{
SendAccessibilityNotifications
(
)
;
}
}
void
ElementRestyler
:
:
ComputeStyleChangeFor
(
nsIFrame
*
aFrame
nsStyleChangeList
*
aChangeList
nsChangeHint
aMinChange
RestyleTracker
&
aRestyleTracker
nsRestyleHint
aRestyleHint
const
RestyleHintData
&
aRestyleHintData
nsTArray
<
ContextToClear
>
&
aContextsToClear
nsTArray
<
RefPtr
<
GeckoStyleContext
>
>
&
aSwappedStructOwners
)
{
AUTO_PROFILER_LABEL
(
"
ElementRestyler
:
:
ComputeStyleChangeFor
"
CSS
)
;
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
aMinChange
)
{
aChangeList
-
>
AppendChange
(
aFrame
content
aMinChange
)
;
}
NS_ASSERTION
(
!
aFrame
-
>
GetPrevContinuation
(
)
"
must
start
with
the
first
continuation
"
)
;
nsPresContext
*
presContext
=
aFrame
-
>
PresContext
(
)
;
TreeMatchContext
treeMatchContext
(
true
nsRuleWalker
:
:
eRelevantLinkUnvisited
presContext
-
>
Document
(
)
)
;
Element
*
parent
=
content
?
content
-
>
GetParentElementCrossingShadowRoot
(
)
:
nullptr
;
treeMatchContext
.
InitAncestors
(
parent
)
;
nsTArray
<
nsCSSSelector
*
>
selectorsForDescendants
;
selectorsForDescendants
.
AppendElements
(
aRestyleHintData
.
mSelectorsForDescendants
)
;
nsTArray
<
nsIContent
*
>
visibleKidsOfHiddenElement
;
nsIFrame
*
nextIBSibling
;
for
(
nsIFrame
*
ibSibling
=
aFrame
;
ibSibling
;
ibSibling
=
nextIBSibling
)
{
nextIBSibling
=
GetNextBlockInInlineSibling
(
ibSibling
)
;
if
(
nextIBSibling
)
{
aRestyleHint
|
=
eRestyle_Force
;
}
for
(
nsIFrame
*
cont
=
ibSibling
;
cont
;
cont
=
cont
-
>
GetNextContinuation
(
)
)
{
if
(
GetPrevContinuationWithSameStyle
(
cont
)
)
{
continue
;
}
ElementRestyler
restyler
(
presContext
cont
aChangeList
aMinChange
aRestyleTracker
selectorsForDescendants
treeMatchContext
visibleKidsOfHiddenElement
aContextsToClear
aSwappedStructOwners
)
;
restyler
.
Restyle
(
aRestyleHint
)
;
if
(
restyler
.
HintsHandledForFrame
(
)
&
nsChangeHint_ReconstructFrame
)
{
NS_ASSERTION
(
!
cont
-
>
GetPrevContinuation
(
)
"
continuing
frame
had
more
severe
impact
than
first
-
in
-
flow
"
)
;
return
;
}
}
}
}
void
ElementRestyler
:
:
RestyleUndisplayedDescendants
(
nsRestyleHint
aChildRestyleHint
)
{
nsIContent
*
undisplayedParent
;
if
(
MustCheckUndisplayedContent
(
mFrame
undisplayedParent
)
)
{
DoRestyleUndisplayedDescendants
(
aChildRestyleHint
undisplayedParent
mFrame
-
>
StyleContext
(
)
-
>
AsGecko
(
)
)
;
}
}
void
ElementRestyler
:
:
DoRestyleUndisplayedDescendants
(
nsRestyleHint
aChildRestyleHint
nsIContent
*
aParent
GeckoStyleContext
*
aParentContext
)
{
nsCSSFrameConstructor
*
fc
=
mPresContext
-
>
FrameConstructor
(
)
;
UndisplayedNode
*
nodes
=
fc
-
>
GetAllRegisteredDisplayNoneStylesIn
(
aParent
)
;
RestyleUndisplayedNodes
(
aChildRestyleHint
nodes
aParent
aParentContext
StyleDisplay
:
:
None
)
;
nodes
=
fc
-
>
GetAllRegisteredDisplayContentsStylesIn
(
aParent
)
;
RestyleUndisplayedNodes
(
aChildRestyleHint
nodes
aParent
aParentContext
StyleDisplay
:
:
Contents
)
;
}
void
ElementRestyler
:
:
RestyleUndisplayedNodes
(
nsRestyleHint
aChildRestyleHint
UndisplayedNode
*
aUndisplayed
nsIContent
*
aUndisplayedParent
GeckoStyleContext
*
aParentContext
const
StyleDisplay
aDisplay
)
{
nsIContent
*
undisplayedParent
=
aUndisplayedParent
;
UndisplayedNode
*
undisplayed
=
aUndisplayed
;
TreeMatchContext
:
:
AutoAncestorPusher
pusher
(
&
mTreeMatchContext
)
;
if
(
undisplayed
)
{
pusher
.
PushAncestorAndStyleScope
(
undisplayedParent
)
;
}
for
(
;
undisplayed
;
undisplayed
=
undisplayed
-
>
getNext
(
)
)
{
NS_ASSERTION
(
undisplayedParent
|
|
undisplayed
-
>
mContent
=
=
mPresContext
-
>
Document
(
)
-
>
GetRootElement
(
)
"
undisplayed
node
child
of
null
must
be
root
"
)
;
NS_ASSERTION
(
!
undisplayed
-
>
mStyle
-
>
GetPseudo
(
)
"
Shouldn
'
t
have
random
pseudo
style
contexts
in
the
"
"
undisplayed
map
"
)
;
LOG_RESTYLE
(
"
RestyleUndisplayedChildren
:
undisplayed
-
>
mContent
=
%
p
"
undisplayed
-
>
mContent
.
get
(
)
)
;
nsIContent
*
parent
=
undisplayed
-
>
mContent
-
>
GetParent
(
)
;
TreeMatchContext
:
:
AutoAncestorPusher
insertionPointPusher
(
&
mTreeMatchContext
)
;
if
(
parent
&
&
parent
-
>
IsActiveChildrenElement
(
)
)
{
insertionPointPusher
.
PushAncestorAndStyleScope
(
parent
)
;
}
nsRestyleHint
thisChildHint
=
aChildRestyleHint
;
nsAutoPtr
<
RestyleTracker
:
:
RestyleData
>
undisplayedRestyleData
;
Element
*
element
=
undisplayed
-
>
mContent
-
>
AsElement
(
)
;
if
(
mRestyleTracker
.
GetRestyleData
(
element
undisplayedRestyleData
)
)
{
thisChildHint
=
nsRestyleHint
(
thisChildHint
|
undisplayedRestyleData
-
>
mRestyleHint
)
;
}
RefPtr
<
GeckoStyleContext
>
undisplayedContext
;
nsStyleSet
*
styleSet
=
StyleSet
(
)
;
if
(
MustRestyleSelf
(
thisChildHint
element
)
)
{
undisplayedContext
=
styleSet
-
>
ResolveStyleFor
(
element
aParentContext
mTreeMatchContext
)
;
}
else
if
(
CanReparentStyleContext
(
thisChildHint
)
)
{
undisplayedContext
=
styleSet
-
>
ReparentStyleContext
(
undisplayed
-
>
mStyle
-
>
AsGecko
(
)
aParentContext
element
)
;
}
else
{
nsRestyleHint
rshint
=
thisChildHint
&
~
eRestyle_SomeDescendants
;
undisplayedContext
=
styleSet
-
>
ResolveStyleWithReplacement
(
element
nullptr
aParentContext
undisplayed
-
>
mStyle
-
>
AsGecko
(
)
rshint
)
;
}
const
nsStyleDisplay
*
display
=
undisplayedContext
-
>
StyleDisplay
(
)
;
if
(
display
-
>
mDisplay
!
=
aDisplay
)
{
NS_ASSERTION
(
element
"
Must
have
undisplayed
content
"
)
;
mChangeList
-
>
AppendChange
(
nullptr
element
nsChangeHint_ReconstructFrame
)
;
}
else
{
undisplayed
-
>
mStyle
=
undisplayedContext
;
if
(
aDisplay
=
=
StyleDisplay
:
:
Contents
)
{
DoRestyleUndisplayedDescendants
(
aChildRestyleHint
element
undisplayed
-
>
mStyle
-
>
AsGecko
(
)
)
;
}
}
}
}
void
ElementRestyler
:
:
MaybeReframeForBeforePseudo
(
)
{
MaybeReframeForPseudo
(
CSSPseudoElementType
:
:
before
mFrame
mFrame
mFrame
-
>
GetContent
(
)
mFrame
-
>
StyleContext
(
)
-
>
AsGecko
(
)
)
;
}
void
ElementRestyler
:
:
MaybeReframeForAfterPseudo
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
)
;
MaybeReframeForPseudo
(
CSSPseudoElementType
:
:
after
aFrame
aFrame
aFrame
-
>
GetContent
(
)
aFrame
-
>
StyleContext
(
)
-
>
AsGecko
(
)
)
;
}
#
ifdef
DEBUG
bool
ElementRestyler
:
:
MustReframeForBeforePseudo
(
)
{
return
MustReframeForPseudo
(
CSSPseudoElementType
:
:
before
mFrame
mFrame
mFrame
-
>
GetContent
(
)
mFrame
-
>
StyleContext
(
)
-
>
AsGecko
(
)
)
;
}
bool
ElementRestyler
:
:
MustReframeForAfterPseudo
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
)
;
return
MustReframeForPseudo
(
CSSPseudoElementType
:
:
after
aFrame
aFrame
aFrame
-
>
GetContent
(
)
aFrame
-
>
StyleContext
(
)
-
>
AsGecko
(
)
)
;
}
#
endif
void
ElementRestyler
:
:
MaybeReframeForPseudo
(
CSSPseudoElementType
aPseudoType
nsIFrame
*
aGenConParentFrame
nsIFrame
*
aFrame
nsIContent
*
aContent
GeckoStyleContext
*
aStyleContext
)
{
if
(
MustReframeForPseudo
(
aPseudoType
aGenConParentFrame
aFrame
aContent
aStyleContext
)
)
{
LOG_RESTYLE
(
"
MaybeReframeForPseudo
appending
"
"
nsChangeHint_ReconstructFrame
"
)
;
mHintsHandledBySelf
|
=
nsChangeHint_ReconstructFrame
;
mChangeList
-
>
AppendChange
(
aFrame
aContent
nsChangeHint_ReconstructFrame
)
;
}
}
bool
ElementRestyler
:
:
MustReframeForPseudo
(
CSSPseudoElementType
aPseudoType
nsIFrame
*
aGenConParentFrame
nsIFrame
*
aFrame
nsIContent
*
aContent
GeckoStyleContext
*
aStyleContext
)
{
MOZ_ASSERT
(
aPseudoType
=
=
CSSPseudoElementType
:
:
before
|
|
aPseudoType
=
=
CSSPseudoElementType
:
:
after
)
;
if
(
aStyleContext
-
>
GetPseudo
(
)
)
{
return
false
;
}
if
(
!
(
aGenConParentFrame
-
>
GetStateBits
(
)
&
NS_FRAME_MAY_HAVE_GENERATED_CONTENT
)
)
{
nsContainerFrame
*
cif
=
aGenConParentFrame
-
>
GetContentInsertionFrame
(
)
;
if
(
!
cif
|
|
!
(
cif
-
>
GetStateBits
(
)
&
NS_FRAME_MAY_HAVE_GENERATED_CONTENT
)
)
{
return
false
;
}
}
if
(
aPseudoType
=
=
CSSPseudoElementType
:
:
before
)
{
if
(
(
aFrame
&
&
!
nsLayoutUtils
:
:
IsFirstContinuationOrIBSplitSibling
(
aFrame
)
)
|
|
nsLayoutUtils
:
:
GetBeforeFrame
(
aContent
)
)
{
return
false
;
}
}
else
{
if
(
(
aFrame
&
&
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
aFrame
)
)
|
|
nsLayoutUtils
:
:
GetAfterFrame
(
aContent
)
)
{
return
false
;
}
}
return
nsLayoutUtils
:
:
HasPseudoStyle
(
aContent
aStyleContext
aPseudoType
mPresContext
)
;
}
void
ElementRestyler
:
:
InitializeAccessibilityNotifications
(
nsStyleContext
*
aNewContext
)
{
#
ifdef
ACCESSIBILITY
if
(
nsIPresShell
:
:
IsAccessibilityActive
(
)
&
&
(
!
mFrame
|
|
(
!
mFrame
-
>
GetPrevContinuation
(
)
&
&
!
mFrame
-
>
FrameIsNonFirstInIBSplit
(
)
)
)
)
{
if
(
mDesiredA11yNotifications
=
=
eSendAllNotifications
)
{
bool
isFrameVisible
=
aNewContext
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
;
if
(
isFrameVisible
!
=
mWasFrameVisible
)
{
if
(
isFrameVisible
)
{
mKidsDesiredA11yNotifications
=
eSkipNotifications
;
mOurA11yNotification
=
eNotifyShown
;
}
else
{
mKidsDesiredA11yNotifications
=
eNotifyIfShown
;
mOurA11yNotification
=
eNotifyHidden
;
}
}
}
else
if
(
mDesiredA11yNotifications
=
=
eNotifyIfShown
&
&
aNewContext
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
)
{
nsIContent
*
c
=
mFrame
?
mFrame
-
>
GetContent
(
)
:
mContent
;
mVisibleKidsOfHiddenElement
.
AppendElement
(
c
)
;
mKidsDesiredA11yNotifications
=
eSkipNotifications
;
}
}
#
endif
}
void
ElementRestyler
:
:
RestyleContentChildren
(
nsIFrame
*
aParent
nsRestyleHint
aChildRestyleHint
)
{
LOG_RESTYLE
(
"
RestyleContentChildren
"
)
;
nsIFrame
:
:
ChildListIterator
lists
(
aParent
)
;
TreeMatchContext
:
:
AutoAncestorPusher
ancestorPusher
(
&
mTreeMatchContext
)
;
if
(
!
lists
.
IsDone
(
)
)
{
ancestorPusher
.
PushAncestorAndStyleScope
(
mContent
)
;
}
for
(
;
!
lists
.
IsDone
(
)
;
lists
.
Next
(
)
)
{
for
(
nsIFrame
*
child
:
lists
.
CurrentList
(
)
)
{
if
(
!
(
child
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
&
&
!
GetPrevContinuationWithSameStyle
(
child
)
)
{
nsIContent
*
parent
=
child
-
>
GetContent
(
)
?
child
-
>
GetContent
(
)
-
>
GetParent
(
)
:
nullptr
;
TreeMatchContext
:
:
AutoAncestorPusher
insertionPointPusher
(
&
mTreeMatchContext
)
;
if
(
parent
&
&
parent
-
>
IsActiveChildrenElement
(
)
)
{
insertionPointPusher
.
PushAncestorAndStyleScope
(
parent
)
;
}
if
(
child
-
>
IsPlaceholderFrame
(
)
)
{
nsIFrame
*
outOfFlowFrame
=
nsPlaceholderFrame
:
:
GetRealFrameForPlaceholder
(
child
)
;
NS_ASSERTION
(
outOfFlowFrame
"
no
out
-
of
-
flow
frame
"
)
;
NS_ASSERTION
(
outOfFlowFrame
!
=
mResolvedChild
"
out
-
of
-
flow
frame
not
a
true
descendant
"
)
;
do
{
if
(
GetPrevContinuationWithSameStyle
(
outOfFlowFrame
)
)
{
continue
;
}
ElementRestyler
oofRestyler
(
*
this
outOfFlowFrame
FOR_OUT_OF_FLOW_CHILD
)
;
oofRestyler
.
Restyle
(
aChildRestyleHint
)
;
}
while
(
(
outOfFlowFrame
=
outOfFlowFrame
-
>
GetNextContinuation
(
)
)
)
;
ElementRestyler
phRestyler
(
*
this
child
0
)
;
phRestyler
.
Restyle
(
aChildRestyleHint
)
;
}
else
{
if
(
child
!
=
mResolvedChild
)
{
ElementRestyler
childRestyler
(
*
this
child
0
)
;
childRestyler
.
Restyle
(
aChildRestyleHint
)
;
}
}
}
}
}
}
void
ElementRestyler
:
:
SendAccessibilityNotifications
(
)
{
#
ifdef
ACCESSIBILITY
if
(
mOurA11yNotification
=
=
eNotifyShown
)
{
nsAccessibilityService
*
accService
=
nsIPresShell
:
:
AccService
(
)
;
if
(
accService
)
{
nsIPresShell
*
presShell
=
mPresContext
-
>
GetPresShell
(
)
;
nsIContent
*
content
=
mFrame
?
mFrame
-
>
GetContent
(
)
:
mContent
;
accService
-
>
ContentRangeInserted
(
presShell
content
-
>
GetParent
(
)
content
content
-
>
GetNextSibling
(
)
)
;
}
}
else
if
(
mOurA11yNotification
=
=
eNotifyHidden
)
{
nsAccessibilityService
*
accService
=
nsIPresShell
:
:
AccService
(
)
;
if
(
accService
)
{
nsIPresShell
*
presShell
=
mPresContext
-
>
GetPresShell
(
)
;
nsIContent
*
content
=
mFrame
?
mFrame
-
>
GetContent
(
)
:
mContent
;
accService
-
>
ContentRemoved
(
presShell
content
)
;
uint32_t
visibleContentCount
=
mVisibleKidsOfHiddenElement
.
Length
(
)
;
for
(
uint32_t
idx
=
0
;
idx
<
visibleContentCount
;
idx
+
+
)
{
nsIContent
*
childContent
=
mVisibleKidsOfHiddenElement
[
idx
]
;
accService
-
>
ContentRangeInserted
(
presShell
childContent
-
>
GetParent
(
)
childContent
childContent
-
>
GetNextSibling
(
)
)
;
}
mVisibleKidsOfHiddenElement
.
Clear
(
)
;
}
}
#
endif
}
static
void
ClearCachedInheritedStyleDataOnDescendants
(
nsTArray
<
ElementRestyler
:
:
ContextToClear
>
&
aContextsToClear
)
{
for
(
size_t
i
=
0
;
i
<
aContextsToClear
.
Length
(
)
;
i
+
+
)
{
auto
&
entry
=
aContextsToClear
[
i
]
;
if
(
!
entry
.
mStyleContext
-
>
HasSingleReference
(
)
)
{
entry
.
mStyleContext
-
>
AsGecko
(
)
-
>
ClearCachedInheritedStyleDataOnDescendants
(
entry
.
mStructs
)
;
}
entry
.
mStyleContext
=
nullptr
;
}
}
void
GeckoRestyleManager
:
:
ComputeAndProcessStyleChange
(
nsIFrame
*
aFrame
nsChangeHint
aMinChange
RestyleTracker
&
aRestyleTracker
nsRestyleHint
aRestyleHint
const
RestyleHintData
&
aRestyleHintData
)
{
MOZ_ASSERT
(
mReframingStyleContexts
"
should
have
rsc
"
)
;
nsStyleChangeList
changeList
(
StyleBackendType
:
:
Gecko
)
;
nsTArray
<
ElementRestyler
:
:
ContextToClear
>
contextsToClear
;
nsTArray
<
RefPtr
<
GeckoStyleContext
>
>
swappedStructOwners
;
ElementRestyler
:
:
ComputeStyleChangeFor
(
aFrame
&
changeList
aMinChange
aRestyleTracker
aRestyleHint
aRestyleHintData
contextsToClear
swappedStructOwners
)
;
ProcessRestyledFrames
(
changeList
)
;
ClearCachedInheritedStyleDataOnDescendants
(
contextsToClear
)
;
}
void
GeckoRestyleManager
:
:
ComputeAndProcessStyleChange
(
GeckoStyleContext
*
aNewContext
Element
*
aElement
nsChangeHint
aMinChange
RestyleTracker
&
aRestyleTracker
nsRestyleHint
aRestyleHint
const
RestyleHintData
&
aRestyleHintData
)
{
MOZ_ASSERT
(
mReframingStyleContexts
"
should
have
rsc
"
)
;
MOZ_ASSERT
(
aNewContext
-
>
StyleDisplay
(
)
-
>
mDisplay
=
=
StyleDisplay
:
:
Contents
)
;
nsIFrame
*
frame
=
GetNearestAncestorFrame
(
aElement
)
;
MOZ_ASSERT
(
frame
"
display
:
contents
node
in
map
although
it
'
s
a
"
"
display
:
none
descendant
?
"
)
;
TreeMatchContext
treeMatchContext
(
true
nsRuleWalker
:
:
eRelevantLinkUnvisited
frame
-
>
PresContext
(
)
-
>
Document
(
)
)
;
nsIContent
*
parent
=
aElement
-
>
GetParent
(
)
;
Element
*
parentElement
=
parent
&
&
parent
-
>
IsElement
(
)
?
parent
-
>
AsElement
(
)
:
nullptr
;
treeMatchContext
.
InitAncestors
(
parentElement
)
;
nsTArray
<
nsCSSSelector
*
>
selectorsForDescendants
;
nsTArray
<
nsIContent
*
>
visibleKidsOfHiddenElement
;
nsTArray
<
ElementRestyler
:
:
ContextToClear
>
contextsToClear
;
nsTArray
<
RefPtr
<
GeckoStyleContext
>
>
swappedStructOwners
;
nsStyleChangeList
changeList
(
StyleBackendType
:
:
Gecko
)
;
ElementRestyler
r
(
frame
-
>
PresContext
(
)
aElement
&
changeList
aMinChange
aRestyleTracker
selectorsForDescendants
treeMatchContext
visibleKidsOfHiddenElement
contextsToClear
swappedStructOwners
)
;
r
.
RestyleChildrenOfDisplayContentsElement
(
frame
aNewContext
aMinChange
aRestyleTracker
aRestyleHint
aRestyleHintData
)
;
ProcessRestyledFrames
(
changeList
)
;
ClearCachedInheritedStyleDataOnDescendants
(
contextsToClear
)
;
}
bool
GeckoRestyleManager
:
:
HasPendingRestyles
(
)
const
{
return
mPendingRestyles
.
Count
(
)
!
=
0
;
}
nsStyleSet
*
ElementRestyler
:
:
StyleSet
(
)
const
{
MOZ_ASSERT
(
mPresContext
-
>
StyleSet
(
)
-
>
IsGecko
(
)
"
ElementRestyler
should
only
be
used
with
a
Gecko
-
flavored
"
"
style
backend
"
)
;
return
mPresContext
-
>
StyleSet
(
)
-
>
AsGecko
(
)
;
}
AutoDisplayContentsAncestorPusher
:
:
AutoDisplayContentsAncestorPusher
(
TreeMatchContext
&
aTreeMatchContext
nsPresContext
*
aPresContext
nsIContent
*
aParent
)
:
mTreeMatchContext
(
aTreeMatchContext
)
mPresContext
(
aPresContext
)
{
if
(
aParent
)
{
nsFrameManager
*
fm
=
mPresContext
-
>
FrameManager
(
)
;
for
(
nsIContent
*
p
=
aParent
;
p
&
&
fm
-
>
GetDisplayContentsStyleFor
(
p
)
;
p
=
p
-
>
GetParent
(
)
)
{
mAncestors
.
AppendElement
(
p
-
>
AsElement
(
)
)
;
}
bool
hasFilter
=
mTreeMatchContext
.
mAncestorFilter
.
HasFilter
(
)
;
nsTArray
<
mozilla
:
:
dom
:
:
Element
*
>
:
:
size_type
i
=
mAncestors
.
Length
(
)
;
while
(
i
-
-
)
{
if
(
hasFilter
)
{
mTreeMatchContext
.
mAncestorFilter
.
PushAncestor
(
mAncestors
[
i
]
)
;
}
mTreeMatchContext
.
PushStyleScope
(
mAncestors
[
i
]
)
;
}
}
}
AutoDisplayContentsAncestorPusher
:
:
~
AutoDisplayContentsAncestorPusher
(
)
{
typedef
nsTArray
<
mozilla
:
:
dom
:
:
Element
*
>
:
:
size_type
sz
;
sz
len
=
mAncestors
.
Length
(
)
;
bool
hasFilter
=
mTreeMatchContext
.
mAncestorFilter
.
HasFilter
(
)
;
for
(
sz
i
=
0
;
i
<
len
;
+
+
i
)
{
if
(
hasFilter
)
{
mTreeMatchContext
.
mAncestorFilter
.
PopAncestor
(
)
;
}
mTreeMatchContext
.
PopStyleScope
(
mAncestors
[
i
]
)
;
}
}
#
ifdef
RESTYLE_LOGGING
uint32_t
GeckoRestyleManager
:
:
StructsToLog
(
)
{
static
bool
initialized
=
false
;
static
uint32_t
structs
;
if
(
!
initialized
)
{
structs
=
0
;
const
char
*
value
=
getenv
(
"
MOZ_DEBUG_RESTYLE_STRUCTS
"
)
;
if
(
value
)
{
nsCString
s
(
value
)
;
while
(
!
s
.
IsEmpty
(
)
)
{
int32_t
index
=
s
.
FindChar
(
'
'
)
;
nsStyleStructID
sid
;
bool
found
;
if
(
index
=
=
-
1
)
{
found
=
GeckoStyleContext
:
:
LookupStruct
(
s
sid
)
;
s
.
Truncate
(
)
;
}
else
{
found
=
nsStyleContext
:
:
LookupStruct
(
Substring
(
s
0
index
)
sid
)
;
s
=
Substring
(
s
index
+
1
)
;
}
if
(
found
)
{
structs
|
=
nsCachedStyleData
:
:
GetBitForSID
(
sid
)
;
}
}
}
initialized
=
true
;
}
return
structs
;
}
#
endif
#
ifdef
DEBUG
nsCString
GeckoRestyleManager
:
:
StructNamesToString
(
uint32_t
aSIDs
)
{
nsCString
result
;
bool
any
=
false
;
for
(
nsStyleStructID
sid
=
nsStyleStructID
(
0
)
;
sid
<
nsStyleStructID_Length
;
sid
=
nsStyleStructID
(
sid
+
1
)
)
{
if
(
aSIDs
&
nsCachedStyleData
:
:
GetBitForSID
(
sid
)
)
{
if
(
any
)
{
result
.
AppendLiteral
(
"
"
)
;
}
result
.
AppendPrintf
(
"
%
s
"
nsStyleContext
:
:
StructName
(
sid
)
)
;
any
=
true
;
}
}
return
result
;
}
nsCString
ElementRestyler
:
:
RestyleResultToString
(
RestyleResult
aRestyleResult
)
{
nsCString
result
;
switch
(
aRestyleResult
)
{
case
RestyleResult
:
:
eStop
:
result
.
AssignLiteral
(
"
RestyleResult
:
:
eStop
"
)
;
break
;
case
RestyleResult
:
:
eStopWithStyleChange
:
result
.
AssignLiteral
(
"
RestyleResult
:
:
eStopWithStyleChange
"
)
;
break
;
case
RestyleResult
:
:
eContinue
:
result
.
AssignLiteral
(
"
RestyleResult
:
:
eContinue
"
)
;
break
;
case
RestyleResult
:
:
eContinueAndForceDescendants
:
result
.
AssignLiteral
(
"
RestyleResult
:
:
eContinueAndForceDescendants
"
)
;
break
;
default
:
MOZ_ASSERT
(
aRestyleResult
=
=
RestyleResult
:
:
eNone
"
Unexpected
RestyleResult
"
)
;
}
return
result
;
}
#
endif
}
