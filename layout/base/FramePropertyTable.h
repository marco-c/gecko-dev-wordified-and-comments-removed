#
ifndef
FRAMEPROPERTYTABLE_H_
#
define
FRAMEPROPERTYTABLE_H_
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
TypeTraits
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
nsHashKeys
.
h
"
class
nsIFrame
;
namespace
mozilla
{
struct
FramePropertyDescriptorUntyped
{
typedef
void
UntypedDestructor
(
void
*
aPropertyValue
)
;
UntypedDestructor
*
mDestructor
;
typedef
void
UntypedDestructorWithFrame
(
const
nsIFrame
*
aFrame
void
*
aPropertyValue
)
;
UntypedDestructorWithFrame
*
mDestructorWithFrame
;
protected
:
constexpr
FramePropertyDescriptorUntyped
(
UntypedDestructor
*
aDtor
UntypedDestructorWithFrame
*
aDtorWithFrame
)
:
mDestructor
(
aDtor
)
mDestructorWithFrame
(
aDtorWithFrame
)
{
}
}
;
template
<
typename
T
>
struct
FramePropertyDescriptor
:
public
FramePropertyDescriptorUntyped
{
typedef
void
Destructor
(
T
*
aPropertyValue
)
;
typedef
void
DestructorWithFrame
(
const
nsIFrame
*
aaFrame
T
*
aPropertyValue
)
;
template
<
Destructor
Dtor
>
static
constexpr
const
FramePropertyDescriptor
<
T
>
NewWithDestructor
(
)
{
return
{
Destruct
<
Dtor
>
nullptr
}
;
}
template
<
DestructorWithFrame
Dtor
>
static
constexpr
const
FramePropertyDescriptor
<
T
>
NewWithDestructorWithFrame
(
)
{
return
{
nullptr
DestructWithFrame
<
Dtor
>
}
;
}
static
constexpr
const
FramePropertyDescriptor
<
T
>
NewWithoutDestructor
(
)
{
return
{
nullptr
nullptr
}
;
}
private
:
constexpr
FramePropertyDescriptor
(
UntypedDestructor
*
aDtor
UntypedDestructorWithFrame
*
aDtorWithFrame
)
:
FramePropertyDescriptorUntyped
(
aDtor
aDtorWithFrame
)
{
}
template
<
Destructor
Dtor
>
static
void
Destruct
(
void
*
aPropertyValue
)
{
Dtor
(
static_cast
<
T
*
>
(
aPropertyValue
)
)
;
}
template
<
DestructorWithFrame
Dtor
>
static
void
DestructWithFrame
(
const
nsIFrame
*
aFrame
void
*
aPropertyValue
)
{
Dtor
(
aFrame
static_cast
<
T
*
>
(
aPropertyValue
)
)
;
}
}
;
template
<
typename
T
>
class
SmallValueHolder
;
namespace
detail
{
template
<
typename
T
>
struct
FramePropertyTypeHelper
{
typedef
T
*
Type
;
}
;
template
<
typename
T
>
struct
FramePropertyTypeHelper
<
SmallValueHolder
<
T
>
>
{
typedef
T
Type
;
}
;
}
class
FramePropertyTable
{
public
:
template
<
typename
T
>
using
Descriptor
=
const
FramePropertyDescriptor
<
T
>
*
;
using
UntypedDescriptor
=
const
FramePropertyDescriptorUntyped
*
;
template
<
typename
T
>
using
PropertyType
=
typename
detail
:
:
FramePropertyTypeHelper
<
T
>
:
:
Type
;
FramePropertyTable
(
)
:
mLastFrame
(
nullptr
)
mLastEntry
(
nullptr
)
{
}
~
FramePropertyTable
(
)
{
DeleteAll
(
)
;
}
template
<
typename
T
>
void
Set
(
nsIFrame
*
aFrame
Descriptor
<
T
>
aProperty
PropertyType
<
T
>
aValue
)
{
void
*
ptr
=
ReinterpretHelper
<
T
>
:
:
ToPointer
(
aValue
)
;
SetInternal
(
aFrame
aProperty
ptr
)
;
}
template
<
typename
T
>
bool
Has
(
const
nsIFrame
*
aFrame
Descriptor
<
T
>
aProperty
)
{
bool
foundResult
=
false
;
mozilla
:
:
Unused
<
<
GetInternal
(
aFrame
aProperty
false
&
foundResult
)
;
return
foundResult
;
}
template
<
typename
T
>
bool
HasSkippingBitCheck
(
const
nsIFrame
*
aFrame
Descriptor
<
T
>
aProperty
)
{
bool
foundResult
=
false
;
mozilla
:
:
Unused
<
<
GetInternal
(
aFrame
aProperty
true
&
foundResult
)
;
return
foundResult
;
}
template
<
typename
T
>
PropertyType
<
T
>
Get
(
const
nsIFrame
*
aFrame
Descriptor
<
T
>
aProperty
bool
*
aFoundResult
=
nullptr
)
{
void
*
ptr
=
GetInternal
(
aFrame
aProperty
false
aFoundResult
)
;
return
ReinterpretHelper
<
T
>
:
:
FromPointer
(
ptr
)
;
}
template
<
typename
T
>
PropertyType
<
T
>
Remove
(
nsIFrame
*
aFrame
Descriptor
<
T
>
aProperty
bool
*
aFoundResult
=
nullptr
)
{
void
*
ptr
=
RemoveInternal
(
aFrame
aProperty
aFoundResult
)
;
return
ReinterpretHelper
<
T
>
:
:
FromPointer
(
ptr
)
;
}
template
<
typename
T
>
void
Delete
(
nsIFrame
*
aFrame
Descriptor
<
T
>
aProperty
)
{
DeleteInternal
(
aFrame
aProperty
)
;
}
void
DeleteAllFor
(
nsIFrame
*
aFrame
)
;
void
DeleteAll
(
)
;
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
protected
:
void
SetInternal
(
nsIFrame
*
aFrame
UntypedDescriptor
aProperty
void
*
aValue
)
;
void
*
GetInternal
(
const
nsIFrame
*
aFrame
UntypedDescriptor
aProperty
bool
aSkipBitCheck
bool
*
aFoundResult
)
;
void
*
RemoveInternal
(
nsIFrame
*
aFrame
UntypedDescriptor
aProperty
bool
*
aFoundResult
)
;
void
DeleteInternal
(
nsIFrame
*
aFrame
UntypedDescriptor
aProperty
)
;
template
<
typename
T
>
struct
ReinterpretHelper
{
static_assert
(
sizeof
(
PropertyType
<
T
>
)
<
=
sizeof
(
void
*
)
"
size
of
the
value
must
never
be
larger
than
a
pointer
"
)
;
static
void
*
ToPointer
(
PropertyType
<
T
>
aValue
)
{
void
*
ptr
=
nullptr
;
memcpy
(
&
ptr
&
aValue
sizeof
(
aValue
)
)
;
return
ptr
;
}
static
PropertyType
<
T
>
FromPointer
(
void
*
aPtr
)
{
PropertyType
<
T
>
value
;
memcpy
(
&
value
&
aPtr
sizeof
(
value
)
)
;
return
value
;
}
}
;
template
<
typename
T
>
struct
ReinterpretHelper
<
T
*
>
{
static
void
*
ToPointer
(
T
*
aValue
)
{
return
static_cast
<
void
*
>
(
aValue
)
;
}
static
T
*
FromPointer
(
void
*
aPtr
)
{
return
static_cast
<
T
*
>
(
aPtr
)
;
}
}
;
struct
PropertyValue
{
PropertyValue
(
)
:
mProperty
(
nullptr
)
mValue
(
nullptr
)
{
}
PropertyValue
(
UntypedDescriptor
aProperty
void
*
aValue
)
:
mProperty
(
aProperty
)
mValue
(
aValue
)
{
}
bool
IsArray
(
)
{
return
!
mProperty
&
&
mValue
;
}
nsTArray
<
PropertyValue
>
*
ToArray
(
)
{
NS_ASSERTION
(
IsArray
(
)
"
Must
be
array
"
)
;
return
reinterpret_cast
<
nsTArray
<
PropertyValue
>
*
>
(
&
mValue
)
;
}
void
DestroyValueFor
(
const
nsIFrame
*
aFrame
)
{
if
(
mProperty
-
>
mDestructor
)
{
mProperty
-
>
mDestructor
(
mValue
)
;
}
else
if
(
mProperty
-
>
mDestructorWithFrame
)
{
mProperty
-
>
mDestructorWithFrame
(
aFrame
mValue
)
;
}
}
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
{
size_t
n
=
0
;
if
(
IsArray
(
)
)
{
nsTArray
<
PropertyValue
>
*
array
=
ToArray
(
)
;
n
+
=
array
-
>
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
}
return
n
;
}
UntypedDescriptor
mProperty
;
void
*
mValue
;
}
;
class
PropertyComparator
{
public
:
bool
Equals
(
const
PropertyValue
&
a
const
PropertyValue
&
b
)
const
{
return
a
.
mProperty
=
=
b
.
mProperty
;
}
bool
Equals
(
UntypedDescriptor
a
const
PropertyValue
&
b
)
const
{
return
a
=
=
b
.
mProperty
;
}
bool
Equals
(
const
PropertyValue
&
a
UntypedDescriptor
b
)
const
{
return
a
.
mProperty
=
=
b
;
}
}
;
class
Entry
:
public
nsPtrHashKey
<
const
nsIFrame
>
{
public
:
explicit
Entry
(
KeyTypePointer
aKey
)
:
nsPtrHashKey
<
const
nsIFrame
>
(
aKey
)
{
}
Entry
(
const
Entry
&
toCopy
)
:
nsPtrHashKey
<
const
nsIFrame
>
(
toCopy
)
mProp
(
toCopy
.
mProp
)
{
}
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
{
return
mProp
.
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
PropertyValue
mProp
;
}
;
static
void
DeleteAllForEntry
(
Entry
*
aEntry
)
;
nsTHashtable
<
Entry
>
mEntries
;
const
nsIFrame
*
mLastFrame
;
Entry
*
mLastEntry
;
}
;
template
<
class
CVnsIFrame
>
class
FramePropertiesBase
{
public
:
template
<
typename
T
>
using
Descriptor
=
FramePropertyTable
:
:
Descriptor
<
T
>
;
template
<
typename
T
>
using
PropertyType
=
FramePropertyTable
:
:
PropertyType
<
T
>
;
template
<
typename
T
>
bool
Has
(
Descriptor
<
T
>
aProperty
)
const
{
return
mTable
-
>
Has
(
mFrame
aProperty
)
;
}
template
<
typename
T
>
PropertyType
<
T
>
Get
(
Descriptor
<
T
>
aProperty
bool
*
aFoundResult
=
nullptr
)
const
{
return
mTable
-
>
Get
(
mFrame
aProperty
aFoundResult
)
;
}
protected
:
FramePropertiesBase
(
FramePropertyTable
*
aTable
CVnsIFrame
*
aFrame
)
:
mTable
(
aTable
)
mFrame
(
aFrame
)
{
}
FramePropertyTable
*
const
mTable
;
CVnsIFrame
*
const
mFrame
;
}
;
class
ConstFrameProperties
:
public
FramePropertiesBase
<
const
nsIFrame
>
{
public
:
ConstFrameProperties
(
FramePropertyTable
*
aTable
const
nsIFrame
*
aFrame
)
:
FramePropertiesBase
(
aTable
aFrame
)
{
}
}
;
class
FrameProperties
:
public
FramePropertiesBase
<
nsIFrame
>
{
public
:
FrameProperties
(
FramePropertyTable
*
aTable
nsIFrame
*
aFrame
)
:
FramePropertiesBase
(
aTable
aFrame
)
{
}
template
<
typename
T
>
void
Set
(
Descriptor
<
T
>
aProperty
PropertyType
<
T
>
aValue
)
const
{
mTable
-
>
Set
(
mFrame
aProperty
aValue
)
;
}
template
<
typename
T
>
PropertyType
<
T
>
Remove
(
Descriptor
<
T
>
aProperty
bool
*
aFoundResult
=
nullptr
)
const
{
return
mTable
-
>
Remove
(
mFrame
aProperty
aFoundResult
)
;
}
template
<
typename
T
>
void
Delete
(
Descriptor
<
T
>
aProperty
)
const
{
mTable
-
>
Delete
(
mFrame
aProperty
)
;
}
}
;
}
#
endif
