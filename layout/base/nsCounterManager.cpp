#
include
"
nsCounterManager
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
WritingModes
.
h
"
#
include
"
nsBulletFrame
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
using
namespace
mozilla
;
bool
nsCounterUseNode
:
:
InitTextFrame
(
nsGenConList
*
aList
nsIFrame
*
aPseudoFrame
nsIFrame
*
aTextFrame
)
{
nsCounterNode
:
:
InitTextFrame
(
aList
aPseudoFrame
aTextFrame
)
;
nsCounterList
*
counterList
=
static_cast
<
nsCounterList
*
>
(
aList
)
;
counterList
-
>
Insert
(
this
)
;
aPseudoFrame
-
>
AddStateBits
(
NS_FRAME_HAS_CSS_COUNTER_STYLE
)
;
bool
dirty
=
counterList
-
>
IsDirty
(
)
;
if
(
!
dirty
)
{
if
(
counterList
-
>
IsLast
(
this
)
)
{
Calc
(
counterList
)
;
nsAutoString
contentString
;
GetText
(
contentString
)
;
aTextFrame
-
>
GetContent
(
)
-
>
AsText
(
)
-
>
SetText
(
contentString
false
)
;
}
else
{
counterList
-
>
SetDirty
(
)
;
return
true
;
}
}
return
false
;
}
void
nsCounterUseNode
:
:
Calc
(
nsCounterList
*
aList
)
{
NS_ASSERTION
(
!
aList
-
>
IsDirty
(
)
"
Why
are
we
calculating
with
a
dirty
list
?
"
)
;
mValueAfter
=
nsCounterList
:
:
ValueBefore
(
this
)
;
}
void
nsCounterChangeNode
:
:
Calc
(
nsCounterList
*
aList
)
{
NS_ASSERTION
(
!
aList
-
>
IsDirty
(
)
"
Why
are
we
calculating
with
a
dirty
list
?
"
)
;
if
(
IsContentBasedReset
(
)
)
{
}
else
if
(
mType
=
=
RESET
|
|
mType
=
=
SET
)
{
mValueAfter
=
mChangeValue
;
}
else
{
NS_ASSERTION
(
mType
=
=
INCREMENT
"
invalid
type
"
)
;
mValueAfter
=
nsCounterManager
:
:
IncrementCounter
(
nsCounterList
:
:
ValueBefore
(
this
)
mChangeValue
)
;
}
}
void
nsCounterUseNode
:
:
GetText
(
nsString
&
aResult
)
{
aResult
.
Truncate
(
)
;
AutoTArray
<
nsCounterNode
*
8
>
stack
;
stack
.
AppendElement
(
static_cast
<
nsCounterNode
*
>
(
this
)
)
;
if
(
mAllCounters
&
&
mScopeStart
)
{
for
(
nsCounterNode
*
n
=
mScopeStart
;
n
-
>
mScopePrev
;
n
=
n
-
>
mScopeStart
)
{
stack
.
AppendElement
(
n
-
>
mScopePrev
)
;
}
}
WritingMode
wm
=
mPseudoFrame
-
>
GetWritingMode
(
)
;
CounterStyle
*
style
=
mPseudoFrame
-
>
PresContext
(
)
-
>
CounterStyleManager
(
)
-
>
ResolveCounterStyle
(
mCounterStyle
)
;
for
(
uint32_t
i
=
stack
.
Length
(
)
-
1
;
;
-
-
i
)
{
nsCounterNode
*
n
=
stack
[
i
]
;
nsAutoString
text
;
bool
isTextRTL
;
style
-
>
GetCounterText
(
n
-
>
mValueAfter
wm
text
isTextRTL
)
;
aResult
.
Append
(
text
)
;
if
(
i
=
=
0
)
{
break
;
}
aResult
.
Append
(
mSeparator
)
;
}
}
void
nsCounterList
:
:
SetScope
(
nsCounterNode
*
aNode
)
{
if
(
aNode
=
=
First
(
)
)
{
aNode
-
>
mScopeStart
=
nullptr
;
aNode
-
>
mScopePrev
=
nullptr
;
return
;
}
nsIContent
*
nodeContent
=
aNode
-
>
mPseudoFrame
-
>
GetContent
(
)
-
>
GetParent
(
)
;
for
(
nsCounterNode
*
prev
=
Prev
(
aNode
)
*
start
;
prev
;
prev
=
start
-
>
mScopePrev
)
{
start
=
(
prev
-
>
mType
=
=
nsCounterNode
:
:
RESET
|
|
!
prev
-
>
mScopeStart
)
?
prev
:
prev
-
>
mScopeStart
;
nsIContent
*
startContent
=
start
-
>
mPseudoFrame
-
>
GetContent
(
)
-
>
GetParent
(
)
;
NS_ASSERTION
(
nodeContent
|
|
!
startContent
"
null
check
on
startContent
should
be
sufficient
to
"
"
null
check
nodeContent
as
well
since
if
nodeContent
"
"
is
for
the
root
startContent
(
which
is
before
it
)
"
"
must
be
too
"
)
;
if
(
!
(
aNode
-
>
mType
=
=
nsCounterNode
:
:
RESET
&
&
nodeContent
=
=
startContent
)
&
&
(
!
startContent
|
|
nsContentUtils
:
:
ContentIsDescendantOf
(
nodeContent
startContent
)
)
)
{
aNode
-
>
mScopeStart
=
start
;
aNode
-
>
mScopePrev
=
prev
;
return
;
}
}
aNode
-
>
mScopeStart
=
nullptr
;
aNode
-
>
mScopePrev
=
nullptr
;
}
void
nsCounterList
:
:
RecalcAll
(
)
{
mDirty
=
false
;
for
(
nsCounterNode
*
node
=
First
(
)
;
node
;
node
=
Next
(
node
)
)
{
SetScope
(
node
)
;
if
(
node
-
>
IsContentBasedReset
(
)
)
{
node
-
>
mValueAfter
=
1
;
}
else
if
(
(
node
-
>
mType
=
=
nsCounterChangeNode
:
:
INCREMENT
|
|
node
-
>
mType
=
=
nsCounterChangeNode
:
:
SET
)
&
&
node
-
>
mScopeStart
&
&
node
-
>
mScopeStart
-
>
IsContentBasedReset
(
)
)
{
+
+
node
-
>
mScopeStart
-
>
mValueAfter
;
}
}
for
(
nsCounterNode
*
node
=
First
(
)
;
node
;
node
=
Next
(
node
)
)
{
auto
oldValue
=
node
-
>
mValueAfter
;
node
-
>
Calc
(
this
)
;
if
(
node
-
>
mType
=
=
nsCounterNode
:
:
USE
)
{
nsCounterUseNode
*
useNode
=
node
-
>
UseNode
(
)
;
if
(
useNode
-
>
mText
)
{
nsAutoString
text
;
useNode
-
>
GetText
(
text
)
;
useNode
-
>
mText
-
>
SetData
(
text
IgnoreErrors
(
)
)
;
}
}
if
(
oldValue
!
=
node
-
>
mValueAfter
&
&
node
-
>
mPseudoFrame
&
&
node
-
>
mPseudoFrame
-
>
StyleDisplay
(
)
-
>
mDisplay
=
=
StyleDisplay
:
:
ListItem
)
{
auto
*
shell
=
node
-
>
mPseudoFrame
-
>
PresShell
(
)
;
shell
-
>
FrameNeedsReflow
(
node
-
>
mPseudoFrame
nsIPresShell
:
:
eStyleChange
NS_FRAME_IS_DIRTY
)
;
}
}
}
static
bool
HasCounters
(
const
nsStyleContent
&
aStyle
)
{
return
aStyle
.
CounterIncrementCount
(
)
|
|
aStyle
.
CounterResetCount
(
)
|
|
aStyle
.
CounterSetCount
(
)
;
}
bool
nsCounterManager
:
:
AddCounterChanges
(
nsIFrame
*
aFrame
)
{
const
bool
requiresListItemIncrement
=
aFrame
-
>
StyleDisplay
(
)
-
>
mDisplay
=
=
StyleDisplay
:
:
ListItem
&
&
!
aFrame
-
>
Style
(
)
-
>
IsAnonBox
(
)
;
const
nsStyleContent
*
styleContent
=
aFrame
-
>
StyleContent
(
)
;
if
(
!
requiresListItemIncrement
&
&
!
HasCounters
(
*
styleContent
)
)
{
MOZ_ASSERT
(
!
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_HAS_CSS_COUNTER_STYLE
)
)
;
return
false
;
}
aFrame
-
>
AddStateBits
(
NS_FRAME_HAS_CSS_COUNTER_STYLE
)
;
bool
dirty
=
false
;
for
(
int32_t
i
:
IntegerRange
(
styleContent
-
>
CounterResetCount
(
)
)
)
{
dirty
|
=
AddCounterChangeNode
(
aFrame
i
styleContent
-
>
CounterResetAt
(
i
)
nsCounterChangeNode
:
:
RESET
)
;
}
bool
hasListItemIncrement
=
false
;
for
(
int32_t
i
:
IntegerRange
(
styleContent
-
>
CounterIncrementCount
(
)
)
)
{
const
nsStyleCounterData
&
increment
=
styleContent
-
>
CounterIncrementAt
(
i
)
;
hasListItemIncrement
|
=
increment
.
mCounter
.
EqualsLiteral
(
"
list
-
item
"
)
;
dirty
|
=
AddCounterChangeNode
(
aFrame
i
increment
nsCounterChangeNode
:
:
INCREMENT
)
;
}
if
(
requiresListItemIncrement
&
&
!
hasListItemIncrement
)
{
bool
reversed
=
aFrame
-
>
StyleList
(
)
-
>
mMozListReversed
=
=
StyleMozListReversed
:
:
True
;
nsStyleCounterData
listItemIncrement
{
NS_LITERAL_STRING
(
"
list
-
item
"
)
reversed
?
-
1
:
1
}
;
dirty
|
=
AddCounterChangeNode
(
aFrame
styleContent
-
>
CounterIncrementCount
(
)
+
1
listItemIncrement
nsCounterChangeNode
:
:
INCREMENT
)
;
}
for
(
int32_t
i
:
IntegerRange
(
styleContent
-
>
CounterSetCount
(
)
)
)
{
dirty
|
=
AddCounterChangeNode
(
aFrame
i
styleContent
-
>
CounterSetAt
(
i
)
nsCounterChangeNode
:
:
SET
)
;
}
return
dirty
;
}
bool
nsCounterManager
:
:
AddCounterChangeNode
(
nsIFrame
*
aFrame
int32_t
aIndex
const
nsStyleCounterData
&
aCounterData
nsCounterNode
:
:
Type
aType
)
{
nsCounterChangeNode
*
node
=
new
nsCounterChangeNode
(
aFrame
aType
aCounterData
.
mValue
aIndex
)
;
nsCounterList
*
counterList
=
CounterListFor
(
aCounterData
.
mCounter
)
;
counterList
-
>
Insert
(
node
)
;
if
(
!
counterList
-
>
IsLast
(
node
)
)
{
counterList
-
>
SetDirty
(
)
;
return
true
;
}
if
(
MOZ_LIKELY
(
!
counterList
-
>
IsDirty
(
)
)
)
{
node
-
>
Calc
(
counterList
)
;
}
return
false
;
}
nsCounterList
*
nsCounterManager
:
:
CounterListFor
(
const
nsAString
&
aCounterName
)
{
return
mNames
.
LookupForAdd
(
aCounterName
)
.
OrInsert
(
[
]
(
)
{
return
new
nsCounterList
(
)
;
}
)
;
}
void
nsCounterManager
:
:
RecalcAll
(
)
{
for
(
auto
iter
=
mNames
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsCounterList
*
list
=
iter
.
UserData
(
)
;
if
(
list
-
>
IsDirty
(
)
)
{
list
-
>
RecalcAll
(
)
;
}
}
}
void
nsCounterManager
:
:
SetAllDirty
(
)
{
for
(
auto
iter
=
mNames
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
iter
.
UserData
(
)
-
>
SetDirty
(
)
;
}
}
bool
nsCounterManager
:
:
DestroyNodesFor
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_HAS_CSS_COUNTER_STYLE
)
"
why
call
me
?
"
)
;
bool
destroyedAny
=
false
;
for
(
auto
iter
=
mNames
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsCounterList
*
list
=
iter
.
UserData
(
)
;
if
(
list
-
>
DestroyNodesFor
(
aFrame
)
)
{
destroyedAny
=
true
;
list
-
>
SetDirty
(
)
;
}
}
return
destroyedAny
;
}
#
ifdef
DEBUG
void
nsCounterManager
:
:
Dump
(
)
{
printf
(
"
\
n
\
nCounter
Manager
Lists
:
\
n
"
)
;
for
(
auto
iter
=
mNames
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
printf
(
"
Counter
named
\
"
%
s
\
"
:
\
n
"
NS_ConvertUTF16toUTF8
(
iter
.
Key
(
)
)
.
get
(
)
)
;
nsCounterList
*
list
=
iter
.
UserData
(
)
;
int32_t
i
=
0
;
for
(
nsCounterNode
*
node
=
list
-
>
First
(
)
;
node
;
node
=
list
-
>
Next
(
node
)
)
{
const
char
*
types
[
]
=
{
"
RESET
"
"
SET
"
"
INCREMENT
"
"
USE
"
}
;
printf
(
"
Node
#
%
d
%
p
frame
=
%
p
index
=
%
d
type
=
%
s
valAfter
=
%
d
\
n
"
"
scope
-
start
=
%
p
scope
-
prev
=
%
p
"
i
+
+
(
void
*
)
node
(
void
*
)
node
-
>
mPseudoFrame
node
-
>
mContentIndex
types
[
node
-
>
mType
]
node
-
>
mValueAfter
(
void
*
)
node
-
>
mScopeStart
(
void
*
)
node
-
>
mScopePrev
)
;
if
(
node
-
>
mType
=
=
nsCounterNode
:
:
USE
)
{
nsAutoString
text
;
node
-
>
UseNode
(
)
-
>
GetText
(
text
)
;
printf
(
"
text
=
%
s
"
NS_ConvertUTF16toUTF8
(
text
)
.
get
(
)
)
;
}
printf
(
"
\
n
"
)
;
}
}
printf
(
"
\
n
\
n
"
)
;
}
#
endif
