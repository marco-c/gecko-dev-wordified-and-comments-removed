#
ifndef
mozilla_RestyleManager_h
#
define
mozilla_RestyleManager_h
#
include
"
mozilla
/
RestyleLogging
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsChangeHint
.
h
"
#
include
"
RestyleTracker
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsRefreshDriver
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsTransitionManager
.
h
"
class
nsIFrame
;
class
nsStyleChangeList
;
struct
TreeMatchContext
;
namespace
mozilla
{
class
EventStates
;
struct
UndisplayedNode
;
namespace
dom
{
class
Element
;
}
class
RestyleManager
final
{
public
:
friend
class
:
:
nsRefreshDriver
;
friend
class
RestyleTracker
;
typedef
mozilla
:
:
dom
:
:
Element
Element
;
explicit
RestyleManager
(
nsPresContext
*
aPresContext
)
;
private
:
~
RestyleManager
(
)
{
MOZ_ASSERT
(
!
mReframingStyleContexts
"
temporary
member
should
be
nulled
out
before
destruction
"
)
;
MOZ_ASSERT
(
!
mAnimationsWithDestroyedFrame
"
leaving
dangling
pointers
from
AnimationsWithDestroyedFrame
"
)
;
}
public
:
NS_INLINE_DECL_REFCOUNTING
(
mozilla
:
:
RestyleManager
)
void
Disconnect
(
)
{
mPresContext
=
nullptr
;
}
nsPresContext
*
PresContext
(
)
const
{
MOZ_ASSERT
(
mPresContext
)
;
return
mPresContext
;
}
void
NotifyDestroyingFrame
(
nsIFrame
*
aFrame
)
;
nsresult
ContentStateChanged
(
nsIContent
*
aContent
EventStates
aStateMask
)
;
void
AttributeWillChange
(
Element
*
aElement
int32_t
aNameSpaceID
nsIAtom
*
aAttribute
int32_t
aModType
const
nsAttrValue
*
aNewValue
)
;
void
AttributeChanged
(
Element
*
aElement
int32_t
aNameSpaceID
nsIAtom
*
aAttribute
int32_t
aModType
const
nsAttrValue
*
aOldValue
)
;
uint32_t
GetRestyleGeneration
(
)
const
{
return
mRestyleGeneration
;
}
uint32_t
GetHoverGeneration
(
)
const
{
return
mHoverGeneration
;
}
uint64_t
GetAnimationGeneration
(
)
const
{
return
mAnimationGeneration
;
}
static
uint64_t
GetAnimationGenerationForFrame
(
nsIFrame
*
aFrame
)
;
void
IncrementAnimationGeneration
(
)
{
+
+
mAnimationGeneration
;
}
bool
SkipAnimationRules
(
)
const
{
return
mSkipAnimationRules
;
}
void
SetSkipAnimationRules
(
bool
aSkipAnimationRules
)
{
mSkipAnimationRules
=
aSkipAnimationRules
;
}
nsresult
ReparentStyleContext
(
nsIFrame
*
aFrame
)
;
void
ClearSelectors
(
)
{
mPendingRestyles
.
ClearSelectors
(
)
;
}
private
:
nsCSSFrameConstructor
*
FrameConstructor
(
)
const
{
return
PresContext
(
)
-
>
FrameConstructor
(
)
;
}
void
ComputeAndProcessStyleChange
(
nsIFrame
*
aFrame
nsChangeHint
aMinChange
RestyleTracker
&
aRestyleTracker
nsRestyleHint
aRestyleHint
const
RestyleHintData
&
aRestyleHintData
)
;
void
ComputeAndProcessStyleChange
(
nsStyleContext
*
aNewContext
Element
*
aElement
nsChangeHint
aMinChange
RestyleTracker
&
aRestyleTracker
nsRestyleHint
aRestyleHint
const
RestyleHintData
&
aRestyleHintData
)
;
public
:
#
ifdef
DEBUG
void
DebugVerifyStyleTree
(
nsIFrame
*
aFrame
)
;
#
endif
nsresult
ProcessRestyledFrames
(
nsStyleChangeList
&
aRestyleArray
)
;
typedef
nsRefPtrHashtable
<
nsRefPtrHashKey
<
nsIContent
>
nsStyleContext
>
ReframingStyleContextTable
;
class
MOZ_STACK_CLASS
ReframingStyleContexts
final
{
public
:
explicit
ReframingStyleContexts
(
RestyleManager
*
aRestyleManager
)
;
~
ReframingStyleContexts
(
)
;
void
Put
(
nsIContent
*
aContent
nsStyleContext
*
aStyleContext
)
{
MOZ_ASSERT
(
aContent
)
;
nsCSSPseudoElements
:
:
Type
pseudoType
=
aStyleContext
-
>
GetPseudoType
(
)
;
if
(
pseudoType
=
=
CSSPseudoElementType
:
:
NotPseudo
)
{
mElementContexts
.
Put
(
aContent
aStyleContext
)
;
}
else
if
(
pseudoType
=
=
CSSPseudoElementType
:
:
before
)
{
MOZ_ASSERT
(
aContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
nsGkAtoms
:
:
mozgeneratedcontentbefore
)
;
mBeforePseudoContexts
.
Put
(
aContent
-
>
GetParent
(
)
aStyleContext
)
;
}
else
if
(
pseudoType
=
=
CSSPseudoElementType
:
:
after
)
{
MOZ_ASSERT
(
aContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
nsGkAtoms
:
:
mozgeneratedcontentafter
)
;
mAfterPseudoContexts
.
Put
(
aContent
-
>
GetParent
(
)
aStyleContext
)
;
}
}
nsStyleContext
*
Get
(
nsIContent
*
aContent
nsCSSPseudoElements
:
:
Type
aPseudoType
)
{
MOZ_ASSERT
(
aContent
)
;
if
(
aPseudoType
=
=
CSSPseudoElementType
:
:
NotPseudo
)
{
return
mElementContexts
.
GetWeak
(
aContent
)
;
}
if
(
aPseudoType
=
=
CSSPseudoElementType
:
:
before
)
{
MOZ_ASSERT
(
aContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
nsGkAtoms
:
:
mozgeneratedcontentbefore
)
;
return
mBeforePseudoContexts
.
GetWeak
(
aContent
-
>
GetParent
(
)
)
;
}
if
(
aPseudoType
=
=
CSSPseudoElementType
:
:
after
)
{
MOZ_ASSERT
(
aContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
nsGkAtoms
:
:
mozgeneratedcontentafter
)
;
return
mAfterPseudoContexts
.
GetWeak
(
aContent
-
>
GetParent
(
)
)
;
}
MOZ_ASSERT
(
false
"
unexpected
aPseudoType
"
)
;
return
nullptr
;
}
private
:
RestyleManager
*
mRestyleManager
;
AutoRestore
<
ReframingStyleContexts
*
>
mRestorePointer
;
ReframingStyleContextTable
mElementContexts
;
ReframingStyleContextTable
mBeforePseudoContexts
;
ReframingStyleContextTable
mAfterPseudoContexts
;
}
;
ReframingStyleContexts
*
GetReframingStyleContexts
(
)
{
return
mReframingStyleContexts
;
}
static
bool
TryStartingTransition
(
nsPresContext
*
aPresContext
nsIContent
*
aContent
nsStyleContext
*
aOldStyleContext
RefPtr
<
nsStyleContext
>
*
aNewStyleContext
)
;
class
MOZ_STACK_CLASS
AnimationsWithDestroyedFrame
final
{
public
:
explicit
AnimationsWithDestroyedFrame
(
RestyleManager
*
aRestyleManager
)
;
~
AnimationsWithDestroyedFrame
(
)
{
}
void
Put
(
nsIContent
*
aContent
nsStyleContext
*
aStyleContext
)
{
MOZ_ASSERT
(
aContent
)
;
nsCSSPseudoElements
:
:
Type
pseudoType
=
aStyleContext
-
>
GetPseudoType
(
)
;
if
(
pseudoType
=
=
CSSPseudoElementType
:
:
NotPseudo
)
{
mContents
.
AppendElement
(
aContent
)
;
}
else
if
(
pseudoType
=
=
CSSPseudoElementType
:
:
before
)
{
MOZ_ASSERT
(
aContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
nsGkAtoms
:
:
mozgeneratedcontentbefore
)
;
mBeforeContents
.
AppendElement
(
aContent
-
>
GetParent
(
)
)
;
}
else
if
(
pseudoType
=
=
CSSPseudoElementType
:
:
after
)
{
MOZ_ASSERT
(
aContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
nsGkAtoms
:
:
mozgeneratedcontentafter
)
;
mAfterContents
.
AppendElement
(
aContent
-
>
GetParent
(
)
)
;
}
}
void
StopAnimationsForElementsWithoutFrames
(
)
;
private
:
void
StopAnimationsWithoutFrame
(
nsTArray
<
RefPtr
<
nsIContent
>
>
&
aArray
nsCSSPseudoElements
:
:
Type
aPseudoType
)
;
RestyleManager
*
mRestyleManager
;
AutoRestore
<
AnimationsWithDestroyedFrame
*
>
mRestorePointer
;
nsTArray
<
RefPtr
<
nsIContent
>
>
mContents
;
nsTArray
<
RefPtr
<
nsIContent
>
>
mBeforeContents
;
nsTArray
<
RefPtr
<
nsIContent
>
>
mAfterContents
;
}
;
AnimationsWithDestroyedFrame
*
GetAnimationsWithDestroyedFrame
(
)
{
return
mAnimationsWithDestroyedFrame
;
}
private
:
void
RestyleForEmptyChange
(
Element
*
aContainer
)
;
public
:
void
RestyleForInsertOrChange
(
Element
*
aContainer
nsIContent
*
aChild
)
;
void
RestyleForRemove
(
Element
*
aContainer
nsIContent
*
aOldChild
nsIContent
*
aFollowingSibling
)
;
void
RestyleForAppend
(
Element
*
aContainer
nsIContent
*
aFirstNewContent
)
;
void
ProcessPendingRestyles
(
)
;
bool
HasPendingRestyles
(
)
{
return
mPendingRestyles
.
Count
(
)
!
=
0
;
}
private
:
void
BeginProcessingRestyles
(
RestyleTracker
&
aRestyleTracker
)
;
void
EndProcessingRestyles
(
)
;
public
:
void
UpdateOnlyAnimationStyles
(
)
;
void
RebuildAllStyleData
(
nsChangeHint
aExtraHint
nsRestyleHint
aRestyleHint
)
;
void
PostRestyleEvent
(
Element
*
aElement
nsRestyleHint
aRestyleHint
nsChangeHint
aMinChangeHint
const
RestyleHintData
*
aRestyleHintData
=
nullptr
)
;
void
PostRestyleEventForLazyConstruction
(
)
{
PostRestyleEventInternal
(
true
)
;
}
void
FlushOverflowChangedTracker
(
)
{
mOverflowChangedTracker
.
Flush
(
)
;
}
static
nsCString
RestyleHintToString
(
nsRestyleHint
aHint
)
;
#
ifdef
DEBUG
static
nsCString
ChangeHintToString
(
nsChangeHint
aHint
)
;
#
endif
private
:
void
PostRestyleEventInternal
(
bool
aForLazyConstruction
)
;
public
:
void
PostRebuildAllStyleDataEvent
(
nsChangeHint
aExtraHint
nsRestyleHint
aRestyleHint
)
;
#
ifdef
RESTYLE_LOGGING
bool
ShouldLogRestyle
(
)
{
return
ShouldLogRestyle
(
mPresContext
)
;
}
static
bool
ShouldLogRestyle
(
nsPresContext
*
aPresContext
)
{
return
aPresContext
-
>
RestyleLoggingEnabled
(
)
&
&
(
!
aPresContext
-
>
TransitionManager
(
)
-
>
InAnimationOnlyStyleUpdate
(
)
|
|
AnimationRestyleLoggingEnabled
(
)
)
;
}
static
bool
RestyleLoggingInitiallyEnabled
(
)
{
static
bool
enabled
=
getenv
(
"
MOZ_DEBUG_RESTYLE
"
)
!
=
0
;
return
enabled
;
}
static
bool
AnimationRestyleLoggingEnabled
(
)
{
static
bool
animations
=
getenv
(
"
MOZ_DEBUG_RESTYLE_ANIMATIONS
"
)
!
=
0
;
return
animations
;
}
static
uint32_t
StructsToLog
(
)
;
static
nsCString
StructNamesToString
(
uint32_t
aSIDs
)
;
int32_t
&
LoggingDepth
(
)
{
return
mLoggingDepth
;
}
#
endif
private
:
void
RestyleElement
(
Element
*
aElement
nsIFrame
*
aPrimaryFrame
nsChangeHint
aMinHint
RestyleTracker
&
aRestyleTracker
nsRestyleHint
aRestyleHint
const
RestyleHintData
&
aRestyleHintData
)
;
void
StartRebuildAllStyleData
(
RestyleTracker
&
aRestyleTracker
)
;
void
FinishRebuildAllStyleData
(
)
;
void
StyleChangeReflow
(
nsIFrame
*
aFrame
nsChangeHint
aHint
)
;
void
AddSubtreeToOverflowTracker
(
nsIFrame
*
aFrame
)
;
bool
RecomputePosition
(
nsIFrame
*
aFrame
)
;
bool
ShouldStartRebuildAllFor
(
RestyleTracker
&
aRestyleTracker
)
{
return
mDoRebuildAllStyleData
&
&
&
aRestyleTracker
=
=
&
mPendingRestyles
;
}
void
ProcessRestyles
(
RestyleTracker
&
aRestyleTracker
)
{
if
(
aRestyleTracker
.
Count
(
)
|
|
ShouldStartRebuildAllFor
(
aRestyleTracker
)
)
{
if
(
+
+
mRestyleGeneration
=
=
0
)
{
+
+
mRestyleGeneration
;
}
aRestyleTracker
.
DoProcessRestyles
(
)
;
}
}
private
:
nsPresContext
*
mPresContext
;
bool
mDoRebuildAllStyleData
:
1
;
bool
mInRebuildAllStyleData
:
1
;
bool
mObservingRefreshDriver
:
1
;
bool
mInStyleRefresh
:
1
;
bool
mSkipAnimationRules
:
1
;
bool
mHavePendingNonAnimationRestyles
:
1
;
uint32_t
mRestyleGeneration
;
uint32_t
mHoverGeneration
;
nsChangeHint
mRebuildAllExtraHint
;
nsRestyleHint
mRebuildAllRestyleHint
;
OverflowChangedTracker
mOverflowChangedTracker
;
uint64_t
mAnimationGeneration
;
ReframingStyleContexts
*
mReframingStyleContexts
;
AnimationsWithDestroyedFrame
*
mAnimationsWithDestroyedFrame
;
RestyleTracker
mPendingRestyles
;
#
ifdef
DEBUG
bool
mIsProcessingRestyles
;
#
endif
#
ifdef
RESTYLE_LOGGING
int32_t
mLoggingDepth
;
#
endif
}
;
class
ElementRestyler
final
{
public
:
typedef
mozilla
:
:
dom
:
:
Element
Element
;
struct
ContextToClear
{
RefPtr
<
nsStyleContext
>
mStyleContext
;
uint32_t
mStructs
;
}
;
ElementRestyler
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
nsStyleChangeList
*
aChangeList
nsChangeHint
aHintsHandledByAncestors
RestyleTracker
&
aRestyleTracker
nsTArray
<
nsCSSSelector
*
>
&
aSelectorsForDescendants
TreeMatchContext
&
aTreeMatchContext
nsTArray
<
nsIContent
*
>
&
aVisibleKidsOfHiddenElement
nsTArray
<
ContextToClear
>
&
aContextsToClear
nsTArray
<
RefPtr
<
nsStyleContext
>
>
&
aSwappedStructOwners
)
;
enum
ConstructorFlags
{
FOR_OUT_OF_FLOW_CHILD
=
1
<
<
0
}
;
ElementRestyler
(
const
ElementRestyler
&
aParentRestyler
nsIFrame
*
aFrame
uint32_t
aConstructorFlags
)
;
enum
ParentContextFromChildFrame
{
PARENT_CONTEXT_FROM_CHILD_FRAME
}
;
ElementRestyler
(
ParentContextFromChildFrame
const
ElementRestyler
&
aParentFrameRestyler
nsIFrame
*
aFrame
)
;
ElementRestyler
(
nsPresContext
*
aPresContext
nsIContent
*
aContent
nsStyleChangeList
*
aChangeList
nsChangeHint
aHintsHandledByAncestors
RestyleTracker
&
aRestyleTracker
nsTArray
<
nsCSSSelector
*
>
&
aSelectorsForDescendants
TreeMatchContext
&
aTreeMatchContext
nsTArray
<
nsIContent
*
>
&
aVisibleKidsOfHiddenElement
nsTArray
<
ContextToClear
>
&
aContextsToClear
nsTArray
<
RefPtr
<
nsStyleContext
>
>
&
aSwappedStructOwners
)
;
void
Restyle
(
nsRestyleHint
aRestyleHint
)
;
nsChangeHint
HintsHandledForFrame
(
)
{
return
mHintsHandled
;
}
void
RestyleChildrenOfDisplayContentsElement
(
nsIFrame
*
aParentFrame
nsStyleContext
*
aNewContext
nsChangeHint
aMinHint
RestyleTracker
&
aRestyleTracker
nsRestyleHint
aRestyleHint
const
RestyleHintData
&
aRestyleHintData
)
;
static
void
ComputeStyleChangeFor
(
nsIFrame
*
aFrame
nsStyleChangeList
*
aChangeList
nsChangeHint
aMinChange
RestyleTracker
&
aRestyleTracker
nsRestyleHint
aRestyleHint
const
RestyleHintData
&
aRestyleHintData
nsTArray
<
ContextToClear
>
&
aContextsToClear
nsTArray
<
RefPtr
<
nsStyleContext
>
>
&
aSwappedStructOwners
)
;
#
ifdef
RESTYLE_LOGGING
bool
ShouldLogRestyle
(
)
{
return
RestyleManager
:
:
ShouldLogRestyle
(
mPresContext
)
;
}
#
endif
private
:
enum
RestyleResult
{
eRestyleResult_Stop
=
1
eRestyleResult_StopWithStyleChange
eRestyleResult_Continue
eRestyleResult_ContinueAndForceDescendants
}
;
struct
SwapInstruction
{
RefPtr
<
nsStyleContext
>
mOldContext
;
RefPtr
<
nsStyleContext
>
mNewContext
;
uint32_t
mStructsToSwap
;
}
;
RestyleResult
RestyleSelf
(
nsIFrame
*
aSelf
nsRestyleHint
aRestyleHint
uint32_t
*
aSwappedStructs
nsTArray
<
SwapInstruction
>
&
aSwaps
)
;
void
RestyleChildren
(
nsRestyleHint
aChildRestyleHint
)
;
bool
SelectorMatchesForRestyle
(
Element
*
aElement
)
;
bool
MustRestyleSelf
(
nsRestyleHint
aRestyleHint
Element
*
aElement
)
;
bool
CanReparentStyleContext
(
nsRestyleHint
aRestyleHint
)
;
void
AddLayerChangesForAnimation
(
)
;
bool
MoveStyleContextsForContentChildren
(
nsIFrame
*
aParent
nsStyleContext
*
aOldContext
nsTArray
<
nsStyleContext
*
>
&
aContextsToMove
)
;
bool
MoveStyleContextsForChildren
(
nsStyleContext
*
aOldContext
)
;
void
CaptureChange
(
nsStyleContext
*
aOldContext
nsStyleContext
*
aNewContext
nsChangeHint
aChangeToAssume
uint32_t
*
aEqualStructs
uint32_t
*
aSamePointerStructs
)
;
void
ComputeRestyleResultFromFrame
(
nsIFrame
*
aSelf
RestyleResult
&
aRestyleResult
bool
&
aCanStopWithStyleChange
)
;
void
ComputeRestyleResultFromNewContext
(
nsIFrame
*
aSelf
nsStyleContext
*
aNewContext
RestyleResult
&
aRestyleResult
bool
&
aCanStopWithStyleChange
)
;
void
RestyleUndisplayedDescendants
(
nsRestyleHint
aChildRestyleHint
)
;
bool
MustCheckUndisplayedContent
(
nsIFrame
*
aFrame
nsIContent
*
&
aUndisplayedParent
)
;
void
DoRestyleUndisplayedDescendants
(
nsRestyleHint
aChildRestyleHint
nsIContent
*
aParent
nsStyleContext
*
aParentStyleContext
)
;
void
RestyleUndisplayedNodes
(
nsRestyleHint
aChildRestyleHint
UndisplayedNode
*
aUndisplayed
nsIContent
*
aUndisplayedParent
nsStyleContext
*
aParentStyleContext
const
uint8_t
aDisplay
)
;
void
MaybeReframeForBeforePseudo
(
)
;
void
MaybeReframeForAfterPseudo
(
nsIFrame
*
aFrame
)
;
void
MaybeReframeForPseudo
(
nsCSSPseudoElements
:
:
Type
aPseudoType
nsIFrame
*
aGenConParentFrame
nsIFrame
*
aFrame
nsIContent
*
aContent
nsStyleContext
*
aStyleContext
)
;
#
ifdef
DEBUG
bool
MustReframeForBeforePseudo
(
)
;
bool
MustReframeForAfterPseudo
(
nsIFrame
*
aFrame
)
;
#
endif
bool
MustReframeForPseudo
(
nsCSSPseudoElements
:
:
Type
aPseudoType
nsIFrame
*
aGenConParentFrame
nsIFrame
*
aFrame
nsIContent
*
aContent
nsStyleContext
*
aStyleContext
)
;
void
RestyleContentChildren
(
nsIFrame
*
aParent
nsRestyleHint
aChildRestyleHint
)
;
void
InitializeAccessibilityNotifications
(
nsStyleContext
*
aNewContext
)
;
void
SendAccessibilityNotifications
(
)
;
enum
DesiredA11yNotifications
{
eSkipNotifications
eSendAllNotifications
eNotifyIfShown
}
;
enum
A11yNotificationType
{
eDontNotify
eNotifyShown
eNotifyHidden
}
;
void
ConditionallyRestyleChildren
(
)
;
void
ConditionallyRestyleChildren
(
nsIFrame
*
aFrame
Element
*
aRestyleRoot
)
;
void
ConditionallyRestyleContentChildren
(
nsIFrame
*
aFrame
Element
*
aRestyleRoot
)
;
void
ConditionallyRestyleUndisplayedDescendants
(
nsIFrame
*
aFrame
Element
*
aRestyleRoot
)
;
void
DoConditionallyRestyleUndisplayedDescendants
(
nsIContent
*
aParent
Element
*
aRestyleRoot
)
;
void
ConditionallyRestyleUndisplayedNodes
(
UndisplayedNode
*
aUndisplayed
nsIContent
*
aUndisplayedParent
const
uint8_t
aDisplay
Element
*
aRestyleRoot
)
;
void
ConditionallyRestyleContentDescendants
(
Element
*
aElement
Element
*
aRestyleRoot
)
;
bool
ConditionallyRestyle
(
nsIFrame
*
aFrame
Element
*
aRestyleRoot
)
;
bool
ConditionallyRestyle
(
Element
*
aElement
Element
*
aRestyleRoot
)
;
#
ifdef
RESTYLE_LOGGING
int32_t
&
LoggingDepth
(
)
{
return
mLoggingDepth
;
}
#
endif
#
ifdef
DEBUG
static
nsCString
RestyleResultToString
(
RestyleResult
aRestyleResult
)
;
#
endif
private
:
nsPresContext
*
const
mPresContext
;
nsIFrame
*
const
mFrame
;
nsIContent
*
const
mParentContent
;
nsIContent
*
const
mContent
;
nsStyleChangeList
*
const
mChangeList
;
nsChangeHint
mHintsHandled
;
nsChangeHint
mParentFrameHintsNotHandledForDescendants
;
nsChangeHint
mHintsNotHandledForDescendants
;
RestyleTracker
&
mRestyleTracker
;
nsTArray
<
nsCSSSelector
*
>
&
mSelectorsForDescendants
;
TreeMatchContext
&
mTreeMatchContext
;
nsIFrame
*
mResolvedChild
;
nsTArray
<
ContextToClear
>
&
mContextsToClear
;
nsTArray
<
RefPtr
<
nsStyleContext
>
>
&
mSwappedStructOwners
;
bool
mIsRootOfRestyle
;
#
ifdef
ACCESSIBILITY
const
DesiredA11yNotifications
mDesiredA11yNotifications
;
DesiredA11yNotifications
mKidsDesiredA11yNotifications
;
A11yNotificationType
mOurA11yNotification
;
nsTArray
<
nsIContent
*
>
&
mVisibleKidsOfHiddenElement
;
bool
mWasFrameVisible
;
#
endif
#
ifdef
RESTYLE_LOGGING
int32_t
mLoggingDepth
;
#
endif
}
;
class
MOZ_STACK_CLASS
AutoDisplayContentsAncestorPusher
final
{
public
:
typedef
mozilla
:
:
dom
:
:
Element
Element
;
AutoDisplayContentsAncestorPusher
(
TreeMatchContext
&
aTreeMatchContext
nsPresContext
*
aPresContext
nsIContent
*
aParent
)
;
~
AutoDisplayContentsAncestorPusher
(
)
;
bool
IsEmpty
(
)
const
{
return
mAncestors
.
Length
(
)
=
=
0
;
}
private
:
TreeMatchContext
&
mTreeMatchContext
;
nsPresContext
*
const
mPresContext
;
AutoTArray
<
mozilla
:
:
dom
:
:
Element
*
4
>
mAncestors
;
}
;
}
#
endif
