#
ifndef
nsCaret_h__
#
define
nsCaret_h__
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsCoord
.
h
"
#
include
"
nsISelectionListener
.
h
"
#
include
"
nsIWeakReferenceUtils
.
h
"
#
include
"
CaretAssociationHint
.
h
"
#
include
"
nsPoint
.
h
"
#
include
"
nsRect
.
h
"
class
nsDisplayListBuilder
;
class
nsFrameSelection
;
class
nsIContent
;
class
nsIDOMNode
;
class
nsIFrame
;
class
nsINode
;
class
nsIPresShell
;
class
nsITimer
;
namespace
mozilla
{
namespace
gfx
{
class
DrawTarget
;
}
}
class
nsCaret
final
:
public
nsISelectionListener
{
typedef
mozilla
:
:
gfx
:
:
DrawTarget
DrawTarget
;
public
:
nsCaret
(
)
;
protected
:
virtual
~
nsCaret
(
)
;
public
:
NS_DECL_ISUPPORTS
typedef
mozilla
:
:
CaretAssociationHint
CaretAssociationHint
;
nsresult
Init
(
nsIPresShell
*
inPresShell
)
;
void
Terminate
(
)
;
void
SetSelection
(
nsISelection
*
aDOMSel
)
;
nsISelection
*
GetSelection
(
)
;
void
SetIgnoreUserModify
(
bool
aIgnoreUserModify
)
;
void
SetVisible
(
bool
intMakeVisible
)
;
bool
IsVisible
(
nsISelection
*
aSelection
=
nullptr
)
{
if
(
!
mVisible
|
|
mHideCount
)
{
return
false
;
}
if
(
!
mShowDuringSelection
)
{
mozilla
:
:
dom
:
:
Selection
*
selection
;
if
(
aSelection
)
{
selection
=
static_cast
<
mozilla
:
:
dom
:
:
Selection
*
>
(
aSelection
)
;
}
else
{
selection
=
GetSelectionInternal
(
)
;
}
if
(
!
selection
|
|
!
selection
-
>
IsCollapsed
(
)
)
{
return
false
;
}
}
if
(
IsMenuPopupHidingCaret
(
)
)
{
return
false
;
}
return
true
;
}
void
AddForceHide
(
)
;
void
RemoveForceHide
(
)
;
void
SetCaretReadOnly
(
bool
inMakeReadonly
)
;
void
SetVisibilityDuringSelection
(
bool
aVisibility
)
;
void
SetCaretPosition
(
nsINode
*
aNode
int32_t
aOffset
)
;
void
SetCaretPosition
(
nsIDOMNode
*
aNode
int32_t
aOffset
)
;
void
SchedulePaint
(
nsISelection
*
aSelection
=
nullptr
)
;
nsIFrame
*
GetPaintGeometry
(
nsRect
*
aRect
)
;
nsIFrame
*
GetGeometry
(
nsRect
*
aRect
)
{
return
GetGeometry
(
GetSelection
(
)
aRect
)
;
}
void
PaintCaret
(
DrawTarget
&
aDrawTarget
nsIFrame
*
aForFrame
const
nsPoint
&
aOffset
)
;
NS_DECL_NSISELECTIONLISTENER
static
nsIFrame
*
GetGeometry
(
nsISelection
*
aSelection
nsRect
*
aRect
)
;
static
nsresult
GetCaretFrameForNodeOffset
(
nsFrameSelection
*
aFrameSelection
nsIContent
*
aContentNode
int32_t
aOffset
CaretAssociationHint
aFrameHint
uint8_t
aBidiLevel
nsIFrame
*
*
aReturnFrame
int32_t
*
aReturnOffset
)
;
static
nsRect
GetGeometryForFrame
(
nsIFrame
*
aFrame
int32_t
aFrameOffset
nscoord
*
aBidiIndicatorSize
)
;
static
nsIFrame
*
GetFrameAndOffset
(
mozilla
:
:
dom
:
:
Selection
*
aSelection
nsINode
*
aOverrideNode
int32_t
aOverrideOffset
int32_t
*
aFrameOffset
)
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
nsIFrame
*
GetFrame
(
int32_t
*
aContentOffset
)
;
void
ComputeCaretRects
(
nsIFrame
*
aFrame
int32_t
aFrameOffset
nsRect
*
aCaretRect
nsRect
*
aHookRect
)
;
protected
:
static
void
CaretBlinkCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
;
void
CheckSelectionLanguageChange
(
)
;
void
ResetBlinking
(
)
;
void
StopBlinking
(
)
;
mozilla
:
:
dom
:
:
Selection
*
GetSelectionInternal
(
)
;
struct
Metrics
{
nscoord
mBidiIndicatorSize
;
nscoord
mCaretWidth
;
}
;
static
Metrics
ComputeMetrics
(
nsIFrame
*
aFrame
int32_t
aOffset
nscoord
aCaretHeight
)
;
bool
IsMenuPopupHidingCaret
(
)
;
nsWeakPtr
mPresShell
;
nsWeakPtr
mDomSelectionWeak
;
nsCOMPtr
<
nsITimer
>
mBlinkTimer
;
nsCOMPtr
<
nsINode
>
mOverrideContent
;
int32_t
mOverrideOffset
;
int32_t
mBlinkCount
;
uint32_t
mBlinkRate
;
uint32_t
mHideCount
;
bool
mIsBlinkOn
;
bool
mVisible
;
bool
mReadOnly
;
bool
mShowDuringSelection
;
bool
mIgnoreUserModify
;
}
;
#
endif
