#
ifndef
nsCaret_h__
#
define
nsCaret_h__
#
include
"
mozilla
/
intl
/
BidiEmbeddingLevel
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsCoord
.
h
"
#
include
"
nsISelectionListener
.
h
"
#
include
"
nsIWeakReferenceUtils
.
h
"
#
include
"
nsPoint
.
h
"
#
include
"
nsRect
.
h
"
class
nsFrameSelection
;
class
nsIContent
;
class
nsIFrame
;
class
nsINode
;
class
nsITimer
;
namespace
mozilla
{
class
PresShell
;
enum
class
CaretAssociationHint
;
namespace
gfx
{
class
DrawTarget
;
}
}
class
nsCaret
final
:
public
nsISelectionListener
{
typedef
mozilla
:
:
gfx
:
:
DrawTarget
DrawTarget
;
public
:
nsCaret
(
)
;
protected
:
virtual
~
nsCaret
(
)
;
public
:
NS_DECL_ISUPPORTS
using
CaretAssociationHint
=
mozilla
:
:
CaretAssociationHint
;
nsresult
Init
(
mozilla
:
:
PresShell
*
aPresShell
)
;
void
Terminate
(
)
;
void
SetSelection
(
mozilla
:
:
dom
:
:
Selection
*
aDOMSel
)
;
mozilla
:
:
dom
:
:
Selection
*
GetSelection
(
)
;
void
SetIgnoreUserModify
(
bool
aIgnoreUserModify
)
;
void
SetVisible
(
bool
intMakeVisible
)
;
bool
IsVisible
(
mozilla
:
:
dom
:
:
Selection
*
aSelection
=
nullptr
)
{
if
(
!
mVisible
|
|
mHideCount
)
{
return
false
;
}
if
(
!
mShowDuringSelection
)
{
mozilla
:
:
dom
:
:
Selection
*
selection
;
if
(
aSelection
)
{
selection
=
aSelection
;
}
else
{
selection
=
GetSelection
(
)
;
}
if
(
!
selection
|
|
!
selection
-
>
IsCollapsed
(
)
)
{
return
false
;
}
}
if
(
IsMenuPopupHidingCaret
(
)
)
{
return
false
;
}
return
true
;
}
void
AddForceHide
(
)
;
void
RemoveForceHide
(
)
;
void
SetCaretReadOnly
(
bool
inMakeReadonly
)
;
void
SetVisibilityDuringSelection
(
bool
aVisibility
)
;
void
SetCaretPosition
(
nsINode
*
aNode
int32_t
aOffset
)
;
void
SchedulePaint
(
mozilla
:
:
dom
:
:
Selection
*
aSelection
=
nullptr
)
;
nsIFrame
*
GetPaintGeometry
(
nsRect
*
aRect
)
;
nsIFrame
*
GetPaintGeometry
(
nsRect
*
aCaretRect
nsRect
*
aHookRect
nscolor
*
aCaretColor
=
nullptr
)
;
nsIFrame
*
GetGeometry
(
nsRect
*
aRect
)
{
return
GetGeometry
(
GetSelection
(
)
aRect
)
;
}
void
PaintCaret
(
DrawTarget
&
aDrawTarget
nsIFrame
*
aForFrame
const
nsPoint
&
aOffset
)
;
NS_DECL_NSISELECTIONLISTENER
static
nsIFrame
*
GetGeometry
(
const
mozilla
:
:
dom
:
:
Selection
*
aSelection
nsRect
*
aRect
)
;
enum
class
ForceEditableRegion
{
No
Yes
}
;
struct
MOZ_STACK_CLASS
CaretFrameData
final
{
nsIFrame
*
mFrame
=
nullptr
;
nsIFrame
*
mUnadjustedFrame
=
nullptr
;
int32_t
mOffsetInFrameContent
=
0
;
CaretAssociationHint
mHint
{
0
}
;
}
;
static
CaretFrameData
GetCaretFrameForNodeOffset
(
const
nsFrameSelection
*
aFrameSelection
nsIContent
*
aContentNode
int32_t
aOffset
CaretAssociationHint
aFrameHint
mozilla
:
:
intl
:
:
BidiEmbeddingLevel
aBidiLevel
ForceEditableRegion
aForceEditableRegion
)
;
static
nsRect
GetGeometryForFrame
(
nsIFrame
*
aFrame
int32_t
aFrameOffset
nscoord
*
aBidiIndicatorSize
)
;
static
nsIFrame
*
GetFrameAndOffset
(
const
mozilla
:
:
dom
:
:
Selection
*
aSelection
nsINode
*
aOverrideNode
int32_t
aOverrideOffset
int32_t
*
aFrameOffset
nsIFrame
*
*
aUnadjustedFrame
=
nullptr
)
;
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
protected
:
static
void
CaretBlinkCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
;
void
CheckSelectionLanguageChange
(
)
;
void
ResetBlinking
(
)
;
void
StopBlinking
(
)
;
struct
Metrics
{
nscoord
mBidiIndicatorSize
;
nscoord
mCaretWidth
;
}
;
static
Metrics
ComputeMetrics
(
nsIFrame
*
aFrame
int32_t
aOffset
nscoord
aCaretHeight
)
;
void
ComputeCaretRects
(
nsIFrame
*
aFrame
int32_t
aFrameOffset
nsRect
*
aCaretRect
nsRect
*
aHookRect
)
;
bool
IsMenuPopupHidingCaret
(
)
;
nsWeakPtr
mPresShell
;
mozilla
:
:
WeakPtr
<
mozilla
:
:
dom
:
:
Selection
>
mDomSelectionWeak
;
nsCOMPtr
<
nsITimer
>
mBlinkTimer
;
nsCOMPtr
<
nsINode
>
mOverrideContent
;
int32_t
mOverrideOffset
;
int32_t
mBlinkCount
;
int32_t
mBlinkRate
;
uint32_t
mHideCount
;
bool
mIsBlinkOn
;
bool
mVisible
;
bool
mReadOnly
;
bool
mShowDuringSelection
;
bool
mIgnoreUserModify
;
}
;
#
endif
