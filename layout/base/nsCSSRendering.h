#
ifndef
nsCSSRendering_h___
#
define
nsCSSRendering_h___
#
include
"
gfxBlur
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
mozilla
/
gfx
/
PathHelpers
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
TypedEnumBits
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsStyleStruct
.
h
"
#
include
"
nsIFrame
.
h
"
class
gfxDrawable
;
class
nsStyleContext
;
class
nsPresContext
;
class
nsRenderingContext
;
namespace
mozilla
{
namespace
gfx
{
struct
Color
;
class
DrawTarget
;
}
namespace
layers
{
class
ImageContainer
;
}
struct
CSSSizeOrRatio
{
CSSSizeOrRatio
(
)
:
mRatio
(
0
0
)
mHasWidth
(
false
)
mHasHeight
(
false
)
{
}
bool
CanComputeConcreteSize
(
)
const
{
return
mHasWidth
+
mHasHeight
+
HasRatio
(
)
>
=
2
;
}
bool
IsConcrete
(
)
const
{
return
mHasWidth
&
&
mHasHeight
;
}
bool
HasRatio
(
)
const
{
return
mRatio
.
width
>
0
&
&
mRatio
.
height
>
0
;
}
bool
IsEmpty
(
)
const
{
return
(
mHasWidth
&
&
mWidth
<
=
0
)
|
|
(
mHasHeight
&
&
mHeight
<
=
0
)
|
|
mRatio
.
width
<
=
0
|
|
mRatio
.
height
<
=
0
;
}
nsSize
ComputeConcreteSize
(
)
const
;
void
SetWidth
(
nscoord
aWidth
)
{
mWidth
=
aWidth
;
mHasWidth
=
true
;
if
(
mHasHeight
)
{
mRatio
=
nsSize
(
mWidth
mHeight
)
;
}
}
void
SetHeight
(
nscoord
aHeight
)
{
mHeight
=
aHeight
;
mHasHeight
=
true
;
if
(
mHasWidth
)
{
mRatio
=
nsSize
(
mWidth
mHeight
)
;
}
}
void
SetSize
(
const
nsSize
&
aSize
)
{
mWidth
=
aSize
.
width
;
mHeight
=
aSize
.
height
;
mHasWidth
=
true
;
mHasHeight
=
true
;
mRatio
=
aSize
;
}
void
SetRatio
(
const
nsSize
&
aRatio
)
{
MOZ_ASSERT
(
!
mHasWidth
|
|
!
mHasHeight
"
Probably
shouldn
'
t
be
setting
a
ratio
if
we
have
a
concrete
size
"
)
;
mRatio
=
aRatio
;
}
nsSize
mRatio
;
nscoord
mWidth
;
nscoord
mHeight
;
bool
mHasWidth
;
bool
mHasHeight
;
}
;
enum
class
PaintBorderFlags
:
uint8_t
{
SYNC_DECODE_IMAGES
=
1
<
<
0
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
PaintBorderFlags
)
}
class
nsImageRenderer
{
public
:
typedef
mozilla
:
:
image
:
:
DrawResult
DrawResult
;
typedef
mozilla
:
:
layers
:
:
LayerManager
LayerManager
;
typedef
mozilla
:
:
layers
:
:
ImageContainer
ImageContainer
;
enum
{
FLAG_SYNC_DECODE_IMAGES
=
0x01
FLAG_PAINTING_TO_WINDOW
=
0x02
}
;
enum
FitType
{
CONTAIN
COVER
}
;
nsImageRenderer
(
nsIFrame
*
aForFrame
const
nsStyleImage
*
aImage
uint32_t
aFlags
)
;
~
nsImageRenderer
(
)
;
bool
PrepareImage
(
)
;
mozilla
:
:
CSSSizeOrRatio
ComputeIntrinsicSize
(
)
;
static
void
ComputeObjectAnchorPoint
(
const
nsStyleImageLayers
:
:
Position
&
aPos
const
nsSize
&
aOriginBounds
const
nsSize
&
aImageSize
nsPoint
*
aTopLeft
nsPoint
*
aAnchorPoint
)
;
static
nsSize
ComputeConstrainedSize
(
const
nsSize
&
aConstrainingSize
const
nsSize
&
aIntrinsicRatio
FitType
aFitType
)
;
static
nsSize
ComputeConcreteSize
(
const
mozilla
:
:
CSSSizeOrRatio
&
aSpecifiedSize
const
mozilla
:
:
CSSSizeOrRatio
&
aIntrinsicSize
const
nsSize
&
aDefaultSize
)
;
void
SetPreferredSize
(
const
mozilla
:
:
CSSSizeOrRatio
&
aIntrinsicSize
const
nsSize
&
aDefaultSize
)
;
DrawResult
DrawBackground
(
nsPresContext
*
aPresContext
nsRenderingContext
&
aRenderingContext
const
nsRect
&
aDest
const
nsRect
&
aFill
const
nsPoint
&
aAnchor
const
nsRect
&
aDirty
const
nsSize
&
aRepeatSize
)
;
DrawResult
DrawBorderImageComponent
(
nsPresContext
*
aPresContext
nsRenderingContext
&
aRenderingContext
const
nsRect
&
aDirtyRect
const
nsRect
&
aFill
const
mozilla
:
:
CSSIntRect
&
aSrc
uint8_t
aHFill
uint8_t
aVFill
const
nsSize
&
aUnitSize
uint8_t
aIndex
const
mozilla
:
:
Maybe
<
nsSize
>
&
aSVGViewportSize
)
;
bool
IsRasterImage
(
)
;
bool
IsAnimatedImage
(
)
;
already_AddRefed
<
imgIContainer
>
GetImage
(
)
;
bool
IsReady
(
)
const
{
return
mPrepareResult
=
=
DrawResult
:
:
SUCCESS
;
}
DrawResult
PrepareResult
(
)
const
{
return
mPrepareResult
;
}
void
SetExtendMode
(
mozilla
:
:
gfx
:
:
ExtendMode
aMode
)
{
mExtendMode
=
aMode
;
}
void
SetMaskOp
(
uint8_t
aMaskOp
)
{
mMaskOp
=
aMaskOp
;
}
private
:
DrawResult
Draw
(
nsPresContext
*
aPresContext
nsRenderingContext
&
aRenderingContext
const
nsRect
&
aDirtyRect
const
nsRect
&
aDest
const
nsRect
&
aFill
const
nsPoint
&
aAnchor
const
nsSize
&
aRepeatSize
const
mozilla
:
:
CSSIntRect
&
aSrc
)
;
already_AddRefed
<
gfxDrawable
>
DrawableForElement
(
const
nsRect
&
aImageRect
nsRenderingContext
&
aRenderingContext
)
;
nsIFrame
*
mForFrame
;
const
nsStyleImage
*
mImage
;
nsStyleImageType
mType
;
nsCOMPtr
<
imgIContainer
>
mImageContainer
;
RefPtr
<
nsStyleGradient
>
mGradientData
;
nsIFrame
*
mPaintServerFrame
;
nsLayoutUtils
:
:
SurfaceFromElementResult
mImageElementSurface
;
DrawResult
mPrepareResult
;
nsSize
mSize
;
uint32_t
mFlags
;
mozilla
:
:
gfx
:
:
ExtendMode
mExtendMode
;
uint8_t
mMaskOp
;
}
;
struct
nsBackgroundLayerState
{
typedef
mozilla
:
:
gfx
:
:
CompositionOp
CompositionOp
;
nsBackgroundLayerState
(
nsIFrame
*
aForFrame
const
nsStyleImage
*
aImage
uint32_t
aFlags
)
:
mImageRenderer
(
aForFrame
aImage
aFlags
)
{
}
nsImageRenderer
mImageRenderer
;
nsRect
mDestArea
;
nsRect
mFillArea
;
nsPoint
mAnchor
;
nsSize
mRepeatSize
;
}
;
struct
nsCSSRendering
{
typedef
mozilla
:
:
gfx
:
:
CompositionOp
CompositionOp
;
typedef
mozilla
:
:
gfx
:
:
DrawTarget
DrawTarget
;
typedef
mozilla
:
:
gfx
:
:
Float
Float
;
typedef
mozilla
:
:
gfx
:
:
Point
Point
;
typedef
mozilla
:
:
gfx
:
:
Rect
Rect
;
typedef
mozilla
:
:
gfx
:
:
Size
Size
;
typedef
mozilla
:
:
gfx
:
:
RectCornerRadii
RectCornerRadii
;
typedef
mozilla
:
:
image
:
:
DrawResult
DrawResult
;
typedef
nsIFrame
:
:
Sides
Sides
;
static
void
Init
(
)
;
static
void
Shutdown
(
)
;
static
void
PaintBoxShadowInner
(
nsPresContext
*
aPresContext
nsRenderingContext
&
aRenderingContext
nsIFrame
*
aForFrame
const
nsRect
&
aFrameArea
)
;
static
void
PaintBoxShadowOuter
(
nsPresContext
*
aPresContext
nsRenderingContext
&
aRenderingContext
nsIFrame
*
aForFrame
const
nsRect
&
aFrameArea
const
nsRect
&
aDirtyRect
float
aOpacity
=
1
.
0
)
;
static
void
ComputePixelRadii
(
const
nscoord
*
aAppUnitsRadii
nscoord
aAppUnitsPerPixel
RectCornerRadii
*
oBorderRadii
)
;
static
DrawResult
PaintBorder
(
nsPresContext
*
aPresContext
nsRenderingContext
&
aRenderingContext
nsIFrame
*
aForFrame
const
nsRect
&
aDirtyRect
const
nsRect
&
aBorderArea
nsStyleContext
*
aStyleContext
mozilla
:
:
PaintBorderFlags
aFlags
Sides
aSkipSides
=
Sides
(
)
)
;
static
DrawResult
PaintBorderWithStyleBorder
(
nsPresContext
*
aPresContext
nsRenderingContext
&
aRenderingContext
nsIFrame
*
aForFrame
const
nsRect
&
aDirtyRect
const
nsRect
&
aBorderArea
const
nsStyleBorder
&
aBorderStyle
nsStyleContext
*
aStyleContext
mozilla
:
:
PaintBorderFlags
aFlags
Sides
aSkipSides
=
Sides
(
)
)
;
static
void
PaintOutline
(
nsPresContext
*
aPresContext
nsRenderingContext
&
aRenderingContext
nsIFrame
*
aForFrame
const
nsRect
&
aDirtyRect
const
nsRect
&
aBorderArea
nsStyleContext
*
aStyleContext
)
;
static
void
PaintFocus
(
nsPresContext
*
aPresContext
DrawTarget
*
aDrawTarget
const
nsRect
&
aFocusRect
nscolor
aColor
)
;
static
void
PaintGradient
(
nsPresContext
*
aPresContext
nsRenderingContext
&
aRenderingContext
nsStyleGradient
*
aGradient
const
nsRect
&
aDirtyRect
const
nsRect
&
aDest
const
nsRect
&
aFill
const
nsSize
&
aRepeatSize
const
mozilla
:
:
CSSIntRect
&
aSrc
const
nsSize
&
aIntrinsiceSize
)
;
static
nsIFrame
*
FindBackgroundStyleFrame
(
nsIFrame
*
aForFrame
)
;
static
bool
IsCanvasFrame
(
nsIFrame
*
aFrame
)
;
static
bool
FindBackground
(
nsIFrame
*
aForFrame
nsStyleContext
*
*
aBackgroundSC
)
;
static
nsStyleContext
*
FindRootFrameBackground
(
nsIFrame
*
aForFrame
)
;
static
nsStyleContext
*
FindCanvasBackground
(
nsIFrame
*
aForFrame
nsIFrame
*
aRootElementFrame
)
{
MOZ_ASSERT
(
IsCanvasFrame
(
aForFrame
)
"
not
a
canvas
frame
"
)
;
if
(
aRootElementFrame
)
return
FindRootFrameBackground
(
aRootElementFrame
)
;
return
aForFrame
-
>
StyleContext
(
)
;
}
static
nsIFrame
*
FindNonTransparentBackgroundFrame
(
nsIFrame
*
aFrame
bool
aStartAtParent
=
false
)
;
static
nscolor
DetermineBackgroundColor
(
nsPresContext
*
aPresContext
nsStyleContext
*
aStyleContext
nsIFrame
*
aFrame
bool
&
aDrawBackgroundImage
bool
&
aDrawBackgroundColor
)
;
static
nsRect
ComputeImageLayerPositioningArea
(
nsPresContext
*
aPresContext
nsIFrame
*
aForFrame
const
nsRect
&
aBorderArea
const
nsStyleImageLayers
:
:
Layer
&
aLayer
nsIFrame
*
*
aAttachedToFrame
bool
*
aOutTransformedFixed
)
;
static
nsBackgroundLayerState
PrepareImageLayer
(
nsPresContext
*
aPresContext
nsIFrame
*
aForFrame
uint32_t
aFlags
const
nsRect
&
aBorderArea
const
nsRect
&
aBGClipRect
const
nsStyleImageLayers
:
:
Layer
&
aLayer
bool
*
aOutIsTransformedFixed
=
nullptr
CompositionOp
aCompositionOp
=
CompositionOp
:
:
OP_OVER
)
;
struct
ImageLayerClipState
{
nsRect
mBGClipArea
;
nsRect
mAdditionalBGClipArea
;
nsRect
mDirtyRect
;
gfxRect
mDirtyRectGfx
;
nscoord
mRadii
[
8
]
;
RectCornerRadii
mClippedRadii
;
bool
mHasRoundedCorners
;
bool
mHasAdditionalBGClipArea
;
bool
mCustomClip
;
}
;
static
void
GetImageLayerClip
(
const
nsStyleImageLayers
:
:
Layer
&
aLayer
nsIFrame
*
aForFrame
const
nsStyleBorder
&
aBorder
const
nsRect
&
aBorderArea
const
nsRect
&
aCallerDirtyRect
bool
aWillPaintBorder
nscoord
aAppUnitsPerPixel
ImageLayerClipState
*
aClipState
)
;
enum
{
PAINTBG_WILL_PAINT_BORDER
=
0x01
PAINTBG_SYNC_DECODE_IMAGES
=
0x02
PAINTBG_TO_WINDOW
=
0x04
PAINTBG_MASK_IMAGE
=
0x08
}
;
struct
PaintBGParams
{
nsPresContext
&
presCtx
;
nsRenderingContext
&
renderingCtx
;
nsRect
dirtyRect
;
nsRect
borderArea
;
nsIFrame
*
frame
;
uint32_t
paintFlags
=
0
;
nsRect
*
bgClipRect
=
nullptr
;
int32_t
layer
;
CompositionOp
compositionOp
=
CompositionOp
:
:
OP_OVER
;
static
PaintBGParams
ForAllLayers
(
nsPresContext
&
aPresCtx
nsRenderingContext
&
aRenderingCtx
const
nsRect
&
aDirtyRect
const
nsRect
&
aBorderArea
nsIFrame
*
aFrame
uint32_t
aPaintFlags
)
;
static
PaintBGParams
ForSingleLayer
(
nsPresContext
&
aPresCtx
nsRenderingContext
&
aRenderingCtx
const
nsRect
&
aDirtyRect
const
nsRect
&
aBorderArea
nsIFrame
*
aFrame
uint32_t
aPaintFlags
int32_t
aLayer
CompositionOp
aCompositionOp
=
CompositionOp
:
:
OP_OVER
)
;
private
:
PaintBGParams
(
nsPresContext
&
aPresCtx
nsRenderingContext
&
aRenderingCtx
const
nsRect
&
aDirtyRect
const
nsRect
&
aBorderArea
)
:
presCtx
(
aPresCtx
)
renderingCtx
(
aRenderingCtx
)
dirtyRect
(
aDirtyRect
)
borderArea
(
aBorderArea
)
{
}
}
;
static
DrawResult
PaintBackground
(
const
PaintBGParams
&
aParams
)
;
static
DrawResult
PaintBackgroundWithSC
(
const
PaintBGParams
&
aParams
nsStyleContext
*
mBackgroundSC
const
nsStyleBorder
&
aBorder
)
;
static
nsRect
GetBackgroundLayerRect
(
nsPresContext
*
aPresContext
nsIFrame
*
aForFrame
const
nsRect
&
aBorderArea
const
nsRect
&
aClipRect
const
nsStyleImageLayers
:
:
Layer
&
aLayer
uint32_t
aFlags
)
;
static
void
BeginFrameTreesLocked
(
)
;
static
void
EndFrameTreesLocked
(
)
;
static
void
DrawTableBorderSegment
(
DrawTarget
&
aDrawTarget
uint8_t
aBorderStyle
nscolor
aBorderColor
const
nsStyleBackground
*
aBGColor
const
nsRect
&
aBorderRect
int32_t
aAppUnitsPerDevPixel
int32_t
aAppUnitsPerCSSPixel
uint8_t
aStartBevelSide
=
0
nscoord
aStartBevelOffset
=
0
uint8_t
aEndBevelSide
=
0
nscoord
aEndBevelOffset
=
0
)
;
struct
DecorationRectParams
{
Size
lineSize
;
Float
ascent
=
0
.
0f
;
Float
offset
=
0
.
0f
;
Float
descentLimit
=
-
1
.
0f
;
uint8_t
decoration
=
NS_STYLE_TEXT_DECORATION_LINE_UNDERLINE
;
uint8_t
style
=
NS_STYLE_TEXT_DECORATION_STYLE_NONE
;
bool
vertical
=
false
;
}
;
struct
PaintDecorationLineParams
:
DecorationRectParams
{
Rect
dirtyRect
;
Point
pt
;
nscolor
color
=
NS_RGBA
(
0
0
0
0
)
;
Float
icoordInFrame
=
0
.
0f
;
}
;
static
void
PaintDecorationLine
(
nsIFrame
*
aFrame
DrawTarget
&
aDrawTarget
const
PaintDecorationLineParams
&
aParams
)
;
static
Rect
DecorationLineToPath
(
const
PaintDecorationLineParams
&
aParams
)
;
static
nsRect
GetTextDecorationRect
(
nsPresContext
*
aPresContext
const
DecorationRectParams
&
aParams
)
;
static
CompositionOp
GetGFXBlendMode
(
uint8_t
mBlendMode
)
{
switch
(
mBlendMode
)
{
case
NS_STYLE_BLEND_NORMAL
:
return
CompositionOp
:
:
OP_OVER
;
case
NS_STYLE_BLEND_MULTIPLY
:
return
CompositionOp
:
:
OP_MULTIPLY
;
case
NS_STYLE_BLEND_SCREEN
:
return
CompositionOp
:
:
OP_SCREEN
;
case
NS_STYLE_BLEND_OVERLAY
:
return
CompositionOp
:
:
OP_OVERLAY
;
case
NS_STYLE_BLEND_DARKEN
:
return
CompositionOp
:
:
OP_DARKEN
;
case
NS_STYLE_BLEND_LIGHTEN
:
return
CompositionOp
:
:
OP_LIGHTEN
;
case
NS_STYLE_BLEND_COLOR_DODGE
:
return
CompositionOp
:
:
OP_COLOR_DODGE
;
case
NS_STYLE_BLEND_COLOR_BURN
:
return
CompositionOp
:
:
OP_COLOR_BURN
;
case
NS_STYLE_BLEND_HARD_LIGHT
:
return
CompositionOp
:
:
OP_HARD_LIGHT
;
case
NS_STYLE_BLEND_SOFT_LIGHT
:
return
CompositionOp
:
:
OP_SOFT_LIGHT
;
case
NS_STYLE_BLEND_DIFFERENCE
:
return
CompositionOp
:
:
OP_DIFFERENCE
;
case
NS_STYLE_BLEND_EXCLUSION
:
return
CompositionOp
:
:
OP_EXCLUSION
;
case
NS_STYLE_BLEND_HUE
:
return
CompositionOp
:
:
OP_HUE
;
case
NS_STYLE_BLEND_SATURATION
:
return
CompositionOp
:
:
OP_SATURATION
;
case
NS_STYLE_BLEND_COLOR
:
return
CompositionOp
:
:
OP_COLOR
;
case
NS_STYLE_BLEND_LUMINOSITY
:
return
CompositionOp
:
:
OP_LUMINOSITY
;
default
:
MOZ_ASSERT
(
false
)
;
return
CompositionOp
:
:
OP_OVER
;
}
}
static
CompositionOp
GetGFXCompositeMode
(
uint8_t
aCompositeMode
)
{
switch
(
aCompositeMode
)
{
case
NS_STYLE_MASK_COMPOSITE_ADD
:
return
CompositionOp
:
:
OP_OVER
;
case
NS_STYLE_MASK_COMPOSITE_SUBSTRACT
:
return
CompositionOp
:
:
OP_OUT
;
case
NS_STYLE_MASK_COMPOSITE_INTERSECT
:
return
CompositionOp
:
:
OP_IN
;
case
NS_STYLE_MASK_COMPOSITE_EXCLUDE
:
return
CompositionOp
:
:
OP_XOR
;
default
:
MOZ_ASSERT
(
false
)
;
return
CompositionOp
:
:
OP_OVER
;
}
}
protected
:
static
gfxRect
GetTextDecorationRectInternal
(
const
Point
&
aPt
const
DecorationRectParams
&
aParams
)
;
static
Rect
ExpandPaintingRectForDecorationLine
(
nsIFrame
*
aFrame
const
uint8_t
aStyle
const
Rect
&
aClippedRect
const
Float
aICoordInFrame
const
Float
aCycleLength
bool
aVertical
)
;
}
;
class
nsContextBoxBlur
{
typedef
mozilla
:
:
gfx
:
:
Color
Color
;
typedef
mozilla
:
:
gfx
:
:
DrawTarget
DrawTarget
;
typedef
mozilla
:
:
gfx
:
:
RectCornerRadii
RectCornerRadii
;
public
:
enum
{
FORCE_MASK
=
0x01
}
;
gfxContext
*
Init
(
const
nsRect
&
aRect
nscoord
aSpreadRadius
nscoord
aBlurRadius
int32_t
aAppUnitsPerDevPixel
gfxContext
*
aDestinationCtx
const
nsRect
&
aDirtyRect
const
gfxRect
*
aSkipRect
uint32_t
aFlags
=
0
)
;
void
DoPaint
(
)
;
gfxContext
*
GetContext
(
)
;
static
nsMargin
GetBlurRadiusMargin
(
nscoord
aBlurRadius
int32_t
aAppUnitsPerDevPixel
)
;
static
void
BlurRectangle
(
gfxContext
*
aDestinationCtx
const
nsRect
&
aRect
int32_t
aAppUnitsPerDevPixel
RectCornerRadii
*
aCornerRadii
nscoord
aBlurRadius
const
Color
&
aShadowColor
const
nsRect
&
aDirtyRect
const
gfxRect
&
aSkipRect
)
;
bool
InsetBoxBlur
(
gfxContext
*
aDestinationCtx
mozilla
:
:
gfx
:
:
Rect
aDestinationRect
mozilla
:
:
gfx
:
:
Rect
aShadowClipRect
mozilla
:
:
gfx
:
:
Color
&
aShadowColor
nscoord
aBlurRadiusAppUnits
nscoord
aSpreadRadiusAppUnits
int32_t
aAppUnitsPerDevPixel
bool
aHasBorderRadius
RectCornerRadii
&
aInnerClipRectRadii
mozilla
:
:
gfx
:
:
Rect
aSkipRect
mozilla
:
:
gfx
:
:
Point
aShadowOffset
)
;
protected
:
static
void
GetBlurAndSpreadRadius
(
DrawTarget
*
aDestDrawTarget
int32_t
aAppUnitsPerDevPixel
nscoord
aBlurRadius
nscoord
aSpreadRadius
mozilla
:
:
gfx
:
:
IntSize
&
aOutBlurRadius
mozilla
:
:
gfx
:
:
IntSize
&
aOutSpreadRadius
bool
aConstrainSpreadRadius
=
true
)
;
gfxAlphaBoxBlur
mAlphaBoxBlur
;
RefPtr
<
gfxContext
>
mContext
;
gfxContext
*
mDestinationCtx
;
bool
mPreTransformed
;
}
;
#
endif
