#
include
"
mozilla
/
RestyleManagerBase
.
h
"
#
include
"
mozilla
/
StyleSetHandle
.
h
"
#
include
"
nsIFrame
.
h
"
namespace
mozilla
{
RestyleManagerBase
:
:
RestyleManagerBase
(
nsPresContext
*
aPresContext
)
:
mPresContext
(
aPresContext
)
mRestyleGeneration
(
1
)
mHoverGeneration
(
0
)
mObservingRefreshDriver
(
false
)
mInStyleRefresh
(
false
)
{
MOZ_ASSERT
(
mPresContext
)
;
}
void
RestyleManagerBase
:
:
ContentStateChangedInternal
(
Element
*
aElement
EventStates
aStateMask
nsChangeHint
*
aOutChangeHint
nsRestyleHint
*
aOutRestyleHint
)
{
MOZ_ASSERT
(
aOutChangeHint
)
;
MOZ_ASSERT
(
aOutRestyleHint
)
;
StyleSetHandle
styleSet
=
PresContext
(
)
-
>
StyleSet
(
)
;
NS_ASSERTION
(
styleSet
"
couldn
'
t
get
style
set
"
)
;
*
aOutChangeHint
=
nsChangeHint
(
0
)
;
nsIFrame
*
primaryFrame
=
aElement
-
>
GetPrimaryFrame
(
)
;
CSSPseudoElementType
pseudoType
=
CSSPseudoElementType
:
:
NotPseudo
;
if
(
primaryFrame
)
{
if
(
!
primaryFrame
-
>
IsGeneratedContentFrame
(
)
&
&
aStateMask
.
HasAtLeastOneOfStates
(
NS_EVENT_STATE_BROKEN
|
NS_EVENT_STATE_USERDISABLED
|
NS_EVENT_STATE_SUPPRESSED
|
NS_EVENT_STATE_LOADING
)
)
{
*
aOutChangeHint
=
nsChangeHint_ReconstructFrame
;
}
else
{
uint8_t
app
=
primaryFrame
-
>
StyleDisplay
(
)
-
>
mAppearance
;
if
(
app
)
{
nsITheme
*
theme
=
PresContext
(
)
-
>
GetTheme
(
)
;
if
(
theme
&
&
theme
-
>
ThemeSupportsWidget
(
PresContext
(
)
primaryFrame
app
)
)
{
bool
repaint
=
false
;
theme
-
>
WidgetStateChanged
(
primaryFrame
app
nullptr
&
repaint
nullptr
)
;
if
(
repaint
)
{
*
aOutChangeHint
|
=
nsChangeHint_RepaintFrame
;
}
}
}
}
pseudoType
=
primaryFrame
-
>
StyleContext
(
)
-
>
GetPseudoType
(
)
;
primaryFrame
-
>
ContentStatesChanged
(
aStateMask
)
;
}
if
(
pseudoType
>
=
CSSPseudoElementType
:
:
Count
)
{
*
aOutRestyleHint
=
styleSet
-
>
HasStateDependentStyle
(
aElement
aStateMask
)
;
}
else
if
(
nsCSSPseudoElements
:
:
PseudoElementSupportsUserActionState
(
pseudoType
)
)
{
Element
*
ancestor
=
ElementForStyleContext
(
nullptr
primaryFrame
pseudoType
)
;
*
aOutRestyleHint
=
styleSet
-
>
HasStateDependentStyle
(
ancestor
pseudoType
aElement
aStateMask
)
;
}
else
{
*
aOutRestyleHint
=
nsRestyleHint
(
0
)
;
}
if
(
aStateMask
.
HasState
(
NS_EVENT_STATE_HOVER
)
&
&
*
aOutRestyleHint
!
=
0
)
{
IncrementHoverGeneration
(
)
;
}
if
(
aStateMask
.
HasState
(
NS_EVENT_STATE_VISITED
)
)
{
*
aOutChangeHint
|
=
nsChangeHint_RepaintFrame
;
}
}
nsCString
RestyleManagerBase
:
:
RestyleHintToString
(
nsRestyleHint
aHint
)
{
nsCString
result
;
bool
any
=
false
;
const
char
*
names
[
]
=
{
"
Self
"
"
SomeDescendants
"
"
Subtree
"
"
LaterSiblings
"
"
CSSTransitions
"
"
CSSAnimations
"
"
SVGAttrAnimations
"
"
StyleAttribute
"
"
StyleAttribute_Animations
"
"
Force
"
"
ForceDescendants
"
}
;
uint32_t
hint
=
aHint
&
(
(
1
<
<
ArrayLength
(
names
)
)
-
1
)
;
uint32_t
rest
=
aHint
&
~
(
(
1
<
<
ArrayLength
(
names
)
)
-
1
)
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
names
)
;
i
+
+
)
{
if
(
hint
&
(
1
<
<
i
)
)
{
if
(
any
)
{
result
.
AppendLiteral
(
"
|
"
)
;
}
result
.
AppendPrintf
(
"
eRestyle_
%
s
"
names
[
i
]
)
;
any
=
true
;
}
}
if
(
rest
)
{
if
(
any
)
{
result
.
AppendLiteral
(
"
|
"
)
;
}
result
.
AppendPrintf
(
"
0x
%
0x
"
rest
)
;
}
else
{
if
(
!
any
)
{
result
.
AppendLiteral
(
"
0
"
)
;
}
}
return
result
;
}
#
ifdef
DEBUG
nsCString
RestyleManagerBase
:
:
ChangeHintToString
(
nsChangeHint
aHint
)
{
nsCString
result
;
bool
any
=
false
;
const
char
*
names
[
]
=
{
"
RepaintFrame
"
"
NeedReflow
"
"
ClearAncestorIntrinsics
"
"
ClearDescendantIntrinsics
"
"
NeedDirtyReflow
"
"
SyncFrameView
"
"
UpdateCursor
"
"
UpdateEffects
"
"
UpdateOpacityLayer
"
"
UpdateTransformLayer
"
"
ReconstructFrame
"
"
UpdateOverflow
"
"
UpdateSubtreeOverflow
"
"
UpdatePostTransformOverflow
"
"
UpdateParentOverflow
"
"
ChildrenOnlyTransform
"
"
RecomputePosition
"
"
AddOrRemoveTransform
"
"
BorderStyleNoneChange
"
"
UpdateTextPath
"
"
SchedulePaint
"
"
NeutralChange
"
"
InvalidateRenderingObservers
"
"
ReflowChangesSizeOrPosition
"
"
UpdateComputedBSize
"
"
UpdateUsesOpacity
"
"
UpdateBackgroundPosition
"
}
;
static_assert
(
nsChangeHint_AllHints
=
=
(
1
<
<
ArrayLength
(
names
)
)
-
1
"
Name
list
doesn
'
t
match
change
hints
.
"
)
;
uint32_t
hint
=
aHint
&
(
(
1
<
<
ArrayLength
(
names
)
)
-
1
)
;
uint32_t
rest
=
aHint
&
~
(
(
1
<
<
ArrayLength
(
names
)
)
-
1
)
;
if
(
hint
=
=
nsChangeHint_Hints_NotHandledForDescendants
)
{
result
.
AppendLiteral
(
"
nsChangeHint_Hints_NotHandledForDescendants
"
)
;
hint
=
0
;
any
=
true
;
}
else
{
if
(
(
hint
&
NS_STYLE_HINT_REFLOW
)
=
=
NS_STYLE_HINT_REFLOW
)
{
result
.
AppendLiteral
(
"
NS_STYLE_HINT_REFLOW
"
)
;
hint
=
hint
&
~
NS_STYLE_HINT_REFLOW
;
any
=
true
;
}
else
if
(
(
hint
&
nsChangeHint_AllReflowHints
)
=
=
nsChangeHint_AllReflowHints
)
{
result
.
AppendLiteral
(
"
nsChangeHint_AllReflowHints
"
)
;
hint
=
hint
&
~
nsChangeHint_AllReflowHints
;
any
=
true
;
}
else
if
(
(
hint
&
NS_STYLE_HINT_VISUAL
)
=
=
NS_STYLE_HINT_VISUAL
)
{
result
.
AppendLiteral
(
"
NS_STYLE_HINT_VISUAL
"
)
;
hint
=
hint
&
~
NS_STYLE_HINT_VISUAL
;
any
=
true
;
}
}
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
names
)
;
i
+
+
)
{
if
(
hint
&
(
1
<
<
i
)
)
{
if
(
any
)
{
result
.
AppendLiteral
(
"
|
"
)
;
}
result
.
AppendPrintf
(
"
nsChangeHint_
%
s
"
names
[
i
]
)
;
any
=
true
;
}
}
if
(
rest
)
{
if
(
any
)
{
result
.
AppendLiteral
(
"
|
"
)
;
}
result
.
AppendPrintf
(
"
0x
%
0x
"
rest
)
;
}
else
{
if
(
!
any
)
{
result
.
AppendLiteral
(
"
nsChangeHint
(
0
)
"
)
;
}
}
return
result
;
}
#
endif
void
RestyleManagerBase
:
:
PostRestyleEventInternal
(
bool
aForLazyConstruction
)
{
bool
inRefresh
=
!
aForLazyConstruction
&
&
mInStyleRefresh
;
nsIPresShell
*
presShell
=
PresContext
(
)
-
>
PresShell
(
)
;
if
(
!
ObservingRefreshDriver
(
)
&
&
!
inRefresh
)
{
SetObservingRefreshDriver
(
PresContext
(
)
-
>
RefreshDriver
(
)
-
>
AddStyleFlushObserver
(
presShell
)
)
;
}
presShell
-
>
GetDocument
(
)
-
>
SetNeedStyleFlush
(
)
;
}
#
ifdef
DEBUG
static
bool
gInApplyRenderingChangeToTree
=
false
;
#
endif
#
ifdef
DEBUG
static
void
DumpContext
(
nsIFrame
*
aFrame
nsStyleContext
*
aContext
)
{
if
(
aFrame
)
{
fputs
(
"
frame
:
"
stdout
)
;
nsAutoString
name
;
aFrame
-
>
GetFrameName
(
name
)
;
fputs
(
NS_LossyConvertUTF16toASCII
(
name
)
.
get
(
)
stdout
)
;
fprintf
(
stdout
"
(
%
p
)
"
static_cast
<
void
*
>
(
aFrame
)
)
;
}
if
(
aContext
)
{
fprintf
(
stdout
"
style
:
%
p
"
static_cast
<
void
*
>
(
aContext
)
)
;
nsIAtom
*
pseudoTag
=
aContext
-
>
GetPseudo
(
)
;
if
(
pseudoTag
)
{
nsAutoString
buffer
;
pseudoTag
-
>
ToString
(
buffer
)
;
fputs
(
NS_LossyConvertUTF16toASCII
(
buffer
)
.
get
(
)
stdout
)
;
fputs
(
"
"
stdout
)
;
}
fputs
(
"
{
}
\
n
"
stdout
)
;
}
}
static
void
VerifySameTree
(
nsStyleContext
*
aContext1
nsStyleContext
*
aContext2
)
{
nsStyleContext
*
top1
=
aContext1
;
nsStyleContext
*
top2
=
aContext2
;
nsStyleContext
*
parent
;
for
(
;
;
)
{
parent
=
top1
-
>
GetParent
(
)
;
if
(
!
parent
)
break
;
top1
=
parent
;
}
for
(
;
;
)
{
parent
=
top2
-
>
GetParent
(
)
;
if
(
!
parent
)
break
;
top2
=
parent
;
}
NS_ASSERTION
(
top1
=
=
top2
"
Style
contexts
are
not
in
the
same
style
context
tree
"
)
;
}
static
void
VerifyContextParent
(
nsIFrame
*
aFrame
nsStyleContext
*
aContext
nsStyleContext
*
aParentContext
)
{
if
(
!
aContext
)
{
aContext
=
aFrame
-
>
StyleContext
(
)
;
}
if
(
!
aParentContext
)
{
nsIFrame
*
providerFrame
;
aParentContext
=
aFrame
-
>
GetParentStyleContext
(
&
providerFrame
)
;
}
NS_ASSERTION
(
aContext
"
Failure
to
get
required
contexts
"
)
;
nsStyleContext
*
actualParentContext
=
aContext
-
>
GetParent
(
)
;
if
(
aParentContext
)
{
if
(
aParentContext
!
=
actualParentContext
)
{
DumpContext
(
aFrame
aContext
)
;
if
(
aContext
=
=
aParentContext
)
{
NS_ERROR
(
"
Using
parent
'
s
style
context
"
)
;
}
else
{
NS_ERROR
(
"
Wrong
parent
style
context
"
)
;
fputs
(
"
Wrong
parent
style
context
:
"
stdout
)
;
DumpContext
(
nullptr
actualParentContext
)
;
fputs
(
"
should
be
using
:
"
stdout
)
;
DumpContext
(
nullptr
aParentContext
)
;
VerifySameTree
(
actualParentContext
aParentContext
)
;
fputs
(
"
\
n
"
stdout
)
;
}
}
}
else
{
if
(
actualParentContext
)
{
NS_ERROR
(
"
Have
parent
context
and
shouldn
'
t
"
)
;
DumpContext
(
aFrame
aContext
)
;
fputs
(
"
Has
parent
context
:
"
stdout
)
;
DumpContext
(
nullptr
actualParentContext
)
;
fputs
(
"
Should
be
null
\
n
\
n
"
stdout
)
;
}
}
nsStyleContext
*
childStyleIfVisited
=
aContext
-
>
GetStyleIfVisited
(
)
;
if
(
childStyleIfVisited
&
&
!
(
(
childStyleIfVisited
-
>
RuleNode
(
)
!
=
aContext
-
>
RuleNode
(
)
&
&
childStyleIfVisited
-
>
GetParent
(
)
=
=
aContext
-
>
GetParent
(
)
)
|
|
childStyleIfVisited
-
>
GetParent
(
)
=
=
aContext
-
>
GetParent
(
)
-
>
GetStyleIfVisited
(
)
)
)
{
NS_ERROR
(
"
Visited
style
has
wrong
parent
"
)
;
DumpContext
(
aFrame
aContext
)
;
fputs
(
"
\
n
"
stdout
)
;
}
}
static
void
VerifyStyleTree
(
nsIFrame
*
aFrame
)
{
nsStyleContext
*
context
=
aFrame
-
>
StyleContext
(
)
;
VerifyContextParent
(
aFrame
context
nullptr
)
;
nsIFrame
:
:
ChildListIterator
lists
(
aFrame
)
;
for
(
;
!
lists
.
IsDone
(
)
;
lists
.
Next
(
)
)
{
for
(
nsIFrame
*
child
:
lists
.
CurrentList
(
)
)
{
if
(
!
(
child
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
)
{
if
(
nsGkAtoms
:
:
placeholderFrame
=
=
child
-
>
GetType
(
)
)
{
nsIFrame
*
outOfFlowFrame
=
nsPlaceholderFrame
:
:
GetRealFrameForPlaceholder
(
child
)
;
do
{
VerifyStyleTree
(
outOfFlowFrame
)
;
}
while
(
(
outOfFlowFrame
=
outOfFlowFrame
-
>
GetNextContinuation
(
)
)
)
;
VerifyContextParent
(
child
nullptr
nullptr
)
;
}
else
{
VerifyStyleTree
(
child
)
;
}
}
}
}
int32_t
contextIndex
=
0
;
for
(
nsStyleContext
*
extraContext
;
(
extraContext
=
aFrame
-
>
GetAdditionalStyleContext
(
contextIndex
)
)
;
+
+
contextIndex
)
{
VerifyContextParent
(
aFrame
extraContext
context
)
;
}
}
void
RestyleManagerBase
:
:
DebugVerifyStyleTree
(
nsIFrame
*
aFrame
)
{
if
(
aFrame
)
{
VerifyStyleTree
(
aFrame
)
;
}
}
#
endif
NS_DECLARE_FRAME_PROPERTY_SMALL_VALUE
(
ChangeListProperty
bool
)
static
void
SyncViewsAndInvalidateDescendants
(
nsIFrame
*
aFrame
nsChangeHint
aChange
)
;
static
void
StyleChangeReflow
(
nsIFrame
*
aFrame
nsChangeHint
aHint
)
;
static
nsIFrame
*
GetFrameForChildrenOnlyTransformHint
(
nsIFrame
*
aFrame
)
{
if
(
aFrame
-
>
GetType
(
)
=
=
nsGkAtoms
:
:
viewportFrame
)
{
aFrame
=
aFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
}
aFrame
=
aFrame
-
>
GetContent
(
)
-
>
GetPrimaryFrame
(
)
;
if
(
aFrame
-
>
GetType
(
)
=
=
nsGkAtoms
:
:
svgOuterSVGFrame
)
{
aFrame
=
aFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
MOZ_ASSERT
(
aFrame
-
>
GetType
(
)
=
=
nsGkAtoms
:
:
svgOuterSVGAnonChildFrame
"
Where
is
the
nsSVGOuterSVGFrame
'
s
anon
child
?
?
"
)
;
}
MOZ_ASSERT
(
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
|
nsIFrame
:
:
eSVGContainer
)
"
Children
-
only
transforms
only
expected
on
SVG
frames
"
)
;
return
aFrame
;
}
bool
RecomputePosition
(
nsIFrame
*
aFrame
)
{
if
(
aFrame
-
>
GetType
(
)
=
=
nsGkAtoms
:
:
tableFrame
)
{
return
true
;
}
const
nsStyleDisplay
*
display
=
aFrame
-
>
StyleDisplay
(
)
;
if
(
display
-
>
mPosition
=
=
NS_STYLE_POSITION_STATIC
)
{
return
true
;
}
if
(
aFrame
-
>
HasView
(
)
|
|
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_HAS_CHILD_WITH_VIEW
)
)
{
StyleChangeReflow
(
aFrame
nsChangeHint_NeedReflow
)
;
return
false
;
}
aFrame
-
>
SchedulePaint
(
)
;
if
(
display
-
>
IsRelativelyPositionedStyle
(
)
)
{
if
(
display
-
>
mPosition
=
=
NS_STYLE_POSITION_STICKY
)
{
if
(
display
-
>
IsInnerTableStyle
(
)
)
{
return
true
;
}
nsIFrame
*
firstContinuation
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
aFrame
)
;
StickyScrollContainer
:
:
ComputeStickyOffsets
(
firstContinuation
)
;
StickyScrollContainer
*
ssc
=
StickyScrollContainer
:
:
GetStickyScrollContainerForFrame
(
firstContinuation
)
;
if
(
ssc
)
{
ssc
-
>
PositionContinuations
(
firstContinuation
)
;
}
}
else
{
MOZ_ASSERT
(
NS_STYLE_POSITION_RELATIVE
=
=
display
-
>
mPosition
"
Unexpected
type
of
positioning
"
)
;
for
(
nsIFrame
*
cont
=
aFrame
;
cont
;
cont
=
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
cont
)
)
{
nsIFrame
*
cb
=
cont
-
>
GetContainingBlock
(
)
;
nsMargin
newOffsets
;
WritingMode
wm
=
cb
-
>
GetWritingMode
(
)
;
const
LogicalSize
size
(
wm
cb
-
>
GetContentRectRelativeToSelf
(
)
.
Size
(
)
)
;
ReflowInput
:
:
ComputeRelativeOffsets
(
wm
cont
size
newOffsets
)
;
NS_ASSERTION
(
newOffsets
.
left
=
=
-
newOffsets
.
right
&
&
newOffsets
.
top
=
=
-
newOffsets
.
bottom
"
ComputeRelativeOffsets
should
return
valid
results
"
)
;
nsPoint
normalPosition
=
cont
-
>
GetNormalPosition
(
)
;
auto
props
=
cont
-
>
Properties
(
)
;
const
auto
&
prop
=
nsIFrame
:
:
NormalPositionProperty
(
)
;
if
(
!
props
.
Get
(
prop
)
)
{
props
.
Set
(
prop
new
nsPoint
(
normalPosition
)
)
;
}
cont
-
>
SetPosition
(
normalPosition
+
nsPoint
(
newOffsets
.
left
newOffsets
.
top
)
)
;
}
}
return
true
;
}
nsRenderingContext
rc
(
aFrame
-
>
PresContext
(
)
-
>
PresShell
(
)
-
>
CreateReferenceRenderingContext
(
)
)
;
nsIFrame
*
parentFrame
=
aFrame
-
>
GetParent
(
)
;
WritingMode
parentWM
=
parentFrame
-
>
GetWritingMode
(
)
;
WritingMode
frameWM
=
aFrame
-
>
GetWritingMode
(
)
;
LogicalSize
parentSize
=
parentFrame
-
>
GetLogicalSize
(
)
;
nsFrameState
savedState
=
parentFrame
-
>
GetStateBits
(
)
;
ReflowInput
parentReflowInput
(
aFrame
-
>
PresContext
(
)
parentFrame
&
rc
parentSize
)
;
parentFrame
-
>
RemoveStateBits
(
~
nsFrameState
(
0
)
)
;
parentFrame
-
>
AddStateBits
(
savedState
)
;
Maybe
<
ReflowInput
>
cbReflowInput
;
nsIFrame
*
cbFrame
=
parentFrame
-
>
GetContainingBlock
(
)
;
if
(
cbFrame
&
&
(
aFrame
-
>
GetContainingBlock
(
)
!
=
parentFrame
|
|
parentFrame
-
>
GetType
(
)
=
=
nsGkAtoms
:
:
tableFrame
)
)
{
LogicalSize
cbSize
=
cbFrame
-
>
GetLogicalSize
(
)
;
cbReflowInput
.
emplace
(
cbFrame
-
>
PresContext
(
)
cbFrame
&
rc
cbSize
)
;
cbReflowInput
-
>
ComputedPhysicalMargin
(
)
=
cbFrame
-
>
GetUsedMargin
(
)
;
cbReflowInput
-
>
ComputedPhysicalPadding
(
)
=
cbFrame
-
>
GetUsedPadding
(
)
;
cbReflowInput
-
>
ComputedPhysicalBorderPadding
(
)
=
cbFrame
-
>
GetUsedBorderAndPadding
(
)
;
parentReflowInput
.
mCBReflowInput
=
cbReflowInput
.
ptr
(
)
;
}
NS_WARNING_ASSERTION
(
parentSize
.
ISize
(
parentWM
)
!
=
NS_INTRINSICSIZE
&
&
parentSize
.
BSize
(
parentWM
)
!
=
NS_INTRINSICSIZE
"
parentSize
should
be
valid
"
)
;
parentReflowInput
.
SetComputedISize
(
std
:
:
max
(
parentSize
.
ISize
(
parentWM
)
0
)
)
;
parentReflowInput
.
SetComputedBSize
(
std
:
:
max
(
parentSize
.
BSize
(
parentWM
)
0
)
)
;
parentReflowInput
.
ComputedPhysicalMargin
(
)
.
SizeTo
(
0
0
0
0
)
;
parentReflowInput
.
ComputedPhysicalPadding
(
)
=
parentFrame
-
>
GetUsedPadding
(
)
;
parentReflowInput
.
ComputedPhysicalBorderPadding
(
)
=
parentFrame
-
>
GetUsedBorderAndPadding
(
)
;
LogicalSize
availSize
=
parentSize
.
ConvertTo
(
frameWM
parentWM
)
;
availSize
.
BSize
(
frameWM
)
=
NS_INTRINSICSIZE
;
ViewportFrame
*
viewport
=
do_QueryFrame
(
parentFrame
)
;
nsSize
cbSize
=
viewport
?
viewport
-
>
AdjustReflowInputAsContainingBlock
(
&
parentReflowInput
)
.
Size
(
)
:
aFrame
-
>
GetContainingBlock
(
)
-
>
GetSize
(
)
;
const
nsMargin
&
parentBorder
=
parentReflowInput
.
mStyleBorder
-
>
GetComputedBorder
(
)
;
cbSize
-
=
nsSize
(
parentBorder
.
LeftRight
(
)
parentBorder
.
TopBottom
(
)
)
;
LogicalSize
lcbSize
(
frameWM
cbSize
)
;
ReflowInput
reflowInput
(
aFrame
-
>
PresContext
(
)
parentReflowInput
aFrame
availSize
&
lcbSize
)
;
nsSize
computedSize
(
reflowInput
.
ComputedWidth
(
)
reflowInput
.
ComputedHeight
(
)
)
;
computedSize
.
width
+
=
reflowInput
.
ComputedPhysicalBorderPadding
(
)
.
LeftRight
(
)
;
if
(
computedSize
.
height
!
=
NS_INTRINSICSIZE
)
{
computedSize
.
height
+
=
reflowInput
.
ComputedPhysicalBorderPadding
(
)
.
TopBottom
(
)
;
}
nsSize
size
=
aFrame
-
>
GetSize
(
)
;
if
(
computedSize
.
width
=
=
size
.
width
&
&
(
computedSize
.
height
=
=
NS_INTRINSICSIZE
|
|
computedSize
.
height
=
=
size
.
height
)
)
{
if
(
NS_AUTOOFFSET
=
=
reflowInput
.
ComputedPhysicalOffsets
(
)
.
left
)
{
reflowInput
.
ComputedPhysicalOffsets
(
)
.
left
=
cbSize
.
width
-
reflowInput
.
ComputedPhysicalOffsets
(
)
.
right
-
reflowInput
.
ComputedPhysicalMargin
(
)
.
right
-
size
.
width
-
reflowInput
.
ComputedPhysicalMargin
(
)
.
left
;
}
if
(
NS_AUTOOFFSET
=
=
reflowInput
.
ComputedPhysicalOffsets
(
)
.
top
)
{
reflowInput
.
ComputedPhysicalOffsets
(
)
.
top
=
cbSize
.
height
-
reflowInput
.
ComputedPhysicalOffsets
(
)
.
bottom
-
reflowInput
.
ComputedPhysicalMargin
(
)
.
bottom
-
size
.
height
-
reflowInput
.
ComputedPhysicalMargin
(
)
.
top
;
}
nsPoint
pos
(
parentBorder
.
left
+
reflowInput
.
ComputedPhysicalOffsets
(
)
.
left
+
reflowInput
.
ComputedPhysicalMargin
(
)
.
left
parentBorder
.
top
+
reflowInput
.
ComputedPhysicalOffsets
(
)
.
top
+
reflowInput
.
ComputedPhysicalMargin
(
)
.
top
)
;
aFrame
-
>
SetPosition
(
pos
)
;
return
true
;
}
StyleChangeReflow
(
aFrame
nsChangeHint_NeedReflow
)
;
return
false
;
}
static
bool
HasBoxAncestor
(
nsIFrame
*
aFrame
)
{
for
(
nsIFrame
*
f
=
aFrame
;
f
;
f
=
f
-
>
GetParent
(
)
)
{
if
(
f
-
>
IsXULBoxFrame
(
)
)
{
return
true
;
}
}
return
false
;
}
static
bool
FrameHasPositionedPlaceholderDescendants
(
nsIFrame
*
aFrame
uint32_t
aPositionMask
)
{
MOZ_ASSERT
(
aPositionMask
&
(
1
<
<
NS_STYLE_POSITION_FIXED
)
)
;
for
(
nsIFrame
:
:
ChildListIterator
lists
(
aFrame
)
;
!
lists
.
IsDone
(
)
;
lists
.
Next
(
)
)
{
for
(
nsIFrame
*
f
:
lists
.
CurrentList
(
)
)
{
if
(
f
-
>
GetType
(
)
=
=
nsGkAtoms
:
:
placeholderFrame
)
{
nsIFrame
*
outOfFlow
=
nsPlaceholderFrame
:
:
GetRealFrameForPlaceholder
(
f
)
;
NS_ASSERTION
(
!
outOfFlow
-
>
IsSVGText
(
)
"
SVG
text
frames
can
'
t
be
out
of
flow
"
)
;
if
(
aPositionMask
&
(
1
<
<
outOfFlow
-
>
StyleDisplay
(
)
-
>
mPosition
)
)
{
return
true
;
}
}
uint32_t
positionMask
=
aPositionMask
;
if
(
f
-
>
IsAbsPosContainingBlock
(
)
)
{
if
(
f
-
>
IsFixedPosContainingBlock
(
)
)
{
continue
;
}
positionMask
=
(
1
<
<
NS_STYLE_POSITION_FIXED
)
;
}
if
(
FrameHasPositionedPlaceholderDescendants
(
f
positionMask
)
)
{
return
true
;
}
}
}
return
false
;
}
static
bool
NeedToReframeForAddingOrRemovingTransform
(
nsIFrame
*
aFrame
)
{
static_assert
(
0
<
=
NS_STYLE_POSITION_ABSOLUTE
&
&
NS_STYLE_POSITION_ABSOLUTE
<
32
"
Style
constant
out
of
range
"
)
;
static_assert
(
0
<
=
NS_STYLE_POSITION_FIXED
&
&
NS_STYLE_POSITION_FIXED
<
32
"
Style
constant
out
of
range
"
)
;
uint32_t
positionMask
;
if
(
aFrame
-
>
IsAbsolutelyPositioned
(
)
|
|
aFrame
-
>
IsRelativelyPositioned
(
)
)
{
positionMask
=
1
<
<
NS_STYLE_POSITION_FIXED
;
}
else
{
positionMask
=
(
1
<
<
NS_STYLE_POSITION_FIXED
)
|
(
1
<
<
NS_STYLE_POSITION_ABSOLUTE
)
;
}
for
(
nsIFrame
*
f
=
aFrame
;
f
;
f
=
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
f
)
)
{
if
(
FrameHasPositionedPlaceholderDescendants
(
f
positionMask
)
)
{
return
true
;
}
}
return
false
;
}
nsIFrame
*
RestyleManagerBase
:
:
GetNearestAncestorFrame
(
nsIContent
*
aContent
)
{
nsIFrame
*
ancestorFrame
=
nullptr
;
for
(
nsIContent
*
ancestor
=
aContent
-
>
GetParent
(
)
;
ancestor
&
&
!
ancestorFrame
;
ancestor
=
ancestor
-
>
GetParent
(
)
)
{
ancestorFrame
=
ancestor
-
>
GetPrimaryFrame
(
)
;
}
return
ancestorFrame
;
}
nsIFrame
*
RestyleManagerBase
:
:
GetNextBlockInInlineSibling
(
FramePropertyTable
*
aPropTable
nsIFrame
*
aFrame
)
{
NS_ASSERTION
(
!
aFrame
-
>
GetPrevContinuation
(
)
"
must
start
with
the
first
continuation
"
)
;
if
(
!
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_PART_OF_IBSPLIT
)
)
{
return
nullptr
;
}
return
static_cast
<
nsIFrame
*
>
(
aPropTable
-
>
Get
(
aFrame
nsIFrame
:
:
IBSplitSibling
(
)
)
)
;
}
static
void
DoApplyRenderingChangeToTree
(
nsIFrame
*
aFrame
nsChangeHint
aChange
)
{
NS_PRECONDITION
(
gInApplyRenderingChangeToTree
"
should
only
be
called
within
ApplyRenderingChangeToTree
"
)
;
for
(
;
aFrame
;
aFrame
=
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
aFrame
)
)
{
SyncViewsAndInvalidateDescendants
(
aFrame
nsChangeHint
(
aChange
&
(
nsChangeHint_RepaintFrame
|
nsChangeHint_SyncFrameView
|
nsChangeHint_UpdateOpacityLayer
|
nsChangeHint_SchedulePaint
)
)
)
;
bool
needInvalidatingPaint
=
false
;
if
(
aChange
&
nsChangeHint_RepaintFrame
)
{
needInvalidatingPaint
=
true
;
aFrame
-
>
InvalidateFrameSubtree
(
)
;
if
(
(
aChange
&
nsChangeHint_UpdateEffects
)
&
&
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
&
&
!
(
aFrame
-
>
GetStateBits
(
)
&
NS_STATE_IS_OUTER_SVG
)
)
{
nsSVGUtils
:
:
ScheduleReflowSVG
(
aFrame
)
;
}
}
if
(
aChange
&
nsChangeHint_UpdateTextPath
)
{
if
(
aFrame
-
>
IsSVGText
(
)
)
{
NS_ASSERTION
(
aFrame
-
>
GetContent
(
)
-
>
IsSVGElement
(
nsGkAtoms
:
:
textPath
)
"
expected
frame
for
a
<
textPath
>
element
"
)
;
nsIFrame
*
text
=
nsLayoutUtils
:
:
GetClosestFrameOfType
(
aFrame
nsGkAtoms
:
:
svgTextFrame
)
;
NS_ASSERTION
(
text
"
expected
to
find
an
ancestor
SVGTextFrame
"
)
;
static_cast
<
SVGTextFrame
*
>
(
text
)
-
>
NotifyGlyphMetricsChange
(
)
;
}
else
{
MOZ_ASSERT
(
false
"
unexpected
frame
got
nsChangeHint_UpdateTextPath
"
)
;
}
}
if
(
aChange
&
nsChangeHint_UpdateOpacityLayer
)
{
needInvalidatingPaint
=
true
;
ActiveLayerTracker
:
:
NotifyRestyle
(
aFrame
eCSSProperty_opacity
)
;
if
(
nsSVGIntegrationUtils
:
:
UsingEffectsForFrame
(
aFrame
)
)
{
aFrame
-
>
InvalidateFrameSubtree
(
)
;
}
}
if
(
(
aChange
&
nsChangeHint_UpdateTransformLayer
)
&
&
aFrame
-
>
IsTransformed
(
)
)
{
ActiveLayerTracker
:
:
NotifyRestyle
(
aFrame
eCSSProperty_transform
)
;
if
(
!
needInvalidatingPaint
)
{
Layer
*
layer
;
needInvalidatingPaint
|
=
!
aFrame
-
>
TryUpdateTransformOnly
(
&
layer
)
;
if
(
!
needInvalidatingPaint
)
{
MOZ_ASSERT
(
layer
"
this
can
'
t
happen
if
there
'
s
no
layer
"
)
;
nsDisplayListBuilder
:
:
AddAnimationsAndTransitionsToLayer
(
layer
nullptr
nullptr
aFrame
eCSSProperty_transform
)
;
}
}
}
if
(
aChange
&
nsChangeHint_ChildrenOnlyTransform
)
{
needInvalidatingPaint
=
true
;
nsIFrame
*
childFrame
=
GetFrameForChildrenOnlyTransformHint
(
aFrame
)
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
for
(
;
childFrame
;
childFrame
=
childFrame
-
>
GetNextSibling
(
)
)
{
ActiveLayerTracker
:
:
NotifyRestyle
(
childFrame
eCSSProperty_transform
)
;
}
}
if
(
aChange
&
nsChangeHint_SchedulePaint
)
{
needInvalidatingPaint
=
true
;
}
aFrame
-
>
SchedulePaint
(
needInvalidatingPaint
?
nsIFrame
:
:
PAINT_DEFAULT
:
nsIFrame
:
:
PAINT_COMPOSITE_ONLY
)
;
}
}
static
void
SyncViewsAndInvalidateDescendants
(
nsIFrame
*
aFrame
nsChangeHint
aChange
)
{
NS_PRECONDITION
(
gInApplyRenderingChangeToTree
"
should
only
be
called
within
ApplyRenderingChangeToTree
"
)
;
NS_ASSERTION
(
nsChangeHint_size_t
(
aChange
)
=
=
(
aChange
&
(
nsChangeHint_RepaintFrame
|
nsChangeHint_SyncFrameView
|
nsChangeHint_UpdateOpacityLayer
|
nsChangeHint_SchedulePaint
)
)
"
Invalid
change
flag
"
)
;
nsView
*
view
=
aFrame
-
>
GetView
(
)
;
if
(
view
)
{
if
(
aChange
&
nsChangeHint_SyncFrameView
)
{
nsContainerFrame
:
:
SyncFrameViewProperties
(
aFrame
-
>
PresContext
(
)
aFrame
nullptr
view
)
;
}
}
nsIFrame
:
:
ChildListIterator
lists
(
aFrame
)
;
for
(
;
!
lists
.
IsDone
(
)
;
lists
.
Next
(
)
)
{
for
(
nsIFrame
*
child
:
lists
.
CurrentList
(
)
)
{
if
(
!
(
child
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
)
{
if
(
nsGkAtoms
:
:
placeholderFrame
=
=
child
-
>
GetType
(
)
)
{
nsIFrame
*
outOfFlowFrame
=
nsPlaceholderFrame
:
:
GetRealFrameForPlaceholder
(
child
)
;
DoApplyRenderingChangeToTree
(
outOfFlowFrame
aChange
)
;
}
else
if
(
lists
.
CurrentID
(
)
=
=
nsIFrame
:
:
kPopupList
)
{
DoApplyRenderingChangeToTree
(
child
aChange
)
;
}
else
{
SyncViewsAndInvalidateDescendants
(
child
aChange
)
;
}
}
}
}
}
static
void
ApplyRenderingChangeToTree
(
nsIPresShell
*
aPresShell
nsIFrame
*
aFrame
nsChangeHint
aChange
)
{
NS_ASSERTION
(
!
(
aChange
&
nsChangeHint_UpdateTransformLayer
)
|
|
aFrame
-
>
IsTransformed
(
)
|
|
aFrame
-
>
StyleDisplay
(
)
-
>
HasTransformStyle
(
)
"
Unexpected
UpdateTransformLayer
hint
"
)
;
if
(
aPresShell
-
>
IsPaintingSuppressed
(
)
)
{
aChange
&
=
~
nsChangeHint_RepaintFrame
;
if
(
!
aChange
)
{
return
;
}
}
#
ifdef
DEBUG
gInApplyRenderingChangeToTree
=
true
;
#
endif
if
(
aChange
&
nsChangeHint_RepaintFrame
)
{
nsStyleContext
*
bgSC
;
nsIFrame
*
propagatedFrame
=
aFrame
;
while
(
!
nsCSSRendering
:
:
FindBackground
(
propagatedFrame
&
bgSC
)
)
{
propagatedFrame
=
propagatedFrame
-
>
GetParent
(
)
;
NS_ASSERTION
(
aFrame
"
root
frame
must
paint
"
)
;
}
if
(
propagatedFrame
!
=
aFrame
)
{
DoApplyRenderingChangeToTree
(
propagatedFrame
nsChangeHint_RepaintFrame
)
;
aChange
&
=
~
nsChangeHint_RepaintFrame
;
if
(
!
aChange
)
{
return
;
}
}
}
DoApplyRenderingChangeToTree
(
aFrame
aChange
)
;
#
ifdef
DEBUG
gInApplyRenderingChangeToTree
=
false
;
#
endif
}
static
void
AddSubtreeToOverflowTracker
(
nsIFrame
*
aFrame
OverflowChangedTracker
&
aOverflowChangedTracker
)
{
if
(
aFrame
-
>
FrameMaintainsOverflow
(
)
)
{
aOverflowChangedTracker
.
AddFrame
(
aFrame
OverflowChangedTracker
:
:
CHILDREN_CHANGED
)
;
}
nsIFrame
:
:
ChildListIterator
lists
(
aFrame
)
;
for
(
;
!
lists
.
IsDone
(
)
;
lists
.
Next
(
)
)
{
for
(
nsIFrame
*
child
:
lists
.
CurrentList
(
)
)
{
AddSubtreeToOverflowTracker
(
child
aOverflowChangedTracker
)
;
}
}
}
static
void
StyleChangeReflow
(
nsIFrame
*
aFrame
nsChangeHint
aHint
)
{
nsIPresShell
:
:
IntrinsicDirty
dirtyType
;
if
(
aHint
&
nsChangeHint_ClearDescendantIntrinsics
)
{
NS_ASSERTION
(
aHint
&
nsChangeHint_ClearAncestorIntrinsics
"
Please
read
the
comments
in
nsChangeHint
.
h
"
)
;
NS_ASSERTION
(
aHint
&
nsChangeHint_NeedDirtyReflow
"
ClearDescendantIntrinsics
requires
NeedDirtyReflow
"
)
;
dirtyType
=
nsIPresShell
:
:
eStyleChange
;
}
else
if
(
(
aHint
&
nsChangeHint_UpdateComputedBSize
)
&
&
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_DESCENDANT_INTRINSIC_ISIZE_DEPENDS_ON_BSIZE
)
)
{
dirtyType
=
nsIPresShell
:
:
eStyleChange
;
}
else
if
(
aHint
&
nsChangeHint_ClearAncestorIntrinsics
)
{
dirtyType
=
nsIPresShell
:
:
eTreeChange
;
}
else
if
(
(
aHint
&
nsChangeHint_UpdateComputedBSize
)
&
&
HasBoxAncestor
(
aFrame
)
)
{
dirtyType
=
nsIPresShell
:
:
eTreeChange
;
}
else
{
dirtyType
=
nsIPresShell
:
:
eResize
;
}
nsFrameState
dirtyBits
;
if
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_FIRST_REFLOW
)
{
dirtyBits
=
nsFrameState
(
0
)
;
}
else
if
(
(
aHint
&
nsChangeHint_NeedDirtyReflow
)
|
|
dirtyType
=
=
nsIPresShell
:
:
eStyleChange
)
{
dirtyBits
=
NS_FRAME_IS_DIRTY
;
}
else
{
dirtyBits
=
NS_FRAME_HAS_DIRTY_CHILDREN
;
}
if
(
dirtyType
=
=
nsIPresShell
:
:
eResize
&
&
!
dirtyBits
)
return
;
nsIPresShell
:
:
ReflowRootHandling
rootHandling
;
if
(
aHint
&
nsChangeHint_ReflowChangesSizeOrPosition
)
{
rootHandling
=
nsIPresShell
:
:
ePositionOrSizeChange
;
}
else
{
rootHandling
=
nsIPresShell
:
:
eNoPositionOrSizeChange
;
}
do
{
aFrame
-
>
PresContext
(
)
-
>
PresShell
(
)
-
>
FrameNeedsReflow
(
aFrame
dirtyType
dirtyBits
rootHandling
)
;
aFrame
=
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
aFrame
)
;
}
while
(
aFrame
)
;
}
nsIFrame
*
RestyleManagerBase
:
:
GetNextContinuationWithSameStyle
(
nsIFrame
*
aFrame
nsStyleContext
*
aOldStyleContext
bool
*
aHaveMoreContinuations
)
{
nsIFrame
*
nextContinuation
=
aFrame
-
>
GetNextContinuation
(
)
;
if
(
!
nextContinuation
&
&
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_PART_OF_IBSPLIT
)
)
{
nextContinuation
=
aFrame
-
>
FirstContinuation
(
)
-
>
Properties
(
)
.
Get
(
nsIFrame
:
:
IBSplitSibling
(
)
)
;
if
(
nextContinuation
)
{
nextContinuation
=
nextContinuation
-
>
Properties
(
)
.
Get
(
nsIFrame
:
:
IBSplitSibling
(
)
)
;
}
}
if
(
!
nextContinuation
)
{
return
nullptr
;
}
NS_ASSERTION
(
nextContinuation
-
>
GetContent
(
)
=
=
aFrame
-
>
GetContent
(
)
"
unexpected
content
mismatch
"
)
;
nsStyleContext
*
nextStyle
=
nextContinuation
-
>
StyleContext
(
)
;
if
(
nextStyle
!
=
aOldStyleContext
)
{
NS_ASSERTION
(
aOldStyleContext
-
>
GetPseudo
(
)
!
=
nextStyle
-
>
GetPseudo
(
)
|
|
aOldStyleContext
-
>
GetParent
(
)
!
=
nextStyle
-
>
GetParent
(
)
"
continuations
should
have
the
same
style
context
"
)
;
nextContinuation
=
nullptr
;
if
(
aHaveMoreContinuations
)
{
*
aHaveMoreContinuations
=
true
;
}
}
return
nextContinuation
;
}
nsresult
RestyleManagerBase
:
:
ProcessRestyledFrames
(
nsStyleChangeList
&
aChangeList
)
{
NS_ASSERTION
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
Someone
forgot
a
script
blocker
"
)
;
if
(
aChangeList
.
IsEmpty
(
)
)
return
NS_OK
;
PROFILER_LABEL
(
"
RestyleManager
"
"
ProcessRestyledFrames
"
js
:
:
ProfileEntry
:
:
Category
:
:
CSS
)
;
nsPresContext
*
presContext
=
PresContext
(
)
;
FramePropertyTable
*
propTable
=
presContext
-
>
PropertyTable
(
)
;
nsCSSFrameConstructor
*
frameConstructor
=
presContext
-
>
FrameConstructor
(
)
;
frameConstructor
-
>
BeginUpdate
(
)
;
for
(
const
nsStyleChangeData
&
data
:
aChangeList
)
{
if
(
data
.
mFrame
)
{
propTable
-
>
Set
(
data
.
mFrame
ChangeListProperty
(
)
true
)
;
}
}
bool
didUpdateCursor
=
false
;
for
(
const
nsStyleChangeData
&
data
:
aChangeList
)
{
nsIFrame
*
frame
=
data
.
mFrame
;
nsIContent
*
content
=
data
.
mContent
;
nsChangeHint
hint
=
data
.
mHint
;
bool
didReflowThisFrame
=
false
;
NS_ASSERTION
(
!
(
hint
&
nsChangeHint_AllReflowHints
)
|
|
(
hint
&
nsChangeHint_NeedReflow
)
"
Reflow
hint
bits
set
without
actually
asking
for
a
reflow
"
)
;
if
(
frame
&
&
!
propTable
-
>
Get
(
frame
ChangeListProperty
(
)
)
)
{
continue
;
}
if
(
frame
&
&
frame
-
>
GetContent
(
)
!
=
content
)
{
frame
=
nullptr
;
if
(
!
(
hint
&
nsChangeHint_ReconstructFrame
)
)
{
continue
;
}
}
if
(
(
hint
&
nsChangeHint_UpdateContainingBlock
)
&
&
frame
&
&
!
(
hint
&
nsChangeHint_ReconstructFrame
)
)
{
if
(
NeedToReframeForAddingOrRemovingTransform
(
frame
)
|
|
frame
-
>
GetType
(
)
=
=
nsGkAtoms
:
:
fieldSetFrame
|
|
frame
-
>
GetContentInsertionFrame
(
)
!
=
frame
)
{
hint
|
=
nsChangeHint_ReconstructFrame
;
}
else
{
for
(
nsIFrame
*
cont
=
frame
;
cont
;
cont
=
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
cont
)
)
{
if
(
cont
-
>
IsAbsPosContainingBlock
(
)
)
{
if
(
cont
-
>
StyleDisplay
(
)
-
>
HasTransform
(
cont
)
)
{
cont
-
>
AddStateBits
(
NS_FRAME_MAY_BE_TRANSFORMED
)
;
}
if
(
!
cont
-
>
IsAbsoluteContainer
(
)
&
&
(
cont
-
>
GetStateBits
(
)
&
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
)
{
cont
-
>
MarkAsAbsoluteContainingBlock
(
)
;
}
}
else
{
if
(
cont
-
>
IsAbsoluteContainer
(
)
)
{
cont
-
>
MarkAsNotAbsoluteContainingBlock
(
)
;
}
}
}
}
}
if
(
hint
&
nsChangeHint_ReconstructFrame
)
{
frameConstructor
-
>
RecreateFramesForContent
(
content
false
nsCSSFrameConstructor
:
:
REMOVE_FOR_RECONSTRUCTION
nullptr
)
;
}
else
{
NS_ASSERTION
(
frame
"
This
shouldn
'
t
happen
"
)
;
if
(
!
frame
-
>
FrameMaintainsOverflow
(
)
)
{
hint
&
=
~
(
nsChangeHint_UpdateOverflow
|
nsChangeHint_ChildrenOnlyTransform
|
nsChangeHint_UpdatePostTransformOverflow
|
nsChangeHint_UpdateParentOverflow
)
;
}
if
(
!
(
frame
-
>
GetStateBits
(
)
&
NS_FRAME_MAY_BE_TRANSFORMED
)
)
{
hint
&
=
~
nsChangeHint_UpdatePostTransformOverflow
;
}
if
(
hint
&
nsChangeHint_UpdateEffects
)
{
for
(
nsIFrame
*
cont
=
frame
;
cont
;
cont
=
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
cont
)
)
{
nsSVGEffects
:
:
UpdateEffects
(
cont
)
;
}
}
if
(
(
hint
&
nsChangeHint_InvalidateRenderingObservers
)
|
|
(
(
hint
&
nsChangeHint_UpdateOpacityLayer
)
&
&
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
&
&
!
(
frame
-
>
GetStateBits
(
)
&
NS_STATE_IS_OUTER_SVG
)
)
)
{
nsSVGEffects
:
:
InvalidateRenderingObservers
(
frame
)
;
}
if
(
hint
&
nsChangeHint_NeedReflow
)
{
StyleChangeReflow
(
frame
hint
)
;
didReflowThisFrame
=
true
;
}
if
(
(
hint
&
nsChangeHint_UpdateUsesOpacity
)
&
&
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eTablePart
)
)
{
NS_ASSERTION
(
hint
&
nsChangeHint_UpdateOpacityLayer
"
should
only
return
UpdateUsesOpacity
hint
"
"
when
also
returning
UpdateOpacityLayer
hint
"
)
;
hint
&
=
~
nsChangeHint_UpdateOpacityLayer
;
hint
|
=
nsChangeHint_RepaintFrame
;
}
if
(
hint
&
nsChangeHint_UpdateBackgroundPosition
)
{
hint
|
=
nsChangeHint_SchedulePaint
;
if
(
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eTablePart
)
|
|
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eMathML
)
)
{
hint
|
=
nsChangeHint_RepaintFrame
;
}
}
if
(
hint
&
(
nsChangeHint_RepaintFrame
|
nsChangeHint_SyncFrameView
|
nsChangeHint_UpdateOpacityLayer
|
nsChangeHint_UpdateTransformLayer
|
nsChangeHint_ChildrenOnlyTransform
|
nsChangeHint_SchedulePaint
)
)
{
ApplyRenderingChangeToTree
(
presContext
-
>
PresShell
(
)
frame
hint
)
;
}
if
(
(
hint
&
nsChangeHint_RecomputePosition
)
&
&
!
didReflowThisFrame
)
{
ActiveLayerTracker
:
:
NotifyOffsetRestyle
(
frame
)
;
if
(
!
RecomputePosition
(
frame
)
)
{
didReflowThisFrame
=
true
;
}
}
NS_ASSERTION
(
!
(
hint
&
nsChangeHint_ChildrenOnlyTransform
)
|
|
(
hint
&
nsChangeHint_UpdateOverflow
)
"
nsChangeHint_UpdateOverflow
should
be
passed
too
"
)
;
if
(
!
didReflowThisFrame
&
&
(
hint
&
(
nsChangeHint_UpdateOverflow
|
nsChangeHint_UpdatePostTransformOverflow
|
nsChangeHint_UpdateParentOverflow
|
nsChangeHint_UpdateSubtreeOverflow
)
)
)
{
if
(
hint
&
nsChangeHint_UpdateSubtreeOverflow
)
{
for
(
nsIFrame
*
cont
=
frame
;
cont
;
cont
=
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
cont
)
)
{
AddSubtreeToOverflowTracker
(
cont
mOverflowChangedTracker
)
;
}
hint
&
=
~
(
nsChangeHint_UpdateOverflow
|
nsChangeHint_UpdatePostTransformOverflow
)
;
}
if
(
hint
&
nsChangeHint_ChildrenOnlyTransform
)
{
nsIFrame
*
hintFrame
=
GetFrameForChildrenOnlyTransformHint
(
frame
)
;
nsIFrame
*
childFrame
=
hintFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
NS_ASSERTION
(
!
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
frame
)
"
SVG
frames
should
not
have
continuations
"
"
or
ib
-
split
siblings
"
)
;
NS_ASSERTION
(
!
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
hintFrame
)
"
SVG
frames
should
not
have
continuations
"
"
or
ib
-
split
siblings
"
)
;
for
(
;
childFrame
;
childFrame
=
childFrame
-
>
GetNextSibling
(
)
)
{
MOZ_ASSERT
(
childFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
"
Not
expecting
non
-
SVG
children
"
)
;
if
(
!
(
childFrame
-
>
GetStateBits
(
)
&
(
NS_FRAME_IS_DIRTY
|
NS_FRAME_HAS_DIRTY_CHILDREN
)
)
)
{
mOverflowChangedTracker
.
AddFrame
(
childFrame
OverflowChangedTracker
:
:
CHILDREN_CHANGED
)
;
}
NS_ASSERTION
(
!
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
childFrame
)
"
SVG
frames
should
not
have
continuations
"
"
or
ib
-
split
siblings
"
)
;
NS_ASSERTION
(
childFrame
-
>
GetParent
(
)
=
=
hintFrame
"
SVG
child
frame
not
expected
to
have
different
parent
"
)
;
}
}
if
(
!
(
frame
-
>
GetStateBits
(
)
&
(
NS_FRAME_IS_DIRTY
|
NS_FRAME_HAS_DIRTY_CHILDREN
)
)
)
{
if
(
hint
&
(
nsChangeHint_UpdateOverflow
|
nsChangeHint_UpdatePostTransformOverflow
)
)
{
OverflowChangedTracker
:
:
ChangeKind
changeKind
;
if
(
hint
&
nsChangeHint_UpdateOverflow
)
{
changeKind
=
OverflowChangedTracker
:
:
CHILDREN_CHANGED
;
}
else
{
changeKind
=
OverflowChangedTracker
:
:
TRANSFORM_CHANGED
;
}
for
(
nsIFrame
*
cont
=
frame
;
cont
;
cont
=
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
cont
)
)
{
mOverflowChangedTracker
.
AddFrame
(
cont
changeKind
)
;
}
}
if
(
hint
&
nsChangeHint_UpdateParentOverflow
)
{
MOZ_ASSERT
(
frame
-
>
GetParent
(
)
"
shouldn
'
t
get
style
hints
for
the
root
frame
"
)
;
for
(
nsIFrame
*
cont
=
frame
;
cont
;
cont
=
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
cont
)
)
{
mOverflowChangedTracker
.
AddFrame
(
cont
-
>
GetParent
(
)
OverflowChangedTracker
:
:
CHILDREN_CHANGED
)
;
}
}
}
}
if
(
(
hint
&
nsChangeHint_UpdateCursor
)
&
&
!
didUpdateCursor
)
{
presContext
-
>
PresShell
(
)
-
>
SynthesizeMouseMove
(
false
)
;
didUpdateCursor
=
true
;
}
}
}
frameConstructor
-
>
EndUpdate
(
)
;
for
(
const
nsStyleChangeData
&
data
:
aChangeList
)
{
if
(
data
.
mFrame
)
{
propTable
-
>
Delete
(
data
.
mFrame
ChangeListProperty
(
)
)
;
}
#
ifdef
DEBUG
if
(
data
.
mContent
)
{
nsIFrame
*
frame
=
data
.
mContent
-
>
GetPrimaryFrame
(
)
;
if
(
frame
)
{
DebugVerifyStyleTree
(
frame
)
;
}
}
else
if
(
!
data
.
mFrame
|
|
data
.
mFrame
-
>
GetType
(
)
!
=
nsGkAtoms
:
:
viewportFrame
)
{
NS_WARNING
(
"
Unable
to
test
style
tree
integrity
-
-
no
content
node
"
"
(
and
not
a
viewport
frame
)
"
)
;
}
#
endif
}
aChangeList
.
Clear
(
)
;
return
NS_OK
;
}
}
