#
ifndef
mozilla_PresShell_h
#
define
mozilla_PresShell_h
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
mozilla
/
dom
/
HTMLDocumentBinding
.
h
"
#
include
"
mozilla
/
layers
/
FocusTarget
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
ScrollTypes
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
mozilla
/
StaticPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsIObserver
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsRefreshDriver
.
h
"
#
include
"
nsStubDocumentObserver
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsWeakReference
.
h
"
#
include
"
TouchManager
.
h
"
#
include
"
ZoomConstraintsClient
.
h
"
class
nsIDocShell
;
class
nsRange
;
struct
RangePaintInfo
;
class
nsPresShellEventCB
;
class
AutoPointerEventTargetUpdater
;
class
MobileViewportManager
;
namespace
mozilla
{
namespace
dom
{
class
Element
;
class
Selection
;
}
class
EventDispatchingCallback
;
class
GeckoMVMContext
;
class
OverflowChangedTracker
;
typedef
nsTHashtable
<
nsPtrHashKey
<
nsIFrame
>
>
VisibleFrames
;
#
define
PAINTLOCK_EVENT_DELAY
5
class
PresShell
final
:
public
nsIPresShell
public
nsISelectionController
public
nsIObserver
public
nsSupportsWeakReference
{
typedef
layers
:
:
FocusTarget
FocusTarget
;
typedef
dom
:
:
Element
Element
;
public
:
PresShell
(
)
;
NS_DECL_ISUPPORTS
static
bool
AccessibleCaretEnabled
(
nsIDocShell
*
aDocShell
)
;
void
Init
(
Document
*
nsPresContext
*
nsViewManager
*
)
;
void
Destroy
(
)
override
;
NS_IMETHOD
GetSelectionFromScript
(
RawSelectionType
aRawSelectionType
dom
:
:
Selection
*
*
aSelection
)
override
;
dom
:
:
Selection
*
GetSelection
(
RawSelectionType
aRawSelectionType
)
override
;
dom
:
:
Selection
*
GetCurrentSelection
(
SelectionType
aSelectionType
)
override
;
already_AddRefed
<
nsISelectionController
>
GetSelectionControllerForFocusedContent
(
nsIContent
*
*
aFocusedContent
=
nullptr
)
override
;
NS_IMETHOD
SetDisplaySelection
(
int16_t
aToggle
)
override
;
NS_IMETHOD
GetDisplaySelection
(
int16_t
*
aToggle
)
override
;
NS_IMETHOD
ScrollSelectionIntoView
(
RawSelectionType
aRawSelectionType
SelectionRegion
aRegion
int16_t
aFlags
)
override
;
NS_IMETHOD
RepaintSelection
(
RawSelectionType
aRawSelectionType
)
override
;
nsresult
Initialize
(
)
override
;
MOZ_CAN_RUN_SCRIPT
nsresult
ResizeReflow
(
nscoord
aWidth
nscoord
aHeight
nscoord
aOldWidth
=
0
nscoord
aOldHeight
=
0
mozilla
:
:
ResizeReflowOptions
aOptions
=
mozilla
:
:
ResizeReflowOptions
:
:
eNoOption
)
override
;
MOZ_CAN_RUN_SCRIPT
nsresult
ResizeReflowIgnoreOverride
(
nscoord
aWidth
nscoord
aHeight
nscoord
aOldWidth
nscoord
aOldHeight
mozilla
:
:
ResizeReflowOptions
aOptions
=
mozilla
:
:
ResizeReflowOptions
:
:
eNoOption
)
override
;
MOZ_CAN_RUN_SCRIPT
void
DoFlushPendingNotifications
(
FlushType
aType
)
override
;
MOZ_CAN_RUN_SCRIPT
void
DoFlushPendingNotifications
(
ChangesToFlush
aType
)
override
;
nsRectVisibility
GetRectVisibility
(
nsIFrame
*
aFrame
const
nsRect
&
aRect
nscoord
aMinTwips
)
const
override
;
nsresult
CaptureHistoryState
(
nsILayoutHistoryState
*
*
aLayoutHistoryState
)
override
;
void
UnsuppressPainting
(
)
override
;
nsresult
GetAgentStyleSheets
(
nsTArray
<
RefPtr
<
StyleSheet
>
>
&
aSheets
)
override
;
nsresult
SetAgentStyleSheets
(
const
nsTArray
<
RefPtr
<
StyleSheet
>
>
&
aSheets
)
override
;
nsresult
AddOverrideStyleSheet
(
StyleSheet
*
aSheet
)
override
;
nsresult
RemoveOverrideStyleSheet
(
StyleSheet
*
aSheet
)
override
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
HandleEventWithTarget
(
WidgetEvent
*
aEvent
nsIFrame
*
aFrame
nsIContent
*
aContent
nsEventStatus
*
aEventStatus
bool
aIsHandlingNativeEvent
=
false
nsIContent
*
*
aTargetContent
=
nullptr
nsIContent
*
aOverrideClickTarget
=
nullptr
)
override
{
MOZ_ASSERT
(
aEvent
)
;
EventHandler
eventHandler
(
*
this
)
;
return
eventHandler
.
HandleEventWithTarget
(
aEvent
aFrame
aContent
aEventStatus
aIsHandlingNativeEvent
aTargetContent
aOverrideClickTarget
)
;
}
void
ReconstructFrames
(
void
)
override
;
void
Freeze
(
)
override
;
void
Thaw
(
)
override
;
void
FireOrClearDelayedEvents
(
bool
aFireEvents
)
override
;
nsresult
RenderDocument
(
const
nsRect
&
aRect
uint32_t
aFlags
nscolor
aBackgroundColor
gfxContext
*
aThebesContext
)
override
;
already_AddRefed
<
SourceSurface
>
RenderNode
(
nsINode
*
aNode
const
Maybe
<
CSSIntRegion
>
&
aRegion
const
LayoutDeviceIntPoint
aPoint
LayoutDeviceIntRect
*
aScreenRect
uint32_t
aFlags
)
override
;
already_AddRefed
<
SourceSurface
>
RenderSelection
(
dom
:
:
Selection
*
aSelection
const
LayoutDeviceIntPoint
aPoint
LayoutDeviceIntRect
*
aScreenRect
uint32_t
aFlags
)
override
;
already_AddRefed
<
nsPIDOMWindowOuter
>
GetRootWindow
(
)
override
;
already_AddRefed
<
nsPIDOMWindowOuter
>
GetFocusedDOMWindowInOurWindow
(
)
override
;
LayerManager
*
GetLayerManager
(
)
override
;
bool
AsyncPanZoomEnabled
(
)
override
;
void
SetIgnoreViewportScrolling
(
bool
aIgnore
)
override
;
nsresult
SetResolutionAndScaleTo
(
float
aResolution
ChangeOrigin
aOrigin
)
override
;
float
GetCumulativeResolution
(
)
override
;
float
GetCumulativeNonRootScaleResolution
(
)
override
;
void
SetRestoreResolution
(
float
aResolution
LayoutDeviceIntSize
aDisplaySize
)
override
;
void
WindowSizeMoveDone
(
)
override
;
void
SysColorChanged
(
)
override
{
mPresContext
-
>
SysColorChanged
(
)
;
}
void
ThemeChanged
(
)
override
{
mPresContext
-
>
ThemeChanged
(
)
;
}
void
BackingScaleFactorChanged
(
)
override
{
mPresContext
-
>
UIResolutionChangedSync
(
)
;
}
void
SynthesizeMouseMove
(
bool
aFromScroll
)
override
;
Document
*
GetPrimaryContentDocument
(
)
override
;
void
PausePainting
(
)
override
;
void
ResumePainting
(
)
override
;
void
Paint
(
nsView
*
aViewToPaint
const
nsRegion
&
aDirtyRegion
uint32_t
aFlags
)
override
;
MOZ_CAN_RUN_SCRIPT
nsresult
HandleEvent
(
nsIFrame
*
aFrameForPresShell
WidgetGUIEvent
*
aEvent
bool
aDontRetargetEvents
nsEventStatus
*
aEventStatus
)
override
;
nsresult
HandleDOMEventWithTarget
(
nsIContent
*
aTargetContent
WidgetEvent
*
aEvent
nsEventStatus
*
aStatus
)
override
;
nsresult
HandleDOMEventWithTarget
(
nsIContent
*
aTargetContent
dom
:
:
Event
*
aEvent
nsEventStatus
*
aStatus
)
override
;
bool
ShouldIgnoreInvalidation
(
)
override
;
MOZ_CAN_RUN_SCRIPT
void
WillPaint
(
)
;
void
WillPaintWindow
(
)
override
;
void
DidPaintWindow
(
)
override
;
void
ScheduleViewManagerFlush
(
PaintType
aType
=
PAINT_DEFAULT
)
override
;
void
ClearMouseCaptureOnView
(
nsView
*
aView
)
override
;
bool
IsVisible
(
)
override
;
void
SuppressDisplayport
(
bool
aEnabled
)
override
;
void
RespectDisplayportSuppression
(
bool
aEnabled
)
override
;
bool
IsDisplayportSuppressed
(
)
override
;
NS_IMETHOD
SetCaretEnabled
(
bool
aInEnable
)
override
;
NS_IMETHOD
SetCaretReadOnly
(
bool
aReadOnly
)
override
;
NS_IMETHOD
GetCaretEnabled
(
bool
*
aOutEnabled
)
override
;
NS_IMETHOD
SetCaretVisibilityDuringSelection
(
bool
aVisibility
)
override
;
NS_IMETHOD
GetCaretVisible
(
bool
*
_retval
)
override
;
NS_IMETHOD
SetSelectionFlags
(
int16_t
aInEnable
)
override
;
NS_IMETHOD
GetSelectionFlags
(
int16_t
*
aOutEnable
)
override
;
using
nsIPresShell
:
:
GetSelectionFlags
;
NS_IMETHOD
PhysicalMove
(
int16_t
aDirection
int16_t
aAmount
bool
aExtend
)
override
;
NS_IMETHOD
CharacterMove
(
bool
aForward
bool
aExtend
)
override
;
NS_IMETHOD
CharacterExtendForDelete
(
)
override
;
NS_IMETHOD
CharacterExtendForBackspace
(
)
override
;
NS_IMETHOD
WordMove
(
bool
aForward
bool
aExtend
)
override
;
NS_IMETHOD
WordExtendForDelete
(
bool
aForward
)
override
;
NS_IMETHOD
LineMove
(
bool
aForward
bool
aExtend
)
override
;
NS_IMETHOD
IntraLineMove
(
bool
aForward
bool
aExtend
)
override
;
MOZ_CAN_RUN_SCRIPT
NS_IMETHOD
PageMove
(
bool
aForward
bool
aExtend
)
override
;
NS_IMETHOD
ScrollPage
(
bool
aForward
)
override
;
NS_IMETHOD
ScrollLine
(
bool
aForward
)
override
;
NS_IMETHOD
ScrollCharacter
(
bool
aRight
)
override
;
NS_IMETHOD
CompleteScroll
(
bool
aForward
)
override
;
NS_IMETHOD
CompleteMove
(
bool
aForward
bool
aExtend
)
override
;
NS_IMETHOD
SelectAll
(
)
override
;
NS_IMETHOD
CheckVisibility
(
nsINode
*
node
int16_t
startOffset
int16_t
EndOffset
bool
*
_retval
)
override
;
nsresult
CheckVisibilityContent
(
nsIContent
*
aNode
int16_t
aStartOffset
int16_t
aEndOffset
bool
*
aRetval
)
override
;
void
DocumentStatesChanged
(
EventStates
)
;
NS_DECL_NSIDOCUMENTOBSERVER_BEGINLOAD
NS_DECL_NSIDOCUMENTOBSERVER_ENDLOAD
NS_DECL_NSIDOCUMENTOBSERVER_CONTENTSTATECHANGED
NS_DECL_NSIMUTATIONOBSERVER_CHARACTERDATACHANGED
NS_DECL_NSIMUTATIONOBSERVER_ATTRIBUTEWILLCHANGE
NS_DECL_NSIMUTATIONOBSERVER_ATTRIBUTECHANGED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTAPPENDED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTINSERTED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTREMOVED
NS_DECL_NSIOBSERVER
#
ifdef
MOZ_REFLOW_PERF
void
DumpReflows
(
)
override
;
void
CountReflows
(
const
char
*
aName
nsIFrame
*
aFrame
)
override
;
void
PaintCount
(
const
char
*
aName
gfxContext
*
aRenderingContext
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
const
nsPoint
&
aOffset
uint32_t
aColor
)
override
;
void
SetPaintFrameCount
(
bool
aOn
)
override
;
bool
IsPaintingFrameCounts
(
)
override
;
#
endif
#
ifdef
DEBUG
void
ListComputedStyles
(
FILE
*
out
int32_t
aIndent
=
0
)
override
;
void
ListStyleSheets
(
FILE
*
out
int32_t
aIndent
=
0
)
override
;
#
endif
void
DisableNonTestMouseEvents
(
bool
aDisable
)
override
;
void
UpdateCanvasBackground
(
)
override
;
void
AddCanvasBackgroundColorItem
(
nsDisplayListBuilder
&
aBuilder
nsDisplayList
&
aList
nsIFrame
*
aFrame
const
nsRect
&
aBounds
nscolor
aBackstopColor
=
NS_RGBA
(
0
0
0
0
)
uint32_t
aFlags
=
0
)
override
;
void
AddPrintPreviewBackgroundItem
(
nsDisplayListBuilder
&
aBuilder
nsDisplayList
&
aList
nsIFrame
*
aFrame
const
nsRect
&
aBounds
)
override
;
nscolor
ComputeBackstopColor
(
nsView
*
aDisplayRoot
)
override
;
nsresult
SetIsActive
(
bool
aIsActive
)
override
;
bool
GetIsViewportOverridden
(
)
override
{
return
(
mMobileViewportManager
!
=
nullptr
)
;
}
RefPtr
<
MobileViewportManager
>
GetMobileViewportManager
(
)
const
override
;
void
UpdateViewportOverridden
(
bool
aAfterInitialization
)
override
;
bool
IsLayoutFlushObserver
(
)
override
{
return
GetPresContext
(
)
-
>
RefreshDriver
(
)
-
>
IsLayoutFlushObserver
(
this
)
;
}
void
LoadComplete
(
)
override
;
void
AddSizeOfIncludingThis
(
nsWindowSizes
&
aWindowSizes
)
const
override
;
size_t
SizeOfTextRuns
(
MallocSizeOf
aMallocSizeOf
)
const
;
void
ScheduleApproximateFrameVisibilityUpdateSoon
(
)
override
;
void
ScheduleApproximateFrameVisibilityUpdateNow
(
)
override
;
void
RebuildApproximateFrameVisibilityDisplayList
(
const
nsDisplayList
&
aList
)
override
;
void
RebuildApproximateFrameVisibility
(
nsRect
*
aRect
=
nullptr
bool
aRemoveOnly
=
false
)
override
;
void
EnsureFrameInApproximatelyVisibleList
(
nsIFrame
*
aFrame
)
override
;
void
RemoveFrameFromApproximatelyVisibleList
(
nsIFrame
*
aFrame
)
override
;
bool
AssumeAllFramesVisible
(
)
override
;
bool
CanDispatchEvent
(
const
WidgetGUIEvent
*
aEvent
=
nullptr
)
const
override
;
void
SetNextPaintCompressed
(
)
{
mNextPaintCompressed
=
true
;
}
bool
HasHandledUserInput
(
)
const
override
{
return
mHasHandledUserInput
;
}
void
FireResizeEvent
(
)
override
;
void
SetKeyPressEventModel
(
uint16_t
aKeyPressEventModel
)
override
{
mForceUseLegacyKeyCodeAndCharCodeValues
|
=
aKeyPressEventModel
=
=
dom
:
:
HTMLDocument_Binding
:
:
KEYPRESS_EVENT_MODEL_SPLIT
;
}
static
PresShell
*
GetShellForEventTarget
(
nsIFrame
*
aFrame
nsIContent
*
aContent
)
;
static
PresShell
*
GetShellForTouchEvent
(
WidgetGUIEvent
*
aEvent
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
GoToAnchor
(
const
nsAString
&
aAnchorName
bool
aScroll
uint32_t
aAdditionalScrollFlags
=
0
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
ScrollToAnchor
(
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
ScrollContentIntoView
(
nsIContent
*
aContent
ScrollAxis
aVertical
ScrollAxis
aHorizontal
uint32_t
aFlags
)
;
private
:
~
PresShell
(
)
;
friend
class
:
:
AutoPointerEventTargetUpdater
;
MOZ_CAN_RUN_SCRIPT
bool
ProcessReflowCommands
(
bool
aInterruptible
)
;
MOZ_CAN_RUN_SCRIPT
void
DidDoReflow
(
bool
aInterruptible
)
;
MOZ_CAN_RUN_SCRIPT
void
HandlePostedReflowCallbacks
(
bool
aInterruptible
)
;
void
SetupFontInflation
(
)
;
struct
RenderingState
{
explicit
RenderingState
(
PresShell
*
aPresShell
)
:
mResolution
(
aPresShell
-
>
mResolution
)
mRenderFlags
(
aPresShell
-
>
mRenderFlags
)
{
}
Maybe
<
float
>
mResolution
;
RenderFlags
mRenderFlags
;
}
;
struct
AutoSaveRestoreRenderingState
{
explicit
AutoSaveRestoreRenderingState
(
PresShell
*
aPresShell
)
:
mPresShell
(
aPresShell
)
mOldState
(
aPresShell
)
{
}
~
AutoSaveRestoreRenderingState
(
)
{
mPresShell
-
>
mRenderFlags
=
mOldState
.
mRenderFlags
;
mPresShell
-
>
mResolution
=
mOldState
.
mResolution
;
}
PresShell
*
mPresShell
;
RenderingState
mOldState
;
}
;
static
RenderFlags
ChangeFlag
(
RenderFlags
aFlags
bool
aOnOff
eRenderFlag
aFlag
)
{
return
aOnOff
?
(
aFlags
|
aFlag
)
:
(
aFlag
&
~
aFlag
)
;
}
void
SetRenderingState
(
const
RenderingState
&
aState
)
;
friend
class
:
:
nsPresShellEventCB
;
bool
mCaretEnabled
;
nsRect
ClipListToRange
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
nsRange
*
aRange
)
;
UniquePtr
<
RangePaintInfo
>
CreateRangePaintInfo
(
nsRange
*
aRange
nsRect
&
aSurfaceRect
bool
aForPrimarySelection
)
;
already_AddRefed
<
SourceSurface
>
PaintRangePaintInfo
(
const
nsTArray
<
UniquePtr
<
RangePaintInfo
>
>
&
aItems
dom
:
:
Selection
*
aSelection
const
Maybe
<
CSSIntRegion
>
&
aRegion
nsRect
aArea
const
LayoutDeviceIntPoint
aPoint
LayoutDeviceIntRect
*
aScreenRect
uint32_t
aFlags
)
;
void
HideViewIfPopup
(
nsView
*
aView
)
;
void
RestoreRootScrollPosition
(
)
;
void
MaybeReleaseCapturingContent
(
)
;
class
DelayedEvent
{
public
:
virtual
~
DelayedEvent
(
)
{
}
virtual
void
Dispatch
(
)
{
}
virtual
bool
IsKeyPressEvent
(
)
{
return
false
;
}
}
;
class
DelayedInputEvent
:
public
DelayedEvent
{
public
:
void
Dispatch
(
)
override
;
protected
:
DelayedInputEvent
(
)
;
~
DelayedInputEvent
(
)
override
;
WidgetInputEvent
*
mEvent
;
}
;
class
DelayedMouseEvent
:
public
DelayedInputEvent
{
public
:
explicit
DelayedMouseEvent
(
WidgetMouseEvent
*
aEvent
)
;
}
;
class
DelayedKeyEvent
:
public
DelayedInputEvent
{
public
:
explicit
DelayedKeyEvent
(
WidgetKeyboardEvent
*
aEvent
)
;
bool
IsKeyPressEvent
(
)
override
;
}
;
void
RecordMouseLocation
(
WidgetGUIEvent
*
aEvent
)
;
class
nsSynthMouseMoveEvent
final
:
public
nsARefreshObserver
{
public
:
nsSynthMouseMoveEvent
(
PresShell
*
aPresShell
bool
aFromScroll
)
:
mPresShell
(
aPresShell
)
mFromScroll
(
aFromScroll
)
{
NS_ASSERTION
(
mPresShell
"
null
parameter
"
)
;
}
private
:
~
nsSynthMouseMoveEvent
(
)
{
Revoke
(
)
;
}
public
:
NS_INLINE_DECL_REFCOUNTING
(
nsSynthMouseMoveEvent
override
)
void
Revoke
(
)
{
if
(
mPresShell
)
{
mPresShell
-
>
GetPresContext
(
)
-
>
RefreshDriver
(
)
-
>
RemoveRefreshObserver
(
this
FlushType
:
:
Display
)
;
mPresShell
=
nullptr
;
}
}
MOZ_CAN_RUN_SCRIPT
void
WillRefresh
(
TimeStamp
aTime
)
override
{
if
(
mPresShell
)
{
RefPtr
<
PresShell
>
shell
=
mPresShell
;
shell
-
>
ProcessSynthMouseMoveEvent
(
mFromScroll
)
;
}
}
private
:
PresShell
*
mPresShell
;
bool
mFromScroll
;
}
;
MOZ_CAN_RUN_SCRIPT
void
ProcessSynthMouseMoveEvent
(
bool
aFromScroll
)
;
void
QueryIsActive
(
)
;
nsresult
UpdateImageLockingState
(
)
;
already_AddRefed
<
PresShell
>
GetParentPresShellForEventHandling
(
)
;
class
MOZ_STACK_CLASS
EventHandler
final
{
public
:
EventHandler
(
)
=
delete
;
EventHandler
(
const
EventHandler
&
aOther
)
=
delete
;
explicit
EventHandler
(
PresShell
&
aPresShell
)
:
mPresShell
(
aPresShell
)
mCurrentEventInfoSetter
(
nullptr
)
{
}
explicit
EventHandler
(
RefPtr
<
PresShell
>
&
&
aPresShell
)
:
mPresShell
(
aPresShell
.
forget
(
)
)
mCurrentEventInfoSetter
(
nullptr
)
{
}
MOZ_CAN_RUN_SCRIPT
nsresult
HandleEvent
(
nsIFrame
*
aFrameForPresShell
WidgetGUIEvent
*
aGUIEvent
bool
aDontRetargetEvents
nsEventStatus
*
aEventStatus
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
HandleEventWithTarget
(
WidgetEvent
*
aEvent
nsIFrame
*
aNewEventFrame
nsIContent
*
aNewEventContent
nsEventStatus
*
aEventStatus
bool
aIsHandlingNativeEvent
nsIContent
*
*
aTargetContent
nsIContent
*
aOverrideClickTarget
)
;
static
inline
void
OnPresShellDestroy
(
Document
*
aDocument
)
;
private
:
static
bool
InZombieDocument
(
nsIContent
*
aContent
)
;
static
nsIFrame
*
GetNearestFrameContainingPresShell
(
PresShell
*
aPresShell
)
;
static
already_AddRefed
<
nsIURI
>
GetDocumentURIToCompareWithBlacklist
(
PresShell
&
aPresShell
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
HandleEventUsingCoordinates
(
nsIFrame
*
aFrameForPresShell
WidgetGUIEvent
*
aGUIEvent
nsEventStatus
*
aEventStatus
bool
aDontRetargetEvents
)
;
struct
MOZ_STACK_CLASS
EventTargetData
final
{
EventTargetData
(
)
=
delete
;
EventTargetData
(
const
EventTargetData
&
aOther
)
=
delete
;
EventTargetData
(
PresShell
*
aPresShell
nsIFrame
*
aFrameToHandleEvent
)
:
mPresShell
(
aPresShell
)
mFrame
(
aFrameToHandleEvent
)
{
}
void
SetPresShellAndFrame
(
PresShell
*
aPresShell
nsIFrame
*
aFrameToHandleEvent
)
{
mPresShell
=
aPresShell
;
mFrame
=
aFrameToHandleEvent
;
mContent
=
nullptr
;
}
void
SetFrameAndComputePresShell
(
nsIFrame
*
aFrameToHandleEvent
)
;
void
SetFrameAndComputePresShellAndContent
(
nsIFrame
*
aFrameToHandleEvent
WidgetGUIEvent
*
aGUIEvent
)
;
void
SetContentForEventFromFrame
(
WidgetGUIEvent
*
aGUIEvent
)
;
nsPresContext
*
GetPresContext
(
)
const
{
return
mPresShell
?
mPresShell
-
>
GetPresContext
(
)
:
nullptr
;
}
;
EventStateManager
*
GetEventStateManager
(
)
const
{
nsPresContext
*
presContext
=
GetPresContext
(
)
;
return
presContext
?
presContext
-
>
EventStateManager
(
)
:
nullptr
;
}
Document
*
GetDocument
(
)
const
{
return
mPresShell
?
mPresShell
-
>
GetDocument
(
)
:
nullptr
;
}
nsIContent
*
GetFrameContent
(
)
const
;
bool
MaybeRetargetToActiveDocument
(
WidgetGUIEvent
*
aGUIEvent
)
;
bool
ComputeElementFromFrame
(
WidgetGUIEvent
*
aGUIEvent
)
;
void
UpdateTouchEventTarget
(
WidgetGUIEvent
*
aGUIEvent
)
;
RefPtr
<
PresShell
>
mPresShell
;
nsIFrame
*
mFrame
;
nsCOMPtr
<
nsIContent
>
mContent
;
nsCOMPtr
<
nsIContent
>
mOverrideClickTarget
;
}
;
MOZ_CAN_RUN_SCRIPT
bool
MaybeFlushPendingNotifications
(
WidgetGUIEvent
*
aGUIEvent
)
;
MOZ_CAN_RUN_SCRIPT
nsIFrame
*
GetFrameToHandleNonTouchEvent
(
nsIFrame
*
aRootFrameToHandleEvent
WidgetGUIEvent
*
aGUIEvent
)
;
MOZ_CAN_RUN_SCRIPT
bool
ComputeEventTargetFrameAndPresShellAtEventPoint
(
nsIFrame
*
aRootFrameToHandleEvent
WidgetGUIEvent
*
aGUIEvent
EventTargetData
*
aEventTargetData
)
;
MOZ_CAN_RUN_SCRIPT
bool
DispatchPrecedingPointerEvent
(
nsIFrame
*
aFrameForPresShell
WidgetGUIEvent
*
aGUIEvent
nsIContent
*
aPointerCapturingContent
bool
aDontRetargetEvents
EventTargetData
*
aEventTargetData
nsEventStatus
*
aEventStatus
)
;
bool
MaybeDiscardEvent
(
WidgetGUIEvent
*
aGUIEvent
)
;
static
nsIContent
*
GetCapturingContentFor
(
WidgetGUIEvent
*
aGUIEvent
)
;
bool
GetRetargetEventDocument
(
WidgetGUIEvent
*
aGUIEvent
Document
*
*
aRetargetEventDocument
)
;
nsIFrame
*
GetFrameForHandlingEventWith
(
WidgetGUIEvent
*
aGUIEvent
Document
*
aRetargetDocument
nsIFrame
*
aFrameForPresShell
)
;
MOZ_CAN_RUN_SCRIPT
bool
MaybeHandleEventWithAnotherPresShell
(
nsIFrame
*
aFrameForPresShell
WidgetGUIEvent
*
aGUIEvent
nsEventStatus
*
aEventStatus
nsresult
*
aRv
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
RetargetEventToParent
(
WidgetGUIEvent
*
aGUIEvent
nsEventStatus
*
aEventStatus
)
;
MOZ_CAN_RUN_SCRIPT
bool
MaybeHandleEventWithAccessibleCaret
(
WidgetGUIEvent
*
aGUIEvent
nsEventStatus
*
aEventStatus
)
;
bool
MaybeDiscardOrDelayKeyboardEvent
(
WidgetGUIEvent
*
aGUIEvent
)
;
bool
MaybeDiscardOrDelayMouseEvent
(
nsIFrame
*
aFrameToHandleEvent
WidgetGUIEvent
*
aGUIEvent
)
;
MOZ_CAN_RUN_SCRIPT
nsIFrame
*
MaybeFlushThrottledStyles
(
nsIFrame
*
aFrameForPresShell
)
;
nsIFrame
*
ComputeRootFrameToHandleEvent
(
nsIFrame
*
aFrameForPresShell
WidgetGUIEvent
*
aGUIEvent
nsIContent
*
aCapturingContent
bool
*
aIsCapturingContentIgnored
bool
*
aIsCaptureRetargeted
)
;
nsIFrame
*
ComputeRootFrameToHandleEventWithPopup
(
nsIFrame
*
aRootFrameToHandleEvent
WidgetGUIEvent
*
aGUIEvent
nsIContent
*
aCapturingContent
bool
*
aIsCapturingContentIgnored
)
;
nsIFrame
*
ComputeRootFrameToHandleEventWithCapturingContent
(
nsIFrame
*
aRootFrameToHandleEvent
nsIContent
*
aCapturingContent
bool
*
aIsCapturingContentIgnored
bool
*
aIsCaptureRetargeted
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
HandleEventWithPointerCapturingContentWithoutItsFrame
(
nsIFrame
*
aFrameForPresShell
WidgetGUIEvent
*
aGUIEvent
nsIContent
*
aPointerCapturingContent
nsEventStatus
*
aEventStatus
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
HandleEventAtFocusedContent
(
WidgetGUIEvent
*
aGUIEvent
nsEventStatus
*
aEventStatus
)
;
dom
:
:
Element
*
ComputeFocusedEventTargetElement
(
WidgetGUIEvent
*
aGUIEvent
)
;
MOZ_CAN_RUN_SCRIPT
bool
MaybeHandleEventWithAnotherPresShell
(
dom
:
:
Element
*
aEventTargetElement
WidgetGUIEvent
*
aGUIEvent
nsEventStatus
*
aEventStatus
nsresult
*
aRv
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
HandleRetargetedEvent
(
WidgetGUIEvent
*
aGUIEvent
nsEventStatus
*
aEventStatus
nsIContent
*
aTarget
)
{
AutoCurrentEventInfoSetter
eventInfoSetter
(
*
this
nullptr
aTarget
)
;
if
(
!
mPresShell
-
>
GetCurrentEventFrame
(
)
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
overrideClickTarget
;
return
HandleEventWithCurrentEventInfo
(
aGUIEvent
aEventStatus
true
overrideClickTarget
)
;
}
MOZ_CAN_RUN_SCRIPT
nsresult
HandleEventWithFrameForPresShell
(
nsIFrame
*
aFrameForPresShell
WidgetGUIEvent
*
aGUIEvent
nsEventStatus
*
aEventStatus
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
HandleEventWithCurrentEventInfo
(
WidgetEvent
*
aEvent
nsEventStatus
*
aEventStatus
bool
aIsHandlingNativeEvent
nsIContent
*
aOverrideClickTarget
)
;
class
MOZ_STACK_CLASS
HandlingTimeAccumulator
final
{
public
:
HandlingTimeAccumulator
(
)
=
delete
;
HandlingTimeAccumulator
(
const
HandlingTimeAccumulator
&
aOther
)
=
delete
;
HandlingTimeAccumulator
(
const
EventHandler
&
aEventHandler
const
WidgetEvent
*
aEvent
)
;
~
HandlingTimeAccumulator
(
)
;
private
:
const
EventHandler
&
mEventHandler
;
const
WidgetEvent
*
mEvent
;
TimeStamp
mHandlingStartTime
;
}
;
void
RecordEventPreparationPerformance
(
const
WidgetEvent
*
aEvent
)
;
void
RecordEventHandlingResponsePerformance
(
const
WidgetEvent
*
aEvent
)
;
MOZ_CAN_RUN_SCRIPT
bool
PrepareToDispatchEvent
(
WidgetEvent
*
aEvent
nsEventStatus
*
aEventStatus
bool
*
aIsUserInteraction
bool
*
aTouchIsNew
)
;
MOZ_CAN_RUN_SCRIPT
void
MaybeHandleKeyboardEventBeforeDispatch
(
WidgetKeyboardEvent
*
aKeyboardEvent
)
;
MOZ_CAN_RUN_SCRIPT
bool
AdjustContextMenuKeyEvent
(
WidgetMouseEvent
*
aMouseEvent
)
;
MOZ_CAN_RUN_SCRIPT
bool
PrepareToUseCaretPosition
(
nsIWidget
*
aEventWidget
LayoutDeviceIntPoint
&
aTargetPt
)
;
MOZ_CAN_RUN_SCRIPT
void
GetCurrentItemAndPositionForElement
(
dom
:
:
Element
*
aFocusedElement
nsIContent
*
*
aTargetToUse
LayoutDeviceIntPoint
&
aTargetPt
nsIWidget
*
aRootWidget
)
;
nsIContent
*
GetOverrideClickTarget
(
WidgetGUIEvent
*
aGUIEvent
nsIFrame
*
aFrame
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
DispatchEvent
(
EventStateManager
*
aEventStateManager
WidgetEvent
*
aEvent
bool
aTouchIsNew
nsEventStatus
*
aEventStatus
nsIContent
*
aOverrideClickTarget
)
;
nsresult
DispatchEventToDOM
(
WidgetEvent
*
aEvent
nsEventStatus
*
aEventStatus
nsPresShellEventCB
*
aEventCB
)
;
void
DispatchTouchEventToDOM
(
WidgetEvent
*
aEvent
nsEventStatus
*
aEventStatus
nsPresShellEventCB
*
aEventCB
bool
aTouchIsNew
)
;
void
FinalizeHandlingEvent
(
WidgetEvent
*
aEvent
)
;
struct
MOZ_STACK_CLASS
AutoCurrentEventInfoSetter
final
{
explicit
AutoCurrentEventInfoSetter
(
EventHandler
&
aEventHandler
)
:
mEventHandler
(
aEventHandler
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mEventHandler
.
mCurrentEventInfoSetter
)
;
mEventHandler
.
mCurrentEventInfoSetter
=
this
;
mEventHandler
.
mPresShell
-
>
PushCurrentEventInfo
(
nullptr
nullptr
)
;
}
AutoCurrentEventInfoSetter
(
EventHandler
&
aEventHandler
nsIFrame
*
aFrame
nsIContent
*
aContent
)
:
mEventHandler
(
aEventHandler
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mEventHandler
.
mCurrentEventInfoSetter
)
;
mEventHandler
.
mCurrentEventInfoSetter
=
this
;
mEventHandler
.
mPresShell
-
>
PushCurrentEventInfo
(
aFrame
aContent
)
;
}
AutoCurrentEventInfoSetter
(
EventHandler
&
aEventHandler
EventTargetData
&
aEventTargetData
)
:
mEventHandler
(
aEventHandler
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mEventHandler
.
mCurrentEventInfoSetter
)
;
mEventHandler
.
mCurrentEventInfoSetter
=
this
;
mEventHandler
.
mPresShell
-
>
PushCurrentEventInfo
(
aEventTargetData
.
mFrame
aEventTargetData
.
mContent
)
;
}
~
AutoCurrentEventInfoSetter
(
)
{
mEventHandler
.
mPresShell
-
>
PopCurrentEventInfo
(
)
;
mEventHandler
.
mCurrentEventInfoSetter
=
nullptr
;
}
private
:
EventHandler
&
mEventHandler
;
}
;
nsPresContext
*
GetPresContext
(
)
const
{
return
mPresShell
-
>
GetPresContext
(
)
;
}
Document
*
GetDocument
(
)
const
{
return
mPresShell
-
>
GetDocument
(
)
;
}
nsCSSFrameConstructor
*
FrameConstructor
(
)
const
{
return
mPresShell
-
>
FrameConstructor
(
)
;
}
already_AddRefed
<
nsPIDOMWindowOuter
>
GetFocusedDOMWindowInOurWindow
(
)
{
return
mPresShell
-
>
GetFocusedDOMWindowInOurWindow
(
)
;
}
already_AddRefed
<
PresShell
>
GetParentPresShellForEventHandling
(
)
{
return
mPresShell
-
>
GetParentPresShellForEventHandling
(
)
;
}
void
PushDelayedEventIntoQueue
(
UniquePtr
<
DelayedEvent
>
&
&
aDelayedEvent
)
{
mPresShell
-
>
mDelayedEvents
.
AppendElement
(
std
:
:
move
(
aDelayedEvent
)
)
;
}
OwningNonNull
<
PresShell
>
mPresShell
;
AutoCurrentEventInfoSetter
*
mCurrentEventInfoSetter
;
static
TimeStamp
sLastInputCreated
;
static
TimeStamp
sLastInputProcessed
;
static
StaticRefPtr
<
dom
:
:
Element
>
sLastKeyDownEventTargetElement
;
}
;
PresShell
*
GetRootPresShell
(
)
;
nscolor
GetDefaultBackgroundColorToDraw
(
)
;
static
void
sPaintSuppressionCallback
(
nsITimer
*
aTimer
void
*
aPresShell
)
;
void
UpdateApproximateFrameVisibility
(
)
;
void
DoUpdateApproximateFrameVisibility
(
bool
aRemoveOnly
)
;
void
ClearApproximatelyVisibleFramesList
(
const
Maybe
<
OnNonvisible
>
&
aNonvisibleAction
=
Nothing
(
)
)
;
static
void
ClearApproximateFrameVisibilityVisited
(
nsView
*
aView
bool
aClear
)
;
static
void
MarkFramesInListApproximatelyVisible
(
const
nsDisplayList
&
aList
)
;
void
MarkFramesInSubtreeApproximatelyVisible
(
nsIFrame
*
aFrame
const
nsRect
&
aRect
bool
aRemoveOnly
=
false
)
;
void
DecApproximateVisibleCount
(
VisibleFrames
&
aFrames
const
Maybe
<
OnNonvisible
>
&
aNonvisibleAction
=
Nothing
(
)
)
;
nsRevocableEventPtr
<
nsRunnableMethod
<
PresShell
>
>
mUpdateApproximateFrameVisibilityEvent
;
VisibleFrames
mApproximatelyVisibleFrames
;
nsresult
SetResolutionImpl
(
float
aResolution
bool
aScaleToResolution
nsAtom
*
aOrigin
)
;
nsPoint
mMouseLocation
;
layers
:
:
ScrollableLayerGuid
mMouseEventTargetGuid
;
nsTArray
<
UniquePtr
<
DelayedEvent
>
>
mDelayedEvents
;
private
:
nsRevocableEventPtr
<
nsSynthMouseMoveEvent
>
mSynthMouseMoveEvent
;
TouchManager
mTouchManager
;
RefPtr
<
ZoomConstraintsClient
>
mZoomConstraintsClient
;
RefPtr
<
GeckoMVMContext
>
mMVMContext
;
RefPtr
<
MobileViewportManager
>
mMobileViewportManager
;
nsCOMPtr
<
nsITimer
>
mPaintSuppressionTimer
;
nsCOMPtr
<
nsITimer
>
mDelayedPaintTimer
;
TimeStamp
mLoadBegin
;
nsCOMPtr
<
nsIContent
>
mPointerEventTarget
;
nsCOMPtr
<
nsIContent
>
mLastAnchorScrolledTo
;
uint64_t
mAPZFocusSequenceNumber
;
FocusTarget
mAPZFocusTarget
;
nscoord
mLastAnchorScrollPositionY
=
0
;
int32_t
mActiveSuppressDisplayport
;
bool
mDocumentLoading
:
1
;
bool
mNoDelayedMouseEvents
:
1
;
bool
mNoDelayedKeyEvents
:
1
;
bool
mApproximateFrameVisibilityVisited
:
1
;
bool
mNextPaintCompressed
:
1
;
bool
mHasCSSBackgroundColor
:
1
;
bool
mIsLastChromeOnlyEscapeKeyConsumed
:
1
;
bool
mHasReceivedPaintMessage
:
1
;
bool
mIsLastKeyDownCanceled
:
1
;
bool
mHasHandledUserInput
:
1
;
bool
mForceDispatchKeyPressEventsForNonPrintableKeys
:
1
;
bool
mForceUseLegacyKeyCodeAndCharCodeValues
:
1
;
bool
mInitializedWithKeyPressEventDispatchingBlacklist
:
1
;
bool
mForceUseLegacyNonPrimaryDispatch
:
1
;
bool
mInitializedWithClickEventDispatchingBlacklist
:
1
;
static
bool
sDisableNonTestMouseEvents
;
TimeStamp
mLastOSWake
;
static
bool
sProcessInteractable
;
}
;
}
#
endif
