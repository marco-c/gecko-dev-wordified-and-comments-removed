#
ifdef
XP_WIN
#
include
<
windows
.
h
>
#
include
<
mmsystem
.
h
>
#
include
"
WinUtils
.
h
"
#
endif
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
nsHostObjectProtocolHandler
.
h
"
#
include
"
nsRefreshDriver
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
mozilla
/
PendingAnimationTracker
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
nsNPAPIPluginInstance
.
h
"
#
include
"
mozilla
/
dom
/
Performance
.
h
"
#
include
"
mozilla
/
dom
/
WindowBinding
.
h
"
#
include
"
mozilla
/
GeckoRestyleManager
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
mozilla
/
RestyleManagerInlines
.
h
"
#
include
"
Layers
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsISimpleEnumerator
.
h
"
#
include
"
nsJSEnvironment
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
BackgroundChild
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundChild
.
h
"
#
include
"
nsIIPCBackgroundChildCreateCallback
.
h
"
#
include
"
mozilla
/
layout
/
VsyncChild
.
h
"
#
include
"
VsyncSource
.
h
"
#
include
"
mozilla
/
VsyncDispatcher
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
TimelineConsumers
.
h
"
#
include
"
nsAnimationManager
.
h
"
#
include
"
nsIDOMEvent
.
h
"
#
include
"
nsDisplayList
.
h
"
#
ifdef
MOZ_XUL
#
include
"
nsXULPopupManager
.
h
"
#
endif
using
namespace
mozilla
;
using
namespace
mozilla
:
:
widget
;
using
namespace
mozilla
:
:
ipc
;
using
namespace
mozilla
:
:
layout
;
static
mozilla
:
:
LazyLogModule
sRefreshDriverLog
(
"
nsRefreshDriver
"
)
;
#
define
LOG
(
.
.
.
)
MOZ_LOG
(
sRefreshDriverLog
mozilla
:
:
LogLevel
:
:
Debug
(
__VA_ARGS__
)
)
#
define
DEFAULT_THROTTLED_FRAME_RATE
1
#
define
DEFAULT_RECOMPUTE_VISIBILITY_INTERVAL_MS
1000
#
define
DEFAULT_NOTIFY_INTERSECTION_OBSERVERS_INTERVAL_MS
100
#
define
DEFAULT_INACTIVE_TIMER_DISABLE_SECONDS
600
#
if
defined
(
MOZ_ASAN
)
#
define
REFRESH_WAIT_WARNING
5
#
elif
defined
(
DEBUG
)
&
&
!
defined
(
MOZ_VALGRIND
)
#
define
REFRESH_WAIT_WARNING
5
#
elif
defined
(
DEBUG
)
&
&
defined
(
MOZ_VALGRIND
)
#
define
REFRESH_WAIT_WARNING
(
RUNNING_ON_VALGRIND
?
20
:
5
)
#
elif
defined
(
MOZ_VALGRIND
)
#
define
REFRESH_WAIT_WARNING
(
RUNNING_ON_VALGRIND
?
10
:
1
)
#
else
#
define
REFRESH_WAIT_WARNING
1
#
endif
namespace
{
static
uint64_t
sActiveVsyncTimers
=
0
;
uint64_t
sJankLevels
[
12
]
;
static
uint32_t
sRefreshDriverCount
=
0
;
}
namespace
mozilla
{
class
RefreshDriverTimer
{
public
:
RefreshDriverTimer
(
)
:
mLastFireEpoch
(
0
)
mLastFireSkipped
(
false
)
{
}
virtual
~
RefreshDriverTimer
(
)
{
MOZ_ASSERT
(
mContentRefreshDrivers
.
Length
(
)
=
=
0
"
Should
have
removed
all
content
refresh
drivers
from
here
by
now
!
"
)
;
MOZ_ASSERT
(
mRootRefreshDrivers
.
Length
(
)
=
=
0
"
Should
have
removed
all
root
refresh
drivers
from
here
by
now
!
"
)
;
}
virtual
void
AddRefreshDriver
(
nsRefreshDriver
*
aDriver
)
{
LOG
(
"
[
%
p
]
AddRefreshDriver
%
p
"
this
aDriver
)
;
bool
startTimer
=
mContentRefreshDrivers
.
IsEmpty
(
)
&
&
mRootRefreshDrivers
.
IsEmpty
(
)
;
if
(
IsRootRefreshDriver
(
aDriver
)
)
{
NS_ASSERTION
(
!
mRootRefreshDrivers
.
Contains
(
aDriver
)
"
Adding
a
duplicate
root
refresh
driver
!
"
)
;
mRootRefreshDrivers
.
AppendElement
(
aDriver
)
;
}
else
{
NS_ASSERTION
(
!
mContentRefreshDrivers
.
Contains
(
aDriver
)
"
Adding
a
duplicate
content
refresh
driver
!
"
)
;
mContentRefreshDrivers
.
AppendElement
(
aDriver
)
;
}
if
(
startTimer
)
{
StartTimer
(
)
;
}
}
virtual
void
RemoveRefreshDriver
(
nsRefreshDriver
*
aDriver
)
{
LOG
(
"
[
%
p
]
RemoveRefreshDriver
%
p
"
this
aDriver
)
;
if
(
IsRootRefreshDriver
(
aDriver
)
)
{
NS_ASSERTION
(
mRootRefreshDrivers
.
Contains
(
aDriver
)
"
RemoveRefreshDriver
for
a
refresh
driver
that
'
s
not
in
the
root
refresh
list
!
"
)
;
mRootRefreshDrivers
.
RemoveElement
(
aDriver
)
;
}
else
{
nsPresContext
*
pc
=
aDriver
-
>
GetPresContext
(
)
;
nsPresContext
*
rootContext
=
pc
?
pc
-
>
GetRootPresContext
(
)
:
nullptr
;
if
(
!
rootContext
)
{
if
(
mRootRefreshDrivers
.
Contains
(
aDriver
)
)
{
mRootRefreshDrivers
.
RemoveElement
(
aDriver
)
;
}
else
{
NS_ASSERTION
(
mContentRefreshDrivers
.
Contains
(
aDriver
)
"
RemoveRefreshDriver
without
a
display
root
for
a
driver
that
is
not
in
the
content
refresh
list
"
)
;
mContentRefreshDrivers
.
RemoveElement
(
aDriver
)
;
}
}
else
{
NS_ASSERTION
(
mContentRefreshDrivers
.
Contains
(
aDriver
)
"
RemoveRefreshDriver
for
a
driver
that
is
not
in
the
content
refresh
list
"
)
;
mContentRefreshDrivers
.
RemoveElement
(
aDriver
)
;
}
}
bool
stopTimer
=
mContentRefreshDrivers
.
IsEmpty
(
)
&
&
mRootRefreshDrivers
.
IsEmpty
(
)
;
if
(
stopTimer
)
{
StopTimer
(
)
;
}
}
TimeStamp
MostRecentRefresh
(
)
const
{
return
mLastFireTime
;
}
int64_t
MostRecentRefreshEpochTime
(
)
const
{
return
mLastFireEpoch
;
}
void
SwapRefreshDrivers
(
RefreshDriverTimer
*
aNewTimer
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
for
(
nsRefreshDriver
*
driver
:
mContentRefreshDrivers
)
{
aNewTimer
-
>
AddRefreshDriver
(
driver
)
;
driver
-
>
mActiveTimer
=
aNewTimer
;
}
mContentRefreshDrivers
.
Clear
(
)
;
for
(
nsRefreshDriver
*
driver
:
mRootRefreshDrivers
)
{
aNewTimer
-
>
AddRefreshDriver
(
driver
)
;
driver
-
>
mActiveTimer
=
aNewTimer
;
}
mRootRefreshDrivers
.
Clear
(
)
;
aNewTimer
-
>
mLastFireEpoch
=
mLastFireEpoch
;
aNewTimer
-
>
mLastFireTime
=
mLastFireTime
;
}
virtual
TimeDuration
GetTimerRate
(
)
=
0
;
bool
LastTickSkippedAnyPaints
(
)
const
{
return
mLastFireSkipped
;
}
TimeStamp
GetIdleDeadlineHint
(
TimeStamp
aDefault
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
LastTickSkippedAnyPaints
(
)
)
{
return
TimeStamp
:
:
Now
(
)
;
}
TimeStamp
mostRecentRefresh
=
MostRecentRefresh
(
)
;
TimeDuration
refreshRate
=
GetTimerRate
(
)
;
TimeStamp
idleEnd
=
mostRecentRefresh
+
refreshRate
;
if
(
idleEnd
+
refreshRate
*
nsLayoutUtils
:
:
QuiescentFramesBeforeIdlePeriod
(
)
<
TimeStamp
:
:
Now
(
)
)
{
return
aDefault
;
}
idleEnd
=
idleEnd
-
TimeDuration
:
:
FromMilliseconds
(
nsLayoutUtils
:
:
IdlePeriodDeadlineLimit
(
)
)
;
return
idleEnd
<
aDefault
?
idleEnd
:
aDefault
;
}
protected
:
virtual
void
StartTimer
(
)
=
0
;
virtual
void
StopTimer
(
)
=
0
;
virtual
void
ScheduleNextTick
(
TimeStamp
aNowTime
)
=
0
;
bool
IsRootRefreshDriver
(
nsRefreshDriver
*
aDriver
)
{
nsPresContext
*
pc
=
aDriver
-
>
GetPresContext
(
)
;
nsPresContext
*
rootContext
=
pc
?
pc
-
>
GetRootPresContext
(
)
:
nullptr
;
if
(
!
rootContext
)
{
return
false
;
}
return
aDriver
=
=
rootContext
-
>
RefreshDriver
(
)
;
}
void
Tick
(
)
{
int64_t
jsnow
=
JS_Now
(
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
Tick
(
jsnow
now
)
;
}
void
TickRefreshDrivers
(
int64_t
aJsNow
TimeStamp
aNow
nsTArray
<
RefPtr
<
nsRefreshDriver
>
>
&
aDrivers
)
{
if
(
aDrivers
.
IsEmpty
(
)
)
{
return
;
}
nsTArray
<
RefPtr
<
nsRefreshDriver
>
>
drivers
(
aDrivers
)
;
for
(
nsRefreshDriver
*
driver
:
drivers
)
{
if
(
driver
-
>
IsTestControllingRefreshesEnabled
(
)
)
{
continue
;
}
TickDriver
(
driver
aJsNow
aNow
)
;
mLastFireSkipped
=
mLastFireSkipped
|
|
driver
-
>
mSkippedPaints
;
}
}
void
Tick
(
int64_t
jsnow
TimeStamp
now
)
{
ScheduleNextTick
(
now
)
;
mLastFireEpoch
=
jsnow
;
mLastFireTime
=
now
;
mLastFireSkipped
=
false
;
LOG
(
"
[
%
p
]
ticking
drivers
.
.
.
"
this
)
;
GeckoProfilerTracingRAII
tracer
(
"
Paint
"
"
RefreshDriverTick
"
)
;
TickRefreshDrivers
(
jsnow
now
mContentRefreshDrivers
)
;
TickRefreshDrivers
(
jsnow
now
mRootRefreshDrivers
)
;
LOG
(
"
[
%
p
]
done
.
"
this
)
;
}
static
void
TickDriver
(
nsRefreshDriver
*
driver
int64_t
jsnow
TimeStamp
now
)
{
LOG
(
"
>
>
TickDriver
:
%
p
(
jsnow
:
%
"
PRId64
"
)
"
driver
jsnow
)
;
driver
-
>
Tick
(
jsnow
now
)
;
}
int64_t
mLastFireEpoch
;
bool
mLastFireSkipped
;
TimeStamp
mLastFireTime
;
TimeStamp
mTargetTime
;
nsTArray
<
RefPtr
<
nsRefreshDriver
>
>
mContentRefreshDrivers
;
nsTArray
<
RefPtr
<
nsRefreshDriver
>
>
mRootRefreshDrivers
;
static
void
TimerTick
(
nsITimer
*
aTimer
void
*
aClosure
)
{
RefreshDriverTimer
*
timer
=
static_cast
<
RefreshDriverTimer
*
>
(
aClosure
)
;
timer
-
>
Tick
(
)
;
}
}
;
class
SimpleTimerBasedRefreshDriverTimer
:
public
RefreshDriverTimer
{
public
:
explicit
SimpleTimerBasedRefreshDriverTimer
(
double
aRate
)
{
SetRate
(
aRate
)
;
mTimer
=
do_CreateInstance
(
NS_TIMER_CONTRACTID
)
;
}
~
SimpleTimerBasedRefreshDriverTimer
(
)
override
{
StopTimer
(
)
;
}
virtual
void
SetRate
(
double
aNewRate
)
{
mRateMilliseconds
=
aNewRate
;
mRateDuration
=
TimeDuration
:
:
FromMilliseconds
(
mRateMilliseconds
)
;
}
double
GetRate
(
)
const
{
return
mRateMilliseconds
;
}
TimeDuration
GetTimerRate
(
)
override
{
return
mRateDuration
;
}
protected
:
void
StartTimer
(
)
override
{
mLastFireEpoch
=
JS_Now
(
)
;
mLastFireTime
=
TimeStamp
:
:
Now
(
)
;
mTargetTime
=
mLastFireTime
+
mRateDuration
;
uint32_t
delay
=
static_cast
<
uint32_t
>
(
mRateMilliseconds
)
;
mTimer
-
>
InitWithFuncCallback
(
TimerTick
this
delay
nsITimer
:
:
TYPE_ONE_SHOT
)
;
}
void
StopTimer
(
)
override
{
mTimer
-
>
Cancel
(
)
;
}
double
mRateMilliseconds
;
TimeDuration
mRateDuration
;
RefPtr
<
nsITimer
>
mTimer
;
}
;
class
VsyncRefreshDriverTimer
:
public
RefreshDriverTimer
{
public
:
VsyncRefreshDriverTimer
(
)
:
mVsyncChild
(
nullptr
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mVsyncObserver
=
new
RefreshDriverVsyncObserver
(
this
)
;
RefPtr
<
mozilla
:
:
gfx
:
:
VsyncSource
>
vsyncSource
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetHardwareVsync
(
)
;
MOZ_ALWAYS_TRUE
(
mVsyncDispatcher
=
vsyncSource
-
>
GetRefreshTimerVsyncDispatcher
(
)
)
;
mVsyncDispatcher
-
>
SetParentRefreshTimer
(
mVsyncObserver
)
;
mVsyncRate
=
vsyncSource
-
>
GetGlobalDisplay
(
)
.
GetVsyncRate
(
)
;
}
explicit
VsyncRefreshDriverTimer
(
VsyncChild
*
aVsyncChild
)
:
mVsyncChild
(
aVsyncChild
)
{
MOZ_ASSERT
(
!
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mVsyncChild
)
;
mVsyncObserver
=
new
RefreshDriverVsyncObserver
(
this
)
;
mVsyncChild
-
>
SetVsyncObserver
(
mVsyncObserver
)
;
mVsyncRate
=
mVsyncChild
-
>
GetVsyncRate
(
)
;
}
TimeDuration
GetTimerRate
(
)
override
{
if
(
mVsyncRate
!
=
TimeDuration
:
:
Forever
(
)
)
{
return
mVsyncRate
;
}
if
(
mVsyncChild
)
{
mVsyncRate
=
mVsyncChild
-
>
VsyncRate
(
)
;
}
return
mVsyncRate
!
=
TimeDuration
:
:
Forever
(
)
?
mVsyncRate
:
TimeDuration
:
:
FromMilliseconds
(
1000
.
0
/
60
.
0
)
;
}
private
:
class
RefreshDriverVsyncObserver
final
:
public
VsyncObserver
{
public
:
explicit
RefreshDriverVsyncObserver
(
VsyncRefreshDriverTimer
*
aVsyncRefreshDriverTimer
)
:
mVsyncRefreshDriverTimer
(
aVsyncRefreshDriverTimer
)
mRefreshTickLock
(
"
RefreshTickLock
"
)
mRecentVsync
(
TimeStamp
:
:
Now
(
)
)
mLastChildTick
(
TimeStamp
:
:
Now
(
)
)
mVsyncRate
(
TimeDuration
:
:
Forever
(
)
)
mProcessedVsync
(
true
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
class
ParentProcessVsyncNotifier
final
:
public
Runnable
public
nsIRunnablePriority
{
public
:
ParentProcessVsyncNotifier
(
RefreshDriverVsyncObserver
*
aObserver
TimeStamp
aVsyncTimestamp
)
:
mObserver
(
aObserver
)
mVsyncTimestamp
(
aVsyncTimestamp
)
{
}
NS_DECL_ISUPPORTS_INHERITED
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
static
bool
sCacheInitialized
=
false
;
static
bool
sHighPriorityPrefValue
=
false
;
if
(
!
sCacheInitialized
)
{
sCacheInitialized
=
true
;
Preferences
:
:
AddBoolVarCache
(
&
sHighPriorityPrefValue
"
vsync
.
parentProcess
.
highPriority
"
mozilla
:
:
BrowserTabsRemoteAutostart
(
)
)
;
}
sHighPriorityEnabled
=
sHighPriorityPrefValue
;
mObserver
-
>
TickRefreshDriver
(
mVsyncTimestamp
)
;
return
NS_OK
;
}
NS_IMETHOD
GetPriority
(
uint32_t
*
aPriority
)
override
{
*
aPriority
=
sHighPriorityEnabled
?
nsIRunnablePriority
:
:
PRIORITY_HIGH
:
nsIRunnablePriority
:
:
PRIORITY_NORMAL
;
return
NS_OK
;
}
private
:
~
ParentProcessVsyncNotifier
(
)
{
}
RefPtr
<
RefreshDriverVsyncObserver
>
mObserver
;
TimeStamp
mVsyncTimestamp
;
static
mozilla
:
:
Atomic
<
bool
>
sHighPriorityEnabled
;
}
;
bool
NotifyVsync
(
TimeStamp
aVsyncTimestamp
)
override
{
if
(
!
NS_IsMainThread
(
)
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
{
MonitorAutoLock
lock
(
mRefreshTickLock
)
;
mRecentVsync
=
aVsyncTimestamp
;
if
(
!
mProcessedVsync
)
{
return
true
;
}
mProcessedVsync
=
false
;
}
nsCOMPtr
<
nsIRunnable
>
vsyncEvent
=
new
ParentProcessVsyncNotifier
(
this
aVsyncTimestamp
)
;
NS_DispatchToMainThread
(
vsyncEvent
)
;
}
else
{
mRecentVsync
=
aVsyncTimestamp
;
if
(
!
mBlockUntil
.
IsNull
(
)
&
&
mBlockUntil
>
aVsyncTimestamp
)
{
if
(
mProcessedVsync
)
{
mProcessedVsync
=
false
;
nsCOMPtr
<
nsIRunnable
>
vsyncEvent
=
NewRunnableMethod
<
>
(
"
RefreshDriverVsyncObserver
:
:
NormalPriorityNotify
"
this
&
RefreshDriverVsyncObserver
:
:
NormalPriorityNotify
)
;
NS_DispatchToMainThread
(
vsyncEvent
)
;
}
return
true
;
}
TickRefreshDriver
(
aVsyncTimestamp
)
;
}
return
true
;
}
void
Shutdown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mVsyncRefreshDriverTimer
=
nullptr
;
}
void
OnTimerStart
(
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
mLastChildTick
=
TimeStamp
:
:
Now
(
)
;
}
}
void
NormalPriorityNotify
(
)
{
if
(
mLastProcessedTickInChildProcess
.
IsNull
(
)
|
|
mRecentVsync
>
mLastProcessedTickInChildProcess
)
{
mBlockUntil
=
TimeStamp
(
)
;
TickRefreshDriver
(
mRecentVsync
)
;
}
mProcessedVsync
=
true
;
}
private
:
~
RefreshDriverVsyncObserver
(
)
=
default
;
void
RecordTelemetryProbes
(
TimeStamp
aVsyncTimestamp
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
#
ifndef
ANDROID
if
(
XRE_IsParentProcess
(
)
)
{
TimeDuration
vsyncLatency
=
TimeStamp
:
:
Now
(
)
-
aVsyncTimestamp
;
uint32_t
sample
=
(
uint32_t
)
vsyncLatency
.
ToMilliseconds
(
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
FX_REFRESH_DRIVER_CHROME_FRAME_DELAY_MS
sample
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
FX_REFRESH_DRIVER_SYNC_SCROLL_FRAME_DELAY_MS
sample
)
;
RecordJank
(
sample
)
;
}
else
if
(
mVsyncRate
!
=
TimeDuration
:
:
Forever
(
)
)
{
TimeDuration
contentDelay
=
(
TimeStamp
:
:
Now
(
)
-
mLastChildTick
)
-
mVsyncRate
;
if
(
contentDelay
.
ToMilliseconds
(
)
<
0
)
{
contentDelay
=
TimeDuration
:
:
FromMilliseconds
(
0
)
;
}
uint32_t
sample
=
(
uint32_t
)
contentDelay
.
ToMilliseconds
(
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
FX_REFRESH_DRIVER_CONTENT_FRAME_DELAY_MS
sample
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
FX_REFRESH_DRIVER_SYNC_SCROLL_FRAME_DELAY_MS
sample
)
;
RecordJank
(
sample
)
;
}
else
{
if
(
mVsyncRefreshDriverTimer
)
{
mVsyncRate
=
mVsyncRefreshDriverTimer
-
>
mVsyncChild
-
>
GetVsyncRate
(
)
;
}
}
#
endif
}
void
RecordJank
(
uint32_t
aJankMS
)
{
uint32_t
duration
=
1
;
for
(
size_t
i
=
0
;
i
<
mozilla
:
:
ArrayLength
(
sJankLevels
)
&
&
duration
<
aJankMS
;
+
+
i
duration
*
=
2
)
{
sJankLevels
[
i
]
+
+
;
}
}
void
TickRefreshDriver
(
TimeStamp
aVsyncTimestamp
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RecordTelemetryProbes
(
aVsyncTimestamp
)
;
if
(
XRE_IsParentProcess
(
)
)
{
MonitorAutoLock
lock
(
mRefreshTickLock
)
;
aVsyncTimestamp
=
mRecentVsync
;
mProcessedVsync
=
true
;
}
else
{
mLastChildTick
=
TimeStamp
:
:
Now
(
)
;
mLastProcessedTickInChildProcess
=
aVsyncTimestamp
;
}
MOZ_ASSERT
(
aVsyncTimestamp
<
=
TimeStamp
:
:
Now
(
)
)
;
if
(
mVsyncRefreshDriverTimer
)
{
mVsyncRefreshDriverTimer
-
>
RunRefreshDrivers
(
aVsyncTimestamp
)
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
TimeDuration
tickDuration
=
TimeStamp
:
:
Now
(
)
-
mLastChildTick
;
mBlockUntil
=
aVsyncTimestamp
+
tickDuration
;
}
}
VsyncRefreshDriverTimer
*
mVsyncRefreshDriverTimer
;
Monitor
mRefreshTickLock
;
TimeStamp
mRecentVsync
;
TimeStamp
mLastChildTick
;
TimeStamp
mLastProcessedTickInChildProcess
;
TimeStamp
mBlockUntil
;
TimeDuration
mVsyncRate
;
bool
mProcessedVsync
;
}
;
~
VsyncRefreshDriverTimer
(
)
override
{
if
(
XRE_IsParentProcess
(
)
)
{
mVsyncDispatcher
-
>
SetParentRefreshTimer
(
nullptr
)
;
mVsyncDispatcher
=
nullptr
;
}
else
{
Unused
<
<
mVsyncChild
-
>
SendUnobserve
(
)
;
mVsyncChild
-
>
SetVsyncObserver
(
nullptr
)
;
mVsyncChild
=
nullptr
;
}
mVsyncObserver
-
>
Shutdown
(
)
;
mVsyncObserver
=
nullptr
;
}
void
StartTimer
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mLastFireEpoch
=
JS_Now
(
)
;
mLastFireTime
=
TimeStamp
:
:
Now
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
mVsyncDispatcher
-
>
SetParentRefreshTimer
(
mVsyncObserver
)
;
}
else
{
Unused
<
<
mVsyncChild
-
>
SendObserve
(
)
;
mVsyncObserver
-
>
OnTimerStart
(
)
;
}
+
+
sActiveVsyncTimers
;
}
void
StopTimer
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
XRE_IsParentProcess
(
)
)
{
mVsyncDispatcher
-
>
SetParentRefreshTimer
(
nullptr
)
;
}
else
{
Unused
<
<
mVsyncChild
-
>
SendUnobserve
(
)
;
}
MOZ_ASSERT
(
sActiveVsyncTimers
>
0
)
;
-
-
sActiveVsyncTimers
;
}
void
ScheduleNextTick
(
TimeStamp
aNowTime
)
override
{
}
void
RunRefreshDrivers
(
TimeStamp
aTimeStamp
)
{
int64_t
jsnow
=
JS_Now
(
)
;
TimeDuration
diff
=
TimeStamp
:
:
Now
(
)
-
aTimeStamp
;
int64_t
vsyncJsNow
=
jsnow
-
diff
.
ToMicroseconds
(
)
;
Tick
(
vsyncJsNow
aTimeStamp
)
;
}
RefPtr
<
RefreshDriverVsyncObserver
>
mVsyncObserver
;
RefPtr
<
RefreshTimerVsyncDispatcher
>
mVsyncDispatcher
;
RefPtr
<
VsyncChild
>
mVsyncChild
;
TimeDuration
mVsyncRate
;
}
;
NS_IMPL_ISUPPORTS_INHERITED
(
VsyncRefreshDriverTimer
:
:
RefreshDriverVsyncObserver
:
:
ParentProcessVsyncNotifier
Runnable
nsIRunnablePriority
)
mozilla
:
:
Atomic
<
bool
>
VsyncRefreshDriverTimer
:
:
RefreshDriverVsyncObserver
:
:
ParentProcessVsyncNotifier
:
:
sHighPriorityEnabled
(
false
)
;
class
StartupRefreshDriverTimer
:
public
SimpleTimerBasedRefreshDriverTimer
{
public
:
explicit
StartupRefreshDriverTimer
(
double
aRate
)
:
SimpleTimerBasedRefreshDriverTimer
(
aRate
)
{
}
protected
:
void
ScheduleNextTick
(
TimeStamp
aNowTime
)
override
{
TimeStamp
newTarget
=
aNowTime
+
mRateDuration
;
uint32_t
delay
=
static_cast
<
uint32_t
>
(
(
newTarget
-
aNowTime
)
.
ToMilliseconds
(
)
)
;
mTimer
-
>
InitWithFuncCallback
(
TimerTick
this
delay
nsITimer
:
:
TYPE_ONE_SHOT
)
;
mTargetTime
=
newTarget
;
}
}
;
class
InactiveRefreshDriverTimer
final
:
public
SimpleTimerBasedRefreshDriverTimer
{
public
:
explicit
InactiveRefreshDriverTimer
(
double
aRate
)
:
SimpleTimerBasedRefreshDriverTimer
(
aRate
)
mNextTickDuration
(
aRate
)
mDisableAfterMilliseconds
(
-
1
.
0
)
mNextDriverIndex
(
0
)
{
}
InactiveRefreshDriverTimer
(
double
aRate
double
aDisableAfterMilliseconds
)
:
SimpleTimerBasedRefreshDriverTimer
(
aRate
)
mNextTickDuration
(
aRate
)
mDisableAfterMilliseconds
(
aDisableAfterMilliseconds
)
mNextDriverIndex
(
0
)
{
}
void
AddRefreshDriver
(
nsRefreshDriver
*
aDriver
)
override
{
RefreshDriverTimer
:
:
AddRefreshDriver
(
aDriver
)
;
LOG
(
"
[
%
p
]
inactive
timer
got
new
refresh
driver
%
p
resetting
rate
"
this
aDriver
)
;
mNextTickDuration
=
mRateMilliseconds
;
mNextDriverIndex
=
GetRefreshDriverCount
(
)
-
1
;
StopTimer
(
)
;
StartTimer
(
)
;
}
TimeDuration
GetTimerRate
(
)
override
{
return
TimeDuration
:
:
FromMilliseconds
(
mNextTickDuration
)
;
}
protected
:
uint32_t
GetRefreshDriverCount
(
)
{
return
mContentRefreshDrivers
.
Length
(
)
+
mRootRefreshDrivers
.
Length
(
)
;
}
void
StartTimer
(
)
override
{
mLastFireEpoch
=
JS_Now
(
)
;
mLastFireTime
=
TimeStamp
:
:
Now
(
)
;
mTargetTime
=
mLastFireTime
+
mRateDuration
;
uint32_t
delay
=
static_cast
<
uint32_t
>
(
mRateMilliseconds
)
;
mTimer
-
>
InitWithFuncCallback
(
TimerTickOne
this
delay
nsITimer
:
:
TYPE_ONE_SHOT
)
;
}
void
StopTimer
(
)
override
{
mTimer
-
>
Cancel
(
)
;
}
void
ScheduleNextTick
(
TimeStamp
aNowTime
)
override
{
if
(
mDisableAfterMilliseconds
>
0
.
0
&
&
mNextTickDuration
>
mDisableAfterMilliseconds
)
{
return
;
}
if
(
mNextDriverIndex
>
=
GetRefreshDriverCount
(
)
)
{
mNextTickDuration
*
=
2
.
0
;
mNextDriverIndex
=
0
;
}
uint32_t
delay
=
static_cast
<
uint32_t
>
(
mNextTickDuration
)
;
mTimer
-
>
InitWithFuncCallback
(
TimerTickOne
this
delay
nsITimer
:
:
TYPE_ONE_SHOT
)
;
LOG
(
"
[
%
p
]
inactive
timer
next
tick
in
%
f
ms
[
index
%
d
/
%
d
]
"
this
mNextTickDuration
mNextDriverIndex
GetRefreshDriverCount
(
)
)
;
}
void
TickOne
(
)
{
int64_t
jsnow
=
JS_Now
(
)
;
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
ScheduleNextTick
(
now
)
;
mLastFireEpoch
=
jsnow
;
mLastFireTime
=
now
;
mLastFireSkipped
=
false
;
nsTArray
<
RefPtr
<
nsRefreshDriver
>
>
drivers
(
mContentRefreshDrivers
)
;
drivers
.
AppendElements
(
mRootRefreshDrivers
)
;
size_t
index
=
mNextDriverIndex
;
if
(
index
<
drivers
.
Length
(
)
&
&
!
drivers
[
index
]
-
>
IsTestControllingRefreshesEnabled
(
)
)
{
TickDriver
(
drivers
[
index
]
jsnow
now
)
;
mLastFireSkipped
=
mLastFireSkipped
|
|
drivers
[
index
]
-
>
SkippedPaints
(
)
;
}
mNextDriverIndex
+
+
;
}
static
void
TimerTickOne
(
nsITimer
*
aTimer
void
*
aClosure
)
{
InactiveRefreshDriverTimer
*
timer
=
static_cast
<
InactiveRefreshDriverTimer
*
>
(
aClosure
)
;
timer
-
>
TickOne
(
)
;
}
double
mNextTickDuration
;
double
mDisableAfterMilliseconds
;
uint32_t
mNextDriverIndex
;
}
;
class
VsyncChildCreateCallback
final
:
public
nsIIPCBackgroundChildCreateCallback
{
NS_DECL_ISUPPORTS
public
:
VsyncChildCreateCallback
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
static
void
CreateVsyncActor
(
PBackgroundChild
*
aPBackgroundChild
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aPBackgroundChild
)
;
layout
:
:
PVsyncChild
*
actor
=
aPBackgroundChild
-
>
SendPVsyncConstructor
(
)
;
layout
:
:
VsyncChild
*
child
=
static_cast
<
layout
:
:
VsyncChild
*
>
(
actor
)
;
nsRefreshDriver
:
:
PVsyncActorCreated
(
child
)
;
}
private
:
virtual
~
VsyncChildCreateCallback
(
)
=
default
;
void
ActorCreated
(
PBackgroundChild
*
aPBackgroundChild
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
aPBackgroundChild
)
;
CreateVsyncActor
(
aPBackgroundChild
)
;
}
void
ActorFailed
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_CRASH
(
"
Failed
To
Create
VsyncChild
Actor
"
)
;
}
}
;
NS_IMPL_ISUPPORTS
(
VsyncChildCreateCallback
nsIIPCBackgroundChildCreateCallback
)
}
static
RefreshDriverTimer
*
sRegularRateTimer
;
static
InactiveRefreshDriverTimer
*
sThrottledRateTimer
;
static
void
CreateContentVsyncRefreshTimer
(
void
*
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
XRE_IsParentProcess
(
)
)
;
PBackgroundChild
*
backgroundChild
=
BackgroundChild
:
:
GetForCurrentThread
(
)
;
if
(
backgroundChild
)
{
VsyncChildCreateCallback
:
:
CreateVsyncActor
(
backgroundChild
)
;
return
;
}
RefPtr
<
nsIIPCBackgroundChildCreateCallback
>
callback
=
new
VsyncChildCreateCallback
(
)
;
if
(
NS_WARN_IF
(
!
BackgroundChild
:
:
GetOrCreateForCurrentThread
(
callback
)
)
)
{
MOZ_CRASH
(
"
PVsync
actor
create
failed
!
"
)
;
}
}
static
void
CreateVsyncRefreshTimer
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
PodArrayZero
(
sJankLevels
)
;
gfxPrefs
:
:
GetSingleton
(
)
;
if
(
gfxPlatform
:
:
IsInLayoutAsapMode
(
)
)
{
return
;
}
if
(
XRE_IsParentProcess
(
)
)
{
gfxPlatform
:
:
GetPlatform
(
)
;
sRegularRateTimer
=
new
VsyncRefreshDriverTimer
(
)
;
return
;
}
CreateContentVsyncRefreshTimer
(
nullptr
)
;
}
static
uint32_t
GetFirstFrameDelay
(
imgIRequest
*
req
)
{
nsCOMPtr
<
imgIContainer
>
container
;
if
(
NS_FAILED
(
req
-
>
GetImage
(
getter_AddRefs
(
container
)
)
)
|
|
!
container
)
{
return
0
;
}
int32_t
delay
=
container
-
>
GetFirstFrameDelay
(
)
;
if
(
delay
<
0
)
return
0
;
return
static_cast
<
uint32_t
>
(
delay
)
;
}
void
nsRefreshDriver
:
:
Shutdown
(
)
{
delete
sRegularRateTimer
;
delete
sThrottledRateTimer
;
sRegularRateTimer
=
nullptr
;
sThrottledRateTimer
=
nullptr
;
}
int32_t
nsRefreshDriver
:
:
DefaultInterval
(
)
{
return
NSToIntRound
(
1000
.
0
/
gfxPlatform
:
:
GetDefaultFrameRate
(
)
)
;
}
double
nsRefreshDriver
:
:
GetRegularTimerInterval
(
bool
*
outIsDefault
)
const
{
int32_t
rate
=
Preferences
:
:
GetInt
(
"
layout
.
frame_rate
"
-
1
)
;
if
(
rate
<
0
)
{
rate
=
gfxPlatform
:
:
GetDefaultFrameRate
(
)
;
if
(
outIsDefault
)
{
*
outIsDefault
=
true
;
}
}
else
{
if
(
outIsDefault
)
{
*
outIsDefault
=
false
;
}
}
if
(
rate
=
=
0
)
{
rate
=
10000
;
}
return
1000
.
0
/
rate
;
}
double
nsRefreshDriver
:
:
GetThrottledTimerInterval
(
)
{
int32_t
rate
=
Preferences
:
:
GetInt
(
"
layout
.
throttled_frame_rate
"
-
1
)
;
if
(
rate
<
=
0
)
{
rate
=
DEFAULT_THROTTLED_FRAME_RATE
;
}
return
1000
.
0
/
rate
;
}
mozilla
:
:
TimeDuration
nsRefreshDriver
:
:
GetMinRecomputeVisibilityInterval
(
)
{
int32_t
interval
=
Preferences
:
:
GetInt
(
"
layout
.
visibility
.
min
-
recompute
-
interval
-
ms
"
-
1
)
;
if
(
interval
<
=
0
)
{
interval
=
DEFAULT_RECOMPUTE_VISIBILITY_INTERVAL_MS
;
}
return
TimeDuration
:
:
FromMilliseconds
(
interval
)
;
}
double
nsRefreshDriver
:
:
GetRefreshTimerInterval
(
)
const
{
return
mThrottled
?
GetThrottledTimerInterval
(
)
:
GetRegularTimerInterval
(
)
;
}
RefreshDriverTimer
*
nsRefreshDriver
:
:
ChooseTimer
(
)
const
{
if
(
mThrottled
)
{
if
(
!
sThrottledRateTimer
)
sThrottledRateTimer
=
new
InactiveRefreshDriverTimer
(
GetThrottledTimerInterval
(
)
DEFAULT_INACTIVE_TIMER_DISABLE_SECONDS
*
1000
.
0
)
;
return
sThrottledRateTimer
;
}
if
(
!
sRegularRateTimer
)
{
bool
isDefault
=
true
;
double
rate
=
GetRegularTimerInterval
(
&
isDefault
)
;
CreateVsyncRefreshTimer
(
)
;
if
(
!
sRegularRateTimer
)
{
sRegularRateTimer
=
new
StartupRefreshDriverTimer
(
rate
)
;
}
}
return
sRegularRateTimer
;
}
nsRefreshDriver
:
:
nsRefreshDriver
(
nsPresContext
*
aPresContext
)
:
mActiveTimer
(
nullptr
)
mPresContext
(
aPresContext
)
mRootRefresh
(
nullptr
)
mPendingTransaction
(
0
)
mCompletedTransaction
(
0
)
mFreezeCount
(
0
)
mThrottledFrameRequestInterval
(
TimeDuration
:
:
FromMilliseconds
(
GetThrottledTimerInterval
(
)
)
)
mMinRecomputeVisibilityInterval
(
GetMinRecomputeVisibilityInterval
(
)
)
mThrottled
(
false
)
mNeedToRecomputeVisibility
(
false
)
mTestControllingRefreshes
(
false
)
mViewManagerFlushIsPending
(
false
)
mInRefresh
(
false
)
mWaitingForTransaction
(
false
)
mSkippedPaints
(
false
)
mResizeSuppressed
(
false
)
mWarningThreshold
(
REFRESH_WAIT_WARNING
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mPresContext
"
Need
a
pres
context
to
tell
us
to
call
Disconnect
(
)
later
"
"
and
decrement
sRefreshDriverCount
.
"
)
;
mMostRecentRefreshEpochTime
=
JS_Now
(
)
;
mMostRecentRefresh
=
TimeStamp
:
:
Now
(
)
;
mMostRecentTick
=
mMostRecentRefresh
;
mNextThrottledFrameRequestTick
=
mMostRecentTick
;
mNextRecomputeVisibilityTick
=
mMostRecentTick
;
+
+
sRefreshDriverCount
;
}
nsRefreshDriver
:
:
~
nsRefreshDriver
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
ObserverCount
(
)
=
=
0
"
observers
should
have
unregistered
"
)
;
MOZ_ASSERT
(
!
mActiveTimer
"
timer
should
be
gone
"
)
;
MOZ_ASSERT
(
!
mPresContext
"
Should
have
called
Disconnect
(
)
and
decremented
"
"
sRefreshDriverCount
!
"
)
;
if
(
mRootRefresh
)
{
mRootRefresh
-
>
RemoveRefreshObserver
(
this
FlushType
:
:
Style
)
;
mRootRefresh
=
nullptr
;
}
}
void
nsRefreshDriver
:
:
AdvanceTimeAndRefresh
(
int64_t
aMilliseconds
)
{
StopTimer
(
)
;
if
(
!
mTestControllingRefreshes
)
{
mMostRecentRefreshEpochTime
=
JS_Now
(
)
;
mMostRecentRefresh
=
TimeStamp
:
:
Now
(
)
;
mTestControllingRefreshes
=
true
;
if
(
mWaitingForTransaction
)
{
mWaitingForTransaction
=
false
;
mSkippedPaints
=
false
;
mWarningThreshold
=
REFRESH_WAIT_WARNING
;
}
}
mMostRecentRefreshEpochTime
+
=
aMilliseconds
*
1000
;
mMostRecentRefresh
+
=
TimeDuration
:
:
FromMilliseconds
(
(
double
)
aMilliseconds
)
;
mozilla
:
:
dom
:
:
AutoNoJSAPI
nojsapi
;
DoTick
(
)
;
}
void
nsRefreshDriver
:
:
RestoreNormalRefresh
(
)
{
mTestControllingRefreshes
=
false
;
EnsureTimerStarted
(
eAllowTimeToGoBackwards
)
;
mCompletedTransaction
=
mPendingTransaction
;
}
TimeStamp
nsRefreshDriver
:
:
MostRecentRefresh
(
)
const
{
if
(
!
ServoStyleSet
:
:
IsInServoTraversal
(
)
)
{
const_cast
<
nsRefreshDriver
*
>
(
this
)
-
>
EnsureTimerStarted
(
)
;
}
return
mMostRecentRefresh
;
}
int64_t
nsRefreshDriver
:
:
MostRecentRefreshEpochTime
(
)
const
{
const_cast
<
nsRefreshDriver
*
>
(
this
)
-
>
EnsureTimerStarted
(
)
;
return
mMostRecentRefreshEpochTime
;
}
bool
nsRefreshDriver
:
:
AddRefreshObserver
(
nsARefreshObserver
*
aObserver
FlushType
aFlushType
)
{
ObserverArray
&
array
=
ArrayFor
(
aFlushType
)
;
bool
success
=
array
.
AppendElement
(
aObserver
)
!
=
nullptr
;
EnsureTimerStarted
(
)
;
return
success
;
}
bool
nsRefreshDriver
:
:
RemoveRefreshObserver
(
nsARefreshObserver
*
aObserver
FlushType
aFlushType
)
{
ObserverArray
&
array
=
ArrayFor
(
aFlushType
)
;
return
array
.
RemoveElement
(
aObserver
)
;
}
void
nsRefreshDriver
:
:
AddPostRefreshObserver
(
nsAPostRefreshObserver
*
aObserver
)
{
mPostRefreshObservers
.
AppendElement
(
aObserver
)
;
}
void
nsRefreshDriver
:
:
RemovePostRefreshObserver
(
nsAPostRefreshObserver
*
aObserver
)
{
mPostRefreshObservers
.
RemoveElement
(
aObserver
)
;
}
bool
nsRefreshDriver
:
:
AddImageRequest
(
imgIRequest
*
aRequest
)
{
uint32_t
delay
=
GetFirstFrameDelay
(
aRequest
)
;
if
(
delay
=
=
0
)
{
if
(
!
mRequests
.
PutEntry
(
aRequest
)
)
{
return
false
;
}
}
else
{
ImageStartData
*
start
=
mStartTable
.
Get
(
delay
)
;
if
(
!
start
)
{
start
=
new
ImageStartData
(
)
;
mStartTable
.
Put
(
delay
start
)
;
}
start
-
>
mEntries
.
PutEntry
(
aRequest
)
;
}
EnsureTimerStarted
(
)
;
return
true
;
}
void
nsRefreshDriver
:
:
RemoveImageRequest
(
imgIRequest
*
aRequest
)
{
mRequests
.
RemoveEntry
(
aRequest
)
;
uint32_t
delay
=
GetFirstFrameDelay
(
aRequest
)
;
if
(
delay
!
=
0
)
{
ImageStartData
*
start
=
mStartTable
.
Get
(
delay
)
;
if
(
start
)
{
start
-
>
mEntries
.
RemoveEntry
(
aRequest
)
;
}
}
}
void
nsRefreshDriver
:
:
EnsureTimerStarted
(
EnsureTimerStartedFlags
aFlags
)
{
MOZ_ASSERT
(
!
ServoStyleSet
:
:
IsInServoTraversal
(
)
|
|
NS_IsMainThread
(
)
"
EnsureTimerStarted
should
be
called
only
when
we
are
not
"
"
in
servo
traversal
or
on
the
main
-
thread
"
)
;
if
(
mTestControllingRefreshes
)
return
;
if
(
mActiveTimer
&
&
!
(
aFlags
&
eForceAdjustTimer
)
)
return
;
if
(
IsFrozen
(
)
|
|
!
mPresContext
)
{
StopTimer
(
)
;
return
;
}
if
(
mPresContext
-
>
Document
(
)
-
>
IsBeingUsedAsImage
(
)
)
{
nsIURI
*
uri
=
mPresContext
-
>
Document
(
)
-
>
GetDocumentURI
(
)
;
if
(
!
uri
|
|
!
IsFontTableURI
(
uri
)
)
{
MOZ_ASSERT
(
!
mActiveTimer
"
image
doc
refresh
driver
should
never
have
its
own
timer
"
)
;
return
;
}
}
RefreshDriverTimer
*
newTimer
=
ChooseTimer
(
)
;
if
(
newTimer
!
=
mActiveTimer
)
{
if
(
mActiveTimer
)
mActiveTimer
-
>
RemoveRefreshDriver
(
this
)
;
mActiveTimer
=
newTimer
;
mActiveTimer
-
>
AddRefreshDriver
(
this
)
;
}
if
(
aFlags
&
eNeverAdjustTimer
)
{
return
;
}
mMostRecentRefresh
=
aFlags
&
eAllowTimeToGoBackwards
?
mActiveTimer
-
>
MostRecentRefresh
(
)
:
std
:
:
max
(
mActiveTimer
-
>
MostRecentRefresh
(
)
mMostRecentRefresh
)
;
mMostRecentRefreshEpochTime
=
aFlags
&
eAllowTimeToGoBackwards
?
mActiveTimer
-
>
MostRecentRefreshEpochTime
(
)
:
std
:
:
max
(
mActiveTimer
-
>
MostRecentRefreshEpochTime
(
)
mMostRecentRefreshEpochTime
)
;
}
void
nsRefreshDriver
:
:
StopTimer
(
)
{
if
(
!
mActiveTimer
)
return
;
mActiveTimer
-
>
RemoveRefreshDriver
(
this
)
;
mActiveTimer
=
nullptr
;
}
uint32_t
nsRefreshDriver
:
:
ObserverCount
(
)
const
{
uint32_t
sum
=
0
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
mObservers
)
;
+
+
i
)
{
sum
+
=
mObservers
[
i
]
.
Length
(
)
;
}
sum
+
=
mStyleFlushObservers
.
Length
(
)
;
sum
+
=
mLayoutFlushObservers
.
Length
(
)
;
sum
+
=
mPendingEvents
.
Length
(
)
;
sum
+
=
mFrameRequestCallbackDocs
.
Length
(
)
;
sum
+
=
mThrottledFrameRequestCallbackDocs
.
Length
(
)
;
sum
+
=
mViewManagerFlushIsPending
;
return
sum
;
}
uint32_t
nsRefreshDriver
:
:
ImageRequestCount
(
)
const
{
uint32_t
count
=
0
;
for
(
auto
iter
=
mStartTable
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
count
+
=
iter
.
UserData
(
)
-
>
mEntries
.
Count
(
)
;
}
return
count
+
mRequests
.
Count
(
)
;
}
nsRefreshDriver
:
:
ObserverArray
&
nsRefreshDriver
:
:
ArrayFor
(
FlushType
aFlushType
)
{
switch
(
aFlushType
)
{
case
FlushType
:
:
Style
:
return
mObservers
[
0
]
;
case
FlushType
:
:
Layout
:
return
mObservers
[
1
]
;
case
FlushType
:
:
Display
:
return
mObservers
[
2
]
;
default
:
MOZ_CRASH
(
"
We
don
'
t
track
refresh
observers
for
this
flush
type
"
)
;
}
}
void
nsRefreshDriver
:
:
DoTick
(
)
{
NS_PRECONDITION
(
!
IsFrozen
(
)
"
Why
are
we
notified
while
frozen
?
"
)
;
NS_PRECONDITION
(
mPresContext
"
Why
are
we
notified
after
disconnection
?
"
)
;
NS_PRECONDITION
(
!
nsContentUtils
:
:
GetCurrentJSContext
(
)
"
Shouldn
'
t
have
a
JSContext
on
the
stack
"
)
;
if
(
mTestControllingRefreshes
)
{
Tick
(
mMostRecentRefreshEpochTime
mMostRecentRefresh
)
;
}
else
{
Tick
(
JS_Now
(
)
TimeStamp
:
:
Now
(
)
)
;
}
}
struct
DocumentFrameCallbacks
{
explicit
DocumentFrameCallbacks
(
nsIDocument
*
aDocument
)
:
mDocument
(
aDocument
)
{
}
nsCOMPtr
<
nsIDocument
>
mDocument
;
nsIDocument
:
:
FrameRequestCallbackList
mCallbacks
;
}
;
static
nsDocShell
*
GetDocShell
(
nsPresContext
*
aPresContext
)
{
return
static_cast
<
nsDocShell
*
>
(
aPresContext
-
>
GetDocShell
(
)
)
;
}
static
bool
HasPendingAnimations
(
nsIPresShell
*
aShell
)
{
nsIDocument
*
doc
=
aShell
-
>
GetDocument
(
)
;
if
(
!
doc
)
{
return
false
;
}
PendingAnimationTracker
*
tracker
=
doc
-
>
GetPendingAnimationTracker
(
)
;
return
tracker
&
&
tracker
-
>
HasPendingAnimations
(
)
;
}
static
void
GetProfileTimelineSubDocShells
(
nsDocShell
*
aRootDocShell
nsTArray
<
nsDocShell
*
>
&
aShells
)
{
if
(
!
aRootDocShell
)
{
return
;
}
RefPtr
<
TimelineConsumers
>
timelines
=
TimelineConsumers
:
:
Get
(
)
;
if
(
!
timelines
|
|
timelines
-
>
IsEmpty
(
)
)
{
return
;
}
nsCOMPtr
<
nsISimpleEnumerator
>
enumerator
;
nsresult
rv
=
aRootDocShell
-
>
GetDocShellEnumerator
(
nsIDocShellTreeItem
:
:
typeAll
nsIDocShell
:
:
ENUMERATE_BACKWARDS
getter_AddRefs
(
enumerator
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
nsCOMPtr
<
nsIDocShell
>
curItem
;
bool
hasMore
=
false
;
while
(
NS_SUCCEEDED
(
enumerator
-
>
HasMoreElements
(
&
hasMore
)
)
&
&
hasMore
)
{
nsCOMPtr
<
nsISupports
>
curSupports
;
enumerator
-
>
GetNext
(
getter_AddRefs
(
curSupports
)
)
;
curItem
=
do_QueryInterface
(
curSupports
)
;
if
(
!
curItem
|
|
!
curItem
-
>
GetRecordProfileTimelineMarkers
(
)
)
{
continue
;
}
nsDocShell
*
shell
=
static_cast
<
nsDocShell
*
>
(
curItem
.
get
(
)
)
;
bool
isVisible
=
false
;
shell
-
>
GetVisibility
(
&
isVisible
)
;
if
(
!
isVisible
)
{
continue
;
}
aShells
.
AppendElement
(
shell
)
;
}
}
static
void
TakeFrameRequestCallbacksFrom
(
nsIDocument
*
aDocument
nsTArray
<
DocumentFrameCallbacks
>
&
aTarget
)
{
aTarget
.
AppendElement
(
aDocument
)
;
aDocument
-
>
TakeFrameRequestCallbacks
(
aTarget
.
LastElement
(
)
.
mCallbacks
)
;
}
void
nsRefreshDriver
:
:
DispatchPendingEvents
(
)
{
nsTArray
<
PendingEvent
>
pendingEvents
(
Move
(
mPendingEvents
)
)
;
for
(
PendingEvent
&
event
:
pendingEvents
)
{
bool
dummy
;
event
.
mTarget
-
>
DispatchEvent
(
event
.
mEvent
&
dummy
)
;
}
}
static
bool
CollectDocuments
(
nsIDocument
*
aDocument
void
*
aDocArray
)
{
static_cast
<
AutoTArray
<
nsCOMPtr
<
nsIDocument
>
32
>
*
>
(
aDocArray
)
-
>
AppendElement
(
aDocument
)
;
aDocument
-
>
EnumerateSubDocuments
(
CollectDocuments
aDocArray
)
;
return
true
;
}
void
nsRefreshDriver
:
:
DispatchAnimationEvents
(
)
{
if
(
!
mPresContext
)
{
return
;
}
AutoTArray
<
nsCOMPtr
<
nsIDocument
>
32
>
documents
;
CollectDocuments
(
mPresContext
-
>
Document
(
)
&
documents
)
;
for
(
uint32_t
i
=
0
;
i
<
documents
.
Length
(
)
;
+
+
i
)
{
nsIDocument
*
doc
=
documents
[
i
]
;
nsIPresShell
*
shell
=
doc
-
>
GetShell
(
)
;
if
(
!
shell
)
{
continue
;
}
RefPtr
<
nsPresContext
>
context
=
shell
-
>
GetPresContext
(
)
;
if
(
!
context
|
|
context
-
>
RefreshDriver
(
)
!
=
this
)
{
continue
;
}
context
-
>
TransitionManager
(
)
-
>
SortEvents
(
)
;
context
-
>
AnimationManager
(
)
-
>
SortEvents
(
)
;
context
-
>
TransitionManager
(
)
-
>
DispatchEvents
(
)
;
if
(
context
-
>
GetPresShell
(
)
)
{
context
-
>
AnimationManager
(
)
-
>
DispatchEvents
(
)
;
}
}
}
void
nsRefreshDriver
:
:
RunFrameRequestCallbacks
(
TimeStamp
aNowTime
)
{
nsTArray
<
DocumentFrameCallbacks
>
frameRequestCallbacks
(
mFrameRequestCallbackDocs
.
Length
(
)
+
mThrottledFrameRequestCallbackDocs
.
Length
(
)
)
;
{
nsTArray
<
nsIDocument
*
>
docsToRemove
;
bool
tickThrottledFrameRequests
=
mThrottled
;
if
(
!
tickThrottledFrameRequests
&
&
aNowTime
>
=
mNextThrottledFrameRequestTick
)
{
mNextThrottledFrameRequestTick
=
aNowTime
+
mThrottledFrameRequestInterval
;
tickThrottledFrameRequests
=
true
;
}
for
(
nsIDocument
*
doc
:
mThrottledFrameRequestCallbackDocs
)
{
if
(
tickThrottledFrameRequests
)
{
TakeFrameRequestCallbacksFrom
(
doc
frameRequestCallbacks
)
;
}
else
if
(
!
doc
-
>
ShouldThrottleFrameRequests
(
)
)
{
TakeFrameRequestCallbacksFrom
(
doc
frameRequestCallbacks
)
;
docsToRemove
.
AppendElement
(
doc
)
;
}
}
if
(
tickThrottledFrameRequests
)
{
mThrottledFrameRequestCallbackDocs
.
Clear
(
)
;
}
else
{
for
(
nsIDocument
*
doc
:
docsToRemove
)
{
mThrottledFrameRequestCallbackDocs
.
RemoveElement
(
doc
)
;
}
}
}
for
(
nsIDocument
*
doc
:
mFrameRequestCallbackDocs
)
{
TakeFrameRequestCallbacksFrom
(
doc
frameRequestCallbacks
)
;
}
mFrameRequestCallbackDocs
.
Clear
(
)
;
if
(
!
frameRequestCallbacks
.
IsEmpty
(
)
)
{
GeckoProfilerTracingRAII
tracer
(
"
Paint
"
"
Scripts
"
)
;
for
(
const
DocumentFrameCallbacks
&
docCallbacks
:
frameRequestCallbacks
)
{
nsPIDOMWindowInner
*
innerWindow
=
docCallbacks
.
mDocument
-
>
GetInnerWindow
(
)
;
DOMHighResTimeStamp
timeStamp
=
0
;
if
(
innerWindow
&
&
innerWindow
-
>
IsInnerWindow
(
)
)
{
mozilla
:
:
dom
:
:
Performance
*
perf
=
innerWindow
-
>
GetPerformance
(
)
;
if
(
perf
)
{
timeStamp
=
perf
-
>
GetDOMTiming
(
)
-
>
TimeStampToDOMHighRes
(
aNowTime
)
;
}
}
for
(
auto
&
callback
:
docCallbacks
.
mCallbacks
)
{
callback
-
>
Call
(
timeStamp
)
;
}
}
}
}
void
nsRefreshDriver
:
:
Tick
(
int64_t
aNowEpoch
TimeStamp
aNowTime
)
{
NS_PRECONDITION
(
!
nsContentUtils
:
:
GetCurrentJSContext
(
)
"
Shouldn
'
t
have
a
JSContext
on
the
stack
"
)
;
if
(
nsNPAPIPluginInstance
:
:
InPluginCallUnsafeForReentry
(
)
)
{
NS_ERROR
(
"
Refresh
driver
should
not
run
during
plugin
call
!
"
)
;
return
;
}
PROFILER_LABEL
(
"
nsRefreshDriver
"
"
Tick
"
js
:
:
ProfileEntry
:
:
Category
:
:
GRAPHICS
)
;
if
(
IsFrozen
(
)
|
|
!
mPresContext
)
{
return
;
}
if
(
(
aNowTime
<
=
mMostRecentRefresh
)
&
&
!
mTestControllingRefreshes
)
{
return
;
}
TimeStamp
previousRefresh
=
mMostRecentRefresh
;
mMostRecentRefresh
=
aNowTime
;
mMostRecentRefreshEpochTime
=
aNowEpoch
;
if
(
IsWaitingForPaint
(
aNowTime
)
)
{
return
;
}
mMostRecentTick
=
aNowTime
;
if
(
mRootRefresh
)
{
mRootRefresh
-
>
RemoveRefreshObserver
(
this
FlushType
:
:
Style
)
;
mRootRefresh
=
nullptr
;
}
mSkippedPaints
=
false
;
mWarningThreshold
=
1
;
nsCOMPtr
<
nsIPresShell
>
presShell
=
mPresContext
-
>
GetPresShell
(
)
;
if
(
!
presShell
|
|
(
ObserverCount
(
)
=
=
0
&
&
ImageRequestCount
(
)
=
=
0
)
)
{
StopTimer
(
)
;
return
;
}
mResizeSuppressed
=
false
;
AutoRestore
<
bool
>
restoreInRefresh
(
mInRefresh
)
;
mInRefresh
=
true
;
AutoRestore
<
TimeStamp
>
restoreTickStart
(
mTickStart
)
;
mTickStart
=
TimeStamp
:
:
Now
(
)
;
gfxPlatform
:
:
GetPlatform
(
)
-
>
SchedulePaintIfDeviceReset
(
)
;
if
(
gfxPrefs
:
:
APZPeekMessages
(
)
)
{
nsLayoutUtils
:
:
UpdateDisplayPortMarginsFromPendingMessages
(
)
;
}
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
mObservers
)
;
+
+
i
)
{
ObserverArray
:
:
EndLimitedIterator
etor
(
mObservers
[
i
]
)
;
while
(
etor
.
HasMore
(
)
)
{
RefPtr
<
nsARefreshObserver
>
obs
=
etor
.
GetNext
(
)
;
obs
-
>
WillRefresh
(
aNowTime
)
;
if
(
!
mPresContext
|
|
!
mPresContext
-
>
GetPresShell
(
)
)
{
StopTimer
(
)
;
return
;
}
}
if
(
i
=
=
0
)
{
DispatchAnimationEvents
(
)
;
DispatchPendingEvents
(
)
;
RunFrameRequestCallbacks
(
aNowTime
)
;
if
(
mPresContext
&
&
mPresContext
-
>
GetPresShell
(
)
)
{
Maybe
<
GeckoProfilerTracingRAII
>
tracingStyleFlush
;
AutoTArray
<
nsIPresShell
*
16
>
observers
;
observers
.
AppendElements
(
mStyleFlushObservers
)
;
for
(
uint32_t
j
=
observers
.
Length
(
)
;
j
&
&
mPresContext
&
&
mPresContext
-
>
GetPresShell
(
)
;
-
-
j
)
{
nsIPresShell
*
shell
=
observers
[
j
-
1
]
;
if
(
!
mStyleFlushObservers
.
RemoveElement
(
shell
)
)
continue
;
if
(
!
tracingStyleFlush
)
{
tracingStyleFlush
.
emplace
(
"
Paint
"
"
Styles
"
Move
(
mStyleCause
)
)
;
mStyleCause
=
nullptr
;
}
nsCOMPtr
<
nsIPresShell
>
shellKungFuDeathGrip
(
shell
)
;
shell
-
>
mObservingStyleFlushes
=
false
;
shell
-
>
FlushPendingNotifications
(
ChangesToFlush
(
FlushType
:
:
Style
false
)
)
;
nsPresContext
*
presContext
=
shell
-
>
GetPresContext
(
)
;
if
(
presContext
)
{
presContext
-
>
NotifyFontFaceSetOnRefresh
(
)
;
}
mNeedToRecomputeVisibility
=
true
;
}
}
}
else
if
(
i
=
=
1
)
{
Maybe
<
GeckoProfilerTracingRAII
>
tracingLayoutFlush
;
AutoTArray
<
nsIPresShell
*
16
>
observers
;
observers
.
AppendElements
(
mLayoutFlushObservers
)
;
for
(
uint32_t
j
=
observers
.
Length
(
)
;
j
&
&
mPresContext
&
&
mPresContext
-
>
GetPresShell
(
)
;
-
-
j
)
{
nsIPresShell
*
shell
=
observers
[
j
-
1
]
;
if
(
!
mLayoutFlushObservers
.
RemoveElement
(
shell
)
)
continue
;
if
(
!
tracingLayoutFlush
)
{
tracingLayoutFlush
.
emplace
(
"
Paint
"
"
Reflow
"
Move
(
mReflowCause
)
)
;
mReflowCause
=
nullptr
;
}
nsCOMPtr
<
nsIPresShell
>
shellKungFuDeathGrip
(
shell
)
;
shell
-
>
mObservingLayoutFlushes
=
false
;
shell
-
>
mSuppressInterruptibleReflows
=
false
;
FlushType
flushType
=
HasPendingAnimations
(
shell
)
?
FlushType
:
:
Layout
:
FlushType
:
:
InterruptibleLayout
;
shell
-
>
FlushPendingNotifications
(
ChangesToFlush
(
flushType
false
)
)
;
nsPresContext
*
presContext
=
shell
-
>
GetPresContext
(
)
;
if
(
presContext
)
{
presContext
-
>
NotifyFontFaceSetOnRefresh
(
)
;
}
mNeedToRecomputeVisibility
=
true
;
}
}
if
(
!
mPresContext
|
|
!
mPresContext
-
>
GetPresShell
(
)
)
{
StopTimer
(
)
;
return
;
}
}
if
(
mNeedToRecomputeVisibility
&
&
!
mThrottled
&
&
aNowTime
>
=
mNextRecomputeVisibilityTick
&
&
!
presShell
-
>
IsPaintingSuppressed
(
)
)
{
mNextRecomputeVisibilityTick
=
aNowTime
+
mMinRecomputeVisibilityInterval
;
mNeedToRecomputeVisibility
=
false
;
presShell
-
>
ScheduleApproximateFrameVisibilityUpdateNow
(
)
;
}
#
ifdef
MOZ_XUL
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
pm
)
{
pm
-
>
UpdatePopupPositions
(
this
)
;
}
#
endif
AutoTArray
<
nsCOMPtr
<
nsIDocument
>
32
>
documents
;
CollectDocuments
(
mPresContext
-
>
Document
(
)
&
documents
)
;
for
(
uint32_t
i
=
0
;
i
<
documents
.
Length
(
)
;
+
+
i
)
{
nsIDocument
*
doc
=
documents
[
i
]
;
doc
-
>
UpdateIntersectionObservations
(
)
;
doc
-
>
ScheduleIntersectionObserverNotification
(
)
;
}
for
(
auto
iter
=
mStartTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
uint32_t
&
delay
=
iter
.
Key
(
)
;
ImageStartData
*
data
=
iter
.
UserData
(
)
;
if
(
data
-
>
mStartTime
)
{
TimeStamp
&
start
=
*
data
-
>
mStartTime
;
TimeDuration
prev
=
previousRefresh
-
start
;
TimeDuration
curr
=
aNowTime
-
start
;
uint32_t
prevMultiple
=
uint32_t
(
prev
.
ToMilliseconds
(
)
)
/
delay
;
if
(
prevMultiple
!
=
uint32_t
(
curr
.
ToMilliseconds
(
)
)
/
delay
)
{
mozilla
:
:
TimeStamp
desired
=
start
+
TimeDuration
:
:
FromMilliseconds
(
prevMultiple
*
delay
)
;
BeginRefreshingImages
(
data
-
>
mEntries
desired
)
;
}
}
else
{
mozilla
:
:
TimeStamp
desired
=
aNowTime
;
BeginRefreshingImages
(
data
-
>
mEntries
desired
)
;
data
-
>
mStartTime
.
emplace
(
aNowTime
)
;
}
}
if
(
mRequests
.
Count
(
)
)
{
nsCOMArray
<
imgIContainer
>
imagesToRefresh
(
mRequests
.
Count
(
)
)
;
for
(
auto
iter
=
mRequests
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsISupportsHashKey
*
entry
=
iter
.
Get
(
)
;
auto
req
=
static_cast
<
imgIRequest
*
>
(
entry
-
>
GetKey
(
)
)
;
MOZ_ASSERT
(
req
"
Unable
to
retrieve
the
image
request
"
)
;
nsCOMPtr
<
imgIContainer
>
image
;
if
(
NS_SUCCEEDED
(
req
-
>
GetImage
(
getter_AddRefs
(
image
)
)
)
)
{
imagesToRefresh
.
AppendElement
(
image
.
forget
(
)
)
;
}
}
for
(
uint32_t
i
=
0
;
i
<
imagesToRefresh
.
Length
(
)
;
i
+
+
)
{
imagesToRefresh
[
i
]
-
>
RequestRefresh
(
aNowTime
)
;
}
}
bool
notifyGC
=
false
;
if
(
mViewManagerFlushIsPending
)
{
RefPtr
<
TimelineConsumers
>
timelines
=
TimelineConsumers
:
:
Get
(
)
;
nsTArray
<
nsDocShell
*
>
profilingDocShells
;
GetProfileTimelineSubDocShells
(
GetDocShell
(
mPresContext
)
profilingDocShells
)
;
for
(
nsDocShell
*
docShell
:
profilingDocShells
)
{
MOZ_ASSERT
(
timelines
)
;
MOZ_ASSERT
(
timelines
-
>
HasConsumer
(
docShell
)
)
;
timelines
-
>
AddMarkerForDocShell
(
docShell
"
Paint
"
MarkerTracingType
:
:
START
)
;
}
#
ifdef
MOZ_DUMP_PAINTING
if
(
nsLayoutUtils
:
:
InvalidationDebuggingIsEnabled
(
)
)
{
printf_stderr
(
"
Starting
ProcessPendingUpdates
\
n
"
)
;
}
#
endif
mViewManagerFlushIsPending
=
false
;
RefPtr
<
nsViewManager
>
vm
=
mPresContext
-
>
GetPresShell
(
)
-
>
GetViewManager
(
)
;
{
PaintTelemetry
:
:
AutoRecordPaint
record
;
vm
-
>
ProcessPendingUpdates
(
)
;
}
#
ifdef
MOZ_DUMP_PAINTING
if
(
nsLayoutUtils
:
:
InvalidationDebuggingIsEnabled
(
)
)
{
printf_stderr
(
"
Ending
ProcessPendingUpdates
\
n
"
)
;
}
#
endif
for
(
nsDocShell
*
docShell
:
profilingDocShells
)
{
MOZ_ASSERT
(
timelines
)
;
MOZ_ASSERT
(
timelines
-
>
HasConsumer
(
docShell
)
)
;
timelines
-
>
AddMarkerForDocShell
(
docShell
"
Paint
"
MarkerTracingType
:
:
END
)
;
}
notifyGC
=
true
;
}
#
ifndef
ANDROID
mozilla
:
:
Telemetry
:
:
AccumulateTimeDelta
(
mozilla
:
:
Telemetry
:
:
REFRESH_DRIVER_TICK
mTickStart
)
;
#
endif
nsTObserverArray
<
nsAPostRefreshObserver
*
>
:
:
ForwardIterator
iter
(
mPostRefreshObservers
)
;
while
(
iter
.
HasMore
(
)
)
{
nsAPostRefreshObserver
*
observer
=
iter
.
GetNext
(
)
;
observer
-
>
DidRefresh
(
)
;
}
NS_ASSERTION
(
mInRefresh
"
Still
in
refresh
"
)
;
if
(
mPresContext
-
>
IsRoot
(
)
&
&
XRE_IsContentProcess
(
)
&
&
gfxPrefs
:
:
AlwaysPaint
(
)
)
{
ScheduleViewManagerFlush
(
)
;
}
if
(
notifyGC
&
&
nsContentUtils
:
:
XPConnect
(
)
)
{
GeckoProfilerTracingRAII
tracer
(
"
Paint
"
"
NotifyDidPaint
"
)
;
nsContentUtils
:
:
XPConnect
(
)
-
>
NotifyDidPaint
(
)
;
nsJSContext
:
:
NotifyDidPaint
(
)
;
}
}
void
nsRefreshDriver
:
:
BeginRefreshingImages
(
RequestTable
&
aEntries
mozilla
:
:
TimeStamp
aDesired
)
{
for
(
auto
iter
=
aEntries
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
req
=
static_cast
<
imgIRequest
*
>
(
iter
.
Get
(
)
-
>
GetKey
(
)
)
;
MOZ_ASSERT
(
req
"
Unable
to
retrieve
the
image
request
"
)
;
mRequests
.
PutEntry
(
req
)
;
nsCOMPtr
<
imgIContainer
>
image
;
if
(
NS_SUCCEEDED
(
req
-
>
GetImage
(
getter_AddRefs
(
image
)
)
)
)
{
image
-
>
SetAnimationStartTime
(
aDesired
)
;
}
}
aEntries
.
Clear
(
)
;
}
void
nsRefreshDriver
:
:
Freeze
(
)
{
StopTimer
(
)
;
mFreezeCount
+
+
;
}
void
nsRefreshDriver
:
:
Thaw
(
)
{
NS_ASSERTION
(
mFreezeCount
>
0
"
Thaw
(
)
called
on
an
unfrozen
refresh
driver
"
)
;
if
(
mFreezeCount
>
0
)
{
mFreezeCount
-
-
;
}
if
(
mFreezeCount
=
=
0
)
{
if
(
ObserverCount
(
)
|
|
ImageRequestCount
(
)
)
{
RefPtr
<
nsRunnableMethod
<
nsRefreshDriver
>
>
event
=
NewRunnableMethod
(
this
&
nsRefreshDriver
:
:
DoRefresh
)
;
nsPresContext
*
pc
=
GetPresContext
(
)
;
if
(
pc
)
{
pc
-
>
Document
(
)
-
>
Dispatch
(
"
nsRefreshDriver
:
:
DoRefresh
"
TaskCategory
:
:
Other
event
.
forget
(
)
)
;
EnsureTimerStarted
(
)
;
}
else
{
NS_ERROR
(
"
Thawing
while
document
is
being
destroyed
"
)
;
}
}
}
}
void
nsRefreshDriver
:
:
FinishedWaitingForTransaction
(
)
{
mWaitingForTransaction
=
false
;
if
(
mSkippedPaints
&
&
!
IsInRefresh
(
)
&
&
(
ObserverCount
(
)
|
|
ImageRequestCount
(
)
)
)
{
GeckoProfilerTracingRAII
tracer
(
"
Paint
"
"
RefreshDriverTick
"
)
;
DoRefresh
(
)
;
}
mSkippedPaints
=
false
;
mWarningThreshold
=
1
;
}
uint64_t
nsRefreshDriver
:
:
GetTransactionId
(
)
{
+
+
mPendingTransaction
;
if
(
mPendingTransaction
>
=
mCompletedTransaction
+
2
&
&
!
mWaitingForTransaction
&
&
!
mTestControllingRefreshes
)
{
mWaitingForTransaction
=
true
;
mSkippedPaints
=
false
;
mWarningThreshold
=
1
;
}
return
mPendingTransaction
;
}
uint64_t
nsRefreshDriver
:
:
LastTransactionId
(
)
const
{
return
mPendingTransaction
;
}
void
nsRefreshDriver
:
:
RevokeTransactionId
(
uint64_t
aTransactionId
)
{
MOZ_ASSERT
(
aTransactionId
=
=
mPendingTransaction
)
;
if
(
mPendingTransaction
=
=
mCompletedTransaction
+
2
&
&
mWaitingForTransaction
)
{
MOZ_ASSERT
(
!
mSkippedPaints
"
How
did
we
skip
a
paint
when
we
'
re
in
the
middle
of
one
?
"
)
;
FinishedWaitingForTransaction
(
)
;
}
mPendingTransaction
-
-
;
}
void
nsRefreshDriver
:
:
ClearPendingTransactions
(
)
{
mCompletedTransaction
=
mPendingTransaction
;
mWaitingForTransaction
=
false
;
}
void
nsRefreshDriver
:
:
ResetInitialTransactionId
(
uint64_t
aTransactionId
)
{
mCompletedTransaction
=
mPendingTransaction
=
aTransactionId
;
}
mozilla
:
:
TimeStamp
nsRefreshDriver
:
:
GetTransactionStart
(
)
{
return
mTickStart
;
}
void
nsRefreshDriver
:
:
NotifyTransactionCompleted
(
uint64_t
aTransactionId
)
{
if
(
aTransactionId
>
mCompletedTransaction
)
{
if
(
mPendingTransaction
>
mCompletedTransaction
+
1
&
&
mWaitingForTransaction
)
{
mCompletedTransaction
=
aTransactionId
;
FinishedWaitingForTransaction
(
)
;
}
else
{
mCompletedTransaction
=
aTransactionId
;
}
}
}
void
nsRefreshDriver
:
:
WillRefresh
(
mozilla
:
:
TimeStamp
aTime
)
{
mRootRefresh
-
>
RemoveRefreshObserver
(
this
FlushType
:
:
Style
)
;
mRootRefresh
=
nullptr
;
if
(
mSkippedPaints
)
{
DoRefresh
(
)
;
}
}
bool
nsRefreshDriver
:
:
IsWaitingForPaint
(
mozilla
:
:
TimeStamp
aTime
)
{
if
(
mTestControllingRefreshes
)
{
return
false
;
}
if
(
mWaitingForTransaction
)
{
if
(
mSkippedPaints
&
&
aTime
>
(
mMostRecentTick
+
TimeDuration
:
:
FromMilliseconds
(
mWarningThreshold
*
1000
)
)
)
{
mWarningThreshold
*
=
2
;
}
mSkippedPaints
=
true
;
return
true
;
}
nsPresContext
*
pc
=
GetPresContext
(
)
;
nsPresContext
*
rootContext
=
pc
?
pc
-
>
GetRootPresContext
(
)
:
nullptr
;
if
(
rootContext
)
{
nsRefreshDriver
*
rootRefresh
=
rootContext
-
>
RefreshDriver
(
)
;
if
(
rootRefresh
&
&
rootRefresh
!
=
this
)
{
if
(
rootRefresh
-
>
IsWaitingForPaint
(
aTime
)
)
{
if
(
mRootRefresh
!
=
rootRefresh
)
{
if
(
mRootRefresh
)
{
mRootRefresh
-
>
RemoveRefreshObserver
(
this
FlushType
:
:
Style
)
;
}
rootRefresh
-
>
AddRefreshObserver
(
this
FlushType
:
:
Style
)
;
mRootRefresh
=
rootRefresh
;
}
mSkippedPaints
=
true
;
return
true
;
}
}
}
return
false
;
}
void
nsRefreshDriver
:
:
SetThrottled
(
bool
aThrottled
)
{
if
(
aThrottled
!
=
mThrottled
)
{
mThrottled
=
aThrottled
;
if
(
mActiveTimer
)
{
EnsureTimerStarted
(
eForceAdjustTimer
)
;
}
}
}
void
nsRefreshDriver
:
:
PVsyncActorCreated
(
VsyncChild
*
aVsyncChild
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
XRE_IsParentProcess
(
)
)
;
auto
*
vsyncRefreshDriverTimer
=
new
VsyncRefreshDriverTimer
(
aVsyncChild
)
;
if
(
sRegularRateTimer
)
{
sRegularRateTimer
-
>
SwapRefreshDrivers
(
vsyncRefreshDriverTimer
)
;
delete
sRegularRateTimer
;
}
sRegularRateTimer
=
vsyncRefreshDriverTimer
;
}
void
nsRefreshDriver
:
:
DoRefresh
(
)
{
if
(
!
IsFrozen
(
)
&
&
mPresContext
&
&
mActiveTimer
)
{
DoTick
(
)
;
}
}
#
ifdef
DEBUG
bool
nsRefreshDriver
:
:
IsRefreshObserver
(
nsARefreshObserver
*
aObserver
FlushType
aFlushType
)
{
ObserverArray
&
array
=
ArrayFor
(
aFlushType
)
;
return
array
.
Contains
(
aObserver
)
;
}
#
endif
void
nsRefreshDriver
:
:
ScheduleViewManagerFlush
(
)
{
NS_ASSERTION
(
mPresContext
-
>
IsRoot
(
)
"
Should
only
schedule
view
manager
flush
on
root
prescontexts
"
)
;
mViewManagerFlushIsPending
=
true
;
EnsureTimerStarted
(
eNeverAdjustTimer
)
;
}
void
nsRefreshDriver
:
:
ScheduleFrameRequestCallbacks
(
nsIDocument
*
aDocument
)
{
NS_ASSERTION
(
mFrameRequestCallbackDocs
.
IndexOf
(
aDocument
)
=
=
mFrameRequestCallbackDocs
.
NoIndex
&
&
mThrottledFrameRequestCallbackDocs
.
IndexOf
(
aDocument
)
=
=
mThrottledFrameRequestCallbackDocs
.
NoIndex
"
Don
'
t
schedule
the
same
document
multiple
times
"
)
;
if
(
aDocument
-
>
ShouldThrottleFrameRequests
(
)
)
{
mThrottledFrameRequestCallbackDocs
.
AppendElement
(
aDocument
)
;
}
else
{
mFrameRequestCallbackDocs
.
AppendElement
(
aDocument
)
;
}
EnsureTimerStarted
(
)
;
}
void
nsRefreshDriver
:
:
RevokeFrameRequestCallbacks
(
nsIDocument
*
aDocument
)
{
mFrameRequestCallbackDocs
.
RemoveElement
(
aDocument
)
;
mThrottledFrameRequestCallbackDocs
.
RemoveElement
(
aDocument
)
;
}
void
nsRefreshDriver
:
:
ScheduleEventDispatch
(
nsINode
*
aTarget
nsIDOMEvent
*
aEvent
)
{
mPendingEvents
.
AppendElement
(
PendingEvent
{
aTarget
aEvent
}
)
;
EnsureTimerStarted
(
)
;
}
void
nsRefreshDriver
:
:
CancelPendingEvents
(
nsIDocument
*
aDocument
)
{
for
(
auto
i
:
Reversed
(
IntegerRange
(
mPendingEvents
.
Length
(
)
)
)
)
{
if
(
mPendingEvents
[
i
]
.
mTarget
-
>
OwnerDoc
(
)
=
=
aDocument
)
{
mPendingEvents
.
RemoveElementAt
(
i
)
;
}
}
}
TimeStamp
nsRefreshDriver
:
:
GetIdleDeadlineHint
(
TimeStamp
aDefault
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
aDefault
.
IsNull
(
)
)
;
if
(
!
sRegularRateTimer
)
{
return
aDefault
;
}
return
sRegularRateTimer
-
>
GetIdleDeadlineHint
(
aDefault
)
;
}
void
nsRefreshDriver
:
:
Disconnect
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
StopTimer
(
)
;
if
(
mPresContext
)
{
mPresContext
=
nullptr
;
if
(
-
-
sRefreshDriverCount
=
=
0
)
{
Shutdown
(
)
;
}
}
}
bool
nsRefreshDriver
:
:
IsJankCritical
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
sActiveVsyncTimers
>
0
;
}
bool
nsRefreshDriver
:
:
GetJankLevels
(
Vector
<
uint64_t
>
&
aJank
)
{
aJank
.
clear
(
)
;
return
aJank
.
append
(
sJankLevels
ArrayLength
(
sJankLevels
)
)
;
}
#
undef
LOG
