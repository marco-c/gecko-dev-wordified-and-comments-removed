#
include
"
nsRefreshDriver
.
h
"
#
include
"
mozilla
/
DataMutex
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
ifdef
XP_WIN
#
include
<
windows
.
h
>
#
include
<
mmsystem
.
h
>
#
include
"
WinUtils
.
h
"
#
endif
#
include
"
mozilla
/
AnimationEventDispatcher
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
BasePrincipal
.
h
"
#
include
"
mozilla
/
CycleCollectedJSContext
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
DisplayPortUtils
.
h
"
#
include
"
mozilla
/
InputTaskManager
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
mozilla
/
PendingAnimationTracker
.
h
"
#
include
"
mozilla
/
PendingFullscreenEvent
.
h
"
#
include
"
mozilla
/
dom
/
PerformanceMainThread
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
StaticPrefs_apz
.
h
"
#
include
"
mozilla
/
StaticPrefs_gfx
.
h
"
#
include
"
mozilla
/
StaticPrefs_idle_period
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
mozilla
/
StaticPrefs_page_load
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
mozilla
/
dom
/
BrowserChild
.
h
"
#
include
"
mozilla
/
dom
/
CallbackDebuggerNotification
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
Performance
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
VsyncMainChild
.
h
"
#
include
"
mozilla
/
dom
/
WindowBinding
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderLayerManager
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
mozilla
/
TaskController
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsISimpleEnumerator
.
h
"
#
include
"
nsJSEnvironment
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
ipc
/
BackgroundChild
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundChild
.
h
"
#
include
"
VsyncSource
.
h
"
#
include
"
mozilla
/
VsyncDispatcher
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
TimelineConsumers
.
h
"
#
include
"
nsAnimationManager
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsDOMNavigationTiming
.
h
"
#
include
"
nsTransitionManager
.
h
"
#
if
defined
(
MOZ_WIDGET_ANDROID
)
#
include
"
VRManagerChild
.
h
"
#
endif
#
include
"
nsXULPopupManager
.
h
"
#
include
<
numeric
>
using
namespace
mozilla
;
using
namespace
mozilla
:
:
widget
;
using
namespace
mozilla
:
:
ipc
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
layout
;
static
mozilla
:
:
LazyLogModule
sRefreshDriverLog
(
"
nsRefreshDriver
"
)
;
#
define
LOG
(
.
.
.
)
\
MOZ_LOG
(
sRefreshDriverLog
mozilla
:
:
LogLevel
:
:
Debug
(
__VA_ARGS__
)
)
#
define
DEFAULT_INACTIVE_TIMER_DISABLE_SECONDS
600
#
if
defined
(
MOZ_ASAN
)
#
define
REFRESH_WAIT_WARNING
5
#
elif
defined
(
DEBUG
)
&
&
!
defined
(
MOZ_VALGRIND
)
#
define
REFRESH_WAIT_WARNING
5
#
elif
defined
(
DEBUG
)
&
&
defined
(
MOZ_VALGRIND
)
#
define
REFRESH_WAIT_WARNING
(
RUNNING_ON_VALGRIND
?
20
:
5
)
#
elif
defined
(
MOZ_VALGRIND
)
#
define
REFRESH_WAIT_WARNING
(
RUNNING_ON_VALGRIND
?
10
:
1
)
#
else
#
define
REFRESH_WAIT_WARNING
1
#
endif
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
nsRefreshDriver
:
:
TickReasons
)
;
namespace
{
static
uint32_t
sRefreshDriverCount
=
0
;
class
AutoRecordPhase
{
public
:
explicit
AutoRecordPhase
(
double
*
aResultMs
)
:
mTotalMs
(
aResultMs
)
mStartTime
(
TimeStamp
:
:
Now
(
)
)
{
MOZ_ASSERT
(
mTotalMs
)
;
}
~
AutoRecordPhase
(
)
{
*
mTotalMs
=
(
TimeStamp
:
:
Now
(
)
-
mStartTime
)
.
ToMilliseconds
(
)
;
}
private
:
double
*
mTotalMs
;
mozilla
:
:
TimeStamp
mStartTime
;
}
;
}
namespace
mozilla
{
static
TimeStamp
sMostRecentHighRateVsync
;
class
RefreshDriverTimer
{
public
:
RefreshDriverTimer
(
)
=
default
;
NS_INLINE_DECL_REFCOUNTING
(
RefreshDriverTimer
)
virtual
void
AddRefreshDriver
(
nsRefreshDriver
*
aDriver
)
{
LOG
(
"
[
%
p
]
AddRefreshDriver
%
p
"
this
aDriver
)
;
bool
startTimer
=
mContentRefreshDrivers
.
IsEmpty
(
)
&
&
mRootRefreshDrivers
.
IsEmpty
(
)
;
if
(
IsRootRefreshDriver
(
aDriver
)
)
{
NS_ASSERTION
(
!
mRootRefreshDrivers
.
Contains
(
aDriver
)
"
Adding
a
duplicate
root
refresh
driver
!
"
)
;
mRootRefreshDrivers
.
AppendElement
(
aDriver
)
;
}
else
{
NS_ASSERTION
(
!
mContentRefreshDrivers
.
Contains
(
aDriver
)
"
Adding
a
duplicate
content
refresh
driver
!
"
)
;
mContentRefreshDrivers
.
AppendElement
(
aDriver
)
;
}
if
(
startTimer
)
{
StartTimer
(
)
;
}
}
void
RemoveRefreshDriver
(
nsRefreshDriver
*
aDriver
)
{
LOG
(
"
[
%
p
]
RemoveRefreshDriver
%
p
"
this
aDriver
)
;
if
(
IsRootRefreshDriver
(
aDriver
)
)
{
NS_ASSERTION
(
mRootRefreshDrivers
.
Contains
(
aDriver
)
"
RemoveRefreshDriver
for
a
refresh
driver
that
'
s
not
in
the
"
"
root
refresh
list
!
"
)
;
mRootRefreshDrivers
.
RemoveElement
(
aDriver
)
;
}
else
{
nsPresContext
*
pc
=
aDriver
-
>
GetPresContext
(
)
;
nsPresContext
*
rootContext
=
pc
?
pc
-
>
GetRootPresContext
(
)
:
nullptr
;
if
(
!
rootContext
)
{
if
(
mRootRefreshDrivers
.
Contains
(
aDriver
)
)
{
mRootRefreshDrivers
.
RemoveElement
(
aDriver
)
;
}
else
{
NS_ASSERTION
(
mContentRefreshDrivers
.
Contains
(
aDriver
)
"
RemoveRefreshDriver
without
a
display
root
for
a
"
"
driver
that
is
not
in
the
content
refresh
list
"
)
;
mContentRefreshDrivers
.
RemoveElement
(
aDriver
)
;
}
}
else
{
NS_ASSERTION
(
mContentRefreshDrivers
.
Contains
(
aDriver
)
"
RemoveRefreshDriver
for
a
driver
that
is
not
in
the
"
"
content
refresh
list
"
)
;
mContentRefreshDrivers
.
RemoveElement
(
aDriver
)
;
}
}
bool
stopTimer
=
mContentRefreshDrivers
.
IsEmpty
(
)
&
&
mRootRefreshDrivers
.
IsEmpty
(
)
;
if
(
stopTimer
)
{
StopTimer
(
)
;
}
}
TimeStamp
MostRecentRefresh
(
)
const
{
return
mLastFireTime
;
}
VsyncId
MostRecentRefreshVsyncId
(
)
const
{
return
mLastFireId
;
}
virtual
TimeDuration
GetTimerRate
(
)
=
0
;
TimeStamp
GetIdleDeadlineHint
(
TimeStamp
aDefault
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
TimeStamp
mostRecentRefresh
=
MostRecentRefresh
(
)
;
TimeDuration
refreshPeriod
=
GetTimerRate
(
)
;
TimeStamp
idleEnd
=
mostRecentRefresh
+
refreshPeriod
;
bool
inHighRateMode
=
nsRefreshDriver
:
:
IsInHighRateMode
(
)
;
if
(
!
inHighRateMode
&
&
(
idleEnd
+
refreshPeriod
*
StaticPrefs
:
:
layout_idle_period_required_quiescent_frames
(
)
<
TimeStamp
:
:
Now
(
)
)
)
{
return
aDefault
;
}
idleEnd
=
idleEnd
-
TimeDuration
:
:
FromMilliseconds
(
inHighRateMode
?
0
:
StaticPrefs
:
:
layout_idle_period_time_limit
(
)
)
;
return
idleEnd
<
aDefault
?
idleEnd
:
aDefault
;
}
Maybe
<
TimeStamp
>
GetNextTickHint
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
TimeStamp
nextTick
=
MostRecentRefresh
(
)
+
GetTimerRate
(
)
;
return
nextTick
<
TimeStamp
:
:
Now
(
)
?
Nothing
(
)
:
Some
(
nextTick
)
;
}
nsPresContext
*
GetPresContextForOnlyRefreshDriver
(
)
{
if
(
mRootRefreshDrivers
.
Length
(
)
=
=
1
&
&
mContentRefreshDrivers
.
IsEmpty
(
)
)
{
return
mRootRefreshDrivers
[
0
]
-
>
GetPresContext
(
)
;
}
if
(
mContentRefreshDrivers
.
Length
(
)
=
=
1
&
&
mRootRefreshDrivers
.
IsEmpty
(
)
)
{
return
mContentRefreshDrivers
[
0
]
-
>
GetPresContext
(
)
;
}
return
nullptr
;
}
bool
IsAnyToplevelContentPageLoading
(
)
{
for
(
nsTArray
<
RefPtr
<
nsRefreshDriver
>
>
*
drivers
:
{
&
mRootRefreshDrivers
&
mContentRefreshDrivers
}
)
{
for
(
RefPtr
<
nsRefreshDriver
>
&
driver
:
*
drivers
)
{
if
(
nsPresContext
*
pc
=
driver
-
>
GetPresContext
(
)
)
{
if
(
pc
-
>
Document
(
)
-
>
IsTopLevelContentDocument
(
)
&
&
pc
-
>
Document
(
)
-
>
GetReadyStateEnum
(
)
<
Document
:
:
READYSTATE_COMPLETE
)
{
return
true
;
}
}
}
}
return
false
;
}
protected
:
virtual
~
RefreshDriverTimer
(
)
{
MOZ_ASSERT
(
mContentRefreshDrivers
.
Length
(
)
=
=
0
"
Should
have
removed
all
content
refresh
drivers
from
here
by
now
!
"
)
;
MOZ_ASSERT
(
mRootRefreshDrivers
.
Length
(
)
=
=
0
"
Should
have
removed
all
root
refresh
drivers
from
here
by
now
!
"
)
;
}
virtual
void
StartTimer
(
)
=
0
;
virtual
void
StopTimer
(
)
=
0
;
virtual
void
ScheduleNextTick
(
TimeStamp
aNowTime
)
=
0
;
public
:
virtual
bool
IsTicking
(
)
const
=
0
;
protected
:
bool
IsRootRefreshDriver
(
nsRefreshDriver
*
aDriver
)
{
nsPresContext
*
pc
=
aDriver
-
>
GetPresContext
(
)
;
nsPresContext
*
rootContext
=
pc
?
pc
-
>
GetRootPresContext
(
)
:
nullptr
;
if
(
!
rootContext
)
{
return
false
;
}
return
aDriver
=
=
rootContext
-
>
RefreshDriver
(
)
;
}
void
Tick
(
)
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
Tick
(
VsyncId
(
)
now
)
;
}
void
TickRefreshDrivers
(
VsyncId
aId
TimeStamp
aNow
nsTArray
<
RefPtr
<
nsRefreshDriver
>
>
&
aDrivers
)
{
if
(
aDrivers
.
IsEmpty
(
)
)
{
return
;
}
for
(
nsRefreshDriver
*
driver
:
aDrivers
.
Clone
(
)
)
{
if
(
driver
-
>
IsTestControllingRefreshesEnabled
(
)
)
{
continue
;
}
TickDriver
(
driver
aId
aNow
)
;
}
}
void
Tick
(
VsyncId
aId
TimeStamp
now
)
{
ScheduleNextTick
(
now
)
;
mLastFireTime
=
now
;
mLastFireId
=
aId
;
LOG
(
"
[
%
p
]
ticking
drivers
.
.
.
"
this
)
;
TickRefreshDrivers
(
aId
now
mContentRefreshDrivers
)
;
TickRefreshDrivers
(
aId
now
mRootRefreshDrivers
)
;
LOG
(
"
[
%
p
]
done
.
"
this
)
;
}
static
void
TickDriver
(
nsRefreshDriver
*
driver
VsyncId
aId
TimeStamp
now
)
{
driver
-
>
Tick
(
aId
now
)
;
}
TimeStamp
mLastFireTime
;
VsyncId
mLastFireId
;
TimeStamp
mTargetTime
;
nsTArray
<
RefPtr
<
nsRefreshDriver
>
>
mContentRefreshDrivers
;
nsTArray
<
RefPtr
<
nsRefreshDriver
>
>
mRootRefreshDrivers
;
static
void
TimerTick
(
nsITimer
*
aTimer
void
*
aClosure
)
{
RefPtr
<
RefreshDriverTimer
>
timer
=
static_cast
<
RefreshDriverTimer
*
>
(
aClosure
)
;
timer
-
>
Tick
(
)
;
}
}
;
class
SimpleTimerBasedRefreshDriverTimer
:
public
RefreshDriverTimer
{
public
:
explicit
SimpleTimerBasedRefreshDriverTimer
(
double
aRate
)
{
SetRate
(
aRate
)
;
mTimer
=
NS_NewTimer
(
)
;
}
virtual
~
SimpleTimerBasedRefreshDriverTimer
(
)
override
{
StopTimer
(
)
;
}
virtual
void
SetRate
(
double
aNewRate
)
{
mRateMilliseconds
=
aNewRate
;
mRateDuration
=
TimeDuration
:
:
FromMilliseconds
(
mRateMilliseconds
)
;
}
double
GetRate
(
)
const
{
return
mRateMilliseconds
;
}
TimeDuration
GetTimerRate
(
)
override
{
return
mRateDuration
;
}
protected
:
void
StartTimer
(
)
override
{
mLastFireTime
=
TimeStamp
:
:
Now
(
)
;
mLastFireId
=
VsyncId
(
)
;
mTargetTime
=
mLastFireTime
+
mRateDuration
;
uint32_t
delay
=
static_cast
<
uint32_t
>
(
mRateMilliseconds
)
;
mTimer
-
>
InitWithNamedFuncCallback
(
TimerTick
this
delay
nsITimer
:
:
TYPE_ONE_SHOT
"
SimpleTimerBasedRefreshDriverTimer
:
:
StartTimer
"
)
;
}
void
StopTimer
(
)
override
{
mTimer
-
>
Cancel
(
)
;
}
double
mRateMilliseconds
;
TimeDuration
mRateDuration
;
RefPtr
<
nsITimer
>
mTimer
;
}
;
class
VsyncRefreshDriverTimer
:
public
RefreshDriverTimer
{
public
:
static
RefPtr
<
VsyncRefreshDriverTimer
>
CreateForParentProcessWithGlobalVsync
(
)
{
MOZ_RELEASE_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
VsyncDispatcher
>
vsyncDispatcher
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetGlobalVsyncDispatcher
(
)
;
RefPtr
<
VsyncRefreshDriverTimer
>
timer
=
new
VsyncRefreshDriverTimer
(
std
:
:
move
(
vsyncDispatcher
)
nullptr
)
;
return
timer
.
forget
(
)
;
}
static
RefPtr
<
VsyncRefreshDriverTimer
>
CreateForParentProcessWithLocalVsyncDispatcher
(
RefPtr
<
VsyncDispatcher
>
&
&
aVsyncDispatcher
)
{
MOZ_RELEASE_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
VsyncRefreshDriverTimer
>
timer
=
new
VsyncRefreshDriverTimer
(
std
:
:
move
(
aVsyncDispatcher
)
nullptr
)
;
return
timer
.
forget
(
)
;
}
static
RefPtr
<
VsyncRefreshDriverTimer
>
CreateForContentProcess
(
RefPtr
<
VsyncMainChild
>
&
&
aVsyncChild
)
{
MOZ_RELEASE_ASSERT
(
XRE_IsContentProcess
(
)
)
;
MOZ_RELEASE_ASSERT
(
NS_IsMainThread
(
)
)
;
RefPtr
<
VsyncRefreshDriverTimer
>
timer
=
new
VsyncRefreshDriverTimer
(
nullptr
std
:
:
move
(
aVsyncChild
)
)
;
return
timer
.
forget
(
)
;
}
TimeDuration
GetTimerRate
(
)
override
{
if
(
mVsyncDispatcher
)
{
mVsyncRate
=
mVsyncDispatcher
-
>
GetVsyncRate
(
)
;
}
else
if
(
mVsyncChild
)
{
mVsyncRate
=
mVsyncChild
-
>
GetVsyncRate
(
)
;
}
return
mVsyncRate
!
=
TimeDuration
:
:
Forever
(
)
?
mVsyncRate
:
TimeDuration
:
:
FromMilliseconds
(
1000
.
0
/
60
.
0
)
;
}
private
:
class
RefreshDriverVsyncObserver
final
:
public
VsyncObserver
{
NS_INLINE_DECL_THREADSAFE_REFCOUNTING
(
VsyncRefreshDriverTimer
:
:
RefreshDriverVsyncObserver
override
)
public
:
explicit
RefreshDriverVsyncObserver
(
VsyncRefreshDriverTimer
*
aVsyncRefreshDriverTimer
)
:
mVsyncRefreshDriverTimer
(
aVsyncRefreshDriverTimer
)
mLastPendingVsyncNotification
(
"
RefreshDriverVsyncObserver
:
:
mLastPendingVsyncNotification
"
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
void
NotifyVsync
(
const
VsyncEvent
&
aVsync
)
override
{
{
auto
pendingVsync
=
mLastPendingVsyncNotification
.
Lock
(
)
;
bool
hadPendingVsync
=
pendingVsync
-
>
isSome
(
)
;
*
pendingVsync
=
Some
(
aVsync
)
;
if
(
hadPendingVsync
)
{
return
;
}
}
if
(
XRE_IsContentProcess
(
)
)
{
NotifyVsyncTimerOnMainThread
(
)
;
return
;
}
bool
useVsyncPriority
=
mozilla
:
:
BrowserTabsRemoteAutostart
(
)
;
nsCOMPtr
<
nsIRunnable
>
vsyncEvent
=
new
PrioritizableRunnable
(
NS_NewRunnableFunction
(
"
RefreshDriverVsyncObserver
:
:
NotifyVsyncTimerOnMainThread
"
[
self
=
RefPtr
{
this
}
]
(
)
{
self
-
>
NotifyVsyncTimerOnMainThread
(
)
;
}
)
useVsyncPriority
?
nsIRunnablePriority
:
:
PRIORITY_VSYNC
:
nsIRunnablePriority
:
:
PRIORITY_NORMAL
)
;
NS_DispatchToMainThread
(
vsyncEvent
)
;
}
void
NotifyVsyncTimerOnMainThread
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
mVsyncRefreshDriverTimer
)
{
return
;
}
VsyncEvent
vsyncEvent
;
{
auto
pendingVsync
=
mLastPendingVsyncNotification
.
Lock
(
)
;
MOZ_RELEASE_ASSERT
(
pendingVsync
-
>
isSome
(
)
"
We
should
always
have
a
pending
vsync
notification
here
.
"
)
;
vsyncEvent
=
pendingVsync
-
>
extract
(
)
;
}
RefPtr
<
VsyncRefreshDriverTimer
>
timer
=
mVsyncRefreshDriverTimer
;
timer
-
>
NotifyVsyncOnMainThread
(
vsyncEvent
)
;
}
void
Shutdown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mVsyncRefreshDriverTimer
=
nullptr
;
}
private
:
~
RefreshDriverVsyncObserver
(
)
=
default
;
VsyncRefreshDriverTimer
*
mVsyncRefreshDriverTimer
;
DataMutex
<
Maybe
<
VsyncEvent
>
>
mLastPendingVsyncNotification
;
}
;
VsyncRefreshDriverTimer
(
RefPtr
<
VsyncDispatcher
>
&
&
aVsyncDispatcher
RefPtr
<
VsyncMainChild
>
&
&
aVsyncChild
)
:
mVsyncDispatcher
(
aVsyncDispatcher
)
mVsyncChild
(
aVsyncChild
)
mVsyncRate
(
TimeDuration
:
:
Forever
(
)
)
mRecentVsync
(
TimeStamp
:
:
Now
(
)
)
mLastTickStart
(
TimeStamp
:
:
Now
(
)
)
mLastIdleTaskCount
(
0
)
mLastRunOutOfMTTasksCount
(
0
)
mProcessedVsync
(
true
)
{
mVsyncObserver
=
new
RefreshDriverVsyncObserver
(
this
)
;
}
~
VsyncRefreshDriverTimer
(
)
override
{
if
(
mVsyncDispatcher
)
{
mVsyncDispatcher
-
>
RemoveVsyncObserver
(
mVsyncObserver
)
;
mVsyncDispatcher
=
nullptr
;
}
else
if
(
mVsyncChild
)
{
mVsyncChild
-
>
RemoveChildRefreshTimer
(
mVsyncObserver
)
;
mVsyncChild
=
nullptr
;
}
mVsyncObserver
-
>
Shutdown
(
)
;
mVsyncObserver
=
nullptr
;
}
bool
ShouldGiveNonVsyncTasksMoreTime
(
)
{
TaskController
*
taskController
=
TaskController
:
:
Get
(
)
;
IdleTaskManager
*
idleTaskManager
=
taskController
-
>
GetIdleTaskManager
(
)
;
uint64_t
pendingTaskCount
=
taskController
-
>
PendingMainthreadTaskCountIncludingSuspended
(
)
;
uint64_t
pendingIdleTaskCount
=
idleTaskManager
-
>
PendingTaskCount
(
)
;
MOZ_ASSERT
(
pendingTaskCount
>
=
pendingIdleTaskCount
)
;
uint64_t
idleTaskCount
=
idleTaskManager
-
>
ProcessedTaskCount
(
)
;
return
mLastIdleTaskCount
=
=
idleTaskCount
&
&
pendingTaskCount
>
pendingIdleTaskCount
&
&
(
taskController
-
>
RunOutOfMTTasksCount
(
)
=
=
mLastRunOutOfMTTasksCount
|
|
XRE_IsParentProcess
(
)
)
;
}
void
NotifyVsyncOnMainThread
(
const
VsyncEvent
&
aVsyncEvent
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mRecentVsync
=
aVsyncEvent
.
mTime
;
mRecentVsyncId
=
aVsyncEvent
.
mId
;
if
(
!
mSuspendVsyncPriorityTicksUntil
.
IsNull
(
)
&
&
mSuspendVsyncPriorityTicksUntil
>
aVsyncEvent
.
mTime
)
{
if
(
ShouldGiveNonVsyncTasksMoreTime
(
)
)
{
if
(
!
IsAnyToplevelContentPageLoading
(
)
)
{
static
bool
sHasPendingLowPrioTask
=
false
;
if
(
!
sHasPendingLowPrioTask
)
{
sHasPendingLowPrioTask
=
true
;
NS_DispatchToMainThreadQueue
(
NS_NewRunnableFunction
(
"
NotifyVsyncOnMainThread
[
low
priority
]
"
[
self
=
RefPtr
{
this
}
event
=
aVsyncEvent
]
(
)
{
sHasPendingLowPrioTask
=
false
;
if
(
self
-
>
mRecentVsync
=
=
event
.
mTime
&
&
self
-
>
mRecentVsyncId
=
=
event
.
mId
&
&
!
self
-
>
ShouldGiveNonVsyncTasksMoreTime
(
)
)
{
self
-
>
mSuspendVsyncPriorityTicksUntil
=
TimeStamp
(
)
;
self
-
>
NotifyVsyncOnMainThread
(
event
)
;
}
}
)
EventQueuePriority
:
:
Low
)
;
}
}
return
;
}
mSuspendVsyncPriorityTicksUntil
=
TimeStamp
(
)
;
}
if
(
StaticPrefs
:
:
layout_lower_priority_refresh_driver_during_load
(
)
&
&
ShouldGiveNonVsyncTasksMoreTime
(
)
)
{
nsPresContext
*
pctx
=
GetPresContextForOnlyRefreshDriver
(
)
;
if
(
pctx
&
&
pctx
-
>
HadContentfulPaint
(
)
&
&
pctx
-
>
Document
(
)
&
&
pctx
-
>
Document
(
)
-
>
GetReadyStateEnum
(
)
<
Document
:
:
READYSTATE_COMPLETE
)
{
nsPIDOMWindowInner
*
win
=
pctx
-
>
Document
(
)
-
>
GetInnerWindow
(
)
;
uint32_t
frameRateMultiplier
=
pctx
-
>
GetNextFrameRateMultiplier
(
)
;
if
(
!
frameRateMultiplier
)
{
pctx
-
>
DidUseFrameRateMultiplier
(
)
;
}
if
(
win
&
&
frameRateMultiplier
)
{
dom
:
:
Performance
*
perf
=
win
-
>
GetPerformance
(
)
;
if
(
perf
&
&
perf
-
>
Now
(
)
<
StaticPrefs
:
:
page_load_deprioritization_period
(
)
)
{
if
(
mProcessedVsync
)
{
mProcessedVsync
=
false
;
TimeDuration
rate
=
GetTimerRate
(
)
;
uint32_t
slowRate
=
static_cast
<
uint32_t
>
(
rate
.
ToMilliseconds
(
)
*
frameRateMultiplier
)
;
pctx
-
>
DidUseFrameRateMultiplier
(
)
;
nsCOMPtr
<
nsIRunnable
>
vsyncEvent
=
NewRunnableMethod
<
>
(
"
VsyncRefreshDriverTimer
:
:
IdlePriorityNotify
"
this
&
VsyncRefreshDriverTimer
:
:
IdlePriorityNotify
)
;
NS_DispatchToCurrentThreadQueue
(
vsyncEvent
.
forget
(
)
slowRate
EventQueuePriority
:
:
Idle
)
;
}
return
;
}
}
}
}
TickRefreshDriver
(
aVsyncEvent
.
mId
aVsyncEvent
.
mTime
)
;
}
void
RecordTelemetryProbes
(
TimeStamp
aVsyncTimestamp
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
#
ifndef
ANDROID
if
(
XRE_IsParentProcess
(
)
)
{
TimeDuration
vsyncLatency
=
TimeStamp
:
:
Now
(
)
-
aVsyncTimestamp
;
uint32_t
sample
=
(
uint32_t
)
vsyncLatency
.
ToMilliseconds
(
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
FX_REFRESH_DRIVER_CHROME_FRAME_DELAY_MS
sample
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
FX_REFRESH_DRIVER_SYNC_SCROLL_FRAME_DELAY_MS
sample
)
;
}
else
if
(
mVsyncRate
!
=
TimeDuration
:
:
Forever
(
)
)
{
TimeDuration
contentDelay
=
(
TimeStamp
:
:
Now
(
)
-
mLastTickStart
)
-
mVsyncRate
;
if
(
contentDelay
.
ToMilliseconds
(
)
<
0
)
{
contentDelay
=
TimeDuration
:
:
FromMilliseconds
(
0
)
;
}
uint32_t
sample
=
(
uint32_t
)
contentDelay
.
ToMilliseconds
(
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
FX_REFRESH_DRIVER_CONTENT_FRAME_DELAY_MS
sample
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
FX_REFRESH_DRIVER_SYNC_SCROLL_FRAME_DELAY_MS
sample
)
;
}
else
{
mVsyncRate
=
mVsyncChild
-
>
GetVsyncRate
(
)
;
}
#
endif
}
void
OnTimerStart
(
)
{
mLastTickStart
=
TimeStamp
:
:
Now
(
)
;
mLastTickEnd
=
TimeStamp
(
)
;
mLastIdleTaskCount
=
0
;
}
void
IdlePriorityNotify
(
)
{
if
(
mLastProcessedTick
.
IsNull
(
)
|
|
mRecentVsync
>
mLastProcessedTick
)
{
mSuspendVsyncPriorityTicksUntil
=
TimeStamp
(
)
;
TickRefreshDriver
(
mRecentVsyncId
mRecentVsync
)
;
}
mProcessedVsync
=
true
;
}
void
TickRefreshDriver
(
VsyncId
aId
TimeStamp
aVsyncTimestamp
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RecordTelemetryProbes
(
aVsyncTimestamp
)
;
TimeStamp
tickStart
=
TimeStamp
:
:
Now
(
)
;
TimeDuration
rate
=
GetTimerRate
(
)
;
if
(
TimeDuration
:
:
FromMilliseconds
(
nsRefreshDriver
:
:
DefaultInterval
(
)
/
2
)
>
rate
)
{
sMostRecentHighRateVsync
=
tickStart
;
}
#
if
!
defined
(
_WIN32
)
MOZ_ASSERT
(
aVsyncTimestamp
<
=
tickStart
)
;
#
endif
bool
shouldGiveNonVSyncTasksMoreTime
=
ShouldGiveNonVsyncTasksMoreTime
(
)
;
mLastTickStart
=
tickStart
;
mLastProcessedTick
=
aVsyncTimestamp
;
RunRefreshDrivers
(
aId
aVsyncTimestamp
)
;
TimeStamp
tickEnd
=
TimeStamp
:
:
Now
(
)
;
TimeStamp
mostRecentTickStart
=
mLastTickStart
;
TimeDuration
gracePeriod
=
rate
/
int64_t
(
100
)
;
if
(
shouldGiveNonVSyncTasksMoreTime
)
{
if
(
!
mLastTickEnd
.
IsNull
(
)
&
&
XRE_IsContentProcess
(
)
&
&
!
IsAnyToplevelContentPageLoading
(
)
)
{
TimeDuration
timeForOutsideTick
=
clamped
(
tickStart
-
mLastTickEnd
-
gracePeriod
TimeDuration
(
)
rate
*
4
)
;
mSuspendVsyncPriorityTicksUntil
=
aVsyncTimestamp
+
timeForOutsideTick
+
(
tickEnd
-
mostRecentTickStart
)
;
}
else
{
mSuspendVsyncPriorityTicksUntil
=
aVsyncTimestamp
+
gracePeriod
+
(
tickEnd
-
mostRecentTickStart
)
;
}
}
else
{
mSuspendVsyncPriorityTicksUntil
=
aVsyncTimestamp
+
gracePeriod
;
}
mLastIdleTaskCount
=
TaskController
:
:
Get
(
)
-
>
GetIdleTaskManager
(
)
-
>
ProcessedTaskCount
(
)
;
mLastRunOutOfMTTasksCount
=
TaskController
:
:
Get
(
)
-
>
RunOutOfMTTasksCount
(
)
;
mLastTickEnd
=
tickEnd
;
}
void
StartTimer
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mLastFireTime
=
TimeStamp
:
:
Now
(
)
;
mLastFireId
=
VsyncId
(
)
;
if
(
mVsyncDispatcher
)
{
mVsyncDispatcher
-
>
AddVsyncObserver
(
mVsyncObserver
)
;
}
else
if
(
mVsyncChild
)
{
mVsyncChild
-
>
AddChildRefreshTimer
(
mVsyncObserver
)
;
OnTimerStart
(
)
;
}
mIsTicking
=
true
;
}
void
StopTimer
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
mVsyncDispatcher
)
{
mVsyncDispatcher
-
>
RemoveVsyncObserver
(
mVsyncObserver
)
;
}
else
if
(
mVsyncChild
)
{
mVsyncChild
-
>
RemoveChildRefreshTimer
(
mVsyncObserver
)
;
}
mIsTicking
=
false
;
}
public
:
bool
IsTicking
(
)
const
override
{
return
mIsTicking
;
}
protected
:
void
ScheduleNextTick
(
TimeStamp
aNowTime
)
override
{
}
void
RunRefreshDrivers
(
VsyncId
aId
TimeStamp
aTimeStamp
)
{
Tick
(
aId
aTimeStamp
)
;
for
(
auto
&
driver
:
mContentRefreshDrivers
)
{
driver
-
>
FinishedVsyncTick
(
)
;
}
for
(
auto
&
driver
:
mRootRefreshDrivers
)
{
driver
-
>
FinishedVsyncTick
(
)
;
}
}
RefPtr
<
RefreshDriverVsyncObserver
>
mVsyncObserver
;
RefPtr
<
VsyncDispatcher
>
mVsyncDispatcher
;
RefPtr
<
VsyncMainChild
>
mVsyncChild
;
TimeDuration
mVsyncRate
;
bool
mIsTicking
=
false
;
TimeStamp
mRecentVsync
;
VsyncId
mRecentVsyncId
;
TimeStamp
mLastTickStart
;
TimeStamp
mLastTickEnd
;
uint64_t
mLastIdleTaskCount
;
uint64_t
mLastRunOutOfMTTasksCount
;
TimeStamp
mLastProcessedTick
;
TimeStamp
mSuspendVsyncPriorityTicksUntil
;
bool
mProcessedVsync
;
}
;
class
StartupRefreshDriverTimer
:
public
SimpleTimerBasedRefreshDriverTimer
{
public
:
explicit
StartupRefreshDriverTimer
(
double
aRate
)
:
SimpleTimerBasedRefreshDriverTimer
(
aRate
)
{
}
protected
:
void
ScheduleNextTick
(
TimeStamp
aNowTime
)
override
{
TimeStamp
newTarget
=
aNowTime
+
mRateDuration
;
uint32_t
delay
=
static_cast
<
uint32_t
>
(
(
newTarget
-
aNowTime
)
.
ToMilliseconds
(
)
)
;
mTimer
-
>
InitWithNamedFuncCallback
(
TimerTick
this
delay
nsITimer
:
:
TYPE_ONE_SHOT
"
StartupRefreshDriverTimer
:
:
ScheduleNextTick
"
)
;
mTargetTime
=
newTarget
;
}
public
:
bool
IsTicking
(
)
const
override
{
return
true
;
}
}
;
class
InactiveRefreshDriverTimer
final
:
public
SimpleTimerBasedRefreshDriverTimer
{
public
:
explicit
InactiveRefreshDriverTimer
(
double
aRate
)
:
SimpleTimerBasedRefreshDriverTimer
(
aRate
)
mNextTickDuration
(
aRate
)
mDisableAfterMilliseconds
(
-
1
.
0
)
mNextDriverIndex
(
0
)
{
}
InactiveRefreshDriverTimer
(
double
aRate
double
aDisableAfterMilliseconds
)
:
SimpleTimerBasedRefreshDriverTimer
(
aRate
)
mNextTickDuration
(
aRate
)
mDisableAfterMilliseconds
(
aDisableAfterMilliseconds
)
mNextDriverIndex
(
0
)
{
}
void
AddRefreshDriver
(
nsRefreshDriver
*
aDriver
)
override
{
RefreshDriverTimer
:
:
AddRefreshDriver
(
aDriver
)
;
LOG
(
"
[
%
p
]
inactive
timer
got
new
refresh
driver
%
p
resetting
rate
"
this
aDriver
)
;
mNextTickDuration
=
mRateMilliseconds
;
mNextDriverIndex
=
GetRefreshDriverCount
(
)
-
1
;
StopTimer
(
)
;
StartTimer
(
)
;
}
TimeDuration
GetTimerRate
(
)
override
{
return
TimeDuration
:
:
FromMilliseconds
(
mNextTickDuration
)
;
}
protected
:
uint32_t
GetRefreshDriverCount
(
)
{
return
mContentRefreshDrivers
.
Length
(
)
+
mRootRefreshDrivers
.
Length
(
)
;
}
void
StartTimer
(
)
override
{
mLastFireTime
=
TimeStamp
:
:
Now
(
)
;
mLastFireId
=
VsyncId
(
)
;
mTargetTime
=
mLastFireTime
+
mRateDuration
;
uint32_t
delay
=
static_cast
<
uint32_t
>
(
mRateMilliseconds
)
;
mTimer
-
>
InitWithNamedFuncCallback
(
TimerTickOne
this
delay
nsITimer
:
:
TYPE_ONE_SHOT
"
InactiveRefreshDriverTimer
:
:
StartTimer
"
)
;
mIsTicking
=
true
;
}
void
StopTimer
(
)
override
{
mTimer
-
>
Cancel
(
)
;
mIsTicking
=
false
;
}
void
ScheduleNextTick
(
TimeStamp
aNowTime
)
override
{
if
(
mDisableAfterMilliseconds
>
0
.
0
&
&
mNextTickDuration
>
mDisableAfterMilliseconds
)
{
return
;
}
if
(
mNextDriverIndex
>
=
GetRefreshDriverCount
(
)
)
{
mNextTickDuration
*
=
2
.
0
;
mNextDriverIndex
=
0
;
}
uint32_t
delay
=
static_cast
<
uint32_t
>
(
mNextTickDuration
)
;
mTimer
-
>
InitWithNamedFuncCallback
(
TimerTickOne
this
delay
nsITimer
:
:
TYPE_ONE_SHOT
"
InactiveRefreshDriverTimer
:
:
ScheduleNextTick
"
)
;
LOG
(
"
[
%
p
]
inactive
timer
next
tick
in
%
f
ms
[
index
%
d
/
%
d
]
"
this
mNextTickDuration
mNextDriverIndex
GetRefreshDriverCount
(
)
)
;
}
public
:
bool
IsTicking
(
)
const
override
{
return
mIsTicking
;
}
protected
:
void
TickOne
(
)
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
ScheduleNextTick
(
now
)
;
mLastFireTime
=
now
;
mLastFireId
=
VsyncId
(
)
;
nsTArray
<
RefPtr
<
nsRefreshDriver
>
>
drivers
(
mContentRefreshDrivers
.
Clone
(
)
)
;
drivers
.
AppendElements
(
mRootRefreshDrivers
)
;
size_t
index
=
mNextDriverIndex
;
if
(
index
<
drivers
.
Length
(
)
&
&
!
drivers
[
index
]
-
>
IsTestControllingRefreshesEnabled
(
)
)
{
TickDriver
(
drivers
[
index
]
VsyncId
(
)
now
)
;
}
mNextDriverIndex
+
+
;
}
static
void
TimerTickOne
(
nsITimer
*
aTimer
void
*
aClosure
)
{
RefPtr
<
InactiveRefreshDriverTimer
>
timer
=
static_cast
<
InactiveRefreshDriverTimer
*
>
(
aClosure
)
;
timer
-
>
TickOne
(
)
;
}
double
mNextTickDuration
;
double
mDisableAfterMilliseconds
;
uint32_t
mNextDriverIndex
;
bool
mIsTicking
=
false
;
}
;
}
static
StaticRefPtr
<
RefreshDriverTimer
>
sRegularRateTimer
;
static
StaticAutoPtr
<
nsTArray
<
RefreshDriverTimer
*
>
>
sRegularRateTimerList
;
static
StaticRefPtr
<
InactiveRefreshDriverTimer
>
sThrottledRateTimer
;
void
nsRefreshDriver
:
:
CreateVsyncRefreshTimer
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
gfxPlatform
:
:
IsInLayoutAsapMode
(
)
)
{
return
;
}
if
(
!
mOwnTimer
)
{
nsPresContext
*
pc
=
GetPresContext
(
)
;
nsCOMPtr
<
nsIWidget
>
widget
=
pc
-
>
GetRootWidget
(
)
;
if
(
widget
)
{
if
(
RefPtr
<
VsyncDispatcher
>
vsyncDispatcher
=
widget
-
>
GetVsyncDispatcher
(
)
)
{
mOwnTimer
=
VsyncRefreshDriverTimer
:
:
CreateForParentProcessWithLocalVsyncDispatcher
(
std
:
:
move
(
vsyncDispatcher
)
)
;
sRegularRateTimerList
-
>
AppendElement
(
mOwnTimer
.
get
(
)
)
;
return
;
}
if
(
BrowserChild
*
browserChild
=
widget
-
>
GetOwningBrowserChild
(
)
)
{
if
(
RefPtr
<
VsyncMainChild
>
vsyncChildViaPBrowser
=
browserChild
-
>
GetVsyncChild
(
)
)
{
mOwnTimer
=
VsyncRefreshDriverTimer
:
:
CreateForContentProcess
(
std
:
:
move
(
vsyncChildViaPBrowser
)
)
;
sRegularRateTimerList
-
>
AppendElement
(
mOwnTimer
.
get
(
)
)
;
return
;
}
}
}
}
if
(
!
sRegularRateTimer
)
{
if
(
XRE_IsParentProcess
(
)
)
{
gfxPlatform
:
:
GetPlatform
(
)
;
sRegularRateTimer
=
VsyncRefreshDriverTimer
:
:
CreateForParentProcessWithGlobalVsync
(
)
;
}
else
{
PBackgroundChild
*
actorChild
=
BackgroundChild
:
:
GetOrCreateForCurrentThread
(
)
;
if
(
NS_WARN_IF
(
!
actorChild
)
)
{
return
;
}
auto
vsyncChildViaPBackground
=
MakeRefPtr
<
dom
:
:
VsyncMainChild
>
(
)
;
dom
:
:
PVsyncChild
*
actor
=
actorChild
-
>
SendPVsyncConstructor
(
vsyncChildViaPBackground
)
;
if
(
NS_WARN_IF
(
!
actor
)
)
{
return
;
}
RefPtr
<
RefreshDriverTimer
>
vsyncRefreshDriverTimer
=
VsyncRefreshDriverTimer
:
:
CreateForContentProcess
(
std
:
:
move
(
vsyncChildViaPBackground
)
)
;
sRegularRateTimer
=
std
:
:
move
(
vsyncRefreshDriverTimer
)
;
}
}
}
static
uint32_t
GetFirstFrameDelay
(
imgIRequest
*
req
)
{
nsCOMPtr
<
imgIContainer
>
container
;
if
(
NS_FAILED
(
req
-
>
GetImage
(
getter_AddRefs
(
container
)
)
)
|
|
!
container
)
{
return
0
;
}
int32_t
delay
=
container
-
>
GetFirstFrameDelay
(
)
;
if
(
delay
<
0
)
return
0
;
return
static_cast
<
uint32_t
>
(
delay
)
;
}
void
nsRefreshDriver
:
:
Shutdown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
sRegularRateTimer
=
nullptr
;
sRegularRateTimerList
=
nullptr
;
sThrottledRateTimer
=
nullptr
;
}
int32_t
nsRefreshDriver
:
:
DefaultInterval
(
)
{
return
NSToIntRound
(
1000
.
0
/
gfxPlatform
:
:
GetDefaultFrameRate
(
)
)
;
}
bool
nsRefreshDriver
:
:
IsInHighRateMode
(
)
{
bool
inHighRateMode
=
!
gfxPlatform
:
:
IsInLayoutAsapMode
(
)
&
&
StaticPrefs
:
:
layout_expose_high_rate_mode_from_refreshdriver
(
)
&
&
!
sMostRecentHighRateVsync
.
IsNull
(
)
&
&
(
sMostRecentHighRateVsync
+
TimeDuration
:
:
FromMilliseconds
(
DefaultInterval
(
)
)
)
>
TimeStamp
:
:
Now
(
)
;
if
(
!
inHighRateMode
)
{
sMostRecentHighRateVsync
=
TimeStamp
(
)
;
}
return
inHighRateMode
;
}
double
nsRefreshDriver
:
:
GetRegularTimerInterval
(
)
const
{
int32_t
rate
=
Preferences
:
:
GetInt
(
"
layout
.
frame_rate
"
-
1
)
;
if
(
rate
<
0
)
{
rate
=
gfxPlatform
:
:
GetDefaultFrameRate
(
)
;
}
else
if
(
rate
=
=
0
)
{
rate
=
10000
;
}
return
1000
.
0
/
rate
;
}
double
nsRefreshDriver
:
:
GetThrottledTimerInterval
(
)
{
uint32_t
rate
=
StaticPrefs
:
:
layout_throttled_frame_rate
(
)
;
return
1000
.
0
/
rate
;
}
TimeDuration
nsRefreshDriver
:
:
GetMinRecomputeVisibilityInterval
(
)
{
return
TimeDuration
:
:
FromMilliseconds
(
StaticPrefs
:
:
layout_visibility_min_recompute_interval_ms
(
)
)
;
}
bool
nsRefreshDriver
:
:
ComputeShouldBeThrottled
(
)
const
{
if
(
mIsActive
)
{
return
false
;
}
if
(
!
mIsInActiveTab
)
{
return
true
;
}
if
(
mIsGrantingActivityGracePeriod
)
{
return
false
;
}
return
true
;
}
RefreshDriverTimer
*
nsRefreshDriver
:
:
ChooseTimer
(
)
{
if
(
mThrottled
)
{
if
(
!
sThrottledRateTimer
)
{
sThrottledRateTimer
=
new
InactiveRefreshDriverTimer
(
GetThrottledTimerInterval
(
)
DEFAULT_INACTIVE_TIMER_DISABLE_SECONDS
*
1000
.
0
)
;
}
return
sThrottledRateTimer
;
}
if
(
!
mOwnTimer
)
{
CreateVsyncRefreshTimer
(
)
;
}
if
(
mOwnTimer
)
{
return
mOwnTimer
.
get
(
)
;
}
if
(
!
sRegularRateTimer
)
{
double
rate
=
GetRegularTimerInterval
(
)
;
sRegularRateTimer
=
new
StartupRefreshDriverTimer
(
rate
)
;
}
return
sRegularRateTimer
;
}
static
nsDocShell
*
GetDocShell
(
nsPresContext
*
aPresContext
)
{
if
(
!
aPresContext
)
{
return
nullptr
;
}
return
static_cast
<
nsDocShell
*
>
(
aPresContext
-
>
GetDocShell
(
)
)
;
}
nsRefreshDriver
:
:
nsRefreshDriver
(
nsPresContext
*
aPresContext
)
:
mActiveTimer
(
nullptr
)
mOwnTimer
(
nullptr
)
mPresContext
(
aPresContext
)
mRootRefresh
(
nullptr
)
mNextTransactionId
{
0
}
mFreezeCount
(
0
)
mThrottledFrameRequestInterval
(
TimeDuration
:
:
FromMilliseconds
(
GetThrottledTimerInterval
(
)
)
)
mMinRecomputeVisibilityInterval
(
GetMinRecomputeVisibilityInterval
(
)
)
mThrottled
(
false
)
mIsActive
(
true
)
mIsInActiveTab
(
true
)
mIsGrantingActivityGracePeriod
(
false
)
mHasGrantedActivityGracePeriod
(
false
)
mNeedToRecomputeVisibility
(
false
)
mTestControllingRefreshes
(
false
)
mViewManagerFlushIsPending
(
false
)
mHasScheduleFlush
(
false
)
mInRefresh
(
false
)
mWaitingForTransaction
(
false
)
mSkippedPaints
(
false
)
mResizeSuppressed
(
false
)
mNotifyDOMContentFlushed
(
false
)
mNeedToUpdateIntersectionObservations
(
false
)
mNeedToUpdateContentRelevancy
(
false
)
mInNormalTick
(
false
)
mAttemptedExtraTickSinceLastVsync
(
false
)
mHasExceededAfterLoadTickPeriod
(
false
)
mHasStartedTimerAtLeastOnce
(
false
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mPresContext
"
Need
a
pres
context
to
tell
us
to
call
Disconnect
(
)
later
"
"
and
decrement
sRefreshDriverCount
.
"
)
;
mMostRecentRefresh
=
TimeStamp
:
:
Now
(
)
;
mNextThrottledFrameRequestTick
=
mMostRecentRefresh
;
mNextRecomputeVisibilityTick
=
mMostRecentRefresh
;
if
(
!
sRegularRateTimerList
)
{
sRegularRateTimerList
=
new
nsTArray
<
RefreshDriverTimer
*
>
(
)
;
}
+
+
sRefreshDriverCount
;
}
nsRefreshDriver
:
:
~
nsRefreshDriver
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
ObserverCount
(
)
=
=
mEarlyRunners
.
Length
(
)
"
observers
except
pending
selection
scrolls
"
"
should
have
been
unregistered
"
)
;
MOZ_ASSERT
(
!
mActiveTimer
"
timer
should
be
gone
"
)
;
MOZ_ASSERT
(
!
mPresContext
"
Should
have
called
Disconnect
(
)
and
decremented
"
"
sRefreshDriverCount
!
"
)
;
if
(
mRootRefresh
)
{
mRootRefresh
-
>
RemoveRefreshObserver
(
this
FlushType
:
:
Style
)
;
mRootRefresh
=
nullptr
;
}
if
(
mOwnTimer
&
&
sRegularRateTimerList
)
{
sRegularRateTimerList
-
>
RemoveElement
(
mOwnTimer
.
get
(
)
)
;
}
}
void
nsRefreshDriver
:
:
AdvanceTimeAndRefresh
(
int64_t
aMilliseconds
)
{
StopTimer
(
)
;
if
(
!
mTestControllingRefreshes
)
{
mMostRecentRefresh
=
TimeStamp
:
:
Now
(
)
;
mTestControllingRefreshes
=
true
;
if
(
mWaitingForTransaction
)
{
mWaitingForTransaction
=
false
;
mSkippedPaints
=
false
;
}
}
mMostRecentRefresh
+
=
TimeDuration
:
:
FromMilliseconds
(
(
double
)
aMilliseconds
)
;
mozilla
:
:
dom
:
:
AutoNoJSAPI
nojsapi
;
DoTick
(
)
;
}
void
nsRefreshDriver
:
:
RestoreNormalRefresh
(
)
{
mTestControllingRefreshes
=
false
;
EnsureTimerStarted
(
eAllowTimeToGoBackwards
)
;
mPendingTransactions
.
Clear
(
)
;
}
TimeStamp
nsRefreshDriver
:
:
MostRecentRefresh
(
bool
aEnsureTimerStarted
)
const
{
if
(
aEnsureTimerStarted
&
&
!
ServoStyleSet
:
:
IsInServoTraversal
(
)
)
{
const_cast
<
nsRefreshDriver
*
>
(
this
)
-
>
EnsureTimerStarted
(
)
;
}
return
mMostRecentRefresh
;
}
void
nsRefreshDriver
:
:
AddRefreshObserver
(
nsARefreshObserver
*
aObserver
FlushType
aFlushType
const
char
*
aObserverDescription
)
{
ObserverArray
&
array
=
ArrayFor
(
aFlushType
)
;
array
.
AppendElement
(
ObserverData
{
aObserver
aObserverDescription
TimeStamp
:
:
Now
(
)
MarkerInnerWindowIdFromDocShell
(
GetDocShell
(
mPresContext
)
)
profiler_capture_backtrace
(
)
aFlushType
}
)
;
EnsureTimerStarted
(
)
;
}
bool
nsRefreshDriver
:
:
RemoveRefreshObserver
(
nsARefreshObserver
*
aObserver
FlushType
aFlushType
)
{
ObserverArray
&
array
=
ArrayFor
(
aFlushType
)
;
auto
index
=
array
.
IndexOf
(
aObserver
)
;
if
(
index
=
=
ObserverArray
:
:
array_type
:
:
NoIndex
)
{
return
false
;
}
if
(
profiler_thread_is_being_profiled_for_markers
(
)
)
{
auto
&
data
=
array
.
ElementAt
(
index
)
;
nsPrintfCString
str
(
"
%
s
[
%
s
]
"
data
.
mDescription
kFlushTypeNames
[
aFlushType
]
)
;
PROFILER_MARKER_TEXT
(
"
RefreshObserver
"
GRAPHICS
MarkerOptions
(
MarkerStack
:
:
TakeBacktrace
(
std
:
:
move
(
data
.
mCause
)
)
MarkerTiming
:
:
IntervalUntilNowFrom
(
data
.
mRegisterTime
)
std
:
:
move
(
data
.
mInnerWindowId
)
)
str
)
;
}
array
.
RemoveElementAt
(
index
)
;
return
true
;
}
void
nsRefreshDriver
:
:
AddTimerAdjustmentObserver
(
nsATimerAdjustmentObserver
*
aObserver
)
{
MOZ_ASSERT
(
!
mTimerAdjustmentObservers
.
Contains
(
aObserver
)
)
;
mTimerAdjustmentObservers
.
AppendElement
(
aObserver
)
;
}
void
nsRefreshDriver
:
:
RemoveTimerAdjustmentObserver
(
nsATimerAdjustmentObserver
*
aObserver
)
{
MOZ_ASSERT
(
mTimerAdjustmentObservers
.
Contains
(
aObserver
)
)
;
mTimerAdjustmentObservers
.
RemoveElement
(
aObserver
)
;
}
void
nsRefreshDriver
:
:
PostVisualViewportResizeEvent
(
VVPResizeEvent
*
aResizeEvent
)
{
mVisualViewportResizeEvents
.
AppendElement
(
aResizeEvent
)
;
EnsureTimerStarted
(
)
;
}
void
nsRefreshDriver
:
:
DispatchVisualViewportResizeEvents
(
)
{
VisualViewportResizeEventArray
events
=
std
:
:
move
(
mVisualViewportResizeEvents
)
;
for
(
auto
&
event
:
events
)
{
event
-
>
Run
(
)
;
}
}
void
nsRefreshDriver
:
:
PostScrollEvent
(
mozilla
:
:
Runnable
*
aScrollEvent
bool
aDelayed
)
{
if
(
aDelayed
)
{
mDelayedScrollEvents
.
AppendElement
(
aScrollEvent
)
;
}
else
{
mScrollEvents
.
AppendElement
(
aScrollEvent
)
;
EnsureTimerStarted
(
)
;
}
}
void
nsRefreshDriver
:
:
DispatchScrollEvents
(
)
{
ScrollEventArray
events
=
std
:
:
move
(
mScrollEvents
)
;
for
(
auto
&
event
:
events
)
{
event
-
>
Run
(
)
;
}
}
void
nsRefreshDriver
:
:
PostVisualViewportScrollEvent
(
VVPScrollEvent
*
aScrollEvent
)
{
mVisualViewportScrollEvents
.
AppendElement
(
aScrollEvent
)
;
EnsureTimerStarted
(
)
;
}
void
nsRefreshDriver
:
:
DispatchVisualViewportScrollEvents
(
)
{
VisualViewportScrollEventArray
events
=
std
:
:
move
(
mVisualViewportScrollEvents
)
;
for
(
auto
&
event
:
events
)
{
event
-
>
Run
(
)
;
}
}
void
nsRefreshDriver
:
:
AddPostRefreshObserver
(
nsAPostRefreshObserver
*
aObserver
)
{
MOZ_ASSERT
(
!
mPostRefreshObservers
.
Contains
(
aObserver
)
)
;
mPostRefreshObservers
.
AppendElement
(
aObserver
)
;
}
void
nsRefreshDriver
:
:
RemovePostRefreshObserver
(
nsAPostRefreshObserver
*
aObserver
)
{
bool
removed
=
mPostRefreshObservers
.
RemoveElement
(
aObserver
)
;
MOZ_DIAGNOSTIC_ASSERT
(
removed
)
;
Unused
<
<
removed
;
}
void
nsRefreshDriver
:
:
AddImageRequest
(
imgIRequest
*
aRequest
)
{
uint32_t
delay
=
GetFirstFrameDelay
(
aRequest
)
;
if
(
delay
=
=
0
)
{
mRequests
.
Insert
(
aRequest
)
;
}
else
{
auto
*
const
start
=
mStartTable
.
GetOrInsertNew
(
delay
)
;
start
-
>
mEntries
.
Insert
(
aRequest
)
;
}
EnsureTimerStarted
(
)
;
if
(
profiler_thread_is_being_profiled_for_markers
(
)
)
{
nsCOMPtr
<
nsIURI
>
uri
=
aRequest
-
>
GetURI
(
)
;
PROFILER_MARKER_TEXT
(
"
Image
Animation
"
GRAPHICS
MarkerOptions
(
MarkerTiming
:
:
IntervalStart
(
)
MarkerInnerWindowIdFromDocShell
(
GetDocShell
(
mPresContext
)
)
)
nsContentUtils
:
:
TruncatedURLForDisplay
(
uri
)
)
;
}
}
void
nsRefreshDriver
:
:
RemoveImageRequest
(
imgIRequest
*
aRequest
)
{
bool
removed
=
mRequests
.
EnsureRemoved
(
aRequest
)
;
uint32_t
delay
=
GetFirstFrameDelay
(
aRequest
)
;
if
(
delay
!
=
0
)
{
ImageStartData
*
start
=
mStartTable
.
Get
(
delay
)
;
if
(
start
)
{
removed
=
removed
|
start
-
>
mEntries
.
EnsureRemoved
(
aRequest
)
;
}
}
if
(
removed
&
&
profiler_thread_is_being_profiled_for_markers
(
)
)
{
nsCOMPtr
<
nsIURI
>
uri
=
aRequest
-
>
GetURI
(
)
;
PROFILER_MARKER_TEXT
(
"
Image
Animation
"
GRAPHICS
MarkerOptions
(
MarkerTiming
:
:
IntervalEnd
(
)
MarkerInnerWindowIdFromDocShell
(
GetDocShell
(
mPresContext
)
)
)
nsContentUtils
:
:
TruncatedURLForDisplay
(
uri
)
)
;
}
}
void
nsRefreshDriver
:
:
NotifyDOMContentLoaded
(
)
{
if
(
!
HasObservers
(
)
)
{
if
(
nsPresContext
*
pc
=
GetPresContext
(
)
)
{
pc
-
>
NotifyDOMContentFlushed
(
)
;
}
}
else
{
mNotifyDOMContentFlushed
=
true
;
}
}
void
nsRefreshDriver
:
:
RegisterCompositionPayload
(
const
mozilla
:
:
layers
:
:
CompositionPayload
&
aPayload
)
{
mCompositionPayloads
.
AppendElement
(
aPayload
)
;
}
void
nsRefreshDriver
:
:
AddForceNotifyContentfulPaintPresContext
(
nsPresContext
*
aPresContext
)
{
mForceNotifyContentfulPaintPresContexts
.
AppendElement
(
aPresContext
)
;
}
void
nsRefreshDriver
:
:
FlushForceNotifyContentfulPaintPresContext
(
)
{
while
(
!
mForceNotifyContentfulPaintPresContexts
.
IsEmpty
(
)
)
{
WeakPtr
<
nsPresContext
>
presContext
=
mForceNotifyContentfulPaintPresContexts
.
PopLastElement
(
)
;
if
(
presContext
)
{
presContext
-
>
NotifyContentfulPaint
(
)
;
}
}
}
void
nsRefreshDriver
:
:
RunDelayedEventsSoon
(
)
{
mScrollEvents
.
AppendElements
(
mDelayedScrollEvents
)
;
mDelayedScrollEvents
.
Clear
(
)
;
mResizeEventFlushObservers
.
AppendElements
(
mDelayedResizeEventFlushObservers
)
;
mDelayedResizeEventFlushObservers
.
Clear
(
)
;
EnsureTimerStarted
(
)
;
}
bool
nsRefreshDriver
:
:
CanDoCatchUpTick
(
)
{
if
(
mTestControllingRefreshes
|
|
!
mActiveTimer
)
{
return
false
;
}
if
(
mMostRecentRefresh
>
=
mActiveTimer
-
>
MostRecentRefresh
(
)
)
{
return
false
;
}
if
(
mTickVsyncTime
.
IsNull
(
)
)
{
return
false
;
}
if
(
mPresContext
&
&
mPresContext
-
>
Document
(
)
-
>
GetReadyStateEnum
(
)
<
Document
:
:
READYSTATE_COMPLETE
)
{
return
false
;
}
return
true
;
}
bool
nsRefreshDriver
:
:
CanDoExtraTick
(
)
{
if
(
mAttemptedExtraTickSinceLastVsync
)
{
return
false
;
}
if
(
!
mActiveTimer
|
|
mActiveTimer
-
>
MostRecentRefresh
(
)
!
=
mMostRecentRefresh
)
{
return
false
;
}
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
Maybe
<
TimeStamp
>
nextTick
=
mActiveTimer
-
>
GetNextTickHint
(
)
;
int32_t
minimumRequiredTime
=
StaticPrefs
:
:
layout_extra_tick_minimum_ms
(
)
;
if
(
minimumRequiredTime
<
0
|
|
!
nextTick
|
|
(
*
nextTick
-
now
)
<
TimeDuration
:
:
FromMilliseconds
(
minimumRequiredTime
)
)
{
return
false
;
}
return
true
;
}
void
nsRefreshDriver
:
:
EnsureTimerStarted
(
EnsureTimerStartedFlags
aFlags
)
{
MOZ_ASSERT
(
!
ServoStyleSet
:
:
IsInServoTraversal
(
)
|
|
NS_IsMainThread
(
)
"
EnsureTimerStarted
should
be
called
only
when
we
are
not
"
"
in
servo
traversal
or
on
the
main
-
thread
"
)
;
if
(
mTestControllingRefreshes
)
return
;
if
(
!
mRefreshTimerStartedCause
)
{
mRefreshTimerStartedCause
=
profiler_capture_backtrace
(
)
;
}
if
(
mActiveTimer
&
&
!
(
aFlags
&
eForceAdjustTimer
)
)
{
if
(
mUserInputProcessingCount
&
&
CanDoExtraTick
(
)
)
{
RefPtr
<
nsRefreshDriver
>
self
=
this
;
NS_DispatchToCurrentThreadQueue
(
NS_NewRunnableFunction
(
"
RefreshDriver
:
:
EnsureTimerStarted
:
:
extra
"
[
self
]
(
)
-
>
void
{
if
(
self
-
>
CanDoExtraTick
(
)
)
{
PROFILER_MARKER_UNTYPED
(
"
ExtraRefreshDriverTick
"
GRAPHICS
)
;
LOG
(
"
[
%
p
]
Doing
extra
tick
for
user
input
"
self
.
get
(
)
)
;
self
-
>
mAttemptedExtraTickSinceLastVsync
=
true
;
self
-
>
Tick
(
self
-
>
mActiveTimer
-
>
MostRecentRefreshVsyncId
(
)
self
-
>
mActiveTimer
-
>
MostRecentRefresh
(
)
IsExtraTick
:
:
Yes
)
;
}
}
)
EventQueuePriority
:
:
Vsync
)
;
}
return
;
}
if
(
IsFrozen
(
)
|
|
!
mPresContext
)
{
StopTimer
(
)
;
return
;
}
if
(
mPresContext
-
>
Document
(
)
-
>
IsBeingUsedAsImage
(
)
)
{
if
(
!
mPresContext
-
>
Document
(
)
-
>
IsSVGGlyphsDocument
(
)
)
{
MOZ_ASSERT
(
!
mActiveTimer
"
image
doc
refresh
driver
should
never
have
its
own
timer
"
)
;
return
;
}
}
RefreshDriverTimer
*
newTimer
=
ChooseTimer
(
)
;
if
(
newTimer
!
=
mActiveTimer
)
{
if
(
mActiveTimer
)
mActiveTimer
-
>
RemoveRefreshDriver
(
this
)
;
mActiveTimer
=
newTimer
;
mActiveTimer
-
>
AddRefreshDriver
(
this
)
;
if
(
!
mHasStartedTimerAtLeastOnce
)
{
mHasStartedTimerAtLeastOnce
=
true
;
if
(
profiler_thread_is_being_profiled_for_markers
(
)
)
{
nsCString
text
=
"
initial
timer
start
"
_ns
;
if
(
mPresContext
-
>
Document
(
)
-
>
GetDocumentURI
(
)
)
{
text
.
Append
(
nsContentUtils
:
:
TruncatedURLForDisplay
(
mPresContext
-
>
Document
(
)
-
>
GetDocumentURI
(
)
)
)
;
}
PROFILER_MARKER_TEXT
(
"
nsRefreshDriver
"
LAYOUT
MarkerOptions
(
MarkerInnerWindowIdFromDocShell
(
GetDocShell
(
mPresContext
)
)
)
text
)
;
}
}
if
(
CanDoCatchUpTick
(
)
)
{
RefPtr
<
nsRefreshDriver
>
self
=
this
;
NS_DispatchToCurrentThreadQueue
(
NS_NewRunnableFunction
(
"
RefreshDriver
:
:
EnsureTimerStarted
:
:
catch
-
up
"
[
self
]
(
)
-
>
void
{
if
(
self
-
>
CanDoCatchUpTick
(
)
)
{
LOG
(
"
[
%
p
]
Doing
catch
up
tick
"
self
.
get
(
)
)
;
self
-
>
Tick
(
self
-
>
mActiveTimer
-
>
MostRecentRefreshVsyncId
(
)
self
-
>
mActiveTimer
-
>
MostRecentRefresh
(
)
)
;
}
}
)
EventQueuePriority
:
:
Vsync
)
;
}
}
if
(
aFlags
&
eNeverAdjustTimer
)
{
return
;
}
if
(
!
(
aFlags
&
eAllowTimeToGoBackwards
)
)
{
return
;
}
if
(
mMostRecentRefresh
!
=
mActiveTimer
-
>
MostRecentRefresh
(
)
)
{
mMostRecentRefresh
=
mActiveTimer
-
>
MostRecentRefresh
(
)
;
for
(
nsATimerAdjustmentObserver
*
obs
:
mTimerAdjustmentObservers
.
EndLimitedRange
(
)
)
{
obs
-
>
NotifyTimerAdjusted
(
mMostRecentRefresh
)
;
}
}
}
void
nsRefreshDriver
:
:
StopTimer
(
)
{
if
(
!
mActiveTimer
)
return
;
mActiveTimer
-
>
RemoveRefreshDriver
(
this
)
;
mActiveTimer
=
nullptr
;
mRefreshTimerStartedCause
=
nullptr
;
}
uint32_t
nsRefreshDriver
:
:
ObserverCount
(
)
const
{
uint32_t
sum
=
0
;
for
(
const
ObserverArray
&
array
:
mObservers
)
{
sum
+
=
array
.
Length
(
)
;
}
sum
+
=
mAnimationEventFlushObservers
.
Length
(
)
;
sum
+
=
mResizeEventFlushObservers
.
Length
(
)
;
sum
+
=
mStyleFlushObservers
.
Length
(
)
;
sum
+
=
mLayoutFlushObservers
.
Length
(
)
;
sum
+
=
mPendingFullscreenEvents
.
Length
(
)
;
sum
+
=
mFrameRequestCallbackDocs
.
Length
(
)
;
sum
+
=
mThrottledFrameRequestCallbackDocs
.
Length
(
)
;
sum
+
=
mViewManagerFlushIsPending
;
sum
+
=
mEarlyRunners
.
Length
(
)
;
sum
+
=
mTimerAdjustmentObservers
.
Length
(
)
;
sum
+
=
mAutoFocusFlushDocuments
.
Length
(
)
;
return
sum
;
}
bool
nsRefreshDriver
:
:
HasObservers
(
)
const
{
for
(
const
ObserverArray
&
array
:
mObservers
)
{
if
(
!
array
.
IsEmpty
(
)
)
{
return
true
;
}
}
return
mViewManagerFlushIsPending
|
|
!
mStyleFlushObservers
.
IsEmpty
(
)
|
|
!
mLayoutFlushObservers
.
IsEmpty
(
)
|
|
!
mAnimationEventFlushObservers
.
IsEmpty
(
)
|
|
!
mResizeEventFlushObservers
.
IsEmpty
(
)
|
|
!
mPendingFullscreenEvents
.
IsEmpty
(
)
|
|
!
mFrameRequestCallbackDocs
.
IsEmpty
(
)
|
|
!
mThrottledFrameRequestCallbackDocs
.
IsEmpty
(
)
|
|
!
mAutoFocusFlushDocuments
.
IsEmpty
(
)
|
|
!
mEarlyRunners
.
IsEmpty
(
)
;
}
void
nsRefreshDriver
:
:
AppendObserverDescriptionsToString
(
nsACString
&
aStr
)
const
{
for
(
const
ObserverArray
&
array
:
mObservers
)
{
for
(
const
auto
&
observer
:
array
.
EndLimitedRange
(
)
)
{
aStr
.
AppendPrintf
(
"
%
s
[
%
s
]
"
observer
.
mDescription
kFlushTypeNames
[
observer
.
mFlushType
]
)
;
}
}
if
(
mViewManagerFlushIsPending
)
{
aStr
.
AppendLiteral
(
"
View
manager
flush
pending
"
)
;
}
if
(
!
mAnimationEventFlushObservers
.
IsEmpty
(
)
)
{
aStr
.
AppendPrintf
(
"
%
zux
Animation
event
flush
observer
"
mAnimationEventFlushObservers
.
Length
(
)
)
;
}
if
(
!
mResizeEventFlushObservers
.
IsEmpty
(
)
)
{
aStr
.
AppendPrintf
(
"
%
zux
Resize
event
flush
observer
"
mResizeEventFlushObservers
.
Length
(
)
)
;
}
if
(
!
mStyleFlushObservers
.
IsEmpty
(
)
)
{
aStr
.
AppendPrintf
(
"
%
zux
Style
flush
observer
"
mStyleFlushObservers
.
Length
(
)
)
;
}
if
(
!
mLayoutFlushObservers
.
IsEmpty
(
)
)
{
aStr
.
AppendPrintf
(
"
%
zux
Layout
flush
observer
"
mLayoutFlushObservers
.
Length
(
)
)
;
}
if
(
!
mPendingFullscreenEvents
.
IsEmpty
(
)
)
{
aStr
.
AppendPrintf
(
"
%
zux
Pending
fullscreen
event
"
mPendingFullscreenEvents
.
Length
(
)
)
;
}
if
(
!
mFrameRequestCallbackDocs
.
IsEmpty
(
)
)
{
aStr
.
AppendPrintf
(
"
%
zux
Frame
request
callback
doc
"
mFrameRequestCallbackDocs
.
Length
(
)
)
;
}
if
(
!
mThrottledFrameRequestCallbackDocs
.
IsEmpty
(
)
)
{
aStr
.
AppendPrintf
(
"
%
zux
Throttled
frame
request
callback
doc
"
mThrottledFrameRequestCallbackDocs
.
Length
(
)
)
;
}
if
(
!
mAutoFocusFlushDocuments
.
IsEmpty
(
)
)
{
aStr
.
AppendPrintf
(
"
%
zux
AutoFocus
flush
doc
"
mAutoFocusFlushDocuments
.
Length
(
)
)
;
}
if
(
!
mEarlyRunners
.
IsEmpty
(
)
)
{
aStr
.
AppendPrintf
(
"
%
zux
Early
runner
"
mEarlyRunners
.
Length
(
)
)
;
}
aStr
.
Truncate
(
aStr
.
Length
(
)
-
2
)
;
}
bool
nsRefreshDriver
:
:
HasImageRequests
(
)
const
{
for
(
const
auto
&
data
:
mStartTable
.
Values
(
)
)
{
if
(
!
data
-
>
mEntries
.
IsEmpty
(
)
)
{
return
true
;
}
}
return
!
mRequests
.
IsEmpty
(
)
;
}
auto
nsRefreshDriver
:
:
GetReasonsToTick
(
)
const
-
>
TickReasons
{
TickReasons
reasons
=
TickReasons
:
:
eNone
;
if
(
HasObservers
(
)
)
{
reasons
|
=
TickReasons
:
:
eHasObservers
;
}
if
(
HasImageRequests
(
)
)
{
reasons
|
=
TickReasons
:
:
eHasImageRequests
;
}
if
(
mNeedToUpdateIntersectionObservations
)
{
reasons
|
=
TickReasons
:
:
eNeedsToUpdateIntersectionObservations
;
}
if
(
mNeedToUpdateContentRelevancy
)
{
reasons
|
=
TickReasons
:
:
eNeedsToUpdateContentRelevancy
;
}
if
(
!
mVisualViewportResizeEvents
.
IsEmpty
(
)
)
{
reasons
|
=
TickReasons
:
:
eHasVisualViewportResizeEvents
;
}
if
(
!
mScrollEvents
.
IsEmpty
(
)
)
{
reasons
|
=
TickReasons
:
:
eHasScrollEvents
;
}
if
(
!
mVisualViewportScrollEvents
.
IsEmpty
(
)
)
{
reasons
|
=
TickReasons
:
:
eHasVisualViewportScrollEvents
;
}
return
reasons
;
}
void
nsRefreshDriver
:
:
AppendTickReasonsToString
(
TickReasons
aReasons
nsACString
&
aStr
)
const
{
if
(
aReasons
=
=
TickReasons
:
:
eNone
)
{
aStr
.
AppendLiteral
(
"
<
none
>
"
)
;
return
;
}
if
(
aReasons
&
TickReasons
:
:
eHasObservers
)
{
aStr
.
AppendLiteral
(
"
HasObservers
(
"
)
;
AppendObserverDescriptionsToString
(
aStr
)
;
aStr
.
AppendLiteral
(
"
)
"
)
;
}
if
(
aReasons
&
TickReasons
:
:
eHasImageRequests
)
{
aStr
.
AppendLiteral
(
"
HasImageAnimations
"
)
;
}
if
(
aReasons
&
TickReasons
:
:
eNeedsToUpdateIntersectionObservations
)
{
aStr
.
AppendLiteral
(
"
NeedsToUpdateIntersectionObservations
"
)
;
}
if
(
aReasons
&
TickReasons
:
:
eNeedsToUpdateContentRelevancy
)
{
aStr
.
AppendLiteral
(
"
NeedsToUpdateContentRelevancy
"
)
;
}
if
(
aReasons
&
TickReasons
:
:
eHasVisualViewportResizeEvents
)
{
aStr
.
AppendLiteral
(
"
HasVisualViewportResizeEvents
"
)
;
}
if
(
aReasons
&
TickReasons
:
:
eHasScrollEvents
)
{
aStr
.
AppendLiteral
(
"
HasScrollEvents
"
)
;
}
if
(
aReasons
&
TickReasons
:
:
eHasVisualViewportScrollEvents
)
{
aStr
.
AppendLiteral
(
"
HasVisualViewportScrollEvents
"
)
;
}
}
bool
nsRefreshDriver
:
:
ShouldKeepTimerRunningWhileWaitingForFirstContentfulPaint
(
)
{
if
(
mThrottled
|
|
mTestControllingRefreshes
|
|
!
XRE_IsContentProcess
(
)
|
|
!
mPresContext
-
>
Document
(
)
-
>
IsTopLevelContentDocument
(
)
|
|
mPresContext
-
>
Document
(
)
-
>
IsInitialDocument
(
)
|
|
gfxPlatform
:
:
IsInLayoutAsapMode
(
)
|
|
mPresContext
-
>
HadContentfulPaint
(
)
|
|
mPresContext
-
>
Document
(
)
-
>
GetReadyStateEnum
(
)
=
=
Document
:
:
READYSTATE_COMPLETE
)
{
return
false
;
}
if
(
mBeforeFirstContentfulPaintTimerRunningLimit
.
IsNull
(
)
)
{
mBeforeFirstContentfulPaintTimerRunningLimit
=
TimeStamp
:
:
Now
(
)
+
TimeDuration
:
:
FromSeconds
(
4
.
0f
)
;
}
return
TimeStamp
:
:
Now
(
)
<
=
mBeforeFirstContentfulPaintTimerRunningLimit
;
}
bool
nsRefreshDriver
:
:
ShouldKeepTimerRunningAfterPageLoad
(
)
{
if
(
mHasExceededAfterLoadTickPeriod
|
|
!
StaticPrefs
:
:
layout_keep_ticking_after_load_ms
(
)
|
|
mThrottled
|
|
mTestControllingRefreshes
|
|
!
XRE_IsContentProcess
(
)
|
|
!
mPresContext
-
>
Document
(
)
-
>
IsTopLevelContentDocument
(
)
|
|
TaskController
:
:
Get
(
)
-
>
PendingMainthreadTaskCountIncludingSuspended
(
)
=
=
0
|
|
gfxPlatform
:
:
IsInLayoutAsapMode
(
)
)
{
mHasExceededAfterLoadTickPeriod
=
true
;
return
false
;
}
nsPIDOMWindowInner
*
innerWindow
=
mPresContext
-
>
Document
(
)
-
>
GetInnerWindow
(
)
;
if
(
!
innerWindow
)
{
return
false
;
}
auto
*
perf
=
static_cast
<
PerformanceMainThread
*
>
(
innerWindow
-
>
GetPerformance
(
)
)
;
if
(
!
perf
)
{
return
false
;
}
nsDOMNavigationTiming
*
timing
=
perf
-
>
GetDOMTiming
(
)
;
if
(
!
timing
)
{
return
false
;
}
TimeStamp
loadend
=
timing
-
>
LoadEventEnd
(
)
;
if
(
!
loadend
)
{
return
false
;
}
const
bool
retval
=
(
loadend
+
TimeDuration
:
:
FromMilliseconds
(
StaticPrefs
:
:
layout_keep_ticking_after_load_ms
(
)
)
)
>
TimeStamp
:
:
Now
(
)
;
if
(
!
retval
)
{
mHasExceededAfterLoadTickPeriod
=
true
;
}
return
retval
;
}
nsRefreshDriver
:
:
ObserverArray
&
nsRefreshDriver
:
:
ArrayFor
(
FlushType
aFlushType
)
{
switch
(
aFlushType
)
{
case
FlushType
:
:
Event
:
return
mObservers
[
0
]
;
case
FlushType
:
:
Style
:
case
FlushType
:
:
Frames
:
return
mObservers
[
1
]
;
case
FlushType
:
:
Layout
:
return
mObservers
[
2
]
;
case
FlushType
:
:
Display
:
return
mObservers
[
3
]
;
default
:
MOZ_CRASH
(
"
We
don
'
t
track
refresh
observers
for
this
flush
type
"
)
;
}
}
void
nsRefreshDriver
:
:
DoTick
(
)
{
MOZ_ASSERT
(
!
IsFrozen
(
)
"
Why
are
we
notified
while
frozen
?
"
)
;
MOZ_ASSERT
(
mPresContext
"
Why
are
we
notified
after
disconnection
?
"
)
;
MOZ_ASSERT
(
!
nsContentUtils
:
:
GetCurrentJSContext
(
)
"
Shouldn
'
t
have
a
JSContext
on
the
stack
"
)
;
if
(
mTestControllingRefreshes
)
{
Tick
(
VsyncId
(
)
mMostRecentRefresh
)
;
}
else
{
Tick
(
VsyncId
(
)
TimeStamp
:
:
Now
(
)
)
;
}
}
struct
DocumentFrameCallbacks
{
explicit
DocumentFrameCallbacks
(
Document
*
aDocument
)
:
mDocument
(
aDocument
)
{
}
RefPtr
<
Document
>
mDocument
;
nsTArray
<
FrameRequest
>
mCallbacks
;
}
;
static
bool
HasPendingAnimations
(
PresShell
*
aPresShell
)
{
Document
*
doc
=
aPresShell
-
>
GetDocument
(
)
;
if
(
!
doc
)
{
return
false
;
}
PendingAnimationTracker
*
tracker
=
doc
-
>
GetPendingAnimationTracker
(
)
;
return
tracker
&
&
tracker
-
>
HasPendingAnimations
(
)
;
}
static
void
GetProfileTimelineSubDocShells
(
nsDocShell
*
aRootDocShell
nsTArray
<
nsDocShell
*
>
&
aShells
)
{
if
(
!
aRootDocShell
)
{
return
;
}
if
(
TimelineConsumers
:
:
IsEmpty
(
)
)
{
return
;
}
RefPtr
<
BrowsingContext
>
bc
=
aRootDocShell
-
>
GetBrowsingContext
(
)
;
if
(
!
bc
)
{
return
;
}
bc
-
>
PostOrderWalk
(
[
&
]
(
BrowsingContext
*
aContext
)
{
if
(
!
aContext
-
>
IsActive
(
)
)
{
return
;
}
nsDocShell
*
shell
=
nsDocShell
:
:
Cast
(
aContext
-
>
GetDocShell
(
)
)
;
if
(
!
shell
|
|
!
shell
-
>
GetRecordProfileTimelineMarkers
(
)
)
{
return
;
}
aShells
.
AppendElement
(
shell
)
;
}
)
;
}
static
void
TakeFrameRequestCallbacksFrom
(
Document
*
aDocument
nsTArray
<
DocumentFrameCallbacks
>
&
aTarget
)
{
aTarget
.
AppendElement
(
aDocument
)
;
aDocument
-
>
TakeFrameRequestCallbacks
(
aTarget
.
LastElement
(
)
.
mCallbacks
)
;
}
void
nsRefreshDriver
:
:
ScheduleAutoFocusFlush
(
Document
*
aDocument
)
{
MOZ_ASSERT
(
!
mAutoFocusFlushDocuments
.
Contains
(
aDocument
)
)
;
mAutoFocusFlushDocuments
.
AppendElement
(
aDocument
)
;
EnsureTimerStarted
(
)
;
}
void
nsRefreshDriver
:
:
FlushAutoFocusDocuments
(
)
{
nsTArray
<
RefPtr
<
Document
>
>
docs
(
std
:
:
move
(
mAutoFocusFlushDocuments
)
)
;
for
(
const
auto
&
doc
:
docs
)
{
MOZ_KnownLive
(
doc
)
-
>
FlushAutoFocusCandidates
(
)
;
}
}
void
nsRefreshDriver
:
:
CancelFlushAutoFocus
(
Document
*
aDocument
)
{
mAutoFocusFlushDocuments
.
RemoveElement
(
aDocument
)
;
}
void
nsRefreshDriver
:
:
RunFullscreenSteps
(
)
{
nsTArray
<
UniquePtr
<
PendingFullscreenEvent
>
>
pendings
(
std
:
:
move
(
mPendingFullscreenEvents
)
)
;
for
(
UniquePtr
<
PendingFullscreenEvent
>
&
event
:
pendings
)
{
event
-
>
Dispatch
(
)
;
}
}
void
nsRefreshDriver
:
:
UpdateIntersectionObservations
(
TimeStamp
aNowTime
)
{
AUTO_PROFILER_LABEL_RELEVANT_FOR_JS
(
"
Compute
intersections
"
LAYOUT
)
;
AutoTArray
<
RefPtr
<
Document
>
32
>
documents
;
if
(
mPresContext
-
>
Document
(
)
-
>
HasIntersectionObservers
(
)
)
{
documents
.
AppendElement
(
mPresContext
-
>
Document
(
)
)
;
}
mPresContext
-
>
Document
(
)
-
>
CollectDescendantDocuments
(
documents
[
]
(
const
Document
*
document
)
-
>
bool
{
return
document
-
>
HasIntersectionObservers
(
)
;
}
)
;
for
(
const
auto
&
doc
:
documents
)
{
doc
-
>
UpdateIntersectionObservations
(
aNowTime
)
;
doc
-
>
ScheduleIntersectionObserverNotification
(
)
;
}
mNeedToUpdateIntersectionObservations
=
false
;
}
void
nsRefreshDriver
:
:
UpdateRelevancyOfContentVisibilityAutoFrames
(
)
{
if
(
!
mNeedToUpdateContentRelevancy
)
{
return
;
}
if
(
RefPtr
<
PresShell
>
topLevelPresShell
=
mPresContext
-
>
GetPresShell
(
)
)
{
topLevelPresShell
-
>
UpdateRelevancyOfContentVisibilityAutoFrames
(
)
;
}
mPresContext
-
>
Document
(
)
-
>
EnumerateSubDocuments
(
[
]
(
Document
&
aSubDoc
)
{
if
(
PresShell
*
presShell
=
aSubDoc
.
GetPresShell
(
)
)
{
presShell
-
>
UpdateRelevancyOfContentVisibilityAutoFrames
(
)
;
}
return
CallState
:
:
Continue
;
}
)
;
mNeedToUpdateContentRelevancy
=
false
;
}
void
nsRefreshDriver
:
:
DispatchAnimationEvents
(
)
{
if
(
!
mPresContext
)
{
return
;
}
AutoTArray
<
RefPtr
<
AnimationEventDispatcher
>
16
>
dispatchers
;
dispatchers
.
AppendElements
(
mAnimationEventFlushObservers
)
;
mAnimationEventFlushObservers
.
Clear
(
)
;
for
(
auto
&
dispatcher
:
dispatchers
)
{
dispatcher
-
>
DispatchEvents
(
)
;
}
}
void
nsRefreshDriver
:
:
RunFrameRequestCallbacks
(
TimeStamp
aNowTime
)
{
nsTArray
<
DocumentFrameCallbacks
>
frameRequestCallbacks
(
mFrameRequestCallbackDocs
.
Length
(
)
+
mThrottledFrameRequestCallbackDocs
.
Length
(
)
)
;
{
nsTArray
<
Document
*
>
docsToRemove
;
bool
tickThrottledFrameRequests
=
mThrottled
;
if
(
!
tickThrottledFrameRequests
&
&
aNowTime
>
=
mNextThrottledFrameRequestTick
)
{
mNextThrottledFrameRequestTick
=
aNowTime
+
mThrottledFrameRequestInterval
;
tickThrottledFrameRequests
=
true
;
}
for
(
Document
*
doc
:
mThrottledFrameRequestCallbackDocs
)
{
if
(
tickThrottledFrameRequests
)
{
TakeFrameRequestCallbacksFrom
(
doc
frameRequestCallbacks
)
;
}
else
if
(
!
doc
-
>
ShouldThrottleFrameRequests
(
)
)
{
TakeFrameRequestCallbacksFrom
(
doc
frameRequestCallbacks
)
;
docsToRemove
.
AppendElement
(
doc
)
;
}
}
if
(
tickThrottledFrameRequests
)
{
mThrottledFrameRequestCallbackDocs
.
Clear
(
)
;
}
else
{
for
(
Document
*
doc
:
docsToRemove
)
{
mThrottledFrameRequestCallbackDocs
.
RemoveElement
(
doc
)
;
}
}
}
for
(
Document
*
doc
:
mFrameRequestCallbackDocs
)
{
TakeFrameRequestCallbacksFrom
(
doc
frameRequestCallbacks
)
;
}
mFrameRequestCallbackDocs
.
Clear
(
)
;
if
(
!
frameRequestCallbacks
.
IsEmpty
(
)
)
{
AUTO_PROFILER_TRACING_MARKER_DOCSHELL
(
"
Paint
"
"
requestAnimationFrame
callbacks
"
GRAPHICS
GetDocShell
(
mPresContext
)
)
;
for
(
const
DocumentFrameCallbacks
&
docCallbacks
:
frameRequestCallbacks
)
{
TimeStamp
startTime
=
TimeStamp
:
:
Now
(
)
;
nsPIDOMWindowInner
*
innerWindow
=
docCallbacks
.
mDocument
-
>
GetInnerWindow
(
)
;
DOMHighResTimeStamp
timeStamp
=
0
;
if
(
innerWindow
)
{
if
(
Performance
*
perf
=
innerWindow
-
>
GetPerformance
(
)
)
{
timeStamp
=
perf
-
>
TimeStampToDOMHighResForRendering
(
aNowTime
)
;
}
}
for
(
auto
&
callback
:
docCallbacks
.
mCallbacks
)
{
if
(
docCallbacks
.
mDocument
-
>
IsCanceledFrameRequestCallback
(
callback
.
mHandle
)
)
{
continue
;
}
nsCOMPtr
<
nsIGlobalObject
>
global
(
innerWindow
?
innerWindow
-
>
AsGlobal
(
)
:
nullptr
)
;
CallbackDebuggerNotificationGuard
guard
(
global
DebuggerNotificationType
:
:
RequestAnimationFrameCallback
)
;
LogFrameRequestCallback
:
:
Run
run
(
callback
.
mCallback
)
;
MOZ_KnownLive
(
callback
.
mCallback
)
-
>
Call
(
timeStamp
)
;
}
if
(
docCallbacks
.
mDocument
-
>
GetReadyStateEnum
(
)
=
=
Document
:
:
READYSTATE_COMPLETE
)
{
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
PERF_REQUEST_ANIMATION_CALLBACK_NON_PAGELOAD_MS
startTime
TimeStamp
:
:
Now
(
)
)
;
}
else
{
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
PERF_REQUEST_ANIMATION_CALLBACK_PAGELOAD_MS
startTime
TimeStamp
:
:
Now
(
)
)
;
}
}
}
}
static
StaticAutoPtr
<
AutoTArray
<
RefPtr
<
Task
>
8
>
>
sPendingIdleTasks
;
void
nsRefreshDriver
:
:
DispatchIdleTaskAfterTickUnlessExists
(
Task
*
aTask
)
{
if
(
!
sPendingIdleTasks
)
{
sPendingIdleTasks
=
new
AutoTArray
<
RefPtr
<
Task
>
8
>
(
)
;
}
else
{
if
(
sPendingIdleTasks
-
>
Contains
(
aTask
)
)
{
return
;
}
}
sPendingIdleTasks
-
>
AppendElement
(
aTask
)
;
}
void
nsRefreshDriver
:
:
CancelIdleTask
(
Task
*
aTask
)
{
if
(
!
sPendingIdleTasks
)
{
return
;
}
sPendingIdleTasks
-
>
RemoveElement
(
aTask
)
;
if
(
sPendingIdleTasks
-
>
IsEmpty
(
)
)
{
sPendingIdleTasks
=
nullptr
;
}
}
static
CallState
ReduceAnimations
(
Document
&
aDocument
)
{
if
(
nsPresContext
*
pc
=
aDocument
.
GetPresContext
(
)
)
{
if
(
pc
-
>
EffectCompositor
(
)
-
>
NeedsReducing
(
)
)
{
pc
-
>
EffectCompositor
(
)
-
>
ReduceAnimations
(
)
;
}
}
aDocument
.
EnumerateSubDocuments
(
ReduceAnimations
)
;
return
CallState
:
:
Continue
;
}
bool
nsRefreshDriver
:
:
ShouldStopActivityGracePeriod
(
)
const
{
MOZ_ASSERT
(
mIsGrantingActivityGracePeriod
)
;
return
TimeStamp
:
:
Now
(
)
-
mActivityGracePeriodStart
>
=
TimeDuration
:
:
FromMilliseconds
(
StaticPrefs
:
:
layout_oopif_activity_grace_period_ms
(
)
)
;
}
void
nsRefreshDriver
:
:
Tick
(
VsyncId
aId
TimeStamp
aNowTime
IsExtraTick
aIsExtraTick
)
{
MOZ_ASSERT
(
!
nsContentUtils
:
:
GetCurrentJSContext
(
)
"
Shouldn
'
t
have
a
JSContext
on
the
stack
"
)
;
if
(
IsFrozen
(
)
|
|
!
mPresContext
)
{
return
;
}
if
(
(
aNowTime
<
=
mMostRecentRefresh
)
&
&
!
mTestControllingRefreshes
&
&
aIsExtraTick
=
=
IsExtraTick
:
:
No
)
{
return
;
}
auto
cleanupInExtraTick
=
MakeScopeExit
(
[
&
]
{
mInNormalTick
=
false
;
}
)
;
mInNormalTick
=
aIsExtraTick
!
=
IsExtraTick
:
:
Yes
;
bool
isPresentingInVR
=
false
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
isPresentingInVR
=
gfx
:
:
VRManagerChild
:
:
IsPresenting
(
)
;
#
endif
if
(
!
isPresentingInVR
&
&
IsWaitingForPaint
(
aNowTime
)
)
{
PROFILER_MARKER_UNTYPED
(
"
RefreshDriverTick
waiting
for
paint
"
GRAPHICS
MarkerInnerWindowIdFromDocShell
(
GetDocShell
(
mPresContext
)
)
)
;
return
;
}
TimeStamp
previousRefresh
=
mMostRecentRefresh
;
mMostRecentRefresh
=
aNowTime
;
if
(
mRootRefresh
)
{
mRootRefresh
-
>
RemoveRefreshObserver
(
this
FlushType
:
:
Style
)
;
mRootRefresh
=
nullptr
;
}
mSkippedPaints
=
false
;
RefPtr
<
PresShell
>
presShell
=
mPresContext
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
StopTimer
(
)
;
return
;
}
TickReasons
tickReasons
=
GetReasonsToTick
(
)
;
if
(
tickReasons
=
=
TickReasons
:
:
eNone
)
{
mCompositionPayloads
.
Clear
(
)
;
if
(
ShouldKeepTimerRunningWhileWaitingForFirstContentfulPaint
(
)
)
{
PROFILER_MARKER
(
"
RefreshDriverTick
waiting
for
first
contentful
paint
"
GRAPHICS
MarkerInnerWindowIdFromDocShell
(
GetDocShell
(
mPresContext
)
)
Tracing
"
Paint
"
)
;
}
else
if
(
ShouldKeepTimerRunningAfterPageLoad
(
)
)
{
PROFILER_MARKER
(
"
RefreshDriverTick
after
page
load
"
GRAPHICS
MarkerInnerWindowIdFromDocShell
(
GetDocShell
(
mPresContext
)
)
Tracing
"
Paint
"
)
;
}
else
{
StopTimer
(
)
;
}
return
;
}
if
(
StaticPrefs
:
:
layout_skip_ticks_while_page_suspended
(
)
)
{
Document
*
doc
=
mPresContext
-
>
Document
(
)
;
nsPIDOMWindowInner
*
win
=
doc
?
doc
-
>
GetInnerWindow
(
)
:
nullptr
;
if
(
win
&
&
win
-
>
IsSuspended
(
)
&
&
doc
-
>
IsInSyncOperation
(
)
)
{
return
;
}
}
if
(
MOZ_UNLIKELY
(
mIsGrantingActivityGracePeriod
)
&
&
ShouldStopActivityGracePeriod
(
)
)
{
mIsGrantingActivityGracePeriod
=
false
;
UpdateThrottledState
(
)
;
}
AUTO_PROFILER_LABEL_RELEVANT_FOR_JS
(
"
RefreshDriver
tick
"
LAYOUT
)
;
nsAutoCString
profilerStr
;
if
(
profiler_thread_is_being_profiled_for_markers
(
)
)
{
profilerStr
.
AppendLiteral
(
"
Tick
reasons
:
"
)
;
AppendTickReasonsToString
(
tickReasons
profilerStr
)
;
}
AUTO_PROFILER_MARKER_TEXT
(
"
RefreshDriverTick
"
GRAPHICS
MarkerOptions
(
MarkerStack
:
:
TakeBacktrace
(
std
:
:
move
(
mRefreshTimerStartedCause
)
)
MarkerInnerWindowIdFromDocShell
(
GetDocShell
(
mPresContext
)
)
)
profilerStr
)
;
mResizeSuppressed
=
false
;
bool
oldInRefresh
=
mInRefresh
;
auto
restoreInRefresh
=
MakeScopeExit
(
[
&
]
{
mInRefresh
=
oldInRefresh
;
}
)
;
mInRefresh
=
true
;
AutoRestore
<
TimeStamp
>
restoreTickStart
(
mTickStart
)
;
mTickStart
=
TimeStamp
:
:
Now
(
)
;
mTickVsyncId
=
aId
;
mTickVsyncTime
=
aNowTime
;
gfxPlatform
:
:
GetPlatform
(
)
-
>
SchedulePaintIfDeviceReset
(
)
;
FlushForceNotifyContentfulPaintPresContext
(
)
;
AutoTArray
<
nsCOMPtr
<
nsIRunnable
>
16
>
earlyRunners
=
std
:
:
move
(
mEarlyRunners
)
;
for
(
auto
&
runner
:
earlyRunners
)
{
runner
-
>
Run
(
)
;
if
(
!
mPresContext
|
|
!
mPresContext
-
>
GetPresShell
(
)
)
{
StopTimer
(
)
;
return
;
}
}
AutoTArray
<
RefPtr
<
PresShell
>
16
>
observers
;
observers
.
AppendElements
(
mResizeEventFlushObservers
)
;
for
(
RefPtr
<
PresShell
>
&
presShell
:
Reversed
(
observers
)
)
{
if
(
!
mPresContext
|
|
!
mPresContext
-
>
GetPresShell
(
)
)
{
StopTimer
(
)
;
return
;
}
if
(
!
mResizeEventFlushObservers
.
RemoveElement
(
presShell
)
)
{
continue
;
}
MOZ_KnownLive
(
presShell
)
-
>
FireResizeEvent
(
)
;
}
DispatchVisualViewportResizeEvents
(
)
;
double
phaseMetrics
[
MOZ_ARRAY_LENGTH
(
mObservers
)
]
=
{
0
.
0
}
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
mObservers
)
;
+
+
i
)
{
AutoRecordPhase
phaseRecord
(
&
phaseMetrics
[
i
]
)
;
for
(
RefPtr
<
nsARefreshObserver
>
obs
:
mObservers
[
i
]
.
EndLimitedRange
(
)
)
{
obs
-
>
WillRefresh
(
aNowTime
)
;
if
(
!
mPresContext
|
|
!
mPresContext
-
>
GetPresShell
(
)
)
{
StopTimer
(
)
;
return
;
}
}
if
(
i
=
=
1
)
{
nsAutoMicroTask
mt
;
ReduceAnimations
(
*
mPresContext
-
>
Document
(
)
)
;
}
if
(
i
=
=
1
&
&
(
!
mPresContext
|
|
!
mPresContext
-
>
GetPresShell
(
)
)
)
{
StopTimer
(
)
;
return
;
}
if
(
i
=
=
1
)
{
FlushAutoFocusDocuments
(
)
;
DispatchScrollEvents
(
)
;
DispatchVisualViewportScrollEvents
(
)
;
DispatchAnimationEvents
(
)
;
RunFullscreenSteps
(
)
;
RunFrameRequestCallbacks
(
aNowTime
)
;
if
(
mPresContext
&
&
mPresContext
-
>
GetPresShell
(
)
)
{
AutoTArray
<
PresShell
*
16
>
observers
;
observers
.
AppendElements
(
mStyleFlushObservers
)
;
for
(
uint32_t
j
=
observers
.
Length
(
)
;
j
&
&
mPresContext
&
&
mPresContext
-
>
GetPresShell
(
)
;
-
-
j
)
{
PresShell
*
rawPresShell
=
observers
[
j
-
1
]
;
if
(
!
mStyleFlushObservers
.
RemoveElement
(
rawPresShell
)
)
{
continue
;
}
LogPresShellObserver
:
:
Run
run
(
rawPresShell
this
)
;
RefPtr
<
PresShell
>
presShell
=
rawPresShell
;
presShell
-
>
mObservingStyleFlushes
=
false
;
presShell
-
>
FlushPendingNotifications
(
ChangesToFlush
(
FlushType
:
:
Style
false
)
)
;
presShell
-
>
NotifyFontFaceSetOnRefresh
(
)
;
mNeedToRecomputeVisibility
=
true
;
presShell
-
>
PingPerTickTelemetry
(
FlushType
:
:
Style
)
;
}
}
}
else
if
(
i
=
=
2
)
{
AutoTArray
<
PresShell
*
16
>
observers
;
observers
.
AppendElements
(
mLayoutFlushObservers
)
;
for
(
uint32_t
j
=
observers
.
Length
(
)
;
j
&
&
mPresContext
&
&
mPresContext
-
>
GetPresShell
(
)
;
-
-
j
)
{
PresShell
*
rawPresShell
=
observers
[
j
-
1
]
;
if
(
!
mLayoutFlushObservers
.
RemoveElement
(
rawPresShell
)
)
{
continue
;
}
LogPresShellObserver
:
:
Run
run
(
rawPresShell
this
)
;
RefPtr
<
PresShell
>
presShell
=
rawPresShell
;
presShell
-
>
mObservingLayoutFlushes
=
false
;
presShell
-
>
mWasLastReflowInterrupted
=
false
;
const
auto
flushType
=
HasPendingAnimations
(
presShell
)
?
FlushType
:
:
Layout
:
FlushType
:
:
InterruptibleLayout
;
const
ChangesToFlush
ctf
(
flushType
false
)
;
presShell
-
>
FlushPendingNotifications
(
ctf
)
;
if
(
presShell
-
>
FixUpFocus
(
)
)
{
presShell
-
>
FlushPendingNotifications
(
ctf
)
;
}
presShell
-
>
NotifyFontFaceSetOnRefresh
(
)
;
mNeedToRecomputeVisibility
=
true
;
presShell
-
>
PingPerTickTelemetry
(
FlushType
:
:
Layout
)
;
}
}
if
(
!
mPresContext
|
|
!
mPresContext
-
>
GetPresShell
(
)
)
{
StopTimer
(
)
;
return
;
}
}
if
(
mNeedToRecomputeVisibility
&
&
!
mThrottled
&
&
aNowTime
>
=
mNextRecomputeVisibilityTick
&
&
!
presShell
-
>
IsPaintingSuppressed
(
)
)
{
mNextRecomputeVisibilityTick
=
aNowTime
+
mMinRecomputeVisibilityInterval
;
mNeedToRecomputeVisibility
=
false
;
presShell
-
>
ScheduleApproximateFrameVisibilityUpdateNow
(
)
;
}
if
(
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
)
{
pm
-
>
UpdatePopupPositions
(
this
)
;
}
UpdateRelevancyOfContentVisibilityAutoFrames
(
)
;
UpdateIntersectionObservations
(
aNowTime
)
;
for
(
const
auto
&
entry
:
mStartTable
)
{
const
uint32_t
&
delay
=
entry
.
GetKey
(
)
;
ImageStartData
*
data
=
entry
.
GetWeak
(
)
;
if
(
data
-
>
mEntries
.
IsEmpty
(
)
)
{
continue
;
}
if
(
data
-
>
mStartTime
)
{
TimeStamp
&
start
=
*
data
-
>
mStartTime
;
if
(
previousRefresh
>
=
start
&
&
aNowTime
>
=
start
)
{
TimeDuration
prev
=
previousRefresh
-
start
;
TimeDuration
curr
=
aNowTime
-
start
;
uint32_t
prevMultiple
=
uint32_t
(
prev
.
ToMilliseconds
(
)
)
/
delay
;
if
(
prevMultiple
!
=
uint32_t
(
curr
.
ToMilliseconds
(
)
)
/
delay
)
{
mozilla
:
:
TimeStamp
desired
=
start
+
TimeDuration
:
:
FromMilliseconds
(
prevMultiple
*
delay
)
;
BeginRefreshingImages
(
data
-
>
mEntries
desired
)
;
}
}
else
{
mozilla
:
:
TimeStamp
desired
=
start
;
BeginRefreshingImages
(
data
-
>
mEntries
desired
)
;
}
}
else
{
mozilla
:
:
TimeStamp
desired
=
aNowTime
;
BeginRefreshingImages
(
data
-
>
mEntries
desired
)
;
data
-
>
mStartTime
.
emplace
(
aNowTime
)
;
}
}
if
(
!
mRequests
.
IsEmpty
(
)
)
{
nsTArray
<
nsCOMPtr
<
imgIContainer
>
>
imagesToRefresh
(
mRequests
.
Count
(
)
)
;
for
(
const
auto
&
req
:
mRequests
)
{
nsCOMPtr
<
imgIContainer
>
image
;
if
(
NS_SUCCEEDED
(
req
-
>
GetImage
(
getter_AddRefs
(
image
)
)
)
)
{
imagesToRefresh
.
AppendElement
(
image
.
forget
(
)
)
;
}
}
for
(
const
auto
&
image
:
imagesToRefresh
)
{
image
-
>
RequestRefresh
(
aNowTime
)
;
}
}
double
phasePaint
=
0
.
0
;
bool
dispatchTasksAfterTick
=
false
;
if
(
mViewManagerFlushIsPending
)
{
AutoRecordPhase
paintRecord
(
&
phasePaint
)
;
nsCString
transactionId
;
if
(
profiler_thread_is_being_profiled_for_markers
(
)
)
{
transactionId
.
AppendLiteral
(
"
Transaction
ID
:
"
)
;
transactionId
.
AppendInt
(
(
uint64_t
)
mNextTransactionId
)
;
}
AUTO_PROFILER_MARKER_TEXT
(
"
ViewManagerFlush
"
GRAPHICS
MarkerOptions
(
MarkerInnerWindowIdFromDocShell
(
GetDocShell
(
mPresContext
)
)
MarkerStack
:
:
TakeBacktrace
(
std
:
:
move
(
mViewManagerFlushCause
)
)
)
transactionId
)
;
if
(
!
mCompositionPayloads
.
IsEmpty
(
)
)
{
nsCOMPtr
<
nsIWidget
>
widget
=
mPresContext
-
>
GetRootWidget
(
)
;
WindowRenderer
*
renderer
=
widget
?
widget
-
>
GetWindowRenderer
(
)
:
nullptr
;
if
(
renderer
&
&
renderer
-
>
AsWebRender
(
)
)
{
renderer
-
>
AsWebRender
(
)
-
>
RegisterPayloads
(
mCompositionPayloads
)
;
}
mCompositionPayloads
.
Clear
(
)
;
}
nsTArray
<
nsDocShell
*
>
profilingDocShells
;
GetProfileTimelineSubDocShells
(
GetDocShell
(
mPresContext
)
profilingDocShells
)
;
for
(
nsDocShell
*
docShell
:
profilingDocShells
)
{
MOZ_ASSERT
(
TimelineConsumers
:
:
HasConsumer
(
docShell
)
)
;
TimelineConsumers
:
:
AddMarkerForDocShell
(
docShell
"
Paint
"
MarkerTracingType
:
:
START
)
;
}
#
ifdef
MOZ_DUMP_PAINTING
if
(
nsLayoutUtils
:
:
InvalidationDebuggingIsEnabled
(
)
)
{
printf_stderr
(
"
Starting
ProcessPendingUpdates
\
n
"
)
;
}
#
endif
mViewManagerFlushIsPending
=
false
;
RefPtr
<
nsViewManager
>
vm
=
mPresContext
-
>
GetPresShell
(
)
-
>
GetViewManager
(
)
;
const
bool
skipPaint
=
isPresentingInVR
;
if
(
!
skipPaint
)
{
PaintTelemetry
:
:
AutoRecordPaint
record
;
vm
-
>
ProcessPendingUpdates
(
)
;
}
#
ifdef
MOZ_DUMP_PAINTING
if
(
nsLayoutUtils
:
:
InvalidationDebuggingIsEnabled
(
)
)
{
printf_stderr
(
"
Ending
ProcessPendingUpdates
\
n
"
)
;
}
#
endif
for
(
nsDocShell
*
docShell
:
profilingDocShells
)
{
MOZ_ASSERT
(
TimelineConsumers
:
:
HasConsumer
(
docShell
)
)
;
TimelineConsumers
:
:
AddMarkerForDocShell
(
docShell
"
Paint
"
MarkerTracingType
:
:
END
)
;
}
dispatchTasksAfterTick
=
true
;
mHasScheduleFlush
=
false
;
}
else
{
mCompositionPayloads
.
Clear
(
)
;
}
double
totalMs
=
(
TimeStamp
:
:
Now
(
)
-
mTickStart
)
.
ToMilliseconds
(
)
;
#
ifndef
ANDROID
mozilla
:
:
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
REFRESH_DRIVER_TICK
static_cast
<
uint32_t
>
(
totalMs
)
)
;
#
endif
if
(
totalMs
>
1000
.
0
/
60
.
0
)
{
auto
record
=
[
=
]
(
const
nsCString
&
aKey
double
aDurationMs
)
-
>
void
{
MOZ_ASSERT
(
aDurationMs
<
=
totalMs
)
;
auto
phasePercent
=
static_cast
<
uint32_t
>
(
aDurationMs
*
100
.
0
/
totalMs
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
REFRESH_DRIVER_TICK_PHASE_WEIGHT
aKey
phasePercent
)
;
}
;
record
(
"
Event
"
_ns
phaseMetrics
[
0
]
)
;
record
(
"
Style
"
_ns
phaseMetrics
[
1
]
)
;
record
(
"
Reflow
"
_ns
phaseMetrics
[
2
]
)
;
record
(
"
Display
"
_ns
phaseMetrics
[
3
]
)
;
record
(
"
Paint
"
_ns
phasePaint
)
;
double
other
=
totalMs
-
std
:
:
accumulate
(
phaseMetrics
ArrayEnd
(
phaseMetrics
)
0
.
0
)
-
phasePaint
;
record
(
"
Other
"
_ns
other
)
;
}
if
(
mNotifyDOMContentFlushed
)
{
mNotifyDOMContentFlushed
=
false
;
mPresContext
-
>
NotifyDOMContentFlushed
(
)
;
}
for
(
nsAPostRefreshObserver
*
observer
:
mPostRefreshObservers
.
ForwardRange
(
)
)
{
observer
-
>
DidRefresh
(
)
;
}
NS_ASSERTION
(
mInRefresh
"
Still
in
refresh
"
)
;
if
(
mPresContext
-
>
IsRoot
(
)
&
&
XRE_IsContentProcess
(
)
&
&
StaticPrefs
:
:
gfx_content_always_paint
(
)
)
{
ScheduleViewManagerFlush
(
)
;
}
if
(
dispatchTasksAfterTick
&
&
sPendingIdleTasks
)
{
UniquePtr
<
AutoTArray
<
RefPtr
<
Task
>
8
>
>
tasks
(
sPendingIdleTasks
.
forget
(
)
)
;
for
(
RefPtr
<
Task
>
&
taskWithDelay
:
*
tasks
)
{
TaskController
:
:
Get
(
)
-
>
AddTask
(
taskWithDelay
.
forget
(
)
)
;
}
}
}
void
nsRefreshDriver
:
:
BeginRefreshingImages
(
RequestTable
&
aEntries
mozilla
:
:
TimeStamp
aDesired
)
{
for
(
const
auto
&
req
:
aEntries
)
{
mRequests
.
Insert
(
req
)
;
nsCOMPtr
<
imgIContainer
>
image
;
if
(
NS_SUCCEEDED
(
req
-
>
GetImage
(
getter_AddRefs
(
image
)
)
)
)
{
image
-
>
SetAnimationStartTime
(
aDesired
)
;
}
}
aEntries
.
Clear
(
)
;
}
void
nsRefreshDriver
:
:
Freeze
(
)
{
StopTimer
(
)
;
mFreezeCount
+
+
;
}
void
nsRefreshDriver
:
:
Thaw
(
)
{
NS_ASSERTION
(
mFreezeCount
>
0
"
Thaw
(
)
called
on
an
unfrozen
refresh
driver
"
)
;
if
(
mFreezeCount
>
0
)
{
mFreezeCount
-
-
;
}
if
(
mFreezeCount
=
=
0
)
{
if
(
HasObservers
(
)
|
|
HasImageRequests
(
)
)
{
RefPtr
<
nsRunnableMethod
<
nsRefreshDriver
>
>
event
=
NewRunnableMethod
(
"
nsRefreshDriver
:
:
DoRefresh
"
this
&
nsRefreshDriver
:
:
DoRefresh
)
;
nsPresContext
*
pc
=
GetPresContext
(
)
;
if
(
pc
)
{
pc
-
>
Document
(
)
-
>
Dispatch
(
TaskCategory
:
:
Other
event
.
forget
(
)
)
;
EnsureTimerStarted
(
)
;
}
else
{
NS_ERROR
(
"
Thawing
while
document
is
being
destroyed
"
)
;
}
}
}
}
void
nsRefreshDriver
:
:
FinishedWaitingForTransaction
(
)
{
if
(
mSkippedPaints
&
&
!
IsInRefresh
(
)
&
&
(
HasObservers
(
)
|
|
HasImageRequests
(
)
)
&
&
CanDoCatchUpTick
(
)
)
{
NS_DispatchToCurrentThreadQueue
(
NS_NewRunnableFunction
(
"
nsRefreshDriver
:
:
FinishedWaitingForTransaction
"
[
self
=
RefPtr
{
this
}
]
(
)
{
if
(
self
-
>
CanDoCatchUpTick
(
)
)
{
self
-
>
Tick
(
self
-
>
mActiveTimer
-
>
MostRecentRefreshVsyncId
(
)
self
-
>
mActiveTimer
-
>
MostRecentRefresh
(
)
)
;
}
}
)
EventQueuePriority
:
:
Vsync
)
;
}
mWaitingForTransaction
=
false
;
mSkippedPaints
=
false
;
}
mozilla
:
:
layers
:
:
TransactionId
nsRefreshDriver
:
:
GetTransactionId
(
bool
aThrottle
)
{
mNextTransactionId
=
mNextTransactionId
.
Next
(
)
;
LOG
(
"
[
%
p
]
Allocating
transaction
id
%
"
PRIu64
this
mNextTransactionId
.
mId
)
;
if
(
aThrottle
&
&
mInNormalTick
)
{
mPendingTransactions
.
AppendElement
(
mNextTransactionId
)
;
if
(
TooManyPendingTransactions
(
)
&
&
!
mWaitingForTransaction
&
&
!
mTestControllingRefreshes
)
{
LOG
(
"
[
%
p
]
Hit
max
pending
transaction
limit
entering
wait
mode
"
this
)
;
mWaitingForTransaction
=
true
;
mSkippedPaints
=
false
;
}
}
return
mNextTransactionId
;
}
mozilla
:
:
layers
:
:
TransactionId
nsRefreshDriver
:
:
LastTransactionId
(
)
const
{
return
mNextTransactionId
;
}
void
nsRefreshDriver
:
:
RevokeTransactionId
(
mozilla
:
:
layers
:
:
TransactionId
aTransactionId
)
{
MOZ_ASSERT
(
aTransactionId
=
=
mNextTransactionId
)
;
LOG
(
"
[
%
p
]
Revoking
transaction
id
%
"
PRIu64
this
aTransactionId
.
mId
)
;
if
(
AtPendingTransactionLimit
(
)
&
&
mPendingTransactions
.
Contains
(
aTransactionId
)
&
&
mWaitingForTransaction
)
{
LOG
(
"
[
%
p
]
No
longer
over
pending
transaction
limit
leaving
wait
state
"
this
)
;
MOZ_ASSERT
(
!
mSkippedPaints
"
How
did
we
skip
a
paint
when
we
'
re
in
the
middle
of
one
?
"
)
;
FinishedWaitingForTransaction
(
)
;
}
nsPresContext
*
pc
=
GetPresContext
(
)
;
if
(
pc
)
{
pc
-
>
NotifyRevokingDidPaint
(
aTransactionId
)
;
}
mPendingTransactions
.
RemoveElement
(
aTransactionId
)
;
}
void
nsRefreshDriver
:
:
ClearPendingTransactions
(
)
{
LOG
(
"
[
%
p
]
ClearPendingTransactions
"
this
)
;
mPendingTransactions
.
Clear
(
)
;
mWaitingForTransaction
=
false
;
}
void
nsRefreshDriver
:
:
ResetInitialTransactionId
(
mozilla
:
:
layers
:
:
TransactionId
aTransactionId
)
{
mNextTransactionId
=
aTransactionId
;
}
mozilla
:
:
TimeStamp
nsRefreshDriver
:
:
GetTransactionStart
(
)
{
return
mTickStart
;
}
VsyncId
nsRefreshDriver
:
:
GetVsyncId
(
)
{
return
mTickVsyncId
;
}
mozilla
:
:
TimeStamp
nsRefreshDriver
:
:
GetVsyncStart
(
)
{
return
mTickVsyncTime
;
}
void
nsRefreshDriver
:
:
NotifyTransactionCompleted
(
mozilla
:
:
layers
:
:
TransactionId
aTransactionId
)
{
LOG
(
"
[
%
p
]
Completed
transaction
id
%
"
PRIu64
this
aTransactionId
.
mId
)
;
mPendingTransactions
.
RemoveElement
(
aTransactionId
)
;
if
(
mWaitingForTransaction
&
&
!
TooManyPendingTransactions
(
)
)
{
LOG
(
"
[
%
p
]
No
longer
over
pending
transaction
limit
leaving
wait
state
"
this
)
;
FinishedWaitingForTransaction
(
)
;
}
}
void
nsRefreshDriver
:
:
WillRefresh
(
mozilla
:
:
TimeStamp
aTime
)
{
mRootRefresh
-
>
RemoveRefreshObserver
(
this
FlushType
:
:
Style
)
;
mRootRefresh
=
nullptr
;
if
(
mSkippedPaints
)
{
DoRefresh
(
)
;
}
}
bool
nsRefreshDriver
:
:
IsWaitingForPaint
(
mozilla
:
:
TimeStamp
aTime
)
{
if
(
mTestControllingRefreshes
)
{
return
false
;
}
if
(
mWaitingForTransaction
)
{
LOG
(
"
[
%
p
]
Over
max
pending
transaction
limit
when
trying
to
paint
"
"
skipping
"
this
)
;
mSkippedPaints
=
true
;
return
true
;
}
nsPresContext
*
pc
=
GetPresContext
(
)
;
nsPresContext
*
rootContext
=
pc
?
pc
-
>
GetRootPresContext
(
)
:
nullptr
;
if
(
rootContext
)
{
nsRefreshDriver
*
rootRefresh
=
rootContext
-
>
RefreshDriver
(
)
;
if
(
rootRefresh
&
&
rootRefresh
!
=
this
)
{
if
(
rootRefresh
-
>
IsWaitingForPaint
(
aTime
)
)
{
if
(
mRootRefresh
!
=
rootRefresh
)
{
if
(
mRootRefresh
)
{
mRootRefresh
-
>
RemoveRefreshObserver
(
this
FlushType
:
:
Style
)
;
}
rootRefresh
-
>
AddRefreshObserver
(
this
FlushType
:
:
Style
"
Waiting
for
paint
"
)
;
mRootRefresh
=
rootRefresh
;
}
mSkippedPaints
=
true
;
return
true
;
}
}
}
return
false
;
}
void
nsRefreshDriver
:
:
SetActivity
(
bool
aIsActive
bool
aIsInActiveTab
)
{
if
(
mIsActive
=
=
aIsActive
&
&
mIsInActiveTab
=
=
aIsInActiveTab
)
{
return
;
}
mIsActive
=
aIsActive
;
mIsInActiveTab
=
aIsInActiveTab
;
if
(
!
mHasGrantedActivityGracePeriod
&
&
!
mIsActive
&
&
mIsInActiveTab
&
&
mPresContext
&
&
!
mPresContext
-
>
IsRootContentDocumentCrossProcess
(
)
)
{
mHasGrantedActivityGracePeriod
=
true
;
mIsGrantingActivityGracePeriod
=
StaticPrefs
:
:
layout_oopif_activity_grace_period_ms
(
)
>
0
;
if
(
mIsGrantingActivityGracePeriod
)
{
mActivityGracePeriodStart
=
TimeStamp
:
:
Now
(
)
;
}
}
UpdateThrottledState
(
)
;
}
void
nsRefreshDriver
:
:
UpdateThrottledState
(
)
{
const
bool
shouldThrottle
=
ComputeShouldBeThrottled
(
)
;
if
(
mThrottled
=
=
shouldThrottle
)
{
return
;
}
mThrottled
=
shouldThrottle
;
if
(
mActiveTimer
)
{
EnsureTimerStarted
(
eForceAdjustTimer
)
;
}
}
nsPresContext
*
nsRefreshDriver
:
:
GetPresContext
(
)
const
{
return
mPresContext
;
}
void
nsRefreshDriver
:
:
DoRefresh
(
)
{
if
(
!
IsFrozen
(
)
&
&
mPresContext
&
&
mActiveTimer
)
{
DoTick
(
)
;
}
}
#
ifdef
DEBUG
bool
nsRefreshDriver
:
:
IsRefreshObserver
(
nsARefreshObserver
*
aObserver
FlushType
aFlushType
)
{
ObserverArray
&
array
=
ArrayFor
(
aFlushType
)
;
return
array
.
Contains
(
aObserver
)
;
}
#
endif
void
nsRefreshDriver
:
:
ScheduleViewManagerFlush
(
)
{
NS_ASSERTION
(
mPresContext
-
>
IsRoot
(
)
"
Should
only
schedule
view
manager
flush
on
root
prescontexts
"
)
;
mViewManagerFlushIsPending
=
true
;
if
(
!
mViewManagerFlushCause
)
{
mViewManagerFlushCause
=
profiler_capture_backtrace
(
)
;
}
mHasScheduleFlush
=
true
;
EnsureTimerStarted
(
eNeverAdjustTimer
)
;
}
void
nsRefreshDriver
:
:
ScheduleFrameRequestCallbacks
(
Document
*
aDocument
)
{
NS_ASSERTION
(
mFrameRequestCallbackDocs
.
IndexOf
(
aDocument
)
=
=
mFrameRequestCallbackDocs
.
NoIndex
&
&
mThrottledFrameRequestCallbackDocs
.
IndexOf
(
aDocument
)
=
=
mThrottledFrameRequestCallbackDocs
.
NoIndex
"
Don
'
t
schedule
the
same
document
multiple
times
"
)
;
if
(
aDocument
-
>
ShouldThrottleFrameRequests
(
)
)
{
mThrottledFrameRequestCallbackDocs
.
AppendElement
(
aDocument
)
;
}
else
{
mFrameRequestCallbackDocs
.
AppendElement
(
aDocument
)
;
}
EnsureTimerStarted
(
)
;
}
void
nsRefreshDriver
:
:
RevokeFrameRequestCallbacks
(
Document
*
aDocument
)
{
mFrameRequestCallbackDocs
.
RemoveElement
(
aDocument
)
;
mThrottledFrameRequestCallbackDocs
.
RemoveElement
(
aDocument
)
;
}
void
nsRefreshDriver
:
:
ScheduleFullscreenEvent
(
UniquePtr
<
PendingFullscreenEvent
>
aEvent
)
{
mPendingFullscreenEvents
.
AppendElement
(
std
:
:
move
(
aEvent
)
)
;
EnsureTimerStarted
(
)
;
}
void
nsRefreshDriver
:
:
CancelPendingFullscreenEvents
(
Document
*
aDocument
)
{
for
(
auto
i
:
Reversed
(
IntegerRange
(
mPendingFullscreenEvents
.
Length
(
)
)
)
)
{
if
(
mPendingFullscreenEvents
[
i
]
-
>
Document
(
)
=
=
aDocument
)
{
mPendingFullscreenEvents
.
RemoveElementAt
(
i
)
;
}
}
}
void
nsRefreshDriver
:
:
CancelPendingAnimationEvents
(
AnimationEventDispatcher
*
aDispatcher
)
{
MOZ_ASSERT
(
aDispatcher
)
;
aDispatcher
-
>
ClearEventQueue
(
)
;
mAnimationEventFlushObservers
.
RemoveElement
(
aDispatcher
)
;
}
TimeStamp
nsRefreshDriver
:
:
GetIdleDeadlineHint
(
TimeStamp
aDefault
IdleCheck
aCheckType
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
aDefault
.
IsNull
(
)
)
;
if
(
sRegularRateTimer
)
{
TimeStamp
retVal
=
sRegularRateTimer
-
>
GetIdleDeadlineHint
(
aDefault
)
;
if
(
retVal
!
=
aDefault
)
{
return
retVal
;
}
}
TimeStamp
hint
=
TimeStamp
(
)
;
if
(
sRegularRateTimerList
)
{
for
(
RefreshDriverTimer
*
timer
:
*
sRegularRateTimerList
)
{
TimeStamp
newHint
=
timer
-
>
GetIdleDeadlineHint
(
aDefault
)
;
if
(
newHint
<
aDefault
&
&
(
hint
.
IsNull
(
)
|
|
newHint
<
hint
)
)
{
hint
=
newHint
;
}
}
}
if
(
!
hint
.
IsNull
(
)
)
{
return
hint
;
}
if
(
aCheckType
=
=
IdleCheck
:
:
AllVsyncListeners
&
&
XRE_IsParentProcess
(
)
)
{
Maybe
<
TimeDuration
>
maybeRate
=
mozilla
:
:
gfx
:
:
VsyncSource
:
:
GetFastestVsyncRate
(
)
;
if
(
maybeRate
.
isSome
(
)
)
{
TimeDuration
minIdlePeriod
=
TimeDuration
:
:
FromMilliseconds
(
StaticPrefs
:
:
idle_period_min
(
)
)
;
TimeDuration
layoutIdleLimit
=
TimeDuration
:
:
FromMilliseconds
(
StaticPrefs
:
:
layout_idle_period_time_limit
(
)
)
;
TimeDuration
rate
=
*
maybeRate
-
layoutIdleLimit
;
rate
=
std
:
:
max
(
rate
minIdlePeriod
+
minIdlePeriod
)
;
TimeStamp
newHint
=
TimeStamp
:
:
Now
(
)
+
rate
;
if
(
newHint
<
aDefault
)
{
return
newHint
;
}
}
}
return
aDefault
;
}
Maybe
<
TimeStamp
>
nsRefreshDriver
:
:
GetNextTickHint
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
sRegularRateTimer
)
{
return
sRegularRateTimer
-
>
GetNextTickHint
(
)
;
}
Maybe
<
TimeStamp
>
hint
=
Nothing
(
)
;
if
(
sRegularRateTimerList
)
{
for
(
RefreshDriverTimer
*
timer
:
*
sRegularRateTimerList
)
{
if
(
Maybe
<
TimeStamp
>
newHint
=
timer
-
>
GetNextTickHint
(
)
)
{
if
(
!
hint
|
|
newHint
.
value
(
)
<
hint
.
value
(
)
)
{
hint
=
newHint
;
}
}
}
}
return
hint
;
}
bool
nsRefreshDriver
:
:
IsRegularRateTimerTicking
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
sRegularRateTimer
)
{
if
(
sRegularRateTimer
-
>
IsTicking
(
)
)
{
return
true
;
}
}
if
(
sRegularRateTimerList
)
{
for
(
RefreshDriverTimer
*
timer
:
*
sRegularRateTimerList
)
{
if
(
timer
-
>
IsTicking
(
)
)
{
return
true
;
}
}
}
return
false
;
}
void
nsRefreshDriver
:
:
Disconnect
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
StopTimer
(
)
;
mEarlyRunners
.
Clear
(
)
;
if
(
mPresContext
)
{
mPresContext
=
nullptr
;
if
(
-
-
sRefreshDriverCount
=
=
0
)
{
Shutdown
(
)
;
}
}
}
#
undef
LOG
