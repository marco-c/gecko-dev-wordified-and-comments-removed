#
include
"
nsRefreshDriver
.
h
"
#
ifdef
XP_WIN
#
include
<
windows
.
h
>
#
include
<
mmsystem
.
h
>
#
include
"
WinUtils
.
h
"
#
endif
#
include
"
mozilla
/
AnimationEventDispatcher
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
dom
/
FontTableURIProtocolHandler
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsComponentManagerUtils
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
jsapi
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
mozilla
/
PendingAnimationTracker
.
h
"
#
include
"
mozilla
/
PendingFullscreenEvent
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
StaticPrefs
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
nsNPAPIPluginInstance
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
Performance
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
WindowBinding
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
Layers
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsISimpleEnumerator
.
h
"
#
include
"
nsJSEnvironment
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
BackgroundChild
.
h
"
#
include
"
mozilla
/
ipc
/
PBackgroundChild
.
h
"
#
include
"
mozilla
/
layout
/
VsyncChild
.
h
"
#
include
"
VsyncSource
.
h
"
#
include
"
mozilla
/
VsyncDispatcher
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
TimelineConsumers
.
h
"
#
include
"
nsAnimationManager
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsTransitionManager
.
h
"
#
ifdef
MOZ_XUL
#
include
"
nsXULPopupManager
.
h
"
#
endif
using
namespace
mozilla
;
using
namespace
mozilla
:
:
widget
;
using
namespace
mozilla
:
:
ipc
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
layout
;
static
mozilla
:
:
LazyLogModule
sRefreshDriverLog
(
"
nsRefreshDriver
"
)
;
#
define
LOG
(
.
.
.
)
\
MOZ_LOG
(
sRefreshDriverLog
mozilla
:
:
LogLevel
:
:
Debug
(
__VA_ARGS__
)
)
#
define
DEFAULT_THROTTLED_FRAME_RATE
1
#
define
DEFAULT_RECOMPUTE_VISIBILITY_INTERVAL_MS
1000
#
define
DEFAULT_NOTIFY_INTERSECTION_OBSERVERS_INTERVAL_MS
100
#
define
DEFAULT_INACTIVE_TIMER_DISABLE_SECONDS
600
#
if
defined
(
MOZ_ASAN
)
#
define
REFRESH_WAIT_WARNING
5
#
elif
defined
(
DEBUG
)
&
&
!
defined
(
MOZ_VALGRIND
)
#
define
REFRESH_WAIT_WARNING
5
#
elif
defined
(
DEBUG
)
&
&
defined
(
MOZ_VALGRIND
)
#
define
REFRESH_WAIT_WARNING
(
RUNNING_ON_VALGRIND
?
20
:
5
)
#
elif
defined
(
MOZ_VALGRIND
)
#
define
REFRESH_WAIT_WARNING
(
RUNNING_ON_VALGRIND
?
10
:
1
)
#
else
#
define
REFRESH_WAIT_WARNING
1
#
endif
namespace
{
static
uint64_t
sActiveVsyncTimers
=
0
;
uint64_t
sJankLevels
[
12
]
;
static
uint32_t
sRefreshDriverCount
=
0
;
}
namespace
mozilla
{
class
RefreshDriverTimer
{
public
:
RefreshDriverTimer
(
)
{
}
NS_INLINE_DECL_REFCOUNTING
(
RefreshDriverTimer
)
virtual
void
AddRefreshDriver
(
nsRefreshDriver
*
aDriver
)
{
LOG
(
"
[
%
p
]
AddRefreshDriver
%
p
"
this
aDriver
)
;
bool
startTimer
=
mContentRefreshDrivers
.
IsEmpty
(
)
&
&
mRootRefreshDrivers
.
IsEmpty
(
)
;
if
(
IsRootRefreshDriver
(
aDriver
)
)
{
NS_ASSERTION
(
!
mRootRefreshDrivers
.
Contains
(
aDriver
)
"
Adding
a
duplicate
root
refresh
driver
!
"
)
;
mRootRefreshDrivers
.
AppendElement
(
aDriver
)
;
}
else
{
NS_ASSERTION
(
!
mContentRefreshDrivers
.
Contains
(
aDriver
)
"
Adding
a
duplicate
content
refresh
driver
!
"
)
;
mContentRefreshDrivers
.
AppendElement
(
aDriver
)
;
}
if
(
startTimer
)
{
StartTimer
(
)
;
}
}
void
RemoveRefreshDriver
(
nsRefreshDriver
*
aDriver
)
{
LOG
(
"
[
%
p
]
RemoveRefreshDriver
%
p
"
this
aDriver
)
;
if
(
IsRootRefreshDriver
(
aDriver
)
)
{
NS_ASSERTION
(
mRootRefreshDrivers
.
Contains
(
aDriver
)
"
RemoveRefreshDriver
for
a
refresh
driver
that
'
s
not
in
the
"
"
root
refresh
list
!
"
)
;
mRootRefreshDrivers
.
RemoveElement
(
aDriver
)
;
}
else
{
nsPresContext
*
pc
=
aDriver
-
>
GetPresContext
(
)
;
nsPresContext
*
rootContext
=
pc
?
pc
-
>
GetRootPresContext
(
)
:
nullptr
;
if
(
!
rootContext
)
{
if
(
mRootRefreshDrivers
.
Contains
(
aDriver
)
)
{
mRootRefreshDrivers
.
RemoveElement
(
aDriver
)
;
}
else
{
NS_ASSERTION
(
mContentRefreshDrivers
.
Contains
(
aDriver
)
"
RemoveRefreshDriver
without
a
display
root
for
a
"
"
driver
that
is
not
in
the
content
refresh
list
"
)
;
mContentRefreshDrivers
.
RemoveElement
(
aDriver
)
;
}
}
else
{
NS_ASSERTION
(
mContentRefreshDrivers
.
Contains
(
aDriver
)
"
RemoveRefreshDriver
for
a
driver
that
is
not
in
the
"
"
content
refresh
list
"
)
;
mContentRefreshDrivers
.
RemoveElement
(
aDriver
)
;
}
}
bool
stopTimer
=
mContentRefreshDrivers
.
IsEmpty
(
)
&
&
mRootRefreshDrivers
.
IsEmpty
(
)
;
if
(
stopTimer
)
{
StopTimer
(
)
;
}
}
TimeStamp
MostRecentRefresh
(
)
const
{
return
mLastFireTime
;
}
void
SwapRefreshDrivers
(
RefreshDriverTimer
*
aNewTimer
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
for
(
nsRefreshDriver
*
driver
:
mContentRefreshDrivers
)
{
aNewTimer
-
>
AddRefreshDriver
(
driver
)
;
driver
-
>
mActiveTimer
=
aNewTimer
;
}
mContentRefreshDrivers
.
Clear
(
)
;
for
(
nsRefreshDriver
*
driver
:
mRootRefreshDrivers
)
{
aNewTimer
-
>
AddRefreshDriver
(
driver
)
;
driver
-
>
mActiveTimer
=
aNewTimer
;
}
mRootRefreshDrivers
.
Clear
(
)
;
aNewTimer
-
>
mLastFireTime
=
mLastFireTime
;
StopTimer
(
)
;
}
virtual
TimeDuration
GetTimerRate
(
)
=
0
;
TimeStamp
GetIdleDeadlineHint
(
TimeStamp
aDefault
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
TimeStamp
mostRecentRefresh
=
MostRecentRefresh
(
)
;
TimeDuration
refreshRate
=
GetTimerRate
(
)
;
TimeStamp
idleEnd
=
mostRecentRefresh
+
refreshRate
;
if
(
idleEnd
+
refreshRate
*
nsLayoutUtils
:
:
QuiescentFramesBeforeIdlePeriod
(
)
<
TimeStamp
:
:
Now
(
)
)
{
return
aDefault
;
}
idleEnd
=
idleEnd
-
TimeDuration
:
:
FromMilliseconds
(
nsLayoutUtils
:
:
IdlePeriodDeadlineLimit
(
)
)
;
return
idleEnd
<
aDefault
?
idleEnd
:
aDefault
;
}
Maybe
<
TimeStamp
>
GetNextTickHint
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
TimeStamp
nextTick
=
MostRecentRefresh
(
)
+
GetTimerRate
(
)
;
return
nextTick
<
TimeStamp
:
:
Now
(
)
?
Nothing
(
)
:
Some
(
nextTick
)
;
}
nsPresContext
*
GetPresContextForOnlyRefreshDriver
(
)
{
if
(
mRootRefreshDrivers
.
Length
(
)
=
=
1
&
&
mContentRefreshDrivers
.
IsEmpty
(
)
)
{
return
mRootRefreshDrivers
[
0
]
-
>
GetPresContext
(
)
;
}
if
(
mContentRefreshDrivers
.
Length
(
)
=
=
1
&
&
mRootRefreshDrivers
.
IsEmpty
(
)
)
{
return
mContentRefreshDrivers
[
0
]
-
>
GetPresContext
(
)
;
}
return
nullptr
;
}
protected
:
virtual
~
RefreshDriverTimer
(
)
{
MOZ_ASSERT
(
mContentRefreshDrivers
.
Length
(
)
=
=
0
"
Should
have
removed
all
content
refresh
drivers
from
here
by
now
!
"
)
;
MOZ_ASSERT
(
mRootRefreshDrivers
.
Length
(
)
=
=
0
"
Should
have
removed
all
root
refresh
drivers
from
here
by
now
!
"
)
;
}
virtual
void
StartTimer
(
)
=
0
;
virtual
void
StopTimer
(
)
=
0
;
virtual
void
ScheduleNextTick
(
TimeStamp
aNowTime
)
=
0
;
bool
IsRootRefreshDriver
(
nsRefreshDriver
*
aDriver
)
{
nsPresContext
*
pc
=
aDriver
-
>
GetPresContext
(
)
;
nsPresContext
*
rootContext
=
pc
?
pc
-
>
GetRootPresContext
(
)
:
nullptr
;
if
(
!
rootContext
)
{
return
false
;
}
return
aDriver
=
=
rootContext
-
>
RefreshDriver
(
)
;
}
void
Tick
(
)
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
Tick
(
VsyncId
(
)
now
)
;
}
void
TickRefreshDrivers
(
VsyncId
aId
TimeStamp
aNow
nsTArray
<
RefPtr
<
nsRefreshDriver
>
>
&
aDrivers
)
{
if
(
aDrivers
.
IsEmpty
(
)
)
{
return
;
}
nsTArray
<
RefPtr
<
nsRefreshDriver
>
>
drivers
(
aDrivers
)
;
for
(
nsRefreshDriver
*
driver
:
drivers
)
{
if
(
driver
-
>
IsTestControllingRefreshesEnabled
(
)
)
{
continue
;
}
TickDriver
(
driver
aId
aNow
)
;
}
}
void
Tick
(
VsyncId
aId
TimeStamp
now
)
{
ScheduleNextTick
(
now
)
;
mLastFireTime
=
now
;
LOG
(
"
[
%
p
]
ticking
drivers
.
.
.
"
this
)
;
AUTO_PROFILER_TRACING
(
"
Paint
"
"
RefreshDriverTick
"
GRAPHICS
)
;
TickRefreshDrivers
(
aId
now
mContentRefreshDrivers
)
;
TickRefreshDrivers
(
aId
now
mRootRefreshDrivers
)
;
LOG
(
"
[
%
p
]
done
.
"
this
)
;
}
static
void
TickDriver
(
nsRefreshDriver
*
driver
VsyncId
aId
TimeStamp
now
)
{
driver
-
>
Tick
(
aId
now
)
;
}
TimeStamp
mLastFireTime
;
TimeStamp
mTargetTime
;
nsTArray
<
RefPtr
<
nsRefreshDriver
>
>
mContentRefreshDrivers
;
nsTArray
<
RefPtr
<
nsRefreshDriver
>
>
mRootRefreshDrivers
;
static
void
TimerTick
(
nsITimer
*
aTimer
void
*
aClosure
)
{
RefPtr
<
RefreshDriverTimer
>
timer
=
static_cast
<
RefreshDriverTimer
*
>
(
aClosure
)
;
timer
-
>
Tick
(
)
;
}
}
;
class
SimpleTimerBasedRefreshDriverTimer
:
public
RefreshDriverTimer
{
public
:
explicit
SimpleTimerBasedRefreshDriverTimer
(
double
aRate
)
{
SetRate
(
aRate
)
;
mTimer
=
NS_NewTimer
(
)
;
}
virtual
~
SimpleTimerBasedRefreshDriverTimer
(
)
override
{
StopTimer
(
)
;
}
virtual
void
SetRate
(
double
aNewRate
)
{
mRateMilliseconds
=
aNewRate
;
mRateDuration
=
TimeDuration
:
:
FromMilliseconds
(
mRateMilliseconds
)
;
}
double
GetRate
(
)
const
{
return
mRateMilliseconds
;
}
TimeDuration
GetTimerRate
(
)
override
{
return
mRateDuration
;
}
protected
:
void
StartTimer
(
)
override
{
mLastFireTime
=
TimeStamp
:
:
Now
(
)
;
mTargetTime
=
mLastFireTime
+
mRateDuration
;
uint32_t
delay
=
static_cast
<
uint32_t
>
(
mRateMilliseconds
)
;
mTimer
-
>
InitWithNamedFuncCallback
(
TimerTick
this
delay
nsITimer
:
:
TYPE_ONE_SHOT
"
SimpleTimerBasedRefreshDriverTimer
:
:
StartTimer
"
)
;
}
void
StopTimer
(
)
override
{
mTimer
-
>
Cancel
(
)
;
}
double
mRateMilliseconds
;
TimeDuration
mRateDuration
;
RefPtr
<
nsITimer
>
mTimer
;
}
;
class
VsyncRefreshDriverTimer
:
public
RefreshDriverTimer
{
public
:
VsyncRefreshDriverTimer
(
)
:
mVsyncChild
(
nullptr
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mVsyncObserver
=
new
RefreshDriverVsyncObserver
(
this
)
;
RefPtr
<
mozilla
:
:
gfx
:
:
VsyncSource
>
vsyncSource
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
GetHardwareVsync
(
)
;
MOZ_ALWAYS_TRUE
(
mVsyncDispatcher
=
vsyncSource
-
>
GetRefreshTimerVsyncDispatcher
(
)
)
;
mVsyncDispatcher
-
>
SetParentRefreshTimer
(
mVsyncObserver
)
;
mVsyncRate
=
vsyncSource
-
>
GetGlobalDisplay
(
)
.
GetVsyncRate
(
)
;
}
explicit
VsyncRefreshDriverTimer
(
VsyncChild
*
aVsyncChild
)
:
mVsyncChild
(
aVsyncChild
)
{
MOZ_ASSERT
(
!
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mVsyncChild
)
;
mVsyncObserver
=
new
RefreshDriverVsyncObserver
(
this
)
;
mVsyncChild
-
>
SetVsyncObserver
(
mVsyncObserver
)
;
mVsyncRate
=
mVsyncChild
-
>
GetVsyncRate
(
)
;
}
TimeDuration
GetTimerRate
(
)
override
{
if
(
mVsyncRate
!
=
TimeDuration
:
:
Forever
(
)
)
{
return
mVsyncRate
;
}
if
(
mVsyncChild
)
{
mVsyncRate
=
mVsyncChild
-
>
VsyncRate
(
)
;
}
return
mVsyncRate
!
=
TimeDuration
:
:
Forever
(
)
?
mVsyncRate
:
TimeDuration
:
:
FromMilliseconds
(
1000
.
0
/
60
.
0
)
;
}
private
:
class
RefreshDriverVsyncObserver
final
:
public
VsyncObserver
{
public
:
explicit
RefreshDriverVsyncObserver
(
VsyncRefreshDriverTimer
*
aVsyncRefreshDriverTimer
)
:
mVsyncRefreshDriverTimer
(
aVsyncRefreshDriverTimer
)
mRefreshTickLock
(
"
RefreshTickLock
"
)
mRecentVsync
(
TimeStamp
:
:
Now
(
)
)
mLastChildTick
(
TimeStamp
:
:
Now
(
)
)
mVsyncRate
(
TimeDuration
:
:
Forever
(
)
)
mProcessedVsync
(
true
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
}
class
ParentProcessVsyncNotifier
final
:
public
Runnable
public
nsIRunnablePriority
{
public
:
ParentProcessVsyncNotifier
(
RefreshDriverVsyncObserver
*
aObserver
VsyncId
aId
TimeStamp
aVsyncTimestamp
)
:
Runnable
(
"
VsyncRefreshDriverTimer
:
:
RefreshDriverVsyncObserver
:
:
"
"
ParentProcessVsyncNotifier
"
)
mObserver
(
aObserver
)
mId
(
aId
)
mVsyncTimestamp
(
aVsyncTimestamp
)
{
}
NS_DECL_ISUPPORTS_INHERITED
NS_IMETHOD
Run
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
static
bool
sCacheInitialized
=
false
;
static
bool
sHighPriorityPrefValue
=
false
;
if
(
!
sCacheInitialized
)
{
sCacheInitialized
=
true
;
Preferences
:
:
AddBoolVarCache
(
&
sHighPriorityPrefValue
"
vsync
.
parentProcess
.
highPriority
"
mozilla
:
:
BrowserTabsRemoteAutostart
(
)
)
;
}
sHighPriorityEnabled
=
sHighPriorityPrefValue
;
mObserver
-
>
TickRefreshDriver
(
mId
mVsyncTimestamp
)
;
return
NS_OK
;
}
NS_IMETHOD
GetPriority
(
uint32_t
*
aPriority
)
override
{
*
aPriority
=
sHighPriorityEnabled
?
nsIRunnablePriority
:
:
PRIORITY_HIGH
:
nsIRunnablePriority
:
:
PRIORITY_NORMAL
;
return
NS_OK
;
}
private
:
~
ParentProcessVsyncNotifier
(
)
{
}
RefPtr
<
RefreshDriverVsyncObserver
>
mObserver
;
VsyncId
mId
;
TimeStamp
mVsyncTimestamp
;
static
mozilla
:
:
Atomic
<
bool
>
sHighPriorityEnabled
;
}
;
bool
NotifyVsync
(
const
VsyncEvent
&
aVsync
)
override
{
if
(
!
NS_IsMainThread
(
)
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
{
MonitorAutoLock
lock
(
mRefreshTickLock
)
;
mRecentVsync
=
aVsync
.
mTime
;
mRecentVsyncId
=
aVsync
.
mId
;
if
(
!
mProcessedVsync
)
{
return
true
;
}
mProcessedVsync
=
false
;
}
nsCOMPtr
<
nsIRunnable
>
vsyncEvent
=
new
ParentProcessVsyncNotifier
(
this
aVsync
.
mId
aVsync
.
mTime
)
;
NS_DispatchToMainThread
(
vsyncEvent
)
;
}
else
{
mRecentVsync
=
aVsync
.
mTime
;
mRecentVsyncId
=
aVsync
.
mId
;
if
(
!
mBlockUntil
.
IsNull
(
)
&
&
mBlockUntil
>
aVsync
.
mTime
)
{
if
(
mProcessedVsync
)
{
mProcessedVsync
=
false
;
nsCOMPtr
<
nsIRunnable
>
vsyncEvent
=
NewRunnableMethod
<
>
(
"
RefreshDriverVsyncObserver
:
:
NormalPriorityNotify
"
this
&
RefreshDriverVsyncObserver
:
:
NormalPriorityNotify
)
;
NS_DispatchToMainThread
(
vsyncEvent
)
;
}
return
true
;
}
if
(
StaticPrefs
:
:
layout_lower_priority_refresh_driver_during_load
(
)
)
{
nsPresContext
*
pctx
=
mVsyncRefreshDriverTimer
-
>
GetPresContextForOnlyRefreshDriver
(
)
;
if
(
pctx
&
&
pctx
-
>
HadContentfulPaint
(
)
&
&
pctx
-
>
Document
(
)
&
&
pctx
-
>
Document
(
)
-
>
GetReadyStateEnum
(
)
<
Document
:
:
READYSTATE_COMPLETE
)
{
nsPIDOMWindowInner
*
win
=
pctx
-
>
Document
(
)
-
>
GetInnerWindow
(
)
;
if
(
win
)
{
dom
:
:
Performance
*
perf
=
win
-
>
GetPerformance
(
)
;
if
(
perf
&
&
perf
-
>
Now
(
)
<
5000
)
{
if
(
mProcessedVsync
)
{
mProcessedVsync
=
false
;
TimeDuration
rate
=
mVsyncRefreshDriverTimer
-
>
GetTimerRate
(
)
;
uint32_t
slowRate
=
static_cast
<
uint32_t
>
(
rate
.
ToMilliseconds
(
)
*
4
)
;
nsCOMPtr
<
nsIRunnable
>
vsyncEvent
=
NewRunnableMethod
<
>
(
"
RefreshDriverVsyncObserver
:
:
NormalPriorityNotify
[
IDLE
]
"
this
&
RefreshDriverVsyncObserver
:
:
NormalPriorityNotify
)
;
NS_DispatchToCurrentThreadQueue
(
vsyncEvent
.
forget
(
)
slowRate
EventQueuePriority
:
:
Idle
)
;
}
return
true
;
}
}
}
}
RefPtr
<
RefreshDriverVsyncObserver
>
kungFuDeathGrip
(
this
)
;
TickRefreshDriver
(
aVsync
.
mId
aVsync
.
mTime
)
;
}
return
true
;
}
void
Shutdown
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mVsyncRefreshDriverTimer
=
nullptr
;
}
void
OnTimerStart
(
)
{
if
(
!
XRE_IsParentProcess
(
)
)
{
mLastChildTick
=
TimeStamp
:
:
Now
(
)
;
}
}
void
NormalPriorityNotify
(
)
{
if
(
mLastProcessedTickInChildProcess
.
IsNull
(
)
|
|
mRecentVsync
>
mLastProcessedTickInChildProcess
)
{
mBlockUntil
=
TimeStamp
(
)
;
TickRefreshDriver
(
mRecentVsyncId
mRecentVsync
)
;
}
mProcessedVsync
=
true
;
}
private
:
~
RefreshDriverVsyncObserver
(
)
=
default
;
void
RecordTelemetryProbes
(
TimeStamp
aVsyncTimestamp
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
#
ifndef
ANDROID
if
(
XRE_IsParentProcess
(
)
)
{
TimeDuration
vsyncLatency
=
TimeStamp
:
:
Now
(
)
-
aVsyncTimestamp
;
uint32_t
sample
=
(
uint32_t
)
vsyncLatency
.
ToMilliseconds
(
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
FX_REFRESH_DRIVER_CHROME_FRAME_DELAY_MS
sample
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
FX_REFRESH_DRIVER_SYNC_SCROLL_FRAME_DELAY_MS
sample
)
;
RecordJank
(
sample
)
;
}
else
if
(
mVsyncRate
!
=
TimeDuration
:
:
Forever
(
)
)
{
TimeDuration
contentDelay
=
(
TimeStamp
:
:
Now
(
)
-
mLastChildTick
)
-
mVsyncRate
;
if
(
contentDelay
.
ToMilliseconds
(
)
<
0
)
{
contentDelay
=
TimeDuration
:
:
FromMilliseconds
(
0
)
;
}
uint32_t
sample
=
(
uint32_t
)
contentDelay
.
ToMilliseconds
(
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
FX_REFRESH_DRIVER_CONTENT_FRAME_DELAY_MS
sample
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
FX_REFRESH_DRIVER_SYNC_SCROLL_FRAME_DELAY_MS
sample
)
;
RecordJank
(
sample
)
;
}
else
{
if
(
mVsyncRefreshDriverTimer
)
{
mVsyncRate
=
mVsyncRefreshDriverTimer
-
>
mVsyncChild
-
>
GetVsyncRate
(
)
;
}
}
#
endif
}
void
RecordJank
(
uint32_t
aJankMS
)
{
uint32_t
duration
=
1
;
for
(
size_t
i
=
0
;
i
<
mozilla
:
:
ArrayLength
(
sJankLevels
)
&
&
duration
<
aJankMS
;
+
+
i
duration
*
=
2
)
{
sJankLevels
[
i
]
+
+
;
}
}
void
TickRefreshDriver
(
VsyncId
aId
TimeStamp
aVsyncTimestamp
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
RecordTelemetryProbes
(
aVsyncTimestamp
)
;
if
(
XRE_IsParentProcess
(
)
)
{
MonitorAutoLock
lock
(
mRefreshTickLock
)
;
aVsyncTimestamp
=
mRecentVsync
;
mProcessedVsync
=
true
;
}
else
{
mLastChildTick
=
TimeStamp
:
:
Now
(
)
;
mLastProcessedTickInChildProcess
=
aVsyncTimestamp
;
}
DebugOnly
<
TimeStamp
>
rightnow
=
TimeStamp
:
:
Now
(
)
;
MOZ_ASSERT_IF
(
(
*
&
rightnow
)
.
UsedCanonicalNow
(
)
=
=
aVsyncTimestamp
.
UsedCanonicalNow
(
)
aVsyncTimestamp
<
=
*
&
rightnow
)
;
if
(
mVsyncRefreshDriverTimer
)
{
RefPtr
<
VsyncRefreshDriverTimer
>
timer
=
mVsyncRefreshDriverTimer
;
timer
-
>
RunRefreshDrivers
(
aId
aVsyncTimestamp
)
;
}
if
(
!
XRE_IsParentProcess
(
)
)
{
TimeDuration
tickDuration
=
TimeStamp
:
:
Now
(
)
-
mLastChildTick
;
mBlockUntil
=
aVsyncTimestamp
+
tickDuration
;
}
}
VsyncRefreshDriverTimer
*
mVsyncRefreshDriverTimer
;
Monitor
mRefreshTickLock
;
TimeStamp
mRecentVsync
;
VsyncId
mRecentVsyncId
;
TimeStamp
mLastChildTick
;
TimeStamp
mLastProcessedTickInChildProcess
;
TimeStamp
mBlockUntil
;
TimeDuration
mVsyncRate
;
bool
mProcessedVsync
;
}
;
~
VsyncRefreshDriverTimer
(
)
override
{
if
(
XRE_IsParentProcess
(
)
)
{
mVsyncDispatcher
-
>
SetParentRefreshTimer
(
nullptr
)
;
mVsyncDispatcher
=
nullptr
;
}
else
{
Unused
<
<
mVsyncChild
-
>
SendUnobserve
(
)
;
mVsyncChild
-
>
SetVsyncObserver
(
nullptr
)
;
mVsyncChild
=
nullptr
;
}
mVsyncObserver
-
>
Shutdown
(
)
;
mVsyncObserver
=
nullptr
;
}
void
StartTimer
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
mLastFireTime
=
TimeStamp
:
:
Now
(
)
;
if
(
XRE_IsParentProcess
(
)
)
{
mVsyncDispatcher
-
>
SetParentRefreshTimer
(
mVsyncObserver
)
;
}
else
{
Unused
<
<
mVsyncChild
-
>
SendObserve
(
)
;
mVsyncObserver
-
>
OnTimerStart
(
)
;
}
+
+
sActiveVsyncTimers
;
}
void
StopTimer
(
)
override
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
XRE_IsParentProcess
(
)
)
{
mVsyncDispatcher
-
>
SetParentRefreshTimer
(
nullptr
)
;
}
else
{
Unused
<
<
mVsyncChild
-
>
SendUnobserve
(
)
;
}
MOZ_ASSERT
(
sActiveVsyncTimers
>
0
)
;
-
-
sActiveVsyncTimers
;
}
void
ScheduleNextTick
(
TimeStamp
aNowTime
)
override
{
}
void
RunRefreshDrivers
(
VsyncId
aId
TimeStamp
aTimeStamp
)
{
Tick
(
aId
aTimeStamp
)
;
}
RefPtr
<
RefreshDriverVsyncObserver
>
mVsyncObserver
;
RefPtr
<
RefreshTimerVsyncDispatcher
>
mVsyncDispatcher
;
RefPtr
<
VsyncChild
>
mVsyncChild
;
TimeDuration
mVsyncRate
;
}
;
NS_IMPL_ISUPPORTS_INHERITED
(
VsyncRefreshDriverTimer
:
:
RefreshDriverVsyncObserver
:
:
ParentProcessVsyncNotifier
Runnable
nsIRunnablePriority
)
mozilla
:
:
Atomic
<
bool
>
VsyncRefreshDriverTimer
:
:
RefreshDriverVsyncObserver
:
:
ParentProcessVsyncNotifier
:
:
sHighPriorityEnabled
(
false
)
;
class
StartupRefreshDriverTimer
:
public
SimpleTimerBasedRefreshDriverTimer
{
public
:
explicit
StartupRefreshDriverTimer
(
double
aRate
)
:
SimpleTimerBasedRefreshDriverTimer
(
aRate
)
{
}
protected
:
void
ScheduleNextTick
(
TimeStamp
aNowTime
)
override
{
TimeStamp
newTarget
=
aNowTime
+
mRateDuration
;
uint32_t
delay
=
static_cast
<
uint32_t
>
(
(
newTarget
-
aNowTime
)
.
ToMilliseconds
(
)
)
;
mTimer
-
>
InitWithNamedFuncCallback
(
TimerTick
this
delay
nsITimer
:
:
TYPE_ONE_SHOT
"
StartupRefreshDriverTimer
:
:
ScheduleNextTick
"
)
;
mTargetTime
=
newTarget
;
}
}
;
class
InactiveRefreshDriverTimer
final
:
public
SimpleTimerBasedRefreshDriverTimer
{
public
:
explicit
InactiveRefreshDriverTimer
(
double
aRate
)
:
SimpleTimerBasedRefreshDriverTimer
(
aRate
)
mNextTickDuration
(
aRate
)
mDisableAfterMilliseconds
(
-
1
.
0
)
mNextDriverIndex
(
0
)
{
}
InactiveRefreshDriverTimer
(
double
aRate
double
aDisableAfterMilliseconds
)
:
SimpleTimerBasedRefreshDriverTimer
(
aRate
)
mNextTickDuration
(
aRate
)
mDisableAfterMilliseconds
(
aDisableAfterMilliseconds
)
mNextDriverIndex
(
0
)
{
}
void
AddRefreshDriver
(
nsRefreshDriver
*
aDriver
)
override
{
RefreshDriverTimer
:
:
AddRefreshDriver
(
aDriver
)
;
LOG
(
"
[
%
p
]
inactive
timer
got
new
refresh
driver
%
p
resetting
rate
"
this
aDriver
)
;
mNextTickDuration
=
mRateMilliseconds
;
mNextDriverIndex
=
GetRefreshDriverCount
(
)
-
1
;
StopTimer
(
)
;
StartTimer
(
)
;
}
TimeDuration
GetTimerRate
(
)
override
{
return
TimeDuration
:
:
FromMilliseconds
(
mNextTickDuration
)
;
}
protected
:
uint32_t
GetRefreshDriverCount
(
)
{
return
mContentRefreshDrivers
.
Length
(
)
+
mRootRefreshDrivers
.
Length
(
)
;
}
void
StartTimer
(
)
override
{
mLastFireTime
=
TimeStamp
:
:
Now
(
)
;
mTargetTime
=
mLastFireTime
+
mRateDuration
;
uint32_t
delay
=
static_cast
<
uint32_t
>
(
mRateMilliseconds
)
;
mTimer
-
>
InitWithNamedFuncCallback
(
TimerTickOne
this
delay
nsITimer
:
:
TYPE_ONE_SHOT
"
InactiveRefreshDriverTimer
:
:
StartTimer
"
)
;
}
void
StopTimer
(
)
override
{
mTimer
-
>
Cancel
(
)
;
}
void
ScheduleNextTick
(
TimeStamp
aNowTime
)
override
{
if
(
mDisableAfterMilliseconds
>
0
.
0
&
&
mNextTickDuration
>
mDisableAfterMilliseconds
)
{
return
;
}
if
(
mNextDriverIndex
>
=
GetRefreshDriverCount
(
)
)
{
mNextTickDuration
*
=
2
.
0
;
mNextDriverIndex
=
0
;
}
uint32_t
delay
=
static_cast
<
uint32_t
>
(
mNextTickDuration
)
;
mTimer
-
>
InitWithNamedFuncCallback
(
TimerTickOne
this
delay
nsITimer
:
:
TYPE_ONE_SHOT
"
InactiveRefreshDriverTimer
:
:
ScheduleNextTick
"
)
;
LOG
(
"
[
%
p
]
inactive
timer
next
tick
in
%
f
ms
[
index
%
d
/
%
d
]
"
this
mNextTickDuration
mNextDriverIndex
GetRefreshDriverCount
(
)
)
;
}
void
TickOne
(
)
{
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
ScheduleNextTick
(
now
)
;
mLastFireTime
=
now
;
nsTArray
<
RefPtr
<
nsRefreshDriver
>
>
drivers
(
mContentRefreshDrivers
)
;
drivers
.
AppendElements
(
mRootRefreshDrivers
)
;
size_t
index
=
mNextDriverIndex
;
if
(
index
<
drivers
.
Length
(
)
&
&
!
drivers
[
index
]
-
>
IsTestControllingRefreshesEnabled
(
)
)
{
TickDriver
(
drivers
[
index
]
VsyncId
(
)
now
)
;
}
mNextDriverIndex
+
+
;
}
static
void
TimerTickOne
(
nsITimer
*
aTimer
void
*
aClosure
)
{
RefPtr
<
InactiveRefreshDriverTimer
>
timer
=
static_cast
<
InactiveRefreshDriverTimer
*
>
(
aClosure
)
;
timer
-
>
TickOne
(
)
;
}
double
mNextTickDuration
;
double
mDisableAfterMilliseconds
;
uint32_t
mNextDriverIndex
;
}
;
}
static
StaticRefPtr
<
RefreshDriverTimer
>
sRegularRateTimer
;
static
StaticRefPtr
<
InactiveRefreshDriverTimer
>
sThrottledRateTimer
;
static
void
CreateContentVsyncRefreshTimer
(
void
*
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
XRE_IsParentProcess
(
)
)
;
PBackgroundChild
*
actorChild
=
BackgroundChild
:
:
GetOrCreateForCurrentThread
(
)
;
if
(
NS_WARN_IF
(
!
actorChild
)
)
{
return
;
}
layout
:
:
PVsyncChild
*
actor
=
actorChild
-
>
SendPVsyncConstructor
(
)
;
if
(
NS_WARN_IF
(
!
actor
)
)
{
return
;
}
layout
:
:
VsyncChild
*
child
=
static_cast
<
layout
:
:
VsyncChild
*
>
(
actor
)
;
nsRefreshDriver
:
:
PVsyncActorCreated
(
child
)
;
}
static
void
CreateVsyncRefreshTimer
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
PodArrayZero
(
sJankLevels
)
;
gfxPrefs
:
:
GetSingleton
(
)
;
if
(
gfxPlatform
:
:
IsInLayoutAsapMode
(
)
)
{
return
;
}
if
(
XRE_IsParentProcess
(
)
)
{
gfxPlatform
:
:
GetPlatform
(
)
;
sRegularRateTimer
=
new
VsyncRefreshDriverTimer
(
)
;
return
;
}
CreateContentVsyncRefreshTimer
(
nullptr
)
;
}
static
uint32_t
GetFirstFrameDelay
(
imgIRequest
*
req
)
{
nsCOMPtr
<
imgIContainer
>
container
;
if
(
NS_FAILED
(
req
-
>
GetImage
(
getter_AddRefs
(
container
)
)
)
|
|
!
container
)
{
return
0
;
}
int32_t
delay
=
container
-
>
GetFirstFrameDelay
(
)
;
if
(
delay
<
0
)
return
0
;
return
static_cast
<
uint32_t
>
(
delay
)
;
}
void
nsRefreshDriver
:
:
Shutdown
(
)
{
sRegularRateTimer
=
nullptr
;
sThrottledRateTimer
=
nullptr
;
}
int32_t
nsRefreshDriver
:
:
DefaultInterval
(
)
{
return
NSToIntRound
(
1000
.
0
/
gfxPlatform
:
:
GetDefaultFrameRate
(
)
)
;
}
double
nsRefreshDriver
:
:
GetRegularTimerInterval
(
)
const
{
int32_t
rate
=
Preferences
:
:
GetInt
(
"
layout
.
frame_rate
"
-
1
)
;
if
(
rate
<
0
)
{
rate
=
gfxPlatform
:
:
GetDefaultFrameRate
(
)
;
}
else
if
(
rate
=
=
0
)
{
rate
=
10000
;
}
return
1000
.
0
/
rate
;
}
double
nsRefreshDriver
:
:
GetThrottledTimerInterval
(
)
{
int32_t
rate
=
Preferences
:
:
GetInt
(
"
layout
.
throttled_frame_rate
"
-
1
)
;
if
(
rate
<
=
0
)
{
rate
=
DEFAULT_THROTTLED_FRAME_RATE
;
}
return
1000
.
0
/
rate
;
}
mozilla
:
:
TimeDuration
nsRefreshDriver
:
:
GetMinRecomputeVisibilityInterval
(
)
{
int32_t
interval
=
Preferences
:
:
GetInt
(
"
layout
.
visibility
.
min
-
recompute
-
interval
-
ms
"
-
1
)
;
if
(
interval
<
=
0
)
{
interval
=
DEFAULT_RECOMPUTE_VISIBILITY_INTERVAL_MS
;
}
return
TimeDuration
:
:
FromMilliseconds
(
interval
)
;
}
RefreshDriverTimer
*
nsRefreshDriver
:
:
ChooseTimer
(
)
const
{
if
(
mThrottled
)
{
if
(
!
sThrottledRateTimer
)
sThrottledRateTimer
=
new
InactiveRefreshDriverTimer
(
GetThrottledTimerInterval
(
)
DEFAULT_INACTIVE_TIMER_DISABLE_SECONDS
*
1000
.
0
)
;
return
sThrottledRateTimer
;
}
if
(
!
sRegularRateTimer
)
{
double
rate
=
GetRegularTimerInterval
(
)
;
CreateVsyncRefreshTimer
(
)
;
if
(
!
sRegularRateTimer
)
{
sRegularRateTimer
=
new
StartupRefreshDriverTimer
(
rate
)
;
}
}
return
sRegularRateTimer
;
}
nsRefreshDriver
:
:
nsRefreshDriver
(
nsPresContext
*
aPresContext
)
:
mActiveTimer
(
nullptr
)
mPresContext
(
aPresContext
)
mRootRefresh
(
nullptr
)
mNextTransactionId
{
0
}
mOutstandingTransactionId
{
0
}
mCompletedTransaction
{
0
}
mFreezeCount
(
0
)
mThrottledFrameRequestInterval
(
TimeDuration
:
:
FromMilliseconds
(
GetThrottledTimerInterval
(
)
)
)
mMinRecomputeVisibilityInterval
(
GetMinRecomputeVisibilityInterval
(
)
)
mThrottled
(
false
)
mNeedToRecomputeVisibility
(
false
)
mTestControllingRefreshes
(
false
)
mViewManagerFlushIsPending
(
false
)
mHasScheduleFlush
(
false
)
mInRefresh
(
false
)
mWaitingForTransaction
(
false
)
mSkippedPaints
(
false
)
mResizeSuppressed
(
false
)
mNotifyDOMContentFlushed
(
false
)
mWarningThreshold
(
REFRESH_WAIT_WARNING
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
mPresContext
"
Need
a
pres
context
to
tell
us
to
call
Disconnect
(
)
later
"
"
and
decrement
sRefreshDriverCount
.
"
)
;
mMostRecentRefresh
=
TimeStamp
:
:
Now
(
)
;
mNextThrottledFrameRequestTick
=
mMostRecentRefresh
;
mNextRecomputeVisibilityTick
=
mMostRecentRefresh
;
+
+
sRefreshDriverCount
;
}
nsRefreshDriver
:
:
~
nsRefreshDriver
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
ObserverCount
(
)
=
=
mEarlyRunners
.
Length
(
)
"
observers
except
pending
selection
scrolls
"
"
should
have
been
unregistered
"
)
;
MOZ_ASSERT
(
!
mActiveTimer
"
timer
should
be
gone
"
)
;
MOZ_ASSERT
(
!
mPresContext
"
Should
have
called
Disconnect
(
)
and
decremented
"
"
sRefreshDriverCount
!
"
)
;
if
(
mRootRefresh
)
{
mRootRefresh
-
>
RemoveRefreshObserver
(
this
FlushType
:
:
Style
)
;
mRootRefresh
=
nullptr
;
}
}
void
nsRefreshDriver
:
:
AdvanceTimeAndRefresh
(
int64_t
aMilliseconds
)
{
StopTimer
(
)
;
if
(
!
mTestControllingRefreshes
)
{
mMostRecentRefresh
=
TimeStamp
:
:
Now
(
)
;
mTestControllingRefreshes
=
true
;
if
(
mWaitingForTransaction
)
{
mWaitingForTransaction
=
false
;
mSkippedPaints
=
false
;
mWarningThreshold
=
REFRESH_WAIT_WARNING
;
}
}
mMostRecentRefresh
+
=
TimeDuration
:
:
FromMilliseconds
(
(
double
)
aMilliseconds
)
;
mozilla
:
:
dom
:
:
AutoNoJSAPI
nojsapi
;
DoTick
(
)
;
}
void
nsRefreshDriver
:
:
RestoreNormalRefresh
(
)
{
mTestControllingRefreshes
=
false
;
EnsureTimerStarted
(
eAllowTimeToGoBackwards
)
;
mCompletedTransaction
=
mOutstandingTransactionId
=
mNextTransactionId
;
}
TimeStamp
nsRefreshDriver
:
:
MostRecentRefresh
(
)
const
{
if
(
!
ServoStyleSet
:
:
IsInServoTraversal
(
)
)
{
const_cast
<
nsRefreshDriver
*
>
(
this
)
-
>
EnsureTimerStarted
(
)
;
}
return
mMostRecentRefresh
;
}
void
nsRefreshDriver
:
:
AddRefreshObserver
(
nsARefreshObserver
*
aObserver
FlushType
aFlushType
)
{
ObserverArray
&
array
=
ArrayFor
(
aFlushType
)
;
array
.
AppendElement
(
aObserver
)
;
EnsureTimerStarted
(
)
;
}
bool
nsRefreshDriver
:
:
RemoveRefreshObserver
(
nsARefreshObserver
*
aObserver
FlushType
aFlushType
)
{
ObserverArray
&
array
=
ArrayFor
(
aFlushType
)
;
return
array
.
RemoveElement
(
aObserver
)
;
}
void
nsRefreshDriver
:
:
AddTimerAdjustmentObserver
(
nsATimerAdjustmentObserver
*
aObserver
)
{
MOZ_ASSERT
(
!
mTimerAdjustmentObservers
.
Contains
(
aObserver
)
)
;
mTimerAdjustmentObservers
.
AppendElement
(
aObserver
)
;
}
void
nsRefreshDriver
:
:
RemoveTimerAdjustmentObserver
(
nsATimerAdjustmentObserver
*
aObserver
)
{
MOZ_ASSERT
(
mTimerAdjustmentObservers
.
Contains
(
aObserver
)
)
;
mTimerAdjustmentObservers
.
RemoveElement
(
aObserver
)
;
}
void
nsRefreshDriver
:
:
PostVisualViewportResizeEvent
(
VVPResizeEvent
*
aResizeEvent
)
{
mVisualViewportResizeEvents
.
AppendElement
(
aResizeEvent
)
;
EnsureTimerStarted
(
)
;
}
void
nsRefreshDriver
:
:
DispatchVisualViewportResizeEvents
(
)
{
VisualViewportResizeEventArray
events
;
events
.
SwapElements
(
mVisualViewportResizeEvents
)
;
for
(
auto
&
event
:
events
)
{
event
-
>
Run
(
)
;
}
}
void
nsRefreshDriver
:
:
PostScrollEvent
(
mozilla
:
:
Runnable
*
aScrollEvent
bool
aDelayed
)
{
if
(
aDelayed
)
{
mDelayedScrollEvents
.
AppendElement
(
aScrollEvent
)
;
}
else
{
mScrollEvents
.
AppendElement
(
aScrollEvent
)
;
EnsureTimerStarted
(
)
;
}
}
void
nsRefreshDriver
:
:
DispatchScrollEvents
(
)
{
ScrollEventArray
events
;
events
.
SwapElements
(
mScrollEvents
)
;
for
(
auto
&
event
:
events
)
{
event
-
>
Run
(
)
;
}
}
void
nsRefreshDriver
:
:
PostVisualViewportScrollEvent
(
VVPScrollEvent
*
aScrollEvent
)
{
mVisualViewportScrollEvents
.
AppendElement
(
aScrollEvent
)
;
EnsureTimerStarted
(
)
;
}
void
nsRefreshDriver
:
:
DispatchVisualViewportScrollEvents
(
)
{
VisualViewportScrollEventArray
events
;
events
.
SwapElements
(
mVisualViewportScrollEvents
)
;
for
(
auto
&
event
:
events
)
{
event
-
>
Run
(
)
;
}
}
void
nsRefreshDriver
:
:
AddPostRefreshObserver
(
nsAPostRefreshObserver
*
aObserver
)
{
mPostRefreshObservers
.
AppendElement
(
aObserver
)
;
}
void
nsRefreshDriver
:
:
RemovePostRefreshObserver
(
nsAPostRefreshObserver
*
aObserver
)
{
mPostRefreshObservers
.
RemoveElement
(
aObserver
)
;
}
bool
nsRefreshDriver
:
:
AddImageRequest
(
imgIRequest
*
aRequest
)
{
uint32_t
delay
=
GetFirstFrameDelay
(
aRequest
)
;
if
(
delay
=
=
0
)
{
mRequests
.
PutEntry
(
aRequest
)
;
}
else
{
ImageStartData
*
start
=
mStartTable
.
LookupForAdd
(
delay
)
.
OrInsert
(
[
]
(
)
{
return
new
ImageStartData
(
)
;
}
)
;
start
-
>
mEntries
.
PutEntry
(
aRequest
)
;
}
EnsureTimerStarted
(
)
;
return
true
;
}
void
nsRefreshDriver
:
:
RemoveImageRequest
(
imgIRequest
*
aRequest
)
{
mRequests
.
RemoveEntry
(
aRequest
)
;
uint32_t
delay
=
GetFirstFrameDelay
(
aRequest
)
;
if
(
delay
!
=
0
)
{
ImageStartData
*
start
=
mStartTable
.
Get
(
delay
)
;
if
(
start
)
{
start
-
>
mEntries
.
RemoveEntry
(
aRequest
)
;
}
}
}
void
nsRefreshDriver
:
:
NotifyDOMContentLoaded
(
)
{
if
(
!
HasObservers
(
)
)
{
GetPresContext
(
)
-
>
NotifyDOMContentFlushed
(
)
;
}
else
{
mNotifyDOMContentFlushed
=
true
;
}
}
void
nsRefreshDriver
:
:
RunDelayedEventsSoon
(
)
{
mScrollEvents
.
AppendElements
(
mDelayedScrollEvents
)
;
mDelayedScrollEvents
.
Clear
(
)
;
mResizeEventFlushObservers
.
AppendElements
(
mDelayedResizeEventFlushObservers
)
;
mDelayedResizeEventFlushObservers
.
Clear
(
)
;
EnsureTimerStarted
(
)
;
}
void
nsRefreshDriver
:
:
EnsureTimerStarted
(
EnsureTimerStartedFlags
aFlags
)
{
MOZ_ASSERT
(
!
ServoStyleSet
:
:
IsInServoTraversal
(
)
|
|
NS_IsMainThread
(
)
"
EnsureTimerStarted
should
be
called
only
when
we
are
not
"
"
in
servo
traversal
or
on
the
main
-
thread
"
)
;
if
(
mTestControllingRefreshes
)
return
;
if
(
mActiveTimer
&
&
!
(
aFlags
&
eForceAdjustTimer
)
)
return
;
if
(
IsFrozen
(
)
|
|
!
mPresContext
)
{
StopTimer
(
)
;
return
;
}
if
(
mPresContext
-
>
Document
(
)
-
>
IsBeingUsedAsImage
(
)
)
{
nsIURI
*
uri
=
mPresContext
-
>
Document
(
)
-
>
GetDocumentURI
(
)
;
if
(
!
uri
|
|
!
mozilla
:
:
dom
:
:
IsFontTableURI
(
uri
)
)
{
MOZ_ASSERT
(
!
mActiveTimer
"
image
doc
refresh
driver
should
never
have
its
own
timer
"
)
;
return
;
}
}
RefreshDriverTimer
*
newTimer
=
ChooseTimer
(
)
;
if
(
newTimer
!
=
mActiveTimer
)
{
if
(
mActiveTimer
)
mActiveTimer
-
>
RemoveRefreshDriver
(
this
)
;
mActiveTimer
=
newTimer
;
mActiveTimer
-
>
AddRefreshDriver
(
this
)
;
}
if
(
aFlags
&
eNeverAdjustTimer
)
{
return
;
}
TimeStamp
newMostRecentRefresh
=
aFlags
&
eAllowTimeToGoBackwards
?
mActiveTimer
-
>
MostRecentRefresh
(
)
:
std
:
:
max
(
mActiveTimer
-
>
MostRecentRefresh
(
)
mMostRecentRefresh
)
;
if
(
mMostRecentRefresh
!
=
newMostRecentRefresh
)
{
mMostRecentRefresh
=
newMostRecentRefresh
;
nsTObserverArray
<
nsATimerAdjustmentObserver
*
>
:
:
EndLimitedIterator
iter
(
mTimerAdjustmentObservers
)
;
while
(
iter
.
HasMore
(
)
)
{
nsATimerAdjustmentObserver
*
obs
=
iter
.
GetNext
(
)
;
obs
-
>
NotifyTimerAdjusted
(
mMostRecentRefresh
)
;
}
}
}
void
nsRefreshDriver
:
:
StopTimer
(
)
{
if
(
!
mActiveTimer
)
return
;
mActiveTimer
-
>
RemoveRefreshDriver
(
this
)
;
mActiveTimer
=
nullptr
;
}
uint32_t
nsRefreshDriver
:
:
ObserverCount
(
)
const
{
uint32_t
sum
=
0
;
for
(
const
ObserverArray
&
array
:
mObservers
)
{
sum
+
=
array
.
Length
(
)
;
}
sum
+
=
mAnimationEventFlushObservers
.
Length
(
)
;
sum
+
=
mResizeEventFlushObservers
.
Length
(
)
;
sum
+
=
mStyleFlushObservers
.
Length
(
)
;
sum
+
=
mLayoutFlushObservers
.
Length
(
)
;
sum
+
=
mPendingFullscreenEvents
.
Length
(
)
;
sum
+
=
mFrameRequestCallbackDocs
.
Length
(
)
;
sum
+
=
mThrottledFrameRequestCallbackDocs
.
Length
(
)
;
sum
+
=
mViewManagerFlushIsPending
;
sum
+
=
mEarlyRunners
.
Length
(
)
;
sum
+
=
mTimerAdjustmentObservers
.
Length
(
)
;
return
sum
;
}
bool
nsRefreshDriver
:
:
HasObservers
(
)
const
{
for
(
const
ObserverArray
&
array
:
mObservers
)
{
if
(
!
array
.
IsEmpty
(
)
)
{
return
true
;
}
}
return
mViewManagerFlushIsPending
|
|
!
mStyleFlushObservers
.
IsEmpty
(
)
|
|
!
mLayoutFlushObservers
.
IsEmpty
(
)
|
|
!
mAnimationEventFlushObservers
.
IsEmpty
(
)
|
|
!
mResizeEventFlushObservers
.
IsEmpty
(
)
|
|
!
mPendingFullscreenEvents
.
IsEmpty
(
)
|
|
!
mFrameRequestCallbackDocs
.
IsEmpty
(
)
|
|
!
mThrottledFrameRequestCallbackDocs
.
IsEmpty
(
)
|
|
!
mEarlyRunners
.
IsEmpty
(
)
;
}
bool
nsRefreshDriver
:
:
HasImageRequests
(
)
const
{
for
(
auto
iter
=
mStartTable
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
if
(
!
iter
.
UserData
(
)
-
>
mEntries
.
IsEmpty
(
)
)
{
return
true
;
}
}
return
!
mRequests
.
IsEmpty
(
)
;
}
nsRefreshDriver
:
:
ObserverArray
&
nsRefreshDriver
:
:
ArrayFor
(
FlushType
aFlushType
)
{
switch
(
aFlushType
)
{
case
FlushType
:
:
Event
:
return
mObservers
[
0
]
;
case
FlushType
:
:
Style
:
return
mObservers
[
1
]
;
case
FlushType
:
:
Layout
:
return
mObservers
[
2
]
;
case
FlushType
:
:
Display
:
return
mObservers
[
3
]
;
default
:
MOZ_CRASH
(
"
We
don
'
t
track
refresh
observers
for
this
flush
type
"
)
;
}
}
void
nsRefreshDriver
:
:
DoTick
(
)
{
MOZ_ASSERT
(
!
IsFrozen
(
)
"
Why
are
we
notified
while
frozen
?
"
)
;
MOZ_ASSERT
(
mPresContext
"
Why
are
we
notified
after
disconnection
?
"
)
;
MOZ_ASSERT
(
!
nsContentUtils
:
:
GetCurrentJSContext
(
)
"
Shouldn
'
t
have
a
JSContext
on
the
stack
"
)
;
if
(
mTestControllingRefreshes
)
{
Tick
(
VsyncId
(
)
mMostRecentRefresh
)
;
}
else
{
Tick
(
VsyncId
(
)
TimeStamp
:
:
Now
(
)
)
;
}
}
struct
DocumentFrameCallbacks
{
explicit
DocumentFrameCallbacks
(
Document
*
aDocument
)
:
mDocument
(
aDocument
)
{
}
RefPtr
<
Document
>
mDocument
;
Document
:
:
FrameRequestCallbackList
mCallbacks
;
}
;
static
nsDocShell
*
GetDocShell
(
nsPresContext
*
aPresContext
)
{
return
static_cast
<
nsDocShell
*
>
(
aPresContext
-
>
GetDocShell
(
)
)
;
}
static
bool
HasPendingAnimations
(
nsIPresShell
*
aShell
)
{
Document
*
doc
=
aShell
-
>
GetDocument
(
)
;
if
(
!
doc
)
{
return
false
;
}
PendingAnimationTracker
*
tracker
=
doc
-
>
GetPendingAnimationTracker
(
)
;
return
tracker
&
&
tracker
-
>
HasPendingAnimations
(
)
;
}
static
void
GetProfileTimelineSubDocShells
(
nsDocShell
*
aRootDocShell
nsTArray
<
nsDocShell
*
>
&
aShells
)
{
if
(
!
aRootDocShell
)
{
return
;
}
RefPtr
<
TimelineConsumers
>
timelines
=
TimelineConsumers
:
:
Get
(
)
;
if
(
!
timelines
|
|
timelines
-
>
IsEmpty
(
)
)
{
return
;
}
nsCOMPtr
<
nsISimpleEnumerator
>
enumerator
;
nsresult
rv
=
aRootDocShell
-
>
GetDocShellEnumerator
(
nsIDocShellTreeItem
:
:
typeAll
nsIDocShell
:
:
ENUMERATE_BACKWARDS
getter_AddRefs
(
enumerator
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
nsCOMPtr
<
nsIDocShell
>
curItem
;
bool
hasMore
=
false
;
while
(
NS_SUCCEEDED
(
enumerator
-
>
HasMoreElements
(
&
hasMore
)
)
&
&
hasMore
)
{
nsCOMPtr
<
nsISupports
>
curSupports
;
enumerator
-
>
GetNext
(
getter_AddRefs
(
curSupports
)
)
;
curItem
=
do_QueryInterface
(
curSupports
)
;
if
(
!
curItem
|
|
!
curItem
-
>
GetRecordProfileTimelineMarkers
(
)
)
{
continue
;
}
nsDocShell
*
shell
=
static_cast
<
nsDocShell
*
>
(
curItem
.
get
(
)
)
;
bool
isVisible
=
false
;
shell
-
>
GetVisibility
(
&
isVisible
)
;
if
(
!
isVisible
)
{
continue
;
}
aShells
.
AppendElement
(
shell
)
;
}
}
static
void
TakeFrameRequestCallbacksFrom
(
Document
*
aDocument
nsTArray
<
DocumentFrameCallbacks
>
&
aTarget
)
{
aTarget
.
AppendElement
(
aDocument
)
;
aDocument
-
>
TakeFrameRequestCallbacks
(
aTarget
.
LastElement
(
)
.
mCallbacks
)
;
}
void
nsRefreshDriver
:
:
RunFullscreenSteps
(
)
{
nsTArray
<
UniquePtr
<
PendingFullscreenEvent
>
>
pendings
(
std
:
:
move
(
mPendingFullscreenEvents
)
)
;
for
(
UniquePtr
<
PendingFullscreenEvent
>
&
event
:
pendings
)
{
event
-
>
Dispatch
(
)
;
}
}
void
nsRefreshDriver
:
:
UpdateIntersectionObservations
(
)
{
AutoTArray
<
RefPtr
<
Document
>
32
>
documents
;
if
(
mPresContext
-
>
Document
(
)
-
>
HasIntersectionObservers
(
)
)
{
documents
.
AppendElement
(
mPresContext
-
>
Document
(
)
)
;
}
mPresContext
-
>
Document
(
)
-
>
CollectDescendantDocuments
(
documents
[
]
(
const
Document
*
document
)
-
>
bool
{
return
document
-
>
HasIntersectionObservers
(
)
;
}
)
;
for
(
uint32_t
i
=
0
;
i
<
documents
.
Length
(
)
;
+
+
i
)
{
Document
*
doc
=
documents
[
i
]
;
doc
-
>
UpdateIntersectionObservations
(
)
;
doc
-
>
ScheduleIntersectionObserverNotification
(
)
;
}
}
void
nsRefreshDriver
:
:
DispatchAnimationEvents
(
)
{
if
(
!
mPresContext
)
{
return
;
}
AutoTArray
<
RefPtr
<
AnimationEventDispatcher
>
16
>
dispatchers
;
dispatchers
.
AppendElements
(
mAnimationEventFlushObservers
)
;
mAnimationEventFlushObservers
.
Clear
(
)
;
for
(
auto
&
dispatcher
:
dispatchers
)
{
dispatcher
-
>
DispatchEvents
(
)
;
}
}
void
nsRefreshDriver
:
:
RunFrameRequestCallbacks
(
TimeStamp
aNowTime
)
{
nsTArray
<
DocumentFrameCallbacks
>
frameRequestCallbacks
(
mFrameRequestCallbackDocs
.
Length
(
)
+
mThrottledFrameRequestCallbackDocs
.
Length
(
)
)
;
{
nsTArray
<
Document
*
>
docsToRemove
;
bool
tickThrottledFrameRequests
=
mThrottled
;
if
(
!
tickThrottledFrameRequests
&
&
aNowTime
>
=
mNextThrottledFrameRequestTick
)
{
mNextThrottledFrameRequestTick
=
aNowTime
+
mThrottledFrameRequestInterval
;
tickThrottledFrameRequests
=
true
;
}
for
(
Document
*
doc
:
mThrottledFrameRequestCallbackDocs
)
{
if
(
tickThrottledFrameRequests
)
{
TakeFrameRequestCallbacksFrom
(
doc
frameRequestCallbacks
)
;
}
else
if
(
!
doc
-
>
ShouldThrottleFrameRequests
(
)
)
{
TakeFrameRequestCallbacksFrom
(
doc
frameRequestCallbacks
)
;
docsToRemove
.
AppendElement
(
doc
)
;
}
}
if
(
tickThrottledFrameRequests
)
{
mThrottledFrameRequestCallbackDocs
.
Clear
(
)
;
}
else
{
for
(
Document
*
doc
:
docsToRemove
)
{
mThrottledFrameRequestCallbackDocs
.
RemoveElement
(
doc
)
;
}
}
}
for
(
Document
*
doc
:
mFrameRequestCallbackDocs
)
{
TakeFrameRequestCallbacksFrom
(
doc
frameRequestCallbacks
)
;
}
mFrameRequestCallbackDocs
.
Clear
(
)
;
if
(
!
frameRequestCallbacks
.
IsEmpty
(
)
)
{
AUTO_PROFILER_TRACING_DOCSHELL
(
"
Paint
"
"
Scripts
"
GRAPHICS
GetDocShell
(
mPresContext
)
)
;
for
(
const
DocumentFrameCallbacks
&
docCallbacks
:
frameRequestCallbacks
)
{
nsPIDOMWindowInner
*
innerWindow
=
docCallbacks
.
mDocument
-
>
GetInnerWindow
(
)
;
DOMHighResTimeStamp
timeStamp
=
0
;
if
(
innerWindow
)
{
mozilla
:
:
dom
:
:
Performance
*
perf
=
innerWindow
-
>
GetPerformance
(
)
;
if
(
perf
)
{
timeStamp
=
perf
-
>
GetDOMTiming
(
)
-
>
TimeStampToDOMHighRes
(
aNowTime
)
;
}
}
for
(
auto
&
callback
:
docCallbacks
.
mCallbacks
)
{
callback
-
>
Call
(
timeStamp
)
;
}
}
}
}
struct
RunnableWithDelay
{
nsCOMPtr
<
nsIRunnable
>
mRunnable
;
uint32_t
mDelay
;
}
;
static
AutoTArray
<
RunnableWithDelay
8
>
*
sPendingIdleRunnables
=
nullptr
;
void
nsRefreshDriver
:
:
DispatchIdleRunnableAfterTick
(
nsIRunnable
*
aRunnable
uint32_t
aDelay
)
{
if
(
!
sPendingIdleRunnables
)
{
sPendingIdleRunnables
=
new
AutoTArray
<
RunnableWithDelay
8
>
(
)
;
}
RunnableWithDelay
rwd
=
{
aRunnable
aDelay
}
;
sPendingIdleRunnables
-
>
AppendElement
(
rwd
)
;
}
void
nsRefreshDriver
:
:
CancelIdleRunnable
(
nsIRunnable
*
aRunnable
)
{
if
(
!
sPendingIdleRunnables
)
{
return
;
}
for
(
uint32_t
i
=
0
;
i
<
sPendingIdleRunnables
-
>
Length
(
)
;
+
+
i
)
{
if
(
(
*
sPendingIdleRunnables
)
[
i
]
.
mRunnable
=
=
aRunnable
)
{
sPendingIdleRunnables
-
>
RemoveElementAt
(
i
)
;
break
;
}
}
if
(
sPendingIdleRunnables
-
>
IsEmpty
(
)
)
{
delete
sPendingIdleRunnables
;
sPendingIdleRunnables
=
nullptr
;
}
}
void
nsRefreshDriver
:
:
Tick
(
VsyncId
aId
TimeStamp
aNowTime
)
{
MOZ_ASSERT
(
!
nsContentUtils
:
:
GetCurrentJSContext
(
)
"
Shouldn
'
t
have
a
JSContext
on
the
stack
"
)
;
if
(
nsNPAPIPluginInstance
:
:
InPluginCallUnsafeForReentry
(
)
)
{
NS_ERROR
(
"
Refresh
driver
should
not
run
during
plugin
call
!
"
)
;
return
;
}
AUTO_PROFILER_LABEL
(
"
nsRefreshDriver
:
:
Tick
"
LAYOUT
)
;
if
(
IsFrozen
(
)
|
|
!
mPresContext
)
{
return
;
}
if
(
(
aNowTime
<
=
mMostRecentRefresh
)
&
&
!
mTestControllingRefreshes
)
{
return
;
}
if
(
IsWaitingForPaint
(
aNowTime
)
)
{
PROFILER_ADD_MARKER
(
"
nsRefreshDriver
:
:
Tick
waiting
for
paint
"
LAYOUT
)
;
return
;
}
TimeStamp
previousRefresh
=
mMostRecentRefresh
;
mMostRecentRefresh
=
aNowTime
;
if
(
mRootRefresh
)
{
mRootRefresh
-
>
RemoveRefreshObserver
(
this
FlushType
:
:
Style
)
;
mRootRefresh
=
nullptr
;
}
mSkippedPaints
=
false
;
mWarningThreshold
=
1
;
nsCOMPtr
<
nsIPresShell
>
presShell
=
mPresContext
-
>
GetPresShell
(
)
;
if
(
!
presShell
|
|
(
!
HasObservers
(
)
&
&
!
HasImageRequests
(
)
&
&
mVisualViewportResizeEvents
.
IsEmpty
(
)
&
&
mScrollEvents
.
IsEmpty
(
)
&
&
mVisualViewportScrollEvents
.
IsEmpty
(
)
)
)
{
if
(
!
XRE_IsContentProcess
(
)
|
|
!
presShell
|
|
mTestControllingRefreshes
|
|
!
mPresContext
-
>
Document
(
)
-
>
IsTopLevelContentDocument
(
)
|
|
mThrottled
|
|
gfxPlatform
:
:
IsInLayoutAsapMode
(
)
)
{
StopTimer
(
)
;
}
else
if
(
mPresContext
-
>
Document
(
)
-
>
GetReadyStateEnum
(
)
<
Document
:
:
READYSTATE_COMPLETE
&
&
!
mPresContext
-
>
HadContentfulPaint
(
)
)
{
if
(
mInitialTimerRunningLimit
.
IsNull
(
)
)
{
mInitialTimerRunningLimit
=
TimeStamp
:
:
Now
(
)
+
TimeDuration
:
:
FromSeconds
(
4
.
0f
)
;
}
else
if
(
mInitialTimerRunningLimit
<
TimeStamp
:
:
Now
(
)
)
{
StopTimer
(
)
;
}
}
return
;
}
mResizeSuppressed
=
false
;
AutoRestore
<
bool
>
restoreInRefresh
(
mInRefresh
)
;
mInRefresh
=
true
;
AutoRestore
<
TimeStamp
>
restoreTickStart
(
mTickStart
)
;
mTickStart
=
TimeStamp
:
:
Now
(
)
;
mTickVsyncId
=
aId
;
mTickVsyncTime
=
aNowTime
;
gfxPlatform
:
:
GetPlatform
(
)
-
>
SchedulePaintIfDeviceReset
(
)
;
if
(
gfxPrefs
:
:
APZPeekMessages
(
)
)
{
nsLayoutUtils
:
:
UpdateDisplayPortMarginsFromPendingMessages
(
)
;
}
AutoTArray
<
nsCOMPtr
<
nsIRunnable
>
16
>
earlyRunners
;
earlyRunners
.
SwapElements
(
mEarlyRunners
)
;
for
(
auto
&
runner
:
earlyRunners
)
{
runner
-
>
Run
(
)
;
}
AutoTArray
<
nsIPresShell
*
16
>
observers
;
observers
.
AppendElements
(
mResizeEventFlushObservers
)
;
for
(
nsIPresShell
*
shell
:
Reversed
(
observers
)
)
{
if
(
!
mPresContext
|
|
!
mPresContext
-
>
GetPresShell
(
)
)
{
StopTimer
(
)
;
return
;
}
if
(
!
mResizeEventFlushObservers
.
RemoveElement
(
shell
)
)
{
continue
;
}
shell
-
>
FireResizeEvent
(
)
;
}
DispatchVisualViewportResizeEvents
(
)
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
mObservers
)
;
+
+
i
)
{
ObserverArray
:
:
EndLimitedIterator
etor
(
mObservers
[
i
]
)
;
while
(
etor
.
HasMore
(
)
)
{
RefPtr
<
nsARefreshObserver
>
obs
=
etor
.
GetNext
(
)
;
obs
-
>
WillRefresh
(
aNowTime
)
;
if
(
!
mPresContext
|
|
!
mPresContext
-
>
GetPresShell
(
)
)
{
StopTimer
(
)
;
return
;
}
}
if
(
i
=
=
1
)
{
DispatchScrollEvents
(
)
;
DispatchVisualViewportScrollEvents
(
)
;
DispatchAnimationEvents
(
)
;
RunFullscreenSteps
(
)
;
RunFrameRequestCallbacks
(
aNowTime
)
;
if
(
mPresContext
&
&
mPresContext
-
>
GetPresShell
(
)
)
{
AutoTArray
<
nsIPresShell
*
16
>
observers
;
observers
.
AppendElements
(
mStyleFlushObservers
)
;
for
(
uint32_t
j
=
observers
.
Length
(
)
;
j
&
&
mPresContext
&
&
mPresContext
-
>
GetPresShell
(
)
;
-
-
j
)
{
nsIPresShell
*
shell
=
observers
[
j
-
1
]
;
if
(
!
mStyleFlushObservers
.
RemoveElement
(
shell
)
)
continue
;
nsCOMPtr
<
nsIPresShell
>
shellKungFuDeathGrip
(
shell
)
;
shell
-
>
mObservingStyleFlushes
=
false
;
shell
-
>
FlushPendingNotifications
(
ChangesToFlush
(
FlushType
:
:
Style
false
)
)
;
shell
-
>
NotifyFontFaceSetOnRefresh
(
)
;
mNeedToRecomputeVisibility
=
true
;
}
}
}
else
if
(
i
=
=
2
)
{
AutoTArray
<
nsIPresShell
*
16
>
observers
;
observers
.
AppendElements
(
mLayoutFlushObservers
)
;
for
(
uint32_t
j
=
observers
.
Length
(
)
;
j
&
&
mPresContext
&
&
mPresContext
-
>
GetPresShell
(
)
;
-
-
j
)
{
nsIPresShell
*
shell
=
observers
[
j
-
1
]
;
if
(
!
mLayoutFlushObservers
.
RemoveElement
(
shell
)
)
continue
;
nsCOMPtr
<
nsIPresShell
>
shellKungFuDeathGrip
(
shell
)
;
shell
-
>
mObservingLayoutFlushes
=
false
;
shell
-
>
mWasLastReflowInterrupted
=
false
;
FlushType
flushType
=
HasPendingAnimations
(
shell
)
?
FlushType
:
:
Layout
:
FlushType
:
:
InterruptibleLayout
;
shell
-
>
FlushPendingNotifications
(
ChangesToFlush
(
flushType
false
)
)
;
shell
-
>
NotifyFontFaceSetOnRefresh
(
)
;
mNeedToRecomputeVisibility
=
true
;
}
}
if
(
!
mPresContext
|
|
!
mPresContext
-
>
GetPresShell
(
)
)
{
StopTimer
(
)
;
return
;
}
}
if
(
mNeedToRecomputeVisibility
&
&
!
mThrottled
&
&
aNowTime
>
=
mNextRecomputeVisibilityTick
&
&
!
presShell
-
>
IsPaintingSuppressed
(
)
)
{
mNextRecomputeVisibilityTick
=
aNowTime
+
mMinRecomputeVisibilityInterval
;
mNeedToRecomputeVisibility
=
false
;
presShell
-
>
ScheduleApproximateFrameVisibilityUpdateNow
(
)
;
}
#
ifdef
MOZ_XUL
if
(
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
)
{
pm
-
>
UpdatePopupPositions
(
this
)
;
}
#
endif
UpdateIntersectionObservations
(
)
;
for
(
auto
iter
=
mStartTable
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
uint32_t
&
delay
=
iter
.
Key
(
)
;
ImageStartData
*
data
=
iter
.
UserData
(
)
;
if
(
data
-
>
mStartTime
)
{
TimeStamp
&
start
=
*
data
-
>
mStartTime
;
TimeDuration
prev
=
previousRefresh
-
start
;
TimeDuration
curr
=
aNowTime
-
start
;
uint32_t
prevMultiple
=
uint32_t
(
prev
.
ToMilliseconds
(
)
)
/
delay
;
if
(
prevMultiple
!
=
uint32_t
(
curr
.
ToMilliseconds
(
)
)
/
delay
)
{
mozilla
:
:
TimeStamp
desired
=
start
+
TimeDuration
:
:
FromMilliseconds
(
prevMultiple
*
delay
)
;
BeginRefreshingImages
(
data
-
>
mEntries
desired
)
;
}
}
else
{
mozilla
:
:
TimeStamp
desired
=
aNowTime
;
BeginRefreshingImages
(
data
-
>
mEntries
desired
)
;
data
-
>
mStartTime
.
emplace
(
aNowTime
)
;
}
}
if
(
mRequests
.
Count
(
)
)
{
nsCOMArray
<
imgIContainer
>
imagesToRefresh
(
mRequests
.
Count
(
)
)
;
for
(
auto
iter
=
mRequests
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsISupportsHashKey
*
entry
=
iter
.
Get
(
)
;
auto
req
=
static_cast
<
imgIRequest
*
>
(
entry
-
>
GetKey
(
)
)
;
MOZ_ASSERT
(
req
"
Unable
to
retrieve
the
image
request
"
)
;
nsCOMPtr
<
imgIContainer
>
image
;
if
(
NS_SUCCEEDED
(
req
-
>
GetImage
(
getter_AddRefs
(
image
)
)
)
)
{
imagesToRefresh
.
AppendElement
(
image
.
forget
(
)
)
;
}
}
for
(
uint32_t
i
=
0
;
i
<
imagesToRefresh
.
Length
(
)
;
i
+
+
)
{
imagesToRefresh
[
i
]
-
>
RequestRefresh
(
aNowTime
)
;
}
}
bool
dispatchRunnablesAfterTick
=
false
;
if
(
mViewManagerFlushIsPending
)
{
RefPtr
<
TimelineConsumers
>
timelines
=
TimelineConsumers
:
:
Get
(
)
;
nsTArray
<
nsDocShell
*
>
profilingDocShells
;
GetProfileTimelineSubDocShells
(
GetDocShell
(
mPresContext
)
profilingDocShells
)
;
for
(
nsDocShell
*
docShell
:
profilingDocShells
)
{
MOZ_ASSERT
(
timelines
)
;
MOZ_ASSERT
(
timelines
-
>
HasConsumer
(
docShell
)
)
;
timelines
-
>
AddMarkerForDocShell
(
docShell
"
Paint
"
MarkerTracingType
:
:
START
)
;
}
#
ifdef
MOZ_DUMP_PAINTING
if
(
nsLayoutUtils
:
:
InvalidationDebuggingIsEnabled
(
)
)
{
printf_stderr
(
"
Starting
ProcessPendingUpdates
\
n
"
)
;
}
#
endif
mViewManagerFlushIsPending
=
false
;
RefPtr
<
nsViewManager
>
vm
=
mPresContext
-
>
GetPresShell
(
)
-
>
GetViewManager
(
)
;
{
PaintTelemetry
:
:
AutoRecordPaint
record
;
vm
-
>
ProcessPendingUpdates
(
)
;
}
#
ifdef
MOZ_DUMP_PAINTING
if
(
nsLayoutUtils
:
:
InvalidationDebuggingIsEnabled
(
)
)
{
printf_stderr
(
"
Ending
ProcessPendingUpdates
\
n
"
)
;
}
#
endif
for
(
nsDocShell
*
docShell
:
profilingDocShells
)
{
MOZ_ASSERT
(
timelines
)
;
MOZ_ASSERT
(
timelines
-
>
HasConsumer
(
docShell
)
)
;
timelines
-
>
AddMarkerForDocShell
(
docShell
"
Paint
"
MarkerTracingType
:
:
END
)
;
}
dispatchRunnablesAfterTick
=
true
;
mHasScheduleFlush
=
false
;
}
#
ifndef
ANDROID
mozilla
:
:
Telemetry
:
:
AccumulateTimeDelta
(
mozilla
:
:
Telemetry
:
:
REFRESH_DRIVER_TICK
mTickStart
)
;
#
endif
if
(
mNotifyDOMContentFlushed
)
{
mNotifyDOMContentFlushed
=
false
;
mPresContext
-
>
NotifyDOMContentFlushed
(
)
;
}
nsTObserverArray
<
nsAPostRefreshObserver
*
>
:
:
ForwardIterator
iter
(
mPostRefreshObservers
)
;
while
(
iter
.
HasMore
(
)
)
{
nsAPostRefreshObserver
*
observer
=
iter
.
GetNext
(
)
;
observer
-
>
DidRefresh
(
)
;
}
NS_ASSERTION
(
mInRefresh
"
Still
in
refresh
"
)
;
if
(
mPresContext
-
>
IsRoot
(
)
&
&
XRE_IsContentProcess
(
)
&
&
gfxPrefs
:
:
AlwaysPaint
(
)
)
{
ScheduleViewManagerFlush
(
)
;
}
if
(
dispatchRunnablesAfterTick
&
&
sPendingIdleRunnables
)
{
AutoTArray
<
RunnableWithDelay
8
>
*
runnables
=
sPendingIdleRunnables
;
sPendingIdleRunnables
=
nullptr
;
for
(
RunnableWithDelay
&
runnableWithDelay
:
*
runnables
)
{
NS_DispatchToCurrentThreadQueue
(
runnableWithDelay
.
mRunnable
.
forget
(
)
runnableWithDelay
.
mDelay
EventQueuePriority
:
:
Idle
)
;
}
delete
runnables
;
}
}
void
nsRefreshDriver
:
:
BeginRefreshingImages
(
RequestTable
&
aEntries
mozilla
:
:
TimeStamp
aDesired
)
{
for
(
auto
iter
=
aEntries
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
req
=
static_cast
<
imgIRequest
*
>
(
iter
.
Get
(
)
-
>
GetKey
(
)
)
;
MOZ_ASSERT
(
req
"
Unable
to
retrieve
the
image
request
"
)
;
mRequests
.
PutEntry
(
req
)
;
nsCOMPtr
<
imgIContainer
>
image
;
if
(
NS_SUCCEEDED
(
req
-
>
GetImage
(
getter_AddRefs
(
image
)
)
)
)
{
image
-
>
SetAnimationStartTime
(
aDesired
)
;
}
}
aEntries
.
Clear
(
)
;
}
void
nsRefreshDriver
:
:
Freeze
(
)
{
StopTimer
(
)
;
mFreezeCount
+
+
;
}
void
nsRefreshDriver
:
:
Thaw
(
)
{
NS_ASSERTION
(
mFreezeCount
>
0
"
Thaw
(
)
called
on
an
unfrozen
refresh
driver
"
)
;
if
(
mFreezeCount
>
0
)
{
mFreezeCount
-
-
;
}
if
(
mFreezeCount
=
=
0
)
{
if
(
HasObservers
(
)
|
|
HasImageRequests
(
)
)
{
RefPtr
<
nsRunnableMethod
<
nsRefreshDriver
>
>
event
=
NewRunnableMethod
(
"
nsRefreshDriver
:
:
DoRefresh
"
this
&
nsRefreshDriver
:
:
DoRefresh
)
;
nsPresContext
*
pc
=
GetPresContext
(
)
;
if
(
pc
)
{
pc
-
>
Document
(
)
-
>
Dispatch
(
TaskCategory
:
:
Other
event
.
forget
(
)
)
;
EnsureTimerStarted
(
)
;
}
else
{
NS_ERROR
(
"
Thawing
while
document
is
being
destroyed
"
)
;
}
}
}
}
void
nsRefreshDriver
:
:
FinishedWaitingForTransaction
(
)
{
mWaitingForTransaction
=
false
;
mSkippedPaints
=
false
;
mWarningThreshold
=
1
;
}
mozilla
:
:
layers
:
:
TransactionId
nsRefreshDriver
:
:
GetTransactionId
(
bool
aThrottle
)
{
mOutstandingTransactionId
=
mOutstandingTransactionId
.
Next
(
)
;
mNextTransactionId
=
mNextTransactionId
.
Next
(
)
;
if
(
aThrottle
&
&
mOutstandingTransactionId
-
mCompletedTransaction
>
=
2
&
&
!
mWaitingForTransaction
&
&
!
mTestControllingRefreshes
)
{
mWaitingForTransaction
=
true
;
mSkippedPaints
=
false
;
mWarningThreshold
=
1
;
}
return
mNextTransactionId
;
}
mozilla
:
:
layers
:
:
TransactionId
nsRefreshDriver
:
:
LastTransactionId
(
)
const
{
return
mNextTransactionId
;
}
void
nsRefreshDriver
:
:
RevokeTransactionId
(
mozilla
:
:
layers
:
:
TransactionId
aTransactionId
)
{
MOZ_ASSERT
(
aTransactionId
=
=
mNextTransactionId
)
;
if
(
mOutstandingTransactionId
-
mCompletedTransaction
=
=
2
&
&
mWaitingForTransaction
)
{
MOZ_ASSERT
(
!
mSkippedPaints
"
How
did
we
skip
a
paint
when
we
'
re
in
the
middle
of
one
?
"
)
;
FinishedWaitingForTransaction
(
)
;
}
nsPresContext
*
pc
=
GetPresContext
(
)
;
if
(
pc
)
{
pc
-
>
NotifyRevokingDidPaint
(
aTransactionId
)
;
}
mOutstandingTransactionId
=
mOutstandingTransactionId
.
Prev
(
)
;
}
void
nsRefreshDriver
:
:
ClearPendingTransactions
(
)
{
mCompletedTransaction
=
mOutstandingTransactionId
=
mNextTransactionId
;
mWaitingForTransaction
=
false
;
}
void
nsRefreshDriver
:
:
ResetInitialTransactionId
(
mozilla
:
:
layers
:
:
TransactionId
aTransactionId
)
{
mCompletedTransaction
=
mOutstandingTransactionId
=
mNextTransactionId
=
aTransactionId
;
}
mozilla
:
:
TimeStamp
nsRefreshDriver
:
:
GetTransactionStart
(
)
{
return
mTickStart
;
}
VsyncId
nsRefreshDriver
:
:
GetVsyncId
(
)
{
return
mTickVsyncId
;
}
mozilla
:
:
TimeStamp
nsRefreshDriver
:
:
GetVsyncStart
(
)
{
return
mTickVsyncTime
;
}
void
nsRefreshDriver
:
:
NotifyTransactionCompleted
(
mozilla
:
:
layers
:
:
TransactionId
aTransactionId
)
{
if
(
aTransactionId
>
mCompletedTransaction
)
{
if
(
mOutstandingTransactionId
-
mCompletedTransaction
>
1
&
&
mWaitingForTransaction
)
{
mCompletedTransaction
=
aTransactionId
;
FinishedWaitingForTransaction
(
)
;
}
else
{
mCompletedTransaction
=
aTransactionId
;
}
}
if
(
mCompletedTransaction
>
mOutstandingTransactionId
)
{
mOutstandingTransactionId
=
mCompletedTransaction
;
}
}
void
nsRefreshDriver
:
:
WillRefresh
(
mozilla
:
:
TimeStamp
aTime
)
{
mRootRefresh
-
>
RemoveRefreshObserver
(
this
FlushType
:
:
Style
)
;
mRootRefresh
=
nullptr
;
if
(
mSkippedPaints
)
{
DoRefresh
(
)
;
}
}
bool
nsRefreshDriver
:
:
IsWaitingForPaint
(
mozilla
:
:
TimeStamp
aTime
)
{
if
(
mTestControllingRefreshes
)
{
return
false
;
}
if
(
mWaitingForTransaction
)
{
if
(
mSkippedPaints
&
&
aTime
>
(
mMostRecentRefresh
+
TimeDuration
:
:
FromMilliseconds
(
mWarningThreshold
*
1000
)
)
)
{
mWarningThreshold
*
=
2
;
}
mSkippedPaints
=
true
;
return
true
;
}
nsPresContext
*
pc
=
GetPresContext
(
)
;
nsPresContext
*
rootContext
=
pc
?
pc
-
>
GetRootPresContext
(
)
:
nullptr
;
if
(
rootContext
)
{
nsRefreshDriver
*
rootRefresh
=
rootContext
-
>
RefreshDriver
(
)
;
if
(
rootRefresh
&
&
rootRefresh
!
=
this
)
{
if
(
rootRefresh
-
>
IsWaitingForPaint
(
aTime
)
)
{
if
(
mRootRefresh
!
=
rootRefresh
)
{
if
(
mRootRefresh
)
{
mRootRefresh
-
>
RemoveRefreshObserver
(
this
FlushType
:
:
Style
)
;
}
rootRefresh
-
>
AddRefreshObserver
(
this
FlushType
:
:
Style
)
;
mRootRefresh
=
rootRefresh
;
}
mSkippedPaints
=
true
;
return
true
;
}
}
}
return
false
;
}
void
nsRefreshDriver
:
:
SetThrottled
(
bool
aThrottled
)
{
if
(
aThrottled
!
=
mThrottled
)
{
mThrottled
=
aThrottled
;
if
(
mActiveTimer
)
{
EnsureTimerStarted
(
eForceAdjustTimer
)
;
}
}
}
void
nsRefreshDriver
:
:
PVsyncActorCreated
(
VsyncChild
*
aVsyncChild
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
XRE_IsParentProcess
(
)
)
;
RefPtr
<
RefreshDriverTimer
>
vsyncRefreshDriverTimer
=
new
VsyncRefreshDriverTimer
(
aVsyncChild
)
;
if
(
sRegularRateTimer
)
{
sRegularRateTimer
-
>
SwapRefreshDrivers
(
vsyncRefreshDriverTimer
)
;
}
sRegularRateTimer
=
vsyncRefreshDriverTimer
.
forget
(
)
;
}
void
nsRefreshDriver
:
:
DoRefresh
(
)
{
if
(
!
IsFrozen
(
)
&
&
mPresContext
&
&
mActiveTimer
)
{
DoTick
(
)
;
}
}
#
ifdef
DEBUG
bool
nsRefreshDriver
:
:
IsRefreshObserver
(
nsARefreshObserver
*
aObserver
FlushType
aFlushType
)
{
ObserverArray
&
array
=
ArrayFor
(
aFlushType
)
;
return
array
.
Contains
(
aObserver
)
;
}
#
endif
void
nsRefreshDriver
:
:
ScheduleViewManagerFlush
(
)
{
NS_ASSERTION
(
mPresContext
-
>
IsRoot
(
)
"
Should
only
schedule
view
manager
flush
on
root
prescontexts
"
)
;
mViewManagerFlushIsPending
=
true
;
mHasScheduleFlush
=
true
;
EnsureTimerStarted
(
eNeverAdjustTimer
)
;
}
void
nsRefreshDriver
:
:
ScheduleFrameRequestCallbacks
(
Document
*
aDocument
)
{
NS_ASSERTION
(
mFrameRequestCallbackDocs
.
IndexOf
(
aDocument
)
=
=
mFrameRequestCallbackDocs
.
NoIndex
&
&
mThrottledFrameRequestCallbackDocs
.
IndexOf
(
aDocument
)
=
=
mThrottledFrameRequestCallbackDocs
.
NoIndex
"
Don
'
t
schedule
the
same
document
multiple
times
"
)
;
if
(
aDocument
-
>
ShouldThrottleFrameRequests
(
)
)
{
mThrottledFrameRequestCallbackDocs
.
AppendElement
(
aDocument
)
;
}
else
{
mFrameRequestCallbackDocs
.
AppendElement
(
aDocument
)
;
}
EnsureTimerStarted
(
)
;
}
void
nsRefreshDriver
:
:
RevokeFrameRequestCallbacks
(
Document
*
aDocument
)
{
mFrameRequestCallbackDocs
.
RemoveElement
(
aDocument
)
;
mThrottledFrameRequestCallbackDocs
.
RemoveElement
(
aDocument
)
;
}
void
nsRefreshDriver
:
:
ScheduleFullscreenEvent
(
UniquePtr
<
PendingFullscreenEvent
>
aEvent
)
{
mPendingFullscreenEvents
.
AppendElement
(
std
:
:
move
(
aEvent
)
)
;
EnsureTimerStarted
(
)
;
}
void
nsRefreshDriver
:
:
CancelPendingFullscreenEvents
(
Document
*
aDocument
)
{
for
(
auto
i
:
Reversed
(
IntegerRange
(
mPendingFullscreenEvents
.
Length
(
)
)
)
)
{
if
(
mPendingFullscreenEvents
[
i
]
-
>
Document
(
)
=
=
aDocument
)
{
mPendingFullscreenEvents
.
RemoveElementAt
(
i
)
;
}
}
}
void
nsRefreshDriver
:
:
CancelPendingAnimationEvents
(
AnimationEventDispatcher
*
aDispatcher
)
{
MOZ_ASSERT
(
aDispatcher
)
;
aDispatcher
-
>
ClearEventQueue
(
)
;
mAnimationEventFlushObservers
.
RemoveElement
(
aDispatcher
)
;
}
TimeStamp
nsRefreshDriver
:
:
GetIdleDeadlineHint
(
TimeStamp
aDefault
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
MOZ_ASSERT
(
!
aDefault
.
IsNull
(
)
)
;
if
(
!
sRegularRateTimer
)
{
return
aDefault
;
}
return
sRegularRateTimer
-
>
GetIdleDeadlineHint
(
aDefault
)
;
}
Maybe
<
TimeStamp
>
nsRefreshDriver
:
:
GetNextTickHint
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
if
(
!
sRegularRateTimer
)
{
return
Nothing
(
)
;
}
return
sRegularRateTimer
-
>
GetNextTickHint
(
)
;
}
void
nsRefreshDriver
:
:
Disconnect
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
StopTimer
(
)
;
if
(
mPresContext
)
{
mPresContext
=
nullptr
;
if
(
-
-
sRefreshDriverCount
=
=
0
)
{
Shutdown
(
)
;
}
}
}
bool
nsRefreshDriver
:
:
IsJankCritical
(
)
{
MOZ_ASSERT
(
NS_IsMainThread
(
)
)
;
return
sActiveVsyncTimers
>
0
;
}
bool
nsRefreshDriver
:
:
GetJankLevels
(
Vector
<
uint64_t
>
&
aJank
)
{
aJank
.
clear
(
)
;
return
aJank
.
append
(
sJankLevels
ArrayLength
(
sJankLevels
)
)
;
}
#
undef
LOG
