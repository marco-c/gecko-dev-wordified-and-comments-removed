#
include
"
nsLayoutUtils
.
h
"
#
include
<
algorithm
>
#
include
<
limits
>
#
include
"
ActiveLayerTracker
.
h
"
#
include
"
ClientLayerManager
.
h
"
#
include
"
DisplayItemClip
.
h
"
#
include
"
FrameLayerBuilder
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxDrawable
.
h
"
#
include
"
gfxEnv
.
h
"
#
include
"
gfxMatrix
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
gfxRect
.
h
"
#
include
"
gfxTypes
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
ImageOps
.
h
"
#
include
"
ImageRegion
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
imgIRequest
.
h
"
#
include
"
Layers
.
h
"
#
include
"
LayoutLogging
.
h
"
#
include
"
MobileViewportManager
.
h
"
#
include
"
mozilla
/
AccessibleCaretEventHub
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
#
include
"
mozilla
/
DisplayPortUtils
.
h
"
#
include
"
mozilla
/
dom
/
AnonymousContent
.
h
"
#
include
"
mozilla
/
dom
/
BrowserChild
.
h
"
#
include
"
mozilla
/
dom
/
CanvasUtils
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
include
"
mozilla
/
dom
/
DOMRect
.
h
"
#
include
"
mozilla
/
dom
/
DOMStringList
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
HTMLBodyElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLCanvasElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLImageElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLMediaElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
HTMLVideoElement
.
h
"
#
include
"
mozilla
/
dom
/
InspectorFontFace
.
h
"
#
include
"
mozilla
/
dom
/
KeyframeEffect
.
h
"
#
include
"
mozilla
/
dom
/
SVGViewportElement
.
h
"
#
include
"
mozilla
/
EffectCompositor
.
h
"
#
include
"
mozilla
/
EffectSet
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
gfxVars
.
h
"
#
include
"
mozilla
/
gfx
/
PathHelpers
.
h
"
#
include
"
mozilla
/
layers
/
APZCCallbackHelper
.
h
"
#
include
"
mozilla
/
layers
/
APZPublicUtils
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeChild
.
h
"
#
include
"
mozilla
/
layers
/
PAPZ
.
h
"
#
include
"
mozilla
/
layers
/
StackingContextHelper
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderLayerManager
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
PerfStats
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
mozilla
/
ScrollOrigin
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
mozilla
/
ServoStyleSetInlines
.
h
"
#
include
"
mozilla
/
StaticPrefs_apz
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
StaticPrefs_font
.
h
"
#
include
"
mozilla
/
StaticPrefs_gfx
.
h
"
#
include
"
mozilla
/
StaticPrefs_image
.
h
"
#
include
"
mozilla
/
StaticPrefs_layers
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
mozilla
/
StyleAnimationValue
.
h
"
#
include
"
mozilla
/
SVGImageContext
.
h
"
#
include
"
mozilla
/
SVGIntegrationUtils
.
h
"
#
include
"
mozilla
/
SVGTextFrame
.
h
"
#
include
"
mozilla
/
SVGUtils
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
mozilla
/
ToString
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
ViewportFrame
.
h
"
#
include
"
mozilla
/
ViewportUtils
.
h
"
#
include
"
mozilla
/
WheelHandlingHelper
.
h
"
#
include
"
nsAnimationManager
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsBidiPresUtils
.
h
"
#
include
"
nsBlockFrame
.
h
"
#
include
"
nsCanvasFrame
.
h
"
#
include
"
nsCaret
.
h
"
#
include
"
nsCharTraits
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsComputedDOMStyle
.
h
"
#
include
"
nsCSSAnonBoxes
.
h
"
#
include
"
nsCSSColorUtils
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
nsCSSProps
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsCSSRendering
.
h
"
#
include
"
nsDataHashtable
.
h
"
#
include
"
nsDeckFrame
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsFlexContainerFrame
.
h
"
#
include
"
nsFontInflationData
.
h
"
#
include
"
nsFontMetrics
.
h
"
#
include
"
nsFrameList
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsICanvasRenderingContextInternal
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentViewer
.
h
"
#
include
"
nsIDocShell
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsIImageLoadingContent
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsIWidget
.
h
"
#
include
"
nsListControlFrame
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsPlaceholderFrame
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsPresContextInlines
.
h
"
#
include
"
nsRefreshDriver
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsStyleStructInlines
.
h
"
#
include
"
nsStyleTransformMatrix
.
h
"
#
include
"
nsSubDocumentFrame
.
h
"
#
include
"
nsTableWrapperFrame
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
"
nsTextFrame
.
h
"
#
include
"
nsTransitionManager
.
h
"
#
include
"
nsView
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
prenv
.
h
"
#
include
"
RegionBuilder
.
h
"
#
include
"
RetainedDisplayListBuilder
.
h
"
#
include
"
TextDrawTarget
.
h
"
#
include
"
TiledLayerBuffer
.
h
"
#
include
"
UnitTransforms
.
h
"
#
include
"
ViewportFrame
.
h
"
#
ifdef
MOZ_XUL
#
include
"
nsXULPopupManager
.
h
"
#
endif
#
ifdef
XP_WIN
#
include
<
process
.
h
>
#
define
getpid
_getpid
#
else
#
include
<
unistd
.
h
>
#
endif
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
image
;
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
layout
;
using
namespace
mozilla
:
:
gfx
;
using
mozilla
:
:
dom
:
:
HTMLMediaElement_Binding
:
:
HAVE_METADATA
;
using
mozilla
:
:
dom
:
:
HTMLMediaElement_Binding
:
:
HAVE_NOTHING
;
#
ifdef
DEBUG
bool
nsLayoutUtils
:
:
gPreventAssertInCompareTreePosition
=
false
;
#
endif
typedef
ScrollableLayerGuid
:
:
ViewID
ViewID
;
typedef
nsStyleTransformMatrix
:
:
TransformReferenceBox
TransformReferenceBox
;
static
ViewID
sScrollIdCounter
=
ScrollableLayerGuid
:
:
START_SCROLL_ID
;
typedef
nsDataHashtable
<
nsUint64HashKey
nsIContent
*
>
ContentMap
;
static
ContentMap
*
sContentMap
=
nullptr
;
static
ContentMap
&
GetContentMap
(
)
{
if
(
!
sContentMap
)
{
sContentMap
=
new
ContentMap
(
)
;
}
return
*
sContentMap
;
}
template
<
typename
TestType
>
static
bool
HasMatchingAnimations
(
EffectSet
&
aEffects
TestType
&
&
aTest
)
{
for
(
KeyframeEffect
*
effect
:
aEffects
)
{
if
(
!
effect
-
>
GetAnimation
(
)
|
|
!
effect
-
>
GetAnimation
(
)
-
>
IsRelevant
(
)
)
{
continue
;
}
if
(
aTest
(
*
effect
aEffects
)
)
{
return
true
;
}
}
return
false
;
}
template
<
typename
TestType
>
static
bool
HasMatchingAnimations
(
const
nsIFrame
*
aFrame
const
nsCSSPropertyIDSet
&
aPropertySet
TestType
&
&
aTest
)
{
MOZ_ASSERT
(
aFrame
)
;
if
(
aPropertySet
.
IsSubsetOf
(
nsCSSPropertyIDSet
:
:
OpacityProperties
(
)
)
&
&
!
aFrame
-
>
MayHaveOpacityAnimation
(
)
)
{
return
false
;
}
if
(
aPropertySet
.
IsSubsetOf
(
nsCSSPropertyIDSet
:
:
TransformLikeProperties
(
)
)
&
&
!
aFrame
-
>
MayHaveTransformAnimation
(
)
)
{
return
false
;
}
EffectSet
*
effectSet
=
EffectSet
:
:
GetEffectSetForFrame
(
aFrame
aPropertySet
)
;
if
(
!
effectSet
)
{
return
false
;
}
return
HasMatchingAnimations
(
*
effectSet
aTest
)
;
}
bool
nsLayoutUtils
:
:
HasAnimationOfPropertySet
(
const
nsIFrame
*
aFrame
const
nsCSSPropertyIDSet
&
aPropertySet
)
{
return
HasMatchingAnimations
(
aFrame
aPropertySet
[
&
aPropertySet
]
(
KeyframeEffect
&
aEffect
const
EffectSet
&
)
{
return
aEffect
.
HasAnimationOfPropertySet
(
aPropertySet
)
;
}
)
;
}
bool
nsLayoutUtils
:
:
HasAnimationOfPropertySet
(
const
nsIFrame
*
aFrame
const
nsCSSPropertyIDSet
&
aPropertySet
EffectSet
*
aEffectSet
)
{
MOZ_ASSERT
(
!
aEffectSet
|
|
EffectSet
:
:
GetEffectSetForFrame
(
aFrame
aPropertySet
)
=
=
aEffectSet
"
The
EffectSet
if
supplied
should
match
what
we
would
otherwise
fetch
"
)
;
if
(
!
aEffectSet
)
{
return
nsLayoutUtils
:
:
HasAnimationOfPropertySet
(
aFrame
aPropertySet
)
;
}
if
(
aPropertySet
.
IsSubsetOf
(
nsCSSPropertyIDSet
:
:
TransformLikeProperties
(
)
)
&
&
!
aEffectSet
-
>
MayHaveTransformAnimation
(
)
)
{
return
false
;
}
if
(
aPropertySet
.
IsSubsetOf
(
nsCSSPropertyIDSet
:
:
OpacityProperties
(
)
)
&
&
!
aEffectSet
-
>
MayHaveOpacityAnimation
(
)
)
{
return
false
;
}
return
HasMatchingAnimations
(
*
aEffectSet
[
&
aPropertySet
]
(
KeyframeEffect
&
aEffect
const
EffectSet
&
aEffectSet
)
{
return
aEffect
.
HasAnimationOfPropertySet
(
aPropertySet
)
;
}
)
;
}
bool
nsLayoutUtils
:
:
HasAnimationOfTransformAndMotionPath
(
const
nsIFrame
*
aFrame
)
{
return
nsLayoutUtils
:
:
HasAnimationOfPropertySet
(
aFrame
nsCSSPropertyIDSet
{
eCSSProperty_transform
eCSSProperty_translate
eCSSProperty_rotate
eCSSProperty_scale
eCSSProperty_offset_path
}
)
|
|
(
!
aFrame
-
>
StyleDisplay
(
)
-
>
mOffsetPath
.
IsNone
(
)
&
&
nsLayoutUtils
:
:
HasAnimationOfPropertySet
(
aFrame
nsCSSPropertyIDSet
:
:
MotionPathProperties
(
)
)
)
;
}
bool
nsLayoutUtils
:
:
HasEffectiveAnimation
(
const
nsIFrame
*
aFrame
const
nsCSSPropertyIDSet
&
aPropertySet
)
{
return
HasMatchingAnimations
(
aFrame
aPropertySet
[
&
aPropertySet
]
(
KeyframeEffect
&
aEffect
const
EffectSet
&
aEffectSet
)
{
return
aEffect
.
HasEffectiveAnimationOfPropertySet
(
aPropertySet
aEffectSet
)
;
}
)
;
}
nsCSSPropertyIDSet
nsLayoutUtils
:
:
GetAnimationPropertiesForCompositor
(
const
nsIFrame
*
aStyleFrame
)
{
nsCSSPropertyIDSet
properties
;
EffectSet
*
effects
=
EffectSet
:
:
GetEffectSetForStyleFrame
(
aStyleFrame
)
;
if
(
!
effects
)
{
return
properties
;
}
AnimationPerformanceWarning
:
:
Type
warning
;
if
(
!
EffectCompositor
:
:
AllowCompositorAnimationsOnFrame
(
aStyleFrame
warning
)
)
{
return
properties
;
}
for
(
const
KeyframeEffect
*
effect
:
*
effects
)
{
properties
|
=
effect
-
>
GetPropertiesForCompositor
(
*
effects
aStyleFrame
)
;
}
if
(
properties
.
IsSubsetOf
(
nsCSSPropertyIDSet
:
:
MotionPathProperties
(
)
)
&
&
!
properties
.
HasProperty
(
eCSSProperty_offset_path
)
&
&
aStyleFrame
-
>
StyleDisplay
(
)
-
>
mOffsetPath
.
IsNone
(
)
)
{
properties
.
Empty
(
)
;
}
return
properties
;
}
static
float
GetSuitableScale
(
float
aMaxScale
float
aMinScale
nscoord
aVisibleDimension
nscoord
aDisplayDimension
)
{
float
displayVisibleRatio
=
float
(
aDisplayDimension
)
/
float
(
aVisibleDimension
)
;
if
(
FuzzyEqualsMultiplicative
(
displayVisibleRatio
aMaxScale
.
01f
)
)
{
return
aMaxScale
;
}
return
std
:
:
max
(
std
:
:
min
(
aMaxScale
displayVisibleRatio
)
aMinScale
)
;
}
using
MinAndMaxScale
=
std
:
:
pair
<
Size
Size
>
;
static
inline
void
UpdateMinMaxScale
(
const
nsIFrame
*
aFrame
const
AnimationValue
&
aValue
MinAndMaxScale
&
aMinAndMaxScale
)
{
Size
size
=
aValue
.
GetScaleValue
(
aFrame
)
;
Size
&
minScale
=
aMinAndMaxScale
.
first
;
Size
&
maxScale
=
aMinAndMaxScale
.
second
;
minScale
=
Min
(
minScale
size
)
;
maxScale
=
Max
(
maxScale
size
)
;
}
static
Array
<
MinAndMaxScale
2
>
GetMinAndMaxScaleForAnimationProperty
(
const
nsIFrame
*
aFrame
const
nsTArray
<
RefPtr
<
dom
:
:
Animation
>
>
&
aAnimations
)
{
const
MinAndMaxScale
defaultValue
=
std
:
:
make_pair
(
Size
(
std
:
:
numeric_limits
<
float
>
:
:
max
(
)
std
:
:
numeric_limits
<
float
>
:
:
max
(
)
)
Size
(
std
:
:
numeric_limits
<
float
>
:
:
min
(
)
std
:
:
numeric_limits
<
float
>
:
:
min
(
)
)
)
;
Array
<
MinAndMaxScale
2
>
minAndMaxScales
(
defaultValue
defaultValue
)
;
for
(
dom
:
:
Animation
*
anim
:
aAnimations
)
{
MOZ_ASSERT
(
anim
-
>
IsRelevant
(
)
)
;
const
dom
:
:
KeyframeEffect
*
effect
=
anim
-
>
GetEffect
(
)
?
anim
-
>
GetEffect
(
)
-
>
AsKeyframeEffect
(
)
:
nullptr
;
MOZ_ASSERT
(
effect
"
A
playing
animation
should
have
a
keyframe
effect
"
)
;
for
(
const
AnimationProperty
&
prop
:
effect
-
>
Properties
(
)
)
{
if
(
prop
.
mProperty
!
=
eCSSProperty_transform
&
&
prop
.
mProperty
!
=
eCSSProperty_scale
)
{
continue
;
}
MinAndMaxScale
&
scales
=
minAndMaxScales
[
prop
.
mProperty
=
=
eCSSProperty_transform
?
0
:
1
]
;
const
AnimationValue
&
baseStyle
=
effect
-
>
BaseStyle
(
prop
.
mProperty
)
;
if
(
!
baseStyle
.
IsNull
(
)
)
{
UpdateMinMaxScale
(
aFrame
baseStyle
scales
)
;
}
for
(
const
AnimationPropertySegment
&
segment
:
prop
.
mSegments
)
{
if
(
segment
.
HasReplaceableFromValue
(
)
)
{
UpdateMinMaxScale
(
aFrame
segment
.
mFromValue
scales
)
;
}
if
(
segment
.
HasReplaceableToValue
(
)
)
{
UpdateMinMaxScale
(
aFrame
segment
.
mToValue
scales
)
;
}
}
}
}
return
minAndMaxScales
;
}
Size
nsLayoutUtils
:
:
ComputeSuitableScaleForAnimation
(
const
nsIFrame
*
aFrame
const
nsSize
&
aVisibleSize
const
nsSize
&
aDisplaySize
)
{
const
nsTArray
<
RefPtr
<
dom
:
:
Animation
>
>
compositorAnimations
=
EffectCompositor
:
:
GetAnimationsForCompositor
(
aFrame
nsCSSPropertyIDSet
{
eCSSProperty_transform
eCSSProperty_scale
}
)
;
if
(
compositorAnimations
.
IsEmpty
(
)
)
{
return
Size
(
1
.
0
1
.
0
)
;
}
const
Array
<
MinAndMaxScale
2
>
minAndMaxScales
=
GetMinAndMaxScaleForAnimationProperty
(
aFrame
compositorAnimations
)
;
Size
maxScale
(
std
:
:
numeric_limits
<
float
>
:
:
min
(
)
std
:
:
numeric_limits
<
float
>
:
:
min
(
)
)
;
Size
minScale
(
std
:
:
numeric_limits
<
float
>
:
:
max
(
)
std
:
:
numeric_limits
<
float
>
:
:
max
(
)
)
;
auto
isUnset
=
[
]
(
const
Size
&
aMax
const
Size
&
aMin
)
{
return
aMax
.
width
=
=
std
:
:
numeric_limits
<
float
>
:
:
min
(
)
&
&
aMax
.
height
=
=
std
:
:
numeric_limits
<
float
>
:
:
min
(
)
&
&
aMin
.
width
=
=
std
:
:
numeric_limits
<
float
>
:
:
max
(
)
&
&
aMin
.
height
=
=
std
:
:
numeric_limits
<
float
>
:
:
max
(
)
;
}
;
for
(
const
auto
&
pair
:
minAndMaxScales
)
{
const
Size
&
currMinScale
=
pair
.
first
;
const
Size
&
currMaxScale
=
pair
.
second
;
if
(
isUnset
(
currMaxScale
currMinScale
)
)
{
continue
;
}
if
(
isUnset
(
maxScale
minScale
)
)
{
maxScale
=
currMaxScale
;
minScale
=
currMinScale
;
}
else
{
maxScale
=
maxScale
*
currMaxScale
;
minScale
=
minScale
*
currMinScale
;
}
}
if
(
isUnset
(
maxScale
minScale
)
)
{
return
Size
(
1
.
0
1
.
0
)
;
}
return
Size
(
GetSuitableScale
(
maxScale
.
width
minScale
.
width
aVisibleSize
.
width
aDisplaySize
.
width
)
GetSuitableScale
(
maxScale
.
height
minScale
.
height
aVisibleSize
.
height
aDisplaySize
.
height
)
)
;
}
bool
nsLayoutUtils
:
:
AreAsyncAnimationsEnabled
(
)
{
return
StaticPrefs
:
:
layers_offmainthreadcomposition_async_animations
(
)
&
&
gfxPlatform
:
:
OffMainThreadCompositingEnabled
(
)
;
}
bool
nsLayoutUtils
:
:
AreRetainedDisplayListsEnabled
(
)
{
#
ifdef
MOZ_WIDGET_ANDROID
return
StaticPrefs
:
:
layout_display_list_retain
(
)
;
#
else
if
(
XRE_IsContentProcess
(
)
)
{
return
StaticPrefs
:
:
layout_display_list_retain
(
)
;
}
if
(
XRE_IsE10sParentProcess
(
)
)
{
return
StaticPrefs
:
:
layout_display_list_retain_chrome
(
)
;
}
return
false
;
#
endif
}
bool
nsLayoutUtils
:
:
DisplayRootHasRetainedDisplayListBuilder
(
nsIFrame
*
aFrame
)
{
const
nsIFrame
*
displayRoot
=
nsLayoutUtils
:
:
GetDisplayRootFrame
(
aFrame
)
;
MOZ_ASSERT
(
displayRoot
)
;
return
displayRoot
-
>
HasProperty
(
RetainedDisplayListBuilder
:
:
Cached
(
)
)
;
}
bool
nsLayoutUtils
:
:
GPUImageScalingEnabled
(
)
{
static
bool
sGPUImageScalingEnabled
;
static
bool
sGPUImageScalingPrefInitialised
=
false
;
if
(
!
sGPUImageScalingPrefInitialised
)
{
sGPUImageScalingPrefInitialised
=
true
;
sGPUImageScalingEnabled
=
Preferences
:
:
GetBool
(
"
layout
.
gpu
-
image
-
scaling
.
enabled
"
false
)
;
}
return
sGPUImageScalingEnabled
;
}
void
nsLayoutUtils
:
:
UnionChildOverflow
(
nsIFrame
*
aFrame
OverflowAreas
&
aOverflowAreas
FrameChildListIDs
aSkipChildLists
)
{
FrameChildListIDs
skip
(
aSkipChildLists
)
;
skip
+
=
{
nsIFrame
:
:
kSelectPopupList
nsIFrame
:
:
kPopupList
}
;
for
(
const
auto
&
[
list
listID
]
:
aFrame
-
>
ChildLists
(
)
)
{
if
(
skip
.
contains
(
listID
)
)
{
continue
;
}
for
(
nsIFrame
*
child
:
list
)
{
OverflowAreas
childOverflow
=
child
-
>
GetOverflowAreas
(
)
+
child
-
>
GetPosition
(
)
;
aOverflowAreas
.
UnionWith
(
childOverflow
)
;
}
}
}
static
void
DestroyViewID
(
void
*
aObject
nsAtom
*
aPropertyName
void
*
aPropertyValue
void
*
aData
)
{
ViewID
*
id
=
static_cast
<
ViewID
*
>
(
aPropertyValue
)
;
GetContentMap
(
)
.
Remove
(
*
id
)
;
delete
id
;
}
bool
nsLayoutUtils
:
:
FindIDFor
(
const
nsIContent
*
aContent
ViewID
*
aOutViewId
)
{
void
*
scrollIdProperty
=
aContent
-
>
GetProperty
(
nsGkAtoms
:
:
RemoteId
)
;
if
(
scrollIdProperty
)
{
*
aOutViewId
=
*
static_cast
<
ViewID
*
>
(
scrollIdProperty
)
;
return
true
;
}
return
false
;
}
ViewID
nsLayoutUtils
:
:
FindOrCreateIDFor
(
nsIContent
*
aContent
)
{
ViewID
scrollId
;
if
(
!
FindIDFor
(
aContent
&
scrollId
)
)
{
scrollId
=
sScrollIdCounter
+
+
;
aContent
-
>
SetProperty
(
nsGkAtoms
:
:
RemoteId
new
ViewID
(
scrollId
)
DestroyViewID
)
;
GetContentMap
(
)
.
Put
(
scrollId
aContent
)
;
}
return
scrollId
;
}
nsIContent
*
nsLayoutUtils
:
:
FindContentFor
(
ViewID
aId
)
{
MOZ_ASSERT
(
aId
!
=
ScrollableLayerGuid
:
:
NULL_SCROLL_ID
"
Cannot
find
a
content
element
in
map
for
null
IDs
.
"
)
;
nsIContent
*
content
;
bool
exists
=
GetContentMap
(
)
.
Get
(
aId
&
content
)
;
if
(
exists
)
{
return
content
;
}
else
{
return
nullptr
;
}
}
nsIFrame
*
nsLayoutUtils
:
:
GetScrollFrameFromContent
(
nsIContent
*
aContent
)
{
nsIFrame
*
frame
=
aContent
-
>
GetPrimaryFrame
(
)
;
if
(
aContent
-
>
OwnerDoc
(
)
-
>
GetRootElement
(
)
=
=
aContent
)
{
PresShell
*
presShell
=
frame
?
frame
-
>
PresShell
(
)
:
nullptr
;
if
(
!
presShell
)
{
presShell
=
aContent
-
>
OwnerDoc
(
)
-
>
GetPresShell
(
)
;
}
nsIFrame
*
rootScrollFrame
=
presShell
?
presShell
-
>
GetRootScrollFrame
(
)
:
nullptr
;
if
(
rootScrollFrame
)
{
frame
=
rootScrollFrame
;
}
}
return
frame
;
}
nsIScrollableFrame
*
nsLayoutUtils
:
:
FindScrollableFrameFor
(
nsIContent
*
aContent
)
{
nsIFrame
*
scrollFrame
=
GetScrollFrameFromContent
(
aContent
)
;
return
scrollFrame
?
scrollFrame
-
>
GetScrollTargetFrame
(
)
:
nullptr
;
}
nsIScrollableFrame
*
nsLayoutUtils
:
:
FindScrollableFrameFor
(
ViewID
aId
)
{
nsIContent
*
content
=
FindContentFor
(
aId
)
;
if
(
!
content
)
{
return
nullptr
;
}
return
FindScrollableFrameFor
(
content
)
;
}
ViewID
nsLayoutUtils
:
:
FindIDForScrollableFrame
(
nsIScrollableFrame
*
aScrollable
)
{
if
(
!
aScrollable
)
{
return
ScrollableLayerGuid
:
:
NULL_SCROLL_ID
;
}
nsIFrame
*
scrollFrame
=
do_QueryFrame
(
aScrollable
)
;
nsIContent
*
scrollContent
=
scrollFrame
-
>
GetContent
(
)
;
ScrollableLayerGuid
:
:
ViewID
scrollId
;
if
(
scrollContent
&
&
nsLayoutUtils
:
:
FindIDFor
(
scrollContent
&
scrollId
)
)
{
return
scrollId
;
}
return
ScrollableLayerGuid
:
:
NULL_SCROLL_ID
;
}
bool
nsLayoutUtils
:
:
UsesAsyncScrolling
(
nsIFrame
*
aFrame
)
{
#
ifdef
MOZ_WIDGET_ANDROID
return
true
;
#
endif
return
AsyncPanZoomEnabled
(
aFrame
)
;
}
bool
nsLayoutUtils
:
:
AsyncPanZoomEnabled
(
const
nsIFrame
*
aFrame
)
{
if
(
!
gfxPlatform
:
:
AsyncPanZoomEnabled
(
)
)
{
return
false
;
}
const
nsIFrame
*
frame
=
nsLayoutUtils
:
:
GetDisplayRootFrame
(
aFrame
)
;
nsIWidget
*
widget
=
frame
-
>
GetNearestWidget
(
)
;
if
(
!
widget
)
{
return
false
;
}
return
widget
-
>
AsyncPanZoomEnabled
(
)
;
}
bool
nsLayoutUtils
:
:
AllowZoomingForDocument
(
const
mozilla
:
:
dom
:
:
Document
*
aDocument
)
{
BrowsingContext
*
bc
=
aDocument
?
aDocument
-
>
GetBrowsingContext
(
)
:
nullptr
;
return
StaticPrefs
:
:
apz_allow_zooming
(
)
|
|
(
bc
&
&
bc
-
>
InRDMPane
(
)
&
&
nsLayoutUtils
:
:
ShouldHandleMetaViewport
(
aDocument
)
)
;
}
float
nsLayoutUtils
:
:
GetCurrentAPZResolutionScale
(
PresShell
*
aPresShell
)
{
return
aPresShell
?
aPresShell
-
>
GetCumulativeResolution
(
)
:
1
.
0
;
}
static
bool
HasVisibleAnonymousContents
(
Document
*
aDoc
)
{
for
(
RefPtr
<
AnonymousContent
>
&
ac
:
aDoc
-
>
GetAnonymousContents
(
)
)
{
if
(
ac
-
>
ContentNode
(
)
.
GetPrimaryFrame
(
)
)
{
return
true
;
}
}
return
false
;
}
bool
nsLayoutUtils
:
:
ShouldDisableApzForElement
(
nsIContent
*
aContent
)
{
if
(
!
aContent
)
{
return
false
;
}
if
(
aContent
-
>
GetProperty
(
nsGkAtoms
:
:
apzDisabled
)
)
{
return
true
;
}
Document
*
doc
=
aContent
-
>
GetComposedDoc
(
)
;
if
(
PresShell
*
rootPresShell
=
APZCCallbackHelper
:
:
GetRootContentDocumentPresShellForContent
(
aContent
)
)
{
if
(
Document
*
rootDoc
=
rootPresShell
-
>
GetDocument
(
)
)
{
nsIContent
*
rootContent
=
rootPresShell
-
>
GetRootScrollFrame
(
)
?
rootPresShell
-
>
GetRootScrollFrame
(
)
-
>
GetContent
(
)
:
rootDoc
-
>
GetDocumentElement
(
)
;
if
(
aContent
!
=
rootContent
&
&
HasVisibleAnonymousContents
(
rootDoc
)
)
{
return
true
;
}
}
}
if
(
!
doc
)
{
return
false
;
}
if
(
PresShell
*
presShell
=
doc
-
>
GetPresShell
(
)
)
{
if
(
RefPtr
<
AccessibleCaretEventHub
>
eventHub
=
presShell
-
>
GetAccessibleCaretEventHub
(
)
)
{
if
(
eventHub
-
>
ShouldDisableApz
(
)
)
{
return
true
;
}
}
}
return
StaticPrefs
:
:
apz_disable_for_scroll_linked_effects
(
)
&
&
doc
-
>
HasScrollLinkedEffect
(
)
;
}
void
nsLayoutUtils
:
:
NotifyPaintSkipTransaction
(
ViewID
aScrollId
)
{
if
(
nsIScrollableFrame
*
scrollFrame
=
nsLayoutUtils
:
:
FindScrollableFrameFor
(
aScrollId
)
)
{
#
ifdef
DEBUG
nsIFrame
*
f
=
do_QueryFrame
(
scrollFrame
)
;
MOZ_ASSERT
(
f
&
&
f
-
>
PresShell
(
)
&
&
!
f
-
>
PresShell
(
)
-
>
IsResolutionUpdated
(
)
)
;
#
endif
scrollFrame
-
>
NotifyApzTransaction
(
)
;
}
}
nsContainerFrame
*
nsLayoutUtils
:
:
LastContinuationWithChild
(
nsContainerFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
"
NULL
frame
pointer
"
)
;
for
(
auto
f
=
aFrame
-
>
LastContinuation
(
)
;
f
;
f
=
f
-
>
GetPrevContinuation
(
)
)
{
for
(
const
auto
&
childList
:
f
-
>
ChildLists
(
)
)
{
if
(
MOZ_LIKELY
(
!
childList
.
mList
.
IsEmpty
(
)
)
)
{
return
static_cast
<
nsContainerFrame
*
>
(
f
)
;
}
}
}
return
aFrame
;
}
FrameChildListID
nsLayoutUtils
:
:
GetChildListNameFor
(
nsIFrame
*
aChildFrame
)
{
nsIFrame
:
:
ChildListID
id
=
nsIFrame
:
:
kPrincipalList
;
MOZ_DIAGNOSTIC_ASSERT
(
!
aChildFrame
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
)
;
if
(
aChildFrame
-
>
HasAnyStateBits
(
NS_FRAME_IS_OVERFLOW_CONTAINER
)
)
{
nsIFrame
*
pif
=
aChildFrame
-
>
GetPrevInFlow
(
)
;
if
(
pif
-
>
GetParent
(
)
=
=
aChildFrame
-
>
GetParent
(
)
)
{
id
=
nsIFrame
:
:
kExcessOverflowContainersList
;
}
else
{
id
=
nsIFrame
:
:
kOverflowContainersList
;
}
}
else
{
LayoutFrameType
childType
=
aChildFrame
-
>
Type
(
)
;
if
(
LayoutFrameType
:
:
MenuPopup
=
=
childType
)
{
nsIFrame
*
parent
=
aChildFrame
-
>
GetParent
(
)
;
MOZ_ASSERT
(
parent
"
nsMenuPopupFrame
can
'
t
be
the
root
frame
"
)
;
if
(
parent
)
{
if
(
parent
-
>
IsPopupSetFrame
(
)
)
{
id
=
nsIFrame
:
:
kPopupList
;
}
else
{
nsIFrame
*
firstPopup
=
parent
-
>
GetChildList
(
nsIFrame
:
:
kPopupList
)
.
FirstChild
(
)
;
MOZ_ASSERT
(
!
firstPopup
|
|
!
firstPopup
-
>
GetNextSibling
(
)
"
We
assume
popupList
only
has
one
child
but
it
has
more
.
"
)
;
id
=
firstPopup
=
=
aChildFrame
?
nsIFrame
:
:
kPopupList
:
nsIFrame
:
:
kPrincipalList
;
}
}
else
{
id
=
nsIFrame
:
:
kPrincipalList
;
}
}
else
if
(
LayoutFrameType
:
:
TableColGroup
=
=
childType
)
{
id
=
nsIFrame
:
:
kColGroupList
;
}
else
if
(
aChildFrame
-
>
IsTableCaption
(
)
)
{
id
=
nsIFrame
:
:
kCaptionList
;
}
else
{
id
=
nsIFrame
:
:
kPrincipalList
;
}
}
#
ifdef
DEBUG
nsContainerFrame
*
parent
=
aChildFrame
-
>
GetParent
(
)
;
bool
found
=
parent
-
>
GetChildList
(
id
)
.
ContainsFrame
(
aChildFrame
)
;
if
(
!
found
)
{
found
=
parent
-
>
GetChildList
(
nsIFrame
:
:
kOverflowList
)
.
ContainsFrame
(
aChildFrame
)
;
MOZ_ASSERT
(
found
"
not
in
child
list
"
)
;
}
#
endif
return
id
;
}
static
Element
*
GetPseudo
(
const
nsIContent
*
aContent
nsAtom
*
aPseudoProperty
)
{
MOZ_ASSERT
(
aPseudoProperty
=
=
nsGkAtoms
:
:
beforePseudoProperty
|
|
aPseudoProperty
=
=
nsGkAtoms
:
:
afterPseudoProperty
|
|
aPseudoProperty
=
=
nsGkAtoms
:
:
markerPseudoProperty
)
;
if
(
!
aContent
-
>
MayHaveAnonymousChildren
(
)
)
{
return
nullptr
;
}
return
static_cast
<
Element
*
>
(
aContent
-
>
GetProperty
(
aPseudoProperty
)
)
;
}
Element
*
nsLayoutUtils
:
:
GetBeforePseudo
(
const
nsIContent
*
aContent
)
{
return
GetPseudo
(
aContent
nsGkAtoms
:
:
beforePseudoProperty
)
;
}
nsIFrame
*
nsLayoutUtils
:
:
GetBeforeFrame
(
const
nsIContent
*
aContent
)
{
Element
*
pseudo
=
GetBeforePseudo
(
aContent
)
;
return
pseudo
?
pseudo
-
>
GetPrimaryFrame
(
)
:
nullptr
;
}
Element
*
nsLayoutUtils
:
:
GetAfterPseudo
(
const
nsIContent
*
aContent
)
{
return
GetPseudo
(
aContent
nsGkAtoms
:
:
afterPseudoProperty
)
;
}
nsIFrame
*
nsLayoutUtils
:
:
GetAfterFrame
(
const
nsIContent
*
aContent
)
{
Element
*
pseudo
=
GetAfterPseudo
(
aContent
)
;
return
pseudo
?
pseudo
-
>
GetPrimaryFrame
(
)
:
nullptr
;
}
Element
*
nsLayoutUtils
:
:
GetMarkerPseudo
(
const
nsIContent
*
aContent
)
{
return
GetPseudo
(
aContent
nsGkAtoms
:
:
markerPseudoProperty
)
;
}
nsIFrame
*
nsLayoutUtils
:
:
GetMarkerFrame
(
const
nsIContent
*
aContent
)
{
Element
*
pseudo
=
GetMarkerPseudo
(
aContent
)
;
return
pseudo
?
pseudo
-
>
GetPrimaryFrame
(
)
:
nullptr
;
}
nsIFrame
*
nsLayoutUtils
:
:
GetClosestFrameOfType
(
nsIFrame
*
aFrame
LayoutFrameType
aFrameType
nsIFrame
*
aStopAt
)
{
for
(
nsIFrame
*
frame
=
aFrame
;
frame
;
frame
=
frame
-
>
GetParent
(
)
)
{
if
(
frame
-
>
Type
(
)
=
=
aFrameType
)
{
return
frame
;
}
if
(
frame
=
=
aStopAt
)
{
break
;
}
}
return
nullptr
;
}
nsIFrame
*
nsLayoutUtils
:
:
GetPageFrame
(
nsIFrame
*
aFrame
)
{
return
GetClosestFrameOfType
(
aFrame
LayoutFrameType
:
:
Page
)
;
}
nsIFrame
*
nsLayoutUtils
:
:
GetStyleFrame
(
nsIFrame
*
aPrimaryFrame
)
{
MOZ_ASSERT
(
aPrimaryFrame
)
;
if
(
aPrimaryFrame
-
>
IsTableWrapperFrame
(
)
)
{
nsIFrame
*
inner
=
aPrimaryFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
return
inner
;
}
return
aPrimaryFrame
;
}
const
nsIFrame
*
nsLayoutUtils
:
:
GetStyleFrame
(
const
nsIFrame
*
aPrimaryFrame
)
{
return
nsLayoutUtils
:
:
GetStyleFrame
(
const_cast
<
nsIFrame
*
>
(
aPrimaryFrame
)
)
;
}
nsIFrame
*
nsLayoutUtils
:
:
GetStyleFrame
(
const
nsIContent
*
aContent
)
{
nsIFrame
*
frame
=
aContent
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
)
{
return
nullptr
;
}
return
nsLayoutUtils
:
:
GetStyleFrame
(
frame
)
;
}
nsIFrame
*
nsLayoutUtils
:
:
GetPrimaryFrameFromStyleFrame
(
nsIFrame
*
aStyleFrame
)
{
nsIFrame
*
parent
=
aStyleFrame
-
>
GetParent
(
)
;
return
parent
&
&
parent
-
>
IsTableWrapperFrame
(
)
?
parent
:
aStyleFrame
;
}
const
nsIFrame
*
nsLayoutUtils
:
:
GetPrimaryFrameFromStyleFrame
(
const
nsIFrame
*
aStyleFrame
)
{
return
nsLayoutUtils
:
:
GetPrimaryFrameFromStyleFrame
(
const_cast
<
nsIFrame
*
>
(
aStyleFrame
)
)
;
}
bool
nsLayoutUtils
:
:
IsPrimaryStyleFrame
(
const
nsIFrame
*
aFrame
)
{
if
(
aFrame
-
>
IsTableWrapperFrame
(
)
)
{
return
false
;
}
const
nsIFrame
*
parent
=
aFrame
-
>
GetParent
(
)
;
if
(
parent
&
&
parent
-
>
IsTableWrapperFrame
(
)
)
{
return
parent
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
=
=
aFrame
;
}
return
aFrame
-
>
IsPrimaryFrame
(
)
;
}
nsIFrame
*
nsLayoutUtils
:
:
GetFloatFromPlaceholder
(
nsIFrame
*
aFrame
)
{
NS_ASSERTION
(
aFrame
-
>
IsPlaceholderFrame
(
)
"
Must
have
a
placeholder
here
"
)
;
if
(
aFrame
-
>
HasAnyStateBits
(
PLACEHOLDER_FOR_FLOAT
)
)
{
nsIFrame
*
outOfFlowFrame
=
nsPlaceholderFrame
:
:
GetRealFrameForPlaceholder
(
aFrame
)
;
NS_ASSERTION
(
outOfFlowFrame
&
&
outOfFlowFrame
-
>
IsFloating
(
)
"
How
did
that
happen
?
"
)
;
return
outOfFlowFrame
;
}
return
nullptr
;
}
nsIFrame
*
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
const
nsIFrame
*
aFrame
nsPoint
*
aExtraOffset
)
{
nsIFrame
*
p
=
aFrame
-
>
GetParent
(
)
;
if
(
p
)
{
return
p
;
}
nsView
*
v
=
aFrame
-
>
GetView
(
)
;
if
(
!
v
)
{
return
nullptr
;
}
v
=
v
-
>
GetParent
(
)
;
if
(
!
v
)
{
return
nullptr
;
}
v
=
v
-
>
GetParent
(
)
;
if
(
!
v
)
{
return
nullptr
;
}
p
=
v
-
>
GetFrame
(
)
;
if
(
p
&
&
aExtraOffset
)
{
nsSubDocumentFrame
*
subdocumentFrame
=
do_QueryFrame
(
p
)
;
MOZ_ASSERT
(
subdocumentFrame
)
;
*
aExtraOffset
+
=
subdocumentFrame
-
>
GetExtraOffset
(
)
;
}
return
p
;
}
bool
nsLayoutUtils
:
:
IsProperAncestorFrameCrossDoc
(
const
nsIFrame
*
aAncestorFrame
const
nsIFrame
*
aFrame
const
nsIFrame
*
aCommonAncestor
)
{
if
(
aFrame
=
=
aAncestorFrame
)
return
false
;
return
IsAncestorFrameCrossDoc
(
aAncestorFrame
aFrame
aCommonAncestor
)
;
}
bool
nsLayoutUtils
:
:
IsAncestorFrameCrossDoc
(
const
nsIFrame
*
aAncestorFrame
const
nsIFrame
*
aFrame
const
nsIFrame
*
aCommonAncestor
)
{
for
(
const
nsIFrame
*
f
=
aFrame
;
f
!
=
aCommonAncestor
;
f
=
GetCrossDocParentFrame
(
f
)
)
{
if
(
f
=
=
aAncestorFrame
)
return
true
;
}
return
aCommonAncestor
=
=
aAncestorFrame
;
}
bool
nsLayoutUtils
:
:
IsProperAncestorFrame
(
const
nsIFrame
*
aAncestorFrame
const
nsIFrame
*
aFrame
const
nsIFrame
*
aCommonAncestor
)
{
if
(
aFrame
=
=
aAncestorFrame
)
return
false
;
for
(
const
nsIFrame
*
f
=
aFrame
;
f
!
=
aCommonAncestor
;
f
=
f
-
>
GetParent
(
)
)
{
if
(
f
=
=
aAncestorFrame
)
return
true
;
}
return
aCommonAncestor
=
=
aAncestorFrame
;
}
int32_t
nsLayoutUtils
:
:
DoCompareTreePosition
(
nsIContent
*
aContent1
nsIContent
*
aContent2
int32_t
aIf1Ancestor
int32_t
aIf2Ancestor
const
nsIContent
*
aCommonAncestor
)
{
MOZ_ASSERT
(
aIf1Ancestor
=
=
-
1
|
|
aIf1Ancestor
=
=
0
|
|
aIf1Ancestor
=
=
1
)
;
MOZ_ASSERT
(
aIf2Ancestor
=
=
-
1
|
|
aIf2Ancestor
=
=
0
|
|
aIf2Ancestor
=
=
1
)
;
MOZ_ASSERT
(
aContent1
"
aContent1
must
not
be
null
"
)
;
MOZ_ASSERT
(
aContent2
"
aContent2
must
not
be
null
"
)
;
AutoTArray
<
nsINode
*
32
>
content1Ancestors
;
nsINode
*
c1
;
for
(
c1
=
aContent1
;
c1
&
&
c1
!
=
aCommonAncestor
;
c1
=
c1
-
>
GetParentOrShadowHostNode
(
)
)
{
content1Ancestors
.
AppendElement
(
c1
)
;
}
if
(
!
c1
&
&
aCommonAncestor
)
{
aCommonAncestor
=
nullptr
;
}
AutoTArray
<
nsINode
*
32
>
content2Ancestors
;
nsINode
*
c2
;
for
(
c2
=
aContent2
;
c2
&
&
c2
!
=
aCommonAncestor
;
c2
=
c2
-
>
GetParentOrShadowHostNode
(
)
)
{
content2Ancestors
.
AppendElement
(
c2
)
;
}
if
(
!
c2
&
&
aCommonAncestor
)
{
return
DoCompareTreePosition
(
aContent1
aContent2
aIf1Ancestor
aIf2Ancestor
nullptr
)
;
}
int
last1
=
content1Ancestors
.
Length
(
)
-
1
;
int
last2
=
content2Ancestors
.
Length
(
)
-
1
;
nsINode
*
content1Ancestor
=
nullptr
;
nsINode
*
content2Ancestor
=
nullptr
;
while
(
last1
>
=
0
&
&
last2
>
=
0
&
&
(
(
content1Ancestor
=
content1Ancestors
.
ElementAt
(
last1
)
)
=
=
(
content2Ancestor
=
content2Ancestors
.
ElementAt
(
last2
)
)
)
)
{
last1
-
-
;
last2
-
-
;
}
if
(
last1
<
0
)
{
if
(
last2
<
0
)
{
NS_ASSERTION
(
aContent1
=
=
aContent2
"
internal
error
?
"
)
;
return
0
;
}
return
aIf1Ancestor
;
}
if
(
last2
<
0
)
{
return
aIf2Ancestor
;
}
nsINode
*
parent
=
content1Ancestor
-
>
GetParentOrShadowHostNode
(
)
;
#
ifdef
DEBUG
NS_ASSERTION
(
gPreventAssertInCompareTreePosition
|
|
parent
"
no
common
ancestor
at
all
?
?
?
"
)
;
#
endif
if
(
!
parent
)
{
return
0
;
}
int32_t
index1
=
parent
-
>
ComputeIndexOf
(
content1Ancestor
)
;
int32_t
index2
=
parent
-
>
ComputeIndexOf
(
content2Ancestor
)
;
if
(
index1
>
=
0
&
&
index2
>
=
0
)
{
return
index1
-
index2
;
}
auto
PseudoIndex
=
[
]
(
const
nsINode
*
aNode
int32_t
aNodeIndex
)
-
>
int32_t
{
if
(
aNodeIndex
>
=
0
)
{
return
1
;
}
if
(
aNode
-
>
IsContent
(
)
)
{
if
(
aNode
-
>
AsContent
(
)
-
>
IsGeneratedContentContainerForMarker
(
)
)
{
return
-
2
;
}
if
(
aNode
-
>
AsContent
(
)
-
>
IsGeneratedContentContainerForBefore
(
)
)
{
return
-
1
;
}
if
(
aNode
-
>
AsContent
(
)
-
>
IsGeneratedContentContainerForAfter
(
)
)
{
return
2
;
}
}
return
0
;
}
;
return
PseudoIndex
(
content1Ancestor
index1
)
-
PseudoIndex
(
content2Ancestor
index2
)
;
}
nsIFrame
*
nsLayoutUtils
:
:
FillAncestors
(
nsIFrame
*
aFrame
nsIFrame
*
aStopAtAncestor
nsTArray
<
nsIFrame
*
>
*
aAncestors
)
{
while
(
aFrame
&
&
aFrame
!
=
aStopAtAncestor
)
{
aAncestors
-
>
AppendElement
(
aFrame
)
;
aFrame
=
nsLayoutUtils
:
:
GetParentOrPlaceholderFor
(
aFrame
)
;
}
return
aFrame
;
}
static
bool
IsFrameAfter
(
nsIFrame
*
aFrame1
nsIFrame
*
aFrame2
)
{
nsIFrame
*
f
=
aFrame2
;
do
{
f
=
f
-
>
GetNextSibling
(
)
;
if
(
f
=
=
aFrame1
)
return
true
;
}
while
(
f
)
;
return
false
;
}
int32_t
nsLayoutUtils
:
:
DoCompareTreePosition
(
nsIFrame
*
aFrame1
nsIFrame
*
aFrame2
int32_t
aIf1Ancestor
int32_t
aIf2Ancestor
nsIFrame
*
aCommonAncestor
)
{
MOZ_ASSERT
(
aIf1Ancestor
=
=
-
1
|
|
aIf1Ancestor
=
=
0
|
|
aIf1Ancestor
=
=
1
)
;
MOZ_ASSERT
(
aIf2Ancestor
=
=
-
1
|
|
aIf2Ancestor
=
=
0
|
|
aIf2Ancestor
=
=
1
)
;
MOZ_ASSERT
(
aFrame1
"
aFrame1
must
not
be
null
"
)
;
MOZ_ASSERT
(
aFrame2
"
aFrame2
must
not
be
null
"
)
;
AutoTArray
<
nsIFrame
*
20
>
frame2Ancestors
;
nsIFrame
*
nonCommonAncestor
=
FillAncestors
(
aFrame2
aCommonAncestor
&
frame2Ancestors
)
;
return
DoCompareTreePosition
(
aFrame1
aFrame2
frame2Ancestors
aIf1Ancestor
aIf2Ancestor
nonCommonAncestor
?
aCommonAncestor
:
nullptr
)
;
}
int32_t
nsLayoutUtils
:
:
DoCompareTreePosition
(
nsIFrame
*
aFrame1
nsIFrame
*
aFrame2
nsTArray
<
nsIFrame
*
>
&
aFrame2Ancestors
int32_t
aIf1Ancestor
int32_t
aIf2Ancestor
nsIFrame
*
aCommonAncestor
)
{
MOZ_ASSERT
(
aIf1Ancestor
=
=
-
1
|
|
aIf1Ancestor
=
=
0
|
|
aIf1Ancestor
=
=
1
)
;
MOZ_ASSERT
(
aIf2Ancestor
=
=
-
1
|
|
aIf2Ancestor
=
=
0
|
|
aIf2Ancestor
=
=
1
)
;
MOZ_ASSERT
(
aFrame1
"
aFrame1
must
not
be
null
"
)
;
MOZ_ASSERT
(
aFrame2
"
aFrame2
must
not
be
null
"
)
;
nsPresContext
*
presContext
=
aFrame1
-
>
PresContext
(
)
;
if
(
presContext
!
=
aFrame2
-
>
PresContext
(
)
)
{
NS_ERROR
(
"
no
common
ancestor
at
all
different
documents
"
)
;
return
0
;
}
AutoTArray
<
nsIFrame
*
20
>
frame1Ancestors
;
if
(
aCommonAncestor
&
&
!
FillAncestors
(
aFrame1
aCommonAncestor
&
frame1Ancestors
)
)
{
return
DoCompareTreePosition
(
aFrame1
aFrame2
aIf1Ancestor
aIf2Ancestor
nullptr
)
;
}
int32_t
last1
=
int32_t
(
frame1Ancestors
.
Length
(
)
)
-
1
;
int32_t
last2
=
int32_t
(
aFrame2Ancestors
.
Length
(
)
)
-
1
;
while
(
last1
>
=
0
&
&
last2
>
=
0
&
&
frame1Ancestors
[
last1
]
=
=
aFrame2Ancestors
[
last2
]
)
{
last1
-
-
;
last2
-
-
;
}
if
(
last1
<
0
)
{
if
(
last2
<
0
)
{
NS_ASSERTION
(
aFrame1
=
=
aFrame2
"
internal
error
?
"
)
;
return
0
;
}
return
aIf1Ancestor
;
}
if
(
last2
<
0
)
{
return
aIf2Ancestor
;
}
nsIFrame
*
ancestor1
=
frame1Ancestors
[
last1
]
;
nsIFrame
*
ancestor2
=
aFrame2Ancestors
[
last2
]
;
if
(
IsFrameAfter
(
ancestor2
ancestor1
)
)
return
-
1
;
if
(
IsFrameAfter
(
ancestor1
ancestor2
)
)
return
1
;
NS_WARNING
(
"
Frames
were
in
different
child
lists
?
?
?
"
)
;
return
0
;
}
nsIFrame
*
nsLayoutUtils
:
:
GetLastSibling
(
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
)
{
return
nullptr
;
}
nsIFrame
*
next
;
while
(
(
next
=
aFrame
-
>
GetNextSibling
(
)
)
!
=
nullptr
)
{
aFrame
=
next
;
}
return
aFrame
;
}
nsView
*
nsLayoutUtils
:
:
FindSiblingViewFor
(
nsView
*
aParentView
nsIFrame
*
aFrame
)
{
nsIFrame
*
parentViewFrame
=
aParentView
-
>
GetFrame
(
)
;
nsIContent
*
parentViewContent
=
parentViewFrame
?
parentViewFrame
-
>
GetContent
(
)
:
nullptr
;
for
(
nsView
*
insertBefore
=
aParentView
-
>
GetFirstChild
(
)
;
insertBefore
;
insertBefore
=
insertBefore
-
>
GetNextSibling
(
)
)
{
nsIFrame
*
f
=
insertBefore
-
>
GetFrame
(
)
;
if
(
!
f
)
{
for
(
nsView
*
searchView
=
insertBefore
-
>
GetParent
(
)
;
searchView
;
searchView
=
searchView
-
>
GetParent
(
)
)
{
f
=
searchView
-
>
GetFrame
(
)
;
if
(
f
)
{
break
;
}
}
NS_ASSERTION
(
f
"
Can
'
t
find
a
frame
anywhere
!
"
)
;
}
if
(
!
f
|
|
!
aFrame
-
>
GetContent
(
)
|
|
!
f
-
>
GetContent
(
)
|
|
CompareTreePosition
(
aFrame
-
>
GetContent
(
)
f
-
>
GetContent
(
)
parentViewContent
)
>
0
)
{
return
insertBefore
;
}
}
return
nullptr
;
}
nsIScrollableFrame
*
nsLayoutUtils
:
:
GetScrollableFrameFor
(
const
nsIFrame
*
aScrolledFrame
)
{
nsIFrame
*
frame
=
aScrolledFrame
-
>
GetParent
(
)
;
nsIScrollableFrame
*
sf
=
do_QueryFrame
(
frame
)
;
return
(
sf
&
&
sf
-
>
GetScrolledFrame
(
)
=
=
aScrolledFrame
)
?
sf
:
nullptr
;
}
SideBits
nsLayoutUtils
:
:
GetSideBitsForFixedPositionContent
(
const
nsIFrame
*
aFixedPosFrame
)
{
return
GetSideBitsAndAdjustAnchorForFixedPositionContent
(
nullptr
aFixedPosFrame
nullptr
nullptr
)
;
}
SideBits
nsLayoutUtils
:
:
GetSideBitsAndAdjustAnchorForFixedPositionContent
(
const
nsIFrame
*
aViewportFrame
const
nsIFrame
*
aFixedPosFrame
LayerPoint
*
aAnchor
const
Rect
*
aAnchorRect
)
{
SideBits
sides
=
SideBits
:
:
eNone
;
if
(
aFixedPosFrame
!
=
aViewportFrame
)
{
const
nsStylePosition
*
position
=
aFixedPosFrame
-
>
StylePosition
(
)
;
if
(
!
position
-
>
mOffset
.
Get
(
eSideRight
)
.
IsAuto
(
)
)
{
sides
|
=
SideBits
:
:
eRight
;
if
(
!
position
-
>
mOffset
.
Get
(
eSideLeft
)
.
IsAuto
(
)
)
{
sides
|
=
SideBits
:
:
eLeft
;
if
(
aAnchor
)
{
aAnchor
-
>
x
=
aAnchorRect
-
>
x
+
aAnchorRect
-
>
width
/
2
.
f
;
}
}
else
{
if
(
aAnchor
)
{
aAnchor
-
>
x
=
aAnchorRect
-
>
XMost
(
)
;
}
}
}
else
if
(
!
position
-
>
mOffset
.
Get
(
eSideLeft
)
.
IsAuto
(
)
)
{
sides
|
=
SideBits
:
:
eLeft
;
}
if
(
!
position
-
>
mOffset
.
Get
(
eSideBottom
)
.
IsAuto
(
)
)
{
sides
|
=
SideBits
:
:
eBottom
;
if
(
!
position
-
>
mOffset
.
Get
(
eSideTop
)
.
IsAuto
(
)
)
{
sides
|
=
SideBits
:
:
eTop
;
if
(
aAnchor
)
{
aAnchor
-
>
y
=
aAnchorRect
-
>
y
+
aAnchorRect
-
>
height
/
2
.
f
;
}
}
else
{
if
(
aAnchor
)
{
aAnchor
-
>
y
=
aAnchorRect
-
>
YMost
(
)
;
}
}
}
else
if
(
!
position
-
>
mOffset
.
Get
(
eSideTop
)
.
IsAuto
(
)
)
{
sides
|
=
SideBits
:
:
eTop
;
}
}
return
sides
;
}
void
nsLayoutUtils
:
:
SetFixedPositionLayerData
(
Layer
*
aLayer
const
nsIFrame
*
aViewportFrame
const
nsRect
&
aAnchorRect
const
nsIFrame
*
aFixedPosFrame
nsPresContext
*
aPresContext
const
ContainerLayerParameters
&
aContainerParameters
)
{
float
factor
=
aPresContext
-
>
AppUnitsPerDevPixel
(
)
;
Rect
anchorRect
(
NSAppUnitsToFloatPixels
(
aAnchorRect
.
x
factor
)
*
aContainerParameters
.
mXScale
NSAppUnitsToFloatPixels
(
aAnchorRect
.
y
factor
)
*
aContainerParameters
.
mYScale
NSAppUnitsToFloatPixels
(
aAnchorRect
.
width
factor
)
*
aContainerParameters
.
mXScale
NSAppUnitsToFloatPixels
(
aAnchorRect
.
height
factor
)
*
aContainerParameters
.
mYScale
)
;
Matrix
transform2d
;
if
(
aLayer
-
>
GetTransform
(
)
.
Is2D
(
&
transform2d
)
)
{
transform2d
.
Invert
(
)
;
anchorRect
=
transform2d
.
TransformBounds
(
anchorRect
)
;
}
else
{
NS_ERROR
(
"
3D
transform
found
between
fixedpos
content
and
its
viewport
(
should
"
"
never
happen
)
"
)
;
anchorRect
=
Rect
(
0
0
0
0
)
;
}
LayerPoint
anchor
(
anchorRect
.
x
anchorRect
.
y
)
;
SideBits
sides
=
GetSideBitsAndAdjustAnchorForFixedPositionContent
(
aViewportFrame
aFixedPosFrame
&
anchor
&
anchorRect
)
;
ViewID
id
=
ScrollIdForRootScrollFrame
(
aPresContext
)
;
aLayer
-
>
SetFixedPositionData
(
id
anchor
sides
)
;
}
ScrollableLayerGuid
:
:
ViewID
nsLayoutUtils
:
:
ScrollIdForRootScrollFrame
(
nsPresContext
*
aPresContext
)
{
ViewID
id
=
ScrollableLayerGuid
:
:
NULL_SCROLL_ID
;
if
(
nsIFrame
*
rootScrollFrame
=
aPresContext
-
>
PresShell
(
)
-
>
GetRootScrollFrame
(
)
)
{
if
(
nsIContent
*
content
=
rootScrollFrame
-
>
GetContent
(
)
)
{
id
=
FindOrCreateIDFor
(
content
)
;
}
}
return
id
;
}
nsIScrollableFrame
*
nsLayoutUtils
:
:
GetNearestScrollableFrameForDirection
(
nsIFrame
*
aFrame
ScrollDirections
aDirections
)
{
NS_ASSERTION
(
aFrame
"
GetNearestScrollableFrameForDirection
expects
a
non
-
null
frame
"
)
;
for
(
nsIFrame
*
f
=
aFrame
;
f
;
f
=
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
f
)
)
{
nsIScrollableFrame
*
scrollableFrame
=
do_QueryFrame
(
f
)
;
if
(
scrollableFrame
)
{
ScrollDirections
directions
=
scrollableFrame
-
>
GetAvailableScrollingDirectionsForUserInputEvents
(
)
;
if
(
aDirections
.
contains
(
ScrollDirection
:
:
eVertical
)
)
{
if
(
directions
.
contains
(
ScrollDirection
:
:
eVertical
)
)
{
return
scrollableFrame
;
}
}
if
(
aDirections
.
contains
(
ScrollDirection
:
:
eHorizontal
)
)
{
if
(
directions
.
contains
(
ScrollDirection
:
:
eHorizontal
)
)
{
return
scrollableFrame
;
}
}
}
}
return
nullptr
;
}
static
nsIFrame
*
GetNearestScrollableOrOverflowClipFrame
(
nsIFrame
*
aFrame
uint32_t
aFlags
const
std
:
:
function
<
bool
(
const
nsIFrame
*
aCurrentFrame
)
>
&
aClipFrameCheck
=
nullptr
)
{
MOZ_ASSERT
(
aFrame
"
GetNearestScrollableOrOverflowClipFrame
expects
a
non
-
null
frame
"
)
;
auto
GetNextFrame
=
[
aFlags
]
(
const
nsIFrame
*
aFrame
)
-
>
nsIFrame
*
{
if
(
aFlags
&
nsLayoutUtils
:
:
SCROLLABLE_FOLLOW_OOF_TO_PLACEHOLDER
)
{
return
(
aFlags
&
nsLayoutUtils
:
:
SCROLLABLE_SAME_DOC
)
?
nsLayoutUtils
:
:
GetParentOrPlaceholderFor
(
aFrame
)
:
nsLayoutUtils
:
:
GetParentOrPlaceholderForCrossDoc
(
aFrame
)
;
}
return
(
aFlags
&
nsLayoutUtils
:
:
SCROLLABLE_SAME_DOC
)
?
aFrame
-
>
GetParent
(
)
:
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
aFrame
)
;
}
;
for
(
nsIFrame
*
f
=
aFrame
;
f
;
f
=
GetNextFrame
(
f
)
)
{
if
(
aClipFrameCheck
&
&
aClipFrameCheck
(
f
)
)
{
return
f
;
}
if
(
(
aFlags
&
nsLayoutUtils
:
:
SCROLLABLE_STOP_AT_PAGE
)
&
&
f
-
>
IsPageFrame
(
)
)
{
break
;
}
if
(
nsIScrollableFrame
*
scrollableFrame
=
do_QueryFrame
(
f
)
)
{
if
(
aFlags
&
nsLayoutUtils
:
:
SCROLLABLE_ONLY_ASYNC_SCROLLABLE
)
{
if
(
scrollableFrame
-
>
WantAsyncScroll
(
)
)
{
return
f
;
}
}
else
{
ScrollStyles
ss
=
scrollableFrame
-
>
GetScrollStyles
(
)
;
if
(
(
aFlags
&
nsLayoutUtils
:
:
SCROLLABLE_INCLUDE_HIDDEN
)
|
|
ss
.
mVertical
!
=
StyleOverflow
:
:
Hidden
|
|
ss
.
mHorizontal
!
=
StyleOverflow
:
:
Hidden
)
{
return
f
;
}
}
if
(
aFlags
&
nsLayoutUtils
:
:
SCROLLABLE_ALWAYS_MATCH_ROOT
)
{
PresShell
*
presShell
=
f
-
>
PresShell
(
)
;
if
(
presShell
-
>
GetRootScrollFrame
(
)
=
=
f
&
&
presShell
-
>
GetDocument
(
)
&
&
presShell
-
>
GetDocument
(
)
-
>
IsRootDisplayDocument
(
)
)
{
return
f
;
}
}
}
if
(
(
aFlags
&
nsLayoutUtils
:
:
SCROLLABLE_FIXEDPOS_FINDS_ROOT
)
&
&
f
-
>
StyleDisplay
(
)
-
>
mPosition
=
=
StylePositionProperty
:
:
Fixed
&
&
nsLayoutUtils
:
:
IsReallyFixedPos
(
f
)
)
{
return
f
-
>
PresShell
(
)
-
>
GetRootScrollFrame
(
)
;
}
}
return
nullptr
;
}
nsIScrollableFrame
*
nsLayoutUtils
:
:
GetNearestScrollableFrame
(
nsIFrame
*
aFrame
uint32_t
aFlags
)
{
nsIFrame
*
found
=
GetNearestScrollableOrOverflowClipFrame
(
aFrame
aFlags
)
;
if
(
!
found
)
{
return
nullptr
;
}
return
do_QueryFrame
(
found
)
;
}
nsIFrame
*
nsLayoutUtils
:
:
GetNearestOverflowClipFrame
(
nsIFrame
*
aFrame
)
{
return
GetNearestScrollableOrOverflowClipFrame
(
aFrame
SCROLLABLE_SAME_DOC
|
SCROLLABLE_INCLUDE_HIDDEN
[
]
(
const
nsIFrame
*
currentFrame
)
-
>
bool
{
LayoutFrameType
type
=
currentFrame
-
>
Type
(
)
;
return
(
(
type
=
=
LayoutFrameType
:
:
SVGOuterSVG
|
|
type
=
=
LayoutFrameType
:
:
SVGInnerSVG
)
&
&
(
currentFrame
-
>
StyleDisplay
(
)
-
>
mOverflowX
!
=
StyleOverflow
:
:
Visible
&
&
currentFrame
-
>
StyleDisplay
(
)
-
>
mOverflowY
!
=
StyleOverflow
:
:
Visible
)
)
;
}
)
;
}
nsRect
nsLayoutUtils
:
:
GetScrolledRect
(
nsIFrame
*
aScrolledFrame
const
nsRect
&
aScrolledFrameOverflowArea
const
nsSize
&
aScrollPortSize
StyleDirection
aDirection
)
{
WritingMode
wm
=
aScrolledFrame
-
>
GetWritingMode
(
)
;
wm
.
SetDirectionFromBidiLevel
(
aDirection
=
=
StyleDirection
:
:
Rtl
?
1
:
0
)
;
nscoord
x1
=
aScrolledFrameOverflowArea
.
x
x2
=
aScrolledFrameOverflowArea
.
XMost
(
)
y1
=
aScrolledFrameOverflowArea
.
y
y2
=
aScrolledFrameOverflowArea
.
YMost
(
)
;
const
bool
isHorizontalWM
=
!
wm
.
IsVertical
(
)
;
const
bool
isVerticalWM
=
wm
.
IsVertical
(
)
;
bool
isInlineFlowFromTopOrLeft
=
!
wm
.
IsInlineReversed
(
)
;
bool
isBlockFlowFromTopOrLeft
=
isHorizontalWM
|
|
wm
.
IsVerticalLR
(
)
;
if
(
aScrolledFrame
-
>
IsFlexContainerFrame
(
)
)
{
FlexboxAxisInfo
info
(
aScrolledFrame
)
;
if
(
info
.
mIsRowOriented
)
{
isInlineFlowFromTopOrLeft
=
isInlineFlowFromTopOrLeft
=
=
!
info
.
mIsMainAxisReversed
;
isBlockFlowFromTopOrLeft
=
isBlockFlowFromTopOrLeft
=
=
!
info
.
mIsCrossAxisReversed
;
}
else
{
isBlockFlowFromTopOrLeft
=
isBlockFlowFromTopOrLeft
=
=
!
info
.
mIsMainAxisReversed
;
isInlineFlowFromTopOrLeft
=
isInlineFlowFromTopOrLeft
=
=
!
info
.
mIsCrossAxisReversed
;
}
}
if
(
(
isHorizontalWM
&
&
isInlineFlowFromTopOrLeft
)
|
|
(
isVerticalWM
&
&
isBlockFlowFromTopOrLeft
)
)
{
if
(
x1
<
0
)
{
x1
=
0
;
}
}
else
{
if
(
x2
>
aScrollPortSize
.
width
)
{
x2
=
aScrollPortSize
.
width
;
}
nscoord
extraWidth
=
std
:
:
max
(
0
aScrolledFrame
-
>
GetSize
(
)
.
width
-
aScrollPortSize
.
width
)
;
x2
+
=
extraWidth
;
}
if
(
(
isHorizontalWM
&
&
isBlockFlowFromTopOrLeft
)
|
|
(
isVerticalWM
&
&
isInlineFlowFromTopOrLeft
)
)
{
if
(
y1
<
0
)
{
y1
=
0
;
}
}
else
{
if
(
y2
>
aScrollPortSize
.
height
)
{
y2
=
aScrollPortSize
.
height
;
}
nscoord
extraHeight
=
std
:
:
max
(
0
aScrolledFrame
-
>
GetSize
(
)
.
height
-
aScrollPortSize
.
height
)
;
y2
+
=
extraHeight
;
}
return
nsRect
(
x1
y1
x2
-
x1
y2
-
y1
)
;
}
bool
nsLayoutUtils
:
:
HasPseudoStyle
(
nsIContent
*
aContent
ComputedStyle
*
aComputedStyle
PseudoStyleType
aPseudoElement
nsPresContext
*
aPresContext
)
{
MOZ_ASSERT
(
aPresContext
"
Must
have
a
prescontext
"
)
;
RefPtr
<
ComputedStyle
>
pseudoContext
;
if
(
aContent
)
{
pseudoContext
=
aPresContext
-
>
StyleSet
(
)
-
>
ProbePseudoElementStyle
(
*
aContent
-
>
AsElement
(
)
aPseudoElement
aComputedStyle
)
;
}
return
pseudoContext
!
=
nullptr
;
}
nsPoint
nsLayoutUtils
:
:
GetDOMEventCoordinatesRelativeTo
(
Event
*
aDOMEvent
nsIFrame
*
aFrame
)
{
if
(
!
aDOMEvent
)
return
nsPoint
(
NS_UNCONSTRAINEDSIZE
NS_UNCONSTRAINEDSIZE
)
;
WidgetEvent
*
event
=
aDOMEvent
-
>
WidgetEventPtr
(
)
;
if
(
!
event
)
return
nsPoint
(
NS_UNCONSTRAINEDSIZE
NS_UNCONSTRAINEDSIZE
)
;
return
GetEventCoordinatesRelativeTo
(
event
RelativeTo
{
aFrame
}
)
;
}
nsPoint
nsLayoutUtils
:
:
GetEventCoordinatesRelativeTo
(
const
WidgetEvent
*
aEvent
RelativeTo
aFrame
)
{
if
(
!
aEvent
|
|
(
aEvent
-
>
mClass
!
=
eMouseEventClass
&
&
aEvent
-
>
mClass
!
=
eMouseScrollEventClass
&
&
aEvent
-
>
mClass
!
=
eWheelEventClass
&
&
aEvent
-
>
mClass
!
=
eDragEventClass
&
&
aEvent
-
>
mClass
!
=
eSimpleGestureEventClass
&
&
aEvent
-
>
mClass
!
=
ePointerEventClass
&
&
aEvent
-
>
mClass
!
=
eGestureNotifyEventClass
&
&
aEvent
-
>
mClass
!
=
eTouchEventClass
&
&
aEvent
-
>
mClass
!
=
eQueryContentEventClass
)
)
return
nsPoint
(
NS_UNCONSTRAINEDSIZE
NS_UNCONSTRAINEDSIZE
)
;
return
GetEventCoordinatesRelativeTo
(
aEvent
aEvent
-
>
AsGUIEvent
(
)
-
>
mRefPoint
aFrame
)
;
}
nsPoint
nsLayoutUtils
:
:
GetEventCoordinatesRelativeTo
(
const
WidgetEvent
*
aEvent
const
LayoutDeviceIntPoint
&
aPoint
RelativeTo
aFrame
)
{
if
(
!
aFrame
.
mFrame
)
{
return
nsPoint
(
NS_UNCONSTRAINEDSIZE
NS_UNCONSTRAINEDSIZE
)
;
}
nsIWidget
*
widget
=
aEvent
-
>
AsGUIEvent
(
)
-
>
mWidget
;
if
(
!
widget
)
{
return
nsPoint
(
NS_UNCONSTRAINEDSIZE
NS_UNCONSTRAINEDSIZE
)
;
}
return
GetEventCoordinatesRelativeTo
(
widget
aPoint
aFrame
)
;
}
nsPoint
GetEventCoordinatesRelativeTo
(
nsIWidget
*
aWidget
const
LayoutDeviceIntPoint
&
aPoint
RelativeTo
aFrame
)
{
const
nsIFrame
*
frame
=
aFrame
.
mFrame
;
if
(
!
frame
|
|
!
aWidget
)
{
return
nsPoint
(
NS_UNCONSTRAINEDSIZE
NS_UNCONSTRAINEDSIZE
)
;
}
nsView
*
view
=
frame
-
>
GetView
(
)
;
if
(
view
)
{
nsIWidget
*
frameWidget
=
view
-
>
GetWidget
(
)
;
if
(
frameWidget
&
&
frameWidget
=
=
aWidget
)
{
nsPresContext
*
presContext
=
frame
-
>
PresContext
(
)
;
nsPoint
pt
(
presContext
-
>
DevPixelsToAppUnits
(
aPoint
.
x
)
presContext
-
>
DevPixelsToAppUnits
(
aPoint
.
y
)
)
;
return
pt
-
view
-
>
ViewToWidgetOffset
(
)
;
}
}
const
nsIFrame
*
rootFrame
=
frame
;
bool
transformFound
=
false
;
for
(
const
nsIFrame
*
f
=
frame
;
f
;
f
=
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
f
)
)
{
if
(
f
-
>
IsTransformed
(
)
|
|
ViewportUtils
:
:
IsZoomedContentRoot
(
f
)
)
{
transformFound
=
true
;
}
rootFrame
=
f
;
}
nsView
*
rootView
=
rootFrame
-
>
GetView
(
)
;
if
(
!
rootView
)
{
return
nsPoint
(
NS_UNCONSTRAINEDSIZE
NS_UNCONSTRAINEDSIZE
)
;
}
nsPoint
widgetToView
=
nsLayoutUtils
:
:
TranslateWidgetToView
(
rootFrame
-
>
PresContext
(
)
aWidget
aPoint
rootView
)
;
if
(
widgetToView
=
=
nsPoint
(
NS_UNCONSTRAINEDSIZE
NS_UNCONSTRAINEDSIZE
)
)
{
return
nsPoint
(
NS_UNCONSTRAINEDSIZE
NS_UNCONSTRAINEDSIZE
)
;
}
int32_t
rootAPD
=
rootFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
int32_t
localAPD
=
frame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
widgetToView
=
widgetToView
.
ScaleToOtherAppUnits
(
rootAPD
localAPD
)
;
if
(
transformFound
|
|
SVGUtils
:
:
IsInSVGTextSubtree
(
frame
)
)
{
return
nsLayoutUtils
:
:
TransformRootPointToFrame
(
ViewportType
:
:
Visual
aFrame
widgetToView
)
;
}
return
widgetToView
-
frame
-
>
GetOffsetToCrossDoc
(
rootFrame
)
;
}
nsPoint
nsLayoutUtils
:
:
GetEventCoordinatesRelativeTo
(
nsIWidget
*
aWidget
const
LayoutDeviceIntPoint
&
aPoint
RelativeTo
aFrame
)
{
nsPoint
result
=
:
:
GetEventCoordinatesRelativeTo
(
aWidget
aPoint
aFrame
)
;
if
(
aFrame
.
mViewportType
=
=
ViewportType
:
:
Layout
&
&
aFrame
.
mFrame
&
&
aFrame
.
mFrame
-
>
Type
(
)
=
=
LayoutFrameType
:
:
Viewport
&
&
aFrame
.
mFrame
-
>
PresContext
(
)
-
>
IsRootContentDocumentCrossProcess
(
)
)
{
result
=
ViewportUtils
:
:
VisualToLayout
(
result
aFrame
.
mFrame
-
>
PresShell
(
)
)
;
}
return
result
;
}
nsIFrame
*
nsLayoutUtils
:
:
GetPopupFrameForEventCoordinates
(
nsPresContext
*
aPresContext
const
WidgetEvent
*
aEvent
)
{
#
ifdef
MOZ_XUL
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
!
pm
)
{
return
nullptr
;
}
nsTArray
<
nsIFrame
*
>
popups
;
pm
-
>
GetVisiblePopups
(
popups
)
;
uint32_t
i
;
for
(
i
=
0
;
i
<
popups
.
Length
(
)
;
i
+
+
)
{
nsIFrame
*
popup
=
popups
[
i
]
;
if
(
popup
-
>
PresContext
(
)
-
>
GetRootPresContext
(
)
=
=
aPresContext
&
&
popup
-
>
ScrollableOverflowRect
(
)
.
Contains
(
GetEventCoordinatesRelativeTo
(
aEvent
RelativeTo
{
popup
}
)
)
)
{
return
popup
;
}
}
#
endif
return
nullptr
;
}
void
nsLayoutUtils
:
:
GetContainerAndOffsetAtEvent
(
PresShell
*
aPresShell
const
WidgetEvent
*
aEvent
nsIContent
*
*
aContainer
int32_t
*
aOffset
)
{
MOZ_ASSERT
(
aContainer
|
|
aOffset
)
;
if
(
aContainer
)
{
*
aContainer
=
nullptr
;
}
if
(
aOffset
)
{
*
aOffset
=
0
;
}
if
(
!
aPresShell
)
{
return
;
}
aPresShell
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
RefPtr
<
nsPresContext
>
presContext
=
aPresShell
-
>
GetPresContext
(
)
;
if
(
!
presContext
)
{
return
;
}
nsIFrame
*
targetFrame
=
presContext
-
>
EventStateManager
(
)
-
>
GetEventTarget
(
)
;
if
(
!
targetFrame
)
{
return
;
}
nsPoint
point
=
nsLayoutUtils
:
:
GetEventCoordinatesRelativeTo
(
aEvent
RelativeTo
{
targetFrame
}
)
;
if
(
aContainer
)
{
nsCOMPtr
<
nsIContent
>
container
=
targetFrame
-
>
GetContentOffsetsFromPoint
(
point
)
.
content
;
if
(
container
&
&
(
!
container
-
>
ChromeOnlyAccess
(
)
|
|
nsContentUtils
:
:
CanAccessNativeAnon
(
)
)
)
{
container
.
forget
(
aContainer
)
;
}
}
if
(
aOffset
)
{
*
aOffset
=
targetFrame
-
>
GetContentOffsetsFromPoint
(
point
)
.
offset
;
}
}
void
nsLayoutUtils
:
:
ConstrainToCoordValues
(
float
&
aStart
float
&
aSize
)
{
MOZ_ASSERT
(
aSize
>
=
0
)
;
float
end
=
aStart
+
aSize
;
aStart
=
clamped
(
aStart
float
(
nscoord_MIN
)
float
(
nscoord_MAX
)
)
;
end
=
clamped
(
end
float
(
nscoord_MIN
)
float
(
nscoord_MAX
)
)
;
aSize
=
end
-
aStart
;
if
(
aSize
>
float
(
nscoord_MAX
)
)
{
float
excess
=
aSize
-
float
(
nscoord_MAX
)
;
excess
/
=
2
;
aStart
+
=
excess
;
aSize
=
(
float
)
nscoord_MAX
;
}
}
static
void
ConstrainToCoordValues
(
gfxFloat
&
aVal
)
{
if
(
aVal
<
=
nscoord_MIN
)
aVal
=
nscoord_MIN
;
else
if
(
aVal
>
=
nscoord_MAX
)
aVal
=
nscoord_MAX
;
}
void
nsLayoutUtils
:
:
ConstrainToCoordValues
(
gfxFloat
&
aStart
gfxFloat
&
aSize
)
{
gfxFloat
max
=
aStart
+
aSize
;
:
:
ConstrainToCoordValues
(
aStart
)
;
:
:
ConstrainToCoordValues
(
max
)
;
aSize
=
max
-
aStart
;
if
(
aSize
>
nscoord_MAX
)
{
gfxFloat
excess
=
aSize
-
nscoord_MAX
;
excess
/
=
2
;
aStart
+
=
excess
;
aSize
=
nscoord_MAX
;
}
else
if
(
aSize
<
nscoord_MIN
)
{
gfxFloat
excess
=
aSize
-
nscoord_MIN
;
excess
/
=
2
;
aStart
-
=
excess
;
aSize
=
nscoord_MIN
;
}
}
nsRegion
nsLayoutUtils
:
:
RoundedRectIntersectRect
(
const
nsRect
&
aRoundedRect
const
nscoord
aRadii
[
8
]
const
nsRect
&
aContainedRect
)
{
nsRect
rectFullHeight
=
aRoundedRect
;
nscoord
xDiff
=
std
:
:
max
(
aRadii
[
eCornerTopLeftX
]
aRadii
[
eCornerBottomLeftX
]
)
;
rectFullHeight
.
x
+
=
xDiff
;
rectFullHeight
.
width
-
=
std
:
:
max
(
aRadii
[
eCornerTopRightX
]
aRadii
[
eCornerBottomRightX
]
)
+
xDiff
;
nsRect
r1
;
r1
.
IntersectRect
(
rectFullHeight
aContainedRect
)
;
nsRect
rectFullWidth
=
aRoundedRect
;
nscoord
yDiff
=
std
:
:
max
(
aRadii
[
eCornerTopLeftY
]
aRadii
[
eCornerTopRightY
]
)
;
rectFullWidth
.
y
+
=
yDiff
;
rectFullWidth
.
height
-
=
std
:
:
max
(
aRadii
[
eCornerBottomLeftY
]
aRadii
[
eCornerBottomRightY
]
)
+
yDiff
;
nsRect
r2
;
r2
.
IntersectRect
(
rectFullWidth
aContainedRect
)
;
nsRegion
result
;
result
.
Or
(
r1
r2
)
;
return
result
;
}
nsIntRegion
nsLayoutUtils
:
:
RoundedRectIntersectIntRect
(
const
nsIntRect
&
aRoundedRect
const
RectCornerRadii
&
aCornerRadii
const
nsIntRect
&
aContainedRect
)
{
nsIntRect
rectFullHeight
=
aRoundedRect
;
uint32_t
xDiff
=
std
:
:
max
(
aCornerRadii
.
TopLeft
(
)
.
width
aCornerRadii
.
BottomLeft
(
)
.
width
)
;
rectFullHeight
.
x
+
=
xDiff
;
rectFullHeight
.
width
-
=
std
:
:
max
(
aCornerRadii
.
TopRight
(
)
.
width
aCornerRadii
.
BottomRight
(
)
.
width
)
+
xDiff
;
nsIntRect
r1
;
r1
.
IntersectRect
(
rectFullHeight
aContainedRect
)
;
nsIntRect
rectFullWidth
=
aRoundedRect
;
uint32_t
yDiff
=
std
:
:
max
(
aCornerRadii
.
TopLeft
(
)
.
height
aCornerRadii
.
TopRight
(
)
.
height
)
;
rectFullWidth
.
y
+
=
yDiff
;
rectFullWidth
.
height
-
=
std
:
:
max
(
aCornerRadii
.
BottomLeft
(
)
.
height
aCornerRadii
.
BottomRight
(
)
.
height
)
+
yDiff
;
nsIntRect
r2
;
r2
.
IntersectRect
(
rectFullWidth
aContainedRect
)
;
nsIntRegion
result
;
result
.
Or
(
r1
r2
)
;
return
result
;
}
static
bool
CheckCorner
(
nscoord
aXOffset
nscoord
aYOffset
nscoord
aXRadius
nscoord
aYRadius
)
{
MOZ_ASSERT
(
aXOffset
>
0
&
&
aYOffset
>
0
"
must
not
pass
nonpositives
to
CheckCorner
"
)
;
MOZ_ASSERT
(
aXRadius
>
=
0
&
&
aYRadius
>
=
0
"
must
not
pass
negatives
to
CheckCorner
"
)
;
if
(
aXOffset
>
=
aXRadius
|
|
aYOffset
>
=
aYRadius
)
return
true
;
float
scaledX
=
float
(
aXRadius
-
aXOffset
)
/
float
(
aXRadius
)
;
float
scaledY
=
float
(
aYRadius
-
aYOffset
)
/
float
(
aYRadius
)
;
return
scaledX
*
scaledX
+
scaledY
*
scaledY
<
1
.
0f
;
}
bool
nsLayoutUtils
:
:
RoundedRectIntersectsRect
(
const
nsRect
&
aRoundedRect
const
nscoord
aRadii
[
8
]
const
nsRect
&
aTestRect
)
{
if
(
!
aTestRect
.
Intersects
(
aRoundedRect
)
)
return
false
;
nsMargin
insets
;
insets
.
top
=
aTestRect
.
YMost
(
)
-
aRoundedRect
.
y
;
insets
.
right
=
aRoundedRect
.
XMost
(
)
-
aTestRect
.
x
;
insets
.
bottom
=
aRoundedRect
.
YMost
(
)
-
aTestRect
.
y
;
insets
.
left
=
aTestRect
.
XMost
(
)
-
aRoundedRect
.
x
;
return
CheckCorner
(
insets
.
left
insets
.
top
aRadii
[
eCornerTopLeftX
]
aRadii
[
eCornerTopLeftY
]
)
&
&
CheckCorner
(
insets
.
right
insets
.
top
aRadii
[
eCornerTopRightX
]
aRadii
[
eCornerTopRightY
]
)
&
&
CheckCorner
(
insets
.
right
insets
.
bottom
aRadii
[
eCornerBottomRightX
]
aRadii
[
eCornerBottomRightY
]
)
&
&
CheckCorner
(
insets
.
left
insets
.
bottom
aRadii
[
eCornerBottomLeftX
]
aRadii
[
eCornerBottomLeftY
]
)
;
}
nsRect
nsLayoutUtils
:
:
MatrixTransformRect
(
const
nsRect
&
aBounds
const
Matrix4x4
&
aMatrix
float
aFactor
)
{
RectDouble
image
=
RectDouble
(
NSAppUnitsToDoublePixels
(
aBounds
.
x
aFactor
)
NSAppUnitsToDoublePixels
(
aBounds
.
y
aFactor
)
NSAppUnitsToDoublePixels
(
aBounds
.
width
aFactor
)
NSAppUnitsToDoublePixels
(
aBounds
.
height
aFactor
)
)
;
RectDouble
maxBounds
=
RectDouble
(
double
(
nscoord_MIN
)
/
aFactor
*
0
.
5
double
(
nscoord_MIN
)
/
aFactor
*
0
.
5
double
(
nscoord_MAX
)
/
aFactor
double
(
nscoord_MAX
)
/
aFactor
)
;
image
=
aMatrix
.
TransformAndClipBounds
(
image
maxBounds
)
;
return
RoundGfxRectToAppRect
(
ThebesRect
(
image
)
aFactor
)
;
}
nsRect
nsLayoutUtils
:
:
MatrixTransformRect
(
const
nsRect
&
aBounds
const
Matrix4x4Flagged
&
aMatrix
float
aFactor
)
{
RectDouble
image
=
RectDouble
(
NSAppUnitsToDoublePixels
(
aBounds
.
x
aFactor
)
NSAppUnitsToDoublePixels
(
aBounds
.
y
aFactor
)
NSAppUnitsToDoublePixels
(
aBounds
.
width
aFactor
)
NSAppUnitsToDoublePixels
(
aBounds
.
height
aFactor
)
)
;
RectDouble
maxBounds
=
RectDouble
(
double
(
nscoord_MIN
)
/
aFactor
*
0
.
5
double
(
nscoord_MIN
)
/
aFactor
*
0
.
5
double
(
nscoord_MAX
)
/
aFactor
double
(
nscoord_MAX
)
/
aFactor
)
;
image
=
aMatrix
.
TransformAndClipBounds
(
image
maxBounds
)
;
return
RoundGfxRectToAppRect
(
ThebesRect
(
image
)
aFactor
)
;
}
nsPoint
nsLayoutUtils
:
:
MatrixTransformPoint
(
const
nsPoint
&
aPoint
const
Matrix4x4
&
aMatrix
float
aFactor
)
{
gfxPoint
image
=
gfxPoint
(
NSAppUnitsToFloatPixels
(
aPoint
.
x
aFactor
)
NSAppUnitsToFloatPixels
(
aPoint
.
y
aFactor
)
)
;
image
=
aMatrix
.
TransformPoint
(
image
)
;
return
nsPoint
(
NSFloatPixelsToAppUnits
(
float
(
image
.
x
)
aFactor
)
NSFloatPixelsToAppUnits
(
float
(
image
.
y
)
aFactor
)
)
;
}
void
nsLayoutUtils
:
:
PostTranslate
(
Matrix4x4
&
aTransform
const
nsPoint
&
aOrigin
float
aAppUnitsPerPixel
bool
aRounded
)
{
Point3D
gfxOrigin
=
Point3D
(
NSAppUnitsToFloatPixels
(
aOrigin
.
x
aAppUnitsPerPixel
)
NSAppUnitsToFloatPixels
(
aOrigin
.
y
aAppUnitsPerPixel
)
0
.
0f
)
;
if
(
aRounded
)
{
gfxOrigin
.
x
=
NS_round
(
gfxOrigin
.
x
)
;
gfxOrigin
.
y
=
NS_round
(
gfxOrigin
.
y
)
;
}
aTransform
.
PostTranslate
(
gfxOrigin
)
;
}
bool
nsLayoutUtils
:
:
ShouldSnapToGrid
(
const
nsIFrame
*
aFrame
)
{
return
!
aFrame
|
|
!
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_SVG_LAYOUT
)
|
|
aFrame
-
>
IsSVGOuterSVGAnonChildFrame
(
)
;
}
Matrix4x4Flagged
nsLayoutUtils
:
:
GetTransformToAncestor
(
RelativeTo
aFrame
RelativeTo
aAncestor
uint32_t
aFlags
nsIFrame
*
*
aOutAncestor
)
{
nsIFrame
*
parent
;
Matrix4x4Flagged
ctm
;
MOZ_ASSERT
(
!
(
aFrame
.
mViewportType
=
=
ViewportType
:
:
Visual
&
&
aAncestor
.
mViewportType
=
=
ViewportType
:
:
Layout
)
)
;
if
(
aFrame
=
=
aAncestor
)
{
return
ctm
;
}
ctm
=
aFrame
.
mFrame
-
>
GetTransformMatrix
(
aFrame
.
mViewportType
aAncestor
&
parent
aFlags
)
;
while
(
parent
&
&
parent
!
=
aAncestor
.
mFrame
&
&
(
!
(
aFlags
&
nsIFrame
:
:
STOP_AT_STACKING_CONTEXT_AND_DISPLAY_PORT
)
|
|
(
!
parent
-
>
IsStackingContext
(
)
&
&
!
DisplayPortUtils
:
:
FrameHasDisplayPort
(
parent
)
)
)
)
{
if
(
!
parent
-
>
Extend3DContext
(
)
)
{
ctm
.
ProjectTo2D
(
)
;
}
ctm
=
ctm
*
parent
-
>
GetTransformMatrix
(
aFrame
.
mViewportType
aAncestor
&
parent
aFlags
)
;
}
if
(
aOutAncestor
)
{
*
aOutAncestor
=
parent
;
}
return
ctm
;
}
gfxSize
nsLayoutUtils
:
:
GetTransformToAncestorScale
(
const
nsIFrame
*
aFrame
)
{
Matrix4x4Flagged
transform
=
GetTransformToAncestor
(
RelativeTo
{
aFrame
}
RelativeTo
{
nsLayoutUtils
:
:
GetDisplayRootFrame
(
aFrame
)
}
)
;
Matrix
transform2D
;
if
(
transform
.
Is2D
(
&
transform2D
)
)
{
return
ThebesMatrix
(
transform2D
)
.
ScaleFactors
(
)
;
}
return
gfxSize
(
1
1
)
;
}
static
Matrix4x4Flagged
GetTransformToAncestorExcludingAnimated
(
nsIFrame
*
aFrame
const
nsIFrame
*
aAncestor
)
{
nsIFrame
*
parent
;
Matrix4x4Flagged
ctm
;
if
(
aFrame
=
=
aAncestor
)
{
return
ctm
;
}
if
(
ActiveLayerTracker
:
:
IsScaleSubjectToAnimation
(
aFrame
)
)
{
return
ctm
;
}
ctm
=
aFrame
-
>
GetTransformMatrix
(
ViewportType
:
:
Layout
RelativeTo
{
aAncestor
}
&
parent
)
;
while
(
parent
&
&
parent
!
=
aAncestor
)
{
if
(
ActiveLayerTracker
:
:
IsScaleSubjectToAnimation
(
parent
)
)
{
return
Matrix4x4Flagged
(
)
;
}
if
(
!
parent
-
>
Extend3DContext
(
)
)
{
ctm
.
ProjectTo2D
(
)
;
}
ctm
=
ctm
*
parent
-
>
GetTransformMatrix
(
ViewportType
:
:
Layout
RelativeTo
{
aAncestor
}
&
parent
)
;
}
return
ctm
;
}
gfxSize
nsLayoutUtils
:
:
GetTransformToAncestorScaleExcludingAnimated
(
nsIFrame
*
aFrame
)
{
Matrix4x4Flagged
transform
=
GetTransformToAncestorExcludingAnimated
(
aFrame
nsLayoutUtils
:
:
GetDisplayRootFrame
(
aFrame
)
)
;
Matrix
transform2D
;
if
(
transform
.
Is2D
(
&
transform2D
)
)
{
return
ThebesMatrix
(
transform2D
)
.
ScaleFactors
(
)
;
}
return
gfxSize
(
1
1
)
;
}
const
nsIFrame
*
nsLayoutUtils
:
:
FindNearestCommonAncestorFrame
(
const
nsIFrame
*
aFrame1
const
nsIFrame
*
aFrame2
)
{
AutoTArray
<
const
nsIFrame
*
100
>
ancestors1
;
AutoTArray
<
const
nsIFrame
*
100
>
ancestors2
;
const
nsIFrame
*
commonAncestor
=
nullptr
;
if
(
aFrame1
-
>
PresContext
(
)
=
=
aFrame2
-
>
PresContext
(
)
)
{
commonAncestor
=
aFrame1
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
;
}
for
(
const
nsIFrame
*
f
=
aFrame1
;
f
!
=
commonAncestor
;
f
=
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
f
)
)
{
ancestors1
.
AppendElement
(
f
)
;
}
for
(
const
nsIFrame
*
f
=
aFrame2
;
f
!
=
commonAncestor
;
f
=
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
f
)
)
{
ancestors2
.
AppendElement
(
f
)
;
}
uint32_t
minLengths
=
std
:
:
min
(
ancestors1
.
Length
(
)
ancestors2
.
Length
(
)
)
;
for
(
uint32_t
i
=
1
;
i
<
=
minLengths
;
+
+
i
)
{
if
(
ancestors1
[
ancestors1
.
Length
(
)
-
i
]
=
=
ancestors2
[
ancestors2
.
Length
(
)
-
i
]
)
{
commonAncestor
=
ancestors1
[
ancestors1
.
Length
(
)
-
i
]
;
}
else
{
break
;
}
}
return
commonAncestor
;
}
const
nsIFrame
*
nsLayoutUtils
:
:
FindNearestCommonAncestorFrameWithinBlock
(
const
nsTextFrame
*
aFrame1
const
nsTextFrame
*
aFrame2
)
{
MOZ_ASSERT
(
aFrame1
)
;
MOZ_ASSERT
(
aFrame2
)
;
const
nsIFrame
*
f1
=
aFrame1
;
const
nsIFrame
*
f2
=
aFrame2
;
int
n1
=
1
;
int
n2
=
1
;
for
(
auto
f
=
f1
-
>
GetParent
(
)
;
;
)
{
NS_ASSERTION
(
f
"
All
text
frames
should
have
a
block
ancestor
"
)
;
if
(
!
f
)
{
return
nullptr
;
}
if
(
f
-
>
IsBlockFrameOrSubclass
(
)
)
{
break
;
}
+
+
n1
;
f
=
f
-
>
GetParent
(
)
;
}
for
(
auto
f
=
f2
-
>
GetParent
(
)
;
;
)
{
NS_ASSERTION
(
f
"
All
text
frames
should
have
a
block
ancestor
"
)
;
if
(
!
f
)
{
return
nullptr
;
}
if
(
f
-
>
IsBlockFrameOrSubclass
(
)
)
{
break
;
}
+
+
n2
;
f
=
f
-
>
GetParent
(
)
;
}
if
(
n1
>
n2
)
{
std
:
:
swap
(
n1
n2
)
;
std
:
:
swap
(
f1
f2
)
;
}
while
(
n2
>
n1
)
{
f2
=
f2
-
>
GetParent
(
)
;
-
-
n2
;
}
while
(
n2
>
=
0
)
{
if
(
f1
=
=
f2
)
{
return
f1
;
}
f1
=
f1
-
>
GetParent
(
)
;
f2
=
f2
-
>
GetParent
(
)
;
-
-
n2
;
}
return
nullptr
;
}
nsLayoutUtils
:
:
TransformResult
nsLayoutUtils
:
:
TransformPoints
(
nsIFrame
*
aFromFrame
nsIFrame
*
aToFrame
uint32_t
aPointCount
CSSPoint
*
aPoints
)
{
const
nsIFrame
*
nearestCommonAncestor
=
FindNearestCommonAncestorFrame
(
aFromFrame
aToFrame
)
;
if
(
!
nearestCommonAncestor
)
{
return
NO_COMMON_ANCESTOR
;
}
Matrix4x4Flagged
downToDest
=
GetTransformToAncestor
(
RelativeTo
{
aToFrame
}
RelativeTo
{
nearestCommonAncestor
}
)
;
if
(
downToDest
.
IsSingular
(
)
)
{
return
NONINVERTIBLE_TRANSFORM
;
}
downToDest
.
Invert
(
)
;
Matrix4x4Flagged
upToAncestor
=
GetTransformToAncestor
(
RelativeTo
{
aFromFrame
}
RelativeTo
{
nearestCommonAncestor
}
)
;
CSSToLayoutDeviceScale
devPixelsPerCSSPixelFromFrame
=
aFromFrame
-
>
PresContext
(
)
-
>
CSSToDevPixelScale
(
)
;
CSSToLayoutDeviceScale
devPixelsPerCSSPixelToFrame
=
aToFrame
-
>
PresContext
(
)
-
>
CSSToDevPixelScale
(
)
;
for
(
uint32_t
i
=
0
;
i
<
aPointCount
;
+
+
i
)
{
LayoutDevicePoint
devPixels
=
aPoints
[
i
]
*
devPixelsPerCSSPixelFromFrame
;
Point
toDevPixels
=
downToDest
.
ProjectPoint
(
(
upToAncestor
.
TransformPoint
(
Point
(
devPixels
.
x
devPixels
.
y
)
)
)
)
.
As2DPoint
(
)
;
aPoints
[
i
]
=
LayoutDevicePoint
(
toDevPixels
.
x
toDevPixels
.
y
)
/
devPixelsPerCSSPixelToFrame
;
}
return
TRANSFORM_SUCCEEDED
;
}
nsLayoutUtils
:
:
TransformResult
nsLayoutUtils
:
:
TransformPoint
(
RelativeTo
aFromFrame
RelativeTo
aToFrame
nsPoint
&
aPoint
)
{
RelativeTo
nearestCommonAncestor
{
FindNearestCommonAncestorFrame
(
aFromFrame
.
mFrame
aToFrame
.
mFrame
)
aFromFrame
.
mViewportType
=
=
ViewportType
:
:
Visual
|
|
aToFrame
.
mViewportType
=
=
ViewportType
:
:
Visual
?
ViewportType
:
:
Visual
:
ViewportType
:
:
Layout
}
;
if
(
!
nearestCommonAncestor
.
mFrame
)
{
return
NO_COMMON_ANCESTOR
;
}
Matrix4x4Flagged
downToDest
=
GetTransformToAncestor
(
aToFrame
nearestCommonAncestor
)
;
if
(
downToDest
.
IsSingular
(
)
)
{
return
NONINVERTIBLE_TRANSFORM
;
}
downToDest
.
Invert
(
)
;
Matrix4x4Flagged
upToAncestor
=
GetTransformToAncestor
(
aFromFrame
nearestCommonAncestor
)
;
float
devPixelsPerAppUnitFromFrame
=
1
.
0f
/
aFromFrame
.
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
float
devPixelsPerAppUnitToFrame
=
1
.
0f
/
aToFrame
.
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
Point4D
toDevPixels
=
downToDest
.
ProjectPoint
(
upToAncestor
.
TransformPoint
(
Point
(
aPoint
.
x
*
devPixelsPerAppUnitFromFrame
aPoint
.
y
*
devPixelsPerAppUnitFromFrame
)
)
)
;
if
(
!
toDevPixels
.
HasPositiveWCoord
(
)
)
{
return
NONINVERTIBLE_TRANSFORM
;
}
aPoint
.
x
=
NSToCoordRound
(
toDevPixels
.
x
/
devPixelsPerAppUnitToFrame
)
;
aPoint
.
y
=
NSToCoordRound
(
toDevPixels
.
y
/
devPixelsPerAppUnitToFrame
)
;
return
TRANSFORM_SUCCEEDED
;
}
nsLayoutUtils
:
:
TransformResult
nsLayoutUtils
:
:
TransformRect
(
const
nsIFrame
*
aFromFrame
const
nsIFrame
*
aToFrame
nsRect
&
aRect
)
{
const
nsIFrame
*
nearestCommonAncestor
=
FindNearestCommonAncestorFrame
(
aFromFrame
aToFrame
)
;
if
(
!
nearestCommonAncestor
)
{
return
NO_COMMON_ANCESTOR
;
}
Matrix4x4Flagged
downToDest
=
GetTransformToAncestor
(
RelativeTo
{
aToFrame
}
RelativeTo
{
nearestCommonAncestor
}
)
;
if
(
downToDest
.
IsSingular
(
)
)
{
return
NONINVERTIBLE_TRANSFORM
;
}
downToDest
.
Invert
(
)
;
Matrix4x4Flagged
upToAncestor
=
GetTransformToAncestor
(
RelativeTo
{
aFromFrame
}
RelativeTo
{
nearestCommonAncestor
}
)
;
float
devPixelsPerAppUnitFromFrame
=
1
.
0f
/
aFromFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
float
devPixelsPerAppUnitToFrame
=
1
.
0f
/
aToFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
gfx
:
:
Rect
toDevPixels
=
downToDest
.
ProjectRectBounds
(
upToAncestor
.
ProjectRectBounds
(
gfx
:
:
Rect
(
aRect
.
x
*
devPixelsPerAppUnitFromFrame
aRect
.
y
*
devPixelsPerAppUnitFromFrame
aRect
.
width
*
devPixelsPerAppUnitFromFrame
aRect
.
height
*
devPixelsPerAppUnitFromFrame
)
Rect
(
-
std
:
:
numeric_limits
<
Float
>
:
:
max
(
)
*
0
.
5f
-
std
:
:
numeric_limits
<
Float
>
:
:
max
(
)
*
0
.
5f
std
:
:
numeric_limits
<
Float
>
:
:
max
(
)
std
:
:
numeric_limits
<
Float
>
:
:
max
(
)
)
)
Rect
(
-
std
:
:
numeric_limits
<
Float
>
:
:
max
(
)
*
devPixelsPerAppUnitFromFrame
*
0
.
5f
-
std
:
:
numeric_limits
<
Float
>
:
:
max
(
)
*
devPixelsPerAppUnitFromFrame
*
0
.
5f
std
:
:
numeric_limits
<
Float
>
:
:
max
(
)
*
devPixelsPerAppUnitFromFrame
std
:
:
numeric_limits
<
Float
>
:
:
max
(
)
*
devPixelsPerAppUnitFromFrame
)
)
;
aRect
.
x
=
NSToCoordRound
(
toDevPixels
.
x
/
devPixelsPerAppUnitToFrame
)
;
aRect
.
y
=
NSToCoordRound
(
toDevPixels
.
y
/
devPixelsPerAppUnitToFrame
)
;
aRect
.
width
=
NSToCoordRound
(
toDevPixels
.
width
/
devPixelsPerAppUnitToFrame
)
;
aRect
.
height
=
NSToCoordRound
(
toDevPixels
.
height
/
devPixelsPerAppUnitToFrame
)
;
return
TRANSFORM_SUCCEEDED
;
}
nsRect
nsLayoutUtils
:
:
GetRectRelativeToFrame
(
Element
*
aElement
nsIFrame
*
aFrame
)
{
if
(
!
aElement
|
|
!
aFrame
)
{
return
nsRect
(
)
;
}
nsIFrame
*
frame
=
aElement
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
)
{
return
nsRect
(
)
;
}
nsRect
rect
=
frame
-
>
GetRectRelativeToSelf
(
)
;
nsLayoutUtils
:
:
TransformResult
rv
=
nsLayoutUtils
:
:
TransformRect
(
frame
aFrame
rect
)
;
if
(
rv
!
=
nsLayoutUtils
:
:
TRANSFORM_SUCCEEDED
)
{
return
nsRect
(
)
;
}
return
rect
;
}
bool
nsLayoutUtils
:
:
ContainsPoint
(
const
nsRect
&
aRect
const
nsPoint
&
aPoint
nscoord
aInflateSize
)
{
nsRect
rect
=
aRect
;
rect
.
Inflate
(
aInflateSize
)
;
return
rect
.
Contains
(
aPoint
)
;
}
nsRect
nsLayoutUtils
:
:
ClampRectToScrollFrames
(
nsIFrame
*
aFrame
const
nsRect
&
aRect
)
{
nsIFrame
*
closestScrollFrame
=
nsLayoutUtils
:
:
GetClosestFrameOfType
(
aFrame
LayoutFrameType
:
:
Scroll
)
;
nsRect
resultRect
=
aRect
;
while
(
closestScrollFrame
)
{
nsIScrollableFrame
*
sf
=
do_QueryFrame
(
closestScrollFrame
)
;
nsRect
scrollPortRect
=
sf
-
>
GetScrollPortRect
(
)
;
nsLayoutUtils
:
:
TransformRect
(
closestScrollFrame
aFrame
scrollPortRect
)
;
resultRect
=
resultRect
.
Intersect
(
scrollPortRect
)
;
if
(
resultRect
.
IsEmpty
(
)
)
{
break
;
}
closestScrollFrame
=
nsLayoutUtils
:
:
GetClosestFrameOfType
(
closestScrollFrame
-
>
GetParent
(
)
LayoutFrameType
:
:
Scroll
)
;
}
return
resultRect
;
}
bool
nsLayoutUtils
:
:
GetLayerTransformForFrame
(
nsIFrame
*
aFrame
Matrix4x4Flagged
*
aTransform
)
{
if
(
aFrame
-
>
Extend3DContext
(
)
|
|
aFrame
-
>
HasTransformGetter
(
)
)
{
return
false
;
}
nsIFrame
*
root
=
nsLayoutUtils
:
:
GetDisplayRootFrame
(
aFrame
)
;
if
(
root
-
>
HasAnyStateBits
(
NS_FRAME_UPDATE_LAYER_TREE
)
)
{
return
false
;
}
if
(
!
aTransform
)
{
return
true
;
}
nsDisplayListBuilder
builder
(
root
nsDisplayListBuilderMode
:
:
TransformComputation
false
)
;
builder
.
BeginFrame
(
)
;
nsDisplayList
list
;
nsDisplayTransform
*
item
=
MakeDisplayItem
<
nsDisplayTransform
>
(
&
builder
aFrame
&
list
nsRect
(
)
)
;
MOZ_ASSERT
(
item
)
;
*
aTransform
=
item
-
>
GetTransform
(
)
;
item
-
>
Destroy
(
&
builder
)
;
builder
.
EndFrame
(
)
;
return
true
;
}
static
bool
TransformGfxPointFromAncestor
(
RelativeTo
aFrame
const
Point
&
aPoint
RelativeTo
aAncestor
Point
*
aOut
)
{
Matrix4x4Flagged
ctm
=
nsLayoutUtils
:
:
GetTransformToAncestor
(
aFrame
aAncestor
)
;
ctm
.
Invert
(
)
;
Point4D
point
=
ctm
.
ProjectPoint
(
aPoint
)
;
if
(
!
point
.
HasPositiveWCoord
(
)
)
{
return
false
;
}
*
aOut
=
point
.
As2DPoint
(
)
;
return
true
;
}
static
Rect
TransformGfxRectToAncestor
(
RelativeTo
aFrame
const
Rect
&
aRect
RelativeTo
aAncestor
bool
*
aPreservesAxisAlignedRectangles
=
nullptr
Maybe
<
Matrix4x4Flagged
>
*
aMatrixCache
=
nullptr
bool
aStopAtStackingContextAndDisplayPortAndOOFFrame
=
false
nsIFrame
*
*
aOutAncestor
=
nullptr
)
{
Matrix4x4Flagged
ctm
;
if
(
aMatrixCache
&
&
*
aMatrixCache
)
{
ctm
=
aMatrixCache
-
>
value
(
)
;
}
else
{
uint32_t
flags
=
0
;
if
(
aStopAtStackingContextAndDisplayPortAndOOFFrame
)
{
flags
|
=
nsIFrame
:
:
STOP_AT_STACKING_CONTEXT_AND_DISPLAY_PORT
;
}
ctm
=
nsLayoutUtils
:
:
GetTransformToAncestor
(
aFrame
aAncestor
flags
aOutAncestor
)
;
if
(
aMatrixCache
)
{
*
aMatrixCache
=
Some
(
ctm
)
;
}
}
if
(
aPreservesAxisAlignedRectangles
)
{
Matrix
matrix2d
;
*
aPreservesAxisAlignedRectangles
=
ctm
.
Is2D
(
&
matrix2d
)
&
&
matrix2d
.
PreservesAxisAlignedRectangles
(
)
;
}
const
nsIFrame
*
ancestor
=
aOutAncestor
?
*
aOutAncestor
:
aAncestor
.
mFrame
;
float
factor
=
ancestor
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
Rect
maxBounds
=
Rect
(
float
(
nscoord_MIN
)
/
factor
*
0
.
5
float
(
nscoord_MIN
)
/
factor
*
0
.
5
float
(
nscoord_MAX
)
/
factor
float
(
nscoord_MAX
)
/
factor
)
;
return
ctm
.
TransformAndClipBounds
(
aRect
maxBounds
)
;
}
static
SVGTextFrame
*
GetContainingSVGTextFrame
(
const
nsIFrame
*
aFrame
)
{
if
(
!
SVGUtils
:
:
IsInSVGTextSubtree
(
aFrame
)
)
{
return
nullptr
;
}
return
static_cast
<
SVGTextFrame
*
>
(
nsLayoutUtils
:
:
GetClosestFrameOfType
(
aFrame
-
>
GetParent
(
)
LayoutFrameType
:
:
SVGText
)
)
;
}
nsPoint
nsLayoutUtils
:
:
TransformAncestorPointToFrame
(
RelativeTo
aFrame
const
nsPoint
&
aPoint
RelativeTo
aAncestor
)
{
SVGTextFrame
*
text
=
GetContainingSVGTextFrame
(
aFrame
.
mFrame
)
;
float
factor
=
aFrame
.
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
Point
result
(
NSAppUnitsToFloatPixels
(
aPoint
.
x
factor
)
NSAppUnitsToFloatPixels
(
aPoint
.
y
factor
)
)
;
if
(
!
TransformGfxPointFromAncestor
(
text
?
RelativeTo
{
text
aFrame
.
mViewportType
}
:
aFrame
result
aAncestor
&
result
)
)
{
return
nsPoint
(
NS_UNCONSTRAINEDSIZE
NS_UNCONSTRAINEDSIZE
)
;
}
if
(
text
)
{
result
=
text
-
>
TransformFramePointToTextChild
(
result
aFrame
.
mFrame
)
;
}
return
nsPoint
(
NSFloatPixelsToAppUnits
(
float
(
result
.
x
)
factor
)
NSFloatPixelsToAppUnits
(
float
(
result
.
y
)
factor
)
)
;
}
nsRect
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
const
nsIFrame
*
aFrame
const
nsRect
&
aRect
RelativeTo
aAncestor
bool
*
aPreservesAxisAlignedRectangles
Maybe
<
Matrix4x4Flagged
>
*
aMatrixCache
bool
aStopAtStackingContextAndDisplayPortAndOOFFrame
nsIFrame
*
*
aOutAncestor
)
{
MOZ_ASSERT
(
IsAncestorFrameCrossDoc
(
aAncestor
.
mFrame
aFrame
)
"
Fix
the
caller
"
)
;
SVGTextFrame
*
text
=
GetContainingSVGTextFrame
(
aFrame
)
;
float
srcAppUnitsPerDevPixel
=
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
Rect
result
;
if
(
text
)
{
result
=
ToRect
(
text
-
>
TransformFrameRectFromTextChild
(
aRect
aFrame
)
)
;
float
devPixelPerCSSPixel
=
float
(
AppUnitsPerCSSPixel
(
)
)
/
srcAppUnitsPerDevPixel
;
result
.
Scale
(
devPixelPerCSSPixel
)
;
result
=
TransformGfxRectToAncestor
(
RelativeTo
{
text
}
result
aAncestor
nullptr
aMatrixCache
aStopAtStackingContextAndDisplayPortAndOOFFrame
aOutAncestor
)
;
if
(
aPreservesAxisAlignedRectangles
)
*
aPreservesAxisAlignedRectangles
=
false
;
}
else
{
result
=
Rect
(
NSAppUnitsToFloatPixels
(
aRect
.
x
srcAppUnitsPerDevPixel
)
NSAppUnitsToFloatPixels
(
aRect
.
y
srcAppUnitsPerDevPixel
)
NSAppUnitsToFloatPixels
(
aRect
.
width
srcAppUnitsPerDevPixel
)
NSAppUnitsToFloatPixels
(
aRect
.
height
srcAppUnitsPerDevPixel
)
)
;
result
=
TransformGfxRectToAncestor
(
RelativeTo
{
aFrame
}
result
aAncestor
aPreservesAxisAlignedRectangles
aMatrixCache
aStopAtStackingContextAndDisplayPortAndOOFFrame
aOutAncestor
)
;
}
float
destAppUnitsPerDevPixel
=
aAncestor
.
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
return
nsRect
(
NSFloatPixelsToAppUnits
(
float
(
result
.
x
)
destAppUnitsPerDevPixel
)
NSFloatPixelsToAppUnits
(
float
(
result
.
y
)
destAppUnitsPerDevPixel
)
NSFloatPixelsToAppUnits
(
float
(
result
.
width
)
destAppUnitsPerDevPixel
)
NSFloatPixelsToAppUnits
(
float
(
result
.
height
)
destAppUnitsPerDevPixel
)
)
;
}
static
LayoutDeviceIntPoint
GetWidgetOffset
(
nsIWidget
*
aWidget
nsIWidget
*
&
aRootWidget
)
{
LayoutDeviceIntPoint
offset
(
0
0
)
;
while
(
(
aWidget
-
>
WindowType
(
)
=
=
eWindowType_child
|
|
aWidget
-
>
IsPlugin
(
)
)
)
{
nsIWidget
*
parent
=
aWidget
-
>
GetParent
(
)
;
if
(
!
parent
)
{
break
;
}
LayoutDeviceIntRect
bounds
=
aWidget
-
>
GetBounds
(
)
;
offset
+
=
bounds
.
TopLeft
(
)
;
aWidget
=
parent
;
}
aRootWidget
=
aWidget
;
return
offset
;
}
LayoutDeviceIntPoint
nsLayoutUtils
:
:
WidgetToWidgetOffset
(
nsIWidget
*
aFrom
nsIWidget
*
aTo
)
{
nsIWidget
*
fromRoot
;
LayoutDeviceIntPoint
fromOffset
=
GetWidgetOffset
(
aFrom
fromRoot
)
;
nsIWidget
*
toRoot
;
LayoutDeviceIntPoint
toOffset
=
GetWidgetOffset
(
aTo
toRoot
)
;
if
(
fromRoot
=
=
toRoot
)
{
return
fromOffset
-
toOffset
;
}
return
aFrom
-
>
WidgetToScreenOffset
(
)
-
aTo
-
>
WidgetToScreenOffset
(
)
;
}
nsPoint
nsLayoutUtils
:
:
TranslateWidgetToView
(
nsPresContext
*
aPresContext
nsIWidget
*
aWidget
const
LayoutDeviceIntPoint
&
aPt
nsView
*
aView
)
{
nsPoint
viewOffset
;
nsIWidget
*
viewWidget
=
aView
-
>
GetNearestWidget
(
&
viewOffset
)
;
if
(
!
viewWidget
)
{
return
nsPoint
(
NS_UNCONSTRAINEDSIZE
NS_UNCONSTRAINEDSIZE
)
;
}
LayoutDeviceIntPoint
widgetPoint
=
aPt
+
WidgetToWidgetOffset
(
aWidget
viewWidget
)
;
nsPoint
widgetAppUnits
(
aPresContext
-
>
DevPixelsToAppUnits
(
widgetPoint
.
x
)
aPresContext
-
>
DevPixelsToAppUnits
(
widgetPoint
.
y
)
)
;
return
widgetAppUnits
-
viewOffset
;
}
LayoutDeviceIntPoint
nsLayoutUtils
:
:
TranslateViewToWidget
(
nsPresContext
*
aPresContext
nsView
*
aView
nsPoint
aPt
ViewportType
aViewportType
nsIWidget
*
aWidget
)
{
nsPoint
viewOffset
;
nsIWidget
*
viewWidget
=
aView
-
>
GetNearestWidget
(
&
viewOffset
)
;
if
(
!
viewWidget
)
{
return
LayoutDeviceIntPoint
(
NS_UNCONSTRAINEDSIZE
NS_UNCONSTRAINEDSIZE
)
;
}
nsPoint
pt
=
(
aPt
+
viewOffset
)
;
if
(
aViewportType
=
=
ViewportType
:
:
Layout
&
&
aPresContext
-
>
GetPresShell
(
)
)
{
pt
=
ViewportUtils
:
:
LayoutToVisual
(
pt
aPresContext
-
>
GetPresShell
(
)
)
;
}
LayoutDeviceIntPoint
relativeToViewWidget
(
aPresContext
-
>
AppUnitsToDevPixels
(
pt
.
x
)
aPresContext
-
>
AppUnitsToDevPixels
(
pt
.
y
)
)
;
return
relativeToViewWidget
+
WidgetToWidgetOffset
(
viewWidget
aWidget
)
;
}
StyleClear
nsLayoutUtils
:
:
CombineBreakType
(
StyleClear
aOrigBreakType
StyleClear
aNewBreakType
)
{
StyleClear
breakType
=
aOrigBreakType
;
switch
(
breakType
)
{
case
StyleClear
:
:
Left
:
if
(
StyleClear
:
:
Right
=
=
aNewBreakType
|
|
StyleClear
:
:
Both
=
=
aNewBreakType
)
{
breakType
=
StyleClear
:
:
Both
;
}
break
;
case
StyleClear
:
:
Right
:
if
(
StyleClear
:
:
Left
=
=
aNewBreakType
|
|
StyleClear
:
:
Both
=
=
aNewBreakType
)
{
breakType
=
StyleClear
:
:
Both
;
}
break
;
case
StyleClear
:
:
None
:
if
(
StyleClear
:
:
Left
=
=
aNewBreakType
|
|
StyleClear
:
:
Right
=
=
aNewBreakType
|
|
StyleClear
:
:
Both
=
=
aNewBreakType
)
{
breakType
=
aNewBreakType
;
}
break
;
default
:
break
;
}
return
breakType
;
}
#
ifdef
MOZ_DUMP_PAINTING
#
include
<
stdio
.
h
>
static
bool
gDumpEventList
=
false
;
StaticAutoPtr
<
nsTArray
<
int
>
>
gPaintCountStack
;
struct
AutoNestedPaintCount
{
AutoNestedPaintCount
(
)
{
gPaintCountStack
-
>
AppendElement
(
0
)
;
}
~
AutoNestedPaintCount
(
)
{
gPaintCountStack
-
>
RemoveLastElement
(
)
;
}
}
;
#
endif
nsIFrame
*
nsLayoutUtils
:
:
GetFrameForPoint
(
RelativeTo
aRelativeTo
nsPoint
aPt
const
FrameForPointOptions
&
aOptions
)
{
AUTO_PROFILER_LABEL
(
"
nsLayoutUtils
:
:
GetFrameForPoint
"
LAYOUT
)
;
nsresult
rv
;
AutoTArray
<
nsIFrame
*
8
>
outFrames
;
rv
=
GetFramesForArea
(
aRelativeTo
nsRect
(
aPt
nsSize
(
1
1
)
)
outFrames
aOptions
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
return
outFrames
.
Length
(
)
?
outFrames
.
ElementAt
(
0
)
:
nullptr
;
}
nsresult
nsLayoutUtils
:
:
GetFramesForArea
(
RelativeTo
aRelativeTo
const
nsRect
&
aRect
nsTArray
<
nsIFrame
*
>
&
aOutFrames
const
FrameForPointOptions
&
aOptions
)
{
AUTO_PROFILER_LABEL
(
"
nsLayoutUtils
:
:
GetFramesForArea
"
LAYOUT
)
;
nsIFrame
*
frame
=
const_cast
<
nsIFrame
*
>
(
aRelativeTo
.
mFrame
)
;
nsDisplayListBuilder
builder
(
frame
nsDisplayListBuilderMode
:
:
EventDelivery
false
)
;
builder
.
BeginFrame
(
)
;
nsDisplayList
list
;
if
(
aOptions
.
mBits
.
contains
(
FrameForPointOption
:
:
IgnorePaintSuppression
)
)
{
builder
.
IgnorePaintSuppression
(
)
;
}
if
(
aOptions
.
mBits
.
contains
(
FrameForPointOption
:
:
IgnoreRootScrollFrame
)
)
{
nsIFrame
*
rootScrollFrame
=
frame
-
>
PresShell
(
)
-
>
GetRootScrollFrame
(
)
;
if
(
rootScrollFrame
)
{
builder
.
SetIgnoreScrollFrame
(
rootScrollFrame
)
;
}
}
if
(
aRelativeTo
.
mViewportType
=
=
ViewportType
:
:
Layout
)
{
builder
.
SetIsRelativeToLayoutViewport
(
)
;
}
if
(
aOptions
.
mBits
.
contains
(
FrameForPointOption
:
:
IgnoreCrossDoc
)
)
{
builder
.
SetDescendIntoSubdocuments
(
false
)
;
}
if
(
aOptions
.
mBits
.
contains
(
FrameForPointOption
:
:
OnlyVisible
)
)
{
builder
.
SetHitTestIsForVisibility
(
aOptions
.
mVisibleThreshold
)
;
}
builder
.
EnterPresShell
(
frame
)
;
builder
.
SetVisibleRect
(
aRect
)
;
builder
.
SetDirtyRect
(
aRect
)
;
frame
-
>
BuildDisplayListForStackingContext
(
&
builder
&
list
)
;
builder
.
LeavePresShell
(
frame
nullptr
)
;
#
ifdef
MOZ_DUMP_PAINTING
if
(
gDumpEventList
)
{
fprintf_stderr
(
stderr
"
Event
handling
-
-
-
(
%
d
%
d
)
:
\
n
"
aRect
.
x
aRect
.
y
)
;
std
:
:
stringstream
ss
;
nsIFrame
:
:
PrintDisplayList
(
&
builder
list
ss
)
;
print_stderr
(
ss
)
;
}
#
endif
nsDisplayItem
:
:
HitTestState
hitTestState
;
list
.
HitTest
(
&
builder
aRect
&
hitTestState
&
aOutFrames
)
;
list
.
DeleteAll
(
&
builder
)
;
builder
.
EndFrame
(
)
;
return
NS_OK
;
}
FrameMetrics
nsLayoutUtils
:
:
CalculateBasicFrameMetrics
(
nsIScrollableFrame
*
aScrollFrame
)
{
nsIFrame
*
frame
=
do_QueryFrame
(
aScrollFrame
)
;
MOZ_ASSERT
(
frame
)
;
FrameMetrics
metrics
;
nsPresContext
*
presContext
=
frame
-
>
PresContext
(
)
;
PresShell
*
presShell
=
presContext
-
>
PresShell
(
)
;
CSSToLayoutDeviceScale
deviceScale
=
presContext
-
>
CSSToDevPixelScale
(
)
;
float
resolution
=
1
.
0f
;
bool
isRcdRsf
=
aScrollFrame
-
>
IsRootScrollFrameOfDocument
(
)
&
&
presContext
-
>
IsRootContentDocumentCrossProcess
(
)
;
metrics
.
SetIsRootContent
(
isRcdRsf
)
;
if
(
isRcdRsf
)
{
resolution
=
presShell
-
>
GetResolution
(
)
;
}
LayoutDeviceToLayerScale2D
cumulativeResolution
(
presShell
-
>
GetCumulativeResolution
(
)
*
nsLayoutUtils
:
:
GetTransformToAncestorScale
(
frame
)
)
;
LayerToParentLayerScale
layerToParentLayerScale
(
1
.
0f
)
;
metrics
.
SetDevPixelsPerCSSPixel
(
deviceScale
)
;
metrics
.
SetPresShellResolution
(
resolution
)
;
metrics
.
SetCumulativeResolution
(
cumulativeResolution
)
;
metrics
.
SetZoom
(
deviceScale
*
cumulativeResolution
*
layerToParentLayerScale
)
;
nsSize
compositionSize
=
nsLayoutUtils
:
:
CalculateCompositionSizeForFrame
(
frame
)
;
LayoutDeviceToParentLayerScale2D
compBoundsScale
;
if
(
frame
=
=
presShell
-
>
GetRootScrollFrame
(
)
&
&
presContext
-
>
IsRootContentDocument
(
)
)
{
if
(
presContext
-
>
GetParentPresContext
(
)
)
{
float
res
=
presContext
-
>
GetParentPresContext
(
)
-
>
PresShell
(
)
-
>
GetCumulativeResolution
(
)
;
compBoundsScale
=
LayoutDeviceToParentLayerScale2D
(
LayoutDeviceToParentLayerScale
(
res
)
)
;
}
}
else
{
compBoundsScale
=
cumulativeResolution
*
layerToParentLayerScale
;
}
metrics
.
SetCompositionBounds
(
LayoutDeviceRect
:
:
FromAppUnits
(
nsRect
(
nsPoint
(
0
0
)
compositionSize
)
presContext
-
>
AppUnitsPerDevPixel
(
)
)
*
compBoundsScale
)
;
metrics
.
SetRootCompositionSize
(
nsLayoutUtils
:
:
CalculateRootCompositionSize
(
frame
false
metrics
)
)
;
metrics
.
SetLayoutViewport
(
CSSRect
:
:
FromAppUnits
(
nsRect
(
aScrollFrame
-
>
GetScrollPosition
(
)
aScrollFrame
-
>
GetScrollPortRect
(
)
.
Size
(
)
)
)
)
;
metrics
.
SetVisualScrollOffset
(
isRcdRsf
?
CSSPoint
:
:
FromAppUnits
(
presShell
-
>
GetVisualViewportOffset
(
)
)
:
metrics
.
GetLayoutViewport
(
)
.
TopLeft
(
)
)
;
metrics
.
SetScrollableRect
(
CSSRect
:
:
FromAppUnits
(
nsLayoutUtils
:
:
CalculateScrollableRectForFrame
(
aScrollFrame
nullptr
)
)
)
;
return
metrics
;
}
nsIScrollableFrame
*
nsLayoutUtils
:
:
GetAsyncScrollableAncestorFrame
(
nsIFrame
*
aTarget
)
{
uint32_t
flags
=
nsLayoutUtils
:
:
SCROLLABLE_ALWAYS_MATCH_ROOT
|
nsLayoutUtils
:
:
SCROLLABLE_ONLY_ASYNC_SCROLLABLE
|
nsLayoutUtils
:
:
SCROLLABLE_FIXEDPOS_FINDS_ROOT
|
nsLayoutUtils
:
:
SCROLLABLE_FOLLOW_OOF_TO_PLACEHOLDER
;
return
nsLayoutUtils
:
:
GetNearestScrollableFrame
(
aTarget
flags
)
;
}
void
nsLayoutUtils
:
:
AddExtraBackgroundItems
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
nsIFrame
*
aFrame
const
nsRect
&
aCanvasArea
const
nsRegion
&
aVisibleRegion
nscolor
aBackstop
)
{
LayoutFrameType
frameType
=
aFrame
-
>
Type
(
)
;
nsPresContext
*
presContext
=
aFrame
-
>
PresContext
(
)
;
PresShell
*
presShell
=
presContext
-
>
PresShell
(
)
;
if
(
frameType
=
=
LayoutFrameType
:
:
Viewport
&
&
nsLayoutUtils
:
:
NeedsPrintPreviewBackground
(
presContext
)
)
{
nsRect
bounds
=
nsRect
(
aBuilder
-
>
ToReferenceFrame
(
aFrame
)
aFrame
-
>
GetSize
(
)
)
;
nsDisplayListBuilder
:
:
AutoBuildingDisplayList
buildingDisplayList
(
aBuilder
aFrame
bounds
bounds
)
;
presShell
-
>
AddPrintPreviewBackgroundItem
(
aBuilder
aList
aFrame
bounds
)
;
}
else
if
(
frameType
!
=
LayoutFrameType
:
:
Page
)
{
nsRect
canvasArea
=
aVisibleRegion
.
GetBounds
(
)
;
canvasArea
.
IntersectRect
(
aCanvasArea
canvasArea
)
;
nsDisplayListBuilder
:
:
AutoBuildingDisplayList
buildingDisplayList
(
aBuilder
aFrame
canvasArea
canvasArea
)
;
presShell
-
>
AddCanvasBackgroundColorItem
(
aBuilder
aList
aFrame
canvasArea
aBackstop
)
;
}
}
static
RetainedDisplayListBuilder
*
GetOrCreateRetainedDisplayListBuilder
(
nsIFrame
*
aFrame
bool
aRetainingEnabled
bool
aBuildCaret
)
{
RetainedDisplayListBuilder
*
retainedBuilder
=
aFrame
-
>
GetProperty
(
RetainedDisplayListBuilder
:
:
Cached
(
)
)
;
if
(
retainedBuilder
)
{
return
retainedBuilder
;
}
if
(
aRetainingEnabled
)
{
retainedBuilder
=
new
RetainedDisplayListBuilder
(
aFrame
nsDisplayListBuilderMode
:
:
Painting
aBuildCaret
)
;
aFrame
-
>
SetProperty
(
RetainedDisplayListBuilder
:
:
Cached
(
)
retainedBuilder
)
;
}
return
retainedBuilder
;
}
#
ifdef
PRINT_HITTESTINFO_STATS
void
PrintHitTestInfoStatsInternal
(
nsDisplayList
*
aList
int
&
aTotal
int
&
aHitTest
int
&
aVisible
int
&
aSpecial
)
{
for
(
nsDisplayItem
*
i
=
aList
-
>
GetBottom
(
)
;
i
;
i
=
i
-
>
GetAbove
(
)
)
{
aTotal
+
+
;
if
(
i
-
>
GetChildren
(
)
)
{
PrintHitTestInfoStatsInternal
(
i
-
>
GetChildren
(
)
aTotal
aHitTest
aVisible
aSpecial
)
;
}
if
(
i
-
>
GetType
(
)
=
=
DisplayItemType
:
:
TYPE_COMPOSITOR_HITTEST_INFO
)
{
aHitTest
+
+
;
const
auto
&
hitTestInfo
=
static_cast
<
nsDisplayHitTestInfoBase
*
>
(
i
)
-
>
HitTestFlags
(
)
;
if
(
hitTestInfo
.
size
(
)
>
1
)
{
aSpecial
+
+
;
continue
;
}
if
(
hitTestInfo
=
=
CompositorHitTestVisibleToHit
)
{
aVisible
+
+
;
continue
;
}
aSpecial
+
+
;
}
}
}
void
PrintHitTestInfoStats
(
nsDisplayList
*
aList
)
{
int
total
=
0
;
int
hitTest
=
0
;
int
visible
=
0
;
int
special
=
0
;
PrintHitTestInfoStatsInternal
(
aList
total
hitTest
visible
special
)
;
double
ratio
=
(
double
)
hitTest
/
(
double
)
total
;
printf
(
"
List
%
p
:
total
items
:
%
d
hit
test
items
:
%
d
ratio
:
%
f
visible
:
%
d
"
"
special
:
%
d
\
n
"
aList
total
hitTest
ratio
visible
special
)
;
}
#
endif
static
void
ApplyEffectsUpdates
(
const
nsDataHashtable
<
nsPtrHashKey
<
RemoteBrowser
>
EffectsInfo
>
&
aUpdates
)
{
for
(
auto
iter
=
aUpdates
.
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
browser
=
iter
.
Key
(
)
;
auto
update
=
iter
.
Data
(
)
;
browser
-
>
UpdateEffects
(
update
)
;
}
}
static
void
LogPaintedPixelCount
(
LayerManager
*
aLayerManager
const
TimeStamp
aPaintStart
)
{
static
std
:
:
vector
<
std
:
:
pair
<
TimeStamp
uint32_t
>
>
history
;
const
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
const
double
rasterizeTime
=
(
now
-
aPaintStart
)
.
ToMilliseconds
(
)
;
const
uint32_t
pixelCount
=
aLayerManager
-
>
GetAndClearPaintedPixelCount
(
)
;
if
(
pixelCount
)
{
history
.
push_back
(
std
:
:
make_pair
(
now
pixelCount
)
)
;
}
uint32_t
paintedInLastSecond
=
0
;
for
(
auto
i
=
history
.
begin
(
)
;
i
!
=
history
.
end
(
)
;
i
+
+
)
{
if
(
(
now
-
i
-
>
first
)
.
ToMilliseconds
(
)
>
1000
.
0f
)
{
continue
;
}
if
(
paintedInLastSecond
=
=
0
)
{
history
.
erase
(
history
.
begin
(
)
i
)
;
i
=
history
.
begin
(
)
;
}
paintedInLastSecond
+
=
i
-
>
second
;
MOZ_ASSERT
(
paintedInLastSecond
)
;
}
printf_stderr
(
"
Painted
%
u
pixels
in
%
fms
(
%
u
in
the
last
1000ms
)
\
n
"
pixelCount
rasterizeTime
paintedInLastSecond
)
;
}
static
void
DumpBeforePaintDisplayList
(
UniquePtr
<
std
:
:
stringstream
>
&
aStream
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
const
nsRect
&
aVisibleRect
)
{
#
ifdef
MOZ_DUMP_PAINTING
if
(
gfxEnv
:
:
DumpPaintToFile
(
)
)
{
nsCString
string
(
"
dump
-
"
)
;
string
.
AppendInt
(
getpid
(
)
)
;
for
(
int
paintCount
:
*
gPaintCountStack
)
{
string
.
AppendLiteral
(
"
-
"
)
;
string
.
AppendInt
(
paintCount
)
;
}
string
.
AppendLiteral
(
"
.
html
"
)
;
gfxUtils
:
:
sDumpPaintFile
=
fopen
(
string
.
BeginReading
(
)
"
w
"
)
;
}
else
{
gfxUtils
:
:
sDumpPaintFile
=
stderr
;
}
if
(
gfxEnv
:
:
DumpPaintToFile
(
)
)
{
*
aStream
<
<
"
<
html
>
<
head
>
<
script
>
\
n
"
"
var
array
=
{
}
;
\
n
"
"
function
ViewImage
(
index
)
{
\
n
"
"
var
image
=
document
.
getElementById
(
index
)
;
\
n
"
"
if
(
image
.
src
)
{
\
n
"
"
image
.
removeAttribute
(
'
src
'
)
;
\
n
"
"
}
else
{
\
n
"
"
image
.
src
=
array
[
index
]
;
\
n
"
"
}
\
n
"
"
}
<
/
script
>
<
/
head
>
<
body
>
"
;
}
#
endif
*
aStream
<
<
nsPrintfCString
(
"
Painting
-
-
-
before
optimization
(
dirty
%
d
%
d
%
d
%
d
)
:
\
n
"
aVisibleRect
.
x
aVisibleRect
.
y
aVisibleRect
.
width
aVisibleRect
.
height
)
.
get
(
)
;
nsIFrame
:
:
PrintDisplayList
(
aBuilder
*
aList
*
aStream
gfxEnv
:
:
DumpPaintToFile
(
)
)
;
if
(
gfxEnv
:
:
DumpPaint
(
)
|
|
gfxEnv
:
:
DumpPaintItems
(
)
)
{
fprint_stderr
(
gfxUtils
:
:
sDumpPaintFile
*
aStream
)
;
aStream
=
MakeUnique
<
std
:
:
stringstream
>
(
)
;
}
}
static
void
DumpAfterPaintDisplayList
(
UniquePtr
<
std
:
:
stringstream
>
&
aStream
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
LayerManager
*
aManager
)
{
*
aStream
<
<
"
Painting
-
-
-
after
optimization
:
\
n
"
;
nsIFrame
:
:
PrintDisplayList
(
aBuilder
*
aList
*
aStream
gfxEnv
:
:
DumpPaintToFile
(
)
)
;
*
aStream
<
<
"
Painting
-
-
-
layer
tree
:
\
n
"
;
if
(
aManager
)
{
FrameLayerBuilder
:
:
DumpRetainedLayerTree
(
aManager
*
aStream
gfxEnv
:
:
DumpPaintToFile
(
)
)
;
}
fprint_stderr
(
gfxUtils
:
:
sDumpPaintFile
*
aStream
)
;
#
ifdef
MOZ_DUMP_PAINTING
if
(
gfxEnv
:
:
DumpPaintToFile
(
)
)
{
*
aStream
<
<
"
<
/
body
>
<
/
html
>
"
;
}
if
(
gfxEnv
:
:
DumpPaintToFile
(
)
)
{
fclose
(
gfxUtils
:
:
sDumpPaintFile
)
;
}
#
endif
std
:
:
stringstream
lsStream
;
nsIFrame
:
:
PrintDisplayList
(
aBuilder
*
aList
lsStream
)
;
if
(
aManager
-
>
GetRoot
(
)
)
{
aManager
-
>
GetRoot
(
)
-
>
SetDisplayListLog
(
lsStream
.
str
(
)
.
c_str
(
)
)
;
}
}
struct
TemporaryDisplayListBuilder
{
TemporaryDisplayListBuilder
(
nsIFrame
*
aFrame
nsDisplayListBuilderMode
aBuilderMode
const
bool
aBuildCaret
)
:
mBuilder
(
aFrame
aBuilderMode
aBuildCaret
)
{
}
~
TemporaryDisplayListBuilder
(
)
{
mList
.
DeleteAll
(
&
mBuilder
)
;
}
nsDisplayListBuilder
mBuilder
;
nsDisplayList
mList
;
RetainedDisplayListMetrics
mMetrics
;
}
;
nsresult
nsLayoutUtils
:
:
PaintFrame
(
gfxContext
*
aRenderingContext
nsIFrame
*
aFrame
const
nsRegion
&
aDirtyRegion
nscolor
aBackstop
nsDisplayListBuilderMode
aBuilderMode
PaintFrameFlags
aFlags
)
{
AUTO_PROFILER_LABEL
(
"
nsLayoutUtils
:
:
PaintFrame
"
GRAPHICS
)
;
#
ifdef
MOZ_DUMP_PAINTING
if
(
!
gPaintCountStack
)
{
gPaintCountStack
=
new
nsTArray
<
int
>
(
)
;
ClearOnShutdown
(
&
gPaintCountStack
)
;
gPaintCountStack
-
>
AppendElement
(
0
)
;
}
+
+
gPaintCountStack
-
>
LastElement
(
)
;
AutoNestedPaintCount
nestedPaintCount
;
#
endif
if
(
aFlags
&
PaintFrameFlags
:
:
WidgetLayers
)
{
nsView
*
view
=
aFrame
-
>
GetView
(
)
;
if
(
!
(
view
&
&
view
-
>
GetWidget
(
)
&
&
GetDisplayRootFrame
(
aFrame
)
=
=
aFrame
)
)
{
aFlags
&
=
~
PaintFrameFlags
:
:
WidgetLayers
;
NS_ASSERTION
(
aRenderingContext
"
need
a
rendering
context
"
)
;
}
}
nsPresContext
*
presContext
=
aFrame
-
>
PresContext
(
)
;
PresShell
*
presShell
=
presContext
-
>
PresShell
(
)
;
nsRootPresContext
*
rootPresContext
=
presContext
-
>
GetRootPresContext
(
)
;
if
(
!
rootPresContext
)
{
return
NS_OK
;
}
TimeStamp
startBuildDisplayList
=
TimeStamp
:
:
Now
(
)
;
const
bool
buildCaret
=
!
(
aFlags
&
PaintFrameFlags
:
:
HideCaret
)
;
const
bool
isForPainting
=
(
aFlags
&
PaintFrameFlags
:
:
WidgetLayers
)
&
&
aBuilderMode
=
=
nsDisplayListBuilderMode
:
:
Painting
;
const
bool
retainingEnabled
=
isForPainting
&
&
AreRetainedDisplayListsEnabled
(
)
&
&
!
aFrame
-
>
GetParent
(
)
;
RetainedDisplayListBuilder
*
retainedBuilder
=
GetOrCreateRetainedDisplayListBuilder
(
aFrame
retainingEnabled
buildCaret
)
;
const
bool
useRetainedBuilder
=
retainedBuilder
&
&
retainingEnabled
;
Maybe
<
TemporaryDisplayListBuilder
>
temporaryBuilder
;
nsDisplayListBuilder
*
builder
=
nullptr
;
nsDisplayList
*
list
=
nullptr
;
RetainedDisplayListMetrics
*
metrics
=
nullptr
;
if
(
useRetainedBuilder
)
{
builder
=
retainedBuilder
-
>
Builder
(
)
;
list
=
retainedBuilder
-
>
List
(
)
;
metrics
=
retainedBuilder
-
>
Metrics
(
)
;
}
else
{
temporaryBuilder
.
emplace
(
aFrame
aBuilderMode
buildCaret
)
;
builder
=
&
temporaryBuilder
-
>
mBuilder
;
list
=
&
temporaryBuilder
-
>
mList
;
metrics
=
&
temporaryBuilder
-
>
mMetrics
;
}
MOZ_ASSERT
(
builder
&
&
list
&
&
metrics
)
;
if
(
!
useRetainedBuilder
&
&
retainedBuilder
)
{
retainedBuilder
-
>
ClearFramesWithProps
(
)
;
retainedBuilder
-
>
List
(
)
-
>
DeleteAll
(
retainedBuilder
-
>
Builder
(
)
)
;
}
metrics
-
>
Reset
(
)
;
metrics
-
>
StartBuild
(
)
;
builder
-
>
BeginFrame
(
)
;
if
(
aFlags
&
PaintFrameFlags
:
:
InTransform
)
{
builder
-
>
SetInTransform
(
true
)
;
}
if
(
aFlags
&
PaintFrameFlags
:
:
SyncDecodeImages
)
{
builder
-
>
SetSyncDecodeImages
(
true
)
;
}
if
(
aFlags
&
(
PaintFrameFlags
:
:
WidgetLayers
|
PaintFrameFlags
:
:
ToWindow
)
)
{
builder
-
>
SetPaintingToWindow
(
true
)
;
}
if
(
aFlags
&
PaintFrameFlags
:
:
UseHighQualityScaling
)
{
builder
-
>
SetUseHighQualityScaling
(
true
)
;
}
if
(
aFlags
&
PaintFrameFlags
:
:
ForWebRender
)
{
builder
-
>
SetPaintingForWebRender
(
true
)
;
}
if
(
aFlags
&
PaintFrameFlags
:
:
IgnoreSuppression
)
{
builder
-
>
IgnorePaintSuppression
(
)
;
}
if
(
BrowsingContext
*
bc
=
presContext
-
>
Document
(
)
-
>
GetBrowsingContext
(
)
)
{
builder
-
>
SetInActiveDocShell
(
bc
-
>
IsActive
(
)
)
;
}
nsRect
rootInkOverflow
=
aFrame
-
>
InkOverflowRectRelativeToSelf
(
)
;
if
(
BrowserChild
*
browserChild
=
BrowserChild
:
:
GetFrom
(
presShell
)
)
{
Maybe
<
nsRect
>
unscaledVisibleRect
=
browserChild
-
>
GetVisibleRect
(
)
;
if
(
unscaledVisibleRect
)
{
rootInkOverflow
.
IntersectRect
(
rootInkOverflow
*
unscaledVisibleRect
)
;
}
}
nsIFrame
*
rootScrollFrame
=
presShell
-
>
GetRootScrollFrame
(
)
;
if
(
rootScrollFrame
&
&
!
aFrame
-
>
GetParent
(
)
)
{
nsIScrollableFrame
*
rootScrollableFrame
=
presShell
-
>
GetRootScrollFrameAsScrollable
(
)
;
MOZ_ASSERT
(
rootScrollableFrame
)
;
nsRect
displayPortBase
=
rootInkOverflow
;
nsRect
temp
=
displayPortBase
;
Unused
<
<
rootScrollableFrame
-
>
DecideScrollableLayer
(
builder
&
displayPortBase
&
temp
true
)
;
}
nsRegion
visibleRegion
;
if
(
aFlags
&
PaintFrameFlags
:
:
WidgetLayers
)
{
visibleRegion
=
rootInkOverflow
;
}
else
{
visibleRegion
=
aDirtyRegion
;
}
if
(
(
aFlags
&
PaintFrameFlags
:
:
WidgetLayers
)
&
&
!
(
aFlags
&
PaintFrameFlags
:
:
DocumentRelative
)
&
&
rootPresContext
-
>
NeedToComputePluginGeometryUpdates
(
)
)
{
builder
-
>
SetWillComputePluginGeometry
(
true
)
;
builder
-
>
SetDisablePartialUpdates
(
true
)
;
}
nsRect
canvasArea
(
nsPoint
(
0
0
)
aFrame
-
>
GetSize
(
)
)
;
bool
ignoreViewportScrolling
=
!
aFrame
-
>
GetParent
(
)
&
&
presShell
-
>
IgnoringViewportScrolling
(
)
;
if
(
ignoreViewportScrolling
&
&
rootScrollFrame
)
{
nsIScrollableFrame
*
rootScrollableFrame
=
presShell
-
>
GetRootScrollFrameAsScrollable
(
)
;
if
(
aFlags
&
PaintFrameFlags
:
:
DocumentRelative
)
{
nsPoint
pos
=
rootScrollableFrame
-
>
GetScrollPosition
(
)
;
visibleRegion
.
MoveBy
(
-
pos
)
;
if
(
aRenderingContext
)
{
gfxPoint
devPixelOffset
=
nsLayoutUtils
:
:
PointToGfxPoint
(
pos
presContext
-
>
AppUnitsPerDevPixel
(
)
)
;
aRenderingContext
-
>
SetMatrixDouble
(
aRenderingContext
-
>
CurrentMatrixDouble
(
)
.
PreTranslate
(
devPixelOffset
)
)
;
}
}
builder
-
>
SetIgnoreScrollFrame
(
rootScrollFrame
)
;
nsCanvasFrame
*
canvasFrame
=
do_QueryFrame
(
rootScrollableFrame
-
>
GetScrolledFrame
(
)
)
;
if
(
canvasFrame
)
{
canvasArea
.
UnionRect
(
canvasArea
canvasFrame
-
>
CanvasArea
(
)
+
builder
-
>
ToReferenceFrame
(
canvasFrame
)
)
;
}
}
builder
-
>
ClearHaveScrollableDisplayPort
(
)
;
if
(
builder
-
>
IsPaintingToWindow
(
)
)
{
DisplayPortUtils
:
:
MaybeCreateDisplayPortInFirstScrollFrameEncountered
(
aFrame
builder
)
;
}
nsRect
visibleRect
=
visibleRegion
.
GetBounds
(
)
;
PartialUpdateResult
updateState
=
PartialUpdateResult
:
:
Failed
;
{
AUTO_PROFILER_LABEL_CATEGORY_PAIR
(
GRAPHICS_DisplayListBuilding
)
;
AUTO_PROFILER_TRACING_MARKER
(
"
Paint
"
"
DisplayList
"
GRAPHICS
)
;
PerfStats
:
:
AutoMetricRecording
<
PerfStats
:
:
Metric
:
:
DisplayListBuilding
>
autoRecording
;
PaintTelemetry
:
:
AutoRecord
record
(
PaintTelemetry
:
:
Metric
:
:
DisplayList
)
;
{
ViewID
id
=
ScrollableLayerGuid
:
:
NULL_SCROLL_ID
;
if
(
ignoreViewportScrolling
&
&
presContext
-
>
IsRootContentDocument
(
)
)
{
if
(
nsIFrame
*
rootScrollFrame
=
presShell
-
>
GetRootScrollFrame
(
)
)
{
if
(
nsIContent
*
content
=
rootScrollFrame
-
>
GetContent
(
)
)
{
id
=
nsLayoutUtils
:
:
FindOrCreateIDFor
(
content
)
;
}
}
}
else
if
(
presShell
-
>
GetDocument
(
)
&
&
presShell
-
>
GetDocument
(
)
-
>
IsRootDisplayDocument
(
)
&
&
!
presShell
-
>
GetRootScrollFrame
(
)
)
{
if
(
dom
:
:
Element
*
element
=
presShell
-
>
GetDocument
(
)
-
>
GetDocumentElement
(
)
)
{
id
=
nsLayoutUtils
:
:
FindOrCreateIDFor
(
element
)
;
}
}
else
if
(
XRE_IsParentProcess
(
)
&
&
presContext
-
>
IsRoot
(
)
&
&
presShell
-
>
GetDocument
(
)
!
=
nullptr
&
&
presShell
-
>
GetRootScrollFrame
(
)
!
=
nullptr
&
&
nsLayoutUtils
:
:
UsesAsyncScrolling
(
presShell
-
>
GetRootScrollFrame
(
)
)
)
{
if
(
dom
:
:
Element
*
element
=
presShell
-
>
GetDocument
(
)
-
>
GetDocumentElement
(
)
)
{
if
(
!
DisplayPortUtils
:
:
HasDisplayPort
(
element
)
)
{
APZCCallbackHelper
:
:
InitializeRootDisplayport
(
presShell
)
;
}
}
}
nsDisplayListBuilder
:
:
AutoCurrentScrollParentIdSetter
idSetter
(
builder
id
)
;
builder
-
>
SetVisibleRect
(
visibleRect
)
;
builder
-
>
SetIsBuilding
(
true
)
;
builder
-
>
SetAncestorHasApzAwareEventHandler
(
gfxPlatform
:
:
AsyncPanZoomEnabled
(
)
&
&
nsLayoutUtils
:
:
HasDocumentLevelListenersForApzAwareEvents
(
presShell
)
)
;
bool
shouldAttemptPartialUpdate
=
useRetainedBuilder
;
if
(
builder
-
>
ShouldRebuildDisplayListDueToPrefChange
(
)
)
{
shouldAttemptPartialUpdate
=
false
;
}
if
(
shouldAttemptPartialUpdate
)
{
updateState
=
retainedBuilder
-
>
AttemptPartialUpdate
(
aBackstop
)
;
metrics
-
>
EndPartialBuild
(
updateState
)
;
}
else
{
metrics
-
>
mPartialUpdateResult
=
PartialUpdateResult
:
:
Failed
;
metrics
-
>
mPartialUpdateFailReason
=
PartialUpdateFailReason
:
:
Disabled
;
}
bool
doFullRebuild
=
updateState
=
=
PartialUpdateResult
:
:
Failed
;
if
(
StaticPrefs
:
:
layout_display_list_build_twice
(
)
)
{
metrics
-
>
StartBuild
(
)
;
doFullRebuild
=
true
;
}
if
(
doFullRebuild
)
{
list
-
>
DeleteAll
(
builder
)
;
list
-
>
RestoreState
(
)
;
builder
-
>
ClearRetainedWindowRegions
(
)
;
builder
-
>
ClearWillChangeBudgets
(
)
;
builder
-
>
EnterPresShell
(
aFrame
)
;
builder
-
>
SetDirtyRect
(
visibleRect
)
;
aFrame
-
>
BuildDisplayListForStackingContext
(
builder
list
)
;
AddExtraBackgroundItems
(
builder
list
aFrame
canvasArea
visibleRegion
aBackstop
)
;
builder
-
>
LeavePresShell
(
aFrame
list
)
;
metrics
-
>
EndFullBuild
(
)
;
updateState
=
PartialUpdateResult
:
:
Updated
;
}
}
builder
-
>
SetIsBuilding
(
false
)
;
builder
-
>
IncrementPresShellPaintCount
(
presShell
)
;
}
if
(
StaticPrefs
:
:
layers_acceleration_draw_fps
(
)
)
{
RefPtr
<
LayerManager
>
lm
=
builder
-
>
GetWidgetLayerManager
(
)
;
PaintTiming
*
pt
=
ClientLayerManager
:
:
MaybeGetPaintTiming
(
lm
)
;
if
(
pt
)
{
pt
-
>
dlMs
(
)
=
static_cast
<
float
>
(
metrics
-
>
mPartialBuildDuration
)
;
pt
-
>
dl2Ms
(
)
=
static_cast
<
float
>
(
metrics
-
>
mFullBuildDuration
)
;
}
}
MOZ_ASSERT
(
updateState
!
=
PartialUpdateResult
:
:
Failed
)
;
builder
-
>
Check
(
)
;
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
PAINT_BUILD_DISPLAYLIST_TIME
startBuildDisplayList
)
;
bool
consoleNeedsDisplayList
=
(
gfxUtils
:
:
DumpDisplayList
(
)
|
|
gfxEnv
:
:
DumpPaint
(
)
)
&
&
builder
-
>
IsInActiveDocShell
(
)
;
#
ifdef
MOZ_DUMP_PAINTING
FILE
*
savedDumpFile
=
gfxUtils
:
:
sDumpPaintFile
;
#
endif
UniquePtr
<
std
:
:
stringstream
>
ss
;
if
(
consoleNeedsDisplayList
)
{
ss
=
MakeUnique
<
std
:
:
stringstream
>
(
)
;
DumpBeforePaintDisplayList
(
ss
builder
list
visibleRect
)
;
}
uint32_t
flags
=
nsDisplayList
:
:
PAINT_DEFAULT
;
if
(
aFlags
&
PaintFrameFlags
:
:
WidgetLayers
)
{
flags
|
=
nsDisplayList
:
:
PAINT_USE_WIDGET_LAYERS
;
if
(
!
(
aFlags
&
PaintFrameFlags
:
:
DocumentRelative
)
)
{
nsIWidget
*
widget
=
aFrame
-
>
GetNearestWidget
(
)
;
if
(
widget
)
{
widget
-
>
UpdateThemeGeometries
(
builder
-
>
GetThemeGeometries
(
)
)
;
}
}
}
if
(
aFlags
&
PaintFrameFlags
:
:
ExistingTransaction
)
{
flags
|
=
nsDisplayList
:
:
PAINT_EXISTING_TRANSACTION
;
}
if
(
aFlags
&
PaintFrameFlags
:
:
NoComposite
)
{
flags
|
=
nsDisplayList
:
:
PAINT_NO_COMPOSITE
;
}
if
(
aFlags
&
PaintFrameFlags
:
:
Compressed
)
{
flags
|
=
nsDisplayList
:
:
PAINT_COMPRESSED
;
}
if
(
updateState
=
=
PartialUpdateResult
:
:
NoChange
&
&
!
aRenderingContext
)
{
flags
|
=
nsDisplayList
:
:
PAINT_IDENTICAL_DISPLAY_LIST
;
}
#
ifdef
PRINT_HITTESTINFO_STATS
if
(
XRE_IsContentProcess
(
)
)
{
PrintHitTestInfoStats
(
list
)
;
}
#
endif
TimeStamp
paintStart
=
TimeStamp
:
:
Now
(
)
;
RefPtr
<
LayerManager
>
layerManager
=
list
-
>
PaintRoot
(
builder
aRenderingContext
flags
)
;
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
PAINT_RASTERIZE_TIME
paintStart
)
;
if
(
builder
-
>
IsPaintingToWindow
(
)
)
{
presShell
-
>
EndPaint
(
)
;
}
builder
-
>
Check
(
)
;
if
(
StaticPrefs
:
:
gfx_logging_painted_pixel_count_enabled
(
)
)
{
LogPaintedPixelCount
(
layerManager
paintStart
)
;
}
if
(
consoleNeedsDisplayList
)
{
DumpAfterPaintDisplayList
(
ss
builder
list
layerManager
)
;
}
#
ifdef
MOZ_DUMP_PAINTING
gfxUtils
:
:
sDumpPaintFile
=
savedDumpFile
;
#
endif
if
(
StaticPrefs
:
:
layers_dump_client_layers
(
)
)
{
std
:
:
stringstream
ss
;
FrameLayerBuilder
:
:
DumpRetainedLayerTree
(
layerManager
ss
false
)
;
print_stderr
(
ss
)
;
}
if
(
(
aFlags
&
PaintFrameFlags
:
:
WidgetLayers
)
&
&
!
(
aFlags
&
PaintFrameFlags
:
:
DocumentRelative
)
)
{
nsIWidget
*
widget
=
aFrame
-
>
GetNearestWidget
(
)
;
if
(
widget
)
{
nsRegion
opaqueRegion
;
opaqueRegion
.
And
(
builder
-
>
GetWindowExcludeGlassRegion
(
)
builder
-
>
GetWindowOpaqueRegion
(
)
)
;
widget
-
>
UpdateOpaqueRegion
(
LayoutDeviceIntRegion
:
:
FromUnknownRegion
(
opaqueRegion
.
ToNearestPixels
(
presContext
-
>
AppUnitsPerDevPixel
(
)
)
)
)
;
widget
-
>
UpdateWindowDraggingRegion
(
builder
-
>
GetWindowDraggingRegion
(
)
)
;
}
}
if
(
builder
-
>
WillComputePluginGeometry
(
)
)
{
if
(
XRE_IsParentProcess
(
)
)
{
rootPresContext
-
>
ComputePluginGeometryUpdates
(
aFrame
builder
list
)
;
if
(
layerManager
&
&
!
layerManager
-
>
NeedsWidgetInvalidation
(
)
)
{
rootPresContext
-
>
ApplyPluginGeometryUpdates
(
)
;
}
}
if
(
layerManager
)
{
layerManager
-
>
ScheduleComposite
(
)
;
}
builder
-
>
SetDisablePartialUpdates
(
true
)
;
}
if
(
isForPainting
)
{
ApplyEffectsUpdates
(
builder
-
>
GetEffectUpdates
(
)
)
;
}
builder
-
>
Check
(
)
;
{
AUTO_PROFILER_TRACING_MARKER
(
"
Paint
"
"
DisplayListResources
"
GRAPHICS
)
;
builder
-
>
EndFrame
(
)
;
if
(
!
useRetainedBuilder
)
{
temporaryBuilder
.
reset
(
)
;
}
}
#
if
0
if
(
XRE_IsParentProcess
(
)
)
{
if
(
metrics
-
>
mPartialUpdateResult
=
=
PartialUpdateResult
:
:
Failed
)
{
printf
(
"
DL
partial
update
failed
:
%
s
Frame
:
%
p
\
n
"
metrics
-
>
FailReasonString
(
)
aFrame
)
;
}
else
{
printf
(
"
DL
partial
build
success
!
"
"
new
:
%
d
reused
:
%
d
rebuilt
:
%
d
removed
:
%
d
total
:
%
d
\
n
"
metrics
-
>
mNewItems
metrics
-
>
mReusedItems
metrics
-
>
mRebuiltItems
metrics
-
>
mRemovedItems
metrics
-
>
mTotalItems
)
;
}
}
#
endif
return
NS_OK
;
}
bool
nsLayoutUtils
:
:
BinarySearchForPosition
(
DrawTarget
*
aDrawTarget
nsFontMetrics
&
aFontMetrics
const
char16_t
*
aText
int32_t
aBaseWidth
int32_t
aBaseInx
int32_t
aStartInx
int32_t
aEndInx
int32_t
aCursorPos
int32_t
&
aIndex
int32_t
&
aTextWidth
)
{
int32_t
range
=
aEndInx
-
aStartInx
;
if
(
(
range
=
=
1
)
|
|
(
range
=
=
2
&
&
NS_IS_HIGH_SURROGATE
(
aText
[
aStartInx
]
)
)
)
{
aIndex
=
aStartInx
+
aBaseInx
;
aTextWidth
=
nsLayoutUtils
:
:
AppUnitWidthOfString
(
aText
aIndex
aFontMetrics
aDrawTarget
)
;
return
true
;
}
int32_t
inx
=
aStartInx
+
(
range
/
2
)
;
if
(
NS_IS_HIGH_SURROGATE
(
aText
[
inx
-
1
]
)
)
inx
+
+
;
int32_t
textWidth
=
nsLayoutUtils
:
:
AppUnitWidthOfString
(
aText
inx
aFontMetrics
aDrawTarget
)
;
int32_t
fullWidth
=
aBaseWidth
+
textWidth
;
if
(
fullWidth
=
=
aCursorPos
)
{
aTextWidth
=
textWidth
;
aIndex
=
inx
;
return
true
;
}
else
if
(
aCursorPos
<
fullWidth
)
{
aTextWidth
=
aBaseWidth
;
if
(
BinarySearchForPosition
(
aDrawTarget
aFontMetrics
aText
aBaseWidth
aBaseInx
aStartInx
inx
aCursorPos
aIndex
aTextWidth
)
)
{
return
true
;
}
}
else
{
aTextWidth
=
fullWidth
;
if
(
BinarySearchForPosition
(
aDrawTarget
aFontMetrics
aText
aBaseWidth
aBaseInx
inx
aEndInx
aCursorPos
aIndex
aTextWidth
)
)
{
return
true
;
}
}
return
false
;
}
void
nsLayoutUtils
:
:
AddBoxesForFrame
(
nsIFrame
*
aFrame
nsLayoutUtils
:
:
BoxCallback
*
aCallback
)
{
auto
pseudoType
=
aFrame
-
>
Style
(
)
-
>
GetPseudoType
(
)
;
if
(
pseudoType
=
=
PseudoStyleType
:
:
tableWrapper
)
{
AddBoxesForFrame
(
aFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
aCallback
)
;
if
(
aCallback
-
>
mIncludeCaptionBoxForTable
)
{
nsIFrame
*
kid
=
aFrame
-
>
GetChildList
(
nsIFrame
:
:
kCaptionList
)
.
FirstChild
(
)
;
if
(
kid
)
{
AddBoxesForFrame
(
kid
aCallback
)
;
}
}
}
else
if
(
pseudoType
=
=
PseudoStyleType
:
:
mozBlockInsideInlineWrapper
|
|
pseudoType
=
=
PseudoStyleType
:
:
mozMathMLAnonymousBlock
|
|
pseudoType
=
=
PseudoStyleType
:
:
mozXULAnonymousBlock
)
{
for
(
nsIFrame
*
kid
:
aFrame
-
>
PrincipalChildList
(
)
)
{
AddBoxesForFrame
(
kid
aCallback
)
;
}
}
else
{
aCallback
-
>
AddBox
(
aFrame
)
;
}
}
void
nsLayoutUtils
:
:
GetAllInFlowBoxes
(
nsIFrame
*
aFrame
BoxCallback
*
aCallback
)
{
while
(
aFrame
)
{
AddBoxesForFrame
(
aFrame
aCallback
)
;
aFrame
=
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
aFrame
)
;
}
}
nsIFrame
*
nsLayoutUtils
:
:
GetFirstNonAnonymousFrame
(
nsIFrame
*
aFrame
)
{
while
(
aFrame
)
{
auto
pseudoType
=
aFrame
-
>
Style
(
)
-
>
GetPseudoType
(
)
;
if
(
pseudoType
=
=
PseudoStyleType
:
:
tableWrapper
)
{
nsIFrame
*
f
=
GetFirstNonAnonymousFrame
(
aFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
)
;
if
(
f
)
{
return
f
;
}
nsIFrame
*
kid
=
aFrame
-
>
GetChildList
(
nsIFrame
:
:
kCaptionList
)
.
FirstChild
(
)
;
if
(
kid
)
{
f
=
GetFirstNonAnonymousFrame
(
kid
)
;
if
(
f
)
{
return
f
;
}
}
}
else
if
(
pseudoType
=
=
PseudoStyleType
:
:
mozBlockInsideInlineWrapper
|
|
pseudoType
=
=
PseudoStyleType
:
:
mozMathMLAnonymousBlock
|
|
pseudoType
=
=
PseudoStyleType
:
:
mozXULAnonymousBlock
)
{
for
(
nsIFrame
*
kid
:
aFrame
-
>
PrincipalChildList
(
)
)
{
nsIFrame
*
f
=
GetFirstNonAnonymousFrame
(
kid
)
;
if
(
f
)
{
return
f
;
}
}
}
else
{
return
aFrame
;
}
aFrame
=
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
aFrame
)
;
}
return
nullptr
;
}
struct
BoxToRect
:
public
nsLayoutUtils
:
:
BoxCallback
{
const
nsIFrame
*
mRelativeTo
;
RectCallback
*
mCallback
;
uint32_t
mFlags
;
bool
mRelativeToIsRoot
;
BoxToRect
(
const
nsIFrame
*
aRelativeTo
RectCallback
*
aCallback
uint32_t
aFlags
)
:
mRelativeTo
(
aRelativeTo
)
mCallback
(
aCallback
)
mFlags
(
aFlags
)
mRelativeToIsRoot
(
!
aRelativeTo
-
>
GetParent
(
)
)
{
}
virtual
void
AddBox
(
nsIFrame
*
aFrame
)
override
{
nsRect
r
;
nsIFrame
*
outer
=
SVGUtils
:
:
GetOuterSVGFrameAndCoveredRegion
(
aFrame
&
r
)
;
if
(
!
outer
)
{
outer
=
aFrame
;
switch
(
mFlags
&
nsLayoutUtils
:
:
RECTS_WHICH_BOX_MASK
)
{
case
nsLayoutUtils
:
:
RECTS_USE_CONTENT_BOX
:
r
=
aFrame
-
>
GetContentRectRelativeToSelf
(
)
;
break
;
case
nsLayoutUtils
:
:
RECTS_USE_PADDING_BOX
:
r
=
aFrame
-
>
GetPaddingRectRelativeToSelf
(
)
;
break
;
case
nsLayoutUtils
:
:
RECTS_USE_MARGIN_BOX
:
r
=
aFrame
-
>
GetMarginRectRelativeToSelf
(
)
;
break
;
default
:
r
=
aFrame
-
>
GetRectRelativeToSelf
(
)
;
}
}
if
(
mFlags
&
nsLayoutUtils
:
:
RECTS_ACCOUNT_FOR_TRANSFORMS
)
{
if
(
mRelativeToIsRoot
)
{
r
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
outer
r
mRelativeTo
)
;
}
else
{
nsLayoutUtils
:
:
TransformRect
(
outer
mRelativeTo
r
)
;
}
}
else
{
r
+
=
outer
-
>
GetOffsetTo
(
mRelativeTo
)
;
}
mCallback
-
>
AddRect
(
r
)
;
}
}
;
struct
MOZ_RAII
BoxToRectAndText
:
public
BoxToRect
{
Sequence
<
nsString
>
*
mTextList
;
BoxToRectAndText
(
const
nsIFrame
*
aRelativeTo
RectCallback
*
aCallback
Sequence
<
nsString
>
*
aTextList
uint32_t
aFlags
)
:
BoxToRect
(
aRelativeTo
aCallback
aFlags
)
mTextList
(
aTextList
)
{
}
static
void
AccumulateText
(
nsIFrame
*
aFrame
nsAString
&
aResult
)
{
MOZ_ASSERT
(
aFrame
)
;
if
(
aFrame
-
>
IsTextFrame
(
)
)
{
nsTextFrame
*
textFrame
=
static_cast
<
nsTextFrame
*
>
(
aFrame
)
;
nsIFrame
:
:
RenderedText
renderedText
=
textFrame
-
>
GetRenderedText
(
textFrame
-
>
GetContentOffset
(
)
textFrame
-
>
GetContentOffset
(
)
+
textFrame
-
>
GetContentLength
(
)
nsIFrame
:
:
TextOffsetType
:
:
OffsetsInContentText
nsIFrame
:
:
TrailingWhitespace
:
:
DontTrim
)
;
aResult
.
Append
(
renderedText
.
mString
)
;
}
for
(
nsIFrame
*
child
=
aFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
AccumulateText
(
child
aResult
)
;
}
}
virtual
void
AddBox
(
nsIFrame
*
aFrame
)
override
{
BoxToRect
:
:
AddBox
(
aFrame
)
;
if
(
mTextList
)
{
nsString
*
textForFrame
=
mTextList
-
>
AppendElement
(
fallible
)
;
if
(
textForFrame
)
{
AccumulateText
(
aFrame
*
textForFrame
)
;
}
}
}
}
;
void
nsLayoutUtils
:
:
GetAllInFlowRects
(
nsIFrame
*
aFrame
const
nsIFrame
*
aRelativeTo
RectCallback
*
aCallback
uint32_t
aFlags
)
{
BoxToRect
converter
(
aRelativeTo
aCallback
aFlags
)
;
GetAllInFlowBoxes
(
aFrame
&
converter
)
;
}
void
nsLayoutUtils
:
:
GetAllInFlowRectsAndTexts
(
nsIFrame
*
aFrame
const
nsIFrame
*
aRelativeTo
RectCallback
*
aCallback
Sequence
<
nsString
>
*
aTextList
uint32_t
aFlags
)
{
BoxToRectAndText
converter
(
aRelativeTo
aCallback
aTextList
aFlags
)
;
GetAllInFlowBoxes
(
aFrame
&
converter
)
;
}
nsLayoutUtils
:
:
RectAccumulator
:
:
RectAccumulator
(
)
:
mSeenFirstRect
(
false
)
{
}
void
nsLayoutUtils
:
:
RectAccumulator
:
:
AddRect
(
const
nsRect
&
aRect
)
{
mResultRect
.
UnionRect
(
mResultRect
aRect
)
;
if
(
!
mSeenFirstRect
)
{
mSeenFirstRect
=
true
;
mFirstRect
=
aRect
;
}
}
nsLayoutUtils
:
:
RectListBuilder
:
:
RectListBuilder
(
DOMRectList
*
aList
)
:
mRectList
(
aList
)
{
}
void
nsLayoutUtils
:
:
RectListBuilder
:
:
AddRect
(
const
nsRect
&
aRect
)
{
RefPtr
<
DOMRect
>
rect
=
new
DOMRect
(
mRectList
)
;
rect
-
>
SetLayoutRect
(
aRect
)
;
mRectList
-
>
Append
(
rect
)
;
}
nsIFrame
*
nsLayoutUtils
:
:
GetContainingBlockForClientRect
(
nsIFrame
*
aFrame
)
{
return
aFrame
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
;
}
nsRect
nsLayoutUtils
:
:
GetAllInFlowRectsUnion
(
nsIFrame
*
aFrame
const
nsIFrame
*
aRelativeTo
uint32_t
aFlags
)
{
RectAccumulator
accumulator
;
GetAllInFlowRects
(
aFrame
aRelativeTo
&
accumulator
aFlags
)
;
return
accumulator
.
mResultRect
.
IsEmpty
(
)
?
accumulator
.
mFirstRect
:
accumulator
.
mResultRect
;
}
nsRect
nsLayoutUtils
:
:
GetTextShadowRectsUnion
(
const
nsRect
&
aTextAndDecorationsRect
nsIFrame
*
aFrame
uint32_t
aFlags
)
{
const
nsStyleText
*
textStyle
=
aFrame
-
>
StyleText
(
)
;
auto
shadows
=
textStyle
-
>
mTextShadow
.
AsSpan
(
)
;
if
(
shadows
.
IsEmpty
(
)
)
{
return
aTextAndDecorationsRect
;
}
nsRect
resultRect
=
aTextAndDecorationsRect
;
int32_t
A2D
=
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
for
(
auto
&
shadow
:
shadows
)
{
nsMargin
blur
=
nsContextBoxBlur
:
:
GetBlurRadiusMargin
(
shadow
.
blur
.
ToAppUnits
(
)
A2D
)
;
if
(
(
aFlags
&
EXCLUDE_BLUR_SHADOWS
)
&
&
blur
!
=
nsMargin
(
0
0
0
0
)
)
continue
;
nsRect
tmpRect
(
aTextAndDecorationsRect
)
;
tmpRect
.
MoveBy
(
nsPoint
(
shadow
.
horizontal
.
ToAppUnits
(
)
shadow
.
vertical
.
ToAppUnits
(
)
)
)
;
tmpRect
.
Inflate
(
blur
)
;
resultRect
.
UnionRect
(
resultRect
tmpRect
)
;
}
return
resultRect
;
}
enum
ObjectDimensionType
{
eWidth
eHeight
}
;
static
nscoord
ComputeMissingDimension
(
const
nsSize
&
aDefaultObjectSize
const
AspectRatio
&
aIntrinsicRatio
const
Maybe
<
nscoord
>
&
aSpecifiedWidth
const
Maybe
<
nscoord
>
&
aSpecifiedHeight
ObjectDimensionType
aDimensionToCompute
)
{
if
(
aIntrinsicRatio
)
{
if
(
aDimensionToCompute
=
=
eWidth
)
{
return
aIntrinsicRatio
.
ApplyTo
(
*
aSpecifiedHeight
)
;
}
return
aIntrinsicRatio
.
Inverted
(
)
.
ApplyTo
(
*
aSpecifiedWidth
)
;
}
return
(
aDimensionToCompute
=
=
eWidth
)
?
aDefaultObjectSize
.
width
:
aDefaultObjectSize
.
height
;
}
static
Maybe
<
nsSize
>
MaybeComputeObjectFitNoneSize
(
const
nsSize
&
aDefaultObjectSize
const
IntrinsicSize
&
aIntrinsicSize
const
AspectRatio
&
aIntrinsicRatio
)
{
const
Maybe
<
nscoord
>
&
specifiedWidth
=
aIntrinsicSize
.
width
;
const
Maybe
<
nscoord
>
&
specifiedHeight
=
aIntrinsicSize
.
height
;
Maybe
<
nsSize
>
noneSize
;
if
(
specifiedWidth
|
|
specifiedHeight
)
{
noneSize
.
emplace
(
)
;
noneSize
-
>
width
=
specifiedWidth
?
*
specifiedWidth
:
ComputeMissingDimension
(
aDefaultObjectSize
aIntrinsicRatio
specifiedWidth
specifiedHeight
eWidth
)
;
noneSize
-
>
height
=
specifiedHeight
?
*
specifiedHeight
:
ComputeMissingDimension
(
aDefaultObjectSize
aIntrinsicRatio
specifiedWidth
specifiedHeight
eHeight
)
;
}
return
noneSize
;
}
static
nsSize
ComputeConcreteObjectSize
(
const
nsSize
&
aConstraintSize
const
IntrinsicSize
&
aIntrinsicSize
const
AspectRatio
&
aIntrinsicRatio
StyleObjectFit
aObjectFit
)
{
if
(
MOZ_LIKELY
(
aObjectFit
=
=
StyleObjectFit
:
:
Fill
)
|
|
!
aIntrinsicRatio
)
{
return
aConstraintSize
;
}
Maybe
<
nsImageRenderer
:
:
FitType
>
fitType
;
Maybe
<
nsSize
>
noneSize
;
if
(
aObjectFit
=
=
StyleObjectFit
:
:
None
|
|
aObjectFit
=
=
StyleObjectFit
:
:
ScaleDown
)
{
noneSize
=
MaybeComputeObjectFitNoneSize
(
aConstraintSize
aIntrinsicSize
aIntrinsicRatio
)
;
if
(
!
noneSize
|
|
aObjectFit
=
=
StyleObjectFit
:
:
ScaleDown
)
{
fitType
.
emplace
(
nsImageRenderer
:
:
CONTAIN
)
;
}
}
else
if
(
aObjectFit
=
=
StyleObjectFit
:
:
Cover
)
{
fitType
.
emplace
(
nsImageRenderer
:
:
COVER
)
;
}
else
if
(
aObjectFit
=
=
StyleObjectFit
:
:
Contain
)
{
fitType
.
emplace
(
nsImageRenderer
:
:
CONTAIN
)
;
}
Maybe
<
nsSize
>
constrainedSize
;
if
(
fitType
)
{
constrainedSize
.
emplace
(
nsImageRenderer
:
:
ComputeConstrainedSize
(
aConstraintSize
aIntrinsicRatio
*
fitType
)
)
;
}
switch
(
aObjectFit
)
{
case
StyleObjectFit
:
:
Contain
:
case
StyleObjectFit
:
:
Cover
:
MOZ_ASSERT
(
constrainedSize
)
;
return
*
constrainedSize
;
case
StyleObjectFit
:
:
None
:
if
(
noneSize
)
{
return
*
noneSize
;
}
MOZ_ASSERT
(
constrainedSize
)
;
return
*
constrainedSize
;
case
StyleObjectFit
:
:
ScaleDown
:
MOZ_ASSERT
(
constrainedSize
)
;
if
(
noneSize
)
{
constrainedSize
-
>
width
=
std
:
:
min
(
constrainedSize
-
>
width
noneSize
-
>
width
)
;
constrainedSize
-
>
height
=
std
:
:
min
(
constrainedSize
-
>
height
noneSize
-
>
height
)
;
}
return
*
constrainedSize
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
enum
value
for
'
object
-
fit
'
"
)
;
return
aConstraintSize
;
}
}
static
bool
IsCoord50Pct
(
const
LengthPercentage
&
aCoord
)
{
return
aCoord
.
ConvertsToPercentage
(
)
&
&
aCoord
.
ToPercentage
(
)
=
=
0
.
5f
;
}
static
bool
HasInitialObjectFitAndPosition
(
const
nsStylePosition
*
aStylePos
)
{
const
Position
&
objectPos
=
aStylePos
-
>
mObjectPosition
;
return
aStylePos
-
>
mObjectFit
=
=
StyleObjectFit
:
:
Fill
&
&
IsCoord50Pct
(
objectPos
.
horizontal
)
&
&
IsCoord50Pct
(
objectPos
.
vertical
)
;
}
nsRect
nsLayoutUtils
:
:
ComputeObjectDestRect
(
const
nsRect
&
aConstraintRect
const
IntrinsicSize
&
aIntrinsicSize
const
AspectRatio
&
aIntrinsicRatio
const
nsStylePosition
*
aStylePos
nsPoint
*
aAnchorPoint
)
{
nsSize
concreteObjectSize
=
ComputeConcreteObjectSize
(
aConstraintRect
.
Size
(
)
aIntrinsicSize
aIntrinsicRatio
aStylePos
-
>
mObjectFit
)
;
nsPoint
imageTopLeftPt
imageAnchorPt
;
nsImageRenderer
:
:
ComputeObjectAnchorPoint
(
aStylePos
-
>
mObjectPosition
aConstraintRect
.
Size
(
)
concreteObjectSize
&
imageTopLeftPt
&
imageAnchorPt
)
;
imageTopLeftPt
+
=
aConstraintRect
.
TopLeft
(
)
;
imageAnchorPt
+
=
aConstraintRect
.
TopLeft
(
)
;
if
(
aAnchorPoint
)
{
if
(
HasInitialObjectFitAndPosition
(
aStylePos
)
)
{
*
aAnchorPoint
=
imageTopLeftPt
;
}
else
{
*
aAnchorPoint
=
imageAnchorPt
;
}
}
return
nsRect
(
imageTopLeftPt
concreteObjectSize
)
;
}
already_AddRefed
<
nsFontMetrics
>
nsLayoutUtils
:
:
GetFontMetricsForFrame
(
const
nsIFrame
*
aFrame
float
aInflation
)
{
ComputedStyle
*
computedStyle
=
aFrame
-
>
Style
(
)
;
uint8_t
variantWidth
=
NS_FONT_VARIANT_WIDTH_NORMAL
;
if
(
computedStyle
-
>
IsTextCombined
(
)
)
{
MOZ_ASSERT
(
aFrame
-
>
IsTextFrame
(
)
)
;
auto
textFrame
=
static_cast
<
const
nsTextFrame
*
>
(
aFrame
)
;
auto
clusters
=
textFrame
-
>
CountGraphemeClusters
(
)
;
if
(
clusters
=
=
2
)
{
variantWidth
=
NS_FONT_VARIANT_WIDTH_HALF
;
}
else
if
(
clusters
=
=
3
)
{
variantWidth
=
NS_FONT_VARIANT_WIDTH_THIRD
;
}
else
if
(
clusters
=
=
4
)
{
variantWidth
=
NS_FONT_VARIANT_WIDTH_QUARTER
;
}
}
return
GetFontMetricsForComputedStyle
(
computedStyle
aFrame
-
>
PresContext
(
)
aInflation
variantWidth
)
;
}
already_AddRefed
<
nsFontMetrics
>
nsLayoutUtils
:
:
GetFontMetricsForComputedStyle
(
ComputedStyle
*
aComputedStyle
nsPresContext
*
aPresContext
float
aInflation
uint8_t
aVariantWidth
)
{
WritingMode
wm
(
aComputedStyle
)
;
const
nsStyleFont
*
styleFont
=
aComputedStyle
-
>
StyleFont
(
)
;
nsFontMetrics
:
:
Params
params
;
params
.
language
=
styleFont
-
>
mLanguage
;
params
.
explicitLanguage
=
styleFont
-
>
mExplicitLanguage
;
params
.
orientation
=
wm
.
IsVertical
(
)
&
&
!
wm
.
IsSideways
(
)
?
nsFontMetrics
:
:
eVertical
:
nsFontMetrics
:
:
eHorizontal
;
params
.
userFontSet
=
aPresContext
-
>
GetUserFontSet
(
)
;
params
.
textPerf
=
aPresContext
-
>
GetTextPerfMetrics
(
)
;
params
.
fontStats
=
aPresContext
-
>
GetFontMatchingStats
(
)
;
params
.
featureValueLookup
=
aPresContext
-
>
GetFontFeatureValuesLookup
(
)
;
if
(
aInflation
=
=
1
.
0f
&
&
aVariantWidth
=
=
NS_FONT_VARIANT_WIDTH_NORMAL
)
{
return
aPresContext
-
>
DeviceContext
(
)
-
>
GetMetricsFor
(
styleFont
-
>
mFont
params
)
;
}
nsFont
font
=
styleFont
-
>
mFont
;
font
.
size
.
ScaleBy
(
aInflation
)
;
font
.
variantWidth
=
aVariantWidth
;
return
aPresContext
-
>
DeviceContext
(
)
-
>
GetMetricsFor
(
font
params
)
;
}
nsIFrame
*
nsLayoutUtils
:
:
FindChildContainingDescendant
(
nsIFrame
*
aParent
nsIFrame
*
aDescendantFrame
)
{
nsIFrame
*
result
=
aDescendantFrame
;
while
(
result
)
{
nsIFrame
*
parent
=
result
-
>
GetParent
(
)
;
if
(
parent
=
=
aParent
)
{
break
;
}
result
=
parent
;
}
return
result
;
}
nsBlockFrame
*
nsLayoutUtils
:
:
FindNearestBlockAncestor
(
nsIFrame
*
aFrame
)
{
nsIFrame
*
nextAncestor
;
for
(
nextAncestor
=
aFrame
-
>
GetParent
(
)
;
nextAncestor
;
nextAncestor
=
nextAncestor
-
>
GetParent
(
)
)
{
nsBlockFrame
*
block
=
do_QueryFrame
(
nextAncestor
)
;
if
(
block
)
return
block
;
}
return
nullptr
;
}
nsIFrame
*
nsLayoutUtils
:
:
GetNonGeneratedAncestor
(
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_GENERATED_CONTENT
)
)
return
aFrame
;
nsIFrame
*
f
=
aFrame
;
do
{
f
=
GetParentOrPlaceholderFor
(
f
)
;
}
while
(
f
-
>
HasAnyStateBits
(
NS_FRAME_GENERATED_CONTENT
)
)
;
return
f
;
}
nsIFrame
*
nsLayoutUtils
:
:
GetParentOrPlaceholderFor
(
const
nsIFrame
*
aFrame
)
{
if
(
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
&
&
!
aFrame
-
>
GetPrevInFlow
(
)
)
{
return
aFrame
-
>
GetProperty
(
nsIFrame
:
:
PlaceholderFrameProperty
(
)
)
;
}
return
aFrame
-
>
GetParent
(
)
;
}
nsIFrame
*
nsLayoutUtils
:
:
GetParentOrPlaceholderForCrossDoc
(
const
nsIFrame
*
aFrame
)
{
nsIFrame
*
f
=
GetParentOrPlaceholderFor
(
aFrame
)
;
if
(
f
)
return
f
;
return
GetCrossDocParentFrame
(
aFrame
)
;
}
nsIFrame
*
nsLayoutUtils
:
:
GetDisplayListParent
(
nsIFrame
*
aFrame
)
{
if
(
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_IS_PUSHED_FLOAT
)
)
{
return
aFrame
-
>
GetParent
(
)
;
}
return
nsLayoutUtils
:
:
GetParentOrPlaceholderForCrossDoc
(
aFrame
)
;
}
nsIFrame
*
nsLayoutUtils
:
:
GetPrevContinuationOrIBSplitSibling
(
const
nsIFrame
*
aFrame
)
{
if
(
nsIFrame
*
result
=
aFrame
-
>
GetPrevContinuation
(
)
)
{
return
result
;
}
if
(
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_PART_OF_IBSPLIT
)
)
{
return
aFrame
-
>
GetProperty
(
nsIFrame
:
:
IBSplitPrevSibling
(
)
)
;
}
return
nullptr
;
}
nsIFrame
*
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
const
nsIFrame
*
aFrame
)
{
if
(
nsIFrame
*
result
=
aFrame
-
>
GetNextContinuation
(
)
)
{
return
result
;
}
if
(
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_PART_OF_IBSPLIT
)
)
{
return
aFrame
-
>
FirstContinuation
(
)
-
>
GetProperty
(
nsIFrame
:
:
IBSplitSibling
(
)
)
;
}
return
nullptr
;
}
nsIFrame
*
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
const
nsIFrame
*
aFrame
)
{
nsIFrame
*
result
=
aFrame
-
>
FirstContinuation
(
)
;
if
(
result
-
>
HasAnyStateBits
(
NS_FRAME_PART_OF_IBSPLIT
)
)
{
while
(
auto
*
f
=
result
-
>
GetProperty
(
nsIFrame
:
:
IBSplitPrevSibling
(
)
)
)
{
result
=
f
;
}
}
return
result
;
}
nsIFrame
*
nsLayoutUtils
:
:
LastContinuationOrIBSplitSibling
(
const
nsIFrame
*
aFrame
)
{
nsIFrame
*
result
=
aFrame
-
>
FirstContinuation
(
)
;
if
(
result
-
>
HasAnyStateBits
(
NS_FRAME_PART_OF_IBSPLIT
)
)
{
while
(
auto
*
f
=
result
-
>
GetProperty
(
nsIFrame
:
:
IBSplitSibling
(
)
)
)
{
result
=
f
;
}
}
return
result
-
>
LastContinuation
(
)
;
}
bool
nsLayoutUtils
:
:
IsFirstContinuationOrIBSplitSibling
(
const
nsIFrame
*
aFrame
)
{
if
(
aFrame
-
>
GetPrevContinuation
(
)
)
{
return
false
;
}
if
(
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_PART_OF_IBSPLIT
)
&
&
aFrame
-
>
GetProperty
(
nsIFrame
:
:
IBSplitPrevSibling
(
)
)
)
{
return
false
;
}
return
true
;
}
bool
nsLayoutUtils
:
:
IsViewportScrollbarFrame
(
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
)
return
false
;
nsIFrame
*
rootScrollFrame
=
aFrame
-
>
PresShell
(
)
-
>
GetRootScrollFrame
(
)
;
if
(
!
rootScrollFrame
)
return
false
;
nsIScrollableFrame
*
rootScrollableFrame
=
do_QueryFrame
(
rootScrollFrame
)
;
NS_ASSERTION
(
rootScrollableFrame
"
The
root
scorollable
frame
is
null
"
)
;
if
(
!
IsProperAncestorFrame
(
rootScrollFrame
aFrame
)
)
return
false
;
nsIFrame
*
rootScrolledFrame
=
rootScrollableFrame
-
>
GetScrolledFrame
(
)
;
return
!
(
rootScrolledFrame
=
=
aFrame
|
|
IsProperAncestorFrame
(
rootScrolledFrame
aFrame
)
)
;
}
template
<
typename
LengthPercentageLike
>
static
bool
GetAbsoluteCoord
(
const
LengthPercentageLike
&
aStyle
nscoord
&
aResult
)
{
if
(
!
aStyle
.
ConvertsToLength
(
)
)
{
return
false
;
}
aResult
=
std
:
:
max
(
0
aStyle
.
ToLength
(
)
)
;
return
true
;
}
static
nscoord
GetBSizeTakenByBoxSizing
(
StyleBoxSizing
aBoxSizing
nsIFrame
*
aFrame
bool
aHorizontalAxis
bool
aIgnorePadding
)
;
static
bool
GetPercentBSize
(
const
LengthPercentage
&
aStyle
nsIFrame
*
aFrame
bool
aHorizontalAxis
nscoord
&
aResult
)
;
template
<
typename
SizeOrMaxSize
>
static
bool
GetPercentBSize
(
const
SizeOrMaxSize
&
aStyle
nsIFrame
*
aFrame
bool
aHorizontalAxis
nscoord
&
aResult
)
{
if
(
!
aStyle
.
IsLengthPercentage
(
)
)
{
return
false
;
}
return
GetPercentBSize
(
aStyle
.
AsLengthPercentage
(
)
aFrame
aHorizontalAxis
aResult
)
;
}
static
bool
GetPercentBSize
(
const
LengthPercentage
&
aStyle
nsIFrame
*
aFrame
bool
aHorizontalAxis
nscoord
&
aResult
)
{
if
(
!
aStyle
.
HasPercent
(
)
)
{
return
false
;
}
MOZ_ASSERT
(
!
aStyle
.
ConvertsToLength
(
)
"
GetAbsoluteCoord
should
have
handled
this
"
)
;
nsIFrame
*
f
=
aFrame
-
>
GetContainingBlock
(
nsIFrame
:
:
SKIP_SCROLLED_FRAME
)
;
if
(
!
f
)
{
MOZ_ASSERT_UNREACHABLE
(
"
top
of
frame
tree
not
a
containing
block
"
)
;
return
false
;
}
WritingMode
wm
=
f
-
>
GetWritingMode
(
)
;
const
nsStylePosition
*
pos
=
f
-
>
StylePosition
(
)
;
const
auto
&
bSizeCoord
=
pos
-
>
BSize
(
wm
)
;
nscoord
h
;
if
(
!
GetAbsoluteCoord
(
bSizeCoord
h
)
&
&
!
GetPercentBSize
(
bSizeCoord
f
aHorizontalAxis
h
)
)
{
NS_ASSERTION
(
bSizeCoord
.
IsAuto
(
)
|
|
bSizeCoord
.
IsExtremumLength
(
)
|
|
bSizeCoord
.
HasPercent
(
)
"
unknown
block
-
size
unit
"
)
;
LayoutFrameType
fType
=
f
-
>
Type
(
)
;
if
(
fType
!
=
LayoutFrameType
:
:
Viewport
&
&
fType
!
=
LayoutFrameType
:
:
Canvas
&
&
fType
!
=
LayoutFrameType
:
:
PageContent
)
{
return
false
;
}
NS_ASSERTION
(
bSizeCoord
.
IsAuto
(
)
|
|
bSizeCoord
.
IsExtremumLength
(
)
"
Unexpected
block
-
size
unit
for
viewport
or
canvas
or
page
-
content
"
)
;
h
=
f
-
>
BSize
(
wm
)
;
if
(
h
=
=
NS_UNCONSTRAINEDSIZE
)
{
return
false
;
}
}
const
auto
&
maxBSizeCoord
=
pos
-
>
MaxBSize
(
wm
)
;
nscoord
maxh
;
if
(
GetAbsoluteCoord
(
maxBSizeCoord
maxh
)
|
|
GetPercentBSize
(
maxBSizeCoord
f
aHorizontalAxis
maxh
)
)
{
if
(
maxh
<
h
)
h
=
maxh
;
}
else
{
NS_ASSERTION
(
maxBSizeCoord
.
IsNone
(
)
|
|
maxBSizeCoord
.
IsExtremumLength
(
)
|
|
maxBSizeCoord
.
HasPercent
(
)
"
unknown
max
block
-
size
unit
"
)
;
}
const
auto
&
minBSizeCoord
=
pos
-
>
MinBSize
(
wm
)
;
nscoord
minh
;
if
(
GetAbsoluteCoord
(
minBSizeCoord
minh
)
|
|
GetPercentBSize
(
minBSizeCoord
f
aHorizontalAxis
minh
)
)
{
if
(
minh
>
h
)
h
=
minh
;
}
else
{
NS_ASSERTION
(
minBSizeCoord
.
IsAuto
(
)
|
|
minBSizeCoord
.
IsExtremumLength
(
)
|
|
minBSizeCoord
.
HasPercent
(
)
"
unknown
min
block
-
size
unit
"
)
;
}
const
bool
ignorePadding
=
aFrame
-
>
IsAbsolutelyPositioned
(
)
;
nscoord
bSizeTakenByBoxSizing
=
GetBSizeTakenByBoxSizing
(
pos
-
>
mBoxSizing
f
aHorizontalAxis
ignorePadding
)
;
h
=
std
:
:
max
(
0
h
-
bSizeTakenByBoxSizing
)
;
aResult
=
std
:
:
max
(
aStyle
.
Resolve
(
h
)
0
)
;
return
true
;
}
static
bool
GetDefiniteSize
(
const
LengthPercentage
&
aStyle
nsIFrame
*
aFrame
bool
aIsInlineAxis
const
Maybe
<
LogicalSize
>
&
aPercentageBasis
nscoord
*
aResult
)
{
if
(
aStyle
.
ConvertsToLength
(
)
)
{
*
aResult
=
aStyle
.
ToLength
(
)
;
return
true
;
}
if
(
!
aPercentageBasis
)
{
return
false
;
}
auto
wm
=
aFrame
-
>
GetWritingMode
(
)
;
nscoord
pb
=
aIsInlineAxis
?
aPercentageBasis
.
value
(
)
.
ISize
(
wm
)
:
aPercentageBasis
.
value
(
)
.
BSize
(
wm
)
;
if
(
pb
=
=
NS_UNCONSTRAINEDSIZE
)
{
return
false
;
}
*
aResult
=
std
:
:
max
(
0
aStyle
.
Resolve
(
pb
)
)
;
return
true
;
}
template
<
typename
SizeOrMaxSize
>
static
bool
GetDefiniteSize
(
const
SizeOrMaxSize
&
aStyle
nsIFrame
*
aFrame
bool
aIsInlineAxis
const
Maybe
<
LogicalSize
>
&
aPercentageBasis
nscoord
*
aResult
)
{
if
(
!
aStyle
.
IsLengthPercentage
(
)
)
{
return
false
;
}
return
GetDefiniteSize
(
aStyle
.
AsLengthPercentage
(
)
aFrame
aIsInlineAxis
aPercentageBasis
aResult
)
;
}
static
nscoord
GetBSizeTakenByBoxSizing
(
StyleBoxSizing
aBoxSizing
nsIFrame
*
aFrame
bool
aHorizontalAxis
bool
aIgnorePadding
)
{
nscoord
bSizeTakenByBoxSizing
=
0
;
if
(
aBoxSizing
=
=
StyleBoxSizing
:
:
Border
)
{
const
nsStyleBorder
*
styleBorder
=
aFrame
-
>
StyleBorder
(
)
;
bSizeTakenByBoxSizing
+
=
aHorizontalAxis
?
styleBorder
-
>
GetComputedBorder
(
)
.
TopBottom
(
)
:
styleBorder
-
>
GetComputedBorder
(
)
.
LeftRight
(
)
;
if
(
!
aIgnorePadding
)
{
const
auto
&
stylePadding
=
aFrame
-
>
StylePadding
(
)
-
>
mPadding
;
const
LengthPercentage
&
paddingStart
=
stylePadding
.
Get
(
aHorizontalAxis
?
eSideTop
:
eSideLeft
)
;
const
LengthPercentage
&
paddingEnd
=
stylePadding
.
Get
(
aHorizontalAxis
?
eSideBottom
:
eSideRight
)
;
nscoord
pad
;
if
(
GetAbsoluteCoord
(
paddingStart
pad
)
|
|
GetPercentBSize
(
paddingStart
aFrame
aHorizontalAxis
pad
)
)
{
bSizeTakenByBoxSizing
+
=
pad
;
}
if
(
GetAbsoluteCoord
(
paddingEnd
pad
)
|
|
GetPercentBSize
(
paddingEnd
aFrame
aHorizontalAxis
pad
)
)
{
bSizeTakenByBoxSizing
+
=
pad
;
}
}
}
return
bSizeTakenByBoxSizing
;
}
static
nscoord
GetDefiniteSizeTakenByBoxSizing
(
StyleBoxSizing
aBoxSizing
nsIFrame
*
aFrame
bool
aIsInlineAxis
bool
aIgnorePadding
const
Maybe
<
LogicalSize
>
&
aPercentageBasis
)
{
nscoord
sizeTakenByBoxSizing
=
0
;
if
(
MOZ_UNLIKELY
(
aBoxSizing
=
=
StyleBoxSizing
:
:
Border
)
)
{
const
bool
isHorizontalAxis
=
aIsInlineAxis
=
=
!
aFrame
-
>
GetWritingMode
(
)
.
IsVertical
(
)
;
const
nsStyleBorder
*
styleBorder
=
aFrame
-
>
StyleBorder
(
)
;
sizeTakenByBoxSizing
=
isHorizontalAxis
?
styleBorder
-
>
GetComputedBorder
(
)
.
LeftRight
(
)
:
styleBorder
-
>
GetComputedBorder
(
)
.
TopBottom
(
)
;
if
(
!
aIgnorePadding
)
{
const
auto
&
stylePadding
=
aFrame
-
>
StylePadding
(
)
-
>
mPadding
;
const
LengthPercentage
&
pStart
=
stylePadding
.
Get
(
isHorizontalAxis
?
eSideLeft
:
eSideTop
)
;
const
LengthPercentage
&
pEnd
=
stylePadding
.
Get
(
isHorizontalAxis
?
eSideRight
:
eSideBottom
)
;
nscoord
pad
;
if
(
GetDefiniteSize
(
pStart
aFrame
aIsInlineAxis
aPercentageBasis
&
pad
)
|
|
(
aPercentageBasis
.
isNothing
(
)
&
&
GetPercentBSize
(
pStart
aFrame
isHorizontalAxis
pad
)
)
)
{
sizeTakenByBoxSizing
+
=
pad
;
}
if
(
GetDefiniteSize
(
pEnd
aFrame
aIsInlineAxis
aPercentageBasis
&
pad
)
|
|
(
aPercentageBasis
.
isNothing
(
)
&
&
GetPercentBSize
(
pEnd
aFrame
isHorizontalAxis
pad
)
)
)
{
sizeTakenByBoxSizing
+
=
pad
;
}
}
}
return
sizeTakenByBoxSizing
;
}
enum
eWidthProperty
{
PROP_WIDTH
PROP_MAX_WIDTH
PROP_MIN_WIDTH
}
;
static
bool
GetIntrinsicCoord
(
StyleExtremumLength
aStyle
gfxContext
*
aRenderingContext
nsIFrame
*
aFrame
eWidthProperty
aProperty
nscoord
&
aResult
)
{
MOZ_ASSERT
(
aProperty
=
=
PROP_WIDTH
|
|
aProperty
=
=
PROP_MAX_WIDTH
|
|
aProperty
=
=
PROP_MIN_WIDTH
"
unexpected
property
"
)
;
if
(
aStyle
=
=
StyleExtremumLength
:
:
MozAvailable
)
return
false
;
if
(
aStyle
=
=
StyleExtremumLength
:
:
MozFitContent
)
{
if
(
aProperty
=
=
PROP_WIDTH
)
return
false
;
if
(
aProperty
=
=
PROP_MAX_WIDTH
)
aStyle
=
StyleExtremumLength
:
:
MaxContent
;
else
aStyle
=
StyleExtremumLength
:
:
MinContent
;
}
NS_ASSERTION
(
aStyle
=
=
StyleExtremumLength
:
:
MinContent
|
|
aStyle
=
=
StyleExtremumLength
:
:
MaxContent
"
should
have
reduced
everything
remaining
to
one
of
these
"
)
;
AutoMaybeDisableFontInflation
an
(
aFrame
)
;
if
(
aStyle
=
=
StyleExtremumLength
:
:
MaxContent
)
aResult
=
aFrame
-
>
GetPrefISize
(
aRenderingContext
)
;
else
aResult
=
aFrame
-
>
GetMinISize
(
aRenderingContext
)
;
return
true
;
}
template
<
typename
SizeOrMaxSize
>
static
bool
GetIntrinsicCoord
(
const
SizeOrMaxSize
&
aStyle
gfxContext
*
aRenderingContext
nsIFrame
*
aFrame
eWidthProperty
aProperty
nscoord
&
aResult
)
{
if
(
!
aStyle
.
IsExtremumLength
(
)
)
{
return
false
;
}
return
GetIntrinsicCoord
(
aStyle
.
AsExtremumLength
(
)
aRenderingContext
aFrame
aProperty
aResult
)
;
}
#
undef
DEBUG_INTRINSIC_WIDTH
#
ifdef
DEBUG_INTRINSIC_WIDTH
static
int32_t
gNoiseIndent
=
0
;
#
endif
static
nscoord
AddIntrinsicSizeOffset
(
gfxContext
*
aRenderingContext
nsIFrame
*
aFrame
const
nsIFrame
:
:
IntrinsicSizeOffsetData
&
aOffsets
IntrinsicISizeType
aType
StyleBoxSizing
aBoxSizing
nscoord
aContentSize
nscoord
aContentMinSize
const
StyleSize
&
aStyleSize
const
nscoord
*
aFixedMinSize
const
StyleSize
&
aStyleMinSize
const
nscoord
*
aFixedMaxSize
const
StyleMaxSize
&
aStyleMaxSize
uint32_t
aFlags
PhysicalAxis
aAxis
)
{
nscoord
result
=
aContentSize
;
nscoord
min
=
aContentMinSize
;
nscoord
coordOutsideSize
=
0
;
if
(
!
(
aFlags
&
nsLayoutUtils
:
:
IGNORE_PADDING
)
)
{
coordOutsideSize
+
=
aOffsets
.
padding
;
}
coordOutsideSize
+
=
aOffsets
.
border
;
if
(
aBoxSizing
=
=
StyleBoxSizing
:
:
Border
)
{
min
+
=
coordOutsideSize
;
result
=
NSCoordSaturatingAdd
(
result
coordOutsideSize
)
;
coordOutsideSize
=
0
;
}
coordOutsideSize
+
=
aOffsets
.
margin
;
min
+
=
coordOutsideSize
;
result
=
NSCoordSaturatingAdd
(
result
coordOutsideSize
)
;
nscoord
size
;
if
(
aType
=
=
IntrinsicISizeType
:
:
MinISize
&
&
aFrame
-
>
IsPercentageResolvedAgainstZero
(
aStyleSize
aStyleMaxSize
)
)
{
result
=
0
;
}
else
if
(
GetAbsoluteCoord
(
aStyleSize
size
)
|
|
GetIntrinsicCoord
(
aStyleSize
aRenderingContext
aFrame
PROP_WIDTH
size
)
)
{
result
=
size
+
coordOutsideSize
;
}
nscoord
maxSize
=
aFixedMaxSize
?
*
aFixedMaxSize
:
0
;
if
(
aFixedMaxSize
|
|
GetIntrinsicCoord
(
aStyleMaxSize
aRenderingContext
aFrame
PROP_MAX_WIDTH
maxSize
)
)
{
maxSize
+
=
coordOutsideSize
;
if
(
result
>
maxSize
)
{
result
=
maxSize
;
}
}
nscoord
minSize
=
aFixedMinSize
?
*
aFixedMinSize
:
0
;
if
(
aFixedMinSize
|
|
GetIntrinsicCoord
(
aStyleMinSize
aRenderingContext
aFrame
PROP_MIN_WIDTH
minSize
)
)
{
minSize
+
=
coordOutsideSize
;
if
(
result
<
minSize
)
{
result
=
minSize
;
}
}
if
(
result
<
min
)
{
result
=
min
;
}
const
nsStyleDisplay
*
disp
=
aFrame
-
>
StyleDisplay
(
)
;
if
(
aFrame
-
>
IsThemed
(
disp
)
)
{
LayoutDeviceIntSize
devSize
;
bool
canOverride
=
true
;
nsPresContext
*
pc
=
aFrame
-
>
PresContext
(
)
;
pc
-
>
Theme
(
)
-
>
GetMinimumWidgetSize
(
pc
aFrame
disp
-
>
EffectiveAppearance
(
)
&
devSize
&
canOverride
)
;
nscoord
themeSize
=
pc
-
>
DevPixelsToAppUnits
(
aAxis
=
=
eAxisVertical
?
devSize
.
height
:
devSize
.
width
)
;
themeSize
+
=
aOffsets
.
margin
;
if
(
themeSize
>
result
|
|
!
canOverride
)
{
result
=
themeSize
;
}
}
return
result
;
}
static
void
AddStateBitToAncestors
(
nsIFrame
*
aFrame
nsFrameState
aBit
)
{
for
(
nsIFrame
*
f
=
aFrame
;
f
;
f
=
f
-
>
GetParent
(
)
)
{
if
(
f
-
>
HasAnyStateBits
(
aBit
)
)
{
break
;
}
f
-
>
AddStateBits
(
aBit
)
;
}
}
nscoord
nsLayoutUtils
:
:
IntrinsicForAxis
(
PhysicalAxis
aAxis
gfxContext
*
aRenderingContext
nsIFrame
*
aFrame
IntrinsicISizeType
aType
const
Maybe
<
LogicalSize
>
&
aPercentageBasis
uint32_t
aFlags
nscoord
aMarginBoxMinSizeClamp
)
{
MOZ_ASSERT
(
aFrame
"
null
frame
"
)
;
MOZ_ASSERT
(
aFrame
-
>
GetParent
(
)
"
IntrinsicForAxis
called
on
frame
not
in
tree
"
)
;
MOZ_ASSERT
(
aFrame
-
>
GetParent
(
)
-
>
Type
(
)
!
=
LayoutFrameType
:
:
GridContainer
|
|
aPercentageBasis
.
isSome
(
)
"
grid
layout
should
always
pass
a
percentage
basis
"
)
;
const
bool
horizontalAxis
=
MOZ_LIKELY
(
aAxis
=
=
eAxisHorizontal
)
;
#
ifdef
DEBUG_INTRINSIC_WIDTH
nsIFrame
:
:
IndentBy
(
stderr
gNoiseIndent
)
;
aFrame
-
>
ListTag
(
stderr
)
;
printf_stderr
(
"
%
s
%
s
intrinsic
size
for
container
:
\
n
"
aType
=
=
IntrinsicISizeType
:
:
MinISize
?
"
min
"
:
"
pref
"
horizontalAxis
?
"
horizontal
"
:
"
vertical
"
)
;
#
endif
AutoMaybeDisableFontInflation
an
(
aFrame
)
;
const
nsStylePosition
*
stylePos
=
aFrame
-
>
StylePosition
(
)
;
StyleBoxSizing
boxSizing
=
stylePos
-
>
mBoxSizing
;
StyleSize
styleMinISize
=
horizontalAxis
?
stylePos
-
>
mMinWidth
:
stylePos
-
>
mMinHeight
;
StyleSize
styleISize
=
(
aFlags
&
MIN_INTRINSIC_ISIZE
)
?
styleMinISize
:
(
horizontalAxis
?
stylePos
-
>
mWidth
:
stylePos
-
>
mHeight
)
;
MOZ_ASSERT
(
!
(
aFlags
&
MIN_INTRINSIC_ISIZE
)
|
|
styleISize
.
IsAuto
(
)
|
|
styleISize
.
IsExtremumLength
(
)
"
should
only
use
MIN_INTRINSIC_ISIZE
for
intrinsic
values
"
)
;
StyleMaxSize
styleMaxISize
=
horizontalAxis
?
stylePos
-
>
mMaxWidth
:
stylePos
-
>
mMaxHeight
;
PhysicalAxis
ourInlineAxis
=
aFrame
-
>
GetWritingMode
(
)
.
PhysicalAxis
(
eLogicalAxisInline
)
;
const
bool
isInlineAxis
=
aAxis
=
=
ourInlineAxis
;
auto
resetIfKeywords
=
[
]
(
StyleSize
&
aSize
StyleSize
&
aMinSize
StyleMaxSize
&
aMaxSize
)
{
if
(
aSize
.
IsExtremumLength
(
)
)
{
aSize
=
StyleSize
:
:
Auto
(
)
;
}
if
(
aMinSize
.
IsExtremumLength
(
)
)
{
aMinSize
=
StyleSize
:
:
Auto
(
)
;
}
if
(
aMaxSize
.
IsExtremumLength
(
)
)
{
aMaxSize
=
StyleMaxSize
:
:
None
(
)
;
}
}
;
if
(
!
isInlineAxis
)
{
resetIfKeywords
(
styleISize
styleMinISize
styleMaxISize
)
;
}
nscoord
result
=
0
min
=
0
;
nscoord
maxISize
;
bool
haveFixedMaxISize
=
GetAbsoluteCoord
(
styleMaxISize
maxISize
)
;
nscoord
minISize
;
bool
haveFixedMinISize
;
if
(
styleMinISize
.
IsAuto
(
)
)
{
minISize
=
0
;
haveFixedMinISize
=
true
;
}
else
{
haveFixedMinISize
=
GetAbsoluteCoord
(
styleMinISize
minISize
)
;
}
if
(
styleISize
.
IsExtremumLength
(
)
&
&
(
styleISize
.
AsExtremumLength
(
)
=
=
StyleExtremumLength
:
:
MaxContent
|
|
styleISize
.
AsExtremumLength
(
)
=
=
StyleExtremumLength
:
:
MinContent
)
)
{
MOZ_ASSERT
(
isInlineAxis
)
;
boxSizing
=
StyleBoxSizing
:
:
Content
;
}
else
if
(
!
styleISize
.
ConvertsToLength
(
)
&
&
!
(
haveFixedMinISize
&
&
haveFixedMaxISize
&
&
maxISize
<
=
minISize
)
)
{
#
ifdef
DEBUG_INTRINSIC_WIDTH
+
+
gNoiseIndent
;
#
endif
if
(
MOZ_UNLIKELY
(
!
isInlineAxis
)
)
{
IntrinsicSize
intrinsicSize
=
aFrame
-
>
GetIntrinsicSize
(
)
;
const
auto
&
intrinsicBSize
=
horizontalAxis
?
intrinsicSize
.
width
:
intrinsicSize
.
height
;
if
(
intrinsicBSize
)
{
result
=
*
intrinsicBSize
;
}
else
{
if
(
aFlags
&
BAIL_IF_REFLOW_NEEDED
)
{
return
NS_INTRINSIC_ISIZE_UNKNOWN
;
}
result
=
aFrame
-
>
BSize
(
)
;
}
}
else
{
result
=
aType
=
=
IntrinsicISizeType
:
:
MinISize
?
aFrame
-
>
GetMinISize
(
aRenderingContext
)
:
aFrame
-
>
GetPrefISize
(
aRenderingContext
)
;
}
#
ifdef
DEBUG_INTRINSIC_WIDTH
-
-
gNoiseIndent
;
nsIFrame
:
:
IndentBy
(
stderr
gNoiseIndent
)
;
aFrame
-
>
ListTag
(
stderr
)
;
printf_stderr
(
"
%
s
%
s
intrinsic
size
from
frame
is
%
d
.
\
n
"
aType
=
=
IntrinsicISizeType
:
:
MinISize
?
"
min
"
:
"
pref
"
horizontalAxis
?
"
horizontal
"
:
"
vertical
"
result
)
;
#
endif
StyleSize
styleBSize
=
horizontalAxis
?
stylePos
-
>
mHeight
:
stylePos
-
>
mWidth
;
StyleSize
styleMinBSize
=
horizontalAxis
?
stylePos
-
>
mMinHeight
:
stylePos
-
>
mMinWidth
;
StyleMaxSize
styleMaxBSize
=
horizontalAxis
?
stylePos
-
>
mMaxHeight
:
stylePos
-
>
mMaxWidth
;
if
(
isInlineAxis
)
{
resetIfKeywords
(
styleBSize
styleMinBSize
styleMaxBSize
)
;
}
if
(
!
styleBSize
.
IsAuto
(
)
|
|
!
(
styleMinBSize
.
IsAuto
(
)
|
|
(
styleMinBSize
.
ConvertsToLength
(
)
&
&
styleMinBSize
.
ToLength
(
)
=
=
0
)
)
|
|
!
styleMaxBSize
.
IsNone
(
)
)
{
if
(
AspectRatio
ratio
=
aFrame
-
>
GetAspectRatio
(
)
)
{
if
(
!
horizontalAxis
)
{
ratio
=
ratio
.
Inverted
(
)
;
}
AddStateBitToAncestors
(
aFrame
NS_FRAME_DESCENDANT_INTRINSIC_ISIZE_DEPENDS_ON_BSIZE
)
;
const
bool
ignorePadding
=
(
aFlags
&
IGNORE_PADDING
)
|
|
aFrame
-
>
IsAbsolutelyPositioned
(
)
;
nscoord
bSizeTakenByBoxSizing
=
GetDefiniteSizeTakenByBoxSizing
(
boxSizing
aFrame
!
isInlineAxis
ignorePadding
aPercentageBasis
)
;
nscoord
minContentSize
=
result
;
nscoord
h
;
if
(
GetDefiniteSize
(
styleBSize
aFrame
!
isInlineAxis
aPercentageBasis
&
h
)
|
|
(
aPercentageBasis
.
isNothing
(
)
&
&
GetPercentBSize
(
styleBSize
aFrame
horizontalAxis
h
)
)
)
{
h
=
std
:
:
max
(
0
h
-
bSizeTakenByBoxSizing
)
;
result
=
ratio
.
ApplyTo
(
h
)
;
}
if
(
GetDefiniteSize
(
styleMaxBSize
aFrame
!
isInlineAxis
aPercentageBasis
&
h
)
|
|
(
aPercentageBasis
.
isNothing
(
)
&
&
GetPercentBSize
(
styleMaxBSize
aFrame
horizontalAxis
h
)
)
)
{
h
=
std
:
:
max
(
0
h
-
bSizeTakenByBoxSizing
)
;
nscoord
maxISize
=
ratio
.
ApplyTo
(
h
)
;
if
(
maxISize
<
result
)
{
result
=
maxISize
;
}
if
(
maxISize
<
minContentSize
)
{
minContentSize
=
maxISize
;
}
}
if
(
GetDefiniteSize
(
styleMinBSize
aFrame
!
isInlineAxis
aPercentageBasis
&
h
)
|
|
(
aPercentageBasis
.
isNothing
(
)
&
&
GetPercentBSize
(
styleMinBSize
aFrame
horizontalAxis
h
)
)
)
{
h
=
std
:
:
max
(
0
h
-
bSizeTakenByBoxSizing
)
;
nscoord
minISize
=
ratio
.
ApplyTo
(
h
)
;
if
(
minISize
>
result
)
{
result
=
minISize
;
}
if
(
minISize
>
minContentSize
)
{
minContentSize
=
minISize
;
}
}
if
(
MOZ_UNLIKELY
(
aFlags
&
nsLayoutUtils
:
:
MIN_INTRINSIC_ISIZE
)
)
{
result
=
std
:
:
min
(
result
minContentSize
)
;
}
}
}
}
if
(
aFrame
-
>
IsTableFrame
(
)
)
{
min
=
aFrame
-
>
GetMinISize
(
aRenderingContext
)
;
}
nscoord
pmPercentageBasis
=
NS_UNCONSTRAINEDSIZE
;
if
(
aPercentageBasis
.
isSome
(
)
)
{
auto
childWM
=
aFrame
-
>
GetWritingMode
(
)
;
pmPercentageBasis
=
aFrame
-
>
GetParent
(
)
-
>
GetWritingMode
(
)
.
IsOrthogonalTo
(
childWM
)
?
aPercentageBasis
-
>
BSize
(
childWM
)
:
aPercentageBasis
-
>
ISize
(
childWM
)
;
}
nsIFrame
:
:
IntrinsicSizeOffsetData
offsets
=
MOZ_LIKELY
(
isInlineAxis
)
?
aFrame
-
>
IntrinsicISizeOffsets
(
pmPercentageBasis
)
:
aFrame
-
>
IntrinsicBSizeOffsets
(
pmPercentageBasis
)
;
nscoord
contentBoxSize
=
result
;
result
=
AddIntrinsicSizeOffset
(
aRenderingContext
aFrame
offsets
aType
boxSizing
result
min
styleISize
haveFixedMinISize
?
&
minISize
:
nullptr
styleMinISize
haveFixedMaxISize
?
&
maxISize
:
nullptr
styleMaxISize
aFlags
aAxis
)
;
nscoord
overflow
=
result
-
aMarginBoxMinSizeClamp
;
if
(
MOZ_UNLIKELY
(
overflow
>
0
)
)
{
nscoord
newContentBoxSize
=
std
:
:
max
(
nscoord
(
0
)
contentBoxSize
-
overflow
)
;
result
-
=
contentBoxSize
-
newContentBoxSize
;
}
#
ifdef
DEBUG_INTRINSIC_WIDTH
nsIFrame
:
:
IndentBy
(
stderr
gNoiseIndent
)
;
aFrame
-
>
ListTag
(
stderr
)
;
printf_stderr
(
"
%
s
%
s
intrinsic
size
for
container
is
%
d
twips
.
\
n
"
aType
=
=
IntrinsicISizeType
:
:
MinISize
?
"
min
"
:
"
pref
"
horizontalAxis
?
"
horizontal
"
:
"
vertical
"
result
)
;
#
endif
return
result
;
}
nscoord
nsLayoutUtils
:
:
IntrinsicForContainer
(
gfxContext
*
aRenderingContext
nsIFrame
*
aFrame
IntrinsicISizeType
aType
uint32_t
aFlags
)
{
MOZ_ASSERT
(
aFrame
&
&
aFrame
-
>
GetParent
(
)
)
;
PhysicalAxis
axis
=
aFrame
-
>
GetParent
(
)
-
>
GetWritingMode
(
)
.
PhysicalAxis
(
eLogicalAxisInline
)
;
return
IntrinsicForAxis
(
axis
aRenderingContext
aFrame
aType
Nothing
(
)
aFlags
)
;
}
nscoord
nsLayoutUtils
:
:
MinSizeContributionForAxis
(
PhysicalAxis
aAxis
gfxContext
*
aRC
nsIFrame
*
aFrame
IntrinsicISizeType
aType
const
LogicalSize
&
aPercentageBasis
uint32_t
aFlags
)
{
MOZ_ASSERT
(
aFrame
)
;
MOZ_ASSERT
(
aFrame
-
>
IsFlexOrGridItem
(
)
"
only
grid
/
flex
items
have
this
behavior
currently
"
)
;
#
ifdef
DEBUG_INTRINSIC_WIDTH
nsIFrame
:
:
IndentBy
(
stderr
gNoiseIndent
)
;
aFrame
-
>
ListTag
(
stderr
)
;
printf_stderr
(
"
%
s
min
-
isize
for
%
s
WM
:
\
n
"
aType
=
=
IntrinsicISizeType
:
:
MinISize
?
"
min
"
:
"
pref
"
aAxis
=
=
eAxisVertical
?
"
vertical
"
:
"
horizontal
"
)
;
#
endif
const
nsStylePosition
*
const
stylePos
=
aFrame
-
>
StylePosition
(
)
;
StyleSize
size
=
aAxis
=
=
eAxisHorizontal
?
stylePos
-
>
mMinWidth
:
stylePos
-
>
mMinHeight
;
StyleMaxSize
maxSize
=
aAxis
=
=
eAxisHorizontal
?
stylePos
-
>
mMaxWidth
:
stylePos
-
>
mMaxHeight
;
auto
childWM
=
aFrame
-
>
GetWritingMode
(
)
;
PhysicalAxis
ourInlineAxis
=
childWM
.
PhysicalAxis
(
eLogicalAxisInline
)
;
if
(
aAxis
!
=
ourInlineAxis
)
{
if
(
size
.
IsExtremumLength
(
)
)
{
size
=
StyleSize
:
:
Auto
(
)
;
}
if
(
maxSize
.
IsExtremumLength
(
)
)
{
maxSize
=
StyleMaxSize
:
:
None
(
)
;
}
}
nscoord
minSize
;
nscoord
*
fixedMinSize
=
nullptr
;
if
(
size
.
IsAuto
(
)
)
{
if
(
aFrame
-
>
StyleDisplay
(
)
-
>
mOverflowX
=
=
StyleOverflow
:
:
Visible
)
{
size
=
aAxis
=
=
eAxisHorizontal
?
stylePos
-
>
mWidth
:
stylePos
-
>
mHeight
;
if
(
aAxis
!
=
ourInlineAxis
&
&
size
.
IsExtremumLength
(
)
)
{
size
=
StyleSize
:
:
Auto
(
)
;
}
if
(
GetAbsoluteCoord
(
size
minSize
)
)
{
fixedMinSize
=
&
minSize
;
}
else
if
(
aFrame
-
>
IsPercentageResolvedAgainstZero
(
size
maxSize
)
)
{
minSize
=
0
;
fixedMinSize
=
&
minSize
;
}
}
else
{
minSize
=
0
;
fixedMinSize
=
&
minSize
;
}
}
else
if
(
GetAbsoluteCoord
(
size
minSize
)
)
{
fixedMinSize
=
&
minSize
;
}
else
if
(
!
size
.
IsExtremumLength
(
)
)
{
MOZ_ASSERT
(
size
.
HasPercent
(
)
)
;
minSize
=
0
;
fixedMinSize
=
&
minSize
;
}
if
(
!
fixedMinSize
)
{
#
ifdef
DEBUG_INTRINSIC_WIDTH
nsIFrame
:
:
IndentBy
(
stderr
gNoiseIndent
)
;
aFrame
-
>
ListTag
(
stderr
)
;
printf_stderr
(
"
%
s
min
-
isize
is
indefinite
.
\
n
"
aType
=
=
IntrinsicISizeType
:
:
MinISize
?
"
min
"
:
"
pref
"
)
;
#
endif
return
NS_UNCONSTRAINEDSIZE
;
}
AutoMaybeDisableFontInflation
an
(
aFrame
)
;
nscoord
pmPercentageBasis
=
aFrame
-
>
GetParent
(
)
-
>
GetWritingMode
(
)
.
IsOrthogonalTo
(
childWM
)
?
aPercentageBasis
.
BSize
(
childWM
)
:
aPercentageBasis
.
ISize
(
childWM
)
;
nsIFrame
:
:
IntrinsicSizeOffsetData
offsets
=
ourInlineAxis
=
=
aAxis
?
aFrame
-
>
IntrinsicISizeOffsets
(
pmPercentageBasis
)
:
aFrame
-
>
IntrinsicBSizeOffsets
(
pmPercentageBasis
)
;
nscoord
result
=
0
;
nscoord
min
=
0
;
result
=
AddIntrinsicSizeOffset
(
aRC
aFrame
offsets
aType
stylePos
-
>
mBoxSizing
result
min
size
fixedMinSize
size
nullptr
maxSize
aFlags
aAxis
)
;
#
ifdef
DEBUG_INTRINSIC_WIDTH
nsIFrame
:
:
IndentBy
(
stderr
gNoiseIndent
)
;
aFrame
-
>
ListTag
(
stderr
)
;
printf_stderr
(
"
%
s
min
-
isize
is
%
d
twips
.
\
n
"
aType
=
=
IntrinsicISizeType
:
:
MinISize
?
"
min
"
:
"
pref
"
result
)
;
#
endif
return
result
;
}
nscoord
nsLayoutUtils
:
:
ComputeBSizeDependentValue
(
nscoord
aContainingBlockBSize
const
LengthPercentageOrAuto
&
aCoord
)
{
MOZ_ASSERT
(
NS_UNCONSTRAINEDSIZE
!
=
aContainingBlockBSize
|
|
!
aCoord
.
HasPercent
(
)
"
unexpected
containing
block
block
-
size
"
)
;
if
(
aCoord
.
IsAuto
(
)
)
{
return
0
;
}
return
aCoord
.
AsLengthPercentage
(
)
.
Resolve
(
aContainingBlockBSize
)
;
}
void
nsLayoutUtils
:
:
MarkDescendantsDirty
(
nsIFrame
*
aSubtreeRoot
)
{
AutoTArray
<
nsIFrame
*
4
>
subtrees
;
subtrees
.
AppendElement
(
aSubtreeRoot
)
;
do
{
nsIFrame
*
subtreeRoot
=
subtrees
.
PopLastElement
(
)
;
AutoTArray
<
nsIFrame
*
32
>
stack
;
stack
.
AppendElement
(
subtreeRoot
)
;
do
{
nsIFrame
*
f
=
stack
.
PopLastElement
(
)
;
f
-
>
MarkIntrinsicISizesDirty
(
)
;
if
(
f
-
>
IsPlaceholderFrame
(
)
)
{
nsIFrame
*
oof
=
nsPlaceholderFrame
:
:
GetRealFrameForPlaceholder
(
f
)
;
if
(
!
nsLayoutUtils
:
:
IsProperAncestorFrame
(
subtreeRoot
oof
)
)
{
subtrees
.
AppendElement
(
oof
)
;
}
}
for
(
const
auto
&
childList
:
f
-
>
ChildLists
(
)
)
{
for
(
nsIFrame
*
kid
:
childList
.
mList
)
{
stack
.
AppendElement
(
kid
)
;
}
}
}
while
(
stack
.
Length
(
)
!
=
0
)
;
}
while
(
subtrees
.
Length
(
)
!
=
0
)
;
}
void
nsLayoutUtils
:
:
MarkIntrinsicISizesDirtyIfDependentOnBSize
(
nsIFrame
*
aFrame
)
{
AutoTArray
<
nsIFrame
*
32
>
stack
;
stack
.
AppendElement
(
aFrame
)
;
do
{
nsIFrame
*
f
=
stack
.
PopLastElement
(
)
;
if
(
!
f
-
>
HasAnyStateBits
(
NS_FRAME_DESCENDANT_INTRINSIC_ISIZE_DEPENDS_ON_BSIZE
)
)
{
continue
;
}
f
-
>
MarkIntrinsicISizesDirty
(
)
;
for
(
const
auto
&
childList
:
f
-
>
ChildLists
(
)
)
{
for
(
nsIFrame
*
kid
:
childList
.
mList
)
{
stack
.
AppendElement
(
kid
)
;
}
}
}
while
(
stack
.
Length
(
)
!
=
0
)
;
}
nsSize
nsLayoutUtils
:
:
ComputeAutoSizeWithIntrinsicDimensions
(
nscoord
minWidth
nscoord
minHeight
nscoord
maxWidth
nscoord
maxHeight
nscoord
tentWidth
nscoord
tentHeight
)
{
if
(
minWidth
>
maxWidth
)
maxWidth
=
minWidth
;
if
(
minHeight
>
maxHeight
)
maxHeight
=
minHeight
;
nscoord
heightAtMaxWidth
heightAtMinWidth
widthAtMaxHeight
widthAtMinHeight
;
if
(
tentWidth
>
0
)
{
heightAtMaxWidth
=
NSCoordMulDiv
(
maxWidth
tentHeight
tentWidth
)
;
if
(
heightAtMaxWidth
<
minHeight
)
heightAtMaxWidth
=
minHeight
;
heightAtMinWidth
=
NSCoordMulDiv
(
minWidth
tentHeight
tentWidth
)
;
if
(
heightAtMinWidth
>
maxHeight
)
heightAtMinWidth
=
maxHeight
;
}
else
{
heightAtMaxWidth
=
heightAtMinWidth
=
NS_CSS_MINMAX
(
tentHeight
minHeight
maxHeight
)
;
}
if
(
tentHeight
>
0
)
{
widthAtMaxHeight
=
NSCoordMulDiv
(
maxHeight
tentWidth
tentHeight
)
;
if
(
widthAtMaxHeight
<
minWidth
)
widthAtMaxHeight
=
minWidth
;
widthAtMinHeight
=
NSCoordMulDiv
(
minHeight
tentWidth
tentHeight
)
;
if
(
widthAtMinHeight
>
maxWidth
)
widthAtMinHeight
=
maxWidth
;
}
else
{
widthAtMaxHeight
=
widthAtMinHeight
=
NS_CSS_MINMAX
(
tentWidth
minWidth
maxWidth
)
;
}
nscoord
width
height
;
if
(
tentWidth
>
maxWidth
)
{
if
(
tentHeight
>
maxHeight
)
{
if
(
int64_t
(
maxWidth
)
*
int64_t
(
tentHeight
)
<
=
int64_t
(
maxHeight
)
*
int64_t
(
tentWidth
)
)
{
width
=
maxWidth
;
height
=
heightAtMaxWidth
;
}
else
{
width
=
widthAtMaxHeight
;
height
=
maxHeight
;
}
}
else
{
width
=
maxWidth
;
height
=
heightAtMaxWidth
;
}
}
else
if
(
tentWidth
<
minWidth
)
{
if
(
tentHeight
<
minHeight
)
{
if
(
int64_t
(
minWidth
)
*
int64_t
(
tentHeight
)
<
=
int64_t
(
minHeight
)
*
int64_t
(
tentWidth
)
)
{
width
=
widthAtMinHeight
;
height
=
minHeight
;
}
else
{
width
=
minWidth
;
height
=
heightAtMinWidth
;
}
}
else
{
width
=
minWidth
;
height
=
heightAtMinWidth
;
}
}
else
{
if
(
tentHeight
>
maxHeight
)
{
width
=
widthAtMaxHeight
;
height
=
maxHeight
;
}
else
if
(
tentHeight
<
minHeight
)
{
width
=
widthAtMinHeight
;
height
=
minHeight
;
}
else
{
width
=
tentWidth
;
height
=
tentHeight
;
}
}
return
nsSize
(
width
height
)
;
}
nscoord
nsLayoutUtils
:
:
MinISizeFromInline
(
nsIFrame
*
aFrame
gfxContext
*
aRenderingContext
)
{
NS_ASSERTION
(
!
aFrame
-
>
IsContainerForFontSizeInflation
(
)
"
should
not
be
container
for
font
size
inflation
"
)
;
nsIFrame
:
:
InlineMinISizeData
data
;
DISPLAY_MIN_INLINE_SIZE
(
aFrame
data
.
mPrevLines
)
;
aFrame
-
>
AddInlineMinISize
(
aRenderingContext
&
data
)
;
data
.
ForceBreak
(
)
;
return
data
.
mPrevLines
;
}
nscoord
nsLayoutUtils
:
:
PrefISizeFromInline
(
nsIFrame
*
aFrame
gfxContext
*
aRenderingContext
)
{
NS_ASSERTION
(
!
aFrame
-
>
IsContainerForFontSizeInflation
(
)
"
should
not
be
container
for
font
size
inflation
"
)
;
nsIFrame
:
:
InlinePrefISizeData
data
;
DISPLAY_PREF_INLINE_SIZE
(
aFrame
data
.
mPrevLines
)
;
aFrame
-
>
AddInlinePrefISize
(
aRenderingContext
&
data
)
;
data
.
ForceBreak
(
)
;
return
data
.
mPrevLines
;
}
static
nscolor
DarkenColor
(
nscolor
aColor
)
{
uint16_t
hue
sat
value
;
uint8_t
alpha
;
NS_RGB2HSV
(
aColor
hue
sat
value
alpha
)
;
if
(
value
>
sat
)
{
value
=
sat
;
NS_HSV2RGB
(
aColor
hue
sat
value
alpha
)
;
}
return
aColor
;
}
static
bool
ShouldDarkenColors
(
nsIFrame
*
aFrame
)
{
nsPresContext
*
pc
=
aFrame
-
>
PresContext
(
)
;
if
(
pc
-
>
GetBackgroundColorDraw
(
)
|
|
pc
-
>
GetBackgroundImageDraw
(
)
)
{
return
false
;
}
return
aFrame
-
>
StyleVisibility
(
)
-
>
mColorAdjust
!
=
StyleColorAdjust
:
:
Exact
;
}
nscolor
nsLayoutUtils
:
:
DarkenColorIfNeeded
(
nsIFrame
*
aFrame
nscolor
aColor
)
{
return
ShouldDarkenColors
(
aFrame
)
?
DarkenColor
(
aColor
)
:
aColor
;
}
gfxFloat
nsLayoutUtils
:
:
GetSnappedBaselineY
(
nsIFrame
*
aFrame
gfxContext
*
aContext
nscoord
aY
nscoord
aAscent
)
{
gfxFloat
appUnitsPerDevUnit
=
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
gfxFloat
baseline
=
gfxFloat
(
aY
)
+
aAscent
;
gfxRect
putativeRect
(
0
baseline
/
appUnitsPerDevUnit
1
1
)
;
if
(
!
aContext
-
>
UserToDevicePixelSnapped
(
putativeRect
true
)
)
return
baseline
;
return
aContext
-
>
DeviceToUser
(
putativeRect
.
TopLeft
(
)
)
.
y
*
appUnitsPerDevUnit
;
}
gfxFloat
nsLayoutUtils
:
:
GetSnappedBaselineX
(
nsIFrame
*
aFrame
gfxContext
*
aContext
nscoord
aX
nscoord
aAscent
)
{
gfxFloat
appUnitsPerDevUnit
=
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
gfxFloat
baseline
=
gfxFloat
(
aX
)
+
aAscent
;
gfxRect
putativeRect
(
baseline
/
appUnitsPerDevUnit
0
1
1
)
;
if
(
!
aContext
-
>
UserToDevicePixelSnapped
(
putativeRect
true
)
)
{
return
baseline
;
}
return
aContext
-
>
DeviceToUser
(
putativeRect
.
TopLeft
(
)
)
.
x
*
appUnitsPerDevUnit
;
}
#
define
MAX_GFX_TEXT_BUF_SIZE
8000
static
int32_t
FindSafeLength
(
const
char16_t
*
aString
uint32_t
aLength
uint32_t
aMaxChunkLength
)
{
if
(
aLength
<
=
aMaxChunkLength
)
return
aLength
;
int32_t
len
=
aMaxChunkLength
;
while
(
len
>
0
&
&
NS_IS_LOW_SURROGATE
(
aString
[
len
]
)
)
{
len
-
-
;
}
if
(
len
=
=
0
)
{
return
aMaxChunkLength
;
}
return
len
;
}
static
int32_t
GetMaxChunkLength
(
nsFontMetrics
&
aFontMetrics
)
{
return
std
:
:
min
(
aFontMetrics
.
GetMaxStringLength
(
)
MAX_GFX_TEXT_BUF_SIZE
)
;
}
nscoord
nsLayoutUtils
:
:
AppUnitWidthOfString
(
const
char16_t
*
aString
uint32_t
aLength
nsFontMetrics
&
aFontMetrics
DrawTarget
*
aDrawTarget
)
{
uint32_t
maxChunkLength
=
GetMaxChunkLength
(
aFontMetrics
)
;
nscoord
width
=
0
;
while
(
aLength
>
0
)
{
int32_t
len
=
FindSafeLength
(
aString
aLength
maxChunkLength
)
;
width
+
=
aFontMetrics
.
GetWidth
(
aString
len
aDrawTarget
)
;
aLength
-
=
len
;
aString
+
=
len
;
}
return
width
;
}
nscoord
nsLayoutUtils
:
:
AppUnitWidthOfStringBidi
(
const
char16_t
*
aString
uint32_t
aLength
const
nsIFrame
*
aFrame
nsFontMetrics
&
aFontMetrics
gfxContext
&
aContext
)
{
nsPresContext
*
presContext
=
aFrame
-
>
PresContext
(
)
;
if
(
presContext
-
>
BidiEnabled
(
)
)
{
nsBidiLevel
level
=
nsBidiPresUtils
:
:
BidiLevelFromStyle
(
aFrame
-
>
Style
(
)
)
;
return
nsBidiPresUtils
:
:
MeasureTextWidth
(
aString
aLength
level
presContext
aContext
aFontMetrics
)
;
}
aFontMetrics
.
SetTextRunRTL
(
false
)
;
aFontMetrics
.
SetVertical
(
aFrame
-
>
GetWritingMode
(
)
.
IsVertical
(
)
)
;
aFontMetrics
.
SetTextOrientation
(
aFrame
-
>
StyleVisibility
(
)
-
>
mTextOrientation
)
;
return
nsLayoutUtils
:
:
AppUnitWidthOfString
(
aString
aLength
aFontMetrics
aContext
.
GetDrawTarget
(
)
)
;
}
bool
nsLayoutUtils
:
:
StringWidthIsGreaterThan
(
const
nsString
&
aString
nsFontMetrics
&
aFontMetrics
DrawTarget
*
aDrawTarget
nscoord
aWidth
)
{
const
char16_t
*
string
=
aString
.
get
(
)
;
uint32_t
length
=
aString
.
Length
(
)
;
uint32_t
maxChunkLength
=
GetMaxChunkLength
(
aFontMetrics
)
;
nscoord
width
=
0
;
while
(
length
>
0
)
{
int32_t
len
=
FindSafeLength
(
string
length
maxChunkLength
)
;
width
+
=
aFontMetrics
.
GetWidth
(
string
len
aDrawTarget
)
;
if
(
width
>
aWidth
)
{
return
true
;
}
length
-
=
len
;
string
+
=
len
;
}
return
false
;
}
nsBoundingMetrics
nsLayoutUtils
:
:
AppUnitBoundsOfString
(
const
char16_t
*
aString
uint32_t
aLength
nsFontMetrics
&
aFontMetrics
DrawTarget
*
aDrawTarget
)
{
uint32_t
maxChunkLength
=
GetMaxChunkLength
(
aFontMetrics
)
;
int32_t
len
=
FindSafeLength
(
aString
aLength
maxChunkLength
)
;
nsBoundingMetrics
totalMetrics
=
aFontMetrics
.
GetBoundingMetrics
(
aString
len
aDrawTarget
)
;
aLength
-
=
len
;
aString
+
=
len
;
while
(
aLength
>
0
)
{
len
=
FindSafeLength
(
aString
aLength
maxChunkLength
)
;
nsBoundingMetrics
metrics
=
aFontMetrics
.
GetBoundingMetrics
(
aString
len
aDrawTarget
)
;
totalMetrics
+
=
metrics
;
aLength
-
=
len
;
aString
+
=
len
;
}
return
totalMetrics
;
}
void
nsLayoutUtils
:
:
DrawString
(
const
nsIFrame
*
aFrame
nsFontMetrics
&
aFontMetrics
gfxContext
*
aContext
const
char16_t
*
aString
int32_t
aLength
nsPoint
aPoint
ComputedStyle
*
aComputedStyle
DrawStringFlags
aFlags
)
{
nsresult
rv
=
NS_ERROR_FAILURE
;
if
(
!
aComputedStyle
)
{
aComputedStyle
=
aFrame
-
>
Style
(
)
;
}
if
(
aFlags
&
DrawStringFlags
:
:
ForceHorizontal
)
{
aFontMetrics
.
SetVertical
(
false
)
;
}
else
{
aFontMetrics
.
SetVertical
(
WritingMode
(
aComputedStyle
)
.
IsVertical
(
)
)
;
}
aFontMetrics
.
SetTextOrientation
(
aComputedStyle
-
>
StyleVisibility
(
)
-
>
mTextOrientation
)
;
nsPresContext
*
presContext
=
aFrame
-
>
PresContext
(
)
;
if
(
presContext
-
>
BidiEnabled
(
)
)
{
nsBidiLevel
level
=
nsBidiPresUtils
:
:
BidiLevelFromStyle
(
aComputedStyle
)
;
rv
=
nsBidiPresUtils
:
:
RenderText
(
aString
aLength
level
presContext
*
aContext
aContext
-
>
GetDrawTarget
(
)
aFontMetrics
aPoint
.
x
aPoint
.
y
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
aFontMetrics
.
SetTextRunRTL
(
false
)
;
DrawUniDirString
(
aString
aLength
aPoint
aFontMetrics
*
aContext
)
;
}
}
void
nsLayoutUtils
:
:
DrawUniDirString
(
const
char16_t
*
aString
uint32_t
aLength
const
nsPoint
&
aPoint
nsFontMetrics
&
aFontMetrics
gfxContext
&
aContext
)
{
nscoord
x
=
aPoint
.
x
;
nscoord
y
=
aPoint
.
y
;
uint32_t
maxChunkLength
=
GetMaxChunkLength
(
aFontMetrics
)
;
if
(
aLength
<
=
maxChunkLength
)
{
aFontMetrics
.
DrawString
(
aString
aLength
x
y
&
aContext
aContext
.
GetDrawTarget
(
)
)
;
return
;
}
bool
isRTL
=
aFontMetrics
.
GetTextRunRTL
(
)
;
if
(
isRTL
)
{
x
+
=
nsLayoutUtils
:
:
AppUnitWidthOfString
(
aString
aLength
aFontMetrics
aContext
.
GetDrawTarget
(
)
)
;
}
while
(
aLength
>
0
)
{
int32_t
len
=
FindSafeLength
(
aString
aLength
maxChunkLength
)
;
nscoord
width
=
aFontMetrics
.
GetWidth
(
aString
len
aContext
.
GetDrawTarget
(
)
)
;
if
(
isRTL
)
{
x
-
=
width
;
}
aFontMetrics
.
DrawString
(
aString
len
x
y
&
aContext
aContext
.
GetDrawTarget
(
)
)
;
if
(
!
isRTL
)
{
x
+
=
width
;
}
aLength
-
=
len
;
aString
+
=
len
;
}
}
void
nsLayoutUtils
:
:
PaintTextShadow
(
const
nsIFrame
*
aFrame
gfxContext
*
aContext
const
nsRect
&
aTextRect
const
nsRect
&
aDirtyRect
const
nscolor
&
aForegroundColor
TextShadowCallback
aCallback
void
*
aCallbackData
)
{
const
nsStyleText
*
textStyle
=
aFrame
-
>
StyleText
(
)
;
auto
shadows
=
textStyle
-
>
mTextShadow
.
AsSpan
(
)
;
if
(
shadows
.
IsEmpty
(
)
)
{
return
;
}
gfxContext
*
aDestCtx
=
aContext
;
for
(
auto
&
shadow
:
Reversed
(
shadows
)
)
{
nsPoint
shadowOffset
(
shadow
.
horizontal
.
ToAppUnits
(
)
shadow
.
vertical
.
ToAppUnits
(
)
)
;
nscoord
blurRadius
=
std
:
:
max
(
shadow
.
blur
.
ToAppUnits
(
)
0
)
;
nsRect
shadowRect
(
aTextRect
)
;
shadowRect
.
MoveBy
(
shadowOffset
)
;
nsPresContext
*
presCtx
=
aFrame
-
>
PresContext
(
)
;
nsContextBoxBlur
contextBoxBlur
;
nscolor
shadowColor
=
shadow
.
color
.
CalcColor
(
aForegroundColor
)
;
if
(
auto
*
textDrawer
=
aContext
-
>
GetTextDrawer
(
)
)
{
wr
:
:
Shadow
wrShadow
;
wrShadow
.
offset
=
{
presCtx
-
>
AppUnitsToFloatDevPixels
(
shadow
.
horizontal
.
ToAppUnits
(
)
)
presCtx
-
>
AppUnitsToFloatDevPixels
(
shadow
.
vertical
.
ToAppUnits
(
)
)
}
;
wrShadow
.
blur_radius
=
presCtx
-
>
AppUnitsToFloatDevPixels
(
blurRadius
)
;
wrShadow
.
color
=
wr
:
:
ToColorF
(
ToDeviceColor
(
shadowColor
)
)
;
bool
inflate
=
false
;
textDrawer
-
>
AppendShadow
(
wrShadow
inflate
)
;
continue
;
}
gfxContext
*
shadowContext
=
contextBoxBlur
.
Init
(
shadowRect
0
blurRadius
presCtx
-
>
AppUnitsPerDevPixel
(
)
aDestCtx
aDirtyRect
nullptr
nsContextBoxBlur
:
:
DISABLE_HARDWARE_ACCELERATION_BLUR
)
;
if
(
!
shadowContext
)
continue
;
aDestCtx
-
>
Save
(
)
;
aDestCtx
-
>
NewPath
(
)
;
aDestCtx
-
>
SetColor
(
sRGBColor
:
:
FromABGR
(
shadowColor
)
)
;
aCallback
(
shadowContext
shadowOffset
shadowColor
aCallbackData
)
;
contextBoxBlur
.
DoPaint
(
)
;
aDestCtx
-
>
Restore
(
)
;
}
}
nscoord
nsLayoutUtils
:
:
GetCenteredFontBaseline
(
nsFontMetrics
*
aFontMetrics
nscoord
aLineHeight
bool
aIsInverted
)
{
nscoord
fontAscent
=
aIsInverted
?
aFontMetrics
-
>
MaxDescent
(
)
:
aFontMetrics
-
>
MaxAscent
(
)
;
nscoord
fontHeight
=
aFontMetrics
-
>
MaxHeight
(
)
;
nscoord
leading
=
aLineHeight
-
fontHeight
;
return
fontAscent
+
leading
/
2
;
}
bool
nsLayoutUtils
:
:
GetFirstLineBaseline
(
WritingMode
aWritingMode
const
nsIFrame
*
aFrame
nscoord
*
aResult
)
{
LinePosition
position
;
if
(
!
GetFirstLinePosition
(
aWritingMode
aFrame
&
position
)
)
return
false
;
*
aResult
=
position
.
mBaseline
;
return
true
;
}
bool
nsLayoutUtils
:
:
GetFirstLinePosition
(
WritingMode
aWM
const
nsIFrame
*
aFrame
LinePosition
*
aResult
)
{
if
(
aFrame
-
>
StyleDisplay
(
)
-
>
IsContainLayout
(
)
)
{
return
false
;
}
const
nsBlockFrame
*
block
=
do_QueryFrame
(
aFrame
)
;
if
(
!
block
)
{
LayoutFrameType
fType
=
aFrame
-
>
Type
(
)
;
if
(
fType
=
=
LayoutFrameType
:
:
TableWrapper
|
|
fType
=
=
LayoutFrameType
:
:
FlexContainer
|
|
fType
=
=
LayoutFrameType
:
:
GridContainer
)
{
if
(
(
fType
=
=
LayoutFrameType
:
:
GridContainer
&
&
aFrame
-
>
HasAnyStateBits
(
NS_STATE_GRID_SYNTHESIZE_BASELINE
)
)
|
|
(
fType
=
=
LayoutFrameType
:
:
FlexContainer
&
&
aFrame
-
>
HasAnyStateBits
(
NS_STATE_FLEX_SYNTHESIZE_BASELINE
)
)
|
|
(
fType
=
=
LayoutFrameType
:
:
TableWrapper
&
&
static_cast
<
const
nsTableWrapperFrame
*
>
(
aFrame
)
-
>
GetRowCount
(
)
=
=
0
)
)
{
aResult
-
>
mBStart
=
0
;
aResult
-
>
mBaseline
=
aFrame
-
>
SynthesizeBaselineBOffsetFromBorderBox
(
aWM
BaselineSharingGroup
:
:
First
)
;
aResult
-
>
mBEnd
=
aFrame
-
>
BSize
(
aWM
)
;
return
true
;
}
aResult
-
>
mBStart
=
0
;
aResult
-
>
mBaseline
=
aFrame
-
>
GetLogicalBaseline
(
aWM
)
;
aResult
-
>
mBEnd
=
aFrame
-
>
BSize
(
aWM
)
;
return
true
;
}
if
(
fType
=
=
LayoutFrameType
:
:
Scroll
)
{
nsIScrollableFrame
*
sFrame
=
do_QueryFrame
(
const_cast
<
nsIFrame
*
>
(
aFrame
)
)
;
if
(
!
sFrame
)
{
MOZ_ASSERT_UNREACHABLE
(
"
not
scroll
frame
"
)
;
}
LinePosition
kidPosition
;
if
(
GetFirstLinePosition
(
aWM
sFrame
-
>
GetScrolledFrame
(
)
&
kidPosition
)
)
{
*
aResult
=
kidPosition
+
aFrame
-
>
GetLogicalUsedBorderAndPadding
(
aWM
)
.
BStart
(
aWM
)
;
return
true
;
}
return
false
;
}
if
(
fType
=
=
LayoutFrameType
:
:
FieldSet
|
|
fType
=
=
LayoutFrameType
:
:
ColumnSet
)
{
LinePosition
kidPosition
;
nsIFrame
*
kid
=
aFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
kid
&
&
GetFirstLinePosition
(
aWM
kid
&
kidPosition
)
)
{
*
aResult
=
kidPosition
+
kid
-
>
GetLogicalNormalPosition
(
aWM
aFrame
-
>
GetSize
(
)
)
.
B
(
aWM
)
;
return
true
;
}
return
false
;
}
return
false
;
}
for
(
const
auto
&
line
:
block
-
>
Lines
(
)
)
{
if
(
line
.
IsBlock
(
)
)
{
const
nsIFrame
*
kid
=
line
.
mFirstChild
;
LinePosition
kidPosition
;
if
(
GetFirstLinePosition
(
aWM
kid
&
kidPosition
)
)
{
const
auto
&
containerSize
=
line
.
mContainerSize
;
*
aResult
=
kidPosition
+
kid
-
>
GetLogicalNormalPosition
(
aWM
containerSize
)
.
B
(
aWM
)
;
return
true
;
}
}
else
{
if
(
0
!
=
line
.
BSize
(
)
|
|
!
line
.
IsEmpty
(
)
)
{
nscoord
bStart
=
line
.
BStart
(
)
;
aResult
-
>
mBStart
=
bStart
;
aResult
-
>
mBaseline
=
bStart
+
line
.
GetLogicalAscent
(
)
;
aResult
-
>
mBEnd
=
bStart
+
line
.
BSize
(
)
;
return
true
;
}
}
}
return
false
;
}
bool
nsLayoutUtils
:
:
GetLastLineBaseline
(
WritingMode
aWM
const
nsIFrame
*
aFrame
nscoord
*
aResult
)
{
if
(
aFrame
-
>
StyleDisplay
(
)
-
>
IsContainLayout
(
)
)
{
return
false
;
}
const
nsBlockFrame
*
block
=
do_QueryFrame
(
aFrame
)
;
if
(
!
block
)
return
false
;
for
(
nsBlockFrame
:
:
ConstReverseLineIterator
line
=
block
-
>
LinesRBegin
(
)
line_end
=
block
-
>
LinesREnd
(
)
;
line
!
=
line_end
;
+
+
line
)
{
if
(
line
-
>
IsBlock
(
)
)
{
nsIFrame
*
kid
=
line
-
>
mFirstChild
;
nscoord
kidBaseline
;
const
nsSize
&
containerSize
=
line
-
>
mContainerSize
;
if
(
GetLastLineBaseline
(
aWM
kid
&
kidBaseline
)
)
{
*
aResult
=
kidBaseline
+
kid
-
>
GetLogicalNormalPosition
(
aWM
containerSize
)
.
B
(
aWM
)
;
return
true
;
}
else
if
(
kid
-
>
IsScrollFrame
(
)
)
{
kidBaseline
=
kid
-
>
GetLogicalBaseline
(
aWM
)
;
*
aResult
=
kidBaseline
+
kid
-
>
GetLogicalNormalPosition
(
aWM
containerSize
)
.
B
(
aWM
)
;
return
true
;
}
}
else
{
if
(
line
-
>
BSize
(
)
!
=
0
|
|
!
line
-
>
IsEmpty
(
)
)
{
*
aResult
=
line
-
>
BStart
(
)
+
line
-
>
GetLogicalAscent
(
)
;
return
true
;
}
}
}
return
false
;
}
static
nscoord
CalculateBlockContentBEnd
(
WritingMode
aWM
nsBlockFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
"
null
ptr
"
)
;
nscoord
contentBEnd
=
0
;
for
(
const
auto
&
line
:
aFrame
-
>
Lines
(
)
)
{
if
(
line
.
IsBlock
(
)
)
{
nsIFrame
*
child
=
line
.
mFirstChild
;
const
auto
&
containerSize
=
line
.
mContainerSize
;
nscoord
offset
=
child
-
>
GetLogicalNormalPosition
(
aWM
containerSize
)
.
B
(
aWM
)
;
contentBEnd
=
std
:
:
max
(
contentBEnd
nsLayoutUtils
:
:
CalculateContentBEnd
(
aWM
child
)
+
offset
)
;
}
else
{
contentBEnd
=
std
:
:
max
(
contentBEnd
line
.
BEnd
(
)
)
;
}
}
return
contentBEnd
;
}
nscoord
nsLayoutUtils
:
:
CalculateContentBEnd
(
WritingMode
aWM
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
"
null
ptr
"
)
;
nscoord
contentBEnd
=
aFrame
-
>
BSize
(
aWM
)
;
LogicalSize
overflowSize
(
aWM
aFrame
-
>
ScrollableOverflowRect
(
)
.
Size
(
)
)
;
if
(
overflowSize
.
BSize
(
aWM
)
>
contentBEnd
)
{
nsIFrame
:
:
ChildListIDs
skip
=
{
nsIFrame
:
:
kOverflowList
nsIFrame
:
:
kExcessOverflowContainersList
nsIFrame
:
:
kOverflowOutOfFlowList
}
;
nsBlockFrame
*
blockFrame
=
do_QueryFrame
(
aFrame
)
;
if
(
blockFrame
)
{
contentBEnd
=
std
:
:
max
(
contentBEnd
CalculateBlockContentBEnd
(
aWM
blockFrame
)
)
;
skip
+
=
nsIFrame
:
:
kPrincipalList
;
}
for
(
const
auto
&
[
list
listID
]
:
aFrame
-
>
ChildLists
(
)
)
{
if
(
!
skip
.
contains
(
listID
)
)
{
for
(
nsIFrame
*
child
:
list
)
{
nscoord
offset
=
child
-
>
GetLogicalNormalPosition
(
aWM
aFrame
-
>
GetSize
(
)
)
.
B
(
aWM
)
;
contentBEnd
=
std
:
:
max
(
contentBEnd
CalculateContentBEnd
(
aWM
child
)
+
offset
)
;
}
}
}
}
return
contentBEnd
;
}
nsIFrame
*
nsLayoutUtils
:
:
GetClosestLayer
(
nsIFrame
*
aFrame
)
{
nsIFrame
*
layer
;
for
(
layer
=
aFrame
;
layer
;
layer
=
layer
-
>
GetParent
(
)
)
{
if
(
layer
-
>
IsAbsPosContainingBlock
(
)
|
|
(
layer
-
>
GetParent
(
)
&
&
layer
-
>
GetParent
(
)
-
>
IsScrollFrame
(
)
)
)
break
;
}
if
(
layer
)
return
layer
;
return
aFrame
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
;
}
SamplingFilter
nsLayoutUtils
:
:
GetSamplingFilterForFrame
(
nsIFrame
*
aForFrame
)
{
SamplingFilter
defaultFilter
=
SamplingFilter
:
:
GOOD
;
ComputedStyle
*
sc
;
if
(
nsCSSRendering
:
:
IsCanvasFrame
(
aForFrame
)
)
{
nsCSSRendering
:
:
FindBackground
(
aForFrame
&
sc
)
;
}
else
{
sc
=
aForFrame
-
>
Style
(
)
;
}
switch
(
sc
-
>
StyleVisibility
(
)
-
>
mImageRendering
)
{
case
StyleImageRendering
:
:
Optimizespeed
:
return
SamplingFilter
:
:
POINT
;
case
StyleImageRendering
:
:
Optimizequality
:
return
SamplingFilter
:
:
LINEAR
;
case
StyleImageRendering
:
:
CrispEdges
:
return
SamplingFilter
:
:
POINT
;
default
:
return
defaultFilter
;
}
}
static
gfxPoint
MapToFloatImagePixels
(
const
gfxSize
&
aSize
const
gfxRect
&
aDest
const
gfxPoint
&
aPt
)
{
return
gfxPoint
(
(
(
aPt
.
x
-
aDest
.
X
(
)
)
*
aSize
.
width
)
/
aDest
.
Width
(
)
(
(
aPt
.
y
-
aDest
.
Y
(
)
)
*
aSize
.
height
)
/
aDest
.
Height
(
)
)
;
}
static
gfxPoint
MapToFloatUserPixels
(
const
gfxSize
&
aSize
const
gfxRect
&
aDest
const
gfxPoint
&
aPt
)
{
return
gfxPoint
(
aPt
.
x
*
aDest
.
Width
(
)
/
aSize
.
width
+
aDest
.
X
(
)
aPt
.
y
*
aDest
.
Height
(
)
/
aSize
.
height
+
aDest
.
Y
(
)
)
;
}
gfxRect
nsLayoutUtils
:
:
RectToGfxRect
(
const
nsRect
&
aRect
int32_t
aAppUnitsPerDevPixel
)
{
return
gfxRect
(
gfxFloat
(
aRect
.
x
)
/
aAppUnitsPerDevPixel
gfxFloat
(
aRect
.
y
)
/
aAppUnitsPerDevPixel
gfxFloat
(
aRect
.
width
)
/
aAppUnitsPerDevPixel
gfxFloat
(
aRect
.
height
)
/
aAppUnitsPerDevPixel
)
;
}
struct
SnappedImageDrawingParameters
{
gfxMatrix
imageSpaceToDeviceSpace
;
nsIntSize
size
;
ImageRegion
region
;
CSSIntSize
svgViewportSize
;
bool
shouldDraw
;
SnappedImageDrawingParameters
(
)
:
region
(
ImageRegion
:
:
Empty
(
)
)
shouldDraw
(
false
)
{
}
SnappedImageDrawingParameters
(
const
gfxMatrix
&
aImageSpaceToDeviceSpace
const
nsIntSize
&
aSize
const
ImageRegion
&
aRegion
const
CSSIntSize
&
aSVGViewportSize
)
:
imageSpaceToDeviceSpace
(
aImageSpaceToDeviceSpace
)
size
(
aSize
)
region
(
aRegion
)
svgViewportSize
(
aSVGViewportSize
)
shouldDraw
(
true
)
{
}
}
;
static
gfxMatrix
TransformBetweenRects
(
const
gfxRect
&
aFrom
const
gfxRect
&
aTo
)
{
gfxSize
scale
(
aTo
.
width
/
aFrom
.
width
aTo
.
height
/
aFrom
.
height
)
;
gfxPoint
translation
(
aTo
.
x
-
aFrom
.
x
*
scale
.
width
aTo
.
y
-
aFrom
.
y
*
scale
.
height
)
;
return
gfxMatrix
(
scale
.
width
0
0
scale
.
height
translation
.
x
translation
.
y
)
;
}
static
nsRect
TileNearRect
(
const
nsRect
&
aAnyTile
const
nsRect
&
aTargetRect
)
{
nsPoint
distance
=
aTargetRect
.
TopLeft
(
)
-
aAnyTile
.
TopLeft
(
)
;
return
aAnyTile
+
nsPoint
(
distance
.
x
/
aAnyTile
.
width
*
aAnyTile
.
width
distance
.
y
/
aAnyTile
.
height
*
aAnyTile
.
height
)
;
}
static
gfxFloat
StableRound
(
gfxFloat
aValue
)
{
return
floor
(
aValue
+
0
.
5001
)
;
}
static
gfxPoint
StableRound
(
const
gfxPoint
&
aPoint
)
{
return
gfxPoint
(
StableRound
(
aPoint
.
x
)
StableRound
(
aPoint
.
y
)
)
;
}
static
SnappedImageDrawingParameters
ComputeSnappedImageDrawingParameters
(
gfxContext
*
aCtx
int32_t
aAppUnitsPerDevPixel
const
nsRect
aDest
const
nsRect
aFill
const
nsPoint
aAnchor
const
nsRect
aDirty
imgIContainer
*
aImage
const
SamplingFilter
aSamplingFilter
uint32_t
aImageFlags
ExtendMode
aExtendMode
)
{
if
(
aDest
.
IsEmpty
(
)
|
|
aFill
.
IsEmpty
(
)
)
return
SnappedImageDrawingParameters
(
)
;
bool
doTile
=
!
aDest
.
Contains
(
aFill
)
;
nsRect
appUnitDest
=
doTile
?
TileNearRect
(
aDest
aFill
.
Intersect
(
aDirty
)
)
:
aDest
;
nsPoint
anchor
=
aAnchor
+
(
appUnitDest
.
TopLeft
(
)
-
aDest
.
TopLeft
(
)
)
;
gfxRect
devPixelDest
=
nsLayoutUtils
:
:
RectToGfxRect
(
appUnitDest
aAppUnitsPerDevPixel
)
;
gfxRect
devPixelFill
=
nsLayoutUtils
:
:
RectToGfxRect
(
aFill
aAppUnitsPerDevPixel
)
;
gfxRect
devPixelDirty
=
nsLayoutUtils
:
:
RectToGfxRect
(
aDirty
aAppUnitsPerDevPixel
)
;
gfxMatrix
currentMatrix
=
aCtx
-
>
CurrentMatrixDouble
(
)
;
gfxRect
fill
=
devPixelFill
;
gfxRect
dest
=
devPixelDest
;
bool
didSnap
;
if
(
!
currentMatrix
.
HasNonAxisAlignedTransform
(
)
&
&
currentMatrix
.
_11
>
0
.
0
&
&
currentMatrix
.
_22
>
0
.
0
&
&
aCtx
-
>
UserToDevicePixelSnapped
(
fill
true
)
&
&
aCtx
-
>
UserToDevicePixelSnapped
(
dest
true
)
)
{
didSnap
=
true
;
}
else
{
didSnap
=
false
;
fill
=
devPixelFill
;
dest
=
devPixelDest
;
}
gfxSize
snappedDestSize
=
dest
.
Size
(
)
;
gfxSize
scaleFactors
=
currentMatrix
.
ScaleFactors
(
)
;
if
(
!
didSnap
)
{
snappedDestSize
.
Scale
(
scaleFactors
.
width
scaleFactors
.
height
)
;
snappedDestSize
.
width
=
NS_round
(
snappedDestSize
.
width
)
;
snappedDestSize
.
height
=
NS_round
(
snappedDestSize
.
height
)
;
}
snappedDestSize
.
width
=
std
:
:
max
(
snappedDestSize
.
width
1
.
0
)
;
snappedDestSize
.
height
=
std
:
:
max
(
snappedDestSize
.
height
1
.
0
)
;
if
(
fill
.
IsEmpty
(
)
)
{
return
SnappedImageDrawingParameters
(
)
;
}
nsIntSize
intImageSize
=
aImage
-
>
OptimalImageSizeForDest
(
snappedDestSize
imgIContainer
:
:
FRAME_CURRENT
aSamplingFilter
aImageFlags
)
;
nsIntSize
svgViewportSize
;
if
(
scaleFactors
.
width
=
=
1
.
0
&
&
scaleFactors
.
height
=
=
1
.
0
)
{
svgViewportSize
=
intImageSize
;
}
else
{
svgViewportSize
=
aImage
-
>
OptimalImageSizeForDest
(
devPixelDest
.
Size
(
)
imgIContainer
:
:
FRAME_CURRENT
aSamplingFilter
aImageFlags
)
;
}
gfxSize
imageSize
(
intImageSize
.
width
intImageSize
.
height
)
;
gfxPoint
subimageTopLeft
=
MapToFloatImagePixels
(
imageSize
devPixelDest
devPixelFill
.
TopLeft
(
)
)
;
gfxPoint
subimageBottomRight
=
MapToFloatImagePixels
(
imageSize
devPixelDest
devPixelFill
.
BottomRight
(
)
)
;
gfxRect
subimage
;
subimage
.
MoveTo
(
NSToIntFloor
(
subimageTopLeft
.
x
)
NSToIntFloor
(
subimageTopLeft
.
y
)
)
;
subimage
.
SizeTo
(
NSToIntCeil
(
subimageBottomRight
.
x
)
-
subimage
.
x
NSToIntCeil
(
subimageBottomRight
.
y
)
-
subimage
.
y
)
;
if
(
subimage
.
IsEmpty
(
)
)
{
return
SnappedImageDrawingParameters
(
)
;
}
gfxMatrix
transform
;
gfxMatrix
invTransform
;
bool
anchorAtUpperLeft
=
anchor
.
x
=
=
appUnitDest
.
x
&
&
anchor
.
y
=
=
appUnitDest
.
y
;
bool
exactlyOneImageCopy
=
aFill
.
IsEqualEdges
(
appUnitDest
)
;
if
(
anchorAtUpperLeft
&
&
exactlyOneImageCopy
)
{
transform
=
TransformBetweenRects
(
subimage
fill
)
;
invTransform
=
TransformBetweenRects
(
fill
subimage
)
;
}
else
{
gfxPoint
anchorPoint
(
gfxFloat
(
anchor
.
x
)
/
aAppUnitsPerDevPixel
gfxFloat
(
anchor
.
y
)
/
aAppUnitsPerDevPixel
)
;
gfxPoint
imageSpaceAnchorPoint
=
MapToFloatImagePixels
(
imageSize
devPixelDest
anchorPoint
)
;
if
(
didSnap
)
{
imageSpaceAnchorPoint
=
StableRound
(
imageSpaceAnchorPoint
)
;
anchorPoint
=
imageSpaceAnchorPoint
;
anchorPoint
=
MapToFloatUserPixels
(
imageSize
devPixelDest
anchorPoint
)
;
anchorPoint
=
currentMatrix
.
TransformPoint
(
anchorPoint
)
;
anchorPoint
=
StableRound
(
anchorPoint
)
;
}
gfxSize
unsnappedDestSize
=
didSnap
?
devPixelDest
.
Size
(
)
*
currentMatrix
.
ScaleFactors
(
)
:
devPixelDest
.
Size
(
)
;
gfxRect
anchoredDestRect
(
anchorPoint
unsnappedDestSize
)
;
gfxRect
anchoredImageRect
(
imageSpaceAnchorPoint
imageSize
)
;
if
(
fill
.
Width
(
)
!
=
devPixelFill
.
Width
(
)
&
&
devPixelDest
.
x
=
=
devPixelFill
.
x
&
&
devPixelDest
.
XMost
(
)
=
=
devPixelFill
.
XMost
(
)
)
{
anchoredDestRect
.
width
=
fill
.
width
;
}
if
(
fill
.
Height
(
)
!
=
devPixelFill
.
Height
(
)
&
&
devPixelDest
.
y
=
=
devPixelFill
.
y
&
&
devPixelDest
.
YMost
(
)
=
=
devPixelFill
.
YMost
(
)
)
{
anchoredDestRect
.
height
=
fill
.
height
;
}
transform
=
TransformBetweenRects
(
anchoredImageRect
anchoredDestRect
)
;
invTransform
=
TransformBetweenRects
(
anchoredDestRect
anchoredImageRect
)
;
}
if
(
didSnap
&
&
!
invTransform
.
HasNonIntegerTranslation
(
)
)
{
devPixelDirty
=
currentMatrix
.
TransformRect
(
devPixelDirty
)
;
devPixelDirty
.
RoundOut
(
)
;
fill
=
fill
.
Intersect
(
devPixelDirty
)
;
}
if
(
fill
.
IsEmpty
(
)
)
return
SnappedImageDrawingParameters
(
)
;
gfxRect
imageSpaceFill
(
didSnap
?
invTransform
.
TransformRect
(
fill
)
:
invTransform
.
TransformBounds
(
fill
)
)
;
if
(
!
didSnap
)
{
transform
=
transform
*
currentMatrix
;
}
ExtendMode
extendMode
=
(
aImageFlags
&
imgIContainer
:
:
FLAG_CLAMP
)
?
ExtendMode
:
:
CLAMP
:
aExtendMode
;
if
(
extendMode
=
=
ExtendMode
:
:
CLAMP
&
&
doTile
)
{
MOZ_ASSERT
(
!
(
aImageFlags
&
imgIContainer
:
:
FLAG_CLAMP
)
)
;
extendMode
=
ExtendMode
:
:
REPEAT
;
}
ImageRegion
region
=
ImageRegion
:
:
CreateWithSamplingRestriction
(
imageSpaceFill
subimage
extendMode
)
;
return
SnappedImageDrawingParameters
(
transform
intImageSize
region
CSSIntSize
(
svgViewportSize
.
width
svgViewportSize
.
height
)
)
;
}
static
ImgDrawResult
DrawImageInternal
(
gfxContext
&
aContext
nsPresContext
*
aPresContext
imgIContainer
*
aImage
const
SamplingFilter
aSamplingFilter
const
nsRect
&
aDest
const
nsRect
&
aFill
const
nsPoint
&
aAnchor
const
nsRect
&
aDirty
const
Maybe
<
SVGImageContext
>
&
aSVGContext
uint32_t
aImageFlags
ExtendMode
aExtendMode
=
ExtendMode
:
:
CLAMP
float
aOpacity
=
1
.
0
)
{
ImgDrawResult
result
=
ImgDrawResult
:
:
SUCCESS
;
aImageFlags
|
=
imgIContainer
:
:
FLAG_ASYNC_NOTIFY
;
if
(
aPresContext
-
>
Type
(
)
=
=
nsPresContext
:
:
eContext_Print
)
{
aImageFlags
|
=
imgIContainer
:
:
FLAG_BYPASS_SURFACE_CACHE
;
}
if
(
aDest
.
Contains
(
aFill
)
)
{
aImageFlags
|
=
imgIContainer
:
:
FLAG_CLAMP
;
}
int32_t
appUnitsPerDevPixel
=
aPresContext
-
>
AppUnitsPerDevPixel
(
)
;
SnappedImageDrawingParameters
params
=
ComputeSnappedImageDrawingParameters
(
&
aContext
appUnitsPerDevPixel
aDest
aFill
aAnchor
aDirty
aImage
aSamplingFilter
aImageFlags
aExtendMode
)
;
if
(
!
params
.
shouldDraw
)
{
return
result
;
}
{
gfxContextMatrixAutoSaveRestore
contextMatrixRestorer
(
&
aContext
)
;
aContext
.
SetMatrixDouble
(
params
.
imageSpaceToDeviceSpace
)
;
Maybe
<
SVGImageContext
>
fallbackContext
;
if
(
!
aSVGContext
)
{
fallbackContext
.
emplace
(
Some
(
params
.
svgViewportSize
)
)
;
}
result
=
aImage
-
>
Draw
(
&
aContext
params
.
size
params
.
region
imgIContainer
:
:
FRAME_CURRENT
aSamplingFilter
aSVGContext
?
aSVGContext
:
fallbackContext
aImageFlags
aOpacity
)
;
}
return
result
;
}
ImgDrawResult
nsLayoutUtils
:
:
DrawSingleUnscaledImage
(
gfxContext
&
aContext
nsPresContext
*
aPresContext
imgIContainer
*
aImage
const
SamplingFilter
aSamplingFilter
const
nsPoint
&
aDest
const
nsRect
*
aDirty
const
Maybe
<
SVGImageContext
>
&
aSVGContext
uint32_t
aImageFlags
const
nsRect
*
aSourceArea
)
{
CSSIntSize
imageSize
;
aImage
-
>
GetWidth
(
&
imageSize
.
width
)
;
aImage
-
>
GetHeight
(
&
imageSize
.
height
)
;
if
(
imageSize
.
width
<
1
|
|
imageSize
.
height
<
1
)
{
NS_WARNING
(
"
Image
width
or
height
is
non
-
positive
"
)
;
return
ImgDrawResult
:
:
TEMPORARY_ERROR
;
}
nsSize
size
(
CSSPixel
:
:
ToAppUnits
(
imageSize
)
)
;
nsRect
source
;
if
(
aSourceArea
)
{
source
=
*
aSourceArea
;
}
else
{
source
.
SizeTo
(
size
)
;
}
nsRect
dest
(
aDest
-
source
.
TopLeft
(
)
size
)
;
nsRect
fill
(
aDest
source
.
Size
(
)
)
;
fill
.
IntersectRect
(
fill
dest
)
;
return
DrawImageInternal
(
aContext
aPresContext
aImage
aSamplingFilter
dest
fill
aDest
aDirty
?
*
aDirty
:
dest
aSVGContext
aImageFlags
)
;
}
ImgDrawResult
nsLayoutUtils
:
:
DrawSingleImage
(
gfxContext
&
aContext
nsPresContext
*
aPresContext
imgIContainer
*
aImage
const
SamplingFilter
aSamplingFilter
const
nsRect
&
aDest
const
nsRect
&
aDirty
const
Maybe
<
SVGImageContext
>
&
aSVGContext
uint32_t
aImageFlags
const
nsPoint
*
aAnchorPoint
const
nsRect
*
aSourceArea
)
{
nscoord
appUnitsPerCSSPixel
=
AppUnitsPerCSSPixel
(
)
;
CSSIntSize
pixelImageSize
(
ComputeSizeForDrawingWithFallback
(
aImage
aDest
.
Size
(
)
)
)
;
if
(
pixelImageSize
.
width
<
1
|
|
pixelImageSize
.
height
<
1
)
{
NS_ASSERTION
(
pixelImageSize
.
width
>
=
0
&
&
pixelImageSize
.
height
>
=
0
"
Image
width
or
height
is
negative
"
)
;
return
ImgDrawResult
:
:
SUCCESS
;
}
nsSize
imageSize
(
CSSPixel
:
:
ToAppUnits
(
pixelImageSize
)
)
;
nsRect
source
;
nsCOMPtr
<
imgIContainer
>
image
;
if
(
aSourceArea
)
{
source
=
*
aSourceArea
;
nsIntRect
subRect
(
source
.
x
source
.
y
source
.
width
source
.
height
)
;
subRect
.
ScaleInverseRoundOut
(
appUnitsPerCSSPixel
)
;
image
=
ImageOps
:
:
Clip
(
aImage
subRect
)
;
nsRect
imageRect
;
imageRect
.
SizeTo
(
imageSize
)
;
nsRect
clippedSource
=
imageRect
.
Intersect
(
source
)
;
source
-
=
clippedSource
.
TopLeft
(
)
;
imageSize
=
clippedSource
.
Size
(
)
;
}
else
{
source
.
SizeTo
(
imageSize
)
;
image
=
aImage
;
}
nsRect
dest
=
GetWholeImageDestination
(
imageSize
source
aDest
)
;
nsRect
fill
;
fill
.
IntersectRect
(
aDest
dest
)
;
return
DrawImageInternal
(
aContext
aPresContext
image
aSamplingFilter
dest
fill
aAnchorPoint
?
*
aAnchorPoint
:
fill
.
TopLeft
(
)
aDirty
aSVGContext
aImageFlags
)
;
}
void
nsLayoutUtils
:
:
ComputeSizeForDrawing
(
imgIContainer
*
aImage
CSSIntSize
&
aImageSize
AspectRatio
&
aIntrinsicRatio
bool
&
aGotWidth
bool
&
aGotHeight
)
{
aGotWidth
=
NS_SUCCEEDED
(
aImage
-
>
GetWidth
(
&
aImageSize
.
width
)
)
;
aGotHeight
=
NS_SUCCEEDED
(
aImage
-
>
GetHeight
(
&
aImageSize
.
height
)
)
;
Maybe
<
AspectRatio
>
intrinsicRatio
=
aImage
-
>
GetIntrinsicRatio
(
)
;
aIntrinsicRatio
=
intrinsicRatio
.
valueOr
(
AspectRatio
(
)
)
;
if
(
!
(
aGotWidth
&
&
aGotHeight
)
&
&
intrinsicRatio
.
isNothing
(
)
)
{
aGotWidth
=
aGotHeight
=
true
;
aImageSize
=
CSSIntSize
(
0
0
)
;
}
}
CSSIntSize
nsLayoutUtils
:
:
ComputeSizeForDrawingWithFallback
(
imgIContainer
*
aImage
const
nsSize
&
aFallbackSize
)
{
CSSIntSize
imageSize
;
AspectRatio
imageRatio
;
bool
gotHeight
gotWidth
;
ComputeSizeForDrawing
(
aImage
imageSize
imageRatio
gotWidth
gotHeight
)
;
if
(
gotWidth
!
=
gotHeight
)
{
if
(
!
gotWidth
)
{
if
(
imageRatio
)
{
imageSize
.
width
=
imageRatio
.
ApplyTo
(
imageSize
.
height
)
;
gotWidth
=
true
;
}
}
else
{
if
(
imageRatio
)
{
imageSize
.
height
=
imageRatio
.
Inverted
(
)
.
ApplyTo
(
imageSize
.
width
)
;
gotHeight
=
true
;
}
}
}
if
(
!
gotWidth
)
{
imageSize
.
width
=
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
aFallbackSize
.
width
)
;
}
if
(
!
gotHeight
)
{
imageSize
.
height
=
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
aFallbackSize
.
height
)
;
}
return
imageSize
;
}
IntSize
nsLayoutUtils
:
:
ComputeImageContainerDrawingParameters
(
imgIContainer
*
aImage
nsIFrame
*
aForFrame
const
LayoutDeviceRect
&
aDestRect
const
StackingContextHelper
&
aSc
uint32_t
aFlags
Maybe
<
SVGImageContext
>
&
aSVGContext
)
{
MOZ_ASSERT
(
aImage
)
;
MOZ_ASSERT
(
aForFrame
)
;
gfx
:
:
Size
scaleFactors
=
aSc
.
GetInheritedScale
(
)
;
SamplingFilter
samplingFilter
=
nsLayoutUtils
:
:
GetSamplingFilterForFrame
(
aForFrame
)
;
SVGImageContext
:
:
MaybeStoreContextPaint
(
aSVGContext
aForFrame
aImage
)
;
if
(
(
scaleFactors
.
width
!
=
1
.
0
|
|
scaleFactors
.
height
!
=
1
.
0
)
&
&
aImage
-
>
GetType
(
)
=
=
imgIContainer
:
:
TYPE_VECTOR
&
&
(
!
aSVGContext
|
|
!
aSVGContext
-
>
GetViewportSize
(
)
)
)
{
gfxSize
gfxDestSize
(
aDestRect
.
Width
(
)
aDestRect
.
Height
(
)
)
;
IntSize
viewportSize
=
aImage
-
>
OptimalImageSizeForDest
(
gfxDestSize
imgIContainer
:
:
FRAME_CURRENT
samplingFilter
aFlags
)
;
CSSIntSize
cssViewportSize
(
viewportSize
.
width
viewportSize
.
height
)
;
if
(
!
aSVGContext
)
{
aSVGContext
.
emplace
(
Some
(
cssViewportSize
)
)
;
}
else
{
aSVGContext
-
>
SetViewportSize
(
Some
(
cssViewportSize
)
)
;
}
}
bool
snapped
=
false
;
gfxSize
gfxLayerSize
;
const
gfx
:
:
Matrix
&
itm
=
aSc
.
GetInheritedTransform
(
)
;
if
(
!
itm
.
HasNonAxisAlignedTransform
(
)
&
&
itm
.
_11
>
0
.
0
&
&
itm
.
_22
>
0
.
0
)
{
gfxRect
rect
(
gfxPoint
(
aDestRect
.
X
(
)
aDestRect
.
Y
(
)
)
gfxSize
(
aDestRect
.
Width
(
)
aDestRect
.
Height
(
)
)
)
;
gfxPoint
p1
=
ThebesPoint
(
itm
.
TransformPoint
(
ToPoint
(
rect
.
TopLeft
(
)
)
)
)
;
gfxPoint
p2
=
ThebesPoint
(
itm
.
TransformPoint
(
ToPoint
(
rect
.
TopRight
(
)
)
)
)
;
gfxPoint
p3
=
ThebesPoint
(
itm
.
TransformPoint
(
ToPoint
(
rect
.
BottomRight
(
)
)
)
)
;
if
(
p2
=
=
gfxPoint
(
p1
.
x
p3
.
y
)
|
|
p2
=
=
gfxPoint
(
p3
.
x
p1
.
y
)
)
{
p1
.
Round
(
)
;
p3
.
Round
(
)
;
rect
.
MoveTo
(
gfxPoint
(
std
:
:
min
(
p1
.
x
p3
.
x
)
std
:
:
min
(
p1
.
y
p3
.
y
)
)
)
;
rect
.
SizeTo
(
gfxSize
(
std
:
:
max
(
p1
.
x
p3
.
x
)
-
rect
.
X
(
)
std
:
:
max
(
p1
.
y
p3
.
y
)
-
rect
.
Y
(
)
)
)
;
gfxLayerSize
=
gfxSize
(
std
:
:
max
(
rect
.
Width
(
)
1
.
0
)
std
:
:
max
(
rect
.
Height
(
)
1
.
0
)
)
;
snapped
=
true
;
}
}
if
(
!
snapped
)
{
const
LayerIntSize
layerSize
=
RoundedToInt
(
LayerSize
(
aDestRect
.
Width
(
)
*
scaleFactors
.
width
aDestRect
.
Height
(
)
*
scaleFactors
.
height
)
)
;
gfxLayerSize
=
gfxSize
(
std
:
:
max
(
layerSize
.
width
1
)
std
:
:
max
(
layerSize
.
height
1
)
)
;
}
return
aImage
-
>
OptimalImageSizeForDest
(
gfxLayerSize
imgIContainer
:
:
FRAME_CURRENT
samplingFilter
aFlags
)
;
}
nsPoint
nsLayoutUtils
:
:
GetBackgroundFirstTilePos
(
const
nsPoint
&
aDest
const
nsPoint
&
aFill
const
nsSize
&
aRepeatSize
)
{
return
nsPoint
(
NSToIntFloor
(
float
(
aFill
.
x
-
aDest
.
x
)
/
aRepeatSize
.
width
)
*
aRepeatSize
.
width
NSToIntFloor
(
float
(
aFill
.
y
-
aDest
.
y
)
/
aRepeatSize
.
height
)
*
aRepeatSize
.
height
)
+
aDest
;
}
ImgDrawResult
nsLayoutUtils
:
:
DrawBackgroundImage
(
gfxContext
&
aContext
nsIFrame
*
aForFrame
nsPresContext
*
aPresContext
imgIContainer
*
aImage
SamplingFilter
aSamplingFilter
const
nsRect
&
aDest
const
nsRect
&
aFill
const
nsSize
&
aRepeatSize
const
nsPoint
&
aAnchor
const
nsRect
&
aDirty
uint32_t
aImageFlags
ExtendMode
aExtendMode
float
aOpacity
)
{
AUTO_PROFILER_LABEL
(
"
nsLayoutUtils
:
:
DrawBackgroundImage
"
GRAPHICS_Rasterization
)
;
CSSIntSize
destCSSSize
{
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
aDest
.
width
)
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
aDest
.
height
)
}
;
Maybe
<
SVGImageContext
>
svgContext
(
Some
(
SVGImageContext
(
Some
(
destCSSSize
)
)
)
)
;
SVGImageContext
:
:
MaybeStoreContextPaint
(
svgContext
aForFrame
aImage
)
;
if
(
aRepeatSize
.
width
=
=
aDest
.
width
&
&
aRepeatSize
.
height
=
=
aDest
.
height
)
{
return
DrawImageInternal
(
aContext
aPresContext
aImage
aSamplingFilter
aDest
aFill
aAnchor
aDirty
svgContext
aImageFlags
aExtendMode
aOpacity
)
;
}
nsPoint
firstTilePos
=
GetBackgroundFirstTilePos
(
aDest
.
TopLeft
(
)
aFill
.
TopLeft
(
)
aRepeatSize
)
;
for
(
int32_t
i
=
firstTilePos
.
x
;
i
<
aFill
.
XMost
(
)
;
i
+
=
aRepeatSize
.
width
)
{
for
(
int32_t
j
=
firstTilePos
.
y
;
j
<
aFill
.
YMost
(
)
;
j
+
=
aRepeatSize
.
height
)
{
nsRect
dest
(
i
j
aDest
.
width
aDest
.
height
)
;
ImgDrawResult
result
=
DrawImageInternal
(
aContext
aPresContext
aImage
aSamplingFilter
dest
dest
aAnchor
aDirty
svgContext
aImageFlags
ExtendMode
:
:
CLAMP
aOpacity
)
;
if
(
result
!
=
ImgDrawResult
:
:
SUCCESS
)
{
return
result
;
}
}
}
return
ImgDrawResult
:
:
SUCCESS
;
}
ImgDrawResult
nsLayoutUtils
:
:
DrawImage
(
gfxContext
&
aContext
ComputedStyle
*
aComputedStyle
nsPresContext
*
aPresContext
imgIContainer
*
aImage
const
SamplingFilter
aSamplingFilter
const
nsRect
&
aDest
const
nsRect
&
aFill
const
nsPoint
&
aAnchor
const
nsRect
&
aDirty
uint32_t
aImageFlags
float
aOpacity
)
{
Maybe
<
SVGImageContext
>
svgContext
;
SVGImageContext
:
:
MaybeStoreContextPaint
(
svgContext
aComputedStyle
aImage
)
;
return
DrawImageInternal
(
aContext
aPresContext
aImage
aSamplingFilter
aDest
aFill
aAnchor
aDirty
svgContext
aImageFlags
ExtendMode
:
:
CLAMP
aOpacity
)
;
}
nsRect
nsLayoutUtils
:
:
GetWholeImageDestination
(
const
nsSize
&
aWholeImageSize
const
nsRect
&
aImageSourceArea
const
nsRect
&
aDestArea
)
{
double
scaleX
=
double
(
aDestArea
.
width
)
/
aImageSourceArea
.
width
;
double
scaleY
=
double
(
aDestArea
.
height
)
/
aImageSourceArea
.
height
;
nscoord
destOffsetX
=
NSToCoordRound
(
aImageSourceArea
.
x
*
scaleX
)
;
nscoord
destOffsetY
=
NSToCoordRound
(
aImageSourceArea
.
y
*
scaleY
)
;
nscoord
wholeSizeX
=
NSToCoordRound
(
aWholeImageSize
.
width
*
scaleX
)
;
nscoord
wholeSizeY
=
NSToCoordRound
(
aWholeImageSize
.
height
*
scaleY
)
;
return
nsRect
(
aDestArea
.
TopLeft
(
)
-
nsPoint
(
destOffsetX
destOffsetY
)
nsSize
(
wholeSizeX
wholeSizeY
)
)
;
}
already_AddRefed
<
imgIContainer
>
nsLayoutUtils
:
:
OrientImage
(
imgIContainer
*
aContainer
const
StyleImageOrientation
&
aOrientation
)
{
MOZ_ASSERT
(
aContainer
"
Should
have
an
image
container
"
)
;
nsCOMPtr
<
imgIContainer
>
img
(
aContainer
)
;
bool
handledOrientation
=
img
-
>
HandledOrientation
(
)
;
switch
(
aOrientation
)
{
case
StyleImageOrientation
:
:
FromImage
:
if
(
!
handledOrientation
)
{
img
=
ImageOps
:
:
Orient
(
img
img
-
>
GetOrientation
(
)
)
;
}
break
;
case
StyleImageOrientation
:
:
None
:
if
(
handledOrientation
)
{
img
=
ImageOps
:
:
Unorient
(
img
)
;
}
break
;
}
return
img
.
forget
(
)
;
}
static
bool
NonZeroCorner
(
const
LengthPercentage
&
aLength
)
{
return
aLength
.
Resolve
(
nscoord_MAX
)
>
0
|
|
aLength
.
Resolve
(
0
)
>
0
;
}
bool
nsLayoutUtils
:
:
HasNonZeroCorner
(
const
BorderRadius
&
aCorners
)
{
for
(
const
auto
corner
:
mozilla
:
:
AllPhysicalHalfCorners
(
)
)
{
if
(
NonZeroCorner
(
aCorners
.
Get
(
corner
)
)
)
return
true
;
}
return
false
;
}
static
bool
IsCornerAdjacentToSide
(
uint8_t
aCorner
Side
aSide
)
{
static_assert
(
(
int
)
eSideTop
=
=
eCornerTopLeft
"
Check
for
Full
Corner
"
)
;
static_assert
(
(
int
)
eSideRight
=
=
eCornerTopRight
"
Check
for
Full
Corner
"
)
;
static_assert
(
(
int
)
eSideBottom
=
=
eCornerBottomRight
"
Check
for
Full
Corner
"
)
;
static_assert
(
(
int
)
eSideLeft
=
=
eCornerBottomLeft
"
Check
for
Full
Corner
"
)
;
static_assert
(
(
int
)
eSideTop
=
=
(
(
eCornerTopRight
-
1
)
&
3
)
"
Check
for
Full
Corner
"
)
;
static_assert
(
(
int
)
eSideRight
=
=
(
(
eCornerBottomRight
-
1
)
&
3
)
"
Check
for
Full
Corner
"
)
;
static_assert
(
(
int
)
eSideBottom
=
=
(
(
eCornerBottomLeft
-
1
)
&
3
)
"
Check
for
Full
Corner
"
)
;
static_assert
(
(
int
)
eSideLeft
=
=
(
(
eCornerTopLeft
-
1
)
&
3
)
"
Check
for
Full
Corner
"
)
;
return
aSide
=
=
aCorner
|
|
aSide
=
=
(
(
aCorner
-
1
)
&
3
)
;
}
bool
nsLayoutUtils
:
:
HasNonZeroCornerOnSide
(
const
BorderRadius
&
aCorners
Side
aSide
)
{
static_assert
(
eCornerTopLeftX
/
2
=
=
eCornerTopLeft
"
Check
for
Non
Zero
on
side
"
)
;
static_assert
(
eCornerTopLeftY
/
2
=
=
eCornerTopLeft
"
Check
for
Non
Zero
on
side
"
)
;
static_assert
(
eCornerTopRightX
/
2
=
=
eCornerTopRight
"
Check
for
Non
Zero
on
side
"
)
;
static_assert
(
eCornerTopRightY
/
2
=
=
eCornerTopRight
"
Check
for
Non
Zero
on
side
"
)
;
static_assert
(
eCornerBottomRightX
/
2
=
=
eCornerBottomRight
"
Check
for
Non
Zero
on
side
"
)
;
static_assert
(
eCornerBottomRightY
/
2
=
=
eCornerBottomRight
"
Check
for
Non
Zero
on
side
"
)
;
static_assert
(
eCornerBottomLeftX
/
2
=
=
eCornerBottomLeft
"
Check
for
Non
Zero
on
side
"
)
;
static_assert
(
eCornerBottomLeftY
/
2
=
=
eCornerBottomLeft
"
Check
for
Non
Zero
on
side
"
)
;
for
(
const
auto
corner
:
mozilla
:
:
AllPhysicalHalfCorners
(
)
)
{
if
(
NonZeroCorner
(
aCorners
.
Get
(
corner
)
)
&
&
IsCornerAdjacentToSide
(
corner
/
2
aSide
)
)
return
true
;
}
return
false
;
}
nsTransparencyMode
nsLayoutUtils
:
:
GetFrameTransparency
(
nsIFrame
*
aBackgroundFrame
nsIFrame
*
aCSSRootFrame
)
{
if
(
aCSSRootFrame
-
>
StyleEffects
(
)
-
>
mOpacity
<
1
.
0f
)
return
eTransparencyTransparent
;
if
(
HasNonZeroCorner
(
aCSSRootFrame
-
>
StyleBorder
(
)
-
>
mBorderRadius
)
)
return
eTransparencyTransparent
;
StyleAppearance
appearance
=
aCSSRootFrame
-
>
StyleDisplay
(
)
-
>
EffectiveAppearance
(
)
;
if
(
appearance
=
=
StyleAppearance
:
:
MozWinGlass
)
return
eTransparencyGlass
;
if
(
appearance
=
=
StyleAppearance
:
:
MozWinBorderlessGlass
)
return
eTransparencyBorderlessGlass
;
nsITheme
:
:
Transparency
transparency
;
if
(
aCSSRootFrame
-
>
IsThemed
(
&
transparency
)
)
return
transparency
=
=
nsITheme
:
:
eTransparent
?
eTransparencyTransparent
:
eTransparencyOpaque
;
if
(
aBackgroundFrame
-
>
IsViewportFrame
(
)
&
&
!
aBackgroundFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
)
{
return
eTransparencyOpaque
;
}
ComputedStyle
*
bgSC
;
if
(
!
nsCSSRendering
:
:
FindBackground
(
aBackgroundFrame
&
bgSC
)
)
{
return
eTransparencyTransparent
;
}
const
nsStyleBackground
*
bg
=
bgSC
-
>
StyleBackground
(
)
;
if
(
NS_GET_A
(
bg
-
>
BackgroundColor
(
bgSC
)
)
<
255
|
|
bg
-
>
BottomLayer
(
)
.
mClip
!
=
StyleGeometryBox
:
:
BorderBox
)
return
eTransparencyTransparent
;
return
eTransparencyOpaque
;
}
static
bool
IsPopupFrame
(
const
nsIFrame
*
aFrame
)
{
LayoutFrameType
frameType
=
aFrame
-
>
Type
(
)
;
if
(
frameType
=
=
LayoutFrameType
:
:
ListControl
)
{
const
nsListControlFrame
*
lcf
=
static_cast
<
const
nsListControlFrame
*
>
(
aFrame
)
;
return
lcf
-
>
IsInDropDownMode
(
)
;
}
return
frameType
=
=
LayoutFrameType
:
:
MenuPopup
;
}
bool
nsLayoutUtils
:
:
IsPopup
(
const
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
-
>
HasView
(
)
)
{
NS_ASSERTION
(
!
IsPopupFrame
(
aFrame
)
"
popup
frame
must
have
a
view
"
)
;
return
false
;
}
return
IsPopupFrame
(
aFrame
)
;
}
nsIFrame
*
nsLayoutUtils
:
:
GetDisplayRootFrame
(
nsIFrame
*
aFrame
)
{
return
const_cast
<
nsIFrame
*
>
(
nsLayoutUtils
:
:
GetDisplayRootFrame
(
const_cast
<
const
nsIFrame
*
>
(
aFrame
)
)
)
;
}
const
nsIFrame
*
nsLayoutUtils
:
:
GetDisplayRootFrame
(
const
nsIFrame
*
aFrame
)
{
const
nsIFrame
*
f
=
aFrame
;
for
(
;
;
)
{
if
(
!
f
-
>
HasAnyStateBits
(
NS_FRAME_IN_POPUP
)
)
{
f
=
f
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
;
if
(
!
f
)
{
return
aFrame
;
}
}
else
if
(
IsPopup
(
f
)
)
{
return
f
;
}
nsIFrame
*
parent
=
GetCrossDocParentFrame
(
f
)
;
if
(
!
parent
)
return
f
;
f
=
parent
;
}
}
nsIFrame
*
nsLayoutUtils
:
:
GetReferenceFrame
(
nsIFrame
*
aFrame
)
{
nsIFrame
*
f
=
aFrame
;
for
(
;
;
)
{
const
nsStyleDisplay
*
disp
=
f
-
>
StyleDisplay
(
)
;
if
(
f
-
>
IsTransformed
(
disp
)
|
|
f
-
>
IsPreserve3DLeaf
(
disp
)
|
|
IsPopup
(
f
)
)
{
return
f
;
}
nsIFrame
*
parent
=
GetCrossDocParentFrame
(
f
)
;
if
(
!
parent
)
{
return
f
;
}
f
=
parent
;
}
}
gfx
:
:
ShapedTextFlags
nsLayoutUtils
:
:
GetTextRunFlagsForStyle
(
ComputedStyle
*
aComputedStyle
nsPresContext
*
aPresContext
const
nsStyleFont
*
aStyleFont
const
nsStyleText
*
aStyleText
nscoord
aLetterSpacing
)
{
gfx
:
:
ShapedTextFlags
result
=
gfx
:
:
ShapedTextFlags
(
)
;
if
(
aLetterSpacing
!
=
0
|
|
aStyleText
-
>
mTextJustify
=
=
StyleTextJustify
:
:
InterCharacter
)
{
result
|
=
gfx
:
:
ShapedTextFlags
:
:
TEXT_DISABLE_OPTIONAL_LIGATURES
;
}
if
(
aStyleText
-
>
mControlCharacterVisibility
=
=
StyleControlCharacterVisibility
:
:
Hidden
)
{
result
|
=
gfx
:
:
ShapedTextFlags
:
:
TEXT_HIDE_CONTROL_CHARACTERS
;
}
switch
(
aComputedStyle
-
>
StyleText
(
)
-
>
mTextRendering
)
{
case
StyleTextRendering
:
:
Optimizespeed
:
result
|
=
gfx
:
:
ShapedTextFlags
:
:
TEXT_OPTIMIZE_SPEED
;
break
;
case
StyleTextRendering
:
:
Auto
:
if
(
aStyleFont
-
>
mFont
.
size
.
ToCSSPixels
(
)
<
aPresContext
-
>
GetAutoQualityMinFontSize
(
)
)
{
result
|
=
gfx
:
:
ShapedTextFlags
:
:
TEXT_OPTIMIZE_SPEED
;
}
break
;
default
:
break
;
}
return
result
|
GetTextRunOrientFlagsForStyle
(
aComputedStyle
)
;
}
gfx
:
:
ShapedTextFlags
nsLayoutUtils
:
:
GetTextRunOrientFlagsForStyle
(
ComputedStyle
*
aComputedStyle
)
{
auto
writingMode
=
aComputedStyle
-
>
StyleVisibility
(
)
-
>
mWritingMode
;
switch
(
writingMode
)
{
case
StyleWritingModeProperty
:
:
HorizontalTb
:
return
gfx
:
:
ShapedTextFlags
:
:
TEXT_ORIENT_HORIZONTAL
;
case
StyleWritingModeProperty
:
:
VerticalLr
:
case
StyleWritingModeProperty
:
:
VerticalRl
:
switch
(
aComputedStyle
-
>
StyleVisibility
(
)
-
>
mTextOrientation
)
{
case
StyleTextOrientation
:
:
Mixed
:
return
gfx
:
:
ShapedTextFlags
:
:
TEXT_ORIENT_VERTICAL_MIXED
;
case
StyleTextOrientation
:
:
Upright
:
return
gfx
:
:
ShapedTextFlags
:
:
TEXT_ORIENT_VERTICAL_UPRIGHT
;
case
StyleTextOrientation
:
:
Sideways
:
return
gfx
:
:
ShapedTextFlags
:
:
TEXT_ORIENT_VERTICAL_SIDEWAYS_RIGHT
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unknown
text
-
orientation
"
)
;
return
gfx
:
:
ShapedTextFlags
(
)
;
}
case
StyleWritingModeProperty
:
:
SidewaysLr
:
return
gfx
:
:
ShapedTextFlags
:
:
TEXT_ORIENT_VERTICAL_SIDEWAYS_LEFT
;
case
StyleWritingModeProperty
:
:
SidewaysRl
:
return
gfx
:
:
ShapedTextFlags
:
:
TEXT_ORIENT_VERTICAL_SIDEWAYS_RIGHT
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unknown
writing
-
mode
"
)
;
return
gfx
:
:
ShapedTextFlags
(
)
;
}
}
void
nsLayoutUtils
:
:
GetRectDifferenceStrips
(
const
nsRect
&
aR1
const
nsRect
&
aR2
nsRect
*
aHStrip
nsRect
*
aVStrip
)
{
NS_ASSERTION
(
aR1
.
TopLeft
(
)
=
=
aR2
.
TopLeft
(
)
"
expected
rects
at
the
same
position
"
)
;
nsRect
unionRect
(
aR1
.
x
aR1
.
y
std
:
:
max
(
aR1
.
width
aR2
.
width
)
std
:
:
max
(
aR1
.
height
aR2
.
height
)
)
;
nscoord
VStripStart
=
std
:
:
min
(
aR1
.
width
aR2
.
width
)
;
nscoord
HStripStart
=
std
:
:
min
(
aR1
.
height
aR2
.
height
)
;
*
aVStrip
=
unionRect
;
aVStrip
-
>
x
+
=
VStripStart
;
aVStrip
-
>
width
-
=
VStripStart
;
*
aHStrip
=
unionRect
;
aHStrip
-
>
y
+
=
HStripStart
;
aHStrip
-
>
height
-
=
HStripStart
;
}
nsDeviceContext
*
nsLayoutUtils
:
:
GetDeviceContextForScreenInfo
(
nsPIDOMWindowOuter
*
aWindow
)
{
if
(
!
aWindow
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
=
aWindow
-
>
GetDocShell
(
)
;
while
(
docShell
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
win
=
docShell
-
>
GetWindow
(
)
;
if
(
!
win
)
{
return
nullptr
;
}
win
-
>
EnsureSizeAndPositionUpToDate
(
)
;
RefPtr
<
nsPresContext
>
presContext
=
docShell
-
>
GetPresContext
(
)
;
if
(
presContext
)
{
nsDeviceContext
*
context
=
presContext
-
>
DeviceContext
(
)
;
if
(
context
)
{
return
context
;
}
}
nsCOMPtr
<
nsIDocShellTreeItem
>
parentItem
;
docShell
-
>
GetInProcessParent
(
getter_AddRefs
(
parentItem
)
)
;
docShell
=
do_QueryInterface
(
parentItem
)
;
}
return
nullptr
;
}
bool
nsLayoutUtils
:
:
IsReallyFixedPos
(
const
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
-
>
StyleDisplay
(
)
-
>
mPosition
=
=
StylePositionProperty
:
:
Fixed
"
IsReallyFixedPos
called
on
non
-
'
position
:
fixed
'
frame
"
)
;
return
MayBeReallyFixedPos
(
aFrame
)
;
}
bool
nsLayoutUtils
:
:
MayBeReallyFixedPos
(
const
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
-
>
GetParent
(
)
"
MayBeReallyFixedPos
called
on
frame
not
in
tree
"
)
;
LayoutFrameType
parentType
=
aFrame
-
>
GetParent
(
)
-
>
Type
(
)
;
return
parentType
=
=
LayoutFrameType
:
:
Viewport
|
|
parentType
=
=
LayoutFrameType
:
:
PageContent
;
}
bool
nsLayoutUtils
:
:
IsInPositionFixedSubtree
(
const
nsIFrame
*
aFrame
)
{
for
(
const
nsIFrame
*
f
=
aFrame
;
f
;
f
=
f
-
>
GetParent
(
)
)
{
if
(
f
-
>
StyleDisplay
(
)
-
>
mPosition
=
=
StylePositionProperty
:
:
Fixed
&
&
nsLayoutUtils
:
:
IsReallyFixedPos
(
f
)
)
{
return
true
;
}
}
return
false
;
}
SurfaceFromElementResult
nsLayoutUtils
:
:
SurfaceFromOffscreenCanvas
(
OffscreenCanvas
*
aOffscreenCanvas
uint32_t
aSurfaceFlags
RefPtr
<
DrawTarget
>
&
aTarget
)
{
SurfaceFromElementResult
result
;
IntSize
size
=
aOffscreenCanvas
-
>
GetWidthHeight
(
)
;
result
.
mSourceSurface
=
aOffscreenCanvas
-
>
GetSurfaceSnapshot
(
&
result
.
mAlphaType
)
;
if
(
!
result
.
mSourceSurface
)
{
result
.
mAlphaType
=
gfxAlphaType
:
:
Opaque
;
RefPtr
<
DrawTarget
>
ref
=
aTarget
?
aTarget
:
gfxPlatform
:
:
GetPlatform
(
)
-
>
ScreenReferenceDrawTarget
(
)
;
if
(
ref
-
>
CanCreateSimilarDrawTarget
(
size
SurfaceFormat
:
:
B8G8R8A8
)
)
{
RefPtr
<
DrawTarget
>
dt
=
ref
-
>
CreateSimilarDrawTarget
(
size
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
dt
)
{
result
.
mSourceSurface
=
dt
-
>
Snapshot
(
)
;
}
}
}
else
if
(
aTarget
)
{
RefPtr
<
SourceSurface
>
opt
=
aTarget
-
>
OptimizeSourceSurface
(
result
.
mSourceSurface
)
;
if
(
opt
)
{
result
.
mSourceSurface
=
opt
;
}
}
result
.
mHasSize
=
true
;
result
.
mSize
=
size
;
result
.
mIntrinsicSize
=
size
;
result
.
mIsWriteOnly
=
aOffscreenCanvas
-
>
IsWriteOnly
(
)
;
return
result
;
}
SurfaceFromElementResult
nsLayoutUtils
:
:
SurfaceFromElement
(
nsIImageLoadingContent
*
aElement
uint32_t
aSurfaceFlags
RefPtr
<
DrawTarget
>
&
aTarget
)
{
SurfaceFromElementResult
result
;
nsresult
rv
;
nsCOMPtr
<
imgIRequest
>
imgRequest
;
rv
=
aElement
-
>
GetRequest
(
nsIImageLoadingContent
:
:
CURRENT_REQUEST
getter_AddRefs
(
imgRequest
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
result
;
}
if
(
!
imgRequest
)
{
nsCOMPtr
<
nsIURI
>
currentURI
;
aElement
-
>
GetCurrentURI
(
getter_AddRefs
(
currentURI
)
)
;
if
(
!
currentURI
)
{
result
.
mHasSize
=
true
;
}
return
result
;
}
uint32_t
status
;
imgRequest
-
>
GetImageStatus
(
&
status
)
;
result
.
mHasSize
=
status
&
imgIRequest
:
:
STATUS_SIZE_AVAILABLE
;
if
(
(
status
&
imgIRequest
:
:
STATUS_LOAD_COMPLETE
)
=
=
0
)
{
result
.
mIsStillLoading
=
(
status
&
imgIRequest
:
:
STATUS_ERROR
)
=
=
0
;
return
result
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
;
rv
=
imgRequest
-
>
GetImagePrincipal
(
getter_AddRefs
(
principal
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
result
;
}
nsCOMPtr
<
imgIContainer
>
imgContainer
;
rv
=
imgRequest
-
>
GetImage
(
getter_AddRefs
(
imgContainer
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
result
;
}
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
aElement
)
;
auto
orientation
=
StaticPrefs
:
:
image_honor_orientation_metadata
(
)
?
StyleImageOrientation
:
:
FromImage
:
StyleImageOrientation
:
:
None
;
if
(
nsIFrame
*
f
=
content
-
>
GetPrimaryFrame
(
)
)
{
orientation
=
f
-
>
StyleVisibility
(
)
-
>
mImageOrientation
;
}
imgContainer
=
OrientImage
(
imgContainer
orientation
)
;
uint32_t
noRasterize
=
aSurfaceFlags
&
SFE_NO_RASTERIZING_VECTORS
;
uint32_t
whichFrame
=
(
aSurfaceFlags
&
SFE_WANT_FIRST_FRAME_IF_IMAGE
)
?
(
uint32_t
)
imgIContainer
:
:
FRAME_FIRST
:
(
uint32_t
)
imgIContainer
:
:
FRAME_CURRENT
;
uint32_t
frameFlags
=
imgIContainer
:
:
FLAG_SYNC_DECODE
|
imgIContainer
:
:
FLAG_ASYNC_NOTIFY
;
if
(
aSurfaceFlags
&
SFE_NO_COLORSPACE_CONVERSION
)
frameFlags
|
=
imgIContainer
:
:
FLAG_DECODE_NO_COLORSPACE_CONVERSION
;
if
(
aSurfaceFlags
&
SFE_ALLOW_NON_PREMULT
)
{
frameFlags
|
=
imgIContainer
:
:
FLAG_DECODE_NO_PREMULTIPLY_ALPHA
;
}
int32_t
imgWidth
imgHeight
;
HTMLImageElement
*
element
=
HTMLImageElement
:
:
FromNodeOrNull
(
content
)
;
if
(
aSurfaceFlags
&
SFE_USE_ELEMENT_SIZE_IF_VECTOR
&
&
element
&
&
imgContainer
-
>
GetType
(
)
=
=
imgIContainer
:
:
TYPE_VECTOR
)
{
imgWidth
=
MOZ_KnownLive
(
element
)
-
>
Width
(
)
;
imgHeight
=
MOZ_KnownLive
(
element
)
-
>
Height
(
)
;
}
else
{
rv
=
imgContainer
-
>
GetWidth
(
&
imgWidth
)
;
nsresult
rv2
=
imgContainer
-
>
GetHeight
(
&
imgHeight
)
;
if
(
NS_FAILED
(
rv
)
|
|
NS_FAILED
(
rv2
)
)
return
result
;
}
result
.
mSize
=
IntSize
(
imgWidth
imgHeight
)
;
result
.
mIntrinsicSize
=
IntSize
(
imgWidth
imgHeight
)
;
if
(
!
noRasterize
|
|
imgContainer
-
>
GetType
(
)
=
=
imgIContainer
:
:
TYPE_RASTER
)
{
if
(
aSurfaceFlags
&
SFE_WANT_IMAGE_SURFACE
)
{
frameFlags
|
=
imgIContainer
:
:
FLAG_WANT_DATA_SURFACE
;
}
result
.
mSourceSurface
=
imgContainer
-
>
GetFrameAtSize
(
result
.
mSize
whichFrame
frameFlags
)
;
if
(
!
result
.
mSourceSurface
)
{
return
result
;
}
if
(
aTarget
)
{
RefPtr
<
SourceSurface
>
optSurface
=
aTarget
-
>
OptimizeSourceSurface
(
result
.
mSourceSurface
)
;
if
(
optSurface
)
{
result
.
mSourceSurface
=
optSurface
;
}
}
const
auto
&
format
=
result
.
mSourceSurface
-
>
GetFormat
(
)
;
if
(
IsOpaque
(
format
)
)
{
result
.
mAlphaType
=
gfxAlphaType
:
:
Opaque
;
}
else
if
(
frameFlags
&
imgIContainer
:
:
FLAG_DECODE_NO_PREMULTIPLY_ALPHA
)
{
result
.
mAlphaType
=
gfxAlphaType
:
:
NonPremult
;
}
else
{
result
.
mAlphaType
=
gfxAlphaType
:
:
Premult
;
}
}
else
{
result
.
mDrawInfo
.
mImgContainer
=
imgContainer
;
result
.
mDrawInfo
.
mWhichFrame
=
whichFrame
;
result
.
mDrawInfo
.
mDrawingFlags
=
frameFlags
;
}
int32_t
corsmode
;
if
(
NS_SUCCEEDED
(
imgRequest
-
>
GetCORSMode
(
&
corsmode
)
)
)
{
result
.
mCORSUsed
=
(
corsmode
!
=
imgIRequest
:
:
CORS_NONE
)
;
}
bool
hadCrossOriginRedirects
=
true
;
imgRequest
-
>
GetHadCrossOriginRedirects
(
&
hadCrossOriginRedirects
)
;
result
.
mPrincipal
=
std
:
:
move
(
principal
)
;
result
.
mHadCrossOriginRedirects
=
hadCrossOriginRedirects
;
result
.
mImageRequest
=
std
:
:
move
(
imgRequest
)
;
result
.
mIsWriteOnly
=
CanvasUtils
:
:
CheckWriteOnlySecurity
(
result
.
mCORSUsed
result
.
mPrincipal
result
.
mHadCrossOriginRedirects
)
;
return
result
;
}
SurfaceFromElementResult
nsLayoutUtils
:
:
SurfaceFromElement
(
HTMLImageElement
*
aElement
uint32_t
aSurfaceFlags
RefPtr
<
DrawTarget
>
&
aTarget
)
{
return
SurfaceFromElement
(
static_cast
<
nsIImageLoadingContent
*
>
(
aElement
)
aSurfaceFlags
aTarget
)
;
}
SurfaceFromElementResult
nsLayoutUtils
:
:
SurfaceFromElement
(
HTMLCanvasElement
*
aElement
uint32_t
aSurfaceFlags
RefPtr
<
DrawTarget
>
&
aTarget
)
{
SurfaceFromElementResult
result
;
IntSize
size
=
aElement
-
>
GetSize
(
)
;
auto
pAlphaType
=
&
result
.
mAlphaType
;
if
(
!
(
aSurfaceFlags
&
SFE_ALLOW_NON_PREMULT
)
)
{
pAlphaType
=
nullptr
;
}
result
.
mSourceSurface
=
aElement
-
>
GetSurfaceSnapshot
(
pAlphaType
)
;
if
(
!
result
.
mSourceSurface
)
{
result
.
mAlphaType
=
gfxAlphaType
:
:
Opaque
;
RefPtr
<
DrawTarget
>
ref
=
aTarget
?
aTarget
:
gfxPlatform
:
:
GetPlatform
(
)
-
>
ScreenReferenceDrawTarget
(
)
;
if
(
ref
-
>
CanCreateSimilarDrawTarget
(
size
SurfaceFormat
:
:
B8G8R8A8
)
)
{
RefPtr
<
DrawTarget
>
dt
=
ref
-
>
CreateSimilarDrawTarget
(
size
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
dt
)
{
result
.
mSourceSurface
=
dt
-
>
Snapshot
(
)
;
}
}
}
else
if
(
aTarget
)
{
RefPtr
<
SourceSurface
>
opt
=
aTarget
-
>
OptimizeSourceSurface
(
result
.
mSourceSurface
)
;
if
(
opt
)
{
result
.
mSourceSurface
=
opt
;
}
}
aElement
-
>
MarkContextClean
(
)
;
result
.
mHasSize
=
true
;
result
.
mSize
=
size
;
result
.
mIntrinsicSize
=
size
;
result
.
mPrincipal
=
aElement
-
>
NodePrincipal
(
)
;
result
.
mHadCrossOriginRedirects
=
false
;
result
.
mIsWriteOnly
=
aElement
-
>
IsWriteOnly
(
)
;
return
result
;
}
SurfaceFromElementResult
nsLayoutUtils
:
:
SurfaceFromElement
(
HTMLVideoElement
*
aElement
uint32_t
aSurfaceFlags
RefPtr
<
DrawTarget
>
&
aTarget
)
{
SurfaceFromElementResult
result
;
result
.
mAlphaType
=
gfxAlphaType
:
:
Opaque
;
if
(
aElement
-
>
ContainsRestrictedContent
(
)
)
{
return
result
;
}
uint16_t
readyState
=
aElement
-
>
ReadyState
(
)
;
if
(
readyState
=
=
HAVE_NOTHING
|
|
readyState
=
=
HAVE_METADATA
)
{
result
.
mIsStillLoading
=
true
;
return
result
;
}
nsCOMPtr
<
nsIPrincipal
>
principal
=
aElement
-
>
GetCurrentVideoPrincipal
(
)
;
if
(
!
principal
)
return
result
;
result
.
mLayersImage
=
aElement
-
>
GetCurrentImage
(
)
;
if
(
!
result
.
mLayersImage
)
return
result
;
if
(
aTarget
)
{
result
.
mSourceSurface
=
result
.
mLayersImage
-
>
GetAsSourceSurface
(
)
;
if
(
!
result
.
mSourceSurface
)
return
result
;
RefPtr
<
SourceSurface
>
opt
=
aTarget
-
>
OptimizeSourceSurface
(
result
.
mSourceSurface
)
;
if
(
opt
)
{
result
.
mSourceSurface
=
opt
;
}
}
result
.
mCORSUsed
=
aElement
-
>
GetCORSMode
(
)
!
=
CORS_NONE
;
result
.
mHasSize
=
true
;
result
.
mSize
=
result
.
mLayersImage
-
>
GetSize
(
)
;
result
.
mIntrinsicSize
=
gfx
:
:
IntSize
(
aElement
-
>
VideoWidth
(
)
aElement
-
>
VideoHeight
(
)
)
;
result
.
mPrincipal
=
std
:
:
move
(
principal
)
;
result
.
mHadCrossOriginRedirects
=
aElement
-
>
HadCrossOriginRedirects
(
)
;
result
.
mIsWriteOnly
=
CanvasUtils
:
:
CheckWriteOnlySecurity
(
result
.
mCORSUsed
result
.
mPrincipal
result
.
mHadCrossOriginRedirects
)
;
return
result
;
}
SurfaceFromElementResult
nsLayoutUtils
:
:
SurfaceFromElement
(
dom
:
:
Element
*
aElement
uint32_t
aSurfaceFlags
RefPtr
<
DrawTarget
>
&
aTarget
)
{
if
(
HTMLCanvasElement
*
canvas
=
HTMLCanvasElement
:
:
FromNodeOrNull
(
aElement
)
)
{
return
SurfaceFromElement
(
canvas
aSurfaceFlags
aTarget
)
;
}
if
(
HTMLVideoElement
*
video
=
HTMLVideoElement
:
:
FromNodeOrNull
(
aElement
)
)
{
return
SurfaceFromElement
(
video
aSurfaceFlags
aTarget
)
;
}
nsCOMPtr
<
nsIImageLoadingContent
>
imageLoader
=
do_QueryInterface
(
aElement
)
;
if
(
!
imageLoader
)
{
return
SurfaceFromElementResult
(
)
;
}
return
SurfaceFromElement
(
imageLoader
aSurfaceFlags
aTarget
)
;
}
Element
*
nsLayoutUtils
:
:
GetEditableRootContentByContentEditable
(
Document
*
aDocument
)
{
if
(
!
aDocument
|
|
aDocument
-
>
HasFlag
(
NODE_IS_EDITABLE
)
)
{
return
nullptr
;
}
if
(
!
aDocument
-
>
IsHTMLOrXHTML
(
)
)
{
return
nullptr
;
}
Element
*
rootElement
=
aDocument
-
>
GetRootElement
(
)
;
if
(
rootElement
&
&
rootElement
-
>
IsEditable
(
)
)
{
return
rootElement
;
}
Element
*
bodyElement
=
aDocument
-
>
GetBody
(
)
;
if
(
bodyElement
&
&
bodyElement
-
>
IsEditable
(
)
)
{
return
bodyElement
;
}
return
nullptr
;
}
#
ifdef
DEBUG
void
nsLayoutUtils
:
:
AssertNoDuplicateContinuations
(
nsIFrame
*
aContainer
const
nsFrameList
&
aFrameList
)
{
for
(
nsIFrame
*
f
:
aFrameList
)
{
for
(
nsIFrame
*
c
=
f
;
(
c
=
c
-
>
GetNextInFlow
(
)
)
;
)
{
NS_ASSERTION
(
c
-
>
GetParent
(
)
!
=
aContainer
|
|
!
aFrameList
.
ContainsFrame
(
c
)
"
Two
continuations
of
the
same
frame
in
the
same
"
"
frame
list
"
)
;
}
}
}
static
bool
IsInLetterFrame
(
nsIFrame
*
aFrame
)
{
for
(
nsIFrame
*
f
=
aFrame
-
>
GetParent
(
)
;
f
;
f
=
f
-
>
GetParent
(
)
)
{
if
(
f
-
>
IsLetterFrame
(
)
)
{
return
true
;
}
}
return
false
;
}
void
nsLayoutUtils
:
:
AssertTreeOnlyEmptyNextInFlows
(
nsIFrame
*
aSubtreeRoot
)
{
NS_ASSERTION
(
aSubtreeRoot
-
>
GetPrevInFlow
(
)
"
frame
tree
not
empty
but
caller
reported
complete
status
"
)
;
int32_t
start
end
;
nsresult
rv
=
aSubtreeRoot
-
>
GetOffsets
(
start
end
)
;
NS_ASSERTION
(
NS_SUCCEEDED
(
rv
)
"
GetOffsets
failed
"
)
;
NS_ASSERTION
(
start
=
=
end
|
|
IsInLetterFrame
(
aSubtreeRoot
)
"
frame
tree
not
empty
but
caller
reported
complete
status
"
)
;
for
(
const
auto
&
childList
:
aSubtreeRoot
-
>
ChildLists
(
)
)
{
for
(
nsIFrame
*
child
:
childList
.
mList
)
{
nsLayoutUtils
:
:
AssertTreeOnlyEmptyNextInFlows
(
child
)
;
}
}
}
#
endif
static
void
GetFontFacesForFramesInner
(
nsIFrame
*
aFrame
nsLayoutUtils
:
:
UsedFontFaceList
&
aResult
nsLayoutUtils
:
:
UsedFontFaceTable
&
aFontFaces
uint32_t
aMaxRanges
bool
aSkipCollapsedWhitespace
)
{
MOZ_ASSERT
(
aFrame
"
NULL
frame
pointer
"
)
;
if
(
aFrame
-
>
IsTextFrame
(
)
)
{
if
(
!
aFrame
-
>
GetPrevContinuation
(
)
)
{
nsLayoutUtils
:
:
GetFontFacesForText
(
aFrame
0
INT32_MAX
true
aResult
aFontFaces
aMaxRanges
aSkipCollapsedWhitespace
)
;
}
return
;
}
nsIFrame
:
:
ChildListID
childLists
[
]
=
{
nsIFrame
:
:
kPrincipalList
nsIFrame
:
:
kPopupList
}
;
for
(
size_t
i
=
0
;
i
<
ArrayLength
(
childLists
)
;
+
+
i
)
{
nsFrameList
children
(
aFrame
-
>
GetChildList
(
childLists
[
i
]
)
)
;
for
(
nsFrameList
:
:
Enumerator
e
(
children
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
)
{
nsIFrame
*
child
=
e
.
get
(
)
;
child
=
nsPlaceholderFrame
:
:
GetRealFrameFor
(
child
)
;
GetFontFacesForFramesInner
(
child
aResult
aFontFaces
aMaxRanges
aSkipCollapsedWhitespace
)
;
}
}
}
nsresult
nsLayoutUtils
:
:
GetFontFacesForFrames
(
nsIFrame
*
aFrame
UsedFontFaceList
&
aResult
UsedFontFaceTable
&
aFontFaces
uint32_t
aMaxRanges
bool
aSkipCollapsedWhitespace
)
{
MOZ_ASSERT
(
aFrame
"
NULL
frame
pointer
"
)
;
while
(
aFrame
)
{
GetFontFacesForFramesInner
(
aFrame
aResult
aFontFaces
aMaxRanges
aSkipCollapsedWhitespace
)
;
aFrame
=
GetNextContinuationOrIBSplitSibling
(
aFrame
)
;
}
return
NS_OK
;
}
static
void
AddFontsFromTextRun
(
gfxTextRun
*
aTextRun
nsTextFrame
*
aFrame
gfxSkipCharsIterator
&
aSkipIter
const
gfxTextRun
:
:
Range
&
aRange
nsLayoutUtils
:
:
UsedFontFaceList
&
aResult
nsLayoutUtils
:
:
UsedFontFaceTable
&
aFontFaces
uint32_t
aMaxRanges
)
{
gfxTextRun
:
:
GlyphRunIterator
glyphRuns
(
aTextRun
aRange
)
;
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
int32_t
contentLimit
=
aFrame
-
>
GetContentOffset
(
)
+
aFrame
-
>
GetInFlowContentLength
(
)
;
while
(
glyphRuns
.
NextRun
(
)
)
{
gfxFontEntry
*
fe
=
glyphRuns
.
GetGlyphRun
(
)
-
>
mFont
-
>
GetFontEntry
(
)
;
InspectorFontFace
*
fontFace
=
aFontFaces
.
Get
(
fe
)
;
if
(
fontFace
)
{
fontFace
-
>
AddMatchType
(
glyphRuns
.
GetGlyphRun
(
)
-
>
mMatchType
)
;
}
else
{
fontFace
=
new
InspectorFontFace
(
fe
aTextRun
-
>
GetFontGroup
(
)
glyphRuns
.
GetGlyphRun
(
)
-
>
mMatchType
)
;
aFontFaces
.
Put
(
fe
fontFace
)
;
aResult
.
AppendElement
(
fontFace
)
;
}
if
(
fontFace
-
>
RangeCount
(
)
<
aMaxRanges
)
{
int32_t
start
=
aSkipIter
.
ConvertSkippedToOriginal
(
glyphRuns
.
GetStringStart
(
)
)
;
int32_t
end
=
aSkipIter
.
ConvertSkippedToOriginal
(
glyphRuns
.
GetStringEnd
(
)
)
;
end
=
std
:
:
min
(
end
contentLimit
)
;
if
(
end
>
start
)
{
RefPtr
<
nsRange
>
range
=
nsRange
:
:
Create
(
content
start
content
end
IgnoreErrors
(
)
)
;
NS_WARNING_ASSERTION
(
range
"
nsRange
:
:
Create
(
)
failed
to
create
valid
range
"
)
;
if
(
range
)
{
fontFace
-
>
AddRange
(
range
)
;
}
}
}
}
}
void
nsLayoutUtils
:
:
GetFontFacesForText
(
nsIFrame
*
aFrame
int32_t
aStartOffset
int32_t
aEndOffset
bool
aFollowContinuations
UsedFontFaceList
&
aResult
UsedFontFaceTable
&
aFontFaces
uint32_t
aMaxRanges
bool
aSkipCollapsedWhitespace
)
{
MOZ_ASSERT
(
aFrame
"
NULL
frame
pointer
"
)
;
if
(
!
aFrame
-
>
IsTextFrame
(
)
)
{
return
;
}
if
(
!
aFrame
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
)
{
return
;
}
nsTextFrame
*
curr
=
static_cast
<
nsTextFrame
*
>
(
aFrame
)
;
do
{
int32_t
fstart
=
std
:
:
max
(
curr
-
>
GetContentOffset
(
)
aStartOffset
)
;
int32_t
fend
=
std
:
:
min
(
curr
-
>
GetContentEnd
(
)
aEndOffset
)
;
if
(
fstart
>
=
fend
)
{
curr
=
static_cast
<
nsTextFrame
*
>
(
curr
-
>
GetNextContinuation
(
)
)
;
continue
;
}
gfxSkipCharsIterator
iter
=
curr
-
>
EnsureTextRun
(
nsTextFrame
:
:
eInflated
)
;
gfxTextRun
*
textRun
=
curr
-
>
GetTextRun
(
nsTextFrame
:
:
eInflated
)
;
if
(
!
textRun
)
{
NS_WARNING
(
"
failed
to
get
textRun
low
memory
?
"
)
;
return
;
}
nsTextFrame
*
next
=
nullptr
;
if
(
aFollowContinuations
&
&
fend
<
aEndOffset
)
{
next
=
static_cast
<
nsTextFrame
*
>
(
curr
-
>
GetNextContinuation
(
)
)
;
while
(
next
&
&
next
-
>
GetTextRun
(
nsTextFrame
:
:
eInflated
)
=
=
textRun
)
{
fend
=
std
:
:
min
(
next
-
>
GetContentEnd
(
)
aEndOffset
)
;
next
=
fend
<
aEndOffset
?
static_cast
<
nsTextFrame
*
>
(
next
-
>
GetNextContinuation
(
)
)
:
nullptr
;
}
}
if
(
!
aSkipCollapsedWhitespace
|
|
(
curr
-
>
HasAnyNoncollapsedCharacters
(
)
&
&
curr
-
>
HasNonSuppressedText
(
)
)
)
{
gfxTextRun
:
:
Range
range
(
iter
.
ConvertOriginalToSkipped
(
fstart
)
iter
.
ConvertOriginalToSkipped
(
fend
)
)
;
AddFontsFromTextRun
(
textRun
curr
iter
range
aResult
aFontFaces
aMaxRanges
)
;
}
curr
=
next
;
}
while
(
aFollowContinuations
&
&
curr
)
;
}
size_t
nsLayoutUtils
:
:
SizeOfTextRunsForFrames
(
nsIFrame
*
aFrame
MallocSizeOf
aMallocSizeOf
bool
clear
)
{
MOZ_ASSERT
(
aFrame
"
NULL
frame
pointer
"
)
;
size_t
total
=
0
;
if
(
aFrame
-
>
IsTextFrame
(
)
)
{
nsTextFrame
*
textFrame
=
static_cast
<
nsTextFrame
*
>
(
aFrame
)
;
for
(
uint32_t
i
=
0
;
i
<
2
;
+
+
i
)
{
gfxTextRun
*
run
=
textFrame
-
>
GetTextRun
(
(
i
!
=
0
)
?
nsTextFrame
:
:
eInflated
:
nsTextFrame
:
:
eNotInflated
)
;
if
(
run
)
{
if
(
clear
)
{
run
-
>
ResetSizeOfAccountingFlags
(
)
;
}
else
{
total
+
=
run
-
>
MaybeSizeOfIncludingThis
(
aMallocSizeOf
)
;
}
}
}
return
total
;
}
for
(
const
auto
&
childList
:
aFrame
-
>
ChildLists
(
)
)
{
for
(
nsIFrame
*
f
:
childList
.
mList
)
{
total
+
=
SizeOfTextRunsForFrames
(
f
aMallocSizeOf
clear
)
;
}
}
return
total
;
}
void
nsLayoutUtils
:
:
Initialize
(
)
{
nsComputedDOMStyle
:
:
RegisterPrefChangeCallbacks
(
)
;
}
void
nsLayoutUtils
:
:
Shutdown
(
)
{
if
(
sContentMap
)
{
delete
sContentMap
;
sContentMap
=
nullptr
;
}
nsComputedDOMStyle
:
:
UnregisterPrefChangeCallbacks
(
)
;
}
void
nsLayoutUtils
:
:
RegisterImageRequest
(
nsPresContext
*
aPresContext
imgIRequest
*
aRequest
bool
*
aRequestRegistered
)
{
if
(
!
aPresContext
)
{
return
;
}
if
(
aRequestRegistered
&
&
*
aRequestRegistered
)
{
return
;
}
if
(
aRequest
)
{
if
(
!
aPresContext
-
>
RefreshDriver
(
)
-
>
AddImageRequest
(
aRequest
)
)
{
NS_WARNING
(
"
Unable
to
add
image
request
"
)
;
return
;
}
if
(
aRequestRegistered
)
{
*
aRequestRegistered
=
true
;
}
}
}
void
nsLayoutUtils
:
:
RegisterImageRequestIfAnimated
(
nsPresContext
*
aPresContext
imgIRequest
*
aRequest
bool
*
aRequestRegistered
)
{
if
(
!
aPresContext
)
{
return
;
}
if
(
aRequestRegistered
&
&
*
aRequestRegistered
)
{
return
;
}
if
(
aRequest
)
{
nsCOMPtr
<
imgIContainer
>
image
;
if
(
NS_SUCCEEDED
(
aRequest
-
>
GetImage
(
getter_AddRefs
(
image
)
)
)
)
{
bool
isAnimated
=
false
;
nsresult
rv
=
image
-
>
GetAnimated
(
&
isAnimated
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
isAnimated
)
{
if
(
!
aPresContext
-
>
RefreshDriver
(
)
-
>
AddImageRequest
(
aRequest
)
)
{
NS_WARNING
(
"
Unable
to
add
image
request
"
)
;
return
;
}
if
(
aRequestRegistered
)
{
*
aRequestRegistered
=
true
;
}
}
}
}
}
void
nsLayoutUtils
:
:
DeregisterImageRequest
(
nsPresContext
*
aPresContext
imgIRequest
*
aRequest
bool
*
aRequestRegistered
)
{
if
(
!
aPresContext
)
{
return
;
}
if
(
aRequestRegistered
&
&
!
*
aRequestRegistered
)
{
return
;
}
if
(
aRequest
)
{
nsCOMPtr
<
imgIContainer
>
image
;
if
(
NS_SUCCEEDED
(
aRequest
-
>
GetImage
(
getter_AddRefs
(
image
)
)
)
)
{
aPresContext
-
>
RefreshDriver
(
)
-
>
RemoveImageRequest
(
aRequest
)
;
if
(
aRequestRegistered
)
{
*
aRequestRegistered
=
false
;
}
}
}
}
void
nsLayoutUtils
:
:
PostRestyleEvent
(
Element
*
aElement
RestyleHint
aRestyleHint
nsChangeHint
aMinChangeHint
)
{
if
(
Document
*
doc
=
aElement
-
>
GetComposedDoc
(
)
)
{
if
(
nsPresContext
*
presContext
=
doc
-
>
GetPresContext
(
)
)
{
presContext
-
>
RestyleManager
(
)
-
>
PostRestyleEvent
(
aElement
aRestyleHint
aMinChangeHint
)
;
}
}
}
nsSetAttrRunnable
:
:
nsSetAttrRunnable
(
Element
*
aElement
nsAtom
*
aAttrName
const
nsAString
&
aValue
)
:
mozilla
:
:
Runnable
(
"
nsSetAttrRunnable
"
)
mElement
(
aElement
)
mAttrName
(
aAttrName
)
mValue
(
aValue
)
{
NS_ASSERTION
(
aElement
&
&
aAttrName
"
Missing
stuff
prepare
to
crash
"
)
;
}
nsSetAttrRunnable
:
:
nsSetAttrRunnable
(
Element
*
aElement
nsAtom
*
aAttrName
int32_t
aValue
)
:
mozilla
:
:
Runnable
(
"
nsSetAttrRunnable
"
)
mElement
(
aElement
)
mAttrName
(
aAttrName
)
{
NS_ASSERTION
(
aElement
&
&
aAttrName
"
Missing
stuff
prepare
to
crash
"
)
;
mValue
.
AppendInt
(
aValue
)
;
}
NS_IMETHODIMP
nsSetAttrRunnable
:
:
Run
(
)
{
return
mElement
-
>
SetAttr
(
kNameSpaceID_None
mAttrName
mValue
true
)
;
}
nsUnsetAttrRunnable
:
:
nsUnsetAttrRunnable
(
Element
*
aElement
nsAtom
*
aAttrName
)
:
mozilla
:
:
Runnable
(
"
nsUnsetAttrRunnable
"
)
mElement
(
aElement
)
mAttrName
(
aAttrName
)
{
NS_ASSERTION
(
aElement
&
&
aAttrName
"
Missing
stuff
prepare
to
crash
"
)
;
}
NS_IMETHODIMP
nsUnsetAttrRunnable
:
:
Run
(
)
{
return
mElement
-
>
UnsetAttr
(
kNameSpaceID_None
mAttrName
true
)
;
}
static
nscoord
MinimumFontSizeFor
(
nsPresContext
*
aPresContext
WritingMode
aWritingMode
nscoord
aContainerISize
)
{
PresShell
*
presShell
=
aPresContext
-
>
PresShell
(
)
;
uint32_t
emPerLine
=
presShell
-
>
FontSizeInflationEmPerLine
(
)
;
uint32_t
minTwips
=
presShell
-
>
FontSizeInflationMinTwips
(
)
;
if
(
emPerLine
=
=
0
&
&
minTwips
=
=
0
)
{
return
0
;
}
nscoord
byLine
=
0
byInch
=
0
;
if
(
emPerLine
!
=
0
)
{
byLine
=
aContainerISize
/
emPerLine
;
}
if
(
minTwips
!
=
0
)
{
gfxSize
screenSize
=
aPresContext
-
>
ScreenSizeInchesForFontInflation
(
)
;
float
deviceISizeInches
=
aWritingMode
.
IsVertical
(
)
?
screenSize
.
height
:
screenSize
.
width
;
byInch
=
NSToCoordRound
(
aContainerISize
/
(
deviceISizeInches
*
1440
/
minTwips
)
)
;
}
return
std
:
:
max
(
byLine
byInch
)
;
}
float
nsLayoutUtils
:
:
FontSizeInflationInner
(
const
nsIFrame
*
aFrame
nscoord
aMinFontSize
)
{
nscoord
styleFontSize
=
aFrame
-
>
StyleFont
(
)
-
>
mFont
.
size
.
ToAppUnits
(
)
;
if
(
styleFontSize
<
=
0
)
{
return
1
.
0
;
}
if
(
aMinFontSize
<
=
0
)
{
return
1
.
0
;
}
for
(
const
nsIFrame
*
f
=
aFrame
;
f
&
&
!
f
-
>
IsContainerForFontSizeInflation
(
)
;
f
=
f
-
>
GetParent
(
)
)
{
nsIContent
*
content
=
f
-
>
GetContent
(
)
;
LayoutFrameType
fType
=
f
-
>
Type
(
)
;
nsIFrame
*
parent
=
f
-
>
GetParent
(
)
;
if
(
!
(
parent
&
&
parent
-
>
GetContent
(
)
=
=
content
)
&
&
fType
!
=
LayoutFrameType
:
:
Inline
&
&
fType
!
=
LayoutFrameType
:
:
CheckboxRadio
)
{
if
(
fType
=
=
LayoutFrameType
:
:
RubyText
)
{
MOZ_ASSERT
(
parent
&
&
parent
-
>
IsRubyTextContainerFrame
(
)
)
;
nsIFrame
*
grandparent
=
parent
-
>
GetParent
(
)
;
MOZ_ASSERT
(
grandparent
&
&
grandparent
-
>
IsRubyFrame
(
)
)
;
return
FontSizeInflationFor
(
grandparent
)
;
}
WritingMode
wm
=
f
-
>
GetWritingMode
(
)
;
const
auto
&
stylePosISize
=
f
-
>
StylePosition
(
)
-
>
ISize
(
wm
)
;
const
auto
&
stylePosBSize
=
f
-
>
StylePosition
(
)
-
>
BSize
(
wm
)
;
if
(
!
stylePosISize
.
IsAuto
(
)
|
|
!
stylePosBSize
.
BehavesLikeInitialValueOnBlockAxis
(
)
)
{
return
1
.
0
;
}
}
}
int32_t
interceptParam
=
StaticPrefs
:
:
font_size_inflation_mappingIntercept
(
)
;
float
maxRatio
=
(
float
)
StaticPrefs
:
:
font_size_inflation_maxRatio
(
)
/
100
.
0f
;
float
ratio
=
float
(
styleFontSize
)
/
float
(
aMinFontSize
)
;
float
inflationRatio
;
if
(
interceptParam
>
=
0
)
{
float
intercept
=
1
+
float
(
interceptParam
)
/
2
.
0f
;
if
(
ratio
>
=
intercept
)
{
return
1
.
0
;
}
inflationRatio
=
(
1
.
0f
+
(
ratio
*
(
intercept
-
1
)
/
intercept
)
)
/
ratio
;
}
else
{
inflationRatio
=
1
+
1
.
0f
/
ratio
;
}
if
(
maxRatio
>
1
.
0
&
&
inflationRatio
>
maxRatio
)
{
return
maxRatio
;
}
else
{
return
inflationRatio
;
}
}
static
bool
ShouldInflateFontsForContainer
(
const
nsIFrame
*
aFrame
)
{
const
nsStyleText
*
styleText
=
aFrame
-
>
StyleText
(
)
;
return
styleText
-
>
mTextSizeAdjust
!
=
StyleTextSizeAdjust
:
:
None
&
&
!
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_IN_CONSTRAINED_BSIZE
)
&
&
(
styleText
-
>
WhiteSpaceCanWrap
(
aFrame
)
|
|
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eMathML
)
)
;
}
nscoord
nsLayoutUtils
:
:
InflationMinFontSizeFor
(
const
nsIFrame
*
aFrame
)
{
nsPresContext
*
presContext
=
aFrame
-
>
PresContext
(
)
;
if
(
!
FontSizeInflationEnabled
(
presContext
)
|
|
presContext
-
>
mInflationDisabledForShrinkWrap
)
{
return
0
;
}
for
(
const
nsIFrame
*
f
=
aFrame
;
f
;
f
=
f
-
>
GetParent
(
)
)
{
if
(
f
-
>
IsContainerForFontSizeInflation
(
)
)
{
if
(
!
ShouldInflateFontsForContainer
(
f
)
)
{
return
0
;
}
nsFontInflationData
*
data
=
nsFontInflationData
:
:
FindFontInflationDataFor
(
aFrame
)
;
if
(
!
data
|
|
!
data
-
>
InflationEnabled
(
)
)
{
return
0
;
}
return
MinimumFontSizeFor
(
aFrame
-
>
PresContext
(
)
aFrame
-
>
GetWritingMode
(
)
data
-
>
UsableISize
(
)
)
;
}
}
MOZ_ASSERT
(
false
"
root
should
always
be
container
"
)
;
return
0
;
}
float
nsLayoutUtils
:
:
FontSizeInflationFor
(
const
nsIFrame
*
aFrame
)
{
if
(
SVGUtils
:
:
IsInSVGTextSubtree
(
aFrame
)
)
{
const
nsIFrame
*
container
=
aFrame
;
while
(
!
container
-
>
IsSVGTextFrame
(
)
)
{
container
=
container
-
>
GetParent
(
)
;
}
NS_ASSERTION
(
container
"
expected
to
find
an
ancestor
SVGTextFrame
"
)
;
return
static_cast
<
const
SVGTextFrame
*
>
(
container
)
-
>
GetFontSizeScaleFactor
(
)
;
}
if
(
!
FontSizeInflationEnabled
(
aFrame
-
>
PresContext
(
)
)
)
{
return
1
.
0f
;
}
return
FontSizeInflationInner
(
aFrame
InflationMinFontSizeFor
(
aFrame
)
)
;
}
bool
nsLayoutUtils
:
:
FontSizeInflationEnabled
(
nsPresContext
*
aPresContext
)
{
PresShell
*
presShell
=
aPresContext
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
false
;
}
return
presShell
-
>
FontSizeInflationEnabled
(
)
;
}
nsRect
nsLayoutUtils
:
:
GetBoxShadowRectForFrame
(
nsIFrame
*
aFrame
const
nsSize
&
aFrameSize
)
{
auto
boxShadows
=
aFrame
-
>
StyleEffects
(
)
-
>
mBoxShadow
.
AsSpan
(
)
;
if
(
boxShadows
.
IsEmpty
(
)
)
{
return
nsRect
(
)
;
}
nsRect
inputRect
(
nsPoint
(
0
0
)
aFrameSize
)
;
const
nsStyleDisplay
*
styleDisplay
=
aFrame
-
>
StyleDisplay
(
)
;
nsITheme
:
:
Transparency
transparency
;
if
(
aFrame
-
>
IsThemed
(
styleDisplay
&
transparency
)
)
{
if
(
transparency
!
=
nsITheme
:
:
eOpaque
)
{
nsPresContext
*
presContext
=
aFrame
-
>
PresContext
(
)
;
presContext
-
>
Theme
(
)
-
>
GetWidgetOverflow
(
presContext
-
>
DeviceContext
(
)
aFrame
styleDisplay
-
>
EffectiveAppearance
(
)
&
inputRect
)
;
}
}
nsRect
shadows
;
int32_t
A2D
=
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
for
(
auto
&
shadow
:
boxShadows
)
{
nsRect
tmpRect
=
inputRect
;
if
(
shadow
.
inset
)
{
continue
;
}
tmpRect
.
MoveBy
(
nsPoint
(
shadow
.
base
.
horizontal
.
ToAppUnits
(
)
shadow
.
base
.
vertical
.
ToAppUnits
(
)
)
)
;
tmpRect
.
Inflate
(
shadow
.
spread
.
ToAppUnits
(
)
)
;
tmpRect
.
Inflate
(
nsContextBoxBlur
:
:
GetBlurRadiusMargin
(
shadow
.
base
.
blur
.
ToAppUnits
(
)
A2D
)
)
;
shadows
.
UnionRect
(
shadows
tmpRect
)
;
}
return
shadows
;
}
bool
nsLayoutUtils
:
:
GetContentViewerSize
(
const
nsPresContext
*
aPresContext
LayoutDeviceIntSize
&
aOutSize
SubtractDynamicToolbar
aSubtractDynamicToolbar
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
=
aPresContext
-
>
GetDocShell
(
)
;
if
(
!
docShell
)
{
return
false
;
}
nsCOMPtr
<
nsIContentViewer
>
cv
;
docShell
-
>
GetContentViewer
(
getter_AddRefs
(
cv
)
)
;
if
(
!
cv
)
{
return
false
;
}
nsIntRect
bounds
;
cv
-
>
GetBounds
(
bounds
)
;
if
(
aPresContext
-
>
IsRootContentDocumentCrossProcess
(
)
&
&
aSubtractDynamicToolbar
=
=
SubtractDynamicToolbar
:
:
Yes
&
&
aPresContext
-
>
HasDynamicToolbar
(
)
&
&
!
bounds
.
IsEmpty
(
)
)
{
MOZ_ASSERT
(
aPresContext
-
>
IsRootContentDocumentCrossProcess
(
)
)
;
bounds
.
height
-
=
aPresContext
-
>
GetDynamicToolbarMaxHeight
(
)
;
if
(
bounds
.
height
<
0
)
{
bounds
.
height
=
0
;
}
}
aOutSize
=
LayoutDeviceIntRect
:
:
FromUnknownRect
(
bounds
)
.
Size
(
)
;
return
true
;
}
bool
nsLayoutUtils
:
:
UpdateCompositionBoundsForRCDRSF
(
ParentLayerRect
&
aCompBounds
const
nsPresContext
*
aPresContext
)
{
SubtractDynamicToolbar
shouldSubtractDynamicToolbar
=
SubtractDynamicToolbar
:
:
Yes
;
if
(
RefPtr
<
MobileViewportManager
>
MVM
=
aPresContext
-
>
PresShell
(
)
-
>
GetMobileViewportManager
(
)
)
{
CSSSize
intrinsicCompositionSize
=
MVM
-
>
GetIntrinsicCompositionSize
(
)
;
if
(
nsIScrollableFrame
*
rootScrollableFrame
=
aPresContext
-
>
PresShell
(
)
-
>
GetRootScrollFrameAsScrollable
(
)
)
{
if
(
intrinsicCompositionSize
.
height
<
CSSPixel
:
:
FromAppUnits
(
CalculateScrollableRectForFrame
(
rootScrollableFrame
nullptr
)
.
Height
(
)
)
)
{
shouldSubtractDynamicToolbar
=
SubtractDynamicToolbar
:
:
No
;
}
}
}
LayoutDeviceIntSize
contentSize
;
if
(
!
GetContentViewerSize
(
aPresContext
contentSize
shouldSubtractDynamicToolbar
)
)
{
return
false
;
}
aCompBounds
.
SizeTo
(
ViewAs
<
ParentLayerPixel
>
(
LayoutDeviceSize
(
contentSize
)
PixelCastJustification
:
:
LayoutDeviceIsParentLayerForRCDRSF
)
)
;
return
true
;
}
nsMargin
nsLayoutUtils
:
:
ScrollbarAreaToExcludeFromCompositionBoundsFor
(
const
nsIFrame
*
aScrollFrame
)
{
if
(
!
aScrollFrame
|
|
!
aScrollFrame
-
>
GetScrollTargetFrame
(
)
)
{
return
nsMargin
(
)
;
}
nsPresContext
*
presContext
=
aScrollFrame
-
>
PresContext
(
)
;
PresShell
*
presShell
=
presContext
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
nsMargin
(
)
;
}
bool
isRootScrollFrame
=
aScrollFrame
=
=
presShell
-
>
GetRootScrollFrame
(
)
;
bool
isRootContentDocRootScrollFrame
=
isRootScrollFrame
&
&
presContext
-
>
IsRootContentDocument
(
)
;
if
(
!
isRootContentDocRootScrollFrame
)
{
return
nsMargin
(
)
;
}
if
(
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
IntID
:
:
UseOverlayScrollbars
)
)
{
return
nsMargin
(
)
;
}
nsIScrollableFrame
*
scrollableFrame
=
aScrollFrame
-
>
GetScrollTargetFrame
(
)
;
if
(
!
scrollableFrame
)
{
return
nsMargin
(
)
;
}
return
scrollableFrame
-
>
GetActualScrollbarSizes
(
nsIScrollableFrame
:
:
ScrollbarSizesOptions
:
:
INCLUDE_VISUAL_VIEWPORT_SCROLLBARS
)
;
}
nsSize
nsLayoutUtils
:
:
CalculateCompositionSizeForFrame
(
nsIFrame
*
aFrame
bool
aSubtractScrollbars
const
nsSize
*
aOverrideScrollPortSize
)
{
nsIScrollableFrame
*
scrollableFrame
=
aFrame
-
>
GetScrollTargetFrame
(
)
;
nsRect
rect
=
scrollableFrame
?
scrollableFrame
-
>
GetScrollPortRect
(
)
:
aFrame
-
>
GetRect
(
)
;
nsSize
size
=
aOverrideScrollPortSize
?
*
aOverrideScrollPortSize
:
rect
.
Size
(
)
;
nsPresContext
*
presContext
=
aFrame
-
>
PresContext
(
)
;
PresShell
*
presShell
=
presContext
-
>
PresShell
(
)
;
bool
isRootContentDocRootScrollFrame
=
presContext
-
>
IsRootContentDocumentCrossProcess
(
)
&
&
aFrame
=
=
presShell
-
>
GetRootScrollFrame
(
)
;
if
(
isRootContentDocRootScrollFrame
)
{
ParentLayerRect
compBounds
;
if
(
UpdateCompositionBoundsForRCDRSF
(
compBounds
presContext
)
)
{
int32_t
auPerDevPixel
=
presContext
-
>
AppUnitsPerDevPixel
(
)
;
size
=
nsSize
(
compBounds
.
width
*
auPerDevPixel
compBounds
.
height
*
auPerDevPixel
)
;
}
}
if
(
aSubtractScrollbars
)
{
nsMargin
margins
=
ScrollbarAreaToExcludeFromCompositionBoundsFor
(
aFrame
)
;
size
.
width
-
=
margins
.
LeftRight
(
)
;
size
.
height
-
=
margins
.
TopBottom
(
)
;
}
return
size
;
}
CSSSize
nsLayoutUtils
:
:
CalculateRootCompositionSize
(
const
nsIFrame
*
aFrame
bool
aIsRootContentDocRootScrollFrame
const
FrameMetrics
&
aMetrics
)
{
if
(
aIsRootContentDocRootScrollFrame
)
{
return
ViewAs
<
LayerPixel
>
(
aMetrics
.
GetCompositionBounds
(
)
.
Size
(
)
PixelCastJustification
:
:
ParentLayerToLayerForRootComposition
)
*
LayerToScreenScale
(
1
.
0f
)
/
aMetrics
.
DisplayportPixelsPerCSSPixel
(
)
;
}
nsPresContext
*
presContext
=
aFrame
-
>
PresContext
(
)
;
ScreenSize
rootCompositionSize
;
nsPresContext
*
rootPresContext
=
presContext
-
>
GetInProcessRootContentDocumentPresContext
(
)
;
if
(
!
rootPresContext
)
{
rootPresContext
=
presContext
-
>
GetRootPresContext
(
)
;
}
PresShell
*
rootPresShell
=
nullptr
;
if
(
rootPresContext
)
{
rootPresShell
=
rootPresContext
-
>
PresShell
(
)
;
if
(
nsIFrame
*
rootFrame
=
rootPresShell
-
>
GetRootFrame
(
)
)
{
LayoutDeviceToLayerScale2D
cumulativeResolution
(
rootPresShell
-
>
GetCumulativeResolution
(
)
*
nsLayoutUtils
:
:
GetTransformToAncestorScale
(
rootFrame
)
)
;
ParentLayerRect
compBounds
;
if
(
UpdateCompositionBoundsForRCDRSF
(
compBounds
rootPresContext
)
)
{
rootCompositionSize
=
ViewAs
<
ScreenPixel
>
(
compBounds
.
Size
(
)
PixelCastJustification
:
:
ScreenIsParentLayerForRoot
)
;
}
else
{
int32_t
rootAUPerDevPixel
=
rootPresContext
-
>
AppUnitsPerDevPixel
(
)
;
LayerSize
frameSize
=
(
LayoutDeviceRect
:
:
FromAppUnits
(
rootFrame
-
>
GetRect
(
)
rootAUPerDevPixel
)
*
cumulativeResolution
)
.
Size
(
)
;
rootCompositionSize
=
frameSize
*
LayerToScreenScale
(
1
.
0f
)
;
}
}
}
else
{
nsIWidget
*
widget
=
aFrame
-
>
GetNearestWidget
(
)
;
LayoutDeviceIntRect
widgetBounds
=
widget
-
>
GetBounds
(
)
;
rootCompositionSize
=
ScreenSize
(
ViewAs
<
ScreenPixel
>
(
widgetBounds
.
Size
(
)
PixelCastJustification
:
:
LayoutDeviceIsScreenForBounds
)
)
;
}
nsIFrame
*
rootRootScrollFrame
=
rootPresShell
?
rootPresShell
-
>
GetRootScrollFrame
(
)
:
nullptr
;
nsMargin
scrollbarMargins
=
ScrollbarAreaToExcludeFromCompositionBoundsFor
(
rootRootScrollFrame
)
;
LayoutDeviceMargin
margins
=
LayoutDeviceMargin
:
:
FromAppUnits
(
scrollbarMargins
rootPresContext
-
>
AppUnitsPerDevPixel
(
)
)
;
rootCompositionSize
.
width
-
=
margins
.
LeftRight
(
)
;
rootCompositionSize
.
height
-
=
margins
.
TopBottom
(
)
;
return
rootCompositionSize
/
aMetrics
.
DisplayportPixelsPerCSSPixel
(
)
;
}
nsRect
nsLayoutUtils
:
:
CalculateScrollableRectForFrame
(
const
nsIScrollableFrame
*
aScrollableFrame
const
nsIFrame
*
aRootFrame
)
{
nsRect
contentBounds
;
if
(
aScrollableFrame
)
{
contentBounds
=
aScrollableFrame
-
>
GetScrollRange
(
)
;
nsPoint
scrollPosition
=
aScrollableFrame
-
>
GetScrollPosition
(
)
;
if
(
aScrollableFrame
-
>
GetScrollStyles
(
)
.
mVertical
=
=
StyleOverflow
:
:
Hidden
)
{
contentBounds
.
y
=
scrollPosition
.
y
;
contentBounds
.
height
=
0
;
}
if
(
aScrollableFrame
-
>
GetScrollStyles
(
)
.
mHorizontal
=
=
StyleOverflow
:
:
Hidden
)
{
contentBounds
.
x
=
scrollPosition
.
x
;
contentBounds
.
width
=
0
;
}
contentBounds
.
width
+
=
aScrollableFrame
-
>
GetScrollPortRect
(
)
.
width
;
contentBounds
.
height
+
=
aScrollableFrame
-
>
GetScrollPortRect
(
)
.
height
;
}
else
{
contentBounds
=
aRootFrame
-
>
GetRect
(
)
;
contentBounds
.
MoveTo
(
0
0
)
;
}
return
contentBounds
;
}
nsRect
nsLayoutUtils
:
:
CalculateExpandedScrollableRect
(
nsIFrame
*
aFrame
)
{
nsRect
scrollableRect
=
CalculateScrollableRectForFrame
(
aFrame
-
>
GetScrollTargetFrame
(
)
aFrame
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
)
;
nsSize
compSize
=
CalculateCompositionSizeForFrame
(
aFrame
)
;
if
(
aFrame
=
=
aFrame
-
>
PresShell
(
)
-
>
GetRootScrollFrame
(
)
)
{
float
res
=
aFrame
-
>
PresShell
(
)
-
>
GetResolution
(
)
;
compSize
.
width
=
NSToCoordRound
(
compSize
.
width
/
res
)
;
compSize
.
height
=
NSToCoordRound
(
compSize
.
height
/
res
)
;
}
if
(
scrollableRect
.
width
<
compSize
.
width
)
{
scrollableRect
.
x
=
std
:
:
max
(
0
scrollableRect
.
x
-
(
compSize
.
width
-
scrollableRect
.
width
)
)
;
scrollableRect
.
width
=
compSize
.
width
;
}
if
(
scrollableRect
.
height
<
compSize
.
height
)
{
scrollableRect
.
y
=
std
:
:
max
(
0
scrollableRect
.
y
-
(
compSize
.
height
-
scrollableRect
.
height
)
)
;
scrollableRect
.
height
=
compSize
.
height
;
}
return
scrollableRect
;
}
void
nsLayoutUtils
:
:
DoLogTestDataForPaint
(
LayerManager
*
aManager
ViewID
aScrollId
const
std
:
:
string
&
aKey
const
std
:
:
string
&
aValue
)
{
MOZ_ASSERT
(
nsLayoutUtils
:
:
IsAPZTestLoggingEnabled
(
)
"
don
'
t
call
me
"
)
;
if
(
ClientLayerManager
*
mgr
=
aManager
-
>
AsClientLayerManager
(
)
)
{
mgr
-
>
LogTestDataForCurrentPaint
(
aScrollId
aKey
aValue
)
;
}
else
if
(
WebRenderLayerManager
*
wrlm
=
aManager
-
>
AsWebRenderLayerManager
(
)
)
{
wrlm
-
>
LogTestDataForCurrentPaint
(
aScrollId
aKey
aValue
)
;
}
}
void
nsLayoutUtils
:
:
LogAdditionalTestData
(
nsDisplayListBuilder
*
aBuilder
const
std
:
:
string
&
aKey
const
std
:
:
string
&
aValue
)
{
LayerManager
*
manager
=
aBuilder
-
>
GetWidgetLayerManager
(
nullptr
)
;
if
(
!
manager
)
{
return
;
}
if
(
ClientLayerManager
*
clm
=
manager
-
>
AsClientLayerManager
(
)
)
{
clm
-
>
LogAdditionalTestData
(
aKey
aValue
)
;
}
else
if
(
WebRenderLayerManager
*
wrlm
=
manager
-
>
AsWebRenderLayerManager
(
)
)
{
wrlm
-
>
LogAdditionalTestData
(
aKey
aValue
)
;
}
}
bool
nsLayoutUtils
:
:
IsAPZTestLoggingEnabled
(
)
{
return
StaticPrefs
:
:
apz_test_logging_enabled
(
)
;
}
SurfaceFromElementResult
:
:
SurfaceFromElementResult
(
)
:
mHadCrossOriginRedirects
(
false
)
mIsWriteOnly
(
true
)
mIsStillLoading
(
false
)
mHasSize
(
false
)
mCORSUsed
(
false
)
mAlphaType
(
gfxAlphaType
:
:
Opaque
)
{
}
const
RefPtr
<
mozilla
:
:
gfx
:
:
SourceSurface
>
&
SurfaceFromElementResult
:
:
GetSourceSurface
(
)
{
if
(
!
mSourceSurface
&
&
mLayersImage
)
{
mSourceSurface
=
mLayersImage
-
>
GetAsSourceSurface
(
)
;
}
return
mSourceSurface
;
}
bool
nsLayoutUtils
:
:
IsNonWrapperBlock
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
)
;
return
aFrame
-
>
IsBlockFrameOrSubclass
(
)
&
&
!
aFrame
-
>
IsBlockWrapper
(
)
;
}
bool
nsLayoutUtils
:
:
NeedsPrintPreviewBackground
(
nsPresContext
*
aPresContext
)
{
return
aPresContext
-
>
IsRootPaginatedDocument
(
)
&
&
(
aPresContext
-
>
Type
(
)
=
=
nsPresContext
:
:
eContext_PrintPreview
|
|
aPresContext
-
>
Type
(
)
=
=
nsPresContext
:
:
eContext_PageLayout
)
;
}
AutoMaybeDisableFontInflation
:
:
AutoMaybeDisableFontInflation
(
nsIFrame
*
aFrame
)
{
if
(
aFrame
-
>
IsContainerForFontSizeInflation
(
)
&
&
!
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eMathML
)
)
{
mPresContext
=
aFrame
-
>
PresContext
(
)
;
mOldValue
=
mPresContext
-
>
mInflationDisabledForShrinkWrap
;
mPresContext
-
>
mInflationDisabledForShrinkWrap
=
true
;
}
else
{
mPresContext
=
nullptr
;
mOldValue
=
false
;
}
}
AutoMaybeDisableFontInflation
:
:
~
AutoMaybeDisableFontInflation
(
)
{
if
(
mPresContext
)
{
mPresContext
-
>
mInflationDisabledForShrinkWrap
=
mOldValue
;
}
}
namespace
mozilla
{
Rect
NSRectToRect
(
const
nsRect
&
aRect
double
aAppUnitsPerPixel
)
{
return
Rect
(
Float
(
aRect
.
x
/
aAppUnitsPerPixel
)
Float
(
aRect
.
y
/
aAppUnitsPerPixel
)
Float
(
aRect
.
width
/
aAppUnitsPerPixel
)
Float
(
aRect
.
height
/
aAppUnitsPerPixel
)
)
;
}
Rect
NSRectToSnappedRect
(
const
nsRect
&
aRect
double
aAppUnitsPerPixel
const
gfx
:
:
DrawTarget
&
aSnapDT
)
{
Rect
rect
(
Float
(
aRect
.
x
/
aAppUnitsPerPixel
)
Float
(
aRect
.
y
/
aAppUnitsPerPixel
)
Float
(
aRect
.
width
/
aAppUnitsPerPixel
)
Float
(
aRect
.
height
/
aAppUnitsPerPixel
)
)
;
MaybeSnapToDevicePixels
(
rect
aSnapDT
true
)
;
return
rect
;
}
Rect
NSRectToNonEmptySnappedRect
(
const
nsRect
&
aRect
double
aAppUnitsPerPixel
const
gfx
:
:
DrawTarget
&
aSnapDT
)
{
Rect
rect
(
Float
(
aRect
.
x
/
aAppUnitsPerPixel
)
Float
(
aRect
.
y
/
aAppUnitsPerPixel
)
Float
(
aRect
.
width
/
aAppUnitsPerPixel
)
Float
(
aRect
.
height
/
aAppUnitsPerPixel
)
)
;
MaybeSnapToDevicePixels
(
rect
aSnapDT
true
false
)
;
return
rect
;
}
void
StrokeLineWithSnapping
(
const
nsPoint
&
aP1
const
nsPoint
&
aP2
int32_t
aAppUnitsPerDevPixel
DrawTarget
&
aDrawTarget
const
Pattern
&
aPattern
const
StrokeOptions
&
aStrokeOptions
const
DrawOptions
&
aDrawOptions
)
{
Point
p1
=
NSPointToPoint
(
aP1
aAppUnitsPerDevPixel
)
;
Point
p2
=
NSPointToPoint
(
aP2
aAppUnitsPerDevPixel
)
;
SnapLineToDevicePixelsForStroking
(
p1
p2
aDrawTarget
aStrokeOptions
.
mLineWidth
)
;
aDrawTarget
.
StrokeLine
(
p1
p2
aPattern
aStrokeOptions
aDrawOptions
)
;
}
namespace
layout
{
void
MaybeSetupTransactionIdAllocator
(
layers
:
:
LayerManager
*
aManager
nsPresContext
*
aPresContext
)
{
auto
backendType
=
aManager
-
>
GetBackendType
(
)
;
if
(
backendType
=
=
LayersBackend
:
:
LAYERS_CLIENT
|
|
backendType
=
=
LayersBackend
:
:
LAYERS_WR
)
{
aManager
-
>
SetTransactionIdAllocator
(
aPresContext
-
>
RefreshDriver
(
)
)
;
}
}
}
}
void
nsLayoutUtils
:
:
SetBSizeFromFontMetrics
(
const
nsIFrame
*
aFrame
ReflowOutput
&
aMetrics
const
LogicalMargin
&
aFramePadding
WritingMode
aLineWM
WritingMode
aFrameWM
)
{
RefPtr
<
nsFontMetrics
>
fm
=
nsLayoutUtils
:
:
GetInflatedFontMetricsForFrame
(
aFrame
)
;
if
(
fm
)
{
aMetrics
.
SetBlockStartAscent
(
aLineWM
.
IsLineInverted
(
)
?
fm
-
>
MaxDescent
(
)
:
fm
-
>
MaxAscent
(
)
)
;
aMetrics
.
BSize
(
aLineWM
)
=
fm
-
>
MaxHeight
(
)
;
}
else
{
NS_WARNING
(
"
Cannot
get
font
metrics
-
defaulting
sizes
to
0
"
)
;
aMetrics
.
SetBlockStartAscent
(
aMetrics
.
BSize
(
aLineWM
)
=
0
)
;
}
aMetrics
.
SetBlockStartAscent
(
aMetrics
.
BlockStartAscent
(
)
+
aFramePadding
.
BStart
(
aFrameWM
)
)
;
aMetrics
.
BSize
(
aLineWM
)
+
=
aFramePadding
.
BStartEnd
(
aFrameWM
)
;
}
bool
nsLayoutUtils
:
:
HasDocumentLevelListenersForApzAwareEvents
(
PresShell
*
aPresShell
)
{
if
(
Document
*
doc
=
aPresShell
-
>
GetDocument
(
)
)
{
WidgetEvent
event
(
true
eVoidEvent
)
;
nsTArray
<
EventTarget
*
>
targets
;
nsresult
rv
=
EventDispatcher
:
:
Dispatch
(
ToSupports
(
doc
)
nullptr
&
event
nullptr
nullptr
nullptr
&
targets
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
for
(
size_t
i
=
0
;
i
<
targets
.
Length
(
)
;
i
+
+
)
{
if
(
targets
[
i
]
-
>
IsApzAware
(
)
)
{
return
true
;
}
}
}
return
false
;
}
bool
nsLayoutUtils
:
:
CanScrollOriginClobberApz
(
ScrollOrigin
aScrollOrigin
)
{
switch
(
aScrollOrigin
)
{
case
ScrollOrigin
:
:
None
:
case
ScrollOrigin
:
:
NotSpecified
:
case
ScrollOrigin
:
:
Apz
:
case
ScrollOrigin
:
:
Restore
:
return
false
;
default
:
return
true
;
}
}
ScrollMetadata
nsLayoutUtils
:
:
ComputeScrollMetadata
(
const
nsIFrame
*
aForFrame
const
nsIFrame
*
aScrollFrame
nsIContent
*
aContent
const
nsIFrame
*
aReferenceFrame
LayerManager
*
aLayerManager
ViewID
aScrollParentId
const
nsSize
&
aScrollPortSize
const
Maybe
<
nsRect
>
&
aClipRect
bool
aIsRootContent
const
Maybe
<
ContainerLayerParameters
>
&
aContainerParameters
)
{
const
nsPresContext
*
presContext
=
aForFrame
-
>
PresContext
(
)
;
int32_t
auPerDevPixel
=
presContext
-
>
AppUnitsPerDevPixel
(
)
;
PresShell
*
presShell
=
presContext
-
>
GetPresShell
(
)
;
ScrollMetadata
metadata
;
FrameMetrics
&
metrics
=
metadata
.
GetMetrics
(
)
;
metrics
.
SetLayoutViewport
(
CSSRect
(
CSSPoint
(
)
CSSSize
:
:
FromAppUnits
(
aScrollPortSize
)
)
)
;
nsIDocShell
*
docShell
=
presContext
-
>
GetDocShell
(
)
;
const
BrowsingContext
*
bc
=
docShell
?
docShell
-
>
GetBrowsingContext
(
)
:
nullptr
;
bool
isTouchEventsEnabled
=
bc
&
&
bc
-
>
TouchEventsOverride
(
)
=
=
mozilla
:
:
dom
:
:
TouchEventsOverride
:
:
Enabled
;
if
(
bc
&
&
bc
-
>
InRDMPane
(
)
&
&
isTouchEventsEnabled
)
{
metadata
.
SetIsRDMTouchSimulationActive
(
true
)
;
}
ViewID
scrollId
=
ScrollableLayerGuid
:
:
NULL_SCROLL_ID
;
if
(
aContent
)
{
if
(
void
*
paintRequestTime
=
aContent
-
>
GetProperty
(
nsGkAtoms
:
:
paintRequestTime
)
)
{
metrics
.
SetPaintRequestTime
(
*
static_cast
<
TimeStamp
*
>
(
paintRequestTime
)
)
;
aContent
-
>
RemoveProperty
(
nsGkAtoms
:
:
paintRequestTime
)
;
}
scrollId
=
nsLayoutUtils
:
:
FindOrCreateIDFor
(
aContent
)
;
nsRect
dp
;
if
(
DisplayPortUtils
:
:
GetDisplayPort
(
aContent
&
dp
)
)
{
metrics
.
SetDisplayPort
(
CSSRect
:
:
FromAppUnits
(
dp
)
)
;
DisplayPortUtils
:
:
MarkDisplayPortAsPainted
(
aContent
)
;
}
if
(
DisplayPortUtils
:
:
GetCriticalDisplayPort
(
aContent
&
dp
)
)
{
metrics
.
SetCriticalDisplayPort
(
CSSRect
:
:
FromAppUnits
(
dp
)
)
;
}
if
(
IsAPZTestLoggingEnabled
(
)
)
{
LogTestDataForPaint
(
aLayerManager
scrollId
"
displayport
"
StaticPrefs
:
:
layers_low_precision_buffer
(
)
?
metrics
.
GetCriticalDisplayPort
(
)
:
metrics
.
GetDisplayPort
(
)
)
;
}
}
const
nsIScrollableFrame
*
scrollableFrame
=
nullptr
;
if
(
aScrollFrame
)
scrollableFrame
=
aScrollFrame
-
>
GetScrollTargetFrame
(
)
;
metrics
.
SetScrollableRect
(
CSSRect
:
:
FromAppUnits
(
nsLayoutUtils
:
:
CalculateScrollableRectForFrame
(
scrollableFrame
aForFrame
)
)
)
;
if
(
scrollableFrame
)
{
CSSPoint
layoutScrollOffset
=
CSSPoint
:
:
FromAppUnits
(
scrollableFrame
-
>
GetScrollPosition
(
)
)
;
CSSPoint
visualScrollOffset
=
aIsRootContent
&
&
presShell
-
>
IsVisualViewportOffsetSet
(
)
?
CSSPoint
:
:
FromAppUnits
(
presShell
-
>
GetVisualViewportOffset
(
)
)
:
layoutScrollOffset
;
metrics
.
SetVisualScrollOffset
(
visualScrollOffset
)
;
metrics
.
SetVisualDestination
(
visualScrollOffset
)
;
if
(
aIsRootContent
)
{
if
(
aLayerManager
-
>
GetIsFirstPaint
(
)
&
&
presShell
-
>
IsVisualViewportOffsetSet
(
)
)
{
presShell
-
>
ScrollToVisual
(
presShell
-
>
GetVisualViewportOffset
(
)
FrameMetrics
:
:
eRestore
ScrollMode
:
:
Instant
)
;
}
}
if
(
scrollableFrame
-
>
IsRootScrollFrameOfDocument
(
)
)
{
if
(
const
Maybe
<
PresShell
:
:
VisualScrollUpdate
>
&
visualUpdate
=
presShell
-
>
GetPendingVisualScrollUpdate
(
)
)
{
metrics
.
SetVisualDestination
(
CSSPoint
:
:
FromAppUnits
(
visualUpdate
-
>
mVisualScrollOffset
)
)
;
metrics
.
SetVisualScrollUpdateType
(
visualUpdate
-
>
mUpdateType
)
;
presShell
-
>
AcknowledgePendingVisualScrollUpdate
(
)
;
}
}
if
(
aIsRootContent
)
{
if
(
presContext
-
>
HasDynamicToolbar
(
)
)
{
CSSRect
viewport
=
metrics
.
GetLayoutViewport
(
)
;
viewport
.
SizeTo
(
nsLayoutUtils
:
:
ExpandHeightForDynamicToolbar
(
presContext
viewport
.
Size
(
)
)
)
;
metrics
.
SetLayoutViewport
(
viewport
)
;
if
(
presContext
-
>
GetDynamicToolbarState
(
)
=
=
DynamicToolbarState
:
:
Collapsed
)
{
metrics
.
SetFixedLayerMargins
(
ScreenMargin
(
0
0
presContext
-
>
GetDynamicToolbarHeight
(
)
-
presContext
-
>
GetDynamicToolbarMaxHeight
(
)
0
)
)
;
}
}
}
metrics
.
SetScrollGeneration
(
scrollableFrame
-
>
CurrentScrollGeneration
(
)
)
;
CSSRect
viewport
=
metrics
.
GetLayoutViewport
(
)
;
viewport
.
MoveTo
(
layoutScrollOffset
)
;
metrics
.
SetLayoutViewport
(
viewport
)
;
nsSize
lineScrollAmount
=
scrollableFrame
-
>
GetLineScrollAmount
(
)
;
LayoutDeviceIntSize
lineScrollAmountInDevPixels
=
LayoutDeviceIntSize
:
:
FromAppUnitsRounded
(
lineScrollAmount
presContext
-
>
AppUnitsPerDevPixel
(
)
)
;
metadata
.
SetLineScrollAmount
(
lineScrollAmountInDevPixels
)
;
nsSize
pageScrollAmount
=
scrollableFrame
-
>
GetPageScrollAmount
(
)
;
LayoutDeviceIntSize
pageScrollAmountInDevPixels
=
LayoutDeviceIntSize
:
:
FromAppUnitsRounded
(
pageScrollAmount
presContext
-
>
AppUnitsPerDevPixel
(
)
)
;
metadata
.
SetPageScrollAmount
(
pageScrollAmountInDevPixels
)
;
if
(
aScrollFrame
-
>
GetParent
(
)
)
{
metadata
.
SetDisregardedDirection
(
WheelHandlingUtils
:
:
GetDisregardedWheelScrollDirection
(
aScrollFrame
-
>
GetParent
(
)
)
)
;
}
metadata
.
SetSnapInfo
(
scrollableFrame
-
>
GetScrollSnapInfo
(
)
)
;
metadata
.
SetOverscrollBehavior
(
scrollableFrame
-
>
GetOverscrollBehaviorInfo
(
)
)
;
metadata
.
SetScrollUpdates
(
scrollableFrame
-
>
GetScrollUpdates
(
)
)
;
}
MOZ_ASSERT
(
aScrollParentId
=
=
ScrollableLayerGuid
:
:
NULL_SCROLL_ID
|
|
scrollId
!
=
aScrollParentId
)
;
metrics
.
SetScrollId
(
scrollId
)
;
metrics
.
SetIsRootContent
(
aIsRootContent
)
;
metadata
.
SetScrollParentId
(
aScrollParentId
)
;
const
nsIFrame
*
rootScrollFrame
=
presShell
-
>
GetRootScrollFrame
(
)
;
bool
isRootScrollFrame
=
aScrollFrame
=
=
rootScrollFrame
;
Document
*
document
=
presShell
-
>
GetDocument
(
)
;
if
(
scrollId
!
=
ScrollableLayerGuid
:
:
NULL_SCROLL_ID
&
&
!
presContext
-
>
GetParentPresContext
(
)
)
{
if
(
(
aScrollFrame
&
&
isRootScrollFrame
)
)
{
metadata
.
SetIsLayersIdRoot
(
true
)
;
}
else
{
MOZ_ASSERT
(
document
"
A
non
-
root
-
scroll
frame
must
be
in
a
document
"
)
;
if
(
aContent
=
=
document
-
>
GetDocumentElement
(
)
)
{
metadata
.
SetIsLayersIdRoot
(
true
)
;
}
}
}
const
Element
*
bodyElement
=
document
?
document
-
>
GetBodyElement
(
)
:
nullptr
;
const
nsIFrame
*
primaryFrame
=
bodyElement
?
bodyElement
-
>
GetPrimaryFrame
(
)
:
rootScrollFrame
;
if
(
!
primaryFrame
)
{
primaryFrame
=
rootScrollFrame
;
}
if
(
primaryFrame
)
{
WritingMode
writingModeOfRootScrollFrame
=
primaryFrame
-
>
GetWritingMode
(
)
;
WritingMode
:
:
BlockDir
blockDirOfRootScrollFrame
=
writingModeOfRootScrollFrame
.
GetBlockDir
(
)
;
WritingMode
:
:
InlineDir
inlineDirOfRootScrollFrame
=
writingModeOfRootScrollFrame
.
GetInlineDir
(
)
;
if
(
blockDirOfRootScrollFrame
=
=
WritingMode
:
:
BlockDir
:
:
eBlockRL
|
|
(
blockDirOfRootScrollFrame
=
=
WritingMode
:
:
BlockDir
:
:
eBlockTB
&
&
inlineDirOfRootScrollFrame
=
=
WritingMode
:
:
InlineDir
:
:
eInlineRTL
)
)
{
metadata
.
SetIsAutoDirRootContentRTL
(
true
)
;
}
}
if
(
isRootScrollFrame
)
{
metrics
.
SetPresShellResolution
(
presShell
-
>
GetResolution
(
)
)
;
}
else
{
metrics
.
SetPresShellResolution
(
1
.
0f
)
;
}
if
(
presShell
-
>
IsResolutionUpdated
(
)
)
{
metadata
.
SetResolutionUpdated
(
true
)
;
}
metrics
.
SetCumulativeResolution
(
aContainerParameters
?
aContainerParameters
-
>
Scale
(
)
:
LayoutDeviceToLayerScale2D
(
LayoutDeviceToLayerScale
(
presShell
-
>
GetCumulativeResolution
(
)
)
)
)
;
LayoutDeviceToScreenScale2D
resolutionToScreen
(
presShell
-
>
GetCumulativeResolution
(
)
*
nsLayoutUtils
:
:
GetTransformToAncestorScale
(
aScrollFrame
?
aScrollFrame
:
aForFrame
)
)
;
metrics
.
SetExtraResolution
(
metrics
.
GetCumulativeResolution
(
)
/
resolutionToScreen
)
;
metrics
.
SetDevPixelsPerCSSPixel
(
presContext
-
>
CSSToDevPixelScale
(
)
)
;
const
LayerToParentLayerScale
layerToParentLayerScale
(
1
.
0f
)
;
metrics
.
SetZoom
(
metrics
.
GetCumulativeResolution
(
)
*
metrics
.
GetDevPixelsPerCSSPixel
(
)
*
layerToParentLayerScale
)
;
const
nsIFrame
*
frameForCompositionBoundsCalculation
=
aScrollFrame
?
aScrollFrame
:
aForFrame
;
nsRect
compositionBounds
(
frameForCompositionBoundsCalculation
-
>
GetOffsetToCrossDoc
(
aReferenceFrame
)
frameForCompositionBoundsCalculation
-
>
GetSize
(
)
)
;
if
(
scrollableFrame
)
{
nsRect
scrollPort
=
scrollableFrame
-
>
GetScrollPortRect
(
)
;
compositionBounds
=
nsRect
(
compositionBounds
.
TopLeft
(
)
+
scrollPort
.
TopLeft
(
)
scrollPort
.
Size
(
)
)
;
}
ParentLayerRect
frameBounds
=
LayoutDeviceRect
:
:
FromAppUnits
(
compositionBounds
auPerDevPixel
)
*
metrics
.
GetCumulativeResolution
(
)
*
layerToParentLayerScale
;
if
(
aClipRect
)
{
ParentLayerRect
rect
=
LayoutDeviceRect
:
:
FromAppUnits
(
*
aClipRect
auPerDevPixel
)
*
metrics
.
GetCumulativeResolution
(
)
*
layerToParentLayerScale
;
metadata
.
SetScrollClip
(
Some
(
LayerClip
(
RoundedToInt
(
rect
)
)
)
)
;
}
bool
isRootContentDocRootScrollFrame
=
isRootScrollFrame
&
&
presContext
-
>
IsRootContentDocumentCrossProcess
(
)
;
if
(
isRootContentDocRootScrollFrame
)
{
UpdateCompositionBoundsForRCDRSF
(
frameBounds
presContext
)
;
if
(
RefPtr
<
MobileViewportManager
>
MVM
=
presContext
-
>
PresShell
(
)
-
>
GetMobileViewportManager
(
)
)
{
metrics
.
SetCompositionSizeWithoutDynamicToolbar
(
MVM
-
>
GetCompositionSizeWithoutDynamicToolbar
(
)
)
;
}
}
nsMargin
sizes
=
ScrollbarAreaToExcludeFromCompositionBoundsFor
(
aScrollFrame
)
;
ParentLayerMargin
boundMargins
=
LayoutDeviceMargin
:
:
FromAppUnits
(
sizes
auPerDevPixel
)
*
LayoutDeviceToParentLayerScale
(
1
.
0f
)
;
frameBounds
.
Deflate
(
boundMargins
)
;
metrics
.
SetCompositionBounds
(
frameBounds
)
;
metrics
.
SetRootCompositionSize
(
nsLayoutUtils
:
:
CalculateRootCompositionSize
(
aScrollFrame
?
aScrollFrame
:
aForFrame
isRootContentDocRootScrollFrame
metrics
)
)
;
if
(
StaticPrefs
:
:
apz_printtree
(
)
|
|
StaticPrefs
:
:
apz_test_logging_enabled
(
)
)
{
if
(
const
nsIContent
*
content
=
frameForCompositionBoundsCalculation
-
>
GetContent
(
)
)
{
nsAutoString
contentDescription
;
if
(
content
-
>
IsElement
(
)
)
{
content
-
>
AsElement
(
)
-
>
Describe
(
contentDescription
)
;
}
else
{
contentDescription
.
AssignLiteral
(
"
(
not
an
element
)
"
)
;
}
metadata
.
SetContentDescription
(
NS_LossyConvertUTF16toASCII
(
contentDescription
)
)
;
if
(
IsAPZTestLoggingEnabled
(
)
)
{
LogTestDataForPaint
(
aLayerManager
scrollId
"
contentDescription
"
metadata
.
GetContentDescription
(
)
.
get
(
)
)
;
}
}
}
metrics
.
SetPresShellId
(
presShell
-
>
GetPresShellId
(
)
)
;
if
(
aScrollFrame
&
&
nsContentUtils
:
:
HasScrollgrab
(
aScrollFrame
-
>
GetContent
(
)
)
)
{
metadata
.
SetHasScrollgrab
(
true
)
;
}
if
(
aScrollFrame
)
{
if
(
isRootScrollFrame
)
{
metadata
.
SetBackgroundColor
(
sRGBColor
:
:
FromABGR
(
presShell
-
>
GetCanvasBackground
(
)
)
)
;
}
else
{
ComputedStyle
*
backgroundStyle
;
if
(
nsCSSRendering
:
:
FindBackground
(
aScrollFrame
&
backgroundStyle
)
)
{
nscolor
backgroundColor
=
backgroundStyle
-
>
StyleBackground
(
)
-
>
BackgroundColor
(
backgroundStyle
)
;
metadata
.
SetBackgroundColor
(
sRGBColor
:
:
FromABGR
(
backgroundColor
)
)
;
}
}
}
if
(
ShouldDisableApzForElement
(
aContent
)
)
{
metadata
.
SetForceDisableApz
(
true
)
;
}
return
metadata
;
}
Maybe
<
ScrollMetadata
>
nsLayoutUtils
:
:
GetRootMetadata
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aLayerManager
const
ContainerLayerParameters
&
aContainerParameters
const
std
:
:
function
<
bool
(
ViewID
&
aScrollId
)
>
&
aCallback
)
{
nsIFrame
*
frame
=
aBuilder
-
>
RootReferenceFrame
(
)
;
nsPresContext
*
presContext
=
frame
-
>
PresContext
(
)
;
PresShell
*
presShell
=
presContext
-
>
PresShell
(
)
;
Document
*
document
=
presShell
-
>
GetDocument
(
)
;
bool
addMetrics
=
XRE_IsParentProcess
(
)
&
&
!
presShell
-
>
GetRootScrollFrame
(
)
;
bool
ensureMetricsForRootId
=
nsLayoutUtils
:
:
AsyncPanZoomEnabled
(
frame
)
&
&
aBuilder
-
>
IsPaintingToWindow
(
)
&
&
!
presContext
-
>
GetParentPresContext
(
)
;
nsIContent
*
content
=
nullptr
;
nsIFrame
*
rootScrollFrame
=
presShell
-
>
GetRootScrollFrame
(
)
;
if
(
rootScrollFrame
)
{
content
=
rootScrollFrame
-
>
GetContent
(
)
;
}
else
{
content
=
document
-
>
GetDocumentElement
(
)
;
}
if
(
ensureMetricsForRootId
&
&
content
)
{
ViewID
scrollId
=
nsLayoutUtils
:
:
FindOrCreateIDFor
(
content
)
;
if
(
aCallback
(
scrollId
)
)
{
ensureMetricsForRootId
=
false
;
}
}
if
(
addMetrics
|
|
ensureMetricsForRootId
)
{
bool
isRootContent
=
presContext
-
>
IsRootContentDocumentCrossProcess
(
)
;
nsSize
scrollPortSize
=
frame
-
>
GetSize
(
)
;
if
(
isRootContent
&
&
rootScrollFrame
)
{
nsIScrollableFrame
*
scrollableFrame
=
rootScrollFrame
-
>
GetScrollTargetFrame
(
)
;
scrollPortSize
=
scrollableFrame
-
>
GetScrollPortRect
(
)
.
Size
(
)
;
}
return
Some
(
nsLayoutUtils
:
:
ComputeScrollMetadata
(
frame
rootScrollFrame
content
aBuilder
-
>
FindReferenceFrameFor
(
frame
)
aLayerManager
ScrollableLayerGuid
:
:
NULL_SCROLL_ID
scrollPortSize
Nothing
(
)
isRootContent
Some
(
aContainerParameters
)
)
)
;
}
return
Nothing
(
)
;
}
bool
nsLayoutUtils
:
:
ContainsMetricsWithId
(
const
Layer
*
aLayer
const
ViewID
&
aScrollId
)
{
for
(
uint32_t
i
=
aLayer
-
>
GetScrollMetadataCount
(
)
;
i
>
0
;
i
-
-
)
{
if
(
aLayer
-
>
GetFrameMetrics
(
i
-
1
)
.
GetScrollId
(
)
=
=
aScrollId
)
{
return
true
;
}
}
for
(
Layer
*
child
=
aLayer
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
ContainsMetricsWithId
(
child
aScrollId
)
)
{
return
true
;
}
}
return
false
;
}
StyleTouchAction
nsLayoutUtils
:
:
GetTouchActionFromFrame
(
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
)
{
return
StyleTouchAction
:
:
AUTO
;
}
bool
isNonReplacedInlineElement
=
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eLineParticipant
)
;
if
(
isNonReplacedInlineElement
)
{
return
StyleTouchAction
:
:
AUTO
;
}
const
nsStyleDisplay
*
disp
=
aFrame
-
>
StyleDisplay
(
)
;
bool
isTableElement
=
disp
-
>
IsInternalTableStyleExceptCell
(
)
;
if
(
isTableElement
)
{
return
StyleTouchAction
:
:
AUTO
;
}
return
disp
-
>
mTouchAction
;
}
void
nsLayoutUtils
:
:
TransformToAncestorAndCombineRegions
(
const
nsRegion
&
aRegion
nsIFrame
*
aFrame
const
nsIFrame
*
aAncestorFrame
nsRegion
*
aPreciseTargetDest
nsRegion
*
aImpreciseTargetDest
Maybe
<
Matrix4x4Flagged
>
*
aMatrixCache
const
DisplayItemClip
*
aClip
)
{
if
(
aRegion
.
IsEmpty
(
)
)
{
return
;
}
bool
isPrecise
;
RegionBuilder
<
nsRegion
>
transformedRegion
;
for
(
nsRegion
:
:
RectIterator
it
=
aRegion
.
RectIter
(
)
;
!
it
.
Done
(
)
;
it
.
Next
(
)
)
{
nsRect
transformed
=
TransformFrameRectToAncestor
(
aFrame
it
.
Get
(
)
aAncestorFrame
&
isPrecise
aMatrixCache
)
;
if
(
aClip
)
{
transformed
=
aClip
-
>
ApplyNonRoundedIntersection
(
transformed
)
;
if
(
aClip
-
>
GetRoundedRectCount
(
)
>
0
)
{
isPrecise
=
false
;
}
}
transformedRegion
.
OrWith
(
transformed
)
;
}
nsRegion
*
dest
=
isPrecise
?
aPreciseTargetDest
:
aImpreciseTargetDest
;
dest
-
>
OrWith
(
transformedRegion
.
ToRegion
(
)
)
;
if
(
dest
-
>
GetNumRects
(
)
>
12
)
{
dest
-
>
SimplifyOutward
(
6
)
;
if
(
isPrecise
)
{
aPreciseTargetDest
-
>
OrWith
(
*
aImpreciseTargetDest
)
;
*
aImpreciseTargetDest
=
std
:
:
move
(
*
aPreciseTargetDest
)
;
aImpreciseTargetDest
-
>
SimplifyOutward
(
6
)
;
*
aPreciseTargetDest
=
nsRegion
(
)
;
}
}
}
bool
nsLayoutUtils
:
:
ShouldUseNoScriptSheet
(
Document
*
aDocument
)
{
if
(
aDocument
-
>
IsStaticDocument
(
)
)
{
aDocument
=
aDocument
-
>
GetOriginalDocument
(
)
;
}
return
aDocument
-
>
IsScriptEnabled
(
)
;
}
bool
nsLayoutUtils
:
:
ShouldUseNoFramesSheet
(
Document
*
aDocument
)
{
bool
allowSubframes
=
true
;
nsIDocShell
*
docShell
=
aDocument
-
>
GetDocShell
(
)
;
if
(
docShell
)
{
docShell
-
>
GetAllowSubframes
(
&
allowSubframes
)
;
}
return
!
allowSubframes
;
}
void
nsLayoutUtils
:
:
GetFrameTextContent
(
nsIFrame
*
aFrame
nsAString
&
aResult
)
{
aResult
.
Truncate
(
)
;
AppendFrameTextContent
(
aFrame
aResult
)
;
}
void
nsLayoutUtils
:
:
AppendFrameTextContent
(
nsIFrame
*
aFrame
nsAString
&
aResult
)
{
if
(
aFrame
-
>
IsTextFrame
(
)
)
{
auto
textFrame
=
static_cast
<
nsTextFrame
*
>
(
aFrame
)
;
auto
offset
=
textFrame
-
>
GetContentOffset
(
)
;
auto
length
=
textFrame
-
>
GetContentLength
(
)
;
textFrame
-
>
TextFragment
(
)
-
>
AppendTo
(
aResult
offset
length
)
;
}
else
{
for
(
nsIFrame
*
child
:
aFrame
-
>
PrincipalChildList
(
)
)
{
AppendFrameTextContent
(
child
aResult
)
;
}
}
}
nsRect
nsLayoutUtils
:
:
GetSelectionBoundingRect
(
const
Selection
*
aSel
)
{
nsRect
res
;
if
(
aSel
-
>
IsCollapsed
(
)
)
{
nsIFrame
*
frame
=
nsCaret
:
:
GetGeometry
(
aSel
&
res
)
;
if
(
frame
)
{
nsIFrame
*
relativeTo
=
GetContainingBlockForClientRect
(
frame
)
;
res
=
TransformFrameRectToAncestor
(
frame
res
relativeTo
)
;
}
}
else
{
int32_t
rangeCount
=
aSel
-
>
RangeCount
(
)
;
RectAccumulator
accumulator
;
for
(
int32_t
idx
=
0
;
idx
<
rangeCount
;
+
+
idx
)
{
nsRange
*
range
=
aSel
-
>
GetRangeAt
(
idx
)
;
nsRange
:
:
CollectClientRectsAndText
(
&
accumulator
nullptr
range
range
-
>
GetStartContainer
(
)
range
-
>
StartOffset
(
)
range
-
>
GetEndContainer
(
)
range
-
>
EndOffset
(
)
true
false
)
;
}
res
=
accumulator
.
mResultRect
.
IsEmpty
(
)
?
accumulator
.
mFirstRect
:
accumulator
.
mResultRect
;
}
return
res
;
}
nsBlockFrame
*
nsLayoutUtils
:
:
GetFloatContainingBlock
(
nsIFrame
*
aFrame
)
{
nsIFrame
*
ancestor
=
aFrame
-
>
GetParent
(
)
;
while
(
ancestor
&
&
!
ancestor
-
>
IsFloatContainingBlock
(
)
)
{
ancestor
=
ancestor
-
>
GetParent
(
)
;
}
MOZ_ASSERT
(
!
ancestor
|
|
ancestor
-
>
IsBlockFrameOrSubclass
(
)
"
Float
containing
block
can
only
be
block
frame
"
)
;
return
static_cast
<
nsBlockFrame
*
>
(
ancestor
)
;
}
CSSRect
nsLayoutUtils
:
:
GetBoundingContentRect
(
const
nsIContent
*
aContent
const
nsIScrollableFrame
*
aRootScrollFrame
)
{
if
(
nsIFrame
*
frame
=
aContent
-
>
GetPrimaryFrame
(
)
)
{
return
GetBoundingFrameRect
(
frame
aRootScrollFrame
)
;
}
return
CSSRect
(
)
;
}
CSSRect
nsLayoutUtils
:
:
GetBoundingFrameRect
(
nsIFrame
*
aFrame
const
nsIScrollableFrame
*
aRootScrollFrame
)
{
CSSRect
result
;
nsIFrame
*
relativeTo
=
aRootScrollFrame
-
>
GetScrolledFrame
(
)
;
result
=
CSSRect
:
:
FromAppUnits
(
nsLayoutUtils
:
:
GetAllInFlowRectsUnion
(
aFrame
relativeTo
nsLayoutUtils
:
:
RECTS_ACCOUNT_FOR_TRANSFORMS
)
)
;
nsIScrollableFrame
*
scrollFrame
=
nsLayoutUtils
:
:
GetNearestScrollableFrame
(
aFrame
)
;
if
(
scrollFrame
&
&
scrollFrame
!
=
aRootScrollFrame
)
{
nsIFrame
*
subFrame
=
do_QueryFrame
(
scrollFrame
)
;
MOZ_ASSERT
(
subFrame
)
;
CSSRect
subFrameRect
=
CSSRect
:
:
FromAppUnits
(
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
subFrame
subFrame
-
>
GetRectRelativeToSelf
(
)
relativeTo
)
)
;
result
=
subFrameRect
.
Intersect
(
result
)
;
}
return
result
;
}
bool
nsLayoutUtils
:
:
IsTransformed
(
nsIFrame
*
aForFrame
nsIFrame
*
aTopFrame
)
{
for
(
nsIFrame
*
f
=
aForFrame
;
f
!
=
aTopFrame
;
f
=
f
-
>
GetParent
(
)
)
{
if
(
f
-
>
IsTransformed
(
)
)
{
return
true
;
}
}
return
false
;
}
CSSPoint
nsLayoutUtils
:
:
GetCumulativeApzCallbackTransform
(
nsIFrame
*
aFrame
)
{
CSSPoint
delta
;
if
(
!
aFrame
)
{
return
delta
;
}
nsIFrame
*
frame
=
aFrame
;
nsCOMPtr
<
nsIContent
>
lastContent
;
bool
seenRcdRsf
=
false
;
auto
applyCallbackTransformForFrame
=
[
&
]
(
nsIFrame
*
frame
)
{
if
(
frame
)
{
nsCOMPtr
<
nsIContent
>
content
=
frame
-
>
GetContent
(
)
;
if
(
content
&
&
(
content
!
=
lastContent
)
)
{
void
*
property
=
content
-
>
GetProperty
(
nsGkAtoms
:
:
apzCallbackTransform
)
;
if
(
property
)
{
delta
+
=
*
static_cast
<
CSSPoint
*
>
(
property
)
;
}
}
lastContent
=
content
;
}
}
;
while
(
frame
)
{
applyCallbackTransformForFrame
(
frame
)
;
nsPresContext
*
pc
=
frame
-
>
PresContext
(
)
;
if
(
nsIScrollableFrame
*
scrollFrame
=
do_QueryFrame
(
frame
)
)
{
if
(
scrollFrame
-
>
IsRootScrollFrameOfDocument
(
)
&
&
pc
-
>
IsRootContentDocument
(
)
)
{
seenRcdRsf
=
true
;
}
}
ViewportFrame
*
viewportFrame
=
do_QueryFrame
(
frame
)
;
if
(
viewportFrame
)
{
if
(
pc
-
>
IsRootContentDocument
(
)
&
&
!
seenRcdRsf
)
{
applyCallbackTransformForFrame
(
pc
-
>
PresShell
(
)
-
>
GetRootScrollFrame
(
)
)
;
}
}
frame
=
GetCrossDocParentFrame
(
frame
)
;
}
return
delta
;
}
static
nsSize
ComputeMaxSizeForPartialPrerender
(
nsIFrame
*
aFrame
nsSize
aMaxSize
)
{
Matrix4x4Flagged
transform
=
nsLayoutUtils
:
:
GetTransformToAncestor
(
RelativeTo
{
aFrame
}
RelativeTo
{
nsLayoutUtils
:
:
GetDisplayRootFrame
(
aFrame
)
}
)
;
Matrix
transform2D
;
if
(
!
transform
.
Is2D
(
&
transform2D
)
)
{
return
aMaxSize
;
}
gfx
:
:
Rect
result
(
0
0
aMaxSize
.
width
aMaxSize
.
height
)
;
gfx
:
:
Size
scale
=
transform2D
.
ScaleFactors
(
)
;
if
(
scale
.
width
!
=
0
&
&
scale
.
height
!
=
0
)
{
result
.
width
/
=
scale
.
width
;
result
.
height
/
=
scale
.
height
;
}
transform2D
.
_31
=
0
.
0f
;
transform2D
.
_32
=
0
.
0f
;
if
(
scale
.
width
!
=
0
&
&
scale
.
height
!
=
0
)
{
transform2D
.
_11
/
=
scale
.
width
;
transform2D
.
_12
/
=
scale
.
width
;
transform2D
.
_21
/
=
scale
.
height
;
transform2D
.
_22
/
=
scale
.
height
;
}
result
=
transform2D
.
TransformBounds
(
result
)
;
return
nsSize
(
result
.
width
result
.
height
)
;
}
nsRect
nsLayoutUtils
:
:
ComputePartialPrerenderArea
(
nsIFrame
*
aFrame
const
nsRect
&
aDirtyRect
const
nsRect
&
aOverflow
const
nsSize
&
aPrerenderSize
)
{
nsSize
maxSizeForPartialPrerender
=
ComputeMaxSizeForPartialPrerender
(
aFrame
aPrerenderSize
)
;
nscoord
xExcess
=
std
:
:
max
(
maxSizeForPartialPrerender
.
width
-
aDirtyRect
.
width
0
)
;
nscoord
yExcess
=
std
:
:
max
(
maxSizeForPartialPrerender
.
height
-
aDirtyRect
.
height
0
)
;
nsRect
result
=
aDirtyRect
;
result
.
Inflate
(
xExcess
/
2
yExcess
/
2
)
;
return
result
.
MoveInsideAndClamp
(
aOverflow
)
;
}
static
bool
LineHasNonEmptyContentWorker
(
nsIFrame
*
aFrame
)
{
if
(
aFrame
-
>
IsInlineFrame
(
)
)
{
for
(
nsIFrame
*
child
:
aFrame
-
>
PrincipalChildList
(
)
)
{
if
(
LineHasNonEmptyContentWorker
(
child
)
)
{
return
true
;
}
}
}
else
{
if
(
!
aFrame
-
>
IsBrFrame
(
)
&
&
!
aFrame
-
>
IsEmpty
(
)
)
{
return
true
;
}
}
return
false
;
}
static
bool
LineHasNonEmptyContent
(
nsLineBox
*
aLine
)
{
int32_t
count
=
aLine
-
>
GetChildCount
(
)
;
for
(
nsIFrame
*
frame
=
aLine
-
>
mFirstChild
;
count
>
0
;
-
-
count
frame
=
frame
-
>
GetNextSibling
(
)
)
{
if
(
LineHasNonEmptyContentWorker
(
frame
)
)
{
return
true
;
}
}
return
false
;
}
bool
nsLayoutUtils
:
:
IsInvisibleBreak
(
nsINode
*
aNode
nsIFrame
*
*
aNextLineFrame
)
{
if
(
aNextLineFrame
)
{
*
aNextLineFrame
=
nullptr
;
}
if
(
!
aNode
-
>
IsElement
(
)
|
|
!
aNode
-
>
IsEditable
(
)
)
{
return
false
;
}
nsIFrame
*
frame
=
aNode
-
>
AsElement
(
)
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
|
|
!
frame
-
>
IsBrFrame
(
)
)
{
return
false
;
}
nsContainerFrame
*
f
=
frame
-
>
GetParent
(
)
;
while
(
f
&
&
f
-
>
IsFrameOfType
(
nsIFrame
:
:
eLineParticipant
)
)
{
f
=
f
-
>
GetParent
(
)
;
}
nsBlockFrame
*
blockAncestor
=
do_QueryFrame
(
f
)
;
if
(
!
blockAncestor
)
{
return
false
;
}
bool
valid
=
false
;
nsBlockInFlowLineIterator
iter
(
blockAncestor
frame
&
valid
)
;
if
(
!
valid
)
{
return
false
;
}
bool
lineNonEmpty
=
LineHasNonEmptyContent
(
iter
.
GetLine
(
)
)
;
if
(
!
lineNonEmpty
)
{
return
false
;
}
while
(
iter
.
Next
(
)
)
{
auto
currentLine
=
iter
.
GetLine
(
)
;
if
(
!
currentLine
-
>
IsEmpty
(
)
)
{
if
(
currentLine
-
>
IsInline
(
)
)
{
if
(
aNextLineFrame
)
{
*
aNextLineFrame
=
currentLine
-
>
mFirstChild
;
}
return
false
;
}
break
;
}
}
return
lineNonEmpty
;
}
static
nsRect
ComputeSVGReferenceRect
(
nsIFrame
*
aFrame
StyleGeometryBox
aGeometryBox
)
{
MOZ_ASSERT
(
aFrame
-
>
GetContent
(
)
-
>
IsSVGElement
(
)
)
;
nsRect
r
;
switch
(
aGeometryBox
)
{
case
StyleGeometryBox
:
:
StrokeBox
:
{
gfxRect
bbox
=
SVGUtils
:
:
GetBBox
(
aFrame
SVGUtils
:
:
eBBoxIncludeFillGeometry
|
SVGUtils
:
:
eBBoxIncludeStroke
)
;
r
=
nsLayoutUtils
:
:
RoundGfxRectToAppRect
(
bbox
AppUnitsPerCSSPixel
(
)
)
;
break
;
}
case
StyleGeometryBox
:
:
ViewBox
:
{
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
SVGElement
*
element
=
static_cast
<
SVGElement
*
>
(
content
)
;
SVGViewportElement
*
svgElement
=
element
-
>
GetCtx
(
)
;
MOZ_ASSERT
(
svgElement
)
;
if
(
svgElement
&
&
svgElement
-
>
HasViewBox
(
)
)
{
const
SVGViewBox
&
value
=
svgElement
-
>
GetAnimatedViewBox
(
)
-
>
GetAnimValue
(
)
;
r
=
nsRect
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
value
.
x
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
value
.
y
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
value
.
width
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
value
.
height
)
)
;
}
else
{
svgFloatSize
viewportSize
=
svgElement
-
>
GetViewportSize
(
)
;
r
=
nsRect
(
0
0
nsPresContext
:
:
CSSPixelsToAppUnits
(
viewportSize
.
width
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
viewportSize
.
height
)
)
;
}
break
;
}
case
StyleGeometryBox
:
:
NoBox
:
case
StyleGeometryBox
:
:
BorderBox
:
case
StyleGeometryBox
:
:
ContentBox
:
case
StyleGeometryBox
:
:
PaddingBox
:
case
StyleGeometryBox
:
:
MarginBox
:
case
StyleGeometryBox
:
:
FillBox
:
{
gfxRect
bbox
=
SVGUtils
:
:
GetBBox
(
aFrame
SVGUtils
:
:
eBBoxIncludeFillGeometry
)
;
r
=
nsLayoutUtils
:
:
RoundGfxRectToAppRect
(
bbox
AppUnitsPerCSSPixel
(
)
)
;
break
;
}
default
:
{
MOZ_ASSERT_UNREACHABLE
(
"
unknown
StyleGeometryBox
type
"
)
;
gfxRect
bbox
=
SVGUtils
:
:
GetBBox
(
aFrame
SVGUtils
:
:
eBBoxIncludeFillGeometry
)
;
r
=
nsLayoutUtils
:
:
RoundGfxRectToAppRect
(
bbox
AppUnitsPerCSSPixel
(
)
)
;
break
;
}
}
return
r
;
}
static
nsRect
ComputeHTMLReferenceRect
(
nsIFrame
*
aFrame
StyleGeometryBox
aGeometryBox
)
{
nsRect
r
;
switch
(
aGeometryBox
)
{
case
StyleGeometryBox
:
:
ContentBox
:
r
=
aFrame
-
>
GetContentRectRelativeToSelf
(
)
;
break
;
case
StyleGeometryBox
:
:
PaddingBox
:
r
=
aFrame
-
>
GetPaddingRectRelativeToSelf
(
)
;
break
;
case
StyleGeometryBox
:
:
MarginBox
:
r
=
aFrame
-
>
GetMarginRectRelativeToSelf
(
)
;
break
;
case
StyleGeometryBox
:
:
NoBox
:
case
StyleGeometryBox
:
:
BorderBox
:
case
StyleGeometryBox
:
:
FillBox
:
case
StyleGeometryBox
:
:
StrokeBox
:
case
StyleGeometryBox
:
:
ViewBox
:
r
=
aFrame
-
>
GetRectRelativeToSelf
(
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unknown
StyleGeometryBox
type
"
)
;
r
=
aFrame
-
>
GetRectRelativeToSelf
(
)
;
break
;
}
return
r
;
}
static
StyleGeometryBox
ShapeBoxToGeometryBox
(
const
StyleShapeBox
&
aBox
)
{
switch
(
aBox
)
{
case
StyleShapeBox
:
:
BorderBox
:
return
StyleGeometryBox
:
:
BorderBox
;
case
StyleShapeBox
:
:
ContentBox
:
return
StyleGeometryBox
:
:
ContentBox
;
case
StyleShapeBox
:
:
MarginBox
:
return
StyleGeometryBox
:
:
MarginBox
;
case
StyleShapeBox
:
:
PaddingBox
:
return
StyleGeometryBox
:
:
PaddingBox
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
shape
box
type
"
)
;
return
StyleGeometryBox
:
:
MarginBox
;
}
static
StyleGeometryBox
ClipPathBoxToGeometryBox
(
const
StyleShapeGeometryBox
&
aBox
)
{
using
Tag
=
StyleShapeGeometryBox
:
:
Tag
;
switch
(
aBox
.
tag
)
{
case
Tag
:
:
ShapeBox
:
return
ShapeBoxToGeometryBox
(
aBox
.
AsShapeBox
(
)
)
;
case
Tag
:
:
ElementDependent
:
return
StyleGeometryBox
:
:
NoBox
;
case
Tag
:
:
FillBox
:
return
StyleGeometryBox
:
:
FillBox
;
case
Tag
:
:
StrokeBox
:
return
StyleGeometryBox
:
:
StrokeBox
;
case
Tag
:
:
ViewBox
:
return
StyleGeometryBox
:
:
ViewBox
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
shape
box
type
"
)
;
return
StyleGeometryBox
:
:
NoBox
;
}
nsRect
nsLayoutUtils
:
:
ComputeGeometryBox
(
nsIFrame
*
aFrame
StyleGeometryBox
aGeometryBox
)
{
return
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_SVG_LAYOUT
)
?
ComputeSVGReferenceRect
(
aFrame
aGeometryBox
)
:
ComputeHTMLReferenceRect
(
aFrame
aGeometryBox
)
;
}
nsRect
nsLayoutUtils
:
:
ComputeGeometryBox
(
nsIFrame
*
aFrame
const
StyleShapeBox
&
aBox
)
{
return
ComputeGeometryBox
(
aFrame
ShapeBoxToGeometryBox
(
aBox
)
)
;
}
nsRect
nsLayoutUtils
:
:
ComputeGeometryBox
(
nsIFrame
*
aFrame
const
StyleShapeGeometryBox
&
aBox
)
{
return
ComputeGeometryBox
(
aFrame
ClipPathBoxToGeometryBox
(
aBox
)
)
;
}
nsPoint
nsLayoutUtils
:
:
ComputeOffsetToUserSpace
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
{
nsPoint
offsetToBoundingBox
=
aBuilder
-
>
ToReferenceFrame
(
aFrame
)
-
SVGIntegrationUtils
:
:
GetOffsetToBoundingBox
(
aFrame
)
;
if
(
!
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
)
{
offsetToBoundingBox
=
nsPoint
(
aFrame
-
>
PresContext
(
)
-
>
RoundAppUnitsToNearestDevPixels
(
offsetToBoundingBox
.
x
)
aFrame
-
>
PresContext
(
)
-
>
RoundAppUnitsToNearestDevPixels
(
offsetToBoundingBox
.
y
)
)
;
}
gfxPoint
toUserSpaceGfx
=
SVGUtils
:
:
FrameSpaceInCSSPxToUserSpaceOffset
(
aFrame
)
;
nsPoint
toUserSpace
=
nsPoint
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
float
(
toUserSpaceGfx
.
x
)
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
float
(
toUserSpaceGfx
.
y
)
)
)
;
return
(
offsetToBoundingBox
-
toUserSpace
)
;
}
mozilla
:
:
StyleControlCharacterVisibility
nsLayoutUtils
:
:
ControlCharVisibilityDefault
(
)
{
return
StaticPrefs
:
:
layout_css_control_characters_visible
(
)
?
StyleControlCharacterVisibility
:
:
Visible
:
StyleControlCharacterVisibility
:
:
Hidden
;
}
already_AddRefed
<
nsFontMetrics
>
nsLayoutUtils
:
:
GetMetricsFor
(
nsPresContext
*
aPresContext
bool
aIsVertical
const
nsStyleFont
*
aStyleFont
Length
aFontSize
bool
aUseUserFontSet
)
{
nsFont
font
=
aStyleFont
-
>
mFont
;
font
.
size
=
aFontSize
;
gfxFont
:
:
Orientation
orientation
=
aIsVertical
?
nsFontMetrics
:
:
eVertical
:
nsFontMetrics
:
:
eHorizontal
;
nsFontMetrics
:
:
Params
params
;
params
.
language
=
aStyleFont
-
>
mLanguage
;
params
.
explicitLanguage
=
aStyleFont
-
>
mExplicitLanguage
;
params
.
orientation
=
orientation
;
params
.
userFontSet
=
aUseUserFontSet
?
aPresContext
-
>
GetUserFontSet
(
)
:
nullptr
;
params
.
textPerf
=
aPresContext
-
>
GetTextPerfMetrics
(
)
;
params
.
fontStats
=
aPresContext
-
>
GetFontMatchingStats
(
)
;
params
.
featureValueLookup
=
aPresContext
-
>
GetFontFeatureValuesLookup
(
)
;
return
aPresContext
-
>
DeviceContext
(
)
-
>
GetMetricsFor
(
font
params
)
;
}
void
nsLayoutUtils
:
:
ComputeSystemFont
(
nsFont
*
aSystemFont
LookAndFeel
:
:
FontID
aFontID
const
nsFont
*
aDefaultVariableFont
const
Document
*
aDocument
)
{
gfxFontStyle
fontStyle
;
nsAutoString
systemFontName
;
if
(
LookAndFeel
:
:
GetFont
(
aFontID
systemFontName
fontStyle
)
)
{
systemFontName
.
Trim
(
"
\
"
'
"
)
;
aSystemFont
-
>
fontlist
=
FontFamilyList
(
NS_ConvertUTF16toUTF8
(
systemFontName
)
StyleFontFamilyNameSyntax
:
:
Identifiers
)
;
aSystemFont
-
>
fontlist
.
SetDefaultFontType
(
StyleGenericFontFamily
:
:
None
)
;
aSystemFont
-
>
style
=
fontStyle
.
style
;
aSystemFont
-
>
systemFont
=
fontStyle
.
systemFont
;
aSystemFont
-
>
weight
=
fontStyle
.
weight
;
aSystemFont
-
>
stretch
=
fontStyle
.
stretch
;
aSystemFont
-
>
size
=
Length
:
:
FromPixels
(
fontStyle
.
size
)
;
if
(
aDocument
-
>
ShouldAvoidNativeTheme
(
)
&
&
(
aFontID
=
=
LookAndFeel
:
:
FontID
:
:
Field
|
|
aFontID
=
=
LookAndFeel
:
:
FontID
:
:
Button
|
|
aFontID
=
=
LookAndFeel
:
:
FontID
:
:
List
)
)
{
auto
newSize
=
aDefaultVariableFont
-
>
size
.
ToCSSPixels
(
)
-
CSSCoord
(
3
.
0f
)
;
aSystemFont
-
>
size
=
Length
:
:
FromPixels
(
std
:
:
max
(
float
(
newSize
)
0
.
0f
)
)
;
}
aSystemFont
-
>
sizeAdjust
=
fontStyle
.
sizeAdjust
;
#
ifdef
XP_WIN
if
(
aFontID
=
=
LookAndFeel
:
:
FontID
:
:
Field
|
|
aFontID
=
=
LookAndFeel
:
:
FontID
:
:
Button
|
|
aFontID
=
=
LookAndFeel
:
:
FontID
:
:
List
)
{
auto
newSize
=
aDefaultVariableFont
-
>
size
.
ToCSSPixels
(
)
-
CSSPixel
:
:
FromPoints
(
2
.
0f
)
;
aSystemFont
-
>
size
=
Length
:
:
FromPixels
(
std
:
:
max
(
float
(
newSize
)
0
.
0f
)
)
;
}
#
endif
}
}
bool
nsLayoutUtils
:
:
ShouldHandleMetaViewport
(
const
Document
*
aDocument
)
{
auto
metaViewportOverride
=
nsIDocShell
:
:
META_VIEWPORT_OVERRIDE_NONE
;
if
(
aDocument
)
{
if
(
nsIDocShell
*
docShell
=
aDocument
-
>
GetDocShell
(
)
)
{
metaViewportOverride
=
docShell
-
>
GetMetaViewportOverride
(
)
;
}
}
switch
(
metaViewportOverride
)
{
case
nsIDocShell
:
:
META_VIEWPORT_OVERRIDE_ENABLED
:
return
true
;
case
nsIDocShell
:
:
META_VIEWPORT_OVERRIDE_DISABLED
:
return
false
;
default
:
MOZ_ASSERT
(
metaViewportOverride
=
=
nsIDocShell
:
:
META_VIEWPORT_OVERRIDE_NONE
)
;
return
StaticPrefs
:
:
dom_meta_viewport_enabled
(
)
;
}
}
ComputedStyle
*
nsLayoutUtils
:
:
StyleForScrollbar
(
nsIFrame
*
aScrollbarPart
)
{
nsIContent
*
content
=
aScrollbarPart
-
>
GetContent
(
)
;
MOZ_ASSERT
(
content
"
No
content
for
the
scrollbar
part
?
"
)
;
while
(
content
&
&
content
-
>
IsInNativeAnonymousSubtree
(
)
&
&
content
-
>
IsAnyOfXULElements
(
nsGkAtoms
:
:
scrollbar
nsGkAtoms
:
:
scrollbarbutton
nsGkAtoms
:
:
scrollcorner
nsGkAtoms
:
:
slider
nsGkAtoms
:
:
thumb
)
)
{
content
=
content
-
>
GetParent
(
)
;
}
MOZ_ASSERT
(
content
"
Native
anonymous
element
with
no
originating
node
?
"
)
;
if
(
nsIFrame
*
primaryFrame
=
content
-
>
GetPrimaryFrame
(
)
)
{
return
primaryFrame
-
>
Style
(
)
;
}
MOZ_ASSERT
(
content
=
=
aScrollbarPart
-
>
PresContext
(
)
-
>
Document
(
)
-
>
GetRootElement
(
)
"
Root
element
is
the
only
case
for
this
fallback
"
"
path
to
be
triggered
"
)
;
RefPtr
<
ComputedStyle
>
style
=
ServoStyleSet
:
:
ResolveServoStyle
(
*
content
-
>
AsElement
(
)
)
;
return
style
.
get
(
)
;
}
static
Maybe
<
ScreenRect
>
GetFrameVisibleRectOnScreen
(
const
nsIFrame
*
aFrame
)
{
nsPresContext
*
topContextInProcess
=
aFrame
-
>
PresContext
(
)
-
>
GetInProcessRootContentDocumentPresContext
(
)
;
if
(
!
topContextInProcess
)
{
return
Nothing
(
)
;
}
if
(
topContextInProcess
-
>
Document
(
)
-
>
IsTopLevelContentDocument
(
)
)
{
return
Nothing
(
)
;
}
nsIDocShell
*
docShell
=
topContextInProcess
-
>
GetDocShell
(
)
;
BrowserChild
*
browserChild
=
BrowserChild
:
:
GetFrom
(
docShell
)
;
if
(
!
browserChild
)
{
return
Nothing
(
)
;
}
if
(
!
browserChild
-
>
GetEffectsInfo
(
)
.
IsVisible
(
)
)
{
return
Some
(
ScreenRect
(
)
)
;
}
nsIFrame
*
rootFrame
=
topContextInProcess
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
;
nsRect
transformedToIFrame
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
aFrame
aFrame
-
>
GetRectRelativeToSelf
(
)
rootFrame
)
;
LayoutDeviceRect
rectInLayoutDevicePixel
=
LayoutDeviceRect
:
:
FromAppUnits
(
transformedToIFrame
topContextInProcess
-
>
AppUnitsPerDevPixel
(
)
)
;
ScreenRect
transformedToRoot
=
ViewAs
<
ScreenPixel
>
(
browserChild
-
>
GetChildToParentConversionMatrix
(
)
.
TransformBounds
(
rectInLayoutDevicePixel
)
PixelCastJustification
:
:
ContentProcessIsLayerInUiProcess
)
;
return
Some
(
browserChild
-
>
GetTopLevelViewportVisibleRectInBrowserCoords
(
)
.
Intersect
(
transformedToRoot
)
)
;
}
bool
nsLayoutUtils
:
:
FrameIsScrolledOutOfViewInCrossProcess
(
const
nsIFrame
*
aFrame
)
{
Maybe
<
ScreenRect
>
visibleRect
=
GetFrameVisibleRectOnScreen
(
aFrame
)
;
if
(
visibleRect
.
isNothing
(
)
)
{
return
false
;
}
return
visibleRect
-
>
IsEmpty
(
)
;
}
bool
nsLayoutUtils
:
:
FrameIsMostlyScrolledOutOfViewInCrossProcess
(
const
nsIFrame
*
aFrame
nscoord
aMargin
)
{
Maybe
<
ScreenRect
>
visibleRect
=
GetFrameVisibleRectOnScreen
(
aFrame
)
;
if
(
visibleRect
.
isNothing
(
)
)
{
return
false
;
}
nsPresContext
*
topContextInProcess
=
aFrame
-
>
PresContext
(
)
-
>
GetInProcessRootContentDocumentPresContext
(
)
;
MOZ_ASSERT
(
topContextInProcess
)
;
nsIDocShell
*
docShell
=
topContextInProcess
-
>
GetDocShell
(
)
;
BrowserChild
*
browserChild
=
BrowserChild
:
:
GetFrom
(
docShell
)
;
MOZ_ASSERT
(
browserChild
)
;
Size
scale
=
browserChild
-
>
GetChildToParentConversionMatrix
(
)
.
As2D
(
)
.
ScaleFactors
(
)
;
ScreenSize
margin
(
scale
.
width
*
CSSPixel
:
:
FromAppUnits
(
aMargin
)
scale
.
height
*
CSSPixel
:
:
FromAppUnits
(
aMargin
)
)
;
return
visibleRect
-
>
width
<
margin
.
width
|
|
visibleRect
-
>
height
<
margin
.
height
;
}
nsSize
nsLayoutUtils
:
:
ExpandHeightForViewportUnits
(
nsPresContext
*
aPresContext
const
nsSize
&
aSize
)
{
nsSize
sizeForViewportUnits
=
aPresContext
-
>
GetSizeForViewportUnits
(
)
;
float
vhExpansionRatio
=
(
float
)
sizeForViewportUnits
.
height
/
aPresContext
-
>
GetVisibleArea
(
)
.
height
;
MOZ_ASSERT
(
aSize
.
height
<
=
NSCoordSaturatingNonnegativeMultiply
(
aSize
.
height
vhExpansionRatio
)
)
;
return
nsSize
(
aSize
.
width
NSCoordSaturatingNonnegativeMultiply
(
aSize
.
height
vhExpansionRatio
)
)
;
}
template
<
typename
SizeType
>
SizeType
ExpandHeightForDynamicToolbarImpl
(
const
nsPresContext
*
aPresContext
const
SizeType
&
aSize
)
{
RefPtr
<
MobileViewportManager
>
MVM
=
aPresContext
-
>
PresShell
(
)
-
>
GetMobileViewportManager
(
)
;
MOZ_ASSERT
(
MVM
)
;
float
toolbarHeightRatio
=
mozilla
:
:
ScreenCoord
(
aPresContext
-
>
GetDynamicToolbarMaxHeight
(
)
)
/
mozilla
:
:
ViewAs
<
mozilla
:
:
ScreenPixel
>
(
MVM
-
>
DisplaySize
(
)
mozilla
:
:
PixelCastJustification
:
:
LayoutDeviceIsScreenForBounds
)
.
height
;
return
SizeType
(
aSize
.
width
NSCoordSaturatingAdd
(
aSize
.
height
aSize
.
height
*
toolbarHeightRatio
)
)
;
}
CSSSize
nsLayoutUtils
:
:
ExpandHeightForDynamicToolbar
(
const
nsPresContext
*
aPresContext
const
CSSSize
&
aSize
)
{
return
ExpandHeightForDynamicToolbarImpl
(
aPresContext
aSize
)
;
}
nsSize
nsLayoutUtils
:
:
ExpandHeightForDynamicToolbar
(
const
nsPresContext
*
aPresContext
const
nsSize
&
aSize
)
{
return
ExpandHeightForDynamicToolbarImpl
(
aPresContext
aSize
)
;
}
