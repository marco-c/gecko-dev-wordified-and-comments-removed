#
include
"
AnchorPositioningUtils
.
h
"
#
include
"
DisplayPortUtils
.
h
"
#
include
"
ScrollContainerFrame
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
StaticPrefs_apz
.
h
"
#
include
"
mozilla
/
dom
/
DOMIntersectionObserver
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
nsCanvasFrame
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsPlaceholderFrame
.
h
"
#
include
"
nsStyleStruct
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
{
namespace
{
bool
IsScrolled
(
const
nsIFrame
*
aFrame
)
{
switch
(
aFrame
-
>
Style
(
)
-
>
GetPseudoType
(
)
)
{
case
PseudoStyleType
:
:
scrolledContent
:
case
PseudoStyleType
:
:
scrolledCanvas
:
return
true
;
default
:
return
false
;
}
}
bool
DoTreeScopedPropertiesOfElementApplyToContent
(
const
nsINode
*
aStylePropertyElement
const
nsINode
*
aStyledContent
)
{
return
aStylePropertyElement
-
>
GetContainingDocumentOrShadowRoot
(
)
=
=
aStyledContent
-
>
GetContainingDocumentOrShadowRoot
(
)
;
}
bool
IsAnchorInScopeForPositionedElement
(
const
nsAtom
*
aName
const
nsIFrame
*
aPossibleAnchorFrame
const
nsIFrame
*
aPositionedFrame
)
{
const
auto
*
positionedContainingBlockContent
=
aPositionedFrame
-
>
GetParent
(
)
-
>
GetContent
(
)
;
auto
getAnchorPosNearestScope
=
[
&
]
(
const
nsAtom
*
aName
const
nsIFrame
*
aFrame
)
-
>
const
nsIContent
*
{
for
(
nsIContent
*
cp
=
aFrame
-
>
GetContent
(
)
;
cp
&
&
cp
!
=
positionedContainingBlockContent
;
cp
=
cp
-
>
GetFlattenedTreeParentElementForStyle
(
)
)
{
const
auto
*
anchorScope
=
[
&
]
(
)
-
>
const
StyleAnchorScope
*
{
const
nsIFrame
*
f
=
nsLayoutUtils
:
:
GetStyleFrame
(
cp
)
;
if
(
MOZ_LIKELY
(
f
)
)
{
return
&
f
-
>
StyleDisplay
(
)
-
>
mAnchorScope
;
}
if
(
cp
-
>
AsElement
(
)
-
>
IsDisplayContents
(
)
)
{
const
auto
*
style
=
Servo_Element_GetMaybeOutOfDateStyle
(
cp
-
>
AsElement
(
)
)
;
MOZ_ASSERT
(
style
)
;
return
&
style
-
>
StyleDisplay
(
)
-
>
mAnchorScope
;
}
return
nullptr
;
}
(
)
;
if
(
!
anchorScope
|
|
anchorScope
-
>
IsNone
(
)
)
{
continue
;
}
if
(
anchorScope
-
>
IsAll
(
)
)
{
return
cp
;
}
MOZ_ASSERT
(
anchorScope
-
>
IsIdents
(
)
)
;
for
(
const
StyleAtom
&
ident
:
anchorScope
-
>
AsIdents
(
)
.
AsSpan
(
)
)
{
if
(
aName
=
=
ident
.
AsAtom
(
)
)
{
return
cp
;
}
}
}
return
nullptr
;
}
;
const
nsIContent
*
nearestScopeForAnchor
=
getAnchorPosNearestScope
(
aName
aPossibleAnchorFrame
)
;
const
nsIContent
*
nearestScopeForPositioned
=
getAnchorPosNearestScope
(
aName
aPositionedFrame
)
;
if
(
!
nearestScopeForAnchor
)
{
return
!
nearestScopeForPositioned
|
|
aPossibleAnchorFrame
-
>
GetContent
(
)
=
=
nearestScopeForPositioned
;
}
return
nearestScopeForAnchor
=
=
nearestScopeForPositioned
;
}
;
bool
IsFullyStyleableTreeAbidingOrNotPseudoElement
(
const
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
-
>
Style
(
)
-
>
IsPseudoElement
(
)
)
{
return
true
;
}
const
PseudoStyleType
pseudoElementType
=
aFrame
-
>
Style
(
)
-
>
GetPseudoType
(
)
;
return
pseudoElementType
=
=
PseudoStyleType
:
:
before
|
|
pseudoElementType
=
=
PseudoStyleType
:
:
after
|
|
pseudoElementType
=
=
PseudoStyleType
:
:
marker
;
}
size_t
GetTopLayerIndex
(
const
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
)
;
const
nsIContent
*
frameContent
=
aFrame
-
>
GetContent
(
)
;
if
(
!
frameContent
)
{
return
0
;
}
const
nsTArray
<
dom
:
:
Element
*
>
&
topLayers
=
frameContent
-
>
OwnerDoc
(
)
-
>
GetTopLayer
(
)
;
for
(
size_t
index
=
0
;
index
<
topLayers
.
Length
(
)
;
+
+
index
)
{
const
auto
&
topLayer
=
topLayers
.
ElementAt
(
index
)
;
if
(
nsContentUtils
:
:
ContentIsFlattenedTreeDescendantOfForStyle
(
frameContent
topLayer
)
)
{
return
1
+
index
;
}
}
return
0
;
}
bool
IsInitialContainingBlock
(
const
nsIFrame
*
aContainingBlock
)
{
return
aContainingBlock
=
=
aContainingBlock
-
>
PresShell
(
)
-
>
FrameConstructor
(
)
-
>
GetDocElementContainingBlock
(
)
;
}
bool
IsContainingBlockGeneratedByElement
(
const
nsIFrame
*
aContainingBlock
)
{
return
!
(
!
aContainingBlock
|
|
aContainingBlock
-
>
IsViewportFrame
(
)
|
|
IsInitialContainingBlock
(
aContainingBlock
)
)
;
}
bool
IsAnchorLaidOutStrictlyBeforeElement
(
const
nsIFrame
*
aPossibleAnchorFrame
const
nsIFrame
*
aPositionedFrame
const
nsTArray
<
const
nsIFrame
*
>
&
aPositionedFrameAncestors
)
{
const
size_t
positionedTopLayerIndex
=
GetTopLayerIndex
(
aPositionedFrame
)
;
const
size_t
anchorTopLayerIndex
=
GetTopLayerIndex
(
aPossibleAnchorFrame
)
;
if
(
anchorTopLayerIndex
!
=
positionedTopLayerIndex
)
{
return
anchorTopLayerIndex
<
positionedTopLayerIndex
;
}
const
nsIFrame
*
positionedContainingBlock
=
aPositionedFrame
-
>
GetParent
(
)
;
const
nsIFrame
*
anchorContainingBlock
=
aPossibleAnchorFrame
-
>
GetParent
(
)
;
if
(
anchorContainingBlock
!
=
positionedContainingBlock
)
{
if
(
positionedContainingBlock
-
>
IsViewportFrame
(
)
&
&
!
anchorContainingBlock
-
>
IsViewportFrame
(
)
)
{
return
!
nsLayoutUtils
:
:
IsProperAncestorFrame
(
aPositionedFrame
aPossibleAnchorFrame
)
;
}
auto
isLastContainingBlockOrderable
=
[
&
aPositionedFrame
&
aPositionedFrameAncestors
&
anchorContainingBlock
&
positionedContainingBlock
]
(
)
-
>
bool
{
const
nsIFrame
*
it
=
anchorContainingBlock
;
while
(
it
)
{
const
nsIFrame
*
parentContainingBlock
=
it
-
>
GetParent
(
)
;
if
(
!
parentContainingBlock
)
{
return
false
;
}
if
(
parentContainingBlock
=
=
positionedContainingBlock
)
{
return
!
it
-
>
IsAbsolutelyPositioned
(
)
|
|
nsLayoutUtils
:
:
CompareTreePosition
(
it
aPositionedFrame
aPositionedFrameAncestors
nullptr
)
<
0
;
}
it
=
parentContainingBlock
;
}
return
false
;
}
;
const
bool
isAnchorContainingBlockGenerated
=
IsContainingBlockGeneratedByElement
(
anchorContainingBlock
)
;
if
(
isAnchorContainingBlockGenerated
&
&
IsInitialContainingBlock
(
positionedContainingBlock
)
)
{
return
isLastContainingBlockOrderable
(
)
;
}
if
(
isAnchorContainingBlockGenerated
&
&
IsContainingBlockGeneratedByElement
(
positionedContainingBlock
)
)
{
return
isLastContainingBlockOrderable
(
)
;
}
return
false
;
}
const
bool
isAnchorAbsolutelyPositioned
=
aPossibleAnchorFrame
-
>
IsAbsolutelyPositioned
(
)
;
if
(
isAnchorAbsolutelyPositioned
)
{
return
nsLayoutUtils
:
:
CompareTreePosition
(
aPossibleAnchorFrame
aPositionedFrame
aPositionedFrameAncestors
nullptr
)
<
0
;
}
return
!
isAnchorAbsolutelyPositioned
;
}
bool
IsPositionedElementAlsoSkippedWhenAnchorIsSkipped
(
const
nsIFrame
*
aPossibleAnchorFrame
const
nsIFrame
*
aPositionedFrame
)
{
if
(
aPossibleAnchorFrame
-
>
HidesContentForLayout
(
)
)
{
return
false
;
}
const
nsIFrame
*
visibilityAncestor
=
aPossibleAnchorFrame
-
>
GetParent
(
)
;
while
(
visibilityAncestor
)
{
if
(
visibilityAncestor
-
>
HidesContentForLayout
(
)
)
{
break
;
}
visibilityAncestor
=
visibilityAncestor
-
>
GetParent
(
)
;
}
if
(
aPositionedFrame
-
>
HidesContentForLayout
(
)
)
{
return
false
;
}
const
nsIFrame
*
ancestor
=
aPositionedFrame
;
while
(
ancestor
)
{
if
(
ancestor
-
>
HidesContentForLayout
(
)
)
{
return
ancestor
=
=
visibilityAncestor
;
}
ancestor
=
ancestor
-
>
GetParent
(
)
;
}
return
true
;
}
class
LazyAncestorHolder
{
const
nsIFrame
*
mFrame
;
AutoTArray
<
const
nsIFrame
*
8
>
mAncestors
;
bool
mFilled
=
false
;
public
:
const
nsTArray
<
const
nsIFrame
*
>
&
GetAncestors
(
)
{
if
(
!
mFilled
)
{
nsLayoutUtils
:
:
FillAncestors
(
mFrame
nullptr
&
mAncestors
)
;
mFilled
=
true
;
}
return
mAncestors
;
}
explicit
LazyAncestorHolder
(
const
nsIFrame
*
aFrame
)
:
mFrame
(
aFrame
)
{
}
}
;
bool
IsAcceptableAnchorElement
(
const
nsIFrame
*
aPossibleAnchorFrame
const
nsAtom
*
aName
const
nsIFrame
*
aPositionedFrame
LazyAncestorHolder
&
aPositionedFrameAncestorHolder
)
{
MOZ_ASSERT
(
aPossibleAnchorFrame
)
;
MOZ_ASSERT
(
aPositionedFrame
)
;
return
(
IsFullyStyleableTreeAbidingOrNotPseudoElement
(
aPossibleAnchorFrame
)
&
&
IsAnchorLaidOutStrictlyBeforeElement
(
aPossibleAnchorFrame
aPositionedFrame
aPositionedFrameAncestorHolder
.
GetAncestors
(
)
)
&
&
IsAnchorInScopeForPositionedElement
(
aName
aPossibleAnchorFrame
aPositionedFrame
)
&
&
IsPositionedElementAlsoSkippedWhenAnchorIsSkipped
(
aPossibleAnchorFrame
aPositionedFrame
)
)
;
}
}
AnchorPosReferenceData
:
:
Result
AnchorPosReferenceData
:
:
InsertOrModify
(
const
nsAtom
*
aAnchorName
bool
aNeedOffset
)
{
bool
exists
=
true
;
auto
*
result
=
&
mMap
.
LookupOrInsertWith
(
aAnchorName
[
&
exists
]
(
)
{
exists
=
false
;
return
Nothing
{
}
;
}
)
;
if
(
!
exists
)
{
return
{
false
result
}
;
}
if
(
result
-
>
isNothing
(
)
)
{
return
{
true
result
}
;
}
if
(
!
aNeedOffset
)
{
return
{
true
result
}
;
}
return
{
result
-
>
ref
(
)
.
mOffsetData
.
isSome
(
)
result
}
;
}
const
AnchorPosReferenceData
:
:
Value
*
AnchorPosReferenceData
:
:
Lookup
(
const
nsAtom
*
aAnchorName
)
const
{
return
mMap
.
Lookup
(
aAnchorName
)
.
DataPtrOrNull
(
)
;
}
AnchorPosDefaultAnchorCache
:
:
AnchorPosDefaultAnchorCache
(
const
nsIFrame
*
aAnchor
const
nsIFrame
*
aScrollContainer
)
:
mAnchor
{
aAnchor
}
mScrollContainer
{
aScrollContainer
}
{
MOZ_ASSERT_IF
(
aAnchor
nsLayoutUtils
:
:
GetNearestScrollContainerFrame
(
const_cast
<
nsContainerFrame
*
>
(
aAnchor
-
>
GetParent
(
)
)
nsLayoutUtils
:
:
SCROLLABLE_SAME_DOC
|
nsLayoutUtils
:
:
SCROLLABLE_INCLUDE_HIDDEN
)
=
=
mScrollContainer
)
;
}
nsIFrame
*
AnchorPositioningUtils
:
:
FindFirstAcceptableAnchor
(
const
nsAtom
*
aName
const
nsIFrame
*
aPositionedFrame
const
nsTArray
<
nsIFrame
*
>
&
aPossibleAnchorFrames
)
{
LazyAncestorHolder
positionedFrameAncestorHolder
(
aPositionedFrame
)
;
const
auto
*
positionedContent
=
aPositionedFrame
-
>
GetContent
(
)
;
for
(
auto
it
=
aPossibleAnchorFrames
.
rbegin
(
)
;
it
!
=
aPossibleAnchorFrames
.
rend
(
)
;
+
+
it
)
{
const
nsIFrame
*
possibleAnchorFrame
=
*
it
;
if
(
!
DoTreeScopedPropertiesOfElementApplyToContent
(
possibleAnchorFrame
-
>
GetContent
(
)
positionedContent
)
)
{
continue
;
}
if
(
IsAcceptableAnchorElement
(
*
it
aName
aPositionedFrame
positionedFrameAncestorHolder
)
)
{
return
*
it
;
}
}
return
nullptr
;
}
static
const
nsIFrame
*
TraverseUpToContainerChild
(
const
nsIFrame
*
aContainer
const
nsIFrame
*
aDescendant
)
{
const
auto
*
current
=
aDescendant
;
while
(
true
)
{
const
auto
*
parent
=
current
-
>
GetParent
(
)
;
if
(
!
parent
)
{
return
nullptr
;
}
if
(
parent
=
=
aContainer
)
{
return
current
;
}
current
=
parent
;
}
}
static
const
nsIFrame
*
GetAnchorOf
(
const
nsIFrame
*
aPositioned
const
nsAtom
*
aAnchorName
)
{
const
auto
*
presShell
=
aPositioned
-
>
PresShell
(
)
;
MOZ_ASSERT
(
presShell
"
No
PresShell
for
frame
?
"
)
;
return
presShell
-
>
GetAnchorPosAnchor
(
aAnchorName
aPositioned
)
;
}
Maybe
<
nsRect
>
AnchorPositioningUtils
:
:
GetAnchorPosRect
(
const
nsIFrame
*
aAbsoluteContainingBlock
const
nsIFrame
*
aAnchor
bool
aCBRectIsvalid
)
{
auto
rect
=
[
&
]
(
)
-
>
Maybe
<
nsRect
>
{
if
(
aCBRectIsvalid
)
{
const
nsRect
result
=
nsLayoutUtils
:
:
GetCombinedFragmentRects
(
aAnchor
true
)
;
const
auto
offset
=
aAnchor
-
>
GetOffsetToIgnoringScrolling
(
aAbsoluteContainingBlock
)
;
return
Some
(
result
+
offset
)
;
}
const
auto
*
containerChild
=
TraverseUpToContainerChild
(
aAbsoluteContainingBlock
aAnchor
)
;
if
(
!
containerChild
)
{
return
Nothing
{
}
;
}
if
(
aAnchor
=
=
containerChild
)
{
return
Some
(
nsLayoutUtils
:
:
GetCombinedFragmentRects
(
aAnchor
false
)
)
;
}
const
nsRect
rectToContainerChild
=
nsLayoutUtils
:
:
GetCombinedFragmentRects
(
aAnchor
true
)
;
const
auto
offset
=
aAnchor
-
>
GetOffsetToIgnoringScrolling
(
containerChild
)
;
return
Some
(
rectToContainerChild
+
offset
+
containerChild
-
>
GetPosition
(
)
)
;
}
(
)
;
return
rect
.
map
(
[
&
]
(
const
nsRect
&
aRect
)
{
const
auto
border
=
aAbsoluteContainingBlock
-
>
GetUsedBorder
(
)
;
const
nsPoint
borderTopLeft
{
border
.
left
border
.
top
}
;
const
auto
rect
=
aRect
-
borderTopLeft
;
return
rect
;
}
)
;
}
Maybe
<
AnchorPosInfo
>
AnchorPositioningUtils
:
:
ResolveAnchorPosRect
(
const
nsIFrame
*
aPositioned
const
nsIFrame
*
aAbsoluteContainingBlock
const
nsAtom
*
aAnchorName
bool
aCBRectIsvalid
AnchorPosResolutionCache
*
aResolutionCache
)
{
if
(
!
aPositioned
)
{
return
Nothing
{
}
;
}
if
(
!
aPositioned
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
)
{
return
Nothing
{
}
;
}
MOZ_ASSERT
(
aPositioned
-
>
GetParent
(
)
=
=
aAbsoluteContainingBlock
)
;
const
auto
*
anchorName
=
GetUsedAnchorName
(
aPositioned
aAnchorName
)
;
if
(
!
anchorName
)
{
return
Nothing
{
}
;
}
Maybe
<
AnchorPosResolutionData
>
*
entry
=
nullptr
;
if
(
aResolutionCache
)
{
const
auto
result
=
aResolutionCache
-
>
mReferenceData
-
>
InsertOrModify
(
anchorName
true
)
;
if
(
result
.
mAlreadyResolved
)
{
MOZ_ASSERT
(
result
.
mEntry
"
Entry
exists
but
null
?
"
)
;
return
result
.
mEntry
-
>
map
(
[
&
]
(
const
AnchorPosResolutionData
&
aData
)
{
MOZ_ASSERT
(
aData
.
mOffsetData
"
Missing
anchor
offset
resolution
.
"
)
;
const
auto
&
offsetData
=
aData
.
mOffsetData
.
ref
(
)
;
return
AnchorPosInfo
{
nsRect
{
offsetData
.
mOrigin
aData
.
mSize
}
offsetData
.
mCompensatesForScroll
}
;
}
)
;
}
entry
=
result
.
mEntry
;
}
const
auto
*
anchor
=
GetAnchorOf
(
aPositioned
anchorName
)
;
if
(
!
anchor
)
{
MOZ_ASSERT_IF
(
entry
entry
-
>
isNothing
(
)
)
;
return
Nothing
{
}
;
}
const
auto
result
=
GetAnchorPosRect
(
aAbsoluteContainingBlock
anchor
aCBRectIsvalid
)
;
return
result
.
map
(
[
&
]
(
const
nsRect
&
aRect
)
{
bool
compensatesForScroll
=
false
;
DistanceToNearestScrollContainer
distanceToNearestScrollContainer
;
if
(
aResolutionCache
)
{
MOZ_ASSERT
(
entry
)
;
compensatesForScroll
=
[
&
]
(
)
{
auto
&
defaultAnchorCache
=
aResolutionCache
-
>
mDefaultAnchorCache
;
if
(
!
aAnchorName
)
{
defaultAnchorCache
.
mAnchor
=
anchor
;
const
auto
[
scrollContainer
distance
]
=
AnchorPositioningUtils
:
:
GetNearestScrollFrame
(
anchor
)
;
distanceToNearestScrollContainer
=
distance
;
defaultAnchorCache
.
mScrollContainer
=
scrollContainer
;
aResolutionCache
-
>
mReferenceData
-
>
mDistanceToDefaultScrollContainer
=
distance
;
aResolutionCache
-
>
mReferenceData
-
>
mDefaultAnchorName
=
anchorName
;
return
true
;
}
if
(
defaultAnchorCache
.
mAnchor
=
=
anchor
)
{
return
true
;
}
const
auto
[
scrollContainer
distance
]
=
AnchorPositioningUtils
:
:
GetNearestScrollFrame
(
anchor
)
;
distanceToNearestScrollContainer
=
distance
;
return
scrollContainer
=
=
aResolutionCache
-
>
mDefaultAnchorCache
.
mScrollContainer
;
}
(
)
;
MOZ_ASSERT_IF
(
*
entry
entry
-
>
ref
(
)
.
mSize
=
=
aRect
.
Size
(
)
)
;
*
entry
=
Some
(
AnchorPosResolutionData
{
aRect
.
Size
(
)
Some
(
AnchorPosOffsetData
{
aRect
.
TopLeft
(
)
compensatesForScroll
distanceToNearestScrollContainer
}
)
}
)
;
}
return
AnchorPosInfo
{
aRect
compensatesForScroll
}
;
}
)
;
}
Maybe
<
nsSize
>
AnchorPositioningUtils
:
:
ResolveAnchorPosSize
(
const
nsIFrame
*
aPositioned
const
nsAtom
*
aAnchorName
AnchorPosResolutionCache
*
aResolutionCache
)
{
const
auto
*
anchorName
=
GetUsedAnchorName
(
aPositioned
aAnchorName
)
;
if
(
!
anchorName
)
{
return
Nothing
{
}
;
}
Maybe
<
AnchorPosResolutionData
>
*
entry
=
nullptr
;
auto
*
referencedAnchors
=
aResolutionCache
?
aResolutionCache
-
>
mReferenceData
:
nullptr
;
if
(
referencedAnchors
)
{
const
auto
result
=
referencedAnchors
-
>
InsertOrModify
(
anchorName
false
)
;
if
(
result
.
mAlreadyResolved
)
{
MOZ_ASSERT
(
result
.
mEntry
"
Entry
exists
but
null
?
"
)
;
return
result
.
mEntry
-
>
map
(
[
]
(
const
AnchorPosResolutionData
&
aData
)
{
return
aData
.
mSize
;
}
)
;
}
entry
=
result
.
mEntry
;
}
const
auto
*
anchor
=
GetAnchorOf
(
aPositioned
anchorName
)
;
if
(
!
anchor
)
{
return
Nothing
{
}
;
}
const
auto
size
=
nsLayoutUtils
:
:
GetCombinedFragmentRects
(
anchor
)
.
Size
(
)
;
if
(
entry
)
{
*
entry
=
Some
(
AnchorPosResolutionData
{
size
Nothing
{
}
}
)
;
}
return
Some
(
size
)
;
}
static
StylePositionArea
ToPhysicalPositionArea
(
StylePositionArea
aPosArea
WritingMode
aCbWM
WritingMode
aPosWM
)
{
StyleWritingMode
cbwm
{
aCbWM
.
GetBits
(
)
}
;
StyleWritingMode
wm
{
aPosWM
.
GetBits
(
)
}
;
Servo_PhysicalizePositionArea
(
&
aPosArea
&
cbwm
&
wm
)
;
return
aPosArea
;
}
nsRect
AnchorPositioningUtils
:
:
AdjustAbsoluteContainingBlockRectForPositionArea
(
const
nsRect
&
aAnchorRect
const
nsRect
&
aCBRect
WritingMode
aPositionedWM
WritingMode
aCBWM
const
StylePositionArea
&
aPosArea
StylePositionArea
*
aOutResolvedArea
)
{
const
nsRect
gridRect
=
aCBRect
.
Union
(
aAnchorRect
)
;
nscoord
ltrEdges
[
4
]
=
{
gridRect
.
x
aAnchorRect
.
x
aAnchorRect
.
x
+
aAnchorRect
.
width
gridRect
.
x
+
gridRect
.
width
}
;
nscoord
ttbEdges
[
4
]
=
{
gridRect
.
y
aAnchorRect
.
y
aAnchorRect
.
y
+
aAnchorRect
.
height
gridRect
.
y
+
gridRect
.
height
}
;
ltrEdges
[
1
]
=
std
:
:
clamp
(
ltrEdges
[
1
]
ltrEdges
[
0
]
ltrEdges
[
3
]
)
;
ltrEdges
[
2
]
=
std
:
:
clamp
(
ltrEdges
[
2
]
ltrEdges
[
0
]
ltrEdges
[
3
]
)
;
ttbEdges
[
1
]
=
std
:
:
clamp
(
ttbEdges
[
1
]
ttbEdges
[
0
]
ttbEdges
[
3
]
)
;
ttbEdges
[
2
]
=
std
:
:
clamp
(
ttbEdges
[
2
]
ttbEdges
[
0
]
ttbEdges
[
3
]
)
;
nsRect
res
=
gridRect
;
StylePositionArea
posArea
=
ToPhysicalPositionArea
(
aPosArea
aCBWM
aPositionedWM
)
;
*
aOutResolvedArea
=
posArea
;
nscoord
right
=
ltrEdges
[
3
]
;
if
(
posArea
.
first
=
=
StylePositionAreaKeyword
:
:
Left
)
{
right
=
ltrEdges
[
1
]
;
}
else
if
(
posArea
.
first
=
=
StylePositionAreaKeyword
:
:
SpanLeft
)
{
right
=
ltrEdges
[
2
]
;
}
else
if
(
posArea
.
first
=
=
StylePositionAreaKeyword
:
:
Center
)
{
res
.
x
=
ltrEdges
[
1
]
;
right
=
ltrEdges
[
2
]
;
}
else
if
(
posArea
.
first
=
=
StylePositionAreaKeyword
:
:
SpanRight
)
{
res
.
x
=
ltrEdges
[
1
]
;
}
else
if
(
posArea
.
first
=
=
StylePositionAreaKeyword
:
:
Right
)
{
res
.
x
=
ltrEdges
[
2
]
;
}
else
if
(
posArea
.
first
=
=
StylePositionAreaKeyword
:
:
SpanAll
)
{
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Bad
value
from
ToPhysicalPositionArea
"
)
;
}
res
.
width
=
right
-
res
.
x
;
nscoord
bottom
=
ttbEdges
[
3
]
;
if
(
posArea
.
second
=
=
StylePositionAreaKeyword
:
:
Top
)
{
bottom
=
ttbEdges
[
1
]
;
}
else
if
(
posArea
.
second
=
=
StylePositionAreaKeyword
:
:
SpanTop
)
{
bottom
=
ttbEdges
[
2
]
;
}
else
if
(
posArea
.
second
=
=
StylePositionAreaKeyword
:
:
Center
)
{
res
.
y
=
ttbEdges
[
1
]
;
bottom
=
ttbEdges
[
2
]
;
}
else
if
(
posArea
.
second
=
=
StylePositionAreaKeyword
:
:
SpanBottom
)
{
res
.
y
=
ttbEdges
[
1
]
;
}
else
if
(
posArea
.
second
=
=
StylePositionAreaKeyword
:
:
Bottom
)
{
res
.
y
=
ttbEdges
[
2
]
;
}
else
if
(
posArea
.
second
=
=
StylePositionAreaKeyword
:
:
SpanAll
)
{
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Bad
value
from
ToPhysicalPositionArea
"
)
;
}
res
.
height
=
bottom
-
res
.
y
;
return
res
;
}
AnchorPositioningUtils
:
:
NearestScrollFrameInfo
AnchorPositioningUtils
:
:
GetNearestScrollFrame
(
const
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
)
{
return
{
nullptr
{
}
}
;
}
uint32_t
distance
=
1
;
for
(
const
nsIFrame
*
f
=
aFrame
-
>
GetParent
(
)
;
f
;
f
=
f
-
>
GetParent
(
)
)
{
if
(
f
-
>
IsScrollContainerOrSubclass
(
)
)
{
return
{
f
DistanceToNearestScrollContainer
{
distance
}
}
;
}
distance
+
+
;
}
return
{
nullptr
{
}
}
;
}
nsPoint
AnchorPositioningUtils
:
:
GetScrollOffsetFor
(
PhysicalAxes
aAxes
const
nsIFrame
*
aPositioned
const
AnchorPosDefaultAnchorCache
&
aDefaultAnchorCache
)
{
MOZ_ASSERT
(
aPositioned
)
;
if
(
!
aDefaultAnchorCache
.
mAnchor
|
|
aAxes
.
isEmpty
(
)
)
{
return
nsPoint
{
}
;
}
nsPoint
offset
;
const
bool
trackHorizontal
=
aAxes
.
contains
(
PhysicalAxis
:
:
Horizontal
)
;
const
bool
trackVertical
=
aAxes
.
contains
(
PhysicalAxis
:
:
Vertical
)
;
const
auto
*
absoluteContainingBlock
=
aPositioned
-
>
GetParent
(
)
;
if
(
GetNearestScrollFrame
(
aPositioned
)
.
mScrollContainer
=
=
aDefaultAnchorCache
.
mScrollContainer
)
{
return
nsPoint
{
}
;
}
for
(
const
auto
*
f
=
aDefaultAnchorCache
.
mScrollContainer
;
f
&
&
f
!
=
absoluteContainingBlock
;
f
=
f
-
>
GetParent
(
)
)
{
if
(
const
ScrollContainerFrame
*
scrollFrame
=
do_QueryFrame
(
f
)
)
{
const
auto
o
=
scrollFrame
-
>
GetScrollPosition
(
)
;
if
(
trackHorizontal
)
{
offset
.
x
+
=
o
.
x
;
}
if
(
trackVertical
)
{
offset
.
y
+
=
o
.
y
;
}
}
}
return
offset
;
}
void
DeleteAnchorPosReferenceData
(
AnchorPosReferenceData
*
aData
)
{
delete
aData
;
}
void
DeleteLastSuccessfulPositionData
(
LastSuccessfulPositionData
*
aData
)
{
delete
aData
;
}
const
nsAtom
*
AnchorPositioningUtils
:
:
GetUsedAnchorName
(
const
nsIFrame
*
aPositioned
const
nsAtom
*
aAnchorName
)
{
if
(
aAnchorName
&
&
!
aAnchorName
-
>
IsEmpty
(
)
)
{
return
aAnchorName
;
}
const
auto
&
defaultAnchor
=
aPositioned
-
>
StylePosition
(
)
-
>
mPositionAnchor
;
if
(
defaultAnchor
.
IsNone
(
)
)
{
return
nullptr
;
}
if
(
defaultAnchor
.
IsIdent
(
)
)
{
return
defaultAnchor
.
AsIdent
(
)
.
AsAtom
(
)
;
}
if
(
aPositioned
-
>
Style
(
)
-
>
IsPseudoElement
(
)
)
{
return
nsGkAtoms
:
:
AnchorPosImplicitAnchor
;
}
if
(
const
nsIContent
*
content
=
aPositioned
-
>
GetContent
(
)
)
{
if
(
const
auto
*
element
=
content
-
>
AsElement
(
)
)
{
if
(
element
-
>
GetPopoverData
(
)
)
{
return
nsGkAtoms
:
:
AnchorPosImplicitAnchor
;
}
}
}
return
nullptr
;
}
nsIFrame
*
AnchorPositioningUtils
:
:
GetAnchorPosImplicitAnchor
(
const
nsIFrame
*
aFrame
)
{
const
auto
*
frameContent
=
aFrame
-
>
GetContent
(
)
;
const
bool
hasElement
=
frameContent
&
&
frameContent
-
>
IsElement
(
)
;
if
(
!
aFrame
-
>
Style
(
)
-
>
IsPseudoElement
(
)
&
&
!
hasElement
)
{
return
nullptr
;
}
if
(
MOZ_LIKELY
(
hasElement
)
)
{
const
auto
*
element
=
frameContent
-
>
AsElement
(
)
;
MOZ_ASSERT
(
element
)
;
const
dom
:
:
PopoverData
*
popoverData
=
element
-
>
GetPopoverData
(
)
;
if
(
MOZ_UNLIKELY
(
popoverData
)
)
{
if
(
const
RefPtr
<
dom
:
:
Element
>
&
invoker
=
popoverData
-
>
GetInvoker
(
)
)
{
return
invoker
-
>
GetPrimaryFrame
(
)
;
}
}
}
const
auto
*
pseudoRoot
=
aFrame
-
>
GetClosestNativeAnonymousSubtreeRoot
(
)
;
if
(
!
pseudoRoot
)
{
return
nullptr
;
}
auto
*
pseudoRootFrame
=
pseudoRoot
-
>
GetPrimaryFrame
(
)
;
if
(
!
pseudoRootFrame
)
{
return
nullptr
;
}
return
pseudoRootFrame
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
?
pseudoRootFrame
-
>
GetPlaceholderFrame
(
)
-
>
GetParent
(
)
:
pseudoRootFrame
-
>
GetParent
(
)
;
}
AnchorPositioningUtils
:
:
ContainingBlockInfo
AnchorPositioningUtils
:
:
ContainingBlockInfo
:
:
ExplicitCBFrameSize
(
const
nsRect
&
aContainingBlockRect
)
{
return
ContainingBlockInfo
{
aContainingBlockRect
}
;
}
AnchorPositioningUtils
:
:
ContainingBlockInfo
AnchorPositioningUtils
:
:
ContainingBlockInfo
:
:
UseCBFrameSize
(
const
nsIFrame
*
aPositioned
)
{
const
auto
*
cb
=
aPositioned
-
>
GetParent
(
)
;
MOZ_ASSERT
(
cb
)
;
if
(
IsScrolled
(
cb
)
)
{
cb
=
aPositioned
-
>
GetParent
(
)
;
}
return
ContainingBlockInfo
{
cb
-
>
GetPaddingRectRelativeToSelf
(
)
}
;
}
bool
AnchorPositioningUtils
:
:
FitsInContainingBlock
(
const
nsIFrame
*
aPositioned
const
AnchorPosReferenceData
&
aReferenceData
)
{
MOZ_ASSERT
(
aPositioned
-
>
GetProperty
(
nsIFrame
:
:
AnchorPosReferences
(
)
)
=
=
&
aReferenceData
)
;
const
auto
&
scrollShift
=
aReferenceData
.
mDefaultScrollShift
;
const
auto
scrollCompensatedSides
=
aReferenceData
.
mScrollCompensatedSides
;
nsSize
checkSize
=
[
&
]
(
)
{
const
auto
&
adjustedCB
=
aReferenceData
.
mAdjustedContainingBlock
;
if
(
scrollShift
=
=
nsPoint
{
}
|
|
scrollCompensatedSides
=
=
SideBits
:
:
eNone
)
{
return
adjustedCB
.
Size
(
)
;
}
const
auto
shifted
=
aReferenceData
.
mAdjustedContainingBlock
-
scrollShift
;
const
auto
&
originalCB
=
aReferenceData
.
mOriginalContainingBlockRect
;
const
nsPoint
pt
{
scrollCompensatedSides
&
SideBits
:
:
eLeft
?
shifted
.
X
(
)
:
originalCB
.
X
(
)
scrollCompensatedSides
&
SideBits
:
:
eTop
?
shifted
.
Y
(
)
:
originalCB
.
Y
(
)
}
;
const
nsPoint
ptMost
{
scrollCompensatedSides
&
SideBits
:
:
eRight
?
shifted
.
XMost
(
)
:
originalCB
.
XMost
(
)
scrollCompensatedSides
&
SideBits
:
:
eBottom
?
shifted
.
YMost
(
)
:
originalCB
.
YMost
(
)
}
;
return
nsSize
{
ptMost
.
x
-
pt
.
x
ptMost
.
y
-
pt
.
y
}
;
}
(
)
;
checkSize
-
=
nsSize
{
aReferenceData
.
mInsets
.
LeftRight
(
)
aReferenceData
.
mInsets
.
TopBottom
(
)
}
;
return
aPositioned
-
>
GetMarginRectRelativeToSelf
(
)
.
Size
(
)
<
=
checkSize
;
}
nsIFrame
*
AnchorPositioningUtils
:
:
GetAnchorThatFrameScrollsWith
(
nsIFrame
*
aFrame
nsDisplayListBuilder
*
aBuilder
bool
aSkipAsserts
)
{
#
ifdef
DEBUG
if
(
!
aSkipAsserts
)
{
MOZ_ASSERT
(
!
aBuilder
|
|
aBuilder
-
>
IsPaintingToWindow
(
)
)
;
MOZ_ASSERT_IF
(
!
aBuilder
aFrame
-
>
PresContext
(
)
-
>
LayoutPhaseCount
(
nsLayoutPhase
:
:
DisplayListBuilding
)
=
=
0
)
;
}
#
endif
if
(
!
StaticPrefs
:
:
apz_async_scroll_css_anchor_pos_AtStartup
(
)
)
{
return
nullptr
;
}
PhysicalAxes
axes
=
aFrame
-
>
GetAnchorPosCompensatingForScroll
(
)
;
if
(
axes
.
isEmpty
(
)
)
{
return
nullptr
;
}
const
auto
*
pos
=
aFrame
-
>
StylePosition
(
)
;
if
(
!
pos
-
>
mPositionAnchor
.
IsIdent
(
)
)
{
return
nullptr
;
}
const
nsAtom
*
defaultAnchorName
=
pos
-
>
mPositionAnchor
.
AsIdent
(
)
.
AsAtom
(
)
;
nsIFrame
*
anchor
=
const_cast
<
nsIFrame
*
>
(
aFrame
-
>
PresShell
(
)
-
>
GetAnchorPosAnchor
(
defaultAnchorName
aFrame
)
)
;
if
(
anchor
&
&
!
nsLayoutUtils
:
:
IsProperAncestorFrameConsideringContinuations
(
aFrame
-
>
GetParent
(
)
anchor
)
)
{
return
nullptr
;
}
if
(
!
aBuilder
)
{
return
anchor
;
}
return
DisplayPortUtils
:
:
ShouldAsyncScrollWithAnchor
(
aFrame
anchor
aBuilder
axes
)
?
anchor
:
nullptr
;
}
static
bool
TriggerFallbackReflow
(
PresShell
*
aPresShell
nsIFrame
*
aPositioned
AnchorPosReferenceData
&
aReferencedAnchors
bool
aEvaluateAllFallbacksIfNeeded
)
{
auto
totalFallbacks
=
aPositioned
-
>
StylePosition
(
)
-
>
mPositionTryFallbacks
.
_0
.
Length
(
)
;
if
(
!
totalFallbacks
)
{
return
false
;
}
const
bool
positionedFitsInCB
=
AnchorPositioningUtils
:
:
FitsInContainingBlock
(
aPositioned
aReferencedAnchors
)
;
if
(
positionedFitsInCB
)
{
return
false
;
}
auto
*
lastSuccessfulPosition
=
aPositioned
-
>
GetProperty
(
nsIFrame
:
:
LastSuccessfulPositionFallback
(
)
)
;
const
bool
needsRetry
=
aEvaluateAllFallbacksIfNeeded
|
|
(
lastSuccessfulPosition
&
&
!
lastSuccessfulPosition
-
>
mTriedAllFallbacks
)
;
if
(
!
needsRetry
)
{
return
false
;
}
aPresShell
-
>
MarkPositionedFrameForReflow
(
aPositioned
)
;
return
true
;
}
static
bool
AnchorIsEffectivelyHidden
(
nsIFrame
*
aAnchor
)
{
if
(
!
aAnchor
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
)
{
return
true
;
}
for
(
auto
*
anchor
=
aAnchor
;
anchor
;
anchor
=
anchor
-
>
GetParent
(
)
)
{
if
(
anchor
-
>
HasAnyStateBits
(
NS_FRAME_POSITION_VISIBILITY_HIDDEN
)
)
{
return
true
;
}
}
return
false
;
}
static
bool
ComputePositionVisibility
(
PresShell
*
aPresShell
nsIFrame
*
aPositioned
AnchorPosReferenceData
&
aReferencedAnchors
)
{
auto
vis
=
aPositioned
-
>
StylePosition
(
)
-
>
mPositionVisibility
;
if
(
vis
&
StylePositionVisibility
:
:
ALWAYS
)
{
MOZ_ASSERT
(
vis
=
=
StylePositionVisibility
:
:
ALWAYS
"
always
can
'
t
be
combined
"
)
;
return
true
;
}
if
(
vis
&
StylePositionVisibility
:
:
ANCHORS_VALID
)
{
for
(
const
auto
&
ref
:
aReferencedAnchors
)
{
if
(
ref
.
GetData
(
)
.
isNothing
(
)
)
{
return
false
;
}
}
}
if
(
vis
&
StylePositionVisibility
:
:
NO_OVERFLOW
)
{
const
bool
positionedFitsInCB
=
AnchorPositioningUtils
:
:
FitsInContainingBlock
(
aPositioned
aReferencedAnchors
)
;
if
(
!
positionedFitsInCB
)
{
return
false
;
}
}
if
(
vis
&
StylePositionVisibility
:
:
ANCHORS_VISIBLE
)
{
const
auto
*
defaultAnchorName
=
aReferencedAnchors
.
mDefaultAnchorName
.
get
(
)
;
if
(
defaultAnchorName
)
{
auto
*
defaultAnchor
=
aPresShell
-
>
GetAnchorPosAnchor
(
defaultAnchorName
aPositioned
)
;
if
(
defaultAnchor
&
&
AnchorIsEffectivelyHidden
(
defaultAnchor
)
)
{
return
false
;
}
if
(
defaultAnchor
&
&
defaultAnchor
-
>
GetParent
(
)
!
=
aPositioned
-
>
GetParent
(
)
)
{
auto
*
intersectionRoot
=
aPositioned
-
>
GetParent
(
)
;
nsRect
rootRect
=
intersectionRoot
-
>
InkOverflowRectRelativeToSelf
(
)
;
if
(
IsScrolled
(
intersectionRoot
)
)
{
intersectionRoot
=
intersectionRoot
-
>
GetParent
(
)
;
ScrollContainerFrame
*
sc
=
do_QueryFrame
(
intersectionRoot
)
;
rootRect
=
sc
-
>
GetScrollPortRectAccountingForDynamicToolbar
(
)
;
}
const
auto
*
doc
=
aPositioned
-
>
PresContext
(
)
-
>
Document
(
)
;
const
nsINode
*
root
=
intersectionRoot
-
>
GetContent
(
)
?
static_cast
<
nsINode
*
>
(
intersectionRoot
-
>
GetContent
(
)
)
:
doc
;
rootRect
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
intersectionRoot
rootRect
nsLayoutUtils
:
:
GetContainingBlockForClientRect
(
intersectionRoot
)
)
;
const
auto
input
=
dom
:
:
IntersectionInput
{
.
mIsImplicitRoot
=
false
.
mRootNode
=
root
.
mRootFrame
=
intersectionRoot
.
mRootRect
=
rootRect
.
mRootMargin
=
{
}
.
mScrollMargin
=
{
}
.
mRemoteDocumentVisibleRect
=
{
}
}
;
const
auto
output
=
dom
:
:
DOMIntersectionObserver
:
:
Intersect
(
input
defaultAnchor
)
;
if
(
!
output
.
Intersects
(
)
|
|
(
output
.
mIntersectionRect
-
>
IsEmpty
(
)
&
&
!
defaultAnchor
-
>
GetRect
(
)
.
IsEmpty
(
)
)
)
{
return
false
;
}
}
}
}
return
true
;
}
bool
AnchorPositioningUtils
:
:
TriggerLayoutOnOverflow
(
PresShell
*
aPresShell
bool
aEvaluateAllFallbacksIfNeeded
)
{
bool
didLayoutPositionedItems
=
false
;
for
(
auto
*
positioned
:
aPresShell
-
>
GetAnchorPosPositioned
(
)
)
{
AnchorPosReferenceData
*
referencedAnchors
=
positioned
-
>
GetProperty
(
nsIFrame
:
:
AnchorPosReferences
(
)
)
;
if
(
NS_WARN_IF
(
!
referencedAnchors
)
)
{
continue
;
}
if
(
TriggerFallbackReflow
(
aPresShell
positioned
*
referencedAnchors
aEvaluateAllFallbacksIfNeeded
)
)
{
didLayoutPositionedItems
=
true
;
}
if
(
didLayoutPositionedItems
)
{
continue
;
}
const
bool
shouldBeVisible
=
ComputePositionVisibility
(
aPresShell
positioned
*
referencedAnchors
)
;
const
bool
isVisible
=
!
positioned
-
>
HasAnyStateBits
(
NS_FRAME_POSITION_VISIBILITY_HIDDEN
)
;
if
(
shouldBeVisible
!
=
isVisible
)
{
positioned
-
>
AddOrRemoveStateBits
(
NS_FRAME_POSITION_VISIBILITY_HIDDEN
!
shouldBeVisible
)
;
positioned
-
>
InvalidateFrameSubtree
(
)
;
}
}
return
didLayoutPositionedItems
;
}
}
