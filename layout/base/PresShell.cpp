#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
Units
.
h
"
#
include
"
mozilla
/
EventForwards
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
dom
/
AncestorIterator
.
h
"
#
include
"
mozilla
/
dom
/
FontFaceSet
.
h
"
#
include
"
mozilla
/
dom
/
ElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
LargestContentfulPaint
.
h
"
#
include
"
mozilla
/
dom
/
MouseEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
PerformanceMainThread
.
h
"
#
include
"
mozilla
/
dom
/
HTMLAreaElement
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
CaretAssociationHint
.
h
"
#
include
"
mozilla
/
ContentIterator
.
h
"
#
include
"
mozilla
/
DisplayPortUtils
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
GeckoMVMContext
.
h
"
#
include
"
mozilla
/
IMEStateManager
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
dom
/
BrowserChild
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
PerfStats
.
h
"
#
include
"
mozilla
/
PointerLockManager
.
h
"
#
include
"
mozilla
/
PresShellInlines
.
h
"
#
include
"
mozilla
/
RangeUtils
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
StaticAnalysisFunctions
.
h
"
#
include
"
mozilla
/
StaticPrefs_apz
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
StaticPrefs_font
.
h
"
#
include
"
mozilla
/
StaticPrefs_image
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
mozilla
/
StaticPrefs_test
.
h
"
#
include
"
mozilla
/
StaticPrefs_toolkit
.
h
"
#
include
"
mozilla
/
Try
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
TouchEvents
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
ViewportUtils
.
h
"
#
include
"
mozilla
/
gfx
/
Types
.
h
"
#
include
<
algorithm
>
#
ifdef
XP_WIN
#
include
"
winuser
.
h
"
#
endif
#
include
"
gfxContext
.
h
"
#
include
"
gfxUserFontSet
.
h
"
#
include
"
nsContentList
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
mozilla
/
dom
/
BrowserBridgeChild
.
h
"
#
include
"
mozilla
/
dom
/
BrowsingContext
.
h
"
#
include
"
mozilla
/
dom
/
CanonicalBrowsingContext
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
PointerEventHandler
.
h
"
#
include
"
mozilla
/
dom
/
PopupBlocker
.
h
"
#
include
"
mozilla
/
dom
/
DOMIntersectionObserver
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
include
"
mozilla
/
dom
/
UserActivation
.
h
"
#
include
"
nsAnimationManager
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsFlexContainerFrame
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsView
.
h
"
#
include
"
nsCRTGlue
.
h
"
#
include
"
prinrval
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsWindowSizes
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsPageSequenceFrame
.
h
"
#
include
"
nsCaret
.
h
"
#
include
"
mozilla
/
AccessibleCaretEventHub
.
h
"
#
include
"
nsFrameManager
.
h
"
#
include
"
nsXPCOM
.
h
"
#
include
"
nsILayoutHistoryState
.
h
"
#
include
"
nsILineIterator
.
h
"
#
include
"
PLDHashTable
.
h
"
#
include
"
mozilla
/
dom
/
Touch
.
h
"
#
include
"
mozilla
/
dom
/
TouchEvent
.
h
"
#
include
"
mozilla
/
dom
/
PointerEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
ShadowIncludingTreeIterator
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsIBaseWindow
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsViewportInfo
.
h
"
#
include
"
nsCSSRendering
.
h
"
#
include
"
prenv
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nsAutoLayoutPhase
.
h
"
#
include
"
AutoProfilerStyleMarker
.
h
"
#
ifdef
MOZ_REFLOW_PERF
#
include
"
nsFontMetrics
.
h
"
#
endif
#
include
"
MobileViewportManager
.
h
"
#
include
"
OverflowChangedTracker
.
h
"
#
include
"
PositionedEventTargeting
.
h
"
#
include
"
nsIReflowCallback
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsStyleSheetService
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
mozilla
/
SMILAnimationController
.
h
"
#
include
"
mozilla
/
dom
/
SVGAnimationElement
.
h
"
#
include
"
mozilla
/
SVGObserverUtils
.
h
"
#
include
"
mozilla
/
SVGFragmentIdentifier
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
mozilla
/
dom
/
Performance
.
h
"
#
include
"
nsRefreshDriver
.
h
"
#
include
"
nsDOMNavigationTiming
.
h
"
#
include
"
nsIDocShellTreeItem
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsITimer
.
h
"
#
ifdef
ACCESSIBILITY
#
include
"
mozilla
/
a11y
/
DocAccessible
.
h
"
#
ifdef
DEBUG
#
include
"
mozilla
/
a11y
/
Logging
.
h
"
#
endif
#
endif
#
include
"
nsStyleChangeList
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
nsTreeBodyFrame
.
h
"
#
include
"
XULTreeElement
.
h
"
#
include
"
nsMenuPopupFrame
.
h
"
#
include
"
nsTreeColumns
.
h
"
#
include
"
nsIDOMXULMultSelectCntrlEl
.
h
"
#
include
"
nsIDOMXULSelectCntrlItemEl
.
h
"
#
include
"
nsIDOMXULMenuListElement
.
h
"
#
include
"
nsXULElement
.
h
"
#
include
"
mozilla
/
layers
/
CompositorBridgeChild
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
mozilla
/
css
/
ImageLoader
.
h
"
#
include
"
mozilla
/
dom
/
DocumentTimeline
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
nsCanvasFrame
.
h
"
#
include
"
nsImageFrame
.
h
"
#
include
"
nsIScreen
.
h
"
#
include
"
nsIScreenManager
.
h
"
#
include
"
nsPlaceholderFrame
.
h
"
#
include
"
nsTransitionManager
.
h
"
#
include
"
ChildIterator
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
nsIDragSession
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsSubDocumentFrame
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
mozilla
/
GlobalStyleSheetCache
.
h
"
#
include
"
mozilla
/
layers
/
InputAPZContext
.
h
"
#
include
"
mozilla
/
layers
/
FocusTarget
.
h
"
#
include
"
mozilla
/
layers
/
ScrollingInteractionContext
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderLayerManager
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderUserData
.
h
"
#
include
"
mozilla
/
layout
/
ScrollAnchorContainer
.
h
"
#
include
"
mozilla
/
layers
/
APZPublicUtils
.
h
"
#
include
"
mozilla
/
ProfilerLabels
.
h
"
#
include
"
mozilla
/
ProfilerMarkers
.
h
"
#
include
"
mozilla
/
ScrollTimelineAnimationTracker
.
h
"
#
include
"
mozilla
/
ScrollTypes
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
mozilla
/
StyleSheet
.
h
"
#
include
"
mozilla
/
StyleSheetInlines
.
h
"
#
include
"
mozilla
/
InputTaskManager
.
h
"
#
include
"
mozilla
/
dom
/
ImageTracker
.
h
"
#
include
"
nsIDocShellTreeOwner
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsGlobalWindowOuter
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
ScrollSnap
.
h
"
#
include
"
VisualViewport
.
h
"
#
include
"
ZoomConstraintsClient
.
h
"
#
define
RELATIVE_SCALEFACTOR
0
.
0925f
using
namespace
mozilla
;
using
namespace
mozilla
:
:
css
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
layout
;
using
PaintFrameFlags
=
nsLayoutUtils
:
:
PaintFrameFlags
;
typedef
ScrollableLayerGuid
:
:
ViewID
ViewID
;
PresShell
:
:
CapturingContentInfo
PresShell
:
:
sCapturingContentInfo
;
struct
RangePaintInfo
{
RefPtr
<
nsRange
>
mRange
;
nsDisplayListBuilder
mBuilder
;
nsDisplayList
mList
;
nsPoint
mRootOffset
;
float
mResolution
=
1
.
0
;
RangePaintInfo
(
nsRange
*
aRange
nsIFrame
*
aFrame
)
:
mRange
(
aRange
)
mBuilder
(
aFrame
nsDisplayListBuilderMode
:
:
Painting
false
)
mList
(
&
mBuilder
)
{
MOZ_COUNT_CTOR
(
RangePaintInfo
)
;
mBuilder
.
BeginFrame
(
)
;
}
~
RangePaintInfo
(
)
{
mList
.
DeleteAll
(
&
mBuilder
)
;
mBuilder
.
EndFrame
(
)
;
MOZ_COUNT_DTOR
(
RangePaintInfo
)
;
}
}
;
#
undef
NOISY
#
ifdef
DEBUG
static
VerifyReflowFlags
gVerifyReflowFlags
;
struct
VerifyReflowFlagData
{
const
char
*
name
;
VerifyReflowFlags
bit
;
}
;
static
const
VerifyReflowFlagData
gFlags
[
]
=
{
{
"
verify
"
VerifyReflowFlags
:
:
On
}
{
"
reflow
"
VerifyReflowFlags
:
:
Noisy
}
{
"
all
"
VerifyReflowFlags
:
:
All
}
{
"
list
-
commands
"
VerifyReflowFlags
:
:
DumpCommands
}
{
"
noisy
-
commands
"
VerifyReflowFlags
:
:
NoisyCommands
}
{
"
really
-
noisy
-
commands
"
VerifyReflowFlags
:
:
ReallyNoisyCommands
}
{
"
resize
"
VerifyReflowFlags
:
:
DuringResizeReflow
}
}
;
#
define
NUM_VERIFY_REFLOW_FLAGS
(
sizeof
(
gFlags
)
/
sizeof
(
gFlags
[
0
]
)
)
static
void
ShowVerifyReflowFlags
(
)
{
printf
(
"
Here
are
the
available
GECKO_VERIFY_REFLOW_FLAGS
:
\
n
"
)
;
const
VerifyReflowFlagData
*
flag
=
gFlags
;
const
VerifyReflowFlagData
*
limit
=
gFlags
+
NUM_VERIFY_REFLOW_FLAGS
;
while
(
flag
<
limit
)
{
printf
(
"
%
s
\
n
"
flag
-
>
name
)
;
+
+
flag
;
}
printf
(
"
Note
:
GECKO_VERIFY_REFLOW_FLAGS
is
a
comma
separated
list
of
flag
\
n
"
)
;
printf
(
"
names
(
no
whitespace
)
\
n
"
)
;
}
#
endif
#
ifdef
MOZ_REFLOW_PERF
class
ReflowCountMgr
;
static
const
char
kGrandTotalsStr
[
]
=
"
Grand
Totals
"
;
class
ReflowCounter
{
public
:
explicit
ReflowCounter
(
ReflowCountMgr
*
aMgr
=
nullptr
)
;
~
ReflowCounter
(
)
;
void
ClearTotals
(
)
;
void
DisplayTotals
(
const
char
*
aStr
)
;
void
DisplayDiffTotals
(
const
char
*
aStr
)
;
void
DisplayHTMLTotals
(
const
char
*
aStr
)
;
void
Add
(
)
{
mTotal
+
+
;
}
void
Add
(
uint32_t
aTotal
)
{
mTotal
+
=
aTotal
;
}
void
CalcDiffInTotals
(
)
;
void
SetTotalsCache
(
)
;
void
SetMgr
(
ReflowCountMgr
*
aMgr
)
{
mMgr
=
aMgr
;
}
uint32_t
GetTotal
(
)
{
return
mTotal
;
}
protected
:
void
DisplayTotals
(
uint32_t
aTotal
const
char
*
aTitle
)
;
void
DisplayHTMLTotals
(
uint32_t
aTotal
const
char
*
aTitle
)
;
uint32_t
mTotal
;
uint32_t
mCacheTotal
;
ReflowCountMgr
*
mMgr
;
}
;
class
IndiReflowCounter
{
public
:
explicit
IndiReflowCounter
(
ReflowCountMgr
*
aMgr
=
nullptr
)
:
mFrame
(
nullptr
)
mCount
(
0
)
mMgr
(
aMgr
)
mCounter
(
aMgr
)
mHasBeenOutput
(
false
)
{
}
virtual
~
IndiReflowCounter
(
)
=
default
;
nsAutoString
mName
;
nsIFrame
*
mFrame
;
int32_t
mCount
;
ReflowCountMgr
*
mMgr
;
ReflowCounter
mCounter
;
bool
mHasBeenOutput
;
}
;
class
ReflowCountMgr
{
public
:
ReflowCountMgr
(
)
;
virtual
~
ReflowCountMgr
(
)
;
void
ClearTotals
(
)
;
void
ClearGrandTotals
(
)
;
void
DisplayTotals
(
const
char
*
aStr
)
;
void
DisplayHTMLTotals
(
const
char
*
aStr
)
;
void
DisplayDiffsInTotals
(
)
;
void
Add
(
const
char
*
aName
nsIFrame
*
aFrame
)
;
ReflowCounter
*
LookUp
(
const
char
*
aName
)
;
void
PaintCount
(
const
char
*
aName
gfxContext
*
aRenderingContext
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
const
nsPoint
&
aOffset
uint32_t
aColor
)
;
FILE
*
GetOutFile
(
)
{
return
mFD
;
}
void
SetPresContext
(
nsPresContext
*
aPresContext
)
{
mPresContext
=
aPresContext
;
}
void
SetPresShell
(
PresShell
*
aPresShell
)
{
mPresShell
=
aPresShell
;
}
void
SetDumpFrameCounts
(
bool
aVal
)
{
mDumpFrameCounts
=
aVal
;
}
void
SetDumpFrameByFrameCounts
(
bool
aVal
)
{
mDumpFrameByFrameCounts
=
aVal
;
}
void
SetPaintFrameCounts
(
bool
aVal
)
{
mPaintFrameByFrameCounts
=
aVal
;
}
bool
IsPaintingFrameCounts
(
)
{
return
mPaintFrameByFrameCounts
;
}
protected
:
void
DisplayTotals
(
uint32_t
aTotal
uint32_t
*
aDupArray
char
*
aTitle
)
;
void
DisplayHTMLTotals
(
uint32_t
aTotal
uint32_t
*
aDupArray
char
*
aTitle
)
;
void
DoGrandTotals
(
)
;
void
DoIndiTotalsTree
(
)
;
void
DoGrandHTMLTotals
(
)
;
nsClassHashtable
<
nsCharPtrHashKey
ReflowCounter
>
mCounts
;
nsClassHashtable
<
nsCharPtrHashKey
IndiReflowCounter
>
mIndiFrameCounts
;
FILE
*
mFD
;
bool
mDumpFrameCounts
;
bool
mDumpFrameByFrameCounts
;
bool
mPaintFrameByFrameCounts
;
bool
mCycledOnce
;
nsPresContext
*
mPresContext
;
PresShell
*
mPresShell
;
}
;
#
endif
#
define
SHOW_CARET
#
define
NS_MAX_REFLOW_TIME
1000000
static
int32_t
gMaxRCProcessingTime
=
-
1
;
struct
nsCallbackEventRequest
{
nsIReflowCallback
*
callback
;
nsCallbackEventRequest
*
next
;
}
;
#
ifdef
DEBUG
#
define
ASSERT_REFLOW_SCHEDULED_STATE
(
)
\
{
\
if
(
ObservingLayoutFlushes
(
)
)
{
\
MOZ_ASSERT
(
\
mDocument
-
>
GetBFCacheEntry
(
)
|
|
\
mPresContext
-
>
RefreshDriver
(
)
-
>
IsLayoutFlushObserver
(
this
)
\
"
Unexpected
state
"
)
;
\
}
else
{
\
MOZ_ASSERT
(
\
!
mPresContext
-
>
RefreshDriver
(
)
-
>
IsLayoutFlushObserver
(
this
)
\
"
Unexpected
state
"
)
;
\
}
\
}
#
else
#
define
ASSERT_REFLOW_SCHEDULED_STATE
(
)
#
endif
class
nsAutoCauseReflowNotifier
{
public
:
MOZ_CAN_RUN_SCRIPT
explicit
nsAutoCauseReflowNotifier
(
PresShell
*
aPresShell
)
:
mPresShell
(
aPresShell
)
{
mPresShell
-
>
WillCauseReflow
(
)
;
}
MOZ_CAN_RUN_SCRIPT
~
nsAutoCauseReflowNotifier
(
)
{
if
(
!
mPresShell
-
>
mHaveShutDown
)
{
RefPtr
<
PresShell
>
presShell
(
mPresShell
)
;
presShell
-
>
DidCauseReflow
(
)
;
}
else
{
nsContentUtils
:
:
RemoveScriptBlocker
(
)
;
}
}
PresShell
*
mPresShell
;
}
;
class
MOZ_STACK_CLASS
nsPresShellEventCB
:
public
EventDispatchingCallback
{
public
:
explicit
nsPresShellEventCB
(
PresShell
*
aPresShell
)
:
mPresShell
(
aPresShell
)
{
}
MOZ_CAN_RUN_SCRIPT
virtual
void
HandleEvent
(
EventChainPostVisitor
&
aVisitor
)
override
{
if
(
aVisitor
.
mPresContext
&
&
aVisitor
.
mEvent
-
>
mClass
!
=
eBasicEventClass
)
{
if
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eMouseDown
|
|
aVisitor
.
mEvent
-
>
mMessage
=
=
eMouseUp
)
{
MOZ_KnownLive
(
mPresShell
)
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
}
else
if
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eWheel
&
&
aVisitor
.
mEventStatus
!
=
nsEventStatus_eConsumeNoDefault
)
{
nsIFrame
*
frame
=
mPresShell
-
>
GetCurrentEventFrame
(
)
;
if
(
frame
)
{
RefPtr
<
EventStateManager
>
esm
=
aVisitor
.
mPresContext
-
>
EventStateManager
(
)
;
esm
-
>
DispatchLegacyMouseScrollEvents
(
frame
aVisitor
.
mEvent
-
>
AsWheelEvent
(
)
&
aVisitor
.
mEventStatus
)
;
}
}
nsIFrame
*
frame
=
mPresShell
-
>
GetCurrentEventFrame
(
)
;
if
(
!
frame
&
&
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eMouseUp
|
|
aVisitor
.
mEvent
-
>
mMessage
=
=
eTouchEnd
)
)
{
frame
=
mPresShell
-
>
GetRootFrame
(
)
;
}
if
(
frame
)
{
frame
-
>
HandleEvent
(
aVisitor
.
mPresContext
aVisitor
.
mEvent
-
>
AsGUIEvent
(
)
&
aVisitor
.
mEventStatus
)
;
}
}
}
RefPtr
<
PresShell
>
mPresShell
;
}
;
class
nsBeforeFirstPaintDispatcher
:
public
Runnable
{
public
:
explicit
nsBeforeFirstPaintDispatcher
(
Document
*
aDocument
)
:
mozilla
:
:
Runnable
(
"
nsBeforeFirstPaintDispatcher
"
)
mDocument
(
aDocument
)
{
}
NS_IMETHOD
Run
(
)
override
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
NotifyObservers
(
ToSupports
(
mDocument
)
"
before
-
first
-
paint
"
nullptr
)
;
}
return
NS_OK
;
}
private
:
RefPtr
<
Document
>
mDocument
;
}
;
class
MOZ_STACK_CLASS
AutoPointerEventTargetUpdater
final
{
public
:
AutoPointerEventTargetUpdater
(
PresShell
*
aShell
WidgetEvent
*
aEvent
nsIFrame
*
aFrame
nsIContent
*
*
aTargetContent
)
{
MOZ_ASSERT
(
aEvent
)
;
if
(
!
aTargetContent
|
|
aEvent
-
>
mClass
!
=
ePointerEventClass
)
{
mTargetContent
=
nullptr
;
return
;
}
MOZ_ASSERT
(
aShell
)
;
MOZ_ASSERT
(
aFrame
)
;
MOZ_ASSERT
(
!
aFrame
-
>
GetContent
(
)
|
|
aShell
-
>
GetDocument
(
)
=
=
aFrame
-
>
GetContent
(
)
-
>
OwnerDoc
(
)
)
;
mShell
=
aShell
;
mWeakFrame
=
aFrame
;
mTargetContent
=
aTargetContent
;
mFromTouch
=
aEvent
-
>
AsPointerEvent
(
)
-
>
mFromTouchEvent
;
mOriginalPointerEventTarget
=
aShell
-
>
mPointerEventTarget
=
aFrame
-
>
GetContent
(
)
;
}
~
AutoPointerEventTargetUpdater
(
)
{
if
(
!
mTargetContent
|
|
!
mShell
|
|
mWeakFrame
.
IsAlive
(
)
)
{
return
;
}
if
(
mFromTouch
)
{
mOriginalPointerEventTarget
.
swap
(
*
mTargetContent
)
;
}
else
{
mShell
-
>
mPointerEventTarget
.
swap
(
*
mTargetContent
)
;
}
}
private
:
RefPtr
<
PresShell
>
mShell
;
nsCOMPtr
<
nsIContent
>
mOriginalPointerEventTarget
;
AutoWeakFrame
mWeakFrame
;
nsIContent
*
*
mTargetContent
;
bool
mFromTouch
=
false
;
}
;
bool
PresShell
:
:
sDisableNonTestMouseEvents
=
false
;
int16_t
PresShell
:
:
sMouseButtons
=
MouseButtonsFlag
:
:
eNoButtons
;
LazyLogModule
PresShell
:
:
gLog
(
"
PresShell
"
)
;
TimeStamp
PresShell
:
:
EventHandler
:
:
sLastInputCreated
;
TimeStamp
PresShell
:
:
EventHandler
:
:
sLastInputProcessed
;
StaticRefPtr
<
Element
>
PresShell
:
:
EventHandler
:
:
sLastKeyDownEventTargetElement
;
bool
PresShell
:
:
sProcessInteractable
=
false
;
static
bool
gVerifyReflowEnabled
;
bool
PresShell
:
:
GetVerifyReflowEnable
(
)
{
#
ifdef
DEBUG
static
bool
firstTime
=
true
;
if
(
firstTime
)
{
firstTime
=
false
;
char
*
flags
=
PR_GetEnv
(
"
GECKO_VERIFY_REFLOW_FLAGS
"
)
;
if
(
flags
)
{
bool
error
=
false
;
for
(
;
;
)
{
char
*
comma
=
strchr
(
flags
'
'
)
;
if
(
comma
)
*
comma
=
'
\
0
'
;
bool
found
=
false
;
const
VerifyReflowFlagData
*
flag
=
gFlags
;
const
VerifyReflowFlagData
*
limit
=
gFlags
+
NUM_VERIFY_REFLOW_FLAGS
;
while
(
flag
<
limit
)
{
if
(
nsCRT
:
:
strcasecmp
(
flag
-
>
name
flags
)
=
=
0
)
{
gVerifyReflowFlags
|
=
flag
-
>
bit
;
found
=
true
;
break
;
}
+
+
flag
;
}
if
(
!
found
)
error
=
true
;
if
(
!
comma
)
break
;
*
comma
=
'
'
;
flags
=
comma
+
1
;
}
if
(
error
)
ShowVerifyReflowFlags
(
)
;
}
if
(
VerifyReflowFlags
:
:
On
&
gVerifyReflowFlags
)
{
gVerifyReflowEnabled
=
true
;
printf
(
"
Note
:
verifyreflow
is
enabled
"
)
;
if
(
VerifyReflowFlags
:
:
Noisy
&
gVerifyReflowFlags
)
{
printf
(
"
(
noisy
)
"
)
;
}
if
(
VerifyReflowFlags
:
:
All
&
gVerifyReflowFlags
)
{
printf
(
"
(
all
)
"
)
;
}
if
(
VerifyReflowFlags
:
:
DumpCommands
&
gVerifyReflowFlags
)
{
printf
(
"
(
show
reflow
commands
)
"
)
;
}
if
(
VerifyReflowFlags
:
:
NoisyCommands
&
gVerifyReflowFlags
)
{
printf
(
"
(
noisy
reflow
commands
)
"
)
;
if
(
VerifyReflowFlags
:
:
ReallyNoisyCommands
&
gVerifyReflowFlags
)
{
printf
(
"
(
REALLY
noisy
reflow
commands
)
"
)
;
}
}
printf
(
"
\
n
"
)
;
}
}
#
endif
return
gVerifyReflowEnabled
;
}
void
PresShell
:
:
SetVerifyReflowEnable
(
bool
aEnabled
)
{
gVerifyReflowEnabled
=
aEnabled
;
}
void
PresShell
:
:
AddAutoWeakFrame
(
AutoWeakFrame
*
aWeakFrame
)
{
if
(
aWeakFrame
-
>
GetFrame
(
)
)
{
aWeakFrame
-
>
GetFrame
(
)
-
>
AddStateBits
(
NS_FRAME_EXTERNAL_REFERENCE
)
;
}
aWeakFrame
-
>
SetPreviousWeakFrame
(
mAutoWeakFrames
)
;
mAutoWeakFrames
=
aWeakFrame
;
}
void
PresShell
:
:
AddWeakFrame
(
WeakFrame
*
aWeakFrame
)
{
if
(
aWeakFrame
-
>
GetFrame
(
)
)
{
aWeakFrame
-
>
GetFrame
(
)
-
>
AddStateBits
(
NS_FRAME_EXTERNAL_REFERENCE
)
;
}
MOZ_ASSERT
(
!
mWeakFrames
.
Contains
(
aWeakFrame
)
)
;
mWeakFrames
.
Insert
(
aWeakFrame
)
;
}
void
PresShell
:
:
RemoveAutoWeakFrame
(
AutoWeakFrame
*
aWeakFrame
)
{
if
(
mAutoWeakFrames
=
=
aWeakFrame
)
{
mAutoWeakFrames
=
aWeakFrame
-
>
GetPreviousWeakFrame
(
)
;
return
;
}
AutoWeakFrame
*
nextWeak
=
mAutoWeakFrames
;
while
(
nextWeak
&
&
nextWeak
-
>
GetPreviousWeakFrame
(
)
!
=
aWeakFrame
)
{
nextWeak
=
nextWeak
-
>
GetPreviousWeakFrame
(
)
;
}
if
(
nextWeak
)
{
nextWeak
-
>
SetPreviousWeakFrame
(
aWeakFrame
-
>
GetPreviousWeakFrame
(
)
)
;
}
}
void
PresShell
:
:
RemoveWeakFrame
(
WeakFrame
*
aWeakFrame
)
{
MOZ_ASSERT
(
mWeakFrames
.
Contains
(
aWeakFrame
)
)
;
mWeakFrames
.
Remove
(
aWeakFrame
)
;
}
already_AddRefed
<
nsFrameSelection
>
PresShell
:
:
FrameSelection
(
)
{
RefPtr
<
nsFrameSelection
>
ret
=
mSelection
;
return
ret
.
forget
(
)
;
}
static
uint32_t
sNextPresShellId
=
0
;
bool
PresShell
:
:
AccessibleCaretEnabled
(
nsIDocShell
*
aDocShell
)
{
if
(
StaticPrefs
:
:
layout_accessiblecaret_enabled
(
)
)
{
return
true
;
}
if
(
StaticPrefs
:
:
layout_accessiblecaret_enabled_on_touch
(
)
&
&
dom
:
:
TouchEvent
:
:
PrefEnabled
(
aDocShell
)
)
{
return
true
;
}
return
false
;
}
PresShell
:
:
PresShell
(
Document
*
aDocument
)
:
mDocument
(
aDocument
)
mViewManager
(
nullptr
)
mFrameManager
(
nullptr
)
mAutoWeakFrames
(
nullptr
)
#
ifdef
ACCESSIBILITY
mDocAccessible
(
nullptr
)
#
endif
mCurrentEventFrame
(
nullptr
)
mMouseLocation
(
NS_UNCONSTRAINEDSIZE
NS_UNCONSTRAINEDSIZE
)
mLastResolutionChangeOrigin
(
ResolutionChangeOrigin
:
:
Apz
)
mPaintCount
(
0
)
mAPZFocusSequenceNumber
(
0
)
mActiveSuppressDisplayport
(
0
)
mPresShellId
(
+
+
sNextPresShellId
)
mFontSizeInflationEmPerLine
(
0
)
mFontSizeInflationMinTwips
(
0
)
mFontSizeInflationLineThreshold
(
0
)
mSelectionFlags
(
nsISelectionDisplay
:
:
DISPLAY_TEXT
|
nsISelectionDisplay
:
:
DISPLAY_IMAGES
)
mChangeNestCount
(
0
)
mRenderingStateFlags
(
RenderingStateFlags
:
:
None
)
mInFlush
(
false
)
mCaretEnabled
(
false
)
mNeedLayoutFlush
(
true
)
mNeedStyleFlush
(
true
)
mNeedThrottledAnimationFlush
(
true
)
mVisualViewportSizeSet
(
false
)
mDidInitialize
(
false
)
mIsDestroying
(
false
)
mIsReflowing
(
false
)
mIsObservingDocument
(
false
)
mForbiddenToFlush
(
false
)
mIsDocumentGone
(
false
)
mHaveShutDown
(
false
)
mPaintingSuppressed
(
false
)
mLastRootReflowHadUnconstrainedBSize
(
false
)
mShouldUnsuppressPainting
(
false
)
mIgnoreFrameDestruction
(
false
)
mIsActive
(
true
)
mFrozen
(
false
)
mIsFirstPaint
(
true
)
mObservesMutationsForPrint
(
false
)
mWasLastReflowInterrupted
(
false
)
mObservingStyleFlushes
(
false
)
mObservingLayoutFlushes
(
false
)
mResizeEventPending
(
false
)
mFontSizeInflationForceEnabled
(
false
)
mFontSizeInflationDisabledInMasterProcess
(
false
)
mFontSizeInflationEnabled
(
false
)
mIsNeverPainting
(
false
)
mResolutionUpdated
(
false
)
mResolutionUpdatedByApz
(
false
)
mUnderHiddenEmbedderElement
(
false
)
mDocumentLoading
(
false
)
mNoDelayedMouseEvents
(
false
)
mNoDelayedKeyEvents
(
false
)
mApproximateFrameVisibilityVisited
(
false
)
mIsLastChromeOnlyEscapeKeyConsumed
(
false
)
mHasReceivedPaintMessage
(
false
)
mIsLastKeyDownCanceled
(
false
)
mHasHandledUserInput
(
false
)
mForceDispatchKeyPressEventsForNonPrintableKeys
(
false
)
mForceUseLegacyKeyCodeAndCharCodeValues
(
false
)
mInitializedWithKeyPressEventDispatchingBlacklist
(
false
)
mMouseLocationWasSetBySynthesizedMouseEventForTests
(
false
)
mHasTriedFastUnsuppress
(
false
)
mProcessingReflowCommands
(
false
)
mPendingDidDoReflow
(
false
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Debug
(
"
PresShell
:
:
PresShell
this
=
%
p
"
this
)
)
;
MOZ_ASSERT
(
aDocument
)
;
#
ifdef
MOZ_REFLOW_PERF
mReflowCountMgr
=
MakeUnique
<
ReflowCountMgr
>
(
)
;
mReflowCountMgr
-
>
SetPresContext
(
mPresContext
)
;
mReflowCountMgr
-
>
SetPresShell
(
this
)
;
#
endif
mLastOSWake
=
mLoadBegin
=
TimeStamp
:
:
Now
(
)
;
}
NS_INTERFACE_TABLE_HEAD
(
PresShell
)
NS_INTERFACE_TABLE_BEGIN
NS_INTERFACE_TABLE_ENTRY
(
PresShell
PresShell
)
NS_INTERFACE_TABLE_ENTRY
(
PresShell
nsIDocumentObserver
)
NS_INTERFACE_TABLE_ENTRY
(
PresShell
nsISelectionController
)
NS_INTERFACE_TABLE_ENTRY
(
PresShell
nsISelectionDisplay
)
NS_INTERFACE_TABLE_ENTRY
(
PresShell
nsIObserver
)
NS_INTERFACE_TABLE_ENTRY
(
PresShell
nsISupportsWeakReference
)
NS_INTERFACE_TABLE_ENTRY
(
PresShell
nsIMutationObserver
)
NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS
(
PresShell
nsISupports
nsIObserver
)
NS_INTERFACE_TABLE_END
NS_INTERFACE_TABLE_TO_MAP_SEGUE
NS_INTERFACE_MAP_END
NS_IMPL_ADDREF
(
PresShell
)
NS_IMPL_RELEASE
(
PresShell
)
PresShell
:
:
~
PresShell
(
)
{
MOZ_RELEASE_ASSERT
(
!
mForbiddenToFlush
"
Flag
should
only
be
set
temporarily
while
doing
things
"
"
that
shouldn
'
t
cause
destruction
"
)
;
MOZ_LOG
(
gLog
LogLevel
:
:
Debug
(
"
PresShell
:
:
~
PresShell
this
=
%
p
"
this
)
)
;
if
(
!
mHaveShutDown
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Someone
did
not
call
PresShell
:
:
Destroy
(
)
"
)
;
Destroy
(
)
;
}
NS_ASSERTION
(
mCurrentEventContentStack
.
Count
(
)
=
=
0
"
Huh
event
content
left
on
the
stack
in
pres
shell
dtor
!
"
)
;
NS_ASSERTION
(
mFirstCallbackEventRequest
=
=
nullptr
&
&
mLastCallbackEventRequest
=
=
nullptr
"
post
-
reflow
queues
not
empty
.
This
means
we
'
re
leaking
"
)
;
MOZ_ASSERT
(
!
mAllocatedPointers
|
|
mAllocatedPointers
-
>
IsEmpty
(
)
"
Some
pres
arena
objects
were
not
freed
"
)
;
mFrameManager
=
nullptr
;
mFrameConstructor
=
nullptr
;
mCurrentEventContent
=
nullptr
;
}
void
PresShell
:
:
Init
(
nsPresContext
*
aPresContext
nsViewManager
*
aViewManager
)
{
MOZ_ASSERT
(
mDocument
)
;
MOZ_ASSERT
(
aPresContext
)
;
MOZ_ASSERT
(
aViewManager
)
;
MOZ_ASSERT
(
!
mViewManager
"
already
initialized
"
)
;
mViewManager
=
aViewManager
;
SetNeedLayoutFlush
(
)
;
SetNeedStyleFlush
(
)
;
mFrameConstructor
=
MakeUnique
<
nsCSSFrameConstructor
>
(
mDocument
this
)
;
mFrameManager
=
mFrameConstructor
.
get
(
)
;
mViewManager
-
>
SetPresShell
(
this
)
;
const_cast
<
RefPtr
<
nsPresContext
>
&
>
(
mPresContext
)
=
aPresContext
;
mPresContext
-
>
AttachPresShell
(
this
)
;
mPresContext
-
>
InitFontCache
(
)
;
EnsureStyleFlush
(
)
;
const
bool
accessibleCaretEnabled
=
AccessibleCaretEnabled
(
mDocument
-
>
GetDocShell
(
)
)
;
if
(
accessibleCaretEnabled
)
{
mAccessibleCaretEventHub
=
new
AccessibleCaretEventHub
(
this
)
;
mAccessibleCaretEventHub
-
>
Init
(
)
;
}
mSelection
=
new
nsFrameSelection
(
this
nullptr
accessibleCaretEnabled
)
;
#
ifdef
SHOW_CARET
mCaret
=
new
nsCaret
(
)
;
mCaret
-
>
Init
(
this
)
;
mOriginalCaret
=
mCaret
;
#
endif
nsPresContext
:
:
nsPresContextType
type
=
mPresContext
-
>
Type
(
)
;
if
(
type
!
=
nsPresContext
:
:
eContext_PrintPreview
&
&
type
!
=
nsPresContext
:
:
eContext_Print
)
{
SetDisplaySelection
(
nsISelectionController
:
:
SELECTION_DISABLED
)
;
}
if
(
gMaxRCProcessingTime
=
=
-
1
)
{
gMaxRCProcessingTime
=
Preferences
:
:
GetInt
(
"
layout
.
reflow
.
timeslice
"
NS_MAX_REFLOW_TIME
)
;
}
if
(
nsStyleSheetService
*
ss
=
nsStyleSheetService
:
:
GetInstance
(
)
)
{
ss
-
>
RegisterPresShell
(
this
)
;
}
{
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
os
-
>
AddObserver
(
this
"
memory
-
pressure
"
false
)
;
os
-
>
AddObserver
(
this
NS_WIDGET_WAKE_OBSERVER_TOPIC
false
)
;
if
(
XRE_IsParentProcess
(
)
&
&
!
sProcessInteractable
)
{
os
-
>
AddObserver
(
this
"
sessionstore
-
one
-
or
-
no
-
tab
-
restored
"
false
)
;
}
os
-
>
AddObserver
(
this
"
font
-
info
-
updated
"
false
)
;
os
-
>
AddObserver
(
this
"
internal
-
look
-
and
-
feel
-
changed
"
false
)
;
}
}
#
ifdef
MOZ_REFLOW_PERF
if
(
mReflowCountMgr
)
{
bool
paintFrameCounts
=
Preferences
:
:
GetBool
(
"
layout
.
reflow
.
showframecounts
"
)
;
bool
dumpFrameCounts
=
Preferences
:
:
GetBool
(
"
layout
.
reflow
.
dumpframecounts
"
)
;
bool
dumpFrameByFrameCounts
=
Preferences
:
:
GetBool
(
"
layout
.
reflow
.
dumpframebyframecounts
"
)
;
mReflowCountMgr
-
>
SetDumpFrameCounts
(
dumpFrameCounts
)
;
mReflowCountMgr
-
>
SetDumpFrameByFrameCounts
(
dumpFrameByFrameCounts
)
;
mReflowCountMgr
-
>
SetPaintFrameCounts
(
paintFrameCounts
)
;
}
#
endif
if
(
mDocument
-
>
HasAnimationController
(
)
)
{
SMILAnimationController
*
animCtrl
=
mDocument
-
>
GetAnimationController
(
)
;
animCtrl
-
>
NotifyRefreshDriverCreated
(
GetPresContext
(
)
-
>
RefreshDriver
(
)
)
;
}
for
(
DocumentTimeline
*
timeline
:
mDocument
-
>
Timelines
(
)
)
{
timeline
-
>
NotifyRefreshDriverCreated
(
GetPresContext
(
)
-
>
RefreshDriver
(
)
)
;
}
ActivenessMaybeChanged
(
)
;
mFontSizeInflationEmPerLine
=
StaticPrefs
:
:
font_size_inflation_emPerLine
(
)
;
mFontSizeInflationMinTwips
=
StaticPrefs
:
:
font_size_inflation_minTwips
(
)
;
mFontSizeInflationLineThreshold
=
StaticPrefs
:
:
font_size_inflation_lineThreshold
(
)
;
mFontSizeInflationForceEnabled
=
StaticPrefs
:
:
font_size_inflation_forceEnabled
(
)
;
mFontSizeInflationDisabledInMasterProcess
=
StaticPrefs
:
:
font_size_inflation_disabledInMasterProcess
(
)
;
mTouchManager
.
Init
(
this
mDocument
)
;
if
(
mPresContext
-
>
IsRootContentDocumentCrossProcess
(
)
)
{
mZoomConstraintsClient
=
new
ZoomConstraintsClient
(
)
;
mZoomConstraintsClient
-
>
Init
(
this
mDocument
)
;
MaybeRecreateMobileViewportManager
(
false
)
;
}
if
(
nsCOMPtr
<
nsIDocShell
>
docShell
=
mPresContext
-
>
GetDocShell
(
)
)
{
if
(
BrowsingContext
*
bc
=
docShell
-
>
GetBrowsingContext
(
)
)
{
mUnderHiddenEmbedderElement
=
bc
-
>
IsUnderHiddenEmbedderElement
(
)
;
}
}
}
enum
TextPerfLogType
{
eLog_reflow
eLog_loaddone
eLog_totals
}
;
static
void
LogTextPerfStats
(
gfxTextPerfMetrics
*
aTextPerf
PresShell
*
aPresShell
const
gfxTextPerfMetrics
:
:
TextCounts
&
aCounts
float
aTime
TextPerfLogType
aLogType
const
char
*
aURL
)
{
LogModule
*
tpLog
=
gfxPlatform
:
:
GetLog
(
eGfxLog_textperf
)
;
mozilla
:
:
LogLevel
logLevel
=
LogLevel
:
:
Warning
;
if
(
aCounts
.
numContentTextRuns
=
=
0
)
{
logLevel
=
LogLevel
:
:
Debug
;
}
if
(
!
MOZ_LOG_TEST
(
tpLog
logLevel
)
)
{
return
;
}
char
prefix
[
256
]
;
switch
(
aLogType
)
{
case
eLog_reflow
:
SprintfLiteral
(
prefix
"
(
textperf
-
reflow
)
%
p
time
-
ms
:
%
7
.
0f
"
aPresShell
aTime
)
;
break
;
case
eLog_loaddone
:
SprintfLiteral
(
prefix
"
(
textperf
-
loaddone
)
%
p
time
-
ms
:
%
7
.
0f
"
aPresShell
aTime
)
;
break
;
default
:
MOZ_ASSERT
(
aLogType
=
=
eLog_totals
"
unknown
textperf
log
type
"
)
;
SprintfLiteral
(
prefix
"
(
textperf
-
totals
)
%
p
"
aPresShell
)
;
}
double
hitRatio
=
0
.
0
;
uint32_t
lookups
=
aCounts
.
wordCacheHit
+
aCounts
.
wordCacheMiss
;
if
(
lookups
)
{
hitRatio
=
double
(
aCounts
.
wordCacheHit
)
/
double
(
lookups
)
;
}
if
(
aLogType
=
=
eLog_loaddone
)
{
MOZ_LOG
(
tpLog
logLevel
(
"
%
s
reflow
:
%
d
chars
:
%
d
"
"
[
%
s
]
"
"
content
-
textruns
:
%
d
chrome
-
textruns
:
%
d
"
"
max
-
textrun
-
len
:
%
d
"
"
word
-
cache
-
lookups
:
%
d
word
-
cache
-
hit
-
ratio
:
%
4
.
3f
"
"
word
-
cache
-
space
:
%
d
word
-
cache
-
long
:
%
d
"
"
pref
-
fallbacks
:
%
d
system
-
fallbacks
:
%
d
"
"
textruns
-
const
:
%
d
textruns
-
destr
:
%
d
"
"
generic
-
lookups
:
%
d
"
"
cumulative
-
textruns
-
destr
:
%
d
\
n
"
prefix
aTextPerf
-
>
reflowCount
aCounts
.
numChars
(
aURL
?
aURL
:
"
"
)
aCounts
.
numContentTextRuns
aCounts
.
numChromeTextRuns
aCounts
.
maxTextRunLen
lookups
hitRatio
aCounts
.
wordCacheSpaceRules
aCounts
.
wordCacheLong
aCounts
.
fallbackPrefs
aCounts
.
fallbackSystem
aCounts
.
textrunConst
aCounts
.
textrunDestr
aCounts
.
genericLookups
aTextPerf
-
>
cumulative
.
textrunDestr
)
)
;
}
else
{
MOZ_LOG
(
tpLog
logLevel
(
"
%
s
reflow
:
%
d
chars
:
%
d
"
"
content
-
textruns
:
%
d
chrome
-
textruns
:
%
d
"
"
max
-
textrun
-
len
:
%
d
"
"
word
-
cache
-
lookups
:
%
d
word
-
cache
-
hit
-
ratio
:
%
4
.
3f
"
"
word
-
cache
-
space
:
%
d
word
-
cache
-
long
:
%
d
"
"
pref
-
fallbacks
:
%
d
system
-
fallbacks
:
%
d
"
"
textruns
-
const
:
%
d
textruns
-
destr
:
%
d
"
"
generic
-
lookups
:
%
d
"
"
cumulative
-
textruns
-
destr
:
%
d
\
n
"
prefix
aTextPerf
-
>
reflowCount
aCounts
.
numChars
aCounts
.
numContentTextRuns
aCounts
.
numChromeTextRuns
aCounts
.
maxTextRunLen
lookups
hitRatio
aCounts
.
wordCacheSpaceRules
aCounts
.
wordCacheLong
aCounts
.
fallbackPrefs
aCounts
.
fallbackSystem
aCounts
.
textrunConst
aCounts
.
textrunDestr
aCounts
.
genericLookups
aTextPerf
-
>
cumulative
.
textrunDestr
)
)
;
}
}
bool
PresShell
:
:
InRDMPane
(
)
{
if
(
Document
*
doc
=
GetDocument
(
)
)
{
if
(
BrowsingContext
*
bc
=
doc
-
>
GetBrowsingContext
(
)
)
{
return
bc
-
>
InRDMPane
(
)
;
}
}
return
false
;
}
#
if
defined
(
MOZ_WIDGET_ANDROID
)
void
PresShell
:
:
MaybeNotifyShowDynamicToolbar
(
)
{
const
DynamicToolbarState
dynToolbarState
=
GetDynamicToolbarState
(
)
;
if
(
(
dynToolbarState
=
=
DynamicToolbarState
:
:
Collapsed
|
|
dynToolbarState
=
=
DynamicToolbarState
:
:
InTransition
)
)
{
MOZ_ASSERT
(
mPresContext
&
&
mPresContext
-
>
IsRootContentDocumentCrossProcess
(
)
)
;
if
(
BrowserChild
*
browserChild
=
BrowserChild
:
:
GetFrom
(
this
)
)
{
browserChild
-
>
SendShowDynamicToolbar
(
)
;
}
}
}
#
endif
void
PresShell
:
:
Destroy
(
)
{
if
(
mHaveShutDown
)
{
return
;
}
NS_ASSERTION
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
destroy
called
on
presshell
while
scripts
not
blocked
"
)
;
[
[
maybe_unused
]
]
nsIURI
*
uri
=
mDocument
-
>
GetDocumentURI
(
)
;
AUTO_PROFILER_LABEL_DYNAMIC_NSCSTRING_RELEVANT_FOR_JS
(
"
Layout
tree
destruction
"
LAYOUT_Destroy
uri
?
uri
-
>
GetSpecOrDefault
(
)
:
"
N
/
A
"
_ns
)
;
auto
isUserZoomablePage
=
[
&
]
(
)
-
>
bool
{
if
(
mIsFirstPaint
)
{
return
false
;
}
if
(
!
mPresContext
-
>
IsRootContentDocumentCrossProcess
(
)
)
{
return
false
;
}
if
(
InRDMPane
(
)
)
{
return
false
;
}
if
(
mDocument
&
&
mDocument
-
>
IsInitialDocument
(
)
)
{
return
false
;
}
if
(
XRE_IsContentProcess
(
)
&
&
IsExtensionRemoteType
(
ContentChild
:
:
GetSingleton
(
)
-
>
GetRemoteType
(
)
)
)
{
return
false
;
}
return
true
;
}
;
if
(
isUserZoomablePage
(
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
APZ_ZOOM_ACTIVITY
IsResolutionUpdatedByApz
(
)
)
;
}
gfxTextPerfMetrics
*
tp
;
if
(
mPresContext
&
&
(
tp
=
mPresContext
-
>
GetTextPerfMetrics
(
)
)
)
{
tp
-
>
Accumulate
(
)
;
if
(
tp
-
>
cumulative
.
numChars
>
0
)
{
LogTextPerfStats
(
tp
this
tp
-
>
cumulative
0
.
0
eLog_totals
nullptr
)
;
}
}
if
(
mPresContext
)
{
if
(
gfxUserFontSet
*
fs
=
mPresContext
-
>
GetUserFontSet
(
)
)
{
uint32_t
fontCount
;
uint64_t
fontSize
;
fs
-
>
GetLoadStatistics
(
fontCount
fontSize
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
WEBFONT_PER_PAGE
fontCount
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
WEBFONT_SIZE_PER_PAGE
uint32_t
(
fontSize
/
1024
)
)
;
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
WEBFONT_PER_PAGE
0
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
WEBFONT_SIZE_PER_PAGE
0
)
;
}
}
#
ifdef
MOZ_REFLOW_PERF
DumpReflows
(
)
;
mReflowCountMgr
=
nullptr
;
#
endif
if
(
mZoomConstraintsClient
)
{
mZoomConstraintsClient
-
>
Destroy
(
)
;
mZoomConstraintsClient
=
nullptr
;
}
if
(
mMobileViewportManager
)
{
mMobileViewportManager
-
>
Destroy
(
)
;
mMobileViewportManager
=
nullptr
;
mMVMContext
=
nullptr
;
}
#
ifdef
ACCESSIBILITY
if
(
mDocAccessible
)
{
#
ifdef
DEBUG
if
(
a11y
:
:
logging
:
:
IsEnabled
(
a11y
:
:
logging
:
:
eDocDestroy
)
)
a11y
:
:
logging
:
:
DocDestroy
(
"
presshell
destroyed
"
mDocument
)
;
#
endif
mDocAccessible
-
>
Shutdown
(
)
;
mDocAccessible
=
nullptr
;
}
#
endif
MaybeReleaseCapturingContent
(
)
;
EventHandler
:
:
OnPresShellDestroy
(
mDocument
)
;
if
(
mContentToScrollTo
)
{
mContentToScrollTo
-
>
RemoveProperty
(
nsGkAtoms
:
:
scrolling
)
;
mContentToScrollTo
=
nullptr
;
}
if
(
mPresContext
)
{
mPresContext
-
>
EventStateManager
(
)
-
>
NotifyDestroyPresContext
(
mPresContext
)
;
}
if
(
nsStyleSheetService
*
ss
=
nsStyleSheetService
:
:
GetInstance
(
)
)
{
ss
-
>
UnregisterPresShell
(
this
)
;
}
{
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
os
-
>
RemoveObserver
(
this
"
memory
-
pressure
"
)
;
os
-
>
RemoveObserver
(
this
NS_WIDGET_WAKE_OBSERVER_TOPIC
)
;
if
(
XRE_IsParentProcess
(
)
)
{
os
-
>
RemoveObserver
(
this
"
sessionstore
-
one
-
or
-
no
-
tab
-
restored
"
)
;
}
os
-
>
RemoveObserver
(
this
"
font
-
info
-
updated
"
)
;
os
-
>
RemoveObserver
(
this
"
internal
-
look
-
and
-
feel
-
changed
"
)
;
}
}
CancelPaintSuppressionTimer
(
)
;
if
(
mReflowContinueTimer
)
{
mReflowContinueTimer
-
>
Cancel
(
)
;
mReflowContinueTimer
=
nullptr
;
}
mSynthMouseMoveEvent
.
Revoke
(
)
;
mUpdateApproximateFrameVisibilityEvent
.
Revoke
(
)
;
ClearApproximatelyVisibleFramesList
(
Some
(
OnNonvisible
:
:
DiscardImages
)
)
;
if
(
mCaret
)
{
mCaret
-
>
Terminate
(
)
;
mCaret
=
nullptr
;
}
mFocusedFrameSelection
=
nullptr
;
if
(
mSelection
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
mSelection
;
frameSelection
-
>
DisconnectFromPresShell
(
)
;
}
mIsDestroying
=
true
;
mCurrentEventFrame
=
nullptr
;
int32_t
i
count
=
mCurrentEventFrameStack
.
Length
(
)
;
for
(
i
=
0
;
i
<
count
;
i
+
+
)
{
mCurrentEventFrameStack
[
i
]
=
nullptr
;
}
mFramesToDirty
.
Clear
(
)
;
mPendingScrollAnchorSelection
.
Clear
(
)
;
mPendingScrollAnchorAdjustment
.
Clear
(
)
;
mPendingScrollResnap
.
Clear
(
)
;
if
(
mViewManager
)
{
mViewManager
-
>
SetPresShell
(
nullptr
)
;
mViewManager
=
nullptr
;
}
nsRefreshDriver
*
rd
=
GetPresContext
(
)
-
>
RefreshDriver
(
)
;
if
(
mDocument
)
{
NS_ASSERTION
(
mDocument
-
>
GetPresShell
(
)
=
=
this
"
Wrong
shell
?
"
)
;
mDocument
-
>
ClearServoRestyleRoot
(
)
;
mDocument
-
>
DeletePresShell
(
)
;
if
(
mDocument
-
>
HasAnimationController
(
)
)
{
mDocument
-
>
GetAnimationController
(
)
-
>
NotifyRefreshDriverDestroying
(
rd
)
;
}
for
(
DocumentTimeline
*
timeline
:
mDocument
-
>
Timelines
(
)
)
{
timeline
-
>
NotifyRefreshDriverDestroying
(
rd
)
;
}
}
if
(
mPresContext
)
{
rd
-
>
CancelPendingAnimationEvents
(
mPresContext
-
>
AnimationEventDispatcher
(
)
)
;
}
StopObservingRefreshDriver
(
)
;
if
(
rd
-
>
GetPresContext
(
)
=
=
GetPresContext
(
)
)
{
rd
-
>
RevokeViewManagerFlush
(
)
;
rd
-
>
ClearHasScheduleFlush
(
)
;
}
CancelAllPendingReflows
(
)
;
CancelPostedReflowCallbacks
(
)
;
mFrameConstructor
-
>
WillDestroyFrameTree
(
)
;
NS_WARNING_ASSERTION
(
!
mAutoWeakFrames
&
&
mWeakFrames
.
IsEmpty
(
)
"
Weak
frames
alive
after
destroying
FrameManager
"
)
;
while
(
mAutoWeakFrames
)
{
mAutoWeakFrames
-
>
Clear
(
this
)
;
}
const
nsTArray
<
WeakFrame
*
>
weakFrames
=
ToArray
(
mWeakFrames
)
;
for
(
WeakFrame
*
weakFrame
:
weakFrames
)
{
weakFrame
-
>
Clear
(
this
)
;
}
if
(
mAccessibleCaretEventHub
)
{
mAccessibleCaretEventHub
-
>
Terminate
(
)
;
mAccessibleCaretEventHub
=
nullptr
;
}
if
(
mPresContext
)
{
mPresContext
-
>
DetachPresShell
(
)
;
}
mHaveShutDown
=
true
;
mTouchManager
.
Destroy
(
)
;
}
void
PresShell
:
:
StopObservingRefreshDriver
(
)
{
nsRefreshDriver
*
rd
=
mPresContext
-
>
RefreshDriver
(
)
;
if
(
mResizeEventPending
)
{
rd
-
>
RemoveResizeEventFlushObserver
(
this
)
;
}
if
(
mObservingLayoutFlushes
)
{
rd
-
>
RemoveLayoutFlushObserver
(
this
)
;
}
if
(
mObservingStyleFlushes
)
{
rd
-
>
RemoveStyleFlushObserver
(
this
)
;
}
}
void
PresShell
:
:
StartObservingRefreshDriver
(
)
{
nsRefreshDriver
*
rd
=
mPresContext
-
>
RefreshDriver
(
)
;
if
(
mResizeEventPending
)
{
rd
-
>
AddResizeEventFlushObserver
(
this
)
;
}
if
(
mObservingLayoutFlushes
)
{
rd
-
>
AddLayoutFlushObserver
(
this
)
;
}
if
(
mObservingStyleFlushes
)
{
rd
-
>
AddStyleFlushObserver
(
this
)
;
}
}
nsRefreshDriver
*
PresShell
:
:
GetRefreshDriver
(
)
const
{
return
mPresContext
?
mPresContext
-
>
RefreshDriver
(
)
:
nullptr
;
}
void
PresShell
:
:
SetAuthorStyleDisabled
(
bool
aStyleDisabled
)
{
if
(
aStyleDisabled
!
=
StyleSet
(
)
-
>
GetAuthorStyleDisabled
(
)
)
{
StyleSet
(
)
-
>
SetAuthorStyleDisabled
(
aStyleDisabled
)
;
mDocument
-
>
ApplicableStylesChanged
(
)
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
NotifyObservers
(
ToSupports
(
mDocument
)
"
author
-
style
-
disabled
-
changed
"
nullptr
)
;
}
}
}
bool
PresShell
:
:
GetAuthorStyleDisabled
(
)
const
{
return
StyleSet
(
)
-
>
GetAuthorStyleDisabled
(
)
;
}
void
PresShell
:
:
AddUserSheet
(
StyleSheet
*
aSheet
)
{
nsStyleSheetService
*
sheetService
=
nsStyleSheetService
:
:
GetInstance
(
)
;
nsTArray
<
RefPtr
<
StyleSheet
>
>
&
userSheets
=
*
sheetService
-
>
UserStyleSheets
(
)
;
MOZ_ASSERT
(
aSheet
)
;
MOZ_ASSERT
(
userSheets
.
LastElement
(
)
=
=
aSheet
)
;
size_t
index
=
userSheets
.
Length
(
)
-
1
;
for
(
size_t
i
=
0
;
i
<
index
;
+
+
i
)
{
MOZ_ASSERT
(
StyleSet
(
)
-
>
SheetAt
(
StyleOrigin
:
:
User
i
)
=
=
userSheets
[
i
]
)
;
}
if
(
index
=
=
static_cast
<
size_t
>
(
StyleSet
(
)
-
>
SheetCount
(
StyleOrigin
:
:
User
)
)
)
{
StyleSet
(
)
-
>
AppendStyleSheet
(
*
aSheet
)
;
}
else
{
StyleSheet
*
ref
=
StyleSet
(
)
-
>
SheetAt
(
StyleOrigin
:
:
User
index
)
;
StyleSet
(
)
-
>
InsertStyleSheetBefore
(
*
aSheet
*
ref
)
;
}
mDocument
-
>
ApplicableStylesChanged
(
)
;
}
void
PresShell
:
:
AddAgentSheet
(
StyleSheet
*
aSheet
)
{
StyleSet
(
)
-
>
AppendStyleSheet
(
*
aSheet
)
;
mDocument
-
>
ApplicableStylesChanged
(
)
;
}
void
PresShell
:
:
AddAuthorSheet
(
StyleSheet
*
aSheet
)
{
StyleSheet
*
firstAuthorSheet
=
mDocument
-
>
GetFirstAdditionalAuthorSheet
(
)
;
if
(
firstAuthorSheet
)
{
StyleSet
(
)
-
>
InsertStyleSheetBefore
(
*
aSheet
*
firstAuthorSheet
)
;
}
else
{
StyleSet
(
)
-
>
AppendStyleSheet
(
*
aSheet
)
;
}
mDocument
-
>
ApplicableStylesChanged
(
)
;
}
bool
PresShell
:
:
FixUpFocus
(
)
{
if
(
NS_WARN_IF
(
!
mDocument
)
)
{
return
false
;
}
nsIContent
*
currentFocus
=
mDocument
-
>
GetUnretargetedFocusedContent
(
Document
:
:
IncludeChromeOnly
:
:
Yes
)
;
if
(
!
currentFocus
)
{
return
false
;
}
if
(
auto
*
area
=
HTMLAreaElement
:
:
FromNode
(
currentFocus
)
)
{
if
(
nsFocusManager
:
:
IsAreaElementFocusable
(
*
area
)
)
{
return
false
;
}
}
nsIFrame
*
f
=
currentFocus
-
>
GetPrimaryFrame
(
)
;
if
(
f
&
&
f
-
>
IsFocusable
(
)
)
{
return
false
;
}
if
(
currentFocus
=
=
mDocument
-
>
GetBody
(
)
|
|
currentFocus
=
=
mDocument
-
>
GetRootElement
(
)
)
{
return
false
;
}
RefPtr
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
mDocument
-
>
GetWindow
(
)
;
if
(
NS_WARN_IF
(
!
window
)
)
{
return
false
;
}
fm
-
>
ClearFocus
(
window
)
;
return
true
;
}
void
PresShell
:
:
SelectionWillTakeFocus
(
)
{
if
(
mSelection
)
{
FrameSelectionWillTakeFocus
(
*
mSelection
)
;
}
}
void
PresShell
:
:
SelectionWillLoseFocus
(
)
{
}
static
void
RepaintNormalSelectionWhenSafe
(
nsFrameSelection
&
aFrameSelection
)
{
if
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
{
aFrameSelection
.
RepaintSelection
(
SelectionType
:
:
eNormal
)
;
return
;
}
nsContentUtils
:
:
AddScriptRunner
(
NS_NewRunnableFunction
(
"
RepaintNormalSelectionWhenSafe
"
[
sel
=
RefPtr
<
nsFrameSelection
>
(
&
aFrameSelection
)
]
{
sel
-
>
RepaintSelection
(
SelectionType
:
:
eNormal
)
;
}
)
)
;
}
void
PresShell
:
:
FrameSelectionWillLoseFocus
(
nsFrameSelection
&
aFrameSelection
)
{
if
(
mFocusedFrameSelection
!
=
&
aFrameSelection
)
{
return
;
}
if
(
&
aFrameSelection
=
=
mSelection
)
{
return
;
}
RefPtr
<
nsFrameSelection
>
old
=
std
:
:
move
(
mFocusedFrameSelection
)
;
MOZ_ASSERT
(
!
mFocusedFrameSelection
)
;
if
(
old
-
>
GetDisplaySelection
(
)
!
=
nsISelectionController
:
:
SELECTION_HIDDEN
)
{
old
-
>
SetDisplaySelection
(
nsISelectionController
:
:
SELECTION_HIDDEN
)
;
RepaintNormalSelectionWhenSafe
(
*
old
)
;
}
if
(
mSelection
)
{
FrameSelectionWillTakeFocus
(
*
mSelection
)
;
}
}
void
PresShell
:
:
FrameSelectionWillTakeFocus
(
nsFrameSelection
&
aFrameSelection
)
{
if
(
mFocusedFrameSelection
=
=
&
aFrameSelection
)
{
#
ifdef
XP_MACOSX
RepaintNormalSelectionWhenSafe
(
aFrameSelection
)
;
#
endif
return
;
}
RefPtr
<
nsFrameSelection
>
old
=
std
:
:
move
(
mFocusedFrameSelection
)
;
mFocusedFrameSelection
=
&
aFrameSelection
;
if
(
old
&
&
old
-
>
GetDisplaySelection
(
)
!
=
nsISelectionController
:
:
SELECTION_HIDDEN
)
{
old
-
>
SetDisplaySelection
(
nsISelectionController
:
:
SELECTION_HIDDEN
)
;
RepaintNormalSelectionWhenSafe
(
*
old
)
;
}
if
(
aFrameSelection
.
GetDisplaySelection
(
)
!
=
nsISelectionController
:
:
SELECTION_ON
)
{
aFrameSelection
.
SetDisplaySelection
(
nsISelectionController
:
:
SELECTION_ON
)
;
RepaintNormalSelectionWhenSafe
(
aFrameSelection
)
;
}
}
NS_IMETHODIMP
PresShell
:
:
SetDisplaySelection
(
int16_t
aToggle
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
mSelection
;
frameSelection
-
>
SetDisplaySelection
(
aToggle
)
;
return
NS_OK
;
}
NS_IMETHODIMP
PresShell
:
:
GetDisplaySelection
(
int16_t
*
aToggle
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
mSelection
;
*
aToggle
=
frameSelection
-
>
GetDisplaySelection
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
PresShell
:
:
GetSelectionFromScript
(
RawSelectionType
aRawSelectionType
Selection
*
*
aSelection
)
{
if
(
!
aSelection
|
|
!
mSelection
)
return
NS_ERROR_NULL_POINTER
;
RefPtr
<
nsFrameSelection
>
frameSelection
=
mSelection
;
RefPtr
<
Selection
>
selection
=
frameSelection
-
>
GetSelection
(
ToSelectionType
(
aRawSelectionType
)
)
;
if
(
!
selection
)
{
return
NS_ERROR_INVALID_ARG
;
}
selection
.
forget
(
aSelection
)
;
return
NS_OK
;
}
Selection
*
PresShell
:
:
GetSelection
(
RawSelectionType
aRawSelectionType
)
{
if
(
!
mSelection
)
{
return
nullptr
;
}
RefPtr
<
nsFrameSelection
>
frameSelection
=
mSelection
;
return
frameSelection
-
>
GetSelection
(
ToSelectionType
(
aRawSelectionType
)
)
;
}
Selection
*
PresShell
:
:
GetCurrentSelection
(
SelectionType
aSelectionType
)
{
if
(
!
mSelection
)
{
return
nullptr
;
}
RefPtr
<
nsFrameSelection
>
frameSelection
=
mSelection
;
return
frameSelection
-
>
GetSelection
(
aSelectionType
)
;
}
nsFrameSelection
*
PresShell
:
:
GetLastFocusedFrameSelection
(
)
{
return
mFocusedFrameSelection
?
mFocusedFrameSelection
:
mSelection
;
}
NS_IMETHODIMP
PresShell
:
:
ScrollSelectionIntoView
(
RawSelectionType
aRawSelectionType
SelectionRegion
aRegion
int16_t
aFlags
)
{
if
(
!
mSelection
)
return
NS_ERROR_NULL_POINTER
;
RefPtr
<
nsFrameSelection
>
frameSelection
=
mSelection
;
return
frameSelection
-
>
ScrollSelectionIntoView
(
ToSelectionType
(
aRawSelectionType
)
aRegion
aFlags
)
;
}
NS_IMETHODIMP
PresShell
:
:
RepaintSelection
(
RawSelectionType
aRawSelectionType
)
{
if
(
!
mSelection
)
{
return
NS_ERROR_NULL_POINTER
;
}
if
(
MOZ_UNLIKELY
(
mIsDestroying
)
)
{
return
NS_OK
;
}
RefPtr
<
nsFrameSelection
>
frameSelection
=
mSelection
;
return
frameSelection
-
>
RepaintSelection
(
ToSelectionType
(
aRawSelectionType
)
)
;
}
void
PresShell
:
:
BeginObservingDocument
(
)
{
if
(
mDocument
&
&
!
mIsDestroying
)
{
mIsObservingDocument
=
true
;
if
(
mIsDocumentGone
)
{
NS_WARNING
(
"
Adding
a
presshell
that
was
disconnected
from
the
document
"
"
as
a
document
observer
?
Sounds
wrong
.
.
.
"
)
;
mIsDocumentGone
=
false
;
}
}
}
void
PresShell
:
:
EndObservingDocument
(
)
{
mIsDocumentGone
=
true
;
mIsObservingDocument
=
false
;
}
#
ifdef
DEBUG_kipp
char
*
nsPresShell_ReflowStackPointerTop
;
#
endif
void
PresShell
:
:
InitPaintSuppressionTimer
(
)
{
Document
*
doc
=
mDocument
-
>
GetDisplayDocument
(
)
?
mDocument
-
>
GetDisplayDocument
(
)
:
mDocument
.
get
(
)
;
const
bool
inProcess
=
!
doc
-
>
GetBrowsingContext
(
)
|
|
doc
-
>
GetBrowsingContext
(
)
-
>
Top
(
)
-
>
IsInProcess
(
)
;
int32_t
delay
=
inProcess
?
StaticPrefs
:
:
nglayout_initialpaint_delay
(
)
:
StaticPrefs
:
:
nglayout_initialpaint_delay_in_oopif
(
)
;
mPaintSuppressionTimer
-
>
InitWithNamedFuncCallback
(
[
]
(
nsITimer
*
aTimer
void
*
aPresShell
)
{
RefPtr
<
PresShell
>
self
=
static_cast
<
PresShell
*
>
(
aPresShell
)
;
self
-
>
UnsuppressPainting
(
)
;
}
this
delay
nsITimer
:
:
TYPE_ONE_SHOT
"
PresShell
:
:
sPaintSuppressionCallback
"
)
;
}
nsresult
PresShell
:
:
Initialize
(
)
{
if
(
mIsDestroying
)
{
return
NS_OK
;
}
if
(
!
mDocument
)
{
return
NS_OK
;
}
MOZ_LOG
(
gLog
LogLevel
:
:
Debug
(
"
PresShell
:
:
Initialize
this
=
%
p
"
this
)
)
;
NS_ASSERTION
(
!
mDidInitialize
"
Why
are
we
being
called
?
"
)
;
RefPtr
<
PresShell
>
kungFuDeathGrip
(
this
)
;
RecomputeFontSizeInflationEnabled
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mIsDestroying
)
;
mPresContext
-
>
FlushPendingMediaFeatureValuesChanged
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mIsDestroying
)
;
mDidInitialize
=
true
;
#
ifdef
DEBUG
if
(
VerifyReflowFlags
:
:
NoisyCommands
&
gVerifyReflowFlags
)
{
if
(
mDocument
)
{
nsIURI
*
uri
=
mDocument
-
>
GetDocumentURI
(
)
;
if
(
uri
)
{
printf
(
"
*
*
*
PresShell
:
:
Initialize
(
this
=
%
p
url
=
'
%
s
'
)
\
n
"
(
void
*
)
this
uri
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
;
}
}
}
#
endif
nsIFrame
*
rootFrame
=
mFrameConstructor
-
>
GetRootFrame
(
)
;
NS_ASSERTION
(
!
rootFrame
"
How
did
that
happen
exactly
?
"
)
;
if
(
!
rootFrame
)
{
nsAutoScriptBlocker
scriptBlocker
;
rootFrame
=
mFrameConstructor
-
>
ConstructRootFrame
(
)
;
mFrameConstructor
-
>
SetRootFrame
(
rootFrame
)
;
}
NS_ENSURE_STATE
(
!
mHaveShutDown
)
;
if
(
!
rootFrame
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
Element
*
root
=
mDocument
-
>
GetRootElement
(
)
)
{
{
nsAutoCauseReflowNotifier
reflowNotifier
(
this
)
;
mFrameConstructor
-
>
ContentInserted
(
root
nsCSSFrameConstructor
:
:
InsertionKind
:
:
Sync
)
;
}
NS_ENSURE_STATE
(
!
mHaveShutDown
)
;
}
if
(
mDocument
-
>
HasAutoFocusCandidates
(
)
)
{
mDocument
-
>
ScheduleFlushAutoFocusCandidates
(
)
;
}
NS_ASSERTION
(
rootFrame
"
How
did
that
happen
?
"
)
;
if
(
MOZ_LIKELY
(
rootFrame
-
>
HasAnyStateBits
(
NS_FRAME_IS_DIRTY
)
)
)
{
rootFrame
-
>
RemoveStateBits
(
NS_FRAME_IS_DIRTY
|
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
NS_ASSERTION
(
!
mDirtyRoots
.
Contains
(
rootFrame
)
"
Why
is
the
root
in
mDirtyRoots
already
?
"
)
;
FrameNeedsReflow
(
rootFrame
IntrinsicDirty
:
:
None
NS_FRAME_IS_DIRTY
)
;
NS_ASSERTION
(
mDirtyRoots
.
Contains
(
rootFrame
)
"
Should
be
in
mDirtyRoots
now
"
)
;
NS_ASSERTION
(
mObservingLayoutFlushes
"
Why
no
reflow
scheduled
?
"
)
;
}
if
(
!
mDocumentLoading
)
{
RestoreRootScrollPosition
(
)
;
}
if
(
!
mPresContext
-
>
IsPaginated
(
)
)
{
mPaintingSuppressed
=
true
;
Document
:
:
ReadyState
readyState
=
mDocument
-
>
GetReadyStateEnum
(
)
;
if
(
readyState
!
=
Document
:
:
READYSTATE_COMPLETE
)
{
mPaintSuppressionTimer
=
NS_NewTimer
(
)
;
}
if
(
!
mPaintSuppressionTimer
)
{
mPaintingSuppressed
=
false
;
}
else
{
mPaintSuppressionTimer
-
>
SetTarget
(
GetMainThreadSerialEventTarget
(
)
)
;
InitPaintSuppressionTimer
(
)
;
if
(
mHasTriedFastUnsuppress
)
{
mHasTriedFastUnsuppress
=
false
;
TryUnsuppressPaintingSoon
(
)
;
MOZ_ASSERT
(
mHasTriedFastUnsuppress
)
;
}
}
}
if
(
!
mPaintingSuppressed
)
{
mShouldUnsuppressPainting
=
true
;
}
return
NS_OK
;
}
void
PresShell
:
:
TryUnsuppressPaintingSoon
(
)
{
if
(
mHasTriedFastUnsuppress
)
{
return
;
}
mHasTriedFastUnsuppress
=
true
;
if
(
!
mDidInitialize
|
|
!
IsPaintingSuppressed
(
)
|
|
!
XRE_IsContentProcess
(
)
)
{
return
;
}
if
(
!
mDocument
-
>
IsInitialDocument
(
)
&
&
mDocument
-
>
DidHitCompleteSheetCache
(
)
&
&
mPresContext
-
>
IsRootContentDocumentCrossProcess
(
)
)
{
NS_DispatchToCurrentThreadQueue
(
NS_NewRunnableFunction
(
"
PresShell
:
:
TryUnsuppressPaintingSoon
"
[
self
=
RefPtr
{
this
}
]
(
)
-
>
void
{
if
(
self
-
>
IsPaintingSuppressed
(
)
)
{
PROFILER_MARKER_UNTYPED
(
"
Fast
paint
unsuppression
"
GRAPHICS
)
;
self
-
>
UnsuppressPainting
(
)
;
}
}
)
EventQueuePriority
:
:
Control
)
;
}
}
void
PresShell
:
:
RefreshZoomConstraintsForScreenSizeChange
(
)
{
if
(
mZoomConstraintsClient
)
{
mZoomConstraintsClient
-
>
ScreenSizeChanged
(
)
;
}
}
void
PresShell
:
:
ForceResizeReflowWithCurrentDimensions
(
)
{
nscoord
currentWidth
=
0
;
nscoord
currentHeight
=
0
;
mViewManager
-
>
GetWindowDimensions
(
&
currentWidth
&
currentHeight
)
;
ResizeReflow
(
currentWidth
currentHeight
)
;
}
void
PresShell
:
:
ResizeReflow
(
nscoord
aWidth
nscoord
aHeight
ResizeReflowOptions
aOptions
)
{
if
(
mZoomConstraintsClient
)
{
mZoomConstraintsClient
-
>
ScreenSizeChanged
(
)
;
}
if
(
UsesMobileViewportSizing
(
)
)
{
MOZ_ASSERT
(
mMobileViewportManager
)
;
mMobileViewportManager
-
>
RequestReflow
(
false
)
;
return
;
}
ResizeReflowIgnoreOverride
(
aWidth
aHeight
aOptions
)
;
}
bool
PresShell
:
:
SimpleResizeReflow
(
nscoord
aWidth
nscoord
aHeight
)
{
MOZ_ASSERT
(
aWidth
!
=
NS_UNCONSTRAINEDSIZE
)
;
MOZ_ASSERT
(
aHeight
!
=
NS_UNCONSTRAINEDSIZE
)
;
nsSize
oldSize
=
mPresContext
-
>
GetVisibleArea
(
)
.
Size
(
)
;
mPresContext
-
>
SetVisibleArea
(
nsRect
(
0
0
aWidth
aHeight
)
)
;
nsIFrame
*
rootFrame
=
GetRootFrame
(
)
;
if
(
!
rootFrame
)
{
return
false
;
}
WritingMode
wm
=
rootFrame
-
>
GetWritingMode
(
)
;
bool
isBSizeChanging
=
wm
.
IsVertical
(
)
?
oldSize
.
width
!
=
aWidth
:
oldSize
.
height
!
=
aHeight
;
if
(
isBSizeChanging
)
{
nsLayoutUtils
:
:
MarkIntrinsicISizesDirtyIfDependentOnBSize
(
rootFrame
)
;
}
FrameNeedsReflow
(
rootFrame
IntrinsicDirty
:
:
None
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
if
(
mMobileViewportManager
)
{
mMobileViewportManager
-
>
UpdateSizesBeforeReflow
(
)
;
}
return
true
;
}
bool
PresShell
:
:
CanHandleUserInputEvents
(
WidgetGUIEvent
*
aGUIEvent
)
{
if
(
XRE_IsParentProcess
(
)
)
{
return
true
;
}
if
(
aGUIEvent
-
>
mFlags
.
mIsSynthesizedForTests
&
&
!
StaticPrefs
:
:
dom_input_events_security_isUserInputHandlingDelayTest
(
)
)
{
return
true
;
}
if
(
!
aGUIEvent
-
>
IsUserAction
(
)
)
{
return
true
;
}
if
(
nsPresContext
*
rootPresContext
=
mPresContext
-
>
GetRootPresContext
(
)
)
{
return
rootPresContext
-
>
UserInputEventsAllowed
(
)
;
}
return
true
;
}
void
PresShell
:
:
AddResizeEventFlushObserverIfNeeded
(
)
{
if
(
!
mIsDestroying
&
&
!
mResizeEventPending
&
&
MOZ_LIKELY
(
!
mDocument
-
>
GetBFCacheEntry
(
)
)
)
{
mResizeEventPending
=
true
;
mPresContext
-
>
RefreshDriver
(
)
-
>
AddResizeEventFlushObserver
(
this
)
;
}
}
bool
PresShell
:
:
ResizeReflowIgnoreOverride
(
nscoord
aWidth
nscoord
aHeight
ResizeReflowOptions
aOptions
)
{
MOZ_ASSERT
(
!
mIsReflowing
"
Shouldn
'
t
be
in
reflow
here
!
"
)
;
const
bool
initialized
=
mDidInitialize
;
RefPtr
<
PresShell
>
kungFuDeathGrip
(
this
)
;
auto
postResizeEventIfNeeded
=
[
this
initialized
]
(
)
{
if
(
initialized
)
{
AddResizeEventFlushObserverIfNeeded
(
)
;
}
}
;
if
(
!
(
aOptions
&
ResizeReflowOptions
:
:
BSizeLimit
)
)
{
nsSize
oldSize
=
mPresContext
-
>
GetVisibleArea
(
)
.
Size
(
)
;
if
(
oldSize
=
=
nsSize
(
aWidth
aHeight
)
)
{
return
false
;
}
bool
changed
=
SimpleResizeReflow
(
aWidth
aHeight
)
;
postResizeEventIfNeeded
(
)
;
return
changed
;
}
mDocument
-
>
FlushPendingNotifications
(
FlushType
:
:
Frames
)
;
nsIFrame
*
rootFrame
=
GetRootFrame
(
)
;
if
(
mIsDestroying
|
|
!
rootFrame
)
{
if
(
aHeight
=
=
NS_UNCONSTRAINEDSIZE
|
|
aWidth
=
=
NS_UNCONSTRAINEDSIZE
)
{
return
false
;
}
mPresContext
-
>
SetVisibleArea
(
nsRect
(
0
0
aWidth
aHeight
)
)
;
return
true
;
}
WritingMode
wm
=
rootFrame
-
>
GetWritingMode
(
)
;
MOZ_ASSERT
(
(
wm
.
IsVertical
(
)
?
aHeight
:
aWidth
)
!
=
NS_UNCONSTRAINEDSIZE
"
unconstrained
isize
not
allowed
"
)
;
nscoord
targetWidth
=
aWidth
;
nscoord
targetHeight
=
aHeight
;
if
(
wm
.
IsVertical
(
)
)
{
targetWidth
=
NS_UNCONSTRAINEDSIZE
;
}
else
{
targetHeight
=
NS_UNCONSTRAINEDSIZE
;
}
mPresContext
-
>
SetVisibleArea
(
nsRect
(
0
0
targetWidth
targetHeight
)
)
;
nsLayoutUtils
:
:
MarkIntrinsicISizesDirtyIfDependentOnBSize
(
rootFrame
)
;
{
nsAutoCauseReflowNotifier
crNotifier
(
this
)
;
WillDoReflow
(
)
;
AUTO_LAYOUT_PHASE_ENTRY_POINT
(
GetPresContext
(
)
Reflow
)
;
nsViewManager
:
:
AutoDisableRefresh
refreshBlocker
(
mViewManager
)
;
mDirtyRoots
.
Remove
(
rootFrame
)
;
DoReflow
(
rootFrame
true
nullptr
)
;
const
bool
reflowAgain
=
wm
.
IsVertical
(
)
?
mPresContext
-
>
GetVisibleArea
(
)
.
width
>
aWidth
:
mPresContext
-
>
GetVisibleArea
(
)
.
height
>
aHeight
;
if
(
reflowAgain
)
{
mPresContext
-
>
SetVisibleArea
(
nsRect
(
0
0
aWidth
aHeight
)
)
;
DoReflow
(
rootFrame
true
nullptr
)
;
}
}
mPendingDidDoReflow
=
true
;
DidDoReflow
(
true
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mPresContext
-
>
GetVisibleArea
(
)
.
width
!
=
NS_UNCONSTRAINEDSIZE
"
width
should
not
be
NS_UNCONSTRAINEDSIZE
after
reflow
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mPresContext
-
>
GetVisibleArea
(
)
.
height
!
=
NS_UNCONSTRAINEDSIZE
"
height
should
not
be
NS_UNCONSTRAINEDSIZE
after
reflow
"
)
;
postResizeEventIfNeeded
(
)
;
return
true
;
}
void
PresShell
:
:
FireResizeEvent
(
)
{
if
(
mIsDocumentGone
)
{
return
;
}
if
(
mDocument
-
>
EventHandlingSuppressed
(
)
)
{
if
(
MOZ_LIKELY
(
!
mDocument
-
>
GetBFCacheEntry
(
)
)
)
{
mDocument
-
>
SetHasDelayedRefreshEvent
(
)
;
mPresContext
-
>
RefreshDriver
(
)
-
>
AddResizeEventFlushObserver
(
this
true
)
;
}
return
;
}
mResizeEventPending
=
false
;
FireResizeEventSync
(
)
;
}
void
PresShell
:
:
FireResizeEventSync
(
)
{
if
(
mIsDocumentGone
)
{
return
;
}
WidgetEvent
event
(
true
mozilla
:
:
eResize
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
if
(
RefPtr
<
nsPIDOMWindowOuter
>
window
=
mDocument
-
>
GetWindow
(
)
)
{
EventDispatcher
:
:
Dispatch
(
MOZ_KnownLive
(
nsGlobalWindowOuter
:
:
Cast
(
window
)
)
mPresContext
&
event
nullptr
&
status
)
;
}
}
static
nsIContent
*
GetNativeAnonymousSubtreeRoot
(
nsIContent
*
aContent
)
{
if
(
!
aContent
)
{
return
nullptr
;
}
return
aContent
-
>
GetClosestNativeAnonymousSubtreeRoot
(
)
;
}
void
PresShell
:
:
NativeAnonymousContentRemoved
(
nsIContent
*
aAnonContent
)
{
MOZ_ASSERT
(
aAnonContent
-
>
IsRootOfNativeAnonymousSubtree
(
)
)
;
mPresContext
-
>
EventStateManager
(
)
-
>
NativeAnonymousContentRemoved
(
aAnonContent
)
;
#
ifdef
ACCESSIBILITY
if
(
nsAccessibilityService
*
accService
=
GetAccService
(
)
)
{
accService
-
>
ContentRemoved
(
this
aAnonContent
)
;
}
#
endif
if
(
mDocument
-
>
DevToolsAnonymousAndShadowEventsEnabled
(
)
)
{
aAnonContent
-
>
QueueDevtoolsAnonymousEvent
(
true
)
;
}
if
(
nsIContent
*
root
=
GetNativeAnonymousSubtreeRoot
(
mCurrentEventContent
)
)
{
if
(
aAnonContent
=
=
root
)
{
mCurrentEventContent
=
aAnonContent
-
>
GetFlattenedTreeParent
(
)
;
mCurrentEventFrame
=
nullptr
;
}
}
for
(
unsigned
int
i
=
0
;
i
<
mCurrentEventContentStack
.
Length
(
)
;
i
+
+
)
{
nsIContent
*
anon
=
GetNativeAnonymousSubtreeRoot
(
mCurrentEventContentStack
.
ElementAt
(
i
)
)
;
if
(
aAnonContent
=
=
anon
)
{
mCurrentEventContentStack
.
ReplaceObjectAt
(
aAnonContent
-
>
GetFlattenedTreeParent
(
)
i
)
;
mCurrentEventFrameStack
[
i
]
=
nullptr
;
}
}
}
void
PresShell
:
:
SetIgnoreFrameDestruction
(
bool
aIgnore
)
{
if
(
mDocument
)
{
mDocument
-
>
StyleImageLoader
(
)
-
>
ClearFrames
(
mPresContext
)
;
}
mIgnoreFrameDestruction
=
aIgnore
;
}
void
PresShell
:
:
NotifyDestroyingFrame
(
nsIFrame
*
aFrame
)
{
aFrame
-
>
RemoveDisplayItemDataForDeletion
(
)
;
if
(
!
mIgnoreFrameDestruction
)
{
if
(
aFrame
-
>
HasImageRequest
(
)
)
{
mDocument
-
>
StyleImageLoader
(
)
-
>
DropRequestsForFrame
(
aFrame
)
;
}
mFrameConstructor
-
>
NotifyDestroyingFrame
(
aFrame
)
;
mDirtyRoots
.
Remove
(
aFrame
)
;
aFrame
-
>
RemoveAllProperties
(
)
;
if
(
aFrame
=
=
mCurrentEventFrame
)
{
mCurrentEventContent
=
aFrame
-
>
GetContent
(
)
;
mCurrentEventFrame
=
nullptr
;
}
for
(
unsigned
int
i
=
0
;
i
<
mCurrentEventFrameStack
.
Length
(
)
;
i
+
+
)
{
if
(
aFrame
=
=
mCurrentEventFrameStack
.
ElementAt
(
i
)
)
{
nsIContent
*
currentEventContent
=
aFrame
-
>
GetContent
(
)
;
mCurrentEventContentStack
.
ReplaceObjectAt
(
currentEventContent
i
)
;
mCurrentEventFrameStack
[
i
]
=
nullptr
;
}
}
mFramesToDirty
.
Remove
(
aFrame
)
;
nsIScrollableFrame
*
scrollableFrame
=
do_QueryFrame
(
aFrame
)
;
if
(
scrollableFrame
)
{
mPendingScrollAnchorSelection
.
Remove
(
scrollableFrame
)
;
mPendingScrollAnchorAdjustment
.
Remove
(
scrollableFrame
)
;
mPendingScrollResnap
.
Remove
(
scrollableFrame
)
;
}
}
}
already_AddRefed
<
nsCaret
>
PresShell
:
:
GetCaret
(
)
const
{
RefPtr
<
nsCaret
>
caret
=
mCaret
;
return
caret
.
forget
(
)
;
}
already_AddRefed
<
AccessibleCaretEventHub
>
PresShell
:
:
GetAccessibleCaretEventHub
(
)
const
{
RefPtr
<
AccessibleCaretEventHub
>
eventHub
=
mAccessibleCaretEventHub
;
return
eventHub
.
forget
(
)
;
}
void
PresShell
:
:
SetCaret
(
nsCaret
*
aNewCaret
)
{
mCaret
=
aNewCaret
;
}
void
PresShell
:
:
RestoreCaret
(
)
{
mCaret
=
mOriginalCaret
;
}
NS_IMETHODIMP
PresShell
:
:
SetCaretEnabled
(
bool
aInEnable
)
{
bool
oldEnabled
=
mCaretEnabled
;
mCaretEnabled
=
aInEnable
;
if
(
mCaretEnabled
!
=
oldEnabled
)
{
MOZ_ASSERT
(
mCaret
)
;
if
(
mCaret
)
{
mCaret
-
>
SetVisible
(
mCaretEnabled
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
PresShell
:
:
SetCaretReadOnly
(
bool
aReadOnly
)
{
if
(
mCaret
)
mCaret
-
>
SetCaretReadOnly
(
aReadOnly
)
;
return
NS_OK
;
}
NS_IMETHODIMP
PresShell
:
:
GetCaretEnabled
(
bool
*
aOutEnabled
)
{
NS_ENSURE_ARG_POINTER
(
aOutEnabled
)
;
*
aOutEnabled
=
mCaretEnabled
;
return
NS_OK
;
}
NS_IMETHODIMP
PresShell
:
:
SetCaretVisibilityDuringSelection
(
bool
aVisibility
)
{
if
(
mCaret
)
mCaret
-
>
SetVisibilityDuringSelection
(
aVisibility
)
;
return
NS_OK
;
}
NS_IMETHODIMP
PresShell
:
:
GetCaretVisible
(
bool
*
aOutIsVisible
)
{
*
aOutIsVisible
=
false
;
if
(
mCaret
)
{
*
aOutIsVisible
=
mCaret
-
>
IsVisible
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
PresShell
:
:
SetSelectionFlags
(
int16_t
aFlags
)
{
mSelectionFlags
=
aFlags
;
return
NS_OK
;
}
NS_IMETHODIMP
PresShell
:
:
GetSelectionFlags
(
int16_t
*
aFlags
)
{
if
(
!
aFlags
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aFlags
=
mSelectionFlags
;
return
NS_OK
;
}
NS_IMETHODIMP
PresShell
:
:
PhysicalMove
(
int16_t
aDirection
int16_t
aAmount
bool
aExtend
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
mSelection
;
return
frameSelection
-
>
PhysicalMove
(
aDirection
aAmount
aExtend
)
;
}
NS_IMETHODIMP
PresShell
:
:
CharacterMove
(
bool
aForward
bool
aExtend
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
mSelection
;
return
frameSelection
-
>
CharacterMove
(
aForward
aExtend
)
;
}
NS_IMETHODIMP
PresShell
:
:
WordMove
(
bool
aForward
bool
aExtend
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
mSelection
;
nsresult
result
=
frameSelection
-
>
WordMove
(
aForward
aExtend
)
;
if
(
NS_FAILED
(
result
)
)
result
=
CompleteMove
(
aForward
aExtend
)
;
return
result
;
}
NS_IMETHODIMP
PresShell
:
:
LineMove
(
bool
aForward
bool
aExtend
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
mSelection
;
nsresult
result
=
frameSelection
-
>
LineMove
(
aForward
aExtend
)
;
if
(
NS_FAILED
(
result
)
)
result
=
CompleteMove
(
aForward
aExtend
)
;
return
result
;
}
NS_IMETHODIMP
PresShell
:
:
IntraLineMove
(
bool
aForward
bool
aExtend
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
mSelection
;
return
frameSelection
-
>
IntraLineMove
(
aForward
aExtend
)
;
}
NS_IMETHODIMP
PresShell
:
:
PageMove
(
bool
aForward
bool
aExtend
)
{
nsIFrame
*
frame
=
nullptr
;
if
(
!
aExtend
)
{
frame
=
do_QueryFrame
(
GetScrollableFrameToScroll
(
VerticalScrollDirection
)
)
;
}
if
(
!
frame
|
|
frame
-
>
PresContext
(
)
!
=
mPresContext
)
{
frame
=
mSelection
-
>
GetFrameToPageSelect
(
)
;
if
(
!
frame
)
{
return
NS_OK
;
}
}
RefPtr
<
nsFrameSelection
>
frameSelection
=
mSelection
;
return
frameSelection
-
>
PageMove
(
aForward
aExtend
frame
nsFrameSelection
:
:
SelectionIntoView
:
:
IfChanged
)
;
}
NS_IMETHODIMP
PresShell
:
:
ScrollPage
(
bool
aForward
)
{
nsIScrollableFrame
*
scrollFrame
=
GetScrollableFrameToScroll
(
VerticalScrollDirection
)
;
ScrollMode
scrollMode
=
apz
:
:
GetScrollModeForOrigin
(
ScrollOrigin
:
:
Pages
)
;
if
(
scrollFrame
)
{
scrollFrame
-
>
ScrollBy
(
nsIntPoint
(
0
aForward
?
1
:
-
1
)
ScrollUnit
:
:
PAGES
scrollMode
nullptr
mozilla
:
:
ScrollOrigin
:
:
NotSpecified
nsIScrollableFrame
:
:
NOT_MOMENTUM
ScrollSnapFlags
:
:
IntendedDirection
|
ScrollSnapFlags
:
:
IntendedEndPosition
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
PresShell
:
:
ScrollLine
(
bool
aForward
)
{
nsIScrollableFrame
*
scrollFrame
=
GetScrollableFrameToScroll
(
VerticalScrollDirection
)
;
ScrollMode
scrollMode
=
apz
:
:
GetScrollModeForOrigin
(
ScrollOrigin
:
:
Lines
)
;
if
(
scrollFrame
)
{
nsRect
scrollPort
=
scrollFrame
-
>
GetScrollPortRect
(
)
;
nsSize
lineSize
=
scrollFrame
-
>
GetLineScrollAmount
(
)
;
int32_t
lineCount
=
StaticPrefs
:
:
toolkit_scrollbox_verticalScrollDistance
(
)
;
if
(
lineCount
*
lineSize
.
height
>
scrollPort
.
Height
(
)
)
{
return
ScrollPage
(
aForward
)
;
}
scrollFrame
-
>
ScrollBy
(
nsIntPoint
(
0
aForward
?
lineCount
:
-
lineCount
)
ScrollUnit
:
:
LINES
scrollMode
nullptr
mozilla
:
:
ScrollOrigin
:
:
NotSpecified
nsIScrollableFrame
:
:
NOT_MOMENTUM
ScrollSnapFlags
:
:
IntendedDirection
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
PresShell
:
:
ScrollCharacter
(
bool
aRight
)
{
nsIScrollableFrame
*
scrollFrame
=
GetScrollableFrameToScroll
(
HorizontalScrollDirection
)
;
ScrollMode
scrollMode
=
apz
:
:
GetScrollModeForOrigin
(
ScrollOrigin
:
:
Lines
)
;
if
(
scrollFrame
)
{
int32_t
h
=
StaticPrefs
:
:
toolkit_scrollbox_horizontalScrollDistance
(
)
;
scrollFrame
-
>
ScrollBy
(
nsIntPoint
(
aRight
?
h
:
-
h
0
)
ScrollUnit
:
:
LINES
scrollMode
nullptr
mozilla
:
:
ScrollOrigin
:
:
NotSpecified
nsIScrollableFrame
:
:
NOT_MOMENTUM
ScrollSnapFlags
:
:
IntendedDirection
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
PresShell
:
:
CompleteScroll
(
bool
aForward
)
{
nsIScrollableFrame
*
scrollFrame
=
GetScrollableFrameToScroll
(
VerticalScrollDirection
)
;
ScrollMode
scrollMode
=
apz
:
:
GetScrollModeForOrigin
(
ScrollOrigin
:
:
Other
)
;
if
(
scrollFrame
)
{
scrollFrame
-
>
ScrollBy
(
nsIntPoint
(
0
aForward
?
1
:
-
1
)
ScrollUnit
:
:
WHOLE
scrollMode
nullptr
mozilla
:
:
ScrollOrigin
:
:
NotSpecified
nsIScrollableFrame
:
:
NOT_MOMENTUM
ScrollSnapFlags
:
:
IntendedEndPosition
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
PresShell
:
:
CompleteMove
(
bool
aForward
bool
aExtend
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
mSelection
;
nsIContent
*
limiter
=
frameSelection
-
>
GetAncestorLimiter
(
)
;
nsIFrame
*
frame
=
limiter
?
limiter
-
>
GetPrimaryFrame
(
)
:
FrameConstructor
(
)
-
>
GetRootElementFrame
(
)
;
if
(
!
frame
)
return
NS_ERROR_FAILURE
;
nsIFrame
:
:
CaretPosition
pos
=
frame
-
>
GetExtremeCaretPosition
(
!
aForward
)
;
const
nsFrameSelection
:
:
FocusMode
focusMode
=
aExtend
?
nsFrameSelection
:
:
FocusMode
:
:
kExtendSelection
:
nsFrameSelection
:
:
FocusMode
:
:
kCollapseToNewPoint
;
frameSelection
-
>
HandleClick
(
MOZ_KnownLive
(
pos
.
mResultContent
)
pos
.
mContentOffset
pos
.
mContentOffset
focusMode
aForward
?
CaretAssociationHint
:
:
After
:
CaretAssociationHint
:
:
Before
)
;
if
(
limiter
)
{
frameSelection
-
>
SetAncestorLimiter
(
limiter
)
;
}
return
ScrollSelectionIntoView
(
nsISelectionController
:
:
SELECTION_NORMAL
nsISelectionController
:
:
SELECTION_FOCUS_REGION
nsISelectionController
:
:
SCROLL_SYNCHRONOUS
|
nsISelectionController
:
:
SCROLL_FOR_CARET_MOVE
)
;
}
nsIFrame
*
PresShell
:
:
GetRootScrollFrame
(
)
const
{
if
(
!
mFrameConstructor
)
{
return
nullptr
;
}
nsIFrame
*
rootFrame
=
mFrameConstructor
-
>
GetRootFrame
(
)
;
if
(
!
rootFrame
|
|
!
rootFrame
-
>
IsViewportFrame
(
)
)
{
return
nullptr
;
}
nsIFrame
*
theFrame
=
rootFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
!
theFrame
|
|
!
theFrame
-
>
IsScrollFrame
(
)
)
{
return
nullptr
;
}
return
theFrame
;
}
nsIScrollableFrame
*
PresShell
:
:
GetRootScrollFrameAsScrollable
(
)
const
{
nsIFrame
*
frame
=
GetRootScrollFrame
(
)
;
if
(
!
frame
)
{
return
nullptr
;
}
nsIScrollableFrame
*
scrollableFrame
=
do_QueryFrame
(
frame
)
;
NS_ASSERTION
(
scrollableFrame
"
All
scroll
frames
must
implement
nsIScrollableFrame
"
)
;
return
scrollableFrame
;
}
nsPageSequenceFrame
*
PresShell
:
:
GetPageSequenceFrame
(
)
const
{
return
mFrameConstructor
-
>
GetPageSequenceFrame
(
)
;
}
nsCanvasFrame
*
PresShell
:
:
GetCanvasFrame
(
)
const
{
return
mFrameConstructor
-
>
GetCanvasFrame
(
)
;
}
void
PresShell
:
:
RestoreRootScrollPosition
(
)
{
nsIScrollableFrame
*
scrollableFrame
=
GetRootScrollFrameAsScrollable
(
)
;
if
(
scrollableFrame
)
{
scrollableFrame
-
>
ScrollToRestoredPosition
(
)
;
}
}
void
PresShell
:
:
MaybeReleaseCapturingContent
(
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
FrameSelection
(
)
;
if
(
frameSelection
)
{
frameSelection
-
>
SetDragState
(
false
)
;
}
if
(
sCapturingContentInfo
.
mContent
&
&
sCapturingContentInfo
.
mContent
-
>
OwnerDoc
(
)
=
=
mDocument
)
{
PresShell
:
:
ReleaseCapturingContent
(
)
;
}
}
void
PresShell
:
:
BeginLoad
(
Document
*
aDocument
)
{
mDocumentLoading
=
true
;
gfxTextPerfMetrics
*
tp
=
nullptr
;
if
(
mPresContext
)
{
tp
=
mPresContext
-
>
GetTextPerfMetrics
(
)
;
}
bool
shouldLog
=
MOZ_LOG_TEST
(
gLog
LogLevel
:
:
Debug
)
;
if
(
shouldLog
|
|
tp
)
{
mLoadBegin
=
TimeStamp
:
:
Now
(
)
;
}
if
(
shouldLog
)
{
nsIURI
*
uri
=
mDocument
-
>
GetDocumentURI
(
)
;
MOZ_LOG
(
gLog
LogLevel
:
:
Debug
(
"
(
presshell
)
%
p
load
begin
[
%
s
]
\
n
"
this
uri
?
uri
-
>
GetSpecOrDefault
(
)
.
get
(
)
:
"
"
)
)
;
}
}
void
PresShell
:
:
EndLoad
(
Document
*
aDocument
)
{
MOZ_ASSERT
(
aDocument
=
=
mDocument
"
Wrong
document
"
)
;
RestoreRootScrollPosition
(
)
;
mDocumentLoading
=
false
;
}
bool
PresShell
:
:
IsLayoutFlushObserver
(
)
{
return
GetPresContext
(
)
-
>
RefreshDriver
(
)
-
>
IsLayoutFlushObserver
(
this
)
;
}
void
PresShell
:
:
LoadComplete
(
)
{
gfxTextPerfMetrics
*
tp
=
nullptr
;
if
(
mPresContext
)
{
tp
=
mPresContext
-
>
GetTextPerfMetrics
(
)
;
}
bool
shouldLog
=
MOZ_LOG_TEST
(
gLog
LogLevel
:
:
Debug
)
;
if
(
shouldLog
|
|
tp
)
{
TimeDuration
loadTime
=
TimeStamp
:
:
Now
(
)
-
mLoadBegin
;
nsIURI
*
uri
=
mDocument
-
>
GetDocumentURI
(
)
;
nsAutoCString
spec
;
if
(
uri
)
{
spec
=
uri
-
>
GetSpecOrDefault
(
)
;
}
if
(
shouldLog
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Debug
(
"
(
presshell
)
%
p
load
done
time
-
ms
:
%
9
.
2f
[
%
s
]
\
n
"
this
loadTime
.
ToMilliseconds
(
)
spec
.
get
(
)
)
)
;
}
if
(
tp
)
{
tp
-
>
Accumulate
(
)
;
if
(
tp
-
>
cumulative
.
numChars
>
0
)
{
LogTextPerfStats
(
tp
this
tp
-
>
cumulative
loadTime
.
ToMilliseconds
(
)
eLog_loaddone
spec
.
get
(
)
)
;
}
}
}
}
#
ifdef
DEBUG
void
PresShell
:
:
VerifyHasDirtyRootAncestor
(
nsIFrame
*
aFrame
)
{
#
if
0
if
(
!
aFrame
-
>
GetParent
(
)
)
{
return
;
}
while
(
aFrame
&
&
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_HAS_DIRTY_CHILDREN
)
)
{
if
(
(
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_REFLOW_ROOT
|
NS_FRAME_DYNAMIC_REFLOW_ROOT
)
|
|
!
aFrame
-
>
GetParent
(
)
)
&
&
mDirtyRoots
.
Contains
(
aFrame
)
)
{
return
;
}
aFrame
=
aFrame
-
>
GetParent
(
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Frame
has
dirty
bits
set
but
isn
'
t
scheduled
to
be
"
"
reflowed
?
"
)
;
#
endif
}
#
endif
void
PresShell
:
:
PostPendingScrollAnchorSelection
(
mozilla
:
:
layout
:
:
ScrollAnchorContainer
*
aContainer
)
{
mPendingScrollAnchorSelection
.
Insert
(
aContainer
-
>
ScrollableFrame
(
)
)
;
}
void
PresShell
:
:
FlushPendingScrollAnchorSelections
(
)
{
for
(
nsIScrollableFrame
*
scroll
:
mPendingScrollAnchorSelection
)
{
scroll
-
>
Anchor
(
)
-
>
SelectAnchor
(
)
;
}
mPendingScrollAnchorSelection
.
Clear
(
)
;
}
void
PresShell
:
:
PostPendingScrollAnchorAdjustment
(
ScrollAnchorContainer
*
aContainer
)
{
mPendingScrollAnchorAdjustment
.
Insert
(
aContainer
-
>
ScrollableFrame
(
)
)
;
}
void
PresShell
:
:
FlushPendingScrollAnchorAdjustments
(
)
{
for
(
nsIScrollableFrame
*
scroll
:
mPendingScrollAnchorAdjustment
)
{
scroll
-
>
Anchor
(
)
-
>
ApplyAdjustments
(
)
;
}
mPendingScrollAnchorAdjustment
.
Clear
(
)
;
}
void
PresShell
:
:
PostPendingScrollResnap
(
nsIScrollableFrame
*
aScrollableFrame
)
{
mPendingScrollResnap
.
Insert
(
aScrollableFrame
)
;
}
void
PresShell
:
:
FlushPendingScrollResnap
(
)
{
for
(
nsIScrollableFrame
*
scrollableFrame
:
mPendingScrollResnap
)
{
scrollableFrame
-
>
TryResnap
(
)
;
}
mPendingScrollResnap
.
Clear
(
)
;
}
void
PresShell
:
:
FrameNeedsReflow
(
nsIFrame
*
aFrame
IntrinsicDirty
aIntrinsicDirty
nsFrameState
aBitToAdd
ReflowRootHandling
aRootHandling
)
{
MOZ_ASSERT
(
aBitToAdd
=
=
NS_FRAME_IS_DIRTY
|
|
aBitToAdd
=
=
NS_FRAME_HAS_DIRTY_CHILDREN
|
|
!
aBitToAdd
"
Unexpected
bits
being
added
"
)
;
NS_ASSERTION
(
aIntrinsicDirty
!
=
IntrinsicDirty
:
:
FrameAncestorsAndDescendants
|
|
aBitToAdd
!
=
NS_FRAME_HAS_DIRTY_CHILDREN
"
bits
don
'
t
correspond
to
style
change
reason
"
)
;
NS_ASSERTION
(
!
mIsReflowing
"
can
'
t
mark
frame
dirty
during
reflow
"
)
;
if
(
!
mDidInitialize
)
return
;
if
(
mIsDestroying
)
return
;
#
ifdef
DEBUG
if
(
mInVerifyReflow
)
return
;
if
(
VerifyReflowFlags
:
:
NoisyCommands
&
gVerifyReflowFlags
)
{
printf
(
"
\
nPresShell
%
p
:
frame
%
p
needs
reflow
\
n
"
(
void
*
)
this
(
void
*
)
aFrame
)
;
if
(
VerifyReflowFlags
:
:
ReallyNoisyCommands
&
gVerifyReflowFlags
)
{
printf
(
"
Current
content
model
:
\
n
"
)
;
Element
*
rootElement
=
mDocument
-
>
GetRootElement
(
)
;
if
(
rootElement
)
{
rootElement
-
>
List
(
stdout
0
)
;
}
}
}
#
endif
AutoTArray
<
nsIFrame
*
4
>
subtrees
;
subtrees
.
AppendElement
(
aFrame
)
;
do
{
nsIFrame
*
subtreeRoot
=
subtrees
.
PopLastElement
(
)
;
bool
wasDirty
=
subtreeRoot
-
>
IsSubtreeDirty
(
)
;
subtreeRoot
-
>
AddStateBits
(
aBitToAdd
)
;
bool
targetNeedsReflowFromParent
;
switch
(
aRootHandling
)
{
case
ReflowRootHandling
:
:
PositionOrSizeChange
:
targetNeedsReflowFromParent
=
true
;
break
;
case
ReflowRootHandling
:
:
NoPositionOrSizeChange
:
targetNeedsReflowFromParent
=
false
;
break
;
case
ReflowRootHandling
:
:
InferFromBitToAdd
:
targetNeedsReflowFromParent
=
(
aBitToAdd
=
=
NS_FRAME_IS_DIRTY
)
;
break
;
}
auto
FrameIsReflowRoot
=
[
]
(
const
nsIFrame
*
aFrame
)
{
return
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_REFLOW_ROOT
|
NS_FRAME_DYNAMIC_REFLOW_ROOT
)
;
}
;
auto
CanStopClearingAncestorIntrinsics
=
[
&
]
(
const
nsIFrame
*
aFrame
)
{
return
FrameIsReflowRoot
(
aFrame
)
&
&
aFrame
!
=
subtreeRoot
;
}
;
auto
IsReflowBoundary
=
[
&
]
(
const
nsIFrame
*
aFrame
)
{
return
FrameIsReflowRoot
(
aFrame
)
&
&
(
aFrame
!
=
subtreeRoot
|
|
!
targetNeedsReflowFromParent
)
;
}
;
if
(
aIntrinsicDirty
!
=
IntrinsicDirty
:
:
None
)
{
for
(
nsIFrame
*
a
=
subtreeRoot
;
a
&
&
!
CanStopClearingAncestorIntrinsics
(
a
)
;
a
=
a
-
>
GetParent
(
)
)
{
a
-
>
MarkIntrinsicISizesDirty
(
)
;
if
(
a
-
>
IsAbsolutelyPositioned
(
)
)
{
break
;
}
}
}
const
bool
frameAncestorAndDescendantISizesDirty
=
(
aIntrinsicDirty
=
=
IntrinsicDirty
:
:
FrameAncestorsAndDescendants
)
;
const
bool
dirty
=
(
aBitToAdd
=
=
NS_FRAME_IS_DIRTY
)
;
if
(
frameAncestorAndDescendantISizesDirty
|
|
dirty
)
{
AutoTArray
<
nsIFrame
*
32
>
stack
;
stack
.
AppendElement
(
subtreeRoot
)
;
do
{
nsIFrame
*
f
=
stack
.
PopLastElement
(
)
;
if
(
frameAncestorAndDescendantISizesDirty
&
&
f
-
>
IsPlaceholderFrame
(
)
)
{
if
(
nsIFrame
*
oof
=
static_cast
<
nsPlaceholderFrame
*
>
(
f
)
-
>
GetOutOfFlowFrame
(
)
)
{
if
(
!
nsLayoutUtils
:
:
IsProperAncestorFrame
(
subtreeRoot
oof
)
)
{
subtrees
.
AppendElement
(
oof
)
;
}
}
}
for
(
const
auto
&
childList
:
f
-
>
ChildLists
(
)
)
{
for
(
nsIFrame
*
kid
:
childList
.
mList
)
{
if
(
frameAncestorAndDescendantISizesDirty
)
{
kid
-
>
MarkIntrinsicISizesDirty
(
)
;
}
if
(
dirty
)
{
kid
-
>
AddStateBits
(
NS_FRAME_IS_DIRTY
)
;
}
stack
.
AppendElement
(
kid
)
;
}
}
}
while
(
stack
.
Length
(
)
!
=
0
)
;
}
if
(
!
aBitToAdd
)
{
continue
;
}
nsIFrame
*
f
=
subtreeRoot
;
for
(
;
;
)
{
if
(
IsReflowBoundary
(
f
)
|
|
!
f
-
>
GetParent
(
)
)
{
if
(
!
wasDirty
)
{
mDirtyRoots
.
Add
(
f
)
;
SetNeedLayoutFlush
(
)
;
}
#
ifdef
DEBUG
else
{
VerifyHasDirtyRootAncestor
(
f
)
;
}
#
endif
break
;
}
nsIFrame
*
child
=
f
;
f
=
f
-
>
GetParent
(
)
;
wasDirty
=
f
-
>
IsSubtreeDirty
(
)
;
f
-
>
ChildIsDirty
(
child
)
;
NS_ASSERTION
(
f
-
>
HasAnyStateBits
(
NS_FRAME_HAS_DIRTY_CHILDREN
)
"
ChildIsDirty
didn
'
t
do
its
job
"
)
;
if
(
wasDirty
)
{
#
ifdef
DEBUG
VerifyHasDirtyRootAncestor
(
f
)
;
#
endif
break
;
}
}
}
while
(
subtrees
.
Length
(
)
!
=
0
)
;
MaybeScheduleReflow
(
)
;
}
void
PresShell
:
:
FrameNeedsToContinueReflow
(
nsIFrame
*
aFrame
)
{
NS_ASSERTION
(
mIsReflowing
"
Must
be
in
reflow
when
marking
path
dirty
.
"
)
;
MOZ_ASSERT
(
mCurrentReflowRoot
"
Must
have
a
current
reflow
root
here
"
)
;
NS_ASSERTION
(
aFrame
=
=
mCurrentReflowRoot
|
|
nsLayoutUtils
:
:
IsProperAncestorFrame
(
mCurrentReflowRoot
aFrame
)
"
Frame
passed
in
is
not
the
descendant
of
mCurrentReflowRoot
"
)
;
NS_ASSERTION
(
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_IN_REFLOW
)
"
Frame
passed
in
not
in
reflow
?
"
)
;
mFramesToDirty
.
Insert
(
aFrame
)
;
}
already_AddRefed
<
nsIContent
>
PresShell
:
:
GetContentForScrolling
(
)
const
{
if
(
nsCOMPtr
<
nsIContent
>
focused
=
GetFocusedContentInOurWindow
(
)
)
{
return
focused
.
forget
(
)
;
}
return
GetSelectedContentForScrolling
(
)
;
}
already_AddRefed
<
nsIContent
>
PresShell
:
:
GetSelectedContentForScrolling
(
)
const
{
nsCOMPtr
<
nsIContent
>
selectedContent
;
if
(
mSelection
)
{
Selection
*
domSelection
=
mSelection
-
>
GetSelection
(
SelectionType
:
:
eNormal
)
;
if
(
domSelection
)
{
selectedContent
=
nsIContent
:
:
FromNodeOrNull
(
domSelection
-
>
GetFocusNode
(
)
)
;
}
}
return
selectedContent
.
forget
(
)
;
}
nsIScrollableFrame
*
PresShell
:
:
GetScrollableFrameToScrollForContent
(
nsIContent
*
aContent
ScrollDirections
aDirections
)
{
nsIScrollableFrame
*
scrollFrame
=
nullptr
;
if
(
aContent
)
{
nsIFrame
*
startFrame
=
aContent
-
>
GetPrimaryFrame
(
)
;
if
(
startFrame
)
{
scrollFrame
=
startFrame
-
>
GetScrollTargetFrame
(
)
;
if
(
scrollFrame
)
{
startFrame
=
scrollFrame
-
>
GetScrolledFrame
(
)
;
}
scrollFrame
=
nsLayoutUtils
:
:
GetNearestScrollableFrameForDirection
(
startFrame
aDirections
)
;
}
}
if
(
!
scrollFrame
)
{
scrollFrame
=
GetRootScrollFrameAsScrollable
(
)
;
if
(
!
scrollFrame
|
|
!
scrollFrame
-
>
GetScrolledFrame
(
)
)
{
return
nullptr
;
}
scrollFrame
=
nsLayoutUtils
:
:
GetNearestScrollableFrameForDirection
(
scrollFrame
-
>
GetScrolledFrame
(
)
aDirections
)
;
}
return
scrollFrame
;
}
nsIScrollableFrame
*
PresShell
:
:
GetScrollableFrameToScroll
(
ScrollDirections
aDirections
)
{
nsCOMPtr
<
nsIContent
>
content
=
GetContentForScrolling
(
)
;
return
GetScrollableFrameToScrollForContent
(
content
.
get
(
)
aDirections
)
;
}
void
PresShell
:
:
CancelAllPendingReflows
(
)
{
mDirtyRoots
.
Clear
(
)
;
if
(
mObservingLayoutFlushes
)
{
GetPresContext
(
)
-
>
RefreshDriver
(
)
-
>
RemoveLayoutFlushObserver
(
this
)
;
mObservingLayoutFlushes
=
false
;
}
ASSERT_REFLOW_SCHEDULED_STATE
(
)
;
}
static
bool
DestroyFramesAndStyleDataFor
(
Element
*
aElement
nsPresContext
&
aPresContext
RestyleManager
:
:
IncludeRoot
aIncludeRoot
)
{
bool
didReconstruct
=
aPresContext
.
FrameConstructor
(
)
-
>
DestroyFramesFor
(
aElement
)
;
RestyleManager
:
:
ClearServoDataFromSubtree
(
aElement
aIncludeRoot
)
;
return
didReconstruct
;
}
void
PresShell
:
:
SlotAssignmentWillChange
(
Element
&
aElement
HTMLSlotElement
*
aOldSlot
HTMLSlotElement
*
aNewSlot
)
{
MOZ_ASSERT
(
aOldSlot
!
=
aNewSlot
)
;
if
(
MOZ_UNLIKELY
(
!
mDidInitialize
)
)
{
return
;
}
if
(
aOldSlot
&
&
aOldSlot
-
>
AssignedNodes
(
)
.
Length
(
)
=
=
1
&
&
aOldSlot
-
>
HasChildren
(
)
)
{
DestroyFramesForAndRestyle
(
aOldSlot
)
;
}
DestroyFramesAndStyleDataFor
(
&
aElement
*
mPresContext
RestyleManager
:
:
IncludeRoot
:
:
Yes
)
;
if
(
aNewSlot
)
{
if
(
aNewSlot
-
>
AssignedNodes
(
)
.
IsEmpty
(
)
&
&
aNewSlot
-
>
HasChildren
(
)
)
{
DestroyFramesForAndRestyle
(
aNewSlot
)
;
}
else
if
(
aNewSlot
-
>
HasServoData
(
)
&
&
!
Servo_Element_IsDisplayNone
(
aNewSlot
)
)
{
aNewSlot
-
>
NoteDescendantsNeedFramesForServo
(
)
;
aElement
.
SetFlags
(
NODE_NEEDS_FRAME
)
;
aNewSlot
-
>
SetHasDirtyDescendantsForServo
(
)
;
aNewSlot
-
>
NoteDirtySubtreeForServo
(
)
;
}
}
}
#
ifdef
DEBUG
static
void
AssertNoFramesOrStyleDataInDescendants
(
Element
&
aElement
)
{
for
(
nsINode
*
node
:
ShadowIncludingTreeIterator
(
aElement
)
)
{
nsIContent
*
c
=
nsIContent
:
:
FromNode
(
node
)
;
if
(
c
=
=
&
aElement
)
{
continue
;
}
MOZ_ASSERT
(
!
c
-
>
GetPrimaryFrame
(
)
|
|
c
-
>
IsHTMLElement
(
nsGkAtoms
:
:
area
)
)
;
MOZ_ASSERT
(
!
c
-
>
IsElement
(
)
|
|
!
c
-
>
AsElement
(
)
-
>
HasServoData
(
)
)
;
}
}
#
endif
void
PresShell
:
:
DestroyFramesForAndRestyle
(
Element
*
aElement
)
{
#
ifdef
DEBUG
auto
postCondition
=
MakeScopeExit
(
[
&
]
(
)
{
MOZ_ASSERT
(
!
aElement
-
>
GetPrimaryFrame
(
)
)
;
AssertNoFramesOrStyleDataInDescendants
(
*
aElement
)
;
}
)
;
#
endif
MOZ_ASSERT
(
aElement
)
;
if
(
!
aElement
-
>
HasServoData
(
)
)
{
return
;
}
nsAutoScriptBlocker
scriptBlocker
;
+
+
mChangeNestCount
;
const
bool
didReconstruct
=
FrameConstructor
(
)
-
>
DestroyFramesFor
(
aElement
)
;
RestyleManager
:
:
ClearServoDataFromSubtree
(
aElement
RestyleManager
:
:
IncludeRoot
:
:
No
)
;
auto
changeHint
=
didReconstruct
?
nsChangeHint
(
0
)
:
nsChangeHint_ReconstructFrame
;
mPresContext
-
>
RestyleManager
(
)
-
>
PostRestyleEvent
(
aElement
RestyleHint
:
:
RestyleSubtree
(
)
changeHint
)
;
-
-
mChangeNestCount
;
}
void
PresShell
:
:
ShadowRootWillBeAttached
(
Element
&
aElement
)
{
#
ifdef
DEBUG
auto
postCondition
=
MakeScopeExit
(
[
&
]
(
)
{
AssertNoFramesOrStyleDataInDescendants
(
aElement
)
;
}
)
;
#
endif
if
(
!
aElement
.
HasServoData
(
)
)
{
return
;
}
if
(
!
aElement
.
HasChildren
(
)
)
{
return
;
}
nsAutoScriptBlocker
scriptBlocker
;
+
+
mChangeNestCount
;
FlattenedChildIterator
iter
(
&
aElement
)
;
nsCSSFrameConstructor
*
fc
=
FrameConstructor
(
)
;
for
(
nsIContent
*
c
=
iter
.
GetNextChild
(
)
;
c
;
c
=
iter
.
GetNextChild
(
)
)
{
fc
-
>
DestroyFramesFor
(
c
)
;
if
(
c
-
>
IsElement
(
)
)
{
RestyleManager
:
:
ClearServoDataFromSubtree
(
c
-
>
AsElement
(
)
)
;
}
}
#
ifdef
ACCESSIBILITY
if
(
nsAccessibilityService
*
accService
=
GetAccService
(
)
)
{
accService
-
>
ScheduleAccessibilitySubtreeUpdate
(
this
&
aElement
)
;
}
#
endif
-
-
mChangeNestCount
;
}
void
PresShell
:
:
PostRecreateFramesFor
(
Element
*
aElement
)
{
if
(
MOZ_UNLIKELY
(
!
mDidInitialize
)
)
{
return
;
}
mPresContext
-
>
RestyleManager
(
)
-
>
PostRestyleEvent
(
aElement
RestyleHint
{
0
}
nsChangeHint_ReconstructFrame
)
;
}
void
PresShell
:
:
RestyleForAnimation
(
Element
*
aElement
RestyleHint
aHint
)
{
mPresContext
-
>
RestyleManager
(
)
-
>
PostRestyleEvent
(
aElement
aHint
nsChangeHint
(
0
)
)
;
}
void
PresShell
:
:
SetForwardingContainer
(
const
WeakPtr
<
nsDocShell
>
&
aContainer
)
{
mForwardingContainer
=
aContainer
;
}
void
PresShell
:
:
ClearFrameRefs
(
nsIFrame
*
aFrame
)
{
mPresContext
-
>
EventStateManager
(
)
-
>
ClearFrameRefs
(
aFrame
)
;
AutoWeakFrame
*
weakFrame
=
mAutoWeakFrames
;
while
(
weakFrame
)
{
AutoWeakFrame
*
prev
=
weakFrame
-
>
GetPreviousWeakFrame
(
)
;
if
(
weakFrame
-
>
GetFrame
(
)
=
=
aFrame
)
{
weakFrame
-
>
Clear
(
this
)
;
}
weakFrame
=
prev
;
}
AutoTArray
<
WeakFrame
*
4
>
toRemove
;
for
(
WeakFrame
*
weakFrame
:
mWeakFrames
)
{
if
(
weakFrame
-
>
GetFrame
(
)
=
=
aFrame
)
{
toRemove
.
AppendElement
(
weakFrame
)
;
}
}
for
(
WeakFrame
*
weakFrame
:
toRemove
)
{
weakFrame
-
>
Clear
(
this
)
;
}
}
UniquePtr
<
gfxContext
>
PresShell
:
:
CreateReferenceRenderingContext
(
)
{
if
(
mPresContext
-
>
IsScreen
(
)
)
{
return
gfxContext
:
:
CreateOrNull
(
gfxPlatform
:
:
GetPlatform
(
)
-
>
ScreenReferenceDrawTarget
(
)
.
get
(
)
)
;
}
nsDeviceContext
*
devCtx
=
mPresContext
-
>
DeviceContext
(
)
;
return
devCtx
-
>
CreateReferenceRenderingContext
(
)
;
}
nsresult
PresShell
:
:
GoToAnchor
(
const
nsAString
&
aAnchorName
bool
aScroll
ScrollFlags
aAdditionalScrollFlags
)
{
if
(
!
mDocument
)
{
return
NS_ERROR_FAILURE
;
}
const
Element
*
root
=
mDocument
-
>
GetRootElement
(
)
;
if
(
root
&
&
root
-
>
IsSVGElement
(
nsGkAtoms
:
:
svg
)
)
{
if
(
SVGFragmentIdentifier
:
:
ProcessFragmentIdentifier
(
mDocument
aAnchorName
)
)
{
return
NS_OK
;
}
}
RefPtr
<
EventStateManager
>
esm
=
mPresContext
-
>
EventStateManager
(
)
;
if
(
aAnchorName
.
IsEmpty
(
)
)
{
NS_ASSERTION
(
!
aScroll
"
can
'
t
scroll
to
empty
anchor
name
"
)
;
esm
-
>
SetContentState
(
nullptr
ElementState
:
:
URLTARGET
)
;
return
NS_OK
;
}
RefPtr
<
Element
>
target
=
nsContentUtils
:
:
GetTargetElement
(
mDocument
aAnchorName
)
;
esm
-
>
SetContentState
(
target
ElementState
:
:
URLTARGET
)
;
if
(
nsIScrollableFrame
*
rootScroll
=
GetRootScrollFrameAsScrollable
(
)
)
{
if
(
rootScroll
-
>
DidHistoryRestore
(
)
)
{
aScroll
=
false
;
rootScroll
-
>
ClearDidHistoryRestore
(
)
;
}
}
if
(
target
)
{
if
(
aScroll
)
{
ScrollingInteractionContext
scrollToAnchorContext
(
true
)
;
MOZ_TRY
(
ScrollContentIntoView
(
target
ScrollAxis
(
WhereToScroll
:
:
Start
WhenToScroll
:
:
Always
)
ScrollAxis
(
)
ScrollFlags
:
:
AnchorScrollFlags
|
aAdditionalScrollFlags
)
)
;
if
(
nsIScrollableFrame
*
rootScroll
=
GetRootScrollFrameAsScrollable
(
)
)
{
mLastAnchorScrolledTo
=
target
;
mLastAnchorScrollPositionY
=
rootScroll
-
>
GetScrollPosition
(
)
.
y
;
}
}
{
RefPtr
<
nsRange
>
jumpToRange
=
nsRange
:
:
Create
(
mDocument
)
;
nsCOMPtr
<
nsIContent
>
nodeToSelect
=
target
.
get
(
)
;
while
(
nodeToSelect
-
>
GetFirstChild
(
)
)
{
nodeToSelect
=
nodeToSelect
-
>
GetFirstChild
(
)
;
}
jumpToRange
-
>
SelectNodeContents
(
*
nodeToSelect
IgnoreErrors
(
)
)
;
if
(
RefPtr
sel
=
mSelection
-
>
GetSelection
(
SelectionType
:
:
eNormal
)
)
{
sel
-
>
RemoveAllRanges
(
IgnoreErrors
(
)
)
;
sel
-
>
AddRangeAndSelectFramesAndNotifyListeners
(
*
jumpToRange
IgnoreErrors
(
)
)
;
if
(
!
StaticPrefs
:
:
layout_selectanchor
(
)
)
{
sel
-
>
CollapseToStart
(
IgnoreErrors
(
)
)
;
}
}
}
const
bool
shouldFocusTarget
=
[
&
]
{
if
(
!
aScroll
)
{
return
false
;
}
nsIFrame
*
targetFrame
=
target
-
>
GetPrimaryFrame
(
)
;
return
targetFrame
&
&
targetFrame
-
>
IsFocusable
(
)
;
}
(
)
;
if
(
shouldFocusTarget
)
{
FocusOptions
options
;
options
.
mPreventScroll
=
true
;
target
-
>
Focus
(
options
CallerType
:
:
NonSystem
IgnoreErrors
(
)
)
;
}
else
if
(
RefPtr
<
nsIFocusManager
>
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
)
{
if
(
nsPIDOMWindowOuter
*
win
=
mDocument
-
>
GetWindow
(
)
)
{
nsCOMPtr
<
mozIDOMWindowProxy
>
focusedWindow
;
fm
-
>
GetFocusedWindow
(
getter_AddRefs
(
focusedWindow
)
)
;
if
(
SameCOMIdentity
(
win
focusedWindow
)
)
{
fm
-
>
ClearFocus
(
focusedWindow
)
;
}
}
}
if
(
auto
*
animationElement
=
SVGAnimationElement
:
:
FromNode
(
target
.
get
(
)
)
)
{
animationElement
-
>
ActivateByHyperlink
(
)
;
}
#
ifdef
ACCESSIBILITY
if
(
nsAccessibilityService
*
accService
=
GetAccService
(
)
)
{
accService
-
>
NotifyOfAnchorJumpTo
(
target
)
;
}
#
endif
}
else
if
(
nsContentUtils
:
:
EqualsIgnoreASCIICase
(
aAnchorName
u
"
top
"
_ns
)
)
{
nsIScrollableFrame
*
sf
=
GetRootScrollFrameAsScrollable
(
)
;
if
(
aScroll
&
&
sf
)
{
ScrollMode
scrollMode
=
sf
-
>
IsSmoothScroll
(
)
?
ScrollMode
:
:
SmoothMsd
:
ScrollMode
:
:
Instant
;
sf
-
>
ScrollTo
(
nsPoint
(
0
0
)
scrollMode
)
;
}
}
else
{
return
NS_ERROR_FAILURE
;
}
return
NS_OK
;
}
nsresult
PresShell
:
:
ScrollToAnchor
(
)
{
nsCOMPtr
<
nsIContent
>
lastAnchor
=
std
:
:
move
(
mLastAnchorScrolledTo
)
;
if
(
!
lastAnchor
)
{
return
NS_OK
;
}
NS_ASSERTION
(
mDidInitialize
"
should
have
done
initial
reflow
by
now
"
)
;
nsIScrollableFrame
*
rootScroll
=
GetRootScrollFrameAsScrollable
(
)
;
if
(
!
rootScroll
|
|
mLastAnchorScrollPositionY
!
=
rootScroll
-
>
GetScrollPosition
(
)
.
y
)
{
return
NS_OK
;
}
return
ScrollContentIntoView
(
lastAnchor
ScrollAxis
(
WhereToScroll
:
:
Start
WhenToScroll
:
:
Always
)
ScrollAxis
(
)
ScrollFlags
:
:
AnchorScrollFlags
)
;
}
static
void
AccumulateFrameBounds
(
nsIFrame
*
aContainerFrame
nsIFrame
*
aFrame
bool
aUseWholeLineHeightForInlines
nsRect
&
aRect
bool
&
aHaveRect
nsIFrame
*
&
aPrevBlock
nsILineIterator
*
&
aLines
int32_t
&
aCurLine
)
{
nsIFrame
*
frame
=
aFrame
;
nsRect
frameBounds
=
nsRect
(
nsPoint
(
0
0
)
aFrame
-
>
GetSize
(
)
)
;
if
(
frameBounds
.
height
=
=
0
|
|
aUseWholeLineHeightForInlines
)
{
nsIFrame
*
prevFrame
=
aFrame
;
nsIFrame
*
f
=
aFrame
;
while
(
f
&
&
f
-
>
IsLineParticipant
(
)
&
&
!
f
-
>
IsTransformed
(
)
&
&
!
f
-
>
IsAbsPosContainingBlock
(
)
)
{
prevFrame
=
f
;
f
=
prevFrame
-
>
GetParent
(
)
;
}
if
(
f
!
=
aFrame
&
&
f
&
&
f
-
>
IsBlockFrame
(
)
)
{
if
(
f
!
=
aPrevBlock
)
{
aLines
=
f
-
>
GetLineIterator
(
)
;
aPrevBlock
=
f
;
aCurLine
=
0
;
}
if
(
aLines
)
{
int32_t
index
=
aLines
-
>
FindLineContaining
(
prevFrame
aCurLine
)
;
if
(
index
>
=
0
)
{
auto
line
=
aLines
-
>
GetLine
(
index
)
.
unwrap
(
)
;
frameBounds
+
=
frame
-
>
GetOffsetTo
(
f
)
;
frame
=
f
;
if
(
line
.
mLineBounds
.
y
<
frameBounds
.
y
)
{
frameBounds
.
height
=
frameBounds
.
YMost
(
)
-
line
.
mLineBounds
.
y
;
frameBounds
.
y
=
line
.
mLineBounds
.
y
;
}
}
}
}
}
nsRect
transformedBounds
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
frame
frameBounds
aContainerFrame
)
;
if
(
aHaveRect
)
{
aRect
=
aRect
.
UnionEdges
(
transformedBounds
)
;
}
else
{
aHaveRect
=
true
;
aRect
=
transformedBounds
;
}
}
static
bool
ComputeNeedToScroll
(
WhenToScroll
aWhenToScroll
nscoord
aLineSize
nscoord
aRectMin
nscoord
aRectMax
nscoord
aViewMin
nscoord
aViewMax
)
{
switch
(
aWhenToScroll
)
{
case
WhenToScroll
:
:
Always
:
return
true
;
case
WhenToScroll
:
:
IfNotVisible
:
if
(
aLineSize
>
(
aRectMax
-
aRectMin
)
)
{
aLineSize
=
0
;
}
return
aRectMax
-
aLineSize
<
=
aViewMin
|
|
aRectMin
+
aLineSize
>
=
aViewMax
;
case
WhenToScroll
:
:
IfNotFullyVisible
:
return
!
(
aRectMin
>
=
aViewMin
&
&
aRectMax
<
=
aViewMax
)
&
&
std
:
:
min
(
aViewMax
aRectMax
)
-
std
:
:
max
(
aRectMin
aViewMin
)
<
aViewMax
-
aViewMin
;
}
return
false
;
}
static
nscoord
ComputeWhereToScroll
(
WhereToScroll
aWhereToScroll
nscoord
aOriginalCoord
nscoord
aRectMin
nscoord
aRectMax
nscoord
aViewMin
nscoord
aViewMax
nscoord
*
aRangeMin
nscoord
*
aRangeMax
)
{
nscoord
resultCoord
=
aOriginalCoord
;
nscoord
scrollPortLength
=
aViewMax
-
aViewMin
;
if
(
!
aWhereToScroll
.
mPercentage
)
{
nscoord
min
=
std
:
:
min
(
aRectMin
aRectMax
-
scrollPortLength
)
;
nscoord
max
=
std
:
:
max
(
aRectMin
aRectMax
-
scrollPortLength
)
;
resultCoord
=
std
:
:
min
(
std
:
:
max
(
aOriginalCoord
min
)
max
)
;
}
else
{
float
percent
=
aWhereToScroll
.
mPercentage
.
value
(
)
/
100
.
0f
;
nscoord
frameAlignCoord
=
NSToCoordRound
(
aRectMin
+
(
aRectMax
-
aRectMin
)
*
percent
)
;
resultCoord
=
NSToCoordRound
(
frameAlignCoord
-
scrollPortLength
*
percent
)
;
}
*
aRangeMin
=
std
:
:
min
(
resultCoord
aRectMax
-
scrollPortLength
)
;
*
aRangeMax
=
std
:
:
max
(
resultCoord
aRectMin
)
;
return
resultCoord
;
}
static
WhereToScroll
GetApplicableWhereToScroll
(
const
nsIScrollableFrame
*
aFrameAsScrollable
const
nsIFrame
*
aScrollableFrame
const
nsIFrame
*
aTarget
ScrollDirection
aScrollDirection
WhereToScroll
aOriginal
)
{
MOZ_ASSERT
(
do_QueryFrame
(
aFrameAsScrollable
)
=
=
aScrollableFrame
)
;
if
(
aTarget
=
=
aScrollableFrame
)
{
return
aOriginal
;
}
StyleScrollSnapAlignKeyword
align
=
aScrollDirection
=
=
ScrollDirection
:
:
eHorizontal
?
aFrameAsScrollable
-
>
GetScrollSnapAlignFor
(
aTarget
)
.
first
:
aFrameAsScrollable
-
>
GetScrollSnapAlignFor
(
aTarget
)
.
second
;
switch
(
align
)
{
case
StyleScrollSnapAlignKeyword
:
:
None
:
return
aOriginal
;
case
StyleScrollSnapAlignKeyword
:
:
Start
:
return
WhereToScroll
:
:
Start
;
case
StyleScrollSnapAlignKeyword
:
:
Center
:
return
WhereToScroll
:
:
Center
;
case
StyleScrollSnapAlignKeyword
:
:
End
:
return
WhereToScroll
:
:
End
;
}
return
aOriginal
;
}
static
void
ScrollToShowRect
(
nsIScrollableFrame
*
aFrameAsScrollable
const
nsIFrame
*
aScrollableFrame
const
nsIFrame
*
aTarget
const
nsRect
&
aRect
const
Sides
aScrollPaddingSkipSides
const
nsMargin
&
aMargin
ScrollAxis
aVertical
ScrollAxis
aHorizontal
ScrollFlags
aScrollFlags
)
{
nsPoint
scrollPt
=
aFrameAsScrollable
-
>
GetVisualViewportOffset
(
)
;
const
nsPoint
originalScrollPt
=
scrollPt
;
const
nsRect
visibleRect
(
scrollPt
aFrameAsScrollable
-
>
GetVisualViewportSize
(
)
)
;
const
nsMargin
padding
=
[
&
]
{
nsMargin
p
=
aFrameAsScrollable
-
>
GetScrollPadding
(
)
;
p
.
ApplySkipSides
(
aScrollPaddingSkipSides
)
;
return
p
+
aMargin
;
}
(
)
;
const
nsRect
rectToScrollIntoView
=
[
&
]
{
nsRect
r
(
aRect
)
;
r
.
Inflate
(
padding
)
;
return
r
.
Intersect
(
aFrameAsScrollable
-
>
GetScrolledRect
(
)
)
;
}
(
)
;
nsSize
lineSize
;
if
(
aVertical
.
mWhenToScroll
=
=
WhenToScroll
:
:
IfNotVisible
|
|
aHorizontal
.
mWhenToScroll
=
=
WhenToScroll
:
:
IfNotVisible
)
{
lineSize
=
aFrameAsScrollable
-
>
GetLineScrollAmount
(
)
;
}
ScrollStyles
ss
=
aFrameAsScrollable
-
>
GetScrollStyles
(
)
;
nsRect
allowedRange
(
scrollPt
nsSize
(
0
0
)
)
;
ScrollDirections
directions
=
aFrameAsScrollable
-
>
GetAvailableScrollingDirections
(
)
;
if
(
(
(
aScrollFlags
&
ScrollFlags
:
:
ScrollOverflowHidden
)
|
|
ss
.
mVertical
!
=
StyleOverflow
:
:
Hidden
)
&
&
(
!
aVertical
.
mOnlyIfPerceivedScrollableDirection
|
|
(
directions
.
contains
(
ScrollDirection
:
:
eVertical
)
)
)
)
{
if
(
ComputeNeedToScroll
(
aVertical
.
mWhenToScroll
lineSize
.
height
aRect
.
y
aRect
.
YMost
(
)
visibleRect
.
y
+
padding
.
top
visibleRect
.
YMost
(
)
-
padding
.
bottom
)
)
{
WhereToScroll
whereToScroll
=
GetApplicableWhereToScroll
(
aFrameAsScrollable
aScrollableFrame
aTarget
ScrollDirection
:
:
eVertical
aVertical
.
mWhereToScroll
)
;
nscoord
maxHeight
;
scrollPt
.
y
=
ComputeWhereToScroll
(
whereToScroll
scrollPt
.
y
rectToScrollIntoView
.
y
rectToScrollIntoView
.
YMost
(
)
visibleRect
.
y
visibleRect
.
YMost
(
)
&
allowedRange
.
y
&
maxHeight
)
;
allowedRange
.
height
=
maxHeight
-
allowedRange
.
y
;
}
}
if
(
(
(
aScrollFlags
&
ScrollFlags
:
:
ScrollOverflowHidden
)
|
|
ss
.
mHorizontal
!
=
StyleOverflow
:
:
Hidden
)
&
&
(
!
aHorizontal
.
mOnlyIfPerceivedScrollableDirection
|
|
(
directions
.
contains
(
ScrollDirection
:
:
eHorizontal
)
)
)
)
{
if
(
ComputeNeedToScroll
(
aHorizontal
.
mWhenToScroll
lineSize
.
width
aRect
.
x
aRect
.
XMost
(
)
visibleRect
.
x
+
padding
.
left
visibleRect
.
XMost
(
)
-
padding
.
right
)
)
{
WhereToScroll
whereToScroll
=
GetApplicableWhereToScroll
(
aFrameAsScrollable
aScrollableFrame
aTarget
ScrollDirection
:
:
eHorizontal
aHorizontal
.
mWhereToScroll
)
;
nscoord
maxWidth
;
scrollPt
.
x
=
ComputeWhereToScroll
(
whereToScroll
scrollPt
.
x
rectToScrollIntoView
.
x
rectToScrollIntoView
.
XMost
(
)
visibleRect
.
x
visibleRect
.
XMost
(
)
&
allowedRange
.
x
&
maxWidth
)
;
allowedRange
.
width
=
maxWidth
-
allowedRange
.
x
;
}
}
if
(
scrollPt
=
=
originalScrollPt
)
{
return
;
}
ScrollMode
scrollMode
=
ScrollMode
:
:
Instant
;
ScrollBehavior
behavior
=
ScrollBehavior
:
:
Instant
;
if
(
aScrollFlags
&
ScrollFlags
:
:
ScrollSmooth
)
{
behavior
=
ScrollBehavior
:
:
Smooth
;
}
else
if
(
aScrollFlags
&
ScrollFlags
:
:
ScrollSmoothAuto
)
{
behavior
=
ScrollBehavior
:
:
Auto
;
}
bool
smoothScroll
=
aFrameAsScrollable
-
>
IsSmoothScroll
(
behavior
)
;
if
(
smoothScroll
)
{
scrollMode
=
ScrollMode
:
:
SmoothMsd
;
}
nsIFrame
*
frame
=
do_QueryFrame
(
aFrameAsScrollable
)
;
AutoWeakFrame
weakFrame
(
frame
)
;
aFrameAsScrollable
-
>
ScrollTo
(
scrollPt
scrollMode
&
allowedRange
ScrollSnapFlags
:
:
IntendedEndPosition
aScrollFlags
&
ScrollFlags
:
:
TriggeredByScript
?
ScrollTriggeredByScript
:
:
Yes
:
ScrollTriggeredByScript
:
:
No
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
;
}
if
(
aFrameAsScrollable
-
>
IsRootScrollFrameOfDocument
(
)
&
&
frame
-
>
PresContext
(
)
-
>
IsRootContentDocumentCrossProcess
(
)
)
{
frame
-
>
PresShell
(
)
-
>
ScrollToVisual
(
scrollPt
FrameMetrics
:
:
eMainThread
scrollMode
)
;
}
}
nsresult
PresShell
:
:
ScrollContentIntoView
(
nsIContent
*
aContent
ScrollAxis
aVertical
ScrollAxis
aHorizontal
ScrollFlags
aScrollFlags
)
{
NS_ENSURE_TRUE
(
aContent
NS_ERROR_NULL_POINTER
)
;
RefPtr
<
Document
>
composedDoc
=
aContent
-
>
GetComposedDoc
(
)
;
NS_ENSURE_STATE
(
composedDoc
)
;
NS_ASSERTION
(
mDidInitialize
"
should
have
done
initial
reflow
by
now
"
)
;
if
(
mContentToScrollTo
)
{
mContentToScrollTo
-
>
RemoveProperty
(
nsGkAtoms
:
:
scrolling
)
;
}
mContentToScrollTo
=
aContent
;
ScrollIntoViewData
*
data
=
new
ScrollIntoViewData
(
)
;
data
-
>
mContentScrollVAxis
=
aVertical
;
data
-
>
mContentScrollHAxis
=
aHorizontal
;
data
-
>
mContentToScrollToFlags
=
aScrollFlags
;
if
(
NS_FAILED
(
mContentToScrollTo
-
>
SetProperty
(
nsGkAtoms
:
:
scrolling
data
nsINode
:
:
DeleteProperty
<
PresShell
:
:
ScrollIntoViewData
>
)
)
)
{
mContentToScrollTo
=
nullptr
;
}
bool
reflowedForHiddenContent
=
false
;
if
(
mContentToScrollTo
)
{
if
(
nsIFrame
*
frame
=
mContentToScrollTo
-
>
GetPrimaryFrame
(
)
)
{
bool
hasContentVisibilityAutoAncestor
=
false
;
auto
*
ancestor
=
frame
-
>
GetClosestContentVisibilityAncestor
(
nsIFrame
:
:
IncludeContentVisibility
:
:
Auto
)
;
while
(
ancestor
)
{
if
(
auto
*
element
=
Element
:
:
FromNodeOrNull
(
ancestor
-
>
GetContent
(
)
)
)
{
hasContentVisibilityAutoAncestor
=
true
;
element
-
>
SetTemporarilyVisibleForScrolledIntoViewDescendant
(
true
)
;
element
-
>
SetVisibleForContentVisibility
(
true
)
;
}
ancestor
=
ancestor
-
>
GetClosestContentVisibilityAncestor
(
nsIFrame
:
:
IncludeContentVisibility
:
:
Auto
)
;
}
if
(
hasContentVisibilityAutoAncestor
)
{
UpdateHiddenContentInForcedLayout
(
frame
)
;
UpdateContentRelevancyImmediately
(
ContentRelevancyReason
:
:
Visible
)
;
reflowedForHiddenContent
=
ReflowForHiddenContentIfNeeded
(
)
;
}
}
}
if
(
!
reflowedForHiddenContent
)
{
if
(
PresShell
*
presShell
=
composedDoc
-
>
GetPresShell
(
)
)
{
presShell
-
>
SetNeedLayoutFlush
(
)
;
}
composedDoc
-
>
FlushPendingNotifications
(
FlushType
:
:
InterruptibleLayout
)
;
}
if
(
mContentToScrollTo
)
{
DoScrollContentIntoView
(
)
;
}
return
NS_OK
;
}
static
nsMargin
GetScrollMargin
(
const
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
)
;
if
(
aFrame
-
>
GetContent
(
)
&
&
aFrame
-
>
GetContent
(
)
-
>
ChromeOnlyAccess
(
)
)
{
if
(
const
nsIContent
*
userContent
=
aFrame
-
>
GetContent
(
)
-
>
GetChromeOnlyAccessSubtreeRootParent
(
)
)
{
if
(
const
nsIFrame
*
frame
=
userContent
-
>
GetPrimaryFrame
(
)
)
{
return
frame
-
>
StyleMargin
(
)
-
>
GetScrollMargin
(
)
;
}
}
}
return
aFrame
-
>
StyleMargin
(
)
-
>
GetScrollMargin
(
)
;
}
void
PresShell
:
:
DoScrollContentIntoView
(
)
{
NS_ASSERTION
(
mDidInitialize
"
should
have
done
initial
reflow
by
now
"
)
;
nsIFrame
*
frame
=
mContentToScrollTo
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
|
|
frame
-
>
IsHiddenByContentVisibilityOnAnyAncestor
(
nsIFrame
:
:
IncludeContentVisibility
:
:
Hidden
)
)
{
mContentToScrollTo
-
>
RemoveProperty
(
nsGkAtoms
:
:
scrolling
)
;
mContentToScrollTo
=
nullptr
;
return
;
}
if
(
frame
-
>
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
)
{
return
;
}
auto
*
data
=
static_cast
<
ScrollIntoViewData
*
>
(
mContentToScrollTo
-
>
GetProperty
(
nsGkAtoms
:
:
scrolling
)
)
;
if
(
MOZ_UNLIKELY
(
!
data
)
)
{
mContentToScrollTo
=
nullptr
;
return
;
}
ScrollFrameIntoView
(
frame
Nothing
(
)
data
-
>
mContentScrollVAxis
data
-
>
mContentScrollHAxis
data
-
>
mContentToScrollToFlags
)
;
}
bool
PresShell
:
:
ScrollFrameIntoView
(
nsIFrame
*
aTargetFrame
const
Maybe
<
nsRect
>
&
aKnownRectRelativeToTarget
ScrollAxis
aVertical
ScrollAxis
aHorizontal
ScrollFlags
aScrollFlags
)
{
const
nsMargin
scrollMargin
=
aKnownRectRelativeToTarget
?
nsMargin
(
)
:
GetScrollMargin
(
aTargetFrame
)
;
Sides
skipPaddingSides
;
const
auto
MaybeSkipPaddingSides
=
[
&
]
(
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
-
>
IsStickyPositioned
(
)
)
{
return
;
}
const
nsPoint
pos
=
aFrame
-
>
GetPosition
(
)
;
const
nsPoint
normalPos
=
aFrame
-
>
GetNormalPosition
(
)
;
if
(
pos
=
=
normalPos
)
{
return
;
}
const
auto
&
offsets
=
aFrame
-
>
StylePosition
(
)
-
>
mOffset
;
for
(
auto
side
:
AllPhysicalSides
(
)
)
{
if
(
offsets
.
Get
(
side
)
.
IsAuto
(
)
)
{
continue
;
}
const
bool
yAxis
=
side
=
=
eSideTop
|
|
side
=
=
eSideBottom
;
const
bool
stuck
=
yAxis
?
pos
.
y
!
=
normalPos
.
y
:
pos
.
x
!
=
normalPos
.
x
;
if
(
!
stuck
)
{
continue
;
}
skipPaddingSides
|
=
SideToSideBit
(
side
)
;
}
}
;
nsIFrame
*
container
=
aTargetFrame
;
nsRect
rect
=
[
&
]
{
if
(
aKnownRectRelativeToTarget
)
{
return
*
aKnownRectRelativeToTarget
;
}
MaybeSkipPaddingSides
(
aTargetFrame
)
;
while
(
nsIFrame
*
parent
=
container
-
>
GetParent
(
)
)
{
container
=
parent
;
if
(
static_cast
<
nsIScrollableFrame
*
>
(
do_QueryFrame
(
container
)
)
)
{
break
;
}
MaybeSkipPaddingSides
(
container
)
;
}
MOZ_DIAGNOSTIC_ASSERT
(
container
)
;
nsRect
targetFrameBounds
;
{
bool
haveRect
=
false
;
const
bool
useWholeLineHeightForInlines
=
aVertical
.
mWhenToScroll
!
=
WhenToScroll
:
:
IfNotFullyVisible
;
AutoAssertNoDomMutations
guard
;
nsIFrame
*
prevBlock
=
nullptr
;
nsILineIterator
*
lines
=
nullptr
;
int32_t
curLine
=
0
;
nsIFrame
*
frame
=
aTargetFrame
;
do
{
AccumulateFrameBounds
(
container
frame
useWholeLineHeightForInlines
targetFrameBounds
haveRect
prevBlock
lines
curLine
)
;
}
while
(
(
frame
=
frame
-
>
GetNextContinuation
(
)
)
)
;
}
return
targetFrameBounds
;
}
(
)
;
bool
didScroll
=
false
;
const
nsIFrame
*
target
=
aTargetFrame
;
do
{
if
(
nsIScrollableFrame
*
sf
=
do_QueryFrame
(
container
)
)
{
nsPoint
oldPosition
=
sf
-
>
GetScrollPosition
(
)
;
nsRect
targetRect
=
rect
;
auto
*
disp
=
container
-
>
StyleDisplay
(
)
;
if
(
disp
-
>
mOverflowClipBoxBlock
=
=
StyleOverflowClipBox
:
:
ContentBox
|
|
disp
-
>
mOverflowClipBoxInline
=
=
StyleOverflowClipBox
:
:
ContentBox
)
{
WritingMode
wm
=
container
-
>
GetWritingMode
(
)
;
bool
cbH
=
(
wm
.
IsVertical
(
)
?
disp
-
>
mOverflowClipBoxBlock
:
disp
-
>
mOverflowClipBoxInline
)
=
=
StyleOverflowClipBox
:
:
ContentBox
;
bool
cbV
=
(
wm
.
IsVertical
(
)
?
disp
-
>
mOverflowClipBoxInline
:
disp
-
>
mOverflowClipBoxBlock
)
=
=
StyleOverflowClipBox
:
:
ContentBox
;
nsMargin
padding
=
container
-
>
GetUsedPadding
(
)
;
if
(
!
cbH
)
{
padding
.
left
=
padding
.
right
=
nscoord
(
0
)
;
}
if
(
!
cbV
)
{
padding
.
top
=
padding
.
bottom
=
nscoord
(
0
)
;
}
targetRect
.
Inflate
(
padding
)
;
}
targetRect
-
=
sf
-
>
GetScrolledFrame
(
)
-
>
GetPosition
(
)
;
{
AutoWeakFrame
wf
(
container
)
;
ScrollToShowRect
(
sf
container
target
targetRect
skipPaddingSides
scrollMargin
aVertical
aHorizontal
aScrollFlags
)
;
if
(
!
wf
.
IsAlive
(
)
)
{
return
didScroll
;
}
}
nsPoint
newPosition
=
sf
-
>
LastScrollDestination
(
)
;
rect
+
=
oldPosition
-
newPosition
;
if
(
oldPosition
!
=
newPosition
)
{
didScroll
=
true
;
}
if
(
aScrollFlags
&
ScrollFlags
:
:
ScrollFirstAncestorOnly
)
{
break
;
}
target
=
container
;
skipPaddingSides
=
{
}
;
}
MaybeSkipPaddingSides
(
container
)
;
nsIFrame
*
parent
;
if
(
container
-
>
IsTransformed
(
)
)
{
container
-
>
GetTransformMatrix
(
ViewportType
:
:
Layout
RelativeTo
{
nullptr
}
&
parent
)
;
rect
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
container
rect
parent
)
;
}
else
{
rect
+
=
container
-
>
GetPosition
(
)
;
parent
=
container
-
>
GetParent
(
)
;
}
if
(
!
parent
&
&
!
(
aScrollFlags
&
ScrollFlags
:
:
ScrollNoParentFrames
)
)
{
nsPoint
extraOffset
(
0
0
)
;
int32_t
APD
=
container
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
parent
=
nsLayoutUtils
:
:
GetCrossDocParentFrameInProcess
(
container
&
extraOffset
)
;
if
(
parent
)
{
int32_t
parentAPD
=
parent
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
rect
=
rect
.
ScaleToOtherAppUnitsRoundOut
(
APD
parentAPD
)
;
rect
+
=
extraOffset
;
}
else
{
nsCOMPtr
<
nsIDocShell
>
docShell
=
container
-
>
PresContext
(
)
-
>
GetDocShell
(
)
;
if
(
BrowserChild
*
browserChild
=
BrowserChild
:
:
GetFrom
(
docShell
)
)
{
Unused
<
<
browserChild
-
>
SendScrollRectIntoView
(
rect
aVertical
aHorizontal
aScrollFlags
APD
)
;
}
}
}
container
=
parent
;
}
while
(
container
)
;
return
didScroll
;
}
void
PresShell
:
:
ScheduleViewManagerFlush
(
)
{
if
(
MOZ_UNLIKELY
(
mIsDestroying
)
)
{
return
;
}
nsPresContext
*
presContext
=
GetPresContext
(
)
;
if
(
presContext
)
{
presContext
-
>
RefreshDriver
(
)
-
>
ScheduleViewManagerFlush
(
)
;
}
SetNeedLayoutFlush
(
)
;
}
void
PresShell
:
:
DispatchSynthMouseMove
(
WidgetGUIEvent
*
aEvent
)
{
AUTO_PROFILER_TRACING_MARKER_DOCSHELL
(
"
Paint
"
"
DispatchSynthMouseMove
"
GRAPHICS
mPresContext
-
>
GetDocShell
(
)
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
nsView
*
targetView
=
nsView
:
:
GetViewFor
(
aEvent
-
>
mWidget
)
;
if
(
!
targetView
)
return
;
RefPtr
<
nsViewManager
>
viewManager
=
targetView
-
>
GetViewManager
(
)
;
viewManager
-
>
DispatchEvent
(
aEvent
targetView
&
status
)
;
}
void
PresShell
:
:
ClearMouseCaptureOnView
(
nsView
*
aView
)
{
if
(
nsIContent
*
capturingContent
=
GetCapturingContent
(
)
)
{
if
(
aView
)
{
nsIFrame
*
frame
=
capturingContent
-
>
GetPrimaryFrame
(
)
;
if
(
frame
)
{
nsView
*
view
=
frame
-
>
GetClosestView
(
)
;
if
(
view
)
{
do
{
if
(
view
=
=
aView
)
{
ReleaseCapturingContent
(
)
;
AllowMouseCapture
(
false
)
;
break
;
}
view
=
view
-
>
GetParent
(
)
;
}
while
(
view
)
;
return
;
}
}
}
ReleaseCapturingContent
(
)
;
}
AllowMouseCapture
(
false
)
;
}
void
PresShell
:
:
ClearMouseCapture
(
)
{
ReleaseCapturingContent
(
)
;
AllowMouseCapture
(
false
)
;
}
void
PresShell
:
:
ClearMouseCapture
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
)
;
nsIContent
*
capturingContent
=
GetCapturingContent
(
)
;
if
(
!
capturingContent
)
{
return
;
}
nsIFrame
*
capturingFrame
=
capturingContent
-
>
GetPrimaryFrame
(
)
;
const
bool
shouldClear
=
!
capturingFrame
|
|
nsLayoutUtils
:
:
IsAncestorFrameCrossDocInProcess
(
aFrame
capturingFrame
)
;
if
(
shouldClear
)
{
ClearMouseCapture
(
)
;
}
}
nsresult
PresShell
:
:
CaptureHistoryState
(
nsILayoutHistoryState
*
*
aState
)
{
MOZ_ASSERT
(
nullptr
!
=
aState
"
null
state
pointer
"
)
;
nsCOMPtr
<
nsIDocShell
>
docShell
(
mPresContext
-
>
GetDocShell
(
)
)
;
if
(
!
docShell
)
return
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsILayoutHistoryState
>
historyState
;
docShell
-
>
GetLayoutHistoryState
(
getter_AddRefs
(
historyState
)
)
;
if
(
!
historyState
)
{
historyState
=
NS_NewLayoutHistoryState
(
)
;
docShell
-
>
SetLayoutHistoryState
(
historyState
)
;
}
*
aState
=
historyState
;
NS_IF_ADDREF
(
*
aState
)
;
nsIFrame
*
rootFrame
=
mFrameConstructor
-
>
GetRootFrame
(
)
;
if
(
!
rootFrame
)
return
NS_OK
;
mFrameConstructor
-
>
CaptureFrameState
(
rootFrame
historyState
)
;
return
NS_OK
;
}
void
PresShell
:
:
ScheduleBeforeFirstPaint
(
)
{
if
(
!
mDocument
-
>
IsResourceDoc
(
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Debug
(
"
PresShell
:
:
ScheduleBeforeFirstPaint
this
=
%
p
"
this
)
)
;
nsContentUtils
:
:
AddScriptRunner
(
new
nsBeforeFirstPaintDispatcher
(
mDocument
)
)
;
}
}
void
PresShell
:
:
UnsuppressAndInvalidate
(
)
{
if
(
(
!
mDocument
-
>
IsResourceDoc
(
)
&
&
!
mPresContext
-
>
EnsureVisible
(
)
)
|
|
mHaveShutDown
)
{
return
;
}
ScheduleBeforeFirstPaint
(
)
;
PROFILER_MARKER_UNTYPED
(
"
UnsuppressAndInvalidate
"
GRAPHICS
)
;
mPaintingSuppressed
=
false
;
if
(
nsIFrame
*
rootFrame
=
mFrameConstructor
-
>
GetRootFrame
(
)
)
{
rootFrame
-
>
InvalidateFrame
(
)
;
}
if
(
mPresContext
-
>
IsRootContentDocumentCrossProcess
(
)
)
{
if
(
auto
*
bc
=
BrowserChild
:
:
GetFrom
(
mDocument
-
>
GetDocShell
(
)
)
)
{
if
(
mDocument
-
>
IsInitialDocument
(
)
)
{
bc
-
>
SendDidUnsuppressPaintingNormalPriority
(
)
;
}
else
{
bc
-
>
SendDidUnsuppressPainting
(
)
;
}
}
}
if
(
nsPIDOMWindowOuter
*
win
=
mDocument
-
>
GetWindow
(
)
)
{
win
-
>
SetReadyForFocus
(
)
;
}
if
(
!
mHaveShutDown
)
{
SynthesizeMouseMove
(
false
)
;
ScheduleApproximateFrameVisibilityUpdateNow
(
)
;
}
}
void
PresShell
:
:
CancelPaintSuppressionTimer
(
)
{
if
(
mPaintSuppressionTimer
)
{
mPaintSuppressionTimer
-
>
Cancel
(
)
;
mPaintSuppressionTimer
=
nullptr
;
}
}
void
PresShell
:
:
UnsuppressPainting
(
)
{
CancelPaintSuppressionTimer
(
)
;
if
(
mIsDocumentGone
|
|
!
mPaintingSuppressed
)
{
return
;
}
if
(
!
mDirtyRoots
.
IsEmpty
(
)
)
mShouldUnsuppressPainting
=
true
;
else
UnsuppressAndInvalidate
(
)
;
}
nsresult
PresShell
:
:
PostReflowCallback
(
nsIReflowCallback
*
aCallback
)
{
void
*
result
=
AllocateByObjectID
(
eArenaObjectID_nsCallbackEventRequest
sizeof
(
nsCallbackEventRequest
)
)
;
nsCallbackEventRequest
*
request
=
(
nsCallbackEventRequest
*
)
result
;
request
-
>
callback
=
aCallback
;
request
-
>
next
=
nullptr
;
if
(
mLastCallbackEventRequest
)
{
mLastCallbackEventRequest
=
mLastCallbackEventRequest
-
>
next
=
request
;
}
else
{
mFirstCallbackEventRequest
=
request
;
mLastCallbackEventRequest
=
request
;
}
return
NS_OK
;
}
void
PresShell
:
:
CancelReflowCallback
(
nsIReflowCallback
*
aCallback
)
{
nsCallbackEventRequest
*
before
=
nullptr
;
nsCallbackEventRequest
*
node
=
mFirstCallbackEventRequest
;
while
(
node
)
{
nsIReflowCallback
*
callback
=
node
-
>
callback
;
if
(
callback
=
=
aCallback
)
{
nsCallbackEventRequest
*
toFree
=
node
;
if
(
node
=
=
mFirstCallbackEventRequest
)
{
node
=
node
-
>
next
;
mFirstCallbackEventRequest
=
node
;
NS_ASSERTION
(
before
=
=
nullptr
"
impossible
"
)
;
}
else
{
node
=
node
-
>
next
;
before
-
>
next
=
node
;
}
if
(
toFree
=
=
mLastCallbackEventRequest
)
{
mLastCallbackEventRequest
=
before
;
}
FreeByObjectID
(
eArenaObjectID_nsCallbackEventRequest
toFree
)
;
}
else
{
before
=
node
;
node
=
node
-
>
next
;
}
}
}
void
PresShell
:
:
CancelPostedReflowCallbacks
(
)
{
while
(
mFirstCallbackEventRequest
)
{
nsCallbackEventRequest
*
node
=
mFirstCallbackEventRequest
;
mFirstCallbackEventRequest
=
node
-
>
next
;
if
(
!
mFirstCallbackEventRequest
)
{
mLastCallbackEventRequest
=
nullptr
;
}
nsIReflowCallback
*
callback
=
node
-
>
callback
;
FreeByObjectID
(
eArenaObjectID_nsCallbackEventRequest
node
)
;
if
(
callback
)
{
callback
-
>
ReflowCallbackCanceled
(
)
;
}
}
}
void
PresShell
:
:
HandlePostedReflowCallbacks
(
bool
aInterruptible
)
{
while
(
true
)
{
bool
shouldFlush
=
false
;
while
(
mFirstCallbackEventRequest
)
{
nsCallbackEventRequest
*
node
=
mFirstCallbackEventRequest
;
mFirstCallbackEventRequest
=
node
-
>
next
;
if
(
!
mFirstCallbackEventRequest
)
{
mLastCallbackEventRequest
=
nullptr
;
}
nsIReflowCallback
*
callback
=
node
-
>
callback
;
FreeByObjectID
(
eArenaObjectID_nsCallbackEventRequest
node
)
;
if
(
callback
&
&
callback
-
>
ReflowFinished
(
)
)
{
shouldFlush
=
true
;
}
}
if
(
!
shouldFlush
|
|
mIsDestroying
)
{
return
;
}
const
auto
flushType
=
aInterruptible
?
FlushType
:
:
InterruptibleLayout
:
FlushType
:
:
Layout
;
FlushPendingNotifications
(
flushType
)
;
}
}
bool
PresShell
:
:
IsSafeToFlush
(
)
const
{
if
(
mIsReflowing
|
|
mChangeNestCount
|
|
mIsDestroying
)
{
return
false
;
}
if
(
nsViewManager
*
viewManager
=
GetViewManager
(
)
)
{
bool
isPainting
=
false
;
viewManager
-
>
IsPainting
(
isPainting
)
;
if
(
isPainting
)
{
return
false
;
}
}
return
true
;
}
void
PresShell
:
:
NotifyFontFaceSetOnRefresh
(
)
{
if
(
FontFaceSet
*
set
=
mDocument
-
>
GetFonts
(
)
)
{
set
-
>
DidRefresh
(
)
;
}
}
void
PresShell
:
:
DoFlushPendingNotifications
(
FlushType
aType
)
{
mozilla
:
:
ChangesToFlush
flush
(
aType
aType
>
=
FlushType
:
:
Style
)
;
FlushPendingNotifications
(
flush
)
;
}
#
ifdef
DEBUG
static
void
AssertFrameSubtreeIsSane
(
const
nsIFrame
&
aRoot
)
{
if
(
const
nsIContent
*
content
=
aRoot
.
GetContent
(
)
)
{
MOZ_ASSERT
(
content
-
>
GetFlattenedTreeParentNodeForStyle
(
)
"
Node
not
in
the
flattened
tree
still
has
a
frame
?
"
)
;
}
for
(
const
auto
&
childList
:
aRoot
.
ChildLists
(
)
)
{
for
(
const
nsIFrame
*
child
:
childList
.
mList
)
{
AssertFrameSubtreeIsSane
(
*
child
)
;
}
}
}
#
endif
static
inline
void
AssertFrameTreeIsSane
(
const
PresShell
&
aPresShell
)
{
#
ifdef
DEBUG
if
(
const
nsIFrame
*
root
=
aPresShell
.
GetRootFrame
(
)
)
{
AssertFrameSubtreeIsSane
(
*
root
)
;
}
#
endif
}
static
void
TriggerPendingScrollTimelineAnimations
(
Document
*
aDocument
)
{
auto
*
tracker
=
aDocument
-
>
GetScrollTimelineAnimationTracker
(
)
;
if
(
!
tracker
|
|
!
tracker
-
>
HasPendingAnimations
(
)
)
{
return
;
}
tracker
-
>
TriggerPendingAnimations
(
)
;
}
void
PresShell
:
:
DoFlushPendingNotifications
(
mozilla
:
:
ChangesToFlush
aFlush
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mForbiddenToFlush
"
This
is
bad
!
"
)
;
RefPtr
<
PresShell
>
kungFuDeathGrip
=
this
;
FlushType
flushType
=
aFlush
.
mFlushType
;
if
(
flushType
>
=
mozilla
:
:
FlushType
:
:
Layout
)
{
UpdateRelevancyOfContentVisibilityAutoFrames
(
)
;
}
MOZ_ASSERT
(
NeedFlush
(
flushType
)
"
Why
did
we
get
called
?
"
)
;
AUTO_PROFILER_MARKER_TEXT
(
"
DoFlushPendingNotifications
"
LAYOUT
MarkerOptions
(
MarkerStack
:
:
Capture
(
)
MarkerInnerWindowIdFromDocShell
(
mPresContext
-
>
GetDocShell
(
)
)
)
nsDependentCString
(
kFlushTypeNames
[
flushType
]
)
)
;
AUTO_PROFILER_LABEL_DYNAMIC_CSTR_NONSENSITIVE
(
"
PresShell
:
:
DoFlushPendingNotifications
"
LAYOUT
kFlushTypeNames
[
flushType
]
)
;
#
ifdef
ACCESSIBILITY
#
ifdef
DEBUG
if
(
nsAccessibilityService
*
accService
=
GetAccService
(
)
)
{
NS_ASSERTION
(
!
accService
-
>
IsProcessingRefreshDriverNotification
(
)
"
Flush
during
accessible
tree
update
!
"
)
;
}
#
endif
#
endif
NS_ASSERTION
(
flushType
>
=
FlushType
:
:
Style
"
Why
did
we
get
called
?
"
)
;
mNeedStyleFlush
=
false
;
mNeedThrottledAnimationFlush
=
mNeedThrottledAnimationFlush
&
&
!
aFlush
.
mFlushAnimations
;
mNeedLayoutFlush
=
mNeedLayoutFlush
&
&
(
flushType
<
FlushType
:
:
InterruptibleLayout
)
;
bool
isSafeToFlush
=
IsSafeToFlush
(
)
;
bool
hasHadScriptObject
;
if
(
mDocument
-
>
GetScriptHandlingObject
(
hasHadScriptObject
)
|
|
hasHadScriptObject
)
{
isSafeToFlush
=
isSafeToFlush
&
&
nsContentUtils
:
:
IsSafeToRunScript
(
)
;
}
if
(
MOZ_UNLIKELY
(
mDocument
-
>
GetPresShell
(
)
!
=
this
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mDocument
-
>
GetPresShell
(
)
"
Where
did
this
shell
come
from
?
"
)
;
isSafeToFlush
=
false
;
}
MOZ_DIAGNOSTIC_ASSERT
(
!
mIsDestroying
|
|
!
isSafeToFlush
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mIsDestroying
|
|
mViewManager
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mIsDestroying
|
|
mDocument
-
>
HasShellOrBFCacheEntry
(
)
)
;
RefPtr
<
nsViewManager
>
viewManager
=
mViewManager
;
bool
didStyleFlush
=
false
;
bool
didLayoutFlush
=
false
;
if
(
isSafeToFlush
)
{
AutoRestore
<
bool
>
guard
(
mInFlush
)
;
mInFlush
=
true
;
mDocument
-
>
FlushExternalResources
(
flushType
)
;
mDocument
-
>
FlushPendingNotifications
(
FlushType
:
:
ContentAndNotify
)
;
mDocument
-
>
UpdateSVGUseElementShadowTrees
(
)
;
if
(
MOZ_LIKELY
(
!
mIsDestroying
)
)
{
viewManager
-
>
FlushDelayedResize
(
)
;
mPresContext
-
>
FlushPendingMediaFeatureValuesChanged
(
)
;
}
if
(
MOZ_LIKELY
(
!
mIsDestroying
)
)
{
StyleSet
(
)
-
>
UpdateStylistIfNeeded
(
)
;
mDocument
-
>
FlushUserFontSet
(
)
;
mPresContext
-
>
FlushCounterStyles
(
)
;
mPresContext
-
>
FlushFontFeatureValues
(
)
;
mPresContext
-
>
FlushFontPaletteValues
(
)
;
if
(
mDocument
-
>
HasAnimationController
(
)
)
{
mDocument
-
>
GetAnimationController
(
)
-
>
FlushResampleRequests
(
)
;
}
}
if
(
MOZ_LIKELY
(
!
mIsDestroying
)
&
&
aFlush
.
mFlushAnimations
&
&
mPresContext
-
>
EffectCompositor
(
)
)
{
mPresContext
-
>
EffectCompositor
(
)
-
>
PostRestyleForThrottledAnimations
(
)
;
}
if
(
MOZ_LIKELY
(
!
mIsDestroying
)
)
{
nsAutoScriptBlocker
scriptBlocker
;
Maybe
<
uint64_t
>
innerWindowID
;
if
(
auto
*
window
=
mDocument
-
>
GetInnerWindow
(
)
)
{
innerWindowID
=
Some
(
window
-
>
WindowID
(
)
)
;
}
AutoProfilerStyleMarker
tracingStyleFlush
(
std
:
:
move
(
mStyleCause
)
innerWindowID
)
;
PerfStats
:
:
AutoMetricRecording
<
PerfStats
:
:
Metric
:
:
Styling
>
autoRecording
;
LAYOUT_TELEMETRY_RECORD_BASE
(
Restyle
)
;
mPresContext
-
>
RestyleManager
(
)
-
>
ProcessPendingRestyles
(
)
;
mNeedStyleFlush
=
false
;
}
AssertFrameTreeIsSane
(
*
this
)
;
didStyleFlush
=
true
;
if
(
flushType
>
=
(
SuppressInterruptibleReflows
(
)
?
FlushType
:
:
Layout
:
FlushType
:
:
InterruptibleLayout
)
&
&
!
mIsDestroying
)
{
didLayoutFlush
=
true
;
if
(
DoFlushLayout
(
flushType
<
FlushType
:
:
Layout
)
)
{
if
(
mContentToScrollTo
)
{
DoScrollContentIntoView
(
)
;
if
(
mContentToScrollTo
)
{
mContentToScrollTo
-
>
RemoveProperty
(
nsGkAtoms
:
:
scrolling
)
;
mContentToScrollTo
=
nullptr
;
}
}
}
}
FlushPendingScrollResnap
(
)
;
if
(
MOZ_LIKELY
(
!
mIsDestroying
)
)
{
TriggerPendingScrollTimelineAnimations
(
mDocument
)
;
}
if
(
flushType
>
=
FlushType
:
:
Layout
)
{
if
(
!
mIsDestroying
)
{
viewManager
-
>
UpdateWidgetGeometry
(
)
;
}
}
}
if
(
!
didStyleFlush
&
&
flushType
>
=
FlushType
:
:
Style
&
&
!
mIsDestroying
)
{
SetNeedStyleFlush
(
)
;
if
(
aFlush
.
mFlushAnimations
)
{
SetNeedThrottledAnimationFlush
(
)
;
}
}
if
(
!
didLayoutFlush
&
&
flushType
>
=
FlushType
:
:
InterruptibleLayout
&
&
!
mIsDestroying
)
{
SetNeedLayoutFlush
(
)
;
}
if
(
didStyleFlush
)
{
mLayoutTelemetry
.
IncReqsPerFlush
(
FlushType
:
:
Style
)
;
}
if
(
didLayoutFlush
)
{
mLayoutTelemetry
.
IncReqsPerFlush
(
FlushType
:
:
Layout
)
;
}
if
(
flushType
>
=
FlushType
:
:
InterruptibleLayout
&
&
didLayoutFlush
)
{
MOZ_ASSERT
(
didLayoutFlush
=
=
didStyleFlush
)
;
mLayoutTelemetry
.
PingReqsPerFlushTelemetry
(
FlushType
:
:
Layout
)
;
}
else
if
(
flushType
>
=
FlushType
:
:
Style
&
&
didStyleFlush
)
{
MOZ_ASSERT
(
!
didLayoutFlush
)
;
mLayoutTelemetry
.
PingReqsPerFlushTelemetry
(
FlushType
:
:
Style
)
;
}
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
PresShell
:
:
CharacterDataChanged
(
nsIContent
*
aContent
const
CharacterDataChangeInfo
&
aInfo
)
{
MOZ_ASSERT
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
;
MOZ_ASSERT
(
!
mIsDocumentGone
"
Unexpected
CharacterDataChanged
"
)
;
MOZ_ASSERT
(
aContent
-
>
OwnerDoc
(
)
=
=
mDocument
"
Unexpected
document
"
)
;
nsAutoCauseReflowNotifier
crNotifier
(
this
)
;
mPresContext
-
>
RestyleManager
(
)
-
>
CharacterDataChanged
(
aContent
aInfo
)
;
mFrameConstructor
-
>
CharacterDataChanged
(
aContent
aInfo
)
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
PresShell
:
:
ElementStateChanged
(
Document
*
aDocument
Element
*
aElement
ElementState
aStateMask
)
{
MOZ_ASSERT
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
;
MOZ_ASSERT
(
!
mIsDocumentGone
"
Unexpected
ContentStateChanged
"
)
;
MOZ_ASSERT
(
aDocument
=
=
mDocument
"
Unexpected
aDocument
"
)
;
if
(
mDidInitialize
)
{
nsAutoCauseReflowNotifier
crNotifier
(
this
)
;
mPresContext
-
>
RestyleManager
(
)
-
>
ElementStateChanged
(
aElement
aStateMask
)
;
}
}
void
PresShell
:
:
DocumentStatesChanged
(
DocumentState
aStateMask
)
{
MOZ_ASSERT
(
!
mIsDocumentGone
"
Unexpected
DocumentStatesChanged
"
)
;
MOZ_ASSERT
(
mDocument
)
;
MOZ_ASSERT
(
!
aStateMask
.
IsEmpty
(
)
)
;
if
(
mDidInitialize
)
{
StyleSet
(
)
-
>
InvalidateStyleForDocumentStateChanges
(
aStateMask
)
;
}
if
(
aStateMask
.
HasState
(
DocumentState
:
:
WINDOW_INACTIVE
)
)
{
if
(
nsIFrame
*
root
=
mFrameConstructor
-
>
GetRootFrame
(
)
)
{
root
-
>
SchedulePaint
(
)
;
}
}
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
PresShell
:
:
AttributeWillChange
(
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
MOZ_ASSERT
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
;
MOZ_ASSERT
(
!
mIsDocumentGone
"
Unexpected
AttributeWillChange
"
)
;
MOZ_ASSERT
(
aElement
-
>
OwnerDoc
(
)
=
=
mDocument
"
Unexpected
document
"
)
;
if
(
mDidInitialize
)
{
nsAutoCauseReflowNotifier
crNotifier
(
this
)
;
mPresContext
-
>
RestyleManager
(
)
-
>
AttributeWillChange
(
aElement
aNameSpaceID
aAttribute
aModType
)
;
}
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
PresShell
:
:
AttributeChanged
(
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
const
nsAttrValue
*
aOldValue
)
{
MOZ_ASSERT
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
;
MOZ_ASSERT
(
!
mIsDocumentGone
"
Unexpected
AttributeChanged
"
)
;
MOZ_ASSERT
(
aElement
-
>
OwnerDoc
(
)
=
=
mDocument
"
Unexpected
document
"
)
;
if
(
mDidInitialize
)
{
nsAutoCauseReflowNotifier
crNotifier
(
this
)
;
mPresContext
-
>
RestyleManager
(
)
-
>
AttributeChanged
(
aElement
aNameSpaceID
aAttribute
aModType
aOldValue
)
;
}
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
PresShell
:
:
ContentAppended
(
nsIContent
*
aFirstNewContent
)
{
MOZ_ASSERT
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
;
MOZ_ASSERT
(
!
mIsDocumentGone
"
Unexpected
ContentAppended
"
)
;
MOZ_ASSERT
(
aFirstNewContent
-
>
OwnerDoc
(
)
=
=
mDocument
"
Unexpected
document
"
)
;
MOZ_ASSERT
(
aFirstNewContent
-
>
GetParent
(
)
)
;
MOZ_ASSERT
(
aFirstNewContent
-
>
GetParent
(
)
-
>
IsElement
(
)
|
|
aFirstNewContent
-
>
GetParent
(
)
-
>
IsShadowRoot
(
)
)
;
if
(
!
mDidInitialize
)
{
return
;
}
nsAutoCauseReflowNotifier
crNotifier
(
this
)
;
mPresContext
-
>
RestyleManager
(
)
-
>
ContentAppended
(
aFirstNewContent
)
;
mFrameConstructor
-
>
ContentAppended
(
aFirstNewContent
nsCSSFrameConstructor
:
:
InsertionKind
:
:
Async
)
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
PresShell
:
:
ContentInserted
(
nsIContent
*
aChild
)
{
MOZ_ASSERT
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
;
MOZ_ASSERT
(
!
mIsDocumentGone
"
Unexpected
ContentInserted
"
)
;
MOZ_ASSERT
(
aChild
-
>
OwnerDoc
(
)
=
=
mDocument
"
Unexpected
document
"
)
;
if
(
!
mDidInitialize
)
{
return
;
}
nsAutoCauseReflowNotifier
crNotifier
(
this
)
;
mPresContext
-
>
RestyleManager
(
)
-
>
ContentInserted
(
aChild
)
;
mFrameConstructor
-
>
ContentInserted
(
aChild
nsCSSFrameConstructor
:
:
InsertionKind
:
:
Async
)
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
PresShell
:
:
ContentRemoved
(
nsIContent
*
aChild
nsIContent
*
aPreviousSibling
)
{
MOZ_ASSERT
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
;
MOZ_ASSERT
(
!
mIsDocumentGone
"
Unexpected
ContentRemoved
"
)
;
MOZ_ASSERT
(
aChild
-
>
OwnerDoc
(
)
=
=
mDocument
"
Unexpected
document
"
)
;
nsINode
*
container
=
aChild
-
>
GetParentNode
(
)
;
mPresContext
-
>
EventStateManager
(
)
-
>
ContentRemoved
(
mDocument
aChild
)
;
nsAutoCauseReflowNotifier
crNotifier
(
this
)
;
nsIContent
*
oldNextSibling
=
nullptr
;
if
(
MOZ_LIKELY
(
!
aChild
-
>
IsRootOfNativeAnonymousSubtree
(
)
)
)
{
oldNextSibling
=
aPreviousSibling
?
aPreviousSibling
-
>
GetNextSibling
(
)
:
container
-
>
GetFirstChild
(
)
;
}
if
(
mPointerEventTarget
&
&
mPointerEventTarget
-
>
IsInclusiveDescendantOf
(
aChild
)
)
{
mPointerEventTarget
=
aChild
-
>
GetParent
(
)
;
}
mFrameConstructor
-
>
ContentRemoved
(
aChild
oldNextSibling
nsCSSFrameConstructor
:
:
REMOVE_CONTENT
)
;
mPresContext
-
>
RestyleManager
(
)
-
>
ContentRemoved
(
aChild
oldNextSibling
)
;
}
void
PresShell
:
:
NotifyCounterStylesAreDirty
(
)
{
nsAutoCauseReflowNotifier
reflowNotifier
(
this
)
;
mFrameConstructor
-
>
NotifyCounterStylesAreDirty
(
)
;
}
bool
PresShell
:
:
FrameIsAncestorOfDirtyRoot
(
nsIFrame
*
aFrame
)
const
{
return
mDirtyRoots
.
FrameIsAncestorOfAnyElement
(
aFrame
)
;
}
void
PresShell
:
:
ReconstructFrames
(
)
{
MOZ_ASSERT
(
!
mFrameConstructor
-
>
GetRootFrame
(
)
|
|
mDidInitialize
"
Must
not
have
root
frame
before
initial
reflow
"
)
;
if
(
!
mDidInitialize
|
|
mIsDestroying
)
{
return
;
}
if
(
Element
*
root
=
mDocument
-
>
GetRootElement
(
)
)
{
PostRecreateFramesFor
(
root
)
;
}
mDocument
-
>
FlushPendingNotifications
(
FlushType
:
:
Frames
)
;
}
nsresult
PresShell
:
:
RenderDocument
(
const
nsRect
&
aRect
RenderDocumentFlags
aFlags
nscolor
aBackgroundColor
gfxContext
*
aThebesContext
)
{
NS_ENSURE_TRUE
(
!
(
aFlags
&
RenderDocumentFlags
:
:
IsUntrusted
)
NS_ERROR_NOT_IMPLEMENTED
)
;
nsRootPresContext
*
rootPresContext
=
mPresContext
-
>
GetRootPresContext
(
)
;
if
(
rootPresContext
)
{
rootPresContext
-
>
FlushWillPaintObservers
(
)
;
if
(
mIsDestroying
)
return
NS_OK
;
}
nsAutoScriptBlocker
blockScripts
;
gfxRect
r
(
0
0
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
aRect
.
width
)
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
aRect
.
height
)
)
;
aThebesContext
-
>
NewPath
(
)
;
#
ifdef
MOZ_GFX_OPTIMIZE_MOBILE
aThebesContext
-
>
SnappedRectangle
(
r
)
;
#
else
aThebesContext
-
>
Rectangle
(
r
)
;
#
endif
nsIFrame
*
rootFrame
=
mFrameConstructor
-
>
GetRootFrame
(
)
;
if
(
!
rootFrame
)
{
aThebesContext
-
>
SetColor
(
sRGBColor
:
:
FromABGR
(
aBackgroundColor
)
)
;
aThebesContext
-
>
Fill
(
)
;
return
NS_OK
;
}
gfxContextAutoSaveRestore
save
(
aThebesContext
)
;
MOZ_ASSERT
(
aThebesContext
-
>
CurrentOp
(
)
=
=
CompositionOp
:
:
OP_OVER
)
;
aThebesContext
-
>
Clip
(
)
;
nsDeviceContext
*
devCtx
=
mPresContext
-
>
DeviceContext
(
)
;
gfxPoint
offset
(
-
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
aRect
.
x
)
-
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
aRect
.
y
)
)
;
gfxFloat
scale
=
gfxFloat
(
devCtx
-
>
AppUnitsPerDevPixel
(
)
)
/
AppUnitsPerCSSPixel
(
)
;
gfxMatrix
newTM
=
aThebesContext
-
>
CurrentMatrixDouble
(
)
.
PreTranslate
(
offset
)
.
PreScale
(
scale
scale
)
.
NudgeToIntegers
(
)
;
aThebesContext
-
>
SetMatrixDouble
(
newTM
)
;
AutoSaveRestoreRenderingState
_
(
this
)
;
bool
wouldFlushRetainedLayers
=
false
;
PaintFrameFlags
flags
=
PaintFrameFlags
:
:
IgnoreSuppression
;
if
(
aThebesContext
-
>
CurrentMatrix
(
)
.
HasNonIntegerTranslation
(
)
)
{
flags
|
=
PaintFrameFlags
:
:
InTransform
;
}
if
(
!
(
aFlags
&
RenderDocumentFlags
:
:
AsyncDecodeImages
)
)
{
flags
|
=
PaintFrameFlags
:
:
SyncDecodeImages
;
}
if
(
aFlags
&
RenderDocumentFlags
:
:
UseHighQualityScaling
)
{
flags
|
=
PaintFrameFlags
:
:
UseHighQualityScaling
;
}
if
(
aFlags
&
RenderDocumentFlags
:
:
UseWidgetLayers
)
{
nsView
*
view
=
rootFrame
-
>
GetView
(
)
;
if
(
view
&
&
view
-
>
GetWidget
(
)
&
&
nsLayoutUtils
:
:
GetDisplayRootFrame
(
rootFrame
)
=
=
rootFrame
)
{
WindowRenderer
*
renderer
=
view
-
>
GetWidget
(
)
-
>
GetWindowRenderer
(
)
;
if
(
renderer
&
&
(
!
renderer
-
>
AsKnowsCompositor
(
)
|
|
XRE_IsParentProcess
(
)
)
)
{
flags
|
=
PaintFrameFlags
:
:
WidgetLayers
;
}
}
}
if
(
!
(
aFlags
&
RenderDocumentFlags
:
:
DrawCaret
)
)
{
wouldFlushRetainedLayers
=
true
;
flags
|
=
PaintFrameFlags
:
:
HideCaret
;
}
if
(
aFlags
&
RenderDocumentFlags
:
:
IgnoreViewportScrolling
)
{
wouldFlushRetainedLayers
=
!
IgnoringViewportScrolling
(
)
;
mRenderingStateFlags
|
=
RenderingStateFlags
:
:
IgnoringViewportScrolling
;
}
if
(
aFlags
&
RenderDocumentFlags
:
:
ResetViewportScrolling
)
{
wouldFlushRetainedLayers
=
true
;
flags
|
=
PaintFrameFlags
:
:
ResetViewportScrolling
;
}
if
(
aFlags
&
RenderDocumentFlags
:
:
DrawWindowNotFlushing
)
{
mRenderingStateFlags
|
=
RenderingStateFlags
:
:
DrawWindowNotFlushing
;
}
if
(
aFlags
&
RenderDocumentFlags
:
:
DocumentRelative
)
{
wouldFlushRetainedLayers
=
true
;
flags
|
=
PaintFrameFlags
:
:
DocumentRelative
;
}
if
(
(
flags
&
PaintFrameFlags
:
:
WidgetLayers
)
&
&
wouldFlushRetainedLayers
)
{
flags
&
=
~
PaintFrameFlags
:
:
WidgetLayers
;
}
nsLayoutUtils
:
:
PaintFrame
(
aThebesContext
rootFrame
nsRegion
(
aRect
)
aBackgroundColor
nsDisplayListBuilderMode
:
:
Painting
flags
)
;
return
NS_OK
;
}
nsRect
PresShell
:
:
ClipListToRange
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
nsRange
*
aRange
)
{
nsRect
surfaceRect
;
for
(
nsDisplayItem
*
i
:
aList
-
>
TakeItems
(
)
)
{
if
(
i
-
>
GetType
(
)
=
=
DisplayItemType
:
:
TYPE_CONTAINER
)
{
aList
-
>
AppendToTop
(
i
)
;
surfaceRect
.
UnionRect
(
surfaceRect
ClipListToRange
(
aBuilder
i
-
>
GetChildren
(
)
aRange
)
)
;
continue
;
}
nsDisplayItem
*
itemToInsert
=
nullptr
;
nsIFrame
*
frame
=
i
-
>
Frame
(
)
;
nsIContent
*
content
=
frame
-
>
GetContent
(
)
;
if
(
content
)
{
bool
atStart
=
(
content
=
=
aRange
-
>
GetStartContainer
(
)
)
;
bool
atEnd
=
(
content
=
=
aRange
-
>
GetEndContainer
(
)
)
;
if
(
(
atStart
|
|
atEnd
)
&
&
frame
-
>
IsTextFrame
(
)
)
{
auto
[
frameStartOffset
frameEndOffset
]
=
frame
-
>
GetOffsets
(
)
;
int32_t
hilightStart
=
atStart
?
std
:
:
max
(
static_cast
<
int32_t
>
(
aRange
-
>
StartOffset
(
)
)
frameStartOffset
)
:
frameStartOffset
;
int32_t
hilightEnd
=
atEnd
?
std
:
:
min
(
static_cast
<
int32_t
>
(
aRange
-
>
EndOffset
(
)
)
frameEndOffset
)
:
frameEndOffset
;
if
(
hilightStart
<
hilightEnd
)
{
nsPoint
startPoint
endPoint
;
frame
-
>
GetPointFromOffset
(
hilightStart
&
startPoint
)
;
frame
-
>
GetPointFromOffset
(
hilightEnd
&
endPoint
)
;
nsRect
textRect
(
aBuilder
-
>
ToReferenceFrame
(
frame
)
frame
-
>
GetSize
(
)
)
;
if
(
frame
-
>
GetWritingMode
(
)
.
IsVertical
(
)
)
{
nscoord
y
=
std
:
:
min
(
startPoint
.
y
endPoint
.
y
)
;
textRect
.
y
+
=
y
;
textRect
.
height
=
std
:
:
max
(
startPoint
.
y
endPoint
.
y
)
-
y
;
}
else
{
nscoord
x
=
std
:
:
min
(
startPoint
.
x
endPoint
.
x
)
;
textRect
.
x
+
=
x
;
textRect
.
width
=
std
:
:
max
(
startPoint
.
x
endPoint
.
x
)
-
x
;
}
surfaceRect
.
UnionRect
(
surfaceRect
textRect
)
;
const
ActiveScrolledRoot
*
asr
=
i
-
>
GetActiveScrolledRoot
(
)
;
DisplayItemClip
newClip
;
newClip
.
SetTo
(
textRect
)
;
const
DisplayItemClipChain
*
newClipChain
=
aBuilder
-
>
AllocateDisplayItemClipChain
(
newClip
asr
nullptr
)
;
i
-
>
IntersectClip
(
aBuilder
newClipChain
true
)
;
itemToInsert
=
i
;
}
}
else
if
(
content
-
>
GetUncomposedDoc
(
)
=
=
aRange
-
>
GetStartContainer
(
)
-
>
GetUncomposedDoc
(
)
)
{
bool
before
after
;
nsresult
rv
=
RangeUtils
:
:
CompareNodeToRange
(
content
aRange
&
before
&
after
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
before
&
&
!
after
)
{
itemToInsert
=
i
;
bool
snap
;
surfaceRect
.
UnionRect
(
surfaceRect
i
-
>
GetBounds
(
aBuilder
&
snap
)
)
;
}
}
}
nsDisplayList
*
sublist
=
i
-
>
GetSameCoordinateSystemChildren
(
)
;
if
(
itemToInsert
|
|
sublist
)
{
aList
-
>
AppendToTop
(
itemToInsert
?
itemToInsert
:
i
)
;
if
(
sublist
)
surfaceRect
.
UnionRect
(
surfaceRect
ClipListToRange
(
aBuilder
sublist
aRange
)
)
;
}
else
{
i
-
>
Destroy
(
aBuilder
)
;
}
}
return
surfaceRect
;
}
#
ifdef
DEBUG
#
include
<
stdio
.
h
>
static
bool
gDumpRangePaintList
=
false
;
#
endif
UniquePtr
<
RangePaintInfo
>
PresShell
:
:
CreateRangePaintInfo
(
nsRange
*
aRange
nsRect
&
aSurfaceRect
bool
aForPrimarySelection
)
{
nsIFrame
*
ancestorFrame
=
nullptr
;
nsIFrame
*
rootFrame
=
GetRootFrame
(
)
;
nsINode
*
startContainer
=
aRange
-
>
GetStartContainer
(
)
;
nsINode
*
endContainer
=
aRange
-
>
GetEndContainer
(
)
;
Document
*
doc
=
startContainer
-
>
GetComposedDoc
(
)
;
if
(
startContainer
=
=
doc
|
|
endContainer
=
=
doc
)
{
ancestorFrame
=
rootFrame
;
}
else
{
nsINode
*
ancestor
=
nsContentUtils
:
:
GetClosestCommonInclusiveAncestor
(
startContainer
endContainer
)
;
NS_ASSERTION
(
!
ancestor
|
|
ancestor
-
>
IsContent
(
)
"
common
ancestor
is
not
content
"
)
;
while
(
ancestor
&
&
ancestor
-
>
IsContent
(
)
)
{
ancestorFrame
=
ancestor
-
>
AsContent
(
)
-
>
GetPrimaryFrame
(
)
;
if
(
ancestorFrame
)
{
break
;
}
ancestor
=
ancestor
-
>
GetParentOrShadowHostNode
(
)
;
}
while
(
ancestorFrame
&
&
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
ancestorFrame
)
)
ancestorFrame
=
ancestorFrame
-
>
GetParent
(
)
;
}
if
(
!
ancestorFrame
)
{
return
nullptr
;
}
auto
info
=
MakeUnique
<
RangePaintInfo
>
(
aRange
ancestorFrame
)
;
info
-
>
mBuilder
.
SetIncludeAllOutOfFlows
(
)
;
if
(
aForPrimarySelection
)
{
info
-
>
mBuilder
.
SetSelectedFramesOnly
(
)
;
}
info
-
>
mBuilder
.
EnterPresShell
(
ancestorFrame
)
;
ContentSubtreeIterator
subtreeIter
;
nsresult
rv
=
subtreeIter
.
Init
(
aRange
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
nullptr
;
}
auto
BuildDisplayListForNode
=
[
&
]
(
nsINode
*
aNode
)
{
if
(
MOZ_UNLIKELY
(
!
aNode
-
>
IsContent
(
)
)
)
{
return
;
}
nsIFrame
*
frame
=
aNode
-
>
AsContent
(
)
-
>
GetPrimaryFrame
(
)
;
for
(
;
frame
;
frame
=
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
frame
)
)
{
info
-
>
mBuilder
.
SetVisibleRect
(
frame
-
>
InkOverflowRect
(
)
)
;
info
-
>
mBuilder
.
SetDirtyRect
(
frame
-
>
InkOverflowRect
(
)
)
;
frame
-
>
BuildDisplayListForStackingContext
(
&
info
-
>
mBuilder
&
info
-
>
mList
)
;
}
}
;
if
(
startContainer
-
>
NodeType
(
)
=
=
nsINode
:
:
TEXT_NODE
)
{
BuildDisplayListForNode
(
startContainer
)
;
}
for
(
;
!
subtreeIter
.
IsDone
(
)
;
subtreeIter
.
Next
(
)
)
{
nsCOMPtr
<
nsINode
>
node
=
subtreeIter
.
GetCurrentNode
(
)
;
BuildDisplayListForNode
(
node
)
;
}
if
(
endContainer
!
=
startContainer
&
&
endContainer
-
>
NodeType
(
)
=
=
nsINode
:
:
TEXT_NODE
)
{
BuildDisplayListForNode
(
endContainer
)
;
}
for
(
nsPresContext
*
ctx
=
GetPresContext
(
)
;
ctx
;
ctx
=
ctx
-
>
GetParentPresContext
(
)
)
{
PresShell
*
shell
=
ctx
-
>
PresShell
(
)
;
float
resolution
=
shell
-
>
GetResolution
(
)
;
if
(
!
ctx
-
>
GetParentPresContext
(
)
)
{
resolution
*
=
ViewportUtils
:
:
TryInferEnclosingResolution
(
shell
)
.
xScale
;
}
if
(
resolution
=
=
1
.
0
)
{
continue
;
}
info
-
>
mResolution
*
=
resolution
;
nsIFrame
*
rootScrollFrame
=
shell
-
>
GetRootScrollFrame
(
)
;
ViewID
zoomedId
=
nsLayoutUtils
:
:
FindOrCreateIDFor
(
rootScrollFrame
-
>
GetContent
(
)
)
;
nsDisplayList
wrapped
(
&
info
-
>
mBuilder
)
;
wrapped
.
AppendNewToTop
<
nsDisplayAsyncZoom
>
(
&
info
-
>
mBuilder
rootScrollFrame
&
info
-
>
mList
nullptr
zoomedId
)
;
info
-
>
mList
.
AppendToTop
(
&
wrapped
)
;
}
#
ifdef
DEBUG
if
(
gDumpRangePaintList
)
{
fprintf
(
stderr
"
CreateRangePaintInfo
-
-
-
before
ClipListToRange
:
\
n
"
)
;
nsIFrame
:
:
PrintDisplayList
(
&
(
info
-
>
mBuilder
)
info
-
>
mList
)
;
}
#
endif
nsRect
rangeRect
=
ClipListToRange
(
&
info
-
>
mBuilder
&
info
-
>
mList
aRange
)
;
info
-
>
mBuilder
.
LeavePresShell
(
ancestorFrame
&
info
-
>
mList
)
;
#
ifdef
DEBUG
if
(
gDumpRangePaintList
)
{
fprintf
(
stderr
"
CreateRangePaintInfo
-
-
-
after
ClipListToRange
:
\
n
"
)
;
nsIFrame
:
:
PrintDisplayList
(
&
(
info
-
>
mBuilder
)
info
-
>
mList
)
;
}
#
endif
info
-
>
mRootOffset
=
ancestorFrame
-
>
GetBoundingClientRect
(
)
.
TopLeft
(
)
;
rangeRect
.
MoveBy
(
info
-
>
mRootOffset
)
;
aSurfaceRect
.
UnionRect
(
aSurfaceRect
rangeRect
)
;
return
info
;
}
already_AddRefed
<
SourceSurface
>
PresShell
:
:
PaintRangePaintInfo
(
const
nsTArray
<
UniquePtr
<
RangePaintInfo
>
>
&
aItems
Selection
*
aSelection
const
Maybe
<
CSSIntRegion
>
&
aRegion
nsRect
aArea
const
LayoutDeviceIntPoint
aPoint
LayoutDeviceIntRect
*
aScreenRect
RenderImageFlags
aFlags
)
{
nsPresContext
*
pc
=
GetPresContext
(
)
;
if
(
!
pc
|
|
aArea
.
width
=
=
0
|
|
aArea
.
height
=
=
0
)
return
nullptr
;
LayoutDeviceIntRect
pixelArea
=
LayoutDeviceIntRect
:
:
FromAppUnitsToOutside
(
aArea
pc
-
>
AppUnitsPerDevPixel
(
)
)
;
float
scale
=
1
.
0
;
nsRect
maxSize
;
pc
-
>
DeviceContext
(
)
-
>
GetClientRect
(
maxSize
)
;
bool
resize
=
!
!
(
aFlags
&
RenderImageFlags
:
:
AutoScale
)
;
if
(
resize
)
{
if
(
aFlags
&
RenderImageFlags
:
:
IsImage
)
{
int32_t
maxWidth
=
pc
-
>
AppUnitsToDevPixels
(
maxSize
.
width
)
;
int32_t
maxHeight
=
pc
-
>
AppUnitsToDevPixels
(
maxSize
.
height
)
;
float
bestHeight
=
float
(
maxHeight
)
*
RELATIVE_SCALEFACTOR
;
float
bestWidth
=
float
(
maxWidth
)
*
RELATIVE_SCALEFACTOR
;
float
adjustedScale
=
bestWidth
/
float
(
pixelArea
.
width
)
;
float
worstHeight
=
float
(
pixelArea
.
height
)
*
adjustedScale
;
float
difference
=
bestHeight
-
worstHeight
;
adjustedScale
=
(
worstHeight
+
difference
/
2
)
/
float
(
pixelArea
.
height
)
;
scale
=
std
:
:
min
(
scale
adjustedScale
)
;
}
else
{
int32_t
maxWidth
=
pc
-
>
AppUnitsToDevPixels
(
maxSize
.
width
>
>
1
)
;
int32_t
maxHeight
=
pc
-
>
AppUnitsToDevPixels
(
maxSize
.
height
>
>
1
)
;
if
(
pixelArea
.
width
>
maxWidth
|
|
pixelArea
.
height
>
maxHeight
)
{
if
(
pixelArea
.
width
>
maxWidth
)
scale
=
std
:
:
min
(
scale
float
(
maxWidth
)
/
pixelArea
.
width
)
;
if
(
pixelArea
.
height
>
maxHeight
)
scale
=
std
:
:
min
(
scale
float
(
maxHeight
)
/
pixelArea
.
height
)
;
}
}
float
resolutionScale
=
1
.
0
;
for
(
const
UniquePtr
<
RangePaintInfo
>
&
rangeInfo
:
aItems
)
{
resolutionScale
=
std
:
:
max
(
resolutionScale
rangeInfo
-
>
mResolution
)
;
}
float
unclampedResolution
=
resolutionScale
;
resolutionScale
=
std
:
:
min
(
resolutionScale
maxSize
.
width
/
(
scale
*
pixelArea
.
width
)
)
;
resolutionScale
=
std
:
:
min
(
resolutionScale
maxSize
.
height
/
(
scale
*
pixelArea
.
height
)
)
;
MOZ_ASSERT
(
resolutionScale
>
=
1
.
0
)
;
resolutionScale
=
std
:
:
max
(
1
.
0f
resolutionScale
)
;
scale
*
=
resolutionScale
;
LayoutDevicePoint
visualPoint
=
ViewportUtils
:
:
ToScreenRelativeVisual
(
LayoutDevicePoint
(
pixelArea
.
TopLeft
(
)
)
pc
)
;
float
scaleRelativeToNormalContent
=
scale
/
unclampedResolution
;
aScreenRect
-
>
x
=
NSToIntFloor
(
aPoint
.
x
-
float
(
aPoint
.
x
.
value
-
visualPoint
.
x
.
value
)
*
scaleRelativeToNormalContent
)
;
aScreenRect
-
>
y
=
NSToIntFloor
(
aPoint
.
y
-
float
(
aPoint
.
y
.
value
-
visualPoint
.
y
.
value
)
*
scaleRelativeToNormalContent
)
;
pixelArea
.
width
=
NSToIntFloor
(
float
(
pixelArea
.
width
)
*
scale
)
;
pixelArea
.
height
=
NSToIntFloor
(
float
(
pixelArea
.
height
)
*
scale
)
;
if
(
!
pixelArea
.
width
|
|
!
pixelArea
.
height
)
{
return
nullptr
;
}
}
else
{
LayoutDevicePoint
visualPoint
=
ViewportUtils
:
:
ToScreenRelativeVisual
(
LayoutDevicePoint
(
pixelArea
.
TopLeft
(
)
)
pc
)
;
aScreenRect
-
>
MoveTo
(
RoundedToInt
(
visualPoint
)
)
;
}
aScreenRect
-
>
width
=
pixelArea
.
width
;
aScreenRect
-
>
height
=
pixelArea
.
height
;
RefPtr
<
DrawTarget
>
dt
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
CreateOffscreenContentDrawTarget
(
IntSize
(
pixelArea
.
width
pixelArea
.
height
)
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
!
dt
|
|
!
dt
-
>
IsValid
(
)
)
{
return
nullptr
;
}
gfxContext
ctx
(
dt
)
;
if
(
aRegion
)
{
RefPtr
<
PathBuilder
>
builder
=
dt
-
>
CreatePathBuilder
(
FillRule
:
:
FILL_WINDING
)
;
nsIntRegion
region
=
aRegion
-
>
ToAppUnits
(
AppUnitsPerCSSPixel
(
)
)
.
ToOutsidePixels
(
pc
-
>
AppUnitsPerDevPixel
(
)
)
;
for
(
auto
iter
=
region
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
IntRect
&
rect
=
iter
.
Get
(
)
;
builder
-
>
MoveTo
(
rect
.
TopLeft
(
)
)
;
builder
-
>
LineTo
(
rect
.
TopRight
(
)
)
;
builder
-
>
LineTo
(
rect
.
BottomRight
(
)
)
;
builder
-
>
LineTo
(
rect
.
BottomLeft
(
)
)
;
builder
-
>
LineTo
(
rect
.
TopLeft
(
)
)
;
}
RefPtr
<
Path
>
path
=
builder
-
>
Finish
(
)
;
ctx
.
Clip
(
path
)
;
}
gfxMatrix
initialTM
=
ctx
.
CurrentMatrixDouble
(
)
;
if
(
resize
)
{
initialTM
.
PreScale
(
scale
scale
)
;
}
gfxPoint
surfaceOffset
=
nsLayoutUtils
:
:
PointToGfxPoint
(
-
aArea
.
TopLeft
(
)
pc
-
>
AppUnitsPerDevPixel
(
)
)
;
initialTM
.
PreTranslate
(
surfaceOffset
)
;
RefPtr
<
nsFrameSelection
>
frameSelection
;
if
(
aSelection
)
{
frameSelection
=
aSelection
-
>
GetFrameSelection
(
)
;
}
else
{
frameSelection
=
FrameSelection
(
)
;
}
int16_t
oldDisplaySelection
=
frameSelection
-
>
GetDisplaySelection
(
)
;
frameSelection
-
>
SetDisplaySelection
(
nsISelectionController
:
:
SELECTION_HIDDEN
)
;
for
(
const
UniquePtr
<
RangePaintInfo
>
&
rangeInfo
:
aItems
)
{
gfxPoint
rootOffset
=
nsLayoutUtils
:
:
PointToGfxPoint
(
rangeInfo
-
>
mRootOffset
pc
-
>
AppUnitsPerDevPixel
(
)
)
;
ctx
.
SetMatrixDouble
(
initialTM
.
PreTranslate
(
rootOffset
)
)
;
aArea
.
MoveBy
(
-
rangeInfo
-
>
mRootOffset
.
x
-
rangeInfo
-
>
mRootOffset
.
y
)
;
nsRegion
visible
(
aArea
)
;
rangeInfo
-
>
mList
.
PaintRoot
(
&
rangeInfo
-
>
mBuilder
&
ctx
nsDisplayList
:
:
PAINT_DEFAULT
Nothing
(
)
)
;
aArea
.
MoveBy
(
rangeInfo
-
>
mRootOffset
.
x
rangeInfo
-
>
mRootOffset
.
y
)
;
}
frameSelection
-
>
SetDisplaySelection
(
oldDisplaySelection
)
;
return
dt
-
>
Snapshot
(
)
;
}
already_AddRefed
<
SourceSurface
>
PresShell
:
:
RenderNode
(
nsINode
*
aNode
const
Maybe
<
CSSIntRegion
>
&
aRegion
const
LayoutDeviceIntPoint
aPoint
LayoutDeviceIntRect
*
aScreenRect
RenderImageFlags
aFlags
)
{
nsRect
area
;
nsTArray
<
UniquePtr
<
RangePaintInfo
>
>
rangeItems
;
if
(
!
aNode
-
>
IsInComposedDoc
(
)
)
{
return
nullptr
;
}
RefPtr
<
nsRange
>
range
=
nsRange
:
:
Create
(
aNode
)
;
IgnoredErrorResult
rv
;
range
-
>
SelectNode
(
*
aNode
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
nullptr
;
}
UniquePtr
<
RangePaintInfo
>
info
=
CreateRangePaintInfo
(
range
area
false
)
;
if
(
info
)
{
rangeItems
.
AppendElement
(
std
:
:
move
(
info
)
)
;
}
Maybe
<
CSSIntRegion
>
region
=
aRegion
;
if
(
region
)
{
CSSIntRect
rrectPixels
=
region
-
>
GetBounds
(
)
;
nsRect
rrect
=
ToAppUnits
(
rrectPixels
AppUnitsPerCSSPixel
(
)
)
;
area
.
IntersectRect
(
area
rrect
)
;
nsPresContext
*
pc
=
GetPresContext
(
)
;
if
(
!
pc
)
return
nullptr
;
region
-
>
MoveBy
(
-
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
area
.
x
)
-
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
area
.
y
)
)
;
}
return
PaintRangePaintInfo
(
rangeItems
nullptr
region
area
aPoint
aScreenRect
aFlags
)
;
}
already_AddRefed
<
SourceSurface
>
PresShell
:
:
RenderSelection
(
Selection
*
aSelection
const
LayoutDeviceIntPoint
aPoint
LayoutDeviceIntRect
*
aScreenRect
RenderImageFlags
aFlags
)
{
nsRect
area
;
nsTArray
<
UniquePtr
<
RangePaintInfo
>
>
rangeItems
;
const
uint32_t
rangeCount
=
aSelection
-
>
RangeCount
(
)
;
NS_ASSERTION
(
rangeCount
>
0
"
RenderSelection
called
with
no
selection
"
)
;
for
(
const
uint32_t
r
:
IntegerRange
(
rangeCount
)
)
{
MOZ_ASSERT
(
aSelection
-
>
RangeCount
(
)
=
=
rangeCount
)
;
RefPtr
<
nsRange
>
range
=
aSelection
-
>
GetRangeAt
(
r
)
;
UniquePtr
<
RangePaintInfo
>
info
=
CreateRangePaintInfo
(
range
area
true
)
;
if
(
info
)
{
rangeItems
.
AppendElement
(
std
:
:
move
(
info
)
)
;
}
}
return
PaintRangePaintInfo
(
rangeItems
aSelection
Nothing
(
)
area
aPoint
aScreenRect
aFlags
)
;
}
void
AddDisplayItemToBottom
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
nsDisplayItem
*
aItem
)
{
if
(
!
aItem
)
{
return
;
}
nsDisplayList
list
(
aBuilder
)
;
list
.
AppendToTop
(
aItem
)
;
list
.
AppendToTop
(
aList
)
;
aList
-
>
AppendToTop
(
&
list
)
;
}
static
bool
AddCanvasBackgroundColor
(
const
nsDisplayList
*
aList
nsIFrame
*
aCanvasFrame
nscolor
aColor
bool
aCSSBackgroundColor
)
{
for
(
nsDisplayItem
*
i
:
*
aList
)
{
const
DisplayItemType
type
=
i
-
>
GetType
(
)
;
if
(
i
-
>
Frame
(
)
=
=
aCanvasFrame
&
&
type
=
=
DisplayItemType
:
:
TYPE_CANVAS_BACKGROUND_COLOR
)
{
auto
*
bg
=
static_cast
<
nsDisplayCanvasBackgroundColor
*
>
(
i
)
;
bg
-
>
SetExtraBackgroundColor
(
aColor
)
;
return
true
;
}
const
bool
isBlendContainer
=
type
=
=
DisplayItemType
:
:
TYPE_BLEND_CONTAINER
|
|
type
=
=
DisplayItemType
:
:
TYPE_TABLE_BLEND_CONTAINER
;
nsDisplayList
*
sublist
=
i
-
>
GetSameCoordinateSystemChildren
(
)
;
if
(
sublist
&
&
!
(
isBlendContainer
&
&
!
aCSSBackgroundColor
)
&
&
AddCanvasBackgroundColor
(
sublist
aCanvasFrame
aColor
aCSSBackgroundColor
)
)
{
return
true
;
}
}
return
false
;
}
void
PresShell
:
:
AddCanvasBackgroundColorItem
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
nsIFrame
*
aFrame
const
nsRect
&
aBounds
nscolor
aBackstopColor
)
{
if
(
aBounds
.
IsEmpty
(
)
)
{
return
;
}
const
bool
isViewport
=
aFrame
-
>
IsViewportFrame
(
)
;
nscolor
canvasColor
;
if
(
isViewport
)
{
canvasColor
=
mCanvasBackground
.
mViewportColor
;
}
else
if
(
aFrame
-
>
IsPageContentFrame
(
)
)
{
canvasColor
=
mCanvasBackground
.
mPageColor
;
}
else
{
return
;
}
const
nscolor
bgcolor
=
NS_ComposeColors
(
aBackstopColor
canvasColor
)
;
if
(
NS_GET_A
(
bgcolor
)
=
=
0
)
{
return
;
}
bool
addedScrollingBackgroundColor
=
false
;
if
(
isViewport
)
{
if
(
nsIScrollableFrame
*
sf
=
GetRootScrollFrameAsScrollable
(
)
)
{
nsCanvasFrame
*
canvasFrame
=
do_QueryFrame
(
sf
-
>
GetScrolledFrame
(
)
)
;
if
(
canvasFrame
&
&
canvasFrame
-
>
IsVisibleForPainting
(
)
)
{
addedScrollingBackgroundColor
=
AddCanvasBackgroundColor
(
aList
canvasFrame
bgcolor
mCanvasBackground
.
mCSSSpecified
)
;
}
}
}
bool
forceUnscrolledItem
=
nsLayoutUtils
:
:
UsesAsyncScrolling
(
aFrame
)
&
&
NS_GET_A
(
bgcolor
)
=
=
255
;
if
(
!
addedScrollingBackgroundColor
|
|
forceUnscrolledItem
)
{
const
bool
isRootContentDocumentCrossProcess
=
mPresContext
-
>
IsRootContentDocumentCrossProcess
(
)
;
MOZ_ASSERT_IF
(
!
aFrame
-
>
GetParent
(
)
&
&
isRootContentDocumentCrossProcess
&
&
mPresContext
-
>
HasDynamicToolbar
(
)
aBounds
.
Size
(
)
=
=
nsLayoutUtils
:
:
ExpandHeightForDynamicToolbar
(
mPresContext
aFrame
-
>
InkOverflowRectRelativeToSelf
(
)
.
Size
(
)
)
)
;
nsDisplaySolidColor
*
item
=
MakeDisplayItem
<
nsDisplaySolidColor
>
(
aBuilder
aFrame
aBounds
bgcolor
)
;
if
(
addedScrollingBackgroundColor
&
&
isRootContentDocumentCrossProcess
)
{
item
-
>
SetIsCheckerboardBackground
(
)
;
}
AddDisplayItemToBottom
(
aBuilder
aList
item
)
;
}
}
bool
PresShell
:
:
IsTransparentContainerElement
(
)
const
{
if
(
mDocument
-
>
IsInitialDocument
(
)
)
{
switch
(
StaticPrefs
:
:
layout_css_initial_document_transparency
(
)
)
{
case
3
:
return
true
;
case
2
:
if
(
!
mDocument
-
>
IsTopLevelContentDocument
(
)
)
{
return
true
;
}
[
[
fallthrough
]
]
;
case
1
:
if
(
mDocument
-
>
IsLikelyContentInaccessibleTopLevelAboutBlank
(
)
)
{
return
true
;
}
[
[
fallthrough
]
]
;
default
:
break
;
}
}
nsPresContext
*
pc
=
GetPresContext
(
)
;
if
(
!
pc
-
>
IsRootContentDocumentCrossProcess
(
)
)
{
if
(
mDocument
-
>
IsInChromeDocShell
(
)
)
{
return
true
;
}
if
(
BrowsingContext
*
bc
=
mDocument
-
>
GetBrowsingContext
(
)
)
{
switch
(
bc
-
>
GetEmbedderColorSchemes
(
)
.
mUsed
)
{
case
dom
:
:
PrefersColorSchemeOverride
:
:
Light
:
return
pc
-
>
DefaultBackgroundColorScheme
(
)
=
=
ColorScheme
:
:
Light
;
case
dom
:
:
PrefersColorSchemeOverride
:
:
Dark
:
return
pc
-
>
DefaultBackgroundColorScheme
(
)
=
=
ColorScheme
:
:
Dark
;
case
dom
:
:
PrefersColorSchemeOverride
:
:
None
:
break
;
}
}
return
true
;
}
nsIDocShell
*
docShell
=
pc
-
>
GetDocShell
(
)
;
if
(
!
docShell
)
{
return
false
;
}
nsPIDOMWindowOuter
*
pwin
=
docShell
-
>
GetWindow
(
)
;
if
(
!
pwin
)
{
return
false
;
}
if
(
Element
*
containerElement
=
pwin
-
>
GetFrameElementInternal
(
)
)
{
return
containerElement
-
>
HasAttr
(
nsGkAtoms
:
:
transparent
)
;
}
if
(
BrowserChild
*
tab
=
BrowserChild
:
:
GetFrom
(
docShell
)
)
{
return
this
=
=
tab
-
>
GetTopLevelPresShell
(
)
&
&
tab
-
>
IsTransparent
(
)
;
}
return
false
;
}
nscolor
PresShell
:
:
GetDefaultBackgroundColorToDraw
(
)
const
{
if
(
!
mPresContext
)
{
return
NS_RGB
(
255
255
255
)
;
}
return
mPresContext
-
>
DefaultBackgroundColor
(
)
;
}
void
PresShell
:
:
UpdateCanvasBackground
(
)
{
mCanvasBackground
=
ComputeCanvasBackground
(
)
;
}
struct
SingleCanvasBackground
{
nscolor
mColor
=
0
;
bool
mCSSSpecified
=
false
;
}
;
static
SingleCanvasBackground
ComputeSingleCanvasBackground
(
nsIFrame
*
aCanvas
)
{
MOZ_ASSERT
(
aCanvas
-
>
IsCanvasFrame
(
)
)
;
const
nsIFrame
*
bgFrame
=
nsCSSRendering
:
:
FindBackgroundFrame
(
aCanvas
)
;
nscolor
color
=
NS_RGBA
(
0
0
0
0
)
;
bool
drawBackgroundImage
=
false
;
bool
drawBackgroundColor
=
false
;
if
(
!
bgFrame
-
>
IsThemed
(
)
)
{
color
=
nsCSSRendering
:
:
DetermineBackgroundColor
(
aCanvas
-
>
PresContext
(
)
bgFrame
-
>
Style
(
)
aCanvas
drawBackgroundImage
drawBackgroundColor
)
;
}
return
{
color
drawBackgroundColor
}
;
}
PresShell
:
:
CanvasBackground
PresShell
:
:
ComputeCanvasBackground
(
)
const
{
nsIFrame
*
canvas
=
GetCanvasFrame
(
)
;
if
(
!
canvas
)
{
nscolor
color
=
GetDefaultBackgroundColorToDraw
(
)
;
return
{
color
color
false
}
;
}
auto
viewportBg
=
ComputeSingleCanvasBackground
(
canvas
)
;
if
(
!
IsTransparentContainerElement
(
)
)
{
viewportBg
.
mColor
=
NS_ComposeColors
(
GetDefaultBackgroundColorToDraw
(
)
viewportBg
.
mColor
)
;
}
nscolor
pageColor
=
viewportBg
.
mColor
;
nsCanvasFrame
*
docElementCb
=
mFrameConstructor
-
>
GetDocElementContainingBlock
(
)
;
if
(
canvas
!
=
docElementCb
)
{
MOZ_ASSERT
(
mPresContext
-
>
IsRootPaginatedDocument
(
)
)
;
pageColor
=
ComputeSingleCanvasBackground
(
docElementCb
)
.
mColor
;
}
return
{
viewportBg
.
mColor
pageColor
viewportBg
.
mCSSSpecified
}
;
}
nscolor
PresShell
:
:
ComputeBackstopColor
(
nsView
*
aDisplayRoot
)
{
nsIWidget
*
widget
=
aDisplayRoot
-
>
GetWidget
(
)
;
if
(
widget
&
&
(
widget
-
>
GetTransparencyMode
(
)
!
=
widget
:
:
TransparencyMode
:
:
Opaque
|
|
widget
-
>
WidgetPaintsBackground
(
)
)
)
{
return
NS_RGBA
(
0
0
0
0
)
;
}
return
GetDefaultBackgroundColorToDraw
(
)
;
}
struct
PaintParams
{
nscolor
mBackgroundColor
;
}
;
WindowRenderer
*
PresShell
:
:
GetWindowRenderer
(
)
{
NS_ASSERTION
(
mViewManager
"
Should
have
view
manager
"
)
;
nsView
*
rootView
=
mViewManager
-
>
GetRootView
(
)
;
if
(
rootView
)
{
if
(
nsIWidget
*
widget
=
rootView
-
>
GetWidget
(
)
)
{
return
widget
-
>
GetWindowRenderer
(
)
;
}
}
return
nullptr
;
}
bool
PresShell
:
:
AsyncPanZoomEnabled
(
)
{
NS_ASSERTION
(
mViewManager
"
Should
have
view
manager
"
)
;
nsView
*
rootView
=
mViewManager
-
>
GetRootView
(
)
;
if
(
rootView
)
{
if
(
nsIWidget
*
widget
=
rootView
-
>
GetWidget
(
)
)
{
return
widget
-
>
AsyncPanZoomEnabled
(
)
;
}
}
return
gfxPlatform
:
:
AsyncPanZoomEnabled
(
)
;
}
nsresult
PresShell
:
:
SetResolutionAndScaleTo
(
float
aResolution
ResolutionChangeOrigin
aOrigin
)
{
if
(
!
(
aResolution
>
0
.
0
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
if
(
aResolution
=
=
mResolution
.
valueOr
(
0
.
0
)
)
{
MOZ_ASSERT
(
mResolution
.
isSome
(
)
)
;
return
NS_OK
;
}
bool
resolutionUpdated
=
(
aResolution
!
=
GetResolution
(
)
)
;
mLastResolutionChangeOrigin
=
aOrigin
;
RenderingState
state
(
this
)
;
state
.
mResolution
=
Some
(
aResolution
)
;
SetRenderingState
(
state
)
;
if
(
mMobileViewportManager
)
{
mMobileViewportManager
-
>
ResolutionUpdated
(
aOrigin
)
;
}
if
(
IsVisualViewportOffsetSet
(
)
)
{
SetVisualViewportOffset
(
GetVisualViewportOffset
(
)
GetLayoutViewportOffset
(
)
)
;
}
if
(
aOrigin
=
=
ResolutionChangeOrigin
:
:
Apz
)
{
mResolutionUpdatedByApz
=
true
;
}
else
if
(
resolutionUpdated
)
{
mResolutionUpdated
=
true
;
}
if
(
auto
*
window
=
nsGlobalWindowInner
:
:
Cast
(
mDocument
-
>
GetInnerWindow
(
)
)
)
{
window
-
>
VisualViewport
(
)
-
>
PostResizeEvent
(
)
;
}
return
NS_OK
;
}
float
PresShell
:
:
GetCumulativeResolution
(
)
const
{
float
resolution
=
GetResolution
(
)
;
nsPresContext
*
parentCtx
=
GetPresContext
(
)
-
>
GetParentPresContext
(
)
;
if
(
parentCtx
)
{
resolution
*
=
parentCtx
-
>
PresShell
(
)
-
>
GetCumulativeResolution
(
)
;
}
return
resolution
;
}
void
PresShell
:
:
SetRestoreResolution
(
float
aResolution
LayoutDeviceIntSize
aDisplaySize
)
{
if
(
mMobileViewportManager
)
{
mMobileViewportManager
-
>
SetRestoreResolution
(
aResolution
aDisplaySize
)
;
}
}
void
PresShell
:
:
SetRenderingState
(
const
RenderingState
&
aState
)
{
if
(
GetResolution
(
)
!
=
aState
.
mResolution
.
valueOr
(
1
.
f
)
)
{
if
(
nsIFrame
*
frame
=
GetRootFrame
(
)
)
{
frame
-
>
SchedulePaint
(
)
;
}
}
mRenderingStateFlags
=
aState
.
mRenderingStateFlags
;
mResolution
=
aState
.
mResolution
;
#
ifdef
ACCESSIBILITY
if
(
nsAccessibilityService
*
accService
=
GetAccService
(
)
)
{
accService
-
>
NotifyOfResolutionChange
(
this
GetResolution
(
)
)
;
}
#
endif
}
void
PresShell
:
:
SynthesizeMouseMove
(
bool
aFromScroll
)
{
if
(
!
StaticPrefs
:
:
layout_reflow_synthMouseMove
(
)
)
return
;
if
(
mPaintingSuppressed
|
|
!
mIsActive
|
|
!
mPresContext
)
{
return
;
}
if
(
!
mPresContext
-
>
IsRoot
(
)
)
{
if
(
PresShell
*
rootPresShell
=
GetRootPresShell
(
)
)
{
rootPresShell
-
>
SynthesizeMouseMove
(
aFromScroll
)
;
}
return
;
}
if
(
mMouseLocation
=
=
nsPoint
(
NS_UNCONSTRAINEDSIZE
NS_UNCONSTRAINEDSIZE
)
)
return
;
if
(
!
mSynthMouseMoveEvent
.
IsPending
(
)
)
{
RefPtr
<
nsSynthMouseMoveEvent
>
ev
=
new
nsSynthMouseMoveEvent
(
this
aFromScroll
)
;
GetPresContext
(
)
-
>
RefreshDriver
(
)
-
>
AddRefreshObserver
(
ev
FlushType
:
:
Display
"
Synthetic
mouse
move
event
"
)
;
mSynthMouseMoveEvent
=
std
:
:
move
(
ev
)
;
}
}
static
nsView
*
FindFloatingViewContaining
(
nsPresContext
*
aRootPresContext
nsIWidget
*
aRootWidget
const
LayoutDeviceIntPoint
&
aPt
)
{
nsIFrame
*
popupFrame
=
nsLayoutUtils
:
:
GetPopupFrameForPoint
(
aRootPresContext
aRootWidget
aPt
nsLayoutUtils
:
:
GetPopupFrameForPointFlags
:
:
OnlyReturnFramesWithWidgets
)
;
return
popupFrame
?
popupFrame
-
>
GetView
(
)
:
nullptr
;
}
static
nsView
*
FindViewContaining
(
nsView
*
aRelativeToView
ViewportType
aRelativeToViewportType
nsView
*
aView
nsPoint
aPt
)
{
MOZ_ASSERT
(
aRelativeToView
-
>
GetFrame
(
)
)
;
if
(
aView
-
>
GetVisibility
(
)
=
=
ViewVisibility
:
:
Hide
)
{
return
nullptr
;
}
nsIFrame
*
frame
=
aView
-
>
GetFrame
(
)
;
if
(
frame
)
{
if
(
!
frame
-
>
PresShell
(
)
-
>
IsActive
(
)
|
|
!
frame
-
>
IsVisibleConsideringAncestors
(
nsIFrame
:
:
VISIBILITY_CROSS_CHROME_CONTENT_BOUNDARY
)
)
{
return
nullptr
;
}
bool
crossingZoomBoundary
=
false
;
if
(
aRelativeToViewportType
=
=
ViewportType
:
:
Visual
)
{
if
(
!
aRelativeToView
-
>
GetParent
(
)
|
|
aRelativeToView
-
>
GetViewManager
(
)
!
=
aRelativeToView
-
>
GetParent
(
)
-
>
GetViewManager
(
)
)
{
if
(
aRelativeToView
-
>
GetFrame
(
)
-
>
PresContext
(
)
-
>
IsRootContentDocumentCrossProcess
(
)
)
{
crossingZoomBoundary
=
true
;
}
}
}
ViewportType
nextRelativeToViewportType
=
aRelativeToViewportType
;
if
(
crossingZoomBoundary
)
{
nextRelativeToViewportType
=
ViewportType
:
:
Layout
;
}
nsLayoutUtils
:
:
TransformResult
result
=
nsLayoutUtils
:
:
TransformPoint
(
RelativeTo
{
aRelativeToView
-
>
GetFrame
(
)
aRelativeToViewportType
}
RelativeTo
{
frame
nextRelativeToViewportType
}
aPt
)
;
if
(
result
!
=
nsLayoutUtils
:
:
TRANSFORM_SUCCEEDED
)
{
return
nullptr
;
}
if
(
!
crossingZoomBoundary
)
{
if
(
!
aView
-
>
GetDimensions
(
)
.
Contains
(
aPt
)
)
{
return
nullptr
;
}
}
aRelativeToView
=
aView
;
aRelativeToViewportType
=
nextRelativeToViewportType
;
}
for
(
nsView
*
v
=
aView
-
>
GetFirstChild
(
)
;
v
;
v
=
v
-
>
GetNextSibling
(
)
)
{
nsView
*
r
=
FindViewContaining
(
aRelativeToView
aRelativeToViewportType
v
aPt
)
;
if
(
r
)
return
r
;
}
return
frame
?
aView
:
nullptr
;
}
static
BrowserBridgeChild
*
GetChildBrowser
(
nsView
*
aView
)
{
if
(
!
aView
)
{
return
nullptr
;
}
nsIFrame
*
frame
=
aView
-
>
GetFrame
(
)
;
if
(
!
frame
&
&
aView
-
>
GetParent
(
)
)
{
frame
=
aView
-
>
GetParent
(
)
-
>
GetFrame
(
)
;
}
if
(
!
frame
|
|
!
frame
-
>
GetContent
(
)
)
{
return
nullptr
;
}
return
BrowserBridgeChild
:
:
GetFrom
(
frame
-
>
GetContent
(
)
)
;
}
void
PresShell
:
:
ProcessSynthMouseMoveEvent
(
bool
aFromScroll
)
{
nsCOMPtr
<
nsIDragSession
>
dragSession
=
nsContentUtils
:
:
GetDragSession
(
)
;
if
(
dragSession
)
{
mSynthMouseMoveEvent
.
Forget
(
)
;
return
;
}
if
(
aFromScroll
)
{
mSynthMouseMoveEvent
.
Forget
(
)
;
}
nsView
*
rootView
=
mViewManager
?
mViewManager
-
>
GetRootView
(
)
:
nullptr
;
if
(
mMouseLocation
=
=
nsPoint
(
NS_UNCONSTRAINEDSIZE
NS_UNCONSTRAINEDSIZE
)
|
|
!
rootView
|
|
!
rootView
-
>
HasWidget
(
)
|
|
!
mPresContext
)
{
mSynthMouseMoveEvent
.
Forget
(
)
;
return
;
}
NS_ASSERTION
(
mPresContext
-
>
IsRoot
(
)
"
Only
a
root
pres
shell
should
be
here
"
)
;
RefPtr
<
PresShell
>
kungFuDeathGrip
(
this
)
;
#
ifdef
DEBUG_MOUSE_LOCATION
printf
(
"
[
ps
=
%
p
]
synthesizing
mouse
move
to
(
%
d
%
d
)
\
n
"
this
mMouseLocation
.
x
mMouseLocation
.
y
)
;
#
endif
int32_t
APD
=
mPresContext
-
>
AppUnitsPerDevPixel
(
)
;
nsView
*
view
=
nullptr
;
int32_t
viewAPD
;
nsPoint
refpoint
(
0
0
)
;
nsViewManager
*
pointVM
=
nullptr
;
if
(
rootView
-
>
GetFrame
(
)
)
{
view
=
FindFloatingViewContaining
(
mPresContext
rootView
-
>
GetWidget
(
)
LayoutDeviceIntPoint
:
:
FromAppUnitsToNearest
(
mMouseLocation
+
rootView
-
>
ViewToWidgetOffset
(
)
APD
)
)
;
}
nsView
*
pointView
=
view
;
if
(
!
view
)
{
view
=
rootView
;
if
(
rootView
-
>
GetFrame
(
)
)
{
pointView
=
FindViewContaining
(
rootView
ViewportType
:
:
Visual
rootView
mMouseLocation
)
;
}
else
{
pointView
=
rootView
;
}
pointVM
=
(
pointView
?
pointView
:
view
)
-
>
GetViewManager
(
)
;
refpoint
=
mMouseLocation
+
rootView
-
>
ViewToWidgetOffset
(
)
;
viewAPD
=
APD
;
}
else
{
pointVM
=
view
-
>
GetViewManager
(
)
;
nsIFrame
*
frame
=
view
-
>
GetFrame
(
)
;
NS_ASSERTION
(
frame
"
floating
views
can
'
t
be
anonymous
"
)
;
viewAPD
=
frame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
refpoint
=
mMouseLocation
;
DebugOnly
<
nsLayoutUtils
:
:
TransformResult
>
result
=
nsLayoutUtils
:
:
TransformPoint
(
RelativeTo
{
rootView
-
>
GetFrame
(
)
ViewportType
:
:
Visual
}
RelativeTo
{
frame
ViewportType
:
:
Layout
}
refpoint
)
;
MOZ_ASSERT
(
result
=
=
nsLayoutUtils
:
:
TRANSFORM_SUCCEEDED
)
;
refpoint
+
=
view
-
>
ViewToWidgetOffset
(
)
;
}
NS_ASSERTION
(
view
-
>
GetWidget
(
)
"
view
should
have
a
widget
here
"
)
;
WidgetMouseEvent
event
(
true
eMouseMove
view
-
>
GetWidget
(
)
WidgetMouseEvent
:
:
eSynthesized
)
;
event
.
mFlags
.
mIsSynthesizedForTests
=
mMouseLocationWasSetBySynthesizedMouseEventForTests
;
event
.
mRefPoint
=
LayoutDeviceIntPoint
:
:
FromAppUnitsToNearest
(
refpoint
viewAPD
)
;
event
.
mButtons
=
PresShell
:
:
sMouseButtons
;
if
(
BrowserBridgeChild
*
bbc
=
GetChildBrowser
(
pointView
)
)
{
event
.
mLayersId
=
bbc
-
>
GetLayersId
(
)
;
bbc
-
>
SendDispatchSynthesizedMouseEvent
(
event
)
;
}
else
if
(
RefPtr
<
PresShell
>
presShell
=
pointVM
-
>
GetPresShell
(
)
)
{
InputAPZContext
apzContext
(
mMouseEventTargetGuid
0
nsEventStatus_eIgnore
)
;
presShell
-
>
DispatchSynthMouseMove
(
&
event
)
;
}
if
(
!
aFromScroll
)
{
mSynthMouseMoveEvent
.
Forget
(
)
;
}
}
void
PresShell
:
:
MarkFramesInListApproximatelyVisible
(
const
nsDisplayList
&
aList
)
{
for
(
nsDisplayItem
*
item
:
aList
)
{
nsDisplayList
*
sublist
=
item
-
>
GetChildren
(
)
;
if
(
sublist
)
{
MarkFramesInListApproximatelyVisible
(
*
sublist
)
;
continue
;
}
nsIFrame
*
frame
=
item
-
>
Frame
(
)
;
MOZ_ASSERT
(
frame
)
;
if
(
!
frame
-
>
TrackingVisibility
(
)
)
{
continue
;
}
PresShell
*
presShell
=
frame
-
>
PresShell
(
)
;
MOZ_ASSERT
(
!
presShell
-
>
AssumeAllFramesVisible
(
)
)
;
if
(
presShell
-
>
mApproximatelyVisibleFrames
.
EnsureInserted
(
frame
)
)
{
frame
-
>
IncApproximateVisibleCount
(
)
;
}
}
}
void
PresShell
:
:
DecApproximateVisibleCount
(
VisibleFrames
&
aFrames
const
Maybe
<
OnNonvisible
>
&
aNonvisibleAction
)
{
for
(
nsIFrame
*
frame
:
aFrames
)
{
if
(
frame
-
>
TrackingVisibility
(
)
)
{
frame
-
>
DecApproximateVisibleCount
(
aNonvisibleAction
)
;
}
}
}
void
PresShell
:
:
RebuildApproximateFrameVisibilityDisplayList
(
const
nsDisplayList
&
aList
)
{
MOZ_ASSERT
(
!
mApproximateFrameVisibilityVisited
"
already
visited
?
"
)
;
mApproximateFrameVisibilityVisited
=
true
;
VisibleFrames
oldApproximatelyVisibleFrames
=
std
:
:
move
(
mApproximatelyVisibleFrames
)
;
MarkFramesInListApproximatelyVisible
(
aList
)
;
DecApproximateVisibleCount
(
oldApproximatelyVisibleFrames
)
;
}
void
PresShell
:
:
ClearApproximateFrameVisibilityVisited
(
nsView
*
aView
bool
aClear
)
{
nsViewManager
*
vm
=
aView
-
>
GetViewManager
(
)
;
if
(
aClear
)
{
PresShell
*
presShell
=
vm
-
>
GetPresShell
(
)
;
if
(
!
presShell
-
>
mApproximateFrameVisibilityVisited
)
{
presShell
-
>
ClearApproximatelyVisibleFramesList
(
)
;
}
presShell
-
>
mApproximateFrameVisibilityVisited
=
false
;
}
for
(
nsView
*
v
=
aView
-
>
GetFirstChild
(
)
;
v
;
v
=
v
-
>
GetNextSibling
(
)
)
{
ClearApproximateFrameVisibilityVisited
(
v
v
-
>
GetViewManager
(
)
!
=
vm
)
;
}
}
void
PresShell
:
:
ClearApproximatelyVisibleFramesList
(
const
Maybe
<
OnNonvisible
>
&
aNonvisibleAction
)
{
DecApproximateVisibleCount
(
mApproximatelyVisibleFrames
aNonvisibleAction
)
;
mApproximatelyVisibleFrames
.
Clear
(
)
;
}
void
PresShell
:
:
MarkFramesInSubtreeApproximatelyVisible
(
nsIFrame
*
aFrame
const
nsRect
&
aRect
bool
aRemoveOnly
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aFrame
"
aFrame
arg
should
be
a
valid
frame
pointer
"
)
;
MOZ_ASSERT
(
aFrame
-
>
PresShell
(
)
=
=
this
"
wrong
presshell
"
)
;
if
(
aFrame
-
>
TrackingVisibility
(
)
&
&
aFrame
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
&
&
(
!
aRemoveOnly
|
|
aFrame
-
>
GetVisibility
(
)
=
=
Visibility
:
:
ApproximatelyVisible
)
)
{
MOZ_ASSERT
(
!
AssumeAllFramesVisible
(
)
)
;
if
(
mApproximatelyVisibleFrames
.
EnsureInserted
(
aFrame
)
)
{
aFrame
-
>
IncApproximateVisibleCount
(
)
;
}
}
nsSubDocumentFrame
*
subdocFrame
=
do_QueryFrame
(
aFrame
)
;
if
(
subdocFrame
)
{
PresShell
*
presShell
=
subdocFrame
-
>
GetSubdocumentPresShellForPainting
(
nsSubDocumentFrame
:
:
IGNORE_PAINT_SUPPRESSION
)
;
if
(
presShell
&
&
!
presShell
-
>
AssumeAllFramesVisible
(
)
)
{
nsRect
rect
=
aRect
;
nsIFrame
*
root
=
presShell
-
>
GetRootFrame
(
)
;
if
(
root
)
{
rect
.
MoveBy
(
aFrame
-
>
GetOffsetToCrossDoc
(
root
)
)
;
}
else
{
rect
.
MoveBy
(
-
aFrame
-
>
GetContentRectRelativeToSelf
(
)
.
TopLeft
(
)
)
;
}
rect
=
rect
.
ScaleToOtherAppUnitsRoundOut
(
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
presShell
-
>
GetPresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
presShell
-
>
RebuildApproximateFrameVisibility
(
&
rect
)
;
}
return
;
}
nsRect
rect
=
aRect
;
nsIScrollableFrame
*
scrollFrame
=
do_QueryFrame
(
aFrame
)
;
if
(
scrollFrame
)
{
bool
ignoreDisplayPort
=
false
;
if
(
DisplayPortUtils
:
:
IsMissingDisplayPortBaseRect
(
aFrame
-
>
GetContent
(
)
)
)
{
nsPresContext
*
pc
=
aFrame
-
>
PresContext
(
)
;
if
(
scrollFrame
-
>
IsRootScrollFrameOfDocument
(
)
&
&
(
pc
-
>
IsRootContentDocumentCrossProcess
(
)
|
|
(
pc
-
>
IsChrome
(
)
&
&
!
pc
-
>
GetParentPresContext
(
)
)
)
)
{
nsRect
baseRect
(
nsPoint
(
)
nsLayoutUtils
:
:
CalculateCompositionSizeForFrame
(
aFrame
)
)
;
DisplayPortUtils
:
:
SetDisplayPortBase
(
aFrame
-
>
GetContent
(
)
baseRect
)
;
}
else
{
ignoreDisplayPort
=
true
;
}
}
nsRect
displayPort
;
bool
usingDisplayport
=
!
ignoreDisplayPort
&
&
DisplayPortUtils
:
:
GetDisplayPortForVisibilityTesting
(
aFrame
-
>
GetContent
(
)
&
displayPort
)
;
scrollFrame
-
>
NotifyApproximateFrameVisibilityUpdate
(
!
usingDisplayport
)
;
if
(
usingDisplayport
)
{
rect
=
displayPort
;
}
else
{
rect
=
rect
.
Intersect
(
scrollFrame
-
>
GetScrollPortRect
(
)
)
;
}
rect
=
scrollFrame
-
>
ExpandRectToNearlyVisible
(
rect
)
;
}
bool
preserves3DChildren
=
aFrame
-
>
Extend3DContext
(
)
;
for
(
const
auto
&
[
list
listID
]
:
aFrame
-
>
ChildLists
(
)
)
{
if
(
listID
=
=
FrameChildListID
:
:
Popup
)
{
continue
;
}
for
(
nsIFrame
*
child
:
list
)
{
MOZ_DIAGNOSTIC_ASSERT
(
child
"
shouldn
'
t
have
null
values
in
child
lists
"
)
;
nsRect
r
=
rect
-
child
-
>
GetPosition
(
)
;
if
(
!
r
.
IntersectRect
(
r
child
-
>
InkOverflowRect
(
)
)
)
{
continue
;
}
if
(
child
-
>
IsTransformed
(
)
)
{
if
(
!
preserves3DChildren
|
|
!
child
-
>
Combines3DTransformWithAncestors
(
)
)
{
const
nsRect
overflow
=
child
-
>
InkOverflowRectRelativeToSelf
(
)
;
nsRect
out
;
if
(
nsDisplayTransform
:
:
UntransformRect
(
r
overflow
child
&
out
)
)
{
r
=
out
;
}
else
{
r
.
SetEmpty
(
)
;
}
}
}
MarkFramesInSubtreeApproximatelyVisible
(
child
r
aRemoveOnly
)
;
}
}
}
void
PresShell
:
:
RebuildApproximateFrameVisibility
(
nsRect
*
aRect
bool
aRemoveOnly
)
{
MOZ_ASSERT
(
!
mApproximateFrameVisibilityVisited
"
already
visited
?
"
)
;
mApproximateFrameVisibilityVisited
=
true
;
nsIFrame
*
rootFrame
=
GetRootFrame
(
)
;
if
(
!
rootFrame
)
{
return
;
}
VisibleFrames
oldApproximatelyVisibleFrames
=
std
:
:
move
(
mApproximatelyVisibleFrames
)
;
nsRect
vis
(
nsPoint
(
0
0
)
rootFrame
-
>
GetSize
(
)
)
;
if
(
aRect
)
{
vis
=
*
aRect
;
}
if
(
mPresContext
-
>
IsRootContentDocumentInProcess
(
)
&
&
!
mPresContext
-
>
IsRootContentDocumentCrossProcess
(
)
)
{
Maybe
<
nsRect
>
visibleRect
;
if
(
BrowserChild
*
browserChild
=
BrowserChild
:
:
GetFrom
(
this
)
)
{
visibleRect
=
browserChild
-
>
GetVisibleRect
(
)
;
}
vis
=
vis
.
Intersect
(
visibleRect
.
valueOr
(
nsRect
(
)
)
)
;
}
MarkFramesInSubtreeApproximatelyVisible
(
rootFrame
vis
aRemoveOnly
)
;
DecApproximateVisibleCount
(
oldApproximatelyVisibleFrames
)
;
}
void
PresShell
:
:
UpdateApproximateFrameVisibility
(
)
{
DoUpdateApproximateFrameVisibility
(
false
)
;
}
void
PresShell
:
:
DoUpdateApproximateFrameVisibility
(
bool
aRemoveOnly
)
{
MOZ_ASSERT
(
!
mPresContext
|
|
mPresContext
-
>
IsRootContentDocumentInProcess
(
)
"
Updating
approximate
frame
visibility
on
a
non
-
root
content
document
?
"
)
;
mUpdateApproximateFrameVisibilityEvent
.
Revoke
(
)
;
if
(
mHaveShutDown
|
|
mIsDestroying
)
{
return
;
}
nsIFrame
*
rootFrame
=
GetRootFrame
(
)
;
if
(
!
rootFrame
)
{
ClearApproximatelyVisibleFramesList
(
Some
(
OnNonvisible
:
:
DiscardImages
)
)
;
return
;
}
RebuildApproximateFrameVisibility
(
nullptr
aRemoveOnly
)
;
ClearApproximateFrameVisibilityVisited
(
rootFrame
-
>
GetView
(
)
true
)
;
#
ifdef
DEBUG_FRAME_VISIBILITY_DISPLAY_LIST
nsDisplayListBuilder
builder
(
rootFrame
nsDisplayListBuilderMode
:
:
FRAME_VISIBILITY
false
)
;
nsRect
updateRect
(
nsPoint
(
0
0
)
rootFrame
-
>
GetSize
(
)
)
;
nsIFrame
*
rootScroll
=
GetRootScrollFrame
(
)
;
if
(
rootScroll
)
{
nsIContent
*
content
=
rootScroll
-
>
GetContent
(
)
;
if
(
content
)
{
Unused
<
<
nsLayoutUtils
:
:
GetDisplayPortForVisibilityTesting
(
content
&
updateRect
RelativeTo
:
:
ScrollFrame
)
;
}
if
(
IgnoringViewportScrolling
(
)
)
{
builder
.
SetIgnoreScrollFrame
(
rootScroll
)
;
}
}
builder
.
IgnorePaintSuppression
(
)
;
builder
.
EnterPresShell
(
rootFrame
)
;
nsDisplayList
list
;
rootFrame
-
>
BuildDisplayListForStackingContext
(
&
builder
updateRect
&
list
)
;
builder
.
LeavePresShell
(
rootFrame
&
list
)
;
RebuildApproximateFrameVisibilityDisplayList
(
list
)
;
ClearApproximateFrameVisibilityVisited
(
rootFrame
-
>
GetView
(
)
true
)
;
list
.
DeleteAll
(
&
builder
)
;
#
endif
}
bool
PresShell
:
:
AssumeAllFramesVisible
(
)
{
if
(
!
StaticPrefs
:
:
layout_framevisibility_enabled
(
)
|
|
!
mPresContext
|
|
!
mDocument
)
{
return
true
;
}
if
(
mPresContext
-
>
Type
(
)
=
=
nsPresContext
:
:
eContext_PrintPreview
|
|
mPresContext
-
>
Type
(
)
=
=
nsPresContext
:
:
eContext_Print
|
|
mPresContext
-
>
IsChrome
(
)
|
|
mDocument
-
>
IsResourceDoc
(
)
)
{
return
true
;
}
if
(
!
mHaveShutDown
&
&
!
mIsDestroying
&
&
!
mPresContext
-
>
IsRootContentDocumentInProcess
(
)
)
{
nsPresContext
*
presContext
=
mPresContext
-
>
GetInProcessRootContentDocumentPresContext
(
)
;
if
(
presContext
&
&
presContext
-
>
PresShell
(
)
-
>
AssumeAllFramesVisible
(
)
)
{
return
true
;
}
}
return
false
;
}
void
PresShell
:
:
ScheduleApproximateFrameVisibilityUpdateSoon
(
)
{
if
(
AssumeAllFramesVisible
(
)
)
{
return
;
}
if
(
!
mPresContext
)
{
return
;
}
nsRefreshDriver
*
refreshDriver
=
mPresContext
-
>
RefreshDriver
(
)
;
if
(
!
refreshDriver
)
{
return
;
}
refreshDriver
-
>
ScheduleFrameVisibilityUpdate
(
)
;
}
void
PresShell
:
:
ScheduleApproximateFrameVisibilityUpdateNow
(
)
{
if
(
AssumeAllFramesVisible
(
)
)
{
return
;
}
if
(
!
mPresContext
-
>
IsRootContentDocumentInProcess
(
)
)
{
nsPresContext
*
presContext
=
mPresContext
-
>
GetInProcessRootContentDocumentPresContext
(
)
;
if
(
!
presContext
)
return
;
MOZ_ASSERT
(
presContext
-
>
IsRootContentDocumentInProcess
(
)
"
Didn
'
t
get
a
root
prescontext
from
"
"
GetInProcessRootContentDocumentPresContext
?
"
)
;
presContext
-
>
PresShell
(
)
-
>
ScheduleApproximateFrameVisibilityUpdateNow
(
)
;
return
;
}
if
(
mHaveShutDown
|
|
mIsDestroying
)
{
return
;
}
if
(
mUpdateApproximateFrameVisibilityEvent
.
IsPending
(
)
)
{
return
;
}
RefPtr
<
nsRunnableMethod
<
PresShell
>
>
event
=
NewRunnableMethod
(
"
PresShell
:
:
UpdateApproximateFrameVisibility
"
this
&
PresShell
:
:
UpdateApproximateFrameVisibility
)
;
nsresult
rv
=
mDocument
-
>
Dispatch
(
do_AddRef
(
event
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mUpdateApproximateFrameVisibilityEvent
=
std
:
:
move
(
event
)
;
}
}
void
PresShell
:
:
EnsureFrameInApproximatelyVisibleList
(
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
-
>
TrackingVisibility
(
)
)
{
return
;
}
if
(
AssumeAllFramesVisible
(
)
)
{
aFrame
-
>
IncApproximateVisibleCount
(
)
;
return
;
}
#
ifdef
DEBUG
nsCOMPtr
<
nsIContent
>
content
=
aFrame
-
>
GetContent
(
)
;
if
(
content
)
{
PresShell
*
presShell
=
content
-
>
OwnerDoc
(
)
-
>
GetPresShell
(
)
;
MOZ_ASSERT
(
!
presShell
|
|
presShell
=
=
this
"
wrong
shell
"
)
;
}
#
endif
if
(
mApproximatelyVisibleFrames
.
EnsureInserted
(
aFrame
)
)
{
aFrame
-
>
IncApproximateVisibleCount
(
)
;
}
}
void
PresShell
:
:
RemoveFrameFromApproximatelyVisibleList
(
nsIFrame
*
aFrame
)
{
#
ifdef
DEBUG
nsCOMPtr
<
nsIContent
>
content
=
aFrame
-
>
GetContent
(
)
;
if
(
content
)
{
PresShell
*
presShell
=
content
-
>
OwnerDoc
(
)
-
>
GetPresShell
(
)
;
MOZ_ASSERT
(
!
presShell
|
|
presShell
=
=
this
"
wrong
shell
"
)
;
}
#
endif
if
(
AssumeAllFramesVisible
(
)
)
{
MOZ_ASSERT
(
mApproximatelyVisibleFrames
.
Count
(
)
=
=
0
"
Shouldn
'
t
have
any
frames
in
the
table
"
)
;
return
;
}
if
(
mApproximatelyVisibleFrames
.
EnsureRemoved
(
aFrame
)
&
&
aFrame
-
>
TrackingVisibility
(
)
)
{
aFrame
-
>
DecApproximateVisibleCount
(
)
;
}
}
void
PresShell
:
:
PaintAndRequestComposite
(
nsView
*
aView
PaintFlags
aFlags
)
{
if
(
!
mIsActive
)
{
return
;
}
WindowRenderer
*
renderer
=
aView
-
>
GetWidget
(
)
-
>
GetWindowRenderer
(
)
;
NS_ASSERTION
(
renderer
"
Must
be
in
paint
event
"
)
;
if
(
renderer
-
>
AsFallback
(
)
)
{
GetViewManager
(
)
-
>
InvalidateView
(
aView
)
;
return
;
}
PaintInternalFlags
flags
=
PaintInternalFlags
:
:
None
;
if
(
aFlags
&
PaintFlags
:
:
PaintSyncDecodeImages
)
{
flags
|
=
PaintInternalFlags
:
:
PaintSyncDecodeImages
;
}
PaintInternal
(
aView
flags
)
;
}
void
PresShell
:
:
SyncPaintFallback
(
nsView
*
aView
)
{
if
(
!
mIsActive
)
{
return
;
}
WindowRenderer
*
renderer
=
aView
-
>
GetWidget
(
)
-
>
GetWindowRenderer
(
)
;
NS_ASSERTION
(
renderer
-
>
AsFallback
(
)
"
Can
'
t
do
Sync
paint
for
remote
renderers
"
)
;
if
(
!
renderer
-
>
AsFallback
(
)
)
{
return
;
}
PaintInternal
(
aView
PaintInternalFlags
:
:
PaintComposite
)
;
GetPresContext
(
)
-
>
NotifyDidPaintForSubtree
(
)
;
}
void
PresShell
:
:
PaintInternal
(
nsView
*
aViewToPaint
PaintInternalFlags
aFlags
)
{
nsCString
url
;
nsIURI
*
uri
=
mDocument
-
>
GetDocumentURI
(
)
;
Document
*
contentRoot
=
GetPrimaryContentDocument
(
)
;
if
(
contentRoot
)
{
uri
=
contentRoot
-
>
GetDocumentURI
(
)
;
}
url
=
uri
?
uri
-
>
GetSpecOrDefault
(
)
:
"
N
/
A
"
_ns
;
AUTO_PROFILER_LABEL_DYNAMIC_NSCSTRING_RELEVANT_FOR_JS
(
"
Paint
"
GRAPHICS
Substring
(
url
std
:
:
min
(
size_t
(
128
)
url
.
Length
(
)
)
)
)
;
Maybe
<
js
:
:
AutoAssertNoContentJS
>
nojs
;
#
if
!
defined
(
MOZ_WIDGET_ANDROID
)
if
(
!
(
aFlags
&
PaintInternalFlags
:
:
PaintComposite
)
)
{
nojs
.
emplace
(
dom
:
:
danger
:
:
GetJSContext
(
)
)
;
}
#
endif
NS_ASSERTION
(
!
mIsDestroying
"
painting
a
destroyed
PresShell
"
)
;
NS_ASSERTION
(
aViewToPaint
"
null
view
"
)
;
MOZ_ASSERT
(
!
mApproximateFrameVisibilityVisited
"
Should
have
been
cleared
"
)
;
if
(
!
mIsActive
)
{
return
;
}
if
(
StaticPrefs
:
:
apz_keyboard_enabled_AtStartup
(
)
)
{
mAPZFocusTarget
=
FocusTarget
(
this
mAPZFocusSequenceNumber
)
;
}
nsPresContext
*
presContext
=
GetPresContext
(
)
;
AUTO_LAYOUT_PHASE_ENTRY_POINT
(
presContext
Paint
)
;
nsIFrame
*
frame
=
aViewToPaint
-
>
GetFrame
(
)
;
WindowRenderer
*
renderer
=
aViewToPaint
-
>
GetWidget
(
)
-
>
GetWindowRenderer
(
)
;
NS_ASSERTION
(
renderer
"
Must
be
in
paint
event
"
)
;
WebRenderLayerManager
*
layerManager
=
renderer
-
>
AsWebRender
(
)
;
if
(
mIsFirstPaint
&
&
!
mPaintingSuppressed
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Debug
(
"
PresShell
:
:
Paint
first
paint
this
=
%
p
"
this
)
)
;
if
(
layerManager
)
{
layerManager
-
>
SetIsFirstPaint
(
)
;
}
mIsFirstPaint
=
false
;
}
if
(
!
renderer
-
>
BeginTransaction
(
url
)
)
{
return
;
}
if
(
layerManager
)
{
layerManager
-
>
SetFocusTarget
(
mAPZFocusTarget
)
;
}
if
(
frame
)
{
if
(
!
(
aFlags
&
PaintInternalFlags
:
:
PaintSyncDecodeImages
)
&
&
!
frame
-
>
HasAnyStateBits
(
NS_FRAME_UPDATE_LAYER_TREE
)
)
{
if
(
layerManager
)
{
layerManager
-
>
SetTransactionIdAllocator
(
presContext
-
>
RefreshDriver
(
)
)
;
}
if
(
renderer
-
>
EndEmptyTransaction
(
(
aFlags
&
PaintInternalFlags
:
:
PaintComposite
)
?
WindowRenderer
:
:
END_DEFAULT
:
WindowRenderer
:
:
END_NO_COMPOSITE
)
)
{
return
;
}
}
frame
-
>
RemoveStateBits
(
NS_FRAME_UPDATE_LAYER_TREE
)
;
}
nscolor
bgcolor
=
ComputeBackstopColor
(
aViewToPaint
)
;
PaintFrameFlags
flags
=
PaintFrameFlags
:
:
WidgetLayers
|
PaintFrameFlags
:
:
ExistingTransaction
;
if
(
aFlags
&
PaintInternalFlags
:
:
PaintSyncDecodeImages
|
|
mDocument
-
>
IsStaticDocument
(
)
|
|
StaticPrefs
:
:
image_decode_sync_enabled
(
)
)
{
flags
|
=
PaintFrameFlags
:
:
SyncDecodeImages
;
}
if
(
renderer
-
>
GetBackendType
(
)
=
=
layers
:
:
LayersBackend
:
:
LAYERS_WR
)
{
flags
|
=
PaintFrameFlags
:
:
ForWebRender
;
}
if
(
frame
)
{
nsLayoutUtils
:
:
PaintFrame
(
nullptr
frame
nsRegion
(
)
bgcolor
nsDisplayListBuilderMode
:
:
Painting
flags
)
;
return
;
}
bgcolor
=
NS_ComposeColors
(
bgcolor
mCanvasBackground
.
mViewportColor
)
;
if
(
renderer
-
>
GetBackendType
(
)
=
=
layers
:
:
LayersBackend
:
:
LAYERS_WR
)
{
LayoutDeviceRect
bounds
=
LayoutDeviceRect
:
:
FromAppUnits
(
presContext
-
>
GetVisibleArea
(
)
presContext
-
>
AppUnitsPerDevPixel
(
)
)
;
WebRenderBackgroundData
data
(
wr
:
:
ToLayoutRect
(
bounds
)
wr
:
:
ToColorF
(
ToDeviceColor
(
bgcolor
)
)
)
;
WrFiltersHolder
wrFilters
;
layerManager
-
>
SetTransactionIdAllocator
(
presContext
-
>
RefreshDriver
(
)
)
;
layerManager
-
>
EndTransactionWithoutLayer
(
nullptr
nullptr
std
:
:
move
(
wrFilters
)
&
data
0
)
;
return
;
}
FallbackRenderer
*
fallback
=
renderer
-
>
AsFallback
(
)
;
MOZ_ASSERT
(
fallback
)
;
if
(
aFlags
&
PaintInternalFlags
:
:
PaintComposite
)
{
nsIntRect
bounds
=
presContext
-
>
GetVisibleArea
(
)
.
ToOutsidePixels
(
presContext
-
>
AppUnitsPerDevPixel
(
)
)
;
fallback
-
>
EndTransactionWithColor
(
bounds
ToDeviceColor
(
bgcolor
)
)
;
}
}
void
PresShell
:
:
SetCapturingContent
(
nsIContent
*
aContent
CaptureFlags
aFlags
WidgetEvent
*
aEvent
)
{
if
(
!
aContent
&
&
sCapturingContentInfo
.
mPointerLock
&
&
!
(
aFlags
&
CaptureFlags
:
:
PointerLock
)
)
{
return
;
}
sCapturingContentInfo
.
mContent
=
nullptr
;
sCapturingContentInfo
.
mRemoteTarget
=
nullptr
;
if
(
(
aFlags
&
CaptureFlags
:
:
IgnoreAllowedState
)
|
|
sCapturingContentInfo
.
mAllowed
|
|
(
aFlags
&
CaptureFlags
:
:
PointerLock
)
)
{
if
(
aContent
)
{
sCapturingContentInfo
.
mContent
=
aContent
;
}
if
(
aEvent
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
aEvent
-
>
mMessage
=
=
eMouseDown
)
;
MOZ_ASSERT
(
aEvent
-
>
HasBeenPostedToRemoteProcess
(
)
)
;
sCapturingContentInfo
.
mRemoteTarget
=
BrowserParent
:
:
GetLastMouseRemoteTarget
(
)
;
MOZ_ASSERT
(
sCapturingContentInfo
.
mRemoteTarget
)
;
}
sCapturingContentInfo
.
mRetargetToElement
=
!
!
(
aFlags
&
CaptureFlags
:
:
RetargetToElement
)
|
|
!
!
(
aFlags
&
CaptureFlags
:
:
PointerLock
)
;
sCapturingContentInfo
.
mPreventDrag
=
!
!
(
aFlags
&
CaptureFlags
:
:
PreventDragStart
)
;
sCapturingContentInfo
.
mPointerLock
=
!
!
(
aFlags
&
CaptureFlags
:
:
PointerLock
)
;
}
}
nsIContent
*
PresShell
:
:
GetCurrentEventContent
(
)
{
if
(
mCurrentEventContent
&
&
mCurrentEventContent
-
>
GetComposedDoc
(
)
!
=
mDocument
)
{
mCurrentEventContent
=
nullptr
;
mCurrentEventFrame
=
nullptr
;
}
return
mCurrentEventContent
;
}
nsIFrame
*
PresShell
:
:
GetCurrentEventFrame
(
)
{
if
(
MOZ_UNLIKELY
(
mIsDestroying
)
)
{
return
nullptr
;
}
nsIContent
*
content
=
GetCurrentEventContent
(
)
;
if
(
!
mCurrentEventFrame
&
&
content
)
{
mCurrentEventFrame
=
content
-
>
GetPrimaryFrame
(
)
;
MOZ_ASSERT
(
!
mCurrentEventFrame
|
|
mCurrentEventFrame
-
>
PresContext
(
)
-
>
GetPresShell
(
)
=
=
this
)
;
}
return
mCurrentEventFrame
;
}
already_AddRefed
<
nsIContent
>
PresShell
:
:
GetEventTargetContent
(
WidgetEvent
*
aEvent
)
{
nsCOMPtr
<
nsIContent
>
content
=
GetCurrentEventContent
(
)
;
if
(
!
content
)
{
nsIFrame
*
currentEventFrame
=
GetCurrentEventFrame
(
)
;
if
(
currentEventFrame
)
{
currentEventFrame
-
>
GetContentForEvent
(
aEvent
getter_AddRefs
(
content
)
)
;
NS_ASSERTION
(
!
content
|
|
content
-
>
GetComposedDoc
(
)
=
=
mDocument
"
handing
out
content
from
a
different
doc
"
)
;
}
}
return
content
.
forget
(
)
;
}
void
PresShell
:
:
PushCurrentEventInfo
(
nsIFrame
*
aFrame
nsIContent
*
aContent
)
{
if
(
mCurrentEventFrame
|
|
mCurrentEventContent
)
{
mCurrentEventFrameStack
.
InsertElementAt
(
0
mCurrentEventFrame
)
;
mCurrentEventContentStack
.
InsertObjectAt
(
mCurrentEventContent
0
)
;
}
mCurrentEventFrame
=
aFrame
;
mCurrentEventContent
=
aContent
;
}
void
PresShell
:
:
PopCurrentEventInfo
(
)
{
mCurrentEventFrame
=
nullptr
;
mCurrentEventContent
=
nullptr
;
if
(
0
!
=
mCurrentEventFrameStack
.
Length
(
)
)
{
mCurrentEventFrame
=
mCurrentEventFrameStack
.
ElementAt
(
0
)
;
mCurrentEventFrameStack
.
RemoveElementAt
(
0
)
;
mCurrentEventContent
=
mCurrentEventContentStack
.
ObjectAt
(
0
)
;
mCurrentEventContentStack
.
RemoveObjectAt
(
0
)
;
if
(
mCurrentEventContent
&
&
mCurrentEventContent
-
>
GetComposedDoc
(
)
!
=
mDocument
)
{
mCurrentEventContent
=
nullptr
;
mCurrentEventFrame
=
nullptr
;
}
}
}
bool
PresShell
:
:
EventHandler
:
:
InZombieDocument
(
nsIContent
*
aContent
)
{
Document
*
doc
=
aContent
-
>
GetComposedDoc
(
)
;
return
!
doc
|
|
!
doc
-
>
GetWindow
(
)
;
}
already_AddRefed
<
nsPIDOMWindowOuter
>
PresShell
:
:
GetRootWindow
(
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
mDocument
-
>
GetWindow
(
)
;
if
(
window
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
rootWindow
=
window
-
>
GetPrivateRoot
(
)
;
NS_ASSERTION
(
rootWindow
"
nsPIDOMWindow
:
:
GetPrivateRoot
(
)
returns
NULL
"
)
;
return
rootWindow
.
forget
(
)
;
}
RefPtr
<
PresShell
>
parentPresShell
=
GetParentPresShellForEventHandling
(
)
;
NS_ENSURE_TRUE
(
parentPresShell
nullptr
)
;
return
parentPresShell
-
>
GetRootWindow
(
)
;
}
already_AddRefed
<
nsPIDOMWindowOuter
>
PresShell
:
:
GetFocusedDOMWindowInOurWindow
(
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
rootWindow
=
GetRootWindow
(
)
;
NS_ENSURE_TRUE
(
rootWindow
nullptr
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
focusedWindow
;
nsFocusManager
:
:
GetFocusedDescendant
(
rootWindow
nsFocusManager
:
:
eIncludeAllDescendants
getter_AddRefs
(
focusedWindow
)
)
;
return
focusedWindow
.
forget
(
)
;
}
already_AddRefed
<
nsIContent
>
PresShell
:
:
GetFocusedContentInOurWindow
(
)
const
{
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
fm
&
&
mDocument
)
{
RefPtr
<
Element
>
focusedElement
;
fm
-
>
GetFocusedElementForWindow
(
mDocument
-
>
GetWindow
(
)
false
nullptr
getter_AddRefs
(
focusedElement
)
)
;
return
focusedElement
.
forget
(
)
;
}
return
nullptr
;
}
already_AddRefed
<
PresShell
>
PresShell
:
:
GetParentPresShellForEventHandling
(
)
{
if
(
!
mPresContext
)
{
return
nullptr
;
}
RefPtr
<
nsDocShell
>
docShell
=
mPresContext
-
>
GetDocShell
(
)
;
if
(
!
docShell
)
{
docShell
=
mForwardingContainer
.
get
(
)
;
}
if
(
!
docShell
)
{
return
nullptr
;
}
BrowsingContext
*
bc
=
docShell
-
>
GetBrowsingContext
(
)
;
if
(
!
bc
)
{
return
nullptr
;
}
RefPtr
<
BrowsingContext
>
parentBC
;
if
(
XRE_IsParentProcess
(
)
)
{
parentBC
=
bc
-
>
Canonical
(
)
-
>
GetParentCrossChromeBoundary
(
)
;
}
else
{
parentBC
=
bc
-
>
GetParent
(
)
;
}
RefPtr
<
nsIDocShell
>
parentDocShell
=
parentBC
?
parentBC
-
>
GetDocShell
(
)
:
nullptr
;
if
(
!
parentDocShell
)
{
return
nullptr
;
}
RefPtr
<
PresShell
>
parentPresShell
=
parentDocShell
-
>
GetPresShell
(
)
;
return
parentPresShell
.
forget
(
)
;
}
nsresult
PresShell
:
:
EventHandler
:
:
RetargetEventToParent
(
WidgetGUIEvent
*
aGUIEvent
nsEventStatus
*
aEventStatus
)
{
RefPtr
<
PresShell
>
parentPresShell
=
GetParentPresShellForEventHandling
(
)
;
NS_ENSURE_TRUE
(
parentPresShell
NS_ERROR_FAILURE
)
;
return
parentPresShell
-
>
HandleEvent
(
parentPresShell
-
>
GetRootFrame
(
)
aGUIEvent
true
aEventStatus
)
;
}
void
PresShell
:
:
DisableNonTestMouseEvents
(
bool
aDisable
)
{
sDisableNonTestMouseEvents
=
aDisable
;
}
bool
PresShell
:
:
MouseLocationWasSetBySynthesizedMouseEventForTests
(
)
const
{
if
(
!
mPresContext
)
{
return
false
;
}
if
(
mPresContext
-
>
IsRoot
(
)
)
{
return
mMouseLocationWasSetBySynthesizedMouseEventForTests
;
}
PresShell
*
rootPresShell
=
GetRootPresShell
(
)
;
return
rootPresShell
&
&
rootPresShell
-
>
mMouseLocationWasSetBySynthesizedMouseEventForTests
;
}
nsPoint
PresShell
:
:
GetEventLocation
(
const
WidgetMouseEvent
&
aEvent
)
const
{
nsIFrame
*
rootFrame
=
GetRootFrame
(
)
;
if
(
rootFrame
)
{
RelativeTo
relativeTo
{
rootFrame
}
;
if
(
rootFrame
-
>
PresContext
(
)
-
>
IsRootContentDocumentCrossProcess
(
)
)
{
relativeTo
.
mViewportType
=
ViewportType
:
:
Visual
;
}
return
nsLayoutUtils
:
:
GetEventCoordinatesRelativeTo
(
&
aEvent
relativeTo
)
;
}
nsView
*
rootView
=
mViewManager
-
>
GetRootView
(
)
;
return
nsLayoutUtils
:
:
TranslateWidgetToView
(
mPresContext
aEvent
.
mWidget
aEvent
.
mRefPoint
rootView
)
;
}
void
PresShell
:
:
RecordPointerLocation
(
WidgetGUIEvent
*
aEvent
)
{
if
(
!
mPresContext
)
{
return
;
}
if
(
!
mPresContext
-
>
IsRoot
(
)
)
{
PresShell
*
rootPresShell
=
GetRootPresShell
(
)
;
if
(
rootPresShell
)
{
rootPresShell
-
>
RecordPointerLocation
(
aEvent
)
;
}
return
;
}
if
(
(
aEvent
-
>
mMessage
=
=
eMouseMove
&
&
aEvent
-
>
AsMouseEvent
(
)
-
>
mReason
=
=
WidgetMouseEvent
:
:
eReal
)
|
|
aEvent
-
>
mMessage
=
=
eMouseEnterIntoWidget
|
|
aEvent
-
>
mMessage
=
=
eMouseDown
|
|
aEvent
-
>
mMessage
=
=
eMouseUp
)
{
mMouseLocation
=
GetEventLocation
(
*
aEvent
-
>
AsMouseEvent
(
)
)
;
mMouseEventTargetGuid
=
InputAPZContext
:
:
GetTargetLayerGuid
(
)
;
mMouseLocationWasSetBySynthesizedMouseEventForTests
=
aEvent
-
>
mFlags
.
mIsSynthesizedForTests
;
#
ifdef
DEBUG_MOUSE_LOCATION
if
(
aEvent
-
>
mMessage
=
=
eMouseEnterIntoWidget
)
{
printf
(
"
[
ps
=
%
p
]
got
mouse
enter
for
%
p
\
n
"
this
aEvent
-
>
mWidget
)
;
}
printf
(
"
[
ps
=
%
p
]
setting
mouse
location
to
(
%
d
%
d
)
\
n
"
this
mMouseLocation
.
x
mMouseLocation
.
y
)
;
#
endif
if
(
aEvent
-
>
mMessage
=
=
eMouseEnterIntoWidget
)
{
SynthesizeMouseMove
(
false
)
;
}
}
else
if
(
aEvent
-
>
mMessage
=
=
eMouseExitFromWidget
)
{
mMouseLocation
=
nsPoint
(
NS_UNCONSTRAINEDSIZE
NS_UNCONSTRAINEDSIZE
)
;
mMouseEventTargetGuid
=
InputAPZContext
:
:
GetTargetLayerGuid
(
)
;
mMouseLocationWasSetBySynthesizedMouseEventForTests
=
aEvent
-
>
mFlags
.
mIsSynthesizedForTests
;
#
ifdef
DEBUG_MOUSE_LOCATION
printf
(
"
[
ps
=
%
p
]
got
mouse
exit
for
%
p
\
n
"
this
aEvent
-
>
mWidget
)
;
printf
(
"
[
ps
=
%
p
]
clearing
mouse
location
\
n
"
this
)
;
#
endif
}
else
if
(
(
aEvent
-
>
mMessage
=
=
ePointerMove
&
&
aEvent
-
>
AsMouseEvent
(
)
-
>
mReason
=
=
WidgetMouseEvent
:
:
eReal
)
|
|
aEvent
-
>
mMessage
=
=
ePointerDown
|
|
aEvent
-
>
mMessage
=
=
ePointerUp
)
{
mLastOverWindowPointerLocation
=
GetEventLocation
(
*
aEvent
-
>
AsMouseEvent
(
)
)
;
}
}
void
PresShell
:
:
nsSynthMouseMoveEvent
:
:
Revoke
(
)
{
if
(
mPresShell
)
{
mPresShell
-
>
GetPresContext
(
)
-
>
RefreshDriver
(
)
-
>
RemoveRefreshObserver
(
this
FlushType
:
:
Display
)
;
mPresShell
=
nullptr
;
}
}
nsIFrame
*
PresShell
:
:
EventHandler
:
:
GetNearestFrameContainingPresShell
(
PresShell
*
aPresShell
)
{
nsViewManager
*
vm
=
aPresShell
-
>
GetViewManager
(
)
;
if
(
!
vm
)
{
return
nullptr
;
}
nsView
*
view
=
vm
-
>
GetRootView
(
)
;
while
(
view
&
&
!
view
-
>
GetFrame
(
)
)
{
view
=
view
-
>
GetParent
(
)
;
}
nsIFrame
*
frame
=
nullptr
;
if
(
view
)
{
frame
=
view
-
>
GetFrame
(
)
;
}
return
frame
;
}
static
CallState
FlushThrottledStyles
(
Document
&
aDocument
)
{
PresShell
*
presShell
=
aDocument
.
GetPresShell
(
)
;
if
(
presShell
&
&
presShell
-
>
IsVisible
(
)
)
{
if
(
nsPresContext
*
presContext
=
presShell
-
>
GetPresContext
(
)
)
{
presContext
-
>
RestyleManager
(
)
-
>
UpdateOnlyAnimationStyles
(
)
;
}
}
aDocument
.
EnumerateSubDocuments
(
FlushThrottledStyles
)
;
return
CallState
:
:
Continue
;
}
bool
PresShell
:
:
CanDispatchEvent
(
const
WidgetGUIEvent
*
aEvent
)
const
{
bool
rv
=
mPresContext
&
&
!
mHaveShutDown
&
&
nsContentUtils
:
:
IsSafeToRunScript
(
)
;
if
(
aEvent
)
{
rv
&
=
(
aEvent
&
&
aEvent
-
>
mWidget
&
&
!
aEvent
-
>
mWidget
-
>
Destroyed
(
)
)
;
}
return
rv
;
}
PresShell
*
PresShell
:
:
GetShellForEventTarget
(
nsIFrame
*
aFrame
nsIContent
*
aContent
)
{
if
(
aFrame
)
{
return
aFrame
-
>
PresShell
(
)
;
}
if
(
aContent
)
{
Document
*
doc
=
aContent
-
>
GetComposedDoc
(
)
;
if
(
!
doc
)
{
return
nullptr
;
}
return
doc
-
>
GetPresShell
(
)
;
}
return
nullptr
;
}
PresShell
*
PresShell
:
:
GetShellForTouchEvent
(
WidgetGUIEvent
*
aEvent
)
{
switch
(
aEvent
-
>
mMessage
)
{
case
eTouchMove
:
case
eTouchCancel
:
case
eTouchEnd
:
{
WidgetTouchEvent
*
touchEvent
=
aEvent
-
>
AsTouchEvent
(
)
;
for
(
dom
:
:
Touch
*
touch
:
touchEvent
-
>
mTouches
)
{
if
(
!
touch
)
{
return
nullptr
;
}
RefPtr
<
dom
:
:
Touch
>
oldTouch
=
TouchManager
:
:
GetCapturedTouch
(
touch
-
>
Identifier
(
)
)
;
if
(
!
oldTouch
)
{
return
nullptr
;
}
nsIContent
*
const
content
=
nsIContent
:
:
FromEventTargetOrNull
(
oldTouch
-
>
GetTarget
(
)
)
;
if
(
!
content
)
{
return
nullptr
;
}
if
(
PresShell
*
const
presShell
=
content
-
>
OwnerDoc
(
)
-
>
GetPresShell
(
)
)
{
return
presShell
;
}
}
return
nullptr
;
}
default
:
return
nullptr
;
}
}
nsresult
PresShell
:
:
HandleEvent
(
nsIFrame
*
aFrameForPresShell
WidgetGUIEvent
*
aGUIEvent
bool
aDontRetargetEvents
nsEventStatus
*
aEventStatus
)
{
MOZ_ASSERT
(
aGUIEvent
)
;
if
(
aGUIEvent
-
>
CameFromAnotherProcess
(
)
&
&
XRE_IsContentProcess
(
)
&
&
!
aGUIEvent
-
>
mFlags
.
mIsSynthesizedForTests
&
&
MouseLocationWasSetBySynthesizedMouseEventForTests
(
)
)
{
switch
(
aGUIEvent
-
>
mMessage
)
{
case
eMouseMove
:
case
eMouseExitFromWidget
:
case
eMouseEnterIntoWidget
:
if
(
!
aGUIEvent
-
>
AsMouseEvent
(
)
-
>
IsReal
(
)
)
{
return
NS_OK
;
}
break
;
default
:
break
;
}
}
if
(
!
CanHandleUserInputEvents
(
aGUIEvent
)
)
{
return
NS_OK
;
}
if
(
mPresContext
)
{
switch
(
aGUIEvent
-
>
mMessage
)
{
case
eMouseMove
:
if
(
!
aGUIEvent
-
>
AsMouseEvent
(
)
-
>
IsReal
(
)
)
{
break
;
}
[
[
fallthrough
]
]
;
case
eMouseDown
:
case
eMouseUp
:
{
RefPtr
<
PresShell
>
rootPresShell
=
mPresContext
-
>
IsRoot
(
)
?
this
:
GetRootPresShell
(
)
;
if
(
rootPresShell
&
&
rootPresShell
-
>
mSynthMouseMoveEvent
.
IsPending
(
)
)
{
AutoWeakFrame
frameForPresShellWeak
(
aFrameForPresShell
)
;
RefPtr
<
nsSynthMouseMoveEvent
>
synthMouseMoveEvent
=
rootPresShell
-
>
mSynthMouseMoveEvent
.
get
(
)
;
synthMouseMoveEvent
-
>
Run
(
)
;
if
(
IsDestroying
(
)
)
{
return
NS_OK
;
}
if
(
MOZ_UNLIKELY
(
!
frameForPresShellWeak
.
IsAlive
(
)
)
)
{
return
NS_OK
;
}
}
break
;
}
default
:
break
;
}
}
EventHandler
eventHandler
(
*
this
)
;
return
eventHandler
.
HandleEvent
(
aFrameForPresShell
aGUIEvent
aDontRetargetEvents
aEventStatus
)
;
}
nsresult
PresShell
:
:
EventHandler
:
:
HandleEvent
(
nsIFrame
*
aFrameForPresShell
WidgetGUIEvent
*
aGUIEvent
bool
aDontRetargetEvents
nsEventStatus
*
aEventStatus
)
{
MOZ_ASSERT
(
aGUIEvent
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aGUIEvent
-
>
IsTrusted
(
)
)
;
MOZ_ASSERT
(
aEventStatus
)
;
NS_ASSERTION
(
aFrameForPresShell
"
aFrameForPresShell
should
be
not
null
"
)
;
if
(
mPresShell
-
>
mAPZFocusSequenceNumber
<
aGUIEvent
-
>
mFocusSequenceNumber
)
{
mPresShell
-
>
mAPZFocusSequenceNumber
=
aGUIEvent
-
>
mFocusSequenceNumber
;
}
if
(
mPresShell
-
>
IsDestroying
(
)
|
|
(
PresShell
:
:
sDisableNonTestMouseEvents
&
&
!
aGUIEvent
-
>
mFlags
.
mIsSynthesizedForTests
&
&
aGUIEvent
-
>
HasMouseEventMessage
(
)
)
)
{
return
NS_OK
;
}
mPresShell
-
>
RecordPointerLocation
(
aGUIEvent
)
;
if
(
MaybeHandleEventWithAccessibleCaret
(
aFrameForPresShell
aGUIEvent
aEventStatus
)
)
{
return
NS_OK
;
}
if
(
MaybeDiscardEvent
(
aGUIEvent
)
)
{
return
NS_OK
;
}
if
(
!
aDontRetargetEvents
)
{
nsresult
rv
=
NS_OK
;
if
(
MaybeHandleEventWithAnotherPresShell
(
aFrameForPresShell
aGUIEvent
aEventStatus
&
rv
)
)
{
return
rv
;
}
}
if
(
MaybeDiscardOrDelayKeyboardEvent
(
aGUIEvent
)
)
{
return
NS_OK
;
}
if
(
aGUIEvent
-
>
IsUsingCoordinates
(
)
)
{
return
HandleEventUsingCoordinates
(
aFrameForPresShell
aGUIEvent
aEventStatus
aDontRetargetEvents
)
;
}
if
(
!
aFrameForPresShell
)
{
if
(
!
NS_EVENT_NEEDS_FRAME
(
aGUIEvent
)
)
{
AutoCurrentEventInfoSetter
eventInfoSetter
(
*
this
)
;
return
HandleEventWithCurrentEventInfo
(
aGUIEvent
aEventStatus
true
nullptr
)
;
}
if
(
aGUIEvent
-
>
HasKeyEventMessage
(
)
)
{
return
RetargetEventToParent
(
aGUIEvent
aEventStatus
)
;
}
return
NS_OK
;
}
if
(
aGUIEvent
-
>
IsTargetedAtFocusedContent
(
)
)
{
return
HandleEventAtFocusedContent
(
aGUIEvent
aEventStatus
)
;
}
return
HandleEventWithFrameForPresShell
(
aFrameForPresShell
aGUIEvent
aEventStatus
)
;
}
nsresult
PresShell
:
:
EventHandler
:
:
HandleEventUsingCoordinates
(
nsIFrame
*
aFrameForPresShell
WidgetGUIEvent
*
aGUIEvent
nsEventStatus
*
aEventStatus
bool
aDontRetargetEvents
)
{
MOZ_ASSERT
(
aGUIEvent
)
;
MOZ_ASSERT
(
aGUIEvent
-
>
IsUsingCoordinates
(
)
)
;
MOZ_ASSERT
(
aEventStatus
)
;
AutoWeakFrame
weakFrame
(
aFrameForPresShell
)
;
MaybeFlushPendingNotifications
(
aGUIEvent
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
*
aEventStatus
=
nsEventStatus_eIgnore
;
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
capturingContent
=
EventHandler
:
:
GetCapturingContentFor
(
aGUIEvent
)
;
if
(
GetDocument
(
)
&
&
aGUIEvent
-
>
mClass
=
=
eTouchEventClass
)
{
PointerLockManager
:
:
Unlock
(
)
;
}
nsIFrame
*
frameForPresShell
=
MaybeFlushThrottledStyles
(
aFrameForPresShell
)
;
if
(
NS_WARN_IF
(
!
frameForPresShell
)
)
{
return
NS_OK
;
}
bool
isCapturingContentIgnored
=
false
;
bool
isCaptureRetargeted
=
false
;
nsIFrame
*
rootFrameToHandleEvent
=
ComputeRootFrameToHandleEvent
(
frameForPresShell
aGUIEvent
capturingContent
&
isCapturingContentIgnored
&
isCaptureRetargeted
)
;
if
(
isCapturingContentIgnored
)
{
capturingContent
=
nullptr
;
}
{
AutoWeakFrame
frameKeeper
(
rootFrameToHandleEvent
)
;
PointerEventHandler
:
:
MaybeProcessPointerCapture
(
aGUIEvent
)
;
if
(
!
frameKeeper
.
IsAlive
(
)
)
{
NS_WARNING
(
"
Nothing
to
handle
this
event
!
"
)
;
return
NS_OK
;
}
}
RefPtr
<
Element
>
pointerCapturingElement
=
PointerEventHandler
:
:
GetPointerCapturingElement
(
aGUIEvent
)
;
if
(
pointerCapturingElement
)
{
rootFrameToHandleEvent
=
pointerCapturingElement
-
>
GetPrimaryFrame
(
)
;
if
(
!
rootFrameToHandleEvent
)
{
return
HandleEventWithPointerCapturingContentWithoutItsFrame
(
aFrameForPresShell
aGUIEvent
pointerCapturingElement
aEventStatus
)
;
}
}
WidgetMouseEvent
*
mouseEvent
=
aGUIEvent
-
>
AsMouseEvent
(
)
;
bool
isWindowLevelMouseExit
=
(
aGUIEvent
-
>
mMessage
=
=
eMouseExitFromWidget
)
&
&
(
mouseEvent
&
&
(
mouseEvent
-
>
mExitFrom
.
value
(
)
=
=
WidgetMouseEvent
:
:
ePlatformTopLevel
|
|
mouseEvent
-
>
mExitFrom
.
value
(
)
=
=
WidgetMouseEvent
:
:
ePuppet
)
)
;
EventTargetData
eventTargetData
(
rootFrameToHandleEvent
)
;
if
(
!
isCaptureRetargeted
&
&
!
isWindowLevelMouseExit
&
&
!
pointerCapturingElement
)
{
if
(
!
ComputeEventTargetFrameAndPresShellAtEventPoint
(
rootFrameToHandleEvent
aGUIEvent
&
eventTargetData
)
)
{
*
aEventStatus
=
nsEventStatus_eIgnore
;
return
NS_OK
;
}
}
if
(
capturingContent
&
&
!
pointerCapturingElement
&
&
(
PresShell
:
:
sCapturingContentInfo
.
mRetargetToElement
|
|
!
eventTargetData
.
GetFrameContent
(
)
|
|
!
nsContentUtils
:
:
ContentIsCrossDocDescendantOf
(
eventTargetData
.
GetFrameContent
(
)
capturingContent
)
)
)
{
NS_ASSERTION
(
capturingContent
-
>
OwnerDoc
(
)
=
=
GetDocument
(
)
"
Unexpected
document
"
)
;
nsIFrame
*
capturingFrame
=
capturingContent
-
>
GetPrimaryFrame
(
)
;
if
(
capturingFrame
)
{
eventTargetData
.
SetFrameAndComputePresShell
(
capturingFrame
)
;
}
}
if
(
NS_WARN_IF
(
!
eventTargetData
.
GetFrame
(
)
)
)
{
return
NS_OK
;
}
if
(
MaybeDiscardOrDelayMouseEvent
(
eventTargetData
.
GetFrame
(
)
aGUIEvent
)
)
{
return
NS_OK
;
}
if
(
eventTargetData
.
MaybeRetargetToActiveDocument
(
aGUIEvent
)
&
&
NS_WARN_IF
(
!
eventTargetData
.
GetFrame
(
)
)
)
{
return
NS_OK
;
}
eventTargetData
.
UpdateWheelEventTarget
(
aGUIEvent
)
;
if
(
!
eventTargetData
.
ComputeElementFromFrame
(
aGUIEvent
)
)
{
return
NS_OK
;
}
if
(
!
DispatchPrecedingPointerEvent
(
aFrameForPresShell
aGUIEvent
pointerCapturingElement
aDontRetargetEvents
&
eventTargetData
aEventStatus
)
)
{
return
NS_OK
;
}
EventHandler
eventHandler
(
*
eventTargetData
.
mPresShell
)
;
AutoCurrentEventInfoSetter
eventInfoSetter
(
eventHandler
eventTargetData
)
;
nsresult
rv
=
eventHandler
.
HandleEventWithCurrentEventInfo
(
aGUIEvent
aEventStatus
true
MOZ_KnownLive
(
eventTargetData
.
mOverrideClickTarget
)
)
;
if
(
NS_FAILED
(
rv
)
|
|
MOZ_UNLIKELY
(
eventTargetData
.
mPresShell
-
>
IsDestroying
(
)
)
)
{
return
rv
;
}
if
(
aGUIEvent
-
>
mMessage
=
=
eTouchEnd
)
{
MaybeSynthesizeCompatMouseEventsForTouchEnd
(
aGUIEvent
-
>
AsTouchEvent
(
)
aEventStatus
)
;
}
return
NS_OK
;
}
bool
PresShell
:
:
EventHandler
:
:
MaybeFlushPendingNotifications
(
WidgetGUIEvent
*
aGUIEvent
)
{
MOZ_ASSERT
(
aGUIEvent
)
;
switch
(
aGUIEvent
-
>
mMessage
)
{
case
eMouseDown
:
case
eMouseUp
:
{
RefPtr
<
nsPresContext
>
presContext
=
mPresShell
-
>
GetPresContext
(
)
;
if
(
NS_WARN_IF
(
!
presContext
)
)
{
return
false
;
}
uint64_t
framesConstructedCount
=
presContext
-
>
FramesConstructedCount
(
)
;
uint64_t
framesReflowedCount
=
presContext
-
>
FramesReflowedCount
(
)
;
MOZ_KnownLive
(
mPresShell
)
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
return
framesConstructedCount
!
=
presContext
-
>
FramesConstructedCount
(
)
|
|
framesReflowedCount
!
=
presContext
-
>
FramesReflowedCount
(
)
;
}
default
:
return
false
;
}
}
static
ViewportType
ViewportTypeForInputEventsRelativeToRoot
(
)
{
#
ifdef
MOZ_WIDGET_ANDROID
return
ViewportType
:
:
Layout
;
#
else
return
ViewportType
:
:
Visual
;
#
endif
}
nsIFrame
*
PresShell
:
:
EventHandler
:
:
GetFrameToHandleNonTouchEvent
(
nsIFrame
*
aRootFrameToHandleEvent
WidgetGUIEvent
*
aGUIEvent
)
{
MOZ_ASSERT
(
aGUIEvent
)
;
MOZ_ASSERT
(
aGUIEvent
-
>
mClass
!
=
eTouchEventClass
)
;
ViewportType
viewportType
=
ViewportType
:
:
Layout
;
if
(
aRootFrameToHandleEvent
-
>
Type
(
)
=
=
LayoutFrameType
:
:
Viewport
)
{
nsPresContext
*
pc
=
aRootFrameToHandleEvent
-
>
PresContext
(
)
;
if
(
pc
-
>
IsChrome
(
)
)
{
viewportType
=
ViewportType
:
:
Visual
;
}
else
if
(
pc
-
>
IsRootContentDocumentCrossProcess
(
)
)
{
viewportType
=
ViewportTypeForInputEventsRelativeToRoot
(
)
;
}
}
RelativeTo
relativeTo
{
aRootFrameToHandleEvent
viewportType
}
;
nsPoint
eventPoint
=
nsLayoutUtils
:
:
GetEventCoordinatesRelativeTo
(
aGUIEvent
relativeTo
)
;
uint32_t
flags
=
0
;
if
(
aGUIEvent
-
>
mClass
=
=
eMouseEventClass
)
{
WidgetMouseEvent
*
mouseEvent
=
aGUIEvent
-
>
AsMouseEvent
(
)
;
if
(
mouseEvent
&
&
mouseEvent
-
>
mIgnoreRootScrollFrame
)
{
flags
|
=
INPUT_IGNORE_ROOT_SCROLL_FRAME
;
}
}
nsIFrame
*
targetFrame
=
FindFrameTargetedByInputEvent
(
aGUIEvent
relativeTo
eventPoint
flags
)
;
if
(
!
targetFrame
)
{
return
aRootFrameToHandleEvent
;
}
if
(
targetFrame
-
>
PresShell
(
)
=
=
mPresShell
)
{
return
targetFrame
;
}
PresShell
*
childPresShell
=
targetFrame
-
>
PresShell
(
)
;
EventHandler
childEventHandler
(
*
childPresShell
)
;
AutoWeakFrame
weakFrame
(
aRootFrameToHandleEvent
)
;
bool
layoutChanged
=
childEventHandler
.
MaybeFlushPendingNotifications
(
aGUIEvent
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
nullptr
;
}
if
(
!
layoutChanged
)
{
return
targetFrame
;
}
targetFrame
=
FindFrameTargetedByInputEvent
(
aGUIEvent
relativeTo
eventPoint
flags
)
;
return
targetFrame
?
targetFrame
:
aRootFrameToHandleEvent
;
}
bool
PresShell
:
:
EventHandler
:
:
ComputeEventTargetFrameAndPresShellAtEventPoint
(
nsIFrame
*
aRootFrameToHandleEvent
WidgetGUIEvent
*
aGUIEvent
EventTargetData
*
aEventTargetData
)
{
MOZ_ASSERT
(
aRootFrameToHandleEvent
)
;
MOZ_ASSERT
(
aGUIEvent
)
;
MOZ_ASSERT
(
aEventTargetData
)
;
if
(
aGUIEvent
-
>
mClass
=
=
eTouchEventClass
)
{
nsIFrame
*
targetFrameAtTouchEvent
=
TouchManager
:
:
SetupTarget
(
aGUIEvent
-
>
AsTouchEvent
(
)
aRootFrameToHandleEvent
)
;
aEventTargetData
-
>
SetFrameAndComputePresShell
(
targetFrameAtTouchEvent
)
;
return
true
;
}
nsIFrame
*
targetFrame
=
GetFrameToHandleNonTouchEvent
(
aRootFrameToHandleEvent
aGUIEvent
)
;
aEventTargetData
-
>
SetFrameAndComputePresShell
(
targetFrame
)
;
return
!
!
aEventTargetData
-
>
GetFrame
(
)
;
}
bool
PresShell
:
:
EventHandler
:
:
DispatchPrecedingPointerEvent
(
nsIFrame
*
aFrameForPresShell
WidgetGUIEvent
*
aGUIEvent
nsIContent
*
aPointerCapturingContent
bool
aDontRetargetEvents
EventTargetData
*
aEventTargetData
nsEventStatus
*
aEventStatus
)
{
MOZ_ASSERT
(
aFrameForPresShell
)
;
MOZ_ASSERT
(
aGUIEvent
)
;
MOZ_ASSERT
(
aEventTargetData
)
;
MOZ_ASSERT
(
aEventStatus
)
;
nsIFrame
*
targetFrame
=
aGUIEvent
-
>
mClass
=
=
eTouchEventClass
?
aFrameForPresShell
:
aEventTargetData
-
>
GetFrame
(
)
;
if
(
aPointerCapturingContent
)
{
aEventTargetData
-
>
mOverrideClickTarget
=
GetOverrideClickTarget
(
aGUIEvent
aFrameForPresShell
)
;
aEventTargetData
-
>
mPresShell
=
PresShell
:
:
GetShellForEventTarget
(
nullptr
aPointerCapturingContent
)
;
if
(
!
aEventTargetData
-
>
mPresShell
)
{
PointerEventHandler
:
:
ReleaseIfCaptureByDescendant
(
aPointerCapturingContent
)
;
return
false
;
}
targetFrame
=
aPointerCapturingContent
-
>
GetPrimaryFrame
(
)
;
aEventTargetData
-
>
SetFrameAndContent
(
targetFrame
aPointerCapturingContent
)
;
}
AutoWeakFrame
weakTargetFrame
(
targetFrame
)
;
AutoWeakFrame
weakFrame
(
aEventTargetData
-
>
GetFrame
(
)
)
;
nsCOMPtr
<
nsIContent
>
pointerEventTargetContent
(
aEventTargetData
-
>
GetContent
(
)
)
;
RefPtr
<
PresShell
>
presShell
(
aEventTargetData
-
>
mPresShell
)
;
nsCOMPtr
<
nsIContent
>
mouseOrTouchEventTargetContent
;
PointerEventHandler
:
:
DispatchPointerFromMouseOrTouch
(
presShell
aEventTargetData
-
>
GetFrame
(
)
pointerEventTargetContent
aGUIEvent
aDontRetargetEvents
aEventStatus
getter_AddRefs
(
mouseOrTouchEventTargetContent
)
)
;
if
(
weakTargetFrame
.
IsAlive
(
)
&
&
weakFrame
.
IsAlive
(
)
)
{
aEventTargetData
-
>
UpdateTouchEventTarget
(
aGUIEvent
)
;
return
true
;
}
presShell
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
if
(
MOZ_UNLIKELY
(
mPresShell
-
>
IsDestroying
(
)
)
)
{
return
false
;
}
if
(
!
mouseOrTouchEventTargetContent
)
{
MOZ_ASSERT
(
aGUIEvent
-
>
mClass
=
=
eMouseEventClass
)
;
return
false
;
}
aEventTargetData
-
>
SetFrameAndContent
(
mouseOrTouchEventTargetContent
-
>
GetPrimaryFrame
(
)
mouseOrTouchEventTargetContent
)
;
aEventTargetData
-
>
mPresShell
=
mouseOrTouchEventTargetContent
-
>
IsInComposedDoc
(
)
?
PresShell
:
:
GetShellForEventTarget
(
aEventTargetData
-
>
GetFrame
(
)
aEventTargetData
-
>
GetContent
(
)
)
:
mouseOrTouchEventTargetContent
-
>
OwnerDoc
(
)
-
>
GetPresShell
(
)
;
if
(
!
aEventTargetData
-
>
mPresShell
)
{
return
false
;
}
aEventTargetData
-
>
UpdateTouchEventTarget
(
aGUIEvent
)
;
return
true
;
}
class
AutoEventTargetPointResetter
{
public
:
explicit
AutoEventTargetPointResetter
(
WidgetGUIEvent
*
aGUIEvent
)
:
mGUIEvent
(
aGUIEvent
)
mRefPoint
(
aGUIEvent
-
>
mRefPoint
)
mHandledByAccessibleCaret
(
false
)
{
}
void
SetHandledByAccessibleCaret
(
)
{
mHandledByAccessibleCaret
=
true
;
}
~
AutoEventTargetPointResetter
(
)
{
if
(
!
mHandledByAccessibleCaret
)
{
mGUIEvent
-
>
mRefPoint
=
mRefPoint
;
}
}
private
:
WidgetGUIEvent
*
mGUIEvent
;
LayoutDeviceIntPoint
mRefPoint
;
bool
mHandledByAccessibleCaret
;
}
;
bool
PresShell
:
:
EventHandler
:
:
MaybeHandleEventWithAccessibleCaret
(
nsIFrame
*
aFrameForPresShell
WidgetGUIEvent
*
aGUIEvent
nsEventStatus
*
aEventStatus
)
{
MOZ_ASSERT
(
aGUIEvent
)
;
MOZ_ASSERT
(
aEventStatus
)
;
if
(
*
aEventStatus
=
=
nsEventStatus_eConsumeNoDefault
)
{
return
false
;
}
if
(
!
AccessibleCaretEnabled
(
GetDocument
(
)
-
>
GetDocShell
(
)
)
)
{
return
false
;
}
if
(
aGUIEvent
-
>
mClass
!
=
eMouseEventClass
&
&
aGUIEvent
-
>
mClass
!
=
eTouchEventClass
&
&
aGUIEvent
-
>
mClass
!
=
eKeyboardEventClass
)
{
return
false
;
}
AutoEventTargetPointResetter
autoEventTargetPointResetter
(
aGUIEvent
)
;
do
{
EventTargetData
eventTargetData
(
nullptr
)
;
if
(
!
ComputeEventTargetFrameAndPresShellAtEventPoint
(
aFrameForPresShell
aGUIEvent
&
eventTargetData
)
)
{
break
;
}
if
(
!
eventTargetData
.
mPresShell
)
{
break
;
}
RefPtr
<
AccessibleCaretEventHub
>
eventHub
=
eventTargetData
.
mPresShell
-
>
GetAccessibleCaretEventHub
(
)
;
if
(
!
eventHub
)
{
break
;
}
*
aEventStatus
=
eventHub
-
>
HandleEvent
(
aGUIEvent
)
;
if
(
*
aEventStatus
!
=
nsEventStatus_eConsumeNoDefault
)
{
break
;
}
aGUIEvent
-
>
mFlags
.
mMultipleActionsPrevented
=
true
;
autoEventTargetPointResetter
.
SetHandledByAccessibleCaret
(
)
;
return
true
;
}
while
(
false
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
GetFocusedDOMWindowInOurWindow
(
)
;
if
(
!
window
)
{
return
false
;
}
RefPtr
<
Document
>
retargetEventDoc
=
window
-
>
GetExtantDoc
(
)
;
if
(
!
retargetEventDoc
)
{
return
false
;
}
RefPtr
<
PresShell
>
presShell
=
retargetEventDoc
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
false
;
}
RefPtr
<
AccessibleCaretEventHub
>
eventHub
=
presShell
-
>
GetAccessibleCaretEventHub
(
)
;
if
(
!
eventHub
)
{
return
false
;
}
*
aEventStatus
=
eventHub
-
>
HandleEvent
(
aGUIEvent
)
;
if
(
*
aEventStatus
!
=
nsEventStatus_eConsumeNoDefault
)
{
return
false
;
}
aGUIEvent
-
>
mFlags
.
mMultipleActionsPrevented
=
true
;
autoEventTargetPointResetter
.
SetHandledByAccessibleCaret
(
)
;
return
true
;
}
void
PresShell
:
:
EventHandler
:
:
MaybeSynthesizeCompatMouseEventsForTouchEnd
(
const
WidgetTouchEvent
*
aTouchEndEvent
const
nsEventStatus
*
aStatus
)
const
{
MOZ_ASSERT
(
aTouchEndEvent
-
>
mMessage
=
=
eTouchEnd
)
;
if
(
!
aTouchEndEvent
-
>
mFlags
.
mIsSynthesizedForTests
|
|
StaticPrefs
:
:
test_events_async_enabled
(
)
)
{
return
;
}
if
(
*
aStatus
=
=
nsEventStatus_eConsumeNoDefault
|
|
!
TouchManager
:
:
IsSingleTapEndToDoDefault
(
aTouchEndEvent
)
)
{
return
;
}
if
(
NS_WARN_IF
(
!
aTouchEndEvent
-
>
mWidget
)
)
{
return
;
}
nsCOMPtr
<
nsIWidget
>
widget
=
aTouchEndEvent
-
>
mWidget
;
RefPtr
<
PresShell
>
presShell
=
mPresShell
;
for
(
const
EventMessage
message
:
{
eMouseMove
eMouseDown
eMouseUp
}
)
{
if
(
MOZ_UNLIKELY
(
presShell
-
>
IsDestroying
(
)
)
)
{
break
;
}
nsIFrame
*
frameForPresShell
=
GetNearestFrameContainingPresShell
(
presShell
)
;
if
(
!
frameForPresShell
)
{
break
;
}
WidgetMouseEvent
event
(
true
message
widget
WidgetMouseEvent
:
:
eReal
WidgetMouseEvent
:
:
eNormal
)
;
event
.
mRefPoint
=
aTouchEndEvent
-
>
mTouches
[
0
]
-
>
mRefPoint
;
event
.
mButton
=
MouseButton
:
:
ePrimary
;
event
.
mButtons
=
message
=
=
eMouseDown
?
MouseButtonsFlag
:
:
ePrimaryFlag
:
MouseButtonsFlag
:
:
eNoButtons
;
event
.
mInputSource
=
MouseEvent_Binding
:
:
MOZ_SOURCE_TOUCH
;
event
.
mClickCount
=
message
=
=
eMouseMove
?
0
:
1
;
event
.
mModifiers
=
aTouchEndEvent
-
>
mModifiers
;
event
.
convertToPointer
=
false
;
nsEventStatus
mouseEventStatus
=
nsEventStatus_eIgnore
;
presShell
-
>
HandleEvent
(
frameForPresShell
&
event
false
&
mouseEventStatus
)
;
}
}
bool
PresShell
:
:
EventHandler
:
:
MaybeDiscardEvent
(
WidgetGUIEvent
*
aGUIEvent
)
{
MOZ_ASSERT
(
aGUIEvent
)
;
if
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
{
return
false
;
}
if
(
!
aGUIEvent
-
>
IsAllowedToDispatchDOMEvent
(
)
)
{
return
false
;
}
if
(
aGUIEvent
-
>
mClass
=
=
eCompositionEventClass
)
{
IMEStateManager
:
:
OnCompositionEventDiscarded
(
aGUIEvent
-
>
AsCompositionEvent
(
)
)
;
}
#
ifdef
DEBUG
if
(
aGUIEvent
-
>
IsIMERelatedEvent
(
)
)
{
nsPrintfCString
warning
(
"
%
s
event
is
discarded
"
ToChar
(
aGUIEvent
-
>
mMessage
)
)
;
NS_WARNING
(
warning
.
get
(
)
)
;
}
#
endif
nsContentUtils
:
:
WarnScriptWasIgnored
(
GetDocument
(
)
)
;
return
true
;
}
nsIContent
*
PresShell
:
:
EventHandler
:
:
GetCapturingContentFor
(
WidgetGUIEvent
*
aGUIEvent
)
{
return
(
aGUIEvent
-
>
mClass
=
=
ePointerEventClass
|
|
aGUIEvent
-
>
mClass
=
=
eWheelEventClass
|
|
aGUIEvent
-
>
HasMouseEventMessage
(
)
)
?
PresShell
:
:
GetCapturingContent
(
)
:
nullptr
;
}
bool
PresShell
:
:
EventHandler
:
:
GetRetargetEventDocument
(
WidgetGUIEvent
*
aGUIEvent
Document
*
*
aRetargetEventDocument
)
{
MOZ_ASSERT
(
aGUIEvent
)
;
MOZ_ASSERT
(
aRetargetEventDocument
)
;
*
aRetargetEventDocument
=
nullptr
;
if
(
aGUIEvent
-
>
IsTargetedAtFocusedWindow
(
)
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
GetFocusedDOMWindowInOurWindow
(
)
;
if
(
!
window
)
{
return
false
;
}
RefPtr
<
Document
>
retargetEventDoc
=
window
-
>
GetExtantDoc
(
)
;
if
(
!
retargetEventDoc
)
{
return
false
;
}
retargetEventDoc
.
forget
(
aRetargetEventDocument
)
;
return
true
;
}
nsIContent
*
capturingContent
=
EventHandler
:
:
GetCapturingContentFor
(
aGUIEvent
)
;
if
(
capturingContent
)
{
RefPtr
<
Document
>
retargetEventDoc
=
capturingContent
-
>
GetComposedDoc
(
)
;
retargetEventDoc
.
forget
(
aRetargetEventDocument
)
;
return
true
;
}
#
ifdef
ANDROID
if
(
aGUIEvent
-
>
mClass
=
=
eTouchEventClass
|
|
aGUIEvent
-
>
mClass
=
=
eMouseEventClass
|
|
aGUIEvent
-
>
mClass
=
=
eWheelEventClass
)
{
RefPtr
<
Document
>
retargetEventDoc
=
mPresShell
-
>
GetPrimaryContentDocument
(
)
;
retargetEventDoc
.
forget
(
aRetargetEventDocument
)
;
return
true
;
}
#
endif
return
true
;
}
nsIFrame
*
PresShell
:
:
EventHandler
:
:
GetFrameForHandlingEventWith
(
WidgetGUIEvent
*
aGUIEvent
Document
*
aRetargetDocument
nsIFrame
*
aFrameForPresShell
)
{
MOZ_ASSERT
(
aGUIEvent
)
;
MOZ_ASSERT
(
aRetargetDocument
)
;
RefPtr
<
PresShell
>
retargetPresShell
=
aRetargetDocument
-
>
GetPresShell
(
)
;
if
(
!
retargetPresShell
)
{
if
(
!
aGUIEvent
-
>
HasKeyEventMessage
(
)
)
{
return
nullptr
;
}
Document
*
retargetEventDoc
=
aRetargetDocument
;
while
(
!
retargetPresShell
)
{
retargetEventDoc
=
retargetEventDoc
-
>
GetInProcessParentDocument
(
)
;
if
(
!
retargetEventDoc
)
{
return
nullptr
;
}
retargetPresShell
=
retargetEventDoc
-
>
GetPresShell
(
)
;
}
}
if
(
retargetPresShell
=
=
mPresShell
)
{
return
aFrameForPresShell
;
}
nsIFrame
*
rootFrame
=
retargetPresShell
-
>
GetRootFrame
(
)
;
if
(
rootFrame
)
{
return
rootFrame
;
}
if
(
aGUIEvent
-
>
mMessage
=
=
eQueryTextContent
|
|
aGUIEvent
-
>
IsContentCommandEvent
(
)
)
{
return
nullptr
;
}
return
GetNearestFrameContainingPresShell
(
retargetPresShell
)
;
}
bool
PresShell
:
:
EventHandler
:
:
MaybeHandleEventWithAnotherPresShell
(
nsIFrame
*
aFrameForPresShell
WidgetGUIEvent
*
aGUIEvent
nsEventStatus
*
aEventStatus
nsresult
*
aRv
)
{
MOZ_ASSERT
(
aGUIEvent
)
;
MOZ_ASSERT
(
aEventStatus
)
;
MOZ_ASSERT
(
aRv
)
;
*
aRv
=
NS_OK
;
RefPtr
<
Document
>
retargetEventDoc
;
if
(
!
GetRetargetEventDocument
(
aGUIEvent
getter_AddRefs
(
retargetEventDoc
)
)
)
{
return
true
;
}
if
(
!
retargetEventDoc
)
{
return
false
;
}
nsIFrame
*
frame
=
GetFrameForHandlingEventWith
(
aGUIEvent
retargetEventDoc
aFrameForPresShell
)
;
if
(
!
frame
)
{
return
true
;
}
if
(
frame
=
=
aFrameForPresShell
)
{
return
false
;
}
RefPtr
<
PresShell
>
presShell
=
frame
-
>
PresContext
(
)
-
>
PresShell
(
)
;
*
aRv
=
presShell
-
>
HandleEvent
(
frame
aGUIEvent
true
aEventStatus
)
;
return
true
;
}
bool
PresShell
:
:
EventHandler
:
:
MaybeDiscardOrDelayKeyboardEvent
(
WidgetGUIEvent
*
aGUIEvent
)
{
MOZ_ASSERT
(
aGUIEvent
)
;
if
(
aGUIEvent
-
>
mClass
!
=
eKeyboardEventClass
)
{
return
false
;
}
Document
*
document
=
GetDocument
(
)
;
if
(
!
document
|
|
!
document
-
>
EventHandlingSuppressed
(
)
)
{
return
false
;
}
MOZ_ASSERT_IF
(
InputTaskManager
:
:
CanSuspendInputEvent
(
)
!
InputTaskManager
:
:
Get
(
)
-
>
IsSuspended
(
)
)
;
if
(
aGUIEvent
-
>
mMessage
=
=
eKeyDown
)
{
mPresShell
-
>
mNoDelayedKeyEvents
=
true
;
}
else
if
(
!
mPresShell
-
>
mNoDelayedKeyEvents
)
{
UniquePtr
<
DelayedKeyEvent
>
delayedKeyEvent
=
MakeUnique
<
DelayedKeyEvent
>
(
aGUIEvent
-
>
AsKeyboardEvent
(
)
)
;
mPresShell
-
>
mDelayedEvents
.
AppendElement
(
std
:
:
move
(
delayedKeyEvent
)
)
;
}
aGUIEvent
-
>
mFlags
.
mIsSuppressedOrDelayed
=
true
;
return
true
;
}
bool
PresShell
:
:
EventHandler
:
:
MaybeDiscardOrDelayMouseEvent
(
nsIFrame
*
aFrameToHandleEvent
WidgetGUIEvent
*
aGUIEvent
)
{
MOZ_ASSERT
(
aFrameToHandleEvent
)
;
MOZ_ASSERT
(
aGUIEvent
)
;
if
(
aGUIEvent
-
>
mClass
!
=
eMouseEventClass
)
{
return
false
;
}
if
(
!
aFrameToHandleEvent
-
>
PresContext
(
)
-
>
Document
(
)
-
>
EventHandlingSuppressed
(
)
)
{
return
false
;
}
MOZ_ASSERT_IF
(
InputTaskManager
:
:
CanSuspendInputEvent
(
)
&
&
aGUIEvent
-
>
mMessage
!
=
eMouseMove
!
InputTaskManager
:
:
Get
(
)
-
>
IsSuspended
(
)
)
;
RefPtr
<
PresShell
>
ps
=
aFrameToHandleEvent
-
>
PresShell
(
)
;
if
(
aGUIEvent
-
>
mMessage
=
=
eMouseDown
)
{
ps
-
>
mNoDelayedMouseEvents
=
true
;
}
else
if
(
!
ps
-
>
mNoDelayedMouseEvents
&
&
(
aGUIEvent
-
>
mMessage
=
=
eMouseUp
|
|
aGUIEvent
-
>
mMessage
=
=
eContextMenu
|
|
aGUIEvent
-
>
mMessage
=
=
eMouseExitFromWidget
)
)
{
UniquePtr
<
DelayedMouseEvent
>
delayedMouseEvent
=
MakeUnique
<
DelayedMouseEvent
>
(
aGUIEvent
-
>
AsMouseEvent
(
)
)
;
ps
-
>
mDelayedEvents
.
AppendElement
(
std
:
:
move
(
delayedMouseEvent
)
)
;
}
RefPtr
<
EventListener
>
suppressedListener
=
aFrameToHandleEvent
-
>
PresContext
(
)
-
>
Document
(
)
-
>
GetSuppressedEventListener
(
)
;
if
(
!
suppressedListener
|
|
aGUIEvent
-
>
AsMouseEvent
(
)
-
>
mReason
=
=
WidgetMouseEvent
:
:
eSynthesized
)
{
return
true
;
}
nsCOMPtr
<
nsIContent
>
targetContent
;
aFrameToHandleEvent
-
>
GetContentForEvent
(
aGUIEvent
getter_AddRefs
(
targetContent
)
)
;
if
(
targetContent
)
{
aGUIEvent
-
>
mTarget
=
targetContent
;
}
nsCOMPtr
<
EventTarget
>
eventTarget
=
aGUIEvent
-
>
mTarget
;
RefPtr
<
Event
>
event
=
EventDispatcher
:
:
CreateEvent
(
eventTarget
aFrameToHandleEvent
-
>
PresContext
(
)
aGUIEvent
u
"
"
_ns
)
;
suppressedListener
-
>
HandleEvent
(
*
event
)
;
return
true
;
}
nsIFrame
*
PresShell
:
:
EventHandler
:
:
MaybeFlushThrottledStyles
(
nsIFrame
*
aFrameForPresShell
)
{
if
(
!
GetDocument
(
)
)
{
return
aFrameForPresShell
;
}
PresShell
*
rootPresShell
=
mPresShell
-
>
GetRootPresShell
(
)
;
if
(
NS_WARN_IF
(
!
rootPresShell
)
)
{
return
nullptr
;
}
Document
*
rootDocument
=
rootPresShell
-
>
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
rootDocument
)
)
{
return
nullptr
;
}
AutoWeakFrame
weakFrameForPresShell
(
aFrameForPresShell
)
;
{
nsAutoScriptBlocker
scriptBlocker
;
FlushThrottledStyles
(
*
rootDocument
)
;
}
if
(
weakFrameForPresShell
.
IsAlive
(
)
)
{
return
aFrameForPresShell
;
}
return
GetNearestFrameContainingPresShell
(
mPresShell
)
;
}
nsIFrame
*
PresShell
:
:
EventHandler
:
:
ComputeRootFrameToHandleEvent
(
nsIFrame
*
aFrameForPresShell
WidgetGUIEvent
*
aGUIEvent
nsIContent
*
aCapturingContent
bool
*
aIsCapturingContentIgnored
bool
*
aIsCaptureRetargeted
)
{
MOZ_ASSERT
(
aFrameForPresShell
)
;
MOZ_ASSERT
(
aGUIEvent
)
;
MOZ_ASSERT
(
aIsCapturingContentIgnored
)
;
MOZ_ASSERT
(
aIsCaptureRetargeted
)
;
nsIFrame
*
rootFrameToHandleEvent
=
ComputeRootFrameToHandleEventWithPopup
(
aFrameForPresShell
aGUIEvent
aCapturingContent
aIsCapturingContentIgnored
)
;
if
(
*
aIsCapturingContentIgnored
)
{
return
rootFrameToHandleEvent
;
}
if
(
!
aCapturingContent
)
{
return
rootFrameToHandleEvent
;
}
return
ComputeRootFrameToHandleEventWithCapturingContent
(
rootFrameToHandleEvent
aCapturingContent
aIsCapturingContentIgnored
aIsCaptureRetargeted
)
;
}
nsIFrame
*
PresShell
:
:
EventHandler
:
:
ComputeRootFrameToHandleEventWithPopup
(
nsIFrame
*
aRootFrameToHandleEvent
WidgetGUIEvent
*
aGUIEvent
nsIContent
*
aCapturingContent
bool
*
aIsCapturingContentIgnored
)
{
MOZ_ASSERT
(
aRootFrameToHandleEvent
)
;
MOZ_ASSERT
(
aGUIEvent
)
;
MOZ_ASSERT
(
aIsCapturingContentIgnored
)
;
*
aIsCapturingContentIgnored
=
false
;
nsPresContext
*
framePresContext
=
aRootFrameToHandleEvent
-
>
PresContext
(
)
;
nsPresContext
*
rootPresContext
=
framePresContext
-
>
GetRootPresContext
(
)
;
NS_ASSERTION
(
rootPresContext
=
=
GetPresContext
(
)
-
>
GetRootPresContext
(
)
"
How
did
we
end
up
outside
the
connected
"
"
prescontext
/
viewmanager
hierarchy
?
"
)
;
nsIFrame
*
popupFrame
=
nsLayoutUtils
:
:
GetPopupFrameForEventCoordinates
(
rootPresContext
aGUIEvent
)
;
if
(
!
popupFrame
)
{
return
aRootFrameToHandleEvent
;
}
if
(
aCapturingContent
&
&
EventStateManager
:
:
IsTopLevelRemoteTarget
(
aCapturingContent
)
)
{
*
aIsCapturingContentIgnored
=
true
;
}
if
(
nsContentUtils
:
:
ContentIsCrossDocDescendantOf
(
framePresContext
-
>
GetPresShell
(
)
-
>
GetDocument
(
)
popupFrame
-
>
GetContent
(
)
)
)
{
return
aRootFrameToHandleEvent
;
}
if
(
framePresContext
=
=
rootPresContext
&
&
aRootFrameToHandleEvent
=
=
FrameConstructor
(
)
-
>
GetRootFrame
(
)
)
{
return
popupFrame
;
}
if
(
aCapturingContent
&
&
!
*
aIsCapturingContentIgnored
&
&
aCapturingContent
-
>
IsInclusiveDescendantOf
(
popupFrame
-
>
GetContent
(
)
)
)
{
return
popupFrame
;
}
return
aRootFrameToHandleEvent
;
}
nsIFrame
*
PresShell
:
:
EventHandler
:
:
ComputeRootFrameToHandleEventWithCapturingContent
(
nsIFrame
*
aRootFrameToHandleEvent
nsIContent
*
aCapturingContent
bool
*
aIsCapturingContentIgnored
bool
*
aIsCaptureRetargeted
)
{
MOZ_ASSERT
(
aRootFrameToHandleEvent
)
;
MOZ_ASSERT
(
aCapturingContent
)
;
MOZ_ASSERT
(
aIsCapturingContentIgnored
)
;
MOZ_ASSERT
(
aIsCaptureRetargeted
)
;
*
aIsCapturingContentIgnored
=
false
;
*
aIsCaptureRetargeted
=
false
;
BrowsingContext
*
bc
=
GetPresContext
(
)
-
>
Document
(
)
-
>
GetBrowsingContext
(
)
;
if
(
!
bc
|
|
!
bc
-
>
IsActive
(
)
)
{
ClearMouseCapture
(
)
;
*
aIsCapturingContentIgnored
=
true
;
return
aRootFrameToHandleEvent
;
}
if
(
PresShell
:
:
sCapturingContentInfo
.
mRetargetToElement
)
{
*
aIsCaptureRetargeted
=
true
;
return
aRootFrameToHandleEvent
;
}
NS_ASSERTION
(
aCapturingContent
-
>
OwnerDoc
(
)
=
=
GetDocument
(
)
"
Unexpected
document
"
)
;
nsIFrame
*
captureFrame
=
aCapturingContent
-
>
GetPrimaryFrame
(
)
;
if
(
!
captureFrame
)
{
return
aRootFrameToHandleEvent
;
}
nsIScrollableFrame
*
scrollFrame
=
do_QueryFrame
(
captureFrame
)
;
return
scrollFrame
?
scrollFrame
-
>
GetScrolledFrame
(
)
:
aRootFrameToHandleEvent
;
}
nsresult
PresShell
:
:
EventHandler
:
:
HandleEventWithPointerCapturingContentWithoutItsFrame
(
nsIFrame
*
aFrameForPresShell
WidgetGUIEvent
*
aGUIEvent
nsIContent
*
aPointerCapturingContent
nsEventStatus
*
aEventStatus
)
{
MOZ_ASSERT
(
aGUIEvent
)
;
MOZ_ASSERT
(
aPointerCapturingContent
)
;
MOZ_ASSERT
(
!
aPointerCapturingContent
-
>
GetPrimaryFrame
(
)
"
Handle
the
event
with
frame
rather
than
only
with
the
content
"
)
;
MOZ_ASSERT
(
aEventStatus
)
;
RefPtr
<
PresShell
>
presShellForCapturingContent
=
PresShell
:
:
GetShellForEventTarget
(
nullptr
aPointerCapturingContent
)
;
if
(
!
presShellForCapturingContent
)
{
PointerEventHandler
:
:
ReleaseIfCaptureByDescendant
(
aPointerCapturingContent
)
;
PointerEventHandler
:
:
MaybeImplicitlyReleasePointerCapture
(
aGUIEvent
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
overrideClickTarget
=
GetOverrideClickTarget
(
aGUIEvent
aFrameForPresShell
)
;
PointerEventHandler
:
:
DispatchPointerFromMouseOrTouch
(
presShellForCapturingContent
nullptr
aPointerCapturingContent
aGUIEvent
false
aEventStatus
nullptr
)
;
if
(
presShellForCapturingContent
=
=
mPresShell
)
{
return
HandleEventWithTarget
(
aGUIEvent
nullptr
aPointerCapturingContent
aEventStatus
true
nullptr
overrideClickTarget
)
;
}
EventHandler
eventHandlerForCapturingContent
(
std
:
:
move
(
presShellForCapturingContent
)
)
;
return
eventHandlerForCapturingContent
.
HandleEventWithTarget
(
aGUIEvent
nullptr
aPointerCapturingContent
aEventStatus
true
nullptr
overrideClickTarget
)
;
}
nsresult
PresShell
:
:
EventHandler
:
:
HandleEventAtFocusedContent
(
WidgetGUIEvent
*
aGUIEvent
nsEventStatus
*
aEventStatus
)
{
MOZ_ASSERT
(
aGUIEvent
)
;
MOZ_ASSERT
(
aGUIEvent
-
>
IsTargetedAtFocusedContent
(
)
)
;
MOZ_ASSERT
(
aEventStatus
)
;
AutoCurrentEventInfoSetter
eventInfoSetter
(
*
this
)
;
RefPtr
<
Element
>
eventTargetElement
=
ComputeFocusedEventTargetElement
(
aGUIEvent
)
;
mPresShell
-
>
mCurrentEventFrame
=
nullptr
;
if
(
eventTargetElement
)
{
nsresult
rv
=
NS_OK
;
if
(
MaybeHandleEventWithAnotherPresShell
(
eventTargetElement
aGUIEvent
aEventStatus
&
rv
)
)
{
return
rv
;
}
}
mPresShell
-
>
mCurrentEventContent
=
eventTargetElement
;
if
(
!
mPresShell
-
>
GetCurrentEventContent
(
)
|
|
!
mPresShell
-
>
GetCurrentEventFrame
(
)
|
|
InZombieDocument
(
mPresShell
-
>
mCurrentEventContent
)
)
{
return
RetargetEventToParent
(
aGUIEvent
aEventStatus
)
;
}
nsresult
rv
=
HandleEventWithCurrentEventInfo
(
aGUIEvent
aEventStatus
true
nullptr
)
;
return
rv
;
}
Element
*
PresShell
:
:
EventHandler
:
:
ComputeFocusedEventTargetElement
(
WidgetGUIEvent
*
aGUIEvent
)
{
MOZ_ASSERT
(
aGUIEvent
)
;
MOZ_ASSERT
(
aGUIEvent
-
>
IsTargetedAtFocusedContent
(
)
)
;
nsPIDOMWindowOuter
*
window
=
GetDocument
(
)
-
>
GetWindow
(
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
focusedWindow
;
Element
*
eventTargetElement
=
nsFocusManager
:
:
GetFocusedDescendant
(
window
nsFocusManager
:
:
eOnlyCurrentWindow
getter_AddRefs
(
focusedWindow
)
)
;
if
(
!
eventTargetElement
|
|
!
eventTargetElement
-
>
GetPrimaryFrame
(
)
)
{
eventTargetElement
=
GetDocument
(
)
-
>
GetUnfocusedKeyEventTarget
(
)
;
}
switch
(
aGUIEvent
-
>
mMessage
)
{
case
eKeyDown
:
sLastKeyDownEventTargetElement
=
eventTargetElement
;
return
eventTargetElement
;
case
eKeyPress
:
case
eKeyUp
:
if
(
!
sLastKeyDownEventTargetElement
)
{
return
eventTargetElement
;
}
if
(
eventTargetElement
)
{
bool
keyDownIsChrome
=
nsContentUtils
:
:
IsChromeDoc
(
sLastKeyDownEventTargetElement
-
>
GetComposedDoc
(
)
)
;
if
(
keyDownIsChrome
!
=
nsContentUtils
:
:
IsChromeDoc
(
eventTargetElement
-
>
GetComposedDoc
(
)
)
|
|
(
keyDownIsChrome
&
&
BrowserParent
:
:
GetFrom
(
eventTargetElement
)
)
)
{
eventTargetElement
=
sLastKeyDownEventTargetElement
;
}
}
if
(
aGUIEvent
-
>
mMessage
=
=
eKeyUp
)
{
sLastKeyDownEventTargetElement
=
nullptr
;
}
[
[
fallthrough
]
]
;
default
:
return
eventTargetElement
;
}
}
bool
PresShell
:
:
EventHandler
:
:
MaybeHandleEventWithAnotherPresShell
(
Element
*
aEventTargetElement
WidgetGUIEvent
*
aGUIEvent
nsEventStatus
*
aEventStatus
nsresult
*
aRv
)
{
MOZ_ASSERT
(
aEventTargetElement
)
;
MOZ_ASSERT
(
aGUIEvent
)
;
MOZ_ASSERT
(
!
aGUIEvent
-
>
IsUsingCoordinates
(
)
)
;
MOZ_ASSERT
(
aEventStatus
)
;
MOZ_ASSERT
(
aRv
)
;
Document
*
eventTargetDocument
=
aEventTargetElement
-
>
OwnerDoc
(
)
;
if
(
!
eventTargetDocument
|
|
eventTargetDocument
=
=
GetDocument
(
)
)
{
*
aRv
=
NS_OK
;
return
false
;
}
RefPtr
<
PresShell
>
eventTargetPresShell
=
eventTargetDocument
-
>
GetPresShell
(
)
;
if
(
!
eventTargetPresShell
)
{
*
aRv
=
NS_OK
;
return
true
;
}
EventHandler
eventHandler
(
std
:
:
move
(
eventTargetPresShell
)
)
;
*
aRv
=
eventHandler
.
HandleRetargetedEvent
(
aGUIEvent
aEventStatus
aEventTargetElement
)
;
return
true
;
}
nsresult
PresShell
:
:
EventHandler
:
:
HandleEventWithFrameForPresShell
(
nsIFrame
*
aFrameForPresShell
WidgetGUIEvent
*
aGUIEvent
nsEventStatus
*
aEventStatus
)
{
MOZ_ASSERT
(
aGUIEvent
)
;
MOZ_ASSERT
(
!
aGUIEvent
-
>
IsUsingCoordinates
(
)
)
;
MOZ_ASSERT
(
!
aGUIEvent
-
>
IsTargetedAtFocusedContent
(
)
)
;
MOZ_ASSERT
(
aEventStatus
)
;
AutoCurrentEventInfoSetter
eventInfoSetter
(
*
this
aFrameForPresShell
nullptr
)
;
nsresult
rv
=
NS_OK
;
if
(
mPresShell
-
>
GetCurrentEventFrame
(
)
)
{
rv
=
HandleEventWithCurrentEventInfo
(
aGUIEvent
aEventStatus
true
nullptr
)
;
}
return
rv
;
}
Document
*
PresShell
:
:
GetPrimaryContentDocument
(
)
{
nsPresContext
*
context
=
GetPresContext
(
)
;
if
(
!
context
|
|
!
context
-
>
IsRoot
(
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
shellAsTreeItem
=
context
-
>
GetDocShell
(
)
;
if
(
!
shellAsTreeItem
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIDocShellTreeOwner
>
owner
;
shellAsTreeItem
-
>
GetTreeOwner
(
getter_AddRefs
(
owner
)
)
;
if
(
!
owner
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
item
;
owner
-
>
GetPrimaryContentShell
(
getter_AddRefs
(
item
)
)
;
nsCOMPtr
<
nsIDocShell
>
childDocShell
=
do_QueryInterface
(
item
)
;
if
(
!
childDocShell
)
{
return
nullptr
;
}
return
childDocShell
-
>
GetExtantDocument
(
)
;
}
nsresult
PresShell
:
:
EventHandler
:
:
HandleEventWithTarget
(
WidgetEvent
*
aEvent
nsIFrame
*
aNewEventFrame
nsIContent
*
aNewEventContent
nsEventStatus
*
aEventStatus
bool
aIsHandlingNativeEvent
nsIContent
*
*
aTargetContent
nsIContent
*
aOverrideClickTarget
)
{
MOZ_ASSERT
(
aEvent
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aEvent
-
>
IsTrusted
(
)
)
;
#
if
DEBUG
MOZ_ASSERT
(
!
aNewEventFrame
|
|
aNewEventFrame
-
>
PresContext
(
)
-
>
GetPresShell
(
)
=
=
mPresShell
"
wrong
shell
"
)
;
if
(
aNewEventContent
)
{
Document
*
doc
=
aNewEventContent
-
>
GetComposedDoc
(
)
;
NS_ASSERTION
(
doc
"
event
for
content
that
isn
'
t
in
a
document
"
)
;
}
#
endif
NS_ENSURE_STATE
(
!
aNewEventContent
|
|
aNewEventContent
-
>
GetComposedDoc
(
)
=
=
GetDocument
(
)
)
;
if
(
aEvent
-
>
mClass
=
=
ePointerEventClass
)
{
mPresShell
-
>
RecordPointerLocation
(
aEvent
-
>
AsMouseEvent
(
)
)
;
}
AutoPointerEventTargetUpdater
updater
(
mPresShell
aEvent
aNewEventFrame
aTargetContent
)
;
AutoCurrentEventInfoSetter
eventInfoSetter
(
*
this
aNewEventFrame
aNewEventContent
)
;
nsresult
rv
=
HandleEventWithCurrentEventInfo
(
aEvent
aEventStatus
false
aOverrideClickTarget
)
;
return
rv
;
}
namespace
{
class
MOZ_RAII
AutoEventHandler
final
{
public
:
AutoEventHandler
(
WidgetEvent
*
aEvent
Document
*
aDocument
)
:
mEvent
(
aEvent
)
{
MOZ_ASSERT
(
mEvent
)
;
MOZ_ASSERT
(
mEvent
-
>
IsTrusted
(
)
)
;
if
(
mEvent
-
>
mMessage
=
=
eMouseDown
)
{
PresShell
:
:
ReleaseCapturingContent
(
)
;
PresShell
:
:
AllowMouseCapture
(
true
)
;
}
if
(
NeedsToUpdateCurrentMouseBtnState
(
)
)
{
WidgetMouseEvent
*
mouseEvent
=
mEvent
-
>
AsMouseEvent
(
)
;
if
(
mouseEvent
)
{
EventStateManager
:
:
sCurrentMouseBtn
=
mouseEvent
-
>
mButton
;
}
}
}
~
AutoEventHandler
(
)
{
if
(
mEvent
-
>
mMessage
=
=
eMouseDown
)
{
PresShell
:
:
AllowMouseCapture
(
false
)
;
}
if
(
NeedsToUpdateCurrentMouseBtnState
(
)
)
{
EventStateManager
:
:
sCurrentMouseBtn
=
MouseButton
:
:
eNotPressed
;
}
}
protected
:
bool
NeedsToUpdateCurrentMouseBtnState
(
)
const
{
return
mEvent
-
>
mMessage
=
=
eMouseDown
|
|
mEvent
-
>
mMessage
=
=
eMouseUp
|
|
mEvent
-
>
mMessage
=
=
ePointerDown
|
|
mEvent
-
>
mMessage
=
=
ePointerUp
;
}
WidgetEvent
*
mEvent
;
}
;
}
nsresult
PresShell
:
:
EventHandler
:
:
HandleEventWithCurrentEventInfo
(
WidgetEvent
*
aEvent
nsEventStatus
*
aEventStatus
bool
aIsHandlingNativeEvent
nsIContent
*
aOverrideClickTarget
)
{
MOZ_ASSERT
(
aEvent
)
;
MOZ_ASSERT
(
aEventStatus
)
;
RefPtr
<
EventStateManager
>
manager
=
GetPresContext
(
)
-
>
EventStateManager
(
)
;
if
(
NS_EVENT_NEEDS_FRAME
(
aEvent
)
&
&
!
mPresShell
-
>
GetCurrentEventFrame
(
)
&
&
!
mPresShell
-
>
GetCurrentEventContent
(
)
)
{
RecordEventHandlingResponsePerformance
(
aEvent
)
;
return
NS_OK
;
}
if
(
mPresShell
-
>
mCurrentEventContent
&
&
aEvent
-
>
IsTargetedAtFocusedWindow
(
)
&
&
aEvent
-
>
AllowFlushingPendingNotifications
(
)
)
{
if
(
RefPtr
<
nsFocusManager
>
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
)
{
nsCOMPtr
<
nsIContent
>
currentEventContent
=
mPresShell
-
>
mCurrentEventContent
;
fm
-
>
FlushBeforeEventHandlingIfNeeded
(
currentEventContent
)
;
}
}
bool
touchIsNew
=
false
;
if
(
!
PrepareToDispatchEvent
(
aEvent
aEventStatus
&
touchIsNew
)
)
{
return
NS_OK
;
}
RecordEventPreparationPerformance
(
aEvent
)
;
AutoHandlingUserInputStatePusher
userInpStatePusher
(
UserActivation
:
:
IsUserInteractionEvent
(
aEvent
)
aEvent
)
;
AutoEventHandler
eventHandler
(
aEvent
GetDocument
(
)
)
;
AutoPopupStatePusher
popupStatePusher
(
PopupBlocker
:
:
GetEventPopupControlState
(
aEvent
)
)
;
aEvent
-
>
mTarget
=
nullptr
;
HandlingTimeAccumulator
handlingTimeAccumulator
(
*
this
aEvent
)
;
nsresult
rv
=
DispatchEvent
(
manager
aEvent
touchIsNew
aEventStatus
aOverrideClickTarget
)
;
if
(
!
mPresShell
-
>
IsDestroying
(
)
&
&
aIsHandlingNativeEvent
)
{
manager
-
>
TryToFlushPendingNotificationsToIME
(
)
;
}
FinalizeHandlingEvent
(
aEvent
aEventStatus
)
;
RecordEventHandlingResponsePerformance
(
aEvent
)
;
return
rv
;
}
nsresult
PresShell
:
:
EventHandler
:
:
DispatchEvent
(
EventStateManager
*
aEventStateManager
WidgetEvent
*
aEvent
bool
aTouchIsNew
nsEventStatus
*
aEventStatus
nsIContent
*
aOverrideClickTarget
)
{
MOZ_ASSERT
(
aEventStateManager
)
;
MOZ_ASSERT
(
aEvent
)
;
MOZ_ASSERT
(
aEventStatus
)
;
{
RefPtr
<
nsPresContext
>
presContext
=
GetPresContext
(
)
;
nsCOMPtr
<
nsIContent
>
eventContent
=
mPresShell
-
>
mCurrentEventContent
;
nsresult
rv
=
aEventStateManager
-
>
PreHandleEvent
(
presContext
aEvent
mPresShell
-
>
mCurrentEventFrame
eventContent
aEventStatus
aOverrideClickTarget
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
bool
wasHandlingKeyBoardEvent
=
nsContentUtils
:
:
IsHandlingKeyBoardEvent
(
)
;
if
(
aEvent
-
>
mClass
=
=
eKeyboardEventClass
)
{
nsContentUtils
:
:
SetIsHandlingKeyBoardEvent
(
true
)
;
}
if
(
aEvent
-
>
IsAllowedToDispatchDOMEvent
(
)
&
&
!
(
aEvent
-
>
PropagationStopped
(
)
&
&
aEvent
-
>
IsWaitingReplyFromRemoteProcess
(
)
)
)
{
MOZ_ASSERT
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
Somebody
changed
aEvent
to
cause
a
DOM
event
!
"
)
;
nsPresShellEventCB
eventCB
(
mPresShell
)
;
if
(
nsIFrame
*
target
=
mPresShell
-
>
GetCurrentEventFrame
(
)
)
{
if
(
target
-
>
OnlySystemGroupDispatch
(
aEvent
-
>
mMessage
)
)
{
aEvent
-
>
StopPropagation
(
)
;
}
}
if
(
aEvent
-
>
mClass
=
=
eTouchEventClass
)
{
DispatchTouchEventToDOM
(
aEvent
aEventStatus
&
eventCB
aTouchIsNew
)
;
}
else
{
DispatchEventToDOM
(
aEvent
aEventStatus
&
eventCB
)
;
}
}
nsContentUtils
:
:
SetIsHandlingKeyBoardEvent
(
wasHandlingKeyBoardEvent
)
;
if
(
mPresShell
-
>
IsDestroying
(
)
)
{
return
NS_OK
;
}
RefPtr
<
nsPresContext
>
presContext
=
GetPresContext
(
)
;
return
aEventStateManager
-
>
PostHandleEvent
(
presContext
aEvent
mPresShell
-
>
GetCurrentEventFrame
(
)
aEventStatus
aOverrideClickTarget
)
;
}
bool
PresShell
:
:
EventHandler
:
:
PrepareToDispatchEvent
(
WidgetEvent
*
aEvent
nsEventStatus
*
aEventStatus
bool
*
aTouchIsNew
)
{
MOZ_ASSERT
(
aEvent
-
>
IsTrusted
(
)
)
;
MOZ_ASSERT
(
aEventStatus
)
;
MOZ_ASSERT
(
aTouchIsNew
)
;
*
aTouchIsNew
=
false
;
if
(
aEvent
-
>
IsUserAction
(
)
)
{
mPresShell
-
>
mHasHandledUserInput
=
true
;
}
switch
(
aEvent
-
>
mMessage
)
{
case
eKeyPress
:
case
eKeyDown
:
case
eKeyUp
:
{
WidgetKeyboardEvent
*
keyboardEvent
=
aEvent
-
>
AsKeyboardEvent
(
)
;
MaybeHandleKeyboardEventBeforeDispatch
(
keyboardEvent
)
;
return
true
;
}
case
eMouseMove
:
{
bool
allowCapture
=
EventStateManager
:
:
GetActiveEventStateManager
(
)
&
&
GetPresContext
(
)
&
&
GetPresContext
(
)
-
>
EventStateManager
(
)
=
=
EventStateManager
:
:
GetActiveEventStateManager
(
)
;
PresShell
:
:
AllowMouseCapture
(
allowCapture
)
;
return
true
;
}
case
eDrop
:
{
nsCOMPtr
<
nsIDragSession
>
session
=
nsContentUtils
:
:
GetDragSession
(
)
;
if
(
session
)
{
bool
onlyChromeDrop
=
false
;
session
-
>
GetOnlyChromeDrop
(
&
onlyChromeDrop
)
;
if
(
onlyChromeDrop
)
{
aEvent
-
>
mFlags
.
mOnlyChromeDispatch
=
true
;
}
}
return
true
;
}
case
eDragExit
:
{
if
(
!
StaticPrefs
:
:
dom_event_dragexit_enabled
(
)
)
{
aEvent
-
>
mFlags
.
mOnlyChromeDispatch
=
true
;
}
return
true
;
}
case
eContextMenu
:
{
WidgetMouseEvent
*
mouseEvent
=
aEvent
-
>
AsMouseEvent
(
)
;
if
(
mouseEvent
-
>
IsContextMenuKeyEvent
(
)
&
&
!
AdjustContextMenuKeyEvent
(
mouseEvent
)
)
{
return
false
;
}
if
(
mouseEvent
-
>
IsShift
(
)
&
&
StaticPrefs
:
:
dom_event_contextmenu_shift_suppresses_event
(
)
)
{
aEvent
-
>
mFlags
.
mOnlyChromeDispatch
=
true
;
aEvent
-
>
mFlags
.
mRetargetToNonNativeAnonymous
=
true
;
}
return
true
;
}
case
eTouchStart
:
case
eTouchMove
:
case
eTouchEnd
:
case
eTouchCancel
:
case
eTouchPointerCancel
:
return
mPresShell
-
>
mTouchManager
.
PreHandleEvent
(
aEvent
aEventStatus
*
aTouchIsNew
mPresShell
-
>
mCurrentEventContent
)
;
default
:
return
true
;
}
}
void
PresShell
:
:
EventHandler
:
:
FinalizeHandlingEvent
(
WidgetEvent
*
aEvent
const
nsEventStatus
*
aStatus
)
{
switch
(
aEvent
-
>
mMessage
)
{
case
eKeyPress
:
case
eKeyDown
:
case
eKeyUp
:
{
if
(
aEvent
-
>
AsKeyboardEvent
(
)
-
>
mKeyCode
=
=
NS_VK_ESCAPE
)
{
if
(
aEvent
-
>
mMessage
=
=
eKeyUp
)
{
mPresShell
-
>
mIsLastChromeOnlyEscapeKeyConsumed
=
false
;
}
else
{
if
(
aEvent
-
>
mFlags
.
mOnlyChromeDispatch
&
&
aEvent
-
>
mFlags
.
mDefaultPreventedByChrome
)
{
mPresShell
-
>
mIsLastChromeOnlyEscapeKeyConsumed
=
true
;
}
if
(
aEvent
-
>
mMessage
=
=
eKeyDown
&
&
!
aEvent
-
>
mFlags
.
mDefaultPrevented
)
{
if
(
RefPtr
<
Document
>
doc
=
GetDocument
(
)
)
{
doc
-
>
HandleEscKey
(
)
;
}
}
}
}
if
(
aEvent
-
>
mMessage
=
=
eKeyDown
)
{
mPresShell
-
>
mIsLastKeyDownCanceled
=
aEvent
-
>
mFlags
.
mDefaultPrevented
;
}
return
;
}
case
eMouseUp
:
PresShell
:
:
ReleaseCapturingContent
(
)
;
return
;
case
eMouseMove
:
PresShell
:
:
AllowMouseCapture
(
false
)
;
return
;
case
eDrag
:
case
eDragEnd
:
case
eDragEnter
:
case
eDragExit
:
case
eDragLeave
:
case
eDragOver
:
case
eDrop
:
{
DataTransfer
*
dataTransfer
=
aEvent
-
>
AsDragEvent
(
)
-
>
mDataTransfer
;
if
(
dataTransfer
)
{
dataTransfer
-
>
Disconnect
(
)
;
}
return
;
}
case
eTouchStart
:
case
eTouchMove
:
case
eTouchEnd
:
case
eTouchCancel
:
case
eTouchPointerCancel
:
case
eMouseLongTap
:
case
eContextMenu
:
{
mPresShell
-
>
mTouchManager
.
PostHandleEvent
(
aEvent
aStatus
)
;
break
;
}
default
:
return
;
}
}
void
PresShell
:
:
EventHandler
:
:
MaybeHandleKeyboardEventBeforeDispatch
(
WidgetKeyboardEvent
*
aKeyboardEvent
)
{
MOZ_ASSERT
(
aKeyboardEvent
)
;
if
(
aKeyboardEvent
-
>
mKeyCode
!
=
NS_VK_ESCAPE
)
{
return
;
}
Document
*
doc
=
mPresShell
-
>
GetCurrentEventContent
(
)
?
mPresShell
-
>
mCurrentEventContent
-
>
OwnerDoc
(
)
:
nullptr
;
Document
*
root
=
nsContentUtils
:
:
GetInProcessSubtreeRootDocument
(
doc
)
;
if
(
root
&
&
root
-
>
GetFullscreenElement
(
)
)
{
aKeyboardEvent
-
>
PreventDefaultBeforeDispatch
(
CrossProcessForwarding
:
:
eStop
)
;
aKeyboardEvent
-
>
mFlags
.
mOnlyChromeDispatch
=
true
;
if
(
!
mPresShell
-
>
mIsLastChromeOnlyEscapeKeyConsumed
&
&
aKeyboardEvent
-
>
mMessage
=
=
eKeyUp
)
{
Document
:
:
AsyncExitFullscreen
(
nullptr
)
;
}
}
nsCOMPtr
<
Document
>
pointerLockedDoc
=
PointerLockManager
:
:
GetLockedDocument
(
)
;
if
(
!
mPresShell
-
>
mIsLastChromeOnlyEscapeKeyConsumed
&
&
pointerLockedDoc
)
{
aKeyboardEvent
-
>
PreventDefaultBeforeDispatch
(
CrossProcessForwarding
:
:
eStop
)
;
aKeyboardEvent
-
>
mFlags
.
mOnlyChromeDispatch
=
true
;
if
(
aKeyboardEvent
-
>
mMessage
=
=
eKeyUp
)
{
PointerLockManager
:
:
Unlock
(
)
;
}
}
}
void
PresShell
:
:
EventHandler
:
:
RecordEventPreparationPerformance
(
const
WidgetEvent
*
aEvent
)
{
MOZ_ASSERT
(
aEvent
)
;
switch
(
aEvent
-
>
mMessage
)
{
case
eKeyPress
:
case
eKeyDown
:
case
eKeyUp
:
if
(
aEvent
-
>
AsKeyboardEvent
(
)
-
>
ShouldInteractionTimeRecorded
(
)
)
{
GetPresContext
(
)
-
>
RecordInteractionTime
(
nsPresContext
:
:
InteractionType
:
:
KeyInteraction
aEvent
-
>
mTimeStamp
)
;
}
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
INPUT_EVENT_QUEUED_KEYBOARD_MS
aEvent
-
>
mTimeStamp
)
;
return
;
case
eMouseDown
:
case
eMouseUp
:
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
INPUT_EVENT_QUEUED_CLICK_MS
aEvent
-
>
mTimeStamp
)
;
[
[
fallthrough
]
]
;
case
ePointerDown
:
case
ePointerUp
:
GetPresContext
(
)
-
>
RecordInteractionTime
(
nsPresContext
:
:
InteractionType
:
:
ClickInteraction
aEvent
-
>
mTimeStamp
)
;
return
;
case
eMouseMove
:
if
(
aEvent
-
>
mFlags
.
mHandledByAPZ
)
{
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
INPUT_EVENT_QUEUED_APZ_MOUSE_MOVE_MS
aEvent
-
>
mTimeStamp
)
;
}
GetPresContext
(
)
-
>
RecordInteractionTime
(
nsPresContext
:
:
InteractionType
:
:
MouseMoveInteraction
aEvent
-
>
mTimeStamp
)
;
return
;
case
eWheel
:
if
(
aEvent
-
>
mFlags
.
mHandledByAPZ
)
{
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
INPUT_EVENT_QUEUED_APZ_WHEEL_MS
aEvent
-
>
mTimeStamp
)
;
}
return
;
case
eTouchMove
:
if
(
aEvent
-
>
mFlags
.
mHandledByAPZ
)
{
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
INPUT_EVENT_QUEUED_APZ_TOUCH_MOVE_MS
aEvent
-
>
mTimeStamp
)
;
}
return
;
default
:
return
;
}
}
void
PresShell
:
:
EventHandler
:
:
RecordEventHandlingResponsePerformance
(
const
WidgetEvent
*
aEvent
)
{
if
(
!
Telemetry
:
:
CanRecordBase
(
)
|
|
aEvent
-
>
mTimeStamp
.
IsNull
(
)
|
|
aEvent
-
>
mTimeStamp
<
=
mPresShell
-
>
mLastOSWake
|
|
!
aEvent
-
>
AsInputEvent
(
)
)
{
return
;
}
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
double
millis
=
(
now
-
aEvent
-
>
mTimeStamp
)
.
ToMilliseconds
(
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
INPUT_EVENT_RESPONSE_MS
millis
)
;
if
(
GetDocument
(
)
&
&
GetDocument
(
)
-
>
GetReadyStateEnum
(
)
!
=
Document
:
:
READYSTATE_COMPLETE
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
LOAD_INPUT_EVENT_RESPONSE_MS
millis
)
;
}
if
(
!
sLastInputProcessed
|
|
sLastInputProcessed
<
aEvent
-
>
mTimeStamp
)
{
if
(
sLastInputProcessed
)
{
double
lastMillis
=
(
sLastInputProcessed
-
sLastInputCreated
)
.
ToMilliseconds
(
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
INPUT_EVENT_RESPONSE_COALESCED_MS
lastMillis
)
;
if
(
MOZ_UNLIKELY
(
!
PresShell
:
:
sProcessInteractable
)
)
{
if
(
XRE_IsContentProcess
(
)
&
&
GetDocument
(
)
&
&
GetDocument
(
)
-
>
IsTopLevelContentDocument
(
)
)
{
switch
(
GetDocument
(
)
-
>
GetReadyStateEnum
(
)
)
{
case
Document
:
:
READYSTATE_INTERACTIVE
:
case
Document
:
:
READYSTATE_COMPLETE
:
PresShell
:
:
sProcessInteractable
=
true
;
break
;
default
:
break
;
}
}
}
if
(
MOZ_LIKELY
(
PresShell
:
:
sProcessInteractable
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
INPUT_EVENT_RESPONSE_POST_STARTUP_MS
lastMillis
)
;
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
INPUT_EVENT_RESPONSE_STARTUP_MS
lastMillis
)
;
}
}
sLastInputCreated
=
aEvent
-
>
mTimeStamp
;
}
else
if
(
aEvent
-
>
mTimeStamp
<
sLastInputCreated
)
{
sLastInputCreated
=
aEvent
-
>
mTimeStamp
;
}
sLastInputProcessed
=
now
;
}
nsIPrincipal
*
PresShell
:
:
EventHandler
:
:
GetDocumentPrincipalToCompareWithBlacklist
(
PresShell
&
aPresShell
)
{
nsPresContext
*
presContext
=
aPresShell
.
GetPresContext
(
)
;
if
(
NS_WARN_IF
(
!
presContext
)
)
{
return
nullptr
;
}
return
presContext
-
>
Document
(
)
-
>
GetPrincipalForPrefBasedHacks
(
)
;
}
nsresult
PresShell
:
:
EventHandler
:
:
DispatchEventToDOM
(
WidgetEvent
*
aEvent
nsEventStatus
*
aEventStatus
nsPresShellEventCB
*
aEventCB
)
{
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsINode
>
eventTarget
=
mPresShell
-
>
mCurrentEventContent
;
nsPresShellEventCB
*
eventCBPtr
=
aEventCB
;
if
(
!
eventTarget
)
{
nsCOMPtr
<
nsIContent
>
targetContent
;
if
(
mPresShell
-
>
mCurrentEventFrame
)
{
rv
=
mPresShell
-
>
mCurrentEventFrame
-
>
GetContentForEvent
(
aEvent
getter_AddRefs
(
targetContent
)
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
&
&
targetContent
)
{
eventTarget
=
targetContent
;
}
else
if
(
GetDocument
(
)
)
{
eventTarget
=
GetDocument
(
)
;
eventCBPtr
=
nullptr
;
}
}
if
(
eventTarget
)
{
if
(
eventTarget
-
>
OwnerDoc
(
)
-
>
ShouldResistFingerprinting
(
RFPTarget
:
:
WidgetEvents
)
&
&
aEvent
-
>
IsBlockedForFingerprintingResistance
(
)
)
{
aEvent
-
>
mFlags
.
mOnlySystemGroupDispatchInContent
=
true
;
}
else
if
(
aEvent
-
>
mMessage
=
=
eKeyPress
)
{
if
(
!
mPresShell
-
>
mInitializedWithKeyPressEventDispatchingBlacklist
)
{
mPresShell
-
>
mInitializedWithKeyPressEventDispatchingBlacklist
=
true
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
GetDocumentPrincipalToCompareWithBlacklist
(
*
mPresShell
)
;
if
(
principal
)
{
mPresShell
-
>
mForceDispatchKeyPressEventsForNonPrintableKeys
=
principal
-
>
IsURIInPrefList
(
"
dom
.
keyboardevent
.
keypress
.
hack
.
dispatch_non_printable_
"
"
keys
"
)
|
|
principal
-
>
IsURIInPrefList
(
"
dom
.
keyboardevent
.
keypress
.
hack
.
"
"
dispatch_non_printable_keys
.
addl
"
)
;
mPresShell
-
>
mForceUseLegacyKeyCodeAndCharCodeValues
|
=
principal
-
>
IsURIInPrefList
(
"
dom
.
keyboardevent
.
keypress
.
hack
.
"
"
use_legacy_keycode_and_charcode
"
)
|
|
principal
-
>
IsURIInPrefList
(
"
dom
.
keyboardevent
.
keypress
.
hack
.
"
"
use_legacy_keycode_and_charcode
.
addl
"
)
;
}
}
if
(
mPresShell
-
>
mForceDispatchKeyPressEventsForNonPrintableKeys
)
{
aEvent
-
>
mFlags
.
mOnlySystemGroupDispatchInContent
=
false
;
}
if
(
mPresShell
-
>
mForceUseLegacyKeyCodeAndCharCodeValues
)
{
aEvent
-
>
AsKeyboardEvent
(
)
-
>
mUseLegacyKeyCodeAndCharCodeValues
=
true
;
}
}
if
(
aEvent
-
>
mClass
=
=
eCompositionEventClass
)
{
RefPtr
<
nsPresContext
>
presContext
=
GetPresContext
(
)
;
RefPtr
<
BrowserParent
>
browserParent
=
IMEStateManager
:
:
GetActiveBrowserParent
(
)
;
IMEStateManager
:
:
DispatchCompositionEvent
(
eventTarget
presContext
browserParent
aEvent
-
>
AsCompositionEvent
(
)
aEventStatus
eventCBPtr
)
;
}
else
{
if
(
aEvent
-
>
mClass
=
=
eMouseEventClass
)
{
PresShell
:
:
sMouseButtons
=
aEvent
-
>
AsMouseEvent
(
)
-
>
mButtons
;
}
RefPtr
<
nsPresContext
>
presContext
=
GetPresContext
(
)
;
EventDispatcher
:
:
Dispatch
(
eventTarget
presContext
aEvent
nullptr
aEventStatus
eventCBPtr
)
;
}
}
return
rv
;
}
void
PresShell
:
:
EventHandler
:
:
DispatchTouchEventToDOM
(
WidgetEvent
*
aEvent
nsEventStatus
*
aEventStatus
nsPresShellEventCB
*
aEventCB
bool
aTouchIsNew
)
{
bool
canPrevent
=
(
aEvent
-
>
mMessage
=
=
eTouchStart
)
|
|
(
aEvent
-
>
mMessage
=
=
eTouchMove
&
&
aTouchIsNew
)
|
|
(
aEvent
-
>
mMessage
=
=
eTouchEnd
)
;
bool
preventDefault
=
false
;
nsEventStatus
tmpStatus
=
nsEventStatus_eIgnore
;
WidgetTouchEvent
*
touchEvent
=
aEvent
-
>
AsTouchEvent
(
)
;
for
(
dom
:
:
Touch
*
touch
:
touchEvent
-
>
mTouches
)
{
MOZ_ASSERT
(
!
touch
-
>
mIsTouchEventSuppressed
)
;
if
(
!
touch
|
|
!
touch
-
>
mChanged
)
{
continue
;
}
nsCOMPtr
<
EventTarget
>
targetPtr
=
touch
-
>
mTarget
;
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
targetPtr
)
;
if
(
!
content
)
{
continue
;
}
Document
*
doc
=
content
-
>
OwnerDoc
(
)
;
nsIContent
*
capturingContent
=
PresShell
:
:
GetCapturingContent
(
)
;
if
(
capturingContent
)
{
if
(
capturingContent
-
>
OwnerDoc
(
)
!
=
doc
)
{
continue
;
}
content
=
capturingContent
;
}
MOZ_ASSERT
(
touchEvent
-
>
IsTrusted
(
)
)
;
WidgetTouchEvent
newEvent
(
true
touchEvent
-
>
mMessage
touchEvent
-
>
mWidget
)
;
newEvent
.
AssignTouchEventData
(
*
touchEvent
false
)
;
newEvent
.
mTarget
=
targetPtr
;
newEvent
.
mFlags
.
mHandledByAPZ
=
touchEvent
-
>
mFlags
.
mHandledByAPZ
;
RefPtr
<
PresShell
>
contentPresShell
;
if
(
doc
=
=
GetDocument
(
)
)
{
contentPresShell
=
doc
-
>
GetPresShell
(
)
;
if
(
contentPresShell
)
{
contentPresShell
-
>
PushCurrentEventInfo
(
content
-
>
GetPrimaryFrame
(
)
content
)
;
}
}
RefPtr
<
nsPresContext
>
presContext
=
doc
-
>
GetPresContext
(
)
;
if
(
!
presContext
)
{
if
(
contentPresShell
)
{
contentPresShell
-
>
PopCurrentEventInfo
(
)
;
}
continue
;
}
tmpStatus
=
nsEventStatus_eIgnore
;
EventDispatcher
:
:
Dispatch
(
targetPtr
presContext
&
newEvent
nullptr
&
tmpStatus
aEventCB
)
;
if
(
nsEventStatus_eConsumeNoDefault
=
=
tmpStatus
|
|
newEvent
.
mFlags
.
mMultipleActionsPrevented
)
{
preventDefault
=
true
;
}
if
(
newEvent
.
mFlags
.
mMultipleActionsPrevented
)
{
touchEvent
-
>
mFlags
.
mMultipleActionsPrevented
=
true
;
}
if
(
contentPresShell
)
{
contentPresShell
-
>
PopCurrentEventInfo
(
)
;
}
}
if
(
preventDefault
&
&
canPrevent
)
{
*
aEventStatus
=
nsEventStatus_eConsumeNoDefault
;
}
else
{
*
aEventStatus
=
nsEventStatus_eIgnore
;
}
}
nsresult
PresShell
:
:
HandleDOMEventWithTarget
(
nsIContent
*
aTargetContent
WidgetEvent
*
aEvent
nsEventStatus
*
aStatus
)
{
nsresult
rv
=
NS_OK
;
PushCurrentEventInfo
(
nullptr
aTargetContent
)
;
nsCOMPtr
<
nsISupports
>
container
=
mPresContext
-
>
GetContainerWeak
(
)
;
if
(
container
)
{
rv
=
EventDispatcher
:
:
Dispatch
(
aTargetContent
mPresContext
aEvent
nullptr
aStatus
)
;
}
PopCurrentEventInfo
(
)
;
return
rv
;
}
nsresult
PresShell
:
:
HandleDOMEventWithTarget
(
nsIContent
*
aTargetContent
Event
*
aEvent
nsEventStatus
*
aStatus
)
{
nsresult
rv
=
NS_OK
;
PushCurrentEventInfo
(
nullptr
aTargetContent
)
;
nsCOMPtr
<
nsISupports
>
container
=
mPresContext
-
>
GetContainerWeak
(
)
;
if
(
container
)
{
rv
=
EventDispatcher
:
:
DispatchDOMEvent
(
aTargetContent
nullptr
aEvent
mPresContext
aStatus
)
;
}
PopCurrentEventInfo
(
)
;
return
rv
;
}
bool
PresShell
:
:
EventHandler
:
:
AdjustContextMenuKeyEvent
(
WidgetMouseEvent
*
aMouseEvent
)
{
if
(
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
)
{
nsIFrame
*
popupFrame
=
pm
-
>
GetTopPopup
(
widget
:
:
PopupType
:
:
Menu
)
;
if
(
popupFrame
)
{
nsIFrame
*
itemFrame
=
(
static_cast
<
nsMenuPopupFrame
*
>
(
popupFrame
)
)
-
>
GetCurrentMenuItemFrame
(
)
;
if
(
!
itemFrame
)
itemFrame
=
popupFrame
;
nsCOMPtr
<
nsIWidget
>
widget
=
popupFrame
-
>
GetNearestWidget
(
)
;
aMouseEvent
-
>
mWidget
=
widget
;
LayoutDeviceIntPoint
widgetPoint
=
widget
-
>
WidgetToScreenOffset
(
)
;
aMouseEvent
-
>
mRefPoint
=
LayoutDeviceIntPoint
:
:
FromAppUnitsToNearest
(
itemFrame
-
>
GetScreenRectInAppUnits
(
)
.
BottomLeft
(
)
itemFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
-
widgetPoint
;
mPresShell
-
>
mCurrentEventContent
=
itemFrame
-
>
GetContent
(
)
;
mPresShell
-
>
mCurrentEventFrame
=
itemFrame
;
return
true
;
}
}
nsRootPresContext
*
rootPC
=
GetPresContext
(
)
-
>
GetRootPresContext
(
)
;
aMouseEvent
-
>
mRefPoint
=
LayoutDeviceIntPoint
(
0
0
)
;
if
(
rootPC
)
{
aMouseEvent
-
>
mWidget
=
rootPC
-
>
PresShell
(
)
-
>
GetViewManager
(
)
-
>
GetRootWidget
(
)
;
if
(
aMouseEvent
-
>
mWidget
)
{
nsPoint
offset
(
0
0
)
;
nsIFrame
*
rootFrame
=
FrameConstructor
(
)
-
>
GetRootFrame
(
)
;
if
(
rootFrame
)
{
nsView
*
view
=
rootFrame
-
>
GetClosestView
(
&
offset
)
;
offset
+
=
view
-
>
GetOffsetToWidget
(
aMouseEvent
-
>
mWidget
)
;
aMouseEvent
-
>
mRefPoint
=
LayoutDeviceIntPoint
:
:
FromAppUnitsToNearest
(
offset
GetPresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
}
}
}
else
{
aMouseEvent
-
>
mWidget
=
nullptr
;
}
LayoutDeviceIntPoint
caretPoint
;
if
(
PrepareToUseCaretPosition
(
MOZ_KnownLive
(
aMouseEvent
-
>
mWidget
)
caretPoint
)
)
{
int32_t
devPixelRatio
=
GetPresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
caretPoint
=
LayoutDeviceIntPoint
:
:
FromAppUnitsToNearest
(
ViewportUtils
:
:
LayoutToVisual
(
LayoutDeviceIntPoint
:
:
ToAppUnits
(
caretPoint
devPixelRatio
)
GetPresContext
(
)
-
>
PresShell
(
)
)
devPixelRatio
)
;
aMouseEvent
-
>
mRefPoint
=
caretPoint
;
return
true
;
}
RefPtr
<
Element
>
currentFocus
;
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
fm
)
{
currentFocus
=
fm
-
>
GetFocusedElement
(
)
;
}
if
(
currentFocus
)
{
nsCOMPtr
<
nsIContent
>
currentPointElement
;
GetCurrentItemAndPositionForElement
(
currentFocus
getter_AddRefs
(
currentPointElement
)
aMouseEvent
-
>
mRefPoint
MOZ_KnownLive
(
aMouseEvent
-
>
mWidget
)
)
;
if
(
currentPointElement
)
{
mPresShell
-
>
mCurrentEventContent
=
currentPointElement
;
mPresShell
-
>
mCurrentEventFrame
=
nullptr
;
mPresShell
-
>
GetCurrentEventFrame
(
)
;
}
}
return
true
;
}
bool
PresShell
:
:
EventHandler
:
:
PrepareToUseCaretPosition
(
nsIWidget
*
aEventWidget
LayoutDeviceIntPoint
&
aTargetPt
)
{
nsresult
rv
;
RefPtr
<
nsCaret
>
caret
=
mPresShell
-
>
GetCaret
(
)
;
NS_ENSURE_TRUE
(
caret
false
)
;
bool
caretVisible
=
caret
-
>
IsVisible
(
)
;
if
(
!
caretVisible
)
return
false
;
Selection
*
domSelection
=
caret
-
>
GetSelection
(
)
;
NS_ENSURE_TRUE
(
domSelection
false
)
;
nsIFrame
*
frame
=
nullptr
;
nsINode
*
node
=
domSelection
-
>
GetFocusNode
(
)
;
NS_ENSURE_TRUE
(
node
false
)
;
nsCOMPtr
<
nsIContent
>
content
=
nsIContent
:
:
FromNode
(
node
)
;
if
(
content
)
{
nsIContent
*
nonNative
=
content
-
>
FindFirstNonChromeOnlyAccessContent
(
)
;
content
=
nonNative
;
}
if
(
content
)
{
rv
=
MOZ_KnownLive
(
mPresShell
)
-
>
ScrollContentIntoView
(
content
ScrollAxis
(
WhereToScroll
:
:
Nearest
WhenToScroll
:
:
IfNotVisible
)
ScrollAxis
(
WhereToScroll
:
:
Nearest
WhenToScroll
:
:
IfNotVisible
)
ScrollFlags
:
:
ScrollOverflowHidden
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
frame
=
content
-
>
GetPrimaryFrame
(
)
;
NS_WARNING_ASSERTION
(
frame
"
No
frame
for
focused
content
?
"
)
;
}
nsCOMPtr
<
nsISelectionController
>
selCon
;
if
(
frame
)
frame
-
>
GetSelectionController
(
GetPresContext
(
)
getter_AddRefs
(
selCon
)
)
;
else
selCon
=
static_cast
<
nsISelectionController
*
>
(
mPresShell
)
;
if
(
selCon
)
{
rv
=
selCon
-
>
ScrollSelectionIntoView
(
nsISelectionController
:
:
SELECTION_NORMAL
nsISelectionController
:
:
SELECTION_FOCUS_REGION
nsISelectionController
:
:
SCROLL_SYNCHRONOUS
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
}
nsPresContext
*
presContext
=
GetPresContext
(
)
;
nsRect
caretCoords
;
nsIFrame
*
caretFrame
=
caret
-
>
GetGeometry
(
&
caretCoords
)
;
if
(
!
caretFrame
)
return
false
;
nsPoint
viewOffset
;
nsView
*
view
=
caretFrame
-
>
GetClosestView
(
&
viewOffset
)
;
if
(
!
view
)
return
false
;
if
(
aEventWidget
)
{
viewOffset
+
=
view
-
>
GetOffsetToWidget
(
aEventWidget
)
;
}
caretCoords
.
MoveBy
(
viewOffset
)
;
aTargetPt
.
x
=
presContext
-
>
AppUnitsToDevPixels
(
caretCoords
.
x
+
caretCoords
.
width
)
;
aTargetPt
.
y
=
presContext
-
>
AppUnitsToDevPixels
(
caretCoords
.
y
+
caretCoords
.
height
)
;
aTargetPt
.
y
-
=
1
;
return
true
;
}
void
PresShell
:
:
EventHandler
:
:
GetCurrentItemAndPositionForElement
(
Element
*
aFocusedElement
nsIContent
*
*
aTargetToUse
LayoutDeviceIntPoint
&
aTargetPt
nsIWidget
*
aRootWidget
)
{
nsCOMPtr
<
nsIContent
>
focusedContent
=
aFocusedElement
;
MOZ_KnownLive
(
mPresShell
)
-
>
ScrollContentIntoView
(
focusedContent
ScrollAxis
(
)
ScrollAxis
(
)
ScrollFlags
:
:
ScrollOverflowHidden
)
;
nsPresContext
*
presContext
=
GetPresContext
(
)
;
bool
istree
=
false
checkLineHeight
=
true
;
nscoord
extraTreeY
=
0
;
nsCOMPtr
<
Element
>
item
;
nsCOMPtr
<
nsIDOMXULMultiSelectControlElement
>
multiSelect
=
aFocusedElement
-
>
AsXULMultiSelectControl
(
)
;
if
(
multiSelect
)
{
checkLineHeight
=
false
;
int32_t
currentIndex
;
multiSelect
-
>
GetCurrentIndex
(
&
currentIndex
)
;
if
(
currentIndex
>
=
0
)
{
RefPtr
<
XULTreeElement
>
tree
=
XULTreeElement
:
:
FromNode
(
focusedContent
)
;
if
(
tree
)
{
tree
-
>
EnsureRowIsVisible
(
currentIndex
)
;
int32_t
firstVisibleRow
=
tree
-
>
GetFirstVisibleRow
(
)
;
int32_t
rowHeight
=
tree
-
>
RowHeight
(
)
;
extraTreeY
+
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
(
currentIndex
-
firstVisibleRow
+
1
)
*
rowHeight
)
;
istree
=
true
;
RefPtr
<
nsTreeColumns
>
cols
=
tree
-
>
GetColumns
(
)
;
if
(
cols
)
{
nsTreeColumn
*
col
=
cols
-
>
GetFirstColumn
(
)
;
if
(
col
)
{
RefPtr
<
Element
>
colElement
=
col
-
>
Element
(
)
;
nsIFrame
*
frame
=
colElement
-
>
GetPrimaryFrame
(
)
;
if
(
frame
)
{
extraTreeY
+
=
frame
-
>
GetSize
(
)
.
height
;
}
}
}
}
else
{
multiSelect
-
>
GetCurrentItem
(
getter_AddRefs
(
item
)
)
;
}
}
}
else
{
nsCOMPtr
<
nsIDOMXULMenuListElement
>
menulist
=
aFocusedElement
-
>
AsXULMenuList
(
)
;
if
(
!
menulist
)
{
nsCOMPtr
<
nsIDOMXULSelectControlElement
>
select
=
aFocusedElement
-
>
AsXULSelectControl
(
)
;
if
(
select
)
{
checkLineHeight
=
false
;
select
-
>
GetSelectedItem
(
getter_AddRefs
(
item
)
)
;
}
}
}
if
(
item
)
{
focusedContent
=
item
;
}
nsIFrame
*
frame
=
focusedContent
-
>
GetPrimaryFrame
(
)
;
if
(
frame
)
{
NS_ASSERTION
(
frame
-
>
PresContext
(
)
=
=
GetPresContext
(
)
"
handling
event
for
focused
content
that
is
not
in
our
document
?
"
)
;
nsPoint
frameOrigin
(
0
0
)
;
nsView
*
view
=
frame
-
>
GetClosestView
(
&
frameOrigin
)
;
NS_ASSERTION
(
view
"
No
view
for
frame
"
)
;
if
(
aRootWidget
)
{
frameOrigin
+
=
view
-
>
GetOffsetToWidget
(
aRootWidget
)
;
}
nscoord
extra
=
0
;
if
(
!
istree
)
{
extra
=
frame
-
>
GetSize
(
)
.
height
;
if
(
checkLineHeight
)
{
nsIScrollableFrame
*
scrollFrame
=
nsLayoutUtils
:
:
GetNearestScrollableFrame
(
frame
nsLayoutUtils
:
:
SCROLLABLE_INCLUDE_HIDDEN
|
nsLayoutUtils
:
:
SCROLLABLE_FIXEDPOS_FINDS_ROOT
)
;
if
(
scrollFrame
)
{
nsSize
scrollAmount
=
scrollFrame
-
>
GetLineScrollAmount
(
)
;
nsIFrame
*
f
=
do_QueryFrame
(
scrollFrame
)
;
int32_t
APD
=
presContext
-
>
AppUnitsPerDevPixel
(
)
;
int32_t
scrollAPD
=
f
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
scrollAmount
=
scrollAmount
.
ScaleToOtherAppUnits
(
scrollAPD
APD
)
;
if
(
extra
>
scrollAmount
.
height
)
{
extra
=
scrollAmount
.
height
;
}
}
}
}
aTargetPt
.
x
=
presContext
-
>
AppUnitsToDevPixels
(
frameOrigin
.
x
)
;
aTargetPt
.
y
=
presContext
-
>
AppUnitsToDevPixels
(
frameOrigin
.
y
+
extra
+
extraTreeY
)
;
}
NS_IF_ADDREF
(
*
aTargetToUse
=
focusedContent
)
;
}
bool
PresShell
:
:
ShouldIgnoreInvalidation
(
)
{
return
mPaintingSuppressed
|
|
!
mIsActive
|
|
mIsNeverPainting
;
}
void
PresShell
:
:
WillPaint
(
)
{
if
(
!
mIsActive
|
|
mPaintingSuppressed
|
|
!
IsVisible
(
)
)
{
return
;
}
nsRootPresContext
*
rootPresContext
=
mPresContext
-
>
GetRootPresContext
(
)
;
if
(
!
rootPresContext
)
{
return
;
}
rootPresContext
-
>
FlushWillPaintObservers
(
)
;
if
(
mIsDestroying
)
return
;
FlushPendingNotifications
(
ChangesToFlush
(
FlushType
:
:
InterruptibleLayout
false
)
)
;
}
void
PresShell
:
:
DidPaintWindow
(
)
{
nsRootPresContext
*
rootPresContext
=
mPresContext
-
>
GetRootPresContext
(
)
;
if
(
rootPresContext
!
=
mPresContext
)
{
return
;
}
if
(
!
mHasReceivedPaintMessage
)
{
mHasReceivedPaintMessage
=
true
;
nsCOMPtr
<
nsIObserverService
>
obsvc
=
services
:
:
GetObserverService
(
)
;
if
(
obsvc
&
&
mDocument
)
{
nsPIDOMWindowOuter
*
window
=
mDocument
-
>
GetWindow
(
)
;
if
(
window
&
&
nsGlobalWindowOuter
:
:
Cast
(
window
)
-
>
IsChromeWindow
(
)
)
{
obsvc
-
>
NotifyObservers
(
window
"
widget
-
first
-
paint
"
nullptr
)
;
}
}
}
}
bool
PresShell
:
:
IsVisible
(
)
const
{
if
(
!
mIsActive
|
|
!
mViewManager
)
return
false
;
nsView
*
view
=
mViewManager
-
>
GetRootView
(
)
;
if
(
!
view
)
return
true
;
view
=
view
-
>
GetParent
(
)
;
if
(
!
view
)
return
true
;
view
=
view
-
>
GetParent
(
)
;
if
(
!
view
)
return
true
;
nsIFrame
*
frame
=
view
-
>
GetFrame
(
)
;
if
(
!
frame
)
return
true
;
return
frame
-
>
IsVisibleConsideringAncestors
(
nsIFrame
:
:
VISIBILITY_CROSS_CHROME_CONTENT_BOUNDARY
)
;
}
void
PresShell
:
:
SuppressDisplayport
(
bool
aEnabled
)
{
if
(
aEnabled
)
{
mActiveSuppressDisplayport
+
+
;
}
else
if
(
mActiveSuppressDisplayport
>
0
)
{
bool
isSuppressed
=
IsDisplayportSuppressed
(
)
;
mActiveSuppressDisplayport
-
-
;
if
(
isSuppressed
&
&
!
IsDisplayportSuppressed
(
)
)
{
if
(
nsIFrame
*
rootFrame
=
mFrameConstructor
-
>
GetRootFrame
(
)
)
{
rootFrame
-
>
SchedulePaint
(
)
;
}
}
}
}
static
bool
sDisplayPortSuppressionRespected
=
true
;
void
PresShell
:
:
RespectDisplayportSuppression
(
bool
aEnabled
)
{
bool
isSuppressed
=
IsDisplayportSuppressed
(
)
;
sDisplayPortSuppressionRespected
=
aEnabled
;
if
(
isSuppressed
&
&
!
IsDisplayportSuppressed
(
)
)
{
if
(
nsIFrame
*
rootFrame
=
mFrameConstructor
-
>
GetRootFrame
(
)
)
{
rootFrame
-
>
SchedulePaint
(
)
;
}
}
}
bool
PresShell
:
:
IsDisplayportSuppressed
(
)
{
return
sDisplayPortSuppressionRespected
&
&
mActiveSuppressDisplayport
>
0
;
}
static
CallState
FreezeSubDocument
(
Document
&
aDocument
)
{
if
(
PresShell
*
presShell
=
aDocument
.
GetPresShell
(
)
)
{
presShell
-
>
Freeze
(
)
;
}
return
CallState
:
:
Continue
;
}
void
PresShell
:
:
Freeze
(
bool
aIncludeSubDocuments
)
{
mUpdateApproximateFrameVisibilityEvent
.
Revoke
(
)
;
MaybeReleaseCapturingContent
(
)
;
if
(
mCaret
)
{
SetCaretEnabled
(
false
)
;
}
mPaintingSuppressed
=
true
;
if
(
aIncludeSubDocuments
&
&
mDocument
)
{
mDocument
-
>
EnumerateSubDocuments
(
FreezeSubDocument
)
;
}
nsPresContext
*
presContext
=
GetPresContext
(
)
;
if
(
presContext
)
{
presContext
-
>
DisableInteractionTimeRecording
(
)
;
if
(
presContext
-
>
RefreshDriver
(
)
-
>
GetPresContext
(
)
=
=
presContext
)
{
presContext
-
>
RefreshDriver
(
)
-
>
Freeze
(
)
;
}
if
(
nsPresContext
*
rootPresContext
=
presContext
-
>
GetRootPresContext
(
)
)
{
rootPresContext
-
>
ResetUserInputEventsAllowed
(
)
;
}
}
mFrozen
=
true
;
if
(
mDocument
)
{
UpdateImageLockingState
(
)
;
}
}
void
PresShell
:
:
FireOrClearDelayedEvents
(
bool
aFireEvents
)
{
mNoDelayedMouseEvents
=
false
;
mNoDelayedKeyEvents
=
false
;
if
(
!
aFireEvents
)
{
mDelayedEvents
.
Clear
(
)
;
return
;
}
if
(
mDocument
)
{
RefPtr
<
Document
>
doc
=
mDocument
;
while
(
!
mIsDestroying
&
&
mDelayedEvents
.
Length
(
)
&
&
!
doc
-
>
EventHandlingSuppressed
(
)
)
{
UniquePtr
<
DelayedEvent
>
ev
=
std
:
:
move
(
mDelayedEvents
[
0
]
)
;
mDelayedEvents
.
RemoveElementAt
(
0
)
;
if
(
ev
-
>
IsKeyPressEvent
(
)
&
&
mIsLastKeyDownCanceled
)
{
continue
;
}
ev
-
>
Dispatch
(
)
;
}
if
(
!
doc
-
>
EventHandlingSuppressed
(
)
)
{
mDelayedEvents
.
Clear
(
)
;
}
}
}
void
PresShell
:
:
Thaw
(
bool
aIncludeSubDocuments
)
{
nsPresContext
*
presContext
=
GetPresContext
(
)
;
if
(
presContext
&
&
presContext
-
>
RefreshDriver
(
)
-
>
GetPresContext
(
)
=
=
presContext
)
{
presContext
-
>
RefreshDriver
(
)
-
>
Thaw
(
)
;
}
if
(
aIncludeSubDocuments
&
&
mDocument
)
{
mDocument
-
>
EnumerateSubDocuments
(
[
]
(
Document
&
aSubDoc
)
{
if
(
PresShell
*
presShell
=
aSubDoc
.
GetPresShell
(
)
)
{
presShell
-
>
Thaw
(
)
;
}
return
CallState
:
:
Continue
;
}
)
;
}
ActivenessMaybeChanged
(
)
;
mFrozen
=
false
;
UpdateImageLockingState
(
)
;
UnsuppressPainting
(
)
;
if
(
presContext
&
&
presContext
-
>
IsRoot
(
)
)
{
if
(
!
presContext
-
>
RefreshDriver
(
)
-
>
HasPendingTick
(
)
)
{
presContext
-
>
RefreshDriver
(
)
-
>
InitializeTimer
(
)
;
}
}
}
void
PresShell
:
:
MaybeScheduleReflow
(
)
{
ASSERT_REFLOW_SCHEDULED_STATE
(
)
;
if
(
mObservingLayoutFlushes
|
|
mIsDestroying
|
|
mIsReflowing
|
|
mDirtyRoots
.
IsEmpty
(
)
)
return
;
if
(
!
mPresContext
-
>
HasPendingInterrupt
(
)
|
|
!
ScheduleReflowOffTimer
(
)
)
{
ScheduleReflow
(
)
;
}
ASSERT_REFLOW_SCHEDULED_STATE
(
)
;
}
void
PresShell
:
:
ScheduleReflow
(
)
{
ASSERT_REFLOW_SCHEDULED_STATE
(
)
;
DoObserveLayoutFlushes
(
)
;
ASSERT_REFLOW_SCHEDULED_STATE
(
)
;
}
void
PresShell
:
:
WillCauseReflow
(
)
{
nsContentUtils
:
:
AddScriptBlocker
(
)
;
+
+
mChangeNestCount
;
}
void
PresShell
:
:
DidCauseReflow
(
)
{
NS_ASSERTION
(
mChangeNestCount
!
=
0
"
Unexpected
call
to
DidCauseReflow
(
)
"
)
;
-
-
mChangeNestCount
;
nsContentUtils
:
:
RemoveScriptBlocker
(
)
;
}
void
PresShell
:
:
WillDoReflow
(
)
{
mDocument
-
>
FlushUserFontSet
(
)
;
mPresContext
-
>
FlushCounterStyles
(
)
;
mPresContext
-
>
FlushFontFeatureValues
(
)
;
mPresContext
-
>
FlushFontPaletteValues
(
)
;
mLastReflowStart
=
GetPerformanceNowUnclamped
(
)
;
}
void
PresShell
:
:
DidDoReflow
(
bool
aInterruptible
)
{
MOZ_ASSERT
(
mPendingDidDoReflow
)
;
if
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
{
SetNeedLayoutFlush
(
)
;
return
;
}
auto
clearPendingDidDoReflow
=
MakeScopeExit
(
[
&
]
{
mPendingDidDoReflow
=
false
;
}
)
;
mHiddenContentInForcedLayout
.
Clear
(
)
;
HandlePostedReflowCallbacks
(
aInterruptible
)
;
if
(
mIsDestroying
)
{
return
;
}
{
nsAutoScriptBlocker
scriptBlocker
;
AutoAssertNoFlush
noReentrantFlush
(
*
this
)
;
if
(
nsCOMPtr
<
nsIDocShell
>
docShell
=
mPresContext
-
>
GetDocShell
(
)
)
{
DOMHighResTimeStamp
now
=
GetPerformanceNowUnclamped
(
)
;
docShell
-
>
NotifyReflowObservers
(
aInterruptible
mLastReflowStart
now
)
;
}
if
(
StaticPrefs
:
:
layout_reflow_synthMouseMove
(
)
)
{
SynthesizeMouseMove
(
false
)
;
}
mPresContext
-
>
NotifyMissingFonts
(
)
;
}
if
(
mIsDestroying
)
{
return
;
}
if
(
mDirtyRoots
.
IsEmpty
(
)
)
{
if
(
mShouldUnsuppressPainting
)
{
mShouldUnsuppressPainting
=
false
;
UnsuppressAndInvalidate
(
)
;
}
}
else
{
MaybeScheduleReflow
(
)
;
SetNeedLayoutFlush
(
)
;
}
}
DOMHighResTimeStamp
PresShell
:
:
GetPerformanceNowUnclamped
(
)
{
DOMHighResTimeStamp
now
=
0
;
if
(
nsPIDOMWindowInner
*
window
=
mDocument
-
>
GetInnerWindow
(
)
)
{
Performance
*
perf
=
window
-
>
GetPerformance
(
)
;
if
(
perf
)
{
now
=
perf
-
>
NowUnclamped
(
)
;
}
}
return
now
;
}
void
PresShell
:
:
sReflowContinueCallback
(
nsITimer
*
aTimer
void
*
aPresShell
)
{
RefPtr
<
PresShell
>
self
=
static_cast
<
PresShell
*
>
(
aPresShell
)
;
MOZ_ASSERT
(
aTimer
=
=
self
-
>
mReflowContinueTimer
"
Unexpected
timer
"
)
;
self
-
>
mReflowContinueTimer
=
nullptr
;
self
-
>
ScheduleReflow
(
)
;
}
bool
PresShell
:
:
ScheduleReflowOffTimer
(
)
{
MOZ_ASSERT
(
!
mObservingLayoutFlushes
"
Shouldn
'
t
get
here
"
)
;
ASSERT_REFLOW_SCHEDULED_STATE
(
)
;
if
(
!
mReflowContinueTimer
)
{
nsresult
rv
=
NS_NewTimerWithFuncCallback
(
getter_AddRefs
(
mReflowContinueTimer
)
sReflowContinueCallback
this
30
nsITimer
:
:
TYPE_ONE_SHOT
"
sReflowContinueCallback
"
GetMainThreadSerialEventTarget
(
)
)
;
return
NS_SUCCEEDED
(
rv
)
;
}
return
true
;
}
bool
PresShell
:
:
DoReflow
(
nsIFrame
*
target
bool
aInterruptible
OverflowChangedTracker
*
aOverflowTracker
)
{
[
[
maybe_unused
]
]
nsIURI
*
uri
=
mDocument
-
>
GetDocumentURI
(
)
;
AUTO_PROFILER_LABEL_DYNAMIC_NSCSTRING_RELEVANT_FOR_JS
(
"
Reflow
"
LAYOUT_Reflow
uri
?
uri
-
>
GetSpecOrDefault
(
)
:
"
N
/
A
"
_ns
)
;
LAYOUT_TELEMETRY_RECORD_BASE
(
Reflow
)
;
PerfStats
:
:
AutoMetricRecording
<
PerfStats
:
:
Metric
:
:
Reflowing
>
autoRecording
;
gfxTextPerfMetrics
*
tp
=
mPresContext
-
>
GetTextPerfMetrics
(
)
;
TimeStamp
timeStart
;
if
(
tp
)
{
tp
-
>
Accumulate
(
)
;
tp
-
>
reflowCount
+
+
;
timeStart
=
TimeStamp
:
:
Now
(
)
;
}
target
-
>
SchedulePaint
(
nsIFrame
:
:
PAINT_DEFAULT
false
)
;
Maybe
<
uint64_t
>
innerWindowID
;
if
(
auto
*
window
=
mDocument
-
>
GetInnerWindow
(
)
)
{
innerWindowID
=
Some
(
window
-
>
WindowID
(
)
)
;
}
AutoProfilerTracing
tracingLayoutFlush
(
"
Paint
"
aInterruptible
?
"
Reflow
(
interruptible
)
"
:
"
Reflow
(
sync
)
"
geckoprofiler
:
:
category
:
:
LAYOUT
std
:
:
move
(
mReflowCause
)
innerWindowID
)
;
mReflowCause
=
nullptr
;
FlushPendingScrollAnchorSelections
(
)
;
if
(
mReflowContinueTimer
)
{
mReflowContinueTimer
-
>
Cancel
(
)
;
mReflowContinueTimer
=
nullptr
;
}
const
bool
isRoot
=
target
=
=
mFrameConstructor
-
>
GetRootFrame
(
)
;
MOZ_ASSERT
(
isRoot
|
|
aOverflowTracker
"
caller
must
provide
overflow
tracker
when
reflowing
"
"
non
-
root
frames
"
)
;
UniquePtr
<
gfxContext
>
rcx
(
CreateReferenceRenderingContext
(
)
)
;
#
ifdef
DEBUG
mCurrentReflowRoot
=
target
;
#
endif
WritingMode
wm
=
target
-
>
GetWritingMode
(
)
;
LogicalSize
size
(
wm
)
;
if
(
isRoot
)
{
size
=
LogicalSize
(
wm
mPresContext
-
>
GetVisibleArea
(
)
.
Size
(
)
)
;
}
else
{
size
=
target
-
>
GetLogicalSize
(
)
;
}
OverflowAreas
oldOverflow
;
if
(
!
isRoot
)
{
oldOverflow
=
target
-
>
GetOverflowAreas
(
)
;
}
NS_ASSERTION
(
!
target
-
>
GetNextInFlow
(
)
&
&
!
target
-
>
GetPrevInFlow
(
)
"
reflow
roots
should
never
split
"
)
;
LogicalSize
reflowSize
(
wm
size
.
ISize
(
wm
)
NS_UNCONSTRAINEDSIZE
)
;
ReflowInput
reflowInput
(
mPresContext
target
rcx
.
get
(
)
reflowSize
ReflowInput
:
:
InitFlag
:
:
CallerWillInit
)
;
reflowInput
.
mOrthogonalLimit
=
size
.
BSize
(
wm
)
;
if
(
isRoot
)
{
reflowInput
.
Init
(
mPresContext
)
;
bool
hasUnconstrainedBSize
=
size
.
BSize
(
wm
)
=
=
NS_UNCONSTRAINEDSIZE
;
if
(
hasUnconstrainedBSize
|
|
mLastRootReflowHadUnconstrainedBSize
)
{
reflowInput
.
SetBResize
(
true
)
;
}
mLastRootReflowHadUnconstrainedBSize
=
hasUnconstrainedBSize
;
}
else
{
reflowInput
.
Init
(
mPresContext
Nothing
(
)
Some
(
target
-
>
GetLogicalUsedBorder
(
wm
)
)
Some
(
target
-
>
GetLogicalUsedPadding
(
wm
)
)
)
;
}
NS_ASSERTION
(
reflowInput
.
ComputedPhysicalMargin
(
)
=
=
nsMargin
(
0
0
0
0
)
"
reflow
input
should
not
set
margin
for
reflow
roots
"
)
;
if
(
size
.
BSize
(
wm
)
!
=
NS_UNCONSTRAINEDSIZE
)
{
nscoord
computedBSize
=
size
.
BSize
(
wm
)
-
reflowInput
.
ComputedLogicalBorderPadding
(
wm
)
.
BStartEnd
(
wm
)
;
computedBSize
=
std
:
:
max
(
computedBSize
0
)
;
reflowInput
.
SetComputedBSize
(
computedBSize
)
;
}
NS_ASSERTION
(
reflowInput
.
ComputedISize
(
)
=
=
size
.
ISize
(
wm
)
-
reflowInput
.
ComputedLogicalBorderPadding
(
wm
)
.
IStartEnd
(
wm
)
"
reflow
input
computed
incorrect
inline
size
"
)
;
mPresContext
-
>
ReflowStarted
(
aInterruptible
)
;
mIsReflowing
=
true
;
nsReflowStatus
status
;
ReflowOutput
desiredSize
(
reflowInput
)
;
target
-
>
Reflow
(
mPresContext
desiredSize
reflowInput
status
)
;
nsRect
boundsRelativeToTarget
=
nsRect
(
0
0
desiredSize
.
Width
(
)
desiredSize
.
Height
(
)
)
;
const
bool
isBSizeLimitReflow
=
isRoot
&
&
size
.
BSize
(
wm
)
=
=
NS_UNCONSTRAINEDSIZE
;
NS_ASSERTION
(
isBSizeLimitReflow
|
|
desiredSize
.
Size
(
wm
)
=
=
size
"
non
-
root
frame
'
s
desired
size
changed
during
an
"
"
incremental
reflow
"
)
;
NS_ASSERTION
(
status
.
IsEmpty
(
)
"
reflow
roots
should
never
split
"
)
;
target
-
>
SetSize
(
boundsRelativeToTarget
.
Size
(
)
)
;
if
(
target
-
>
HasView
(
)
)
{
nsContainerFrame
:
:
SyncFrameViewAfterReflow
(
mPresContext
target
target
-
>
GetView
(
)
boundsRelativeToTarget
)
;
if
(
target
-
>
IsViewportFrame
(
)
)
{
SyncWindowProperties
(
false
)
;
}
}
target
-
>
DidReflow
(
mPresContext
nullptr
)
;
if
(
target
-
>
IsInScrollAnchorChain
(
)
)
{
ScrollAnchorContainer
*
container
=
ScrollAnchorContainer
:
:
FindFor
(
target
)
;
PostPendingScrollAnchorAdjustment
(
container
)
;
}
if
(
MOZ_UNLIKELY
(
isBSizeLimitReflow
)
)
{
mPresContext
-
>
SetVisibleArea
(
boundsRelativeToTarget
)
;
}
#
ifdef
DEBUG
mCurrentReflowRoot
=
nullptr
;
#
endif
if
(
!
isRoot
&
&
oldOverflow
!
=
target
-
>
GetOverflowAreas
(
)
)
{
aOverflowTracker
-
>
AddFrame
(
target
-
>
GetParent
(
)
OverflowChangedTracker
:
:
CHILDREN_CHANGED
)
;
}
NS_ASSERTION
(
mPresContext
-
>
HasPendingInterrupt
(
)
|
|
mFramesToDirty
.
Count
(
)
=
=
0
"
Why
do
we
need
to
dirty
anything
if
not
interrupted
?
"
)
;
mIsReflowing
=
false
;
bool
interrupted
=
mPresContext
-
>
HasPendingInterrupt
(
)
;
if
(
interrupted
)
{
for
(
const
auto
&
key
:
mFramesToDirty
)
{
for
(
nsIFrame
*
f
=
key
;
f
&
&
!
f
-
>
IsSubtreeDirty
(
)
;
f
=
f
-
>
GetParent
(
)
)
{
f
-
>
AddStateBits
(
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
if
(
f
-
>
IsFlexItem
(
)
)
{
nsFlexContainerFrame
:
:
MarkCachedFlexMeasurementsDirty
(
f
)
;
}
if
(
f
=
=
target
)
{
break
;
}
}
}
NS_ASSERTION
(
target
-
>
IsSubtreeDirty
(
)
"
Why
is
the
target
not
dirty
?
"
)
;
mDirtyRoots
.
Add
(
target
)
;
SetNeedLayoutFlush
(
)
;
#
ifdef
NOISY_INTERRUPTIBLE_REFLOW
printf
(
"
mFramesToDirty
.
Count
(
)
=
=
%
u
\
n
"
mFramesToDirty
.
Count
(
)
)
;
#
endif
mFramesToDirty
.
Clear
(
)
;
mWasLastReflowInterrupted
=
true
;
MaybeScheduleReflow
(
)
;
}
if
(
tp
)
{
if
(
tp
-
>
current
.
numChars
>
100
)
{
TimeDuration
reflowTime
=
TimeStamp
:
:
Now
(
)
-
timeStart
;
LogTextPerfStats
(
tp
this
tp
-
>
current
reflowTime
.
ToMilliseconds
(
)
eLog_reflow
nullptr
)
;
}
tp
-
>
Accumulate
(
)
;
}
return
!
interrupted
;
}
#
ifdef
DEBUG
void
PresShell
:
:
DoVerifyReflow
(
)
{
if
(
GetVerifyReflowEnable
(
)
)
{
nsView
*
rootView
=
mViewManager
-
>
GetRootView
(
)
;
mViewManager
-
>
InvalidateView
(
rootView
)
;
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
mInVerifyReflow
=
true
;
bool
ok
=
VerifyIncrementalReflow
(
)
;
mInVerifyReflow
=
false
;
if
(
VerifyReflowFlags
:
:
All
&
gVerifyReflowFlags
)
{
printf
(
"
ProcessReflowCommands
:
finished
(
%
s
)
\
n
"
ok
?
"
ok
"
:
"
failed
"
)
;
}
if
(
!
mDirtyRoots
.
IsEmpty
(
)
)
{
printf
(
"
XXX
yikes
!
reflow
commands
queued
during
verify
-
reflow
\
n
"
)
;
}
}
}
#
endif
#
define
NS_LONG_REFLOW_TIME_MS
5000
bool
PresShell
:
:
ProcessReflowCommands
(
bool
aInterruptible
)
{
if
(
mDirtyRoots
.
IsEmpty
(
)
&
&
!
mShouldUnsuppressPainting
&
&
!
mPendingDidDoReflow
)
{
return
true
;
}
const
bool
wasProcessingReflowCommands
=
mProcessingReflowCommands
;
auto
restoreProcessingReflowCommands
=
MakeScopeExit
(
[
&
]
{
mProcessingReflowCommands
=
wasProcessingReflowCommands
;
}
)
;
mProcessingReflowCommands
=
true
;
auto
timerStart
=
mozilla
:
:
TimeStamp
:
:
Now
(
)
;
bool
interrupted
=
false
;
if
(
!
mDirtyRoots
.
IsEmpty
(
)
)
{
#
ifdef
DEBUG
if
(
VerifyReflowFlags
:
:
DumpCommands
&
gVerifyReflowFlags
)
{
printf
(
"
ProcessReflowCommands
:
begin
incremental
reflow
\
n
"
)
;
}
#
endif
const
PRIntervalTime
deadline
=
aInterruptible
?
PR_IntervalNow
(
)
+
PR_MicrosecondsToInterval
(
gMaxRCProcessingTime
)
:
(
PRIntervalTime
)
0
;
nsAutoScriptBlocker
scriptBlocker
;
WillDoReflow
(
)
;
AUTO_LAYOUT_PHASE_ENTRY_POINT
(
GetPresContext
(
)
Reflow
)
;
nsViewManager
:
:
AutoDisableRefresh
refreshBlocker
(
mViewManager
)
;
OverflowChangedTracker
overflowTracker
;
do
{
nsIFrame
*
target
=
mDirtyRoots
.
PopShallowestRoot
(
)
;
if
(
!
target
-
>
IsSubtreeDirty
(
)
)
{
continue
;
}
interrupted
=
!
DoReflow
(
target
aInterruptible
&
overflowTracker
)
;
}
while
(
!
interrupted
&
&
!
mDirtyRoots
.
IsEmpty
(
)
&
&
(
!
aInterruptible
|
|
PR_IntervalNow
(
)
<
deadline
)
)
;
interrupted
=
!
mDirtyRoots
.
IsEmpty
(
)
;
overflowTracker
.
Flush
(
)
;
if
(
!
interrupted
)
{
FlushPendingScrollAnchorAdjustments
(
)
;
}
mPendingDidDoReflow
=
true
;
}
if
(
!
mIsDestroying
&
&
mPendingDidDoReflow
&
&
!
wasProcessingReflowCommands
)
{
DidDoReflow
(
aInterruptible
)
;
}
#
ifdef
DEBUG
if
(
VerifyReflowFlags
:
:
DumpCommands
&
gVerifyReflowFlags
)
{
printf
(
"
\
nPresShell
:
:
ProcessReflowCommands
(
)
finished
:
this
=
%
p
\
n
"
(
void
*
)
this
)
;
}
DoVerifyReflow
(
)
;
#
endif
{
TimeDuration
elapsed
=
TimeStamp
:
:
Now
(
)
-
timerStart
;
int32_t
intElapsed
=
int32_t
(
elapsed
.
ToMilliseconds
(
)
)
;
if
(
intElapsed
>
NS_LONG_REFLOW_TIME_MS
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
LONG_REFLOW_INTERRUPTIBLE
aInterruptible
?
1
:
0
)
;
}
}
return
!
interrupted
;
}
bool
PresShell
:
:
DoFlushLayout
(
bool
aInterruptible
)
{
mFrameConstructor
-
>
RecalcQuotesAndCounters
(
)
;
return
ProcessReflowCommands
(
aInterruptible
)
;
}
void
PresShell
:
:
WindowSizeMoveDone
(
)
{
if
(
mPresContext
)
{
EventStateManager
:
:
ClearGlobalActiveContent
(
nullptr
)
;
ClearMouseCapture
(
)
;
}
}
NS_IMETHODIMP
PresShell
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
mIsDestroying
)
{
NS_WARNING
(
"
our
observers
should
have
been
unregistered
by
now
"
)
;
return
NS_OK
;
}
if
(
!
nsCRT
:
:
strcmp
(
aTopic
"
memory
-
pressure
"
)
)
{
if
(
!
AssumeAllFramesVisible
(
)
&
&
mPresContext
-
>
IsRootContentDocumentInProcess
(
)
)
{
DoUpdateApproximateFrameVisibility
(
true
)
;
}
return
NS_OK
;
}
if
(
!
nsCRT
:
:
strcmp
(
aTopic
NS_WIDGET_WAKE_OBSERVER_TOPIC
)
)
{
mLastOSWake
=
TimeStamp
:
:
Now
(
)
;
return
NS_OK
;
}
if
(
!
nsCRT
:
:
strcmp
(
aTopic
"
sessionstore
-
one
-
or
-
no
-
tab
-
restored
"
)
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
sProcessInteractable
=
true
;
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
os
-
>
RemoveObserver
(
this
"
sessionstore
-
one
-
or
-
no
-
tab
-
restored
"
)
;
}
return
NS_OK
;
}
if
(
!
nsCRT
:
:
strcmp
(
aTopic
"
font
-
info
-
updated
"
)
)
{
bool
needsReframe
=
aData
&
&
!
!
aData
[
0
]
;
mPresContext
-
>
ForceReflowForFontInfoUpdate
(
needsReframe
)
;
return
NS_OK
;
}
if
(
!
nsCRT
:
:
strcmp
(
aTopic
"
internal
-
look
-
and
-
feel
-
changed
"
)
)
{
auto
kind
=
widget
:
:
ThemeChangeKind
(
aData
[
0
]
)
;
mPresContext
-
>
ThemeChanged
(
kind
)
;
return
NS_OK
;
}
NS_WARNING
(
"
unrecognized
topic
in
PresShell
:
:
Observe
"
)
;
return
NS_ERROR_FAILURE
;
}
bool
PresShell
:
:
AddRefreshObserver
(
nsARefreshObserver
*
aObserver
FlushType
aFlushType
const
char
*
aObserverDescription
)
{
nsPresContext
*
presContext
=
GetPresContext
(
)
;
if
(
MOZ_UNLIKELY
(
!
presContext
)
)
{
return
false
;
}
presContext
-
>
RefreshDriver
(
)
-
>
AddRefreshObserver
(
aObserver
aFlushType
aObserverDescription
)
;
return
true
;
}
bool
PresShell
:
:
RemoveRefreshObserver
(
nsARefreshObserver
*
aObserver
FlushType
aFlushType
)
{
nsPresContext
*
presContext
=
GetPresContext
(
)
;
return
presContext
&
&
presContext
-
>
RefreshDriver
(
)
-
>
RemoveRefreshObserver
(
aObserver
aFlushType
)
;
}
bool
PresShell
:
:
AddPostRefreshObserver
(
nsAPostRefreshObserver
*
aObserver
)
{
nsPresContext
*
presContext
=
GetPresContext
(
)
;
if
(
!
presContext
)
{
return
false
;
}
presContext
-
>
RefreshDriver
(
)
-
>
AddPostRefreshObserver
(
aObserver
)
;
return
true
;
}
bool
PresShell
:
:
RemovePostRefreshObserver
(
nsAPostRefreshObserver
*
aObserver
)
{
nsPresContext
*
presContext
=
GetPresContext
(
)
;
if
(
!
presContext
)
{
return
false
;
}
presContext
-
>
RefreshDriver
(
)
-
>
RemovePostRefreshObserver
(
aObserver
)
;
return
true
;
}
void
PresShell
:
:
DoObserveStyleFlushes
(
)
{
MOZ_ASSERT
(
!
ObservingStyleFlushes
(
)
)
;
mObservingStyleFlushes
=
true
;
if
(
MOZ_LIKELY
(
!
mDocument
-
>
GetBFCacheEntry
(
)
)
)
{
mPresContext
-
>
RefreshDriver
(
)
-
>
AddStyleFlushObserver
(
this
)
;
}
}
void
PresShell
:
:
DoObserveLayoutFlushes
(
)
{
MOZ_ASSERT
(
!
ObservingLayoutFlushes
(
)
)
;
mObservingLayoutFlushes
=
true
;
if
(
MOZ_LIKELY
(
!
mDocument
-
>
GetBFCacheEntry
(
)
)
)
{
mPresContext
-
>
RefreshDriver
(
)
-
>
AddLayoutFlushObserver
(
this
)
;
}
}
PresShell
:
:
DelayedInputEvent
:
:
DelayedInputEvent
(
)
:
DelayedEvent
(
)
mEvent
(
nullptr
)
{
}
PresShell
:
:
DelayedInputEvent
:
:
~
DelayedInputEvent
(
)
{
delete
mEvent
;
}
void
PresShell
:
:
DelayedInputEvent
:
:
Dispatch
(
)
{
if
(
!
mEvent
|
|
!
mEvent
-
>
mWidget
)
{
return
;
}
nsCOMPtr
<
nsIWidget
>
widget
=
mEvent
-
>
mWidget
;
nsEventStatus
status
;
widget
-
>
DispatchEvent
(
mEvent
status
)
;
}
PresShell
:
:
DelayedMouseEvent
:
:
DelayedMouseEvent
(
WidgetMouseEvent
*
aEvent
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aEvent
-
>
IsTrusted
(
)
)
;
WidgetMouseEvent
*
mouseEvent
=
new
WidgetMouseEvent
(
true
aEvent
-
>
mMessage
aEvent
-
>
mWidget
aEvent
-
>
mReason
aEvent
-
>
mContextMenuTrigger
)
;
mouseEvent
-
>
AssignMouseEventData
(
*
aEvent
false
)
;
mEvent
=
mouseEvent
;
}
PresShell
:
:
DelayedKeyEvent
:
:
DelayedKeyEvent
(
WidgetKeyboardEvent
*
aEvent
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aEvent
-
>
IsTrusted
(
)
)
;
WidgetKeyboardEvent
*
keyEvent
=
new
WidgetKeyboardEvent
(
true
aEvent
-
>
mMessage
aEvent
-
>
mWidget
)
;
keyEvent
-
>
AssignKeyEventData
(
*
aEvent
false
)
;
keyEvent
-
>
mFlags
.
mIsSynthesizedForTests
=
aEvent
-
>
mFlags
.
mIsSynthesizedForTests
;
keyEvent
-
>
mFlags
.
mIsSuppressedOrDelayed
=
true
;
mEvent
=
keyEvent
;
}
bool
PresShell
:
:
DelayedKeyEvent
:
:
IsKeyPressEvent
(
)
{
return
mEvent
-
>
mMessage
=
=
eKeyPress
;
}
#
ifdef
DEBUG
static
void
LogVerifyMessage
(
nsIFrame
*
k1
nsIFrame
*
k2
const
char
*
aMsg
)
{
nsAutoString
n1
n2
;
if
(
k1
)
{
k1
-
>
GetFrameName
(
n1
)
;
}
else
{
n1
.
AssignLiteral
(
u
"
(
null
)
"
)
;
}
if
(
k2
)
{
k2
-
>
GetFrameName
(
n2
)
;
}
else
{
n2
.
AssignLiteral
(
u
"
(
null
)
"
)
;
}
printf
(
"
verifyreflow
:
%
s
%
p
!
=
%
s
%
p
%
s
\
n
"
NS_LossyConvertUTF16toASCII
(
n1
)
.
get
(
)
(
void
*
)
k1
NS_LossyConvertUTF16toASCII
(
n2
)
.
get
(
)
(
void
*
)
k2
aMsg
)
;
}
static
void
LogVerifyMessage
(
nsIFrame
*
k1
nsIFrame
*
k2
const
char
*
aMsg
const
nsRect
&
r1
const
nsRect
&
r2
)
{
printf
(
"
VerifyReflow
Error
:
\
n
"
)
;
nsAutoString
name
;
if
(
k1
)
{
k1
-
>
GetFrameName
(
name
)
;
printf
(
"
%
s
%
p
"
NS_LossyConvertUTF16toASCII
(
name
)
.
get
(
)
(
void
*
)
k1
)
;
}
printf
(
"
{
%
d
%
d
%
d
%
d
}
!
=
\
n
"
r1
.
x
r1
.
y
r1
.
width
r1
.
height
)
;
if
(
k2
)
{
k2
-
>
GetFrameName
(
name
)
;
printf
(
"
%
s
%
p
"
NS_LossyConvertUTF16toASCII
(
name
)
.
get
(
)
(
void
*
)
k2
)
;
}
printf
(
"
{
%
d
%
d
%
d
%
d
}
\
n
%
s
\
n
"
r2
.
x
r2
.
y
r2
.
width
r2
.
height
aMsg
)
;
}
static
void
LogVerifyMessage
(
nsIFrame
*
k1
nsIFrame
*
k2
const
char
*
aMsg
const
nsIntRect
&
r1
const
nsIntRect
&
r2
)
{
printf
(
"
VerifyReflow
Error
:
\
n
"
)
;
nsAutoString
name
;
if
(
k1
)
{
k1
-
>
GetFrameName
(
name
)
;
printf
(
"
%
s
%
p
"
NS_LossyConvertUTF16toASCII
(
name
)
.
get
(
)
(
void
*
)
k1
)
;
}
printf
(
"
{
%
d
%
d
%
d
%
d
}
!
=
\
n
"
r1
.
x
r1
.
y
r1
.
width
r1
.
height
)
;
if
(
k2
)
{
k2
-
>
GetFrameName
(
name
)
;
printf
(
"
%
s
%
p
"
NS_LossyConvertUTF16toASCII
(
name
)
.
get
(
)
(
void
*
)
k2
)
;
}
printf
(
"
{
%
d
%
d
%
d
%
d
}
\
n
%
s
\
n
"
r2
.
x
r2
.
y
r2
.
width
r2
.
height
aMsg
)
;
}
static
bool
CompareTrees
(
nsPresContext
*
aFirstPresContext
nsIFrame
*
aFirstFrame
nsPresContext
*
aSecondPresContext
nsIFrame
*
aSecondFrame
)
{
if
(
!
aFirstPresContext
|
|
!
aFirstFrame
|
|
!
aSecondPresContext
|
|
!
aSecondFrame
)
return
true
;
bool
ok
=
true
;
const
auto
&
childLists1
=
aFirstFrame
-
>
ChildLists
(
)
;
const
auto
&
childLists2
=
aSecondFrame
-
>
ChildLists
(
)
;
auto
iterLists1
=
childLists1
.
begin
(
)
;
auto
iterLists2
=
childLists2
.
begin
(
)
;
do
{
const
nsFrameList
&
kids1
=
iterLists1
!
=
childLists1
.
end
(
)
?
iterLists1
-
>
mList
:
nsFrameList
:
:
EmptyList
(
)
;
const
nsFrameList
&
kids2
=
iterLists2
!
=
childLists2
.
end
(
)
?
iterLists2
-
>
mList
:
nsFrameList
:
:
EmptyList
(
)
;
int32_t
l1
=
kids1
.
GetLength
(
)
;
int32_t
l2
=
kids2
.
GetLength
(
)
;
if
(
l1
!
=
l2
)
{
ok
=
false
;
LogVerifyMessage
(
kids1
.
FirstChild
(
)
kids2
.
FirstChild
(
)
"
child
counts
don
'
t
match
:
"
)
;
printf
(
"
%
d
!
=
%
d
\
n
"
l1
l2
)
;
if
(
!
(
VerifyReflowFlags
:
:
All
&
gVerifyReflowFlags
)
)
{
break
;
}
}
LayoutDeviceIntRect
r1
r2
;
nsView
*
v1
;
nsView
*
v2
;
for
(
auto
kids1Iter
=
kids1
.
begin
(
)
kids2Iter
=
kids2
.
begin
(
)
;
;
+
+
kids1Iter
+
+
kids2Iter
)
{
nsIFrame
*
k1
=
*
kids1Iter
;
nsIFrame
*
k2
=
*
kids2Iter
;
if
(
(
(
nullptr
=
=
k1
)
&
&
(
nullptr
!
=
k2
)
)
|
|
(
(
nullptr
!
=
k1
)
&
&
(
nullptr
=
=
k2
)
)
)
{
ok
=
false
;
LogVerifyMessage
(
k1
k2
"
child
lists
are
different
\
n
"
)
;
break
;
}
else
if
(
nullptr
!
=
k1
)
{
if
(
!
k1
-
>
GetRect
(
)
.
IsEqualInterior
(
k2
-
>
GetRect
(
)
)
)
{
ok
=
false
;
LogVerifyMessage
(
k1
k2
"
(
frame
rects
)
"
k1
-
>
GetRect
(
)
k2
-
>
GetRect
(
)
)
;
}
v1
=
k1
-
>
GetView
(
)
;
v2
=
k2
-
>
GetView
(
)
;
if
(
(
(
nullptr
=
=
v1
)
&
&
(
nullptr
!
=
v2
)
)
|
|
(
(
nullptr
!
=
v1
)
&
&
(
nullptr
=
=
v2
)
)
)
{
ok
=
false
;
LogVerifyMessage
(
k1
k2
"
child
views
are
not
matched
\
n
"
)
;
}
else
if
(
nullptr
!
=
v1
)
{
if
(
!
v1
-
>
GetBounds
(
)
.
IsEqualInterior
(
v2
-
>
GetBounds
(
)
)
)
{
LogVerifyMessage
(
k1
k2
"
(
view
rects
)
"
v1
-
>
GetBounds
(
)
v2
-
>
GetBounds
(
)
)
;
}
nsIWidget
*
w1
=
v1
-
>
GetWidget
(
)
;
nsIWidget
*
w2
=
v2
-
>
GetWidget
(
)
;
if
(
(
(
nullptr
=
=
w1
)
&
&
(
nullptr
!
=
w2
)
)
|
|
(
(
nullptr
!
=
w1
)
&
&
(
nullptr
=
=
w2
)
)
)
{
ok
=
false
;
LogVerifyMessage
(
k1
k2
"
child
widgets
are
not
matched
\
n
"
)
;
}
else
if
(
nullptr
!
=
w1
)
{
r1
=
w1
-
>
GetBounds
(
)
;
r2
=
w2
-
>
GetBounds
(
)
;
if
(
!
r1
.
IsEqualEdges
(
r2
)
)
{
LogVerifyMessage
(
k1
k2
"
(
widget
rects
)
"
r1
.
ToUnknownRect
(
)
r2
.
ToUnknownRect
(
)
)
;
}
}
}
if
(
!
ok
&
&
!
(
VerifyReflowFlags
:
:
All
&
gVerifyReflowFlags
)
)
{
break
;
}
if
(
!
CompareTrees
(
aFirstPresContext
k1
aSecondPresContext
k2
)
)
{
ok
=
false
;
if
(
!
(
VerifyReflowFlags
:
:
All
&
gVerifyReflowFlags
)
)
{
break
;
}
}
}
else
{
break
;
}
}
if
(
!
ok
&
&
(
!
(
VerifyReflowFlags
:
:
All
&
gVerifyReflowFlags
)
)
)
{
break
;
}
+
+
iterLists1
;
+
+
iterLists2
;
const
bool
lists1Done
=
iterLists1
=
=
childLists1
.
end
(
)
;
const
bool
lists2Done
=
iterLists2
=
=
childLists2
.
end
(
)
;
if
(
lists1Done
!
=
lists2Done
|
|
(
!
lists1Done
&
&
iterLists1
-
>
mID
!
=
iterLists2
-
>
mID
)
)
{
if
(
!
(
VerifyReflowFlags
:
:
All
&
gVerifyReflowFlags
)
)
{
ok
=
false
;
}
LogVerifyMessage
(
kids1
.
FirstChild
(
)
kids2
.
FirstChild
(
)
"
child
list
names
are
not
matched
:
"
)
;
fprintf
(
stdout
"
%
s
!
=
%
s
\
n
"
!
lists1Done
?
ChildListName
(
iterLists1
-
>
mID
)
:
"
(
null
)
"
!
lists2Done
?
ChildListName
(
iterLists2
-
>
mID
)
:
"
(
null
)
"
)
;
break
;
}
}
while
(
ok
&
&
iterLists1
!
=
childLists1
.
end
(
)
)
;
return
ok
;
}
#
endif
#
if
0
static
nsIFrame
*
FindTopFrame
(
nsIFrame
*
aRoot
)
{
if
(
aRoot
)
{
nsIContent
*
content
=
aRoot
-
>
GetContent
(
)
;
if
(
content
)
{
nsAtom
*
tag
;
content
-
>
GetTag
(
tag
)
;
if
(
nullptr
!
=
tag
)
{
NS_RELEASE
(
tag
)
;
return
aRoot
;
}
}
for
(
nsIFrame
*
kid
:
aRoot
-
>
PrincipalChildList
(
)
)
{
nsIFrame
*
result
=
FindTopFrame
(
kid
)
;
if
(
nullptr
!
=
result
)
{
return
result
;
}
}
}
return
nullptr
;
}
#
endif
#
ifdef
DEBUG
bool
PresShell
:
:
VerifyIncrementalReflow
(
)
{
if
(
VerifyReflowFlags
:
:
Noisy
&
gVerifyReflowFlags
)
{
printf
(
"
Building
Verification
Tree
.
.
.
\
n
"
)
;
}
RefPtr
<
nsPresContext
>
cx
=
new
nsRootPresContext
(
mDocument
mPresContext
-
>
IsPaginated
(
)
?
nsPresContext
:
:
eContext_PrintPreview
:
nsPresContext
:
:
eContext_Galley
)
;
NS_ENSURE_TRUE
(
cx
false
)
;
nsDeviceContext
*
dc
=
mPresContext
-
>
DeviceContext
(
)
;
nsresult
rv
=
cx
-
>
Init
(
dc
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
nsView
*
rootView
=
mViewManager
-
>
GetRootView
(
)
;
NS_ENSURE_TRUE
(
rootView
-
>
HasWidget
(
)
false
)
;
nsIWidget
*
parentWidget
=
rootView
-
>
GetWidget
(
)
;
RefPtr
<
nsViewManager
>
vm
=
new
nsViewManager
(
)
;
NS_ENSURE_TRUE
(
vm
false
)
;
rv
=
vm
-
>
Init
(
dc
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
nsRect
tbounds
=
mPresContext
-
>
GetVisibleArea
(
)
;
nsView
*
view
=
vm
-
>
CreateView
(
tbounds
nullptr
)
;
NS_ENSURE_TRUE
(
view
false
)
;
rv
=
view
-
>
CreateWidgetForParent
(
parentWidget
nullptr
true
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
vm
-
>
SetRootView
(
view
)
;
cx
-
>
SetVisibleArea
(
mPresContext
-
>
GetVisibleArea
(
)
)
;
RefPtr
<
PresShell
>
presShell
=
mDocument
-
>
CreatePresShell
(
cx
vm
)
;
NS_ENSURE_TRUE
(
presShell
false
)
;
presShell
-
>
SetVerifyReflowEnable
(
false
)
;
vm
-
>
SetPresShell
(
presShell
)
;
{
nsAutoCauseReflowNotifier
crNotifier
(
this
)
;
presShell
-
>
Initialize
(
)
;
}
presShell
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
presShell
-
>
SetVerifyReflowEnable
(
true
)
;
presShell
-
>
mPaintingSuppressed
=
false
;
if
(
VerifyReflowFlags
:
:
Noisy
&
gVerifyReflowFlags
)
{
printf
(
"
Verification
Tree
built
comparing
.
.
.
\
n
"
)
;
}
nsIFrame
*
root1
=
mFrameConstructor
-
>
GetRootFrame
(
)
;
nsIFrame
*
root2
=
presShell
-
>
GetRootFrame
(
)
;
bool
ok
=
CompareTrees
(
mPresContext
root1
cx
root2
)
;
if
(
!
ok
&
&
(
VerifyReflowFlags
:
:
Noisy
&
gVerifyReflowFlags
)
)
{
printf
(
"
Verify
reflow
failed
primary
tree
:
\
n
"
)
;
root1
-
>
List
(
stdout
)
;
printf
(
"
Verification
tree
:
\
n
"
)
;
root2
-
>
List
(
stdout
)
;
}
#
if
0
if
(
!
ok
)
{
nsString
stra
;
static
int
num
=
0
;
stra
.
AppendLiteral
(
"
C
:
\
\
mozilla
\
\
mozilla
\
\
debug
\
\
filea
"
)
;
stra
.
AppendInt
(
num
)
;
stra
.
AppendLiteral
(
"
.
png
"
)
;
gfxUtils
:
:
WriteAsPNG
(
presShell
stra
)
;
nsString
strb
;
strb
.
AppendLiteral
(
"
C
:
\
\
mozilla
\
\
mozilla
\
\
debug
\
\
fileb
"
)
;
strb
.
AppendInt
(
num
)
;
strb
.
AppendLiteral
(
"
.
png
"
)
;
gfxUtils
:
:
WriteAsPNG
(
presShell
strb
)
;
+
+
num
;
}
#
endif
presShell
-
>
EndObservingDocument
(
)
;
presShell
-
>
Destroy
(
)
;
if
(
VerifyReflowFlags
:
:
Noisy
&
gVerifyReflowFlags
)
{
printf
(
"
Finished
Verifying
Reflow
.
.
.
\
n
"
)
;
}
return
ok
;
}
void
PresShell
:
:
ListComputedStyles
(
FILE
*
out
int32_t
aIndent
)
{
nsIFrame
*
rootFrame
=
GetRootFrame
(
)
;
if
(
rootFrame
)
{
rootFrame
-
>
Style
(
)
-
>
List
(
out
aIndent
)
;
}
Element
*
rootElement
=
mDocument
-
>
GetRootElement
(
)
;
if
(
rootElement
)
{
nsIFrame
*
rootElementFrame
=
rootElement
-
>
GetPrimaryFrame
(
)
;
if
(
rootElementFrame
)
{
rootElementFrame
-
>
Style
(
)
-
>
List
(
out
aIndent
)
;
}
}
}
#
endif
#
if
defined
(
DEBUG
)
|
|
defined
(
MOZ_LAYOUT_DEBUGGER
)
void
PresShell
:
:
ListStyleSheets
(
FILE
*
out
int32_t
aIndent
)
{
auto
ListStyleSheetsAtOrigin
=
[
this
out
aIndent
]
(
StyleOrigin
origin
)
{
int32_t
sheetCount
=
StyleSet
(
)
-
>
SheetCount
(
origin
)
;
for
(
int32_t
i
=
0
;
i
<
sheetCount
;
+
+
i
)
{
StyleSet
(
)
-
>
SheetAt
(
origin
i
)
-
>
List
(
out
aIndent
)
;
}
}
;
ListStyleSheetsAtOrigin
(
StyleOrigin
:
:
UserAgent
)
;
ListStyleSheetsAtOrigin
(
StyleOrigin
:
:
User
)
;
ListStyleSheetsAtOrigin
(
StyleOrigin
:
:
Author
)
;
}
#
endif
#
ifdef
MOZ_REFLOW_PERF
void
PresShell
:
:
DumpReflows
(
)
{
if
(
mReflowCountMgr
)
{
nsAutoCString
uriStr
;
if
(
mDocument
)
{
nsIURI
*
uri
=
mDocument
-
>
GetDocumentURI
(
)
;
if
(
uri
)
{
uri
-
>
GetPathQueryRef
(
uriStr
)
;
}
}
mReflowCountMgr
-
>
DisplayTotals
(
uriStr
.
get
(
)
)
;
mReflowCountMgr
-
>
DisplayHTMLTotals
(
uriStr
.
get
(
)
)
;
mReflowCountMgr
-
>
DisplayDiffsInTotals
(
)
;
}
}
void
PresShell
:
:
CountReflows
(
const
char
*
aName
nsIFrame
*
aFrame
)
{
if
(
mReflowCountMgr
)
{
mReflowCountMgr
-
>
Add
(
aName
aFrame
)
;
}
}
void
PresShell
:
:
PaintCount
(
const
char
*
aName
gfxContext
*
aRenderingContext
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
const
nsPoint
&
aOffset
uint32_t
aColor
)
{
if
(
mReflowCountMgr
)
{
mReflowCountMgr
-
>
PaintCount
(
aName
aRenderingContext
aPresContext
aFrame
aOffset
aColor
)
;
}
}
void
PresShell
:
:
SetPaintFrameCount
(
bool
aPaintFrameCounts
)
{
if
(
mReflowCountMgr
)
{
mReflowCountMgr
-
>
SetPaintFrameCounts
(
aPaintFrameCounts
)
;
}
}
bool
PresShell
:
:
IsPaintingFrameCounts
(
)
{
if
(
mReflowCountMgr
)
return
mReflowCountMgr
-
>
IsPaintingFrameCounts
(
)
;
return
false
;
}
ReflowCounter
:
:
ReflowCounter
(
ReflowCountMgr
*
aMgr
)
:
mMgr
(
aMgr
)
{
ClearTotals
(
)
;
SetTotalsCache
(
)
;
}
ReflowCounter
:
:
~
ReflowCounter
(
)
=
default
;
void
ReflowCounter
:
:
ClearTotals
(
)
{
mTotal
=
0
;
}
void
ReflowCounter
:
:
SetTotalsCache
(
)
{
mCacheTotal
=
mTotal
;
}
void
ReflowCounter
:
:
CalcDiffInTotals
(
)
{
mCacheTotal
=
mTotal
-
mCacheTotal
;
}
void
ReflowCounter
:
:
DisplayTotals
(
const
char
*
aStr
)
{
DisplayTotals
(
mTotal
aStr
?
aStr
:
"
Totals
"
)
;
}
void
ReflowCounter
:
:
DisplayDiffTotals
(
const
char
*
aStr
)
{
DisplayTotals
(
mCacheTotal
aStr
?
aStr
:
"
Diff
Totals
"
)
;
}
void
ReflowCounter
:
:
DisplayHTMLTotals
(
const
char
*
aStr
)
{
DisplayHTMLTotals
(
mTotal
aStr
?
aStr
:
"
Totals
"
)
;
}
void
ReflowCounter
:
:
DisplayTotals
(
uint32_t
aTotal
const
char
*
aTitle
)
{
if
(
aTotal
=
=
0
)
{
return
;
}
ReflowCounter
*
gTots
=
(
ReflowCounter
*
)
mMgr
-
>
LookUp
(
kGrandTotalsStr
)
;
printf
(
"
%
25s
\
t
"
aTitle
)
;
printf
(
"
%
d
\
t
"
aTotal
)
;
if
(
gTots
!
=
this
&
&
aTotal
>
0
)
{
gTots
-
>
Add
(
aTotal
)
;
}
}
void
ReflowCounter
:
:
DisplayHTMLTotals
(
uint32_t
aTotal
const
char
*
aTitle
)
{
if
(
aTotal
=
=
0
)
{
return
;
}
ReflowCounter
*
gTots
=
(
ReflowCounter
*
)
mMgr
-
>
LookUp
(
kGrandTotalsStr
)
;
FILE
*
fd
=
mMgr
-
>
GetOutFile
(
)
;
if
(
!
fd
)
{
return
;
}
fprintf
(
fd
"
<
tr
>
<
td
>
<
center
>
%
s
<
/
center
>
<
/
td
>
"
aTitle
)
;
fprintf
(
fd
"
<
td
>
<
center
>
%
d
<
/
center
>
<
/
td
>
<
/
tr
>
\
n
"
aTotal
)
;
if
(
gTots
!
=
this
&
&
aTotal
>
0
)
{
gTots
-
>
Add
(
aTotal
)
;
}
}
#
define
KEY_BUF_SIZE_FOR_PTR
\
24
/
/
adequate
char
[
]
buffer
to
sprintf
a
pointer
ReflowCountMgr
:
:
ReflowCountMgr
(
)
:
mCounts
(
10
)
mIndiFrameCounts
(
10
)
{
mCycledOnce
=
false
;
mDumpFrameCounts
=
false
;
mDumpFrameByFrameCounts
=
false
;
mPaintFrameByFrameCounts
=
false
;
}
ReflowCountMgr
:
:
~
ReflowCountMgr
(
)
=
default
;
ReflowCounter
*
ReflowCountMgr
:
:
LookUp
(
const
char
*
aName
)
{
return
mCounts
.
Get
(
aName
)
;
}
void
ReflowCountMgr
:
:
Add
(
const
char
*
aName
nsIFrame
*
aFrame
)
{
NS_ASSERTION
(
aName
!
=
nullptr
"
Name
shouldn
'
t
be
null
!
"
)
;
if
(
mDumpFrameCounts
)
{
auto
*
const
counter
=
mCounts
.
GetOrInsertNew
(
aName
this
)
;
counter
-
>
Add
(
)
;
}
if
(
(
mDumpFrameByFrameCounts
|
|
mPaintFrameByFrameCounts
)
&
&
aFrame
!
=
nullptr
)
{
char
key
[
KEY_BUF_SIZE_FOR_PTR
]
;
SprintfLiteral
(
key
"
%
p
"
(
void
*
)
aFrame
)
;
auto
*
const
counter
=
mIndiFrameCounts
.
LookupOrInsertWith
(
key
[
&
aName
&
aFrame
this
]
(
)
{
auto
counter
=
MakeUnique
<
IndiReflowCounter
>
(
this
)
;
counter
-
>
mFrame
=
aFrame
;
counter
-
>
mName
.
AssignASCII
(
aName
)
;
return
counter
;
}
)
.
get
(
)
;
if
(
counter
&
&
counter
-
>
mName
.
EqualsASCII
(
aName
)
)
{
counter
-
>
mCount
+
+
;
counter
-
>
mCounter
.
Add
(
1
)
;
}
}
}
void
ReflowCountMgr
:
:
PaintCount
(
const
char
*
aName
gfxContext
*
aRenderingContext
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
const
nsPoint
&
aOffset
uint32_t
aColor
)
{
if
(
mPaintFrameByFrameCounts
&
&
aFrame
!
=
nullptr
)
{
char
key
[
KEY_BUF_SIZE_FOR_PTR
]
;
SprintfLiteral
(
key
"
%
p
"
(
void
*
)
aFrame
)
;
IndiReflowCounter
*
counter
=
mIndiFrameCounts
.
Get
(
key
)
;
if
(
counter
!
=
nullptr
&
&
counter
-
>
mName
.
EqualsASCII
(
aName
)
)
{
DrawTarget
*
drawTarget
=
aRenderingContext
-
>
GetDrawTarget
(
)
;
int32_t
appUnitsPerDevPixel
=
aPresContext
-
>
AppUnitsPerDevPixel
(
)
;
aRenderingContext
-
>
Save
(
)
;
gfxPoint
devPixelOffset
=
nsLayoutUtils
:
:
PointToGfxPoint
(
aOffset
appUnitsPerDevPixel
)
;
aRenderingContext
-
>
SetMatrixDouble
(
aRenderingContext
-
>
CurrentMatrixDouble
(
)
.
PreTranslate
(
devPixelOffset
)
)
;
nsFont
font
(
StyleGenericFontFamily
:
:
Serif
Length
:
:
FromPixels
(
11
)
)
;
nsFontMetrics
:
:
Params
params
;
params
.
language
=
nsGkAtoms
:
:
x_western
;
params
.
textPerf
=
aPresContext
-
>
GetTextPerfMetrics
(
)
;
params
.
featureValueLookup
=
aPresContext
-
>
GetFontFeatureValuesLookup
(
)
;
RefPtr
<
nsFontMetrics
>
fm
=
aPresContext
-
>
GetMetricsFor
(
font
params
)
;
char
buf
[
16
]
;
int
len
=
SprintfLiteral
(
buf
"
%
d
"
counter
-
>
mCount
)
;
nscoord
x
=
0
y
=
fm
-
>
MaxAscent
(
)
;
nscoord
width
height
=
fm
-
>
MaxHeight
(
)
;
fm
-
>
SetTextRunRTL
(
false
)
;
width
=
fm
-
>
GetWidth
(
buf
len
drawTarget
)
;
sRGBColor
color
;
sRGBColor
color2
;
if
(
aColor
!
=
0
)
{
color
=
sRGBColor
:
:
FromABGR
(
aColor
)
;
color2
=
sRGBColor
(
0
.
f
0
.
f
0
.
f
)
;
}
else
{
gfx
:
:
Float
rc
=
0
.
f
gc
=
0
.
f
bc
=
0
.
f
;
if
(
counter
-
>
mCount
<
5
)
{
rc
=
1
.
f
;
gc
=
1
.
f
;
}
else
if
(
counter
-
>
mCount
<
11
)
{
gc
=
1
.
f
;
}
else
{
rc
=
1
.
f
;
}
color
=
sRGBColor
(
rc
gc
bc
)
;
color2
=
sRGBColor
(
rc
/
2
gc
/
2
bc
/
2
)
;
}
nsRect
rect
(
0
0
width
+
15
height
+
15
)
;
Rect
devPxRect
=
NSRectToSnappedRect
(
rect
appUnitsPerDevPixel
*
drawTarget
)
;
ColorPattern
black
(
ToDeviceColor
(
sRGBColor
:
:
OpaqueBlack
(
)
)
)
;
drawTarget
-
>
FillRect
(
devPxRect
black
)
;
aRenderingContext
-
>
SetColor
(
color2
)
;
fm
-
>
DrawString
(
buf
len
x
+
15
y
+
15
aRenderingContext
)
;
aRenderingContext
-
>
SetColor
(
color
)
;
fm
-
>
DrawString
(
buf
len
x
y
aRenderingContext
)
;
aRenderingContext
-
>
Restore
(
)
;
}
}
}
void
ReflowCountMgr
:
:
DoGrandTotals
(
)
{
mCounts
.
WithEntryHandle
(
kGrandTotalsStr
[
this
]
(
auto
&
&
entry
)
{
if
(
!
entry
)
{
entry
.
Insert
(
MakeUnique
<
ReflowCounter
>
(
this
)
)
;
}
else
{
entry
.
Data
(
)
-
>
ClearTotals
(
)
;
}
}
)
;
printf
(
"
\
t
\
t
\
t
\
tTotal
\
n
"
)
;
for
(
uint32_t
i
=
0
;
i
<
78
;
i
+
+
)
{
printf
(
"
-
"
)
;
}
printf
(
"
\
n
"
)
;
for
(
const
auto
&
entry
:
mCounts
)
{
entry
.
GetData
(
)
-
>
DisplayTotals
(
entry
.
GetKey
(
)
)
;
}
}
static
void
RecurseIndiTotals
(
nsPresContext
*
aPresContext
nsClassHashtable
<
nsCharPtrHashKey
IndiReflowCounter
>
&
aHT
nsIFrame
*
aParentFrame
int32_t
aLevel
)
{
if
(
aParentFrame
=
=
nullptr
)
{
return
;
}
char
key
[
KEY_BUF_SIZE_FOR_PTR
]
;
SprintfLiteral
(
key
"
%
p
"
(
void
*
)
aParentFrame
)
;
IndiReflowCounter
*
counter
=
aHT
.
Get
(
key
)
;
if
(
counter
)
{
counter
-
>
mHasBeenOutput
=
true
;
char
*
name
=
ToNewCString
(
counter
-
>
mName
)
;
for
(
int32_t
i
=
0
;
i
<
aLevel
;
i
+
+
)
printf
(
"
"
)
;
printf
(
"
%
s
-
%
p
[
%
d
]
[
"
name
(
void
*
)
aParentFrame
counter
-
>
mCount
)
;
printf
(
"
%
d
"
counter
-
>
mCounter
.
GetTotal
(
)
)
;
printf
(
"
]
\
n
"
)
;
free
(
name
)
;
}
for
(
nsIFrame
*
child
:
aParentFrame
-
>
PrincipalChildList
(
)
)
{
RecurseIndiTotals
(
aPresContext
aHT
child
aLevel
+
1
)
;
}
}
void
ReflowCountMgr
:
:
DoIndiTotalsTree
(
)
{
printf
(
"
\
n
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
\
n
"
)
;
printf
(
"
-
-
Individual
Frame
Counts
\
n
"
)
;
printf
(
"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
\
n
"
)
;
if
(
mPresShell
)
{
nsIFrame
*
rootFrame
=
mPresShell
-
>
GetRootFrame
(
)
;
RecurseIndiTotals
(
mPresContext
mIndiFrameCounts
rootFrame
0
)
;
printf
(
"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
\
n
"
)
;
printf
(
"
-
-
Individual
Counts
of
Frames
not
in
Root
Tree
\
n
"
)
;
printf
(
"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
\
n
"
)
;
for
(
const
auto
&
counter
:
mIndiFrameCounts
.
Values
(
)
)
{
if
(
!
counter
-
>
mHasBeenOutput
)
{
char
*
name
=
ToNewCString
(
counter
-
>
mName
)
;
printf
(
"
%
s
-
%
p
[
%
d
]
[
"
name
(
void
*
)
counter
-
>
mFrame
counter
-
>
mCount
)
;
printf
(
"
%
d
"
counter
-
>
mCounter
.
GetTotal
(
)
)
;
printf
(
"
]
\
n
"
)
;
free
(
name
)
;
}
}
}
}
void
ReflowCountMgr
:
:
DoGrandHTMLTotals
(
)
{
mCounts
.
WithEntryHandle
(
kGrandTotalsStr
[
this
]
(
auto
&
&
entry
)
{
if
(
!
entry
)
{
entry
.
Insert
(
MakeUnique
<
ReflowCounter
>
(
this
)
)
;
}
else
{
entry
.
Data
(
)
-
>
ClearTotals
(
)
;
}
}
)
;
static
const
char
*
title
[
]
=
{
"
Class
"
"
Reflows
"
}
;
fprintf
(
mFD
"
<
tr
>
"
)
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
title
)
;
i
+
+
)
{
fprintf
(
mFD
"
<
td
>
<
center
>
<
b
>
%
s
<
b
>
<
/
center
>
<
/
td
>
"
title
[
i
]
)
;
}
fprintf
(
mFD
"
<
/
tr
>
\
n
"
)
;
for
(
const
auto
&
entry
:
mCounts
)
{
entry
.
GetData
(
)
-
>
DisplayHTMLTotals
(
entry
.
GetKey
(
)
)
;
}
}
void
ReflowCountMgr
:
:
DisplayTotals
(
const
char
*
aStr
)
{
#
ifdef
DEBUG_rods
printf
(
"
%
s
\
n
"
aStr
?
aStr
:
"
No
name
"
)
;
#
endif
if
(
mDumpFrameCounts
)
{
DoGrandTotals
(
)
;
}
if
(
mDumpFrameByFrameCounts
)
{
DoIndiTotalsTree
(
)
;
}
}
void
ReflowCountMgr
:
:
DisplayHTMLTotals
(
const
char
*
aStr
)
{
#
ifdef
WIN32x
char
name
[
1024
]
;
char
*
sptr
=
strrchr
(
aStr
'
/
'
)
;
if
(
sptr
)
{
sptr
+
+
;
strcpy
(
name
sptr
)
;
char
*
eptr
=
strrchr
(
name
'
.
'
)
;
if
(
eptr
)
{
*
eptr
=
0
;
}
strcat
(
name
"
_stats
.
html
"
)
;
}
mFD
=
fopen
(
name
"
w
"
)
;
if
(
mFD
)
{
fprintf
(
mFD
"
<
html
>
<
head
>
<
title
>
Reflow
Stats
<
/
title
>
<
/
head
>
<
body
>
\
n
"
)
;
const
char
*
title
=
aStr
?
aStr
:
"
No
name
"
;
fprintf
(
mFD
"
<
center
>
<
b
>
%
s
<
/
b
>
<
br
>
<
table
border
=
1
"
"
style
=
\
"
background
-
color
:
#
e0e0e0
\
"
>
"
title
)
;
DoGrandHTMLTotals
(
)
;
fprintf
(
mFD
"
<
/
center
>
<
/
table
>
\
n
"
)
;
fprintf
(
mFD
"
<
/
body
>
<
/
html
>
\
n
"
)
;
fclose
(
mFD
)
;
mFD
=
nullptr
;
}
#
endif
}
void
ReflowCountMgr
:
:
ClearTotals
(
)
{
for
(
const
auto
&
data
:
mCounts
.
Values
(
)
)
{
data
-
>
ClearTotals
(
)
;
}
}
void
ReflowCountMgr
:
:
ClearGrandTotals
(
)
{
mCounts
.
WithEntryHandle
(
kGrandTotalsStr
[
&
]
(
auto
&
&
entry
)
{
if
(
!
entry
)
{
entry
.
Insert
(
MakeUnique
<
ReflowCounter
>
(
this
)
)
;
}
else
{
entry
.
Data
(
)
-
>
ClearTotals
(
)
;
entry
.
Data
(
)
-
>
SetTotalsCache
(
)
;
}
}
)
;
}
void
ReflowCountMgr
:
:
DisplayDiffsInTotals
(
)
{
if
(
mCycledOnce
)
{
printf
(
"
Differences
\
n
"
)
;
for
(
int32_t
i
=
0
;
i
<
78
;
i
+
+
)
{
printf
(
"
-
"
)
;
}
printf
(
"
\
n
"
)
;
ClearGrandTotals
(
)
;
}
for
(
const
auto
&
entry
:
mCounts
)
{
if
(
mCycledOnce
)
{
entry
.
GetData
(
)
-
>
CalcDiffInTotals
(
)
;
entry
.
GetData
(
)
-
>
DisplayDiffTotals
(
entry
.
GetKey
(
)
)
;
}
entry
.
GetData
(
)
-
>
SetTotalsCache
(
)
;
}
mCycledOnce
=
true
;
}
#
endif
nsIFrame
*
PresShell
:
:
GetAbsoluteContainingBlock
(
nsIFrame
*
aFrame
)
{
return
FrameConstructor
(
)
-
>
GetAbsoluteContainingBlock
(
aFrame
nsCSSFrameConstructor
:
:
ABS_POS
)
;
}
void
PresShell
:
:
ActivenessMaybeChanged
(
)
{
if
(
!
mDocument
)
{
return
;
}
SetIsActive
(
ComputeActiveness
(
)
)
;
}
bool
PresShell
:
:
ComputeActiveness
(
)
const
{
MOZ_LOG
(
gLog
LogLevel
:
:
Debug
(
"
PresShell
:
:
ComputeActiveness
(
%
s
%
d
)
\
n
"
mDocument
-
>
GetDocumentURI
(
)
?
mDocument
-
>
GetDocumentURI
(
)
-
>
GetSpecOrDefault
(
)
.
get
(
)
:
"
(
no
uri
)
"
mIsActive
)
)
;
Document
*
doc
=
mDocument
;
if
(
doc
-
>
IsBeingUsedAsImage
(
)
)
{
return
true
;
}
if
(
Document
*
displayDoc
=
doc
-
>
GetDisplayDocument
(
)
)
{
MOZ_ASSERT
(
!
doc
-
>
GetBrowsingContext
(
)
"
external
resource
doc
shouldn
'
t
have
its
own
BC
"
)
;
doc
=
displayDoc
;
}
BrowsingContext
*
bc
=
doc
-
>
GetBrowsingContext
(
)
;
const
bool
inActiveTab
=
bc
&
&
bc
-
>
IsActive
(
)
;
MOZ_LOG
(
gLog
LogLevel
:
:
Debug
(
"
>
BrowsingContext
%
p
active
:
%
d
"
bc
inActiveTab
)
)
;
Document
*
root
=
nsContentUtils
:
:
GetInProcessSubtreeRootDocument
(
doc
)
;
if
(
auto
*
browserChild
=
BrowserChild
:
:
GetFrom
(
root
-
>
GetDocShell
(
)
)
)
{
if
(
!
browserChild
-
>
IsVisible
(
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Debug
(
"
>
BrowserChild
%
p
is
not
visible
"
browserChild
)
)
;
return
false
;
}
if
(
!
browserChild
-
>
IsPreservingLayers
(
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Debug
(
"
>
BrowserChild
%
p
is
visible
and
not
preserving
layers
"
browserChild
)
)
;
return
true
;
}
MOZ_LOG
(
gLog
LogLevel
:
:
Debug
(
"
>
BrowserChild
%
p
is
visible
and
preserving
layers
"
browserChild
)
)
;
}
return
inActiveTab
;
}
void
PresShell
:
:
SetIsActive
(
bool
aIsActive
)
{
MOZ_ASSERT
(
mDocument
"
should
only
be
called
with
a
document
"
)
;
const
bool
activityChanged
=
mIsActive
!
=
aIsActive
;
mIsActive
=
aIsActive
;
nsPresContext
*
presContext
=
GetPresContext
(
)
;
if
(
presContext
&
&
presContext
-
>
RefreshDriver
(
)
-
>
GetPresContext
(
)
=
=
presContext
)
{
presContext
-
>
RefreshDriver
(
)
-
>
SetActivity
(
aIsActive
)
;
}
if
(
activityChanged
)
{
auto
recurse
=
[
aIsActive
]
(
Document
&
aSubDoc
)
{
if
(
PresShell
*
presShell
=
aSubDoc
.
GetPresShell
(
)
)
{
presShell
-
>
SetIsActive
(
aIsActive
)
;
}
return
CallState
:
:
Continue
;
}
;
mDocument
-
>
EnumerateExternalResources
(
recurse
)
;
mDocument
-
>
EnumerateSubDocuments
(
recurse
)
;
}
UpdateImageLockingState
(
)
;
if
(
activityChanged
)
{
#
if
defined
(
MOZ_WIDGET_ANDROID
)
if
(
!
aIsActive
&
&
presContext
&
&
presContext
-
>
IsRootContentDocumentCrossProcess
(
)
)
{
if
(
BrowserChild
*
browserChild
=
BrowserChild
:
:
GetFrom
(
this
)
)
{
presContext
-
>
UpdateDynamicToolbarOffset
(
0
)
;
}
}
#
endif
}
if
(
aIsActive
)
{
#
ifdef
ACCESSIBILITY
if
(
nsAccessibilityService
*
accService
=
GetAccService
(
)
)
{
accService
-
>
PresShellActivated
(
this
)
;
}
#
endif
if
(
nsIFrame
*
rootFrame
=
GetRootFrame
(
)
)
{
rootFrame
-
>
SchedulePaint
(
)
;
}
}
}
RefPtr
<
MobileViewportManager
>
PresShell
:
:
GetMobileViewportManager
(
)
const
{
return
mMobileViewportManager
;
}
Maybe
<
MobileViewportManager
:
:
ManagerType
>
UseMobileViewportManager
(
PresShell
*
aPresShell
Document
*
aDocument
)
{
if
(
nsPresContext
*
presContext
=
aPresShell
-
>
GetPresContext
(
)
)
{
if
(
nsIWidget
*
widget
=
presContext
-
>
GetNearestWidget
(
)
)
{
if
(
!
widget
-
>
AsyncPanZoomEnabled
(
)
)
{
return
Nothing
(
)
;
}
}
}
if
(
nsLayoutUtils
:
:
ShouldHandleMetaViewport
(
aDocument
)
)
{
return
Some
(
MobileViewportManager
:
:
ManagerType
:
:
VisualAndMetaViewport
)
;
}
if
(
StaticPrefs
:
:
apz_mvm_force_enabled
(
)
|
|
nsLayoutUtils
:
:
AllowZoomingForDocument
(
aDocument
)
)
{
return
Some
(
MobileViewportManager
:
:
ManagerType
:
:
VisualViewportOnly
)
;
}
return
Nothing
(
)
;
}
void
PresShell
:
:
MaybeRecreateMobileViewportManager
(
bool
aAfterInitialization
)
{
Maybe
<
MobileViewportManager
:
:
ManagerType
>
mvmType
=
UseMobileViewportManager
(
this
mDocument
)
;
if
(
mvmType
.
isNothing
(
)
&
&
!
mMobileViewportManager
)
{
return
;
}
if
(
mvmType
&
&
mMobileViewportManager
&
&
*
mvmType
=
=
mMobileViewportManager
-
>
GetManagerType
(
)
)
{
return
;
}
if
(
mMobileViewportManager
)
{
mMobileViewportManager
-
>
Destroy
(
)
;
mMobileViewportManager
=
nullptr
;
mMVMContext
=
nullptr
;
ResetVisualViewportSize
(
)
;
SetResolutionAndScaleTo
(
mDocument
-
>
GetSavedResolutionBeforeMVM
(
)
ResolutionChangeOrigin
:
:
MainThreadRestore
)
;
if
(
aAfterInitialization
)
{
ForceResizeReflowWithCurrentDimensions
(
)
;
}
}
if
(
mvmType
)
{
MOZ_ASSERT
(
!
mMobileViewportManager
)
;
if
(
mPresContext
-
>
IsRootContentDocumentCrossProcess
(
)
)
{
mDocument
-
>
SetSavedResolutionBeforeMVM
(
mResolution
.
valueOr
(
1
.
0f
)
)
;
mMVMContext
=
new
GeckoMVMContext
(
mDocument
this
)
;
mMobileViewportManager
=
new
MobileViewportManager
(
mMVMContext
*
mvmType
)
;
if
(
MOZ_UNLIKELY
(
MOZ_LOG_TEST
(
MobileViewportManager
:
:
gLog
LogLevel
:
:
Debug
)
)
)
{
nsIURI
*
uri
=
mDocument
-
>
GetDocumentURI
(
)
;
MOZ_LOG
(
MobileViewportManager
:
:
gLog
LogLevel
:
:
Debug
(
"
Created
MVM
%
p
(
type
%
d
)
for
URI
%
s
"
mMobileViewportManager
.
get
(
)
(
int
)
*
mvmType
uri
?
uri
-
>
GetSpecOrDefault
(
)
.
get
(
)
:
"
(
null
)
"
)
)
;
}
if
(
aAfterInitialization
)
{
mMobileViewportManager
-
>
SetInitialViewport
(
)
;
}
}
}
}
bool
PresShell
:
:
UsesMobileViewportSizing
(
)
const
{
return
mMobileViewportManager
!
=
nullptr
&
&
nsLayoutUtils
:
:
ShouldHandleMetaViewport
(
mDocument
)
;
}
void
PresShell
:
:
UpdateImageLockingState
(
)
{
const
bool
locked
=
!
mFrozen
&
&
mIsActive
;
auto
*
tracker
=
mDocument
-
>
ImageTracker
(
)
;
if
(
locked
=
=
tracker
-
>
GetLockingState
(
)
)
{
return
;
}
tracker
-
>
SetLockingState
(
locked
)
;
if
(
locked
)
{
for
(
const
auto
&
key
:
mApproximatelyVisibleFrames
)
{
if
(
nsImageFrame
*
imageFrame
=
do_QueryFrame
(
key
)
)
{
imageFrame
-
>
MaybeDecodeForPredictedSize
(
)
;
}
}
}
}
PresShell
*
PresShell
:
:
GetRootPresShell
(
)
const
{
if
(
mPresContext
)
{
nsPresContext
*
rootPresContext
=
mPresContext
-
>
GetRootPresContext
(
)
;
if
(
rootPresContext
)
{
return
rootPresContext
-
>
PresShell
(
)
;
}
}
return
nullptr
;
}
void
PresShell
:
:
AddSizeOfIncludingThis
(
nsWindowSizes
&
aSizes
)
const
{
MallocSizeOf
mallocSizeOf
=
aSizes
.
mState
.
mMallocSizeOf
;
mFrameArena
.
AddSizeOfExcludingThis
(
aSizes
Arena
:
:
ArenaKind
:
:
PresShell
)
;
aSizes
.
mLayoutPresShellSize
+
=
mallocSizeOf
(
this
)
;
if
(
mCaret
)
{
aSizes
.
mLayoutPresShellSize
+
=
mCaret
-
>
SizeOfIncludingThis
(
mallocSizeOf
)
;
}
aSizes
.
mLayoutPresShellSize
+
=
mApproximatelyVisibleFrames
.
ShallowSizeOfExcludingThis
(
mallocSizeOf
)
+
mFramesToDirty
.
ShallowSizeOfExcludingThis
(
mallocSizeOf
)
+
mPendingScrollAnchorSelection
.
ShallowSizeOfExcludingThis
(
mallocSizeOf
)
+
mPendingScrollAnchorAdjustment
.
ShallowSizeOfExcludingThis
(
mallocSizeOf
)
;
aSizes
.
mLayoutTextRunsSize
+
=
SizeOfTextRuns
(
mallocSizeOf
)
;
aSizes
.
mLayoutPresContextSize
+
=
mPresContext
-
>
SizeOfIncludingThis
(
mallocSizeOf
)
;
mFrameConstructor
-
>
AddSizeOfIncludingThis
(
aSizes
)
;
}
size_t
PresShell
:
:
SizeOfTextRuns
(
MallocSizeOf
aMallocSizeOf
)
const
{
nsIFrame
*
rootFrame
=
mFrameConstructor
-
>
GetRootFrame
(
)
;
if
(
!
rootFrame
)
{
return
0
;
}
nsLayoutUtils
:
:
SizeOfTextRunsForFrames
(
rootFrame
nullptr
true
)
;
return
nsLayoutUtils
:
:
SizeOfTextRunsForFrames
(
rootFrame
aMallocSizeOf
false
)
;
}
void
PresShell
:
:
MarkFixedFramesForReflow
(
IntrinsicDirty
aIntrinsicDirty
)
{
nsIFrame
*
rootFrame
=
mFrameConstructor
-
>
GetRootFrame
(
)
;
if
(
rootFrame
)
{
const
nsFrameList
&
childList
=
rootFrame
-
>
GetChildList
(
FrameChildListID
:
:
Fixed
)
;
for
(
nsIFrame
*
childFrame
:
childList
)
{
FrameNeedsReflow
(
childFrame
aIntrinsicDirty
NS_FRAME_IS_DIRTY
)
;
}
}
}
static
void
AppendSubtree
(
nsIDocShell
*
aDocShell
nsTArray
<
nsCOMPtr
<
nsIDocumentViewer
>
>
&
aArray
)
{
if
(
nsCOMPtr
<
nsIDocumentViewer
>
viewer
=
aDocShell
-
>
GetDocViewer
(
)
)
{
aArray
.
AppendElement
(
viewer
)
;
}
int32_t
n
=
aDocShell
-
>
GetInProcessChildCount
(
)
;
for
(
int32_t
i
=
0
;
i
<
n
;
i
+
+
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
childItem
;
aDocShell
-
>
GetInProcessChildAt
(
i
getter_AddRefs
(
childItem
)
)
;
if
(
childItem
)
{
nsCOMPtr
<
nsIDocShell
>
child
(
do_QueryInterface
(
childItem
)
)
;
AppendSubtree
(
child
aArray
)
;
}
}
}
void
PresShell
:
:
MaybeReflowForInflationScreenSizeChange
(
)
{
nsPresContext
*
pc
=
GetPresContext
(
)
;
const
bool
fontInflationWasEnabled
=
FontSizeInflationEnabled
(
)
;
RecomputeFontSizeInflationEnabled
(
)
;
bool
changed
=
false
;
if
(
FontSizeInflationEnabled
(
)
&
&
FontSizeInflationMinTwips
(
)
!
=
0
)
{
pc
-
>
ScreenSizeInchesForFontInflation
(
&
changed
)
;
}
changed
=
changed
|
|
fontInflationWasEnabled
!
=
FontSizeInflationEnabled
(
)
;
if
(
!
changed
)
{
return
;
}
if
(
nsCOMPtr
<
nsIDocShell
>
docShell
=
pc
-
>
GetDocShell
(
)
)
{
nsTArray
<
nsCOMPtr
<
nsIDocumentViewer
>
>
array
;
AppendSubtree
(
docShell
array
)
;
for
(
uint32_t
i
=
0
iEnd
=
array
.
Length
(
)
;
i
<
iEnd
;
+
+
i
)
{
nsCOMPtr
<
nsIDocumentViewer
>
viewer
=
array
[
i
]
;
if
(
RefPtr
<
PresShell
>
descendantPresShell
=
viewer
-
>
GetPresShell
(
)
)
{
nsIFrame
*
rootFrame
=
descendantPresShell
-
>
GetRootFrame
(
)
;
if
(
rootFrame
)
{
descendantPresShell
-
>
FrameNeedsReflow
(
rootFrame
IntrinsicDirty
:
:
FrameAncestorsAndDescendants
NS_FRAME_IS_DIRTY
)
;
}
}
}
}
}
void
PresShell
:
:
CompleteChangeToVisualViewportSize
(
)
{
if
(
!
mIsReflowing
)
{
if
(
nsIScrollableFrame
*
rootScrollFrame
=
GetRootScrollFrameAsScrollable
(
)
)
{
rootScrollFrame
-
>
MarkScrollbarsDirtyForReflow
(
)
;
}
MarkFixedFramesForReflow
(
IntrinsicDirty
:
:
None
)
;
}
MaybeReflowForInflationScreenSizeChange
(
)
;
if
(
auto
*
window
=
nsGlobalWindowInner
:
:
Cast
(
mDocument
-
>
GetInnerWindow
(
)
)
)
{
window
-
>
VisualViewport
(
)
-
>
PostResizeEvent
(
)
;
}
}
void
PresShell
:
:
SetVisualViewportSize
(
nscoord
aWidth
nscoord
aHeight
)
{
MOZ_ASSERT
(
aWidth
>
=
0
.
0
&
&
aHeight
>
=
0
.
0
)
;
if
(
!
mVisualViewportSizeSet
|
|
mVisualViewportSize
.
width
!
=
aWidth
|
|
mVisualViewportSize
.
height
!
=
aHeight
)
{
mVisualViewportSizeSet
=
true
;
mVisualViewportSize
.
width
=
aWidth
;
mVisualViewportSize
.
height
=
aHeight
;
CompleteChangeToVisualViewportSize
(
)
;
}
}
void
PresShell
:
:
ResetVisualViewportSize
(
)
{
if
(
mVisualViewportSizeSet
)
{
mVisualViewportSizeSet
=
false
;
mVisualViewportSize
.
width
=
0
;
mVisualViewportSize
.
height
=
0
;
CompleteChangeToVisualViewportSize
(
)
;
}
}
bool
PresShell
:
:
SetVisualViewportOffset
(
const
nsPoint
&
aScrollOffset
const
nsPoint
&
aPrevLayoutScrollPos
)
{
nsPoint
newOffset
=
aScrollOffset
;
nsIScrollableFrame
*
rootScrollFrame
=
GetRootScrollFrameAsScrollable
(
)
;
if
(
rootScrollFrame
)
{
nsRect
scrollRange
=
rootScrollFrame
-
>
GetScrollRangeForUserInputEvents
(
)
;
if
(
!
scrollRange
.
Contains
(
newOffset
)
)
{
newOffset
.
x
=
std
:
:
min
(
newOffset
.
x
scrollRange
.
XMost
(
)
)
;
newOffset
.
x
=
std
:
:
max
(
newOffset
.
x
scrollRange
.
x
)
;
newOffset
.
y
=
std
:
:
min
(
newOffset
.
y
scrollRange
.
YMost
(
)
)
;
newOffset
.
y
=
std
:
:
max
(
newOffset
.
y
scrollRange
.
y
)
;
}
}
nsPoint
prevOffset
=
aPrevLayoutScrollPos
;
if
(
mVisualViewportOffset
.
isSome
(
)
)
{
prevOffset
=
*
mVisualViewportOffset
;
}
if
(
prevOffset
=
=
newOffset
)
{
return
false
;
}
mVisualViewportOffset
=
Some
(
newOffset
)
;
if
(
auto
*
window
=
nsGlobalWindowInner
:
:
Cast
(
mDocument
-
>
GetInnerWindow
(
)
)
)
{
window
-
>
VisualViewport
(
)
-
>
PostScrollEvent
(
prevOffset
aPrevLayoutScrollPos
)
;
}
if
(
IsVisualViewportSizeSet
(
)
&
&
rootScrollFrame
)
{
rootScrollFrame
-
>
Anchor
(
)
-
>
UserScrolled
(
)
;
}
if
(
gfxPlatform
:
:
UseDesktopZoomingScrollbars
(
)
)
{
if
(
nsIScrollableFrame
*
rootScrollFrame
=
GetRootScrollFrameAsScrollable
(
)
)
{
rootScrollFrame
-
>
UpdateScrollbarPosition
(
)
;
}
}
return
true
;
}
void
PresShell
:
:
ResetVisualViewportOffset
(
)
{
mVisualViewportOffset
.
reset
(
)
;
}
void
PresShell
:
:
ScrollToVisual
(
const
nsPoint
&
aVisualViewportOffset
FrameMetrics
:
:
ScrollOffsetUpdateType
aUpdateType
ScrollMode
aMode
)
{
MOZ_ASSERT
(
aMode
=
=
ScrollMode
:
:
Instant
|
|
aMode
=
=
ScrollMode
:
:
SmoothMsd
)
;
if
(
aMode
=
=
ScrollMode
:
:
SmoothMsd
)
{
if
(
nsIScrollableFrame
*
sf
=
GetRootScrollFrameAsScrollable
(
)
)
{
if
(
sf
-
>
SmoothScrollVisual
(
aVisualViewportOffset
aUpdateType
)
)
{
return
;
}
}
}
SetPendingVisualScrollUpdate
(
aVisualViewportOffset
aUpdateType
)
;
}
void
PresShell
:
:
SetPendingVisualScrollUpdate
(
const
nsPoint
&
aVisualViewportOffset
FrameMetrics
:
:
ScrollOffsetUpdateType
aUpdateType
)
{
mPendingVisualScrollUpdate
=
Some
(
VisualScrollUpdate
{
aVisualViewportOffset
aUpdateType
}
)
;
if
(
nsIFrame
*
rootFrame
=
GetRootFrame
(
)
)
{
rootFrame
-
>
SchedulePaint
(
)
;
}
}
void
PresShell
:
:
ClearPendingVisualScrollUpdate
(
)
{
if
(
mPendingVisualScrollUpdate
&
&
mPendingVisualScrollUpdate
-
>
mAcknowledged
)
{
mPendingVisualScrollUpdate
=
mozilla
:
:
Nothing
(
)
;
}
}
void
PresShell
:
:
AcknowledgePendingVisualScrollUpdate
(
)
{
MOZ_ASSERT
(
mPendingVisualScrollUpdate
)
;
mPendingVisualScrollUpdate
-
>
mAcknowledged
=
true
;
}
nsPoint
PresShell
:
:
GetVisualViewportOffsetRelativeToLayoutViewport
(
)
const
{
return
GetVisualViewportOffset
(
)
-
GetLayoutViewportOffset
(
)
;
}
nsPoint
PresShell
:
:
GetLayoutViewportOffset
(
)
const
{
nsPoint
result
;
if
(
nsIScrollableFrame
*
sf
=
GetRootScrollFrameAsScrollable
(
)
)
{
result
=
sf
-
>
GetScrollPosition
(
)
;
}
return
result
;
}
nsSize
PresShell
:
:
GetLayoutViewportSize
(
)
const
{
nsSize
result
;
if
(
nsIScrollableFrame
*
sf
=
GetRootScrollFrameAsScrollable
(
)
)
{
result
=
sf
-
>
GetScrollPortRect
(
)
.
Size
(
)
;
}
return
result
;
}
nsSize
PresShell
:
:
GetVisualViewportSizeUpdatedByDynamicToolbar
(
)
const
{
NS_ASSERTION
(
mVisualViewportSizeSet
"
asking
for
visual
viewport
size
when
its
not
set
?
"
)
;
if
(
!
mMobileViewportManager
)
{
return
mVisualViewportSize
;
}
MOZ_ASSERT
(
GetDynamicToolbarState
(
)
=
=
DynamicToolbarState
:
:
InTransition
|
|
GetDynamicToolbarState
(
)
=
=
DynamicToolbarState
:
:
Collapsed
)
;
nsSize
sizeUpdatedByDynamicToolbar
=
mMobileViewportManager
-
>
GetVisualViewportSizeUpdatedByDynamicToolbar
(
)
;
return
sizeUpdatedByDynamicToolbar
=
=
nsSize
(
)
?
mVisualViewportSize
:
sizeUpdatedByDynamicToolbar
;
}
void
PresShell
:
:
RecomputeFontSizeInflationEnabled
(
)
{
mFontSizeInflationEnabled
=
DetermineFontSizeInflationState
(
)
;
}
bool
PresShell
:
:
DetermineFontSizeInflationState
(
)
{
MOZ_ASSERT
(
mPresContext
"
our
pres
context
should
not
be
null
"
)
;
if
(
mPresContext
-
>
IsChrome
(
)
)
{
return
false
;
}
if
(
FontSizeInflationEmPerLine
(
)
=
=
0
&
&
FontSizeInflationMinTwips
(
)
=
=
0
)
{
return
false
;
}
if
(
!
FontSizeInflationForceEnabled
(
)
)
{
if
(
BrowserChild
*
tab
=
BrowserChild
:
:
GetFrom
(
this
)
)
{
if
(
!
tab
-
>
AsyncPanZoomEnabled
(
)
)
{
return
false
;
}
}
else
if
(
XRE_IsParentProcess
(
)
)
{
if
(
FontSizeInflationDisabledInMasterProcess
(
)
)
{
return
false
;
}
}
}
Maybe
<
LayoutDeviceIntSize
>
displaySize
;
if
(
mPresContext
-
>
IsRootContentDocumentCrossProcess
(
)
)
{
if
(
mMobileViewportManager
)
{
displaySize
=
Some
(
mMobileViewportManager
-
>
DisplaySize
(
)
)
;
}
}
else
if
(
PresShell
*
rootPresShell
=
GetRootPresShell
(
)
)
{
if
(
auto
mvm
=
rootPresShell
-
>
GetMobileViewportManager
(
)
)
{
displaySize
=
Some
(
mvm
-
>
DisplaySize
(
)
)
;
}
}
if
(
!
displaySize
)
{
nsPresContext
*
topContext
=
mPresContext
-
>
GetInProcessRootContentDocumentPresContext
(
)
;
LayoutDeviceIntSize
result
;
if
(
!
nsLayoutUtils
:
:
GetDocumentViewerSize
(
topContext
result
)
)
{
return
false
;
}
displaySize
=
Some
(
result
)
;
}
ScreenIntSize
screenSize
=
ViewAs
<
ScreenPixel
>
(
displaySize
.
value
(
)
PixelCastJustification
:
:
LayoutDeviceIsScreenForBounds
)
;
nsViewportInfo
vInf
=
GetDocument
(
)
-
>
GetViewportInfo
(
screenSize
)
;
CSSToScreenScale
defaultScale
=
mPresContext
-
>
CSSToDevPixelScale
(
)
*
LayoutDeviceToScreenScale
(
1
.
0
)
;
if
(
vInf
.
GetDefaultZoom
(
)
>
=
defaultScale
|
|
vInf
.
IsAutoSizeEnabled
(
)
)
{
return
false
;
}
return
true
;
}
static
nsIWidget
*
GetPresContextContainerWidget
(
nsPresContext
*
aPresContext
)
{
nsCOMPtr
<
nsISupports
>
container
=
aPresContext
-
>
Document
(
)
-
>
GetContainer
(
)
;
nsCOMPtr
<
nsIBaseWindow
>
baseWindow
=
do_QueryInterface
(
container
)
;
if
(
!
baseWindow
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIWidget
>
mainWidget
;
baseWindow
-
>
GetMainWidget
(
getter_AddRefs
(
mainWidget
)
)
;
return
mainWidget
;
}
static
bool
IsTopLevelWidget
(
nsIWidget
*
aWidget
)
{
using
WindowType
=
mozilla
:
:
widget
:
:
WindowType
;
auto
windowType
=
aWidget
-
>
GetWindowType
(
)
;
return
windowType
=
=
WindowType
:
:
TopLevel
|
|
windowType
=
=
WindowType
:
:
Dialog
|
|
windowType
=
=
WindowType
:
:
Popup
|
|
windowType
=
=
WindowType
:
:
Sheet
;
}
PresShell
:
:
WindowSizeConstraints
PresShell
:
:
GetWindowSizeConstraints
(
)
{
nsSize
minSize
(
0
0
)
;
nsSize
maxSize
(
NS_UNCONSTRAINEDSIZE
NS_UNCONSTRAINEDSIZE
)
;
nsIFrame
*
rootFrame
=
FrameConstructor
(
)
-
>
GetRootElementStyleFrame
(
)
;
if
(
!
rootFrame
|
|
!
mPresContext
)
{
return
{
minSize
maxSize
}
;
}
const
auto
*
pos
=
rootFrame
-
>
StylePosition
(
)
;
if
(
pos
-
>
mMinWidth
.
ConvertsToLength
(
)
)
{
minSize
.
width
=
pos
-
>
mMinWidth
.
ToLength
(
)
;
}
if
(
pos
-
>
mMinHeight
.
ConvertsToLength
(
)
)
{
minSize
.
height
=
pos
-
>
mMinHeight
.
ToLength
(
)
;
}
if
(
pos
-
>
mMaxWidth
.
ConvertsToLength
(
)
)
{
maxSize
.
width
=
pos
-
>
mMaxWidth
.
ToLength
(
)
;
}
if
(
pos
-
>
mMaxHeight
.
ConvertsToLength
(
)
)
{
maxSize
.
height
=
pos
-
>
mMaxHeight
.
ToLength
(
)
;
}
return
{
minSize
maxSize
}
;
}
void
PresShell
:
:
SyncWindowProperties
(
bool
aSync
)
{
nsView
*
view
=
mViewManager
-
>
GetRootView
(
)
;
if
(
!
view
|
|
!
view
-
>
HasWidget
(
)
)
{
return
;
}
RefPtr
pc
=
mPresContext
;
if
(
!
pc
)
{
return
;
}
nsCOMPtr
<
nsIWidget
>
windowWidget
=
GetPresContextContainerWidget
(
pc
)
;
if
(
!
windowWidget
|
|
!
IsTopLevelWidget
(
windowWidget
)
)
{
return
;
}
nsIFrame
*
rootFrame
=
FrameConstructor
(
)
-
>
GetRootElementStyleFrame
(
)
;
if
(
!
rootFrame
)
{
return
;
}
if
(
!
aSync
)
{
view
-
>
SetNeedsWindowPropertiesSync
(
)
;
return
;
}
AutoWeakFrame
weak
(
rootFrame
)
;
if
(
!
GetRootScrollFrame
(
)
)
{
auto
*
canvas
=
GetCanvasFrame
(
)
;
widget
:
:
TransparencyMode
mode
=
nsLayoutUtils
:
:
GetFrameTransparency
(
canvas
?
canvas
:
rootFrame
rootFrame
)
;
windowWidget
-
>
SetTransparencyMode
(
mode
)
;
if
(
auto
scheme
=
pc
-
>
GetOverriddenOrEmbedderColorScheme
(
)
)
{
windowWidget
-
>
SetColorScheme
(
scheme
)
;
}
}
if
(
!
weak
.
IsAlive
(
)
)
{
return
;
}
const
auto
&
constraints
=
GetWindowSizeConstraints
(
)
;
nsContainerFrame
:
:
SetSizeConstraints
(
pc
windowWidget
constraints
.
mMinSize
constraints
.
mMaxSize
)
;
}
nsresult
PresShell
:
:
HasRuleProcessorUsedByMultipleStyleSets
(
uint32_t
aSheetType
bool
*
aRetVal
)
{
*
aRetVal
=
false
;
return
NS_OK
;
}
void
PresShell
:
:
NotifyStyleSheetServiceSheetAdded
(
StyleSheet
*
aSheet
uint32_t
aSheetType
)
{
switch
(
aSheetType
)
{
case
nsIStyleSheetService
:
:
AGENT_SHEET
:
AddAgentSheet
(
aSheet
)
;
break
;
case
nsIStyleSheetService
:
:
USER_SHEET
:
AddUserSheet
(
aSheet
)
;
break
;
case
nsIStyleSheetService
:
:
AUTHOR_SHEET
:
AddAuthorSheet
(
aSheet
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
aSheetType
value
"
)
;
break
;
}
}
void
PresShell
:
:
NotifyStyleSheetServiceSheetRemoved
(
StyleSheet
*
aSheet
uint32_t
aSheetType
)
{
StyleSet
(
)
-
>
RemoveStyleSheet
(
*
aSheet
)
;
mDocument
-
>
ApplicableStylesChanged
(
)
;
}
nsIContent
*
PresShell
:
:
EventHandler
:
:
GetOverrideClickTarget
(
WidgetGUIEvent
*
aGUIEvent
nsIFrame
*
aFrame
)
{
if
(
aGUIEvent
-
>
mMessage
!
=
eMouseUp
)
{
return
nullptr
;
}
MOZ_ASSERT
(
aGUIEvent
-
>
mClass
=
=
eMouseEventClass
)
;
WidgetMouseEvent
*
mouseEvent
=
aGUIEvent
-
>
AsMouseEvent
(
)
;
uint32_t
flags
=
0
;
RelativeTo
relativeTo
{
aFrame
}
;
nsPoint
eventPoint
=
nsLayoutUtils
:
:
GetEventCoordinatesRelativeTo
(
aGUIEvent
relativeTo
)
;
if
(
mouseEvent
-
>
mIgnoreRootScrollFrame
)
{
flags
|
=
INPUT_IGNORE_ROOT_SCROLL_FRAME
;
}
nsIFrame
*
target
=
FindFrameTargetedByInputEvent
(
aGUIEvent
relativeTo
eventPoint
flags
)
;
if
(
!
target
)
{
return
nullptr
;
}
nsIContent
*
overrideClickTarget
=
target
-
>
GetContent
(
)
;
while
(
overrideClickTarget
&
&
!
overrideClickTarget
-
>
IsElement
(
)
)
{
overrideClickTarget
=
overrideClickTarget
-
>
GetFlattenedTreeParent
(
)
;
}
return
overrideClickTarget
;
}
void
PresShell
:
:
EventHandler
:
:
EventTargetData
:
:
SetFrameAndComputePresShell
(
nsIFrame
*
aFrameToHandleEvent
)
{
if
(
aFrameToHandleEvent
)
{
mFrame
=
aFrameToHandleEvent
;
mPresShell
=
aFrameToHandleEvent
-
>
PresShell
(
)
;
}
else
{
mFrame
=
nullptr
;
mPresShell
=
nullptr
;
}
}
void
PresShell
:
:
EventHandler
:
:
EventTargetData
:
:
SetFrameAndComputePresShellAndContent
(
nsIFrame
*
aFrameToHandleEvent
WidgetGUIEvent
*
aGUIEvent
)
{
MOZ_ASSERT
(
aFrameToHandleEvent
)
;
MOZ_ASSERT
(
aGUIEvent
)
;
SetFrameAndComputePresShell
(
aFrameToHandleEvent
)
;
SetContentForEventFromFrame
(
aGUIEvent
)
;
}
void
PresShell
:
:
EventHandler
:
:
EventTargetData
:
:
SetContentForEventFromFrame
(
WidgetGUIEvent
*
aGUIEvent
)
{
MOZ_ASSERT
(
mFrame
)
;
mContent
=
nullptr
;
mFrame
-
>
GetContentForEvent
(
aGUIEvent
getter_AddRefs
(
mContent
)
)
;
AssertIfEventTargetContentAndFrameContentMismatch
(
aGUIEvent
)
;
}
nsIContent
*
PresShell
:
:
EventHandler
:
:
EventTargetData
:
:
GetFrameContent
(
)
const
{
return
mFrame
?
mFrame
-
>
GetContent
(
)
:
nullptr
;
}
void
PresShell
:
:
EventHandler
:
:
EventTargetData
:
:
AssertIfEventTargetContentAndFrameContentMismatch
(
const
WidgetGUIEvent
*
aGUIEvent
)
const
{
#
ifdef
DEBUG
if
(
!
mContent
|
|
!
mFrame
|
|
!
mFrame
-
>
GetContent
(
)
)
{
return
;
}
if
(
aGUIEvent
)
{
nsCOMPtr
<
nsIContent
>
content
;
mFrame
-
>
GetContentForEvent
(
aGUIEvent
getter_AddRefs
(
content
)
)
;
MOZ_ASSERT
(
mContent
=
=
content
)
;
return
;
}
if
(
!
mContent
-
>
IsElement
(
)
)
{
MOZ_ASSERT
(
mContent
=
=
mFrame
-
>
GetContent
(
)
)
;
return
;
}
const
Element
*
const
closestInclusiveAncestorElement
=
[
&
]
(
)
-
>
const
Element
*
{
for
(
const
nsIContent
*
const
content
:
mFrame
-
>
GetContent
(
)
-
>
InclusiveFlatTreeAncestorsOfType
<
nsIContent
>
(
)
)
{
if
(
content
-
>
IsElement
(
)
)
{
return
content
-
>
AsElement
(
)
;
}
}
return
nullptr
;
}
(
)
;
if
(
closestInclusiveAncestorElement
=
=
mContent
)
{
return
;
}
if
(
closestInclusiveAncestorElement
-
>
IsInNativeAnonymousSubtree
(
)
&
&
(
mContent
=
=
closestInclusiveAncestorElement
-
>
FindFirstNonChromeOnlyAccessContent
(
)
)
)
{
return
;
}
NS_WARNING
(
nsPrintfCString
(
"
mContent
=
%
s
"
ToString
(
*
mContent
)
.
c_str
(
)
)
.
get
(
)
)
;
NS_WARNING
(
nsPrintfCString
(
"
mFrame
-
>
GetContent
(
)
=
%
s
"
ToString
(
*
mFrame
-
>
GetContent
(
)
)
.
c_str
(
)
)
.
get
(
)
)
;
MOZ_ASSERT
(
mContent
=
=
mFrame
-
>
GetContent
(
)
)
;
#
endif
}
bool
PresShell
:
:
EventHandler
:
:
EventTargetData
:
:
MaybeRetargetToActiveDocument
(
WidgetGUIEvent
*
aGUIEvent
)
{
MOZ_ASSERT
(
aGUIEvent
)
;
MOZ_ASSERT
(
mFrame
)
;
MOZ_ASSERT
(
mPresShell
)
;
MOZ_ASSERT
(
!
mContent
"
Doesn
'
t
support
to
retarget
the
content
"
)
;
EventStateManager
*
activeESM
=
EventStateManager
:
:
GetActiveEventStateManager
(
)
;
if
(
!
activeESM
)
{
return
false
;
}
if
(
aGUIEvent
-
>
mClass
!
=
ePointerEventClass
&
&
!
aGUIEvent
-
>
HasMouseEventMessage
(
)
)
{
return
false
;
}
if
(
activeESM
=
=
GetEventStateManager
(
)
)
{
return
false
;
}
nsPresContext
*
activePresContext
=
activeESM
-
>
GetPresContext
(
)
;
if
(
!
activePresContext
)
{
return
false
;
}
PresShell
*
activePresShell
=
activePresContext
-
>
GetPresShell
(
)
;
if
(
!
activePresShell
)
{
return
false
;
}
if
(
!
nsContentUtils
:
:
ContentIsCrossDocDescendantOf
(
activePresShell
-
>
GetDocument
(
)
GetDocument
(
)
)
)
{
return
false
;
}
SetFrameAndComputePresShell
(
activePresShell
-
>
GetRootFrame
(
)
)
;
return
true
;
}
bool
PresShell
:
:
EventHandler
:
:
EventTargetData
:
:
ComputeElementFromFrame
(
WidgetGUIEvent
*
aGUIEvent
)
{
MOZ_ASSERT
(
aGUIEvent
)
;
MOZ_ASSERT
(
aGUIEvent
-
>
IsUsingCoordinates
(
)
)
;
MOZ_ASSERT
(
mPresShell
)
;
MOZ_ASSERT
(
mFrame
)
;
SetContentForEventFromFrame
(
aGUIEvent
)
;
if
(
!
mContent
)
{
return
true
;
}
nsIContent
*
content
=
mContent
;
while
(
content
&
&
!
content
-
>
IsElement
(
)
)
{
content
=
content
-
>
GetFlattenedTreeParent
(
)
;
}
mContent
=
content
;
return
!
!
mContent
;
}
void
PresShell
:
:
EventHandler
:
:
EventTargetData
:
:
UpdateWheelEventTarget
(
WidgetGUIEvent
*
aGUIEvent
)
{
MOZ_ASSERT
(
aGUIEvent
)
;
if
(
aGUIEvent
-
>
mMessage
!
=
eWheel
)
{
return
;
}
nsIFrame
*
groupFrame
=
WheelTransaction
:
:
GetEventTargetFrame
(
)
;
if
(
!
groupFrame
)
{
return
;
}
if
(
!
groupFrame
-
>
PresContext
(
)
|
|
!
groupFrame
-
>
PresShell
(
)
|
|
groupFrame
-
>
PresContext
(
)
!
=
GetPresContext
(
)
)
{
return
;
}
SetFrameAndComputePresShellAndContent
(
groupFrame
aGUIEvent
)
;
}
void
PresShell
:
:
EventHandler
:
:
EventTargetData
:
:
UpdateTouchEventTarget
(
WidgetGUIEvent
*
aGUIEvent
)
{
MOZ_ASSERT
(
aGUIEvent
)
;
if
(
aGUIEvent
-
>
mClass
!
=
eTouchEventClass
)
{
return
;
}
if
(
aGUIEvent
-
>
mMessage
=
=
eTouchStart
)
{
WidgetTouchEvent
*
touchEvent
=
aGUIEvent
-
>
AsTouchEvent
(
)
;
nsIFrame
*
newFrame
=
TouchManager
:
:
SuppressInvalidPointsAndGetTargetedFrame
(
touchEvent
)
;
if
(
!
newFrame
)
{
return
;
}
SetFrameAndComputePresShellAndContent
(
newFrame
aGUIEvent
)
;
return
;
}
PresShell
*
newPresShell
=
PresShell
:
:
GetShellForTouchEvent
(
aGUIEvent
)
;
if
(
!
newPresShell
)
{
return
;
}
mPresShell
=
newPresShell
;
}
PresShell
:
:
EventHandler
:
:
HandlingTimeAccumulator
:
:
HandlingTimeAccumulator
(
const
PresShell
:
:
EventHandler
&
aEventHandler
const
WidgetEvent
*
aEvent
)
:
mEventHandler
(
aEventHandler
)
mEvent
(
aEvent
)
mHandlingStartTime
(
TimeStamp
:
:
Now
(
)
)
{
MOZ_ASSERT
(
mEvent
)
;
MOZ_ASSERT
(
mEvent
-
>
IsTrusted
(
)
)
;
}
PresShell
:
:
EventHandler
:
:
HandlingTimeAccumulator
:
:
~
HandlingTimeAccumulator
(
)
{
if
(
mEvent
-
>
mTimeStamp
<
=
mEventHandler
.
mPresShell
-
>
mLastOSWake
)
{
return
;
}
switch
(
mEvent
-
>
mMessage
)
{
case
eKeyPress
:
case
eKeyDown
:
case
eKeyUp
:
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
INPUT_EVENT_HANDLED_KEYBOARD_MS
mHandlingStartTime
)
;
return
;
case
eMouseDown
:
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
INPUT_EVENT_HANDLED_MOUSE_DOWN_MS
mHandlingStartTime
)
;
return
;
case
eMouseUp
:
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
INPUT_EVENT_HANDLED_MOUSE_UP_MS
mHandlingStartTime
)
;
return
;
case
eMouseMove
:
if
(
mEvent
-
>
mFlags
.
mHandledByAPZ
)
{
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
INPUT_EVENT_HANDLED_APZ_MOUSE_MOVE_MS
mHandlingStartTime
)
;
}
return
;
case
eWheel
:
if
(
mEvent
-
>
mFlags
.
mHandledByAPZ
)
{
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
INPUT_EVENT_HANDLED_APZ_WHEEL_MS
mHandlingStartTime
)
;
}
return
;
case
eTouchMove
:
if
(
mEvent
-
>
mFlags
.
mHandledByAPZ
)
{
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
INPUT_EVENT_HANDLED_APZ_TOUCH_MOVE_MS
mHandlingStartTime
)
;
}
return
;
default
:
return
;
}
}
void
PresShell
:
:
EndPaint
(
)
{
ClearPendingVisualScrollUpdate
(
)
;
if
(
mDocument
)
{
mDocument
-
>
EnumerateSubDocuments
(
[
]
(
Document
&
aSubDoc
)
{
if
(
PresShell
*
presShell
=
aSubDoc
.
GetPresShell
(
)
)
{
presShell
-
>
EndPaint
(
)
;
}
return
CallState
:
:
Continue
;
}
)
;
if
(
nsPresContext
*
presContext
=
GetPresContext
(
)
)
{
if
(
PerformanceMainThread
*
perf
=
presContext
-
>
GetPerformanceMainThread
(
)
)
{
perf
-
>
FinalizeLCPEntriesForText
(
)
;
}
}
}
}
void
PresShell
:
:
PingPerTickTelemetry
(
FlushType
aFlushType
)
{
mLayoutTelemetry
.
PingPerTickTelemetry
(
aFlushType
)
;
}
bool
PresShell
:
:
GetZoomableByAPZ
(
)
const
{
return
mZoomConstraintsClient
&
&
mZoomConstraintsClient
-
>
GetAllowZoom
(
)
;
}
bool
PresShell
:
:
ReflowForHiddenContentIfNeeded
(
)
{
if
(
mHiddenContentInForcedLayout
.
IsEmpty
(
)
)
{
return
false
;
}
mDocument
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
mHiddenContentInForcedLayout
.
Clear
(
)
;
return
true
;
}
void
PresShell
:
:
UpdateHiddenContentInForcedLayout
(
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
|
|
!
aFrame
-
>
IsSubtreeDirty
(
)
|
|
!
StaticPrefs
:
:
layout_css_content_visibility_enabled
(
)
)
{
return
;
}
nsIFrame
*
topmostFrameWithContentHidden
=
nullptr
;
for
(
nsIFrame
*
cur
=
aFrame
-
>
GetInFlowParent
(
)
;
cur
;
cur
=
cur
-
>
GetInFlowParent
(
)
)
{
if
(
cur
-
>
HidesContent
(
)
)
{
topmostFrameWithContentHidden
=
cur
;
mHiddenContentInForcedLayout
.
Insert
(
cur
-
>
GetContent
(
)
)
;
}
}
if
(
mHiddenContentInForcedLayout
.
IsEmpty
(
)
)
{
return
;
}
MOZ_ASSERT
(
topmostFrameWithContentHidden
)
;
FrameNeedsReflow
(
topmostFrameWithContentHidden
IntrinsicDirty
:
:
None
NS_FRAME_IS_DIRTY
)
;
}
void
PresShell
:
:
EnsureReflowIfFrameHasHiddenContent
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
mHiddenContentInForcedLayout
.
IsEmpty
(
)
)
;
UpdateHiddenContentInForcedLayout
(
aFrame
)
;
ReflowForHiddenContentIfNeeded
(
)
;
}
bool
PresShell
:
:
IsForcingLayoutForHiddenContent
(
const
nsIFrame
*
aFrame
)
const
{
return
mHiddenContentInForcedLayout
.
Contains
(
aFrame
-
>
GetContent
(
)
)
;
}
void
PresShell
:
:
UpdateRelevancyOfContentVisibilityAutoFrames
(
)
{
if
(
mContentVisibilityRelevancyToUpdate
.
isEmpty
(
)
)
{
return
;
}
for
(
nsIFrame
*
frame
:
mContentVisibilityAutoFrames
)
{
frame
-
>
UpdateIsRelevantContent
(
mContentVisibilityRelevancyToUpdate
)
;
}
if
(
nsPresContext
*
presContext
=
GetPresContext
(
)
)
{
presContext
-
>
UpdateHiddenByContentVisibilityForAnimationsIfNeeded
(
)
;
}
mContentVisibilityRelevancyToUpdate
.
clear
(
)
;
}
void
PresShell
:
:
ScheduleContentRelevancyUpdate
(
ContentRelevancyReason
aReason
)
{
if
(
MOZ_UNLIKELY
(
mIsDestroying
)
)
{
return
;
}
mContentVisibilityRelevancyToUpdate
+
=
aReason
;
SetNeedLayoutFlush
(
)
;
if
(
nsPresContext
*
presContext
=
GetPresContext
(
)
)
{
presContext
-
>
RefreshDriver
(
)
-
>
EnsureContentRelevancyUpdateHappens
(
)
;
}
}
PresShell
:
:
ProximityToViewportResult
PresShell
:
:
DetermineProximityToViewport
(
)
{
ProximityToViewportResult
result
;
if
(
mContentVisibilityAutoFrames
.
IsEmpty
(
)
)
{
return
result
;
}
auto
margin
=
LengthPercentage
:
:
FromPercentage
(
StaticPrefs
:
:
layout_css_content_visibility_relevant_content_margin
(
)
/
100
.
0f
)
;
auto
rootMargin
=
StyleRect
<
LengthPercentage
>
:
:
WithAllSides
(
margin
)
;
auto
input
=
DOMIntersectionObserver
:
:
ComputeInput
(
*
mDocument
nullptr
&
rootMargin
)
;
for
(
nsIFrame
*
frame
:
mContentVisibilityAutoFrames
)
{
auto
*
element
=
frame
-
>
GetContent
(
)
-
>
AsElement
(
)
;
result
.
mAnyScrollIntoViewFlag
|
=
element
-
>
TemporarilyVisibleForScrolledIntoViewDescendant
(
)
;
Maybe
<
bool
>
oldVisibility
=
element
-
>
GetVisibleForContentVisibility
(
)
;
bool
checkForInitialDetermination
=
oldVisibility
.
isNothing
(
)
&
&
(
element
-
>
GetContentRelevancy
(
)
.
isNothing
(
)
|
|
element
-
>
GetContentRelevancy
(
)
-
>
isEmpty
(
)
)
;
bool
intersects
=
DOMIntersectionObserver
:
:
Intersect
(
input
*
element
DOMIntersectionObserver
:
:
IsForProximityToViewport
:
:
Yes
)
.
Intersects
(
)
;
element
-
>
SetVisibleForContentVisibility
(
intersects
)
;
if
(
oldVisibility
.
isNothing
(
)
|
|
*
oldVisibility
!
=
intersects
)
{
frame
-
>
UpdateIsRelevantContent
(
ContentRelevancyReason
:
:
Visible
)
;
}
if
(
checkForInitialDetermination
&
&
intersects
)
{
result
.
mHadInitialDetermination
=
true
;
}
}
if
(
nsPresContext
*
presContext
=
GetPresContext
(
)
)
{
presContext
-
>
UpdateHiddenByContentVisibilityForAnimationsIfNeeded
(
)
;
}
return
result
;
}
void
PresShell
:
:
ClearTemporarilyVisibleForScrolledIntoViewDescendantFlags
(
)
const
{
for
(
nsIFrame
*
frame
:
mContentVisibilityAutoFrames
)
{
frame
-
>
GetContent
(
)
-
>
AsElement
(
)
-
>
SetTemporarilyVisibleForScrolledIntoViewDescendant
(
false
)
;
}
}
void
PresShell
:
:
UpdateContentRelevancyImmediately
(
ContentRelevancyReason
aReason
)
{
if
(
MOZ_UNLIKELY
(
mIsDestroying
)
)
{
return
;
}
mContentVisibilityRelevancyToUpdate
+
=
aReason
;
SetNeedLayoutFlush
(
)
;
UpdateRelevancyOfContentVisibilityAutoFrames
(
)
;
}
