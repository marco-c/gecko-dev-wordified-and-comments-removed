#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
Units
.
h
"
#
include
"
mozilla
/
dom
/
FontFaceSet
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
ContentIterator
.
h
"
#
include
"
mozilla
/
DisplayPortUtils
.
h
"
#
include
"
mozilla
/
EventDispatcher
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
GeckoMVMContext
.
h
"
#
include
"
mozilla
/
IMEStateManager
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
dom
/
BrowserChild
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
Logging
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
PerfStats
.
h
"
#
include
"
mozilla
/
PointerLockManager
.
h
"
#
include
"
mozilla
/
PresShellInlines
.
h
"
#
include
"
mozilla
/
RangeUtils
.
h
"
#
include
"
mozilla
/
ScopeExit
.
h
"
#
include
"
mozilla
/
Sprintf
.
h
"
#
include
"
mozilla
/
StaticAnalysisFunctions
.
h
"
#
include
"
mozilla
/
StaticPrefs_apz
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
StaticPrefs_font
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
TouchEvents
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
ViewportUtils
.
h
"
#
include
<
algorithm
>
#
ifdef
XP_WIN
#
include
"
winuser
.
h
"
#
endif
#
include
"
gfxContext
.
h
"
#
include
"
gfxUserFontSet
.
h
"
#
include
"
nsContentList
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
mozilla
/
dom
/
BrowserBridgeChild
.
h
"
#
include
"
mozilla
/
dom
/
BrowsingContext
.
h
"
#
include
"
mozilla
/
dom
/
CanonicalBrowsingContext
.
h
"
#
include
"
mozilla
/
dom
/
ContentChild
.
h
"
#
include
"
mozilla
/
dom
/
ContentParent
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
PointerEventHandler
.
h
"
#
include
"
mozilla
/
dom
/
PopupBlocker
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
include
"
mozilla
/
dom
/
UserActivation
.
h
"
#
include
"
nsAnimationManager
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsFlexContainerFrame
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
FrameLayerBuilder
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsView
.
h
"
#
include
"
nsCRTGlue
.
h
"
#
include
"
prinrval
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
nsWindowSizes
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsReadableUtils
.
h
"
#
include
"
nsPageSequenceFrame
.
h
"
#
include
"
nsCaret
.
h
"
#
include
"
mozilla
/
AccessibleCaretEventHub
.
h
"
#
include
"
nsFrameManager
.
h
"
#
include
"
nsXPCOM
.
h
"
#
include
"
nsILayoutHistoryState
.
h
"
#
include
"
nsILineIterator
.
h
"
#
include
"
PLDHashTable
.
h
"
#
include
"
mozilla
/
dom
/
Touch
.
h
"
#
include
"
mozilla
/
dom
/
TouchEvent
.
h
"
#
include
"
mozilla
/
dom
/
PointerEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
ShadowIncludingTreeIterator
.
h
"
#
include
"
nsIObserverService
.
h
"
#
include
"
nsDocShell
.
h
"
#
include
"
nsIBaseWindow
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsViewportInfo
.
h
"
#
include
"
nsCSSRendering
.
h
"
#
include
"
prenv
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nsAutoLayoutPhase
.
h
"
#
ifdef
MOZ_GECKO_PROFILER
#
include
"
AutoProfilerStyleMarker
.
h
"
#
endif
#
ifdef
MOZ_REFLOW_PERF
#
include
"
nsFontMetrics
.
h
"
#
endif
#
include
"
MobileViewportManager
.
h
"
#
include
"
OverflowChangedTracker
.
h
"
#
include
"
PositionedEventTargeting
.
h
"
#
include
"
nsIReflowCallback
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsStyleSheetService
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
mozilla
/
SMILAnimationController
.
h
"
#
include
"
mozilla
/
dom
/
SVGAnimationElement
.
h
"
#
include
"
mozilla
/
SVGObserverUtils
.
h
"
#
include
"
mozilla
/
SVGFragmentIdentifier
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
mozilla
/
dom
/
Performance
.
h
"
#
include
"
nsRefreshDriver
.
h
"
#
include
"
nsDOMNavigationTiming
.
h
"
#
include
"
nsIDocShellTreeItem
.
h
"
#
include
"
nsIURI
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsITimer
.
h
"
#
ifdef
ACCESSIBILITY
#
include
"
nsAccessibilityService
.
h
"
#
include
"
mozilla
/
a11y
/
DocAccessible
.
h
"
#
ifdef
DEBUG
#
include
"
mozilla
/
a11y
/
Logging
.
h
"
#
endif
#
endif
#
include
"
nsStyleChangeList
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
ifdef
MOZ_XUL
#
include
"
nsMenuFrame
.
h
"
#
include
"
nsTreeBodyFrame
.
h
"
#
include
"
XULTreeElement
.
h
"
#
include
"
nsMenuPopupFrame
.
h
"
#
include
"
nsTreeColumns
.
h
"
#
include
"
nsIDOMXULMultSelectCntrlEl
.
h
"
#
include
"
nsIDOMXULSelectCntrlItemEl
.
h
"
#
include
"
nsIDOMXULMenuListElement
.
h
"
#
include
"
nsXULElement
.
h
"
#
endif
#
include
"
mozilla
/
layers
/
CompositorBridgeChild
.
h
"
#
include
"
ClientLayerManager
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
Layers
.
h
"
#
include
"
LayerTreeInvalidation
.
h
"
#
include
"
mozilla
/
css
/
ImageLoader
.
h
"
#
include
"
mozilla
/
dom
/
DocumentTimeline
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
Telemetry
.
h
"
#
include
"
nsCanvasFrame
.
h
"
#
include
"
nsImageFrame
.
h
"
#
include
"
nsIScreen
.
h
"
#
include
"
nsIScreenManager
.
h
"
#
include
"
nsPlaceholderFrame
.
h
"
#
include
"
nsTransitionManager
.
h
"
#
include
"
ChildIterator
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
nsIDragSession
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
nsSubDocumentFrame
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
mozilla
/
GlobalStyleSheetCache
.
h
"
#
include
"
mozilla
/
layers
/
InputAPZContext
.
h
"
#
include
"
mozilla
/
layers
/
ScrollInputMethods
.
h
"
#
include
"
mozilla
/
layers
/
FocusTarget
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderLayerManager
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderUserData
.
h
"
#
include
"
mozilla
/
layout
/
ScrollAnchorContainer
.
h
"
#
include
"
mozilla
/
ProfilerLabels
.
h
"
#
include
"
mozilla
/
ProfilerMarkers
.
h
"
#
include
"
mozilla
/
ScrollTypes
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
mozilla
/
StyleSheet
.
h
"
#
include
"
mozilla
/
StyleSheetInlines
.
h
"
#
include
"
mozilla
/
InputTaskManager
.
h
"
#
include
"
mozilla
/
dom
/
ImageTracker
.
h
"
#
include
"
nsIDocShellTreeOwner
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
VisualViewport
.
h
"
#
include
"
ZoomConstraintsClient
.
h
"
#
ifdef
MOZ_TASK_TRACER
#
include
"
GeckoTaskTracer
.
h
"
using
namespace
mozilla
:
:
tasktracer
;
#
endif
#
define
RELATIVE_SCALEFACTOR
0
.
0925f
using
namespace
mozilla
;
using
namespace
mozilla
:
:
css
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
layout
;
using
PaintFrameFlags
=
nsLayoutUtils
:
:
PaintFrameFlags
;
typedef
ScrollableLayerGuid
:
:
ViewID
ViewID
;
PresShell
:
:
CapturingContentInfo
PresShell
:
:
sCapturingContentInfo
;
struct
RangePaintInfo
{
RefPtr
<
nsRange
>
mRange
;
nsDisplayListBuilder
mBuilder
;
nsDisplayList
mList
;
nsPoint
mRootOffset
;
float
mResolution
=
1
.
0
;
RangePaintInfo
(
nsRange
*
aRange
nsIFrame
*
aFrame
)
:
mRange
(
aRange
)
mBuilder
(
aFrame
nsDisplayListBuilderMode
:
:
Painting
false
)
{
MOZ_COUNT_CTOR
(
RangePaintInfo
)
;
mBuilder
.
BeginFrame
(
)
;
}
~
RangePaintInfo
(
)
{
mList
.
DeleteAll
(
&
mBuilder
)
;
mBuilder
.
EndFrame
(
)
;
MOZ_COUNT_DTOR
(
RangePaintInfo
)
;
}
}
;
#
undef
NOISY
#
ifdef
DEBUG
static
VerifyReflowFlags
gVerifyReflowFlags
;
struct
VerifyReflowFlagData
{
const
char
*
name
;
VerifyReflowFlags
bit
;
}
;
static
const
VerifyReflowFlagData
gFlags
[
]
=
{
{
"
verify
"
VerifyReflowFlags
:
:
On
}
{
"
reflow
"
VerifyReflowFlags
:
:
Noisy
}
{
"
all
"
VerifyReflowFlags
:
:
All
}
{
"
list
-
commands
"
VerifyReflowFlags
:
:
DumpCommands
}
{
"
noisy
-
commands
"
VerifyReflowFlags
:
:
NoisyCommands
}
{
"
really
-
noisy
-
commands
"
VerifyReflowFlags
:
:
ReallyNoisyCommands
}
{
"
resize
"
VerifyReflowFlags
:
:
DuringResizeReflow
}
}
;
#
define
NUM_VERIFY_REFLOW_FLAGS
(
sizeof
(
gFlags
)
/
sizeof
(
gFlags
[
0
]
)
)
static
void
ShowVerifyReflowFlags
(
)
{
printf
(
"
Here
are
the
available
GECKO_VERIFY_REFLOW_FLAGS
:
\
n
"
)
;
const
VerifyReflowFlagData
*
flag
=
gFlags
;
const
VerifyReflowFlagData
*
limit
=
gFlags
+
NUM_VERIFY_REFLOW_FLAGS
;
while
(
flag
<
limit
)
{
printf
(
"
%
s
\
n
"
flag
-
>
name
)
;
+
+
flag
;
}
printf
(
"
Note
:
GECKO_VERIFY_REFLOW_FLAGS
is
a
comma
separated
list
of
flag
\
n
"
)
;
printf
(
"
names
(
no
whitespace
)
\
n
"
)
;
}
#
endif
#
ifdef
MOZ_REFLOW_PERF
class
ReflowCountMgr
;
static
const
char
kGrandTotalsStr
[
]
=
"
Grand
Totals
"
;
class
ReflowCounter
{
public
:
explicit
ReflowCounter
(
ReflowCountMgr
*
aMgr
=
nullptr
)
;
~
ReflowCounter
(
)
;
void
ClearTotals
(
)
;
void
DisplayTotals
(
const
char
*
aStr
)
;
void
DisplayDiffTotals
(
const
char
*
aStr
)
;
void
DisplayHTMLTotals
(
const
char
*
aStr
)
;
void
Add
(
)
{
mTotal
+
+
;
}
void
Add
(
uint32_t
aTotal
)
{
mTotal
+
=
aTotal
;
}
void
CalcDiffInTotals
(
)
;
void
SetTotalsCache
(
)
;
void
SetMgr
(
ReflowCountMgr
*
aMgr
)
{
mMgr
=
aMgr
;
}
uint32_t
GetTotal
(
)
{
return
mTotal
;
}
protected
:
void
DisplayTotals
(
uint32_t
aTotal
const
char
*
aTitle
)
;
void
DisplayHTMLTotals
(
uint32_t
aTotal
const
char
*
aTitle
)
;
uint32_t
mTotal
;
uint32_t
mCacheTotal
;
ReflowCountMgr
*
mMgr
;
}
;
class
IndiReflowCounter
{
public
:
explicit
IndiReflowCounter
(
ReflowCountMgr
*
aMgr
=
nullptr
)
:
mFrame
(
nullptr
)
mCount
(
0
)
mMgr
(
aMgr
)
mCounter
(
aMgr
)
mHasBeenOutput
(
false
)
{
}
virtual
~
IndiReflowCounter
(
)
=
default
;
nsAutoString
mName
;
nsIFrame
*
mFrame
;
int32_t
mCount
;
ReflowCountMgr
*
mMgr
;
ReflowCounter
mCounter
;
bool
mHasBeenOutput
;
}
;
class
ReflowCountMgr
{
public
:
ReflowCountMgr
(
)
;
virtual
~
ReflowCountMgr
(
)
;
void
ClearTotals
(
)
;
void
ClearGrandTotals
(
)
;
void
DisplayTotals
(
const
char
*
aStr
)
;
void
DisplayHTMLTotals
(
const
char
*
aStr
)
;
void
DisplayDiffsInTotals
(
)
;
void
Add
(
const
char
*
aName
nsIFrame
*
aFrame
)
;
ReflowCounter
*
LookUp
(
const
char
*
aName
)
;
void
PaintCount
(
const
char
*
aName
gfxContext
*
aRenderingContext
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
const
nsPoint
&
aOffset
uint32_t
aColor
)
;
FILE
*
GetOutFile
(
)
{
return
mFD
;
}
void
SetPresContext
(
nsPresContext
*
aPresContext
)
{
mPresContext
=
aPresContext
;
}
void
SetPresShell
(
PresShell
*
aPresShell
)
{
mPresShell
=
aPresShell
;
}
void
SetDumpFrameCounts
(
bool
aVal
)
{
mDumpFrameCounts
=
aVal
;
}
void
SetDumpFrameByFrameCounts
(
bool
aVal
)
{
mDumpFrameByFrameCounts
=
aVal
;
}
void
SetPaintFrameCounts
(
bool
aVal
)
{
mPaintFrameByFrameCounts
=
aVal
;
}
bool
IsPaintingFrameCounts
(
)
{
return
mPaintFrameByFrameCounts
;
}
protected
:
void
DisplayTotals
(
uint32_t
aTotal
uint32_t
*
aDupArray
char
*
aTitle
)
;
void
DisplayHTMLTotals
(
uint32_t
aTotal
uint32_t
*
aDupArray
char
*
aTitle
)
;
void
DoGrandTotals
(
)
;
void
DoIndiTotalsTree
(
)
;
void
DoGrandHTMLTotals
(
)
;
nsClassHashtable
<
nsCharPtrHashKey
ReflowCounter
>
mCounts
;
nsClassHashtable
<
nsCharPtrHashKey
IndiReflowCounter
>
mIndiFrameCounts
;
FILE
*
mFD
;
bool
mDumpFrameCounts
;
bool
mDumpFrameByFrameCounts
;
bool
mPaintFrameByFrameCounts
;
bool
mCycledOnce
;
nsPresContext
*
mPresContext
;
PresShell
*
mPresShell
;
}
;
#
endif
#
define
SHOW_CARET
#
define
NS_MAX_REFLOW_TIME
1000000
static
int32_t
gMaxRCProcessingTime
=
-
1
;
struct
nsCallbackEventRequest
{
nsIReflowCallback
*
callback
;
nsCallbackEventRequest
*
next
;
}
;
#
ifdef
DEBUG
#
define
ASSERT_REFLOW_SCHEDULED_STATE
(
)
\
{
\
if
(
ObservingLayoutFlushes
(
)
)
{
\
MOZ_ASSERT
(
\
mDocument
-
>
GetBFCacheEntry
(
)
|
|
\
mPresContext
-
>
RefreshDriver
(
)
-
>
IsLayoutFlushObserver
(
this
)
\
"
Unexpected
state
"
)
;
\
}
else
{
\
MOZ_ASSERT
(
\
!
mPresContext
-
>
RefreshDriver
(
)
-
>
IsLayoutFlushObserver
(
this
)
\
"
Unexpected
state
"
)
;
\
}
\
}
#
else
#
define
ASSERT_REFLOW_SCHEDULED_STATE
(
)
#
endif
class
nsAutoCauseReflowNotifier
{
public
:
MOZ_CAN_RUN_SCRIPT
explicit
nsAutoCauseReflowNotifier
(
PresShell
*
aPresShell
)
:
mPresShell
(
aPresShell
)
{
mPresShell
-
>
WillCauseReflow
(
)
;
}
MOZ_CAN_RUN_SCRIPT
~
nsAutoCauseReflowNotifier
(
)
{
if
(
!
mPresShell
-
>
mHaveShutDown
)
{
RefPtr
<
PresShell
>
presShell
(
mPresShell
)
;
presShell
-
>
DidCauseReflow
(
)
;
}
else
{
nsContentUtils
:
:
RemoveScriptBlocker
(
)
;
}
}
PresShell
*
mPresShell
;
}
;
class
MOZ_STACK_CLASS
nsPresShellEventCB
:
public
EventDispatchingCallback
{
public
:
explicit
nsPresShellEventCB
(
PresShell
*
aPresShell
)
:
mPresShell
(
aPresShell
)
{
}
MOZ_CAN_RUN_SCRIPT
virtual
void
HandleEvent
(
EventChainPostVisitor
&
aVisitor
)
override
{
if
(
aVisitor
.
mPresContext
&
&
aVisitor
.
mEvent
-
>
mClass
!
=
eBasicEventClass
)
{
if
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eMouseDown
|
|
aVisitor
.
mEvent
-
>
mMessage
=
=
eMouseUp
)
{
MOZ_KnownLive
(
mPresShell
)
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
}
else
if
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eWheel
&
&
aVisitor
.
mEventStatus
!
=
nsEventStatus_eConsumeNoDefault
)
{
nsIFrame
*
frame
=
mPresShell
-
>
GetCurrentEventFrame
(
)
;
if
(
frame
)
{
RefPtr
<
EventStateManager
>
esm
=
aVisitor
.
mPresContext
-
>
EventStateManager
(
)
;
esm
-
>
DispatchLegacyMouseScrollEvents
(
frame
aVisitor
.
mEvent
-
>
AsWheelEvent
(
)
&
aVisitor
.
mEventStatus
)
;
}
}
nsIFrame
*
frame
=
mPresShell
-
>
GetCurrentEventFrame
(
)
;
if
(
!
frame
&
&
(
aVisitor
.
mEvent
-
>
mMessage
=
=
eMouseUp
|
|
aVisitor
.
mEvent
-
>
mMessage
=
=
eTouchEnd
)
)
{
frame
=
mPresShell
-
>
GetRootFrame
(
)
;
}
if
(
frame
)
{
frame
-
>
HandleEvent
(
aVisitor
.
mPresContext
aVisitor
.
mEvent
-
>
AsGUIEvent
(
)
&
aVisitor
.
mEventStatus
)
;
}
}
}
RefPtr
<
PresShell
>
mPresShell
;
}
;
class
nsBeforeFirstPaintDispatcher
:
public
Runnable
{
public
:
explicit
nsBeforeFirstPaintDispatcher
(
Document
*
aDocument
)
:
mozilla
:
:
Runnable
(
"
nsBeforeFirstPaintDispatcher
"
)
mDocument
(
aDocument
)
{
}
NS_IMETHOD
Run
(
)
override
{
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
NotifyObservers
(
ToSupports
(
mDocument
)
"
before
-
first
-
paint
"
nullptr
)
;
}
return
NS_OK
;
}
private
:
RefPtr
<
Document
>
mDocument
;
}
;
class
MOZ_STACK_CLASS
AutoPointerEventTargetUpdater
final
{
public
:
AutoPointerEventTargetUpdater
(
PresShell
*
aShell
WidgetEvent
*
aEvent
nsIFrame
*
aFrame
nsIContent
*
*
aTargetContent
)
{
MOZ_ASSERT
(
aEvent
)
;
if
(
!
aTargetContent
|
|
aEvent
-
>
mClass
!
=
ePointerEventClass
)
{
mTargetContent
=
nullptr
;
return
;
}
MOZ_ASSERT
(
aShell
)
;
MOZ_ASSERT
(
aFrame
)
;
MOZ_ASSERT
(
!
aFrame
-
>
GetContent
(
)
|
|
aShell
-
>
GetDocument
(
)
=
=
aFrame
-
>
GetContent
(
)
-
>
OwnerDoc
(
)
)
;
mShell
=
aShell
;
mWeakFrame
=
aFrame
;
mTargetContent
=
aTargetContent
;
aShell
-
>
mPointerEventTarget
=
aFrame
-
>
GetContent
(
)
;
}
~
AutoPointerEventTargetUpdater
(
)
{
if
(
!
mTargetContent
|
|
!
mShell
|
|
mWeakFrame
.
IsAlive
(
)
)
{
return
;
}
mShell
-
>
mPointerEventTarget
.
swap
(
*
mTargetContent
)
;
}
private
:
RefPtr
<
PresShell
>
mShell
;
AutoWeakFrame
mWeakFrame
;
nsIContent
*
*
mTargetContent
;
}
;
void
PresShell
:
:
DirtyRootsList
:
:
Add
(
nsIFrame
*
aFrame
)
{
if
(
mList
.
Contains
(
aFrame
)
)
{
MOZ_ASSERT
(
aFrame
-
>
GetDepthInFrameTree
(
)
=
=
mList
[
mList
.
IndexOf
(
aFrame
)
]
.
mDepth
)
;
return
;
}
mList
.
InsertElementSorted
(
FrameAndDepth
{
aFrame
aFrame
-
>
GetDepthInFrameTree
(
)
}
FrameAndDepth
:
:
CompareByReverseDepth
{
}
)
;
}
void
PresShell
:
:
DirtyRootsList
:
:
Remove
(
nsIFrame
*
aFrame
)
{
mList
.
RemoveElement
(
aFrame
)
;
}
nsIFrame
*
PresShell
:
:
DirtyRootsList
:
:
PopShallowestRoot
(
)
{
const
FrameAndDepth
&
lastFAD
=
mList
.
PopLastElement
(
)
;
nsIFrame
*
frame
=
lastFAD
.
mFrame
;
MOZ_ASSERT
(
frame
-
>
GetDepthInFrameTree
(
)
=
=
lastFAD
.
mDepth
)
;
return
frame
;
}
void
PresShell
:
:
DirtyRootsList
:
:
Clear
(
)
{
mList
.
Clear
(
)
;
}
bool
PresShell
:
:
DirtyRootsList
:
:
Contains
(
nsIFrame
*
aFrame
)
const
{
return
mList
.
Contains
(
aFrame
)
;
}
bool
PresShell
:
:
DirtyRootsList
:
:
IsEmpty
(
)
const
{
return
mList
.
IsEmpty
(
)
;
}
bool
PresShell
:
:
DirtyRootsList
:
:
FrameIsAncestorOfDirtyRoot
(
nsIFrame
*
aFrame
)
const
{
MOZ_ASSERT
(
aFrame
)
;
for
(
nsIFrame
*
dirtyFrame
:
mList
)
{
do
{
if
(
dirtyFrame
=
=
aFrame
)
{
return
true
;
}
dirtyFrame
=
dirtyFrame
-
>
GetParent
(
)
;
}
while
(
dirtyFrame
)
;
}
return
false
;
}
bool
PresShell
:
:
sDisableNonTestMouseEvents
=
false
;
LazyLogModule
PresShell
:
:
gLog
(
"
PresShell
"
)
;
TimeStamp
PresShell
:
:
EventHandler
:
:
sLastInputCreated
;
TimeStamp
PresShell
:
:
EventHandler
:
:
sLastInputProcessed
;
StaticRefPtr
<
Element
>
PresShell
:
:
EventHandler
:
:
sLastKeyDownEventTargetElement
;
bool
PresShell
:
:
sProcessInteractable
=
false
;
static
bool
gVerifyReflowEnabled
;
extern
mozilla
:
:
LazyLogModule
sApzMvmLog
;
bool
PresShell
:
:
GetVerifyReflowEnable
(
)
{
#
ifdef
DEBUG
static
bool
firstTime
=
true
;
if
(
firstTime
)
{
firstTime
=
false
;
char
*
flags
=
PR_GetEnv
(
"
GECKO_VERIFY_REFLOW_FLAGS
"
)
;
if
(
flags
)
{
bool
error
=
false
;
for
(
;
;
)
{
char
*
comma
=
PL_strchr
(
flags
'
'
)
;
if
(
comma
)
*
comma
=
'
\
0
'
;
bool
found
=
false
;
const
VerifyReflowFlagData
*
flag
=
gFlags
;
const
VerifyReflowFlagData
*
limit
=
gFlags
+
NUM_VERIFY_REFLOW_FLAGS
;
while
(
flag
<
limit
)
{
if
(
PL_strcasecmp
(
flag
-
>
name
flags
)
=
=
0
)
{
gVerifyReflowFlags
|
=
flag
-
>
bit
;
found
=
true
;
break
;
}
+
+
flag
;
}
if
(
!
found
)
error
=
true
;
if
(
!
comma
)
break
;
*
comma
=
'
'
;
flags
=
comma
+
1
;
}
if
(
error
)
ShowVerifyReflowFlags
(
)
;
}
if
(
VerifyReflowFlags
:
:
On
&
gVerifyReflowFlags
)
{
gVerifyReflowEnabled
=
true
;
printf
(
"
Note
:
verifyreflow
is
enabled
"
)
;
if
(
VerifyReflowFlags
:
:
Noisy
&
gVerifyReflowFlags
)
{
printf
(
"
(
noisy
)
"
)
;
}
if
(
VerifyReflowFlags
:
:
All
&
gVerifyReflowFlags
)
{
printf
(
"
(
all
)
"
)
;
}
if
(
VerifyReflowFlags
:
:
DumpCommands
&
gVerifyReflowFlags
)
{
printf
(
"
(
show
reflow
commands
)
"
)
;
}
if
(
VerifyReflowFlags
:
:
NoisyCommands
&
gVerifyReflowFlags
)
{
printf
(
"
(
noisy
reflow
commands
)
"
)
;
if
(
VerifyReflowFlags
:
:
ReallyNoisyCommands
&
gVerifyReflowFlags
)
{
printf
(
"
(
REALLY
noisy
reflow
commands
)
"
)
;
}
}
printf
(
"
\
n
"
)
;
}
}
#
endif
return
gVerifyReflowEnabled
;
}
void
PresShell
:
:
SetVerifyReflowEnable
(
bool
aEnabled
)
{
gVerifyReflowEnabled
=
aEnabled
;
}
void
PresShell
:
:
AddAutoWeakFrame
(
AutoWeakFrame
*
aWeakFrame
)
{
if
(
aWeakFrame
-
>
GetFrame
(
)
)
{
aWeakFrame
-
>
GetFrame
(
)
-
>
AddStateBits
(
NS_FRAME_EXTERNAL_REFERENCE
)
;
}
aWeakFrame
-
>
SetPreviousWeakFrame
(
mAutoWeakFrames
)
;
mAutoWeakFrames
=
aWeakFrame
;
}
void
PresShell
:
:
AddWeakFrame
(
WeakFrame
*
aWeakFrame
)
{
if
(
aWeakFrame
-
>
GetFrame
(
)
)
{
aWeakFrame
-
>
GetFrame
(
)
-
>
AddStateBits
(
NS_FRAME_EXTERNAL_REFERENCE
)
;
}
MOZ_ASSERT
(
!
mWeakFrames
.
Contains
(
aWeakFrame
)
)
;
mWeakFrames
.
Insert
(
aWeakFrame
)
;
}
void
PresShell
:
:
RemoveAutoWeakFrame
(
AutoWeakFrame
*
aWeakFrame
)
{
if
(
mAutoWeakFrames
=
=
aWeakFrame
)
{
mAutoWeakFrames
=
aWeakFrame
-
>
GetPreviousWeakFrame
(
)
;
return
;
}
AutoWeakFrame
*
nextWeak
=
mAutoWeakFrames
;
while
(
nextWeak
&
&
nextWeak
-
>
GetPreviousWeakFrame
(
)
!
=
aWeakFrame
)
{
nextWeak
=
nextWeak
-
>
GetPreviousWeakFrame
(
)
;
}
if
(
nextWeak
)
{
nextWeak
-
>
SetPreviousWeakFrame
(
aWeakFrame
-
>
GetPreviousWeakFrame
(
)
)
;
}
}
void
PresShell
:
:
RemoveWeakFrame
(
WeakFrame
*
aWeakFrame
)
{
MOZ_ASSERT
(
mWeakFrames
.
Contains
(
aWeakFrame
)
)
;
mWeakFrames
.
Remove
(
aWeakFrame
)
;
}
already_AddRefed
<
nsFrameSelection
>
PresShell
:
:
FrameSelection
(
)
{
RefPtr
<
nsFrameSelection
>
ret
=
mSelection
;
return
ret
.
forget
(
)
;
}
static
uint32_t
sNextPresShellId
;
bool
PresShell
:
:
AccessibleCaretEnabled
(
nsIDocShell
*
aDocShell
)
{
if
(
StaticPrefs
:
:
layout_accessiblecaret_enabled
(
)
)
{
return
true
;
}
if
(
StaticPrefs
:
:
layout_accessiblecaret_enabled_on_touch
(
)
&
&
dom
:
:
TouchEvent
:
:
PrefEnabled
(
aDocShell
)
)
{
return
true
;
}
return
false
;
}
PresShell
:
:
PresShell
(
Document
*
aDocument
)
:
mDocument
(
aDocument
)
mViewManager
(
nullptr
)
mFrameManager
(
nullptr
)
mAutoWeakFrames
(
nullptr
)
#
ifdef
ACCESSIBILITY
mDocAccessible
(
nullptr
)
#
endif
mCurrentEventFrame
(
nullptr
)
mMouseLocation
(
NS_UNCONSTRAINEDSIZE
NS_UNCONSTRAINEDSIZE
)
mPaintCount
(
0
)
mAPZFocusSequenceNumber
(
0
)
mCanvasBackgroundColor
(
NS_RGBA
(
0
0
0
0
)
)
mActiveSuppressDisplayport
(
0
)
mPresShellId
(
sNextPresShellId
+
+
)
mFontSizeInflationEmPerLine
(
0
)
mFontSizeInflationMinTwips
(
0
)
mFontSizeInflationLineThreshold
(
0
)
mSelectionFlags
(
nsISelectionDisplay
:
:
DISPLAY_TEXT
|
nsISelectionDisplay
:
:
DISPLAY_IMAGES
)
mChangeNestCount
(
0
)
mRenderingStateFlags
(
RenderingStateFlags
:
:
None
)
mInFlush
(
false
)
mCaretEnabled
(
false
)
mNeedLayoutFlush
(
true
)
mNeedStyleFlush
(
true
)
mNeedThrottledAnimationFlush
(
true
)
mVisualViewportSizeSet
(
false
)
mDidInitialize
(
false
)
mIsDestroying
(
false
)
mIsReflowing
(
false
)
mIsObservingDocument
(
false
)
mForbiddenToFlush
(
false
)
mIsDocumentGone
(
false
)
mHaveShutDown
(
false
)
mPaintingSuppressed
(
false
)
mLastRootReflowHadUnconstrainedBSize
(
false
)
mShouldUnsuppressPainting
(
false
)
mIgnoreFrameDestruction
(
false
)
mIsActive
(
true
)
mFrozen
(
false
)
mIsFirstPaint
(
true
)
mObservesMutationsForPrint
(
false
)
mWasLastReflowInterrupted
(
false
)
mObservingStyleFlushes
(
false
)
mObservingLayoutFlushes
(
false
)
mResizeEventPending
(
false
)
mFontSizeInflationForceEnabled
(
false
)
mFontSizeInflationDisabledInMasterProcess
(
false
)
mFontSizeInflationEnabled
(
false
)
mIsNeverPainting
(
false
)
mResolutionUpdated
(
false
)
mResolutionUpdatedByApz
(
false
)
mUnderHiddenEmbedderElement
(
false
)
mDocumentLoading
(
false
)
mNoDelayedMouseEvents
(
false
)
mNoDelayedKeyEvents
(
false
)
mApproximateFrameVisibilityVisited
(
false
)
mNextPaintCompressed
(
false
)
mHasCSSBackgroundColor
(
true
)
mIsLastChromeOnlyEscapeKeyConsumed
(
false
)
mHasReceivedPaintMessage
(
false
)
mIsLastKeyDownCanceled
(
false
)
mHasHandledUserInput
(
false
)
mForceDispatchKeyPressEventsForNonPrintableKeys
(
false
)
mForceUseLegacyKeyCodeAndCharCodeValues
(
false
)
mInitializedWithKeyPressEventDispatchingBlacklist
(
false
)
mForceUseLegacyNonPrimaryDispatch
(
false
)
mInitializedWithClickEventDispatchingBlacklist
(
false
)
mMouseLocationWasSetBySynthesizedMouseEventForTests
(
false
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Debug
(
"
PresShell
:
:
PresShell
this
=
%
p
"
this
)
)
;
MOZ_ASSERT
(
aDocument
)
;
#
ifdef
MOZ_REFLOW_PERF
mReflowCountMgr
=
MakeUnique
<
ReflowCountMgr
>
(
)
;
mReflowCountMgr
-
>
SetPresContext
(
mPresContext
)
;
mReflowCountMgr
-
>
SetPresShell
(
this
)
;
#
endif
mLastOSWake
=
mLoadBegin
=
TimeStamp
:
:
Now
(
)
;
}
NS_INTERFACE_TABLE_HEAD
(
PresShell
)
NS_INTERFACE_TABLE_BEGIN
NS_INTERFACE_TABLE_ENTRY
(
PresShell
PresShell
)
NS_INTERFACE_TABLE_ENTRY
(
PresShell
nsIDocumentObserver
)
NS_INTERFACE_TABLE_ENTRY
(
PresShell
nsISelectionController
)
NS_INTERFACE_TABLE_ENTRY
(
PresShell
nsISelectionDisplay
)
NS_INTERFACE_TABLE_ENTRY
(
PresShell
nsIObserver
)
NS_INTERFACE_TABLE_ENTRY
(
PresShell
nsISupportsWeakReference
)
NS_INTERFACE_TABLE_ENTRY
(
PresShell
nsIMutationObserver
)
NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS
(
PresShell
nsISupports
nsIObserver
)
NS_INTERFACE_TABLE_END
NS_INTERFACE_TABLE_TO_MAP_SEGUE
NS_INTERFACE_MAP_END
NS_IMPL_ADDREF
(
PresShell
)
NS_IMPL_RELEASE
(
PresShell
)
PresShell
:
:
~
PresShell
(
)
{
MOZ_RELEASE_ASSERT
(
!
mForbiddenToFlush
"
Flag
should
only
be
set
temporarily
while
doing
things
"
"
that
shouldn
'
t
cause
destruction
"
)
;
MOZ_LOG
(
gLog
LogLevel
:
:
Debug
(
"
PresShell
:
:
~
PresShell
this
=
%
p
"
this
)
)
;
if
(
!
mHaveShutDown
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Someone
did
not
call
PresShell
:
:
Destroy
(
)
"
)
;
Destroy
(
)
;
}
NS_ASSERTION
(
mCurrentEventContentStack
.
Count
(
)
=
=
0
"
Huh
event
content
left
on
the
stack
in
pres
shell
dtor
!
"
)
;
NS_ASSERTION
(
mFirstCallbackEventRequest
=
=
nullptr
&
&
mLastCallbackEventRequest
=
=
nullptr
"
post
-
reflow
queues
not
empty
.
This
means
we
'
re
leaking
"
)
;
MOZ_ASSERT
(
mAllocatedPointers
.
IsEmpty
(
)
"
Some
pres
arena
objects
were
not
freed
"
)
;
mFrameManager
=
nullptr
;
mFrameConstructor
=
nullptr
;
mCurrentEventContent
=
nullptr
;
}
void
PresShell
:
:
Init
(
nsPresContext
*
aPresContext
nsViewManager
*
aViewManager
)
{
MOZ_ASSERT
(
mDocument
)
;
MOZ_ASSERT
(
aPresContext
)
;
MOZ_ASSERT
(
aViewManager
)
;
MOZ_ASSERT
(
!
mViewManager
"
already
initialized
"
)
;
mViewManager
=
aViewManager
;
SetNeedLayoutFlush
(
)
;
SetNeedStyleFlush
(
)
;
mFrameConstructor
=
MakeUnique
<
nsCSSFrameConstructor
>
(
mDocument
this
)
;
mFrameManager
=
mFrameConstructor
.
get
(
)
;
mViewManager
-
>
SetPresShell
(
this
)
;
const_cast
<
RefPtr
<
nsPresContext
>
&
>
(
mPresContext
)
=
aPresContext
;
mPresContext
-
>
AttachPresShell
(
this
)
;
mPresContext
-
>
DeviceContext
(
)
-
>
InitFontCache
(
)
;
EnsureStyleFlush
(
)
;
UpdatePreferenceStyles
(
)
;
bool
accessibleCaretEnabled
=
AccessibleCaretEnabled
(
mDocument
-
>
GetDocShell
(
)
)
;
if
(
accessibleCaretEnabled
)
{
mAccessibleCaretEventHub
=
new
AccessibleCaretEventHub
(
this
)
;
}
mSelection
=
new
nsFrameSelection
(
this
nullptr
accessibleCaretEnabled
)
;
#
ifdef
SHOW_CARET
mCaret
=
new
nsCaret
(
)
;
mCaret
-
>
Init
(
this
)
;
mOriginalCaret
=
mCaret
;
#
endif
nsPresContext
:
:
nsPresContextType
type
=
mPresContext
-
>
Type
(
)
;
if
(
type
!
=
nsPresContext
:
:
eContext_PrintPreview
&
&
type
!
=
nsPresContext
:
:
eContext_Print
)
{
SetDisplaySelection
(
nsISelectionController
:
:
SELECTION_DISABLED
)
;
}
if
(
gMaxRCProcessingTime
=
=
-
1
)
{
gMaxRCProcessingTime
=
Preferences
:
:
GetInt
(
"
layout
.
reflow
.
timeslice
"
NS_MAX_REFLOW_TIME
)
;
}
if
(
nsStyleSheetService
*
ss
=
nsStyleSheetService
:
:
GetInstance
(
)
)
{
ss
-
>
RegisterPresShell
(
this
)
;
}
{
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
os
-
>
AddObserver
(
this
"
memory
-
pressure
"
false
)
;
os
-
>
AddObserver
(
this
NS_WIDGET_WAKE_OBSERVER_TOPIC
false
)
;
if
(
XRE_IsParentProcess
(
)
&
&
!
sProcessInteractable
)
{
os
-
>
AddObserver
(
this
"
sessionstore
-
one
-
or
-
no
-
tab
-
restored
"
false
)
;
}
os
-
>
AddObserver
(
this
"
font
-
info
-
updated
"
false
)
;
os
-
>
AddObserver
(
this
"
look
-
and
-
feel
-
changed
"
false
)
;
}
}
#
ifdef
MOZ_REFLOW_PERF
if
(
mReflowCountMgr
)
{
bool
paintFrameCounts
=
Preferences
:
:
GetBool
(
"
layout
.
reflow
.
showframecounts
"
)
;
bool
dumpFrameCounts
=
Preferences
:
:
GetBool
(
"
layout
.
reflow
.
dumpframecounts
"
)
;
bool
dumpFrameByFrameCounts
=
Preferences
:
:
GetBool
(
"
layout
.
reflow
.
dumpframebyframecounts
"
)
;
mReflowCountMgr
-
>
SetDumpFrameCounts
(
dumpFrameCounts
)
;
mReflowCountMgr
-
>
SetDumpFrameByFrameCounts
(
dumpFrameByFrameCounts
)
;
mReflowCountMgr
-
>
SetPaintFrameCounts
(
paintFrameCounts
)
;
}
#
endif
if
(
mDocument
-
>
HasAnimationController
(
)
)
{
SMILAnimationController
*
animCtrl
=
mDocument
-
>
GetAnimationController
(
)
;
animCtrl
-
>
NotifyRefreshDriverCreated
(
GetPresContext
(
)
-
>
RefreshDriver
(
)
)
;
}
for
(
DocumentTimeline
*
timeline
:
mDocument
-
>
Timelines
(
)
)
{
timeline
-
>
NotifyRefreshDriverCreated
(
GetPresContext
(
)
-
>
RefreshDriver
(
)
)
;
}
QueryIsActive
(
)
;
mFontSizeInflationEmPerLine
=
StaticPrefs
:
:
font_size_inflation_emPerLine
(
)
;
mFontSizeInflationMinTwips
=
StaticPrefs
:
:
font_size_inflation_minTwips
(
)
;
mFontSizeInflationLineThreshold
=
StaticPrefs
:
:
font_size_inflation_lineThreshold
(
)
;
mFontSizeInflationForceEnabled
=
StaticPrefs
:
:
font_size_inflation_forceEnabled
(
)
;
mFontSizeInflationDisabledInMasterProcess
=
StaticPrefs
:
:
font_size_inflation_disabledInMasterProcess
(
)
;
mTouchManager
.
Init
(
this
mDocument
)
;
if
(
mPresContext
-
>
IsRootContentDocumentCrossProcess
(
)
)
{
mZoomConstraintsClient
=
new
ZoomConstraintsClient
(
)
;
mZoomConstraintsClient
-
>
Init
(
this
mDocument
)
;
MaybeRecreateMobileViewportManager
(
false
)
;
}
if
(
nsCOMPtr
<
nsIDocShell
>
docShell
=
mPresContext
-
>
GetDocShell
(
)
)
{
BrowsingContext
*
bc
=
docShell
-
>
GetBrowsingContext
(
)
;
bool
embedderFrameIsHidden
=
true
;
if
(
Element
*
embedderElement
=
bc
-
>
GetEmbedderElement
(
)
)
{
if
(
auto
embedderFrame
=
embedderElement
-
>
GetPrimaryFrame
(
)
)
{
embedderFrameIsHidden
=
!
embedderFrame
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
;
}
}
if
(
BrowsingContext
*
parent
=
bc
-
>
GetParent
(
)
)
{
if
(
nsCOMPtr
<
nsIDocShell
>
parentDocShell
=
parent
-
>
GetDocShell
(
)
)
{
if
(
PresShell
*
parentPresShell
=
parentDocShell
-
>
GetPresShell
(
)
)
{
mUnderHiddenEmbedderElement
=
parentPresShell
-
>
IsUnderHiddenEmbedderElement
(
)
|
|
embedderFrameIsHidden
;
}
}
}
}
}
enum
TextPerfLogType
{
eLog_reflow
eLog_loaddone
eLog_totals
}
;
static
void
LogTextPerfStats
(
gfxTextPerfMetrics
*
aTextPerf
PresShell
*
aPresShell
const
gfxTextPerfMetrics
:
:
TextCounts
&
aCounts
float
aTime
TextPerfLogType
aLogType
const
char
*
aURL
)
{
LogModule
*
tpLog
=
gfxPlatform
:
:
GetLog
(
eGfxLog_textperf
)
;
mozilla
:
:
LogLevel
logLevel
=
LogLevel
:
:
Warning
;
if
(
aCounts
.
numContentTextRuns
=
=
0
)
{
logLevel
=
LogLevel
:
:
Debug
;
}
if
(
!
MOZ_LOG_TEST
(
tpLog
logLevel
)
)
{
return
;
}
char
prefix
[
256
]
;
switch
(
aLogType
)
{
case
eLog_reflow
:
SprintfLiteral
(
prefix
"
(
textperf
-
reflow
)
%
p
time
-
ms
:
%
7
.
0f
"
aPresShell
aTime
)
;
break
;
case
eLog_loaddone
:
SprintfLiteral
(
prefix
"
(
textperf
-
loaddone
)
%
p
time
-
ms
:
%
7
.
0f
"
aPresShell
aTime
)
;
break
;
default
:
MOZ_ASSERT
(
aLogType
=
=
eLog_totals
"
unknown
textperf
log
type
"
)
;
SprintfLiteral
(
prefix
"
(
textperf
-
totals
)
%
p
"
aPresShell
)
;
}
double
hitRatio
=
0
.
0
;
uint32_t
lookups
=
aCounts
.
wordCacheHit
+
aCounts
.
wordCacheMiss
;
if
(
lookups
)
{
hitRatio
=
double
(
aCounts
.
wordCacheHit
)
/
double
(
lookups
)
;
}
if
(
aLogType
=
=
eLog_loaddone
)
{
MOZ_LOG
(
tpLog
logLevel
(
"
%
s
reflow
:
%
d
chars
:
%
d
"
"
[
%
s
]
"
"
content
-
textruns
:
%
d
chrome
-
textruns
:
%
d
"
"
max
-
textrun
-
len
:
%
d
"
"
word
-
cache
-
lookups
:
%
d
word
-
cache
-
hit
-
ratio
:
%
4
.
3f
"
"
word
-
cache
-
space
:
%
d
word
-
cache
-
long
:
%
d
"
"
pref
-
fallbacks
:
%
d
system
-
fallbacks
:
%
d
"
"
textruns
-
const
:
%
d
textruns
-
destr
:
%
d
"
"
generic
-
lookups
:
%
d
"
"
cumulative
-
textruns
-
destr
:
%
d
\
n
"
prefix
aTextPerf
-
>
reflowCount
aCounts
.
numChars
(
aURL
?
aURL
:
"
"
)
aCounts
.
numContentTextRuns
aCounts
.
numChromeTextRuns
aCounts
.
maxTextRunLen
lookups
hitRatio
aCounts
.
wordCacheSpaceRules
aCounts
.
wordCacheLong
aCounts
.
fallbackPrefs
aCounts
.
fallbackSystem
aCounts
.
textrunConst
aCounts
.
textrunDestr
aCounts
.
genericLookups
aTextPerf
-
>
cumulative
.
textrunDestr
)
)
;
}
else
{
MOZ_LOG
(
tpLog
logLevel
(
"
%
s
reflow
:
%
d
chars
:
%
d
"
"
content
-
textruns
:
%
d
chrome
-
textruns
:
%
d
"
"
max
-
textrun
-
len
:
%
d
"
"
word
-
cache
-
lookups
:
%
d
word
-
cache
-
hit
-
ratio
:
%
4
.
3f
"
"
word
-
cache
-
space
:
%
d
word
-
cache
-
long
:
%
d
"
"
pref
-
fallbacks
:
%
d
system
-
fallbacks
:
%
d
"
"
textruns
-
const
:
%
d
textruns
-
destr
:
%
d
"
"
generic
-
lookups
:
%
d
"
"
cumulative
-
textruns
-
destr
:
%
d
\
n
"
prefix
aTextPerf
-
>
reflowCount
aCounts
.
numChars
aCounts
.
numContentTextRuns
aCounts
.
numChromeTextRuns
aCounts
.
maxTextRunLen
lookups
hitRatio
aCounts
.
wordCacheSpaceRules
aCounts
.
wordCacheLong
aCounts
.
fallbackPrefs
aCounts
.
fallbackSystem
aCounts
.
textrunConst
aCounts
.
textrunDestr
aCounts
.
genericLookups
aTextPerf
-
>
cumulative
.
textrunDestr
)
)
;
}
}
bool
PresShell
:
:
InRDMPane
(
)
{
if
(
Document
*
doc
=
GetDocument
(
)
)
{
if
(
BrowsingContext
*
bc
=
doc
-
>
GetBrowsingContext
(
)
)
{
return
bc
-
>
InRDMPane
(
)
;
}
}
return
false
;
}
void
PresShell
:
:
Destroy
(
)
{
if
(
mHaveShutDown
)
{
return
;
}
NS_ASSERTION
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
destroy
called
on
presshell
while
scripts
not
blocked
"
)
;
AUTO_PROFILER_LABEL
(
"
PresShell
:
:
Destroy
"
LAYOUT
)
;
auto
isUserZoomablePage
=
[
&
]
(
)
-
>
bool
{
if
(
mIsFirstPaint
)
{
return
false
;
}
if
(
!
mPresContext
-
>
IsRootContentDocumentCrossProcess
(
)
)
{
return
false
;
}
if
(
InRDMPane
(
)
)
{
return
false
;
}
if
(
mDocument
&
&
mDocument
-
>
IsInitialDocument
(
)
)
{
return
false
;
}
if
(
XRE_IsContentProcess
(
)
&
&
IsExtensionRemoteType
(
ContentChild
:
:
GetSingleton
(
)
-
>
GetRemoteType
(
)
)
)
{
return
false
;
}
return
true
;
}
;
if
(
isUserZoomablePage
(
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
APZ_ZOOM_ACTIVITY
IsResolutionUpdatedByApz
(
)
)
;
}
gfxTextPerfMetrics
*
tp
;
if
(
mPresContext
&
&
(
tp
=
mPresContext
-
>
GetTextPerfMetrics
(
)
)
)
{
tp
-
>
Accumulate
(
)
;
if
(
tp
-
>
cumulative
.
numChars
>
0
)
{
LogTextPerfStats
(
tp
this
tp
-
>
cumulative
0
.
0
eLog_totals
nullptr
)
;
}
}
if
(
mPresContext
)
{
if
(
gfxUserFontSet
*
fs
=
mPresContext
-
>
GetUserFontSet
(
)
)
{
uint32_t
fontCount
;
uint64_t
fontSize
;
fs
-
>
GetLoadStatistics
(
fontCount
fontSize
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
WEBFONT_PER_PAGE
fontCount
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
WEBFONT_SIZE_PER_PAGE
uint32_t
(
fontSize
/
1024
)
)
;
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
WEBFONT_PER_PAGE
0
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
WEBFONT_SIZE_PER_PAGE
0
)
;
}
const
auto
*
stats
=
mPresContext
-
>
GetFontMatchingStats
(
)
;
if
(
stats
)
{
Document
*
doc
=
GetDocument
(
)
;
if
(
doc
&
&
doc
-
>
IsContentDocument
(
)
)
{
nsIURI
*
uri
=
doc
-
>
GetDocumentURI
(
)
;
nsAutoCString
path
;
if
(
uri
&
&
!
uri
-
>
SchemeIs
(
"
about
"
)
&
&
!
uri
-
>
SchemeIs
(
"
chrome
"
)
&
&
!
uri
-
>
SchemeIs
(
"
resource
"
)
&
&
!
(
uri
-
>
SchemeIs
(
"
moz
-
extension
"
)
&
&
(
NS_SUCCEEDED
(
uri
-
>
GetFilePath
(
path
)
)
&
&
StringEndsWith
(
path
"
/
_generated_background_page
.
html
"
_ns
)
)
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
BASE_FONT_FAMILIES_PER_PAGE
stats
-
>
mBaseFonts
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
LANGPACK_FONT_FAMILIES_PER_PAGE
stats
-
>
mLangPackFonts
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
USER_FONT_FAMILIES_PER_PAGE
stats
-
>
mUserFonts
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
WEB_FONT_FAMILIES_PER_PAGE
stats
-
>
mWebFonts
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
FALLBACK_TO_PREFS_FONT
bool
(
stats
-
>
mFallbacks
&
FallbackTypes
:
:
FallbackToPrefsFont
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
FALLBACK_TO_BASE_FONT
bool
(
stats
-
>
mFallbacks
&
FallbackTypes
:
:
FallbackToBaseFont
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
FALLBACK_TO_LANGPACK_FONT
bool
(
stats
-
>
mFallbacks
&
FallbackTypes
:
:
FallbackToLangPackFont
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
FALLBACK_TO_USER_FONT
bool
(
stats
-
>
mFallbacks
&
FallbackTypes
:
:
FallbackToUserFont
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
MISSING_FONT
bool
(
stats
-
>
mFallbacks
&
FallbackTypes
:
:
MissingFont
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
MISSING_FONT_LANGPACK
bool
(
stats
-
>
mFallbacks
&
FallbackTypes
:
:
MissingFontLangPack
)
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
MISSING_FONT_USER
bool
(
stats
-
>
mFallbacks
&
FallbackTypes
:
:
MissingFontUser
)
)
;
}
}
}
mPresContext
-
>
ClearOneShotPostRefreshObservers
(
)
;
}
#
ifdef
MOZ_REFLOW_PERF
DumpReflows
(
)
;
mReflowCountMgr
=
nullptr
;
#
endif
if
(
mZoomConstraintsClient
)
{
mZoomConstraintsClient
-
>
Destroy
(
)
;
mZoomConstraintsClient
=
nullptr
;
}
if
(
mMobileViewportManager
)
{
mMobileViewportManager
-
>
Destroy
(
)
;
mMobileViewportManager
=
nullptr
;
mMVMContext
=
nullptr
;
}
#
ifdef
ACCESSIBILITY
if
(
mDocAccessible
)
{
#
ifdef
DEBUG
if
(
a11y
:
:
logging
:
:
IsEnabled
(
a11y
:
:
logging
:
:
eDocDestroy
)
)
a11y
:
:
logging
:
:
DocDestroy
(
"
presshell
destroyed
"
mDocument
)
;
#
endif
mDocAccessible
-
>
Shutdown
(
)
;
mDocAccessible
=
nullptr
;
}
#
endif
MaybeReleaseCapturingContent
(
)
;
EventHandler
:
:
OnPresShellDestroy
(
mDocument
)
;
if
(
mContentToScrollTo
)
{
mContentToScrollTo
-
>
RemoveProperty
(
nsGkAtoms
:
:
scrolling
)
;
mContentToScrollTo
=
nullptr
;
}
if
(
mPresContext
)
{
mPresContext
-
>
EventStateManager
(
)
-
>
NotifyDestroyPresContext
(
mPresContext
)
;
}
if
(
nsStyleSheetService
*
ss
=
nsStyleSheetService
:
:
GetInstance
(
)
)
{
ss
-
>
UnregisterPresShell
(
this
)
;
}
{
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
os
-
>
RemoveObserver
(
this
"
memory
-
pressure
"
)
;
os
-
>
RemoveObserver
(
this
NS_WIDGET_WAKE_OBSERVER_TOPIC
)
;
if
(
XRE_IsParentProcess
(
)
)
{
os
-
>
RemoveObserver
(
this
"
sessionstore
-
one
-
or
-
no
-
tab
-
restored
"
)
;
}
os
-
>
RemoveObserver
(
this
"
font
-
info
-
updated
"
)
;
os
-
>
RemoveObserver
(
this
"
look
-
and
-
feel
-
changed
"
)
;
}
}
CancelPaintSuppressionTimer
(
)
;
if
(
mReflowContinueTimer
)
{
mReflowContinueTimer
-
>
Cancel
(
)
;
mReflowContinueTimer
=
nullptr
;
}
if
(
mDelayedPaintTimer
)
{
mDelayedPaintTimer
-
>
Cancel
(
)
;
mDelayedPaintTimer
=
nullptr
;
}
mSynthMouseMoveEvent
.
Revoke
(
)
;
mUpdateApproximateFrameVisibilityEvent
.
Revoke
(
)
;
ClearApproximatelyVisibleFramesList
(
Some
(
OnNonvisible
:
:
DiscardImages
)
)
;
if
(
mCaret
)
{
mCaret
-
>
Terminate
(
)
;
mCaret
=
nullptr
;
}
mFocusedFrameSelection
=
nullptr
;
if
(
mSelection
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
mSelection
;
frameSelection
-
>
DisconnectFromPresShell
(
)
;
}
RemovePreferenceStyles
(
)
;
mIsDestroying
=
true
;
mCurrentEventFrame
=
nullptr
;
int32_t
i
count
=
mCurrentEventFrameStack
.
Length
(
)
;
for
(
i
=
0
;
i
<
count
;
i
+
+
)
{
mCurrentEventFrameStack
[
i
]
=
nullptr
;
}
mFramesToDirty
.
Clear
(
)
;
mPendingScrollAnchorSelection
.
Clear
(
)
;
mPendingScrollAnchorAdjustment
.
Clear
(
)
;
if
(
mViewManager
)
{
mViewManager
-
>
SetPresShell
(
nullptr
)
;
mViewManager
=
nullptr
;
}
nsRefreshDriver
*
rd
=
GetPresContext
(
)
-
>
RefreshDriver
(
)
;
if
(
mDocument
)
{
NS_ASSERTION
(
mDocument
-
>
GetPresShell
(
)
=
=
this
"
Wrong
shell
?
"
)
;
mDocument
-
>
ClearServoRestyleRoot
(
)
;
mDocument
-
>
DeletePresShell
(
)
;
if
(
mDocument
-
>
HasAnimationController
(
)
)
{
mDocument
-
>
GetAnimationController
(
)
-
>
NotifyRefreshDriverDestroying
(
rd
)
;
}
for
(
DocumentTimeline
*
timeline
:
mDocument
-
>
Timelines
(
)
)
{
timeline
-
>
NotifyRefreshDriverDestroying
(
rd
)
;
}
}
if
(
mPresContext
)
{
rd
-
>
CancelPendingAnimationEvents
(
mPresContext
-
>
AnimationEventDispatcher
(
)
)
;
}
StopObservingRefreshDriver
(
)
;
if
(
rd
-
>
GetPresContext
(
)
=
=
GetPresContext
(
)
)
{
rd
-
>
RevokeViewManagerFlush
(
)
;
rd
-
>
ClearHasScheduleFlush
(
)
;
}
CancelAllPendingReflows
(
)
;
CancelPostedReflowCallbacks
(
)
;
mFrameConstructor
-
>
WillDestroyFrameTree
(
)
;
NS_WARNING_ASSERTION
(
!
mAutoWeakFrames
&
&
mWeakFrames
.
IsEmpty
(
)
"
Weak
frames
alive
after
destroying
FrameManager
"
)
;
while
(
mAutoWeakFrames
)
{
mAutoWeakFrames
-
>
Clear
(
this
)
;
}
const
nsTArray
<
WeakFrame
*
>
weakFrames
=
ToArray
(
mWeakFrames
)
;
for
(
WeakFrame
*
weakFrame
:
weakFrames
)
{
weakFrame
-
>
Clear
(
this
)
;
}
if
(
mAccessibleCaretEventHub
)
{
mAccessibleCaretEventHub
-
>
Terminate
(
)
;
mAccessibleCaretEventHub
=
nullptr
;
}
if
(
mPresContext
)
{
mPresContext
-
>
DetachPresShell
(
)
;
}
mHaveShutDown
=
true
;
mTouchManager
.
Destroy
(
)
;
}
void
PresShell
:
:
StopObservingRefreshDriver
(
)
{
nsRefreshDriver
*
rd
=
mPresContext
-
>
RefreshDriver
(
)
;
if
(
mResizeEventPending
)
{
rd
-
>
RemoveResizeEventFlushObserver
(
this
)
;
}
if
(
mObservingLayoutFlushes
)
{
rd
-
>
RemoveLayoutFlushObserver
(
this
)
;
}
if
(
mObservingStyleFlushes
)
{
rd
-
>
RemoveStyleFlushObserver
(
this
)
;
}
}
void
PresShell
:
:
StartObservingRefreshDriver
(
)
{
nsRefreshDriver
*
rd
=
mPresContext
-
>
RefreshDriver
(
)
;
if
(
mResizeEventPending
)
{
rd
-
>
AddResizeEventFlushObserver
(
this
)
;
}
if
(
mObservingLayoutFlushes
)
{
rd
-
>
AddLayoutFlushObserver
(
this
)
;
}
if
(
mObservingStyleFlushes
)
{
rd
-
>
AddStyleFlushObserver
(
this
)
;
}
}
nsRefreshDriver
*
PresShell
:
:
GetRefreshDriver
(
)
const
{
return
mPresContext
?
mPresContext
-
>
RefreshDriver
(
)
:
nullptr
;
}
void
PresShell
:
:
SetAuthorStyleDisabled
(
bool
aStyleDisabled
)
{
if
(
aStyleDisabled
!
=
StyleSet
(
)
-
>
GetAuthorStyleDisabled
(
)
)
{
StyleSet
(
)
-
>
SetAuthorStyleDisabled
(
aStyleDisabled
)
;
mDocument
-
>
ApplicableStylesChanged
(
)
;
nsCOMPtr
<
nsIObserverService
>
observerService
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
observerService
)
{
observerService
-
>
NotifyObservers
(
ToSupports
(
mDocument
)
"
author
-
style
-
disabled
-
changed
"
nullptr
)
;
}
}
}
bool
PresShell
:
:
GetAuthorStyleDisabled
(
)
const
{
return
StyleSet
(
)
-
>
GetAuthorStyleDisabled
(
)
;
}
void
PresShell
:
:
UpdatePreferenceStyles
(
)
{
if
(
!
mDocument
)
{
return
;
}
if
(
!
mDocument
-
>
GetWindow
(
)
)
{
return
;
}
if
(
nsContentUtils
:
:
IsInChromeDocshell
(
mDocument
)
)
{
return
;
}
PreferenceSheet
:
:
EnsureInitialized
(
)
;
auto
*
cache
=
GlobalStyleSheetCache
:
:
Singleton
(
)
;
RefPtr
<
StyleSheet
>
newPrefSheet
=
PreferenceSheet
:
:
ShouldUseChromePrefs
(
*
mDocument
)
?
cache
-
>
ChromePreferenceSheet
(
)
:
cache
-
>
ContentPreferenceSheet
(
)
;
if
(
mPrefStyleSheet
=
=
newPrefSheet
)
{
return
;
}
RemovePreferenceStyles
(
)
;
StyleSet
(
)
-
>
AppendStyleSheet
(
*
newPrefSheet
)
;
mPrefStyleSheet
=
newPrefSheet
;
}
void
PresShell
:
:
RemovePreferenceStyles
(
)
{
if
(
mPrefStyleSheet
)
{
StyleSet
(
)
-
>
RemoveStyleSheet
(
*
mPrefStyleSheet
)
;
mPrefStyleSheet
=
nullptr
;
}
}
void
PresShell
:
:
AddUserSheet
(
StyleSheet
*
aSheet
)
{
nsStyleSheetService
*
sheetService
=
nsStyleSheetService
:
:
GetInstance
(
)
;
nsTArray
<
RefPtr
<
StyleSheet
>
>
&
userSheets
=
*
sheetService
-
>
UserStyleSheets
(
)
;
MOZ_ASSERT
(
aSheet
)
;
MOZ_ASSERT
(
userSheets
.
LastElement
(
)
=
=
aSheet
)
;
size_t
index
=
userSheets
.
Length
(
)
-
1
;
for
(
size_t
i
=
0
;
i
<
index
;
+
+
i
)
{
MOZ_ASSERT
(
StyleSet
(
)
-
>
SheetAt
(
StyleOrigin
:
:
User
i
)
=
=
userSheets
[
i
]
)
;
}
if
(
index
=
=
static_cast
<
size_t
>
(
StyleSet
(
)
-
>
SheetCount
(
StyleOrigin
:
:
User
)
)
)
{
StyleSet
(
)
-
>
AppendStyleSheet
(
*
aSheet
)
;
}
else
{
StyleSheet
*
ref
=
StyleSet
(
)
-
>
SheetAt
(
StyleOrigin
:
:
User
index
)
;
StyleSet
(
)
-
>
InsertStyleSheetBefore
(
*
aSheet
*
ref
)
;
}
mDocument
-
>
ApplicableStylesChanged
(
)
;
}
void
PresShell
:
:
AddAgentSheet
(
StyleSheet
*
aSheet
)
{
StyleSet
(
)
-
>
AppendStyleSheet
(
*
aSheet
)
;
mDocument
-
>
ApplicableStylesChanged
(
)
;
}
void
PresShell
:
:
AddAuthorSheet
(
StyleSheet
*
aSheet
)
{
StyleSheet
*
firstAuthorSheet
=
mDocument
-
>
GetFirstAdditionalAuthorSheet
(
)
;
if
(
firstAuthorSheet
)
{
StyleSet
(
)
-
>
InsertStyleSheetBefore
(
*
aSheet
*
firstAuthorSheet
)
;
}
else
{
StyleSet
(
)
-
>
AppendStyleSheet
(
*
aSheet
)
;
}
mDocument
-
>
ApplicableStylesChanged
(
)
;
}
void
PresShell
:
:
SelectionWillTakeFocus
(
)
{
if
(
mSelection
)
{
FrameSelectionWillTakeFocus
(
*
mSelection
)
;
}
}
void
PresShell
:
:
SelectionWillLoseFocus
(
)
{
}
static
void
RepaintNormalSelectionWhenSafe
(
nsFrameSelection
&
aFrameSelection
)
{
if
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
{
aFrameSelection
.
RepaintSelection
(
SelectionType
:
:
eNormal
)
;
return
;
}
nsContentUtils
:
:
AddScriptRunner
(
NS_NewRunnableFunction
(
"
RepaintNormalSelectionWhenSafe
"
[
sel
=
RefPtr
<
nsFrameSelection
>
(
&
aFrameSelection
)
]
{
sel
-
>
RepaintSelection
(
SelectionType
:
:
eNormal
)
;
}
)
)
;
}
void
PresShell
:
:
FrameSelectionWillLoseFocus
(
nsFrameSelection
&
aFrameSelection
)
{
if
(
mFocusedFrameSelection
!
=
&
aFrameSelection
)
{
return
;
}
if
(
&
aFrameSelection
=
=
mSelection
)
{
return
;
}
RefPtr
<
nsFrameSelection
>
old
=
std
:
:
move
(
mFocusedFrameSelection
)
;
MOZ_ASSERT
(
!
mFocusedFrameSelection
)
;
if
(
old
-
>
GetDisplaySelection
(
)
!
=
nsISelectionController
:
:
SELECTION_HIDDEN
)
{
old
-
>
SetDisplaySelection
(
nsISelectionController
:
:
SELECTION_HIDDEN
)
;
RepaintNormalSelectionWhenSafe
(
*
old
)
;
}
if
(
mSelection
)
{
FrameSelectionWillTakeFocus
(
*
mSelection
)
;
}
}
void
PresShell
:
:
FrameSelectionWillTakeFocus
(
nsFrameSelection
&
aFrameSelection
)
{
if
(
mFocusedFrameSelection
=
=
&
aFrameSelection
)
{
#
ifdef
XP_MACOSX
RepaintNormalSelectionWhenSafe
(
aFrameSelection
)
;
#
endif
return
;
}
RefPtr
<
nsFrameSelection
>
old
=
std
:
:
move
(
mFocusedFrameSelection
)
;
mFocusedFrameSelection
=
&
aFrameSelection
;
if
(
old
&
&
old
-
>
GetDisplaySelection
(
)
!
=
nsISelectionController
:
:
SELECTION_HIDDEN
)
{
old
-
>
SetDisplaySelection
(
nsISelectionController
:
:
SELECTION_HIDDEN
)
;
RepaintNormalSelectionWhenSafe
(
*
old
)
;
}
if
(
aFrameSelection
.
GetDisplaySelection
(
)
!
=
nsISelectionController
:
:
SELECTION_ON
)
{
aFrameSelection
.
SetDisplaySelection
(
nsISelectionController
:
:
SELECTION_ON
)
;
RepaintNormalSelectionWhenSafe
(
aFrameSelection
)
;
}
}
NS_IMETHODIMP
PresShell
:
:
SetDisplaySelection
(
int16_t
aToggle
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
mSelection
;
frameSelection
-
>
SetDisplaySelection
(
aToggle
)
;
return
NS_OK
;
}
NS_IMETHODIMP
PresShell
:
:
GetDisplaySelection
(
int16_t
*
aToggle
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
mSelection
;
*
aToggle
=
frameSelection
-
>
GetDisplaySelection
(
)
;
return
NS_OK
;
}
NS_IMETHODIMP
PresShell
:
:
GetSelectionFromScript
(
RawSelectionType
aRawSelectionType
Selection
*
*
aSelection
)
{
if
(
!
aSelection
|
|
!
mSelection
)
return
NS_ERROR_NULL_POINTER
;
RefPtr
<
nsFrameSelection
>
frameSelection
=
mSelection
;
RefPtr
<
Selection
>
selection
=
frameSelection
-
>
GetSelection
(
ToSelectionType
(
aRawSelectionType
)
)
;
if
(
!
selection
)
{
return
NS_ERROR_INVALID_ARG
;
}
selection
.
forget
(
aSelection
)
;
return
NS_OK
;
}
Selection
*
PresShell
:
:
GetSelection
(
RawSelectionType
aRawSelectionType
)
{
if
(
!
mSelection
)
{
return
nullptr
;
}
RefPtr
<
nsFrameSelection
>
frameSelection
=
mSelection
;
return
frameSelection
-
>
GetSelection
(
ToSelectionType
(
aRawSelectionType
)
)
;
}
Selection
*
PresShell
:
:
GetCurrentSelection
(
SelectionType
aSelectionType
)
{
if
(
!
mSelection
)
{
return
nullptr
;
}
RefPtr
<
nsFrameSelection
>
frameSelection
=
mSelection
;
return
frameSelection
-
>
GetSelection
(
aSelectionType
)
;
}
nsFrameSelection
*
PresShell
:
:
GetLastFocusedFrameSelection
(
)
{
return
mFocusedFrameSelection
?
mFocusedFrameSelection
:
mSelection
;
}
NS_IMETHODIMP
PresShell
:
:
ScrollSelectionIntoView
(
RawSelectionType
aRawSelectionType
SelectionRegion
aRegion
int16_t
aFlags
)
{
if
(
!
mSelection
)
return
NS_ERROR_NULL_POINTER
;
RefPtr
<
nsFrameSelection
>
frameSelection
=
mSelection
;
return
frameSelection
-
>
ScrollSelectionIntoView
(
ToSelectionType
(
aRawSelectionType
)
aRegion
aFlags
)
;
}
NS_IMETHODIMP
PresShell
:
:
RepaintSelection
(
RawSelectionType
aRawSelectionType
)
{
if
(
!
mSelection
)
{
return
NS_ERROR_NULL_POINTER
;
}
if
(
MOZ_UNLIKELY
(
mIsDestroying
)
)
{
return
NS_OK
;
}
RefPtr
<
nsFrameSelection
>
frameSelection
=
mSelection
;
return
frameSelection
-
>
RepaintSelection
(
ToSelectionType
(
aRawSelectionType
)
)
;
}
void
PresShell
:
:
BeginObservingDocument
(
)
{
if
(
mDocument
&
&
!
mIsDestroying
)
{
mIsObservingDocument
=
true
;
if
(
mIsDocumentGone
)
{
NS_WARNING
(
"
Adding
a
presshell
that
was
disconnected
from
the
document
"
"
as
a
document
observer
?
Sounds
wrong
.
.
.
"
)
;
mIsDocumentGone
=
false
;
}
}
}
void
PresShell
:
:
EndObservingDocument
(
)
{
mIsDocumentGone
=
true
;
mIsObservingDocument
=
false
;
}
#
ifdef
DEBUG_kipp
char
*
nsPresShell_ReflowStackPointerTop
;
#
endif
void
PresShell
:
:
InitPaintSuppressionTimer
(
)
{
Document
*
doc
=
mDocument
-
>
GetDisplayDocument
(
)
?
mDocument
-
>
GetDisplayDocument
(
)
:
mDocument
.
get
(
)
;
const
bool
inProcess
=
!
doc
-
>
GetBrowsingContext
(
)
|
|
doc
-
>
GetBrowsingContext
(
)
-
>
Top
(
)
-
>
IsInProcess
(
)
;
int32_t
delay
=
inProcess
?
StaticPrefs
:
:
nglayout_initialpaint_delay
(
)
:
StaticPrefs
:
:
nglayout_initialpaint_delay_in_oopif
(
)
;
if
(
mPaintSuppressionAttempts
)
{
delay
+
=
mPaintSuppressionAttempts
*
StaticPrefs
:
:
nglayout_initialpaint_retry_extra_delay
(
)
;
}
mPaintSuppressionTimer
-
>
InitWithNamedFuncCallback
(
[
]
(
nsITimer
*
aTimer
void
*
aPresShell
)
{
RefPtr
<
PresShell
>
self
=
static_cast
<
PresShell
*
>
(
aPresShell
)
;
self
-
>
UnsuppressPaintingFromTimer
(
)
;
}
this
delay
nsITimer
:
:
TYPE_ONE_SHOT
"
PresShell
:
:
sPaintSuppressionCallback
"
)
;
}
nsresult
PresShell
:
:
Initialize
(
)
{
if
(
mIsDestroying
)
{
return
NS_OK
;
}
if
(
!
mDocument
)
{
return
NS_OK
;
}
MOZ_LOG
(
gLog
LogLevel
:
:
Debug
(
"
PresShell
:
:
Initialize
this
=
%
p
"
this
)
)
;
NS_ASSERTION
(
!
mDidInitialize
"
Why
are
we
being
called
?
"
)
;
RefPtr
<
PresShell
>
kungFuDeathGrip
(
this
)
;
RecomputeFontSizeInflationEnabled
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mIsDestroying
)
;
mPresContext
-
>
FlushPendingMediaFeatureValuesChanged
(
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
mIsDestroying
)
;
mDidInitialize
=
true
;
#
ifdef
DEBUG
if
(
VerifyReflowFlags
:
:
NoisyCommands
&
gVerifyReflowFlags
)
{
if
(
mDocument
)
{
nsIURI
*
uri
=
mDocument
-
>
GetDocumentURI
(
)
;
if
(
uri
)
{
printf
(
"
*
*
*
PresShell
:
:
Initialize
(
this
=
%
p
url
=
'
%
s
'
)
\
n
"
(
void
*
)
this
uri
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
;
}
}
}
#
endif
nsIFrame
*
rootFrame
=
mFrameConstructor
-
>
GetRootFrame
(
)
;
NS_ASSERTION
(
!
rootFrame
"
How
did
that
happen
exactly
?
"
)
;
if
(
!
rootFrame
)
{
nsAutoScriptBlocker
scriptBlocker
;
rootFrame
=
mFrameConstructor
-
>
ConstructRootFrame
(
)
;
mFrameConstructor
-
>
SetRootFrame
(
rootFrame
)
;
}
NS_ENSURE_STATE
(
!
mHaveShutDown
)
;
if
(
!
rootFrame
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
Element
*
root
=
mDocument
-
>
GetRootElement
(
)
)
{
{
nsAutoCauseReflowNotifier
reflowNotifier
(
this
)
;
mFrameConstructor
-
>
ContentInserted
(
root
nsCSSFrameConstructor
:
:
InsertionKind
:
:
Sync
)
;
}
NS_ENSURE_STATE
(
!
mHaveShutDown
)
;
}
mDocument
-
>
TriggerAutoFocus
(
)
;
NS_ASSERTION
(
rootFrame
"
How
did
that
happen
?
"
)
;
if
(
MOZ_LIKELY
(
rootFrame
-
>
HasAnyStateBits
(
NS_FRAME_IS_DIRTY
)
)
)
{
rootFrame
-
>
RemoveStateBits
(
NS_FRAME_IS_DIRTY
|
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
NS_ASSERTION
(
!
mDirtyRoots
.
Contains
(
rootFrame
)
"
Why
is
the
root
in
mDirtyRoots
already
?
"
)
;
FrameNeedsReflow
(
rootFrame
IntrinsicDirty
:
:
Resize
NS_FRAME_IS_DIRTY
)
;
NS_ASSERTION
(
mDirtyRoots
.
Contains
(
rootFrame
)
"
Should
be
in
mDirtyRoots
now
"
)
;
NS_ASSERTION
(
mObservingLayoutFlushes
"
Why
no
reflow
scheduled
?
"
)
;
}
if
(
!
mDocumentLoading
)
{
RestoreRootScrollPosition
(
)
;
}
if
(
!
mPresContext
-
>
IsPaginated
(
)
)
{
mPaintingSuppressed
=
true
;
Document
:
:
ReadyState
readyState
=
mDocument
-
>
GetReadyStateEnum
(
)
;
if
(
readyState
!
=
Document
:
:
READYSTATE_COMPLETE
)
{
mPaintSuppressionTimer
=
NS_NewTimer
(
)
;
}
if
(
!
mPaintSuppressionTimer
)
{
mPaintingSuppressed
=
false
;
}
else
{
mPaintSuppressionTimer
-
>
SetTarget
(
mDocument
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
)
;
InitPaintSuppressionTimer
(
)
;
}
}
if
(
!
mPaintingSuppressed
)
{
mShouldUnsuppressPainting
=
true
;
}
return
NS_OK
;
}
nsresult
PresShell
:
:
ResizeReflow
(
nscoord
aWidth
nscoord
aHeight
ResizeReflowOptions
aOptions
)
{
if
(
mZoomConstraintsClient
)
{
mZoomConstraintsClient
-
>
ScreenSizeChanged
(
)
;
}
if
(
UsesMobileViewportSizing
(
)
)
{
MOZ_ASSERT
(
mMobileViewportManager
)
;
mMobileViewportManager
-
>
RequestReflow
(
false
)
;
return
NS_OK
;
}
return
ResizeReflowIgnoreOverride
(
aWidth
aHeight
aOptions
)
;
}
void
PresShell
:
:
SimpleResizeReflow
(
nscoord
aWidth
nscoord
aHeight
ResizeReflowOptions
aOptions
)
{
MOZ_ASSERT
(
aWidth
!
=
NS_UNCONSTRAINEDSIZE
)
;
MOZ_ASSERT
(
aHeight
!
=
NS_UNCONSTRAINEDSIZE
)
;
nsSize
oldSize
=
mPresContext
-
>
GetVisibleArea
(
)
.
Size
(
)
;
mPresContext
-
>
SetVisibleArea
(
nsRect
(
0
0
aWidth
aHeight
)
)
;
nsIFrame
*
rootFrame
=
GetRootFrame
(
)
;
if
(
!
rootFrame
)
{
return
;
}
WritingMode
wm
=
rootFrame
-
>
GetWritingMode
(
)
;
bool
isBSizeChanging
=
wm
.
IsVertical
(
)
?
oldSize
.
width
!
=
aWidth
:
oldSize
.
height
!
=
aHeight
;
if
(
isBSizeChanging
)
{
nsLayoutUtils
:
:
MarkIntrinsicISizesDirtyIfDependentOnBSize
(
rootFrame
)
;
}
FrameNeedsReflow
(
rootFrame
IntrinsicDirty
:
:
Resize
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
bool
suppressReflow
=
(
aOptions
&
ResizeReflowOptions
:
:
SuppressReflow
)
|
|
mPresContext
-
>
SuppressingResizeReflow
(
)
;
if
(
!
suppressReflow
)
{
mDocument
-
>
FlushPendingNotifications
(
FlushType
:
:
InterruptibleLayout
)
;
}
}
void
PresShell
:
:
AddResizeEventFlushObserverIfNeeded
(
)
{
if
(
!
mIsDestroying
&
&
!
mResizeEventPending
&
&
MOZ_LIKELY
(
!
mDocument
-
>
GetBFCacheEntry
(
)
)
)
{
mResizeEventPending
=
true
;
mPresContext
-
>
RefreshDriver
(
)
-
>
AddResizeEventFlushObserver
(
this
)
;
}
}
nsresult
PresShell
:
:
ResizeReflowIgnoreOverride
(
nscoord
aWidth
nscoord
aHeight
ResizeReflowOptions
aOptions
)
{
MOZ_ASSERT
(
!
mIsReflowing
"
Shouldn
'
t
be
in
reflow
here
!
"
)
;
const
bool
initialized
=
mDidInitialize
;
RefPtr
<
PresShell
>
kungFuDeathGrip
(
this
)
;
auto
postResizeEventIfNeeded
=
[
this
initialized
]
(
)
{
if
(
initialized
)
{
AddResizeEventFlushObserverIfNeeded
(
)
;
}
}
;
if
(
!
(
aOptions
&
ResizeReflowOptions
:
:
BSizeLimit
)
)
{
nsSize
oldSize
=
mPresContext
-
>
GetVisibleArea
(
)
.
Size
(
)
;
if
(
oldSize
=
=
nsSize
(
aWidth
aHeight
)
)
{
return
NS_OK
;
}
SimpleResizeReflow
(
aWidth
aHeight
aOptions
)
;
postResizeEventIfNeeded
(
)
;
return
NS_OK
;
}
MOZ_ASSERT
(
!
mPresContext
-
>
SuppressingResizeReflow
(
)
&
&
!
(
aOptions
&
ResizeReflowOptions
:
:
SuppressReflow
)
"
Can
'
t
suppress
resize
reflow
and
shrink
-
wrap
at
the
same
time
"
)
;
mDocument
-
>
FlushPendingNotifications
(
FlushType
:
:
Frames
)
;
nsIFrame
*
rootFrame
=
GetRootFrame
(
)
;
if
(
mIsDestroying
|
|
!
rootFrame
)
{
if
(
aHeight
=
=
NS_UNCONSTRAINEDSIZE
|
|
aWidth
=
=
NS_UNCONSTRAINEDSIZE
)
{
return
NS_ERROR_NOT_AVAILABLE
;
}
mPresContext
-
>
SetVisibleArea
(
nsRect
(
0
0
aWidth
aHeight
)
)
;
return
NS_OK
;
}
WritingMode
wm
=
rootFrame
-
>
GetWritingMode
(
)
;
MOZ_ASSERT
(
(
wm
.
IsVertical
(
)
?
aHeight
:
aWidth
)
!
=
NS_UNCONSTRAINEDSIZE
"
unconstrained
isize
not
allowed
"
)
;
nscoord
targetWidth
=
aWidth
;
nscoord
targetHeight
=
aHeight
;
if
(
wm
.
IsVertical
(
)
)
{
targetWidth
=
NS_UNCONSTRAINEDSIZE
;
}
else
{
targetHeight
=
NS_UNCONSTRAINEDSIZE
;
}
mPresContext
-
>
SetVisibleArea
(
nsRect
(
0
0
targetWidth
targetHeight
)
)
;
nsLayoutUtils
:
:
MarkIntrinsicISizesDirtyIfDependentOnBSize
(
rootFrame
)
;
{
nsAutoCauseReflowNotifier
crNotifier
(
this
)
;
WillDoReflow
(
)
;
AUTO_LAYOUT_PHASE_ENTRY_POINT
(
GetPresContext
(
)
Reflow
)
;
nsViewManager
:
:
AutoDisableRefresh
refreshBlocker
(
mViewManager
)
;
mDirtyRoots
.
Remove
(
rootFrame
)
;
DoReflow
(
rootFrame
true
nullptr
)
;
const
bool
reflowAgain
=
wm
.
IsVertical
(
)
?
mPresContext
-
>
GetVisibleArea
(
)
.
width
>
aWidth
:
mPresContext
-
>
GetVisibleArea
(
)
.
height
>
aHeight
;
if
(
reflowAgain
)
{
mPresContext
-
>
SetVisibleArea
(
nsRect
(
0
0
aWidth
aHeight
)
)
;
DoReflow
(
rootFrame
true
nullptr
)
;
}
}
DidDoReflow
(
true
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mPresContext
-
>
GetVisibleArea
(
)
.
width
!
=
NS_UNCONSTRAINEDSIZE
"
width
should
not
be
NS_UNCONSTRAINEDSIZE
after
reflow
"
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mPresContext
-
>
GetVisibleArea
(
)
.
height
!
=
NS_UNCONSTRAINEDSIZE
"
height
should
not
be
NS_UNCONSTRAINEDSIZE
after
reflow
"
)
;
postResizeEventIfNeeded
(
)
;
return
NS_OK
;
}
void
PresShell
:
:
FireResizeEvent
(
)
{
if
(
mIsDocumentGone
)
{
return
;
}
if
(
mDocument
-
>
EventHandlingSuppressed
(
)
)
{
if
(
MOZ_LIKELY
(
!
mDocument
-
>
GetBFCacheEntry
(
)
)
)
{
mDocument
-
>
SetHasDelayedRefreshEvent
(
)
;
mPresContext
-
>
RefreshDriver
(
)
-
>
AddResizeEventFlushObserver
(
this
true
)
;
}
return
;
}
mResizeEventPending
=
false
;
WidgetEvent
event
(
true
mozilla
:
:
eResize
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
if
(
nsPIDOMWindowOuter
*
window
=
mDocument
-
>
GetWindow
(
)
)
{
EventDispatcher
:
:
Dispatch
(
window
mPresContext
&
event
nullptr
&
status
)
;
}
}
static
nsIContent
*
GetNativeAnonymousSubtreeRoot
(
nsIContent
*
aContent
)
{
if
(
!
aContent
)
{
return
nullptr
;
}
return
aContent
-
>
GetClosestNativeAnonymousSubtreeRoot
(
)
;
}
void
PresShell
:
:
NativeAnonymousContentRemoved
(
nsIContent
*
aAnonContent
)
{
MOZ_ASSERT
(
aAnonContent
-
>
IsRootOfNativeAnonymousSubtree
(
)
)
;
if
(
nsIContent
*
root
=
GetNativeAnonymousSubtreeRoot
(
mCurrentEventContent
)
)
{
if
(
aAnonContent
=
=
root
)
{
mCurrentEventContent
=
aAnonContent
-
>
GetFlattenedTreeParent
(
)
;
mCurrentEventFrame
=
nullptr
;
}
}
for
(
unsigned
int
i
=
0
;
i
<
mCurrentEventContentStack
.
Length
(
)
;
i
+
+
)
{
nsIContent
*
anon
=
GetNativeAnonymousSubtreeRoot
(
mCurrentEventContentStack
.
ElementAt
(
i
)
)
;
if
(
aAnonContent
=
=
anon
)
{
mCurrentEventContentStack
.
ReplaceObjectAt
(
aAnonContent
-
>
GetFlattenedTreeParent
(
)
i
)
;
mCurrentEventFrameStack
[
i
]
=
nullptr
;
}
}
}
void
PresShell
:
:
SetIgnoreFrameDestruction
(
bool
aIgnore
)
{
if
(
mDocument
)
{
mDocument
-
>
StyleImageLoader
(
)
-
>
ClearFrames
(
mPresContext
)
;
}
mIgnoreFrameDestruction
=
aIgnore
;
}
void
PresShell
:
:
NotifyDestroyingFrame
(
nsIFrame
*
aFrame
)
{
aFrame
-
>
RemoveDisplayItemDataForDeletion
(
)
;
if
(
!
mIgnoreFrameDestruction
)
{
if
(
aFrame
-
>
HasImageRequest
(
)
)
{
mDocument
-
>
StyleImageLoader
(
)
-
>
DropRequestsForFrame
(
aFrame
)
;
}
mFrameConstructor
-
>
NotifyDestroyingFrame
(
aFrame
)
;
mDirtyRoots
.
Remove
(
aFrame
)
;
aFrame
-
>
RemoveAllProperties
(
)
;
if
(
aFrame
=
=
mCurrentEventFrame
)
{
mCurrentEventContent
=
aFrame
-
>
GetContent
(
)
;
mCurrentEventFrame
=
nullptr
;
}
#
ifdef
DEBUG
if
(
aFrame
=
=
mDrawEventTargetFrame
)
{
mDrawEventTargetFrame
=
nullptr
;
}
#
endif
for
(
unsigned
int
i
=
0
;
i
<
mCurrentEventFrameStack
.
Length
(
)
;
i
+
+
)
{
if
(
aFrame
=
=
mCurrentEventFrameStack
.
ElementAt
(
i
)
)
{
nsIContent
*
currentEventContent
=
aFrame
-
>
GetContent
(
)
;
mCurrentEventContentStack
.
ReplaceObjectAt
(
currentEventContent
i
)
;
mCurrentEventFrameStack
[
i
]
=
nullptr
;
}
}
mFramesToDirty
.
Remove
(
aFrame
)
;
nsIScrollableFrame
*
scrollableFrame
=
do_QueryFrame
(
aFrame
)
;
if
(
scrollableFrame
)
{
mPendingScrollAnchorSelection
.
Remove
(
scrollableFrame
)
;
mPendingScrollAnchorAdjustment
.
Remove
(
scrollableFrame
)
;
}
}
}
already_AddRefed
<
nsCaret
>
PresShell
:
:
GetCaret
(
)
const
{
RefPtr
<
nsCaret
>
caret
=
mCaret
;
return
caret
.
forget
(
)
;
}
already_AddRefed
<
AccessibleCaretEventHub
>
PresShell
:
:
GetAccessibleCaretEventHub
(
)
const
{
RefPtr
<
AccessibleCaretEventHub
>
eventHub
=
mAccessibleCaretEventHub
;
return
eventHub
.
forget
(
)
;
}
void
PresShell
:
:
SetCaret
(
nsCaret
*
aNewCaret
)
{
mCaret
=
aNewCaret
;
}
void
PresShell
:
:
RestoreCaret
(
)
{
mCaret
=
mOriginalCaret
;
}
NS_IMETHODIMP
PresShell
:
:
SetCaretEnabled
(
bool
aInEnable
)
{
bool
oldEnabled
=
mCaretEnabled
;
mCaretEnabled
=
aInEnable
;
if
(
mCaretEnabled
!
=
oldEnabled
)
{
MOZ_ASSERT
(
mCaret
)
;
if
(
mCaret
)
{
mCaret
-
>
SetVisible
(
mCaretEnabled
)
;
}
}
return
NS_OK
;
}
NS_IMETHODIMP
PresShell
:
:
SetCaretReadOnly
(
bool
aReadOnly
)
{
if
(
mCaret
)
mCaret
-
>
SetCaretReadOnly
(
aReadOnly
)
;
return
NS_OK
;
}
NS_IMETHODIMP
PresShell
:
:
GetCaretEnabled
(
bool
*
aOutEnabled
)
{
NS_ENSURE_ARG_POINTER
(
aOutEnabled
)
;
*
aOutEnabled
=
mCaretEnabled
;
return
NS_OK
;
}
NS_IMETHODIMP
PresShell
:
:
SetCaretVisibilityDuringSelection
(
bool
aVisibility
)
{
if
(
mCaret
)
mCaret
-
>
SetVisibilityDuringSelection
(
aVisibility
)
;
return
NS_OK
;
}
NS_IMETHODIMP
PresShell
:
:
GetCaretVisible
(
bool
*
aOutIsVisible
)
{
*
aOutIsVisible
=
false
;
if
(
mCaret
)
{
*
aOutIsVisible
=
mCaret
-
>
IsVisible
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
PresShell
:
:
SetSelectionFlags
(
int16_t
aFlags
)
{
mSelectionFlags
=
aFlags
;
return
NS_OK
;
}
NS_IMETHODIMP
PresShell
:
:
GetSelectionFlags
(
int16_t
*
aFlags
)
{
if
(
!
aFlags
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aFlags
=
mSelectionFlags
;
return
NS_OK
;
}
NS_IMETHODIMP
PresShell
:
:
PhysicalMove
(
int16_t
aDirection
int16_t
aAmount
bool
aExtend
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
mSelection
;
return
frameSelection
-
>
PhysicalMove
(
aDirection
aAmount
aExtend
)
;
}
NS_IMETHODIMP
PresShell
:
:
CharacterMove
(
bool
aForward
bool
aExtend
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
mSelection
;
return
frameSelection
-
>
CharacterMove
(
aForward
aExtend
)
;
}
NS_IMETHODIMP
PresShell
:
:
WordMove
(
bool
aForward
bool
aExtend
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
mSelection
;
nsresult
result
=
frameSelection
-
>
WordMove
(
aForward
aExtend
)
;
if
(
NS_FAILED
(
result
)
)
result
=
CompleteMove
(
aForward
aExtend
)
;
return
result
;
}
NS_IMETHODIMP
PresShell
:
:
LineMove
(
bool
aForward
bool
aExtend
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
mSelection
;
nsresult
result
=
frameSelection
-
>
LineMove
(
aForward
aExtend
)
;
if
(
NS_FAILED
(
result
)
)
result
=
CompleteMove
(
aForward
aExtend
)
;
return
result
;
}
NS_IMETHODIMP
PresShell
:
:
IntraLineMove
(
bool
aForward
bool
aExtend
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
mSelection
;
return
frameSelection
-
>
IntraLineMove
(
aForward
aExtend
)
;
}
NS_IMETHODIMP
PresShell
:
:
PageMove
(
bool
aForward
bool
aExtend
)
{
nsIFrame
*
frame
=
nullptr
;
if
(
!
aExtend
)
{
frame
=
do_QueryFrame
(
GetScrollableFrameToScroll
(
VerticalScrollDirection
)
)
;
}
if
(
!
frame
|
|
frame
-
>
PresContext
(
)
!
=
mPresContext
)
{
frame
=
mSelection
-
>
GetFrameToPageSelect
(
)
;
if
(
!
frame
)
{
return
NS_OK
;
}
}
RefPtr
<
nsFrameSelection
>
frameSelection
=
mSelection
;
return
frameSelection
-
>
PageMove
(
aForward
aExtend
frame
nsFrameSelection
:
:
SelectionIntoView
:
:
IfChanged
)
;
}
NS_IMETHODIMP
PresShell
:
:
ScrollPage
(
bool
aForward
)
{
nsIScrollableFrame
*
scrollFrame
=
GetScrollableFrameToScroll
(
VerticalScrollDirection
)
;
if
(
scrollFrame
)
{
mozilla
:
:
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
SCROLL_INPUT_METHODS
(
uint32_t
)
ScrollInputMethod
:
:
MainThreadScrollPage
)
;
scrollFrame
-
>
ScrollBy
(
nsIntPoint
(
0
aForward
?
1
:
-
1
)
ScrollUnit
:
:
PAGES
ScrollMode
:
:
Smooth
nullptr
mozilla
:
:
ScrollOrigin
:
:
NotSpecified
nsIScrollableFrame
:
:
NOT_MOMENTUM
nsIScrollableFrame
:
:
ENABLE_SNAP
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
PresShell
:
:
ScrollLine
(
bool
aForward
)
{
nsIScrollableFrame
*
scrollFrame
=
GetScrollableFrameToScroll
(
VerticalScrollDirection
)
;
if
(
scrollFrame
)
{
mozilla
:
:
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
SCROLL_INPUT_METHODS
(
uint32_t
)
ScrollInputMethod
:
:
MainThreadScrollLine
)
;
int32_t
lineCount
=
Preferences
:
:
GetInt
(
"
toolkit
.
scrollbox
.
verticalScrollDistance
"
NS_DEFAULT_VERTICAL_SCROLL_DISTANCE
)
;
scrollFrame
-
>
ScrollBy
(
nsIntPoint
(
0
aForward
?
lineCount
:
-
lineCount
)
ScrollUnit
:
:
LINES
ScrollMode
:
:
Smooth
nullptr
mozilla
:
:
ScrollOrigin
:
:
NotSpecified
nsIScrollableFrame
:
:
NOT_MOMENTUM
nsIScrollableFrame
:
:
ENABLE_SNAP
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
PresShell
:
:
ScrollCharacter
(
bool
aRight
)
{
nsIScrollableFrame
*
scrollFrame
=
GetScrollableFrameToScroll
(
HorizontalScrollDirection
)
;
if
(
scrollFrame
)
{
mozilla
:
:
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
SCROLL_INPUT_METHODS
(
uint32_t
)
ScrollInputMethod
:
:
MainThreadScrollCharacter
)
;
int32_t
h
=
Preferences
:
:
GetInt
(
"
toolkit
.
scrollbox
.
horizontalScrollDistance
"
NS_DEFAULT_HORIZONTAL_SCROLL_DISTANCE
)
;
scrollFrame
-
>
ScrollBy
(
nsIntPoint
(
aRight
?
h
:
-
h
0
)
ScrollUnit
:
:
LINES
ScrollMode
:
:
Smooth
nullptr
mozilla
:
:
ScrollOrigin
:
:
NotSpecified
nsIScrollableFrame
:
:
NOT_MOMENTUM
nsIScrollableFrame
:
:
ENABLE_SNAP
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
PresShell
:
:
CompleteScroll
(
bool
aForward
)
{
nsIScrollableFrame
*
scrollFrame
=
GetScrollableFrameToScroll
(
VerticalScrollDirection
)
;
if
(
scrollFrame
)
{
mozilla
:
:
Telemetry
:
:
Accumulate
(
mozilla
:
:
Telemetry
:
:
SCROLL_INPUT_METHODS
(
uint32_t
)
ScrollInputMethod
:
:
MainThreadCompleteScroll
)
;
scrollFrame
-
>
ScrollBy
(
nsIntPoint
(
0
aForward
?
1
:
-
1
)
ScrollUnit
:
:
WHOLE
ScrollMode
:
:
Smooth
nullptr
mozilla
:
:
ScrollOrigin
:
:
NotSpecified
nsIScrollableFrame
:
:
NOT_MOMENTUM
nsIScrollableFrame
:
:
ENABLE_SNAP
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP
PresShell
:
:
CompleteMove
(
bool
aForward
bool
aExtend
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
mSelection
;
nsIContent
*
limiter
=
frameSelection
-
>
GetAncestorLimiter
(
)
;
nsIFrame
*
frame
=
limiter
?
limiter
-
>
GetPrimaryFrame
(
)
:
FrameConstructor
(
)
-
>
GetRootElementFrame
(
)
;
if
(
!
frame
)
return
NS_ERROR_FAILURE
;
nsIFrame
:
:
CaretPosition
pos
=
frame
-
>
GetExtremeCaretPosition
(
!
aForward
)
;
const
nsFrameSelection
:
:
FocusMode
focusMode
=
aExtend
?
nsFrameSelection
:
:
FocusMode
:
:
kExtendSelection
:
nsFrameSelection
:
:
FocusMode
:
:
kCollapseToNewPoint
;
frameSelection
-
>
HandleClick
(
MOZ_KnownLive
(
pos
.
mResultContent
)
pos
.
mContentOffset
pos
.
mContentOffset
focusMode
aForward
?
CARET_ASSOCIATE_AFTER
:
CARET_ASSOCIATE_BEFORE
)
;
if
(
limiter
)
{
frameSelection
-
>
SetAncestorLimiter
(
limiter
)
;
}
return
ScrollSelectionIntoView
(
nsISelectionController
:
:
SELECTION_NORMAL
nsISelectionController
:
:
SELECTION_FOCUS_REGION
nsISelectionController
:
:
SCROLL_SYNCHRONOUS
|
nsISelectionController
:
:
SCROLL_FOR_CARET_MOVE
)
;
}
static
void
DoCheckVisibility
(
nsPresContext
*
aPresContext
nsIContent
*
aNode
int16_t
aStartOffset
int16_t
aEndOffset
bool
*
aRetval
)
{
nsIFrame
*
frame
=
aNode
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
)
{
return
;
}
bool
finished
=
false
;
frame
-
>
CheckVisibility
(
aPresContext
aStartOffset
aEndOffset
true
&
finished
aRetval
)
;
}
NS_IMETHODIMP
PresShell
:
:
CheckVisibility
(
nsINode
*
node
int16_t
startOffset
int16_t
EndOffset
bool
*
_retval
)
{
if
(
!
node
|
|
startOffset
>
EndOffset
|
|
!
_retval
|
|
startOffset
<
0
|
|
EndOffset
<
0
)
return
NS_ERROR_INVALID_ARG
;
*
_retval
=
false
;
nsCOMPtr
<
nsIContent
>
content
(
do_QueryInterface
(
node
)
)
;
if
(
!
content
)
return
NS_ERROR_FAILURE
;
DoCheckVisibility
(
mPresContext
content
startOffset
EndOffset
_retval
)
;
return
NS_OK
;
}
nsresult
PresShell
:
:
CheckVisibilityContent
(
nsIContent
*
aNode
int16_t
aStartOffset
int16_t
aEndOffset
bool
*
aRetval
)
{
if
(
!
aNode
|
|
aStartOffset
>
aEndOffset
|
|
!
aRetval
|
|
aStartOffset
<
0
|
|
aEndOffset
<
0
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
aRetval
=
false
;
DoCheckVisibility
(
mPresContext
aNode
aStartOffset
aEndOffset
aRetval
)
;
return
NS_OK
;
}
nsIFrame
*
PresShell
:
:
GetRootScrollFrame
(
)
const
{
nsIFrame
*
rootFrame
=
mFrameConstructor
-
>
GetRootFrame
(
)
;
if
(
!
rootFrame
|
|
!
rootFrame
-
>
IsViewportFrame
(
)
)
return
nullptr
;
nsIFrame
*
theFrame
=
rootFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
!
theFrame
|
|
!
theFrame
-
>
IsScrollFrame
(
)
)
return
nullptr
;
return
theFrame
;
}
nsIScrollableFrame
*
PresShell
:
:
GetRootScrollFrameAsScrollable
(
)
const
{
nsIFrame
*
frame
=
GetRootScrollFrame
(
)
;
if
(
!
frame
)
return
nullptr
;
nsIScrollableFrame
*
scrollableFrame
=
do_QueryFrame
(
frame
)
;
NS_ASSERTION
(
scrollableFrame
"
All
scroll
frames
must
implement
nsIScrollableFrame
"
)
;
return
scrollableFrame
;
}
nsPageSequenceFrame
*
PresShell
:
:
GetPageSequenceFrame
(
)
const
{
return
mFrameConstructor
-
>
GetPageSequenceFrame
(
)
;
}
nsCanvasFrame
*
PresShell
:
:
GetCanvasFrame
(
)
const
{
nsIFrame
*
frame
=
mFrameConstructor
-
>
GetDocElementContainingBlock
(
)
;
return
do_QueryFrame
(
frame
)
;
}
void
PresShell
:
:
RestoreRootScrollPosition
(
)
{
nsIScrollableFrame
*
scrollableFrame
=
GetRootScrollFrameAsScrollable
(
)
;
if
(
scrollableFrame
)
{
scrollableFrame
-
>
ScrollToRestoredPosition
(
)
;
}
}
void
PresShell
:
:
MaybeReleaseCapturingContent
(
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
FrameSelection
(
)
;
if
(
frameSelection
)
{
frameSelection
-
>
SetDragState
(
false
)
;
}
if
(
sCapturingContentInfo
.
mContent
&
&
sCapturingContentInfo
.
mContent
-
>
OwnerDoc
(
)
=
=
mDocument
)
{
PresShell
:
:
ReleaseCapturingContent
(
)
;
}
}
void
PresShell
:
:
BeginLoad
(
Document
*
aDocument
)
{
mDocumentLoading
=
true
;
gfxTextPerfMetrics
*
tp
=
nullptr
;
if
(
mPresContext
)
{
tp
=
mPresContext
-
>
GetTextPerfMetrics
(
)
;
}
bool
shouldLog
=
MOZ_LOG_TEST
(
gLog
LogLevel
:
:
Debug
)
;
if
(
shouldLog
|
|
tp
)
{
mLoadBegin
=
TimeStamp
:
:
Now
(
)
;
}
if
(
shouldLog
)
{
nsIURI
*
uri
=
mDocument
-
>
GetDocumentURI
(
)
;
MOZ_LOG
(
gLog
LogLevel
:
:
Debug
(
"
(
presshell
)
%
p
load
begin
[
%
s
]
\
n
"
this
uri
?
uri
-
>
GetSpecOrDefault
(
)
.
get
(
)
:
"
"
)
)
;
}
}
void
PresShell
:
:
EndLoad
(
Document
*
aDocument
)
{
MOZ_ASSERT
(
aDocument
=
=
mDocument
"
Wrong
document
"
)
;
RestoreRootScrollPosition
(
)
;
mDocumentLoading
=
false
;
}
bool
PresShell
:
:
IsLayoutFlushObserver
(
)
{
return
GetPresContext
(
)
-
>
RefreshDriver
(
)
-
>
IsLayoutFlushObserver
(
this
)
;
}
void
PresShell
:
:
LoadComplete
(
)
{
gfxTextPerfMetrics
*
tp
=
nullptr
;
if
(
mPresContext
)
{
tp
=
mPresContext
-
>
GetTextPerfMetrics
(
)
;
}
bool
shouldLog
=
MOZ_LOG_TEST
(
gLog
LogLevel
:
:
Debug
)
;
if
(
shouldLog
|
|
tp
)
{
TimeDuration
loadTime
=
TimeStamp
:
:
Now
(
)
-
mLoadBegin
;
nsIURI
*
uri
=
mDocument
-
>
GetDocumentURI
(
)
;
nsAutoCString
spec
;
if
(
uri
)
{
spec
=
uri
-
>
GetSpecOrDefault
(
)
;
}
if
(
shouldLog
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Debug
(
"
(
presshell
)
%
p
load
done
time
-
ms
:
%
9
.
2f
[
%
s
]
\
n
"
this
loadTime
.
ToMilliseconds
(
)
spec
.
get
(
)
)
)
;
}
if
(
tp
)
{
tp
-
>
Accumulate
(
)
;
if
(
tp
-
>
cumulative
.
numChars
>
0
)
{
LogTextPerfStats
(
tp
this
tp
-
>
cumulative
loadTime
.
ToMilliseconds
(
)
eLog_loaddone
spec
.
get
(
)
)
;
}
}
}
}
#
ifdef
DEBUG
void
PresShell
:
:
VerifyHasDirtyRootAncestor
(
nsIFrame
*
aFrame
)
{
return
;
if
(
!
aFrame
-
>
GetParent
(
)
)
{
return
;
}
while
(
aFrame
&
&
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_HAS_DIRTY_CHILDREN
)
)
{
if
(
(
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_REFLOW_ROOT
|
NS_FRAME_DYNAMIC_REFLOW_ROOT
)
|
|
!
aFrame
-
>
GetParent
(
)
)
&
&
mDirtyRoots
.
Contains
(
aFrame
)
)
{
return
;
}
aFrame
=
aFrame
-
>
GetParent
(
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Frame
has
dirty
bits
set
but
isn
'
t
scheduled
to
be
"
"
reflowed
?
"
)
;
}
#
endif
void
PresShell
:
:
PostPendingScrollAnchorSelection
(
mozilla
:
:
layout
:
:
ScrollAnchorContainer
*
aContainer
)
{
mPendingScrollAnchorSelection
.
Insert
(
aContainer
-
>
ScrollableFrame
(
)
)
;
}
void
PresShell
:
:
FlushPendingScrollAnchorSelections
(
)
{
for
(
nsIScrollableFrame
*
scroll
:
mPendingScrollAnchorSelection
)
{
scroll
-
>
Anchor
(
)
-
>
SelectAnchor
(
)
;
}
mPendingScrollAnchorSelection
.
Clear
(
)
;
}
void
PresShell
:
:
PostPendingScrollAnchorAdjustment
(
ScrollAnchorContainer
*
aContainer
)
{
mPendingScrollAnchorAdjustment
.
Insert
(
aContainer
-
>
ScrollableFrame
(
)
)
;
}
void
PresShell
:
:
FlushPendingScrollAnchorAdjustments
(
)
{
for
(
nsIScrollableFrame
*
scroll
:
mPendingScrollAnchorAdjustment
)
{
scroll
-
>
Anchor
(
)
-
>
ApplyAdjustments
(
)
;
}
mPendingScrollAnchorAdjustment
.
Clear
(
)
;
}
void
PresShell
:
:
FrameNeedsReflow
(
nsIFrame
*
aFrame
IntrinsicDirty
aIntrinsicDirty
nsFrameState
aBitToAdd
ReflowRootHandling
aRootHandling
)
{
MOZ_ASSERT
(
aBitToAdd
=
=
NS_FRAME_IS_DIRTY
|
|
aBitToAdd
=
=
NS_FRAME_HAS_DIRTY_CHILDREN
|
|
!
aBitToAdd
"
Unexpected
bits
being
added
"
)
;
NS_ASSERTION
(
!
(
aIntrinsicDirty
=
=
IntrinsicDirty
:
:
StyleChange
&
&
aBitToAdd
=
=
NS_FRAME_HAS_DIRTY_CHILDREN
)
"
bits
don
'
t
correspond
to
style
change
reason
"
)
;
NS_ASSERTION
(
!
mIsReflowing
"
can
'
t
mark
frame
dirty
during
reflow
"
)
;
if
(
!
mDidInitialize
)
return
;
if
(
mIsDestroying
)
return
;
#
ifdef
DEBUG
if
(
mInVerifyReflow
)
return
;
if
(
VerifyReflowFlags
:
:
NoisyCommands
&
gVerifyReflowFlags
)
{
printf
(
"
\
nPresShell
%
p
:
frame
%
p
needs
reflow
\
n
"
(
void
*
)
this
(
void
*
)
aFrame
)
;
if
(
VerifyReflowFlags
:
:
ReallyNoisyCommands
&
gVerifyReflowFlags
)
{
printf
(
"
Current
content
model
:
\
n
"
)
;
Element
*
rootElement
=
mDocument
-
>
GetRootElement
(
)
;
if
(
rootElement
)
{
rootElement
-
>
List
(
stdout
0
)
;
}
}
}
#
endif
AutoTArray
<
nsIFrame
*
4
>
subtrees
;
subtrees
.
AppendElement
(
aFrame
)
;
do
{
nsIFrame
*
subtreeRoot
=
subtrees
.
PopLastElement
(
)
;
bool
wasDirty
=
subtreeRoot
-
>
IsSubtreeDirty
(
)
;
subtreeRoot
-
>
AddStateBits
(
aBitToAdd
)
;
bool
targetNeedsReflowFromParent
;
switch
(
aRootHandling
)
{
case
ReflowRootHandling
:
:
PositionOrSizeChange
:
targetNeedsReflowFromParent
=
true
;
break
;
case
ReflowRootHandling
:
:
NoPositionOrSizeChange
:
targetNeedsReflowFromParent
=
false
;
break
;
case
ReflowRootHandling
:
:
InferFromBitToAdd
:
targetNeedsReflowFromParent
=
(
aBitToAdd
=
=
NS_FRAME_IS_DIRTY
)
;
break
;
}
#
define
FRAME_IS_REFLOW_ROOT
(
_f
)
\
(
(
_f
)
-
>
HasAnyStateBits
(
NS_FRAME_REFLOW_ROOT
|
\
NS_FRAME_DYNAMIC_REFLOW_ROOT
)
&
&
\
(
(
_f
)
!
=
subtreeRoot
|
|
!
targetNeedsReflowFromParent
)
)
if
(
aIntrinsicDirty
!
=
IntrinsicDirty
:
:
Resize
)
{
for
(
nsIFrame
*
a
=
subtreeRoot
;
a
&
&
!
FRAME_IS_REFLOW_ROOT
(
a
)
;
a
=
a
-
>
GetParent
(
)
)
{
a
-
>
MarkIntrinsicISizesDirty
(
)
;
if
(
a
-
>
IsAbsolutelyPositioned
(
)
)
{
break
;
}
}
}
const
bool
styleChange
=
(
aIntrinsicDirty
=
=
IntrinsicDirty
:
:
StyleChange
)
;
const
bool
dirty
=
(
aBitToAdd
=
=
NS_FRAME_IS_DIRTY
)
;
if
(
styleChange
|
|
dirty
)
{
AutoTArray
<
nsIFrame
*
32
>
stack
;
stack
.
AppendElement
(
subtreeRoot
)
;
do
{
nsIFrame
*
f
=
stack
.
PopLastElement
(
)
;
if
(
styleChange
&
&
f
-
>
IsPlaceholderFrame
(
)
)
{
if
(
nsIFrame
*
oof
=
static_cast
<
nsPlaceholderFrame
*
>
(
f
)
-
>
GetOutOfFlowFrame
(
)
)
{
if
(
!
nsLayoutUtils
:
:
IsProperAncestorFrame
(
subtreeRoot
oof
)
)
{
subtrees
.
AppendElement
(
oof
)
;
}
}
}
for
(
const
auto
&
childList
:
f
-
>
ChildLists
(
)
)
{
for
(
nsIFrame
*
kid
:
childList
.
mList
)
{
if
(
styleChange
)
{
kid
-
>
MarkIntrinsicISizesDirty
(
)
;
}
if
(
dirty
)
{
kid
-
>
AddStateBits
(
NS_FRAME_IS_DIRTY
)
;
}
stack
.
AppendElement
(
kid
)
;
}
}
}
while
(
stack
.
Length
(
)
!
=
0
)
;
}
if
(
!
aBitToAdd
)
{
continue
;
}
nsIFrame
*
f
=
subtreeRoot
;
for
(
;
;
)
{
if
(
FRAME_IS_REFLOW_ROOT
(
f
)
|
|
!
f
-
>
GetParent
(
)
)
{
if
(
!
wasDirty
)
{
mDirtyRoots
.
Add
(
f
)
;
SetNeedLayoutFlush
(
)
;
}
#
ifdef
DEBUG
else
{
VerifyHasDirtyRootAncestor
(
f
)
;
}
#
endif
break
;
}
nsIFrame
*
child
=
f
;
f
=
f
-
>
GetParent
(
)
;
wasDirty
=
f
-
>
IsSubtreeDirty
(
)
;
f
-
>
ChildIsDirty
(
child
)
;
NS_ASSERTION
(
f
-
>
HasAnyStateBits
(
NS_FRAME_HAS_DIRTY_CHILDREN
)
"
ChildIsDirty
didn
'
t
do
its
job
"
)
;
if
(
wasDirty
)
{
#
ifdef
DEBUG
VerifyHasDirtyRootAncestor
(
f
)
;
#
endif
break
;
}
}
}
while
(
subtrees
.
Length
(
)
!
=
0
)
;
MaybeScheduleReflow
(
)
;
}
void
PresShell
:
:
FrameNeedsToContinueReflow
(
nsIFrame
*
aFrame
)
{
NS_ASSERTION
(
mIsReflowing
"
Must
be
in
reflow
when
marking
path
dirty
.
"
)
;
MOZ_ASSERT
(
mCurrentReflowRoot
"
Must
have
a
current
reflow
root
here
"
)
;
NS_ASSERTION
(
aFrame
=
=
mCurrentReflowRoot
|
|
nsLayoutUtils
:
:
IsProperAncestorFrame
(
mCurrentReflowRoot
aFrame
)
"
Frame
passed
in
is
not
the
descendant
of
mCurrentReflowRoot
"
)
;
NS_ASSERTION
(
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_IN_REFLOW
)
"
Frame
passed
in
not
in
reflow
?
"
)
;
mFramesToDirty
.
Insert
(
aFrame
)
;
}
already_AddRefed
<
nsIContent
>
PresShell
:
:
GetContentForScrolling
(
)
const
{
if
(
nsCOMPtr
<
nsIContent
>
focused
=
GetFocusedContentInOurWindow
(
)
)
{
return
focused
.
forget
(
)
;
}
return
GetSelectedContentForScrolling
(
)
;
}
already_AddRefed
<
nsIContent
>
PresShell
:
:
GetSelectedContentForScrolling
(
)
const
{
nsCOMPtr
<
nsIContent
>
selectedContent
;
if
(
mSelection
)
{
Selection
*
domSelection
=
mSelection
-
>
GetSelection
(
SelectionType
:
:
eNormal
)
;
if
(
domSelection
)
{
selectedContent
=
nsIContent
:
:
FromNodeOrNull
(
domSelection
-
>
GetFocusNode
(
)
)
;
}
}
return
selectedContent
.
forget
(
)
;
}
nsIScrollableFrame
*
PresShell
:
:
GetScrollableFrameToScrollForContent
(
nsIContent
*
aContent
ScrollDirections
aDirections
)
{
nsIScrollableFrame
*
scrollFrame
=
nullptr
;
if
(
aContent
)
{
nsIFrame
*
startFrame
=
aContent
-
>
GetPrimaryFrame
(
)
;
if
(
startFrame
)
{
scrollFrame
=
startFrame
-
>
GetScrollTargetFrame
(
)
;
if
(
scrollFrame
)
{
startFrame
=
scrollFrame
-
>
GetScrolledFrame
(
)
;
}
scrollFrame
=
nsLayoutUtils
:
:
GetNearestScrollableFrameForDirection
(
startFrame
aDirections
)
;
}
}
if
(
!
scrollFrame
)
{
scrollFrame
=
GetRootScrollFrameAsScrollable
(
)
;
if
(
!
scrollFrame
|
|
!
scrollFrame
-
>
GetScrolledFrame
(
)
)
{
return
nullptr
;
}
scrollFrame
=
nsLayoutUtils
:
:
GetNearestScrollableFrameForDirection
(
scrollFrame
-
>
GetScrolledFrame
(
)
aDirections
)
;
}
return
scrollFrame
;
}
nsIScrollableFrame
*
PresShell
:
:
GetScrollableFrameToScroll
(
ScrollDirections
aDirections
)
{
nsCOMPtr
<
nsIContent
>
content
=
GetContentForScrolling
(
)
;
return
GetScrollableFrameToScrollForContent
(
content
.
get
(
)
aDirections
)
;
}
void
PresShell
:
:
CancelAllPendingReflows
(
)
{
mDirtyRoots
.
Clear
(
)
;
if
(
mObservingLayoutFlushes
)
{
GetPresContext
(
)
-
>
RefreshDriver
(
)
-
>
RemoveLayoutFlushObserver
(
this
)
;
mObservingLayoutFlushes
=
false
;
}
ASSERT_REFLOW_SCHEDULED_STATE
(
)
;
}
static
bool
DestroyFramesAndStyleDataFor
(
Element
*
aElement
nsPresContext
&
aPresContext
RestyleManager
:
:
IncludeRoot
aIncludeRoot
)
{
bool
didReconstruct
=
aPresContext
.
FrameConstructor
(
)
-
>
DestroyFramesFor
(
aElement
)
;
RestyleManager
:
:
ClearServoDataFromSubtree
(
aElement
aIncludeRoot
)
;
return
didReconstruct
;
}
void
PresShell
:
:
SlotAssignmentWillChange
(
Element
&
aElement
HTMLSlotElement
*
aOldSlot
HTMLSlotElement
*
aNewSlot
)
{
MOZ_ASSERT
(
aOldSlot
!
=
aNewSlot
)
;
if
(
MOZ_UNLIKELY
(
!
mDidInitialize
)
)
{
return
;
}
if
(
aOldSlot
&
&
aOldSlot
-
>
AssignedNodes
(
)
.
Length
(
)
=
=
1
&
&
aOldSlot
-
>
HasChildren
(
)
)
{
DestroyFramesForAndRestyle
(
aOldSlot
)
;
}
DestroyFramesAndStyleDataFor
(
&
aElement
*
mPresContext
RestyleManager
:
:
IncludeRoot
:
:
Yes
)
;
if
(
aNewSlot
)
{
if
(
aNewSlot
-
>
AssignedNodes
(
)
.
IsEmpty
(
)
&
&
aNewSlot
-
>
HasChildren
(
)
)
{
DestroyFramesForAndRestyle
(
aNewSlot
)
;
}
else
if
(
aNewSlot
-
>
HasServoData
(
)
&
&
!
Servo_Element_IsDisplayNone
(
aNewSlot
)
)
{
aNewSlot
-
>
NoteDescendantsNeedFramesForServo
(
)
;
aElement
.
SetFlags
(
NODE_NEEDS_FRAME
)
;
aNewSlot
-
>
SetHasDirtyDescendantsForServo
(
)
;
aNewSlot
-
>
NoteDirtySubtreeForServo
(
)
;
}
}
}
#
ifdef
DEBUG
static
void
AssertNoFramesInSubtree
(
nsIContent
*
aContent
)
{
for
(
nsINode
*
node
:
ShadowIncludingTreeIterator
(
*
aContent
)
)
{
nsIContent
*
c
=
nsIContent
:
:
FromNode
(
node
)
;
MOZ_ASSERT
(
!
c
-
>
GetPrimaryFrame
(
)
)
;
}
}
#
endif
void
PresShell
:
:
DestroyFramesForAndRestyle
(
Element
*
aElement
)
{
#
ifdef
DEBUG
auto
postCondition
=
mozilla
:
:
MakeScopeExit
(
[
&
]
(
)
{
AssertNoFramesInSubtree
(
aElement
)
;
}
)
;
#
endif
MOZ_ASSERT
(
aElement
)
;
if
(
MOZ_UNLIKELY
(
!
mDidInitialize
)
)
{
return
;
}
if
(
!
aElement
-
>
GetFlattenedTreeParentNode
(
)
)
{
return
;
}
nsAutoScriptBlocker
scriptBlocker
;
+
+
mChangeNestCount
;
const
bool
didReconstruct
=
FrameConstructor
(
)
-
>
DestroyFramesFor
(
aElement
)
;
RestyleManager
:
:
ClearServoDataFromSubtree
(
aElement
RestyleManager
:
:
IncludeRoot
:
:
No
)
;
auto
changeHint
=
didReconstruct
?
nsChangeHint
(
0
)
:
nsChangeHint_ReconstructFrame
;
mPresContext
-
>
RestyleManager
(
)
-
>
PostRestyleEvent
(
aElement
RestyleHint
:
:
RestyleSubtree
(
)
changeHint
)
;
-
-
mChangeNestCount
;
}
void
PresShell
:
:
PostRecreateFramesFor
(
Element
*
aElement
)
{
if
(
MOZ_UNLIKELY
(
!
mDidInitialize
)
)
{
return
;
}
mPresContext
-
>
RestyleManager
(
)
-
>
PostRestyleEvent
(
aElement
RestyleHint
{
0
}
nsChangeHint_ReconstructFrame
)
;
}
void
PresShell
:
:
RestyleForAnimation
(
Element
*
aElement
RestyleHint
aHint
)
{
mPresContext
-
>
RestyleManager
(
)
-
>
PostRestyleEvent
(
aElement
aHint
nsChangeHint
(
0
)
)
;
}
void
PresShell
:
:
SetForwardingContainer
(
const
WeakPtr
<
nsDocShell
>
&
aContainer
)
{
mForwardingContainer
=
aContainer
;
}
void
PresShell
:
:
ClearFrameRefs
(
nsIFrame
*
aFrame
)
{
mPresContext
-
>
EventStateManager
(
)
-
>
ClearFrameRefs
(
aFrame
)
;
AutoWeakFrame
*
weakFrame
=
mAutoWeakFrames
;
while
(
weakFrame
)
{
AutoWeakFrame
*
prev
=
weakFrame
-
>
GetPreviousWeakFrame
(
)
;
if
(
weakFrame
-
>
GetFrame
(
)
=
=
aFrame
)
{
weakFrame
-
>
Clear
(
this
)
;
}
weakFrame
=
prev
;
}
AutoTArray
<
WeakFrame
*
4
>
toRemove
;
for
(
WeakFrame
*
weakFrame
:
mWeakFrames
)
{
if
(
weakFrame
-
>
GetFrame
(
)
=
=
aFrame
)
{
toRemove
.
AppendElement
(
weakFrame
)
;
}
}
for
(
WeakFrame
*
weakFrame
:
toRemove
)
{
weakFrame
-
>
Clear
(
this
)
;
}
}
already_AddRefed
<
gfxContext
>
PresShell
:
:
CreateReferenceRenderingContext
(
)
{
nsDeviceContext
*
devCtx
=
mPresContext
-
>
DeviceContext
(
)
;
RefPtr
<
gfxContext
>
rc
;
if
(
mPresContext
-
>
IsScreen
(
)
)
{
rc
=
gfxContext
:
:
CreateOrNull
(
gfxPlatform
:
:
GetPlatform
(
)
-
>
ScreenReferenceDrawTarget
(
)
.
get
(
)
)
;
}
else
{
rc
=
devCtx
-
>
CreateReferenceRenderingContext
(
)
;
}
return
rc
?
rc
.
forget
(
)
:
nullptr
;
}
nsresult
PresShell
:
:
GoToAnchor
(
const
nsAString
&
aAnchorName
bool
aScroll
ScrollFlags
aAdditionalScrollFlags
)
{
if
(
!
mDocument
)
{
return
NS_ERROR_FAILURE
;
}
const
Element
*
root
=
mDocument
-
>
GetRootElement
(
)
;
if
(
root
&
&
root
-
>
IsSVGElement
(
nsGkAtoms
:
:
svg
)
)
{
if
(
SVGFragmentIdentifier
:
:
ProcessFragmentIdentifier
(
mDocument
aAnchorName
)
)
{
return
NS_OK
;
}
}
RefPtr
<
EventStateManager
>
esm
=
mPresContext
-
>
EventStateManager
(
)
;
if
(
aAnchorName
.
IsEmpty
(
)
)
{
NS_ASSERTION
(
!
aScroll
"
can
'
t
scroll
to
empty
anchor
name
"
)
;
esm
-
>
SetContentState
(
nullptr
NS_EVENT_STATE_URLTARGET
)
;
return
NS_OK
;
}
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsIContent
>
content
;
if
(
mDocument
)
{
content
=
mDocument
-
>
GetElementById
(
aAnchorName
)
;
}
if
(
!
content
&
&
mDocument
-
>
IsHTMLDocument
(
)
)
{
nsCOMPtr
<
nsINodeList
>
list
=
mDocument
-
>
GetElementsByName
(
aAnchorName
)
;
if
(
list
)
{
uint32_t
length
=
list
-
>
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
length
;
i
+
+
)
{
nsIContent
*
node
=
list
-
>
Item
(
i
)
;
if
(
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
a
)
)
{
content
=
node
;
break
;
}
}
}
}
if
(
!
content
&
&
!
mDocument
-
>
IsHTMLDocument
(
)
)
{
constexpr
auto
nameSpace
=
u
"
http
:
/
/
www
.
w3
.
org
/
1999
/
xhtml
"
_ns
;
nsCOMPtr
<
nsINodeList
>
list
=
mDocument
-
>
GetElementsByTagNameNS
(
nameSpace
u
"
a
"
_ns
)
;
for
(
uint32_t
i
=
0
;
true
;
i
+
+
)
{
nsIContent
*
node
=
list
-
>
Item
(
i
)
;
if
(
!
node
)
{
break
;
}
if
(
node
-
>
IsElement
(
)
&
&
node
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
name
aAnchorName
eCaseMatters
)
)
{
content
=
node
;
break
;
}
}
}
esm
-
>
SetContentState
(
content
NS_EVENT_STATE_URLTARGET
)
;
#
ifdef
ACCESSIBILITY
nsIContent
*
anchorTarget
=
content
;
#
endif
nsIScrollableFrame
*
rootScroll
=
GetRootScrollFrameAsScrollable
(
)
;
if
(
rootScroll
&
&
rootScroll
-
>
DidHistoryRestore
(
)
)
{
aScroll
=
false
;
rootScroll
-
>
ClearDidHistoryRestore
(
)
;
}
if
(
content
)
{
if
(
aScroll
)
{
rv
=
ScrollContentIntoView
(
content
ScrollAxis
(
kScrollToTop
WhenToScroll
:
:
Always
)
ScrollAxis
(
)
ScrollFlags
:
:
AnchorScrollFlags
|
aAdditionalScrollFlags
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsIScrollableFrame
*
rootScroll
=
GetRootScrollFrameAsScrollable
(
)
;
if
(
rootScroll
)
{
mLastAnchorScrolledTo
=
content
;
mLastAnchorScrollPositionY
=
rootScroll
-
>
GetScrollPosition
(
)
.
y
;
}
}
bool
selectAnchor
=
Preferences
:
:
GetBool
(
"
layout
.
selectanchor
"
)
;
RefPtr
<
nsRange
>
jumpToRange
=
nsRange
:
:
Create
(
mDocument
)
;
while
(
content
&
&
content
-
>
GetFirstChild
(
)
)
{
content
=
content
-
>
GetFirstChild
(
)
;
}
jumpToRange
-
>
SelectNodeContents
(
*
content
IgnoreErrors
(
)
)
;
RefPtr
<
Selection
>
sel
=
mSelection
-
>
GetSelection
(
SelectionType
:
:
eNormal
)
;
if
(
sel
)
{
sel
-
>
RemoveAllRanges
(
IgnoreErrors
(
)
)
;
sel
-
>
AddRangeAndSelectFramesAndNotifyListeners
(
*
jumpToRange
IgnoreErrors
(
)
)
;
if
(
!
selectAnchor
)
{
sel
-
>
CollapseToStart
(
IgnoreErrors
(
)
)
;
}
}
nsPIDOMWindowOuter
*
win
=
mDocument
-
>
GetWindow
(
)
;
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
fm
&
&
win
)
{
nsCOMPtr
<
mozIDOMWindowProxy
>
focusedWindow
;
fm
-
>
GetFocusedWindow
(
getter_AddRefs
(
focusedWindow
)
)
;
if
(
SameCOMIdentity
(
win
focusedWindow
)
)
{
fm
-
>
ClearFocus
(
focusedWindow
)
;
}
}
nsCOMPtr
<
SVGAnimationElement
>
animationElement
=
do_QueryInterface
(
content
)
;
if
(
animationElement
)
{
animationElement
-
>
ActivateByHyperlink
(
)
;
}
}
else
{
rv
=
NS_ERROR_FAILURE
;
if
(
nsContentUtils
:
:
EqualsIgnoreASCIICase
(
aAnchorName
u
"
top
"
_ns
)
)
{
rv
=
NS_OK
;
nsIScrollableFrame
*
sf
=
GetRootScrollFrameAsScrollable
(
)
;
if
(
aScroll
&
&
sf
)
{
ScrollMode
scrollMode
=
sf
-
>
IsSmoothScroll
(
)
?
ScrollMode
:
:
SmoothMsd
:
ScrollMode
:
:
Instant
;
sf
-
>
ScrollTo
(
nsPoint
(
0
0
)
scrollMode
)
;
}
}
}
#
ifdef
ACCESSIBILITY
if
(
anchorTarget
)
{
if
(
nsAccessibilityService
*
accService
=
GetAccessibilityService
(
)
)
{
accService
-
>
NotifyOfAnchorJumpTo
(
anchorTarget
)
;
}
}
#
endif
return
rv
;
}
nsresult
PresShell
:
:
ScrollToAnchor
(
)
{
nsCOMPtr
<
nsIContent
>
lastAnchor
=
std
:
:
move
(
mLastAnchorScrolledTo
)
;
if
(
!
lastAnchor
)
{
return
NS_OK
;
}
NS_ASSERTION
(
mDidInitialize
"
should
have
done
initial
reflow
by
now
"
)
;
nsIScrollableFrame
*
rootScroll
=
GetRootScrollFrameAsScrollable
(
)
;
if
(
!
rootScroll
|
|
mLastAnchorScrollPositionY
!
=
rootScroll
-
>
GetScrollPosition
(
)
.
y
)
{
return
NS_OK
;
}
return
ScrollContentIntoView
(
lastAnchor
ScrollAxis
(
kScrollToTop
WhenToScroll
:
:
Always
)
ScrollAxis
(
)
ScrollFlags
:
:
AnchorScrollFlags
)
;
}
static
void
AccumulateFrameBounds
(
nsIFrame
*
aContainerFrame
nsIFrame
*
aFrame
bool
aUseWholeLineHeightForInlines
nsRect
&
aRect
bool
&
aHaveRect
nsIFrame
*
&
aPrevBlock
nsAutoLineIterator
&
aLines
int32_t
&
aCurLine
)
{
nsIFrame
*
frame
=
aFrame
;
nsRect
frameBounds
=
nsRect
(
nsPoint
(
0
0
)
aFrame
-
>
GetSize
(
)
)
;
if
(
frameBounds
.
height
=
=
0
|
|
aUseWholeLineHeightForInlines
)
{
nsIFrame
*
prevFrame
=
aFrame
;
nsIFrame
*
f
=
aFrame
;
while
(
f
&
&
f
-
>
IsFrameOfType
(
nsIFrame
:
:
eLineParticipant
)
&
&
!
f
-
>
IsTransformed
(
)
&
&
!
f
-
>
IsAbsPosContainingBlock
(
)
)
{
prevFrame
=
f
;
f
=
prevFrame
-
>
GetParent
(
)
;
}
if
(
f
!
=
aFrame
&
&
f
&
&
f
-
>
IsBlockFrame
(
)
)
{
if
(
f
!
=
aPrevBlock
)
{
aLines
=
f
-
>
GetLineIterator
(
)
;
aPrevBlock
=
f
;
aCurLine
=
0
;
}
if
(
aLines
)
{
int32_t
index
=
aLines
-
>
FindLineContaining
(
prevFrame
aCurLine
)
;
if
(
index
>
=
0
)
{
auto
line
=
aLines
-
>
GetLine
(
index
)
.
unwrap
(
)
;
frameBounds
+
=
frame
-
>
GetOffsetTo
(
f
)
;
frame
=
f
;
if
(
line
.
mLineBounds
.
y
<
frameBounds
.
y
)
{
frameBounds
.
height
=
frameBounds
.
YMost
(
)
-
line
.
mLineBounds
.
y
;
frameBounds
.
y
=
line
.
mLineBounds
.
y
;
}
}
}
}
}
nsRect
transformedBounds
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
frame
frameBounds
aContainerFrame
)
;
if
(
aHaveRect
)
{
aRect
=
aRect
.
UnionEdges
(
transformedBounds
)
;
}
else
{
aHaveRect
=
true
;
aRect
=
transformedBounds
;
}
}
static
bool
ComputeNeedToScroll
(
WhenToScroll
aWhenToScroll
nscoord
aLineSize
nscoord
aRectMin
nscoord
aRectMax
nscoord
aViewMin
nscoord
aViewMax
)
{
switch
(
aWhenToScroll
)
{
case
WhenToScroll
:
:
Always
:
return
true
;
case
WhenToScroll
:
:
IfNotVisible
:
return
aRectMax
-
aLineSize
<
=
aViewMin
|
|
aRectMin
+
aLineSize
>
=
aViewMax
;
case
WhenToScroll
:
:
IfNotFullyVisible
:
return
!
(
aRectMin
>
=
aViewMin
&
&
aRectMax
<
=
aViewMax
)
&
&
std
:
:
min
(
aViewMax
aRectMax
)
-
std
:
:
max
(
aRectMin
aViewMin
)
<
aViewMax
-
aViewMin
;
}
return
false
;
}
static
nscoord
ComputeWhereToScroll
(
WhereToScroll
aWhereToScroll
nscoord
aOriginalCoord
nscoord
aRectMin
nscoord
aRectMax
nscoord
aViewMin
nscoord
aViewMax
nscoord
*
aRangeMin
nscoord
*
aRangeMax
)
{
nscoord
resultCoord
=
aOriginalCoord
;
nscoord
scrollPortLength
=
aViewMax
-
aViewMin
;
if
(
kScrollMinimum
=
=
aWhereToScroll
)
{
nscoord
min
=
std
:
:
min
(
aRectMin
aRectMax
-
scrollPortLength
)
;
nscoord
max
=
std
:
:
max
(
aRectMin
aRectMax
-
scrollPortLength
)
;
resultCoord
=
std
:
:
min
(
std
:
:
max
(
aOriginalCoord
min
)
max
)
;
}
else
{
nscoord
frameAlignCoord
=
NSToCoordRound
(
aRectMin
+
(
aRectMax
-
aRectMin
)
*
(
aWhereToScroll
/
100
.
0f
)
)
;
resultCoord
=
NSToCoordRound
(
frameAlignCoord
-
scrollPortLength
*
(
aWhereToScroll
/
100
.
0f
)
)
;
}
*
aRangeMin
=
std
:
:
min
(
resultCoord
aRectMax
-
scrollPortLength
)
;
*
aRangeMax
=
std
:
:
max
(
resultCoord
aRectMin
)
;
return
resultCoord
;
}
static
void
ScrollToShowRect
(
nsIScrollableFrame
*
aFrameAsScrollable
const
nsRect
&
aRect
ScrollAxis
aVertical
ScrollAxis
aHorizontal
ScrollFlags
aScrollFlags
)
{
nsPoint
scrollPt
=
aFrameAsScrollable
-
>
GetVisualViewportOffset
(
)
;
const
nsPoint
originalScrollPt
=
scrollPt
;
const
nsRect
visibleRect
(
scrollPt
aFrameAsScrollable
-
>
GetVisualViewportSize
(
)
)
;
const
nsMargin
scrollPadding
=
(
aScrollFlags
&
ScrollFlags
:
:
IgnoreMarginAndPadding
)
?
nsMargin
(
)
:
aFrameAsScrollable
-
>
GetScrollPadding
(
)
;
const
nsRect
rectToScrollIntoView
=
[
&
]
{
nsRect
r
(
aRect
)
;
r
.
Inflate
(
scrollPadding
)
;
return
r
.
Intersect
(
aFrameAsScrollable
-
>
GetScrolledRect
(
)
)
;
}
(
)
;
nsSize
lineSize
;
if
(
aVertical
.
mWhenToScroll
=
=
WhenToScroll
:
:
IfNotVisible
|
|
aHorizontal
.
mWhenToScroll
=
=
WhenToScroll
:
:
IfNotVisible
)
{
lineSize
=
aFrameAsScrollable
-
>
GetLineScrollAmount
(
)
;
}
ScrollStyles
ss
=
aFrameAsScrollable
-
>
GetScrollStyles
(
)
;
nsRect
allowedRange
(
scrollPt
nsSize
(
0
0
)
)
;
ScrollDirections
directions
=
aFrameAsScrollable
-
>
GetAvailableScrollingDirections
(
)
;
if
(
(
(
aScrollFlags
&
ScrollFlags
:
:
ScrollOverflowHidden
)
|
|
ss
.
mVertical
!
=
StyleOverflow
:
:
Hidden
)
&
&
(
!
aVertical
.
mOnlyIfPerceivedScrollableDirection
|
|
(
directions
.
contains
(
ScrollDirection
:
:
eVertical
)
)
)
)
{
if
(
ComputeNeedToScroll
(
aVertical
.
mWhenToScroll
lineSize
.
height
aRect
.
y
aRect
.
YMost
(
)
visibleRect
.
y
+
scrollPadding
.
top
visibleRect
.
YMost
(
)
-
scrollPadding
.
bottom
)
)
{
nscoord
maxHeight
;
scrollPt
.
y
=
ComputeWhereToScroll
(
aVertical
.
mWhereToScroll
scrollPt
.
y
rectToScrollIntoView
.
y
rectToScrollIntoView
.
YMost
(
)
visibleRect
.
y
visibleRect
.
YMost
(
)
&
allowedRange
.
y
&
maxHeight
)
;
allowedRange
.
height
=
maxHeight
-
allowedRange
.
y
;
}
}
if
(
(
(
aScrollFlags
&
ScrollFlags
:
:
ScrollOverflowHidden
)
|
|
ss
.
mHorizontal
!
=
StyleOverflow
:
:
Hidden
)
&
&
(
!
aHorizontal
.
mOnlyIfPerceivedScrollableDirection
|
|
(
directions
.
contains
(
ScrollDirection
:
:
eHorizontal
)
)
)
)
{
if
(
ComputeNeedToScroll
(
aHorizontal
.
mWhenToScroll
lineSize
.
width
aRect
.
x
aRect
.
XMost
(
)
visibleRect
.
x
+
scrollPadding
.
left
visibleRect
.
XMost
(
)
-
scrollPadding
.
right
)
)
{
nscoord
maxWidth
;
scrollPt
.
x
=
ComputeWhereToScroll
(
aHorizontal
.
mWhereToScroll
scrollPt
.
x
rectToScrollIntoView
.
x
rectToScrollIntoView
.
XMost
(
)
visibleRect
.
x
visibleRect
.
XMost
(
)
&
allowedRange
.
x
&
maxWidth
)
;
allowedRange
.
width
=
maxWidth
-
allowedRange
.
x
;
}
}
if
(
scrollPt
=
=
originalScrollPt
)
{
return
;
}
ScrollMode
scrollMode
=
ScrollMode
:
:
Instant
;
bool
autoBehaviorIsSmooth
=
aFrameAsScrollable
-
>
IsSmoothScroll
(
)
;
bool
smoothScroll
=
(
aScrollFlags
&
ScrollFlags
:
:
ScrollSmooth
)
|
|
(
(
aScrollFlags
&
ScrollFlags
:
:
ScrollSmoothAuto
)
&
&
autoBehaviorIsSmooth
)
;
if
(
StaticPrefs
:
:
layout_css_scroll_behavior_enabled
(
)
&
&
smoothScroll
)
{
scrollMode
=
ScrollMode
:
:
SmoothMsd
;
}
nsIFrame
*
frame
=
do_QueryFrame
(
aFrameAsScrollable
)
;
AutoWeakFrame
weakFrame
(
frame
)
;
aFrameAsScrollable
-
>
ScrollTo
(
scrollPt
scrollMode
&
allowedRange
aScrollFlags
&
ScrollFlags
:
:
ScrollSnap
?
nsIScrollbarMediator
:
:
ENABLE_SNAP
:
nsIScrollbarMediator
:
:
DISABLE_SNAP
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
;
}
if
(
aFrameAsScrollable
-
>
IsRootScrollFrameOfDocument
(
)
&
&
frame
-
>
PresShell
(
)
-
>
GetPresContext
(
)
-
>
IsRootContentDocument
(
)
)
{
frame
-
>
PresShell
(
)
-
>
ScrollToVisual
(
scrollPt
FrameMetrics
:
:
eMainThread
scrollMode
)
;
}
}
nsresult
PresShell
:
:
ScrollContentIntoView
(
nsIContent
*
aContent
ScrollAxis
aVertical
ScrollAxis
aHorizontal
ScrollFlags
aScrollFlags
)
{
NS_ENSURE_TRUE
(
aContent
NS_ERROR_NULL_POINTER
)
;
RefPtr
<
Document
>
composedDoc
=
aContent
-
>
GetComposedDoc
(
)
;
NS_ENSURE_STATE
(
composedDoc
)
;
NS_ASSERTION
(
mDidInitialize
"
should
have
done
initial
reflow
by
now
"
)
;
if
(
mContentToScrollTo
)
{
mContentToScrollTo
-
>
RemoveProperty
(
nsGkAtoms
:
:
scrolling
)
;
}
mContentToScrollTo
=
aContent
;
ScrollIntoViewData
*
data
=
new
ScrollIntoViewData
(
)
;
data
-
>
mContentScrollVAxis
=
aVertical
;
data
-
>
mContentScrollHAxis
=
aHorizontal
;
data
-
>
mContentToScrollToFlags
=
aScrollFlags
;
if
(
NS_FAILED
(
mContentToScrollTo
-
>
SetProperty
(
nsGkAtoms
:
:
scrolling
data
nsINode
:
:
DeleteProperty
<
PresShell
:
:
ScrollIntoViewData
>
)
)
)
{
mContentToScrollTo
=
nullptr
;
}
if
(
PresShell
*
presShell
=
composedDoc
-
>
GetPresShell
(
)
)
{
presShell
-
>
SetNeedLayoutFlush
(
)
;
}
composedDoc
-
>
FlushPendingNotifications
(
FlushType
:
:
InterruptibleLayout
)
;
if
(
mContentToScrollTo
)
{
DoScrollContentIntoView
(
)
;
}
return
NS_OK
;
}
void
PresShell
:
:
DoScrollContentIntoView
(
)
{
NS_ASSERTION
(
mDidInitialize
"
should
have
done
initial
reflow
by
now
"
)
;
nsIFrame
*
frame
=
mContentToScrollTo
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
)
{
mContentToScrollTo
-
>
RemoveProperty
(
nsGkAtoms
:
:
scrolling
)
;
mContentToScrollTo
=
nullptr
;
return
;
}
if
(
frame
-
>
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
)
{
return
;
}
nsIFrame
*
container
=
nsLayoutUtils
:
:
GetClosestFrameOfType
(
frame
-
>
GetParent
(
)
LayoutFrameType
:
:
Scroll
)
;
if
(
!
container
)
{
return
;
}
ScrollIntoViewData
*
data
=
static_cast
<
ScrollIntoViewData
*
>
(
mContentToScrollTo
-
>
GetProperty
(
nsGkAtoms
:
:
scrolling
)
)
;
if
(
MOZ_UNLIKELY
(
!
data
)
)
{
mContentToScrollTo
=
nullptr
;
return
;
}
nsMargin
scrollMargin
;
if
(
!
(
data
-
>
mContentToScrollToFlags
&
ScrollFlags
:
:
IgnoreMarginAndPadding
)
)
{
scrollMargin
=
frame
-
>
StyleMargin
(
)
-
>
GetScrollMargin
(
)
;
}
nsRect
frameBounds
;
bool
haveRect
=
false
;
bool
useWholeLineHeightForInlines
=
data
-
>
mContentScrollVAxis
.
mWhenToScroll
!
=
WhenToScroll
:
:
IfNotFullyVisible
;
nsIFrame
*
prevBlock
=
nullptr
;
nsAutoLineIterator
lines
;
int32_t
curLine
=
0
;
do
{
AccumulateFrameBounds
(
container
frame
useWholeLineHeightForInlines
frameBounds
haveRect
prevBlock
lines
curLine
)
;
}
while
(
(
frame
=
frame
-
>
GetNextContinuation
(
)
)
)
;
frameBounds
.
Inflate
(
scrollMargin
)
;
ScrollFrameRectIntoView
(
container
frameBounds
data
-
>
mContentScrollVAxis
data
-
>
mContentScrollHAxis
data
-
>
mContentToScrollToFlags
)
;
}
bool
PresShell
:
:
ScrollFrameRectIntoView
(
nsIFrame
*
aFrame
const
nsRect
&
aRect
ScrollAxis
aVertical
ScrollAxis
aHorizontal
ScrollFlags
aScrollFlags
)
{
bool
didScroll
=
false
;
nsRect
rect
=
aRect
;
nsIFrame
*
container
=
aFrame
;
do
{
nsIScrollableFrame
*
sf
=
do_QueryFrame
(
container
)
;
if
(
sf
)
{
nsPoint
oldPosition
=
sf
-
>
GetScrollPosition
(
)
;
nsRect
targetRect
=
rect
;
auto
*
disp
=
container
-
>
StyleDisplay
(
)
;
if
(
disp
-
>
mOverflowClipBoxBlock
=
=
StyleOverflowClipBox
:
:
ContentBox
|
|
disp
-
>
mOverflowClipBoxInline
=
=
StyleOverflowClipBox
:
:
ContentBox
)
{
WritingMode
wm
=
container
-
>
GetWritingMode
(
)
;
bool
cbH
=
(
wm
.
IsVertical
(
)
?
disp
-
>
mOverflowClipBoxBlock
:
disp
-
>
mOverflowClipBoxInline
)
=
=
StyleOverflowClipBox
:
:
ContentBox
;
bool
cbV
=
(
wm
.
IsVertical
(
)
?
disp
-
>
mOverflowClipBoxInline
:
disp
-
>
mOverflowClipBoxBlock
)
=
=
StyleOverflowClipBox
:
:
ContentBox
;
nsMargin
padding
=
container
-
>
GetUsedPadding
(
)
;
if
(
!
cbH
)
{
padding
.
left
=
padding
.
right
=
nscoord
(
0
)
;
}
if
(
!
cbV
)
{
padding
.
top
=
padding
.
bottom
=
nscoord
(
0
)
;
}
targetRect
.
Inflate
(
padding
)
;
}
targetRect
-
=
sf
-
>
GetScrolledFrame
(
)
-
>
GetPosition
(
)
;
{
AutoWeakFrame
wf
(
container
)
;
ScrollToShowRect
(
sf
targetRect
aVertical
aHorizontal
aScrollFlags
)
;
if
(
!
wf
.
IsAlive
(
)
)
{
return
didScroll
;
}
}
nsPoint
newPosition
=
sf
-
>
LastScrollDestination
(
)
;
rect
+
=
oldPosition
-
newPosition
;
if
(
oldPosition
!
=
newPosition
)
{
didScroll
=
true
;
}
if
(
aScrollFlags
&
ScrollFlags
:
:
ScrollFirstAncestorOnly
)
{
break
;
}
}
nsIFrame
*
parent
;
if
(
container
-
>
IsTransformed
(
)
)
{
container
-
>
GetTransformMatrix
(
ViewportType
:
:
Layout
RelativeTo
{
nullptr
}
&
parent
)
;
rect
=
nsLayoutUtils
:
:
TransformFrameRectToAncestor
(
container
rect
parent
)
;
}
else
{
rect
+
=
container
-
>
GetPosition
(
)
;
parent
=
container
-
>
GetParent
(
)
;
}
if
(
!
parent
&
&
!
(
aScrollFlags
&
ScrollFlags
:
:
ScrollNoParentFrames
)
)
{
nsPoint
extraOffset
(
0
0
)
;
int32_t
APD
=
container
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
parent
=
nsLayoutUtils
:
:
GetCrossDocParentFrame
(
container
&
extraOffset
)
;
if
(
parent
)
{
int32_t
parentAPD
=
parent
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
rect
=
rect
.
ScaleToOtherAppUnitsRoundOut
(
APD
parentAPD
)
;
rect
+
=
extraOffset
;
}
else
{
nsCOMPtr
<
nsIDocShell
>
docShell
=
container
-
>
PresContext
(
)
-
>
GetDocShell
(
)
;
if
(
BrowserChild
*
browserChild
=
BrowserChild
:
:
GetFrom
(
docShell
)
)
{
Unused
<
<
browserChild
-
>
SendScrollRectIntoView
(
rect
aVertical
aHorizontal
aScrollFlags
APD
)
;
}
}
}
container
=
parent
;
}
while
(
container
)
;
return
didScroll
;
}
void
PresShell
:
:
ScheduleViewManagerFlush
(
PaintType
aType
)
{
if
(
MOZ_UNLIKELY
(
mIsDestroying
)
)
{
return
;
}
if
(
aType
=
=
PaintType
:
:
DelayedCompress
)
{
static
const
uint32_t
kPaintDelayPeriod
=
1000
;
if
(
!
mDelayedPaintTimer
)
{
nsTimerCallbackFunc
PaintTimerCallBack
=
[
]
(
nsITimer
*
aTimer
void
*
aClosure
)
{
auto
self
=
static_cast
<
PresShell
*
>
(
aClosure
)
;
self
-
>
SetNextPaintCompressed
(
)
;
self
-
>
ScheduleViewManagerFlush
(
)
;
}
;
NS_NewTimerWithFuncCallback
(
getter_AddRefs
(
mDelayedPaintTimer
)
PaintTimerCallBack
this
kPaintDelayPeriod
nsITimer
:
:
TYPE_ONE_SHOT
"
PaintTimerCallBack
"
mDocument
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
)
;
}
return
;
}
nsPresContext
*
presContext
=
GetPresContext
(
)
;
if
(
presContext
)
{
presContext
-
>
RefreshDriver
(
)
-
>
ScheduleViewManagerFlush
(
)
;
}
SetNeedLayoutFlush
(
)
;
}
void
PresShell
:
:
DispatchSynthMouseMove
(
WidgetGUIEvent
*
aEvent
)
{
AUTO_PROFILER_TRACING_MARKER_DOCSHELL
(
"
Paint
"
"
DispatchSynthMouseMove
"
GRAPHICS
mPresContext
-
>
GetDocShell
(
)
)
;
nsEventStatus
status
=
nsEventStatus_eIgnore
;
nsView
*
targetView
=
nsView
:
:
GetViewFor
(
aEvent
-
>
mWidget
)
;
if
(
!
targetView
)
return
;
RefPtr
<
nsViewManager
>
viewManager
=
targetView
-
>
GetViewManager
(
)
;
viewManager
-
>
DispatchEvent
(
aEvent
targetView
&
status
)
;
}
void
PresShell
:
:
ClearMouseCaptureOnView
(
nsView
*
aView
)
{
if
(
nsIContent
*
capturingContent
=
GetCapturingContent
(
)
)
{
if
(
aView
)
{
nsIFrame
*
frame
=
capturingContent
-
>
GetPrimaryFrame
(
)
;
if
(
frame
)
{
nsView
*
view
=
frame
-
>
GetClosestView
(
)
;
if
(
view
)
{
do
{
if
(
view
=
=
aView
)
{
ReleaseCapturingContent
(
)
;
AllowMouseCapture
(
false
)
;
break
;
}
view
=
view
-
>
GetParent
(
)
;
}
while
(
view
)
;
return
;
}
}
}
ReleaseCapturingContent
(
)
;
}
AllowMouseCapture
(
false
)
;
}
void
PresShell
:
:
ClearMouseCapture
(
nsIFrame
*
aFrame
)
{
nsIContent
*
capturingContent
=
GetCapturingContent
(
)
;
if
(
!
capturingContent
)
{
AllowMouseCapture
(
false
)
;
return
;
}
if
(
!
aFrame
)
{
ReleaseCapturingContent
(
)
;
AllowMouseCapture
(
false
)
;
return
;
}
nsIFrame
*
capturingFrame
=
capturingContent
-
>
GetPrimaryFrame
(
)
;
if
(
!
capturingFrame
)
{
ReleaseCapturingContent
(
)
;
AllowMouseCapture
(
false
)
;
return
;
}
if
(
nsLayoutUtils
:
:
IsAncestorFrameCrossDoc
(
aFrame
capturingFrame
)
)
{
ReleaseCapturingContent
(
)
;
AllowMouseCapture
(
false
)
;
}
}
nsresult
PresShell
:
:
CaptureHistoryState
(
nsILayoutHistoryState
*
*
aState
)
{
MOZ_ASSERT
(
nullptr
!
=
aState
"
null
state
pointer
"
)
;
nsCOMPtr
<
nsIDocShell
>
docShell
(
mPresContext
-
>
GetDocShell
(
)
)
;
if
(
!
docShell
)
return
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsILayoutHistoryState
>
historyState
;
docShell
-
>
GetLayoutHistoryState
(
getter_AddRefs
(
historyState
)
)
;
if
(
!
historyState
)
{
historyState
=
NS_NewLayoutHistoryState
(
)
;
docShell
-
>
SetLayoutHistoryState
(
historyState
)
;
}
*
aState
=
historyState
;
NS_IF_ADDREF
(
*
aState
)
;
nsIFrame
*
rootFrame
=
mFrameConstructor
-
>
GetRootFrame
(
)
;
if
(
!
rootFrame
)
return
NS_OK
;
mFrameConstructor
-
>
CaptureFrameState
(
rootFrame
historyState
)
;
return
NS_OK
;
}
void
PresShell
:
:
ScheduleBeforeFirstPaint
(
)
{
if
(
!
mDocument
-
>
IsResourceDoc
(
)
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Debug
(
"
PresShell
:
:
ScheduleBeforeFirstPaint
this
=
%
p
"
this
)
)
;
nsContentUtils
:
:
AddScriptRunner
(
new
nsBeforeFirstPaintDispatcher
(
mDocument
)
)
;
}
}
void
PresShell
:
:
UnsuppressAndInvalidate
(
)
{
if
(
(
!
mDocument
-
>
IsResourceDoc
(
)
&
&
!
mPresContext
-
>
EnsureVisible
(
)
)
|
|
mHaveShutDown
)
{
return
;
}
ScheduleBeforeFirstPaint
(
)
;
mPaintingSuppressed
=
false
;
nsIFrame
*
rootFrame
=
mFrameConstructor
-
>
GetRootFrame
(
)
;
if
(
rootFrame
)
{
rootFrame
-
>
InvalidateFrame
(
)
;
}
if
(
nsPIDOMWindowOuter
*
win
=
mDocument
-
>
GetWindow
(
)
)
{
win
-
>
SetReadyForFocus
(
)
;
}
if
(
!
mHaveShutDown
)
{
SynthesizeMouseMove
(
false
)
;
ScheduleApproximateFrameVisibilityUpdateNow
(
)
;
}
}
void
PresShell
:
:
CancelPaintSuppressionTimer
(
)
{
if
(
mPaintSuppressionTimer
)
{
mPaintSuppressionTimer
-
>
Cancel
(
)
;
mPaintSuppressionTimer
=
nullptr
;
}
}
void
PresShell
:
:
UnsuppressPaintingFromTimer
(
)
{
if
(
mIsDocumentGone
|
|
!
mPaintingSuppressed
)
{
CancelPaintSuppressionTimer
(
)
;
return
;
}
if
(
!
StaticPrefs
:
:
nglayout_initialpaint_unsuppress_with_no_background
(
)
)
{
if
(
mPresContext
-
>
IsRootContentDocumentCrossProcess
(
)
)
{
UpdateCanvasBackground
(
)
;
if
(
!
mHasCSSBackgroundColor
)
{
if
(
mPaintSuppressionAttempts
+
+
<
StaticPrefs
:
:
nglayout_initialpaint_retry_max_retry_count
(
)
)
{
InitPaintSuppressionTimer
(
)
;
return
;
}
}
}
}
UnsuppressPainting
(
)
;
}
void
PresShell
:
:
UnsuppressPainting
(
)
{
CancelPaintSuppressionTimer
(
)
;
if
(
mIsDocumentGone
|
|
!
mPaintingSuppressed
)
{
return
;
}
if
(
!
mDirtyRoots
.
IsEmpty
(
)
)
mShouldUnsuppressPainting
=
true
;
else
UnsuppressAndInvalidate
(
)
;
}
nsresult
PresShell
:
:
PostReflowCallback
(
nsIReflowCallback
*
aCallback
)
{
void
*
result
=
AllocateByObjectID
(
eArenaObjectID_nsCallbackEventRequest
sizeof
(
nsCallbackEventRequest
)
)
;
nsCallbackEventRequest
*
request
=
(
nsCallbackEventRequest
*
)
result
;
request
-
>
callback
=
aCallback
;
request
-
>
next
=
nullptr
;
if
(
mLastCallbackEventRequest
)
{
mLastCallbackEventRequest
=
mLastCallbackEventRequest
-
>
next
=
request
;
}
else
{
mFirstCallbackEventRequest
=
request
;
mLastCallbackEventRequest
=
request
;
}
return
NS_OK
;
}
void
PresShell
:
:
CancelReflowCallback
(
nsIReflowCallback
*
aCallback
)
{
nsCallbackEventRequest
*
before
=
nullptr
;
nsCallbackEventRequest
*
node
=
mFirstCallbackEventRequest
;
while
(
node
)
{
nsIReflowCallback
*
callback
=
node
-
>
callback
;
if
(
callback
=
=
aCallback
)
{
nsCallbackEventRequest
*
toFree
=
node
;
if
(
node
=
=
mFirstCallbackEventRequest
)
{
node
=
node
-
>
next
;
mFirstCallbackEventRequest
=
node
;
NS_ASSERTION
(
before
=
=
nullptr
"
impossible
"
)
;
}
else
{
node
=
node
-
>
next
;
before
-
>
next
=
node
;
}
if
(
toFree
=
=
mLastCallbackEventRequest
)
{
mLastCallbackEventRequest
=
before
;
}
FreeByObjectID
(
eArenaObjectID_nsCallbackEventRequest
toFree
)
;
}
else
{
before
=
node
;
node
=
node
-
>
next
;
}
}
}
void
PresShell
:
:
CancelPostedReflowCallbacks
(
)
{
while
(
mFirstCallbackEventRequest
)
{
nsCallbackEventRequest
*
node
=
mFirstCallbackEventRequest
;
mFirstCallbackEventRequest
=
node
-
>
next
;
if
(
!
mFirstCallbackEventRequest
)
{
mLastCallbackEventRequest
=
nullptr
;
}
nsIReflowCallback
*
callback
=
node
-
>
callback
;
FreeByObjectID
(
eArenaObjectID_nsCallbackEventRequest
node
)
;
if
(
callback
)
{
callback
-
>
ReflowCallbackCanceled
(
)
;
}
}
}
void
PresShell
:
:
HandlePostedReflowCallbacks
(
bool
aInterruptible
)
{
bool
shouldFlush
=
false
;
while
(
mFirstCallbackEventRequest
)
{
nsCallbackEventRequest
*
node
=
mFirstCallbackEventRequest
;
mFirstCallbackEventRequest
=
node
-
>
next
;
if
(
!
mFirstCallbackEventRequest
)
{
mLastCallbackEventRequest
=
nullptr
;
}
nsIReflowCallback
*
callback
=
node
-
>
callback
;
FreeByObjectID
(
eArenaObjectID_nsCallbackEventRequest
node
)
;
if
(
callback
)
{
if
(
callback
-
>
ReflowFinished
(
)
)
{
shouldFlush
=
true
;
}
}
}
FlushType
flushType
=
aInterruptible
?
FlushType
:
:
InterruptibleLayout
:
FlushType
:
:
Layout
;
if
(
shouldFlush
&
&
!
mIsDestroying
)
{
FlushPendingNotifications
(
flushType
)
;
}
}
bool
PresShell
:
:
IsSafeToFlush
(
)
const
{
if
(
mIsReflowing
|
|
mChangeNestCount
|
|
mIsDestroying
)
{
return
false
;
}
if
(
nsViewManager
*
viewManager
=
GetViewManager
(
)
)
{
bool
isPainting
=
false
;
viewManager
-
>
IsPainting
(
isPainting
)
;
if
(
isPainting
)
{
return
false
;
}
}
return
true
;
}
void
PresShell
:
:
NotifyFontFaceSetOnRefresh
(
)
{
if
(
FontFaceSet
*
set
=
mDocument
-
>
GetFonts
(
)
)
{
set
-
>
DidRefresh
(
)
;
}
}
void
PresShell
:
:
DoFlushPendingNotifications
(
FlushType
aType
)
{
mozilla
:
:
ChangesToFlush
flush
(
aType
aType
>
=
FlushType
:
:
Style
)
;
FlushPendingNotifications
(
flush
)
;
}
#
ifdef
DEBUG
static
void
AssertFrameSubtreeIsSane
(
const
nsIFrame
&
aRoot
)
{
if
(
const
nsIContent
*
content
=
aRoot
.
GetContent
(
)
)
{
MOZ_ASSERT
(
content
-
>
GetFlattenedTreeParentNodeForStyle
(
)
"
Node
not
in
the
flattened
tree
still
has
a
frame
?
"
)
;
}
for
(
const
auto
&
childList
:
aRoot
.
ChildLists
(
)
)
{
for
(
const
nsIFrame
*
child
:
childList
.
mList
)
{
AssertFrameSubtreeIsSane
(
*
child
)
;
}
}
}
#
endif
static
inline
void
AssertFrameTreeIsSane
(
const
PresShell
&
aPresShell
)
{
#
ifdef
DEBUG
if
(
const
nsIFrame
*
root
=
aPresShell
.
GetRootFrame
(
)
)
{
AssertFrameSubtreeIsSane
(
*
root
)
;
}
#
endif
}
void
PresShell
:
:
DoFlushPendingNotifications
(
mozilla
:
:
ChangesToFlush
aFlush
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mForbiddenToFlush
"
This
is
bad
!
"
)
;
RefPtr
<
PresShell
>
kungFuDeathGrip
=
this
;
FlushType
flushType
=
aFlush
.
mFlushType
;
MOZ_ASSERT
(
NeedFlush
(
flushType
)
"
Why
did
we
get
called
?
"
)
;
AUTO_PROFILER_MARKER_TEXT
(
"
DoFlushPendingNotifications
"
LAYOUT
MarkerOptions
(
MarkerStack
:
:
Capture
(
)
MarkerInnerWindowIdFromDocShell
(
mPresContext
-
>
GetDocShell
(
)
)
)
nsDependentCString
(
kFlushTypeNames
[
flushType
]
)
)
;
AUTO_PROFILER_LABEL_DYNAMIC_CSTR_NONSENSITIVE
(
"
PresShell
:
:
DoFlushPendingNotifications
"
LAYOUT
kFlushTypeNames
[
flushType
]
)
;
#
ifdef
ACCESSIBILITY
#
ifdef
DEBUG
if
(
nsAccessibilityService
*
accService
=
GetAccService
(
)
)
{
NS_ASSERTION
(
!
accService
-
>
IsProcessingRefreshDriverNotification
(
)
"
Flush
during
accessible
tree
update
!
"
)
;
}
#
endif
#
endif
NS_ASSERTION
(
flushType
>
=
FlushType
:
:
Style
"
Why
did
we
get
called
?
"
)
;
mNeedStyleFlush
=
false
;
mNeedThrottledAnimationFlush
=
mNeedThrottledAnimationFlush
&
&
!
aFlush
.
mFlushAnimations
;
mNeedLayoutFlush
=
mNeedLayoutFlush
&
&
(
flushType
<
FlushType
:
:
InterruptibleLayout
)
;
bool
isSafeToFlush
=
IsSafeToFlush
(
)
;
bool
hasHadScriptObject
;
if
(
mDocument
-
>
GetScriptHandlingObject
(
hasHadScriptObject
)
|
|
hasHadScriptObject
)
{
isSafeToFlush
=
isSafeToFlush
&
&
nsContentUtils
:
:
IsSafeToRunScript
(
)
;
}
if
(
MOZ_UNLIKELY
(
mDocument
-
>
GetPresShell
(
)
!
=
this
)
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mDocument
-
>
GetPresShell
(
)
"
Where
did
this
shell
come
from
?
"
)
;
isSafeToFlush
=
false
;
}
MOZ_DIAGNOSTIC_ASSERT
(
!
mIsDestroying
|
|
!
isSafeToFlush
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mIsDestroying
|
|
mViewManager
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mIsDestroying
|
|
mDocument
-
>
HasShellOrBFCacheEntry
(
)
)
;
RefPtr
<
nsViewManager
>
viewManager
=
mViewManager
;
bool
didStyleFlush
=
false
;
bool
didLayoutFlush
=
false
;
if
(
isSafeToFlush
)
{
AutoRestore
<
bool
>
guard
(
mInFlush
)
;
mInFlush
=
true
;
mDocument
-
>
FlushExternalResources
(
flushType
)
;
mDocument
-
>
FlushPendingNotifications
(
FlushType
:
:
ContentAndNotify
)
;
mDocument
-
>
UpdateSVGUseElementShadowTrees
(
)
;
if
(
MOZ_LIKELY
(
!
mIsDestroying
)
)
{
viewManager
-
>
FlushDelayedResize
(
false
)
;
mPresContext
-
>
FlushPendingMediaFeatureValuesChanged
(
)
;
}
if
(
MOZ_LIKELY
(
!
mIsDestroying
)
)
{
StyleSet
(
)
-
>
UpdateStylistIfNeeded
(
)
;
mDocument
-
>
FlushUserFontSet
(
)
;
mPresContext
-
>
FlushCounterStyles
(
)
;
mPresContext
-
>
FlushFontFeatureValues
(
)
;
if
(
mDocument
-
>
HasAnimationController
(
)
)
{
mDocument
-
>
GetAnimationController
(
)
-
>
FlushResampleRequests
(
)
;
}
if
(
aFlush
.
mFlushAnimations
&
&
mPresContext
-
>
EffectCompositor
(
)
)
{
mPresContext
-
>
EffectCompositor
(
)
-
>
PostRestyleForThrottledAnimations
(
)
;
}
}
if
(
MOZ_LIKELY
(
!
mIsDestroying
)
)
{
nsAutoScriptBlocker
scriptBlocker
;
#
ifdef
MOZ_GECKO_PROFILER
Maybe
<
uint64_t
>
innerWindowID
;
if
(
auto
*
window
=
mDocument
-
>
GetInnerWindow
(
)
)
{
innerWindowID
=
Some
(
window
-
>
WindowID
(
)
)
;
}
AutoProfilerStyleMarker
tracingStyleFlush
(
std
:
:
move
(
mStyleCause
)
innerWindowID
)
;
#
endif
PerfStats
:
:
AutoMetricRecording
<
PerfStats
:
:
Metric
:
:
Styling
>
autoRecording
;
LAYOUT_TELEMETRY_RECORD_BASE
(
Restyle
)
;
mPresContext
-
>
RestyleManager
(
)
-
>
ProcessPendingRestyles
(
)
;
}
if
(
MOZ_LIKELY
(
!
mIsDestroying
)
)
{
nsAutoScriptBlocker
scriptBlocker
;
#
ifdef
MOZ_GECKO_PROFILER
Maybe
<
uint64_t
>
innerWindowID
;
if
(
auto
*
window
=
mDocument
-
>
GetInnerWindow
(
)
)
{
innerWindowID
=
Some
(
window
-
>
WindowID
(
)
)
;
}
AutoProfilerStyleMarker
tracingStyleFlush
(
std
:
:
move
(
mStyleCause
)
innerWindowID
)
;
#
endif
PerfStats
:
:
AutoMetricRecording
<
PerfStats
:
:
Metric
:
:
Styling
>
autoRecording
;
LAYOUT_TELEMETRY_RECORD_BASE
(
Restyle
)
;
mPresContext
-
>
RestyleManager
(
)
-
>
ProcessPendingRestyles
(
)
;
mNeedStyleFlush
=
false
;
}
AssertFrameTreeIsSane
(
*
this
)
;
didStyleFlush
=
true
;
if
(
flushType
>
=
(
SuppressInterruptibleReflows
(
)
?
FlushType
:
:
Layout
:
FlushType
:
:
InterruptibleLayout
)
&
&
!
mIsDestroying
)
{
didLayoutFlush
=
true
;
mFrameConstructor
-
>
RecalcQuotesAndCounters
(
)
;
if
(
ProcessReflowCommands
(
flushType
<
FlushType
:
:
Layout
)
)
{
if
(
mContentToScrollTo
)
{
DoScrollContentIntoView
(
)
;
if
(
mContentToScrollTo
)
{
mContentToScrollTo
-
>
RemoveProperty
(
nsGkAtoms
:
:
scrolling
)
;
mContentToScrollTo
=
nullptr
;
}
}
}
}
if
(
flushType
>
=
FlushType
:
:
Layout
)
{
if
(
!
mIsDestroying
)
{
viewManager
-
>
UpdateWidgetGeometry
(
)
;
}
}
}
if
(
!
didStyleFlush
&
&
flushType
>
=
FlushType
:
:
Style
&
&
!
mIsDestroying
)
{
SetNeedStyleFlush
(
)
;
if
(
aFlush
.
mFlushAnimations
)
{
SetNeedThrottledAnimationFlush
(
)
;
}
}
if
(
!
didLayoutFlush
&
&
flushType
>
=
FlushType
:
:
InterruptibleLayout
&
&
!
mIsDestroying
)
{
SetNeedLayoutFlush
(
)
;
}
if
(
didStyleFlush
)
{
mLayoutTelemetry
.
IncReqsPerFlush
(
FlushType
:
:
Style
)
;
}
if
(
didLayoutFlush
)
{
mLayoutTelemetry
.
IncReqsPerFlush
(
FlushType
:
:
Layout
)
;
}
if
(
flushType
>
=
FlushType
:
:
InterruptibleLayout
&
&
didLayoutFlush
)
{
MOZ_ASSERT
(
didLayoutFlush
=
=
didStyleFlush
)
;
mLayoutTelemetry
.
PingReqsPerFlushTelemetry
(
FlushType
:
:
Layout
)
;
}
else
if
(
flushType
>
=
FlushType
:
:
Style
&
&
didStyleFlush
)
{
MOZ_ASSERT
(
!
didLayoutFlush
)
;
mLayoutTelemetry
.
PingReqsPerFlushTelemetry
(
FlushType
:
:
Style
)
;
}
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
PresShell
:
:
CharacterDataChanged
(
nsIContent
*
aContent
const
CharacterDataChangeInfo
&
aInfo
)
{
MOZ_ASSERT
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
;
MOZ_ASSERT
(
!
mIsDocumentGone
"
Unexpected
CharacterDataChanged
"
)
;
MOZ_ASSERT
(
aContent
-
>
OwnerDoc
(
)
=
=
mDocument
"
Unexpected
document
"
)
;
nsAutoCauseReflowNotifier
crNotifier
(
this
)
;
mPresContext
-
>
RestyleManager
(
)
-
>
CharacterDataChanged
(
aContent
aInfo
)
;
mFrameConstructor
-
>
CharacterDataChanged
(
aContent
aInfo
)
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
PresShell
:
:
ContentStateChanged
(
Document
*
aDocument
nsIContent
*
aContent
EventStates
aStateMask
)
{
MOZ_ASSERT
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
;
MOZ_ASSERT
(
!
mIsDocumentGone
"
Unexpected
ContentStateChanged
"
)
;
MOZ_ASSERT
(
aDocument
=
=
mDocument
"
Unexpected
aDocument
"
)
;
if
(
mDidInitialize
)
{
nsAutoCauseReflowNotifier
crNotifier
(
this
)
;
mPresContext
-
>
RestyleManager
(
)
-
>
ContentStateChanged
(
aContent
aStateMask
)
;
}
}
void
PresShell
:
:
DocumentStatesChanged
(
EventStates
aStateMask
)
{
MOZ_ASSERT
(
!
mIsDocumentGone
"
Unexpected
DocumentStatesChanged
"
)
;
MOZ_ASSERT
(
mDocument
)
;
MOZ_ASSERT
(
!
aStateMask
.
IsEmpty
(
)
)
;
if
(
mDidInitialize
)
{
StyleSet
(
)
-
>
InvalidateStyleForDocumentStateChanges
(
aStateMask
)
;
}
if
(
aStateMask
.
HasState
(
NS_DOCUMENT_STATE_WINDOW_INACTIVE
)
)
{
if
(
nsIFrame
*
root
=
mFrameConstructor
-
>
GetRootFrame
(
)
)
{
root
-
>
SchedulePaint
(
)
;
}
}
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
PresShell
:
:
AttributeWillChange
(
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
MOZ_ASSERT
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
;
MOZ_ASSERT
(
!
mIsDocumentGone
"
Unexpected
AttributeWillChange
"
)
;
MOZ_ASSERT
(
aElement
-
>
OwnerDoc
(
)
=
=
mDocument
"
Unexpected
document
"
)
;
if
(
mDidInitialize
)
{
nsAutoCauseReflowNotifier
crNotifier
(
this
)
;
mPresContext
-
>
RestyleManager
(
)
-
>
AttributeWillChange
(
aElement
aNameSpaceID
aAttribute
aModType
)
;
}
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
PresShell
:
:
AttributeChanged
(
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
const
nsAttrValue
*
aOldValue
)
{
MOZ_ASSERT
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
;
MOZ_ASSERT
(
!
mIsDocumentGone
"
Unexpected
AttributeChanged
"
)
;
MOZ_ASSERT
(
aElement
-
>
OwnerDoc
(
)
=
=
mDocument
"
Unexpected
document
"
)
;
if
(
mDidInitialize
)
{
nsAutoCauseReflowNotifier
crNotifier
(
this
)
;
mPresContext
-
>
RestyleManager
(
)
-
>
AttributeChanged
(
aElement
aNameSpaceID
aAttribute
aModType
aOldValue
)
;
}
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
PresShell
:
:
ContentAppended
(
nsIContent
*
aFirstNewContent
)
{
MOZ_ASSERT
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
;
MOZ_ASSERT
(
!
mIsDocumentGone
"
Unexpected
ContentAppended
"
)
;
MOZ_ASSERT
(
aFirstNewContent
-
>
OwnerDoc
(
)
=
=
mDocument
"
Unexpected
document
"
)
;
MOZ_ASSERT
(
aFirstNewContent
-
>
GetParent
(
)
)
;
MOZ_ASSERT
(
aFirstNewContent
-
>
GetParent
(
)
-
>
IsElement
(
)
|
|
aFirstNewContent
-
>
GetParent
(
)
-
>
IsShadowRoot
(
)
)
;
if
(
!
mDidInitialize
)
{
return
;
}
nsAutoCauseReflowNotifier
crNotifier
(
this
)
;
mPresContext
-
>
RestyleManager
(
)
-
>
ContentAppended
(
aFirstNewContent
)
;
mFrameConstructor
-
>
ContentAppended
(
aFirstNewContent
nsCSSFrameConstructor
:
:
InsertionKind
:
:
Async
)
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
PresShell
:
:
ContentInserted
(
nsIContent
*
aChild
)
{
MOZ_ASSERT
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
;
MOZ_ASSERT
(
!
mIsDocumentGone
"
Unexpected
ContentInserted
"
)
;
MOZ_ASSERT
(
aChild
-
>
OwnerDoc
(
)
=
=
mDocument
"
Unexpected
document
"
)
;
if
(
!
mDidInitialize
)
{
return
;
}
nsAutoCauseReflowNotifier
crNotifier
(
this
)
;
mPresContext
-
>
RestyleManager
(
)
-
>
ContentInserted
(
aChild
)
;
mFrameConstructor
-
>
ContentInserted
(
aChild
nsCSSFrameConstructor
:
:
InsertionKind
:
:
Async
)
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
PresShell
:
:
ContentRemoved
(
nsIContent
*
aChild
nsIContent
*
aPreviousSibling
)
{
MOZ_ASSERT
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
;
MOZ_ASSERT
(
!
mIsDocumentGone
"
Unexpected
ContentRemoved
"
)
;
MOZ_ASSERT
(
aChild
-
>
OwnerDoc
(
)
=
=
mDocument
"
Unexpected
document
"
)
;
nsINode
*
container
=
aChild
-
>
GetParentNode
(
)
;
mPresContext
-
>
EventStateManager
(
)
-
>
ContentRemoved
(
mDocument
aChild
)
;
nsAutoCauseReflowNotifier
crNotifier
(
this
)
;
nsIContent
*
oldNextSibling
=
nullptr
;
if
(
MOZ_LIKELY
(
!
aChild
-
>
IsRootOfNativeAnonymousSubtree
(
)
)
)
{
oldNextSibling
=
aPreviousSibling
?
aPreviousSibling
-
>
GetNextSibling
(
)
:
container
-
>
GetFirstChild
(
)
;
}
if
(
mPointerEventTarget
&
&
mPointerEventTarget
-
>
IsInclusiveDescendantOf
(
aChild
)
)
{
mPointerEventTarget
=
aChild
-
>
GetParent
(
)
;
}
mFrameConstructor
-
>
ContentRemoved
(
aChild
oldNextSibling
nsCSSFrameConstructor
:
:
REMOVE_CONTENT
)
;
mPresContext
-
>
RestyleManager
(
)
-
>
ContentRemoved
(
aChild
oldNextSibling
)
;
}
void
PresShell
:
:
NotifyCounterStylesAreDirty
(
)
{
nsAutoCauseReflowNotifier
reflowNotifier
(
this
)
;
mFrameConstructor
-
>
NotifyCounterStylesAreDirty
(
)
;
}
bool
PresShell
:
:
FrameIsAncestorOfDirtyRoot
(
nsIFrame
*
aFrame
)
const
{
return
mDirtyRoots
.
FrameIsAncestorOfDirtyRoot
(
aFrame
)
;
}
void
PresShell
:
:
ReconstructFrames
(
)
{
MOZ_ASSERT
(
!
mFrameConstructor
-
>
GetRootFrame
(
)
|
|
mDidInitialize
"
Must
not
have
root
frame
before
initial
reflow
"
)
;
if
(
!
mDidInitialize
|
|
mIsDestroying
)
{
return
;
}
mDocument
-
>
FlushPendingNotifications
(
FlushType
:
:
Style
)
;
if
(
mIsDestroying
)
{
return
;
}
nsAutoCauseReflowNotifier
crNotifier
(
this
)
;
mFrameConstructor
-
>
ReconstructDocElementHierarchy
(
nsCSSFrameConstructor
:
:
InsertionKind
:
:
Sync
)
;
}
nsresult
PresShell
:
:
RenderDocument
(
const
nsRect
&
aRect
RenderDocumentFlags
aFlags
nscolor
aBackgroundColor
gfxContext
*
aThebesContext
)
{
NS_ENSURE_TRUE
(
!
(
aFlags
&
RenderDocumentFlags
:
:
IsUntrusted
)
NS_ERROR_NOT_IMPLEMENTED
)
;
nsRootPresContext
*
rootPresContext
=
mPresContext
-
>
GetRootPresContext
(
)
;
if
(
rootPresContext
)
{
rootPresContext
-
>
FlushWillPaintObservers
(
)
;
if
(
mIsDestroying
)
return
NS_OK
;
}
nsAutoScriptBlocker
blockScripts
;
gfxRect
r
(
0
0
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
aRect
.
width
)
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
aRect
.
height
)
)
;
aThebesContext
-
>
NewPath
(
)
;
#
ifdef
MOZ_GFX_OPTIMIZE_MOBILE
aThebesContext
-
>
SnappedRectangle
(
r
)
;
#
else
aThebesContext
-
>
Rectangle
(
r
)
;
#
endif
nsIFrame
*
rootFrame
=
mFrameConstructor
-
>
GetRootFrame
(
)
;
if
(
!
rootFrame
)
{
aThebesContext
-
>
SetColor
(
sRGBColor
:
:
FromABGR
(
aBackgroundColor
)
)
;
aThebesContext
-
>
Fill
(
)
;
return
NS_OK
;
}
gfxContextAutoSaveRestore
save
(
aThebesContext
)
;
MOZ_ASSERT
(
aThebesContext
-
>
CurrentOp
(
)
=
=
CompositionOp
:
:
OP_OVER
)
;
aThebesContext
-
>
Clip
(
)
;
nsDeviceContext
*
devCtx
=
mPresContext
-
>
DeviceContext
(
)
;
gfxPoint
offset
(
-
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
aRect
.
x
)
-
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
aRect
.
y
)
)
;
gfxFloat
scale
=
gfxFloat
(
devCtx
-
>
AppUnitsPerDevPixel
(
)
)
/
AppUnitsPerCSSPixel
(
)
;
gfxMatrix
newTM
=
aThebesContext
-
>
CurrentMatrixDouble
(
)
.
PreTranslate
(
offset
)
.
PreScale
(
scale
scale
)
.
NudgeToIntegers
(
)
;
aThebesContext
-
>
SetMatrixDouble
(
newTM
)
;
AutoSaveRestoreRenderingState
_
(
this
)
;
bool
wouldFlushRetainedLayers
=
false
;
PaintFrameFlags
flags
=
PaintFrameFlags
:
:
IgnoreSuppression
;
if
(
aThebesContext
-
>
CurrentMatrix
(
)
.
HasNonIntegerTranslation
(
)
)
{
flags
|
=
PaintFrameFlags
:
:
InTransform
;
}
if
(
!
(
aFlags
&
RenderDocumentFlags
:
:
AsyncDecodeImages
)
)
{
flags
|
=
PaintFrameFlags
:
:
SyncDecodeImages
;
}
if
(
aFlags
&
RenderDocumentFlags
:
:
UseHighQualityScaling
)
{
flags
|
=
PaintFrameFlags
:
:
UseHighQualityScaling
;
}
if
(
aFlags
&
RenderDocumentFlags
:
:
UseWidgetLayers
)
{
nsView
*
view
=
rootFrame
-
>
GetView
(
)
;
if
(
view
&
&
view
-
>
GetWidget
(
)
&
&
nsLayoutUtils
:
:
GetDisplayRootFrame
(
rootFrame
)
=
=
rootFrame
)
{
LayerManager
*
layerManager
=
view
-
>
GetWidget
(
)
-
>
GetLayerManager
(
)
;
if
(
layerManager
&
&
(
!
layerManager
-
>
AsKnowsCompositor
(
)
|
|
XRE_IsParentProcess
(
)
)
)
{
flags
|
=
PaintFrameFlags
:
:
WidgetLayers
;
}
}
}
if
(
!
(
aFlags
&
RenderDocumentFlags
:
:
DrawCaret
)
)
{
wouldFlushRetainedLayers
=
true
;
flags
|
=
PaintFrameFlags
:
:
HideCaret
;
}
if
(
aFlags
&
RenderDocumentFlags
:
:
IgnoreViewportScrolling
)
{
wouldFlushRetainedLayers
=
!
IgnoringViewportScrolling
(
)
;
mRenderingStateFlags
|
=
RenderingStateFlags
:
:
IgnoringViewportScrolling
;
}
if
(
aFlags
&
RenderDocumentFlags
:
:
ResetViewportScrolling
)
{
wouldFlushRetainedLayers
=
true
;
flags
|
=
PaintFrameFlags
:
:
ResetViewportScrolling
;
}
if
(
aFlags
&
RenderDocumentFlags
:
:
DrawWindowNotFlushing
)
{
mRenderingStateFlags
|
=
RenderingStateFlags
:
:
DrawWindowNotFlushing
;
}
if
(
aFlags
&
RenderDocumentFlags
:
:
DocumentRelative
)
{
wouldFlushRetainedLayers
=
true
;
flags
|
=
PaintFrameFlags
:
:
DocumentRelative
;
}
if
(
(
flags
&
PaintFrameFlags
:
:
WidgetLayers
)
&
&
wouldFlushRetainedLayers
)
{
flags
&
=
~
PaintFrameFlags
:
:
WidgetLayers
;
}
nsLayoutUtils
:
:
PaintFrame
(
aThebesContext
rootFrame
nsRegion
(
aRect
)
aBackgroundColor
nsDisplayListBuilderMode
:
:
Painting
flags
)
;
return
NS_OK
;
}
nsRect
PresShell
:
:
ClipListToRange
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
nsRange
*
aRange
)
{
nsRect
surfaceRect
;
nsDisplayList
tmpList
;
nsDisplayItem
*
i
;
while
(
(
i
=
aList
-
>
RemoveBottom
(
)
)
)
{
if
(
i
-
>
GetType
(
)
=
=
DisplayItemType
:
:
TYPE_CONTAINER
)
{
tmpList
.
AppendToTop
(
i
)
;
surfaceRect
.
UnionRect
(
surfaceRect
ClipListToRange
(
aBuilder
i
-
>
GetChildren
(
)
aRange
)
)
;
continue
;
}
nsDisplayItem
*
itemToInsert
=
nullptr
;
nsIFrame
*
frame
=
i
-
>
Frame
(
)
;
nsIContent
*
content
=
frame
-
>
GetContent
(
)
;
if
(
content
)
{
bool
atStart
=
(
content
=
=
aRange
-
>
GetStartContainer
(
)
)
;
bool
atEnd
=
(
content
=
=
aRange
-
>
GetEndContainer
(
)
)
;
if
(
(
atStart
|
|
atEnd
)
&
&
frame
-
>
IsTextFrame
(
)
)
{
int32_t
frameStartOffset
frameEndOffset
;
frame
-
>
GetOffsets
(
frameStartOffset
frameEndOffset
)
;
int32_t
hilightStart
=
atStart
?
std
:
:
max
(
static_cast
<
int32_t
>
(
aRange
-
>
StartOffset
(
)
)
frameStartOffset
)
:
frameStartOffset
;
int32_t
hilightEnd
=
atEnd
?
std
:
:
min
(
static_cast
<
int32_t
>
(
aRange
-
>
EndOffset
(
)
)
frameEndOffset
)
:
frameEndOffset
;
if
(
hilightStart
<
hilightEnd
)
{
nsPoint
startPoint
endPoint
;
frame
-
>
GetPointFromOffset
(
hilightStart
&
startPoint
)
;
frame
-
>
GetPointFromOffset
(
hilightEnd
&
endPoint
)
;
nsRect
textRect
(
aBuilder
-
>
ToReferenceFrame
(
frame
)
frame
-
>
GetSize
(
)
)
;
if
(
frame
-
>
GetWritingMode
(
)
.
IsVertical
(
)
)
{
nscoord
y
=
std
:
:
min
(
startPoint
.
y
endPoint
.
y
)
;
textRect
.
y
+
=
y
;
textRect
.
height
=
std
:
:
max
(
startPoint
.
y
endPoint
.
y
)
-
y
;
}
else
{
nscoord
x
=
std
:
:
min
(
startPoint
.
x
endPoint
.
x
)
;
textRect
.
x
+
=
x
;
textRect
.
width
=
std
:
:
max
(
startPoint
.
x
endPoint
.
x
)
-
x
;
}
surfaceRect
.
UnionRect
(
surfaceRect
textRect
)
;
const
ActiveScrolledRoot
*
asr
=
i
-
>
GetActiveScrolledRoot
(
)
;
DisplayItemClip
newClip
;
newClip
.
SetTo
(
textRect
)
;
const
DisplayItemClipChain
*
newClipChain
=
aBuilder
-
>
AllocateDisplayItemClipChain
(
newClip
asr
nullptr
)
;
i
-
>
IntersectClip
(
aBuilder
newClipChain
true
)
;
itemToInsert
=
i
;
}
}
else
if
(
content
-
>
GetUncomposedDoc
(
)
=
=
aRange
-
>
GetStartContainer
(
)
-
>
GetUncomposedDoc
(
)
)
{
bool
before
after
;
nsresult
rv
=
RangeUtils
:
:
CompareNodeToRange
(
content
aRange
&
before
&
after
)
;
if
(
NS_SUCCEEDED
(
rv
)
&
&
!
before
&
&
!
after
)
{
itemToInsert
=
i
;
bool
snap
;
surfaceRect
.
UnionRect
(
surfaceRect
i
-
>
GetBounds
(
aBuilder
&
snap
)
)
;
}
}
}
nsDisplayList
*
sublist
=
i
-
>
GetSameCoordinateSystemChildren
(
)
;
if
(
itemToInsert
|
|
sublist
)
{
tmpList
.
AppendToTop
(
itemToInsert
?
itemToInsert
:
i
)
;
if
(
sublist
)
surfaceRect
.
UnionRect
(
surfaceRect
ClipListToRange
(
aBuilder
sublist
aRange
)
)
;
}
else
{
i
-
>
Destroy
(
aBuilder
)
;
}
}
aList
-
>
AppendToTop
(
&
tmpList
)
;
return
surfaceRect
;
}
#
ifdef
DEBUG
#
include
<
stdio
.
h
>
static
bool
gDumpRangePaintList
=
false
;
#
endif
UniquePtr
<
RangePaintInfo
>
PresShell
:
:
CreateRangePaintInfo
(
nsRange
*
aRange
nsRect
&
aSurfaceRect
bool
aForPrimarySelection
)
{
nsIFrame
*
ancestorFrame
=
nullptr
;
nsIFrame
*
rootFrame
=
GetRootFrame
(
)
;
nsINode
*
startContainer
=
aRange
-
>
GetStartContainer
(
)
;
nsINode
*
endContainer
=
aRange
-
>
GetEndContainer
(
)
;
Document
*
doc
=
startContainer
-
>
GetComposedDoc
(
)
;
if
(
startContainer
=
=
doc
|
|
endContainer
=
=
doc
)
{
ancestorFrame
=
rootFrame
;
}
else
{
nsINode
*
ancestor
=
nsContentUtils
:
:
GetClosestCommonInclusiveAncestor
(
startContainer
endContainer
)
;
NS_ASSERTION
(
!
ancestor
|
|
ancestor
-
>
IsContent
(
)
"
common
ancestor
is
not
content
"
)
;
while
(
ancestor
&
&
ancestor
-
>
IsContent
(
)
)
{
ancestorFrame
=
ancestor
-
>
AsContent
(
)
-
>
GetPrimaryFrame
(
)
;
if
(
ancestorFrame
)
{
break
;
}
ancestor
=
ancestor
-
>
GetParentOrShadowHostNode
(
)
;
}
while
(
ancestorFrame
&
&
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
ancestorFrame
)
)
ancestorFrame
=
ancestorFrame
-
>
GetParent
(
)
;
}
if
(
!
ancestorFrame
)
{
return
nullptr
;
}
auto
info
=
MakeUnique
<
RangePaintInfo
>
(
aRange
ancestorFrame
)
;
info
-
>
mBuilder
.
SetIncludeAllOutOfFlows
(
)
;
if
(
aForPrimarySelection
)
{
info
-
>
mBuilder
.
SetSelectedFramesOnly
(
)
;
}
info
-
>
mBuilder
.
EnterPresShell
(
ancestorFrame
)
;
ContentSubtreeIterator
subtreeIter
;
nsresult
rv
=
subtreeIter
.
Init
(
aRange
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
nullptr
;
}
auto
BuildDisplayListForNode
=
[
&
]
(
nsINode
*
aNode
)
{
if
(
MOZ_UNLIKELY
(
!
aNode
-
>
IsContent
(
)
)
)
{
return
;
}
nsIFrame
*
frame
=
aNode
-
>
AsContent
(
)
-
>
GetPrimaryFrame
(
)
;
for
(
;
frame
;
frame
=
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
frame
)
)
{
info
-
>
mBuilder
.
SetVisibleRect
(
frame
-
>
InkOverflowRect
(
)
)
;
info
-
>
mBuilder
.
SetDirtyRect
(
frame
-
>
InkOverflowRect
(
)
)
;
frame
-
>
BuildDisplayListForStackingContext
(
&
info
-
>
mBuilder
&
info
-
>
mList
)
;
}
}
;
if
(
startContainer
-
>
NodeType
(
)
=
=
nsINode
:
:
TEXT_NODE
)
{
BuildDisplayListForNode
(
startContainer
)
;
}
for
(
;
!
subtreeIter
.
IsDone
(
)
;
subtreeIter
.
Next
(
)
)
{
nsCOMPtr
<
nsINode
>
node
=
subtreeIter
.
GetCurrentNode
(
)
;
BuildDisplayListForNode
(
node
)
;
}
if
(
endContainer
!
=
startContainer
&
&
endContainer
-
>
NodeType
(
)
=
=
nsINode
:
:
TEXT_NODE
)
{
BuildDisplayListForNode
(
endContainer
)
;
}
for
(
nsPresContext
*
ctx
=
GetPresContext
(
)
;
ctx
;
ctx
=
ctx
-
>
GetParentPresContext
(
)
)
{
PresShell
*
shell
=
ctx
-
>
PresShell
(
)
;
float
resolution
=
shell
-
>
GetResolution
(
)
;
if
(
resolution
=
=
1
.
0
)
{
continue
;
}
info
-
>
mResolution
*
=
resolution
;
nsIFrame
*
rootScrollFrame
=
shell
-
>
GetRootScrollFrame
(
)
;
ViewID
zoomedId
=
nsLayoutUtils
:
:
FindOrCreateIDFor
(
rootScrollFrame
-
>
GetContent
(
)
)
;
nsDisplayList
wrapped
;
wrapped
.
AppendNewToTop
<
nsDisplayAsyncZoom
>
(
&
info
-
>
mBuilder
rootScrollFrame
&
info
-
>
mList
nullptr
zoomedId
)
;
info
-
>
mList
.
AppendToTop
(
&
wrapped
)
;
}
#
ifdef
DEBUG
if
(
gDumpRangePaintList
)
{
fprintf
(
stderr
"
CreateRangePaintInfo
-
-
-
before
ClipListToRange
:
\
n
"
)
;
nsIFrame
:
:
PrintDisplayList
(
&
(
info
-
>
mBuilder
)
info
-
>
mList
)
;
}
#
endif
nsRect
rangeRect
=
ClipListToRange
(
&
info
-
>
mBuilder
&
info
-
>
mList
aRange
)
;
info
-
>
mBuilder
.
LeavePresShell
(
ancestorFrame
&
info
-
>
mList
)
;
#
ifdef
DEBUG
if
(
gDumpRangePaintList
)
{
fprintf
(
stderr
"
CreateRangePaintInfo
-
-
-
after
ClipListToRange
:
\
n
"
)
;
nsIFrame
:
:
PrintDisplayList
(
&
(
info
-
>
mBuilder
)
info
-
>
mList
)
;
}
#
endif
info
-
>
mRootOffset
=
ancestorFrame
-
>
GetBoundingClientRect
(
)
.
TopLeft
(
)
;
rangeRect
.
MoveBy
(
info
-
>
mRootOffset
)
;
aSurfaceRect
.
UnionRect
(
aSurfaceRect
rangeRect
)
;
return
info
;
}
already_AddRefed
<
SourceSurface
>
PresShell
:
:
PaintRangePaintInfo
(
const
nsTArray
<
UniquePtr
<
RangePaintInfo
>
>
&
aItems
Selection
*
aSelection
const
Maybe
<
CSSIntRegion
>
&
aRegion
nsRect
aArea
const
LayoutDeviceIntPoint
aPoint
LayoutDeviceIntRect
*
aScreenRect
RenderImageFlags
aFlags
)
{
nsPresContext
*
pc
=
GetPresContext
(
)
;
if
(
!
pc
|
|
aArea
.
width
=
=
0
|
|
aArea
.
height
=
=
0
)
return
nullptr
;
LayoutDeviceIntRect
pixelArea
=
LayoutDeviceIntRect
:
:
FromAppUnitsToOutside
(
aArea
pc
-
>
AppUnitsPerDevPixel
(
)
)
;
float
scale
=
1
.
0
;
nsRect
maxSize
;
pc
-
>
DeviceContext
(
)
-
>
GetClientRect
(
maxSize
)
;
bool
resize
=
!
!
(
aFlags
&
RenderImageFlags
:
:
AutoScale
)
;
if
(
resize
)
{
if
(
aFlags
&
RenderImageFlags
:
:
IsImage
)
{
int32_t
maxWidth
=
pc
-
>
AppUnitsToDevPixels
(
maxSize
.
width
)
;
int32_t
maxHeight
=
pc
-
>
AppUnitsToDevPixels
(
maxSize
.
height
)
;
float
bestHeight
=
float
(
maxHeight
)
*
RELATIVE_SCALEFACTOR
;
float
bestWidth
=
float
(
maxWidth
)
*
RELATIVE_SCALEFACTOR
;
float
adjustedScale
=
bestWidth
/
float
(
pixelArea
.
width
)
;
float
worstHeight
=
float
(
pixelArea
.
height
)
*
adjustedScale
;
float
difference
=
bestHeight
-
worstHeight
;
adjustedScale
=
(
worstHeight
+
difference
/
2
)
/
float
(
pixelArea
.
height
)
;
scale
=
std
:
:
min
(
scale
adjustedScale
)
;
}
else
{
int32_t
maxWidth
=
pc
-
>
AppUnitsToDevPixels
(
maxSize
.
width
>
>
1
)
;
int32_t
maxHeight
=
pc
-
>
AppUnitsToDevPixels
(
maxSize
.
height
>
>
1
)
;
if
(
pixelArea
.
width
>
maxWidth
|
|
pixelArea
.
height
>
maxHeight
)
{
if
(
pixelArea
.
width
>
maxWidth
)
scale
=
std
:
:
min
(
scale
float
(
maxWidth
)
/
pixelArea
.
width
)
;
if
(
pixelArea
.
height
>
maxHeight
)
scale
=
std
:
:
min
(
scale
float
(
maxHeight
)
/
pixelArea
.
height
)
;
}
}
float
resolutionScale
=
1
.
0
;
for
(
const
UniquePtr
<
RangePaintInfo
>
&
rangeInfo
:
aItems
)
{
resolutionScale
=
std
:
:
max
(
resolutionScale
rangeInfo
-
>
mResolution
)
;
}
float
unclampedResolution
=
resolutionScale
;
resolutionScale
=
std
:
:
min
(
resolutionScale
maxSize
.
width
/
(
scale
*
pixelArea
.
width
)
)
;
resolutionScale
=
std
:
:
min
(
resolutionScale
maxSize
.
height
/
(
scale
*
pixelArea
.
height
)
)
;
MOZ_ASSERT
(
resolutionScale
>
=
1
.
0
)
;
resolutionScale
=
std
:
:
max
(
1
.
0f
resolutionScale
)
;
scale
*
=
resolutionScale
;
LayoutDevicePoint
visualPoint
=
ViewportUtils
:
:
ToScreenRelativeVisual
(
LayoutDevicePoint
(
pixelArea
.
TopLeft
(
)
)
pc
)
;
float
scaleRelativeToNormalContent
=
scale
/
unclampedResolution
;
aScreenRect
-
>
x
=
NSToIntFloor
(
aPoint
.
x
-
float
(
aPoint
.
x
-
visualPoint
.
x
)
*
scaleRelativeToNormalContent
)
;
aScreenRect
-
>
y
=
NSToIntFloor
(
aPoint
.
y
-
float
(
aPoint
.
y
-
visualPoint
.
y
)
*
scaleRelativeToNormalContent
)
;
pixelArea
.
width
=
NSToIntFloor
(
float
(
pixelArea
.
width
)
*
scale
)
;
pixelArea
.
height
=
NSToIntFloor
(
float
(
pixelArea
.
height
)
*
scale
)
;
if
(
!
pixelArea
.
width
|
|
!
pixelArea
.
height
)
{
return
nullptr
;
}
}
else
{
LayoutDevicePoint
visualPoint
=
ViewportUtils
:
:
ToScreenRelativeVisual
(
LayoutDevicePoint
(
pixelArea
.
TopLeft
(
)
)
pc
)
;
aScreenRect
-
>
MoveTo
(
RoundedToInt
(
visualPoint
)
)
;
}
aScreenRect
-
>
width
=
pixelArea
.
width
;
aScreenRect
-
>
height
=
pixelArea
.
height
;
RefPtr
<
DrawTarget
>
dt
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
CreateOffscreenContentDrawTarget
(
IntSize
(
pixelArea
.
width
pixelArea
.
height
)
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
!
dt
|
|
!
dt
-
>
IsValid
(
)
)
{
return
nullptr
;
}
RefPtr
<
gfxContext
>
ctx
=
gfxContext
:
:
CreateOrNull
(
dt
)
;
MOZ_ASSERT
(
ctx
)
;
if
(
aRegion
)
{
RefPtr
<
PathBuilder
>
builder
=
dt
-
>
CreatePathBuilder
(
FillRule
:
:
FILL_WINDING
)
;
nsIntRegion
region
=
aRegion
-
>
ToAppUnits
(
AppUnitsPerCSSPixel
(
)
)
.
ToOutsidePixels
(
pc
-
>
AppUnitsPerDevPixel
(
)
)
;
for
(
auto
iter
=
region
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
IntRect
&
rect
=
iter
.
Get
(
)
;
builder
-
>
MoveTo
(
rect
.
TopLeft
(
)
)
;
builder
-
>
LineTo
(
rect
.
TopRight
(
)
)
;
builder
-
>
LineTo
(
rect
.
BottomRight
(
)
)
;
builder
-
>
LineTo
(
rect
.
BottomLeft
(
)
)
;
builder
-
>
LineTo
(
rect
.
TopLeft
(
)
)
;
}
RefPtr
<
Path
>
path
=
builder
-
>
Finish
(
)
;
ctx
-
>
Clip
(
path
)
;
}
gfxMatrix
initialTM
=
ctx
-
>
CurrentMatrixDouble
(
)
;
if
(
resize
)
{
initialTM
.
PreScale
(
scale
scale
)
;
}
gfxPoint
surfaceOffset
=
nsLayoutUtils
:
:
PointToGfxPoint
(
-
aArea
.
TopLeft
(
)
pc
-
>
AppUnitsPerDevPixel
(
)
)
;
initialTM
.
PreTranslate
(
surfaceOffset
)
;
RefPtr
<
nsFrameSelection
>
frameSelection
;
if
(
aSelection
)
{
frameSelection
=
aSelection
-
>
GetFrameSelection
(
)
;
}
else
{
frameSelection
=
FrameSelection
(
)
;
}
int16_t
oldDisplaySelection
=
frameSelection
-
>
GetDisplaySelection
(
)
;
frameSelection
-
>
SetDisplaySelection
(
nsISelectionController
:
:
SELECTION_HIDDEN
)
;
for
(
const
UniquePtr
<
RangePaintInfo
>
&
rangeInfo
:
aItems
)
{
gfxPoint
rootOffset
=
nsLayoutUtils
:
:
PointToGfxPoint
(
rangeInfo
-
>
mRootOffset
pc
-
>
AppUnitsPerDevPixel
(
)
)
;
ctx
-
>
SetMatrixDouble
(
initialTM
.
PreTranslate
(
rootOffset
)
)
;
aArea
.
MoveBy
(
-
rangeInfo
-
>
mRootOffset
.
x
-
rangeInfo
-
>
mRootOffset
.
y
)
;
nsRegion
visible
(
aArea
)
;
RefPtr
<
LayerManager
>
layerManager
=
rangeInfo
-
>
mList
.
PaintRoot
(
&
rangeInfo
-
>
mBuilder
ctx
nsDisplayList
:
:
PAINT_DEFAULT
Nothing
(
)
)
;
aArea
.
MoveBy
(
rangeInfo
-
>
mRootOffset
.
x
rangeInfo
-
>
mRootOffset
.
y
)
;
}
frameSelection
-
>
SetDisplaySelection
(
oldDisplaySelection
)
;
return
dt
-
>
Snapshot
(
)
;
}
already_AddRefed
<
SourceSurface
>
PresShell
:
:
RenderNode
(
nsINode
*
aNode
const
Maybe
<
CSSIntRegion
>
&
aRegion
const
LayoutDeviceIntPoint
aPoint
LayoutDeviceIntRect
*
aScreenRect
RenderImageFlags
aFlags
)
{
nsRect
area
;
nsTArray
<
UniquePtr
<
RangePaintInfo
>
>
rangeItems
;
if
(
!
aNode
-
>
IsInComposedDoc
(
)
)
{
return
nullptr
;
}
RefPtr
<
nsRange
>
range
=
nsRange
:
:
Create
(
aNode
)
;
IgnoredErrorResult
rv
;
range
-
>
SelectNode
(
*
aNode
rv
)
;
if
(
rv
.
Failed
(
)
)
{
return
nullptr
;
}
UniquePtr
<
RangePaintInfo
>
info
=
CreateRangePaintInfo
(
range
area
false
)
;
if
(
info
)
{
rangeItems
.
AppendElement
(
std
:
:
move
(
info
)
)
;
}
Maybe
<
CSSIntRegion
>
region
=
aRegion
;
if
(
region
)
{
CSSIntRect
rrectPixels
=
region
-
>
GetBounds
(
)
;
nsRect
rrect
=
ToAppUnits
(
rrectPixels
AppUnitsPerCSSPixel
(
)
)
;
area
.
IntersectRect
(
area
rrect
)
;
nsPresContext
*
pc
=
GetPresContext
(
)
;
if
(
!
pc
)
return
nullptr
;
region
-
>
MoveBy
(
-
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
area
.
x
)
-
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
area
.
y
)
)
;
}
return
PaintRangePaintInfo
(
rangeItems
nullptr
region
area
aPoint
aScreenRect
aFlags
)
;
}
already_AddRefed
<
SourceSurface
>
PresShell
:
:
RenderSelection
(
Selection
*
aSelection
const
LayoutDeviceIntPoint
aPoint
LayoutDeviceIntRect
*
aScreenRect
RenderImageFlags
aFlags
)
{
nsRect
area
;
nsTArray
<
UniquePtr
<
RangePaintInfo
>
>
rangeItems
;
uint32_t
numRanges
=
aSelection
-
>
RangeCount
(
)
;
NS_ASSERTION
(
numRanges
>
0
"
RenderSelection
called
with
no
selection
"
)
;
for
(
uint32_t
r
=
0
;
r
<
numRanges
;
r
+
+
)
{
RefPtr
<
nsRange
>
range
=
aSelection
-
>
GetRangeAt
(
r
)
;
UniquePtr
<
RangePaintInfo
>
info
=
CreateRangePaintInfo
(
range
area
true
)
;
if
(
info
)
{
rangeItems
.
AppendElement
(
std
:
:
move
(
info
)
)
;
}
}
return
PaintRangePaintInfo
(
rangeItems
aSelection
Nothing
(
)
area
aPoint
aScreenRect
aFlags
)
;
}
void
PresShell
:
:
AddPrintPreviewBackgroundItem
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
nsIFrame
*
aFrame
const
nsRect
&
aBounds
)
{
aList
-
>
AppendNewToBottom
<
nsDisplaySolidColor
>
(
aBuilder
aFrame
aBounds
NS_RGB
(
115
115
115
)
)
;
}
static
bool
AddCanvasBackgroundColor
(
const
nsDisplayList
*
aList
nsIFrame
*
aCanvasFrame
nscolor
aColor
bool
aCSSBackgroundColor
)
{
for
(
nsDisplayItem
*
i
=
aList
-
>
GetBottom
(
)
;
i
;
i
=
i
-
>
GetAbove
(
)
)
{
const
DisplayItemType
type
=
i
-
>
GetType
(
)
;
if
(
i
-
>
Frame
(
)
=
=
aCanvasFrame
&
&
type
=
=
DisplayItemType
:
:
TYPE_CANVAS_BACKGROUND_COLOR
)
{
auto
*
bg
=
static_cast
<
nsDisplayCanvasBackgroundColor
*
>
(
i
)
;
bg
-
>
SetExtraBackgroundColor
(
aColor
)
;
return
true
;
}
const
bool
isBlendContainer
=
type
=
=
DisplayItemType
:
:
TYPE_BLEND_CONTAINER
|
|
type
=
=
DisplayItemType
:
:
TYPE_TABLE_BLEND_CONTAINER
;
nsDisplayList
*
sublist
=
i
-
>
GetSameCoordinateSystemChildren
(
)
;
if
(
sublist
&
&
!
(
isBlendContainer
&
&
!
aCSSBackgroundColor
)
&
&
AddCanvasBackgroundColor
(
sublist
aCanvasFrame
aColor
aCSSBackgroundColor
)
)
return
true
;
}
return
false
;
}
void
PresShell
:
:
AddCanvasBackgroundColorItem
(
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
nsIFrame
*
aFrame
const
nsRect
&
aBounds
nscolor
aBackstopColor
AddCanvasBackgroundColorFlags
aFlags
)
{
if
(
aBounds
.
IsEmpty
(
)
)
{
return
;
}
if
(
!
(
aFlags
&
AddCanvasBackgroundColorFlags
:
:
ForceDraw
)
&
&
!
nsCSSRendering
:
:
IsCanvasFrame
(
aFrame
)
)
{
return
;
}
nscolor
bgcolor
=
NS_ComposeColors
(
aBackstopColor
mCanvasBackgroundColor
)
;
if
(
NS_GET_A
(
bgcolor
)
=
=
0
)
return
;
bool
addedScrollingBackgroundColor
=
!
!
(
aFlags
&
AddCanvasBackgroundColorFlags
:
:
AppendUnscrolledOnly
)
;
if
(
!
aFrame
-
>
GetParent
(
)
&
&
!
addedScrollingBackgroundColor
)
{
nsIScrollableFrame
*
sf
=
aFrame
-
>
PresShell
(
)
-
>
GetRootScrollFrameAsScrollable
(
)
;
if
(
sf
)
{
nsCanvasFrame
*
canvasFrame
=
do_QueryFrame
(
sf
-
>
GetScrolledFrame
(
)
)
;
if
(
canvasFrame
&
&
canvasFrame
-
>
IsVisibleForPainting
(
)
)
{
addedScrollingBackgroundColor
=
AddCanvasBackgroundColor
(
aList
canvasFrame
bgcolor
mHasCSSBackgroundColor
)
;
}
}
}
bool
forceUnscrolledItem
=
nsLayoutUtils
:
:
UsesAsyncScrolling
(
aFrame
)
&
&
NS_GET_A
(
bgcolor
)
=
=
255
;
if
(
!
addedScrollingBackgroundColor
|
|
forceUnscrolledItem
)
{
aList
-
>
AppendNewToBottom
<
nsDisplaySolidColor
>
(
aBuilder
aFrame
aBounds
bgcolor
)
;
}
}
static
bool
IsTransparentContainerElement
(
nsPresContext
*
aPresContext
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
=
aPresContext
-
>
GetDocShell
(
)
;
if
(
!
docShell
)
{
return
false
;
}
nsCOMPtr
<
nsPIDOMWindowOuter
>
pwin
=
docShell
-
>
GetWindow
(
)
;
if
(
!
pwin
)
return
false
;
nsCOMPtr
<
Element
>
containerElement
=
pwin
-
>
GetFrameElementInternal
(
)
;
BrowserChild
*
tab
=
BrowserChild
:
:
GetFrom
(
docShell
)
;
if
(
tab
)
{
if
(
aPresContext
-
>
GetPresShell
(
)
!
=
tab
-
>
GetTopLevelPresShell
(
)
)
{
tab
=
nullptr
;
}
}
return
(
containerElement
&
&
containerElement
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
transparent
)
)
|
|
(
tab
&
&
tab
-
>
IsTransparent
(
)
)
;
}
nscolor
PresShell
:
:
GetDefaultBackgroundColorToDraw
(
)
{
if
(
!
mPresContext
|
|
!
mPresContext
-
>
GetBackgroundColorDraw
(
)
)
{
return
NS_RGB
(
255
255
255
)
;
}
nscolor
backgroundColor
=
mPresContext
-
>
DefaultBackgroundColor
(
)
;
if
(
backgroundColor
!
=
NS_RGB
(
255
255
255
)
)
{
return
backgroundColor
;
}
Document
*
doc
=
GetDocument
(
)
;
BrowsingContext
*
bc
=
doc
-
>
GetBrowsingContext
(
)
;
if
(
bc
&
&
bc
-
>
IsTop
(
)
&
&
!
bc
-
>
HasOpener
(
)
&
&
doc
-
>
GetDocumentURI
(
)
&
&
NS_IsAboutBlank
(
doc
-
>
GetDocumentURI
(
)
)
&
&
doc
-
>
PrefersColorScheme
(
Document
:
:
IgnoreRFP
:
:
Yes
)
=
=
StylePrefersColorScheme
:
:
Dark
)
{
return
NS_RGB
(
0x2A
0x2A
0x2E
)
;
}
return
backgroundColor
;
}
void
PresShell
:
:
UpdateCanvasBackground
(
)
{
nsIFrame
*
rootStyleFrame
=
FrameConstructor
(
)
-
>
GetRootElementStyleFrame
(
)
;
if
(
rootStyleFrame
)
{
ComputedStyle
*
bgStyle
=
nsCSSRendering
:
:
FindRootFrameBackground
(
rootStyleFrame
)
;
bool
drawBackgroundImage
=
false
;
bool
drawBackgroundColor
=
false
;
const
nsStyleDisplay
*
disp
=
rootStyleFrame
-
>
StyleDisplay
(
)
;
StyleAppearance
appearance
=
disp
-
>
EffectiveAppearance
(
)
;
if
(
rootStyleFrame
-
>
IsThemed
(
disp
)
&
&
appearance
!
=
StyleAppearance
:
:
MozWinGlass
&
&
appearance
!
=
StyleAppearance
:
:
MozWinBorderlessGlass
)
{
mCanvasBackgroundColor
=
NS_RGBA
(
0
0
0
0
)
;
}
else
{
mCanvasBackgroundColor
=
nsCSSRendering
:
:
DetermineBackgroundColor
(
mPresContext
bgStyle
rootStyleFrame
drawBackgroundImage
drawBackgroundColor
)
;
}
mHasCSSBackgroundColor
=
drawBackgroundColor
;
if
(
mPresContext
-
>
IsRootContentDocumentCrossProcess
(
)
&
&
!
IsTransparentContainerElement
(
mPresContext
)
)
{
mCanvasBackgroundColor
=
NS_ComposeColors
(
GetDefaultBackgroundColorToDraw
(
)
mCanvasBackgroundColor
)
;
}
}
if
(
!
FrameConstructor
(
)
-
>
GetRootElementFrame
(
)
)
{
mCanvasBackgroundColor
=
GetDefaultBackgroundColorToDraw
(
)
;
}
}
nscolor
PresShell
:
:
ComputeBackstopColor
(
nsView
*
aDisplayRoot
)
{
nsIWidget
*
widget
=
aDisplayRoot
-
>
GetWidget
(
)
;
if
(
widget
&
&
(
widget
-
>
GetTransparencyMode
(
)
!
=
eTransparencyOpaque
|
|
widget
-
>
WidgetPaintsBackground
(
)
)
)
{
return
NS_RGBA
(
0
0
0
0
)
;
}
return
GetDefaultBackgroundColorToDraw
(
)
;
}
struct
PaintParams
{
nscolor
mBackgroundColor
;
}
;
LayerManager
*
PresShell
:
:
GetLayerManager
(
)
{
NS_ASSERTION
(
mViewManager
"
Should
have
view
manager
"
)
;
nsView
*
rootView
=
mViewManager
-
>
GetRootView
(
)
;
if
(
rootView
)
{
if
(
nsIWidget
*
widget
=
rootView
-
>
GetWidget
(
)
)
{
return
widget
-
>
GetLayerManager
(
)
;
}
}
return
nullptr
;
}
bool
PresShell
:
:
AsyncPanZoomEnabled
(
)
{
NS_ASSERTION
(
mViewManager
"
Should
have
view
manager
"
)
;
nsView
*
rootView
=
mViewManager
-
>
GetRootView
(
)
;
if
(
rootView
)
{
if
(
nsIWidget
*
widget
=
rootView
-
>
GetWidget
(
)
)
{
return
widget
-
>
AsyncPanZoomEnabled
(
)
;
}
}
return
gfxPlatform
:
:
AsyncPanZoomEnabled
(
)
;
}
nsresult
PresShell
:
:
SetResolutionAndScaleTo
(
float
aResolution
ResolutionChangeOrigin
aOrigin
)
{
if
(
!
(
aResolution
>
0
.
0
)
)
{
return
NS_ERROR_ILLEGAL_VALUE
;
}
if
(
aResolution
=
=
mResolution
.
valueOr
(
0
.
0
)
)
{
MOZ_ASSERT
(
mResolution
.
isSome
(
)
)
;
return
NS_OK
;
}
bool
resolutionUpdated
=
(
aResolution
!
=
GetResolution
(
)
)
;
RenderingState
state
(
this
)
;
state
.
mResolution
=
Some
(
aResolution
)
;
SetRenderingState
(
state
)
;
if
(
mMobileViewportManager
)
{
mMobileViewportManager
-
>
ResolutionUpdated
(
aOrigin
)
;
}
if
(
aOrigin
=
=
ResolutionChangeOrigin
:
:
Apz
)
{
mResolutionUpdatedByApz
=
true
;
}
else
if
(
resolutionUpdated
)
{
mResolutionUpdated
=
true
;
}
if
(
auto
*
window
=
nsGlobalWindowInner
:
:
Cast
(
mDocument
-
>
GetInnerWindow
(
)
)
)
{
window
-
>
VisualViewport
(
)
-
>
PostResizeEvent
(
)
;
}
return
NS_OK
;
}
float
PresShell
:
:
GetCumulativeResolution
(
)
const
{
float
resolution
=
GetResolution
(
)
;
nsPresContext
*
parentCtx
=
GetPresContext
(
)
-
>
GetParentPresContext
(
)
;
if
(
parentCtx
)
{
resolution
*
=
parentCtx
-
>
PresShell
(
)
-
>
GetCumulativeResolution
(
)
;
}
return
resolution
;
}
void
PresShell
:
:
SetRestoreResolution
(
float
aResolution
LayoutDeviceIntSize
aDisplaySize
)
{
if
(
mMobileViewportManager
)
{
mMobileViewportManager
-
>
SetRestoreResolution
(
aResolution
aDisplaySize
)
;
}
}
void
PresShell
:
:
SetRenderingState
(
const
RenderingState
&
aState
)
{
if
(
mRenderingStateFlags
!
=
aState
.
mRenderingStateFlags
)
{
LayerManager
*
manager
=
GetLayerManager
(
)
;
if
(
manager
)
{
FrameLayerBuilder
:
:
InvalidateAllLayers
(
manager
)
;
}
}
mRenderingStateFlags
=
aState
.
mRenderingStateFlags
;
mResolution
=
aState
.
mResolution
;
}
void
PresShell
:
:
SynthesizeMouseMove
(
bool
aFromScroll
)
{
if
(
!
StaticPrefs
:
:
layout_reflow_synthMouseMove
(
)
)
return
;
if
(
mPaintingSuppressed
|
|
!
mIsActive
|
|
!
mPresContext
)
{
return
;
}
if
(
!
mPresContext
-
>
IsRoot
(
)
)
{
if
(
PresShell
*
rootPresShell
=
GetRootPresShell
(
)
)
{
rootPresShell
-
>
SynthesizeMouseMove
(
aFromScroll
)
;
}
return
;
}
if
(
mMouseLocation
=
=
nsPoint
(
NS_UNCONSTRAINEDSIZE
NS_UNCONSTRAINEDSIZE
)
)
return
;
if
(
!
mSynthMouseMoveEvent
.
IsPending
(
)
)
{
RefPtr
<
nsSynthMouseMoveEvent
>
ev
=
new
nsSynthMouseMoveEvent
(
this
aFromScroll
)
;
GetPresContext
(
)
-
>
RefreshDriver
(
)
-
>
AddRefreshObserver
(
ev
FlushType
:
:
Display
"
Synthetic
mouse
move
event
"
)
;
mSynthMouseMoveEvent
=
std
:
:
move
(
ev
)
;
}
}
static
nsView
*
FindFloatingViewContaining
(
nsView
*
aRelativeToView
ViewportType
aRelativeToViewportType
nsView
*
aView
nsPoint
aPt
)
{
MOZ_ASSERT
(
aRelativeToView
-
>
GetFrame
(
)
)
;
if
(
aView
-
>
GetVisibility
(
)
=
=
nsViewVisibility_kHide
)
{
return
nullptr
;
}
bool
crossingZoomBoundary
=
false
;
nsIFrame
*
frame
=
aView
-
>
GetFrame
(
)
;
if
(
frame
)
{
if
(
!
frame
-
>
IsVisibleConsideringAncestors
(
nsIFrame
:
:
VISIBILITY_CROSS_CHROME_CONTENT_BOUNDARY
)
|
|
!
frame
-
>
PresShell
(
)
-
>
IsActive
(
)
)
{
return
nullptr
;
}
if
(
!
aRelativeToView
-
>
GetParent
(
)
|
|
aRelativeToView
-
>
GetViewManager
(
)
!
=
aRelativeToView
-
>
GetParent
(
)
-
>
GetViewManager
(
)
)
{
if
(
aRelativeToView
-
>
GetFrame
(
)
-
>
PresContext
(
)
-
>
IsRootContentDocumentCrossProcess
(
)
)
{
crossingZoomBoundary
=
true
;
}
}
ViewportType
nextRelativeToViewportType
=
aRelativeToViewportType
;
if
(
crossingZoomBoundary
)
{
nextRelativeToViewportType
=
ViewportType
:
:
Layout
;
}
nsLayoutUtils
:
:
TransformResult
result
=
nsLayoutUtils
:
:
TransformPoint
(
RelativeTo
{
aRelativeToView
-
>
GetFrame
(
)
aRelativeToViewportType
}
RelativeTo
{
frame
nextRelativeToViewportType
}
aPt
)
;
if
(
result
!
=
nsLayoutUtils
:
:
TRANSFORM_SUCCEEDED
)
{
return
nullptr
;
}
aRelativeToView
=
aView
;
aRelativeToViewportType
=
nextRelativeToViewportType
;
}
for
(
nsView
*
v
=
aView
-
>
GetFirstChild
(
)
;
v
;
v
=
v
-
>
GetNextSibling
(
)
)
{
nsView
*
r
=
FindFloatingViewContaining
(
aRelativeToView
aRelativeToViewportType
v
aPt
)
;
if
(
r
)
return
r
;
}
if
(
!
frame
|
|
!
aView
-
>
GetFloating
(
)
|
|
!
aView
-
>
HasWidget
(
)
)
{
return
nullptr
;
}
if
(
!
crossingZoomBoundary
)
{
if
(
aView
-
>
GetDimensions
(
)
.
Contains
(
aPt
)
)
{
return
aView
;
}
}
return
nullptr
;
}
static
nsView
*
FindViewContaining
(
nsView
*
aRelativeToView
ViewportType
aRelativeToViewportType
nsView
*
aView
nsPoint
aPt
)
{
MOZ_ASSERT
(
aRelativeToView
-
>
GetFrame
(
)
)
;
if
(
aView
-
>
GetVisibility
(
)
=
=
nsViewVisibility_kHide
)
{
return
nullptr
;
}
nsIFrame
*
frame
=
aView
-
>
GetFrame
(
)
;
if
(
frame
)
{
if
(
!
frame
-
>
IsVisibleConsideringAncestors
(
nsIFrame
:
:
VISIBILITY_CROSS_CHROME_CONTENT_BOUNDARY
)
|
|
!
frame
-
>
PresShell
(
)
-
>
IsActive
(
)
)
{
return
nullptr
;
}
bool
crossingZoomBoundary
=
false
;
if
(
!
aRelativeToView
-
>
GetParent
(
)
|
|
aRelativeToView
-
>
GetViewManager
(
)
!
=
aRelativeToView
-
>
GetParent
(
)
-
>
GetViewManager
(
)
)
{
if
(
aRelativeToView
-
>
GetFrame
(
)
-
>
PresContext
(
)
-
>
IsRootContentDocumentCrossProcess
(
)
)
{
crossingZoomBoundary
=
true
;
}
}
ViewportType
nextRelativeToViewportType
=
aRelativeToViewportType
;
if
(
crossingZoomBoundary
)
{
nextRelativeToViewportType
=
ViewportType
:
:
Layout
;
}
nsLayoutUtils
:
:
TransformResult
result
=
nsLayoutUtils
:
:
TransformPoint
(
RelativeTo
{
aRelativeToView
-
>
GetFrame
(
)
aRelativeToViewportType
}
RelativeTo
{
frame
nextRelativeToViewportType
}
aPt
)
;
if
(
result
!
=
nsLayoutUtils
:
:
TRANSFORM_SUCCEEDED
)
{
return
nullptr
;
}
if
(
!
crossingZoomBoundary
)
{
if
(
!
aView
-
>
GetDimensions
(
)
.
Contains
(
aPt
)
)
{
return
nullptr
;
}
}
aRelativeToView
=
aView
;
aRelativeToViewportType
=
nextRelativeToViewportType
;
}
for
(
nsView
*
v
=
aView
-
>
GetFirstChild
(
)
;
v
;
v
=
v
-
>
GetNextSibling
(
)
)
{
nsView
*
r
=
FindViewContaining
(
aRelativeToView
aRelativeToViewportType
v
aPt
)
;
if
(
r
)
return
r
;
}
return
frame
?
aView
:
nullptr
;
}
static
BrowserBridgeChild
*
GetChildBrowser
(
nsView
*
aView
)
{
if
(
!
aView
)
{
return
nullptr
;
}
nsIFrame
*
frame
=
aView
-
>
GetFrame
(
)
;
if
(
!
frame
&
&
aView
-
>
GetParent
(
)
)
{
frame
=
aView
-
>
GetParent
(
)
-
>
GetFrame
(
)
;
}
if
(
!
frame
|
|
!
frame
-
>
GetContent
(
)
)
{
return
nullptr
;
}
return
BrowserBridgeChild
:
:
GetFrom
(
frame
-
>
GetContent
(
)
)
;
}
void
PresShell
:
:
ProcessSynthMouseMoveEvent
(
bool
aFromScroll
)
{
nsCOMPtr
<
nsIDragSession
>
dragSession
=
nsContentUtils
:
:
GetDragSession
(
)
;
if
(
dragSession
)
{
mSynthMouseMoveEvent
.
Forget
(
)
;
return
;
}
if
(
aFromScroll
)
{
mSynthMouseMoveEvent
.
Forget
(
)
;
}
nsView
*
rootView
=
mViewManager
?
mViewManager
-
>
GetRootView
(
)
:
nullptr
;
if
(
mMouseLocation
=
=
nsPoint
(
NS_UNCONSTRAINEDSIZE
NS_UNCONSTRAINEDSIZE
)
|
|
!
rootView
|
|
!
rootView
-
>
HasWidget
(
)
|
|
!
mPresContext
)
{
mSynthMouseMoveEvent
.
Forget
(
)
;
return
;
}
NS_ASSERTION
(
mPresContext
-
>
IsRoot
(
)
"
Only
a
root
pres
shell
should
be
here
"
)
;
RefPtr
<
PresShell
>
kungFuDeathGrip
(
this
)
;
#
ifdef
DEBUG_MOUSE_LOCATION
printf
(
"
[
ps
=
%
p
]
synthesizing
mouse
move
to
(
%
d
%
d
)
\
n
"
this
mMouseLocation
.
x
mMouseLocation
.
y
)
;
#
endif
int32_t
APD
=
mPresContext
-
>
AppUnitsPerDevPixel
(
)
;
nsView
*
view
=
nullptr
;
int32_t
viewAPD
;
nsPoint
refpoint
(
0
0
)
;
nsViewManager
*
pointVM
=
nullptr
;
if
(
rootView
-
>
GetFrame
(
)
)
{
view
=
FindFloatingViewContaining
(
rootView
ViewportType
:
:
Visual
rootView
mMouseLocation
)
;
}
nsView
*
pointView
=
view
;
if
(
!
view
)
{
view
=
rootView
;
if
(
rootView
-
>
GetFrame
(
)
)
{
pointView
=
FindViewContaining
(
rootView
ViewportType
:
:
Visual
rootView
mMouseLocation
)
;
}
else
{
pointView
=
rootView
;
}
pointVM
=
(
pointView
?
pointView
:
view
)
-
>
GetViewManager
(
)
;
refpoint
=
mMouseLocation
+
rootView
-
>
ViewToWidgetOffset
(
)
;
viewAPD
=
APD
;
}
else
{
pointVM
=
view
-
>
GetViewManager
(
)
;
nsIFrame
*
frame
=
view
-
>
GetFrame
(
)
;
NS_ASSERTION
(
frame
"
floating
views
can
'
t
be
anonymous
"
)
;
viewAPD
=
frame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
refpoint
=
mMouseLocation
;
DebugOnly
<
nsLayoutUtils
:
:
TransformResult
>
result
=
nsLayoutUtils
:
:
TransformPoint
(
RelativeTo
{
rootView
-
>
GetFrame
(
)
ViewportType
:
:
Visual
}
RelativeTo
{
frame
ViewportType
:
:
Layout
}
refpoint
)
;
MOZ_ASSERT
(
result
=
=
nsLayoutUtils
:
:
TRANSFORM_SUCCEEDED
)
;
refpoint
+
=
view
-
>
ViewToWidgetOffset
(
)
;
}
NS_ASSERTION
(
view
-
>
GetWidget
(
)
"
view
should
have
a
widget
here
"
)
;
WidgetMouseEvent
event
(
true
eMouseMove
view
-
>
GetWidget
(
)
WidgetMouseEvent
:
:
eSynthesized
)
;
event
.
mRefPoint
=
LayoutDeviceIntPoint
:
:
FromAppUnitsToNearest
(
refpoint
viewAPD
)
;
event
.
mTime
=
PR_IntervalNow
(
)
;
if
(
BrowserBridgeChild
*
bbc
=
GetChildBrowser
(
pointView
)
)
{
event
.
mLayersId
=
bbc
-
>
GetLayersId
(
)
;
bbc
-
>
SendDispatchSynthesizedMouseEvent
(
event
)
;
}
else
if
(
RefPtr
<
PresShell
>
presShell
=
pointVM
-
>
GetPresShell
(
)
)
{
InputAPZContext
apzContext
(
mMouseEventTargetGuid
0
nsEventStatus_eIgnore
)
;
presShell
-
>
DispatchSynthMouseMove
(
&
event
)
;
}
if
(
!
aFromScroll
)
{
mSynthMouseMoveEvent
.
Forget
(
)
;
}
}
void
PresShell
:
:
MarkFramesInListApproximatelyVisible
(
const
nsDisplayList
&
aList
)
{
for
(
nsDisplayItem
*
item
=
aList
.
GetBottom
(
)
;
item
;
item
=
item
-
>
GetAbove
(
)
)
{
nsDisplayList
*
sublist
=
item
-
>
GetChildren
(
)
;
if
(
sublist
)
{
MarkFramesInListApproximatelyVisible
(
*
sublist
)
;
continue
;
}
nsIFrame
*
frame
=
item
-
>
Frame
(
)
;
MOZ_ASSERT
(
frame
)
;
if
(
!
frame
-
>
TrackingVisibility
(
)
)
{
continue
;
}
PresShell
*
presShell
=
frame
-
>
PresShell
(
)
;
MOZ_ASSERT
(
!
presShell
-
>
AssumeAllFramesVisible
(
)
)
;
if
(
presShell
-
>
mApproximatelyVisibleFrames
.
EnsureInserted
(
frame
)
)
{
frame
-
>
IncApproximateVisibleCount
(
)
;
}
}
}
void
PresShell
:
:
DecApproximateVisibleCount
(
VisibleFrames
&
aFrames
const
Maybe
<
OnNonvisible
>
&
aNonvisibleAction
)
{
for
(
nsIFrame
*
frame
:
aFrames
)
{
if
(
frame
-
>
TrackingVisibility
(
)
)
{
frame
-
>
DecApproximateVisibleCount
(
aNonvisibleAction
)
;
}
}
}
void
PresShell
:
:
RebuildApproximateFrameVisibilityDisplayList
(
const
nsDisplayList
&
aList
)
{
MOZ_ASSERT
(
!
mApproximateFrameVisibilityVisited
"
already
visited
?
"
)
;
mApproximateFrameVisibilityVisited
=
true
;
VisibleFrames
oldApproximatelyVisibleFrames
=
std
:
:
move
(
mApproximatelyVisibleFrames
)
;
MarkFramesInListApproximatelyVisible
(
aList
)
;
DecApproximateVisibleCount
(
oldApproximatelyVisibleFrames
)
;
}
void
PresShell
:
:
ClearApproximateFrameVisibilityVisited
(
nsView
*
aView
bool
aClear
)
{
nsViewManager
*
vm
=
aView
-
>
GetViewManager
(
)
;
if
(
aClear
)
{
PresShell
*
presShell
=
vm
-
>
GetPresShell
(
)
;
if
(
!
presShell
-
>
mApproximateFrameVisibilityVisited
)
{
presShell
-
>
ClearApproximatelyVisibleFramesList
(
)
;
}
presShell
-
>
mApproximateFrameVisibilityVisited
=
false
;
}
for
(
nsView
*
v
=
aView
-
>
GetFirstChild
(
)
;
v
;
v
=
v
-
>
GetNextSibling
(
)
)
{
ClearApproximateFrameVisibilityVisited
(
v
v
-
>
GetViewManager
(
)
!
=
vm
)
;
}
}
void
PresShell
:
:
ClearApproximatelyVisibleFramesList
(
const
Maybe
<
OnNonvisible
>
&
aNonvisibleAction
)
{
DecApproximateVisibleCount
(
mApproximatelyVisibleFrames
aNonvisibleAction
)
;
mApproximatelyVisibleFrames
.
Clear
(
)
;
}
void
PresShell
:
:
MarkFramesInSubtreeApproximatelyVisible
(
nsIFrame
*
aFrame
const
nsRect
&
aRect
bool
aRemoveOnly
)
{
MOZ_ASSERT
(
aFrame
-
>
PresShell
(
)
=
=
this
"
wrong
presshell
"
)
;
if
(
aFrame
-
>
TrackingVisibility
(
)
&
&
aFrame
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
&
&
(
!
aRemoveOnly
|
|
aFrame
-
>
GetVisibility
(
)
=
=
Visibility
:
:
ApproximatelyVisible
)
)
{
MOZ_ASSERT
(
!
AssumeAllFramesVisible
(
)
)
;
if
(
mApproximatelyVisibleFrames
.
EnsureInserted
(
aFrame
)
)
{
aFrame
-
>
IncApproximateVisibleCount
(
)
;
}
}
nsSubDocumentFrame
*
subdocFrame
=
do_QueryFrame
(
aFrame
)
;
if
(
subdocFrame
)
{
PresShell
*
presShell
=
subdocFrame
-
>
GetSubdocumentPresShellForPainting
(
nsSubDocumentFrame
:
:
IGNORE_PAINT_SUPPRESSION
)
;
if
(
presShell
&
&
!
presShell
-
>
AssumeAllFramesVisible
(
)
)
{
nsRect
rect
=
aRect
;
nsIFrame
*
root
=
presShell
-
>
GetRootFrame
(
)
;
if
(
root
)
{
rect
.
MoveBy
(
aFrame
-
>
GetOffsetToCrossDoc
(
root
)
)
;
}
else
{
rect
.
MoveBy
(
-
aFrame
-
>
GetContentRectRelativeToSelf
(
)
.
TopLeft
(
)
)
;
}
rect
=
rect
.
ScaleToOtherAppUnitsRoundOut
(
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
presShell
-
>
GetPresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
presShell
-
>
RebuildApproximateFrameVisibility
(
&
rect
)
;
}
return
;
}
nsRect
rect
=
aRect
;
nsIScrollableFrame
*
scrollFrame
=
do_QueryFrame
(
aFrame
)
;
if
(
scrollFrame
)
{
bool
ignoreDisplayPort
=
false
;
if
(
DisplayPortUtils
:
:
IsMissingDisplayPortBaseRect
(
aFrame
-
>
GetContent
(
)
)
)
{
nsPresContext
*
pc
=
aFrame
-
>
PresContext
(
)
;
if
(
scrollFrame
-
>
IsRootScrollFrameOfDocument
(
)
&
&
(
pc
-
>
IsRootContentDocument
(
)
|
|
!
pc
-
>
GetParentPresContext
(
)
)
)
{
nsRect
baseRect
=
nsRect
(
nsPoint
(
0
0
)
nsLayoutUtils
:
:
CalculateCompositionSizeForFrame
(
aFrame
)
)
;
DisplayPortUtils
:
:
SetDisplayPortBase
(
aFrame
-
>
GetContent
(
)
baseRect
)
;
}
else
{
ignoreDisplayPort
=
true
;
}
}
nsRect
displayPort
;
bool
usingDisplayport
=
!
ignoreDisplayPort
&
&
DisplayPortUtils
:
:
GetDisplayPortForVisibilityTesting
(
aFrame
-
>
GetContent
(
)
&
displayPort
)
;
scrollFrame
-
>
NotifyApproximateFrameVisibilityUpdate
(
!
usingDisplayport
)
;
if
(
usingDisplayport
)
{
rect
=
displayPort
;
}
else
{
rect
=
rect
.
Intersect
(
scrollFrame
-
>
GetScrollPortRect
(
)
)
;
}
rect
=
scrollFrame
-
>
ExpandRectToNearlyVisible
(
rect
)
;
}
bool
preserves3DChildren
=
aFrame
-
>
Extend3DContext
(
)
;
const
nsIFrame
:
:
ChildListIDs
skip
=
{
nsIFrame
:
:
kPopupList
nsIFrame
:
:
kSelectPopupList
}
;
for
(
const
auto
&
[
list
listID
]
:
aFrame
-
>
ChildLists
(
)
)
{
if
(
skip
.
contains
(
listID
)
)
{
continue
;
}
for
(
nsIFrame
*
child
:
list
)
{
nsRect
r
=
rect
-
child
-
>
GetPosition
(
)
;
if
(
!
r
.
IntersectRect
(
r
child
-
>
InkOverflowRect
(
)
)
)
{
continue
;
}
if
(
child
-
>
IsTransformed
(
)
)
{
if
(
!
preserves3DChildren
|
|
!
child
-
>
Combines3DTransformWithAncestors
(
)
)
{
const
nsRect
overflow
=
child
-
>
InkOverflowRectRelativeToSelf
(
)
;
nsRect
out
;
if
(
nsDisplayTransform
:
:
UntransformRect
(
r
overflow
child
&
out
)
)
{
r
=
out
;
}
else
{
r
.
SetEmpty
(
)
;
}
}
}
MarkFramesInSubtreeApproximatelyVisible
(
child
r
)
;
}
}
}
void
PresShell
:
:
RebuildApproximateFrameVisibility
(
nsRect
*
aRect
bool
aRemoveOnly
)
{
MOZ_ASSERT
(
!
mApproximateFrameVisibilityVisited
"
already
visited
?
"
)
;
mApproximateFrameVisibilityVisited
=
true
;
nsIFrame
*
rootFrame
=
GetRootFrame
(
)
;
if
(
!
rootFrame
)
{
return
;
}
VisibleFrames
oldApproximatelyVisibleFrames
=
std
:
:
move
(
mApproximatelyVisibleFrames
)
;
nsRect
vis
(
nsPoint
(
0
0
)
rootFrame
-
>
GetSize
(
)
)
;
if
(
aRect
)
{
vis
=
*
aRect
;
}
MarkFramesInSubtreeApproximatelyVisible
(
rootFrame
vis
aRemoveOnly
)
;
DecApproximateVisibleCount
(
oldApproximatelyVisibleFrames
)
;
}
void
PresShell
:
:
UpdateApproximateFrameVisibility
(
)
{
DoUpdateApproximateFrameVisibility
(
false
)
;
}
void
PresShell
:
:
DoUpdateApproximateFrameVisibility
(
bool
aRemoveOnly
)
{
MOZ_ASSERT
(
!
mPresContext
|
|
mPresContext
-
>
IsRootContentDocument
(
)
"
Updating
approximate
frame
visibility
on
a
non
-
root
content
document
?
"
)
;
mUpdateApproximateFrameVisibilityEvent
.
Revoke
(
)
;
if
(
mHaveShutDown
|
|
mIsDestroying
)
{
return
;
}
nsIFrame
*
rootFrame
=
GetRootFrame
(
)
;
if
(
!
rootFrame
)
{
ClearApproximatelyVisibleFramesList
(
Some
(
OnNonvisible
:
:
DiscardImages
)
)
;
return
;
}
RebuildApproximateFrameVisibility
(
nullptr
aRemoveOnly
)
;
ClearApproximateFrameVisibilityVisited
(
rootFrame
-
>
GetView
(
)
true
)
;
#
ifdef
DEBUG_FRAME_VISIBILITY_DISPLAY_LIST
nsDisplayListBuilder
builder
(
rootFrame
nsDisplayListBuilderMode
:
:
FRAME_VISIBILITY
false
)
;
nsRect
updateRect
(
nsPoint
(
0
0
)
rootFrame
-
>
GetSize
(
)
)
;
nsIFrame
*
rootScroll
=
GetRootScrollFrame
(
)
;
if
(
rootScroll
)
{
nsIContent
*
content
=
rootScroll
-
>
GetContent
(
)
;
if
(
content
)
{
Unused
<
<
nsLayoutUtils
:
:
GetDisplayPortForVisibilityTesting
(
content
&
updateRect
RelativeTo
:
:
ScrollFrame
)
;
}
if
(
IgnoringViewportScrolling
(
)
)
{
builder
.
SetIgnoreScrollFrame
(
rootScroll
)
;
}
}
builder
.
IgnorePaintSuppression
(
)
;
builder
.
EnterPresShell
(
rootFrame
)
;
nsDisplayList
list
;
rootFrame
-
>
BuildDisplayListForStackingContext
(
&
builder
updateRect
&
list
)
;
builder
.
LeavePresShell
(
rootFrame
&
list
)
;
RebuildApproximateFrameVisibilityDisplayList
(
list
)
;
ClearApproximateFrameVisibilityVisited
(
rootFrame
-
>
GetView
(
)
true
)
;
list
.
DeleteAll
(
&
builder
)
;
#
endif
}
bool
PresShell
:
:
AssumeAllFramesVisible
(
)
{
if
(
!
StaticPrefs
:
:
layout_framevisibility_enabled
(
)
|
|
!
mPresContext
|
|
!
mDocument
)
{
return
true
;
}
if
(
mPresContext
-
>
Type
(
)
=
=
nsPresContext
:
:
eContext_PrintPreview
|
|
mPresContext
-
>
Type
(
)
=
=
nsPresContext
:
:
eContext_Print
|
|
mPresContext
-
>
IsChrome
(
)
|
|
mDocument
-
>
IsResourceDoc
(
)
)
{
return
true
;
}
if
(
!
mHaveShutDown
&
&
!
mIsDestroying
&
&
!
mPresContext
-
>
IsRootContentDocumentInProcess
(
)
)
{
nsPresContext
*
presContext
=
mPresContext
-
>
GetInProcessRootContentDocumentPresContext
(
)
;
if
(
presContext
&
&
presContext
-
>
PresShell
(
)
-
>
AssumeAllFramesVisible
(
)
)
{
return
true
;
}
}
return
false
;
}
void
PresShell
:
:
ScheduleApproximateFrameVisibilityUpdateSoon
(
)
{
if
(
AssumeAllFramesVisible
(
)
)
{
return
;
}
if
(
!
mPresContext
)
{
return
;
}
nsRefreshDriver
*
refreshDriver
=
mPresContext
-
>
RefreshDriver
(
)
;
if
(
!
refreshDriver
)
{
return
;
}
refreshDriver
-
>
ScheduleFrameVisibilityUpdate
(
)
;
}
void
PresShell
:
:
ScheduleApproximateFrameVisibilityUpdateNow
(
)
{
if
(
AssumeAllFramesVisible
(
)
)
{
return
;
}
if
(
!
mPresContext
-
>
IsRootContentDocument
(
)
)
{
nsPresContext
*
presContext
=
mPresContext
-
>
GetInProcessRootContentDocumentPresContext
(
)
;
if
(
!
presContext
)
return
;
MOZ_ASSERT
(
presContext
-
>
IsRootContentDocument
(
)
"
Didn
'
t
get
a
root
prescontext
from
"
"
GetInProcessRootContentDocumentPresContext
?
"
)
;
presContext
-
>
PresShell
(
)
-
>
ScheduleApproximateFrameVisibilityUpdateNow
(
)
;
return
;
}
if
(
mHaveShutDown
|
|
mIsDestroying
)
{
return
;
}
if
(
mUpdateApproximateFrameVisibilityEvent
.
IsPending
(
)
)
{
return
;
}
RefPtr
<
nsRunnableMethod
<
PresShell
>
>
event
=
NewRunnableMethod
(
"
PresShell
:
:
UpdateApproximateFrameVisibility
"
this
&
PresShell
:
:
UpdateApproximateFrameVisibility
)
;
nsresult
rv
=
mDocument
-
>
Dispatch
(
TaskCategory
:
:
Other
do_AddRef
(
event
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mUpdateApproximateFrameVisibilityEvent
=
std
:
:
move
(
event
)
;
}
}
void
PresShell
:
:
EnsureFrameInApproximatelyVisibleList
(
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
-
>
TrackingVisibility
(
)
)
{
return
;
}
if
(
AssumeAllFramesVisible
(
)
)
{
aFrame
-
>
IncApproximateVisibleCount
(
)
;
return
;
}
#
ifdef
DEBUG
nsCOMPtr
<
nsIContent
>
content
=
aFrame
-
>
GetContent
(
)
;
if
(
content
)
{
PresShell
*
presShell
=
content
-
>
OwnerDoc
(
)
-
>
GetPresShell
(
)
;
MOZ_ASSERT
(
!
presShell
|
|
presShell
=
=
this
"
wrong
shell
"
)
;
}
#
endif
if
(
mApproximatelyVisibleFrames
.
EnsureInserted
(
aFrame
)
)
{
aFrame
-
>
IncApproximateVisibleCount
(
)
;
}
}
void
PresShell
:
:
RemoveFrameFromApproximatelyVisibleList
(
nsIFrame
*
aFrame
)
{
#
ifdef
DEBUG
nsCOMPtr
<
nsIContent
>
content
=
aFrame
-
>
GetContent
(
)
;
if
(
content
)
{
PresShell
*
presShell
=
content
-
>
OwnerDoc
(
)
-
>
GetPresShell
(
)
;
MOZ_ASSERT
(
!
presShell
|
|
presShell
=
=
this
"
wrong
shell
"
)
;
}
#
endif
if
(
AssumeAllFramesVisible
(
)
)
{
MOZ_ASSERT
(
mApproximatelyVisibleFrames
.
Count
(
)
=
=
0
"
Shouldn
'
t
have
any
frames
in
the
table
"
)
;
return
;
}
if
(
mApproximatelyVisibleFrames
.
EnsureRemoved
(
aFrame
)
&
&
aFrame
-
>
TrackingVisibility
(
)
)
{
aFrame
-
>
DecApproximateVisibleCount
(
)
;
}
}
class
nsAutoNotifyDidPaint
{
public
:
nsAutoNotifyDidPaint
(
PresShell
*
aShell
PaintFlags
aFlags
)
:
mShell
(
aShell
)
mFlags
(
aFlags
)
{
}
~
nsAutoNotifyDidPaint
(
)
{
if
(
!
!
(
mFlags
&
PaintFlags
:
:
PaintComposite
)
)
{
mShell
-
>
GetPresContext
(
)
-
>
NotifyDidPaintForSubtree
(
)
;
}
}
private
:
PresShell
*
mShell
;
PaintFlags
mFlags
;
}
;
void
PresShell
:
:
Paint
(
nsView
*
aViewToPaint
const
nsRegion
&
aDirtyRegion
PaintFlags
aFlags
)
{
nsCString
url
;
nsIURI
*
uri
=
mDocument
-
>
GetDocumentURI
(
)
;
Document
*
contentRoot
=
GetPrimaryContentDocument
(
)
;
if
(
contentRoot
)
{
uri
=
contentRoot
-
>
GetDocumentURI
(
)
;
}
url
=
uri
?
uri
-
>
GetSpecOrDefault
(
)
:
"
N
/
A
"
_ns
;
AUTO_PROFILER_LABEL_DYNAMIC_NSCSTRING
(
"
PresShell
:
:
Paint
"
GRAPHICS
url
)
;
Maybe
<
js
:
:
AutoAssertNoContentJS
>
nojs
;
#
if
!
defined
(
MOZ_WIDGET_ANDROID
)
if
(
!
(
aFlags
&
PaintFlags
:
:
PaintComposite
)
)
{
nojs
.
emplace
(
dom
:
:
danger
:
:
GetJSContext
(
)
)
;
}
#
endif
NS_ASSERTION
(
!
mIsDestroying
"
painting
a
destroyed
PresShell
"
)
;
NS_ASSERTION
(
aViewToPaint
"
null
view
"
)
;
MOZ_ASSERT
(
!
mApproximateFrameVisibilityVisited
"
Should
have
been
cleared
"
)
;
if
(
!
mIsActive
)
{
return
;
}
if
(
StaticPrefs
:
:
apz_keyboard_enabled_AtStartup
(
)
)
{
mAPZFocusTarget
=
FocusTarget
(
this
mAPZFocusSequenceNumber
)
;
}
nsPresContext
*
presContext
=
GetPresContext
(
)
;
AUTO_LAYOUT_PHASE_ENTRY_POINT
(
presContext
Paint
)
;
nsIFrame
*
frame
=
aViewToPaint
-
>
GetFrame
(
)
;
LayerManager
*
layerManager
=
aViewToPaint
-
>
GetWidget
(
)
-
>
GetLayerManager
(
)
;
NS_ASSERTION
(
layerManager
"
Must
be
in
paint
event
"
)
;
bool
shouldInvalidate
=
layerManager
-
>
NeedsWidgetInvalidation
(
)
;
nsAutoNotifyDidPaint
notifyDidPaint
(
this
aFlags
)
;
if
(
mIsFirstPaint
&
&
!
mPaintingSuppressed
)
{
MOZ_LOG
(
gLog
LogLevel
:
:
Debug
(
"
PresShell
:
:
Paint
first
paint
this
=
%
p
"
this
)
)
;
layerManager
-
>
SetIsFirstPaint
(
)
;
mIsFirstPaint
=
false
;
}
if
(
!
layerManager
-
>
BeginTransaction
(
url
)
)
{
return
;
}
layerManager
-
>
SetFocusTarget
(
mAPZFocusTarget
)
;
if
(
frame
)
{
if
(
!
(
aFlags
&
PaintFlags
:
:
PaintLayers
)
)
{
if
(
layerManager
-
>
EndEmptyTransaction
(
)
)
{
return
;
}
NS_WARNING
(
"
Must
complete
empty
transaction
when
compositing
!
"
)
;
}
if
(
!
(
aFlags
&
PaintFlags
:
:
PaintSyncDecodeImages
)
&
&
!
frame
-
>
HasAnyStateBits
(
NS_FRAME_UPDATE_LAYER_TREE
)
&
&
!
mNextPaintCompressed
)
{
NotifySubDocInvalidationFunc
computeInvalidFunc
=
presContext
-
>
MayHavePaintEventListenerInSubDocument
(
)
?
nsPresContext
:
:
NotifySubDocInvalidation
:
0
;
bool
computeInvalidRect
=
computeInvalidFunc
|
|
(
layerManager
-
>
GetBackendType
(
)
=
=
LayersBackend
:
:
LAYERS_BASIC
)
;
UniquePtr
<
LayerProperties
>
props
;
if
(
computeInvalidRect
&
&
layerManager
-
>
GetRoot
(
)
)
{
props
=
LayerProperties
:
:
CloneFrom
(
layerManager
-
>
GetRoot
(
)
)
;
}
MaybeSetupTransactionIdAllocator
(
layerManager
presContext
)
;
if
(
layerManager
-
>
EndEmptyTransaction
(
(
aFlags
&
PaintFlags
:
:
PaintComposite
)
?
LayerManager
:
:
END_DEFAULT
:
LayerManager
:
:
END_NO_COMPOSITE
)
)
{
nsIntRegion
invalid
;
bool
areaOverflowed
=
false
;
if
(
props
)
{
if
(
!
props
-
>
ComputeDifferences
(
layerManager
-
>
GetRoot
(
)
invalid
computeInvalidFunc
)
)
{
areaOverflowed
=
true
;
}
}
else
{
LayerProperties
:
:
ClearInvalidations
(
layerManager
-
>
GetRoot
(
)
)
;
}
if
(
props
&
&
!
areaOverflowed
)
{
if
(
!
invalid
.
IsEmpty
(
)
)
{
nsIntRect
bounds
=
invalid
.
GetBounds
(
)
;
nsRect
rect
(
presContext
-
>
DevPixelsToAppUnits
(
bounds
.
x
)
presContext
-
>
DevPixelsToAppUnits
(
bounds
.
y
)
presContext
-
>
DevPixelsToAppUnits
(
bounds
.
width
)
presContext
-
>
DevPixelsToAppUnits
(
bounds
.
height
)
)
;
if
(
shouldInvalidate
)
{
aViewToPaint
-
>
GetViewManager
(
)
-
>
InvalidateViewNoSuppression
(
aViewToPaint
rect
)
;
}
presContext
-
>
NotifyInvalidation
(
layerManager
-
>
GetLastTransactionId
(
)
bounds
)
;
}
}
else
if
(
shouldInvalidate
)
{
aViewToPaint
-
>
GetViewManager
(
)
-
>
InvalidateView
(
aViewToPaint
)
;
}
frame
-
>
UpdatePaintCountForPaintedPresShells
(
)
;
return
;
}
}
frame
-
>
RemoveStateBits
(
NS_FRAME_UPDATE_LAYER_TREE
)
;
}
if
(
frame
)
{
frame
-
>
ClearPresShellsFromLastPaint
(
)
;
}
nscolor
bgcolor
=
ComputeBackstopColor
(
aViewToPaint
)
;
PaintFrameFlags
flags
=
PaintFrameFlags
:
:
WidgetLayers
|
PaintFrameFlags
:
:
ExistingTransaction
;
if
(
!
(
aFlags
&
PaintFlags
:
:
PaintComposite
)
)
{
flags
|
=
PaintFrameFlags
:
:
NoComposite
;
}
if
(
aFlags
&
PaintFlags
:
:
PaintSyncDecodeImages
|
|
mDocument
-
>
IsStaticDocument
(
)
)
{
flags
|
=
PaintFrameFlags
:
:
SyncDecodeImages
;
}
if
(
mNextPaintCompressed
)
{
flags
|
=
PaintFrameFlags
:
:
Compressed
;
mNextPaintCompressed
=
false
;
}
if
(
layerManager
-
>
GetBackendType
(
)
=
=
layers
:
:
LayersBackend
:
:
LAYERS_WR
)
{
flags
|
=
PaintFrameFlags
:
:
ForWebRender
;
}
if
(
frame
)
{
nsLayoutUtils
:
:
PaintFrame
(
nullptr
frame
aDirtyRegion
bgcolor
nsDisplayListBuilderMode
:
:
Painting
flags
)
;
return
;
}
if
(
layerManager
-
>
GetBackendType
(
)
=
=
layers
:
:
LayersBackend
:
:
LAYERS_WR
)
{
nsPresContext
*
pc
=
GetPresContext
(
)
;
LayoutDeviceRect
bounds
=
LayoutDeviceRect
:
:
FromAppUnits
(
pc
-
>
GetVisibleArea
(
)
pc
-
>
AppUnitsPerDevPixel
(
)
)
;
bgcolor
=
NS_ComposeColors
(
bgcolor
mCanvasBackgroundColor
)
;
WebRenderBackgroundData
data
(
wr
:
:
ToLayoutRect
(
bounds
)
wr
:
:
ToColorF
(
ToDeviceColor
(
bgcolor
)
)
)
;
WrFiltersHolder
wrFilters
;
MaybeSetupTransactionIdAllocator
(
layerManager
presContext
)
;
layerManager
-
>
AsWebRenderLayerManager
(
)
-
>
EndTransactionWithoutLayer
(
nullptr
nullptr
std
:
:
move
(
wrFilters
)
&
data
0
)
;
return
;
}
RefPtr
<
ColorLayer
>
root
=
layerManager
-
>
CreateColorLayer
(
)
;
if
(
root
)
{
nsPresContext
*
pc
=
GetPresContext
(
)
;
nsIntRect
bounds
=
pc
-
>
GetVisibleArea
(
)
.
ToOutsidePixels
(
pc
-
>
AppUnitsPerDevPixel
(
)
)
;
bgcolor
=
NS_ComposeColors
(
bgcolor
mCanvasBackgroundColor
)
;
root
-
>
SetColor
(
ToDeviceColor
(
bgcolor
)
)
;
root
-
>
SetVisibleRegion
(
LayerIntRegion
:
:
FromUnknownRegion
(
bounds
)
)
;
layerManager
-
>
SetRoot
(
root
)
;
}
MaybeSetupTransactionIdAllocator
(
layerManager
presContext
)
;
layerManager
-
>
EndTransaction
(
nullptr
nullptr
(
aFlags
&
PaintFlags
:
:
PaintComposite
)
?
LayerManager
:
:
END_DEFAULT
:
LayerManager
:
:
END_NO_COMPOSITE
)
;
}
void
PresShell
:
:
SetCapturingContent
(
nsIContent
*
aContent
CaptureFlags
aFlags
WidgetEvent
*
aEvent
)
{
if
(
!
aContent
&
&
sCapturingContentInfo
.
mPointerLock
&
&
!
(
aFlags
&
CaptureFlags
:
:
PointerLock
)
)
{
return
;
}
sCapturingContentInfo
.
mContent
=
nullptr
;
sCapturingContentInfo
.
mRemoteTarget
=
nullptr
;
if
(
(
aFlags
&
CaptureFlags
:
:
IgnoreAllowedState
)
|
|
sCapturingContentInfo
.
mAllowed
|
|
(
aFlags
&
CaptureFlags
:
:
PointerLock
)
)
{
if
(
aContent
)
{
sCapturingContentInfo
.
mContent
=
aContent
;
}
if
(
aEvent
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
MOZ_ASSERT
(
aEvent
-
>
mMessage
=
=
eMouseDown
)
;
MOZ_ASSERT
(
aEvent
-
>
HasBeenPostedToRemoteProcess
(
)
)
;
sCapturingContentInfo
.
mRemoteTarget
=
BrowserParent
:
:
GetLastMouseRemoteTarget
(
)
;
MOZ_ASSERT
(
sCapturingContentInfo
.
mRemoteTarget
)
;
}
sCapturingContentInfo
.
mRetargetToElement
=
!
!
(
aFlags
&
CaptureFlags
:
:
RetargetToElement
)
|
|
!
!
(
aFlags
&
CaptureFlags
:
:
PointerLock
)
;
sCapturingContentInfo
.
mPreventDrag
=
!
!
(
aFlags
&
CaptureFlags
:
:
PreventDragStart
)
;
sCapturingContentInfo
.
mPointerLock
=
!
!
(
aFlags
&
CaptureFlags
:
:
PointerLock
)
;
}
}
nsIContent
*
PresShell
:
:
GetCurrentEventContent
(
)
{
if
(
mCurrentEventContent
&
&
mCurrentEventContent
-
>
GetComposedDoc
(
)
!
=
mDocument
)
{
mCurrentEventContent
=
nullptr
;
mCurrentEventFrame
=
nullptr
;
}
return
mCurrentEventContent
;
}
nsIFrame
*
PresShell
:
:
GetCurrentEventFrame
(
)
{
if
(
MOZ_UNLIKELY
(
mIsDestroying
)
)
{
return
nullptr
;
}
nsIContent
*
content
=
GetCurrentEventContent
(
)
;
if
(
!
mCurrentEventFrame
&
&
content
)
{
mCurrentEventFrame
=
content
-
>
GetPrimaryFrame
(
)
;
MOZ_ASSERT
(
!
mCurrentEventFrame
|
|
mCurrentEventFrame
-
>
PresContext
(
)
-
>
GetPresShell
(
)
=
=
this
)
;
}
return
mCurrentEventFrame
;
}
already_AddRefed
<
nsIContent
>
PresShell
:
:
GetEventTargetContent
(
WidgetEvent
*
aEvent
)
{
nsCOMPtr
<
nsIContent
>
content
=
GetCurrentEventContent
(
)
;
if
(
!
content
)
{
nsIFrame
*
currentEventFrame
=
GetCurrentEventFrame
(
)
;
if
(
currentEventFrame
)
{
currentEventFrame
-
>
GetContentForEvent
(
aEvent
getter_AddRefs
(
content
)
)
;
NS_ASSERTION
(
!
content
|
|
content
-
>
GetComposedDoc
(
)
=
=
mDocument
"
handing
out
content
from
a
different
doc
"
)
;
}
}
return
content
.
forget
(
)
;
}
void
PresShell
:
:
PushCurrentEventInfo
(
nsIFrame
*
aFrame
nsIContent
*
aContent
)
{
if
(
mCurrentEventFrame
|
|
mCurrentEventContent
)
{
mCurrentEventFrameStack
.
InsertElementAt
(
0
mCurrentEventFrame
)
;
mCurrentEventContentStack
.
InsertObjectAt
(
mCurrentEventContent
0
)
;
}
mCurrentEventFrame
=
aFrame
;
mCurrentEventContent
=
aContent
;
}
void
PresShell
:
:
PopCurrentEventInfo
(
)
{
mCurrentEventFrame
=
nullptr
;
mCurrentEventContent
=
nullptr
;
if
(
0
!
=
mCurrentEventFrameStack
.
Length
(
)
)
{
mCurrentEventFrame
=
mCurrentEventFrameStack
.
ElementAt
(
0
)
;
mCurrentEventFrameStack
.
RemoveElementAt
(
0
)
;
mCurrentEventContent
=
mCurrentEventContentStack
.
ObjectAt
(
0
)
;
mCurrentEventContentStack
.
RemoveObjectAt
(
0
)
;
if
(
mCurrentEventContent
&
&
mCurrentEventContent
-
>
GetComposedDoc
(
)
!
=
mDocument
)
{
mCurrentEventContent
=
nullptr
;
mCurrentEventFrame
=
nullptr
;
}
}
}
bool
PresShell
:
:
EventHandler
:
:
InZombieDocument
(
nsIContent
*
aContent
)
{
Document
*
doc
=
aContent
-
>
GetComposedDoc
(
)
;
return
!
doc
|
|
!
doc
-
>
GetWindow
(
)
;
}
already_AddRefed
<
nsPIDOMWindowOuter
>
PresShell
:
:
GetRootWindow
(
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
mDocument
-
>
GetWindow
(
)
;
if
(
window
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
rootWindow
=
window
-
>
GetPrivateRoot
(
)
;
NS_ASSERTION
(
rootWindow
"
nsPIDOMWindow
:
:
GetPrivateRoot
(
)
returns
NULL
"
)
;
return
rootWindow
.
forget
(
)
;
}
RefPtr
<
PresShell
>
parentPresShell
=
GetParentPresShellForEventHandling
(
)
;
NS_ENSURE_TRUE
(
parentPresShell
nullptr
)
;
return
parentPresShell
-
>
GetRootWindow
(
)
;
}
already_AddRefed
<
nsPIDOMWindowOuter
>
PresShell
:
:
GetFocusedDOMWindowInOurWindow
(
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
rootWindow
=
GetRootWindow
(
)
;
NS_ENSURE_TRUE
(
rootWindow
nullptr
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
focusedWindow
;
nsFocusManager
:
:
GetFocusedDescendant
(
rootWindow
nsFocusManager
:
:
eIncludeAllDescendants
getter_AddRefs
(
focusedWindow
)
)
;
return
focusedWindow
.
forget
(
)
;
}
already_AddRefed
<
nsIContent
>
PresShell
:
:
GetFocusedContentInOurWindow
(
)
const
{
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
fm
&
&
mDocument
)
{
RefPtr
<
Element
>
focusedElement
;
fm
-
>
GetFocusedElementForWindow
(
mDocument
-
>
GetWindow
(
)
false
nullptr
getter_AddRefs
(
focusedElement
)
)
;
return
focusedElement
.
forget
(
)
;
}
return
nullptr
;
}
already_AddRefed
<
PresShell
>
PresShell
:
:
GetParentPresShellForEventHandling
(
)
{
if
(
!
mPresContext
)
{
return
nullptr
;
}
RefPtr
<
nsDocShell
>
docShell
=
mPresContext
-
>
GetDocShell
(
)
;
if
(
!
docShell
)
{
docShell
=
mForwardingContainer
.
get
(
)
;
}
if
(
!
docShell
)
{
return
nullptr
;
}
BrowsingContext
*
bc
=
docShell
-
>
GetBrowsingContext
(
)
;
if
(
!
bc
)
{
return
nullptr
;
}
RefPtr
<
BrowsingContext
>
parentBC
;
if
(
XRE_IsParentProcess
(
)
)
{
parentBC
=
bc
-
>
Canonical
(
)
-
>
GetParentCrossChromeBoundary
(
)
;
}
else
{
parentBC
=
bc
-
>
GetParent
(
)
;
}
RefPtr
<
nsIDocShell
>
parentDocShell
=
parentBC
?
parentBC
-
>
GetDocShell
(
)
:
nullptr
;
if
(
!
parentDocShell
)
{
return
nullptr
;
}
RefPtr
<
PresShell
>
parentPresShell
=
parentDocShell
-
>
GetPresShell
(
)
;
return
parentPresShell
.
forget
(
)
;
}
nsresult
PresShell
:
:
EventHandler
:
:
RetargetEventToParent
(
WidgetGUIEvent
*
aGUIEvent
nsEventStatus
*
aEventStatus
)
{
RefPtr
<
PresShell
>
parentPresShell
=
GetParentPresShellForEventHandling
(
)
;
NS_ENSURE_TRUE
(
parentPresShell
NS_ERROR_FAILURE
)
;
return
parentPresShell
-
>
HandleEvent
(
parentPresShell
-
>
GetRootFrame
(
)
aGUIEvent
true
aEventStatus
)
;
}
void
PresShell
:
:
DisableNonTestMouseEvents
(
bool
aDisable
)
{
sDisableNonTestMouseEvents
=
aDisable
;
}
bool
PresShell
:
:
MouseLocationWasSetBySynthesizedMouseEventForTests
(
)
const
{
if
(
!
mPresContext
)
{
return
false
;
}
if
(
mPresContext
-
>
IsRoot
(
)
)
{
return
mMouseLocationWasSetBySynthesizedMouseEventForTests
;
}
PresShell
*
rootPresShell
=
GetRootPresShell
(
)
;
return
rootPresShell
&
&
rootPresShell
-
>
mMouseLocationWasSetBySynthesizedMouseEventForTests
;
}
void
PresShell
:
:
RecordMouseLocation
(
WidgetGUIEvent
*
aEvent
)
{
if
(
!
mPresContext
)
return
;
if
(
!
mPresContext
-
>
IsRoot
(
)
)
{
PresShell
*
rootPresShell
=
GetRootPresShell
(
)
;
if
(
rootPresShell
)
{
rootPresShell
-
>
RecordMouseLocation
(
aEvent
)
;
}
return
;
}
if
(
(
aEvent
-
>
mMessage
=
=
eMouseMove
&
&
aEvent
-
>
AsMouseEvent
(
)
-
>
mReason
=
=
WidgetMouseEvent
:
:
eReal
)
|
|
aEvent
-
>
mMessage
=
=
eMouseEnterIntoWidget
|
|
aEvent
-
>
mMessage
=
=
eMouseDown
|
|
aEvent
-
>
mMessage
=
=
eMouseUp
)
{
nsIFrame
*
rootFrame
=
GetRootFrame
(
)
;
if
(
!
rootFrame
)
{
nsView
*
rootView
=
mViewManager
-
>
GetRootView
(
)
;
mMouseLocation
=
nsLayoutUtils
:
:
TranslateWidgetToView
(
mPresContext
aEvent
-
>
mWidget
aEvent
-
>
mRefPoint
rootView
)
;
mMouseEventTargetGuid
=
InputAPZContext
:
:
GetTargetLayerGuid
(
)
;
}
else
{
RelativeTo
relativeTo
{
rootFrame
}
;
if
(
rootFrame
-
>
PresContext
(
)
-
>
IsRootContentDocumentCrossProcess
(
)
)
{
relativeTo
.
mViewportType
=
ViewportType
:
:
Visual
;
}
mMouseLocation
=
nsLayoutUtils
:
:
GetEventCoordinatesRelativeTo
(
aEvent
relativeTo
)
;
mMouseEventTargetGuid
=
InputAPZContext
:
:
GetTargetLayerGuid
(
)
;
}
mMouseLocationWasSetBySynthesizedMouseEventForTests
=
aEvent
-
>
mFlags
.
mIsSynthesizedForTests
;
#
ifdef
DEBUG_MOUSE_LOCATION
if
(
aEvent
-
>
mMessage
=
=
eMouseEnterIntoWidget
)
{
printf
(
"
[
ps
=
%
p
]
got
mouse
enter
for
%
p
\
n
"
this
aEvent
-
>
mWidget
)
;
}
printf
(
"
[
ps
=
%
p
]
setting
mouse
location
to
(
%
d
%
d
)
\
n
"
this
mMouseLocation
.
x
mMouseLocation
.
y
)
;
#
endif
if
(
aEvent
-
>
mMessage
=
=
eMouseEnterIntoWidget
)
{
SynthesizeMouseMove
(
false
)
;
}
}
else
if
(
aEvent
-
>
mMessage
=
=
eMouseExitFromWidget
)
{
mMouseLocation
=
nsPoint
(
NS_UNCONSTRAINEDSIZE
NS_UNCONSTRAINEDSIZE
)
;
mMouseEventTargetGuid
=
InputAPZContext
:
:
GetTargetLayerGuid
(
)
;
mMouseLocationWasSetBySynthesizedMouseEventForTests
=
aEvent
-
>
mFlags
.
mIsSynthesizedForTests
;
#
ifdef
DEBUG_MOUSE_LOCATION
printf
(
"
[
ps
=
%
p
]
got
mouse
exit
for
%
p
\
n
"
this
aEvent
-
>
mWidget
)
;
printf
(
"
[
ps
=
%
p
]
clearing
mouse
location
\
n
"
this
)
;
#
endif
}
}
void
PresShell
:
:
nsSynthMouseMoveEvent
:
:
Revoke
(
)
{
if
(
mPresShell
)
{
mPresShell
-
>
GetPresContext
(
)
-
>
RefreshDriver
(
)
-
>
RemoveRefreshObserver
(
this
FlushType
:
:
Display
)
;
mPresShell
=
nullptr
;
}
}
nsIFrame
*
PresShell
:
:
EventHandler
:
:
GetNearestFrameContainingPresShell
(
PresShell
*
aPresShell
)
{
nsView
*
view
=
aPresShell
-
>
GetViewManager
(
)
-
>
GetRootView
(
)
;
while
(
view
&
&
!
view
-
>
GetFrame
(
)
)
{
view
=
view
-
>
GetParent
(
)
;
}
nsIFrame
*
frame
=
nullptr
;
if
(
view
)
{
frame
=
view
-
>
GetFrame
(
)
;
}
return
frame
;
}
static
CallState
FlushThrottledStyles
(
Document
&
aDocument
)
{
PresShell
*
presShell
=
aDocument
.
GetPresShell
(
)
;
if
(
presShell
&
&
presShell
-
>
IsVisible
(
)
)
{
if
(
nsPresContext
*
presContext
=
presShell
-
>
GetPresContext
(
)
)
{
presContext
-
>
RestyleManager
(
)
-
>
UpdateOnlyAnimationStyles
(
)
;
}
}
aDocument
.
EnumerateSubDocuments
(
FlushThrottledStyles
)
;
return
CallState
:
:
Continue
;
}
bool
PresShell
:
:
CanDispatchEvent
(
const
WidgetGUIEvent
*
aEvent
)
const
{
bool
rv
=
mPresContext
&
&
!
mHaveShutDown
&
&
nsContentUtils
:
:
IsSafeToRunScript
(
)
;
if
(
aEvent
)
{
rv
&
=
(
aEvent
&
&
aEvent
-
>
mWidget
&
&
!
aEvent
-
>
mWidget
-
>
Destroyed
(
)
)
;
}
return
rv
;
}
PresShell
*
PresShell
:
:
GetShellForEventTarget
(
nsIFrame
*
aFrame
nsIContent
*
aContent
)
{
if
(
aFrame
)
{
return
aFrame
-
>
PresShell
(
)
;
}
if
(
aContent
)
{
Document
*
doc
=
aContent
-
>
GetComposedDoc
(
)
;
if
(
!
doc
)
{
return
nullptr
;
}
return
doc
-
>
GetPresShell
(
)
;
}
return
nullptr
;
}
PresShell
*
PresShell
:
:
GetShellForTouchEvent
(
WidgetGUIEvent
*
aEvent
)
{
switch
(
aEvent
-
>
mMessage
)
{
case
eTouchMove
:
case
eTouchCancel
:
case
eTouchEnd
:
{
WidgetTouchEvent
*
touchEvent
=
aEvent
-
>
AsTouchEvent
(
)
;
for
(
dom
:
:
Touch
*
touch
:
touchEvent
-
>
mTouches
)
{
if
(
!
touch
)
{
return
nullptr
;
}
RefPtr
<
dom
:
:
Touch
>
oldTouch
=
TouchManager
:
:
GetCapturedTouch
(
touch
-
>
Identifier
(
)
)
;
if
(
!
oldTouch
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
oldTouch
-
>
GetTarget
(
)
)
;
if
(
!
content
)
{
return
nullptr
;
}
nsIFrame
*
contentFrame
=
content
-
>
GetPrimaryFrame
(
)
;
if
(
!
contentFrame
)
{
return
nullptr
;
}
PresShell
*
presShell
=
contentFrame
-
>
PresContext
(
)
-
>
GetPresShell
(
)
;
if
(
presShell
)
{
return
presShell
;
}
}
return
nullptr
;
}
default
:
return
nullptr
;
}
}
nsresult
PresShell
:
:
HandleEvent
(
nsIFrame
*
aFrameForPresShell
WidgetGUIEvent
*
aGUIEvent
bool
aDontRetargetEvents
nsEventStatus
*
aEventStatus
)
{
MOZ_ASSERT
(
aGUIEvent
)
;
if
(
aGUIEvent
-
>
mMessage
=
=
eMouseMove
&
&
aGUIEvent
-
>
CameFromAnotherProcess
(
)
&
&
XRE_IsContentProcess
(
)
&
&
!
aGUIEvent
-
>
mFlags
.
mIsSynthesizedForTests
&
&
MouseLocationWasSetBySynthesizedMouseEventForTests
(
)
&
&
aGUIEvent
-
>
AsMouseEvent
(
)
-
>
mReason
=
=
WidgetMouseEvent
:
:
eSynthesized
)
{
return
NS_OK
;
}
EventHandler
eventHandler
(
*
this
)
;
return
eventHandler
.
HandleEvent
(
aFrameForPresShell
aGUIEvent
aDontRetargetEvents
aEventStatus
)
;
}
nsresult
PresShell
:
:
EventHandler
:
:
HandleEvent
(
nsIFrame
*
aFrameForPresShell
WidgetGUIEvent
*
aGUIEvent
bool
aDontRetargetEvents
nsEventStatus
*
aEventStatus
)
{
MOZ_ASSERT
(
aGUIEvent
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aGUIEvent
-
>
IsTrusted
(
)
)
;
MOZ_ASSERT
(
aEventStatus
)
;
#
ifdef
MOZ_TASK_TRACER
Maybe
<
AutoSourceEvent
>
taskTracerEvent
;
if
(
MOZ_UNLIKELY
(
IsStartLogging
(
)
)
)
{
SourceEventType
type
=
SourceEventType
:
:
Unknown
;
if
(
aGUIEvent
-
>
AsTouchEvent
(
)
)
{
type
=
SourceEventType
:
:
Touch
;
}
else
if
(
aGUIEvent
-
>
AsMouseEvent
(
)
)
{
type
=
SourceEventType
:
:
Mouse
;
}
else
if
(
aGUIEvent
-
>
AsKeyboardEvent
(
)
)
{
type
=
SourceEventType
:
:
Key
;
}
taskTracerEvent
.
emplace
(
type
)
;
}
#
endif
NS_ASSERTION
(
aFrameForPresShell
"
aFrameForPresShell
should
be
not
null
"
)
;
if
(
mPresShell
-
>
mAPZFocusSequenceNumber
<
aGUIEvent
-
>
mFocusSequenceNumber
)
{
mPresShell
-
>
mAPZFocusSequenceNumber
=
aGUIEvent
-
>
mFocusSequenceNumber
;
}
if
(
mPresShell
-
>
IsDestroying
(
)
|
|
(
PresShell
:
:
sDisableNonTestMouseEvents
&
&
!
aGUIEvent
-
>
mFlags
.
mIsSynthesizedForTests
&
&
aGUIEvent
-
>
HasMouseEventMessage
(
)
)
)
{
return
NS_OK
;
}
mPresShell
-
>
RecordMouseLocation
(
aGUIEvent
)
;
if
(
MaybeHandleEventWithAccessibleCaret
(
aFrameForPresShell
aGUIEvent
aEventStatus
)
)
{
return
NS_OK
;
}
if
(
MaybeDiscardEvent
(
aGUIEvent
)
)
{
return
NS_OK
;
}
if
(
!
aDontRetargetEvents
)
{
nsresult
rv
=
NS_OK
;
if
(
MaybeHandleEventWithAnotherPresShell
(
aFrameForPresShell
aGUIEvent
aEventStatus
&
rv
)
)
{
return
rv
;
}
}
if
(
MaybeDiscardOrDelayKeyboardEvent
(
aGUIEvent
)
)
{
return
NS_OK
;
}
if
(
aGUIEvent
-
>
IsUsingCoordinates
(
)
)
{
return
HandleEventUsingCoordinates
(
aFrameForPresShell
aGUIEvent
aEventStatus
aDontRetargetEvents
)
;
}
if
(
!
aFrameForPresShell
)
{
if
(
!
NS_EVENT_NEEDS_FRAME
(
aGUIEvent
)
)
{
AutoCurrentEventInfoSetter
eventInfoSetter
(
*
this
)
;
return
HandleEventWithCurrentEventInfo
(
aGUIEvent
aEventStatus
true
nullptr
)
;
}
if
(
aGUIEvent
-
>
HasKeyEventMessage
(
)
)
{
return
RetargetEventToParent
(
aGUIEvent
aEventStatus
)
;
}
return
NS_OK
;
}
if
(
aGUIEvent
-
>
IsTargetedAtFocusedContent
(
)
)
{
return
HandleEventAtFocusedContent
(
aGUIEvent
aEventStatus
)
;
}
return
HandleEventWithFrameForPresShell
(
aFrameForPresShell
aGUIEvent
aEventStatus
)
;
}
nsresult
PresShell
:
:
EventHandler
:
:
HandleEventUsingCoordinates
(
nsIFrame
*
aFrameForPresShell
WidgetGUIEvent
*
aGUIEvent
nsEventStatus
*
aEventStatus
bool
aDontRetargetEvents
)
{
MOZ_ASSERT
(
aGUIEvent
)
;
MOZ_ASSERT
(
aGUIEvent
-
>
IsUsingCoordinates
(
)
)
;
MOZ_ASSERT
(
aEventStatus
)
;
AutoWeakFrame
weakFrame
(
aFrameForPresShell
)
;
MaybeFlushPendingNotifications
(
aGUIEvent
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
*
aEventStatus
=
nsEventStatus_eIgnore
;
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
capturingContent
=
EventHandler
:
:
GetCapturingContentFor
(
aGUIEvent
)
;
if
(
GetDocument
(
)
&
&
aGUIEvent
-
>
mClass
=
=
eTouchEventClass
)
{
PointerLockManager
:
:
Unlock
(
)
;
}
nsIFrame
*
frameForPresShell
=
MaybeFlushThrottledStyles
(
aFrameForPresShell
)
;
if
(
NS_WARN_IF
(
!
frameForPresShell
)
)
{
return
NS_OK
;
}
bool
isCapturingContentIgnored
=
false
;
bool
isCaptureRetargeted
=
false
;
nsIFrame
*
rootFrameToHandleEvent
=
ComputeRootFrameToHandleEvent
(
frameForPresShell
aGUIEvent
capturingContent
&
isCapturingContentIgnored
&
isCaptureRetargeted
)
;
if
(
isCapturingContentIgnored
)
{
capturingContent
=
nullptr
;
}
{
AutoWeakFrame
frameKeeper
(
rootFrameToHandleEvent
)
;
PointerEventHandler
:
:
MaybeProcessPointerCapture
(
aGUIEvent
)
;
if
(
!
frameKeeper
.
IsAlive
(
)
)
{
NS_WARNING
(
"
Nothing
to
handle
this
event
!
"
)
;
return
NS_OK
;
}
}
RefPtr
<
Element
>
pointerCapturingElement
=
PointerEventHandler
:
:
GetPointerCapturingElement
(
aGUIEvent
)
;
if
(
pointerCapturingElement
)
{
rootFrameToHandleEvent
=
pointerCapturingElement
-
>
GetPrimaryFrame
(
)
;
if
(
!
rootFrameToHandleEvent
)
{
return
HandleEventWithPointerCapturingContentWithoutItsFrame
(
aFrameForPresShell
aGUIEvent
pointerCapturingElement
aEventStatus
)
;
}
}
WidgetMouseEvent
*
mouseEvent
=
aGUIEvent
-
>
AsMouseEvent
(
)
;
bool
isWindowLevelMouseExit
=
(
aGUIEvent
-
>
mMessage
=
=
eMouseExitFromWidget
)
&
&
(
mouseEvent
&
&
(
mouseEvent
-
>
mExitFrom
.
value
(
)
=
=
WidgetMouseEvent
:
:
ePlatformTopLevel
|
|
mouseEvent
-
>
mExitFrom
.
value
(
)
=
=
WidgetMouseEvent
:
:
ePuppet
)
)
;
EventTargetData
eventTargetData
(
rootFrameToHandleEvent
)
;
if
(
!
isCaptureRetargeted
&
&
!
isWindowLevelMouseExit
&
&
!
pointerCapturingElement
)
{
if
(
!
ComputeEventTargetFrameAndPresShellAtEventPoint
(
rootFrameToHandleEvent
aGUIEvent
&
eventTargetData
)
)
{
*
aEventStatus
=
nsEventStatus_eIgnore
;
return
NS_OK
;
}
}
if
(
capturingContent
&
&
!
pointerCapturingElement
&
&
(
PresShell
:
:
sCapturingContentInfo
.
mRetargetToElement
|
|
!
eventTargetData
.
mFrame
-
>
GetContent
(
)
|
|
!
nsContentUtils
:
:
ContentIsCrossDocDescendantOf
(
eventTargetData
.
mFrame
-
>
GetContent
(
)
capturingContent
)
)
)
{
NS_ASSERTION
(
capturingContent
-
>
OwnerDoc
(
)
=
=
GetDocument
(
)
"
Unexpected
document
"
)
;
nsIFrame
*
capturingFrame
=
capturingContent
-
>
GetPrimaryFrame
(
)
;
if
(
capturingFrame
)
{
eventTargetData
.
SetFrameAndComputePresShell
(
capturingFrame
)
;
}
}
if
(
NS_WARN_IF
(
!
eventTargetData
.
mFrame
)
)
{
return
NS_OK
;
}
if
(
MaybeDiscardOrDelayMouseEvent
(
eventTargetData
.
mFrame
aGUIEvent
)
)
{
return
NS_OK
;
}
if
(
eventTargetData
.
MaybeRetargetToActiveDocument
(
aGUIEvent
)
&
&
NS_WARN_IF
(
!
eventTargetData
.
mFrame
)
)
{
return
NS_OK
;
}
if
(
!
eventTargetData
.
ComputeElementFromFrame
(
aGUIEvent
)
)
{
return
NS_OK
;
}
if
(
!
DispatchPrecedingPointerEvent
(
aFrameForPresShell
aGUIEvent
pointerCapturingElement
aDontRetargetEvents
&
eventTargetData
aEventStatus
)
)
{
return
NS_OK
;
}
eventTargetData
.
UpdateTouchEventTarget
(
aGUIEvent
)
;
EventHandler
eventHandler
(
*
eventTargetData
.
mPresShell
)
;
AutoCurrentEventInfoSetter
eventInfoSetter
(
eventHandler
eventTargetData
)
;
nsresult
rv
=
eventHandler
.
HandleEventWithCurrentEventInfo
(
aGUIEvent
aEventStatus
true
MOZ_KnownLive
(
eventTargetData
.
mOverrideClickTarget
)
)
;
#
ifdef
DEBUG
eventTargetData
.
mPresShell
-
>
ShowEventTargetDebug
(
)
;
#
endif
return
rv
;
}
bool
PresShell
:
:
EventHandler
:
:
MaybeFlushPendingNotifications
(
WidgetGUIEvent
*
aGUIEvent
)
{
MOZ_ASSERT
(
aGUIEvent
)
;
switch
(
aGUIEvent
-
>
mMessage
)
{
case
eMouseDown
:
case
eMouseUp
:
{
RefPtr
<
nsPresContext
>
presContext
=
mPresShell
-
>
GetPresContext
(
)
;
if
(
NS_WARN_IF
(
!
presContext
)
)
{
return
false
;
}
uint64_t
framesConstructedCount
=
presContext
-
>
FramesConstructedCount
(
)
;
uint64_t
framesReflowedCount
=
presContext
-
>
FramesReflowedCount
(
)
;
MOZ_KnownLive
(
mPresShell
)
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
return
framesConstructedCount
!
=
presContext
-
>
FramesConstructedCount
(
)
|
|
framesReflowedCount
!
=
presContext
-
>
FramesReflowedCount
(
)
;
}
default
:
return
false
;
}
}
static
ViewportType
ViewportTypeForInputEventsRelativeToRoot
(
)
{
#
ifdef
MOZ_WIDGET_ANDROID
return
ViewportType
:
:
Layout
;
#
else
return
ViewportType
:
:
Visual
;
#
endif
}
nsIFrame
*
PresShell
:
:
EventHandler
:
:
GetFrameToHandleNonTouchEvent
(
nsIFrame
*
aRootFrameToHandleEvent
WidgetGUIEvent
*
aGUIEvent
)
{
MOZ_ASSERT
(
aGUIEvent
)
;
MOZ_ASSERT
(
aGUIEvent
-
>
mClass
!
=
eTouchEventClass
)
;
ViewportType
viewportType
=
ViewportType
:
:
Layout
;
if
(
aRootFrameToHandleEvent
-
>
Type
(
)
=
=
LayoutFrameType
:
:
Viewport
)
{
nsPresContext
*
pc
=
aRootFrameToHandleEvent
-
>
PresContext
(
)
;
if
(
pc
-
>
IsChrome
(
)
)
{
viewportType
=
ViewportType
:
:
Visual
;
}
else
if
(
pc
-
>
IsRootContentDocument
(
)
)
{
viewportType
=
ViewportTypeForInputEventsRelativeToRoot
(
)
;
}
}
RelativeTo
relativeTo
{
aRootFrameToHandleEvent
viewportType
}
;
nsPoint
eventPoint
=
nsLayoutUtils
:
:
GetEventCoordinatesRelativeTo
(
aGUIEvent
relativeTo
)
;
uint32_t
flags
=
0
;
if
(
aGUIEvent
-
>
mClass
=
=
eMouseEventClass
)
{
WidgetMouseEvent
*
mouseEvent
=
aGUIEvent
-
>
AsMouseEvent
(
)
;
if
(
mouseEvent
&
&
mouseEvent
-
>
mIgnoreRootScrollFrame
)
{
flags
|
=
INPUT_IGNORE_ROOT_SCROLL_FRAME
;
}
}
nsIFrame
*
targetFrame
=
FindFrameTargetedByInputEvent
(
aGUIEvent
relativeTo
eventPoint
flags
)
;
if
(
!
targetFrame
)
{
return
aRootFrameToHandleEvent
;
}
if
(
targetFrame
-
>
PresShell
(
)
=
=
mPresShell
)
{
return
targetFrame
;
}
PresShell
*
childPresShell
=
targetFrame
-
>
PresShell
(
)
;
EventHandler
childEventHandler
(
*
childPresShell
)
;
AutoWeakFrame
weakFrame
(
aRootFrameToHandleEvent
)
;
bool
layoutChanged
=
childEventHandler
.
MaybeFlushPendingNotifications
(
aGUIEvent
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
nullptr
;
}
if
(
!
layoutChanged
)
{
return
targetFrame
;
}
targetFrame
=
FindFrameTargetedByInputEvent
(
aGUIEvent
relativeTo
eventPoint
flags
)
;
return
targetFrame
?
targetFrame
:
aRootFrameToHandleEvent
;
}
bool
PresShell
:
:
EventHandler
:
:
ComputeEventTargetFrameAndPresShellAtEventPoint
(
nsIFrame
*
aRootFrameToHandleEvent
WidgetGUIEvent
*
aGUIEvent
EventTargetData
*
aEventTargetData
)
{
MOZ_ASSERT
(
aRootFrameToHandleEvent
)
;
MOZ_ASSERT
(
aGUIEvent
)
;
MOZ_ASSERT
(
aEventTargetData
)
;
if
(
aGUIEvent
-
>
mClass
=
=
eTouchEventClass
)
{
nsIFrame
*
targetFrameAtTouchEvent
=
TouchManager
:
:
SetupTarget
(
aGUIEvent
-
>
AsTouchEvent
(
)
aRootFrameToHandleEvent
)
;
aEventTargetData
-
>
SetFrameAndComputePresShell
(
targetFrameAtTouchEvent
)
;
return
true
;
}
nsIFrame
*
targetFrame
=
GetFrameToHandleNonTouchEvent
(
aRootFrameToHandleEvent
aGUIEvent
)
;
aEventTargetData
-
>
SetFrameAndComputePresShell
(
targetFrame
)
;
return
!
!
aEventTargetData
-
>
mFrame
;
}
bool
PresShell
:
:
EventHandler
:
:
DispatchPrecedingPointerEvent
(
nsIFrame
*
aFrameForPresShell
WidgetGUIEvent
*
aGUIEvent
nsIContent
*
aPointerCapturingContent
bool
aDontRetargetEvents
EventTargetData
*
aEventTargetData
nsEventStatus
*
aEventStatus
)
{
MOZ_ASSERT
(
aFrameForPresShell
)
;
MOZ_ASSERT
(
aGUIEvent
)
;
MOZ_ASSERT
(
aEventTargetData
)
;
MOZ_ASSERT
(
aEventStatus
)
;
nsIFrame
*
targetFrame
=
aGUIEvent
-
>
mClass
=
=
eTouchEventClass
?
aFrameForPresShell
:
aEventTargetData
-
>
mFrame
;
if
(
aPointerCapturingContent
)
{
aEventTargetData
-
>
mOverrideClickTarget
=
GetOverrideClickTarget
(
aGUIEvent
aFrameForPresShell
)
;
aEventTargetData
-
>
mPresShell
=
PresShell
:
:
GetShellForEventTarget
(
nullptr
aPointerCapturingContent
)
;
if
(
!
aEventTargetData
-
>
mPresShell
)
{
PointerEventHandler
:
:
ReleaseIfCaptureByDescendant
(
aPointerCapturingContent
)
;
return
false
;
}
targetFrame
=
aPointerCapturingContent
-
>
GetPrimaryFrame
(
)
;
aEventTargetData
-
>
mFrame
=
targetFrame
;
}
AutoWeakFrame
weakTargetFrame
(
targetFrame
)
;
AutoWeakFrame
weakFrame
(
aEventTargetData
-
>
mFrame
)
;
nsCOMPtr
<
nsIContent
>
content
(
aEventTargetData
-
>
mContent
)
;
RefPtr
<
PresShell
>
presShell
(
aEventTargetData
-
>
mPresShell
)
;
nsCOMPtr
<
nsIContent
>
targetContent
;
PointerEventHandler
:
:
DispatchPointerFromMouseOrTouch
(
presShell
aEventTargetData
-
>
mFrame
content
aGUIEvent
aDontRetargetEvents
aEventStatus
getter_AddRefs
(
targetContent
)
)
;
if
(
weakTargetFrame
.
IsAlive
(
)
)
{
return
weakFrame
.
IsAlive
(
)
;
}
if
(
aGUIEvent
-
>
mClass
!
=
eMouseEventClass
)
{
return
weakFrame
.
IsAlive
(
)
;
}
if
(
!
targetContent
)
{
return
false
;
}
aEventTargetData
-
>
mFrame
=
targetContent
-
>
GetPrimaryFrame
(
)
;
aEventTargetData
-
>
mPresShell
=
PresShell
:
:
GetShellForEventTarget
(
aEventTargetData
-
>
mFrame
targetContent
)
;
return
!
!
aEventTargetData
-
>
mPresShell
;
}
bool
PresShell
:
:
EventHandler
:
:
MaybeHandleEventWithAccessibleCaret
(
nsIFrame
*
aFrameForPresShell
WidgetGUIEvent
*
aGUIEvent
nsEventStatus
*
aEventStatus
)
{
MOZ_ASSERT
(
aGUIEvent
)
;
MOZ_ASSERT
(
aEventStatus
)
;
if
(
*
aEventStatus
=
=
nsEventStatus_eConsumeNoDefault
)
{
return
false
;
}
if
(
!
AccessibleCaretEnabled
(
GetDocument
(
)
-
>
GetDocShell
(
)
)
)
{
return
false
;
}
if
(
aGUIEvent
-
>
mClass
!
=
eMouseEventClass
&
&
aGUIEvent
-
>
mClass
!
=
eTouchEventClass
&
&
aGUIEvent
-
>
mClass
!
=
eKeyboardEventClass
)
{
return
false
;
}
do
{
EventTargetData
eventTargetData
(
nullptr
)
;
if
(
!
ComputeEventTargetFrameAndPresShellAtEventPoint
(
aFrameForPresShell
aGUIEvent
&
eventTargetData
)
)
{
break
;
}
if
(
!
eventTargetData
.
mPresShell
)
{
break
;
}
RefPtr
<
AccessibleCaretEventHub
>
eventHub
=
eventTargetData
.
mPresShell
-
>
GetAccessibleCaretEventHub
(
)
;
if
(
!
eventHub
)
{
break
;
}
*
aEventStatus
=
eventHub
-
>
HandleEvent
(
aGUIEvent
)
;
if
(
*
aEventStatus
!
=
nsEventStatus_eConsumeNoDefault
)
{
break
;
}
aGUIEvent
-
>
mFlags
.
mMultipleActionsPrevented
=
true
;
return
true
;
}
while
(
false
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
GetFocusedDOMWindowInOurWindow
(
)
;
if
(
!
window
)
{
return
false
;
}
RefPtr
<
Document
>
retargetEventDoc
=
window
-
>
GetExtantDoc
(
)
;
if
(
!
retargetEventDoc
)
{
return
false
;
}
RefPtr
<
PresShell
>
presShell
=
retargetEventDoc
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
return
false
;
}
RefPtr
<
AccessibleCaretEventHub
>
eventHub
=
presShell
-
>
GetAccessibleCaretEventHub
(
)
;
if
(
!
eventHub
)
{
return
false
;
}
*
aEventStatus
=
eventHub
-
>
HandleEvent
(
aGUIEvent
)
;
if
(
*
aEventStatus
!
=
nsEventStatus_eConsumeNoDefault
)
{
return
false
;
}
aGUIEvent
-
>
mFlags
.
mMultipleActionsPrevented
=
true
;
return
true
;
}
bool
PresShell
:
:
EventHandler
:
:
MaybeDiscardEvent
(
WidgetGUIEvent
*
aGUIEvent
)
{
MOZ_ASSERT
(
aGUIEvent
)
;
if
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
{
return
false
;
}
if
(
!
aGUIEvent
-
>
IsAllowedToDispatchDOMEvent
(
)
)
{
return
false
;
}
if
(
aGUIEvent
-
>
mClass
=
=
eCompositionEventClass
)
{
IMEStateManager
:
:
OnCompositionEventDiscarded
(
aGUIEvent
-
>
AsCompositionEvent
(
)
)
;
}
#
ifdef
DEBUG
if
(
aGUIEvent
-
>
IsIMERelatedEvent
(
)
)
{
nsPrintfCString
warning
(
"
%
s
event
is
discarded
"
ToChar
(
aGUIEvent
-
>
mMessage
)
)
;
NS_WARNING
(
warning
.
get
(
)
)
;
}
#
endif
nsContentUtils
:
:
WarnScriptWasIgnored
(
GetDocument
(
)
)
;
return
true
;
}
nsIContent
*
PresShell
:
:
EventHandler
:
:
GetCapturingContentFor
(
WidgetGUIEvent
*
aGUIEvent
)
{
return
(
aGUIEvent
-
>
mClass
=
=
ePointerEventClass
|
|
aGUIEvent
-
>
mClass
=
=
eWheelEventClass
|
|
aGUIEvent
-
>
HasMouseEventMessage
(
)
)
?
PresShell
:
:
GetCapturingContent
(
)
:
nullptr
;
}
bool
PresShell
:
:
EventHandler
:
:
GetRetargetEventDocument
(
WidgetGUIEvent
*
aGUIEvent
Document
*
*
aRetargetEventDocument
)
{
MOZ_ASSERT
(
aGUIEvent
)
;
MOZ_ASSERT
(
aRetargetEventDocument
)
;
*
aRetargetEventDocument
=
nullptr
;
if
(
aGUIEvent
-
>
IsTargetedAtFocusedWindow
(
)
)
{
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
=
GetFocusedDOMWindowInOurWindow
(
)
;
if
(
!
window
)
{
return
false
;
}
RefPtr
<
Document
>
retargetEventDoc
=
window
-
>
GetExtantDoc
(
)
;
if
(
!
retargetEventDoc
)
{
return
false
;
}
retargetEventDoc
.
forget
(
aRetargetEventDocument
)
;
return
true
;
}
nsIContent
*
capturingContent
=
EventHandler
:
:
GetCapturingContentFor
(
aGUIEvent
)
;
if
(
capturingContent
)
{
RefPtr
<
Document
>
retargetEventDoc
=
capturingContent
-
>
GetComposedDoc
(
)
;
retargetEventDoc
.
forget
(
aRetargetEventDocument
)
;
return
true
;
}
#
ifdef
ANDROID
if
(
aGUIEvent
-
>
mClass
=
=
eTouchEventClass
|
|
aGUIEvent
-
>
mClass
=
=
eMouseEventClass
|
|
aGUIEvent
-
>
mClass
=
=
eWheelEventClass
)
{
RefPtr
<
Document
>
retargetEventDoc
=
mPresShell
-
>
GetPrimaryContentDocument
(
)
;
retargetEventDoc
.
forget
(
aRetargetEventDocument
)
;
return
true
;
}
#
endif
return
true
;
}
nsIFrame
*
PresShell
:
:
EventHandler
:
:
GetFrameForHandlingEventWith
(
WidgetGUIEvent
*
aGUIEvent
Document
*
aRetargetDocument
nsIFrame
*
aFrameForPresShell
)
{
MOZ_ASSERT
(
aGUIEvent
)
;
MOZ_ASSERT
(
aRetargetDocument
)
;
RefPtr
<
PresShell
>
retargetPresShell
=
aRetargetDocument
-
>
GetPresShell
(
)
;
if
(
!
retargetPresShell
)
{
if
(
!
aGUIEvent
-
>
HasKeyEventMessage
(
)
)
{
return
nullptr
;
}
Document
*
retargetEventDoc
=
aRetargetDocument
;
while
(
!
retargetPresShell
)
{
retargetEventDoc
=
retargetEventDoc
-
>
GetInProcessParentDocument
(
)
;
if
(
!
retargetEventDoc
)
{
return
nullptr
;
}
retargetPresShell
=
retargetEventDoc
-
>
GetPresShell
(
)
;
}
}
if
(
retargetPresShell
=
=
mPresShell
)
{
return
aFrameForPresShell
;
}
nsIFrame
*
rootFrame
=
retargetPresShell
-
>
GetRootFrame
(
)
;
if
(
rootFrame
)
{
return
rootFrame
;
}
if
(
aGUIEvent
-
>
mMessage
=
=
eQueryTextContent
|
|
aGUIEvent
-
>
IsContentCommandEvent
(
)
)
{
return
nullptr
;
}
return
GetNearestFrameContainingPresShell
(
retargetPresShell
)
;
}
bool
PresShell
:
:
EventHandler
:
:
MaybeHandleEventWithAnotherPresShell
(
nsIFrame
*
aFrameForPresShell
WidgetGUIEvent
*
aGUIEvent
nsEventStatus
*
aEventStatus
nsresult
*
aRv
)
{
MOZ_ASSERT
(
aGUIEvent
)
;
MOZ_ASSERT
(
aEventStatus
)
;
MOZ_ASSERT
(
aRv
)
;
*
aRv
=
NS_OK
;
RefPtr
<
Document
>
retargetEventDoc
;
if
(
!
GetRetargetEventDocument
(
aGUIEvent
getter_AddRefs
(
retargetEventDoc
)
)
)
{
return
true
;
}
if
(
!
retargetEventDoc
)
{
return
false
;
}
nsIFrame
*
frame
=
GetFrameForHandlingEventWith
(
aGUIEvent
retargetEventDoc
aFrameForPresShell
)
;
if
(
!
frame
)
{
return
true
;
}
if
(
frame
=
=
aFrameForPresShell
)
{
return
false
;
}
RefPtr
<
PresShell
>
presShell
=
frame
-
>
PresContext
(
)
-
>
PresShell
(
)
;
*
aRv
=
presShell
-
>
HandleEvent
(
frame
aGUIEvent
true
aEventStatus
)
;
return
true
;
}
bool
PresShell
:
:
EventHandler
:
:
MaybeDiscardOrDelayKeyboardEvent
(
WidgetGUIEvent
*
aGUIEvent
)
{
MOZ_ASSERT
(
aGUIEvent
)
;
if
(
aGUIEvent
-
>
mClass
!
=
eKeyboardEventClass
)
{
return
false
;
}
Document
*
document
=
GetDocument
(
)
;
if
(
!
document
|
|
!
document
-
>
EventHandlingSuppressed
(
)
)
{
return
false
;
}
MOZ_ASSERT_IF
(
InputTaskManager
:
:
CanSuspendInputEvent
(
)
!
InputTaskManager
:
:
Get
(
)
-
>
IsSuspended
(
)
)
;
if
(
aGUIEvent
-
>
mMessage
=
=
eKeyDown
)
{
mPresShell
-
>
mNoDelayedKeyEvents
=
true
;
}
else
if
(
!
mPresShell
-
>
mNoDelayedKeyEvents
)
{
UniquePtr
<
DelayedKeyEvent
>
delayedKeyEvent
=
MakeUnique
<
DelayedKeyEvent
>
(
aGUIEvent
-
>
AsKeyboardEvent
(
)
)
;
PushDelayedEventIntoQueue
(
std
:
:
move
(
delayedKeyEvent
)
)
;
}
aGUIEvent
-
>
mFlags
.
mIsSuppressedOrDelayed
=
true
;
return
true
;
}
bool
PresShell
:
:
EventHandler
:
:
MaybeDiscardOrDelayMouseEvent
(
nsIFrame
*
aFrameToHandleEvent
WidgetGUIEvent
*
aGUIEvent
)
{
MOZ_ASSERT
(
aFrameToHandleEvent
)
;
MOZ_ASSERT
(
aGUIEvent
)
;
if
(
aGUIEvent
-
>
mClass
!
=
eMouseEventClass
)
{
return
false
;
}
if
(
!
aFrameToHandleEvent
-
>
PresContext
(
)
-
>
Document
(
)
-
>
EventHandlingSuppressed
(
)
)
{
return
false
;
}
MOZ_ASSERT_IF
(
InputTaskManager
:
:
CanSuspendInputEvent
(
)
&
&
aGUIEvent
-
>
mMessage
!
=
eMouseMove
!
InputTaskManager
:
:
Get
(
)
-
>
IsSuspended
(
)
)
;
if
(
aGUIEvent
-
>
mMessage
=
=
eMouseDown
)
{
mPresShell
-
>
mNoDelayedMouseEvents
=
true
;
}
else
if
(
!
mPresShell
-
>
mNoDelayedMouseEvents
&
&
(
aGUIEvent
-
>
mMessage
=
=
eMouseUp
|
|
aGUIEvent
-
>
mMessage
=
=
eContextMenu
|
|
aGUIEvent
-
>
mMessage
=
=
eMouseExitFromWidget
)
)
{
UniquePtr
<
DelayedMouseEvent
>
delayedMouseEvent
=
MakeUnique
<
DelayedMouseEvent
>
(
aGUIEvent
-
>
AsMouseEvent
(
)
)
;
PushDelayedEventIntoQueue
(
std
:
:
move
(
delayedMouseEvent
)
)
;
}
RefPtr
<
EventListener
>
suppressedListener
=
aFrameToHandleEvent
-
>
PresContext
(
)
-
>
Document
(
)
-
>
GetSuppressedEventListener
(
)
;
if
(
!
suppressedListener
|
|
aGUIEvent
-
>
AsMouseEvent
(
)
-
>
mReason
=
=
WidgetMouseEvent
:
:
eSynthesized
)
{
return
true
;
}
nsCOMPtr
<
nsIContent
>
targetContent
;
aFrameToHandleEvent
-
>
GetContentForEvent
(
aGUIEvent
getter_AddRefs
(
targetContent
)
)
;
if
(
targetContent
)
{
aGUIEvent
-
>
mTarget
=
targetContent
;
}
nsCOMPtr
<
EventTarget
>
eventTarget
=
aGUIEvent
-
>
mTarget
;
RefPtr
<
Event
>
event
=
EventDispatcher
:
:
CreateEvent
(
eventTarget
aFrameToHandleEvent
-
>
PresContext
(
)
aGUIEvent
u
"
"
_ns
)
;
suppressedListener
-
>
HandleEvent
(
*
event
)
;
return
true
;
}
nsIFrame
*
PresShell
:
:
EventHandler
:
:
MaybeFlushThrottledStyles
(
nsIFrame
*
aFrameForPresShell
)
{
if
(
!
GetDocument
(
)
)
{
return
aFrameForPresShell
;
}
PresShell
*
rootPresShell
=
mPresShell
-
>
GetRootPresShell
(
)
;
if
(
NS_WARN_IF
(
!
rootPresShell
)
)
{
return
nullptr
;
}
Document
*
rootDocument
=
rootPresShell
-
>
GetDocument
(
)
;
if
(
NS_WARN_IF
(
!
rootDocument
)
)
{
return
nullptr
;
}
AutoWeakFrame
weakFrameForPresShell
(
aFrameForPresShell
)
;
{
nsAutoScriptBlocker
scriptBlocker
;
FlushThrottledStyles
(
*
rootDocument
)
;
}
if
(
weakFrameForPresShell
.
IsAlive
(
)
)
{
return
aFrameForPresShell
;
}
return
GetNearestFrameContainingPresShell
(
mPresShell
)
;
}
nsIFrame
*
PresShell
:
:
EventHandler
:
:
ComputeRootFrameToHandleEvent
(
nsIFrame
*
aFrameForPresShell
WidgetGUIEvent
*
aGUIEvent
nsIContent
*
aCapturingContent
bool
*
aIsCapturingContentIgnored
bool
*
aIsCaptureRetargeted
)
{
MOZ_ASSERT
(
aFrameForPresShell
)
;
MOZ_ASSERT
(
aGUIEvent
)
;
MOZ_ASSERT
(
aIsCapturingContentIgnored
)
;
MOZ_ASSERT
(
aIsCaptureRetargeted
)
;
nsIFrame
*
rootFrameToHandleEvent
=
ComputeRootFrameToHandleEventWithPopup
(
aFrameForPresShell
aGUIEvent
aCapturingContent
aIsCapturingContentIgnored
)
;
if
(
*
aIsCapturingContentIgnored
)
{
return
rootFrameToHandleEvent
;
}
if
(
!
aCapturingContent
)
{
return
rootFrameToHandleEvent
;
}
return
ComputeRootFrameToHandleEventWithCapturingContent
(
rootFrameToHandleEvent
aCapturingContent
aIsCapturingContentIgnored
aIsCaptureRetargeted
)
;
}
nsIFrame
*
PresShell
:
:
EventHandler
:
:
ComputeRootFrameToHandleEventWithPopup
(
nsIFrame
*
aRootFrameToHandleEvent
WidgetGUIEvent
*
aGUIEvent
nsIContent
*
aCapturingContent
bool
*
aIsCapturingContentIgnored
)
{
MOZ_ASSERT
(
aRootFrameToHandleEvent
)
;
MOZ_ASSERT
(
aGUIEvent
)
;
MOZ_ASSERT
(
aIsCapturingContentIgnored
)
;
*
aIsCapturingContentIgnored
=
false
;
nsPresContext
*
framePresContext
=
aRootFrameToHandleEvent
-
>
PresContext
(
)
;
nsPresContext
*
rootPresContext
=
framePresContext
-
>
GetRootPresContext
(
)
;
NS_ASSERTION
(
rootPresContext
=
=
GetPresContext
(
)
-
>
GetRootPresContext
(
)
"
How
did
we
end
up
outside
the
connected
"
"
prescontext
/
viewmanager
hierarchy
?
"
)
;
nsIFrame
*
popupFrame
=
nsLayoutUtils
:
:
GetPopupFrameForEventCoordinates
(
rootPresContext
aGUIEvent
)
;
if
(
!
popupFrame
)
{
return
aRootFrameToHandleEvent
;
}
if
(
aCapturingContent
&
&
EventStateManager
:
:
IsTopLevelRemoteTarget
(
aCapturingContent
)
)
{
*
aIsCapturingContentIgnored
=
true
;
}
if
(
nsContentUtils
:
:
ContentIsCrossDocDescendantOf
(
framePresContext
-
>
GetPresShell
(
)
-
>
GetDocument
(
)
popupFrame
-
>
GetContent
(
)
)
)
{
return
aRootFrameToHandleEvent
;
}
if
(
framePresContext
=
=
rootPresContext
&
&
aRootFrameToHandleEvent
=
=
FrameConstructor
(
)
-
>
GetRootFrame
(
)
)
{
return
popupFrame
;
}
if
(
aCapturingContent
&
&
!
*
aIsCapturingContentIgnored
&
&
aCapturingContent
-
>
IsInclusiveDescendantOf
(
popupFrame
-
>
GetContent
(
)
)
)
{
return
popupFrame
;
}
return
aRootFrameToHandleEvent
;
}
nsIFrame
*
PresShell
:
:
EventHandler
:
:
ComputeRootFrameToHandleEventWithCapturingContent
(
nsIFrame
*
aRootFrameToHandleEvent
nsIContent
*
aCapturingContent
bool
*
aIsCapturingContentIgnored
bool
*
aIsCaptureRetargeted
)
{
MOZ_ASSERT
(
aRootFrameToHandleEvent
)
;
MOZ_ASSERT
(
aCapturingContent
)
;
MOZ_ASSERT
(
aIsCapturingContentIgnored
)
;
MOZ_ASSERT
(
aIsCaptureRetargeted
)
;
*
aIsCapturingContentIgnored
=
false
;
*
aIsCaptureRetargeted
=
false
;
BrowsingContext
*
bc
=
GetPresContext
(
)
-
>
Document
(
)
-
>
GetBrowsingContext
(
)
;
if
(
!
bc
|
|
!
bc
-
>
IsActive
(
)
)
{
ClearMouseCapture
(
nullptr
)
;
*
aIsCapturingContentIgnored
=
true
;
return
aRootFrameToHandleEvent
;
}
if
(
PresShell
:
:
sCapturingContentInfo
.
mRetargetToElement
)
{
*
aIsCaptureRetargeted
=
true
;
return
aRootFrameToHandleEvent
;
}
NS_ASSERTION
(
aCapturingContent
-
>
OwnerDoc
(
)
=
=
GetDocument
(
)
"
Unexpected
document
"
)
;
nsIFrame
*
captureFrame
=
aCapturingContent
-
>
GetPrimaryFrame
(
)
;
if
(
!
captureFrame
)
{
return
aRootFrameToHandleEvent
;
}
if
(
aCapturingContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
select
)
)
{
nsIFrame
*
childFrame
=
captureFrame
-
>
GetChildList
(
nsIFrame
:
:
kSelectPopupList
)
.
FirstChild
(
)
;
if
(
childFrame
)
{
captureFrame
=
childFrame
;
}
}
nsIScrollableFrame
*
scrollFrame
=
do_QueryFrame
(
captureFrame
)
;
return
scrollFrame
?
scrollFrame
-
>
GetScrolledFrame
(
)
:
aRootFrameToHandleEvent
;
}
nsresult
PresShell
:
:
EventHandler
:
:
HandleEventWithPointerCapturingContentWithoutItsFrame
(
nsIFrame
*
aFrameForPresShell
WidgetGUIEvent
*
aGUIEvent
nsIContent
*
aPointerCapturingContent
nsEventStatus
*
aEventStatus
)
{
MOZ_ASSERT
(
aGUIEvent
)
;
MOZ_ASSERT
(
aPointerCapturingContent
)
;
MOZ_ASSERT
(
!
aPointerCapturingContent
-
>
GetPrimaryFrame
(
)
"
Handle
the
event
with
frame
rather
than
only
with
the
content
"
)
;
MOZ_ASSERT
(
aEventStatus
)
;
RefPtr
<
PresShell
>
presShellForCapturingContent
=
PresShell
:
:
GetShellForEventTarget
(
nullptr
aPointerCapturingContent
)
;
if
(
!
presShellForCapturingContent
)
{
PointerEventHandler
:
:
ReleaseIfCaptureByDescendant
(
aPointerCapturingContent
)
;
return
NS_OK
;
}
nsCOMPtr
<
nsIContent
>
overrideClickTarget
=
GetOverrideClickTarget
(
aGUIEvent
aFrameForPresShell
)
;
PointerEventHandler
:
:
DispatchPointerFromMouseOrTouch
(
presShellForCapturingContent
nullptr
aPointerCapturingContent
aGUIEvent
false
aEventStatus
nullptr
)
;
if
(
presShellForCapturingContent
=
=
mPresShell
)
{
return
HandleEventWithTarget
(
aGUIEvent
nullptr
aPointerCapturingContent
aEventStatus
true
nullptr
overrideClickTarget
)
;
}
EventHandler
eventHandlerForCapturingContent
(
std
:
:
move
(
presShellForCapturingContent
)
)
;
return
eventHandlerForCapturingContent
.
HandleEventWithTarget
(
aGUIEvent
nullptr
aPointerCapturingContent
aEventStatus
true
nullptr
overrideClickTarget
)
;
}
nsresult
PresShell
:
:
EventHandler
:
:
HandleEventAtFocusedContent
(
WidgetGUIEvent
*
aGUIEvent
nsEventStatus
*
aEventStatus
)
{
MOZ_ASSERT
(
aGUIEvent
)
;
MOZ_ASSERT
(
aGUIEvent
-
>
IsTargetedAtFocusedContent
(
)
)
;
MOZ_ASSERT
(
aEventStatus
)
;
AutoCurrentEventInfoSetter
eventInfoSetter
(
*
this
)
;
RefPtr
<
Element
>
eventTargetElement
=
ComputeFocusedEventTargetElement
(
aGUIEvent
)
;
mPresShell
-
>
mCurrentEventFrame
=
nullptr
;
if
(
eventTargetElement
)
{
nsresult
rv
=
NS_OK
;
if
(
MaybeHandleEventWithAnotherPresShell
(
eventTargetElement
aGUIEvent
aEventStatus
&
rv
)
)
{
return
rv
;
}
}
mPresShell
-
>
mCurrentEventContent
=
eventTargetElement
;
if
(
!
mPresShell
-
>
GetCurrentEventContent
(
)
|
|
!
mPresShell
-
>
GetCurrentEventFrame
(
)
|
|
InZombieDocument
(
mPresShell
-
>
mCurrentEventContent
)
)
{
return
RetargetEventToParent
(
aGUIEvent
aEventStatus
)
;
}
nsresult
rv
=
HandleEventWithCurrentEventInfo
(
aGUIEvent
aEventStatus
true
nullptr
)
;
#
ifdef
DEBUG
mPresShell
-
>
ShowEventTargetDebug
(
)
;
#
endif
return
rv
;
}
Element
*
PresShell
:
:
EventHandler
:
:
ComputeFocusedEventTargetElement
(
WidgetGUIEvent
*
aGUIEvent
)
{
MOZ_ASSERT
(
aGUIEvent
)
;
MOZ_ASSERT
(
aGUIEvent
-
>
IsTargetedAtFocusedContent
(
)
)
;
nsPIDOMWindowOuter
*
window
=
GetDocument
(
)
-
>
GetWindow
(
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
focusedWindow
;
Element
*
eventTargetElement
=
nsFocusManager
:
:
GetFocusedDescendant
(
window
nsFocusManager
:
:
eOnlyCurrentWindow
getter_AddRefs
(
focusedWindow
)
)
;
if
(
!
eventTargetElement
|
|
!
eventTargetElement
-
>
GetPrimaryFrame
(
)
)
{
eventTargetElement
=
GetDocument
(
)
-
>
GetUnfocusedKeyEventTarget
(
)
;
}
switch
(
aGUIEvent
-
>
mMessage
)
{
case
eKeyDown
:
sLastKeyDownEventTargetElement
=
eventTargetElement
;
return
eventTargetElement
;
case
eKeyPress
:
case
eKeyUp
:
if
(
!
sLastKeyDownEventTargetElement
)
{
return
eventTargetElement
;
}
if
(
eventTargetElement
)
{
bool
keyDownIsChrome
=
nsContentUtils
:
:
IsChromeDoc
(
sLastKeyDownEventTargetElement
-
>
GetComposedDoc
(
)
)
;
if
(
keyDownIsChrome
!
=
nsContentUtils
:
:
IsChromeDoc
(
eventTargetElement
-
>
GetComposedDoc
(
)
)
|
|
(
keyDownIsChrome
&
&
BrowserParent
:
:
GetFrom
(
eventTargetElement
)
)
)
{
eventTargetElement
=
sLastKeyDownEventTargetElement
;
}
}
if
(
aGUIEvent
-
>
mMessage
=
=
eKeyUp
)
{
sLastKeyDownEventTargetElement
=
nullptr
;
}
[
[
fallthrough
]
]
;
default
:
return
eventTargetElement
;
}
}
bool
PresShell
:
:
EventHandler
:
:
MaybeHandleEventWithAnotherPresShell
(
Element
*
aEventTargetElement
WidgetGUIEvent
*
aGUIEvent
nsEventStatus
*
aEventStatus
nsresult
*
aRv
)
{
MOZ_ASSERT
(
aEventTargetElement
)
;
MOZ_ASSERT
(
aGUIEvent
)
;
MOZ_ASSERT
(
!
aGUIEvent
-
>
IsUsingCoordinates
(
)
)
;
MOZ_ASSERT
(
aEventStatus
)
;
MOZ_ASSERT
(
aRv
)
;
Document
*
eventTargetDocument
=
aEventTargetElement
-
>
OwnerDoc
(
)
;
if
(
!
eventTargetDocument
|
|
eventTargetDocument
=
=
GetDocument
(
)
)
{
*
aRv
=
NS_OK
;
return
false
;
}
RefPtr
<
PresShell
>
eventTargetPresShell
=
eventTargetDocument
-
>
GetPresShell
(
)
;
if
(
!
eventTargetPresShell
)
{
*
aRv
=
NS_OK
;
return
true
;
}
EventHandler
eventHandler
(
std
:
:
move
(
eventTargetPresShell
)
)
;
*
aRv
=
eventHandler
.
HandleRetargetedEvent
(
aGUIEvent
aEventStatus
aEventTargetElement
)
;
return
true
;
}
nsresult
PresShell
:
:
EventHandler
:
:
HandleEventWithFrameForPresShell
(
nsIFrame
*
aFrameForPresShell
WidgetGUIEvent
*
aGUIEvent
nsEventStatus
*
aEventStatus
)
{
MOZ_ASSERT
(
aGUIEvent
)
;
MOZ_ASSERT
(
!
aGUIEvent
-
>
IsUsingCoordinates
(
)
)
;
MOZ_ASSERT
(
!
aGUIEvent
-
>
IsTargetedAtFocusedContent
(
)
)
;
MOZ_ASSERT
(
aEventStatus
)
;
AutoCurrentEventInfoSetter
eventInfoSetter
(
*
this
aFrameForPresShell
nullptr
)
;
nsresult
rv
=
NS_OK
;
if
(
mPresShell
-
>
GetCurrentEventFrame
(
)
)
{
rv
=
HandleEventWithCurrentEventInfo
(
aGUIEvent
aEventStatus
true
nullptr
)
;
}
#
ifdef
DEBUG
mPresShell
-
>
ShowEventTargetDebug
(
)
;
#
endif
return
rv
;
}
Document
*
PresShell
:
:
GetPrimaryContentDocument
(
)
{
nsPresContext
*
context
=
GetPresContext
(
)
;
if
(
!
context
|
|
!
context
-
>
IsRoot
(
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
shellAsTreeItem
=
context
-
>
GetDocShell
(
)
;
if
(
!
shellAsTreeItem
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIDocShellTreeOwner
>
owner
;
shellAsTreeItem
-
>
GetTreeOwner
(
getter_AddRefs
(
owner
)
)
;
if
(
!
owner
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIDocShellTreeItem
>
item
;
owner
-
>
GetPrimaryContentShell
(
getter_AddRefs
(
item
)
)
;
nsCOMPtr
<
nsIDocShell
>
childDocShell
=
do_QueryInterface
(
item
)
;
if
(
!
childDocShell
)
{
return
nullptr
;
}
return
childDocShell
-
>
GetExtantDocument
(
)
;
}
#
ifdef
DEBUG
void
PresShell
:
:
ShowEventTargetDebug
(
)
{
if
(
nsIFrame
:
:
GetShowEventTargetFrameBorder
(
)
&
&
GetCurrentEventFrame
(
)
)
{
if
(
mDrawEventTargetFrame
)
{
mDrawEventTargetFrame
-
>
InvalidateFrame
(
)
;
}
mDrawEventTargetFrame
=
mCurrentEventFrame
;
mDrawEventTargetFrame
-
>
InvalidateFrame
(
)
;
}
}
#
endif
nsresult
PresShell
:
:
EventHandler
:
:
HandleEventWithTarget
(
WidgetEvent
*
aEvent
nsIFrame
*
aNewEventFrame
nsIContent
*
aNewEventContent
nsEventStatus
*
aEventStatus
bool
aIsHandlingNativeEvent
nsIContent
*
*
aTargetContent
nsIContent
*
aOverrideClickTarget
)
{
MOZ_ASSERT
(
aEvent
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aEvent
-
>
IsTrusted
(
)
)
;
#
if
DEBUG
MOZ_ASSERT
(
!
aNewEventFrame
|
|
aNewEventFrame
-
>
PresContext
(
)
-
>
GetPresShell
(
)
=
=
mPresShell
"
wrong
shell
"
)
;
if
(
aNewEventContent
)
{
Document
*
doc
=
aNewEventContent
-
>
GetComposedDoc
(
)
;
NS_ASSERTION
(
doc
"
event
for
content
that
isn
'
t
in
a
document
"
)
;
}
#
endif
NS_ENSURE_STATE
(
!
aNewEventContent
|
|
aNewEventContent
-
>
GetComposedDoc
(
)
=
=
GetDocument
(
)
)
;
AutoPointerEventTargetUpdater
updater
(
mPresShell
aEvent
aNewEventFrame
aTargetContent
)
;
AutoCurrentEventInfoSetter
eventInfoSetter
(
*
this
aNewEventFrame
aNewEventContent
)
;
nsresult
rv
=
HandleEventWithCurrentEventInfo
(
aEvent
aEventStatus
false
aOverrideClickTarget
)
;
return
rv
;
}
namespace
{
class
MOZ_RAII
AutoEventHandler
final
{
public
:
AutoEventHandler
(
WidgetEvent
*
aEvent
Document
*
aDocument
)
:
mEvent
(
aEvent
)
{
MOZ_ASSERT
(
mEvent
)
;
MOZ_ASSERT
(
mEvent
-
>
IsTrusted
(
)
)
;
if
(
mEvent
-
>
mMessage
=
=
eMouseDown
)
{
PresShell
:
:
ReleaseCapturingContent
(
)
;
PresShell
:
:
AllowMouseCapture
(
true
)
;
}
if
(
NeedsToUpdateCurrentMouseBtnState
(
)
)
{
WidgetMouseEvent
*
mouseEvent
=
mEvent
-
>
AsMouseEvent
(
)
;
if
(
mouseEvent
)
{
EventStateManager
:
:
sCurrentMouseBtn
=
mouseEvent
-
>
mButton
;
}
}
}
~
AutoEventHandler
(
)
{
if
(
mEvent
-
>
mMessage
=
=
eMouseDown
)
{
PresShell
:
:
AllowMouseCapture
(
false
)
;
}
if
(
NeedsToUpdateCurrentMouseBtnState
(
)
)
{
EventStateManager
:
:
sCurrentMouseBtn
=
MouseButton
:
:
eNotPressed
;
}
}
protected
:
bool
NeedsToUpdateCurrentMouseBtnState
(
)
const
{
return
mEvent
-
>
mMessage
=
=
eMouseDown
|
|
mEvent
-
>
mMessage
=
=
eMouseUp
|
|
mEvent
-
>
mMessage
=
=
ePointerDown
|
|
mEvent
-
>
mMessage
=
=
ePointerUp
;
}
WidgetEvent
*
mEvent
;
}
;
}
nsresult
PresShell
:
:
EventHandler
:
:
HandleEventWithCurrentEventInfo
(
WidgetEvent
*
aEvent
nsEventStatus
*
aEventStatus
bool
aIsHandlingNativeEvent
nsIContent
*
aOverrideClickTarget
)
{
MOZ_ASSERT
(
aEvent
)
;
MOZ_ASSERT
(
aEventStatus
)
;
RefPtr
<
EventStateManager
>
manager
=
GetPresContext
(
)
-
>
EventStateManager
(
)
;
if
(
NS_EVENT_NEEDS_FRAME
(
aEvent
)
&
&
!
mPresShell
-
>
GetCurrentEventFrame
(
)
&
&
!
mPresShell
-
>
GetCurrentEventContent
(
)
)
{
RecordEventHandlingResponsePerformance
(
aEvent
)
;
return
NS_OK
;
}
if
(
mPresShell
-
>
mCurrentEventContent
&
&
aEvent
-
>
IsTargetedAtFocusedWindow
(
)
)
{
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
fm
)
{
fm
-
>
FlushBeforeEventHandlingIfNeeded
(
mPresShell
-
>
mCurrentEventContent
)
;
}
}
bool
touchIsNew
=
false
;
if
(
!
PrepareToDispatchEvent
(
aEvent
aEventStatus
&
touchIsNew
)
)
{
return
NS_OK
;
}
RecordEventPreparationPerformance
(
aEvent
)
;
AutoHandlingUserInputStatePusher
userInpStatePusher
(
UserActivation
:
:
IsUserInteractionEvent
(
aEvent
)
aEvent
)
;
AutoEventHandler
eventHandler
(
aEvent
GetDocument
(
)
)
;
AutoPopupStatePusher
popupStatePusher
(
PopupBlocker
:
:
GetEventPopupControlState
(
aEvent
)
)
;
aEvent
-
>
mTarget
=
nullptr
;
HandlingTimeAccumulator
handlingTimeAccumulator
(
*
this
aEvent
)
;
nsresult
rv
=
DispatchEvent
(
manager
aEvent
touchIsNew
aEventStatus
aOverrideClickTarget
)
;
if
(
!
mPresShell
-
>
IsDestroying
(
)
&
&
aIsHandlingNativeEvent
)
{
manager
-
>
TryToFlushPendingNotificationsToIME
(
)
;
}
FinalizeHandlingEvent
(
aEvent
)
;
RecordEventHandlingResponsePerformance
(
aEvent
)
;
return
rv
;
}
nsresult
PresShell
:
:
EventHandler
:
:
DispatchEvent
(
EventStateManager
*
aEventStateManager
WidgetEvent
*
aEvent
bool
aTouchIsNew
nsEventStatus
*
aEventStatus
nsIContent
*
aOverrideClickTarget
)
{
MOZ_ASSERT
(
aEventStateManager
)
;
MOZ_ASSERT
(
aEvent
)
;
MOZ_ASSERT
(
aEventStatus
)
;
{
RefPtr
<
nsPresContext
>
presContext
=
GetPresContext
(
)
;
nsCOMPtr
<
nsIContent
>
eventContent
=
mPresShell
-
>
mCurrentEventContent
;
nsresult
rv
=
aEventStateManager
-
>
PreHandleEvent
(
presContext
aEvent
mPresShell
-
>
mCurrentEventFrame
eventContent
aEventStatus
aOverrideClickTarget
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
bool
wasHandlingKeyBoardEvent
=
nsContentUtils
:
:
IsHandlingKeyBoardEvent
(
)
;
if
(
aEvent
-
>
mClass
=
=
eKeyboardEventClass
)
{
nsContentUtils
:
:
SetIsHandlingKeyBoardEvent
(
true
)
;
}
if
(
aEvent
-
>
IsAllowedToDispatchDOMEvent
(
)
&
&
!
(
aEvent
-
>
PropagationStopped
(
)
&
&
aEvent
-
>
IsWaitingReplyFromRemoteProcess
(
)
)
)
{
MOZ_ASSERT
(
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
Somebody
changed
aEvent
to
cause
a
DOM
event
!
"
)
;
nsPresShellEventCB
eventCB
(
mPresShell
)
;
if
(
nsIFrame
*
target
=
mPresShell
-
>
GetCurrentEventFrame
(
)
)
{
if
(
target
-
>
OnlySystemGroupDispatch
(
aEvent
-
>
mMessage
)
)
{
aEvent
-
>
StopPropagation
(
)
;
}
}
if
(
aEvent
-
>
mClass
=
=
eTouchEventClass
)
{
DispatchTouchEventToDOM
(
aEvent
aEventStatus
&
eventCB
aTouchIsNew
)
;
}
else
{
DispatchEventToDOM
(
aEvent
aEventStatus
&
eventCB
)
;
}
}
nsContentUtils
:
:
SetIsHandlingKeyBoardEvent
(
wasHandlingKeyBoardEvent
)
;
if
(
mPresShell
-
>
IsDestroying
(
)
)
{
return
NS_OK
;
}
RefPtr
<
nsPresContext
>
presContext
=
GetPresContext
(
)
;
return
aEventStateManager
-
>
PostHandleEvent
(
presContext
aEvent
mPresShell
-
>
GetCurrentEventFrame
(
)
aEventStatus
aOverrideClickTarget
)
;
}
bool
PresShell
:
:
EventHandler
:
:
PrepareToDispatchEvent
(
WidgetEvent
*
aEvent
nsEventStatus
*
aEventStatus
bool
*
aTouchIsNew
)
{
MOZ_ASSERT
(
aEvent
-
>
IsTrusted
(
)
)
;
MOZ_ASSERT
(
aEventStatus
)
;
MOZ_ASSERT
(
aTouchIsNew
)
;
*
aTouchIsNew
=
false
;
if
(
aEvent
-
>
IsUserAction
(
)
)
{
mPresShell
-
>
mHasHandledUserInput
=
true
;
}
switch
(
aEvent
-
>
mMessage
)
{
case
eKeyPress
:
case
eKeyDown
:
case
eKeyUp
:
{
WidgetKeyboardEvent
*
keyboardEvent
=
aEvent
-
>
AsKeyboardEvent
(
)
;
MaybeHandleKeyboardEventBeforeDispatch
(
keyboardEvent
)
;
return
true
;
}
case
eMouseMove
:
{
bool
allowCapture
=
EventStateManager
:
:
GetActiveEventStateManager
(
)
&
&
GetPresContext
(
)
&
&
GetPresContext
(
)
-
>
EventStateManager
(
)
=
=
EventStateManager
:
:
GetActiveEventStateManager
(
)
;
PresShell
:
:
AllowMouseCapture
(
allowCapture
)
;
return
true
;
}
case
eDrop
:
{
nsCOMPtr
<
nsIDragSession
>
session
=
nsContentUtils
:
:
GetDragSession
(
)
;
if
(
session
)
{
bool
onlyChromeDrop
=
false
;
session
-
>
GetOnlyChromeDrop
(
&
onlyChromeDrop
)
;
if
(
onlyChromeDrop
)
{
aEvent
-
>
mFlags
.
mOnlyChromeDispatch
=
true
;
}
}
return
true
;
}
case
eContextMenu
:
{
WidgetMouseEvent
*
mouseEvent
=
aEvent
-
>
AsMouseEvent
(
)
;
if
(
mouseEvent
-
>
IsContextMenuKeyEvent
(
)
&
&
!
AdjustContextMenuKeyEvent
(
mouseEvent
)
)
{
return
false
;
}
if
(
mouseEvent
-
>
IsShift
(
)
)
{
aEvent
-
>
mFlags
.
mOnlyChromeDispatch
=
true
;
aEvent
-
>
mFlags
.
mRetargetToNonNativeAnonymous
=
true
;
}
return
true
;
}
case
eTouchStart
:
case
eTouchMove
:
case
eTouchEnd
:
case
eTouchCancel
:
case
eTouchPointerCancel
:
return
mPresShell
-
>
mTouchManager
.
PreHandleEvent
(
aEvent
aEventStatus
*
aTouchIsNew
mPresShell
-
>
mCurrentEventContent
)
;
default
:
return
true
;
}
}
void
PresShell
:
:
EventHandler
:
:
FinalizeHandlingEvent
(
WidgetEvent
*
aEvent
)
{
switch
(
aEvent
-
>
mMessage
)
{
case
eKeyPress
:
case
eKeyDown
:
case
eKeyUp
:
{
if
(
aEvent
-
>
AsKeyboardEvent
(
)
-
>
mKeyCode
=
=
NS_VK_ESCAPE
)
{
if
(
aEvent
-
>
mMessage
=
=
eKeyUp
)
{
mPresShell
-
>
mIsLastChromeOnlyEscapeKeyConsumed
=
false
;
}
else
{
if
(
aEvent
-
>
mFlags
.
mOnlyChromeDispatch
&
&
aEvent
-
>
mFlags
.
mDefaultPreventedByChrome
)
{
mPresShell
-
>
mIsLastChromeOnlyEscapeKeyConsumed
=
true
;
}
if
(
aEvent
-
>
mMessage
=
=
eKeyDown
&
&
!
aEvent
-
>
mFlags
.
mDefaultPrevented
)
{
if
(
Document
*
doc
=
GetDocument
(
)
)
{
doc
-
>
TryCancelDialog
(
)
;
}
}
}
}
if
(
aEvent
-
>
mMessage
=
=
eKeyDown
)
{
mPresShell
-
>
mIsLastKeyDownCanceled
=
aEvent
-
>
mFlags
.
mDefaultPrevented
;
}
return
;
}
case
eMouseUp
:
PresShell
:
:
ReleaseCapturingContent
(
)
;
return
;
case
eMouseMove
:
PresShell
:
:
AllowMouseCapture
(
false
)
;
return
;
case
eDrag
:
case
eDragEnd
:
case
eDragEnter
:
case
eDragExit
:
case
eDragLeave
:
case
eDragOver
:
case
eDrop
:
{
DataTransfer
*
dataTransfer
=
aEvent
-
>
AsDragEvent
(
)
-
>
mDataTransfer
;
if
(
dataTransfer
)
{
dataTransfer
-
>
Disconnect
(
)
;
}
return
;
}
default
:
return
;
}
}
void
PresShell
:
:
EventHandler
:
:
MaybeHandleKeyboardEventBeforeDispatch
(
WidgetKeyboardEvent
*
aKeyboardEvent
)
{
MOZ_ASSERT
(
aKeyboardEvent
)
;
if
(
aKeyboardEvent
-
>
mKeyCode
!
=
NS_VK_ESCAPE
)
{
return
;
}
Document
*
doc
=
mPresShell
-
>
GetCurrentEventContent
(
)
?
mPresShell
-
>
mCurrentEventContent
-
>
OwnerDoc
(
)
:
nullptr
;
Document
*
root
=
nsContentUtils
:
:
GetRootDocument
(
doc
)
;
if
(
root
&
&
root
-
>
GetFullscreenElement
(
)
)
{
aKeyboardEvent
-
>
PreventDefaultBeforeDispatch
(
CrossProcessForwarding
:
:
eStop
)
;
aKeyboardEvent
-
>
mFlags
.
mOnlyChromeDispatch
=
true
;
if
(
!
mPresShell
-
>
mIsLastChromeOnlyEscapeKeyConsumed
&
&
aKeyboardEvent
-
>
mMessage
=
=
eKeyUp
)
{
Document
:
:
AsyncExitFullscreen
(
nullptr
)
;
}
}
nsCOMPtr
<
Document
>
pointerLockedDoc
=
PointerLockManager
:
:
GetLockedDocument
(
)
;
if
(
!
mPresShell
-
>
mIsLastChromeOnlyEscapeKeyConsumed
&
&
pointerLockedDoc
)
{
aKeyboardEvent
-
>
PreventDefaultBeforeDispatch
(
CrossProcessForwarding
:
:
eStop
)
;
aKeyboardEvent
-
>
mFlags
.
mOnlyChromeDispatch
=
true
;
if
(
aKeyboardEvent
-
>
mMessage
=
=
eKeyUp
)
{
PointerLockManager
:
:
Unlock
(
)
;
}
}
}
void
PresShell
:
:
EventHandler
:
:
RecordEventPreparationPerformance
(
const
WidgetEvent
*
aEvent
)
{
MOZ_ASSERT
(
aEvent
)
;
switch
(
aEvent
-
>
mMessage
)
{
case
eKeyPress
:
case
eKeyDown
:
case
eKeyUp
:
if
(
aEvent
-
>
AsKeyboardEvent
(
)
-
>
ShouldInteractionTimeRecorded
(
)
)
{
GetPresContext
(
)
-
>
RecordInteractionTime
(
nsPresContext
:
:
InteractionType
:
:
KeyInteraction
aEvent
-
>
mTimeStamp
)
;
}
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
INPUT_EVENT_QUEUED_KEYBOARD_MS
aEvent
-
>
mTimeStamp
)
;
return
;
case
eMouseDown
:
case
eMouseUp
:
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
INPUT_EVENT_QUEUED_CLICK_MS
aEvent
-
>
mTimeStamp
)
;
[
[
fallthrough
]
]
;
case
ePointerDown
:
case
ePointerUp
:
GetPresContext
(
)
-
>
RecordInteractionTime
(
nsPresContext
:
:
InteractionType
:
:
ClickInteraction
aEvent
-
>
mTimeStamp
)
;
return
;
case
eMouseMove
:
if
(
aEvent
-
>
mFlags
.
mHandledByAPZ
)
{
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
INPUT_EVENT_QUEUED_APZ_MOUSE_MOVE_MS
aEvent
-
>
mTimeStamp
)
;
}
GetPresContext
(
)
-
>
RecordInteractionTime
(
nsPresContext
:
:
InteractionType
:
:
MouseMoveInteraction
aEvent
-
>
mTimeStamp
)
;
return
;
case
eWheel
:
if
(
aEvent
-
>
mFlags
.
mHandledByAPZ
)
{
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
INPUT_EVENT_QUEUED_APZ_WHEEL_MS
aEvent
-
>
mTimeStamp
)
;
}
return
;
case
eTouchMove
:
if
(
aEvent
-
>
mFlags
.
mHandledByAPZ
)
{
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
INPUT_EVENT_QUEUED_APZ_TOUCH_MOVE_MS
aEvent
-
>
mTimeStamp
)
;
}
return
;
default
:
return
;
}
}
void
PresShell
:
:
EventHandler
:
:
RecordEventHandlingResponsePerformance
(
const
WidgetEvent
*
aEvent
)
{
if
(
!
Telemetry
:
:
CanRecordBase
(
)
|
|
aEvent
-
>
mTimeStamp
.
IsNull
(
)
|
|
aEvent
-
>
mTimeStamp
<
=
mPresShell
-
>
mLastOSWake
|
|
!
aEvent
-
>
AsInputEvent
(
)
)
{
return
;
}
TimeStamp
now
=
TimeStamp
:
:
Now
(
)
;
double
millis
=
(
now
-
aEvent
-
>
mTimeStamp
)
.
ToMilliseconds
(
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
INPUT_EVENT_RESPONSE_MS
millis
)
;
if
(
GetDocument
(
)
&
&
GetDocument
(
)
-
>
GetReadyStateEnum
(
)
!
=
Document
:
:
READYSTATE_COMPLETE
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
LOAD_INPUT_EVENT_RESPONSE_MS
millis
)
;
}
if
(
!
sLastInputProcessed
|
|
sLastInputProcessed
<
aEvent
-
>
mTimeStamp
)
{
if
(
sLastInputProcessed
)
{
double
lastMillis
=
(
sLastInputProcessed
-
sLastInputCreated
)
.
ToMilliseconds
(
)
;
Telemetry
:
:
Accumulate
(
Telemetry
:
:
INPUT_EVENT_RESPONSE_COALESCED_MS
lastMillis
)
;
if
(
MOZ_UNLIKELY
(
!
PresShell
:
:
sProcessInteractable
)
)
{
if
(
XRE_IsContentProcess
(
)
&
&
GetDocument
(
)
&
&
GetDocument
(
)
-
>
IsTopLevelContentDocument
(
)
)
{
switch
(
GetDocument
(
)
-
>
GetReadyStateEnum
(
)
)
{
case
Document
:
:
READYSTATE_INTERACTIVE
:
case
Document
:
:
READYSTATE_COMPLETE
:
PresShell
:
:
sProcessInteractable
=
true
;
break
;
default
:
break
;
}
}
}
if
(
MOZ_LIKELY
(
PresShell
:
:
sProcessInteractable
)
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
INPUT_EVENT_RESPONSE_POST_STARTUP_MS
lastMillis
)
;
}
else
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
INPUT_EVENT_RESPONSE_STARTUP_MS
lastMillis
)
;
}
}
sLastInputCreated
=
aEvent
-
>
mTimeStamp
;
}
else
if
(
aEvent
-
>
mTimeStamp
<
sLastInputCreated
)
{
sLastInputCreated
=
aEvent
-
>
mTimeStamp
;
}
sLastInputProcessed
=
now
;
}
nsIPrincipal
*
PresShell
:
:
EventHandler
:
:
GetDocumentPrincipalToCompareWithBlacklist
(
PresShell
&
aPresShell
)
{
nsPresContext
*
presContext
=
aPresShell
.
GetPresContext
(
)
;
if
(
NS_WARN_IF
(
!
presContext
)
)
{
return
nullptr
;
}
return
presContext
-
>
Document
(
)
-
>
GetPrincipalForPrefBasedHacks
(
)
;
}
nsresult
PresShell
:
:
EventHandler
:
:
DispatchEventToDOM
(
WidgetEvent
*
aEvent
nsEventStatus
*
aEventStatus
nsPresShellEventCB
*
aEventCB
)
{
nsresult
rv
=
NS_OK
;
nsCOMPtr
<
nsINode
>
eventTarget
=
mPresShell
-
>
mCurrentEventContent
;
nsPresShellEventCB
*
eventCBPtr
=
aEventCB
;
if
(
!
eventTarget
)
{
nsCOMPtr
<
nsIContent
>
targetContent
;
if
(
mPresShell
-
>
mCurrentEventFrame
)
{
rv
=
mPresShell
-
>
mCurrentEventFrame
-
>
GetContentForEvent
(
aEvent
getter_AddRefs
(
targetContent
)
)
;
}
if
(
NS_SUCCEEDED
(
rv
)
&
&
targetContent
)
{
eventTarget
=
targetContent
;
}
else
if
(
GetDocument
(
)
)
{
eventTarget
=
GetDocument
(
)
;
eventCBPtr
=
nullptr
;
}
}
if
(
eventTarget
)
{
if
(
aEvent
-
>
IsBlockedForFingerprintingResistance
(
)
)
{
aEvent
-
>
mFlags
.
mOnlySystemGroupDispatchInContent
=
true
;
}
else
if
(
aEvent
-
>
mMessage
=
=
eKeyPress
)
{
if
(
!
mPresShell
-
>
mInitializedWithKeyPressEventDispatchingBlacklist
)
{
mPresShell
-
>
mInitializedWithKeyPressEventDispatchingBlacklist
=
true
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
GetDocumentPrincipalToCompareWithBlacklist
(
*
mPresShell
)
;
if
(
principal
)
{
mPresShell
-
>
mForceDispatchKeyPressEventsForNonPrintableKeys
=
principal
-
>
IsURIInPrefList
(
"
dom
.
keyboardevent
.
keypress
.
hack
.
dispatch_non_printable_
"
"
keys
"
)
|
|
principal
-
>
IsURIInPrefList
(
"
dom
.
keyboardevent
.
keypress
.
hack
.
"
"
dispatch_non_printable_keys
.
addl
"
)
;
mPresShell
-
>
mForceUseLegacyKeyCodeAndCharCodeValues
|
=
principal
-
>
IsURIInPrefList
(
"
dom
.
keyboardevent
.
keypress
.
hack
.
"
"
use_legacy_keycode_and_charcode
"
)
|
|
principal
-
>
IsURIInPrefList
(
"
dom
.
keyboardevent
.
keypress
.
hack
.
"
"
use_legacy_keycode_and_charcode
.
addl
"
)
;
}
}
if
(
mPresShell
-
>
mForceDispatchKeyPressEventsForNonPrintableKeys
)
{
aEvent
-
>
mFlags
.
mOnlySystemGroupDispatchInContent
=
false
;
}
if
(
mPresShell
-
>
mForceUseLegacyKeyCodeAndCharCodeValues
)
{
aEvent
-
>
AsKeyboardEvent
(
)
-
>
mUseLegacyKeyCodeAndCharCodeValues
=
true
;
}
}
else
if
(
aEvent
-
>
mMessage
=
=
eMouseUp
)
{
if
(
!
mPresShell
-
>
mInitializedWithClickEventDispatchingBlacklist
)
{
mPresShell
-
>
mInitializedWithClickEventDispatchingBlacklist
=
true
;
nsCOMPtr
<
nsIPrincipal
>
principal
=
GetDocumentPrincipalToCompareWithBlacklist
(
*
mPresShell
)
;
if
(
principal
)
{
mPresShell
-
>
mForceUseLegacyNonPrimaryDispatch
=
principal
-
>
IsURIInPrefList
(
"
dom
.
mouseevent
.
click
.
hack
.
use_legacy_non
-
primary_dispatch
"
)
;
}
}
if
(
mPresShell
-
>
mForceUseLegacyNonPrimaryDispatch
)
{
aEvent
-
>
AsMouseEvent
(
)
-
>
mUseLegacyNonPrimaryDispatch
=
true
;
}
}
if
(
aEvent
-
>
mClass
=
=
eCompositionEventClass
)
{
RefPtr
<
nsPresContext
>
presContext
=
GetPresContext
(
)
;
RefPtr
<
BrowserParent
>
browserParent
=
IMEStateManager
:
:
GetActiveBrowserParent
(
)
;
IMEStateManager
:
:
DispatchCompositionEvent
(
eventTarget
presContext
browserParent
aEvent
-
>
AsCompositionEvent
(
)
aEventStatus
eventCBPtr
)
;
}
else
{
RefPtr
<
nsPresContext
>
presContext
=
GetPresContext
(
)
;
EventDispatcher
:
:
Dispatch
(
eventTarget
presContext
aEvent
nullptr
aEventStatus
eventCBPtr
)
;
}
}
return
rv
;
}
void
PresShell
:
:
EventHandler
:
:
DispatchTouchEventToDOM
(
WidgetEvent
*
aEvent
nsEventStatus
*
aEventStatus
nsPresShellEventCB
*
aEventCB
bool
aTouchIsNew
)
{
bool
canPrevent
=
(
aEvent
-
>
mMessage
=
=
eTouchStart
)
|
|
(
aEvent
-
>
mMessage
=
=
eTouchMove
&
&
aTouchIsNew
)
|
|
(
aEvent
-
>
mMessage
=
=
eTouchEnd
)
;
bool
preventDefault
=
false
;
nsEventStatus
tmpStatus
=
nsEventStatus_eIgnore
;
WidgetTouchEvent
*
touchEvent
=
aEvent
-
>
AsTouchEvent
(
)
;
for
(
dom
:
:
Touch
*
touch
:
touchEvent
-
>
mTouches
)
{
MOZ_ASSERT
(
!
touch
-
>
mIsTouchEventSuppressed
)
;
if
(
!
touch
|
|
!
touch
-
>
mChanged
)
{
continue
;
}
nsCOMPtr
<
EventTarget
>
targetPtr
=
touch
-
>
mTarget
;
nsCOMPtr
<
nsIContent
>
content
=
do_QueryInterface
(
targetPtr
)
;
if
(
!
content
)
{
continue
;
}
Document
*
doc
=
content
-
>
OwnerDoc
(
)
;
nsIContent
*
capturingContent
=
PresShell
:
:
GetCapturingContent
(
)
;
if
(
capturingContent
)
{
if
(
capturingContent
-
>
OwnerDoc
(
)
!
=
doc
)
{
continue
;
}
content
=
capturingContent
;
}
MOZ_ASSERT
(
touchEvent
-
>
IsTrusted
(
)
)
;
WidgetTouchEvent
newEvent
(
true
touchEvent
-
>
mMessage
touchEvent
-
>
mWidget
)
;
newEvent
.
AssignTouchEventData
(
*
touchEvent
false
)
;
newEvent
.
mTarget
=
targetPtr
;
newEvent
.
mFlags
.
mHandledByAPZ
=
touchEvent
-
>
mFlags
.
mHandledByAPZ
;
RefPtr
<
PresShell
>
contentPresShell
;
if
(
doc
=
=
GetDocument
(
)
)
{
contentPresShell
=
doc
-
>
GetPresShell
(
)
;
if
(
contentPresShell
)
{
contentPresShell
-
>
PushCurrentEventInfo
(
content
-
>
GetPrimaryFrame
(
)
content
)
;
}
}
nsPresContext
*
context
=
doc
-
>
GetPresContext
(
)
;
if
(
!
context
)
{
if
(
contentPresShell
)
{
contentPresShell
-
>
PopCurrentEventInfo
(
)
;
}
continue
;
}
tmpStatus
=
nsEventStatus_eIgnore
;
EventDispatcher
:
:
Dispatch
(
targetPtr
context
&
newEvent
nullptr
&
tmpStatus
aEventCB
)
;
if
(
nsEventStatus_eConsumeNoDefault
=
=
tmpStatus
|
|
newEvent
.
mFlags
.
mMultipleActionsPrevented
)
{
preventDefault
=
true
;
}
if
(
newEvent
.
mFlags
.
mMultipleActionsPrevented
)
{
touchEvent
-
>
mFlags
.
mMultipleActionsPrevented
=
true
;
}
if
(
contentPresShell
)
{
contentPresShell
-
>
PopCurrentEventInfo
(
)
;
}
}
if
(
preventDefault
&
&
canPrevent
)
{
*
aEventStatus
=
nsEventStatus_eConsumeNoDefault
;
}
else
{
*
aEventStatus
=
nsEventStatus_eIgnore
;
}
}
nsresult
PresShell
:
:
HandleDOMEventWithTarget
(
nsIContent
*
aTargetContent
WidgetEvent
*
aEvent
nsEventStatus
*
aStatus
)
{
nsresult
rv
=
NS_OK
;
PushCurrentEventInfo
(
nullptr
aTargetContent
)
;
nsCOMPtr
<
nsISupports
>
container
=
mPresContext
-
>
GetContainerWeak
(
)
;
if
(
container
)
{
rv
=
EventDispatcher
:
:
Dispatch
(
aTargetContent
mPresContext
aEvent
nullptr
aStatus
)
;
}
PopCurrentEventInfo
(
)
;
return
rv
;
}
nsresult
PresShell
:
:
HandleDOMEventWithTarget
(
nsIContent
*
aTargetContent
Event
*
aEvent
nsEventStatus
*
aStatus
)
{
nsresult
rv
=
NS_OK
;
PushCurrentEventInfo
(
nullptr
aTargetContent
)
;
nsCOMPtr
<
nsISupports
>
container
=
mPresContext
-
>
GetContainerWeak
(
)
;
if
(
container
)
{
rv
=
EventDispatcher
:
:
DispatchDOMEvent
(
aTargetContent
nullptr
aEvent
mPresContext
aStatus
)
;
}
PopCurrentEventInfo
(
)
;
return
rv
;
}
bool
PresShell
:
:
EventHandler
:
:
AdjustContextMenuKeyEvent
(
WidgetMouseEvent
*
aMouseEvent
)
{
#
ifdef
MOZ_XUL
nsXULPopupManager
*
pm
=
nsXULPopupManager
:
:
GetInstance
(
)
;
if
(
pm
)
{
nsIFrame
*
popupFrame
=
pm
-
>
GetTopPopup
(
ePopupTypeMenu
)
;
if
(
popupFrame
)
{
nsIFrame
*
itemFrame
=
(
static_cast
<
nsMenuPopupFrame
*
>
(
popupFrame
)
)
-
>
GetCurrentMenuItem
(
)
;
if
(
!
itemFrame
)
itemFrame
=
popupFrame
;
nsCOMPtr
<
nsIWidget
>
widget
=
popupFrame
-
>
GetNearestWidget
(
)
;
aMouseEvent
-
>
mWidget
=
widget
;
LayoutDeviceIntPoint
widgetPoint
=
widget
-
>
WidgetToScreenOffset
(
)
;
aMouseEvent
-
>
mRefPoint
=
LayoutDeviceIntPoint
:
:
FromAppUnitsToNearest
(
itemFrame
-
>
GetScreenRectInAppUnits
(
)
.
BottomLeft
(
)
itemFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
-
widgetPoint
;
mPresShell
-
>
mCurrentEventContent
=
itemFrame
-
>
GetContent
(
)
;
mPresShell
-
>
mCurrentEventFrame
=
itemFrame
;
return
true
;
}
}
#
endif
nsRootPresContext
*
rootPC
=
GetPresContext
(
)
-
>
GetRootPresContext
(
)
;
aMouseEvent
-
>
mRefPoint
=
LayoutDeviceIntPoint
(
0
0
)
;
if
(
rootPC
)
{
rootPC
-
>
PresShell
(
)
-
>
GetViewManager
(
)
-
>
GetRootWidget
(
getter_AddRefs
(
aMouseEvent
-
>
mWidget
)
)
;
if
(
aMouseEvent
-
>
mWidget
)
{
nsPoint
offset
(
0
0
)
;
nsIFrame
*
rootFrame
=
FrameConstructor
(
)
-
>
GetRootFrame
(
)
;
if
(
rootFrame
)
{
nsView
*
view
=
rootFrame
-
>
GetClosestView
(
&
offset
)
;
offset
+
=
view
-
>
GetOffsetToWidget
(
aMouseEvent
-
>
mWidget
)
;
aMouseEvent
-
>
mRefPoint
=
LayoutDeviceIntPoint
:
:
FromAppUnitsToNearest
(
offset
GetPresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
}
}
}
else
{
aMouseEvent
-
>
mWidget
=
nullptr
;
}
LayoutDeviceIntPoint
caretPoint
;
if
(
PrepareToUseCaretPosition
(
MOZ_KnownLive
(
aMouseEvent
-
>
mWidget
)
caretPoint
)
)
{
int32_t
devPixelRatio
=
GetPresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
caretPoint
=
LayoutDeviceIntPoint
:
:
FromAppUnitsToNearest
(
ViewportUtils
:
:
LayoutToVisual
(
LayoutDeviceIntPoint
:
:
ToAppUnits
(
caretPoint
devPixelRatio
)
GetPresContext
(
)
-
>
PresShell
(
)
)
devPixelRatio
)
;
aMouseEvent
-
>
mRefPoint
=
caretPoint
;
return
true
;
}
RefPtr
<
Element
>
currentFocus
;
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
fm
)
{
currentFocus
=
fm
-
>
GetFocusedElement
(
)
;
}
if
(
currentFocus
)
{
nsCOMPtr
<
nsIContent
>
currentPointElement
;
GetCurrentItemAndPositionForElement
(
currentFocus
getter_AddRefs
(
currentPointElement
)
aMouseEvent
-
>
mRefPoint
MOZ_KnownLive
(
aMouseEvent
-
>
mWidget
)
)
;
if
(
currentPointElement
)
{
mPresShell
-
>
mCurrentEventContent
=
currentPointElement
;
mPresShell
-
>
mCurrentEventFrame
=
nullptr
;
mPresShell
-
>
GetCurrentEventFrame
(
)
;
}
}
return
true
;
}
bool
PresShell
:
:
EventHandler
:
:
PrepareToUseCaretPosition
(
nsIWidget
*
aEventWidget
LayoutDeviceIntPoint
&
aTargetPt
)
{
nsresult
rv
;
RefPtr
<
nsCaret
>
caret
=
mPresShell
-
>
GetCaret
(
)
;
NS_ENSURE_TRUE
(
caret
false
)
;
bool
caretVisible
=
caret
-
>
IsVisible
(
)
;
if
(
!
caretVisible
)
return
false
;
Selection
*
domSelection
=
caret
-
>
GetSelection
(
)
;
NS_ENSURE_TRUE
(
domSelection
false
)
;
nsIFrame
*
frame
=
nullptr
;
nsINode
*
node
=
domSelection
-
>
GetFocusNode
(
)
;
NS_ENSURE_TRUE
(
node
false
)
;
nsCOMPtr
<
nsIContent
>
content
=
nsIContent
:
:
FromNode
(
node
)
;
if
(
content
)
{
nsIContent
*
nonNative
=
content
-
>
FindFirstNonChromeOnlyAccessContent
(
)
;
content
=
nonNative
;
}
if
(
content
)
{
rv
=
MOZ_KnownLive
(
mPresShell
)
-
>
ScrollContentIntoView
(
content
ScrollAxis
(
kScrollMinimum
WhenToScroll
:
:
IfNotVisible
)
ScrollAxis
(
kScrollMinimum
WhenToScroll
:
:
IfNotVisible
)
ScrollFlags
:
:
ScrollOverflowHidden
|
ScrollFlags
:
:
IgnoreMarginAndPadding
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
frame
=
content
-
>
GetPrimaryFrame
(
)
;
NS_WARNING_ASSERTION
(
frame
"
No
frame
for
focused
content
?
"
)
;
}
nsCOMPtr
<
nsISelectionController
>
selCon
;
if
(
frame
)
frame
-
>
GetSelectionController
(
GetPresContext
(
)
getter_AddRefs
(
selCon
)
)
;
else
selCon
=
static_cast
<
nsISelectionController
*
>
(
mPresShell
)
;
if
(
selCon
)
{
rv
=
selCon
-
>
ScrollSelectionIntoView
(
nsISelectionController
:
:
SELECTION_NORMAL
nsISelectionController
:
:
SELECTION_FOCUS_REGION
nsISelectionController
:
:
SCROLL_SYNCHRONOUS
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
}
nsPresContext
*
presContext
=
GetPresContext
(
)
;
nsRect
caretCoords
;
nsIFrame
*
caretFrame
=
caret
-
>
GetGeometry
(
&
caretCoords
)
;
if
(
!
caretFrame
)
return
false
;
nsPoint
viewOffset
;
nsView
*
view
=
caretFrame
-
>
GetClosestView
(
&
viewOffset
)
;
if
(
!
view
)
return
false
;
if
(
aEventWidget
)
{
viewOffset
+
=
view
-
>
GetOffsetToWidget
(
aEventWidget
)
;
}
caretCoords
.
MoveBy
(
viewOffset
)
;
aTargetPt
.
x
=
presContext
-
>
AppUnitsToDevPixels
(
caretCoords
.
x
+
caretCoords
.
width
)
;
aTargetPt
.
y
=
presContext
-
>
AppUnitsToDevPixels
(
caretCoords
.
y
+
caretCoords
.
height
)
;
aTargetPt
.
y
-
=
1
;
return
true
;
}
void
PresShell
:
:
EventHandler
:
:
GetCurrentItemAndPositionForElement
(
Element
*
aFocusedElement
nsIContent
*
*
aTargetToUse
LayoutDeviceIntPoint
&
aTargetPt
nsIWidget
*
aRootWidget
)
{
nsCOMPtr
<
nsIContent
>
focusedContent
=
aFocusedElement
;
MOZ_KnownLive
(
mPresShell
)
-
>
ScrollContentIntoView
(
focusedContent
ScrollAxis
(
)
ScrollAxis
(
)
ScrollFlags
:
:
ScrollOverflowHidden
)
;
nsPresContext
*
presContext
=
GetPresContext
(
)
;
bool
istree
=
false
checkLineHeight
=
true
;
nscoord
extraTreeY
=
0
;
#
ifdef
MOZ_XUL
nsCOMPtr
<
Element
>
item
;
nsCOMPtr
<
nsIDOMXULMultiSelectControlElement
>
multiSelect
=
aFocusedElement
-
>
AsXULMultiSelectControl
(
)
;
if
(
multiSelect
)
{
checkLineHeight
=
false
;
int32_t
currentIndex
;
multiSelect
-
>
GetCurrentIndex
(
&
currentIndex
)
;
if
(
currentIndex
>
=
0
)
{
RefPtr
<
XULTreeElement
>
tree
=
XULTreeElement
:
:
FromNode
(
focusedContent
)
;
if
(
tree
)
{
tree
-
>
EnsureRowIsVisible
(
currentIndex
)
;
int32_t
firstVisibleRow
=
tree
-
>
GetFirstVisibleRow
(
)
;
int32_t
rowHeight
=
tree
-
>
RowHeight
(
)
;
extraTreeY
+
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
(
currentIndex
-
firstVisibleRow
+
1
)
*
rowHeight
)
;
istree
=
true
;
RefPtr
<
nsTreeColumns
>
cols
=
tree
-
>
GetColumns
(
)
;
if
(
cols
)
{
nsTreeColumn
*
col
=
cols
-
>
GetFirstColumn
(
)
;
if
(
col
)
{
RefPtr
<
Element
>
colElement
=
col
-
>
Element
(
)
;
nsIFrame
*
frame
=
colElement
-
>
GetPrimaryFrame
(
)
;
if
(
frame
)
{
extraTreeY
+
=
frame
-
>
GetSize
(
)
.
height
;
}
}
}
}
else
{
multiSelect
-
>
GetCurrentItem
(
getter_AddRefs
(
item
)
)
;
}
}
}
else
{
nsCOMPtr
<
nsIDOMXULMenuListElement
>
menulist
=
aFocusedElement
-
>
AsXULMenuList
(
)
;
if
(
!
menulist
)
{
nsCOMPtr
<
nsIDOMXULSelectControlElement
>
select
=
aFocusedElement
-
>
AsXULSelectControl
(
)
;
if
(
select
)
{
checkLineHeight
=
false
;
select
-
>
GetSelectedItem
(
getter_AddRefs
(
item
)
)
;
}
}
}
if
(
item
)
{
focusedContent
=
item
;
}
#
endif
nsIFrame
*
frame
=
focusedContent
-
>
GetPrimaryFrame
(
)
;
if
(
frame
)
{
NS_ASSERTION
(
frame
-
>
PresContext
(
)
=
=
GetPresContext
(
)
"
handling
event
for
focused
content
that
is
not
in
our
document
?
"
)
;
nsPoint
frameOrigin
(
0
0
)
;
nsView
*
view
=
frame
-
>
GetClosestView
(
&
frameOrigin
)
;
NS_ASSERTION
(
view
"
No
view
for
frame
"
)
;
if
(
aRootWidget
)
{
frameOrigin
+
=
view
-
>
GetOffsetToWidget
(
aRootWidget
)
;
}
nscoord
extra
=
0
;
if
(
!
istree
)
{
extra
=
frame
-
>
GetSize
(
)
.
height
;
if
(
checkLineHeight
)
{
nsIScrollableFrame
*
scrollFrame
=
nsLayoutUtils
:
:
GetNearestScrollableFrame
(
frame
)
;
if
(
scrollFrame
)
{
nsSize
scrollAmount
=
scrollFrame
-
>
GetLineScrollAmount
(
)
;
nsIFrame
*
f
=
do_QueryFrame
(
scrollFrame
)
;
int32_t
APD
=
presContext
-
>
AppUnitsPerDevPixel
(
)
;
int32_t
scrollAPD
=
f
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
scrollAmount
=
scrollAmount
.
ScaleToOtherAppUnits
(
scrollAPD
APD
)
;
if
(
extra
>
scrollAmount
.
height
)
{
extra
=
scrollAmount
.
height
;
}
}
}
}
aTargetPt
.
x
=
presContext
-
>
AppUnitsToDevPixels
(
frameOrigin
.
x
)
;
aTargetPt
.
y
=
presContext
-
>
AppUnitsToDevPixels
(
frameOrigin
.
y
+
extra
+
extraTreeY
)
;
}
NS_IF_ADDREF
(
*
aTargetToUse
=
focusedContent
)
;
}
bool
PresShell
:
:
ShouldIgnoreInvalidation
(
)
{
return
mPaintingSuppressed
|
|
!
mIsActive
|
|
mIsNeverPainting
;
}
void
PresShell
:
:
WillPaint
(
)
{
if
(
!
mIsActive
|
|
mPaintingSuppressed
|
|
!
IsVisible
(
)
)
{
return
;
}
nsRootPresContext
*
rootPresContext
=
mPresContext
-
>
GetRootPresContext
(
)
;
if
(
!
rootPresContext
)
{
return
;
}
rootPresContext
-
>
FlushWillPaintObservers
(
)
;
if
(
mIsDestroying
)
return
;
FlushPendingNotifications
(
ChangesToFlush
(
FlushType
:
:
InterruptibleLayout
false
)
)
;
}
void
PresShell
:
:
DidPaintWindow
(
)
{
nsRootPresContext
*
rootPresContext
=
mPresContext
-
>
GetRootPresContext
(
)
;
if
(
rootPresContext
!
=
mPresContext
)
{
return
;
}
if
(
!
mHasReceivedPaintMessage
)
{
mHasReceivedPaintMessage
=
true
;
nsCOMPtr
<
nsIObserverService
>
obsvc
=
services
:
:
GetObserverService
(
)
;
if
(
obsvc
&
&
mDocument
)
{
nsPIDOMWindowOuter
*
window
=
mDocument
-
>
GetWindow
(
)
;
nsCOMPtr
<
nsIDOMChromeWindow
>
chromeWin
(
do_QueryInterface
(
window
)
)
;
if
(
chromeWin
)
{
obsvc
-
>
NotifyObservers
(
chromeWin
"
widget
-
first
-
paint
"
nullptr
)
;
}
}
}
}
bool
PresShell
:
:
IsVisible
(
)
const
{
if
(
!
mIsActive
|
|
!
mViewManager
)
return
false
;
nsView
*
view
=
mViewManager
-
>
GetRootView
(
)
;
if
(
!
view
)
return
true
;
view
=
view
-
>
GetParent
(
)
;
if
(
!
view
)
return
true
;
view
=
view
-
>
GetParent
(
)
;
if
(
!
view
)
return
true
;
nsIFrame
*
frame
=
view
-
>
GetFrame
(
)
;
if
(
!
frame
)
return
true
;
return
frame
-
>
IsVisibleConsideringAncestors
(
nsIFrame
:
:
VISIBILITY_CROSS_CHROME_CONTENT_BOUNDARY
)
;
}
void
PresShell
:
:
SuppressDisplayport
(
bool
aEnabled
)
{
if
(
aEnabled
)
{
mActiveSuppressDisplayport
+
+
;
}
else
if
(
mActiveSuppressDisplayport
>
0
)
{
bool
isSuppressed
=
IsDisplayportSuppressed
(
)
;
mActiveSuppressDisplayport
-
-
;
if
(
isSuppressed
&
&
!
IsDisplayportSuppressed
(
)
)
{
if
(
nsIFrame
*
rootFrame
=
mFrameConstructor
-
>
GetRootFrame
(
)
)
{
rootFrame
-
>
SchedulePaint
(
)
;
}
}
}
}
static
bool
sDisplayPortSuppressionRespected
=
true
;
void
PresShell
:
:
RespectDisplayportSuppression
(
bool
aEnabled
)
{
bool
isSuppressed
=
IsDisplayportSuppressed
(
)
;
sDisplayPortSuppressionRespected
=
aEnabled
;
if
(
isSuppressed
&
&
!
IsDisplayportSuppressed
(
)
)
{
if
(
nsIFrame
*
rootFrame
=
mFrameConstructor
-
>
GetRootFrame
(
)
)
{
rootFrame
-
>
SchedulePaint
(
)
;
}
}
}
bool
PresShell
:
:
IsDisplayportSuppressed
(
)
{
return
sDisplayPortSuppressionRespected
&
&
mActiveSuppressDisplayport
>
0
;
}
static
CallState
FreezeSubDocument
(
Document
&
aDocument
)
{
if
(
PresShell
*
presShell
=
aDocument
.
GetPresShell
(
)
)
{
presShell
-
>
Freeze
(
)
;
}
return
CallState
:
:
Continue
;
}
void
PresShell
:
:
Freeze
(
bool
aIncludeSubDocuments
)
{
mUpdateApproximateFrameVisibilityEvent
.
Revoke
(
)
;
MaybeReleaseCapturingContent
(
)
;
if
(
mCaret
)
{
SetCaretEnabled
(
false
)
;
}
mPaintingSuppressed
=
true
;
if
(
aIncludeSubDocuments
&
&
mDocument
)
{
mDocument
-
>
EnumerateSubDocuments
(
FreezeSubDocument
)
;
}
nsPresContext
*
presContext
=
GetPresContext
(
)
;
if
(
presContext
)
{
presContext
-
>
DisableInteractionTimeRecording
(
)
;
if
(
presContext
-
>
RefreshDriver
(
)
-
>
GetPresContext
(
)
=
=
presContext
)
{
presContext
-
>
RefreshDriver
(
)
-
>
Freeze
(
)
;
}
}
mFrozen
=
true
;
if
(
mDocument
)
{
UpdateImageLockingState
(
)
;
}
}
void
PresShell
:
:
FireOrClearDelayedEvents
(
bool
aFireEvents
)
{
mNoDelayedMouseEvents
=
false
;
mNoDelayedKeyEvents
=
false
;
if
(
!
aFireEvents
)
{
mDelayedEvents
.
Clear
(
)
;
return
;
}
if
(
mDocument
)
{
RefPtr
<
Document
>
doc
=
mDocument
;
while
(
!
mIsDestroying
&
&
mDelayedEvents
.
Length
(
)
&
&
!
doc
-
>
EventHandlingSuppressed
(
)
)
{
UniquePtr
<
DelayedEvent
>
ev
=
std
:
:
move
(
mDelayedEvents
[
0
]
)
;
mDelayedEvents
.
RemoveElementAt
(
0
)
;
if
(
ev
-
>
IsKeyPressEvent
(
)
&
&
mIsLastKeyDownCanceled
)
{
continue
;
}
ev
-
>
Dispatch
(
)
;
}
if
(
!
doc
-
>
EventHandlingSuppressed
(
)
)
{
mDelayedEvents
.
Clear
(
)
;
}
}
}
void
PresShell
:
:
Thaw
(
bool
aIncludeSubDocuments
)
{
nsPresContext
*
presContext
=
GetPresContext
(
)
;
if
(
presContext
&
&
presContext
-
>
RefreshDriver
(
)
-
>
GetPresContext
(
)
=
=
presContext
)
{
presContext
-
>
RefreshDriver
(
)
-
>
Thaw
(
)
;
}
if
(
aIncludeSubDocuments
&
&
mDocument
)
{
mDocument
-
>
EnumerateSubDocuments
(
[
]
(
Document
&
aSubDoc
)
{
if
(
PresShell
*
presShell
=
aSubDoc
.
GetPresShell
(
)
)
{
presShell
-
>
Thaw
(
)
;
}
return
CallState
:
:
Continue
;
}
)
;
}
QueryIsActive
(
)
;
mFrozen
=
false
;
UpdateImageLockingState
(
)
;
UnsuppressPainting
(
)
;
}
void
PresShell
:
:
MaybeScheduleReflow
(
)
{
ASSERT_REFLOW_SCHEDULED_STATE
(
)
;
if
(
mObservingLayoutFlushes
|
|
mIsDestroying
|
|
mIsReflowing
|
|
mDirtyRoots
.
IsEmpty
(
)
)
return
;
if
(
!
mPresContext
-
>
HasPendingInterrupt
(
)
|
|
!
ScheduleReflowOffTimer
(
)
)
{
ScheduleReflow
(
)
;
}
ASSERT_REFLOW_SCHEDULED_STATE
(
)
;
}
void
PresShell
:
:
ScheduleReflow
(
)
{
ASSERT_REFLOW_SCHEDULED_STATE
(
)
;
DoObserveLayoutFlushes
(
)
;
ASSERT_REFLOW_SCHEDULED_STATE
(
)
;
}
void
PresShell
:
:
WillCauseReflow
(
)
{
nsContentUtils
:
:
AddScriptBlocker
(
)
;
+
+
mChangeNestCount
;
}
void
PresShell
:
:
DidCauseReflow
(
)
{
NS_ASSERTION
(
mChangeNestCount
!
=
0
"
Unexpected
call
to
DidCauseReflow
(
)
"
)
;
-
-
mChangeNestCount
;
nsContentUtils
:
:
RemoveScriptBlocker
(
)
;
}
void
PresShell
:
:
WillDoReflow
(
)
{
mDocument
-
>
FlushUserFontSet
(
)
;
mPresContext
-
>
FlushCounterStyles
(
)
;
mPresContext
-
>
FlushFontFeatureValues
(
)
;
mLastReflowStart
=
GetPerformanceNowUnclamped
(
)
;
}
void
PresShell
:
:
DidDoReflow
(
bool
aInterruptible
)
{
HandlePostedReflowCallbacks
(
aInterruptible
)
;
if
(
mIsDestroying
)
{
return
;
}
nsAutoScriptBlocker
scriptBlocker
;
AutoAssertNoFlush
noReentrantFlush
(
*
this
)
;
if
(
nsCOMPtr
<
nsIDocShell
>
docShell
=
mPresContext
-
>
GetDocShell
(
)
)
{
DOMHighResTimeStamp
now
=
GetPerformanceNowUnclamped
(
)
;
docShell
-
>
NotifyReflowObservers
(
aInterruptible
mLastReflowStart
now
)
;
}
if
(
!
mPresContext
-
>
HasPendingInterrupt
(
)
)
{
mDocument
-
>
ScheduleResizeObserversNotification
(
)
;
}
if
(
StaticPrefs
:
:
layout_reflow_synthMouseMove
(
)
)
{
SynthesizeMouseMove
(
false
)
;
}
mPresContext
-
>
NotifyMissingFonts
(
)
;
}
DOMHighResTimeStamp
PresShell
:
:
GetPerformanceNowUnclamped
(
)
{
DOMHighResTimeStamp
now
=
0
;
if
(
nsPIDOMWindowInner
*
window
=
mDocument
-
>
GetInnerWindow
(
)
)
{
Performance
*
perf
=
window
-
>
GetPerformance
(
)
;
if
(
perf
)
{
now
=
perf
-
>
NowUnclamped
(
)
;
}
}
return
now
;
}
void
PresShell
:
:
sReflowContinueCallback
(
nsITimer
*
aTimer
void
*
aPresShell
)
{
RefPtr
<
PresShell
>
self
=
static_cast
<
PresShell
*
>
(
aPresShell
)
;
MOZ_ASSERT
(
aTimer
=
=
self
-
>
mReflowContinueTimer
"
Unexpected
timer
"
)
;
self
-
>
mReflowContinueTimer
=
nullptr
;
self
-
>
ScheduleReflow
(
)
;
}
bool
PresShell
:
:
ScheduleReflowOffTimer
(
)
{
MOZ_ASSERT
(
!
mObservingLayoutFlushes
"
Shouldn
'
t
get
here
"
)
;
ASSERT_REFLOW_SCHEDULED_STATE
(
)
;
if
(
!
mReflowContinueTimer
)
{
nsresult
rv
=
NS_NewTimerWithFuncCallback
(
getter_AddRefs
(
mReflowContinueTimer
)
sReflowContinueCallback
this
30
nsITimer
:
:
TYPE_ONE_SHOT
"
sReflowContinueCallback
"
mDocument
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
)
;
return
NS_SUCCEEDED
(
rv
)
;
}
return
true
;
}
bool
PresShell
:
:
DoReflow
(
nsIFrame
*
target
bool
aInterruptible
OverflowChangedTracker
*
aOverflowTracker
)
{
[
[
maybe_unused
]
]
nsIURI
*
uri
=
mDocument
-
>
GetDocumentURI
(
)
;
AUTO_PROFILER_LABEL_DYNAMIC_NSCSTRING
(
"
Reflow
"
LAYOUT_Reflow
uri
?
uri
-
>
GetSpecOrDefault
(
)
:
"
N
/
A
"
_ns
)
;
LAYOUT_TELEMETRY_RECORD_BASE
(
Reflow
)
;
PerfStats
:
:
AutoMetricRecording
<
PerfStats
:
:
Metric
:
:
Reflowing
>
autoRecording
;
gfxTextPerfMetrics
*
tp
=
mPresContext
-
>
GetTextPerfMetrics
(
)
;
TimeStamp
timeStart
;
if
(
tp
)
{
tp
-
>
Accumulate
(
)
;
tp
-
>
reflowCount
+
+
;
timeStart
=
TimeStamp
:
:
Now
(
)
;
}
if
(
mMobileViewportManager
)
{
mMobileViewportManager
-
>
UpdateSizesBeforeReflow
(
)
;
}
target
-
>
SchedulePaint
(
nsIFrame
:
:
PAINT_DEFAULT
false
)
;
nsDocShell
*
docShell
=
static_cast
<
nsDocShell
*
>
(
GetPresContext
(
)
-
>
GetDocShell
(
)
)
;
RefPtr
<
TimelineConsumers
>
timelines
=
TimelineConsumers
:
:
Get
(
)
;
bool
isTimelineRecording
=
timelines
&
&
timelines
-
>
HasConsumer
(
docShell
)
;
if
(
isTimelineRecording
)
{
timelines
-
>
AddMarkerForDocShell
(
docShell
"
Reflow
"
MarkerTracingType
:
:
START
)
;
}
#
ifdef
MOZ_GECKO_PROFILER
Maybe
<
uint64_t
>
innerWindowID
;
if
(
auto
*
window
=
mDocument
-
>
GetInnerWindow
(
)
)
{
innerWindowID
=
Some
(
window
-
>
WindowID
(
)
)
;
}
AutoProfilerTracing
tracingLayoutFlush
(
"
Paint
"
"
Reflow
"
geckoprofiler
:
:
category
:
:
LAYOUT
std
:
:
move
(
mReflowCause
)
innerWindowID
)
;
mReflowCause
=
nullptr
;
#
endif
FlushPendingScrollAnchorSelections
(
)
;
if
(
mReflowContinueTimer
)
{
mReflowContinueTimer
-
>
Cancel
(
)
;
mReflowContinueTimer
=
nullptr
;
}
const
bool
isRoot
=
target
=
=
mFrameConstructor
-
>
GetRootFrame
(
)
;
MOZ_ASSERT
(
isRoot
|
|
aOverflowTracker
"
caller
must
provide
overflow
tracker
when
reflowing
"
"
non
-
root
frames
"
)
;
RefPtr
<
gfxContext
>
rcx
(
CreateReferenceRenderingContext
(
)
)
;
#
ifdef
DEBUG
mCurrentReflowRoot
=
target
;
#
endif
WritingMode
wm
=
target
-
>
GetWritingMode
(
)
;
LogicalSize
size
(
wm
)
;
if
(
isRoot
)
{
size
=
LogicalSize
(
wm
mPresContext
-
>
GetVisibleArea
(
)
.
Size
(
)
)
;
}
else
{
size
=
target
-
>
GetLogicalSize
(
)
;
}
OverflowAreas
oldOverflow
;
if
(
!
isRoot
)
{
oldOverflow
=
target
-
>
GetOverflowAreas
(
)
;
}
NS_ASSERTION
(
!
target
-
>
GetNextInFlow
(
)
&
&
!
target
-
>
GetPrevInFlow
(
)
"
reflow
roots
should
never
split
"
)
;
LogicalSize
reflowSize
(
wm
size
.
ISize
(
wm
)
NS_UNCONSTRAINEDSIZE
)
;
ReflowInput
reflowInput
(
mPresContext
target
rcx
reflowSize
ReflowInput
:
:
InitFlag
:
:
CallerWillInit
)
;
reflowInput
.
mOrthogonalLimit
=
size
.
BSize
(
wm
)
;
if
(
isRoot
)
{
reflowInput
.
Init
(
mPresContext
)
;
bool
hasUnconstrainedBSize
=
size
.
BSize
(
wm
)
=
=
NS_UNCONSTRAINEDSIZE
;
if
(
hasUnconstrainedBSize
|
|
mLastRootReflowHadUnconstrainedBSize
)
{
reflowInput
.
SetBResize
(
true
)
;
}
mLastRootReflowHadUnconstrainedBSize
=
hasUnconstrainedBSize
;
}
else
{
reflowInput
.
Init
(
mPresContext
Nothing
(
)
Some
(
target
-
>
GetLogicalUsedBorder
(
wm
)
)
Some
(
target
-
>
GetLogicalUsedPadding
(
wm
)
)
)
;
}
NS_ASSERTION
(
reflowInput
.
ComputedPhysicalMargin
(
)
=
=
nsMargin
(
0
0
0
0
)
"
reflow
input
should
not
set
margin
for
reflow
roots
"
)
;
if
(
size
.
BSize
(
wm
)
!
=
NS_UNCONSTRAINEDSIZE
)
{
nscoord
computedBSize
=
size
.
BSize
(
wm
)
-
reflowInput
.
ComputedLogicalBorderPadding
(
wm
)
.
BStartEnd
(
wm
)
;
computedBSize
=
std
:
:
max
(
computedBSize
0
)
;
reflowInput
.
SetComputedBSize
(
computedBSize
)
;
}
NS_ASSERTION
(
reflowInput
.
ComputedISize
(
)
=
=
size
.
ISize
(
wm
)
-
reflowInput
.
ComputedLogicalBorderPadding
(
wm
)
.
IStartEnd
(
wm
)
"
reflow
input
computed
incorrect
inline
size
"
)
;
mPresContext
-
>
ReflowStarted
(
aInterruptible
)
;
mIsReflowing
=
true
;
nsReflowStatus
status
;
ReflowOutput
desiredSize
(
reflowInput
)
;
target
-
>
Reflow
(
mPresContext
desiredSize
reflowInput
status
)
;
nsRect
boundsRelativeToTarget
=
nsRect
(
0
0
desiredSize
.
Width
(
)
desiredSize
.
Height
(
)
)
;
NS_ASSERTION
(
(
isRoot
&
&
size
.
BSize
(
wm
)
=
=
NS_UNCONSTRAINEDSIZE
)
|
|
(
desiredSize
.
ISize
(
wm
)
=
=
size
.
ISize
(
wm
)
&
&
desiredSize
.
BSize
(
wm
)
=
=
size
.
BSize
(
wm
)
)
"
non
-
root
frame
'
s
desired
size
changed
during
an
"
"
incremental
reflow
"
)
;
NS_ASSERTION
(
status
.
IsEmpty
(
)
"
reflow
roots
should
never
split
"
)
;
target
-
>
SetSize
(
boundsRelativeToTarget
.
Size
(
)
)
;
nsContainerFrame
:
:
SyncFrameViewAfterReflow
(
mPresContext
target
target
-
>
GetView
(
)
boundsRelativeToTarget
)
;
nsContainerFrame
:
:
SyncWindowProperties
(
mPresContext
target
target
-
>
GetView
(
)
rcx
nsContainerFrame
:
:
SET_ASYNC
)
;
target
-
>
DidReflow
(
mPresContext
nullptr
)
;
if
(
target
-
>
IsInScrollAnchorChain
(
)
)
{
ScrollAnchorContainer
*
container
=
ScrollAnchorContainer
:
:
FindFor
(
target
)
;
PostPendingScrollAnchorAdjustment
(
container
)
;
}
if
(
isRoot
&
&
size
.
BSize
(
wm
)
=
=
NS_UNCONSTRAINEDSIZE
)
{
mPresContext
-
>
SetVisibleArea
(
boundsRelativeToTarget
)
;
}
#
ifdef
DEBUG
mCurrentReflowRoot
=
nullptr
;
#
endif
if
(
!
isRoot
&
&
oldOverflow
!
=
target
-
>
GetOverflowAreas
(
)
)
{
aOverflowTracker
-
>
AddFrame
(
target
-
>
GetParent
(
)
OverflowChangedTracker
:
:
CHILDREN_CHANGED
)
;
}
NS_ASSERTION
(
mPresContext
-
>
HasPendingInterrupt
(
)
|
|
mFramesToDirty
.
Count
(
)
=
=
0
"
Why
do
we
need
to
dirty
anything
if
not
interrupted
?
"
)
;
mIsReflowing
=
false
;
bool
interrupted
=
mPresContext
-
>
HasPendingInterrupt
(
)
;
if
(
interrupted
)
{
for
(
const
auto
&
key
:
mFramesToDirty
)
{
for
(
nsIFrame
*
f
=
key
;
f
&
&
!
f
-
>
IsSubtreeDirty
(
)
;
f
=
f
-
>
GetParent
(
)
)
{
f
-
>
AddStateBits
(
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
if
(
f
-
>
IsFlexItem
(
)
)
{
nsFlexContainerFrame
:
:
MarkCachedFlexMeasurementsDirty
(
f
)
;
}
if
(
f
=
=
target
)
{
break
;
}
}
}
NS_ASSERTION
(
target
-
>
IsSubtreeDirty
(
)
"
Why
is
the
target
not
dirty
?
"
)
;
mDirtyRoots
.
Add
(
target
)
;
SetNeedLayoutFlush
(
)
;
#
ifdef
NOISY_INTERRUPTIBLE_REFLOW
printf
(
"
mFramesToDirty
.
Count
(
)
=
=
%
u
\
n
"
mFramesToDirty
.
Count
(
)
)
;
#
endif
mFramesToDirty
.
Clear
(
)
;
mWasLastReflowInterrupted
=
true
;
MaybeScheduleReflow
(
)
;
}
if
(
tp
)
{
if
(
tp
-
>
current
.
numChars
>
100
)
{
TimeDuration
reflowTime
=
TimeStamp
:
:
Now
(
)
-
timeStart
;
LogTextPerfStats
(
tp
this
tp
-
>
current
reflowTime
.
ToMilliseconds
(
)
eLog_reflow
nullptr
)
;
}
tp
-
>
Accumulate
(
)
;
}
if
(
isTimelineRecording
)
{
timelines
-
>
AddMarkerForDocShell
(
docShell
"
Reflow
"
MarkerTracingType
:
:
END
)
;
}
return
!
interrupted
;
}
#
ifdef
DEBUG
void
PresShell
:
:
DoVerifyReflow
(
)
{
if
(
GetVerifyReflowEnable
(
)
)
{
nsView
*
rootView
=
mViewManager
-
>
GetRootView
(
)
;
mViewManager
-
>
InvalidateView
(
rootView
)
;
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
mInVerifyReflow
=
true
;
bool
ok
=
VerifyIncrementalReflow
(
)
;
mInVerifyReflow
=
false
;
if
(
VerifyReflowFlags
:
:
All
&
gVerifyReflowFlags
)
{
printf
(
"
ProcessReflowCommands
:
finished
(
%
s
)
\
n
"
ok
?
"
ok
"
:
"
failed
"
)
;
}
if
(
!
mDirtyRoots
.
IsEmpty
(
)
)
{
printf
(
"
XXX
yikes
!
reflow
commands
queued
during
verify
-
reflow
\
n
"
)
;
}
}
}
#
endif
#
define
NS_LONG_REFLOW_TIME_MS
5000
bool
PresShell
:
:
ProcessReflowCommands
(
bool
aInterruptible
)
{
if
(
mDirtyRoots
.
IsEmpty
(
)
&
&
!
mShouldUnsuppressPainting
)
{
return
true
;
}
mozilla
:
:
TimeStamp
timerStart
=
mozilla
:
:
TimeStamp
:
:
Now
(
)
;
bool
interrupted
=
false
;
if
(
!
mDirtyRoots
.
IsEmpty
(
)
)
{
#
ifdef
DEBUG
if
(
VerifyReflowFlags
:
:
DumpCommands
&
gVerifyReflowFlags
)
{
printf
(
"
ProcessReflowCommands
:
begin
incremental
reflow
\
n
"
)
;
}
#
endif
const
PRIntervalTime
deadline
=
aInterruptible
?
PR_IntervalNow
(
)
+
PR_MicrosecondsToInterval
(
gMaxRCProcessingTime
)
:
(
PRIntervalTime
)
0
;
{
nsAutoScriptBlocker
scriptBlocker
;
WillDoReflow
(
)
;
AUTO_LAYOUT_PHASE_ENTRY_POINT
(
GetPresContext
(
)
Reflow
)
;
nsViewManager
:
:
AutoDisableRefresh
refreshBlocker
(
mViewManager
)
;
OverflowChangedTracker
overflowTracker
;
do
{
nsIFrame
*
target
=
mDirtyRoots
.
PopShallowestRoot
(
)
;
if
(
!
target
-
>
IsSubtreeDirty
(
)
)
{
continue
;
}
interrupted
=
!
DoReflow
(
target
aInterruptible
&
overflowTracker
)
;
}
while
(
!
interrupted
&
&
!
mDirtyRoots
.
IsEmpty
(
)
&
&
(
!
aInterruptible
|
|
PR_IntervalNow
(
)
<
deadline
)
)
;
interrupted
=
!
mDirtyRoots
.
IsEmpty
(
)
;
overflowTracker
.
Flush
(
)
;
if
(
!
interrupted
)
{
FlushPendingScrollAnchorAdjustments
(
)
;
}
}
if
(
!
mIsDestroying
)
{
DidDoReflow
(
aInterruptible
)
;
}
if
(
!
mIsDestroying
)
{
#
ifdef
DEBUG
if
(
VerifyReflowFlags
:
:
DumpCommands
&
gVerifyReflowFlags
)
{
printf
(
"
\
nPresShell
:
:
ProcessReflowCommands
(
)
finished
:
this
=
%
p
\
n
"
(
void
*
)
this
)
;
}
DoVerifyReflow
(
)
;
#
endif
if
(
!
mDirtyRoots
.
IsEmpty
(
)
)
{
MaybeScheduleReflow
(
)
;
SetNeedLayoutFlush
(
)
;
}
}
}
if
(
!
mIsDestroying
&
&
mShouldUnsuppressPainting
&
&
mDirtyRoots
.
IsEmpty
(
)
)
{
mShouldUnsuppressPainting
=
false
;
UnsuppressAndInvalidate
(
)
;
}
if
(
mDocument
-
>
GetRootElement
(
)
)
{
TimeDuration
elapsed
=
TimeStamp
:
:
Now
(
)
-
timerStart
;
int32_t
intElapsed
=
int32_t
(
elapsed
.
ToMilliseconds
(
)
)
;
if
(
intElapsed
>
NS_LONG_REFLOW_TIME_MS
)
{
Telemetry
:
:
Accumulate
(
Telemetry
:
:
LONG_REFLOW_INTERRUPTIBLE
aInterruptible
?
1
:
0
)
;
}
}
return
!
interrupted
;
}
void
PresShell
:
:
WindowSizeMoveDone
(
)
{
if
(
mPresContext
)
{
EventStateManager
:
:
ClearGlobalActiveContent
(
nullptr
)
;
ClearMouseCapture
(
nullptr
)
;
}
}
NS_IMETHODIMP
PresShell
:
:
Observe
(
nsISupports
*
aSubject
const
char
*
aTopic
const
char16_t
*
aData
)
{
if
(
mIsDestroying
)
{
NS_WARNING
(
"
our
observers
should
have
been
unregistered
by
now
"
)
;
return
NS_OK
;
}
if
(
!
nsCRT
:
:
strcmp
(
aTopic
"
memory
-
pressure
"
)
)
{
if
(
!
AssumeAllFramesVisible
(
)
&
&
mPresContext
-
>
IsRootContentDocument
(
)
)
{
DoUpdateApproximateFrameVisibility
(
true
)
;
}
return
NS_OK
;
}
if
(
!
nsCRT
:
:
strcmp
(
aTopic
NS_WIDGET_WAKE_OBSERVER_TOPIC
)
)
{
mLastOSWake
=
TimeStamp
:
:
Now
(
)
;
return
NS_OK
;
}
if
(
!
nsCRT
:
:
strcmp
(
aTopic
"
sessionstore
-
one
-
or
-
no
-
tab
-
restored
"
)
)
{
MOZ_ASSERT
(
XRE_IsParentProcess
(
)
)
;
sProcessInteractable
=
true
;
nsCOMPtr
<
nsIObserverService
>
os
=
mozilla
:
:
services
:
:
GetObserverService
(
)
;
if
(
os
)
{
os
-
>
RemoveObserver
(
this
"
sessionstore
-
one
-
or
-
no
-
tab
-
restored
"
)
;
}
return
NS_OK
;
}
if
(
!
nsCRT
:
:
strcmp
(
aTopic
"
font
-
info
-
updated
"
)
)
{
mPresContext
-
>
ForceReflowForFontInfoUpdate
(
)
;
return
NS_OK
;
}
if
(
!
nsCRT
:
:
strcmp
(
aTopic
"
look
-
and
-
feel
-
changed
"
)
)
{
auto
kind
=
widget
:
:
ThemeChangeKind
(
reinterpret_cast
<
uintptr_t
>
(
aData
)
)
;
ThemeChanged
(
kind
)
;
return
NS_OK
;
}
NS_WARNING
(
"
unrecognized
topic
in
PresShell
:
:
Observe
"
)
;
return
NS_ERROR_FAILURE
;
}
bool
PresShell
:
:
AddRefreshObserver
(
nsARefreshObserver
*
aObserver
FlushType
aFlushType
const
char
*
aObserverDescription
)
{
nsPresContext
*
presContext
=
GetPresContext
(
)
;
if
(
MOZ_UNLIKELY
(
!
presContext
)
)
{
return
false
;
}
presContext
-
>
RefreshDriver
(
)
-
>
AddRefreshObserver
(
aObserver
aFlushType
aObserverDescription
)
;
return
true
;
}
bool
PresShell
:
:
RemoveRefreshObserver
(
nsARefreshObserver
*
aObserver
FlushType
aFlushType
)
{
nsPresContext
*
presContext
=
GetPresContext
(
)
;
return
presContext
&
&
presContext
-
>
RefreshDriver
(
)
-
>
RemoveRefreshObserver
(
aObserver
aFlushType
)
;
}
bool
PresShell
:
:
AddPostRefreshObserver
(
nsAPostRefreshObserver
*
aObserver
)
{
nsPresContext
*
presContext
=
GetPresContext
(
)
;
if
(
!
presContext
)
{
return
false
;
}
presContext
-
>
RefreshDriver
(
)
-
>
AddPostRefreshObserver
(
aObserver
)
;
return
true
;
}
bool
PresShell
:
:
RemovePostRefreshObserver
(
nsAPostRefreshObserver
*
aObserver
)
{
nsPresContext
*
presContext
=
GetPresContext
(
)
;
if
(
!
presContext
)
{
return
false
;
}
presContext
-
>
RefreshDriver
(
)
-
>
RemovePostRefreshObserver
(
aObserver
)
;
return
true
;
}
void
PresShell
:
:
DoObserveStyleFlushes
(
)
{
MOZ_ASSERT
(
!
ObservingStyleFlushes
(
)
)
;
mObservingStyleFlushes
=
true
;
if
(
MOZ_LIKELY
(
!
mDocument
-
>
GetBFCacheEntry
(
)
)
)
{
mPresContext
-
>
RefreshDriver
(
)
-
>
AddStyleFlushObserver
(
this
)
;
}
}
void
PresShell
:
:
DoObserveLayoutFlushes
(
)
{
MOZ_ASSERT
(
!
ObservingLayoutFlushes
(
)
)
;
mObservingLayoutFlushes
=
true
;
if
(
MOZ_LIKELY
(
!
mDocument
-
>
GetBFCacheEntry
(
)
)
)
{
mPresContext
-
>
RefreshDriver
(
)
-
>
AddLayoutFlushObserver
(
this
)
;
}
}
PresShell
:
:
DelayedInputEvent
:
:
DelayedInputEvent
(
)
:
DelayedEvent
(
)
mEvent
(
nullptr
)
{
}
PresShell
:
:
DelayedInputEvent
:
:
~
DelayedInputEvent
(
)
{
delete
mEvent
;
}
void
PresShell
:
:
DelayedInputEvent
:
:
Dispatch
(
)
{
if
(
!
mEvent
|
|
!
mEvent
-
>
mWidget
)
{
return
;
}
nsCOMPtr
<
nsIWidget
>
widget
=
mEvent
-
>
mWidget
;
nsEventStatus
status
;
widget
-
>
DispatchEvent
(
mEvent
status
)
;
}
PresShell
:
:
DelayedMouseEvent
:
:
DelayedMouseEvent
(
WidgetMouseEvent
*
aEvent
)
:
DelayedInputEvent
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aEvent
-
>
IsTrusted
(
)
)
;
WidgetMouseEvent
*
mouseEvent
=
new
WidgetMouseEvent
(
true
aEvent
-
>
mMessage
aEvent
-
>
mWidget
aEvent
-
>
mReason
aEvent
-
>
mContextMenuTrigger
)
;
mouseEvent
-
>
AssignMouseEventData
(
*
aEvent
false
)
;
mEvent
=
mouseEvent
;
}
PresShell
:
:
DelayedKeyEvent
:
:
DelayedKeyEvent
(
WidgetKeyboardEvent
*
aEvent
)
:
DelayedInputEvent
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aEvent
-
>
IsTrusted
(
)
)
;
WidgetKeyboardEvent
*
keyEvent
=
new
WidgetKeyboardEvent
(
true
aEvent
-
>
mMessage
aEvent
-
>
mWidget
)
;
keyEvent
-
>
AssignKeyEventData
(
*
aEvent
false
)
;
keyEvent
-
>
mFlags
.
mIsSynthesizedForTests
=
aEvent
-
>
mFlags
.
mIsSynthesizedForTests
;
keyEvent
-
>
mFlags
.
mIsSuppressedOrDelayed
=
true
;
mEvent
=
keyEvent
;
}
bool
PresShell
:
:
DelayedKeyEvent
:
:
IsKeyPressEvent
(
)
{
return
mEvent
-
>
mMessage
=
=
eKeyPress
;
}
#
ifdef
DEBUG
static
void
LogVerifyMessage
(
nsIFrame
*
k1
nsIFrame
*
k2
const
char
*
aMsg
)
{
nsAutoString
n1
n2
;
if
(
k1
)
{
k1
-
>
GetFrameName
(
n1
)
;
}
else
{
n1
.
AssignLiteral
(
u
"
(
null
)
"
)
;
}
if
(
k2
)
{
k2
-
>
GetFrameName
(
n2
)
;
}
else
{
n2
.
AssignLiteral
(
u
"
(
null
)
"
)
;
}
printf
(
"
verifyreflow
:
%
s
%
p
!
=
%
s
%
p
%
s
\
n
"
NS_LossyConvertUTF16toASCII
(
n1
)
.
get
(
)
(
void
*
)
k1
NS_LossyConvertUTF16toASCII
(
n2
)
.
get
(
)
(
void
*
)
k2
aMsg
)
;
}
static
void
LogVerifyMessage
(
nsIFrame
*
k1
nsIFrame
*
k2
const
char
*
aMsg
const
nsRect
&
r1
const
nsRect
&
r2
)
{
printf
(
"
VerifyReflow
Error
:
\
n
"
)
;
nsAutoString
name
;
if
(
k1
)
{
k1
-
>
GetFrameName
(
name
)
;
printf
(
"
%
s
%
p
"
NS_LossyConvertUTF16toASCII
(
name
)
.
get
(
)
(
void
*
)
k1
)
;
}
printf
(
"
{
%
d
%
d
%
d
%
d
}
!
=
\
n
"
r1
.
x
r1
.
y
r1
.
width
r1
.
height
)
;
if
(
k2
)
{
k2
-
>
GetFrameName
(
name
)
;
printf
(
"
%
s
%
p
"
NS_LossyConvertUTF16toASCII
(
name
)
.
get
(
)
(
void
*
)
k2
)
;
}
printf
(
"
{
%
d
%
d
%
d
%
d
}
\
n
%
s
\
n
"
r2
.
x
r2
.
y
r2
.
width
r2
.
height
aMsg
)
;
}
static
void
LogVerifyMessage
(
nsIFrame
*
k1
nsIFrame
*
k2
const
char
*
aMsg
const
nsIntRect
&
r1
const
nsIntRect
&
r2
)
{
printf
(
"
VerifyReflow
Error
:
\
n
"
)
;
nsAutoString
name
;
if
(
k1
)
{
k1
-
>
GetFrameName
(
name
)
;
printf
(
"
%
s
%
p
"
NS_LossyConvertUTF16toASCII
(
name
)
.
get
(
)
(
void
*
)
k1
)
;
}
printf
(
"
{
%
d
%
d
%
d
%
d
}
!
=
\
n
"
r1
.
x
r1
.
y
r1
.
width
r1
.
height
)
;
if
(
k2
)
{
k2
-
>
GetFrameName
(
name
)
;
printf
(
"
%
s
%
p
"
NS_LossyConvertUTF16toASCII
(
name
)
.
get
(
)
(
void
*
)
k2
)
;
}
printf
(
"
{
%
d
%
d
%
d
%
d
}
\
n
%
s
\
n
"
r2
.
x
r2
.
y
r2
.
width
r2
.
height
aMsg
)
;
}
static
bool
CompareTrees
(
nsPresContext
*
aFirstPresContext
nsIFrame
*
aFirstFrame
nsPresContext
*
aSecondPresContext
nsIFrame
*
aSecondFrame
)
{
if
(
!
aFirstPresContext
|
|
!
aFirstFrame
|
|
!
aSecondPresContext
|
|
!
aSecondFrame
)
return
true
;
bool
ok
=
true
;
const
auto
&
childLists1
=
aFirstFrame
-
>
ChildLists
(
)
;
const
auto
&
childLists2
=
aSecondFrame
-
>
ChildLists
(
)
;
auto
iterLists1
=
childLists1
.
begin
(
)
;
auto
iterLists2
=
childLists2
.
begin
(
)
;
do
{
const
nsFrameList
&
kids1
=
iterLists1
!
=
childLists1
.
end
(
)
?
iterLists1
-
>
mList
:
nsFrameList
(
)
;
const
nsFrameList
&
kids2
=
iterLists2
!
=
childLists2
.
end
(
)
?
iterLists2
-
>
mList
:
nsFrameList
(
)
;
int32_t
l1
=
kids1
.
GetLength
(
)
;
int32_t
l2
=
kids2
.
GetLength
(
)
;
if
(
l1
!
=
l2
)
{
ok
=
false
;
LogVerifyMessage
(
kids1
.
FirstChild
(
)
kids2
.
FirstChild
(
)
"
child
counts
don
'
t
match
:
"
)
;
printf
(
"
%
d
!
=
%
d
\
n
"
l1
l2
)
;
if
(
!
(
VerifyReflowFlags
:
:
All
&
gVerifyReflowFlags
)
)
{
break
;
}
}
LayoutDeviceIntRect
r1
r2
;
nsView
*
v1
;
nsView
*
v2
;
for
(
nsFrameList
:
:
Enumerator
e1
(
kids1
)
e2
(
kids2
)
;
;
e1
.
Next
(
)
e2
.
Next
(
)
)
{
nsIFrame
*
k1
=
e1
.
get
(
)
;
nsIFrame
*
k2
=
e2
.
get
(
)
;
if
(
(
(
nullptr
=
=
k1
)
&
&
(
nullptr
!
=
k2
)
)
|
|
(
(
nullptr
!
=
k1
)
&
&
(
nullptr
=
=
k2
)
)
)
{
ok
=
false
;
LogVerifyMessage
(
k1
k2
"
child
lists
are
different
\
n
"
)
;
break
;
}
else
if
(
nullptr
!
=
k1
)
{
if
(
!
k1
-
>
GetRect
(
)
.
IsEqualInterior
(
k2
-
>
GetRect
(
)
)
)
{
ok
=
false
;
LogVerifyMessage
(
k1
k2
"
(
frame
rects
)
"
k1
-
>
GetRect
(
)
k2
-
>
GetRect
(
)
)
;
}
v1
=
k1
-
>
GetView
(
)
;
v2
=
k2
-
>
GetView
(
)
;
if
(
(
(
nullptr
=
=
v1
)
&
&
(
nullptr
!
=
v2
)
)
|
|
(
(
nullptr
!
=
v1
)
&
&
(
nullptr
=
=
v2
)
)
)
{
ok
=
false
;
LogVerifyMessage
(
k1
k2
"
child
views
are
not
matched
\
n
"
)
;
}
else
if
(
nullptr
!
=
v1
)
{
if
(
!
v1
-
>
GetBounds
(
)
.
IsEqualInterior
(
v2
-
>
GetBounds
(
)
)
)
{
LogVerifyMessage
(
k1
k2
"
(
view
rects
)
"
v1
-
>
GetBounds
(
)
v2
-
>
GetBounds
(
)
)
;
}
nsIWidget
*
w1
=
v1
-
>
GetWidget
(
)
;
nsIWidget
*
w2
=
v2
-
>
GetWidget
(
)
;
if
(
(
(
nullptr
=
=
w1
)
&
&
(
nullptr
!
=
w2
)
)
|
|
(
(
nullptr
!
=
w1
)
&
&
(
nullptr
=
=
w2
)
)
)
{
ok
=
false
;
LogVerifyMessage
(
k1
k2
"
child
widgets
are
not
matched
\
n
"
)
;
}
else
if
(
nullptr
!
=
w1
)
{
r1
=
w1
-
>
GetBounds
(
)
;
r2
=
w2
-
>
GetBounds
(
)
;
if
(
!
r1
.
IsEqualEdges
(
r2
)
)
{
LogVerifyMessage
(
k1
k2
"
(
widget
rects
)
"
r1
.
ToUnknownRect
(
)
r2
.
ToUnknownRect
(
)
)
;
}
}
}
if
(
!
ok
&
&
!
(
VerifyReflowFlags
:
:
All
&
gVerifyReflowFlags
)
)
{
break
;
}
if
(
!
CompareTrees
(
aFirstPresContext
k1
aSecondPresContext
k2
)
)
{
ok
=
false
;
if
(
!
(
VerifyReflowFlags
:
:
All
&
gVerifyReflowFlags
)
)
{
break
;
}
}
}
else
{
break
;
}
}
if
(
!
ok
&
&
(
!
(
VerifyReflowFlags
:
:
All
&
gVerifyReflowFlags
)
)
)
{
break
;
}
+
+
iterLists1
;
+
+
iterLists2
;
const
bool
lists1Done
=
iterLists1
=
=
childLists1
.
end
(
)
;
const
bool
lists2Done
=
iterLists2
=
=
childLists2
.
end
(
)
;
if
(
lists1Done
!
=
lists2Done
|
|
(
!
lists1Done
&
&
iterLists1
-
>
mID
!
=
iterLists2
-
>
mID
)
)
{
if
(
!
(
VerifyReflowFlags
:
:
All
&
gVerifyReflowFlags
)
)
{
ok
=
false
;
}
LogVerifyMessage
(
kids1
.
FirstChild
(
)
kids2
.
FirstChild
(
)
"
child
list
names
are
not
matched
:
"
)
;
fprintf
(
stdout
"
%
s
!
=
%
s
\
n
"
!
lists1Done
?
ChildListName
(
iterLists1
-
>
mID
)
:
"
(
null
)
"
!
lists2Done
?
ChildListName
(
iterLists2
-
>
mID
)
:
"
(
null
)
"
)
;
break
;
}
}
while
(
ok
&
&
iterLists1
!
=
childLists1
.
end
(
)
)
;
return
ok
;
}
#
endif
#
if
0
static
nsIFrame
*
FindTopFrame
(
nsIFrame
*
aRoot
)
{
if
(
aRoot
)
{
nsIContent
*
content
=
aRoot
-
>
GetContent
(
)
;
if
(
content
)
{
nsAtom
*
tag
;
content
-
>
GetTag
(
tag
)
;
if
(
nullptr
!
=
tag
)
{
NS_RELEASE
(
tag
)
;
return
aRoot
;
}
}
for
(
nsIFrame
*
kid
:
aRoot
-
>
PrincipalChildList
(
)
)
{
nsIFrame
*
result
=
FindTopFrame
(
kid
)
;
if
(
nullptr
!
=
result
)
{
return
result
;
}
}
}
return
nullptr
;
}
#
endif
#
ifdef
DEBUG
bool
PresShell
:
:
VerifyIncrementalReflow
(
)
{
if
(
VerifyReflowFlags
:
:
Noisy
&
gVerifyReflowFlags
)
{
printf
(
"
Building
Verification
Tree
.
.
.
\
n
"
)
;
}
RefPtr
<
nsPresContext
>
cx
=
new
nsRootPresContext
(
mDocument
mPresContext
-
>
IsPaginated
(
)
?
nsPresContext
:
:
eContext_PrintPreview
:
nsPresContext
:
:
eContext_Galley
)
;
NS_ENSURE_TRUE
(
cx
false
)
;
nsDeviceContext
*
dc
=
mPresContext
-
>
DeviceContext
(
)
;
nsresult
rv
=
cx
-
>
Init
(
dc
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
nsView
*
rootView
=
mViewManager
-
>
GetRootView
(
)
;
NS_ENSURE_TRUE
(
rootView
-
>
HasWidget
(
)
false
)
;
nsIWidget
*
parentWidget
=
rootView
-
>
GetWidget
(
)
;
RefPtr
<
nsViewManager
>
vm
=
new
nsViewManager
(
)
;
NS_ENSURE_TRUE
(
vm
false
)
;
rv
=
vm
-
>
Init
(
dc
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
nsRect
tbounds
=
mPresContext
-
>
GetVisibleArea
(
)
;
nsView
*
view
=
vm
-
>
CreateView
(
tbounds
nullptr
)
;
NS_ENSURE_TRUE
(
view
false
)
;
rv
=
view
-
>
CreateWidgetForParent
(
parentWidget
nullptr
true
)
;
NS_ENSURE_SUCCESS
(
rv
false
)
;
vm
-
>
SetRootView
(
view
)
;
cx
-
>
SetVisibleArea
(
mPresContext
-
>
GetVisibleArea
(
)
)
;
RefPtr
<
PresShell
>
presShell
=
mDocument
-
>
CreatePresShell
(
cx
vm
)
;
NS_ENSURE_TRUE
(
presShell
false
)
;
presShell
-
>
SetVerifyReflowEnable
(
false
)
;
vm
-
>
SetPresShell
(
presShell
)
;
{
nsAutoCauseReflowNotifier
crNotifier
(
this
)
;
presShell
-
>
Initialize
(
)
;
}
presShell
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
presShell
-
>
SetVerifyReflowEnable
(
true
)
;
presShell
-
>
mPaintingSuppressed
=
false
;
if
(
VerifyReflowFlags
:
:
Noisy
&
gVerifyReflowFlags
)
{
printf
(
"
Verification
Tree
built
comparing
.
.
.
\
n
"
)
;
}
nsIFrame
*
root1
=
mFrameConstructor
-
>
GetRootFrame
(
)
;
nsIFrame
*
root2
=
presShell
-
>
GetRootFrame
(
)
;
bool
ok
=
CompareTrees
(
mPresContext
root1
cx
root2
)
;
if
(
!
ok
&
&
(
VerifyReflowFlags
:
:
Noisy
&
gVerifyReflowFlags
)
)
{
printf
(
"
Verify
reflow
failed
primary
tree
:
\
n
"
)
;
root1
-
>
List
(
stdout
)
;
printf
(
"
Verification
tree
:
\
n
"
)
;
root2
-
>
List
(
stdout
)
;
}
#
if
0
if
(
!
ok
)
{
nsString
stra
;
static
int
num
=
0
;
stra
.
AppendLiteral
(
"
C
:
\
\
mozilla
\
\
mozilla
\
\
debug
\
\
filea
"
)
;
stra
.
AppendInt
(
num
)
;
stra
.
AppendLiteral
(
"
.
png
"
)
;
gfxUtils
:
:
WriteAsPNG
(
presShell
stra
)
;
nsString
strb
;
strb
.
AppendLiteral
(
"
C
:
\
\
mozilla
\
\
mozilla
\
\
debug
\
\
fileb
"
)
;
strb
.
AppendInt
(
num
)
;
strb
.
AppendLiteral
(
"
.
png
"
)
;
gfxUtils
:
:
WriteAsPNG
(
presShell
strb
)
;
+
+
num
;
}
#
endif
presShell
-
>
EndObservingDocument
(
)
;
presShell
-
>
Destroy
(
)
;
if
(
VerifyReflowFlags
:
:
Noisy
&
gVerifyReflowFlags
)
{
printf
(
"
Finished
Verifying
Reflow
.
.
.
\
n
"
)
;
}
return
ok
;
}
void
PresShell
:
:
ListComputedStyles
(
FILE
*
out
int32_t
aIndent
)
{
nsIFrame
*
rootFrame
=
GetRootFrame
(
)
;
if
(
rootFrame
)
{
rootFrame
-
>
Style
(
)
-
>
List
(
out
aIndent
)
;
}
Element
*
rootElement
=
mDocument
-
>
GetRootElement
(
)
;
if
(
rootElement
)
{
nsIFrame
*
rootElementFrame
=
rootElement
-
>
GetPrimaryFrame
(
)
;
if
(
rootElementFrame
)
{
rootElementFrame
-
>
Style
(
)
-
>
List
(
out
aIndent
)
;
}
}
}
#
endif
#
if
defined
(
DEBUG
)
|
|
defined
(
MOZ_LAYOUT_DEBUGGER
)
void
PresShell
:
:
ListStyleSheets
(
FILE
*
out
int32_t
aIndent
)
{
auto
ListStyleSheetsAtOrigin
=
[
this
out
aIndent
]
(
StyleOrigin
origin
)
{
int32_t
sheetCount
=
StyleSet
(
)
-
>
SheetCount
(
origin
)
;
for
(
int32_t
i
=
0
;
i
<
sheetCount
;
+
+
i
)
{
StyleSet
(
)
-
>
SheetAt
(
origin
i
)
-
>
List
(
out
aIndent
)
;
}
}
;
ListStyleSheetsAtOrigin
(
StyleOrigin
:
:
UserAgent
)
;
ListStyleSheetsAtOrigin
(
StyleOrigin
:
:
User
)
;
ListStyleSheetsAtOrigin
(
StyleOrigin
:
:
Author
)
;
}
#
endif
#
ifdef
MOZ_REFLOW_PERF
void
PresShell
:
:
DumpReflows
(
)
{
if
(
mReflowCountMgr
)
{
nsAutoCString
uriStr
;
if
(
mDocument
)
{
nsIURI
*
uri
=
mDocument
-
>
GetDocumentURI
(
)
;
if
(
uri
)
{
uri
-
>
GetPathQueryRef
(
uriStr
)
;
}
}
mReflowCountMgr
-
>
DisplayTotals
(
uriStr
.
get
(
)
)
;
mReflowCountMgr
-
>
DisplayHTMLTotals
(
uriStr
.
get
(
)
)
;
mReflowCountMgr
-
>
DisplayDiffsInTotals
(
)
;
}
}
void
PresShell
:
:
CountReflows
(
const
char
*
aName
nsIFrame
*
aFrame
)
{
if
(
mReflowCountMgr
)
{
mReflowCountMgr
-
>
Add
(
aName
aFrame
)
;
}
}
void
PresShell
:
:
PaintCount
(
const
char
*
aName
gfxContext
*
aRenderingContext
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
const
nsPoint
&
aOffset
uint32_t
aColor
)
{
if
(
mReflowCountMgr
)
{
mReflowCountMgr
-
>
PaintCount
(
aName
aRenderingContext
aPresContext
aFrame
aOffset
aColor
)
;
}
}
void
PresShell
:
:
SetPaintFrameCount
(
bool
aPaintFrameCounts
)
{
if
(
mReflowCountMgr
)
{
mReflowCountMgr
-
>
SetPaintFrameCounts
(
aPaintFrameCounts
)
;
}
}
bool
PresShell
:
:
IsPaintingFrameCounts
(
)
{
if
(
mReflowCountMgr
)
return
mReflowCountMgr
-
>
IsPaintingFrameCounts
(
)
;
return
false
;
}
ReflowCounter
:
:
ReflowCounter
(
ReflowCountMgr
*
aMgr
)
:
mMgr
(
aMgr
)
{
ClearTotals
(
)
;
SetTotalsCache
(
)
;
}
ReflowCounter
:
:
~
ReflowCounter
(
)
=
default
;
void
ReflowCounter
:
:
ClearTotals
(
)
{
mTotal
=
0
;
}
void
ReflowCounter
:
:
SetTotalsCache
(
)
{
mCacheTotal
=
mTotal
;
}
void
ReflowCounter
:
:
CalcDiffInTotals
(
)
{
mCacheTotal
=
mTotal
-
mCacheTotal
;
}
void
ReflowCounter
:
:
DisplayTotals
(
const
char
*
aStr
)
{
DisplayTotals
(
mTotal
aStr
?
aStr
:
"
Totals
"
)
;
}
void
ReflowCounter
:
:
DisplayDiffTotals
(
const
char
*
aStr
)
{
DisplayTotals
(
mCacheTotal
aStr
?
aStr
:
"
Diff
Totals
"
)
;
}
void
ReflowCounter
:
:
DisplayHTMLTotals
(
const
char
*
aStr
)
{
DisplayHTMLTotals
(
mTotal
aStr
?
aStr
:
"
Totals
"
)
;
}
void
ReflowCounter
:
:
DisplayTotals
(
uint32_t
aTotal
const
char
*
aTitle
)
{
if
(
aTotal
=
=
0
)
{
return
;
}
ReflowCounter
*
gTots
=
(
ReflowCounter
*
)
mMgr
-
>
LookUp
(
kGrandTotalsStr
)
;
printf
(
"
%
25s
\
t
"
aTitle
)
;
printf
(
"
%
d
\
t
"
aTotal
)
;
if
(
gTots
!
=
this
&
&
aTotal
>
0
)
{
gTots
-
>
Add
(
aTotal
)
;
}
}
void
ReflowCounter
:
:
DisplayHTMLTotals
(
uint32_t
aTotal
const
char
*
aTitle
)
{
if
(
aTotal
=
=
0
)
{
return
;
}
ReflowCounter
*
gTots
=
(
ReflowCounter
*
)
mMgr
-
>
LookUp
(
kGrandTotalsStr
)
;
FILE
*
fd
=
mMgr
-
>
GetOutFile
(
)
;
if
(
!
fd
)
{
return
;
}
fprintf
(
fd
"
<
tr
>
<
td
>
<
center
>
%
s
<
/
center
>
<
/
td
>
"
aTitle
)
;
fprintf
(
fd
"
<
td
>
<
center
>
%
d
<
/
center
>
<
/
td
>
<
/
tr
>
\
n
"
aTotal
)
;
if
(
gTots
!
=
this
&
&
aTotal
>
0
)
{
gTots
-
>
Add
(
aTotal
)
;
}
}
#
define
KEY_BUF_SIZE_FOR_PTR
\
24
/
/
adequate
char
[
]
buffer
to
sprintf
a
pointer
ReflowCountMgr
:
:
ReflowCountMgr
(
)
:
mCounts
(
10
)
mIndiFrameCounts
(
10
)
{
mCycledOnce
=
false
;
mDumpFrameCounts
=
false
;
mDumpFrameByFrameCounts
=
false
;
mPaintFrameByFrameCounts
=
false
;
}
ReflowCountMgr
:
:
~
ReflowCountMgr
(
)
=
default
;
ReflowCounter
*
ReflowCountMgr
:
:
LookUp
(
const
char
*
aName
)
{
return
mCounts
.
Get
(
aName
)
;
}
void
ReflowCountMgr
:
:
Add
(
const
char
*
aName
nsIFrame
*
aFrame
)
{
NS_ASSERTION
(
aName
!
=
nullptr
"
Name
shouldn
'
t
be
null
!
"
)
;
if
(
mDumpFrameCounts
)
{
auto
*
const
counter
=
mCounts
.
GetOrInsertNew
(
aName
this
)
;
counter
-
>
Add
(
)
;
}
if
(
(
mDumpFrameByFrameCounts
|
|
mPaintFrameByFrameCounts
)
&
&
aFrame
!
=
nullptr
)
{
char
key
[
KEY_BUF_SIZE_FOR_PTR
]
;
SprintfLiteral
(
key
"
%
p
"
(
void
*
)
aFrame
)
;
auto
*
const
counter
=
mIndiFrameCounts
.
LookupOrInsertWith
(
key
[
&
aName
&
aFrame
this
]
(
)
{
auto
counter
=
MakeUnique
<
IndiReflowCounter
>
(
this
)
;
counter
-
>
mFrame
=
aFrame
;
counter
-
>
mName
.
AssignASCII
(
aName
)
;
return
counter
;
}
)
.
get
(
)
;
if
(
counter
&
&
counter
-
>
mName
.
EqualsASCII
(
aName
)
)
{
counter
-
>
mCount
+
+
;
counter
-
>
mCounter
.
Add
(
1
)
;
}
}
}
void
ReflowCountMgr
:
:
PaintCount
(
const
char
*
aName
gfxContext
*
aRenderingContext
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
const
nsPoint
&
aOffset
uint32_t
aColor
)
{
if
(
mPaintFrameByFrameCounts
&
&
aFrame
!
=
nullptr
)
{
char
key
[
KEY_BUF_SIZE_FOR_PTR
]
;
SprintfLiteral
(
key
"
%
p
"
(
void
*
)
aFrame
)
;
IndiReflowCounter
*
counter
=
mIndiFrameCounts
.
Get
(
key
)
;
if
(
counter
!
=
nullptr
&
&
counter
-
>
mName
.
EqualsASCII
(
aName
)
)
{
DrawTarget
*
drawTarget
=
aRenderingContext
-
>
GetDrawTarget
(
)
;
int32_t
appUnitsPerDevPixel
=
aPresContext
-
>
AppUnitsPerDevPixel
(
)
;
aRenderingContext
-
>
Save
(
)
;
gfxPoint
devPixelOffset
=
nsLayoutUtils
:
:
PointToGfxPoint
(
aOffset
appUnitsPerDevPixel
)
;
aRenderingContext
-
>
SetMatrixDouble
(
aRenderingContext
-
>
CurrentMatrixDouble
(
)
.
PreTranslate
(
devPixelOffset
)
)
;
nsFont
font
(
StyleGenericFontFamily
:
:
Serif
Length
:
:
FromPixels
(
11
)
)
;
nsFontMetrics
:
:
Params
params
;
params
.
language
=
nsGkAtoms
:
:
x_western
;
params
.
textPerf
=
aPresContext
-
>
GetTextPerfMetrics
(
)
;
params
.
fontStats
=
nullptr
;
params
.
featureValueLookup
=
aPresContext
-
>
GetFontFeatureValuesLookup
(
)
;
RefPtr
<
nsFontMetrics
>
fm
=
aPresContext
-
>
DeviceContext
(
)
-
>
GetMetricsFor
(
font
params
)
;
char
buf
[
16
]
;
int
len
=
SprintfLiteral
(
buf
"
%
d
"
counter
-
>
mCount
)
;
nscoord
x
=
0
y
=
fm
-
>
MaxAscent
(
)
;
nscoord
width
height
=
fm
-
>
MaxHeight
(
)
;
fm
-
>
SetTextRunRTL
(
false
)
;
width
=
fm
-
>
GetWidth
(
buf
len
drawTarget
)
;
sRGBColor
color
;
sRGBColor
color2
;
if
(
aColor
!
=
0
)
{
color
=
sRGBColor
:
:
FromABGR
(
aColor
)
;
color2
=
sRGBColor
(
0
.
f
0
.
f
0
.
f
)
;
}
else
{
gfx
:
:
Float
rc
=
0
.
f
gc
=
0
.
f
bc
=
0
.
f
;
if
(
counter
-
>
mCount
<
5
)
{
rc
=
1
.
f
;
gc
=
1
.
f
;
}
else
if
(
counter
-
>
mCount
<
11
)
{
gc
=
1
.
f
;
}
else
{
rc
=
1
.
f
;
}
color
=
sRGBColor
(
rc
gc
bc
)
;
color2
=
sRGBColor
(
rc
/
2
gc
/
2
bc
/
2
)
;
}
nsRect
rect
(
0
0
width
+
15
height
+
15
)
;
Rect
devPxRect
=
NSRectToSnappedRect
(
rect
appUnitsPerDevPixel
*
drawTarget
)
;
ColorPattern
black
(
ToDeviceColor
(
sRGBColor
:
:
OpaqueBlack
(
)
)
)
;
drawTarget
-
>
FillRect
(
devPxRect
black
)
;
aRenderingContext
-
>
SetColor
(
color2
)
;
fm
-
>
DrawString
(
buf
len
x
+
15
y
+
15
aRenderingContext
)
;
aRenderingContext
-
>
SetColor
(
color
)
;
fm
-
>
DrawString
(
buf
len
x
y
aRenderingContext
)
;
aRenderingContext
-
>
Restore
(
)
;
}
}
}
void
ReflowCountMgr
:
:
DoGrandTotals
(
)
{
mCounts
.
WithEntryHandle
(
kGrandTotalsStr
[
this
]
(
auto
&
&
entry
)
{
if
(
!
entry
)
{
entry
.
Insert
(
MakeUnique
<
ReflowCounter
>
(
this
)
)
;
}
else
{
entry
.
Data
(
)
-
>
ClearTotals
(
)
;
}
}
)
;
printf
(
"
\
t
\
t
\
t
\
tTotal
\
n
"
)
;
for
(
uint32_t
i
=
0
;
i
<
78
;
i
+
+
)
{
printf
(
"
-
"
)
;
}
printf
(
"
\
n
"
)
;
for
(
const
auto
&
entry
:
mCounts
)
{
entry
.
GetData
(
)
-
>
DisplayTotals
(
entry
.
GetKey
(
)
)
;
}
}
static
void
RecurseIndiTotals
(
nsPresContext
*
aPresContext
nsClassHashtable
<
nsCharPtrHashKey
IndiReflowCounter
>
&
aHT
nsIFrame
*
aParentFrame
int32_t
aLevel
)
{
if
(
aParentFrame
=
=
nullptr
)
{
return
;
}
char
key
[
KEY_BUF_SIZE_FOR_PTR
]
;
SprintfLiteral
(
key
"
%
p
"
(
void
*
)
aParentFrame
)
;
IndiReflowCounter
*
counter
=
aHT
.
Get
(
key
)
;
if
(
counter
)
{
counter
-
>
mHasBeenOutput
=
true
;
char
*
name
=
ToNewCString
(
counter
-
>
mName
)
;
for
(
int32_t
i
=
0
;
i
<
aLevel
;
i
+
+
)
printf
(
"
"
)
;
printf
(
"
%
s
-
%
p
[
%
d
]
[
"
name
(
void
*
)
aParentFrame
counter
-
>
mCount
)
;
printf
(
"
%
d
"
counter
-
>
mCounter
.
GetTotal
(
)
)
;
printf
(
"
]
\
n
"
)
;
free
(
name
)
;
}
for
(
nsIFrame
*
child
:
aParentFrame
-
>
PrincipalChildList
(
)
)
{
RecurseIndiTotals
(
aPresContext
aHT
child
aLevel
+
1
)
;
}
}
void
ReflowCountMgr
:
:
DoIndiTotalsTree
(
)
{
printf
(
"
\
n
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
\
n
"
)
;
printf
(
"
-
-
Individual
Frame
Counts
\
n
"
)
;
printf
(
"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
\
n
"
)
;
if
(
mPresShell
)
{
nsIFrame
*
rootFrame
=
mPresShell
-
>
GetRootFrame
(
)
;
RecurseIndiTotals
(
mPresContext
mIndiFrameCounts
rootFrame
0
)
;
printf
(
"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
\
n
"
)
;
printf
(
"
-
-
Individual
Counts
of
Frames
not
in
Root
Tree
\
n
"
)
;
printf
(
"
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
\
n
"
)
;
for
(
const
auto
&
counter
:
mIndiFrameCounts
.
Values
(
)
)
{
if
(
!
counter
-
>
mHasBeenOutput
)
{
char
*
name
=
ToNewCString
(
counter
-
>
mName
)
;
printf
(
"
%
s
-
%
p
[
%
d
]
[
"
name
(
void
*
)
counter
-
>
mFrame
counter
-
>
mCount
)
;
printf
(
"
%
d
"
counter
-
>
mCounter
.
GetTotal
(
)
)
;
printf
(
"
]
\
n
"
)
;
free
(
name
)
;
}
}
}
}
void
ReflowCountMgr
:
:
DoGrandHTMLTotals
(
)
{
mCounts
.
WithEntryHandle
(
kGrandTotalsStr
[
this
]
(
auto
&
&
entry
)
{
if
(
!
entry
)
{
entry
.
Insert
(
MakeUnique
<
ReflowCounter
>
(
this
)
)
;
}
else
{
entry
.
Data
(
)
-
>
ClearTotals
(
)
;
}
}
)
;
static
const
char
*
title
[
]
=
{
"
Class
"
"
Reflows
"
}
;
fprintf
(
mFD
"
<
tr
>
"
)
;
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
title
)
;
i
+
+
)
{
fprintf
(
mFD
"
<
td
>
<
center
>
<
b
>
%
s
<
b
>
<
/
center
>
<
/
td
>
"
title
[
i
]
)
;
}
fprintf
(
mFD
"
<
/
tr
>
\
n
"
)
;
for
(
const
auto
&
entry
:
mCounts
)
{
entry
.
GetData
(
)
-
>
DisplayHTMLTotals
(
entry
.
GetKey
(
)
)
;
}
}
void
ReflowCountMgr
:
:
DisplayTotals
(
const
char
*
aStr
)
{
#
ifdef
DEBUG_rods
printf
(
"
%
s
\
n
"
aStr
?
aStr
:
"
No
name
"
)
;
#
endif
if
(
mDumpFrameCounts
)
{
DoGrandTotals
(
)
;
}
if
(
mDumpFrameByFrameCounts
)
{
DoIndiTotalsTree
(
)
;
}
}
void
ReflowCountMgr
:
:
DisplayHTMLTotals
(
const
char
*
aStr
)
{
#
ifdef
WIN32x
char
name
[
1024
]
;
char
*
sptr
=
strrchr
(
aStr
'
/
'
)
;
if
(
sptr
)
{
sptr
+
+
;
strcpy
(
name
sptr
)
;
char
*
eptr
=
strrchr
(
name
'
.
'
)
;
if
(
eptr
)
{
*
eptr
=
0
;
}
strcat
(
name
"
_stats
.
html
"
)
;
}
mFD
=
fopen
(
name
"
w
"
)
;
if
(
mFD
)
{
fprintf
(
mFD
"
<
html
>
<
head
>
<
title
>
Reflow
Stats
<
/
title
>
<
/
head
>
<
body
>
\
n
"
)
;
const
char
*
title
=
aStr
?
aStr
:
"
No
name
"
;
fprintf
(
mFD
"
<
center
>
<
b
>
%
s
<
/
b
>
<
br
>
<
table
border
=
1
"
"
style
=
\
"
background
-
color
:
#
e0e0e0
\
"
>
"
title
)
;
DoGrandHTMLTotals
(
)
;
fprintf
(
mFD
"
<
/
center
>
<
/
table
>
\
n
"
)
;
fprintf
(
mFD
"
<
/
body
>
<
/
html
>
\
n
"
)
;
fclose
(
mFD
)
;
mFD
=
nullptr
;
}
#
endif
}
void
ReflowCountMgr
:
:
ClearTotals
(
)
{
for
(
const
auto
&
data
:
mCounts
.
Values
(
)
)
{
data
-
>
ClearTotals
(
)
;
}
}
void
ReflowCountMgr
:
:
ClearGrandTotals
(
)
{
mCounts
.
WithEntryHandle
(
kGrandTotalsStr
[
&
]
(
auto
&
&
entry
)
{
if
(
!
entry
)
{
entry
.
Insert
(
MakeUnique
<
ReflowCounter
>
(
this
)
)
;
}
else
{
entry
.
Data
(
)
-
>
ClearTotals
(
)
;
entry
.
Data
(
)
-
>
SetTotalsCache
(
)
;
}
}
)
;
}
void
ReflowCountMgr
:
:
DisplayDiffsInTotals
(
)
{
if
(
mCycledOnce
)
{
printf
(
"
Differences
\
n
"
)
;
for
(
int32_t
i
=
0
;
i
<
78
;
i
+
+
)
{
printf
(
"
-
"
)
;
}
printf
(
"
\
n
"
)
;
ClearGrandTotals
(
)
;
}
for
(
const
auto
&
entry
:
mCounts
)
{
if
(
mCycledOnce
)
{
entry
.
GetData
(
)
-
>
CalcDiffInTotals
(
)
;
entry
.
GetData
(
)
-
>
DisplayDiffTotals
(
entry
.
GetKey
(
)
)
;
}
entry
.
GetData
(
)
-
>
SetTotalsCache
(
)
;
}
mCycledOnce
=
true
;
}
#
endif
nsIFrame
*
PresShell
:
:
GetAbsoluteContainingBlock
(
nsIFrame
*
aFrame
)
{
return
FrameConstructor
(
)
-
>
GetAbsoluteContainingBlock
(
aFrame
nsCSSFrameConstructor
:
:
ABS_POS
)
;
}
#
ifdef
ACCESSIBILITY
bool
PresShell
:
:
IsAccessibilityActive
(
)
{
return
GetAccService
(
)
!
=
nullptr
;
}
nsAccessibilityService
*
PresShell
:
:
GetAccessibilityService
(
)
{
return
GetAccService
(
)
;
}
#
endif
void
PresShell
:
:
QueryIsActive
(
)
{
Document
*
doc
=
mDocument
;
if
(
!
doc
)
{
return
;
}
if
(
Document
*
displayDoc
=
doc
-
>
GetDisplayDocument
(
)
)
{
MOZ_ASSERT
(
!
doc
-
>
GetBrowsingContext
(
)
"
external
resource
doc
shouldn
'
t
have
its
own
BC
"
)
;
doc
=
displayDoc
;
}
if
(
BrowsingContext
*
bc
=
doc
-
>
GetBrowsingContext
(
)
)
{
auto
*
browserChild
=
BrowserChild
:
:
GetFrom
(
doc
-
>
GetDocShell
(
)
)
;
const
bool
hiddenInRemoteFrame
=
browserChild
&
&
!
browserChild
-
>
IsTopLevel
(
)
&
&
!
browserChild
-
>
IsVisible
(
)
;
SetIsActive
(
bc
-
>
IsActive
(
)
&
&
!
hiddenInRemoteFrame
)
;
}
}
nsresult
PresShell
:
:
SetIsActive
(
bool
aIsActive
)
{
MOZ_ASSERT
(
mDocument
"
should
only
be
called
with
a
document
"
)
;
#
if
defined
(
MOZ_WIDGET_ANDROID
)
const
bool
changed
=
mIsActive
!
=
aIsActive
;
#
endif
mIsActive
=
aIsActive
;
nsPresContext
*
presContext
=
GetPresContext
(
)
;
if
(
presContext
&
&
presContext
-
>
RefreshDriver
(
)
-
>
GetPresContext
(
)
=
=
presContext
)
{
presContext
-
>
RefreshDriver
(
)
-
>
SetThrottled
(
!
mIsActive
)
;
}
{
auto
recurse
=
[
aIsActive
]
(
Document
&
aResourceDoc
)
{
if
(
PresShell
*
presShell
=
aResourceDoc
.
GetPresShell
(
)
)
{
presShell
-
>
SetIsActive
(
aIsActive
)
;
}
return
CallState
:
:
Continue
;
}
;
mDocument
-
>
EnumerateExternalResources
(
recurse
)
;
}
nsresult
rv
=
UpdateImageLockingState
(
)
;
#
ifdef
ACCESSIBILITY
if
(
aIsActive
)
{
if
(
nsAccessibilityService
*
accService
=
PresShell
:
:
GetAccessibilityService
(
)
)
{
accService
-
>
PresShellActivated
(
this
)
;
}
}
#
endif
#
if
defined
(
MOZ_WIDGET_ANDROID
)
if
(
changed
&
&
!
aIsActive
&
&
presContext
&
&
presContext
-
>
IsRootContentDocumentCrossProcess
(
)
)
{
if
(
BrowserChild
*
browserChild
=
BrowserChild
:
:
GetFrom
(
this
)
)
{
presContext
-
>
UpdateDynamicToolbarOffset
(
0
)
;
}
}
#
endif
return
rv
;
}
RefPtr
<
MobileViewportManager
>
PresShell
:
:
GetMobileViewportManager
(
)
const
{
return
mMobileViewportManager
;
}
Maybe
<
MobileViewportManager
:
:
ManagerType
>
UseMobileViewportManager
(
PresShell
*
aPresShell
Document
*
aDocument
)
{
if
(
nsPresContext
*
presContext
=
aPresShell
-
>
GetPresContext
(
)
)
{
if
(
nsIWidget
*
widget
=
presContext
-
>
GetNearestWidget
(
)
)
{
if
(
!
widget
-
>
AsyncPanZoomEnabled
(
)
)
{
return
Nothing
(
)
;
}
}
}
if
(
nsLayoutUtils
:
:
ShouldHandleMetaViewport
(
aDocument
)
)
{
return
Some
(
MobileViewportManager
:
:
ManagerType
:
:
VisualAndMetaViewport
)
;
}
if
(
StaticPrefs
:
:
apz_mvm_force_enabled
(
)
|
|
nsLayoutUtils
:
:
AllowZoomingForDocument
(
aDocument
)
)
{
return
Some
(
MobileViewportManager
:
:
ManagerType
:
:
VisualViewportOnly
)
;
}
return
Nothing
(
)
;
}
void
PresShell
:
:
MaybeRecreateMobileViewportManager
(
bool
aAfterInitialization
)
{
Maybe
<
MobileViewportManager
:
:
ManagerType
>
mvmType
=
UseMobileViewportManager
(
this
mDocument
)
;
if
(
mvmType
.
isNothing
(
)
&
&
!
mMobileViewportManager
)
{
return
;
}
if
(
mvmType
&
&
mMobileViewportManager
&
&
*
mvmType
=
=
mMobileViewportManager
-
>
GetManagerType
(
)
)
{
return
;
}
if
(
mMobileViewportManager
)
{
mMobileViewportManager
-
>
Destroy
(
)
;
mMobileViewportManager
=
nullptr
;
mMVMContext
=
nullptr
;
ResetVisualViewportSize
(
)
;
SetResolutionAndScaleTo
(
mDocument
-
>
GetSavedResolutionBeforeMVM
(
)
ResolutionChangeOrigin
:
:
MainThreadRestore
)
;
if
(
aAfterInitialization
)
{
nsDocShell
*
docShell
=
static_cast
<
nsDocShell
*
>
(
GetPresContext
(
)
-
>
GetDocShell
(
)
)
;
int32_t
width
height
;
docShell
-
>
GetSize
(
&
width
&
height
)
;
docShell
-
>
SetSize
(
width
height
false
)
;
}
}
if
(
mvmType
)
{
MOZ_ASSERT
(
!
mMobileViewportManager
)
;
if
(
mPresContext
-
>
IsRootContentDocumentCrossProcess
(
)
)
{
mDocument
-
>
SetSavedResolutionBeforeMVM
(
mResolution
.
valueOr
(
1
.
0f
)
)
;
mMVMContext
=
new
GeckoMVMContext
(
mDocument
this
)
;
mMobileViewportManager
=
new
MobileViewportManager
(
mMVMContext
*
mvmType
)
;
if
(
MOZ_UNLIKELY
(
MOZ_LOG_TEST
(
sApzMvmLog
LogLevel
:
:
Debug
)
)
)
{
nsIURI
*
uri
=
mDocument
-
>
GetDocumentURI
(
)
;
MOZ_LOG
(
sApzMvmLog
LogLevel
:
:
Debug
(
"
Created
MVM
%
p
(
type
%
d
)
for
URI
%
s
"
mMobileViewportManager
.
get
(
)
(
int
)
*
mvmType
uri
?
uri
-
>
GetSpecOrDefault
(
)
.
get
(
)
:
"
(
null
)
"
)
)
;
}
if
(
aAfterInitialization
)
{
mMobileViewportManager
-
>
SetInitialViewport
(
)
;
}
}
}
}
bool
PresShell
:
:
UsesMobileViewportSizing
(
)
const
{
return
mMobileViewportManager
!
=
nullptr
&
&
nsLayoutUtils
:
:
ShouldHandleMetaViewport
(
mDocument
)
;
}
nsresult
PresShell
:
:
UpdateImageLockingState
(
)
{
bool
locked
=
!
mFrozen
&
&
mIsActive
;
nsresult
rv
=
mDocument
-
>
ImageTracker
(
)
-
>
SetLockingState
(
locked
)
;
if
(
locked
)
{
for
(
const
auto
&
key
:
mApproximatelyVisibleFrames
)
{
if
(
nsImageFrame
*
imageFrame
=
do_QueryFrame
(
key
)
)
{
imageFrame
-
>
MaybeDecodeForPredictedSize
(
)
;
}
}
}
return
rv
;
}
PresShell
*
PresShell
:
:
GetRootPresShell
(
)
const
{
if
(
mPresContext
)
{
nsPresContext
*
rootPresContext
=
mPresContext
-
>
GetRootPresContext
(
)
;
if
(
rootPresContext
)
{
return
rootPresContext
-
>
PresShell
(
)
;
}
}
return
nullptr
;
}
void
PresShell
:
:
AddSizeOfIncludingThis
(
nsWindowSizes
&
aSizes
)
const
{
MallocSizeOf
mallocSizeOf
=
aSizes
.
mState
.
mMallocSizeOf
;
mFrameArena
.
AddSizeOfExcludingThis
(
aSizes
Arena
:
:
ArenaKind
:
:
PresShell
)
;
aSizes
.
mLayoutPresShellSize
+
=
mallocSizeOf
(
this
)
;
if
(
mCaret
)
{
aSizes
.
mLayoutPresShellSize
+
=
mCaret
-
>
SizeOfIncludingThis
(
mallocSizeOf
)
;
}
aSizes
.
mLayoutPresShellSize
+
=
mApproximatelyVisibleFrames
.
ShallowSizeOfExcludingThis
(
mallocSizeOf
)
+
mFramesToDirty
.
ShallowSizeOfExcludingThis
(
mallocSizeOf
)
+
mPendingScrollAnchorSelection
.
ShallowSizeOfExcludingThis
(
mallocSizeOf
)
+
mPendingScrollAnchorAdjustment
.
ShallowSizeOfExcludingThis
(
mallocSizeOf
)
;
aSizes
.
mLayoutTextRunsSize
+
=
SizeOfTextRuns
(
mallocSizeOf
)
;
aSizes
.
mLayoutPresContextSize
+
=
mPresContext
-
>
SizeOfIncludingThis
(
mallocSizeOf
)
;
mFrameConstructor
-
>
AddSizeOfIncludingThis
(
aSizes
)
;
}
size_t
PresShell
:
:
SizeOfTextRuns
(
MallocSizeOf
aMallocSizeOf
)
const
{
nsIFrame
*
rootFrame
=
mFrameConstructor
-
>
GetRootFrame
(
)
;
if
(
!
rootFrame
)
{
return
0
;
}
nsLayoutUtils
:
:
SizeOfTextRunsForFrames
(
rootFrame
nullptr
true
)
;
return
nsLayoutUtils
:
:
SizeOfTextRunsForFrames
(
rootFrame
aMallocSizeOf
false
)
;
}
void
PresShell
:
:
MarkFixedFramesForReflow
(
IntrinsicDirty
aIntrinsicDirty
)
{
nsIFrame
*
rootFrame
=
mFrameConstructor
-
>
GetRootFrame
(
)
;
if
(
rootFrame
)
{
const
nsFrameList
&
childList
=
rootFrame
-
>
GetChildList
(
nsIFrame
:
:
kFixedList
)
;
for
(
nsIFrame
*
childFrame
:
childList
)
{
FrameNeedsReflow
(
childFrame
aIntrinsicDirty
NS_FRAME_IS_DIRTY
)
;
}
}
}
static
void
AppendSubtree
(
nsIDocShell
*
aDocShell
nsTArray
<
nsCOMPtr
<
nsIContentViewer
>
>
&
aArray
)
{
if
(
nsCOMPtr
<
nsIContentViewer
>
cv
=
aDocShell
-
>
GetContentViewer
(
)
)
{
aArray
.
AppendElement
(
cv
)
;
}
int32_t
n
=
aDocShell
-
>
GetInProcessChildCount
(
)
;
for
(
int32_t
i
=
0
;
i
<
n
;
i
+
+
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
childItem
;
aDocShell
-
>
GetInProcessChildAt
(
i
getter_AddRefs
(
childItem
)
)
;
if
(
childItem
)
{
nsCOMPtr
<
nsIDocShell
>
child
(
do_QueryInterface
(
childItem
)
)
;
AppendSubtree
(
child
aArray
)
;
}
}
}
void
PresShell
:
:
MaybeReflowForInflationScreenSizeChange
(
)
{
nsPresContext
*
pc
=
GetPresContext
(
)
;
const
bool
fontInflationWasEnabled
=
FontSizeInflationEnabled
(
)
;
RecomputeFontSizeInflationEnabled
(
)
;
bool
changed
=
false
;
if
(
FontSizeInflationEnabled
(
)
&
&
FontSizeInflationMinTwips
(
)
!
=
0
)
{
pc
-
>
ScreenSizeInchesForFontInflation
(
&
changed
)
;
}
changed
=
changed
|
|
fontInflationWasEnabled
!
=
FontSizeInflationEnabled
(
)
;
if
(
!
changed
)
{
return
;
}
if
(
nsCOMPtr
<
nsIDocShell
>
docShell
=
pc
-
>
GetDocShell
(
)
)
{
nsTArray
<
nsCOMPtr
<
nsIContentViewer
>
>
array
;
AppendSubtree
(
docShell
array
)
;
for
(
uint32_t
i
=
0
iEnd
=
array
.
Length
(
)
;
i
<
iEnd
;
+
+
i
)
{
nsCOMPtr
<
nsIContentViewer
>
cv
=
array
[
i
]
;
if
(
RefPtr
<
PresShell
>
descendantPresShell
=
cv
-
>
GetPresShell
(
)
)
{
nsIFrame
*
rootFrame
=
descendantPresShell
-
>
GetRootFrame
(
)
;
if
(
rootFrame
)
{
descendantPresShell
-
>
FrameNeedsReflow
(
rootFrame
IntrinsicDirty
:
:
StyleChange
NS_FRAME_IS_DIRTY
)
;
}
}
}
}
}
void
PresShell
:
:
CompleteChangeToVisualViewportSize
(
)
{
if
(
!
mIsReflowing
)
{
if
(
nsIScrollableFrame
*
rootScrollFrame
=
GetRootScrollFrameAsScrollable
(
)
)
{
rootScrollFrame
-
>
MarkScrollbarsDirtyForReflow
(
)
;
}
MarkFixedFramesForReflow
(
IntrinsicDirty
:
:
Resize
)
;
}
MaybeReflowForInflationScreenSizeChange
(
)
;
if
(
auto
*
window
=
nsGlobalWindowInner
:
:
Cast
(
mDocument
-
>
GetInnerWindow
(
)
)
)
{
window
-
>
VisualViewport
(
)
-
>
PostResizeEvent
(
)
;
}
}
void
PresShell
:
:
SetVisualViewportSize
(
nscoord
aWidth
nscoord
aHeight
)
{
MOZ_ASSERT
(
aWidth
>
=
0
.
0
&
&
aHeight
>
=
0
.
0
)
;
if
(
!
mVisualViewportSizeSet
|
|
mVisualViewportSize
.
width
!
=
aWidth
|
|
mVisualViewportSize
.
height
!
=
aHeight
)
{
mVisualViewportSizeSet
=
true
;
mVisualViewportSize
.
width
=
aWidth
;
mVisualViewportSize
.
height
=
aHeight
;
CompleteChangeToVisualViewportSize
(
)
;
}
}
void
PresShell
:
:
ResetVisualViewportSize
(
)
{
if
(
mVisualViewportSizeSet
)
{
mVisualViewportSizeSet
=
false
;
mVisualViewportSize
.
width
=
0
;
mVisualViewportSize
.
height
=
0
;
CompleteChangeToVisualViewportSize
(
)
;
}
}
bool
PresShell
:
:
SetVisualViewportOffset
(
const
nsPoint
&
aScrollOffset
const
nsPoint
&
aPrevLayoutScrollPos
)
{
nsPoint
newOffset
=
aScrollOffset
;
nsIScrollableFrame
*
rootScrollFrame
=
GetRootScrollFrameAsScrollable
(
)
;
if
(
rootScrollFrame
)
{
nsRect
scrollRange
=
rootScrollFrame
-
>
GetScrollRangeForUserInputEvents
(
)
;
if
(
!
scrollRange
.
Contains
(
newOffset
)
)
{
newOffset
.
x
=
std
:
:
min
(
newOffset
.
x
scrollRange
.
XMost
(
)
)
;
newOffset
.
x
=
std
:
:
max
(
newOffset
.
x
scrollRange
.
x
)
;
newOffset
.
y
=
std
:
:
min
(
newOffset
.
y
scrollRange
.
YMost
(
)
)
;
newOffset
.
y
=
std
:
:
max
(
newOffset
.
y
scrollRange
.
y
)
;
}
}
nsPoint
prevOffset
=
GetVisualViewportOffset
(
)
;
if
(
prevOffset
=
=
newOffset
)
{
return
false
;
}
mVisualViewportOffset
=
Some
(
newOffset
)
;
if
(
auto
*
window
=
nsGlobalWindowInner
:
:
Cast
(
mDocument
-
>
GetInnerWindow
(
)
)
)
{
window
-
>
VisualViewport
(
)
-
>
PostScrollEvent
(
prevOffset
aPrevLayoutScrollPos
)
;
}
if
(
IsVisualViewportSizeSet
(
)
&
&
rootScrollFrame
)
{
rootScrollFrame
-
>
Anchor
(
)
-
>
UserScrolled
(
)
;
}
if
(
gfxPlatform
:
:
UseDesktopZoomingScrollbars
(
)
)
{
if
(
nsIScrollableFrame
*
rootScrollFrame
=
GetRootScrollFrameAsScrollable
(
)
)
{
rootScrollFrame
-
>
UpdateScrollbarPosition
(
)
;
}
}
return
true
;
}
void
PresShell
:
:
ScrollToVisual
(
const
nsPoint
&
aVisualViewportOffset
FrameMetrics
:
:
ScrollOffsetUpdateType
aUpdateType
ScrollMode
aMode
)
{
MOZ_ASSERT
(
aMode
=
=
ScrollMode
:
:
Instant
|
|
aMode
=
=
ScrollMode
:
:
SmoothMsd
)
;
if
(
aMode
=
=
ScrollMode
:
:
SmoothMsd
)
{
if
(
nsIScrollableFrame
*
sf
=
GetRootScrollFrameAsScrollable
(
)
)
{
if
(
sf
-
>
SmoothScrollVisual
(
aVisualViewportOffset
aUpdateType
)
)
{
return
;
}
}
}
SetPendingVisualScrollUpdate
(
aVisualViewportOffset
aUpdateType
)
;
}
void
PresShell
:
:
SetPendingVisualScrollUpdate
(
const
nsPoint
&
aVisualViewportOffset
FrameMetrics
:
:
ScrollOffsetUpdateType
aUpdateType
)
{
mPendingVisualScrollUpdate
=
Some
(
VisualScrollUpdate
{
aVisualViewportOffset
aUpdateType
}
)
;
if
(
nsIFrame
*
rootFrame
=
GetRootFrame
(
)
)
{
rootFrame
-
>
SchedulePaint
(
)
;
}
}
void
PresShell
:
:
ClearPendingVisualScrollUpdate
(
)
{
if
(
mPendingVisualScrollUpdate
&
&
mPendingVisualScrollUpdate
-
>
mAcknowledged
)
{
mPendingVisualScrollUpdate
=
mozilla
:
:
Nothing
(
)
;
}
}
void
PresShell
:
:
AcknowledgePendingVisualScrollUpdate
(
)
{
MOZ_ASSERT
(
mPendingVisualScrollUpdate
)
;
mPendingVisualScrollUpdate
-
>
mAcknowledged
=
true
;
}
nsPoint
PresShell
:
:
GetVisualViewportOffsetRelativeToLayoutViewport
(
)
const
{
return
GetVisualViewportOffset
(
)
-
GetLayoutViewportOffset
(
)
;
}
nsPoint
PresShell
:
:
GetLayoutViewportOffset
(
)
const
{
nsPoint
result
;
if
(
nsIScrollableFrame
*
sf
=
GetRootScrollFrameAsScrollable
(
)
)
{
result
=
sf
-
>
GetScrollPosition
(
)
;
}
return
result
;
}
nsSize
PresShell
:
:
GetLayoutViewportSize
(
)
const
{
nsSize
result
;
if
(
nsIScrollableFrame
*
sf
=
GetRootScrollFrameAsScrollable
(
)
)
{
result
=
sf
-
>
GetScrollPortRect
(
)
.
Size
(
)
;
}
return
result
;
}
nsSize
PresShell
:
:
GetVisualViewportSizeUpdatedByDynamicToolbar
(
)
const
{
NS_ASSERTION
(
mVisualViewportSizeSet
"
asking
for
visual
viewport
size
when
its
not
set
?
"
)
;
if
(
!
mMobileViewportManager
)
{
return
mVisualViewportSize
;
}
MOZ_ASSERT
(
GetDynamicToolbarState
(
)
=
=
DynamicToolbarState
:
:
InTransition
|
|
GetDynamicToolbarState
(
)
=
=
DynamicToolbarState
:
:
Collapsed
)
;
nsSize
sizeUpdatedByDynamicToolbar
=
mMobileViewportManager
-
>
GetVisualViewportSizeUpdatedByDynamicToolbar
(
)
;
return
sizeUpdatedByDynamicToolbar
=
=
nsSize
(
)
?
mVisualViewportSize
:
sizeUpdatedByDynamicToolbar
;
}
void
PresShell
:
:
RecomputeFontSizeInflationEnabled
(
)
{
mFontSizeInflationEnabled
=
DetermineFontSizeInflationState
(
)
;
float
fontScale
=
StaticPrefs
:
:
font_size_systemFontScale
(
)
/
100
.
0f
;
if
(
fontScale
=
=
0
.
0f
)
{
return
;
}
MOZ_ASSERT
(
mDocument
)
;
MOZ_ASSERT
(
mPresContext
)
;
if
(
mFontSizeInflationEnabled
|
|
mDocument
-
>
IsSyntheticDocument
(
)
)
{
mPresContext
-
>
SetSystemFontScale
(
1
.
0f
)
;
}
else
{
mPresContext
-
>
SetSystemFontScale
(
fontScale
)
;
}
}
bool
PresShell
:
:
DetermineFontSizeInflationState
(
)
{
MOZ_ASSERT
(
mPresContext
"
our
pres
context
should
not
be
null
"
)
;
if
(
mPresContext
-
>
IsChrome
(
)
)
{
return
false
;
}
if
(
FontSizeInflationEmPerLine
(
)
=
=
0
&
&
FontSizeInflationMinTwips
(
)
=
=
0
)
{
return
false
;
}
if
(
!
FontSizeInflationForceEnabled
(
)
)
{
if
(
BrowserChild
*
tab
=
BrowserChild
:
:
GetFrom
(
this
)
)
{
if
(
!
tab
-
>
AsyncPanZoomEnabled
(
)
)
{
return
false
;
}
}
else
if
(
XRE_IsParentProcess
(
)
)
{
if
(
FontSizeInflationDisabledInMasterProcess
(
)
)
{
return
false
;
}
}
}
nsresult
rv
;
nsCOMPtr
<
nsIScreenManager
>
screenMgr
=
do_GetService
(
"
mozilla
.
org
/
gfx
/
screenmanager
;
1
"
&
rv
)
;
if
(
!
NS_SUCCEEDED
(
rv
)
)
{
return
false
;
}
nsCOMPtr
<
nsIScreen
>
screen
;
screenMgr
-
>
GetPrimaryScreen
(
getter_AddRefs
(
screen
)
)
;
if
(
screen
)
{
int32_t
screenLeft
screenTop
screenWidth
screenHeight
;
screen
-
>
GetRect
(
&
screenLeft
&
screenTop
&
screenWidth
&
screenHeight
)
;
nsViewportInfo
vInf
=
GetDocument
(
)
-
>
GetViewportInfo
(
ScreenIntSize
(
screenWidth
screenHeight
)
)
;
if
(
vInf
.
GetDefaultZoom
(
)
>
=
CSSToScreenScale
(
1
.
0f
)
|
|
vInf
.
IsAutoSizeEnabled
(
)
)
{
return
false
;
}
}
return
true
;
}
void
PresShell
:
:
SyncWindowProperties
(
nsView
*
aView
)
{
nsIFrame
*
frame
=
aView
-
>
GetFrame
(
)
;
if
(
frame
&
&
mPresContext
)
{
RefPtr
<
gfxContext
>
rcx
(
CreateReferenceRenderingContext
(
)
)
;
nsContainerFrame
:
:
SyncWindowProperties
(
mPresContext
frame
aView
rcx
0
)
;
}
}
nsresult
PresShell
:
:
HasRuleProcessorUsedByMultipleStyleSets
(
uint32_t
aSheetType
bool
*
aRetVal
)
{
*
aRetVal
=
false
;
return
NS_OK
;
}
void
PresShell
:
:
NotifyStyleSheetServiceSheetAdded
(
StyleSheet
*
aSheet
uint32_t
aSheetType
)
{
switch
(
aSheetType
)
{
case
nsIStyleSheetService
:
:
AGENT_SHEET
:
AddAgentSheet
(
aSheet
)
;
break
;
case
nsIStyleSheetService
:
:
USER_SHEET
:
AddUserSheet
(
aSheet
)
;
break
;
case
nsIStyleSheetService
:
:
AUTHOR_SHEET
:
AddAuthorSheet
(
aSheet
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
aSheetType
value
"
)
;
break
;
}
}
void
PresShell
:
:
NotifyStyleSheetServiceSheetRemoved
(
StyleSheet
*
aSheet
uint32_t
aSheetType
)
{
StyleSet
(
)
-
>
RemoveStyleSheet
(
*
aSheet
)
;
mDocument
-
>
ApplicableStylesChanged
(
)
;
}
void
PresShell
:
:
SetIsUnderHiddenEmbedderElement
(
bool
aUnderHiddenEmbedderElement
)
{
if
(
mUnderHiddenEmbedderElement
=
=
aUnderHiddenEmbedderElement
)
{
return
;
}
mUnderHiddenEmbedderElement
=
aUnderHiddenEmbedderElement
;
if
(
nsCOMPtr
<
nsIDocShell
>
docShell
=
mPresContext
-
>
GetDocShell
(
)
)
{
BrowsingContext
*
bc
=
docShell
-
>
GetBrowsingContext
(
)
;
for
(
BrowsingContext
*
child
:
bc
-
>
Children
(
)
)
{
Element
*
embedderElement
=
child
-
>
GetEmbedderElement
(
)
;
if
(
!
embedderElement
)
{
continue
;
}
bool
embedderFrameIsHidden
=
true
;
if
(
auto
embedderFrame
=
embedderElement
-
>
GetPrimaryFrame
(
)
)
{
embedderFrameIsHidden
=
!
embedderFrame
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
;
}
if
(
nsIDocShell
*
childDocShell
=
child
-
>
GetDocShell
(
)
)
{
PresShell
*
presShell
=
childDocShell
-
>
GetPresShell
(
)
;
if
(
!
presShell
)
{
continue
;
}
presShell
-
>
SetIsUnderHiddenEmbedderElement
(
aUnderHiddenEmbedderElement
|
|
embedderFrameIsHidden
)
;
}
else
{
BrowserBridgeChild
*
bridgeChild
=
BrowserBridgeChild
:
:
GetFrom
(
embedderElement
)
;
bridgeChild
-
>
SetIsUnderHiddenEmbedderElement
(
aUnderHiddenEmbedderElement
|
|
embedderFrameIsHidden
)
;
}
}
}
}
nsIContent
*
PresShell
:
:
EventHandler
:
:
GetOverrideClickTarget
(
WidgetGUIEvent
*
aGUIEvent
nsIFrame
*
aFrame
)
{
if
(
aGUIEvent
-
>
mMessage
!
=
eMouseUp
)
{
return
nullptr
;
}
MOZ_ASSERT
(
aGUIEvent
-
>
mClass
=
=
eMouseEventClass
)
;
WidgetMouseEvent
*
mouseEvent
=
aGUIEvent
-
>
AsMouseEvent
(
)
;
uint32_t
flags
=
0
;
RelativeTo
relativeTo
{
aFrame
}
;
nsPoint
eventPoint
=
nsLayoutUtils
:
:
GetEventCoordinatesRelativeTo
(
aGUIEvent
relativeTo
)
;
if
(
mouseEvent
-
>
mIgnoreRootScrollFrame
)
{
flags
|
=
INPUT_IGNORE_ROOT_SCROLL_FRAME
;
}
nsIFrame
*
target
=
FindFrameTargetedByInputEvent
(
aGUIEvent
relativeTo
eventPoint
flags
)
;
if
(
!
target
)
{
return
nullptr
;
}
nsIContent
*
overrideClickTarget
=
target
-
>
GetContent
(
)
;
while
(
overrideClickTarget
&
&
!
overrideClickTarget
-
>
IsElement
(
)
)
{
overrideClickTarget
=
overrideClickTarget
-
>
GetFlattenedTreeParent
(
)
;
}
return
overrideClickTarget
;
}
void
PresShell
:
:
EventHandler
:
:
EventTargetData
:
:
SetFrameAndComputePresShell
(
nsIFrame
*
aFrameToHandleEvent
)
{
if
(
aFrameToHandleEvent
)
{
mFrame
=
aFrameToHandleEvent
;
mPresShell
=
aFrameToHandleEvent
-
>
PresShell
(
)
;
}
else
{
mFrame
=
nullptr
;
mPresShell
=
nullptr
;
}
}
void
PresShell
:
:
EventHandler
:
:
EventTargetData
:
:
SetFrameAndComputePresShellAndContent
(
nsIFrame
*
aFrameToHandleEvent
WidgetGUIEvent
*
aGUIEvent
)
{
MOZ_ASSERT
(
aFrameToHandleEvent
)
;
MOZ_ASSERT
(
aGUIEvent
)
;
SetFrameAndComputePresShell
(
aFrameToHandleEvent
)
;
SetContentForEventFromFrame
(
aGUIEvent
)
;
}
void
PresShell
:
:
EventHandler
:
:
EventTargetData
:
:
SetContentForEventFromFrame
(
WidgetGUIEvent
*
aGUIEvent
)
{
MOZ_ASSERT
(
mFrame
)
;
mContent
=
nullptr
;
mFrame
-
>
GetContentForEvent
(
aGUIEvent
getter_AddRefs
(
mContent
)
)
;
}
nsIContent
*
PresShell
:
:
EventHandler
:
:
EventTargetData
:
:
GetFrameContent
(
)
const
{
return
mFrame
?
mFrame
-
>
GetContent
(
)
:
nullptr
;
}
bool
PresShell
:
:
EventHandler
:
:
EventTargetData
:
:
MaybeRetargetToActiveDocument
(
WidgetGUIEvent
*
aGUIEvent
)
{
MOZ_ASSERT
(
aGUIEvent
)
;
MOZ_ASSERT
(
mFrame
)
;
MOZ_ASSERT
(
mPresShell
)
;
MOZ_ASSERT
(
!
mContent
"
Doesn
'
t
support
to
retarget
the
content
"
)
;
EventStateManager
*
activeESM
=
EventStateManager
:
:
GetActiveEventStateManager
(
)
;
if
(
!
activeESM
)
{
return
false
;
}
if
(
aGUIEvent
-
>
mClass
!
=
ePointerEventClass
&
&
!
aGUIEvent
-
>
HasMouseEventMessage
(
)
)
{
return
false
;
}
if
(
activeESM
=
=
GetEventStateManager
(
)
)
{
return
false
;
}
nsPresContext
*
activePresContext
=
activeESM
-
>
GetPresContext
(
)
;
if
(
!
activePresContext
)
{
return
false
;
}
PresShell
*
activePresShell
=
activePresContext
-
>
GetPresShell
(
)
;
if
(
!
activePresShell
)
{
return
false
;
}
if
(
!
nsContentUtils
:
:
ContentIsCrossDocDescendantOf
(
activePresShell
-
>
GetDocument
(
)
GetDocument
(
)
)
)
{
return
false
;
}
SetFrameAndComputePresShell
(
activePresShell
-
>
GetRootFrame
(
)
)
;
return
true
;
}
bool
PresShell
:
:
EventHandler
:
:
EventTargetData
:
:
ComputeElementFromFrame
(
WidgetGUIEvent
*
aGUIEvent
)
{
MOZ_ASSERT
(
aGUIEvent
)
;
MOZ_ASSERT
(
aGUIEvent
-
>
IsUsingCoordinates
(
)
)
;
MOZ_ASSERT
(
mPresShell
)
;
MOZ_ASSERT
(
mFrame
)
;
SetContentForEventFromFrame
(
aGUIEvent
)
;
if
(
!
mContent
)
{
return
true
;
}
nsIContent
*
content
=
mContent
;
while
(
content
&
&
!
content
-
>
IsElement
(
)
)
{
content
=
content
-
>
GetFlattenedTreeParent
(
)
;
}
mContent
=
content
;
return
!
!
mContent
;
}
void
PresShell
:
:
EventHandler
:
:
EventTargetData
:
:
UpdateTouchEventTarget
(
WidgetGUIEvent
*
aGUIEvent
)
{
MOZ_ASSERT
(
aGUIEvent
)
;
if
(
aGUIEvent
-
>
mClass
!
=
eTouchEventClass
)
{
return
;
}
if
(
aGUIEvent
-
>
mMessage
=
=
eTouchStart
)
{
WidgetTouchEvent
*
touchEvent
=
aGUIEvent
-
>
AsTouchEvent
(
)
;
nsIFrame
*
newFrame
=
TouchManager
:
:
SuppressInvalidPointsAndGetTargetedFrame
(
touchEvent
)
;
if
(
!
newFrame
)
{
return
;
}
SetFrameAndComputePresShellAndContent
(
newFrame
aGUIEvent
)
;
return
;
}
PresShell
*
newPresShell
=
PresShell
:
:
GetShellForTouchEvent
(
aGUIEvent
)
;
if
(
!
newPresShell
)
{
return
;
}
mPresShell
=
newPresShell
;
}
PresShell
:
:
EventHandler
:
:
HandlingTimeAccumulator
:
:
HandlingTimeAccumulator
(
const
PresShell
:
:
EventHandler
&
aEventHandler
const
WidgetEvent
*
aEvent
)
:
mEventHandler
(
aEventHandler
)
mEvent
(
aEvent
)
mHandlingStartTime
(
TimeStamp
:
:
Now
(
)
)
{
MOZ_ASSERT
(
mEvent
)
;
MOZ_ASSERT
(
mEvent
-
>
IsTrusted
(
)
)
;
}
PresShell
:
:
EventHandler
:
:
HandlingTimeAccumulator
:
:
~
HandlingTimeAccumulator
(
)
{
if
(
mEvent
-
>
mTimeStamp
<
=
mEventHandler
.
mPresShell
-
>
mLastOSWake
)
{
return
;
}
switch
(
mEvent
-
>
mMessage
)
{
case
eKeyPress
:
case
eKeyDown
:
case
eKeyUp
:
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
INPUT_EVENT_HANDLED_KEYBOARD_MS
mHandlingStartTime
)
;
return
;
case
eMouseDown
:
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
INPUT_EVENT_HANDLED_MOUSE_DOWN_MS
mHandlingStartTime
)
;
return
;
case
eMouseUp
:
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
INPUT_EVENT_HANDLED_MOUSE_UP_MS
mHandlingStartTime
)
;
return
;
case
eMouseMove
:
if
(
mEvent
-
>
mFlags
.
mHandledByAPZ
)
{
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
INPUT_EVENT_HANDLED_APZ_MOUSE_MOVE_MS
mHandlingStartTime
)
;
}
return
;
case
eWheel
:
if
(
mEvent
-
>
mFlags
.
mHandledByAPZ
)
{
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
INPUT_EVENT_HANDLED_APZ_WHEEL_MS
mHandlingStartTime
)
;
}
return
;
case
eTouchMove
:
if
(
mEvent
-
>
mFlags
.
mHandledByAPZ
)
{
Telemetry
:
:
AccumulateTimeDelta
(
Telemetry
:
:
INPUT_EVENT_HANDLED_APZ_TOUCH_MOVE_MS
mHandlingStartTime
)
;
}
return
;
default
:
return
;
}
}
void
PresShell
:
:
EndPaint
(
)
{
ClearPendingVisualScrollUpdate
(
)
;
if
(
mDocument
)
{
mDocument
-
>
EnumerateSubDocuments
(
[
]
(
Document
&
aSubDoc
)
{
if
(
PresShell
*
presShell
=
aSubDoc
.
GetPresShell
(
)
)
{
presShell
-
>
EndPaint
(
)
;
}
return
CallState
:
:
Continue
;
}
)
;
}
}
void
PresShell
:
:
PingPerTickTelemetry
(
FlushType
aFlushType
)
{
mLayoutTelemetry
.
PingPerTickTelemetry
(
aFlushType
)
;
}
bool
PresShell
:
:
GetZoomableByAPZ
(
)
const
{
return
mZoomConstraintsClient
&
&
mZoomConstraintsClient
-
>
GetAllowZoom
(
)
;
}
