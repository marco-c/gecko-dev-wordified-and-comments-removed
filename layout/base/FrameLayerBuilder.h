#
ifndef
FRAMELAYERBUILDER_H_
#
define
FRAMELAYERBUILDER_H_
#
include
"
nsTHashtable
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
DisplayItemClip
.
h
"
#
include
"
mozilla
/
gfx
/
MatrixFwd
.
h
"
#
include
"
mozilla
/
layers
/
LayersTypes
.
h
"
#
include
"
LayerState
.
h
"
#
include
"
LayerUserData
.
h
"
class
nsDisplayListBuilder
;
class
nsDisplayList
;
class
nsDisplayItem
;
class
gfxContext
;
class
nsDisplayItemGeometry
;
namespace
mozilla
{
class
DisplayItemScrollClip
;
namespace
layers
{
class
ContainerLayer
;
class
LayerManager
;
class
BasicLayerManager
;
class
PaintedLayer
;
class
ImageLayer
;
}
class
FrameLayerBuilder
;
class
LayerManagerData
;
class
PaintedLayerData
;
class
ContainerState
;
class
RefCountedRegion
{
private
:
~
RefCountedRegion
(
)
{
}
public
:
NS_INLINE_DECL_REFCOUNTING
(
RefCountedRegion
)
RefCountedRegion
(
)
:
mIsInfinite
(
false
)
{
}
nsRegion
mRegion
;
bool
mIsInfinite
;
}
;
struct
ContainerLayerParameters
{
ContainerLayerParameters
(
)
:
mXScale
(
1
)
mYScale
(
1
)
mLayerContentsVisibleRect
(
nullptr
)
mBackgroundColor
(
NS_RGBA
(
0
0
0
0
)
)
mScrollClip
(
nullptr
)
mInTransformedSubtree
(
false
)
mInActiveTransformedSubtree
(
false
)
mDisableSubpixelAntialiasingInDescendants
(
false
)
mInLowPrecisionDisplayPort
(
false
)
mForEventsOnly
(
false
)
{
}
ContainerLayerParameters
(
float
aXScale
float
aYScale
)
:
mXScale
(
aXScale
)
mYScale
(
aYScale
)
mLayerContentsVisibleRect
(
nullptr
)
mBackgroundColor
(
NS_RGBA
(
0
0
0
0
)
)
mScrollClip
(
nullptr
)
mInTransformedSubtree
(
false
)
mInActiveTransformedSubtree
(
false
)
mDisableSubpixelAntialiasingInDescendants
(
false
)
mInLowPrecisionDisplayPort
(
false
)
mForEventsOnly
(
false
)
{
}
ContainerLayerParameters
(
float
aXScale
float
aYScale
const
nsIntPoint
&
aOffset
const
ContainerLayerParameters
&
aParent
)
:
mXScale
(
aXScale
)
mYScale
(
aYScale
)
mLayerContentsVisibleRect
(
nullptr
)
mOffset
(
aOffset
)
mBackgroundColor
(
aParent
.
mBackgroundColor
)
mScrollClip
(
aParent
.
mScrollClip
)
mInTransformedSubtree
(
aParent
.
mInTransformedSubtree
)
mInActiveTransformedSubtree
(
aParent
.
mInActiveTransformedSubtree
)
mDisableSubpixelAntialiasingInDescendants
(
aParent
.
mDisableSubpixelAntialiasingInDescendants
)
mInLowPrecisionDisplayPort
(
aParent
.
mInLowPrecisionDisplayPort
)
mForEventsOnly
(
aParent
.
mForEventsOnly
)
{
}
float
mXScale
mYScale
;
LayoutDeviceToLayerScale2D
Scale
(
)
const
{
return
LayoutDeviceToLayerScale2D
(
mXScale
mYScale
)
;
}
nsIntRect
*
mLayerContentsVisibleRect
;
nsIntPoint
mOffset
;
LayerIntPoint
Offset
(
)
const
{
return
LayerIntPoint
:
:
FromUnknownPoint
(
mOffset
)
;
}
nscolor
mBackgroundColor
;
const
DisplayItemScrollClip
*
mScrollClip
;
bool
mInTransformedSubtree
;
bool
mInActiveTransformedSubtree
;
bool
mDisableSubpixelAntialiasingInDescendants
;
bool
mInLowPrecisionDisplayPort
;
bool
mForEventsOnly
;
bool
AllowResidualTranslation
(
)
{
return
mInTransformedSubtree
&
&
!
mInActiveTransformedSubtree
;
}
}
;
class
FrameLayerBuilder
:
public
layers
:
:
LayerUserData
{
public
:
typedef
layers
:
:
ContainerLayer
ContainerLayer
;
typedef
layers
:
:
Layer
Layer
;
typedef
layers
:
:
PaintedLayer
PaintedLayer
;
typedef
layers
:
:
ImageLayer
ImageLayer
;
typedef
layers
:
:
LayerManager
LayerManager
;
typedef
layers
:
:
BasicLayerManager
BasicLayerManager
;
typedef
layers
:
:
EventRegions
EventRegions
;
FrameLayerBuilder
(
)
;
~
FrameLayerBuilder
(
)
;
static
void
Shutdown
(
)
;
void
Init
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
PaintedLayerData
*
aLayerData
=
nullptr
)
;
void
DidBeginRetainedLayerTransaction
(
LayerManager
*
aManager
)
;
void
WillEndTransaction
(
)
;
void
DidEndTransaction
(
)
;
enum
{
CONTAINER_NOT_CLIPPED_BY_ANCESTORS
=
0x01
CONTAINER_ALLOW_PULL_BACKGROUND_COLOR
=
0x02
}
;
already_AddRefed
<
ContainerLayer
>
BuildContainerLayerFor
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
nsIFrame
*
aContainerFrame
nsDisplayItem
*
aContainerItem
nsDisplayList
*
aChildren
const
ContainerLayerParameters
&
aContainerParameters
const
gfx
:
:
Matrix4x4
*
aTransform
uint32_t
aFlags
=
0
)
;
Layer
*
GetLeafLayerFor
(
nsDisplayListBuilder
*
aBuilder
nsDisplayItem
*
aItem
)
;
static
void
InvalidateAllLayers
(
LayerManager
*
aManager
)
;
static
void
InvalidateAllLayersForFrame
(
nsIFrame
*
aFrame
)
;
static
Layer
*
GetDedicatedLayer
(
nsIFrame
*
aFrame
uint32_t
aDisplayItemKey
)
;
static
void
DrawPaintedLayer
(
PaintedLayer
*
aLayer
gfxContext
*
aContext
const
nsIntRegion
&
aRegionToDraw
const
nsIntRegion
&
aDirtyRegion
mozilla
:
:
layers
:
:
DrawRegionClip
aClip
const
nsIntRegion
&
aRegionToInvalidate
void
*
aCallbackData
)
;
static
void
DumpRetainedLayerTree
(
LayerManager
*
aManager
std
:
:
stringstream
&
aStream
bool
aDumpHtml
=
false
)
;
static
nsDisplayItemGeometry
*
GetMostRecentGeometry
(
nsDisplayItem
*
aItem
)
;
void
AddLayerDisplayItem
(
Layer
*
aLayer
nsDisplayItem
*
aItem
LayerState
aLayerState
BasicLayerManager
*
aManager
)
;
void
AddPaintedDisplayItem
(
PaintedLayerData
*
aLayer
nsDisplayItem
*
aItem
const
DisplayItemClip
&
aClip
ContainerState
&
aContainerState
LayerState
aLayerState
const
nsPoint
&
aTopLeft
)
;
Layer
*
GetOldLayerFor
(
nsDisplayItem
*
aItem
nsDisplayItemGeometry
*
*
aOldGeometry
=
nullptr
DisplayItemClip
*
*
aOldClip
=
nullptr
)
;
void
ClearCachedGeometry
(
nsDisplayItem
*
aItem
)
;
static
Layer
*
GetDebugOldLayerFor
(
nsIFrame
*
aFrame
uint32_t
aDisplayItemKey
)
;
static
PaintedLayer
*
GetDebugSingleOldPaintedLayerForFrame
(
nsIFrame
*
aFrame
)
;
static
void
DestroyDisplayItemDataFor
(
nsIFrame
*
aFrame
)
;
LayerManager
*
GetRetainingLayerManager
(
)
{
return
mRetainingManager
;
}
static
bool
HasRetainedDataFor
(
nsIFrame
*
aFrame
uint32_t
aDisplayItemKey
)
;
class
DisplayItemData
;
typedef
void
(
*
DisplayItemDataCallback
)
(
nsIFrame
*
aFrame
DisplayItemData
*
aItem
)
;
static
void
IterateRetainedDataFor
(
nsIFrame
*
aFrame
DisplayItemDataCallback
aCallback
)
;
void
SavePreviousDataForLayer
(
PaintedLayer
*
aLayer
uint32_t
aClipCount
)
;
nsIntPoint
GetLastPaintOffset
(
PaintedLayer
*
aLayer
)
;
static
gfxSize
GetPaintedLayerScaleForFrame
(
nsIFrame
*
aFrame
)
;
void
StoreOptimizedLayerForFrame
(
nsDisplayItem
*
aItem
Layer
*
aLayer
)
;
NS_DECLARE_FRAME_PROPERTY_WITH_FRAME_IN_DTOR
(
LayerManagerDataProperty
nsTArray
<
DisplayItemData
*
>
RemoveFrameFromLayerManager
)
class
DisplayItemData
final
{
public
:
friend
class
FrameLayerBuilder
;
uint32_t
GetDisplayItemKey
(
)
{
return
mDisplayItemKey
;
}
Layer
*
GetLayer
(
)
{
return
mLayer
;
}
nsDisplayItemGeometry
*
GetGeometry
(
)
const
{
return
mGeometry
.
get
(
)
;
}
void
Invalidate
(
)
{
mIsInvalid
=
true
;
}
void
ClearAnimationCompositorState
(
)
;
private
:
DisplayItemData
(
LayerManagerData
*
aParent
uint32_t
aKey
Layer
*
aLayer
nsIFrame
*
aFrame
=
nullptr
)
;
~
DisplayItemData
(
)
;
NS_INLINE_DECL_REFCOUNTING
(
DisplayItemData
)
void
AddFrame
(
nsIFrame
*
aFrame
)
;
void
RemoveFrame
(
nsIFrame
*
aFrame
)
;
const
nsTArray
<
nsIFrame
*
>
&
GetFrameListChanges
(
)
;
void
BeginUpdate
(
Layer
*
aLayer
LayerState
aState
uint32_t
aContainerLayerGeneration
nsDisplayItem
*
aItem
=
nullptr
)
;
void
EndUpdate
(
nsAutoPtr
<
nsDisplayItemGeometry
>
aGeometry
)
;
void
EndUpdate
(
)
;
LayerManagerData
*
mParent
;
RefPtr
<
Layer
>
mLayer
;
RefPtr
<
Layer
>
mOptLayer
;
RefPtr
<
BasicLayerManager
>
mInactiveManager
;
nsAutoTArray
<
nsIFrame
*
1
>
mFrameList
;
nsAutoPtr
<
nsDisplayItemGeometry
>
mGeometry
;
DisplayItemClip
mClip
;
uint32_t
mDisplayItemKey
;
uint32_t
mContainerLayerGeneration
;
LayerState
mLayerState
;
nsDisplayItem
*
mItem
;
nsAutoTArray
<
nsIFrame
*
1
>
mFrameListChanges
;
bool
mUsed
;
bool
mIsInvalid
;
}
;
protected
:
friend
class
LayerManagerData
;
static
void
RemoveFrameFromLayerManager
(
const
nsIFrame
*
aFrame
nsTArray
<
DisplayItemData
*
>
*
aArray
)
;
DisplayItemData
*
GetOldLayerForFrame
(
nsIFrame
*
aFrame
uint32_t
aDisplayItemKey
)
;
DisplayItemData
*
StoreDataForFrame
(
nsDisplayItem
*
aItem
Layer
*
aLayer
LayerState
aState
)
;
void
StoreDataForFrame
(
nsIFrame
*
aFrame
uint32_t
aDisplayItemKey
Layer
*
aLayer
LayerState
aState
)
;
static
void
FlashPaint
(
gfxContext
*
aContext
)
;
DisplayItemData
*
GetDisplayItemData
(
nsIFrame
*
aFrame
uint32_t
aKey
)
;
static
DisplayItemData
*
GetDisplayItemDataForManager
(
nsIFrame
*
aFrame
uint32_t
aDisplayItemKey
LayerManager
*
aManager
)
;
static
DisplayItemData
*
GetDisplayItemDataForManager
(
nsIFrame
*
aFrame
uint32_t
aDisplayItemKey
)
;
static
DisplayItemData
*
GetDisplayItemDataForManager
(
nsDisplayItem
*
aItem
LayerManager
*
aManager
)
;
static
DisplayItemData
*
GetDisplayItemDataForManager
(
nsIFrame
*
aFrame
uint32_t
aDisplayItemKey
LayerManagerData
*
aData
)
;
struct
ClippedDisplayItem
{
ClippedDisplayItem
(
nsDisplayItem
*
aItem
uint32_t
aGeneration
)
;
~
ClippedDisplayItem
(
)
;
nsDisplayItem
*
mItem
;
RefPtr
<
LayerManager
>
mInactiveLayerManager
;
uint32_t
mContainerLayerGeneration
;
}
;
static
void
RecomputeVisibilityForItems
(
nsTArray
<
ClippedDisplayItem
>
&
aItems
nsDisplayListBuilder
*
aBuilder
const
nsIntRegion
&
aRegionToDraw
const
nsIntPoint
&
aOffset
int32_t
aAppUnitsPerDevPixel
float
aXScale
float
aYScale
)
;
void
PaintItems
(
nsTArray
<
ClippedDisplayItem
>
&
aItems
const
nsIntRect
&
aRect
gfxContext
*
aContext
nsRenderingContext
*
aRC
nsDisplayListBuilder
*
aBuilder
nsPresContext
*
aPresContext
const
nsIntPoint
&
aOffset
float
aXScale
float
aYScale
int32_t
aCommonClipCount
)
;
public
:
class
PaintedLayerItemsEntry
:
public
nsPtrHashKey
<
PaintedLayer
>
{
public
:
explicit
PaintedLayerItemsEntry
(
const
PaintedLayer
*
key
)
;
PaintedLayerItemsEntry
(
const
PaintedLayerItemsEntry
&
)
;
~
PaintedLayerItemsEntry
(
)
;
nsTArray
<
ClippedDisplayItem
>
mItems
;
nsIFrame
*
mContainerLayerFrame
;
nsIntPoint
mLastPaintOffset
;
uint32_t
mLastCommonClipCount
;
uint32_t
mContainerLayerGeneration
;
bool
mHasExplicitLastPaintOffset
;
uint32_t
mCommonClipCount
;
enum
{
ALLOW_MEMMOVE
=
true
}
;
}
;
PaintedLayerItemsEntry
*
GetPaintedLayerItemsEntry
(
PaintedLayer
*
aLayer
)
{
return
mPaintedLayerItems
.
GetEntry
(
aLayer
)
;
}
PaintedLayerData
*
GetContainingPaintedLayerData
(
)
{
return
mContainingPaintedLayer
;
}
bool
IsBuildingRetainedLayers
(
)
{
return
!
mContainingPaintedLayer
&
&
mRetainingManager
;
}
void
SetLayerTreeCompressionMode
(
)
{
mInLayerTreeCompressionMode
=
true
;
}
bool
CheckInLayerTreeCompressionMode
(
)
;
void
ComputeGeometryChangeForItem
(
DisplayItemData
*
aData
)
;
protected
:
bool
CheckDOMModified
(
)
;
LayerManager
*
mRetainingManager
;
RefPtr
<
nsRootPresContext
>
mRootPresContext
;
nsDisplayListBuilder
*
mDisplayListBuilder
;
nsTHashtable
<
PaintedLayerItemsEntry
>
mPaintedLayerItems
;
PaintedLayerData
*
mContainingPaintedLayer
;
uint32_t
mInitialDOMGeneration
;
bool
mDetectedDOMModification
;
bool
mInvalidateAllLayers
;
bool
mInLayerTreeCompressionMode
;
uint32_t
mContainerLayerGeneration
;
uint32_t
mMaxContainerLayerGeneration
;
}
;
}
#
endif
