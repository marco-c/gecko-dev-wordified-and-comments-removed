#
include
"
nsCaret
.
h
"
#
include
<
algorithm
>
#
include
"
gfxUtils
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsFontMetrics
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsBlockFrame
.
h
"
#
include
"
nsISelectionController
.
h
"
#
include
"
nsTextFrame
.
h
"
#
include
"
nsXULPopupManager
.
h
"
#
include
"
nsMenuPopupFrame
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsIBidiKeyboard
.
h
"
#
include
"
nsContentUtils
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
gfx
;
static
const
int32_t
kMinBidiIndicatorPixels
=
2
;
static
const
uint32_t
kDefaultCaretBlinkRate
=
500
;
static
nsIFrame
*
CheckForTrailingTextFrameRecursive
(
nsIFrame
*
aFrame
nsIFrame
*
aStopAtFrame
)
{
if
(
aFrame
=
=
aStopAtFrame
|
|
(
(
aFrame
-
>
IsTextFrame
(
)
&
&
(
static_cast
<
nsTextFrame
*
>
(
aFrame
)
)
-
>
IsAtEndOfLine
(
)
)
)
)
return
aFrame
;
if
(
!
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eLineParticipant
)
)
return
nullptr
;
for
(
nsIFrame
*
f
:
aFrame
-
>
PrincipalChildList
(
)
)
{
nsIFrame
*
r
=
CheckForTrailingTextFrameRecursive
(
f
aStopAtFrame
)
;
if
(
r
)
return
r
;
}
return
nullptr
;
}
static
nsLineBox
*
FindContainingLine
(
nsIFrame
*
aFrame
)
{
while
(
aFrame
&
&
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eLineParticipant
)
)
{
nsIFrame
*
parent
=
aFrame
-
>
GetParent
(
)
;
nsBlockFrame
*
blockParent
=
do_QueryFrame
(
parent
)
;
if
(
blockParent
)
{
bool
isValid
;
nsBlockInFlowLineIterator
iter
(
blockParent
aFrame
&
isValid
)
;
return
isValid
?
iter
.
GetLine
(
)
.
get
(
)
:
nullptr
;
}
aFrame
=
parent
;
}
return
nullptr
;
}
static
void
AdjustCaretFrameForLineEnd
(
nsIFrame
*
*
aFrame
int32_t
*
aOffset
)
{
nsLineBox
*
line
=
FindContainingLine
(
*
aFrame
)
;
if
(
!
line
)
return
;
int32_t
count
=
line
-
>
GetChildCount
(
)
;
for
(
nsIFrame
*
f
=
line
-
>
mFirstChild
;
count
>
0
;
-
-
count
f
=
f
-
>
GetNextSibling
(
)
)
{
nsIFrame
*
r
=
CheckForTrailingTextFrameRecursive
(
f
*
aFrame
)
;
if
(
r
=
=
*
aFrame
)
{
return
;
}
if
(
r
)
{
MOZ_ASSERT
(
r
-
>
IsTextFrame
(
)
"
Expected
text
frame
"
)
;
*
aFrame
=
r
;
*
aOffset
=
(
static_cast
<
nsTextFrame
*
>
(
r
)
)
-
>
GetContentEnd
(
)
;
return
;
}
}
}
static
bool
IsBidiUI
(
)
{
return
Preferences
:
:
GetBool
(
"
bidi
.
browser
.
ui
"
)
;
}
nsCaret
:
:
nsCaret
(
)
:
mOverrideOffset
(
0
)
mBlinkCount
(
-
1
)
mBlinkRate
(
0
)
mHideCount
(
0
)
mIsBlinkOn
(
false
)
mVisible
(
false
)
mReadOnly
(
false
)
mShowDuringSelection
(
false
)
mIgnoreUserModify
(
true
)
{
}
nsCaret
:
:
~
nsCaret
(
)
{
StopBlinking
(
)
;
}
nsresult
nsCaret
:
:
Init
(
nsIPresShell
*
inPresShell
)
{
NS_ENSURE_ARG
(
inPresShell
)
;
mPresShell
=
do_GetWeakReference
(
inPresShell
)
;
NS_ASSERTION
(
mPresShell
"
Hey
pres
shell
should
support
weak
refs
"
)
;
mShowDuringSelection
=
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
eIntID_ShowCaretDuringSelection
mShowDuringSelection
?
1
:
0
)
!
=
0
;
nsCOMPtr
<
nsISelectionController
>
selCon
=
do_QueryReferent
(
mPresShell
)
;
if
(
!
selCon
)
{
return
NS_ERROR_FAILURE
;
}
RefPtr
<
Selection
>
selection
=
selCon
-
>
GetSelection
(
nsISelectionController
:
:
SELECTION_NORMAL
)
;
if
(
!
selection
)
{
return
NS_ERROR_FAILURE
;
}
selection
-
>
AddSelectionListener
(
this
)
;
mDomSelectionWeak
=
selection
;
return
NS_OK
;
}
static
bool
DrawCJKCaret
(
nsIFrame
*
aFrame
int32_t
aOffset
)
{
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
const
nsTextFragment
*
frag
=
content
-
>
GetText
(
)
;
if
(
!
frag
)
return
false
;
if
(
aOffset
<
0
|
|
uint32_t
(
aOffset
)
>
=
frag
-
>
GetLength
(
)
)
return
false
;
char16_t
ch
=
frag
-
>
CharAt
(
aOffset
)
;
return
0x2e80
<
=
ch
&
&
ch
<
=
0xd7ff
;
}
nsCaret
:
:
Metrics
nsCaret
:
:
ComputeMetrics
(
nsIFrame
*
aFrame
int32_t
aOffset
nscoord
aCaretHeight
)
{
nscoord
caretWidth
=
(
aCaretHeight
*
LookAndFeel
:
:
GetFloat
(
LookAndFeel
:
:
eFloatID_CaretAspectRatio
0
.
0f
)
)
+
nsPresContext
:
:
CSSPixelsToAppUnits
(
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
eIntID_CaretWidth
1
)
)
;
if
(
DrawCJKCaret
(
aFrame
aOffset
)
)
{
caretWidth
+
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
1
)
;
}
nscoord
bidiIndicatorSize
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
kMinBidiIndicatorPixels
)
;
bidiIndicatorSize
=
std
:
:
max
(
caretWidth
bidiIndicatorSize
)
;
int32_t
tpp
=
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
Metrics
result
;
result
.
mCaretWidth
=
NS_ROUND_BORDER_TO_PIXELS
(
caretWidth
tpp
)
;
result
.
mBidiIndicatorSize
=
NS_ROUND_BORDER_TO_PIXELS
(
bidiIndicatorSize
tpp
)
;
return
result
;
}
void
nsCaret
:
:
Terminate
(
)
{
StopBlinking
(
)
;
mBlinkTimer
=
nullptr
;
if
(
mDomSelectionWeak
)
{
mDomSelectionWeak
-
>
RemoveSelectionListener
(
this
)
;
}
mDomSelectionWeak
=
nullptr
;
mPresShell
=
nullptr
;
mOverrideContent
=
nullptr
;
}
NS_IMPL_ISUPPORTS
(
nsCaret
nsISelectionListener
)
Selection
*
nsCaret
:
:
GetSelection
(
)
{
return
mDomSelectionWeak
;
}
void
nsCaret
:
:
SetSelection
(
Selection
*
aDOMSel
)
{
MOZ_ASSERT
(
aDOMSel
)
;
mDomSelectionWeak
=
aDOMSel
;
ResetBlinking
(
)
;
SchedulePaint
(
aDOMSel
)
;
}
void
nsCaret
:
:
SetVisible
(
bool
inMakeVisible
)
{
mVisible
=
inMakeVisible
;
mIgnoreUserModify
=
mVisible
;
ResetBlinking
(
)
;
SchedulePaint
(
)
;
}
void
nsCaret
:
:
AddForceHide
(
)
{
MOZ_ASSERT
(
mHideCount
<
UINT32_MAX
)
;
if
(
+
+
mHideCount
>
1
)
{
return
;
}
ResetBlinking
(
)
;
SchedulePaint
(
)
;
}
void
nsCaret
:
:
RemoveForceHide
(
)
{
if
(
!
mHideCount
|
|
-
-
mHideCount
)
{
return
;
}
ResetBlinking
(
)
;
SchedulePaint
(
)
;
}
void
nsCaret
:
:
SetCaretReadOnly
(
bool
inMakeReadonly
)
{
mReadOnly
=
inMakeReadonly
;
ResetBlinking
(
)
;
SchedulePaint
(
)
;
}
nsRect
nsCaret
:
:
GetGeometryForFrame
(
nsIFrame
*
aFrame
int32_t
aFrameOffset
nscoord
*
aBidiIndicatorSize
)
{
nsPoint
framePos
(
0
0
)
;
nsRect
rect
;
nsresult
rv
=
aFrame
-
>
GetPointFromOffset
(
aFrameOffset
&
framePos
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
aBidiIndicatorSize
)
{
*
aBidiIndicatorSize
=
0
;
}
return
rect
;
}
nsIFrame
*
frame
=
aFrame
-
>
GetContentInsertionFrame
(
)
;
if
(
!
frame
)
{
frame
=
aFrame
;
}
NS_ASSERTION
(
!
(
frame
-
>
GetStateBits
(
)
&
NS_FRAME_IN_REFLOW
)
"
We
should
not
be
in
the
middle
of
reflow
"
)
;
nscoord
baseline
=
frame
-
>
GetCaretBaseline
(
)
;
nscoord
ascent
=
0
descent
=
0
;
RefPtr
<
nsFontMetrics
>
fm
=
nsLayoutUtils
:
:
GetInflatedFontMetricsForFrame
(
aFrame
)
;
NS_ASSERTION
(
fm
"
We
should
be
able
to
get
the
font
metrics
"
)
;
if
(
fm
)
{
ascent
=
fm
-
>
MaxAscent
(
)
;
descent
=
fm
-
>
MaxDescent
(
)
;
}
nscoord
height
=
ascent
+
descent
;
WritingMode
wm
=
aFrame
-
>
GetWritingMode
(
)
;
bool
vertical
=
wm
.
IsVertical
(
)
;
if
(
vertical
)
{
if
(
wm
.
IsLineInverted
(
)
)
{
framePos
.
x
=
baseline
-
descent
;
}
else
{
framePos
.
x
=
baseline
-
ascent
;
}
}
else
{
framePos
.
y
=
baseline
-
ascent
;
}
Metrics
caretMetrics
=
ComputeMetrics
(
aFrame
aFrameOffset
height
)
;
nsTextFrame
*
textFrame
=
do_QueryFrame
(
aFrame
)
;
if
(
textFrame
)
{
gfxTextRun
*
textRun
=
textFrame
-
>
GetTextRun
(
nsTextFrame
:
:
TextRunType
:
:
eInflated
)
;
if
(
textRun
)
{
bool
textRunDirIsReverseOfFrame
=
wm
.
IsInlineReversed
(
)
!
=
textRun
-
>
IsInlineReversed
(
)
;
if
(
textRunDirIsReverseOfFrame
!
=
textRun
-
>
IsSidewaysLeft
(
)
)
{
int
dir
=
wm
.
IsBidiLTR
(
)
?
-
1
:
1
;
if
(
vertical
)
{
framePos
.
y
+
=
dir
*
caretMetrics
.
mCaretWidth
;
}
else
{
framePos
.
x
+
=
dir
*
caretMetrics
.
mCaretWidth
;
}
}
}
}
rect
=
nsRect
(
framePos
vertical
?
nsSize
(
height
caretMetrics
.
mCaretWidth
)
:
nsSize
(
caretMetrics
.
mCaretWidth
height
)
)
;
nsIFrame
*
scrollFrame
=
nsLayoutUtils
:
:
GetClosestFrameOfType
(
aFrame
LayoutFrameType
:
:
Scroll
)
;
if
(
scrollFrame
)
{
nsIScrollableFrame
*
sf
=
do_QueryFrame
(
scrollFrame
)
;
nsIFrame
*
scrolled
=
sf
-
>
GetScrolledFrame
(
)
;
nsRect
caretInScroll
=
rect
+
aFrame
-
>
GetOffsetTo
(
scrolled
)
;
if
(
vertical
)
{
nscoord
overflow
=
caretInScroll
.
YMost
(
)
-
scrolled
-
>
GetVisualOverflowRectRelativeToSelf
(
)
.
height
;
if
(
overflow
>
0
)
{
rect
.
y
-
=
overflow
;
}
}
else
{
nscoord
overflow
=
caretInScroll
.
XMost
(
)
-
scrolled
-
>
GetVisualOverflowRectRelativeToSelf
(
)
.
width
;
if
(
overflow
>
0
)
{
rect
.
x
-
=
overflow
;
}
}
}
if
(
aBidiIndicatorSize
)
{
*
aBidiIndicatorSize
=
caretMetrics
.
mBidiIndicatorSize
;
}
return
rect
;
}
nsIFrame
*
nsCaret
:
:
GetFrameAndOffset
(
Selection
*
aSelection
nsINode
*
aOverrideNode
int32_t
aOverrideOffset
int32_t
*
aFrameOffset
nsIFrame
*
*
aUnadjustedFrame
)
{
if
(
aUnadjustedFrame
)
{
*
aUnadjustedFrame
=
nullptr
;
}
nsINode
*
focusNode
;
int32_t
focusOffset
;
if
(
aOverrideNode
)
{
focusNode
=
aOverrideNode
;
focusOffset
=
aOverrideOffset
;
}
else
if
(
aSelection
)
{
focusNode
=
aSelection
-
>
GetFocusNode
(
)
;
focusOffset
=
aSelection
-
>
FocusOffset
(
)
;
}
else
{
return
nullptr
;
}
if
(
!
focusNode
|
|
!
focusNode
-
>
IsContent
(
)
)
{
return
nullptr
;
}
nsIContent
*
contentNode
=
focusNode
-
>
AsContent
(
)
;
nsFrameSelection
*
frameSelection
=
aSelection
-
>
GetFrameSelection
(
)
;
nsBidiLevel
bidiLevel
=
frameSelection
-
>
GetCaretBidiLevel
(
)
;
nsIFrame
*
frame
;
nsresult
rv
=
nsCaret
:
:
GetCaretFrameForNodeOffset
(
frameSelection
contentNode
focusOffset
frameSelection
-
>
GetHint
(
)
bidiLevel
&
frame
aUnadjustedFrame
aFrameOffset
)
;
if
(
NS_FAILED
(
rv
)
|
|
!
frame
)
{
return
nullptr
;
}
return
frame
;
}
nsIFrame
*
nsCaret
:
:
GetGeometry
(
Selection
*
aSelection
nsRect
*
aRect
)
{
int32_t
frameOffset
;
nsIFrame
*
frame
=
GetFrameAndOffset
(
aSelection
nullptr
0
&
frameOffset
)
;
if
(
frame
)
{
*
aRect
=
GetGeometryForFrame
(
frame
frameOffset
nullptr
)
;
}
return
frame
;
}
void
nsCaret
:
:
SchedulePaint
(
Selection
*
aSelection
)
{
Selection
*
selection
;
if
(
aSelection
)
{
selection
=
aSelection
;
}
else
{
selection
=
GetSelection
(
)
;
}
int32_t
frameOffset
;
nsIFrame
*
frame
=
GetFrameAndOffset
(
selection
mOverrideContent
mOverrideOffset
&
frameOffset
)
;
if
(
frame
)
{
frame
-
>
SchedulePaint
(
)
;
}
}
void
nsCaret
:
:
SetVisibilityDuringSelection
(
bool
aVisibility
)
{
mShowDuringSelection
=
aVisibility
;
SchedulePaint
(
)
;
}
void
nsCaret
:
:
SetCaretPosition
(
nsINode
*
aNode
int32_t
aOffset
)
{
mOverrideContent
=
aNode
;
mOverrideOffset
=
aOffset
;
ResetBlinking
(
)
;
SchedulePaint
(
)
;
}
void
nsCaret
:
:
CheckSelectionLanguageChange
(
)
{
if
(
!
IsBidiUI
(
)
)
{
return
;
}
bool
isKeyboardRTL
=
false
;
nsIBidiKeyboard
*
bidiKeyboard
=
nsContentUtils
:
:
GetBidiKeyboard
(
)
;
if
(
bidiKeyboard
)
{
bidiKeyboard
-
>
IsLangRTL
(
&
isKeyboardRTL
)
;
}
Selection
*
selection
=
GetSelection
(
)
;
if
(
selection
)
{
selection
-
>
SelectionLanguageChange
(
isKeyboardRTL
)
;
}
}
nsIFrame
*
nsCaret
:
:
GetPaintGeometry
(
nsRect
*
aRect
)
{
if
(
!
IsVisible
(
)
|
|
!
mIsBlinkOn
)
{
return
nullptr
;
}
CheckSelectionLanguageChange
(
)
;
int32_t
frameOffset
;
nsIFrame
*
unadjustedFrame
=
nullptr
;
nsIFrame
*
frame
=
GetFrameAndOffset
(
GetSelection
(
)
mOverrideContent
mOverrideOffset
&
frameOffset
&
unadjustedFrame
)
;
MOZ_ASSERT
(
!
!
frame
=
=
!
!
unadjustedFrame
)
;
if
(
!
frame
)
{
return
nullptr
;
}
const
nsStyleUI
*
ui
=
unadjustedFrame
-
>
StyleUI
(
)
;
if
(
(
!
mIgnoreUserModify
&
&
ui
-
>
mUserModify
=
=
StyleUserModify
:
:
ReadOnly
)
|
|
unadjustedFrame
-
>
IsContentDisabled
(
)
)
{
return
nullptr
;
}
int32_t
startOffset
endOffset
;
if
(
frame
-
>
IsTextFrame
(
)
&
&
(
NS_FAILED
(
frame
-
>
GetOffsets
(
startOffset
endOffset
)
)
|
|
startOffset
>
frameOffset
|
|
endOffset
<
frameOffset
)
)
{
return
nullptr
;
}
nsRect
caretRect
;
nsRect
hookRect
;
ComputeCaretRects
(
frame
frameOffset
&
caretRect
&
hookRect
)
;
aRect
-
>
UnionRect
(
caretRect
hookRect
)
;
return
frame
;
}
nsIFrame
*
nsCaret
:
:
GetFrame
(
int32_t
*
aContentOffset
)
{
return
GetFrameAndOffset
(
GetSelection
(
)
mOverrideContent
mOverrideOffset
aContentOffset
)
;
}
void
nsCaret
:
:
PaintCaret
(
DrawTarget
&
aDrawTarget
nsIFrame
*
aForFrame
const
nsPoint
&
aOffset
)
{
int32_t
contentOffset
;
nsIFrame
*
frame
=
GetFrame
(
&
contentOffset
)
;
if
(
!
frame
)
{
return
;
}
NS_ASSERTION
(
frame
=
=
aForFrame
"
We
'
re
referring
different
frame
"
)
;
int32_t
appUnitsPerDevPixel
=
frame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
nsRect
caretRect
;
nsRect
hookRect
;
ComputeCaretRects
(
frame
contentOffset
&
caretRect
&
hookRect
)
;
Rect
devPxCaretRect
=
NSRectToSnappedRect
(
caretRect
+
aOffset
appUnitsPerDevPixel
aDrawTarget
)
;
Rect
devPxHookRect
=
NSRectToSnappedRect
(
hookRect
+
aOffset
appUnitsPerDevPixel
aDrawTarget
)
;
ColorPattern
color
(
ToDeviceColor
(
frame
-
>
GetCaretColorAt
(
contentOffset
)
)
)
;
aDrawTarget
.
FillRect
(
devPxCaretRect
color
)
;
if
(
!
hookRect
.
IsEmpty
(
)
)
{
aDrawTarget
.
FillRect
(
devPxHookRect
color
)
;
}
}
NS_IMETHODIMP
nsCaret
:
:
NotifySelectionChanged
(
Document
*
Selection
*
aDomSel
int16_t
aReason
)
{
if
(
(
aReason
&
nsISelectionListener
:
:
MOUSEUP_REASON
)
|
|
!
IsVisible
(
aDomSel
)
)
return
NS_OK
;
if
(
mDomSelectionWeak
!
=
aDomSel
)
return
NS_OK
;
ResetBlinking
(
)
;
SchedulePaint
(
aDomSel
)
;
return
NS_OK
;
}
void
nsCaret
:
:
ResetBlinking
(
)
{
mIsBlinkOn
=
true
;
if
(
mReadOnly
|
|
!
mVisible
|
|
mHideCount
)
{
StopBlinking
(
)
;
return
;
}
uint32_t
blinkRate
=
static_cast
<
uint32_t
>
(
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
eIntID_CaretBlinkTime
kDefaultCaretBlinkRate
)
)
;
if
(
mBlinkRate
=
=
blinkRate
)
{
return
;
}
mBlinkRate
=
blinkRate
;
if
(
mBlinkTimer
)
{
mBlinkTimer
-
>
Cancel
(
)
;
}
else
{
nsIEventTarget
*
target
=
nullptr
;
if
(
nsCOMPtr
<
nsIPresShell
>
presShell
=
do_QueryReferent
(
mPresShell
)
)
{
if
(
nsCOMPtr
<
Document
>
doc
=
presShell
-
>
GetDocument
(
)
)
{
target
=
doc
-
>
EventTargetFor
(
TaskCategory
:
:
Other
)
;
}
}
mBlinkTimer
=
NS_NewTimer
(
target
)
;
if
(
!
mBlinkTimer
)
{
return
;
}
}
if
(
blinkRate
>
0
)
{
mBlinkCount
=
Preferences
:
:
GetInt
(
"
ui
.
caretBlinkCount
"
-
1
)
;
mBlinkTimer
-
>
InitWithNamedFuncCallback
(
CaretBlinkCallback
this
blinkRate
nsITimer
:
:
TYPE_REPEATING_SLACK
"
nsCaret
:
:
CaretBlinkCallback_timer
"
)
;
}
}
void
nsCaret
:
:
StopBlinking
(
)
{
if
(
mBlinkTimer
)
{
mBlinkTimer
-
>
Cancel
(
)
;
mBlinkRate
=
0
;
}
}
nsresult
nsCaret
:
:
GetCaretFrameForNodeOffset
(
nsFrameSelection
*
aFrameSelection
nsIContent
*
aContentNode
int32_t
aOffset
CaretAssociationHint
aFrameHint
nsBidiLevel
aBidiLevel
nsIFrame
*
*
aReturnFrame
nsIFrame
*
*
aReturnUnadjustedFrame
int32_t
*
aReturnOffset
)
{
if
(
!
aFrameSelection
)
return
NS_ERROR_FAILURE
;
nsIPresShell
*
presShell
=
aFrameSelection
-
>
GetShell
(
)
;
if
(
!
presShell
)
return
NS_ERROR_FAILURE
;
if
(
!
aContentNode
|
|
!
aContentNode
-
>
IsInComposedDoc
(
)
|
|
presShell
-
>
GetDocument
(
)
!
=
aContentNode
-
>
GetComposedDoc
(
)
)
return
NS_ERROR_FAILURE
;
nsIFrame
*
theFrame
=
nullptr
;
int32_t
theFrameOffset
=
0
;
theFrame
=
aFrameSelection
-
>
GetFrameForNodeOffset
(
aContentNode
aOffset
aFrameHint
&
theFrameOffset
)
;
if
(
!
theFrame
)
return
NS_ERROR_FAILURE
;
if
(
aReturnUnadjustedFrame
)
{
*
aReturnUnadjustedFrame
=
theFrame
;
}
AdjustCaretFrameForLineEnd
(
&
theFrame
&
theFrameOffset
)
;
if
(
theFrame
-
>
PresContext
(
)
-
>
BidiEnabled
(
)
)
{
if
(
aBidiLevel
&
BIDI_LEVEL_UNDEFINED
)
{
aBidiLevel
=
theFrame
-
>
GetEmbeddingLevel
(
)
;
}
int32_t
start
;
int32_t
end
;
nsIFrame
*
frameBefore
;
nsIFrame
*
frameAfter
;
nsBidiLevel
levelBefore
;
nsBidiLevel
levelAfter
;
theFrame
-
>
GetOffsets
(
start
end
)
;
if
(
start
=
=
0
|
|
end
=
=
0
|
|
start
=
=
theFrameOffset
|
|
end
=
=
theFrameOffset
)
{
nsPrevNextBidiLevels
levels
=
aFrameSelection
-
>
GetPrevNextBidiLevels
(
aContentNode
aOffset
false
)
;
if
(
levels
.
mFrameBefore
|
|
levels
.
mFrameAfter
)
{
frameBefore
=
levels
.
mFrameBefore
;
frameAfter
=
levels
.
mFrameAfter
;
levelBefore
=
levels
.
mLevelBefore
;
levelAfter
=
levels
.
mLevelAfter
;
if
(
(
levelBefore
!
=
levelAfter
)
|
|
(
aBidiLevel
!
=
levelBefore
)
)
{
aBidiLevel
=
std
:
:
max
(
aBidiLevel
std
:
:
min
(
levelBefore
levelAfter
)
)
;
aBidiLevel
=
std
:
:
min
(
aBidiLevel
std
:
:
max
(
levelBefore
levelAfter
)
)
;
if
(
aBidiLevel
=
=
levelBefore
|
|
(
aBidiLevel
>
levelBefore
&
&
aBidiLevel
<
levelAfter
&
&
IS_SAME_DIRECTION
(
aBidiLevel
levelBefore
)
)
|
|
(
aBidiLevel
<
levelBefore
&
&
aBidiLevel
>
levelAfter
&
&
IS_SAME_DIRECTION
(
aBidiLevel
levelBefore
)
)
)
{
if
(
theFrame
!
=
frameBefore
)
{
if
(
frameBefore
)
{
theFrame
=
frameBefore
;
theFrame
-
>
GetOffsets
(
start
end
)
;
theFrameOffset
=
end
;
}
else
{
nsBidiLevel
baseLevel
=
frameAfter
-
>
GetBaseLevel
(
)
;
if
(
baseLevel
!
=
levelAfter
)
{
nsPeekOffsetStruct
pos
(
eSelectBeginLine
eDirPrevious
0
nsPoint
(
0
0
)
false
true
false
true
false
)
;
if
(
NS_SUCCEEDED
(
frameAfter
-
>
PeekOffset
(
&
pos
)
)
)
{
theFrame
=
pos
.
mResultFrame
;
theFrameOffset
=
pos
.
mContentOffset
;
}
}
}
}
}
else
if
(
aBidiLevel
=
=
levelAfter
|
|
(
aBidiLevel
>
levelBefore
&
&
aBidiLevel
<
levelAfter
&
&
IS_SAME_DIRECTION
(
aBidiLevel
levelAfter
)
)
|
|
(
aBidiLevel
<
levelBefore
&
&
aBidiLevel
>
levelAfter
&
&
IS_SAME_DIRECTION
(
aBidiLevel
levelAfter
)
)
)
{
if
(
theFrame
!
=
frameAfter
)
{
if
(
frameAfter
)
{
theFrame
=
frameAfter
;
theFrame
-
>
GetOffsets
(
start
end
)
;
theFrameOffset
=
start
;
}
else
{
nsBidiLevel
baseLevel
=
frameBefore
-
>
GetBaseLevel
(
)
;
if
(
baseLevel
!
=
levelBefore
)
{
nsPeekOffsetStruct
pos
(
eSelectEndLine
eDirNext
0
nsPoint
(
0
0
)
false
true
false
true
false
)
;
if
(
NS_SUCCEEDED
(
frameBefore
-
>
PeekOffset
(
&
pos
)
)
)
{
theFrame
=
pos
.
mResultFrame
;
theFrameOffset
=
pos
.
mContentOffset
;
}
}
}
}
}
else
if
(
aBidiLevel
>
levelBefore
&
&
aBidiLevel
<
levelAfter
&
&
IS_SAME_DIRECTION
(
levelBefore
levelAfter
)
&
&
!
IS_SAME_DIRECTION
(
aBidiLevel
levelAfter
)
)
{
if
(
NS_SUCCEEDED
(
aFrameSelection
-
>
GetFrameFromLevel
(
frameAfter
eDirNext
aBidiLevel
&
theFrame
)
)
)
{
theFrame
-
>
GetOffsets
(
start
end
)
;
levelAfter
=
theFrame
-
>
GetEmbeddingLevel
(
)
;
if
(
IS_LEVEL_RTL
(
aBidiLevel
)
)
theFrameOffset
=
IS_LEVEL_RTL
(
levelAfter
)
?
start
:
end
;
else
theFrameOffset
=
IS_LEVEL_RTL
(
levelAfter
)
?
end
:
start
;
}
}
else
if
(
aBidiLevel
<
levelBefore
&
&
aBidiLevel
>
levelAfter
&
&
IS_SAME_DIRECTION
(
levelBefore
levelAfter
)
&
&
!
IS_SAME_DIRECTION
(
aBidiLevel
levelAfter
)
)
{
if
(
NS_SUCCEEDED
(
aFrameSelection
-
>
GetFrameFromLevel
(
frameBefore
eDirPrevious
aBidiLevel
&
theFrame
)
)
)
{
theFrame
-
>
GetOffsets
(
start
end
)
;
levelBefore
=
theFrame
-
>
GetEmbeddingLevel
(
)
;
if
(
IS_LEVEL_RTL
(
aBidiLevel
)
)
theFrameOffset
=
IS_LEVEL_RTL
(
levelBefore
)
?
end
:
start
;
else
theFrameOffset
=
IS_LEVEL_RTL
(
levelBefore
)
?
start
:
end
;
}
}
}
}
}
}
*
aReturnFrame
=
theFrame
;
*
aReturnOffset
=
theFrameOffset
;
return
NS_OK
;
}
size_t
nsCaret
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
total
=
aMallocSizeOf
(
this
)
;
if
(
mPresShell
)
{
total
+
=
mPresShell
-
>
SizeOfOnlyThis
(
aMallocSizeOf
)
;
}
if
(
mBlinkTimer
)
{
total
+
=
mBlinkTimer
-
>
SizeOfIncludingThis
(
aMallocSizeOf
)
;
}
return
total
;
}
bool
nsCaret
:
:
IsMenuPopupHidingCaret
(
)
{
#
ifdef
MOZ_XUL
nsXULPopupManager
*
popMgr
=
nsXULPopupManager
:
:
GetInstance
(
)
;
nsTArray
<
nsIFrame
*
>
popups
;
popMgr
-
>
GetVisiblePopups
(
popups
)
;
if
(
popups
.
Length
(
)
=
=
0
)
return
false
;
if
(
!
mDomSelectionWeak
)
{
return
true
;
}
nsCOMPtr
<
nsIContent
>
caretContent
=
nsIContent
:
:
FromNodeOrNull
(
mDomSelectionWeak
-
>
GetFocusNode
(
)
)
;
if
(
!
caretContent
)
return
true
;
for
(
uint32_t
i
=
0
;
i
<
popups
.
Length
(
)
;
i
+
+
)
{
nsMenuPopupFrame
*
popupFrame
=
static_cast
<
nsMenuPopupFrame
*
>
(
popups
[
i
]
)
;
nsIContent
*
popupContent
=
popupFrame
-
>
GetContent
(
)
;
if
(
nsContentUtils
:
:
ContentIsDescendantOf
(
caretContent
popupContent
)
)
{
return
false
;
}
if
(
popupFrame
-
>
PopupType
(
)
=
=
ePopupTypeMenu
&
&
!
popupFrame
-
>
IsContextMenu
(
)
)
{
return
true
;
}
}
#
endif
return
false
;
}
void
nsCaret
:
:
ComputeCaretRects
(
nsIFrame
*
aFrame
int32_t
aFrameOffset
nsRect
*
aCaretRect
nsRect
*
aHookRect
)
{
NS_ASSERTION
(
aFrame
"
Should
have
a
frame
here
"
)
;
WritingMode
wm
=
aFrame
-
>
GetWritingMode
(
)
;
bool
isVertical
=
wm
.
IsVertical
(
)
;
nscoord
bidiIndicatorSize
;
*
aCaretRect
=
GetGeometryForFrame
(
aFrame
aFrameOffset
&
bidiIndicatorSize
)
;
const
nsStyleVisibility
*
vis
=
aFrame
-
>
StyleVisibility
(
)
;
if
(
NS_STYLE_DIRECTION_RTL
=
=
vis
-
>
mDirection
)
{
if
(
isVertical
)
{
aCaretRect
-
>
y
-
=
aCaretRect
-
>
height
;
}
else
{
aCaretRect
-
>
x
-
=
aCaretRect
-
>
width
;
}
}
aHookRect
-
>
SetEmpty
(
)
;
if
(
!
IsBidiUI
(
)
)
{
return
;
}
bool
isCaretRTL
;
nsIBidiKeyboard
*
bidiKeyboard
=
nsContentUtils
:
:
GetBidiKeyboard
(
)
;
if
(
bidiKeyboard
&
&
NS_SUCCEEDED
(
bidiKeyboard
-
>
IsLangRTL
(
&
isCaretRTL
)
)
)
{
if
(
isVertical
)
{
bool
isSidewaysLR
=
wm
.
IsVerticalLR
(
)
&
&
!
wm
.
IsLineInverted
(
)
;
if
(
isSidewaysLR
)
{
aHookRect
-
>
SetRect
(
aCaretRect
-
>
x
+
bidiIndicatorSize
aCaretRect
-
>
y
+
(
!
isCaretRTL
?
bidiIndicatorSize
*
-
1
:
aCaretRect
-
>
height
)
aCaretRect
-
>
height
bidiIndicatorSize
)
;
}
else
{
aHookRect
-
>
SetRect
(
aCaretRect
-
>
XMost
(
)
-
bidiIndicatorSize
aCaretRect
-
>
y
+
(
isCaretRTL
?
bidiIndicatorSize
*
-
1
:
aCaretRect
-
>
height
)
aCaretRect
-
>
height
bidiIndicatorSize
)
;
}
}
else
{
aHookRect
-
>
SetRect
(
aCaretRect
-
>
x
+
(
isCaretRTL
?
bidiIndicatorSize
*
-
1
:
aCaretRect
-
>
width
)
aCaretRect
-
>
y
+
bidiIndicatorSize
bidiIndicatorSize
aCaretRect
-
>
width
)
;
}
}
}
void
nsCaret
:
:
CaretBlinkCallback
(
nsITimer
*
aTimer
void
*
aClosure
)
{
nsCaret
*
theCaret
=
reinterpret_cast
<
nsCaret
*
>
(
aClosure
)
;
if
(
!
theCaret
)
{
return
;
}
theCaret
-
>
mIsBlinkOn
=
!
theCaret
-
>
mIsBlinkOn
;
theCaret
-
>
SchedulePaint
(
)
;
if
(
theCaret
-
>
mBlinkCount
=
=
-
1
)
{
return
;
}
if
(
!
theCaret
-
>
mIsBlinkOn
)
{
if
(
-
-
theCaret
-
>
mBlinkCount
<
=
0
)
{
theCaret
-
>
StopBlinking
(
)
;
}
}
}
void
nsCaret
:
:
SetIgnoreUserModify
(
bool
aIgnoreUserModify
)
{
mIgnoreUserModify
=
aIgnoreUserModify
;
SchedulePaint
(
)
;
}
