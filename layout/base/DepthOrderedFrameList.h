#
ifndef
mozilla_DepthOrderedFrameList_h
#
define
mozilla_DepthOrderedFrameList_h
#
include
"
mozilla
/
ReverseIterator
.
h
"
#
include
"
nsTArray
.
h
"
class
nsIFrame
;
namespace
mozilla
{
class
DepthOrderedFrameList
{
public
:
void
Add
(
nsIFrame
*
aFrame
)
;
void
Remove
(
nsIFrame
*
aFrame
)
;
nsIFrame
*
PopShallowestRoot
(
)
;
void
Clear
(
)
{
mList
.
Clear
(
)
;
}
bool
Contains
(
nsIFrame
*
aFrame
)
const
{
return
mList
.
Contains
(
aFrame
)
;
}
bool
IsEmpty
(
)
const
{
return
mList
.
IsEmpty
(
)
;
}
bool
FrameIsAncestorOfAnyElement
(
nsIFrame
*
aFrame
)
const
;
auto
IterFromShallowest
(
)
const
{
return
Reversed
(
mList
)
;
}
size_t
Length
(
)
const
{
return
mList
.
Length
(
)
;
}
nsIFrame
*
ElementAt
(
size_t
i
)
const
{
return
mList
.
ElementAt
(
i
)
;
}
void
RemoveElementAt
(
size_t
i
)
{
mList
.
RemoveElementAt
(
i
)
;
}
private
:
struct
FrameAndDepth
{
nsIFrame
*
mFrame
;
const
uint32_t
mDepth
;
operator
nsIFrame
*
(
)
const
{
return
mFrame
;
}
class
CompareByReverseDepth
{
public
:
bool
Equals
(
const
FrameAndDepth
&
aA
const
FrameAndDepth
&
aB
)
const
{
return
aA
.
mFrame
=
=
aB
.
mFrame
;
}
bool
LessThan
(
const
FrameAndDepth
&
aA
const
FrameAndDepth
&
aB
)
const
{
if
(
aA
.
mDepth
!
=
aB
.
mDepth
)
{
return
aA
.
mDepth
>
aB
.
mDepth
;
}
return
uintptr_t
(
aA
.
mFrame
)
<
uintptr_t
(
aB
.
mFrame
)
;
}
}
;
}
;
nsTArray
<
FrameAndDepth
>
mList
;
}
;
}
#
endif
