#
ifndef
nsLayoutUtils_h__
#
define
nsLayoutUtils_h__
#
include
"
LayoutConstants
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
TypedEnumBits
.
h
"
#
include
"
nsBoundingMetrics
.
h
"
#
include
"
nsChangeHint
.
h
"
#
include
"
mozilla
/
layout
/
FrameChildList
.
h
"
#
include
"
mozilla
/
layers
/
ScrollableLayerGuid
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsCSSPropertyIDSet
.
h
"
#
include
"
nsStyleCoord
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
Units
.
h
"
#
include
"
mozilla
/
ToString
.
h
"
#
include
"
mozilla
/
ReflowOutput
.
h
"
#
include
"
ImageContainer
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
SVGImageContext
.
h
"
#
include
<
limits
>
#
include
<
algorithm
>
#
include
"
gfxPoint
.
h
"
#
include
"
nsClassHashtable
.
h
"
class
gfxContext
;
class
gfxFontEntry
;
class
imgIContainer
;
class
nsFrameList
;
class
nsPresContext
;
class
nsIContent
;
class
nsIPrincipal
;
class
nsIWidget
;
class
nsAtom
;
class
nsIScrollableFrame
;
class
nsRegion
;
class
nsDisplayListBuilder
;
enum
class
nsDisplayListBuilderMode
:
uint8_t
;
class
nsDisplayItem
;
class
nsFontMetrics
;
class
nsFontFaceList
;
class
nsIImageLoadingContent
;
class
nsBlockFrame
;
class
nsContainerFrame
;
class
nsView
;
class
nsIFrame
;
class
nsStyleCoord
;
class
nsPIDOMWindowOuter
;
class
imgIRequest
;
struct
nsStyleFont
;
struct
nsOverflowAreas
;
namespace
mozilla
{
class
ComputedStyle
;
class
PresShell
;
enum
class
PseudoStyleType
:
uint8_t
;
class
EventListenerManager
;
enum
class
LayoutFrameType
:
uint8_t
;
struct
IntrinsicSize
;
struct
ContainerLayerParameters
;
class
WritingMode
;
class
DisplayItemClip
;
class
EffectSet
;
struct
ActiveScrolledRoot
;
enum
class
StyleImageOrientation
:
uint8_t
;
namespace
dom
{
class
CanvasRenderingContext2D
;
class
DOMRectList
;
class
Document
;
class
Element
;
class
Event
;
class
HTMLImageElement
;
class
HTMLCanvasElement
;
class
HTMLVideoElement
;
class
InspectorFontFace
;
class
OffscreenCanvas
;
class
Selection
;
}
namespace
gfx
{
struct
RectCornerRadii
;
enum
class
ShapedTextFlags
:
uint16_t
;
}
namespace
layers
{
struct
FrameMetrics
;
struct
ScrollMetadata
;
class
Image
;
class
StackingContextHelper
;
class
Layer
;
}
}
namespace
mozilla
{
struct
DisplayPortPropertyData
{
DisplayPortPropertyData
(
const
nsRect
&
aRect
uint32_t
aPriority
)
:
mRect
(
aRect
)
mPriority
(
aPriority
)
{
}
nsRect
mRect
;
uint32_t
mPriority
;
}
;
struct
DisplayPortMarginsPropertyData
{
DisplayPortMarginsPropertyData
(
const
ScreenMargin
&
aMargins
uint32_t
aPriority
)
:
mMargins
(
aMargins
)
mPriority
(
aPriority
)
{
}
ScreenMargin
mMargins
;
uint32_t
mPriority
;
}
;
struct
MotionPathData
{
gfx
:
:
Point
mTranslate
;
float
mRotate
;
}
;
}
enum
class
RelativeTo
{
ScrollPort
ScrollFrame
}
;
enum
class
DrawStringFlags
{
Default
=
0x0
ForceHorizontal
=
0x1
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
DrawStringFlags
)
enum
class
ReparentingDirection
{
Backwards
Forwards
Variable
}
;
class
nsLayoutUtils
{
typedef
mozilla
:
:
ComputedStyle
ComputedStyle
;
typedef
mozilla
:
:
LengthPercentage
LengthPercentage
;
typedef
mozilla
:
:
LengthPercentageOrAuto
LengthPercentageOrAuto
;
typedef
mozilla
:
:
dom
:
:
DOMRectList
DOMRectList
;
typedef
mozilla
:
:
layers
:
:
Layer
Layer
;
typedef
mozilla
:
:
layers
:
:
StackingContextHelper
StackingContextHelper
;
typedef
mozilla
:
:
ContainerLayerParameters
ContainerLayerParameters
;
typedef
mozilla
:
:
IntrinsicSize
IntrinsicSize
;
typedef
mozilla
:
:
gfx
:
:
SourceSurface
SourceSurface
;
typedef
mozilla
:
:
gfx
:
:
Color
Color
;
typedef
mozilla
:
:
gfx
:
:
DrawTarget
DrawTarget
;
typedef
mozilla
:
:
gfx
:
:
ExtendMode
ExtendMode
;
typedef
mozilla
:
:
gfx
:
:
SamplingFilter
SamplingFilter
;
typedef
mozilla
:
:
gfx
:
:
Float
Float
;
typedef
mozilla
:
:
gfx
:
:
Point
Point
;
typedef
mozilla
:
:
gfx
:
:
Rect
Rect
;
typedef
mozilla
:
:
gfx
:
:
RectDouble
RectDouble
;
typedef
mozilla
:
:
gfx
:
:
Size
Size
;
typedef
mozilla
:
:
gfx
:
:
Matrix4x4
Matrix4x4
;
typedef
mozilla
:
:
gfx
:
:
Matrix4x4Flagged
Matrix4x4Flagged
;
typedef
mozilla
:
:
gfx
:
:
RectCornerRadii
RectCornerRadii
;
typedef
mozilla
:
:
gfx
:
:
StrokeOptions
StrokeOptions
;
typedef
mozilla
:
:
image
:
:
ImgDrawResult
ImgDrawResult
;
public
:
typedef
mozilla
:
:
layers
:
:
FrameMetrics
FrameMetrics
;
typedef
mozilla
:
:
layers
:
:
ScrollMetadata
ScrollMetadata
;
typedef
mozilla
:
:
layers
:
:
ScrollableLayerGuid
:
:
ViewID
ViewID
;
typedef
mozilla
:
:
CSSPoint
CSSPoint
;
typedef
mozilla
:
:
CSSSize
CSSSize
;
typedef
mozilla
:
:
CSSIntSize
CSSIntSize
;
typedef
mozilla
:
:
CSSRect
CSSRect
;
typedef
mozilla
:
:
ScreenMargin
ScreenMargin
;
typedef
mozilla
:
:
LayoutDeviceIntSize
LayoutDeviceIntSize
;
typedef
mozilla
:
:
LayoutDeviceRect
LayoutDeviceRect
;
typedef
mozilla
:
:
PresShell
PresShell
;
typedef
mozilla
:
:
StyleGeometryBox
StyleGeometryBox
;
typedef
mozilla
:
:
SVGImageContext
SVGImageContext
;
typedef
mozilla
:
:
LogicalSize
LogicalSize
;
static
bool
FindIDFor
(
const
nsIContent
*
aContent
ViewID
*
aOutViewId
)
;
static
ViewID
FindOrCreateIDFor
(
nsIContent
*
aContent
)
;
static
nsIContent
*
FindContentFor
(
ViewID
aId
)
;
static
nsIScrollableFrame
*
FindScrollableFrameFor
(
ViewID
aId
)
;
static
ViewID
FindIDForScrollableFrame
(
nsIScrollableFrame
*
aScrollable
)
;
static
bool
GetDisplayPort
(
nsIContent
*
aContent
nsRect
*
aResult
RelativeTo
aRelativeTo
=
RelativeTo
:
:
ScrollPort
)
;
static
bool
HasDisplayPort
(
nsIContent
*
aContent
)
;
static
bool
FrameHasDisplayPort
(
nsIFrame
*
aFrame
const
nsIFrame
*
aScrolledFrame
=
nullptr
)
;
static
bool
IsMissingDisplayPortBaseRect
(
nsIContent
*
aContent
)
;
static
void
UpdateDisplayPortMarginsFromPendingMessages
(
)
;
static
bool
GetDisplayPortForVisibilityTesting
(
nsIContent
*
aContent
nsRect
*
aResult
RelativeTo
aRelativeTo
=
RelativeTo
:
:
ScrollPort
)
;
enum
class
RepaintMode
:
uint8_t
{
Repaint
DoNotRepaint
}
;
static
void
InvalidateForDisplayPortChange
(
nsIContent
*
aContent
bool
aHadDisplayPort
const
nsRect
&
aOldDisplayPort
const
nsRect
&
aNewDisplayPort
RepaintMode
aRepaintMode
=
RepaintMode
:
:
Repaint
)
;
static
bool
SetDisplayPortMargins
(
nsIContent
*
aContent
PresShell
*
aPresShell
const
ScreenMargin
&
aMargins
uint32_t
aPriority
=
0
RepaintMode
aRepaintMode
=
RepaintMode
:
:
Repaint
)
;
static
void
SetDisplayPortBase
(
nsIContent
*
aContent
const
nsRect
&
aBase
)
;
static
void
SetDisplayPortBaseIfNotSet
(
nsIContent
*
aContent
const
nsRect
&
aBase
)
;
static
bool
GetCriticalDisplayPort
(
nsIContent
*
aContent
nsRect
*
aResult
)
;
static
bool
HasCriticalDisplayPort
(
nsIContent
*
aContent
)
;
static
bool
GetHighResolutionDisplayPort
(
nsIContent
*
aContent
nsRect
*
aResult
)
;
static
void
RemoveDisplayPort
(
nsIContent
*
aContent
)
;
static
mozilla
:
:
layout
:
:
FrameChildListID
GetChildListNameFor
(
nsIFrame
*
aChildFrame
)
;
static
mozilla
:
:
dom
:
:
Element
*
GetBeforePseudo
(
const
nsIContent
*
aContent
)
;
static
nsIFrame
*
GetBeforeFrame
(
const
nsIContent
*
aContent
)
;
static
mozilla
:
:
dom
:
:
Element
*
GetAfterPseudo
(
const
nsIContent
*
aContent
)
;
static
nsIFrame
*
GetAfterFrame
(
const
nsIContent
*
aContent
)
;
static
mozilla
:
:
dom
:
:
Element
*
GetMarkerPseudo
(
const
nsIContent
*
aContent
)
;
static
nsIFrame
*
GetMarkerFrame
(
const
nsIContent
*
aContent
)
;
static
nsIFrame
*
GetClosestFrameOfType
(
nsIFrame
*
aFrame
mozilla
:
:
LayoutFrameType
aFrameType
nsIFrame
*
aStopAt
=
nullptr
)
;
static
nsIFrame
*
GetPageFrame
(
nsIFrame
*
aFrame
)
;
static
nsIFrame
*
GetStyleFrame
(
nsIFrame
*
aPrimaryFrame
)
;
static
const
nsIFrame
*
GetStyleFrame
(
const
nsIFrame
*
aPrimaryFrame
)
;
static
nsIFrame
*
GetStyleFrame
(
const
nsIContent
*
aContent
)
;
static
nsIFrame
*
GetPrimaryFrameFromStyleFrame
(
nsIFrame
*
aStyleFrame
)
;
static
const
nsIFrame
*
GetPrimaryFrameFromStyleFrame
(
const
nsIFrame
*
aStyleFrame
)
;
static
bool
IsPrimaryStyleFrame
(
const
nsIFrame
*
aFrame
)
;
static
nsIFrame
*
GetRealPrimaryFrameFor
(
const
nsIContent
*
aContent
)
;
#
ifdef
DEBUG
static
bool
gPreventAssertInCompareTreePosition
;
#
endif
static
int32_t
CompareTreePosition
(
nsIContent
*
aContent1
nsIContent
*
aContent2
const
nsIContent
*
aCommonAncestor
=
nullptr
)
{
return
DoCompareTreePosition
(
aContent1
aContent2
-
1
1
aCommonAncestor
)
;
}
static
int32_t
DoCompareTreePosition
(
nsIContent
*
aContent1
nsIContent
*
aContent2
int32_t
aIf1Ancestor
int32_t
aIf2Ancestor
const
nsIContent
*
aCommonAncestor
=
nullptr
)
;
static
int32_t
CompareTreePosition
(
nsIFrame
*
aFrame1
nsIFrame
*
aFrame2
nsIFrame
*
aCommonAncestor
=
nullptr
)
{
return
DoCompareTreePosition
(
aFrame1
aFrame2
-
1
1
aCommonAncestor
)
;
}
static
int32_t
CompareTreePosition
(
nsIFrame
*
aFrame1
nsIFrame
*
aFrame2
nsTArray
<
nsIFrame
*
>
&
aFrame2Ancestors
nsIFrame
*
aCommonAncestor
=
nullptr
)
{
return
DoCompareTreePosition
(
aFrame1
aFrame2
aFrame2Ancestors
-
1
1
aCommonAncestor
)
;
}
static
int32_t
DoCompareTreePosition
(
nsIFrame
*
aFrame1
nsIFrame
*
aFrame2
int32_t
aIf1Ancestor
int32_t
aIf2Ancestor
nsIFrame
*
aCommonAncestor
=
nullptr
)
;
static
nsIFrame
*
FillAncestors
(
nsIFrame
*
aFrame
nsIFrame
*
aStopAtAncestor
nsTArray
<
nsIFrame
*
>
*
aAncestors
)
;
static
int32_t
DoCompareTreePosition
(
nsIFrame
*
aFrame1
nsIFrame
*
aFrame2
nsTArray
<
nsIFrame
*
>
&
aFrame2Ancestors
int32_t
aIf1Ancestor
int32_t
aIf2Ancestor
nsIFrame
*
aCommonAncestor
)
;
static
nsContainerFrame
*
LastContinuationWithChild
(
nsContainerFrame
*
aFrame
)
;
static
nsIFrame
*
GetLastSibling
(
nsIFrame
*
aFrame
)
;
static
nsView
*
FindSiblingViewFor
(
nsView
*
aParentView
nsIFrame
*
aFrame
)
;
static
nsIFrame
*
GetCrossDocParentFrame
(
const
nsIFrame
*
aFrame
nsPoint
*
aCrossDocOffset
=
nullptr
)
;
static
bool
IsProperAncestorFrame
(
const
nsIFrame
*
aAncestorFrame
const
nsIFrame
*
aFrame
const
nsIFrame
*
aCommonAncestor
=
nullptr
)
;
static
bool
IsProperAncestorFrameCrossDoc
(
nsIFrame
*
aAncestorFrame
nsIFrame
*
aFrame
nsIFrame
*
aCommonAncestor
=
nullptr
)
;
static
bool
IsAncestorFrameCrossDoc
(
const
nsIFrame
*
aAncestorFrame
const
nsIFrame
*
aFrame
const
nsIFrame
*
aCommonAncestor
=
nullptr
)
;
static
void
SetFixedPositionLayerData
(
Layer
*
aLayer
const
nsIFrame
*
aViewportFrame
const
nsRect
&
aAnchorRect
const
nsIFrame
*
aFixedPosFrame
nsPresContext
*
aPresContext
const
ContainerLayerParameters
&
aContainerParameters
)
;
static
ViewID
ScrollIdForRootScrollFrame
(
nsPresContext
*
aPresContext
)
;
static
bool
ViewportHasDisplayPort
(
nsPresContext
*
aPresContext
)
;
static
bool
IsFixedPosFrameInDisplayPort
(
const
nsIFrame
*
aFrame
)
;
static
nsIScrollableFrame
*
GetScrollableFrameFor
(
const
nsIFrame
*
aScrolledFrame
)
;
enum
Direction
{
eHorizontal
eVertical
}
;
static
nsIScrollableFrame
*
GetNearestScrollableFrameForDirection
(
nsIFrame
*
aFrame
Direction
aDirection
)
;
enum
{
SCROLLABLE_SAME_DOC
=
0x01
SCROLLABLE_INCLUDE_HIDDEN
=
0x02
SCROLLABLE_ONLY_ASYNC_SCROLLABLE
=
0x04
SCROLLABLE_ALWAYS_MATCH_ROOT
=
0x08
SCROLLABLE_FIXEDPOS_FINDS_ROOT
=
0x10
}
;
static
nsIScrollableFrame
*
GetNearestScrollableFrame
(
nsIFrame
*
aFrame
uint32_t
aFlags
=
0
)
;
static
nsRect
GetScrolledRect
(
nsIFrame
*
aScrolledFrame
const
nsRect
&
aScrolledFrameOverflowArea
const
nsSize
&
aScrollPortSize
uint8_t
aDirection
)
;
static
bool
HasPseudoStyle
(
nsIContent
*
aContent
ComputedStyle
*
aComputedStyle
mozilla
:
:
PseudoStyleType
aPseudoElement
nsPresContext
*
aPresContext
)
;
static
nsIFrame
*
GetFloatFromPlaceholder
(
nsIFrame
*
aPlaceholder
)
;
static
mozilla
:
:
StyleClear
CombineBreakType
(
mozilla
:
:
StyleClear
aOrigBreakType
mozilla
:
:
StyleClear
aNewBreakType
)
;
static
nsPoint
GetDOMEventCoordinatesRelativeTo
(
mozilla
:
:
dom
:
:
Event
*
aDOMEvent
nsIFrame
*
aFrame
)
;
static
nsPoint
GetEventCoordinatesRelativeTo
(
const
mozilla
:
:
WidgetEvent
*
aEvent
nsIFrame
*
aFrame
)
;
static
nsPoint
GetEventCoordinatesRelativeTo
(
const
mozilla
:
:
WidgetEvent
*
aEvent
const
mozilla
:
:
LayoutDeviceIntPoint
&
aPoint
nsIFrame
*
aFrame
)
;
static
nsPoint
GetEventCoordinatesRelativeTo
(
nsIWidget
*
aWidget
const
mozilla
:
:
LayoutDeviceIntPoint
&
aPoint
nsIFrame
*
aFrame
)
;
static
nsIFrame
*
GetPopupFrameForEventCoordinates
(
nsPresContext
*
aPresContext
const
mozilla
:
:
WidgetEvent
*
aEvent
)
;
MOZ_CAN_RUN_SCRIPT
static
void
GetContainerAndOffsetAtEvent
(
PresShell
*
aPresShell
const
mozilla
:
:
WidgetEvent
*
aEvent
nsIContent
*
*
aContainer
int32_t
*
aOffset
)
;
static
nsPoint
TranslateWidgetToView
(
nsPresContext
*
aPresContext
nsIWidget
*
aWidget
const
mozilla
:
:
LayoutDeviceIntPoint
&
aPt
nsView
*
aView
)
;
static
mozilla
:
:
LayoutDeviceIntPoint
TranslateViewToWidget
(
nsPresContext
*
aPresContext
nsView
*
aView
nsPoint
aPt
nsIWidget
*
aWidget
)
;
static
mozilla
:
:
LayoutDeviceIntPoint
WidgetToWidgetOffset
(
nsIWidget
*
aFromWidget
nsIWidget
*
aToWidget
)
;
enum
class
FrameForPointOption
{
IgnorePaintSuppression
=
1
IgnoreRootScrollFrame
IgnoreCrossDoc
OnlyVisible
}
;
static
nsIFrame
*
GetFrameForPoint
(
nsIFrame
*
aFrame
nsPoint
aPt
mozilla
:
:
EnumSet
<
FrameForPointOption
>
=
{
}
)
;
static
nsresult
GetFramesForArea
(
nsIFrame
*
aFrame
const
nsRect
&
aRect
nsTArray
<
nsIFrame
*
>
&
aOutFrames
mozilla
:
:
EnumSet
<
FrameForPointOption
>
=
{
}
)
;
static
nsRect
TransformFrameRectToAncestor
(
const
nsIFrame
*
aFrame
const
nsRect
&
aRect
const
nsIFrame
*
aAncestor
bool
*
aPreservesAxisAlignedRectangles
=
nullptr
mozilla
:
:
Maybe
<
Matrix4x4Flagged
>
*
aMatrixCache
=
nullptr
bool
aStopAtStackingContextAndDisplayPortAndOOFFrame
=
false
nsIFrame
*
*
aOutAncestor
=
nullptr
)
;
static
Matrix4x4Flagged
GetTransformToAncestor
(
const
nsIFrame
*
aFrame
const
nsIFrame
*
aAncestor
uint32_t
aFlags
=
0
nsIFrame
*
*
aOutAncestor
=
nullptr
)
;
static
gfxSize
GetTransformToAncestorScale
(
nsIFrame
*
aFrame
)
;
static
gfxSize
GetTransformToAncestorScaleExcludingAnimated
(
nsIFrame
*
aFrame
)
;
static
nsIFrame
*
FindNearestCommonAncestorFrame
(
nsIFrame
*
aFrame1
nsIFrame
*
aFrame2
)
;
enum
TransformResult
{
TRANSFORM_SUCCEEDED
NO_COMMON_ANCESTOR
NONINVERTIBLE_TRANSFORM
}
;
static
TransformResult
TransformPoints
(
nsIFrame
*
aFromFrame
nsIFrame
*
aToFrame
uint32_t
aPointCount
CSSPoint
*
aPoints
)
;
static
TransformResult
TransformPoint
(
nsIFrame
*
aFromFrame
nsIFrame
*
aToFrame
nsPoint
&
aPoint
)
;
static
TransformResult
TransformRect
(
nsIFrame
*
aFromFrame
nsIFrame
*
aToFrame
nsRect
&
aRect
)
;
static
void
PostTranslate
(
Matrix4x4
&
aTransform
const
nsPoint
&
aOrigin
float
aAppUnitsPerPixel
bool
aRounded
)
;
static
nsRect
GetRectRelativeToFrame
(
mozilla
:
:
dom
:
:
Element
*
aElement
nsIFrame
*
aFrame
)
;
static
bool
ContainsPoint
(
const
nsRect
&
aRect
const
nsPoint
&
aPoint
nscoord
aInflateSize
)
;
static
nsRect
ClampRectToScrollFrames
(
nsIFrame
*
aFrame
const
nsRect
&
aRect
)
;
static
bool
GetLayerTransformForFrame
(
nsIFrame
*
aFrame
Matrix4x4Flagged
*
aTransform
)
;
static
nsPoint
TransformRootPointToFrame
(
nsIFrame
*
aFrame
const
nsPoint
&
aPoint
)
{
return
TransformAncestorPointToFrame
(
aFrame
aPoint
nullptr
)
;
}
static
nsPoint
TransformAncestorPointToFrame
(
nsIFrame
*
aFrame
const
nsPoint
&
aPoint
nsIFrame
*
aAncestor
)
;
static
nsRect
MatrixTransformRect
(
const
nsRect
&
aBounds
const
Matrix4x4
&
aMatrix
float
aFactor
)
;
static
nsRect
MatrixTransformRect
(
const
nsRect
&
aBounds
const
Matrix4x4Flagged
&
aMatrix
float
aFactor
)
;
static
nsPoint
MatrixTransformPoint
(
const
nsPoint
&
aPoint
const
Matrix4x4
&
aMatrix
float
aFactor
)
;
static
nsRect
RoundGfxRectToAppRect
(
const
Rect
&
aRect
float
aFactor
)
;
static
nsRect
RoundGfxRectToAppRect
(
const
gfxRect
&
aRect
float
aFactor
)
;
static
nsRegion
RoundedRectIntersectRect
(
const
nsRect
&
aRoundedRect
const
nscoord
aRadii
[
8
]
const
nsRect
&
aContainedRect
)
;
static
nsIntRegion
RoundedRectIntersectIntRect
(
const
nsIntRect
&
aRoundedRect
const
RectCornerRadii
&
aCornerRadii
const
nsIntRect
&
aContainedRect
)
;
static
bool
RoundedRectIntersectsRect
(
const
nsRect
&
aRoundedRect
const
nscoord
aRadii
[
8
]
const
nsRect
&
aTestRect
)
;
static
bool
MaybeCreateDisplayPortInFirstScrollFrameEncountered
(
nsIFrame
*
aFrame
nsDisplayListBuilder
&
aBuilder
)
;
enum
class
PaintFrameFlags
:
uint32_t
{
InTransform
=
0x01
SyncDecodeImages
=
0x02
WidgetLayers
=
0x04
IgnoreSuppression
=
0x08
DocumentRelative
=
0x10
HideCaret
=
0x20
ToWindow
=
0x40
ExistingTransaction
=
0x80
NoComposite
=
0x100
Compressed
=
0x200
ForWebRender
=
0x400
}
;
static
nsresult
PaintFrame
(
gfxContext
*
aRenderingContext
nsIFrame
*
aFrame
const
nsRegion
&
aDirtyRegion
nscolor
aBackstop
nsDisplayListBuilderMode
aBuilderMode
PaintFrameFlags
aFlags
=
PaintFrameFlags
(
0
)
)
;
static
bool
BinarySearchForPosition
(
DrawTarget
*
aDrawTarget
nsFontMetrics
&
aFontMetrics
const
char16_t
*
aText
int32_t
aBaseWidth
int32_t
aBaseInx
int32_t
aStartInx
int32_t
aEndInx
int32_t
aCursorPos
int32_t
&
aIndex
int32_t
&
aTextWidth
)
;
class
BoxCallback
{
public
:
BoxCallback
(
)
:
mIncludeCaptionBoxForTable
(
true
)
{
}
virtual
void
AddBox
(
nsIFrame
*
aFrame
)
=
0
;
bool
mIncludeCaptionBoxForTable
;
}
;
static
void
GetAllInFlowBoxes
(
nsIFrame
*
aFrame
BoxCallback
*
aCallback
)
;
static
void
AddBoxesForFrame
(
nsIFrame
*
aFrame
BoxCallback
*
aCallback
)
;
static
nsIFrame
*
GetFirstNonAnonymousFrame
(
nsIFrame
*
aFrame
)
;
class
RectCallback
{
public
:
virtual
void
AddRect
(
const
nsRect
&
aRect
)
=
0
;
}
;
struct
RectAccumulator
:
public
RectCallback
{
nsRect
mResultRect
;
nsRect
mFirstRect
;
bool
mSeenFirstRect
;
RectAccumulator
(
)
;
virtual
void
AddRect
(
const
nsRect
&
aRect
)
override
;
}
;
struct
RectListBuilder
:
public
RectCallback
{
DOMRectList
*
mRectList
;
explicit
RectListBuilder
(
DOMRectList
*
aList
)
;
virtual
void
AddRect
(
const
nsRect
&
aRect
)
override
;
}
;
static
nsIFrame
*
GetContainingBlockForClientRect
(
nsIFrame
*
aFrame
)
;
enum
{
RECTS_ACCOUNT_FOR_TRANSFORMS
=
0x01
RECTS_USE_CONTENT_BOX
=
0x02
RECTS_USE_PADDING_BOX
=
0x04
RECTS_USE_MARGIN_BOX
=
0x06
RECTS_WHICH_BOX_MASK
=
0x06
}
;
static
void
GetAllInFlowRects
(
nsIFrame
*
aFrame
const
nsIFrame
*
aRelativeTo
RectCallback
*
aCallback
uint32_t
aFlags
=
0
)
;
static
void
GetAllInFlowRectsAndTexts
(
nsIFrame
*
aFrame
const
nsIFrame
*
aRelativeTo
RectCallback
*
aCallback
mozilla
:
:
dom
:
:
Sequence
<
nsString
>
*
aTextList
uint32_t
aFlags
=
0
)
;
static
nsRect
GetAllInFlowRectsUnion
(
nsIFrame
*
aFrame
const
nsIFrame
*
aRelativeTo
uint32_t
aFlags
=
0
)
;
enum
{
EXCLUDE_BLUR_SHADOWS
=
0x01
}
;
static
nsRect
GetTextShadowRectsUnion
(
const
nsRect
&
aTextAndDecorationsRect
nsIFrame
*
aFrame
uint32_t
aFlags
=
0
)
;
static
nsRect
ComputeObjectDestRect
(
const
nsRect
&
aConstraintRect
const
IntrinsicSize
&
aIntrinsicSize
const
nsSize
&
aIntrinsicRatio
const
nsStylePosition
*
aStylePos
nsPoint
*
aAnchorPoint
=
nullptr
)
;
static
already_AddRefed
<
nsFontMetrics
>
GetFontMetricsForFrame
(
const
nsIFrame
*
aFrame
float
aSizeInflation
)
;
static
already_AddRefed
<
nsFontMetrics
>
GetInflatedFontMetricsForFrame
(
const
nsIFrame
*
aFrame
)
{
return
GetFontMetricsForFrame
(
aFrame
FontSizeInflationFor
(
aFrame
)
)
;
}
static
already_AddRefed
<
nsFontMetrics
>
GetFontMetricsForComputedStyle
(
ComputedStyle
*
aComputedStyle
nsPresContext
*
aPresContext
float
aSizeInflation
=
1
.
0f
uint8_t
aVariantWidth
=
NS_FONT_VARIANT_WIDTH_NORMAL
)
;
static
already_AddRefed
<
nsFontMetrics
>
GetFontMetricsOfEmphasisMarks
(
ComputedStyle
*
aComputedStyle
nsPresContext
*
aPresContext
float
aInflation
)
{
return
GetFontMetricsForComputedStyle
(
aComputedStyle
aPresContext
aInflation
*
0
.
5f
)
;
}
static
nsIFrame
*
FindChildContainingDescendant
(
nsIFrame
*
aParent
nsIFrame
*
aDescendantFrame
)
;
static
nsBlockFrame
*
FindNearestBlockAncestor
(
nsIFrame
*
aFrame
)
;
static
nsIFrame
*
GetNonGeneratedAncestor
(
nsIFrame
*
aFrame
)
;
static
bool
IsNonWrapperBlock
(
nsIFrame
*
aFrame
)
;
static
nsIFrame
*
GetParentOrPlaceholderFor
(
const
nsIFrame
*
aFrame
)
;
static
nsIFrame
*
GetParentOrPlaceholderForCrossDoc
(
nsIFrame
*
aFrame
)
;
static
nsIFrame
*
GetNextContinuationOrIBSplitSibling
(
nsIFrame
*
aFrame
)
;
static
nsIFrame
*
FirstContinuationOrIBSplitSibling
(
const
nsIFrame
*
aFrame
)
;
static
nsIFrame
*
LastContinuationOrIBSplitSibling
(
const
nsIFrame
*
aFrame
)
;
static
bool
IsFirstContinuationOrIBSplitSibling
(
const
nsIFrame
*
aFrame
)
;
static
bool
IsViewportScrollbarFrame
(
nsIFrame
*
aFrame
)
;
enum
class
IntrinsicISizeType
{
MinISize
PrefISize
}
;
static
const
auto
MIN_ISIZE
=
IntrinsicISizeType
:
:
MinISize
;
static
const
auto
PREF_ISIZE
=
IntrinsicISizeType
:
:
PrefISize
;
enum
{
IGNORE_PADDING
=
0x01
BAIL_IF_REFLOW_NEEDED
=
0x02
MIN_INTRINSIC_ISIZE
=
0x04
}
;
static
nscoord
IntrinsicForAxis
(
mozilla
:
:
PhysicalAxis
aAxis
gfxContext
*
aRenderingContext
nsIFrame
*
aFrame
IntrinsicISizeType
aType
const
mozilla
:
:
Maybe
<
LogicalSize
>
&
aPercentageBasis
=
mozilla
:
:
Nothing
(
)
uint32_t
aFlags
=
0
nscoord
aMarginBoxMinSizeClamp
=
NS_MAXSIZE
)
;
static
nscoord
IntrinsicForContainer
(
gfxContext
*
aRenderingContext
nsIFrame
*
aFrame
IntrinsicISizeType
aType
uint32_t
aFlags
=
0
)
;
static
nscoord
MinSizeContributionForAxis
(
mozilla
:
:
PhysicalAxis
aAxis
gfxContext
*
aRC
nsIFrame
*
aFrame
IntrinsicISizeType
aType
const
LogicalSize
&
aPercentageBasis
uint32_t
aFlags
=
0
)
;
static
nscoord
ComputeCBDependentValue
(
nscoord
aPercentBasis
const
LengthPercentage
&
aCoord
)
{
NS_WARNING_ASSERTION
(
aPercentBasis
!
=
NS_UNCONSTRAINEDSIZE
"
have
unconstrained
width
or
height
;
this
should
only
result
from
very
"
"
large
sizes
not
attempts
at
intrinsic
size
calculation
"
)
;
return
aCoord
.
Resolve
(
aPercentBasis
)
;
}
static
nscoord
ComputeCBDependentValue
(
nscoord
aPercentBasis
const
LengthPercentageOrAuto
&
aCoord
)
{
if
(
aCoord
.
IsAuto
(
)
)
{
return
0
;
}
return
ComputeCBDependentValue
(
aPercentBasis
aCoord
.
AsLengthPercentage
(
)
)
;
}
static
nscoord
ComputeBSizeDependentValue
(
nscoord
aContainingBlockBSize
const
LengthPercentageOrAuto
&
)
;
static
nscoord
ComputeBSizeValue
(
nscoord
aContainingBlockBSize
nscoord
aContentEdgeToBoxSizingBoxEdge
const
LengthPercentage
&
aCoord
)
{
MOZ_ASSERT
(
aContainingBlockBSize
!
=
nscoord_MAX
|
|
!
aCoord
.
HasPercent
(
)
"
caller
must
deal
with
%
%
of
unconstrained
block
-
size
"
)
;
nscoord
result
=
aCoord
.
Resolve
(
aContainingBlockBSize
)
;
return
std
:
:
max
(
0
result
-
aContentEdgeToBoxSizingBoxEdge
)
;
}
template
<
typename
SizeOrMaxSize
>
static
bool
IsAutoBSize
(
const
SizeOrMaxSize
&
aCoord
nscoord
aCBBSize
)
{
return
aCoord
.
BehavesLikeInitialValueOnBlockAxis
(
)
|
|
(
aCBBSize
=
=
nscoord_MAX
&
&
aCoord
.
HasPercent
(
)
)
;
}
static
bool
IsPaddingZero
(
const
LengthPercentage
&
aLength
)
{
return
aLength
.
Resolve
(
nscoord_MAX
)
<
=
0
&
&
aLength
.
Resolve
(
0
)
<
=
0
;
}
static
bool
IsMarginZero
(
const
LengthPercentage
&
aLength
)
{
return
aLength
.
Resolve
(
nscoord_MAX
)
=
=
0
&
&
aLength
.
Resolve
(
0
)
=
=
0
;
}
static
void
MarkDescendantsDirty
(
nsIFrame
*
aSubtreeRoot
)
;
static
void
MarkIntrinsicISizesDirtyIfDependentOnBSize
(
nsIFrame
*
aFrame
)
;
static
nsSize
ComputeAutoSizeWithIntrinsicDimensions
(
nscoord
minWidth
nscoord
minHeight
nscoord
maxWidth
nscoord
maxHeight
nscoord
tentWidth
nscoord
tentHeight
)
;
static
nscoord
PrefISizeFromInline
(
nsIFrame
*
aFrame
gfxContext
*
aRenderingContext
)
;
static
nscoord
MinISizeFromInline
(
nsIFrame
*
aFrame
gfxContext
*
aRenderingContext
)
;
static
nscolor
DarkenColorIfNeeded
(
nsIFrame
*
aFrame
nscolor
aColor
)
;
template
<
typename
Frame
typename
T
typename
S
>
static
nscolor
GetColor
(
Frame
*
aFrame
T
S
:
:
*
aField
)
{
nscolor
color
=
aFrame
-
>
GetVisitedDependentColor
(
aField
)
;
return
DarkenColorIfNeeded
(
aFrame
color
)
;
}
static
gfxFloat
GetSnappedBaselineY
(
nsIFrame
*
aFrame
gfxContext
*
aContext
nscoord
aY
nscoord
aAscent
)
;
static
gfxFloat
GetSnappedBaselineX
(
nsIFrame
*
aFrame
gfxContext
*
aContext
nscoord
aX
nscoord
aAscent
)
;
static
nscoord
AppUnitWidthOfString
(
char16_t
aC
nsFontMetrics
&
aFontMetrics
DrawTarget
*
aDrawTarget
)
{
return
AppUnitWidthOfString
(
&
aC
1
aFontMetrics
aDrawTarget
)
;
}
static
nscoord
AppUnitWidthOfString
(
const
nsString
&
aString
nsFontMetrics
&
aFontMetrics
DrawTarget
*
aDrawTarget
)
{
return
nsLayoutUtils
:
:
AppUnitWidthOfString
(
aString
.
get
(
)
aString
.
Length
(
)
aFontMetrics
aDrawTarget
)
;
}
static
nscoord
AppUnitWidthOfString
(
const
char16_t
*
aString
uint32_t
aLength
nsFontMetrics
&
aFontMetrics
DrawTarget
*
aDrawTarget
)
;
static
nscoord
AppUnitWidthOfStringBidi
(
const
nsString
&
aString
const
nsIFrame
*
aFrame
nsFontMetrics
&
aFontMetrics
gfxContext
&
aContext
)
{
return
nsLayoutUtils
:
:
AppUnitWidthOfStringBidi
(
aString
.
get
(
)
aString
.
Length
(
)
aFrame
aFontMetrics
aContext
)
;
}
static
nscoord
AppUnitWidthOfStringBidi
(
const
char16_t
*
aString
uint32_t
aLength
const
nsIFrame
*
aFrame
nsFontMetrics
&
aFontMetrics
gfxContext
&
aContext
)
;
static
bool
StringWidthIsGreaterThan
(
const
nsString
&
aString
nsFontMetrics
&
aFontMetrics
DrawTarget
*
aDrawTarget
nscoord
aWidth
)
;
static
nsBoundingMetrics
AppUnitBoundsOfString
(
const
char16_t
*
aString
uint32_t
aLength
nsFontMetrics
&
aFontMetrics
DrawTarget
*
aDrawTarget
)
;
static
void
DrawString
(
const
nsIFrame
*
aFrame
nsFontMetrics
&
aFontMetrics
gfxContext
*
aContext
const
char16_t
*
aString
int32_t
aLength
nsPoint
aPoint
ComputedStyle
*
aComputedStyle
=
nullptr
DrawStringFlags
aFlags
=
DrawStringFlags
:
:
Default
)
;
static
nsPoint
GetBackgroundFirstTilePos
(
const
nsPoint
&
aDest
const
nsPoint
&
aFill
const
nsSize
&
aRepeatSize
)
;
static
void
DrawUniDirString
(
const
char16_t
*
aString
uint32_t
aLength
const
nsPoint
&
aPoint
nsFontMetrics
&
aFontMetrics
gfxContext
&
aContext
)
;
typedef
void
(
*
TextShadowCallback
)
(
gfxContext
*
aCtx
nsPoint
aShadowOffset
const
nscolor
&
aShadowColor
void
*
aData
)
;
static
void
PaintTextShadow
(
const
nsIFrame
*
aFrame
gfxContext
*
aContext
const
nsRect
&
aTextRect
const
nsRect
&
aDirtyRect
const
nscolor
&
aForegroundColor
TextShadowCallback
aCallback
void
*
aCallbackData
)
;
static
nscoord
GetCenteredFontBaseline
(
nsFontMetrics
*
aFontMetrics
nscoord
aLineHeight
bool
aIsInverted
)
;
static
bool
GetFirstLineBaseline
(
mozilla
:
:
WritingMode
aWritingMode
const
nsIFrame
*
aFrame
nscoord
*
aResult
)
;
struct
LinePosition
{
nscoord
mBStart
mBaseline
mBEnd
;
LinePosition
operator
+
(
nscoord
aOffset
)
const
{
LinePosition
result
;
result
.
mBStart
=
mBStart
+
aOffset
;
result
.
mBaseline
=
mBaseline
+
aOffset
;
result
.
mBEnd
=
mBEnd
+
aOffset
;
return
result
;
}
}
;
static
bool
GetFirstLinePosition
(
mozilla
:
:
WritingMode
aWritingMode
const
nsIFrame
*
aFrame
LinePosition
*
aResult
)
;
static
bool
GetLastLineBaseline
(
mozilla
:
:
WritingMode
aWritingMode
const
nsIFrame
*
aFrame
nscoord
*
aResult
)
;
static
nscoord
CalculateContentBEnd
(
mozilla
:
:
WritingMode
aWritingMode
nsIFrame
*
aFrame
)
;
static
nsIFrame
*
GetClosestLayer
(
nsIFrame
*
aFrame
)
;
static
SamplingFilter
GetSamplingFilterForFrame
(
nsIFrame
*
aFrame
)
;
static
inline
void
InitDashPattern
(
StrokeOptions
&
aStrokeOptions
mozilla
:
:
StyleBorderStyle
aBorderStyle
)
{
if
(
aBorderStyle
=
=
mozilla
:
:
StyleBorderStyle
:
:
Dotted
)
{
static
Float
dot
[
]
=
{
1
.
f
1
.
f
}
;
aStrokeOptions
.
mDashLength
=
MOZ_ARRAY_LENGTH
(
dot
)
;
aStrokeOptions
.
mDashPattern
=
dot
;
}
else
if
(
aBorderStyle
=
=
mozilla
:
:
StyleBorderStyle
:
:
Dashed
)
{
static
Float
dash
[
]
=
{
5
.
f
5
.
f
}
;
aStrokeOptions
.
mDashLength
=
MOZ_ARRAY_LENGTH
(
dash
)
;
aStrokeOptions
.
mDashPattern
=
dash
;
}
else
{
aStrokeOptions
.
mDashLength
=
0
;
aStrokeOptions
.
mDashPattern
=
nullptr
;
}
}
static
gfxRect
RectToGfxRect
(
const
nsRect
&
aRect
int32_t
aAppUnitsPerDevPixel
)
;
static
gfxPoint
PointToGfxPoint
(
const
nsPoint
&
aPoint
int32_t
aAppUnitsPerPixel
)
{
return
gfxPoint
(
gfxFloat
(
aPoint
.
x
)
/
aAppUnitsPerPixel
gfxFloat
(
aPoint
.
y
)
/
aAppUnitsPerPixel
)
;
}
static
ImgDrawResult
DrawBackgroundImage
(
gfxContext
&
aContext
nsIFrame
*
aForFrame
nsPresContext
*
aPresContext
imgIContainer
*
aImage
SamplingFilter
aSamplingFilter
const
nsRect
&
aDest
const
nsRect
&
aFill
const
nsSize
&
aRepeatSize
const
nsPoint
&
aAnchor
const
nsRect
&
aDirty
uint32_t
aImageFlags
ExtendMode
aExtendMode
float
aOpacity
)
;
static
ImgDrawResult
DrawImage
(
gfxContext
&
aContext
ComputedStyle
*
aComputedStyle
nsPresContext
*
aPresContext
imgIContainer
*
aImage
const
SamplingFilter
aSamplingFilter
const
nsRect
&
aDest
const
nsRect
&
aFill
const
nsPoint
&
aAnchor
const
nsRect
&
aDirty
uint32_t
aImageFlags
float
aOpacity
=
1
.
0
)
;
static
ImgDrawResult
DrawSingleUnscaledImage
(
gfxContext
&
aContext
nsPresContext
*
aPresContext
imgIContainer
*
aImage
const
SamplingFilter
aSamplingFilter
const
nsPoint
&
aDest
const
nsRect
*
aDirty
const
mozilla
:
:
Maybe
<
SVGImageContext
>
&
aSVGContext
uint32_t
aImageFlags
const
nsRect
*
aSourceArea
=
nullptr
)
;
static
ImgDrawResult
DrawSingleImage
(
gfxContext
&
aContext
nsPresContext
*
aPresContext
imgIContainer
*
aImage
const
SamplingFilter
aSamplingFilter
const
nsRect
&
aDest
const
nsRect
&
aDirty
const
mozilla
:
:
Maybe
<
SVGImageContext
>
&
aSVGContext
uint32_t
aImageFlags
const
nsPoint
*
aAnchorPoint
=
nullptr
const
nsRect
*
aSourceArea
=
nullptr
)
;
static
void
ComputeSizeForDrawing
(
imgIContainer
*
aImage
CSSIntSize
&
aImageSize
nsSize
&
aIntrinsicRatio
bool
&
aGotWidth
bool
&
aGotHeight
)
;
static
CSSIntSize
ComputeSizeForDrawingWithFallback
(
imgIContainer
*
aImage
const
nsSize
&
aFallbackSize
)
;
static
mozilla
:
:
gfx
:
:
IntSize
ComputeImageContainerDrawingParameters
(
imgIContainer
*
aImage
nsIFrame
*
aForFrame
const
LayoutDeviceRect
&
aDestRect
const
StackingContextHelper
&
aSc
uint32_t
aFlags
mozilla
:
:
Maybe
<
SVGImageContext
>
&
aSVGContext
)
;
static
nsRect
GetWholeImageDestination
(
const
nsSize
&
aWholeImageSize
const
nsRect
&
aImageSourceArea
const
nsRect
&
aDestArea
)
;
static
already_AddRefed
<
imgIContainer
>
OrientImage
(
imgIContainer
*
aContainer
const
mozilla
:
:
StyleImageOrientation
&
aOrientation
)
;
static
bool
HasNonZeroCorner
(
const
mozilla
:
:
BorderRadius
&
aCorners
)
;
static
bool
HasNonZeroCornerOnSide
(
const
mozilla
:
:
BorderRadius
&
aCorners
mozilla
:
:
Side
aSide
)
;
static
nsTransparencyMode
GetFrameTransparency
(
nsIFrame
*
aBackgroundFrame
nsIFrame
*
aCSSRootFrame
)
;
static
bool
IsPopup
(
const
nsIFrame
*
aFrame
)
;
static
nsIFrame
*
GetDisplayRootFrame
(
nsIFrame
*
aFrame
)
;
static
nsIFrame
*
GetReferenceFrame
(
nsIFrame
*
aFrame
)
;
static
mozilla
:
:
gfx
:
:
ShapedTextFlags
GetTextRunFlagsForStyle
(
ComputedStyle
*
aComputedStyle
nsPresContext
*
aPresContext
const
nsStyleFont
*
aStyleFont
const
nsStyleText
*
aStyleText
nscoord
aLetterSpacing
)
;
static
mozilla
:
:
gfx
:
:
ShapedTextFlags
GetTextRunOrientFlagsForStyle
(
ComputedStyle
*
aComputedStyle
)
;
static
void
GetRectDifferenceStrips
(
const
nsRect
&
aR1
const
nsRect
&
aR2
nsRect
*
aHStrip
nsRect
*
aVStrip
)
;
static
nsDeviceContext
*
GetDeviceContextForScreenInfo
(
nsPIDOMWindowOuter
*
aWindow
)
;
static
bool
IsReallyFixedPos
(
const
nsIFrame
*
aFrame
)
;
static
bool
MayBeReallyFixedPos
(
const
nsIFrame
*
aFrame
)
;
enum
{
SFE_WANT_IMAGE_SURFACE
=
1
<
<
0
SFE_WANT_FIRST_FRAME_IF_IMAGE
=
1
<
<
1
SFE_NO_COLORSPACE_CONVERSION
=
1
<
<
2
SFE_PREFER_NO_PREMULTIPLY_ALPHA
=
1
<
<
3
SFE_NO_RASTERIZING_VECTORS
=
1
<
<
4
SFE_USE_ELEMENT_SIZE_IF_VECTOR
=
1
<
<
5
}
;
struct
DirectDrawInfo
{
nsCOMPtr
<
imgIContainer
>
mImgContainer
;
uint32_t
mWhichFrame
;
uint32_t
mDrawingFlags
;
}
;
struct
SurfaceFromElementResult
{
friend
class
mozilla
:
:
dom
:
:
CanvasRenderingContext2D
;
friend
class
nsLayoutUtils
;
RefPtr
<
mozilla
:
:
layers
:
:
Image
>
mLayersImage
;
protected
:
RefPtr
<
mozilla
:
:
gfx
:
:
SourceSurface
>
mSourceSurface
;
public
:
DirectDrawInfo
mDrawInfo
;
mozilla
:
:
gfx
:
:
IntSize
mSize
;
nsCOMPtr
<
nsIPrincipal
>
mPrincipal
;
nsCOMPtr
<
imgIRequest
>
mImageRequest
;
bool
mIsWriteOnly
;
bool
mIsStillLoading
;
bool
mHasSize
;
bool
mCORSUsed
;
gfxAlphaType
mAlphaType
;
SurfaceFromElementResult
(
)
;
const
RefPtr
<
mozilla
:
:
gfx
:
:
SourceSurface
>
&
GetSourceSurface
(
)
;
}
;
static
SurfaceFromElementResult
SurfaceFromOffscreenCanvas
(
mozilla
:
:
dom
:
:
OffscreenCanvas
*
aOffscreenCanvas
uint32_t
aSurfaceFlags
RefPtr
<
DrawTarget
>
&
aTarget
)
;
static
SurfaceFromElementResult
SurfaceFromOffscreenCanvas
(
mozilla
:
:
dom
:
:
OffscreenCanvas
*
aOffscreenCanvas
uint32_t
aSurfaceFlags
=
0
)
{
RefPtr
<
DrawTarget
>
target
=
nullptr
;
return
SurfaceFromOffscreenCanvas
(
aOffscreenCanvas
aSurfaceFlags
target
)
;
}
static
SurfaceFromElementResult
SurfaceFromElement
(
mozilla
:
:
dom
:
:
Element
*
aElement
uint32_t
aSurfaceFlags
RefPtr
<
DrawTarget
>
&
aTarget
)
;
static
SurfaceFromElementResult
SurfaceFromElement
(
mozilla
:
:
dom
:
:
Element
*
aElement
uint32_t
aSurfaceFlags
=
0
)
{
RefPtr
<
DrawTarget
>
target
=
nullptr
;
return
SurfaceFromElement
(
aElement
aSurfaceFlags
target
)
;
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
static
SurfaceFromElementResult
SurfaceFromElement
(
nsIImageLoadingContent
*
aElement
uint32_t
aSurfaceFlags
RefPtr
<
DrawTarget
>
&
aTarget
)
;
static
SurfaceFromElementResult
SurfaceFromElement
(
mozilla
:
:
dom
:
:
HTMLImageElement
*
aElement
uint32_t
aSurfaceFlags
RefPtr
<
DrawTarget
>
&
aTarget
)
;
static
SurfaceFromElementResult
SurfaceFromElement
(
mozilla
:
:
dom
:
:
HTMLCanvasElement
*
aElement
uint32_t
aSurfaceFlags
RefPtr
<
DrawTarget
>
&
aTarget
)
;
static
SurfaceFromElementResult
SurfaceFromElement
(
mozilla
:
:
dom
:
:
HTMLVideoElement
*
aElement
uint32_t
aSurfaceFlags
RefPtr
<
DrawTarget
>
&
aTarget
)
;
static
mozilla
:
:
dom
:
:
Element
*
GetEditableRootContentByContentEditable
(
mozilla
:
:
dom
:
:
Document
*
aDocument
)
;
static
void
AddExtraBackgroundItems
(
nsDisplayListBuilder
&
aBuilder
nsDisplayList
&
aList
nsIFrame
*
aFrame
const
nsRect
&
aCanvasArea
const
nsRegion
&
aVisibleRegion
nscolor
aBackstop
)
;
static
bool
NeedsPrintPreviewBackground
(
nsPresContext
*
aPresContext
)
;
typedef
nsTArray
<
nsAutoPtr
<
mozilla
:
:
dom
:
:
InspectorFontFace
>
>
UsedFontFaceList
;
typedef
nsDataHashtable
<
nsPtrHashKey
<
gfxFontEntry
>
mozilla
:
:
dom
:
:
InspectorFontFace
*
>
UsedFontFaceTable
;
static
nsresult
GetFontFacesForFrames
(
nsIFrame
*
aFrame
UsedFontFaceList
&
aResult
UsedFontFaceTable
&
aFontFaces
uint32_t
aMaxRanges
bool
aSkipCollapsedWhitespace
)
;
static
void
GetFontFacesForText
(
nsIFrame
*
aFrame
int32_t
aStartOffset
int32_t
aEndOffset
bool
aFollowContinuations
UsedFontFaceList
&
aResult
UsedFontFaceTable
&
aFontFaces
uint32_t
aMaxRanges
bool
aSkipCollapsedWhitespace
)
;
static
size_t
SizeOfTextRunsForFrames
(
nsIFrame
*
aFrame
mozilla
:
:
MallocSizeOf
aMallocSizeOf
bool
clear
)
;
static
bool
HasAnimationOfPropertySet
(
const
nsIFrame
*
aFrame
const
nsCSSPropertyIDSet
&
aPropertySet
)
;
static
bool
HasAnimationOfPropertySet
(
const
nsIFrame
*
aFrame
const
nsCSSPropertyIDSet
&
aPropertySet
mozilla
:
:
EffectSet
*
aEffectSet
)
;
static
bool
HasEffectiveAnimation
(
const
nsIFrame
*
aFrame
nsCSSPropertyID
aProperty
)
;
static
bool
HasEffectiveAnimation
(
const
nsIFrame
*
aFrame
const
nsCSSPropertyIDSet
&
aPropertySet
)
;
static
nsCSSPropertyIDSet
GetAnimationPropertiesForCompositor
(
const
nsIFrame
*
aStyleFrame
)
;
static
bool
AreAsyncAnimationsEnabled
(
)
;
static
bool
IsAnimationLoggingEnabled
(
)
;
static
bool
AreRetainedDisplayListsEnabled
(
)
;
static
bool
DisplayRootHasRetainedDisplayListBuilder
(
nsIFrame
*
aFrame
)
;
static
Size
ComputeSuitableScaleForAnimation
(
const
nsIFrame
*
aFrame
const
nsSize
&
aVisibleSize
const
nsSize
&
aDisplaySize
)
;
static
bool
GPUImageScalingEnabled
(
)
;
static
bool
AnimatedImageLayersEnabled
(
)
;
static
bool
IsInterCharacterRubyEnabled
(
)
;
static
bool
InterruptibleReflowEnabled
(
)
{
return
sInterruptibleReflowEnabled
;
}
static
void
UnionChildOverflow
(
nsIFrame
*
aFrame
nsOverflowAreas
&
aOverflowAreas
mozilla
:
:
layout
:
:
FrameChildListIDs
aSkipChildLists
=
mozilla
:
:
layout
:
:
FrameChildListIDs
(
)
)
;
static
float
FontSizeInflationFor
(
const
nsIFrame
*
aFrame
)
;
static
nscoord
InflationMinFontSizeFor
(
const
nsIFrame
*
aFrame
)
;
static
float
FontSizeInflationInner
(
const
nsIFrame
*
aFrame
nscoord
aMinFontSize
)
;
static
bool
FontSizeInflationEnabled
(
nsPresContext
*
aPresContext
)
;
static
uint32_t
FontSizeInflationMaxRatio
(
)
{
return
sFontSizeInflationMaxRatio
;
}
static
uint32_t
FontSizeInflationEmPerLine
(
)
{
return
sFontSizeInflationEmPerLine
;
}
static
uint32_t
FontSizeInflationMinTwips
(
)
{
return
sFontSizeInflationMinTwips
;
}
static
uint32_t
FontSizeInflationLineThreshold
(
)
{
return
sFontSizeInflationLineThreshold
;
}
static
bool
FontSizeInflationForceEnabled
(
)
{
return
sFontSizeInflationForceEnabled
;
}
static
bool
FontSizeInflationDisabledInMasterProcess
(
)
{
return
sFontSizeInflationDisabledInMasterProcess
;
}
static
float
SystemFontScale
(
)
{
return
sSystemFontScale
/
100
.
0f
;
}
static
float
MaxZoom
(
)
{
return
sZoomMaxPercent
/
100
.
0f
;
}
static
float
MinZoom
(
)
{
return
sZoomMinPercent
/
100
.
0f
;
}
static
bool
SVGTransformBoxEnabled
(
)
{
return
sSVGTransformBoxEnabled
;
}
static
uint32_t
IdlePeriodDeadlineLimit
(
)
{
return
sIdlePeriodDeadlineLimit
;
}
static
uint32_t
QuiescentFramesBeforeIdlePeriod
(
)
{
return
sQuiescentFramesBeforeIdlePeriod
;
}
static
int32_t
FontSizeInflationMappingIntercept
(
)
{
return
sFontSizeInflationMappingIntercept
;
}
static
bool
InvalidationDebuggingIsEnabled
(
)
{
return
sInvalidationDebuggingIsEnabled
|
|
getenv
(
"
MOZ_DUMP_INVALIDATION
"
)
!
=
0
;
}
static
void
Initialize
(
)
;
static
void
Shutdown
(
)
;
static
void
RegisterImageRequest
(
nsPresContext
*
aPresContext
imgIRequest
*
aRequest
bool
*
aRequestRegistered
)
;
static
void
RegisterImageRequestIfAnimated
(
nsPresContext
*
aPresContext
imgIRequest
*
aRequest
bool
*
aRequestRegistered
)
;
static
void
DeregisterImageRequest
(
nsPresContext
*
aPresContext
imgIRequest
*
aRequest
bool
*
aRequestRegistered
)
;
static
void
PostRestyleEvent
(
mozilla
:
:
dom
:
:
Element
*
mozilla
:
:
RestyleHint
nsChangeHint
aMinChangeHint
)
;
template
<
typename
PointType
typename
RectType
typename
CoordType
>
static
bool
PointIsCloserToRect
(
PointType
aPoint
const
RectType
&
aRect
CoordType
&
aClosestXDistance
CoordType
&
aClosestYDistance
)
;
static
nsRect
GetBoxShadowRectForFrame
(
nsIFrame
*
aFrame
const
nsSize
&
aFrameSize
)
;
#
ifdef
DEBUG
static
void
AssertNoDuplicateContinuations
(
nsIFrame
*
aContainer
const
nsFrameList
&
aFrameList
)
;
static
void
AssertTreeOnlyEmptyNextInFlows
(
nsIFrame
*
aSubtreeRoot
)
;
#
endif
static
mozilla
:
:
StyleTouchAction
GetTouchActionFromFrame
(
nsIFrame
*
aFrame
)
;
static
void
TransformToAncestorAndCombineRegions
(
const
nsRegion
&
aRegion
nsIFrame
*
aFrame
const
nsIFrame
*
aAncestorFrame
nsRegion
*
aPreciseTargetDest
nsRegion
*
aImpreciseTargetDest
mozilla
:
:
Maybe
<
Matrix4x4Flagged
>
*
aMatrixCache
const
mozilla
:
:
DisplayItemClip
*
aClip
)
;
static
bool
GetContentViewerSize
(
nsPresContext
*
aPresContext
LayoutDeviceIntSize
&
aOutSize
)
;
static
nsSize
CalculateCompositionSizeForFrame
(
nsIFrame
*
aFrame
bool
aSubtractScrollbars
=
true
)
;
static
CSSSize
CalculateRootCompositionSize
(
nsIFrame
*
aFrame
bool
aIsRootContentDocRootScrollFrame
const
FrameMetrics
&
aMetrics
)
;
static
nsRect
CalculateScrollableRectForFrame
(
nsIScrollableFrame
*
aScrollableFrame
nsIFrame
*
aRootFrame
)
;
static
nsRect
CalculateExpandedScrollableRect
(
nsIFrame
*
aFrame
)
;
static
bool
UsesAsyncScrolling
(
nsIFrame
*
aFrame
)
;
static
bool
AsyncPanZoomEnabled
(
nsIFrame
*
aFrame
)
;
static
float
GetCurrentAPZResolutionScale
(
PresShell
*
aPresShell
)
;
static
bool
AllowZoomingForDocument
(
const
mozilla
:
:
dom
:
:
Document
*
aDocument
)
;
static
bool
ShouldDisableApzForElement
(
nsIContent
*
aContent
)
;
static
void
LogTestDataForPaint
(
mozilla
:
:
layers
:
:
LayerManager
*
aManager
ViewID
aScrollId
const
std
:
:
string
&
aKey
const
std
:
:
string
&
aValue
)
{
DoLogTestDataForPaint
(
aManager
aScrollId
aKey
aValue
)
;
}
template
<
typename
Value
>
static
void
LogTestDataForPaint
(
mozilla
:
:
layers
:
:
LayerManager
*
aManager
ViewID
aScrollId
const
std
:
:
string
&
aKey
const
Value
&
aValue
)
{
DoLogTestDataForPaint
(
aManager
aScrollId
aKey
mozilla
:
:
ToString
(
aValue
)
)
;
}
static
FrameMetrics
CalculateBasicFrameMetrics
(
nsIScrollableFrame
*
aScrollFrame
)
;
static
bool
CalculateAndSetDisplayPortMargins
(
nsIScrollableFrame
*
aScrollFrame
RepaintMode
aRepaintMode
)
;
static
bool
MaybeCreateDisplayPort
(
nsDisplayListBuilder
&
aBuilder
nsIFrame
*
aScrollFrame
RepaintMode
aRepaintMode
)
;
static
nsIScrollableFrame
*
GetAsyncScrollableAncestorFrame
(
nsIFrame
*
aTarget
)
;
static
void
SetZeroMarginDisplayPortOnAsyncScrollableAncestors
(
nsIFrame
*
aFrame
RepaintMode
aRepaintMode
)
;
static
void
ExpireDisplayPortOnAsyncScrollableAncestor
(
nsIFrame
*
aFrame
)
;
static
bool
IsOutlineStyleAutoEnabled
(
)
;
static
void
SetBSizeFromFontMetrics
(
const
nsIFrame
*
aFrame
mozilla
:
:
ReflowOutput
&
aMetrics
const
mozilla
:
:
LogicalMargin
&
aFramePadding
mozilla
:
:
WritingMode
aLineWM
mozilla
:
:
WritingMode
aFrameWM
)
;
static
bool
HasDocumentLevelListenersForApzAwareEvents
(
PresShell
*
aPresShell
)
;
static
void
SetVisualViewportSize
(
PresShell
*
aPresShell
CSSSize
aSize
)
;
static
bool
CanScrollOriginClobberApz
(
nsAtom
*
aScrollOrigin
)
;
static
ScrollMetadata
ComputeScrollMetadata
(
nsIFrame
*
aForFrame
nsIFrame
*
aScrollFrame
nsIContent
*
aContent
const
nsIFrame
*
aReferenceFrame
mozilla
:
:
layers
:
:
LayerManager
*
aLayerManager
ViewID
aScrollParentId
const
nsRect
&
aViewport
const
mozilla
:
:
Maybe
<
nsRect
>
&
aClipRect
bool
aIsRoot
const
mozilla
:
:
Maybe
<
ContainerLayerParameters
>
&
aContainerParameters
)
;
static
mozilla
:
:
Maybe
<
ScrollMetadata
>
GetRootMetadata
(
nsDisplayListBuilder
*
aBuilder
mozilla
:
:
layers
:
:
LayerManager
*
aLayerManager
const
ContainerLayerParameters
&
aContainerParameters
const
std
:
:
function
<
bool
(
ViewID
&
aScrollId
)
>
&
aCallback
)
;
static
nsMargin
ScrollbarAreaToExcludeFromCompositionBoundsFor
(
nsIFrame
*
aScrollFrame
)
;
static
bool
ContainsMetricsWithId
(
const
Layer
*
aLayer
const
ViewID
&
aScrollId
)
;
static
bool
ShouldUseNoScriptSheet
(
mozilla
:
:
dom
:
:
Document
*
)
;
static
bool
ShouldUseNoFramesSheet
(
mozilla
:
:
dom
:
:
Document
*
)
;
static
void
GetFrameTextContent
(
nsIFrame
*
aFrame
nsAString
&
aResult
)
;
static
void
AppendFrameTextContent
(
nsIFrame
*
aFrame
nsAString
&
aResult
)
;
static
nsRect
GetSelectionBoundingRect
(
mozilla
:
:
dom
:
:
Selection
*
aSel
)
;
static
CSSRect
GetBoundingContentRect
(
const
nsIContent
*
aContent
const
nsIScrollableFrame
*
aRootScrollFrame
)
;
static
nsBlockFrame
*
GetFloatContainingBlock
(
nsIFrame
*
aFrame
)
;
static
bool
IsTransformed
(
nsIFrame
*
aForFrame
nsIFrame
*
aTopFrame
=
nullptr
)
;
static
CSSPoint
GetCumulativeApzCallbackTransform
(
nsIFrame
*
aFrame
)
;
static
nsRect
ComputePartialPrerenderArea
(
const
nsRect
&
aDirtyRect
const
nsRect
&
aOverflow
const
nsSize
&
aPrerenderSize
)
;
static
bool
IsInvisibleBreak
(
nsINode
*
aNode
nsIFrame
*
*
aNextLineFrame
=
nullptr
)
;
static
nsRect
ComputeGeometryBox
(
nsIFrame
*
aFrame
StyleGeometryBox
aGeometryBox
)
;
static
nsPoint
ComputeOffsetToUserSpace
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
;
static
uint8_t
ControlCharVisibilityDefault
(
)
;
static
already_AddRefed
<
nsFontMetrics
>
GetMetricsFor
(
nsPresContext
*
aPresContext
bool
aIsVertical
const
nsStyleFont
*
aStyleFont
nscoord
aFontSize
bool
aUseUserFontSet
)
;
static
void
ComputeSystemFont
(
nsFont
*
aSystemFont
mozilla
:
:
LookAndFeel
:
:
FontID
aFontID
const
nsFont
*
aDefaultVariableFont
)
;
static
void
ComputeFontFeatures
(
const
nsCSSValuePairList
*
aFeaturesList
nsTArray
<
gfxFontFeature
>
&
aFeatureSettings
)
;
static
void
ComputeFontVariations
(
const
nsCSSValuePairList
*
aVariationsList
nsTArray
<
gfxFontVariation
>
&
aVariationSettings
)
;
static
uint32_t
ParseFontLanguageOverride
(
const
nsAString
&
aLangTag
)
;
static
bool
ShouldHandleMetaViewport
(
const
mozilla
:
:
dom
:
:
Document
*
)
;
template
<
bool
clampNegativeResultToZero
>
static
nscoord
ResolveToLength
(
const
LengthPercentage
&
aLengthPercentage
nscoord
aPercentageBasis
)
{
nscoord
value
=
(
aPercentageBasis
=
=
NS_UNCONSTRAINEDSIZE
)
?
aLengthPercentage
.
Resolve
(
0
)
:
aLengthPercentage
.
Resolve
(
aPercentageBasis
)
;
return
clampNegativeResultToZero
?
std
:
:
max
(
0
value
)
:
value
;
}
static
nscoord
ResolveGapToLength
(
const
mozilla
:
:
NonNegativeLengthPercentageOrNormal
&
aGap
nscoord
aPercentageBasis
)
{
if
(
aGap
.
IsNormal
(
)
)
{
return
nscoord
(
0
)
;
}
return
ResolveToLength
<
true
>
(
aGap
.
AsLengthPercentage
(
)
aPercentageBasis
)
;
}
static
ComputedStyle
*
StyleForScrollbar
(
nsIFrame
*
aScrollbarPart
)
;
static
mozilla
:
:
Maybe
<
mozilla
:
:
MotionPathData
>
ResolveMotionPath
(
const
nsIFrame
*
aFrame
)
;
private
:
static
uint32_t
sFontSizeInflationEmPerLine
;
static
uint32_t
sFontSizeInflationMinTwips
;
static
uint32_t
sFontSizeInflationLineThreshold
;
static
int32_t
sFontSizeInflationMappingIntercept
;
static
uint32_t
sFontSizeInflationMaxRatio
;
static
bool
sFontSizeInflationForceEnabled
;
static
bool
sFontSizeInflationDisabledInMasterProcess
;
static
uint32_t
sSystemFontScale
;
static
uint32_t
sZoomMaxPercent
;
static
uint32_t
sZoomMinPercent
;
static
bool
sInvalidationDebuggingIsEnabled
;
static
bool
sInterruptibleReflowEnabled
;
static
bool
sSVGTransformBoxEnabled
;
static
uint32_t
sIdlePeriodDeadlineLimit
;
static
uint32_t
sQuiescentFramesBeforeIdlePeriod
;
static
void
DoLogTestDataForPaint
(
mozilla
:
:
layers
:
:
LayerManager
*
aManager
ViewID
aScrollId
const
std
:
:
string
&
aKey
const
std
:
:
string
&
aValue
)
;
static
bool
IsAPZTestLoggingEnabled
(
)
;
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
nsLayoutUtils
:
:
PaintFrameFlags
)
template
<
typename
PointType
typename
RectType
typename
CoordType
>
bool
nsLayoutUtils
:
:
PointIsCloserToRect
(
PointType
aPoint
const
RectType
&
aRect
CoordType
&
aClosestXDistance
CoordType
&
aClosestYDistance
)
{
CoordType
fromLeft
=
aPoint
.
x
-
aRect
.
x
;
CoordType
fromRight
=
aPoint
.
x
-
aRect
.
XMost
(
)
;
CoordType
xDistance
;
if
(
fromLeft
>
=
0
&
&
fromRight
<
=
0
)
{
xDistance
=
0
;
}
else
{
xDistance
=
std
:
:
min
(
abs
(
fromLeft
)
abs
(
fromRight
)
)
;
}
if
(
xDistance
<
=
aClosestXDistance
)
{
if
(
xDistance
<
aClosestXDistance
)
{
aClosestYDistance
=
std
:
:
numeric_limits
<
CoordType
>
:
:
max
(
)
;
}
CoordType
fromTop
=
aPoint
.
y
-
aRect
.
y
;
CoordType
fromBottom
=
aPoint
.
y
-
aRect
.
YMost
(
)
;
CoordType
yDistance
;
if
(
fromTop
>
=
0
&
&
fromBottom
<
=
0
)
{
yDistance
=
0
;
}
else
{
yDistance
=
std
:
:
min
(
abs
(
fromTop
)
abs
(
fromBottom
)
)
;
}
if
(
yDistance
<
aClosestYDistance
)
{
aClosestXDistance
=
xDistance
;
aClosestYDistance
=
yDistance
;
return
true
;
}
}
return
false
;
}
namespace
mozilla
{
inline
gfx
:
:
Point
NSPointToPoint
(
const
nsPoint
&
aPoint
int32_t
aAppUnitsPerPixel
)
{
return
gfx
:
:
Point
(
gfx
:
:
Float
(
aPoint
.
x
)
/
aAppUnitsPerPixel
gfx
:
:
Float
(
aPoint
.
y
)
/
aAppUnitsPerPixel
)
;
}
gfx
:
:
Rect
NSRectToRect
(
const
nsRect
&
aRect
double
aAppUnitsPerPixel
)
;
gfx
:
:
Rect
NSRectToSnappedRect
(
const
nsRect
&
aRect
double
aAppUnitsPerPixel
const
gfx
:
:
DrawTarget
&
aSnapDT
)
;
gfx
:
:
Rect
NSRectToNonEmptySnappedRect
(
const
nsRect
&
aRect
double
aAppUnitsPerPixel
const
gfx
:
:
DrawTarget
&
aSnapDT
)
;
void
StrokeLineWithSnapping
(
const
nsPoint
&
aP1
const
nsPoint
&
aP2
int32_t
aAppUnitsPerDevPixel
gfx
:
:
DrawTarget
&
aDrawTarget
const
gfx
:
:
Pattern
&
aPattern
const
gfx
:
:
StrokeOptions
&
aStrokeOptions
=
gfx
:
:
StrokeOptions
(
)
const
gfx
:
:
DrawOptions
&
aDrawOptions
=
gfx
:
:
DrawOptions
(
)
)
;
namespace
layout
{
class
AutoMaybeDisableFontInflation
{
public
:
explicit
AutoMaybeDisableFontInflation
(
nsIFrame
*
aFrame
)
;
~
AutoMaybeDisableFontInflation
(
)
;
private
:
nsPresContext
*
mPresContext
;
bool
mOldValue
;
}
;
void
MaybeSetupTransactionIdAllocator
(
layers
:
:
LayerManager
*
aManager
nsPresContext
*
aPresContext
)
;
}
}
class
nsSetAttrRunnable
:
public
mozilla
:
:
Runnable
{
public
:
nsSetAttrRunnable
(
mozilla
:
:
dom
:
:
Element
*
aElement
nsAtom
*
aAttrName
const
nsAString
&
aValue
)
;
nsSetAttrRunnable
(
mozilla
:
:
dom
:
:
Element
*
aElement
nsAtom
*
aAttrName
int32_t
aValue
)
;
NS_DECL_NSIRUNNABLE
RefPtr
<
Element
>
mElement
;
RefPtr
<
nsAtom
>
mAttrName
;
nsAutoString
mValue
;
}
;
class
nsUnsetAttrRunnable
:
public
mozilla
:
:
Runnable
{
public
:
nsUnsetAttrRunnable
(
mozilla
:
:
dom
:
:
Element
*
aElement
nsAtom
*
aAttrName
)
;
NS_DECL_NSIRUNNABLE
RefPtr
<
Element
>
mElement
;
RefPtr
<
nsAtom
>
mAttrName
;
}
;
template
<
typename
T
>
class
MOZ_RAII
SetAndNullOnExit
{
public
:
SetAndNullOnExit
(
T
*
&
aVariable
T
*
aValue
)
{
aVariable
=
aValue
;
mVariable
=
&
aVariable
;
}
~
SetAndNullOnExit
(
)
{
*
mVariable
=
nullptr
;
}
private
:
T
*
*
mVariable
;
}
;
#
endif
