#
include
"
nscore
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsStyleContext
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
plhash
.
h
"
#
include
"
nsPlaceholderFrame
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsILayoutHistoryState
.
h
"
#
include
"
nsPresState
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsAbsoluteContainingBlock
.
h
"
#
include
"
ChildIterator
.
h
"
#
include
"
nsFrameManager
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
nsIStatefulFrame
.
h
"
#
include
"
nsContainerFrame
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
nsFrameManagerBase
:
:
nsFrameManagerBase
(
)
:
mPresShell
(
nullptr
)
mRootFrame
(
nullptr
)
mUndisplayedMap
(
nullptr
)
mDisplayContentsMap
(
nullptr
)
mIsDestroyingFrames
(
false
)
{
}
class
nsFrameManagerBase
:
:
UndisplayedMap
:
private
nsClassHashtable
<
nsPtrHashKey
<
nsIContent
>
LinkedList
<
UndisplayedNode
>
>
{
typedef
nsClassHashtable
<
nsPtrHashKey
<
nsIContent
>
LinkedList
<
UndisplayedNode
>
>
base_type
;
public
:
UndisplayedMap
(
)
;
~
UndisplayedMap
(
)
;
UndisplayedNode
*
GetFirstNode
(
nsIContent
*
aParentContent
)
;
void
AddNodeFor
(
nsIContent
*
aParentContent
nsIContent
*
aChild
nsStyleContext
*
aStyle
)
;
void
RemoveNodeFor
(
nsIContent
*
aParentContent
UndisplayedNode
*
aNode
)
;
void
RemoveNodesFor
(
nsIContent
*
aParentContent
)
;
nsAutoPtr
<
LinkedList
<
UndisplayedNode
>
>
UnlinkNodesFor
(
nsIContent
*
aParentContent
)
;
void
Clear
(
)
;
protected
:
LinkedList
<
UndisplayedNode
>
*
GetListFor
(
nsIContent
*
aParentContent
)
;
LinkedList
<
UndisplayedNode
>
*
GetOrCreateListFor
(
nsIContent
*
aParentContent
)
;
void
AppendNodeFor
(
UndisplayedNode
*
aNode
nsIContent
*
aParentContent
)
;
nsIContent
*
GetApplicableParent
(
nsIContent
*
aParent
)
;
}
;
nsFrameManager
:
:
~
nsFrameManager
(
)
{
NS_ASSERTION
(
!
mPresShell
"
nsFrameManager
:
:
Destroy
never
called
"
)
;
}
void
nsFrameManager
:
:
Destroy
(
)
{
NS_ASSERTION
(
mPresShell
"
Frame
manager
already
shut
down
.
"
)
;
mPresShell
-
>
SetIgnoreFrameDestruction
(
true
)
;
nsFrameManager
:
:
ClearPlaceholderFrameMap
(
)
;
if
(
mRootFrame
)
{
mRootFrame
-
>
Destroy
(
)
;
mRootFrame
=
nullptr
;
}
delete
mUndisplayedMap
;
mUndisplayedMap
=
nullptr
;
delete
mDisplayContentsMap
;
mDisplayContentsMap
=
nullptr
;
mPresShell
=
nullptr
;
}
nsPlaceholderFrame
*
nsFrameManager
:
:
GetPlaceholderFrameFor
(
const
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
)
;
MOZ_ASSERT
(
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
)
;
return
aFrame
-
>
GetProperty
(
nsIFrame
:
:
PlaceholderFrameProperty
(
)
)
;
}
void
nsFrameManager
:
:
RegisterPlaceholderFrame
(
nsPlaceholderFrame
*
aPlaceholderFrame
)
{
MOZ_ASSERT
(
aPlaceholderFrame
)
;
MOZ_ASSERT
(
!
GetPlaceholderFrameFor
(
aPlaceholderFrame
-
>
GetOutOfFlowFrame
(
)
)
"
Registering
a
placeholder
for
a
frame
that
already
has
a
placeholder
!
"
)
;
aPlaceholderFrame
-
>
GetOutOfFlowFrame
(
)
-
>
SetProperty
(
nsIFrame
:
:
PlaceholderFrameProperty
(
)
aPlaceholderFrame
)
;
}
void
nsFrameManager
:
:
UnregisterPlaceholderFrame
(
nsPlaceholderFrame
*
aPlaceholderFrame
)
{
MOZ_ASSERT
(
aPlaceholderFrame
)
;
aPlaceholderFrame
-
>
GetOutOfFlowFrame
(
)
-
>
DeleteProperty
(
nsIFrame
:
:
PlaceholderFrameProperty
(
)
)
;
}
void
nsFrameManager
:
:
ClearPlaceholderFrameMap
(
)
{
}
static
nsIContent
*
ParentForUndisplayedMap
(
const
nsIContent
*
aContent
)
{
MOZ_ASSERT
(
aContent
)
;
nsIContent
*
parent
=
aContent
-
>
GetParentElementCrossingShadowRoot
(
)
;
MOZ_ASSERT
(
parent
|
|
!
aContent
-
>
GetParent
(
)
"
no
non
-
elements
"
)
;
return
parent
;
}
nsStyleContext
*
nsFrameManager
:
:
GetStyleContextInMap
(
UndisplayedMap
*
aMap
const
nsIContent
*
aContent
)
{
UndisplayedNode
*
node
=
GetUndisplayedNodeInMapFor
(
aMap
aContent
)
;
return
node
?
node
-
>
mStyle
.
get
(
)
:
nullptr
;
}
UndisplayedNode
*
nsFrameManager
:
:
GetUndisplayedNodeInMapFor
(
UndisplayedMap
*
aMap
const
nsIContent
*
aContent
)
{
if
(
!
aContent
)
{
return
nullptr
;
}
nsIContent
*
parent
=
ParentForUndisplayedMap
(
aContent
)
;
for
(
UndisplayedNode
*
node
=
aMap
-
>
GetFirstNode
(
parent
)
;
node
;
node
=
node
-
>
getNext
(
)
)
{
if
(
node
-
>
mContent
=
=
aContent
)
return
node
;
}
return
nullptr
;
}
UndisplayedNode
*
nsFrameManager
:
:
GetAllUndisplayedNodesInMapFor
(
UndisplayedMap
*
aMap
nsIContent
*
aParentContent
)
{
return
aMap
?
aMap
-
>
GetFirstNode
(
aParentContent
)
:
nullptr
;
}
UndisplayedNode
*
nsFrameManager
:
:
GetAllUndisplayedContentIn
(
nsIContent
*
aParentContent
)
{
return
GetAllUndisplayedNodesInMapFor
(
mUndisplayedMap
aParentContent
)
;
}
void
nsFrameManager
:
:
SetStyleContextInMap
(
UndisplayedMap
*
aMap
nsIContent
*
aContent
nsStyleContext
*
aStyleContext
)
{
MOZ_ASSERT
(
!
aStyleContext
-
>
GetPseudo
(
)
"
Should
only
have
actual
elements
here
"
)
;
#
if
defined
(
DEBUG_UNDISPLAYED_MAP
)
|
|
defined
(
DEBUG_DISPLAY_BOX_CONTENTS_MAP
)
static
int
i
=
0
;
printf
(
"
SetStyleContextInMap
(
%
d
)
:
p
=
%
p
\
n
"
i
+
+
(
void
*
)
aContent
)
;
#
endif
MOZ_ASSERT
(
!
GetStyleContextInMap
(
aMap
aContent
)
"
Already
have
an
entry
for
aContent
"
)
;
nsIContent
*
parent
=
ParentForUndisplayedMap
(
aContent
)
;
#
ifdef
DEBUG
nsIPresShell
*
shell
=
aStyleContext
-
>
PresContext
(
)
-
>
PresShell
(
)
;
NS_ASSERTION
(
parent
|
|
(
shell
&
&
shell
-
>
GetDocument
(
)
&
&
shell
-
>
GetDocument
(
)
-
>
GetRootElement
(
)
=
=
aContent
)
"
undisplayed
content
must
have
a
parent
unless
it
'
s
the
root
"
"
element
"
)
;
#
endif
aMap
-
>
AddNodeFor
(
parent
aContent
aStyleContext
)
;
}
void
nsFrameManager
:
:
SetUndisplayedContent
(
nsIContent
*
aContent
nsStyleContext
*
aStyleContext
)
{
if
(
!
mUndisplayedMap
)
{
mUndisplayedMap
=
new
UndisplayedMap
;
}
SetStyleContextInMap
(
mUndisplayedMap
aContent
aStyleContext
)
;
}
void
nsFrameManager
:
:
ChangeStyleContextInMap
(
UndisplayedMap
*
aMap
nsIContent
*
aContent
nsStyleContext
*
aStyleContext
)
{
MOZ_ASSERT
(
aMap
"
expecting
a
map
"
)
;
#
if
defined
(
DEBUG_UNDISPLAYED_MAP
)
|
|
defined
(
DEBUG_DISPLAY_BOX_CONTENTS_MAP
)
static
int
i
=
0
;
printf
(
"
ChangeStyleContextInMap
(
%
d
)
:
p
=
%
p
\
n
"
i
+
+
(
void
*
)
aContent
)
;
#
endif
for
(
UndisplayedNode
*
node
=
aMap
-
>
GetFirstNode
(
aContent
-
>
GetParent
(
)
)
;
node
;
node
=
node
-
>
getNext
(
)
)
{
if
(
node
-
>
mContent
=
=
aContent
)
{
node
-
>
mStyle
=
aStyleContext
;
return
;
}
}
MOZ_CRASH
(
"
couldn
'
t
find
the
entry
to
change
"
)
;
}
void
nsFrameManager
:
:
ClearUndisplayedContentIn
(
nsIContent
*
aContent
nsIContent
*
aParentContent
)
{
#
ifdef
DEBUG_UNDISPLAYED_MAP
static
int
i
=
0
;
printf
(
"
ClearUndisplayedContent
(
%
d
)
:
content
=
%
p
parent
=
%
p
-
-
>
"
i
+
+
(
void
*
)
aContent
(
void
*
)
aParentContent
)
;
#
endif
if
(
!
mUndisplayedMap
)
{
return
;
}
for
(
UndisplayedNode
*
node
=
mUndisplayedMap
-
>
GetFirstNode
(
aParentContent
)
;
node
;
node
=
node
-
>
getNext
(
)
)
{
if
(
node
-
>
mContent
=
=
aContent
)
{
mUndisplayedMap
-
>
RemoveNodeFor
(
aParentContent
node
)
;
#
ifdef
DEBUG_UNDISPLAYED_MAP
printf
(
"
REMOVED
!
\
n
"
)
;
#
endif
MOZ_ASSERT
(
!
GetUndisplayedContent
(
aContent
)
"
Found
more
undisplayed
content
data
after
removal
"
)
;
return
;
}
}
#
ifdef
DEBUG_UNDISPLAYED_MAP
printf
(
"
not
found
.
\
n
"
)
;
#
endif
}
void
nsFrameManager
:
:
ClearAllUndisplayedContentIn
(
nsIContent
*
aParentContent
)
{
#
ifdef
DEBUG_UNDISPLAYED_MAP
static
int
i
=
0
;
printf
(
"
ClearAllUndisplayedContentIn
(
%
d
)
:
parent
=
%
p
\
n
"
i
+
+
(
void
*
)
aParentContent
)
;
#
endif
if
(
mUndisplayedMap
)
{
mUndisplayedMap
-
>
RemoveNodesFor
(
aParentContent
)
;
}
FlattenedChildIterator
iter
(
aParentContent
)
;
for
(
nsIContent
*
child
=
iter
.
GetNextChild
(
)
;
child
;
child
=
iter
.
GetNextChild
(
)
)
{
if
(
child
-
>
GetParent
(
)
!
=
aParentContent
)
{
ClearUndisplayedContentIn
(
child
child
-
>
GetParent
(
)
)
;
}
}
}
void
nsFrameManager
:
:
SetDisplayContents
(
nsIContent
*
aContent
nsStyleContext
*
aStyleContext
)
{
if
(
!
mDisplayContentsMap
)
{
mDisplayContentsMap
=
new
UndisplayedMap
;
}
SetStyleContextInMap
(
mDisplayContentsMap
aContent
aStyleContext
)
;
}
UndisplayedNode
*
nsFrameManager
:
:
GetAllDisplayContentsIn
(
nsIContent
*
aParentContent
)
{
return
GetAllUndisplayedNodesInMapFor
(
mDisplayContentsMap
aParentContent
)
;
}
void
nsFrameManager
:
:
ClearDisplayContentsIn
(
nsIContent
*
aContent
nsIContent
*
aParentContent
)
{
#
ifdef
DEBUG_DISPLAY_CONTENTS_MAP
static
int
i
=
0
;
printf
(
"
ClearDisplayContents
(
%
d
)
:
content
=
%
p
parent
=
%
p
-
-
>
"
i
+
+
(
void
*
)
aContent
(
void
*
)
aParentContent
)
;
#
endif
if
(
!
mDisplayContentsMap
)
{
return
;
}
for
(
UndisplayedNode
*
node
=
mDisplayContentsMap
-
>
GetFirstNode
(
aParentContent
)
;
node
;
node
=
node
-
>
getNext
(
)
)
{
if
(
node
-
>
mContent
=
=
aContent
)
{
mDisplayContentsMap
-
>
RemoveNodeFor
(
aParentContent
node
)
;
#
ifdef
DEBUG_DISPLAY_CONTENTS_MAP
printf
(
"
REMOVED
!
\
n
"
)
;
#
endif
MOZ_ASSERT
(
!
GetDisplayContentsStyleFor
(
aContent
)
"
Found
more
entries
for
aContent
after
removal
"
)
;
ClearAllDisplayContentsIn
(
aContent
)
;
ClearAllUndisplayedContentIn
(
aContent
)
;
return
;
}
}
#
ifdef
DEBUG_DISPLAY_CONTENTS_MAP
printf
(
"
not
found
.
\
n
"
)
;
#
endif
}
void
nsFrameManager
:
:
ClearAllDisplayContentsIn
(
nsIContent
*
aParentContent
)
{
#
ifdef
DEBUG_DISPLAY_CONTENTS_MAP
static
int
i
=
0
;
printf
(
"
ClearAllDisplayContentsIn
(
%
d
)
:
parent
=
%
p
\
n
"
i
+
+
(
void
*
)
aParentContent
)
;
#
endif
if
(
mDisplayContentsMap
)
{
nsAutoPtr
<
LinkedList
<
UndisplayedNode
>
>
list
=
mDisplayContentsMap
-
>
UnlinkNodesFor
(
aParentContent
)
;
if
(
list
)
{
while
(
UndisplayedNode
*
node
=
list
-
>
popFirst
(
)
)
{
ClearAllDisplayContentsIn
(
node
-
>
mContent
)
;
ClearAllUndisplayedContentIn
(
node
-
>
mContent
)
;
delete
node
;
}
}
}
FlattenedChildIterator
iter
(
aParentContent
)
;
for
(
nsIContent
*
child
=
iter
.
GetNextChild
(
)
;
child
;
child
=
iter
.
GetNextChild
(
)
)
{
if
(
child
-
>
GetParent
(
)
!
=
aParentContent
)
{
ClearDisplayContentsIn
(
child
child
-
>
GetParent
(
)
)
;
ClearUndisplayedContentIn
(
child
child
-
>
GetParent
(
)
)
;
}
}
}
void
nsFrameManager
:
:
AppendFrames
(
nsContainerFrame
*
aParentFrame
ChildListID
aListID
nsFrameList
&
aFrameList
)
{
if
(
aParentFrame
-
>
IsAbsoluteContainer
(
)
&
&
aListID
=
=
aParentFrame
-
>
GetAbsoluteListID
(
)
)
{
aParentFrame
-
>
GetAbsoluteContainingBlock
(
)
-
>
AppendFrames
(
aParentFrame
aListID
aFrameList
)
;
}
else
{
aParentFrame
-
>
AppendFrames
(
aListID
aFrameList
)
;
}
}
void
nsFrameManager
:
:
InsertFrames
(
nsContainerFrame
*
aParentFrame
ChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
aFrameList
)
{
NS_PRECONDITION
(
!
aPrevFrame
|
|
(
!
aPrevFrame
-
>
GetNextContinuation
(
)
|
|
(
(
(
aPrevFrame
-
>
GetNextContinuation
(
)
-
>
GetStateBits
(
)
&
NS_FRAME_IS_OVERFLOW_CONTAINER
)
)
&
&
!
(
aPrevFrame
-
>
GetStateBits
(
)
&
NS_FRAME_IS_OVERFLOW_CONTAINER
)
)
)
"
aPrevFrame
must
be
the
last
continuation
in
its
chain
!
"
)
;
if
(
aParentFrame
-
>
IsAbsoluteContainer
(
)
&
&
aListID
=
=
aParentFrame
-
>
GetAbsoluteListID
(
)
)
{
aParentFrame
-
>
GetAbsoluteContainingBlock
(
)
-
>
InsertFrames
(
aParentFrame
aListID
aPrevFrame
aFrameList
)
;
}
else
{
aParentFrame
-
>
InsertFrames
(
aListID
aPrevFrame
aFrameList
)
;
}
}
void
nsFrameManager
:
:
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
{
bool
wasDestroyingFrames
=
mIsDestroyingFrames
;
mIsDestroyingFrames
=
true
;
aOldFrame
-
>
InvalidateFrameForRemoval
(
)
;
NS_ASSERTION
(
!
aOldFrame
-
>
GetPrevContinuation
(
)
|
|
aOldFrame
-
>
IsTextFrame
(
)
"
Must
remove
first
continuation
.
"
)
;
NS_ASSERTION
(
!
(
aOldFrame
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
&
&
GetPlaceholderFrameFor
(
aOldFrame
)
)
"
Must
call
RemoveFrame
on
placeholder
for
out
-
of
-
flows
.
"
)
;
nsContainerFrame
*
parentFrame
=
aOldFrame
-
>
GetParent
(
)
;
if
(
parentFrame
-
>
IsAbsoluteContainer
(
)
&
&
aListID
=
=
parentFrame
-
>
GetAbsoluteListID
(
)
)
{
parentFrame
-
>
GetAbsoluteContainingBlock
(
)
-
>
RemoveFrame
(
parentFrame
aListID
aOldFrame
)
;
}
else
{
parentFrame
-
>
RemoveFrame
(
aListID
aOldFrame
)
;
}
mIsDestroyingFrames
=
wasDestroyingFrames
;
}
void
nsFrameManager
:
:
NotifyDestroyingFrame
(
nsIFrame
*
aFrame
)
{
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
content
&
&
content
-
>
GetPrimaryFrame
(
)
=
=
aFrame
)
{
ClearAllUndisplayedContentIn
(
content
)
;
ClearAllDisplayContentsIn
(
content
)
;
}
}
void
nsFrameManager
:
:
CaptureFrameStateFor
(
nsIFrame
*
aFrame
nsILayoutHistoryState
*
aState
)
{
if
(
!
aFrame
|
|
!
aState
)
{
NS_WARNING
(
"
null
frame
or
state
"
)
;
return
;
}
nsIStatefulFrame
*
statefulFrame
=
do_QueryFrame
(
aFrame
)
;
if
(
!
statefulFrame
)
{
return
;
}
nsAutoPtr
<
nsPresState
>
frameState
;
nsresult
rv
=
statefulFrame
-
>
SaveState
(
getter_Transfers
(
frameState
)
)
;
if
(
!
frameState
)
{
return
;
}
nsAutoCString
stateKey
;
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
nsIDocument
*
doc
=
content
?
content
-
>
GetUncomposedDoc
(
)
:
nullptr
;
rv
=
statefulFrame
-
>
GenerateStateKey
(
content
doc
stateKey
)
;
if
(
NS_FAILED
(
rv
)
|
|
stateKey
.
IsEmpty
(
)
)
{
return
;
}
aState
-
>
AddState
(
stateKey
frameState
.
forget
(
)
)
;
}
void
nsFrameManager
:
:
CaptureFrameState
(
nsIFrame
*
aFrame
nsILayoutHistoryState
*
aState
)
{
NS_PRECONDITION
(
nullptr
!
=
aFrame
&
&
nullptr
!
=
aState
"
null
parameters
passed
in
"
)
;
CaptureFrameStateFor
(
aFrame
aState
)
;
nsIFrame
:
:
ChildListIterator
lists
(
aFrame
)
;
for
(
;
!
lists
.
IsDone
(
)
;
lists
.
Next
(
)
)
{
nsFrameList
:
:
Enumerator
childFrames
(
lists
.
CurrentList
(
)
)
;
for
(
;
!
childFrames
.
AtEnd
(
)
;
childFrames
.
Next
(
)
)
{
nsIFrame
*
child
=
childFrames
.
get
(
)
;
if
(
child
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
{
continue
;
}
CaptureFrameState
(
nsPlaceholderFrame
:
:
GetRealFrameFor
(
child
)
aState
)
;
}
}
}
void
nsFrameManager
:
:
RestoreFrameStateFor
(
nsIFrame
*
aFrame
nsILayoutHistoryState
*
aState
)
{
if
(
!
aFrame
|
|
!
aState
)
{
NS_WARNING
(
"
null
frame
or
state
"
)
;
return
;
}
nsIStatefulFrame
*
statefulFrame
=
do_QueryFrame
(
aFrame
)
;
if
(
!
statefulFrame
)
{
return
;
}
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
!
content
)
{
return
;
}
nsAutoCString
stateKey
;
nsIDocument
*
doc
=
content
-
>
GetUncomposedDoc
(
)
;
nsresult
rv
=
statefulFrame
-
>
GenerateStateKey
(
content
doc
stateKey
)
;
if
(
NS_FAILED
(
rv
)
|
|
stateKey
.
IsEmpty
(
)
)
{
return
;
}
nsPresState
*
frameState
=
aState
-
>
GetState
(
stateKey
)
;
if
(
!
frameState
)
{
return
;
}
rv
=
statefulFrame
-
>
RestoreState
(
frameState
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
aState
-
>
RemoveState
(
stateKey
)
;
}
void
nsFrameManager
:
:
RestoreFrameState
(
nsIFrame
*
aFrame
nsILayoutHistoryState
*
aState
)
{
NS_PRECONDITION
(
nullptr
!
=
aFrame
&
&
nullptr
!
=
aState
"
null
parameters
passed
in
"
)
;
RestoreFrameStateFor
(
aFrame
aState
)
;
nsIFrame
:
:
ChildListIterator
lists
(
aFrame
)
;
for
(
;
!
lists
.
IsDone
(
)
;
lists
.
Next
(
)
)
{
nsFrameList
:
:
Enumerator
childFrames
(
lists
.
CurrentList
(
)
)
;
for
(
;
!
childFrames
.
AtEnd
(
)
;
childFrames
.
Next
(
)
)
{
RestoreFrameState
(
childFrames
.
get
(
)
aState
)
;
}
}
}
nsFrameManagerBase
:
:
UndisplayedMap
:
:
UndisplayedMap
(
)
{
MOZ_COUNT_CTOR
(
nsFrameManagerBase
:
:
UndisplayedMap
)
;
}
nsFrameManagerBase
:
:
UndisplayedMap
:
:
~
UndisplayedMap
(
void
)
{
MOZ_COUNT_DTOR
(
nsFrameManagerBase
:
:
UndisplayedMap
)
;
Clear
(
)
;
}
void
nsFrameManagerBase
:
:
UndisplayedMap
:
:
Clear
(
)
{
for
(
auto
iter
=
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
*
list
=
iter
.
UserData
(
)
;
while
(
auto
*
node
=
list
-
>
popFirst
(
)
)
{
delete
node
;
}
iter
.
Remove
(
)
;
}
}
nsIContent
*
nsFrameManagerBase
:
:
UndisplayedMap
:
:
GetApplicableParent
(
nsIContent
*
aParent
)
{
if
(
aParent
&
&
nsContentUtils
:
:
IsContentInsertionPoint
(
aParent
)
)
{
return
aParent
-
>
GetParent
(
)
;
}
return
aParent
;
}
LinkedList
<
UndisplayedNode
>
*
nsFrameManagerBase
:
:
UndisplayedMap
:
:
GetListFor
(
nsIContent
*
aParent
)
{
aParent
=
GetApplicableParent
(
aParent
)
;
LinkedList
<
UndisplayedNode
>
*
list
;
if
(
Get
(
aParent
&
list
)
)
{
return
list
;
}
return
nullptr
;
}
LinkedList
<
UndisplayedNode
>
*
nsFrameManagerBase
:
:
UndisplayedMap
:
:
GetOrCreateListFor
(
nsIContent
*
aParent
)
{
aParent
=
GetApplicableParent
(
aParent
)
;
return
LookupOrAdd
(
aParent
)
;
}
UndisplayedNode
*
nsFrameManagerBase
:
:
UndisplayedMap
:
:
GetFirstNode
(
nsIContent
*
aParentContent
)
{
auto
*
list
=
GetListFor
(
aParentContent
)
;
return
list
?
list
-
>
getFirst
(
)
:
nullptr
;
}
void
nsFrameManagerBase
:
:
UndisplayedMap
:
:
AppendNodeFor
(
UndisplayedNode
*
aNode
nsIContent
*
aParentContent
)
{
LinkedList
<
UndisplayedNode
>
*
list
=
GetOrCreateListFor
(
aParentContent
)
;
#
ifdef
DEBUG
for
(
UndisplayedNode
*
node
=
list
-
>
getFirst
(
)
;
node
;
node
=
node
-
>
getNext
(
)
)
{
MOZ_ASSERT
(
node
-
>
mContent
!
=
aNode
-
>
mContent
"
Duplicated
content
in
undisplayed
list
!
"
)
;
}
#
endif
list
-
>
insertBack
(
aNode
)
;
}
void
nsFrameManagerBase
:
:
UndisplayedMap
:
:
AddNodeFor
(
nsIContent
*
aParentContent
nsIContent
*
aChild
nsStyleContext
*
aStyle
)
{
UndisplayedNode
*
node
=
new
UndisplayedNode
(
aChild
aStyle
)
;
AppendNodeFor
(
node
aParentContent
)
;
}
void
nsFrameManagerBase
:
:
UndisplayedMap
:
:
RemoveNodeFor
(
nsIContent
*
aParentContent
UndisplayedNode
*
aNode
)
{
#
ifdef
DEBUG
auto
list
=
GetListFor
(
aParentContent
)
;
MOZ_ASSERT
(
list
"
content
not
in
map
"
)
;
aNode
-
>
removeFrom
(
*
list
)
;
#
else
aNode
-
>
remove
(
)
;
#
endif
delete
aNode
;
}
nsAutoPtr
<
LinkedList
<
UndisplayedNode
>
>
nsFrameManagerBase
:
:
UndisplayedMap
:
:
UnlinkNodesFor
(
nsIContent
*
aParentContent
)
{
nsAutoPtr
<
LinkedList
<
UndisplayedNode
>
>
list
;
RemoveAndForget
(
GetApplicableParent
(
aParentContent
)
list
)
;
return
list
;
}
void
nsFrameManagerBase
:
:
UndisplayedMap
:
:
RemoveNodesFor
(
nsIContent
*
aParentContent
)
{
nsAutoPtr
<
LinkedList
<
UndisplayedNode
>
>
list
=
UnlinkNodesFor
(
aParentContent
)
;
if
(
list
)
{
while
(
auto
*
node
=
list
-
>
popFirst
(
)
)
{
delete
node
;
}
}
}
