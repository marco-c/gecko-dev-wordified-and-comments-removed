#
include
"
nsFrameManager
.
h
"
#
include
"
nscore
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
plhash
.
h
"
#
include
"
nsPlaceholderFrame
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsILayoutHistoryState
.
h
"
#
include
"
nsPresState
.
h
"
#
include
"
mozilla
/
ComputedStyle
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
UndisplayedNode
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsAbsoluteContainingBlock
.
h
"
#
include
"
ChildIterator
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
nsIStatefulFrame
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsWindowSizes
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
class
nsFrameManager
:
:
UndisplayedMap
:
private
nsClassHashtable
<
nsPtrHashKey
<
nsIContent
>
LinkedList
<
UndisplayedNode
>
>
{
typedef
nsClassHashtable
<
nsPtrHashKey
<
nsIContent
>
LinkedList
<
UndisplayedNode
>
>
base_type
;
public
:
UndisplayedMap
(
)
;
~
UndisplayedMap
(
)
;
UndisplayedNode
*
GetFirstNode
(
nsIContent
*
aParentContent
)
;
void
AddNodeFor
(
nsIContent
*
aParentContent
nsIContent
*
aChild
ComputedStyle
*
aStyle
)
;
void
RemoveNodeFor
(
nsIContent
*
aParentContent
UndisplayedNode
*
aNode
)
;
void
RemoveNodesFor
(
nsIContent
*
aParentContent
)
;
nsAutoPtr
<
LinkedList
<
UndisplayedNode
>
>
UnlinkNodesFor
(
nsIContent
*
aParentContent
)
;
void
Clear
(
)
;
static
nsIContent
*
GetApplicableParent
(
nsIContent
*
aParent
)
;
void
AddSizeOfIncludingThis
(
nsWindowSizes
&
aSizes
bool
aIsServo
)
const
;
protected
:
LinkedList
<
UndisplayedNode
>
*
GetListFor
(
nsIContent
*
aParentContent
)
;
LinkedList
<
UndisplayedNode
>
*
GetOrCreateListFor
(
nsIContent
*
aParentContent
)
;
void
AppendNodeFor
(
UndisplayedNode
*
aNode
nsIContent
*
aParentContent
)
;
}
;
nsFrameManager
:
:
~
nsFrameManager
(
)
{
NS_ASSERTION
(
!
mPresShell
"
nsFrameManager
:
:
Destroy
never
called
"
)
;
}
void
nsFrameManager
:
:
Destroy
(
)
{
NS_ASSERTION
(
mPresShell
"
Frame
manager
already
shut
down
.
"
)
;
mPresShell
-
>
SetIgnoreFrameDestruction
(
true
)
;
if
(
mRootFrame
)
{
mRootFrame
-
>
Destroy
(
)
;
mRootFrame
=
nullptr
;
}
delete
mDisplayNoneMap
;
mDisplayNoneMap
=
nullptr
;
delete
mDisplayContentsMap
;
mDisplayContentsMap
=
nullptr
;
mPresShell
=
nullptr
;
}
nsIContent
*
nsFrameManager
:
:
ParentForUndisplayedMap
(
const
nsIContent
*
aContent
)
{
MOZ_ASSERT
(
aContent
)
;
nsIContent
*
parent
=
aContent
-
>
GetParentElementCrossingShadowRoot
(
)
;
parent
=
UndisplayedMap
:
:
GetApplicableParent
(
parent
)
;
return
parent
;
}
ComputedStyle
*
nsFrameManager
:
:
GetComputedStyleInMap
(
UndisplayedMap
*
aMap
const
nsIContent
*
aContent
)
{
UndisplayedNode
*
node
=
GetUndisplayedNodeInMapFor
(
aMap
aContent
)
;
return
node
?
node
-
>
mStyle
.
get
(
)
:
nullptr
;
}
UndisplayedNode
*
nsFrameManager
:
:
GetUndisplayedNodeInMapFor
(
UndisplayedMap
*
aMap
const
nsIContent
*
aContent
)
{
if
(
!
aContent
)
{
return
nullptr
;
}
nsIContent
*
parent
=
ParentForUndisplayedMap
(
aContent
)
;
for
(
UndisplayedNode
*
node
=
aMap
-
>
GetFirstNode
(
parent
)
;
node
;
node
=
node
-
>
getNext
(
)
)
{
if
(
node
-
>
mContent
=
=
aContent
)
return
node
;
}
return
nullptr
;
}
UndisplayedNode
*
nsFrameManager
:
:
GetAllUndisplayedNodesInMapFor
(
UndisplayedMap
*
aMap
nsIContent
*
aParentContent
)
{
return
aMap
?
aMap
-
>
GetFirstNode
(
aParentContent
)
:
nullptr
;
}
UndisplayedNode
*
nsFrameManager
:
:
GetAllRegisteredDisplayNoneStylesIn
(
nsIContent
*
aParentContent
)
{
return
GetAllUndisplayedNodesInMapFor
(
mDisplayNoneMap
aParentContent
)
;
}
void
nsFrameManager
:
:
SetComputedStyleInMap
(
UndisplayedMap
*
aMap
nsIContent
*
aContent
ComputedStyle
*
aComputedStyle
)
{
MOZ_ASSERT
(
!
aComputedStyle
-
>
GetPseudo
(
)
"
Should
only
have
actual
elements
here
"
)
;
#
if
defined
(
DEBUG_UNDISPLAYED_MAP
)
|
|
defined
(
DEBUG_DISPLAY_BOX_CONTENTS_MAP
)
static
int
i
=
0
;
printf
(
"
SetComputedStyleInMap
(
%
d
)
:
p
=
%
p
\
n
"
i
+
+
(
void
*
)
aContent
)
;
#
endif
MOZ_ASSERT
(
!
GetComputedStyleInMap
(
aMap
aContent
)
"
Already
have
an
entry
for
aContent
"
)
;
nsIContent
*
parent
=
ParentForUndisplayedMap
(
aContent
)
;
MOZ_ASSERT
(
parent
|
|
!
aContent
-
>
GetParent
(
)
"
no
non
-
elements
"
)
;
#
ifdef
DEBUG
nsIPresShell
*
shell
=
aComputedStyle
-
>
PresContext
(
)
-
>
PresShell
(
)
;
NS_ASSERTION
(
parent
|
|
(
shell
&
&
shell
-
>
GetDocument
(
)
&
&
shell
-
>
GetDocument
(
)
-
>
GetRootElement
(
)
=
=
aContent
)
"
undisplayed
content
must
have
a
parent
unless
it
'
s
the
root
"
"
element
"
)
;
#
endif
if
(
parent
)
{
parent
-
>
SetMayHaveChildrenWithLayoutBoxesDisabled
(
)
;
}
aMap
-
>
AddNodeFor
(
parent
aContent
aComputedStyle
)
;
}
void
nsFrameManager
:
:
RegisterDisplayNoneStyleFor
(
nsIContent
*
aContent
ComputedStyle
*
aComputedStyle
)
{
if
(
!
mDisplayNoneMap
)
{
mDisplayNoneMap
=
new
UndisplayedMap
;
}
SetComputedStyleInMap
(
mDisplayNoneMap
aContent
aComputedStyle
)
;
}
void
nsFrameManager
:
:
ChangeComputedStyleInMap
(
UndisplayedMap
*
aMap
nsIContent
*
aContent
ComputedStyle
*
aComputedStyle
)
{
MOZ_ASSERT
(
aMap
"
expecting
a
map
"
)
;
#
if
defined
(
DEBUG_UNDISPLAYED_MAP
)
|
|
defined
(
DEBUG_DISPLAY_BOX_CONTENTS_MAP
)
static
int
i
=
0
;
printf
(
"
ChangeComputedStyleInMap
(
%
d
)
:
p
=
%
p
\
n
"
i
+
+
(
void
*
)
aContent
)
;
#
endif
nsIContent
*
parent
=
ParentForUndisplayedMap
(
aContent
)
;
MOZ_ASSERT
(
parent
|
|
!
aContent
-
>
GetParent
(
)
"
no
non
-
elements
"
)
;
for
(
UndisplayedNode
*
node
=
aMap
-
>
GetFirstNode
(
parent
)
;
node
;
node
=
node
-
>
getNext
(
)
)
{
if
(
node
-
>
mContent
=
=
aContent
)
{
node
-
>
mStyle
=
aComputedStyle
;
return
;
}
}
MOZ_CRASH
(
"
couldn
'
t
find
the
entry
to
change
"
)
;
}
void
nsFrameManager
:
:
UnregisterDisplayNoneStyleFor
(
nsIContent
*
aContent
nsIContent
*
aParentContent
)
{
#
ifdef
DEBUG_UNDISPLAYED_MAP
static
int
i
=
0
;
printf
(
"
ClearUndisplayedContent
(
%
d
)
:
content
=
%
p
parent
=
%
p
-
-
>
"
i
+
+
(
void
*
)
aContent
(
void
*
)
aParentContent
)
;
#
endif
if
(
!
mDisplayNoneMap
)
{
return
;
}
aParentContent
=
UndisplayedMap
:
:
GetApplicableParent
(
aParentContent
)
;
if
(
aParentContent
&
&
!
aParentContent
-
>
MayHaveChildrenWithLayoutBoxesDisabled
(
)
)
{
MOZ_ASSERT
(
!
mDisplayNoneMap
-
>
GetFirstNode
(
aParentContent
)
"
MayHaveChildrenWithLayoutBoxesDisabled
bit
out
of
sync
-
"
"
may
fail
to
remove
node
from
mDisplayNoneMap
"
)
;
return
;
}
UndisplayedNode
*
node
=
mDisplayNoneMap
-
>
GetFirstNode
(
aParentContent
)
;
const
bool
haveOneDisplayNoneChild
=
node
&
&
!
node
-
>
getNext
(
)
;
for
(
;
node
;
node
=
node
-
>
getNext
(
)
)
{
if
(
node
-
>
mContent
=
=
aContent
)
{
mDisplayNoneMap
-
>
RemoveNodeFor
(
aParentContent
node
)
;
#
ifdef
DEBUG_UNDISPLAYED_MAP
printf
(
"
REMOVED
!
\
n
"
)
;
#
endif
MOZ_ASSERT
(
!
GetDisplayNoneStyleFor
(
aContent
)
"
Found
more
undisplayed
content
data
after
removal
"
)
;
if
(
haveOneDisplayNoneChild
)
{
MOZ_ASSERT
(
!
mDisplayNoneMap
-
>
GetFirstNode
(
aParentContent
)
"
Bad
UnsetMayHaveChildrenWithLayoutBoxesDisabled
call
"
)
;
if
(
aParentContent
&
&
!
mDisplayContentsMap
)
{
aParentContent
-
>
UnsetMayHaveChildrenWithLayoutBoxesDisabled
(
)
;
}
}
return
;
}
}
#
ifdef
DEBUG_UNDISPLAYED_MAP
printf
(
"
not
found
.
\
n
"
)
;
#
endif
}
void
nsFrameManager
:
:
ClearAllMapsFor
(
nsIContent
*
aParentContent
)
{
#
if
defined
(
DEBUG_UNDISPLAYED_MAP
)
|
|
defined
(
DEBUG_DISPLAY_CONTENTS_MAP
)
static
int
i
=
0
;
printf
(
"
ClearAllMapsFor
(
%
d
)
:
parent
=
%
p
\
n
"
i
+
+
aParentContent
)
;
#
endif
if
(
!
aParentContent
|
|
aParentContent
-
>
MayHaveChildrenWithLayoutBoxesDisabled
(
)
)
{
if
(
mDisplayNoneMap
)
{
mDisplayNoneMap
-
>
RemoveNodesFor
(
aParentContent
)
;
}
if
(
mDisplayContentsMap
)
{
nsAutoPtr
<
LinkedList
<
UndisplayedNode
>
>
list
=
mDisplayContentsMap
-
>
UnlinkNodesFor
(
aParentContent
)
;
if
(
list
)
{
while
(
UndisplayedNode
*
node
=
list
-
>
popFirst
(
)
)
{
ClearAllMapsFor
(
node
-
>
mContent
)
;
delete
node
;
}
}
}
if
(
aParentContent
)
{
aParentContent
-
>
UnsetMayHaveChildrenWithLayoutBoxesDisabled
(
)
;
}
}
#
ifdef
DEBUG
else
{
if
(
mDisplayNoneMap
)
{
MOZ_ASSERT
(
!
mDisplayNoneMap
-
>
GetFirstNode
(
aParentContent
)
"
We
failed
to
remove
a
node
from
mDisplayNoneMap
"
)
;
}
if
(
mDisplayContentsMap
)
{
MOZ_ASSERT
(
!
mDisplayContentsMap
-
>
GetFirstNode
(
aParentContent
)
"
We
failed
to
remove
a
node
from
mDisplayContentsMap
"
)
;
}
}
#
endif
FlattenedChildIterator
iter
(
aParentContent
)
;
for
(
nsIContent
*
child
=
iter
.
GetNextChild
(
)
;
child
;
child
=
iter
.
GetNextChild
(
)
)
{
auto
parent
=
child
-
>
GetParent
(
)
;
if
(
parent
!
=
aParentContent
)
{
UnregisterDisplayNoneStyleFor
(
child
parent
)
;
UnregisterDisplayContentsStyleFor
(
child
parent
)
;
}
}
}
void
nsFrameManager
:
:
RegisterDisplayContentsStyleFor
(
nsIContent
*
aContent
ComputedStyle
*
aComputedStyle
)
{
if
(
!
mDisplayContentsMap
)
{
mDisplayContentsMap
=
new
UndisplayedMap
;
}
SetComputedStyleInMap
(
mDisplayContentsMap
aContent
aComputedStyle
)
;
}
UndisplayedNode
*
nsFrameManager
:
:
GetAllRegisteredDisplayContentsStylesIn
(
nsIContent
*
aParentContent
)
{
return
GetAllUndisplayedNodesInMapFor
(
mDisplayContentsMap
aParentContent
)
;
}
void
nsFrameManager
:
:
UnregisterDisplayContentsStyleFor
(
nsIContent
*
aContent
nsIContent
*
aParentContent
)
{
#
ifdef
DEBUG_DISPLAY_CONTENTS_MAP
static
int
i
=
0
;
printf
(
"
ClearDisplayContents
(
%
d
)
:
content
=
%
p
parent
=
%
p
-
-
>
"
i
+
+
(
void
*
)
aContent
(
void
*
)
aParentContent
)
;
#
endif
if
(
!
mDisplayContentsMap
)
{
return
;
}
aParentContent
=
UndisplayedMap
:
:
GetApplicableParent
(
aParentContent
)
;
if
(
aParentContent
&
&
!
aParentContent
-
>
MayHaveChildrenWithLayoutBoxesDisabled
(
)
)
{
MOZ_ASSERT
(
!
mDisplayContentsMap
-
>
GetFirstNode
(
aParentContent
)
"
MayHaveChildrenWithLayoutBoxesDisabled
bit
out
of
sync
-
"
"
may
fail
to
remove
node
from
mDisplayContentsMap
"
)
;
return
;
}
UndisplayedNode
*
node
=
mDisplayContentsMap
-
>
GetFirstNode
(
aParentContent
)
;
const
bool
haveOneDisplayContentsChild
=
node
&
&
!
node
-
>
getNext
(
)
;
for
(
;
node
;
node
=
node
-
>
getNext
(
)
)
{
if
(
node
-
>
mContent
=
=
aContent
)
{
mDisplayContentsMap
-
>
RemoveNodeFor
(
aParentContent
node
)
;
#
ifdef
DEBUG_DISPLAY_CONTENTS_MAP
printf
(
"
REMOVED
!
\
n
"
)
;
#
endif
MOZ_ASSERT
(
!
GetDisplayContentsStyleFor
(
aContent
)
"
Found
more
entries
for
aContent
after
removal
"
)
;
ClearAllMapsFor
(
aContent
)
;
if
(
haveOneDisplayContentsChild
)
{
MOZ_ASSERT
(
!
mDisplayContentsMap
-
>
GetFirstNode
(
aParentContent
)
"
Bad
UnsetMayHaveChildrenWithLayoutBoxesDisabled
call
"
)
;
if
(
aParentContent
&
&
!
mDisplayNoneMap
)
{
aParentContent
-
>
UnsetMayHaveChildrenWithLayoutBoxesDisabled
(
)
;
}
}
return
;
}
}
#
ifdef
DEBUG_DISPLAY_CONTENTS_MAP
printf
(
"
not
found
.
\
n
"
)
;
#
endif
}
void
nsFrameManager
:
:
AppendFrames
(
nsContainerFrame
*
aParentFrame
ChildListID
aListID
nsFrameList
&
aFrameList
)
{
if
(
aParentFrame
-
>
IsAbsoluteContainer
(
)
&
&
aListID
=
=
aParentFrame
-
>
GetAbsoluteListID
(
)
)
{
aParentFrame
-
>
GetAbsoluteContainingBlock
(
)
-
>
AppendFrames
(
aParentFrame
aListID
aFrameList
)
;
}
else
{
aParentFrame
-
>
AppendFrames
(
aListID
aFrameList
)
;
}
}
void
nsFrameManager
:
:
InsertFrames
(
nsContainerFrame
*
aParentFrame
ChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
aFrameList
)
{
NS_PRECONDITION
(
!
aPrevFrame
|
|
(
!
aPrevFrame
-
>
GetNextContinuation
(
)
|
|
(
(
(
aPrevFrame
-
>
GetNextContinuation
(
)
-
>
GetStateBits
(
)
&
NS_FRAME_IS_OVERFLOW_CONTAINER
)
)
&
&
!
(
aPrevFrame
-
>
GetStateBits
(
)
&
NS_FRAME_IS_OVERFLOW_CONTAINER
)
)
)
"
aPrevFrame
must
be
the
last
continuation
in
its
chain
!
"
)
;
if
(
aParentFrame
-
>
IsAbsoluteContainer
(
)
&
&
aListID
=
=
aParentFrame
-
>
GetAbsoluteListID
(
)
)
{
aParentFrame
-
>
GetAbsoluteContainingBlock
(
)
-
>
InsertFrames
(
aParentFrame
aListID
aPrevFrame
aFrameList
)
;
}
else
{
aParentFrame
-
>
InsertFrames
(
aListID
aPrevFrame
aFrameList
)
;
}
}
void
nsFrameManager
:
:
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
{
bool
wasDestroyingFrames
=
mIsDestroyingFrames
;
mIsDestroyingFrames
=
true
;
aOldFrame
-
>
InvalidateFrameForRemoval
(
)
;
NS_ASSERTION
(
!
aOldFrame
-
>
GetPrevContinuation
(
)
|
|
aOldFrame
-
>
IsTextFrame
(
)
"
Must
remove
first
continuation
.
"
)
;
NS_ASSERTION
(
!
(
aOldFrame
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
&
&
aOldFrame
-
>
GetPlaceholderFrame
(
)
)
"
Must
call
RemoveFrame
on
placeholder
for
out
-
of
-
flows
.
"
)
;
nsContainerFrame
*
parentFrame
=
aOldFrame
-
>
GetParent
(
)
;
if
(
parentFrame
-
>
IsAbsoluteContainer
(
)
&
&
aListID
=
=
parentFrame
-
>
GetAbsoluteListID
(
)
)
{
parentFrame
-
>
GetAbsoluteContainingBlock
(
)
-
>
RemoveFrame
(
parentFrame
aListID
aOldFrame
)
;
}
else
{
parentFrame
-
>
RemoveFrame
(
aListID
aOldFrame
)
;
}
mIsDestroyingFrames
=
wasDestroyingFrames
;
}
void
nsFrameManager
:
:
NotifyDestroyingFrame
(
nsIFrame
*
aFrame
)
{
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
content
&
&
content
-
>
GetPrimaryFrame
(
)
=
=
aFrame
)
{
ClearAllMapsFor
(
content
)
;
}
}
void
nsFrameManager
:
:
CaptureFrameStateFor
(
nsIFrame
*
aFrame
nsILayoutHistoryState
*
aState
)
{
if
(
!
aFrame
|
|
!
aState
)
{
NS_WARNING
(
"
null
frame
or
state
"
)
;
return
;
}
nsIStatefulFrame
*
statefulFrame
=
do_QueryFrame
(
aFrame
)
;
if
(
!
statefulFrame
)
{
return
;
}
nsAutoPtr
<
nsPresState
>
frameState
;
nsresult
rv
=
statefulFrame
-
>
SaveState
(
getter_Transfers
(
frameState
)
)
;
if
(
!
frameState
)
{
return
;
}
nsAutoCString
stateKey
;
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
nsIDocument
*
doc
=
content
?
content
-
>
GetUncomposedDoc
(
)
:
nullptr
;
rv
=
statefulFrame
-
>
GenerateStateKey
(
content
doc
stateKey
)
;
if
(
NS_FAILED
(
rv
)
|
|
stateKey
.
IsEmpty
(
)
)
{
return
;
}
aState
-
>
AddState
(
stateKey
frameState
.
forget
(
)
)
;
}
void
nsFrameManager
:
:
CaptureFrameState
(
nsIFrame
*
aFrame
nsILayoutHistoryState
*
aState
)
{
NS_PRECONDITION
(
nullptr
!
=
aFrame
&
&
nullptr
!
=
aState
"
null
parameters
passed
in
"
)
;
CaptureFrameStateFor
(
aFrame
aState
)
;
nsIFrame
:
:
ChildListIterator
lists
(
aFrame
)
;
for
(
;
!
lists
.
IsDone
(
)
;
lists
.
Next
(
)
)
{
nsFrameList
:
:
Enumerator
childFrames
(
lists
.
CurrentList
(
)
)
;
for
(
;
!
childFrames
.
AtEnd
(
)
;
childFrames
.
Next
(
)
)
{
nsIFrame
*
child
=
childFrames
.
get
(
)
;
if
(
child
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
{
continue
;
}
CaptureFrameState
(
nsPlaceholderFrame
:
:
GetRealFrameFor
(
child
)
aState
)
;
}
}
}
void
nsFrameManager
:
:
RestoreFrameStateFor
(
nsIFrame
*
aFrame
nsILayoutHistoryState
*
aState
)
{
if
(
!
aFrame
|
|
!
aState
)
{
NS_WARNING
(
"
null
frame
or
state
"
)
;
return
;
}
nsIStatefulFrame
*
statefulFrame
=
do_QueryFrame
(
aFrame
)
;
if
(
!
statefulFrame
)
{
return
;
}
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
!
content
)
{
return
;
}
nsAutoCString
stateKey
;
nsIDocument
*
doc
=
content
-
>
GetUncomposedDoc
(
)
;
nsresult
rv
=
statefulFrame
-
>
GenerateStateKey
(
content
doc
stateKey
)
;
if
(
NS_FAILED
(
rv
)
|
|
stateKey
.
IsEmpty
(
)
)
{
return
;
}
nsPresState
*
frameState
=
aState
-
>
GetState
(
stateKey
)
;
if
(
!
frameState
)
{
return
;
}
rv
=
statefulFrame
-
>
RestoreState
(
frameState
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
aState
-
>
RemoveState
(
stateKey
)
;
}
void
nsFrameManager
:
:
RestoreFrameState
(
nsIFrame
*
aFrame
nsILayoutHistoryState
*
aState
)
{
NS_PRECONDITION
(
nullptr
!
=
aFrame
&
&
nullptr
!
=
aState
"
null
parameters
passed
in
"
)
;
RestoreFrameStateFor
(
aFrame
aState
)
;
nsIFrame
:
:
ChildListIterator
lists
(
aFrame
)
;
for
(
;
!
lists
.
IsDone
(
)
;
lists
.
Next
(
)
)
{
nsFrameList
:
:
Enumerator
childFrames
(
lists
.
CurrentList
(
)
)
;
for
(
;
!
childFrames
.
AtEnd
(
)
;
childFrames
.
Next
(
)
)
{
RestoreFrameState
(
childFrames
.
get
(
)
aState
)
;
}
}
}
void
nsFrameManager
:
:
DestroyAnonymousContent
(
already_AddRefed
<
nsIContent
>
aContent
)
{
nsCOMPtr
<
nsIContent
>
content
=
aContent
;
if
(
content
)
{
ClearAllMapsFor
(
content
)
;
content
-
>
UnbindFromTree
(
)
;
}
}
void
nsFrameManager
:
:
AddSizeOfIncludingThis
(
nsWindowSizes
&
aSizes
)
const
{
bool
isServo
=
mPresShell
-
>
StyleSet
(
)
-
>
IsServo
(
)
;
aSizes
.
mLayoutPresShellSize
+
=
aSizes
.
mState
.
mMallocSizeOf
(
this
)
;
if
(
mDisplayNoneMap
)
{
mDisplayNoneMap
-
>
AddSizeOfIncludingThis
(
aSizes
isServo
)
;
}
if
(
mDisplayContentsMap
)
{
mDisplayContentsMap
-
>
AddSizeOfIncludingThis
(
aSizes
isServo
)
;
}
}
nsFrameManager
:
:
UndisplayedMap
:
:
UndisplayedMap
(
)
{
MOZ_COUNT_CTOR
(
nsFrameManager
:
:
UndisplayedMap
)
;
}
nsFrameManager
:
:
UndisplayedMap
:
:
~
UndisplayedMap
(
void
)
{
MOZ_COUNT_DTOR
(
nsFrameManager
:
:
UndisplayedMap
)
;
Clear
(
)
;
}
void
nsFrameManager
:
:
UndisplayedMap
:
:
Clear
(
)
{
for
(
auto
iter
=
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
auto
*
list
=
iter
.
UserData
(
)
;
while
(
auto
*
node
=
list
-
>
popFirst
(
)
)
{
delete
node
;
}
iter
.
Remove
(
)
;
}
}
nsIContent
*
nsFrameManager
:
:
UndisplayedMap
:
:
GetApplicableParent
(
nsIContent
*
aParent
)
{
if
(
aParent
&
&
aParent
-
>
IsActiveChildrenElement
(
)
)
{
return
aParent
-
>
GetParent
(
)
;
}
return
aParent
;
}
LinkedList
<
UndisplayedNode
>
*
nsFrameManager
:
:
UndisplayedMap
:
:
GetListFor
(
nsIContent
*
aParent
)
{
MOZ_ASSERT
(
aParent
=
=
GetApplicableParent
(
aParent
)
"
The
parent
that
we
use
as
the
hash
key
must
have
been
normalized
"
)
;
LinkedList
<
UndisplayedNode
>
*
list
;
if
(
Get
(
aParent
&
list
)
)
{
return
list
;
}
return
nullptr
;
}
LinkedList
<
UndisplayedNode
>
*
nsFrameManager
:
:
UndisplayedMap
:
:
GetOrCreateListFor
(
nsIContent
*
aParent
)
{
MOZ_ASSERT
(
aParent
=
=
GetApplicableParent
(
aParent
)
"
The
parent
that
we
use
as
the
hash
key
must
have
been
normalized
"
)
;
return
LookupOrAdd
(
aParent
)
;
}
UndisplayedNode
*
nsFrameManager
:
:
UndisplayedMap
:
:
GetFirstNode
(
nsIContent
*
aParentContent
)
{
auto
*
list
=
GetListFor
(
aParentContent
)
;
return
list
?
list
-
>
getFirst
(
)
:
nullptr
;
}
void
nsFrameManager
:
:
UndisplayedMap
:
:
AppendNodeFor
(
UndisplayedNode
*
aNode
nsIContent
*
aParentContent
)
{
LinkedList
<
UndisplayedNode
>
*
list
=
GetOrCreateListFor
(
aParentContent
)
;
#
ifdef
DEBUG
for
(
UndisplayedNode
*
node
=
list
-
>
getFirst
(
)
;
node
;
node
=
node
-
>
getNext
(
)
)
{
MOZ_ASSERT
(
node
-
>
mContent
!
=
aNode
-
>
mContent
"
Duplicated
content
in
undisplayed
list
!
"
)
;
}
#
endif
list
-
>
insertBack
(
aNode
)
;
}
void
nsFrameManager
:
:
UndisplayedMap
:
:
AddNodeFor
(
nsIContent
*
aParentContent
nsIContent
*
aChild
ComputedStyle
*
aStyle
)
{
UndisplayedNode
*
node
=
new
UndisplayedNode
(
aChild
aStyle
)
;
AppendNodeFor
(
node
aParentContent
)
;
}
void
nsFrameManager
:
:
UndisplayedMap
:
:
RemoveNodeFor
(
nsIContent
*
aParentContent
UndisplayedNode
*
aNode
)
{
#
ifdef
DEBUG
auto
list
=
GetListFor
(
aParentContent
)
;
MOZ_ASSERT
(
list
"
content
not
in
map
"
)
;
aNode
-
>
removeFrom
(
*
list
)
;
#
else
aNode
-
>
remove
(
)
;
#
endif
delete
aNode
;
}
nsAutoPtr
<
LinkedList
<
UndisplayedNode
>
>
nsFrameManager
:
:
UndisplayedMap
:
:
UnlinkNodesFor
(
nsIContent
*
aParentContent
)
{
nsAutoPtr
<
LinkedList
<
UndisplayedNode
>
>
list
;
Remove
(
GetApplicableParent
(
aParentContent
)
&
list
)
;
return
list
;
}
void
nsFrameManager
:
:
UndisplayedMap
:
:
RemoveNodesFor
(
nsIContent
*
aParentContent
)
{
nsAutoPtr
<
LinkedList
<
UndisplayedNode
>
>
list
=
UnlinkNodesFor
(
aParentContent
)
;
if
(
list
)
{
while
(
auto
*
node
=
list
-
>
popFirst
(
)
)
{
delete
node
;
}
}
}
void
nsFrameManager
:
:
UndisplayedMap
:
:
AddSizeOfIncludingThis
(
nsWindowSizes
&
aSizes
bool
aIsServo
)
const
{
MallocSizeOf
mallocSizeOf
=
aSizes
.
mState
.
mMallocSizeOf
;
aSizes
.
mLayoutPresShellSize
+
=
ShallowSizeOfIncludingThis
(
mallocSizeOf
)
;
nsWindowSizes
staleSizes
(
aSizes
.
mState
)
;
for
(
auto
iter
=
ConstIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
const
LinkedList
<
UndisplayedNode
>
*
list
=
iter
.
UserData
(
)
;
aSizes
.
mLayoutPresShellSize
+
=
list
-
>
sizeOfExcludingThis
(
mallocSizeOf
)
;
if
(
!
aIsServo
)
{
continue
;
}
for
(
const
UndisplayedNode
*
node
=
list
-
>
getFirst
(
)
;
node
;
node
=
node
-
>
getNext
(
)
)
{
ComputedStyle
*
computedStyle
=
node
-
>
mStyle
;
if
(
!
aSizes
.
mState
.
HaveSeenPtr
(
computedStyle
)
)
{
computedStyle
-
>
AddSizeOfIncludingThis
(
staleSizes
&
aSizes
.
mLayoutComputedValuesStale
)
;
}
}
}
aSizes
.
mLayoutComputedValuesStale
+
=
staleSizes
.
getTotalSize
(
)
;
}
