#
include
"
nsFrameManager
.
h
"
#
include
"
ChildIterator
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
mozilla
/
AbsoluteContainingBlock
.
h
"
#
include
"
mozilla
/
ComputedStyle
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
PresState
.
h
"
#
include
"
mozilla
/
ViewportFrame
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsILayoutHistoryState
.
h
"
#
include
"
nsIStatefulFrame
.
h
"
#
include
"
nsPlaceholderFrame
.
h
"
#
include
"
nsWindowSizes
.
h
"
#
include
"
nscore
.
h
"
#
include
"
plhash
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
nsFrameManager
:
:
~
nsFrameManager
(
)
{
NS_ASSERTION
(
!
mPresShell
"
nsFrameManager
:
:
Destroy
never
called
"
)
;
}
void
nsFrameManager
:
:
SetRootFrame
(
ViewportFrame
*
aRootFrame
)
{
MOZ_ASSERT
(
aRootFrame
"
The
root
frame
should
be
valid
!
"
)
;
MOZ_ASSERT
(
!
mRootFrame
"
We
should
set
a
root
frame
only
once
!
"
)
;
mRootFrame
=
aRootFrame
;
}
void
nsFrameManager
:
:
Destroy
(
)
{
NS_ASSERTION
(
mPresShell
"
Frame
manager
already
shut
down
.
"
)
;
mPresShell
-
>
SetIgnoreFrameDestruction
(
true
)
;
if
(
mRootFrame
)
{
FrameDestroyContext
context
(
mPresShell
)
;
mRootFrame
-
>
Destroy
(
context
)
;
mRootFrame
=
nullptr
;
}
mPresShell
=
nullptr
;
}
void
nsFrameManager
:
:
AppendFrames
(
nsContainerFrame
*
aParentFrame
FrameChildListID
aListID
nsFrameList
&
&
aFrameList
)
{
if
(
aParentFrame
-
>
IsAbsoluteContainer
(
)
&
&
aListID
=
=
aParentFrame
-
>
GetAbsoluteListID
(
)
)
{
aParentFrame
-
>
GetAbsoluteContainingBlock
(
)
-
>
AppendFrames
(
aParentFrame
aListID
std
:
:
move
(
aFrameList
)
)
;
}
else
{
aParentFrame
-
>
AppendFrames
(
aListID
std
:
:
move
(
aFrameList
)
)
;
}
}
void
nsFrameManager
:
:
InsertFrames
(
nsContainerFrame
*
aParentFrame
FrameChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
&
aFrameList
)
{
MOZ_ASSERT
(
!
aPrevFrame
|
|
(
!
aPrevFrame
-
>
GetNextContinuation
(
)
|
|
(
aPrevFrame
-
>
GetNextContinuation
(
)
-
>
HasAnyStateBits
(
NS_FRAME_IS_OVERFLOW_CONTAINER
)
&
&
!
aPrevFrame
-
>
HasAnyStateBits
(
NS_FRAME_IS_OVERFLOW_CONTAINER
)
)
)
"
aPrevFrame
must
be
the
last
continuation
in
its
chain
!
"
)
;
if
(
aParentFrame
-
>
IsAbsoluteContainer
(
)
&
&
aListID
=
=
aParentFrame
-
>
GetAbsoluteListID
(
)
)
{
aParentFrame
-
>
GetAbsoluteContainingBlock
(
)
-
>
InsertFrames
(
aParentFrame
aListID
aPrevFrame
std
:
:
move
(
aFrameList
)
)
;
}
else
{
aParentFrame
-
>
InsertFrames
(
aListID
aPrevFrame
nullptr
std
:
:
move
(
aFrameList
)
)
;
}
}
void
nsFrameManager
:
:
RemoveFrame
(
DestroyContext
&
aContext
FrameChildListID
aListID
nsIFrame
*
aOldFrame
)
{
aOldFrame
-
>
InvalidateFrameForRemoval
(
)
;
NS_ASSERTION
(
!
aOldFrame
-
>
GetPrevContinuation
(
)
|
|
aOldFrame
-
>
IsTextFrame
(
)
"
Must
remove
first
continuation
.
"
)
;
NS_ASSERTION
(
!
(
aOldFrame
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
&
&
aOldFrame
-
>
GetPlaceholderFrame
(
)
)
"
Must
call
RemoveFrame
on
placeholder
for
out
-
of
-
flows
.
"
)
;
nsContainerFrame
*
parentFrame
=
aOldFrame
-
>
GetParent
(
)
;
if
(
parentFrame
-
>
IsAbsoluteContainer
(
)
&
&
aListID
=
=
parentFrame
-
>
GetAbsoluteListID
(
)
)
{
parentFrame
-
>
GetAbsoluteContainingBlock
(
)
-
>
RemoveFrame
(
aContext
aListID
aOldFrame
)
;
}
else
{
parentFrame
-
>
RemoveFrame
(
aContext
aListID
aOldFrame
)
;
}
}
void
nsFrameManager
:
:
CaptureFrameStateFor
(
nsIFrame
*
aFrame
nsILayoutHistoryState
*
aState
)
{
if
(
!
aFrame
|
|
!
aState
)
{
NS_WARNING
(
"
null
frame
or
state
"
)
;
return
;
}
nsIStatefulFrame
*
statefulFrame
=
do_QueryFrame
(
aFrame
)
;
if
(
!
statefulFrame
)
{
return
;
}
UniquePtr
<
PresState
>
frameState
=
statefulFrame
-
>
SaveState
(
)
;
if
(
!
frameState
)
{
return
;
}
nsAutoCString
stateKey
;
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
Document
*
doc
=
content
?
content
-
>
GetUncomposedDoc
(
)
:
nullptr
;
statefulFrame
-
>
GenerateStateKey
(
content
doc
stateKey
)
;
if
(
stateKey
.
IsEmpty
(
)
)
{
return
;
}
aState
-
>
AddState
(
stateKey
std
:
:
move
(
frameState
)
)
;
}
void
nsFrameManager
:
:
CaptureFrameState
(
nsIFrame
*
aFrame
nsILayoutHistoryState
*
aState
)
{
MOZ_ASSERT
(
nullptr
!
=
aFrame
&
&
nullptr
!
=
aState
"
null
parameters
passed
in
"
)
;
CaptureFrameStateFor
(
aFrame
aState
)
;
for
(
const
auto
&
childList
:
aFrame
-
>
ChildLists
(
)
)
{
for
(
nsIFrame
*
child
:
childList
.
mList
)
{
if
(
child
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
)
{
continue
;
}
nsIFrame
*
realChild
=
nsPlaceholderFrame
:
:
GetRealFrameFor
(
child
)
;
if
(
MOZ_LIKELY
(
realChild
)
)
{
CaptureFrameState
(
realChild
aState
)
;
}
}
}
}
void
nsFrameManager
:
:
RestoreFrameStateFor
(
nsIFrame
*
aFrame
nsILayoutHistoryState
*
aState
)
{
if
(
!
aFrame
|
|
!
aState
)
{
NS_WARNING
(
"
null
frame
or
state
"
)
;
return
;
}
nsIStatefulFrame
*
statefulFrame
=
do_QueryFrame
(
aFrame
)
;
if
(
!
statefulFrame
)
{
return
;
}
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
!
content
)
{
return
;
}
nsAutoCString
stateKey
;
Document
*
doc
=
content
-
>
GetUncomposedDoc
(
)
;
statefulFrame
-
>
GenerateStateKey
(
content
doc
stateKey
)
;
if
(
stateKey
.
IsEmpty
(
)
)
{
return
;
}
PresState
*
frameState
=
aState
-
>
GetState
(
stateKey
)
;
if
(
!
frameState
)
{
return
;
}
nsresult
rv
=
statefulFrame
-
>
RestoreState
(
frameState
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
aState
-
>
RemoveState
(
stateKey
)
;
}
void
nsFrameManager
:
:
RestoreFrameState
(
nsIFrame
*
aFrame
nsILayoutHistoryState
*
aState
)
{
MOZ_ASSERT
(
nullptr
!
=
aFrame
&
&
nullptr
!
=
aState
"
null
parameters
passed
in
"
)
;
RestoreFrameStateFor
(
aFrame
aState
)
;
for
(
const
auto
&
childList
:
aFrame
-
>
ChildLists
(
)
)
{
for
(
nsIFrame
*
child
:
childList
.
mList
)
{
RestoreFrameState
(
child
aState
)
;
}
}
}
void
nsFrameManager
:
:
AddSizeOfIncludingThis
(
nsWindowSizes
&
aSizes
)
const
{
aSizes
.
mLayoutPresShellSize
+
=
aSizes
.
mState
.
mMallocSizeOf
(
this
)
;
}
