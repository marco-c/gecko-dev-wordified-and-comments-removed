#
include
"
nsBidi
.
h
"
nsresult
nsBidi
:
:
CountRuns
(
int32_t
*
aRunCount
)
{
UErrorCode
errorCode
=
U_ZERO_ERROR
;
*
aRunCount
=
ubidi_countRuns
(
mBiDi
&
errorCode
)
;
if
(
U_SUCCESS
(
errorCode
)
)
{
mLength
=
ubidi_getProcessedLength
(
mBiDi
)
;
mLevels
=
mLength
>
0
?
ubidi_getLevels
(
mBiDi
&
errorCode
)
:
nullptr
;
}
return
ICUUtils
:
:
UErrorToNsResult
(
errorCode
)
;
}
void
nsBidi
:
:
GetLogicalRun
(
int32_t
aLogicalStart
int32_t
*
aLogicalLimit
nsBidiLevel
*
aLevel
)
{
MOZ_ASSERT
(
mLevels
"
CountRuns
hasn
'
t
been
run
?
"
)
;
MOZ_RELEASE_ASSERT
(
aLogicalStart
<
mLength
"
Out
of
bound
"
)
;
MOZ_ASSERT
(
ubidi_getReorderingMode
(
mBiDi
)
!
=
UBIDI_REORDER_RUNS_ONLY
"
Don
'
t
support
UBIDI_REORDER_RUNS_ONLY
mode
"
)
;
nsBidiLevel
level
=
mLevels
[
aLogicalStart
]
;
int32_t
limit
;
for
(
limit
=
aLogicalStart
+
1
;
limit
<
mLength
;
limit
+
+
)
{
if
(
mLevels
[
limit
]
!
=
level
)
{
break
;
}
}
*
aLogicalLimit
=
limit
;
*
aLevel
=
level
;
}
