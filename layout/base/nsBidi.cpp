#
include
"
nsBidi
.
h
"
#
include
"
nsUnicodeProperties
.
h
"
#
include
"
nsCRTGlue
.
h
"
using
namespace
mozilla
:
:
unicode
;
#
undef
CS
#
undef
ES
enum
{
L
=
eCharType_LeftToRight
R
=
eCharType_RightToLeft
EN
=
eCharType_EuropeanNumber
ES
=
eCharType_EuropeanNumberSeparator
ET
=
eCharType_EuropeanNumberTerminator
AN
=
eCharType_ArabicNumber
CS
=
eCharType_CommonNumberSeparator
B
=
eCharType_BlockSeparator
S
=
eCharType_SegmentSeparator
WS
=
eCharType_WhiteSpaceNeutral
O_N
=
eCharType_OtherNeutral
LRE
=
eCharType_LeftToRightEmbedding
LRO
=
eCharType_LeftToRightOverride
AL
=
eCharType_RightToLeftArabic
RLE
=
eCharType_RightToLeftEmbedding
RLO
=
eCharType_RightToLeftOverride
PDF
=
eCharType_PopDirectionalFormat
NSM
=
eCharType_DirNonSpacingMark
BN
=
eCharType_BoundaryNeutral
LRI
=
eCharType_LeftToRightIsolate
RLI
=
eCharType_RightToLeftIsolate
FSI
=
eCharType_FirstStrongIsolate
PDI
=
eCharType_PopDirectionalIsolate
ENL
ENR
dirPropCount
}
;
#
define
IS_STRONG_TYPE
(
dirProp
)
(
(
dirProp
)
<
=
R
|
|
(
dirProp
)
=
=
AL
)
static
Flags
flagLR
[
2
]
=
{
DIRPROP_FLAG
(
L
)
DIRPROP_FLAG
(
R
)
}
;
static
Flags
flagE
[
2
]
=
{
DIRPROP_FLAG
(
LRE
)
DIRPROP_FLAG
(
RLE
)
}
;
static
Flags
flagO
[
2
]
=
{
DIRPROP_FLAG
(
LRO
)
DIRPROP_FLAG
(
RLO
)
}
;
#
define
DIRPROP_FLAG_LR
(
level
)
flagLR
[
(
level
)
&
1
]
#
define
DIRPROP_FLAG_E
(
level
)
flagE
[
(
level
)
&
1
]
#
define
DIRPROP_FLAG_O
(
level
)
flagO
[
(
level
)
&
1
]
#
define
NO_OVERRIDE
(
level
)
(
(
level
)
&
~
NSBIDI_LEVEL_OVERRIDE
)
static
inline
uint8_t
DirFromStrong
(
uint8_t
aDirProp
)
{
MOZ_ASSERT
(
IS_STRONG_TYPE
(
aDirProp
)
)
;
return
aDirProp
=
=
L
?
L
:
R
;
}
nsBidi
:
:
nsBidi
(
)
{
Init
(
)
;
}
nsBidi
:
:
~
nsBidi
(
)
{
Free
(
)
;
}
void
nsBidi
:
:
Init
(
)
{
mLength
=
0
;
mParaLevel
=
0
;
mFlags
=
0
;
mDirection
=
NSBIDI_LTR
;
mTrailingWSStart
=
0
;
mDirPropsSize
=
0
;
mLevelsSize
=
0
;
mRunsSize
=
0
;
mIsolatesSize
=
0
;
mRunCount
=
-
1
;
mIsolateCount
=
-
1
;
mDirProps
=
nullptr
;
mLevels
=
nullptr
;
mRuns
=
nullptr
;
mIsolates
=
nullptr
;
mDirPropsMemory
=
nullptr
;
mLevelsMemory
=
nullptr
;
mRunsMemory
=
nullptr
;
mIsolatesMemory
=
nullptr
;
}
bool
nsBidi
:
:
GetMemory
(
void
*
*
aMemory
size_t
*
aSize
size_t
aSizeNeeded
)
{
if
(
*
aMemory
=
=
nullptr
)
{
*
aMemory
=
malloc
(
aSizeNeeded
)
;
if
(
*
aMemory
!
=
nullptr
)
{
*
aSize
=
aSizeNeeded
;
return
true
;
}
else
{
*
aSize
=
0
;
return
false
;
}
}
else
{
if
(
aSizeNeeded
!
=
*
aSize
)
{
void
*
memory
=
realloc
(
*
aMemory
aSizeNeeded
)
;
if
(
memory
!
=
nullptr
)
{
*
aMemory
=
memory
;
*
aSize
=
aSizeNeeded
;
return
true
;
}
else
{
return
false
;
}
}
else
{
return
true
;
}
}
}
void
nsBidi
:
:
Free
(
)
{
free
(
mDirPropsMemory
)
;
mDirPropsMemory
=
nullptr
;
free
(
mLevelsMemory
)
;
mLevelsMemory
=
nullptr
;
free
(
mRunsMemory
)
;
mRunsMemory
=
nullptr
;
free
(
mIsolatesMemory
)
;
mIsolatesMemory
=
nullptr
;
}
nsresult
nsBidi
:
:
SetPara
(
const
char16_t
*
aText
int32_t
aLength
nsBidiLevel
aParaLevel
)
{
nsBidiDirection
direction
;
if
(
aText
=
=
nullptr
|
|
(
(
NSBIDI_MAX_EXPLICIT_LEVEL
<
aParaLevel
)
&
&
!
IS_DEFAULT_LEVEL
(
aParaLevel
)
)
|
|
aLength
<
-
1
)
{
return
NS_ERROR_INVALID_ARG
;
}
if
(
aLength
=
=
-
1
)
{
aLength
=
NS_strlen
(
aText
)
;
}
mLength
=
aLength
;
mParaLevel
=
aParaLevel
;
mDirection
=
aParaLevel
&
1
?
NSBIDI_RTL
:
NSBIDI_LTR
;
mTrailingWSStart
=
aLength
;
mDirProps
=
nullptr
;
mLevels
=
nullptr
;
mRuns
=
nullptr
;
if
(
aLength
=
=
0
)
{
if
(
IS_DEFAULT_LEVEL
(
aParaLevel
)
)
{
mParaLevel
&
=
1
;
}
mFlags
=
DIRPROP_FLAG_LR
(
aParaLevel
)
;
mRunCount
=
0
;
return
NS_OK
;
}
mRunCount
=
-
1
;
if
(
GETDIRPROPSMEMORY
(
aLength
)
)
{
mDirProps
=
mDirPropsMemory
;
GetDirProps
(
aText
)
;
}
else
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
GETLEVELSMEMORY
(
aLength
)
)
{
mLevels
=
mLevelsMemory
;
ResolveExplicitLevels
(
&
direction
aText
)
;
}
else
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
if
(
mIsolateCount
<
=
SIMPLE_ISOLATES_SIZE
)
{
mIsolates
=
mSimpleIsolates
;
}
else
{
if
(
mIsolateCount
*
sizeof
(
Isolate
)
<
=
mIsolatesSize
)
{
mIsolates
=
mIsolatesMemory
;
}
else
{
if
(
GETISOLATESMEMORY
(
mIsolateCount
)
)
{
mIsolates
=
mIsolatesMemory
;
}
else
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
}
}
mIsolateCount
=
-
1
;
mDirection
=
direction
;
switch
(
direction
)
{
case
NSBIDI_LTR
:
mParaLevel
=
(
mParaLevel
+
1
)
&
~
1
;
mTrailingWSStart
=
0
;
break
;
case
NSBIDI_RTL
:
mParaLevel
|
=
1
;
mTrailingWSStart
=
0
;
break
;
default
:
if
(
!
(
mFlags
&
DIRPROP_FLAG_MULTI_RUNS
)
)
{
ResolveImplicitLevels
(
0
aLength
GET_LR_FROM_LEVEL
(
mParaLevel
)
GET_LR_FROM_LEVEL
(
mParaLevel
)
)
;
}
else
{
nsBidiLevel
*
levels
=
mLevels
;
int32_t
start
limit
=
0
;
nsBidiLevel
level
nextLevel
;
DirProp
sor
eor
;
level
=
mParaLevel
;
nextLevel
=
levels
[
0
]
;
if
(
level
<
nextLevel
)
{
eor
=
GET_LR_FROM_LEVEL
(
nextLevel
)
;
}
else
{
eor
=
GET_LR_FROM_LEVEL
(
level
)
;
}
do
{
sor
=
eor
;
start
=
limit
;
level
=
nextLevel
;
while
(
+
+
limit
<
aLength
&
&
levels
[
limit
]
=
=
level
)
{
}
if
(
limit
<
aLength
)
{
nextLevel
=
levels
[
limit
]
;
}
else
{
nextLevel
=
mParaLevel
;
}
if
(
(
level
&
~
NSBIDI_LEVEL_OVERRIDE
)
<
(
nextLevel
&
~
NSBIDI_LEVEL_OVERRIDE
)
)
{
eor
=
GET_LR_FROM_LEVEL
(
nextLevel
)
;
}
else
{
eor
=
GET_LR_FROM_LEVEL
(
level
)
;
}
if
(
!
(
level
&
NSBIDI_LEVEL_OVERRIDE
)
)
{
ResolveImplicitLevels
(
start
limit
sor
eor
)
;
}
else
{
do
{
levels
[
start
+
+
]
&
=
~
NSBIDI_LEVEL_OVERRIDE
;
}
while
(
start
<
limit
)
;
}
}
while
(
limit
<
aLength
)
;
}
AdjustWSLevels
(
)
;
break
;
}
return
NS_OK
;
}
void
nsBidi
:
:
GetDirProps
(
const
char16_t
*
aText
)
{
DirProp
*
dirProps
=
mDirPropsMemory
;
int32_t
i
=
0
length
=
mLength
;
Flags
flags
=
0
;
char16_t
uchar
;
DirProp
dirProp
;
bool
isDefaultLevel
=
IS_DEFAULT_LEVEL
(
mParaLevel
)
;
enum
State
{
NOT_SEEKING_STRONG
SEEKING_STRONG_FOR_PARA
SEEKING_STRONG_FOR_FSI
LOOKING_FOR_PDI
}
;
State
state
;
int32_t
isolateStartStack
[
NSBIDI_MAX_EXPLICIT_LEVEL
+
1
]
;
State
previousStateStack
[
NSBIDI_MAX_EXPLICIT_LEVEL
+
1
]
;
int32_t
stackLast
=
-
1
;
if
(
isDefaultLevel
)
{
mParaLevel
&
=
1
;
state
=
SEEKING_STRONG_FOR_PARA
;
}
else
{
state
=
NOT_SEEKING_STRONG
;
}
for
(
;
i
<
length
;
)
{
uchar
=
aText
[
i
]
;
if
(
!
IS_FIRST_SURROGATE
(
uchar
)
|
|
i
+
1
=
=
length
|
|
!
IS_SECOND_SURROGATE
(
aText
[
i
+
1
]
)
)
{
flags
|
=
DIRPROP_FLAG
(
dirProps
[
i
]
=
dirProp
=
GetBidiCat
(
(
uint32_t
)
uchar
)
)
;
}
else
{
dirProps
[
i
+
+
]
=
BN
;
flags
|
=
DIRPROP_FLAG
(
dirProps
[
i
]
=
dirProp
=
GetBidiCat
(
GET_UTF_32
(
uchar
aText
[
i
]
)
)
)
|
DIRPROP_FLAG
(
BN
)
;
}
+
+
i
;
switch
(
dirProp
)
{
case
L
:
if
(
state
=
=
SEEKING_STRONG_FOR_PARA
)
{
mParaLevel
=
0
;
state
=
NOT_SEEKING_STRONG
;
}
else
if
(
state
=
=
SEEKING_STRONG_FOR_FSI
)
{
if
(
stackLast
<
=
NSBIDI_MAX_EXPLICIT_LEVEL
)
{
dirProps
[
isolateStartStack
[
stackLast
]
]
=
LRI
;
flags
|
=
DIRPROP_FLAG
(
LRI
)
;
}
state
=
LOOKING_FOR_PDI
;
}
break
;
case
R
:
case
AL
:
if
(
state
=
=
SEEKING_STRONG_FOR_PARA
)
{
mParaLevel
=
1
;
state
=
NOT_SEEKING_STRONG
;
}
else
if
(
state
=
=
SEEKING_STRONG_FOR_FSI
)
{
if
(
stackLast
<
=
NSBIDI_MAX_EXPLICIT_LEVEL
)
{
dirProps
[
isolateStartStack
[
stackLast
]
]
=
RLI
;
flags
|
=
DIRPROP_FLAG
(
RLI
)
;
}
state
=
LOOKING_FOR_PDI
;
}
break
;
case
FSI
:
case
LRI
:
case
RLI
:
stackLast
+
+
;
if
(
stackLast
<
=
NSBIDI_MAX_EXPLICIT_LEVEL
)
{
isolateStartStack
[
stackLast
]
=
i
-
1
;
previousStateStack
[
stackLast
]
=
state
;
}
if
(
dirProp
=
=
FSI
)
{
state
=
SEEKING_STRONG_FOR_FSI
;
}
else
{
state
=
LOOKING_FOR_PDI
;
}
break
;
case
PDI
:
if
(
state
=
=
SEEKING_STRONG_FOR_FSI
)
{
if
(
stackLast
<
=
NSBIDI_MAX_EXPLICIT_LEVEL
)
{
dirProps
[
isolateStartStack
[
stackLast
]
]
=
LRI
;
flags
|
=
DIRPROP_FLAG
(
LRI
)
;
}
}
if
(
stackLast
>
=
0
)
{
if
(
stackLast
<
=
NSBIDI_MAX_EXPLICIT_LEVEL
)
{
state
=
previousStateStack
[
stackLast
]
;
}
stackLast
-
-
;
}
break
;
case
B
:
NS_NOTREACHED
(
"
Unexpected
paragraph
separator
"
)
;
break
;
default
:
break
;
}
}
if
(
stackLast
>
NSBIDI_MAX_EXPLICIT_LEVEL
)
{
stackLast
=
NSBIDI_MAX_EXPLICIT_LEVEL
;
if
(
dirProps
[
previousStateStack
[
NSBIDI_MAX_EXPLICIT_LEVEL
]
]
!
=
FSI
)
{
state
=
LOOKING_FOR_PDI
;
}
}
while
(
stackLast
>
=
0
)
{
if
(
state
=
=
SEEKING_STRONG_FOR_FSI
)
{
dirProps
[
isolateStartStack
[
stackLast
]
]
=
LRI
;
flags
|
=
DIRPROP_FLAG
(
LRI
)
;
}
state
=
previousStateStack
[
stackLast
]
;
stackLast
-
-
;
}
flags
|
=
DIRPROP_FLAG_LR
(
mParaLevel
)
;
mFlags
=
flags
;
}
nsBidi
:
:
BracketData
:
:
BracketData
(
const
nsBidi
*
aBidi
)
{
mIsoRunLast
=
0
;
mIsoRuns
[
0
]
.
start
=
0
;
mIsoRuns
[
0
]
.
limit
=
0
;
mIsoRuns
[
0
]
.
level
=
aBidi
-
>
mParaLevel
;
mIsoRuns
[
0
]
.
lastStrong
=
mIsoRuns
[
0
]
.
lastBase
=
mIsoRuns
[
0
]
.
contextDir
=
GET_LR_FROM_LEVEL
(
aBidi
-
>
mParaLevel
)
;
mIsoRuns
[
0
]
.
contextPos
=
0
;
mOpenings
=
mSimpleOpenings
;
mOpeningsCount
=
SIMPLE_OPENINGS_COUNT
;
mOpeningsMemory
=
nullptr
;
}
nsBidi
:
:
BracketData
:
:
~
BracketData
(
)
{
free
(
mOpeningsMemory
)
;
}
void
nsBidi
:
:
BracketData
:
:
ProcessBoundary
(
int32_t
aLastDirControlCharPos
nsBidiLevel
aContextLevel
nsBidiLevel
aEmbeddingLevel
const
DirProp
*
aDirProps
)
{
IsoRun
&
lastIsoRun
=
mIsoRuns
[
mIsoRunLast
]
;
if
(
DIRPROP_FLAG
(
aDirProps
[
aLastDirControlCharPos
]
)
&
MASK_ISO
)
{
return
;
}
if
(
NO_OVERRIDE
(
aEmbeddingLevel
)
>
NO_OVERRIDE
(
aContextLevel
)
)
{
aContextLevel
=
aEmbeddingLevel
;
}
lastIsoRun
.
limit
=
lastIsoRun
.
start
;
lastIsoRun
.
level
=
aEmbeddingLevel
;
lastIsoRun
.
lastStrong
=
lastIsoRun
.
lastBase
=
lastIsoRun
.
contextDir
=
GET_LR_FROM_LEVEL
(
aContextLevel
)
;
lastIsoRun
.
contextPos
=
aLastDirControlCharPos
;
}
void
nsBidi
:
:
BracketData
:
:
ProcessLRI_RLI
(
nsBidiLevel
aLevel
)
{
MOZ_ASSERT
(
mIsoRunLast
<
=
NSBIDI_MAX_EXPLICIT_LEVEL
)
;
IsoRun
&
lastIsoRun
=
mIsoRuns
[
mIsoRunLast
]
;
lastIsoRun
.
lastBase
=
O_N
;
IsoRun
&
currIsoRun
=
mIsoRuns
[
+
+
mIsoRunLast
]
;
currIsoRun
.
start
=
currIsoRun
.
limit
=
lastIsoRun
.
limit
;
currIsoRun
.
level
=
aLevel
;
currIsoRun
.
lastStrong
=
currIsoRun
.
lastBase
=
currIsoRun
.
contextDir
=
GET_LR_FROM_LEVEL
(
aLevel
)
;
currIsoRun
.
contextPos
=
0
;
}
void
nsBidi
:
:
BracketData
:
:
ProcessPDI
(
)
{
mIsoRuns
[
mIsoRunLast
]
.
lastBase
=
O_N
;
}
bool
nsBidi
:
:
BracketData
:
:
AddOpening
(
char16_t
aMatch
int32_t
aPosition
)
{
IsoRun
&
lastIsoRun
=
mIsoRuns
[
mIsoRunLast
]
;
if
(
lastIsoRun
.
limit
>
=
mOpeningsCount
)
{
if
(
!
GETOPENINGSMEMORY
(
lastIsoRun
.
limit
*
2
)
)
{
return
false
;
}
if
(
mOpenings
=
=
mSimpleOpenings
)
{
memcpy
(
mOpeningsMemory
mSimpleOpenings
SIMPLE_OPENINGS_COUNT
*
sizeof
(
Opening
)
)
;
}
mOpenings
=
mOpeningsMemory
;
mOpeningsCount
=
mOpeningsSize
/
sizeof
(
Opening
)
;
}
Opening
&
o
=
mOpenings
[
lastIsoRun
.
limit
]
;
o
.
position
=
aPosition
;
o
.
match
=
aMatch
;
o
.
contextDir
=
lastIsoRun
.
contextDir
;
o
.
contextPos
=
lastIsoRun
.
contextPos
;
o
.
flags
=
0
;
lastIsoRun
.
limit
+
+
;
return
true
;
}
void
nsBidi
:
:
BracketData
:
:
FixN0c
(
int32_t
aOpeningIndex
int32_t
aNewPropPosition
DirProp
aNewProp
DirProp
*
aDirProps
)
{
IsoRun
&
lastIsoRun
=
mIsoRuns
[
mIsoRunLast
]
;
for
(
int32_t
k
=
aOpeningIndex
+
1
;
k
<
lastIsoRun
.
limit
;
k
+
+
)
{
Opening
&
o
=
mOpenings
[
k
]
;
if
(
o
.
match
>
=
0
)
{
continue
;
}
if
(
aNewPropPosition
<
o
.
contextPos
)
{
break
;
}
int32_t
openingPosition
=
o
.
position
;
if
(
aNewPropPosition
>
=
openingPosition
)
{
continue
;
}
if
(
aNewProp
=
=
o
.
contextDir
)
{
break
;
}
aDirProps
[
openingPosition
]
=
aNewProp
;
int32_t
closingPosition
=
-
(
o
.
match
)
;
aDirProps
[
closingPosition
]
=
aNewProp
;
o
.
match
=
0
;
FixN0c
(
k
openingPosition
aNewProp
aDirProps
)
;
FixN0c
(
k
closingPosition
aNewProp
aDirProps
)
;
}
}
DirProp
nsBidi
:
:
BracketData
:
:
ProcessClosing
(
int32_t
aOpenIdx
int32_t
aPosition
DirProp
*
aDirProps
)
{
IsoRun
&
lastIsoRun
=
mIsoRuns
[
mIsoRunLast
]
;
Opening
&
o
=
mOpenings
[
aOpenIdx
]
;
DirProp
newProp
;
DirProp
direction
=
GET_LR_FROM_LEVEL
(
lastIsoRun
.
level
)
;
bool
stable
=
true
;
if
(
(
direction
=
=
0
&
&
o
.
flags
&
FOUND_L
)
|
|
(
direction
=
=
1
&
&
o
.
flags
&
FOUND_R
)
)
{
newProp
=
direction
;
}
else
if
(
o
.
flags
&
(
FOUND_L
|
FOUND_R
)
)
{
stable
=
(
aOpenIdx
=
=
lastIsoRun
.
start
)
;
if
(
direction
!
=
o
.
contextDir
)
{
newProp
=
o
.
contextDir
;
}
else
{
newProp
=
direction
;
}
}
else
{
lastIsoRun
.
limit
=
aOpenIdx
;
return
O_N
;
}
aDirProps
[
o
.
position
]
=
newProp
;
aDirProps
[
aPosition
]
=
newProp
;
FixN0c
(
aOpenIdx
o
.
position
newProp
aDirProps
)
;
if
(
stable
)
{
lastIsoRun
.
limit
=
aOpenIdx
;
}
else
{
int32_t
k
;
o
.
match
=
-
aPosition
;
for
(
k
=
aOpenIdx
+
1
;
k
<
lastIsoRun
.
limit
;
k
+
+
)
{
Opening
&
oo
=
mOpenings
[
k
]
;
if
(
oo
.
position
>
aPosition
)
{
break
;
}
if
(
oo
.
match
>
0
)
{
oo
.
match
=
0
;
}
}
}
return
newProp
;
}
static
inline
bool
IsMatchingCloseBracket
(
char16_t
aCh1
char16_t
aCh2
)
{
return
(
aCh1
=
=
aCh2
)
|
|
(
aCh1
=
=
0x232A
&
&
aCh2
=
=
0x3009
)
|
|
(
aCh2
=
=
0x232A
&
&
aCh1
=
=
0x3009
)
;
}
bool
nsBidi
:
:
BracketData
:
:
ProcessChar
(
int32_t
aPosition
char16_t
aCh
DirProp
*
aDirProps
nsBidiLevel
*
aLevels
)
{
IsoRun
&
lastIsoRun
=
mIsoRuns
[
mIsoRunLast
]
;
DirProp
newProp
;
DirProp
dirProp
=
aDirProps
[
aPosition
]
;
nsBidiLevel
level
=
aLevels
[
aPosition
]
;
if
(
dirProp
=
=
O_N
)
{
for
(
int32_t
idx
=
lastIsoRun
.
limit
-
1
;
idx
>
=
lastIsoRun
.
start
;
idx
-
-
)
{
if
(
!
IsMatchingCloseBracket
(
aCh
mOpenings
[
idx
]
.
match
)
)
{
continue
;
}
newProp
=
ProcessClosing
(
idx
aPosition
aDirProps
)
;
if
(
newProp
=
=
O_N
)
{
aCh
=
0
;
break
;
}
lastIsoRun
.
lastBase
=
O_N
;
lastIsoRun
.
contextDir
=
newProp
;
lastIsoRun
.
contextPos
=
aPosition
;
if
(
level
&
NSBIDI_LEVEL_OVERRIDE
)
{
newProp
=
GET_LR_FROM_LEVEL
(
level
)
;
lastIsoRun
.
lastStrong
=
newProp
;
uint16_t
flag
=
DIRPROP_FLAG
(
newProp
)
;
for
(
int32_t
i
=
lastIsoRun
.
start
;
i
<
idx
;
i
+
+
)
{
mOpenings
[
i
]
.
flags
|
=
flag
;
}
aLevels
[
aPosition
]
&
=
~
NSBIDI_LEVEL_OVERRIDE
;
}
aLevels
[
mOpenings
[
idx
]
.
position
]
&
=
~
NSBIDI_LEVEL_OVERRIDE
;
return
true
;
}
char16_t
match
=
GetPairedBracket
(
aCh
)
;
if
(
match
!
=
aCh
&
&
GetPairedBracketType
(
aCh
)
=
=
PAIRED_BRACKET_TYPE_OPEN
)
{
if
(
!
AddOpening
(
match
aPosition
)
)
{
return
false
;
}
}
}
if
(
level
&
NSBIDI_LEVEL_OVERRIDE
)
{
newProp
=
GET_LR_FROM_LEVEL
(
level
)
;
if
(
dirProp
!
=
S
&
&
dirProp
!
=
WS
&
&
dirProp
!
=
O_N
)
{
aDirProps
[
aPosition
]
=
newProp
;
}
lastIsoRun
.
lastBase
=
newProp
;
lastIsoRun
.
lastStrong
=
newProp
;
lastIsoRun
.
contextDir
=
newProp
;
lastIsoRun
.
contextPos
=
aPosition
;
}
else
if
(
IS_STRONG_TYPE
(
dirProp
)
)
{
newProp
=
DirFromStrong
(
dirProp
)
;
lastIsoRun
.
lastBase
=
dirProp
;
lastIsoRun
.
lastStrong
=
dirProp
;
lastIsoRun
.
contextDir
=
newProp
;
lastIsoRun
.
contextPos
=
aPosition
;
}
else
if
(
dirProp
=
=
EN
)
{
lastIsoRun
.
lastBase
=
EN
;
if
(
lastIsoRun
.
lastStrong
=
=
L
)
{
newProp
=
L
;
aDirProps
[
aPosition
]
=
ENL
;
lastIsoRun
.
contextDir
=
L
;
lastIsoRun
.
contextPos
=
aPosition
;
}
else
{
newProp
=
R
;
if
(
lastIsoRun
.
lastStrong
=
=
AL
)
{
aDirProps
[
aPosition
]
=
AN
;
}
else
{
aDirProps
[
aPosition
]
=
ENR
;
}
lastIsoRun
.
contextDir
=
R
;
lastIsoRun
.
contextPos
=
aPosition
;
}
}
else
if
(
dirProp
=
=
AN
)
{
newProp
=
R
;
lastIsoRun
.
lastBase
=
AN
;
lastIsoRun
.
contextDir
=
R
;
lastIsoRun
.
contextPos
=
aPosition
;
}
else
if
(
dirProp
=
=
NSM
)
{
newProp
=
lastIsoRun
.
lastBase
;
if
(
newProp
=
=
O_N
)
{
aDirProps
[
aPosition
]
=
newProp
;
}
}
else
{
newProp
=
dirProp
;
lastIsoRun
.
lastBase
=
dirProp
;
}
if
(
IS_STRONG_TYPE
(
newProp
)
)
{
uint16_t
flag
=
DIRPROP_FLAG
(
DirFromStrong
(
newProp
)
)
;
for
(
int32_t
i
=
lastIsoRun
.
start
;
i
<
lastIsoRun
.
limit
;
i
+
+
)
{
if
(
aPosition
>
mOpenings
[
i
]
.
position
)
{
mOpenings
[
i
]
.
flags
|
=
flag
;
}
}
}
return
true
;
}
void
nsBidi
:
:
ResolveExplicitLevels
(
nsBidiDirection
*
aDirection
const
char16_t
*
aText
)
{
DirProp
*
dirProps
=
mDirProps
;
nsBidiLevel
*
levels
=
mLevels
;
int32_t
i
=
0
length
=
mLength
;
Flags
flags
=
mFlags
;
DirProp
dirProp
;
nsBidiLevel
level
=
mParaLevel
;
nsBidiDirection
direction
;
mIsolateCount
=
0
;
direction
=
DirectionFromFlags
(
flags
)
;
if
(
direction
!
=
NSBIDI_MIXED
)
{
}
else
if
(
!
(
flags
&
(
MASK_EXPLICIT
|
MASK_ISO
)
)
)
{
BracketData
bracketData
(
this
)
;
for
(
i
=
0
;
i
<
length
;
+
+
i
)
{
levels
[
i
]
=
level
;
if
(
dirProps
[
i
]
=
=
BN
)
{
continue
;
}
if
(
!
bracketData
.
ProcessChar
(
i
aText
[
i
]
mDirProps
mLevels
)
)
{
NS_WARNING
(
"
BracketData
:
:
ProcessChar
failed
out
of
memory
?
"
)
;
*
aDirection
=
NSBIDI_LTR
;
return
;
}
}
}
else
{
nsBidiLevel
embeddingLevel
=
level
newLevel
;
nsBidiLevel
previousLevel
=
level
;
int32_t
lastDirControlCharPos
=
0
;
uint16_t
stack
[
NSBIDI_MAX_EXPLICIT_LEVEL
+
2
]
;
int32_t
stackLast
=
0
;
int32_t
overflowIsolateCount
=
0
;
int32_t
overflowEmbeddingCount
=
0
;
int32_t
validIsolateCount
=
0
;
BracketData
bracketData
(
this
)
;
stack
[
0
]
=
level
;
flags
=
0
;
for
(
i
=
0
;
i
<
length
;
+
+
i
)
{
dirProp
=
dirProps
[
i
]
;
switch
(
dirProp
)
{
case
LRE
:
case
RLE
:
case
LRO
:
case
RLO
:
flags
|
=
DIRPROP_FLAG
(
BN
)
;
levels
[
i
]
=
previousLevel
;
if
(
dirProp
=
=
LRE
|
|
dirProp
=
=
LRO
)
{
newLevel
=
(
embeddingLevel
+
2
)
&
~
(
NSBIDI_LEVEL_OVERRIDE
|
1
)
;
}
else
{
newLevel
=
(
(
embeddingLevel
&
~
NSBIDI_LEVEL_OVERRIDE
)
+
1
)
|
1
;
}
if
(
newLevel
<
=
NSBIDI_MAX_EXPLICIT_LEVEL
&
&
overflowIsolateCount
=
=
0
&
&
overflowEmbeddingCount
=
=
0
)
{
lastDirControlCharPos
=
i
;
embeddingLevel
=
newLevel
;
if
(
dirProp
=
=
LRO
|
|
dirProp
=
=
RLO
)
{
embeddingLevel
|
=
NSBIDI_LEVEL_OVERRIDE
;
}
stackLast
+
+
;
stack
[
stackLast
]
=
embeddingLevel
;
}
else
{
if
(
overflowIsolateCount
=
=
0
)
{
overflowEmbeddingCount
+
+
;
}
}
break
;
case
PDF
:
flags
|
=
DIRPROP_FLAG
(
BN
)
;
levels
[
i
]
=
previousLevel
;
if
(
overflowIsolateCount
)
{
break
;
}
if
(
overflowEmbeddingCount
)
{
overflowEmbeddingCount
-
-
;
break
;
}
if
(
stackLast
>
0
&
&
stack
[
stackLast
]
<
ISOLATE
)
{
lastDirControlCharPos
=
i
;
stackLast
-
-
;
embeddingLevel
=
stack
[
stackLast
]
;
}
break
;
case
LRI
:
case
RLI
:
flags
|
=
DIRPROP_FLAG
(
O_N
)
|
DIRPROP_FLAG_LR
(
embeddingLevel
)
;
levels
[
i
]
=
NO_OVERRIDE
(
embeddingLevel
)
;
if
(
NO_OVERRIDE
(
embeddingLevel
)
!
=
NO_OVERRIDE
(
previousLevel
)
)
{
bracketData
.
ProcessBoundary
(
lastDirControlCharPos
previousLevel
embeddingLevel
mDirProps
)
;
flags
|
=
DIRPROP_FLAG_MULTI_RUNS
;
}
previousLevel
=
embeddingLevel
;
if
(
dirProp
=
=
LRI
)
{
newLevel
=
(
embeddingLevel
+
2
)
&
~
(
NSBIDI_LEVEL_OVERRIDE
|
1
)
;
}
else
{
newLevel
=
(
(
embeddingLevel
&
~
NSBIDI_LEVEL_OVERRIDE
)
+
1
)
|
1
;
}
if
(
newLevel
<
=
NSBIDI_MAX_EXPLICIT_LEVEL
&
&
overflowIsolateCount
=
=
0
&
&
overflowEmbeddingCount
=
=
0
)
{
flags
|
=
DIRPROP_FLAG
(
dirProp
)
;
lastDirControlCharPos
=
i
;
previousLevel
=
embeddingLevel
;
validIsolateCount
+
+
;
if
(
validIsolateCount
>
mIsolateCount
)
{
mIsolateCount
=
validIsolateCount
;
}
embeddingLevel
=
newLevel
;
stackLast
+
+
;
stack
[
stackLast
]
=
embeddingLevel
+
ISOLATE
;
bracketData
.
ProcessLRI_RLI
(
embeddingLevel
)
;
}
else
{
dirProps
[
i
]
=
WS
;
overflowIsolateCount
+
+
;
}
break
;
case
PDI
:
if
(
NO_OVERRIDE
(
embeddingLevel
)
!
=
NO_OVERRIDE
(
previousLevel
)
)
{
bracketData
.
ProcessBoundary
(
lastDirControlCharPos
previousLevel
embeddingLevel
mDirProps
)
;
flags
|
=
DIRPROP_FLAG_MULTI_RUNS
;
}
if
(
overflowIsolateCount
)
{
overflowIsolateCount
-
-
;
dirProps
[
i
]
=
WS
;
}
else
if
(
validIsolateCount
)
{
flags
|
=
DIRPROP_FLAG
(
PDI
)
;
lastDirControlCharPos
=
i
;
overflowEmbeddingCount
=
0
;
while
(
stack
[
stackLast
]
<
ISOLATE
)
{
stackLast
-
-
;
MOZ_ASSERT
(
stackLast
>
0
)
;
}
stackLast
-
-
;
MOZ_ASSERT
(
stackLast
>
=
0
)
;
validIsolateCount
-
-
;
bracketData
.
ProcessPDI
(
)
;
}
else
{
dirProps
[
i
]
=
WS
;
}
embeddingLevel
=
stack
[
stackLast
]
&
~
ISOLATE
;
flags
|
=
DIRPROP_FLAG
(
O_N
)
|
DIRPROP_FLAG_LR
(
embeddingLevel
)
;
previousLevel
=
embeddingLevel
;
levels
[
i
]
=
NO_OVERRIDE
(
embeddingLevel
)
;
break
;
case
B
:
NS_NOTREACHED
(
"
Unexpected
paragraph
separator
"
)
;
break
;
case
BN
:
levels
[
i
]
=
previousLevel
;
flags
|
=
DIRPROP_FLAG
(
BN
)
;
break
;
default
:
if
(
NO_OVERRIDE
(
embeddingLevel
)
!
=
NO_OVERRIDE
(
previousLevel
)
)
{
bracketData
.
ProcessBoundary
(
lastDirControlCharPos
previousLevel
embeddingLevel
mDirProps
)
;
flags
|
=
DIRPROP_FLAG_MULTI_RUNS
;
if
(
embeddingLevel
&
NSBIDI_LEVEL_OVERRIDE
)
{
flags
|
=
DIRPROP_FLAG_O
(
embeddingLevel
)
;
}
else
{
flags
|
=
DIRPROP_FLAG_E
(
embeddingLevel
)
;
}
}
previousLevel
=
embeddingLevel
;
levels
[
i
]
=
embeddingLevel
;
if
(
!
bracketData
.
ProcessChar
(
i
aText
[
i
]
mDirProps
mLevels
)
)
{
NS_WARNING
(
"
BracketData
:
:
ProcessChar
failed
out
of
memory
?
"
)
;
*
aDirection
=
NSBIDI_LTR
;
return
;
}
flags
|
=
DIRPROP_FLAG
(
dirProps
[
i
]
)
;
break
;
}
}
if
(
flags
&
MASK_EMBEDDING
)
{
flags
|
=
DIRPROP_FLAG_LR
(
mParaLevel
)
;
}
mFlags
=
flags
;
direction
=
DirectionFromFlags
(
flags
)
;
}
*
aDirection
=
direction
;
}
nsBidiDirection
nsBidi
:
:
DirectionFromFlags
(
Flags
aFlags
)
{
if
(
!
(
aFlags
&
MASK_RTL
|
|
(
aFlags
&
DIRPROP_FLAG
(
AN
)
&
&
aFlags
&
MASK_POSSIBLE_N
)
)
)
{
return
NSBIDI_LTR
;
}
else
if
(
!
(
aFlags
&
MASK_LTR
)
)
{
return
NSBIDI_RTL
;
}
else
{
return
NSBIDI_MIXED
;
}
}
#
define
IMPTABPROPS_COLUMNS
16
#
define
IMPTABPROPS_RES
(
IMPTABPROPS_COLUMNS
-
1
)
#
define
GET_STATEPROPS
(
cell
)
(
(
cell
)
&
0x1f
)
#
define
GET_ACTIONPROPS
(
cell
)
(
(
cell
)
>
>
5
)
#
undef
s
#
define
s
(
action
newState
)
(
(
uint8_t
)
(
newState
+
(
action
<
<
5
)
)
)
static
const
uint8_t
groupProp
[
]
=
{
0
1
2
7
8
3
9
6
5
4
4
10
10
12
10
10
10
11
10
4
4
4
4
13
14
}
;
static
const
uint8_t
impTabProps
[
]
[
IMPTABPROPS_COLUMNS
]
=
{
{
1
2
4
5
7
15
17
7
9
7
0
7
3
18
21
DirProp_ON
}
{
1
s
(
1
2
)
s
(
1
4
)
s
(
1
5
)
s
(
1
7
)
s
(
1
15
)
s
(
1
17
)
s
(
1
7
)
s
(
1
9
)
s
(
1
7
)
1
1
s
(
1
3
)
s
(
1
18
)
s
(
1
21
)
DirProp_L
}
{
s
(
1
1
)
2
s
(
1
4
)
s
(
1
5
)
s
(
1
7
)
s
(
1
15
)
s
(
1
17
)
s
(
1
7
)
s
(
1
9
)
s
(
1
7
)
2
2
s
(
1
3
)
s
(
1
18
)
s
(
1
21
)
DirProp_R
}
{
s
(
1
1
)
s
(
1
2
)
s
(
1
6
)
s
(
1
6
)
s
(
1
8
)
s
(
1
16
)
s
(
1
17
)
s
(
1
8
)
s
(
1
8
)
s
(
1
8
)
3
3
3
s
(
1
18
)
s
(
1
21
)
DirProp_R
}
{
s
(
1
1
)
s
(
1
2
)
4
s
(
1
5
)
s
(
1
7
)
s
(
1
15
)
s
(
1
17
)
s
(
2
10
)
11
s
(
2
10
)
4
4
s
(
1
3
)
18
21
DirProp_EN
}
{
s
(
1
1
)
s
(
1
2
)
s
(
1
4
)
5
s
(
1
7
)
s
(
1
15
)
s
(
1
17
)
s
(
1
7
)
s
(
1
9
)
s
(
2
12
)
5
5
s
(
1
3
)
s
(
1
18
)
s
(
1
21
)
DirProp_AN
}
{
s
(
1
1
)
s
(
1
2
)
6
6
s
(
1
8
)
s
(
1
16
)
s
(
1
17
)
s
(
1
8
)
s
(
1
8
)
s
(
2
13
)
6
6
s
(
1
3
)
18
21
DirProp_AN
}
{
s
(
1
1
)
s
(
1
2
)
s
(
1
4
)
s
(
1
5
)
7
s
(
1
15
)
s
(
1
17
)
7
s
(
2
14
)
7
7
7
s
(
1
3
)
s
(
1
18
)
s
(
1
21
)
DirProp_ON
}
{
s
(
1
1
)
s
(
1
2
)
s
(
1
6
)
s
(
1
6
)
8
s
(
1
16
)
s
(
1
17
)
8
8
8
8
8
s
(
1
3
)
s
(
1
18
)
s
(
1
21
)
DirProp_ON
}
{
s
(
1
1
)
s
(
1
2
)
4
s
(
1
5
)
7
s
(
1
15
)
s
(
1
17
)
7
9
7
9
9
s
(
1
3
)
18
21
DirProp_ON
}
{
s
(
3
1
)
s
(
3
2
)
4
s
(
3
5
)
s
(
4
7
)
s
(
3
15
)
s
(
3
17
)
s
(
4
7
)
s
(
4
14
)
s
(
4
7
)
10
s
(
4
7
)
s
(
3
3
)
18
21
DirProp_EN
}
{
s
(
1
1
)
s
(
1
2
)
4
s
(
1
5
)
s
(
1
7
)
s
(
1
15
)
s
(
1
17
)
s
(
1
7
)
11
s
(
1
7
)
11
11
s
(
1
3
)
18
21
DirProp_EN
}
{
s
(
3
1
)
s
(
3
2
)
s
(
3
4
)
5
s
(
4
7
)
s
(
3
15
)
s
(
3
17
)
s
(
4
7
)
s
(
4
14
)
s
(
4
7
)
12
s
(
4
7
)
s
(
3
3
)
s
(
3
18
)
s
(
3
21
)
DirProp_AN
}
{
s
(
3
1
)
s
(
3
2
)
6
6
s
(
4
8
)
s
(
3
16
)
s
(
3
17
)
s
(
4
8
)
s
(
4
8
)
s
(
4
8
)
13
s
(
4
8
)
s
(
3
3
)
18
21
DirProp_AN
}
{
s
(
1
1
)
s
(
1
2
)
s
(
4
4
)
s
(
1
5
)
7
s
(
1
15
)
s
(
1
17
)
7
14
7
14
14
s
(
1
3
)
s
(
4
18
)
s
(
4
21
)
DirProp_ON
}
{
s
(
1
1
)
s
(
1
2
)
s
(
1
4
)
s
(
1
5
)
s
(
1
7
)
15
s
(
1
17
)
s
(
1
7
)
s
(
1
9
)
s
(
1
7
)
15
s
(
1
7
)
s
(
1
3
)
s
(
1
18
)
s
(
1
21
)
DirProp_S
}
{
s
(
1
1
)
s
(
1
2
)
s
(
1
6
)
s
(
1
6
)
s
(
1
8
)
16
s
(
1
17
)
s
(
1
8
)
s
(
1
8
)
s
(
1
8
)
16
s
(
1
8
)
s
(
1
3
)
s
(
1
18
)
s
(
1
21
)
DirProp_S
}
{
s
(
1
1
)
s
(
1
2
)
s
(
1
4
)
s
(
1
5
)
s
(
1
7
)
s
(
1
15
)
17
s
(
1
7
)
s
(
1
9
)
s
(
1
7
)
17
s
(
1
7
)
s
(
1
3
)
s
(
1
18
)
s
(
1
21
)
DirProp_B
}
{
s
(
1
1
)
s
(
1
2
)
18
s
(
1
5
)
s
(
1
7
)
s
(
1
15
)
s
(
1
17
)
s
(
2
19
)
20
s
(
2
19
)
18
18
s
(
1
3
)
18
21
DirProp_L
}
{
s
(
3
1
)
s
(
3
2
)
18
s
(
3
5
)
s
(
4
7
)
s
(
3
15
)
s
(
3
17
)
s
(
4
7
)
s
(
4
14
)
s
(
4
7
)
19
s
(
4
7
)
s
(
3
3
)
18
21
DirProp_L
}
{
s
(
1
1
)
s
(
1
2
)
18
s
(
1
5
)
s
(
1
7
)
s
(
1
15
)
s
(
1
17
)
s
(
1
7
)
20
s
(
1
7
)
20
20
s
(
1
3
)
18
21
DirProp_L
}
{
s
(
1
1
)
s
(
1
2
)
21
s
(
1
5
)
s
(
1
7
)
s
(
1
15
)
s
(
1
17
)
s
(
2
22
)
23
s
(
2
22
)
21
21
s
(
1
3
)
18
21
DirProp_AN
}
{
s
(
3
1
)
s
(
3
2
)
21
s
(
3
5
)
s
(
4
7
)
s
(
3
15
)
s
(
3
17
)
s
(
4
7
)
s
(
4
14
)
s
(
4
7
)
22
s
(
4
7
)
s
(
3
3
)
18
21
DirProp_AN
}
{
s
(
1
1
)
s
(
1
2
)
21
s
(
1
5
)
s
(
1
7
)
s
(
1
15
)
s
(
1
17
)
s
(
1
7
)
23
s
(
1
7
)
23
23
s
(
1
3
)
18
21
DirProp_AN
}
}
;
#
undef
s
#
define
IMPTABLEVELS_RES
(
IMPTABLEVELS_COLUMNS
-
1
)
#
define
GET_STATE
(
cell
)
(
(
cell
)
&
0x0f
)
#
define
GET_ACTION
(
cell
)
(
(
cell
)
>
>
4
)
#
define
s
(
action
newState
)
(
(
uint8_t
)
(
newState
+
(
action
<
<
4
)
)
)
static
const
ImpTab
impTabL
=
{
{
0
1
0
2
0
0
0
0
}
{
0
1
3
3
s
(
1
4
)
s
(
1
4
)
0
1
}
{
0
1
0
2
s
(
1
5
)
s
(
1
5
)
0
2
}
{
0
1
3
3
s
(
1
4
)
s
(
1
4
)
0
2
}
{
s
(
2
0
)
1
3
3
4
4
s
(
2
0
)
1
}
{
s
(
2
0
)
1
s
(
2
0
)
2
5
5
s
(
2
0
)
1
}
}
;
static
const
ImpTab
impTabR
=
{
{
1
0
2
2
0
0
0
0
}
{
1
0
1
3
s
(
1
4
)
s
(
1
4
)
0
1
}
{
1
0
2
2
0
0
0
1
}
{
1
0
1
3
5
5
0
1
}
{
s
(
2
1
)
0
s
(
2
1
)
3
4
4
0
0
}
{
1
0
1
3
5
5
0
0
}
}
;
#
undef
s
static
ImpAct
impAct0
=
{
0
1
2
3
4
5
6
}
;
static
PImpTab
impTab
[
2
]
=
{
impTabL
impTabR
}
;
void
nsBidi
:
:
ProcessPropertySeq
(
LevState
*
pLevState
uint8_t
_prop
int32_t
start
int32_t
limit
)
{
uint8_t
cell
oldStateSeq
actionSeq
;
PImpTab
pImpTab
=
pLevState
-
>
pImpTab
;
PImpAct
pImpAct
=
pLevState
-
>
pImpAct
;
nsBidiLevel
*
levels
=
mLevels
;
nsBidiLevel
level
addLevel
;
int32_t
start0
k
;
start0
=
start
;
oldStateSeq
=
(
uint8_t
)
pLevState
-
>
state
;
cell
=
pImpTab
[
oldStateSeq
]
[
_prop
]
;
pLevState
-
>
state
=
GET_STATE
(
cell
)
;
actionSeq
=
pImpAct
[
GET_ACTION
(
cell
)
]
;
addLevel
=
pImpTab
[
pLevState
-
>
state
]
[
IMPTABLEVELS_RES
]
;
if
(
actionSeq
)
{
switch
(
actionSeq
)
{
case
1
:
pLevState
-
>
startON
=
start0
;
break
;
case
2
:
start
=
pLevState
-
>
startON
;
break
;
default
:
MOZ_ASSERT
(
false
)
;
break
;
}
}
if
(
addLevel
|
|
(
start
<
start0
)
)
{
level
=
pLevState
-
>
runLevel
+
addLevel
;
if
(
start
>
=
pLevState
-
>
runStart
)
{
for
(
k
=
start
;
k
<
limit
;
k
+
+
)
{
levels
[
k
]
=
level
;
}
}
else
{
DirProp
*
dirProps
=
mDirProps
dirProp
;
int32_t
isolateCount
=
0
;
for
(
k
=
start
;
k
<
limit
;
k
+
+
)
{
dirProp
=
dirProps
[
k
]
;
if
(
dirProp
=
=
PDI
)
{
isolateCount
-
-
;
}
if
(
isolateCount
=
=
0
)
{
levels
[
k
]
=
level
;
}
if
(
dirProp
=
=
LRI
|
|
dirProp
=
=
RLI
)
{
isolateCount
+
+
;
}
}
}
}
}
void
nsBidi
:
:
ResolveImplicitLevels
(
int32_t
aStart
int32_t
aLimit
DirProp
aSOR
DirProp
aEOR
)
{
const
DirProp
*
dirProps
=
mDirProps
;
DirProp
dirProp
;
LevState
levState
;
int32_t
i
start1
start2
;
uint16_t
oldStateImp
stateImp
actionImp
;
uint8_t
gprop
resProp
cell
;
levState
.
runStart
=
aStart
;
levState
.
runLevel
=
mLevels
[
aStart
]
;
levState
.
pImpTab
=
impTab
[
levState
.
runLevel
&
1
]
;
levState
.
pImpAct
=
impAct0
;
if
(
dirProps
[
aStart
]
=
=
PDI
&
&
mIsolateCount
>
=
0
)
{
start1
=
mIsolates
[
mIsolateCount
]
.
start1
;
stateImp
=
mIsolates
[
mIsolateCount
]
.
stateImp
;
levState
.
state
=
mIsolates
[
mIsolateCount
]
.
state
;
mIsolateCount
-
-
;
}
else
{
levState
.
startON
=
-
1
;
start1
=
aStart
;
if
(
dirProps
[
aStart
]
=
=
NSM
)
{
stateImp
=
1
+
aSOR
;
}
else
{
stateImp
=
0
;
}
levState
.
state
=
0
;
ProcessPropertySeq
(
&
levState
aSOR
aStart
aStart
)
;
}
start2
=
aStart
;
for
(
i
=
aStart
;
i
<
=
aLimit
;
i
+
+
)
{
if
(
i
>
=
aLimit
)
{
if
(
aLimit
>
aStart
)
{
dirProp
=
mDirProps
[
aLimit
-
1
]
;
if
(
dirProp
=
=
LRI
|
|
dirProp
=
=
RLI
)
{
break
;
}
}
gprop
=
aEOR
;
}
else
{
DirProp
prop
;
prop
=
dirProps
[
i
]
;
gprop
=
groupProp
[
prop
]
;
}
oldStateImp
=
stateImp
;
cell
=
impTabProps
[
oldStateImp
]
[
gprop
]
;
stateImp
=
GET_STATEPROPS
(
cell
)
;
actionImp
=
GET_ACTIONPROPS
(
cell
)
;
if
(
(
i
=
=
aLimit
)
&
&
(
actionImp
=
=
0
)
)
{
actionImp
=
1
;
}
if
(
actionImp
)
{
resProp
=
impTabProps
[
oldStateImp
]
[
IMPTABPROPS_RES
]
;
switch
(
actionImp
)
{
case
1
:
ProcessPropertySeq
(
&
levState
resProp
start1
i
)
;
start1
=
i
;
break
;
case
2
:
start2
=
i
;
break
;
case
3
:
ProcessPropertySeq
(
&
levState
resProp
start1
start2
)
;
ProcessPropertySeq
(
&
levState
DirProp_ON
start2
i
)
;
start1
=
i
;
break
;
case
4
:
ProcessPropertySeq
(
&
levState
resProp
start1
start2
)
;
start1
=
start2
;
start2
=
i
;
break
;
default
:
MOZ_ASSERT
(
false
)
;
break
;
}
}
}
dirProp
=
dirProps
[
aLimit
-
1
]
;
if
(
(
dirProp
=
=
LRI
|
|
dirProp
=
=
RLI
)
&
&
aLimit
<
mLength
)
{
mIsolateCount
+
+
;
mIsolates
[
mIsolateCount
]
.
stateImp
=
stateImp
;
mIsolates
[
mIsolateCount
]
.
state
=
levState
.
state
;
mIsolates
[
mIsolateCount
]
.
start1
=
start1
;
}
else
{
ProcessPropertySeq
(
&
levState
aEOR
aLimit
aLimit
)
;
}
}
void
nsBidi
:
:
AdjustWSLevels
(
)
{
const
DirProp
*
dirProps
=
mDirProps
;
nsBidiLevel
*
levels
=
mLevels
;
int32_t
i
;
if
(
mFlags
&
MASK_WS
)
{
nsBidiLevel
paraLevel
=
mParaLevel
;
Flags
flag
;
i
=
mTrailingWSStart
;
while
(
i
>
0
)
{
while
(
i
>
0
&
&
DIRPROP_FLAG
(
dirProps
[
-
-
i
]
)
&
MASK_WS
)
{
levels
[
i
]
=
paraLevel
;
}
while
(
i
>
0
)
{
flag
=
DIRPROP_FLAG
(
dirProps
[
-
-
i
]
)
;
if
(
flag
&
MASK_BN_EXPLICIT
)
{
levels
[
i
]
=
levels
[
i
+
1
]
;
}
else
if
(
flag
&
MASK_B_S
)
{
levels
[
i
]
=
paraLevel
;
break
;
}
}
}
}
}
nsresult
nsBidi
:
:
GetDirection
(
nsBidiDirection
*
aDirection
)
{
*
aDirection
=
mDirection
;
return
NS_OK
;
}
nsresult
nsBidi
:
:
GetParaLevel
(
nsBidiLevel
*
aParaLevel
)
{
*
aParaLevel
=
mParaLevel
;
return
NS_OK
;
}
nsresult
nsBidi
:
:
GetCharTypeAt
(
int32_t
aCharIndex
nsCharType
*
pType
)
{
if
(
aCharIndex
<
0
|
|
mLength
<
=
aCharIndex
)
{
return
NS_ERROR_INVALID_ARG
;
}
*
pType
=
(
nsCharType
)
mDirProps
[
aCharIndex
]
;
return
NS_OK
;
}
nsresult
nsBidi
:
:
GetLogicalRun
(
int32_t
aLogicalStart
int32_t
*
aLogicalLimit
nsBidiLevel
*
aLevel
)
{
int32_t
length
=
mLength
;
if
(
aLogicalStart
<
0
|
|
length
<
=
aLogicalStart
)
{
return
NS_ERROR_INVALID_ARG
;
}
int32_t
runCount
visualStart
logicalLimit
logicalFirst
i
;
Run
iRun
;
nsresult
rv
=
CountRuns
(
&
runCount
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
visualStart
=
logicalLimit
=
0
;
iRun
=
mRuns
[
0
]
;
for
(
i
=
0
;
i
<
runCount
;
i
+
+
)
{
iRun
=
mRuns
[
i
]
;
logicalFirst
=
GET_INDEX
(
iRun
.
logicalStart
)
;
logicalLimit
=
logicalFirst
+
iRun
.
visualLimit
-
visualStart
;
if
(
(
aLogicalStart
>
=
logicalFirst
)
&
&
(
aLogicalStart
<
logicalLimit
)
)
{
break
;
}
visualStart
=
iRun
.
visualLimit
;
}
if
(
aLogicalLimit
)
{
*
aLogicalLimit
=
logicalLimit
;
}
if
(
aLevel
)
{
if
(
mDirection
!
=
NSBIDI_MIXED
|
|
aLogicalStart
>
=
mTrailingWSStart
)
{
*
aLevel
=
mParaLevel
;
}
else
{
*
aLevel
=
mLevels
[
aLogicalStart
]
;
}
}
return
NS_OK
;
}
nsresult
nsBidi
:
:
CountRuns
(
int32_t
*
aRunCount
)
{
if
(
mRunCount
<
0
&
&
!
GetRuns
(
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
else
{
if
(
aRunCount
)
*
aRunCount
=
mRunCount
;
return
NS_OK
;
}
}
nsresult
nsBidi
:
:
GetVisualRun
(
int32_t
aRunIndex
int32_t
*
aLogicalStart
int32_t
*
aLength
nsBidiDirection
*
aDirection
)
{
if
(
aRunIndex
<
0
|
|
(
mRunCount
=
=
-
1
&
&
!
GetRuns
(
)
)
|
|
aRunIndex
>
=
mRunCount
)
{
*
aDirection
=
NSBIDI_LTR
;
return
NS_OK
;
}
else
{
int32_t
start
=
mRuns
[
aRunIndex
]
.
logicalStart
;
if
(
aLogicalStart
!
=
nullptr
)
{
*
aLogicalStart
=
GET_INDEX
(
start
)
;
}
if
(
aLength
!
=
nullptr
)
{
if
(
aRunIndex
>
0
)
{
*
aLength
=
mRuns
[
aRunIndex
]
.
visualLimit
-
mRuns
[
aRunIndex
-
1
]
.
visualLimit
;
}
else
{
*
aLength
=
mRuns
[
0
]
.
visualLimit
;
}
}
*
aDirection
=
(
nsBidiDirection
)
GET_ODD_BIT
(
start
)
;
return
NS_OK
;
}
}
bool
nsBidi
:
:
GetRuns
(
)
{
if
(
mRunCount
>
=
0
)
{
return
true
;
}
if
(
mDirection
!
=
NSBIDI_MIXED
)
{
GetSingleRun
(
mParaLevel
)
;
}
else
{
int32_t
length
=
mLength
limit
=
mTrailingWSStart
;
nsBidiLevel
*
levels
=
mLevels
;
int32_t
i
runCount
;
nsBidiLevel
level
=
NSBIDI_DEFAULT_LTR
;
runCount
=
0
;
for
(
i
=
0
;
i
<
limit
;
+
+
i
)
{
if
(
levels
[
i
]
!
=
level
)
{
+
+
runCount
;
level
=
levels
[
i
]
;
}
}
if
(
runCount
=
=
1
&
&
limit
=
=
length
)
{
GetSingleRun
(
levels
[
0
]
)
;
}
else
{
Run
*
runs
;
int32_t
runIndex
start
;
nsBidiLevel
minLevel
=
NSBIDI_MAX_EXPLICIT_LEVEL
+
1
maxLevel
=
0
;
if
(
limit
<
length
)
{
+
+
runCount
;
}
if
(
GETRUNSMEMORY
(
runCount
)
)
{
runs
=
mRunsMemory
;
}
else
{
return
false
;
}
runIndex
=
0
;
i
=
0
;
do
{
start
=
i
;
level
=
levels
[
i
]
;
if
(
level
<
minLevel
)
{
minLevel
=
level
;
}
if
(
level
>
maxLevel
)
{
maxLevel
=
level
;
}
while
(
+
+
i
<
limit
&
&
levels
[
i
]
=
=
level
)
{
}
runs
[
runIndex
]
.
logicalStart
=
start
;
runs
[
runIndex
]
.
visualLimit
=
i
-
start
;
+
+
runIndex
;
}
while
(
i
<
limit
)
;
if
(
limit
<
length
)
{
runs
[
runIndex
]
.
logicalStart
=
limit
;
runs
[
runIndex
]
.
visualLimit
=
length
-
limit
;
if
(
mParaLevel
<
minLevel
)
{
minLevel
=
mParaLevel
;
}
}
mRuns
=
runs
;
mRunCount
=
runCount
;
ReorderLine
(
minLevel
maxLevel
)
;
limit
=
0
;
for
(
i
=
0
;
i
<
runCount
;
+
+
i
)
{
ADD_ODD_BIT_FROM_LEVEL
(
runs
[
i
]
.
logicalStart
levels
[
runs
[
i
]
.
logicalStart
]
)
;
limit
+
=
runs
[
i
]
.
visualLimit
;
runs
[
i
]
.
visualLimit
=
limit
;
}
if
(
runIndex
<
runCount
)
{
int32_t
trailingRun
=
(
mParaLevel
&
1
)
?
0
:
runIndex
;
ADD_ODD_BIT_FROM_LEVEL
(
runs
[
trailingRun
]
.
logicalStart
mParaLevel
)
;
}
}
}
return
true
;
}
void
nsBidi
:
:
GetSingleRun
(
nsBidiLevel
aLevel
)
{
mRuns
=
mSimpleRuns
;
mRunCount
=
1
;
mRuns
[
0
]
.
logicalStart
=
MAKE_INDEX_ODD_PAIR
(
0
aLevel
)
;
mRuns
[
0
]
.
visualLimit
=
mLength
;
}
void
nsBidi
:
:
ReorderLine
(
nsBidiLevel
aMinLevel
nsBidiLevel
aMaxLevel
)
{
Run
*
runs
tempRun
;
nsBidiLevel
*
levels
;
int32_t
firstRun
endRun
limitRun
runCount
;
if
(
aMaxLevel
<
=
(
aMinLevel
|
1
)
)
{
return
;
}
+
+
aMinLevel
;
runs
=
mRuns
;
levels
=
mLevels
;
runCount
=
mRunCount
;
if
(
mTrailingWSStart
<
mLength
)
{
-
-
runCount
;
}
while
(
-
-
aMaxLevel
>
=
aMinLevel
)
{
firstRun
=
0
;
for
(
;
;
)
{
while
(
firstRun
<
runCount
&
&
levels
[
runs
[
firstRun
]
.
logicalStart
]
<
aMaxLevel
)
{
+
+
firstRun
;
}
if
(
firstRun
>
=
runCount
)
{
break
;
}
for
(
limitRun
=
firstRun
;
+
+
limitRun
<
runCount
&
&
levels
[
runs
[
limitRun
]
.
logicalStart
]
>
=
aMaxLevel
;
)
{
}
endRun
=
limitRun
-
1
;
while
(
firstRun
<
endRun
)
{
tempRun
=
runs
[
firstRun
]
;
runs
[
firstRun
]
=
runs
[
endRun
]
;
runs
[
endRun
]
=
tempRun
;
+
+
firstRun
;
-
-
endRun
;
}
if
(
limitRun
=
=
runCount
)
{
break
;
}
else
{
firstRun
=
limitRun
+
1
;
}
}
}
if
(
!
(
aMinLevel
&
1
)
)
{
firstRun
=
0
;
if
(
mTrailingWSStart
=
=
mLength
)
{
-
-
runCount
;
}
while
(
firstRun
<
runCount
)
{
tempRun
=
runs
[
firstRun
]
;
runs
[
firstRun
]
=
runs
[
runCount
]
;
runs
[
runCount
]
=
tempRun
;
+
+
firstRun
;
-
-
runCount
;
}
}
}
nsresult
nsBidi
:
:
ReorderVisual
(
const
nsBidiLevel
*
aLevels
int32_t
aLength
int32_t
*
aIndexMap
)
{
int32_t
start
end
limit
temp
;
nsBidiLevel
minLevel
maxLevel
;
if
(
aIndexMap
=
=
nullptr
|
|
!
PrepareReorder
(
aLevels
aLength
aIndexMap
&
minLevel
&
maxLevel
)
)
{
return
NS_OK
;
}
if
(
minLevel
=
=
maxLevel
&
&
(
minLevel
&
1
)
=
=
0
)
{
return
NS_OK
;
}
minLevel
|
=
1
;
do
{
start
=
0
;
for
(
;
;
)
{
while
(
start
<
aLength
&
&
aLevels
[
start
]
<
maxLevel
)
{
+
+
start
;
}
if
(
start
>
=
aLength
)
{
break
;
}
for
(
limit
=
start
;
+
+
limit
<
aLength
&
&
aLevels
[
limit
]
>
=
maxLevel
;
)
{
}
end
=
limit
-
1
;
while
(
start
<
end
)
{
temp
=
aIndexMap
[
start
]
;
aIndexMap
[
start
]
=
aIndexMap
[
end
]
;
aIndexMap
[
end
]
=
temp
;
+
+
start
;
-
-
end
;
}
if
(
limit
=
=
aLength
)
{
break
;
}
else
{
start
=
limit
+
1
;
}
}
}
while
(
-
-
maxLevel
>
=
minLevel
)
;
return
NS_OK
;
}
bool
nsBidi
:
:
PrepareReorder
(
const
nsBidiLevel
*
aLevels
int32_t
aLength
int32_t
*
aIndexMap
nsBidiLevel
*
aMinLevel
nsBidiLevel
*
aMaxLevel
)
{
int32_t
start
;
nsBidiLevel
level
minLevel
maxLevel
;
if
(
aLevels
=
=
nullptr
|
|
aLength
<
=
0
)
{
return
false
;
}
minLevel
=
NSBIDI_MAX_EXPLICIT_LEVEL
+
1
;
maxLevel
=
0
;
for
(
start
=
aLength
;
start
>
0
;
)
{
level
=
aLevels
[
-
-
start
]
;
if
(
level
>
NSBIDI_MAX_EXPLICIT_LEVEL
+
1
)
{
return
false
;
}
if
(
level
<
minLevel
)
{
minLevel
=
level
;
}
if
(
level
>
maxLevel
)
{
maxLevel
=
level
;
}
}
*
aMinLevel
=
minLevel
;
*
aMaxLevel
=
maxLevel
;
for
(
start
=
aLength
;
start
>
0
;
)
{
-
-
start
;
aIndexMap
[
start
]
=
start
;
}
return
true
;
}
