#
include
"
mozilla
/
MotionPathUtils
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
mozilla
/
dom
/
SVGPathData
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
Matrix
.
h
"
#
include
"
mozilla
/
layers
/
LayersMessages
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsStyleTransformMatrix
.
h
"
#
include
<
math
.
h
>
namespace
mozilla
{
using
nsStyleTransformMatrix
:
:
TransformReferenceBox
;
RayReferenceData
:
:
RayReferenceData
(
const
nsIFrame
*
aFrame
)
{
const
nsIFrame
*
container
=
aFrame
-
>
GetContainingBlock
(
)
;
if
(
!
container
)
{
return
;
}
mInitialPosition
=
CSSPoint
:
:
FromAppUnits
(
aFrame
-
>
GetOffsetTo
(
container
)
)
;
mContainingBlockRect
=
CSSRect
:
:
FromAppUnits
(
container
-
>
GetRectRelativeToSelf
(
)
)
;
}
static
CSSCoord
ComputeSides
(
const
CSSPoint
&
aInitialPosition
const
CSSSize
&
aContainerSize
const
StyleAngle
&
aAngle
)
{
double
theta
=
aAngle
.
ToRadians
(
)
;
double
sint
=
std
:
:
sin
(
theta
)
;
double
cost
=
std
:
:
cos
(
theta
)
;
double
b
=
cost
>
=
0
?
aInitialPosition
.
y
:
aContainerSize
.
height
-
aInitialPosition
.
y
;
double
bPrime
=
sint
>
=
0
?
aContainerSize
.
width
-
aInitialPosition
.
x
:
aInitialPosition
.
x
;
sint
=
std
:
:
fabs
(
sint
)
;
cost
=
std
:
:
fabs
(
cost
)
;
if
(
b
*
sint
>
bPrime
*
cost
)
{
return
bPrime
/
sint
;
}
return
b
/
cost
;
}
static
CSSCoord
ComputeRayPathLength
(
const
StyleRaySize
aRaySizeType
const
StyleAngle
&
aAngle
const
RayReferenceData
&
aRayData
)
{
if
(
aRaySizeType
=
=
StyleRaySize
:
:
Sides
)
{
if
(
!
aRayData
.
mContainingBlockRect
.
Contains
(
aRayData
.
mInitialPosition
)
)
{
return
0
.
0
;
}
return
ComputeSides
(
aRayData
.
mInitialPosition
aRayData
.
mContainingBlockRect
.
Size
(
)
aAngle
)
;
}
CSSCoord
left
=
std
:
:
abs
(
aRayData
.
mInitialPosition
.
x
)
;
CSSCoord
right
=
std
:
:
abs
(
aRayData
.
mContainingBlockRect
.
width
-
aRayData
.
mInitialPosition
.
x
)
;
CSSCoord
top
=
std
:
:
abs
(
aRayData
.
mInitialPosition
.
y
)
;
CSSCoord
bottom
=
std
:
:
abs
(
aRayData
.
mContainingBlockRect
.
height
-
aRayData
.
mInitialPosition
.
y
)
;
switch
(
aRaySizeType
)
{
case
StyleRaySize
:
:
ClosestSide
:
return
std
:
:
min
(
{
left
right
top
bottom
}
)
;
case
StyleRaySize
:
:
FarthestSide
:
return
std
:
:
max
(
{
left
right
top
bottom
}
)
;
case
StyleRaySize
:
:
ClosestCorner
:
case
StyleRaySize
:
:
FarthestCorner
:
{
CSSCoord
h
=
0
;
CSSCoord
v
=
0
;
if
(
aRaySizeType
=
=
StyleRaySize
:
:
ClosestCorner
)
{
h
=
std
:
:
min
(
left
right
)
;
v
=
std
:
:
min
(
top
bottom
)
;
}
else
{
h
=
std
:
:
max
(
left
right
)
;
v
=
std
:
:
max
(
top
bottom
)
;
}
return
sqrt
(
h
.
value
*
h
.
value
+
v
.
value
*
v
.
value
)
;
}
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unsupported
ray
size
"
)
;
}
return
0
.
0
;
}
static
void
ApplyRotationAndMoveRayToXAxis
(
const
StyleOffsetRotate
&
aOffsetRotate
const
StyleAngle
&
aRayAngle
AutoTArray
<
gfx
:
:
Point
4
>
&
aVertices
)
{
const
StyleAngle
directionAngle
=
aRayAngle
-
StyleAngle
{
90
.
0f
}
;
const
StyleAngle
rotateAngle
=
(
aOffsetRotate
.
auto_
?
directionAngle
:
StyleAngle
{
0
.
0f
}
)
+
aOffsetRotate
.
angle
;
const
StyleAngle
rayToXAxis
=
StyleAngle
{
90
.
0
}
-
aRayAngle
;
gfx
:
:
Matrix
m
;
m
.
PreRotate
(
(
rotateAngle
+
rayToXAxis
)
.
ToRadians
(
)
)
;
for
(
gfx
:
:
Point
&
p
:
aVertices
)
{
p
=
m
.
TransformPoint
(
p
)
;
}
}
class
RayPointComparator
{
public
:
bool
Equals
(
const
gfx
:
:
Point
&
a
const
gfx
:
:
Point
&
b
)
const
{
return
std
:
:
fabs
(
a
.
y
)
=
=
std
:
:
fabs
(
b
.
y
)
;
}
bool
LessThan
(
const
gfx
:
:
Point
&
a
const
gfx
:
:
Point
&
b
)
const
{
return
std
:
:
fabs
(
a
.
y
)
>
std
:
:
fabs
(
b
.
y
)
;
}
}
;
static
CSSCoord
ComputeRayUsedDistance
(
const
RayFunction
&
aRay
const
LengthPercentage
&
aDistance
const
StyleOffsetRotate
&
aRotate
const
StylePositionOrAuto
&
aAnchor
const
CSSPoint
&
aTransformOrigin
TransformReferenceBox
&
aRefBox
const
CSSCoord
&
aPathLength
)
{
CSSCoord
usedDistance
=
aDistance
.
ResolveToCSSPixels
(
aPathLength
)
;
if
(
!
aRay
.
contain
)
{
return
usedDistance
;
}
CSSPoint
usedAnchor
=
aTransformOrigin
;
CSSSize
size
=
CSSPixel
:
:
FromAppUnits
(
nsSize
(
aRefBox
.
Width
(
)
aRefBox
.
Height
(
)
)
)
;
if
(
!
aAnchor
.
IsAuto
(
)
)
{
const
StylePosition
&
anchor
=
aAnchor
.
AsPosition
(
)
;
usedAnchor
.
x
=
anchor
.
horizontal
.
ResolveToCSSPixels
(
size
.
width
)
;
usedAnchor
.
y
=
anchor
.
vertical
.
ResolveToCSSPixels
(
size
.
height
)
;
}
AutoTArray
<
gfx
:
:
Point
4
>
vertices
=
{
{
-
usedAnchor
.
x
-
usedAnchor
.
y
}
{
size
.
width
-
usedAnchor
.
x
-
usedAnchor
.
y
}
{
size
.
width
-
usedAnchor
.
x
size
.
height
-
usedAnchor
.
y
}
{
-
usedAnchor
.
x
size
.
height
-
usedAnchor
.
y
}
}
;
ApplyRotationAndMoveRayToXAxis
(
aRotate
aRay
.
angle
vertices
)
;
float
upperMin
=
std
:
:
numeric_limits
<
float
>
:
:
max
(
)
;
float
lowerMax
=
std
:
:
numeric_limits
<
float
>
:
:
min
(
)
;
bool
shouldIncreasePathLength
=
false
;
for
(
const
gfx
:
:
Point
&
p
:
vertices
)
{
float
d
=
aPathLength
.
value
*
aPathLength
.
value
-
p
.
y
*
p
.
y
;
if
(
d
<
0
)
{
shouldIncreasePathLength
=
true
;
break
;
}
float
sqrtD
=
sqrt
(
d
)
;
upperMin
=
std
:
:
min
(
upperMin
-
p
.
x
+
sqrtD
)
;
lowerMax
=
std
:
:
max
(
lowerMax
-
p
.
x
-
sqrtD
)
;
}
if
(
!
shouldIncreasePathLength
)
{
return
std
:
:
max
(
lowerMax
std
:
:
min
(
upperMin
(
float
)
usedDistance
)
)
;
}
vertices
.
Sort
(
RayPointComparator
(
)
)
;
double
radius
=
std
:
:
fabs
(
vertices
[
0
]
.
y
)
;
usedDistance
=
-
vertices
[
0
]
.
x
;
const
double
epsilon
=
1e
-
5
;
for
(
size_t
i
=
0
;
i
<
3
;
+
+
i
)
{
for
(
size_t
j
=
i
+
1
;
j
<
4
;
+
+
j
)
{
double
xi
=
vertices
[
i
]
.
x
;
double
yi
=
vertices
[
i
]
.
y
;
double
xj
=
vertices
[
j
]
.
x
;
double
yj
=
vertices
[
j
]
.
y
;
double
dx
=
xi
-
xj
;
if
(
dx
*
dx
+
yj
*
yj
<
=
yi
*
yi
+
epsilon
)
{
continue
;
}
double
newUsedDistance
=
(
xj
*
xj
+
yj
*
yj
-
xi
*
xi
-
yi
*
yi
)
/
dx
/
2
.
0
;
xi
+
=
newUsedDistance
;
double
newRadius
=
sqrt
(
xi
*
xi
+
yi
*
yi
)
;
if
(
newRadius
>
radius
)
{
radius
=
newRadius
;
usedDistance
=
(
float
)
newUsedDistance
;
}
}
}
return
usedDistance
;
}
CSSPoint
MotionPathUtils
:
:
ComputeAnchorPointAdjustment
(
const
nsIFrame
&
aFrame
)
{
if
(
!
aFrame
.
HasAnyStateBits
(
NS_FRAME_SVG_LAYOUT
)
)
{
return
{
}
;
}
auto
transformBox
=
aFrame
.
StyleDisplay
(
)
-
>
mTransformBox
;
if
(
transformBox
=
=
StyleGeometryBox
:
:
ViewBox
|
|
transformBox
=
=
StyleGeometryBox
:
:
BorderBox
)
{
return
{
}
;
}
if
(
aFrame
.
IsFrameOfType
(
nsIFrame
:
:
eSVGContainer
)
)
{
nsRect
boxRect
=
nsLayoutUtils
:
:
ComputeGeometryBox
(
const_cast
<
nsIFrame
*
>
(
&
aFrame
)
StyleGeometryBox
:
:
FillBox
)
;
return
CSSPoint
:
:
FromAppUnits
(
boxRect
.
TopLeft
(
)
)
;
}
return
CSSPoint
:
:
FromAppUnits
(
aFrame
.
GetPosition
(
)
)
;
}
Maybe
<
ResolvedMotionPathData
>
MotionPathUtils
:
:
ResolveMotionPath
(
const
OffsetPathData
&
aPath
const
LengthPercentage
&
aDistance
const
StyleOffsetRotate
&
aRotate
const
StylePositionOrAuto
&
aAnchor
const
CSSPoint
&
aTransformOrigin
TransformReferenceBox
&
aRefBox
const
CSSPoint
&
aAnchorPointAdjustment
)
{
if
(
aPath
.
IsNone
(
)
)
{
return
Nothing
(
)
;
}
double
directionAngle
=
0
.
0
;
gfx
:
:
Point
point
;
if
(
aPath
.
IsPath
(
)
)
{
const
auto
&
path
=
aPath
.
AsPath
(
)
;
if
(
!
path
.
mGfxPath
)
{
return
Nothing
(
)
;
}
gfx
:
:
Float
pathLength
=
path
.
mGfxPath
-
>
ComputeLength
(
)
;
gfx
:
:
Float
usedDistance
=
aDistance
.
ResolveToCSSPixels
(
CSSCoord
(
pathLength
)
)
;
if
(
path
.
mIsClosedIntervals
)
{
usedDistance
=
pathLength
>
0
.
0
?
fmod
(
usedDistance
pathLength
)
:
0
.
0
;
if
(
usedDistance
<
0
.
0
)
{
usedDistance
+
=
pathLength
;
}
}
else
{
usedDistance
=
clamped
(
usedDistance
0
.
0f
pathLength
)
;
}
gfx
:
:
Point
tangent
;
point
=
path
.
mGfxPath
-
>
ComputePointAtLength
(
usedDistance
&
tangent
)
;
directionAngle
=
(
double
)
atan2
(
tangent
.
y
tangent
.
x
)
;
}
else
if
(
aPath
.
IsRay
(
)
)
{
const
auto
&
ray
=
aPath
.
AsRay
(
)
;
MOZ_ASSERT
(
ray
.
mRay
)
;
CSSCoord
pathLength
=
ComputeRayPathLength
(
ray
.
mRay
-
>
size
ray
.
mRay
-
>
angle
ray
.
mData
)
;
CSSCoord
usedDistance
=
ComputeRayUsedDistance
(
*
ray
.
mRay
aDistance
aRotate
aAnchor
aTransformOrigin
aRefBox
pathLength
)
;
directionAngle
=
StyleAngle
{
ray
.
mRay
-
>
angle
.
ToDegrees
(
)
-
90
.
0f
}
.
ToRadians
(
)
;
point
.
x
=
usedDistance
*
cos
(
directionAngle
)
;
point
.
y
=
usedDistance
*
sin
(
directionAngle
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
Unsupported
offset
-
path
value
"
)
;
return
Nothing
(
)
;
}
gfx
:
:
Float
angle
=
static_cast
<
gfx
:
:
Float
>
(
(
aRotate
.
auto_
?
directionAngle
:
0
.
0
)
+
aRotate
.
angle
.
ToRadians
(
)
)
;
CSSPoint
anchorPoint
(
aTransformOrigin
)
;
gfx
:
:
Point
shift
;
if
(
!
aAnchor
.
IsAuto
(
)
)
{
const
auto
&
pos
=
aAnchor
.
AsPosition
(
)
;
anchorPoint
=
nsStyleTransformMatrix
:
:
Convert2DPosition
(
pos
.
horizontal
pos
.
vertical
aRefBox
)
;
shift
=
(
anchorPoint
-
aTransformOrigin
)
.
ToUnknownPoint
(
)
;
}
anchorPoint
+
=
aAnchorPointAdjustment
;
return
Some
(
ResolvedMotionPathData
{
point
-
anchorPoint
.
ToUnknownPoint
(
)
angle
shift
}
)
;
}
static
OffsetPathData
GenerateOffsetPathData
(
const
nsIFrame
*
aFrame
)
{
const
StyleOffsetPath
&
path
=
aFrame
-
>
StyleDisplay
(
)
-
>
mOffsetPath
;
switch
(
path
.
tag
)
{
case
StyleOffsetPath
:
:
Tag
:
:
Path
:
{
const
StyleSVGPathData
&
pathData
=
path
.
AsPath
(
)
;
RefPtr
<
gfx
:
:
Path
>
gfxPath
=
aFrame
-
>
GetProperty
(
nsIFrame
:
:
OffsetPathCache
(
)
)
;
MOZ_ASSERT
(
gfxPath
|
|
pathData
.
_0
.
IsEmpty
(
)
"
Should
have
a
valid
cached
gfx
:
:
Path
or
an
empty
path
string
"
)
;
return
OffsetPathData
:
:
Path
(
pathData
gfxPath
.
forget
(
)
)
;
}
case
StyleOffsetPath
:
:
Tag
:
:
Ray
:
return
OffsetPathData
:
:
Ray
(
path
.
AsRay
(
)
RayReferenceData
(
aFrame
)
)
;
case
StyleOffsetPath
:
:
Tag
:
:
None
:
return
OffsetPathData
:
:
None
(
)
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
offset
-
path
"
)
;
return
OffsetPathData
:
:
None
(
)
;
}
}
Maybe
<
ResolvedMotionPathData
>
MotionPathUtils
:
:
ResolveMotionPath
(
const
nsIFrame
*
aFrame
TransformReferenceBox
&
aRefBox
)
{
MOZ_ASSERT
(
aFrame
)
;
const
nsStyleDisplay
*
display
=
aFrame
-
>
StyleDisplay
(
)
;
CSSPoint
transformOrigin
=
nsStyleTransformMatrix
:
:
Convert2DPosition
(
display
-
>
mTransformOrigin
.
horizontal
display
-
>
mTransformOrigin
.
vertical
aRefBox
)
;
return
ResolveMotionPath
(
GenerateOffsetPathData
(
aFrame
)
display
-
>
mOffsetDistance
display
-
>
mOffsetRotate
display
-
>
mOffsetAnchor
transformOrigin
aRefBox
ComputeAnchorPointAdjustment
(
*
aFrame
)
)
;
}
static
OffsetPathData
GenerateOffsetPathData
(
const
StyleOffsetPath
&
aPath
const
RayReferenceData
&
aRayReferenceData
gfx
:
:
Path
*
aCachedMotionPath
)
{
switch
(
aPath
.
tag
)
{
case
StyleOffsetPath
:
:
Tag
:
:
Path
:
{
const
StyleSVGPathData
&
pathData
=
aPath
.
AsPath
(
)
;
RefPtr
<
gfx
:
:
Path
>
path
=
aCachedMotionPath
;
if
(
!
path
)
{
RefPtr
<
gfx
:
:
PathBuilder
>
builder
=
MotionPathUtils
:
:
GetCompositorPathBuilder
(
)
;
path
=
MotionPathUtils
:
:
BuildPath
(
pathData
builder
)
;
}
return
OffsetPathData
:
:
Path
(
pathData
path
.
forget
(
)
)
;
}
case
StyleOffsetPath
:
:
Tag
:
:
Ray
:
return
OffsetPathData
:
:
Ray
(
aPath
.
AsRay
(
)
aRayReferenceData
)
;
case
StyleOffsetPath
:
:
Tag
:
:
None
:
default
:
return
OffsetPathData
:
:
None
(
)
;
}
}
Maybe
<
ResolvedMotionPathData
>
MotionPathUtils
:
:
ResolveMotionPath
(
const
StyleOffsetPath
*
aPath
const
StyleLengthPercentage
*
aDistance
const
StyleOffsetRotate
*
aRotate
const
StylePositionOrAuto
*
aAnchor
const
Maybe
<
layers
:
:
MotionPathData
>
&
aMotionPathData
TransformReferenceBox
&
aRefBox
gfx
:
:
Path
*
aCachedMotionPath
)
{
if
(
!
aPath
)
{
return
Nothing
(
)
;
}
MOZ_ASSERT
(
aMotionPathData
)
;
auto
zeroOffsetDistance
=
LengthPercentage
:
:
Zero
(
)
;
auto
autoOffsetRotate
=
StyleOffsetRotate
{
true
StyleAngle
:
:
Zero
(
)
}
;
auto
autoOffsetAnchor
=
StylePositionOrAuto
:
:
Auto
(
)
;
return
ResolveMotionPath
(
GenerateOffsetPathData
(
*
aPath
aMotionPathData
-
>
rayReferenceData
(
)
aCachedMotionPath
)
aDistance
?
*
aDistance
:
zeroOffsetDistance
aRotate
?
*
aRotate
:
autoOffsetRotate
aAnchor
?
*
aAnchor
:
autoOffsetAnchor
aMotionPathData
-
>
origin
(
)
aRefBox
aMotionPathData
-
>
anchorAdjustment
(
)
)
;
}
StyleSVGPathData
MotionPathUtils
:
:
NormalizeSVGPathData
(
const
StyleSVGPathData
&
aPath
)
{
StyleSVGPathData
n
;
Servo_SVGPathData_Normalize
(
&
aPath
&
n
)
;
return
n
;
}
already_AddRefed
<
gfx
:
:
Path
>
MotionPathUtils
:
:
BuildPath
(
const
StyleSVGPathData
&
aPath
gfx
:
:
PathBuilder
*
aPathBuilder
)
{
if
(
!
aPathBuilder
)
{
return
nullptr
;
}
const
Span
<
const
StylePathCommand
>
&
path
=
aPath
.
_0
.
AsSpan
(
)
;
return
SVGPathData
:
:
BuildPath
(
path
aPathBuilder
StyleStrokeLinecap
:
:
Butt
0
.
0
)
;
}
already_AddRefed
<
gfx
:
:
PathBuilder
>
MotionPathUtils
:
:
GetCompositorPathBuilder
(
)
{
RefPtr
<
gfx
:
:
PathBuilder
>
builder
=
gfxPlatform
:
:
Initialized
(
)
?
gfxPlatform
:
:
GetPlatform
(
)
-
>
ScreenReferenceDrawTarget
(
)
-
>
CreatePathBuilder
(
gfx
:
:
FillRule
:
:
FILL_WINDING
)
:
gfx
:
:
Factory
:
:
CreateSimplePathBuilder
(
)
;
return
builder
.
forget
(
)
;
}
}
