#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
ifndef
mozilla_ArenaRefPtr_h
#
define
mozilla_ArenaRefPtr_h
class
nsPresArena
;
namespace
mozilla
{
template
<
typename
T
>
class
ArenaRefPtr
{
friend
class
:
:
nsPresArena
;
public
:
ArenaRefPtr
(
)
{
AssertValidType
(
)
;
}
template
<
typename
I
>
MOZ_IMPLICIT
ArenaRefPtr
(
already_AddRefed
<
I
>
&
aRhs
)
{
AssertValidType
(
)
;
assign
(
aRhs
)
;
}
template
<
typename
I
>
MOZ_IMPLICIT
ArenaRefPtr
(
already_AddRefed
<
I
>
&
&
aRhs
)
{
AssertValidType
(
)
;
assign
(
aRhs
)
;
}
MOZ_IMPLICIT
ArenaRefPtr
(
T
*
aRhs
)
{
AssertValidType
(
)
;
assign
(
aRhs
)
;
}
template
<
typename
I
>
ArenaRefPtr
<
T
>
&
operator
=
(
already_AddRefed
<
I
>
&
aRhs
)
{
assign
(
aRhs
)
;
return
*
this
;
}
template
<
typename
I
>
ArenaRefPtr
<
T
>
&
operator
=
(
already_AddRefed
<
I
>
&
&
aRhs
)
{
assign
(
aRhs
)
;
return
*
this
;
}
ArenaRefPtr
<
T
>
&
operator
=
(
T
*
aRhs
)
{
assign
(
aRhs
)
;
return
*
this
;
}
~
ArenaRefPtr
(
)
{
assign
(
nullptr
)
;
}
operator
T
*
(
)
const
&
{
return
get
(
)
;
}
operator
T
*
(
)
const
&
&
=
delete
;
explicit
operator
bool
(
)
const
{
return
!
!
mPtr
;
}
bool
operator
!
(
)
const
{
return
!
mPtr
;
}
T
*
operator
-
>
(
)
const
{
return
mPtr
.
operator
-
>
(
)
;
}
T
&
operator
*
(
)
const
{
return
*
get
(
)
;
}
T
*
get
(
)
const
{
return
mPtr
;
}
private
:
void
AssertValidType
(
)
;
void
ClearWithoutDeregistering
(
)
{
mPtr
=
nullptr
;
}
template
<
typename
I
>
void
assign
(
already_AddRefed
<
I
>
&
aSmartPtr
)
{
RefPtr
<
T
>
newPtr
(
aSmartPtr
)
;
assignFrom
(
newPtr
)
;
}
template
<
typename
I
>
void
assign
(
already_AddRefed
<
I
>
&
&
aSmartPtr
)
{
RefPtr
<
T
>
newPtr
(
aSmartPtr
)
;
assignFrom
(
newPtr
)
;
}
void
assign
(
T
*
aPtr
)
{
assignFrom
(
aPtr
)
;
}
template
<
typename
I
>
void
assignFrom
(
I
&
aPtr
)
{
if
(
aPtr
=
=
mPtr
)
{
return
;
}
bool
sameArena
=
mPtr
&
&
aPtr
&
&
mPtr
-
>
Arena
(
)
=
=
aPtr
-
>
Arena
(
)
;
if
(
mPtr
&
&
!
sameArena
)
{
MOZ_ASSERT
(
mPtr
-
>
Arena
(
)
)
;
mPtr
-
>
Arena
(
)
-
>
DeregisterArenaRefPtr
(
this
)
;
}
mPtr
=
std
:
:
move
(
aPtr
)
;
if
(
mPtr
&
&
!
sameArena
)
{
MOZ_ASSERT
(
mPtr
-
>
Arena
(
)
)
;
mPtr
-
>
Arena
(
)
-
>
RegisterArenaRefPtr
(
this
)
;
}
}
RefPtr
<
T
>
mPtr
;
}
;
}
#
endif
