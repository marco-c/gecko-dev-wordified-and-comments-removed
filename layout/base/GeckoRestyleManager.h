#
ifndef
mozilla_GeckoRestyleManager_h
#
define
mozilla_GeckoRestyleManager_h
#
include
"
mozilla
/
RestyleLogging
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsChangeHint
.
h
"
#
include
"
RestyleTracker
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsRefreshDriver
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
nsTransitionManager
.
h
"
class
nsIFrame
;
class
nsStyleChangeList
;
struct
TreeMatchContext
;
namespace
mozilla
{
enum
class
CSSPseudoElementType
:
uint8_t
;
class
EventStates
;
struct
UndisplayedNode
;
namespace
dom
{
class
Element
;
}
class
GeckoRestyleManager
final
:
public
RestyleManager
{
public
:
typedef
RestyleManager
base_type
;
friend
class
RestyleTracker
;
friend
class
ElementRestyler
;
explicit
GeckoRestyleManager
(
nsPresContext
*
aPresContext
)
;
protected
:
~
GeckoRestyleManager
(
)
override
{
MOZ_ASSERT
(
!
mReframingStyleContexts
"
temporary
member
should
be
nulled
out
before
destruction
"
)
;
}
public
:
void
ContentStateChanged
(
nsIContent
*
aContent
EventStates
aStateMask
)
;
void
AttributeWillChange
(
Element
*
aElement
int32_t
aNameSpaceID
nsIAtom
*
aAttribute
int32_t
aModType
const
nsAttrValue
*
aNewValue
)
;
void
AttributeChanged
(
Element
*
aElement
int32_t
aNameSpaceID
nsIAtom
*
aAttribute
int32_t
aModType
const
nsAttrValue
*
aOldValue
)
;
bool
SkipAnimationRules
(
)
const
{
return
mSkipAnimationRules
;
}
void
SetSkipAnimationRules
(
bool
aSkipAnimationRules
)
{
mSkipAnimationRules
=
aSkipAnimationRules
;
}
nsresult
ReparentStyleContext
(
nsIFrame
*
aFrame
)
;
void
ClearSelectors
(
)
{
mPendingRestyles
.
ClearSelectors
(
)
;
}
void
PostRestyleEventForLazyConstruction
(
)
{
PostRestyleEventInternal
(
)
;
}
private
:
void
PostRestyleEventInternal
(
)
;
void
ComputeAndProcessStyleChange
(
nsIFrame
*
aFrame
nsChangeHint
aMinChange
RestyleTracker
&
aRestyleTracker
nsRestyleHint
aRestyleHint
const
RestyleHintData
&
aRestyleHintData
)
;
void
ComputeAndProcessStyleChange
(
GeckoStyleContext
*
aNewContext
Element
*
aElement
nsChangeHint
aMinChange
RestyleTracker
&
aRestyleTracker
nsRestyleHint
aRestyleHint
const
RestyleHintData
&
aRestyleHintData
)
;
public
:
typedef
nsRefPtrHashtable
<
nsRefPtrHashKey
<
nsIContent
>
GeckoStyleContext
>
ReframingStyleContextTable
;
class
MOZ_STACK_CLASS
ReframingStyleContexts
final
{
public
:
explicit
ReframingStyleContexts
(
GeckoRestyleManager
*
aRestyleManager
)
;
~
ReframingStyleContexts
(
)
;
void
Put
(
nsIContent
*
aContent
GeckoStyleContext
*
aStyleContext
)
{
MOZ_ASSERT
(
aContent
)
;
CSSPseudoElementType
pseudoType
=
aStyleContext
-
>
GetPseudoType
(
)
;
if
(
pseudoType
=
=
CSSPseudoElementType
:
:
NotPseudo
)
{
mElementContexts
.
Put
(
aContent
aStyleContext
)
;
}
else
if
(
pseudoType
=
=
CSSPseudoElementType
:
:
before
)
{
MOZ_ASSERT
(
aContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
nsGkAtoms
:
:
mozgeneratedcontentbefore
)
;
mBeforePseudoContexts
.
Put
(
aContent
-
>
GetParent
(
)
aStyleContext
)
;
}
else
if
(
pseudoType
=
=
CSSPseudoElementType
:
:
after
)
{
MOZ_ASSERT
(
aContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
nsGkAtoms
:
:
mozgeneratedcontentafter
)
;
mAfterPseudoContexts
.
Put
(
aContent
-
>
GetParent
(
)
aStyleContext
)
;
}
}
GeckoStyleContext
*
Get
(
nsIContent
*
aContent
CSSPseudoElementType
aPseudoType
)
{
MOZ_ASSERT
(
aContent
)
;
if
(
aPseudoType
=
=
CSSPseudoElementType
:
:
NotPseudo
)
{
return
mElementContexts
.
GetWeak
(
aContent
)
;
}
if
(
aPseudoType
=
=
CSSPseudoElementType
:
:
before
)
{
MOZ_ASSERT
(
aContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
nsGkAtoms
:
:
mozgeneratedcontentbefore
)
;
return
mBeforePseudoContexts
.
GetWeak
(
aContent
-
>
GetParent
(
)
)
;
}
if
(
aPseudoType
=
=
CSSPseudoElementType
:
:
after
)
{
MOZ_ASSERT
(
aContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
nsGkAtoms
:
:
mozgeneratedcontentafter
)
;
return
mAfterPseudoContexts
.
GetWeak
(
aContent
-
>
GetParent
(
)
)
;
}
MOZ_ASSERT
(
false
"
unexpected
aPseudoType
"
)
;
return
nullptr
;
}
private
:
GeckoRestyleManager
*
mRestyleManager
;
AutoRestore
<
ReframingStyleContexts
*
>
mRestorePointer
;
ReframingStyleContextTable
mElementContexts
;
ReframingStyleContextTable
mBeforePseudoContexts
;
ReframingStyleContextTable
mAfterPseudoContexts
;
}
;
ReframingStyleContexts
*
GetReframingStyleContexts
(
)
{
return
mReframingStyleContexts
;
}
static
bool
TryInitiatingTransition
(
nsPresContext
*
aPresContext
nsIContent
*
aContent
GeckoStyleContext
*
aOldStyleContext
RefPtr
<
GeckoStyleContext
>
*
aNewStyleContext
)
;
public
:
void
ProcessPendingRestyles
(
)
;
private
:
void
BeginProcessingRestyles
(
RestyleTracker
&
aRestyleTracker
)
;
void
EndProcessingRestyles
(
)
;
public
:
void
UpdateOnlyAnimationStyles
(
)
;
void
RebuildAllStyleData
(
nsChangeHint
aExtraHint
nsRestyleHint
aRestyleHint
)
;
void
PostRestyleEvent
(
Element
*
aElement
nsRestyleHint
aRestyleHint
nsChangeHint
aMinChangeHint
const
RestyleHintData
*
aRestyleHintData
=
nullptr
)
;
public
:
void
PostRebuildAllStyleDataEvent
(
nsChangeHint
aExtraHint
nsRestyleHint
aRestyleHint
)
;
#
ifdef
DEBUG
bool
InRebuildAllStyleData
(
)
const
{
return
mInRebuildAllStyleData
;
}
#
endif
#
ifdef
RESTYLE_LOGGING
bool
ShouldLogRestyle
(
)
{
return
ShouldLogRestyle
(
PresContext
(
)
)
;
}
static
bool
ShouldLogRestyle
(
nsPresContext
*
aPresContext
)
{
return
aPresContext
-
>
RestyleLoggingEnabled
(
)
&
&
(
!
aPresContext
-
>
TransitionManager
(
)
-
>
InAnimationOnlyStyleUpdate
(
)
|
|
AnimationRestyleLoggingEnabled
(
)
)
;
}
static
bool
RestyleLoggingInitiallyEnabled
(
)
{
static
bool
enabled
=
getenv
(
"
MOZ_DEBUG_RESTYLE
"
)
!
=
0
;
return
enabled
;
}
static
bool
AnimationRestyleLoggingEnabled
(
)
{
static
bool
animations
=
getenv
(
"
MOZ_DEBUG_RESTYLE_ANIMATIONS
"
)
!
=
0
;
return
animations
;
}
static
uint32_t
StructsToLog
(
)
;
static
nsCString
StructNamesToString
(
uint32_t
aSIDs
)
;
int32_t
&
LoggingDepth
(
)
{
return
mLoggingDepth
;
}
#
endif
bool
IsProcessingRestyles
(
)
{
return
mIsProcessingRestyles
;
}
private
:
inline
nsStyleSet
*
StyleSet
(
)
const
{
MOZ_ASSERT
(
PresContext
(
)
-
>
StyleSet
(
)
-
>
IsGecko
(
)
"
GeckoRestyleManager
should
only
be
used
with
a
Gecko
-
flavored
"
"
style
backend
"
)
;
return
PresContext
(
)
-
>
StyleSet
(
)
-
>
AsGecko
(
)
;
}
void
RestyleElement
(
Element
*
aElement
nsIFrame
*
aPrimaryFrame
nsChangeHint
aMinHint
RestyleTracker
&
aRestyleTracker
nsRestyleHint
aRestyleHint
const
RestyleHintData
&
aRestyleHintData
)
;
void
StartRebuildAllStyleData
(
RestyleTracker
&
aRestyleTracker
)
;
void
FinishRebuildAllStyleData
(
)
;
bool
ShouldStartRebuildAllFor
(
RestyleTracker
&
aRestyleTracker
)
{
return
mDoRebuildAllStyleData
&
&
&
aRestyleTracker
=
=
&
mPendingRestyles
;
}
void
ProcessRestyles
(
RestyleTracker
&
aRestyleTracker
)
{
if
(
aRestyleTracker
.
Count
(
)
|
|
ShouldStartRebuildAllFor
(
aRestyleTracker
)
)
{
IncrementRestyleGeneration
(
)
;
aRestyleTracker
.
DoProcessRestyles
(
)
;
}
}
private
:
bool
mDoRebuildAllStyleData
:
1
;
bool
mInRebuildAllStyleData
:
1
;
bool
mSkipAnimationRules
:
1
;
bool
mHavePendingNonAnimationRestyles
:
1
;
nsChangeHint
mRebuildAllExtraHint
;
nsRestyleHint
mRebuildAllRestyleHint
;
ReframingStyleContexts
*
mReframingStyleContexts
;
RestyleTracker
mPendingRestyles
;
bool
mIsProcessingRestyles
;
#
ifdef
RESTYLE_LOGGING
int32_t
mLoggingDepth
;
#
endif
}
;
class
ElementRestyler
final
{
public
:
typedef
mozilla
:
:
dom
:
:
Element
Element
;
struct
ContextToClear
{
RefPtr
<
GeckoStyleContext
>
mStyleContext
;
uint32_t
mStructs
;
}
;
ElementRestyler
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
nsStyleChangeList
*
aChangeList
nsChangeHint
aHintsHandledByAncestors
RestyleTracker
&
aRestyleTracker
nsTArray
<
nsCSSSelector
*
>
&
aSelectorsForDescendants
TreeMatchContext
&
aTreeMatchContext
nsTArray
<
nsIContent
*
>
&
aVisibleKidsOfHiddenElement
nsTArray
<
ContextToClear
>
&
aContextsToClear
nsTArray
<
RefPtr
<
GeckoStyleContext
>
>
&
aSwappedStructOwners
)
;
enum
ConstructorFlags
{
FOR_OUT_OF_FLOW_CHILD
=
1
<
<
0
}
;
ElementRestyler
(
const
ElementRestyler
&
aParentRestyler
nsIFrame
*
aFrame
uint32_t
aConstructorFlags
)
;
enum
ParentContextFromChildFrame
{
PARENT_CONTEXT_FROM_CHILD_FRAME
}
;
ElementRestyler
(
ParentContextFromChildFrame
const
ElementRestyler
&
aParentFrameRestyler
nsIFrame
*
aFrame
)
;
ElementRestyler
(
nsPresContext
*
aPresContext
nsIContent
*
aContent
nsStyleChangeList
*
aChangeList
nsChangeHint
aHintsHandledByAncestors
RestyleTracker
&
aRestyleTracker
nsTArray
<
nsCSSSelector
*
>
&
aSelectorsForDescendants
TreeMatchContext
&
aTreeMatchContext
nsTArray
<
nsIContent
*
>
&
aVisibleKidsOfHiddenElement
nsTArray
<
ContextToClear
>
&
aContextsToClear
nsTArray
<
RefPtr
<
GeckoStyleContext
>
>
&
aSwappedStructOwners
)
;
void
Restyle
(
nsRestyleHint
aRestyleHint
)
;
nsChangeHint
HintsHandledForFrame
(
)
{
return
mHintsHandledBySelf
;
}
void
RestyleChildrenOfDisplayContentsElement
(
nsIFrame
*
aParentFrame
GeckoStyleContext
*
aNewContext
nsChangeHint
aMinHint
RestyleTracker
&
aRestyleTracker
nsRestyleHint
aRestyleHint
const
RestyleHintData
&
aRestyleHintData
)
;
static
void
ComputeStyleChangeFor
(
nsIFrame
*
aFrame
nsStyleChangeList
*
aChangeList
nsChangeHint
aMinChange
RestyleTracker
&
aRestyleTracker
nsRestyleHint
aRestyleHint
const
RestyleHintData
&
aRestyleHintData
nsTArray
<
ContextToClear
>
&
aContextsToClear
nsTArray
<
RefPtr
<
GeckoStyleContext
>
>
&
aSwappedStructOwners
)
;
#
ifdef
RESTYLE_LOGGING
bool
ShouldLogRestyle
(
)
{
return
GeckoRestyleManager
:
:
ShouldLogRestyle
(
mPresContext
)
;
}
#
endif
private
:
inline
nsStyleSet
*
StyleSet
(
)
const
;
enum
class
RestyleResult
:
uint8_t
{
eNone
eStop
eStopWithStyleChange
eContinue
eContinueAndForceDescendants
}
;
struct
SwapInstruction
{
RefPtr
<
GeckoStyleContext
>
mOldContext
;
RefPtr
<
GeckoStyleContext
>
mNewContext
;
uint32_t
mStructsToSwap
;
}
;
RestyleResult
RestyleSelf
(
nsIFrame
*
aSelf
nsRestyleHint
aRestyleHint
uint32_t
*
aSwappedStructs
nsTArray
<
SwapInstruction
>
&
aSwaps
)
;
void
RestyleChildren
(
nsRestyleHint
aChildRestyleHint
)
;
bool
SelectorMatchesForRestyle
(
Element
*
aElement
)
;
bool
MustRestyleSelf
(
nsRestyleHint
aRestyleHint
Element
*
aElement
)
;
bool
CanReparentStyleContext
(
nsRestyleHint
aRestyleHint
)
;
bool
MoveStyleContextsForContentChildren
(
nsIFrame
*
aParent
GeckoStyleContext
*
aOldContext
nsTArray
<
GeckoStyleContext
*
>
&
aContextsToMove
)
;
bool
MoveStyleContextsForChildren
(
GeckoStyleContext
*
aOldContext
)
;
void
CaptureChange
(
GeckoStyleContext
*
aOldContext
GeckoStyleContext
*
aNewContext
nsChangeHint
aChangeToAssume
uint32_t
*
aEqualStructs
uint32_t
*
aSamePointerStructs
)
;
void
ComputeRestyleResultFromFrame
(
nsIFrame
*
aSelf
RestyleResult
&
aRestyleResult
bool
&
aCanStopWithStyleChange
)
;
void
ComputeRestyleResultFromNewContext
(
nsIFrame
*
aSelf
GeckoStyleContext
*
aNewContext
RestyleResult
&
aRestyleResult
bool
&
aCanStopWithStyleChange
)
;
void
RestyleUndisplayedDescendants
(
nsRestyleHint
aChildRestyleHint
)
;
bool
MustCheckUndisplayedContent
(
nsIFrame
*
aFrame
nsIContent
*
&
aUndisplayedParent
)
;
void
DoRestyleUndisplayedDescendants
(
nsRestyleHint
aChildRestyleHint
nsIContent
*
aParent
GeckoStyleContext
*
aParentStyleContext
)
;
void
RestyleUndisplayedNodes
(
nsRestyleHint
aChildRestyleHint
UndisplayedNode
*
aUndisplayed
nsIContent
*
aUndisplayedParent
GeckoStyleContext
*
aParentStyleContext
const
StyleDisplay
aDisplay
)
;
void
MaybeReframeForBeforePseudo
(
)
;
void
MaybeReframeForAfterPseudo
(
nsIFrame
*
aFrame
)
;
void
MaybeReframeForPseudo
(
CSSPseudoElementType
aPseudoType
nsIFrame
*
aGenConParentFrame
nsIFrame
*
aFrame
nsIContent
*
aContent
GeckoStyleContext
*
aStyleContext
)
;
#
ifdef
DEBUG
bool
MustReframeForBeforePseudo
(
)
;
bool
MustReframeForAfterPseudo
(
nsIFrame
*
aFrame
)
;
#
endif
bool
MustReframeForPseudo
(
CSSPseudoElementType
aPseudoType
nsIFrame
*
aGenConParentFrame
nsIFrame
*
aFrame
nsIContent
*
aContent
GeckoStyleContext
*
aStyleContext
)
;
void
RestyleContentChildren
(
nsIFrame
*
aParent
nsRestyleHint
aChildRestyleHint
)
;
void
InitializeAccessibilityNotifications
(
nsStyleContext
*
aNewContext
)
;
void
SendAccessibilityNotifications
(
)
;
enum
DesiredA11yNotifications
{
eSkipNotifications
eSendAllNotifications
eNotifyIfShown
}
;
enum
A11yNotificationType
{
eDontNotify
eNotifyShown
eNotifyHidden
}
;
void
ConditionallyRestyleChildren
(
)
;
void
ConditionallyRestyleChildren
(
nsIFrame
*
aFrame
Element
*
aRestyleRoot
)
;
void
ConditionallyRestyleContentChildren
(
nsIFrame
*
aFrame
Element
*
aRestyleRoot
)
;
void
ConditionallyRestyleUndisplayedDescendants
(
nsIFrame
*
aFrame
Element
*
aRestyleRoot
)
;
void
DoConditionallyRestyleUndisplayedDescendants
(
nsIContent
*
aParent
Element
*
aRestyleRoot
)
;
void
ConditionallyRestyleUndisplayedNodes
(
UndisplayedNode
*
aUndisplayed
nsIContent
*
aUndisplayedParent
const
StyleDisplay
aDisplay
Element
*
aRestyleRoot
)
;
void
ConditionallyRestyleContentDescendants
(
Element
*
aElement
Element
*
aRestyleRoot
)
;
bool
ConditionallyRestyle
(
nsIFrame
*
aFrame
Element
*
aRestyleRoot
)
;
bool
ConditionallyRestyle
(
Element
*
aElement
Element
*
aRestyleRoot
)
;
#
ifdef
RESTYLE_LOGGING
int32_t
&
LoggingDepth
(
)
{
return
mLoggingDepth
;
}
#
endif
#
ifdef
DEBUG
static
nsCString
RestyleResultToString
(
RestyleResult
aRestyleResult
)
;
#
endif
private
:
nsPresContext
*
const
mPresContext
;
nsIFrame
*
const
mFrame
;
nsIContent
*
const
mParentContent
;
nsIContent
*
const
mContent
;
nsStyleChangeList
*
const
mChangeList
;
const
nsChangeHint
mHintsHandledByAncestors
;
nsChangeHint
mHintsHandledBySelf
;
RestyleTracker
&
mRestyleTracker
;
nsTArray
<
nsCSSSelector
*
>
&
mSelectorsForDescendants
;
TreeMatchContext
&
mTreeMatchContext
;
nsIFrame
*
mResolvedChild
;
nsTArray
<
ContextToClear
>
&
mContextsToClear
;
nsTArray
<
RefPtr
<
GeckoStyleContext
>
>
&
mSwappedStructOwners
;
bool
mIsRootOfRestyle
;
#
ifdef
ACCESSIBILITY
const
DesiredA11yNotifications
mDesiredA11yNotifications
;
DesiredA11yNotifications
mKidsDesiredA11yNotifications
;
A11yNotificationType
mOurA11yNotification
;
nsTArray
<
nsIContent
*
>
&
mVisibleKidsOfHiddenElement
;
bool
mWasFrameVisible
;
#
endif
#
ifdef
RESTYLE_LOGGING
int32_t
mLoggingDepth
;
#
endif
}
;
class
MOZ_RAII
AutoDisplayContentsAncestorPusher
final
{
public
:
typedef
mozilla
:
:
dom
:
:
Element
Element
;
AutoDisplayContentsAncestorPusher
(
TreeMatchContext
&
aTreeMatchContext
nsPresContext
*
aPresContext
nsIContent
*
aParent
)
;
~
AutoDisplayContentsAncestorPusher
(
)
;
bool
IsEmpty
(
)
const
{
return
mAncestors
.
Length
(
)
=
=
0
;
}
private
:
TreeMatchContext
&
mTreeMatchContext
;
nsPresContext
*
const
mPresContext
;
AutoTArray
<
mozilla
:
:
dom
:
:
Element
*
4
>
mAncestors
;
}
;
}
#
endif
