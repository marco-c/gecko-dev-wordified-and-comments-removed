#
ifndef
mozilla_MotionPathUtils_h
#
define
mozilla_MotionPathUtils_h
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
ServoStyleConsts
.
h
"
#
include
"
Units
.
h
"
class
nsIFrame
;
namespace
nsStyleTransformMatrix
{
class
TransformReferenceBox
;
}
namespace
mozilla
{
using
RayFunction
=
StyleRayFunction
<
StyleAngle
>
;
namespace
layers
{
class
MotionPathData
;
class
PathCommand
;
}
struct
ResolvedMotionPathData
{
gfx
:
:
Point
mTranslate
;
float
mRotate
;
gfx
:
:
Point
mShift
;
}
;
struct
RayReferenceData
{
CSSPoint
mInitialPosition
;
CSSRect
mContainingBlockRect
;
RayReferenceData
(
)
=
default
;
explicit
RayReferenceData
(
const
nsIFrame
*
aFrame
)
;
bool
operator
=
=
(
const
RayReferenceData
&
aOther
)
const
{
return
mInitialPosition
=
=
aOther
.
mInitialPosition
&
&
mContainingBlockRect
=
=
aOther
.
mContainingBlockRect
;
}
}
;
struct
OffsetPathData
{
enum
class
Type
:
uint8_t
{
None
Path
Ray
}
;
struct
PathData
{
RefPtr
<
gfx
:
:
Path
>
mGfxPath
;
bool
mIsClosedIntervals
;
}
;
struct
RayData
{
const
RayFunction
*
mRay
;
RayReferenceData
mData
;
}
;
Type
mType
;
union
{
PathData
mPath
;
RayData
mRay
;
}
;
static
OffsetPathData
None
(
)
{
return
OffsetPathData
(
)
;
}
static
OffsetPathData
Path
(
const
StyleSVGPathData
&
aPath
already_AddRefed
<
gfx
:
:
Path
>
&
&
aGfxPath
)
{
const
auto
&
path
=
aPath
.
_0
.
AsSpan
(
)
;
return
OffsetPathData
(
std
:
:
move
(
aGfxPath
)
!
path
.
empty
(
)
&
&
path
.
rbegin
(
)
-
>
IsClosePath
(
)
)
;
}
static
OffsetPathData
Ray
(
const
RayFunction
&
aRay
const
RayReferenceData
&
aData
)
{
return
OffsetPathData
(
&
aRay
aData
)
;
}
static
OffsetPathData
Ray
(
const
RayFunction
&
aRay
RayReferenceData
&
&
aData
)
{
return
OffsetPathData
(
&
aRay
std
:
:
move
(
aData
)
)
;
}
bool
IsNone
(
)
const
{
return
mType
=
=
Type
:
:
None
;
}
bool
IsPath
(
)
const
{
return
mType
=
=
Type
:
:
Path
;
}
bool
IsRay
(
)
const
{
return
mType
=
=
Type
:
:
Ray
;
}
const
PathData
&
AsPath
(
)
const
{
MOZ_ASSERT
(
IsPath
(
)
)
;
return
mPath
;
}
const
RayData
&
AsRay
(
)
const
{
MOZ_ASSERT
(
IsRay
(
)
)
;
return
mRay
;
}
~
OffsetPathData
(
)
{
switch
(
mType
)
{
case
Type
:
:
Path
:
mPath
.
~
PathData
(
)
;
break
;
case
Type
:
:
Ray
:
mRay
.
~
RayData
(
)
;
break
;
default
:
break
;
}
}
OffsetPathData
(
const
OffsetPathData
&
aOther
)
:
mType
(
aOther
.
mType
)
{
switch
(
mType
)
{
case
Type
:
:
Path
:
mPath
=
aOther
.
mPath
;
break
;
case
Type
:
:
Ray
:
mRay
=
aOther
.
mRay
;
break
;
default
:
break
;
}
}
OffsetPathData
(
OffsetPathData
&
&
aOther
)
:
mType
(
aOther
.
mType
)
{
switch
(
mType
)
{
case
Type
:
:
Path
:
mPath
=
std
:
:
move
(
aOther
.
mPath
)
;
break
;
case
Type
:
:
Ray
:
mRay
=
std
:
:
move
(
aOther
.
mRay
)
;
break
;
default
:
break
;
}
}
private
:
OffsetPathData
(
)
:
mType
(
Type
:
:
None
)
{
}
OffsetPathData
(
already_AddRefed
<
gfx
:
:
Path
>
&
&
aPath
bool
aIsClosed
)
:
mType
(
Type
:
:
Path
)
mPath
{
std
:
:
move
(
aPath
)
aIsClosed
}
{
}
OffsetPathData
(
const
RayFunction
*
aRay
RayReferenceData
&
&
aRef
)
:
mType
(
Type
:
:
Ray
)
mRay
{
aRay
std
:
:
move
(
aRef
)
}
{
}
OffsetPathData
(
const
RayFunction
*
aRay
const
RayReferenceData
&
aRef
)
:
mType
(
Type
:
:
Ray
)
mRay
{
aRay
aRef
}
{
}
OffsetPathData
&
operator
=
(
const
OffsetPathData
&
)
=
delete
;
OffsetPathData
&
operator
=
(
OffsetPathData
&
&
)
=
delete
;
}
;
class
MotionPathUtils
final
{
using
TransformReferenceBox
=
nsStyleTransformMatrix
:
:
TransformReferenceBox
;
public
:
static
CSSPoint
ComputeAnchorPointAdjustment
(
const
nsIFrame
&
aFrame
)
;
static
Maybe
<
ResolvedMotionPathData
>
ResolveMotionPath
(
const
OffsetPathData
&
aPath
const
LengthPercentage
&
aDistance
const
StyleOffsetRotate
&
aRotate
const
StylePositionOrAuto
&
aAnchor
const
CSSPoint
&
aTransformOrigin
TransformReferenceBox
&
const
CSSPoint
&
aAnchorPointAdjustment
)
;
static
Maybe
<
ResolvedMotionPathData
>
ResolveMotionPath
(
const
nsIFrame
*
aFrame
TransformReferenceBox
&
)
;
static
Maybe
<
ResolvedMotionPathData
>
ResolveMotionPath
(
const
StyleOffsetPath
*
aPath
const
StyleLengthPercentage
*
aDistance
const
StyleOffsetRotate
*
aRotate
const
StylePositionOrAuto
*
aAnchor
const
Maybe
<
layers
:
:
MotionPathData
>
&
aMotionPathData
TransformReferenceBox
&
gfx
:
:
Path
*
aCachedMotionPath
)
;
static
StyleSVGPathData
NormalizeSVGPathData
(
const
StyleSVGPathData
&
aPath
)
;
static
already_AddRefed
<
gfx
:
:
Path
>
BuildPath
(
const
StyleSVGPathData
&
aPath
gfx
:
:
PathBuilder
*
aPathBuilder
)
;
static
already_AddRefed
<
gfx
:
:
PathBuilder
>
GetCompositorPathBuilder
(
)
;
}
;
}
#
endif
