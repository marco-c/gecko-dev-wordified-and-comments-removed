#
include
"
mozilla
/
ServoRestyleManager
.
h
"
#
include
"
mozilla
/
AutoRestyleTimelineMarker
.
h
"
#
include
"
mozilla
/
AutoTimelineMarker
.
h
"
#
include
"
mozilla
/
DocumentStyleRootIterator
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
mozilla
/
ServoStyleContext
.
h
"
#
include
"
mozilla
/
ServoStyleContextInlines
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
ViewportFrame
.
h
"
#
include
"
mozilla
/
dom
/
ChildIterator
.
h
"
#
include
"
mozilla
/
dom
/
ElementInlines
.
h
"
#
include
"
nsBlockFrame
.
h
"
#
include
"
nsBulletFrame
.
h
"
#
include
"
nsPlaceholderFrame
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsRefreshDriver
.
h
"
#
include
"
nsStyleChangeList
.
h
"
using
namespace
mozilla
:
:
dom
;
namespace
mozilla
{
#
ifdef
DEBUG
static
bool
IsAnonBox
(
const
nsIFrame
&
aFrame
)
{
return
aFrame
.
StyleContext
(
)
-
>
IsAnonBox
(
)
;
}
static
const
nsIFrame
*
FirstContinuationOrPartOfIBSplit
(
const
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
)
{
return
nullptr
;
}
return
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
aFrame
)
;
}
static
const
nsIFrame
*
ExpectedOwnerForChild
(
const
nsIFrame
&
aFrame
)
{
if
(
IsAnonBox
(
aFrame
)
&
&
!
aFrame
.
IsTextFrame
(
)
)
{
return
aFrame
.
GetParent
(
)
-
>
IsViewportFrame
(
)
?
nullptr
:
aFrame
.
GetParent
(
)
;
}
if
(
aFrame
.
IsBulletFrame
(
)
)
{
return
aFrame
.
GetParent
(
)
;
}
if
(
aFrame
.
IsLineFrame
(
)
)
{
return
aFrame
.
GetParent
(
)
;
}
const
nsIFrame
*
parent
=
FirstContinuationOrPartOfIBSplit
(
aFrame
.
GetParent
(
)
)
;
if
(
aFrame
.
IsTableFrame
(
)
)
{
MOZ_ASSERT
(
parent
-
>
IsTableWrapperFrame
(
)
)
;
parent
=
FirstContinuationOrPartOfIBSplit
(
parent
-
>
GetParent
(
)
)
;
}
while
(
parent
&
&
(
IsAnonBox
(
*
parent
)
|
|
parent
-
>
IsLineFrame
(
)
)
)
{
auto
*
pseudo
=
parent
-
>
StyleContext
(
)
-
>
GetPseudo
(
)
;
if
(
pseudo
=
=
nsCSSAnonBoxes
:
:
tableWrapper
)
{
const
nsIFrame
*
tableFrame
=
parent
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
MOZ_ASSERT
(
tableFrame
-
>
IsTableFrame
(
)
)
;
parent
=
IsAnonBox
(
*
tableFrame
)
?
parent
-
>
GetParent
(
)
:
tableFrame
;
}
else
{
parent
=
parent
-
>
GetParent
(
)
;
}
parent
=
FirstContinuationOrPartOfIBSplit
(
parent
)
;
}
return
parent
;
}
void
ServoRestyleState
:
:
AssertOwner
(
const
ServoRestyleState
&
aParent
)
const
{
MOZ_ASSERT
(
mOwner
)
;
MOZ_ASSERT
(
!
mOwner
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
)
;
MOZ_ASSERT_IF
(
aParent
.
mOwner
ExpectedOwnerForChild
(
*
mOwner
)
=
=
aParent
.
mOwner
)
;
}
nsChangeHint
ServoRestyleState
:
:
ChangesHandledFor
(
const
nsIFrame
&
aFrame
)
const
{
if
(
!
mOwner
)
{
MOZ_ASSERT
(
!
mChangesHandled
)
;
return
mChangesHandled
;
}
MOZ_ASSERT
(
mOwner
=
=
ExpectedOwnerForChild
(
aFrame
)
"
Missed
some
frame
in
the
hierarchy
?
"
)
;
return
mChangesHandled
;
}
#
endif
ServoRestyleManager
:
:
ServoRestyleManager
(
nsPresContext
*
aPresContext
)
:
RestyleManager
(
StyleBackendType
:
:
Servo
aPresContext
)
mReentrantChanges
(
nullptr
)
{
}
void
ServoRestyleManager
:
:
PostRestyleEvent
(
Element
*
aElement
nsRestyleHint
aRestyleHint
nsChangeHint
aMinChangeHint
)
{
MOZ_ASSERT
(
!
(
aMinChangeHint
&
nsChangeHint_NeutralChange
)
"
Didn
'
t
expect
explicit
change
hints
to
be
neutral
!
"
)
;
if
(
MOZ_UNLIKELY
(
IsDisconnected
(
)
)
|
|
MOZ_UNLIKELY
(
PresContext
(
)
-
>
PresShell
(
)
-
>
IsDestroying
(
)
)
)
{
return
;
}
MOZ_ASSERT
(
!
ServoStyleSet
:
:
IsInServoTraversal
(
)
)
;
if
(
aRestyleHint
=
=
0
&
&
!
aMinChangeHint
)
{
return
;
}
if
(
aRestyleHint
)
{
IncrementUndisplayedRestyleGeneration
(
)
;
}
if
(
mReentrantChanges
&
&
!
aRestyleHint
)
{
mReentrantChanges
-
>
AppendElement
(
ReentrantChange
{
aElement
aMinChangeHint
}
)
;
return
;
}
if
(
aRestyleHint
&
~
eRestyle_AllHintsWithAnimations
)
{
mHaveNonAnimationRestyles
=
true
;
}
if
(
aRestyleHint
&
eRestyle_LaterSiblings
)
{
aRestyleHint
&
=
~
eRestyle_LaterSiblings
;
nsRestyleHint
siblingHint
=
eRestyle_Subtree
;
Element
*
current
=
aElement
-
>
GetNextElementSibling
(
)
;
while
(
current
)
{
Servo_NoteExplicitHints
(
current
siblingHint
nsChangeHint
(
0
)
)
;
current
=
current
-
>
GetNextElementSibling
(
)
;
}
}
if
(
aRestyleHint
|
|
aMinChangeHint
)
{
Servo_NoteExplicitHints
(
aElement
aRestyleHint
aMinChangeHint
)
;
}
}
void
ServoRestyleManager
:
:
PostRestyleEventForCSSRuleChanges
(
)
{
mRestyleForCSSRuleChanges
=
true
;
mPresContext
-
>
PresShell
(
)
-
>
EnsureStyleFlush
(
)
;
}
void
ServoRestyleManager
:
:
PostRestyleEventForAnimations
(
Element
*
aElement
CSSPseudoElementType
aPseudoType
nsRestyleHint
aRestyleHint
)
{
Element
*
elementToRestyle
=
EffectCompositor
:
:
GetElementToRestyle
(
aElement
aPseudoType
)
;
if
(
!
elementToRestyle
)
{
return
;
}
Servo_NoteExplicitHints
(
elementToRestyle
aRestyleHint
nsChangeHint
(
0
)
)
;
}
void
ServoRestyleManager
:
:
RebuildAllStyleData
(
nsChangeHint
aExtraHint
nsRestyleHint
aRestyleHint
)
{
PostRebuildAllStyleDataEvent
(
aExtraHint
aRestyleHint
)
;
}
void
ServoRestyleManager
:
:
PostRebuildAllStyleDataEvent
(
nsChangeHint
aExtraHint
nsRestyleHint
aRestyleHint
)
{
StyleSet
(
)
-
>
ClearCachedStyleData
(
)
;
DocumentStyleRootIterator
iter
(
mPresContext
-
>
Document
(
)
)
;
while
(
Element
*
root
=
iter
.
GetNextStyleRoot
(
)
)
{
PostRestyleEvent
(
root
aRestyleHint
aExtraHint
)
;
}
}
void
ServoRestyleManager
:
:
ClearServoDataFromSubtree
(
Element
*
aElement
)
{
if
(
!
aElement
-
>
HasServoData
(
)
)
{
MOZ_ASSERT
(
!
aElement
-
>
HasDirtyDescendantsForServo
(
)
)
;
MOZ_ASSERT
(
!
aElement
-
>
HasAnimationOnlyDirtyDescendantsForServo
(
)
)
;
return
;
}
StyleChildrenIterator
it
(
aElement
)
;
for
(
nsIContent
*
n
=
it
.
GetNextChild
(
)
;
n
;
n
=
it
.
GetNextChild
(
)
)
{
if
(
n
-
>
IsElement
(
)
)
{
ClearServoDataFromSubtree
(
n
-
>
AsElement
(
)
)
;
}
}
aElement
-
>
ClearServoData
(
)
;
}
void
ServoRestyleManager
:
:
ClearRestyleStateFromSubtree
(
Element
*
aElement
)
{
if
(
aElement
-
>
HasDirtyDescendantsForServo
(
)
|
|
aElement
-
>
HasAnimationOnlyDirtyDescendantsForServo
(
)
)
{
StyleChildrenIterator
it
(
aElement
)
;
for
(
nsIContent
*
n
=
it
.
GetNextChild
(
)
;
n
;
n
=
it
.
GetNextChild
(
)
)
{
if
(
n
-
>
IsElement
(
)
)
{
ClearRestyleStateFromSubtree
(
n
-
>
AsElement
(
)
)
;
}
}
}
bool
wasRestyled
;
Unused
<
<
Servo_TakeChangeHint
(
aElement
ServoTraversalFlags
:
:
Empty
&
wasRestyled
)
;
aElement
-
>
UnsetHasDirtyDescendantsForServo
(
)
;
aElement
-
>
UnsetHasAnimationOnlyDirtyDescendantsForServo
(
)
;
aElement
-
>
UnsetFlags
(
NODE_DESCENDANTS_NEED_FRAMES
)
;
}
struct
ServoRestyleManager
:
:
TextPostTraversalState
{
public
:
TextPostTraversalState
(
ServoStyleContext
&
aParentContext
bool
aDisplayContentsParentStyleChanged
ServoRestyleState
&
aParentRestyleState
)
:
mParentContext
(
aParentContext
)
mParentRestyleState
(
aParentRestyleState
)
mStyle
(
nullptr
)
mShouldPostHints
(
aDisplayContentsParentStyleChanged
)
mShouldComputeHints
(
aDisplayContentsParentStyleChanged
)
mComputedHint
(
nsChangeHint_Empty
)
{
}
nsStyleChangeList
&
ChangeList
(
)
{
return
mParentRestyleState
.
ChangeList
(
)
;
}
nsStyleContext
&
ComputeStyle
(
nsIContent
*
aTextNode
)
{
if
(
!
mStyle
)
{
mStyle
=
mParentRestyleState
.
StyleSet
(
)
.
ResolveStyleForText
(
aTextNode
&
mParentContext
)
;
}
MOZ_ASSERT
(
mStyle
)
;
return
*
mStyle
;
}
void
ComputeHintIfNeeded
(
nsIContent
*
aContent
nsIFrame
*
aTextFrame
nsStyleContext
&
aNewContext
)
{
MOZ_ASSERT
(
aTextFrame
)
;
MOZ_ASSERT
(
aNewContext
.
GetPseudo
(
)
=
=
nsCSSAnonBoxes
:
:
mozText
)
;
if
(
MOZ_LIKELY
(
!
mShouldPostHints
)
)
{
return
;
}
ServoStyleContext
*
oldContext
=
aTextFrame
-
>
StyleContext
(
)
-
>
AsServo
(
)
;
MOZ_ASSERT
(
oldContext
-
>
GetPseudo
(
)
=
=
nsCSSAnonBoxes
:
:
mozText
)
;
if
(
mShouldComputeHints
)
{
mShouldComputeHints
=
false
;
uint32_t
equalStructs
samePointerStructs
;
mComputedHint
=
oldContext
-
>
CalcStyleDifference
(
&
aNewContext
&
equalStructs
&
samePointerStructs
)
;
mComputedHint
=
NS_RemoveSubsumedHints
(
mComputedHint
mParentRestyleState
.
ChangesHandledFor
(
*
aTextFrame
)
)
;
}
if
(
mComputedHint
)
{
mParentRestyleState
.
ChangeList
(
)
.
AppendChange
(
aTextFrame
aContent
mComputedHint
)
;
}
}
private
:
ServoStyleContext
&
mParentContext
;
ServoRestyleState
&
mParentRestyleState
;
RefPtr
<
nsStyleContext
>
mStyle
;
bool
mShouldPostHints
;
bool
mShouldComputeHints
;
nsChangeHint
mComputedHint
;
}
;
static
nsBlockFrame
*
GetBlockForElement
(
const
Element
*
aElement
)
{
nsIFrame
*
frame
=
aElement
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
)
{
return
nullptr
;
}
frame
=
frame
-
>
GetContentInsertionFrame
(
)
;
if
(
!
frame
)
{
return
nullptr
;
}
if
(
!
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eBlockFrame
)
)
{
return
nullptr
;
}
return
static_cast
<
nsBlockFrame
*
>
(
frame
)
;
}
static
nsIFrame
*
FindFirstLetterFrameForElement
(
const
Element
*
aElement
)
{
nsBlockFrame
*
f
=
GetBlockForElement
(
aElement
)
;
return
f
?
f
-
>
GetFirstLetter
(
)
:
nullptr
;
}
static
nsIFrame
*
FindFirstLineFrameForElement
(
const
Element
*
aElement
)
{
nsBlockFrame
*
f
=
GetBlockForElement
(
aElement
)
;
return
f
?
f
-
>
GetFirstLineFrame
(
)
:
nullptr
;
}
static
void
UpdateBackdropIfNeeded
(
nsIFrame
*
aFrame
ServoStyleSet
&
aStyleSet
nsStyleChangeList
&
aChangeList
)
{
const
nsStyleDisplay
*
display
=
aFrame
-
>
StyleContext
(
)
-
>
StyleDisplay
(
)
;
if
(
display
-
>
mTopLayer
!
=
NS_STYLE_TOP_LAYER_TOP
)
{
return
;
}
MOZ_ASSERT
(
display
-
>
IsAbsolutelyPositionedStyle
(
)
)
;
nsIFrame
*
backdropPlaceholder
=
aFrame
-
>
GetChildList
(
nsIFrame
:
:
kBackdropList
)
.
FirstChild
(
)
;
if
(
!
backdropPlaceholder
)
{
return
;
}
MOZ_ASSERT
(
backdropPlaceholder
-
>
IsPlaceholderFrame
(
)
)
;
nsIFrame
*
backdropFrame
=
nsPlaceholderFrame
:
:
GetRealFrameForPlaceholder
(
backdropPlaceholder
)
;
MOZ_ASSERT
(
backdropFrame
-
>
IsBackdropFrame
(
)
)
;
MOZ_ASSERT
(
backdropFrame
-
>
StyleContext
(
)
-
>
GetPseudoType
(
)
=
=
CSSPseudoElementType
:
:
backdrop
)
;
RefPtr
<
nsStyleContext
>
newContext
=
aStyleSet
.
ResolvePseudoElementStyle
(
aFrame
-
>
GetContent
(
)
-
>
AsElement
(
)
CSSPseudoElementType
:
:
backdrop
aFrame
-
>
StyleContext
(
)
-
>
AsServo
(
)
nullptr
)
;
MOZ_ASSERT
(
backdropFrame
-
>
GetParent
(
)
-
>
IsViewportFrame
(
)
)
;
ServoRestyleState
state
(
aStyleSet
aChangeList
)
;
aFrame
-
>
UpdateStyleOfOwnedChildFrame
(
backdropFrame
newContext
state
)
;
}
static
void
UpdateFirstLetterIfNeeded
(
nsIFrame
*
aFrame
ServoRestyleState
&
aRestyleState
)
{
if
(
!
aFrame
-
>
HasFirstLetterChild
(
)
)
{
return
;
}
nsIFrame
*
block
=
aFrame
;
while
(
!
block
-
>
IsFrameOfType
(
nsIFrame
:
:
eBlockFrame
)
)
{
block
=
block
-
>
GetParent
(
)
;
}
static_cast
<
nsBlockFrame
*
>
(
block
-
>
FirstContinuation
(
)
)
-
>
UpdateFirstLetterStyle
(
aRestyleState
)
;
}
static
void
UpdateOneAdditionalStyleContext
(
nsIFrame
*
aFrame
uint32_t
aIndex
ServoStyleContext
&
aOldContext
ServoRestyleState
&
aRestyleState
)
{
auto
pseudoType
=
aOldContext
.
GetPseudoType
(
)
;
MOZ_ASSERT
(
pseudoType
!
=
CSSPseudoElementType
:
:
NotPseudo
)
;
MOZ_ASSERT
(
!
nsCSSPseudoElements
:
:
PseudoElementSupportsUserActionState
(
pseudoType
)
)
;
RefPtr
<
ServoStyleContext
>
newContext
=
aRestyleState
.
StyleSet
(
)
.
ResolvePseudoElementStyle
(
aFrame
-
>
GetContent
(
)
-
>
AsElement
(
)
pseudoType
aFrame
-
>
StyleContext
(
)
-
>
AsServo
(
)
nullptr
)
;
uint32_t
equalStructs
samePointerStructs
;
nsChangeHint
childHint
=
aOldContext
.
CalcStyleDifference
(
newContext
&
equalStructs
&
samePointerStructs
)
;
if
(
!
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
)
{
childHint
=
NS_RemoveSubsumedHints
(
childHint
aRestyleState
.
ChangesHandledFor
(
*
aFrame
)
)
;
}
if
(
childHint
)
{
aRestyleState
.
ChangeList
(
)
.
AppendChange
(
aFrame
aFrame
-
>
GetContent
(
)
childHint
)
;
}
aFrame
-
>
SetAdditionalStyleContext
(
aIndex
newContext
)
;
}
static
void
UpdateAdditionalStyleContexts
(
nsIFrame
*
aFrame
ServoRestyleState
&
aRestyleState
)
{
MOZ_ASSERT
(
aFrame
)
;
MOZ_ASSERT
(
aFrame
-
>
GetContent
(
)
&
&
aFrame
-
>
GetContent
(
)
-
>
IsElement
(
)
)
;
uint32_t
index
=
0
;
while
(
auto
*
oldContext
=
aFrame
-
>
GetAdditionalStyleContext
(
index
)
)
{
UpdateOneAdditionalStyleContext
(
aFrame
index
+
+
*
oldContext
-
>
AsServo
(
)
aRestyleState
)
;
}
}
static
void
UpdateFramePseudoElementStyles
(
nsIFrame
*
aFrame
ServoRestyleState
&
aRestyleState
)
{
UpdateFirstLetterIfNeeded
(
aFrame
aRestyleState
)
;
if
(
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eBlockFrame
)
)
{
static_cast
<
nsBlockFrame
*
>
(
aFrame
)
-
>
UpdatePseudoElementStyles
(
aRestyleState
)
;
}
UpdateBackdropIfNeeded
(
aFrame
aRestyleState
.
StyleSet
(
)
aRestyleState
.
ChangeList
(
)
)
;
}
static
inline
bool
NeedsToTraverseElementChildren
(
const
Element
&
aParent
ServoTraversalFlags
aFlags
)
{
if
(
aParent
.
HasAnimationOnlyDirtyDescendantsForServo
(
)
)
{
return
true
;
}
if
(
!
(
aFlags
&
ServoTraversalFlags
:
:
AnimationOnly
)
)
{
return
aParent
.
HasDirtyDescendantsForServo
(
)
|
|
aParent
.
HasFlag
(
NODE_DESCENDANTS_NEED_FRAMES
)
;
}
return
false
;
}
bool
ServoRestyleManager
:
:
ProcessPostTraversal
(
Element
*
aElement
ServoStyleContext
*
aParentContext
ServoRestyleState
&
aRestyleState
ServoTraversalFlags
aFlags
)
{
nsIFrame
*
styleFrame
=
nsLayoutUtils
:
:
GetStyleFrame
(
aElement
)
;
const
bool
isOutOfFlow
=
aElement
-
>
GetPrimaryFrame
(
)
&
&
aElement
-
>
GetPrimaryFrame
(
)
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
;
bool
wasRestyled
;
nsChangeHint
changeHint
=
Servo_TakeChangeHint
(
aElement
aFlags
&
wasRestyled
)
;
if
(
styleFrame
&
&
styleFrame
-
>
GetContent
(
)
!
=
aElement
)
{
MOZ_ASSERT
(
styleFrame
-
>
IsImageFrame
(
)
)
;
styleFrame
=
nullptr
;
}
if
(
aElement
-
>
HasFlag
(
NODE_NEEDS_FRAME
)
)
{
changeHint
|
=
nsChangeHint_ReconstructFrame
;
MOZ_ASSERT
(
!
styleFrame
)
;
}
if
(
styleFrame
&
&
!
isOutOfFlow
)
{
changeHint
=
NS_RemoveSubsumedHints
(
changeHint
aRestyleState
.
ChangesHandledFor
(
*
styleFrame
)
)
;
}
if
(
(
styleFrame
|
|
(
changeHint
&
nsChangeHint_ReconstructFrame
)
)
&
&
changeHint
)
{
aRestyleState
.
ChangeList
(
)
.
AppendChange
(
styleFrame
aElement
changeHint
)
;
}
if
(
changeHint
&
nsChangeHint_ReconstructFrame
)
{
ClearRestyleStateFromSubtree
(
aElement
)
;
return
true
;
}
RefPtr
<
ServoStyleContext
>
oldStyleContext
=
styleFrame
?
styleFrame
-
>
StyleContext
(
)
-
>
AsServo
(
)
:
nullptr
;
nsStyleContext
*
displayContentsStyle
=
nullptr
;
if
(
!
oldStyleContext
)
{
displayContentsStyle
=
PresContext
(
)
-
>
FrameConstructor
(
)
-
>
GetDisplayContentsStyleFor
(
aElement
)
;
if
(
displayContentsStyle
)
{
oldStyleContext
=
displayContentsStyle
-
>
AsServo
(
)
;
}
}
Maybe
<
ServoRestyleState
>
thisFrameRestyleState
;
if
(
styleFrame
)
{
auto
type
=
isOutOfFlow
?
ServoRestyleState
:
:
Type
:
:
OutOfFlow
:
ServoRestyleState
:
:
Type
:
:
InFlow
;
thisFrameRestyleState
.
emplace
(
*
styleFrame
aRestyleState
changeHint
type
)
;
}
ServoRestyleState
&
childrenRestyleState
=
thisFrameRestyleState
?
*
thisFrameRestyleState
:
aRestyleState
;
RefPtr
<
ServoStyleContext
>
newContext
=
nullptr
;
if
(
wasRestyled
&
&
oldStyleContext
)
{
MOZ_ASSERT
(
styleFrame
|
|
displayContentsStyle
)
;
newContext
=
aRestyleState
.
StyleSet
(
)
.
ResolveServoStyle
(
aElement
aFlags
)
;
MOZ_ASSERT
(
oldStyleContext
-
>
ComputedData
(
)
!
=
newContext
-
>
ComputedData
(
)
)
;
newContext
-
>
ResolveSameStructsAs
(
oldStyleContext
)
;
for
(
nsIFrame
*
f
=
styleFrame
;
f
;
f
=
f
-
>
GetNextContinuation
(
)
)
{
MOZ_ASSERT_IF
(
f
!
=
styleFrame
!
f
-
>
GetAdditionalStyleContext
(
0
)
)
;
f
-
>
SetStyleContext
(
newContext
)
;
}
if
(
MOZ_UNLIKELY
(
displayContentsStyle
)
)
{
MOZ_ASSERT
(
!
styleFrame
)
;
PresContext
(
)
-
>
FrameConstructor
(
)
-
>
ChangeRegisteredDisplayContentsStyleFor
(
aElement
newContext
)
;
}
if
(
styleFrame
)
{
UpdateAdditionalStyleContexts
(
styleFrame
aRestyleState
)
;
styleFrame
-
>
UpdateStyleOfOwnedAnonBoxes
(
childrenRestyleState
)
;
}
if
(
!
aElement
-
>
GetParent
(
)
)
{
ViewportFrame
*
viewport
=
do_QueryFrame
(
mPresContext
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
)
;
if
(
viewport
)
{
viewport
-
>
UpdateStyle
(
aRestyleState
)
;
}
}
AddLayerChangesForAnimation
(
styleFrame
aElement
aRestyleState
.
ChangeList
(
)
)
;
}
const
bool
traverseElementChildren
=
NeedsToTraverseElementChildren
(
*
aElement
aFlags
)
;
const
bool
descendantsNeedFrames
=
aElement
-
>
HasFlag
(
NODE_DESCENDANTS_NEED_FRAMES
)
;
const
bool
forThrottledAnimationFlush
=
!
!
(
aFlags
&
ServoTraversalFlags
:
:
AnimationOnly
)
;
const
bool
traverseTextChildren
=
wasRestyled
|
|
(
!
forThrottledAnimationFlush
&
&
descendantsNeedFrames
)
;
bool
recreatedAnyContext
=
wasRestyled
;
if
(
traverseElementChildren
|
|
traverseTextChildren
)
{
ServoStyleContext
*
upToDateContext
=
wasRestyled
?
newContext
:
oldStyleContext
;
StyleChildrenIterator
it
(
aElement
)
;
TextPostTraversalState
textState
(
*
upToDateContext
displayContentsStyle
&
&
wasRestyled
childrenRestyleState
)
;
for
(
nsIContent
*
n
=
it
.
GetNextChild
(
)
;
n
;
n
=
it
.
GetNextChild
(
)
)
{
if
(
traverseElementChildren
&
&
n
-
>
IsElement
(
)
)
{
recreatedAnyContext
|
=
ProcessPostTraversal
(
n
-
>
AsElement
(
)
upToDateContext
childrenRestyleState
aFlags
)
;
}
else
if
(
traverseTextChildren
&
&
n
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
{
recreatedAnyContext
|
=
ProcessPostTraversalForText
(
n
textState
)
;
}
}
}
if
(
styleFrame
)
{
if
(
wasRestyled
)
{
UpdateFramePseudoElementStyles
(
styleFrame
childrenRestyleState
)
;
}
else
if
(
traverseElementChildren
&
&
styleFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eBlockFrame
)
)
{
nsIFrame
*
firstLineFrame
=
static_cast
<
nsBlockFrame
*
>
(
styleFrame
)
-
>
GetFirstLineFrame
(
)
;
if
(
firstLineFrame
)
{
for
(
nsIFrame
*
kid
:
firstLineFrame
-
>
PrincipalChildList
(
)
)
{
ReparentStyleContext
(
kid
)
;
}
}
}
}
if
(
!
forThrottledAnimationFlush
)
{
aElement
-
>
UnsetHasDirtyDescendantsForServo
(
)
;
aElement
-
>
UnsetFlags
(
NODE_DESCENDANTS_NEED_FRAMES
)
;
}
aElement
-
>
UnsetHasAnimationOnlyDirtyDescendantsForServo
(
)
;
return
recreatedAnyContext
;
}
bool
ServoRestyleManager
:
:
ProcessPostTraversalForText
(
nsIContent
*
aTextNode
TextPostTraversalState
&
aPostTraversalState
)
{
if
(
aTextNode
-
>
HasFlag
(
NODE_NEEDS_FRAME
)
)
{
aPostTraversalState
.
ChangeList
(
)
.
AppendChange
(
nullptr
aTextNode
nsChangeHint_ReconstructFrame
)
;
return
true
;
}
nsIFrame
*
primaryFrame
=
aTextNode
-
>
GetPrimaryFrame
(
)
;
if
(
!
primaryFrame
)
{
return
false
;
}
nsStyleContext
&
newContext
=
aPostTraversalState
.
ComputeStyle
(
aTextNode
)
;
aPostTraversalState
.
ComputeHintIfNeeded
(
aTextNode
primaryFrame
newContext
)
;
for
(
nsIFrame
*
f
=
primaryFrame
;
f
;
f
=
f
-
>
GetNextContinuation
(
)
)
{
f
-
>
SetStyleContext
(
&
newContext
)
;
}
return
true
;
}
void
ServoRestyleManager
:
:
ClearSnapshots
(
)
{
for
(
auto
iter
=
mSnapshots
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
iter
.
Key
(
)
-
>
UnsetFlags
(
ELEMENT_HAS_SNAPSHOT
|
ELEMENT_HANDLED_SNAPSHOT
)
;
iter
.
Remove
(
)
;
}
}
ServoElementSnapshot
&
ServoRestyleManager
:
:
SnapshotFor
(
Element
*
aElement
)
{
MOZ_ASSERT
(
!
mInStyleRefresh
)
;
MOZ_ASSERT
(
aElement
-
>
HasServoData
(
)
)
;
MOZ_ASSERT
(
!
aElement
-
>
HasFlag
(
ELEMENT_HANDLED_SNAPSHOT
)
)
;
ServoElementSnapshot
*
snapshot
=
mSnapshots
.
LookupOrAdd
(
aElement
aElement
)
;
aElement
-
>
SetFlags
(
ELEMENT_HAS_SNAPSHOT
)
;
nsIPresShell
*
presShell
=
mPresContext
-
>
PresShell
(
)
;
presShell
-
>
EnsureStyleFlush
(
)
;
return
*
snapshot
;
}
nsIFrame
*
ServoRestyleManager
:
:
FrameForPseudoElement
(
const
Element
*
aElement
nsIAtom
*
aPseudoTagOrNull
)
{
if
(
!
aPseudoTagOrNull
)
{
return
nsLayoutUtils
:
:
GetStyleFrame
(
aElement
)
;
}
if
(
aPseudoTagOrNull
=
=
nsCSSPseudoElements
:
:
before
)
{
Element
*
pseudoElement
=
nsLayoutUtils
:
:
GetBeforePseudo
(
aElement
)
;
return
pseudoElement
?
nsLayoutUtils
:
:
GetStyleFrame
(
pseudoElement
)
:
nullptr
;
}
if
(
aPseudoTagOrNull
=
=
nsCSSPseudoElements
:
:
after
)
{
Element
*
pseudoElement
=
nsLayoutUtils
:
:
GetAfterPseudo
(
aElement
)
;
return
pseudoElement
?
nsLayoutUtils
:
:
GetStyleFrame
(
pseudoElement
)
:
nullptr
;
}
if
(
aPseudoTagOrNull
=
=
nsCSSPseudoElements
:
:
firstLetter
)
{
return
FindFirstLetterFrameForElement
(
aElement
)
;
}
if
(
aPseudoTagOrNull
=
=
nsCSSPseudoElements
:
:
firstLine
)
{
return
FindFirstLineFrameForElement
(
aElement
)
;
}
MOZ_CRASH
(
"
Unkown
pseudo
-
element
given
to
"
"
ServoRestyleManager
:
:
FrameForPseudoElement
"
)
;
return
nullptr
;
}
void
ServoRestyleManager
:
:
DoProcessPendingRestyles
(
ServoTraversalFlags
aFlags
)
{
MOZ_ASSERT
(
PresContext
(
)
-
>
Document
(
)
"
No
document
?
Pshaw
!
"
)
;
MOZ_ASSERT
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
Missing
a
script
blocker
!
"
)
;
MOZ_ASSERT
(
!
mInStyleRefresh
"
Reentrant
call
?
"
)
;
if
(
MOZ_UNLIKELY
(
!
PresContext
(
)
-
>
PresShell
(
)
-
>
DidInitialize
(
)
)
)
{
return
;
}
AnimationsWithDestroyedFrame
animationsWithDestroyedFrame
(
this
)
;
ServoStyleSet
*
styleSet
=
StyleSet
(
)
;
nsIDocument
*
doc
=
PresContext
(
)
-
>
Document
(
)
;
bool
forThrottledAnimationFlush
=
!
!
(
aFlags
&
ServoTraversalFlags
:
:
AnimationOnly
)
;
PresContext
(
)
-
>
RefreshDriver
(
)
-
>
MostRecentRefresh
(
)
;
mInStyleRefresh
=
true
;
if
(
mHaveNonAnimationRestyles
&
&
!
forThrottledAnimationFlush
)
{
+
+
mAnimationGeneration
;
}
if
(
mRestyleForCSSRuleChanges
)
{
aFlags
|
=
ServoTraversalFlags
:
:
ForCSSRuleChanges
;
}
while
(
styleSet
-
>
StyleDocument
(
aFlags
)
)
{
if
(
!
forThrottledAnimationFlush
)
{
ClearSnapshots
(
)
;
}
nsStyleChangeList
currentChanges
(
StyleBackendType
:
:
Servo
)
;
bool
anyStyleChanged
=
false
;
{
AutoRestyleTimelineMarker
marker
(
mPresContext
-
>
GetDocShell
(
)
forThrottledAnimationFlush
)
;
DocumentStyleRootIterator
iter
(
doc
)
;
while
(
Element
*
root
=
iter
.
GetNextStyleRoot
(
)
)
{
ServoRestyleState
state
(
*
styleSet
currentChanges
)
;
anyStyleChanged
|
=
ProcessPostTraversal
(
root
nullptr
state
aFlags
)
;
}
}
{
AutoTimelineMarker
marker
(
mPresContext
-
>
GetDocShell
(
)
"
StylesApplyChanges
"
)
;
ReentrantChangeList
newChanges
;
mReentrantChanges
=
&
newChanges
;
while
(
!
currentChanges
.
IsEmpty
(
)
)
{
ProcessRestyledFrames
(
currentChanges
)
;
MOZ_ASSERT
(
currentChanges
.
IsEmpty
(
)
)
;
for
(
ReentrantChange
&
change
:
newChanges
)
{
if
(
!
(
change
.
mHint
&
nsChangeHint_ReconstructFrame
)
&
&
!
change
.
mContent
-
>
GetPrimaryFrame
(
)
)
{
continue
;
}
currentChanges
.
AppendChange
(
change
.
mContent
-
>
GetPrimaryFrame
(
)
change
.
mContent
change
.
mHint
)
;
}
newChanges
.
Clear
(
)
;
}
mReentrantChanges
=
nullptr
;
}
if
(
anyStyleChanged
)
{
IncrementRestyleGeneration
(
)
;
}
}
FlushOverflowChangedTracker
(
)
;
if
(
!
forThrottledAnimationFlush
)
{
ClearSnapshots
(
)
;
styleSet
-
>
AssertTreeIsClean
(
)
;
mHaveNonAnimationRestyles
=
false
;
}
mRestyleForCSSRuleChanges
=
false
;
mInStyleRefresh
=
false
;
styleSet
-
>
MaybeGCRuleTree
(
)
;
MOZ_ASSERT
(
mAnimationsWithDestroyedFrame
)
;
mAnimationsWithDestroyedFrame
-
>
StopAnimationsForElementsWithoutFrames
(
)
;
}
void
ServoRestyleManager
:
:
ProcessPendingRestyles
(
)
{
DoProcessPendingRestyles
(
ServoTraversalFlags
:
:
Empty
)
;
}
void
ServoRestyleManager
:
:
UpdateOnlyAnimationStyles
(
)
{
bool
doCSS
=
PresContext
(
)
-
>
EffectCompositor
(
)
-
>
HasPendingStyleUpdates
(
)
;
if
(
!
doCSS
)
{
return
;
}
DoProcessPendingRestyles
(
ServoTraversalFlags
:
:
AnimationOnly
)
;
}
void
ServoRestyleManager
:
:
ContentStateChanged
(
nsIContent
*
aContent
EventStates
aChangedBits
)
{
MOZ_ASSERT
(
!
mInStyleRefresh
)
;
if
(
!
aContent
-
>
IsElement
(
)
)
{
return
;
}
Element
*
aElement
=
aContent
-
>
AsElement
(
)
;
nsChangeHint
changeHint
;
nsRestyleHint
restyleHint
;
if
(
!
aElement
-
>
HasServoData
(
)
)
{
return
;
}
ContentStateChangedInternal
(
aElement
aChangedBits
&
changeHint
&
restyleHint
)
;
if
(
!
aChangedBits
.
HasAtLeastOneOfStates
(
DIRECTION_STATES
)
&
&
!
StyleSet
(
)
-
>
HasStateDependency
(
*
aElement
aChangedBits
)
)
{
return
;
}
ServoElementSnapshot
&
snapshot
=
SnapshotFor
(
aElement
)
;
EventStates
previousState
=
aElement
-
>
StyleState
(
)
^
aChangedBits
;
snapshot
.
AddState
(
previousState
)
;
if
(
Element
*
parent
=
aElement
-
>
GetFlattenedTreeParentElementForStyle
(
)
)
{
parent
-
>
NoteDirtyDescendantsForServo
(
)
;
}
if
(
restyleHint
|
|
changeHint
)
{
Servo_NoteExplicitHints
(
aElement
restyleHint
changeHint
)
;
}
IncrementUndisplayedRestyleGeneration
(
)
;
}
static
inline
bool
AttributeInfluencesOtherPseudoClassState
(
const
Element
&
aElement
const
nsIAtom
*
aAttribute
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
mozbrowser
)
{
return
aElement
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
iframe
nsGkAtoms
:
:
frame
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
border
)
{
return
aElement
.
IsHTMLElement
(
nsGkAtoms
:
:
table
)
;
}
return
false
;
}
static
inline
bool
NeedToRecordAttrChange
(
const
ServoStyleSet
&
aStyleSet
const
Element
&
aElement
int32_t
aNameSpaceID
nsIAtom
*
aAttribute
bool
*
aInfluencesOtherPseudoClassState
)
{
*
aInfluencesOtherPseudoClassState
=
AttributeInfluencesOtherPseudoClassState
(
aElement
aAttribute
)
;
if
(
*
aInfluencesOtherPseudoClassState
)
{
return
true
;
}
if
(
aNameSpaceID
=
=
kNameSpaceID_None
&
&
(
aAttribute
=
=
nsGkAtoms
:
:
id
|
|
aAttribute
=
=
nsGkAtoms
:
:
_class
)
)
{
return
true
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
lang
)
{
return
true
;
}
return
aStyleSet
.
MightHaveAttributeDependency
(
aElement
aAttribute
)
;
}
void
ServoRestyleManager
:
:
AttributeWillChange
(
Element
*
aElement
int32_t
aNameSpaceID
nsIAtom
*
aAttribute
int32_t
aModType
const
nsAttrValue
*
aNewValue
)
{
TakeSnapshotForAttributeChange
(
aElement
aNameSpaceID
aAttribute
)
;
}
void
ServoRestyleManager
:
:
ClassAttributeWillBeChangedBySMIL
(
Element
*
aElement
)
{
TakeSnapshotForAttributeChange
(
aElement
kNameSpaceID_None
nsGkAtoms
:
:
_class
)
;
}
void
ServoRestyleManager
:
:
TakeSnapshotForAttributeChange
(
Element
*
aElement
int32_t
aNameSpaceID
nsIAtom
*
aAttribute
)
{
MOZ_ASSERT
(
!
mInStyleRefresh
)
;
if
(
!
aElement
-
>
HasServoData
(
)
)
{
return
;
}
bool
influencesOtherPseudoClassState
;
if
(
!
NeedToRecordAttrChange
(
*
StyleSet
(
)
*
aElement
aNameSpaceID
aAttribute
&
influencesOtherPseudoClassState
)
)
{
return
;
}
IncrementUndisplayedRestyleGeneration
(
)
;
mHaveNonAnimationRestyles
=
true
;
ServoElementSnapshot
&
snapshot
=
SnapshotFor
(
aElement
)
;
snapshot
.
AddAttrs
(
aElement
aNameSpaceID
aAttribute
)
;
if
(
influencesOtherPseudoClassState
)
{
snapshot
.
AddOtherPseudoClassState
(
aElement
)
;
}
if
(
Element
*
parent
=
aElement
-
>
GetFlattenedTreeParentElementForStyle
(
)
)
{
parent
-
>
NoteDirtyDescendantsForServo
(
)
;
}
}
static
inline
bool
AttributeChangeRequiresSubtreeRestyle
(
const
Element
&
aElement
nsIAtom
*
aAttr
)
{
if
(
aAttr
=
=
nsGkAtoms
:
:
cellpadding
)
{
return
aElement
.
IsHTMLElement
(
nsGkAtoms
:
:
table
)
;
}
return
aAttr
=
=
nsGkAtoms
:
:
lang
;
}
void
ServoRestyleManager
:
:
AttributeChanged
(
Element
*
aElement
int32_t
aNameSpaceID
nsIAtom
*
aAttribute
int32_t
aModType
const
nsAttrValue
*
aOldValue
)
{
MOZ_ASSERT
(
!
mInStyleRefresh
)
;
if
(
nsIFrame
*
primaryFrame
=
aElement
-
>
GetPrimaryFrame
(
)
)
{
primaryFrame
-
>
AttributeChanged
(
aNameSpaceID
aAttribute
aModType
)
;
}
auto
changeHint
=
nsChangeHint
(
0
)
;
auto
restyleHint
=
nsRestyleHint
(
0
)
;
changeHint
|
=
aElement
-
>
GetAttributeChangeHint
(
aAttribute
aModType
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
style
)
{
restyleHint
|
=
eRestyle_StyleAttribute
;
}
else
if
(
AttributeChangeRequiresSubtreeRestyle
(
*
aElement
aAttribute
)
)
{
restyleHint
|
=
eRestyle_Subtree
;
}
else
if
(
aElement
-
>
IsAttributeMapped
(
aAttribute
)
)
{
restyleHint
|
=
eRestyle_Self
;
}
if
(
restyleHint
|
|
changeHint
)
{
Servo_NoteExplicitHints
(
aElement
restyleHint
changeHint
)
;
}
if
(
restyleHint
)
{
IncrementUndisplayedRestyleGeneration
(
)
;
mHaveNonAnimationRestyles
=
true
;
}
}
nsresult
ServoRestyleManager
:
:
ReparentStyleContext
(
nsIFrame
*
aFrame
)
{
#
ifdef
DEBUG
{
nsIFrame
*
f
=
aFrame
-
>
GetParent
(
)
;
while
(
f
&
&
!
f
-
>
IsLineFrame
(
)
)
{
MOZ_ASSERT
(
f
-
>
IsInlineFrame
(
)
"
Must
only
have
inline
frames
between
us
and
the
first
-
line
"
"
frame
"
)
;
f
=
f
-
>
GetParent
(
)
;
}
MOZ_ASSERT
(
f
"
Must
have
found
a
first
-
line
frame
"
)
;
}
#
endif
DoReparentStyleContext
(
aFrame
*
StyleSet
(
)
)
;
return
NS_OK
;
}
void
ServoRestyleManager
:
:
DoReparentStyleContext
(
nsIFrame
*
aFrame
ServoStyleSet
&
aStyleSet
)
{
if
(
aFrame
-
>
IsBackdropFrame
(
)
)
{
return
;
}
if
(
aFrame
-
>
IsPlaceholderFrame
(
)
)
{
nsIFrame
*
outOfFlow
=
nsPlaceholderFrame
:
:
GetRealFrameForPlaceholder
(
aFrame
)
;
MOZ_ASSERT
(
outOfFlow
"
no
out
-
of
-
flow
frame
"
)
;
for
(
;
outOfFlow
;
outOfFlow
=
outOfFlow
-
>
GetNextContinuation
(
)
)
{
DoReparentStyleContext
(
outOfFlow
aStyleSet
)
;
}
}
nsIFrame
*
providerFrame
;
nsStyleContext
*
newParentContext
=
aFrame
-
>
GetParentStyleContext
(
&
providerFrame
)
;
if
(
!
newParentContext
)
{
#
ifdef
DEBUG
nsIFrame
:
:
ChildListIterator
lists
(
aFrame
)
;
for
(
;
!
lists
.
IsDone
(
)
;
lists
.
Next
(
)
)
{
MOZ_ASSERT
(
lists
.
CurrentList
(
)
.
IsEmpty
(
)
"
Failing
to
reparent
style
context
for
child
of
"
"
non
-
inheriting
anon
box
"
)
;
}
#
endif
return
;
}
bool
isChild
=
providerFrame
&
&
providerFrame
-
>
GetParent
(
)
=
=
aFrame
;
nsIFrame
*
providerChild
=
nullptr
;
if
(
isChild
)
{
DoReparentStyleContext
(
providerFrame
aStyleSet
)
;
newParentContext
=
providerFrame
-
>
StyleContext
(
)
;
providerChild
=
providerFrame
;
MOZ_ASSERT
(
!
providerFrame
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
"
Out
of
flow
provider
?
"
)
;
}
bool
isElement
=
aFrame
-
>
GetContent
(
)
-
>
IsElement
(
)
;
ServoStyleContext
*
oldContext
=
aFrame
-
>
StyleContext
(
)
-
>
AsServo
(
)
;
Element
*
ourElement
=
oldContext
-
>
GetPseudoType
(
)
=
=
CSSPseudoElementType
:
:
NotPseudo
&
&
isElement
?
aFrame
-
>
GetContent
(
)
-
>
AsElement
(
)
:
nullptr
;
ServoStyleContext
*
newParent
=
newParentContext
-
>
AsServo
(
)
;
ServoStyleContext
*
newParentIgnoringFirstLine
;
if
(
newParent
-
>
GetPseudoType
(
)
=
=
CSSPseudoElementType
:
:
firstLine
)
{
MOZ_ASSERT
(
providerFrame
&
&
providerFrame
-
>
GetParent
(
)
-
>
IsFrameOfType
(
nsIFrame
:
:
eBlockFrame
)
"
How
could
we
get
a
:
:
first
-
line
parent
style
without
having
"
"
a
:
:
first
-
line
provider
frame
?
"
)
;
nsIFrame
*
blockFrame
=
providerFrame
-
>
GetParent
(
)
;
nsIFrame
*
correctedFrame
=
nsFrame
:
:
CorrectStyleParentFrame
(
blockFrame
oldContext
-
>
GetPseudo
(
)
)
;
newParentIgnoringFirstLine
=
correctedFrame
-
>
StyleContext
(
)
-
>
AsServo
(
)
;
}
else
{
newParentIgnoringFirstLine
=
newParent
;
}
if
(
!
providerFrame
)
{
providerFrame
=
nsFrame
:
:
CorrectStyleParentFrame
(
aFrame
-
>
GetParent
(
)
oldContext
-
>
GetPseudo
(
)
)
;
}
ServoStyleContext
*
layoutParent
=
providerFrame
-
>
StyleContext
(
)
-
>
AsServo
(
)
;
RefPtr
<
ServoStyleContext
>
newContext
=
aStyleSet
.
ReparentStyleContext
(
oldContext
newParent
newParentIgnoringFirstLine
layoutParent
ourElement
)
;
aFrame
-
>
SetStyleContext
(
newContext
)
;
if
(
isElement
)
{
uint32_t
index
=
0
;
while
(
nsStyleContext
*
oldAdditionalContext
=
aFrame
-
>
GetAdditionalStyleContext
(
index
)
)
{
RefPtr
<
ServoStyleContext
>
newAdditionalContext
=
aStyleSet
.
ReparentStyleContext
(
oldAdditionalContext
-
>
AsServo
(
)
newContext
newContext
newContext
nullptr
)
;
aFrame
-
>
SetAdditionalStyleContext
(
index
newAdditionalContext
)
;
+
+
index
;
}
}
nsIFrame
:
:
ChildListIterator
lists
(
aFrame
)
;
for
(
;
!
lists
.
IsDone
(
)
;
lists
.
Next
(
)
)
{
for
(
nsIFrame
*
child
:
lists
.
CurrentList
(
)
)
{
if
(
!
(
child
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
&
&
child
!
=
providerChild
)
{
DoReparentStyleContext
(
child
aStyleSet
)
;
}
}
}
}
}
