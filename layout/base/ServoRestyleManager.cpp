#
include
"
mozilla
/
ServoRestyleManager
.
h
"
#
include
"
mozilla
/
AutoRestyleTimelineMarker
.
h
"
#
include
"
mozilla
/
AutoTimelineMarker
.
h
"
#
include
"
mozilla
/
DocumentStyleRootIterator
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
mozilla
/
ServoStyleContext
.
h
"
#
include
"
mozilla
/
ServoStyleContextInlines
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
mozilla
/
ViewportFrame
.
h
"
#
include
"
mozilla
/
dom
/
ChildIterator
.
h
"
#
include
"
mozilla
/
dom
/
ElementInlines
.
h
"
#
include
"
nsBlockFrame
.
h
"
#
include
"
nsBulletFrame
.
h
"
#
include
"
nsImageFrame
.
h
"
#
include
"
nsPlaceholderFrame
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
nsPrintfCString
.
h
"
#
include
"
nsRefreshDriver
.
h
"
#
include
"
nsStyleChangeList
.
h
"
#
ifdef
ACCESSIBILITY
#
include
"
nsAccessibilityService
.
h
"
#
endif
using
namespace
mozilla
:
:
dom
;
namespace
mozilla
{
#
ifdef
DEBUG
static
bool
IsAnonBox
(
const
nsIFrame
&
aFrame
)
{
return
aFrame
.
StyleContext
(
)
-
>
IsAnonBox
(
)
;
}
static
const
nsIFrame
*
FirstContinuationOrPartOfIBSplit
(
const
nsIFrame
*
aFrame
)
{
if
(
!
aFrame
)
{
return
nullptr
;
}
return
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
aFrame
)
;
}
static
const
nsIFrame
*
ExpectedOwnerForChild
(
const
nsIFrame
&
aFrame
)
{
const
nsIFrame
*
parent
=
aFrame
.
GetParent
(
)
;
if
(
aFrame
.
IsTableFrame
(
)
)
{
MOZ_ASSERT
(
parent
-
>
IsTableWrapperFrame
(
)
)
;
parent
=
parent
-
>
GetParent
(
)
;
}
if
(
IsAnonBox
(
aFrame
)
&
&
!
aFrame
.
IsTextFrame
(
)
)
{
if
(
parent
-
>
IsLineFrame
(
)
)
{
parent
=
parent
-
>
GetParent
(
)
;
}
return
parent
-
>
IsViewportFrame
(
)
?
nullptr
:
FirstContinuationOrPartOfIBSplit
(
parent
)
;
}
if
(
aFrame
.
IsBulletFrame
(
)
)
{
return
FirstContinuationOrPartOfIBSplit
(
parent
)
;
}
if
(
aFrame
.
IsLineFrame
(
)
)
{
return
parent
;
}
if
(
aFrame
.
IsLetterFrame
(
)
)
{
if
(
parent
-
>
IsLineFrame
(
)
)
{
parent
=
parent
-
>
GetParent
(
)
;
}
return
FirstContinuationOrPartOfIBSplit
(
parent
)
;
}
if
(
parent
-
>
IsLetterFrame
(
)
)
{
parent
=
parent
-
>
GetParent
(
)
;
}
parent
=
FirstContinuationOrPartOfIBSplit
(
parent
)
;
while
(
parent
&
&
(
IsAnonBox
(
*
parent
)
|
|
parent
-
>
IsLineFrame
(
)
)
)
{
auto
*
pseudo
=
parent
-
>
StyleContext
(
)
-
>
GetPseudo
(
)
;
if
(
pseudo
=
=
nsCSSAnonBoxes
:
:
tableWrapper
)
{
const
nsIFrame
*
tableFrame
=
parent
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
MOZ_ASSERT
(
tableFrame
-
>
IsTableFrame
(
)
)
;
parent
=
IsAnonBox
(
*
tableFrame
)
?
parent
-
>
GetParent
(
)
:
tableFrame
;
}
else
{
parent
=
parent
-
>
GetInFlowParent
(
)
;
}
parent
=
FirstContinuationOrPartOfIBSplit
(
parent
)
;
}
return
parent
;
}
void
ServoRestyleState
:
:
AssertOwner
(
const
ServoRestyleState
&
aParent
)
const
{
MOZ_ASSERT
(
mOwner
)
;
MOZ_ASSERT
(
!
mOwner
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
)
;
#
ifdef
DEBUG
if
(
aParent
.
mOwner
)
{
const
nsIFrame
*
owner
=
ExpectedOwnerForChild
(
*
mOwner
)
;
if
(
owner
!
=
aParent
.
mOwner
)
{
MOZ_ASSERT
(
IsAnonBox
(
*
owner
)
"
Should
only
have
expected
owner
weirdness
when
anon
boxes
are
involved
"
)
;
bool
found
=
false
;
for
(
;
owner
;
owner
=
ExpectedOwnerForChild
(
*
owner
)
)
{
if
(
owner
=
=
aParent
.
mOwner
)
{
found
=
true
;
break
;
}
}
MOZ_ASSERT
(
found
"
Must
have
aParent
.
mOwner
on
our
expected
owner
chain
"
)
;
}
}
#
endif
}
nsChangeHint
ServoRestyleState
:
:
ChangesHandledFor
(
const
nsIFrame
&
aFrame
)
const
{
if
(
!
mOwner
)
{
MOZ_ASSERT
(
!
mChangesHandled
)
;
return
mChangesHandled
;
}
MOZ_ASSERT
(
mOwner
=
=
ExpectedOwnerForChild
(
aFrame
)
"
Missed
some
frame
in
the
hierarchy
?
"
)
;
return
mChangesHandled
;
}
#
endif
void
ServoRestyleState
:
:
AddPendingWrapperRestyle
(
nsIFrame
*
aWrapperFrame
)
{
MOZ_ASSERT
(
aWrapperFrame
-
>
StyleContext
(
)
-
>
IsWrapperAnonBox
(
)
"
All
our
wrappers
are
anon
boxes
and
why
would
we
restyle
"
"
non
-
inheriting
ones
?
"
)
;
MOZ_ASSERT
(
aWrapperFrame
-
>
StyleContext
(
)
-
>
IsInheritingAnonBox
(
)
"
All
our
wrappers
are
anon
boxes
and
why
would
we
restyle
"
"
non
-
inheriting
ones
?
"
)
;
MOZ_ASSERT
(
aWrapperFrame
-
>
StyleContext
(
)
-
>
GetPseudo
(
)
!
=
nsCSSAnonBoxes
:
:
cellContent
"
Someone
should
be
using
TableAwareParentFor
"
)
;
MOZ_ASSERT
(
aWrapperFrame
-
>
StyleContext
(
)
-
>
GetPseudo
(
)
!
=
nsCSSAnonBoxes
:
:
tableWrapper
"
Someone
should
be
using
TableAwareParentFor
"
)
;
aWrapperFrame
=
aWrapperFrame
-
>
FirstContinuation
(
)
;
nsIFrame
*
last
=
mPendingWrapperRestyles
.
SafeLastElement
(
nullptr
)
;
if
(
last
=
=
aWrapperFrame
)
{
return
;
}
if
(
aWrapperFrame
-
>
ParentIsWrapperAnonBox
(
)
)
{
AddPendingWrapperRestyle
(
TableAwareParentFor
(
aWrapperFrame
)
)
;
}
if
(
mPendingWrapperRestyles
.
AppendElement
(
aWrapperFrame
fallible
)
)
{
aWrapperFrame
-
>
SetIsWrapperAnonBoxNeedingRestyle
(
true
)
;
}
}
void
ServoRestyleState
:
:
ProcessWrapperRestyles
(
nsIFrame
*
aParentFrame
)
{
size_t
i
=
mPendingWrapperRestyleOffset
;
while
(
i
<
mPendingWrapperRestyles
.
Length
(
)
)
{
i
+
=
ProcessMaybeNestedWrapperRestyle
(
aParentFrame
i
)
;
}
mPendingWrapperRestyles
.
TruncateLength
(
mPendingWrapperRestyleOffset
)
;
}
size_t
ServoRestyleState
:
:
ProcessMaybeNestedWrapperRestyle
(
nsIFrame
*
aParent
size_t
aIndex
)
{
MOZ_ASSERT
(
aIndex
<
mPendingWrapperRestyles
.
Length
(
)
)
;
nsIFrame
*
cur
=
mPendingWrapperRestyles
[
aIndex
]
;
MOZ_ASSERT
(
cur
-
>
StyleContext
(
)
-
>
IsWrapperAnonBox
(
)
)
;
nsIFrame
*
parent
=
cur
-
>
GetParent
(
)
;
if
(
cur
-
>
IsTableFrame
(
)
)
{
MOZ_ASSERT
(
parent
-
>
IsTableWrapperFrame
(
)
)
;
parent
=
parent
-
>
GetParent
(
)
;
}
if
(
parent
-
>
IsLineFrame
(
)
)
{
parent
=
parent
-
>
GetParent
(
)
;
}
MOZ_ASSERT
(
FirstContinuationOrPartOfIBSplit
(
parent
)
=
=
aParent
|
|
(
parent
-
>
StyleContext
(
)
-
>
IsInheritingAnonBox
(
)
&
&
parent
-
>
GetContent
(
)
=
=
aParent
-
>
GetContent
(
)
)
)
;
Maybe
<
ServoRestyleState
>
parentRestyleState
;
nsIFrame
*
parentForRestyle
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
parent
)
;
if
(
parentForRestyle
!
=
aParent
)
{
parentRestyleState
.
emplace
(
*
parentForRestyle
*
this
nsChangeHint_Empty
Type
:
:
InFlow
)
;
}
ServoRestyleState
&
curRestyleState
=
parentRestyleState
?
*
parentRestyleState
:
*
this
;
if
(
cur
-
>
IsWrapperAnonBoxNeedingRestyle
(
)
)
{
parentForRestyle
-
>
UpdateStyleOfChildAnonBox
(
cur
curRestyleState
)
;
cur
-
>
SetIsWrapperAnonBoxNeedingRestyle
(
false
)
;
}
size_t
numProcessed
=
1
;
if
(
aIndex
+
1
<
mPendingWrapperRestyles
.
Length
(
)
)
{
nsIFrame
*
next
=
mPendingWrapperRestyles
[
aIndex
+
1
]
;
if
(
TableAwareParentFor
(
next
)
=
=
cur
&
&
next
-
>
IsWrapperAnonBoxNeedingRestyle
(
)
)
{
ServoRestyleState
childState
(
*
cur
curRestyleState
nsChangeHint_Empty
Type
:
:
InFlow
false
)
;
numProcessed
+
=
childState
.
ProcessMaybeNestedWrapperRestyle
(
cur
aIndex
+
1
)
;
}
}
return
numProcessed
;
}
nsIFrame
*
ServoRestyleState
:
:
TableAwareParentFor
(
const
nsIFrame
*
aChild
)
{
if
(
aChild
-
>
IsTableFrame
(
)
)
{
aChild
=
aChild
-
>
GetParent
(
)
;
MOZ_ASSERT
(
aChild
-
>
IsTableWrapperFrame
(
)
)
;
}
nsIFrame
*
parent
=
aChild
-
>
GetParent
(
)
;
if
(
parent
-
>
StyleContext
(
)
-
>
GetPseudo
(
)
=
=
nsCSSAnonBoxes
:
:
cellContent
)
{
parent
=
parent
-
>
GetParent
(
)
;
}
else
if
(
parent
-
>
IsTableWrapperFrame
(
)
)
{
MOZ_ASSERT
(
aChild
-
>
StyleDisplay
(
)
-
>
mDisplay
=
=
StyleDisplay
:
:
TableCaption
)
;
parent
=
parent
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
}
return
parent
;
}
ServoRestyleManager
:
:
ServoRestyleManager
(
nsPresContext
*
aPresContext
)
:
RestyleManager
(
StyleBackendType
:
:
Servo
aPresContext
)
mReentrantChanges
(
nullptr
)
{
}
void
ServoRestyleManager
:
:
PostRestyleEvent
(
Element
*
aElement
nsRestyleHint
aRestyleHint
nsChangeHint
aMinChangeHint
)
{
MOZ_ASSERT
(
!
(
aMinChangeHint
&
nsChangeHint_NeutralChange
)
"
Didn
'
t
expect
explicit
change
hints
to
be
neutral
!
"
)
;
if
(
MOZ_UNLIKELY
(
IsDisconnected
(
)
)
|
|
MOZ_UNLIKELY
(
PresContext
(
)
-
>
PresShell
(
)
-
>
IsDestroying
(
)
)
)
{
return
;
}
MOZ_ASSERT
(
!
ServoStyleSet
:
:
IsInServoTraversal
(
)
)
;
if
(
aRestyleHint
=
=
0
&
&
!
aMinChangeHint
)
{
return
;
}
if
(
aRestyleHint
)
{
IncrementUndisplayedRestyleGeneration
(
)
;
}
if
(
mReentrantChanges
&
&
!
aRestyleHint
)
{
mReentrantChanges
-
>
AppendElement
(
ReentrantChange
{
aElement
aMinChangeHint
}
)
;
return
;
}
if
(
aRestyleHint
&
~
eRestyle_AllHintsWithAnimations
)
{
mHaveNonAnimationRestyles
=
true
;
}
if
(
aRestyleHint
&
eRestyle_LaterSiblings
)
{
aRestyleHint
&
=
~
eRestyle_LaterSiblings
;
nsRestyleHint
siblingHint
=
eRestyle_Subtree
;
Element
*
current
=
aElement
-
>
GetNextElementSibling
(
)
;
while
(
current
)
{
Servo_NoteExplicitHints
(
current
siblingHint
nsChangeHint
(
0
)
)
;
current
=
current
-
>
GetNextElementSibling
(
)
;
}
}
if
(
aRestyleHint
|
|
aMinChangeHint
)
{
Servo_NoteExplicitHints
(
aElement
aRestyleHint
aMinChangeHint
)
;
}
}
void
ServoRestyleManager
:
:
PostRestyleEventForCSSRuleChanges
(
)
{
mRestyleForCSSRuleChanges
=
true
;
mPresContext
-
>
PresShell
(
)
-
>
EnsureStyleFlush
(
)
;
}
void
ServoRestyleManager
:
:
PostRestyleEventForAnimations
(
Element
*
aElement
CSSPseudoElementType
aPseudoType
nsRestyleHint
aRestyleHint
)
{
Element
*
elementToRestyle
=
EffectCompositor
:
:
GetElementToRestyle
(
aElement
aPseudoType
)
;
if
(
!
elementToRestyle
)
{
return
;
}
AutoRestyleTimelineMarker
marker
(
mPresContext
-
>
GetDocShell
(
)
true
)
;
Servo_NoteExplicitHints
(
elementToRestyle
aRestyleHint
nsChangeHint
(
0
)
)
;
}
void
ServoRestyleManager
:
:
RebuildAllStyleData
(
nsChangeHint
aExtraHint
nsRestyleHint
aRestyleHint
)
{
PostRebuildAllStyleDataEvent
(
aExtraHint
aRestyleHint
)
;
}
void
ServoRestyleManager
:
:
PostRebuildAllStyleDataEvent
(
nsChangeHint
aExtraHint
nsRestyleHint
aRestyleHint
)
{
StyleSet
(
)
-
>
ClearCachedStyleData
(
)
;
DocumentStyleRootIterator
iter
(
mPresContext
-
>
Document
(
)
)
;
while
(
Element
*
root
=
iter
.
GetNextStyleRoot
(
)
)
{
PostRestyleEvent
(
root
aRestyleHint
aExtraHint
)
;
}
}
void
ServoRestyleManager
:
:
ClearServoDataFromSubtree
(
Element
*
aElement
IncludeRoot
aIncludeRoot
)
{
if
(
!
aElement
-
>
HasServoData
(
)
)
{
MOZ_ASSERT
(
!
aElement
-
>
HasDirtyDescendantsForServo
(
)
)
;
MOZ_ASSERT
(
!
aElement
-
>
HasAnimationOnlyDirtyDescendantsForServo
(
)
)
;
return
;
}
StyleChildrenIterator
it
(
aElement
)
;
for
(
nsIContent
*
n
=
it
.
GetNextChild
(
)
;
n
;
n
=
it
.
GetNextChild
(
)
)
{
if
(
n
-
>
IsElement
(
)
)
{
ClearServoDataFromSubtree
(
n
-
>
AsElement
(
)
IncludeRoot
:
:
Yes
)
;
}
}
if
(
MOZ_LIKELY
(
aIncludeRoot
=
=
IncludeRoot
:
:
Yes
)
)
{
aElement
-
>
ClearServoData
(
)
;
}
}
void
ServoRestyleManager
:
:
ClearRestyleStateFromSubtree
(
Element
*
aElement
)
{
if
(
aElement
-
>
HasAnyOfFlags
(
Element
:
:
kAllServoDescendantBits
)
)
{
StyleChildrenIterator
it
(
aElement
)
;
for
(
nsIContent
*
n
=
it
.
GetNextChild
(
)
;
n
;
n
=
it
.
GetNextChild
(
)
)
{
if
(
n
-
>
IsElement
(
)
)
{
ClearRestyleStateFromSubtree
(
n
-
>
AsElement
(
)
)
;
}
}
}
bool
wasRestyled
;
Unused
<
<
Servo_TakeChangeHint
(
aElement
&
wasRestyled
)
;
aElement
-
>
UnsetFlags
(
Element
:
:
kAllServoDescendantBits
)
;
}
struct
ServoRestyleManager
:
:
TextPostTraversalState
{
public
:
TextPostTraversalState
(
Element
&
aParentElement
ServoStyleContext
*
aParentContext
bool
aDisplayContentsParentStyleChanged
ServoRestyleState
&
aParentRestyleState
)
:
mParentElement
(
aParentElement
)
mParentContext
(
aParentContext
)
mParentRestyleState
(
aParentRestyleState
)
mStyle
(
nullptr
)
mShouldPostHints
(
aDisplayContentsParentStyleChanged
)
mShouldComputeHints
(
aDisplayContentsParentStyleChanged
)
mComputedHint
(
nsChangeHint_Empty
)
{
}
nsStyleChangeList
&
ChangeList
(
)
{
return
mParentRestyleState
.
ChangeList
(
)
;
}
nsStyleContext
&
ComputeStyle
(
nsIContent
*
aTextNode
)
{
if
(
!
mStyle
)
{
mStyle
=
mParentRestyleState
.
StyleSet
(
)
.
ResolveStyleForText
(
aTextNode
&
ParentStyle
(
)
)
;
}
MOZ_ASSERT
(
mStyle
)
;
return
*
mStyle
;
}
void
ComputeHintIfNeeded
(
nsIContent
*
aContent
nsIFrame
*
aTextFrame
nsStyleContext
&
aNewContext
)
{
MOZ_ASSERT
(
aTextFrame
)
;
MOZ_ASSERT
(
aNewContext
.
GetPseudo
(
)
=
=
nsCSSAnonBoxes
:
:
mozText
)
;
if
(
MOZ_LIKELY
(
!
mShouldPostHints
)
)
{
return
;
}
ServoStyleContext
*
oldContext
=
aTextFrame
-
>
StyleContext
(
)
-
>
AsServo
(
)
;
MOZ_ASSERT
(
oldContext
-
>
GetPseudo
(
)
=
=
nsCSSAnonBoxes
:
:
mozText
)
;
if
(
mShouldComputeHints
)
{
mShouldComputeHints
=
false
;
uint32_t
equalStructs
samePointerStructs
;
mComputedHint
=
oldContext
-
>
CalcStyleDifference
(
&
aNewContext
&
equalStructs
&
samePointerStructs
)
;
mComputedHint
=
NS_RemoveSubsumedHints
(
mComputedHint
mParentRestyleState
.
ChangesHandledFor
(
*
aTextFrame
)
)
;
}
if
(
mComputedHint
)
{
mParentRestyleState
.
ChangeList
(
)
.
AppendChange
(
aTextFrame
aContent
mComputedHint
)
;
}
}
private
:
ServoStyleContext
&
ParentStyle
(
)
{
if
(
!
mParentContext
)
{
mLazilyResolvedParentContext
=
mParentRestyleState
.
StyleSet
(
)
.
ResolveServoStyle
(
&
mParentElement
)
;
mParentContext
=
mLazilyResolvedParentContext
;
}
return
*
mParentContext
;
}
Element
&
mParentElement
;
ServoStyleContext
*
mParentContext
;
RefPtr
<
ServoStyleContext
>
mLazilyResolvedParentContext
;
ServoRestyleState
&
mParentRestyleState
;
RefPtr
<
nsStyleContext
>
mStyle
;
bool
mShouldPostHints
;
bool
mShouldComputeHints
;
nsChangeHint
mComputedHint
;
}
;
static
void
UpdateBackdropIfNeeded
(
nsIFrame
*
aFrame
ServoStyleSet
&
aStyleSet
nsStyleChangeList
&
aChangeList
)
{
const
nsStyleDisplay
*
display
=
aFrame
-
>
StyleContext
(
)
-
>
StyleDisplay
(
)
;
if
(
display
-
>
mTopLayer
!
=
NS_STYLE_TOP_LAYER_TOP
)
{
return
;
}
MOZ_ASSERT
(
display
-
>
IsAbsolutelyPositionedStyle
(
)
)
;
nsIFrame
*
backdropPlaceholder
=
aFrame
-
>
GetChildList
(
nsIFrame
:
:
kBackdropList
)
.
FirstChild
(
)
;
if
(
!
backdropPlaceholder
)
{
return
;
}
MOZ_ASSERT
(
backdropPlaceholder
-
>
IsPlaceholderFrame
(
)
)
;
nsIFrame
*
backdropFrame
=
nsPlaceholderFrame
:
:
GetRealFrameForPlaceholder
(
backdropPlaceholder
)
;
MOZ_ASSERT
(
backdropFrame
-
>
IsBackdropFrame
(
)
)
;
MOZ_ASSERT
(
backdropFrame
-
>
StyleContext
(
)
-
>
GetPseudoType
(
)
=
=
CSSPseudoElementType
:
:
backdrop
)
;
RefPtr
<
nsStyleContext
>
newContext
=
aStyleSet
.
ResolvePseudoElementStyle
(
aFrame
-
>
GetContent
(
)
-
>
AsElement
(
)
CSSPseudoElementType
:
:
backdrop
aFrame
-
>
StyleContext
(
)
-
>
AsServo
(
)
nullptr
)
;
MOZ_ASSERT
(
backdropFrame
-
>
GetParent
(
)
-
>
IsViewportFrame
(
)
|
|
backdropFrame
-
>
GetParent
(
)
-
>
IsCanvasFrame
(
)
)
;
nsTArray
<
nsIFrame
*
>
wrappersToRestyle
;
ServoRestyleState
state
(
aStyleSet
aChangeList
wrappersToRestyle
)
;
aFrame
-
>
UpdateStyleOfOwnedChildFrame
(
backdropFrame
newContext
state
)
;
}
static
void
UpdateFirstLetterIfNeeded
(
nsIFrame
*
aFrame
ServoRestyleState
&
aRestyleState
)
{
MOZ_ASSERT
(
!
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eBlockFrame
)
"
You
'
re
probably
duplicating
work
with
UpdatePseudoElementStyles
!
"
)
;
if
(
!
aFrame
-
>
HasFirstLetterChild
(
)
)
{
return
;
}
nsIFrame
*
block
=
aFrame
-
>
GetParent
(
)
;
while
(
!
block
-
>
IsFrameOfType
(
nsIFrame
:
:
eBlockFrame
)
)
{
block
=
block
-
>
GetParent
(
)
;
}
static_cast
<
nsBlockFrame
*
>
(
block
-
>
FirstContinuation
(
)
)
-
>
UpdateFirstLetterStyle
(
aRestyleState
)
;
}
static
void
UpdateOneAdditionalStyleContext
(
nsIFrame
*
aFrame
uint32_t
aIndex
ServoStyleContext
&
aOldContext
ServoRestyleState
&
aRestyleState
)
{
auto
pseudoType
=
aOldContext
.
GetPseudoType
(
)
;
MOZ_ASSERT
(
pseudoType
!
=
CSSPseudoElementType
:
:
NotPseudo
)
;
MOZ_ASSERT
(
!
nsCSSPseudoElements
:
:
PseudoElementSupportsUserActionState
(
pseudoType
)
)
;
RefPtr
<
ServoStyleContext
>
newContext
=
aRestyleState
.
StyleSet
(
)
.
ResolvePseudoElementStyle
(
aFrame
-
>
GetContent
(
)
-
>
AsElement
(
)
pseudoType
aFrame
-
>
StyleContext
(
)
-
>
AsServo
(
)
nullptr
)
;
uint32_t
equalStructs
samePointerStructs
;
nsChangeHint
childHint
=
aOldContext
.
CalcStyleDifference
(
newContext
&
equalStructs
&
samePointerStructs
)
;
if
(
!
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
)
{
childHint
=
NS_RemoveSubsumedHints
(
childHint
aRestyleState
.
ChangesHandledFor
(
*
aFrame
)
)
;
}
if
(
childHint
)
{
aRestyleState
.
ChangeList
(
)
.
AppendChange
(
aFrame
aFrame
-
>
GetContent
(
)
childHint
)
;
}
aFrame
-
>
SetAdditionalStyleContext
(
aIndex
newContext
)
;
}
static
void
UpdateAdditionalStyleContexts
(
nsIFrame
*
aFrame
ServoRestyleState
&
aRestyleState
)
{
MOZ_ASSERT
(
aFrame
)
;
MOZ_ASSERT
(
aFrame
-
>
GetContent
(
)
&
&
aFrame
-
>
GetContent
(
)
-
>
IsElement
(
)
)
;
uint32_t
index
=
0
;
while
(
auto
*
oldContext
=
aFrame
-
>
GetAdditionalStyleContext
(
index
)
)
{
UpdateOneAdditionalStyleContext
(
aFrame
index
+
+
*
oldContext
-
>
AsServo
(
)
aRestyleState
)
;
}
}
static
void
UpdateFramePseudoElementStyles
(
nsIFrame
*
aFrame
ServoRestyleState
&
aRestyleState
)
{
if
(
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eBlockFrame
)
)
{
static_cast
<
nsBlockFrame
*
>
(
aFrame
)
-
>
UpdatePseudoElementStyles
(
aRestyleState
)
;
}
else
{
UpdateFirstLetterIfNeeded
(
aFrame
aRestyleState
)
;
}
UpdateBackdropIfNeeded
(
aFrame
aRestyleState
.
StyleSet
(
)
aRestyleState
.
ChangeList
(
)
)
;
}
enum
class
ServoPostTraversalFlags
:
uint32_t
{
Empty
=
0
ParentWasRestyled
=
1
<
<
0
SkipA11yNotifications
=
1
<
<
1
SendA11yNotificationsIfShown
=
1
<
<
2
}
;
MOZ_MAKE_ENUM_CLASS_BITWISE_OPERATORS
(
ServoPostTraversalFlags
)
static
ServoPostTraversalFlags
SendA11yNotifications
(
nsPresContext
*
aPresContext
Element
*
aElement
nsStyleContext
*
aOldStyleContext
nsStyleContext
*
aNewStyleContext
ServoPostTraversalFlags
aFlags
)
{
using
Flags
=
ServoPostTraversalFlags
;
MOZ_ASSERT
(
!
(
aFlags
&
Flags
:
:
SkipA11yNotifications
)
|
|
!
(
aFlags
&
Flags
:
:
SendA11yNotificationsIfShown
)
"
The
two
a11y
flags
should
never
be
set
together
"
)
;
#
ifdef
ACCESSIBILITY
nsAccessibilityService
*
accService
=
GetAccService
(
)
;
if
(
!
accService
)
{
return
Flags
:
:
Empty
;
}
if
(
aFlags
&
Flags
:
:
SkipA11yNotifications
)
{
return
Flags
:
:
SkipA11yNotifications
;
}
bool
needsNotify
=
false
;
bool
isVisible
=
aNewStyleContext
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
;
if
(
aFlags
&
Flags
:
:
SendA11yNotificationsIfShown
)
{
if
(
!
isVisible
)
{
return
Flags
:
:
SendA11yNotificationsIfShown
;
}
needsNotify
=
true
;
}
else
{
bool
wasVisible
=
aOldStyleContext
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
;
needsNotify
=
wasVisible
!
=
isVisible
;
}
if
(
needsNotify
)
{
nsIPresShell
*
presShell
=
aPresContext
-
>
PresShell
(
)
;
if
(
isVisible
)
{
accService
-
>
ContentRangeInserted
(
presShell
aElement
-
>
GetParent
(
)
aElement
aElement
-
>
GetNextSibling
(
)
)
;
return
Flags
:
:
SkipA11yNotifications
;
}
accService
-
>
ContentRemoved
(
presShell
aElement
)
;
return
Flags
:
:
SendA11yNotificationsIfShown
;
}
#
endif
return
Flags
:
:
Empty
;
}
bool
ServoRestyleManager
:
:
ProcessPostTraversal
(
Element
*
aElement
ServoStyleContext
*
aParentContext
ServoRestyleState
&
aRestyleState
ServoPostTraversalFlags
aFlags
)
{
nsIFrame
*
styleFrame
=
nsLayoutUtils
:
:
GetStyleFrame
(
aElement
)
;
nsIFrame
*
primaryFrame
=
aElement
-
>
GetPrimaryFrame
(
)
;
const
bool
isOutOfFlow
=
primaryFrame
&
&
primaryFrame
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
;
bool
wasRestyled
;
nsChangeHint
changeHint
=
static_cast
<
nsChangeHint
>
(
Servo_TakeChangeHint
(
aElement
&
wasRestyled
)
)
;
if
(
styleFrame
&
&
styleFrame
-
>
GetContent
(
)
!
=
aElement
)
{
MOZ_ASSERT
(
static_cast
<
nsImageFrame
*
>
(
do_QueryFrame
(
styleFrame
)
)
)
;
styleFrame
=
nullptr
;
}
if
(
aElement
-
>
HasFlag
(
NODE_NEEDS_FRAME
)
)
{
changeHint
|
=
nsChangeHint_ReconstructFrame
;
MOZ_ASSERT
(
!
styleFrame
)
;
}
if
(
styleFrame
)
{
MOZ_ASSERT
(
primaryFrame
)
;
nsIFrame
*
maybeAnonBoxChild
;
if
(
isOutOfFlow
)
{
maybeAnonBoxChild
=
primaryFrame
-
>
GetPlaceholderFrame
(
)
;
}
else
{
maybeAnonBoxChild
=
primaryFrame
;
changeHint
=
NS_RemoveSubsumedHints
(
changeHint
aRestyleState
.
ChangesHandledFor
(
*
styleFrame
)
)
;
}
if
(
(
aFlags
&
ServoPostTraversalFlags
:
:
ParentWasRestyled
)
&
&
maybeAnonBoxChild
-
>
ParentIsWrapperAnonBox
(
)
)
{
aRestyleState
.
AddPendingWrapperRestyle
(
ServoRestyleState
:
:
TableAwareParentFor
(
maybeAnonBoxChild
)
)
;
}
}
if
(
(
styleFrame
|
|
(
changeHint
&
nsChangeHint_ReconstructFrame
)
)
&
&
changeHint
)
{
aRestyleState
.
ChangeList
(
)
.
AppendChange
(
styleFrame
aElement
changeHint
)
;
}
if
(
changeHint
&
nsChangeHint_ReconstructFrame
)
{
ClearRestyleStateFromSubtree
(
aElement
)
;
return
true
;
}
RefPtr
<
ServoStyleContext
>
oldStyleContext
=
styleFrame
?
styleFrame
-
>
StyleContext
(
)
-
>
AsServo
(
)
:
nullptr
;
nsStyleContext
*
displayContentsStyle
=
nullptr
;
if
(
!
oldStyleContext
)
{
displayContentsStyle
=
PresContext
(
)
-
>
FrameConstructor
(
)
-
>
GetDisplayContentsStyleFor
(
aElement
)
;
if
(
displayContentsStyle
)
{
oldStyleContext
=
displayContentsStyle
-
>
AsServo
(
)
;
}
}
Maybe
<
ServoRestyleState
>
thisFrameRestyleState
;
if
(
styleFrame
)
{
auto
type
=
isOutOfFlow
?
ServoRestyleState
:
:
Type
:
:
OutOfFlow
:
ServoRestyleState
:
:
Type
:
:
InFlow
;
thisFrameRestyleState
.
emplace
(
*
styleFrame
aRestyleState
changeHint
type
)
;
}
ServoRestyleState
&
childrenRestyleState
=
thisFrameRestyleState
?
*
thisFrameRestyleState
:
aRestyleState
;
RefPtr
<
ServoStyleContext
>
upToDateContext
=
wasRestyled
?
aRestyleState
.
StyleSet
(
)
.
ResolveServoStyle
(
aElement
)
:
oldStyleContext
;
ServoPostTraversalFlags
childrenFlags
=
wasRestyled
?
ServoPostTraversalFlags
:
:
ParentWasRestyled
:
ServoPostTraversalFlags
:
:
Empty
;
if
(
wasRestyled
&
&
oldStyleContext
)
{
MOZ_ASSERT
(
styleFrame
|
|
displayContentsStyle
)
;
MOZ_ASSERT
(
oldStyleContext
-
>
ComputedData
(
)
!
=
upToDateContext
-
>
ComputedData
(
)
)
;
upToDateContext
-
>
ResolveSameStructsAs
(
oldStyleContext
)
;
for
(
nsIFrame
*
f
=
styleFrame
;
f
;
f
=
f
-
>
GetNextContinuation
(
)
)
{
MOZ_ASSERT_IF
(
f
!
=
styleFrame
!
f
-
>
GetAdditionalStyleContext
(
0
)
)
;
f
-
>
SetStyleContext
(
upToDateContext
)
;
}
if
(
MOZ_UNLIKELY
(
displayContentsStyle
)
)
{
MOZ_ASSERT
(
!
styleFrame
)
;
PresContext
(
)
-
>
FrameConstructor
(
)
-
>
ChangeRegisteredDisplayContentsStyleFor
(
aElement
upToDateContext
)
;
}
if
(
styleFrame
)
{
UpdateAdditionalStyleContexts
(
styleFrame
aRestyleState
)
;
}
if
(
!
aElement
-
>
GetParent
(
)
)
{
ViewportFrame
*
viewport
=
do_QueryFrame
(
mPresContext
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
)
;
if
(
viewport
)
{
viewport
-
>
UpdateStyle
(
aRestyleState
)
;
}
}
AddLayerChangesForAnimation
(
styleFrame
aElement
aRestyleState
.
ChangeList
(
)
)
;
childrenFlags
|
=
SendA11yNotifications
(
mPresContext
aElement
oldStyleContext
upToDateContext
aFlags
)
;
}
const
bool
traverseElementChildren
=
aElement
-
>
HasAnyOfFlags
(
Element
:
:
kAllServoDescendantBits
)
;
const
bool
traverseTextChildren
=
wasRestyled
|
|
aElement
-
>
HasFlag
(
NODE_DESCENDANTS_NEED_FRAMES
)
;
bool
recreatedAnyContext
=
wasRestyled
;
if
(
traverseElementChildren
|
|
traverseTextChildren
)
{
StyleChildrenIterator
it
(
aElement
)
;
TextPostTraversalState
textState
(
*
aElement
upToDateContext
displayContentsStyle
&
&
wasRestyled
childrenRestyleState
)
;
for
(
nsIContent
*
n
=
it
.
GetNextChild
(
)
;
n
;
n
=
it
.
GetNextChild
(
)
)
{
if
(
traverseElementChildren
&
&
n
-
>
IsElement
(
)
)
{
recreatedAnyContext
|
=
ProcessPostTraversal
(
n
-
>
AsElement
(
)
upToDateContext
childrenRestyleState
childrenFlags
)
;
}
else
if
(
traverseTextChildren
&
&
n
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
{
recreatedAnyContext
|
=
ProcessPostTraversalForText
(
n
textState
childrenRestyleState
childrenFlags
)
;
}
}
}
if
(
styleFrame
)
{
if
(
wasRestyled
)
{
styleFrame
-
>
UpdateStyleOfOwnedAnonBoxes
(
childrenRestyleState
)
;
}
childrenRestyleState
.
ProcessWrapperRestyles
(
styleFrame
)
;
if
(
wasRestyled
)
{
UpdateFramePseudoElementStyles
(
styleFrame
childrenRestyleState
)
;
}
else
if
(
traverseElementChildren
&
&
styleFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eBlockFrame
)
)
{
nsIFrame
*
firstLineFrame
=
static_cast
<
nsBlockFrame
*
>
(
styleFrame
)
-
>
GetFirstLineFrame
(
)
;
if
(
firstLineFrame
)
{
for
(
nsIFrame
*
kid
:
firstLineFrame
-
>
PrincipalChildList
(
)
)
{
ReparentStyleContext
(
kid
)
;
}
}
}
}
aElement
-
>
UnsetFlags
(
Element
:
:
kAllServoDescendantBits
)
;
return
recreatedAnyContext
;
}
bool
ServoRestyleManager
:
:
ProcessPostTraversalForText
(
nsIContent
*
aTextNode
TextPostTraversalState
&
aPostTraversalState
ServoRestyleState
&
aRestyleState
ServoPostTraversalFlags
aFlags
)
{
if
(
aTextNode
-
>
HasFlag
(
NODE_NEEDS_FRAME
)
)
{
aPostTraversalState
.
ChangeList
(
)
.
AppendChange
(
nullptr
aTextNode
nsChangeHint_ReconstructFrame
)
;
return
true
;
}
nsIFrame
*
primaryFrame
=
aTextNode
-
>
GetPrimaryFrame
(
)
;
if
(
!
primaryFrame
)
{
return
false
;
}
if
(
(
aFlags
&
ServoPostTraversalFlags
:
:
ParentWasRestyled
)
&
&
primaryFrame
-
>
ParentIsWrapperAnonBox
(
)
)
{
aRestyleState
.
AddPendingWrapperRestyle
(
ServoRestyleState
:
:
TableAwareParentFor
(
primaryFrame
)
)
;
}
nsStyleContext
&
newContext
=
aPostTraversalState
.
ComputeStyle
(
aTextNode
)
;
aPostTraversalState
.
ComputeHintIfNeeded
(
aTextNode
primaryFrame
newContext
)
;
for
(
nsIFrame
*
f
=
primaryFrame
;
f
;
f
=
f
-
>
GetNextContinuation
(
)
)
{
f
-
>
SetStyleContext
(
&
newContext
)
;
}
return
true
;
}
void
ServoRestyleManager
:
:
ClearSnapshots
(
)
{
for
(
auto
iter
=
mSnapshots
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
iter
.
Key
(
)
-
>
UnsetFlags
(
ELEMENT_HAS_SNAPSHOT
|
ELEMENT_HANDLED_SNAPSHOT
)
;
iter
.
Remove
(
)
;
}
}
ServoElementSnapshot
&
ServoRestyleManager
:
:
SnapshotFor
(
Element
*
aElement
)
{
MOZ_ASSERT
(
!
mInStyleRefresh
)
;
MOZ_ASSERT
(
aElement
-
>
HasServoData
(
)
)
;
MOZ_ASSERT
(
!
aElement
-
>
HasFlag
(
ELEMENT_HANDLED_SNAPSHOT
)
)
;
ServoElementSnapshot
*
snapshot
=
mSnapshots
.
LookupOrAdd
(
aElement
aElement
)
;
aElement
-
>
SetFlags
(
ELEMENT_HAS_SNAPSHOT
)
;
aElement
-
>
NoteDirtyForServo
(
)
;
return
*
snapshot
;
}
void
ServoRestyleManager
:
:
DoProcessPendingRestyles
(
ServoTraversalFlags
aFlags
)
{
nsPresContext
*
presContext
=
PresContext
(
)
;
MOZ_ASSERT
(
presContext
-
>
Document
(
)
"
No
document
?
Pshaw
!
"
)
;
MOZ_ASSERT
(
(
aFlags
&
ServoTraversalFlags
:
:
FlushThrottledAnimations
)
|
|
!
presContext
-
>
HasPendingMediaQueryUpdates
(
)
"
Someone
forgot
to
update
media
queries
?
"
)
;
MOZ_ASSERT
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
Missing
a
script
blocker
!
"
)
;
MOZ_ASSERT
(
!
mInStyleRefresh
"
Reentrant
call
?
"
)
;
if
(
MOZ_UNLIKELY
(
!
presContext
-
>
PresShell
(
)
-
>
DidInitialize
(
)
)
)
{
return
;
}
AnimationsWithDestroyedFrame
animationsWithDestroyedFrame
(
this
)
;
ServoStyleSet
*
styleSet
=
StyleSet
(
)
;
nsIDocument
*
doc
=
presContext
-
>
Document
(
)
;
presContext
-
>
RefreshDriver
(
)
-
>
MostRecentRefresh
(
)
;
mInStyleRefresh
=
true
;
if
(
mHaveNonAnimationRestyles
)
{
+
+
mAnimationGeneration
;
}
if
(
mRestyleForCSSRuleChanges
)
{
aFlags
|
=
ServoTraversalFlags
:
:
ForCSSRuleChanges
;
}
while
(
styleSet
-
>
StyleDocument
(
aFlags
)
)
{
ClearSnapshots
(
)
;
nsStyleChangeList
currentChanges
(
StyleBackendType
:
:
Servo
)
;
bool
anyStyleChanged
=
false
;
{
AutoRestyleTimelineMarker
marker
(
presContext
-
>
GetDocShell
(
)
false
)
;
DocumentStyleRootIterator
iter
(
doc
-
>
GetServoRestyleRoot
(
)
)
;
while
(
Element
*
root
=
iter
.
GetNextStyleRoot
(
)
)
{
nsTArray
<
nsIFrame
*
>
wrappersToRestyle
;
ServoRestyleState
state
(
*
styleSet
currentChanges
wrappersToRestyle
)
;
ServoPostTraversalFlags
flags
=
ServoPostTraversalFlags
:
:
Empty
;
anyStyleChanged
|
=
ProcessPostTraversal
(
root
nullptr
state
flags
)
;
}
}
doc
-
>
ClearServoRestyleRoot
(
)
;
{
AutoTimelineMarker
marker
(
presContext
-
>
GetDocShell
(
)
"
StylesApplyChanges
"
)
;
ReentrantChangeList
newChanges
;
mReentrantChanges
=
&
newChanges
;
while
(
!
currentChanges
.
IsEmpty
(
)
)
{
ProcessRestyledFrames
(
currentChanges
)
;
MOZ_ASSERT
(
currentChanges
.
IsEmpty
(
)
)
;
for
(
ReentrantChange
&
change
:
newChanges
)
{
if
(
!
(
change
.
mHint
&
nsChangeHint_ReconstructFrame
)
&
&
!
change
.
mContent
-
>
GetPrimaryFrame
(
)
)
{
continue
;
}
currentChanges
.
AppendChange
(
change
.
mContent
-
>
GetPrimaryFrame
(
)
change
.
mContent
change
.
mHint
)
;
}
newChanges
.
Clear
(
)
;
}
mReentrantChanges
=
nullptr
;
}
if
(
anyStyleChanged
)
{
IncrementRestyleGeneration
(
)
;
}
}
doc
-
>
ClearServoRestyleRoot
(
)
;
FlushOverflowChangedTracker
(
)
;
ClearSnapshots
(
)
;
styleSet
-
>
AssertTreeIsClean
(
)
;
mHaveNonAnimationRestyles
=
false
;
mRestyleForCSSRuleChanges
=
false
;
mInStyleRefresh
=
false
;
styleSet
-
>
MaybeGCRuleTree
(
)
;
MOZ_ASSERT
(
mAnimationsWithDestroyedFrame
)
;
mAnimationsWithDestroyedFrame
-
>
StopAnimationsForElementsWithoutFrames
(
)
;
}
#
ifdef
DEBUG
static
void
VerifyFlatTree
(
const
nsIContent
&
aContent
)
{
StyleChildrenIterator
iter
(
&
aContent
)
;
for
(
auto
*
content
=
iter
.
GetNextChild
(
)
;
content
;
content
=
iter
.
GetNextChild
(
)
)
{
MOZ_ASSERT
(
content
-
>
GetFlattenedTreeParentNodeForStyle
(
)
=
=
&
aContent
)
;
VerifyFlatTree
(
*
content
)
;
}
}
#
endif
void
ServoRestyleManager
:
:
ProcessPendingRestyles
(
)
{
#
ifdef
DEBUG
if
(
auto
*
root
=
mPresContext
-
>
Document
(
)
-
>
GetRootElement
(
)
)
{
VerifyFlatTree
(
*
root
)
;
}
#
endif
DoProcessPendingRestyles
(
ServoTraversalFlags
:
:
Empty
)
;
}
void
ServoRestyleManager
:
:
ProcessAllPendingAttributeAndStateInvalidations
(
)
{
if
(
mSnapshots
.
IsEmpty
(
)
)
{
return
;
}
for
(
auto
iter
=
mSnapshots
.
Iter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
if
(
iter
.
Key
(
)
-
>
HasFlag
(
ELEMENT_HAS_SNAPSHOT
)
)
{
Servo_ProcessInvalidations
(
StyleSet
(
)
-
>
RawSet
(
)
iter
.
Key
(
)
&
mSnapshots
)
;
}
}
ClearSnapshots
(
)
;
}
bool
ServoRestyleManager
:
:
HasPendingRestyleAncestor
(
Element
*
aElement
)
const
{
return
Servo_HasPendingRestyleAncestor
(
aElement
)
;
}
void
ServoRestyleManager
:
:
UpdateOnlyAnimationStyles
(
)
{
bool
doCSS
=
PresContext
(
)
-
>
EffectCompositor
(
)
-
>
HasPendingStyleUpdates
(
)
;
if
(
!
doCSS
)
{
return
;
}
DoProcessPendingRestyles
(
ServoTraversalFlags
:
:
FlushThrottledAnimations
)
;
}
void
ServoRestyleManager
:
:
ContentStateChanged
(
nsIContent
*
aContent
EventStates
aChangedBits
)
{
MOZ_ASSERT
(
!
mInStyleRefresh
)
;
if
(
!
aContent
-
>
IsElement
(
)
)
{
return
;
}
Element
*
aElement
=
aContent
-
>
AsElement
(
)
;
if
(
!
aElement
-
>
HasServoData
(
)
)
{
return
;
}
nsChangeHint
changeHint
;
ContentStateChangedInternal
(
aElement
aChangedBits
&
changeHint
)
;
if
(
!
aChangedBits
.
HasAtLeastOneOfStates
(
DIRECTION_STATES
)
&
&
!
StyleSet
(
)
-
>
HasStateDependency
(
*
aElement
aChangedBits
)
)
{
return
;
}
ServoElementSnapshot
&
snapshot
=
SnapshotFor
(
aElement
)
;
EventStates
previousState
=
aElement
-
>
StyleState
(
)
^
aChangedBits
;
snapshot
.
AddState
(
previousState
)
;
if
(
changeHint
)
{
Servo_NoteExplicitHints
(
aElement
nsRestyleHint
(
0
)
changeHint
)
;
}
IncrementUndisplayedRestyleGeneration
(
)
;
}
static
inline
bool
AttributeInfluencesOtherPseudoClassState
(
const
Element
&
aElement
const
nsAtom
*
aAttribute
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
mozbrowser
)
{
return
aElement
.
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
iframe
nsGkAtoms
:
:
frame
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
border
)
{
return
aElement
.
IsHTMLElement
(
nsGkAtoms
:
:
table
)
;
}
return
false
;
}
static
inline
bool
NeedToRecordAttrChange
(
const
ServoStyleSet
&
aStyleSet
const
Element
&
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
bool
*
aInfluencesOtherPseudoClassState
)
{
*
aInfluencesOtherPseudoClassState
=
AttributeInfluencesOtherPseudoClassState
(
aElement
aAttribute
)
;
if
(
*
aInfluencesOtherPseudoClassState
)
{
return
true
;
}
if
(
aNameSpaceID
=
=
kNameSpaceID_None
&
&
(
aAttribute
=
=
nsGkAtoms
:
:
id
|
|
aAttribute
=
=
nsGkAtoms
:
:
_class
)
)
{
return
true
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
lang
)
{
return
true
;
}
return
aStyleSet
.
MightHaveAttributeDependency
(
aElement
aAttribute
)
;
}
void
ServoRestyleManager
:
:
AttributeWillChange
(
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
const
nsAttrValue
*
aNewValue
)
{
TakeSnapshotForAttributeChange
(
aElement
aNameSpaceID
aAttribute
)
;
}
void
ServoRestyleManager
:
:
ClassAttributeWillBeChangedBySMIL
(
Element
*
aElement
)
{
TakeSnapshotForAttributeChange
(
aElement
kNameSpaceID_None
nsGkAtoms
:
:
_class
)
;
}
void
ServoRestyleManager
:
:
TakeSnapshotForAttributeChange
(
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
)
{
MOZ_ASSERT
(
!
mInStyleRefresh
)
;
if
(
!
aElement
-
>
HasServoData
(
)
)
{
return
;
}
bool
influencesOtherPseudoClassState
;
if
(
!
NeedToRecordAttrChange
(
*
StyleSet
(
)
*
aElement
aNameSpaceID
aAttribute
&
influencesOtherPseudoClassState
)
)
{
return
;
}
IncrementUndisplayedRestyleGeneration
(
)
;
mHaveNonAnimationRestyles
=
true
;
ServoElementSnapshot
&
snapshot
=
SnapshotFor
(
aElement
)
;
snapshot
.
AddAttrs
(
aElement
aNameSpaceID
aAttribute
)
;
if
(
influencesOtherPseudoClassState
)
{
snapshot
.
AddOtherPseudoClassState
(
aElement
)
;
}
}
static
inline
bool
AttributeChangeRequiresSubtreeRestyle
(
const
Element
&
aElement
nsAtom
*
aAttr
)
{
if
(
aAttr
=
=
nsGkAtoms
:
:
cellpadding
)
{
return
aElement
.
IsHTMLElement
(
nsGkAtoms
:
:
table
)
;
}
if
(
aAttr
=
=
nsGkAtoms
:
:
lwtheme
|
|
aAttr
=
=
nsGkAtoms
:
:
lwthemetextcolor
)
{
return
aElement
.
GetNameSpaceID
(
)
=
=
kNameSpaceID_XUL
&
&
&
aElement
=
=
aElement
.
OwnerDoc
(
)
-
>
GetRootElement
(
)
;
}
return
aAttr
=
=
nsGkAtoms
:
:
lang
;
}
void
ServoRestyleManager
:
:
AttributeChanged
(
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
const
nsAttrValue
*
aOldValue
)
{
MOZ_ASSERT
(
!
mInStyleRefresh
)
;
auto
changeHint
=
nsChangeHint
(
0
)
;
auto
restyleHint
=
nsRestyleHint
(
0
)
;
changeHint
|
=
aElement
-
>
GetAttributeChangeHint
(
aAttribute
aModType
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
style
)
{
restyleHint
|
=
eRestyle_StyleAttribute
;
}
else
if
(
AttributeChangeRequiresSubtreeRestyle
(
*
aElement
aAttribute
)
)
{
restyleHint
|
=
eRestyle_Subtree
;
}
else
if
(
aElement
-
>
IsAttributeMapped
(
aAttribute
)
)
{
restyleHint
|
=
eRestyle_Self
;
}
if
(
nsIFrame
*
primaryFrame
=
aElement
-
>
GetPrimaryFrame
(
)
)
{
const
nsStyleDisplay
*
disp
=
primaryFrame
-
>
StyleDisplay
(
)
;
if
(
disp
-
>
mAppearance
)
{
nsITheme
*
theme
=
PresContext
(
)
-
>
GetTheme
(
)
;
if
(
theme
&
&
theme
-
>
ThemeSupportsWidget
(
PresContext
(
)
primaryFrame
disp
-
>
mAppearance
)
)
{
bool
repaint
=
false
;
theme
-
>
WidgetStateChanged
(
primaryFrame
disp
-
>
mAppearance
aAttribute
&
repaint
aOldValue
)
;
if
(
repaint
)
{
changeHint
|
=
nsChangeHint_RepaintFrame
;
}
}
}
primaryFrame
-
>
AttributeChanged
(
aNameSpaceID
aAttribute
aModType
)
;
}
if
(
restyleHint
|
|
changeHint
)
{
Servo_NoteExplicitHints
(
aElement
restyleHint
changeHint
)
;
}
if
(
restyleHint
)
{
IncrementUndisplayedRestyleGeneration
(
)
;
mHaveNonAnimationRestyles
=
true
;
}
}
nsresult
ServoRestyleManager
:
:
ReparentStyleContext
(
nsIFrame
*
aFrame
)
{
#
ifdef
DEBUG
{
nsIFrame
*
f
=
aFrame
-
>
GetParent
(
)
;
while
(
f
&
&
!
f
-
>
IsLineFrame
(
)
)
{
f
=
f
-
>
GetParent
(
)
;
}
MOZ_ASSERT
(
f
"
Must
have
found
a
first
-
line
frame
"
)
;
}
#
endif
DoReparentStyleContext
(
aFrame
*
StyleSet
(
)
)
;
return
NS_OK
;
}
void
ServoRestyleManager
:
:
DoReparentStyleContext
(
nsIFrame
*
aFrame
ServoStyleSet
&
aStyleSet
)
{
if
(
aFrame
-
>
IsBackdropFrame
(
)
)
{
return
;
}
if
(
aFrame
-
>
IsPlaceholderFrame
(
)
)
{
nsIFrame
*
outOfFlow
=
nsPlaceholderFrame
:
:
GetRealFrameForPlaceholder
(
aFrame
)
;
MOZ_ASSERT
(
outOfFlow
"
no
out
-
of
-
flow
frame
"
)
;
for
(
;
outOfFlow
;
outOfFlow
=
outOfFlow
-
>
GetNextContinuation
(
)
)
{
DoReparentStyleContext
(
outOfFlow
aStyleSet
)
;
}
}
nsIFrame
*
providerFrame
;
nsStyleContext
*
newParentContext
=
aFrame
-
>
GetParentStyleContext
(
&
providerFrame
)
;
bool
isChild
=
providerFrame
&
&
providerFrame
-
>
GetParent
(
)
=
=
aFrame
;
nsIFrame
*
providerChild
=
nullptr
;
if
(
isChild
)
{
DoReparentStyleContext
(
providerFrame
aStyleSet
)
;
newParentContext
=
providerFrame
-
>
StyleContext
(
)
;
providerChild
=
providerFrame
;
MOZ_ASSERT
(
!
providerFrame
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
"
Out
of
flow
provider
?
"
)
;
}
if
(
!
newParentContext
)
{
MOZ_ASSERT
(
aFrame
-
>
StyleContext
(
)
-
>
IsNonInheritingAnonBox
(
)
"
Why
did
this
frame
not
end
up
with
a
parent
context
?
"
)
;
ReparentFrameDescendants
(
aFrame
providerChild
aStyleSet
)
;
return
;
}
bool
isElement
=
aFrame
-
>
GetContent
(
)
-
>
IsElement
(
)
;
ServoStyleContext
*
oldContext
=
aFrame
-
>
StyleContext
(
)
-
>
AsServo
(
)
;
Element
*
ourElement
=
oldContext
-
>
GetPseudoType
(
)
=
=
CSSPseudoElementType
:
:
NotPseudo
&
&
isElement
?
aFrame
-
>
GetContent
(
)
-
>
AsElement
(
)
:
nullptr
;
ServoStyleContext
*
newParent
=
newParentContext
-
>
AsServo
(
)
;
ServoStyleContext
*
newParentIgnoringFirstLine
;
if
(
newParent
-
>
GetPseudoType
(
)
=
=
CSSPseudoElementType
:
:
firstLine
)
{
MOZ_ASSERT
(
providerFrame
&
&
providerFrame
-
>
GetParent
(
)
-
>
IsFrameOfType
(
nsIFrame
:
:
eBlockFrame
)
"
How
could
we
get
a
:
:
first
-
line
parent
style
without
having
"
"
a
:
:
first
-
line
provider
frame
?
"
)
;
nsIFrame
*
blockFrame
=
providerFrame
-
>
GetParent
(
)
;
nsIFrame
*
correctedFrame
=
nsFrame
:
:
CorrectStyleParentFrame
(
blockFrame
oldContext
-
>
GetPseudo
(
)
)
;
newParentIgnoringFirstLine
=
correctedFrame
-
>
StyleContext
(
)
-
>
AsServo
(
)
;
}
else
{
newParentIgnoringFirstLine
=
newParent
;
}
if
(
!
providerFrame
)
{
if
(
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
)
{
aFrame
-
>
GetPlaceholderFrame
(
)
-
>
GetLayoutParentStyleForOutOfFlow
(
&
providerFrame
)
;
}
else
{
providerFrame
=
nsFrame
:
:
CorrectStyleParentFrame
(
aFrame
-
>
GetParent
(
)
oldContext
-
>
GetPseudo
(
)
)
;
}
}
ServoStyleContext
*
layoutParent
=
providerFrame
-
>
StyleContext
(
)
-
>
AsServo
(
)
;
RefPtr
<
ServoStyleContext
>
newContext
=
aStyleSet
.
ReparentStyleContext
(
oldContext
newParent
newParentIgnoringFirstLine
layoutParent
ourElement
)
;
aFrame
-
>
SetStyleContext
(
newContext
)
;
if
(
isElement
)
{
uint32_t
index
=
0
;
while
(
nsStyleContext
*
oldAdditionalContext
=
aFrame
-
>
GetAdditionalStyleContext
(
index
)
)
{
RefPtr
<
ServoStyleContext
>
newAdditionalContext
=
aStyleSet
.
ReparentStyleContext
(
oldAdditionalContext
-
>
AsServo
(
)
newContext
newContext
newContext
nullptr
)
;
aFrame
-
>
SetAdditionalStyleContext
(
index
newAdditionalContext
)
;
+
+
index
;
}
}
ReparentFrameDescendants
(
aFrame
providerChild
aStyleSet
)
;
}
void
ServoRestyleManager
:
:
ReparentFrameDescendants
(
nsIFrame
*
aFrame
nsIFrame
*
aProviderChild
ServoStyleSet
&
aStyleSet
)
{
nsIFrame
:
:
ChildListIterator
lists
(
aFrame
)
;
for
(
;
!
lists
.
IsDone
(
)
;
lists
.
Next
(
)
)
{
for
(
nsIFrame
*
child
:
lists
.
CurrentList
(
)
)
{
if
(
!
(
child
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
&
&
child
!
=
aProviderChild
)
{
DoReparentStyleContext
(
child
aStyleSet
)
;
}
}
}
}
}
