#
ifndef
AccessibleCaret_h__
#
define
AccessibleCaret_h__
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
dom
/
AnonymousContent
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIDOMEventListener
.
h
"
#
include
"
nsISupportsBase
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsLiteralString
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
nsString
.
h
"
class
nsIFrame
;
struct
nsPoint
;
namespace
mozilla
{
class
PresShell
;
namespace
dom
{
class
Event
;
}
class
AccessibleCaret
{
public
:
explicit
AccessibleCaret
(
PresShell
*
aPresShell
)
;
virtual
~
AccessibleCaret
(
)
;
enum
class
Appearance
:
uint8_t
{
None
Normal
NormalNotShown
Left
Right
}
;
friend
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
Appearance
&
aAppearance
)
;
Appearance
GetAppearance
(
)
const
{
return
mAppearance
;
}
virtual
void
SetAppearance
(
Appearance
aAppearance
)
;
bool
IsLogicallyVisible
(
)
const
{
return
mAppearance
!
=
Appearance
:
:
None
;
}
bool
IsVisuallyVisible
(
)
const
{
return
(
mAppearance
!
=
Appearance
:
:
None
)
&
&
(
mAppearance
!
=
Appearance
:
:
NormalNotShown
)
;
}
enum
class
PositionChangedResult
:
uint8_t
{
NotChanged
Changed
Invisible
}
;
friend
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
PositionChangedResult
&
aResult
)
;
virtual
PositionChangedResult
SetPosition
(
nsIFrame
*
aFrame
int32_t
aOffset
)
;
bool
Intersects
(
const
AccessibleCaret
&
aCaret
)
const
;
enum
class
TouchArea
{
Full
CaretImage
}
;
bool
Contains
(
const
nsPoint
&
aPoint
TouchArea
aTouchArea
)
const
;
nsPoint
LogicalPosition
(
)
const
{
return
mImaginaryCaretRect
.
Center
(
)
;
}
dom
:
:
Element
&
CaretElement
(
)
const
{
return
mCaretElementHolder
-
>
ContentNode
(
)
;
}
void
EnsureApzAware
(
)
;
protected
:
void
SetCaretElementStyle
(
const
nsRect
&
aRect
float
aZoomLevel
)
;
void
SetTextOverlayElementStyle
(
const
nsRect
&
aRect
float
aZoomLevel
)
;
void
SetCaretImageElementStyle
(
const
nsRect
&
aRect
float
aZoomLevel
)
;
float
GetZoomLevel
(
)
;
dom
:
:
Element
*
TextOverlayElement
(
)
const
{
return
mCaretElementHolder
-
>
GetElementById
(
sTextOverlayElementId
)
;
}
dom
:
:
Element
*
CaretImageElement
(
)
const
{
return
mCaretElementHolder
-
>
GetElementById
(
sCaretImageElementId
)
;
}
nsIFrame
*
RootFrame
(
)
const
{
return
mPresShell
-
>
GetRootFrame
(
)
;
}
nsIFrame
*
CustomContentContainerFrame
(
)
const
;
static
nsAutoString
AppearanceString
(
Appearance
aAppearance
)
;
already_AddRefed
<
dom
:
:
Element
>
CreateCaretElement
(
dom
:
:
Document
*
)
const
;
void
InjectCaretElement
(
dom
:
:
Document
*
)
;
void
RemoveCaretElement
(
dom
:
:
Document
*
)
;
static
nsPoint
CaretElementPosition
(
const
nsRect
&
aRect
)
{
return
aRect
.
TopLeft
(
)
+
nsPoint
(
aRect
.
width
/
2
0
)
;
}
class
DummyTouchListener
final
:
public
nsIDOMEventListener
{
public
:
NS_DECL_ISUPPORTS
NS_IMETHOD
HandleEvent
(
mozilla
:
:
dom
:
:
Event
*
aEvent
)
override
{
return
NS_OK
;
}
private
:
virtual
~
DummyTouchListener
(
)
{
}
;
}
;
Appearance
mAppearance
=
Appearance
:
:
None
;
PresShell
*
const
MOZ_NON_OWNING_REF
mPresShell
=
nullptr
;
RefPtr
<
dom
:
:
AnonymousContent
>
mCaretElementHolder
;
nsRect
mImaginaryCaretRect
;
float
mZoomLevel
=
0
.
0f
;
RefPtr
<
DummyTouchListener
>
mDummyTouchListener
{
new
DummyTouchListener
(
)
}
;
static
const
nsLiteralString
sTextOverlayElementId
;
static
const
nsLiteralString
sCaretImageElementId
;
}
;
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
AccessibleCaret
:
:
Appearance
&
aAppearance
)
;
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
AccessibleCaret
:
:
PositionChangedResult
&
aResult
)
;
}
#
endif
