#
include
"
AccessibleCaret
.
h
"
#
include
"
AccessibleCaretLogger
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
ToString
.
h
"
#
include
"
nsCanvasFrame
.
h
"
#
include
"
nsCaret
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
nsDOMTokenList
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsPlaceholderFrame
.
h
"
namespace
mozilla
{
using
namespace
dom
;
#
undef
AC_LOG
#
define
AC_LOG
(
message
.
.
.
)
\
AC_LOG_BASE
(
"
AccessibleCaret
(
%
p
)
:
"
message
this
#
#
__VA_ARGS__
)
;
#
undef
AC_LOGV
#
define
AC_LOGV
(
message
.
.
.
)
\
AC_LOGV_BASE
(
"
AccessibleCaret
(
%
p
)
:
"
message
this
#
#
__VA_ARGS__
)
;
NS_IMPL_ISUPPORTS
(
AccessibleCaret
:
:
DummyTouchListener
nsIDOMEventListener
)
float
AccessibleCaret
:
:
sWidth
=
0
.
0f
;
float
AccessibleCaret
:
:
sHeight
=
0
.
0f
;
float
AccessibleCaret
:
:
sMarginLeft
=
0
.
0f
;
NS_NAMED_LITERAL_STRING
(
AccessibleCaret
:
:
sTextOverlayElementId
"
text
-
overlay
"
)
;
NS_NAMED_LITERAL_STRING
(
AccessibleCaret
:
:
sCaretImageElementId
"
image
"
)
;
#
define
AC_PROCESS_ENUM_TO_STREAM
(
e
)
case
(
e
)
:
aStream
<
<
#
e
;
break
;
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
AccessibleCaret
:
:
Appearance
&
aAppearance
)
{
using
Appearance
=
AccessibleCaret
:
:
Appearance
;
switch
(
aAppearance
)
{
AC_PROCESS_ENUM_TO_STREAM
(
Appearance
:
:
None
)
;
AC_PROCESS_ENUM_TO_STREAM
(
Appearance
:
:
Normal
)
;
AC_PROCESS_ENUM_TO_STREAM
(
Appearance
:
:
NormalNotShown
)
;
AC_PROCESS_ENUM_TO_STREAM
(
Appearance
:
:
Left
)
;
AC_PROCESS_ENUM_TO_STREAM
(
Appearance
:
:
Right
)
;
}
return
aStream
;
}
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aStream
const
AccessibleCaret
:
:
PositionChangedResult
&
aResult
)
{
using
PositionChangedResult
=
AccessibleCaret
:
:
PositionChangedResult
;
switch
(
aResult
)
{
AC_PROCESS_ENUM_TO_STREAM
(
PositionChangedResult
:
:
NotChanged
)
;
AC_PROCESS_ENUM_TO_STREAM
(
PositionChangedResult
:
:
Changed
)
;
AC_PROCESS_ENUM_TO_STREAM
(
PositionChangedResult
:
:
Invisible
)
;
}
return
aStream
;
}
#
undef
AC_PROCESS_ENUM_TO_STREAM
AccessibleCaret
:
:
AccessibleCaret
(
nsIPresShell
*
aPresShell
)
:
mPresShell
(
aPresShell
)
{
if
(
mPresShell
)
{
MOZ_ASSERT
(
RootFrame
(
)
)
;
MOZ_ASSERT
(
mPresShell
-
>
GetDocument
(
)
)
;
InjectCaretElement
(
mPresShell
-
>
GetDocument
(
)
)
;
}
static
bool
prefsAdded
=
false
;
if
(
!
prefsAdded
)
{
Preferences
:
:
AddFloatVarCache
(
&
sWidth
"
layout
.
accessiblecaret
.
width
"
)
;
Preferences
:
:
AddFloatVarCache
(
&
sHeight
"
layout
.
accessiblecaret
.
height
"
)
;
Preferences
:
:
AddFloatVarCache
(
&
sMarginLeft
"
layout
.
accessiblecaret
.
margin
-
left
"
)
;
prefsAdded
=
true
;
}
}
AccessibleCaret
:
:
~
AccessibleCaret
(
)
{
if
(
mPresShell
)
{
RemoveCaretElement
(
mPresShell
-
>
GetDocument
(
)
)
;
}
}
void
AccessibleCaret
:
:
SetAppearance
(
Appearance
aAppearance
)
{
if
(
mAppearance
=
=
aAppearance
)
{
return
;
}
ErrorResult
rv
;
CaretElement
(
)
.
ClassList
(
)
-
>
Remove
(
AppearanceString
(
mAppearance
)
rv
)
;
MOZ_ASSERT
(
!
rv
.
Failed
(
)
"
Remove
old
appearance
failed
!
"
)
;
CaretElement
(
)
.
ClassList
(
)
-
>
Add
(
AppearanceString
(
aAppearance
)
rv
)
;
MOZ_ASSERT
(
!
rv
.
Failed
(
)
"
Add
new
appearance
failed
!
"
)
;
AC_LOG
(
"
%
s
:
%
s
-
>
%
s
"
__FUNCTION__
ToString
(
mAppearance
)
.
c_str
(
)
ToString
(
aAppearance
)
.
c_str
(
)
)
;
mAppearance
=
aAppearance
;
if
(
mAppearance
=
=
Appearance
:
:
None
)
{
mImaginaryCaretRect
=
nsRect
(
)
;
mZoomLevel
=
0
.
0f
;
}
}
nsAutoString
AccessibleCaret
:
:
AppearanceString
(
Appearance
aAppearance
)
{
nsAutoString
string
;
switch
(
aAppearance
)
{
case
Appearance
:
:
None
:
case
Appearance
:
:
NormalNotShown
:
string
=
NS_LITERAL_STRING
(
"
none
"
)
;
break
;
case
Appearance
:
:
Normal
:
string
=
NS_LITERAL_STRING
(
"
normal
"
)
;
break
;
case
Appearance
:
:
Right
:
string
=
NS_LITERAL_STRING
(
"
right
"
)
;
break
;
case
Appearance
:
:
Left
:
string
=
NS_LITERAL_STRING
(
"
left
"
)
;
break
;
}
return
string
;
}
bool
AccessibleCaret
:
:
Intersects
(
const
AccessibleCaret
&
aCaret
)
const
{
MOZ_ASSERT
(
mPresShell
=
=
aCaret
.
mPresShell
)
;
if
(
!
IsVisuallyVisible
(
)
|
|
!
aCaret
.
IsVisuallyVisible
(
)
)
{
return
false
;
}
nsRect
rect
=
nsLayoutUtils
:
:
GetRectRelativeToFrame
(
&
CaretElement
(
)
RootFrame
(
)
)
;
nsRect
rhsRect
=
nsLayoutUtils
:
:
GetRectRelativeToFrame
(
&
aCaret
.
CaretElement
(
)
RootFrame
(
)
)
;
return
rect
.
Intersects
(
rhsRect
)
;
}
bool
AccessibleCaret
:
:
Contains
(
const
nsPoint
&
aPoint
TouchArea
aTouchArea
)
const
{
if
(
!
IsVisuallyVisible
(
)
)
{
return
false
;
}
nsRect
textOverlayRect
=
nsLayoutUtils
:
:
GetRectRelativeToFrame
(
TextOverlayElement
(
)
RootFrame
(
)
)
;
nsRect
caretImageRect
=
nsLayoutUtils
:
:
GetRectRelativeToFrame
(
CaretImageElement
(
)
RootFrame
(
)
)
;
if
(
aTouchArea
=
=
TouchArea
:
:
CaretImage
)
{
return
caretImageRect
.
Contains
(
aPoint
)
;
}
MOZ_ASSERT
(
aTouchArea
=
=
TouchArea
:
:
Full
"
Unexpected
TouchArea
type
!
"
)
;
return
textOverlayRect
.
Contains
(
aPoint
)
|
|
caretImageRect
.
Contains
(
aPoint
)
;
}
void
AccessibleCaret
:
:
EnsureApzAware
(
)
{
if
(
!
CaretElement
(
)
.
IsApzAware
(
)
)
{
CaretElement
(
)
.
AddEventListener
(
NS_LITERAL_STRING
(
"
touchstart
"
)
mDummyTouchListener
false
)
;
}
}
void
AccessibleCaret
:
:
InjectCaretElement
(
nsIDocument
*
aDocument
)
{
ErrorResult
rv
;
RefPtr
<
Element
>
element
=
CreateCaretElement
(
aDocument
)
;
mCaretElementHolder
=
aDocument
-
>
InsertAnonymousContent
(
*
element
rv
)
;
MOZ_ASSERT
(
!
rv
.
Failed
(
)
"
Insert
anonymous
content
should
not
fail
!
"
)
;
MOZ_ASSERT
(
mCaretElementHolder
"
We
must
have
anonymous
content
!
"
)
;
EnsureApzAware
(
)
;
}
already_AddRefed
<
Element
>
AccessibleCaret
:
:
CreateCaretElement
(
nsIDocument
*
aDocument
)
const
{
ErrorResult
rv
;
RefPtr
<
Element
>
parent
=
aDocument
-
>
CreateHTMLElement
(
nsGkAtoms
:
:
div
)
;
parent
-
>
ClassList
(
)
-
>
Add
(
NS_LITERAL_STRING
(
"
moz
-
accessiblecaret
"
)
rv
)
;
parent
-
>
ClassList
(
)
-
>
Add
(
NS_LITERAL_STRING
(
"
none
"
)
rv
)
;
auto
CreateAndAppendChildElement
=
[
aDocument
&
parent
]
(
const
nsLiteralString
&
aElementId
)
{
RefPtr
<
Element
>
child
=
aDocument
-
>
CreateHTMLElement
(
nsGkAtoms
:
:
div
)
;
child
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
id
aElementId
true
)
;
parent
-
>
AppendChildTo
(
child
false
)
;
}
;
CreateAndAppendChildElement
(
sTextOverlayElementId
)
;
CreateAndAppendChildElement
(
sCaretImageElementId
)
;
return
parent
.
forget
(
)
;
}
void
AccessibleCaret
:
:
RemoveCaretElement
(
nsIDocument
*
aDocument
)
{
CaretElement
(
)
.
RemoveEventListener
(
NS_LITERAL_STRING
(
"
touchstart
"
)
mDummyTouchListener
false
)
;
if
(
nsIFrame
*
frame
=
CaretElement
(
)
.
GetPrimaryFrame
(
)
)
{
if
(
frame
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
)
{
frame
=
frame
-
>
GetPlaceholderFrame
(
)
;
}
nsAutoScriptBlocker
scriptBlocker
;
frame
-
>
GetParent
(
)
-
>
RemoveFrame
(
nsIFrame
:
:
kPrincipalList
frame
)
;
}
aDocument
-
>
RemoveAnonymousContent
(
*
mCaretElementHolder
IgnoreErrors
(
)
)
;
}
AccessibleCaret
:
:
PositionChangedResult
AccessibleCaret
:
:
SetPosition
(
nsIFrame
*
aFrame
int32_t
aOffset
)
{
if
(
!
CustomContentContainerFrame
(
)
)
{
return
PositionChangedResult
:
:
NotChanged
;
}
nsRect
imaginaryCaretRectInFrame
=
nsCaret
:
:
GetGeometryForFrame
(
aFrame
aOffset
nullptr
)
;
imaginaryCaretRectInFrame
=
nsLayoutUtils
:
:
ClampRectToScrollFrames
(
aFrame
imaginaryCaretRectInFrame
)
;
if
(
imaginaryCaretRectInFrame
.
IsEmpty
(
)
)
{
mImaginaryCaretRect
=
nsRect
(
)
;
mZoomLevel
=
0
.
0f
;
return
PositionChangedResult
:
:
Invisible
;
}
nsRect
imaginaryCaretRect
=
imaginaryCaretRectInFrame
;
nsLayoutUtils
:
:
TransformRect
(
aFrame
RootFrame
(
)
imaginaryCaretRect
)
;
float
zoomLevel
=
GetZoomLevel
(
)
;
if
(
imaginaryCaretRect
.
IsEqualEdges
(
mImaginaryCaretRect
)
&
&
FuzzyEqualsMultiplicative
(
zoomLevel
mZoomLevel
)
)
{
return
PositionChangedResult
:
:
NotChanged
;
}
mImaginaryCaretRect
=
imaginaryCaretRect
;
mZoomLevel
=
zoomLevel
;
nsRect
imaginaryCaretRectInContainerFrame
=
imaginaryCaretRectInFrame
;
nsLayoutUtils
:
:
TransformRect
(
aFrame
CustomContentContainerFrame
(
)
imaginaryCaretRectInContainerFrame
)
;
SetCaretElementStyle
(
imaginaryCaretRectInContainerFrame
mZoomLevel
)
;
return
PositionChangedResult
:
:
Changed
;
}
nsIFrame
*
AccessibleCaret
:
:
CustomContentContainerFrame
(
)
const
{
nsCanvasFrame
*
canvasFrame
=
mPresShell
-
>
GetCanvasFrame
(
)
;
Element
*
container
=
canvasFrame
-
>
GetCustomContentContainer
(
)
;
nsIFrame
*
containerFrame
=
container
-
>
GetPrimaryFrame
(
)
;
return
containerFrame
;
}
void
AccessibleCaret
:
:
SetCaretElementStyle
(
const
nsRect
&
aRect
float
aZoomLevel
)
{
nsPoint
position
=
CaretElementPosition
(
aRect
)
;
nsAutoString
styleStr
;
styleStr
.
AppendPrintf
(
"
left
:
%
dpx
;
top
:
%
dpx
;
"
"
width
:
"
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
position
.
x
)
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
position
.
y
)
)
;
styleStr
.
AppendFloat
(
sWidth
/
aZoomLevel
)
;
styleStr
.
AppendLiteral
(
"
px
;
height
:
"
)
;
styleStr
.
AppendFloat
(
sHeight
/
aZoomLevel
)
;
styleStr
.
AppendLiteral
(
"
px
;
margin
-
left
:
"
)
;
styleStr
.
AppendFloat
(
sMarginLeft
/
aZoomLevel
)
;
styleStr
.
AppendLiteral
(
"
px
"
)
;
CaretElement
(
)
.
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
style
styleStr
true
)
;
AC_LOG
(
"
%
s
:
%
s
"
__FUNCTION__
NS_ConvertUTF16toUTF8
(
styleStr
)
.
get
(
)
)
;
SetTextOverlayElementStyle
(
aRect
aZoomLevel
)
;
SetCaretImageElementStyle
(
aRect
aZoomLevel
)
;
}
void
AccessibleCaret
:
:
SetTextOverlayElementStyle
(
const
nsRect
&
aRect
float
aZoomLevel
)
{
nsAutoString
styleStr
;
styleStr
.
AppendPrintf
(
"
height
:
%
dpx
;
"
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
aRect
.
height
)
)
;
TextOverlayElement
(
)
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
style
styleStr
true
)
;
AC_LOG
(
"
%
s
:
%
s
"
__FUNCTION__
NS_ConvertUTF16toUTF8
(
styleStr
)
.
get
(
)
)
;
}
void
AccessibleCaret
:
:
SetCaretImageElementStyle
(
const
nsRect
&
aRect
float
aZoomLevel
)
{
nsAutoString
styleStr
;
styleStr
.
AppendPrintf
(
"
margin
-
top
:
%
dpx
;
"
nsPresContext
:
:
AppUnitsToIntCSSPixels
(
aRect
.
height
)
)
;
CaretImageElement
(
)
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
style
styleStr
true
)
;
AC_LOG
(
"
%
s
:
%
s
"
__FUNCTION__
NS_ConvertUTF16toUTF8
(
styleStr
)
.
get
(
)
)
;
}
float
AccessibleCaret
:
:
GetZoomLevel
(
)
{
float
fullZoom
=
mPresShell
-
>
GetPresContext
(
)
-
>
GetFullZoom
(
)
;
float
resolution
=
mPresShell
-
>
GetCumulativeResolution
(
)
;
return
fullZoom
*
resolution
;
}
}
