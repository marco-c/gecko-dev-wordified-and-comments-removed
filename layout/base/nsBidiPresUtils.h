#
ifndef
nsBidiPresUtils_h___
#
define
nsBidiPresUtils_h___
#
include
"
gfxContext
.
h
"
#
include
"
nsBidi
.
h
"
#
include
"
nsBidiUtils
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsCoord
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsLineBox
.
h
"
#
ifdef
DrawText
#
undef
DrawText
#
endif
struct
BidiParagraphData
;
struct
BidiLineData
;
class
gfxContext
;
class
nsFontMetrics
;
class
nsIFrame
;
class
nsBlockFrame
;
class
nsPresContext
;
struct
nsSize
;
template
<
class
T
>
class
nsTHashtable
;
namespace
mozilla
{
class
ComputedStyle
;
class
LogicalMargin
;
class
WritingMode
;
}
struct
nsFrameContinuationState
:
public
nsVoidPtrHashKey
{
explicit
nsFrameContinuationState
(
const
void
*
aFrame
)
:
nsVoidPtrHashKey
(
aFrame
)
{
}
nsIFrame
*
mFirstVisualFrame
{
nullptr
}
;
uint32_t
mFrameCount
{
0
}
;
bool
mHasContOnPrevLines
{
false
}
;
bool
mHasContOnNextLines
{
false
}
;
}
;
struct
nsContinuationStates
{
static
constexpr
size_t
kArrayMax
=
32
;
bool
mUseTable
=
false
;
AutoTArray
<
nsFrameContinuationState
kArrayMax
>
mValues
;
nsTHashtable
<
nsFrameContinuationState
>
mTable
;
void
Insert
(
nsIFrame
*
aFrame
)
{
if
(
MOZ_UNLIKELY
(
mUseTable
)
)
{
mTable
.
PutEntry
(
aFrame
)
;
return
;
}
if
(
MOZ_LIKELY
(
mValues
.
Length
(
)
<
kArrayMax
)
)
{
mValues
.
AppendElement
(
aFrame
)
;
return
;
}
for
(
const
auto
&
entry
:
mValues
)
{
mTable
.
PutEntry
(
entry
.
GetKey
(
)
)
;
}
mTable
.
PutEntry
(
aFrame
)
;
mValues
.
Clear
(
)
;
mUseTable
=
true
;
}
nsFrameContinuationState
*
Get
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
mValues
.
IsEmpty
(
)
!
=
mTable
.
IsEmpty
(
)
"
expect
entries
to
either
be
in
mValues
or
in
mTable
"
)
;
if
(
mUseTable
)
{
return
mTable
.
GetEntry
(
aFrame
)
;
}
for
(
size_t
i
=
0
len
=
mValues
.
Length
(
)
;
i
!
=
len
;
+
+
i
)
{
if
(
mValues
[
i
]
.
GetKey
(
)
=
=
aFrame
)
{
return
&
mValues
[
i
]
;
}
}
return
nullptr
;
}
}
;
struct
nsBidiPositionResolve
{
int32_t
logicalIndex
;
int32_t
visualIndex
;
int32_t
visualLeftTwips
;
int32_t
visualWidth
;
}
;
class
nsBidiPresUtils
{
public
:
typedef
mozilla
:
:
gfx
:
:
DrawTarget
DrawTarget
;
nsBidiPresUtils
(
)
;
~
nsBidiPresUtils
(
)
;
class
BidiProcessor
{
public
:
virtual
~
BidiProcessor
(
)
{
}
virtual
void
SetText
(
const
char16_t
*
aText
int32_t
aLength
nsBidiDirection
aDirection
)
=
0
;
virtual
nscoord
GetWidth
(
)
=
0
;
virtual
void
DrawText
(
nscoord
aXOffset
nscoord
aWidth
)
=
0
;
}
;
static
nsresult
Resolve
(
nsBlockFrame
*
aBlockFrame
)
;
static
nsresult
ResolveParagraph
(
BidiParagraphData
*
aBpd
)
;
static
void
ResolveParagraphWithinBlock
(
BidiParagraphData
*
aBpd
)
;
static
nscoord
ReorderFrames
(
nsIFrame
*
aFirstFrameOnLine
int32_t
aNumFramesOnLine
mozilla
:
:
WritingMode
aLineWM
const
nsSize
&
aContainerSize
nscoord
aStart
)
;
static
nsresult
FormatUnicodeText
(
nsPresContext
*
aPresContext
char16_t
*
aText
int32_t
&
aTextLength
nsCharType
aCharType
)
;
static
nsresult
RenderText
(
const
char16_t
*
aText
int32_t
aLength
nsBidiLevel
aBaseLevel
nsPresContext
*
aPresContext
gfxContext
&
aRenderingContext
DrawTarget
*
aTextRunConstructionDrawTarget
nsFontMetrics
&
aFontMetrics
nscoord
aX
nscoord
aY
nsBidiPositionResolve
*
aPosResolve
=
nullptr
int32_t
aPosResolveCount
=
0
)
{
return
ProcessTextForRenderingContext
(
aText
aLength
aBaseLevel
aPresContext
aRenderingContext
aTextRunConstructionDrawTarget
aFontMetrics
MODE_DRAW
aX
aY
aPosResolve
aPosResolveCount
nullptr
)
;
}
static
nscoord
MeasureTextWidth
(
const
char16_t
*
aText
int32_t
aLength
nsBidiLevel
aBaseLevel
nsPresContext
*
aPresContext
gfxContext
&
aRenderingContext
nsFontMetrics
&
aFontMetrics
)
{
nscoord
length
;
nsresult
rv
=
ProcessTextForRenderingContext
(
aText
aLength
aBaseLevel
aPresContext
aRenderingContext
aRenderingContext
.
GetDrawTarget
(
)
aFontMetrics
MODE_MEASURE
0
0
nullptr
0
&
length
)
;
return
NS_SUCCEEDED
(
rv
)
?
length
:
0
;
}
static
bool
CheckLineOrder
(
nsIFrame
*
aFirstFrameOnLine
int32_t
aNumFramesOnLine
nsIFrame
*
*
aLeftmost
nsIFrame
*
*
aRightmost
)
;
static
nsIFrame
*
GetFrameToRightOf
(
const
nsIFrame
*
aFrame
nsIFrame
*
aFirstFrameOnLine
int32_t
aNumFramesOnLine
)
;
static
nsIFrame
*
GetFrameToLeftOf
(
const
nsIFrame
*
aFrame
nsIFrame
*
aFirstFrameOnLine
int32_t
aNumFramesOnLine
)
;
static
nsIFrame
*
GetFirstLeaf
(
nsIFrame
*
aFrame
)
;
static
mozilla
:
:
FrameBidiData
GetFrameBidiData
(
nsIFrame
*
aFrame
)
;
static
nsBidiLevel
GetFrameEmbeddingLevel
(
nsIFrame
*
aFrame
)
;
static
nsBidiLevel
GetFrameBaseLevel
(
nsIFrame
*
aFrame
)
;
static
nsBidiDirection
ParagraphDirection
(
nsIFrame
*
aFrame
)
{
return
DIRECTION_FROM_LEVEL
(
GetFrameBaseLevel
(
aFrame
)
)
;
}
static
nsBidiDirection
FrameDirection
(
nsIFrame
*
aFrame
)
{
return
DIRECTION_FROM_LEVEL
(
GetFrameEmbeddingLevel
(
aFrame
)
)
;
}
static
bool
IsFrameInParagraphDirection
(
nsIFrame
*
aFrame
)
{
return
ParagraphDirection
(
aFrame
)
=
=
FrameDirection
(
aFrame
)
;
}
enum
Mode
{
MODE_DRAW
MODE_MEASURE
}
;
static
nsresult
ProcessText
(
const
char16_t
*
aText
int32_t
aLength
nsBidiLevel
aBaseLevel
nsPresContext
*
aPresContext
BidiProcessor
&
aprocessor
Mode
aMode
nsBidiPositionResolve
*
aPosResolve
int32_t
aPosResolveCount
nscoord
*
aWidth
nsBidi
*
aBidiEngine
)
;
static
nsBidiLevel
BidiLevelFromStyle
(
mozilla
:
:
ComputedStyle
*
aComputedStyle
)
;
private
:
static
nsresult
ProcessTextForRenderingContext
(
const
char16_t
*
aText
int32_t
aLength
nsBidiLevel
aBaseLevel
nsPresContext
*
aPresContext
gfxContext
&
aRenderingContext
DrawTarget
*
aTextRunConstructionDrawTarget
nsFontMetrics
&
aFontMetrics
Mode
aMode
nscoord
aX
nscoord
aY
nsBidiPositionResolve
*
aPosResolve
int32_t
aPosResolveCount
nscoord
*
aWidth
)
;
static
void
TraverseFrames
(
nsIFrame
*
aCurrentFrame
BidiParagraphData
*
aBpd
)
;
static
bool
ChildListMayRequireBidi
(
nsIFrame
*
aFirstChild
nsIContent
*
*
aCurrContent
)
;
static
void
RepositionRubyContentFrame
(
nsIFrame
*
aFrame
mozilla
:
:
WritingMode
aFrameWM
const
mozilla
:
:
LogicalMargin
&
aBorderPadding
)
;
static
nscoord
RepositionRubyFrame
(
nsIFrame
*
aFrame
nsContinuationStates
*
aContinuationStates
const
mozilla
:
:
WritingMode
aContainerWM
const
mozilla
:
:
LogicalMargin
&
aBorderPadding
)
;
static
nscoord
RepositionFrame
(
nsIFrame
*
aFrame
bool
aIsEvenLevel
nscoord
aStartOrEnd
nsContinuationStates
*
aContinuationStates
mozilla
:
:
WritingMode
aContainerWM
bool
aContainerReverseOrder
const
nsSize
&
aContainerSize
)
;
static
void
InitContinuationStates
(
nsIFrame
*
aFrame
nsContinuationStates
*
aContinuationStates
)
;
static
void
IsFirstOrLast
(
nsIFrame
*
aFrame
nsContinuationStates
*
aContinuationStates
bool
aSpanInLineOrder
bool
&
aIsFirst
bool
&
aIsLast
)
;
static
nscoord
RepositionInlineFrames
(
BidiLineData
*
aBld
mozilla
:
:
WritingMode
aLineWM
const
nsSize
&
aContainerSize
nscoord
aStart
)
;
static
inline
nsresult
EnsureBidiContinuation
(
nsIFrame
*
aFrame
const
nsLineList
:
:
iterator
aLine
nsIFrame
*
*
aNewFrame
int32_t
aStart
int32_t
aEnd
)
;
static
void
RemoveBidiContinuation
(
BidiParagraphData
*
aBpd
nsIFrame
*
aFrame
int32_t
aFirstIndex
int32_t
aLastIndex
)
;
static
void
CalculateCharType
(
nsBidi
*
aBidiEngine
const
char16_t
*
aText
int32_t
&
aOffset
int32_t
aCharTypeLimit
int32_t
&
aRunLimit
int32_t
&
aRunLength
int32_t
&
aRunCount
uint8_t
&
aCharType
uint8_t
&
aPrevCharType
)
;
static
void
StripBidiControlCharacters
(
char16_t
*
aText
int32_t
&
aTextLength
)
;
}
;
#
endif
