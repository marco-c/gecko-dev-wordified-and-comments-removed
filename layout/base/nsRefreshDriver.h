#
ifndef
nsRefreshDriver_h_
#
define
nsRefreshDriver_h_
#
include
"
mozilla
/
FlushType
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
nsTObserverArray
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
nsTObserverArray
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
GeckoProfiler
.
h
"
#
include
"
mozilla
/
layers
/
TransactionIdAllocator
.
h
"
class
nsPresContext
;
class
nsIPresShell
;
class
nsIDocument
;
class
imgIRequest
;
class
nsIDOMEvent
;
class
nsINode
;
class
nsIRunnable
;
namespace
mozilla
{
class
RefreshDriverTimer
;
namespace
layout
{
class
VsyncChild
;
}
}
class
nsARefreshObserver
{
public
:
NS_INLINE_DECL_PURE_VIRTUAL_REFCOUNTING
virtual
void
WillRefresh
(
mozilla
:
:
TimeStamp
aTime
)
=
0
;
}
;
class
nsAPostRefreshObserver
{
public
:
virtual
void
DidRefresh
(
)
=
0
;
}
;
class
nsRefreshDriver
final
:
public
mozilla
:
:
layers
:
:
TransactionIdAllocator
public
nsARefreshObserver
{
public
:
explicit
nsRefreshDriver
(
nsPresContext
*
aPresContext
)
;
~
nsRefreshDriver
(
)
;
void
AdvanceTimeAndRefresh
(
int64_t
aMilliseconds
)
;
void
RestoreNormalRefresh
(
)
;
void
DoTick
(
)
;
bool
IsTestControllingRefreshesEnabled
(
)
const
{
return
mTestControllingRefreshes
;
}
mozilla
:
:
TimeStamp
MostRecentRefresh
(
)
const
;
int64_t
MostRecentRefreshEpochTime
(
)
const
;
bool
AddRefreshObserver
(
nsARefreshObserver
*
aObserver
mozilla
:
:
FlushType
aFlushType
)
;
bool
RemoveRefreshObserver
(
nsARefreshObserver
*
aObserver
mozilla
:
:
FlushType
aFlushType
)
;
void
AddPostRefreshObserver
(
nsAPostRefreshObserver
*
aObserver
)
;
void
RemovePostRefreshObserver
(
nsAPostRefreshObserver
*
aObserver
)
;
bool
AddImageRequest
(
imgIRequest
*
aRequest
)
;
void
RemoveImageRequest
(
imgIRequest
*
aRequest
)
;
bool
AddStyleFlushObserver
(
nsIPresShell
*
aShell
)
{
NS_ASSERTION
(
!
mStyleFlushObservers
.
Contains
(
aShell
)
"
Double
-
adding
style
flush
observer
"
)
;
if
(
!
mStyleCause
)
{
mStyleCause
=
profiler_get_backtrace
(
)
;
}
bool
appended
=
mStyleFlushObservers
.
AppendElement
(
aShell
)
!
=
nullptr
;
EnsureTimerStarted
(
)
;
return
appended
;
}
void
RemoveStyleFlushObserver
(
nsIPresShell
*
aShell
)
{
mStyleFlushObservers
.
RemoveElement
(
aShell
)
;
}
bool
AddLayoutFlushObserver
(
nsIPresShell
*
aShell
)
{
NS_ASSERTION
(
!
IsLayoutFlushObserver
(
aShell
)
"
Double
-
adding
layout
flush
observer
"
)
;
if
(
!
mReflowCause
)
{
mReflowCause
=
profiler_get_backtrace
(
)
;
}
bool
appended
=
mLayoutFlushObservers
.
AppendElement
(
aShell
)
!
=
nullptr
;
EnsureTimerStarted
(
)
;
return
appended
;
}
void
RemoveLayoutFlushObserver
(
nsIPresShell
*
aShell
)
{
mLayoutFlushObservers
.
RemoveElement
(
aShell
)
;
}
bool
IsLayoutFlushObserver
(
nsIPresShell
*
aShell
)
{
return
mLayoutFlushObservers
.
Contains
(
aShell
)
;
}
void
AddEarlyRunner
(
nsIRunnable
*
aRunnable
)
{
mEarlyRunners
.
AppendElement
(
aRunnable
)
;
EnsureTimerStarted
(
)
;
}
void
ScheduleViewManagerFlush
(
)
;
void
RevokeViewManagerFlush
(
)
{
mViewManagerFlushIsPending
=
false
;
}
bool
ViewManagerFlushIsPending
(
)
{
return
mViewManagerFlushIsPending
;
}
void
ScheduleFrameRequestCallbacks
(
nsIDocument
*
aDocument
)
;
void
RevokeFrameRequestCallbacks
(
nsIDocument
*
aDocument
)
;
void
ScheduleEventDispatch
(
nsINode
*
aTarget
nsIDOMEvent
*
aEvent
)
;
void
CancelPendingEvents
(
nsIDocument
*
aDocument
)
;
void
ScheduleFrameVisibilityUpdate
(
)
{
mNeedToRecomputeVisibility
=
true
;
}
void
Disconnect
(
)
;
bool
IsFrozen
(
)
{
return
mFreezeCount
>
0
;
}
void
Freeze
(
)
;
void
Thaw
(
)
;
void
SetThrottled
(
bool
aThrottled
)
;
nsPresContext
*
GetPresContext
(
)
const
{
return
mPresContext
;
}
static
void
PVsyncActorCreated
(
mozilla
:
:
layout
:
:
VsyncChild
*
aVsyncChild
)
;
#
ifdef
DEBUG
bool
IsRefreshObserver
(
nsARefreshObserver
*
aObserver
mozilla
:
:
FlushType
aFlushType
)
;
#
endif
static
int32_t
DefaultInterval
(
)
;
bool
IsInRefresh
(
)
{
return
mInRefresh
;
}
void
SetIsResizeSuppressed
(
)
{
mResizeSuppressed
=
true
;
}
bool
IsResizeSuppressed
(
)
const
{
return
mResizeSuppressed
;
}
static
bool
GetJankLevels
(
mozilla
:
:
Vector
<
uint64_t
>
&
aJank
)
;
uint64_t
GetTransactionId
(
bool
aThrottle
)
override
;
uint64_t
LastTransactionId
(
)
const
override
;
void
NotifyTransactionCompleted
(
uint64_t
aTransactionId
)
override
;
void
RevokeTransactionId
(
uint64_t
aTransactionId
)
override
;
void
ClearPendingTransactions
(
)
override
;
void
ResetInitialTransactionId
(
uint64_t
aTransactionId
)
override
;
mozilla
:
:
TimeStamp
GetTransactionStart
(
)
override
;
bool
IsWaitingForPaint
(
mozilla
:
:
TimeStamp
aTime
)
;
NS_IMETHOD_
(
MozExternalRefCountType
)
AddRef
(
void
)
override
{
return
TransactionIdAllocator
:
:
AddRef
(
)
;
}
NS_IMETHOD_
(
MozExternalRefCountType
)
Release
(
void
)
override
{
return
TransactionIdAllocator
:
:
Release
(
)
;
}
virtual
void
WillRefresh
(
mozilla
:
:
TimeStamp
aTime
)
override
;
static
mozilla
:
:
TimeStamp
GetIdleDeadlineHint
(
mozilla
:
:
TimeStamp
aDefault
)
;
static
void
DispatchIdleRunnableAfterTick
(
nsIRunnable
*
aRunnable
uint32_t
aDelay
)
;
static
void
CancelIdleRunnable
(
nsIRunnable
*
aRunnable
)
;
bool
SkippedPaints
(
)
const
{
return
mSkippedPaints
;
}
private
:
typedef
nsTObserverArray
<
nsARefreshObserver
*
>
ObserverArray
;
typedef
nsTHashtable
<
nsISupportsHashKey
>
RequestTable
;
struct
ImageStartData
{
ImageStartData
(
)
{
}
mozilla
:
:
Maybe
<
mozilla
:
:
TimeStamp
>
mStartTime
;
RequestTable
mEntries
;
}
;
typedef
nsClassHashtable
<
nsUint32HashKey
ImageStartData
>
ImageStartTable
;
void
DispatchPendingEvents
(
)
;
void
DispatchAnimationEvents
(
)
;
void
RunFrameRequestCallbacks
(
mozilla
:
:
TimeStamp
aNowTime
)
;
void
Tick
(
int64_t
aNowEpoch
mozilla
:
:
TimeStamp
aNowTime
)
;
enum
EnsureTimerStartedFlags
{
eNone
=
0
eForceAdjustTimer
=
1
<
<
0
eAllowTimeToGoBackwards
=
1
<
<
1
eNeverAdjustTimer
=
1
<
<
2
}
;
void
EnsureTimerStarted
(
EnsureTimerStartedFlags
aFlags
=
eNone
)
;
void
StopTimer
(
)
;
uint32_t
ObserverCount
(
)
const
;
uint32_t
ImageRequestCount
(
)
const
;
ObserverArray
&
ArrayFor
(
mozilla
:
:
FlushType
aFlushType
)
;
void
DoRefresh
(
)
;
double
GetRefreshTimerInterval
(
)
const
;
double
GetRegularTimerInterval
(
bool
*
outIsDefault
=
nullptr
)
const
;
static
double
GetThrottledTimerInterval
(
)
;
static
mozilla
:
:
TimeDuration
GetMinRecomputeVisibilityInterval
(
)
;
bool
HaveFrameRequestCallbacks
(
)
const
{
return
mFrameRequestCallbackDocs
.
Length
(
)
!
=
0
;
}
void
FinishedWaitingForTransaction
(
)
;
mozilla
:
:
RefreshDriverTimer
*
ChooseTimer
(
)
const
;
mozilla
:
:
RefreshDriverTimer
*
mActiveTimer
;
UniqueProfilerBacktrace
mReflowCause
;
UniqueProfilerBacktrace
mStyleCause
;
mozilla
:
:
WeakPtr
<
nsPresContext
>
mPresContext
;
RefPtr
<
nsRefreshDriver
>
mRootRefresh
;
uint64_t
mPendingTransaction
;
uint64_t
mCompletedTransaction
;
uint32_t
mFreezeCount
;
const
mozilla
:
:
TimeDuration
mThrottledFrameRequestInterval
;
const
mozilla
:
:
TimeDuration
mMinRecomputeVisibilityInterval
;
bool
mThrottled
;
bool
mNeedToRecomputeVisibility
;
bool
mTestControllingRefreshes
;
bool
mViewManagerFlushIsPending
;
bool
mInRefresh
;
bool
mWaitingForTransaction
;
bool
mSkippedPaints
;
bool
mResizeSuppressed
;
int64_t
mMostRecentRefreshEpochTime
;
uint64_t
mWarningThreshold
;
mozilla
:
:
TimeStamp
mMostRecentRefresh
;
mozilla
:
:
TimeStamp
mMostRecentTick
;
mozilla
:
:
TimeStamp
mTickStart
;
mozilla
:
:
TimeStamp
mNextThrottledFrameRequestTick
;
mozilla
:
:
TimeStamp
mNextRecomputeVisibilityTick
;
ObserverArray
mObservers
[
3
]
;
RequestTable
mRequests
;
ImageStartTable
mStartTable
;
AutoTArray
<
nsCOMPtr
<
nsIRunnable
>
16
>
mEarlyRunners
;
struct
PendingEvent
{
nsCOMPtr
<
nsINode
>
mTarget
;
nsCOMPtr
<
nsIDOMEvent
>
mEvent
;
}
;
AutoTArray
<
nsIPresShell
*
16
>
mStyleFlushObservers
;
AutoTArray
<
nsIPresShell
*
16
>
mLayoutFlushObservers
;
nsTArray
<
nsIDocument
*
>
mFrameRequestCallbackDocs
;
nsTArray
<
nsIDocument
*
>
mThrottledFrameRequestCallbackDocs
;
nsTObserverArray
<
nsAPostRefreshObserver
*
>
mPostRefreshObservers
;
nsTArray
<
PendingEvent
>
mPendingEvents
;
void
BeginRefreshingImages
(
RequestTable
&
aEntries
mozilla
:
:
TimeStamp
aDesired
)
;
friend
class
mozilla
:
:
RefreshDriverTimer
;
static
void
Shutdown
(
)
;
static
bool
IsJankCritical
(
)
;
}
;
#
endif
