#
ifndef
nsRefreshDriver_h_
#
define
nsRefreshDriver_h_
#
include
"
mozilla
/
FlushType
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
nsTObserverArray
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
dom
/
VisualViewport
.
h
"
#
include
"
mozilla
/
layers
/
TransactionIdAllocator
.
h
"
#
include
"
mozilla
/
VsyncDispatcher
.
h
"
class
nsPresContext
;
class
imgIRequest
;
class
nsINode
;
class
nsIRunnable
;
namespace
mozilla
{
class
AnimationEventDispatcher
;
class
PendingFullscreenEvent
;
class
PresShell
;
class
RefreshDriverTimer
;
class
Runnable
;
namespace
layout
{
class
VsyncChild
;
}
namespace
dom
{
class
Event
;
}
}
class
nsARefreshObserver
{
public
:
NS_INLINE_DECL_PURE_VIRTUAL_REFCOUNTING
MOZ_CAN_RUN_SCRIPT
virtual
void
WillRefresh
(
mozilla
:
:
TimeStamp
aTime
)
=
0
;
}
;
class
nsATimerAdjustmentObserver
{
public
:
virtual
void
NotifyTimerAdjusted
(
mozilla
:
:
TimeStamp
aTime
)
=
0
;
}
;
class
nsAPostRefreshObserver
{
public
:
virtual
void
DidRefresh
(
)
=
0
;
}
;
class
nsRefreshDriver
final
:
public
mozilla
:
:
layers
:
:
TransactionIdAllocator
public
nsARefreshObserver
{
using
Document
=
mozilla
:
:
dom
:
:
Document
;
using
TransactionId
=
mozilla
:
:
layers
:
:
TransactionId
;
using
VVPResizeEvent
=
mozilla
:
:
dom
:
:
VisualViewport
:
:
VisualViewportResizeEvent
;
using
VVPScrollEvent
=
mozilla
:
:
dom
:
:
VisualViewport
:
:
VisualViewportScrollEvent
;
public
:
explicit
nsRefreshDriver
(
nsPresContext
*
aPresContext
)
;
~
nsRefreshDriver
(
)
;
void
AdvanceTimeAndRefresh
(
int64_t
aMilliseconds
)
;
void
RestoreNormalRefresh
(
)
;
void
DoTick
(
)
;
bool
IsTestControllingRefreshesEnabled
(
)
const
{
return
mTestControllingRefreshes
;
}
mozilla
:
:
TimeStamp
MostRecentRefresh
(
)
const
;
void
AddRefreshObserver
(
nsARefreshObserver
*
aObserver
mozilla
:
:
FlushType
aFlushType
)
;
bool
RemoveRefreshObserver
(
nsARefreshObserver
*
aObserver
mozilla
:
:
FlushType
aFlushType
)
;
void
AddTimerAdjustmentObserver
(
nsATimerAdjustmentObserver
*
aObserver
)
;
void
RemoveTimerAdjustmentObserver
(
nsATimerAdjustmentObserver
*
aObserver
)
;
void
PostVisualViewportResizeEvent
(
VVPResizeEvent
*
aResizeEvent
)
;
void
DispatchVisualViewportResizeEvents
(
)
;
void
PostScrollEvent
(
mozilla
:
:
Runnable
*
aScrollEvent
bool
aDelayed
=
false
)
;
void
DispatchScrollEvents
(
)
;
void
PostVisualViewportScrollEvent
(
VVPScrollEvent
*
aScrollEvent
)
;
void
DispatchVisualViewportScrollEvents
(
)
;
void
AddPostRefreshObserver
(
nsAPostRefreshObserver
*
aObserver
)
;
void
RemovePostRefreshObserver
(
nsAPostRefreshObserver
*
aObserver
)
;
bool
AddImageRequest
(
imgIRequest
*
aRequest
)
;
void
RemoveImageRequest
(
imgIRequest
*
aRequest
)
;
void
AddResizeEventFlushObserver
(
mozilla
:
:
PresShell
*
aPresShell
bool
aDelayed
=
false
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mResizeEventFlushObservers
.
Contains
(
aPresShell
)
&
&
!
mDelayedResizeEventFlushObservers
.
Contains
(
aPresShell
)
"
Double
-
adding
resize
event
flush
observer
"
)
;
if
(
aDelayed
)
{
mDelayedResizeEventFlushObservers
.
AppendElement
(
aPresShell
)
;
}
else
{
mResizeEventFlushObservers
.
AppendElement
(
aPresShell
)
;
EnsureTimerStarted
(
)
;
}
}
void
RemoveResizeEventFlushObserver
(
mozilla
:
:
PresShell
*
aPresShell
)
{
mResizeEventFlushObservers
.
RemoveElement
(
aPresShell
)
;
mDelayedResizeEventFlushObservers
.
RemoveElement
(
aPresShell
)
;
}
void
AddStyleFlushObserver
(
mozilla
:
:
PresShell
*
aPresShell
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mStyleFlushObservers
.
Contains
(
aPresShell
)
"
Double
-
adding
style
flush
observer
"
)
;
mStyleFlushObservers
.
AppendElement
(
aPresShell
)
;
EnsureTimerStarted
(
)
;
}
void
RemoveStyleFlushObserver
(
mozilla
:
:
PresShell
*
aPresShell
)
{
mStyleFlushObservers
.
RemoveElement
(
aPresShell
)
;
}
void
AddLayoutFlushObserver
(
mozilla
:
:
PresShell
*
aPresShell
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
IsLayoutFlushObserver
(
aPresShell
)
"
Double
-
adding
layout
flush
observer
"
)
;
mLayoutFlushObservers
.
AppendElement
(
aPresShell
)
;
EnsureTimerStarted
(
)
;
}
void
RemoveLayoutFlushObserver
(
mozilla
:
:
PresShell
*
aPresShell
)
{
mLayoutFlushObservers
.
RemoveElement
(
aPresShell
)
;
}
bool
IsLayoutFlushObserver
(
mozilla
:
:
PresShell
*
aPresShell
)
{
return
mLayoutFlushObservers
.
Contains
(
aPresShell
)
;
}
void
AddEarlyRunner
(
nsIRunnable
*
aRunnable
)
{
mEarlyRunners
.
AppendElement
(
aRunnable
)
;
EnsureTimerStarted
(
)
;
}
void
ScheduleViewManagerFlush
(
)
;
void
RevokeViewManagerFlush
(
)
{
mViewManagerFlushIsPending
=
false
;
}
bool
ViewManagerFlushIsPending
(
)
{
return
mViewManagerFlushIsPending
;
}
bool
HasScheduleFlush
(
)
{
return
mHasScheduleFlush
;
}
void
ClearHasScheduleFlush
(
)
{
mHasScheduleFlush
=
false
;
}
void
ScheduleFrameRequestCallbacks
(
Document
*
aDocument
)
;
void
RevokeFrameRequestCallbacks
(
Document
*
aDocument
)
;
void
ScheduleFullscreenEvent
(
mozilla
:
:
UniquePtr
<
mozilla
:
:
PendingFullscreenEvent
>
aEvent
)
;
void
CancelPendingFullscreenEvents
(
Document
*
aDocument
)
;
void
ScheduleAnimationEventDispatch
(
mozilla
:
:
AnimationEventDispatcher
*
aDispatcher
)
{
NS_ASSERTION
(
!
mAnimationEventFlushObservers
.
Contains
(
aDispatcher
)
"
Double
-
adding
animation
event
flush
observer
"
)
;
mAnimationEventFlushObservers
.
AppendElement
(
aDispatcher
)
;
EnsureTimerStarted
(
)
;
}
void
CancelPendingAnimationEvents
(
mozilla
:
:
AnimationEventDispatcher
*
aDispatcher
)
;
void
ScheduleFrameVisibilityUpdate
(
)
{
mNeedToRecomputeVisibility
=
true
;
}
void
Disconnect
(
)
;
bool
IsFrozen
(
)
{
return
mFreezeCount
>
0
;
}
void
Freeze
(
)
;
void
Thaw
(
)
;
void
SetThrottled
(
bool
aThrottled
)
;
nsPresContext
*
GetPresContext
(
)
const
{
return
mPresContext
;
}
static
void
PVsyncActorCreated
(
mozilla
:
:
layout
:
:
VsyncChild
*
aVsyncChild
)
;
void
CreateVsyncRefreshTimer
(
)
;
#
ifdef
DEBUG
bool
IsRefreshObserver
(
nsARefreshObserver
*
aObserver
mozilla
:
:
FlushType
aFlushType
)
;
#
endif
static
int32_t
DefaultInterval
(
)
;
bool
IsInRefresh
(
)
{
return
mInRefresh
;
}
void
SetIsResizeSuppressed
(
)
{
mResizeSuppressed
=
true
;
}
bool
IsResizeSuppressed
(
)
const
{
return
mResizeSuppressed
;
}
static
bool
GetJankLevels
(
mozilla
:
:
Vector
<
uint64_t
>
&
aJank
)
;
TransactionId
GetTransactionId
(
bool
aThrottle
)
override
;
TransactionId
LastTransactionId
(
)
const
override
;
void
NotifyTransactionCompleted
(
TransactionId
aTransactionId
)
override
;
void
RevokeTransactionId
(
TransactionId
aTransactionId
)
override
;
void
ClearPendingTransactions
(
)
override
;
void
ResetInitialTransactionId
(
TransactionId
aTransactionId
)
override
;
mozilla
:
:
TimeStamp
GetTransactionStart
(
)
override
;
mozilla
:
:
VsyncId
GetVsyncId
(
)
override
;
mozilla
:
:
TimeStamp
GetVsyncStart
(
)
override
;
bool
IsWaitingForPaint
(
mozilla
:
:
TimeStamp
aTime
)
;
NS_IMETHOD_
(
MozExternalRefCountType
)
AddRef
(
void
)
override
{
return
TransactionIdAllocator
:
:
AddRef
(
)
;
}
NS_IMETHOD_
(
MozExternalRefCountType
)
Release
(
void
)
override
{
return
TransactionIdAllocator
:
:
Release
(
)
;
}
virtual
void
WillRefresh
(
mozilla
:
:
TimeStamp
aTime
)
override
;
static
mozilla
:
:
TimeStamp
GetIdleDeadlineHint
(
mozilla
:
:
TimeStamp
aDefault
)
;
static
mozilla
:
:
Maybe
<
mozilla
:
:
TimeStamp
>
GetNextTickHint
(
)
;
static
void
DispatchIdleRunnableAfterTickUnlessExists
(
nsIRunnable
*
aRunnable
uint32_t
aDelay
)
;
static
void
CancelIdleRunnable
(
nsIRunnable
*
aRunnable
)
;
void
NotifyDOMContentLoaded
(
)
;
void
RunDelayedEventsSoon
(
)
;
void
InitializeTimer
(
)
{
MOZ_ASSERT
(
!
mActiveTimer
)
;
EnsureTimerStarted
(
)
;
}
void
EnsureIntersectionObservationsUpdateHappens
(
)
{
EnsureTimerStarted
(
)
;
mNeedToUpdateIntersectionObservations
=
true
;
}
private
:
typedef
nsTObserverArray
<
nsARefreshObserver
*
>
ObserverArray
;
typedef
nsTArray
<
RefPtr
<
VVPResizeEvent
>
>
VisualViewportResizeEventArray
;
typedef
nsTArray
<
RefPtr
<
mozilla
:
:
Runnable
>
>
ScrollEventArray
;
typedef
nsTArray
<
RefPtr
<
VVPScrollEvent
>
>
VisualViewportScrollEventArray
;
typedef
nsTHashtable
<
nsISupportsHashKey
>
RequestTable
;
struct
ImageStartData
{
ImageStartData
(
)
{
}
mozilla
:
:
Maybe
<
mozilla
:
:
TimeStamp
>
mStartTime
;
RequestTable
mEntries
;
}
;
typedef
nsClassHashtable
<
nsUint32HashKey
ImageStartData
>
ImageStartTable
;
void
RunFullscreenSteps
(
)
;
void
DispatchAnimationEvents
(
)
;
MOZ_CAN_RUN_SCRIPT
void
RunFrameRequestCallbacks
(
mozilla
:
:
TimeStamp
aNowTime
)
;
void
UpdateIntersectionObservations
(
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
Tick
(
mozilla
:
:
VsyncId
aId
mozilla
:
:
TimeStamp
aNowTime
)
;
enum
EnsureTimerStartedFlags
{
eNone
=
0
eForceAdjustTimer
=
1
<
<
0
eAllowTimeToGoBackwards
=
1
<
<
1
eNeverAdjustTimer
=
1
<
<
2
}
;
void
EnsureTimerStarted
(
EnsureTimerStartedFlags
aFlags
=
eNone
)
;
void
StopTimer
(
)
;
bool
HasObservers
(
)
const
;
uint32_t
ObserverCount
(
)
const
;
bool
HasImageRequests
(
)
const
;
ObserverArray
&
ArrayFor
(
mozilla
:
:
FlushType
aFlushType
)
;
void
DoRefresh
(
)
;
double
GetRegularTimerInterval
(
)
const
;
static
double
GetThrottledTimerInterval
(
)
;
static
mozilla
:
:
TimeDuration
GetMinRecomputeVisibilityInterval
(
)
;
bool
HaveFrameRequestCallbacks
(
)
const
{
return
mFrameRequestCallbackDocs
.
Length
(
)
!
=
0
;
}
void
FinishedWaitingForTransaction
(
)
;
mozilla
:
:
RefreshDriverTimer
*
ChooseTimer
(
)
;
mozilla
:
:
RefreshDriverTimer
*
mActiveTimer
;
RefPtr
<
mozilla
:
:
RefreshDriverTimer
>
mOwnTimer
;
mozilla
:
:
WeakPtr
<
nsPresContext
>
mPresContext
;
RefPtr
<
nsRefreshDriver
>
mRootRefresh
;
TransactionId
mNextTransactionId
;
TransactionId
mOutstandingTransactionId
;
TransactionId
mCompletedTransaction
;
uint32_t
mFreezeCount
;
const
mozilla
:
:
TimeDuration
mThrottledFrameRequestInterval
;
const
mozilla
:
:
TimeDuration
mMinRecomputeVisibilityInterval
;
bool
mThrottled
:
1
;
bool
mNeedToRecomputeVisibility
:
1
;
bool
mTestControllingRefreshes
:
1
;
bool
mViewManagerFlushIsPending
:
1
;
bool
mHasScheduleFlush
:
1
;
bool
mInRefresh
:
1
;
bool
mWaitingForTransaction
:
1
;
bool
mSkippedPaints
:
1
;
bool
mResizeSuppressed
:
1
;
bool
mNotifyDOMContentFlushed
:
1
;
bool
mNeedToUpdateIntersectionObservations
:
1
;
uint64_t
mWarningThreshold
;
mozilla
:
:
TimeStamp
mMostRecentRefresh
;
mozilla
:
:
TimeStamp
mTickStart
;
mozilla
:
:
VsyncId
mTickVsyncId
;
mozilla
:
:
TimeStamp
mTickVsyncTime
;
mozilla
:
:
TimeStamp
mNextThrottledFrameRequestTick
;
mozilla
:
:
TimeStamp
mNextRecomputeVisibilityTick
;
mozilla
:
:
TimeStamp
mInitialTimerRunningLimit
;
ObserverArray
mObservers
[
4
]
;
nsTObserverArray
<
nsATimerAdjustmentObserver
*
>
mTimerAdjustmentObservers
;
RequestTable
mRequests
;
ImageStartTable
mStartTable
;
AutoTArray
<
nsCOMPtr
<
nsIRunnable
>
16
>
mEarlyRunners
;
VisualViewportResizeEventArray
mVisualViewportResizeEvents
;
ScrollEventArray
mScrollEvents
;
VisualViewportScrollEventArray
mVisualViewportScrollEvents
;
ScrollEventArray
mDelayedScrollEvents
;
AutoTArray
<
mozilla
:
:
PresShell
*
16
>
mResizeEventFlushObservers
;
AutoTArray
<
mozilla
:
:
PresShell
*
16
>
mDelayedResizeEventFlushObservers
;
AutoTArray
<
mozilla
:
:
PresShell
*
16
>
mStyleFlushObservers
;
AutoTArray
<
mozilla
:
:
PresShell
*
16
>
mLayoutFlushObservers
;
nsTArray
<
Document
*
>
mFrameRequestCallbackDocs
;
nsTArray
<
Document
*
>
mThrottledFrameRequestCallbackDocs
;
nsTObserverArray
<
nsAPostRefreshObserver
*
>
mPostRefreshObservers
;
nsTArray
<
mozilla
:
:
UniquePtr
<
mozilla
:
:
PendingFullscreenEvent
>
>
mPendingFullscreenEvents
;
AutoTArray
<
mozilla
:
:
AnimationEventDispatcher
*
16
>
mAnimationEventFlushObservers
;
void
BeginRefreshingImages
(
RequestTable
&
aEntries
mozilla
:
:
TimeStamp
aDesired
)
;
friend
class
mozilla
:
:
RefreshDriverTimer
;
static
void
Shutdown
(
)
;
static
bool
IsJankCritical
(
)
;
}
;
#
endif
