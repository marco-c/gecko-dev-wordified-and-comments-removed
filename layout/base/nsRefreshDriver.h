#
ifndef
nsRefreshDriver_h_
#
define
nsRefreshDriver_h_
#
include
"
mozilla
/
FlushType
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
nsTObserverArray
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTHashSet
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsRefreshObservers
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
dom
/
VisualViewport
.
h
"
#
include
"
mozilla
/
layers
/
TransactionIdAllocator
.
h
"
#
include
"
LayersTypes
.
h
"
#
include
"
GeckoProfiler
.
h
"
class
nsPresContext
;
class
imgIRequest
;
class
nsIRunnable
;
struct
DocumentFrameCallbacks
;
namespace
mozilla
{
class
AnimationEventDispatcher
;
class
PendingFullscreenEvent
;
class
PresShell
;
class
RefreshDriverTimer
;
class
Runnable
;
class
Task
;
}
class
nsRefreshDriver
final
:
public
mozilla
:
:
layers
:
:
TransactionIdAllocator
public
nsARefreshObserver
{
using
Document
=
mozilla
:
:
dom
:
:
Document
;
using
TransactionId
=
mozilla
:
:
layers
:
:
TransactionId
;
using
VVPResizeEvent
=
mozilla
:
:
dom
:
:
VisualViewport
:
:
VisualViewportResizeEvent
;
using
VVPScrollEvent
=
mozilla
:
:
dom
:
:
VisualViewport
:
:
VisualViewportScrollEvent
;
using
LogPresShellObserver
=
mozilla
:
:
LogPresShellObserver
;
public
:
explicit
nsRefreshDriver
(
nsPresContext
*
aPresContext
)
;
~
nsRefreshDriver
(
)
;
void
AdvanceTimeAndRefresh
(
int64_t
aMilliseconds
)
;
void
RestoreNormalRefresh
(
)
;
void
DoTick
(
)
;
bool
IsTestControllingRefreshesEnabled
(
)
const
{
return
mTestControllingRefreshes
;
}
mozilla
:
:
TimeStamp
MostRecentRefresh
(
bool
aEnsureTimerStarted
=
true
)
const
;
void
AddRefreshObserver
(
nsARefreshObserver
*
aObserver
mozilla
:
:
FlushType
aFlushType
const
char
*
aObserverDescription
)
;
bool
RemoveRefreshObserver
(
nsARefreshObserver
*
aObserver
mozilla
:
:
FlushType
aFlushType
)
;
void
PostVisualViewportResizeEvent
(
VVPResizeEvent
*
aResizeEvent
)
;
void
DispatchVisualViewportResizeEvents
(
)
;
void
PostScrollEvent
(
mozilla
:
:
Runnable
*
aScrollEvent
bool
aDelayed
=
false
)
;
void
PostScrollEndEvent
(
mozilla
:
:
Runnable
*
aScrollEndEvent
bool
aDelayed
=
false
)
;
void
DispatchScrollEvents
(
)
;
void
DispatchScrollEndEvents
(
)
;
void
PostVisualViewportScrollEvent
(
VVPScrollEvent
*
aScrollEvent
)
;
void
DispatchVisualViewportScrollEvents
(
)
;
MOZ_CAN_RUN_SCRIPT
void
DispatchResizeEvents
(
)
;
MOZ_CAN_RUN_SCRIPT
void
FlushLayoutOnPendingDocsAndFixUpFocus
(
)
;
void
AddPostRefreshObserver
(
nsAPostRefreshObserver
*
aObserver
)
;
void
AddPostRefreshObserver
(
mozilla
:
:
ManagedPostRefreshObserver
*
)
=
delete
;
void
RemovePostRefreshObserver
(
nsAPostRefreshObserver
*
aObserver
)
;
void
RemovePostRefreshObserver
(
mozilla
:
:
ManagedPostRefreshObserver
*
)
=
delete
;
void
AddImageRequest
(
imgIRequest
*
aRequest
)
;
void
RemoveImageRequest
(
imgIRequest
*
aRequest
)
;
void
EnterUserInputProcessing
(
)
{
mUserInputProcessingCount
+
+
;
}
void
ExitUserInputProcessing
(
)
{
MOZ_ASSERT
(
mUserInputProcessingCount
>
0
)
;
mUserInputProcessingCount
-
-
;
}
void
AddResizeEventFlushObserver
(
mozilla
:
:
PresShell
*
aPresShell
bool
aDelayed
=
false
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
mResizeEventFlushObservers
.
Contains
(
aPresShell
)
&
&
!
mDelayedResizeEventFlushObservers
.
Contains
(
aPresShell
)
"
Double
-
adding
resize
event
flush
observer
"
)
;
if
(
aDelayed
)
{
mDelayedResizeEventFlushObservers
.
AppendElement
(
aPresShell
)
;
}
else
{
mResizeEventFlushObservers
.
AppendElement
(
aPresShell
)
;
EnsureTimerStarted
(
)
;
}
}
void
RemoveResizeEventFlushObserver
(
mozilla
:
:
PresShell
*
aPresShell
)
{
mResizeEventFlushObservers
.
RemoveElement
(
aPresShell
)
;
mDelayedResizeEventFlushObservers
.
RemoveElement
(
aPresShell
)
;
}
void
AddStyleFlushObserver
(
mozilla
:
:
PresShell
*
aPresShell
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
IsStyleFlushObserver
(
aPresShell
)
"
Double
-
adding
style
flush
observer
"
)
;
LogPresShellObserver
:
:
LogDispatch
(
aPresShell
this
)
;
mStyleFlushObservers
.
AppendElement
(
aPresShell
)
;
EnsureTimerStarted
(
)
;
}
void
RemoveStyleFlushObserver
(
mozilla
:
:
PresShell
*
aPresShell
)
{
mStyleFlushObservers
.
RemoveElement
(
aPresShell
)
;
}
bool
IsStyleFlushObserver
(
mozilla
:
:
PresShell
*
aPresShell
)
{
return
mStyleFlushObservers
.
Contains
(
aPresShell
)
;
}
void
AddEarlyRunner
(
nsIRunnable
*
aRunnable
)
{
mEarlyRunners
.
AppendElement
(
aRunnable
)
;
EnsureTimerStarted
(
)
;
}
void
ScheduleViewManagerFlush
(
)
;
void
RevokeViewManagerFlush
(
)
{
mViewManagerFlushIsPending
=
false
;
}
bool
ViewManagerFlushIsPending
(
)
{
return
mViewManagerFlushIsPending
;
}
bool
HasScheduleFlush
(
)
{
return
mHasScheduleFlush
;
}
void
ClearHasScheduleFlush
(
)
{
mHasScheduleFlush
=
false
;
}
void
ScheduleFullscreenEvent
(
mozilla
:
:
UniquePtr
<
mozilla
:
:
PendingFullscreenEvent
>
aEvent
)
;
void
CancelPendingFullscreenEvents
(
Document
*
aDocument
)
;
void
ScheduleAnimationEventDispatch
(
mozilla
:
:
AnimationEventDispatcher
*
aDispatcher
)
{
NS_ASSERTION
(
!
mAnimationEventFlushObservers
.
Contains
(
aDispatcher
)
"
Double
-
adding
animation
event
flush
observer
"
)
;
mAnimationEventFlushObservers
.
AppendElement
(
aDispatcher
)
;
EnsureTimerStarted
(
)
;
}
void
CancelPendingAnimationEvents
(
mozilla
:
:
AnimationEventDispatcher
*
aDispatcher
)
;
void
ScheduleFrameVisibilityUpdate
(
)
{
mNeedToRecomputeVisibility
=
true
;
}
void
Disconnect
(
)
;
bool
IsFrozen
(
)
const
{
return
mFreezeCount
>
0
;
}
bool
IsThrottled
(
)
const
{
return
mThrottled
;
}
void
Freeze
(
)
;
void
Thaw
(
)
;
void
SetActivity
(
bool
aIsActive
)
;
nsPresContext
*
GetPresContext
(
)
const
;
void
CreateVsyncRefreshTimer
(
)
;
#
ifdef
DEBUG
bool
IsRefreshObserver
(
nsARefreshObserver
*
aObserver
mozilla
:
:
FlushType
aFlushType
)
;
#
endif
static
int32_t
DefaultInterval
(
)
;
static
double
HighRateMultiplier
(
)
;
bool
IsInRefresh
(
)
{
return
mInRefresh
;
}
void
SetIsResizeSuppressed
(
)
{
mResizeSuppressed
=
true
;
}
bool
IsResizeSuppressed
(
)
const
{
return
mResizeSuppressed
;
}
TransactionId
GetTransactionId
(
bool
aThrottle
)
override
;
TransactionId
LastTransactionId
(
)
const
override
;
void
NotifyTransactionCompleted
(
TransactionId
aTransactionId
)
override
;
void
RevokeTransactionId
(
TransactionId
aTransactionId
)
override
;
void
ClearPendingTransactions
(
)
override
;
void
ResetInitialTransactionId
(
TransactionId
aTransactionId
)
override
;
mozilla
:
:
TimeStamp
GetTransactionStart
(
)
override
;
mozilla
:
:
VsyncId
GetVsyncId
(
)
override
;
mozilla
:
:
TimeStamp
GetVsyncStart
(
)
override
;
bool
IsWaitingForPaint
(
mozilla
:
:
TimeStamp
aTime
)
;
void
ScheduleAutoFocusFlush
(
Document
*
aDocument
)
;
NS_IMETHOD_
(
MozExternalRefCountType
)
AddRef
(
void
)
override
{
return
TransactionIdAllocator
:
:
AddRef
(
)
;
}
NS_IMETHOD_
(
MozExternalRefCountType
)
Release
(
void
)
override
{
return
TransactionIdAllocator
:
:
Release
(
)
;
}
virtual
void
WillRefresh
(
mozilla
:
:
TimeStamp
aTime
)
override
;
enum
IdleCheck
{
OnlyThisProcessRefreshDriver
AllVsyncListeners
}
;
static
mozilla
:
:
TimeStamp
GetIdleDeadlineHint
(
mozilla
:
:
TimeStamp
aDefault
IdleCheck
aCheckType
)
;
static
mozilla
:
:
Maybe
<
mozilla
:
:
TimeStamp
>
GetNextTickHint
(
)
;
static
bool
IsRegularRateTimerTicking
(
)
;
static
void
DispatchIdleTaskAfterTickUnlessExists
(
mozilla
:
:
Task
*
aTask
)
;
static
void
CancelIdleTask
(
mozilla
:
:
Task
*
aTask
)
;
void
RunDelayedEventsSoon
(
)
;
void
InitializeTimer
(
)
{
MOZ_ASSERT
(
!
mActiveTimer
)
;
EnsureTimerStarted
(
)
;
}
bool
HasPendingTick
(
)
const
{
return
mActiveTimer
;
}
void
EnsureIntersectionObservationsUpdateHappens
(
)
{
EnsureTimerStarted
(
)
;
mNeedToUpdateIntersectionObservations
=
true
;
}
void
EnsureFrameRequestCallbacksHappen
(
)
{
EnsureTimerStarted
(
)
;
mNeedToRunFrameRequestCallbacks
=
true
;
}
void
EnsureResizeObserverUpdateHappens
(
)
{
EnsureTimerStarted
(
)
;
mNeedToUpdateResizeObservers
=
true
;
}
void
EnsureViewTransitionOperationsHappen
(
)
{
EnsureTimerStarted
(
)
;
mNeedToUpdateViewTransitions
=
true
;
}
void
EnsureAnimationUpdate
(
)
{
EnsureTimerStarted
(
)
;
mNeedToUpdateAnimations
=
true
;
}
void
ScheduleMediaQueryListenerUpdate
(
)
{
EnsureTimerStarted
(
)
;
mMightNeedMediaQueryListenerUpdate
=
true
;
}
void
EnsureContentRelevancyUpdateHappens
(
)
{
EnsureTimerStarted
(
)
;
mNeedToUpdateContentRelevancy
=
true
;
}
void
RegisterCompositionPayload
(
const
mozilla
:
:
layers
:
:
CompositionPayload
&
aPayload
)
;
enum
class
TickReasons
:
uint32_t
{
eNone
=
0
eHasObservers
=
1
<
<
0
eHasImageRequests
=
1
<
<
1
eNeedsToUpdateIntersectionObservations
=
1
<
<
2
eNeedsToUpdateContentRelevancy
=
1
<
<
3
eHasVisualViewportResizeEvents
=
1
<
<
4
eHasScrollEvents
=
1
<
<
5
eHasVisualViewportScrollEvents
=
1
<
<
6
eHasPendingMediaQueryListeners
=
1
<
<
7
eNeedsToNotifyResizeObservers
=
1
<
<
8
eRootNeedsMoreTicksForUserInput
=
1
<
<
9
eNeedsToUpdateAnimations
=
1
<
<
10
eNeedsToRunFrameRequestCallbacks
=
1
<
<
11
eNeedsToUpdateViewTransitions
=
1
<
<
12
}
;
void
AddForceNotifyContentfulPaintPresContext
(
nsPresContext
*
aPresContext
)
;
void
FlushForceNotifyContentfulPaintPresContext
(
)
;
void
FinishedVsyncTick
(
)
{
mAttemptedExtraTickSinceLastVsync
=
false
;
}
void
CancelFlushAutoFocus
(
Document
*
aDocument
)
;
private
:
typedef
nsTArray
<
RefPtr
<
VVPResizeEvent
>
>
VisualViewportResizeEventArray
;
typedef
nsTArray
<
RefPtr
<
mozilla
:
:
Runnable
>
>
ScrollEventArray
;
typedef
nsTArray
<
RefPtr
<
VVPScrollEvent
>
>
VisualViewportScrollEventArray
;
using
RequestTable
=
nsTHashSet
<
RefPtr
<
imgIRequest
>
>
;
struct
ImageStartData
{
ImageStartData
(
)
=
default
;
mozilla
:
:
Maybe
<
mozilla
:
:
TimeStamp
>
mStartTime
;
RequestTable
mEntries
;
}
;
typedef
nsClassHashtable
<
nsUint32HashKey
ImageStartData
>
ImageStartTable
;
struct
ObserverData
{
nsARefreshObserver
*
mObserver
;
const
char
*
mDescription
;
mozilla
:
:
TimeStamp
mRegisterTime
;
mozilla
:
:
MarkerInnerWindowId
mInnerWindowId
;
mozilla
:
:
UniquePtr
<
mozilla
:
:
ProfileChunkedBuffer
>
mCause
;
mozilla
:
:
FlushType
mFlushType
;
bool
operator
=
=
(
nsARefreshObserver
*
aObserver
)
const
{
return
mObserver
=
=
aObserver
;
}
operator
RefPtr
<
nsARefreshObserver
>
(
)
{
return
mObserver
;
}
}
;
using
ObserverArray
=
nsTObserverArray
<
ObserverData
>
;
MOZ_CAN_RUN_SCRIPT
void
FlushAutoFocusDocuments
(
)
;
void
RunFullscreenSteps
(
)
;
void
UpdateAnimationsAndSendEvents
(
)
;
MOZ_CAN_RUN_SCRIPT
void
RunVideoAndFrameRequestCallbacks
(
mozilla
:
:
TimeStamp
aNowTime
)
;
MOZ_CAN_RUN_SCRIPT
void
RunVideoFrameCallbacks
(
const
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
Document
>
>
&
mozilla
:
:
TimeStamp
aNowTime
)
;
MOZ_CAN_RUN_SCRIPT
void
RunFrameRequestCallbacks
(
const
nsTArray
<
RefPtr
<
mozilla
:
:
dom
:
:
Document
>
>
&
mozilla
:
:
TimeStamp
aNowTime
)
;
void
UpdateIntersectionObservations
(
mozilla
:
:
TimeStamp
aNowTime
)
;
void
UpdateRemoteFrameEffects
(
)
;
void
UpdateRelevancyOfContentVisibilityAutoFrames
(
)
;
void
PerformPendingViewTransitionOperations
(
)
;
MOZ_CAN_RUN_SCRIPT
void
DetermineProximityToViewportAndNotifyResizeObservers
(
)
;
void
MaybeIncreaseMeasuredTicksSinceLoading
(
)
;
void
EvaluateMediaQueriesAndReportChanges
(
)
;
enum
class
IsExtraTick
{
No
Yes
}
;
MOZ_CAN_RUN_SCRIPT
bool
TickObserverArray
(
uint32_t
aIdx
mozilla
:
:
TimeStamp
aNowTime
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
Tick
(
mozilla
:
:
VsyncId
aId
mozilla
:
:
TimeStamp
aNowTime
IsExtraTick
aIsExtraTick
=
IsExtraTick
:
:
No
)
;
enum
EnsureTimerStartedFlags
{
eNone
=
0
eForceAdjustTimer
=
1
<
<
0
eAllowTimeToGoBackwards
=
1
<
<
1
eNeverAdjustTimer
=
1
<
<
2
}
;
void
EnsureTimerStarted
(
EnsureTimerStartedFlags
aFlags
=
eNone
)
;
void
StopTimer
(
)
;
void
UpdateThrottledState
(
)
;
bool
HasObservers
(
)
const
;
void
AppendObserverDescriptionsToString
(
nsACString
&
aStr
)
const
;
uint32_t
ObserverCount
(
)
const
;
bool
HasImageRequests
(
)
const
;
bool
ShouldKeepTimerRunningWhileWaitingForFirstContentfulPaint
(
)
;
bool
ShouldKeepTimerRunningAfterPageLoad
(
)
;
ObserverArray
&
ArrayFor
(
mozilla
:
:
FlushType
aFlushType
)
;
void
DoRefresh
(
)
;
void
UpdateAnimatedImages
(
mozilla
:
:
TimeStamp
aPreviousRefresh
mozilla
:
:
TimeStamp
aNowTime
)
;
bool
HasReasonsToTick
(
)
const
{
return
GetReasonsToTick
(
)
!
=
TickReasons
:
:
eNone
;
}
TickReasons
GetReasonsToTick
(
)
const
;
void
AppendTickReasonsToString
(
TickReasons
aReasons
nsACString
&
aStr
)
const
;
double
GetRegularTimerInterval
(
)
const
;
static
double
GetThrottledTimerInterval
(
)
;
static
mozilla
:
:
TimeDuration
GetMinRecomputeVisibilityInterval
(
)
;
void
FinishedWaitingForTransaction
(
)
;
bool
CanDoCatchUpTick
(
)
;
bool
CanDoExtraTick
(
)
;
bool
AtPendingTransactionLimit
(
)
{
return
mPendingTransactions
.
Length
(
)
=
=
2
;
}
bool
TooManyPendingTransactions
(
)
{
return
mPendingTransactions
.
Length
(
)
>
=
2
;
}
mozilla
:
:
RefreshDriverTimer
*
ChooseTimer
(
)
;
mozilla
:
:
RefreshDriverTimer
*
mActiveTimer
;
RefPtr
<
mozilla
:
:
RefreshDriverTimer
>
mOwnTimer
;
mozilla
:
:
UniquePtr
<
mozilla
:
:
ProfileChunkedBuffer
>
mRefreshTimerStartedCause
;
mozilla
:
:
WeakPtr
<
nsPresContext
>
mPresContext
;
RefPtr
<
nsRefreshDriver
>
mRootRefresh
;
TransactionId
mNextTransactionId
;
AutoTArray
<
TransactionId
3
>
mPendingTransactions
;
uint32_t
mFreezeCount
;
uint32_t
mUserInputProcessingCount
=
0
;
const
mozilla
:
:
TimeDuration
mThrottledFrameRequestInterval
;
const
mozilla
:
:
TimeDuration
mMinRecomputeVisibilityInterval
;
mozilla
:
:
UniquePtr
<
mozilla
:
:
ProfileChunkedBuffer
>
mViewManagerFlushCause
;
bool
mThrottled
:
1
;
bool
mNeedToRecomputeVisibility
:
1
;
bool
mTestControllingRefreshes
:
1
;
bool
mViewManagerFlushIsPending
:
1
;
bool
mHasScheduleFlush
:
1
;
bool
mInRefresh
:
1
;
bool
mWaitingForTransaction
:
1
;
bool
mSkippedPaints
:
1
;
bool
mResizeSuppressed
:
1
;
bool
mNeedToUpdateIntersectionObservations
:
1
;
bool
mNeedToUpdateResizeObservers
:
1
;
bool
mNeedToUpdateViewTransitions
:
1
;
bool
mNeedToRunFrameRequestCallbacks
:
1
;
bool
mNeedToUpdateAnimations
:
1
;
bool
mMightNeedMediaQueryListenerUpdate
:
1
;
bool
mNeedToUpdateContentRelevancy
:
1
;
bool
mInNormalTick
:
1
;
bool
mAttemptedExtraTickSinceLastVsync
:
1
;
bool
mHasExceededAfterLoadTickPeriod
:
1
;
bool
mHasStartedTimerAtLeastOnce
:
1
;
mozilla
:
:
TimeStamp
mMostRecentRefresh
;
mozilla
:
:
TimeStamp
mTickStart
;
mozilla
:
:
VsyncId
mTickVsyncId
;
mozilla
:
:
TimeStamp
mTickVsyncTime
;
mozilla
:
:
TimeStamp
mNextThrottledFrameRequestTick
;
mozilla
:
:
TimeStamp
mNextRecomputeVisibilityTick
;
mozilla
:
:
TimeStamp
mBeforeFirstContentfulPaintTimerRunningLimit
;
ObserverArray
mObservers
[
3
]
;
nsTArray
<
mozilla
:
:
layers
:
:
CompositionPayload
>
mCompositionPayloads
;
RequestTable
mRequests
;
ImageStartTable
mStartTable
;
AutoTArray
<
nsCOMPtr
<
nsIRunnable
>
16
>
mEarlyRunners
;
VisualViewportResizeEventArray
mVisualViewportResizeEvents
;
ScrollEventArray
mScrollEvents
;
ScrollEventArray
mScrollEndEvents
;
VisualViewportScrollEventArray
mVisualViewportScrollEvents
;
ScrollEventArray
mDelayedScrollEvents
;
ScrollEventArray
mDelayedScrollEndEvents
;
AutoTArray
<
mozilla
:
:
PresShell
*
16
>
mResizeEventFlushObservers
;
AutoTArray
<
mozilla
:
:
PresShell
*
16
>
mDelayedResizeEventFlushObservers
;
AutoTArray
<
mozilla
:
:
PresShell
*
16
>
mStyleFlushObservers
;
nsTArray
<
RefPtr
<
Document
>
>
mAutoFocusFlushDocuments
;
nsTObserverArray
<
nsAPostRefreshObserver
*
>
mPostRefreshObservers
;
nsTArray
<
mozilla
:
:
UniquePtr
<
mozilla
:
:
PendingFullscreenEvent
>
>
mPendingFullscreenEvents
;
AutoTArray
<
mozilla
:
:
AnimationEventDispatcher
*
16
>
mAnimationEventFlushObservers
;
nsTArray
<
mozilla
:
:
WeakPtr
<
nsPresContext
>
>
mForceNotifyContentfulPaintPresContexts
;
void
BeginRefreshingImages
(
RequestTable
&
aEntries
mozilla
:
:
TimeStamp
aDesired
)
;
friend
class
mozilla
:
:
RefreshDriverTimer
;
static
void
Shutdown
(
)
;
}
;
#
endif
