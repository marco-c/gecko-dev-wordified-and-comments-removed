#
ifndef
mozilla_OverflowChangedTracker_h
#
define
mozilla_OverflowChangedTracker_h
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
{
class
OverflowChangedTracker
{
public
:
enum
ChangeKind
{
TRANSFORM_CHANGED
CHILDREN_CHANGED
}
;
OverflowChangedTracker
(
)
:
mSubtreeRoot
(
nullptr
)
{
}
~
OverflowChangedTracker
(
)
{
MOZ_ASSERT
(
mEntryList
.
IsEmpty
(
)
"
Need
to
flush
before
destroying
!
"
)
;
}
void
AddFrame
(
nsIFrame
*
aFrame
ChangeKind
aChangeKind
)
{
MOZ_ASSERT
(
aFrame
-
>
FrameMaintainsOverflow
(
)
"
Why
add
a
frame
that
doesn
'
t
maintain
overflow
to
the
tracker
?
"
)
;
AddFrameWithDepth
(
aFrame
aFrame
-
>
GetDepthInFrameTree
(
)
aChangeKind
)
;
}
void
RemoveFrame
(
nsIFrame
*
aFrame
)
{
if
(
mEntryList
.
IsEmpty
(
)
)
{
return
;
}
mEntryList
.
RemoveElementSorted
(
Entry
(
aFrame
aFrame
-
>
GetDepthInFrameTree
(
)
)
)
;
}
void
SetSubtreeRoot
(
const
nsIFrame
*
aSubtreeRoot
)
{
mSubtreeRoot
=
aSubtreeRoot
;
}
void
Flush
(
)
{
while
(
!
mEntryList
.
IsEmpty
(
)
)
{
Entry
entry
=
mEntryList
.
PopLastElement
(
)
;
nsIFrame
*
frame
=
entry
.
mFrame
;
bool
overflowChanged
=
false
;
if
(
entry
.
mChangeKind
=
=
CHILDREN_CHANGED
)
{
overflowChanged
=
frame
-
>
UpdateOverflow
(
)
;
}
else
{
MOZ_ASSERT
(
frame
-
>
GetProperty
(
nsIFrame
:
:
DebugInitialOverflowPropertyApplied
(
)
)
"
InitialOverflowProperty
must
be
set
first
.
"
)
;
OverflowAreas
*
overflow
=
frame
-
>
GetProperty
(
nsIFrame
:
:
InitialOverflowProperty
(
)
)
;
if
(
overflow
)
{
OverflowAreas
overflowCopy
=
*
overflow
;
frame
-
>
FinishAndStoreOverflow
(
overflowCopy
frame
-
>
GetSize
(
)
)
;
}
else
{
nsRect
bounds
(
nsPoint
(
0
0
)
frame
-
>
GetSize
(
)
)
;
OverflowAreas
boundsOverflow
;
boundsOverflow
.
SetAllTo
(
bounds
)
;
frame
-
>
FinishAndStoreOverflow
(
boundsOverflow
bounds
.
Size
(
)
)
;
}
overflowChanged
=
true
;
}
if
(
overflowChanged
)
{
nsIFrame
*
parent
=
frame
-
>
GetParent
(
)
;
if
(
parent
&
&
parent
!
=
mSubtreeRoot
&
&
parent
-
>
FrameMaintainsOverflow
(
)
)
{
AddFrameWithDepth
(
parent
entry
.
mDepth
-
1
CHILDREN_CHANGED
)
;
}
}
}
}
private
:
struct
Entry
{
Entry
(
nsIFrame
*
aFrame
uint32_t
aDepth
ChangeKind
aChangeKind
=
CHILDREN_CHANGED
)
:
mFrame
(
aFrame
)
mDepth
(
aDepth
)
mChangeKind
(
aChangeKind
)
{
}
bool
operator
=
=
(
const
Entry
&
aOther
)
const
{
return
mFrame
=
=
aOther
.
mFrame
;
}
bool
operator
<
(
const
Entry
&
aOther
)
const
{
if
(
mDepth
=
=
aOther
.
mDepth
)
{
return
mFrame
<
aOther
.
mFrame
;
}
return
mDepth
<
aOther
.
mDepth
;
}
static
int
compare
(
const
Entry
&
aOne
const
Entry
&
aTwo
)
{
if
(
aOne
=
=
aTwo
)
{
return
0
;
}
else
if
(
aOne
<
aTwo
)
{
return
-
1
;
}
else
{
return
1
;
}
}
nsIFrame
*
mFrame
;
uint32_t
mDepth
;
ChangeKind
mChangeKind
;
}
;
void
AddFrameWithDepth
(
nsIFrame
*
aFrame
uint32_t
aDepth
ChangeKind
aChangeKind
)
{
Entry
entry
(
aFrame
aDepth
aChangeKind
)
;
auto
index
=
mEntryList
.
IndexOfFirstElementGt
(
entry
)
;
if
(
index
>
0
&
&
mEntryList
[
index
-
1
]
=
=
entry
)
{
Entry
&
existing
=
mEntryList
[
index
-
1
]
;
existing
.
mChangeKind
=
std
:
:
max
(
existing
.
mChangeKind
aChangeKind
)
;
}
else
{
mEntryList
.
InsertElementAt
(
index
entry
)
;
}
}
nsTArray
<
Entry
>
mEntryList
;
const
nsIFrame
*
mSubtreeRoot
;
}
;
}
#
endif
