#
ifndef
mozilla_OverflowChangedTracker_h
#
define
mozilla_OverflowChangedTracker_h
#
include
"
mozilla
/
HashTable
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsTArray
.
h
"
namespace
mozilla
{
class
OverflowChangedTracker
{
public
:
enum
ChangeKind
{
TRANSFORM_CHANGED
CHILDREN_CHANGED
}
;
OverflowChangedTracker
(
)
:
mSubtreeRoot
(
nullptr
)
{
}
~
OverflowChangedTracker
(
)
{
NS_ASSERTION
(
mEntries
.
empty
(
)
"
Need
to
flush
before
destroying
!
"
)
;
}
void
AddFrame
(
nsIFrame
*
aFrame
ChangeKind
aChangeKind
)
{
MOZ_ASSERT
(
aFrame
-
>
FrameMaintainsOverflow
(
)
"
Why
add
a
frame
that
doesn
'
t
maintain
overflow
to
the
tracker
?
"
)
;
if
(
auto
p
=
mEntries
.
lookupForAdd
(
aFrame
)
)
{
p
-
>
value
(
)
=
std
:
:
max
(
p
-
>
value
(
)
aChangeKind
)
;
}
else
{
(
void
)
mEntries
.
add
(
p
aFrame
aChangeKind
)
;
}
}
void
RemoveFrame
(
nsIFrame
*
aFrame
)
{
if
(
!
mEntries
.
empty
(
)
)
{
mEntries
.
remove
(
aFrame
)
;
}
}
void
SetSubtreeRoot
(
const
nsIFrame
*
aSubtreeRoot
)
{
mSubtreeRoot
=
aSubtreeRoot
;
}
void
Flush
(
)
{
AutoTArray
<
Entry
8
>
sortedEntries
;
(
void
)
sortedEntries
.
SetCapacity
(
mEntries
.
count
(
)
fallible
)
;
for
(
auto
iter
=
mEntries
.
iter
(
)
;
!
iter
.
done
(
)
;
iter
.
next
(
)
)
{
nsIFrame
*
frame
=
iter
.
get
(
)
.
key
(
)
;
uint32_t
depth
=
frame
-
>
GetDepthInFrameTree
(
)
;
ChangeKind
kind
=
iter
.
get
(
)
.
value
(
)
;
if
(
!
sortedEntries
.
AppendElement
(
Entry
(
frame
depth
kind
)
fallible
)
)
{
break
;
}
}
mEntries
.
clearAndCompact
(
)
;
sortedEntries
.
Sort
(
)
;
while
(
!
sortedEntries
.
IsEmpty
(
)
)
{
Entry
entry
=
sortedEntries
.
PopLastElement
(
)
;
nsIFrame
*
frame
=
entry
.
mFrame
;
bool
overflowChanged
=
false
;
if
(
entry
.
mChangeKind
=
=
CHILDREN_CHANGED
)
{
overflowChanged
=
frame
-
>
UpdateOverflow
(
)
;
}
else
{
NS_ASSERTION
(
frame
-
>
GetProperty
(
nsIFrame
:
:
DebugInitialOverflowPropertyApplied
(
)
)
"
InitialOverflowProperty
must
be
set
first
.
"
)
;
OverflowAreas
*
overflow
=
frame
-
>
GetProperty
(
nsIFrame
:
:
InitialOverflowProperty
(
)
)
;
if
(
overflow
)
{
OverflowAreas
overflowCopy
=
*
overflow
;
frame
-
>
FinishAndStoreOverflow
(
overflowCopy
frame
-
>
GetSize
(
)
)
;
}
else
{
nsRect
bounds
(
nsPoint
(
0
0
)
frame
-
>
GetSize
(
)
)
;
OverflowAreas
boundsOverflow
;
boundsOverflow
.
SetAllTo
(
bounds
)
;
frame
-
>
FinishAndStoreOverflow
(
boundsOverflow
bounds
.
Size
(
)
)
;
}
overflowChanged
=
true
;
}
if
(
overflowChanged
)
{
nsIFrame
*
parent
=
frame
-
>
GetParent
(
)
;
if
(
parent
&
&
parent
!
=
mSubtreeRoot
&
&
parent
-
>
FrameMaintainsOverflow
(
)
)
{
Entry
parentEntry
(
parent
entry
.
mDepth
-
1
CHILDREN_CHANGED
)
;
auto
index
=
sortedEntries
.
IndexOfFirstElementGt
(
parentEntry
)
;
if
(
index
>
0
&
&
sortedEntries
[
index
-
1
]
=
=
parentEntry
)
{
Entry
&
existing
=
sortedEntries
[
index
-
1
]
;
existing
.
mChangeKind
=
std
:
:
max
(
existing
.
mChangeKind
CHILDREN_CHANGED
)
;
}
else
{
(
void
)
sortedEntries
.
InsertElementAt
(
index
parentEntry
fallible
)
;
}
}
}
}
}
private
:
struct
Entry
{
Entry
(
nsIFrame
*
aFrame
uint32_t
aDepth
ChangeKind
aChangeKind
=
CHILDREN_CHANGED
)
:
mFrame
(
aFrame
)
mDepth
(
aDepth
)
mChangeKind
(
aChangeKind
)
{
}
bool
operator
=
=
(
const
Entry
&
aOther
)
const
{
return
mFrame
=
=
aOther
.
mFrame
;
}
bool
operator
<
(
const
Entry
&
aOther
)
const
{
if
(
mDepth
=
=
aOther
.
mDepth
)
{
return
mFrame
<
aOther
.
mFrame
;
}
return
mDepth
<
aOther
.
mDepth
;
}
nsIFrame
*
mFrame
;
uint32_t
mDepth
;
ChangeKind
mChangeKind
;
}
;
HashMap
<
nsIFrame
*
ChangeKind
>
mEntries
;
const
nsIFrame
*
mSubtreeRoot
;
}
;
}
#
endif
