#
ifndef
mozilla_OverflowChangedTracker_h
#
define
mozilla_OverflowChangedTracker_h
#
include
"
nsIFrame
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
mozilla
/
SplayTree
.
h
"
namespace
mozilla
{
class
OverflowChangedTracker
{
public
:
enum
ChangeKind
{
TRANSFORM_CHANGED
CHILDREN_CHANGED
}
;
OverflowChangedTracker
(
)
:
mSubtreeRoot
(
nullptr
)
{
}
~
OverflowChangedTracker
(
)
{
NS_ASSERTION
(
mEntryList
.
empty
(
)
"
Need
to
flush
before
destroying
!
"
)
;
}
void
AddFrame
(
nsIFrame
*
aFrame
ChangeKind
aChangeKind
)
{
MOZ_ASSERT
(
aFrame
-
>
FrameMaintainsOverflow
(
)
"
Why
add
a
frame
that
doesn
'
t
maintain
overflow
to
the
tracker
?
"
)
;
uint32_t
depth
=
aFrame
-
>
GetDepthInFrameTree
(
)
;
Entry
*
entry
=
nullptr
;
if
(
!
mEntryList
.
empty
(
)
)
{
entry
=
mEntryList
.
find
(
Entry
(
aFrame
depth
)
)
;
}
if
(
entry
=
=
nullptr
)
{
mEntryList
.
insert
(
new
Entry
(
aFrame
depth
aChangeKind
)
)
;
}
else
{
entry
-
>
mChangeKind
=
std
:
:
max
(
entry
-
>
mChangeKind
aChangeKind
)
;
}
}
void
RemoveFrame
(
nsIFrame
*
aFrame
)
{
if
(
mEntryList
.
empty
(
)
)
{
return
;
}
uint32_t
depth
=
aFrame
-
>
GetDepthInFrameTree
(
)
;
if
(
mEntryList
.
find
(
Entry
(
aFrame
depth
)
)
)
{
delete
mEntryList
.
remove
(
Entry
(
aFrame
depth
)
)
;
}
}
void
SetSubtreeRoot
(
const
nsIFrame
*
aSubtreeRoot
)
{
mSubtreeRoot
=
aSubtreeRoot
;
}
void
Flush
(
)
{
while
(
!
mEntryList
.
empty
(
)
)
{
Entry
*
entry
=
mEntryList
.
removeMin
(
)
;
nsIFrame
*
frame
=
entry
-
>
mFrame
;
bool
overflowChanged
=
false
;
if
(
entry
-
>
mChangeKind
=
=
CHILDREN_CHANGED
)
{
overflowChanged
=
frame
-
>
UpdateOverflow
(
)
;
}
else
{
NS_ASSERTION
(
frame
-
>
GetProperty
(
nsIFrame
:
:
DebugInitialOverflowPropertyApplied
(
)
)
"
InitialOverflowProperty
must
be
set
first
.
"
)
;
nsOverflowAreas
*
overflow
=
frame
-
>
GetProperty
(
nsIFrame
:
:
InitialOverflowProperty
(
)
)
;
if
(
overflow
)
{
nsOverflowAreas
overflowCopy
=
*
overflow
;
frame
-
>
FinishAndStoreOverflow
(
overflowCopy
frame
-
>
GetSize
(
)
)
;
}
else
{
nsRect
bounds
(
nsPoint
(
0
0
)
frame
-
>
GetSize
(
)
)
;
nsOverflowAreas
boundsOverflow
;
boundsOverflow
.
SetAllTo
(
bounds
)
;
frame
-
>
FinishAndStoreOverflow
(
boundsOverflow
bounds
.
Size
(
)
)
;
}
overflowChanged
=
true
;
}
if
(
overflowChanged
)
{
nsIFrame
*
parent
=
frame
-
>
GetParent
(
)
;
while
(
parent
&
&
parent
!
=
mSubtreeRoot
&
&
parent
-
>
FrameMaintainsOverflow
(
)
&
&
parent
-
>
Combines3DTransformWithAncestors
(
)
)
{
parent
=
parent
-
>
GetParent
(
)
;
MOZ_ASSERT
(
parent
"
Root
frame
should
never
return
true
for
"
"
Combines3DTransformWithAncestors
"
)
;
}
if
(
parent
&
&
parent
!
=
mSubtreeRoot
&
&
parent
-
>
FrameMaintainsOverflow
(
)
)
{
Entry
*
parentEntry
=
mEntryList
.
find
(
Entry
(
parent
entry
-
>
mDepth
-
1
)
)
;
if
(
parentEntry
)
{
parentEntry
-
>
mChangeKind
=
std
:
:
max
(
parentEntry
-
>
mChangeKind
CHILDREN_CHANGED
)
;
}
else
{
mEntryList
.
insert
(
new
Entry
(
parent
entry
-
>
mDepth
-
1
CHILDREN_CHANGED
)
)
;
}
}
}
delete
entry
;
}
}
private
:
struct
Entry
:
SplayTreeNode
<
Entry
>
{
Entry
(
nsIFrame
*
aFrame
uint32_t
aDepth
ChangeKind
aChangeKind
=
CHILDREN_CHANGED
)
:
mFrame
(
aFrame
)
mDepth
(
aDepth
)
mChangeKind
(
aChangeKind
)
{
}
bool
operator
=
=
(
const
Entry
&
aOther
)
const
{
return
mFrame
=
=
aOther
.
mFrame
;
}
bool
operator
<
(
const
Entry
&
aOther
)
const
{
if
(
mDepth
=
=
aOther
.
mDepth
)
{
return
mFrame
<
aOther
.
mFrame
;
}
return
mDepth
>
aOther
.
mDepth
;
}
static
int
compare
(
const
Entry
&
aOne
const
Entry
&
aTwo
)
{
if
(
aOne
=
=
aTwo
)
{
return
0
;
}
else
if
(
aOne
<
aTwo
)
{
return
-
1
;
}
else
{
return
1
;
}
}
nsIFrame
*
mFrame
;
uint32_t
mDepth
;
ChangeKind
mChangeKind
;
}
;
SplayTree
<
Entry
Entry
>
mEntryList
;
const
nsIFrame
*
mSubtreeRoot
;
}
;
}
#
endif
