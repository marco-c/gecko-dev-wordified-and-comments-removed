#
ifndef
nsCounterManager_h_
#
define
nsCounterManager_h_
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
nsGenConList
.
h
"
#
include
"
nsClassHashtable
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
CounterStyleManager
.
h
"
class
nsCounterList
;
struct
nsCounterUseNode
;
struct
nsCounterChangeNode
;
struct
nsCounterNode
:
public
nsGenConNode
{
enum
Type
{
RESET
INCREMENT
SET
USE
}
;
Type
mType
;
int32_t
mValueAfter
=
0
;
nsCounterNode
*
mScopeStart
=
nullptr
;
nsCounterNode
*
mScopePrev
=
nullptr
;
inline
nsCounterUseNode
*
UseNode
(
)
;
inline
nsCounterChangeNode
*
ChangeNode
(
)
;
nsCounterNode
(
int32_t
aContentIndex
Type
aType
)
:
nsGenConNode
(
aContentIndex
)
mType
(
aType
)
{
}
inline
void
Calc
(
nsCounterList
*
aList
bool
aNotify
)
;
inline
bool
IsContentBasedReset
(
)
;
inline
bool
IsReversed
(
)
;
inline
bool
IsUnitializedIncrementNode
(
)
;
}
;
struct
nsCounterUseNode
:
public
nsCounterNode
{
mozilla
:
:
CounterStylePtr
mCounterStyle
;
nsString
mSeparator
;
bool
mAllCounters
=
false
;
bool
mForLegacyBullet
=
false
;
enum
ForLegacyBullet
{
ForLegacyBullet
}
;
nsCounterUseNode
(
enum
ForLegacyBullet
mozilla
:
:
CounterStylePtr
aCounterStyle
)
:
nsCounterNode
(
0
USE
)
mCounterStyle
(
std
:
:
move
(
aCounterStyle
)
)
mForLegacyBullet
(
true
)
{
}
nsCounterUseNode
(
mozilla
:
:
CounterStylePtr
aCounterStyle
nsString
aSeparator
uint32_t
aContentIndex
bool
aAllCounters
)
:
nsCounterNode
(
aContentIndex
USE
)
mCounterStyle
(
std
:
:
move
(
aCounterStyle
)
)
mSeparator
(
std
:
:
move
(
aSeparator
)
)
mAllCounters
(
aAllCounters
)
{
NS_ASSERTION
(
aContentIndex
<
=
INT32_MAX
"
out
of
range
"
)
;
}
bool
InitTextFrame
(
nsGenConList
*
aList
nsIFrame
*
aPseudoFrame
nsIFrame
*
aTextFrame
)
override
;
void
Calc
(
nsCounterList
*
aList
bool
aNotify
)
;
void
GetText
(
nsString
&
aResult
)
;
void
GetText
(
mozilla
:
:
WritingMode
aWM
mozilla
:
:
CounterStyle
*
aStyle
nsString
&
aResult
)
;
}
;
struct
nsCounterChangeNode
:
public
nsCounterNode
{
nsCounterChangeNode
(
nsIFrame
*
aPseudoFrame
nsCounterNode
:
:
Type
aChangeType
int32_t
aChangeValue
int32_t
aPropIndex
bool
aIsReversed
)
:
nsCounterNode
(
aPropIndex
+
(
aChangeType
=
=
RESET
?
(
INT32_MIN
)
:
(
aChangeType
=
=
INCREMENT
?
(
(
INT32_MIN
/
3
)
*
2
)
:
INT32_MIN
/
3
)
)
aChangeType
)
mChangeValue
(
aChangeValue
)
mIsReversed
(
aIsReversed
)
mSeenSetNode
(
false
)
{
NS_ASSERTION
(
aPropIndex
>
=
0
"
out
of
range
"
)
;
NS_ASSERTION
(
aChangeType
=
=
INCREMENT
|
|
aChangeType
=
=
SET
|
|
aChangeType
=
=
RESET
"
bad
type
"
)
;
mPseudoFrame
=
aPseudoFrame
;
CheckFrameAssertions
(
)
;
}
void
Calc
(
nsCounterList
*
aList
)
;
int32_t
mChangeValue
;
bool
mIsReversed
:
1
;
bool
mSeenSetNode
:
1
;
}
;
inline
nsCounterUseNode
*
nsCounterNode
:
:
UseNode
(
)
{
NS_ASSERTION
(
mType
=
=
USE
"
wrong
type
"
)
;
return
static_cast
<
nsCounterUseNode
*
>
(
this
)
;
}
inline
nsCounterChangeNode
*
nsCounterNode
:
:
ChangeNode
(
)
{
MOZ_ASSERT
(
mType
=
=
INCREMENT
|
|
mType
=
=
SET
|
|
mType
=
=
RESET
)
;
return
static_cast
<
nsCounterChangeNode
*
>
(
this
)
;
}
inline
void
nsCounterNode
:
:
Calc
(
nsCounterList
*
aList
bool
aNotify
)
{
if
(
mType
=
=
USE
)
UseNode
(
)
-
>
Calc
(
aList
aNotify
)
;
else
ChangeNode
(
)
-
>
Calc
(
aList
)
;
}
inline
bool
nsCounterNode
:
:
IsContentBasedReset
(
)
{
return
mType
=
=
RESET
&
&
ChangeNode
(
)
-
>
mChangeValue
=
=
std
:
:
numeric_limits
<
int32_t
>
:
:
min
(
)
;
}
inline
bool
nsCounterNode
:
:
IsReversed
(
)
{
return
mType
=
=
RESET
&
&
ChangeNode
(
)
-
>
mIsReversed
;
}
inline
bool
nsCounterNode
:
:
IsUnitializedIncrementNode
(
)
{
return
mType
=
=
INCREMENT
&
&
ChangeNode
(
)
-
>
mChangeValue
=
=
std
:
:
numeric_limits
<
int32_t
>
:
:
min
(
)
;
}
class
nsCounterList
:
public
nsGenConList
{
public
:
nsCounterList
(
)
:
nsGenConList
(
)
mDirty
(
false
)
{
}
nsCounterNode
*
GetFirstNodeFor
(
nsIFrame
*
aFrame
)
const
{
return
static_cast
<
nsCounterNode
*
>
(
nsGenConList
:
:
GetFirstNodeFor
(
aFrame
)
)
;
}
void
Insert
(
nsCounterNode
*
aNode
)
{
nsGenConList
:
:
Insert
(
aNode
)
;
if
(
MOZ_LIKELY
(
!
IsDirty
(
)
)
)
{
SetScope
(
aNode
)
;
}
}
nsCounterNode
*
First
(
)
{
return
static_cast
<
nsCounterNode
*
>
(
mList
.
getFirst
(
)
)
;
}
static
nsCounterNode
*
Next
(
nsCounterNode
*
aNode
)
{
return
static_cast
<
nsCounterNode
*
>
(
nsGenConList
:
:
Next
(
aNode
)
)
;
}
static
nsCounterNode
*
Prev
(
nsCounterNode
*
aNode
)
{
return
static_cast
<
nsCounterNode
*
>
(
nsGenConList
:
:
Prev
(
aNode
)
)
;
}
static
int32_t
ValueBefore
(
nsCounterNode
*
aNode
)
{
return
aNode
-
>
mScopePrev
?
aNode
-
>
mScopePrev
-
>
mValueAfter
:
0
;
}
void
SetScope
(
nsCounterNode
*
aNode
)
;
void
RecalcAll
(
)
;
bool
IsDirty
(
)
{
return
mDirty
;
}
void
SetDirty
(
)
{
mDirty
=
true
;
}
private
:
bool
mDirty
;
}
;
class
nsCounterManager
{
public
:
bool
AddCounterChanges
(
nsIFrame
*
aFrame
)
;
nsCounterList
*
CounterListFor
(
nsAtom
*
aCounterName
)
;
void
RecalcAll
(
)
;
void
SetAllDirty
(
)
;
bool
DestroyNodesFor
(
nsIFrame
*
aFrame
)
;
void
Clear
(
)
{
mNames
.
Clear
(
)
;
}
#
ifdef
ACCESSIBILITY
void
GetSpokenCounterText
(
nsIFrame
*
aFrame
nsAString
&
aText
)
const
;
#
endif
#
if
defined
(
DEBUG
)
|
|
defined
(
MOZ_LAYOUT_DEBUGGER
)
void
Dump
(
)
const
;
#
endif
static
int32_t
IncrementCounter
(
int32_t
aOldValue
int32_t
aIncrement
)
{
int32_t
newValue
=
int32_t
(
uint32_t
(
aOldValue
)
+
uint32_t
(
aIncrement
)
)
;
if
(
(
aIncrement
>
0
)
!
=
(
newValue
>
aOldValue
)
)
{
newValue
=
aOldValue
;
}
return
newValue
;
}
private
:
nsClassHashtable
<
nsRefPtrHashKey
<
nsAtom
>
nsCounterList
>
mNames
;
}
;
#
endif
