#
ifndef
AnchorPositioningUtils_h__
#
define
AnchorPositioningUtils_h__
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsTHashMap
.
h
"
class
nsAtom
;
class
nsIFrame
;
template
<
class
T
>
class
nsTArray
;
template
<
class
T
>
class
CopyableTArray
;
namespace
mozilla
{
struct
AnchorPosInfo
{
nsRect
mRect
;
const
nsIFrame
*
mContainingBlock
;
}
;
struct
AnchorPosResolutionData
{
nsSize
mSize
;
mozilla
:
:
Maybe
<
nsPoint
>
mOrigin
;
}
;
class
AnchorPosReferenceData
{
private
:
using
Map
=
nsTHashMap
<
RefPtr
<
const
nsAtom
>
mozilla
:
:
Maybe
<
AnchorPosResolutionData
>
>
;
public
:
using
Value
=
mozilla
:
:
Maybe
<
AnchorPosResolutionData
>
;
AnchorPosReferenceData
(
)
=
default
;
AnchorPosReferenceData
(
const
AnchorPosReferenceData
&
)
=
delete
;
AnchorPosReferenceData
(
AnchorPosReferenceData
&
&
)
=
default
;
AnchorPosReferenceData
&
operator
=
(
const
AnchorPosReferenceData
&
)
=
delete
;
AnchorPosReferenceData
&
operator
=
(
AnchorPosReferenceData
&
&
)
=
default
;
struct
Result
{
bool
mAlreadyResolved
;
Value
*
mEntry
;
}
;
Result
InsertOrModify
(
const
nsAtom
*
aAnchorName
bool
aNeedOffset
)
;
const
Value
*
Lookup
(
const
nsAtom
*
aAnchorName
)
const
;
bool
IsEmpty
(
)
const
{
return
mMap
.
IsEmpty
(
)
;
}
Map
:
:
const_iterator
begin
(
)
const
{
return
mMap
.
cbegin
(
)
;
}
Map
:
:
const_iterator
end
(
)
const
{
return
mMap
.
cend
(
)
;
}
private
:
Map
mMap
;
}
;
struct
StylePositionArea
;
class
WritingMode
;
enum
class
StylePositionTryFallbacksTryTacticKeyword
:
uint8_t
;
using
StylePositionTryFallbacksTryTactic
=
CopyableTArray
<
StylePositionTryFallbacksTryTacticKeyword
>
;
struct
AnchorPositioningUtils
{
static
nsIFrame
*
FindFirstAcceptableAnchor
(
const
nsAtom
*
aName
const
nsIFrame
*
aPositionedFrame
const
nsTArray
<
nsIFrame
*
>
&
aPossibleAnchorFrames
)
;
static
Maybe
<
AnchorPosInfo
>
GetAnchorPosRect
(
const
nsIFrame
*
aAbsoluteContainingBlock
const
nsIFrame
*
aAnchor
bool
aCBRectIsvalid
Maybe
<
AnchorPosResolutionData
>
*
aReferencedAnchorsEntry
)
;
static
nsRect
AdjustAbsoluteContainingBlockRectForPositionArea
(
const
nsRect
&
aAnchorRect
const
nsRect
&
aCBRect
WritingMode
aPositionedWM
WritingMode
aCBWM
const
StylePositionArea
&
aPosArea
)
;
static
const
nsAtom
*
GetUsedAnchorName
(
const
nsIFrame
*
aPositioned
const
nsAtom
*
aAnchorName
)
;
static
const
nsIFrame
*
GetAnchorPosImplicitAnchor
(
const
nsIFrame
*
aFrame
)
;
struct
DefaultAnchorInfo
{
const
nsAtom
*
mName
=
nullptr
;
Maybe
<
nsRect
>
mRect
;
}
;
static
DefaultAnchorInfo
GetDefaultAnchor
(
const
nsIFrame
*
aPositioned
bool
aCBRectIsValid
AnchorPosReferenceData
*
aAnchorPosReferenceData
)
;
}
;
}
#
endif
