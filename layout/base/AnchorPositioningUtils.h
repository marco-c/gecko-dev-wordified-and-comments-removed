#
ifndef
AnchorPositioningUtils_h__
#
define
AnchorPositioningUtils_h__
#
include
"
WritingModes
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsTHashMap
.
h
"
class
nsAtom
;
class
nsIFrame
;
template
<
class
T
>
class
nsTArray
;
template
<
class
T
>
class
CopyableTArray
;
namespace
mozilla
{
struct
AnchorPosInfo
{
nsRect
mRect
;
bool
mCompensatesForScroll
;
}
;
class
DistanceToNearestScrollContainer
{
public
:
DistanceToNearestScrollContainer
(
)
=
default
;
explicit
DistanceToNearestScrollContainer
(
uint32_t
aDistance
)
:
mDistance
{
aDistance
}
{
}
bool
Valid
(
)
const
{
return
mDistance
!
=
kInvalid
;
}
bool
operator
=
=
(
const
DistanceToNearestScrollContainer
&
)
const
=
default
;
bool
operator
!
=
(
const
DistanceToNearestScrollContainer
&
)
const
=
default
;
private
:
static
constexpr
uint32_t
kInvalid
=
0
;
uint32_t
mDistance
=
kInvalid
;
}
;
struct
AnchorPosOffsetData
{
nsPoint
mOrigin
;
bool
mCompensatesForScroll
=
false
;
DistanceToNearestScrollContainer
mDistanceToNearestScrollContainer
;
}
;
struct
AnchorPosResolutionData
{
nsSize
mSize
;
Maybe
<
AnchorPosOffsetData
>
mOffsetData
;
}
;
class
AnchorPosReferenceData
{
private
:
using
ResolutionMap
=
nsTHashMap
<
RefPtr
<
const
nsAtom
>
mozilla
:
:
Maybe
<
AnchorPosResolutionData
>
>
;
public
:
struct
PositionTryBackup
{
mozilla
:
:
PhysicalAxes
mCompensatingForScroll
;
nsPoint
mDefaultScrollShift
;
nsRect
mAdjustedContainingBlock
;
}
;
using
Value
=
mozilla
:
:
Maybe
<
AnchorPosResolutionData
>
;
AnchorPosReferenceData
(
)
=
default
;
AnchorPosReferenceData
(
const
AnchorPosReferenceData
&
)
=
delete
;
AnchorPosReferenceData
(
AnchorPosReferenceData
&
&
)
=
default
;
AnchorPosReferenceData
&
operator
=
(
const
AnchorPosReferenceData
&
)
=
delete
;
AnchorPosReferenceData
&
operator
=
(
AnchorPosReferenceData
&
&
)
=
default
;
struct
Result
{
bool
mAlreadyResolved
;
Value
*
mEntry
;
}
;
Result
InsertOrModify
(
const
nsAtom
*
aAnchorName
bool
aNeedOffset
)
;
const
Value
*
Lookup
(
const
nsAtom
*
aAnchorName
)
const
;
bool
IsEmpty
(
)
const
{
return
mMap
.
IsEmpty
(
)
;
}
ResolutionMap
:
:
const_iterator
begin
(
)
const
{
return
mMap
.
cbegin
(
)
;
}
ResolutionMap
:
:
const_iterator
end
(
)
const
{
return
mMap
.
cend
(
)
;
}
void
AdjustCompensatingForScroll
(
const
mozilla
:
:
PhysicalAxes
&
aAxes
)
{
mCompensatingForScroll
+
=
aAxes
;
}
mozilla
:
:
PhysicalAxes
CompensatingForScrollAxes
(
)
const
{
return
mCompensatingForScroll
;
}
PositionTryBackup
TryPositionWithSameDefaultAnchor
(
)
{
auto
compensatingForScroll
=
std
:
:
exchange
(
mCompensatingForScroll
{
}
)
;
auto
defaultScrollShift
=
std
:
:
exchange
(
mDefaultScrollShift
{
}
)
;
auto
adjustedContainingBlock
=
std
:
:
exchange
(
mAdjustedContainingBlock
{
}
)
;
return
{
compensatingForScroll
defaultScrollShift
adjustedContainingBlock
}
;
}
void
UndoTryPositionWithSameDefaultAnchor
(
PositionTryBackup
&
&
aBackup
)
{
mCompensatingForScroll
=
aBackup
.
mCompensatingForScroll
;
mDefaultScrollShift
=
aBackup
.
mDefaultScrollShift
;
mAdjustedContainingBlock
=
aBackup
.
mAdjustedContainingBlock
;
}
DistanceToNearestScrollContainer
mDistanceToDefaultScrollContainer
;
nsPoint
mDefaultScrollShift
;
nsRect
mOriginalContainingBlockRect
;
nsRect
mAdjustedContainingBlock
;
RefPtr
<
const
nsAtom
>
mDefaultAnchorName
;
private
:
ResolutionMap
mMap
;
mozilla
:
:
PhysicalAxes
mCompensatingForScroll
;
}
;
struct
LastSuccessfulPositionData
{
uint32_t
mIndex
=
0
;
bool
mTriedAllFallbacks
=
false
;
}
;
struct
StylePositionArea
;
class
WritingMode
;
struct
AnchorPosDefaultAnchorCache
{
const
nsIFrame
*
mAnchor
=
nullptr
;
const
nsIFrame
*
mScrollContainer
=
nullptr
;
AnchorPosDefaultAnchorCache
(
)
=
default
;
AnchorPosDefaultAnchorCache
(
const
nsIFrame
*
aAnchor
const
nsIFrame
*
aScrollContainer
)
;
}
;
struct
AnchorPosResolutionCache
{
AnchorPosReferenceData
*
mReferenceData
=
nullptr
;
AnchorPosDefaultAnchorCache
mDefaultAnchorCache
;
using
PositionTryBackup
=
AnchorPosReferenceData
:
:
PositionTryBackup
;
PositionTryBackup
TryPositionWithSameDefaultAnchor
(
)
{
return
mReferenceData
-
>
TryPositionWithSameDefaultAnchor
(
)
;
}
void
UndoTryPositionWithSameDefaultAnchor
(
PositionTryBackup
&
&
aBackup
)
{
mReferenceData
-
>
UndoTryPositionWithSameDefaultAnchor
(
std
:
:
move
(
aBackup
)
)
;
}
using
PositionTryFullBackup
=
std
:
:
pair
<
AnchorPosReferenceData
AnchorPosDefaultAnchorCache
>
;
PositionTryFullBackup
TryPositionWithDifferentDefaultAnchor
(
)
{
auto
referenceData
=
std
:
:
move
(
*
mReferenceData
)
;
*
mReferenceData
=
{
}
;
return
std
:
:
make_pair
(
std
:
:
move
(
referenceData
)
std
:
:
exchange
(
mDefaultAnchorCache
AnchorPosDefaultAnchorCache
{
}
)
)
;
}
void
UndoTryPositionWithDifferentDefaultAnchor
(
PositionTryFullBackup
&
&
aBackup
)
{
*
mReferenceData
=
std
:
:
move
(
aBackup
.
first
)
;
std
:
:
exchange
(
mDefaultAnchorCache
aBackup
.
second
)
;
}
}
;
enum
class
StylePositionTryFallbacksTryTacticKeyword
:
uint8_t
;
using
StylePositionTryFallbacksTryTactic
=
CopyableTArray
<
StylePositionTryFallbacksTryTacticKeyword
>
;
struct
AnchorPositioningUtils
{
static
nsIFrame
*
FindFirstAcceptableAnchor
(
const
nsAtom
*
aName
const
nsIFrame
*
aPositionedFrame
const
nsTArray
<
nsIFrame
*
>
&
aPossibleAnchorFrames
)
;
static
Maybe
<
nsRect
>
GetAnchorPosRect
(
const
nsIFrame
*
aAbsoluteContainingBlock
const
nsIFrame
*
aAnchor
bool
aCBRectIsvalid
)
;
static
Maybe
<
AnchorPosInfo
>
ResolveAnchorPosRect
(
const
nsIFrame
*
aPositioned
const
nsIFrame
*
aAbsoluteContainingBlock
const
nsAtom
*
aAnchorName
bool
aCBRectIsvalid
AnchorPosResolutionCache
*
aResolutionCache
)
;
static
Maybe
<
nsSize
>
ResolveAnchorPosSize
(
const
nsIFrame
*
aPositioned
const
nsAtom
*
aAnchorName
AnchorPosResolutionCache
*
aResolutionCache
)
;
static
nsRect
AdjustAbsoluteContainingBlockRectForPositionArea
(
const
nsRect
&
aAnchorRect
const
nsRect
&
aCBRect
WritingMode
aPositionedWM
WritingMode
aCBWM
const
StylePositionArea
&
aPosArea
StylePositionArea
*
aOutResolvedArea
)
;
static
const
nsAtom
*
GetUsedAnchorName
(
const
nsIFrame
*
aPositioned
const
nsAtom
*
aAnchorName
)
;
static
nsIFrame
*
GetAnchorPosImplicitAnchor
(
const
nsIFrame
*
aFrame
)
;
struct
NearestScrollFrameInfo
{
const
nsIFrame
*
mScrollContainer
=
nullptr
;
DistanceToNearestScrollContainer
mDistance
;
}
;
static
NearestScrollFrameInfo
GetNearestScrollFrame
(
const
nsIFrame
*
aFrame
)
;
static
nsPoint
GetScrollOffsetFor
(
PhysicalAxes
aAxes
const
nsIFrame
*
aPositioned
const
AnchorPosDefaultAnchorCache
&
aDefaultAnchorCache
)
;
struct
ContainingBlockInfo
{
static
ContainingBlockInfo
ExplicitCBFrameSize
(
const
nsRect
&
aContainingBlockRect
)
;
static
ContainingBlockInfo
UseCBFrameSize
(
const
nsIFrame
*
aPositioned
)
;
nsRect
GetContainingBlockRect
(
)
const
{
return
mRect
;
}
private
:
explicit
ContainingBlockInfo
(
const
nsRect
&
aRect
)
:
mRect
{
aRect
}
{
}
nsRect
mRect
;
}
;
static
bool
FitsInContainingBlock
(
const
nsIFrame
*
aPositioned
const
AnchorPosReferenceData
&
)
;
static
nsIFrame
*
GetAnchorThatFrameScrollsWith
(
nsIFrame
*
aFrame
)
;
static
bool
TriggerLayoutOnOverflow
(
PresShell
*
aPresShell
bool
aEvaluateAllFallbacksIfNeeded
)
;
}
;
}
#
endif
