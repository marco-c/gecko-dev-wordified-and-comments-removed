#
include
"
gtest
/
gtest
.
h
"
#
include
"
gmock
/
gmock
.
h
"
#
include
<
string
>
#
include
"
AccessibleCaret
.
h
"
#
include
"
AccessibleCaretManager
.
h
"
using
:
:
testing
:
:
DefaultValue
;
using
:
:
testing
:
:
Eq
;
using
:
:
testing
:
:
InSequence
;
using
:
:
testing
:
:
MockFunction
;
using
:
:
testing
:
:
Return
;
using
:
:
testing
:
:
_
;
namespace
mozilla
{
using
dom
:
:
CaretChangedReason
;
class
AccessibleCaretManagerTester
:
public
:
:
testing
:
:
Test
{
public
:
class
MockAccessibleCaret
:
public
AccessibleCaret
{
public
:
MockAccessibleCaret
(
)
:
AccessibleCaret
(
nullptr
)
{
}
virtual
void
SetAppearance
(
Appearance
aAppearance
)
override
{
mAppearance
=
aAppearance
;
}
virtual
void
SetSelectionBarEnabled
(
bool
aEnabled
)
override
{
mSelectionBarEnabled
=
aEnabled
;
}
MOCK_METHOD2
(
SetPosition
PositionChangedResult
(
nsIFrame
*
aFrame
int32_t
aOffset
)
)
;
}
;
class
MockAccessibleCaretManager
:
public
AccessibleCaretManager
{
public
:
using
CaretMode
=
AccessibleCaretManager
:
:
CaretMode
;
using
AccessibleCaretManager
:
:
UpdateCarets
;
MockAccessibleCaretManager
(
)
:
AccessibleCaretManager
(
nullptr
)
{
mFirstCaret
=
MakeUnique
<
MockAccessibleCaret
>
(
)
;
mSecondCaret
=
MakeUnique
<
MockAccessibleCaret
>
(
)
;
}
MockAccessibleCaret
&
FirstCaret
(
)
{
return
static_cast
<
MockAccessibleCaret
&
>
(
*
mFirstCaret
)
;
}
MockAccessibleCaret
&
SecondCaret
(
)
{
return
static_cast
<
MockAccessibleCaret
&
>
(
*
mSecondCaret
)
;
}
virtual
bool
CompareTreePosition
(
nsIFrame
*
aStartFrame
nsIFrame
*
aEndFrame
)
const
override
{
return
true
;
}
virtual
bool
IsCaretDisplayableInCursorMode
(
nsIFrame
*
*
aOutFrame
=
nullptr
int32_t
*
aOutOffset
=
nullptr
)
const
override
{
return
true
;
}
virtual
void
UpdateCaretsForTilt
(
)
override
{
}
MOCK_CONST_METHOD0
(
GetCaretMode
CaretMode
(
)
)
;
MOCK_CONST_METHOD1
(
DispatchCaretStateChangedEvent
void
(
CaretChangedReason
aReason
)
)
;
MOCK_CONST_METHOD1
(
HasNonEmptyTextContent
bool
(
nsINode
*
aNode
)
)
;
}
;
using
Appearance
=
AccessibleCaret
:
:
Appearance
;
using
PositionChangedResult
=
AccessibleCaret
:
:
PositionChangedResult
;
using
CaretMode
=
MockAccessibleCaretManager
:
:
CaretMode
;
AccessibleCaretManagerTester
(
)
{
DefaultValue
<
CaretMode
>
:
:
Set
(
CaretMode
:
:
None
)
;
DefaultValue
<
PositionChangedResult
>
:
:
Set
(
PositionChangedResult
:
:
NotChanged
)
;
EXPECT_CALL
(
mManager
.
FirstCaret
(
)
SetPosition
(
_
_
)
)
.
WillRepeatedly
(
Return
(
PositionChangedResult
:
:
Changed
)
)
;
EXPECT_CALL
(
mManager
.
SecondCaret
(
)
SetPosition
(
_
_
)
)
.
WillRepeatedly
(
Return
(
PositionChangedResult
:
:
Changed
)
)
;
}
AccessibleCaret
:
:
Appearance
FirstCaretAppearance
(
)
{
return
mManager
.
FirstCaret
(
)
.
GetAppearance
(
)
;
}
AccessibleCaret
:
:
Appearance
SecondCaretAppearance
(
)
{
return
mManager
.
SecondCaret
(
)
.
GetAppearance
(
)
;
}
MockAccessibleCaretManager
mManager
;
}
;
TEST_F
(
AccessibleCaretManagerTester
TestUpdatesInSelectionMode
)
{
EXPECT_CALL
(
mManager
GetCaretMode
(
)
)
.
WillRepeatedly
(
Return
(
CaretMode
:
:
Selection
)
)
;
EXPECT_CALL
(
mManager
DispatchCaretStateChangedEvent
(
CaretChangedReason
:
:
Updateposition
)
)
.
Times
(
3
)
;
mManager
.
UpdateCarets
(
)
;
EXPECT_EQ
(
FirstCaretAppearance
(
)
Appearance
:
:
Normal
)
;
EXPECT_EQ
(
SecondCaretAppearance
(
)
Appearance
:
:
Normal
)
;
mManager
.
OnReflow
(
)
;
EXPECT_EQ
(
FirstCaretAppearance
(
)
Appearance
:
:
Normal
)
;
EXPECT_EQ
(
SecondCaretAppearance
(
)
Appearance
:
:
Normal
)
;
mManager
.
OnScrollPositionChanged
(
)
;
EXPECT_EQ
(
FirstCaretAppearance
(
)
Appearance
:
:
Normal
)
;
EXPECT_EQ
(
SecondCaretAppearance
(
)
Appearance
:
:
Normal
)
;
}
TEST_F
(
AccessibleCaretManagerTester
TestUpdatesInCursorModeOnNonEmptyContent
)
{
EXPECT_CALL
(
mManager
GetCaretMode
(
)
)
.
WillRepeatedly
(
Return
(
CaretMode
:
:
Cursor
)
)
;
EXPECT_CALL
(
mManager
HasNonEmptyTextContent
(
_
)
)
.
WillRepeatedly
(
Return
(
true
)
)
;
MockFunction
<
void
(
std
:
:
string
aCheckPointName
)
>
check
;
{
InSequence
dummy
;
EXPECT_CALL
(
mManager
DispatchCaretStateChangedEvent
(
CaretChangedReason
:
:
Updateposition
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
check
Call
(
"
mouse
down
"
)
)
;
EXPECT_CALL
(
mManager
DispatchCaretStateChangedEvent
(
CaretChangedReason
:
:
Updateposition
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
check
Call
(
"
reflow
"
)
)
;
EXPECT_CALL
(
mManager
DispatchCaretStateChangedEvent
(
CaretChangedReason
:
:
Visibilitychange
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
check
Call
(
"
blur
"
)
)
;
EXPECT_CALL
(
mManager
DispatchCaretStateChangedEvent
(
CaretChangedReason
:
:
Updateposition
)
)
.
Times
(
1
)
;
EXPECT_CALL
(
check
Call
(
"
mouse
up
"
)
)
;
EXPECT_CALL
(
mManager
DispatchCaretStateChangedEvent
(
CaretChangedReason
:
:
Updateposition
)
)
.
Times
(
1
)
;
}
mManager
.
OnSelectionChanged
(
nullptr
nullptr
nsISelectionListener
:
:
DRAG_REASON
|
nsISelectionListener
:
:
MOUSEDOWN_REASON
)
;
EXPECT_EQ
(
FirstCaretAppearance
(
)
Appearance
:
:
Normal
)
;
check
.
Call
(
"
mouse
down
"
)
;
mManager
.
OnReflow
(
)
;
EXPECT_EQ
(
FirstCaretAppearance
(
)
Appearance
:
:
Normal
)
;
check
.
Call
(
"
reflow
"
)
;
mManager
.
OnBlur
(
)
;
EXPECT_EQ
(
FirstCaretAppearance
(
)
Appearance
:
:
None
)
;
check
.
Call
(
"
blur
"
)
;
mManager
.
OnSelectionChanged
(
nullptr
nullptr
nsISelectionListener
:
:
MOUSEUP_REASON
)
;
EXPECT_EQ
(
FirstCaretAppearance
(
)
Appearance
:
:
Normal
)
;
check
.
Call
(
"
mouse
up
"
)
;
mManager
.
OnScrollPositionChanged
(
)
;
EXPECT_EQ
(
FirstCaretAppearance
(
)
Appearance
:
:
Normal
)
;
}
}
