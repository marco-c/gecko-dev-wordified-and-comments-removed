#
ifndef
mozilla_UniqueOrNonOwningPtr_h
#
define
mozilla_UniqueOrNonOwningPtr_h
#
include
<
cstdint
>
#
include
<
utility
>
#
include
"
mozilla
/
Assertions
.
h
"
namespace
mozilla
{
template
<
typename
T
>
class
UniqueOrNonOwningPtr
;
namespace
detail
{
template
<
typename
T
>
struct
UniqueOfUniqueOrNonOwningSelector
{
using
SingleObject
=
UniqueOrNonOwningPtr
<
T
>
;
}
;
template
<
typename
T
>
struct
UniqueOfUniqueOrNonOwningSelector
<
T
[
]
>
;
template
<
typename
T
decltype
(
sizeof
(
int
)
)
N
>
struct
UniqueOfUniqueOrNonOwningSelector
<
T
[
N
]
>
;
}
template
<
typename
T
typename
.
.
.
Args
>
typename
detail
:
:
UniqueOfUniqueOrNonOwningSelector
<
T
>
:
:
SingleObject
MakeUniqueOfUniqueOrNonOwning
(
Args
&
&
.
.
.
aArgs
)
{
return
UniqueOrNonOwningPtr
<
T
>
:
:
UniquelyOwning
(
new
T
(
std
:
:
forward
<
Args
>
(
aArgs
)
.
.
.
)
)
;
}
template
<
typename
T
>
class
UniqueOrNonOwningPtr
{
public
:
static_assert
(
alignof
(
T
)
!
=
1
"
Can
'
t
support
data
aligned
to
byte
boundaries
.
"
)
;
UniqueOrNonOwningPtr
(
)
:
mBits
{
0
}
{
}
UniqueOrNonOwningPtr
(
const
UniqueOrNonOwningPtr
&
)
=
delete
;
UniqueOrNonOwningPtr
(
UniqueOrNonOwningPtr
&
&
aOther
)
:
mBits
{
aOther
.
mBits
}
{
aOther
.
mBits
=
0
;
}
~
UniqueOrNonOwningPtr
(
)
{
if
(
IsUniquelyOwning
(
)
)
{
delete
get
(
)
;
}
}
UniqueOrNonOwningPtr
&
operator
=
(
const
UniqueOrNonOwningPtr
&
aOther
)
=
delete
;
UniqueOrNonOwningPtr
&
operator
=
(
UniqueOrNonOwningPtr
&
&
aOther
)
{
mBits
=
aOther
.
mBits
;
aOther
.
mBits
=
0
;
return
*
this
;
}
static
UniqueOrNonOwningPtr
UniquelyOwning
(
T
*
aPtr
)
{
MOZ_ASSERT
(
aPtr
"
Passing
in
null
pointer
as
owning
?
"
)
;
const
uintptr_t
bits
=
reinterpret_cast
<
uintptr_t
>
(
aPtr
)
;
MOZ_ASSERT
(
(
bits
&
kUniquelyOwningBit
)
=
=
0
"
Odd
-
aligned
owning
pointer
?
"
)
;
return
UniqueOrNonOwningPtr
{
bits
|
kUniquelyOwningBit
}
;
}
static
UniqueOrNonOwningPtr
NonOwning
(
T
*
aPtr
)
{
const
uintptr_t
bits
=
reinterpret_cast
<
uintptr_t
>
(
aPtr
)
;
MOZ_ASSERT
(
(
bits
&
kUniquelyOwningBit
)
=
=
0
"
Odd
-
aligned
non
-
owning
pointer
?
"
)
;
return
UniqueOrNonOwningPtr
{
bits
}
;
}
std
:
:
add_lvalue_reference_t
<
T
>
operator
*
(
)
const
{
MOZ_ASSERT
(
get
(
)
"
dereferencing
a
UniqueOrNonOwningPtr
containing
nullptr
with
*
"
)
;
return
*
get
(
)
;
}
T
*
operator
-
>
(
)
const
{
MOZ_ASSERT
(
get
(
)
"
dereferencing
a
UniqueOrNonOwningPtr
containing
nullptr
with
-
>
"
)
;
return
get
(
)
;
}
explicit
operator
bool
(
)
const
{
return
get
(
)
!
=
nullptr
;
}
T
*
get
(
)
const
{
return
reinterpret_cast
<
T
*
>
(
mBits
&
~
kUniquelyOwningBit
)
;
}
private
:
bool
IsUniquelyOwning
(
)
const
{
return
(
mBits
&
kUniquelyOwningBit
)
!
=
0
;
}
static
constexpr
uintptr_t
kUniquelyOwningBit
=
1
;
explicit
UniqueOrNonOwningPtr
(
uintptr_t
aValue
)
:
mBits
{
aValue
}
{
}
uintptr_t
mBits
;
}
;
template
<
typename
T
>
class
UniqueOrNonOwningPtr
<
T
[
]
>
;
}
#
endif
