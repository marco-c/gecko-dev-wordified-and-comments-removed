#
ifndef
nsGenConList_h___
#
define
nsGenConList_h___
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
nsStyleStruct
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsTextNode
.
h
"
class
nsGenConList
;
class
nsIFrame
;
struct
nsGenConNode
:
public
mozilla
:
:
LinkedListElement
<
nsGenConNode
>
{
using
StyleContentType
=
mozilla
:
:
StyleContentItem
:
:
Tag
;
nsIFrame
*
mPseudoFrame
;
const
int32_t
mContentIndex
;
RefPtr
<
nsTextNode
>
mText
;
explicit
nsGenConNode
(
int32_t
aContentIndex
)
:
mPseudoFrame
(
nullptr
)
mContentIndex
(
aContentIndex
)
{
}
virtual
bool
InitTextFrame
(
nsGenConList
*
aList
nsIFrame
*
aPseudoFrame
nsIFrame
*
aTextFrame
)
{
mPseudoFrame
=
aPseudoFrame
;
CheckFrameAssertions
(
)
;
return
false
;
}
virtual
~
nsGenConNode
(
)
=
default
;
protected
:
void
CheckFrameAssertions
(
)
{
NS_ASSERTION
(
mContentIndex
<
int32_t
(
mPseudoFrame
-
>
StyleContent
(
)
-
>
ContentCount
(
)
)
|
|
mContentIndex
=
=
0
"
index
out
of
range
"
)
;
NS_ASSERTION
(
mContentIndex
<
0
|
|
mPseudoFrame
-
>
Style
(
)
-
>
GetPseudoType
(
)
=
=
mozilla
:
:
PseudoStyleType
:
:
before
|
|
mPseudoFrame
-
>
Style
(
)
-
>
GetPseudoType
(
)
=
=
mozilla
:
:
PseudoStyleType
:
:
after
|
|
mPseudoFrame
-
>
Style
(
)
-
>
GetPseudoType
(
)
=
=
mozilla
:
:
PseudoStyleType
:
:
marker
"
not
CSS
generated
content
and
not
counter
change
"
)
;
NS_ASSERTION
(
mContentIndex
<
0
|
|
mPseudoFrame
-
>
HasAnyStateBits
(
NS_FRAME_GENERATED_CONTENT
)
"
not
generated
content
and
not
counter
change
"
)
;
}
}
;
class
nsGenConList
{
protected
:
mozilla
:
:
LinkedList
<
nsGenConNode
>
mList
;
uint32_t
mSize
;
public
:
nsGenConList
(
)
:
mSize
(
0
)
mLastInserted
(
nullptr
)
{
}
~
nsGenConList
(
)
{
Clear
(
)
;
}
void
Clear
(
)
;
static
nsGenConNode
*
Next
(
nsGenConNode
*
aNode
)
{
MOZ_ASSERT
(
aNode
"
aNode
cannot
be
nullptr
!
"
)
;
return
aNode
-
>
getNext
(
)
;
}
static
nsGenConNode
*
Prev
(
nsGenConNode
*
aNode
)
{
MOZ_ASSERT
(
aNode
"
aNode
cannot
be
nullptr
!
"
)
;
return
aNode
-
>
getPrevious
(
)
;
}
void
Insert
(
nsGenConNode
*
aNode
)
;
bool
DestroyNodesFor
(
nsIFrame
*
aFrame
)
;
nsGenConNode
*
GetFirstNodeFor
(
nsIFrame
*
aFrame
)
const
{
return
mNodes
.
Get
(
aFrame
)
;
}
static
bool
NodeAfter
(
const
nsGenConNode
*
aNode1
const
nsGenConNode
*
aNode2
)
;
bool
IsFirst
(
nsGenConNode
*
aNode
)
{
MOZ_ASSERT
(
aNode
"
aNode
cannot
be
nullptr
!
"
)
;
return
aNode
=
=
mList
.
getFirst
(
)
;
}
bool
IsLast
(
nsGenConNode
*
aNode
)
{
MOZ_ASSERT
(
aNode
"
aNode
cannot
be
nullptr
!
"
)
;
return
aNode
=
=
mList
.
getLast
(
)
;
}
private
:
void
Destroy
(
nsGenConNode
*
aNode
)
{
MOZ_ASSERT
(
aNode
"
aNode
cannot
be
nullptr
!
"
)
;
delete
aNode
;
mSize
-
-
;
}
nsTHashMap
<
nsPtrHashKey
<
nsIFrame
>
nsGenConNode
*
>
mNodes
;
nsGenConNode
*
mLastInserted
;
}
;
#
endif
