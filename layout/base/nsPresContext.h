#
ifndef
nsPresContext_h___
#
define
nsPresContext_h___
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
EnumeratedArray
.
h
"
#
include
"
mozilla
/
MediaFeatureChange
.
h
"
#
include
"
mozilla
/
NotNull
.
h
"
#
include
"
mozilla
/
ScrollStyles
.
h
"
#
include
"
mozilla
/
PreferenceSheet
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
nsColor
.
h
"
#
include
"
nsCoord
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsFont
.
h
"
#
include
"
gfxFontConstants
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsIWidgetListener
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsChangeHint
.
h
"
#
include
<
algorithm
>
#
include
"
gfxTypes
.
h
"
#
include
"
gfxRect
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
AppUnits
.
h
"
#
include
"
mozilla
/
MediaEmulationData
.
h
"
#
include
"
mozilla
/
PresShellForwards
.
h
"
#
include
"
prclist
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
Units
.
h
"
#
include
"
prenv
.
h
"
#
include
"
mozilla
/
StaticPresData
.
h
"
class
nsBidi
;
class
nsIPrintSettings
;
class
nsDocShell
;
class
nsIDocShell
;
class
nsITheme
;
class
nsITimer
;
class
nsIContent
;
class
nsIFrame
;
class
nsFrameManager
;
class
nsAtom
;
class
nsIRunnable
;
class
gfxFontFeatureValueSet
;
class
gfxUserFontEntry
;
class
gfxUserFontSet
;
class
gfxTextPerfMetrics
;
class
nsCSSFontFeatureValuesRule
;
class
nsCSSFrameConstructor
;
class
nsDisplayList
;
class
nsDisplayListBuilder
;
class
nsPluginFrame
;
class
nsTransitionManager
;
class
nsAnimationManager
;
class
nsRefreshDriver
;
class
nsIWidget
;
class
nsDeviceContext
;
class
gfxMissingFontRecorder
;
namespace
mozilla
{
class
AnimationEventDispatcher
;
class
EffectCompositor
;
class
Encoding
;
class
EventStateManager
;
class
CounterStyleManager
;
class
PresShell
;
class
RestyleManager
;
namespace
layers
{
class
ContainerLayer
;
class
LayerManager
;
}
namespace
dom
{
class
Document
;
class
Element
;
}
}
enum
nsPresContext_CachedIntPrefType
{
kPresContext_ScrollbarSide
=
1
kPresContext_BidiDirection
}
;
const
uint8_t
kPresContext_DefaultVariableFont_ID
=
0x00
;
const
uint8_t
kPresContext_DefaultFixedFont_ID
=
0x01
;
#
ifdef
DEBUG
struct
nsAutoLayoutPhase
;
enum
class
nsLayoutPhase
:
uint8_t
{
Paint
DisplayListBuilding
Reflow
FrameC
COUNT
}
;
#
endif
#
define
NS_AUTHOR_SPECIFIED_BACKGROUND
(
1
<
<
0
)
#
define
NS_AUTHOR_SPECIFIED_BORDER
(
1
<
<
1
)
#
define
NS_AUTHOR_SPECIFIED_PADDING
(
1
<
<
2
)
class
nsRootPresContext
;
class
nsPresContext
:
public
nsISupports
public
mozilla
:
:
SupportsWeakPtr
<
nsPresContext
>
{
public
:
using
Encoding
=
mozilla
:
:
Encoding
;
template
<
typename
T
>
using
NotNull
=
mozilla
:
:
NotNull
<
T
>
;
using
MediaEmulationData
=
mozilla
:
:
MediaEmulationData
;
using
StylePrefersColorScheme
=
mozilla
:
:
StylePrefersColorScheme
;
typedef
mozilla
:
:
ScrollStyles
ScrollStyles
;
typedef
mozilla
:
:
StaticPresData
StaticPresData
;
using
TransactionId
=
mozilla
:
:
layers
:
:
TransactionId
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS_FINAL
NS_DECL_CYCLE_COLLECTION_CLASS
(
nsPresContext
)
MOZ_DECLARE_WEAKREFERENCE_TYPENAME
(
nsPresContext
)
enum
nsPresContextType
{
eContext_Galley
eContext_PrintPreview
eContext_Print
eContext_PageLayout
}
;
nsPresContext
(
mozilla
:
:
dom
:
:
Document
*
aDocument
nsPresContextType
aType
)
;
nsresult
Init
(
nsDeviceContext
*
aDeviceContext
)
;
void
AttachPresShell
(
mozilla
:
:
PresShell
*
aPresShell
)
;
void
DetachPresShell
(
)
;
nsPresContextType
Type
(
)
const
{
return
mType
;
}
mozilla
:
:
PresShell
*
PresShell
(
)
const
{
NS_ASSERTION
(
mPresShell
"
Null
pres
shell
"
)
;
return
mPresShell
;
}
mozilla
:
:
PresShell
*
GetPresShell
(
)
const
{
return
mPresShell
;
}
void
DispatchCharSetChange
(
NotNull
<
const
Encoding
*
>
aCharSet
)
;
nsPresContext
*
GetParentPresContext
(
)
;
nsPresContext
*
GetToplevelContentDocumentPresContext
(
)
;
nsIWidget
*
GetNearestWidget
(
nsPoint
*
aOffset
=
nullptr
)
;
nsIWidget
*
GetRootWidget
(
)
const
;
nsIWidget
*
GetTextInputHandlingWidget
(
)
const
{
return
GetRootWidget
(
)
;
}
nsRootPresContext
*
GetRootPresContext
(
)
;
virtual
bool
IsRoot
(
)
{
return
false
;
}
mozilla
:
:
dom
:
:
Document
*
Document
(
)
const
{
#
ifdef
DEBUG
ValidatePresShellAndDocumentReleation
(
)
;
#
endif
return
mDocument
;
}
inline
mozilla
:
:
ServoStyleSet
*
StyleSet
(
)
const
;
bool
HasPendingMediaQueryUpdates
(
)
const
{
return
!
!
mPendingMediaFeatureValuesChange
;
}
inline
nsCSSFrameConstructor
*
FrameConstructor
(
)
;
mozilla
:
:
AnimationEventDispatcher
*
AnimationEventDispatcher
(
)
{
return
mAnimationEventDispatcher
;
}
mozilla
:
:
EffectCompositor
*
EffectCompositor
(
)
{
return
mEffectCompositor
;
}
nsTransitionManager
*
TransitionManager
(
)
{
return
mTransitionManager
.
get
(
)
;
}
nsAnimationManager
*
AnimationManager
(
)
{
return
mAnimationManager
.
get
(
)
;
}
const
nsAnimationManager
*
AnimationManager
(
)
const
{
return
mAnimationManager
.
get
(
)
;
}
nsRefreshDriver
*
RefreshDriver
(
)
{
return
mRefreshDriver
;
}
mozilla
:
:
RestyleManager
*
RestyleManager
(
)
{
MOZ_ASSERT
(
mRestyleManager
)
;
return
mRestyleManager
.
get
(
)
;
}
mozilla
:
:
CounterStyleManager
*
CounterStyleManager
(
)
const
{
return
mCounterStyleManager
;
}
void
RebuildAllStyleData
(
nsChangeHint
aExtraHint
mozilla
:
:
RestyleHint
)
;
void
PostRebuildAllStyleDataEvent
(
nsChangeHint
aExtraHint
mozilla
:
:
RestyleHint
)
;
void
ContentLanguageChanged
(
)
;
void
MediaFeatureValuesChanged
(
const
mozilla
:
:
MediaFeatureChange
&
aChange
)
;
void
FlushPendingMediaFeatureValuesChanged
(
)
;
void
MediaFeatureValuesChangedAllDocuments
(
const
mozilla
:
:
MediaFeatureChange
&
)
;
void
SizeModeChanged
(
nsSizeMode
aSizeMode
)
;
nsCompatibility
CompatibilityMode
(
)
const
;
uint16_t
ImageAnimationMode
(
)
const
{
return
mImageAnimationMode
;
}
void
SetImageAnimationMode
(
uint16_t
aMode
)
;
const
nsAtom
*
Medium
(
)
{
MOZ_ASSERT
(
mMedium
)
;
return
mMediaEmulationData
.
mMedium
?
mMediaEmulationData
.
mMedium
.
get
(
)
:
mMedium
;
}
void
EmulateMedium
(
nsAtom
*
aMediaType
)
;
int32_t
GetCachedIntPref
(
nsPresContext_CachedIntPrefType
aPrefType
)
const
{
switch
(
aPrefType
)
{
case
kPresContext_ScrollbarSide
:
return
mPrefScrollbarSide
;
case
kPresContext_BidiDirection
:
return
mPrefBidiDirection
;
default
:
NS_ERROR
(
"
invalid
arg
passed
to
GetCachedIntPref
"
)
;
}
return
false
;
}
const
mozilla
:
:
PreferenceSheet
:
:
Prefs
&
PrefSheetPrefs
(
)
const
{
return
mozilla
:
:
PreferenceSheet
:
:
PrefsFor
(
*
mDocument
)
;
}
nscolor
DefaultBackgroundColor
(
)
const
{
return
PrefSheetPrefs
(
)
.
mDefaultBackgroundColor
;
}
nsISupports
*
GetContainerWeak
(
)
const
;
nsDocShell
*
GetDocShell
(
)
const
;
nsRect
GetVisibleArea
(
)
const
{
return
mVisibleArea
;
}
void
SetVisibleArea
(
const
nsRect
&
r
)
;
nsSize
GetSizeForViewportUnits
(
)
const
{
return
mSizeForViewportUnits
;
}
MOZ_CAN_RUN_SCRIPT
void
SetDynamicToolbarMaxHeight
(
mozilla
:
:
ScreenIntCoord
aHeight
)
;
mozilla
:
:
ScreenIntCoord
GetDynamicToolbarMaxHeight
(
)
const
{
MOZ_ASSERT
(
IsRootContentDocumentCrossProcess
(
)
)
;
return
mDynamicToolbarMaxHeight
;
}
bool
HasDynamicToolbar
(
)
const
{
MOZ_ASSERT
(
IsRootContentDocumentCrossProcess
(
)
)
;
return
mDynamicToolbarMaxHeight
>
0
;
}
void
UpdateDynamicToolbarOffset
(
mozilla
:
:
ScreenIntCoord
aOffset
)
;
mozilla
:
:
ScreenIntCoord
GetDynamicToolbarHeight
(
)
const
{
MOZ_ASSERT
(
IsRootContentDocumentCrossProcess
(
)
)
;
return
mDynamicToolbarHeight
;
}
mozilla
:
:
DynamicToolbarState
GetDynamicToolbarState
(
)
const
;
bool
IsPaginated
(
)
const
{
return
mPaginated
;
}
void
SetPaginatedScrolling
(
bool
aResult
)
;
bool
HasPaginatedScrolling
(
)
const
{
return
mCanPaginatedScroll
;
}
nsSize
GetPageSize
(
)
{
return
mPageSize
;
}
void
SetPageSize
(
nsSize
aSize
)
{
mPageSize
=
aSize
;
}
bool
IsRootPaginatedDocument
(
)
{
return
mIsRootPaginatedDocument
;
}
void
SetIsRootPaginatedDocument
(
bool
aIsRootPaginatedDocument
)
{
mIsRootPaginatedDocument
=
aIsRootPaginatedDocument
;
}
float
GetPageScale
(
)
{
return
mPageScale
;
}
void
SetPageScale
(
float
aScale
)
{
mPageScale
=
aScale
;
}
float
GetPrintPreviewScale
(
)
{
return
mPPScale
;
}
void
SetPrintPreviewScale
(
float
aScale
)
{
mPPScale
=
aScale
;
}
nsDeviceContext
*
DeviceContext
(
)
const
{
return
mDeviceContext
;
}
mozilla
:
:
EventStateManager
*
EventStateManager
(
)
{
return
mEventManager
;
}
float
GetSystemFontScale
(
)
const
{
return
mSystemFontScale
;
}
void
SetSystemFontScale
(
float
aFontScale
)
{
MOZ_ASSERT
(
aFontScale
>
0
.
0f
"
invalid
font
scale
"
)
;
if
(
aFontScale
=
=
mSystemFontScale
|
|
IsPrintingOrPrintPreview
(
)
)
{
return
;
}
mSystemFontScale
=
aFontScale
;
UpdateEffectiveTextZoom
(
)
;
}
float
TextZoom
(
)
const
{
return
mTextZoom
;
}
void
SetTextZoom
(
float
aZoom
)
{
MOZ_ASSERT
(
aZoom
>
0
.
0f
"
invalid
zoom
factor
"
)
;
if
(
aZoom
=
=
mTextZoom
)
return
;
mTextZoom
=
aZoom
;
UpdateEffectiveTextZoom
(
)
;
}
protected
:
void
UpdateEffectiveTextZoom
(
)
;
#
ifdef
DEBUG
void
ValidatePresShellAndDocumentReleation
(
)
const
;
#
endif
public
:
float
EffectiveTextZoom
(
)
const
{
return
mEffectiveTextZoom
;
}
float
GetFullZoom
(
)
{
return
mFullZoom
;
}
float
GetDeviceFullZoom
(
)
;
void
SetFullZoom
(
float
aZoom
)
;
float
GetOverrideDPPX
(
)
const
{
return
mMediaEmulationData
.
mDPPX
;
}
void
SetOverrideDPPX
(
float
)
;
Maybe
<
StylePrefersColorScheme
>
GetOverridePrefersColorScheme
(
)
const
{
return
mMediaEmulationData
.
mPrefersColorScheme
;
}
void
SetOverridePrefersColorScheme
(
const
Maybe
<
StylePrefersColorScheme
>
&
)
;
nscoord
GetAutoQualityMinFontSize
(
)
{
return
DevPixelsToAppUnits
(
mAutoQualityMinFontSizePixelsPref
)
;
}
gfxSize
ScreenSizeInchesForFontInflation
(
bool
*
aChanged
=
nullptr
)
;
int32_t
AppUnitsPerDevPixel
(
)
const
{
return
mCurAppUnitsPerDevPixel
;
}
static
nscoord
CSSPixelsToAppUnits
(
int32_t
aPixels
)
{
return
NSToCoordRoundWithClamp
(
float
(
aPixels
)
*
float
(
mozilla
:
:
AppUnitsPerCSSPixel
(
)
)
)
;
}
static
nscoord
CSSPixelsToAppUnits
(
float
aPixels
)
{
return
NSToCoordRoundWithClamp
(
aPixels
*
float
(
mozilla
:
:
AppUnitsPerCSSPixel
(
)
)
)
;
}
static
int32_t
AppUnitsToIntCSSPixels
(
nscoord
aAppUnits
)
{
return
NSAppUnitsToIntPixels
(
aAppUnits
float
(
mozilla
:
:
AppUnitsPerCSSPixel
(
)
)
)
;
}
static
float
AppUnitsToFloatCSSPixels
(
nscoord
aAppUnits
)
{
return
NSAppUnitsToFloatPixels
(
aAppUnits
float
(
mozilla
:
:
AppUnitsPerCSSPixel
(
)
)
)
;
}
static
double
AppUnitsToDoubleCSSPixels
(
nscoord
aAppUnits
)
{
return
NSAppUnitsToDoublePixels
(
aAppUnits
double
(
mozilla
:
:
AppUnitsPerCSSPixel
(
)
)
)
;
}
nscoord
DevPixelsToAppUnits
(
int32_t
aPixels
)
const
{
return
NSIntPixelsToAppUnits
(
aPixels
AppUnitsPerDevPixel
(
)
)
;
}
int32_t
AppUnitsToDevPixels
(
nscoord
aAppUnits
)
const
{
return
NSAppUnitsToIntPixels
(
aAppUnits
float
(
AppUnitsPerDevPixel
(
)
)
)
;
}
float
AppUnitsToFloatDevPixels
(
nscoord
aAppUnits
)
{
return
aAppUnits
/
float
(
AppUnitsPerDevPixel
(
)
)
;
}
int32_t
CSSPixelsToDevPixels
(
int32_t
aPixels
)
{
return
AppUnitsToDevPixels
(
CSSPixelsToAppUnits
(
aPixels
)
)
;
}
float
CSSPixelsToDevPixels
(
float
aPixels
)
{
return
NSAppUnitsToFloatPixels
(
CSSPixelsToAppUnits
(
aPixels
)
float
(
AppUnitsPerDevPixel
(
)
)
)
;
}
int32_t
DevPixelsToIntCSSPixels
(
int32_t
aPixels
)
{
return
AppUnitsToIntCSSPixels
(
DevPixelsToAppUnits
(
aPixels
)
)
;
}
float
DevPixelsToFloatCSSPixels
(
int32_t
aPixels
)
{
return
AppUnitsToFloatCSSPixels
(
DevPixelsToAppUnits
(
aPixels
)
)
;
}
mozilla
:
:
CSSToLayoutDeviceScale
CSSToDevPixelScale
(
)
const
{
return
mozilla
:
:
CSSToLayoutDeviceScale
(
float
(
mozilla
:
:
AppUnitsPerCSSPixel
(
)
)
/
float
(
AppUnitsPerDevPixel
(
)
)
)
;
}
nscoord
GfxUnitsToAppUnits
(
gfxFloat
aGfxUnits
)
const
;
gfxFloat
AppUnitsToGfxUnits
(
nscoord
aAppUnits
)
const
;
gfxRect
AppUnitsToGfxUnits
(
const
nsRect
&
aAppRect
)
const
{
return
gfxRect
(
AppUnitsToGfxUnits
(
aAppRect
.
x
)
AppUnitsToGfxUnits
(
aAppRect
.
y
)
AppUnitsToGfxUnits
(
aAppRect
.
Width
(
)
)
AppUnitsToGfxUnits
(
aAppRect
.
Height
(
)
)
)
;
}
static
nscoord
CSSTwipsToAppUnits
(
float
aTwips
)
{
return
NSToCoordRoundWithClamp
(
mozilla
:
:
AppUnitsPerCSSInch
(
)
*
NS_TWIPS_TO_INCHES
(
aTwips
)
)
;
}
static
nsMargin
CSSTwipsToAppUnits
(
const
nsIntMargin
&
marginInTwips
)
{
return
nsMargin
(
CSSTwipsToAppUnits
(
float
(
marginInTwips
.
top
)
)
CSSTwipsToAppUnits
(
float
(
marginInTwips
.
right
)
)
CSSTwipsToAppUnits
(
float
(
marginInTwips
.
bottom
)
)
CSSTwipsToAppUnits
(
float
(
marginInTwips
.
left
)
)
)
;
}
static
nscoord
CSSPointsToAppUnits
(
float
aPoints
)
{
return
NSToCoordRound
(
aPoints
*
mozilla
:
:
AppUnitsPerCSSInch
(
)
/
POINTS_PER_INCH_FLOAT
)
;
}
nscoord
PhysicalMillimetersToAppUnits
(
float
aMM
)
const
;
nscoord
RoundAppUnitsToNearestDevPixels
(
nscoord
aAppUnits
)
const
{
return
DevPixelsToAppUnits
(
AppUnitsToDevPixels
(
aAppUnits
)
)
;
}
mozilla
:
:
dom
:
:
Element
*
UpdateViewportScrollStylesOverride
(
)
;
mozilla
:
:
dom
:
:
Element
*
GetViewportScrollStylesOverrideElement
(
)
const
{
return
mViewportScrollOverrideElement
;
}
const
ScrollStyles
&
GetViewportScrollStylesOverride
(
)
const
{
return
mViewportScrollStyles
;
}
bool
ElementWouldPropagateScrollStyles
(
const
mozilla
:
:
dom
:
:
Element
&
)
;
bool
GetBackgroundImageDraw
(
)
const
{
return
mDrawImageBackground
;
}
void
SetBackgroundImageDraw
(
bool
aCanDraw
)
{
mDrawImageBackground
=
aCanDraw
;
}
bool
GetBackgroundColorDraw
(
)
const
{
return
mDrawColorBackground
;
}
void
SetBackgroundColorDraw
(
bool
aCanDraw
)
{
mDrawColorBackground
=
aCanDraw
;
}
bool
BidiEnabled
(
)
const
;
void
SetBidiEnabled
(
)
const
;
void
SetVisualMode
(
bool
aIsVisual
)
{
mIsVisual
=
aIsVisual
;
}
bool
IsVisualMode
(
)
const
{
return
mIsVisual
;
}
enum
class
InteractionType
:
uint32_t
{
ClickInteraction
KeyInteraction
MouseMoveInteraction
ScrollInteraction
}
;
void
RecordInteractionTime
(
InteractionType
aType
const
mozilla
:
:
TimeStamp
&
aTimeStamp
)
;
void
DisableInteractionTimeRecording
(
)
{
mInteractionTimeEnabled
=
false
;
}
void
SetBidi
(
uint32_t
aBidiOptions
)
;
uint32_t
GetBidi
(
)
const
;
nsITheme
*
GetTheme
(
)
;
void
ThemeChanged
(
)
;
void
UIResolutionChanged
(
)
;
void
UIResolutionChangedSync
(
)
;
void
SysColorChanged
(
)
;
void
SetPrintSettings
(
nsIPrintSettings
*
aPrintSettings
)
;
nsIPrintSettings
*
GetPrintSettings
(
)
{
return
mPrintSettings
;
}
bool
EnsureVisible
(
)
;
#
ifdef
MOZ_REFLOW_PERF
void
CountReflows
(
const
char
*
aName
nsIFrame
*
aFrame
)
;
#
endif
void
ConstructedFrame
(
)
{
+
+
mFramesConstructed
;
}
void
ReflowedFrame
(
)
{
+
+
mFramesReflowed
;
}
uint64_t
FramesConstructedCount
(
)
{
return
mFramesConstructed
;
}
uint64_t
FramesReflowedCount
(
)
{
return
mFramesReflowed
;
}
static
nscoord
GetBorderWidthForKeyword
(
unsigned
int
aBorderWidthKeyword
)
{
static
const
nscoord
kBorderWidths
[
]
=
{
CSSPixelsToAppUnits
(
1
)
CSSPixelsToAppUnits
(
3
)
CSSPixelsToAppUnits
(
5
)
}
;
MOZ_ASSERT
(
size_t
(
aBorderWidthKeyword
)
<
mozilla
:
:
ArrayLength
(
kBorderWidths
)
)
;
return
kBorderWidths
[
aBorderWidthKeyword
]
;
}
gfxTextPerfMetrics
*
GetTextPerfMetrics
(
)
{
return
mTextPerf
.
get
(
)
;
}
bool
IsDynamic
(
)
{
return
(
mType
=
=
eContext_PageLayout
|
|
mType
=
=
eContext_Galley
)
;
}
bool
IsScreen
(
)
{
return
(
mMedium
=
=
nsGkAtoms
:
:
screen
|
|
mType
=
=
eContext_PageLayout
|
|
mType
=
=
eContext_PrintPreview
)
;
}
bool
IsPrintingOrPrintPreview
(
)
{
return
(
mType
=
=
eContext_Print
|
|
mType
=
=
eContext_PrintPreview
)
;
}
bool
IsChrome
(
)
const
;
bool
HasAuthorSpecifiedRules
(
const
nsIFrame
*
aFrame
uint32_t
ruleTypeMask
)
const
;
void
SetPaintFlashing
(
bool
aPaintFlashing
)
{
mPaintFlashing
=
aPaintFlashing
;
mPaintFlashingInitialized
=
true
;
}
bool
GetPaintFlashing
(
)
const
;
bool
SuppressingResizeReflow
(
)
const
{
return
mSuppressResizeReflow
;
}
gfxUserFontSet
*
GetUserFontSet
(
)
;
void
UserFontSetUpdated
(
gfxUserFontEntry
*
aUpdatedFont
=
nullptr
)
;
gfxMissingFontRecorder
*
MissingFontRecorder
(
)
{
return
mMissingFonts
.
get
(
)
;
}
void
NotifyMissingFonts
(
)
;
void
FlushCounterStyles
(
)
;
void
MarkCounterStylesDirty
(
)
;
void
FlushFontFeatureValues
(
)
;
void
MarkFontFeatureValuesDirty
(
)
{
mFontFeatureValuesDirty
=
true
;
}
void
EnsureSafeToHandOutCSSRules
(
)
;
void
NotifyInvalidation
(
TransactionId
aTransactionId
const
nsRect
&
aRect
)
;
void
NotifyInvalidation
(
TransactionId
aTransactionId
const
nsIntRect
&
aRect
)
;
void
NotifyDidPaintForSubtree
(
TransactionId
aTransactionId
=
TransactionId
{
0
}
const
mozilla
:
:
TimeStamp
&
aTimeStamp
=
mozilla
:
:
TimeStamp
(
)
)
;
void
NotifyRevokingDidPaint
(
TransactionId
aTransactionId
)
;
void
FireDOMPaintEvent
(
nsTArray
<
nsRect
>
*
aList
TransactionId
aTransactionId
mozilla
:
:
TimeStamp
aTimeStamp
=
mozilla
:
:
TimeStamp
(
)
)
;
static
void
NotifySubDocInvalidation
(
mozilla
:
:
layers
:
:
ContainerLayer
*
aContainer
const
nsIntRegion
*
aRegion
)
;
void
SetNotifySubDocInvalidationData
(
mozilla
:
:
layers
:
:
ContainerLayer
*
aContainer
)
;
static
void
ClearNotifySubDocInvalidationData
(
mozilla
:
:
layers
:
:
ContainerLayer
*
aContainer
)
;
bool
IsDOMPaintEventPending
(
)
;
uint64_t
GetRestyleGeneration
(
)
const
;
uint64_t
GetUndisplayedRestyleGeneration
(
)
const
;
bool
HasPendingRestyleOrReflow
(
)
;
void
ReflowStarted
(
bool
aInterruptible
)
;
class
InterruptPreventer
;
friend
class
InterruptPreventer
;
class
MOZ_STACK_CLASS
InterruptPreventer
{
public
:
explicit
InterruptPreventer
(
nsPresContext
*
aCtx
)
:
mCtx
(
aCtx
)
mInterruptsEnabled
(
aCtx
-
>
mInterruptsEnabled
)
mHasPendingInterrupt
(
aCtx
-
>
mHasPendingInterrupt
)
{
mCtx
-
>
mInterruptsEnabled
=
false
;
mCtx
-
>
mHasPendingInterrupt
=
false
;
}
~
InterruptPreventer
(
)
{
mCtx
-
>
mInterruptsEnabled
=
mInterruptsEnabled
;
mCtx
-
>
mHasPendingInterrupt
=
mHasPendingInterrupt
;
}
private
:
nsPresContext
*
mCtx
;
bool
mInterruptsEnabled
;
bool
mHasPendingInterrupt
;
}
;
bool
CheckForInterrupt
(
nsIFrame
*
aFrame
)
;
bool
HasPendingInterrupt
(
)
{
return
mHasPendingInterrupt
;
}
void
SetPendingInterruptFromTest
(
)
{
mPendingInterruptFromTest
=
true
;
}
nsIFrame
*
GetPrimaryFrameFor
(
nsIContent
*
aContent
)
;
virtual
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
virtual
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
bool
IsRootContentDocument
(
)
const
;
bool
IsRootContentDocumentInProcess
(
)
const
;
bool
IsRootContentDocumentCrossProcess
(
)
const
;
bool
HadNonBlankPaint
(
)
const
{
return
mHadNonBlankPaint
;
}
bool
HadContentfulPaint
(
)
const
{
return
mHadContentfulPaint
;
}
void
NotifyNonBlankPaint
(
)
;
void
NotifyContentfulPaint
(
)
;
void
NotifyDOMContentFlushed
(
)
;
bool
UsesRootEMUnits
(
)
const
{
return
mUsesRootEMUnits
;
}
void
SetUsesRootEMUnits
(
bool
aValue
)
{
mUsesRootEMUnits
=
aValue
;
}
bool
UsesExChUnits
(
)
const
{
return
mUsesExChUnits
;
}
void
SetUsesExChUnits
(
bool
aValue
)
{
mUsesExChUnits
=
aValue
;
}
bool
ExistThrottledUpdates
(
)
const
{
return
mExistThrottledUpdates
;
}
void
SetExistThrottledUpdates
(
bool
aExistThrottledUpdates
)
{
mExistThrottledUpdates
=
aExistThrottledUpdates
;
}
bool
IsDeviceSizePageSize
(
)
;
bool
HasWarnedAboutPositionedTableParts
(
)
const
{
return
mHasWarnedAboutPositionedTableParts
;
}
void
SetHasWarnedAboutPositionedTableParts
(
)
{
mHasWarnedAboutPositionedTableParts
=
true
;
}
bool
HasWarnedAboutTooLargeDashedOrDottedRadius
(
)
const
{
return
mHasWarnedAboutTooLargeDashedOrDottedRadius
;
}
void
SetHasWarnedAboutTooLargeDashedOrDottedRadius
(
)
{
mHasWarnedAboutTooLargeDashedOrDottedRadius
=
true
;
}
nsBidi
&
GetBidiEngine
(
)
;
gfxFontFeatureValueSet
*
GetFontFeatureValuesLookup
(
)
const
{
return
mFontFeatureValuesLookup
;
}
protected
:
friend
class
nsRunnableMethod
<
nsPresContext
>
;
void
ThemeChangedInternal
(
)
;
void
SysColorChangedInternal
(
)
;
void
RefreshSystemMetrics
(
)
;
void
UIResolutionChangedInternal
(
)
;
void
UIResolutionChangedInternalScale
(
double
aScale
)
;
static
mozilla
:
:
CallState
UIResolutionChangedSubdocumentCallback
(
mozilla
:
:
dom
:
:
Document
&
void
*
aData
)
;
void
SetImgAnimations
(
nsIContent
*
aParent
uint16_t
aMode
)
;
void
SetSMILAnimations
(
mozilla
:
:
dom
:
:
Document
*
aDoc
uint16_t
aNewMode
uint16_t
aOldMode
)
;
static
void
PreferenceChanged
(
const
char
*
aPrefName
void
*
aSelf
)
;
void
PreferenceChanged
(
const
char
*
aPrefName
)
;
void
UpdateAfterPreferencesChanged
(
)
;
void
DispatchPrefChangedRunnableIfNeeded
(
)
;
void
GetUserPreferences
(
)
;
void
UpdateCharSet
(
NotNull
<
const
Encoding
*
>
aCharSet
)
;
static
mozilla
:
:
CallState
NotifyDidPaintSubdocumentCallback
(
mozilla
:
:
dom
:
:
Document
&
void
*
aData
)
;
static
mozilla
:
:
CallState
NotifyRevokingDidPaintSubdocumentCallback
(
mozilla
:
:
dom
:
:
Document
&
void
*
aData
)
;
public
:
void
ForceReflowForFontInfoUpdate
(
)
;
void
DoChangeCharSet
(
NotNull
<
const
Encoding
*
>
aCharSet
)
;
bool
MayHavePaintEventListener
(
)
;
bool
MayHavePaintEventListenerInSubDocument
(
)
;
void
InvalidatePaintedLayers
(
)
;
uint32_t
GetNextFrameRateMultiplier
(
)
const
{
return
mNextFrameRateMultiplier
;
}
void
DidUseFrameRateMultiplier
(
)
{
if
(
!
mNextFrameRateMultiplier
)
{
mNextFrameRateMultiplier
=
1
;
}
else
if
(
mNextFrameRateMultiplier
<
8
)
{
mNextFrameRateMultiplier
=
mNextFrameRateMultiplier
*
2
;
}
}
protected
:
void
Destroy
(
)
;
void
AppUnitsPerDevPixelChanged
(
)
;
bool
HavePendingInputEvent
(
)
;
already_AddRefed
<
nsITimer
>
CreateTimer
(
nsTimerCallbackFunc
aCallback
const
char
*
aName
uint32_t
aDelay
)
;
struct
TransactionInvalidations
{
TransactionId
mTransactionId
;
nsTArray
<
nsRect
>
mInvalidations
;
bool
mIsWaitingForPreviousTransaction
=
false
;
}
;
TransactionInvalidations
*
GetInvalidations
(
TransactionId
aTransactionId
)
;
void
AdjustSizeForViewportUnits
(
)
;
nsPresContextType
mType
;
mozilla
:
:
PresShell
*
MOZ_NON_OWNING_REF
mPresShell
;
RefPtr
<
mozilla
:
:
dom
:
:
Document
>
mDocument
;
RefPtr
<
nsDeviceContext
>
mDeviceContext
;
RefPtr
<
mozilla
:
:
EventStateManager
>
mEventManager
;
RefPtr
<
nsRefreshDriver
>
mRefreshDriver
;
RefPtr
<
mozilla
:
:
AnimationEventDispatcher
>
mAnimationEventDispatcher
;
RefPtr
<
mozilla
:
:
EffectCompositor
>
mEffectCompositor
;
mozilla
:
:
UniquePtr
<
nsTransitionManager
>
mTransitionManager
;
mozilla
:
:
UniquePtr
<
nsAnimationManager
>
mAnimationManager
;
mozilla
:
:
UniquePtr
<
mozilla
:
:
RestyleManager
>
mRestyleManager
;
RefPtr
<
mozilla
:
:
CounterStyleManager
>
mCounterStyleManager
;
const
nsStaticAtom
*
mMedium
;
RefPtr
<
gfxFontFeatureValueSet
>
mFontFeatureValuesLookup
;
MediaEmulationData
mMediaEmulationData
;
public
:
bool
mInflationDisabledForShrinkWrap
;
protected
:
float
mSystemFontScale
;
float
mTextZoom
;
float
mEffectiveTextZoom
;
float
mFullZoom
;
gfxSize
mLastFontInflationScreenSize
;
int32_t
mCurAppUnitsPerDevPixel
;
int32_t
mAutoQualityMinFontSizePixelsPref
;
nsCOMPtr
<
nsITheme
>
mTheme
;
nsCOMPtr
<
nsIPrintSettings
>
mPrintSettings
;
mozilla
:
:
UniquePtr
<
nsBidi
>
mBidiEngine
;
AutoTArray
<
TransactionInvalidations
4
>
mTransactions
;
mozilla
:
:
UniquePtr
<
gfxTextPerfMetrics
>
mTextPerf
;
mozilla
:
:
UniquePtr
<
gfxMissingFontRecorder
>
mMissingFonts
;
nsRect
mVisibleArea
;
nsSize
mSizeForViewportUnits
;
mozilla
:
:
ScreenIntCoord
mDynamicToolbarMaxHeight
;
mozilla
:
:
ScreenIntCoord
mDynamicToolbarHeight
;
nsSize
mPageSize
;
float
mPageScale
;
float
mPPScale
;
mozilla
:
:
dom
:
:
Element
*
MOZ_NON_OWNING_REF
mViewportScrollOverrideElement
;
ScrollStyles
mViewportScrollStyles
;
bool
mExistThrottledUpdates
;
uint16_t
mImageAnimationMode
;
uint16_t
mImageAnimationModePref
;
uint32_t
mInterruptChecksToSkip
;
uint32_t
mNextFrameRateMultiplier
;
uint64_t
mElementsRestyled
;
uint64_t
mFramesConstructed
;
uint64_t
mFramesReflowed
;
mozilla
:
:
TimeStamp
mReflowStartTime
;
mozilla
:
:
Maybe
<
TransactionId
>
mFirstContentfulPaintTransactionId
;
mozilla
:
:
TimeStamp
mFirstNonBlankPaintTime
;
mozilla
:
:
TimeStamp
mFirstClickTime
;
mozilla
:
:
TimeStamp
mFirstKeyTime
;
mozilla
:
:
TimeStamp
mFirstMouseMoveTime
;
mozilla
:
:
TimeStamp
mFirstScrollTime
;
bool
mInteractionTimeEnabled
;
mozilla
:
:
TimeStamp
mLastStyleUpdateForAllAnimations
;
unsigned
mHasPendingInterrupt
:
1
;
unsigned
mPendingInterruptFromTest
:
1
;
unsigned
mInterruptsEnabled
:
1
;
unsigned
mSendAfterPaintToContent
:
1
;
unsigned
mDrawImageBackground
:
1
;
unsigned
mDrawColorBackground
:
1
;
unsigned
mNeverAnimate
:
1
;
unsigned
mPaginated
:
1
;
unsigned
mCanPaginatedScroll
:
1
;
unsigned
mDoScaledTwips
:
1
;
unsigned
mIsRootPaginatedDocument
:
1
;
unsigned
mPrefBidiDirection
:
1
;
unsigned
mPrefScrollbarSide
:
2
;
unsigned
mPendingSysColorChanged
:
1
;
unsigned
mPendingThemeChanged
:
1
;
unsigned
mPendingUIResolutionChanged
:
1
;
unsigned
mPrefChangePendingNeedsReflow
:
1
;
unsigned
mPostedPrefChangedRunnable
:
1
;
unsigned
mIsGlyph
:
1
;
unsigned
mUsesRootEMUnits
:
1
;
unsigned
mUsesExChUnits
:
1
;
unsigned
mCounterStylesDirty
:
1
;
unsigned
mFontFeatureValuesDirty
:
1
;
unsigned
mSuppressResizeReflow
:
1
;
unsigned
mIsVisual
:
1
;
mutable
unsigned
mPaintFlashing
:
1
;
mutable
unsigned
mPaintFlashingInitialized
:
1
;
unsigned
mHasWarnedAboutPositionedTableParts
:
1
;
unsigned
mHasWarnedAboutTooLargeDashedOrDottedRadius
:
1
;
unsigned
mQuirkSheetAdded
:
1
;
unsigned
mHadNonBlankPaint
:
1
;
unsigned
mHadContentfulPaint
:
1
;
unsigned
mHadContentfulPaintComposite
:
1
;
#
ifdef
DEBUG
unsigned
mInitialized
:
1
;
#
endif
mozilla
:
:
Maybe
<
mozilla
:
:
MediaFeatureChange
>
mPendingMediaFeatureValuesChange
;
protected
:
virtual
~
nsPresContext
(
)
;
void
LastRelease
(
)
;
#
ifdef
DEBUG
private
:
friend
struct
nsAutoLayoutPhase
;
mozilla
:
:
EnumeratedArray
<
nsLayoutPhase
nsLayoutPhase
:
:
COUNT
uint32_t
>
mLayoutPhaseCount
;
public
:
uint32_t
LayoutPhaseCount
(
nsLayoutPhase
aPhase
)
{
return
mLayoutPhaseCount
[
aPhase
]
;
}
#
endif
}
;
class
nsRootPresContext
final
:
public
nsPresContext
{
public
:
nsRootPresContext
(
mozilla
:
:
dom
:
:
Document
*
aDocument
nsPresContextType
aType
)
;
virtual
~
nsRootPresContext
(
)
;
void
RegisterPluginForGeometryUpdates
(
nsIContent
*
aPlugin
)
;
void
UnregisterPluginForGeometryUpdates
(
nsIContent
*
aPlugin
)
;
bool
NeedToComputePluginGeometryUpdates
(
)
{
return
mRegisteredPlugins
.
Count
(
)
>
0
;
}
void
ComputePluginGeometryUpdates
(
nsIFrame
*
aFrame
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
)
;
void
ApplyPluginGeometryUpdates
(
)
;
void
CollectPluginGeometryUpdates
(
mozilla
:
:
layers
:
:
LayerManager
*
aLayerManager
)
;
virtual
bool
IsRoot
(
)
override
{
return
true
;
}
void
AddWillPaintObserver
(
nsIRunnable
*
aRunnable
)
;
void
FlushWillPaintObservers
(
)
;
virtual
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
override
;
protected
:
void
InitApplyPluginGeometryTimer
(
)
;
void
CancelApplyPluginGeometryTimer
(
)
;
class
RunWillPaintObservers
:
public
mozilla
:
:
Runnable
{
public
:
explicit
RunWillPaintObservers
(
nsRootPresContext
*
aPresContext
)
:
Runnable
(
"
nsPresContextType
:
:
RunWillPaintObservers
"
)
mPresContext
(
aPresContext
)
{
}
void
Revoke
(
)
{
mPresContext
=
nullptr
;
}
NS_IMETHOD
Run
(
)
override
{
if
(
mPresContext
)
{
mPresContext
-
>
FlushWillPaintObservers
(
)
;
}
return
NS_OK
;
}
nsRootPresContext
*
MOZ_NON_OWNING_REF
mPresContext
;
}
;
friend
class
nsPresContext
;
nsCOMPtr
<
nsITimer
>
mApplyPluginGeometryTimer
;
nsTHashtable
<
nsRefPtrHashKey
<
nsIContent
>
>
mRegisteredPlugins
;
nsTArray
<
nsCOMPtr
<
nsIRunnable
>
>
mWillPaintObservers
;
nsRevocableEventPtr
<
RunWillPaintObservers
>
mWillPaintFallbackEvent
;
}
;
#
ifdef
MOZ_REFLOW_PERF
#
define
DO_GLOBAL_REFLOW_COUNT
(
_name
)
\
aPresContext
-
>
CountReflows
(
(
_name
)
(
nsIFrame
*
)
this
)
;
#
else
#
define
DO_GLOBAL_REFLOW_COUNT
(
_name
)
#
endif
#
endif
