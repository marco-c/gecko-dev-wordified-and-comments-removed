#
ifndef
nsPresContext_h___
#
define
nsPresContext_h___
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
MediaFeatureChange
.
h
"
#
include
"
mozilla
/
NotNull
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
WeakPtr
.
h
"
#
include
"
nsColor
.
h
"
#
include
"
nsCoord
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsIPresShellInlines
.
h
"
#
include
"
nsRect
.
h
"
#
include
"
nsStringFwd
.
h
"
#
include
"
nsFont
.
h
"
#
include
"
gfxFontConstants
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsITimer
.
h
"
#
include
"
nsCRT
.
h
"
#
include
"
nsIWidgetListener
.
h
"
#
include
"
nsLanguageAtomService
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsChangeHint
.
h
"
#
include
<
algorithm
>
#
include
"
gfxTypes
.
h
"
#
include
"
gfxRect
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
TimeStamp
.
h
"
#
include
"
mozilla
/
AppUnits
.
h
"
#
include
"
prclist
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
ScrollbarStyles
.
h
"
#
include
"
nsIMessageManager
.
h
"
#
include
"
Units
.
h
"
#
include
"
prenv
.
h
"
#
include
"
mozilla
/
StaticPresData
.
h
"
class
nsBidi
;
class
nsIPrintSettings
;
class
nsDocShell
;
class
nsIDocShell
;
class
nsIDocument
;
class
nsITheme
;
class
nsIContent
;
class
nsIFrame
;
class
nsFrameManager
;
class
nsILinkHandler
;
class
nsAtom
;
class
nsIRunnable
;
class
gfxFontFeatureValueSet
;
class
gfxUserFontEntry
;
class
gfxUserFontSet
;
class
gfxTextPerfMetrics
;
class
nsCSSFontFeatureValuesRule
;
class
nsPluginFrame
;
class
nsTransitionManager
;
class
nsAnimationManager
;
class
nsRefreshDriver
;
class
nsIWidget
;
class
nsDeviceContext
;
class
gfxMissingFontRecorder
;
namespace
mozilla
{
class
AnimationEventDispatcher
;
class
EffectCompositor
;
class
Encoding
;
class
EventStateManager
;
class
CounterStyleManager
;
class
RestyleManager
;
namespace
layers
{
class
ContainerLayer
;
class
LayerManager
;
}
namespace
dom
{
class
Element
;
}
}
enum
nsPresContext_CachedBoolPrefType
{
kPresContext_UseDocumentFonts
=
1
kPresContext_UnderlineLinks
}
;
enum
nsPresContext_CachedIntPrefType
{
kPresContext_ScrollbarSide
=
1
kPresContext_BidiDirection
}
;
const
uint8_t
kPresContext_DefaultVariableFont_ID
=
0x00
;
const
uint8_t
kPresContext_DefaultFixedFont_ID
=
0x01
;
#
ifdef
DEBUG
struct
nsAutoLayoutPhase
;
enum
nsLayoutPhase
{
eLayoutPhase_Paint
eLayoutPhase_DisplayListBuilding
eLayoutPhase_Reflow
eLayoutPhase_FrameC
eLayoutPhase_COUNT
}
;
#
endif
#
define
NS_AUTHOR_SPECIFIED_BACKGROUND
(
1
<
<
0
)
#
define
NS_AUTHOR_SPECIFIED_BORDER
(
1
<
<
1
)
#
define
NS_AUTHOR_SPECIFIED_PADDING
(
1
<
<
2
)
class
nsRootPresContext
;
class
nsPresContext
:
public
nsISupports
public
mozilla
:
:
SupportsWeakPtr
<
nsPresContext
>
{
public
:
using
Encoding
=
mozilla
:
:
Encoding
;
template
<
typename
T
>
using
NotNull
=
mozilla
:
:
NotNull
<
T
>
;
typedef
mozilla
:
:
LangGroupFontPrefs
LangGroupFontPrefs
;
typedef
mozilla
:
:
ScrollbarStyles
ScrollbarStyles
;
typedef
mozilla
:
:
StaticPresData
StaticPresData
;
using
TransactionId
=
mozilla
:
:
layers
:
:
TransactionId
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
nsPresContext
)
MOZ_DECLARE_WEAKREFERENCE_TYPENAME
(
nsPresContext
)
enum
nsPresContextType
{
eContext_Galley
eContext_PrintPreview
eContext_Print
eContext_PageLayout
}
;
nsPresContext
(
nsIDocument
*
aDocument
nsPresContextType
aType
)
;
nsresult
Init
(
nsDeviceContext
*
aDeviceContext
)
;
void
AttachShell
(
nsIPresShell
*
aShell
)
;
void
DetachShell
(
)
;
nsPresContextType
Type
(
)
const
{
return
mType
;
}
nsIPresShell
*
PresShell
(
)
const
{
NS_ASSERTION
(
mShell
"
Null
pres
shell
"
)
;
return
mShell
;
}
nsIPresShell
*
GetPresShell
(
)
const
{
return
mShell
;
}
void
DispatchCharSetChange
(
NotNull
<
const
Encoding
*
>
aCharSet
)
;
nsPresContext
*
GetParentPresContext
(
)
;
nsPresContext
*
GetToplevelContentDocumentPresContext
(
)
;
nsIWidget
*
GetNearestWidget
(
nsPoint
*
aOffset
=
nullptr
)
;
nsIWidget
*
GetRootWidget
(
)
;
nsRootPresContext
*
GetRootPresContext
(
)
;
virtual
bool
IsRoot
(
)
{
return
false
;
}
nsIDocument
*
Document
(
)
const
{
NS_ASSERTION
(
!
mShell
|
|
!
mShell
-
>
GetDocument
(
)
|
|
mShell
-
>
GetDocument
(
)
=
=
mDocument
"
nsPresContext
doesn
'
t
have
the
same
document
as
nsPresShell
!
"
)
;
return
mDocument
;
}
mozilla
:
:
ServoStyleSet
*
StyleSet
(
)
const
{
return
GetPresShell
(
)
-
>
StyleSet
(
)
;
}
bool
HasPendingMediaQueryUpdates
(
)
const
{
return
!
!
mPendingMediaFeatureValuesChange
;
}
nsCSSFrameConstructor
*
FrameConstructor
(
)
{
return
PresShell
(
)
-
>
FrameConstructor
(
)
;
}
mozilla
:
:
AnimationEventDispatcher
*
AnimationEventDispatcher
(
)
{
return
mAnimationEventDispatcher
;
}
mozilla
:
:
EffectCompositor
*
EffectCompositor
(
)
{
return
mEffectCompositor
;
}
nsTransitionManager
*
TransitionManager
(
)
{
return
mTransitionManager
.
get
(
)
;
}
nsAnimationManager
*
AnimationManager
(
)
{
return
mAnimationManager
.
get
(
)
;
}
const
nsAnimationManager
*
AnimationManager
(
)
const
{
return
mAnimationManager
.
get
(
)
;
}
nsRefreshDriver
*
RefreshDriver
(
)
{
return
mRefreshDriver
;
}
mozilla
:
:
RestyleManager
*
RestyleManager
(
)
{
MOZ_ASSERT
(
mRestyleManager
)
;
return
mRestyleManager
.
get
(
)
;
}
mozilla
:
:
CounterStyleManager
*
CounterStyleManager
(
)
const
{
return
mCounterStyleManager
;
}
void
RebuildAllStyleData
(
nsChangeHint
aExtraHint
nsRestyleHint
aRestyleHint
)
;
void
PostRebuildAllStyleDataEvent
(
nsChangeHint
aExtraHint
nsRestyleHint
aRestyleHint
)
;
void
MediaFeatureValuesChanged
(
const
mozilla
:
:
MediaFeatureChange
&
aChange
)
{
if
(
mShell
)
{
mShell
-
>
EnsureStyleFlush
(
)
;
}
if
(
!
mPendingMediaFeatureValuesChange
)
{
mPendingMediaFeatureValuesChange
.
emplace
(
aChange
)
;
return
;
}
*
mPendingMediaFeatureValuesChange
|
=
aChange
;
}
void
FlushPendingMediaFeatureValuesChanged
(
)
;
void
MediaFeatureValuesChangedAllDocuments
(
const
mozilla
:
:
MediaFeatureChange
&
)
;
void
SizeModeChanged
(
nsSizeMode
aSizeMode
)
;
nsCompatibility
CompatibilityMode
(
)
const
;
void
CompatibilityModeChanged
(
)
;
uint16_t
ImageAnimationMode
(
)
const
{
return
mImageAnimationMode
;
}
void
SetImageAnimationMode
(
uint16_t
aMode
)
;
nsAtom
*
Medium
(
)
{
if
(
!
mIsEmulatingMedia
)
return
mMedium
;
return
mMediaEmulated
;
}
void
EmulateMedium
(
const
nsAString
&
aMediaType
)
;
void
StopEmulatingMedium
(
)
;
const
nsFont
*
GetDefaultFont
(
uint8_t
aFontID
nsAtom
*
aLanguage
bool
*
aNeedsToCache
=
nullptr
)
const
{
nsAtom
*
lang
=
aLanguage
?
aLanguage
:
mLanguage
.
get
(
)
;
const
LangGroupFontPrefs
*
prefs
=
GetFontPrefsForLang
(
lang
aNeedsToCache
)
;
if
(
aNeedsToCache
&
&
*
aNeedsToCache
)
{
return
nullptr
;
}
return
StaticPresData
:
:
Get
(
)
-
>
GetDefaultFontHelper
(
aFontID
lang
prefs
)
;
}
void
ForceCacheLang
(
nsAtom
*
aLanguage
)
;
void
CacheAllLangs
(
)
;
bool
GetCachedBoolPref
(
nsPresContext_CachedBoolPrefType
aPrefType
)
const
{
switch
(
aPrefType
)
{
case
kPresContext_UseDocumentFonts
:
return
mUseDocumentFonts
;
case
kPresContext_UnderlineLinks
:
return
mUnderlineLinks
;
default
:
NS_ERROR
(
"
Invalid
arg
passed
to
GetCachedBoolPref
"
)
;
}
return
false
;
}
int32_t
GetCachedIntPref
(
nsPresContext_CachedIntPrefType
aPrefType
)
const
{
switch
(
aPrefType
)
{
case
kPresContext_ScrollbarSide
:
return
mPrefScrollbarSide
;
case
kPresContext_BidiDirection
:
return
mPrefBidiDirection
;
default
:
NS_ERROR
(
"
invalid
arg
passed
to
GetCachedIntPref
"
)
;
}
return
false
;
}
nscolor
DefaultColor
(
)
const
{
return
mDefaultColor
;
}
nscolor
DefaultBackgroundColor
(
)
const
{
return
mBackgroundColor
;
}
nscolor
DefaultLinkColor
(
)
const
{
return
mLinkColor
;
}
nscolor
DefaultActiveLinkColor
(
)
const
{
return
mActiveLinkColor
;
}
nscolor
DefaultVisitedLinkColor
(
)
const
{
return
mVisitedLinkColor
;
}
nscolor
FocusBackgroundColor
(
)
const
{
return
mFocusBackgroundColor
;
}
nscolor
FocusTextColor
(
)
const
{
return
mFocusTextColor
;
}
nscolor
BodyTextColor
(
)
const
{
return
mBodyTextColor
;
}
void
SetBodyTextColor
(
nscolor
aColor
)
{
mBodyTextColor
=
aColor
;
}
bool
GetUseFocusColors
(
)
const
{
return
mUseFocusColors
;
}
uint8_t
FocusRingWidth
(
)
const
{
return
mFocusRingWidth
;
}
bool
GetFocusRingOnAnything
(
)
const
{
return
mFocusRingOnAnything
;
}
uint8_t
GetFocusRingStyle
(
)
const
{
return
mFocusRingStyle
;
}
void
SetContainer
(
nsIDocShell
*
aContainer
)
;
nsISupports
*
GetContainerWeak
(
)
const
;
nsIDocShell
*
GetDocShell
(
)
const
;
void
SetLinkHandler
(
nsILinkHandler
*
aHandler
)
{
mLinkHandler
=
aHandler
;
}
nsILinkHandler
*
GetLinkHandler
(
)
{
return
mLinkHandler
;
}
virtual
void
Detach
(
)
;
nsRect
GetVisibleArea
(
)
const
{
return
mVisibleArea
;
}
void
SetVisibleArea
(
const
nsRect
&
r
)
{
if
(
!
r
.
IsEqualEdges
(
mVisibleArea
)
)
{
mVisibleArea
=
r
;
if
(
!
IsPaginated
(
)
)
{
MediaFeatureValuesChanged
(
{
mozilla
:
:
MediaFeatureChangeReason
:
:
ViewportChange
}
)
;
}
}
}
bool
ShouldFireResizeEvent
(
)
const
{
return
!
mLastResizeEventVisibleArea
.
IsEqualEdges
(
mVisibleArea
)
;
}
void
WillFireResizeEvent
(
)
{
mLastResizeEventVisibleArea
=
mVisibleArea
;
}
bool
IsPaginated
(
)
const
{
return
mPaginated
;
}
void
SetPaginatedScrolling
(
bool
aResult
)
;
bool
HasPaginatedScrolling
(
)
const
{
return
mCanPaginatedScroll
;
}
nsSize
GetPageSize
(
)
{
return
mPageSize
;
}
void
SetPageSize
(
nsSize
aSize
)
{
mPageSize
=
aSize
;
}
bool
IsRootPaginatedDocument
(
)
{
return
mIsRootPaginatedDocument
;
}
void
SetIsRootPaginatedDocument
(
bool
aIsRootPaginatedDocument
)
{
mIsRootPaginatedDocument
=
aIsRootPaginatedDocument
;
}
float
GetPageScale
(
)
{
return
mPageScale
;
}
void
SetPageScale
(
float
aScale
)
{
mPageScale
=
aScale
;
}
float
GetPrintPreviewScale
(
)
{
return
mPPScale
;
}
void
SetPrintPreviewScale
(
float
aScale
)
{
mPPScale
=
aScale
;
}
nsDeviceContext
*
DeviceContext
(
)
const
{
return
mDeviceContext
;
}
mozilla
:
:
EventStateManager
*
EventStateManager
(
)
{
return
mEventManager
;
}
nsAtom
*
GetLanguageFromCharset
(
)
const
{
return
mLanguage
;
}
already_AddRefed
<
nsAtom
>
GetContentLanguage
(
)
const
;
float
GetSystemFontScale
(
)
const
{
return
mSystemFontScale
;
}
void
SetSystemFontScale
(
float
aFontScale
)
{
MOZ_ASSERT
(
aFontScale
>
0
.
0f
"
invalid
font
scale
"
)
;
if
(
aFontScale
=
=
mSystemFontScale
|
|
IsPrintingOrPrintPreview
(
)
)
{
return
;
}
mSystemFontScale
=
aFontScale
;
UpdateEffectiveTextZoom
(
)
;
}
float
TextZoom
(
)
const
{
return
mTextZoom
;
}
void
SetTextZoom
(
float
aZoom
)
{
MOZ_ASSERT
(
aZoom
>
0
.
0f
"
invalid
zoom
factor
"
)
;
if
(
aZoom
=
=
mTextZoom
)
return
;
mTextZoom
=
aZoom
;
UpdateEffectiveTextZoom
(
)
;
}
protected
:
void
UpdateEffectiveTextZoom
(
)
;
public
:
float
EffectiveTextZoom
(
)
const
{
return
mEffectiveTextZoom
;
}
int32_t
MinFontSize
(
nsAtom
*
aLanguage
bool
*
aNeedsToCache
=
nullptr
)
const
{
const
LangGroupFontPrefs
*
prefs
=
GetFontPrefsForLang
(
aLanguage
aNeedsToCache
)
;
if
(
aNeedsToCache
&
&
*
aNeedsToCache
)
{
return
0
;
}
return
std
:
:
max
(
mBaseMinFontSize
prefs
-
>
mMinimumFontSize
)
;
}
int32_t
BaseMinFontSize
(
)
const
{
return
mBaseMinFontSize
;
}
void
SetBaseMinFontSize
(
int32_t
aMinFontSize
)
{
if
(
aMinFontSize
=
=
mBaseMinFontSize
)
{
return
;
}
mBaseMinFontSize
=
aMinFontSize
;
MediaFeatureValuesChanged
(
{
eRestyle_ForceDescendants
NS_STYLE_HINT_REFLOW
mozilla
:
:
MediaFeatureChangeReason
:
:
MinFontSizeChange
}
)
;
}
float
GetFullZoom
(
)
{
return
mFullZoom
;
}
float
GetDeviceFullZoom
(
)
;
void
SetFullZoom
(
float
aZoom
)
;
float
GetOverrideDPPX
(
)
{
return
mOverrideDPPX
;
}
void
SetOverrideDPPX
(
float
aDPPX
)
;
nscoord
GetAutoQualityMinFontSize
(
)
{
return
DevPixelsToAppUnits
(
mAutoQualityMinFontSizePixelsPref
)
;
}
gfxSize
ScreenSizeInchesForFontInflation
(
bool
*
aChanged
=
nullptr
)
;
static
int32_t
AppUnitsPerCSSPixel
(
)
{
return
mozilla
:
:
AppUnitsPerCSSPixel
(
)
;
}
int32_t
AppUnitsPerDevPixel
(
)
const
;
static
int32_t
AppUnitsPerCSSInch
(
)
{
return
mozilla
:
:
AppUnitsPerCSSInch
(
)
;
}
static
nscoord
CSSPixelsToAppUnits
(
int32_t
aPixels
)
{
return
NSToCoordRoundWithClamp
(
float
(
aPixels
)
*
float
(
AppUnitsPerCSSPixel
(
)
)
)
;
}
static
nscoord
CSSPixelsToAppUnits
(
float
aPixels
)
{
return
NSToCoordRoundWithClamp
(
aPixels
*
float
(
AppUnitsPerCSSPixel
(
)
)
)
;
}
static
int32_t
AppUnitsToIntCSSPixels
(
nscoord
aAppUnits
)
{
return
NSAppUnitsToIntPixels
(
aAppUnits
float
(
AppUnitsPerCSSPixel
(
)
)
)
;
}
static
float
AppUnitsToFloatCSSPixels
(
nscoord
aAppUnits
)
{
return
NSAppUnitsToFloatPixels
(
aAppUnits
float
(
AppUnitsPerCSSPixel
(
)
)
)
;
}
static
double
AppUnitsToDoubleCSSPixels
(
nscoord
aAppUnits
)
{
return
NSAppUnitsToDoublePixels
(
aAppUnits
double
(
AppUnitsPerCSSPixel
(
)
)
)
;
}
nscoord
DevPixelsToAppUnits
(
int32_t
aPixels
)
const
{
return
NSIntPixelsToAppUnits
(
aPixels
AppUnitsPerDevPixel
(
)
)
;
}
int32_t
AppUnitsToDevPixels
(
nscoord
aAppUnits
)
const
{
return
NSAppUnitsToIntPixels
(
aAppUnits
float
(
AppUnitsPerDevPixel
(
)
)
)
;
}
float
AppUnitsToFloatDevPixels
(
nscoord
aAppUnits
)
{
return
aAppUnits
/
float
(
AppUnitsPerDevPixel
(
)
)
;
}
int32_t
CSSPixelsToDevPixels
(
int32_t
aPixels
)
{
return
AppUnitsToDevPixels
(
CSSPixelsToAppUnits
(
aPixels
)
)
;
}
float
CSSPixelsToDevPixels
(
float
aPixels
)
{
return
NSAppUnitsToFloatPixels
(
CSSPixelsToAppUnits
(
aPixels
)
float
(
AppUnitsPerDevPixel
(
)
)
)
;
}
int32_t
DevPixelsToIntCSSPixels
(
int32_t
aPixels
)
{
return
AppUnitsToIntCSSPixels
(
DevPixelsToAppUnits
(
aPixels
)
)
;
}
float
DevPixelsToFloatCSSPixels
(
int32_t
aPixels
)
{
return
AppUnitsToFloatCSSPixels
(
DevPixelsToAppUnits
(
aPixels
)
)
;
}
mozilla
:
:
CSSToLayoutDeviceScale
CSSToDevPixelScale
(
)
const
{
return
mozilla
:
:
CSSToLayoutDeviceScale
(
float
(
AppUnitsPerCSSPixel
(
)
)
/
float
(
AppUnitsPerDevPixel
(
)
)
)
;
}
nscoord
GfxUnitsToAppUnits
(
gfxFloat
aGfxUnits
)
const
;
gfxFloat
AppUnitsToGfxUnits
(
nscoord
aAppUnits
)
const
;
gfxRect
AppUnitsToGfxUnits
(
const
nsRect
&
aAppRect
)
const
{
return
gfxRect
(
AppUnitsToGfxUnits
(
aAppRect
.
x
)
AppUnitsToGfxUnits
(
aAppRect
.
y
)
AppUnitsToGfxUnits
(
aAppRect
.
Width
(
)
)
AppUnitsToGfxUnits
(
aAppRect
.
Height
(
)
)
)
;
}
static
nscoord
CSSTwipsToAppUnits
(
float
aTwips
)
{
return
NSToCoordRoundWithClamp
(
mozilla
:
:
AppUnitsPerCSSInch
(
)
*
NS_TWIPS_TO_INCHES
(
aTwips
)
)
;
}
static
nsMargin
CSSTwipsToAppUnits
(
const
nsIntMargin
&
marginInTwips
)
{
return
nsMargin
(
CSSTwipsToAppUnits
(
float
(
marginInTwips
.
top
)
)
CSSTwipsToAppUnits
(
float
(
marginInTwips
.
right
)
)
CSSTwipsToAppUnits
(
float
(
marginInTwips
.
bottom
)
)
CSSTwipsToAppUnits
(
float
(
marginInTwips
.
left
)
)
)
;
}
static
nscoord
CSSPointsToAppUnits
(
float
aPoints
)
{
return
NSToCoordRound
(
aPoints
*
mozilla
:
:
AppUnitsPerCSSInch
(
)
/
POINTS_PER_INCH_FLOAT
)
;
}
nscoord
PhysicalMillimetersToAppUnits
(
float
aMM
)
const
;
nscoord
RoundAppUnitsToNearestDevPixels
(
nscoord
aAppUnits
)
const
{
return
DevPixelsToAppUnits
(
AppUnitsToDevPixels
(
aAppUnits
)
)
;
}
mozilla
:
:
dom
:
:
Element
*
UpdateViewportScrollbarStylesOverride
(
)
;
mozilla
:
:
dom
:
:
Element
*
GetViewportScrollbarStylesOverrideElement
(
)
const
{
return
mViewportScrollbarOverrideElement
;
}
const
ScrollbarStyles
&
GetViewportScrollbarStylesOverride
(
)
const
{
return
mViewportStyleScrollbar
;
}
bool
ElementWouldPropagateScrollbarStyles
(
mozilla
:
:
dom
:
:
Element
*
aElement
)
;
bool
GetBackgroundImageDraw
(
)
const
{
return
mDrawImageBackground
;
}
void
SetBackgroundImageDraw
(
bool
aCanDraw
)
{
mDrawImageBackground
=
aCanDraw
;
}
bool
GetBackgroundColorDraw
(
)
const
{
return
mDrawColorBackground
;
}
void
SetBackgroundColorDraw
(
bool
aCanDraw
)
{
mDrawColorBackground
=
aCanDraw
;
}
bool
BidiEnabled
(
)
const
;
void
SetBidiEnabled
(
)
const
;
void
SetVisualMode
(
bool
aIsVisual
)
{
mIsVisual
=
aIsVisual
;
}
bool
IsVisualMode
(
)
const
{
return
mIsVisual
;
}
enum
class
InteractionType
:
uint32_t
{
eClickInteraction
eKeyInteraction
eMouseMoveInteraction
eScrollInteraction
}
;
void
RecordInteractionTime
(
InteractionType
aType
const
mozilla
:
:
TimeStamp
&
aTimeStamp
)
;
void
DisableInteractionTimeRecording
(
)
{
mInteractionTimeEnabled
=
false
;
}
void
SetBidi
(
uint32_t
aBidiOptions
)
;
uint32_t
GetBidi
(
)
const
;
void
SetIsRenderingOnlySelection
(
bool
aResult
)
{
mIsRenderingOnlySelection
=
aResult
;
}
bool
IsRenderingOnlySelection
(
)
const
{
return
mIsRenderingOnlySelection
;
}
bool
IsTopLevelWindowInactive
(
)
;
nsITheme
*
GetTheme
(
)
;
void
ThemeChanged
(
)
;
void
UIResolutionChanged
(
)
;
void
UIResolutionChangedSync
(
)
;
void
SysColorChanged
(
)
;
void
SetPrintSettings
(
nsIPrintSettings
*
aPrintSettings
)
;
nsIPrintSettings
*
GetPrintSettings
(
)
{
return
mPrintSettings
;
}
bool
EnsureVisible
(
)
;
#
ifdef
MOZ_REFLOW_PERF
void
CountReflows
(
const
char
*
aName
nsIFrame
*
aFrame
)
;
#
endif
void
ConstructedFrame
(
)
{
+
+
mFramesConstructed
;
}
void
ReflowedFrame
(
)
{
+
+
mFramesReflowed
;
}
uint64_t
FramesConstructedCount
(
)
{
return
mFramesConstructed
;
}
uint64_t
FramesReflowedCount
(
)
{
return
mFramesReflowed
;
}
static
nscoord
GetBorderWidthForKeyword
(
unsigned
int
aBorderWidthKeyword
)
{
static
const
nscoord
kBorderWidths
[
]
=
{
CSSPixelsToAppUnits
(
1
)
CSSPixelsToAppUnits
(
3
)
CSSPixelsToAppUnits
(
5
)
}
;
MOZ_ASSERT
(
size_t
(
aBorderWidthKeyword
)
<
mozilla
:
:
ArrayLength
(
kBorderWidths
)
)
;
return
kBorderWidths
[
aBorderWidthKeyword
]
;
}
gfxTextPerfMetrics
*
GetTextPerfMetrics
(
)
{
return
mTextPerf
;
}
bool
IsDynamic
(
)
{
return
(
mType
=
=
eContext_PageLayout
|
|
mType
=
=
eContext_Galley
)
;
}
bool
IsScreen
(
)
{
return
(
mMedium
=
=
nsGkAtoms
:
:
screen
|
|
mType
=
=
eContext_PageLayout
|
|
mType
=
=
eContext_PrintPreview
)
;
}
bool
IsPrintingOrPrintPreview
(
)
{
return
(
mType
=
=
eContext_Print
|
|
mType
=
=
eContext_PrintPreview
)
;
}
bool
IsChrome
(
)
const
{
return
mIsChrome
;
}
bool
IsChromeOriginImage
(
)
const
{
return
mIsChromeOriginImage
;
}
void
UpdateIsChrome
(
)
;
bool
HasAuthorSpecifiedRules
(
const
nsIFrame
*
aFrame
uint32_t
ruleTypeMask
)
const
;
bool
UseDocumentColors
(
)
const
{
MOZ_ASSERT
(
mUseDocumentColors
|
|
!
(
IsChrome
(
)
|
|
IsChromeOriginImage
(
)
)
"
We
should
never
have
a
chrome
doc
or
image
that
can
'
t
use
its
colors
.
"
)
;
return
mUseDocumentColors
;
}
void
SetPaintFlashing
(
bool
aPaintFlashing
)
{
mPaintFlashing
=
aPaintFlashing
;
mPaintFlashingInitialized
=
true
;
}
bool
GetPaintFlashing
(
)
const
;
bool
SuppressingResizeReflow
(
)
const
{
return
mSuppressResizeReflow
;
}
gfxUserFontSet
*
GetUserFontSet
(
bool
aFlushUserFontSet
=
true
)
;
void
UserFontSetUpdated
(
gfxUserFontEntry
*
aUpdatedFont
=
nullptr
)
;
gfxMissingFontRecorder
*
MissingFontRecorder
(
)
{
return
mMissingFonts
;
}
void
NotifyMissingFonts
(
)
;
void
FlushCounterStyles
(
)
;
void
MarkCounterStylesDirty
(
)
;
void
FlushFontFeatureValues
(
)
;
void
MarkFontFeatureValuesDirty
(
)
{
mFontFeatureValuesDirty
=
true
;
}
void
EnsureSafeToHandOutCSSRules
(
)
;
void
NotifyInvalidation
(
TransactionId
aTransactionId
const
nsRect
&
aRect
)
;
void
NotifyInvalidation
(
TransactionId
aTransactionId
const
nsIntRect
&
aRect
)
;
void
NotifyDidPaintForSubtree
(
TransactionId
aTransactionId
=
TransactionId
{
0
}
const
mozilla
:
:
TimeStamp
&
aTimeStamp
=
mozilla
:
:
TimeStamp
(
)
)
;
void
FireDOMPaintEvent
(
nsTArray
<
nsRect
>
*
aList
TransactionId
aTransactionId
mozilla
:
:
TimeStamp
aTimeStamp
=
mozilla
:
:
TimeStamp
(
)
)
;
static
void
NotifySubDocInvalidation
(
mozilla
:
:
layers
:
:
ContainerLayer
*
aContainer
const
nsIntRegion
*
aRegion
)
;
void
SetNotifySubDocInvalidationData
(
mozilla
:
:
layers
:
:
ContainerLayer
*
aContainer
)
;
static
void
ClearNotifySubDocInvalidationData
(
mozilla
:
:
layers
:
:
ContainerLayer
*
aContainer
)
;
bool
IsDOMPaintEventPending
(
)
;
uint64_t
GetRestyleGeneration
(
)
const
;
uint64_t
GetUndisplayedRestyleGeneration
(
)
const
;
bool
HasPendingRestyleOrReflow
(
)
;
void
ReflowStarted
(
bool
aInterruptible
)
;
class
InterruptPreventer
;
friend
class
InterruptPreventer
;
class
MOZ_STACK_CLASS
InterruptPreventer
{
public
:
explicit
InterruptPreventer
(
nsPresContext
*
aCtx
)
:
mCtx
(
aCtx
)
mInterruptsEnabled
(
aCtx
-
>
mInterruptsEnabled
)
mHasPendingInterrupt
(
aCtx
-
>
mHasPendingInterrupt
)
{
mCtx
-
>
mInterruptsEnabled
=
false
;
mCtx
-
>
mHasPendingInterrupt
=
false
;
}
~
InterruptPreventer
(
)
{
mCtx
-
>
mInterruptsEnabled
=
mInterruptsEnabled
;
mCtx
-
>
mHasPendingInterrupt
=
mHasPendingInterrupt
;
}
private
:
nsPresContext
*
mCtx
;
bool
mInterruptsEnabled
;
bool
mHasPendingInterrupt
;
}
;
bool
CheckForInterrupt
(
nsIFrame
*
aFrame
)
;
bool
HasPendingInterrupt
(
)
{
return
mHasPendingInterrupt
;
}
void
SetPendingInterruptFromTest
(
)
{
mPendingInterruptFromTest
=
true
;
}
nsIFrame
*
GetPrimaryFrameFor
(
nsIContent
*
aContent
)
;
virtual
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
;
virtual
size_t
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
return
aMallocSizeOf
(
this
)
+
SizeOfExcludingThis
(
aMallocSizeOf
)
;
}
bool
IsRootContentDocument
(
)
const
;
bool
HadNonBlankPaint
(
)
const
{
return
mHadNonBlankPaint
;
}
void
NotifyNonBlankPaint
(
)
;
void
NotifyDOMContentFlushed
(
)
;
bool
UsesRootEMUnits
(
)
const
{
return
mUsesRootEMUnits
;
}
void
SetUsesRootEMUnits
(
bool
aValue
)
{
mUsesRootEMUnits
=
aValue
;
}
bool
UsesExChUnits
(
)
const
{
return
mUsesExChUnits
;
}
void
SetUsesExChUnits
(
bool
aValue
)
{
mUsesExChUnits
=
aValue
;
}
bool
ExistThrottledUpdates
(
)
const
{
return
mExistThrottledUpdates
;
}
void
SetExistThrottledUpdates
(
bool
aExistThrottledUpdates
)
{
mExistThrottledUpdates
=
aExistThrottledUpdates
;
}
bool
IsDeviceSizePageSize
(
)
;
bool
HasWarnedAboutPositionedTableParts
(
)
const
{
return
mHasWarnedAboutPositionedTableParts
;
}
void
SetHasWarnedAboutPositionedTableParts
(
)
{
mHasWarnedAboutPositionedTableParts
=
true
;
}
bool
HasWarnedAboutTooLargeDashedOrDottedRadius
(
)
const
{
return
mHasWarnedAboutTooLargeDashedOrDottedRadius
;
}
void
SetHasWarnedAboutTooLargeDashedOrDottedRadius
(
)
{
mHasWarnedAboutTooLargeDashedOrDottedRadius
=
true
;
}
nsBidi
&
GetBidiEngine
(
)
;
gfxFontFeatureValueSet
*
GetFontFeatureValuesLookup
(
)
const
{
return
mFontFeatureValuesLookup
;
}
protected
:
friend
class
nsRunnableMethod
<
nsPresContext
>
;
void
ThemeChangedInternal
(
)
;
void
SysColorChangedInternal
(
)
;
void
RefreshSystemMetrics
(
)
;
void
UIResolutionChangedInternal
(
)
;
void
UIResolutionChangedInternalScale
(
double
aScale
)
;
static
bool
UIResolutionChangedSubdocumentCallback
(
nsIDocument
*
aDocument
void
*
aData
)
;
void
SetImgAnimations
(
nsIContent
*
aParent
uint16_t
aMode
)
;
void
SetSMILAnimations
(
nsIDocument
*
aDoc
uint16_t
aNewMode
uint16_t
aOldMode
)
;
void
GetDocumentColorPreferences
(
)
;
void
PreferenceChanged
(
const
char
*
aPrefName
)
;
static
void
PrefChangedCallback
(
const
char
*
nsPresContext
*
)
;
void
UpdateAfterPreferencesChanged
(
)
;
void
DispatchPrefChangedRunnableIfNeeded
(
)
;
void
GetUserPreferences
(
)
;
const
LangGroupFontPrefs
*
GetFontPrefsForLang
(
nsAtom
*
aLanguage
bool
*
aNeedsToCache
=
nullptr
)
const
{
nsAtom
*
lang
=
aLanguage
?
aLanguage
:
mLanguage
.
get
(
)
;
return
StaticPresData
:
:
Get
(
)
-
>
GetFontPrefsForLangHelper
(
lang
&
mLangGroupFontPrefs
aNeedsToCache
)
;
}
void
UpdateCharSet
(
NotNull
<
const
Encoding
*
>
aCharSet
)
;
static
bool
NotifyDidPaintSubdocumentCallback
(
nsIDocument
*
aDocument
void
*
aData
)
;
public
:
void
ForceReflowForFontInfoUpdate
(
)
;
void
DoChangeCharSet
(
NotNull
<
const
Encoding
*
>
aCharSet
)
;
bool
MayHavePaintEventListener
(
)
;
bool
MayHavePaintEventListenerInSubDocument
(
)
;
void
InvalidatePaintedLayers
(
)
;
protected
:
void
Destroy
(
)
;
void
AppUnitsPerDevPixelChanged
(
)
;
bool
HavePendingInputEvent
(
)
;
already_AddRefed
<
nsITimer
>
CreateTimer
(
nsTimerCallbackFunc
aCallback
const
char
*
aName
uint32_t
aDelay
)
;
struct
TransactionInvalidations
{
TransactionId
mTransactionId
;
nsTArray
<
nsRect
>
mInvalidations
;
}
;
TransactionInvalidations
*
GetInvalidations
(
TransactionId
aTransactionId
)
;
nsPresContextType
mType
;
nsIPresShell
*
MOZ_NON_OWNING_REF
mShell
;
nsCOMPtr
<
nsIDocument
>
mDocument
;
RefPtr
<
nsDeviceContext
>
mDeviceContext
;
RefPtr
<
mozilla
:
:
EventStateManager
>
mEventManager
;
RefPtr
<
nsRefreshDriver
>
mRefreshDriver
;
RefPtr
<
mozilla
:
:
AnimationEventDispatcher
>
mAnimationEventDispatcher
;
RefPtr
<
mozilla
:
:
EffectCompositor
>
mEffectCompositor
;
mozilla
:
:
UniquePtr
<
nsTransitionManager
>
mTransitionManager
;
mozilla
:
:
UniquePtr
<
nsAnimationManager
>
mAnimationManager
;
mozilla
:
:
UniquePtr
<
mozilla
:
:
RestyleManager
>
mRestyleManager
;
RefPtr
<
mozilla
:
:
CounterStyleManager
>
mCounterStyleManager
;
nsAtom
*
MOZ_UNSAFE_REF
(
"
always
a
static
atom
"
)
mMedium
;
RefPtr
<
nsAtom
>
mMediaEmulated
;
RefPtr
<
gfxFontFeatureValueSet
>
mFontFeatureValuesLookup
;
nsILinkHandler
*
MOZ_NON_OWNING_REF
mLinkHandler
;
RefPtr
<
nsAtom
>
mLanguage
;
public
:
bool
mInflationDisabledForShrinkWrap
;
protected
:
mozilla
:
:
WeakPtr
<
nsDocShell
>
mContainer
;
int32_t
mBaseMinFontSize
;
float
mSystemFontScale
;
float
mTextZoom
;
float
mEffectiveTextZoom
;
float
mFullZoom
;
float
mOverrideDPPX
;
gfxSize
mLastFontInflationScreenSize
;
int32_t
mCurAppUnitsPerDevPixel
;
int32_t
mAutoQualityMinFontSizePixelsPref
;
nsCOMPtr
<
nsITheme
>
mTheme
;
nsLanguageAtomService
*
mLangService
;
nsCOMPtr
<
nsIPrintSettings
>
mPrintSettings
;
mozilla
:
:
UniquePtr
<
nsBidi
>
mBidiEngine
;
AutoTArray
<
TransactionInvalidations
4
>
mTransactions
;
nsAutoPtr
<
gfxTextPerfMetrics
>
mTextPerf
;
nsAutoPtr
<
gfxMissingFontRecorder
>
mMissingFonts
;
nsRect
mVisibleArea
;
nsRect
mLastResizeEventVisibleArea
;
nsSize
mPageSize
;
float
mPageScale
;
float
mPPScale
;
nscolor
mDefaultColor
;
nscolor
mBackgroundColor
;
nscolor
mLinkColor
;
nscolor
mActiveLinkColor
;
nscolor
mVisitedLinkColor
;
nscolor
mFocusBackgroundColor
;
nscolor
mFocusTextColor
;
nscolor
mBodyTextColor
;
mozilla
:
:
dom
:
:
Element
*
MOZ_NON_OWNING_REF
mViewportScrollbarOverrideElement
;
ScrollbarStyles
mViewportStyleScrollbar
;
uint8_t
mFocusRingWidth
;
bool
mExistThrottledUpdates
;
uint16_t
mImageAnimationMode
;
uint16_t
mImageAnimationModePref
;
LangGroupFontPrefs
mLangGroupFontPrefs
;
bool
mFontGroupCacheDirty
;
nsTHashtable
<
nsRefPtrHashKey
<
nsAtom
>
>
mLanguagesUsed
;
nscoord
mBorderWidthTable
[
3
]
;
uint32_t
mInterruptChecksToSkip
;
uint64_t
mElementsRestyled
;
uint64_t
mFramesConstructed
;
uint64_t
mFramesReflowed
;
mozilla
:
:
TimeStamp
mReflowStartTime
;
mozilla
:
:
TimeStamp
mFirstNonBlankPaintTime
;
mozilla
:
:
TimeStamp
mFirstClickTime
;
mozilla
:
:
TimeStamp
mFirstKeyTime
;
mozilla
:
:
TimeStamp
mFirstMouseMoveTime
;
mozilla
:
:
TimeStamp
mFirstScrollTime
;
bool
mInteractionTimeEnabled
;
mozilla
:
:
TimeStamp
mLastStyleUpdateForAllAnimations
;
unsigned
mHasPendingInterrupt
:
1
;
unsigned
mPendingInterruptFromTest
:
1
;
unsigned
mInterruptsEnabled
:
1
;
unsigned
mUseDocumentFonts
:
1
;
unsigned
mUseDocumentColors
:
1
;
unsigned
mUnderlineLinks
:
1
;
unsigned
mSendAfterPaintToContent
:
1
;
unsigned
mUseFocusColors
:
1
;
unsigned
mFocusRingOnAnything
:
1
;
unsigned
mFocusRingStyle
:
1
;
unsigned
mDrawImageBackground
:
1
;
unsigned
mDrawColorBackground
:
1
;
unsigned
mNeverAnimate
:
1
;
unsigned
mIsRenderingOnlySelection
:
1
;
unsigned
mPaginated
:
1
;
unsigned
mCanPaginatedScroll
:
1
;
unsigned
mDoScaledTwips
:
1
;
unsigned
mIsRootPaginatedDocument
:
1
;
unsigned
mPrefBidiDirection
:
1
;
unsigned
mPrefScrollbarSide
:
2
;
unsigned
mPendingSysColorChanged
:
1
;
unsigned
mPendingThemeChanged
:
1
;
unsigned
mPendingUIResolutionChanged
:
1
;
unsigned
mPrefChangePendingNeedsReflow
:
1
;
unsigned
mPostedPrefChangedRunnable
:
1
;
unsigned
mIsEmulatingMedia
:
1
;
unsigned
mIsGlyph
:
1
;
unsigned
mUsesRootEMUnits
:
1
;
unsigned
mUsesExChUnits
:
1
;
unsigned
mCounterStylesDirty
:
1
;
unsigned
mFontFeatureValuesDirty
:
1
;
unsigned
mSuppressResizeReflow
:
1
;
unsigned
mIsVisual
:
1
;
unsigned
mIsChrome
:
1
;
unsigned
mIsChromeOriginImage
:
1
;
mutable
unsigned
mPaintFlashing
:
1
;
mutable
unsigned
mPaintFlashingInitialized
:
1
;
unsigned
mHasWarnedAboutPositionedTableParts
:
1
;
unsigned
mHasWarnedAboutTooLargeDashedOrDottedRadius
:
1
;
unsigned
mQuirkSheetAdded
:
1
;
unsigned
mNeedsPrefUpdate
:
1
;
unsigned
mHadNonBlankPaint
:
1
;
#
ifdef
DEBUG
unsigned
mInitialized
:
1
;
#
endif
mozilla
:
:
Maybe
<
mozilla
:
:
MediaFeatureChange
>
mPendingMediaFeatureValuesChange
;
protected
:
virtual
~
nsPresContext
(
)
;
nscolor
MakeColorPref
(
const
nsString
&
aColor
)
;
void
LastRelease
(
)
;
#
ifdef
DEBUG
private
:
friend
struct
nsAutoLayoutPhase
;
uint32_t
mLayoutPhaseCount
[
eLayoutPhase_COUNT
]
;
public
:
uint32_t
LayoutPhaseCount
(
nsLayoutPhase
aPhase
)
{
return
mLayoutPhaseCount
[
aPhase
]
;
}
#
endif
}
;
class
nsRootPresContext
final
:
public
nsPresContext
{
public
:
nsRootPresContext
(
nsIDocument
*
aDocument
nsPresContextType
aType
)
;
virtual
~
nsRootPresContext
(
)
;
virtual
void
Detach
(
)
override
;
void
EnsureEventualDidPaintEvent
(
TransactionId
aTransactionId
)
;
void
CancelDidPaintTimers
(
TransactionId
aTransactionId
)
;
void
CancelAllDidPaintTimers
(
)
;
void
RegisterPluginForGeometryUpdates
(
nsIContent
*
aPlugin
)
;
void
UnregisterPluginForGeometryUpdates
(
nsIContent
*
aPlugin
)
;
bool
NeedToComputePluginGeometryUpdates
(
)
{
return
mRegisteredPlugins
.
Count
(
)
>
0
;
}
void
ComputePluginGeometryUpdates
(
nsIFrame
*
aFrame
nsDisplayListBuilder
*
aBuilder
nsDisplayList
*
aList
)
;
void
ApplyPluginGeometryUpdates
(
)
;
void
CollectPluginGeometryUpdates
(
mozilla
:
:
layers
:
:
LayerManager
*
aLayerManager
)
;
virtual
bool
IsRoot
(
)
override
{
return
true
;
}
void
AddWillPaintObserver
(
nsIRunnable
*
aRunnable
)
;
void
FlushWillPaintObservers
(
)
;
virtual
size_t
SizeOfExcludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
override
;
protected
:
void
InitApplyPluginGeometryTimer
(
)
;
void
CancelApplyPluginGeometryTimer
(
)
;
class
RunWillPaintObservers
:
public
mozilla
:
:
Runnable
{
public
:
explicit
RunWillPaintObservers
(
nsRootPresContext
*
aPresContext
)
:
Runnable
(
"
nsPresContextType
:
:
RunWillPaintObservers
"
)
mPresContext
(
aPresContext
)
{
}
void
Revoke
(
)
{
mPresContext
=
nullptr
;
}
NS_IMETHOD
Run
(
)
override
{
if
(
mPresContext
)
{
mPresContext
-
>
FlushWillPaintObservers
(
)
;
}
return
NS_OK
;
}
nsRootPresContext
*
MOZ_NON_OWNING_REF
mPresContext
;
}
;
friend
class
nsPresContext
;
struct
NotifyDidPaintTimer
{
TransactionId
mTransactionId
;
nsCOMPtr
<
nsITimer
>
mTimer
;
}
;
AutoTArray
<
NotifyDidPaintTimer
4
>
mNotifyDidPaintTimers
;
nsCOMPtr
<
nsITimer
>
mApplyPluginGeometryTimer
;
nsTHashtable
<
nsRefPtrHashKey
<
nsIContent
>
>
mRegisteredPlugins
;
nsTArray
<
nsCOMPtr
<
nsIRunnable
>
>
mWillPaintObservers
;
nsRevocableEventPtr
<
RunWillPaintObservers
>
mWillPaintFallbackEvent
;
}
;
#
ifdef
MOZ_REFLOW_PERF
#
define
DO_GLOBAL_REFLOW_COUNT
(
_name
)
\
aPresContext
-
>
CountReflows
(
(
_name
)
(
nsIFrame
*
)
this
)
;
#
else
#
define
DO_GLOBAL_REFLOW_COUNT
(
_name
)
#
endif
#
endif
