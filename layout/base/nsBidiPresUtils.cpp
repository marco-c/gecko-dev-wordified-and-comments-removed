#
include
"
nsBidiPresUtils
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
nsFontMetrics
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsBidiUtils
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsInlineFrame
.
h
"
#
include
"
nsPlaceholderFrame
.
h
"
#
include
"
nsPointerHashKeys
.
h
"
#
include
"
nsFirstLetterFrame
.
h
"
#
include
"
nsUnicodeProperties
.
h
"
#
include
"
nsTextFrame
.
h
"
#
include
"
nsBlockFrame
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsStyleStructInlines
.
h
"
#
include
"
RubyUtils
.
h
"
#
include
"
nsRubyFrame
.
h
"
#
include
"
nsRubyBaseFrame
.
h
"
#
include
"
nsRubyTextFrame
.
h
"
#
include
"
nsRubyBaseContainerFrame
.
h
"
#
include
"
nsRubyTextContainerFrame
.
h
"
#
include
<
algorithm
>
#
undef
NOISY_BIDI
#
undef
REALLY_NOISY_BIDI
using
namespace
mozilla
;
static
const
char16_t
kSpace
=
0x0020
;
static
const
char16_t
kZWSP
=
0x200B
;
static
const
char16_t
kLineSeparator
=
0x2028
;
static
const
char16_t
kObjectSubstitute
=
0xFFFC
;
static
const
char16_t
kLRE
=
0x202A
;
static
const
char16_t
kRLE
=
0x202B
;
static
const
char16_t
kLRO
=
0x202D
;
static
const
char16_t
kRLO
=
0x202E
;
static
const
char16_t
kPDF
=
0x202C
;
static
const
char16_t
kLRI
=
0x2066
;
static
const
char16_t
kRLI
=
0x2067
;
static
const
char16_t
kFSI
=
0x2068
;
static
const
char16_t
kPDI
=
0x2069
;
static
const
char16_t
kSeparators
[
]
=
{
char16_t
(
'
\
t
'
)
char16_t
(
'
\
r
'
)
char16_t
(
'
\
n
'
)
char16_t
(
0xb
)
char16_t
(
0x1c
)
char16_t
(
0x1d
)
char16_t
(
0x1e
)
char16_t
(
0x1f
)
char16_t
(
0x85
)
char16_t
(
0x2029
)
char16_t
(
0
)
}
;
#
define
NS_BIDI_CONTROL_FRAME
(
(
nsIFrame
*
)
0xfffb1d1
)
enum
class
BidiControlFrameType
{
Value
}
;
static
bool
IsIsolateControl
(
char16_t
aChar
)
{
return
aChar
=
=
kLRI
|
|
aChar
=
=
kRLI
|
|
aChar
=
=
kFSI
;
}
static
char16_t
GetBidiOverride
(
ComputedStyle
*
aComputedStyle
)
{
const
nsStyleVisibility
*
vis
=
aComputedStyle
-
>
StyleVisibility
(
)
;
if
(
(
vis
-
>
mWritingMode
=
=
NS_STYLE_WRITING_MODE_VERTICAL_RL
|
|
vis
-
>
mWritingMode
=
=
NS_STYLE_WRITING_MODE_VERTICAL_LR
)
&
&
vis
-
>
mTextOrientation
=
=
StyleTextOrientation
:
:
Upright
)
{
return
kLRO
;
}
const
nsStyleTextReset
*
text
=
aComputedStyle
-
>
StyleTextReset
(
)
;
if
(
text
-
>
mUnicodeBidi
&
NS_STYLE_UNICODE_BIDI_BIDI_OVERRIDE
)
{
return
NS_STYLE_DIRECTION_RTL
=
=
vis
-
>
mDirection
?
kRLO
:
kLRO
;
}
return
0
;
}
static
char16_t
GetBidiControl
(
ComputedStyle
*
aComputedStyle
)
{
const
nsStyleVisibility
*
vis
=
aComputedStyle
-
>
StyleVisibility
(
)
;
const
nsStyleTextReset
*
text
=
aComputedStyle
-
>
StyleTextReset
(
)
;
if
(
text
-
>
mUnicodeBidi
&
NS_STYLE_UNICODE_BIDI_EMBED
)
{
return
NS_STYLE_DIRECTION_RTL
=
=
vis
-
>
mDirection
?
kRLE
:
kLRE
;
}
if
(
text
-
>
mUnicodeBidi
&
NS_STYLE_UNICODE_BIDI_ISOLATE
)
{
if
(
text
-
>
mUnicodeBidi
&
NS_STYLE_UNICODE_BIDI_BIDI_OVERRIDE
)
{
return
kFSI
;
}
return
NS_STYLE_DIRECTION_RTL
=
=
vis
-
>
mDirection
?
kRLI
:
kLRI
;
}
if
(
text
-
>
mUnicodeBidi
&
NS_STYLE_UNICODE_BIDI_PLAINTEXT
)
{
return
kFSI
;
}
return
0
;
}
#
ifdef
DEBUG
static
inline
bool
AreContinuationsInOrder
(
nsIFrame
*
aFrame1
nsIFrame
*
aFrame2
)
{
nsIFrame
*
f
=
aFrame1
;
do
{
f
=
f
-
>
GetNextContinuation
(
)
;
}
while
(
f
&
&
f
!
=
aFrame2
)
;
return
!
!
f
;
}
#
endif
struct
MOZ_STACK_CLASS
BidiParagraphData
{
struct
FrameInfo
{
FrameInfo
(
nsIFrame
*
aFrame
nsBlockInFlowLineIterator
&
aLineIter
)
:
mFrame
(
aFrame
)
mBlockContainer
(
aLineIter
.
GetContainer
(
)
)
mInOverflow
(
aLineIter
.
GetInOverflow
(
)
)
{
}
explicit
FrameInfo
(
BidiControlFrameType
aValue
)
:
mFrame
(
NS_BIDI_CONTROL_FRAME
)
mBlockContainer
(
nullptr
)
mInOverflow
(
false
)
{
}
FrameInfo
(
)
:
mFrame
(
nullptr
)
mBlockContainer
(
nullptr
)
mInOverflow
(
false
)
{
}
nsIFrame
*
mFrame
;
nsBlockFrame
*
mBlockContainer
;
bool
mInOverflow
;
}
;
nsAutoString
mBuffer
;
AutoTArray
<
char16_t
16
>
mEmbeddingStack
;
AutoTArray
<
FrameInfo
16
>
mLogicalFrames
;
nsDataHashtable
<
nsPtrHashKey
<
const
nsIContent
>
int32_t
>
mContentToFrameIndex
;
nsPresContext
*
mPresContext
;
bool
mIsVisual
;
bool
mRequiresBidi
;
nsBidiLevel
mParaLevel
;
nsIContent
*
mPrevContent
;
struct
FastLineIterator
{
FastLineIterator
(
)
:
mPrevFrame
(
nullptr
)
mNextLineStart
(
nullptr
)
{
}
nsBlockInFlowLineIterator
mLineIterator
;
nsIFrame
*
mPrevFrame
;
nsIFrame
*
mNextLineStart
;
nsLineList
:
:
iterator
GetLine
(
)
{
return
mLineIterator
.
GetLine
(
)
;
}
static
bool
IsFrameInCurrentLine
(
nsBlockInFlowLineIterator
*
aLineIter
nsIFrame
*
aPrevFrame
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
!
aPrevFrame
|
|
aLineIter
-
>
GetLine
(
)
-
>
Contains
(
aPrevFrame
)
"
aPrevFrame
must
be
in
aLineIter
'
s
current
line
"
)
;
nsIFrame
*
endFrame
=
aLineIter
-
>
IsLastLineInList
(
)
?
nullptr
:
aLineIter
-
>
GetLine
(
)
.
next
(
)
-
>
mFirstChild
;
nsIFrame
*
startFrame
=
aPrevFrame
?
aPrevFrame
:
aLineIter
-
>
GetLine
(
)
-
>
mFirstChild
;
for
(
nsIFrame
*
frame
=
startFrame
;
frame
&
&
frame
!
=
endFrame
;
frame
=
frame
-
>
GetNextSibling
(
)
)
{
if
(
frame
=
=
aFrame
)
return
true
;
}
return
false
;
}
static
nsIFrame
*
FirstChildOfNextLine
(
nsBlockInFlowLineIterator
&
aIterator
)
{
const
nsLineList
:
:
iterator
line
=
aIterator
.
GetLine
(
)
;
const
nsLineList
:
:
iterator
lineEnd
=
aIterator
.
End
(
)
;
MOZ_ASSERT
(
line
!
=
lineEnd
"
iterator
should
start
off
valid
"
)
;
const
nsLineList
:
:
iterator
nextLine
=
line
.
next
(
)
;
return
nextLine
!
=
lineEnd
?
nextLine
-
>
mFirstChild
:
nullptr
;
}
void
AdvanceToFrame
(
nsIFrame
*
aFrame
)
{
if
(
mPrevFrame
&
&
FirstChildOfNextLine
(
mLineIterator
)
!
=
mNextLineStart
)
{
mPrevFrame
=
nullptr
;
}
nsIFrame
*
child
=
aFrame
;
nsIFrame
*
parent
=
nsLayoutUtils
:
:
GetParentOrPlaceholderFor
(
child
)
;
while
(
parent
&
&
!
parent
-
>
IsBlockFrameOrSubclass
(
)
)
{
child
=
parent
;
parent
=
nsLayoutUtils
:
:
GetParentOrPlaceholderFor
(
child
)
;
}
MOZ_ASSERT
(
parent
"
aFrame
is
not
a
descendent
of
a
block
frame
"
)
;
while
(
!
IsFrameInCurrentLine
(
&
mLineIterator
mPrevFrame
child
)
)
{
#
ifdef
DEBUG
bool
hasNext
=
#
endif
mLineIterator
.
Next
(
)
;
MOZ_ASSERT
(
hasNext
"
Can
'
t
find
frame
in
lines
!
"
)
;
mPrevFrame
=
nullptr
;
}
mPrevFrame
=
child
;
mNextLineStart
=
FirstChildOfNextLine
(
mLineIterator
)
;
}
void
AdvanceToLinesAndFrame
(
const
FrameInfo
&
aFrameInfo
)
{
if
(
mLineIterator
.
GetContainer
(
)
!
=
aFrameInfo
.
mBlockContainer
|
|
mLineIterator
.
GetInOverflow
(
)
!
=
aFrameInfo
.
mInOverflow
)
{
MOZ_ASSERT
(
mLineIterator
.
GetContainer
(
)
=
=
aFrameInfo
.
mBlockContainer
?
(
!
mLineIterator
.
GetInOverflow
(
)
&
&
aFrameInfo
.
mInOverflow
)
:
(
!
mLineIterator
.
GetContainer
(
)
|
|
AreContinuationsInOrder
(
mLineIterator
.
GetContainer
(
)
aFrameInfo
.
mBlockContainer
)
)
"
must
move
forwards
"
)
;
nsBlockFrame
*
block
=
aFrameInfo
.
mBlockContainer
;
nsLineList
:
:
iterator
lines
=
aFrameInfo
.
mInOverflow
?
block
-
>
GetOverflowLines
(
)
-
>
mLines
.
begin
(
)
:
block
-
>
LinesBegin
(
)
;
mLineIterator
=
nsBlockInFlowLineIterator
(
block
lines
aFrameInfo
.
mInOverflow
)
;
mPrevFrame
=
nullptr
;
}
AdvanceToFrame
(
aFrameInfo
.
mFrame
)
;
}
}
;
FastLineIterator
mCurrentTraverseLine
mCurrentResolveLine
;
#
ifdef
DEBUG
nsBlockFrame
*
mCurrentBlock
;
#
endif
explicit
BidiParagraphData
(
nsBlockFrame
*
aBlockFrame
)
:
mPresContext
(
aBlockFrame
-
>
PresContext
(
)
)
mIsVisual
(
mPresContext
-
>
IsVisualMode
(
)
)
mRequiresBidi
(
false
)
mParaLevel
(
nsBidiPresUtils
:
:
BidiLevelFromStyle
(
aBlockFrame
-
>
Style
(
)
)
)
mPrevContent
(
nullptr
)
#
ifdef
DEBUG
mCurrentBlock
(
aBlockFrame
)
#
endif
{
if
(
mParaLevel
>
0
)
{
mRequiresBidi
=
true
;
}
if
(
mIsVisual
)
{
for
(
nsIContent
*
content
=
aBlockFrame
-
>
GetContent
(
)
;
content
;
content
=
content
-
>
GetParent
(
)
)
{
if
(
content
-
>
IsNodeOfType
(
nsINode
:
:
eHTML_FORM_CONTROL
)
|
|
content
-
>
IsXULElement
(
)
)
{
mIsVisual
=
false
;
break
;
}
}
}
}
nsresult
SetPara
(
)
{
return
mPresContext
-
>
GetBidiEngine
(
)
.
SetPara
(
mBuffer
.
get
(
)
BufferLength
(
)
mParaLevel
)
;
}
nsBidiLevel
GetParaLevel
(
)
{
nsBidiLevel
paraLevel
=
mParaLevel
;
if
(
paraLevel
=
=
NSBIDI_DEFAULT_LTR
|
|
paraLevel
=
=
NSBIDI_DEFAULT_RTL
)
{
paraLevel
=
mPresContext
-
>
GetBidiEngine
(
)
.
GetParaLevel
(
)
;
}
return
paraLevel
;
}
nsBidiDirection
GetDirection
(
)
{
return
mPresContext
-
>
GetBidiEngine
(
)
.
GetDirection
(
)
;
}
nsresult
CountRuns
(
int32_t
*
runCount
)
{
return
mPresContext
-
>
GetBidiEngine
(
)
.
CountRuns
(
runCount
)
;
}
void
GetLogicalRun
(
int32_t
aLogicalStart
int32_t
*
aLogicalLimit
nsBidiLevel
*
aLevel
)
{
mPresContext
-
>
GetBidiEngine
(
)
.
GetLogicalRun
(
aLogicalStart
aLogicalLimit
aLevel
)
;
if
(
mIsVisual
)
{
*
aLevel
=
GetParaLevel
(
)
;
}
}
void
ResetData
(
)
{
mLogicalFrames
.
Clear
(
)
;
mContentToFrameIndex
.
Clear
(
)
;
mBuffer
.
SetLength
(
0
)
;
mPrevContent
=
nullptr
;
for
(
uint32_t
i
=
0
;
i
<
mEmbeddingStack
.
Length
(
)
;
+
+
i
)
{
mBuffer
.
Append
(
mEmbeddingStack
[
i
]
)
;
mLogicalFrames
.
AppendElement
(
FrameInfo
(
BidiControlFrameType
:
:
Value
)
)
;
}
}
void
AppendFrame
(
nsIFrame
*
aFrame
FastLineIterator
&
aLineIter
nsIContent
*
aContent
=
nullptr
)
{
if
(
aContent
)
{
mContentToFrameIndex
.
Put
(
aContent
FrameCount
(
)
)
;
}
mLogicalFrames
.
AppendElement
(
FrameInfo
(
aFrame
aLineIter
.
mLineIterator
)
)
;
}
void
AdvanceAndAppendFrame
(
nsIFrame
*
*
aFrame
FastLineIterator
&
aLineIter
nsIFrame
*
*
aNextSibling
)
{
nsIFrame
*
frame
=
*
aFrame
;
nsIFrame
*
nextSibling
=
*
aNextSibling
;
frame
=
frame
-
>
GetNextContinuation
(
)
;
if
(
frame
)
{
AppendFrame
(
frame
aLineIter
nullptr
)
;
if
(
frame
=
=
nextSibling
)
{
nextSibling
=
frame
-
>
GetNextSibling
(
)
;
}
}
*
aFrame
=
frame
;
*
aNextSibling
=
nextSibling
;
}
int32_t
GetLastFrameForContent
(
nsIContent
*
aContent
)
{
int32_t
index
=
0
;
mContentToFrameIndex
.
Get
(
aContent
&
index
)
;
return
index
;
}
int32_t
FrameCount
(
)
{
return
mLogicalFrames
.
Length
(
)
;
}
int32_t
BufferLength
(
)
{
return
mBuffer
.
Length
(
)
;
}
nsIFrame
*
FrameAt
(
int32_t
aIndex
)
{
return
mLogicalFrames
[
aIndex
]
.
mFrame
;
}
const
FrameInfo
&
FrameInfoAt
(
int32_t
aIndex
)
{
return
mLogicalFrames
[
aIndex
]
;
}
void
AppendUnichar
(
char16_t
aCh
)
{
mBuffer
.
Append
(
aCh
)
;
}
void
AppendString
(
const
nsDependentSubstring
&
aString
)
{
mBuffer
.
Append
(
aString
)
;
}
void
AppendControlChar
(
char16_t
aCh
)
{
mLogicalFrames
.
AppendElement
(
FrameInfo
(
BidiControlFrameType
:
:
Value
)
)
;
AppendUnichar
(
aCh
)
;
}
void
PushBidiControl
(
char16_t
aCh
)
{
AppendControlChar
(
aCh
)
;
mEmbeddingStack
.
AppendElement
(
aCh
)
;
}
void
AppendPopChar
(
char16_t
aCh
)
{
AppendControlChar
(
IsIsolateControl
(
aCh
)
?
kPDI
:
kPDF
)
;
}
void
PopBidiControl
(
char16_t
aCh
)
{
MOZ_ASSERT
(
mEmbeddingStack
.
Length
(
)
"
embedding
/
override
underflow
"
)
;
MOZ_ASSERT
(
aCh
=
=
mEmbeddingStack
.
LastElement
(
)
)
;
AppendPopChar
(
aCh
)
;
mEmbeddingStack
.
TruncateLength
(
mEmbeddingStack
.
Length
(
)
-
1
)
;
}
void
ClearBidiControls
(
)
{
for
(
char16_t
c
:
Reversed
(
mEmbeddingStack
)
)
{
AppendPopChar
(
c
)
;
}
}
}
;
struct
MOZ_STACK_CLASS
BidiLineData
{
AutoTArray
<
nsIFrame
*
16
>
mLogicalFrames
;
AutoTArray
<
nsIFrame
*
16
>
mVisualFrames
;
AutoTArray
<
int32_t
16
>
mIndexMap
;
AutoTArray
<
uint8_t
16
>
mLevels
;
bool
mIsReordered
;
BidiLineData
(
nsIFrame
*
aFirstFrameOnLine
int32_t
aNumFramesOnLine
)
{
bool
isReordered
=
false
;
bool
hasRTLFrames
=
false
;
bool
hasVirtualControls
=
false
;
auto
appendFrame
=
[
&
]
(
nsIFrame
*
frame
nsBidiLevel
level
)
{
mLogicalFrames
.
AppendElement
(
frame
)
;
mLevels
.
AppendElement
(
level
)
;
mIndexMap
.
AppendElement
(
0
)
;
if
(
IS_LEVEL_RTL
(
level
)
)
{
hasRTLFrames
=
true
;
}
}
;
bool
firstFrame
=
true
;
for
(
nsIFrame
*
frame
=
aFirstFrameOnLine
;
frame
&
&
aNumFramesOnLine
-
-
;
frame
=
frame
-
>
GetNextSibling
(
)
)
{
FrameBidiData
bidiData
=
nsBidiPresUtils
:
:
GetFrameBidiData
(
frame
)
;
if
(
!
firstFrame
&
&
bidiData
.
precedingControl
!
=
kBidiLevelNone
)
{
appendFrame
(
NS_BIDI_CONTROL_FRAME
bidiData
.
precedingControl
)
;
hasVirtualControls
=
true
;
}
appendFrame
(
frame
bidiData
.
embeddingLevel
)
;
firstFrame
=
false
;
}
nsBidi
:
:
ReorderVisual
(
mLevels
.
Elements
(
)
FrameCount
(
)
mIndexMap
.
Elements
(
)
)
;
if
(
hasVirtualControls
)
{
auto
originalCount
=
mLogicalFrames
.
Length
(
)
;
AutoTArray
<
int32_t
16
>
realFrameMap
;
realFrameMap
.
SetCapacity
(
originalCount
)
;
size_t
count
=
0
;
for
(
auto
i
:
IntegerRange
(
originalCount
)
)
{
if
(
mLogicalFrames
[
i
]
=
=
NS_BIDI_CONTROL_FRAME
)
{
realFrameMap
.
AppendElement
(
-
1
)
;
}
else
{
mLogicalFrames
[
count
]
=
mLogicalFrames
[
i
]
;
mLevels
[
count
]
=
mLevels
[
i
]
;
realFrameMap
.
AppendElement
(
count
)
;
count
+
+
;
}
}
for
(
size_t
i
=
0
j
=
0
;
i
<
originalCount
;
+
+
i
)
{
auto
newIndex
=
realFrameMap
[
mIndexMap
[
i
]
]
;
if
(
newIndex
!
=
-
1
)
{
mIndexMap
[
j
]
=
newIndex
;
j
+
+
;
}
}
mLogicalFrames
.
TruncateLength
(
count
)
;
mLevels
.
TruncateLength
(
count
)
;
mIndexMap
.
TruncateLength
(
count
)
;
}
for
(
int32_t
i
=
0
;
i
<
FrameCount
(
)
;
i
+
+
)
{
mVisualFrames
.
AppendElement
(
LogicalFrameAt
(
mIndexMap
[
i
]
)
)
;
if
(
i
!
=
mIndexMap
[
i
]
)
{
isReordered
=
true
;
}
}
mIsReordered
=
isReordered
|
|
hasRTLFrames
;
}
int32_t
FrameCount
(
)
const
{
return
mLogicalFrames
.
Length
(
)
;
}
nsIFrame
*
LogicalFrameAt
(
int32_t
aIndex
)
const
{
return
mLogicalFrames
[
aIndex
]
;
}
nsIFrame
*
VisualFrameAt
(
int32_t
aIndex
)
const
{
return
mVisualFrames
[
aIndex
]
;
}
}
;
#
ifdef
DEBUG
extern
"
C
"
{
void
MOZ_EXPORT
DumpFrameArray
(
const
nsTArray
<
nsIFrame
*
>
&
aFrames
)
{
for
(
nsIFrame
*
frame
:
aFrames
)
{
if
(
frame
=
=
NS_BIDI_CONTROL_FRAME
)
{
fprintf_stderr
(
stderr
"
(
Bidi
control
frame
)
\
n
"
)
;
}
else
{
frame
-
>
List
(
)
;
}
}
}
void
MOZ_EXPORT
DumpBidiLine
(
BidiLineData
*
aData
bool
aVisualOrder
)
{
DumpFrameArray
(
aVisualOrder
?
aData
-
>
mVisualFrames
:
aData
-
>
mLogicalFrames
)
;
}
}
#
endif
static
bool
IsBidiSplittable
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
)
;
LayoutFrameType
frameType
=
aFrame
-
>
Type
(
)
;
return
(
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eBidiInlineContainer
)
&
&
frameType
!
=
LayoutFrameType
:
:
Line
)
|
|
frameType
=
=
LayoutFrameType
:
:
Text
;
}
static
bool
IsBidiLeaf
(
nsIFrame
*
aFrame
)
{
nsIFrame
*
kid
=
aFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
kid
)
{
if
(
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eBidiInlineContainer
)
|
|
RubyUtils
:
:
IsRubyBox
(
aFrame
-
>
Type
(
)
)
)
{
return
false
;
}
}
return
true
;
}
static
void
SplitInlineAncestors
(
nsContainerFrame
*
aParent
nsLineList
:
:
iterator
aLine
nsIFrame
*
aFrame
)
{
nsPresContext
*
presContext
=
aParent
-
>
PresContext
(
)
;
PresShell
*
presShell
=
presContext
-
>
PresShell
(
)
;
nsIFrame
*
frame
=
aFrame
;
nsContainerFrame
*
parent
=
aParent
;
nsContainerFrame
*
newParent
;
while
(
IsBidiSplittable
(
parent
)
)
{
nsContainerFrame
*
grandparent
=
parent
-
>
GetParent
(
)
;
NS_ASSERTION
(
grandparent
"
Couldn
'
t
get
parent
'
s
parent
in
"
"
nsBidiPresUtils
:
:
SplitInlineAncestors
"
)
;
if
(
!
frame
|
|
frame
-
>
GetNextSibling
(
)
)
{
newParent
=
static_cast
<
nsContainerFrame
*
>
(
presShell
-
>
FrameConstructor
(
)
-
>
CreateContinuingFrame
(
presContext
parent
grandparent
false
)
)
;
nsFrameList
tail
=
parent
-
>
StealFramesAfter
(
frame
)
;
nsContainerFrame
:
:
ReparentFrameViewList
(
tail
parent
newParent
)
;
MOZ_ASSERT
(
!
newParent
-
>
IsBlockFrameOrSubclass
(
)
"
blocks
should
not
be
IsBidiSplittable
"
)
;
newParent
-
>
InsertFrames
(
nsIFrame
:
:
kNoReflowPrincipalList
nullptr
nullptr
tail
)
;
const
nsLineList
:
:
iterator
*
parentLine
;
if
(
grandparent
-
>
IsBlockFrameOrSubclass
(
)
)
{
MOZ_ASSERT
(
aLine
-
>
Contains
(
parent
)
)
;
parentLine
=
&
aLine
;
}
else
{
parentLine
=
nullptr
;
}
nsFrameList
temp
(
newParent
newParent
)
;
grandparent
-
>
InsertFrames
(
nsIFrame
:
:
kNoReflowPrincipalList
parent
parentLine
temp
)
;
}
frame
=
parent
;
parent
=
grandparent
;
}
}
static
void
MakeContinuationFluid
(
nsIFrame
*
aFrame
nsIFrame
*
aNext
)
{
NS_ASSERTION
(
!
aFrame
-
>
GetNextInFlow
(
)
|
|
aFrame
-
>
GetNextInFlow
(
)
=
=
aNext
"
next
-
in
-
flow
is
not
next
continuation
!
"
)
;
aFrame
-
>
SetNextInFlow
(
aNext
)
;
NS_ASSERTION
(
!
aNext
-
>
GetPrevInFlow
(
)
|
|
aNext
-
>
GetPrevInFlow
(
)
=
=
aFrame
"
prev
-
in
-
flow
is
not
prev
continuation
!
"
)
;
aNext
-
>
SetPrevInFlow
(
aFrame
)
;
}
static
void
MakeContinuationsNonFluidUpParentChain
(
nsIFrame
*
aFrame
nsIFrame
*
aNext
)
{
nsIFrame
*
frame
;
nsIFrame
*
next
;
for
(
frame
=
aFrame
next
=
aNext
;
frame
&
&
next
&
&
next
!
=
frame
&
&
next
=
=
frame
-
>
GetNextInFlow
(
)
&
&
IsBidiSplittable
(
frame
)
;
frame
=
frame
-
>
GetParent
(
)
next
=
next
-
>
GetParent
(
)
)
{
frame
-
>
SetNextContinuation
(
next
)
;
next
-
>
SetPrevContinuation
(
frame
)
;
}
}
static
void
JoinInlineAncestors
(
nsIFrame
*
aFrame
)
{
nsIFrame
*
frame
=
aFrame
;
while
(
frame
&
&
IsBidiSplittable
(
frame
)
)
{
nsIFrame
*
next
=
frame
-
>
GetNextContinuation
(
)
;
if
(
next
)
{
MakeContinuationFluid
(
frame
next
)
;
}
if
(
frame
-
>
GetNextSibling
(
)
)
break
;
frame
=
frame
-
>
GetParent
(
)
;
}
}
static
void
CreateContinuation
(
nsIFrame
*
aFrame
const
nsLineList
:
:
iterator
aLine
nsIFrame
*
*
aNewFrame
bool
aIsFluid
)
{
MOZ_ASSERT
(
aNewFrame
"
null
OUT
ptr
"
)
;
MOZ_ASSERT
(
aFrame
"
null
ptr
"
)
;
*
aNewFrame
=
nullptr
;
nsPresContext
*
presContext
=
aFrame
-
>
PresContext
(
)
;
PresShell
*
presShell
=
presContext
-
>
PresShell
(
)
;
NS_ASSERTION
(
presShell
"
PresShell
must
be
set
on
PresContext
before
calling
"
"
nsBidiPresUtils
:
:
CreateContinuation
"
)
;
nsContainerFrame
*
parent
=
aFrame
-
>
GetParent
(
)
;
NS_ASSERTION
(
parent
"
Couldn
'
t
get
frame
parent
in
nsBidiPresUtils
:
:
CreateContinuation
"
)
;
const
nsLineList
:
:
iterator
*
parentLine
;
if
(
parent
-
>
IsBlockFrameOrSubclass
(
)
)
{
MOZ_ASSERT
(
aLine
-
>
Contains
(
aFrame
)
)
;
parentLine
=
&
aLine
;
}
else
{
parentLine
=
nullptr
;
}
if
(
parent
-
>
IsLetterFrame
(
)
&
&
parent
-
>
IsFloating
(
)
)
{
nsFirstLetterFrame
*
letterFrame
=
do_QueryFrame
(
parent
)
;
letterFrame
-
>
CreateContinuationForFloatingParent
(
presContext
aFrame
aNewFrame
aIsFluid
)
;
return
;
}
*
aNewFrame
=
presShell
-
>
FrameConstructor
(
)
-
>
CreateContinuingFrame
(
presContext
aFrame
parent
aIsFluid
)
;
nsFrameList
temp
(
*
aNewFrame
*
aNewFrame
)
;
parent
-
>
InsertFrames
(
nsIFrame
:
:
kNoReflowPrincipalList
aFrame
parentLine
temp
)
;
if
(
!
aIsFluid
)
{
SplitInlineAncestors
(
parent
aLine
aFrame
)
;
}
}
nsresult
nsBidiPresUtils
:
:
Resolve
(
nsBlockFrame
*
aBlockFrame
)
{
BidiParagraphData
bpd
(
aBlockFrame
)
;
char16_t
ch
=
GetBidiOverride
(
aBlockFrame
-
>
Style
(
)
)
;
if
(
ch
!
=
0
)
{
bpd
.
PushBidiControl
(
ch
)
;
bpd
.
mRequiresBidi
=
true
;
}
else
{
nsIContent
*
currContent
=
nullptr
;
for
(
nsBlockFrame
*
block
=
aBlockFrame
;
block
;
block
=
static_cast
<
nsBlockFrame
*
>
(
block
-
>
GetNextContinuation
(
)
)
)
{
block
-
>
RemoveStateBits
(
NS_BLOCK_NEEDS_BIDI_RESOLUTION
)
;
if
(
!
bpd
.
mRequiresBidi
&
&
ChildListMayRequireBidi
(
block
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
&
currContent
)
)
{
bpd
.
mRequiresBidi
=
true
;
}
if
(
!
bpd
.
mRequiresBidi
)
{
nsBlockFrame
:
:
FrameLines
*
overflowLines
=
block
-
>
GetOverflowLines
(
)
;
if
(
overflowLines
)
{
if
(
ChildListMayRequireBidi
(
overflowLines
-
>
mFrames
.
FirstChild
(
)
&
currContent
)
)
{
bpd
.
mRequiresBidi
=
true
;
}
}
}
}
if
(
!
bpd
.
mRequiresBidi
)
{
return
NS_OK
;
}
}
for
(
nsBlockFrame
*
block
=
aBlockFrame
;
block
;
block
=
static_cast
<
nsBlockFrame
*
>
(
block
-
>
GetNextContinuation
(
)
)
)
{
#
ifdef
DEBUG
bpd
.
mCurrentBlock
=
block
;
#
endif
block
-
>
RemoveStateBits
(
NS_BLOCK_NEEDS_BIDI_RESOLUTION
)
;
bpd
.
mCurrentTraverseLine
.
mLineIterator
=
nsBlockInFlowLineIterator
(
block
block
-
>
LinesBegin
(
)
)
;
bpd
.
mCurrentTraverseLine
.
mPrevFrame
=
nullptr
;
TraverseFrames
(
block
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
&
bpd
)
;
nsBlockFrame
:
:
FrameLines
*
overflowLines
=
block
-
>
GetOverflowLines
(
)
;
if
(
overflowLines
)
{
bpd
.
mCurrentTraverseLine
.
mLineIterator
=
nsBlockInFlowLineIterator
(
block
overflowLines
-
>
mLines
.
begin
(
)
true
)
;
bpd
.
mCurrentTraverseLine
.
mPrevFrame
=
nullptr
;
TraverseFrames
(
overflowLines
-
>
mFrames
.
FirstChild
(
)
&
bpd
)
;
}
}
if
(
ch
!
=
0
)
{
bpd
.
PopBidiControl
(
ch
)
;
}
return
ResolveParagraph
(
&
bpd
)
;
}
nsresult
nsBidiPresUtils
:
:
ResolveParagraph
(
BidiParagraphData
*
aBpd
)
{
if
(
aBpd
-
>
BufferLength
(
)
<
1
)
{
return
NS_OK
;
}
aBpd
-
>
mBuffer
.
ReplaceChar
(
kSeparators
kSpace
)
;
int32_t
runCount
;
nsresult
rv
=
aBpd
-
>
SetPara
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsBidiLevel
embeddingLevel
=
aBpd
-
>
GetParaLevel
(
)
;
rv
=
aBpd
-
>
CountRuns
(
&
runCount
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
int32_t
runLength
=
0
;
int32_t
logicalLimit
=
0
;
int32_t
numRun
=
-
1
;
int32_t
fragmentLength
=
0
;
int32_t
frameIndex
=
-
1
;
int32_t
frameCount
=
aBpd
-
>
FrameCount
(
)
;
int32_t
contentOffset
=
0
;
bool
isTextFrame
=
false
;
nsIFrame
*
frame
=
nullptr
;
BidiParagraphData
:
:
FrameInfo
frameInfo
;
nsIContent
*
content
=
nullptr
;
int32_t
contentTextLength
=
0
;
#
ifdef
DEBUG
#
ifdef
NOISY_BIDI
printf
(
"
Before
Resolve
(
)
mCurrentBlock
=
%
p
mBuffer
=
'
%
s
'
frameCount
=
%
d
"
"
runCount
=
%
d
\
n
"
(
void
*
)
aBpd
-
>
mCurrentBlock
NS_ConvertUTF16toUTF8
(
aBpd
-
>
mBuffer
)
.
get
(
)
frameCount
runCount
)
;
#
ifdef
REALLY_NOISY_BIDI
printf
(
"
block
frame
tree
=
:
\
n
"
)
;
aBpd
-
>
mCurrentBlock
-
>
List
(
stdout
)
;
#
endif
#
endif
#
endif
if
(
runCount
=
=
1
&
&
frameCount
=
=
1
&
&
aBpd
-
>
GetDirection
(
)
=
=
NSBIDI_LTR
&
&
aBpd
-
>
GetParaLevel
(
)
=
=
0
)
{
nsIFrame
*
frame
=
aBpd
-
>
FrameAt
(
0
)
;
if
(
frame
!
=
NS_BIDI_CONTROL_FRAME
)
{
FrameBidiData
bidiData
=
frame
-
>
GetBidiData
(
)
;
if
(
!
bidiData
.
embeddingLevel
&
&
!
bidiData
.
baseLevel
)
{
#
ifdef
DEBUG
#
ifdef
NOISY_BIDI
printf
(
"
early
return
for
single
direction
frame
%
p
\
n
"
(
void
*
)
frame
)
;
#
endif
#
endif
frame
-
>
AddStateBits
(
NS_FRAME_IS_BIDI
)
;
return
NS_OK
;
}
}
}
BidiParagraphData
:
:
FrameInfo
lastRealFrame
;
nsBidiLevel
lastEmbeddingLevel
=
kBidiLevelNone
;
nsBidiLevel
precedingControl
=
kBidiLevelNone
;
auto
storeBidiDataToFrame
=
[
&
]
(
)
{
FrameBidiData
bidiData
;
bidiData
.
embeddingLevel
=
embeddingLevel
;
bidiData
.
baseLevel
=
aBpd
-
>
GetParaLevel
(
)
;
if
(
precedingControl
>
=
embeddingLevel
|
|
precedingControl
>
=
lastEmbeddingLevel
)
{
bidiData
.
precedingControl
=
kBidiLevelNone
;
}
else
{
bidiData
.
precedingControl
=
precedingControl
;
}
precedingControl
=
kBidiLevelNone
;
lastEmbeddingLevel
=
embeddingLevel
;
frame
-
>
SetProperty
(
nsIFrame
:
:
BidiDataProperty
(
)
bidiData
)
;
}
;
for
(
;
;
)
{
if
(
fragmentLength
<
=
0
)
{
if
(
+
+
frameIndex
>
=
frameCount
)
{
break
;
}
frameInfo
=
aBpd
-
>
FrameInfoAt
(
frameIndex
)
;
frame
=
frameInfo
.
mFrame
;
if
(
frame
=
=
NS_BIDI_CONTROL_FRAME
|
|
!
frame
-
>
IsTextFrame
(
)
)
{
isTextFrame
=
false
;
fragmentLength
=
1
;
}
else
{
aBpd
-
>
mCurrentResolveLine
.
AdvanceToLinesAndFrame
(
frameInfo
)
;
content
=
frame
-
>
GetContent
(
)
;
if
(
!
content
)
{
rv
=
NS_OK
;
break
;
}
contentTextLength
=
content
-
>
TextLength
(
)
;
int32_t
start
end
;
frame
-
>
GetOffsets
(
start
end
)
;
NS_ASSERTION
(
!
(
contentTextLength
<
end
-
start
)
"
Frame
offsets
don
'
t
fit
in
content
"
)
;
fragmentLength
=
std
:
:
min
(
contentTextLength
end
-
start
)
;
contentOffset
=
start
;
isTextFrame
=
true
;
}
}
if
(
runLength
<
=
0
)
{
if
(
+
+
numRun
>
=
runCount
)
{
storeBidiDataToFrame
(
)
;
if
(
isTextFrame
)
{
frame
-
>
AdjustOffsetsForBidi
(
contentOffset
contentOffset
+
fragmentLength
)
;
}
break
;
}
int32_t
lineOffset
=
logicalLimit
;
aBpd
-
>
GetLogicalRun
(
lineOffset
&
logicalLimit
&
embeddingLevel
)
;
runLength
=
logicalLimit
-
lineOffset
;
}
if
(
frame
=
=
NS_BIDI_CONTROL_FRAME
)
{
precedingControl
=
std
:
:
min
(
precedingControl
embeddingLevel
)
;
}
else
{
storeBidiDataToFrame
(
)
;
if
(
isTextFrame
)
{
if
(
contentTextLength
=
=
0
)
{
frame
-
>
AdjustOffsetsForBidi
(
0
0
)
;
lastRealFrame
=
frameInfo
;
continue
;
}
nsLineList
:
:
iterator
currentLine
=
aBpd
-
>
mCurrentResolveLine
.
GetLine
(
)
;
if
(
(
runLength
>
0
)
&
&
(
runLength
<
fragmentLength
)
)
{
currentLine
-
>
MarkDirty
(
)
;
nsIFrame
*
nextBidi
;
int32_t
runEnd
=
contentOffset
+
runLength
;
EnsureBidiContinuation
(
frame
currentLine
&
nextBidi
contentOffset
runEnd
)
;
nextBidi
-
>
AdjustOffsetsForBidi
(
runEnd
contentOffset
+
fragmentLength
)
;
frame
=
nextBidi
;
frameInfo
.
mFrame
=
frame
;
contentOffset
=
runEnd
;
aBpd
-
>
mCurrentResolveLine
.
AdvanceToFrame
(
frame
)
;
}
else
{
if
(
contentOffset
+
fragmentLength
=
=
contentTextLength
)
{
int32_t
newIndex
=
aBpd
-
>
GetLastFrameForContent
(
content
)
;
if
(
newIndex
>
frameIndex
)
{
currentLine
-
>
MarkDirty
(
)
;
RemoveBidiContinuation
(
aBpd
frame
frameIndex
newIndex
)
;
frameIndex
=
newIndex
;
frameInfo
=
aBpd
-
>
FrameInfoAt
(
frameIndex
)
;
frame
=
frameInfo
.
mFrame
;
}
}
else
if
(
fragmentLength
>
0
&
&
runLength
>
fragmentLength
)
{
int32_t
newIndex
=
frameIndex
;
do
{
}
while
(
+
+
newIndex
<
frameCount
&
&
aBpd
-
>
FrameAt
(
newIndex
)
=
=
NS_BIDI_CONTROL_FRAME
)
;
if
(
newIndex
<
frameCount
)
{
currentLine
-
>
MarkDirty
(
)
;
RemoveBidiContinuation
(
aBpd
frame
frameIndex
newIndex
)
;
}
}
else
if
(
runLength
=
=
fragmentLength
)
{
nsIFrame
*
next
=
frame
-
>
GetNextInFlow
(
)
;
if
(
next
)
{
currentLine
-
>
MarkDirty
(
)
;
MakeContinuationsNonFluidUpParentChain
(
frame
next
)
;
}
}
frame
-
>
AdjustOffsetsForBidi
(
contentOffset
contentOffset
+
fragmentLength
)
;
}
}
}
int32_t
temp
=
runLength
;
runLength
-
=
fragmentLength
;
fragmentLength
-
=
temp
;
if
(
frame
!
=
NS_BIDI_CONTROL_FRAME
)
{
lastRealFrame
=
frameInfo
;
}
if
(
lastRealFrame
.
mFrame
&
&
fragmentLength
<
=
0
)
{
if
(
runLength
<
=
0
&
&
!
lastRealFrame
.
mFrame
-
>
GetNextInFlow
(
)
)
{
if
(
numRun
+
1
<
runCount
)
{
nsIFrame
*
child
=
lastRealFrame
.
mFrame
;
nsContainerFrame
*
parent
=
child
-
>
GetParent
(
)
;
while
(
parent
&
&
IsBidiSplittable
(
parent
)
&
&
!
child
-
>
GetNextSibling
(
)
)
{
nsIFrame
*
next
=
parent
-
>
GetNextInFlow
(
)
;
if
(
next
)
{
parent
-
>
SetNextContinuation
(
next
)
;
next
-
>
SetPrevContinuation
(
parent
)
;
}
child
=
parent
;
parent
=
child
-
>
GetParent
(
)
;
}
if
(
parent
&
&
IsBidiSplittable
(
parent
)
)
{
aBpd
-
>
mCurrentResolveLine
.
AdvanceToLinesAndFrame
(
lastRealFrame
)
;
SplitInlineAncestors
(
parent
aBpd
-
>
mCurrentResolveLine
.
GetLine
(
)
child
)
;
aBpd
-
>
mCurrentResolveLine
.
AdvanceToLinesAndFrame
(
lastRealFrame
)
;
}
}
}
else
if
(
frame
!
=
NS_BIDI_CONTROL_FRAME
)
{
JoinInlineAncestors
(
frame
)
;
}
}
}
#
ifdef
DEBUG
#
ifdef
REALLY_NOISY_BIDI
printf
(
"
-
-
-
\
nAfter
Resolve
(
)
frameTree
=
:
\
n
"
)
;
aBpd
-
>
mCurrentBlock
-
>
List
(
stdout
)
;
printf
(
"
=
=
=
\
n
"
)
;
#
endif
#
endif
return
rv
;
}
void
nsBidiPresUtils
:
:
TraverseFrames
(
nsIFrame
*
aCurrentFrame
BidiParagraphData
*
aBpd
)
{
if
(
!
aCurrentFrame
)
return
;
#
ifdef
DEBUG
nsBlockFrame
*
initialLineContainer
=
aBpd
-
>
mCurrentTraverseLine
.
mLineIterator
.
GetContainer
(
)
;
#
endif
nsIFrame
*
childFrame
=
aCurrentFrame
;
do
{
nsIFrame
*
nextSibling
=
childFrame
-
>
GetNextSibling
(
)
;
nsIFrame
*
frame
=
childFrame
;
if
(
childFrame
-
>
IsPlaceholderFrame
(
)
)
{
nsIFrame
*
realFrame
=
nsPlaceholderFrame
:
:
GetRealFrameForPlaceholder
(
childFrame
)
;
if
(
realFrame
-
>
IsLetterFrame
(
)
)
{
frame
=
realFrame
;
}
}
auto
DifferentBidiValues
=
[
]
(
ComputedStyle
*
aSC1
nsIFrame
*
aFrame2
)
{
ComputedStyle
*
sc2
=
aFrame2
-
>
Style
(
)
;
return
GetBidiControl
(
aSC1
)
!
=
GetBidiControl
(
sc2
)
|
|
GetBidiOverride
(
aSC1
)
!
=
GetBidiOverride
(
sc2
)
;
}
;
ComputedStyle
*
sc
=
frame
-
>
Style
(
)
;
nsIFrame
*
nextContinuation
=
frame
-
>
GetNextContinuation
(
)
;
nsIFrame
*
prevContinuation
=
frame
-
>
GetPrevContinuation
(
)
;
bool
isLastFrame
=
!
nextContinuation
|
|
DifferentBidiValues
(
sc
nextContinuation
)
;
bool
isFirstFrame
=
!
prevContinuation
|
|
DifferentBidiValues
(
sc
prevContinuation
)
;
char16_t
controlChar
=
0
;
char16_t
overrideChar
=
0
;
LayoutFrameType
frameType
=
frame
-
>
Type
(
)
;
if
(
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eBidiInlineContainer
)
|
|
frameType
=
=
LayoutFrameType
:
:
Ruby
)
{
if
(
!
(
frame
-
>
GetStateBits
(
)
&
NS_FRAME_FIRST_REFLOW
)
)
{
nsContainerFrame
*
c
=
static_cast
<
nsContainerFrame
*
>
(
frame
)
;
MOZ_ASSERT
(
c
=
=
do_QueryFrame
(
frame
)
"
eBidiInlineContainer
and
ruby
frame
must
be
"
"
a
nsContainerFrame
subclass
"
)
;
c
-
>
DrainSelfOverflowList
(
)
;
}
controlChar
=
GetBidiControl
(
sc
)
;
overrideChar
=
GetBidiOverride
(
sc
)
;
if
(
isFirstFrame
)
{
if
(
controlChar
!
=
0
)
{
aBpd
-
>
PushBidiControl
(
controlChar
)
;
}
if
(
overrideChar
!
=
0
)
{
aBpd
-
>
PushBidiControl
(
overrideChar
)
;
}
}
}
if
(
IsBidiLeaf
(
frame
)
)
{
nsIContent
*
content
=
frame
-
>
GetContent
(
)
;
aBpd
-
>
AppendFrame
(
frame
aBpd
-
>
mCurrentTraverseLine
content
)
;
if
(
LayoutFrameType
:
:
Text
=
=
frameType
)
{
if
(
content
!
=
aBpd
-
>
mPrevContent
)
{
aBpd
-
>
mPrevContent
=
content
;
if
(
!
frame
-
>
StyleText
(
)
-
>
NewlineIsSignificant
(
static_cast
<
nsTextFrame
*
>
(
frame
)
)
)
{
content
-
>
GetAsText
(
)
-
>
AppendTextTo
(
aBpd
-
>
mBuffer
)
;
}
else
{
nsAutoString
text
;
content
-
>
GetAsText
(
)
-
>
AppendTextTo
(
text
)
;
nsIFrame
*
next
;
do
{
next
=
nullptr
;
int32_t
start
end
;
frame
-
>
GetOffsets
(
start
end
)
;
int32_t
endLine
=
text
.
FindChar
(
'
\
n
'
start
)
;
if
(
endLine
=
=
-
1
)
{
aBpd
-
>
AppendString
(
Substring
(
text
start
)
)
;
while
(
frame
&
&
nextSibling
)
{
aBpd
-
>
AdvanceAndAppendFrame
(
&
frame
aBpd
-
>
mCurrentTraverseLine
&
nextSibling
)
;
}
break
;
}
+
+
endLine
;
aBpd
-
>
AppendString
(
Substring
(
text
start
std
:
:
min
(
end
endLine
)
-
start
)
)
;
while
(
end
<
endLine
&
&
nextSibling
)
{
aBpd
-
>
AdvanceAndAppendFrame
(
&
frame
aBpd
-
>
mCurrentTraverseLine
&
nextSibling
)
;
NS_ASSERTION
(
frame
"
Premature
end
of
continuation
chain
"
)
;
frame
-
>
GetOffsets
(
start
end
)
;
aBpd
-
>
AppendString
(
Substring
(
text
start
std
:
:
min
(
end
endLine
)
-
start
)
)
;
}
if
(
end
<
endLine
)
{
aBpd
-
>
mPrevContent
=
nullptr
;
break
;
}
bool
createdContinuation
=
false
;
if
(
uint32_t
(
endLine
)
<
text
.
Length
(
)
)
{
next
=
frame
-
>
GetNextInFlow
(
)
;
if
(
!
next
)
{
next
=
frame
-
>
GetNextContinuation
(
)
;
if
(
next
)
{
MakeContinuationFluid
(
frame
next
)
;
JoinInlineAncestors
(
frame
)
;
}
}
nsTextFrame
*
textFrame
=
static_cast
<
nsTextFrame
*
>
(
frame
)
;
textFrame
-
>
SetLength
(
endLine
-
start
nullptr
)
;
aBpd
-
>
mCurrentTraverseLine
.
AdvanceToFrame
(
frame
)
;
if
(
!
next
)
{
CreateContinuation
(
frame
aBpd
-
>
mCurrentTraverseLine
.
GetLine
(
)
&
next
true
)
;
createdContinuation
=
true
;
}
aBpd
-
>
mCurrentTraverseLine
.
GetLine
(
)
-
>
MarkDirty
(
)
;
}
ResolveParagraphWithinBlock
(
aBpd
)
;
if
(
!
nextSibling
&
&
!
createdContinuation
)
{
break
;
}
else
if
(
next
)
{
frame
=
next
;
aBpd
-
>
AppendFrame
(
frame
aBpd
-
>
mCurrentTraverseLine
)
;
aBpd
-
>
mCurrentTraverseLine
.
AdvanceToFrame
(
frame
)
;
aBpd
-
>
mCurrentTraverseLine
.
GetLine
(
)
-
>
MarkDirty
(
)
;
}
if
(
frame
&
&
frame
=
=
nextSibling
)
{
nextSibling
=
frame
-
>
GetNextSibling
(
)
;
}
}
while
(
next
)
;
}
}
}
else
if
(
LayoutFrameType
:
:
Br
=
=
frameType
)
{
aBpd
-
>
AppendUnichar
(
kLineSeparator
)
;
ResolveParagraphWithinBlock
(
aBpd
)
;
}
else
{
aBpd
-
>
AppendUnichar
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
wbr
)
?
kZWSP
:
kObjectSubstitute
)
;
if
(
!
frame
-
>
IsInlineOutside
(
)
)
{
ResolveParagraphWithinBlock
(
aBpd
)
;
}
}
}
else
{
nsIFrame
*
kid
=
frame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
MOZ_ASSERT
(
!
frame
-
>
GetChildList
(
nsIFrame
:
:
kOverflowList
)
.
FirstChild
(
)
"
should
have
drained
the
overflow
list
above
"
)
;
if
(
kid
)
{
TraverseFrames
(
kid
aBpd
)
;
}
}
if
(
isLastFrame
)
{
if
(
overrideChar
!
=
0
)
{
aBpd
-
>
PopBidiControl
(
overrideChar
)
;
}
if
(
controlChar
!
=
0
)
{
aBpd
-
>
PopBidiControl
(
controlChar
)
;
}
}
childFrame
=
nextSibling
;
}
while
(
childFrame
)
;
MOZ_ASSERT
(
initialLineContainer
=
=
aBpd
-
>
mCurrentTraverseLine
.
mLineIterator
.
GetContainer
(
)
)
;
}
bool
nsBidiPresUtils
:
:
ChildListMayRequireBidi
(
nsIFrame
*
aFirstChild
nsIContent
*
*
aCurrContent
)
{
MOZ_ASSERT
(
!
aFirstChild
|
|
!
aFirstChild
-
>
GetPrevSibling
(
)
"
Expecting
to
traverse
from
the
start
of
a
child
list
"
)
;
for
(
nsIFrame
*
childFrame
=
aFirstChild
;
childFrame
;
childFrame
=
childFrame
-
>
GetNextSibling
(
)
)
{
nsIFrame
*
frame
=
childFrame
;
if
(
childFrame
-
>
IsPlaceholderFrame
(
)
)
{
nsIFrame
*
realFrame
=
nsPlaceholderFrame
:
:
GetRealFrameForPlaceholder
(
childFrame
)
;
if
(
realFrame
-
>
IsLetterFrame
(
)
)
{
frame
=
realFrame
;
}
}
ComputedStyle
*
sc
=
frame
-
>
Style
(
)
;
if
(
GetBidiControl
(
sc
)
|
|
GetBidiOverride
(
sc
)
)
{
return
true
;
}
if
(
IsBidiLeaf
(
frame
)
)
{
if
(
frame
-
>
IsTextFrame
(
)
)
{
if
(
frame
-
>
HasProperty
(
nsIFrame
:
:
BidiDataProperty
(
)
)
)
{
return
true
;
}
dom
:
:
Text
*
content
=
frame
-
>
GetContent
(
)
-
>
AsText
(
)
;
if
(
content
!
=
*
aCurrContent
)
{
*
aCurrContent
=
content
;
const
nsTextFragment
*
txt
=
&
content
-
>
TextFragment
(
)
;
if
(
txt
-
>
Is2b
(
)
&
&
HasRTLChars
(
MakeSpan
(
txt
-
>
Get2b
(
)
txt
-
>
GetLength
(
)
)
)
)
{
return
true
;
}
}
}
}
else
if
(
ChildListMayRequireBidi
(
frame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
aCurrContent
)
)
{
return
true
;
}
}
return
false
;
}
void
nsBidiPresUtils
:
:
ResolveParagraphWithinBlock
(
BidiParagraphData
*
aBpd
)
{
aBpd
-
>
ClearBidiControls
(
)
;
ResolveParagraph
(
aBpd
)
;
aBpd
-
>
ResetData
(
)
;
}
nscoord
nsBidiPresUtils
:
:
ReorderFrames
(
nsIFrame
*
aFirstFrameOnLine
int32_t
aNumFramesOnLine
WritingMode
aLineWM
const
nsSize
&
aContainerSize
nscoord
aStart
)
{
nsSize
containerSize
(
aContainerSize
)
;
if
(
aFirstFrameOnLine
-
>
IsLineFrame
(
)
)
{
containerSize
=
aFirstFrameOnLine
-
>
GetSize
(
)
;
aFirstFrameOnLine
=
aFirstFrameOnLine
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
!
aFirstFrameOnLine
)
{
return
0
;
}
aNumFramesOnLine
=
-
1
;
}
BidiLineData
bld
(
aFirstFrameOnLine
aNumFramesOnLine
)
;
return
RepositionInlineFrames
(
&
bld
aLineWM
containerSize
aStart
)
;
}
nsIFrame
*
nsBidiPresUtils
:
:
GetFirstLeaf
(
nsIFrame
*
aFrame
)
{
nsIFrame
*
firstLeaf
=
aFrame
;
while
(
!
IsBidiLeaf
(
firstLeaf
)
)
{
nsIFrame
*
firstChild
=
firstLeaf
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
nsIFrame
*
realFrame
=
nsPlaceholderFrame
:
:
GetRealFrameFor
(
firstChild
)
;
firstLeaf
=
(
realFrame
-
>
IsLetterFrame
(
)
)
?
realFrame
:
firstChild
;
}
return
firstLeaf
;
}
FrameBidiData
nsBidiPresUtils
:
:
GetFrameBidiData
(
nsIFrame
*
aFrame
)
{
return
GetFirstLeaf
(
aFrame
)
-
>
GetBidiData
(
)
;
}
nsBidiLevel
nsBidiPresUtils
:
:
GetFrameEmbeddingLevel
(
nsIFrame
*
aFrame
)
{
return
GetFirstLeaf
(
aFrame
)
-
>
GetEmbeddingLevel
(
)
;
}
nsBidiLevel
nsBidiPresUtils
:
:
GetFrameBaseLevel
(
nsIFrame
*
aFrame
)
{
nsIFrame
*
firstLeaf
=
aFrame
;
while
(
!
IsBidiLeaf
(
firstLeaf
)
)
{
firstLeaf
=
firstLeaf
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
}
return
firstLeaf
-
>
GetBaseLevel
(
)
;
}
void
nsBidiPresUtils
:
:
IsFirstOrLast
(
nsIFrame
*
aFrame
nsContinuationStates
*
aContinuationStates
bool
aSpanDirMatchesLineDir
bool
&
aIsFirst
bool
&
aIsLast
)
{
bool
firstInLineOrder
lastInLineOrder
;
nsFrameContinuationState
*
frameState
=
aContinuationStates
-
>
Get
(
aFrame
)
;
nsFrameContinuationState
*
firstFrameState
;
if
(
!
frameState
-
>
mFirstVisualFrame
)
{
nsFrameContinuationState
*
contState
;
nsIFrame
*
frame
;
frameState
-
>
mFrameCount
=
1
;
frameState
-
>
mFirstVisualFrame
=
aFrame
;
for
(
frame
=
aFrame
-
>
GetPrevContinuation
(
)
;
frame
&
&
(
contState
=
aContinuationStates
-
>
Get
(
frame
)
)
;
frame
=
frame
-
>
GetPrevContinuation
(
)
)
{
frameState
-
>
mFrameCount
+
+
;
contState
-
>
mFirstVisualFrame
=
aFrame
;
}
frameState
-
>
mHasContOnPrevLines
=
(
frame
!
=
nullptr
)
;
for
(
frame
=
aFrame
-
>
GetNextContinuation
(
)
;
frame
&
&
(
contState
=
aContinuationStates
-
>
Get
(
frame
)
)
;
frame
=
frame
-
>
GetNextContinuation
(
)
)
{
frameState
-
>
mFrameCount
+
+
;
contState
-
>
mFirstVisualFrame
=
aFrame
;
}
frameState
-
>
mHasContOnNextLines
=
(
frame
!
=
nullptr
)
;
firstInLineOrder
=
true
;
firstFrameState
=
frameState
;
}
else
{
firstInLineOrder
=
false
;
firstFrameState
=
aContinuationStates
-
>
Get
(
frameState
-
>
mFirstVisualFrame
)
;
}
lastInLineOrder
=
(
firstFrameState
-
>
mFrameCount
=
=
1
)
;
if
(
aSpanDirMatchesLineDir
)
{
aIsFirst
=
firstInLineOrder
;
aIsLast
=
lastInLineOrder
;
}
else
{
aIsFirst
=
lastInLineOrder
;
aIsLast
=
firstInLineOrder
;
}
if
(
frameState
-
>
mHasContOnPrevLines
)
{
aIsFirst
=
false
;
}
if
(
firstFrameState
-
>
mHasContOnNextLines
)
{
aIsLast
=
false
;
}
if
(
(
aIsFirst
|
|
aIsLast
)
&
&
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_PART_OF_IBSPLIT
)
)
{
nsIFrame
*
firstContinuation
=
aFrame
-
>
FirstContinuation
(
)
;
if
(
firstContinuation
-
>
FrameIsNonLastInIBSplit
(
)
)
{
aIsLast
=
false
;
}
if
(
firstContinuation
-
>
FrameIsNonFirstInIBSplit
(
)
)
{
aIsFirst
=
false
;
}
}
firstFrameState
-
>
mFrameCount
-
-
;
nsInlineFrame
*
testFrame
=
do_QueryFrame
(
aFrame
)
;
if
(
testFrame
)
{
aFrame
-
>
AddStateBits
(
NS_INLINE_FRAME_BIDI_VISUAL_STATE_IS_SET
)
;
if
(
aIsFirst
)
{
aFrame
-
>
AddStateBits
(
NS_INLINE_FRAME_BIDI_VISUAL_IS_FIRST
)
;
}
else
{
aFrame
-
>
RemoveStateBits
(
NS_INLINE_FRAME_BIDI_VISUAL_IS_FIRST
)
;
}
if
(
aIsLast
)
{
aFrame
-
>
AddStateBits
(
NS_INLINE_FRAME_BIDI_VISUAL_IS_LAST
)
;
}
else
{
aFrame
-
>
RemoveStateBits
(
NS_INLINE_FRAME_BIDI_VISUAL_IS_LAST
)
;
}
}
}
void
nsBidiPresUtils
:
:
RepositionRubyContentFrame
(
nsIFrame
*
aFrame
WritingMode
aFrameWM
const
LogicalMargin
&
aBorderPadding
)
{
const
nsFrameList
&
childList
=
aFrame
-
>
PrincipalChildList
(
)
;
if
(
childList
.
IsEmpty
(
)
)
{
return
;
}
nscoord
isize
=
ReorderFrames
(
childList
.
FirstChild
(
)
childList
.
GetLength
(
)
aFrameWM
aFrame
-
>
GetSize
(
)
aBorderPadding
.
IStart
(
aFrameWM
)
)
;
isize
+
=
aBorderPadding
.
IEnd
(
aFrameWM
)
;
if
(
aFrame
-
>
StyleText
(
)
-
>
mRubyAlign
=
=
StyleRubyAlign
:
:
Start
)
{
return
;
}
nscoord
residualISize
=
aFrame
-
>
ISize
(
aFrameWM
)
-
isize
;
if
(
residualISize
<
=
0
)
{
return
;
}
const
nsSize
dummyContainerSize
;
for
(
nsIFrame
*
child
:
childList
)
{
LogicalRect
rect
=
child
-
>
GetLogicalRect
(
aFrameWM
dummyContainerSize
)
;
rect
.
IStart
(
aFrameWM
)
+
=
residualISize
/
2
;
child
-
>
SetRect
(
aFrameWM
rect
dummyContainerSize
)
;
}
}
nscoord
nsBidiPresUtils
:
:
RepositionRubyFrame
(
nsIFrame
*
aFrame
nsContinuationStates
*
aContinuationStates
const
WritingMode
aContainerWM
const
LogicalMargin
&
aBorderPadding
)
{
LayoutFrameType
frameType
=
aFrame
-
>
Type
(
)
;
MOZ_ASSERT
(
RubyUtils
:
:
IsRubyBox
(
frameType
)
)
;
nscoord
icoord
=
0
;
WritingMode
frameWM
=
aFrame
-
>
GetWritingMode
(
)
;
bool
isLTR
=
frameWM
.
IsBidiLTR
(
)
;
nsSize
frameSize
=
aFrame
-
>
GetSize
(
)
;
if
(
frameType
=
=
LayoutFrameType
:
:
Ruby
)
{
icoord
+
=
aBorderPadding
.
IStart
(
frameWM
)
;
for
(
RubySegmentEnumerator
e
(
static_cast
<
nsRubyFrame
*
>
(
aFrame
)
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
)
{
nsRubyBaseContainerFrame
*
rbc
=
e
.
GetBaseContainer
(
)
;
AutoRubyTextContainerArray
textContainers
(
rbc
)
;
nscoord
segmentISize
=
RepositionFrame
(
rbc
isLTR
icoord
aContinuationStates
frameWM
false
frameSize
)
;
for
(
nsRubyTextContainerFrame
*
rtc
:
textContainers
)
{
nscoord
isize
=
RepositionFrame
(
rtc
isLTR
icoord
aContinuationStates
frameWM
false
frameSize
)
;
segmentISize
=
std
:
:
max
(
segmentISize
isize
)
;
}
icoord
+
=
segmentISize
;
}
icoord
+
=
aBorderPadding
.
IEnd
(
frameWM
)
;
}
else
if
(
frameType
=
=
LayoutFrameType
:
:
RubyBaseContainer
)
{
auto
rbc
=
static_cast
<
nsRubyBaseContainerFrame
*
>
(
aFrame
)
;
AutoRubyTextContainerArray
textContainers
(
rbc
)
;
for
(
RubyColumnEnumerator
e
(
rbc
textContainers
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
)
{
RubyColumn
column
;
e
.
GetColumn
(
column
)
;
nscoord
columnISize
=
RepositionFrame
(
column
.
mBaseFrame
isLTR
icoord
aContinuationStates
frameWM
false
frameSize
)
;
for
(
nsRubyTextFrame
*
rt
:
column
.
mTextFrames
)
{
nscoord
isize
=
RepositionFrame
(
rt
isLTR
icoord
aContinuationStates
frameWM
false
frameSize
)
;
columnISize
=
std
:
:
max
(
columnISize
isize
)
;
}
icoord
+
=
columnISize
;
}
}
else
{
if
(
frameType
=
=
LayoutFrameType
:
:
RubyBase
|
|
frameType
=
=
LayoutFrameType
:
:
RubyText
)
{
RepositionRubyContentFrame
(
aFrame
frameWM
aBorderPadding
)
;
}
icoord
+
=
aFrame
-
>
ISize
(
aContainerWM
)
;
}
return
icoord
;
}
nscoord
nsBidiPresUtils
:
:
RepositionFrame
(
nsIFrame
*
aFrame
bool
aIsEvenLevel
nscoord
aStartOrEnd
nsContinuationStates
*
aContinuationStates
WritingMode
aContainerWM
bool
aContainerReverseDir
const
nsSize
&
aContainerSize
)
{
nscoord
lineSize
=
aContainerWM
.
IsVertical
(
)
?
aContainerSize
.
height
:
aContainerSize
.
width
;
NS_ASSERTION
(
lineSize
!
=
NS_UNCONSTRAINEDSIZE
"
Unconstrained
inline
line
size
in
bidi
frame
reordering
"
)
;
if
(
!
aFrame
)
return
0
;
bool
isFirst
isLast
;
WritingMode
frameWM
=
aFrame
-
>
GetWritingMode
(
)
;
IsFirstOrLast
(
aFrame
aContinuationStates
aContainerWM
.
IsBidiLTR
(
)
=
=
frameWM
.
IsBidiLTR
(
)
isFirst
isLast
)
;
nscoord
frameISize
=
aFrame
-
>
ISize
(
)
;
LogicalMargin
frameMargin
=
aFrame
-
>
GetLogicalUsedMargin
(
frameWM
)
;
LogicalMargin
borderPadding
=
aFrame
-
>
GetLogicalUsedBorderAndPadding
(
frameWM
)
;
if
(
aFrame
-
>
StyleBorder
(
)
-
>
mBoxDecorationBreak
=
=
StyleBoxDecorationBreak
:
:
Slice
)
{
if
(
!
aFrame
-
>
GetPrevContinuation
(
)
)
{
frameISize
-
=
borderPadding
.
IStart
(
frameWM
)
;
}
if
(
!
aFrame
-
>
GetNextContinuation
(
)
)
{
frameISize
-
=
borderPadding
.
IEnd
(
frameWM
)
;
}
if
(
!
isFirst
)
{
frameMargin
.
IStart
(
frameWM
)
=
0
;
borderPadding
.
IStart
(
frameWM
)
=
0
;
}
if
(
!
isLast
)
{
frameMargin
.
IEnd
(
frameWM
)
=
0
;
borderPadding
.
IEnd
(
frameWM
)
=
0
;
}
frameISize
+
=
borderPadding
.
IStartEnd
(
frameWM
)
;
}
nscoord
icoord
=
0
;
if
(
IsBidiLeaf
(
aFrame
)
)
{
icoord
+
=
frameWM
.
IsOrthogonalTo
(
aContainerWM
)
?
aFrame
-
>
BSize
(
)
:
frameISize
;
}
else
if
(
RubyUtils
:
:
IsRubyBox
(
aFrame
-
>
Type
(
)
)
)
{
icoord
+
=
RepositionRubyFrame
(
aFrame
aContinuationStates
aContainerWM
borderPadding
)
;
}
else
{
bool
reverseDir
=
aIsEvenLevel
!
=
frameWM
.
IsBidiLTR
(
)
;
icoord
+
=
reverseDir
?
borderPadding
.
IEnd
(
frameWM
)
:
borderPadding
.
IStart
(
frameWM
)
;
LogicalSize
logicalSize
(
frameWM
frameISize
aFrame
-
>
BSize
(
)
)
;
nsSize
frameSize
=
logicalSize
.
GetPhysicalSize
(
frameWM
)
;
for
(
nsFrameList
:
:
Enumerator
e
(
aFrame
-
>
PrincipalChildList
(
)
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
)
{
icoord
+
=
RepositionFrame
(
e
.
get
(
)
aIsEvenLevel
icoord
aContinuationStates
frameWM
reverseDir
frameSize
)
;
}
icoord
+
=
reverseDir
?
borderPadding
.
IStart
(
frameWM
)
:
borderPadding
.
IEnd
(
frameWM
)
;
}
const
LogicalMargin
margin
=
frameMargin
.
ConvertTo
(
aContainerWM
frameWM
)
;
nscoord
marginStartOrEnd
=
aContainerReverseDir
?
margin
.
IEnd
(
aContainerWM
)
:
margin
.
IStart
(
aContainerWM
)
;
nscoord
frameStartOrEnd
=
aStartOrEnd
+
marginStartOrEnd
;
LogicalRect
rect
=
aFrame
-
>
GetLogicalRect
(
aContainerWM
aContainerSize
)
;
rect
.
ISize
(
aContainerWM
)
=
icoord
;
rect
.
IStart
(
aContainerWM
)
=
aContainerReverseDir
?
lineSize
-
frameStartOrEnd
-
icoord
:
frameStartOrEnd
;
aFrame
-
>
SetRect
(
aContainerWM
rect
aContainerSize
)
;
return
icoord
+
margin
.
IStartEnd
(
aContainerWM
)
;
}
void
nsBidiPresUtils
:
:
InitContinuationStates
(
nsIFrame
*
aFrame
nsContinuationStates
*
aContinuationStates
)
{
aContinuationStates
-
>
Insert
(
aFrame
)
;
if
(
!
IsBidiLeaf
(
aFrame
)
)
{
for
(
nsIFrame
*
frame
:
aFrame
-
>
PrincipalChildList
(
)
)
{
InitContinuationStates
(
frame
aContinuationStates
)
;
}
}
}
nscoord
nsBidiPresUtils
:
:
RepositionInlineFrames
(
BidiLineData
*
aBld
WritingMode
aLineWM
const
nsSize
&
aContainerSize
nscoord
aStart
)
{
nscoord
start
=
aStart
;
nsIFrame
*
frame
;
int32_t
count
=
aBld
-
>
mVisualFrames
.
Length
(
)
;
int32_t
index
;
nsContinuationStates
continuationStates
;
for
(
index
=
0
;
index
<
count
;
index
+
+
)
{
InitContinuationStates
(
aBld
-
>
VisualFrameAt
(
index
)
&
continuationStates
)
;
}
int32_t
step
limit
;
if
(
aLineWM
.
IsBidiLTR
(
)
)
{
index
=
0
;
step
=
1
;
limit
=
count
;
}
else
{
index
=
count
-
1
;
step
=
-
1
;
limit
=
-
1
;
}
for
(
;
index
!
=
limit
;
index
+
=
step
)
{
frame
=
aBld
-
>
VisualFrameAt
(
index
)
;
start
+
=
RepositionFrame
(
frame
!
(
IS_LEVEL_RTL
(
aBld
-
>
mLevels
[
aBld
-
>
mIndexMap
[
index
]
]
)
)
start
&
continuationStates
aLineWM
false
aContainerSize
)
;
}
return
start
;
}
bool
nsBidiPresUtils
:
:
CheckLineOrder
(
nsIFrame
*
aFirstFrameOnLine
int32_t
aNumFramesOnLine
nsIFrame
*
*
aFirstVisual
nsIFrame
*
*
aLastVisual
)
{
BidiLineData
bld
(
aFirstFrameOnLine
aNumFramesOnLine
)
;
int32_t
count
=
bld
.
FrameCount
(
)
;
if
(
aFirstVisual
)
{
*
aFirstVisual
=
bld
.
VisualFrameAt
(
0
)
;
}
if
(
aLastVisual
)
{
*
aLastVisual
=
bld
.
VisualFrameAt
(
count
-
1
)
;
}
return
bld
.
mIsReordered
;
}
nsIFrame
*
nsBidiPresUtils
:
:
GetFrameToRightOf
(
const
nsIFrame
*
aFrame
nsIFrame
*
aFirstFrameOnLine
int32_t
aNumFramesOnLine
)
{
BidiLineData
bld
(
aFirstFrameOnLine
aNumFramesOnLine
)
;
int32_t
count
=
bld
.
mVisualFrames
.
Length
(
)
;
if
(
aFrame
=
=
nullptr
&
&
count
)
return
bld
.
VisualFrameAt
(
0
)
;
for
(
int32_t
i
=
0
;
i
<
count
-
1
;
i
+
+
)
{
if
(
bld
.
VisualFrameAt
(
i
)
=
=
aFrame
)
{
return
bld
.
VisualFrameAt
(
i
+
1
)
;
}
}
return
nullptr
;
}
nsIFrame
*
nsBidiPresUtils
:
:
GetFrameToLeftOf
(
const
nsIFrame
*
aFrame
nsIFrame
*
aFirstFrameOnLine
int32_t
aNumFramesOnLine
)
{
BidiLineData
bld
(
aFirstFrameOnLine
aNumFramesOnLine
)
;
int32_t
count
=
bld
.
mVisualFrames
.
Length
(
)
;
if
(
aFrame
=
=
nullptr
&
&
count
)
return
bld
.
VisualFrameAt
(
count
-
1
)
;
for
(
int32_t
i
=
1
;
i
<
count
;
i
+
+
)
{
if
(
bld
.
VisualFrameAt
(
i
)
=
=
aFrame
)
{
return
bld
.
VisualFrameAt
(
i
-
1
)
;
}
}
return
nullptr
;
}
inline
void
nsBidiPresUtils
:
:
EnsureBidiContinuation
(
nsIFrame
*
aFrame
const
nsLineList
:
:
iterator
aLine
nsIFrame
*
*
aNewFrame
int32_t
aStart
int32_t
aEnd
)
{
MOZ_ASSERT
(
aNewFrame
"
null
OUT
ptr
"
)
;
MOZ_ASSERT
(
aFrame
"
aFrame
is
null
"
)
;
aFrame
-
>
AdjustOffsetsForBidi
(
aStart
aEnd
)
;
CreateContinuation
(
aFrame
aLine
aNewFrame
false
)
;
}
void
nsBidiPresUtils
:
:
RemoveBidiContinuation
(
BidiParagraphData
*
aBpd
nsIFrame
*
aFrame
int32_t
aFirstIndex
int32_t
aLastIndex
)
{
FrameBidiData
bidiData
=
aFrame
-
>
GetBidiData
(
)
;
bidiData
.
precedingControl
=
kBidiLevelNone
;
for
(
int32_t
index
=
aFirstIndex
+
1
;
index
<
=
aLastIndex
;
index
+
+
)
{
nsIFrame
*
frame
=
aBpd
-
>
FrameAt
(
index
)
;
if
(
frame
!
=
NS_BIDI_CONTROL_FRAME
)
{
frame
-
>
SetProperty
(
nsIFrame
:
:
BidiDataProperty
(
)
bidiData
)
;
frame
-
>
AddStateBits
(
NS_FRAME_IS_BIDI
)
;
while
(
frame
&
&
IsBidiSplittable
(
frame
)
)
{
nsIFrame
*
prev
=
frame
-
>
GetPrevContinuation
(
)
;
if
(
prev
)
{
MakeContinuationFluid
(
prev
frame
)
;
frame
=
frame
-
>
GetParent
(
)
;
}
else
{
break
;
}
}
}
}
nsIFrame
*
lastFrame
=
aBpd
-
>
FrameAt
(
aLastIndex
)
;
MakeContinuationsNonFluidUpParentChain
(
lastFrame
lastFrame
-
>
GetNextInFlow
(
)
)
;
}
nsresult
nsBidiPresUtils
:
:
FormatUnicodeText
(
nsPresContext
*
aPresContext
char16_t
*
aText
int32_t
&
aTextLength
nsCharType
aCharType
)
{
nsresult
rv
=
NS_OK
;
uint32_t
bidiOptions
=
aPresContext
-
>
GetBidi
(
)
;
switch
(
GET_BIDI_OPTION_NUMERAL
(
bidiOptions
)
)
{
case
IBMBIDI_NUMERAL_HINDI
:
HandleNumbers
(
aText
aTextLength
IBMBIDI_NUMERAL_HINDI
)
;
break
;
case
IBMBIDI_NUMERAL_ARABIC
:
HandleNumbers
(
aText
aTextLength
IBMBIDI_NUMERAL_ARABIC
)
;
break
;
case
IBMBIDI_NUMERAL_PERSIAN
:
HandleNumbers
(
aText
aTextLength
IBMBIDI_NUMERAL_PERSIAN
)
;
break
;
case
IBMBIDI_NUMERAL_REGULAR
:
switch
(
aCharType
)
{
case
eCharType_EuropeanNumber
:
HandleNumbers
(
aText
aTextLength
IBMBIDI_NUMERAL_ARABIC
)
;
break
;
case
eCharType_ArabicNumber
:
HandleNumbers
(
aText
aTextLength
IBMBIDI_NUMERAL_HINDI
)
;
break
;
default
:
break
;
}
break
;
case
IBMBIDI_NUMERAL_HINDICONTEXT
:
if
(
(
(
GET_BIDI_OPTION_DIRECTION
(
bidiOptions
)
=
=
IBMBIDI_TEXTDIRECTION_RTL
)
&
&
(
IS_ARABIC_DIGIT
(
aText
[
0
]
)
)
)
|
|
(
eCharType_ArabicNumber
=
=
aCharType
)
)
HandleNumbers
(
aText
aTextLength
IBMBIDI_NUMERAL_HINDI
)
;
else
if
(
eCharType_EuropeanNumber
=
=
aCharType
)
HandleNumbers
(
aText
aTextLength
IBMBIDI_NUMERAL_ARABIC
)
;
break
;
case
IBMBIDI_NUMERAL_PERSIANCONTEXT
:
if
(
(
(
GET_BIDI_OPTION_DIRECTION
(
bidiOptions
)
=
=
IBMBIDI_TEXTDIRECTION_RTL
)
&
&
(
IS_ARABIC_DIGIT
(
aText
[
0
]
)
)
)
|
|
(
eCharType_ArabicNumber
=
=
aCharType
)
)
HandleNumbers
(
aText
aTextLength
IBMBIDI_NUMERAL_PERSIAN
)
;
else
if
(
eCharType_EuropeanNumber
=
=
aCharType
)
HandleNumbers
(
aText
aTextLength
IBMBIDI_NUMERAL_ARABIC
)
;
break
;
case
IBMBIDI_NUMERAL_NOMINAL
:
default
:
break
;
}
StripBidiControlCharacters
(
aText
aTextLength
)
;
return
rv
;
}
void
nsBidiPresUtils
:
:
StripBidiControlCharacters
(
char16_t
*
aText
int32_t
&
aTextLength
)
{
if
(
(
nullptr
=
=
aText
)
|
|
(
aTextLength
<
1
)
)
{
return
;
}
int32_t
stripLen
=
0
;
for
(
int32_t
i
=
0
;
i
<
aTextLength
;
i
+
+
)
{
if
(
IsBidiControl
(
(
uint32_t
)
aText
[
i
]
)
)
{
+
+
stripLen
;
}
else
{
aText
[
i
-
stripLen
]
=
aText
[
i
]
;
}
}
aTextLength
-
=
stripLen
;
}
#
if
0
void
RemoveDiacritics
(
char16_t
*
aText
int32_t
&
aTextLength
)
{
if
(
aText
&
&
(
aTextLength
>
0
)
)
{
int32_t
offset
=
0
;
for
(
int32_t
i
=
0
;
i
<
aTextLength
&
&
aText
[
i
]
;
i
+
+
)
{
if
(
IS_BIDI_DIACRITIC
(
aText
[
i
]
)
)
{
+
+
offset
;
continue
;
}
aText
[
i
-
offset
]
=
aText
[
i
]
;
}
aTextLength
=
i
-
offset
;
aText
[
aTextLength
]
=
0
;
}
}
#
endif
void
nsBidiPresUtils
:
:
CalculateCharType
(
nsBidi
*
aBidiEngine
const
char16_t
*
aText
int32_t
&
aOffset
int32_t
aCharTypeLimit
int32_t
&
aRunLimit
int32_t
&
aRunLength
int32_t
&
aRunCount
uint8_t
&
aCharType
uint8_t
&
aPrevCharType
)
{
bool
strongTypeFound
=
false
;
int32_t
offset
;
nsCharType
charType
;
aCharType
=
eCharType_OtherNeutral
;
int32_t
charLen
;
for
(
offset
=
aOffset
;
offset
<
aCharTypeLimit
;
offset
+
=
charLen
)
{
charLen
=
1
;
uint32_t
ch
=
aText
[
offset
]
;
if
(
IS_HEBREW_CHAR
(
ch
)
)
{
charType
=
eCharType_RightToLeft
;
}
else
if
(
IS_ARABIC_ALPHABETIC
(
ch
)
)
{
charType
=
eCharType_RightToLeftArabic
;
}
else
{
if
(
offset
+
1
<
aCharTypeLimit
&
&
NS_IS_SURROGATE_PAIR
(
ch
aText
[
offset
+
1
]
)
)
{
ch
=
SURROGATE_TO_UCS4
(
ch
aText
[
offset
+
1
]
)
;
charLen
=
2
;
}
charType
=
unicode
:
:
GetBidiCat
(
ch
)
;
}
if
(
!
CHARTYPE_IS_WEAK
(
charType
)
)
{
if
(
strongTypeFound
&
&
(
charType
!
=
aPrevCharType
)
&
&
(
CHARTYPE_IS_RTL
(
charType
)
|
|
CHARTYPE_IS_RTL
(
aPrevCharType
)
)
)
{
aRunLength
=
offset
-
aOffset
;
aRunLimit
=
offset
;
+
+
aRunCount
;
break
;
}
if
(
(
eCharType_RightToLeftArabic
=
=
aPrevCharType
|
|
eCharType_ArabicNumber
=
=
aPrevCharType
)
&
&
eCharType_EuropeanNumber
=
=
charType
)
{
charType
=
eCharType_ArabicNumber
;
}
aPrevCharType
=
charType
;
strongTypeFound
=
true
;
aCharType
=
charType
;
}
}
aOffset
=
offset
;
}
nsresult
nsBidiPresUtils
:
:
ProcessText
(
const
char16_t
*
aText
int32_t
aLength
nsBidiLevel
aBaseLevel
nsPresContext
*
aPresContext
BidiProcessor
&
aprocessor
Mode
aMode
nsBidiPositionResolve
*
aPosResolve
int32_t
aPosResolveCount
nscoord
*
aWidth
nsBidi
*
aBidiEngine
)
{
NS_ASSERTION
(
(
aPosResolve
=
=
nullptr
)
!
=
(
aPosResolveCount
>
0
)
"
Incorrect
aPosResolve
/
aPosResolveCount
arguments
"
)
;
int32_t
runCount
;
nsAutoString
textBuffer
(
aText
aLength
)
;
textBuffer
.
ReplaceChar
(
kSeparators
kSpace
)
;
const
char16_t
*
text
=
textBuffer
.
get
(
)
;
nsresult
rv
=
aBidiEngine
-
>
SetPara
(
text
aLength
aBaseLevel
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
rv
=
aBidiEngine
-
>
CountRuns
(
&
runCount
)
;
if
(
NS_FAILED
(
rv
)
)
return
rv
;
nscoord
xOffset
=
0
;
nscoord
width
xEndRun
=
0
;
nscoord
totalWidth
=
0
;
int32_t
i
start
limit
length
;
uint32_t
visualStart
=
0
;
uint8_t
charType
;
uint8_t
prevType
=
eCharType_LeftToRight
;
for
(
int
nPosResolve
=
0
;
nPosResolve
<
aPosResolveCount
;
+
+
nPosResolve
)
{
aPosResolve
[
nPosResolve
]
.
visualIndex
=
kNotFound
;
aPosResolve
[
nPosResolve
]
.
visualLeftTwips
=
kNotFound
;
aPosResolve
[
nPosResolve
]
.
visualWidth
=
kNotFound
;
}
for
(
i
=
0
;
i
<
runCount
;
i
+
+
)
{
nsBidiDirection
dir
=
aBidiEngine
-
>
GetVisualRun
(
i
&
start
&
length
)
;
nsBidiLevel
level
;
aBidiEngine
-
>
GetLogicalRun
(
start
&
limit
&
level
)
;
dir
=
DIRECTION_FROM_LEVEL
(
level
)
;
int32_t
subRunLength
=
limit
-
start
;
int32_t
lineOffset
=
start
;
int32_t
typeLimit
=
std
:
:
min
(
limit
aLength
)
;
int32_t
subRunCount
=
1
;
int32_t
subRunLimit
=
typeLimit
;
if
(
dir
=
=
NSBIDI_RTL
)
{
aprocessor
.
SetText
(
text
+
start
subRunLength
dir
)
;
width
=
aprocessor
.
GetWidth
(
)
;
xOffset
+
=
width
;
xEndRun
=
xOffset
;
}
while
(
subRunCount
>
0
)
{
CalculateCharType
(
aBidiEngine
text
lineOffset
typeLimit
subRunLimit
subRunLength
subRunCount
charType
prevType
)
;
nsAutoString
runVisualText
;
runVisualText
.
Assign
(
text
+
start
subRunLength
)
;
if
(
int32_t
(
runVisualText
.
Length
(
)
)
<
subRunLength
)
return
NS_ERROR_OUT_OF_MEMORY
;
FormatUnicodeText
(
aPresContext
runVisualText
.
BeginWriting
(
)
subRunLength
(
nsCharType
)
charType
)
;
aprocessor
.
SetText
(
runVisualText
.
get
(
)
subRunLength
dir
)
;
width
=
aprocessor
.
GetWidth
(
)
;
totalWidth
+
=
width
;
if
(
dir
=
=
NSBIDI_RTL
)
{
xOffset
-
=
width
;
}
if
(
aMode
=
=
MODE_DRAW
)
{
aprocessor
.
DrawText
(
xOffset
width
)
;
}
for
(
int
nPosResolve
=
0
;
nPosResolve
<
aPosResolveCount
;
+
+
nPosResolve
)
{
nsBidiPositionResolve
*
posResolve
=
&
aPosResolve
[
nPosResolve
]
;
if
(
posResolve
-
>
visualLeftTwips
!
=
kNotFound
)
continue
;
if
(
start
<
=
posResolve
-
>
logicalIndex
&
&
start
+
subRunLength
>
posResolve
-
>
logicalIndex
)
{
if
(
subRunLength
=
=
1
)
{
posResolve
-
>
visualIndex
=
visualStart
;
posResolve
-
>
visualLeftTwips
=
xOffset
;
posResolve
-
>
visualWidth
=
width
;
}
else
{
nscoord
subWidth
;
const
char16_t
*
visualLeftPart
;
const
char16_t
*
visualRightSide
;
if
(
dir
=
=
NSBIDI_RTL
)
{
posResolve
-
>
visualIndex
=
visualStart
+
(
subRunLength
-
(
posResolve
-
>
logicalIndex
+
1
-
start
)
)
;
visualLeftPart
=
text
+
posResolve
-
>
logicalIndex
+
1
;
visualRightSide
=
visualLeftPart
-
1
;
}
else
{
posResolve
-
>
visualIndex
=
visualStart
+
(
posResolve
-
>
logicalIndex
-
start
)
;
visualLeftPart
=
text
+
start
;
visualRightSide
=
visualLeftPart
;
}
int32_t
visualLeftLength
=
posResolve
-
>
visualIndex
-
visualStart
;
aprocessor
.
SetText
(
visualLeftPart
visualLeftLength
dir
)
;
subWidth
=
aprocessor
.
GetWidth
(
)
;
aprocessor
.
SetText
(
visualRightSide
visualLeftLength
+
1
dir
)
;
posResolve
-
>
visualLeftTwips
=
xOffset
+
subWidth
;
posResolve
-
>
visualWidth
=
aprocessor
.
GetWidth
(
)
-
subWidth
;
}
}
}
if
(
dir
=
=
NSBIDI_LTR
)
{
xOffset
+
=
width
;
}
-
-
subRunCount
;
start
=
lineOffset
;
subRunLimit
=
typeLimit
;
subRunLength
=
typeLimit
-
lineOffset
;
}
if
(
dir
=
=
NSBIDI_RTL
)
{
xOffset
=
xEndRun
;
}
visualStart
+
=
length
;
}
if
(
aWidth
)
{
*
aWidth
=
totalWidth
;
}
return
NS_OK
;
}
class
MOZ_STACK_CLASS
nsIRenderingContextBidiProcessor
final
:
public
nsBidiPresUtils
:
:
BidiProcessor
{
public
:
typedef
mozilla
:
:
gfx
:
:
DrawTarget
DrawTarget
;
nsIRenderingContextBidiProcessor
(
gfxContext
*
aCtx
DrawTarget
*
aTextRunConstructionDrawTarget
nsFontMetrics
*
aFontMetrics
const
nsPoint
&
aPt
)
:
mCtx
(
aCtx
)
mTextRunConstructionDrawTarget
(
aTextRunConstructionDrawTarget
)
mFontMetrics
(
aFontMetrics
)
mPt
(
aPt
)
mText
(
nullptr
)
mLength
(
0
)
{
}
~
nsIRenderingContextBidiProcessor
(
)
{
mFontMetrics
-
>
SetTextRunRTL
(
false
)
;
}
virtual
void
SetText
(
const
char16_t
*
aText
int32_t
aLength
nsBidiDirection
aDirection
)
override
{
mFontMetrics
-
>
SetTextRunRTL
(
aDirection
=
=
NSBIDI_RTL
)
;
mText
=
aText
;
mLength
=
aLength
;
}
virtual
nscoord
GetWidth
(
)
override
{
return
nsLayoutUtils
:
:
AppUnitWidthOfString
(
mText
mLength
*
mFontMetrics
mTextRunConstructionDrawTarget
)
;
}
virtual
void
DrawText
(
nscoord
aIOffset
nscoord
)
override
{
nsPoint
pt
(
mPt
)
;
if
(
mFontMetrics
-
>
GetVertical
(
)
)
{
pt
.
y
+
=
aIOffset
;
}
else
{
pt
.
x
+
=
aIOffset
;
}
mFontMetrics
-
>
DrawString
(
mText
mLength
pt
.
x
pt
.
y
mCtx
mTextRunConstructionDrawTarget
)
;
}
private
:
gfxContext
*
mCtx
;
DrawTarget
*
mTextRunConstructionDrawTarget
;
nsFontMetrics
*
mFontMetrics
;
nsPoint
mPt
;
const
char16_t
*
mText
;
int32_t
mLength
;
}
;
nsresult
nsBidiPresUtils
:
:
ProcessTextForRenderingContext
(
const
char16_t
*
aText
int32_t
aLength
nsBidiLevel
aBaseLevel
nsPresContext
*
aPresContext
gfxContext
&
aRenderingContext
DrawTarget
*
aTextRunConstructionDrawTarget
nsFontMetrics
&
aFontMetrics
Mode
aMode
nscoord
aX
nscoord
aY
nsBidiPositionResolve
*
aPosResolve
int32_t
aPosResolveCount
nscoord
*
aWidth
)
{
nsIRenderingContextBidiProcessor
processor
(
&
aRenderingContext
aTextRunConstructionDrawTarget
&
aFontMetrics
nsPoint
(
aX
aY
)
)
;
return
ProcessText
(
aText
aLength
aBaseLevel
aPresContext
processor
aMode
aPosResolve
aPosResolveCount
aWidth
&
aPresContext
-
>
GetBidiEngine
(
)
)
;
}
nsBidiLevel
nsBidiPresUtils
:
:
BidiLevelFromStyle
(
ComputedStyle
*
aComputedStyle
)
{
if
(
aComputedStyle
-
>
StyleTextReset
(
)
-
>
mUnicodeBidi
&
NS_STYLE_UNICODE_BIDI_PLAINTEXT
)
{
return
NSBIDI_DEFAULT_LTR
;
}
if
(
aComputedStyle
-
>
StyleVisibility
(
)
-
>
mDirection
=
=
NS_STYLE_DIRECTION_RTL
)
{
return
NSBIDI_RTL
;
}
return
NSBIDI_LTR
;
}
