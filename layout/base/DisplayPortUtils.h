#
ifndef
mozilla_DisplayPortUtils_h__
#
define
mozilla_DisplayPortUtils_h__
#
include
<
cstdint
>
#
include
<
iosfwd
>
#
include
"
Units
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsRect
.
h
"
class
nsIContent
;
class
nsIFrame
;
class
nsPresContext
;
namespace
mozilla
{
class
nsDisplayListBuilder
;
class
PresShell
;
class
ScrollContainerFrame
;
enum
class
DisplayportRelativeTo
{
ScrollPort
ScrollFrame
}
;
enum
class
ContentGeometryType
{
Scrolled
Fixed
}
;
struct
DisplayPortOptions
{
DisplayportRelativeTo
mRelativeTo
=
DisplayportRelativeTo
:
:
ScrollPort
;
ContentGeometryType
mGeometryType
=
ContentGeometryType
:
:
Scrolled
;
DisplayPortOptions
With
(
DisplayportRelativeTo
aRelativeTo
)
const
{
DisplayPortOptions
result
=
*
this
;
result
.
mRelativeTo
=
aRelativeTo
;
return
result
;
}
DisplayPortOptions
With
(
ContentGeometryType
aGeometryType
)
const
{
DisplayPortOptions
result
=
*
this
;
result
.
mGeometryType
=
aGeometryType
;
return
result
;
}
}
;
struct
DisplayPortPropertyData
{
DisplayPortPropertyData
(
const
nsRect
&
aRect
uint32_t
aPriority
bool
aPainted
)
:
mRect
(
aRect
)
mPriority
(
aPriority
)
mPainted
(
aPainted
)
{
}
nsRect
mRect
;
uint32_t
mPriority
;
bool
mPainted
;
}
;
struct
DisplayPortMargins
{
ScreenMargin
mMargins
;
CSSPoint
mVisualOffset
;
CSSPoint
mLayoutOffset
;
static
DisplayPortMargins
FromAPZ
(
const
ScreenMargin
&
aMargins
const
CSSPoint
&
aVisualOffset
const
CSSPoint
&
aLayoutOffset
)
;
static
DisplayPortMargins
ForScrollContainerFrame
(
ScrollContainerFrame
*
aScrollContainerFrame
const
ScreenMargin
&
aMargins
)
;
static
DisplayPortMargins
ForContent
(
nsIContent
*
aContent
const
ScreenMargin
&
aMargins
)
;
static
DisplayPortMargins
Empty
(
nsIContent
*
aContent
)
{
return
ForContent
(
aContent
ScreenMargin
(
)
)
;
}
ScreenMargin
GetRelativeToLayoutViewport
(
ContentGeometryType
aGeometryType
ScrollContainerFrame
*
aScrollContainerFrame
const
CSSToScreenScale2D
&
aDisplayportScale
)
const
;
friend
std
:
:
ostream
&
operator
<
<
(
std
:
:
ostream
&
aOs
const
DisplayPortMargins
&
aMargins
)
;
private
:
CSSPoint
ComputeAsyncTranslation
(
ContentGeometryType
aGeometryType
ScrollContainerFrame
*
aScrollContainerFrame
)
const
;
}
;
struct
DisplayPortMarginsPropertyData
{
DisplayPortMarginsPropertyData
(
const
DisplayPortMargins
&
aMargins
uint32_t
aPriority
bool
aPainted
)
:
mMargins
(
aMargins
)
mPriority
(
aPriority
)
mPainted
(
aPainted
)
{
}
DisplayPortMargins
mMargins
;
uint32_t
mPriority
;
bool
mPainted
;
}
;
class
DisplayPortUtils
{
public
:
static
bool
GetDisplayPort
(
nsIContent
*
aContent
nsRect
*
aResult
const
DisplayPortOptions
&
aOptions
=
DisplayPortOptions
(
)
)
;
static
bool
HasDisplayPort
(
nsIContent
*
aContent
)
;
static
bool
HasPaintedDisplayPort
(
nsIContent
*
aContent
)
;
static
void
MarkDisplayPortAsPainted
(
nsIContent
*
aContent
)
;
static
bool
FrameHasDisplayPort
(
nsIFrame
*
aFrame
const
nsIFrame
*
aScrolledFrame
=
nullptr
)
;
static
bool
HasNonMinimalDisplayPort
(
nsIContent
*
aContent
)
;
static
bool
HasNonMinimalNonZeroDisplayPort
(
nsIContent
*
aContent
)
;
static
bool
IsMissingDisplayPortBaseRect
(
nsIContent
*
aContent
)
;
static
bool
GetDisplayPortForVisibilityTesting
(
nsIContent
*
aContent
nsRect
*
aResult
)
;
enum
class
RepaintMode
:
uint8_t
{
Repaint
DoNotRepaint
}
;
static
void
InvalidateForDisplayPortChange
(
nsIContent
*
aContent
bool
aHadDisplayPort
const
nsRect
&
aOldDisplayPort
const
nsRect
&
aNewDisplayPort
RepaintMode
aRepaintMode
=
RepaintMode
:
:
Repaint
)
;
enum
class
ClearMinimalDisplayPortProperty
{
No
Yes
}
;
static
bool
SetDisplayPortMargins
(
nsIContent
*
aContent
PresShell
*
aPresShell
const
DisplayPortMargins
&
aMargins
ClearMinimalDisplayPortProperty
aClearMinimalDisplayPortProperty
uint32_t
aPriority
=
0
RepaintMode
aRepaintMode
=
RepaintMode
:
:
Repaint
)
;
static
void
SetDisplayPortBase
(
nsIContent
*
aContent
const
nsRect
&
aBase
)
;
static
void
SetDisplayPortBaseIfNotSet
(
nsIContent
*
aContent
const
nsRect
&
aBase
)
;
static
void
RemoveDisplayPort
(
nsIContent
*
aContent
)
;
static
bool
ViewportHasDisplayPort
(
nsPresContext
*
aPresContext
)
;
static
bool
IsFixedPosFrameInDisplayPort
(
const
nsIFrame
*
aFrame
)
;
static
bool
MaybeCreateDisplayPortInFirstScrollFrameEncountered
(
nsIFrame
*
aFrame
nsDisplayListBuilder
*
aBuilder
)
;
static
bool
CalculateAndSetDisplayPortMargins
(
ScrollContainerFrame
*
aScrollContainerFrame
RepaintMode
aRepaintMode
)
;
static
bool
MaybeCreateDisplayPort
(
nsDisplayListBuilder
*
aBuilder
ScrollContainerFrame
*
aScrollContainerFrame
RepaintMode
aRepaintMode
)
;
static
nsIFrame
*
OneStepInAsyncScrollableAncestorChain
(
nsIFrame
*
aFrame
)
;
static
void
SetZeroMarginDisplayPortOnAsyncScrollableAncestors
(
nsIFrame
*
aFrame
)
;
static
void
ExpireDisplayPortOnAsyncScrollableAncestor
(
nsIFrame
*
aFrame
)
;
static
Maybe
<
nsRect
>
GetRootDisplayportBase
(
PresShell
*
aPresShell
)
;
static
nsRect
GetDisplayportBase
(
nsIFrame
*
aFrame
)
;
static
bool
WillUseEmptyDisplayPortMargins
(
nsIContent
*
aContent
)
;
}
;
}
#
endif
