#
ifndef
nsCSSFrameConstructor_h___
#
define
nsCSSFrameConstructor_h___
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsILayoutHistoryState
.
h
"
#
include
"
nsQuoteList
.
h
"
#
include
"
nsCounterManager
.
h
"
#
include
"
nsIAnonymousContentCreator
.
h
"
#
include
"
nsFrameManager
.
h
"
#
include
"
ScrollbarStyles
.
h
"
struct
nsFrameItems
;
class
nsStyleContext
;
struct
nsStyleDisplay
;
struct
nsGenConInitializer
;
class
nsContainerFrame
;
class
nsFirstLineFrame
;
class
nsFirstLetterFrame
;
class
nsICSSAnonBoxPseudo
;
class
nsIDocument
;
class
nsPageContentFrame
;
struct
PendingBinding
;
class
nsGenericDOMDataNode
;
class
nsFrameConstructorState
;
namespace
mozilla
{
namespace
dom
{
class
FlattenedChildIterator
;
}
}
class
nsCSSFrameConstructor
final
:
public
nsFrameManager
{
public
:
typedef
mozilla
:
:
CSSPseudoElementType
CSSPseudoElementType
;
typedef
mozilla
:
:
dom
:
:
Element
Element
;
friend
class
mozilla
:
:
RestyleManager
;
friend
class
mozilla
:
:
GeckoRestyleManager
;
friend
class
mozilla
:
:
ServoRestyleManager
;
nsCSSFrameConstructor
(
nsIDocument
*
aDocument
nsIPresShell
*
aPresShell
)
;
~
nsCSSFrameConstructor
(
)
{
MOZ_ASSERT
(
mUpdateCount
=
=
0
"
Dying
in
the
middle
of
our
own
update
?
"
)
;
}
static
void
GetAlternateTextFor
(
nsIContent
*
aContent
nsIAtom
*
aTag
nsAString
&
aAltText
)
;
private
:
nsCSSFrameConstructor
(
const
nsCSSFrameConstructor
&
aCopy
)
=
delete
;
nsCSSFrameConstructor
&
operator
=
(
const
nsCSSFrameConstructor
&
aCopy
)
=
delete
;
public
:
enum
class
InsertionKind
{
Sync
Async
}
;
mozilla
:
:
RestyleManager
*
RestyleManager
(
)
const
{
return
mPresShell
-
>
GetPresContext
(
)
-
>
RestyleManager
(
)
;
}
nsIFrame
*
ConstructRootFrame
(
)
;
void
ReconstructDocElementHierarchy
(
InsertionKind
)
;
void
CreateNeededFrames
(
)
;
private
:
void
CreateNeededFrames
(
nsIContent
*
aContent
TreeMatchContext
&
aTreeMatchContext
)
;
enum
Operation
{
CONTENTAPPEND
CONTENTINSERT
}
;
bool
MaybeConstructLazily
(
Operation
aOperation
nsIContent
*
aContainer
nsIContent
*
aChild
)
;
#
ifdef
DEBUG
void
CheckBitsForLazyFrameConstruction
(
nsIContent
*
aParent
)
;
#
else
void
CheckBitsForLazyFrameConstruction
(
nsIContent
*
)
{
}
#
endif
void
IssueSingleInsertNofications
(
nsIContent
*
aContainer
nsIContent
*
aStartChild
nsIContent
*
aEndChild
InsertionKind
bool
aForReconstruction
)
;
struct
InsertionPoint
{
InsertionPoint
(
)
:
mParentFrame
(
nullptr
)
mContainer
(
nullptr
)
mMultiple
(
false
)
{
}
InsertionPoint
(
nsContainerFrame
*
aParentFrame
nsIContent
*
aContainer
bool
aMultiple
=
false
)
:
mParentFrame
(
aParentFrame
)
mContainer
(
aContainer
)
mMultiple
(
aMultiple
)
{
}
nsContainerFrame
*
mParentFrame
;
nsIContent
*
mContainer
;
bool
mMultiple
;
}
;
InsertionPoint
GetRangeInsertionPoint
(
nsIContent
*
aContainer
nsIContent
*
aStartChild
nsIContent
*
aEndChild
InsertionKind
bool
aForReconstruction
)
;
bool
MaybeRecreateForFrameset
(
nsIFrame
*
aParentFrame
nsIContent
*
aStartChild
nsIContent
*
aEndChild
InsertionKind
)
;
void
LazilyStyleNewChildRange
(
nsIContent
*
aStartChild
nsIContent
*
aEndChild
)
;
void
StyleNewChildRange
(
nsIContent
*
aStartChild
nsIContent
*
aEndChild
)
;
public
:
void
ContentAppended
(
nsIContent
*
aContainer
nsIContent
*
aFirstNewContent
InsertionKind
aInsertionKind
TreeMatchContext
*
aProvidedTreeMatchContext
=
nullptr
)
{
ContentAppended
(
aContainer
aFirstNewContent
aInsertionKind
false
aProvidedTreeMatchContext
)
;
}
void
ContentInserted
(
nsIContent
*
aContainer
nsIContent
*
aChild
nsILayoutHistoryState
*
aFrameState
InsertionKind
aInsertionKind
)
;
void
ContentRangeInserted
(
nsIContent
*
aContainer
nsIContent
*
aStartChild
nsIContent
*
aEndChild
nsILayoutHistoryState
*
aFrameState
InsertionKind
aInsertionKind
TreeMatchContext
*
aProvidedTreeMatchContext
=
nullptr
)
{
ContentRangeInserted
(
aContainer
aStartChild
aEndChild
aFrameState
aInsertionKind
false
aProvidedTreeMatchContext
)
;
}
private
:
void
ContentAppended
(
nsIContent
*
aContainer
nsIContent
*
aFirstNewContent
InsertionKind
aInsertionKind
bool
aForReconstruction
TreeMatchContext
*
aProvidedTreeMatchContext
)
;
void
ContentRangeInserted
(
nsIContent
*
aContainer
nsIContent
*
aStartChild
nsIContent
*
aEndChild
nsILayoutHistoryState
*
aFrameState
InsertionKind
aInsertionKind
bool
aForReconstruction
TreeMatchContext
*
aProvidedTreeMatchContext
)
;
public
:
enum
RemoveFlags
{
REMOVE_CONTENT
REMOVE_FOR_RECONSTRUCTION
}
;
bool
ContentRemoved
(
nsIContent
*
aContainer
nsIContent
*
aChild
nsIContent
*
aOldNextSibling
InsertionKind
aInsertionKind
RemoveFlags
aFlags
)
;
void
CharacterDataChanged
(
nsIContent
*
aContent
CharacterDataChangeInfo
*
aInfo
)
;
nsIFrame
*
EnsureFrameForTextNode
(
nsGenericDOMDataNode
*
aContent
)
;
void
GenerateChildFrames
(
nsContainerFrame
*
aFrame
)
;
void
NotifyDestroyingFrame
(
nsIFrame
*
aFrame
)
;
void
BeginUpdate
(
)
;
void
EndUpdate
(
)
;
void
RecalcQuotesAndCounters
(
)
;
void
NotifyCounterStylesAreDirty
(
)
;
void
WillDestroyFrameTree
(
)
;
bool
DestroyFramesFor
(
mozilla
:
:
dom
:
:
Element
*
aElement
)
;
nsIFrame
*
CreateContinuingFrame
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
nsContainerFrame
*
aParentFrame
bool
aIsFluid
=
true
)
;
nsresult
ReplicateFixedFrames
(
nsPageContentFrame
*
aParentFrame
)
;
InsertionPoint
GetInsertionPoint
(
nsIContent
*
aContainer
nsIContent
*
aChild
)
;
void
CreateListBoxContent
(
nsContainerFrame
*
aParentFrame
nsIFrame
*
aPrevFrame
nsIContent
*
aChild
nsIFrame
*
*
aResult
bool
aIsAppend
)
;
nsContainerFrame
*
GetRootElementFrame
(
)
{
return
mRootElementFrame
;
}
nsIFrame
*
GetRootElementStyleFrame
(
)
{
return
mRootElementStyleFrame
;
}
nsIFrame
*
GetPageSequenceFrame
(
)
{
return
mPageSequenceFrame
;
}
nsContainerFrame
*
GetDocElementContainingBlock
(
)
{
return
mDocElementContainingBlock
;
}
private
:
struct
FrameConstructionItem
;
class
FrameConstructionItemList
;
nsContainerFrame
*
ConstructPageFrame
(
nsIPresShell
*
aPresShell
nsContainerFrame
*
aParentFrame
nsIFrame
*
aPrevPageFrame
nsContainerFrame
*
&
aCanvasFrame
)
;
void
InitAndRestoreFrame
(
const
nsFrameConstructorState
&
aState
nsIContent
*
aContent
nsContainerFrame
*
aParentFrame
nsIFrame
*
aNewFrame
bool
aAllowCounters
=
true
)
;
already_AddRefed
<
nsStyleContext
>
ResolveStyleContext
(
nsIFrame
*
aParentFrame
nsIContent
*
aContainer
nsIContent
*
aChild
nsFrameConstructorState
*
aState
)
;
already_AddRefed
<
nsStyleContext
>
ResolveStyleContext
(
nsIFrame
*
aParentFrame
nsIContent
*
aChild
nsFrameConstructorState
*
aState
)
;
already_AddRefed
<
nsStyleContext
>
ResolveStyleContext
(
const
InsertionPoint
&
aInsertion
nsIContent
*
aChild
nsFrameConstructorState
*
aState
)
;
already_AddRefed
<
nsStyleContext
>
ResolveStyleContext
(
nsStyleContext
*
aParentStyleContext
nsIContent
*
aContent
nsFrameConstructorState
*
aState
Element
*
aOriginatingElementOrNull
=
nullptr
)
;
void
AddFrameConstructionItems
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
bool
aSuppressWhiteSpaceOptimizations
const
InsertionPoint
&
aInsertion
FrameConstructionItemList
&
aItems
)
;
bool
ShouldCreateItemsForChild
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
nsContainerFrame
*
aParentFrame
)
;
void
DoAddFrameConstructionItems
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
nsStyleContext
*
aStyleContext
bool
aSuppressWhiteSpaceOptimizations
nsContainerFrame
*
aParentFrame
nsTArray
<
nsIAnonymousContentCreator
:
:
ContentInfo
>
*
aAnonChildren
FrameConstructionItemList
&
aItems
)
;
nsIFrame
*
ConstructDocElementFrame
(
Element
*
aDocElement
nsILayoutHistoryState
*
aFrameState
)
;
void
SetUpDocElementContainingBlock
(
nsIContent
*
aDocElement
)
;
void
CreateAttributeContent
(
nsIContent
*
aParentContent
nsIFrame
*
aParentFrame
int32_t
aAttrNamespace
nsIAtom
*
aAttrName
nsStyleContext
*
aStyleContext
nsCOMArray
<
nsIContent
>
&
aGeneratedContent
nsIContent
*
*
aNewContent
nsIFrame
*
*
aNewFrame
)
;
already_AddRefed
<
nsIContent
>
CreateGenConTextNode
(
nsFrameConstructorState
&
aState
const
nsString
&
aString
RefPtr
<
nsTextNode
>
*
aText
nsGenConInitializer
*
aInitializer
)
;
already_AddRefed
<
nsIContent
>
CreateGeneratedContent
(
nsFrameConstructorState
&
aState
nsIContent
*
aParentContent
nsStyleContext
*
aStyleContext
uint32_t
aContentIndex
)
;
void
CreateGeneratedContentItem
(
nsFrameConstructorState
&
aState
nsContainerFrame
*
aFrame
nsIContent
*
aContent
nsStyleContext
*
aStyleContext
CSSPseudoElementType
aPseudoElement
FrameConstructionItemList
&
aItems
)
;
void
AppendFramesToParent
(
nsFrameConstructorState
&
aState
nsContainerFrame
*
aParentFrame
nsFrameItems
&
aFrameList
nsIFrame
*
aPrevSibling
bool
aIsRecursiveCall
=
false
)
;
nsIFrame
*
ConstructTable
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aDisplay
nsFrameItems
&
aFrameItems
)
;
nsIFrame
*
ConstructTableRowOrRowGroup
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aStyleDisplay
nsFrameItems
&
aFrameItems
)
;
nsIFrame
*
ConstructTableCol
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aStyleDisplay
nsFrameItems
&
aFrameItems
)
;
nsIFrame
*
ConstructTableCell
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aStyleDisplay
nsFrameItems
&
aFrameItems
)
;
private
:
enum
ParentType
{
eTypeBlock
=
0
eTypeRow
eTypeRowGroup
eTypeColGroup
eTypeTable
eTypeRuby
eTypeRubyBase
eTypeRubyBaseContainer
eTypeRubyText
eTypeRubyTextContainer
eParentTypeCount
}
;
#
define
FCDATA_PARENT_TYPE_OFFSET
28
#
define
FCDATA_DESIRED_PARENT_TYPE
(
_bits
)
\
ParentType
(
(
_bits
)
>
>
FCDATA_PARENT_TYPE_OFFSET
)
#
define
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
_type
)
\
(
(
(
uint32_t
)
(
_type
)
)
<
<
FCDATA_PARENT_TYPE_OFFSET
)
static
ParentType
GetParentType
(
nsIFrame
*
aParentFrame
)
{
return
GetParentType
(
aParentFrame
-
>
Type
(
)
)
;
}
static
ParentType
GetParentType
(
mozilla
:
:
LayoutFrameType
aFrameType
)
;
static
bool
IsRubyParentType
(
ParentType
aParentType
)
{
return
(
aParentType
=
=
eTypeRuby
|
|
aParentType
=
=
eTypeRubyBase
|
|
aParentType
=
=
eTypeRubyBaseContainer
|
|
aParentType
=
=
eTypeRubyText
|
|
aParentType
=
=
eTypeRubyTextContainer
)
;
}
static
bool
IsTableParentType
(
ParentType
aParentType
)
{
return
(
aParentType
=
=
eTypeTable
|
|
aParentType
=
=
eTypeRow
|
|
aParentType
=
=
eTypeRowGroup
|
|
aParentType
=
=
eTypeColGroup
)
;
}
typedef
nsIFrame
*
(
*
FrameCreationFunc
)
(
nsIPresShell
*
nsStyleContext
*
)
;
typedef
nsContainerFrame
*
(
*
ContainerFrameCreationFunc
)
(
nsIPresShell
*
nsStyleContext
*
)
;
typedef
nsBlockFrame
*
(
*
BlockFrameCreationFunc
)
(
nsIPresShell
*
nsStyleContext
*
)
;
struct
FrameConstructionData
;
typedef
const
FrameConstructionData
*
(
*
FrameConstructionDataGetter
)
(
Element
*
nsStyleContext
*
)
;
typedef
nsIFrame
*
(
nsCSSFrameConstructor
:
:
*
FrameFullConstructor
)
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aStyleDisplay
nsFrameItems
&
aFrameItems
)
;
#
define
FCDATA_SKIP_FRAMESET
0x1
#
define
FCDATA_FUNC_IS_DATA_GETTER
0x2
#
define
FCDATA_FUNC_IS_FULL_CTOR
0x4
#
define
FCDATA_DISALLOW_OUT_OF_FLOW
0x8
#
define
FCDATA_FORCE_NULL_ABSPOS_CONTAINER
0x10
#
define
FCDATA_WRAP_KIDS_IN_BLOCKS
0x20
#
define
FCDATA_SUPPRESS_FRAME
0x40
#
define
FCDATA_MAY_NEED_SCROLLFRAME
0x80
#
ifdef
MOZ_XUL
#
define
FCDATA_IS_POPUP
0x100
#
endif
#
define
FCDATA_SKIP_ABSPOS_PUSH
0x200
#
define
FCDATA_DISALLOW_GENERATED_CONTENT
0x400
#
define
FCDATA_IS_TABLE_PART
0x800
#
define
FCDATA_IS_INLINE
0x1000
#
define
FCDATA_IS_LINE_PARTICIPANT
0x2000
#
define
FCDATA_IS_LINE_BREAK
0x4000
#
define
FCDATA_ALLOW_BLOCK_STYLES
0x8000
#
define
FCDATA_USE_CHILD_ITEMS
0x10000
#
define
FCDATA_FORCED_NON_SCROLLABLE_BLOCK
0x20000
#
define
FCDATA_CREATE_BLOCK_WRAPPER_FOR_ALL_KIDS
0x40000
#
define
FCDATA_IS_SVG_TEXT
0x80000
#
define
FCDATA_IS_CONTENTS
0x100000
#
define
FCDATA_ALLOW_GRID_FLEX_COLUMNSET
0x200000
#
define
FCDATA_IS_WRAPPER_ANON_BOX
0x400000
struct
FrameConstructionData
{
uint32_t
mBits
;
union
Func
{
FrameCreationFunc
mCreationFunc
;
FrameConstructionDataGetter
mDataGetter
;
}
mFunc
;
FrameFullConstructor
mFullConstructor
;
nsICSSAnonBoxPseudo
*
const
*
const
mAnonBoxPseudo
;
}
;
struct
FrameConstructionDataByTag
{
const
nsIAtom
*
const
*
const
mTag
;
const
FrameConstructionData
mData
;
}
;
struct
FrameConstructionDataByInt
{
const
int32_t
mInt
;
const
FrameConstructionData
mData
;
}
;
struct
FrameConstructionDataByDisplay
{
#
ifdef
DEBUG
const
mozilla
:
:
StyleDisplay
mDisplay
;
#
endif
const
FrameConstructionData
mData
;
}
;
#
ifdef
DEBUG
#
define
FCDATA_FOR_DISPLAY
(
_display
_fcdata
)
\
{
_display
_fcdata
}
#
else
#
define
FCDATA_FOR_DISPLAY
(
_display
_fcdata
)
\
{
_fcdata
}
#
endif
struct
PseudoParentData
{
const
FrameConstructionData
mFCData
;
nsICSSAnonBoxPseudo
*
const
*
const
mPseudoType
;
}
;
static
const
PseudoParentData
sPseudoParentData
[
eParentTypeCount
]
;
static
const
FrameConstructionData
*
FindDataByInt
(
int32_t
aInt
Element
*
aElement
nsStyleContext
*
aStyleContext
const
FrameConstructionDataByInt
*
aDataPtr
uint32_t
aDataLength
)
;
static
const
FrameConstructionData
*
FindDataByTag
(
nsIAtom
*
aTag
Element
*
aElement
nsStyleContext
*
aStyleContext
const
FrameConstructionDataByTag
*
aDataPtr
uint32_t
aDataLength
)
;
class
FrameConstructionItemList
final
{
public
:
FrameConstructionItemList
(
)
:
mInlineCount
(
0
)
mBlockCount
(
0
)
mLineParticipantCount
(
0
)
mItemCount
(
0
)
mLineBoundaryAtStart
(
false
)
mLineBoundaryAtEnd
(
false
)
mParentHasNoXBLChildren
(
false
)
mTriedConstructingFrames
(
false
)
{
memset
(
mDesiredParentCounts
0
sizeof
(
mDesiredParentCounts
)
)
;
}
~
FrameConstructionItemList
(
)
{
while
(
FrameConstructionItem
*
item
=
mItems
.
popFirst
(
)
)
{
delete
item
;
}
if
(
!
mUndisplayedItems
.
IsEmpty
(
)
&
&
mTriedConstructingFrames
)
{
nsFrameManager
*
mgr
=
mUndisplayedItems
[
0
]
.
mStyleContext
-
>
PresContext
(
)
-
>
FrameManager
(
)
;
for
(
uint32_t
i
=
0
;
i
<
mUndisplayedItems
.
Length
(
)
;
+
+
i
)
{
UndisplayedItem
&
item
=
mUndisplayedItems
[
i
]
;
mgr
-
>
RegisterDisplayNoneStyleFor
(
item
.
mContent
item
.
mStyleContext
)
;
}
}
}
void
SetLineBoundaryAtStart
(
bool
aBoundary
)
{
mLineBoundaryAtStart
=
aBoundary
;
}
void
SetLineBoundaryAtEnd
(
bool
aBoundary
)
{
mLineBoundaryAtEnd
=
aBoundary
;
}
void
SetParentHasNoXBLChildren
(
bool
aHasNoXBLChildren
)
{
mParentHasNoXBLChildren
=
aHasNoXBLChildren
;
}
void
SetTriedConstructingFrames
(
)
{
mTriedConstructingFrames
=
true
;
}
bool
HasLineBoundaryAtStart
(
)
{
return
mLineBoundaryAtStart
;
}
bool
HasLineBoundaryAtEnd
(
)
{
return
mLineBoundaryAtEnd
;
}
bool
ParentHasNoXBLChildren
(
)
{
return
mParentHasNoXBLChildren
;
}
bool
IsEmpty
(
)
const
{
return
mItems
.
isEmpty
(
)
;
}
bool
AnyItemsNeedBlockParent
(
)
const
{
return
mLineParticipantCount
!
=
0
;
}
bool
AreAllItemsInline
(
)
const
{
return
mInlineCount
=
=
mItemCount
;
}
bool
AreAllItemsBlock
(
)
const
{
return
mBlockCount
=
=
mItemCount
;
}
bool
AllWantParentType
(
ParentType
aDesiredParentType
)
const
{
return
mDesiredParentCounts
[
aDesiredParentType
]
=
=
mItemCount
;
}
FrameConstructionItem
*
AppendItem
(
const
FrameConstructionData
*
aFCData
nsIContent
*
aContent
nsIAtom
*
aTag
int32_t
aNameSpaceID
PendingBinding
*
aPendingBinding
already_AddRefed
<
nsStyleContext
>
&
&
aStyleContext
bool
aSuppressWhiteSpaceOptimizations
nsTArray
<
nsIAnonymousContentCreator
:
:
ContentInfo
>
*
aAnonChildren
)
{
FrameConstructionItem
*
item
=
new
FrameConstructionItem
(
aFCData
aContent
aTag
aNameSpaceID
aPendingBinding
aStyleContext
aSuppressWhiteSpaceOptimizations
aAnonChildren
)
;
mItems
.
insertBack
(
item
)
;
+
+
mItemCount
;
+
+
mDesiredParentCounts
[
item
-
>
DesiredParentType
(
)
]
;
return
item
;
}
FrameConstructionItem
*
PrependItem
(
const
FrameConstructionData
*
aFCData
nsIContent
*
aContent
nsIAtom
*
aTag
int32_t
aNameSpaceID
PendingBinding
*
aPendingBinding
already_AddRefed
<
nsStyleContext
>
&
&
aStyleContext
bool
aSuppressWhiteSpaceOptimizations
nsTArray
<
nsIAnonymousContentCreator
:
:
ContentInfo
>
*
aAnonChildren
)
{
FrameConstructionItem
*
item
=
new
FrameConstructionItem
(
aFCData
aContent
aTag
aNameSpaceID
aPendingBinding
aStyleContext
aSuppressWhiteSpaceOptimizations
aAnonChildren
)
;
mItems
.
insertFront
(
item
)
;
+
+
mItemCount
;
+
+
mDesiredParentCounts
[
item
-
>
DesiredParentType
(
)
]
;
return
item
;
}
void
AppendUndisplayedItem
(
nsIContent
*
aContent
nsStyleContext
*
aStyleContext
)
{
mUndisplayedItems
.
AppendElement
(
UndisplayedItem
(
aContent
aStyleContext
)
)
;
}
void
InlineItemAdded
(
)
{
+
+
mInlineCount
;
}
void
BlockItemAdded
(
)
{
+
+
mBlockCount
;
}
void
LineParticipantItemAdded
(
)
{
+
+
mLineParticipantCount
;
}
class
Iterator
{
public
:
explicit
Iterator
(
FrameConstructionItemList
&
aList
)
:
mCurrent
(
aList
.
mItems
.
getFirst
(
)
)
mList
(
aList
)
{
}
Iterator
(
const
Iterator
&
aOther
)
:
mCurrent
(
aOther
.
mCurrent
)
mList
(
aOther
.
mList
)
{
}
bool
operator
=
=
(
const
Iterator
&
aOther
)
const
{
MOZ_ASSERT
(
&
mList
=
=
&
aOther
.
mList
"
Iterators
for
different
lists
?
"
)
;
return
mCurrent
=
=
aOther
.
mCurrent
;
}
bool
operator
!
=
(
const
Iterator
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
Iterator
&
operator
=
(
const
Iterator
&
aOther
)
{
MOZ_ASSERT
(
&
mList
=
=
&
aOther
.
mList
"
Iterators
for
different
lists
?
"
)
;
mCurrent
=
aOther
.
mCurrent
;
return
*
this
;
}
FrameConstructionItemList
*
List
(
)
{
return
&
mList
;
}
FrameConstructionItem
&
item
(
)
{
MOZ_ASSERT
(
!
IsDone
(
)
"
Should
have
checked
IsDone
(
)
!
"
)
;
return
*
mCurrent
;
}
const
FrameConstructionItem
&
item
(
)
const
{
MOZ_ASSERT
(
!
IsDone
(
)
"
Should
have
checked
IsDone
(
)
!
"
)
;
return
*
mCurrent
;
}
bool
IsDone
(
)
const
{
return
mCurrent
=
=
nullptr
;
}
bool
AtStart
(
)
const
{
return
mCurrent
=
=
mList
.
mItems
.
getFirst
(
)
;
}
void
Next
(
)
{
NS_ASSERTION
(
!
IsDone
(
)
"
Should
have
checked
IsDone
(
)
!
"
)
;
mCurrent
=
mCurrent
-
>
getNext
(
)
;
}
void
Prev
(
)
{
NS_ASSERTION
(
!
AtStart
(
)
"
Should
have
checked
AtStart
(
)
!
"
)
;
mCurrent
=
mCurrent
?
mCurrent
-
>
getPrevious
(
)
:
mList
.
mItems
.
getLast
(
)
;
}
void
SetToEnd
(
)
{
mCurrent
=
nullptr
;
}
inline
bool
SkipItemsWantingParentType
(
ParentType
aParentType
)
;
inline
bool
SkipItemsNotWantingParentType
(
ParentType
aParentType
)
;
inline
bool
SkipItemsThatNeedAnonFlexOrGridItem
(
const
nsFrameConstructorState
&
aState
bool
aIsWebkitBox
)
;
inline
bool
SkipItemsThatDontNeedAnonFlexOrGridItem
(
const
nsFrameConstructorState
&
aState
bool
aIsWebkitBox
)
;
inline
bool
SkipItemsNotWantingRubyParent
(
)
;
inline
bool
SkipWhitespace
(
nsFrameConstructorState
&
aState
)
;
void
AppendItemToList
(
FrameConstructionItemList
&
aTargetList
)
;
void
AppendItemsToList
(
const
Iterator
&
aEnd
FrameConstructionItemList
&
aTargetList
)
;
void
InsertItem
(
FrameConstructionItem
*
aItem
)
;
void
DeleteItemsTo
(
const
Iterator
&
aEnd
)
;
private
:
FrameConstructionItem
*
mCurrent
;
FrameConstructionItemList
&
mList
;
}
;
private
:
struct
UndisplayedItem
{
UndisplayedItem
(
nsIContent
*
aContent
nsStyleContext
*
aStyleContext
)
:
mContent
(
aContent
)
mStyleContext
(
aStyleContext
)
{
}
nsIContent
*
const
mContent
;
RefPtr
<
nsStyleContext
>
mStyleContext
;
}
;
void
AdjustCountsForItem
(
FrameConstructionItem
*
aItem
int32_t
aDelta
)
;
mozilla
:
:
LinkedList
<
FrameConstructionItem
>
mItems
;
uint32_t
mInlineCount
;
uint32_t
mBlockCount
;
uint32_t
mLineParticipantCount
;
uint32_t
mItemCount
;
uint32_t
mDesiredParentCounts
[
eParentTypeCount
]
;
bool
mLineBoundaryAtStart
;
bool
mLineBoundaryAtEnd
;
bool
mParentHasNoXBLChildren
;
bool
mTriedConstructingFrames
;
nsTArray
<
UndisplayedItem
>
mUndisplayedItems
;
}
;
typedef
FrameConstructionItemList
:
:
Iterator
FCItemIterator
;
struct
FrameConstructionItem
final
:
public
mozilla
:
:
LinkedListElement
<
FrameConstructionItem
>
{
FrameConstructionItem
(
const
FrameConstructionData
*
aFCData
nsIContent
*
aContent
nsIAtom
*
aTag
int32_t
aNameSpaceID
PendingBinding
*
aPendingBinding
already_AddRefed
<
nsStyleContext
>
&
aStyleContext
bool
aSuppressWhiteSpaceOptimizations
nsTArray
<
nsIAnonymousContentCreator
:
:
ContentInfo
>
*
aAnonChildren
)
:
mFCData
(
aFCData
)
mContent
(
aContent
)
mTag
(
aTag
)
mPendingBinding
(
aPendingBinding
)
mStyleContext
(
aStyleContext
)
mNameSpaceID
(
aNameSpaceID
)
mSuppressWhiteSpaceOptimizations
(
aSuppressWhiteSpaceOptimizations
)
mIsText
(
false
)
mIsGeneratedContent
(
false
)
mIsAnonymousContentCreatorContent
(
false
)
mIsRootPopupgroup
(
false
)
mIsAllInline
(
false
)
mIsBlock
(
false
)
mHasInlineEnds
(
false
)
mIsPopup
(
false
)
mIsLineParticipant
(
false
)
mIsForSVGAElement
(
false
)
{
if
(
aAnonChildren
)
{
NS_ASSERTION
(
!
(
mFCData
-
>
mBits
&
FCDATA_FUNC_IS_FULL_CTOR
)
|
|
mFCData
-
>
mFullConstructor
=
=
&
nsCSSFrameConstructor
:
:
ConstructInline
"
This
is
going
to
fail
"
)
;
NS_ASSERTION
(
!
(
mFCData
-
>
mBits
&
FCDATA_USE_CHILD_ITEMS
)
"
nsIAnonymousContentCreator
:
:
CreateAnonymousContent
"
"
implementations
should
not
output
a
list
where
the
"
"
items
have
children
in
this
case
"
)
;
mAnonChildren
.
SwapElements
(
*
aAnonChildren
)
;
}
}
~
FrameConstructionItem
(
)
{
if
(
mIsGeneratedContent
)
{
mContent
-
>
UnbindFromTree
(
)
;
NS_RELEASE
(
mContent
)
;
}
}
ParentType
DesiredParentType
(
)
{
return
FCDATA_DESIRED_PARENT_TYPE
(
mFCData
-
>
mBits
)
;
}
bool
NeedsAnonFlexOrGridItem
(
const
nsFrameConstructorState
&
aState
bool
aIsWebkitBox
)
;
bool
IsWhitespace
(
nsFrameConstructorState
&
aState
)
const
;
bool
IsLineBoundary
(
)
const
{
return
mIsBlock
|
|
(
mFCData
-
>
mBits
&
FCDATA_IS_LINE_BREAK
)
;
}
FrameConstructionItemList
mChildItems
;
nsTArray
<
nsIAnonymousContentCreator
:
:
ContentInfo
>
mAnonChildren
;
const
FrameConstructionData
*
mFCData
;
nsIContent
*
mContent
;
nsIAtom
*
mTag
;
PendingBinding
*
mPendingBinding
;
RefPtr
<
nsStyleContext
>
mStyleContext
;
int32_t
mNameSpaceID
;
bool
mSuppressWhiteSpaceOptimizations
:
1
;
bool
mIsText
:
1
;
bool
mIsGeneratedContent
:
1
;
bool
mIsAnonymousContentCreatorContent
:
1
;
bool
mIsRootPopupgroup
:
1
;
bool
mIsAllInline
:
1
;
bool
mIsBlock
:
1
;
bool
mHasInlineEnds
:
1
;
bool
mIsPopup
:
1
;
bool
mIsLineParticipant
:
1
;
bool
mIsForSVGAElement
:
1
;
private
:
FrameConstructionItem
(
const
FrameConstructionItem
&
aOther
)
=
delete
;
}
;
void
CreateNeededAnonFlexOrGridItems
(
nsFrameConstructorState
&
aState
FrameConstructionItemList
&
aItems
nsIFrame
*
aParentFrame
)
;
enum
RubyWhitespaceType
{
eRubyNotWhitespace
eRubyInterLevelWhitespace
eRubyInterLeafWhitespace
eRubyInterSegmentWhitespace
}
;
static
inline
RubyWhitespaceType
ComputeRubyWhitespaceType
(
mozilla
:
:
StyleDisplay
aPrevDisplay
mozilla
:
:
StyleDisplay
aNextDisplay
)
;
static
inline
RubyWhitespaceType
InterpretRubyWhitespace
(
nsFrameConstructorState
&
aState
const
FCItemIterator
&
aStartIter
const
FCItemIterator
&
aEndIter
)
;
void
WrapItemsInPseudoRubyLeafBox
(
FCItemIterator
&
aIter
nsStyleContext
*
aParentStyle
nsIContent
*
aParentContent
)
;
inline
void
WrapItemsInPseudoRubyLevelContainer
(
nsFrameConstructorState
&
aState
FCItemIterator
&
aIter
nsStyleContext
*
aParentStyle
nsIContent
*
aParentContent
)
;
inline
void
TrimLeadingAndTrailingWhitespaces
(
nsFrameConstructorState
&
aState
FrameConstructionItemList
&
aItems
)
;
inline
void
CreateNeededPseudoInternalRubyBoxes
(
nsFrameConstructorState
&
aState
FrameConstructionItemList
&
aItems
nsIFrame
*
aParentFrame
)
;
inline
void
CreateNeededPseudoContainers
(
nsFrameConstructorState
&
aState
FrameConstructionItemList
&
aItems
nsIFrame
*
aParentFrame
)
;
inline
void
WrapItemsInPseudoParent
(
nsIContent
*
aParentContent
nsStyleContext
*
aParentStyle
ParentType
aWrapperType
FCItemIterator
&
aIter
const
FCItemIterator
&
aEndIter
)
;
inline
void
CreateNeededPseudoSiblings
(
nsFrameConstructorState
&
aState
FrameConstructionItemList
&
aItems
nsIFrame
*
aParentFrame
)
;
void
AdjustParentFrame
(
nsContainerFrame
*
*
aParentFrame
const
FrameConstructionData
*
aFCData
nsStyleContext
*
aStyleContext
)
;
protected
:
static
nsIFrame
*
CreatePlaceholderFrameFor
(
nsIPresShell
*
aPresShell
nsIContent
*
aContent
nsIFrame
*
aFrame
nsContainerFrame
*
aParentFrame
nsIFrame
*
aPrevInFlow
nsFrameState
aTypeBit
)
;
static
nsIFrame
*
CreateBackdropFrameFor
(
nsIPresShell
*
aPresShell
nsIContent
*
aContent
nsIFrame
*
aFrame
nsContainerFrame
*
aParentFrame
)
;
private
:
nsIFrame
*
ConstructSelectFrame
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aStyleDisplay
nsFrameItems
&
aFrameItems
)
;
nsIFrame
*
ConstructFieldSetFrame
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aStyleDisplay
nsFrameItems
&
aFrameItems
)
;
nsIFrame
*
ConstructDetailsFrame
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aStyleDisplay
nsFrameItems
&
aFrameItems
)
;
static
const
FrameConstructionData
*
FindTextData
(
nsIFrame
*
aParentFrame
)
;
void
ConstructTextFrame
(
const
FrameConstructionData
*
aData
nsFrameConstructorState
&
aState
nsIContent
*
aContent
nsContainerFrame
*
aParentFrame
nsStyleContext
*
aStyleContext
nsFrameItems
&
aFrameItems
)
;
void
AddTextItemIfNeeded
(
nsFrameConstructorState
&
aState
const
InsertionPoint
&
aInsertion
nsIContent
*
aPossibleTextContent
FrameConstructionItemList
&
aItems
)
;
void
ReframeTextIfNeeded
(
nsIContent
*
aParentContent
nsIContent
*
aContent
)
;
void
AddPageBreakItem
(
nsIContent
*
aContent
FrameConstructionItemList
&
aItems
)
;
static
const
FrameConstructionData
*
FindHTMLData
(
Element
*
aContent
nsIAtom
*
aTag
int32_t
aNameSpaceID
nsIFrame
*
aParentFrame
nsStyleContext
*
aStyleContext
)
;
static
const
FrameConstructionData
*
FindImgData
(
Element
*
aElement
nsStyleContext
*
aStyleContext
)
;
static
const
FrameConstructionData
*
FindImgControlData
(
Element
*
aElement
nsStyleContext
*
aStyleContext
)
;
static
const
FrameConstructionData
*
FindInputData
(
Element
*
aElement
nsStyleContext
*
aStyleContext
)
;
static
const
FrameConstructionData
*
FindObjectData
(
Element
*
aElement
nsStyleContext
*
aStyleContext
)
;
static
const
FrameConstructionData
*
FindCanvasData
(
Element
*
aElement
nsStyleContext
*
aStyleContext
)
;
void
ConstructFrameFromItemInternal
(
FrameConstructionItem
&
aItem
nsFrameConstructorState
&
aState
nsContainerFrame
*
aParentFrame
nsFrameItems
&
aFrameItems
)
;
#
define
ITEM_ALLOW_XBL_BASE
0x1
#
define
ITEM_ALLOW_PAGE_BREAK
0x2
#
define
ITEM_IS_GENERATED_CONTENT
0x4
#
define
ITEM_IS_WITHIN_SVG_TEXT
0x8
#
define
ITEM_ALLOWS_TEXT_PATH_CHILD
0x10
#
define
ITEM_IS_ANONYMOUSCONTENTCREATOR_CONTENT
0x20
void
AddFrameConstructionItemsInternal
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
nsContainerFrame
*
aParentFrame
nsIAtom
*
aTag
int32_t
aNameSpaceID
bool
aSuppressWhiteSpaceOptimizations
nsStyleContext
*
aStyleContext
uint32_t
aFlags
nsTArray
<
nsIAnonymousContentCreator
:
:
ContentInfo
>
*
aAnonChildren
FrameConstructionItemList
&
aItems
)
;
void
ConstructFramesFromItemList
(
nsFrameConstructorState
&
aState
FrameConstructionItemList
&
aItems
nsContainerFrame
*
aParentFrame
bool
aParentIsWrapperAnonBox
nsFrameItems
&
aFrameItems
)
;
void
ConstructFramesFromItem
(
nsFrameConstructorState
&
aState
FCItemIterator
&
aItem
nsContainerFrame
*
aParentFrame
nsFrameItems
&
aFrameItems
)
;
static
bool
AtLineBoundary
(
FCItemIterator
&
aIter
)
;
nsresult
GetAnonymousContent
(
nsIContent
*
aParent
nsIFrame
*
aParentFrame
nsTArray
<
nsIAnonymousContentCreator
:
:
ContentInfo
>
&
aAnonContent
)
;
void
FlushAccumulatedBlock
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
nsContainerFrame
*
aParentFrame
nsFrameItems
&
aBlockItems
nsFrameItems
&
aNewItems
)
;
static
const
FrameConstructionData
*
FindMathMLData
(
Element
*
aElement
nsIAtom
*
aTag
int32_t
aNameSpaceID
nsStyleContext
*
aStyleContext
)
;
static
const
FrameConstructionData
*
FindXULTagData
(
Element
*
aElement
nsIAtom
*
aTag
int32_t
aNameSpaceID
nsStyleContext
*
aStyleContext
)
;
#
ifdef
MOZ_XUL
static
const
FrameConstructionData
*
FindPopupGroupData
(
Element
*
aElement
nsStyleContext
*
aStyleContext
)
;
static
const
FrameConstructionData
sXULTextBoxData
;
static
const
FrameConstructionData
*
FindXULLabelData
(
Element
*
aElement
nsStyleContext
*
aStyleContext
)
;
static
const
FrameConstructionData
*
FindXULDescriptionData
(
Element
*
aElement
nsStyleContext
*
aStyleContext
)
;
#
ifdef
XP_MACOSX
static
const
FrameConstructionData
*
FindXULMenubarData
(
Element
*
aElement
nsStyleContext
*
aStyleContext
)
;
#
endif
static
const
FrameConstructionData
*
FindXULListBoxBodyData
(
Element
*
aElement
nsStyleContext
*
aStyleContext
)
;
static
const
FrameConstructionData
*
FindXULListItemData
(
Element
*
aElement
nsStyleContext
*
aStyleContext
)
;
#
endif
static
const
FrameConstructionData
*
FindXULDisplayData
(
const
nsStyleDisplay
*
aDisplay
Element
*
aElement
nsStyleContext
*
aStyleContext
)
;
nsContainerFrame
*
ConstructFrameWithAnonymousChild
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
nsFrameItems
&
aFrameItems
ContainerFrameCreationFunc
aConstructor
ContainerFrameCreationFunc
aInnerConstructor
nsICSSAnonBoxPseudo
*
aInnerPseudo
bool
aCandidateRootFrame
)
;
nsIFrame
*
ConstructOuterSVG
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aDisplay
nsFrameItems
&
aFrameItems
)
;
nsIFrame
*
ConstructMarker
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aDisplay
nsFrameItems
&
aFrameItems
)
;
static
const
FrameConstructionData
*
FindSVGData
(
Element
*
aElement
nsIAtom
*
aTag
int32_t
aNameSpaceID
nsIFrame
*
aParentFrame
bool
aIsWithinSVGText
bool
aAllowsTextPathChild
nsStyleContext
*
aStyleContext
)
;
const
FrameConstructionData
*
FindDisplayData
(
const
nsStyleDisplay
*
aDisplay
Element
*
aElement
nsStyleContext
*
aStyleContext
)
;
nsIFrame
*
ConstructScrollableBlock
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aDisplay
nsFrameItems
&
aFrameItems
)
;
nsIFrame
*
ConstructScrollableBlockWithConstructor
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aDisplay
nsFrameItems
&
aFrameItems
BlockFrameCreationFunc
aConstructor
)
;
nsIFrame
*
ConstructNonScrollableBlock
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aDisplay
nsFrameItems
&
aFrameItems
)
;
nsIFrame
*
ConstructNonScrollableBlockWithConstructor
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aDisplay
nsFrameItems
&
aFrameItems
BlockFrameCreationFunc
aConstructor
)
;
void
AddFCItemsForAnonymousContent
(
nsFrameConstructorState
&
aState
nsContainerFrame
*
aFrame
nsTArray
<
nsIAnonymousContentCreator
:
:
ContentInfo
>
&
aAnonymousItems
FrameConstructionItemList
&
aItemsToConstruct
uint32_t
aExtraFlags
=
0
)
;
void
ProcessChildren
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
nsStyleContext
*
aStyleContext
nsContainerFrame
*
aParentFrame
const
bool
aCanHaveGeneratedContent
nsFrameItems
&
aFrameItems
const
bool
aAllowBlockStyles
PendingBinding
*
aPendingBinding
nsIFrame
*
aPossiblyLeafFrame
=
nullptr
)
;
public
:
enum
ContainingBlockType
{
ABS_POS
FIXED_POS
}
;
nsContainerFrame
*
GetAbsoluteContainingBlock
(
nsIFrame
*
aFrame
ContainingBlockType
aType
)
;
nsContainerFrame
*
GetFloatContainingBlock
(
nsIFrame
*
aFrame
)
;
private
:
void
BuildScrollFrame
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
nsStyleContext
*
aContentStyle
nsIFrame
*
aScrolledFrame
nsContainerFrame
*
aParentFrame
nsContainerFrame
*
&
aNewFrame
)
;
already_AddRefed
<
nsStyleContext
>
BeginBuildingScrollFrame
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
nsStyleContext
*
aContentStyle
nsContainerFrame
*
aParentFrame
nsIAtom
*
aScrolledPseudo
bool
aIsRoot
nsContainerFrame
*
&
aNewFrame
)
;
void
FinishBuildingScrollFrame
(
nsContainerFrame
*
aScrollFrame
nsIFrame
*
aScrolledFrame
)
;
void
InitializeSelectFrame
(
nsFrameConstructorState
&
aState
nsContainerFrame
*
aScrollFrame
nsContainerFrame
*
aScrolledFrame
nsIContent
*
aContent
nsContainerFrame
*
aParentFrame
nsStyleContext
*
aStyleContext
bool
aBuildCombobox
PendingBinding
*
aPendingBinding
nsFrameItems
&
aFrameItems
)
;
nsStyleContext
*
MaybeRecreateFramesForElement
(
Element
*
aElement
)
;
void
RecreateFramesForContent
(
nsIContent
*
aContent
InsertionKind
aInsertionKind
)
;
void
UpdateTableCellSpans
(
nsIContent
*
aContent
)
;
bool
MaybeRecreateContainerForFrameRemoval
(
nsIFrame
*
aFrame
InsertionKind
aInsertionKind
)
;
nsIFrame
*
CreateContinuingOuterTableFrame
(
nsIPresShell
*
aPresShell
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
nsContainerFrame
*
aParentFrame
nsIContent
*
aContent
nsStyleContext
*
aStyleContext
)
;
nsIFrame
*
CreateContinuingTableFrame
(
nsIPresShell
*
aPresShell
nsIFrame
*
aFrame
nsContainerFrame
*
aParentFrame
nsIContent
*
aContent
nsStyleContext
*
aStyleContext
)
;
already_AddRefed
<
nsStyleContext
>
GetFirstLetterStyle
(
nsIContent
*
aContent
nsStyleContext
*
aStyleContext
)
;
already_AddRefed
<
nsStyleContext
>
GetFirstLineStyle
(
nsIContent
*
aContent
nsStyleContext
*
aStyleContext
)
;
bool
ShouldHaveFirstLetterStyle
(
nsIContent
*
aContent
nsStyleContext
*
aStyleContext
)
;
bool
HasFirstLetterStyle
(
nsIFrame
*
aBlockFrame
)
;
bool
ShouldHaveFirstLineStyle
(
nsIContent
*
aContent
nsStyleContext
*
aStyleContext
)
;
void
ShouldHaveSpecialBlockStyle
(
nsIContent
*
aContent
nsStyleContext
*
aStyleContext
bool
*
aHaveFirstLetterStyle
bool
*
aHaveFirstLineStyle
)
;
void
ConstructBlock
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
nsContainerFrame
*
aParentFrame
nsContainerFrame
*
aContentParentFrame
nsStyleContext
*
aStyleContext
nsContainerFrame
*
*
aNewFrame
nsFrameItems
&
aFrameItems
nsIFrame
*
aPositionedFrameForAbsPosContainer
PendingBinding
*
aPendingBinding
)
;
nsIFrame
*
ConstructInline
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aDisplay
nsFrameItems
&
aFrameItems
)
;
void
CreateIBSiblings
(
nsFrameConstructorState
&
aState
nsContainerFrame
*
aInitialInline
bool
aIsPositioned
nsFrameItems
&
aChildItems
nsFrameItems
&
aSiblings
)
;
void
BuildInlineChildItems
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aParentItem
bool
aItemIsWithinSVGText
bool
aItemAllowsTextPathChild
)
;
bool
WipeContainingBlock
(
nsFrameConstructorState
&
aState
nsIFrame
*
aContainingBlock
nsIFrame
*
aFrame
FrameConstructionItemList
&
aItems
bool
aIsAppend
nsIFrame
*
aPrevSibling
InsertionKind
)
;
void
ReframeContainingBlock
(
nsIFrame
*
aFrame
InsertionKind
aInsertionKind
)
;
nsFirstLetterFrame
*
CreateFloatingLetterFrame
(
nsFrameConstructorState
&
aState
nsIContent
*
aTextContent
nsIFrame
*
aTextFrame
nsContainerFrame
*
aParentFrame
nsStyleContext
*
aParentStyleContext
nsStyleContext
*
aStyleContext
nsFrameItems
&
aResult
)
;
void
CreateLetterFrame
(
nsContainerFrame
*
aBlockFrame
nsContainerFrame
*
aBlockContinuation
nsIContent
*
aTextContent
nsContainerFrame
*
aParentFrame
nsFrameItems
&
aResult
)
;
void
WrapFramesInFirstLetterFrame
(
nsContainerFrame
*
aBlockFrame
nsFrameItems
&
aBlockFrames
)
;
void
WrapFramesInFirstLetterFrame
(
nsContainerFrame
*
aBlockFrame
nsContainerFrame
*
aBlockContinuation
nsContainerFrame
*
aParentFrame
nsIFrame
*
aParentFrameList
nsContainerFrame
*
*
aModifiedParent
nsIFrame
*
*
aTextFrame
nsIFrame
*
*
aPrevFrame
nsFrameItems
&
aLetterFrames
bool
*
aStopLooking
)
;
void
RecoverLetterFrames
(
nsContainerFrame
*
aBlockFrame
)
;
void
RemoveLetterFrames
(
nsIPresShell
*
aPresShell
nsContainerFrame
*
aBlockFrame
)
;
void
RemoveFirstLetterFrames
(
nsIPresShell
*
aPresShell
nsContainerFrame
*
aFrame
nsContainerFrame
*
aBlockFrame
bool
*
aStopLooking
)
;
void
RemoveFloatingFirstLetterFrames
(
nsIPresShell
*
aPresShell
nsIFrame
*
aBlockFrame
)
;
void
CaptureStateForFramesOf
(
nsIContent
*
aContent
nsILayoutHistoryState
*
aHistoryState
)
;
void
WrapFramesInFirstLineFrame
(
nsFrameConstructorState
&
aState
nsIContent
*
aBlockContent
nsContainerFrame
*
aBlockFrame
nsFirstLineFrame
*
aLineFrame
nsFrameItems
&
aFrameItems
)
;
void
AppendFirstLineFrames
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
nsContainerFrame
*
aBlockFrame
nsFrameItems
&
aFrameItems
)
;
void
InsertFirstLineFrames
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
nsIFrame
*
aBlockFrame
nsContainerFrame
*
*
aParentFrame
nsIFrame
*
aPrevSibling
nsFrameItems
&
aFrameItems
)
;
void
CheckForFirstLineInsertion
(
nsIFrame
*
aParentFrame
nsFrameItems
&
aFrameItems
)
;
nsIFrame
*
FindFrameForContentSibling
(
nsIContent
*
aContent
nsIContent
*
aTargetContent
mozilla
:
:
StyleDisplay
&
aTargetContentDisplay
nsContainerFrame
*
aParentFrame
bool
aPrevSibling
)
;
nsIFrame
*
FindPreviousSibling
(
mozilla
:
:
dom
:
:
FlattenedChildIterator
aIter
nsIContent
*
aTargetContent
mozilla
:
:
StyleDisplay
&
aTargetContentDisplay
nsContainerFrame
*
aParentFrame
)
;
nsIFrame
*
FindNextSibling
(
mozilla
:
:
dom
:
:
FlattenedChildIterator
aIter
nsIContent
*
aTargetContent
mozilla
:
:
StyleDisplay
&
aTargetContentDisplay
nsContainerFrame
*
aParentFrame
)
;
nsIFrame
*
GetInsertionPrevSibling
(
InsertionPoint
*
aInsertion
nsIContent
*
aChild
bool
*
aIsAppend
bool
*
aIsRangeInsertSafe
nsIContent
*
aStartSkipChild
=
nullptr
nsIContent
*
aEndSkipChild
=
nullptr
)
;
nsContainerFrame
*
GetContentInsertionFrameFor
(
nsIContent
*
aContent
)
;
bool
IsValidSibling
(
nsIFrame
*
aSibling
nsIContent
*
aContent
mozilla
:
:
StyleDisplay
&
aDisplay
)
;
void
QuotesDirty
(
)
;
void
CountersDirty
(
)
;
void
SetAsUndisplayedContent
(
nsFrameConstructorState
&
aState
FrameConstructionItemList
&
aList
nsIContent
*
aContent
nsStyleContext
*
aStyleContext
bool
aIsGeneratedContent
)
;
void
ConstructAnonymousContentForCanvas
(
nsFrameConstructorState
&
aState
nsIFrame
*
aFrame
nsIContent
*
aDocElement
)
;
public
:
friend
class
nsFrameConstructorState
;
private
:
nsIDocument
*
mDocument
;
nsContainerFrame
*
mRootElementFrame
;
nsIFrame
*
mRootElementStyleFrame
;
nsContainerFrame
*
mDocElementContainingBlock
;
nsIFrame
*
mPageSequenceFrame
;
nsQuoteList
mQuoteList
;
nsCounterManager
mCounterManager
;
uint16_t
mCurrentDepth
;
#
ifdef
DEBUG
uint16_t
mUpdateCount
;
#
endif
bool
mQuotesDirty
:
1
;
bool
mCountersDirty
:
1
;
bool
mIsDestroyingFrameTree
:
1
;
bool
mHasRootAbsPosContainingBlock
:
1
;
bool
mAlwaysCreateFramesForIgnorableWhitespace
:
1
;
nsCOMPtr
<
nsILayoutHistoryState
>
mTempFrameTreeState
;
}
;
#
endif
