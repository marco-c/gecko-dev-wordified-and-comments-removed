#
ifndef
nsCSSFrameConstructor_h___
#
define
nsCSSFrameConstructor_h___
#
include
"
mozilla
/
ArenaAllocator
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
mozilla
/
ScrollStyles
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsILayoutHistoryState
.
h
"
#
include
"
nsQuoteList
.
h
"
#
include
"
nsCounterManager
.
h
"
#
include
"
nsIAnonymousContentCreator
.
h
"
#
include
"
nsFrameManager
.
h
"
struct
nsFrameItems
;
struct
nsStyleDisplay
;
struct
nsGenConInitializer
;
class
nsContainerFrame
;
class
nsFirstLineFrame
;
class
nsFirstLetterFrame
;
class
nsICSSAnonBoxPseudo
;
class
nsIDocument
;
class
nsPageContentFrame
;
struct
PendingBinding
;
class
nsFrameConstructorState
;
namespace
mozilla
{
class
ComputedStyle
;
namespace
dom
{
class
CharacterData
;
class
FlattenedChildIterator
;
}
}
class
nsCSSFrameConstructor
final
:
public
nsFrameManager
{
public
:
typedef
mozilla
:
:
ComputedStyle
ComputedStyle
;
typedef
mozilla
:
:
CSSPseudoElementType
CSSPseudoElementType
;
typedef
mozilla
:
:
dom
:
:
Element
Element
;
friend
class
mozilla
:
:
RestyleManager
;
nsCSSFrameConstructor
(
nsIDocument
*
aDocument
nsIPresShell
*
aPresShell
)
;
~
nsCSSFrameConstructor
(
)
{
MOZ_ASSERT
(
mFCItemsInUse
=
=
0
)
;
}
static
void
GetAlternateTextFor
(
Element
*
aContent
nsAtom
*
aTag
nsAString
&
aAltText
)
;
private
:
nsCSSFrameConstructor
(
const
nsCSSFrameConstructor
&
aCopy
)
=
delete
;
nsCSSFrameConstructor
&
operator
=
(
const
nsCSSFrameConstructor
&
aCopy
)
=
delete
;
public
:
enum
class
InsertionKind
{
Sync
Async
}
;
mozilla
:
:
RestyleManager
*
RestyleManager
(
)
const
{
return
mPresShell
-
>
GetPresContext
(
)
-
>
RestyleManager
(
)
;
}
nsIFrame
*
ConstructRootFrame
(
)
;
void
ReconstructDocElementHierarchy
(
InsertionKind
)
;
private
:
enum
Operation
{
CONTENTAPPEND
CONTENTINSERT
}
;
bool
MaybeConstructLazily
(
Operation
aOperation
nsIContent
*
aChild
)
;
#
ifdef
DEBUG
void
CheckBitsForLazyFrameConstruction
(
nsIContent
*
aParent
)
;
#
else
void
CheckBitsForLazyFrameConstruction
(
nsIContent
*
)
{
}
#
endif
void
IssueSingleInsertNofications
(
nsIContent
*
aStartChild
nsIContent
*
aEndChild
InsertionKind
)
;
struct
InsertionPoint
{
InsertionPoint
(
)
:
mParentFrame
(
nullptr
)
mContainer
(
nullptr
)
{
}
InsertionPoint
(
nsContainerFrame
*
aParentFrame
nsIContent
*
aContainer
)
:
mParentFrame
(
aParentFrame
)
mContainer
(
aContainer
)
{
}
nsContainerFrame
*
mParentFrame
;
nsIContent
*
mContainer
;
bool
IsMultiple
(
)
const
;
}
;
InsertionPoint
GetRangeInsertionPoint
(
nsIContent
*
aStartChild
nsIContent
*
aEndChild
InsertionKind
)
;
bool
MaybeRecreateForFrameset
(
nsIFrame
*
aParentFrame
nsIContent
*
aStartChild
nsIContent
*
aEndChild
)
;
void
LazilyStyleNewChildRange
(
nsIContent
*
aStartChild
nsIContent
*
aEndChild
)
;
void
StyleNewChildRange
(
nsIContent
*
aStartChild
nsIContent
*
aEndChild
)
;
public
:
void
ContentAppended
(
nsIContent
*
aFirstNewContent
InsertionKind
)
;
void
ContentInserted
(
nsIContent
*
aChild
nsILayoutHistoryState
*
aFrameState
InsertionKind
aInsertionKind
)
;
void
ContentRangeInserted
(
nsIContent
*
aStartChild
nsIContent
*
aEndChild
nsILayoutHistoryState
*
aFrameState
InsertionKind
aInsertionKind
)
;
enum
RemoveFlags
{
REMOVE_CONTENT
REMOVE_FOR_RECONSTRUCTION
}
;
bool
ContentRemoved
(
nsIContent
*
aChild
nsIContent
*
aOldNextSibling
RemoveFlags
aFlags
)
;
void
CharacterDataChanged
(
nsIContent
*
aContent
const
CharacterDataChangeInfo
&
aInfo
)
;
bool
EnsureFrameForTextNodeIsCreatedAfterFlush
(
mozilla
:
:
dom
:
:
CharacterData
*
aContent
)
;
void
GenerateChildFrames
(
nsContainerFrame
*
aFrame
)
;
void
NotifyDestroyingFrame
(
nsIFrame
*
aFrame
)
;
void
RecalcQuotesAndCounters
(
)
;
void
NotifyCounterStylesAreDirty
(
)
;
void
WillDestroyFrameTree
(
)
;
bool
DestroyFramesFor
(
Element
*
aElement
)
;
nsIFrame
*
CreateContinuingFrame
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
nsContainerFrame
*
aParentFrame
bool
aIsFluid
=
true
)
;
nsresult
ReplicateFixedFrames
(
nsPageContentFrame
*
aParentFrame
)
;
InsertionPoint
GetInsertionPoint
(
nsIContent
*
aChild
)
;
nsContainerFrame
*
GetContentInsertionFrameFor
(
nsIContent
*
aContent
)
;
nsContainerFrame
*
GetRootElementFrame
(
)
{
return
mRootElementFrame
;
}
nsIFrame
*
GetRootElementStyleFrame
(
)
{
return
mRootElementStyleFrame
;
}
nsIFrame
*
GetPageSequenceFrame
(
)
{
return
mPageSequenceFrame
;
}
nsContainerFrame
*
GetDocElementContainingBlock
(
)
{
return
mDocElementContainingBlock
;
}
void
AddSizeOfIncludingThis
(
nsWindowSizes
&
aSizes
)
const
;
private
:
struct
FrameConstructionItem
;
class
FrameConstructionItemList
;
nsContainerFrame
*
ConstructPageFrame
(
nsIPresShell
*
aPresShell
nsContainerFrame
*
aParentFrame
nsIFrame
*
aPrevPageFrame
nsContainerFrame
*
&
aCanvasFrame
)
;
void
InitAndRestoreFrame
(
const
nsFrameConstructorState
&
aState
nsIContent
*
aContent
nsContainerFrame
*
aParentFrame
nsIFrame
*
aNewFrame
bool
aAllowCounters
=
true
)
;
already_AddRefed
<
ComputedStyle
>
ResolveComputedStyle
(
nsIContent
*
aContent
)
;
void
AddFrameConstructionItems
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
bool
aSuppressWhiteSpaceOptimizations
const
InsertionPoint
&
aInsertion
FrameConstructionItemList
&
aItems
)
;
bool
ShouldCreateItemsForChild
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
nsContainerFrame
*
aParentFrame
)
;
void
DoAddFrameConstructionItems
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
ComputedStyle
*
aComputedStyle
bool
aSuppressWhiteSpaceOptimizations
nsContainerFrame
*
aParentFrame
FrameConstructionItemList
&
aItems
)
;
nsIFrame
*
ConstructDocElementFrame
(
Element
*
aDocElement
nsILayoutHistoryState
*
aFrameState
)
;
void
SetUpDocElementContainingBlock
(
nsIContent
*
aDocElement
)
;
void
CreateAttributeContent
(
const
Element
&
aParentContent
nsIFrame
*
aParentFrame
int32_t
aAttrNamespace
nsAtom
*
aAttrName
ComputedStyle
*
aComputedStyle
nsCOMArray
<
nsIContent
>
&
aGeneratedContent
nsIContent
*
*
aNewContent
nsIFrame
*
*
aNewFrame
)
;
already_AddRefed
<
nsIContent
>
CreateGenConTextNode
(
nsFrameConstructorState
&
aState
const
nsString
&
aString
RefPtr
<
nsTextNode
>
*
aText
nsGenConInitializer
*
aInitializer
)
;
already_AddRefed
<
nsIContent
>
CreateGeneratedContent
(
nsFrameConstructorState
&
aState
const
Element
&
aOriginatingElement
ComputedStyle
&
aComputedStyle
uint32_t
aContentIndex
)
;
void
CreateGeneratedContentItem
(
nsFrameConstructorState
&
aState
nsContainerFrame
*
aParentFrame
Element
&
aOriginatingElement
ComputedStyle
&
CSSPseudoElementType
aPseudoElement
FrameConstructionItemList
&
aItems
)
;
void
AppendFramesToParent
(
nsFrameConstructorState
&
aState
nsContainerFrame
*
aParentFrame
nsFrameItems
&
aFrameList
nsIFrame
*
aPrevSibling
bool
aIsRecursiveCall
=
false
)
;
nsIFrame
*
ConstructTable
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aDisplay
nsFrameItems
&
aFrameItems
)
;
nsIFrame
*
ConstructTableRowOrRowGroup
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aStyleDisplay
nsFrameItems
&
aFrameItems
)
;
nsIFrame
*
ConstructTableCol
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aStyleDisplay
nsFrameItems
&
aFrameItems
)
;
nsIFrame
*
ConstructTableCell
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aStyleDisplay
nsFrameItems
&
aFrameItems
)
;
private
:
enum
ParentType
{
eTypeBlock
=
0
eTypeRow
eTypeRowGroup
eTypeColGroup
eTypeTable
eTypeRuby
eTypeRubyBase
eTypeRubyBaseContainer
eTypeRubyText
eTypeRubyTextContainer
eParentTypeCount
}
;
#
define
FCDATA_PARENT_TYPE_OFFSET
28
#
define
FCDATA_DESIRED_PARENT_TYPE
(
_bits
)
\
ParentType
(
(
_bits
)
>
>
FCDATA_PARENT_TYPE_OFFSET
)
#
define
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
_type
)
\
(
(
(
uint32_t
)
(
_type
)
)
<
<
FCDATA_PARENT_TYPE_OFFSET
)
static
ParentType
GetParentType
(
nsIFrame
*
aParentFrame
)
{
return
GetParentType
(
aParentFrame
-
>
Type
(
)
)
;
}
static
ParentType
GetParentType
(
mozilla
:
:
LayoutFrameType
aFrameType
)
;
static
bool
IsRubyParentType
(
ParentType
aParentType
)
{
return
(
aParentType
=
=
eTypeRuby
|
|
aParentType
=
=
eTypeRubyBase
|
|
aParentType
=
=
eTypeRubyBaseContainer
|
|
aParentType
=
=
eTypeRubyText
|
|
aParentType
=
=
eTypeRubyTextContainer
)
;
}
static
bool
IsTableParentType
(
ParentType
aParentType
)
{
return
(
aParentType
=
=
eTypeTable
|
|
aParentType
=
=
eTypeRow
|
|
aParentType
=
=
eTypeRowGroup
|
|
aParentType
=
=
eTypeColGroup
)
;
}
typedef
nsIFrame
*
(
*
FrameCreationFunc
)
(
nsIPresShell
*
ComputedStyle
*
)
;
typedef
nsContainerFrame
*
(
*
ContainerFrameCreationFunc
)
(
nsIPresShell
*
ComputedStyle
*
)
;
typedef
nsBlockFrame
*
(
*
BlockFrameCreationFunc
)
(
nsIPresShell
*
ComputedStyle
*
)
;
struct
FrameConstructionData
;
typedef
const
FrameConstructionData
*
(
*
FrameConstructionDataGetter
)
(
const
Element
&
ComputedStyle
&
)
;
typedef
nsIFrame
*
(
nsCSSFrameConstructor
:
:
*
FrameFullConstructor
)
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aStyleDisplay
nsFrameItems
&
aFrameItems
)
;
#
define
FCDATA_SKIP_FRAMESET
0x1
#
define
FCDATA_FUNC_IS_DATA_GETTER
0x2
#
define
FCDATA_FUNC_IS_FULL_CTOR
0x4
#
define
FCDATA_DISALLOW_OUT_OF_FLOW
0x8
#
define
FCDATA_FORCE_NULL_ABSPOS_CONTAINER
0x10
#
define
FCDATA_WRAP_KIDS_IN_BLOCKS
0x20
#
define
FCDATA_SUPPRESS_FRAME
0x40
#
define
FCDATA_MAY_NEED_SCROLLFRAME
0x80
#
ifdef
MOZ_XUL
#
define
FCDATA_IS_POPUP
0x100
#
endif
#
define
FCDATA_SKIP_ABSPOS_PUSH
0x200
#
define
FCDATA_DISALLOW_GENERATED_CONTENT
0x400
#
define
FCDATA_IS_TABLE_PART
0x800
#
define
FCDATA_IS_INLINE
0x1000
#
define
FCDATA_IS_LINE_PARTICIPANT
0x2000
#
define
FCDATA_IS_LINE_BREAK
0x4000
#
define
FCDATA_ALLOW_BLOCK_STYLES
0x8000
#
define
FCDATA_USE_CHILD_ITEMS
0x10000
#
define
FCDATA_FORCED_NON_SCROLLABLE_BLOCK
0x20000
#
define
FCDATA_CREATE_BLOCK_WRAPPER_FOR_ALL_KIDS
0x40000
#
define
FCDATA_IS_SVG_TEXT
0x80000
#
define
FCDATA_ALLOW_GRID_FLEX_COLUMNSET
0x200000
#
define
FCDATA_IS_WRAPPER_ANON_BOX
0x400000
struct
FrameConstructionData
{
uint32_t
mBits
;
union
Func
{
FrameCreationFunc
mCreationFunc
;
FrameConstructionDataGetter
mDataGetter
;
}
mFunc
;
FrameFullConstructor
mFullConstructor
;
nsICSSAnonBoxPseudo
*
const
*
const
mAnonBoxPseudo
;
}
;
struct
FrameConstructionDataByTag
{
const
nsStaticAtom
*
const
*
const
mTag
;
const
FrameConstructionData
mData
;
}
;
struct
FrameConstructionDataByInt
{
const
int32_t
mInt
;
const
FrameConstructionData
mData
;
}
;
struct
FrameConstructionDataByDisplay
{
#
ifdef
DEBUG
const
mozilla
:
:
StyleDisplay
mDisplay
;
#
endif
const
FrameConstructionData
mData
;
}
;
#
ifdef
DEBUG
#
define
FCDATA_FOR_DISPLAY
(
_display
_fcdata
)
\
{
_display
_fcdata
}
#
else
#
define
FCDATA_FOR_DISPLAY
(
_display
_fcdata
)
\
{
_fcdata
}
#
endif
struct
PseudoParentData
{
const
FrameConstructionData
mFCData
;
nsICSSAnonBoxPseudo
*
const
*
const
mPseudoType
;
}
;
static
const
PseudoParentData
sPseudoParentData
[
eParentTypeCount
]
;
struct
MOZ_STACK_CLASS
XBLBindingLoadInfo
{
RefPtr
<
ComputedStyle
>
mStyle
;
mozilla
:
:
UniquePtr
<
PendingBinding
>
mPendingBinding
;
nsAtom
*
mTag
=
nullptr
;
XBLBindingLoadInfo
(
nsIContent
&
ComputedStyle
&
)
;
XBLBindingLoadInfo
(
already_AddRefed
<
ComputedStyle
>
aStyle
mozilla
:
:
UniquePtr
<
PendingBinding
>
aPendingBinding
nsAtom
*
aTag
)
;
XBLBindingLoadInfo
(
)
;
}
;
XBLBindingLoadInfo
LoadXBLBindingIfNeeded
(
nsIContent
&
ComputedStyle
&
uint32_t
aFlags
)
;
static
const
FrameConstructionData
*
FindDataByInt
(
int32_t
aInt
const
Element
&
ComputedStyle
&
const
FrameConstructionDataByInt
*
aDataPtr
uint32_t
aDataLength
)
;
static
const
FrameConstructionData
*
FindDataByTag
(
nsAtom
*
aTag
const
Element
&
aElement
ComputedStyle
&
aComputedStyle
const
FrameConstructionDataByTag
*
aDataPtr
uint32_t
aDataLength
)
;
class
FrameConstructionItemList
{
public
:
void
Reset
(
nsCSSFrameConstructor
*
aFCtor
)
{
Destroy
(
aFCtor
)
;
this
-
>
~
FrameConstructionItemList
(
)
;
new
(
this
)
FrameConstructionItemList
(
)
;
}
void
SetLineBoundaryAtStart
(
bool
aBoundary
)
{
mLineBoundaryAtStart
=
aBoundary
;
}
void
SetLineBoundaryAtEnd
(
bool
aBoundary
)
{
mLineBoundaryAtEnd
=
aBoundary
;
}
void
SetParentHasNoXBLChildren
(
bool
aHasNoXBLChildren
)
{
mParentHasNoXBLChildren
=
aHasNoXBLChildren
;
}
bool
HasLineBoundaryAtStart
(
)
{
return
mLineBoundaryAtStart
;
}
bool
HasLineBoundaryAtEnd
(
)
{
return
mLineBoundaryAtEnd
;
}
bool
ParentHasNoXBLChildren
(
)
{
return
mParentHasNoXBLChildren
;
}
bool
IsEmpty
(
)
const
{
return
mItems
.
isEmpty
(
)
;
}
bool
AnyItemsNeedBlockParent
(
)
const
{
return
mLineParticipantCount
!
=
0
;
}
bool
AreAllItemsInline
(
)
const
{
return
mInlineCount
=
=
mItemCount
;
}
bool
AreAllItemsBlock
(
)
const
{
return
mBlockCount
=
=
mItemCount
;
}
bool
AllWantParentType
(
ParentType
aDesiredParentType
)
const
{
return
mDesiredParentCounts
[
aDesiredParentType
]
=
=
mItemCount
;
}
FrameConstructionItem
*
AppendItem
(
nsCSSFrameConstructor
*
aFCtor
const
FrameConstructionData
*
aFCData
nsIContent
*
aContent
PendingBinding
*
aPendingBinding
already_AddRefed
<
ComputedStyle
>
&
&
aComputedStyle
bool
aSuppressWhiteSpaceOptimizations
)
{
FrameConstructionItem
*
item
=
new
(
aFCtor
)
FrameConstructionItem
(
aFCData
aContent
aPendingBinding
aComputedStyle
aSuppressWhiteSpaceOptimizations
)
;
mItems
.
insertBack
(
item
)
;
+
+
mItemCount
;
+
+
mDesiredParentCounts
[
item
-
>
DesiredParentType
(
)
]
;
return
item
;
}
FrameConstructionItem
*
PrependItem
(
nsCSSFrameConstructor
*
aFCtor
const
FrameConstructionData
*
aFCData
nsIContent
*
aContent
PendingBinding
*
aPendingBinding
already_AddRefed
<
ComputedStyle
>
&
&
aComputedStyle
bool
aSuppressWhiteSpaceOptimizations
)
{
FrameConstructionItem
*
item
=
new
(
aFCtor
)
FrameConstructionItem
(
aFCData
aContent
aPendingBinding
aComputedStyle
aSuppressWhiteSpaceOptimizations
)
;
mItems
.
insertFront
(
item
)
;
+
+
mItemCount
;
+
+
mDesiredParentCounts
[
item
-
>
DesiredParentType
(
)
]
;
return
item
;
}
void
InlineItemAdded
(
)
{
+
+
mInlineCount
;
}
void
BlockItemAdded
(
)
{
+
+
mBlockCount
;
}
void
LineParticipantItemAdded
(
)
{
+
+
mLineParticipantCount
;
}
class
Iterator
{
public
:
explicit
Iterator
(
FrameConstructionItemList
&
aList
)
:
mCurrent
(
aList
.
mItems
.
getFirst
(
)
)
mList
(
aList
)
{
}
Iterator
(
const
Iterator
&
aOther
)
:
mCurrent
(
aOther
.
mCurrent
)
mList
(
aOther
.
mList
)
{
}
bool
operator
=
=
(
const
Iterator
&
aOther
)
const
{
MOZ_ASSERT
(
&
mList
=
=
&
aOther
.
mList
"
Iterators
for
different
lists
?
"
)
;
return
mCurrent
=
=
aOther
.
mCurrent
;
}
bool
operator
!
=
(
const
Iterator
&
aOther
)
const
{
return
!
(
*
this
=
=
aOther
)
;
}
Iterator
&
operator
=
(
const
Iterator
&
aOther
)
{
MOZ_ASSERT
(
&
mList
=
=
&
aOther
.
mList
"
Iterators
for
different
lists
?
"
)
;
mCurrent
=
aOther
.
mCurrent
;
return
*
this
;
}
FrameConstructionItemList
*
List
(
)
{
return
&
mList
;
}
FrameConstructionItem
&
item
(
)
{
MOZ_ASSERT
(
!
IsDone
(
)
"
Should
have
checked
IsDone
(
)
!
"
)
;
return
*
mCurrent
;
}
const
FrameConstructionItem
&
item
(
)
const
{
MOZ_ASSERT
(
!
IsDone
(
)
"
Should
have
checked
IsDone
(
)
!
"
)
;
return
*
mCurrent
;
}
bool
IsDone
(
)
const
{
return
mCurrent
=
=
nullptr
;
}
bool
AtStart
(
)
const
{
return
mCurrent
=
=
mList
.
mItems
.
getFirst
(
)
;
}
void
Next
(
)
{
NS_ASSERTION
(
!
IsDone
(
)
"
Should
have
checked
IsDone
(
)
!
"
)
;
mCurrent
=
mCurrent
-
>
getNext
(
)
;
}
void
Prev
(
)
{
NS_ASSERTION
(
!
AtStart
(
)
"
Should
have
checked
AtStart
(
)
!
"
)
;
mCurrent
=
mCurrent
?
mCurrent
-
>
getPrevious
(
)
:
mList
.
mItems
.
getLast
(
)
;
}
void
SetToEnd
(
)
{
mCurrent
=
nullptr
;
}
inline
bool
SkipItemsWantingParentType
(
ParentType
aParentType
)
;
inline
bool
SkipItemsNotWantingParentType
(
ParentType
aParentType
)
;
inline
bool
SkipItemsThatNeedAnonFlexOrGridItem
(
const
nsFrameConstructorState
&
aState
bool
aIsWebkitBox
)
;
inline
bool
SkipItemsThatDontNeedAnonFlexOrGridItem
(
const
nsFrameConstructorState
&
aState
bool
aIsWebkitBox
)
;
inline
bool
SkipItemsNotWantingRubyParent
(
)
;
inline
bool
SkipWhitespace
(
nsFrameConstructorState
&
aState
)
;
void
AppendItemToList
(
FrameConstructionItemList
&
aTargetList
)
;
void
AppendItemsToList
(
nsCSSFrameConstructor
*
aFCtor
const
Iterator
&
aEnd
FrameConstructionItemList
&
aTargetList
)
;
void
InsertItem
(
FrameConstructionItem
*
aItem
)
;
void
DeleteItemsTo
(
nsCSSFrameConstructor
*
aFCtor
const
Iterator
&
aEnd
)
;
private
:
FrameConstructionItem
*
mCurrent
;
FrameConstructionItemList
&
mList
;
}
;
protected
:
FrameConstructionItemList
(
)
:
mInlineCount
(
0
)
mBlockCount
(
0
)
mLineParticipantCount
(
0
)
mItemCount
(
0
)
mLineBoundaryAtStart
(
false
)
mLineBoundaryAtEnd
(
false
)
mParentHasNoXBLChildren
(
false
)
{
MOZ_COUNT_CTOR
(
FrameConstructionItemList
)
;
memset
(
mDesiredParentCounts
0
sizeof
(
mDesiredParentCounts
)
)
;
}
void
Destroy
(
nsCSSFrameConstructor
*
aFCtor
)
{
while
(
FrameConstructionItem
*
item
=
mItems
.
popFirst
(
)
)
{
item
-
>
Delete
(
aFCtor
)
;
}
}
friend
struct
FrameConstructionItem
;
~
FrameConstructionItemList
(
)
{
MOZ_COUNT_DTOR
(
FrameConstructionItemList
)
;
MOZ_ASSERT
(
mItems
.
isEmpty
(
)
"
leaking
"
)
;
}
private
:
void
*
operator
new
(
size_t
)
=
delete
;
void
*
operator
new
[
]
(
size_t
)
=
delete
;
#
ifdef
_MSC_VER
void
operator
delete
(
void
*
)
{
MOZ_CRASH
(
"
FrameConstructionItemList
:
:
del
"
)
;
}
#
else
void
operator
delete
(
void
*
)
=
delete
;
#
endif
void
operator
delete
[
]
(
void
*
)
=
delete
;
void
*
operator
new
(
size_t
void
*
aPtr
)
{
return
aPtr
;
}
struct
UndisplayedItem
{
UndisplayedItem
(
nsIContent
*
aContent
ComputedStyle
*
aComputedStyle
)
:
mContent
(
aContent
)
mComputedStyle
(
aComputedStyle
)
{
}
nsIContent
*
const
mContent
;
RefPtr
<
ComputedStyle
>
mComputedStyle
;
}
;
void
AdjustCountsForItem
(
FrameConstructionItem
*
aItem
int32_t
aDelta
)
;
mozilla
:
:
LinkedList
<
FrameConstructionItem
>
mItems
;
uint32_t
mInlineCount
;
uint32_t
mBlockCount
;
uint32_t
mLineParticipantCount
;
uint32_t
mItemCount
;
uint32_t
mDesiredParentCounts
[
eParentTypeCount
]
;
bool
mLineBoundaryAtStart
;
bool
mLineBoundaryAtEnd
;
bool
mParentHasNoXBLChildren
;
}
;
struct
MOZ_RAII
AutoFrameConstructionItemList
final
:
public
FrameConstructionItemList
{
template
<
typename
.
.
.
Args
>
explicit
AutoFrameConstructionItemList
(
nsCSSFrameConstructor
*
aFCtor
Args
&
&
.
.
.
args
)
:
FrameConstructionItemList
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
mFCtor
(
aFCtor
)
{
MOZ_ASSERT
(
mFCtor
)
;
}
~
AutoFrameConstructionItemList
(
)
{
Destroy
(
mFCtor
)
;
}
private
:
nsCSSFrameConstructor
*
const
mFCtor
;
}
;
typedef
FrameConstructionItemList
:
:
Iterator
FCItemIterator
;
struct
FrameConstructionItem
final
:
public
mozilla
:
:
LinkedListElement
<
FrameConstructionItem
>
{
FrameConstructionItem
(
const
FrameConstructionData
*
aFCData
nsIContent
*
aContent
PendingBinding
*
aPendingBinding
already_AddRefed
<
ComputedStyle
>
&
aComputedStyle
bool
aSuppressWhiteSpaceOptimizations
)
:
mFCData
(
aFCData
)
mContent
(
aContent
)
mPendingBinding
(
aPendingBinding
)
mComputedStyle
(
aComputedStyle
)
mSuppressWhiteSpaceOptimizations
(
aSuppressWhiteSpaceOptimizations
)
mIsText
(
false
)
mIsGeneratedContent
(
false
)
mIsAnonymousContentCreatorContent
(
false
)
mIsRootPopupgroup
(
false
)
mIsAllInline
(
false
)
mIsBlock
(
false
)
mHasInlineEnds
(
false
)
mIsPopup
(
false
)
mIsLineParticipant
(
false
)
mIsForSVGAElement
(
false
)
{
MOZ_COUNT_CTOR
(
FrameConstructionItem
)
;
}
void
*
operator
new
(
size_t
nsCSSFrameConstructor
*
aFCtor
)
{
return
aFCtor
-
>
AllocateFCItem
(
)
;
}
void
Delete
(
nsCSSFrameConstructor
*
aFCtor
)
{
mChildItems
.
Destroy
(
aFCtor
)
;
if
(
mIsGeneratedContent
)
{
mContent
-
>
UnbindFromTree
(
)
;
NS_RELEASE
(
mContent
)
;
}
this
-
>
~
FrameConstructionItem
(
)
;
aFCtor
-
>
FreeFCItem
(
this
)
;
}
ParentType
DesiredParentType
(
)
{
return
FCDATA_DESIRED_PARENT_TYPE
(
mFCData
-
>
mBits
)
;
}
bool
NeedsAnonFlexOrGridItem
(
const
nsFrameConstructorState
&
aState
bool
aIsWebkitBox
)
;
bool
IsWhitespace
(
nsFrameConstructorState
&
aState
)
const
;
bool
IsLineBoundary
(
)
const
{
return
mIsBlock
|
|
(
mFCData
-
>
mBits
&
FCDATA_IS_LINE_BREAK
)
;
}
FrameConstructionItemList
mChildItems
;
const
FrameConstructionData
*
mFCData
;
nsIContent
*
mContent
;
PendingBinding
*
mPendingBinding
;
RefPtr
<
ComputedStyle
>
mComputedStyle
;
bool
mSuppressWhiteSpaceOptimizations
:
1
;
bool
mIsText
:
1
;
bool
mIsGeneratedContent
:
1
;
bool
mIsAnonymousContentCreatorContent
:
1
;
bool
mIsRootPopupgroup
:
1
;
bool
mIsAllInline
:
1
;
bool
mIsBlock
:
1
;
bool
mHasInlineEnds
:
1
;
bool
mIsPopup
:
1
;
bool
mIsLineParticipant
:
1
;
bool
mIsForSVGAElement
:
1
;
private
:
void
*
operator
new
(
size_t
)
=
delete
;
void
*
operator
new
[
]
(
size_t
)
=
delete
;
#
ifdef
_MSC_VER
void
operator
delete
(
void
*
)
{
MOZ_CRASH
(
"
FrameConstructionItem
:
:
delete
"
)
;
}
#
else
void
operator
delete
(
void
*
)
=
delete
;
#
endif
void
operator
delete
[
]
(
void
*
)
=
delete
;
FrameConstructionItem
(
const
FrameConstructionItem
&
aOther
)
=
delete
;
~
FrameConstructionItem
(
)
{
MOZ_COUNT_DTOR
(
FrameConstructionItem
)
;
MOZ_ASSERT
(
mChildItems
.
IsEmpty
(
)
"
leaking
"
)
;
}
}
;
struct
MOZ_RAII
AutoFrameConstructionItem
final
{
template
<
typename
.
.
.
Args
>
explicit
AutoFrameConstructionItem
(
nsCSSFrameConstructor
*
aFCtor
Args
&
&
.
.
.
args
)
:
mFCtor
(
aFCtor
)
mItem
(
new
(
aFCtor
)
FrameConstructionItem
(
std
:
:
forward
<
Args
>
(
args
)
.
.
.
)
)
{
MOZ_ASSERT
(
mFCtor
)
;
}
~
AutoFrameConstructionItem
(
)
{
mItem
-
>
Delete
(
mFCtor
)
;
}
operator
FrameConstructionItem
&
(
)
{
return
*
mItem
;
}
private
:
nsCSSFrameConstructor
*
const
mFCtor
;
FrameConstructionItem
*
const
mItem
;
}
;
void
CreateNeededAnonFlexOrGridItems
(
nsFrameConstructorState
&
aState
FrameConstructionItemList
&
aItems
nsIFrame
*
aParentFrame
)
;
enum
RubyWhitespaceType
{
eRubyNotWhitespace
eRubyInterLevelWhitespace
eRubyInterLeafWhitespace
eRubyInterSegmentWhitespace
}
;
static
inline
RubyWhitespaceType
ComputeRubyWhitespaceType
(
mozilla
:
:
StyleDisplay
aPrevDisplay
mozilla
:
:
StyleDisplay
aNextDisplay
)
;
static
inline
RubyWhitespaceType
InterpretRubyWhitespace
(
nsFrameConstructorState
&
aState
const
FCItemIterator
&
aStartIter
const
FCItemIterator
&
aEndIter
)
;
void
WrapItemsInPseudoRubyLeafBox
(
FCItemIterator
&
aIter
ComputedStyle
*
aParentStyle
nsIContent
*
aParentContent
)
;
inline
void
WrapItemsInPseudoRubyLevelContainer
(
nsFrameConstructorState
&
aState
FCItemIterator
&
aIter
ComputedStyle
*
aParentStyle
nsIContent
*
aParentContent
)
;
inline
void
TrimLeadingAndTrailingWhitespaces
(
nsFrameConstructorState
&
aState
FrameConstructionItemList
&
aItems
)
;
inline
void
CreateNeededPseudoInternalRubyBoxes
(
nsFrameConstructorState
&
aState
FrameConstructionItemList
&
aItems
nsIFrame
*
aParentFrame
)
;
inline
void
CreateNeededPseudoContainers
(
nsFrameConstructorState
&
aState
FrameConstructionItemList
&
aItems
nsIFrame
*
aParentFrame
)
;
inline
void
WrapItemsInPseudoParent
(
nsIContent
*
aParentContent
ComputedStyle
*
aParentStyle
ParentType
aWrapperType
FCItemIterator
&
aIter
const
FCItemIterator
&
aEndIter
)
;
inline
void
CreateNeededPseudoSiblings
(
nsFrameConstructorState
&
aState
FrameConstructionItemList
&
aItems
nsIFrame
*
aParentFrame
)
;
void
AdjustParentFrame
(
nsContainerFrame
*
*
aParentFrame
const
FrameConstructionData
*
aFCData
ComputedStyle
*
aComputedStyle
)
;
protected
:
static
nsIFrame
*
CreatePlaceholderFrameFor
(
nsIPresShell
*
aPresShell
nsIContent
*
aContent
nsIFrame
*
aFrame
nsContainerFrame
*
aParentFrame
nsIFrame
*
aPrevInFlow
nsFrameState
aTypeBit
)
;
static
nsIFrame
*
CreateBackdropFrameFor
(
nsIPresShell
*
aPresShell
nsIContent
*
aContent
nsIFrame
*
aFrame
nsContainerFrame
*
aParentFrame
)
;
private
:
nsIFrame
*
ConstructSelectFrame
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aStyleDisplay
nsFrameItems
&
aFrameItems
)
;
nsIFrame
*
ConstructFieldSetFrame
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aStyleDisplay
nsFrameItems
&
aFrameItems
)
;
nsIFrame
*
ConstructDetailsFrame
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aStyleDisplay
nsFrameItems
&
aFrameItems
)
;
static
const
FrameConstructionData
*
FindTextData
(
nsIFrame
*
aParentFrame
nsIContent
*
aTextContent
)
;
void
ConstructTextFrame
(
const
FrameConstructionData
*
aData
nsFrameConstructorState
&
aState
nsIContent
*
aContent
nsContainerFrame
*
aParentFrame
ComputedStyle
*
aComputedStyle
nsFrameItems
&
aFrameItems
)
;
void
AddTextItemIfNeeded
(
nsFrameConstructorState
&
aState
const
InsertionPoint
&
aInsertion
nsIContent
*
aPossibleTextContent
FrameConstructionItemList
&
aItems
)
;
void
ReframeTextIfNeeded
(
nsIContent
*
aContent
)
;
void
AddPageBreakItem
(
nsIContent
*
aContent
FrameConstructionItemList
&
aItems
)
;
static
const
FrameConstructionData
*
FindHTMLData
(
const
Element
&
nsIFrame
*
aParentFrame
ComputedStyle
&
)
;
static
const
FrameConstructionData
*
FindImgData
(
const
Element
&
ComputedStyle
&
)
;
static
const
FrameConstructionData
*
FindGeneratedImageData
(
const
Element
&
ComputedStyle
&
)
;
static
const
FrameConstructionData
*
FindImgControlData
(
const
Element
&
ComputedStyle
&
)
;
static
const
FrameConstructionData
*
FindInputData
(
const
Element
&
ComputedStyle
&
)
;
static
const
FrameConstructionData
*
FindObjectData
(
const
Element
&
ComputedStyle
&
)
;
static
const
FrameConstructionData
*
FindCanvasData
(
const
Element
&
ComputedStyle
&
)
;
void
ConstructFrameFromItemInternal
(
FrameConstructionItem
&
aItem
nsFrameConstructorState
&
aState
nsContainerFrame
*
aParentFrame
nsFrameItems
&
aFrameItems
)
;
#
define
ITEM_ALLOW_XBL_BASE
0x1
#
define
ITEM_ALLOW_PAGE_BREAK
0x2
#
define
ITEM_IS_GENERATED_CONTENT
0x4
#
define
ITEM_IS_WITHIN_SVG_TEXT
0x8
#
define
ITEM_ALLOWS_TEXT_PATH_CHILD
0x10
#
define
ITEM_IS_ANONYMOUSCONTENTCREATOR_CONTENT
0x20
void
AddFrameConstructionItemsInternal
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
nsContainerFrame
*
aParentFrame
bool
aSuppressWhiteSpaceOptimizations
ComputedStyle
*
aComputedStyle
uint32_t
aFlags
FrameConstructionItemList
&
aItems
)
;
void
ConstructFramesFromItemList
(
nsFrameConstructorState
&
aState
FrameConstructionItemList
&
aItems
nsContainerFrame
*
aParentFrame
bool
aParentIsWrapperAnonBox
nsFrameItems
&
aFrameItems
)
;
void
ConstructFramesFromItem
(
nsFrameConstructorState
&
aState
FCItemIterator
&
aItem
nsContainerFrame
*
aParentFrame
nsFrameItems
&
aFrameItems
)
;
static
bool
AtLineBoundary
(
FCItemIterator
&
aIter
)
;
nsresult
GetAnonymousContent
(
nsIContent
*
aParent
nsIFrame
*
aParentFrame
nsTArray
<
nsIAnonymousContentCreator
:
:
ContentInfo
>
&
aAnonContent
)
;
void
FlushAccumulatedBlock
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
nsContainerFrame
*
aParentFrame
nsFrameItems
&
aBlockItems
nsFrameItems
&
aNewItems
)
;
static
const
FrameConstructionData
*
FindMathMLData
(
const
Element
&
ComputedStyle
&
)
;
static
const
FrameConstructionData
*
FindXULTagData
(
const
Element
&
nsAtom
*
aTag
int32_t
aNameSpaceID
ComputedStyle
&
)
;
#
ifdef
MOZ_XUL
static
const
FrameConstructionData
*
FindPopupGroupData
(
const
Element
&
ComputedStyle
&
)
;
static
const
FrameConstructionData
sXULTextBoxData
;
static
const
FrameConstructionData
*
FindXULLabelData
(
const
Element
&
ComputedStyle
&
)
;
static
const
FrameConstructionData
*
FindXULDescriptionData
(
const
Element
&
ComputedStyle
&
)
;
#
ifdef
XP_MACOSX
static
const
FrameConstructionData
*
FindXULMenubarData
(
const
Element
&
ComputedStyle
&
)
;
#
endif
#
endif
static
const
FrameConstructionData
*
FindXULDisplayData
(
const
nsStyleDisplay
&
const
Element
&
)
;
nsContainerFrame
*
ConstructFrameWithAnonymousChild
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
nsFrameItems
&
aFrameItems
ContainerFrameCreationFunc
aConstructor
ContainerFrameCreationFunc
aInnerConstructor
nsICSSAnonBoxPseudo
*
aInnerPseudo
bool
aCandidateRootFrame
)
;
nsIFrame
*
ConstructOuterSVG
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aDisplay
nsFrameItems
&
aFrameItems
)
;
nsIFrame
*
ConstructMarker
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aDisplay
nsFrameItems
&
aFrameItems
)
;
static
const
FrameConstructionData
*
FindSVGData
(
const
Element
&
nsIFrame
*
aParentFrame
bool
aIsWithinSVGText
bool
aAllowsTextPathChild
ComputedStyle
&
)
;
const
FrameConstructionData
*
FindDisplayData
(
const
nsStyleDisplay
&
const
Element
&
)
;
nsIFrame
*
ConstructScrollableBlock
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aDisplay
nsFrameItems
&
aFrameItems
)
;
nsIFrame
*
ConstructScrollableBlockWithConstructor
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aDisplay
nsFrameItems
&
aFrameItems
BlockFrameCreationFunc
aConstructor
)
;
nsIFrame
*
ConstructNonScrollableBlock
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aDisplay
nsFrameItems
&
aFrameItems
)
;
nsIFrame
*
ConstructNonScrollableBlockWithConstructor
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aDisplay
nsFrameItems
&
aFrameItems
BlockFrameCreationFunc
aConstructor
)
;
void
AddFCItemsForAnonymousContent
(
nsFrameConstructorState
&
aState
nsContainerFrame
*
aFrame
const
nsTArray
<
nsIAnonymousContentCreator
:
:
ContentInfo
>
&
aAnonymousItems
FrameConstructionItemList
&
aItemsToConstruct
uint32_t
aExtraFlags
=
0
)
;
void
ProcessChildren
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
ComputedStyle
*
aComputedStyle
nsContainerFrame
*
aParentFrame
const
bool
aCanHaveGeneratedContent
nsFrameItems
&
aFrameItems
const
bool
aAllowBlockStyles
PendingBinding
*
aPendingBinding
nsIFrame
*
aPossiblyLeafFrame
=
nullptr
)
;
public
:
enum
ContainingBlockType
{
ABS_POS
FIXED_POS
}
;
nsContainerFrame
*
GetAbsoluteContainingBlock
(
nsIFrame
*
aFrame
ContainingBlockType
aType
)
;
nsContainerFrame
*
GetFloatContainingBlock
(
nsIFrame
*
aFrame
)
;
private
:
void
BuildScrollFrame
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
ComputedStyle
*
aContentStyle
nsIFrame
*
aScrolledFrame
nsContainerFrame
*
aParentFrame
nsContainerFrame
*
&
aNewFrame
)
;
already_AddRefed
<
ComputedStyle
>
BeginBuildingScrollFrame
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
ComputedStyle
*
aContentStyle
nsContainerFrame
*
aParentFrame
nsAtom
*
aScrolledPseudo
bool
aIsRoot
nsContainerFrame
*
&
aNewFrame
)
;
void
FinishBuildingScrollFrame
(
nsContainerFrame
*
aScrollFrame
nsIFrame
*
aScrolledFrame
)
;
void
InitializeSelectFrame
(
nsFrameConstructorState
&
aState
nsContainerFrame
*
aScrollFrame
nsContainerFrame
*
aScrolledFrame
nsIContent
*
aContent
nsContainerFrame
*
aParentFrame
ComputedStyle
*
aComputedStyle
bool
aBuildCombobox
PendingBinding
*
aPendingBinding
nsFrameItems
&
aFrameItems
)
;
void
RecreateFramesForContent
(
nsIContent
*
aContent
InsertionKind
aInsertionKind
)
;
void
UpdateTableCellSpans
(
nsIContent
*
aContent
)
;
bool
MaybeRecreateContainerForFrameRemoval
(
nsIFrame
*
aFrame
)
;
nsIFrame
*
CreateContinuingOuterTableFrame
(
nsIPresShell
*
aPresShell
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
nsContainerFrame
*
aParentFrame
nsIContent
*
aContent
ComputedStyle
*
aComputedStyle
)
;
nsIFrame
*
CreateContinuingTableFrame
(
nsIPresShell
*
aPresShell
nsIFrame
*
aFrame
nsContainerFrame
*
aParentFrame
nsIContent
*
aContent
ComputedStyle
*
aComputedStyle
)
;
already_AddRefed
<
ComputedStyle
>
GetFirstLetterStyle
(
nsIContent
*
aContent
ComputedStyle
*
aComputedStyle
)
;
already_AddRefed
<
ComputedStyle
>
GetFirstLineStyle
(
nsIContent
*
aContent
ComputedStyle
*
aComputedStyle
)
;
bool
ShouldHaveFirstLetterStyle
(
nsIContent
*
aContent
ComputedStyle
*
aComputedStyle
)
;
bool
HasFirstLetterStyle
(
nsIFrame
*
aBlockFrame
)
;
bool
ShouldHaveFirstLineStyle
(
nsIContent
*
aContent
ComputedStyle
*
aComputedStyle
)
;
void
ShouldHaveSpecialBlockStyle
(
nsIContent
*
aContent
ComputedStyle
*
aComputedStyle
bool
*
aHaveFirstLetterStyle
bool
*
aHaveFirstLineStyle
)
;
nsContainerFrame
*
InitAndWrapInColumnSetFrameIfNeeded
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
nsContainerFrame
*
aParentFrame
nsContainerFrame
*
aBlockFrame
ComputedStyle
*
aComputedStyle
)
;
void
ConstructBlock
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
nsContainerFrame
*
aParentFrame
nsContainerFrame
*
aContentParentFrame
ComputedStyle
*
aComputedStyle
nsContainerFrame
*
*
aNewFrame
nsFrameItems
&
aFrameItems
nsIFrame
*
aPositionedFrameForAbsPosContainer
PendingBinding
*
aPendingBinding
)
;
nsIFrame
*
ConstructInline
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aDisplay
nsFrameItems
&
aFrameItems
)
;
void
CreateIBSiblings
(
nsFrameConstructorState
&
aState
nsContainerFrame
*
aInitialInline
bool
aIsPositioned
nsFrameItems
&
aChildItems
nsFrameItems
&
aSiblings
)
;
void
BuildInlineChildItems
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aParentItem
bool
aItemIsWithinSVGText
bool
aItemAllowsTextPathChild
)
;
bool
WipeContainingBlock
(
nsFrameConstructorState
&
aState
nsIFrame
*
aContainingBlock
nsIFrame
*
aFrame
FrameConstructionItemList
&
aItems
bool
aIsAppend
nsIFrame
*
aPrevSibling
)
;
void
ReframeContainingBlock
(
nsIFrame
*
aFrame
)
;
nsFirstLetterFrame
*
CreateFloatingLetterFrame
(
nsFrameConstructorState
&
aState
nsIContent
*
aTextContent
nsIFrame
*
aTextFrame
nsContainerFrame
*
aParentFrame
ComputedStyle
*
aParentComputedStyle
ComputedStyle
*
aComputedStyle
nsFrameItems
&
aResult
)
;
void
CreateLetterFrame
(
nsContainerFrame
*
aBlockFrame
nsContainerFrame
*
aBlockContinuation
nsIContent
*
aTextContent
nsContainerFrame
*
aParentFrame
nsFrameItems
&
aResult
)
;
void
WrapFramesInFirstLetterFrame
(
nsContainerFrame
*
aBlockFrame
nsFrameItems
&
aBlockFrames
)
;
void
WrapFramesInFirstLetterFrame
(
nsContainerFrame
*
aBlockFrame
nsContainerFrame
*
aBlockContinuation
nsContainerFrame
*
aParentFrame
nsIFrame
*
aParentFrameList
nsContainerFrame
*
*
aModifiedParent
nsIFrame
*
*
aTextFrame
nsIFrame
*
*
aPrevFrame
nsFrameItems
&
aLetterFrames
bool
*
aStopLooking
)
;
void
RecoverLetterFrames
(
nsContainerFrame
*
aBlockFrame
)
;
void
RemoveLetterFrames
(
nsIPresShell
*
aPresShell
nsContainerFrame
*
aBlockFrame
)
;
void
RemoveFirstLetterFrames
(
nsIPresShell
*
aPresShell
nsContainerFrame
*
aFrame
nsContainerFrame
*
aBlockFrame
bool
*
aStopLooking
)
;
void
RemoveFloatingFirstLetterFrames
(
nsIPresShell
*
aPresShell
nsIFrame
*
aBlockFrame
)
;
void
CaptureStateForFramesOf
(
nsIContent
*
aContent
nsILayoutHistoryState
*
aHistoryState
)
;
void
WrapFramesInFirstLineFrame
(
nsFrameConstructorState
&
aState
nsIContent
*
aBlockContent
nsContainerFrame
*
aBlockFrame
nsFirstLineFrame
*
aLineFrame
nsFrameItems
&
aFrameItems
)
;
void
AppendFirstLineFrames
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
nsContainerFrame
*
aBlockFrame
nsFrameItems
&
aFrameItems
)
;
void
CheckForFirstLineInsertion
(
nsIFrame
*
aParentFrame
nsFrameItems
&
aFrameItems
)
;
nsIFrame
*
FindNextSiblingForAppend
(
const
InsertionPoint
&
)
;
enum
class
SiblingDirection
{
Forward
Backward
}
;
template
<
SiblingDirection
>
nsIFrame
*
FindSibling
(
const
mozilla
:
:
dom
:
:
FlattenedChildIterator
&
aIter
mozilla
:
:
StyleDisplay
&
aTargetContentDisplay
)
;
template
<
SiblingDirection
>
nsIFrame
*
FindSiblingInternal
(
mozilla
:
:
dom
:
:
FlattenedChildIterator
&
nsIContent
*
aTargetContent
mozilla
:
:
StyleDisplay
&
aTargetContentDisplay
)
;
nsIFrame
*
FindNextSibling
(
const
mozilla
:
:
dom
:
:
FlattenedChildIterator
&
aIter
mozilla
:
:
StyleDisplay
&
aTargetContentDisplay
)
;
nsIFrame
*
FindPreviousSibling
(
const
mozilla
:
:
dom
:
:
FlattenedChildIterator
&
aIter
mozilla
:
:
StyleDisplay
&
aTargetContentDisplay
)
;
nsIFrame
*
AdjustSiblingFrame
(
nsIFrame
*
aSibling
nsIContent
*
aTargetContent
mozilla
:
:
StyleDisplay
&
aTargetContentDisplay
SiblingDirection
aDirection
)
;
nsIFrame
*
GetInsertionPrevSibling
(
InsertionPoint
*
aInsertion
nsIContent
*
aChild
bool
*
aIsAppend
bool
*
aIsRangeInsertSafe
nsIContent
*
aStartSkipChild
=
nullptr
nsIContent
*
aEndSkipChild
=
nullptr
)
;
bool
IsValidSibling
(
nsIFrame
*
aSibling
nsIContent
*
aContent
mozilla
:
:
StyleDisplay
&
aDisplay
)
;
void
QuotesDirty
(
)
;
void
CountersDirty
(
)
;
void
ConstructAnonymousContentForCanvas
(
nsFrameConstructorState
&
aState
nsIFrame
*
aFrame
nsIContent
*
aDocElement
)
;
public
:
friend
class
nsFrameConstructorState
;
private
:
friend
struct
FrameConstructionItem
;
void
*
AllocateFCItem
(
)
;
void
FreeFCItem
(
FrameConstructionItem
*
)
;
nsIDocument
*
mDocument
;
nsContainerFrame
*
mRootElementFrame
;
nsIFrame
*
mRootElementStyleFrame
;
nsContainerFrame
*
mDocElementContainingBlock
;
nsIFrame
*
mPageSequenceFrame
;
mozilla
:
:
ArenaAllocator
<
4096
8
>
mFCItemPool
;
struct
FreeFCItemLink
{
FreeFCItemLink
*
mNext
;
}
;
FreeFCItemLink
*
mFirstFreeFCItem
;
size_t
mFCItemsInUse
;
nsQuoteList
mQuoteList
;
nsCounterManager
mCounterManager
;
uint16_t
mCurrentDepth
;
bool
mQuotesDirty
:
1
;
bool
mCountersDirty
:
1
;
bool
mIsDestroyingFrameTree
:
1
;
bool
mHasRootAbsPosContainingBlock
:
1
;
bool
mAlwaysCreateFramesForIgnorableWhitespace
:
1
;
nsCOMPtr
<
nsILayoutHistoryState
>
mTempFrameTreeState
;
}
;
#
endif
