#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
ComputedStyleInlines
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
dom
/
GeneratedImageContent
.
h
"
#
include
"
mozilla
/
dom
/
HTMLDetailsElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLSelectElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLSummaryElement
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
mozilla
/
ServoStyleSetInlines
.
h
"
#
include
"
mozilla
/
StaticPrefs
.
h
"
#
include
"
nsAbsoluteContainingBlock
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
DocumentInlines
.
h
"
#
include
"
nsTableFrame
.
h
"
#
include
"
nsTableColFrame
.
h
"
#
include
"
nsTableRowFrame
.
h
"
#
include
"
nsTableCellFrame
.
h
"
#
include
"
nsHTMLParts
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
ifdef
MOZ_XUL
#
include
"
nsXULElement
.
h
"
#
include
"
mozilla
/
dom
/
BoxObject
.
h
"
#
endif
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsComboboxControlFrame
.
h
"
#
include
"
nsListControlFrame
.
h
"
#
include
"
nsPlaceholderFrame
.
h
"
#
include
"
nsTableRowGroupFrame
.
h
"
#
include
"
nsIFormControl
.
h
"
#
include
"
nsCSSAnonBoxes
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
"
nsIAnonymousContentCreator
.
h
"
#
include
"
nsBindingManager
.
h
"
#
include
"
nsXBLBinding
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIScriptError
.
h
"
#
ifdef
XP_MACOSX
#
include
"
nsIDocShell
.
h
"
#
endif
#
include
"
ChildIterator
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsBoxFrame
.
h
"
#
include
"
nsBoxLayout
.
h
"
#
include
"
nsFlexContainerFrame
.
h
"
#
include
"
nsGridContainerFrame
.
h
"
#
include
"
RubyUtils
.
h
"
#
include
"
nsRubyFrame
.
h
"
#
include
"
nsRubyBaseFrame
.
h
"
#
include
"
nsRubyBaseContainerFrame
.
h
"
#
include
"
nsRubyTextFrame
.
h
"
#
include
"
nsRubyTextContainerFrame
.
h
"
#
include
"
nsImageFrame
.
h
"
#
include
"
nsIObjectLoadingContent
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
dom
/
CharacterData
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
ElementInlines
.
h
"
#
include
"
mozilla
/
dom
/
HTMLInputElement
.
h
"
#
include
"
nsAutoLayoutPhase
.
h
"
#
include
"
nsStyleStructInlines
.
h
"
#
include
"
nsPageContentFrame
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
StickyScrollContainer
.
h
"
#
include
"
nsFieldSetFrame
.
h
"
#
include
"
nsInlineFrame
.
h
"
#
include
"
nsBlockFrame
.
h
"
#
include
"
nsCanvasFrame
.
h
"
#
include
"
nsFirstLetterFrame
.
h
"
#
include
"
nsGfxScrollFrame
.
h
"
#
include
"
nsPageFrame
.
h
"
#
include
"
nsSimplePageSequenceFrame
.
h
"
#
include
"
nsTableWrapperFrame
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsBackdropFrame
.
h
"
#
include
"
nsTransitionManager
.
h
"
#
include
"
DetailsFrame
.
h
"
#
ifdef
MOZ_XUL
#
include
"
nsIPopupContainer
.
h
"
#
endif
#
ifdef
ACCESSIBILITY
#
include
"
nsAccessibilityService
.
h
"
#
endif
#
include
"
nsXBLService
.
h
"
#
undef
NOISY_FIRST_LETTER
#
include
"
nsMathMLParts
.
h
"
#
include
"
mozilla
/
dom
/
SVGTests
.
h
"
#
include
"
nsSVGUtils
.
h
"
#
include
"
nsRefreshDriver
.
h
"
#
include
"
nsTextNode
.
h
"
#
include
"
ActiveLayerTracker
.
h
"
#
include
"
nsIPresShellInlines
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
static
const
nsIFrame
:
:
ChildListID
kPrincipalList
=
nsIFrame
:
:
kPrincipalList
;
nsIFrame
*
NS_NewHTMLCanvasFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewHTMLVideoFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsContainerFrame
*
NS_NewSVGOuterSVGFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsContainerFrame
*
NS_NewSVGOuterSVGAnonChildFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewSVGInnerSVGFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewSVGGeometryFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewSVGGFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewSVGGenericContainerFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsContainerFrame
*
NS_NewSVGForeignObjectFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewSVGAFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewSVGSwitchFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewSVGSymbolFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewSVGTextFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewSVGContainerFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewSVGUseFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewSVGViewFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
extern
nsIFrame
*
NS_NewSVGLinearGradientFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
extern
nsIFrame
*
NS_NewSVGRadialGradientFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
extern
nsIFrame
*
NS_NewSVGStopFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsContainerFrame
*
NS_NewSVGMarkerFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsContainerFrame
*
NS_NewSVGMarkerAnonChildFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
extern
nsIFrame
*
NS_NewSVGImageFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewSVGClipPathFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewSVGFilterFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewSVGPatternFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewSVGMaskFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewSVGFEContainerFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewSVGFELeafFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewSVGFEImageFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewSVGFEUnstyledLeafFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
#
include
"
mozilla
/
dom
/
NodeInfo
.
h
"
#
include
"
prenv
.
h
"
#
include
"
nsNodeInfoManager
.
h
"
#
include
"
nsContentCreatorFunctions
.
h
"
#
ifdef
DEBUG
static
bool
gNoisyContentUpdates
=
false
;
static
bool
gReallyNoisyContentUpdates
=
false
;
static
bool
gNoisyInlineConstruction
=
false
;
struct
FrameCtorDebugFlags
{
const
char
*
name
;
bool
*
on
;
}
;
static
FrameCtorDebugFlags
gFlags
[
]
=
{
{
"
content
-
updates
"
&
gNoisyContentUpdates
}
{
"
really
-
noisy
-
content
-
updates
"
&
gReallyNoisyContentUpdates
}
{
"
noisy
-
inline
"
&
gNoisyInlineConstruction
}
}
;
#
define
NUM_DEBUG_FLAGS
(
sizeof
(
gFlags
)
/
sizeof
(
gFlags
[
0
]
)
)
#
endif
#
ifdef
MOZ_XUL
#
include
"
nsMenuFrame
.
h
"
#
include
"
nsPopupSetFrame
.
h
"
#
include
"
nsTreeColFrame
.
h
"
#
include
"
nsIBoxObject
.
h
"
#
include
"
nsXULLabelFrame
.
h
"
nsContainerFrame
*
NS_NewRootBoxFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsContainerFrame
*
NS_NewDocElementBoxFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewDeckFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewLeafBoxFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewStackFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewRangeFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewImageBoxFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewTextBoxFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewGroupBoxFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewButtonBoxFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewSplitterFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewMenuPopupFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewPopupSetFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewMenuFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
uint32_t
aFlags
)
;
nsIFrame
*
NS_NewMenuBarFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewTreeBodyFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsresult
NS_NewGridLayout2
(
nsIPresShell
*
aPresShell
nsBoxLayout
*
*
aNewLayout
)
;
nsIFrame
*
NS_NewGridRowLeafFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewGridRowGroupFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewTitleBarFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewResizerFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
#
endif
nsHTMLScrollFrame
*
NS_NewHTMLScrollFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
bool
aIsRoot
)
;
nsXULScrollFrame
*
NS_NewXULScrollFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
bool
aIsRoot
bool
aClipAllDescendants
)
;
nsIFrame
*
NS_NewSliderFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewScrollbarFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewScrollbarButtonFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewImageFrameForContentProperty
(
nsIPresShell
*
ComputedStyle
*
)
;
nsIFrame
*
NS_NewImageFrameForGeneratedContentIndex
(
nsIPresShell
*
ComputedStyle
*
)
;
static
inline
bool
IsAnonymousFlexOrGridItem
(
const
nsIFrame
*
aFrame
)
{
const
nsAtom
*
pseudoType
=
aFrame
-
>
Style
(
)
-
>
GetPseudo
(
)
;
return
pseudoType
=
=
nsCSSAnonBoxes
:
:
anonymousFlexItem
(
)
|
|
pseudoType
=
=
nsCSSAnonBoxes
:
:
anonymousGridItem
(
)
;
}
static
inline
bool
IsFlexContainerForLegacyBox
(
const
nsIFrame
*
aFrame
)
{
return
aFrame
-
>
IsFlexContainerFrame
(
)
&
&
aFrame
-
>
HasAnyStateBits
(
NS_STATE_FLEX_IS_EMULATING_LEGACY_BOX
)
;
}
#
if
DEBUG
static
void
AssertAnonymousFlexOrGridItemParent
(
const
nsIFrame
*
aChild
const
nsIFrame
*
aParent
)
{
MOZ_ASSERT
(
IsAnonymousFlexOrGridItem
(
aChild
)
"
expected
an
anonymous
flex
or
grid
item
child
frame
"
)
;
MOZ_ASSERT
(
aParent
"
expected
a
parent
frame
"
)
;
const
nsAtom
*
pseudoType
=
aChild
-
>
Style
(
)
-
>
GetPseudo
(
)
;
if
(
pseudoType
=
=
nsCSSAnonBoxes
:
:
anonymousFlexItem
(
)
)
{
MOZ_ASSERT
(
aParent
-
>
IsFlexContainerFrame
(
)
"
anonymous
flex
items
should
only
exist
as
children
"
"
of
flex
container
frames
"
)
;
}
else
{
MOZ_ASSERT
(
aParent
-
>
IsGridContainerFrame
(
)
"
anonymous
grid
items
should
only
exist
as
children
"
"
of
grid
container
frames
"
)
;
}
}
#
else
#
define
AssertAnonymousFlexOrGridItemParent
(
x
y
)
PR_BEGIN_MACRO
PR_END_MACRO
#
endif
static
inline
nsContainerFrame
*
GetFieldSetBlockFrame
(
nsIFrame
*
aFieldsetFrame
)
{
nsIFrame
*
firstChild
=
aFieldsetFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
nsIFrame
*
inner
=
firstChild
&
&
firstChild
-
>
GetNextSibling
(
)
?
firstChild
-
>
GetNextSibling
(
)
:
firstChild
;
return
inner
?
inner
-
>
GetContentInsertionFrame
(
)
:
nullptr
;
}
#
define
FCDATA_DECL
(
_flags
_func
)
\
{
_flags
{
(
FrameCreationFunc
)
_func
}
nullptr
nullptr
}
#
define
FCDATA_WITH_WRAPPING_BLOCK
(
_flags
_func
_anon_box
)
\
{
\
_flags
|
FCDATA_CREATE_BLOCK_WRAPPER_FOR_ALL_KIDS
\
{
(
FrameCreationFunc
)
_func
}
nullptr
_anon_box
\
}
#
define
UNREACHABLE_FCDATA
(
)
\
{
0
{
(
FrameCreationFunc
)
nullptr
}
nullptr
nullptr
}
static
bool
IsInlineFrame
(
const
nsIFrame
*
aFrame
)
{
return
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eLineParticipant
)
;
}
static
inline
bool
IsDisplayContents
(
const
Element
*
aElement
)
{
return
aElement
-
>
IsDisplayContents
(
)
;
}
static
inline
bool
IsDisplayContents
(
const
nsIContent
*
aContent
)
{
return
aContent
-
>
IsElement
(
)
&
&
IsDisplayContents
(
aContent
-
>
AsElement
(
)
)
;
}
static
bool
IsFrameForSVG
(
const
nsIFrame
*
aFrame
)
{
return
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
|
|
nsSVGUtils
:
:
IsInSVGTextSubtree
(
aFrame
)
;
}
static
bool
IsLastContinuationForColumnContent
(
const
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
)
;
return
aFrame
-
>
Style
(
)
-
>
GetPseudo
(
)
=
=
nsCSSAnonBoxes
:
:
columnContent
(
)
&
&
!
aFrame
-
>
GetNextContinuation
(
)
;
}
static
bool
ShouldSuppressFloatingOfDescendants
(
nsIFrame
*
aFrame
)
{
return
aFrame
-
>
IsFlexOrGridContainer
(
)
|
|
aFrame
-
>
IsXULBoxFrame
(
)
|
|
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eMathML
)
;
}
static
bool
ShouldSuppressColumnSpanDescendants
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
StaticPrefs
:
:
layout_css_column_span_enabled
(
)
"
Call
this
only
when
layout
.
css
.
column
-
span
.
enabled
is
true
!
"
)
;
if
(
aFrame
-
>
Style
(
)
-
>
GetPseudo
(
)
=
=
nsCSSAnonBoxes
:
:
columnContent
(
)
)
{
return
false
;
}
if
(
aFrame
-
>
IsInlineFrame
(
)
)
{
return
false
;
}
if
(
!
nsLayoutUtils
:
:
GetAsBlock
(
aFrame
)
|
|
aFrame
-
>
HasAnyStateBits
(
NS_BLOCK_FLOAT_MGR
|
NS_FRAME_OUT_OF_FLOW
)
)
{
return
true
;
}
return
false
;
}
static
nsIContent
*
AnyKidsNeedBlockParent
(
nsIFrame
*
aFrameList
)
{
for
(
nsIFrame
*
k
=
aFrameList
;
k
;
k
=
k
-
>
GetNextSibling
(
)
)
{
if
(
k
-
>
IsFrameOfType
(
nsIFrame
:
:
eLineParticipant
)
)
{
return
k
-
>
GetContent
(
)
;
}
}
return
nullptr
;
}
static
void
ReparentFrame
(
RestyleManager
*
aRestyleManager
nsContainerFrame
*
aNewParentFrame
nsIFrame
*
aFrame
bool
aForceStyleReparent
)
{
aFrame
-
>
SetParent
(
aNewParentFrame
)
;
if
(
aForceStyleReparent
)
{
aRestyleManager
-
>
ReparentComputedStyleForFirstLine
(
aFrame
)
;
}
}
static
void
ReparentFrames
(
nsCSSFrameConstructor
*
aFrameConstructor
nsContainerFrame
*
aNewParentFrame
const
nsFrameList
&
aFrameList
bool
aForceStyleReparent
)
{
RestyleManager
*
restyleManager
=
aFrameConstructor
-
>
RestyleManager
(
)
;
for
(
nsIFrame
*
f
:
aFrameList
)
{
ReparentFrame
(
restyleManager
aNewParentFrame
f
aForceStyleReparent
)
;
}
}
static
inline
bool
IsFramePartOfIBSplit
(
nsIFrame
*
aFrame
)
{
bool
result
=
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_PART_OF_IBSPLIT
)
!
=
0
;
MOZ_ASSERT
(
!
result
|
|
static_cast
<
nsBlockFrame
*
>
(
do_QueryFrame
(
aFrame
)
)
|
|
static_cast
<
nsInlineFrame
*
>
(
do_QueryFrame
(
aFrame
)
)
"
only
block
/
inline
frames
can
have
NS_FRAME_PART_OF_IBSPLIT
"
)
;
return
result
;
}
static
nsContainerFrame
*
GetIBSplitSibling
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
IsFramePartOfIBSplit
(
aFrame
)
"
Shouldn
'
t
call
this
"
)
;
return
aFrame
-
>
FirstContinuation
(
)
-
>
GetProperty
(
nsIFrame
:
:
IBSplitSibling
(
)
)
;
}
static
nsContainerFrame
*
GetIBSplitPrevSibling
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
IsFramePartOfIBSplit
(
aFrame
)
"
Shouldn
'
t
call
this
"
)
;
return
aFrame
-
>
FirstContinuation
(
)
-
>
GetProperty
(
nsIFrame
:
:
IBSplitPrevSibling
(
)
)
;
}
static
nsContainerFrame
*
GetLastIBSplitSibling
(
nsIFrame
*
aFrame
)
{
for
(
nsIFrame
*
frame
=
aFrame
*
next
;
;
frame
=
next
)
{
next
=
GetIBSplitSibling
(
frame
)
;
if
(
!
next
)
{
return
static_cast
<
nsContainerFrame
*
>
(
frame
)
;
}
}
MOZ_ASSERT_UNREACHABLE
(
"
unreachable
code
"
)
;
return
nullptr
;
}
static
void
SetFrameIsIBSplit
(
nsContainerFrame
*
aFrame
nsContainerFrame
*
aIBSplitSibling
)
{
MOZ_ASSERT
(
aFrame
"
bad
args
!
"
)
;
NS_ASSERTION
(
!
aFrame
-
>
GetPrevContinuation
(
)
"
assigning
ib
-
split
sibling
to
other
than
first
continuation
!
"
)
;
NS_ASSERTION
(
!
aFrame
-
>
GetNextContinuation
(
)
|
|
IsFramePartOfIBSplit
(
aFrame
-
>
GetNextContinuation
(
)
)
"
should
have
no
non
-
ib
-
split
continuations
here
"
)
;
aFrame
-
>
AddStateBits
(
NS_FRAME_PART_OF_IBSPLIT
)
;
if
(
aIBSplitSibling
)
{
NS_ASSERTION
(
!
aIBSplitSibling
-
>
GetPrevContinuation
(
)
"
assigning
something
other
than
the
first
continuation
as
the
"
"
ib
-
split
sibling
"
)
;
aFrame
-
>
SetProperty
(
nsIFrame
:
:
IBSplitSibling
(
)
aIBSplitSibling
)
;
aIBSplitSibling
-
>
SetProperty
(
nsIFrame
:
:
IBSplitPrevSibling
(
)
aFrame
)
;
}
}
static
nsIFrame
*
GetIBContainingBlockFor
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
IsFramePartOfIBSplit
(
aFrame
)
"
GetIBContainingBlockFor
(
)
should
only
be
called
on
known
IB
frames
"
)
;
nsIFrame
*
parentFrame
;
do
{
parentFrame
=
aFrame
-
>
GetParent
(
)
;
if
(
!
parentFrame
)
{
NS_ERROR
(
"
no
unsplit
block
frame
in
IB
hierarchy
"
)
;
return
aFrame
;
}
if
(
!
IsFramePartOfIBSplit
(
parentFrame
)
&
&
!
parentFrame
-
>
Style
(
)
-
>
GetPseudo
(
)
)
break
;
aFrame
=
parentFrame
;
}
while
(
1
)
;
NS_ASSERTION
(
parentFrame
"
no
normal
ancestor
found
for
ib
-
split
frame
"
"
in
GetIBContainingBlockFor
"
)
;
NS_ASSERTION
(
parentFrame
!
=
aFrame
"
parentFrame
is
actually
the
child
frame
-
bogus
reslt
"
)
;
return
parentFrame
;
}
static
nsContainerFrame
*
GetMultiColumnContainingBlockFor
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_HAS_MULTI_COLUMN_ANCESTOR
)
"
Should
only
be
called
if
the
frame
has
a
multi
-
column
ancestor
!
"
)
;
nsContainerFrame
*
current
=
aFrame
-
>
GetParent
(
)
;
while
(
current
&
&
!
current
-
>
IsColumnSetWrapperFrame
(
)
)
{
current
=
current
-
>
GetParent
(
)
;
}
MOZ_ASSERT
(
current
"
No
ColumnSetWrapperFrame
in
a
valid
column
hierarchy
?
"
)
;
return
current
;
}
static
bool
ParentIsWrapperAnonBox
(
nsIFrame
*
aParent
)
{
nsIFrame
*
maybeAnonBox
=
aParent
;
if
(
maybeAnonBox
-
>
Style
(
)
-
>
GetPseudo
(
)
=
=
nsCSSAnonBoxes
:
:
cellContent
(
)
)
{
maybeAnonBox
=
maybeAnonBox
-
>
GetParent
(
)
;
}
return
maybeAnonBox
-
>
Style
(
)
-
>
IsWrapperAnonBox
(
)
;
}
inline
void
SetInitialSingleChild
(
nsContainerFrame
*
aParent
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
!
aFrame
-
>
GetNextSibling
(
)
"
Should
be
using
a
frame
list
"
)
;
nsFrameList
temp
(
aFrame
aFrame
)
;
aParent
-
>
SetInitialChildList
(
kPrincipalList
temp
)
;
}
struct
nsFrameItems
:
public
nsFrameList
{
void
AddChild
(
nsIFrame
*
aChild
)
;
}
;
void
nsFrameItems
:
:
AddChild
(
nsIFrame
*
aChild
)
{
MOZ_ASSERT
(
aChild
"
nsFrameItems
:
:
AddChild
"
)
;
MOZ_ASSERT
(
!
aChild
-
>
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
|
|
aChild
-
>
GetPlaceholderFrame
(
)
"
An
out
-
of
-
flow
child
without
a
placeholder
frame
?
"
)
;
if
(
IsEmpty
(
)
)
{
SetFrames
(
aChild
)
;
}
else
{
NS_ASSERTION
(
aChild
!
=
mLastChild
"
Same
frame
being
added
to
frame
list
twice
?
"
)
;
mLastChild
-
>
SetNextSibling
(
aChild
)
;
mLastChild
=
nsLayoutUtils
:
:
GetLastSibling
(
aChild
)
;
}
}
struct
nsAbsoluteItems
:
nsFrameItems
{
nsContainerFrame
*
containingBlock
;
explicit
nsAbsoluteItems
(
nsContainerFrame
*
aContainingBlock
)
;
#
ifdef
DEBUG
~
nsAbsoluteItems
(
)
{
NS_ASSERTION
(
!
FirstChild
(
)
"
Dangling
child
list
.
Someone
forgot
to
insert
it
?
"
)
;
}
#
endif
}
;
nsAbsoluteItems
:
:
nsAbsoluteItems
(
nsContainerFrame
*
aContainingBlock
)
:
containingBlock
(
aContainingBlock
)
{
}
class
MOZ_STACK_CLASS
nsFrameConstructorSaveState
{
public
:
typedef
nsIFrame
:
:
ChildListID
ChildListID
;
nsFrameConstructorSaveState
(
)
;
~
nsFrameConstructorSaveState
(
)
;
private
:
nsAbsoluteItems
*
mItems
;
nsAbsoluteItems
mSavedItems
;
ChildListID
mChildListID
;
nsFrameConstructorState
*
mState
;
nsAbsoluteItems
mSavedFixedItems
;
bool
mSavedFixedPosIsAbsPos
;
friend
class
nsFrameConstructorState
;
}
;
struct
PendingBinding
:
public
LinkedListElement
<
PendingBinding
>
{
#
ifdef
NS_BUILD_REFCNT_LOGGING
PendingBinding
(
)
{
MOZ_COUNT_CTOR
(
PendingBinding
)
;
}
~
PendingBinding
(
)
{
MOZ_COUNT_DTOR
(
PendingBinding
)
;
}
#
endif
RefPtr
<
nsXBLBinding
>
mBinding
;
}
;
class
MOZ_STACK_CLASS
nsFrameConstructorState
{
public
:
typedef
nsIFrame
:
:
ChildListID
ChildListID
;
nsPresContext
*
mPresContext
;
nsIPresShell
*
mPresShell
;
nsFrameManager
*
mFrameManager
;
#
ifdef
MOZ_XUL
nsAbsoluteItems
mPopupItems
;
#
endif
nsAbsoluteItems
mFixedItems
;
nsAbsoluteItems
mAbsoluteItems
;
nsAbsoluteItems
mFloatedItems
;
nsAbsoluteItems
mTopLayerFixedItems
;
nsAbsoluteItems
mTopLayerAbsoluteItems
;
nsCOMPtr
<
nsILayoutHistoryState
>
mFrameState
;
nsFrameState
mAdditionalStateBits
;
bool
mFixedPosIsAbsPos
;
bool
mHavePendingPopupgroup
;
bool
mCreatingExtraFrames
;
nsCOMArray
<
nsIContent
>
mGeneratedTextNodesWithInitializer
;
nsFrameConstructorState
(
nsIPresShell
*
aPresShell
nsContainerFrame
*
aFixedContainingBlock
nsContainerFrame
*
aAbsoluteContainingBlock
nsContainerFrame
*
aFloatContainingBlock
already_AddRefed
<
nsILayoutHistoryState
>
aHistoryState
)
;
nsFrameConstructorState
(
nsIPresShell
*
aPresShell
nsContainerFrame
*
aFixedContainingBlock
nsContainerFrame
*
aAbsoluteContainingBlock
nsContainerFrame
*
aFloatContainingBlock
)
;
~
nsFrameConstructorState
(
)
;
void
PushAbsoluteContainingBlock
(
nsContainerFrame
*
aNewAbsoluteContainingBlock
nsIFrame
*
aPositionedFrame
nsFrameConstructorSaveState
&
aSaveState
)
;
void
PushFloatContainingBlock
(
nsContainerFrame
*
aNewFloatContainingBlock
nsFrameConstructorSaveState
&
aSaveState
)
;
nsContainerFrame
*
GetGeometricParent
(
const
nsStyleDisplay
&
aStyleDisplay
nsContainerFrame
*
aContentParentFrame
)
const
;
void
ReparentAbsoluteItems
(
nsContainerFrame
*
aNewParent
)
;
void
AddChild
(
nsIFrame
*
aNewFrame
nsFrameItems
&
aFrameItems
nsIContent
*
aContent
nsContainerFrame
*
aParentFrame
bool
aCanBePositioned
=
true
bool
aCanBeFloated
=
true
bool
aIsOutOfFlowPopup
=
false
bool
aInsertAfter
=
false
nsIFrame
*
aInsertAfterFrame
=
nullptr
)
;
nsAbsoluteItems
&
GetFixedItems
(
)
{
return
mFixedPosIsAbsPos
?
mAbsoluteItems
:
mFixedItems
;
}
const
nsAbsoluteItems
&
GetFixedItems
(
)
const
{
return
mFixedPosIsAbsPos
?
mAbsoluteItems
:
mFixedItems
;
}
class
PendingBindingAutoPusher
;
friend
class
PendingBindingAutoPusher
;
class
MOZ_STACK_CLASS
PendingBindingAutoPusher
{
public
:
PendingBindingAutoPusher
(
nsFrameConstructorState
&
aState
PendingBinding
*
aPendingBinding
)
:
mState
(
aState
)
mPendingBinding
(
aState
.
mCurrentPendingBindingInsertionPoint
)
{
if
(
aPendingBinding
)
{
aState
.
mCurrentPendingBindingInsertionPoint
=
aPendingBinding
;
}
}
~
PendingBindingAutoPusher
(
)
{
mState
.
mCurrentPendingBindingInsertionPoint
=
mPendingBinding
;
}
private
:
nsFrameConstructorState
&
mState
;
PendingBinding
*
mPendingBinding
;
}
;
void
AddPendingBinding
(
UniquePtr
<
PendingBinding
>
aPendingBinding
)
{
if
(
mCurrentPendingBindingInsertionPoint
)
{
mCurrentPendingBindingInsertionPoint
-
>
setPrevious
(
aPendingBinding
.
release
(
)
)
;
}
else
{
mPendingBindings
.
insertBack
(
aPendingBinding
.
release
(
)
)
;
}
}
protected
:
friend
class
nsFrameConstructorSaveState
;
void
ProcessFrameInsertions
(
nsAbsoluteItems
&
aFrameItems
ChildListID
aChildListID
)
;
nsAbsoluteItems
*
GetOutOfFlowFrameItems
(
nsIFrame
*
aNewFrame
bool
aCanBePositioned
bool
aCanBeFloated
bool
aIsOutOfFlowPopup
nsFrameState
*
aPlaceholderType
)
;
void
ConstructBackdropFrameFor
(
nsIContent
*
aContent
nsIFrame
*
aFrame
)
;
LinkedList
<
PendingBinding
>
mPendingBindings
;
PendingBinding
*
mCurrentPendingBindingInsertionPoint
;
}
;
nsFrameConstructorState
:
:
nsFrameConstructorState
(
nsIPresShell
*
aPresShell
nsContainerFrame
*
aFixedContainingBlock
nsContainerFrame
*
aAbsoluteContainingBlock
nsContainerFrame
*
aFloatContainingBlock
already_AddRefed
<
nsILayoutHistoryState
>
aHistoryState
)
:
mPresContext
(
aPresShell
-
>
GetPresContext
(
)
)
mPresShell
(
aPresShell
)
mFrameManager
(
aPresShell
-
>
FrameConstructor
(
)
)
#
ifdef
MOZ_XUL
mPopupItems
(
nullptr
)
#
endif
mFixedItems
(
aFixedContainingBlock
)
mAbsoluteItems
(
aAbsoluteContainingBlock
)
mFloatedItems
(
aFloatContainingBlock
)
mTopLayerFixedItems
(
static_cast
<
nsContainerFrame
*
>
(
mFrameManager
-
>
GetRootFrame
(
)
)
)
mTopLayerAbsoluteItems
(
aPresShell
-
>
FrameConstructor
(
)
-
>
GetDocElementContainingBlock
(
)
)
mFrameState
(
aHistoryState
)
mAdditionalStateBits
(
nsFrameState
(
0
)
)
mFixedPosIsAbsPos
(
aFixedContainingBlock
=
=
aAbsoluteContainingBlock
)
mHavePendingPopupgroup
(
false
)
mCreatingExtraFrames
(
false
)
mCurrentPendingBindingInsertionPoint
(
nullptr
)
{
#
ifdef
MOZ_XUL
nsIPopupContainer
*
popupContainer
=
nsIPopupContainer
:
:
GetPopupContainer
(
aPresShell
)
;
if
(
popupContainer
)
{
mPopupItems
.
containingBlock
=
popupContainer
-
>
GetPopupSetFrame
(
)
;
}
#
endif
MOZ_COUNT_CTOR
(
nsFrameConstructorState
)
;
}
nsFrameConstructorState
:
:
nsFrameConstructorState
(
nsIPresShell
*
aPresShell
nsContainerFrame
*
aFixedContainingBlock
nsContainerFrame
*
aAbsoluteContainingBlock
nsContainerFrame
*
aFloatContainingBlock
)
:
nsFrameConstructorState
(
aPresShell
aFixedContainingBlock
aAbsoluteContainingBlock
aFloatContainingBlock
aPresShell
-
>
GetDocument
(
)
-
>
GetLayoutHistoryState
(
)
)
{
}
nsFrameConstructorState
:
:
~
nsFrameConstructorState
(
)
{
MOZ_COUNT_DTOR
(
nsFrameConstructorState
)
;
ProcessFrameInsertions
(
mTopLayerFixedItems
nsIFrame
:
:
kFixedList
)
;
ProcessFrameInsertions
(
mTopLayerAbsoluteItems
nsIFrame
:
:
kAbsoluteList
)
;
ProcessFrameInsertions
(
mFloatedItems
nsIFrame
:
:
kFloatList
)
;
ProcessFrameInsertions
(
mAbsoluteItems
nsIFrame
:
:
kAbsoluteList
)
;
ProcessFrameInsertions
(
mFixedItems
nsIFrame
:
:
kFixedList
)
;
#
ifdef
MOZ_XUL
ProcessFrameInsertions
(
mPopupItems
nsIFrame
:
:
kPopupList
)
;
#
endif
for
(
int32_t
i
=
mGeneratedTextNodesWithInitializer
.
Count
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
mGeneratedTextNodesWithInitializer
[
i
]
-
>
DeleteProperty
(
nsGkAtoms
:
:
genConInitializerProperty
)
;
}
if
(
!
mPendingBindings
.
isEmpty
(
)
)
{
nsBindingManager
*
bindingManager
=
mPresShell
-
>
GetDocument
(
)
-
>
BindingManager
(
)
;
do
{
UniquePtr
<
PendingBinding
>
pendingBinding
(
mPendingBindings
.
popFirst
(
)
)
;
bindingManager
-
>
AddToAttachedQueue
(
pendingBinding
-
>
mBinding
)
;
}
while
(
!
mPendingBindings
.
isEmpty
(
)
)
;
mCurrentPendingBindingInsertionPoint
=
nullptr
;
}
}
void
nsFrameConstructorState
:
:
PushAbsoluteContainingBlock
(
nsContainerFrame
*
aNewAbsoluteContainingBlock
nsIFrame
*
aPositionedFrame
nsFrameConstructorSaveState
&
aSaveState
)
{
aSaveState
.
mItems
=
&
mAbsoluteItems
;
aSaveState
.
mSavedItems
=
mAbsoluteItems
;
aSaveState
.
mChildListID
=
nsIFrame
:
:
kAbsoluteList
;
aSaveState
.
mState
=
this
;
aSaveState
.
mSavedFixedPosIsAbsPos
=
mFixedPosIsAbsPos
;
if
(
mFixedPosIsAbsPos
)
{
aSaveState
.
mSavedFixedItems
=
mFixedItems
;
mFixedItems
=
mAbsoluteItems
;
}
mAbsoluteItems
=
nsAbsoluteItems
(
aNewAbsoluteContainingBlock
)
;
mFixedPosIsAbsPos
=
aPositionedFrame
&
&
aPositionedFrame
-
>
IsFixedPosContainingBlock
(
)
;
if
(
aNewAbsoluteContainingBlock
)
{
aNewAbsoluteContainingBlock
-
>
MarkAsAbsoluteContainingBlock
(
)
;
}
}
void
nsFrameConstructorState
:
:
PushFloatContainingBlock
(
nsContainerFrame
*
aNewFloatContainingBlock
nsFrameConstructorSaveState
&
aSaveState
)
{
MOZ_ASSERT
(
!
aNewFloatContainingBlock
|
|
aNewFloatContainingBlock
-
>
IsFloatContainingBlock
(
)
"
Please
push
a
real
float
containing
block
!
"
)
;
NS_ASSERTION
(
!
aNewFloatContainingBlock
|
|
!
ShouldSuppressFloatingOfDescendants
(
aNewFloatContainingBlock
)
"
We
should
not
push
a
frame
that
is
supposed
to
_suppress_
"
"
floats
as
a
float
containing
block
!
"
)
;
aSaveState
.
mItems
=
&
mFloatedItems
;
aSaveState
.
mSavedItems
=
mFloatedItems
;
aSaveState
.
mChildListID
=
nsIFrame
:
:
kFloatList
;
aSaveState
.
mState
=
this
;
mFloatedItems
=
nsAbsoluteItems
(
aNewFloatContainingBlock
)
;
}
nsContainerFrame
*
nsFrameConstructorState
:
:
GetGeometricParent
(
const
nsStyleDisplay
&
aStyleDisplay
nsContainerFrame
*
aContentParentFrame
)
const
{
if
(
aContentParentFrame
&
&
nsSVGUtils
:
:
IsInSVGTextSubtree
(
aContentParentFrame
)
)
{
return
aContentParentFrame
;
}
if
(
aStyleDisplay
.
IsFloatingStyle
(
)
&
&
mFloatedItems
.
containingBlock
)
{
NS_ASSERTION
(
!
aStyleDisplay
.
IsAbsolutelyPositionedStyle
(
)
"
Absolutely
positioned
_and_
floating
?
"
)
;
return
mFloatedItems
.
containingBlock
;
}
if
(
aStyleDisplay
.
mTopLayer
!
=
NS_STYLE_TOP_LAYER_NONE
)
{
MOZ_ASSERT
(
aStyleDisplay
.
mTopLayer
=
=
NS_STYLE_TOP_LAYER_TOP
"
-
moz
-
top
-
layer
should
be
either
none
or
top
"
)
;
MOZ_ASSERT
(
aStyleDisplay
.
IsAbsolutelyPositionedStyle
(
)
"
Top
layer
items
should
always
be
absolutely
positioned
"
)
;
if
(
aStyleDisplay
.
mPosition
=
=
NS_STYLE_POSITION_FIXED
)
{
MOZ_ASSERT
(
mTopLayerFixedItems
.
containingBlock
"
No
root
frame
?
"
)
;
return
mTopLayerFixedItems
.
containingBlock
;
}
MOZ_ASSERT
(
aStyleDisplay
.
mPosition
=
=
NS_STYLE_POSITION_ABSOLUTE
)
;
MOZ_ASSERT
(
mTopLayerAbsoluteItems
.
containingBlock
)
;
return
mTopLayerAbsoluteItems
.
containingBlock
;
}
if
(
aStyleDisplay
.
mPosition
=
=
NS_STYLE_POSITION_ABSOLUTE
&
&
mAbsoluteItems
.
containingBlock
)
{
return
mAbsoluteItems
.
containingBlock
;
}
if
(
aStyleDisplay
.
mPosition
=
=
NS_STYLE_POSITION_FIXED
&
&
GetFixedItems
(
)
.
containingBlock
)
{
return
GetFixedItems
(
)
.
containingBlock
;
}
return
aContentParentFrame
;
}
void
nsFrameConstructorState
:
:
ReparentAbsoluteItems
(
nsContainerFrame
*
aNewParent
)
{
MOZ_ASSERT
(
aNewParent
-
>
HasAnyStateBits
(
NS_FRAME_HAS_MULTI_COLUMN_ANCESTOR
)
"
Restrict
the
usage
under
column
hierarchy
.
"
)
;
nsFrameList
newAbsoluteItems
;
nsIFrame
*
current
=
mAbsoluteItems
.
FirstChild
(
)
;
while
(
current
)
{
nsIFrame
*
placeholder
=
current
-
>
GetPlaceholderFrame
(
)
;
if
(
nsLayoutUtils
:
:
IsProperAncestorFrame
(
aNewParent
placeholder
)
)
{
nsIFrame
*
next
=
current
-
>
GetNextSibling
(
)
;
mAbsoluteItems
.
RemoveFrame
(
current
)
;
newAbsoluteItems
.
AppendFrame
(
aNewParent
current
)
;
current
=
next
;
}
else
{
current
=
current
-
>
GetNextSibling
(
)
;
}
}
if
(
newAbsoluteItems
.
NotEmpty
(
)
)
{
nsFrameConstructorSaveState
absoluteSaveState
;
PushAbsoluteContainingBlock
(
aNewParent
aNewParent
absoluteSaveState
)
;
mAbsoluteItems
.
SetFrames
(
newAbsoluteItems
)
;
}
}
nsAbsoluteItems
*
nsFrameConstructorState
:
:
GetOutOfFlowFrameItems
(
nsIFrame
*
aNewFrame
bool
aCanBePositioned
bool
aCanBeFloated
bool
aIsOutOfFlowPopup
nsFrameState
*
aPlaceholderType
)
{
#
ifdef
MOZ_XUL
if
(
MOZ_UNLIKELY
(
aIsOutOfFlowPopup
)
)
{
MOZ_ASSERT
(
mPopupItems
.
containingBlock
"
Must
have
a
popup
set
frame
!
"
)
;
*
aPlaceholderType
=
PLACEHOLDER_FOR_POPUP
;
return
&
mPopupItems
;
}
#
endif
if
(
aCanBeFloated
&
&
aNewFrame
-
>
IsFloating
(
)
)
{
*
aPlaceholderType
=
PLACEHOLDER_FOR_FLOAT
;
return
&
mFloatedItems
;
}
if
(
aCanBePositioned
)
{
const
nsStyleDisplay
*
disp
=
aNewFrame
-
>
StyleDisplay
(
)
;
if
(
disp
-
>
mTopLayer
!
=
NS_STYLE_TOP_LAYER_NONE
)
{
*
aPlaceholderType
=
PLACEHOLDER_FOR_TOPLAYER
;
if
(
disp
-
>
mPosition
=
=
NS_STYLE_POSITION_FIXED
)
{
*
aPlaceholderType
|
=
PLACEHOLDER_FOR_FIXEDPOS
;
return
&
mTopLayerFixedItems
;
}
*
aPlaceholderType
|
=
PLACEHOLDER_FOR_ABSPOS
;
return
&
mTopLayerAbsoluteItems
;
}
if
(
disp
-
>
mPosition
=
=
NS_STYLE_POSITION_ABSOLUTE
)
{
*
aPlaceholderType
=
PLACEHOLDER_FOR_ABSPOS
;
return
&
mAbsoluteItems
;
}
if
(
disp
-
>
mPosition
=
=
NS_STYLE_POSITION_FIXED
)
{
*
aPlaceholderType
=
PLACEHOLDER_FOR_FIXEDPOS
;
return
&
GetFixedItems
(
)
;
}
}
return
nullptr
;
}
void
nsFrameConstructorState
:
:
ConstructBackdropFrameFor
(
nsIContent
*
aContent
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
-
>
StyleDisplay
(
)
-
>
mTopLayer
=
=
NS_STYLE_TOP_LAYER_TOP
)
;
nsContainerFrame
*
frame
=
do_QueryFrame
(
aFrame
)
;
if
(
!
frame
)
{
NS_WARNING
(
"
Cannot
create
backdrop
frame
for
non
-
container
frame
"
)
;
return
;
}
RefPtr
<
ComputedStyle
>
style
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolvePseudoElementStyle
(
aContent
-
>
AsElement
(
)
CSSPseudoElementType
:
:
backdrop
nullptr
nullptr
)
;
MOZ_ASSERT
(
style
-
>
StyleDisplay
(
)
-
>
mTopLayer
=
=
NS_STYLE_TOP_LAYER_TOP
)
;
nsContainerFrame
*
parentFrame
=
GetGeometricParent
(
*
style
-
>
StyleDisplay
(
)
nullptr
)
;
nsBackdropFrame
*
backdropFrame
=
new
(
mPresShell
)
nsBackdropFrame
(
style
)
;
backdropFrame
-
>
Init
(
aContent
parentFrame
nullptr
)
;
nsFrameState
placeholderType
;
nsAbsoluteItems
*
frameItems
=
GetOutOfFlowFrameItems
(
backdropFrame
true
true
false
&
placeholderType
)
;
MOZ_ASSERT
(
placeholderType
&
PLACEHOLDER_FOR_TOPLAYER
)
;
nsIFrame
*
placeholder
=
nsCSSFrameConstructor
:
:
CreatePlaceholderFrameFor
(
mPresShell
aContent
backdropFrame
frame
nullptr
placeholderType
)
;
nsFrameList
temp
(
placeholder
placeholder
)
;
frame
-
>
SetInitialChildList
(
nsIFrame
:
:
kBackdropList
temp
)
;
frameItems
-
>
AddChild
(
backdropFrame
)
;
}
void
nsFrameConstructorState
:
:
AddChild
(
nsIFrame
*
aNewFrame
nsFrameItems
&
aFrameItems
nsIContent
*
aContent
nsContainerFrame
*
aParentFrame
bool
aCanBePositioned
bool
aCanBeFloated
bool
aIsOutOfFlowPopup
bool
aInsertAfter
nsIFrame
*
aInsertAfterFrame
)
{
MOZ_ASSERT
(
!
aNewFrame
-
>
GetNextSibling
(
)
"
Shouldn
'
t
happen
"
)
;
nsFrameState
placeholderType
;
nsAbsoluteItems
*
outOfFlowFrameItems
=
GetOutOfFlowFrameItems
(
aNewFrame
aCanBePositioned
aCanBeFloated
aIsOutOfFlowPopup
&
placeholderType
)
;
nsFrameItems
*
frameItems
;
if
(
outOfFlowFrameItems
&
&
outOfFlowFrameItems
-
>
containingBlock
)
{
MOZ_ASSERT
(
aNewFrame
-
>
GetParent
(
)
=
=
outOfFlowFrameItems
-
>
containingBlock
"
Parent
of
the
frame
is
not
the
containing
block
?
"
)
;
frameItems
=
outOfFlowFrameItems
;
}
else
{
frameItems
=
&
aFrameItems
;
placeholderType
=
nsFrameState
(
0
)
;
}
if
(
placeholderType
)
{
NS_ASSERTION
(
frameItems
!
=
&
aFrameItems
"
Putting
frame
in
-
flow
_and_
want
a
placeholder
?
"
)
;
nsIFrame
*
placeholderFrame
=
nsCSSFrameConstructor
:
:
CreatePlaceholderFrameFor
(
mPresShell
aContent
aNewFrame
aParentFrame
nullptr
placeholderType
)
;
placeholderFrame
-
>
AddStateBits
(
mAdditionalStateBits
)
;
aFrameItems
.
AddChild
(
placeholderFrame
)
;
if
(
placeholderType
&
PLACEHOLDER_FOR_TOPLAYER
)
{
ConstructBackdropFrameFor
(
aContent
aNewFrame
)
;
}
}
#
ifdef
DEBUG
else
{
NS_ASSERTION
(
aNewFrame
-
>
GetParent
(
)
=
=
aParentFrame
"
In
-
flow
frame
has
wrong
parent
"
)
;
}
#
endif
if
(
aInsertAfter
)
{
frameItems
-
>
InsertFrame
(
nullptr
aInsertAfterFrame
aNewFrame
)
;
}
else
{
frameItems
-
>
AddChild
(
aNewFrame
)
;
}
}
void
nsFrameConstructorState
:
:
ProcessFrameInsertions
(
nsAbsoluteItems
&
aFrameItems
ChildListID
aChildListID
)
{
#
define
NS_NONXUL_LIST_TEST
\
(
&
aFrameItems
=
=
&
mFloatedItems
&
&
aChildListID
=
=
nsIFrame
:
:
kFloatList
)
|
|
\
(
(
&
aFrameItems
=
=
&
mAbsoluteItems
|
|
\
&
aFrameItems
=
=
&
mTopLayerAbsoluteItems
)
&
&
\
aChildListID
=
=
nsIFrame
:
:
kAbsoluteList
)
|
|
\
(
(
&
aFrameItems
=
=
&
mFixedItems
|
|
\
&
aFrameItems
=
=
&
mTopLayerFixedItems
)
&
&
\
aChildListID
=
=
nsIFrame
:
:
kFixedList
)
#
ifdef
MOZ_XUL
MOZ_ASSERT
(
NS_NONXUL_LIST_TEST
|
|
(
&
aFrameItems
=
=
&
mPopupItems
&
&
aChildListID
=
=
nsIFrame
:
:
kPopupList
)
"
Unexpected
aFrameItems
/
aChildListID
combination
"
)
;
#
else
MOZ_ASSERT
(
NS_NONXUL_LIST_TEST
"
Unexpected
aFrameItems
/
aChildListID
combination
"
)
;
#
endif
if
(
aFrameItems
.
IsEmpty
(
)
)
{
return
;
}
nsContainerFrame
*
containingBlock
=
aFrameItems
.
containingBlock
;
NS_ASSERTION
(
containingBlock
"
Child
list
without
containing
block
?
"
)
;
if
(
aChildListID
=
=
nsIFrame
:
:
kFixedList
)
{
aChildListID
=
containingBlock
-
>
GetAbsoluteListID
(
)
;
}
const
nsFrameList
&
childList
=
containingBlock
-
>
GetChildList
(
aChildListID
)
;
if
(
childList
.
IsEmpty
(
)
&
&
(
containingBlock
-
>
GetStateBits
(
)
&
NS_FRAME_FIRST_REFLOW
)
)
{
if
(
aChildListID
=
=
containingBlock
-
>
GetAbsoluteListID
(
)
)
{
containingBlock
-
>
GetAbsoluteContainingBlock
(
)
-
>
SetInitialChildList
(
containingBlock
aChildListID
aFrameItems
)
;
}
else
{
containingBlock
-
>
SetInitialChildList
(
aChildListID
aFrameItems
)
;
}
}
else
if
(
aChildListID
=
=
nsIFrame
:
:
kFixedList
|
|
aChildListID
=
=
nsIFrame
:
:
kAbsoluteList
)
{
mFrameManager
-
>
AppendFrames
(
containingBlock
aChildListID
aFrameItems
)
;
}
else
{
nsIFrame
*
lastChild
=
childList
.
LastChild
(
)
;
nsIFrame
*
firstNewFrame
=
aFrameItems
.
FirstChild
(
)
;
AutoTArray
<
nsIFrame
*
20
>
firstNewFrameAncestors
;
nsIFrame
*
notCommonAncestor
=
nullptr
;
if
(
lastChild
)
{
notCommonAncestor
=
nsLayoutUtils
:
:
FillAncestors
(
firstNewFrame
containingBlock
&
firstNewFrameAncestors
)
;
}
if
(
!
lastChild
|
|
nsLayoutUtils
:
:
CompareTreePosition
(
lastChild
firstNewFrame
firstNewFrameAncestors
notCommonAncestor
?
containingBlock
:
nullptr
)
<
0
)
{
mFrameManager
-
>
AppendFrames
(
containingBlock
aChildListID
aFrameItems
)
;
}
else
{
AutoTArray
<
nsIFrame
*
128
>
children
;
for
(
nsIFrame
*
f
=
childList
.
FirstChild
(
)
;
f
!
=
lastChild
;
f
=
f
-
>
GetNextSibling
(
)
)
{
children
.
AppendElement
(
f
)
;
}
nsIFrame
*
insertionPoint
=
nullptr
;
int32_t
imin
=
0
;
int32_t
max
=
children
.
Length
(
)
;
while
(
max
>
imin
)
{
int32_t
imid
=
imin
+
(
(
max
-
imin
)
/
2
)
;
nsIFrame
*
f
=
children
[
imid
]
;
int32_t
compare
=
nsLayoutUtils
:
:
CompareTreePosition
(
f
firstNewFrame
firstNewFrameAncestors
notCommonAncestor
?
containingBlock
:
nullptr
)
;
if
(
compare
>
0
)
{
max
=
imid
;
insertionPoint
=
imid
>
0
?
children
[
imid
-
1
]
:
nullptr
;
}
else
if
(
compare
<
0
)
{
imin
=
imid
+
1
;
insertionPoint
=
f
;
}
else
{
NS_WARNING
(
"
Something
odd
happening
?
?
?
"
)
;
insertionPoint
=
nullptr
;
for
(
uint32_t
i
=
0
;
i
<
children
.
Length
(
)
;
+
+
i
)
{
nsIFrame
*
f
=
children
[
i
]
;
if
(
nsLayoutUtils
:
:
CompareTreePosition
(
f
firstNewFrame
firstNewFrameAncestors
notCommonAncestor
?
containingBlock
:
nullptr
)
>
0
)
{
break
;
}
insertionPoint
=
f
;
}
break
;
}
}
mFrameManager
-
>
InsertFrames
(
containingBlock
aChildListID
insertionPoint
aFrameItems
)
;
}
}
MOZ_ASSERT
(
aFrameItems
.
IsEmpty
(
)
"
How
did
that
happen
?
"
)
;
}
nsFrameConstructorSaveState
:
:
nsFrameConstructorSaveState
(
)
:
mItems
(
nullptr
)
mSavedItems
(
nullptr
)
mChildListID
(
kPrincipalList
)
mState
(
nullptr
)
mSavedFixedItems
(
nullptr
)
mSavedFixedPosIsAbsPos
(
false
)
{
}
nsFrameConstructorSaveState
:
:
~
nsFrameConstructorSaveState
(
)
{
if
(
mItems
)
{
NS_ASSERTION
(
mState
"
Can
'
t
have
mItems
set
without
having
a
state
!
"
)
;
mState
-
>
ProcessFrameInsertions
(
*
mItems
mChildListID
)
;
*
mItems
=
mSavedItems
;
#
ifdef
DEBUG
mSavedItems
.
Clear
(
)
;
#
endif
if
(
mItems
=
=
&
mState
-
>
mAbsoluteItems
)
{
mState
-
>
mFixedPosIsAbsPos
=
mSavedFixedPosIsAbsPos
;
if
(
mSavedFixedPosIsAbsPos
)
{
mState
-
>
mAbsoluteItems
=
mState
-
>
mFixedItems
;
mState
-
>
mFixedItems
=
mSavedFixedItems
;
#
ifdef
DEBUG
mSavedFixedItems
.
Clear
(
)
;
#
endif
}
}
NS_ASSERTION
(
!
mItems
-
>
LastChild
(
)
|
|
!
mItems
-
>
LastChild
(
)
-
>
GetNextSibling
(
)
"
Something
corrupted
our
list
"
)
;
}
}
static
void
MoveChildrenTo
(
nsIFrame
*
aOldParent
nsContainerFrame
*
aNewParent
nsFrameList
&
aFrameList
)
{
bool
sameGrandParent
=
aOldParent
-
>
GetParent
(
)
=
=
aNewParent
-
>
GetParent
(
)
;
if
(
aNewParent
-
>
HasView
(
)
|
|
aOldParent
-
>
HasView
(
)
|
|
!
sameGrandParent
)
{
nsContainerFrame
:
:
ReparentFrameViewList
(
aFrameList
aOldParent
aNewParent
)
;
}
for
(
nsFrameList
:
:
Enumerator
e
(
aFrameList
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
)
{
e
.
get
(
)
-
>
SetParent
(
aNewParent
)
;
}
if
(
aNewParent
-
>
PrincipalChildList
(
)
.
IsEmpty
(
)
&
&
(
aNewParent
-
>
GetStateBits
(
)
&
NS_FRAME_FIRST_REFLOW
)
)
{
aNewParent
-
>
SetInitialChildList
(
kPrincipalList
aFrameList
)
;
}
else
{
aNewParent
-
>
AppendFrames
(
kPrincipalList
aFrameList
)
;
}
}
static
bool
ShouldCreateImageFrameForContent
(
const
Element
&
aElement
ComputedStyle
&
aStyle
)
{
if
(
aElement
.
IsRootOfNativeAnonymousSubtree
(
)
)
{
return
false
;
}
auto
&
content
=
*
aStyle
.
StyleContent
(
)
;
if
(
content
.
ContentCount
(
)
!
=
1
)
{
return
false
;
}
return
content
.
ContentAt
(
0
)
.
GetType
(
)
=
=
StyleContentType
:
:
Image
;
}
nsCSSFrameConstructor
:
:
nsCSSFrameConstructor
(
Document
*
aDocument
nsIPresShell
*
aPresShell
)
:
nsFrameManager
(
aPresShell
)
mDocument
(
aDocument
)
mRootElementFrame
(
nullptr
)
mRootElementStyleFrame
(
nullptr
)
mDocElementContainingBlock
(
nullptr
)
mPageSequenceFrame
(
nullptr
)
mFirstFreeFCItem
(
nullptr
)
mFCItemsInUse
(
0
)
mCurrentDepth
(
0
)
mQuotesDirty
(
false
)
mCountersDirty
(
false
)
mIsDestroyingFrameTree
(
false
)
mHasRootAbsPosContainingBlock
(
false
)
mAlwaysCreateFramesForIgnorableWhitespace
(
false
)
{
#
ifdef
DEBUG
static
bool
gFirstTime
=
true
;
if
(
gFirstTime
)
{
gFirstTime
=
false
;
char
*
flags
=
PR_GetEnv
(
"
GECKO_FRAMECTOR_DEBUG_FLAGS
"
)
;
if
(
flags
)
{
bool
error
=
false
;
for
(
;
;
)
{
char
*
comma
=
PL_strchr
(
flags
'
'
)
;
if
(
comma
)
*
comma
=
'
\
0
'
;
bool
found
=
false
;
FrameCtorDebugFlags
*
flag
=
gFlags
;
FrameCtorDebugFlags
*
limit
=
gFlags
+
NUM_DEBUG_FLAGS
;
while
(
flag
<
limit
)
{
if
(
PL_strcasecmp
(
flag
-
>
name
flags
)
=
=
0
)
{
*
(
flag
-
>
on
)
=
true
;
printf
(
"
nsCSSFrameConstructor
:
setting
%
s
debug
flag
on
\
n
"
flag
-
>
name
)
;
found
=
true
;
break
;
}
+
+
flag
;
}
if
(
!
found
)
error
=
true
;
if
(
!
comma
)
break
;
*
comma
=
'
'
;
flags
=
comma
+
1
;
}
if
(
error
)
{
printf
(
"
Here
are
the
available
GECKO_FRAMECTOR_DEBUG_FLAGS
:
\
n
"
)
;
FrameCtorDebugFlags
*
flag
=
gFlags
;
FrameCtorDebugFlags
*
limit
=
gFlags
+
NUM_DEBUG_FLAGS
;
while
(
flag
<
limit
)
{
printf
(
"
%
s
\
n
"
flag
-
>
name
)
;
+
+
flag
;
}
printf
(
"
Note
:
GECKO_FRAMECTOR_DEBUG_FLAGS
is
a
comma
separated
list
of
"
"
flag
\
n
"
)
;
printf
(
"
names
(
no
whitespace
)
\
n
"
)
;
}
}
}
#
endif
}
void
nsCSSFrameConstructor
:
:
NotifyDestroyingFrame
(
nsIFrame
*
aFrame
)
{
if
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_GENERATED_CONTENT
)
{
if
(
mQuoteList
.
DestroyNodesFor
(
aFrame
)
)
QuotesDirty
(
)
;
}
if
(
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_HAS_CSS_COUNTER_STYLE
)
&
&
mCounterManager
.
DestroyNodesFor
(
aFrame
)
)
{
CountersDirty
(
)
;
}
RestyleManager
(
)
-
>
NotifyDestroyingFrame
(
aFrame
)
;
}
struct
nsGenConInitializer
{
nsAutoPtr
<
nsGenConNode
>
mNode
;
nsGenConList
*
mList
;
void
(
nsCSSFrameConstructor
:
:
*
mDirtyAll
)
(
)
;
nsGenConInitializer
(
nsGenConNode
*
aNode
nsGenConList
*
aList
void
(
nsCSSFrameConstructor
:
:
*
aDirtyAll
)
(
)
)
:
mNode
(
aNode
)
mList
(
aList
)
mDirtyAll
(
aDirtyAll
)
{
}
}
;
already_AddRefed
<
nsIContent
>
nsCSSFrameConstructor
:
:
CreateGenConTextNode
(
nsFrameConstructorState
&
aState
const
nsString
&
aString
RefPtr
<
nsTextNode
>
*
aText
nsGenConInitializer
*
aInitializer
)
{
RefPtr
<
nsTextNode
>
content
=
new
nsTextNode
(
mDocument
-
>
NodeInfoManager
(
)
)
;
content
-
>
SetText
(
aString
false
)
;
if
(
aText
)
{
*
aText
=
content
;
}
if
(
aInitializer
)
{
content
-
>
SetProperty
(
nsGkAtoms
:
:
genConInitializerProperty
aInitializer
nsINode
:
:
DeleteProperty
<
nsGenConInitializer
>
)
;
aState
.
mGeneratedTextNodesWithInitializer
.
AppendObject
(
content
)
;
}
return
content
.
forget
(
)
;
}
already_AddRefed
<
nsIContent
>
nsCSSFrameConstructor
:
:
CreateGeneratedContent
(
nsFrameConstructorState
&
aState
const
Element
&
aOriginatingElement
ComputedStyle
&
aPseudoStyle
uint32_t
aContentIndex
)
{
const
nsStyleContentData
&
data
=
aPseudoStyle
.
StyleContent
(
)
-
>
ContentAt
(
aContentIndex
)
;
const
StyleContentType
type
=
data
.
GetType
(
)
;
switch
(
type
)
{
case
StyleContentType
:
:
Image
:
return
GeneratedImageContent
:
:
Create
(
*
mDocument
aContentIndex
)
;
case
StyleContentType
:
:
String
:
return
CreateGenConTextNode
(
aState
nsDependentString
(
data
.
GetString
(
)
)
nullptr
nullptr
)
;
case
StyleContentType
:
:
Attr
:
{
const
nsStyleContentAttr
*
attr
=
data
.
GetAttr
(
)
;
RefPtr
<
nsAtom
>
attrName
=
attr
-
>
mName
;
int32_t
attrNameSpace
=
kNameSpaceID_None
;
if
(
RefPtr
<
nsAtom
>
ns
=
attr
-
>
mNamespaceURL
)
{
nsresult
rv
=
nsContentUtils
:
:
NameSpaceManager
(
)
-
>
RegisterNameSpace
(
ns
.
forget
(
)
attrNameSpace
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
}
if
(
mDocument
-
>
IsHTMLDocument
(
)
&
&
aOriginatingElement
.
IsHTMLElement
(
)
)
{
ToLowerCaseASCII
(
attrName
)
;
}
nsCOMPtr
<
nsIContent
>
content
;
NS_NewAttributeContent
(
mDocument
-
>
NodeInfoManager
(
)
attrNameSpace
attrName
getter_AddRefs
(
content
)
)
;
return
content
.
forget
(
)
;
}
case
StyleContentType
:
:
Counter
:
case
StyleContentType
:
:
Counters
:
{
nsStyleContentData
:
:
CounterFunction
*
counters
=
data
.
GetCounters
(
)
;
nsCounterList
*
counterList
=
mCounterManager
.
CounterListFor
(
counters
-
>
mIdent
)
;
nsCounterUseNode
*
node
=
new
nsCounterUseNode
(
counters
aContentIndex
type
=
=
StyleContentType
:
:
Counters
)
;
nsGenConInitializer
*
initializer
=
new
nsGenConInitializer
(
node
counterList
&
nsCSSFrameConstructor
:
:
CountersDirty
)
;
return
CreateGenConTextNode
(
aState
EmptyString
(
)
&
node
-
>
mText
initializer
)
;
}
case
StyleContentType
:
:
OpenQuote
:
case
StyleContentType
:
:
CloseQuote
:
case
StyleContentType
:
:
NoOpenQuote
:
case
StyleContentType
:
:
NoCloseQuote
:
{
nsQuoteNode
*
node
=
new
nsQuoteNode
(
type
aContentIndex
)
;
nsGenConInitializer
*
initializer
=
new
nsGenConInitializer
(
node
&
mQuoteList
&
nsCSSFrameConstructor
:
:
QuotesDirty
)
;
return
CreateGenConTextNode
(
aState
EmptyString
(
)
&
node
-
>
mText
initializer
)
;
}
case
StyleContentType
:
:
AltContent
:
{
if
(
aOriginatingElement
.
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
alt
)
)
{
nsCOMPtr
<
nsIContent
>
content
;
NS_NewAttributeContent
(
mDocument
-
>
NodeInfoManager
(
)
kNameSpaceID_None
nsGkAtoms
:
:
alt
getter_AddRefs
(
content
)
)
;
return
content
.
forget
(
)
;
}
if
(
aOriginatingElement
.
IsHTMLElement
(
nsGkAtoms
:
:
input
)
)
{
if
(
aOriginatingElement
.
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
value
)
)
{
nsCOMPtr
<
nsIContent
>
content
;
NS_NewAttributeContent
(
mDocument
-
>
NodeInfoManager
(
)
kNameSpaceID_None
nsGkAtoms
:
:
value
getter_AddRefs
(
content
)
)
;
return
content
.
forget
(
)
;
}
nsAutoString
temp
;
nsContentUtils
:
:
GetLocalizedString
(
nsContentUtils
:
:
eFORMS_PROPERTIES
"
Submit
"
temp
)
;
return
CreateGenConTextNode
(
aState
temp
nullptr
nullptr
)
;
}
break
;
}
case
StyleContentType
:
:
Uninitialized
:
MOZ_ASSERT_UNREACHABLE
(
"
uninitialized
content
type
"
)
;
return
nullptr
;
}
return
nullptr
;
}
void
nsCSSFrameConstructor
:
:
CreateGeneratedContentItem
(
nsFrameConstructorState
&
aState
nsContainerFrame
*
aParentFrame
Element
&
aOriginatingElement
ComputedStyle
&
aStyle
CSSPseudoElementType
aPseudoElement
FrameConstructionItemList
&
aItems
)
{
MOZ_ASSERT
(
aPseudoElement
=
=
CSSPseudoElementType
:
:
before
|
|
aPseudoElement
=
=
CSSPseudoElementType
:
:
after
"
unexpected
aPseudoElement
"
)
;
if
(
aParentFrame
&
&
(
aParentFrame
-
>
IsHTMLVideoFrame
(
)
|
|
aParentFrame
-
>
IsDateTimeControlFrame
(
)
)
)
{
return
;
}
ServoStyleSet
*
styleSet
=
mPresShell
-
>
StyleSet
(
)
;
RefPtr
<
ComputedStyle
>
pseudoStyle
=
styleSet
-
>
ProbePseudoElementStyle
(
aOriginatingElement
aPseudoElement
&
aStyle
)
;
if
(
!
pseudoStyle
)
{
return
;
}
bool
isBefore
=
aPseudoElement
=
=
CSSPseudoElementType
:
:
before
;
nsAtom
*
elemName
=
isBefore
?
nsGkAtoms
:
:
mozgeneratedcontentbefore
:
nsGkAtoms
:
:
mozgeneratedcontentafter
;
RefPtr
<
NodeInfo
>
nodeInfo
=
mDocument
-
>
NodeInfoManager
(
)
-
>
GetNodeInfo
(
elemName
nullptr
kNameSpaceID_None
nsINode
:
:
ELEMENT_NODE
)
;
RefPtr
<
Element
>
container
;
nsresult
rv
=
NS_NewXMLElement
(
getter_AddRefs
(
container
)
nodeInfo
.
forget
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
;
}
nsAtom
*
property
=
isBefore
?
nsGkAtoms
:
:
beforePseudoProperty
:
nsGkAtoms
:
:
afterPseudoProperty
;
aOriginatingElement
.
SetProperty
(
property
container
.
get
(
)
)
;
container
-
>
SetIsNativeAnonymousRoot
(
)
;
container
-
>
SetPseudoElementType
(
aPseudoElement
)
;
Document
*
bindDocument
=
aOriginatingElement
.
HasFlag
(
NODE_IS_IN_SHADOW_TREE
)
?
nullptr
:
mDocument
;
rv
=
container
-
>
BindToTree
(
bindDocument
&
aOriginatingElement
&
aOriginatingElement
)
;
if
(
NS_FAILED
(
rv
)
)
{
container
-
>
UnbindFromTree
(
)
;
return
;
}
if
(
!
Servo_ComputedValues_SpecifiesAnimationsOrTransitions
(
pseudoStyle
)
)
{
Servo_SetExplicitStyle
(
container
pseudoStyle
)
;
}
else
{
mPresShell
-
>
StyleSet
(
)
-
>
StyleNewSubtree
(
container
)
;
pseudoStyle
=
styleSet
-
>
ResolveServoStyle
(
*
container
)
;
}
uint32_t
contentCount
=
pseudoStyle
-
>
StyleContent
(
)
-
>
ContentCount
(
)
;
for
(
uint32_t
contentIndex
=
0
;
contentIndex
<
contentCount
;
contentIndex
+
+
)
{
nsCOMPtr
<
nsIContent
>
content
=
CreateGeneratedContent
(
aState
aOriginatingElement
*
pseudoStyle
contentIndex
)
;
if
(
!
content
)
{
continue
;
}
content
-
>
SetFlags
(
NODE_IS_IN_NATIVE_ANONYMOUS_SUBTREE
)
;
container
-
>
AppendChildTo
(
content
false
)
;
if
(
auto
*
element
=
Element
:
:
FromNode
(
content
)
)
{
mPresShell
-
>
StyleSet
(
)
-
>
StyleNewSubtree
(
element
)
;
}
}
AddFrameConstructionItemsInternal
(
aState
container
aParentFrame
true
pseudoStyle
ITEM_IS_GENERATED_CONTENT
aItems
)
;
}
static
bool
IsTablePseudo
(
nsIFrame
*
aFrame
)
{
nsAtom
*
pseudoType
=
aFrame
-
>
Style
(
)
-
>
GetPseudo
(
)
;
return
pseudoType
&
&
(
pseudoType
=
=
nsCSSAnonBoxes
:
:
table
(
)
|
|
pseudoType
=
=
nsCSSAnonBoxes
:
:
inlineTable
(
)
|
|
pseudoType
=
=
nsCSSAnonBoxes
:
:
tableColGroup
(
)
|
|
pseudoType
=
=
nsCSSAnonBoxes
:
:
tableRowGroup
(
)
|
|
pseudoType
=
=
nsCSSAnonBoxes
:
:
tableRow
(
)
|
|
pseudoType
=
=
nsCSSAnonBoxes
:
:
tableCell
(
)
|
|
(
pseudoType
=
=
nsCSSAnonBoxes
:
:
cellContent
(
)
&
&
aFrame
-
>
GetParent
(
)
-
>
Style
(
)
-
>
GetPseudo
(
)
=
=
nsCSSAnonBoxes
:
:
tableCell
(
)
)
|
|
(
pseudoType
=
=
nsCSSAnonBoxes
:
:
tableWrapper
(
)
&
&
(
aFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
-
>
Style
(
)
-
>
GetPseudo
(
)
=
=
nsCSSAnonBoxes
:
:
table
(
)
|
|
aFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
-
>
Style
(
)
-
>
GetPseudo
(
)
=
=
nsCSSAnonBoxes
:
:
inlineTable
(
)
)
)
)
;
}
static
bool
IsRubyPseudo
(
nsIFrame
*
aFrame
)
{
return
RubyUtils
:
:
IsRubyPseudo
(
aFrame
-
>
Style
(
)
-
>
GetPseudo
(
)
)
;
}
static
bool
IsTableOrRubyPseudo
(
nsIFrame
*
aFrame
)
{
return
IsTablePseudo
(
aFrame
)
|
|
IsRubyPseudo
(
aFrame
)
;
}
nsCSSFrameConstructor
:
:
ParentType
nsCSSFrameConstructor
:
:
GetParentType
(
LayoutFrameType
aFrameType
)
{
if
(
aFrameType
=
=
LayoutFrameType
:
:
Table
)
{
return
eTypeTable
;
}
if
(
aFrameType
=
=
LayoutFrameType
:
:
TableRowGroup
)
{
return
eTypeRowGroup
;
}
if
(
aFrameType
=
=
LayoutFrameType
:
:
TableRow
)
{
return
eTypeRow
;
}
if
(
aFrameType
=
=
LayoutFrameType
:
:
TableColGroup
)
{
return
eTypeColGroup
;
}
if
(
aFrameType
=
=
LayoutFrameType
:
:
RubyBaseContainer
)
{
return
eTypeRubyBaseContainer
;
}
if
(
aFrameType
=
=
LayoutFrameType
:
:
RubyTextContainer
)
{
return
eTypeRubyTextContainer
;
}
if
(
aFrameType
=
=
LayoutFrameType
:
:
Ruby
)
{
return
eTypeRuby
;
}
return
eTypeBlock
;
}
static
nsContainerFrame
*
AdjustCaptionParentFrame
(
nsContainerFrame
*
aParentFrame
)
{
if
(
aParentFrame
-
>
IsTableFrame
(
)
)
{
return
aParentFrame
-
>
GetParent
(
)
;
}
return
aParentFrame
;
}
static
bool
GetCaptionAdjustedParent
(
nsContainerFrame
*
aParentFrame
const
nsIFrame
*
aChildFrame
nsContainerFrame
*
*
aAdjParentFrame
)
{
*
aAdjParentFrame
=
aParentFrame
;
bool
haveCaption
=
false
;
if
(
aChildFrame
-
>
IsTableCaption
(
)
)
{
haveCaption
=
true
;
*
aAdjParentFrame
=
:
:
AdjustCaptionParentFrame
(
aParentFrame
)
;
}
return
haveCaption
;
}
void
nsCSSFrameConstructor
:
:
AdjustParentFrame
(
nsContainerFrame
*
*
aParentFrame
const
FrameConstructionData
*
aFCData
ComputedStyle
*
aComputedStyle
)
{
MOZ_ASSERT
(
aComputedStyle
"
Must
have
child
'
s
style
"
)
;
MOZ_ASSERT
(
aFCData
"
Must
have
frame
construction
data
"
)
;
bool
tablePart
=
(
(
aFCData
-
>
mBits
&
FCDATA_IS_TABLE_PART
)
!
=
0
)
;
if
(
tablePart
&
&
aComputedStyle
-
>
StyleDisplay
(
)
-
>
mDisplay
=
=
StyleDisplay
:
:
TableCaption
)
{
*
aParentFrame
=
:
:
AdjustCaptionParentFrame
(
*
aParentFrame
)
;
}
}
static
void
PullOutCaptionFrames
(
nsFrameItems
&
aItems
nsFrameItems
&
aCaptions
)
{
nsIFrame
*
child
=
aItems
.
FirstChild
(
)
;
while
(
child
)
{
nsIFrame
*
nextSibling
=
child
-
>
GetNextSibling
(
)
;
if
(
child
-
>
IsTableCaption
(
)
)
{
aItems
.
RemoveFrame
(
child
)
;
aCaptions
.
AddChild
(
child
)
;
}
child
=
nextSibling
;
}
}
nsIFrame
*
nsCSSFrameConstructor
:
:
ConstructTable
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aDisplay
nsFrameItems
&
aFrameItems
)
{
MOZ_ASSERT
(
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
Table
|
|
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
InlineTable
"
Unexpected
call
"
)
;
nsIContent
*
const
content
=
aItem
.
mContent
;
ComputedStyle
*
const
computedStyle
=
aItem
.
mComputedStyle
;
const
bool
isMathMLContent
=
content
-
>
IsMathMLElement
(
)
;
RefPtr
<
ComputedStyle
>
outerComputedStyle
;
outerComputedStyle
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveInheritingAnonymousBoxStyle
(
nsCSSAnonBoxes
:
:
tableWrapper
(
)
computedStyle
)
;
nsContainerFrame
*
newFrame
;
if
(
isMathMLContent
)
newFrame
=
NS_NewMathMLmtableOuterFrame
(
mPresShell
outerComputedStyle
)
;
else
newFrame
=
NS_NewTableWrapperFrame
(
mPresShell
outerComputedStyle
)
;
nsContainerFrame
*
geometricParent
=
aState
.
GetGeometricParent
(
*
outerComputedStyle
-
>
StyleDisplay
(
)
aParentFrame
)
;
InitAndRestoreFrame
(
aState
content
geometricParent
newFrame
)
;
nsContainerFrame
*
innerFrame
;
if
(
isMathMLContent
)
innerFrame
=
NS_NewMathMLmtableFrame
(
mPresShell
computedStyle
)
;
else
innerFrame
=
NS_NewTableFrame
(
mPresShell
computedStyle
)
;
InitAndRestoreFrame
(
aState
content
newFrame
innerFrame
)
;
innerFrame
-
>
AddStateBits
(
NS_FRAME_OWNS_ANON_BOXES
)
;
SetInitialSingleChild
(
newFrame
innerFrame
)
;
aState
.
AddChild
(
newFrame
aFrameItems
content
aParentFrame
)
;
if
(
!
mRootElementFrame
)
{
mRootElementFrame
=
newFrame
;
}
nsFrameItems
childItems
;
nsFrameConstructorSaveState
absoluteSaveState
;
const
nsStyleDisplay
*
display
=
outerComputedStyle
-
>
StyleDisplay
(
)
;
newFrame
-
>
AddStateBits
(
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
;
if
(
display
-
>
IsAbsPosContainingBlock
(
newFrame
)
)
{
aState
.
PushAbsoluteContainingBlock
(
newFrame
newFrame
absoluteSaveState
)
;
}
if
(
aItem
.
mFCData
-
>
mBits
&
FCDATA_USE_CHILD_ITEMS
)
{
ConstructFramesFromItemList
(
aState
aItem
.
mChildItems
innerFrame
aItem
.
mFCData
-
>
mBits
&
FCDATA_IS_WRAPPER_ANON_BOX
childItems
)
;
}
else
{
ProcessChildren
(
aState
content
computedStyle
innerFrame
true
childItems
false
aItem
.
mPendingBinding
)
;
}
nsFrameItems
captionItems
;
PullOutCaptionFrames
(
childItems
captionItems
)
;
innerFrame
-
>
SetInitialChildList
(
kPrincipalList
childItems
)
;
if
(
captionItems
.
NotEmpty
(
)
)
{
newFrame
-
>
SetInitialChildList
(
nsIFrame
:
:
kCaptionList
captionItems
)
;
}
return
newFrame
;
}
static
void
MakeTablePartAbsoluteContainingBlockIfNeeded
(
nsFrameConstructorState
&
aState
const
nsStyleDisplay
*
aDisplay
nsFrameConstructorSaveState
&
aAbsSaveState
nsContainerFrame
*
aFrame
)
{
if
(
aDisplay
-
>
IsAbsPosContainingBlock
(
aFrame
)
)
{
aFrame
-
>
AddStateBits
(
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
;
aState
.
PushAbsoluteContainingBlock
(
aFrame
aFrame
aAbsSaveState
)
;
nsTableFrame
:
:
RegisterPositionedTablePart
(
aFrame
)
;
}
}
nsIFrame
*
nsCSSFrameConstructor
:
:
ConstructTableRowOrRowGroup
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aDisplay
nsFrameItems
&
aFrameItems
)
{
MOZ_ASSERT
(
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
TableRow
|
|
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
TableRowGroup
|
|
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
TableFooterGroup
|
|
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
TableHeaderGroup
"
Not
a
row
or
row
group
"
)
;
MOZ_ASSERT
(
aItem
.
mComputedStyle
-
>
StyleDisplay
(
)
=
=
aDisplay
"
Display
style
doesn
'
t
match
style
"
)
;
nsIContent
*
const
content
=
aItem
.
mContent
;
ComputedStyle
*
const
computedStyle
=
aItem
.
mComputedStyle
;
nsContainerFrame
*
newFrame
;
if
(
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
TableRow
)
{
if
(
content
-
>
IsMathMLElement
(
)
)
newFrame
=
NS_NewMathMLmtrFrame
(
mPresShell
computedStyle
)
;
else
newFrame
=
NS_NewTableRowFrame
(
mPresShell
computedStyle
)
;
}
else
{
newFrame
=
NS_NewTableRowGroupFrame
(
mPresShell
computedStyle
)
;
}
InitAndRestoreFrame
(
aState
content
aParentFrame
newFrame
)
;
nsFrameConstructorSaveState
absoluteSaveState
;
MakeTablePartAbsoluteContainingBlockIfNeeded
(
aState
aDisplay
absoluteSaveState
newFrame
)
;
nsFrameItems
childItems
;
if
(
aItem
.
mFCData
-
>
mBits
&
FCDATA_USE_CHILD_ITEMS
)
{
ConstructFramesFromItemList
(
aState
aItem
.
mChildItems
newFrame
aItem
.
mFCData
-
>
mBits
&
FCDATA_IS_WRAPPER_ANON_BOX
childItems
)
;
}
else
{
ProcessChildren
(
aState
content
computedStyle
newFrame
true
childItems
false
aItem
.
mPendingBinding
)
;
}
newFrame
-
>
SetInitialChildList
(
kPrincipalList
childItems
)
;
aFrameItems
.
AddChild
(
newFrame
)
;
return
newFrame
;
}
nsIFrame
*
nsCSSFrameConstructor
:
:
ConstructTableCol
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aStyleDisplay
nsFrameItems
&
aFrameItems
)
{
nsIContent
*
const
content
=
aItem
.
mContent
;
ComputedStyle
*
const
computedStyle
=
aItem
.
mComputedStyle
;
nsTableColFrame
*
colFrame
=
NS_NewTableColFrame
(
mPresShell
computedStyle
)
;
InitAndRestoreFrame
(
aState
content
aParentFrame
colFrame
)
;
NS_ASSERTION
(
colFrame
-
>
Style
(
)
=
=
computedStyle
"
Unexpected
style
"
)
;
aFrameItems
.
AddChild
(
colFrame
)
;
int32_t
span
=
colFrame
-
>
GetSpan
(
)
;
for
(
int32_t
spanX
=
1
;
spanX
<
span
;
spanX
+
+
)
{
nsTableColFrame
*
newCol
=
NS_NewTableColFrame
(
mPresShell
computedStyle
)
;
InitAndRestoreFrame
(
aState
content
aParentFrame
newCol
false
)
;
aFrameItems
.
LastChild
(
)
-
>
SetNextContinuation
(
newCol
)
;
newCol
-
>
SetPrevContinuation
(
aFrameItems
.
LastChild
(
)
)
;
aFrameItems
.
AddChild
(
newCol
)
;
newCol
-
>
SetColType
(
eColAnonymousCol
)
;
}
return
colFrame
;
}
nsIFrame
*
nsCSSFrameConstructor
:
:
ConstructTableCell
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aDisplay
nsFrameItems
&
aFrameItems
)
{
MOZ_ASSERT
(
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
TableCell
"
Unexpected
call
"
)
;
nsIContent
*
const
content
=
aItem
.
mContent
;
ComputedStyle
*
const
computedStyle
=
aItem
.
mComputedStyle
;
const
bool
isMathMLContent
=
content
-
>
IsMathMLElement
(
)
;
nsTableFrame
*
tableFrame
=
static_cast
<
nsTableRowFrame
*
>
(
aParentFrame
)
-
>
GetTableFrame
(
)
;
nsContainerFrame
*
newFrame
;
if
(
isMathMLContent
&
&
!
tableFrame
-
>
IsBorderCollapse
(
)
)
{
newFrame
=
NS_NewMathMLmtdFrame
(
mPresShell
computedStyle
tableFrame
)
;
}
else
{
newFrame
=
NS_NewTableCellFrame
(
mPresShell
computedStyle
tableFrame
)
;
}
InitAndRestoreFrame
(
aState
content
aParentFrame
newFrame
)
;
newFrame
-
>
AddStateBits
(
NS_FRAME_OWNS_ANON_BOXES
)
;
RefPtr
<
ComputedStyle
>
innerPseudoStyle
;
innerPseudoStyle
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveInheritingAnonymousBoxStyle
(
nsCSSAnonBoxes
:
:
cellContent
(
)
computedStyle
)
;
bool
isBlock
;
nsContainerFrame
*
cellInnerFrame
;
if
(
isMathMLContent
)
{
cellInnerFrame
=
NS_NewMathMLmtdInnerFrame
(
mPresShell
innerPseudoStyle
)
;
isBlock
=
false
;
}
else
{
cellInnerFrame
=
NS_NewBlockFormattingContext
(
mPresShell
innerPseudoStyle
)
;
isBlock
=
true
;
}
InitAndRestoreFrame
(
aState
content
newFrame
cellInnerFrame
)
;
nsFrameConstructorSaveState
absoluteSaveState
;
MakeTablePartAbsoluteContainingBlockIfNeeded
(
aState
aDisplay
absoluteSaveState
newFrame
)
;
nsFrameItems
childItems
;
if
(
aItem
.
mFCData
-
>
mBits
&
FCDATA_USE_CHILD_ITEMS
)
{
nsFrameConstructorSaveState
floatSaveState
;
if
(
!
isBlock
)
{
aState
.
PushFloatContainingBlock
(
nullptr
floatSaveState
)
;
}
else
{
aState
.
PushFloatContainingBlock
(
cellInnerFrame
floatSaveState
)
;
}
ConstructFramesFromItemList
(
aState
aItem
.
mChildItems
cellInnerFrame
aItem
.
mFCData
-
>
mBits
&
FCDATA_IS_WRAPPER_ANON_BOX
childItems
)
;
}
else
{
ProcessChildren
(
aState
content
computedStyle
cellInnerFrame
true
childItems
isBlock
aItem
.
mPendingBinding
)
;
}
cellInnerFrame
-
>
SetInitialChildList
(
kPrincipalList
childItems
)
;
SetInitialSingleChild
(
newFrame
cellInnerFrame
)
;
aFrameItems
.
AddChild
(
newFrame
)
;
return
newFrame
;
}
static
inline
bool
NeedFrameFor
(
const
nsFrameConstructorState
&
aState
nsIFrame
*
aParentFrame
nsIContent
*
aChildContent
)
{
MOZ_ASSERT
(
!
aChildContent
-
>
GetPrimaryFrame
(
)
|
|
aState
.
mCreatingExtraFrames
|
|
aChildContent
-
>
GetPrimaryFrame
(
)
-
>
GetContent
(
)
!
=
aChildContent
"
Why
did
we
get
called
?
"
)
;
if
(
(
aParentFrame
&
&
(
!
aParentFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eExcludesIgnorableWhitespace
)
|
|
aParentFrame
-
>
IsGeneratedContentFrame
(
)
)
)
|
|
!
aChildContent
-
>
IsText
(
)
)
{
return
true
;
}
aChildContent
-
>
SetFlags
(
NS_CREATE_FRAME_IF_NON_WHITESPACE
|
NS_REFRAME_IF_WHITESPACE
)
;
return
!
aChildContent
-
>
TextIsOnlyWhitespace
(
)
;
}
nsIFrame
*
nsCSSFrameConstructor
:
:
ConstructDocElementFrame
(
Element
*
aDocElement
nsILayoutHistoryState
*
aFrameState
)
{
MOZ_ASSERT
(
GetRootFrame
(
)
"
No
viewport
?
Someone
forgot
to
call
ConstructRootFrame
!
"
)
;
MOZ_ASSERT
(
!
mDocElementContainingBlock
"
Shouldn
'
t
have
a
doc
element
containing
block
here
"
)
;
{
RefPtr
<
ComputedStyle
>
sc
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveInheritingAnonymousBoxStyle
(
nsCSSAnonBoxes
:
:
viewport
(
)
nullptr
)
;
GetRootFrame
(
)
-
>
SetComputedStyleWithoutNotification
(
sc
)
;
}
DebugOnly
<
nsIContent
*
>
propagatedScrollFrom
;
if
(
nsPresContext
*
presContext
=
mPresShell
-
>
GetPresContext
(
)
)
{
propagatedScrollFrom
=
presContext
-
>
UpdateViewportScrollStylesOverride
(
)
;
}
SetUpDocElementContainingBlock
(
aDocElement
)
;
NS_ASSERTION
(
mDocElementContainingBlock
"
Should
have
parent
by
now
"
)
;
nsFrameConstructorState
state
(
mPresShell
GetAbsoluteContainingBlock
(
mDocElementContainingBlock
FIXED_POS
)
nullptr
nullptr
do_AddRef
(
aFrameState
)
)
;
if
(
!
mTempFrameTreeState
)
state
.
mPresShell
-
>
CaptureHistoryState
(
getter_AddRefs
(
mTempFrameTreeState
)
)
;
ServoStyleSet
*
set
=
mPresShell
-
>
StyleSet
(
)
;
if
(
!
aDocElement
-
>
HasServoData
(
)
)
{
set
-
>
StyleNewSubtree
(
aDocElement
)
;
}
RefPtr
<
ComputedStyle
>
computedStyle
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveServoStyle
(
*
aDocElement
)
;
const
nsStyleDisplay
*
display
=
computedStyle
-
>
StyleDisplay
(
)
;
if
(
display
-
>
mBinding
)
{
nsresult
rv
;
bool
resolveStyle
;
nsXBLService
*
xblService
=
nsXBLService
:
:
GetInstance
(
)
;
if
(
!
xblService
)
{
return
nullptr
;
}
RefPtr
<
nsXBLBinding
>
binding
;
rv
=
xblService
-
>
LoadBindings
(
aDocElement
display
-
>
mBinding
-
>
GetURI
(
)
display
-
>
mBinding
-
>
ExtraData
(
)
-
>
Principal
(
)
getter_AddRefs
(
binding
)
&
resolveStyle
)
;
if
(
NS_FAILED
(
rv
)
&
&
rv
!
=
NS_ERROR_XBL_BLOCKED
)
{
return
nullptr
;
}
if
(
binding
)
{
mDocument
-
>
BindingManager
(
)
-
>
AddToAttachedQueue
(
binding
)
;
}
if
(
resolveStyle
)
{
computedStyle
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveServoStyle
(
*
aDocElement
)
;
display
=
computedStyle
-
>
StyleDisplay
(
)
;
}
}
NS_ASSERTION
(
!
display
-
>
IsScrollableOverflow
(
)
|
|
state
.
mPresContext
-
>
IsPaginated
(
)
|
|
propagatedScrollFrom
=
=
aDocElement
"
Scrollbars
should
have
been
propagated
to
the
viewport
"
)
;
if
(
MOZ_UNLIKELY
(
display
-
>
mDisplay
=
=
StyleDisplay
:
:
None
)
)
{
return
nullptr
;
}
nsFrameConstructorSaveState
docElementContainingBlockAbsoluteSaveState
;
if
(
mHasRootAbsPosContainingBlock
)
{
mDocElementContainingBlock
-
>
AddStateBits
(
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
;
state
.
PushAbsoluteContainingBlock
(
mDocElementContainingBlock
mDocElementContainingBlock
docElementContainingBlockAbsoluteSaveState
)
;
}
nsContainerFrame
*
contentFrame
;
nsIFrame
*
newFrame
;
bool
processChildren
=
false
;
nsFrameConstructorSaveState
absoluteSaveState
;
#
ifdef
MOZ_XUL
if
(
aDocElement
-
>
IsXULElement
(
)
)
{
contentFrame
=
NS_NewDocElementBoxFrame
(
mPresShell
computedStyle
)
;
InitAndRestoreFrame
(
state
aDocElement
mDocElementContainingBlock
contentFrame
)
;
newFrame
=
contentFrame
;
processChildren
=
true
;
}
else
#
endif
if
(
aDocElement
-
>
IsSVGElement
(
)
)
{
if
(
!
aDocElement
-
>
IsSVGElement
(
nsGkAtoms
:
:
svg
)
)
{
return
nullptr
;
}
static
const
FrameConstructionData
rootSVGData
=
FCDATA_DECL
(
0
nullptr
)
;
AutoFrameConstructionItem
item
(
this
&
rootSVGData
aDocElement
nullptr
do_AddRef
(
computedStyle
)
true
)
;
nsFrameItems
frameItems
;
contentFrame
=
static_cast
<
nsContainerFrame
*
>
(
ConstructOuterSVG
(
state
item
mDocElementContainingBlock
computedStyle
-
>
StyleDisplay
(
)
frameItems
)
)
;
newFrame
=
frameItems
.
FirstChild
(
)
;
NS_ASSERTION
(
frameItems
.
OnlyChild
(
)
"
multiple
root
element
frames
"
)
;
}
else
if
(
display
-
>
mDisplay
=
=
StyleDisplay
:
:
Flex
|
|
display
-
>
mDisplay
=
=
StyleDisplay
:
:
WebkitBox
|
|
(
StaticPrefs
:
:
layout_css_emulate_moz_box_with_flex
(
)
&
&
display
-
>
mDisplay
=
=
StyleDisplay
:
:
MozBox
)
)
{
contentFrame
=
NS_NewFlexContainerFrame
(
mPresShell
computedStyle
)
;
InitAndRestoreFrame
(
state
aDocElement
mDocElementContainingBlock
contentFrame
)
;
newFrame
=
contentFrame
;
processChildren
=
true
;
newFrame
-
>
AddStateBits
(
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
;
if
(
display
-
>
IsAbsPosContainingBlock
(
newFrame
)
)
{
state
.
PushAbsoluteContainingBlock
(
contentFrame
newFrame
absoluteSaveState
)
;
}
}
else
if
(
display
-
>
mDisplay
=
=
StyleDisplay
:
:
Grid
)
{
contentFrame
=
NS_NewGridContainerFrame
(
mPresShell
computedStyle
)
;
InitAndRestoreFrame
(
state
aDocElement
mDocElementContainingBlock
contentFrame
)
;
newFrame
=
contentFrame
;
processChildren
=
true
;
newFrame
-
>
AddStateBits
(
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
;
if
(
display
-
>
IsAbsPosContainingBlock
(
newFrame
)
)
{
state
.
PushAbsoluteContainingBlock
(
contentFrame
newFrame
absoluteSaveState
)
;
}
}
else
if
(
display
-
>
mDisplay
=
=
StyleDisplay
:
:
Table
)
{
static
const
FrameConstructionData
rootTableData
=
FCDATA_DECL
(
0
nullptr
)
;
AutoFrameConstructionItem
item
(
this
&
rootTableData
aDocElement
nullptr
do_AddRef
(
computedStyle
)
true
)
;
nsFrameItems
frameItems
;
contentFrame
=
static_cast
<
nsContainerFrame
*
>
(
ConstructTable
(
state
item
mDocElementContainingBlock
computedStyle
-
>
StyleDisplay
(
)
frameItems
)
)
;
newFrame
=
frameItems
.
FirstChild
(
)
;
NS_ASSERTION
(
frameItems
.
OnlyChild
(
)
"
multiple
root
element
frames
"
)
;
}
else
{
MOZ_ASSERT
(
display
-
>
mDisplay
=
=
StyleDisplay
:
:
Block
|
|
display
-
>
mDisplay
=
=
StyleDisplay
:
:
FlowRoot
"
Unhandled
display
type
for
root
element
"
)
;
contentFrame
=
NS_NewBlockFormattingContext
(
mPresShell
computedStyle
)
;
nsFrameItems
frameItems
;
ConstructBlock
(
state
aDocElement
state
.
GetGeometricParent
(
*
display
mDocElementContainingBlock
)
mDocElementContainingBlock
computedStyle
&
contentFrame
frameItems
display
-
>
IsAbsPosContainingBlock
(
contentFrame
)
?
contentFrame
:
nullptr
nullptr
)
;
newFrame
=
frameItems
.
FirstChild
(
)
;
NS_ASSERTION
(
frameItems
.
OnlyChild
(
)
"
multiple
root
element
frames
"
)
;
}
MOZ_ASSERT
(
newFrame
)
;
MOZ_ASSERT
(
contentFrame
)
;
NS_ASSERTION
(
processChildren
?
!
mRootElementFrame
:
mRootElementFrame
=
=
contentFrame
"
unexpected
mRootElementFrame
"
)
;
mRootElementFrame
=
contentFrame
;
contentFrame
-
>
GetParentComputedStyle
(
&
mRootElementStyleFrame
)
;
bool
isChild
=
mRootElementStyleFrame
&
&
mRootElementStyleFrame
-
>
GetParent
(
)
=
=
contentFrame
;
if
(
!
isChild
)
{
mRootElementStyleFrame
=
mRootElementFrame
;
}
if
(
processChildren
)
{
nsFrameItems
childItems
;
NS_ASSERTION
(
!
nsLayoutUtils
:
:
GetAsBlock
(
contentFrame
)
&
&
!
contentFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
"
Only
XUL
frames
should
reach
here
"
)
;
ProcessChildren
(
state
aDocElement
computedStyle
contentFrame
true
childItems
false
nullptr
)
;
contentFrame
-
>
SetInitialChildList
(
kPrincipalList
childItems
)
;
}
aDocElement
-
>
SetPrimaryFrame
(
contentFrame
)
;
SetInitialSingleChild
(
mDocElementContainingBlock
newFrame
)
;
if
(
mDocElementContainingBlock
-
>
IsCanvasFrame
(
)
)
{
ConstructAnonymousContentForCanvas
(
state
mDocElementContainingBlock
aDocElement
)
;
}
return
newFrame
;
}
nsIFrame
*
nsCSSFrameConstructor
:
:
ConstructRootFrame
(
)
{
AUTO_PROFILER_LABEL
(
"
nsCSSFrameConstructor
:
:
ConstructRootFrame
"
LAYOUT
)
;
AUTO_LAYOUT_PHASE_ENTRY_POINT
(
mPresShell
-
>
GetPresContext
(
)
FrameC
)
;
ServoStyleSet
*
styleSet
=
mPresShell
-
>
StyleSet
(
)
;
RefPtr
<
ComputedStyle
>
viewportPseudoStyle
=
styleSet
-
>
ResolveInheritingAnonymousBoxStyle
(
nsCSSAnonBoxes
:
:
viewport
(
)
nullptr
)
;
ViewportFrame
*
viewportFrame
=
NS_NewViewportFrame
(
mPresShell
viewportPseudoStyle
)
;
viewportFrame
-
>
Init
(
nullptr
nullptr
nullptr
)
;
viewportFrame
-
>
AddStateBits
(
NS_FRAME_OWNS_ANON_BOXES
)
;
nsView
*
rootView
=
mPresShell
-
>
GetViewManager
(
)
-
>
GetRootView
(
)
;
viewportFrame
-
>
SetView
(
rootView
)
;
viewportFrame
-
>
SyncFrameViewProperties
(
rootView
)
;
nsContainerFrame
:
:
SyncWindowProperties
(
mPresShell
-
>
GetPresContext
(
)
viewportFrame
rootView
nullptr
nsContainerFrame
:
:
SET_ASYNC
)
;
viewportFrame
-
>
AddStateBits
(
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
;
viewportFrame
-
>
MarkAsAbsoluteContainingBlock
(
)
;
return
viewportFrame
;
}
void
nsCSSFrameConstructor
:
:
SetUpDocElementContainingBlock
(
nsIContent
*
aDocElement
)
{
MOZ_ASSERT
(
aDocElement
"
No
element
?
"
)
;
MOZ_ASSERT
(
!
aDocElement
-
>
GetParent
(
)
"
Not
root
content
?
"
)
;
MOZ_ASSERT
(
aDocElement
-
>
GetUncomposedDoc
(
)
"
Not
in
a
document
?
"
)
;
MOZ_ASSERT
(
aDocElement
-
>
GetUncomposedDoc
(
)
-
>
GetRootElement
(
)
=
=
aDocElement
"
Not
the
root
of
the
document
?
"
)
;
nsPresContext
*
presContext
=
mPresShell
-
>
GetPresContext
(
)
;
bool
isPaginated
=
presContext
-
>
IsRootPaginatedDocument
(
)
;
nsContainerFrame
*
viewportFrame
=
static_cast
<
nsContainerFrame
*
>
(
GetRootFrame
(
)
)
;
ComputedStyle
*
viewportPseudoStyle
=
viewportFrame
-
>
Style
(
)
;
nsContainerFrame
*
rootFrame
=
nullptr
;
nsAtom
*
rootPseudo
;
if
(
!
isPaginated
)
{
#
ifdef
MOZ_XUL
if
(
aDocElement
-
>
IsXULElement
(
)
)
{
rootFrame
=
NS_NewRootBoxFrame
(
mPresShell
viewportPseudoStyle
)
;
}
else
#
endif
{
rootFrame
=
NS_NewCanvasFrame
(
mPresShell
viewportPseudoStyle
)
;
mHasRootAbsPosContainingBlock
=
true
;
}
rootPseudo
=
nsCSSAnonBoxes
:
:
canvas
(
)
;
mDocElementContainingBlock
=
rootFrame
;
}
else
{
rootFrame
=
NS_NewSimplePageSequenceFrame
(
mPresShell
viewportPseudoStyle
)
;
mPageSequenceFrame
=
rootFrame
;
rootPseudo
=
nsCSSAnonBoxes
:
:
pageSequence
(
)
;
rootFrame
-
>
AddStateBits
(
NS_FRAME_OWNS_ANON_BOXES
)
;
}
bool
isHTML
=
aDocElement
-
>
IsHTMLElement
(
)
;
bool
isXUL
=
false
;
if
(
!
isHTML
)
{
isXUL
=
aDocElement
-
>
IsXULElement
(
)
;
}
bool
isScrollable
=
isPaginated
?
presContext
-
>
HasPaginatedScrolling
(
)
:
!
isXUL
;
NS_ASSERTION
(
!
isScrollable
|
|
!
isXUL
"
XUL
documents
should
never
be
scrollable
-
see
above
"
)
;
nsContainerFrame
*
newFrame
=
rootFrame
;
RefPtr
<
ComputedStyle
>
rootPseudoStyle
;
nsFrameConstructorState
state
(
mPresShell
nullptr
nullptr
nullptr
)
;
nsContainerFrame
*
parentFrame
=
viewportFrame
;
ServoStyleSet
*
styleSet
=
mPresShell
-
>
StyleSet
(
)
;
if
(
!
isScrollable
)
{
rootPseudoStyle
=
styleSet
-
>
ResolveInheritingAnonymousBoxStyle
(
rootPseudo
viewportPseudoStyle
)
;
}
else
{
if
(
rootPseudo
=
=
nsCSSAnonBoxes
:
:
canvas
(
)
)
{
rootPseudo
=
nsCSSAnonBoxes
:
:
scrolledCanvas
(
)
;
}
else
{
NS_ASSERTION
(
rootPseudo
=
=
nsCSSAnonBoxes
:
:
pageSequence
(
)
"
Unknown
root
pseudo
"
)
;
rootPseudo
=
nsCSSAnonBoxes
:
:
scrolledPageSequence
(
)
;
}
RefPtr
<
ComputedStyle
>
computedStyle
=
styleSet
-
>
ResolveInheritingAnonymousBoxStyle
(
nsCSSAnonBoxes
:
:
viewportScroll
(
)
viewportPseudoStyle
)
;
newFrame
=
nullptr
;
rootPseudoStyle
=
BeginBuildingScrollFrame
(
state
aDocElement
computedStyle
viewportFrame
rootPseudo
true
newFrame
)
;
parentFrame
=
newFrame
;
}
rootFrame
-
>
SetComputedStyleWithoutNotification
(
rootPseudoStyle
)
;
rootFrame
-
>
Init
(
aDocElement
parentFrame
nullptr
)
;
if
(
isScrollable
)
{
FinishBuildingScrollFrame
(
parentFrame
rootFrame
)
;
}
if
(
isPaginated
)
{
nsContainerFrame
*
canvasFrame
;
nsContainerFrame
*
pageFrame
=
ConstructPageFrame
(
mPresShell
rootFrame
nullptr
canvasFrame
)
;
pageFrame
-
>
AddStateBits
(
NS_FRAME_OWNS_ANON_BOXES
)
;
SetInitialSingleChild
(
rootFrame
pageFrame
)
;
mDocElementContainingBlock
=
canvasFrame
;
mHasRootAbsPosContainingBlock
=
true
;
}
if
(
viewportFrame
-
>
GetStateBits
(
)
&
NS_FRAME_FIRST_REFLOW
)
{
SetInitialSingleChild
(
viewportFrame
newFrame
)
;
}
else
{
nsFrameList
newFrameList
(
newFrame
newFrame
)
;
viewportFrame
-
>
AppendFrames
(
kPrincipalList
newFrameList
)
;
}
}
void
nsCSSFrameConstructor
:
:
ConstructAnonymousContentForCanvas
(
nsFrameConstructorState
&
aState
nsIFrame
*
aFrame
nsIContent
*
aDocElement
)
{
NS_ASSERTION
(
aFrame
-
>
IsCanvasFrame
(
)
"
aFrame
should
be
canvas
frame
!
"
)
;
AutoTArray
<
nsIAnonymousContentCreator
:
:
ContentInfo
4
>
anonymousItems
;
GetAnonymousContent
(
aDocElement
aFrame
anonymousItems
)
;
if
(
anonymousItems
.
IsEmpty
(
)
)
{
return
;
}
AutoFrameConstructionItemList
itemsToConstruct
(
this
)
;
nsContainerFrame
*
frameAsContainer
=
do_QueryFrame
(
aFrame
)
;
AddFCItemsForAnonymousContent
(
aState
frameAsContainer
anonymousItems
itemsToConstruct
)
;
nsFrameItems
frameItems
;
ConstructFramesFromItemList
(
aState
itemsToConstruct
frameAsContainer
false
frameItems
)
;
frameAsContainer
-
>
AppendFrames
(
kPrincipalList
frameItems
)
;
}
nsContainerFrame
*
nsCSSFrameConstructor
:
:
ConstructPageFrame
(
nsIPresShell
*
aPresShell
nsContainerFrame
*
aParentFrame
nsIFrame
*
aPrevPageFrame
nsContainerFrame
*
&
aCanvasFrame
)
{
ComputedStyle
*
parentComputedStyle
=
aParentFrame
-
>
Style
(
)
;
ServoStyleSet
*
styleSet
=
aPresShell
-
>
StyleSet
(
)
;
RefPtr
<
ComputedStyle
>
pagePseudoStyle
;
pagePseudoStyle
=
styleSet
-
>
ResolveInheritingAnonymousBoxStyle
(
nsCSSAnonBoxes
:
:
page
(
)
parentComputedStyle
)
;
nsContainerFrame
*
pageFrame
=
NS_NewPageFrame
(
aPresShell
pagePseudoStyle
)
;
pageFrame
-
>
Init
(
nullptr
aParentFrame
aPrevPageFrame
)
;
RefPtr
<
ComputedStyle
>
pageContentPseudoStyle
;
pageContentPseudoStyle
=
styleSet
-
>
ResolveInheritingAnonymousBoxStyle
(
nsCSSAnonBoxes
:
:
pageContent
(
)
pagePseudoStyle
)
;
nsContainerFrame
*
pageContentFrame
=
NS_NewPageContentFrame
(
aPresShell
pageContentPseudoStyle
)
;
nsIFrame
*
prevPageContentFrame
=
nullptr
;
if
(
aPrevPageFrame
)
{
prevPageContentFrame
=
aPrevPageFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
NS_ASSERTION
(
prevPageContentFrame
"
missing
page
content
frame
"
)
;
}
pageContentFrame
-
>
Init
(
nullptr
pageFrame
prevPageContentFrame
)
;
if
(
!
prevPageContentFrame
)
{
pageContentFrame
-
>
AddStateBits
(
NS_FRAME_OWNS_ANON_BOXES
)
;
}
SetInitialSingleChild
(
pageFrame
pageContentFrame
)
;
pageContentFrame
-
>
AddStateBits
(
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
;
pageContentFrame
-
>
MarkAsAbsoluteContainingBlock
(
)
;
RefPtr
<
ComputedStyle
>
canvasPseudoStyle
;
canvasPseudoStyle
=
styleSet
-
>
ResolveInheritingAnonymousBoxStyle
(
nsCSSAnonBoxes
:
:
canvas
(
)
pageContentPseudoStyle
)
;
aCanvasFrame
=
NS_NewCanvasFrame
(
aPresShell
canvasPseudoStyle
)
;
nsIFrame
*
prevCanvasFrame
=
nullptr
;
if
(
prevPageContentFrame
)
{
prevCanvasFrame
=
prevPageContentFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
NS_ASSERTION
(
prevCanvasFrame
"
missing
canvas
frame
"
)
;
}
aCanvasFrame
-
>
Init
(
nullptr
pageContentFrame
prevCanvasFrame
)
;
SetInitialSingleChild
(
pageContentFrame
aCanvasFrame
)
;
return
pageFrame
;
}
nsIFrame
*
nsCSSFrameConstructor
:
:
CreatePlaceholderFrameFor
(
nsIPresShell
*
aPresShell
nsIContent
*
aContent
nsIFrame
*
aFrame
nsContainerFrame
*
aParentFrame
nsIFrame
*
aPrevInFlow
nsFrameState
aTypeBit
)
{
RefPtr
<
ComputedStyle
>
placeholderStyle
=
aPresShell
-
>
StyleSet
(
)
-
>
ResolveStyleForPlaceholder
(
)
;
nsPlaceholderFrame
*
placeholderFrame
=
NS_NewPlaceholderFrame
(
aPresShell
placeholderStyle
aTypeBit
)
;
placeholderFrame
-
>
Init
(
aContent
aParentFrame
aPrevInFlow
)
;
placeholderFrame
-
>
SetOutOfFlowFrame
(
aFrame
)
;
aFrame
-
>
SetProperty
(
nsIFrame
:
:
PlaceholderFrameProperty
(
)
placeholderFrame
)
;
aFrame
-
>
AddStateBits
(
NS_FRAME_OUT_OF_FLOW
)
;
return
placeholderFrame
;
}
static
inline
void
ClearLazyBits
(
nsIContent
*
aStartContent
nsIContent
*
aEndContent
)
{
MOZ_ASSERT
(
aStartContent
|
|
!
aEndContent
"
Must
have
start
child
if
we
have
an
end
child
"
)
;
for
(
nsIContent
*
cur
=
aStartContent
;
cur
!
=
aEndContent
;
cur
=
cur
-
>
GetNextSibling
(
)
)
{
cur
-
>
UnsetFlags
(
NODE_DESCENDANTS_NEED_FRAMES
|
NODE_NEEDS_FRAME
)
;
}
}
nsIFrame
*
nsCSSFrameConstructor
:
:
ConstructSelectFrame
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aStyleDisplay
nsFrameItems
&
aFrameItems
)
{
nsIContent
*
const
content
=
aItem
.
mContent
;
ComputedStyle
*
const
computedStyle
=
aItem
.
mComputedStyle
;
dom
:
:
HTMLSelectElement
*
sel
=
dom
:
:
HTMLSelectElement
:
:
FromNode
(
content
)
;
MOZ_ASSERT
(
sel
)
;
if
(
sel
-
>
IsCombobox
(
)
)
{
nsFrameState
flags
=
NS_BLOCK_FLOAT_MGR
;
nsComboboxControlFrame
*
comboboxFrame
=
NS_NewComboboxControlFrame
(
mPresShell
computedStyle
flags
)
;
nsILayoutHistoryState
*
historyState
=
aState
.
mFrameState
;
aState
.
mFrameState
=
nullptr
;
InitAndRestoreFrame
(
aState
content
aState
.
GetGeometricParent
(
*
aStyleDisplay
aParentFrame
)
comboboxFrame
)
;
comboboxFrame
-
>
AddStateBits
(
NS_FRAME_OWNS_ANON_BOXES
)
;
aState
.
AddChild
(
comboboxFrame
aFrameItems
content
aParentFrame
)
;
RefPtr
<
ComputedStyle
>
listStyle
;
listStyle
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveInheritingAnonymousBoxStyle
(
nsCSSAnonBoxes
:
:
dropDownList
(
)
computedStyle
)
;
nsContainerFrame
*
listFrame
=
NS_NewListControlFrame
(
mPresShell
listStyle
)
;
nsListControlFrame
*
listControlFrame
=
do_QueryFrame
(
listFrame
)
;
if
(
listControlFrame
)
{
listControlFrame
-
>
SetComboboxFrame
(
comboboxFrame
)
;
}
comboboxFrame
-
>
SetDropDown
(
listFrame
)
;
if
(
!
nsLayoutUtils
:
:
IsContentSelectEnabled
(
)
)
{
NS_ASSERTION
(
!
listFrame
-
>
IsAbsPosContainingBlock
(
)
"
Ended
up
with
positioned
dropdown
list
somehow
.
"
)
;
}
NS_ASSERTION
(
!
listFrame
-
>
IsFloating
(
)
"
Ended
up
with
floating
dropdown
list
somehow
.
"
)
;
nsFrameItems
childItems
;
nsContainerFrame
*
scrolledFrame
=
NS_NewSelectsAreaFrame
(
mPresShell
computedStyle
flags
)
;
InitializeSelectFrame
(
aState
listFrame
scrolledFrame
content
comboboxFrame
listStyle
true
aItem
.
mPendingBinding
childItems
)
;
if
(
!
nsLayoutUtils
:
:
IsContentSelectEnabled
(
)
)
{
NS_ASSERTION
(
listFrame
-
>
GetView
(
)
"
ListFrame
'
s
view
is
nullptr
"
)
;
}
AutoTArray
<
nsIAnonymousContentCreator
:
:
ContentInfo
2
>
newAnonymousItems
;
DebugOnly
<
nsresult
>
rv
=
GetAnonymousContent
(
content
comboboxFrame
newAnonymousItems
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
MOZ_ASSERT
(
newAnonymousItems
.
Length
(
)
=
=
2
)
;
MOZ_ASSERT
(
newAnonymousItems
[
0
]
.
mContent
=
=
comboboxFrame
-
>
GetDisplayNode
(
)
)
;
newAnonymousItems
.
RemoveElementAt
(
0
)
;
nsIFrame
*
customFrame
=
comboboxFrame
-
>
CreateFrameForDisplayNode
(
)
;
MOZ_ASSERT
(
customFrame
)
;
customFrame
-
>
AddStateBits
(
NS_FRAME_ANONYMOUSCONTENTCREATOR_CONTENT
)
;
childItems
.
AddChild
(
customFrame
)
;
AutoFrameConstructionItemList
fcItems
(
this
)
;
AddFCItemsForAnonymousContent
(
aState
comboboxFrame
newAnonymousItems
fcItems
)
;
ConstructFramesFromItemList
(
aState
fcItems
comboboxFrame
false
childItems
)
;
comboboxFrame
-
>
SetInitialChildList
(
kPrincipalList
childItems
)
;
if
(
!
nsLayoutUtils
:
:
IsContentSelectEnabled
(
)
)
{
nsFrameItems
popupItems
;
popupItems
.
AddChild
(
listFrame
)
;
comboboxFrame
-
>
SetInitialChildList
(
nsIFrame
:
:
kSelectPopupList
popupItems
)
;
}
aState
.
mFrameState
=
historyState
;
if
(
aState
.
mFrameState
)
{
RestoreFrameState
(
comboboxFrame
aState
.
mFrameState
)
;
}
return
comboboxFrame
;
}
nsContainerFrame
*
listFrame
=
NS_NewListControlFrame
(
mPresShell
computedStyle
)
;
nsContainerFrame
*
scrolledFrame
=
NS_NewSelectsAreaFrame
(
mPresShell
computedStyle
NS_BLOCK_FLOAT_MGR
)
;
InitializeSelectFrame
(
aState
listFrame
scrolledFrame
content
aParentFrame
computedStyle
false
aItem
.
mPendingBinding
aFrameItems
)
;
return
listFrame
;
}
void
nsCSSFrameConstructor
:
:
InitializeSelectFrame
(
nsFrameConstructorState
&
aState
nsContainerFrame
*
scrollFrame
nsContainerFrame
*
scrolledFrame
nsIContent
*
aContent
nsContainerFrame
*
aParentFrame
ComputedStyle
*
aComputedStyle
bool
aBuildCombobox
PendingBinding
*
aPendingBinding
nsFrameItems
&
aFrameItems
)
{
nsContainerFrame
*
geometricParent
=
aState
.
GetGeometricParent
(
*
aComputedStyle
-
>
StyleDisplay
(
)
aParentFrame
)
;
scrollFrame
-
>
Init
(
aContent
geometricParent
nullptr
)
;
if
(
!
aBuildCombobox
|
|
nsLayoutUtils
:
:
IsContentSelectEnabled
(
)
)
{
aState
.
AddChild
(
scrollFrame
aFrameItems
aContent
aParentFrame
)
;
}
BuildScrollFrame
(
aState
aContent
aComputedStyle
scrolledFrame
geometricParent
scrollFrame
)
;
if
(
aState
.
mFrameState
)
{
RestoreFrameStateFor
(
scrollFrame
aState
.
mFrameState
)
;
}
nsFrameItems
childItems
;
ProcessChildren
(
aState
aContent
aComputedStyle
scrolledFrame
false
childItems
false
aPendingBinding
)
;
scrolledFrame
-
>
SetInitialChildList
(
kPrincipalList
childItems
)
;
}
nsIFrame
*
nsCSSFrameConstructor
:
:
ConstructFieldSetFrame
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aStyleDisplay
nsFrameItems
&
aFrameItems
)
{
nsIContent
*
const
content
=
aItem
.
mContent
;
ComputedStyle
*
const
computedStyle
=
aItem
.
mComputedStyle
;
nsContainerFrame
*
fieldsetFrame
=
NS_NewFieldSetFrame
(
mPresShell
computedStyle
)
;
InitAndRestoreFrame
(
aState
content
aState
.
GetGeometricParent
(
*
aStyleDisplay
aParentFrame
)
fieldsetFrame
)
;
fieldsetFrame
-
>
AddStateBits
(
NS_FRAME_OWNS_ANON_BOXES
)
;
RefPtr
<
ComputedStyle
>
fieldsetContentStyle
;
fieldsetContentStyle
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveInheritingAnonymousBoxStyle
(
nsCSSAnonBoxes
:
:
fieldsetContent
(
)
computedStyle
)
;
const
nsStyleDisplay
*
fieldsetContentDisplay
=
fieldsetContentStyle
-
>
StyleDisplay
(
)
;
bool
isScrollable
=
fieldsetContentDisplay
-
>
IsScrollableOverflow
(
)
;
nsContainerFrame
*
scrollFrame
=
nullptr
;
if
(
isScrollable
)
{
fieldsetContentStyle
=
BeginBuildingScrollFrame
(
aState
content
fieldsetContentStyle
fieldsetFrame
nsCSSAnonBoxes
:
:
scrolledContent
(
)
false
scrollFrame
)
;
}
nsContainerFrame
*
absPosContainer
=
nullptr
;
if
(
fieldsetFrame
-
>
IsAbsPosContainingBlock
(
)
)
{
absPosContainer
=
fieldsetFrame
;
}
nsContainerFrame
*
contentFrameTop
;
nsContainerFrame
*
contentFrame
;
auto
parent
=
scrollFrame
?
scrollFrame
:
fieldsetFrame
;
switch
(
fieldsetContentDisplay
-
>
mDisplay
)
{
case
StyleDisplay
:
:
Flex
:
contentFrame
=
NS_NewFlexContainerFrame
(
mPresShell
fieldsetContentStyle
)
;
InitAndRestoreFrame
(
aState
content
parent
contentFrame
)
;
contentFrameTop
=
contentFrame
;
break
;
case
StyleDisplay
:
:
Grid
:
contentFrame
=
NS_NewGridContainerFrame
(
mPresShell
fieldsetContentStyle
)
;
InitAndRestoreFrame
(
aState
content
parent
contentFrame
)
;
contentFrameTop
=
contentFrame
;
break
;
default
:
{
MOZ_ASSERT
(
fieldsetContentDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
Block
"
bug
in
StyleAdjuster
:
:
adjust_for_fieldset_content
?
"
)
;
contentFrame
=
NS_NewBlockFormattingContext
(
mPresShell
fieldsetContentStyle
)
;
contentFrameTop
=
InitAndWrapInColumnSetFrameIfNeeded
(
aState
content
parent
contentFrame
fieldsetContentStyle
)
;
if
(
contentFrame
!
=
contentFrameTop
)
{
if
(
absPosContainer
)
{
absPosContainer
=
contentFrameTop
;
}
}
break
;
}
}
aState
.
AddChild
(
fieldsetFrame
aFrameItems
content
aParentFrame
)
;
nsFrameConstructorSaveState
absoluteSaveState
;
nsFrameItems
childItems
;
contentFrame
-
>
AddStateBits
(
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
;
if
(
absPosContainer
)
{
aState
.
PushAbsoluteContainingBlock
(
contentFrame
absPosContainer
absoluteSaveState
)
;
}
ProcessChildren
(
aState
content
computedStyle
contentFrame
true
childItems
true
aItem
.
mPendingBinding
)
;
nsFrameItems
fieldsetKids
;
fieldsetKids
.
AddChild
(
scrollFrame
?
scrollFrame
:
contentFrameTop
)
;
for
(
nsFrameList
:
:
Enumerator
e
(
childItems
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
)
{
nsIFrame
*
child
=
e
.
get
(
)
;
nsContainerFrame
*
cif
=
child
-
>
GetContentInsertionFrame
(
)
;
if
(
cif
&
&
cif
-
>
IsLegendFrame
(
)
)
{
childItems
.
RemoveFrame
(
child
)
;
fieldsetKids
.
InsertFrame
(
fieldsetFrame
nullptr
child
)
;
if
(
scrollFrame
)
{
StickyScrollContainer
:
:
NotifyReparentedFrameAcrossScrollFrameBoundary
(
child
contentFrame
)
;
}
break
;
}
}
if
(
isScrollable
)
{
FinishBuildingScrollFrame
(
scrollFrame
contentFrameTop
)
;
}
contentFrame
-
>
SetInitialChildList
(
kPrincipalList
childItems
)
;
fieldsetFrame
-
>
SetInitialChildList
(
kPrincipalList
fieldsetKids
)
;
return
fieldsetFrame
;
}
nsIFrame
*
nsCSSFrameConstructor
:
:
ConstructDetailsFrame
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aStyleDisplay
nsFrameItems
&
aFrameItems
)
{
if
(
!
aStyleDisplay
-
>
IsScrollableOverflow
(
)
)
{
return
ConstructNonScrollableBlockWithConstructor
(
aState
aItem
aParentFrame
aStyleDisplay
aFrameItems
NS_NewDetailsFrame
)
;
}
return
ConstructScrollableBlockWithConstructor
(
aState
aItem
aParentFrame
aStyleDisplay
aFrameItems
NS_NewDetailsFrame
)
;
}
static
nsIFrame
*
FindAncestorWithGeneratedContentPseudo
(
nsIFrame
*
aFrame
)
{
for
(
nsIFrame
*
f
=
aFrame
-
>
GetParent
(
)
;
f
;
f
=
f
-
>
GetParent
(
)
)
{
NS_ASSERTION
(
f
-
>
IsGeneratedContentFrame
(
)
"
should
not
have
exited
generated
content
"
)
;
nsAtom
*
pseudo
=
f
-
>
Style
(
)
-
>
GetPseudo
(
)
;
if
(
pseudo
=
=
nsCSSPseudoElements
:
:
before
(
)
|
|
pseudo
=
=
nsCSSPseudoElements
:
:
after
(
)
)
return
f
;
}
return
nullptr
;
}
#
define
SIMPLE_FCDATA
(
_func
)
FCDATA_DECL
(
0
_func
)
#
define
FULL_CTOR_FCDATA
(
_flags
_func
)
\
{
_flags
|
FCDATA_FUNC_IS_FULL_CTOR
{
nullptr
}
_func
nullptr
}
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindTextData
(
const
Text
&
aTextContent
nsIFrame
*
aParentFrame
)
{
if
(
aParentFrame
&
&
IsFrameForSVG
(
aParentFrame
)
)
{
nsIFrame
*
ancestorFrame
=
nsSVGUtils
:
:
GetFirstNonAAncestorFrame
(
aParentFrame
)
;
if
(
!
ancestorFrame
|
|
!
nsSVGUtils
:
:
IsInSVGTextSubtree
(
ancestorFrame
)
)
{
return
nullptr
;
}
if
(
aParentFrame
-
>
GetContent
(
)
!
=
aTextContent
.
GetParent
(
)
)
{
return
nullptr
;
}
static
const
FrameConstructionData
sSVGTextData
=
FCDATA_DECL
(
FCDATA_IS_LINE_PARTICIPANT
|
FCDATA_IS_SVG_TEXT
NS_NewTextFrame
)
;
return
&
sSVGTextData
;
}
static
const
FrameConstructionData
sTextData
=
FCDATA_DECL
(
FCDATA_IS_LINE_PARTICIPANT
NS_NewTextFrame
)
;
return
&
sTextData
;
}
void
nsCSSFrameConstructor
:
:
ConstructTextFrame
(
const
FrameConstructionData
*
aData
nsFrameConstructorState
&
aState
nsIContent
*
aContent
nsContainerFrame
*
aParentFrame
ComputedStyle
*
aComputedStyle
nsFrameItems
&
aFrameItems
)
{
MOZ_ASSERT
(
aData
"
Must
have
frame
construction
data
"
)
;
nsIFrame
*
newFrame
=
(
*
aData
-
>
mFunc
.
mCreationFunc
)
(
mPresShell
aComputedStyle
)
;
InitAndRestoreFrame
(
aState
aContent
aParentFrame
newFrame
)
;
if
(
newFrame
-
>
IsGeneratedContentFrame
(
)
)
{
UniquePtr
<
nsGenConInitializer
>
initializer
(
static_cast
<
nsGenConInitializer
*
>
(
aContent
-
>
UnsetProperty
(
nsGkAtoms
:
:
genConInitializerProperty
)
)
)
;
if
(
initializer
)
{
if
(
initializer
-
>
mNode
-
>
InitTextFrame
(
initializer
-
>
mList
FindAncestorWithGeneratedContentPseudo
(
newFrame
)
newFrame
)
)
{
(
this
-
>
*
(
initializer
-
>
mDirtyAll
)
)
(
)
;
}
initializer
-
>
mNode
.
forget
(
)
;
}
}
aFrameItems
.
AddChild
(
newFrame
)
;
if
(
!
aState
.
mCreatingExtraFrames
)
aContent
-
>
SetPrimaryFrame
(
newFrame
)
;
}
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindDataByInt
(
int32_t
aInt
const
Element
&
aElement
ComputedStyle
&
aComputedStyle
const
FrameConstructionDataByInt
*
aDataPtr
uint32_t
aDataLength
)
{
for
(
const
FrameConstructionDataByInt
*
curData
=
aDataPtr
*
endData
=
aDataPtr
+
aDataLength
;
curData
!
=
endData
;
+
+
curData
)
{
if
(
curData
-
>
mInt
=
=
aInt
)
{
const
FrameConstructionData
*
data
=
&
curData
-
>
mData
;
if
(
data
-
>
mBits
&
FCDATA_FUNC_IS_DATA_GETTER
)
{
return
data
-
>
mFunc
.
mDataGetter
(
aElement
aComputedStyle
)
;
}
return
data
;
}
}
return
nullptr
;
}
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindDataByTag
(
nsAtom
*
aTag
const
Element
&
aElement
ComputedStyle
&
aStyle
const
FrameConstructionDataByTag
*
aDataPtr
uint32_t
aDataLength
)
{
for
(
const
FrameConstructionDataByTag
*
curData
=
aDataPtr
*
endData
=
aDataPtr
+
aDataLength
;
curData
!
=
endData
;
+
+
curData
)
{
if
(
curData
-
>
mTag
=
=
aTag
)
{
const
FrameConstructionData
*
data
=
&
curData
-
>
mData
;
if
(
data
-
>
mBits
&
FCDATA_FUNC_IS_DATA_GETTER
)
{
return
data
-
>
mFunc
.
mDataGetter
(
aElement
aStyle
)
;
}
return
data
;
}
}
return
nullptr
;
}
#
define
SUPPRESS_FCDATA
(
)
FCDATA_DECL
(
FCDATA_SUPPRESS_FRAME
nullptr
)
#
define
SIMPLE_INT_CREATE
(
_int
_func
)
\
{
_int
SIMPLE_FCDATA
(
_func
)
}
#
define
SIMPLE_INT_CHAIN
(
_int
_func
)
\
{
_int
FCDATA_DECL
(
FCDATA_FUNC_IS_DATA_GETTER
_func
)
}
#
define
COMPLEX_INT_CREATE
(
_int
_func
)
\
{
_int
FULL_CTOR_FCDATA
(
0
_func
)
}
#
define
SIMPLE_TAG_CREATE
(
_tag
_func
)
\
{
nsGkAtoms
:
:
_tag
SIMPLE_FCDATA
(
_func
)
}
#
define
SIMPLE_TAG_CHAIN
(
_tag
_func
)
\
{
nsGkAtoms
:
:
_tag
FCDATA_DECL
(
FCDATA_FUNC_IS_DATA_GETTER
_func
)
}
#
define
COMPLEX_TAG_CREATE
(
_tag
_func
)
\
{
nsGkAtoms
:
:
_tag
FULL_CTOR_FCDATA
(
0
_func
)
}
static
bool
IsFrameForFieldSet
(
nsIFrame
*
aFrame
)
{
nsAtom
*
pseudo
=
aFrame
-
>
Style
(
)
-
>
GetPseudo
(
)
;
if
(
pseudo
=
=
nsCSSAnonBoxes
:
:
fieldsetContent
(
)
|
|
pseudo
=
=
nsCSSAnonBoxes
:
:
scrolledContent
(
)
|
|
pseudo
=
=
nsCSSAnonBoxes
:
:
columnContent
(
)
)
{
return
IsFrameForFieldSet
(
aFrame
-
>
GetParent
(
)
)
;
}
return
aFrame
-
>
IsFieldSetFrame
(
)
;
}
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindHTMLData
(
const
Element
&
aElement
nsIFrame
*
aParentFrame
ComputedStyle
&
aStyle
)
{
MOZ_ASSERT
(
aElement
.
IsHTMLElement
(
)
)
;
nsAtom
*
tag
=
aElement
.
NodeInfo
(
)
-
>
NameAtom
(
)
;
NS_ASSERTION
(
!
aParentFrame
|
|
aParentFrame
-
>
Style
(
)
-
>
GetPseudo
(
)
!
=
nsCSSAnonBoxes
:
:
fieldsetContent
(
)
|
|
aParentFrame
-
>
GetParent
(
)
-
>
IsFieldSetFrame
(
)
"
Unexpected
parent
for
fieldset
content
anon
box
"
)
;
if
(
tag
=
=
nsGkAtoms
:
:
legend
&
&
(
!
aParentFrame
|
|
!
IsFrameForFieldSet
(
aParentFrame
)
|
|
aStyle
.
StyleDisplay
(
)
-
>
IsFloatingStyle
(
)
|
|
aStyle
.
StyleDisplay
(
)
-
>
IsAbsolutelyPositionedStyle
(
)
)
)
{
return
nullptr
;
}
static
const
FrameConstructionDataByTag
sHTMLData
[
]
=
{
SIMPLE_TAG_CHAIN
(
img
nsCSSFrameConstructor
:
:
FindImgData
)
SIMPLE_TAG_CHAIN
(
mozgeneratedcontentimage
nsCSSFrameConstructor
:
:
FindGeneratedImageData
)
{
nsGkAtoms
:
:
br
FCDATA_DECL
(
FCDATA_IS_LINE_PARTICIPANT
|
FCDATA_IS_LINE_BREAK
NS_NewBRFrame
)
}
SIMPLE_TAG_CREATE
(
wbr
NS_NewWBRFrame
)
SIMPLE_TAG_CHAIN
(
input
nsCSSFrameConstructor
:
:
FindInputData
)
SIMPLE_TAG_CREATE
(
textarea
NS_NewTextControlFrame
)
COMPLEX_TAG_CREATE
(
select
&
nsCSSFrameConstructor
:
:
ConstructSelectFrame
)
SIMPLE_TAG_CHAIN
(
object
nsCSSFrameConstructor
:
:
FindObjectData
)
SIMPLE_TAG_CHAIN
(
embed
nsCSSFrameConstructor
:
:
FindObjectData
)
COMPLEX_TAG_CREATE
(
fieldset
&
nsCSSFrameConstructor
:
:
ConstructFieldSetFrame
)
{
nsGkAtoms
:
:
legend
FCDATA_DECL
(
FCDATA_ALLOW_BLOCK_STYLES
|
FCDATA_MAY_NEED_SCROLLFRAME
|
FCDATA_MAY_NEED_BULLET
NS_NewLegendFrame
)
}
SIMPLE_TAG_CREATE
(
frameset
NS_NewHTMLFramesetFrame
)
SIMPLE_TAG_CREATE
(
iframe
NS_NewSubDocumentFrame
)
{
nsGkAtoms
:
:
button
FCDATA_WITH_WRAPPING_BLOCK
(
FCDATA_ALLOW_BLOCK_STYLES
|
FCDATA_ALLOW_GRID_FLEX_COLUMNSET
NS_NewHTMLButtonControlFrame
nsCSSAnonBoxes
:
:
buttonContent
(
)
)
}
SIMPLE_TAG_CHAIN
(
canvas
nsCSSFrameConstructor
:
:
FindCanvasData
)
SIMPLE_TAG_CREATE
(
video
NS_NewHTMLVideoFrame
)
SIMPLE_TAG_CREATE
(
audio
NS_NewHTMLVideoFrame
)
SIMPLE_TAG_CREATE
(
progress
NS_NewProgressFrame
)
SIMPLE_TAG_CREATE
(
meter
NS_NewMeterFrame
)
COMPLEX_TAG_CREATE
(
details
&
nsCSSFrameConstructor
:
:
ConstructDetailsFrame
)
}
;
return
FindDataByTag
(
tag
aElement
aStyle
sHTMLData
ArrayLength
(
sHTMLData
)
)
;
}
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindGeneratedImageData
(
const
Element
&
aElement
ComputedStyle
&
)
{
if
(
!
aElement
.
IsInNativeAnonymousSubtree
(
)
)
{
return
nullptr
;
}
static
const
FrameConstructionData
sImgData
=
SIMPLE_FCDATA
(
NS_NewImageFrameForGeneratedContentIndex
)
;
return
&
sImgData
;
}
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindImgData
(
const
Element
&
aElement
ComputedStyle
&
aStyle
)
{
if
(
!
nsImageFrame
:
:
ShouldCreateImageFrameFor
(
aElement
aStyle
)
)
{
return
nullptr
;
}
static
const
FrameConstructionData
sImgData
=
SIMPLE_FCDATA
(
NS_NewImageFrame
)
;
return
&
sImgData
;
}
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindImgControlData
(
const
Element
&
aElement
ComputedStyle
&
aStyle
)
{
if
(
!
nsImageFrame
:
:
ShouldCreateImageFrameFor
(
aElement
aStyle
)
)
{
return
nullptr
;
}
static
const
FrameConstructionData
sImgControlData
=
SIMPLE_FCDATA
(
NS_NewImageControlFrame
)
;
return
&
sImgControlData
;
}
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindInputData
(
const
Element
&
aElement
ComputedStyle
&
aStyle
)
{
static
const
FrameConstructionDataByInt
sInputData
[
]
=
{
SIMPLE_INT_CREATE
(
NS_FORM_INPUT_CHECKBOX
NS_NewCheckboxRadioFrame
)
SIMPLE_INT_CREATE
(
NS_FORM_INPUT_RADIO
NS_NewCheckboxRadioFrame
)
SIMPLE_INT_CREATE
(
NS_FORM_INPUT_FILE
NS_NewFileControlFrame
)
SIMPLE_INT_CHAIN
(
NS_FORM_INPUT_IMAGE
nsCSSFrameConstructor
:
:
FindImgControlData
)
SIMPLE_INT_CREATE
(
NS_FORM_INPUT_EMAIL
NS_NewTextControlFrame
)
SIMPLE_INT_CREATE
(
NS_FORM_INPUT_SEARCH
NS_NewTextControlFrame
)
SIMPLE_INT_CREATE
(
NS_FORM_INPUT_TEXT
NS_NewTextControlFrame
)
SIMPLE_INT_CREATE
(
NS_FORM_INPUT_TEL
NS_NewTextControlFrame
)
SIMPLE_INT_CREATE
(
NS_FORM_INPUT_URL
NS_NewTextControlFrame
)
SIMPLE_INT_CREATE
(
NS_FORM_INPUT_RANGE
NS_NewRangeFrame
)
SIMPLE_INT_CREATE
(
NS_FORM_INPUT_PASSWORD
NS_NewTextControlFrame
)
{
NS_FORM_INPUT_COLOR
FCDATA_WITH_WRAPPING_BLOCK
(
0
NS_NewColorControlFrame
nsCSSAnonBoxes
:
:
buttonContent
(
)
)
}
SIMPLE_INT_CREATE
(
NS_FORM_INPUT_NUMBER
NS_NewNumberControlFrame
)
SIMPLE_INT_CREATE
(
NS_FORM_INPUT_TIME
NS_NewDateTimeControlFrame
)
SIMPLE_INT_CREATE
(
NS_FORM_INPUT_DATE
NS_NewDateTimeControlFrame
)
SIMPLE_INT_CREATE
(
NS_FORM_INPUT_MONTH
NS_NewTextControlFrame
)
SIMPLE_INT_CREATE
(
NS_FORM_INPUT_WEEK
NS_NewTextControlFrame
)
SIMPLE_INT_CREATE
(
NS_FORM_INPUT_DATETIME_LOCAL
NS_NewTextControlFrame
)
{
NS_FORM_INPUT_SUBMIT
FCDATA_WITH_WRAPPING_BLOCK
(
0
NS_NewGfxButtonControlFrame
nsCSSAnonBoxes
:
:
buttonContent
(
)
)
}
{
NS_FORM_INPUT_RESET
FCDATA_WITH_WRAPPING_BLOCK
(
0
NS_NewGfxButtonControlFrame
nsCSSAnonBoxes
:
:
buttonContent
(
)
)
}
{
NS_FORM_INPUT_BUTTON
FCDATA_WITH_WRAPPING_BLOCK
(
0
NS_NewGfxButtonControlFrame
nsCSSAnonBoxes
:
:
buttonContent
(
)
)
}
}
;
auto
controlType
=
HTMLInputElement
:
:
FromNode
(
aElement
)
-
>
ControlType
(
)
;
if
(
(
controlType
=
=
NS_FORM_INPUT_CHECKBOX
|
|
controlType
=
=
NS_FORM_INPUT_RADIO
)
&
&
!
aStyle
.
StyleDisplay
(
)
-
>
HasAppearance
(
)
)
{
return
nullptr
;
}
return
FindDataByInt
(
controlType
aElement
aStyle
sInputData
ArrayLength
(
sInputData
)
)
;
}
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindObjectData
(
const
Element
&
aElement
ComputedStyle
&
aStyle
)
{
uint32_t
type
;
if
(
aElement
.
State
(
)
.
HasAtLeastOneOfStates
(
NS_EVENT_STATE_BROKEN
|
NS_EVENT_STATE_USERDISABLED
|
NS_EVENT_STATE_SUPPRESSED
)
)
{
type
=
nsIObjectLoadingContent
:
:
TYPE_NULL
;
}
else
{
nsCOMPtr
<
nsIObjectLoadingContent
>
objContent
=
do_QueryInterface
(
const_cast
<
Element
*
>
(
&
aElement
)
)
;
NS_ASSERTION
(
objContent
"
embed
and
object
must
implement
"
"
nsIObjectLoadingContent
!
"
)
;
objContent
-
>
GetDisplayedType
(
&
type
)
;
}
static
const
FrameConstructionDataByInt
sObjectData
[
]
=
{
SIMPLE_INT_CREATE
(
nsIObjectLoadingContent
:
:
TYPE_LOADING
NS_NewEmptyFrame
)
SIMPLE_INT_CREATE
(
nsIObjectLoadingContent
:
:
TYPE_PLUGIN
NS_NewObjectFrame
)
SIMPLE_INT_CREATE
(
nsIObjectLoadingContent
:
:
TYPE_IMAGE
NS_NewImageFrame
)
SIMPLE_INT_CREATE
(
nsIObjectLoadingContent
:
:
TYPE_DOCUMENT
NS_NewSubDocumentFrame
)
SIMPLE_INT_CREATE
(
nsIObjectLoadingContent
:
:
TYPE_FAKE_PLUGIN
NS_NewSubDocumentFrame
)
}
;
return
FindDataByInt
(
(
int32_t
)
type
aElement
aStyle
sObjectData
ArrayLength
(
sObjectData
)
)
;
}
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindCanvasData
(
const
Element
&
aElement
ComputedStyle
&
aStyle
)
{
Document
*
doc
=
aElement
.
OwnerDoc
(
)
;
if
(
doc
-
>
IsStaticDocument
(
)
)
{
doc
=
doc
-
>
GetOriginalDocument
(
)
;
}
if
(
!
doc
-
>
IsScriptEnabled
(
)
)
{
return
nullptr
;
}
static
const
FrameConstructionData
sCanvasData
=
FCDATA_WITH_WRAPPING_BLOCK
(
0
NS_NewHTMLCanvasFrame
nsCSSAnonBoxes
:
:
htmlCanvasContent
(
)
)
;
return
&
sCanvasData
;
}
void
nsCSSFrameConstructor
:
:
ConstructFrameFromItemInternal
(
FrameConstructionItem
&
aItem
nsFrameConstructorState
&
aState
nsContainerFrame
*
aParentFrame
nsFrameItems
&
aFrameItems
)
{
const
FrameConstructionData
*
data
=
aItem
.
mFCData
;
NS_ASSERTION
(
data
"
Must
have
frame
construction
data
"
)
;
uint32_t
bits
=
data
-
>
mBits
;
NS_ASSERTION
(
!
(
bits
&
FCDATA_FUNC_IS_DATA_GETTER
)
"
Should
have
dealt
with
this
inside
the
data
finder
"
)
;
#
define
CHECK_ONLY_ONE_BIT
(
_bit1
_bit2
)
\
NS_ASSERTION
(
!
(
bits
&
_bit1
)
|
|
!
(
bits
&
_bit2
)
\
"
Only
one
of
these
bits
should
be
set
"
)
CHECK_ONLY_ONE_BIT
(
FCDATA_FUNC_IS_FULL_CTOR
FCDATA_FORCE_NULL_ABSPOS_CONTAINER
)
;
CHECK_ONLY_ONE_BIT
(
FCDATA_FUNC_IS_FULL_CTOR
FCDATA_WRAP_KIDS_IN_BLOCKS
)
;
CHECK_ONLY_ONE_BIT
(
FCDATA_FUNC_IS_FULL_CTOR
FCDATA_MAY_NEED_SCROLLFRAME
)
;
CHECK_ONLY_ONE_BIT
(
FCDATA_FUNC_IS_FULL_CTOR
FCDATA_IS_POPUP
)
;
CHECK_ONLY_ONE_BIT
(
FCDATA_FUNC_IS_FULL_CTOR
FCDATA_SKIP_ABSPOS_PUSH
)
;
CHECK_ONLY_ONE_BIT
(
FCDATA_FUNC_IS_FULL_CTOR
FCDATA_DISALLOW_GENERATED_CONTENT
)
;
CHECK_ONLY_ONE_BIT
(
FCDATA_FUNC_IS_FULL_CTOR
FCDATA_ALLOW_BLOCK_STYLES
)
;
CHECK_ONLY_ONE_BIT
(
FCDATA_FUNC_IS_FULL_CTOR
FCDATA_CREATE_BLOCK_WRAPPER_FOR_ALL_KIDS
)
;
CHECK_ONLY_ONE_BIT
(
FCDATA_WRAP_KIDS_IN_BLOCKS
FCDATA_CREATE_BLOCK_WRAPPER_FOR_ALL_KIDS
)
;
#
undef
CHECK_ONLY_ONE_BIT
NS_ASSERTION
(
!
(
bits
&
FCDATA_FORCED_NON_SCROLLABLE_BLOCK
)
|
|
(
(
bits
&
FCDATA_FUNC_IS_FULL_CTOR
)
&
&
data
-
>
mFullConstructor
=
=
&
nsCSSFrameConstructor
:
:
ConstructNonScrollableBlock
)
"
Unexpected
FCDATA_FORCED_NON_SCROLLABLE_BLOCK
flag
"
)
;
MOZ_ASSERT
(
!
(
bits
&
FCDATA_IS_WRAPPER_ANON_BOX
)
|
|
(
bits
&
FCDATA_USE_CHILD_ITEMS
)
"
Wrapper
anon
boxes
should
always
have
FCDATA_USE_CHILD_ITEMS
"
)
;
if
(
aState
.
mCreatingExtraFrames
&
&
aItem
.
mContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
iframe
)
)
{
return
;
}
nsIContent
*
const
content
=
aItem
.
mContent
;
nsIFrame
*
newFrame
;
nsIFrame
*
primaryFrame
;
ComputedStyle
*
const
computedStyle
=
aItem
.
mComputedStyle
;
const
nsStyleDisplay
*
display
=
computedStyle
-
>
StyleDisplay
(
)
;
if
(
bits
&
FCDATA_FUNC_IS_FULL_CTOR
)
{
newFrame
=
(
this
-
>
*
(
data
-
>
mFullConstructor
)
)
(
aState
aItem
aParentFrame
display
aFrameItems
)
;
MOZ_ASSERT
(
newFrame
"
Full
constructor
failed
"
)
;
primaryFrame
=
newFrame
;
}
else
{
newFrame
=
(
*
data
-
>
mFunc
.
mCreationFunc
)
(
mPresShell
computedStyle
)
;
bool
allowOutOfFlow
=
!
(
bits
&
FCDATA_DISALLOW_OUT_OF_FLOW
)
;
bool
isPopup
=
aItem
.
mIsPopup
;
NS_ASSERTION
(
!
isPopup
|
|
(
aState
.
mPopupItems
.
containingBlock
&
&
aState
.
mPopupItems
.
containingBlock
-
>
IsPopupSetFrame
(
)
)
"
Should
have
a
containing
block
here
!
"
)
;
nsContainerFrame
*
geometricParent
=
isPopup
?
aState
.
mPopupItems
.
containingBlock
:
(
allowOutOfFlow
?
aState
.
GetGeometricParent
(
*
display
aParentFrame
)
:
aParentFrame
)
;
nsIFrame
*
frameToAddToList
=
nullptr
;
if
(
(
bits
&
FCDATA_MAY_NEED_SCROLLFRAME
)
&
&
display
-
>
IsScrollableOverflow
(
)
)
{
nsContainerFrame
*
scrollframe
=
nullptr
;
BuildScrollFrame
(
aState
content
computedStyle
newFrame
geometricParent
scrollframe
)
;
frameToAddToList
=
scrollframe
;
}
else
{
InitAndRestoreFrame
(
aState
content
geometricParent
newFrame
)
;
frameToAddToList
=
newFrame
;
}
primaryFrame
=
frameToAddToList
;
nsIFrame
*
maybeAbsoluteContainingBlockStyleFrame
=
primaryFrame
;
nsIFrame
*
maybeAbsoluteContainingBlock
=
newFrame
;
nsIFrame
*
possiblyLeafFrame
=
newFrame
;
if
(
bits
&
FCDATA_CREATE_BLOCK_WRAPPER_FOR_ALL_KIDS
)
{
RefPtr
<
ComputedStyle
>
outerSC
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveInheritingAnonymousBoxStyle
(
data
-
>
mAnonBoxPseudo
computedStyle
)
;
#
ifdef
DEBUG
nsContainerFrame
*
containerFrame
=
do_QueryFrame
(
newFrame
)
;
MOZ_ASSERT
(
containerFrame
)
;
#
endif
nsContainerFrame
*
container
=
static_cast
<
nsContainerFrame
*
>
(
newFrame
)
;
nsContainerFrame
*
outerFrame
;
nsContainerFrame
*
innerFrame
;
if
(
bits
&
FCDATA_ALLOW_GRID_FLEX_COLUMNSET
)
{
switch
(
display
-
>
mDisplay
)
{
case
StyleDisplay
:
:
Flex
:
case
StyleDisplay
:
:
InlineFlex
:
outerFrame
=
NS_NewFlexContainerFrame
(
mPresShell
outerSC
)
;
InitAndRestoreFrame
(
aState
content
container
outerFrame
)
;
innerFrame
=
outerFrame
;
break
;
case
StyleDisplay
:
:
Grid
:
case
StyleDisplay
:
:
InlineGrid
:
outerFrame
=
NS_NewGridContainerFrame
(
mPresShell
outerSC
)
;
InitAndRestoreFrame
(
aState
content
container
outerFrame
)
;
innerFrame
=
outerFrame
;
break
;
default
:
{
innerFrame
=
NS_NewBlockFormattingContext
(
mPresShell
outerSC
)
;
outerFrame
=
InitAndWrapInColumnSetFrameIfNeeded
(
aState
content
container
innerFrame
outerSC
)
;
break
;
}
}
}
else
{
innerFrame
=
NS_NewBlockFormattingContext
(
mPresShell
outerSC
)
;
InitAndRestoreFrame
(
aState
content
container
innerFrame
)
;
outerFrame
=
innerFrame
;
}
SetInitialSingleChild
(
container
outerFrame
)
;
container
-
>
AddStateBits
(
NS_FRAME_OWNS_ANON_BOXES
)
;
auto
outerDisplay
=
outerSC
-
>
StyleDisplay
(
)
;
if
(
outerDisplay
-
>
IsAbsPosContainingBlock
(
outerFrame
)
)
{
maybeAbsoluteContainingBlock
=
outerFrame
;
maybeAbsoluteContainingBlockStyleFrame
=
outerFrame
;
innerFrame
-
>
AddStateBits
(
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
;
}
newFrame
=
innerFrame
;
}
aState
.
AddChild
(
frameToAddToList
aFrameItems
content
aParentFrame
allowOutOfFlow
allowOutOfFlow
isPopup
)
;
nsContainerFrame
*
newFrameAsContainer
=
do_QueryFrame
(
newFrame
)
;
if
(
newFrameAsContainer
)
{
#
ifdef
MOZ_XUL
if
(
aItem
.
mIsRootPopupgroup
)
{
NS_ASSERTION
(
nsIPopupContainer
:
:
GetPopupContainer
(
mPresShell
)
&
&
nsIPopupContainer
:
:
GetPopupContainer
(
mPresShell
)
-
>
GetPopupSetFrame
(
)
=
=
newFrame
"
Unexpected
PopupSetFrame
"
)
;
aState
.
mPopupItems
.
containingBlock
=
newFrameAsContainer
;
aState
.
mHavePendingPopupgroup
=
false
;
}
#
endif
nsFrameItems
childItems
;
nsFrameConstructorSaveState
absoluteSaveState
;
if
(
bits
&
FCDATA_FORCE_NULL_ABSPOS_CONTAINER
)
{
aState
.
PushAbsoluteContainingBlock
(
nullptr
nullptr
absoluteSaveState
)
;
}
else
if
(
!
(
bits
&
FCDATA_SKIP_ABSPOS_PUSH
)
)
{
maybeAbsoluteContainingBlock
-
>
AddStateBits
(
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
;
if
(
maybeAbsoluteContainingBlockStyleFrame
-
>
IsAbsPosContainingBlock
(
)
)
{
auto
*
cf
=
static_cast
<
nsContainerFrame
*
>
(
maybeAbsoluteContainingBlock
)
;
aState
.
PushAbsoluteContainingBlock
(
cf
maybeAbsoluteContainingBlockStyleFrame
absoluteSaveState
)
;
}
}
if
(
bits
&
FCDATA_USE_CHILD_ITEMS
)
{
nsFrameConstructorSaveState
floatSaveState
;
if
(
ShouldSuppressFloatingOfDescendants
(
newFrame
)
)
{
aState
.
PushFloatContainingBlock
(
nullptr
floatSaveState
)
;
}
else
if
(
newFrame
-
>
IsFloatContainingBlock
(
)
)
{
aState
.
PushFloatContainingBlock
(
newFrameAsContainer
floatSaveState
)
;
}
ConstructFramesFromItemList
(
aState
aItem
.
mChildItems
newFrameAsContainer
bits
&
FCDATA_IS_WRAPPER_ANON_BOX
childItems
)
;
}
else
{
ProcessChildren
(
aState
content
computedStyle
newFrameAsContainer
!
(
bits
&
FCDATA_DISALLOW_GENERATED_CONTENT
)
childItems
(
bits
&
FCDATA_ALLOW_BLOCK_STYLES
)
!
=
0
aItem
.
mPendingBinding
possiblyLeafFrame
)
;
}
if
(
bits
&
FCDATA_WRAP_KIDS_IN_BLOCKS
)
{
nsFrameItems
newItems
;
nsFrameItems
currentBlockItems
;
nsIFrame
*
f
;
while
(
(
f
=
childItems
.
FirstChild
(
)
)
!
=
nullptr
)
{
bool
wrapFrame
=
IsInlineFrame
(
f
)
|
|
IsFramePartOfIBSplit
(
f
)
;
if
(
!
wrapFrame
)
{
FlushAccumulatedBlock
(
aState
content
newFrameAsContainer
currentBlockItems
newItems
)
;
}
childItems
.
RemoveFrame
(
f
)
;
if
(
wrapFrame
)
{
currentBlockItems
.
AddChild
(
f
)
;
}
else
{
newItems
.
AddChild
(
f
)
;
}
}
FlushAccumulatedBlock
(
aState
content
newFrameAsContainer
currentBlockItems
newItems
)
;
if
(
childItems
.
NotEmpty
(
)
)
{
childItems
.
DestroyFrames
(
)
;
}
childItems
=
newItems
;
}
newFrameAsContainer
-
>
SetInitialChildList
(
kPrincipalList
childItems
)
;
if
(
bits
&
FCDATA_MAY_NEED_BULLET
)
{
nsBlockFrame
*
block
=
nsLayoutUtils
:
:
GetAsBlock
(
newFrameAsContainer
)
;
MOZ_ASSERT
(
block
"
FCDATA_MAY_NEED_BULLET
should
not
be
set
on
"
"
non
-
block
type
!
"
)
;
CreateBulletFrameForListItemIfNeeded
(
block
)
;
}
}
}
NS_ASSERTION
(
newFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eLineParticipant
)
=
=
(
(
bits
&
FCDATA_IS_LINE_PARTICIPANT
)
!
=
0
)
"
Incorrectly
set
FCDATA_IS_LINE_PARTICIPANT
bits
"
)
;
if
(
aItem
.
mIsAnonymousContentCreatorContent
)
{
primaryFrame
-
>
AddStateBits
(
NS_FRAME_ANONYMOUSCONTENTCREATOR_CONTENT
)
;
}
if
(
(
!
aState
.
mCreatingExtraFrames
|
|
(
primaryFrame
-
>
HasAnyStateBits
(
NS_FRAME_ANONYMOUSCONTENTCREATOR_CONTENT
|
NS_FRAME_GENERATED_CONTENT
)
&
&
!
aItem
.
mContent
-
>
GetPrimaryFrame
(
)
)
)
&
&
!
(
bits
&
FCDATA_SKIP_FRAMESET
)
)
{
aItem
.
mContent
-
>
SetPrimaryFrame
(
primaryFrame
)
;
ActiveLayerTracker
:
:
TransferActivityToFrame
(
aItem
.
mContent
primaryFrame
)
;
}
}
static
void
SetFlagsOnSubtree
(
nsIContent
*
aNode
uintptr_t
aFlagsToSet
)
{
#
ifdef
DEBUG
{
FlattenedChildIterator
iter
(
aNode
)
;
NS_ASSERTION
(
!
iter
.
XBLInvolved
(
)
|
|
!
iter
.
GetNextChild
(
)
"
The
node
should
not
have
any
XBL
children
"
)
;
}
#
endif
aNode
-
>
SetFlags
(
aFlagsToSet
)
;
for
(
nsIContent
*
child
=
aNode
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
SetFlagsOnSubtree
(
child
aFlagsToSet
)
;
}
}
nsresult
nsCSSFrameConstructor
:
:
GetAnonymousContent
(
nsIContent
*
aParent
nsIFrame
*
aParentFrame
nsTArray
<
nsIAnonymousContentCreator
:
:
ContentInfo
>
&
aContent
)
{
nsIAnonymousContentCreator
*
creator
=
do_QueryFrame
(
aParentFrame
)
;
if
(
!
creator
)
return
NS_OK
;
nsresult
rv
=
creator
-
>
CreateAnonymousContent
(
aContent
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
for
(
const
auto
&
info
:
aContent
)
{
nsIContent
*
content
=
info
.
mContent
;
content
-
>
SetIsNativeAnonymousRoot
(
)
;
bool
anonContentIsEditable
=
content
-
>
HasFlag
(
NODE_IS_EDITABLE
)
;
Document
*
bindDocument
=
aParent
-
>
HasFlag
(
NODE_IS_IN_SHADOW_TREE
)
?
nullptr
:
mDocument
;
rv
=
content
-
>
BindToTree
(
bindDocument
aParent
aParent
)
;
if
(
anonContentIsEditable
)
{
NS_ASSERTION
(
aParentFrame
-
>
IsTextInputFrame
(
)
"
We
only
expect
this
for
anonymous
content
under
a
text
"
"
control
frame
"
)
;
SetFlagsOnSubtree
(
content
NODE_IS_EDITABLE
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
content
-
>
UnbindFromTree
(
)
;
return
rv
;
}
}
ServoStyleSet
*
styleSet
=
mPresShell
-
>
StyleSet
(
)
;
for
(
auto
&
info
:
aContent
)
{
if
(
info
.
mContent
-
>
IsElement
(
)
)
{
styleSet
-
>
StyleNewSubtree
(
info
.
mContent
-
>
AsElement
(
)
)
;
}
}
return
NS_OK
;
}
static
bool
IsXULDisplayType
(
const
nsStyleDisplay
*
aDisplay
)
{
if
(
!
StaticPrefs
:
:
layout_css_emulate_moz_box_with_flex
(
)
&
&
(
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
MozInlineBox
|
|
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
MozBox
)
)
{
return
true
;
}
#
ifdef
MOZ_XUL
return
(
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
MozInlineGrid
|
|
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
MozInlineStack
|
|
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
MozGrid
|
|
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
MozStack
|
|
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
MozGridGroup
|
|
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
MozGridLine
|
|
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
MozDeck
|
|
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
MozPopup
|
|
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
MozGroupbox
)
;
#
else
return
false
;
#
endif
}
#
define
SIMPLE_XUL_FCDATA
(
_func
)
\
FCDATA_DECL
(
FCDATA_DISALLOW_OUT_OF_FLOW
|
FCDATA_SKIP_ABSPOS_PUSH
_func
)
#
define
SCROLLABLE_XUL_FCDATA
(
_func
)
\
FCDATA_DECL
(
FCDATA_DISALLOW_OUT_OF_FLOW
|
FCDATA_SKIP_ABSPOS_PUSH
|
\
FCDATA_MAY_NEED_SCROLLFRAME
\
_func
)
#
define
SCROLLABLE_ABSPOS_CONTAINER_XUL_FCDATA
(
_func
)
\
FCDATA_DECL
(
FCDATA_DISALLOW_OUT_OF_FLOW
|
FCDATA_MAY_NEED_SCROLLFRAME
_func
)
#
define
SIMPLE_XUL_CREATE
(
_tag
_func
)
\
{
nsGkAtoms
:
:
_tag
SIMPLE_XUL_FCDATA
(
_func
)
}
#
define
SCROLLABLE_XUL_CREATE
(
_tag
_func
)
\
{
nsGkAtoms
:
:
_tag
SCROLLABLE_XUL_FCDATA
(
_func
)
}
#
define
SIMPLE_XUL_DISPLAY_CREATE
(
_display
_func
)
\
FCDATA_FOR_DISPLAY
(
_display
SIMPLE_XUL_FCDATA
(
_func
)
)
#
define
SCROLLABLE_XUL_DISPLAY_CREATE
(
_display
_func
)
\
FCDATA_FOR_DISPLAY
(
_display
SCROLLABLE_XUL_FCDATA
(
_func
)
)
#
define
SCROLLABLE_ABSPOS_CONTAINER_XUL_DISPLAY_CREATE
(
_display
_func
)
\
FCDATA_FOR_DISPLAY
(
_display
SCROLLABLE_ABSPOS_CONTAINER_XUL_FCDATA
(
_func
)
)
static
nsIFrame
*
NS_NewGridBoxFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aComputedStyle
)
{
nsCOMPtr
<
nsBoxLayout
>
layout
;
NS_NewGridLayout2
(
aPresShell
getter_AddRefs
(
layout
)
)
;
return
NS_NewBoxFrame
(
aPresShell
aComputedStyle
false
layout
)
;
}
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindXULTagData
(
const
Element
&
aElement
nsAtom
*
aTag
ComputedStyle
&
aStyle
)
{
MOZ_ASSERT
(
aElement
.
IsXULElement
(
)
)
;
static
const
FrameConstructionDataByTag
sXULTagData
[
]
=
{
#
ifdef
MOZ_XUL
SCROLLABLE_XUL_CREATE
(
button
NS_NewButtonBoxFrame
)
SCROLLABLE_XUL_CREATE
(
thumb
NS_NewButtonBoxFrame
)
SCROLLABLE_XUL_CREATE
(
checkbox
NS_NewButtonBoxFrame
)
SCROLLABLE_XUL_CREATE
(
radio
NS_NewButtonBoxFrame
)
SCROLLABLE_XUL_CREATE
(
titlebar
NS_NewTitleBarFrame
)
SCROLLABLE_XUL_CREATE
(
resizer
NS_NewResizerFrame
)
SCROLLABLE_XUL_CREATE
(
toolbarpaletteitem
NS_NewBoxFrame
)
SCROLLABLE_XUL_CREATE
(
treecolpicker
NS_NewButtonBoxFrame
)
SIMPLE_XUL_CREATE
(
image
NS_NewImageBoxFrame
)
SIMPLE_XUL_CREATE
(
spring
NS_NewLeafBoxFrame
)
SIMPLE_XUL_CREATE
(
spacer
NS_NewLeafBoxFrame
)
SIMPLE_XUL_CREATE
(
treechildren
NS_NewTreeBodyFrame
)
SIMPLE_XUL_CREATE
(
treecol
NS_NewTreeColFrame
)
SIMPLE_XUL_CREATE
(
text
NS_NewTextBoxFrame
)
SIMPLE_TAG_CHAIN
(
label
nsCSSFrameConstructor
:
:
FindXULLabelData
)
SIMPLE_TAG_CHAIN
(
description
nsCSSFrameConstructor
:
:
FindXULDescriptionData
)
SIMPLE_XUL_CREATE
(
menu
NS_NewMenuFrame
)
SIMPLE_XUL_CREATE
(
menubutton
NS_NewMenuFrame
)
SIMPLE_XUL_CREATE
(
menulist
NS_NewMenuFrame
)
SIMPLE_XUL_CREATE
(
menuitem
NS_NewMenuItemFrame
)
#
ifdef
XP_MACOSX
SIMPLE_TAG_CHAIN
(
menubar
nsCSSFrameConstructor
:
:
FindXULMenubarData
)
#
else
SIMPLE_XUL_CREATE
(
menubar
NS_NewMenuBarFrame
)
#
endif
SIMPLE_TAG_CHAIN
(
popupgroup
nsCSSFrameConstructor
:
:
FindPopupGroupData
)
SIMPLE_XUL_CREATE
(
iframe
NS_NewSubDocumentFrame
)
SIMPLE_XUL_CREATE
(
editor
NS_NewSubDocumentFrame
)
SIMPLE_XUL_CREATE
(
browser
NS_NewSubDocumentFrame
)
SIMPLE_XUL_CREATE
(
splitter
NS_NewSplitterFrame
)
#
endif
SIMPLE_XUL_CREATE
(
slider
NS_NewSliderFrame
)
SIMPLE_XUL_CREATE
(
scrollbar
NS_NewScrollbarFrame
)
SIMPLE_XUL_CREATE
(
scrollbarbutton
NS_NewScrollbarButtonFrame
)
}
;
return
FindDataByTag
(
aTag
aElement
aStyle
sXULTagData
ArrayLength
(
sXULTagData
)
)
;
}
#
ifdef
MOZ_XUL
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindPopupGroupData
(
const
Element
&
aElement
ComputedStyle
&
)
{
if
(
!
aElement
.
IsRootOfNativeAnonymousSubtree
(
)
)
{
return
nullptr
;
}
static
const
FrameConstructionData
sPopupSetData
=
SIMPLE_XUL_FCDATA
(
NS_NewPopupSetFrame
)
;
return
&
sPopupSetData
;
}
const
nsCSSFrameConstructor
:
:
FrameConstructionData
nsCSSFrameConstructor
:
:
sXULTextBoxData
=
SIMPLE_XUL_FCDATA
(
NS_NewTextBoxFrame
)
;
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindXULLabelData
(
const
Element
&
aElement
ComputedStyle
&
)
{
if
(
aElement
.
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
value
)
)
{
return
&
sXULTextBoxData
;
}
static
const
FrameConstructionData
sLabelData
=
SIMPLE_XUL_FCDATA
(
NS_NewXULLabelFrame
)
;
return
&
sLabelData
;
}
static
nsIFrame
*
NS_NewXULDescriptionFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aContext
)
{
return
NS_NewBlockFormattingContext
(
aPresShell
aContext
)
;
}
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindXULDescriptionData
(
const
Element
&
aElement
ComputedStyle
&
)
{
if
(
aElement
.
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
value
)
)
{
return
&
sXULTextBoxData
;
}
static
const
FrameConstructionData
sDescriptionData
=
SIMPLE_XUL_FCDATA
(
NS_NewXULDescriptionFrame
)
;
return
&
sDescriptionData
;
}
#
ifdef
XP_MACOSX
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindXULMenubarData
(
const
Element
&
aElement
ComputedStyle
&
)
{
nsCOMPtr
<
nsIDocShell
>
treeItem
=
aElement
.
OwnerDoc
(
)
-
>
GetDocShell
(
)
;
if
(
treeItem
&
&
nsIDocShellTreeItem
:
:
typeChrome
=
=
treeItem
-
>
ItemType
(
)
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
parent
;
treeItem
-
>
GetParent
(
getter_AddRefs
(
parent
)
)
;
if
(
!
parent
)
{
static
const
FrameConstructionData
sSuppressData
=
SUPPRESS_FCDATA
(
)
;
return
&
sSuppressData
;
}
}
static
const
FrameConstructionData
sMenubarData
=
SIMPLE_XUL_FCDATA
(
NS_NewMenuBarFrame
)
;
return
&
sMenubarData
;
}
#
endif
#
endif
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindXULDisplayData
(
const
nsStyleDisplay
&
aDisplay
const
Element
&
aElement
)
{
static
const
FrameConstructionDataByDisplay
sXULDisplayData
[
]
=
{
SCROLLABLE_ABSPOS_CONTAINER_XUL_DISPLAY_CREATE
(
StyleDisplay
:
:
MozBox
NS_NewBoxFrame
)
SCROLLABLE_ABSPOS_CONTAINER_XUL_DISPLAY_CREATE
(
StyleDisplay
:
:
MozInlineBox
NS_NewBoxFrame
)
#
ifdef
MOZ_XUL
SCROLLABLE_XUL_DISPLAY_CREATE
(
StyleDisplay
:
:
MozGrid
NS_NewGridBoxFrame
)
SCROLLABLE_XUL_DISPLAY_CREATE
(
StyleDisplay
:
:
MozInlineGrid
NS_NewGridBoxFrame
)
SCROLLABLE_XUL_DISPLAY_CREATE
(
StyleDisplay
:
:
MozGridGroup
NS_NewGridRowGroupFrame
)
SCROLLABLE_XUL_DISPLAY_CREATE
(
StyleDisplay
:
:
MozGridLine
NS_NewGridRowLeafFrame
)
SCROLLABLE_XUL_DISPLAY_CREATE
(
StyleDisplay
:
:
MozStack
NS_NewStackFrame
)
SCROLLABLE_XUL_DISPLAY_CREATE
(
StyleDisplay
:
:
MozInlineStack
NS_NewStackFrame
)
SIMPLE_XUL_DISPLAY_CREATE
(
StyleDisplay
:
:
MozDeck
NS_NewDeckFrame
)
SCROLLABLE_XUL_DISPLAY_CREATE
(
StyleDisplay
:
:
MozGroupbox
NS_NewGroupBoxFrame
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
MozPopup
FCDATA_DECL
(
FCDATA_DISALLOW_OUT_OF_FLOW
|
FCDATA_IS_POPUP
|
FCDATA_SKIP_ABSPOS_PUSH
NS_NewMenuPopupFrame
)
)
#
endif
}
;
if
(
aDisplay
.
mDisplay
<
StyleDisplay
:
:
MozBox
)
{
return
nullptr
;
}
MOZ_ASSERT
(
aDisplay
.
mDisplay
<
=
StyleDisplay
:
:
MozPopup
"
Someone
added
a
new
display
value
?
"
)
;
if
(
aDisplay
.
mDisplay
=
=
StyleDisplay
:
:
MozBox
|
|
aDisplay
.
mDisplay
=
=
StyleDisplay
:
:
MozInlineBox
)
{
if
(
!
aElement
.
IsInNativeAnonymousSubtree
(
)
&
&
aElement
.
OwnerDoc
(
)
-
>
IsContentDocument
(
)
)
{
aElement
.
OwnerDoc
(
)
-
>
WarnOnceAbout
(
Document
:
:
eMozBoxOrInlineBoxDisplay
)
;
}
if
(
StaticPrefs
:
:
layout_css_emulate_moz_box_with_flex
(
)
&
&
!
aElement
.
IsXULElement
(
nsGkAtoms
:
:
scrollcorner
)
)
{
return
nullptr
;
}
}
const
FrameConstructionDataByDisplay
&
data
=
sXULDisplayData
[
size_t
(
aDisplay
.
mDisplay
)
-
size_t
(
StyleDisplay
:
:
MozBox
)
]
;
MOZ_ASSERT
(
aDisplay
.
mDisplay
=
=
data
.
mDisplay
"
Did
someone
mess
with
the
order
?
"
)
;
return
&
data
.
mData
;
}
already_AddRefed
<
ComputedStyle
>
nsCSSFrameConstructor
:
:
BeginBuildingScrollFrame
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
ComputedStyle
*
aContentStyle
nsContainerFrame
*
aParentFrame
nsAtom
*
aScrolledPseudo
bool
aIsRoot
nsContainerFrame
*
&
aNewFrame
)
{
nsContainerFrame
*
gfxScrollFrame
=
aNewFrame
;
nsFrameItems
anonymousItems
;
RefPtr
<
ComputedStyle
>
contentStyle
=
aContentStyle
;
if
(
!
gfxScrollFrame
)
{
const
nsStyleDisplay
*
displayStyle
=
aContentStyle
-
>
StyleDisplay
(
)
;
if
(
IsXULDisplayType
(
displayStyle
)
)
{
gfxScrollFrame
=
NS_NewXULScrollFrame
(
mPresShell
contentStyle
aIsRoot
displayStyle
-
>
mDisplay
=
=
StyleDisplay
:
:
MozStack
|
|
displayStyle
-
>
mDisplay
=
=
StyleDisplay
:
:
MozInlineStack
)
;
}
else
{
gfxScrollFrame
=
NS_NewHTMLScrollFrame
(
mPresShell
contentStyle
aIsRoot
)
;
}
InitAndRestoreFrame
(
aState
aContent
aParentFrame
gfxScrollFrame
)
;
}
AutoTArray
<
nsIAnonymousContentCreator
:
:
ContentInfo
4
>
scrollNAC
;
DebugOnly
<
nsresult
>
rv
=
GetAnonymousContent
(
aContent
gfxScrollFrame
scrollNAC
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
scrollNAC
.
Length
(
)
>
0
)
{
AutoFrameConstructionItemList
items
(
this
)
;
AddFCItemsForAnonymousContent
(
aState
gfxScrollFrame
scrollNAC
items
)
;
ConstructFramesFromItemList
(
aState
items
gfxScrollFrame
false
anonymousItems
)
;
}
aNewFrame
=
gfxScrollFrame
;
gfxScrollFrame
-
>
AddStateBits
(
NS_FRAME_OWNS_ANON_BOXES
)
;
ServoStyleSet
*
styleSet
=
mPresShell
-
>
StyleSet
(
)
;
RefPtr
<
ComputedStyle
>
scrolledChildStyle
=
styleSet
-
>
ResolveInheritingAnonymousBoxStyle
(
aScrolledPseudo
contentStyle
)
;
if
(
gfxScrollFrame
)
{
gfxScrollFrame
-
>
SetInitialChildList
(
kPrincipalList
anonymousItems
)
;
}
return
scrolledChildStyle
.
forget
(
)
;
}
void
nsCSSFrameConstructor
:
:
FinishBuildingScrollFrame
(
nsContainerFrame
*
aScrollFrame
nsIFrame
*
aScrolledFrame
)
{
nsFrameList
scrolled
(
aScrolledFrame
aScrolledFrame
)
;
aScrollFrame
-
>
AppendFrames
(
kPrincipalList
scrolled
)
;
}
void
nsCSSFrameConstructor
:
:
BuildScrollFrame
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
ComputedStyle
*
aContentStyle
nsIFrame
*
aScrolledFrame
nsContainerFrame
*
aParentFrame
nsContainerFrame
*
&
aNewFrame
)
{
RefPtr
<
ComputedStyle
>
scrolledContentStyle
=
BeginBuildingScrollFrame
(
aState
aContent
aContentStyle
aParentFrame
nsCSSAnonBoxes
:
:
scrolledContent
(
)
false
aNewFrame
)
;
aScrolledFrame
-
>
SetComputedStyleWithoutNotification
(
scrolledContentStyle
)
;
InitAndRestoreFrame
(
aState
aContent
aNewFrame
aScrolledFrame
)
;
FinishBuildingScrollFrame
(
aNewFrame
aScrolledFrame
)
;
}
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindDisplayData
(
const
nsStyleDisplay
&
aDisplay
const
Element
&
aElement
)
{
static_assert
(
eParentTypeCount
<
(
1
<
<
(
32
-
FCDATA_PARENT_TYPE_OFFSET
)
)
"
Check
eParentTypeCount
should
not
overflow
"
)
;
NS_ASSERTION
(
!
(
aDisplay
.
IsFloatingStyle
(
)
|
|
aDisplay
.
IsAbsolutelyPositionedStyle
(
)
)
|
|
aDisplay
.
IsBlockOutsideStyle
(
)
|
|
aDisplay
.
mDisplay
=
=
StyleDisplay
:
:
Contents
"
Style
system
did
not
apply
CSS2
.
1
section
9
.
7
fixups
"
)
;
bool
propagatedScrollToViewport
=
false
;
if
(
aElement
.
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
if
(
nsPresContext
*
presContext
=
mPresShell
-
>
GetPresContext
(
)
)
{
propagatedScrollToViewport
=
presContext
-
>
UpdateViewportScrollStylesOverride
(
)
=
=
&
aElement
;
}
}
NS_ASSERTION
(
!
propagatedScrollToViewport
|
|
!
mPresShell
-
>
GetPresContext
(
)
-
>
IsPaginated
(
)
"
Shouldn
'
t
propagate
scroll
in
paginated
contexts
"
)
;
if
(
aDisplay
.
IsBlockInsideStyle
(
)
)
{
const
uint32_t
kCaptionCtorFlags
=
FCDATA_IS_TABLE_PART
|
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
eTypeTable
)
;
bool
caption
=
aDisplay
.
mDisplay
=
=
StyleDisplay
:
:
TableCaption
;
bool
suppressScrollFrame
=
false
;
bool
needScrollFrame
=
aDisplay
.
IsScrollableOverflow
(
)
&
&
!
propagatedScrollToViewport
;
if
(
needScrollFrame
)
{
suppressScrollFrame
=
mPresShell
-
>
GetPresContext
(
)
-
>
IsPaginated
(
)
&
&
aDisplay
.
IsBlockOutsideStyle
(
)
&
&
!
aElement
.
IsInNativeAnonymousSubtree
(
)
;
if
(
!
suppressScrollFrame
)
{
static
const
FrameConstructionData
sScrollableBlockData
[
2
]
=
{
FULL_CTOR_FCDATA
(
0
&
nsCSSFrameConstructor
:
:
ConstructScrollableBlock
)
FULL_CTOR_FCDATA
(
kCaptionCtorFlags
&
nsCSSFrameConstructor
:
:
ConstructScrollableBlock
)
}
;
return
&
sScrollableBlockData
[
caption
]
;
}
if
(
mPresShell
-
>
GetPresContext
(
)
-
>
ElementWouldPropagateScrollStyles
(
aElement
)
)
{
suppressScrollFrame
=
false
;
}
}
static
const
FrameConstructionData
sNonScrollableBlockData
[
2
]
[
2
]
=
{
{
FULL_CTOR_FCDATA
(
0
&
nsCSSFrameConstructor
:
:
ConstructNonScrollableBlock
)
FULL_CTOR_FCDATA
(
kCaptionCtorFlags
&
nsCSSFrameConstructor
:
:
ConstructNonScrollableBlock
)
}
{
FULL_CTOR_FCDATA
(
FCDATA_FORCED_NON_SCROLLABLE_BLOCK
&
nsCSSFrameConstructor
:
:
ConstructNonScrollableBlock
)
FULL_CTOR_FCDATA
(
FCDATA_FORCED_NON_SCROLLABLE_BLOCK
|
kCaptionCtorFlags
&
nsCSSFrameConstructor
:
:
ConstructNonScrollableBlock
)
}
}
;
return
&
sNonScrollableBlockData
[
suppressScrollFrame
]
[
caption
]
;
}
if
(
propagatedScrollToViewport
&
&
aDisplay
.
IsScrollableOverflow
(
)
)
{
if
(
aDisplay
.
mDisplay
=
=
StyleDisplay
:
:
Flex
|
|
aDisplay
.
mDisplay
=
=
StyleDisplay
:
:
WebkitBox
|
|
(
StaticPrefs
:
:
layout_css_emulate_moz_box_with_flex
(
)
&
&
aDisplay
.
mDisplay
=
=
StyleDisplay
:
:
MozBox
)
)
{
static
const
FrameConstructionData
sNonScrollableFlexData
=
FCDATA_DECL
(
0
NS_NewFlexContainerFrame
)
;
return
&
sNonScrollableFlexData
;
}
if
(
aDisplay
.
mDisplay
=
=
StyleDisplay
:
:
Grid
)
{
static
const
FrameConstructionData
sNonScrollableGridData
=
FCDATA_DECL
(
0
NS_NewGridContainerFrame
)
;
return
&
sNonScrollableGridData
;
}
}
static
const
FrameConstructionDataByDisplay
sDisplayData
[
]
=
{
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
None
UNREACHABLE_FCDATA
(
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
Block
UNREACHABLE_FCDATA
(
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
FlowRoot
UNREACHABLE_FCDATA
(
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
Inline
FULL_CTOR_FCDATA
(
FCDATA_IS_INLINE
|
FCDATA_IS_LINE_PARTICIPANT
&
nsCSSFrameConstructor
:
:
ConstructInline
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
InlineBlock
UNREACHABLE_FCDATA
(
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
ListItem
UNREACHABLE_FCDATA
(
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
Table
FULL_CTOR_FCDATA
(
0
&
nsCSSFrameConstructor
:
:
ConstructTable
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
InlineTable
FULL_CTOR_FCDATA
(
0
&
nsCSSFrameConstructor
:
:
ConstructTable
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
TableRowGroup
FULL_CTOR_FCDATA
(
FCDATA_IS_TABLE_PART
|
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
eTypeTable
)
&
nsCSSFrameConstructor
:
:
ConstructTableRowOrRowGroup
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
TableColumn
FULL_CTOR_FCDATA
(
FCDATA_IS_TABLE_PART
|
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
eTypeColGroup
)
&
nsCSSFrameConstructor
:
:
ConstructTableCol
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
TableColumnGroup
FCDATA_DECL
(
FCDATA_IS_TABLE_PART
|
FCDATA_DISALLOW_OUT_OF_FLOW
|
FCDATA_SKIP_ABSPOS_PUSH
|
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
eTypeTable
)
NS_NewTableColGroupFrame
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
TableHeaderGroup
FULL_CTOR_FCDATA
(
FCDATA_IS_TABLE_PART
|
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
eTypeTable
)
&
nsCSSFrameConstructor
:
:
ConstructTableRowOrRowGroup
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
TableFooterGroup
FULL_CTOR_FCDATA
(
FCDATA_IS_TABLE_PART
|
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
eTypeTable
)
&
nsCSSFrameConstructor
:
:
ConstructTableRowOrRowGroup
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
TableRow
FULL_CTOR_FCDATA
(
FCDATA_IS_TABLE_PART
|
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
eTypeRowGroup
)
&
nsCSSFrameConstructor
:
:
ConstructTableRowOrRowGroup
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
TableCell
FULL_CTOR_FCDATA
(
FCDATA_IS_TABLE_PART
|
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
eTypeRow
)
&
nsCSSFrameConstructor
:
:
ConstructTableCell
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
TableCaption
UNREACHABLE_FCDATA
(
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
Flex
FCDATA_DECL
(
FCDATA_MAY_NEED_SCROLLFRAME
NS_NewFlexContainerFrame
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
InlineFlex
FCDATA_DECL
(
FCDATA_MAY_NEED_SCROLLFRAME
NS_NewFlexContainerFrame
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
Grid
FCDATA_DECL
(
FCDATA_MAY_NEED_SCROLLFRAME
NS_NewGridContainerFrame
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
InlineGrid
FCDATA_DECL
(
FCDATA_MAY_NEED_SCROLLFRAME
NS_NewGridContainerFrame
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
Ruby
FCDATA_DECL
(
FCDATA_IS_LINE_PARTICIPANT
NS_NewRubyFrame
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
RubyBase
FCDATA_DECL
(
FCDATA_IS_LINE_PARTICIPANT
|
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
eTypeRubyBaseContainer
)
NS_NewRubyBaseFrame
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
RubyBaseContainer
FCDATA_DECL
(
FCDATA_IS_LINE_PARTICIPANT
|
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
eTypeRuby
)
NS_NewRubyBaseContainerFrame
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
RubyText
FCDATA_DECL
(
FCDATA_IS_LINE_PARTICIPANT
|
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
eTypeRubyTextContainer
)
NS_NewRubyTextFrame
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
RubyTextContainer
FCDATA_DECL
(
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
eTypeRuby
)
NS_NewRubyTextContainerFrame
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
Contents
UNREACHABLE_FCDATA
(
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
WebkitBox
FCDATA_DECL
(
FCDATA_MAY_NEED_SCROLLFRAME
NS_NewFlexContainerFrame
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
WebkitInlineBox
FCDATA_DECL
(
FCDATA_MAY_NEED_SCROLLFRAME
NS_NewFlexContainerFrame
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
MozBox
FCDATA_DECL
(
FCDATA_MAY_NEED_SCROLLFRAME
NS_NewFlexContainerFrame
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
MozInlineBox
FCDATA_DECL
(
FCDATA_MAY_NEED_SCROLLFRAME
NS_NewFlexContainerFrame
)
)
}
;
static_assert
(
ArrayLength
(
sDisplayData
)
=
=
size_t
(
StyleDisplay
:
:
MozInlineBox
)
+
1
"
Be
sure
to
update
sDisplayData
if
you
touch
StyleDisplay
"
)
;
MOZ_ASSERT
(
StaticPrefs
:
:
layout_css_emulate_moz_box_with_flex
(
)
|
|
(
aDisplay
.
mDisplay
!
=
StyleDisplay
:
:
MozBox
&
&
aDisplay
.
mDisplay
!
=
StyleDisplay
:
:
MozInlineBox
)
"
-
moz
-
{
inline
-
}
box
as
XUL
should
have
already
been
handled
"
)
;
MOZ_ASSERT
(
size_t
(
aDisplay
.
mDisplay
)
<
ArrayLength
(
sDisplayData
)
"
XUL
display
data
should
have
already
been
handled
"
)
;
MOZ_ASSERT
(
aDisplay
.
mDisplay
!
=
StyleDisplay
:
:
Contents
|
|
!
aElement
.
IsRootOfNativeAnonymousSubtree
(
)
"
display
:
contents
on
anonymous
content
is
unsupported
"
)
;
const
FrameConstructionDataByDisplay
&
data
=
sDisplayData
[
size_t
(
aDisplay
.
mDisplay
)
]
;
MOZ_ASSERT
(
data
.
mDisplay
=
=
aDisplay
.
mDisplay
"
Someone
messed
up
the
order
in
the
display
values
"
)
;
return
&
data
.
mData
;
}
nsIFrame
*
nsCSSFrameConstructor
:
:
ConstructScrollableBlock
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aDisplay
nsFrameItems
&
aFrameItems
)
{
return
ConstructScrollableBlockWithConstructor
(
aState
aItem
aParentFrame
aDisplay
aFrameItems
NS_NewBlockFormattingContext
)
;
}
nsIFrame
*
nsCSSFrameConstructor
:
:
ConstructScrollableBlockWithConstructor
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aDisplay
nsFrameItems
&
aFrameItems
BlockFrameCreationFunc
aConstructor
)
{
nsIContent
*
const
content
=
aItem
.
mContent
;
ComputedStyle
*
const
computedStyle
=
aItem
.
mComputedStyle
;
nsContainerFrame
*
newFrame
=
nullptr
;
RefPtr
<
ComputedStyle
>
scrolledContentStyle
=
BeginBuildingScrollFrame
(
aState
content
computedStyle
aState
.
GetGeometricParent
(
*
aDisplay
aParentFrame
)
nsCSSAnonBoxes
:
:
scrolledContent
(
)
false
newFrame
)
;
nsContainerFrame
*
scrolledFrame
=
aConstructor
(
mPresShell
computedStyle
)
;
aState
.
AddChild
(
newFrame
aFrameItems
content
aParentFrame
)
;
nsFrameItems
blockItem
;
ConstructBlock
(
aState
content
newFrame
newFrame
scrolledContentStyle
&
scrolledFrame
blockItem
aDisplay
-
>
IsAbsPosContainingBlock
(
newFrame
)
?
newFrame
:
nullptr
aItem
.
mPendingBinding
)
;
MOZ_ASSERT
(
blockItem
.
OnlyChild
(
)
=
=
scrolledFrame
"
Scrollframe
'
s
frameItems
should
be
exactly
the
scrolled
frame
!
"
)
;
FinishBuildingScrollFrame
(
newFrame
scrolledFrame
)
;
return
newFrame
;
}
nsIFrame
*
nsCSSFrameConstructor
:
:
ConstructNonScrollableBlock
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aDisplay
nsFrameItems
&
aFrameItems
)
{
return
ConstructNonScrollableBlockWithConstructor
(
aState
aItem
aParentFrame
aDisplay
aFrameItems
NS_NewBlockFrame
)
;
}
nsIFrame
*
nsCSSFrameConstructor
:
:
ConstructNonScrollableBlockWithConstructor
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aDisplay
nsFrameItems
&
aFrameItems
BlockFrameCreationFunc
aConstructor
)
{
ComputedStyle
*
const
computedStyle
=
aItem
.
mComputedStyle
;
bool
clipPaginatedOverflow
=
(
aItem
.
mFCData
-
>
mBits
&
FCDATA_FORCED_NON_SCROLLABLE_BLOCK
)
!
=
0
;
nsFrameState
flags
=
nsFrameState
(
0
)
;
if
(
(
aDisplay
-
>
IsAbsolutelyPositionedStyle
(
)
|
|
aDisplay
-
>
IsFloatingStyle
(
)
|
|
StyleDisplay
:
:
InlineBlock
=
=
aDisplay
-
>
mDisplay
|
|
clipPaginatedOverflow
)
&
&
!
nsSVGUtils
:
:
IsInSVGTextSubtree
(
aParentFrame
)
)
{
flags
=
NS_BLOCK_FORMATTING_CONTEXT_STATE_BITS
;
if
(
clipPaginatedOverflow
)
{
flags
|
=
NS_BLOCK_CLIP_PAGINATED_OVERFLOW
;
}
}
nsContainerFrame
*
newFrame
=
aConstructor
(
mPresShell
computedStyle
)
;
newFrame
-
>
AddStateBits
(
flags
)
;
ConstructBlock
(
aState
aItem
.
mContent
aState
.
GetGeometricParent
(
*
aDisplay
aParentFrame
)
aParentFrame
computedStyle
&
newFrame
aFrameItems
aDisplay
-
>
IsAbsPosContainingBlock
(
newFrame
)
?
newFrame
:
nullptr
aItem
.
mPendingBinding
)
;
return
newFrame
;
}
void
nsCSSFrameConstructor
:
:
InitAndRestoreFrame
(
const
nsFrameConstructorState
&
aState
nsIContent
*
aContent
nsContainerFrame
*
aParentFrame
nsIFrame
*
aNewFrame
bool
aAllowCounters
)
{
MOZ_ASSERT
(
aNewFrame
"
Null
frame
cannot
be
initialized
"
)
;
aNewFrame
-
>
Init
(
aContent
aParentFrame
nullptr
)
;
aNewFrame
-
>
AddStateBits
(
aState
.
mAdditionalStateBits
)
;
if
(
aState
.
mFrameState
)
{
RestoreFrameStateFor
(
aNewFrame
aState
.
mFrameState
)
;
}
if
(
aAllowCounters
&
&
mCounterManager
.
AddCounterResetsAndIncrements
(
aNewFrame
)
)
{
CountersDirty
(
)
;
}
}
already_AddRefed
<
ComputedStyle
>
nsCSSFrameConstructor
:
:
ResolveComputedStyle
(
nsIContent
*
aContent
)
{
ServoStyleSet
*
styleSet
=
mPresShell
-
>
StyleSet
(
)
;
if
(
auto
*
element
=
Element
:
:
FromNode
(
aContent
)
)
{
return
styleSet
-
>
ResolveServoStyle
(
*
element
)
;
}
MOZ_ASSERT
(
aContent
-
>
IsText
(
)
"
shouldn
'
t
waste
time
creating
ComputedStyles
for
"
"
comments
and
processing
instructions
"
)
;
Element
*
parent
=
aContent
-
>
GetFlattenedTreeParentElement
(
)
;
MOZ_ASSERT
(
parent
"
Text
out
of
the
flattened
tree
?
"
)
;
RefPtr
<
ComputedStyle
>
parentStyle
=
Servo_Element_GetPrimaryComputedValues
(
parent
)
.
Consume
(
)
;
return
styleSet
-
>
ResolveStyleForText
(
aContent
parentStyle
)
;
}
void
nsCSSFrameConstructor
:
:
FlushAccumulatedBlock
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
nsContainerFrame
*
aParentFrame
nsFrameItems
&
aBlockItems
nsFrameItems
&
aNewItems
)
{
if
(
aBlockItems
.
IsEmpty
(
)
)
{
return
;
}
nsAtom
*
anonPseudo
=
nsCSSAnonBoxes
:
:
mozMathMLAnonymousBlock
(
)
;
ComputedStyle
*
parentContext
=
nsFrame
:
:
CorrectStyleParentFrame
(
aParentFrame
anonPseudo
)
-
>
Style
(
)
;
ServoStyleSet
*
styleSet
=
mPresShell
-
>
StyleSet
(
)
;
RefPtr
<
ComputedStyle
>
blockContext
;
blockContext
=
styleSet
-
>
ResolveInheritingAnonymousBoxStyle
(
anonPseudo
parentContext
)
;
nsContainerFrame
*
blockFrame
=
NS_NewMathMLmathBlockFrame
(
mPresShell
blockContext
)
;
InitAndRestoreFrame
(
aState
aContent
aParentFrame
blockFrame
)
;
ReparentFrames
(
this
blockFrame
aBlockItems
false
)
;
for
(
nsIFrame
*
f
:
aBlockItems
)
{
f
-
>
SetParentIsWrapperAnonBox
(
)
;
}
blockFrame
-
>
SetInitialChildList
(
kPrincipalList
aBlockItems
)
;
NS_ASSERTION
(
aBlockItems
.
IsEmpty
(
)
"
What
happened
?
"
)
;
aBlockItems
.
Clear
(
)
;
aNewItems
.
AddChild
(
blockFrame
)
;
}
#
define
SIMPLE_MATHML_CREATE
(
_tag
_func
)
\
{
\
nsGkAtoms
:
:
_tag
FCDATA_DECL
(
FCDATA_DISALLOW_OUT_OF_FLOW
|
\
FCDATA_FORCE_NULL_ABSPOS_CONTAINER
|
\
FCDATA_WRAP_KIDS_IN_BLOCKS
\
_func
)
\
}
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindMathMLData
(
const
Element
&
aElement
ComputedStyle
&
aStyle
)
{
MOZ_ASSERT
(
aElement
.
IsMathMLElement
(
)
)
;
nsAtom
*
tag
=
aElement
.
NodeInfo
(
)
-
>
NameAtom
(
)
;
if
(
tag
=
=
nsGkAtoms
:
:
math
)
{
if
(
aStyle
.
StyleDisplay
(
)
-
>
IsBlockOutsideStyle
(
)
)
{
static
const
FrameConstructionData
sBlockMathData
=
FCDATA_DECL
(
FCDATA_FORCE_NULL_ABSPOS_CONTAINER
|
FCDATA_WRAP_KIDS_IN_BLOCKS
NS_NewMathMLmathBlockFrame
)
;
return
&
sBlockMathData
;
}
static
const
FrameConstructionData
sInlineMathData
=
FCDATA_DECL
(
FCDATA_FORCE_NULL_ABSPOS_CONTAINER
|
FCDATA_IS_LINE_PARTICIPANT
|
FCDATA_WRAP_KIDS_IN_BLOCKS
NS_NewMathMLmathInlineFrame
)
;
return
&
sInlineMathData
;
}
static
const
FrameConstructionDataByTag
sMathMLData
[
]
=
{
SIMPLE_MATHML_CREATE
(
annotation_
NS_NewMathMLTokenFrame
)
SIMPLE_MATHML_CREATE
(
annotation_xml_
NS_NewMathMLmrowFrame
)
SIMPLE_MATHML_CREATE
(
mi_
NS_NewMathMLTokenFrame
)
SIMPLE_MATHML_CREATE
(
mn_
NS_NewMathMLTokenFrame
)
SIMPLE_MATHML_CREATE
(
ms_
NS_NewMathMLTokenFrame
)
SIMPLE_MATHML_CREATE
(
mtext_
NS_NewMathMLTokenFrame
)
SIMPLE_MATHML_CREATE
(
mo_
NS_NewMathMLmoFrame
)
SIMPLE_MATHML_CREATE
(
mfrac_
NS_NewMathMLmfracFrame
)
SIMPLE_MATHML_CREATE
(
msup_
NS_NewMathMLmmultiscriptsFrame
)
SIMPLE_MATHML_CREATE
(
msub_
NS_NewMathMLmmultiscriptsFrame
)
SIMPLE_MATHML_CREATE
(
msubsup_
NS_NewMathMLmmultiscriptsFrame
)
SIMPLE_MATHML_CREATE
(
munder_
NS_NewMathMLmunderoverFrame
)
SIMPLE_MATHML_CREATE
(
mover_
NS_NewMathMLmunderoverFrame
)
SIMPLE_MATHML_CREATE
(
munderover_
NS_NewMathMLmunderoverFrame
)
SIMPLE_MATHML_CREATE
(
mphantom_
NS_NewMathMLmrowFrame
)
SIMPLE_MATHML_CREATE
(
mpadded_
NS_NewMathMLmpaddedFrame
)
SIMPLE_MATHML_CREATE
(
mspace_
NS_NewMathMLmspaceFrame
)
SIMPLE_MATHML_CREATE
(
none
NS_NewMathMLmspaceFrame
)
SIMPLE_MATHML_CREATE
(
mprescripts_
NS_NewMathMLmspaceFrame
)
SIMPLE_MATHML_CREATE
(
mfenced_
NS_NewMathMLmfencedFrame
)
SIMPLE_MATHML_CREATE
(
mmultiscripts_
NS_NewMathMLmmultiscriptsFrame
)
SIMPLE_MATHML_CREATE
(
mstyle_
NS_NewMathMLmrowFrame
)
SIMPLE_MATHML_CREATE
(
msqrt_
NS_NewMathMLmsqrtFrame
)
SIMPLE_MATHML_CREATE
(
mroot_
NS_NewMathMLmrootFrame
)
SIMPLE_MATHML_CREATE
(
maction_
NS_NewMathMLmactionFrame
)
SIMPLE_MATHML_CREATE
(
mrow_
NS_NewMathMLmrowFrame
)
SIMPLE_MATHML_CREATE
(
merror_
NS_NewMathMLmrowFrame
)
SIMPLE_MATHML_CREATE
(
menclose_
NS_NewMathMLmencloseFrame
)
SIMPLE_MATHML_CREATE
(
semantics_
NS_NewMathMLsemanticsFrame
)
}
;
return
FindDataByTag
(
tag
aElement
aStyle
sMathMLData
ArrayLength
(
sMathMLData
)
)
;
}
nsContainerFrame
*
nsCSSFrameConstructor
:
:
ConstructFrameWithAnonymousChild
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
nsFrameItems
&
aFrameItems
ContainerFrameCreationFunc
aConstructor
ContainerFrameCreationFunc
aInnerConstructor
nsCSSAnonBoxPseudoStaticAtom
*
aInnerPseudo
bool
aCandidateRootFrame
)
{
nsIContent
*
const
content
=
aItem
.
mContent
;
ComputedStyle
*
const
computedStyle
=
aItem
.
mComputedStyle
;
nsContainerFrame
*
newFrame
=
aConstructor
(
mPresShell
computedStyle
)
;
InitAndRestoreFrame
(
aState
content
aCandidateRootFrame
?
aState
.
GetGeometricParent
(
*
computedStyle
-
>
StyleDisplay
(
)
aParentFrame
)
:
aParentFrame
newFrame
)
;
newFrame
-
>
AddStateBits
(
NS_FRAME_OWNS_ANON_BOXES
)
;
RefPtr
<
ComputedStyle
>
scForAnon
;
scForAnon
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveInheritingAnonymousBoxStyle
(
aInnerPseudo
computedStyle
)
;
nsContainerFrame
*
innerFrame
=
aInnerConstructor
(
mPresShell
scForAnon
)
;
InitAndRestoreFrame
(
aState
content
newFrame
innerFrame
)
;
SetInitialSingleChild
(
newFrame
innerFrame
)
;
aState
.
AddChild
(
newFrame
aFrameItems
content
aParentFrame
aCandidateRootFrame
aCandidateRootFrame
)
;
if
(
!
mRootElementFrame
&
&
aCandidateRootFrame
)
{
mRootElementFrame
=
newFrame
;
}
nsFrameItems
childItems
;
if
(
aItem
.
mFCData
-
>
mBits
&
FCDATA_USE_CHILD_ITEMS
)
{
ConstructFramesFromItemList
(
aState
aItem
.
mChildItems
innerFrame
aItem
.
mFCData
-
>
mBits
&
FCDATA_IS_WRAPPER_ANON_BOX
childItems
)
;
}
else
{
ProcessChildren
(
aState
content
computedStyle
innerFrame
true
childItems
false
aItem
.
mPendingBinding
)
;
}
innerFrame
-
>
SetInitialChildList
(
kPrincipalList
childItems
)
;
return
newFrame
;
}
nsIFrame
*
nsCSSFrameConstructor
:
:
ConstructOuterSVG
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aDisplay
nsFrameItems
&
aFrameItems
)
{
return
ConstructFrameWithAnonymousChild
(
aState
aItem
aParentFrame
aFrameItems
NS_NewSVGOuterSVGFrame
NS_NewSVGOuterSVGAnonChildFrame
nsCSSAnonBoxes
:
:
mozSVGOuterSVGAnonChild
(
)
true
)
;
}
nsIFrame
*
nsCSSFrameConstructor
:
:
ConstructMarker
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aDisplay
nsFrameItems
&
aFrameItems
)
{
return
ConstructFrameWithAnonymousChild
(
aState
aItem
aParentFrame
aFrameItems
NS_NewSVGMarkerFrame
NS_NewSVGMarkerAnonChildFrame
nsCSSAnonBoxes
:
:
mozSVGMarkerAnonChild
(
)
false
)
;
}
#
define
SIMPLE_SVG_FCDATA
(
_func
)
\
FCDATA_DECL
(
FCDATA_DISALLOW_OUT_OF_FLOW
|
FCDATA_SKIP_ABSPOS_PUSH
|
\
FCDATA_DISALLOW_GENERATED_CONTENT
\
_func
)
#
define
SIMPLE_SVG_CREATE
(
_tag
_func
)
\
{
nsGkAtoms
:
:
_tag
SIMPLE_SVG_FCDATA
(
_func
)
}
static
bool
IsFilterPrimitiveChildTag
(
const
nsAtom
*
aTag
)
{
return
aTag
=
=
nsGkAtoms
:
:
feDistantLight
|
|
aTag
=
=
nsGkAtoms
:
:
fePointLight
|
|
aTag
=
=
nsGkAtoms
:
:
feSpotLight
|
|
aTag
=
=
nsGkAtoms
:
:
feFuncR
|
|
aTag
=
=
nsGkAtoms
:
:
feFuncG
|
|
aTag
=
=
nsGkAtoms
:
:
feFuncB
|
|
aTag
=
=
nsGkAtoms
:
:
feFuncA
|
|
aTag
=
=
nsGkAtoms
:
:
feMergeNode
;
}
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindSVGData
(
const
Element
&
aElement
nsIFrame
*
aParentFrame
bool
aIsWithinSVGText
bool
aAllowsTextPathChild
ComputedStyle
&
aStyle
)
{
MOZ_ASSERT
(
aElement
.
IsSVGElement
(
)
)
;
static
const
FrameConstructionData
sSuppressData
=
SUPPRESS_FCDATA
(
)
;
static
const
FrameConstructionData
sContainerData
=
SIMPLE_SVG_FCDATA
(
NS_NewSVGContainerFrame
)
;
bool
parentIsSVG
=
aIsWithinSVGText
;
nsIContent
*
parentContent
=
aParentFrame
?
aParentFrame
-
>
GetContent
(
)
:
nullptr
;
nsAtom
*
tag
=
aElement
.
NodeInfo
(
)
-
>
NameAtom
(
)
;
if
(
parentContent
)
{
parentIsSVG
=
parentContent
-
>
IsSVGElement
(
)
&
&
parentContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
!
=
nsGkAtoms
:
:
foreignObject
;
}
if
(
(
tag
!
=
nsGkAtoms
:
:
svg
&
&
!
parentIsSVG
)
|
|
(
tag
=
=
nsGkAtoms
:
:
desc
|
|
tag
=
=
nsGkAtoms
:
:
title
|
|
tag
=
=
nsGkAtoms
:
:
metadata
)
)
{
return
&
sSuppressData
;
}
if
(
aElement
.
IsNodeOfType
(
nsINode
:
:
eANIMATION
)
)
{
return
&
sSuppressData
;
}
if
(
tag
=
=
nsGkAtoms
:
:
svg
&
&
!
parentIsSVG
)
{
static
const
FrameConstructionData
sOuterSVGData
=
FULL_CTOR_FCDATA
(
0
&
nsCSSFrameConstructor
:
:
ConstructOuterSVG
)
;
return
&
sOuterSVGData
;
}
if
(
tag
=
=
nsGkAtoms
:
:
marker
)
{
static
const
FrameConstructionData
sMarkerSVGData
=
FULL_CTOR_FCDATA
(
0
&
nsCSSFrameConstructor
:
:
ConstructMarker
)
;
return
&
sMarkerSVGData
;
}
nsCOMPtr
<
SVGTests
>
tests
=
do_QueryInterface
(
const_cast
<
Element
*
>
(
&
aElement
)
)
;
if
(
tests
&
&
!
tests
-
>
PassesConditionalProcessingTests
(
)
)
{
if
(
aIsWithinSVGText
)
{
return
&
sSuppressData
;
}
return
&
sContainerData
;
}
bool
parentIsGradient
=
aParentFrame
&
&
(
aParentFrame
-
>
IsSVGLinearGradientFrame
(
)
|
|
aParentFrame
-
>
IsSVGRadialGradientFrame
(
)
)
;
bool
stop
=
(
tag
=
=
nsGkAtoms
:
:
stop
)
;
if
(
(
parentIsGradient
&
&
!
stop
)
|
|
(
!
parentIsGradient
&
&
stop
)
)
{
return
&
sSuppressData
;
}
bool
parentIsFilter
=
aParentFrame
&
&
aParentFrame
-
>
IsSVGFilterFrame
(
)
;
bool
filterPrimitive
=
aElement
.
IsNodeOfType
(
nsINode
:
:
eFILTER
)
;
if
(
(
parentIsFilter
&
&
!
filterPrimitive
)
|
|
(
!
parentIsFilter
&
&
filterPrimitive
)
)
{
return
&
sSuppressData
;
}
bool
parentIsFEContainerFrame
=
aParentFrame
&
&
aParentFrame
-
>
IsSVGFEContainerFrame
(
)
;
if
(
(
parentIsFEContainerFrame
&
&
!
IsFilterPrimitiveChildTag
(
tag
)
)
|
|
(
!
parentIsFEContainerFrame
&
&
IsFilterPrimitiveChildTag
(
tag
)
)
)
{
return
&
sSuppressData
;
}
if
(
aIsWithinSVGText
)
{
static
const
FrameConstructionData
sTSpanData
=
FCDATA_DECL
(
FCDATA_DISALLOW_OUT_OF_FLOW
|
FCDATA_SKIP_ABSPOS_PUSH
|
FCDATA_DISALLOW_GENERATED_CONTENT
|
FCDATA_IS_LINE_PARTICIPANT
|
FCDATA_IS_INLINE
|
FCDATA_USE_CHILD_ITEMS
NS_NewInlineFrame
)
;
if
(
tag
=
=
nsGkAtoms
:
:
textPath
)
{
if
(
aAllowsTextPathChild
)
{
return
&
sTSpanData
;
}
}
else
if
(
tag
=
=
nsGkAtoms
:
:
tspan
|
|
tag
=
=
nsGkAtoms
:
:
a
)
{
return
&
sTSpanData
;
}
return
&
sSuppressData
;
}
else
if
(
tag
=
=
nsGkAtoms
:
:
tspan
|
|
tag
=
=
nsGkAtoms
:
:
textPath
)
{
return
&
sSuppressData
;
}
static
const
FrameConstructionDataByTag
sSVGData
[
]
=
{
SIMPLE_SVG_CREATE
(
svg
NS_NewSVGInnerSVGFrame
)
SIMPLE_SVG_CREATE
(
g
NS_NewSVGGFrame
)
SIMPLE_SVG_CREATE
(
svgSwitch
NS_NewSVGSwitchFrame
)
SIMPLE_SVG_CREATE
(
symbol
NS_NewSVGSymbolFrame
)
SIMPLE_SVG_CREATE
(
polygon
NS_NewSVGGeometryFrame
)
SIMPLE_SVG_CREATE
(
polyline
NS_NewSVGGeometryFrame
)
SIMPLE_SVG_CREATE
(
circle
NS_NewSVGGeometryFrame
)
SIMPLE_SVG_CREATE
(
ellipse
NS_NewSVGGeometryFrame
)
SIMPLE_SVG_CREATE
(
line
NS_NewSVGGeometryFrame
)
SIMPLE_SVG_CREATE
(
rect
NS_NewSVGGeometryFrame
)
SIMPLE_SVG_CREATE
(
path
NS_NewSVGGeometryFrame
)
SIMPLE_SVG_CREATE
(
defs
NS_NewSVGContainerFrame
)
SIMPLE_SVG_CREATE
(
generic_
NS_NewSVGGenericContainerFrame
)
{
nsGkAtoms
:
:
text
FCDATA_WITH_WRAPPING_BLOCK
(
FCDATA_DISALLOW_OUT_OF_FLOW
|
FCDATA_ALLOW_BLOCK_STYLES
NS_NewSVGTextFrame
nsCSSAnonBoxes
:
:
mozSVGText
(
)
)
}
{
nsGkAtoms
:
:
foreignObject
FCDATA_WITH_WRAPPING_BLOCK
(
FCDATA_DISALLOW_OUT_OF_FLOW
NS_NewSVGForeignObjectFrame
nsCSSAnonBoxes
:
:
mozSVGForeignContent
(
)
)
}
SIMPLE_SVG_CREATE
(
a
NS_NewSVGAFrame
)
SIMPLE_SVG_CREATE
(
linearGradient
NS_NewSVGLinearGradientFrame
)
SIMPLE_SVG_CREATE
(
radialGradient
NS_NewSVGRadialGradientFrame
)
SIMPLE_SVG_CREATE
(
stop
NS_NewSVGStopFrame
)
SIMPLE_SVG_CREATE
(
use
NS_NewSVGUseFrame
)
SIMPLE_SVG_CREATE
(
view
NS_NewSVGViewFrame
)
SIMPLE_SVG_CREATE
(
image
NS_NewSVGImageFrame
)
SIMPLE_SVG_CREATE
(
clipPath
NS_NewSVGClipPathFrame
)
SIMPLE_SVG_CREATE
(
filter
NS_NewSVGFilterFrame
)
SIMPLE_SVG_CREATE
(
pattern
NS_NewSVGPatternFrame
)
SIMPLE_SVG_CREATE
(
mask
NS_NewSVGMaskFrame
)
SIMPLE_SVG_CREATE
(
feDistantLight
NS_NewSVGFEUnstyledLeafFrame
)
SIMPLE_SVG_CREATE
(
fePointLight
NS_NewSVGFEUnstyledLeafFrame
)
SIMPLE_SVG_CREATE
(
feSpotLight
NS_NewSVGFEUnstyledLeafFrame
)
SIMPLE_SVG_CREATE
(
feBlend
NS_NewSVGFELeafFrame
)
SIMPLE_SVG_CREATE
(
feColorMatrix
NS_NewSVGFELeafFrame
)
SIMPLE_SVG_CREATE
(
feFuncR
NS_NewSVGFEUnstyledLeafFrame
)
SIMPLE_SVG_CREATE
(
feFuncG
NS_NewSVGFEUnstyledLeafFrame
)
SIMPLE_SVG_CREATE
(
feFuncB
NS_NewSVGFEUnstyledLeafFrame
)
SIMPLE_SVG_CREATE
(
feFuncA
NS_NewSVGFEUnstyledLeafFrame
)
SIMPLE_SVG_CREATE
(
feComposite
NS_NewSVGFELeafFrame
)
SIMPLE_SVG_CREATE
(
feComponentTransfer
NS_NewSVGFEContainerFrame
)
SIMPLE_SVG_CREATE
(
feConvolveMatrix
NS_NewSVGFELeafFrame
)
SIMPLE_SVG_CREATE
(
feDiffuseLighting
NS_NewSVGFEContainerFrame
)
SIMPLE_SVG_CREATE
(
feDisplacementMap
NS_NewSVGFELeafFrame
)
SIMPLE_SVG_CREATE
(
feDropShadow
NS_NewSVGFELeafFrame
)
SIMPLE_SVG_CREATE
(
feFlood
NS_NewSVGFELeafFrame
)
SIMPLE_SVG_CREATE
(
feGaussianBlur
NS_NewSVGFELeafFrame
)
SIMPLE_SVG_CREATE
(
feImage
NS_NewSVGFEImageFrame
)
SIMPLE_SVG_CREATE
(
feMerge
NS_NewSVGFEContainerFrame
)
SIMPLE_SVG_CREATE
(
feMergeNode
NS_NewSVGFEUnstyledLeafFrame
)
SIMPLE_SVG_CREATE
(
feMorphology
NS_NewSVGFELeafFrame
)
SIMPLE_SVG_CREATE
(
feOffset
NS_NewSVGFELeafFrame
)
SIMPLE_SVG_CREATE
(
feSpecularLighting
NS_NewSVGFEContainerFrame
)
SIMPLE_SVG_CREATE
(
feTile
NS_NewSVGFELeafFrame
)
SIMPLE_SVG_CREATE
(
feTurbulence
NS_NewSVGFELeafFrame
)
}
;
const
FrameConstructionData
*
data
=
FindDataByTag
(
tag
aElement
aStyle
sSVGData
ArrayLength
(
sSVGData
)
)
;
if
(
!
data
)
{
data
=
&
sContainerData
;
}
return
data
;
}
void
nsCSSFrameConstructor
:
:
AddPageBreakItem
(
nsIContent
*
aContent
FrameConstructionItemList
&
aItems
)
{
RefPtr
<
ComputedStyle
>
pseudoStyle
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveNonInheritingAnonymousBoxStyle
(
nsCSSAnonBoxes
:
:
pageBreak
(
)
)
;
MOZ_ASSERT
(
pseudoStyle
-
>
StyleDisplay
(
)
-
>
mDisplay
=
=
StyleDisplay
:
:
Block
"
Unexpected
display
"
)
;
static
const
FrameConstructionData
sPageBreakData
=
FCDATA_DECL
(
FCDATA_SKIP_FRAMESET
NS_NewPageBreakFrame
)
;
aItems
.
AppendItem
(
this
&
sPageBreakData
aContent
nullptr
pseudoStyle
.
forget
(
)
true
)
;
}
bool
nsCSSFrameConstructor
:
:
ShouldCreateItemsForChild
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
nsContainerFrame
*
aParentFrame
)
{
aContent
-
>
UnsetFlags
(
NODE_DESCENDANTS_NEED_FRAMES
|
NODE_NEEDS_FRAME
)
;
if
(
aContent
-
>
GetPrimaryFrame
(
)
&
&
aContent
-
>
GetPrimaryFrame
(
)
-
>
GetContent
(
)
=
=
aContent
&
&
!
aState
.
mCreatingExtraFrames
)
{
MOZ_ASSERT
(
false
"
asked
to
create
frame
construction
item
for
a
node
that
"
"
already
has
a
frame
"
)
;
return
false
;
}
if
(
!
NeedFrameFor
(
aState
aParentFrame
aContent
)
)
{
return
false
;
}
if
(
aContent
-
>
IsComment
(
)
|
|
aContent
-
>
IsProcessingInstruction
(
)
)
{
return
false
;
}
return
true
;
}
void
nsCSSFrameConstructor
:
:
DoAddFrameConstructionItems
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
ComputedStyle
*
aComputedStyle
bool
aSuppressWhiteSpaceOptimizations
nsContainerFrame
*
aParentFrame
FrameConstructionItemList
&
aItems
)
{
uint32_t
flags
=
ITEM_ALLOW_XBL_BASE
|
ITEM_ALLOW_PAGE_BREAK
;
if
(
aParentFrame
)
{
if
(
nsSVGUtils
:
:
IsInSVGTextSubtree
(
aParentFrame
)
)
{
flags
|
=
ITEM_IS_WITHIN_SVG_TEXT
;
}
if
(
aParentFrame
-
>
IsBlockFrame
(
)
&
&
aParentFrame
-
>
GetParent
(
)
&
&
aParentFrame
-
>
GetParent
(
)
-
>
IsSVGTextFrame
(
)
)
{
flags
|
=
ITEM_ALLOWS_TEXT_PATH_CHILD
;
}
}
AddFrameConstructionItemsInternal
(
aState
aContent
aParentFrame
aSuppressWhiteSpaceOptimizations
aComputedStyle
flags
aItems
)
;
}
void
nsCSSFrameConstructor
:
:
AddFrameConstructionItems
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
bool
aSuppressWhiteSpaceOptimizations
const
InsertionPoint
&
aInsertion
FrameConstructionItemList
&
aItems
)
{
nsContainerFrame
*
parentFrame
=
aInsertion
.
mParentFrame
;
if
(
!
ShouldCreateItemsForChild
(
aState
aContent
parentFrame
)
)
{
return
;
}
RefPtr
<
ComputedStyle
>
computedStyle
=
ResolveComputedStyle
(
aContent
)
;
DoAddFrameConstructionItems
(
aState
aContent
computedStyle
aSuppressWhiteSpaceOptimizations
parentFrame
aItems
)
;
}
static
bool
ShouldSuppressFrameInSelect
(
const
nsIContent
*
aParent
const
nsIContent
&
aChild
)
{
if
(
!
aParent
|
|
!
aParent
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
select
nsGkAtoms
:
:
optgroup
)
)
{
return
false
;
}
if
(
aChild
.
GetParent
(
)
!
=
aParent
)
{
return
true
;
}
if
(
aChild
.
IsHTMLElement
(
nsGkAtoms
:
:
option
)
)
{
return
false
;
}
if
(
aChild
.
IsHTMLElement
(
nsGkAtoms
:
:
optgroup
)
&
&
aParent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
select
)
)
{
return
false
;
}
if
(
aChild
.
IsRootOfAnonymousSubtree
(
)
)
{
return
false
;
}
return
true
;
}
static
bool
ShouldSuppressFrameInNonOpenDetails
(
const
HTMLDetailsElement
*
aDetails
const
nsIContent
&
aChild
)
{
if
(
!
aDetails
|
|
aDetails
-
>
Open
(
)
)
{
return
false
;
}
if
(
aChild
.
GetParent
(
)
!
=
aDetails
)
{
return
true
;
}
auto
*
summary
=
HTMLSummaryElement
:
:
FromNode
(
aChild
)
;
if
(
summary
&
&
summary
-
>
IsMainSummary
(
)
)
{
return
false
;
}
if
(
aChild
.
IsRootOfAnonymousSubtree
(
)
&
&
!
aChild
.
IsGeneratedContentContainerForBefore
(
)
&
&
!
aChild
.
IsGeneratedContentContainerForAfter
(
)
)
{
return
false
;
}
return
true
;
}
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindDataForContent
(
nsIContent
&
aContent
ComputedStyle
&
aStyle
nsIFrame
*
aParentFrame
nsAtom
*
aTag
uint32_t
aFlags
)
{
MOZ_ASSERT
(
aStyle
.
StyleDisplay
(
)
-
>
mDisplay
!
=
StyleDisplay
:
:
None
&
&
aStyle
.
StyleDisplay
(
)
-
>
mDisplay
!
=
StyleDisplay
:
:
Contents
"
These
two
special
display
values
should
be
handled
earlier
"
)
;
if
(
auto
*
text
=
Text
:
:
FromNode
(
aContent
)
)
{
return
FindTextData
(
*
text
aParentFrame
)
;
}
return
FindElementData
(
*
aContent
.
AsElement
(
)
aStyle
aParentFrame
aTag
aFlags
)
;
}
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindElementData
(
const
Element
&
aElement
ComputedStyle
&
aStyle
nsIFrame
*
aParentFrame
nsAtom
*
aTag
uint32_t
aFlags
)
{
if
(
!
aElement
.
IsSVGElement
(
)
)
{
if
(
aParentFrame
&
&
IsFrameForSVG
(
aParentFrame
)
&
&
!
aParentFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVGForeignObject
)
)
{
return
nullptr
;
}
if
(
aFlags
&
ITEM_IS_WITHIN_SVG_TEXT
)
{
return
nullptr
;
}
}
if
(
auto
*
data
=
FindElementTagData
(
aElement
aStyle
aParentFrame
aTag
aFlags
)
)
{
return
data
;
}
if
(
ShouldCreateImageFrameForContent
(
aElement
aStyle
)
)
{
static
const
FrameConstructionData
sImgData
=
SIMPLE_FCDATA
(
NS_NewImageFrameForContentProperty
)
;
return
&
sImgData
;
}
const
auto
&
display
=
*
aStyle
.
StyleDisplay
(
)
;
if
(
auto
*
data
=
FindXULDisplayData
(
display
aElement
)
)
{
return
data
;
}
return
FindDisplayData
(
display
aElement
)
;
}
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindElementTagData
(
const
Element
&
aElement
ComputedStyle
&
aStyle
nsIFrame
*
aParentFrame
nsAtom
*
aTag
uint32_t
aFlags
)
{
switch
(
aElement
.
GetNameSpaceID
(
)
)
{
case
kNameSpaceID_XHTML
:
return
FindHTMLData
(
aElement
aParentFrame
aStyle
)
;
case
kNameSpaceID_MathML
:
return
FindMathMLData
(
aElement
aStyle
)
;
case
kNameSpaceID_SVG
:
return
FindSVGData
(
aElement
aParentFrame
aFlags
&
ITEM_IS_WITHIN_SVG_TEXT
aFlags
&
ITEM_ALLOWS_TEXT_PATH_CHILD
aStyle
)
;
case
kNameSpaceID_XUL
:
return
FindXULTagData
(
aElement
aTag
aStyle
)
;
default
:
return
nullptr
;
}
}
nsCSSFrameConstructor
:
:
XBLBindingLoadInfo
:
:
XBLBindingLoadInfo
(
already_AddRefed
<
ComputedStyle
>
&
&
aStyle
mozilla
:
:
UniquePtr
<
PendingBinding
>
aPendingBinding
nsAtom
*
aTag
)
:
mStyle
(
std
:
:
move
(
aStyle
)
)
mPendingBinding
(
std
:
:
move
(
aPendingBinding
)
)
mTag
(
aTag
)
{
MOZ_ASSERT
(
mTag
)
;
MOZ_ASSERT
(
mStyle
)
;
}
nsCSSFrameConstructor
:
:
XBLBindingLoadInfo
:
:
XBLBindingLoadInfo
(
nsIContent
&
aContent
ComputedStyle
&
aStyle
)
:
mStyle
(
&
aStyle
)
mPendingBinding
(
nullptr
)
mTag
(
aContent
.
NodeInfo
(
)
-
>
NameAtom
(
)
)
{
}
nsCSSFrameConstructor
:
:
XBLBindingLoadInfo
:
:
XBLBindingLoadInfo
(
)
=
default
;
nsCSSFrameConstructor
:
:
XBLBindingLoadInfo
nsCSSFrameConstructor
:
:
LoadXBLBindingIfNeeded
(
nsIContent
&
aContent
ComputedStyle
&
aStyle
uint32_t
aFlags
)
{
if
(
!
(
aFlags
&
ITEM_ALLOW_XBL_BASE
)
)
{
return
{
aContent
aStyle
}
;
}
css
:
:
URLValue
*
binding
=
aStyle
.
StyleDisplay
(
)
-
>
mBinding
;
if
(
!
binding
)
{
return
{
aContent
aStyle
}
;
}
nsXBLService
*
xblService
=
nsXBLService
:
:
GetInstance
(
)
;
if
(
!
xblService
)
{
return
{
}
;
}
auto
newPendingBinding
=
MakeUnique
<
PendingBinding
>
(
)
;
bool
resolveStyle
;
nsresult
rv
=
xblService
-
>
LoadBindings
(
aContent
.
AsElement
(
)
binding
-
>
GetURI
(
)
binding
-
>
ExtraData
(
)
-
>
Principal
(
)
getter_AddRefs
(
newPendingBinding
-
>
mBinding
)
&
resolveStyle
)
;
if
(
NS_FAILED
(
rv
)
)
{
if
(
rv
=
=
NS_ERROR_XBL_BLOCKED
)
{
return
{
aContent
aStyle
}
;
}
return
{
}
;
}
RefPtr
<
ComputedStyle
>
style
=
resolveStyle
?
mPresShell
-
>
StyleSet
(
)
-
>
ResolveServoStyle
(
*
aContent
.
AsElement
(
)
)
:
do_AddRef
(
&
aStyle
)
;
nsAtom
*
tag
=
aContent
.
NodeInfo
(
)
-
>
NameAtom
(
)
;
if
(
aContent
.
IsXULElement
(
)
)
{
int32_t
overridenNamespace
;
nsAtom
*
overridenTag
=
mDocument
-
>
BindingManager
(
)
-
>
ResolveTag
(
&
aContent
&
overridenNamespace
)
;
if
(
overridenNamespace
=
=
kNameSpaceID_XUL
)
{
tag
=
overridenTag
;
}
}
return
{
style
.
forget
(
)
std
:
:
move
(
newPendingBinding
)
tag
}
;
}
void
nsCSSFrameConstructor
:
:
AddFrameConstructionItemsInternal
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
nsContainerFrame
*
aParentFrame
bool
aSuppressWhiteSpaceOptimizations
ComputedStyle
*
aComputedStyle
uint32_t
aFlags
FrameConstructionItemList
&
aItems
)
{
MOZ_ASSERT
(
aContent
-
>
IsText
(
)
|
|
aContent
-
>
IsElement
(
)
"
Shouldn
'
t
get
anything
else
here
!
"
)
;
MOZ_ASSERT
(
aContent
-
>
IsInComposedDoc
(
)
)
;
MOZ_ASSERT
(
!
aContent
-
>
GetPrimaryFrame
(
)
|
|
aState
.
mCreatingExtraFrames
|
|
aContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
nsGkAtoms
:
:
area
)
;
PendingBinding
*
pendingBinding
=
nullptr
;
RefPtr
<
ComputedStyle
>
style
;
nsAtom
*
tag
;
{
XBLBindingLoadInfo
xblInfo
=
LoadXBLBindingIfNeeded
(
*
aContent
*
aComputedStyle
aFlags
)
;
if
(
!
xblInfo
.
mTag
)
{
return
;
}
if
(
xblInfo
.
mPendingBinding
&
&
xblInfo
.
mPendingBinding
-
>
mBinding
)
{
pendingBinding
=
xblInfo
.
mPendingBinding
.
get
(
)
;
aState
.
AddPendingBinding
(
std
:
:
move
(
xblInfo
.
mPendingBinding
)
)
;
}
style
=
xblInfo
.
mStyle
.
forget
(
)
;
aComputedStyle
=
style
.
get
(
)
;
tag
=
xblInfo
.
mTag
;
}
const
bool
isGeneratedContent
=
!
!
(
aFlags
&
ITEM_IS_GENERATED_CONTENT
)
;
MOZ_ASSERT
(
!
isGeneratedContent
|
|
style
-
>
GetPseudo
(
)
"
Generated
content
should
be
a
pseudo
-
element
"
)
;
FrameConstructionItem
*
item
=
nullptr
;
auto
cleanupGeneratedContent
=
mozilla
:
:
MakeScopeExit
(
[
&
]
(
)
{
if
(
isGeneratedContent
&
&
!
item
)
{
MOZ_ASSERT
(
!
IsDisplayContents
(
aContent
)
"
This
would
need
to
change
if
we
support
display
:
contents
"
"
in
generated
content
"
)
;
aContent
-
>
UnbindFromTree
(
)
;
}
}
)
;
const
nsStyleDisplay
&
display
=
*
style
-
>
StyleDisplay
(
)
;
if
(
display
.
mDisplay
=
=
StyleDisplay
:
:
None
)
{
return
;
}
if
(
display
.
mDisplay
=
=
StyleDisplay
:
:
Contents
)
{
CreateGeneratedContentItem
(
aState
aParentFrame
*
aContent
-
>
AsElement
(
)
*
style
CSSPseudoElementType
:
:
before
aItems
)
;
FlattenedChildIterator
iter
(
aContent
)
;
InsertionPoint
insertion
(
aParentFrame
aContent
)
;
for
(
nsIContent
*
child
=
iter
.
GetNextChild
(
)
;
child
;
child
=
iter
.
GetNextChild
(
)
)
{
AddFrameConstructionItems
(
aState
child
aSuppressWhiteSpaceOptimizations
insertion
aItems
)
;
}
aItems
.
SetParentHasNoXBLChildren
(
!
iter
.
XBLInvolved
(
)
)
;
CreateGeneratedContentItem
(
aState
aParentFrame
*
aContent
-
>
AsElement
(
)
*
style
CSSPseudoElementType
:
:
after
aItems
)
;
return
;
}
nsIContent
*
parent
=
aParentFrame
?
aParentFrame
-
>
GetContent
(
)
:
nullptr
;
if
(
ShouldSuppressFrameInSelect
(
parent
*
aContent
)
)
{
return
;
}
auto
*
details
=
HTMLDetailsElement
:
:
FromNodeOrNull
(
parent
)
;
if
(
ShouldSuppressFrameInNonOpenDetails
(
details
*
aContent
)
)
{
return
;
}
const
FrameConstructionData
*
data
=
FindDataForContent
(
*
aContent
*
style
aParentFrame
tag
aFlags
)
;
if
(
!
data
|
|
data
-
>
mBits
&
FCDATA_SUPPRESS_FRAME
)
{
return
;
}
bool
isPopup
=
false
;
#
ifdef
MOZ_XUL
if
(
(
data
-
>
mBits
&
FCDATA_IS_POPUP
)
&
&
(
!
aParentFrame
|
|
!
aParentFrame
-
>
IsMenuFrame
(
)
)
)
{
if
(
!
aState
.
mPopupItems
.
containingBlock
&
&
!
aState
.
mHavePendingPopupgroup
)
{
return
;
}
isPopup
=
true
;
}
#
endif
uint32_t
bits
=
data
-
>
mBits
;
if
(
aParentFrame
&
&
aParentFrame
-
>
IsTableColGroupFrame
(
)
&
&
(
!
(
bits
&
FCDATA_IS_TABLE_PART
)
|
|
display
.
mDisplay
!
=
StyleDisplay
:
:
TableColumn
)
)
{
return
;
}
bool
canHavePageBreak
=
(
aFlags
&
ITEM_ALLOW_PAGE_BREAK
)
&
&
aState
.
mPresContext
-
>
IsPaginated
(
)
&
&
!
display
.
IsAbsolutelyPositionedStyle
(
)
&
&
!
(
aParentFrame
&
&
aParentFrame
-
>
IsGridContainerFrame
(
)
)
&
&
!
(
bits
&
FCDATA_IS_TABLE_PART
)
&
&
!
(
bits
&
FCDATA_IS_SVG_TEXT
)
;
if
(
canHavePageBreak
&
&
display
.
BreakBefore
(
)
)
{
AddPageBreakItem
(
aContent
aItems
)
;
}
if
(
details
&
&
details
-
>
Open
(
)
)
{
auto
*
summary
=
HTMLSummaryElement
:
:
FromNode
(
aContent
)
;
if
(
summary
&
&
summary
-
>
IsMainSummary
(
)
)
{
item
=
aItems
.
PrependItem
(
this
data
aContent
pendingBinding
style
.
forget
(
)
aSuppressWhiteSpaceOptimizations
)
;
}
}
if
(
!
item
)
{
item
=
aItems
.
AppendItem
(
this
data
aContent
pendingBinding
style
.
forget
(
)
aSuppressWhiteSpaceOptimizations
)
;
}
item
-
>
mIsText
=
!
aContent
-
>
IsElement
(
)
;
item
-
>
mIsGeneratedContent
=
isGeneratedContent
;
item
-
>
mIsAnonymousContentCreatorContent
=
aFlags
&
ITEM_IS_ANONYMOUSCONTENTCREATOR_CONTENT
;
if
(
isGeneratedContent
)
{
item
-
>
mContent
-
>
AddRef
(
)
;
}
item
-
>
mIsRootPopupgroup
=
aContent
-
>
IsRootOfNativeAnonymousSubtree
(
)
&
&
aContent
-
>
IsXULElement
(
)
&
&
tag
=
=
nsGkAtoms
:
:
popupgroup
;
if
(
item
-
>
mIsRootPopupgroup
)
{
aState
.
mHavePendingPopupgroup
=
true
;
}
item
-
>
mIsPopup
=
isPopup
;
if
(
canHavePageBreak
&
&
display
.
BreakAfter
(
)
)
{
AddPageBreakItem
(
aContent
aItems
)
;
}
if
(
bits
&
FCDATA_IS_INLINE
)
{
BuildInlineChildItems
(
aState
*
item
aFlags
&
ITEM_IS_WITHIN_SVG_TEXT
aFlags
&
ITEM_ALLOWS_TEXT_PATH_CHILD
)
;
item
-
>
mIsBlock
=
false
;
}
else
{
bool
isInline
=
(
(
bits
&
FCDATA_IS_TABLE_PART
)
&
&
(
!
aParentFrame
|
|
aParentFrame
-
>
StyleDisplay
(
)
-
>
mDisplay
=
=
StyleDisplay
:
:
Inline
)
)
|
|
display
.
IsInlineOutsideStyle
(
)
|
|
isPopup
;
item
-
>
mIsAllInline
=
isInline
|
|
(
!
(
bits
&
FCDATA_DISALLOW_OUT_OF_FLOW
)
&
&
aState
.
GetGeometricParent
(
display
nullptr
)
)
;
item
-
>
mIsBlock
=
!
isInline
&
&
!
display
.
IsAbsolutelyPositionedStyle
(
)
&
&
!
display
.
IsFloatingStyle
(
)
&
&
!
(
bits
&
FCDATA_IS_SVG_TEXT
)
;
}
if
(
item
-
>
mIsAllInline
)
{
aItems
.
InlineItemAdded
(
)
;
}
else
if
(
item
-
>
mIsBlock
)
{
aItems
.
BlockItemAdded
(
)
;
}
if
(
(
bits
&
FCDATA_IS_LINE_PARTICIPANT
)
&
&
(
(
bits
&
FCDATA_DISALLOW_OUT_OF_FLOW
)
|
|
!
aState
.
GetGeometricParent
(
display
nullptr
)
)
)
{
item
-
>
mIsLineParticipant
=
true
;
aItems
.
LineParticipantItemAdded
(
)
;
}
}
bool
nsCSSFrameConstructor
:
:
AtLineBoundary
(
FCItemIterator
&
aIter
)
{
if
(
aIter
.
item
(
)
.
mSuppressWhiteSpaceOptimizations
)
{
return
false
;
}
if
(
aIter
.
AtStart
(
)
)
{
if
(
aIter
.
List
(
)
-
>
HasLineBoundaryAtStart
(
)
&
&
!
aIter
.
item
(
)
.
mContent
-
>
GetPreviousSibling
(
)
)
return
true
;
}
else
{
FCItemIterator
prev
=
aIter
;
prev
.
Prev
(
)
;
if
(
prev
.
item
(
)
.
IsLineBoundary
(
)
&
&
!
prev
.
item
(
)
.
mSuppressWhiteSpaceOptimizations
&
&
aIter
.
item
(
)
.
mContent
-
>
GetPreviousSibling
(
)
=
=
prev
.
item
(
)
.
mContent
)
return
true
;
}
FCItemIterator
next
=
aIter
;
next
.
Next
(
)
;
if
(
next
.
IsDone
(
)
)
{
if
(
aIter
.
List
(
)
-
>
HasLineBoundaryAtEnd
(
)
&
&
!
aIter
.
item
(
)
.
mContent
-
>
GetNextSibling
(
)
)
return
true
;
}
else
{
if
(
next
.
item
(
)
.
IsLineBoundary
(
)
&
&
!
next
.
item
(
)
.
mSuppressWhiteSpaceOptimizations
&
&
aIter
.
item
(
)
.
mContent
-
>
GetNextSibling
(
)
=
=
next
.
item
(
)
.
mContent
)
return
true
;
}
return
false
;
}
void
nsCSSFrameConstructor
:
:
ConstructFramesFromItem
(
nsFrameConstructorState
&
aState
FCItemIterator
&
aIter
nsContainerFrame
*
aParentFrame
nsFrameItems
&
aFrameItems
)
{
nsContainerFrame
*
adjParentFrame
=
aParentFrame
;
FrameConstructionItem
&
item
=
aIter
.
item
(
)
;
ComputedStyle
*
computedStyle
=
item
.
mComputedStyle
;
AdjustParentFrame
(
&
adjParentFrame
item
.
mFCData
computedStyle
)
;
if
(
item
.
mIsText
)
{
if
(
AtLineBoundary
(
aIter
)
&
&
!
computedStyle
-
>
StyleText
(
)
-
>
WhiteSpaceOrNewlineIsSignificant
(
)
&
&
aIter
.
List
(
)
-
>
ParentHasNoXBLChildren
(
)
&
&
!
(
aState
.
mAdditionalStateBits
&
NS_FRAME_GENERATED_CONTENT
)
&
&
(
item
.
mFCData
-
>
mBits
&
FCDATA_IS_LINE_PARTICIPANT
)
&
&
!
(
item
.
mFCData
-
>
mBits
&
FCDATA_IS_SVG_TEXT
)
&
&
!
mAlwaysCreateFramesForIgnorableWhitespace
&
&
item
.
IsWhitespace
(
aState
)
)
return
;
ConstructTextFrame
(
item
.
mFCData
aState
item
.
mContent
adjParentFrame
computedStyle
aFrameItems
)
;
return
;
}
AutoRestore
<
nsFrameState
>
savedStateBits
(
aState
.
mAdditionalStateBits
)
;
if
(
item
.
mIsGeneratedContent
)
{
aState
.
mAdditionalStateBits
|
=
NS_FRAME_GENERATED_CONTENT
;
}
ConstructFrameFromItemInternal
(
item
aState
adjParentFrame
aFrameItems
)
;
if
(
item
.
mIsGeneratedContent
)
{
item
.
mContent
-
>
Release
(
)
;
item
.
mIsGeneratedContent
=
false
;
}
}
inline
bool
IsRootBoxFrame
(
nsIFrame
*
aFrame
)
{
return
(
aFrame
-
>
IsRootFrame
(
)
)
;
}
void
nsCSSFrameConstructor
:
:
ReconstructDocElementHierarchy
(
InsertionKind
aInsertionKind
)
{
Element
*
rootElement
=
mDocument
-
>
GetRootElement
(
)
;
if
(
!
rootElement
)
{
return
;
}
RecreateFramesForContent
(
rootElement
aInsertionKind
)
;
}
nsContainerFrame
*
nsCSSFrameConstructor
:
:
GetAbsoluteContainingBlock
(
nsIFrame
*
aFrame
ContainingBlockType
aType
)
{
for
(
nsIFrame
*
frame
=
aFrame
;
frame
;
frame
=
frame
-
>
GetParent
(
)
)
{
if
(
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eMathML
)
)
{
return
nullptr
;
}
if
(
aType
=
=
FIXED_POS
)
{
LayoutFrameType
t
=
frame
-
>
Type
(
)
;
if
(
t
=
=
LayoutFrameType
:
:
Viewport
|
|
t
=
=
LayoutFrameType
:
:
PageContent
)
{
return
static_cast
<
nsContainerFrame
*
>
(
frame
)
;
}
}
if
(
!
frame
-
>
IsAbsPosContainingBlock
(
)
|
|
(
aType
=
=
FIXED_POS
&
&
!
frame
-
>
IsFixedPosContainingBlock
(
)
)
)
{
continue
;
}
nsIFrame
*
absPosCBCandidate
=
frame
;
LayoutFrameType
type
=
absPosCBCandidate
-
>
Type
(
)
;
if
(
type
=
=
LayoutFrameType
:
:
FieldSet
)
{
absPosCBCandidate
=
static_cast
<
nsFieldSetFrame
*
>
(
absPosCBCandidate
)
-
>
GetInner
(
)
;
if
(
!
absPosCBCandidate
)
{
continue
;
}
type
=
absPosCBCandidate
-
>
Type
(
)
;
}
if
(
type
=
=
LayoutFrameType
:
:
Scroll
)
{
nsIScrollableFrame
*
scrollFrame
=
do_QueryFrame
(
absPosCBCandidate
)
;
absPosCBCandidate
=
scrollFrame
-
>
GetScrolledFrame
(
)
;
if
(
!
absPosCBCandidate
)
{
continue
;
}
type
=
absPosCBCandidate
-
>
Type
(
)
;
}
absPosCBCandidate
=
absPosCBCandidate
-
>
FirstContinuation
(
)
;
if
(
!
absPosCBCandidate
-
>
IsAbsoluteContainer
(
)
)
{
continue
;
}
if
(
type
=
=
LayoutFrameType
:
:
Table
)
{
continue
;
}
MOZ_ASSERT
(
(
nsContainerFrame
*
)
do_QueryFrame
(
absPosCBCandidate
)
"
abs
.
pos
.
containing
block
must
be
nsContainerFrame
sub
-
class
"
)
;
return
static_cast
<
nsContainerFrame
*
>
(
absPosCBCandidate
)
;
}
MOZ_ASSERT
(
aType
!
=
FIXED_POS
"
no
ICB
in
this
frame
tree
?
"
)
;
return
mHasRootAbsPosContainingBlock
?
mDocElementContainingBlock
:
nullptr
;
}
nsContainerFrame
*
nsCSSFrameConstructor
:
:
GetFloatContainingBlock
(
nsIFrame
*
aFrame
)
{
for
(
nsIFrame
*
containingBlock
=
aFrame
;
containingBlock
&
&
!
ShouldSuppressFloatingOfDescendants
(
containingBlock
)
;
containingBlock
=
containingBlock
-
>
GetParent
(
)
)
{
if
(
containingBlock
-
>
IsFloatContainingBlock
(
)
)
{
MOZ_ASSERT
(
(
nsContainerFrame
*
)
do_QueryFrame
(
containingBlock
)
"
float
containing
block
must
be
nsContainerFrame
sub
-
class
"
)
;
return
static_cast
<
nsContainerFrame
*
>
(
containingBlock
)
;
}
}
return
nullptr
;
}
static
nsIFrame
*
FindAppendPrevSibling
(
nsIFrame
*
aParentFrame
nsIFrame
*
aNextSibling
)
{
aParentFrame
-
>
DrainSelfOverflowList
(
)
;
if
(
aNextSibling
)
{
MOZ_ASSERT
(
aNextSibling
-
>
GetParent
(
)
-
>
GetContentInsertionFrame
(
)
=
=
aParentFrame
"
Wrong
parent
"
)
;
return
aNextSibling
-
>
GetPrevSibling
(
)
;
}
return
aParentFrame
-
>
GetChildList
(
kPrincipalList
)
.
LastChild
(
)
;
}
static
nsContainerFrame
*
ContinuationToAppendTo
(
nsContainerFrame
*
aParentFrame
)
{
MOZ_ASSERT
(
aParentFrame
)
;
if
(
IsFramePartOfIBSplit
(
aParentFrame
)
)
{
return
static_cast
<
nsContainerFrame
*
>
(
GetLastIBSplitSibling
(
aParentFrame
)
-
>
LastContinuation
(
)
)
;
}
return
nsLayoutUtils
:
:
LastContinuationWithChild
(
aParentFrame
)
;
}
static
nsIFrame
*
GetInsertNextSibling
(
nsIFrame
*
aParentFrame
nsIFrame
*
aPrevSibling
)
{
if
(
aPrevSibling
)
{
return
aPrevSibling
-
>
GetNextSibling
(
)
;
}
return
aParentFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
}
void
nsCSSFrameConstructor
:
:
AppendFramesToParent
(
nsFrameConstructorState
&
aState
nsContainerFrame
*
aParentFrame
nsFrameItems
&
aFrameList
nsIFrame
*
aPrevSibling
bool
aIsRecursiveCall
)
{
MOZ_ASSERT
(
!
IsFramePartOfIBSplit
(
aParentFrame
)
|
|
!
GetIBSplitSibling
(
aParentFrame
)
|
|
!
GetIBSplitSibling
(
aParentFrame
)
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
"
aParentFrame
has
a
ib
-
split
sibling
with
kids
?
"
)
;
MOZ_ASSERT
(
!
aPrevSibling
|
|
aPrevSibling
-
>
GetParent
(
)
=
=
aParentFrame
"
Parent
and
prevsibling
don
'
t
match
"
)
;
MOZ_ASSERT
(
!
aParentFrame
-
>
HasAnyStateBits
(
NS_FRAME_HAS_MULTI_COLUMN_ANCESTOR
)
|
|
!
IsFramePartOfIBSplit
(
aParentFrame
)
"
We
should
have
wiped
aParentFrame
in
WipeContainingBlock
(
)
"
"
if
it
'
s
part
of
an
IB
split
!
"
)
;
nsIFrame
*
nextSibling
=
:
:
GetInsertNextSibling
(
aParentFrame
aPrevSibling
)
;
NS_ASSERTION
(
nextSibling
|
|
!
aParentFrame
-
>
GetNextContinuation
(
)
|
|
!
aParentFrame
-
>
GetNextContinuation
(
)
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
|
|
aIsRecursiveCall
"
aParentFrame
has
later
continuations
with
kids
?
"
)
;
NS_ASSERTION
(
nextSibling
|
|
!
IsFramePartOfIBSplit
(
aParentFrame
)
|
|
(
IsInlineFrame
(
aParentFrame
)
&
&
!
GetIBSplitSibling
(
aParentFrame
)
&
&
!
aParentFrame
-
>
GetNextContinuation
(
)
)
|
|
aIsRecursiveCall
"
aParentFrame
is
not
last
?
"
)
;
if
(
!
nextSibling
&
&
IsFramePartOfIBSplit
(
aParentFrame
)
)
{
if
(
aFrameList
.
NotEmpty
(
)
&
&
aFrameList
.
FirstChild
(
)
-
>
IsBlockOutside
(
)
)
{
nsIFrame
*
firstContinuation
=
aParentFrame
-
>
FirstContinuation
(
)
;
if
(
firstContinuation
-
>
PrincipalChildList
(
)
.
IsEmpty
(
)
)
{
nsFrameList
blockKids
=
aFrameList
.
Split
(
[
]
(
nsIFrame
*
f
)
{
return
!
f
-
>
IsBlockOutside
(
)
;
}
)
;
NS_ASSERTION
(
blockKids
.
NotEmpty
(
)
"
No
blocks
?
"
)
;
nsContainerFrame
*
prevBlock
=
GetIBSplitPrevSibling
(
firstContinuation
)
;
prevBlock
=
static_cast
<
nsContainerFrame
*
>
(
prevBlock
-
>
LastContinuation
(
)
)
;
NS_ASSERTION
(
prevBlock
"
Should
have
previous
block
here
"
)
;
MoveChildrenTo
(
aParentFrame
prevBlock
blockKids
)
;
}
}
nsFrameList
inlineKids
=
aFrameList
.
Split
(
[
]
(
nsIFrame
*
f
)
{
return
f
-
>
IsBlockOutside
(
)
;
}
)
;
if
(
!
inlineKids
.
IsEmpty
(
)
)
{
AppendFrames
(
aParentFrame
kPrincipalList
inlineKids
)
;
}
if
(
!
aFrameList
.
IsEmpty
(
)
)
{
nsFrameItems
ibSiblings
;
CreateIBSiblings
(
aState
aParentFrame
aParentFrame
-
>
IsAbsPosContainingBlock
(
)
aFrameList
ibSiblings
)
;
mPresShell
-
>
FrameNeedsReflow
(
aParentFrame
nsIPresShell
:
:
eTreeChange
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
return
AppendFramesToParent
(
aState
aParentFrame
-
>
GetParent
(
)
ibSiblings
aParentFrame
true
)
;
}
return
;
}
if
(
!
nextSibling
&
&
IsLastContinuationForColumnContent
(
aParentFrame
)
)
{
nsFrameList
initialNonColumnSpanKids
=
aFrameList
.
Split
(
[
]
(
nsIFrame
*
f
)
{
return
f
-
>
IsColumnSpan
(
)
;
}
)
;
AppendFrames
(
aParentFrame
kPrincipalList
initialNonColumnSpanKids
)
;
if
(
aFrameList
.
IsEmpty
(
)
)
{
return
;
}
nsFrameList
columnSpanSiblings
=
CreateColumnSpanSiblings
(
aState
aParentFrame
aFrameList
nullptr
)
;
FinishBuildingColumns
(
aState
GetMultiColumnContainingBlockFor
(
aParentFrame
)
aParentFrame
columnSpanSiblings
)
;
MOZ_ASSERT
(
columnSpanSiblings
.
IsEmpty
(
)
"
The
column
-
span
siblings
should
be
moved
to
the
proper
place
!
"
)
;
return
;
}
InsertFrames
(
aParentFrame
kPrincipalList
aPrevSibling
aFrameList
)
;
}
bool
nsCSSFrameConstructor
:
:
IsValidSibling
(
nsIFrame
*
aSibling
nsIContent
*
aContent
Maybe
<
StyleDisplay
>
&
aDisplay
)
{
nsIFrame
*
parentFrame
=
aSibling
-
>
GetParent
(
)
;
LayoutFrameType
parentType
=
parentFrame
-
>
Type
(
)
;
StyleDisplay
siblingDisplay
=
aSibling
-
>
GetDisplay
(
)
;
if
(
StyleDisplay
:
:
TableColumnGroup
=
=
siblingDisplay
|
|
StyleDisplay
:
:
TableColumn
=
=
siblingDisplay
|
|
StyleDisplay
:
:
TableCaption
=
=
siblingDisplay
|
|
StyleDisplay
:
:
TableHeaderGroup
=
=
siblingDisplay
|
|
StyleDisplay
:
:
TableRowGroup
=
=
siblingDisplay
|
|
StyleDisplay
:
:
TableFooterGroup
=
=
siblingDisplay
|
|
LayoutFrameType
:
:
Menu
=
=
parentType
)
{
if
(
aDisplay
.
isNothing
(
)
)
{
if
(
aContent
-
>
IsComment
(
)
|
|
aContent
-
>
IsProcessingInstruction
(
)
)
{
return
false
;
}
RefPtr
<
ComputedStyle
>
computedStyle
=
ResolveComputedStyle
(
aContent
)
;
const
nsStyleDisplay
*
display
=
computedStyle
-
>
StyleDisplay
(
)
;
aDisplay
.
emplace
(
display
-
>
mDisplay
)
;
}
StyleDisplay
display
=
aDisplay
.
value
(
)
;
if
(
LayoutFrameType
:
:
Menu
=
=
parentType
)
{
return
(
StyleDisplay
:
:
MozPopup
=
=
display
)
=
=
(
StyleDisplay
:
:
MozPopup
=
=
siblingDisplay
)
;
}
if
(
(
siblingDisplay
=
=
StyleDisplay
:
:
TableCaption
)
!
=
(
display
=
=
StyleDisplay
:
:
TableCaption
)
)
{
return
false
;
}
if
(
(
siblingDisplay
=
=
StyleDisplay
:
:
TableColumnGroup
|
|
siblingDisplay
=
=
StyleDisplay
:
:
TableColumn
)
!
=
(
display
=
=
StyleDisplay
:
:
TableColumnGroup
|
|
display
=
=
StyleDisplay
:
:
TableColumn
)
)
{
return
false
;
}
}
if
(
IsFrameForFieldSet
(
parentFrame
)
)
{
if
(
nsContainerFrame
*
cif
=
aSibling
-
>
GetContentInsertionFrame
(
)
)
{
aSibling
=
cif
;
}
LayoutFrameType
sibType
=
aSibling
-
>
Type
(
)
;
bool
legendContent
=
aContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
legend
)
;
if
(
(
legendContent
&
&
(
LayoutFrameType
:
:
Legend
!
=
sibType
)
)
|
|
(
!
legendContent
&
&
(
LayoutFrameType
:
:
Legend
=
=
sibType
)
)
)
return
false
;
}
return
true
;
}
template
<
nsCSSFrameConstructor
:
:
SiblingDirection
aDirection
>
nsIFrame
*
nsCSSFrameConstructor
:
:
FindSiblingInternal
(
FlattenedChildIterator
&
aIter
nsIContent
*
aTargetContent
Maybe
<
StyleDisplay
>
&
aTargetContentDisplay
)
{
auto
adjust
=
[
&
]
(
nsIFrame
*
aPotentialSiblingFrame
)
-
>
nsIFrame
*
{
return
AdjustSiblingFrame
(
aPotentialSiblingFrame
aTargetContent
aTargetContentDisplay
aDirection
)
;
}
;
auto
nextDomSibling
=
[
]
(
FlattenedChildIterator
&
aIter
)
-
>
nsIContent
*
{
return
aDirection
=
=
SiblingDirection
:
:
Forward
?
aIter
.
GetNextChild
(
)
:
aIter
.
GetPreviousChild
(
)
;
}
;
auto
getNearPseudo
=
[
]
(
const
nsIContent
*
aContent
)
-
>
nsIFrame
*
{
return
aDirection
=
=
SiblingDirection
:
:
Forward
?
nsLayoutUtils
:
:
GetBeforeFrame
(
aContent
)
:
nsLayoutUtils
:
:
GetAfterFrame
(
aContent
)
;
}
;
auto
getFarPseudo
=
[
]
(
const
nsIContent
*
aContent
)
-
>
nsIFrame
*
{
return
aDirection
=
=
SiblingDirection
:
:
Forward
?
nsLayoutUtils
:
:
GetAfterFrame
(
aContent
)
:
nsLayoutUtils
:
:
GetBeforeFrame
(
aContent
)
;
}
;
while
(
nsIContent
*
sibling
=
nextDomSibling
(
aIter
)
)
{
if
(
nsIFrame
*
primaryFrame
=
sibling
-
>
GetPrimaryFrame
(
)
)
{
if
(
primaryFrame
-
>
GetContent
(
)
=
=
sibling
)
{
if
(
nsIFrame
*
frame
=
adjust
(
primaryFrame
)
)
{
return
frame
;
}
}
}
if
(
IsDisplayContents
(
sibling
)
)
{
if
(
nsIFrame
*
frame
=
adjust
(
getNearPseudo
(
sibling
)
)
)
{
return
frame
;
}
const
bool
startFromBeginning
=
aDirection
=
=
SiblingDirection
:
:
Forward
;
FlattenedChildIterator
iter
(
sibling
startFromBeginning
)
;
nsIFrame
*
sibling
=
FindSiblingInternal
<
aDirection
>
(
iter
aTargetContent
aTargetContentDisplay
)
;
if
(
sibling
)
{
return
sibling
;
}
}
}
return
adjust
(
getFarPseudo
(
aIter
.
Parent
(
)
)
)
;
}
nsIFrame
*
nsCSSFrameConstructor
:
:
AdjustSiblingFrame
(
nsIFrame
*
aSibling
nsIContent
*
aTargetContent
Maybe
<
StyleDisplay
>
&
aTargetContentDisplay
SiblingDirection
aDirection
)
{
if
(
!
aSibling
)
{
return
nullptr
;
}
if
(
aSibling
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
{
aSibling
=
aSibling
-
>
GetPlaceholderFrame
(
)
;
MOZ_ASSERT
(
aSibling
)
;
}
MOZ_ASSERT
(
!
aSibling
-
>
GetPrevContinuation
(
)
"
How
?
"
)
;
if
(
aDirection
=
=
SiblingDirection
:
:
Backward
)
{
if
(
IsFramePartOfIBSplit
(
aSibling
)
)
{
aSibling
=
GetLastIBSplitSibling
(
aSibling
)
;
}
aSibling
=
aSibling
-
>
GetTailContinuation
(
)
;
}
if
(
!
IsValidSibling
(
aSibling
aTargetContent
aTargetContentDisplay
)
)
{
return
nullptr
;
}
return
aSibling
;
}
nsIFrame
*
nsCSSFrameConstructor
:
:
FindPreviousSibling
(
const
FlattenedChildIterator
&
aIter
Maybe
<
StyleDisplay
>
&
aTargetContentDisplay
)
{
return
FindSibling
<
SiblingDirection
:
:
Backward
>
(
aIter
aTargetContentDisplay
)
;
}
nsIFrame
*
nsCSSFrameConstructor
:
:
FindNextSibling
(
const
FlattenedChildIterator
&
aIter
Maybe
<
StyleDisplay
>
&
aTargetContentDisplay
)
{
return
FindSibling
<
SiblingDirection
:
:
Forward
>
(
aIter
aTargetContentDisplay
)
;
}
template
<
nsCSSFrameConstructor
:
:
SiblingDirection
aDirection
>
nsIFrame
*
nsCSSFrameConstructor
:
:
FindSibling
(
const
FlattenedChildIterator
&
aIter
Maybe
<
StyleDisplay
>
&
aTargetContentDisplay
)
{
nsIContent
*
targetContent
=
aIter
.
Get
(
)
;
FlattenedChildIterator
siblingIter
=
aIter
;
nsIFrame
*
sibling
=
FindSiblingInternal
<
aDirection
>
(
siblingIter
targetContent
aTargetContentDisplay
)
;
if
(
sibling
)
{
return
sibling
;
}
const
nsIContent
*
current
=
aIter
.
Parent
(
)
;
while
(
IsDisplayContents
(
current
)
)
{
const
nsIContent
*
parent
=
current
-
>
GetFlattenedTreeParent
(
)
;
MOZ_ASSERT
(
parent
"
No
display
:
contents
on
the
root
"
)
;
FlattenedChildIterator
iter
(
parent
)
;
iter
.
Seek
(
current
)
;
sibling
=
FindSiblingInternal
<
aDirection
>
(
iter
targetContent
aTargetContentDisplay
)
;
if
(
sibling
)
{
return
sibling
;
}
current
=
parent
;
}
return
nullptr
;
}
static
nsContainerFrame
*
GetAdjustedParentFrame
(
nsContainerFrame
*
aParentFrame
nsIContent
*
aChildContent
)
{
MOZ_ASSERT
(
!
aParentFrame
-
>
IsTableWrapperFrame
(
)
"
Shouldn
'
t
be
happening
!
"
)
;
nsContainerFrame
*
newParent
=
nullptr
;
if
(
aParentFrame
-
>
IsFieldSetFrame
(
)
)
{
if
(
!
aChildContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
legend
)
)
{
newParent
=
GetFieldSetBlockFrame
(
aParentFrame
)
;
}
}
return
newParent
?
newParent
:
aParentFrame
;
}
nsIFrame
*
nsCSSFrameConstructor
:
:
GetInsertionPrevSibling
(
InsertionPoint
*
aInsertion
nsIContent
*
aChild
bool
*
aIsAppend
bool
*
aIsRangeInsertSafe
nsIContent
*
aStartSkipChild
nsIContent
*
aEndSkipChild
)
{
MOZ_ASSERT
(
aInsertion
-
>
mParentFrame
"
Must
have
parent
frame
to
start
with
"
)
;
*
aIsAppend
=
false
;
FlattenedChildIterator
iter
(
aInsertion
-
>
mContainer
)
;
bool
xblCase
=
iter
.
XBLInvolved
(
)
|
|
aInsertion
-
>
mParentFrame
-
>
GetContent
(
)
!
=
aInsertion
-
>
mContainer
;
if
(
xblCase
|
|
!
aChild
-
>
IsRootOfAnonymousSubtree
(
)
)
{
if
(
aStartSkipChild
)
{
iter
.
Seek
(
aStartSkipChild
)
;
}
else
{
iter
.
Seek
(
aChild
)
;
}
}
else
{
iter
.
GetNextChild
(
)
;
MOZ_ASSERT
(
aChild
-
>
GetProperty
(
nsGkAtoms
:
:
restylableAnonymousNode
)
"
Someone
passed
native
anonymous
content
directly
into
frame
"
"
construction
.
Stop
doing
that
!
"
)
;
}
Maybe
<
StyleDisplay
>
childDisplay
;
nsIFrame
*
prevSibling
=
FindPreviousSibling
(
iter
childDisplay
)
;
if
(
prevSibling
)
{
aInsertion
-
>
mParentFrame
=
prevSibling
-
>
GetParent
(
)
-
>
GetContentInsertionFrame
(
)
;
}
else
{
if
(
aEndSkipChild
)
{
iter
.
Seek
(
aEndSkipChild
)
;
iter
.
GetPreviousChild
(
)
;
}
if
(
nsIFrame
*
nextSibling
=
FindNextSibling
(
iter
childDisplay
)
)
{
aInsertion
-
>
mParentFrame
=
nextSibling
-
>
GetParent
(
)
-
>
GetContentInsertionFrame
(
)
;
}
else
{
*
aIsAppend
=
true
;
aInsertion
-
>
mParentFrame
=
:
:
GetAdjustedParentFrame
(
aInsertion
-
>
mParentFrame
aChild
)
;
aInsertion
-
>
mParentFrame
=
:
:
ContinuationToAppendTo
(
aInsertion
-
>
mParentFrame
)
;
prevSibling
=
:
:
FindAppendPrevSibling
(
aInsertion
-
>
mParentFrame
nullptr
)
;
}
}
*
aIsRangeInsertSafe
=
childDisplay
.
isNothing
(
)
;
return
prevSibling
;
}
nsContainerFrame
*
nsCSSFrameConstructor
:
:
GetContentInsertionFrameFor
(
nsIContent
*
aContent
)
{
nsIFrame
*
frame
;
while
(
!
(
frame
=
aContent
-
>
GetPrimaryFrame
(
)
)
)
{
if
(
!
IsDisplayContents
(
aContent
)
)
{
return
nullptr
;
}
aContent
=
aContent
-
>
GetFlattenedTreeParent
(
)
;
if
(
!
aContent
)
{
return
nullptr
;
}
}
if
(
frame
-
>
GetContent
(
)
!
=
aContent
)
{
return
nullptr
;
}
nsContainerFrame
*
insertionFrame
=
frame
-
>
GetContentInsertionFrame
(
)
;
NS_ASSERTION
(
!
insertionFrame
|
|
insertionFrame
=
=
frame
|
|
!
frame
-
>
IsLeaf
(
)
"
The
insertion
frame
is
the
primary
frame
or
the
primary
frame
"
"
isn
'
t
a
leaf
"
)
;
return
insertionFrame
;
}
static
bool
IsSpecialFramesetChild
(
nsIContent
*
aContent
)
{
return
aContent
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
frameset
nsGkAtoms
:
:
frame
)
;
}
static
void
InvalidateCanvasIfNeeded
(
nsIPresShell
*
presShell
nsIContent
*
node
)
;
void
nsCSSFrameConstructor
:
:
AddTextItemIfNeeded
(
nsFrameConstructorState
&
aState
const
InsertionPoint
&
aInsertion
nsIContent
*
aPossibleTextContent
FrameConstructionItemList
&
aItems
)
{
MOZ_ASSERT
(
aPossibleTextContent
"
Must
have
node
"
)
;
if
(
!
aPossibleTextContent
-
>
IsText
(
)
|
|
!
aPossibleTextContent
-
>
HasFlag
(
NS_CREATE_FRAME_IF_NON_WHITESPACE
)
|
|
aPossibleTextContent
-
>
HasFlag
(
NODE_NEEDS_FRAME
)
)
{
return
;
}
MOZ_ASSERT
(
!
aPossibleTextContent
-
>
GetPrimaryFrame
(
)
"
Text
node
has
a
frame
and
NS_CREATE_FRAME_IF_NON_WHITESPACE
"
)
;
AddFrameConstructionItems
(
aState
aPossibleTextContent
false
aInsertion
aItems
)
;
}
void
nsCSSFrameConstructor
:
:
ReframeTextIfNeeded
(
nsIContent
*
aContent
)
{
if
(
!
aContent
-
>
IsText
(
)
|
|
!
aContent
-
>
HasFlag
(
NS_CREATE_FRAME_IF_NON_WHITESPACE
)
|
|
aContent
-
>
HasFlag
(
NODE_NEEDS_FRAME
)
)
{
return
;
}
MOZ_ASSERT
(
!
aContent
-
>
GetPrimaryFrame
(
)
"
Text
node
has
a
frame
and
NS_CREATE_FRAME_IF_NON_WHITESPACE
"
)
;
ContentInserted
(
aContent
nullptr
InsertionKind
:
:
Async
)
;
}
#
ifdef
DEBUG
void
nsCSSFrameConstructor
:
:
CheckBitsForLazyFrameConstruction
(
nsIContent
*
aParent
)
{
bool
noPrimaryFrame
=
false
;
bool
needsFrameBitSet
=
false
;
nsIContent
*
content
=
aParent
;
while
(
content
&
&
!
content
-
>
HasFlag
(
NODE_DESCENDANTS_NEED_FRAMES
)
)
{
if
(
content
-
>
GetPrimaryFrame
(
)
&
&
content
-
>
GetPrimaryFrame
(
)
-
>
IsLeaf
(
)
)
{
noPrimaryFrame
=
needsFrameBitSet
=
false
;
}
if
(
!
noPrimaryFrame
&
&
!
content
-
>
GetPrimaryFrame
(
)
)
{
noPrimaryFrame
=
!
IsDisplayContents
(
content
)
;
}
if
(
!
needsFrameBitSet
&
&
content
-
>
HasFlag
(
NODE_NEEDS_FRAME
)
)
{
needsFrameBitSet
=
true
;
}
content
=
content
-
>
GetFlattenedTreeParent
(
)
;
}
if
(
content
&
&
content
-
>
GetPrimaryFrame
(
)
&
&
content
-
>
GetPrimaryFrame
(
)
-
>
IsLeaf
(
)
)
{
noPrimaryFrame
=
needsFrameBitSet
=
false
;
}
MOZ_ASSERT
(
!
noPrimaryFrame
"
Ancestors
of
nodes
with
frames
to
be
"
"
constructed
lazily
should
have
frames
"
)
;
MOZ_ASSERT
(
!
needsFrameBitSet
"
Ancestors
of
nodes
with
frames
to
be
"
"
constructed
lazily
should
not
have
NEEDS_FRAME
bit
set
"
)
;
}
#
endif
bool
nsCSSFrameConstructor
:
:
MaybeConstructLazily
(
Operation
aOperation
nsIContent
*
aChild
)
{
MOZ_ASSERT
(
aChild
-
>
GetParent
(
)
)
;
if
(
aOperation
=
=
CONTENTINSERT
)
{
MOZ_ASSERT
(
!
aChild
-
>
IsRootOfAnonymousSubtree
(
)
)
;
if
(
aChild
-
>
IsXULElement
(
)
)
{
return
false
;
}
}
else
{
MOZ_ASSERT
(
aOperation
=
=
CONTENTAPPEND
"
operation
should
be
either
insert
or
append
"
)
;
for
(
nsIContent
*
child
=
aChild
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
MOZ_ASSERT
(
!
child
-
>
IsRootOfAnonymousSubtree
(
)
)
;
if
(
child
-
>
IsXULElement
(
)
)
{
return
false
;
}
}
}
Element
*
parent
=
aChild
-
>
GetFlattenedTreeParentElement
(
)
;
if
(
!
parent
)
{
return
true
;
}
if
(
Servo_Element_IsDisplayNone
(
parent
)
)
{
return
true
;
}
if
(
aOperation
=
=
CONTENTINSERT
)
{
NS_ASSERTION
(
!
aChild
-
>
GetPrimaryFrame
(
)
|
|
aChild
-
>
GetPrimaryFrame
(
)
-
>
GetContent
(
)
!
=
aChild
"
setting
NEEDS_FRAME
on
a
node
that
already
has
a
frame
?
"
)
;
aChild
-
>
SetFlags
(
NODE_NEEDS_FRAME
)
;
}
else
{
for
(
nsIContent
*
child
=
aChild
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
NS_ASSERTION
(
!
child
-
>
GetPrimaryFrame
(
)
|
|
child
-
>
GetPrimaryFrame
(
)
-
>
GetContent
(
)
!
=
child
"
setting
NEEDS_FRAME
on
a
node
that
already
has
a
frame
?
"
)
;
child
-
>
SetFlags
(
NODE_NEEDS_FRAME
)
;
}
}
CheckBitsForLazyFrameConstruction
(
parent
)
;
parent
-
>
NoteDescendantsNeedFramesForServo
(
)
;
return
true
;
}
void
nsCSSFrameConstructor
:
:
IssueSingleInsertNofications
(
nsIContent
*
aStartChild
nsIContent
*
aEndChild
InsertionKind
aInsertionKind
)
{
for
(
nsIContent
*
child
=
aStartChild
;
child
!
=
aEndChild
;
child
=
child
-
>
GetNextSibling
(
)
)
{
MOZ_ASSERT
(
!
child
-
>
GetPrimaryFrame
(
)
)
;
ContentRangeInserted
(
child
child
-
>
GetNextSibling
(
)
mTempFrameTreeState
aInsertionKind
)
;
}
}
bool
nsCSSFrameConstructor
:
:
InsertionPoint
:
:
IsMultiple
(
)
const
{
if
(
!
mParentFrame
)
{
return
false
;
}
if
(
mParentFrame
-
>
IsFieldSetFrame
(
)
)
{
return
true
;
}
if
(
mParentFrame
-
>
IsDetailsFrame
(
)
)
{
return
true
;
}
return
false
;
}
nsCSSFrameConstructor
:
:
InsertionPoint
nsCSSFrameConstructor
:
:
GetRangeInsertionPoint
(
nsIContent
*
aStartChild
nsIContent
*
aEndChild
InsertionKind
aInsertionKind
)
{
MOZ_ASSERT
(
aStartChild
)
;
MOZ_ASSERT
(
aStartChild
-
>
GetParent
(
)
)
;
nsIContent
*
parent
=
aStartChild
-
>
GetParent
(
)
;
if
(
parent
-
>
GetShadowRoot
(
)
|
|
parent
-
>
GetXBLBinding
(
)
)
{
IssueSingleInsertNofications
(
aStartChild
aEndChild
aInsertionKind
)
;
return
{
}
;
}
#
ifdef
DEBUG
{
nsIContent
*
expectedParent
=
aStartChild
-
>
GetFlattenedTreeParent
(
)
;
for
(
nsIContent
*
child
=
aStartChild
-
>
GetNextSibling
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
MOZ_ASSERT
(
child
-
>
GetFlattenedTreeParent
(
)
=
=
expectedParent
)
;
}
}
#
endif
InsertionPoint
ip
=
GetInsertionPoint
(
aStartChild
)
;
if
(
ip
.
IsMultiple
(
)
)
{
IssueSingleInsertNofications
(
aStartChild
aEndChild
aInsertionKind
)
;
return
{
}
;
}
return
ip
;
}
bool
nsCSSFrameConstructor
:
:
MaybeRecreateForFrameset
(
nsIFrame
*
aParentFrame
nsIContent
*
aStartChild
nsIContent
*
aEndChild
)
{
if
(
aParentFrame
-
>
IsFrameSetFrame
(
)
)
{
for
(
nsIContent
*
cur
=
aStartChild
;
cur
!
=
aEndChild
;
cur
=
cur
-
>
GetNextSibling
(
)
)
{
if
(
IsSpecialFramesetChild
(
cur
)
)
{
RecreateFramesForContent
(
aParentFrame
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
return
true
;
}
}
}
return
false
;
}
void
nsCSSFrameConstructor
:
:
LazilyStyleNewChildRange
(
nsIContent
*
aStartChild
nsIContent
*
aEndChild
)
{
for
(
nsIContent
*
child
=
aStartChild
;
child
!
=
aEndChild
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
-
>
IsElement
(
)
)
{
child
-
>
AsElement
(
)
-
>
NoteDirtyForServo
(
)
;
}
}
}
#
ifdef
DEBUG
static
bool
IsFlattenedTreeChild
(
nsIContent
*
aParent
nsIContent
*
aChild
)
{
FlattenedChildIterator
iter
(
aParent
)
;
for
(
nsIContent
*
node
=
iter
.
GetNextChild
(
)
;
node
;
node
=
iter
.
GetNextChild
(
)
)
{
if
(
node
=
=
aChild
)
{
return
true
;
}
}
return
false
;
}
#
endif
void
nsCSSFrameConstructor
:
:
StyleNewChildRange
(
nsIContent
*
aStartChild
nsIContent
*
aEndChild
)
{
ServoStyleSet
*
styleSet
=
mPresShell
-
>
StyleSet
(
)
;
for
(
nsIContent
*
child
=
aStartChild
;
child
!
=
aEndChild
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
!
child
-
>
IsElement
(
)
)
{
continue
;
}
Element
*
childElement
=
child
-
>
AsElement
(
)
;
MOZ_ASSERT
(
!
childElement
-
>
HasServoData
(
)
)
;
#
ifdef
DEBUG
{
Element
*
parent
=
childElement
-
>
GetFlattenedTreeParentElement
(
)
;
MOZ_ASSERT
(
parent
)
;
MOZ_ASSERT
(
parent
-
>
HasServoData
(
)
)
;
MOZ_ASSERT
(
IsFlattenedTreeChild
(
parent
child
)
"
GetFlattenedTreeParent
and
ChildIterator
don
'
t
agree
fix
this
!
"
)
;
}
#
endif
styleSet
-
>
StyleNewSubtree
(
childElement
)
;
}
}
nsIFrame
*
nsCSSFrameConstructor
:
:
FindNextSiblingForAppend
(
const
InsertionPoint
&
aInsertion
)
{
auto
SlowPath
=
[
&
]
(
)
-
>
nsIFrame
*
{
FlattenedChildIterator
iter
(
aInsertion
.
mContainer
false
)
;
iter
.
GetPreviousChild
(
)
;
Maybe
<
StyleDisplay
>
unused
;
return
FindNextSibling
(
iter
unused
)
;
}
;
if
(
!
IsDisplayContents
(
aInsertion
.
mContainer
)
&
&
!
nsLayoutUtils
:
:
GetAfterFrame
(
aInsertion
.
mContainer
)
)
{
MOZ_ASSERT
(
!
SlowPath
(
)
)
;
return
nullptr
;
}
return
SlowPath
(
)
;
}
void
nsCSSFrameConstructor
:
:
ContentAppended
(
nsIContent
*
aFirstNewContent
InsertionKind
aInsertionKind
)
{
MOZ_ASSERT
(
aInsertionKind
=
=
InsertionKind
:
:
Sync
|
|
!
RestyleManager
(
)
-
>
IsInStyleRefresh
(
)
)
;
AUTO_PROFILER_LABEL
(
"
nsCSSFrameConstructor
:
:
ContentAppended
"
LAYOUT
)
;
AUTO_LAYOUT_PHASE_ENTRY_POINT
(
mPresShell
-
>
GetPresContext
(
)
FrameC
)
;
#
ifdef
DEBUG
if
(
gNoisyContentUpdates
)
{
printf
(
"
nsCSSFrameConstructor
:
:
ContentAppended
container
=
%
p
"
"
first
-
child
=
%
p
lazy
=
%
d
\
n
"
aFirstNewContent
-
>
GetParent
(
)
aFirstNewContent
aInsertionKind
=
=
InsertionKind
:
:
Async
)
;
if
(
gReallyNoisyContentUpdates
&
&
aFirstNewContent
-
>
GetParent
(
)
)
{
aFirstNewContent
-
>
GetParent
(
)
-
>
List
(
stdout
0
)
;
}
}
for
(
nsIContent
*
child
=
aFirstNewContent
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
MOZ_ASSERT
(
!
child
-
>
GetPrimaryFrame
(
)
|
|
child
-
>
GetPrimaryFrame
(
)
-
>
GetContent
(
)
!
=
child
"
asked
to
construct
a
frame
for
a
node
that
already
has
a
frame
"
)
;
}
#
endif
LAYOUT_PHASE_TEMP_EXIT
(
)
;
InsertionPoint
insertion
=
GetRangeInsertionPoint
(
aFirstNewContent
nullptr
aInsertionKind
)
;
nsContainerFrame
*
&
parentFrame
=
insertion
.
mParentFrame
;
LAYOUT_PHASE_TEMP_REENTER
(
)
;
if
(
!
parentFrame
)
{
if
(
aInsertionKind
=
=
InsertionKind
:
:
Async
)
{
LazilyStyleNewChildRange
(
aFirstNewContent
nullptr
)
;
}
return
;
}
if
(
aInsertionKind
=
=
InsertionKind
:
:
Async
)
{
if
(
MaybeConstructLazily
(
CONTENTAPPEND
aFirstNewContent
)
)
{
LazilyStyleNewChildRange
(
aFirstNewContent
nullptr
)
;
return
;
}
StyleNewChildRange
(
aFirstNewContent
nullptr
)
;
}
LAYOUT_PHASE_TEMP_EXIT
(
)
;
if
(
MaybeRecreateForFrameset
(
parentFrame
aFirstNewContent
nullptr
)
)
{
LAYOUT_PHASE_TEMP_REENTER
(
)
;
return
;
}
LAYOUT_PHASE_TEMP_REENTER
(
)
;
if
(
parentFrame
-
>
IsLeaf
(
)
)
{
ClearLazyBits
(
aFirstNewContent
nullptr
)
;
return
;
}
if
(
parentFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eMathML
)
)
{
LAYOUT_PHASE_TEMP_EXIT
(
)
;
RecreateFramesForContent
(
parentFrame
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
LAYOUT_PHASE_TEMP_REENTER
(
)
;
return
;
}
#
ifdef
DEBUG
if
(
gNoisyContentUpdates
&
&
IsFramePartOfIBSplit
(
parentFrame
)
)
{
printf
(
"
nsCSSFrameConstructor
:
:
ContentAppended
:
parentFrame
=
"
)
;
parentFrame
-
>
ListTag
(
stdout
)
;
printf
(
"
is
ib
-
split
\
n
"
)
;
}
#
endif
MOZ_ASSERT
(
!
parentFrame
-
>
IsFieldSetFrame
(
)
&
&
!
parentFrame
-
>
IsDetailsFrame
(
)
"
Parent
frame
should
not
be
fieldset
or
details
!
"
)
;
nsIFrame
*
nextSibling
=
FindNextSiblingForAppend
(
insertion
)
;
if
(
nextSibling
)
{
parentFrame
=
nextSibling
-
>
GetParent
(
)
-
>
GetContentInsertionFrame
(
)
;
}
else
{
parentFrame
=
:
:
ContinuationToAppendTo
(
parentFrame
)
;
}
nsContainerFrame
*
containingBlock
=
GetFloatContainingBlock
(
parentFrame
)
;
const
bool
haveFirstLetterStyle
=
containingBlock
&
&
HasFirstLetterStyle
(
containingBlock
)
;
const
bool
haveFirstLineStyle
=
containingBlock
&
&
ShouldHaveFirstLineStyle
(
containingBlock
-
>
GetContent
(
)
containingBlock
-
>
Style
(
)
)
;
if
(
haveFirstLetterStyle
)
{
AutoWeakFrame
wf
(
nextSibling
)
;
RemoveLetterFrames
(
mPresShell
containingBlock
)
;
if
(
nextSibling
&
&
!
wf
)
{
nextSibling
=
FindNextSiblingForAppend
(
insertion
)
;
if
(
nextSibling
)
{
parentFrame
=
nextSibling
-
>
GetParent
(
)
-
>
GetContentInsertionFrame
(
)
;
containingBlock
=
GetFloatContainingBlock
(
parentFrame
)
;
}
}
}
nsFrameConstructorState
state
(
mPresShell
GetAbsoluteContainingBlock
(
parentFrame
FIXED_POS
)
GetAbsoluteContainingBlock
(
parentFrame
ABS_POS
)
containingBlock
)
;
LayoutFrameType
frameType
=
parentFrame
-
>
Type
(
)
;
FlattenedChildIterator
iter
(
insertion
.
mContainer
)
;
const
bool
haveNoXBLChildren
=
!
iter
.
XBLInvolved
(
)
|
|
!
iter
.
GetNextChild
(
)
;
AutoFrameConstructionItemList
items
(
this
)
;
if
(
aFirstNewContent
-
>
GetPreviousSibling
(
)
&
&
GetParentType
(
frameType
)
=
=
eTypeBlock
&
&
haveNoXBLChildren
)
{
AddTextItemIfNeeded
(
state
insertion
aFirstNewContent
-
>
GetPreviousSibling
(
)
items
)
;
}
for
(
nsIContent
*
child
=
aFirstNewContent
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
AddFrameConstructionItems
(
state
child
false
insertion
items
)
;
}
nsIFrame
*
prevSibling
=
:
:
FindAppendPrevSibling
(
parentFrame
nextSibling
)
;
LAYOUT_PHASE_TEMP_EXIT
(
)
;
if
(
WipeContainingBlock
(
state
containingBlock
parentFrame
items
true
prevSibling
)
)
{
LAYOUT_PHASE_TEMP_REENTER
(
)
;
return
;
}
LAYOUT_PHASE_TEMP_REENTER
(
)
;
if
(
nsLayoutUtils
:
:
GetAsBlock
(
parentFrame
)
&
&
!
haveFirstLetterStyle
&
&
!
haveFirstLineStyle
&
&
!
IsFramePartOfIBSplit
(
parentFrame
)
)
{
items
.
SetLineBoundaryAtStart
(
!
prevSibling
|
|
!
prevSibling
-
>
IsInlineOutside
(
)
|
|
prevSibling
-
>
IsBrFrame
(
)
)
;
items
.
SetLineBoundaryAtEnd
(
!
nextSibling
|
|
!
nextSibling
-
>
IsInlineOutside
(
)
)
;
}
items
.
SetParentHasNoXBLChildren
(
haveNoXBLChildren
)
;
nsFrameItems
frameItems
;
ConstructFramesFromItemList
(
state
items
parentFrame
ParentIsWrapperAnonBox
(
parentFrame
)
frameItems
)
;
for
(
nsIContent
*
child
=
aFirstNewContent
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
InvalidateCanvasIfNeeded
(
mPresShell
child
)
;
}
nsFrameItems
captionItems
;
if
(
LayoutFrameType
:
:
Table
=
=
frameType
)
{
PullOutCaptionFrames
(
frameItems
captionItems
)
;
}
if
(
haveFirstLineStyle
&
&
parentFrame
=
=
containingBlock
)
{
AppendFirstLineFrames
(
state
containingBlock
-
>
GetContent
(
)
containingBlock
frameItems
)
;
}
else
if
(
parentFrame
-
>
Style
(
)
-
>
HasPseudoElementData
(
)
)
{
CheckForFirstLineInsertion
(
parentFrame
frameItems
)
;
CheckForFirstLineInsertion
(
parentFrame
captionItems
)
;
}
if
(
captionItems
.
NotEmpty
(
)
)
{
NS_ASSERTION
(
LayoutFrameType
:
:
Table
=
=
frameType
"
how
did
that
happen
?
"
)
;
nsContainerFrame
*
outerTable
=
parentFrame
-
>
GetParent
(
)
;
AppendFrames
(
outerTable
nsIFrame
:
:
kCaptionList
captionItems
)
;
}
LAYOUT_PHASE_TEMP_EXIT
(
)
;
if
(
StaticPrefs
:
:
layout_css_column_span_enabled
(
)
&
&
MaybeRecreateForColumnSpan
(
state
parentFrame
frameItems
prevSibling
)
)
{
LAYOUT_PHASE_TEMP_REENTER
(
)
;
return
;
}
LAYOUT_PHASE_TEMP_REENTER
(
)
;
if
(
frameItems
.
NotEmpty
(
)
)
{
AppendFramesToParent
(
state
parentFrame
frameItems
prevSibling
)
;
}
if
(
haveFirstLetterStyle
)
{
RecoverLetterFrames
(
containingBlock
)
;
}
#
ifdef
DEBUG
if
(
gReallyNoisyContentUpdates
)
{
printf
(
"
nsCSSFrameConstructor
:
:
ContentAppended
:
resulting
frame
model
:
\
n
"
)
;
parentFrame
-
>
List
(
stdout
)
;
}
#
endif
#
ifdef
ACCESSIBILITY
if
(
nsAccessibilityService
*
accService
=
nsIPresShell
:
:
AccService
(
)
)
{
accService
-
>
ContentRangeInserted
(
mPresShell
aFirstNewContent
nullptr
)
;
}
#
endif
}
void
nsCSSFrameConstructor
:
:
ContentInserted
(
nsIContent
*
aChild
nsILayoutHistoryState
*
aFrameState
InsertionKind
aInsertionKind
)
{
ContentRangeInserted
(
aChild
aChild
-
>
GetNextSibling
(
)
aFrameState
aInsertionKind
)
;
}
void
nsCSSFrameConstructor
:
:
ContentRangeInserted
(
nsIContent
*
aStartChild
nsIContent
*
aEndChild
nsILayoutHistoryState
*
aFrameState
InsertionKind
aInsertionKind
)
{
MOZ_ASSERT
(
aInsertionKind
=
=
InsertionKind
:
:
Sync
|
|
!
RestyleManager
(
)
-
>
IsInStyleRefresh
(
)
)
;
AUTO_PROFILER_LABEL
(
"
nsCSSFrameConstructor
:
:
ContentRangeInserted
"
LAYOUT
)
;
AUTO_LAYOUT_PHASE_ENTRY_POINT
(
mPresShell
-
>
GetPresContext
(
)
FrameC
)
;
MOZ_ASSERT
(
aStartChild
"
must
always
pass
a
child
"
)
;
#
ifdef
DEBUG
if
(
gNoisyContentUpdates
)
{
printf
(
"
nsCSSFrameConstructor
:
:
ContentRangeInserted
container
=
%
p
"
"
start
-
child
=
%
p
end
-
child
=
%
p
lazy
=
%
d
\
n
"
aStartChild
-
>
GetParent
(
)
aStartChild
aEndChild
aInsertionKind
=
=
InsertionKind
:
:
Async
)
;
if
(
gReallyNoisyContentUpdates
)
{
if
(
aStartChild
-
>
GetParent
(
)
)
{
aStartChild
-
>
GetParent
(
)
-
>
List
(
stdout
0
)
;
}
else
{
aStartChild
-
>
List
(
stdout
0
)
;
}
}
}
for
(
nsIContent
*
child
=
aStartChild
;
child
!
=
aEndChild
;
child
=
child
-
>
GetNextSibling
(
)
)
{
NS_ASSERTION
(
!
child
-
>
GetPrimaryFrame
(
)
|
|
child
-
>
GetPrimaryFrame
(
)
-
>
GetContent
(
)
!
=
child
"
asked
to
construct
a
frame
for
a
node
that
already
has
a
frame
"
)
;
}
#
endif
bool
isSingleInsert
=
(
aStartChild
-
>
GetNextSibling
(
)
=
=
aEndChild
)
;
NS_ASSERTION
(
isSingleInsert
|
|
aInsertionKind
=
=
InsertionKind
:
:
Sync
"
range
insert
shouldn
'
t
be
lazy
"
)
;
NS_ASSERTION
(
isSingleInsert
|
|
aEndChild
"
range
should
not
include
all
nodes
after
aStartChild
"
)
;
if
(
!
aStartChild
-
>
GetParent
(
)
)
{
MOZ_ASSERT
(
isSingleInsert
"
root
node
insertion
should
be
a
single
insertion
"
)
;
Element
*
docElement
=
mDocument
-
>
GetRootElement
(
)
;
if
(
aStartChild
!
=
docElement
)
{
return
;
}
MOZ_ASSERT
(
!
mRootElementFrame
"
root
element
frame
already
created
"
)
;
if
(
ConstructDocElementFrame
(
docElement
aFrameState
)
)
{
InvalidateCanvasIfNeeded
(
mPresShell
aStartChild
)
;
#
ifdef
DEBUG
if
(
gReallyNoisyContentUpdates
)
{
printf
(
"
nsCSSFrameConstructor
:
:
ContentRangeInserted
:
resulting
frame
"
"
model
:
\
n
"
)
;
mRootElementFrame
-
>
List
(
stdout
)
;
}
#
endif
}
if
(
aFrameState
)
{
if
(
nsIFrame
*
rootScrollFrame
=
mPresShell
-
>
GetRootScrollFrame
(
)
)
{
RestoreFrameStateFor
(
rootScrollFrame
aFrameState
)
;
}
}
#
ifdef
ACCESSIBILITY
if
(
nsAccessibilityService
*
accService
=
nsIPresShell
:
:
AccService
(
)
)
{
accService
-
>
ContentRangeInserted
(
mPresShell
aStartChild
aEndChild
)
;
}
#
endif
return
;
}
InsertionPoint
insertion
;
if
(
isSingleInsert
)
{
insertion
=
GetInsertionPoint
(
aStartChild
)
;
}
else
{
LAYOUT_PHASE_TEMP_EXIT
(
)
;
insertion
=
GetRangeInsertionPoint
(
aStartChild
aEndChild
aInsertionKind
)
;
LAYOUT_PHASE_TEMP_REENTER
(
)
;
}
if
(
!
insertion
.
mParentFrame
)
{
if
(
aInsertionKind
=
=
InsertionKind
:
:
Async
)
{
LazilyStyleNewChildRange
(
aStartChild
aEndChild
)
;
}
return
;
}
if
(
aInsertionKind
=
=
InsertionKind
:
:
Async
)
{
if
(
MaybeConstructLazily
(
CONTENTINSERT
aStartChild
)
)
{
LazilyStyleNewChildRange
(
aStartChild
aEndChild
)
;
return
;
}
StyleNewChildRange
(
aStartChild
aEndChild
)
;
}
bool
isAppend
isRangeInsertSafe
;
nsIFrame
*
prevSibling
=
GetInsertionPrevSibling
(
&
insertion
aStartChild
&
isAppend
&
isRangeInsertSafe
)
;
if
(
!
isSingleInsert
&
&
!
isRangeInsertSafe
)
{
LAYOUT_PHASE_TEMP_EXIT
(
)
;
IssueSingleInsertNofications
(
aStartChild
aEndChild
InsertionKind
:
:
Sync
)
;
LAYOUT_PHASE_TEMP_REENTER
(
)
;
return
;
}
LayoutFrameType
frameType
=
insertion
.
mParentFrame
-
>
Type
(
)
;
LAYOUT_PHASE_TEMP_EXIT
(
)
;
if
(
MaybeRecreateForFrameset
(
insertion
.
mParentFrame
aStartChild
aEndChild
)
)
{
LAYOUT_PHASE_TEMP_REENTER
(
)
;
return
;
}
LAYOUT_PHASE_TEMP_REENTER
(
)
;
NS_ASSERTION
(
isSingleInsert
|
|
frameType
!
=
LayoutFrameType
:
:
FieldSet
"
Unexpected
parent
"
)
;
if
(
IsFrameForFieldSet
(
insertion
.
mParentFrame
)
&
&
aStartChild
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
nsGkAtoms
:
:
legend
)
{
LAYOUT_PHASE_TEMP_EXIT
(
)
;
RecreateFramesForContent
(
insertion
.
mParentFrame
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
LAYOUT_PHASE_TEMP_REENTER
(
)
;
return
;
}
MOZ_ASSERT
(
isSingleInsert
|
|
frameType
!
=
LayoutFrameType
:
:
Details
)
;
if
(
frameType
=
=
LayoutFrameType
:
:
Details
)
{
LAYOUT_PHASE_TEMP_EXIT
(
)
;
RecreateFramesForContent
(
insertion
.
mParentFrame
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
LAYOUT_PHASE_TEMP_REENTER
(
)
;
return
;
}
if
(
insertion
.
mParentFrame
-
>
IsLeaf
(
)
)
{
ClearLazyBits
(
aStartChild
aEndChild
)
;
return
;
}
if
(
insertion
.
mParentFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eMathML
)
)
{
LAYOUT_PHASE_TEMP_EXIT
(
)
;
RecreateFramesForContent
(
insertion
.
mParentFrame
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
LAYOUT_PHASE_TEMP_REENTER
(
)
;
return
;
}
nsFrameConstructorState
state
(
mPresShell
GetAbsoluteContainingBlock
(
insertion
.
mParentFrame
FIXED_POS
)
GetAbsoluteContainingBlock
(
insertion
.
mParentFrame
ABS_POS
)
GetFloatContainingBlock
(
insertion
.
mParentFrame
)
do_AddRef
(
aFrameState
)
)
;
nsContainerFrame
*
containingBlock
=
state
.
mFloatedItems
.
containingBlock
;
bool
haveFirstLetterStyle
=
false
;
bool
haveFirstLineStyle
=
false
;
StyleDisplay
parentDisplay
=
insertion
.
mParentFrame
-
>
GetDisplay
(
)
;
if
(
(
StyleDisplay
:
:
Block
=
=
parentDisplay
)
|
|
(
StyleDisplay
:
:
ListItem
=
=
parentDisplay
)
|
|
(
StyleDisplay
:
:
Inline
=
=
parentDisplay
)
|
|
(
StyleDisplay
:
:
InlineBlock
=
=
parentDisplay
)
)
{
if
(
containingBlock
)
{
haveFirstLetterStyle
=
HasFirstLetterStyle
(
containingBlock
)
;
haveFirstLineStyle
=
ShouldHaveFirstLineStyle
(
containingBlock
-
>
GetContent
(
)
containingBlock
-
>
Style
(
)
)
;
}
if
(
haveFirstLetterStyle
)
{
if
(
insertion
.
mParentFrame
-
>
IsLetterFrame
(
)
)
{
if
(
insertion
.
mParentFrame
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
{
nsPlaceholderFrame
*
placeholderFrame
=
insertion
.
mParentFrame
-
>
GetPlaceholderFrame
(
)
;
NS_ASSERTION
(
placeholderFrame
"
No
placeholder
for
out
-
of
-
flow
?
"
)
;
insertion
.
mParentFrame
=
placeholderFrame
-
>
GetParent
(
)
;
}
else
{
insertion
.
mParentFrame
=
insertion
.
mParentFrame
-
>
GetParent
(
)
;
}
}
RemoveLetterFrames
(
mPresShell
state
.
mFloatedItems
.
containingBlock
)
;
prevSibling
=
GetInsertionPrevSibling
(
&
insertion
aStartChild
&
isAppend
&
isRangeInsertSafe
)
;
if
(
!
isSingleInsert
&
&
!
isRangeInsertSafe
)
{
RecoverLetterFrames
(
state
.
mFloatedItems
.
containingBlock
)
;
LAYOUT_PHASE_TEMP_EXIT
(
)
;
IssueSingleInsertNofications
(
aStartChild
aEndChild
InsertionKind
:
:
Sync
)
;
LAYOUT_PHASE_TEMP_REENTER
(
)
;
return
;
}
frameType
=
insertion
.
mParentFrame
-
>
Type
(
)
;
}
}
AutoFrameConstructionItemList
items
(
this
)
;
ParentType
parentType
=
GetParentType
(
frameType
)
;
FlattenedChildIterator
iter
(
insertion
.
mContainer
)
;
bool
haveNoXBLChildren
=
!
iter
.
XBLInvolved
(
)
|
|
!
iter
.
GetNextChild
(
)
;
if
(
aStartChild
-
>
GetPreviousSibling
(
)
&
&
parentType
=
=
eTypeBlock
&
&
haveNoXBLChildren
)
{
AddTextItemIfNeeded
(
state
insertion
aStartChild
-
>
GetPreviousSibling
(
)
items
)
;
}
if
(
isSingleInsert
)
{
AddFrameConstructionItems
(
state
aStartChild
aStartChild
-
>
IsRootOfAnonymousSubtree
(
)
insertion
items
)
;
}
else
{
for
(
nsIContent
*
child
=
aStartChild
;
child
!
=
aEndChild
;
child
=
child
-
>
GetNextSibling
(
)
)
{
AddFrameConstructionItems
(
state
child
false
insertion
items
)
;
}
}
if
(
aEndChild
&
&
parentType
=
=
eTypeBlock
&
&
haveNoXBLChildren
)
{
AddTextItemIfNeeded
(
state
insertion
aEndChild
items
)
;
}
LAYOUT_PHASE_TEMP_EXIT
(
)
;
if
(
WipeContainingBlock
(
state
containingBlock
insertion
.
mParentFrame
items
isAppend
prevSibling
)
)
{
LAYOUT_PHASE_TEMP_REENTER
(
)
;
return
;
}
LAYOUT_PHASE_TEMP_REENTER
(
)
;
nsFrameItems
frameItems
captionItems
;
ConstructFramesFromItemList
(
state
items
insertion
.
mParentFrame
ParentIsWrapperAnonBox
(
insertion
.
mParentFrame
)
frameItems
)
;
if
(
frameItems
.
NotEmpty
(
)
)
{
for
(
nsIContent
*
child
=
aStartChild
;
child
!
=
aEndChild
;
child
=
child
-
>
GetNextSibling
(
)
)
{
InvalidateCanvasIfNeeded
(
mPresShell
child
)
;
}
if
(
LayoutFrameType
:
:
Table
=
=
frameType
|
|
LayoutFrameType
:
:
TableWrapper
=
=
frameType
)
{
PullOutCaptionFrames
(
frameItems
captionItems
)
;
}
}
if
(
haveFirstLineStyle
&
&
insertion
.
mParentFrame
=
=
containingBlock
&
&
isAppend
)
{
AppendFirstLineFrames
(
state
containingBlock
-
>
GetContent
(
)
containingBlock
frameItems
)
;
}
else
if
(
insertion
.
mParentFrame
-
>
Style
(
)
-
>
HasPseudoElementData
(
)
)
{
CheckForFirstLineInsertion
(
insertion
.
mParentFrame
frameItems
)
;
CheckForFirstLineInsertion
(
insertion
.
mParentFrame
captionItems
)
;
}
if
(
captionItems
.
NotEmpty
(
)
)
{
NS_ASSERTION
(
LayoutFrameType
:
:
Table
=
=
frameType
|
|
LayoutFrameType
:
:
TableWrapper
=
=
frameType
"
parent
for
caption
is
not
table
?
"
)
;
bool
captionIsAppend
;
nsIFrame
*
captionPrevSibling
=
nullptr
;
bool
ignored
;
InsertionPoint
captionInsertion
(
insertion
.
mParentFrame
insertion
.
mContainer
)
;
if
(
isSingleInsert
)
{
captionPrevSibling
=
GetInsertionPrevSibling
(
&
captionInsertion
aStartChild
&
captionIsAppend
&
ignored
)
;
}
else
{
nsIContent
*
firstCaption
=
captionItems
.
FirstChild
(
)
-
>
GetContent
(
)
;
captionPrevSibling
=
GetInsertionPrevSibling
(
&
captionInsertion
firstCaption
&
captionIsAppend
&
ignored
aStartChild
aEndChild
)
;
}
nsContainerFrame
*
outerTable
=
nullptr
;
if
(
GetCaptionAdjustedParent
(
captionInsertion
.
mParentFrame
captionItems
.
FirstChild
(
)
&
outerTable
)
)
{
NS_ASSERTION
(
outerTable
-
>
IsTableWrapperFrame
(
)
"
Pseudo
frame
construction
failure
;
"
"
a
caption
can
be
only
a
child
of
a
table
wrapper
frame
"
)
;
if
(
captionPrevSibling
&
&
captionPrevSibling
-
>
GetParent
(
)
!
=
outerTable
)
{
captionPrevSibling
=
nullptr
;
}
if
(
captionIsAppend
)
{
AppendFrames
(
outerTable
nsIFrame
:
:
kCaptionList
captionItems
)
;
}
else
{
InsertFrames
(
outerTable
nsIFrame
:
:
kCaptionList
captionPrevSibling
captionItems
)
;
}
}
}
LAYOUT_PHASE_TEMP_EXIT
(
)
;
if
(
StaticPrefs
:
:
layout_css_column_span_enabled
(
)
&
&
MaybeRecreateForColumnSpan
(
state
insertion
.
mParentFrame
frameItems
prevSibling
)
)
{
LAYOUT_PHASE_TEMP_REENTER
(
)
;
return
;
}
LAYOUT_PHASE_TEMP_REENTER
(
)
;
if
(
frameItems
.
NotEmpty
(
)
)
{
if
(
isAppend
)
{
AppendFramesToParent
(
state
insertion
.
mParentFrame
frameItems
prevSibling
)
;
}
else
{
InsertFrames
(
insertion
.
mParentFrame
kPrincipalList
prevSibling
frameItems
)
;
}
}
if
(
haveFirstLetterStyle
)
{
RecoverLetterFrames
(
state
.
mFloatedItems
.
containingBlock
)
;
}
#
ifdef
DEBUG
if
(
gReallyNoisyContentUpdates
&
&
insertion
.
mParentFrame
)
{
printf
(
"
nsCSSFrameConstructor
:
:
ContentRangeInserted
:
resulting
frame
"
"
model
:
\
n
"
)
;
insertion
.
mParentFrame
-
>
List
(
stdout
)
;
}
#
endif
#
ifdef
ACCESSIBILITY
if
(
nsAccessibilityService
*
accService
=
nsIPresShell
:
:
AccService
(
)
)
{
accService
-
>
ContentRangeInserted
(
mPresShell
aStartChild
aEndChild
)
;
}
#
endif
}
bool
nsCSSFrameConstructor
:
:
ContentRemoved
(
nsIContent
*
aChild
nsIContent
*
aOldNextSibling
RemoveFlags
aFlags
)
{
MOZ_ASSERT
(
aChild
)
;
MOZ_ASSERT
(
!
aChild
-
>
IsRootOfAnonymousSubtree
(
)
|
|
!
aOldNextSibling
"
Anonymous
roots
don
'
t
have
siblings
"
)
;
AUTO_PROFILER_LABEL
(
"
nsCSSFrameConstructor
:
:
ContentRemoved
"
LAYOUT
)
;
AUTO_LAYOUT_PHASE_ENTRY_POINT
(
mPresShell
-
>
GetPresContext
(
)
FrameC
)
;
nsPresContext
*
presContext
=
mPresShell
-
>
GetPresContext
(
)
;
MOZ_ASSERT
(
presContext
"
Our
presShell
should
have
a
valid
presContext
"
)
;
if
(
aChild
=
=
presContext
-
>
GetViewportScrollStylesOverrideElement
(
)
|
|
(
aChild
-
>
IsElement
(
)
&
&
!
aChild
-
>
GetParent
(
)
)
)
{
Element
*
newOverrideElement
=
presContext
-
>
UpdateViewportScrollStylesOverride
(
)
;
if
(
aChild
-
>
GetParent
(
)
&
&
newOverrideElement
&
&
newOverrideElement
-
>
GetParent
(
)
&
&
newOverrideElement
!
=
aChild
)
{
LAYOUT_PHASE_TEMP_EXIT
(
)
;
RecreateFramesForContent
(
newOverrideElement
InsertionKind
:
:
Async
)
;
LAYOUT_PHASE_TEMP_REENTER
(
)
;
}
}
#
ifdef
DEBUG
if
(
gNoisyContentUpdates
)
{
printf
(
"
nsCSSFrameConstructor
:
:
ContentRemoved
container
=
%
p
child
=
%
p
"
"
old
-
next
-
sibling
=
%
p
\
n
"
aChild
-
>
GetParent
(
)
aChild
aOldNextSibling
)
;
if
(
gReallyNoisyContentUpdates
)
{
aChild
-
>
GetParent
(
)
-
>
List
(
stdout
0
)
;
}
}
#
endif
nsIFrame
*
childFrame
=
aChild
-
>
GetPrimaryFrame
(
)
;
if
(
!
childFrame
|
|
childFrame
-
>
GetContent
(
)
!
=
aChild
)
{
childFrame
=
nullptr
;
}
bool
isRoot
=
false
;
if
(
!
aChild
-
>
GetParent
(
)
)
{
if
(
nsIFrame
*
viewport
=
GetRootFrame
(
)
)
{
nsIFrame
*
firstChild
=
viewport
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
firstChild
&
&
firstChild
-
>
GetContent
(
)
=
=
aChild
)
{
isRoot
=
true
;
childFrame
=
firstChild
;
NS_ASSERTION
(
!
childFrame
-
>
GetNextSibling
(
)
"
How
did
that
happen
?
"
)
;
}
}
}
auto
CouldHaveBeenDisplayContents
=
[
aFlags
]
(
nsIContent
*
aContent
)
-
>
bool
{
return
aFlags
=
=
REMOVE_FOR_RECONSTRUCTION
|
|
IsDisplayContents
(
aContent
)
;
}
;
if
(
!
childFrame
&
&
CouldHaveBeenDisplayContents
(
aChild
)
)
{
StyleChildrenIterator
iter
(
aChild
)
;
for
(
nsIContent
*
c
=
iter
.
GetNextChild
(
)
;
c
;
c
=
iter
.
GetNextChild
(
)
)
{
if
(
c
-
>
GetPrimaryFrame
(
)
|
|
CouldHaveBeenDisplayContents
(
c
)
)
{
LAYOUT_PHASE_TEMP_EXIT
(
)
;
bool
didReconstruct
=
ContentRemoved
(
c
nullptr
aFlags
)
;
LAYOUT_PHASE_TEMP_REENTER
(
)
;
if
(
didReconstruct
)
{
return
true
;
}
}
}
return
false
;
}
if
(
childFrame
)
{
if
(
aFlags
=
=
REMOVE_FOR_RECONSTRUCTION
)
{
CaptureStateForFramesOf
(
aChild
mTempFrameTreeState
)
;
}
InvalidateCanvasIfNeeded
(
mPresShell
aChild
)
;
LAYOUT_PHASE_TEMP_EXIT
(
)
;
if
(
MaybeRecreateContainerForFrameRemoval
(
childFrame
)
)
{
LAYOUT_PHASE_TEMP_REENTER
(
)
;
return
true
;
}
LAYOUT_PHASE_TEMP_REENTER
(
)
;
nsIFrame
*
parentFrame
=
childFrame
-
>
GetParent
(
)
;
LayoutFrameType
parentType
=
parentFrame
-
>
Type
(
)
;
if
(
parentType
=
=
LayoutFrameType
:
:
FrameSet
&
&
IsSpecialFramesetChild
(
aChild
)
)
{
LAYOUT_PHASE_TEMP_EXIT
(
)
;
RecreateFramesForContent
(
parentFrame
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
LAYOUT_PHASE_TEMP_REENTER
(
)
;
return
true
;
}
nsIFrame
*
possibleMathMLAncestor
=
parentType
=
=
LayoutFrameType
:
:
Block
?
parentFrame
-
>
GetParent
(
)
:
parentFrame
;
if
(
possibleMathMLAncestor
-
>
IsFrameOfType
(
nsIFrame
:
:
eMathML
)
)
{
LAYOUT_PHASE_TEMP_EXIT
(
)
;
RecreateFramesForContent
(
parentFrame
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
LAYOUT_PHASE_TEMP_REENTER
(
)
;
return
true
;
}
nsIFrame
*
grandparentFrame
=
parentFrame
-
>
GetParent
(
)
;
if
(
grandparentFrame
&
&
grandparentFrame
-
>
IsXULBoxFrame
(
)
&
&
(
grandparentFrame
-
>
GetStateBits
(
)
&
NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK
)
&
&
aChild
=
=
AnyKidsNeedBlockParent
(
parentFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
)
&
&
!
AnyKidsNeedBlockParent
(
childFrame
-
>
GetNextSibling
(
)
)
)
{
LAYOUT_PHASE_TEMP_EXIT
(
)
;
RecreateFramesForContent
(
grandparentFrame
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
LAYOUT_PHASE_TEMP_REENTER
(
)
;
return
true
;
}
#
ifdef
ACCESSIBILITY
if
(
nsAccessibilityService
*
accService
=
nsIPresShell
:
:
AccService
(
)
)
{
accService
-
>
ContentRemoved
(
mPresShell
aChild
)
;
}
#
endif
nsIFrame
*
inflowChild
=
childFrame
;
if
(
childFrame
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
{
inflowChild
=
childFrame
-
>
GetPlaceholderFrame
(
)
;
NS_ASSERTION
(
inflowChild
"
No
placeholder
for
out
-
of
-
flow
?
"
)
;
}
nsContainerFrame
*
containingBlock
=
GetFloatContainingBlock
(
inflowChild
-
>
GetParent
(
)
)
;
bool
haveFLS
=
containingBlock
&
&
HasFirstLetterStyle
(
containingBlock
)
;
if
(
haveFLS
)
{
#
ifdef
NOISY_FIRST_LETTER
printf
(
"
ContentRemoved
:
containingBlock
=
"
)
;
containingBlock
-
>
ListTag
(
stdout
)
;
printf
(
"
parentFrame
=
"
)
;
parentFrame
-
>
ListTag
(
stdout
)
;
printf
(
"
childFrame
=
"
)
;
childFrame
-
>
ListTag
(
stdout
)
;
printf
(
"
\
n
"
)
;
#
endif
RemoveLetterFrames
(
mPresShell
containingBlock
)
;
childFrame
=
aChild
-
>
GetPrimaryFrame
(
)
;
if
(
!
childFrame
|
|
childFrame
-
>
GetContent
(
)
!
=
aChild
)
{
return
false
;
}
parentFrame
=
childFrame
-
>
GetParent
(
)
;
parentType
=
parentFrame
-
>
Type
(
)
;
#
ifdef
NOISY_FIRST_LETTER
printf
(
"
=
=
>
revised
parentFrame
=
"
)
;
parentFrame
-
>
ListTag
(
stdout
)
;
printf
(
"
childFrame
=
"
)
;
childFrame
-
>
ListTag
(
stdout
)
;
printf
(
"
\
n
"
)
;
#
endif
}
#
ifdef
DEBUG
if
(
gReallyNoisyContentUpdates
)
{
printf
(
"
nsCSSFrameConstructor
:
:
ContentRemoved
:
childFrame
=
"
)
;
childFrame
-
>
ListTag
(
stdout
)
;
putchar
(
'
\
n
'
)
;
parentFrame
-
>
List
(
stdout
)
;
}
#
endif
if
(
childFrame
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
{
childFrame
=
childFrame
-
>
GetPlaceholderFrame
(
)
;
NS_ASSERTION
(
childFrame
"
Missing
placeholder
frame
for
out
of
flow
.
"
)
;
parentFrame
=
childFrame
-
>
GetParent
(
)
;
}
RemoveFrame
(
nsLayoutUtils
:
:
GetChildListNameFor
(
childFrame
)
childFrame
)
;
if
(
isRoot
)
{
mRootElementFrame
=
nullptr
;
mRootElementStyleFrame
=
nullptr
;
mDocElementContainingBlock
=
nullptr
;
mPageSequenceFrame
=
nullptr
;
mHasRootAbsPosContainingBlock
=
false
;
}
if
(
haveFLS
&
&
mRootElementFrame
)
{
RecoverLetterFrames
(
containingBlock
)
;
}
if
(
aOldNextSibling
&
&
aFlags
=
=
REMOVE_CONTENT
&
&
GetParentType
(
parentType
)
=
=
eTypeBlock
)
{
MOZ_ASSERT
(
aChild
-
>
GetParentNode
(
)
"
How
did
we
have
a
sibling
without
a
parent
?
"
)
;
nsIContent
*
prevSibling
=
aOldNextSibling
-
>
GetPreviousSibling
(
)
;
if
(
prevSibling
&
&
prevSibling
-
>
GetPreviousSibling
(
)
)
{
LAYOUT_PHASE_TEMP_EXIT
(
)
;
ReframeTextIfNeeded
(
prevSibling
)
;
LAYOUT_PHASE_TEMP_REENTER
(
)
;
}
if
(
aOldNextSibling
-
>
GetNextSibling
(
)
&
&
aOldNextSibling
-
>
GetPreviousSibling
(
)
)
{
LAYOUT_PHASE_TEMP_EXIT
(
)
;
ReframeTextIfNeeded
(
aOldNextSibling
)
;
LAYOUT_PHASE_TEMP_REENTER
(
)
;
}
}
#
ifdef
DEBUG
if
(
gReallyNoisyContentUpdates
&
&
parentFrame
)
{
printf
(
"
nsCSSFrameConstructor
:
:
ContentRemoved
:
resulting
frame
model
:
\
n
"
)
;
parentFrame
-
>
List
(
stdout
)
;
}
#
endif
}
return
false
;
}
static
void
InvalidateCanvasIfNeeded
(
nsIPresShell
*
presShell
nsIContent
*
node
)
{
MOZ_ASSERT
(
presShell
-
>
GetRootFrame
(
)
"
What
happened
here
?
"
)
;
MOZ_ASSERT
(
presShell
-
>
GetPresContext
(
)
"
Say
what
?
"
)
;
nsIContent
*
parent
=
node
-
>
GetParent
(
)
;
if
(
parent
)
{
nsIContent
*
grandParent
=
parent
-
>
GetParent
(
)
;
if
(
grandParent
)
{
return
;
}
if
(
!
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
return
;
}
}
nsIFrame
*
rootFrame
=
presShell
-
>
GetRootFrame
(
)
;
rootFrame
-
>
InvalidateFrameSubtree
(
)
;
}
bool
nsCSSFrameConstructor
:
:
EnsureFrameForTextNodeIsCreatedAfterFlush
(
CharacterData
*
aContent
)
{
if
(
!
aContent
-
>
HasFlag
(
NS_CREATE_FRAME_IF_NON_WHITESPACE
)
)
{
return
false
;
}
if
(
mAlwaysCreateFramesForIgnorableWhitespace
)
{
return
false
;
}
mAlwaysCreateFramesForIgnorableWhitespace
=
true
;
Element
*
root
=
mDocument
-
>
GetRootElement
(
)
;
if
(
!
root
)
{
return
false
;
}
RestyleManager
(
)
-
>
PostRestyleEvent
(
root
nsRestyleHint
(
0
)
nsChangeHint_ReconstructFrame
)
;
return
true
;
}
void
nsCSSFrameConstructor
:
:
CharacterDataChanged
(
nsIContent
*
aContent
const
CharacterDataChangeInfo
&
aInfo
)
{
AUTO_PROFILER_LABEL
(
"
nsCSSFrameConstructor
:
:
CharacterDataChanged
"
LAYOUT
)
;
AUTO_LAYOUT_PHASE_ENTRY_POINT
(
mPresShell
-
>
GetPresContext
(
)
FrameC
)
;
if
(
(
aContent
-
>
HasFlag
(
NS_CREATE_FRAME_IF_NON_WHITESPACE
)
&
&
!
aContent
-
>
TextIsOnlyWhitespace
(
)
)
|
|
(
aContent
-
>
HasFlag
(
NS_REFRAME_IF_WHITESPACE
)
&
&
aContent
-
>
TextIsOnlyWhitespace
(
)
)
)
{
#
ifdef
DEBUG
nsIFrame
*
frame
=
aContent
-
>
GetPrimaryFrame
(
)
;
NS_ASSERTION
(
!
frame
|
|
!
frame
-
>
IsGeneratedContentFrame
(
)
"
Bit
should
never
be
set
on
generated
content
"
)
;
#
endif
LAYOUT_PHASE_TEMP_EXIT
(
)
;
RecreateFramesForContent
(
aContent
InsertionKind
:
:
Async
)
;
LAYOUT_PHASE_TEMP_REENTER
(
)
;
return
;
}
if
(
nsIFrame
*
frame
=
aContent
-
>
GetPrimaryFrame
(
)
)
{
#
if
0
NS_FRAME_LOG
(
NS_FRAME_TRACE_CALLS
(
"
nsCSSFrameConstructor
:
:
CharacterDataChanged
:
content
=
%
p
[
%
s
]
subcontent
=
%
p
frame
=
%
p
"
aContent
ContentTag
(
aContent
0
)
aSubContent
frame
)
)
;
#
endif
nsContainerFrame
*
block
=
GetFloatContainingBlock
(
frame
)
;
bool
haveFirstLetterStyle
=
false
;
if
(
block
)
{
haveFirstLetterStyle
=
HasFirstLetterStyle
(
block
)
;
if
(
haveFirstLetterStyle
)
{
RemoveLetterFrames
(
mPresShell
block
)
;
frame
=
aContent
-
>
GetPrimaryFrame
(
)
;
NS_ASSERTION
(
frame
"
Should
have
frame
here
!
"
)
;
}
}
frame
-
>
CharacterDataChanged
(
aInfo
)
;
if
(
haveFirstLetterStyle
)
{
RecoverLetterFrames
(
block
)
;
}
}
}
void
nsCSSFrameConstructor
:
:
RecalcQuotesAndCounters
(
)
{
nsAutoScriptBlocker
scriptBlocker
;
if
(
mQuotesDirty
)
{
mQuotesDirty
=
false
;
mQuoteList
.
RecalcAll
(
)
;
}
if
(
mCountersDirty
)
{
mCountersDirty
=
false
;
mCounterManager
.
RecalcAll
(
)
;
}
NS_ASSERTION
(
!
mQuotesDirty
"
Quotes
updates
will
be
lost
"
)
;
NS_ASSERTION
(
!
mCountersDirty
"
Counter
updates
will
be
lost
"
)
;
}
void
nsCSSFrameConstructor
:
:
NotifyCounterStylesAreDirty
(
)
{
mCounterManager
.
SetAllDirty
(
)
;
CountersDirty
(
)
;
}
void
nsCSSFrameConstructor
:
:
WillDestroyFrameTree
(
)
{
#
if
defined
(
DEBUG_dbaron_off
)
mCounterManager
.
Dump
(
)
;
#
endif
mIsDestroyingFrameTree
=
true
;
mQuoteList
.
Clear
(
)
;
mCounterManager
.
Clear
(
)
;
nsFrameManager
:
:
Destroy
(
)
;
}
void
nsCSSFrameConstructor
:
:
GetAlternateTextFor
(
Element
*
aElement
nsAtom
*
aTag
nsAString
&
aAltText
)
{
if
(
aElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
alt
aAltText
)
)
{
return
;
}
if
(
nsGkAtoms
:
:
input
=
=
aTag
)
{
if
(
aElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
value
aAltText
)
)
{
return
;
}
nsContentUtils
:
:
GetLocalizedString
(
nsContentUtils
:
:
eFORMS_PROPERTIES
"
Submit
"
aAltText
)
;
}
}
nsIFrame
*
nsCSSFrameConstructor
:
:
CreateContinuingOuterTableFrame
(
nsIPresShell
*
aPresShell
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
nsContainerFrame
*
aParentFrame
nsIContent
*
aContent
ComputedStyle
*
aComputedStyle
)
{
nsTableWrapperFrame
*
newFrame
=
NS_NewTableWrapperFrame
(
aPresShell
aComputedStyle
)
;
newFrame
-
>
Init
(
aContent
aParentFrame
aFrame
)
;
nsFrameItems
newChildFrames
;
nsIFrame
*
childFrame
=
aFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
childFrame
)
{
nsIFrame
*
continuingTableFrame
=
CreateContinuingFrame
(
aPresContext
childFrame
newFrame
)
;
newChildFrames
.
AddChild
(
continuingTableFrame
)
;
NS_ASSERTION
(
!
childFrame
-
>
GetNextSibling
(
)
"
there
can
be
only
one
inner
table
frame
"
)
;
}
newFrame
-
>
SetInitialChildList
(
kPrincipalList
newChildFrames
)
;
return
newFrame
;
}
nsIFrame
*
nsCSSFrameConstructor
:
:
CreateContinuingTableFrame
(
nsIPresShell
*
aPresShell
nsIFrame
*
aFrame
nsContainerFrame
*
aParentFrame
nsIContent
*
aContent
ComputedStyle
*
aComputedStyle
)
{
nsTableFrame
*
newFrame
=
NS_NewTableFrame
(
aPresShell
aComputedStyle
)
;
newFrame
-
>
Init
(
aContent
aParentFrame
aFrame
)
;
nsFrameItems
childFrames
;
for
(
nsIFrame
*
childFrame
:
aFrame
-
>
PrincipalChildList
(
)
)
{
nsTableRowGroupFrame
*
rowGroupFrame
=
static_cast
<
nsTableRowGroupFrame
*
>
(
childFrame
)
;
nsIFrame
*
rgNextInFlow
=
rowGroupFrame
-
>
GetNextInFlow
(
)
;
if
(
rgNextInFlow
)
{
rowGroupFrame
-
>
SetRepeatable
(
false
)
;
}
else
if
(
rowGroupFrame
-
>
IsRepeatable
(
)
)
{
nsTableRowGroupFrame
*
headerFooterFrame
;
nsFrameItems
childItems
;
nsFrameConstructorState
state
(
mPresShell
GetAbsoluteContainingBlock
(
newFrame
FIXED_POS
)
GetAbsoluteContainingBlock
(
newFrame
ABS_POS
)
nullptr
)
;
state
.
mCreatingExtraFrames
=
true
;
ComputedStyle
*
const
headerFooterComputedStyle
=
rowGroupFrame
-
>
Style
(
)
;
headerFooterFrame
=
static_cast
<
nsTableRowGroupFrame
*
>
(
NS_NewTableRowGroupFrame
(
aPresShell
headerFooterComputedStyle
)
)
;
nsIContent
*
headerFooter
=
rowGroupFrame
-
>
GetContent
(
)
;
headerFooterFrame
-
>
Init
(
headerFooter
newFrame
nullptr
)
;
nsFrameConstructorSaveState
absoluteSaveState
;
MakeTablePartAbsoluteContainingBlockIfNeeded
(
state
headerFooterComputedStyle
-
>
StyleDisplay
(
)
absoluteSaveState
headerFooterFrame
)
;
ProcessChildren
(
state
headerFooter
rowGroupFrame
-
>
Style
(
)
headerFooterFrame
true
childItems
false
nullptr
)
;
NS_ASSERTION
(
state
.
mFloatedItems
.
IsEmpty
(
)
"
unexpected
floated
element
"
)
;
headerFooterFrame
-
>
SetInitialChildList
(
kPrincipalList
childItems
)
;
headerFooterFrame
-
>
SetRepeatable
(
true
)
;
headerFooterFrame
-
>
InitRepeatedFrame
(
rowGroupFrame
)
;
childFrames
.
AddChild
(
headerFooterFrame
)
;
}
}
newFrame
-
>
SetInitialChildList
(
kPrincipalList
childFrames
)
;
return
newFrame
;
}
nsIFrame
*
nsCSSFrameConstructor
:
:
CreateContinuingFrame
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
nsContainerFrame
*
aParentFrame
bool
aIsFluid
)
{
nsIPresShell
*
shell
=
aPresContext
-
>
PresShell
(
)
;
ComputedStyle
*
computedStyle
=
aFrame
-
>
Style
(
)
;
nsIFrame
*
newFrame
=
nullptr
;
nsIFrame
*
nextContinuation
=
aFrame
-
>
GetNextContinuation
(
)
;
nsIFrame
*
nextInFlow
=
aFrame
-
>
GetNextInFlow
(
)
;
LayoutFrameType
frameType
=
aFrame
-
>
Type
(
)
;
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
LayoutFrameType
:
:
Text
=
=
frameType
)
{
newFrame
=
NS_NewContinuingTextFrame
(
shell
computedStyle
)
;
newFrame
-
>
Init
(
content
aParentFrame
aFrame
)
;
}
else
if
(
LayoutFrameType
:
:
Inline
=
=
frameType
)
{
newFrame
=
NS_NewInlineFrame
(
shell
computedStyle
)
;
newFrame
-
>
Init
(
content
aParentFrame
aFrame
)
;
}
else
if
(
LayoutFrameType
:
:
Block
=
=
frameType
)
{
MOZ_ASSERT
(
!
aFrame
-
>
IsTableCaption
(
)
"
no
support
for
fragmenting
table
captions
yet
"
)
;
newFrame
=
NS_NewBlockFrame
(
shell
computedStyle
)
;
newFrame
-
>
Init
(
content
aParentFrame
aFrame
)
;
#
ifdef
MOZ_XUL
}
else
if
(
LayoutFrameType
:
:
XULLabel
=
=
frameType
)
{
newFrame
=
NS_NewXULLabelFrame
(
shell
computedStyle
)
;
newFrame
-
>
Init
(
content
aParentFrame
aFrame
)
;
#
endif
}
else
if
(
LayoutFrameType
:
:
ColumnSetWrapper
=
=
frameType
)
{
newFrame
=
NS_NewColumnSetWrapperFrame
(
shell
computedStyle
nsFrameState
(
0
)
)
;
newFrame
-
>
Init
(
content
aParentFrame
aFrame
)
;
}
else
if
(
LayoutFrameType
:
:
ColumnSet
=
=
frameType
)
{
MOZ_ASSERT
(
!
aFrame
-
>
IsTableCaption
(
)
"
no
support
for
fragmenting
table
captions
yet
"
)
;
newFrame
=
NS_NewColumnSetFrame
(
shell
computedStyle
nsFrameState
(
0
)
)
;
newFrame
-
>
Init
(
content
aParentFrame
aFrame
)
;
}
else
if
(
LayoutFrameType
:
:
Page
=
=
frameType
)
{
nsContainerFrame
*
canvasFrame
;
newFrame
=
ConstructPageFrame
(
shell
aParentFrame
aFrame
canvasFrame
)
;
}
else
if
(
LayoutFrameType
:
:
TableWrapper
=
=
frameType
)
{
newFrame
=
CreateContinuingOuterTableFrame
(
shell
aPresContext
aFrame
aParentFrame
content
computedStyle
)
;
}
else
if
(
LayoutFrameType
:
:
Table
=
=
frameType
)
{
newFrame
=
CreateContinuingTableFrame
(
shell
aFrame
aParentFrame
content
computedStyle
)
;
}
else
if
(
LayoutFrameType
:
:
TableRowGroup
=
=
frameType
)
{
newFrame
=
NS_NewTableRowGroupFrame
(
shell
computedStyle
)
;
newFrame
-
>
Init
(
content
aParentFrame
aFrame
)
;
if
(
newFrame
-
>
GetStateBits
(
)
&
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
{
nsTableFrame
:
:
RegisterPositionedTablePart
(
newFrame
)
;
}
}
else
if
(
LayoutFrameType
:
:
TableRow
=
=
frameType
)
{
nsTableRowFrame
*
rowFrame
=
NS_NewTableRowFrame
(
shell
computedStyle
)
;
rowFrame
-
>
Init
(
content
aParentFrame
aFrame
)
;
if
(
rowFrame
-
>
GetStateBits
(
)
&
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
{
nsTableFrame
:
:
RegisterPositionedTablePart
(
rowFrame
)
;
}
nsFrameItems
newChildList
;
nsIFrame
*
cellFrame
=
aFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
while
(
cellFrame
)
{
if
(
IsTableCell
(
cellFrame
-
>
Type
(
)
)
)
{
nsIFrame
*
continuingCellFrame
=
CreateContinuingFrame
(
aPresContext
cellFrame
rowFrame
)
;
newChildList
.
AddChild
(
continuingCellFrame
)
;
}
cellFrame
=
cellFrame
-
>
GetNextSibling
(
)
;
}
rowFrame
-
>
SetInitialChildList
(
kPrincipalList
newChildList
)
;
newFrame
=
rowFrame
;
}
else
if
(
IsTableCell
(
frameType
)
)
{
nsTableFrame
*
tableFrame
=
static_cast
<
nsTableRowFrame
*
>
(
aParentFrame
)
-
>
GetTableFrame
(
)
;
nsTableCellFrame
*
cellFrame
=
NS_NewTableCellFrame
(
shell
computedStyle
tableFrame
)
;
cellFrame
-
>
Init
(
content
aParentFrame
aFrame
)
;
if
(
cellFrame
-
>
GetStateBits
(
)
&
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
{
nsTableFrame
:
:
RegisterPositionedTablePart
(
cellFrame
)
;
}
nsIFrame
*
blockFrame
=
aFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
nsIFrame
*
continuingBlockFrame
=
CreateContinuingFrame
(
aPresContext
blockFrame
static_cast
<
nsContainerFrame
*
>
(
cellFrame
)
)
;
SetInitialSingleChild
(
cellFrame
continuingBlockFrame
)
;
newFrame
=
cellFrame
;
}
else
if
(
LayoutFrameType
:
:
Line
=
=
frameType
)
{
newFrame
=
NS_NewFirstLineFrame
(
shell
computedStyle
)
;
newFrame
-
>
Init
(
content
aParentFrame
aFrame
)
;
}
else
if
(
LayoutFrameType
:
:
Letter
=
=
frameType
)
{
newFrame
=
NS_NewFirstLetterFrame
(
shell
computedStyle
)
;
newFrame
-
>
Init
(
content
aParentFrame
aFrame
)
;
}
else
if
(
LayoutFrameType
:
:
Image
=
=
frameType
)
{
auto
*
imageFrame
=
static_cast
<
nsImageFrame
*
>
(
aFrame
)
;
newFrame
=
imageFrame
-
>
CreateContinuingFrame
(
shell
computedStyle
)
;
newFrame
-
>
Init
(
content
aParentFrame
aFrame
)
;
}
else
if
(
LayoutFrameType
:
:
ImageControl
=
=
frameType
)
{
newFrame
=
NS_NewImageControlFrame
(
shell
computedStyle
)
;
newFrame
-
>
Init
(
content
aParentFrame
aFrame
)
;
}
else
if
(
LayoutFrameType
:
:
FieldSet
=
=
frameType
)
{
nsContainerFrame
*
fieldset
=
NS_NewFieldSetFrame
(
shell
computedStyle
)
;
fieldset
-
>
Init
(
content
aParentFrame
aFrame
)
;
nsContainerFrame
*
blockFrame
=
GetFieldSetBlockFrame
(
aFrame
)
;
if
(
blockFrame
)
{
nsIFrame
*
continuingBlockFrame
=
CreateContinuingFrame
(
aPresContext
blockFrame
fieldset
)
;
SetInitialSingleChild
(
fieldset
continuingBlockFrame
)
;
}
else
{
MOZ_ASSERT
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_IS_OVERFLOW_CONTAINER
"
FieldSet
block
may
only
be
null
for
overflow
containers
"
)
;
}
newFrame
=
fieldset
;
}
else
if
(
LayoutFrameType
:
:
Legend
=
=
frameType
)
{
newFrame
=
NS_NewLegendFrame
(
shell
computedStyle
)
;
newFrame
-
>
Init
(
content
aParentFrame
aFrame
)
;
}
else
if
(
LayoutFrameType
:
:
FlexContainer
=
=
frameType
)
{
newFrame
=
NS_NewFlexContainerFrame
(
shell
computedStyle
)
;
newFrame
-
>
Init
(
content
aParentFrame
aFrame
)
;
}
else
if
(
LayoutFrameType
:
:
GridContainer
=
=
frameType
)
{
newFrame
=
NS_NewGridContainerFrame
(
shell
computedStyle
)
;
newFrame
-
>
Init
(
content
aParentFrame
aFrame
)
;
}
else
if
(
LayoutFrameType
:
:
Ruby
=
=
frameType
)
{
newFrame
=
NS_NewRubyFrame
(
shell
computedStyle
)
;
newFrame
-
>
Init
(
content
aParentFrame
aFrame
)
;
}
else
if
(
LayoutFrameType
:
:
RubyBaseContainer
=
=
frameType
)
{
newFrame
=
NS_NewRubyBaseContainerFrame
(
shell
computedStyle
)
;
newFrame
-
>
Init
(
content
aParentFrame
aFrame
)
;
}
else
if
(
LayoutFrameType
:
:
RubyTextContainer
=
=
frameType
)
{
newFrame
=
NS_NewRubyTextContainerFrame
(
shell
computedStyle
)
;
newFrame
-
>
Init
(
content
aParentFrame
aFrame
)
;
}
else
if
(
LayoutFrameType
:
:
Details
=
=
frameType
)
{
newFrame
=
NS_NewDetailsFrame
(
shell
computedStyle
)
;
newFrame
-
>
Init
(
content
aParentFrame
aFrame
)
;
}
else
{
MOZ_CRASH
(
"
unexpected
frame
type
"
)
;
}
if
(
!
aIsFluid
)
{
newFrame
-
>
SetPrevContinuation
(
aFrame
)
;
}
if
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_GENERATED_CONTENT
)
{
newFrame
-
>
AddStateBits
(
NS_FRAME_GENERATED_CONTENT
)
;
}
if
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_ANONYMOUSCONTENTCREATOR_CONTENT
)
{
newFrame
-
>
AddStateBits
(
NS_FRAME_ANONYMOUSCONTENTCREATOR_CONTENT
)
;
}
if
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
{
newFrame
-
>
AddStateBits
(
NS_FRAME_OUT_OF_FLOW
)
;
}
if
(
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_HAS_MULTI_COLUMN_ANCESTOR
)
)
{
newFrame
-
>
AddStateBits
(
NS_FRAME_HAS_MULTI_COLUMN_ANCESTOR
)
;
}
if
(
nextInFlow
)
{
nextInFlow
-
>
SetPrevInFlow
(
newFrame
)
;
newFrame
-
>
SetNextInFlow
(
nextInFlow
)
;
}
else
if
(
nextContinuation
)
{
nextContinuation
-
>
SetPrevContinuation
(
newFrame
)
;
newFrame
-
>
SetNextContinuation
(
nextContinuation
)
;
}
MOZ_ASSERT
(
!
newFrame
-
>
GetNextSibling
(
)
"
unexpected
sibling
"
)
;
return
newFrame
;
}
nsresult
nsCSSFrameConstructor
:
:
ReplicateFixedFrames
(
nsPageContentFrame
*
aParentFrame
)
{
nsIFrame
*
prevPageContentFrame
=
aParentFrame
-
>
GetPrevInFlow
(
)
;
if
(
!
prevPageContentFrame
)
{
return
NS_OK
;
}
nsContainerFrame
*
canvasFrame
=
do_QueryFrame
(
aParentFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
)
;
nsIFrame
*
prevCanvasFrame
=
prevPageContentFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
!
canvasFrame
|
|
!
prevCanvasFrame
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsFrameItems
fixedPlaceholders
;
nsIFrame
*
firstFixed
=
prevPageContentFrame
-
>
GetChildList
(
nsIFrame
:
:
kFixedList
)
.
FirstChild
(
)
;
if
(
!
firstFixed
)
{
return
NS_OK
;
}
nsFrameConstructorState
state
(
mPresShell
aParentFrame
nullptr
mRootElementFrame
)
;
state
.
mCreatingExtraFrames
=
true
;
for
(
nsIFrame
*
fixed
=
firstFixed
;
fixed
;
fixed
=
fixed
-
>
GetNextSibling
(
)
)
{
nsIFrame
*
prevPlaceholder
=
fixed
-
>
GetPlaceholderFrame
(
)
;
if
(
prevPlaceholder
&
&
nsLayoutUtils
:
:
IsProperAncestorFrame
(
prevCanvasFrame
prevPlaceholder
)
)
{
nsIContent
*
content
=
fixed
-
>
GetContent
(
)
;
ComputedStyle
*
computedStyle
=
nsLayoutUtils
:
:
GetStyleFrame
(
content
)
-
>
Style
(
)
;
AutoFrameConstructionItemList
items
(
this
)
;
AddFrameConstructionItemsInternal
(
state
content
canvasFrame
true
computedStyle
ITEM_ALLOW_XBL_BASE
|
ITEM_ALLOW_PAGE_BREAK
items
)
;
ConstructFramesFromItemList
(
state
items
canvasFrame
false
fixedPlaceholders
)
;
}
}
NS_ASSERTION
(
!
canvasFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
"
leaking
frames
;
doc
root
continuation
must
be
empty
"
)
;
canvasFrame
-
>
SetInitialChildList
(
kPrincipalList
fixedPlaceholders
)
;
return
NS_OK
;
}
nsCSSFrameConstructor
:
:
InsertionPoint
nsCSSFrameConstructor
:
:
GetInsertionPoint
(
nsIContent
*
aChild
)
{
MOZ_ASSERT
(
aChild
)
;
nsIContent
*
insertionElement
=
aChild
-
>
GetFlattenedTreeParent
(
)
;
if
(
!
insertionElement
)
{
return
{
}
;
}
return
{
GetContentInsertionFrameFor
(
insertionElement
)
insertionElement
}
;
}
void
nsCSSFrameConstructor
:
:
CaptureStateForFramesOf
(
nsIContent
*
aContent
nsILayoutHistoryState
*
aHistoryState
)
{
if
(
!
aHistoryState
)
{
return
;
}
nsIFrame
*
frame
=
aContent
-
>
GetPrimaryFrame
(
)
;
if
(
frame
=
=
mRootElementFrame
)
{
frame
=
mRootElementFrame
?
GetAbsoluteContainingBlock
(
mRootElementFrame
FIXED_POS
)
:
GetRootFrame
(
)
;
}
for
(
;
frame
;
frame
=
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
frame
)
)
{
CaptureFrameState
(
frame
aHistoryState
)
;
}
}
static
bool
IsWhitespaceFrame
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
"
invalid
argument
"
)
;
return
aFrame
-
>
IsTextFrame
(
)
&
&
aFrame
-
>
GetContent
(
)
-
>
TextIsOnlyWhitespace
(
)
;
}
static
nsIFrame
*
FindFirstNonWhitespaceChild
(
nsIFrame
*
aParentFrame
)
{
nsIFrame
*
f
=
aParentFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
while
(
f
&
&
IsWhitespaceFrame
(
f
)
)
{
f
=
f
-
>
GetNextSibling
(
)
;
}
return
f
;
}
static
nsIFrame
*
FindNextNonWhitespaceSibling
(
nsIFrame
*
aFrame
)
{
nsIFrame
*
f
=
aFrame
;
do
{
f
=
f
-
>
GetNextSibling
(
)
;
}
while
(
f
&
&
IsWhitespaceFrame
(
f
)
)
;
return
f
;
}
static
nsIFrame
*
FindPreviousNonWhitespaceSibling
(
nsIFrame
*
aFrame
)
{
nsIFrame
*
f
=
aFrame
;
do
{
f
=
f
-
>
GetPrevSibling
(
)
;
}
while
(
f
&
&
IsWhitespaceFrame
(
f
)
)
;
return
f
;
}
bool
nsCSSFrameConstructor
:
:
MaybeRecreateContainerForFrameRemoval
(
nsIFrame
*
aFrame
)
{
#
define
TRACE
(
reason
)
\
PROFILER_TRACING
(
"
Layout
"
"
MaybeRecreateContainerForFrameRemoval
:
"
reason
\
LAYOUT
TRACING_EVENT
)
MOZ_ASSERT
(
aFrame
"
Must
have
a
frame
"
)
;
MOZ_ASSERT
(
aFrame
-
>
GetParent
(
)
"
Frame
shouldn
'
t
be
root
"
)
;
MOZ_ASSERT
(
aFrame
=
=
aFrame
-
>
FirstContinuation
(
)
"
aFrame
not
the
result
of
GetPrimaryFrame
(
)
?
"
)
;
nsIFrame
*
inFlowFrame
=
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
?
aFrame
-
>
GetPlaceholderFrame
(
)
:
aFrame
;
MOZ_ASSERT
(
inFlowFrame
"
How
did
that
happen
?
"
)
;
MOZ_ASSERT
(
inFlowFrame
=
=
inFlowFrame
-
>
FirstContinuation
(
)
"
placeholder
for
primary
frame
has
previous
continuations
?
"
)
;
nsIFrame
*
parent
=
inFlowFrame
-
>
GetParent
(
)
;
if
(
inFlowFrame
-
>
HasAnyStateBits
(
NS_FRAME_HAS_MULTI_COLUMN_ANCESTOR
)
)
{
nsIFrame
*
grandparent
=
parent
-
>
GetParent
(
)
;
MOZ_ASSERT
(
grandparent
)
;
bool
needsReframe
=
inFlowFrame
-
>
IsColumnSpan
(
)
|
|
inFlowFrame
-
>
GetProperty
(
nsIFrame
:
:
HasColumnSpanSiblings
(
)
)
|
|
(
parent
-
>
Style
(
)
-
>
GetPseudo
(
)
=
=
nsCSSAnonBoxes
:
:
columnContent
(
)
&
&
!
inFlowFrame
-
>
GetPrevSibling
(
)
&
&
!
inFlowFrame
-
>
GetNextSibling
(
)
&
&
!
parent
-
>
GetPrevInFlow
(
)
&
&
grandparent
-
>
GetPrevSibling
(
)
)
;
if
(
needsReframe
)
{
nsContainerFrame
*
containingBlock
=
GetMultiColumnContainingBlockFor
(
inFlowFrame
)
;
#
ifdef
DEBUG
if
(
IsFramePartOfIBSplit
(
inFlowFrame
)
)
{
nsIFrame
*
ibContainingBlock
=
GetIBContainingBlockFor
(
inFlowFrame
)
;
MOZ_ASSERT
(
containingBlock
=
=
ibContainingBlock
|
|
nsLayoutUtils
:
:
IsProperAncestorFrame
(
containingBlock
ibContainingBlock
)
"
Multi
-
column
containing
block
should
be
equal
to
or
be
the
"
"
ancestor
of
the
IB
containing
block
!
"
)
;
}
#
endif
TRACE
(
"
Multi
-
column
"
)
;
RecreateFramesForContent
(
containingBlock
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
return
true
;
}
}
if
(
IsFramePartOfIBSplit
(
aFrame
)
)
{
TRACE
(
"
IB
split
removal
"
)
;
ReframeContainingBlock
(
aFrame
)
;
return
true
;
}
nsContainerFrame
*
insertionFrame
=
aFrame
-
>
GetContentInsertionFrame
(
)
;
if
(
insertionFrame
&
&
insertionFrame
-
>
IsLegendFrame
(
)
&
&
aFrame
-
>
GetParent
(
)
-
>
IsFieldSetFrame
(
)
)
{
TRACE
(
"
Fieldset
/
Legend
"
)
;
RecreateFramesForContent
(
aFrame
-
>
GetParent
(
)
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
return
true
;
}
if
(
parent
&
&
parent
-
>
IsDetailsFrame
(
)
)
{
HTMLSummaryElement
*
summary
=
HTMLSummaryElement
:
:
FromNode
(
aFrame
-
>
GetContent
(
)
)
;
DetailsFrame
*
detailsFrame
=
static_cast
<
DetailsFrame
*
>
(
parent
)
;
if
(
summary
&
&
detailsFrame
-
>
HasMainSummaryFrame
(
aFrame
)
)
{
TRACE
(
"
Details
/
Summary
"
)
;
RecreateFramesForContent
(
parent
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
return
true
;
}
}
if
(
IsTableOrRubyPseudo
(
parent
)
)
{
if
(
FindFirstNonWhitespaceChild
(
parent
)
=
=
inFlowFrame
|
|
!
FindNextNonWhitespaceSibling
(
inFlowFrame
-
>
LastContinuation
(
)
)
|
|
(
IsWhitespaceFrame
(
aFrame
)
&
&
parent
-
>
PrincipalChildList
(
)
.
OnlyChild
(
)
)
|
|
(
inFlowFrame
-
>
IsTableColGroupFrame
(
)
&
&
parent
-
>
GetChildList
(
nsIFrame
:
:
kColGroupList
)
.
FirstChild
(
)
=
=
inFlowFrame
)
|
|
(
inFlowFrame
-
>
IsTableCaption
(
)
&
&
parent
-
>
GetChildList
(
nsIFrame
:
:
kCaptionList
)
.
FirstChild
(
)
=
=
inFlowFrame
)
)
{
TRACE
(
"
Table
or
ruby
pseudo
parent
"
)
;
RecreateFramesForContent
(
parent
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
return
true
;
}
}
nsIFrame
*
nextSibling
=
FindNextNonWhitespaceSibling
(
inFlowFrame
-
>
LastContinuation
(
)
)
;
NS_ASSERTION
(
!
IsTableOrRubyPseudo
(
inFlowFrame
)
"
Shouldn
'
t
happen
here
"
)
;
if
(
nextSibling
&
&
IsTableOrRubyPseudo
(
nextSibling
)
)
{
nsIFrame
*
prevSibling
=
FindPreviousNonWhitespaceSibling
(
inFlowFrame
)
;
if
(
prevSibling
&
&
IsTableOrRubyPseudo
(
prevSibling
)
)
{
TRACE
(
"
Table
or
ruby
pseudo
sibling
"
)
;
RecreateFramesForContent
(
parent
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
return
true
;
}
}
LayoutFrameType
parentType
=
parent
-
>
Type
(
)
;
if
(
parentType
=
=
LayoutFrameType
:
:
Ruby
|
|
RubyUtils
:
:
IsRubyContainerBox
(
parentType
)
)
{
TRACE
(
"
Ruby
container
"
)
;
RecreateFramesForContent
(
parent
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
return
true
;
}
if
(
nextSibling
&
&
IsAnonymousFlexOrGridItem
(
nextSibling
)
)
{
AssertAnonymousFlexOrGridItemParent
(
nextSibling
parent
)
;
TRACE
(
"
Anon
flex
or
grid
item
next
sibling
"
)
;
RecreateFramesForContent
(
parent
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
return
true
;
}
if
(
!
nextSibling
&
&
IsAnonymousFlexOrGridItem
(
parent
)
)
{
AssertAnonymousFlexOrGridItemParent
(
parent
parent
-
>
GetParent
(
)
)
;
TRACE
(
"
Anon
flex
or
grid
item
parent
"
)
;
RecreateFramesForContent
(
parent
-
>
GetParent
(
)
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
return
true
;
}
#
ifdef
MOZ_XUL
if
(
aFrame
-
>
IsPopupSetFrame
(
)
)
{
nsIPopupContainer
*
popupContainer
=
nsIPopupContainer
:
:
GetPopupContainer
(
mPresShell
)
;
if
(
popupContainer
&
&
popupContainer
-
>
GetPopupSetFrame
(
)
=
=
aFrame
)
{
TRACE
(
"
PopupSet
"
)
;
ReconstructDocElementHierarchy
(
InsertionKind
:
:
Async
)
;
return
true
;
}
}
#
endif
if
(
!
inFlowFrame
-
>
GetPrevSibling
(
)
&
&
!
inFlowFrame
-
>
GetNextSibling
(
)
&
&
(
(
parent
-
>
GetPrevContinuation
(
)
&
&
!
parent
-
>
GetPrevInFlow
(
)
)
|
|
(
parent
-
>
GetNextContinuation
(
)
&
&
!
parent
-
>
GetNextInFlow
(
)
)
)
)
{
TRACE
(
"
Removing
last
child
of
non
-
fluid
split
parent
"
)
;
RecreateFramesForContent
(
parent
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
return
true
;
}
if
(
!
IsFramePartOfIBSplit
(
parent
)
)
{
return
false
;
}
if
(
inFlowFrame
!
=
parent
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
|
|
inFlowFrame
-
>
LastContinuation
(
)
-
>
GetNextSibling
(
)
)
{
return
false
;
}
nsIFrame
*
parentFirstContinuation
=
parent
-
>
FirstContinuation
(
)
;
if
(
!
GetIBSplitSibling
(
parentFirstContinuation
)
|
|
!
GetIBSplitPrevSibling
(
parentFirstContinuation
)
)
{
return
false
;
}
TRACE
(
"
IB
split
parent
"
)
;
ReframeContainingBlock
(
parent
)
;
return
true
;
#
undef
TRACE
}
void
nsCSSFrameConstructor
:
:
UpdateTableCellSpans
(
nsIContent
*
aContent
)
{
nsTableCellFrame
*
cellFrame
=
do_QueryFrame
(
aContent
-
>
GetPrimaryFrame
(
)
)
;
NS_WARNING_ASSERTION
(
cellFrame
"
Hint
should
only
be
posted
on
table
cells
!
"
)
;
if
(
cellFrame
)
{
cellFrame
-
>
GetTableFrame
(
)
-
>
RowOrColSpanChanged
(
cellFrame
)
;
}
}
static
nsIContent
*
GetTopmostMathMLElement
(
nsIContent
*
aMathMLContent
)
{
MOZ_ASSERT
(
aMathMLContent
-
>
IsMathMLElement
(
)
)
;
MOZ_ASSERT
(
aMathMLContent
-
>
GetPrimaryFrame
(
)
)
;
MOZ_ASSERT
(
aMathMLContent
-
>
GetPrimaryFrame
(
)
-
>
IsFrameOfType
(
nsIFrame
:
:
eMathML
)
)
;
nsIContent
*
root
=
aMathMLContent
;
for
(
nsIContent
*
parent
=
aMathMLContent
-
>
GetFlattenedTreeParent
(
)
;
parent
;
parent
=
parent
-
>
GetFlattenedTreeParent
(
)
)
{
nsIFrame
*
frame
=
parent
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
|
|
!
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eMathML
)
)
{
break
;
}
root
=
parent
;
}
return
root
;
}
void
nsCSSFrameConstructor
:
:
RecreateFramesForContent
(
nsIContent
*
aContent
InsertionKind
aInsertionKind
)
{
MOZ_ASSERT
(
aContent
)
;
if
(
NS_WARN_IF
(
!
aContent
-
>
GetComposedDoc
(
)
)
)
{
return
;
}
nsIFrame
*
frame
=
aContent
-
>
GetPrimaryFrame
(
)
;
if
(
frame
&
&
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eMathML
)
)
{
aContent
=
GetTopmostMathMLElement
(
aContent
)
;
frame
=
aContent
-
>
GetPrimaryFrame
(
)
;
}
if
(
frame
)
{
nsIFrame
*
nonGeneratedAncestor
=
nsLayoutUtils
:
:
GetNonGeneratedAncestor
(
frame
)
;
if
(
nonGeneratedAncestor
-
>
GetContent
(
)
!
=
aContent
)
{
return
RecreateFramesForContent
(
nonGeneratedAncestor
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
}
if
(
frame
-
>
GetStateBits
(
)
&
NS_FRAME_ANONYMOUSCONTENTCREATOR_CONTENT
)
{
nsIAnonymousContentCreator
*
acc
=
nullptr
;
nsIFrame
*
ancestor
=
nsLayoutUtils
:
:
GetParentOrPlaceholderFor
(
frame
)
;
while
(
!
(
acc
=
do_QueryFrame
(
ancestor
)
)
)
{
ancestor
=
nsLayoutUtils
:
:
GetParentOrPlaceholderFor
(
ancestor
)
;
}
NS_ASSERTION
(
acc
"
Where
is
the
nsIAnonymousContentCreator
?
We
may
fail
"
"
to
recreate
its
content
correctly
"
)
;
NS_ASSERTION
(
aContent
-
>
IsInNativeAnonymousSubtree
(
)
"
Why
is
NS_FRAME_ANONYMOUSCONTENTCREATOR_CONTENT
set
?
"
)
;
return
RecreateFramesForContent
(
ancestor
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
}
nsIFrame
*
parent
=
frame
-
>
GetParent
(
)
;
nsIContent
*
parentContent
=
parent
?
parent
-
>
GetContent
(
)
:
nullptr
;
if
(
parent
&
&
parent
-
>
IsLeaf
(
)
&
&
parentContent
&
&
parentContent
!
=
aContent
)
{
return
RecreateFramesForContent
(
parentContent
InsertionKind
:
:
Async
)
;
}
}
if
(
frame
&
&
MaybeRecreateContainerForFrameRemoval
(
frame
)
)
{
return
;
}
MOZ_ASSERT
(
aContent
-
>
GetParentNode
(
)
)
;
nsIContent
*
nextSibling
=
aContent
-
>
IsRootOfAnonymousSubtree
(
)
?
nullptr
:
aContent
-
>
GetNextSibling
(
)
;
bool
didReconstruct
=
ContentRemoved
(
aContent
nextSibling
REMOVE_FOR_RECONSTRUCTION
)
;
if
(
!
didReconstruct
)
{
if
(
aInsertionKind
=
=
InsertionKind
:
:
Async
&
&
aContent
-
>
IsElement
(
)
)
{
RestyleManager
(
)
-
>
PostRestyleEvent
(
aContent
-
>
AsElement
(
)
nsRestyleHint
(
0
)
nsChangeHint_ReconstructFrame
)
;
}
else
{
ContentRangeInserted
(
aContent
aContent
-
>
GetNextSibling
(
)
mTempFrameTreeState
aInsertionKind
)
;
}
}
}
bool
nsCSSFrameConstructor
:
:
DestroyFramesFor
(
Element
*
aElement
)
{
MOZ_ASSERT
(
aElement
&
&
aElement
-
>
GetParentNode
(
)
)
;
nsIContent
*
nextSibling
=
aElement
-
>
IsRootOfAnonymousSubtree
(
)
?
nullptr
:
aElement
-
>
GetNextSibling
(
)
;
return
ContentRemoved
(
aElement
nextSibling
REMOVE_FOR_RECONSTRUCTION
)
;
}
already_AddRefed
<
ComputedStyle
>
nsCSSFrameConstructor
:
:
GetFirstLetterStyle
(
nsIContent
*
aContent
ComputedStyle
*
aComputedStyle
)
{
if
(
aContent
)
{
return
mPresShell
-
>
StyleSet
(
)
-
>
ResolvePseudoElementStyle
(
aContent
-
>
AsElement
(
)
CSSPseudoElementType
:
:
firstLetter
aComputedStyle
nullptr
)
;
}
return
nullptr
;
}
already_AddRefed
<
ComputedStyle
>
nsCSSFrameConstructor
:
:
GetFirstLineStyle
(
nsIContent
*
aContent
ComputedStyle
*
aComputedStyle
)
{
if
(
aContent
)
{
return
mPresShell
-
>
StyleSet
(
)
-
>
ResolvePseudoElementStyle
(
aContent
-
>
AsElement
(
)
CSSPseudoElementType
:
:
firstLine
aComputedStyle
nullptr
)
;
}
return
nullptr
;
}
bool
nsCSSFrameConstructor
:
:
ShouldHaveFirstLetterStyle
(
nsIContent
*
aContent
ComputedStyle
*
aComputedStyle
)
{
return
nsLayoutUtils
:
:
HasPseudoStyle
(
aContent
aComputedStyle
CSSPseudoElementType
:
:
firstLetter
mPresShell
-
>
GetPresContext
(
)
)
;
}
bool
nsCSSFrameConstructor
:
:
HasFirstLetterStyle
(
nsIFrame
*
aBlockFrame
)
{
MOZ_ASSERT
(
aBlockFrame
"
Need
a
frame
"
)
;
NS_ASSERTION
(
nsLayoutUtils
:
:
GetAsBlock
(
aBlockFrame
)
"
Not
a
block
frame
?
"
)
;
return
(
aBlockFrame
-
>
GetStateBits
(
)
&
NS_BLOCK_HAS_FIRST_LETTER_STYLE
)
!
=
0
;
}
bool
nsCSSFrameConstructor
:
:
ShouldHaveFirstLineStyle
(
nsIContent
*
aContent
ComputedStyle
*
aComputedStyle
)
{
bool
hasFirstLine
=
nsLayoutUtils
:
:
HasPseudoStyle
(
aContent
aComputedStyle
CSSPseudoElementType
:
:
firstLine
mPresShell
-
>
GetPresContext
(
)
)
;
return
hasFirstLine
&
&
!
aContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
fieldset
)
;
}
void
nsCSSFrameConstructor
:
:
ShouldHaveSpecialBlockStyle
(
nsIContent
*
aContent
ComputedStyle
*
aComputedStyle
bool
*
aHaveFirstLetterStyle
bool
*
aHaveFirstLineStyle
)
{
*
aHaveFirstLetterStyle
=
ShouldHaveFirstLetterStyle
(
aContent
aComputedStyle
)
;
*
aHaveFirstLineStyle
=
ShouldHaveFirstLineStyle
(
aContent
aComputedStyle
)
;
}
const
nsCSSFrameConstructor
:
:
PseudoParentData
nsCSSFrameConstructor
:
:
sPseudoParentData
[
eParentTypeCount
]
=
{
{
FULL_CTOR_FCDATA
(
FCDATA_IS_TABLE_PART
|
FCDATA_SKIP_FRAMESET
|
FCDATA_USE_CHILD_ITEMS
|
FCDATA_IS_WRAPPER_ANON_BOX
|
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
eTypeRow
)
&
nsCSSFrameConstructor
:
:
ConstructTableCell
)
nsCSSAnonBoxes
:
:
tableCell
(
)
}
{
FULL_CTOR_FCDATA
(
FCDATA_IS_TABLE_PART
|
FCDATA_SKIP_FRAMESET
|
FCDATA_USE_CHILD_ITEMS
|
FCDATA_IS_WRAPPER_ANON_BOX
|
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
eTypeRowGroup
)
&
nsCSSFrameConstructor
:
:
ConstructTableRowOrRowGroup
)
nsCSSAnonBoxes
:
:
tableRow
(
)
}
{
FULL_CTOR_FCDATA
(
FCDATA_IS_TABLE_PART
|
FCDATA_SKIP_FRAMESET
|
FCDATA_USE_CHILD_ITEMS
|
FCDATA_IS_WRAPPER_ANON_BOX
|
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
eTypeTable
)
&
nsCSSFrameConstructor
:
:
ConstructTableRowOrRowGroup
)
nsCSSAnonBoxes
:
:
tableRowGroup
(
)
}
{
FCDATA_DECL
(
FCDATA_IS_TABLE_PART
|
FCDATA_SKIP_FRAMESET
|
FCDATA_DISALLOW_OUT_OF_FLOW
|
FCDATA_USE_CHILD_ITEMS
|
FCDATA_SKIP_ABSPOS_PUSH
|
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
eTypeTable
)
NS_NewTableColGroupFrame
)
nsCSSAnonBoxes
:
:
tableColGroup
(
)
}
{
FULL_CTOR_FCDATA
(
FCDATA_SKIP_FRAMESET
|
FCDATA_USE_CHILD_ITEMS
|
FCDATA_IS_WRAPPER_ANON_BOX
&
nsCSSFrameConstructor
:
:
ConstructTable
)
nsCSSAnonBoxes
:
:
table
(
)
}
{
FCDATA_DECL
(
FCDATA_IS_LINE_PARTICIPANT
|
FCDATA_USE_CHILD_ITEMS
|
FCDATA_IS_WRAPPER_ANON_BOX
|
FCDATA_SKIP_FRAMESET
NS_NewRubyFrame
)
nsCSSAnonBoxes
:
:
ruby
(
)
}
{
FCDATA_DECL
(
FCDATA_USE_CHILD_ITEMS
|
FCDATA_IS_LINE_PARTICIPANT
|
FCDATA_IS_WRAPPER_ANON_BOX
|
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
eTypeRubyBaseContainer
)
|
FCDATA_SKIP_FRAMESET
NS_NewRubyBaseFrame
)
nsCSSAnonBoxes
:
:
rubyBase
(
)
}
{
FCDATA_DECL
(
FCDATA_USE_CHILD_ITEMS
|
FCDATA_IS_LINE_PARTICIPANT
|
FCDATA_IS_WRAPPER_ANON_BOX
|
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
eTypeRuby
)
|
FCDATA_SKIP_FRAMESET
NS_NewRubyBaseContainerFrame
)
nsCSSAnonBoxes
:
:
rubyBaseContainer
(
)
}
{
FCDATA_DECL
(
FCDATA_USE_CHILD_ITEMS
|
FCDATA_IS_LINE_PARTICIPANT
|
FCDATA_IS_WRAPPER_ANON_BOX
|
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
eTypeRubyTextContainer
)
|
FCDATA_SKIP_FRAMESET
NS_NewRubyTextFrame
)
nsCSSAnonBoxes
:
:
rubyText
(
)
}
{
FCDATA_DECL
(
FCDATA_USE_CHILD_ITEMS
|
FCDATA_IS_WRAPPER_ANON_BOX
|
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
eTypeRuby
)
|
FCDATA_SKIP_FRAMESET
NS_NewRubyTextContainerFrame
)
nsCSSAnonBoxes
:
:
rubyTextContainer
(
)
}
}
;
void
nsCSSFrameConstructor
:
:
CreateNeededAnonFlexOrGridItems
(
nsFrameConstructorState
&
aState
FrameConstructionItemList
&
aItems
nsIFrame
*
aParentFrame
)
{
if
(
aItems
.
IsEmpty
(
)
|
|
!
aParentFrame
-
>
IsFlexOrGridContainer
(
)
)
{
return
;
}
const
bool
isLegacyBox
=
IsFlexContainerForLegacyBox
(
aParentFrame
)
;
FCItemIterator
iter
(
aItems
)
;
do
{
if
(
iter
.
SkipItemsThatDontNeedAnonFlexOrGridItem
(
aState
isLegacyBox
)
)
{
return
;
}
if
(
!
aParentFrame
-
>
IsGeneratedContentFrame
(
)
&
&
iter
.
item
(
)
.
IsWhitespace
(
aState
)
)
{
FCItemIterator
afterWhitespaceIter
(
iter
)
;
bool
hitEnd
=
afterWhitespaceIter
.
SkipWhitespace
(
aState
)
;
bool
nextChildNeedsAnonItem
=
!
hitEnd
&
&
afterWhitespaceIter
.
item
(
)
.
NeedsAnonFlexOrGridItem
(
aState
isLegacyBox
)
;
if
(
!
nextChildNeedsAnonItem
)
{
iter
.
DeleteItemsTo
(
this
afterWhitespaceIter
)
;
if
(
hitEnd
)
{
return
;
}
MOZ_ASSERT
(
!
iter
.
IsDone
(
)
&
&
!
iter
.
item
(
)
.
NeedsAnonFlexOrGridItem
(
aState
isLegacyBox
)
"
hitEnd
and
/
or
nextChildNeedsAnonItem
lied
"
)
;
continue
;
}
}
FCItemIterator
endIter
(
iter
)
;
endIter
.
SkipItemsThatNeedAnonFlexOrGridItem
(
aState
isLegacyBox
)
;
NS_ASSERTION
(
iter
!
=
endIter
"
Should
'
ve
had
at
least
one
wrappable
child
to
seek
past
"
)
;
nsAtom
*
pseudoType
=
(
aParentFrame
-
>
IsFlexContainerFrame
(
)
)
?
nsCSSAnonBoxes
:
:
anonymousFlexItem
(
)
:
nsCSSAnonBoxes
:
:
anonymousGridItem
(
)
;
ComputedStyle
*
parentStyle
=
aParentFrame
-
>
Style
(
)
;
nsIContent
*
parentContent
=
aParentFrame
-
>
GetContent
(
)
;
RefPtr
<
ComputedStyle
>
wrapperStyle
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveInheritingAnonymousBoxStyle
(
pseudoType
parentStyle
)
;
static
const
FrameConstructionData
sBlockFormattingContextFCData
=
FCDATA_DECL
(
FCDATA_SKIP_FRAMESET
|
FCDATA_USE_CHILD_ITEMS
|
FCDATA_IS_WRAPPER_ANON_BOX
NS_NewBlockFormattingContext
)
;
FrameConstructionItem
*
newItem
=
new
(
this
)
FrameConstructionItem
(
&
sBlockFormattingContextFCData
parentContent
nullptr
wrapperStyle
.
forget
(
)
true
)
;
newItem
-
>
mIsAllInline
=
newItem
-
>
mComputedStyle
-
>
StyleDisplay
(
)
-
>
IsInlineOutsideStyle
(
)
;
newItem
-
>
mIsBlock
=
!
newItem
-
>
mIsAllInline
;
MOZ_ASSERT
(
!
newItem
-
>
mIsAllInline
&
&
newItem
-
>
mIsBlock
"
expecting
anonymous
flex
/
grid
items
to
be
block
-
level
"
"
(
this
will
make
a
difference
when
we
encounter
"
"
'
align
-
items
:
baseline
'
)
"
)
;
newItem
-
>
mChildItems
.
SetLineBoundaryAtStart
(
true
)
;
newItem
-
>
mChildItems
.
SetLineBoundaryAtEnd
(
true
)
;
newItem
-
>
mChildItems
.
SetParentHasNoXBLChildren
(
aItems
.
ParentHasNoXBLChildren
(
)
)
;
iter
.
AppendItemsToList
(
this
endIter
newItem
-
>
mChildItems
)
;
iter
.
InsertItem
(
newItem
)
;
}
while
(
!
iter
.
IsDone
(
)
)
;
}
nsCSSFrameConstructor
:
:
RubyWhitespaceType
nsCSSFrameConstructor
:
:
ComputeRubyWhitespaceType
(
StyleDisplay
aPrevDisplay
StyleDisplay
aNextDisplay
)
{
MOZ_ASSERT
(
nsStyleDisplay
:
:
IsRubyDisplayType
(
aPrevDisplay
)
&
&
nsStyleDisplay
:
:
IsRubyDisplayType
(
aNextDisplay
)
)
;
if
(
aPrevDisplay
=
=
aNextDisplay
&
&
(
aPrevDisplay
=
=
StyleDisplay
:
:
RubyBase
|
|
aPrevDisplay
=
=
StyleDisplay
:
:
RubyText
)
)
{
return
eRubyInterLeafWhitespace
;
}
if
(
aNextDisplay
=
=
StyleDisplay
:
:
RubyText
|
|
aNextDisplay
=
=
StyleDisplay
:
:
RubyTextContainer
)
{
return
eRubyInterLevelWhitespace
;
}
return
eRubyInterSegmentWhitespace
;
}
nsCSSFrameConstructor
:
:
RubyWhitespaceType
nsCSSFrameConstructor
:
:
InterpretRubyWhitespace
(
nsFrameConstructorState
&
aState
const
FCItemIterator
&
aStartIter
const
FCItemIterator
&
aEndIter
)
{
if
(
!
aStartIter
.
item
(
)
.
IsWhitespace
(
aState
)
)
{
return
eRubyNotWhitespace
;
}
FCItemIterator
spaceEndIter
(
aStartIter
)
;
spaceEndIter
.
SkipWhitespace
(
aState
)
;
if
(
spaceEndIter
!
=
aEndIter
)
{
return
eRubyNotWhitespace
;
}
MOZ_ASSERT
(
!
aStartIter
.
AtStart
(
)
&
&
!
aEndIter
.
IsDone
(
)
)
;
FCItemIterator
prevIter
(
aStartIter
)
;
prevIter
.
Prev
(
)
;
return
ComputeRubyWhitespaceType
(
prevIter
.
item
(
)
.
mComputedStyle
-
>
StyleDisplay
(
)
-
>
mDisplay
aEndIter
.
item
(
)
.
mComputedStyle
-
>
StyleDisplay
(
)
-
>
mDisplay
)
;
}
void
nsCSSFrameConstructor
:
:
WrapItemsInPseudoRubyLeafBox
(
FCItemIterator
&
aIter
ComputedStyle
*
aParentStyle
nsIContent
*
aParentContent
)
{
StyleDisplay
parentDisplay
=
aParentStyle
-
>
StyleDisplay
(
)
-
>
mDisplay
;
ParentType
parentType
wrapperType
;
if
(
parentDisplay
=
=
StyleDisplay
:
:
RubyTextContainer
)
{
parentType
=
eTypeRubyTextContainer
;
wrapperType
=
eTypeRubyText
;
}
else
{
MOZ_ASSERT
(
parentDisplay
=
=
StyleDisplay
:
:
RubyBaseContainer
)
;
parentType
=
eTypeRubyBaseContainer
;
wrapperType
=
eTypeRubyBase
;
}
MOZ_ASSERT
(
aIter
.
item
(
)
.
DesiredParentType
(
)
!
=
parentType
"
Should
point
to
something
needs
to
be
wrapped
.
"
)
;
FCItemIterator
endIter
(
aIter
)
;
endIter
.
SkipItemsNotWantingParentType
(
parentType
)
;
WrapItemsInPseudoParent
(
aParentContent
aParentStyle
wrapperType
aIter
endIter
)
;
}
void
nsCSSFrameConstructor
:
:
WrapItemsInPseudoRubyLevelContainer
(
nsFrameConstructorState
&
aState
FCItemIterator
&
aIter
ComputedStyle
*
aParentStyle
nsIContent
*
aParentContent
)
{
MOZ_ASSERT
(
aIter
.
item
(
)
.
DesiredParentType
(
)
!
=
eTypeRuby
"
Pointing
to
a
level
container
?
"
)
;
FrameConstructionItem
&
firstItem
=
aIter
.
item
(
)
;
ParentType
wrapperType
=
firstItem
.
DesiredParentType
(
)
;
if
(
wrapperType
!
=
eTypeRubyTextContainer
)
{
wrapperType
=
eTypeRubyBaseContainer
;
}
FCItemIterator
endIter
(
aIter
)
;
do
{
if
(
endIter
.
SkipItemsWantingParentType
(
wrapperType
)
|
|
IsRubyParentType
(
endIter
.
item
(
)
.
DesiredParentType
(
)
)
)
{
break
;
}
FCItemIterator
contentEndIter
(
endIter
)
;
contentEndIter
.
SkipItemsNotWantingRubyParent
(
)
;
MOZ_ASSERT
(
contentEndIter
!
=
endIter
)
;
RubyWhitespaceType
whitespaceType
=
InterpretRubyWhitespace
(
aState
endIter
contentEndIter
)
;
if
(
whitespaceType
=
=
eRubyInterLevelWhitespace
)
{
bool
atStart
=
(
aIter
=
=
endIter
)
;
endIter
.
DeleteItemsTo
(
this
contentEndIter
)
;
if
(
atStart
)
{
aIter
=
endIter
;
}
}
else
if
(
whitespaceType
=
=
eRubyInterSegmentWhitespace
)
{
if
(
aIter
=
=
endIter
)
{
MOZ_ASSERT
(
wrapperType
=
=
eTypeRubyBaseContainer
"
Inter
-
segment
whitespace
should
be
wrapped
in
rbc
"
)
;
endIter
=
contentEndIter
;
}
break
;
}
else
if
(
wrapperType
=
=
eTypeRubyTextContainer
&
&
whitespaceType
!
=
eRubyInterLeafWhitespace
)
{
break
;
}
else
{
endIter
=
contentEndIter
;
}
}
while
(
!
endIter
.
IsDone
(
)
)
;
if
(
aIter
!
=
endIter
)
{
WrapItemsInPseudoParent
(
aParentContent
aParentStyle
wrapperType
aIter
endIter
)
;
}
}
void
nsCSSFrameConstructor
:
:
TrimLeadingAndTrailingWhitespaces
(
nsFrameConstructorState
&
aState
FrameConstructionItemList
&
aItems
)
{
FCItemIterator
iter
(
aItems
)
;
if
(
!
iter
.
IsDone
(
)
&
&
iter
.
item
(
)
.
IsWhitespace
(
aState
)
)
{
FCItemIterator
spaceEndIter
(
iter
)
;
spaceEndIter
.
SkipWhitespace
(
aState
)
;
iter
.
DeleteItemsTo
(
this
spaceEndIter
)
;
}
iter
.
SetToEnd
(
)
;
if
(
!
iter
.
AtStart
(
)
)
{
FCItemIterator
spaceEndIter
(
iter
)
;
do
{
iter
.
Prev
(
)
;
if
(
iter
.
AtStart
(
)
)
{
break
;
}
}
while
(
iter
.
item
(
)
.
IsWhitespace
(
aState
)
)
;
iter
.
Next
(
)
;
if
(
iter
!
=
spaceEndIter
)
{
iter
.
DeleteItemsTo
(
this
spaceEndIter
)
;
}
}
}
void
nsCSSFrameConstructor
:
:
CreateNeededPseudoInternalRubyBoxes
(
nsFrameConstructorState
&
aState
FrameConstructionItemList
&
aItems
nsIFrame
*
aParentFrame
)
{
const
ParentType
ourParentType
=
GetParentType
(
aParentFrame
)
;
if
(
!
IsRubyParentType
(
ourParentType
)
|
|
aItems
.
AllWantParentType
(
ourParentType
)
)
{
return
;
}
if
(
!
IsRubyPseudo
(
aParentFrame
)
)
{
TrimLeadingAndTrailingWhitespaces
(
aState
aItems
)
;
}
FCItemIterator
iter
(
aItems
)
;
nsIContent
*
parentContent
=
aParentFrame
-
>
GetContent
(
)
;
ComputedStyle
*
parentStyle
=
aParentFrame
-
>
Style
(
)
;
while
(
!
iter
.
IsDone
(
)
)
{
if
(
!
iter
.
SkipItemsWantingParentType
(
ourParentType
)
)
{
if
(
ourParentType
=
=
eTypeRuby
)
{
WrapItemsInPseudoRubyLevelContainer
(
aState
iter
parentStyle
parentContent
)
;
}
else
{
WrapItemsInPseudoRubyLeafBox
(
iter
parentStyle
parentContent
)
;
}
}
}
}
void
nsCSSFrameConstructor
:
:
CreateNeededPseudoContainers
(
nsFrameConstructorState
&
aState
FrameConstructionItemList
&
aItems
nsIFrame
*
aParentFrame
)
{
ParentType
ourParentType
=
GetParentType
(
aParentFrame
)
;
if
(
IsRubyParentType
(
ourParentType
)
|
|
aItems
.
AllWantParentType
(
ourParentType
)
)
{
return
;
}
FCItemIterator
iter
(
aItems
)
;
do
{
if
(
iter
.
SkipItemsWantingParentType
(
ourParentType
)
)
{
return
;
}
FCItemIterator
endIter
(
iter
)
;
ParentType
groupingParentType
=
endIter
.
item
(
)
.
DesiredParentType
(
)
;
if
(
aItems
.
AllWantParentType
(
groupingParentType
)
&
&
groupingParentType
!
=
eTypeBlock
)
{
endIter
.
SetToEnd
(
)
;
}
else
{
ParentType
prevParentType
=
ourParentType
;
do
{
FCItemIterator
spaceEndIter
(
endIter
)
;
if
(
prevParentType
!
=
eTypeBlock
&
&
!
aParentFrame
-
>
IsGeneratedContentFrame
(
)
&
&
spaceEndIter
.
item
(
)
.
IsWhitespace
(
aState
)
)
{
bool
trailingSpaces
=
spaceEndIter
.
SkipWhitespace
(
aState
)
;
if
(
(
!
trailingSpaces
&
&
IsTableParentType
(
spaceEndIter
.
item
(
)
.
DesiredParentType
(
)
)
)
|
|
(
trailingSpaces
&
&
ourParentType
!
=
eTypeBlock
)
)
{
bool
updateStart
=
(
iter
=
=
endIter
)
;
endIter
.
DeleteItemsTo
(
this
spaceEndIter
)
;
NS_ASSERTION
(
trailingSpaces
=
=
endIter
.
IsDone
(
)
"
These
should
match
"
)
;
if
(
updateStart
)
{
iter
=
endIter
;
}
if
(
trailingSpaces
)
{
break
;
}
if
(
updateStart
)
{
groupingParentType
=
iter
.
item
(
)
.
DesiredParentType
(
)
;
}
}
}
prevParentType
=
endIter
.
item
(
)
.
DesiredParentType
(
)
;
if
(
prevParentType
=
=
ourParentType
&
&
(
endIter
=
=
spaceEndIter
|
|
spaceEndIter
.
IsDone
(
)
|
|
!
IsRubyParentType
(
groupingParentType
)
|
|
!
IsRubyParentType
(
spaceEndIter
.
item
(
)
.
DesiredParentType
(
)
)
)
)
{
break
;
}
if
(
ourParentType
=
=
eTypeTable
&
&
(
prevParentType
=
=
eTypeColGroup
)
!
=
(
groupingParentType
=
=
eTypeColGroup
)
)
{
break
;
}
if
(
spaceEndIter
!
=
endIter
&
&
!
spaceEndIter
.
IsDone
(
)
&
&
ourParentType
=
=
spaceEndIter
.
item
(
)
.
DesiredParentType
(
)
)
{
endIter
=
spaceEndIter
;
break
;
}
endIter
=
spaceEndIter
;
prevParentType
=
endIter
.
item
(
)
.
DesiredParentType
(
)
;
endIter
.
Next
(
)
;
}
while
(
!
endIter
.
IsDone
(
)
)
;
}
if
(
iter
=
=
endIter
)
{
continue
;
}
ParentType
wrapperType
;
switch
(
ourParentType
)
{
case
eTypeRow
:
wrapperType
=
eTypeBlock
;
break
;
case
eTypeRowGroup
:
wrapperType
=
eTypeRow
;
break
;
case
eTypeTable
:
wrapperType
=
groupingParentType
=
=
eTypeColGroup
?
eTypeColGroup
:
eTypeRowGroup
;
break
;
case
eTypeColGroup
:
MOZ_CRASH
(
"
Colgroups
should
be
suppresing
non
-
col
child
items
"
)
;
default
:
NS_ASSERTION
(
ourParentType
=
=
eTypeBlock
"
Unrecognized
parent
type
"
)
;
if
(
IsRubyParentType
(
groupingParentType
)
)
{
wrapperType
=
eTypeRuby
;
}
else
{
NS_ASSERTION
(
IsTableParentType
(
groupingParentType
)
"
groupingParentType
should
be
either
Ruby
or
table
"
)
;
wrapperType
=
eTypeTable
;
}
}
ComputedStyle
*
parentStyle
=
aParentFrame
-
>
Style
(
)
;
WrapItemsInPseudoParent
(
aParentFrame
-
>
GetContent
(
)
parentStyle
wrapperType
iter
endIter
)
;
}
while
(
!
iter
.
IsDone
(
)
)
;
}
void
nsCSSFrameConstructor
:
:
WrapItemsInPseudoParent
(
nsIContent
*
aParentContent
ComputedStyle
*
aParentStyle
ParentType
aWrapperType
FCItemIterator
&
aIter
const
FCItemIterator
&
aEndIter
)
{
const
PseudoParentData
&
pseudoData
=
sPseudoParentData
[
aWrapperType
]
;
nsCSSAnonBoxPseudoStaticAtom
*
pseudoType
=
pseudoData
.
mPseudoType
;
StyleDisplay
parentDisplay
=
aParentStyle
-
>
StyleDisplay
(
)
-
>
mDisplay
;
if
(
pseudoType
=
=
nsCSSAnonBoxes
:
:
table
(
)
&
&
(
parentDisplay
=
=
StyleDisplay
:
:
Inline
|
|
parentDisplay
=
=
StyleDisplay
:
:
RubyBase
|
|
parentDisplay
=
=
StyleDisplay
:
:
RubyText
)
)
{
pseudoType
=
nsCSSAnonBoxes
:
:
inlineTable
(
)
;
}
RefPtr
<
ComputedStyle
>
wrapperStyle
;
if
(
pseudoData
.
mFCData
.
mBits
&
FCDATA_IS_WRAPPER_ANON_BOX
)
{
wrapperStyle
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveInheritingAnonymousBoxStyle
(
pseudoType
aParentStyle
)
;
}
else
{
wrapperStyle
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveNonInheritingAnonymousBoxStyle
(
pseudoType
)
;
}
FrameConstructionItem
*
newItem
=
new
(
this
)
FrameConstructionItem
(
&
pseudoData
.
mFCData
aParentContent
nullptr
wrapperStyle
.
forget
(
)
true
)
;
const
nsStyleDisplay
*
disp
=
newItem
-
>
mComputedStyle
-
>
StyleDisplay
(
)
;
newItem
-
>
mIsAllInline
=
disp
-
>
IsInlineOutsideStyle
(
)
;
bool
isRuby
=
disp
-
>
IsRubyDisplayType
(
)
;
newItem
-
>
mIsLineParticipant
=
isRuby
;
if
(
!
isRuby
)
{
newItem
-
>
mChildItems
.
SetLineBoundaryAtStart
(
true
)
;
newItem
-
>
mChildItems
.
SetLineBoundaryAtEnd
(
true
)
;
}
newItem
-
>
mChildItems
.
SetParentHasNoXBLChildren
(
aIter
.
List
(
)
-
>
ParentHasNoXBLChildren
(
)
)
;
aIter
.
AppendItemsToList
(
this
aEndIter
newItem
-
>
mChildItems
)
;
aIter
.
InsertItem
(
newItem
)
;
}
void
nsCSSFrameConstructor
:
:
CreateNeededPseudoSiblings
(
nsFrameConstructorState
&
aState
FrameConstructionItemList
&
aItems
nsIFrame
*
aParentFrame
)
{
if
(
aItems
.
IsEmpty
(
)
|
|
GetParentType
(
aParentFrame
)
!
=
eTypeRuby
)
{
return
;
}
FCItemIterator
iter
(
aItems
)
;
StyleDisplay
firstDisplay
=
iter
.
item
(
)
.
mComputedStyle
-
>
StyleDisplay
(
)
-
>
mDisplay
;
if
(
firstDisplay
=
=
StyleDisplay
:
:
RubyBaseContainer
)
{
return
;
}
NS_ASSERTION
(
firstDisplay
=
=
StyleDisplay
:
:
RubyTextContainer
"
Child
of
ruby
frame
should
either
a
rbc
or
a
rtc
"
)
;
const
PseudoParentData
&
pseudoData
=
sPseudoParentData
[
eTypeRubyBaseContainer
]
;
RefPtr
<
ComputedStyle
>
pseudoStyle
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveInheritingAnonymousBoxStyle
(
pseudoData
.
mPseudoType
aParentFrame
-
>
Style
(
)
)
;
FrameConstructionItem
*
newItem
=
new
(
this
)
FrameConstructionItem
(
&
pseudoData
.
mFCData
aParentFrame
-
>
GetContent
(
)
nullptr
pseudoStyle
.
forget
(
)
true
)
;
newItem
-
>
mIsAllInline
=
true
;
newItem
-
>
mChildItems
.
SetParentHasNoXBLChildren
(
true
)
;
iter
.
InsertItem
(
newItem
)
;
}
#
ifdef
DEBUG
static
bool
FrameWantsToBeInAnonymousItem
(
const
nsIFrame
*
aContainerFrame
const
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aContainerFrame
-
>
IsFlexOrGridContainer
(
)
)
;
if
(
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eLineParticipant
)
)
{
return
true
;
}
if
(
IsFlexContainerForLegacyBox
(
aContainerFrame
)
&
&
aFrame
-
>
IsPlaceholderFrame
(
)
)
{
return
true
;
}
return
false
;
}
#
endif
static
void
VerifyGridFlexContainerChildren
(
nsIFrame
*
aParentFrame
const
nsFrameList
&
aChildren
)
{
#
ifdef
DEBUG
if
(
!
aParentFrame
-
>
IsFlexOrGridContainer
(
)
)
{
return
;
}
bool
prevChildWasAnonItem
=
false
;
for
(
const
nsIFrame
*
child
:
aChildren
)
{
MOZ_ASSERT
(
!
FrameWantsToBeInAnonymousItem
(
aParentFrame
child
)
"
frame
wants
to
be
inside
an
anonymous
item
but
it
isn
'
t
"
)
;
if
(
IsAnonymousFlexOrGridItem
(
child
)
)
{
AssertAnonymousFlexOrGridItemParent
(
child
aParentFrame
)
;
MOZ_ASSERT
(
!
prevChildWasAnonItem
"
two
anon
items
in
a
row
"
)
;
nsIFrame
*
firstWrappedChild
=
child
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
MOZ_ASSERT
(
firstWrappedChild
"
anonymous
item
shouldn
'
t
be
empty
"
)
;
prevChildWasAnonItem
=
true
;
}
else
{
prevChildWasAnonItem
=
false
;
}
}
#
endif
}
inline
void
nsCSSFrameConstructor
:
:
ConstructFramesFromItemList
(
nsFrameConstructorState
&
aState
FrameConstructionItemList
&
aItems
nsContainerFrame
*
aParentFrame
bool
aParentIsWrapperAnonBox
nsFrameItems
&
aFrameItems
)
{
MOZ_ASSERT
(
ParentIsWrapperAnonBox
(
aParentFrame
)
=
=
aParentIsWrapperAnonBox
)
;
CreateNeededPseudoContainers
(
aState
aItems
aParentFrame
)
;
CreateNeededAnonFlexOrGridItems
(
aState
aItems
aParentFrame
)
;
CreateNeededPseudoInternalRubyBoxes
(
aState
aItems
aParentFrame
)
;
CreateNeededPseudoSiblings
(
aState
aItems
aParentFrame
)
;
for
(
FCItemIterator
iter
(
aItems
)
;
!
iter
.
IsDone
(
)
;
iter
.
Next
(
)
)
{
NS_ASSERTION
(
iter
.
item
(
)
.
DesiredParentType
(
)
=
=
GetParentType
(
aParentFrame
)
"
Needed
pseudos
didn
'
t
get
created
;
expect
bad
things
"
)
;
ConstructFramesFromItem
(
aState
iter
aParentFrame
aFrameItems
)
;
}
VerifyGridFlexContainerChildren
(
aParentFrame
aFrameItems
)
;
NS_ASSERTION
(
!
aState
.
mHavePendingPopupgroup
"
Should
have
proccessed
it
by
now
"
)
;
if
(
aParentIsWrapperAnonBox
)
{
for
(
nsIFrame
*
f
:
aFrameItems
)
{
f
-
>
SetParentIsWrapperAnonBox
(
)
;
}
}
}
void
nsCSSFrameConstructor
:
:
AddFCItemsForAnonymousContent
(
nsFrameConstructorState
&
aState
nsContainerFrame
*
aFrame
const
nsTArray
<
nsIAnonymousContentCreator
:
:
ContentInfo
>
&
aAnonymousItems
FrameConstructionItemList
&
aItemsToConstruct
uint32_t
aExtraFlags
)
{
for
(
const
auto
&
info
:
aAnonymousItems
)
{
nsIContent
*
content
=
info
.
mContent
;
MOZ_ASSERT
(
!
(
content
-
>
GetFlags
(
)
&
(
NODE_DESCENDANTS_NEED_FRAMES
|
NODE_NEEDS_FRAME
)
)
"
Should
not
be
marked
as
needing
frames
"
)
;
MOZ_ASSERT
(
!
content
-
>
GetPrimaryFrame
(
)
"
Should
have
no
existing
frame
"
)
;
MOZ_ASSERT
(
!
content
-
>
IsComment
(
)
&
&
!
content
-
>
IsProcessingInstruction
(
)
"
Why
is
someone
creating
garbage
anonymous
content
"
)
;
MOZ_ASSERT
(
!
content
-
>
IsElement
(
)
|
|
content
-
>
AsElement
(
)
-
>
HasServoData
(
)
)
;
RefPtr
<
ComputedStyle
>
computedStyle
=
ResolveComputedStyle
(
content
)
;
uint32_t
flags
=
ITEM_ALLOW_XBL_BASE
|
ITEM_ALLOW_PAGE_BREAK
|
ITEM_IS_ANONYMOUSCONTENTCREATOR_CONTENT
|
aExtraFlags
;
AddFrameConstructionItemsInternal
(
aState
content
aFrame
true
computedStyle
flags
aItemsToConstruct
)
;
}
}
void
nsCSSFrameConstructor
:
:
ProcessChildren
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
ComputedStyle
*
aComputedStyle
nsContainerFrame
*
aFrame
const
bool
aCanHaveGeneratedContent
nsFrameItems
&
aFrameItems
const
bool
aAllowBlockStyles
PendingBinding
*
aPendingBinding
nsIFrame
*
aPossiblyLeafFrame
)
{
MOZ_ASSERT
(
aFrame
"
Must
have
parent
frame
here
"
)
;
MOZ_ASSERT
(
aFrame
-
>
GetContentInsertionFrame
(
)
=
=
aFrame
"
Parent
frame
in
ProcessChildren
should
be
its
own
"
"
content
insertion
frame
"
)
;
const
uint32_t
kMaxDepth
=
2
*
MAX_REFLOW_DEPTH
;
static_assert
(
kMaxDepth
<
=
UINT16_MAX
"
mCurrentDepth
type
is
too
narrow
"
)
;
AutoRestore
<
uint16_t
>
savedDepth
(
mCurrentDepth
)
;
if
(
mCurrentDepth
!
=
UINT16_MAX
)
{
+
+
mCurrentDepth
;
}
if
(
!
aPossiblyLeafFrame
)
{
aPossiblyLeafFrame
=
aFrame
;
}
const
bool
allowFirstPseudos
=
aAllowBlockStyles
&
&
nsLayoutUtils
:
:
GetAsBlock
(
aFrame
)
;
bool
haveFirstLetterStyle
=
false
haveFirstLineStyle
=
false
;
if
(
allowFirstPseudos
)
{
ShouldHaveSpecialBlockStyle
(
aContent
aComputedStyle
&
haveFirstLetterStyle
&
haveFirstLineStyle
)
;
}
nsFrameConstructorSaveState
floatSaveState
;
if
(
ShouldSuppressFloatingOfDescendants
(
aFrame
)
)
{
aState
.
PushFloatContainingBlock
(
nullptr
floatSaveState
)
;
}
else
if
(
aFrame
-
>
IsFloatContainingBlock
(
)
)
{
aState
.
PushFloatContainingBlock
(
aFrame
floatSaveState
)
;
}
nsFrameConstructorState
:
:
PendingBindingAutoPusher
pusher
(
aState
aPendingBinding
)
;
AutoFrameConstructionItemList
itemsToConstruct
(
this
)
;
if
(
allowFirstPseudos
&
&
!
haveFirstLetterStyle
&
&
!
haveFirstLineStyle
)
{
itemsToConstruct
.
SetLineBoundaryAtStart
(
true
)
;
itemsToConstruct
.
SetLineBoundaryAtEnd
(
true
)
;
}
AutoTArray
<
nsIAnonymousContentCreator
:
:
ContentInfo
4
>
anonymousItems
;
GetAnonymousContent
(
aContent
aPossiblyLeafFrame
anonymousItems
)
;
#
ifdef
DEBUG
for
(
uint32_t
i
=
0
;
i
<
anonymousItems
.
Length
(
)
;
+
+
i
)
{
MOZ_ASSERT
(
anonymousItems
[
i
]
.
mContent
-
>
IsRootOfAnonymousSubtree
(
)
"
Content
should
know
it
'
s
an
anonymous
subtree
"
)
;
}
#
endif
AddFCItemsForAnonymousContent
(
aState
aFrame
anonymousItems
itemsToConstruct
)
;
if
(
!
aPossiblyLeafFrame
-
>
IsLeaf
(
)
)
{
ComputedStyle
*
computedStyle
;
if
(
aCanHaveGeneratedContent
)
{
computedStyle
=
nsFrame
:
:
CorrectStyleParentFrame
(
aFrame
nullptr
)
-
>
Style
(
)
;
CreateGeneratedContentItem
(
aState
aFrame
*
aContent
-
>
AsElement
(
)
*
computedStyle
CSSPseudoElementType
:
:
before
itemsToConstruct
)
;
}
const
bool
addChildItems
=
MOZ_LIKELY
(
mCurrentDepth
<
kMaxDepth
)
;
if
(
!
addChildItems
)
{
NS_WARNING
(
"
ProcessChildren
max
depth
exceeded
"
)
;
}
FlattenedChildIterator
iter
(
aContent
)
;
const
InsertionPoint
insertion
(
aFrame
aContent
)
;
for
(
nsIContent
*
child
=
iter
.
GetNextChild
(
)
;
child
;
child
=
iter
.
GetNextChild
(
)
)
{
MOZ_ASSERT
(
insertion
.
mContainer
=
=
GetInsertionPoint
(
child
)
.
mContainer
"
GetInsertionPoint
should
agree
with
us
"
)
;
if
(
addChildItems
)
{
AddFrameConstructionItems
(
aState
child
iter
.
XBLInvolved
(
)
insertion
itemsToConstruct
)
;
}
else
{
ClearLazyBits
(
child
child
-
>
GetNextSibling
(
)
)
;
}
}
itemsToConstruct
.
SetParentHasNoXBLChildren
(
!
iter
.
XBLInvolved
(
)
)
;
if
(
aCanHaveGeneratedContent
)
{
CreateGeneratedContentItem
(
aState
aFrame
*
aContent
-
>
AsElement
(
)
*
computedStyle
CSSPseudoElementType
:
:
after
itemsToConstruct
)
;
}
}
else
{
ClearLazyBits
(
aContent
-
>
GetFirstChild
(
)
nullptr
)
;
}
ConstructFramesFromItemList
(
aState
itemsToConstruct
aFrame
false
aFrameItems
)
;
NS_ASSERTION
(
!
allowFirstPseudos
|
|
!
aFrame
-
>
IsXULBoxFrame
(
)
"
can
'
t
be
both
block
and
box
"
)
;
if
(
haveFirstLetterStyle
)
{
WrapFramesInFirstLetterFrame
(
aFrame
aFrameItems
)
;
}
if
(
haveFirstLineStyle
)
{
WrapFramesInFirstLineFrame
(
aState
aContent
aFrame
nullptr
aFrameItems
)
;
}
NS_ASSERTION
(
!
haveFirstLineStyle
|
|
!
aFrame
-
>
IsXULBoxFrame
(
)
"
Shouldn
'
t
have
first
-
line
style
if
we
'
re
a
box
"
)
;
NS_ASSERTION
(
!
aFrame
-
>
IsXULBoxFrame
(
)
|
|
itemsToConstruct
.
AnyItemsNeedBlockParent
(
)
=
=
(
AnyKidsNeedBlockParent
(
aFrameItems
.
FirstChild
(
)
)
!
=
nullptr
)
"
Something
went
awry
in
our
block
parent
calculations
"
)
;
if
(
aFrame
-
>
IsXULBoxFrame
(
)
&
&
itemsToConstruct
.
AnyItemsNeedBlockParent
(
)
)
{
ComputedStyle
*
frameComputedStyle
=
aFrame
-
>
Style
(
)
;
if
(
!
aFrame
-
>
IsGeneratedContentFrame
(
)
&
&
mPresShell
-
>
GetPresContext
(
)
-
>
IsChrome
(
)
)
{
nsIContent
*
badKid
=
AnyKidsNeedBlockParent
(
aFrameItems
.
FirstChild
(
)
)
;
nsDependentAtomString
parentTag
(
aContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
kidTag
(
badKid
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
;
const
char16_t
*
params
[
]
=
{
parentTag
.
get
(
)
kidTag
.
get
(
)
}
;
const
nsStyleDisplay
*
display
=
frameComputedStyle
-
>
StyleDisplay
(
)
;
const
char
*
message
=
(
display
-
>
mDisplay
=
=
StyleDisplay
:
:
MozInlineBox
)
?
"
NeededToWrapXULInlineBox
"
:
"
NeededToWrapXUL
"
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
Layout
:
FrameConstructor
"
)
mDocument
nsContentUtils
:
:
eXUL_PROPERTIES
message
params
ArrayLength
(
params
)
)
;
}
RefPtr
<
ComputedStyle
>
blockSC
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveInheritingAnonymousBoxStyle
(
nsCSSAnonBoxes
:
:
mozXULAnonymousBlock
(
)
frameComputedStyle
)
;
nsBlockFrame
*
blockFrame
=
NS_NewBlockFrame
(
mPresShell
blockSC
)
;
InitAndRestoreFrame
(
aState
aContent
aFrame
blockFrame
false
)
;
NS_ASSERTION
(
!
blockFrame
-
>
HasView
(
)
"
need
to
do
view
reparenting
"
)
;
ReparentFrames
(
this
blockFrame
aFrameItems
false
)
;
blockFrame
-
>
SetInitialChildList
(
kPrincipalList
aFrameItems
)
;
NS_ASSERTION
(
aFrameItems
.
IsEmpty
(
)
"
How
did
that
happen
?
"
)
;
aFrameItems
.
Clear
(
)
;
aFrameItems
.
AddChild
(
blockFrame
)
;
aFrame
-
>
AddStateBits
(
NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK
)
;
MOZ_ASSERT
(
!
aFrame
-
>
IsLeaf
(
)
"
Why
do
we
have
an
nsLeafBoxFrame
here
?
"
)
;
aFrame
-
>
AddStateBits
(
NS_FRAME_OWNS_ANON_BOXES
)
;
}
}
void
nsCSSFrameConstructor
:
:
WrapFramesInFirstLineFrame
(
nsFrameConstructorState
&
aState
nsIContent
*
aBlockContent
nsContainerFrame
*
aBlockFrame
nsFirstLineFrame
*
aLineFrame
nsFrameItems
&
aFrameItems
)
{
nsFrameList
firstLineChildren
=
aFrameItems
.
Split
(
[
]
(
nsIFrame
*
f
)
{
return
!
f
-
>
IsInlineOutside
(
)
;
}
)
;
if
(
firstLineChildren
.
IsEmpty
(
)
)
{
return
;
}
if
(
!
aLineFrame
)
{
ComputedStyle
*
parentStyle
=
nsFrame
:
:
CorrectStyleParentFrame
(
aBlockFrame
nsCSSPseudoElements
:
:
firstLine
(
)
)
-
>
Style
(
)
;
RefPtr
<
ComputedStyle
>
firstLineStyle
=
GetFirstLineStyle
(
aBlockContent
parentStyle
)
;
aLineFrame
=
NS_NewFirstLineFrame
(
mPresShell
firstLineStyle
)
;
InitAndRestoreFrame
(
aState
aBlockContent
aBlockFrame
aLineFrame
)
;
aFrameItems
.
InsertFrame
(
nullptr
nullptr
aLineFrame
)
;
NS_ASSERTION
(
aLineFrame
-
>
Style
(
)
=
=
firstLineStyle
"
Bogus
style
on
line
frame
"
)
;
}
ReparentFrames
(
this
aLineFrame
firstLineChildren
true
)
;
if
(
aLineFrame
-
>
PrincipalChildList
(
)
.
IsEmpty
(
)
&
&
(
aLineFrame
-
>
GetStateBits
(
)
&
NS_FRAME_FIRST_REFLOW
)
)
{
aLineFrame
-
>
SetInitialChildList
(
kPrincipalList
firstLineChildren
)
;
}
else
{
AppendFrames
(
aLineFrame
kPrincipalList
firstLineChildren
)
;
}
}
void
nsCSSFrameConstructor
:
:
AppendFirstLineFrames
(
nsFrameConstructorState
&
aState
nsIContent
*
aBlockContent
nsContainerFrame
*
aBlockFrame
nsFrameItems
&
aFrameItems
)
{
const
nsFrameList
&
blockKids
=
aBlockFrame
-
>
PrincipalChildList
(
)
;
if
(
blockKids
.
IsEmpty
(
)
)
{
WrapFramesInFirstLineFrame
(
aState
aBlockContent
aBlockFrame
nullptr
aFrameItems
)
;
return
;
}
nsIFrame
*
lastBlockKid
=
blockKids
.
LastChild
(
)
;
if
(
!
lastBlockKid
-
>
IsLineFrame
(
)
)
{
return
;
}
nsFirstLineFrame
*
lineFrame
=
static_cast
<
nsFirstLineFrame
*
>
(
lastBlockKid
)
;
WrapFramesInFirstLineFrame
(
aState
aBlockContent
aBlockFrame
lineFrame
aFrameItems
)
;
}
void
nsCSSFrameConstructor
:
:
CheckForFirstLineInsertion
(
nsIFrame
*
aParentFrame
nsFrameItems
&
aFrameItems
)
{
MOZ_ASSERT
(
aParentFrame
-
>
Style
(
)
-
>
HasPseudoElementData
(
)
"
Why
were
we
called
?
"
)
;
if
(
aFrameItems
.
IsEmpty
(
)
)
{
return
;
}
class
RestyleManager
*
restyleManager
=
RestyleManager
(
)
;
nsIFrame
*
ancestor
=
aParentFrame
;
while
(
ancestor
)
{
if
(
!
ancestor
-
>
Style
(
)
-
>
HasPseudoElementData
(
)
)
{
return
;
}
if
(
!
ancestor
-
>
IsLineFrame
(
)
)
{
ancestor
=
ancestor
-
>
GetParent
(
)
;
continue
;
}
if
(
!
ancestor
-
>
Style
(
)
-
>
IsPseudoElement
(
)
)
{
return
;
}
for
(
nsIFrame
*
f
:
aFrameItems
)
{
restyleManager
-
>
ReparentComputedStyleForFirstLine
(
f
)
;
}
return
;
}
}
static
int32_t
FirstLetterCount
(
const
nsTextFragment
*
aFragment
)
{
int32_t
count
=
0
;
int32_t
firstLetterLength
=
0
;
int32_t
i
n
=
aFragment
-
>
GetLength
(
)
;
for
(
i
=
0
;
i
<
n
;
i
+
+
)
{
char16_t
ch
=
aFragment
-
>
CharAt
(
i
)
;
if
(
dom
:
:
IsSpaceCharacter
(
ch
)
)
{
if
(
firstLetterLength
)
{
break
;
}
count
+
+
;
continue
;
}
if
(
(
ch
=
=
'
\
'
'
)
|
|
(
ch
=
=
'
\
"
'
)
)
{
if
(
firstLetterLength
)
{
break
;
}
firstLetterLength
=
1
;
}
else
{
count
+
+
;
break
;
}
}
return
count
;
}
static
bool
NeedFirstLetterContinuation
(
nsIContent
*
aContent
)
{
MOZ_ASSERT
(
aContent
"
null
ptr
"
)
;
bool
result
=
false
;
if
(
aContent
)
{
const
nsTextFragment
*
frag
=
aContent
-
>
GetText
(
)
;
if
(
frag
)
{
int32_t
flc
=
FirstLetterCount
(
frag
)
;
int32_t
tl
=
frag
-
>
GetLength
(
)
;
if
(
flc
<
tl
)
{
result
=
true
;
}
}
}
return
result
;
}
static
bool
IsFirstLetterContent
(
nsIContent
*
aContent
)
{
return
aContent
-
>
TextLength
(
)
&
&
!
aContent
-
>
TextIsOnlyWhitespace
(
)
;
}
nsFirstLetterFrame
*
nsCSSFrameConstructor
:
:
CreateFloatingLetterFrame
(
nsFrameConstructorState
&
aState
nsIContent
*
aTextContent
nsIFrame
*
aTextFrame
nsContainerFrame
*
aParentFrame
ComputedStyle
*
aParentComputedStyle
ComputedStyle
*
aComputedStyle
nsFrameItems
&
aResult
)
{
MOZ_ASSERT
(
aParentComputedStyle
)
;
nsFirstLetterFrame
*
letterFrame
=
NS_NewFirstLetterFrame
(
mPresShell
aComputedStyle
)
;
nsIContent
*
letterContent
=
aParentFrame
-
>
GetContent
(
)
;
nsContainerFrame
*
containingBlock
=
aState
.
GetGeometricParent
(
*
aComputedStyle
-
>
StyleDisplay
(
)
aParentFrame
)
;
InitAndRestoreFrame
(
aState
letterContent
containingBlock
letterFrame
)
;
ServoStyleSet
*
styleSet
=
mPresShell
-
>
StyleSet
(
)
;
RefPtr
<
ComputedStyle
>
textSC
=
styleSet
-
>
ResolveStyleForText
(
aTextContent
aComputedStyle
)
;
aTextFrame
-
>
SetComputedStyleWithoutNotification
(
textSC
)
;
InitAndRestoreFrame
(
aState
aTextContent
letterFrame
aTextFrame
)
;
SetInitialSingleChild
(
letterFrame
aTextFrame
)
;
nsIFrame
*
nextTextFrame
=
nullptr
;
if
(
NeedFirstLetterContinuation
(
aTextContent
)
)
{
nextTextFrame
=
CreateContinuingFrame
(
aState
.
mPresContext
aTextFrame
aParentFrame
)
;
RefPtr
<
ComputedStyle
>
newSC
=
styleSet
-
>
ResolveStyleForText
(
aTextContent
aParentComputedStyle
)
;
nextTextFrame
-
>
SetComputedStyle
(
newSC
)
;
}
NS_ASSERTION
(
aResult
.
IsEmpty
(
)
"
aResult
should
be
an
empty
nsFrameItems
!
"
)
;
nsFrameList
:
:
FrameLinkEnumerator
link
(
aState
.
mFloatedItems
)
;
while
(
!
link
.
AtEnd
(
)
&
&
link
.
NextFrame
(
)
-
>
GetParent
(
)
!
=
containingBlock
)
{
link
.
Next
(
)
;
}
aState
.
AddChild
(
letterFrame
aResult
letterContent
aParentFrame
false
true
false
true
link
.
PrevFrame
(
)
)
;
if
(
nextTextFrame
)
{
aResult
.
AddChild
(
nextTextFrame
)
;
}
return
letterFrame
;
}
void
nsCSSFrameConstructor
:
:
CreateLetterFrame
(
nsContainerFrame
*
aBlockFrame
nsContainerFrame
*
aBlockContinuation
nsIContent
*
aTextContent
nsContainerFrame
*
aParentFrame
nsFrameItems
&
aResult
)
{
MOZ_ASSERT
(
aTextContent
-
>
IsText
(
)
"
aTextContent
isn
'
t
text
"
)
;
NS_ASSERTION
(
nsLayoutUtils
:
:
GetAsBlock
(
aBlockFrame
)
"
Not
a
block
frame
?
"
)
;
nsIFrame
*
parentFrame
=
nsFrame
:
:
CorrectStyleParentFrame
(
aParentFrame
nsCSSPseudoElements
:
:
firstLetter
(
)
)
;
ComputedStyle
*
parentComputedStyle
=
parentFrame
-
>
Style
(
)
;
nsIContent
*
blockContent
=
aBlockFrame
-
>
GetContent
(
)
;
RefPtr
<
ComputedStyle
>
sc
=
GetFirstLetterStyle
(
blockContent
parentComputedStyle
)
;
if
(
sc
)
{
if
(
parentFrame
-
>
IsLineFrame
(
)
)
{
nsIFrame
*
parentIgnoringFirstLine
=
nsFrame
:
:
CorrectStyleParentFrame
(
aBlockFrame
nsCSSPseudoElements
:
:
firstLetter
(
)
)
;
sc
=
mPresShell
-
>
StyleSet
(
)
-
>
ReparentComputedStyle
(
sc
parentComputedStyle
parentIgnoringFirstLine
-
>
Style
(
)
parentComputedStyle
blockContent
-
>
AsElement
(
)
)
;
}
RefPtr
<
ComputedStyle
>
textSC
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveStyleForText
(
aTextContent
sc
)
;
aTextContent
-
>
SetPrimaryFrame
(
nullptr
)
;
nsIFrame
*
textFrame
=
NS_NewTextFrame
(
mPresShell
textSC
)
;
NS_ASSERTION
(
aBlockContinuation
=
=
GetFloatContainingBlock
(
aParentFrame
)
"
Containing
block
is
confused
"
)
;
nsFrameConstructorState
state
(
mPresShell
GetAbsoluteContainingBlock
(
aParentFrame
FIXED_POS
)
GetAbsoluteContainingBlock
(
aParentFrame
ABS_POS
)
aBlockContinuation
)
;
const
nsStyleDisplay
*
display
=
sc
-
>
StyleDisplay
(
)
;
nsFirstLetterFrame
*
letterFrame
;
if
(
display
-
>
IsFloatingStyle
(
)
&
&
!
nsSVGUtils
:
:
IsInSVGTextSubtree
(
aParentFrame
)
)
{
letterFrame
=
CreateFloatingLetterFrame
(
state
aTextContent
textFrame
aParentFrame
parentComputedStyle
sc
aResult
)
;
}
else
{
letterFrame
=
NS_NewFirstLetterFrame
(
mPresShell
sc
)
;
nsIContent
*
letterContent
=
aParentFrame
-
>
GetContent
(
)
;
letterFrame
-
>
Init
(
letterContent
aParentFrame
nullptr
)
;
InitAndRestoreFrame
(
state
aTextContent
letterFrame
textFrame
)
;
SetInitialSingleChild
(
letterFrame
textFrame
)
;
aResult
.
Clear
(
)
;
aResult
.
AddChild
(
letterFrame
)
;
NS_ASSERTION
(
!
aBlockFrame
-
>
GetPrevContinuation
(
)
"
should
have
the
first
continuation
here
"
)
;
aBlockFrame
-
>
AddStateBits
(
NS_BLOCK_HAS_FIRST_LETTER_CHILD
)
;
}
MOZ_ASSERT
(
!
aBlockFrame
-
>
GetPrevContinuation
(
)
"
Setting
up
a
first
-
letter
frame
on
a
non
-
first
block
continuation
?
"
)
;
auto
parent
=
static_cast
<
nsContainerFrame
*
>
(
aParentFrame
-
>
FirstContinuation
(
)
)
;
if
(
MOZ_UNLIKELY
(
parent
-
>
IsLineFrame
(
)
)
)
{
parent
=
static_cast
<
nsContainerFrame
*
>
(
parent
-
>
GetParent
(
)
-
>
FirstContinuation
(
)
)
;
}
parent
-
>
SetHasFirstLetterChild
(
)
;
aBlockFrame
-
>
SetProperty
(
nsContainerFrame
:
:
FirstLetterProperty
(
)
letterFrame
)
;
aTextContent
-
>
SetPrimaryFrame
(
textFrame
)
;
}
}
void
nsCSSFrameConstructor
:
:
WrapFramesInFirstLetterFrame
(
nsContainerFrame
*
aBlockFrame
nsFrameItems
&
aBlockFrames
)
{
aBlockFrame
-
>
AddStateBits
(
NS_BLOCK_HAS_FIRST_LETTER_STYLE
)
;
nsContainerFrame
*
parentFrame
=
nullptr
;
nsIFrame
*
textFrame
=
nullptr
;
nsIFrame
*
prevFrame
=
nullptr
;
nsFrameItems
letterFrames
;
bool
stopLooking
=
false
;
WrapFramesInFirstLetterFrame
(
aBlockFrame
aBlockFrame
aBlockFrame
aBlockFrames
.
FirstChild
(
)
&
parentFrame
&
textFrame
&
prevFrame
letterFrames
&
stopLooking
)
;
if
(
parentFrame
)
{
if
(
parentFrame
=
=
aBlockFrame
)
{
aBlockFrames
.
DestroyFrame
(
textFrame
)
;
aBlockFrames
.
InsertFrames
(
nullptr
prevFrame
letterFrames
)
;
}
else
{
RemoveFrame
(
kPrincipalList
textFrame
)
;
parentFrame
-
>
InsertFrames
(
kPrincipalList
prevFrame
letterFrames
)
;
}
}
}
void
nsCSSFrameConstructor
:
:
WrapFramesInFirstLetterFrame
(
nsContainerFrame
*
aBlockFrame
nsContainerFrame
*
aBlockContinuation
nsContainerFrame
*
aParentFrame
nsIFrame
*
aParentFrameList
nsContainerFrame
*
*
aModifiedParent
nsIFrame
*
*
aTextFrame
nsIFrame
*
*
aPrevFrame
nsFrameItems
&
aLetterFrames
bool
*
aStopLooking
)
{
nsIFrame
*
prevFrame
=
nullptr
;
nsIFrame
*
frame
=
aParentFrameList
;
while
(
frame
)
{
nsIFrame
*
nextFrame
=
frame
-
>
GetNextSibling
(
)
;
LayoutFrameType
frameType
=
frame
-
>
Type
(
)
;
if
(
LayoutFrameType
:
:
Text
=
=
frameType
)
{
nsIContent
*
textContent
=
frame
-
>
GetContent
(
)
;
if
(
IsFirstLetterContent
(
textContent
)
)
{
CreateLetterFrame
(
aBlockFrame
aBlockContinuation
textContent
aParentFrame
aLetterFrames
)
;
*
aModifiedParent
=
aParentFrame
;
*
aTextFrame
=
frame
;
*
aPrevFrame
=
prevFrame
;
*
aStopLooking
=
true
;
return
;
}
}
else
if
(
IsInlineFrame
(
frame
)
&
&
frameType
!
=
LayoutFrameType
:
:
Br
)
{
nsIFrame
*
kids
=
frame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
WrapFramesInFirstLetterFrame
(
aBlockFrame
aBlockContinuation
static_cast
<
nsContainerFrame
*
>
(
frame
)
kids
aModifiedParent
aTextFrame
aPrevFrame
aLetterFrames
aStopLooking
)
;
if
(
*
aStopLooking
)
{
return
;
}
}
else
{
*
aStopLooking
=
true
;
break
;
}
prevFrame
=
frame
;
frame
=
nextFrame
;
}
}
static
nsIFrame
*
FindFirstLetterFrame
(
nsIFrame
*
aFrame
nsIFrame
:
:
ChildListID
aListID
)
{
nsFrameList
list
=
aFrame
-
>
GetChildList
(
aListID
)
;
for
(
nsFrameList
:
:
Enumerator
e
(
list
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
)
{
if
(
e
.
get
(
)
-
>
IsLetterFrame
(
)
)
{
return
e
.
get
(
)
;
}
}
return
nullptr
;
}
static
void
ClearHasFirstLetterChildFrom
(
nsContainerFrame
*
aParentFrame
)
{
MOZ_ASSERT
(
aParentFrame
)
;
auto
*
parent
=
static_cast
<
nsContainerFrame
*
>
(
aParentFrame
-
>
FirstContinuation
(
)
)
;
if
(
MOZ_UNLIKELY
(
parent
-
>
IsLineFrame
(
)
)
)
{
MOZ_ASSERT
(
!
parent
-
>
HasFirstLetterChild
(
)
)
;
parent
=
static_cast
<
nsContainerFrame
*
>
(
parent
-
>
GetParent
(
)
-
>
FirstContinuation
(
)
)
;
}
MOZ_ASSERT
(
parent
-
>
HasFirstLetterChild
(
)
)
;
parent
-
>
ClearHasFirstLetterChild
(
)
;
}
void
nsCSSFrameConstructor
:
:
RemoveFloatingFirstLetterFrames
(
nsIPresShell
*
aPresShell
nsIFrame
*
aBlockFrame
)
{
nsIFrame
*
floatFrame
=
:
:
FindFirstLetterFrame
(
aBlockFrame
nsIFrame
:
:
kFloatList
)
;
if
(
!
floatFrame
)
{
floatFrame
=
:
:
FindFirstLetterFrame
(
aBlockFrame
nsIFrame
:
:
kPushedFloatsList
)
;
if
(
!
floatFrame
)
{
return
;
}
}
nsIFrame
*
textFrame
=
floatFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
!
textFrame
)
{
return
;
}
nsPlaceholderFrame
*
placeholderFrame
=
floatFrame
-
>
GetPlaceholderFrame
(
)
;
if
(
!
placeholderFrame
)
{
return
;
}
nsContainerFrame
*
parentFrame
=
placeholderFrame
-
>
GetParent
(
)
;
if
(
!
parentFrame
)
{
return
;
}
ClearHasFirstLetterChildFrom
(
parentFrame
)
;
ComputedStyle
*
parentSC
=
parentFrame
-
>
Style
(
)
;
nsIContent
*
textContent
=
textFrame
-
>
GetContent
(
)
;
if
(
!
textContent
)
{
return
;
}
RefPtr
<
ComputedStyle
>
newSC
=
aPresShell
-
>
StyleSet
(
)
-
>
ResolveStyleForText
(
textContent
parentSC
)
;
nsIFrame
*
newTextFrame
=
NS_NewTextFrame
(
aPresShell
newSC
)
;
newTextFrame
-
>
Init
(
textContent
parentFrame
nullptr
)
;
nsIFrame
*
frameToDelete
=
textFrame
-
>
LastContinuation
(
)
;
while
(
frameToDelete
!
=
textFrame
)
{
nsIFrame
*
nextFrameToDelete
=
frameToDelete
-
>
GetPrevContinuation
(
)
;
RemoveFrame
(
kPrincipalList
frameToDelete
)
;
frameToDelete
=
nextFrameToDelete
;
}
nsIFrame
*
prevSibling
=
placeholderFrame
-
>
GetPrevSibling
(
)
;
#
ifdef
NOISY_FIRST_LETTER
printf
(
"
RemoveFloatingFirstLetterFrames
:
textContent
=
%
p
oldTextFrame
=
%
p
"
"
newTextFrame
=
%
p
\
n
"
textContent
.
get
(
)
textFrame
newTextFrame
)
;
#
endif
RemoveFrame
(
kPrincipalList
placeholderFrame
)
;
textContent
-
>
SetPrimaryFrame
(
newTextFrame
)
;
bool
offsetsNeedFixing
=
prevSibling
&
&
prevSibling
-
>
IsTextFrame
(
)
;
if
(
offsetsNeedFixing
)
{
prevSibling
-
>
AddStateBits
(
TEXT_OFFSETS_NEED_FIXING
)
;
}
nsFrameList
textList
(
newTextFrame
newTextFrame
)
;
InsertFrames
(
parentFrame
kPrincipalList
prevSibling
textList
)
;
if
(
offsetsNeedFixing
)
{
prevSibling
-
>
RemoveStateBits
(
TEXT_OFFSETS_NEED_FIXING
)
;
}
}
void
nsCSSFrameConstructor
:
:
RemoveFirstLetterFrames
(
nsIPresShell
*
aPresShell
nsContainerFrame
*
aFrame
nsContainerFrame
*
aBlockFrame
bool
*
aStopLooking
)
{
nsIFrame
*
prevSibling
=
nullptr
;
nsIFrame
*
kid
=
aFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
while
(
kid
)
{
if
(
kid
-
>
IsLetterFrame
(
)
)
{
ClearHasFirstLetterChildFrom
(
aFrame
)
;
nsIFrame
*
textFrame
=
kid
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
!
textFrame
)
{
break
;
}
ComputedStyle
*
parentSC
=
aFrame
-
>
Style
(
)
;
if
(
!
parentSC
)
{
break
;
}
nsIContent
*
textContent
=
textFrame
-
>
GetContent
(
)
;
if
(
!
textContent
)
{
break
;
}
RefPtr
<
ComputedStyle
>
newSC
=
aPresShell
-
>
StyleSet
(
)
-
>
ResolveStyleForText
(
textContent
parentSC
)
;
textFrame
=
NS_NewTextFrame
(
aPresShell
newSC
)
;
textFrame
-
>
Init
(
textContent
aFrame
nullptr
)
;
RemoveFrame
(
kPrincipalList
kid
)
;
textContent
-
>
SetPrimaryFrame
(
textFrame
)
;
bool
offsetsNeedFixing
=
prevSibling
&
&
prevSibling
-
>
IsTextFrame
(
)
;
if
(
offsetsNeedFixing
)
{
prevSibling
-
>
AddStateBits
(
TEXT_OFFSETS_NEED_FIXING
)
;
}
nsFrameList
textList
(
textFrame
textFrame
)
;
InsertFrames
(
aFrame
kPrincipalList
prevSibling
textList
)
;
if
(
offsetsNeedFixing
)
{
prevSibling
-
>
RemoveStateBits
(
TEXT_OFFSETS_NEED_FIXING
)
;
}
*
aStopLooking
=
true
;
NS_ASSERTION
(
!
aBlockFrame
-
>
GetPrevContinuation
(
)
"
should
have
the
first
continuation
here
"
)
;
aBlockFrame
-
>
RemoveStateBits
(
NS_BLOCK_HAS_FIRST_LETTER_CHILD
)
;
break
;
}
else
if
(
IsInlineFrame
(
kid
)
)
{
nsContainerFrame
*
kidAsContainerFrame
=
do_QueryFrame
(
kid
)
;
if
(
kidAsContainerFrame
)
{
RemoveFirstLetterFrames
(
aPresShell
kidAsContainerFrame
aBlockFrame
aStopLooking
)
;
if
(
*
aStopLooking
)
{
break
;
}
}
}
prevSibling
=
kid
;
kid
=
kid
-
>
GetNextSibling
(
)
;
}
}
void
nsCSSFrameConstructor
:
:
RemoveLetterFrames
(
nsIPresShell
*
aPresShell
nsContainerFrame
*
aBlockFrame
)
{
aBlockFrame
=
static_cast
<
nsContainerFrame
*
>
(
aBlockFrame
-
>
FirstContinuation
(
)
)
;
aBlockFrame
-
>
RemoveProperty
(
nsContainerFrame
:
:
FirstLetterProperty
(
)
)
;
nsContainerFrame
*
continuation
=
aBlockFrame
;
bool
stopLooking
=
false
;
do
{
RemoveFloatingFirstLetterFrames
(
aPresShell
continuation
)
;
RemoveFirstLetterFrames
(
aPresShell
continuation
aBlockFrame
&
stopLooking
)
;
if
(
stopLooking
)
{
break
;
}
continuation
=
static_cast
<
nsContainerFrame
*
>
(
continuation
-
>
GetNextContinuation
(
)
)
;
}
while
(
continuation
)
;
}
void
nsCSSFrameConstructor
:
:
RecoverLetterFrames
(
nsContainerFrame
*
aBlockFrame
)
{
aBlockFrame
=
static_cast
<
nsContainerFrame
*
>
(
aBlockFrame
-
>
FirstContinuation
(
)
)
;
nsContainerFrame
*
continuation
=
aBlockFrame
;
nsContainerFrame
*
parentFrame
=
nullptr
;
nsIFrame
*
textFrame
=
nullptr
;
nsIFrame
*
prevFrame
=
nullptr
;
nsFrameItems
letterFrames
;
bool
stopLooking
=
false
;
do
{
continuation
-
>
AddStateBits
(
NS_BLOCK_HAS_FIRST_LETTER_STYLE
)
;
WrapFramesInFirstLetterFrame
(
aBlockFrame
continuation
continuation
continuation
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
&
parentFrame
&
textFrame
&
prevFrame
letterFrames
&
stopLooking
)
;
if
(
stopLooking
)
{
break
;
}
continuation
=
static_cast
<
nsContainerFrame
*
>
(
continuation
-
>
GetNextContinuation
(
)
)
;
}
while
(
continuation
)
;
if
(
parentFrame
)
{
RemoveFrame
(
kPrincipalList
textFrame
)
;
parentFrame
-
>
InsertFrames
(
kPrincipalList
prevFrame
letterFrames
)
;
}
}
nsContainerFrame
*
nsCSSFrameConstructor
:
:
InitAndWrapInColumnSetFrameIfNeeded
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
nsContainerFrame
*
aParentFrame
nsContainerFrame
*
aBlockFrame
ComputedStyle
*
aComputedStyle
)
{
MOZ_ASSERT
(
(
aBlockFrame
-
>
IsBlockFrame
(
)
|
|
aBlockFrame
-
>
IsDetailsFrame
(
)
)
"
aBlockFrame
should
either
be
a
block
frame
or
a
details
frame
.
"
)
;
if
(
!
aComputedStyle
-
>
StyleColumn
(
)
-
>
IsColumnContainerStyle
(
)
)
{
aBlockFrame
-
>
SetComputedStyleWithoutNotification
(
aComputedStyle
)
;
InitAndRestoreFrame
(
aState
aContent
aParentFrame
aBlockFrame
)
;
return
aBlockFrame
;
}
nsContainerFrame
*
columnSetFrame
=
NS_NewColumnSetFrame
(
mPresShell
aComputedStyle
nsFrameState
(
NS_FRAME_OWNS_ANON_BOXES
)
)
;
InitAndRestoreFrame
(
aState
aContent
aParentFrame
columnSetFrame
)
;
SetInitialSingleChild
(
columnSetFrame
aBlockFrame
)
;
RefPtr
<
ComputedStyle
>
anonBlockStyle
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveInheritingAnonymousBoxStyle
(
nsCSSAnonBoxes
:
:
columnContent
(
)
aComputedStyle
)
;
aBlockFrame
-
>
SetComputedStyleWithoutNotification
(
anonBlockStyle
)
;
InitAndRestoreFrame
(
aState
aContent
columnSetFrame
aBlockFrame
)
;
return
columnSetFrame
;
}
void
nsCSSFrameConstructor
:
:
ConstructBlock
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
nsContainerFrame
*
aParentFrame
nsContainerFrame
*
aContentParentFrame
ComputedStyle
*
aComputedStyle
nsContainerFrame
*
*
aNewFrame
nsFrameItems
&
aFrameItems
nsIFrame
*
aPositionedFrameForAbsPosContainer
PendingBinding
*
aPendingBinding
)
{
nsBlockFrame
*
blockFrame
=
do_QueryFrame
(
*
aNewFrame
)
;
MOZ_ASSERT
(
blockFrame
-
>
IsBlockFrame
(
)
|
|
blockFrame
-
>
IsDetailsFrame
(
)
"
not
a
block
frame
nor
a
details
frame
?
"
)
;
const
bool
needsColumn
=
aComputedStyle
-
>
StyleColumn
(
)
-
>
IsColumnContainerStyle
(
)
;
if
(
needsColumn
)
{
*
aNewFrame
=
BeginBuildingColumns
(
aState
aContent
aParentFrame
blockFrame
aComputedStyle
)
;
if
(
aPositionedFrameForAbsPosContainer
=
=
blockFrame
)
{
aPositionedFrameForAbsPosContainer
=
*
aNewFrame
;
}
}
else
{
blockFrame
-
>
SetComputedStyleWithoutNotification
(
aComputedStyle
)
;
InitAndRestoreFrame
(
aState
aContent
aParentFrame
blockFrame
)
;
}
aState
.
AddChild
(
*
aNewFrame
aFrameItems
aContent
aContentParentFrame
?
aContentParentFrame
:
aParentFrame
)
;
if
(
!
mRootElementFrame
)
{
mRootElementFrame
=
*
aNewFrame
;
}
nsFrameConstructorSaveState
absoluteSaveState
;
(
*
aNewFrame
)
-
>
AddStateBits
(
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
;
if
(
aPositionedFrameForAbsPosContainer
)
{
aState
.
PushAbsoluteContainingBlock
(
*
aNewFrame
aPositionedFrameForAbsPosContainer
absoluteSaveState
)
;
}
if
(
StaticPrefs
:
:
layout_css_column_span_enabled
(
)
)
{
if
(
aParentFrame
-
>
HasAnyStateBits
(
NS_FRAME_HAS_MULTI_COLUMN_ANCESTOR
)
&
&
!
ShouldSuppressColumnSpanDescendants
(
aParentFrame
)
)
{
blockFrame
-
>
AddStateBits
(
NS_FRAME_HAS_MULTI_COLUMN_ANCESTOR
)
;
}
}
nsFrameItems
childItems
;
ProcessChildren
(
aState
aContent
aComputedStyle
blockFrame
true
childItems
true
aPendingBinding
)
;
if
(
!
StaticPrefs
:
:
layout_css_column_span_enabled
(
)
)
{
blockFrame
-
>
SetInitialChildList
(
kPrincipalList
childItems
)
;
CreateBulletFrameForListItemIfNeeded
(
blockFrame
)
;
return
;
}
if
(
!
MayNeedToCreateColumnSpanSiblings
(
blockFrame
childItems
)
)
{
blockFrame
-
>
SetInitialChildList
(
kPrincipalList
childItems
)
;
CreateBulletFrameForListItemIfNeeded
(
blockFrame
)
;
return
;
}
nsFrameList
initialNonColumnSpanKids
=
childItems
.
Split
(
[
]
(
nsIFrame
*
f
)
{
return
f
-
>
IsColumnSpan
(
)
;
}
)
;
blockFrame
-
>
SetInitialChildList
(
kPrincipalList
initialNonColumnSpanKids
)
;
nsBlockFrame
*
blockFrameToCreateBullet
=
blockFrame
;
if
(
needsColumn
&
&
(
*
aNewFrame
)
-
>
StyleList
(
)
-
>
mListStylePosition
=
=
NS_STYLE_LIST_STYLE_POSITION_OUTSIDE
)
{
blockFrameToCreateBullet
=
static_cast
<
nsBlockFrame
*
>
(
*
aNewFrame
)
;
}
CreateBulletFrameForListItemIfNeeded
(
blockFrameToCreateBullet
)
;
if
(
childItems
.
IsEmpty
(
)
)
{
return
;
}
nsFrameList
columnSpanSiblings
=
CreateColumnSpanSiblings
(
aState
blockFrame
childItems
needsColumn
?
nullptr
:
aPositionedFrameForAbsPosContainer
)
;
if
(
needsColumn
)
{
FinishBuildingColumns
(
aState
*
aNewFrame
blockFrame
columnSpanSiblings
)
;
}
else
{
aFrameItems
.
AppendFrames
(
nullptr
columnSpanSiblings
)
;
}
MOZ_ASSERT
(
columnSpanSiblings
.
IsEmpty
(
)
"
The
column
-
span
siblings
should
be
moved
to
the
proper
place
!
"
)
;
}
void
nsCSSFrameConstructor
:
:
CreateBulletFrameForListItemIfNeeded
(
nsBlockFrame
*
aBlockFrame
)
{
nsIFrame
*
possibleListItem
=
aBlockFrame
;
while
(
true
)
{
nsIFrame
*
parent
=
possibleListItem
-
>
GetParent
(
)
;
if
(
parent
-
>
GetContent
(
)
!
=
aBlockFrame
-
>
GetContent
(
)
)
{
break
;
}
possibleListItem
=
parent
;
}
if
(
possibleListItem
-
>
StyleDisplay
(
)
-
>
mDisplay
=
=
StyleDisplay
:
:
ListItem
)
{
aBlockFrame
-
>
CreateBulletFrameForListItem
(
)
;
}
}
nsContainerFrame
*
nsCSSFrameConstructor
:
:
BeginBuildingColumns
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
nsContainerFrame
*
aParentFrame
nsContainerFrame
*
aColumnContent
ComputedStyle
*
aComputedStyle
)
{
MOZ_ASSERT
(
aColumnContent
-
>
IsBlockFrame
(
)
|
|
aColumnContent
-
>
IsDetailsFrame
(
)
"
aColumnContent
should
either
be
a
block
frame
or
a
details
frame
.
"
)
;
MOZ_ASSERT
(
aComputedStyle
-
>
StyleColumn
(
)
-
>
IsColumnContainerStyle
(
)
"
No
need
to
build
a
column
hierarchy
!
"
)
;
if
(
!
StaticPrefs
:
:
layout_css_column_span_enabled
(
)
)
{
nsContainerFrame
*
columnSetFrame
=
NS_NewColumnSetFrame
(
mPresShell
aComputedStyle
nsFrameState
(
NS_FRAME_OWNS_ANON_BOXES
)
)
;
InitAndRestoreFrame
(
aState
aContent
aParentFrame
columnSetFrame
)
;
SetInitialSingleChild
(
columnSetFrame
aColumnContent
)
;
RefPtr
<
ComputedStyle
>
anonBlockStyle
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveInheritingAnonymousBoxStyle
(
nsCSSAnonBoxes
:
:
columnContent
(
)
aComputedStyle
)
;
aColumnContent
-
>
SetComputedStyleWithoutNotification
(
anonBlockStyle
)
;
InitAndRestoreFrame
(
aState
aContent
columnSetFrame
aColumnContent
)
;
return
columnSetFrame
;
}
nsBlockFrame
*
columnSetWrapper
=
NS_NewColumnSetWrapperFrame
(
mPresShell
aComputedStyle
nsFrameState
(
NS_FRAME_OWNS_ANON_BOXES
)
)
;
InitAndRestoreFrame
(
aState
aContent
aParentFrame
columnSetWrapper
)
;
RefPtr
<
ComputedStyle
>
columnSetStyle
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveInheritingAnonymousBoxStyle
(
nsCSSAnonBoxes
:
:
columnSet
(
)
aComputedStyle
)
;
nsContainerFrame
*
columnSet
=
NS_NewColumnSetFrame
(
mPresShell
columnSetStyle
nsFrameState
(
NS_FRAME_OWNS_ANON_BOXES
)
)
;
InitAndRestoreFrame
(
aState
aContent
columnSetWrapper
columnSet
)
;
columnSet
-
>
AddStateBits
(
NS_FRAME_HAS_MULTI_COLUMN_ANCESTOR
)
;
RefPtr
<
ComputedStyle
>
blockStyle
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveInheritingAnonymousBoxStyle
(
nsCSSAnonBoxes
:
:
columnContent
(
)
columnSetStyle
)
;
aColumnContent
-
>
SetComputedStyleWithoutNotification
(
blockStyle
)
;
InitAndRestoreFrame
(
aState
aContent
columnSet
aColumnContent
)
;
aColumnContent
-
>
AddStateBits
(
NS_FRAME_HAS_MULTI_COLUMN_ANCESTOR
)
;
SetInitialSingleChild
(
columnSetWrapper
columnSet
)
;
SetInitialSingleChild
(
columnSet
aColumnContent
)
;
return
columnSetWrapper
;
}
void
nsCSSFrameConstructor
:
:
FinishBuildingColumns
(
nsFrameConstructorState
&
aState
nsContainerFrame
*
aColumnSetWrapper
nsContainerFrame
*
aColumnContent
nsFrameList
&
aColumnContentSiblings
)
{
MOZ_ASSERT
(
StaticPrefs
:
:
layout_css_column_span_enabled
(
)
"
Call
this
only
when
layout
.
css
.
column
-
span
.
enabled
is
true
!
"
)
;
nsContainerFrame
*
prevColumnSet
=
aColumnContent
-
>
GetParent
(
)
;
MOZ_ASSERT
(
prevColumnSet
-
>
IsColumnSetFrame
(
)
&
&
prevColumnSet
-
>
GetParent
(
)
=
=
aColumnSetWrapper
"
Should
have
established
column
hierarchy
!
"
)
;
nsFrameItems
finalItems
;
while
(
aColumnContentSiblings
.
NotEmpty
(
)
)
{
nsIFrame
*
f
=
aColumnContentSiblings
.
RemoveFirstChild
(
)
;
if
(
f
-
>
IsColumnSpan
(
)
)
{
finalItems
.
AddChild
(
f
)
;
}
else
{
auto
*
continuingColumnSet
=
static_cast
<
nsContainerFrame
*
>
(
CreateContinuingFrame
(
mPresShell
-
>
GetPresContext
(
)
prevColumnSet
aColumnSetWrapper
false
)
)
;
f
-
>
SetParent
(
continuingColumnSet
)
;
SetInitialSingleChild
(
continuingColumnSet
f
)
;
finalItems
.
AddChild
(
continuingColumnSet
)
;
prevColumnSet
=
continuingColumnSet
;
}
}
finalItems
.
ApplySetParent
(
aColumnSetWrapper
)
;
aColumnSetWrapper
-
>
AppendFrames
(
kPrincipalList
finalItems
)
;
}
bool
nsCSSFrameConstructor
:
:
MayNeedToCreateColumnSpanSiblings
(
nsContainerFrame
*
aBlockFrame
const
nsFrameList
&
aChildList
)
{
MOZ_ASSERT
(
StaticPrefs
:
:
layout_css_column_span_enabled
(
)
"
Call
this
only
when
layout
.
css
.
column
-
span
.
enabled
is
true
!
"
)
;
if
(
!
aBlockFrame
-
>
HasAnyStateBits
(
NS_FRAME_HAS_MULTI_COLUMN_ANCESTOR
)
)
{
return
false
;
}
if
(
ShouldSuppressColumnSpanDescendants
(
aBlockFrame
)
)
{
return
false
;
}
if
(
aChildList
.
IsEmpty
(
)
)
{
return
false
;
}
return
true
;
}
nsFrameItems
nsCSSFrameConstructor
:
:
CreateColumnSpanSiblings
(
nsFrameConstructorState
&
aState
nsContainerFrame
*
aInitialBlock
nsFrameList
&
aChildList
nsIFrame
*
aPositionedFrame
)
{
MOZ_ASSERT
(
!
aPositionedFrame
|
|
aPositionedFrame
-
>
IsAbsPosContainingBlock
(
)
)
;
nsIContent
*
const
content
=
aInitialBlock
-
>
GetContent
(
)
;
nsContainerFrame
*
const
parentFrame
=
aInitialBlock
-
>
GetParent
(
)
;
aInitialBlock
-
>
SetProperty
(
nsIFrame
:
:
HasColumnSpanSiblings
(
)
true
)
;
nsFrameItems
siblings
;
nsContainerFrame
*
lastNonColumnSpanWrapper
=
aInitialBlock
;
do
{
MOZ_ASSERT
(
aChildList
.
NotEmpty
(
)
"
Why
call
this
if
child
list
is
empty
?
"
)
;
MOZ_ASSERT
(
aChildList
.
FirstChild
(
)
-
>
IsColumnSpan
(
)
"
Must
have
the
child
starting
with
column
-
span
!
"
)
;
RefPtr
<
ComputedStyle
>
columnSpanWrapperStyle
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveNonInheritingAnonymousBoxStyle
(
nsCSSAnonBoxes
:
:
columnSpanWrapper
(
)
)
;
nsBlockFrame
*
columnSpanWrapper
=
NS_NewBlockFrame
(
mPresShell
columnSpanWrapperStyle
)
;
InitAndRestoreFrame
(
aState
content
parentFrame
columnSpanWrapper
false
)
;
columnSpanWrapper
-
>
AddStateBits
(
NS_FRAME_HAS_MULTI_COLUMN_ANCESTOR
|
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
;
nsFrameList
columnSpanKids
=
aChildList
.
Split
(
[
]
(
nsIFrame
*
f
)
{
return
!
f
-
>
IsColumnSpan
(
)
;
}
)
;
columnSpanKids
.
ApplySetParent
(
columnSpanWrapper
)
;
columnSpanWrapper
-
>
SetInitialChildList
(
kPrincipalList
columnSpanKids
)
;
if
(
aPositionedFrame
)
{
aState
.
ReparentAbsoluteItems
(
columnSpanWrapper
)
;
}
siblings
.
AddChild
(
columnSpanWrapper
)
;
auto
*
nonColumnSpanWrapper
=
static_cast
<
nsContainerFrame
*
>
(
CreateContinuingFrame
(
mPresShell
-
>
GetPresContext
(
)
lastNonColumnSpanWrapper
parentFrame
false
)
)
;
nonColumnSpanWrapper
-
>
AddStateBits
(
NS_FRAME_HAS_MULTI_COLUMN_ANCESTOR
|
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
;
if
(
aChildList
.
NotEmpty
(
)
)
{
nsFrameList
nonColumnSpanKids
=
aChildList
.
Split
(
[
]
(
nsIFrame
*
f
)
{
return
f
-
>
IsColumnSpan
(
)
;
}
)
;
nonColumnSpanKids
.
ApplySetParent
(
nonColumnSpanWrapper
)
;
nonColumnSpanWrapper
-
>
SetInitialChildList
(
kPrincipalList
nonColumnSpanKids
)
;
if
(
aPositionedFrame
)
{
aState
.
ReparentAbsoluteItems
(
nonColumnSpanWrapper
)
;
}
}
siblings
.
AddChild
(
nonColumnSpanWrapper
)
;
lastNonColumnSpanWrapper
=
nonColumnSpanWrapper
;
}
while
(
aChildList
.
NotEmpty
(
)
)
;
return
siblings
;
}
bool
nsCSSFrameConstructor
:
:
MaybeRecreateForColumnSpan
(
nsFrameConstructorState
&
aState
nsContainerFrame
*
aParentFrame
nsFrameList
&
aFrameList
nsIFrame
*
aPrevSibling
)
{
MOZ_ASSERT
(
StaticPrefs
:
:
layout_css_column_span_enabled
(
)
"
Call
this
only
when
layout
.
css
.
column
-
span
.
enabled
is
true
!
"
)
;
if
(
!
aParentFrame
-
>
HasAnyStateBits
(
NS_FRAME_HAS_MULTI_COLUMN_ANCESTOR
)
)
{
return
false
;
}
MOZ_ASSERT
(
!
IsFramePartOfIBSplit
(
aParentFrame
)
"
We
should
have
wiped
aParentFrame
in
WipeContainingBlock
if
it
'
s
"
"
part
of
IB
split
!
"
)
;
nsIFrame
*
nextSibling
=
:
:
GetInsertNextSibling
(
aParentFrame
aPrevSibling
)
;
if
(
!
nextSibling
&
&
IsLastContinuationForColumnContent
(
aParentFrame
)
)
{
return
false
;
}
auto
HasColumnSpan
=
[
]
(
const
nsFrameList
&
aList
)
{
for
(
nsIFrame
*
f
:
aList
)
{
if
(
f
-
>
IsColumnSpan
(
)
)
{
return
true
;
}
}
return
false
;
}
;
if
(
HasColumnSpan
(
aFrameList
)
)
{
PROFILER_TRACING
(
"
Layout
"
"
Reframe
multi
-
column
after
constructing
frame
list
"
LAYOUT
TRACING_EVENT
)
;
aFrameList
.
DestroyFrames
(
)
;
RecreateFramesForContent
(
GetMultiColumnContainingBlockFor
(
aParentFrame
)
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
return
true
;
}
return
false
;
}
nsIFrame
*
nsCSSFrameConstructor
:
:
ConstructInline
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aDisplay
nsFrameItems
&
aFrameItems
)
{
nsIContent
*
const
content
=
aItem
.
mContent
;
ComputedStyle
*
const
computedStyle
=
aItem
.
mComputedStyle
;
nsInlineFrame
*
newFrame
=
NS_NewInlineFrame
(
mPresShell
computedStyle
)
;
InitAndRestoreFrame
(
aState
content
aParentFrame
newFrame
)
;
nsFrameConstructorSaveState
absoluteSaveState
;
bool
isAbsPosCB
=
newFrame
-
>
IsAbsPosContainingBlock
(
)
;
newFrame
-
>
AddStateBits
(
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
;
if
(
isAbsPosCB
)
{
aState
.
PushAbsoluteContainingBlock
(
newFrame
newFrame
absoluteSaveState
)
;
}
if
(
StaticPrefs
:
:
layout_css_column_span_enabled
(
)
)
{
if
(
aParentFrame
-
>
HasAnyStateBits
(
NS_FRAME_HAS_MULTI_COLUMN_ANCESTOR
)
&
&
!
ShouldSuppressColumnSpanDescendants
(
aParentFrame
)
)
{
newFrame
-
>
AddStateBits
(
NS_FRAME_HAS_MULTI_COLUMN_ANCESTOR
)
;
}
}
nsFrameItems
childItems
;
ConstructFramesFromItemList
(
aState
aItem
.
mChildItems
newFrame
false
childItems
)
;
nsFrameList
:
:
FrameLinkEnumerator
firstBlockEnumerator
(
childItems
)
;
if
(
!
aItem
.
mIsAllInline
)
{
firstBlockEnumerator
.
Find
(
[
]
(
nsIFrame
*
aFrame
)
{
return
aFrame
-
>
IsBlockOutside
(
)
;
}
)
;
}
if
(
aItem
.
mIsAllInline
|
|
firstBlockEnumerator
.
AtEnd
(
)
)
{
newFrame
-
>
SetInitialChildList
(
kPrincipalList
childItems
)
;
aState
.
AddChild
(
newFrame
aFrameItems
content
aParentFrame
)
;
return
newFrame
;
}
nsFrameList
firstInlineKids
=
childItems
.
ExtractHead
(
firstBlockEnumerator
)
;
newFrame
-
>
SetInitialChildList
(
kPrincipalList
firstInlineKids
)
;
aFrameItems
.
AddChild
(
newFrame
)
;
newFrame
-
>
AddStateBits
(
NS_FRAME_OWNS_ANON_BOXES
)
;
CreateIBSiblings
(
aState
newFrame
isAbsPosCB
childItems
aFrameItems
)
;
return
newFrame
;
}
void
nsCSSFrameConstructor
:
:
CreateIBSiblings
(
nsFrameConstructorState
&
aState
nsContainerFrame
*
aInitialInline
bool
aIsAbsPosCB
nsFrameItems
&
aChildItems
nsFrameItems
&
aSiblings
)
{
MOZ_ASSERT
(
aIsAbsPosCB
=
=
aInitialInline
-
>
IsAbsPosContainingBlock
(
)
)
;
nsIContent
*
content
=
aInitialInline
-
>
GetContent
(
)
;
ComputedStyle
*
computedStyle
=
aInitialInline
-
>
Style
(
)
;
nsContainerFrame
*
parentFrame
=
aInitialInline
-
>
GetParent
(
)
;
RefPtr
<
ComputedStyle
>
blockSC
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveInheritingAnonymousBoxStyle
(
nsCSSAnonBoxes
:
:
mozBlockInsideInlineWrapper
(
)
computedStyle
)
;
nsContainerFrame
*
lastNewInline
=
static_cast
<
nsContainerFrame
*
>
(
aInitialInline
-
>
FirstContinuation
(
)
)
;
do
{
MOZ_ASSERT
(
aChildItems
.
NotEmpty
(
)
"
Should
have
child
items
"
)
;
MOZ_ASSERT
(
aChildItems
.
FirstChild
(
)
-
>
IsBlockOutside
(
)
"
Must
have
list
starting
with
block
"
)
;
nsBlockFrame
*
blockFrame
=
NS_NewBlockFrame
(
mPresShell
blockSC
)
;
InitAndRestoreFrame
(
aState
content
parentFrame
blockFrame
false
)
;
if
(
aInitialInline
-
>
HasAnyStateBits
(
NS_FRAME_HAS_MULTI_COLUMN_ANCESTOR
)
)
{
blockFrame
-
>
AddStateBits
(
NS_FRAME_HAS_MULTI_COLUMN_ANCESTOR
)
;
}
nsFrameList
blockKids
=
aChildItems
.
Split
(
[
]
(
nsIFrame
*
f
)
{
return
!
f
-
>
IsBlockOutside
(
)
;
}
)
;
if
(
!
StaticPrefs
:
:
layout_css_column_span_enabled
(
)
|
|
!
aInitialInline
-
>
HasAnyStateBits
(
NS_FRAME_HAS_MULTI_COLUMN_ANCESTOR
)
)
{
MoveChildrenTo
(
aInitialInline
blockFrame
blockKids
)
;
SetFrameIsIBSplit
(
lastNewInline
blockFrame
)
;
aSiblings
.
AddChild
(
blockFrame
)
;
}
else
{
nsFrameList
initialNonColumnSpanKids
=
blockKids
.
Split
(
[
]
(
nsIFrame
*
f
)
{
return
f
-
>
IsColumnSpan
(
)
;
}
)
;
MoveChildrenTo
(
aInitialInline
blockFrame
initialNonColumnSpanKids
)
;
SetFrameIsIBSplit
(
lastNewInline
blockFrame
)
;
aSiblings
.
AddChild
(
blockFrame
)
;
if
(
blockKids
.
NotEmpty
(
)
)
{
blockFrame
-
>
AddStateBits
(
NS_FRAME_PART_OF_IBSPLIT
)
;
nsFrameItems
columnSpanSiblings
=
CreateColumnSpanSiblings
(
aState
blockFrame
blockKids
aIsAbsPosCB
?
aInitialInline
:
nullptr
)
;
aSiblings
.
AppendFrames
(
nullptr
columnSpanSiblings
)
;
}
}
nsInlineFrame
*
inlineFrame
=
NS_NewInlineFrame
(
mPresShell
computedStyle
)
;
InitAndRestoreFrame
(
aState
content
parentFrame
inlineFrame
false
)
;
inlineFrame
-
>
AddStateBits
(
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
;
if
(
aInitialInline
-
>
HasAnyStateBits
(
NS_FRAME_HAS_MULTI_COLUMN_ANCESTOR
)
)
{
inlineFrame
-
>
AddStateBits
(
NS_FRAME_HAS_MULTI_COLUMN_ANCESTOR
)
;
}
if
(
aIsAbsPosCB
)
{
inlineFrame
-
>
MarkAsAbsoluteContainingBlock
(
)
;
}
if
(
aChildItems
.
NotEmpty
(
)
)
{
nsFrameList
inlineKids
=
aChildItems
.
Split
(
[
]
(
nsIFrame
*
f
)
{
return
f
-
>
IsBlockOutside
(
)
;
}
)
;
MoveChildrenTo
(
aInitialInline
inlineFrame
inlineKids
)
;
}
SetFrameIsIBSplit
(
blockFrame
inlineFrame
)
;
aSiblings
.
AddChild
(
inlineFrame
)
;
lastNewInline
=
inlineFrame
;
}
while
(
aChildItems
.
NotEmpty
(
)
)
;
SetFrameIsIBSplit
(
lastNewInline
nullptr
)
;
}
void
nsCSSFrameConstructor
:
:
BuildInlineChildItems
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aParentItem
bool
aItemIsWithinSVGText
bool
aItemAllowsTextPathChild
)
{
nsFrameConstructorState
:
:
PendingBindingAutoPusher
pusher
(
aState
aParentItem
.
mPendingBinding
)
;
ComputedStyle
*
const
parentComputedStyle
=
aParentItem
.
mComputedStyle
;
nsIContent
*
const
parentContent
=
aParentItem
.
mContent
;
if
(
!
aItemIsWithinSVGText
)
{
CreateGeneratedContentItem
(
aState
nullptr
*
parentContent
-
>
AsElement
(
)
*
parentComputedStyle
CSSPseudoElementType
:
:
before
aParentItem
.
mChildItems
)
;
}
uint32_t
flags
=
ITEM_ALLOW_XBL_BASE
|
ITEM_ALLOW_PAGE_BREAK
;
if
(
aItemIsWithinSVGText
)
{
flags
|
=
ITEM_IS_WITHIN_SVG_TEXT
;
}
if
(
aItemAllowsTextPathChild
&
&
aParentItem
.
mContent
-
>
IsSVGElement
(
nsGkAtoms
:
:
a
)
)
{
flags
|
=
ITEM_ALLOWS_TEXT_PATH_CHILD
;
}
FlattenedChildIterator
iter
(
parentContent
)
;
for
(
nsIContent
*
content
=
iter
.
GetNextChild
(
)
;
content
;
content
=
iter
.
GetNextChild
(
)
)
{
content
-
>
UnsetFlags
(
NODE_DESCENDANTS_NEED_FRAMES
|
NODE_NEEDS_FRAME
)
;
if
(
content
-
>
IsComment
(
)
|
|
content
-
>
IsProcessingInstruction
(
)
)
{
continue
;
}
RefPtr
<
ComputedStyle
>
childContext
=
ResolveComputedStyle
(
content
)
;
AddFrameConstructionItemsInternal
(
aState
content
nullptr
iter
.
XBLInvolved
(
)
childContext
flags
aParentItem
.
mChildItems
)
;
}
if
(
!
aItemIsWithinSVGText
)
{
CreateGeneratedContentItem
(
aState
nullptr
*
parentContent
-
>
AsElement
(
)
*
parentComputedStyle
CSSPseudoElementType
:
:
after
aParentItem
.
mChildItems
)
;
}
aParentItem
.
mIsAllInline
=
aParentItem
.
mChildItems
.
AreAllItemsInline
(
)
;
}
static
bool
IsSafeToAppendToIBSplitInline
(
nsIFrame
*
aParentFrame
nsIFrame
*
aNextSibling
)
{
MOZ_ASSERT
(
IsInlineFrame
(
aParentFrame
)
"
Must
have
an
inline
parent
here
"
)
;
do
{
NS_ASSERTION
(
IsFramePartOfIBSplit
(
aParentFrame
)
"
How
is
this
not
part
of
an
ib
-
split
?
"
)
;
if
(
aNextSibling
|
|
aParentFrame
-
>
GetNextContinuation
(
)
|
|
GetIBSplitSibling
(
aParentFrame
)
)
{
return
false
;
}
aNextSibling
=
aParentFrame
-
>
GetNextSibling
(
)
;
aParentFrame
=
aParentFrame
-
>
GetParent
(
)
;
}
while
(
IsInlineFrame
(
aParentFrame
)
)
;
return
true
;
}
bool
nsCSSFrameConstructor
:
:
WipeContainingBlock
(
nsFrameConstructorState
&
aState
nsIFrame
*
aContainingBlock
nsIFrame
*
aFrame
FrameConstructionItemList
&
aItems
bool
aIsAppend
nsIFrame
*
aPrevSibling
)
{
#
define
TRACE
(
reason
)
\
PROFILER_TRACING
(
"
Layout
"
"
WipeContainingBlock
:
"
reason
LAYOUT
\
TRACING_EVENT
)
if
(
aItems
.
IsEmpty
(
)
)
{
return
false
;
}
if
(
aFrame
-
>
IsXULBoxFrame
(
)
&
&
!
(
aFrame
-
>
GetStateBits
(
)
&
NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK
)
&
&
aItems
.
AnyItemsNeedBlockParent
(
)
)
{
TRACE
(
"
XUL
with
block
-
wrapped
kids
"
)
;
RecreateFramesForContent
(
aFrame
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
return
true
;
}
nsIFrame
*
nextSibling
=
:
:
GetInsertNextSibling
(
aFrame
aPrevSibling
)
;
LayoutFrameType
frameType
=
aFrame
-
>
Type
(
)
;
if
(
frameType
=
=
LayoutFrameType
:
:
FlexContainer
|
|
frameType
=
=
LayoutFrameType
:
:
GridContainer
)
{
FCItemIterator
iter
(
aItems
)
;
const
bool
isLegacyBox
=
IsFlexContainerForLegacyBox
(
aFrame
)
;
if
(
aPrevSibling
&
&
IsAnonymousFlexOrGridItem
(
aPrevSibling
)
&
&
iter
.
item
(
)
.
NeedsAnonFlexOrGridItem
(
aState
isLegacyBox
)
)
{
TRACE
(
"
Inserting
inline
after
anon
flex
or
grid
item
"
)
;
RecreateFramesForContent
(
aFrame
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
return
true
;
}
if
(
nextSibling
&
&
IsAnonymousFlexOrGridItem
(
nextSibling
)
)
{
iter
.
SetToEnd
(
)
;
iter
.
Prev
(
)
;
if
(
iter
.
item
(
)
.
NeedsAnonFlexOrGridItem
(
aState
isLegacyBox
)
)
{
TRACE
(
"
Inserting
inline
before
anon
flex
or
grid
item
"
)
;
RecreateFramesForContent
(
aFrame
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
return
true
;
}
}
}
if
(
IsAnonymousFlexOrGridItem
(
aFrame
)
)
{
AssertAnonymousFlexOrGridItemParent
(
aFrame
aFrame
-
>
GetParent
(
)
)
;
nsFrameConstructorSaveState
floatSaveState
;
aState
.
PushFloatContainingBlock
(
nullptr
floatSaveState
)
;
FCItemIterator
iter
(
aItems
)
;
nsIFrame
*
containerFrame
=
aFrame
-
>
GetParent
(
)
;
const
bool
isLegacyBox
=
IsFlexContainerForLegacyBox
(
containerFrame
)
;
if
(
!
iter
.
SkipItemsThatNeedAnonFlexOrGridItem
(
aState
isLegacyBox
)
)
{
TRACE
(
"
Inserting
non
-
inlines
inside
anon
flex
or
grid
item
"
)
;
RecreateFramesForContent
(
containerFrame
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
return
true
;
}
}
if
(
IsRubyPseudo
(
aFrame
)
|
|
frameType
=
=
LayoutFrameType
:
:
Ruby
|
|
RubyUtils
:
:
IsRubyContainerBox
(
frameType
)
)
{
TRACE
(
"
Ruby
"
)
;
RecreateFramesForContent
(
aFrame
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
return
true
;
}
ParentType
parentType
=
GetParentType
(
aFrame
)
;
if
(
!
aItems
.
AllWantParentType
(
parentType
)
)
{
if
(
parentType
!
=
eTypeBlock
&
&
!
aFrame
-
>
IsGeneratedContentFrame
(
)
)
{
FCItemIterator
iter
(
aItems
)
;
FCItemIterator
start
(
iter
)
;
do
{
if
(
iter
.
SkipItemsWantingParentType
(
parentType
)
)
{
break
;
}
if
(
!
iter
.
item
(
)
.
IsWhitespace
(
aState
)
)
{
break
;
}
if
(
iter
=
=
start
)
{
nsIFrame
*
prevSibling
=
aPrevSibling
;
if
(
!
prevSibling
)
{
nsIFrame
*
parentPrevCont
=
aFrame
-
>
GetPrevContinuation
(
)
;
while
(
parentPrevCont
)
{
prevSibling
=
parentPrevCont
-
>
GetChildList
(
kPrincipalList
)
.
LastChild
(
)
;
if
(
prevSibling
)
{
break
;
}
parentPrevCont
=
parentPrevCont
-
>
GetPrevContinuation
(
)
;
}
}
;
if
(
prevSibling
)
{
if
(
IsTablePseudo
(
prevSibling
)
)
{
break
;
}
}
else
if
(
IsTablePseudo
(
aFrame
)
)
{
break
;
}
}
FCItemIterator
spaceEndIter
(
iter
)
;
bool
trailingSpaces
=
spaceEndIter
.
SkipWhitespace
(
aState
)
;
bool
okToDrop
;
if
(
trailingSpaces
)
{
okToDrop
=
aIsAppend
&
&
!
nextSibling
;
if
(
!
okToDrop
)
{
if
(
!
nextSibling
)
{
nsIFrame
*
parentNextCont
=
aFrame
-
>
GetNextContinuation
(
)
;
while
(
parentNextCont
)
{
nextSibling
=
parentNextCont
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
nextSibling
)
{
break
;
}
parentNextCont
=
parentNextCont
-
>
GetNextContinuation
(
)
;
}
}
okToDrop
=
(
nextSibling
&
&
!
IsTablePseudo
(
nextSibling
)
)
|
|
(
!
nextSibling
&
&
!
IsTablePseudo
(
aFrame
)
)
;
}
#
ifdef
DEBUG
else
{
NS_ASSERTION
(
!
IsTablePseudo
(
aFrame
)
"
How
did
that
happen
?
"
)
;
}
#
endif
}
else
{
okToDrop
=
(
spaceEndIter
.
item
(
)
.
DesiredParentType
(
)
=
=
parentType
)
;
}
if
(
okToDrop
)
{
iter
.
DeleteItemsTo
(
this
spaceEndIter
)
;
}
else
{
break
;
}
}
while
(
!
iter
.
IsDone
(
)
)
;
}
if
(
aItems
.
IsEmpty
(
)
)
{
return
false
;
}
if
(
!
aItems
.
AllWantParentType
(
parentType
)
)
{
TRACE
(
"
Pseudo
-
frames
going
wrong
"
)
;
RecreateFramesForContent
(
aFrame
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
return
true
;
}
}
if
(
aFrame
-
>
IsColumnSetWrapperFrame
(
)
)
{
TRACE
(
"
Multi
-
column
"
)
;
RecreateFramesForContent
(
aFrame
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
return
true
;
}
if
(
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_HAS_MULTI_COLUMN_ANCESTOR
)
)
{
bool
anyColumnSpanItems
=
false
;
for
(
FCItemIterator
iter
(
aItems
)
;
!
iter
.
IsDone
(
)
;
iter
.
Next
(
)
)
{
if
(
iter
.
item
(
)
.
mComputedStyle
-
>
StyleColumn
(
)
-
>
IsColumnSpanStyle
(
)
)
{
anyColumnSpanItems
=
true
;
break
;
}
}
bool
needsReframe
=
anyColumnSpanItems
|
|
aFrame
-
>
Style
(
)
-
>
GetPseudo
(
)
=
=
nsCSSAnonBoxes
:
:
columnSpanWrapper
(
)
|
|
IsFramePartOfIBSplit
(
aFrame
)
;
if
(
needsReframe
)
{
TRACE
(
"
Multi
-
column
"
)
;
RecreateFramesForContent
(
GetMultiColumnContainingBlockFor
(
aFrame
)
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
return
true
;
}
return
false
;
}
do
{
if
(
IsInlineFrame
(
aFrame
)
)
{
if
(
aItems
.
AreAllItemsInline
(
)
)
{
return
false
;
}
if
(
!
IsFramePartOfIBSplit
(
aFrame
)
)
{
break
;
}
if
(
aIsAppend
&
&
IsSafeToAppendToIBSplitInline
(
aFrame
nextSibling
)
)
{
return
false
;
}
break
;
}
if
(
!
IsFramePartOfIBSplit
(
aFrame
)
)
{
return
false
;
}
if
(
aItems
.
AreAllItemsBlock
(
)
)
{
return
false
;
}
}
while
(
0
)
;
if
(
!
aContainingBlock
)
{
aContainingBlock
=
aFrame
;
}
while
(
IsFramePartOfIBSplit
(
aContainingBlock
)
|
|
aContainingBlock
-
>
IsInlineOutside
(
)
|
|
aContainingBlock
-
>
Style
(
)
-
>
GetPseudo
(
)
)
{
aContainingBlock
=
aContainingBlock
-
>
GetParent
(
)
;
NS_ASSERTION
(
aContainingBlock
"
Must
have
non
-
inline
non
-
ib
-
split
non
-
pseudo
frame
as
"
"
root
(
or
child
of
root
for
a
table
root
)
!
"
)
;
}
nsIContent
*
blockContent
=
aContainingBlock
-
>
GetContent
(
)
;
TRACE
(
"
IB
splits
"
)
;
RecreateFramesForContent
(
blockContent
InsertionKind
:
:
Async
)
;
return
true
;
#
undef
TRACE
}
void
nsCSSFrameConstructor
:
:
ReframeContainingBlock
(
nsIFrame
*
aFrame
)
{
if
(
mPresShell
-
>
IsReflowLocked
(
)
)
{
NS_ERROR
(
"
Atemptted
to
nsCSSFrameConstructor
:
:
ReframeContainingBlock
during
a
"
"
Reflow
!
!
!
"
)
;
return
;
}
nsIFrame
*
containingBlock
=
GetIBContainingBlockFor
(
aFrame
)
;
if
(
containingBlock
)
{
if
(
nsIContent
*
blockContent
=
containingBlock
-
>
GetContent
(
)
)
{
#
ifdef
DEBUG
if
(
gNoisyContentUpdates
)
{
printf
(
"
=
=
>
blockContent
=
%
p
\
n
"
blockContent
)
;
}
#
endif
RecreateFramesForContent
(
blockContent
InsertionKind
:
:
Async
)
;
return
;
}
}
RecreateFramesForContent
(
mPresShell
-
>
GetDocument
(
)
-
>
GetRootElement
(
)
InsertionKind
:
:
Async
)
;
}
void
nsCSSFrameConstructor
:
:
GenerateChildFrames
(
nsContainerFrame
*
aFrame
)
{
{
nsAutoScriptBlocker
scriptBlocker
;
nsFrameItems
childItems
;
nsFrameConstructorState
state
(
mPresShell
nullptr
nullptr
nullptr
)
;
ProcessChildren
(
state
aFrame
-
>
GetContent
(
)
aFrame
-
>
Style
(
)
aFrame
false
childItems
false
nullptr
)
;
aFrame
-
>
SetInitialChildList
(
kPrincipalList
childItems
)
;
}
#
ifdef
ACCESSIBILITY
if
(
nsAccessibilityService
*
accService
=
nsIPresShell
:
:
AccService
(
)
)
{
if
(
nsIContent
*
child
=
aFrame
-
>
GetContent
(
)
-
>
GetFirstChild
(
)
)
{
accService
-
>
ContentRangeInserted
(
mPresShell
child
nullptr
)
;
}
}
#
endif
mPresShell
-
>
GetDocument
(
)
-
>
BindingManager
(
)
-
>
ProcessAttachedQueue
(
)
;
}
bool
nsCSSFrameConstructor
:
:
FrameConstructionItem
:
:
IsWhitespace
(
nsFrameConstructorState
&
aState
)
const
{
MOZ_ASSERT
(
aState
.
mCreatingExtraFrames
|
|
!
mContent
-
>
GetPrimaryFrame
(
)
"
How
did
that
happen
?
"
)
;
if
(
!
mIsText
)
{
return
false
;
}
mContent
-
>
SetFlags
(
NS_CREATE_FRAME_IF_NON_WHITESPACE
|
NS_REFRAME_IF_WHITESPACE
)
;
return
mContent
-
>
TextIsOnlyWhitespace
(
)
;
}
void
nsCSSFrameConstructor
:
:
FrameConstructionItemList
:
:
AdjustCountsForItem
(
FrameConstructionItem
*
aItem
int32_t
aDelta
)
{
MOZ_ASSERT
(
aDelta
=
=
1
|
|
aDelta
=
=
-
1
"
Unexpected
delta
"
)
;
mItemCount
+
=
aDelta
;
if
(
aItem
-
>
mIsAllInline
)
{
mInlineCount
+
=
aDelta
;
}
if
(
aItem
-
>
mIsBlock
)
{
mBlockCount
+
=
aDelta
;
}
if
(
aItem
-
>
mIsLineParticipant
)
{
mLineParticipantCount
+
=
aDelta
;
}
mDesiredParentCounts
[
aItem
-
>
DesiredParentType
(
)
]
+
=
aDelta
;
}
inline
bool
nsCSSFrameConstructor
:
:
FrameConstructionItemList
:
:
Iterator
:
:
SkipItemsWantingParentType
(
ParentType
aParentType
)
{
MOZ_ASSERT
(
!
IsDone
(
)
"
Shouldn
'
t
be
done
yet
"
)
;
while
(
item
(
)
.
DesiredParentType
(
)
=
=
aParentType
)
{
Next
(
)
;
if
(
IsDone
(
)
)
{
return
true
;
}
}
return
false
;
}
inline
bool
nsCSSFrameConstructor
:
:
FrameConstructionItemList
:
:
Iterator
:
:
SkipItemsNotWantingParentType
(
ParentType
aParentType
)
{
MOZ_ASSERT
(
!
IsDone
(
)
"
Shouldn
'
t
be
done
yet
"
)
;
while
(
item
(
)
.
DesiredParentType
(
)
!
=
aParentType
)
{
Next
(
)
;
if
(
IsDone
(
)
)
{
return
true
;
}
}
return
false
;
}
bool
nsCSSFrameConstructor
:
:
FrameConstructionItem
:
:
NeedsAnonFlexOrGridItem
(
const
nsFrameConstructorState
&
aState
bool
aIsLegacyBox
)
{
if
(
mFCData
-
>
mBits
&
FCDATA_IS_LINE_PARTICIPANT
)
{
return
true
;
}
if
(
aIsLegacyBox
)
{
if
(
mComputedStyle
-
>
StyleDisplay
(
)
-
>
IsInlineOutsideStyle
(
)
)
{
return
true
;
}
if
(
mIsPopup
|
|
(
!
(
mFCData
-
>
mBits
&
FCDATA_DISALLOW_OUT_OF_FLOW
)
&
&
aState
.
GetGeometricParent
(
*
mComputedStyle
-
>
StyleDisplay
(
)
nullptr
)
)
)
{
return
true
;
}
}
return
false
;
}
inline
bool
nsCSSFrameConstructor
:
:
FrameConstructionItemList
:
:
Iterator
:
:
SkipItemsThatNeedAnonFlexOrGridItem
(
const
nsFrameConstructorState
&
aState
bool
aIsLegacyBox
)
{
MOZ_ASSERT
(
!
IsDone
(
)
"
Shouldn
'
t
be
done
yet
"
)
;
while
(
item
(
)
.
NeedsAnonFlexOrGridItem
(
aState
aIsLegacyBox
)
)
{
Next
(
)
;
if
(
IsDone
(
)
)
{
return
true
;
}
}
return
false
;
}
inline
bool
nsCSSFrameConstructor
:
:
FrameConstructionItemList
:
:
Iterator
:
:
SkipItemsThatDontNeedAnonFlexOrGridItem
(
const
nsFrameConstructorState
&
aState
bool
aIsLegacyBox
)
{
MOZ_ASSERT
(
!
IsDone
(
)
"
Shouldn
'
t
be
done
yet
"
)
;
while
(
!
(
item
(
)
.
NeedsAnonFlexOrGridItem
(
aState
aIsLegacyBox
)
)
)
{
Next
(
)
;
if
(
IsDone
(
)
)
{
return
true
;
}
}
return
false
;
}
inline
bool
nsCSSFrameConstructor
:
:
FrameConstructionItemList
:
:
Iterator
:
:
SkipItemsNotWantingRubyParent
(
)
{
MOZ_ASSERT
(
!
IsDone
(
)
"
Shouldn
'
t
be
done
yet
"
)
;
while
(
!
IsRubyParentType
(
item
(
)
.
DesiredParentType
(
)
)
)
{
Next
(
)
;
if
(
IsDone
(
)
)
{
return
true
;
}
}
return
false
;
}
inline
bool
nsCSSFrameConstructor
:
:
FrameConstructionItemList
:
:
Iterator
:
:
SkipWhitespace
(
nsFrameConstructorState
&
aState
)
{
MOZ_ASSERT
(
!
IsDone
(
)
"
Shouldn
'
t
be
done
yet
"
)
;
MOZ_ASSERT
(
item
(
)
.
IsWhitespace
(
aState
)
"
Not
pointing
to
whitespace
?
"
)
;
do
{
Next
(
)
;
if
(
IsDone
(
)
)
{
return
true
;
}
}
while
(
item
(
)
.
IsWhitespace
(
aState
)
)
;
return
false
;
}
void
nsCSSFrameConstructor
:
:
FrameConstructionItemList
:
:
Iterator
:
:
AppendItemToList
(
FrameConstructionItemList
&
aTargetList
)
{
NS_ASSERTION
(
&
aTargetList
!
=
&
mList
"
Unexpected
call
"
)
;
MOZ_ASSERT
(
!
IsDone
(
)
"
should
not
be
done
"
)
;
FrameConstructionItem
*
item
=
mCurrent
;
Next
(
)
;
item
-
>
remove
(
)
;
aTargetList
.
mItems
.
insertBack
(
item
)
;
mList
.
AdjustCountsForItem
(
item
-
1
)
;
aTargetList
.
AdjustCountsForItem
(
item
1
)
;
}
void
nsCSSFrameConstructor
:
:
FrameConstructionItemList
:
:
Iterator
:
:
AppendItemsToList
(
nsCSSFrameConstructor
*
aFCtor
const
Iterator
&
aEnd
FrameConstructionItemList
&
aTargetList
)
{
NS_ASSERTION
(
&
aTargetList
!
=
&
mList
"
Unexpected
call
"
)
;
MOZ_ASSERT
(
&
mList
=
=
&
aEnd
.
mList
"
End
iterator
for
some
other
list
?
"
)
;
if
(
!
AtStart
(
)
|
|
!
aEnd
.
IsDone
(
)
|
|
!
aTargetList
.
IsEmpty
(
)
)
{
do
{
AppendItemToList
(
aTargetList
)
;
}
while
(
*
this
!
=
aEnd
)
;
return
;
}
aTargetList
.
mItems
=
std
:
:
move
(
mList
.
mItems
)
;
aTargetList
.
mInlineCount
=
mList
.
mInlineCount
;
aTargetList
.
mBlockCount
=
mList
.
mBlockCount
;
aTargetList
.
mLineParticipantCount
=
mList
.
mLineParticipantCount
;
aTargetList
.
mItemCount
=
mList
.
mItemCount
;
memcpy
(
aTargetList
.
mDesiredParentCounts
mList
.
mDesiredParentCounts
sizeof
(
aTargetList
.
mDesiredParentCounts
)
)
;
mList
.
Reset
(
aFCtor
)
;
SetToEnd
(
)
;
MOZ_ASSERT
(
*
this
=
=
aEnd
"
How
did
that
happen
?
"
)
;
}
void
nsCSSFrameConstructor
:
:
FrameConstructionItemList
:
:
Iterator
:
:
InsertItem
(
FrameConstructionItem
*
aItem
)
{
if
(
IsDone
(
)
)
{
mList
.
mItems
.
insertBack
(
aItem
)
;
}
else
{
mCurrent
-
>
setPrevious
(
aItem
)
;
}
mList
.
AdjustCountsForItem
(
aItem
1
)
;
MOZ_ASSERT
(
aItem
-
>
getNext
(
)
=
=
mCurrent
"
How
did
that
happen
?
"
)
;
}
void
nsCSSFrameConstructor
:
:
FrameConstructionItemList
:
:
Iterator
:
:
DeleteItemsTo
(
nsCSSFrameConstructor
*
aFCtor
const
Iterator
&
aEnd
)
{
MOZ_ASSERT
(
&
mList
=
=
&
aEnd
.
mList
"
End
iterator
for
some
other
list
?
"
)
;
MOZ_ASSERT
(
*
this
!
=
aEnd
"
Shouldn
'
t
be
at
aEnd
yet
"
)
;
do
{
NS_ASSERTION
(
!
IsDone
(
)
"
Ran
off
end
of
list
?
"
)
;
FrameConstructionItem
*
item
=
mCurrent
;
Next
(
)
;
item
-
>
remove
(
)
;
mList
.
AdjustCountsForItem
(
item
-
1
)
;
item
-
>
Delete
(
aFCtor
)
;
}
while
(
*
this
!
=
aEnd
)
;
}
void
nsCSSFrameConstructor
:
:
QuotesDirty
(
)
{
mQuotesDirty
=
true
;
mPresShell
-
>
SetNeedLayoutFlush
(
)
;
}
void
nsCSSFrameConstructor
:
:
CountersDirty
(
)
{
mCountersDirty
=
true
;
mPresShell
-
>
SetNeedLayoutFlush
(
)
;
}
void
*
nsCSSFrameConstructor
:
:
AllocateFCItem
(
)
{
void
*
item
;
if
(
mFirstFreeFCItem
)
{
item
=
mFirstFreeFCItem
;
mFirstFreeFCItem
=
mFirstFreeFCItem
-
>
mNext
;
}
else
{
item
=
mFCItemPool
.
Allocate
(
sizeof
(
FrameConstructionItem
)
)
;
}
+
+
mFCItemsInUse
;
return
item
;
}
void
nsCSSFrameConstructor
:
:
FreeFCItem
(
FrameConstructionItem
*
aItem
)
{
MOZ_ASSERT
(
mFCItemsInUse
!
=
0
)
;
if
(
-
-
mFCItemsInUse
=
=
0
)
{
mFirstFreeFCItem
=
nullptr
;
mFCItemPool
.
Clear
(
)
;
}
else
{
FreeFCItemLink
*
item
=
reinterpret_cast
<
FreeFCItemLink
*
>
(
aItem
)
;
item
-
>
mNext
=
mFirstFreeFCItem
;
mFirstFreeFCItem
=
item
;
}
}
void
nsCSSFrameConstructor
:
:
AddSizeOfIncludingThis
(
nsWindowSizes
&
aSizes
)
const
{
if
(
nsIFrame
*
rootFrame
=
GetRootFrame
(
)
)
{
rootFrame
-
>
AddSizeOfExcludingThisForTree
(
aSizes
)
;
}
nsFrameManager
:
:
AddSizeOfIncludingThis
(
aSizes
)
;
}
