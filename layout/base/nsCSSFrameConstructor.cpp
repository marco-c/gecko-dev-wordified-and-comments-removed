#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
ComputedStyleInlines
.
h
"
#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
mozilla
/
ErrorResult
.
h
"
#
include
"
mozilla
/
dom
/
HTMLDetailsElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLSelectElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLSummaryElement
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
MemoryReporting
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
mozilla
/
ServoStyleSetInlines
.
h
"
#
include
"
mozilla
/
StaticPrefs
.
h
"
#
include
"
nsAbsoluteContainingBlock
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIDocumentInlines
.
h
"
#
include
"
nsTableFrame
.
h
"
#
include
"
nsTableColFrame
.
h
"
#
include
"
nsTableRowFrame
.
h
"
#
include
"
nsTableCellFrame
.
h
"
#
include
"
nsHTMLParts
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
ifdef
MOZ_XUL
#
include
"
nsXULElement
.
h
"
#
include
"
mozilla
/
dom
/
BoxObject
.
h
"
#
endif
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsIComboboxControlFrame
.
h
"
#
include
"
nsComboboxControlFrame
.
h
"
#
include
"
nsIListControlFrame
.
h
"
#
include
"
nsPlaceholderFrame
.
h
"
#
include
"
nsTableRowGroupFrame
.
h
"
#
include
"
nsIFormControl
.
h
"
#
include
"
nsCSSAnonBoxes
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
"
nsIAnonymousContentCreator
.
h
"
#
include
"
nsBindingManager
.
h
"
#
include
"
nsXBLBinding
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIScriptError
.
h
"
#
ifdef
XP_MACOSX
#
include
"
nsIDocShell
.
h
"
#
endif
#
include
"
ChildIterator
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsBoxFrame
.
h
"
#
include
"
nsBoxLayout
.
h
"
#
include
"
nsFlexContainerFrame
.
h
"
#
include
"
nsGridContainerFrame
.
h
"
#
include
"
RubyUtils
.
h
"
#
include
"
nsRubyFrame
.
h
"
#
include
"
nsRubyBaseFrame
.
h
"
#
include
"
nsRubyBaseContainerFrame
.
h
"
#
include
"
nsRubyTextFrame
.
h
"
#
include
"
nsRubyTextContainerFrame
.
h
"
#
include
"
nsImageFrame
.
h
"
#
include
"
nsIObjectLoadingContent
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
mozilla
/
dom
/
CharacterData
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
ElementInlines
.
h
"
#
include
"
nsAutoLayoutPhase
.
h
"
#
include
"
nsStyleStructInlines
.
h
"
#
include
"
nsPageContentFrame
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
StickyScrollContainer
.
h
"
#
include
"
nsFieldSetFrame
.
h
"
#
include
"
nsInlineFrame
.
h
"
#
include
"
nsBlockFrame
.
h
"
#
include
"
nsCanvasFrame
.
h
"
#
include
"
nsFirstLetterFrame
.
h
"
#
include
"
nsGfxScrollFrame
.
h
"
#
include
"
nsPageFrame
.
h
"
#
include
"
nsSimplePageSequenceFrame
.
h
"
#
include
"
nsTableWrapperFrame
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsBackdropFrame
.
h
"
#
include
"
nsTransitionManager
.
h
"
#
include
"
DetailsFrame
.
h
"
#
include
"
nsThemeConstants
.
h
"
#
ifdef
MOZ_XUL
#
include
"
nsIRootBox
.
h
"
#
endif
#
ifdef
ACCESSIBILITY
#
include
"
nsAccessibilityService
.
h
"
#
endif
#
include
"
nsXBLService
.
h
"
#
undef
NOISY_FIRST_LETTER
#
include
"
nsMathMLParts
.
h
"
#
include
"
mozilla
/
dom
/
SVGTests
.
h
"
#
include
"
nsSVGUtils
.
h
"
#
include
"
nsRefreshDriver
.
h
"
#
include
"
nsTextNode
.
h
"
#
include
"
ActiveLayerTracker
.
h
"
#
include
"
nsIPresShellInlines
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
static
const
nsIFrame
:
:
ChildListID
kPrincipalList
=
nsIFrame
:
:
kPrincipalList
;
nsIFrame
*
NS_NewHTMLCanvasFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewHTMLVideoFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsContainerFrame
*
NS_NewSVGOuterSVGFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsContainerFrame
*
NS_NewSVGOuterSVGAnonChildFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewSVGInnerSVGFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewSVGGeometryFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewSVGGFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewSVGGenericContainerFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsContainerFrame
*
NS_NewSVGForeignObjectFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewSVGAFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewSVGSwitchFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewSVGSymbolFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewSVGTextFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewSVGContainerFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewSVGUseFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewSVGViewFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
extern
nsIFrame
*
NS_NewSVGLinearGradientFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
extern
nsIFrame
*
NS_NewSVGRadialGradientFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
extern
nsIFrame
*
NS_NewSVGStopFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsContainerFrame
*
NS_NewSVGMarkerFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsContainerFrame
*
NS_NewSVGMarkerAnonChildFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
extern
nsIFrame
*
NS_NewSVGImageFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewSVGClipPathFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewSVGFilterFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewSVGPatternFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewSVGMaskFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewSVGFEContainerFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewSVGFELeafFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewSVGFEImageFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewSVGFEUnstyledLeafFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
#
include
"
mozilla
/
dom
/
NodeInfo
.
h
"
#
include
"
prenv
.
h
"
#
include
"
nsNodeInfoManager
.
h
"
#
include
"
nsContentCreatorFunctions
.
h
"
#
ifdef
DEBUG
static
bool
gNoisyContentUpdates
=
false
;
static
bool
gReallyNoisyContentUpdates
=
false
;
static
bool
gNoisyInlineConstruction
=
false
;
struct
FrameCtorDebugFlags
{
const
char
*
name
;
bool
*
on
;
}
;
static
FrameCtorDebugFlags
gFlags
[
]
=
{
{
"
content
-
updates
"
&
gNoisyContentUpdates
}
{
"
really
-
noisy
-
content
-
updates
"
&
gReallyNoisyContentUpdates
}
{
"
noisy
-
inline
"
&
gNoisyInlineConstruction
}
}
;
#
define
NUM_DEBUG_FLAGS
(
sizeof
(
gFlags
)
/
sizeof
(
gFlags
[
0
]
)
)
#
endif
#
ifdef
MOZ_XUL
#
include
"
nsMenuFrame
.
h
"
#
include
"
nsPopupSetFrame
.
h
"
#
include
"
nsTreeColFrame
.
h
"
#
include
"
nsIBoxObject
.
h
"
#
include
"
nsPIListBoxObject
.
h
"
#
include
"
nsListBoxBodyFrame
.
h
"
#
include
"
nsListItemFrame
.
h
"
#
include
"
nsXULLabelFrame
.
h
"
nsIFrame
*
NS_NewAutoRepeatBoxFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsContainerFrame
*
NS_NewRootBoxFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsContainerFrame
*
NS_NewDocElementBoxFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewDeckFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewLeafBoxFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewStackFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewProgressMeterFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewRangeFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewImageBoxFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewTextBoxFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewGroupBoxFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewButtonBoxFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewSplitterFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewMenuPopupFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewPopupSetFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewMenuFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
uint32_t
aFlags
)
;
nsIFrame
*
NS_NewMenuBarFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewTreeBodyFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsresult
NS_NewGridLayout2
(
nsIPresShell
*
aPresShell
nsBoxLayout
*
*
aNewLayout
)
;
nsIFrame
*
NS_NewGridRowLeafFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewGridRowGroupFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewTitleBarFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewResizerFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
#
endif
nsHTMLScrollFrame
*
NS_NewHTMLScrollFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
bool
aIsRoot
)
;
nsXULScrollFrame
*
NS_NewXULScrollFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
bool
aIsRoot
bool
aClipAllDescendants
)
;
nsIFrame
*
NS_NewSliderFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewScrollbarFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsIFrame
*
NS_NewScrollbarButtonFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
#
ifdef
NOISY_FINDFRAME
static
int32_t
FFWC_totalCount
=
0
;
static
int32_t
FFWC_doLoop
=
0
;
static
int32_t
FFWC_doSibling
=
0
;
static
int32_t
FFWC_recursions
=
0
;
static
int32_t
FFWC_nextInFlows
=
0
;
#
endif
#
ifdef
MOZ_XUL
static
bool
IsXULListBox
(
nsIContent
*
aContainer
)
{
return
aContainer
-
>
IsXULElement
(
nsGkAtoms
:
:
listbox
)
;
}
static
nsListBoxBodyFrame
*
MaybeGetListBoxBodyFrame
(
nsIContent
*
aChild
)
{
if
(
aChild
-
>
IsXULElement
(
nsGkAtoms
:
:
listitem
)
&
&
aChild
-
>
GetParent
(
)
&
&
IsXULListBox
(
aChild
-
>
GetParent
(
)
)
)
{
RefPtr
<
nsXULElement
>
xulElement
=
nsXULElement
:
:
FromNode
(
aChild
-
>
GetParent
(
)
)
;
nsCOMPtr
<
nsIBoxObject
>
boxObject
=
xulElement
-
>
GetBoxObject
(
IgnoreErrors
(
)
)
;
nsCOMPtr
<
nsPIListBoxObject
>
listBoxObject
=
do_QueryInterface
(
boxObject
)
;
if
(
listBoxObject
)
{
return
listBoxObject
-
>
GetListBoxBody
(
false
)
;
}
}
return
nullptr
;
}
#
endif
static
inline
bool
IsAnonymousFlexOrGridItem
(
const
nsIFrame
*
aFrame
)
{
const
nsAtom
*
pseudoType
=
aFrame
-
>
Style
(
)
-
>
GetPseudo
(
)
;
return
pseudoType
=
=
nsCSSAnonBoxes
:
:
anonymousFlexItem
|
|
pseudoType
=
=
nsCSSAnonBoxes
:
:
anonymousGridItem
;
}
static
inline
bool
IsFlexOrGridContainer
(
const
nsIFrame
*
aFrame
)
{
const
LayoutFrameType
t
=
aFrame
-
>
Type
(
)
;
return
t
=
=
LayoutFrameType
:
:
FlexContainer
|
|
t
=
=
LayoutFrameType
:
:
GridContainer
;
}
static
inline
bool
IsFlexContainerForLegacyBox
(
const
nsIFrame
*
aFrame
)
{
return
aFrame
-
>
IsFlexContainerFrame
(
)
&
&
aFrame
-
>
HasAnyStateBits
(
NS_STATE_FLEX_IS_EMULATING_LEGACY_BOX
)
;
}
#
if
DEBUG
static
void
AssertAnonymousFlexOrGridItemParent
(
const
nsIFrame
*
aChild
const
nsIFrame
*
aParent
)
{
MOZ_ASSERT
(
IsAnonymousFlexOrGridItem
(
aChild
)
"
expected
an
anonymous
flex
or
grid
item
child
frame
"
)
;
MOZ_ASSERT
(
aParent
"
expected
a
parent
frame
"
)
;
const
nsAtom
*
pseudoType
=
aChild
-
>
Style
(
)
-
>
GetPseudo
(
)
;
if
(
pseudoType
=
=
nsCSSAnonBoxes
:
:
anonymousFlexItem
)
{
MOZ_ASSERT
(
aParent
-
>
IsFlexContainerFrame
(
)
"
anonymous
flex
items
should
only
exist
as
children
"
"
of
flex
container
frames
"
)
;
}
else
{
MOZ_ASSERT
(
aParent
-
>
IsGridContainerFrame
(
)
"
anonymous
grid
items
should
only
exist
as
children
"
"
of
grid
container
frames
"
)
;
}
}
#
else
#
define
AssertAnonymousFlexOrGridItemParent
(
x
y
)
do
{
/
*
nothing
*
/
}
while
(
0
)
#
endif
static
inline
nsContainerFrame
*
GetFieldSetBlockFrame
(
nsIFrame
*
aFieldsetFrame
)
{
nsIFrame
*
firstChild
=
aFieldsetFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
nsIFrame
*
inner
=
firstChild
&
&
firstChild
-
>
GetNextSibling
(
)
?
firstChild
-
>
GetNextSibling
(
)
:
firstChild
;
return
inner
?
inner
-
>
GetContentInsertionFrame
(
)
:
nullptr
;
}
#
define
FCDATA_DECL
(
_flags
_func
)
\
{
_flags
{
(
FrameCreationFunc
)
_func
}
nullptr
nullptr
}
#
define
FCDATA_WITH_WRAPPING_BLOCK
(
_flags
_func
_anon_box
)
\
{
_flags
|
FCDATA_CREATE_BLOCK_WRAPPER_FOR_ALL_KIDS
\
{
(
FrameCreationFunc
)
_func
}
nullptr
&
_anon_box
}
#
define
UNREACHABLE_FCDATA
(
)
\
{
0
{
(
FrameCreationFunc
)
nullptr
}
nullptr
nullptr
}
static
bool
IsInlineFrame
(
const
nsIFrame
*
aFrame
)
{
return
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eLineParticipant
)
;
}
static
inline
bool
IsDisplayContents
(
const
Element
*
aElement
)
{
return
aElement
-
>
IsDisplayContents
(
)
;
}
static
inline
bool
IsDisplayContents
(
const
nsIContent
*
aContent
)
{
return
aContent
-
>
IsElement
(
)
&
&
IsDisplayContents
(
aContent
-
>
AsElement
(
)
)
;
}
static
bool
IsFrameForSVG
(
const
nsIFrame
*
aFrame
)
{
return
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
|
|
nsSVGUtils
:
:
IsInSVGTextSubtree
(
aFrame
)
;
}
static
bool
ShouldSuppressFloatingOfDescendants
(
nsIFrame
*
aFrame
)
{
return
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eMathML
)
|
|
aFrame
-
>
IsXULBoxFrame
(
)
|
|
:
:
IsFlexOrGridContainer
(
aFrame
)
;
}
static
nsIContent
*
AnyKidsNeedBlockParent
(
nsIFrame
*
aFrameList
)
{
for
(
nsIFrame
*
k
=
aFrameList
;
k
;
k
=
k
-
>
GetNextSibling
(
)
)
{
if
(
k
-
>
IsFrameOfType
(
nsIFrame
:
:
eLineParticipant
)
)
{
return
k
-
>
GetContent
(
)
;
}
}
return
nullptr
;
}
static
void
ReparentFrame
(
RestyleManager
*
aRestyleManager
nsContainerFrame
*
aNewParentFrame
nsIFrame
*
aFrame
bool
aForceStyleReparent
)
{
aFrame
-
>
SetParent
(
aNewParentFrame
)
;
if
(
aForceStyleReparent
)
{
aRestyleManager
-
>
ReparentComputedStyleForFirstLine
(
aFrame
)
;
}
}
static
void
ReparentFrames
(
nsCSSFrameConstructor
*
aFrameConstructor
nsContainerFrame
*
aNewParentFrame
const
nsFrameList
&
aFrameList
bool
aForceStyleReparent
)
{
RestyleManager
*
restyleManager
=
aFrameConstructor
-
>
RestyleManager
(
)
;
for
(
nsIFrame
*
f
:
aFrameList
)
{
ReparentFrame
(
restyleManager
aNewParentFrame
f
aForceStyleReparent
)
;
}
}
static
inline
bool
IsFramePartOfIBSplit
(
nsIFrame
*
aFrame
)
{
bool
result
=
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_PART_OF_IBSPLIT
)
!
=
0
;
MOZ_ASSERT
(
!
result
|
|
static_cast
<
nsBlockFrame
*
>
(
do_QueryFrame
(
aFrame
)
)
|
|
static_cast
<
nsInlineFrame
*
>
(
do_QueryFrame
(
aFrame
)
)
"
only
block
/
inline
frames
can
have
NS_FRAME_PART_OF_IBSPLIT
"
)
;
return
result
;
}
static
nsContainerFrame
*
GetIBSplitSibling
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
IsFramePartOfIBSplit
(
aFrame
)
"
Shouldn
'
t
call
this
"
)
;
return
aFrame
-
>
FirstContinuation
(
)
-
>
GetProperty
(
nsIFrame
:
:
IBSplitSibling
(
)
)
;
}
static
nsContainerFrame
*
GetIBSplitPrevSibling
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
IsFramePartOfIBSplit
(
aFrame
)
"
Shouldn
'
t
call
this
"
)
;
return
aFrame
-
>
FirstContinuation
(
)
-
>
GetProperty
(
nsIFrame
:
:
IBSplitPrevSibling
(
)
)
;
}
static
nsContainerFrame
*
GetLastIBSplitSibling
(
nsIFrame
*
aFrame
)
{
for
(
nsIFrame
*
frame
=
aFrame
*
next
;
;
frame
=
next
)
{
next
=
GetIBSplitSibling
(
frame
)
;
if
(
!
next
)
{
return
static_cast
<
nsContainerFrame
*
>
(
frame
)
;
}
}
NS_NOTREACHED
(
"
unreachable
code
"
)
;
return
nullptr
;
}
static
void
SetFrameIsIBSplit
(
nsContainerFrame
*
aFrame
nsContainerFrame
*
aIBSplitSibling
)
{
MOZ_ASSERT
(
aFrame
"
bad
args
!
"
)
;
NS_ASSERTION
(
!
aFrame
-
>
GetPrevContinuation
(
)
"
assigning
ib
-
split
sibling
to
other
than
first
continuation
!
"
)
;
NS_ASSERTION
(
!
aFrame
-
>
GetNextContinuation
(
)
|
|
IsFramePartOfIBSplit
(
aFrame
-
>
GetNextContinuation
(
)
)
"
should
have
no
non
-
ib
-
split
continuations
here
"
)
;
aFrame
-
>
AddStateBits
(
NS_FRAME_PART_OF_IBSPLIT
)
;
if
(
aIBSplitSibling
)
{
NS_ASSERTION
(
!
aIBSplitSibling
-
>
GetPrevContinuation
(
)
"
assigning
something
other
than
the
first
continuation
as
the
"
"
ib
-
split
sibling
"
)
;
aFrame
-
>
SetProperty
(
nsIFrame
:
:
IBSplitSibling
(
)
aIBSplitSibling
)
;
aIBSplitSibling
-
>
SetProperty
(
nsIFrame
:
:
IBSplitPrevSibling
(
)
aFrame
)
;
}
}
static
nsIFrame
*
GetIBContainingBlockFor
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
IsFramePartOfIBSplit
(
aFrame
)
"
GetIBContainingBlockFor
(
)
should
only
be
called
on
known
IB
frames
"
)
;
nsIFrame
*
parentFrame
;
do
{
parentFrame
=
aFrame
-
>
GetParent
(
)
;
if
(
!
parentFrame
)
{
NS_ERROR
(
"
no
unsplit
block
frame
in
IB
hierarchy
"
)
;
return
aFrame
;
}
if
(
!
IsFramePartOfIBSplit
(
parentFrame
)
&
&
!
parentFrame
-
>
Style
(
)
-
>
GetPseudo
(
)
)
break
;
aFrame
=
parentFrame
;
}
while
(
1
)
;
NS_ASSERTION
(
parentFrame
"
no
normal
ancestor
found
for
ib
-
split
frame
"
"
in
GetIBContainingBlockFor
"
)
;
NS_ASSERTION
(
parentFrame
!
=
aFrame
"
parentFrame
is
actually
the
child
frame
-
bogus
reslt
"
)
;
return
parentFrame
;
}
static
bool
ParentIsWrapperAnonBox
(
nsIFrame
*
aParent
)
{
nsIFrame
*
maybeAnonBox
=
aParent
;
if
(
maybeAnonBox
-
>
Style
(
)
-
>
GetPseudo
(
)
=
=
nsCSSAnonBoxes
:
:
cellContent
)
{
maybeAnonBox
=
maybeAnonBox
-
>
GetParent
(
)
;
}
return
maybeAnonBox
-
>
Style
(
)
-
>
IsWrapperAnonBox
(
)
;
}
static
void
FindFirstBlock
(
nsFrameList
:
:
FrameLinkEnumerator
&
aLink
)
{
for
(
;
!
aLink
.
AtEnd
(
)
;
aLink
.
Next
(
)
)
{
if
(
!
aLink
.
NextFrame
(
)
-
>
IsInlineOutside
(
)
)
{
return
;
}
}
}
static
nsFrameList
:
:
FrameLinkEnumerator
FindFirstNonBlock
(
const
nsFrameList
&
aList
)
{
nsFrameList
:
:
FrameLinkEnumerator
link
(
aList
)
;
for
(
;
!
link
.
AtEnd
(
)
;
link
.
Next
(
)
)
{
if
(
link
.
NextFrame
(
)
-
>
IsInlineOutside
(
)
)
{
break
;
}
}
return
link
;
}
inline
void
SetInitialSingleChild
(
nsContainerFrame
*
aParent
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
!
aFrame
-
>
GetNextSibling
(
)
"
Should
be
using
a
frame
list
"
)
;
nsFrameList
temp
(
aFrame
aFrame
)
;
aParent
-
>
SetInitialChildList
(
kPrincipalList
temp
)
;
}
struct
nsFrameItems
:
public
nsFrameList
{
void
AddChild
(
nsIFrame
*
aChild
)
;
}
;
void
nsFrameItems
:
:
AddChild
(
nsIFrame
*
aChild
)
{
MOZ_ASSERT
(
aChild
"
nsFrameItems
:
:
AddChild
"
)
;
if
(
IsEmpty
(
)
)
{
SetFrames
(
aChild
)
;
}
else
{
NS_ASSERTION
(
aChild
!
=
mLastChild
"
Same
frame
being
added
to
frame
list
twice
?
"
)
;
mLastChild
-
>
SetNextSibling
(
aChild
)
;
mLastChild
=
nsLayoutUtils
:
:
GetLastSibling
(
aChild
)
;
}
}
struct
nsAbsoluteItems
:
nsFrameItems
{
nsContainerFrame
*
containingBlock
;
explicit
nsAbsoluteItems
(
nsContainerFrame
*
aContainingBlock
)
;
#
ifdef
DEBUG
~
nsAbsoluteItems
(
)
{
NS_ASSERTION
(
!
FirstChild
(
)
"
Dangling
child
list
.
Someone
forgot
to
insert
it
?
"
)
;
}
#
endif
void
AddChild
(
nsIFrame
*
aChild
)
;
}
;
nsAbsoluteItems
:
:
nsAbsoluteItems
(
nsContainerFrame
*
aContainingBlock
)
:
containingBlock
(
aContainingBlock
)
{
}
void
nsAbsoluteItems
:
:
AddChild
(
nsIFrame
*
aChild
)
{
aChild
-
>
AddStateBits
(
NS_FRAME_OUT_OF_FLOW
)
;
NS_ASSERTION
(
aChild
-
>
GetPlaceholderFrame
(
)
"
Child
without
placeholder
being
added
to
nsAbsoluteItems
?
"
)
;
nsFrameItems
:
:
AddChild
(
aChild
)
;
}
class
MOZ_STACK_CLASS
nsFrameConstructorSaveState
{
public
:
typedef
nsIFrame
:
:
ChildListID
ChildListID
;
nsFrameConstructorSaveState
(
)
;
~
nsFrameConstructorSaveState
(
)
;
private
:
nsAbsoluteItems
*
mItems
;
nsAbsoluteItems
mSavedItems
;
ChildListID
mChildListID
;
nsFrameConstructorState
*
mState
;
nsAbsoluteItems
mSavedFixedItems
;
bool
mSavedFixedPosIsAbsPos
;
friend
class
nsFrameConstructorState
;
}
;
struct
PendingBinding
:
public
LinkedListElement
<
PendingBinding
>
{
#
ifdef
NS_BUILD_REFCNT_LOGGING
PendingBinding
(
)
{
MOZ_COUNT_CTOR
(
PendingBinding
)
;
}
~
PendingBinding
(
)
{
MOZ_COUNT_DTOR
(
PendingBinding
)
;
}
#
endif
RefPtr
<
nsXBLBinding
>
mBinding
;
}
;
class
MOZ_STACK_CLASS
nsFrameConstructorState
{
public
:
typedef
nsIFrame
:
:
ChildListID
ChildListID
;
nsPresContext
*
mPresContext
;
nsIPresShell
*
mPresShell
;
nsFrameManager
*
mFrameManager
;
#
ifdef
MOZ_XUL
nsAbsoluteItems
mPopupItems
;
#
endif
nsAbsoluteItems
mFixedItems
;
nsAbsoluteItems
mAbsoluteItems
;
nsAbsoluteItems
mFloatedItems
;
nsAbsoluteItems
mTopLayerFixedItems
;
nsAbsoluteItems
mTopLayerAbsoluteItems
;
nsCOMPtr
<
nsILayoutHistoryState
>
mFrameState
;
nsFrameState
mAdditionalStateBits
;
bool
mFixedPosIsAbsPos
;
bool
mHavePendingPopupgroup
;
bool
mCreatingExtraFrames
;
nsCOMArray
<
nsIContent
>
mGeneratedTextNodesWithInitializer
;
nsFrameConstructorState
(
nsIPresShell
*
aPresShell
nsContainerFrame
*
aFixedContainingBlock
nsContainerFrame
*
aAbsoluteContainingBlock
nsContainerFrame
*
aFloatContainingBlock
already_AddRefed
<
nsILayoutHistoryState
>
aHistoryState
)
;
nsFrameConstructorState
(
nsIPresShell
*
aPresShell
nsContainerFrame
*
aFixedContainingBlock
nsContainerFrame
*
aAbsoluteContainingBlock
nsContainerFrame
*
aFloatContainingBlock
)
;
~
nsFrameConstructorState
(
)
;
void
PushAbsoluteContainingBlock
(
nsContainerFrame
*
aNewAbsoluteContainingBlock
nsIFrame
*
aPositionedFrame
nsFrameConstructorSaveState
&
aSaveState
)
;
void
PushFloatContainingBlock
(
nsContainerFrame
*
aNewFloatContainingBlock
nsFrameConstructorSaveState
&
aSaveState
)
;
nsContainerFrame
*
GetGeometricParent
(
const
nsStyleDisplay
*
aStyleDisplay
nsContainerFrame
*
aContentParentFrame
)
const
;
void
AddChild
(
nsIFrame
*
aNewFrame
nsFrameItems
&
aFrameItems
nsIContent
*
aContent
nsContainerFrame
*
aParentFrame
bool
aCanBePositioned
=
true
bool
aCanBeFloated
=
true
bool
aIsOutOfFlowPopup
=
false
bool
aInsertAfter
=
false
nsIFrame
*
aInsertAfterFrame
=
nullptr
)
;
nsAbsoluteItems
&
GetFixedItems
(
)
{
return
mFixedPosIsAbsPos
?
mAbsoluteItems
:
mFixedItems
;
}
const
nsAbsoluteItems
&
GetFixedItems
(
)
const
{
return
mFixedPosIsAbsPos
?
mAbsoluteItems
:
mFixedItems
;
}
class
PendingBindingAutoPusher
;
friend
class
PendingBindingAutoPusher
;
class
MOZ_STACK_CLASS
PendingBindingAutoPusher
{
public
:
PendingBindingAutoPusher
(
nsFrameConstructorState
&
aState
PendingBinding
*
aPendingBinding
)
:
mState
(
aState
)
mPendingBinding
(
aState
.
mCurrentPendingBindingInsertionPoint
)
{
if
(
aPendingBinding
)
{
aState
.
mCurrentPendingBindingInsertionPoint
=
aPendingBinding
;
}
}
~
PendingBindingAutoPusher
(
)
{
mState
.
mCurrentPendingBindingInsertionPoint
=
mPendingBinding
;
}
private
:
nsFrameConstructorState
&
mState
;
PendingBinding
*
mPendingBinding
;
}
;
void
AddPendingBinding
(
PendingBinding
*
aPendingBinding
)
{
if
(
mCurrentPendingBindingInsertionPoint
)
{
mCurrentPendingBindingInsertionPoint
-
>
setPrevious
(
aPendingBinding
)
;
}
else
{
mPendingBindings
.
insertBack
(
aPendingBinding
)
;
}
}
protected
:
friend
class
nsFrameConstructorSaveState
;
void
ProcessFrameInsertions
(
nsAbsoluteItems
&
aFrameItems
ChildListID
aChildListID
)
;
nsAbsoluteItems
*
GetOutOfFlowFrameItems
(
nsIFrame
*
aNewFrame
bool
aCanBePositioned
bool
aCanBeFloated
bool
aIsOutOfFlowPopup
nsFrameState
*
aPlaceholderType
)
;
void
ConstructBackdropFrameFor
(
nsIContent
*
aContent
nsIFrame
*
aFrame
)
;
LinkedList
<
PendingBinding
>
mPendingBindings
;
PendingBinding
*
mCurrentPendingBindingInsertionPoint
;
}
;
nsFrameConstructorState
:
:
nsFrameConstructorState
(
nsIPresShell
*
aPresShell
nsContainerFrame
*
aFixedContainingBlock
nsContainerFrame
*
aAbsoluteContainingBlock
nsContainerFrame
*
aFloatContainingBlock
already_AddRefed
<
nsILayoutHistoryState
>
aHistoryState
)
:
mPresContext
(
aPresShell
-
>
GetPresContext
(
)
)
mPresShell
(
aPresShell
)
mFrameManager
(
aPresShell
-
>
FrameConstructor
(
)
)
#
ifdef
MOZ_XUL
mPopupItems
(
nullptr
)
#
endif
mFixedItems
(
aFixedContainingBlock
)
mAbsoluteItems
(
aAbsoluteContainingBlock
)
mFloatedItems
(
aFloatContainingBlock
)
mTopLayerFixedItems
(
static_cast
<
nsContainerFrame
*
>
(
mFrameManager
-
>
GetRootFrame
(
)
)
)
mTopLayerAbsoluteItems
(
aPresShell
-
>
FrameConstructor
(
)
-
>
GetDocElementContainingBlock
(
)
)
mFrameState
(
aHistoryState
)
mAdditionalStateBits
(
nsFrameState
(
0
)
)
mFixedPosIsAbsPos
(
aFixedContainingBlock
=
=
aAbsoluteContainingBlock
)
mHavePendingPopupgroup
(
false
)
mCreatingExtraFrames
(
false
)
mCurrentPendingBindingInsertionPoint
(
nullptr
)
{
#
ifdef
MOZ_XUL
nsIRootBox
*
rootBox
=
nsIRootBox
:
:
GetRootBox
(
aPresShell
)
;
if
(
rootBox
)
{
mPopupItems
.
containingBlock
=
rootBox
-
>
GetPopupSetFrame
(
)
;
}
#
endif
MOZ_COUNT_CTOR
(
nsFrameConstructorState
)
;
}
nsFrameConstructorState
:
:
nsFrameConstructorState
(
nsIPresShell
*
aPresShell
nsContainerFrame
*
aFixedContainingBlock
nsContainerFrame
*
aAbsoluteContainingBlock
nsContainerFrame
*
aFloatContainingBlock
)
:
nsFrameConstructorState
(
aPresShell
aFixedContainingBlock
aAbsoluteContainingBlock
aFloatContainingBlock
aPresShell
-
>
GetDocument
(
)
-
>
GetLayoutHistoryState
(
)
)
{
}
nsFrameConstructorState
:
:
~
nsFrameConstructorState
(
)
{
MOZ_COUNT_DTOR
(
nsFrameConstructorState
)
;
ProcessFrameInsertions
(
mTopLayerFixedItems
nsIFrame
:
:
kFixedList
)
;
ProcessFrameInsertions
(
mTopLayerAbsoluteItems
nsIFrame
:
:
kAbsoluteList
)
;
ProcessFrameInsertions
(
mFloatedItems
nsIFrame
:
:
kFloatList
)
;
ProcessFrameInsertions
(
mAbsoluteItems
nsIFrame
:
:
kAbsoluteList
)
;
ProcessFrameInsertions
(
mFixedItems
nsIFrame
:
:
kFixedList
)
;
#
ifdef
MOZ_XUL
ProcessFrameInsertions
(
mPopupItems
nsIFrame
:
:
kPopupList
)
;
#
endif
for
(
int32_t
i
=
mGeneratedTextNodesWithInitializer
.
Count
(
)
-
1
;
i
>
=
0
;
-
-
i
)
{
mGeneratedTextNodesWithInitializer
[
i
]
-
>
DeleteProperty
(
nsGkAtoms
:
:
genConInitializerProperty
)
;
}
if
(
!
mPendingBindings
.
isEmpty
(
)
)
{
nsBindingManager
*
bindingManager
=
mPresShell
-
>
GetDocument
(
)
-
>
BindingManager
(
)
;
do
{
nsAutoPtr
<
PendingBinding
>
pendingBinding
;
pendingBinding
=
mPendingBindings
.
popFirst
(
)
;
bindingManager
-
>
AddToAttachedQueue
(
pendingBinding
-
>
mBinding
)
;
}
while
(
!
mPendingBindings
.
isEmpty
(
)
)
;
mCurrentPendingBindingInsertionPoint
=
nullptr
;
}
}
static
nsContainerFrame
*
AdjustAbsoluteContainingBlock
(
nsContainerFrame
*
aContainingBlockIn
)
{
if
(
!
aContainingBlockIn
)
{
return
nullptr
;
}
return
static_cast
<
nsContainerFrame
*
>
(
aContainingBlockIn
-
>
FirstContinuation
(
)
)
;
}
void
nsFrameConstructorState
:
:
PushAbsoluteContainingBlock
(
nsContainerFrame
*
aNewAbsoluteContainingBlock
nsIFrame
*
aPositionedFrame
nsFrameConstructorSaveState
&
aSaveState
)
{
aSaveState
.
mItems
=
&
mAbsoluteItems
;
aSaveState
.
mSavedItems
=
mAbsoluteItems
;
aSaveState
.
mChildListID
=
nsIFrame
:
:
kAbsoluteList
;
aSaveState
.
mState
=
this
;
aSaveState
.
mSavedFixedPosIsAbsPos
=
mFixedPosIsAbsPos
;
if
(
mFixedPosIsAbsPos
)
{
aSaveState
.
mSavedFixedItems
=
mFixedItems
;
mFixedItems
=
mAbsoluteItems
;
}
mAbsoluteItems
=
nsAbsoluteItems
(
AdjustAbsoluteContainingBlock
(
aNewAbsoluteContainingBlock
)
)
;
mFixedPosIsAbsPos
=
aPositionedFrame
&
&
aPositionedFrame
-
>
IsFixedPosContainingBlock
(
)
;
if
(
aNewAbsoluteContainingBlock
)
{
aNewAbsoluteContainingBlock
-
>
MarkAsAbsoluteContainingBlock
(
)
;
}
}
void
nsFrameConstructorState
:
:
PushFloatContainingBlock
(
nsContainerFrame
*
aNewFloatContainingBlock
nsFrameConstructorSaveState
&
aSaveState
)
{
MOZ_ASSERT
(
!
aNewFloatContainingBlock
|
|
aNewFloatContainingBlock
-
>
IsFloatContainingBlock
(
)
"
Please
push
a
real
float
containing
block
!
"
)
;
NS_ASSERTION
(
!
aNewFloatContainingBlock
|
|
!
ShouldSuppressFloatingOfDescendants
(
aNewFloatContainingBlock
)
"
We
should
not
push
a
frame
that
is
supposed
to
_suppress_
"
"
floats
as
a
float
containing
block
!
"
)
;
aSaveState
.
mItems
=
&
mFloatedItems
;
aSaveState
.
mSavedItems
=
mFloatedItems
;
aSaveState
.
mChildListID
=
nsIFrame
:
:
kFloatList
;
aSaveState
.
mState
=
this
;
mFloatedItems
=
nsAbsoluteItems
(
aNewFloatContainingBlock
)
;
}
nsContainerFrame
*
nsFrameConstructorState
:
:
GetGeometricParent
(
const
nsStyleDisplay
*
aStyleDisplay
nsContainerFrame
*
aContentParentFrame
)
const
{
MOZ_ASSERT
(
aStyleDisplay
"
Must
have
display
struct
!
"
)
;
if
(
aContentParentFrame
&
&
nsSVGUtils
:
:
IsInSVGTextSubtree
(
aContentParentFrame
)
)
{
return
aContentParentFrame
;
}
if
(
aStyleDisplay
-
>
IsFloatingStyle
(
)
&
&
mFloatedItems
.
containingBlock
)
{
NS_ASSERTION
(
!
aStyleDisplay
-
>
IsAbsolutelyPositionedStyle
(
)
"
Absolutely
positioned
_and_
floating
?
"
)
;
return
mFloatedItems
.
containingBlock
;
}
if
(
aStyleDisplay
-
>
mTopLayer
!
=
NS_STYLE_TOP_LAYER_NONE
)
{
MOZ_ASSERT
(
aStyleDisplay
-
>
mTopLayer
=
=
NS_STYLE_TOP_LAYER_TOP
"
-
moz
-
top
-
layer
should
be
either
none
or
top
"
)
;
MOZ_ASSERT
(
aStyleDisplay
-
>
IsAbsolutelyPositionedStyle
(
)
"
Top
layer
items
should
always
be
absolutely
positioned
"
)
;
if
(
aStyleDisplay
-
>
mPosition
=
=
NS_STYLE_POSITION_FIXED
)
{
MOZ_ASSERT
(
mTopLayerFixedItems
.
containingBlock
"
No
root
frame
?
"
)
;
return
mTopLayerFixedItems
.
containingBlock
;
}
MOZ_ASSERT
(
aStyleDisplay
-
>
mPosition
=
=
NS_STYLE_POSITION_ABSOLUTE
)
;
MOZ_ASSERT
(
mTopLayerAbsoluteItems
.
containingBlock
)
;
return
mTopLayerAbsoluteItems
.
containingBlock
;
}
if
(
aStyleDisplay
-
>
mPosition
=
=
NS_STYLE_POSITION_ABSOLUTE
&
&
mAbsoluteItems
.
containingBlock
)
{
return
mAbsoluteItems
.
containingBlock
;
}
if
(
aStyleDisplay
-
>
mPosition
=
=
NS_STYLE_POSITION_FIXED
&
&
GetFixedItems
(
)
.
containingBlock
)
{
return
GetFixedItems
(
)
.
containingBlock
;
}
return
aContentParentFrame
;
}
nsAbsoluteItems
*
nsFrameConstructorState
:
:
GetOutOfFlowFrameItems
(
nsIFrame
*
aNewFrame
bool
aCanBePositioned
bool
aCanBeFloated
bool
aIsOutOfFlowPopup
nsFrameState
*
aPlaceholderType
)
{
#
ifdef
MOZ_XUL
if
(
MOZ_UNLIKELY
(
aIsOutOfFlowPopup
)
)
{
MOZ_ASSERT
(
mPopupItems
.
containingBlock
"
Must
have
a
popup
set
frame
!
"
)
;
*
aPlaceholderType
=
PLACEHOLDER_FOR_POPUP
;
return
&
mPopupItems
;
}
#
endif
if
(
aCanBeFloated
&
&
aNewFrame
-
>
IsFloating
(
)
)
{
*
aPlaceholderType
=
PLACEHOLDER_FOR_FLOAT
;
return
&
mFloatedItems
;
}
if
(
aCanBePositioned
)
{
const
nsStyleDisplay
*
disp
=
aNewFrame
-
>
StyleDisplay
(
)
;
if
(
disp
-
>
mTopLayer
!
=
NS_STYLE_TOP_LAYER_NONE
)
{
*
aPlaceholderType
=
PLACEHOLDER_FOR_TOPLAYER
;
if
(
disp
-
>
mPosition
=
=
NS_STYLE_POSITION_FIXED
)
{
*
aPlaceholderType
|
=
PLACEHOLDER_FOR_FIXEDPOS
;
return
&
mTopLayerFixedItems
;
}
*
aPlaceholderType
|
=
PLACEHOLDER_FOR_ABSPOS
;
return
&
mTopLayerAbsoluteItems
;
}
if
(
disp
-
>
mPosition
=
=
NS_STYLE_POSITION_ABSOLUTE
)
{
*
aPlaceholderType
=
PLACEHOLDER_FOR_ABSPOS
;
return
&
mAbsoluteItems
;
}
if
(
disp
-
>
mPosition
=
=
NS_STYLE_POSITION_FIXED
)
{
*
aPlaceholderType
=
PLACEHOLDER_FOR_FIXEDPOS
;
return
&
GetFixedItems
(
)
;
}
}
return
nullptr
;
}
void
nsFrameConstructorState
:
:
ConstructBackdropFrameFor
(
nsIContent
*
aContent
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
-
>
StyleDisplay
(
)
-
>
mTopLayer
=
=
NS_STYLE_TOP_LAYER_TOP
)
;
nsContainerFrame
*
frame
=
do_QueryFrame
(
aFrame
)
;
if
(
!
frame
)
{
NS_WARNING
(
"
Cannot
create
backdrop
frame
for
non
-
container
frame
"
)
;
return
;
}
RefPtr
<
ComputedStyle
>
style
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolvePseudoElementStyle
(
aContent
-
>
AsElement
(
)
CSSPseudoElementType
:
:
backdrop
nullptr
nullptr
)
;
MOZ_ASSERT
(
style
-
>
StyleDisplay
(
)
-
>
mTopLayer
=
=
NS_STYLE_TOP_LAYER_TOP
)
;
nsContainerFrame
*
parentFrame
=
GetGeometricParent
(
style
-
>
StyleDisplay
(
)
nullptr
)
;
nsBackdropFrame
*
backdropFrame
=
new
(
mPresShell
)
nsBackdropFrame
(
style
)
;
backdropFrame
-
>
Init
(
aContent
parentFrame
nullptr
)
;
nsFrameState
placeholderType
;
nsAbsoluteItems
*
frameItems
=
GetOutOfFlowFrameItems
(
backdropFrame
true
true
false
&
placeholderType
)
;
MOZ_ASSERT
(
placeholderType
&
PLACEHOLDER_FOR_TOPLAYER
)
;
nsIFrame
*
placeholder
=
nsCSSFrameConstructor
:
:
CreatePlaceholderFrameFor
(
mPresShell
aContent
backdropFrame
frame
nullptr
placeholderType
)
;
nsFrameList
temp
(
placeholder
placeholder
)
;
frame
-
>
SetInitialChildList
(
nsIFrame
:
:
kBackdropList
temp
)
;
frameItems
-
>
AddChild
(
backdropFrame
)
;
}
void
nsFrameConstructorState
:
:
AddChild
(
nsIFrame
*
aNewFrame
nsFrameItems
&
aFrameItems
nsIContent
*
aContent
nsContainerFrame
*
aParentFrame
bool
aCanBePositioned
bool
aCanBeFloated
bool
aIsOutOfFlowPopup
bool
aInsertAfter
nsIFrame
*
aInsertAfterFrame
)
{
MOZ_ASSERT
(
!
aNewFrame
-
>
GetNextSibling
(
)
"
Shouldn
'
t
happen
"
)
;
nsFrameState
placeholderType
;
nsAbsoluteItems
*
outOfFlowFrameItems
=
GetOutOfFlowFrameItems
(
aNewFrame
aCanBePositioned
aCanBeFloated
aIsOutOfFlowPopup
&
placeholderType
)
;
nsFrameItems
*
frameItems
;
if
(
outOfFlowFrameItems
&
&
outOfFlowFrameItems
-
>
containingBlock
)
{
MOZ_ASSERT
(
aNewFrame
-
>
GetParent
(
)
=
=
outOfFlowFrameItems
-
>
containingBlock
"
Parent
of
the
frame
is
not
the
containing
block
?
"
)
;
frameItems
=
outOfFlowFrameItems
;
}
else
{
frameItems
=
&
aFrameItems
;
placeholderType
=
nsFrameState
(
0
)
;
}
if
(
placeholderType
)
{
NS_ASSERTION
(
frameItems
!
=
&
aFrameItems
"
Putting
frame
in
-
flow
_and_
want
a
placeholder
?
"
)
;
nsIFrame
*
placeholderFrame
=
nsCSSFrameConstructor
:
:
CreatePlaceholderFrameFor
(
mPresShell
aContent
aNewFrame
aParentFrame
nullptr
placeholderType
)
;
placeholderFrame
-
>
AddStateBits
(
mAdditionalStateBits
)
;
aFrameItems
.
AddChild
(
placeholderFrame
)
;
if
(
placeholderType
&
PLACEHOLDER_FOR_TOPLAYER
)
{
ConstructBackdropFrameFor
(
aContent
aNewFrame
)
;
}
}
#
ifdef
DEBUG
else
{
NS_ASSERTION
(
aNewFrame
-
>
GetParent
(
)
=
=
aParentFrame
"
In
-
flow
frame
has
wrong
parent
"
)
;
}
#
endif
if
(
aInsertAfter
)
{
frameItems
-
>
InsertFrame
(
nullptr
aInsertAfterFrame
aNewFrame
)
;
}
else
{
frameItems
-
>
AddChild
(
aNewFrame
)
;
}
}
void
nsFrameConstructorState
:
:
ProcessFrameInsertions
(
nsAbsoluteItems
&
aFrameItems
ChildListID
aChildListID
)
{
#
define
NS_NONXUL_LIST_TEST
(
&
aFrameItems
=
=
&
mFloatedItems
&
&
\
aChildListID
=
=
nsIFrame
:
:
kFloatList
)
|
|
\
(
(
&
aFrameItems
=
=
&
mAbsoluteItems
|
|
\
&
aFrameItems
=
=
&
mTopLayerAbsoluteItems
)
&
&
\
aChildListID
=
=
nsIFrame
:
:
kAbsoluteList
)
|
|
\
(
(
&
aFrameItems
=
=
&
mFixedItems
|
|
\
&
aFrameItems
=
=
&
mTopLayerFixedItems
)
&
&
\
aChildListID
=
=
nsIFrame
:
:
kFixedList
)
#
ifdef
MOZ_XUL
MOZ_ASSERT
(
NS_NONXUL_LIST_TEST
|
|
(
&
aFrameItems
=
=
&
mPopupItems
&
&
aChildListID
=
=
nsIFrame
:
:
kPopupList
)
"
Unexpected
aFrameItems
/
aChildListID
combination
"
)
;
#
else
MOZ_ASSERT
(
NS_NONXUL_LIST_TEST
"
Unexpected
aFrameItems
/
aChildListID
combination
"
)
;
#
endif
if
(
aFrameItems
.
IsEmpty
(
)
)
{
return
;
}
nsContainerFrame
*
containingBlock
=
aFrameItems
.
containingBlock
;
NS_ASSERTION
(
containingBlock
"
Child
list
without
containing
block
?
"
)
;
if
(
aChildListID
=
=
nsIFrame
:
:
kFixedList
)
{
aChildListID
=
containingBlock
-
>
GetAbsoluteListID
(
)
;
}
const
nsFrameList
&
childList
=
containingBlock
-
>
GetChildList
(
aChildListID
)
;
if
(
childList
.
IsEmpty
(
)
&
&
(
containingBlock
-
>
GetStateBits
(
)
&
NS_FRAME_FIRST_REFLOW
)
)
{
if
(
aChildListID
=
=
containingBlock
-
>
GetAbsoluteListID
(
)
)
{
containingBlock
-
>
GetAbsoluteContainingBlock
(
)
-
>
SetInitialChildList
(
containingBlock
aChildListID
aFrameItems
)
;
}
else
{
containingBlock
-
>
SetInitialChildList
(
aChildListID
aFrameItems
)
;
}
}
else
if
(
aChildListID
=
=
nsIFrame
:
:
kFixedList
|
|
aChildListID
=
=
nsIFrame
:
:
kAbsoluteList
)
{
mFrameManager
-
>
AppendFrames
(
containingBlock
aChildListID
aFrameItems
)
;
}
else
{
nsIFrame
*
lastChild
=
childList
.
LastChild
(
)
;
nsIFrame
*
firstNewFrame
=
aFrameItems
.
FirstChild
(
)
;
AutoTArray
<
nsIFrame
*
20
>
firstNewFrameAncestors
;
nsIFrame
*
notCommonAncestor
=
nullptr
;
if
(
lastChild
)
{
notCommonAncestor
=
nsLayoutUtils
:
:
FillAncestors
(
firstNewFrame
containingBlock
&
firstNewFrameAncestors
)
;
}
if
(
!
lastChild
|
|
nsLayoutUtils
:
:
CompareTreePosition
(
lastChild
firstNewFrame
firstNewFrameAncestors
notCommonAncestor
?
containingBlock
:
nullptr
)
<
0
)
{
mFrameManager
-
>
AppendFrames
(
containingBlock
aChildListID
aFrameItems
)
;
}
else
{
AutoTArray
<
nsIFrame
*
128
>
children
;
for
(
nsIFrame
*
f
=
childList
.
FirstChild
(
)
;
f
!
=
lastChild
;
f
=
f
-
>
GetNextSibling
(
)
)
{
children
.
AppendElement
(
f
)
;
}
nsIFrame
*
insertionPoint
=
nullptr
;
int32_t
imin
=
0
;
int32_t
max
=
children
.
Length
(
)
;
while
(
max
>
imin
)
{
int32_t
imid
=
imin
+
(
(
max
-
imin
)
/
2
)
;
nsIFrame
*
f
=
children
[
imid
]
;
int32_t
compare
=
nsLayoutUtils
:
:
CompareTreePosition
(
f
firstNewFrame
firstNewFrameAncestors
notCommonAncestor
?
containingBlock
:
nullptr
)
;
if
(
compare
>
0
)
{
max
=
imid
;
insertionPoint
=
imid
>
0
?
children
[
imid
-
1
]
:
nullptr
;
}
else
if
(
compare
<
0
)
{
imin
=
imid
+
1
;
insertionPoint
=
f
;
}
else
{
NS_WARNING
(
"
Something
odd
happening
?
?
?
"
)
;
insertionPoint
=
nullptr
;
for
(
uint32_t
i
=
0
;
i
<
children
.
Length
(
)
;
+
+
i
)
{
nsIFrame
*
f
=
children
[
i
]
;
if
(
nsLayoutUtils
:
:
CompareTreePosition
(
f
firstNewFrame
firstNewFrameAncestors
notCommonAncestor
?
containingBlock
:
nullptr
)
>
0
)
{
break
;
}
insertionPoint
=
f
;
}
break
;
}
}
mFrameManager
-
>
InsertFrames
(
containingBlock
aChildListID
insertionPoint
aFrameItems
)
;
}
}
MOZ_ASSERT
(
aFrameItems
.
IsEmpty
(
)
"
How
did
that
happen
?
"
)
;
}
nsFrameConstructorSaveState
:
:
nsFrameConstructorSaveState
(
)
:
mItems
(
nullptr
)
mSavedItems
(
nullptr
)
mChildListID
(
kPrincipalList
)
mState
(
nullptr
)
mSavedFixedItems
(
nullptr
)
mSavedFixedPosIsAbsPos
(
false
)
{
}
nsFrameConstructorSaveState
:
:
~
nsFrameConstructorSaveState
(
)
{
if
(
mItems
)
{
NS_ASSERTION
(
mState
"
Can
'
t
have
mItems
set
without
having
a
state
!
"
)
;
mState
-
>
ProcessFrameInsertions
(
*
mItems
mChildListID
)
;
*
mItems
=
mSavedItems
;
#
ifdef
DEBUG
mSavedItems
.
Clear
(
)
;
#
endif
if
(
mItems
=
=
&
mState
-
>
mAbsoluteItems
)
{
mState
-
>
mFixedPosIsAbsPos
=
mSavedFixedPosIsAbsPos
;
if
(
mSavedFixedPosIsAbsPos
)
{
mState
-
>
mAbsoluteItems
=
mState
-
>
mFixedItems
;
mState
-
>
mFixedItems
=
mSavedFixedItems
;
#
ifdef
DEBUG
mSavedFixedItems
.
Clear
(
)
;
#
endif
}
}
NS_ASSERTION
(
!
mItems
-
>
LastChild
(
)
|
|
!
mItems
-
>
LastChild
(
)
-
>
GetNextSibling
(
)
"
Something
corrupted
our
list
"
)
;
}
}
static
void
MoveChildrenTo
(
nsIFrame
*
aOldParent
nsContainerFrame
*
aNewParent
nsFrameList
&
aFrameList
)
{
bool
sameGrandParent
=
aOldParent
-
>
GetParent
(
)
=
=
aNewParent
-
>
GetParent
(
)
;
if
(
aNewParent
-
>
HasView
(
)
|
|
aOldParent
-
>
HasView
(
)
|
|
!
sameGrandParent
)
{
nsContainerFrame
:
:
ReparentFrameViewList
(
aFrameList
aOldParent
aNewParent
)
;
}
for
(
nsFrameList
:
:
Enumerator
e
(
aFrameList
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
)
{
e
.
get
(
)
-
>
SetParent
(
aNewParent
)
;
}
if
(
aNewParent
-
>
PrincipalChildList
(
)
.
IsEmpty
(
)
&
&
(
aNewParent
-
>
GetStateBits
(
)
&
NS_FRAME_FIRST_REFLOW
)
)
{
aNewParent
-
>
SetInitialChildList
(
kPrincipalList
aFrameList
)
;
}
else
{
aNewParent
-
>
AppendFrames
(
kPrincipalList
aFrameList
)
;
}
}
nsCSSFrameConstructor
:
:
nsCSSFrameConstructor
(
nsIDocument
*
aDocument
nsIPresShell
*
aPresShell
)
:
nsFrameManager
(
aPresShell
)
mDocument
(
aDocument
)
mRootElementFrame
(
nullptr
)
mRootElementStyleFrame
(
nullptr
)
mDocElementContainingBlock
(
nullptr
)
mPageSequenceFrame
(
nullptr
)
mFirstFreeFCItem
(
nullptr
)
mFCItemsInUse
(
0
)
mCurrentDepth
(
0
)
mQuotesDirty
(
false
)
mCountersDirty
(
false
)
mIsDestroyingFrameTree
(
false
)
mHasRootAbsPosContainingBlock
(
false
)
mAlwaysCreateFramesForIgnorableWhitespace
(
false
)
{
#
ifdef
DEBUG
static
bool
gFirstTime
=
true
;
if
(
gFirstTime
)
{
gFirstTime
=
false
;
char
*
flags
=
PR_GetEnv
(
"
GECKO_FRAMECTOR_DEBUG_FLAGS
"
)
;
if
(
flags
)
{
bool
error
=
false
;
for
(
;
;
)
{
char
*
comma
=
PL_strchr
(
flags
'
'
)
;
if
(
comma
)
*
comma
=
'
\
0
'
;
bool
found
=
false
;
FrameCtorDebugFlags
*
flag
=
gFlags
;
FrameCtorDebugFlags
*
limit
=
gFlags
+
NUM_DEBUG_FLAGS
;
while
(
flag
<
limit
)
{
if
(
PL_strcasecmp
(
flag
-
>
name
flags
)
=
=
0
)
{
*
(
flag
-
>
on
)
=
true
;
printf
(
"
nsCSSFrameConstructor
:
setting
%
s
debug
flag
on
\
n
"
flag
-
>
name
)
;
found
=
true
;
break
;
}
+
+
flag
;
}
if
(
!
found
)
error
=
true
;
if
(
!
comma
)
break
;
*
comma
=
'
'
;
flags
=
comma
+
1
;
}
if
(
error
)
{
printf
(
"
Here
are
the
available
GECKO_FRAMECTOR_DEBUG_FLAGS
:
\
n
"
)
;
FrameCtorDebugFlags
*
flag
=
gFlags
;
FrameCtorDebugFlags
*
limit
=
gFlags
+
NUM_DEBUG_FLAGS
;
while
(
flag
<
limit
)
{
printf
(
"
%
s
\
n
"
flag
-
>
name
)
;
+
+
flag
;
}
printf
(
"
Note
:
GECKO_FRAMECTOR_DEBUG_FLAGS
is
a
comma
separated
list
of
flag
\
n
"
)
;
printf
(
"
names
(
no
whitespace
)
\
n
"
)
;
}
}
}
#
endif
}
void
nsCSSFrameConstructor
:
:
NotifyDestroyingFrame
(
nsIFrame
*
aFrame
)
{
if
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_GENERATED_CONTENT
)
{
if
(
mQuoteList
.
DestroyNodesFor
(
aFrame
)
)
QuotesDirty
(
)
;
}
if
(
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_HAS_CSS_COUNTER_STYLE
)
&
&
mCounterManager
.
DestroyNodesFor
(
aFrame
)
)
{
CountersDirty
(
)
;
}
RestyleManager
(
)
-
>
NotifyDestroyingFrame
(
aFrame
)
;
}
struct
nsGenConInitializer
{
nsAutoPtr
<
nsGenConNode
>
mNode
;
nsGenConList
*
mList
;
void
(
nsCSSFrameConstructor
:
:
*
mDirtyAll
)
(
)
;
nsGenConInitializer
(
nsGenConNode
*
aNode
nsGenConList
*
aList
void
(
nsCSSFrameConstructor
:
:
*
aDirtyAll
)
(
)
)
:
mNode
(
aNode
)
mList
(
aList
)
mDirtyAll
(
aDirtyAll
)
{
}
}
;
already_AddRefed
<
nsIContent
>
nsCSSFrameConstructor
:
:
CreateGenConTextNode
(
nsFrameConstructorState
&
aState
const
nsString
&
aString
RefPtr
<
nsTextNode
>
*
aText
nsGenConInitializer
*
aInitializer
)
{
RefPtr
<
nsTextNode
>
content
=
new
nsTextNode
(
mDocument
-
>
NodeInfoManager
(
)
)
;
content
-
>
SetText
(
aString
false
)
;
if
(
aText
)
{
*
aText
=
content
;
}
if
(
aInitializer
)
{
content
-
>
SetProperty
(
nsGkAtoms
:
:
genConInitializerProperty
aInitializer
nsINode
:
:
DeleteProperty
<
nsGenConInitializer
>
)
;
aState
.
mGeneratedTextNodesWithInitializer
.
AppendObject
(
content
)
;
}
return
content
.
forget
(
)
;
}
already_AddRefed
<
nsIContent
>
nsCSSFrameConstructor
:
:
CreateGeneratedContent
(
nsFrameConstructorState
&
aState
Element
*
aParentContent
ComputedStyle
*
aComputedStyle
uint32_t
aContentIndex
)
{
const
nsStyleContentData
&
data
=
aComputedStyle
-
>
StyleContent
(
)
-
>
ContentAt
(
aContentIndex
)
;
nsStyleContentType
type
=
data
.
GetType
(
)
;
switch
(
type
)
{
case
eStyleContentType_Image
:
{
imgRequestProxy
*
image
=
data
.
GetImage
(
)
;
if
(
!
image
)
{
return
nullptr
;
}
return
CreateGenConImageContent
(
mDocument
image
)
;
}
case
eStyleContentType_String
:
return
CreateGenConTextNode
(
aState
nsDependentString
(
data
.
GetString
(
)
)
nullptr
nullptr
)
;
case
eStyleContentType_Attr
:
{
const
nsStyleContentAttr
*
attr
=
data
.
GetAttr
(
)
;
RefPtr
<
nsAtom
>
attrName
=
attr
-
>
mName
;
int32_t
attrNameSpace
=
kNameSpaceID_None
;
if
(
RefPtr
<
nsAtom
>
ns
=
attr
-
>
mNamespaceURL
)
{
nsresult
rv
=
nsContentUtils
:
:
NameSpaceManager
(
)
-
>
RegisterNameSpace
(
ns
.
forget
(
)
attrNameSpace
)
;
NS_ENSURE_SUCCESS
(
rv
nullptr
)
;
}
if
(
mDocument
-
>
IsHTMLDocument
(
)
&
&
aParentContent
-
>
IsHTMLElement
(
)
)
{
ToLowerCaseASCII
(
attrName
)
;
}
nsCOMPtr
<
nsIContent
>
content
;
NS_NewAttributeContent
(
mDocument
-
>
NodeInfoManager
(
)
attrNameSpace
attrName
getter_AddRefs
(
content
)
)
;
return
content
.
forget
(
)
;
}
case
eStyleContentType_Counter
:
case
eStyleContentType_Counters
:
{
nsStyleContentData
:
:
CounterFunction
*
counters
=
data
.
GetCounters
(
)
;
nsCounterList
*
counterList
=
mCounterManager
.
CounterListFor
(
counters
-
>
mIdent
)
;
nsCounterUseNode
*
node
=
new
nsCounterUseNode
(
counters
aContentIndex
type
=
=
eStyleContentType_Counters
)
;
nsGenConInitializer
*
initializer
=
new
nsGenConInitializer
(
node
counterList
&
nsCSSFrameConstructor
:
:
CountersDirty
)
;
return
CreateGenConTextNode
(
aState
EmptyString
(
)
&
node
-
>
mText
initializer
)
;
}
case
eStyleContentType_OpenQuote
:
case
eStyleContentType_CloseQuote
:
case
eStyleContentType_NoOpenQuote
:
case
eStyleContentType_NoCloseQuote
:
{
nsQuoteNode
*
node
=
new
nsQuoteNode
(
type
aContentIndex
)
;
nsGenConInitializer
*
initializer
=
new
nsGenConInitializer
(
node
&
mQuoteList
&
nsCSSFrameConstructor
:
:
QuotesDirty
)
;
return
CreateGenConTextNode
(
aState
EmptyString
(
)
&
node
-
>
mText
initializer
)
;
}
case
eStyleContentType_AltContent
:
{
if
(
aParentContent
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
alt
)
)
{
nsCOMPtr
<
nsIContent
>
content
;
NS_NewAttributeContent
(
mDocument
-
>
NodeInfoManager
(
)
kNameSpaceID_None
nsGkAtoms
:
:
alt
getter_AddRefs
(
content
)
)
;
return
content
.
forget
(
)
;
}
if
(
aParentContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
input
)
)
{
if
(
aParentContent
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
value
)
)
{
nsCOMPtr
<
nsIContent
>
content
;
NS_NewAttributeContent
(
mDocument
-
>
NodeInfoManager
(
)
kNameSpaceID_None
nsGkAtoms
:
:
value
getter_AddRefs
(
content
)
)
;
return
content
.
forget
(
)
;
}
nsAutoString
temp
;
nsContentUtils
:
:
GetLocalizedString
(
nsContentUtils
:
:
eFORMS_PROPERTIES
"
Submit
"
temp
)
;
return
CreateGenConTextNode
(
aState
temp
nullptr
nullptr
)
;
}
break
;
}
case
eStyleContentType_Uninitialized
:
NS_NOTREACHED
(
"
uninitialized
content
type
"
)
;
return
nullptr
;
}
return
nullptr
;
}
void
nsCSSFrameConstructor
:
:
CreateGeneratedContentItem
(
nsFrameConstructorState
&
aState
nsContainerFrame
*
aParentFrame
Element
*
aParentContent
ComputedStyle
*
aComputedStyle
CSSPseudoElementType
aPseudoElement
FrameConstructionItemList
&
aItems
)
{
MOZ_ASSERT
(
aPseudoElement
=
=
CSSPseudoElementType
:
:
before
|
|
aPseudoElement
=
=
CSSPseudoElementType
:
:
after
"
unexpected
aPseudoElement
"
)
;
ServoStyleSet
*
styleSet
=
mPresShell
-
>
StyleSet
(
)
;
RefPtr
<
ComputedStyle
>
pseudoComputedStyle
;
pseudoComputedStyle
=
styleSet
-
>
ProbePseudoElementStyle
(
aParentContent
aPseudoElement
aComputedStyle
)
;
if
(
!
pseudoComputedStyle
)
return
;
bool
isBefore
=
aPseudoElement
=
=
CSSPseudoElementType
:
:
before
;
RefPtr
<
NodeInfo
>
nodeInfo
;
nsAtom
*
elemName
=
isBefore
?
nsGkAtoms
:
:
mozgeneratedcontentbefore
:
nsGkAtoms
:
:
mozgeneratedcontentafter
;
nodeInfo
=
mDocument
-
>
NodeInfoManager
(
)
-
>
GetNodeInfo
(
elemName
nullptr
kNameSpaceID_None
nsINode
:
:
ELEMENT_NODE
)
;
nsCOMPtr
<
Element
>
container
;
nsresult
rv
=
NS_NewXMLElement
(
getter_AddRefs
(
container
)
nodeInfo
.
forget
(
)
)
;
if
(
NS_FAILED
(
rv
)
)
return
;
nsAtom
*
property
=
isBefore
?
nsGkAtoms
:
:
beforePseudoProperty
:
nsGkAtoms
:
:
afterPseudoProperty
;
aParentContent
-
>
SetProperty
(
property
container
.
get
(
)
)
;
container
-
>
SetIsNativeAnonymousRoot
(
)
;
container
-
>
SetPseudoElementType
(
aPseudoElement
)
;
nsIDocument
*
bindDocument
=
aParentContent
-
>
HasFlag
(
NODE_IS_IN_SHADOW_TREE
)
?
nullptr
:
mDocument
;
rv
=
container
-
>
BindToTree
(
bindDocument
aParentContent
aParentContent
true
)
;
if
(
NS_FAILED
(
rv
)
)
{
container
-
>
UnbindFromTree
(
)
;
return
;
}
bool
hasServoAnimations
=
Servo_ComputedValues_SpecifiesAnimationsOrTransitions
(
pseudoComputedStyle
)
;
if
(
!
hasServoAnimations
)
{
Servo_SetExplicitStyle
(
container
pseudoComputedStyle
)
;
}
else
{
mPresShell
-
>
StyleSet
(
)
-
>
StyleNewSubtree
(
container
)
;
pseudoComputedStyle
=
styleSet
-
>
ResolveServoStyle
(
container
)
;
}
uint32_t
contentCount
=
pseudoComputedStyle
-
>
StyleContent
(
)
-
>
ContentCount
(
)
;
for
(
uint32_t
contentIndex
=
0
;
contentIndex
<
contentCount
;
contentIndex
+
+
)
{
nsCOMPtr
<
nsIContent
>
content
=
CreateGeneratedContent
(
aState
aParentContent
pseudoComputedStyle
contentIndex
)
;
if
(
content
)
{
container
-
>
AppendChildTo
(
content
false
)
;
if
(
content
-
>
IsElement
(
)
)
{
mPresShell
-
>
StyleSet
(
)
-
>
StyleNewSubtree
(
content
-
>
AsElement
(
)
)
;
}
}
}
AddFrameConstructionItemsInternal
(
aState
container
aParentFrame
true
pseudoComputedStyle
ITEM_IS_GENERATED_CONTENT
nullptr
aItems
)
;
}
static
bool
IsTablePseudo
(
nsIFrame
*
aFrame
)
{
nsAtom
*
pseudoType
=
aFrame
-
>
Style
(
)
-
>
GetPseudo
(
)
;
return
pseudoType
&
&
(
pseudoType
=
=
nsCSSAnonBoxes
:
:
table
|
|
pseudoType
=
=
nsCSSAnonBoxes
:
:
inlineTable
|
|
pseudoType
=
=
nsCSSAnonBoxes
:
:
tableColGroup
|
|
pseudoType
=
=
nsCSSAnonBoxes
:
:
tableRowGroup
|
|
pseudoType
=
=
nsCSSAnonBoxes
:
:
tableRow
|
|
pseudoType
=
=
nsCSSAnonBoxes
:
:
tableCell
|
|
(
pseudoType
=
=
nsCSSAnonBoxes
:
:
cellContent
&
&
aFrame
-
>
GetParent
(
)
-
>
Style
(
)
-
>
GetPseudo
(
)
=
=
nsCSSAnonBoxes
:
:
tableCell
)
|
|
(
pseudoType
=
=
nsCSSAnonBoxes
:
:
tableWrapper
&
&
(
aFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
-
>
Style
(
)
-
>
GetPseudo
(
)
=
=
nsCSSAnonBoxes
:
:
table
|
|
aFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
-
>
Style
(
)
-
>
GetPseudo
(
)
=
=
nsCSSAnonBoxes
:
:
inlineTable
)
)
)
;
}
static
bool
IsRubyPseudo
(
nsIFrame
*
aFrame
)
{
return
RubyUtils
:
:
IsRubyPseudo
(
aFrame
-
>
Style
(
)
-
>
GetPseudo
(
)
)
;
}
static
bool
IsTableOrRubyPseudo
(
nsIFrame
*
aFrame
)
{
return
IsTablePseudo
(
aFrame
)
|
|
IsRubyPseudo
(
aFrame
)
;
}
nsCSSFrameConstructor
:
:
ParentType
nsCSSFrameConstructor
:
:
GetParentType
(
LayoutFrameType
aFrameType
)
{
if
(
aFrameType
=
=
LayoutFrameType
:
:
Table
)
{
return
eTypeTable
;
}
if
(
aFrameType
=
=
LayoutFrameType
:
:
TableRowGroup
)
{
return
eTypeRowGroup
;
}
if
(
aFrameType
=
=
LayoutFrameType
:
:
TableRow
)
{
return
eTypeRow
;
}
if
(
aFrameType
=
=
LayoutFrameType
:
:
TableColGroup
)
{
return
eTypeColGroup
;
}
if
(
aFrameType
=
=
LayoutFrameType
:
:
RubyBaseContainer
)
{
return
eTypeRubyBaseContainer
;
}
if
(
aFrameType
=
=
LayoutFrameType
:
:
RubyTextContainer
)
{
return
eTypeRubyTextContainer
;
}
if
(
aFrameType
=
=
LayoutFrameType
:
:
Ruby
)
{
return
eTypeRuby
;
}
return
eTypeBlock
;
}
static
nsContainerFrame
*
AdjustCaptionParentFrame
(
nsContainerFrame
*
aParentFrame
)
{
if
(
aParentFrame
-
>
IsTableFrame
(
)
)
{
return
aParentFrame
-
>
GetParent
(
)
;
}
return
aParentFrame
;
}
static
bool
GetCaptionAdjustedParent
(
nsContainerFrame
*
aParentFrame
const
nsIFrame
*
aChildFrame
nsContainerFrame
*
*
aAdjParentFrame
)
{
*
aAdjParentFrame
=
aParentFrame
;
bool
haveCaption
=
false
;
if
(
aChildFrame
-
>
IsTableCaption
(
)
)
{
haveCaption
=
true
;
*
aAdjParentFrame
=
:
:
AdjustCaptionParentFrame
(
aParentFrame
)
;
}
return
haveCaption
;
}
void
nsCSSFrameConstructor
:
:
AdjustParentFrame
(
nsContainerFrame
*
*
aParentFrame
const
FrameConstructionData
*
aFCData
ComputedStyle
*
aComputedStyle
)
{
MOZ_ASSERT
(
aComputedStyle
"
Must
have
child
'
s
style
"
)
;
MOZ_ASSERT
(
aFCData
"
Must
have
frame
construction
data
"
)
;
bool
tablePart
=
(
(
aFCData
-
>
mBits
&
FCDATA_IS_TABLE_PART
)
!
=
0
)
;
if
(
tablePart
&
&
aComputedStyle
-
>
StyleDisplay
(
)
-
>
mDisplay
=
=
StyleDisplay
:
:
TableCaption
)
{
*
aParentFrame
=
:
:
AdjustCaptionParentFrame
(
*
aParentFrame
)
;
}
}
static
void
PullOutCaptionFrames
(
nsFrameItems
&
aItems
nsFrameItems
&
aCaptions
)
{
nsIFrame
*
child
=
aItems
.
FirstChild
(
)
;
while
(
child
)
{
nsIFrame
*
nextSibling
=
child
-
>
GetNextSibling
(
)
;
if
(
child
-
>
IsTableCaption
(
)
)
{
aItems
.
RemoveFrame
(
child
)
;
aCaptions
.
AddChild
(
child
)
;
}
child
=
nextSibling
;
}
}
nsIFrame
*
nsCSSFrameConstructor
:
:
ConstructTable
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aDisplay
nsFrameItems
&
aFrameItems
)
{
MOZ_ASSERT
(
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
Table
|
|
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
InlineTable
"
Unexpected
call
"
)
;
nsIContent
*
const
content
=
aItem
.
mContent
;
ComputedStyle
*
const
computedStyle
=
aItem
.
mComputedStyle
;
const
bool
isMathMLContent
=
content
-
>
IsMathMLElement
(
)
;
RefPtr
<
ComputedStyle
>
outerComputedStyle
;
outerComputedStyle
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveInheritingAnonymousBoxStyle
(
nsCSSAnonBoxes
:
:
tableWrapper
computedStyle
)
;
nsContainerFrame
*
newFrame
;
if
(
isMathMLContent
)
newFrame
=
NS_NewMathMLmtableOuterFrame
(
mPresShell
outerComputedStyle
)
;
else
newFrame
=
NS_NewTableWrapperFrame
(
mPresShell
outerComputedStyle
)
;
nsContainerFrame
*
geometricParent
=
aState
.
GetGeometricParent
(
outerComputedStyle
-
>
StyleDisplay
(
)
aParentFrame
)
;
InitAndRestoreFrame
(
aState
content
geometricParent
newFrame
)
;
nsContainerFrame
*
innerFrame
;
if
(
isMathMLContent
)
innerFrame
=
NS_NewMathMLmtableFrame
(
mPresShell
computedStyle
)
;
else
innerFrame
=
NS_NewTableFrame
(
mPresShell
computedStyle
)
;
InitAndRestoreFrame
(
aState
content
newFrame
innerFrame
)
;
innerFrame
-
>
AddStateBits
(
NS_FRAME_OWNS_ANON_BOXES
)
;
SetInitialSingleChild
(
newFrame
innerFrame
)
;
aState
.
AddChild
(
newFrame
aFrameItems
content
aParentFrame
)
;
if
(
!
mRootElementFrame
)
{
mRootElementFrame
=
newFrame
;
}
nsFrameItems
childItems
;
nsFrameConstructorSaveState
absoluteSaveState
;
const
nsStyleDisplay
*
display
=
outerComputedStyle
-
>
StyleDisplay
(
)
;
newFrame
-
>
AddStateBits
(
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
;
if
(
display
-
>
IsAbsPosContainingBlock
(
newFrame
)
)
{
aState
.
PushAbsoluteContainingBlock
(
newFrame
newFrame
absoluteSaveState
)
;
}
NS_ASSERTION
(
aItem
.
mAnonChildren
.
IsEmpty
(
)
"
nsIAnonymousContentCreator
:
:
CreateAnonymousContent
"
"
implementations
for
table
frames
are
not
currently
expected
"
"
to
output
a
list
where
the
items
have
their
own
children
"
)
;
if
(
aItem
.
mFCData
-
>
mBits
&
FCDATA_USE_CHILD_ITEMS
)
{
ConstructFramesFromItemList
(
aState
aItem
.
mChildItems
innerFrame
aItem
.
mFCData
-
>
mBits
&
FCDATA_IS_WRAPPER_ANON_BOX
childItems
)
;
}
else
{
ProcessChildren
(
aState
content
computedStyle
innerFrame
true
childItems
false
aItem
.
mPendingBinding
)
;
}
nsFrameItems
captionItems
;
PullOutCaptionFrames
(
childItems
captionItems
)
;
innerFrame
-
>
SetInitialChildList
(
kPrincipalList
childItems
)
;
if
(
captionItems
.
NotEmpty
(
)
)
{
newFrame
-
>
SetInitialChildList
(
nsIFrame
:
:
kCaptionList
captionItems
)
;
}
return
newFrame
;
}
static
void
MakeTablePartAbsoluteContainingBlockIfNeeded
(
nsFrameConstructorState
&
aState
const
nsStyleDisplay
*
aDisplay
nsFrameConstructorSaveState
&
aAbsSaveState
nsContainerFrame
*
aFrame
)
{
if
(
aDisplay
-
>
IsAbsPosContainingBlock
(
aFrame
)
)
{
aFrame
-
>
AddStateBits
(
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
;
aState
.
PushAbsoluteContainingBlock
(
aFrame
aFrame
aAbsSaveState
)
;
nsTableFrame
:
:
RegisterPositionedTablePart
(
aFrame
)
;
}
}
nsIFrame
*
nsCSSFrameConstructor
:
:
ConstructTableRowOrRowGroup
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aDisplay
nsFrameItems
&
aFrameItems
)
{
MOZ_ASSERT
(
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
TableRow
|
|
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
TableRowGroup
|
|
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
TableFooterGroup
|
|
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
TableHeaderGroup
"
Not
a
row
or
row
group
"
)
;
MOZ_ASSERT
(
aItem
.
mComputedStyle
-
>
StyleDisplay
(
)
=
=
aDisplay
"
Display
style
doesn
'
t
match
style
"
)
;
nsIContent
*
const
content
=
aItem
.
mContent
;
ComputedStyle
*
const
computedStyle
=
aItem
.
mComputedStyle
;
nsContainerFrame
*
newFrame
;
if
(
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
TableRow
)
{
if
(
content
-
>
IsMathMLElement
(
)
)
newFrame
=
NS_NewMathMLmtrFrame
(
mPresShell
computedStyle
)
;
else
newFrame
=
NS_NewTableRowFrame
(
mPresShell
computedStyle
)
;
}
else
{
newFrame
=
NS_NewTableRowGroupFrame
(
mPresShell
computedStyle
)
;
}
InitAndRestoreFrame
(
aState
content
aParentFrame
newFrame
)
;
nsFrameConstructorSaveState
absoluteSaveState
;
MakeTablePartAbsoluteContainingBlockIfNeeded
(
aState
aDisplay
absoluteSaveState
newFrame
)
;
nsFrameItems
childItems
;
NS_ASSERTION
(
aItem
.
mAnonChildren
.
IsEmpty
(
)
"
nsIAnonymousContentCreator
:
:
CreateAnonymousContent
"
"
implementations
for
table
frames
are
not
currently
expected
"
"
to
output
a
list
where
the
items
have
their
own
children
"
)
;
if
(
aItem
.
mFCData
-
>
mBits
&
FCDATA_USE_CHILD_ITEMS
)
{
ConstructFramesFromItemList
(
aState
aItem
.
mChildItems
newFrame
aItem
.
mFCData
-
>
mBits
&
FCDATA_IS_WRAPPER_ANON_BOX
childItems
)
;
}
else
{
ProcessChildren
(
aState
content
computedStyle
newFrame
true
childItems
false
aItem
.
mPendingBinding
)
;
}
newFrame
-
>
SetInitialChildList
(
kPrincipalList
childItems
)
;
aFrameItems
.
AddChild
(
newFrame
)
;
return
newFrame
;
}
nsIFrame
*
nsCSSFrameConstructor
:
:
ConstructTableCol
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aStyleDisplay
nsFrameItems
&
aFrameItems
)
{
nsIContent
*
const
content
=
aItem
.
mContent
;
ComputedStyle
*
const
computedStyle
=
aItem
.
mComputedStyle
;
nsTableColFrame
*
colFrame
=
NS_NewTableColFrame
(
mPresShell
computedStyle
)
;
InitAndRestoreFrame
(
aState
content
aParentFrame
colFrame
)
;
NS_ASSERTION
(
colFrame
-
>
Style
(
)
=
=
computedStyle
"
Unexpected
style
"
)
;
aFrameItems
.
AddChild
(
colFrame
)
;
int32_t
span
=
colFrame
-
>
GetSpan
(
)
;
for
(
int32_t
spanX
=
1
;
spanX
<
span
;
spanX
+
+
)
{
nsTableColFrame
*
newCol
=
NS_NewTableColFrame
(
mPresShell
computedStyle
)
;
InitAndRestoreFrame
(
aState
content
aParentFrame
newCol
false
)
;
aFrameItems
.
LastChild
(
)
-
>
SetNextContinuation
(
newCol
)
;
newCol
-
>
SetPrevContinuation
(
aFrameItems
.
LastChild
(
)
)
;
aFrameItems
.
AddChild
(
newCol
)
;
newCol
-
>
SetColType
(
eColAnonymousCol
)
;
}
return
colFrame
;
}
nsIFrame
*
nsCSSFrameConstructor
:
:
ConstructTableCell
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aDisplay
nsFrameItems
&
aFrameItems
)
{
MOZ_ASSERT
(
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
TableCell
"
Unexpected
call
"
)
;
nsIContent
*
const
content
=
aItem
.
mContent
;
ComputedStyle
*
const
computedStyle
=
aItem
.
mComputedStyle
;
const
bool
isMathMLContent
=
content
-
>
IsMathMLElement
(
)
;
nsTableFrame
*
tableFrame
=
static_cast
<
nsTableRowFrame
*
>
(
aParentFrame
)
-
>
GetTableFrame
(
)
;
nsContainerFrame
*
newFrame
;
if
(
isMathMLContent
&
&
!
tableFrame
-
>
IsBorderCollapse
(
)
)
{
newFrame
=
NS_NewMathMLmtdFrame
(
mPresShell
computedStyle
tableFrame
)
;
}
else
{
newFrame
=
NS_NewTableCellFrame
(
mPresShell
computedStyle
tableFrame
)
;
}
InitAndRestoreFrame
(
aState
content
aParentFrame
newFrame
)
;
newFrame
-
>
AddStateBits
(
NS_FRAME_OWNS_ANON_BOXES
)
;
RefPtr
<
ComputedStyle
>
innerPseudoStyle
;
innerPseudoStyle
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveInheritingAnonymousBoxStyle
(
nsCSSAnonBoxes
:
:
cellContent
computedStyle
)
;
bool
isBlock
;
nsContainerFrame
*
cellInnerFrame
;
if
(
isMathMLContent
)
{
cellInnerFrame
=
NS_NewMathMLmtdInnerFrame
(
mPresShell
innerPseudoStyle
)
;
isBlock
=
false
;
}
else
{
cellInnerFrame
=
NS_NewBlockFormattingContext
(
mPresShell
innerPseudoStyle
)
;
isBlock
=
true
;
}
InitAndRestoreFrame
(
aState
content
newFrame
cellInnerFrame
)
;
nsFrameConstructorSaveState
absoluteSaveState
;
MakeTablePartAbsoluteContainingBlockIfNeeded
(
aState
aDisplay
absoluteSaveState
newFrame
)
;
nsFrameItems
childItems
;
NS_ASSERTION
(
aItem
.
mAnonChildren
.
IsEmpty
(
)
"
nsIAnonymousContentCreator
:
:
CreateAnonymousContent
"
"
implementations
for
table
frames
are
not
currently
expected
"
"
to
output
a
list
where
the
items
have
their
own
children
"
)
;
if
(
aItem
.
mFCData
-
>
mBits
&
FCDATA_USE_CHILD_ITEMS
)
{
nsFrameConstructorSaveState
floatSaveState
;
if
(
!
isBlock
)
{
aState
.
PushFloatContainingBlock
(
nullptr
floatSaveState
)
;
}
else
{
aState
.
PushFloatContainingBlock
(
cellInnerFrame
floatSaveState
)
;
}
ConstructFramesFromItemList
(
aState
aItem
.
mChildItems
cellInnerFrame
aItem
.
mFCData
-
>
mBits
&
FCDATA_IS_WRAPPER_ANON_BOX
childItems
)
;
}
else
{
ProcessChildren
(
aState
content
computedStyle
cellInnerFrame
true
childItems
isBlock
aItem
.
mPendingBinding
)
;
}
cellInnerFrame
-
>
SetInitialChildList
(
kPrincipalList
childItems
)
;
SetInitialSingleChild
(
newFrame
cellInnerFrame
)
;
aFrameItems
.
AddChild
(
newFrame
)
;
return
newFrame
;
}
static
inline
bool
NeedFrameFor
(
const
nsFrameConstructorState
&
aState
nsIFrame
*
aParentFrame
nsIContent
*
aChildContent
)
{
MOZ_ASSERT
(
!
aChildContent
-
>
GetPrimaryFrame
(
)
|
|
aState
.
mCreatingExtraFrames
|
|
aChildContent
-
>
GetPrimaryFrame
(
)
-
>
GetContent
(
)
!
=
aChildContent
"
Why
did
we
get
called
?
"
)
;
if
(
(
aParentFrame
&
&
(
!
aParentFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eExcludesIgnorableWhitespace
)
|
|
aParentFrame
-
>
IsGeneratedContentFrame
(
)
)
)
|
|
!
aChildContent
-
>
IsText
(
)
)
{
return
true
;
}
aChildContent
-
>
SetFlags
(
NS_CREATE_FRAME_IF_NON_WHITESPACE
|
NS_REFRAME_IF_WHITESPACE
)
;
return
!
aChildContent
-
>
TextIsOnlyWhitespace
(
)
;
}
nsIFrame
*
nsCSSFrameConstructor
:
:
ConstructDocElementFrame
(
Element
*
aDocElement
nsILayoutHistoryState
*
aFrameState
)
{
MOZ_ASSERT
(
GetRootFrame
(
)
"
No
viewport
?
Someone
forgot
to
call
ConstructRootFrame
!
"
)
;
MOZ_ASSERT
(
!
mDocElementContainingBlock
"
Shouldn
'
t
have
a
doc
element
containing
block
here
"
)
;
{
RefPtr
<
ComputedStyle
>
sc
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveInheritingAnonymousBoxStyle
(
nsCSSAnonBoxes
:
:
viewport
nullptr
)
;
GetRootFrame
(
)
-
>
SetComputedStyleWithoutNotification
(
sc
)
;
}
DebugOnly
<
nsIContent
*
>
propagatedScrollFrom
;
if
(
nsPresContext
*
presContext
=
mPresShell
-
>
GetPresContext
(
)
)
{
propagatedScrollFrom
=
presContext
-
>
UpdateViewportScrollbarStylesOverride
(
)
;
}
SetUpDocElementContainingBlock
(
aDocElement
)
;
NS_ASSERTION
(
mDocElementContainingBlock
"
Should
have
parent
by
now
"
)
;
nsFrameConstructorState
state
(
mPresShell
GetAbsoluteContainingBlock
(
mDocElementContainingBlock
FIXED_POS
)
nullptr
nullptr
do_AddRef
(
aFrameState
)
)
;
if
(
!
mTempFrameTreeState
)
state
.
mPresShell
-
>
CaptureHistoryState
(
getter_AddRefs
(
mTempFrameTreeState
)
)
;
ServoStyleSet
*
set
=
mPresShell
-
>
StyleSet
(
)
;
if
(
!
aDocElement
-
>
HasServoData
(
)
)
{
set
-
>
StyleNewSubtree
(
aDocElement
)
;
}
RefPtr
<
ComputedStyle
>
computedStyle
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveServoStyle
(
aDocElement
)
;
const
nsStyleDisplay
*
display
=
computedStyle
-
>
StyleDisplay
(
)
;
if
(
display
-
>
mBinding
)
{
nsresult
rv
;
bool
resolveStyle
;
nsXBLService
*
xblService
=
nsXBLService
:
:
GetInstance
(
)
;
if
(
!
xblService
)
{
return
nullptr
;
}
RefPtr
<
nsXBLBinding
>
binding
;
rv
=
xblService
-
>
LoadBindings
(
aDocElement
display
-
>
mBinding
-
>
GetURI
(
)
display
-
>
mBinding
-
>
mExtraData
-
>
GetPrincipal
(
)
getter_AddRefs
(
binding
)
&
resolveStyle
)
;
if
(
NS_FAILED
(
rv
)
&
&
rv
!
=
NS_ERROR_XBL_BLOCKED
)
{
return
nullptr
;
}
if
(
binding
)
{
mDocument
-
>
BindingManager
(
)
-
>
AddToAttachedQueue
(
binding
)
;
}
if
(
resolveStyle
)
{
computedStyle
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveServoStyle
(
aDocElement
)
;
display
=
computedStyle
-
>
StyleDisplay
(
)
;
}
}
NS_ASSERTION
(
!
display
-
>
IsScrollableOverflow
(
)
|
|
state
.
mPresContext
-
>
IsPaginated
(
)
|
|
propagatedScrollFrom
=
=
aDocElement
"
Scrollbars
should
have
been
propagated
to
the
viewport
"
)
;
if
(
MOZ_UNLIKELY
(
display
-
>
mDisplay
=
=
StyleDisplay
:
:
None
)
)
{
return
nullptr
;
}
computedStyle
-
>
StartBackgroundImageLoads
(
)
;
nsFrameConstructorSaveState
docElementContainingBlockAbsoluteSaveState
;
if
(
mHasRootAbsPosContainingBlock
)
{
mDocElementContainingBlock
-
>
AddStateBits
(
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
;
state
.
PushAbsoluteContainingBlock
(
mDocElementContainingBlock
mDocElementContainingBlock
docElementContainingBlockAbsoluteSaveState
)
;
}
nsContainerFrame
*
contentFrame
;
nsIFrame
*
newFrame
;
bool
processChildren
=
false
;
nsFrameConstructorSaveState
absoluteSaveState
;
#
ifdef
MOZ_XUL
if
(
aDocElement
-
>
IsXULElement
(
)
)
{
contentFrame
=
NS_NewDocElementBoxFrame
(
mPresShell
computedStyle
)
;
InitAndRestoreFrame
(
state
aDocElement
mDocElementContainingBlock
contentFrame
)
;
newFrame
=
contentFrame
;
processChildren
=
true
;
}
else
#
endif
if
(
aDocElement
-
>
IsSVGElement
(
)
)
{
if
(
!
aDocElement
-
>
IsSVGElement
(
nsGkAtoms
:
:
svg
)
)
{
return
nullptr
;
}
static
const
FrameConstructionData
rootSVGData
=
FCDATA_DECL
(
0
nullptr
)
;
already_AddRefed
<
ComputedStyle
>
extraRef
=
RefPtr
<
ComputedStyle
>
(
computedStyle
)
.
forget
(
)
;
AutoFrameConstructionItem
item
(
this
&
rootSVGData
aDocElement
nullptr
extraRef
true
nullptr
)
;
nsFrameItems
frameItems
;
contentFrame
=
static_cast
<
nsContainerFrame
*
>
(
ConstructOuterSVG
(
state
item
mDocElementContainingBlock
computedStyle
-
>
StyleDisplay
(
)
frameItems
)
)
;
newFrame
=
frameItems
.
FirstChild
(
)
;
NS_ASSERTION
(
frameItems
.
OnlyChild
(
)
"
multiple
root
element
frames
"
)
;
}
else
if
(
display
-
>
mDisplay
=
=
StyleDisplay
:
:
Flex
|
|
display
-
>
mDisplay
=
=
StyleDisplay
:
:
WebkitBox
|
|
(
StaticPrefs
:
:
layout_css_emulate_moz_box_with_flex
(
)
&
&
display
-
>
mDisplay
=
=
StyleDisplay
:
:
MozBox
)
)
{
contentFrame
=
NS_NewFlexContainerFrame
(
mPresShell
computedStyle
)
;
InitAndRestoreFrame
(
state
aDocElement
mDocElementContainingBlock
contentFrame
)
;
newFrame
=
contentFrame
;
processChildren
=
true
;
newFrame
-
>
AddStateBits
(
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
;
if
(
display
-
>
IsAbsPosContainingBlock
(
newFrame
)
)
{
state
.
PushAbsoluteContainingBlock
(
contentFrame
newFrame
absoluteSaveState
)
;
}
}
else
if
(
display
-
>
mDisplay
=
=
StyleDisplay
:
:
Grid
)
{
contentFrame
=
NS_NewGridContainerFrame
(
mPresShell
computedStyle
)
;
InitAndRestoreFrame
(
state
aDocElement
mDocElementContainingBlock
contentFrame
)
;
newFrame
=
contentFrame
;
processChildren
=
true
;
newFrame
-
>
AddStateBits
(
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
;
if
(
display
-
>
IsAbsPosContainingBlock
(
newFrame
)
)
{
state
.
PushAbsoluteContainingBlock
(
contentFrame
newFrame
absoluteSaveState
)
;
}
}
else
if
(
display
-
>
mDisplay
=
=
StyleDisplay
:
:
Table
)
{
static
const
FrameConstructionData
rootTableData
=
FCDATA_DECL
(
0
nullptr
)
;
already_AddRefed
<
ComputedStyle
>
extraRef
=
RefPtr
<
ComputedStyle
>
(
computedStyle
)
.
forget
(
)
;
AutoFrameConstructionItem
item
(
this
&
rootTableData
aDocElement
nullptr
extraRef
true
nullptr
)
;
nsFrameItems
frameItems
;
contentFrame
=
static_cast
<
nsContainerFrame
*
>
(
ConstructTable
(
state
item
mDocElementContainingBlock
computedStyle
-
>
StyleDisplay
(
)
frameItems
)
)
;
newFrame
=
frameItems
.
FirstChild
(
)
;
NS_ASSERTION
(
frameItems
.
OnlyChild
(
)
"
multiple
root
element
frames
"
)
;
}
else
{
MOZ_ASSERT
(
display
-
>
mDisplay
=
=
StyleDisplay
:
:
Block
|
|
display
-
>
mDisplay
=
=
StyleDisplay
:
:
FlowRoot
"
Unhandled
display
type
for
root
element
"
)
;
contentFrame
=
NS_NewBlockFormattingContext
(
mPresShell
computedStyle
)
;
nsFrameItems
frameItems
;
ConstructBlock
(
state
aDocElement
state
.
GetGeometricParent
(
display
mDocElementContainingBlock
)
mDocElementContainingBlock
computedStyle
&
contentFrame
frameItems
display
-
>
IsAbsPosContainingBlock
(
contentFrame
)
?
contentFrame
:
nullptr
nullptr
)
;
newFrame
=
frameItems
.
FirstChild
(
)
;
NS_ASSERTION
(
frameItems
.
OnlyChild
(
)
"
multiple
root
element
frames
"
)
;
}
MOZ_ASSERT
(
newFrame
)
;
MOZ_ASSERT
(
contentFrame
)
;
NS_ASSERTION
(
processChildren
?
!
mRootElementFrame
:
mRootElementFrame
=
=
contentFrame
"
unexpected
mRootElementFrame
"
)
;
mRootElementFrame
=
contentFrame
;
contentFrame
-
>
GetParentComputedStyle
(
&
mRootElementStyleFrame
)
;
bool
isChild
=
mRootElementStyleFrame
&
&
mRootElementStyleFrame
-
>
GetParent
(
)
=
=
contentFrame
;
if
(
!
isChild
)
{
mRootElementStyleFrame
=
mRootElementFrame
;
}
if
(
processChildren
)
{
nsFrameItems
childItems
;
NS_ASSERTION
(
!
nsLayoutUtils
:
:
GetAsBlock
(
contentFrame
)
&
&
!
contentFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
"
Only
XUL
frames
should
reach
here
"
)
;
ProcessChildren
(
state
aDocElement
computedStyle
contentFrame
true
childItems
false
nullptr
)
;
contentFrame
-
>
SetInitialChildList
(
kPrincipalList
childItems
)
;
}
aDocElement
-
>
SetPrimaryFrame
(
contentFrame
)
;
SetInitialSingleChild
(
mDocElementContainingBlock
newFrame
)
;
if
(
mDocElementContainingBlock
-
>
IsCanvasFrame
(
)
)
{
ConstructAnonymousContentForCanvas
(
state
mDocElementContainingBlock
aDocElement
)
;
}
return
newFrame
;
}
nsIFrame
*
nsCSSFrameConstructor
:
:
ConstructRootFrame
(
)
{
AUTO_LAYOUT_PHASE_ENTRY_POINT
(
mPresShell
-
>
GetPresContext
(
)
FrameC
)
;
ServoStyleSet
*
styleSet
=
mPresShell
-
>
StyleSet
(
)
;
RefPtr
<
ComputedStyle
>
viewportPseudoStyle
=
styleSet
-
>
ResolveInheritingAnonymousBoxStyle
(
nsCSSAnonBoxes
:
:
viewport
nullptr
)
;
ViewportFrame
*
viewportFrame
=
NS_NewViewportFrame
(
mPresShell
viewportPseudoStyle
)
;
viewportFrame
-
>
Init
(
nullptr
nullptr
nullptr
)
;
viewportFrame
-
>
AddStateBits
(
NS_FRAME_OWNS_ANON_BOXES
)
;
nsView
*
rootView
=
mPresShell
-
>
GetViewManager
(
)
-
>
GetRootView
(
)
;
viewportFrame
-
>
SetView
(
rootView
)
;
viewportFrame
-
>
SyncFrameViewProperties
(
rootView
)
;
nsContainerFrame
:
:
SyncWindowProperties
(
mPresShell
-
>
GetPresContext
(
)
viewportFrame
rootView
nullptr
nsContainerFrame
:
:
SET_ASYNC
)
;
viewportFrame
-
>
AddStateBits
(
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
;
viewportFrame
-
>
MarkAsAbsoluteContainingBlock
(
)
;
return
viewportFrame
;
}
void
nsCSSFrameConstructor
:
:
SetUpDocElementContainingBlock
(
nsIContent
*
aDocElement
)
{
MOZ_ASSERT
(
aDocElement
"
No
element
?
"
)
;
MOZ_ASSERT
(
!
aDocElement
-
>
GetParent
(
)
"
Not
root
content
?
"
)
;
MOZ_ASSERT
(
aDocElement
-
>
GetUncomposedDoc
(
)
"
Not
in
a
document
?
"
)
;
MOZ_ASSERT
(
aDocElement
-
>
GetUncomposedDoc
(
)
-
>
GetRootElement
(
)
=
=
aDocElement
"
Not
the
root
of
the
document
?
"
)
;
nsPresContext
*
presContext
=
mPresShell
-
>
GetPresContext
(
)
;
bool
isPaginated
=
presContext
-
>
IsRootPaginatedDocument
(
)
;
nsContainerFrame
*
viewportFrame
=
static_cast
<
nsContainerFrame
*
>
(
GetRootFrame
(
)
)
;
ComputedStyle
*
viewportPseudoStyle
=
viewportFrame
-
>
Style
(
)
;
nsContainerFrame
*
rootFrame
=
nullptr
;
nsAtom
*
rootPseudo
;
if
(
!
isPaginated
)
{
#
ifdef
MOZ_XUL
if
(
aDocElement
-
>
IsXULElement
(
)
)
{
rootFrame
=
NS_NewRootBoxFrame
(
mPresShell
viewportPseudoStyle
)
;
}
else
#
endif
{
rootFrame
=
NS_NewCanvasFrame
(
mPresShell
viewportPseudoStyle
)
;
mHasRootAbsPosContainingBlock
=
true
;
}
rootPseudo
=
nsCSSAnonBoxes
:
:
canvas
;
mDocElementContainingBlock
=
rootFrame
;
}
else
{
rootFrame
=
NS_NewSimplePageSequenceFrame
(
mPresShell
viewportPseudoStyle
)
;
mPageSequenceFrame
=
rootFrame
;
rootPseudo
=
nsCSSAnonBoxes
:
:
pageSequence
;
rootFrame
-
>
AddStateBits
(
NS_FRAME_OWNS_ANON_BOXES
)
;
}
bool
isHTML
=
aDocElement
-
>
IsHTMLElement
(
)
;
bool
isXUL
=
false
;
if
(
!
isHTML
)
{
isXUL
=
aDocElement
-
>
IsXULElement
(
)
;
}
bool
isScrollable
=
isPaginated
?
presContext
-
>
HasPaginatedScrolling
(
)
:
!
isXUL
;
NS_ASSERTION
(
!
isScrollable
|
|
!
isXUL
"
XUL
documents
should
never
be
scrollable
-
see
above
"
)
;
nsContainerFrame
*
newFrame
=
rootFrame
;
RefPtr
<
ComputedStyle
>
rootPseudoStyle
;
nsFrameConstructorState
state
(
mPresShell
nullptr
nullptr
nullptr
)
;
nsContainerFrame
*
parentFrame
=
viewportFrame
;
ServoStyleSet
*
styleSet
=
mPresShell
-
>
StyleSet
(
)
;
if
(
!
isScrollable
)
{
rootPseudoStyle
=
styleSet
-
>
ResolveInheritingAnonymousBoxStyle
(
rootPseudo
viewportPseudoStyle
)
;
}
else
{
if
(
rootPseudo
=
=
nsCSSAnonBoxes
:
:
canvas
)
{
rootPseudo
=
nsCSSAnonBoxes
:
:
scrolledCanvas
;
}
else
{
NS_ASSERTION
(
rootPseudo
=
=
nsCSSAnonBoxes
:
:
pageSequence
"
Unknown
root
pseudo
"
)
;
rootPseudo
=
nsCSSAnonBoxes
:
:
scrolledPageSequence
;
}
RefPtr
<
ComputedStyle
>
computedStyle
=
styleSet
-
>
ResolveInheritingAnonymousBoxStyle
(
nsCSSAnonBoxes
:
:
viewportScroll
viewportPseudoStyle
)
;
newFrame
=
nullptr
;
rootPseudoStyle
=
BeginBuildingScrollFrame
(
state
aDocElement
computedStyle
viewportFrame
rootPseudo
true
newFrame
)
;
parentFrame
=
newFrame
;
}
rootFrame
-
>
SetComputedStyleWithoutNotification
(
rootPseudoStyle
)
;
rootFrame
-
>
Init
(
aDocElement
parentFrame
nullptr
)
;
if
(
isScrollable
)
{
FinishBuildingScrollFrame
(
parentFrame
rootFrame
)
;
}
if
(
isPaginated
)
{
nsContainerFrame
*
canvasFrame
;
nsContainerFrame
*
pageFrame
=
ConstructPageFrame
(
mPresShell
rootFrame
nullptr
canvasFrame
)
;
pageFrame
-
>
AddStateBits
(
NS_FRAME_OWNS_ANON_BOXES
)
;
SetInitialSingleChild
(
rootFrame
pageFrame
)
;
mDocElementContainingBlock
=
canvasFrame
;
mHasRootAbsPosContainingBlock
=
true
;
}
if
(
viewportFrame
-
>
GetStateBits
(
)
&
NS_FRAME_FIRST_REFLOW
)
{
SetInitialSingleChild
(
viewportFrame
newFrame
)
;
}
else
{
nsFrameList
newFrameList
(
newFrame
newFrame
)
;
viewportFrame
-
>
AppendFrames
(
kPrincipalList
newFrameList
)
;
}
}
void
nsCSSFrameConstructor
:
:
ConstructAnonymousContentForCanvas
(
nsFrameConstructorState
&
aState
nsIFrame
*
aFrame
nsIContent
*
aDocElement
)
{
NS_ASSERTION
(
aFrame
-
>
IsCanvasFrame
(
)
"
aFrame
should
be
canvas
frame
!
"
)
;
AutoTArray
<
nsIAnonymousContentCreator
:
:
ContentInfo
4
>
anonymousItems
;
GetAnonymousContent
(
aDocElement
aFrame
anonymousItems
)
;
if
(
anonymousItems
.
IsEmpty
(
)
)
{
return
;
}
AutoFrameConstructionItemList
itemsToConstruct
(
this
)
;
nsContainerFrame
*
frameAsContainer
=
do_QueryFrame
(
aFrame
)
;
AddFCItemsForAnonymousContent
(
aState
frameAsContainer
anonymousItems
itemsToConstruct
)
;
nsFrameItems
frameItems
;
ConstructFramesFromItemList
(
aState
itemsToConstruct
frameAsContainer
false
frameItems
)
;
frameAsContainer
-
>
AppendFrames
(
kPrincipalList
frameItems
)
;
}
nsContainerFrame
*
nsCSSFrameConstructor
:
:
ConstructPageFrame
(
nsIPresShell
*
aPresShell
nsContainerFrame
*
aParentFrame
nsIFrame
*
aPrevPageFrame
nsContainerFrame
*
&
aCanvasFrame
)
{
ComputedStyle
*
parentComputedStyle
=
aParentFrame
-
>
Style
(
)
;
ServoStyleSet
*
styleSet
=
aPresShell
-
>
StyleSet
(
)
;
RefPtr
<
ComputedStyle
>
pagePseudoStyle
;
pagePseudoStyle
=
styleSet
-
>
ResolveInheritingAnonymousBoxStyle
(
nsCSSAnonBoxes
:
:
page
parentComputedStyle
)
;
nsContainerFrame
*
pageFrame
=
NS_NewPageFrame
(
aPresShell
pagePseudoStyle
)
;
pageFrame
-
>
Init
(
nullptr
aParentFrame
aPrevPageFrame
)
;
RefPtr
<
ComputedStyle
>
pageContentPseudoStyle
;
pageContentPseudoStyle
=
styleSet
-
>
ResolveInheritingAnonymousBoxStyle
(
nsCSSAnonBoxes
:
:
pageContent
pagePseudoStyle
)
;
nsContainerFrame
*
pageContentFrame
=
NS_NewPageContentFrame
(
aPresShell
pageContentPseudoStyle
)
;
nsIFrame
*
prevPageContentFrame
=
nullptr
;
if
(
aPrevPageFrame
)
{
prevPageContentFrame
=
aPrevPageFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
NS_ASSERTION
(
prevPageContentFrame
"
missing
page
content
frame
"
)
;
}
pageContentFrame
-
>
Init
(
nullptr
pageFrame
prevPageContentFrame
)
;
if
(
!
prevPageContentFrame
)
{
pageContentFrame
-
>
AddStateBits
(
NS_FRAME_OWNS_ANON_BOXES
)
;
}
SetInitialSingleChild
(
pageFrame
pageContentFrame
)
;
pageContentFrame
-
>
AddStateBits
(
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
;
pageContentFrame
-
>
MarkAsAbsoluteContainingBlock
(
)
;
RefPtr
<
ComputedStyle
>
canvasPseudoStyle
;
canvasPseudoStyle
=
styleSet
-
>
ResolveInheritingAnonymousBoxStyle
(
nsCSSAnonBoxes
:
:
canvas
pageContentPseudoStyle
)
;
aCanvasFrame
=
NS_NewCanvasFrame
(
aPresShell
canvasPseudoStyle
)
;
nsIFrame
*
prevCanvasFrame
=
nullptr
;
if
(
prevPageContentFrame
)
{
prevCanvasFrame
=
prevPageContentFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
NS_ASSERTION
(
prevCanvasFrame
"
missing
canvas
frame
"
)
;
}
aCanvasFrame
-
>
Init
(
nullptr
pageContentFrame
prevCanvasFrame
)
;
SetInitialSingleChild
(
pageContentFrame
aCanvasFrame
)
;
return
pageFrame
;
}
nsIFrame
*
nsCSSFrameConstructor
:
:
CreatePlaceholderFrameFor
(
nsIPresShell
*
aPresShell
nsIContent
*
aContent
nsIFrame
*
aFrame
nsContainerFrame
*
aParentFrame
nsIFrame
*
aPrevInFlow
nsFrameState
aTypeBit
)
{
RefPtr
<
ComputedStyle
>
placeholderStyle
=
aPresShell
-
>
StyleSet
(
)
-
>
ResolveStyleForPlaceholder
(
)
;
nsPlaceholderFrame
*
placeholderFrame
=
(
nsPlaceholderFrame
*
)
NS_NewPlaceholderFrame
(
aPresShell
placeholderStyle
aTypeBit
)
;
placeholderFrame
-
>
Init
(
aContent
aParentFrame
aPrevInFlow
)
;
placeholderFrame
-
>
SetOutOfFlowFrame
(
aFrame
)
;
aFrame
-
>
SetProperty
(
nsIFrame
:
:
PlaceholderFrameProperty
(
)
placeholderFrame
)
;
aFrame
-
>
AddStateBits
(
NS_FRAME_OUT_OF_FLOW
)
;
return
placeholderFrame
;
}
static
inline
void
ClearLazyBits
(
nsIContent
*
aStartContent
nsIContent
*
aEndContent
)
{
MOZ_ASSERT
(
aStartContent
|
|
!
aEndContent
"
Must
have
start
child
if
we
have
an
end
child
"
)
;
for
(
nsIContent
*
cur
=
aStartContent
;
cur
!
=
aEndContent
;
cur
=
cur
-
>
GetNextSibling
(
)
)
{
cur
-
>
UnsetFlags
(
NODE_DESCENDANTS_NEED_FRAMES
|
NODE_NEEDS_FRAME
)
;
}
}
nsIFrame
*
nsCSSFrameConstructor
:
:
ConstructSelectFrame
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aStyleDisplay
nsFrameItems
&
aFrameItems
)
{
nsIContent
*
const
content
=
aItem
.
mContent
;
ComputedStyle
*
const
computedStyle
=
aItem
.
mComputedStyle
;
dom
:
:
HTMLSelectElement
*
sel
=
dom
:
:
HTMLSelectElement
:
:
FromNode
(
content
)
;
MOZ_ASSERT
(
sel
)
;
if
(
sel
-
>
IsCombobox
(
)
)
{
nsFrameState
flags
=
NS_BLOCK_FLOAT_MGR
;
nsComboboxControlFrame
*
comboboxFrame
=
NS_NewComboboxControlFrame
(
mPresShell
computedStyle
flags
)
;
nsILayoutHistoryState
*
historyState
=
aState
.
mFrameState
;
aState
.
mFrameState
=
nullptr
;
InitAndRestoreFrame
(
aState
content
aState
.
GetGeometricParent
(
aStyleDisplay
aParentFrame
)
comboboxFrame
)
;
comboboxFrame
-
>
AddStateBits
(
NS_FRAME_OWNS_ANON_BOXES
)
;
aState
.
AddChild
(
comboboxFrame
aFrameItems
content
aParentFrame
)
;
RefPtr
<
ComputedStyle
>
listStyle
;
listStyle
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveInheritingAnonymousBoxStyle
(
nsCSSAnonBoxes
:
:
dropDownList
computedStyle
)
;
nsContainerFrame
*
listFrame
=
NS_NewListControlFrame
(
mPresShell
listStyle
)
;
nsIListControlFrame
*
listControlFrame
=
do_QueryFrame
(
listFrame
)
;
if
(
listControlFrame
)
{
listControlFrame
-
>
SetComboboxFrame
(
comboboxFrame
)
;
}
comboboxFrame
-
>
SetDropDown
(
listFrame
)
;
if
(
!
nsLayoutUtils
:
:
IsContentSelectEnabled
(
)
)
{
NS_ASSERTION
(
!
listFrame
-
>
IsAbsPosContainingBlock
(
)
"
Ended
up
with
positioned
dropdown
list
somehow
.
"
)
;
}
NS_ASSERTION
(
!
listFrame
-
>
IsFloating
(
)
"
Ended
up
with
floating
dropdown
list
somehow
.
"
)
;
nsFrameItems
childItems
;
nsContainerFrame
*
scrolledFrame
=
NS_NewSelectsAreaFrame
(
mPresShell
computedStyle
flags
)
;
InitializeSelectFrame
(
aState
listFrame
scrolledFrame
content
comboboxFrame
listStyle
true
aItem
.
mPendingBinding
childItems
)
;
if
(
!
nsLayoutUtils
:
:
IsContentSelectEnabled
(
)
)
{
NS_ASSERTION
(
listFrame
-
>
GetView
(
)
"
ListFrame
'
s
view
is
nullptr
"
)
;
}
AutoTArray
<
nsIAnonymousContentCreator
:
:
ContentInfo
2
>
newAnonymousItems
;
DebugOnly
<
nsresult
>
rv
=
GetAnonymousContent
(
content
comboboxFrame
newAnonymousItems
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
MOZ_ASSERT
(
newAnonymousItems
.
Length
(
)
=
=
2
)
;
MOZ_ASSERT
(
newAnonymousItems
[
0
]
.
mContent
=
=
comboboxFrame
-
>
GetDisplayNode
(
)
)
;
newAnonymousItems
.
RemoveElementAt
(
0
)
;
nsIFrame
*
customFrame
=
comboboxFrame
-
>
CreateFrameForDisplayNode
(
)
;
MOZ_ASSERT
(
customFrame
)
;
customFrame
-
>
AddStateBits
(
NS_FRAME_ANONYMOUSCONTENTCREATOR_CONTENT
)
;
childItems
.
AddChild
(
customFrame
)
;
AutoFrameConstructionItemList
fcItems
(
this
)
;
AddFCItemsForAnonymousContent
(
aState
comboboxFrame
newAnonymousItems
fcItems
)
;
ConstructFramesFromItemList
(
aState
fcItems
comboboxFrame
false
childItems
)
;
comboboxFrame
-
>
SetInitialChildList
(
kPrincipalList
childItems
)
;
if
(
!
nsLayoutUtils
:
:
IsContentSelectEnabled
(
)
)
{
nsFrameItems
popupItems
;
popupItems
.
AddChild
(
listFrame
)
;
comboboxFrame
-
>
SetInitialChildList
(
nsIFrame
:
:
kSelectPopupList
popupItems
)
;
}
aState
.
mFrameState
=
historyState
;
if
(
aState
.
mFrameState
)
{
RestoreFrameState
(
comboboxFrame
aState
.
mFrameState
)
;
}
return
comboboxFrame
;
}
nsContainerFrame
*
listFrame
=
NS_NewListControlFrame
(
mPresShell
computedStyle
)
;
nsContainerFrame
*
scrolledFrame
=
NS_NewSelectsAreaFrame
(
mPresShell
computedStyle
NS_BLOCK_FLOAT_MGR
)
;
InitializeSelectFrame
(
aState
listFrame
scrolledFrame
content
aParentFrame
computedStyle
false
aItem
.
mPendingBinding
aFrameItems
)
;
return
listFrame
;
}
void
nsCSSFrameConstructor
:
:
InitializeSelectFrame
(
nsFrameConstructorState
&
aState
nsContainerFrame
*
scrollFrame
nsContainerFrame
*
scrolledFrame
nsIContent
*
aContent
nsContainerFrame
*
aParentFrame
ComputedStyle
*
aComputedStyle
bool
aBuildCombobox
PendingBinding
*
aPendingBinding
nsFrameItems
&
aFrameItems
)
{
nsContainerFrame
*
geometricParent
=
aState
.
GetGeometricParent
(
aComputedStyle
-
>
StyleDisplay
(
)
aParentFrame
)
;
scrollFrame
-
>
Init
(
aContent
geometricParent
nullptr
)
;
if
(
!
aBuildCombobox
|
|
nsLayoutUtils
:
:
IsContentSelectEnabled
(
)
)
{
aState
.
AddChild
(
scrollFrame
aFrameItems
aContent
aParentFrame
)
;
}
BuildScrollFrame
(
aState
aContent
aComputedStyle
scrolledFrame
geometricParent
scrollFrame
)
;
if
(
aState
.
mFrameState
)
{
RestoreFrameStateFor
(
scrollFrame
aState
.
mFrameState
)
;
}
nsFrameItems
childItems
;
ProcessChildren
(
aState
aContent
aComputedStyle
scrolledFrame
false
childItems
false
aPendingBinding
)
;
scrolledFrame
-
>
SetInitialChildList
(
kPrincipalList
childItems
)
;
}
nsIFrame
*
nsCSSFrameConstructor
:
:
ConstructFieldSetFrame
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aStyleDisplay
nsFrameItems
&
aFrameItems
)
{
nsIContent
*
const
content
=
aItem
.
mContent
;
ComputedStyle
*
const
computedStyle
=
aItem
.
mComputedStyle
;
nsContainerFrame
*
fieldsetFrame
=
NS_NewFieldSetFrame
(
mPresShell
computedStyle
)
;
InitAndRestoreFrame
(
aState
content
aState
.
GetGeometricParent
(
aStyleDisplay
aParentFrame
)
fieldsetFrame
)
;
fieldsetFrame
-
>
AddStateBits
(
NS_FRAME_OWNS_ANON_BOXES
)
;
RefPtr
<
ComputedStyle
>
fieldsetContentStyle
;
fieldsetContentStyle
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveInheritingAnonymousBoxStyle
(
nsCSSAnonBoxes
:
:
fieldsetContent
computedStyle
)
;
const
nsStyleDisplay
*
fieldsetContentDisplay
=
fieldsetContentStyle
-
>
StyleDisplay
(
)
;
bool
isScrollable
=
fieldsetContentDisplay
-
>
IsScrollableOverflow
(
)
;
nsContainerFrame
*
scrollFrame
=
nullptr
;
if
(
isScrollable
)
{
fieldsetContentStyle
=
BeginBuildingScrollFrame
(
aState
content
fieldsetContentStyle
fieldsetFrame
nsCSSAnonBoxes
:
:
scrolledContent
false
scrollFrame
)
;
}
nsContainerFrame
*
absPosContainer
=
nullptr
;
if
(
fieldsetFrame
-
>
IsAbsPosContainingBlock
(
)
)
{
absPosContainer
=
fieldsetFrame
;
}
nsContainerFrame
*
contentFrameTop
;
nsContainerFrame
*
contentFrame
;
auto
parent
=
scrollFrame
?
scrollFrame
:
fieldsetFrame
;
switch
(
fieldsetContentDisplay
-
>
mDisplay
)
{
case
StyleDisplay
:
:
Flex
:
contentFrame
=
NS_NewFlexContainerFrame
(
mPresShell
fieldsetContentStyle
)
;
InitAndRestoreFrame
(
aState
content
parent
contentFrame
)
;
contentFrameTop
=
contentFrame
;
break
;
case
StyleDisplay
:
:
Grid
:
contentFrame
=
NS_NewGridContainerFrame
(
mPresShell
fieldsetContentStyle
)
;
InitAndRestoreFrame
(
aState
content
parent
contentFrame
)
;
contentFrameTop
=
contentFrame
;
break
;
default
:
{
MOZ_ASSERT
(
fieldsetContentDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
Block
"
bug
in
nsRuleNode
:
:
ComputeDisplayData
?
"
)
;
nsContainerFrame
*
columnSetFrame
=
nullptr
;
RefPtr
<
ComputedStyle
>
innerSC
=
fieldsetContentStyle
;
const
nsStyleColumn
*
columns
=
fieldsetContentStyle
-
>
StyleColumn
(
)
;
if
(
columns
-
>
mColumnCount
!
=
NS_STYLE_COLUMN_COUNT_AUTO
|
|
columns
-
>
mColumnWidth
.
GetUnit
(
)
!
=
eStyleUnit_Auto
)
{
columnSetFrame
=
NS_NewColumnSetFrame
(
mPresShell
fieldsetContentStyle
nsFrameState
(
NS_FRAME_OWNS_ANON_BOXES
)
)
;
InitAndRestoreFrame
(
aState
content
parent
columnSetFrame
)
;
innerSC
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveInheritingAnonymousBoxStyle
(
nsCSSAnonBoxes
:
:
columnContent
fieldsetContentStyle
)
;
if
(
absPosContainer
)
{
absPosContainer
=
columnSetFrame
;
}
}
contentFrame
=
NS_NewBlockFormattingContext
(
mPresShell
innerSC
)
;
if
(
columnSetFrame
)
{
InitAndRestoreFrame
(
aState
content
columnSetFrame
contentFrame
)
;
SetInitialSingleChild
(
columnSetFrame
contentFrame
)
;
contentFrameTop
=
columnSetFrame
;
}
else
{
InitAndRestoreFrame
(
aState
content
parent
contentFrame
)
;
contentFrameTop
=
contentFrame
;
}
break
;
}
}
aState
.
AddChild
(
fieldsetFrame
aFrameItems
content
aParentFrame
)
;
nsFrameConstructorSaveState
absoluteSaveState
;
nsFrameItems
childItems
;
contentFrame
-
>
AddStateBits
(
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
;
if
(
absPosContainer
)
{
aState
.
PushAbsoluteContainingBlock
(
contentFrame
absPosContainer
absoluteSaveState
)
;
}
ProcessChildren
(
aState
content
computedStyle
contentFrame
true
childItems
true
aItem
.
mPendingBinding
)
;
nsFrameItems
fieldsetKids
;
fieldsetKids
.
AddChild
(
scrollFrame
?
scrollFrame
:
contentFrameTop
)
;
for
(
nsFrameList
:
:
Enumerator
e
(
childItems
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
)
{
nsIFrame
*
child
=
e
.
get
(
)
;
nsContainerFrame
*
cif
=
child
-
>
GetContentInsertionFrame
(
)
;
if
(
cif
&
&
cif
-
>
IsLegendFrame
(
)
)
{
childItems
.
RemoveFrame
(
child
)
;
fieldsetKids
.
InsertFrame
(
fieldsetFrame
nullptr
child
)
;
if
(
scrollFrame
)
{
StickyScrollContainer
:
:
NotifyReparentedFrameAcrossScrollFrameBoundary
(
child
contentFrame
)
;
}
break
;
}
}
if
(
isScrollable
)
{
FinishBuildingScrollFrame
(
scrollFrame
contentFrameTop
)
;
}
contentFrame
-
>
SetInitialChildList
(
kPrincipalList
childItems
)
;
fieldsetFrame
-
>
SetInitialChildList
(
kPrincipalList
fieldsetKids
)
;
fieldsetFrame
-
>
AddStateBits
(
NS_FRAME_MAY_HAVE_GENERATED_CONTENT
)
;
return
fieldsetFrame
;
}
nsIFrame
*
nsCSSFrameConstructor
:
:
ConstructDetailsFrame
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aStyleDisplay
nsFrameItems
&
aFrameItems
)
{
if
(
!
aStyleDisplay
-
>
IsScrollableOverflow
(
)
)
{
return
ConstructNonScrollableBlockWithConstructor
(
aState
aItem
aParentFrame
aStyleDisplay
aFrameItems
NS_NewDetailsFrame
)
;
}
return
ConstructScrollableBlockWithConstructor
(
aState
aItem
aParentFrame
aStyleDisplay
aFrameItems
NS_NewDetailsFrame
)
;
}
static
nsIFrame
*
FindAncestorWithGeneratedContentPseudo
(
nsIFrame
*
aFrame
)
{
for
(
nsIFrame
*
f
=
aFrame
-
>
GetParent
(
)
;
f
;
f
=
f
-
>
GetParent
(
)
)
{
NS_ASSERTION
(
f
-
>
IsGeneratedContentFrame
(
)
"
should
not
have
exited
generated
content
"
)
;
nsAtom
*
pseudo
=
f
-
>
Style
(
)
-
>
GetPseudo
(
)
;
if
(
pseudo
=
=
nsCSSPseudoElements
:
:
before
|
|
pseudo
=
=
nsCSSPseudoElements
:
:
after
)
return
f
;
}
return
nullptr
;
}
#
define
SIMPLE_FCDATA
(
_func
)
FCDATA_DECL
(
0
_func
)
#
define
FULL_CTOR_FCDATA
(
_flags
_func
)
\
{
_flags
|
FCDATA_FUNC_IS_FULL_CTOR
{
nullptr
}
_func
nullptr
}
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindTextData
(
nsIFrame
*
aParentFrame
nsIContent
*
aTextContent
)
{
MOZ_ASSERT
(
aTextContent
"
How
?
"
)
;
if
(
aParentFrame
&
&
IsFrameForSVG
(
aParentFrame
)
)
{
nsIFrame
*
ancestorFrame
=
nsSVGUtils
:
:
GetFirstNonAAncestorFrame
(
aParentFrame
)
;
if
(
!
ancestorFrame
|
|
!
nsSVGUtils
:
:
IsInSVGTextSubtree
(
ancestorFrame
)
)
{
return
nullptr
;
}
if
(
aParentFrame
-
>
GetContent
(
)
!
=
aTextContent
-
>
GetParent
(
)
)
{
return
nullptr
;
}
static
const
FrameConstructionData
sSVGTextData
=
FCDATA_DECL
(
FCDATA_IS_LINE_PARTICIPANT
|
FCDATA_IS_SVG_TEXT
NS_NewTextFrame
)
;
return
&
sSVGTextData
;
}
static
const
FrameConstructionData
sTextData
=
FCDATA_DECL
(
FCDATA_IS_LINE_PARTICIPANT
NS_NewTextFrame
)
;
return
&
sTextData
;
}
void
nsCSSFrameConstructor
:
:
ConstructTextFrame
(
const
FrameConstructionData
*
aData
nsFrameConstructorState
&
aState
nsIContent
*
aContent
nsContainerFrame
*
aParentFrame
ComputedStyle
*
aComputedStyle
nsFrameItems
&
aFrameItems
)
{
MOZ_ASSERT
(
aData
"
Must
have
frame
construction
data
"
)
;
nsIFrame
*
newFrame
=
(
*
aData
-
>
mFunc
.
mCreationFunc
)
(
mPresShell
aComputedStyle
)
;
InitAndRestoreFrame
(
aState
aContent
aParentFrame
newFrame
)
;
if
(
newFrame
-
>
IsGeneratedContentFrame
(
)
)
{
nsAutoPtr
<
nsGenConInitializer
>
initializer
;
initializer
=
static_cast
<
nsGenConInitializer
*
>
(
aContent
-
>
UnsetProperty
(
nsGkAtoms
:
:
genConInitializerProperty
)
)
;
if
(
initializer
)
{
if
(
initializer
-
>
mNode
-
>
InitTextFrame
(
initializer
-
>
mList
FindAncestorWithGeneratedContentPseudo
(
newFrame
)
newFrame
)
)
{
(
this
-
>
*
(
initializer
-
>
mDirtyAll
)
)
(
)
;
}
initializer
-
>
mNode
.
forget
(
)
;
}
}
aFrameItems
.
AddChild
(
newFrame
)
;
if
(
!
aState
.
mCreatingExtraFrames
)
aContent
-
>
SetPrimaryFrame
(
newFrame
)
;
}
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindDataByInt
(
int32_t
aInt
Element
*
aElement
ComputedStyle
*
aComputedStyle
const
FrameConstructionDataByInt
*
aDataPtr
uint32_t
aDataLength
)
{
for
(
const
FrameConstructionDataByInt
*
curData
=
aDataPtr
*
endData
=
aDataPtr
+
aDataLength
;
curData
!
=
endData
;
+
+
curData
)
{
if
(
curData
-
>
mInt
=
=
aInt
)
{
const
FrameConstructionData
*
data
=
&
curData
-
>
mData
;
if
(
data
-
>
mBits
&
FCDATA_FUNC_IS_DATA_GETTER
)
{
return
data
-
>
mFunc
.
mDataGetter
(
aElement
aComputedStyle
)
;
}
return
data
;
}
}
return
nullptr
;
}
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindDataByTag
(
nsAtom
*
aTag
Element
*
aElement
ComputedStyle
*
aComputedStyle
const
FrameConstructionDataByTag
*
aDataPtr
uint32_t
aDataLength
)
{
for
(
const
FrameConstructionDataByTag
*
curData
=
aDataPtr
*
endData
=
aDataPtr
+
aDataLength
;
curData
!
=
endData
;
+
+
curData
)
{
if
(
*
curData
-
>
mTag
=
=
aTag
)
{
const
FrameConstructionData
*
data
=
&
curData
-
>
mData
;
if
(
data
-
>
mBits
&
FCDATA_FUNC_IS_DATA_GETTER
)
{
return
data
-
>
mFunc
.
mDataGetter
(
aElement
aComputedStyle
)
;
}
return
data
;
}
}
return
nullptr
;
}
#
define
SUPPRESS_FCDATA
(
)
FCDATA_DECL
(
FCDATA_SUPPRESS_FRAME
nullptr
)
#
define
SIMPLE_INT_CREATE
(
_int
_func
)
{
_int
SIMPLE_FCDATA
(
_func
)
}
#
define
SIMPLE_INT_CHAIN
(
_int
_func
)
\
{
_int
FCDATA_DECL
(
FCDATA_FUNC_IS_DATA_GETTER
_func
)
}
#
define
COMPLEX_INT_CREATE
(
_int
_func
)
\
{
_int
FULL_CTOR_FCDATA
(
0
_func
)
}
#
define
SIMPLE_TAG_CREATE
(
_tag
_func
)
\
{
&
nsGkAtoms
:
:
_tag
SIMPLE_FCDATA
(
_func
)
}
#
define
SIMPLE_TAG_CHAIN
(
_tag
_func
)
\
{
&
nsGkAtoms
:
:
_tag
FCDATA_DECL
(
FCDATA_FUNC_IS_DATA_GETTER
_func
)
}
#
define
COMPLEX_TAG_CREATE
(
_tag
_func
)
\
{
&
nsGkAtoms
:
:
_tag
FULL_CTOR_FCDATA
(
0
_func
)
}
static
bool
IsFrameForFieldSet
(
nsIFrame
*
aFrame
)
{
nsAtom
*
pseudo
=
aFrame
-
>
Style
(
)
-
>
GetPseudo
(
)
;
if
(
pseudo
=
=
nsCSSAnonBoxes
:
:
fieldsetContent
|
|
pseudo
=
=
nsCSSAnonBoxes
:
:
scrolledContent
|
|
pseudo
=
=
nsCSSAnonBoxes
:
:
columnContent
)
{
return
IsFrameForFieldSet
(
aFrame
-
>
GetParent
(
)
)
;
}
return
aFrame
-
>
IsFieldSetFrame
(
)
;
}
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindHTMLData
(
Element
*
aElement
nsAtom
*
aTag
int32_t
aNameSpaceID
nsIFrame
*
aParentFrame
ComputedStyle
*
aComputedStyle
)
{
if
(
aNameSpaceID
!
=
kNameSpaceID_XHTML
)
{
return
nullptr
;
}
NS_ASSERTION
(
!
aParentFrame
|
|
aParentFrame
-
>
Style
(
)
-
>
GetPseudo
(
)
!
=
nsCSSAnonBoxes
:
:
fieldsetContent
|
|
aParentFrame
-
>
GetParent
(
)
-
>
IsFieldSetFrame
(
)
"
Unexpected
parent
for
fieldset
content
anon
box
"
)
;
if
(
aTag
=
=
nsGkAtoms
:
:
legend
&
&
(
!
aParentFrame
|
|
!
IsFrameForFieldSet
(
aParentFrame
)
|
|
aComputedStyle
-
>
StyleDisplay
(
)
-
>
IsFloatingStyle
(
)
|
|
aComputedStyle
-
>
StyleDisplay
(
)
-
>
IsAbsolutelyPositionedStyle
(
)
)
)
{
return
nullptr
;
}
static
const
FrameConstructionDataByTag
sHTMLData
[
]
=
{
SIMPLE_TAG_CHAIN
(
img
nsCSSFrameConstructor
:
:
FindImgData
)
SIMPLE_TAG_CHAIN
(
mozgeneratedcontentimage
nsCSSFrameConstructor
:
:
FindImgData
)
{
&
nsGkAtoms
:
:
br
FCDATA_DECL
(
FCDATA_IS_LINE_PARTICIPANT
|
FCDATA_IS_LINE_BREAK
NS_NewBRFrame
)
}
SIMPLE_TAG_CREATE
(
wbr
NS_NewWBRFrame
)
SIMPLE_TAG_CHAIN
(
input
nsCSSFrameConstructor
:
:
FindInputData
)
SIMPLE_TAG_CREATE
(
textarea
NS_NewTextControlFrame
)
COMPLEX_TAG_CREATE
(
select
&
nsCSSFrameConstructor
:
:
ConstructSelectFrame
)
SIMPLE_TAG_CHAIN
(
object
nsCSSFrameConstructor
:
:
FindObjectData
)
SIMPLE_TAG_CHAIN
(
embed
nsCSSFrameConstructor
:
:
FindObjectData
)
COMPLEX_TAG_CREATE
(
fieldset
&
nsCSSFrameConstructor
:
:
ConstructFieldSetFrame
)
{
&
nsGkAtoms
:
:
legend
FCDATA_DECL
(
FCDATA_ALLOW_BLOCK_STYLES
|
FCDATA_MAY_NEED_SCROLLFRAME
NS_NewLegendFrame
)
}
SIMPLE_TAG_CREATE
(
frameset
NS_NewHTMLFramesetFrame
)
SIMPLE_TAG_CREATE
(
iframe
NS_NewSubDocumentFrame
)
{
&
nsGkAtoms
:
:
button
FCDATA_WITH_WRAPPING_BLOCK
(
FCDATA_ALLOW_BLOCK_STYLES
|
FCDATA_ALLOW_GRID_FLEX_COLUMNSET
NS_NewHTMLButtonControlFrame
nsCSSAnonBoxes
:
:
buttonContent
)
}
SIMPLE_TAG_CHAIN
(
canvas
nsCSSFrameConstructor
:
:
FindCanvasData
)
SIMPLE_TAG_CREATE
(
video
NS_NewHTMLVideoFrame
)
SIMPLE_TAG_CREATE
(
audio
NS_NewHTMLVideoFrame
)
SIMPLE_TAG_CREATE
(
progress
NS_NewProgressFrame
)
SIMPLE_TAG_CREATE
(
meter
NS_NewMeterFrame
)
COMPLEX_TAG_CREATE
(
details
&
nsCSSFrameConstructor
:
:
ConstructDetailsFrame
)
}
;
return
FindDataByTag
(
aTag
aElement
aComputedStyle
sHTMLData
ArrayLength
(
sHTMLData
)
)
;
}
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindImgData
(
Element
*
aElement
ComputedStyle
*
aComputedStyle
)
{
if
(
!
nsImageFrame
:
:
ShouldCreateImageFrameFor
(
aElement
aComputedStyle
)
)
{
return
nullptr
;
}
static
const
FrameConstructionData
sImgData
=
SIMPLE_FCDATA
(
NS_NewImageFrame
)
;
return
&
sImgData
;
}
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindImgControlData
(
Element
*
aElement
ComputedStyle
*
aComputedStyle
)
{
if
(
!
nsImageFrame
:
:
ShouldCreateImageFrameFor
(
aElement
aComputedStyle
)
)
{
return
nullptr
;
}
static
const
FrameConstructionData
sImgControlData
=
SIMPLE_FCDATA
(
NS_NewImageControlFrame
)
;
return
&
sImgControlData
;
}
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindInputData
(
Element
*
aElement
ComputedStyle
*
aComputedStyle
)
{
static
const
FrameConstructionDataByInt
sInputData
[
]
=
{
SIMPLE_INT_CREATE
(
NS_FORM_INPUT_CHECKBOX
NS_NewCheckboxRadioFrame
)
SIMPLE_INT_CREATE
(
NS_FORM_INPUT_RADIO
NS_NewCheckboxRadioFrame
)
SIMPLE_INT_CREATE
(
NS_FORM_INPUT_FILE
NS_NewFileControlFrame
)
SIMPLE_INT_CHAIN
(
NS_FORM_INPUT_IMAGE
nsCSSFrameConstructor
:
:
FindImgControlData
)
SIMPLE_INT_CREATE
(
NS_FORM_INPUT_EMAIL
NS_NewTextControlFrame
)
SIMPLE_INT_CREATE
(
NS_FORM_INPUT_SEARCH
NS_NewTextControlFrame
)
SIMPLE_INT_CREATE
(
NS_FORM_INPUT_TEXT
NS_NewTextControlFrame
)
SIMPLE_INT_CREATE
(
NS_FORM_INPUT_TEL
NS_NewTextControlFrame
)
SIMPLE_INT_CREATE
(
NS_FORM_INPUT_URL
NS_NewTextControlFrame
)
SIMPLE_INT_CREATE
(
NS_FORM_INPUT_RANGE
NS_NewRangeFrame
)
SIMPLE_INT_CREATE
(
NS_FORM_INPUT_PASSWORD
NS_NewTextControlFrame
)
{
NS_FORM_INPUT_COLOR
FCDATA_WITH_WRAPPING_BLOCK
(
0
NS_NewColorControlFrame
nsCSSAnonBoxes
:
:
buttonContent
)
}
SIMPLE_INT_CREATE
(
NS_FORM_INPUT_NUMBER
NS_NewNumberControlFrame
)
SIMPLE_INT_CREATE
(
NS_FORM_INPUT_TIME
NS_NewDateTimeControlFrame
)
SIMPLE_INT_CREATE
(
NS_FORM_INPUT_DATE
NS_NewDateTimeControlFrame
)
SIMPLE_INT_CREATE
(
NS_FORM_INPUT_MONTH
NS_NewTextControlFrame
)
SIMPLE_INT_CREATE
(
NS_FORM_INPUT_WEEK
NS_NewTextControlFrame
)
SIMPLE_INT_CREATE
(
NS_FORM_INPUT_DATETIME_LOCAL
NS_NewTextControlFrame
)
{
NS_FORM_INPUT_SUBMIT
FCDATA_WITH_WRAPPING_BLOCK
(
0
NS_NewGfxButtonControlFrame
nsCSSAnonBoxes
:
:
buttonContent
)
}
{
NS_FORM_INPUT_RESET
FCDATA_WITH_WRAPPING_BLOCK
(
0
NS_NewGfxButtonControlFrame
nsCSSAnonBoxes
:
:
buttonContent
)
}
{
NS_FORM_INPUT_BUTTON
FCDATA_WITH_WRAPPING_BLOCK
(
0
NS_NewGfxButtonControlFrame
nsCSSAnonBoxes
:
:
buttonContent
)
}
}
;
nsCOMPtr
<
nsIFormControl
>
control
=
do_QueryInterface
(
aElement
)
;
NS_ASSERTION
(
control
"
input
doesn
'
t
implement
nsIFormControl
?
"
)
;
auto
controlType
=
control
-
>
ControlType
(
)
;
if
(
(
controlType
=
=
NS_FORM_INPUT_CHECKBOX
|
|
controlType
=
=
NS_FORM_INPUT_RADIO
)
&
&
aComputedStyle
-
>
StyleDisplay
(
)
-
>
mAppearance
=
=
NS_THEME_NONE
)
{
return
nullptr
;
}
return
FindDataByInt
(
controlType
aElement
aComputedStyle
sInputData
ArrayLength
(
sInputData
)
)
;
}
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindObjectData
(
Element
*
aElement
ComputedStyle
*
aComputedStyle
)
{
uint32_t
type
;
if
(
aElement
-
>
State
(
)
.
HasAtLeastOneOfStates
(
NS_EVENT_STATE_BROKEN
|
NS_EVENT_STATE_USERDISABLED
|
NS_EVENT_STATE_SUPPRESSED
)
)
{
type
=
nsIObjectLoadingContent
:
:
TYPE_NULL
;
}
else
{
nsCOMPtr
<
nsIObjectLoadingContent
>
objContent
(
do_QueryInterface
(
aElement
)
)
;
NS_ASSERTION
(
objContent
"
embed
and
object
must
implement
"
"
nsIObjectLoadingContent
!
"
)
;
objContent
-
>
GetDisplayedType
(
&
type
)
;
}
static
const
FrameConstructionDataByInt
sObjectData
[
]
=
{
SIMPLE_INT_CREATE
(
nsIObjectLoadingContent
:
:
TYPE_LOADING
NS_NewEmptyFrame
)
SIMPLE_INT_CREATE
(
nsIObjectLoadingContent
:
:
TYPE_PLUGIN
NS_NewObjectFrame
)
SIMPLE_INT_CREATE
(
nsIObjectLoadingContent
:
:
TYPE_IMAGE
NS_NewImageFrame
)
SIMPLE_INT_CREATE
(
nsIObjectLoadingContent
:
:
TYPE_DOCUMENT
NS_NewSubDocumentFrame
)
SIMPLE_INT_CREATE
(
nsIObjectLoadingContent
:
:
TYPE_FAKE_PLUGIN
NS_NewSubDocumentFrame
)
}
;
return
FindDataByInt
(
(
int32_t
)
type
aElement
aComputedStyle
sObjectData
ArrayLength
(
sObjectData
)
)
;
}
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindCanvasData
(
Element
*
aElement
ComputedStyle
*
aComputedStyle
)
{
nsIDocument
*
doc
=
aElement
-
>
OwnerDoc
(
)
;
if
(
doc
-
>
IsStaticDocument
(
)
)
{
doc
=
doc
-
>
GetOriginalDocument
(
)
;
}
if
(
!
doc
-
>
IsScriptEnabled
(
)
)
{
return
nullptr
;
}
static
const
FrameConstructionData
sCanvasData
=
FCDATA_WITH_WRAPPING_BLOCK
(
0
NS_NewHTMLCanvasFrame
nsCSSAnonBoxes
:
:
htmlCanvasContent
)
;
return
&
sCanvasData
;
}
void
nsCSSFrameConstructor
:
:
ConstructFrameFromItemInternal
(
FrameConstructionItem
&
aItem
nsFrameConstructorState
&
aState
nsContainerFrame
*
aParentFrame
nsFrameItems
&
aFrameItems
)
{
const
FrameConstructionData
*
data
=
aItem
.
mFCData
;
NS_ASSERTION
(
data
"
Must
have
frame
construction
data
"
)
;
uint32_t
bits
=
data
-
>
mBits
;
NS_ASSERTION
(
!
(
bits
&
FCDATA_FUNC_IS_DATA_GETTER
)
"
Should
have
dealt
with
this
inside
the
data
finder
"
)
;
#
define
CHECK_ONLY_ONE_BIT
(
_bit1
_bit2
)
\
NS_ASSERTION
(
!
(
bits
&
_bit1
)
|
|
!
(
bits
&
_bit2
)
\
"
Only
one
of
these
bits
should
be
set
"
)
CHECK_ONLY_ONE_BIT
(
FCDATA_FUNC_IS_FULL_CTOR
FCDATA_FORCE_NULL_ABSPOS_CONTAINER
)
;
CHECK_ONLY_ONE_BIT
(
FCDATA_FUNC_IS_FULL_CTOR
FCDATA_WRAP_KIDS_IN_BLOCKS
)
;
CHECK_ONLY_ONE_BIT
(
FCDATA_FUNC_IS_FULL_CTOR
FCDATA_MAY_NEED_SCROLLFRAME
)
;
CHECK_ONLY_ONE_BIT
(
FCDATA_FUNC_IS_FULL_CTOR
FCDATA_IS_POPUP
)
;
CHECK_ONLY_ONE_BIT
(
FCDATA_FUNC_IS_FULL_CTOR
FCDATA_SKIP_ABSPOS_PUSH
)
;
CHECK_ONLY_ONE_BIT
(
FCDATA_FUNC_IS_FULL_CTOR
FCDATA_DISALLOW_GENERATED_CONTENT
)
;
CHECK_ONLY_ONE_BIT
(
FCDATA_FUNC_IS_FULL_CTOR
FCDATA_ALLOW_BLOCK_STYLES
)
;
CHECK_ONLY_ONE_BIT
(
FCDATA_FUNC_IS_FULL_CTOR
FCDATA_CREATE_BLOCK_WRAPPER_FOR_ALL_KIDS
)
;
CHECK_ONLY_ONE_BIT
(
FCDATA_WRAP_KIDS_IN_BLOCKS
FCDATA_CREATE_BLOCK_WRAPPER_FOR_ALL_KIDS
)
;
#
undef
CHECK_ONLY_ONE_BIT
NS_ASSERTION
(
!
(
bits
&
FCDATA_FORCED_NON_SCROLLABLE_BLOCK
)
|
|
(
(
bits
&
FCDATA_FUNC_IS_FULL_CTOR
)
&
&
data
-
>
mFullConstructor
=
=
&
nsCSSFrameConstructor
:
:
ConstructNonScrollableBlock
)
"
Unexpected
FCDATA_FORCED_NON_SCROLLABLE_BLOCK
flag
"
)
;
MOZ_ASSERT
(
!
(
bits
&
FCDATA_IS_WRAPPER_ANON_BOX
)
|
|
(
bits
&
FCDATA_USE_CHILD_ITEMS
)
"
Wrapper
anon
boxes
should
always
have
FCDATA_USE_CHILD_ITEMS
"
)
;
if
(
aState
.
mCreatingExtraFrames
&
&
aItem
.
mContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
iframe
)
)
{
return
;
}
nsIContent
*
const
content
=
aItem
.
mContent
;
nsIFrame
*
newFrame
;
nsIFrame
*
primaryFrame
;
ComputedStyle
*
const
computedStyle
=
aItem
.
mComputedStyle
;
const
nsStyleDisplay
*
display
=
computedStyle
-
>
StyleDisplay
(
)
;
if
(
bits
&
FCDATA_FUNC_IS_FULL_CTOR
)
{
newFrame
=
(
this
-
>
*
(
data
-
>
mFullConstructor
)
)
(
aState
aItem
aParentFrame
display
aFrameItems
)
;
MOZ_ASSERT
(
newFrame
"
Full
constructor
failed
"
)
;
primaryFrame
=
newFrame
;
}
else
{
newFrame
=
(
*
data
-
>
mFunc
.
mCreationFunc
)
(
mPresShell
computedStyle
)
;
bool
allowOutOfFlow
=
!
(
bits
&
FCDATA_DISALLOW_OUT_OF_FLOW
)
;
bool
isPopup
=
aItem
.
mIsPopup
;
NS_ASSERTION
(
!
isPopup
|
|
(
aState
.
mPopupItems
.
containingBlock
&
&
aState
.
mPopupItems
.
containingBlock
-
>
IsPopupSetFrame
(
)
)
"
Should
have
a
containing
block
here
!
"
)
;
nsContainerFrame
*
geometricParent
=
isPopup
?
aState
.
mPopupItems
.
containingBlock
:
(
allowOutOfFlow
?
aState
.
GetGeometricParent
(
display
aParentFrame
)
:
aParentFrame
)
;
nsIFrame
*
frameToAddToList
=
nullptr
;
if
(
(
bits
&
FCDATA_MAY_NEED_SCROLLFRAME
)
&
&
display
-
>
IsScrollableOverflow
(
)
)
{
nsContainerFrame
*
scrollframe
=
nullptr
;
BuildScrollFrame
(
aState
content
computedStyle
newFrame
geometricParent
scrollframe
)
;
frameToAddToList
=
scrollframe
;
}
else
{
InitAndRestoreFrame
(
aState
content
geometricParent
newFrame
)
;
frameToAddToList
=
newFrame
;
}
primaryFrame
=
frameToAddToList
;
const
nsStyleDisplay
*
maybeAbsoluteContainingBlockDisplay
=
display
;
nsIFrame
*
maybeAbsoluteContainingBlockStyleFrame
=
primaryFrame
;
nsIFrame
*
maybeAbsoluteContainingBlock
=
newFrame
;
nsIFrame
*
possiblyLeafFrame
=
newFrame
;
if
(
bits
&
FCDATA_CREATE_BLOCK_WRAPPER_FOR_ALL_KIDS
)
{
RefPtr
<
ComputedStyle
>
outerSC
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveInheritingAnonymousBoxStyle
(
*
data
-
>
mAnonBoxPseudo
computedStyle
)
;
#
ifdef
DEBUG
nsContainerFrame
*
containerFrame
=
do_QueryFrame
(
newFrame
)
;
MOZ_ASSERT
(
containerFrame
)
;
#
endif
nsContainerFrame
*
container
=
static_cast
<
nsContainerFrame
*
>
(
newFrame
)
;
nsContainerFrame
*
outerFrame
;
nsContainerFrame
*
innerFrame
;
if
(
bits
&
FCDATA_ALLOW_GRID_FLEX_COLUMNSET
)
{
switch
(
display
-
>
mDisplay
)
{
case
StyleDisplay
:
:
Flex
:
case
StyleDisplay
:
:
InlineFlex
:
outerFrame
=
NS_NewFlexContainerFrame
(
mPresShell
outerSC
)
;
InitAndRestoreFrame
(
aState
content
container
outerFrame
)
;
innerFrame
=
outerFrame
;
break
;
case
StyleDisplay
:
:
Grid
:
case
StyleDisplay
:
:
InlineGrid
:
outerFrame
=
NS_NewGridContainerFrame
(
mPresShell
outerSC
)
;
InitAndRestoreFrame
(
aState
content
container
outerFrame
)
;
innerFrame
=
outerFrame
;
break
;
default
:
{
nsContainerFrame
*
columnSetFrame
=
nullptr
;
RefPtr
<
ComputedStyle
>
innerSC
=
outerSC
;
const
nsStyleColumn
*
columns
=
outerSC
-
>
StyleColumn
(
)
;
if
(
columns
-
>
mColumnCount
!
=
NS_STYLE_COLUMN_COUNT_AUTO
|
|
columns
-
>
mColumnWidth
.
GetUnit
(
)
!
=
eStyleUnit_Auto
)
{
columnSetFrame
=
NS_NewColumnSetFrame
(
mPresShell
outerSC
nsFrameState
(
NS_FRAME_OWNS_ANON_BOXES
)
)
;
InitAndRestoreFrame
(
aState
content
container
columnSetFrame
)
;
innerSC
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveInheritingAnonymousBoxStyle
(
nsCSSAnonBoxes
:
:
columnContent
outerSC
)
;
}
innerFrame
=
NS_NewBlockFormattingContext
(
mPresShell
innerSC
)
;
if
(
columnSetFrame
)
{
InitAndRestoreFrame
(
aState
content
columnSetFrame
innerFrame
)
;
SetInitialSingleChild
(
columnSetFrame
innerFrame
)
;
outerFrame
=
columnSetFrame
;
}
else
{
InitAndRestoreFrame
(
aState
content
container
innerFrame
)
;
outerFrame
=
innerFrame
;
}
break
;
}
}
}
else
{
innerFrame
=
NS_NewBlockFormattingContext
(
mPresShell
outerSC
)
;
InitAndRestoreFrame
(
aState
content
container
innerFrame
)
;
outerFrame
=
innerFrame
;
}
SetInitialSingleChild
(
container
outerFrame
)
;
container
-
>
AddStateBits
(
NS_FRAME_OWNS_ANON_BOXES
)
;
auto
outerDisplay
=
outerSC
-
>
StyleDisplay
(
)
;
if
(
outerDisplay
-
>
IsAbsPosContainingBlock
(
outerFrame
)
)
{
maybeAbsoluteContainingBlockDisplay
=
outerDisplay
;
maybeAbsoluteContainingBlock
=
outerFrame
;
maybeAbsoluteContainingBlockStyleFrame
=
outerFrame
;
innerFrame
-
>
AddStateBits
(
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
;
}
newFrame
=
innerFrame
;
}
aState
.
AddChild
(
frameToAddToList
aFrameItems
content
aParentFrame
allowOutOfFlow
allowOutOfFlow
isPopup
)
;
nsContainerFrame
*
newFrameAsContainer
=
do_QueryFrame
(
newFrame
)
;
if
(
newFrameAsContainer
)
{
#
ifdef
MOZ_XUL
if
(
aItem
.
mIsRootPopupgroup
)
{
NS_ASSERTION
(
nsIRootBox
:
:
GetRootBox
(
mPresShell
)
&
&
nsIRootBox
:
:
GetRootBox
(
mPresShell
)
-
>
GetPopupSetFrame
(
)
=
=
newFrame
"
Unexpected
PopupSetFrame
"
)
;
aState
.
mPopupItems
.
containingBlock
=
newFrameAsContainer
;
aState
.
mHavePendingPopupgroup
=
false
;
}
#
endif
nsFrameItems
childItems
;
nsFrameConstructorSaveState
absoluteSaveState
;
if
(
bits
&
FCDATA_FORCE_NULL_ABSPOS_CONTAINER
)
{
aState
.
PushAbsoluteContainingBlock
(
nullptr
nullptr
absoluteSaveState
)
;
}
else
if
(
!
(
bits
&
FCDATA_SKIP_ABSPOS_PUSH
)
)
{
maybeAbsoluteContainingBlock
-
>
AddStateBits
(
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
;
if
(
(
maybeAbsoluteContainingBlockDisplay
-
>
IsAbsolutelyPositionedStyle
(
)
|
|
maybeAbsoluteContainingBlockDisplay
-
>
IsRelativelyPositionedStyle
(
)
|
|
maybeAbsoluteContainingBlockDisplay
-
>
IsFixedPosContainingBlock
(
maybeAbsoluteContainingBlockStyleFrame
)
)
&
&
!
nsSVGUtils
:
:
IsInSVGTextSubtree
(
maybeAbsoluteContainingBlockStyleFrame
)
)
{
nsContainerFrame
*
cf
=
static_cast
<
nsContainerFrame
*
>
(
maybeAbsoluteContainingBlock
)
;
aState
.
PushAbsoluteContainingBlock
(
cf
cf
absoluteSaveState
)
;
}
}
if
(
!
aItem
.
mAnonChildren
.
IsEmpty
(
)
)
{
NS_ASSERTION
(
!
(
bits
&
FCDATA_USE_CHILD_ITEMS
)
"
We
should
not
have
both
anonymous
and
non
-
anonymous
"
"
children
in
a
given
FrameConstructorItem
"
)
;
AddFCItemsForAnonymousContent
(
aState
newFrameAsContainer
aItem
.
mAnonChildren
aItem
.
mChildItems
)
;
bits
|
=
FCDATA_USE_CHILD_ITEMS
;
}
if
(
bits
&
FCDATA_USE_CHILD_ITEMS
)
{
nsFrameConstructorSaveState
floatSaveState
;
if
(
ShouldSuppressFloatingOfDescendants
(
newFrame
)
)
{
aState
.
PushFloatContainingBlock
(
nullptr
floatSaveState
)
;
}
else
if
(
newFrame
-
>
IsFloatContainingBlock
(
)
)
{
aState
.
PushFloatContainingBlock
(
newFrameAsContainer
floatSaveState
)
;
}
ConstructFramesFromItemList
(
aState
aItem
.
mChildItems
newFrameAsContainer
bits
&
FCDATA_IS_WRAPPER_ANON_BOX
childItems
)
;
}
else
{
ProcessChildren
(
aState
content
computedStyle
newFrameAsContainer
!
(
bits
&
FCDATA_DISALLOW_GENERATED_CONTENT
)
childItems
(
bits
&
FCDATA_ALLOW_BLOCK_STYLES
)
!
=
0
aItem
.
mPendingBinding
possiblyLeafFrame
)
;
}
if
(
bits
&
FCDATA_WRAP_KIDS_IN_BLOCKS
)
{
nsFrameItems
newItems
;
nsFrameItems
currentBlockItems
;
nsIFrame
*
f
;
while
(
(
f
=
childItems
.
FirstChild
(
)
)
!
=
nullptr
)
{
bool
wrapFrame
=
IsInlineFrame
(
f
)
|
|
IsFramePartOfIBSplit
(
f
)
;
if
(
!
wrapFrame
)
{
FlushAccumulatedBlock
(
aState
content
newFrameAsContainer
currentBlockItems
newItems
)
;
}
childItems
.
RemoveFrame
(
f
)
;
if
(
wrapFrame
)
{
currentBlockItems
.
AddChild
(
f
)
;
}
else
{
newItems
.
AddChild
(
f
)
;
}
}
FlushAccumulatedBlock
(
aState
content
newFrameAsContainer
currentBlockItems
newItems
)
;
if
(
childItems
.
NotEmpty
(
)
)
{
childItems
.
DestroyFrames
(
)
;
}
childItems
=
newItems
;
}
newFrameAsContainer
-
>
SetInitialChildList
(
kPrincipalList
childItems
)
;
}
}
NS_ASSERTION
(
newFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eLineParticipant
)
=
=
(
(
bits
&
FCDATA_IS_LINE_PARTICIPANT
)
!
=
0
)
"
Incorrectly
set
FCDATA_IS_LINE_PARTICIPANT
bits
"
)
;
if
(
aItem
.
mIsAnonymousContentCreatorContent
)
{
primaryFrame
-
>
AddStateBits
(
NS_FRAME_ANONYMOUSCONTENTCREATOR_CONTENT
)
;
}
if
(
(
!
aState
.
mCreatingExtraFrames
|
|
(
primaryFrame
-
>
HasAnyStateBits
(
NS_FRAME_ANONYMOUSCONTENTCREATOR_CONTENT
|
NS_FRAME_GENERATED_CONTENT
)
&
&
!
aItem
.
mContent
-
>
GetPrimaryFrame
(
)
)
)
&
&
!
(
bits
&
FCDATA_SKIP_FRAMESET
)
)
{
aItem
.
mContent
-
>
SetPrimaryFrame
(
primaryFrame
)
;
ActiveLayerTracker
:
:
TransferActivityToFrame
(
aItem
.
mContent
primaryFrame
)
;
}
}
static
void
SetFlagsOnSubtree
(
nsIContent
*
aNode
uintptr_t
aFlagsToSet
)
{
#
ifdef
DEBUG
{
FlattenedChildIterator
iter
(
aNode
)
;
NS_ASSERTION
(
!
iter
.
XBLInvolved
(
)
|
|
!
iter
.
GetNextChild
(
)
"
The
node
should
not
have
any
XBL
children
"
)
;
}
#
endif
aNode
-
>
SetFlags
(
aFlagsToSet
)
;
for
(
nsIContent
*
child
=
aNode
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
SetFlagsOnSubtree
(
child
aFlagsToSet
)
;
}
}
static
void
ConnectAnonymousTreeDescendants
(
nsIContent
*
aParent
nsTArray
<
nsIAnonymousContentCreator
:
:
ContentInfo
>
&
aContent
)
{
uint32_t
count
=
aContent
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
i
+
+
)
{
nsIContent
*
content
=
aContent
[
i
]
.
mContent
;
NS_ASSERTION
(
content
"
null
anonymous
content
?
"
)
;
ConnectAnonymousTreeDescendants
(
content
aContent
[
i
]
.
mChildren
)
;
aParent
-
>
AppendChildTo
(
content
false
)
;
}
}
nsresult
nsCSSFrameConstructor
:
:
GetAnonymousContent
(
nsIContent
*
aParent
nsIFrame
*
aParentFrame
nsTArray
<
nsIAnonymousContentCreator
:
:
ContentInfo
>
&
aContent
)
{
nsIAnonymousContentCreator
*
creator
=
do_QueryFrame
(
aParentFrame
)
;
if
(
!
creator
)
return
NS_OK
;
nsresult
rv
=
creator
-
>
CreateAnonymousContent
(
aContent
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
uint32_t
count
=
aContent
.
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
count
;
i
+
+
)
{
nsIContent
*
content
=
aContent
[
i
]
.
mContent
;
NS_ASSERTION
(
content
"
null
anonymous
content
?
"
)
;
ConnectAnonymousTreeDescendants
(
content
aContent
[
i
]
.
mChildren
)
;
if
(
aParentFrame
-
>
IsSVGUseFrame
(
)
)
{
content
-
>
SetFlags
(
NODE_IS_ANONYMOUS_ROOT
)
;
}
else
{
content
-
>
SetIsNativeAnonymousRoot
(
)
;
}
bool
anonContentIsEditable
=
content
-
>
HasFlag
(
NODE_IS_EDITABLE
)
;
nsIDocument
*
bindDocument
=
aParent
-
>
HasFlag
(
NODE_IS_IN_SHADOW_TREE
)
?
nullptr
:
mDocument
;
rv
=
content
-
>
BindToTree
(
bindDocument
aParent
aParent
true
)
;
if
(
anonContentIsEditable
)
{
NS_ASSERTION
(
aParentFrame
-
>
IsTextInputFrame
(
)
"
We
only
expect
this
for
anonymous
content
under
a
text
control
frame
"
)
;
SetFlagsOnSubtree
(
content
NODE_IS_EDITABLE
)
;
}
if
(
NS_FAILED
(
rv
)
)
{
content
-
>
UnbindFromTree
(
)
;
return
rv
;
}
}
ServoStyleSet
*
styleSet
=
mPresShell
-
>
StyleSet
(
)
;
for
(
auto
&
info
:
aContent
)
{
if
(
info
.
mContent
-
>
IsElement
(
)
)
{
styleSet
-
>
StyleNewSubtree
(
info
.
mContent
-
>
AsElement
(
)
)
;
}
}
return
NS_OK
;
}
static
bool
IsXULDisplayType
(
const
nsStyleDisplay
*
aDisplay
)
{
if
(
!
StaticPrefs
:
:
layout_css_emulate_moz_box_with_flex
(
)
&
&
(
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
MozInlineBox
|
|
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
MozBox
)
)
{
return
true
;
}
#
ifdef
MOZ_XUL
return
(
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
MozInlineGrid
|
|
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
MozInlineStack
|
|
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
MozGrid
|
|
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
MozStack
|
|
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
MozGridGroup
|
|
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
MozGridLine
|
|
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
MozDeck
|
|
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
MozPopup
|
|
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
MozGroupbox
)
;
#
else
return
false
;
#
endif
}
#
define
SIMPLE_XUL_FCDATA
(
_func
)
\
FCDATA_DECL
(
FCDATA_DISALLOW_OUT_OF_FLOW
|
FCDATA_SKIP_ABSPOS_PUSH
\
_func
)
#
define
SCROLLABLE_XUL_FCDATA
(
_func
)
\
FCDATA_DECL
(
FCDATA_DISALLOW_OUT_OF_FLOW
|
FCDATA_SKIP_ABSPOS_PUSH
|
\
FCDATA_MAY_NEED_SCROLLFRAME
_func
)
#
define
SCROLLABLE_ABSPOS_CONTAINER_XUL_FCDATA
(
_func
)
\
FCDATA_DECL
(
FCDATA_DISALLOW_OUT_OF_FLOW
|
\
FCDATA_MAY_NEED_SCROLLFRAME
_func
)
#
define
SIMPLE_XUL_CREATE
(
_tag
_func
)
\
{
&
nsGkAtoms
:
:
_tag
SIMPLE_XUL_FCDATA
(
_func
)
}
#
define
SCROLLABLE_XUL_CREATE
(
_tag
_func
)
\
{
&
nsGkAtoms
:
:
_tag
SCROLLABLE_XUL_FCDATA
(
_func
)
}
#
define
SIMPLE_XUL_DISPLAY_CREATE
(
_display
_func
)
\
FCDATA_FOR_DISPLAY
(
_display
SIMPLE_XUL_FCDATA
(
_func
)
)
#
define
SCROLLABLE_XUL_DISPLAY_CREATE
(
_display
_func
)
\
FCDATA_FOR_DISPLAY
(
_display
SCROLLABLE_XUL_FCDATA
(
_func
)
)
#
define
SCROLLABLE_ABSPOS_CONTAINER_XUL_DISPLAY_CREATE
(
_display
_func
)
\
FCDATA_FOR_DISPLAY
(
_display
SCROLLABLE_ABSPOS_CONTAINER_XUL_FCDATA
(
_func
)
)
static
nsIFrame
*
NS_NewGridBoxFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aComputedStyle
)
{
nsCOMPtr
<
nsBoxLayout
>
layout
;
NS_NewGridLayout2
(
aPresShell
getter_AddRefs
(
layout
)
)
;
return
NS_NewBoxFrame
(
aPresShell
aComputedStyle
false
layout
)
;
}
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindXULTagData
(
Element
*
aElement
nsAtom
*
aTag
int32_t
aNameSpaceID
ComputedStyle
*
aComputedStyle
)
{
if
(
aNameSpaceID
!
=
kNameSpaceID_XUL
)
{
return
nullptr
;
}
static
const
FrameConstructionDataByTag
sXULTagData
[
]
=
{
#
ifdef
MOZ_XUL
SCROLLABLE_XUL_CREATE
(
button
NS_NewButtonBoxFrame
)
SCROLLABLE_XUL_CREATE
(
thumb
NS_NewButtonBoxFrame
)
SCROLLABLE_XUL_CREATE
(
checkbox
NS_NewButtonBoxFrame
)
SCROLLABLE_XUL_CREATE
(
radio
NS_NewButtonBoxFrame
)
SCROLLABLE_XUL_CREATE
(
autorepeatbutton
NS_NewAutoRepeatBoxFrame
)
SCROLLABLE_XUL_CREATE
(
titlebar
NS_NewTitleBarFrame
)
SCROLLABLE_XUL_CREATE
(
resizer
NS_NewResizerFrame
)
SCROLLABLE_XUL_CREATE
(
toolbarpaletteitem
NS_NewBoxFrame
)
SIMPLE_XUL_CREATE
(
image
NS_NewImageBoxFrame
)
SIMPLE_XUL_CREATE
(
spring
NS_NewLeafBoxFrame
)
SIMPLE_XUL_CREATE
(
spacer
NS_NewLeafBoxFrame
)
SIMPLE_XUL_CREATE
(
treechildren
NS_NewTreeBodyFrame
)
SIMPLE_XUL_CREATE
(
treecol
NS_NewTreeColFrame
)
SIMPLE_XUL_CREATE
(
text
NS_NewTextBoxFrame
)
SIMPLE_TAG_CHAIN
(
label
nsCSSFrameConstructor
:
:
FindXULLabelData
)
SIMPLE_TAG_CHAIN
(
description
nsCSSFrameConstructor
:
:
FindXULDescriptionData
)
SIMPLE_XUL_CREATE
(
menu
NS_NewMenuFrame
)
SIMPLE_XUL_CREATE
(
menubutton
NS_NewMenuFrame
)
SIMPLE_XUL_CREATE
(
menuitem
NS_NewMenuItemFrame
)
#
ifdef
XP_MACOSX
SIMPLE_TAG_CHAIN
(
menubar
nsCSSFrameConstructor
:
:
FindXULMenubarData
)
#
else
SIMPLE_XUL_CREATE
(
menubar
NS_NewMenuBarFrame
)
#
endif
SIMPLE_TAG_CHAIN
(
popupgroup
nsCSSFrameConstructor
:
:
FindPopupGroupData
)
SIMPLE_XUL_CREATE
(
iframe
NS_NewSubDocumentFrame
)
SIMPLE_XUL_CREATE
(
editor
NS_NewSubDocumentFrame
)
SIMPLE_XUL_CREATE
(
browser
NS_NewSubDocumentFrame
)
SIMPLE_XUL_CREATE
(
progressmeter
NS_NewProgressMeterFrame
)
SIMPLE_XUL_CREATE
(
splitter
NS_NewSplitterFrame
)
SIMPLE_TAG_CHAIN
(
listboxbody
nsCSSFrameConstructor
:
:
FindXULListBoxBodyData
)
SIMPLE_TAG_CHAIN
(
listitem
nsCSSFrameConstructor
:
:
FindXULListItemData
)
#
endif
SIMPLE_XUL_CREATE
(
slider
NS_NewSliderFrame
)
SIMPLE_XUL_CREATE
(
scrollbar
NS_NewScrollbarFrame
)
SIMPLE_XUL_CREATE
(
scrollbarbutton
NS_NewScrollbarButtonFrame
)
}
;
return
FindDataByTag
(
aTag
aElement
aComputedStyle
sXULTagData
ArrayLength
(
sXULTagData
)
)
;
}
#
ifdef
MOZ_XUL
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindPopupGroupData
(
Element
*
aElement
ComputedStyle
*
)
{
if
(
!
aElement
-
>
IsRootOfNativeAnonymousSubtree
(
)
)
{
return
nullptr
;
}
static
const
FrameConstructionData
sPopupSetData
=
SIMPLE_XUL_FCDATA
(
NS_NewPopupSetFrame
)
;
return
&
sPopupSetData
;
}
const
nsCSSFrameConstructor
:
:
FrameConstructionData
nsCSSFrameConstructor
:
:
sXULTextBoxData
=
SIMPLE_XUL_FCDATA
(
NS_NewTextBoxFrame
)
;
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindXULLabelData
(
Element
*
aElement
ComputedStyle
*
)
{
if
(
aElement
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
value
)
)
{
return
&
sXULTextBoxData
;
}
static
const
FrameConstructionData
sLabelData
=
SIMPLE_XUL_FCDATA
(
NS_NewXULLabelFrame
)
;
return
&
sLabelData
;
}
static
nsIFrame
*
NS_NewXULDescriptionFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aContext
)
{
return
NS_NewBlockFormattingContext
(
aPresShell
aContext
)
;
}
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindXULDescriptionData
(
Element
*
aElement
ComputedStyle
*
)
{
if
(
aElement
-
>
HasAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
value
)
)
{
return
&
sXULTextBoxData
;
}
static
const
FrameConstructionData
sDescriptionData
=
SIMPLE_XUL_FCDATA
(
NS_NewXULDescriptionFrame
)
;
return
&
sDescriptionData
;
}
#
ifdef
XP_MACOSX
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindXULMenubarData
(
Element
*
aElement
ComputedStyle
*
aComputedStyle
)
{
nsCOMPtr
<
nsIDocShell
>
treeItem
=
aElement
-
>
OwnerDoc
(
)
-
>
GetDocShell
(
)
;
if
(
treeItem
&
&
nsIDocShellTreeItem
:
:
typeChrome
=
=
treeItem
-
>
ItemType
(
)
)
{
nsCOMPtr
<
nsIDocShellTreeItem
>
parent
;
treeItem
-
>
GetParent
(
getter_AddRefs
(
parent
)
)
;
if
(
!
parent
)
{
static
const
FrameConstructionData
sSuppressData
=
SUPPRESS_FCDATA
(
)
;
return
&
sSuppressData
;
}
}
static
const
FrameConstructionData
sMenubarData
=
SIMPLE_XUL_FCDATA
(
NS_NewMenuBarFrame
)
;
return
&
sMenubarData
;
}
#
endif
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindXULListBoxBodyData
(
Element
*
aElement
ComputedStyle
*
aComputedStyle
)
{
if
(
aComputedStyle
-
>
StyleDisplay
(
)
-
>
mDisplay
!
=
StyleDisplay
:
:
MozGridGroup
)
{
return
nullptr
;
}
static
const
FrameConstructionData
sListBoxBodyData
=
SCROLLABLE_XUL_FCDATA
(
NS_NewListBoxBodyFrame
)
;
return
&
sListBoxBodyData
;
}
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindXULListItemData
(
Element
*
aElement
ComputedStyle
*
aComputedStyle
)
{
if
(
aComputedStyle
-
>
StyleDisplay
(
)
-
>
mDisplay
!
=
StyleDisplay
:
:
MozGridLine
)
{
return
nullptr
;
}
static
const
FrameConstructionData
sListItemData
=
SCROLLABLE_XUL_FCDATA
(
NS_NewListItemFrame
)
;
return
&
sListItemData
;
}
#
endif
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindXULDisplayData
(
const
nsStyleDisplay
*
aDisplay
Element
*
aElement
ComputedStyle
*
aComputedStyle
)
{
static
const
FrameConstructionDataByDisplay
sXULDisplayData
[
]
=
{
SCROLLABLE_ABSPOS_CONTAINER_XUL_DISPLAY_CREATE
(
StyleDisplay
:
:
MozBox
NS_NewBoxFrame
)
SCROLLABLE_ABSPOS_CONTAINER_XUL_DISPLAY_CREATE
(
StyleDisplay
:
:
MozInlineBox
NS_NewBoxFrame
)
#
ifdef
MOZ_XUL
SCROLLABLE_XUL_DISPLAY_CREATE
(
StyleDisplay
:
:
MozGrid
NS_NewGridBoxFrame
)
SCROLLABLE_XUL_DISPLAY_CREATE
(
StyleDisplay
:
:
MozInlineGrid
NS_NewGridBoxFrame
)
SCROLLABLE_XUL_DISPLAY_CREATE
(
StyleDisplay
:
:
MozGridGroup
NS_NewGridRowGroupFrame
)
SCROLLABLE_XUL_DISPLAY_CREATE
(
StyleDisplay
:
:
MozGridLine
NS_NewGridRowLeafFrame
)
SCROLLABLE_XUL_DISPLAY_CREATE
(
StyleDisplay
:
:
MozStack
NS_NewStackFrame
)
SCROLLABLE_XUL_DISPLAY_CREATE
(
StyleDisplay
:
:
MozInlineStack
NS_NewStackFrame
)
SIMPLE_XUL_DISPLAY_CREATE
(
StyleDisplay
:
:
MozDeck
NS_NewDeckFrame
)
SCROLLABLE_XUL_DISPLAY_CREATE
(
StyleDisplay
:
:
MozGroupbox
NS_NewGroupBoxFrame
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
MozPopup
FCDATA_DECL
(
FCDATA_DISALLOW_OUT_OF_FLOW
|
FCDATA_IS_POPUP
|
FCDATA_SKIP_ABSPOS_PUSH
NS_NewMenuPopupFrame
)
)
#
endif
}
;
if
(
aDisplay
-
>
mDisplay
<
StyleDisplay
:
:
MozBox
)
{
return
nullptr
;
}
if
(
StaticPrefs
:
:
layout_css_emulate_moz_box_with_flex
(
)
&
&
aElement
&
&
!
aElement
-
>
IsXULElement
(
nsGkAtoms
:
:
scrollcorner
)
&
&
(
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
MozBox
|
|
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
MozInlineBox
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
aDisplay
-
>
mDisplay
<
=
StyleDisplay
:
:
MozPopup
"
Someone
added
a
new
display
value
?
"
)
;
const
FrameConstructionDataByDisplay
&
data
=
sXULDisplayData
[
size_t
(
aDisplay
-
>
mDisplay
)
-
size_t
(
StyleDisplay
:
:
MozBox
)
]
;
MOZ_ASSERT
(
aDisplay
-
>
mDisplay
=
=
data
.
mDisplay
"
Did
someone
mess
with
the
order
?
"
)
;
return
&
data
.
mData
;
}
already_AddRefed
<
ComputedStyle
>
nsCSSFrameConstructor
:
:
BeginBuildingScrollFrame
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
ComputedStyle
*
aContentStyle
nsContainerFrame
*
aParentFrame
nsAtom
*
aScrolledPseudo
bool
aIsRoot
nsContainerFrame
*
&
aNewFrame
)
{
nsContainerFrame
*
gfxScrollFrame
=
aNewFrame
;
nsFrameItems
anonymousItems
;
RefPtr
<
ComputedStyle
>
contentStyle
=
aContentStyle
;
if
(
!
gfxScrollFrame
)
{
const
nsStyleDisplay
*
displayStyle
=
aContentStyle
-
>
StyleDisplay
(
)
;
if
(
IsXULDisplayType
(
displayStyle
)
)
{
gfxScrollFrame
=
NS_NewXULScrollFrame
(
mPresShell
contentStyle
aIsRoot
displayStyle
-
>
mDisplay
=
=
StyleDisplay
:
:
MozStack
|
|
displayStyle
-
>
mDisplay
=
=
StyleDisplay
:
:
MozInlineStack
)
;
}
else
{
gfxScrollFrame
=
NS_NewHTMLScrollFrame
(
mPresShell
contentStyle
aIsRoot
)
;
}
InitAndRestoreFrame
(
aState
aContent
aParentFrame
gfxScrollFrame
)
;
}
AutoTArray
<
nsIAnonymousContentCreator
:
:
ContentInfo
4
>
scrollNAC
;
DebugOnly
<
nsresult
>
rv
=
GetAnonymousContent
(
aContent
gfxScrollFrame
scrollNAC
)
;
MOZ_ASSERT
(
NS_SUCCEEDED
(
rv
)
)
;
if
(
scrollNAC
.
Length
(
)
>
0
)
{
AutoFrameConstructionItemList
items
(
this
)
;
AddFCItemsForAnonymousContent
(
aState
gfxScrollFrame
scrollNAC
items
)
;
ConstructFramesFromItemList
(
aState
items
gfxScrollFrame
false
anonymousItems
)
;
}
aNewFrame
=
gfxScrollFrame
;
gfxScrollFrame
-
>
AddStateBits
(
NS_FRAME_OWNS_ANON_BOXES
)
;
ServoStyleSet
*
styleSet
=
mPresShell
-
>
StyleSet
(
)
;
RefPtr
<
ComputedStyle
>
scrolledChildStyle
=
styleSet
-
>
ResolveInheritingAnonymousBoxStyle
(
aScrolledPseudo
contentStyle
)
;
if
(
gfxScrollFrame
)
{
gfxScrollFrame
-
>
SetInitialChildList
(
kPrincipalList
anonymousItems
)
;
}
return
scrolledChildStyle
.
forget
(
)
;
}
void
nsCSSFrameConstructor
:
:
FinishBuildingScrollFrame
(
nsContainerFrame
*
aScrollFrame
nsIFrame
*
aScrolledFrame
)
{
nsFrameList
scrolled
(
aScrolledFrame
aScrolledFrame
)
;
aScrollFrame
-
>
AppendFrames
(
kPrincipalList
scrolled
)
;
}
void
nsCSSFrameConstructor
:
:
BuildScrollFrame
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
ComputedStyle
*
aContentStyle
nsIFrame
*
aScrolledFrame
nsContainerFrame
*
aParentFrame
nsContainerFrame
*
&
aNewFrame
)
{
RefPtr
<
ComputedStyle
>
scrolledContentStyle
=
BeginBuildingScrollFrame
(
aState
aContent
aContentStyle
aParentFrame
nsCSSAnonBoxes
:
:
scrolledContent
false
aNewFrame
)
;
aScrolledFrame
-
>
SetComputedStyleWithoutNotification
(
scrolledContentStyle
)
;
InitAndRestoreFrame
(
aState
aContent
aNewFrame
aScrolledFrame
)
;
FinishBuildingScrollFrame
(
aNewFrame
aScrolledFrame
)
;
}
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindDisplayData
(
const
nsStyleDisplay
*
aDisplay
Element
*
aElement
ComputedStyle
*
aComputedStyle
)
{
static_assert
(
eParentTypeCount
<
(
1
<
<
(
32
-
FCDATA_PARENT_TYPE_OFFSET
)
)
"
Check
eParentTypeCount
should
not
overflow
"
)
;
NS_ASSERTION
(
!
(
aDisplay
-
>
IsFloatingStyle
(
)
|
|
aDisplay
-
>
IsAbsolutelyPositionedStyle
(
)
)
|
|
aDisplay
-
>
IsBlockOutsideStyle
(
)
|
|
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
Contents
"
Style
system
did
not
apply
CSS2
.
1
section
9
.
7
fixups
"
)
;
bool
propagatedScrollToViewport
=
false
;
if
(
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
if
(
nsPresContext
*
presContext
=
mPresShell
-
>
GetPresContext
(
)
)
{
propagatedScrollToViewport
=
presContext
-
>
UpdateViewportScrollbarStylesOverride
(
)
=
=
aElement
;
}
}
NS_ASSERTION
(
!
propagatedScrollToViewport
|
|
!
mPresShell
-
>
GetPresContext
(
)
-
>
IsPaginated
(
)
"
Shouldn
'
t
propagate
scroll
in
paginated
contexts
"
)
;
if
(
aDisplay
-
>
IsBlockInsideStyle
(
)
)
{
const
uint32_t
kCaptionCtorFlags
=
FCDATA_IS_TABLE_PART
|
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
eTypeTable
)
;
bool
caption
=
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
TableCaption
;
bool
suppressScrollFrame
=
false
;
bool
needScrollFrame
=
aDisplay
-
>
IsScrollableOverflow
(
)
&
&
!
propagatedScrollToViewport
;
if
(
needScrollFrame
)
{
suppressScrollFrame
=
mPresShell
-
>
GetPresContext
(
)
-
>
IsPaginated
(
)
&
&
aDisplay
-
>
IsBlockOutsideStyle
(
)
&
&
!
aElement
-
>
IsInNativeAnonymousSubtree
(
)
;
if
(
!
suppressScrollFrame
)
{
static
const
FrameConstructionData
sScrollableBlockData
[
2
]
=
{
FULL_CTOR_FCDATA
(
0
&
nsCSSFrameConstructor
:
:
ConstructScrollableBlock
)
FULL_CTOR_FCDATA
(
kCaptionCtorFlags
&
nsCSSFrameConstructor
:
:
ConstructScrollableBlock
)
}
;
return
&
sScrollableBlockData
[
caption
]
;
}
if
(
mPresShell
-
>
GetPresContext
(
)
-
>
ElementWouldPropagateScrollbarStyles
(
aElement
)
)
{
suppressScrollFrame
=
false
;
}
}
static
const
FrameConstructionData
sNonScrollableBlockData
[
2
]
[
2
]
=
{
{
FULL_CTOR_FCDATA
(
0
&
nsCSSFrameConstructor
:
:
ConstructNonScrollableBlock
)
FULL_CTOR_FCDATA
(
kCaptionCtorFlags
&
nsCSSFrameConstructor
:
:
ConstructNonScrollableBlock
)
}
{
FULL_CTOR_FCDATA
(
FCDATA_FORCED_NON_SCROLLABLE_BLOCK
&
nsCSSFrameConstructor
:
:
ConstructNonScrollableBlock
)
FULL_CTOR_FCDATA
(
FCDATA_FORCED_NON_SCROLLABLE_BLOCK
|
kCaptionCtorFlags
&
nsCSSFrameConstructor
:
:
ConstructNonScrollableBlock
)
}
}
;
return
&
sNonScrollableBlockData
[
suppressScrollFrame
]
[
caption
]
;
}
if
(
propagatedScrollToViewport
&
&
aDisplay
-
>
IsScrollableOverflow
(
)
)
{
if
(
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
Flex
|
|
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
WebkitBox
|
|
(
StaticPrefs
:
:
layout_css_emulate_moz_box_with_flex
(
)
&
&
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
MozBox
)
)
{
static
const
FrameConstructionData
sNonScrollableFlexData
=
FCDATA_DECL
(
0
NS_NewFlexContainerFrame
)
;
return
&
sNonScrollableFlexData
;
}
if
(
aDisplay
-
>
mDisplay
=
=
StyleDisplay
:
:
Grid
)
{
static
const
FrameConstructionData
sNonScrollableGridData
=
FCDATA_DECL
(
0
NS_NewGridContainerFrame
)
;
return
&
sNonScrollableGridData
;
}
}
static
const
FrameConstructionDataByDisplay
sDisplayData
[
]
=
{
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
None
UNREACHABLE_FCDATA
(
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
Block
UNREACHABLE_FCDATA
(
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
FlowRoot
UNREACHABLE_FCDATA
(
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
Inline
FULL_CTOR_FCDATA
(
FCDATA_IS_INLINE
|
FCDATA_IS_LINE_PARTICIPANT
&
nsCSSFrameConstructor
:
:
ConstructInline
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
InlineBlock
UNREACHABLE_FCDATA
(
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
ListItem
UNREACHABLE_FCDATA
(
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
Table
FULL_CTOR_FCDATA
(
0
&
nsCSSFrameConstructor
:
:
ConstructTable
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
InlineTable
FULL_CTOR_FCDATA
(
0
&
nsCSSFrameConstructor
:
:
ConstructTable
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
TableRowGroup
FULL_CTOR_FCDATA
(
FCDATA_IS_TABLE_PART
|
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
eTypeTable
)
&
nsCSSFrameConstructor
:
:
ConstructTableRowOrRowGroup
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
TableColumn
FULL_CTOR_FCDATA
(
FCDATA_IS_TABLE_PART
|
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
eTypeColGroup
)
&
nsCSSFrameConstructor
:
:
ConstructTableCol
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
TableColumnGroup
FCDATA_DECL
(
FCDATA_IS_TABLE_PART
|
FCDATA_DISALLOW_OUT_OF_FLOW
|
FCDATA_SKIP_ABSPOS_PUSH
|
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
eTypeTable
)
NS_NewTableColGroupFrame
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
TableHeaderGroup
FULL_CTOR_FCDATA
(
FCDATA_IS_TABLE_PART
|
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
eTypeTable
)
&
nsCSSFrameConstructor
:
:
ConstructTableRowOrRowGroup
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
TableFooterGroup
FULL_CTOR_FCDATA
(
FCDATA_IS_TABLE_PART
|
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
eTypeTable
)
&
nsCSSFrameConstructor
:
:
ConstructTableRowOrRowGroup
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
TableRow
FULL_CTOR_FCDATA
(
FCDATA_IS_TABLE_PART
|
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
eTypeRowGroup
)
&
nsCSSFrameConstructor
:
:
ConstructTableRowOrRowGroup
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
TableCell
FULL_CTOR_FCDATA
(
FCDATA_IS_TABLE_PART
|
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
eTypeRow
)
&
nsCSSFrameConstructor
:
:
ConstructTableCell
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
TableCaption
UNREACHABLE_FCDATA
(
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
Flex
FCDATA_DECL
(
FCDATA_MAY_NEED_SCROLLFRAME
NS_NewFlexContainerFrame
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
InlineFlex
FCDATA_DECL
(
FCDATA_MAY_NEED_SCROLLFRAME
NS_NewFlexContainerFrame
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
Grid
FCDATA_DECL
(
FCDATA_MAY_NEED_SCROLLFRAME
NS_NewGridContainerFrame
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
InlineGrid
FCDATA_DECL
(
FCDATA_MAY_NEED_SCROLLFRAME
NS_NewGridContainerFrame
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
Ruby
FCDATA_DECL
(
FCDATA_IS_LINE_PARTICIPANT
NS_NewRubyFrame
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
RubyBase
FCDATA_DECL
(
FCDATA_IS_LINE_PARTICIPANT
|
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
eTypeRubyBaseContainer
)
NS_NewRubyBaseFrame
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
RubyBaseContainer
FCDATA_DECL
(
FCDATA_IS_LINE_PARTICIPANT
|
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
eTypeRuby
)
NS_NewRubyBaseContainerFrame
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
RubyText
FCDATA_DECL
(
FCDATA_IS_LINE_PARTICIPANT
|
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
eTypeRubyTextContainer
)
NS_NewRubyTextFrame
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
RubyTextContainer
FCDATA_DECL
(
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
eTypeRuby
)
NS_NewRubyTextContainerFrame
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
Contents
UNREACHABLE_FCDATA
(
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
WebkitBox
FCDATA_DECL
(
FCDATA_MAY_NEED_SCROLLFRAME
NS_NewFlexContainerFrame
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
WebkitInlineBox
FCDATA_DECL
(
FCDATA_MAY_NEED_SCROLLFRAME
NS_NewFlexContainerFrame
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
MozBox
FCDATA_DECL
(
FCDATA_MAY_NEED_SCROLLFRAME
NS_NewFlexContainerFrame
)
)
FCDATA_FOR_DISPLAY
(
StyleDisplay
:
:
MozInlineBox
FCDATA_DECL
(
FCDATA_MAY_NEED_SCROLLFRAME
NS_NewFlexContainerFrame
)
)
}
;
static_assert
(
ArrayLength
(
sDisplayData
)
=
=
size_t
(
StyleDisplay
:
:
MozInlineBox
)
+
1
"
Be
sure
to
update
sDisplayData
if
you
touch
StyleDisplay
"
)
;
MOZ_ASSERT
(
StaticPrefs
:
:
layout_css_emulate_moz_box_with_flex
(
)
|
|
(
aDisplay
-
>
mDisplay
!
=
StyleDisplay
:
:
MozBox
&
&
aDisplay
-
>
mDisplay
!
=
StyleDisplay
:
:
MozInlineBox
)
"
-
moz
-
{
inline
-
}
box
as
XUL
should
have
already
been
handled
"
)
;
MOZ_ASSERT
(
size_t
(
aDisplay
-
>
mDisplay
)
<
ArrayLength
(
sDisplayData
)
"
XUL
display
data
should
have
already
been
handled
"
)
;
MOZ_ASSERT
(
aDisplay
-
>
mDisplay
!
=
StyleDisplay
:
:
Contents
|
|
!
aElement
-
>
IsRootOfNativeAnonymousSubtree
(
)
"
display
:
contents
on
anonymous
content
is
unsupported
"
)
;
const
FrameConstructionDataByDisplay
&
data
=
sDisplayData
[
size_t
(
aDisplay
-
>
mDisplay
)
]
;
MOZ_ASSERT
(
data
.
mDisplay
=
=
aDisplay
-
>
mDisplay
"
Someone
messed
up
the
order
in
the
display
values
"
)
;
return
&
data
.
mData
;
}
nsIFrame
*
nsCSSFrameConstructor
:
:
ConstructScrollableBlock
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aDisplay
nsFrameItems
&
aFrameItems
)
{
return
ConstructScrollableBlockWithConstructor
(
aState
aItem
aParentFrame
aDisplay
aFrameItems
NS_NewBlockFormattingContext
)
;
}
nsIFrame
*
nsCSSFrameConstructor
:
:
ConstructScrollableBlockWithConstructor
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aDisplay
nsFrameItems
&
aFrameItems
BlockFrameCreationFunc
aConstructor
)
{
nsIContent
*
const
content
=
aItem
.
mContent
;
ComputedStyle
*
const
computedStyle
=
aItem
.
mComputedStyle
;
nsContainerFrame
*
newFrame
=
nullptr
;
RefPtr
<
ComputedStyle
>
scrolledContentStyle
=
BeginBuildingScrollFrame
(
aState
content
computedStyle
aState
.
GetGeometricParent
(
aDisplay
aParentFrame
)
nsCSSAnonBoxes
:
:
scrolledContent
false
newFrame
)
;
nsContainerFrame
*
scrolledFrame
=
aConstructor
(
mPresShell
computedStyle
)
;
aState
.
AddChild
(
newFrame
aFrameItems
content
aParentFrame
)
;
nsFrameItems
blockItem
;
ConstructBlock
(
aState
content
newFrame
newFrame
scrolledContentStyle
&
scrolledFrame
blockItem
aDisplay
-
>
IsAbsPosContainingBlock
(
newFrame
)
?
newFrame
:
nullptr
aItem
.
mPendingBinding
)
;
MOZ_ASSERT
(
blockItem
.
OnlyChild
(
)
=
=
scrolledFrame
"
Scrollframe
'
s
frameItems
should
be
exactly
the
scrolled
frame
!
"
)
;
FinishBuildingScrollFrame
(
newFrame
scrolledFrame
)
;
return
newFrame
;
}
nsIFrame
*
nsCSSFrameConstructor
:
:
ConstructNonScrollableBlock
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aDisplay
nsFrameItems
&
aFrameItems
)
{
return
ConstructNonScrollableBlockWithConstructor
(
aState
aItem
aParentFrame
aDisplay
aFrameItems
NS_NewBlockFrame
)
;
}
nsIFrame
*
nsCSSFrameConstructor
:
:
ConstructNonScrollableBlockWithConstructor
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aDisplay
nsFrameItems
&
aFrameItems
BlockFrameCreationFunc
aConstructor
)
{
ComputedStyle
*
const
computedStyle
=
aItem
.
mComputedStyle
;
bool
clipPaginatedOverflow
=
(
aItem
.
mFCData
-
>
mBits
&
FCDATA_FORCED_NON_SCROLLABLE_BLOCK
)
!
=
0
;
nsFrameState
flags
=
nsFrameState
(
0
)
;
if
(
(
aDisplay
-
>
IsAbsolutelyPositionedStyle
(
)
|
|
aDisplay
-
>
IsFloatingStyle
(
)
|
|
StyleDisplay
:
:
InlineBlock
=
=
aDisplay
-
>
mDisplay
|
|
clipPaginatedOverflow
)
&
&
!
nsSVGUtils
:
:
IsInSVGTextSubtree
(
aParentFrame
)
)
{
flags
=
NS_BLOCK_FORMATTING_CONTEXT_STATE_BITS
;
if
(
clipPaginatedOverflow
)
{
flags
|
=
NS_BLOCK_CLIP_PAGINATED_OVERFLOW
;
}
}
nsContainerFrame
*
newFrame
=
aConstructor
(
mPresShell
computedStyle
)
;
newFrame
-
>
AddStateBits
(
flags
)
;
ConstructBlock
(
aState
aItem
.
mContent
aState
.
GetGeometricParent
(
aDisplay
aParentFrame
)
aParentFrame
computedStyle
&
newFrame
aFrameItems
aDisplay
-
>
IsAbsPosContainingBlock
(
newFrame
)
?
newFrame
:
nullptr
aItem
.
mPendingBinding
)
;
return
newFrame
;
}
void
nsCSSFrameConstructor
:
:
InitAndRestoreFrame
(
const
nsFrameConstructorState
&
aState
nsIContent
*
aContent
nsContainerFrame
*
aParentFrame
nsIFrame
*
aNewFrame
bool
aAllowCounters
)
{
MOZ_ASSERT
(
aNewFrame
"
Null
frame
cannot
be
initialized
"
)
;
aNewFrame
-
>
Init
(
aContent
aParentFrame
nullptr
)
;
aNewFrame
-
>
AddStateBits
(
aState
.
mAdditionalStateBits
)
;
if
(
aState
.
mFrameState
)
{
RestoreFrameStateFor
(
aNewFrame
aState
.
mFrameState
)
;
}
if
(
aAllowCounters
&
&
mCounterManager
.
AddCounterResetsAndIncrements
(
aNewFrame
)
)
{
CountersDirty
(
)
;
}
}
already_AddRefed
<
ComputedStyle
>
nsCSSFrameConstructor
:
:
ResolveComputedStyle
(
nsIContent
*
aContent
)
{
ServoStyleSet
*
styleSet
=
mPresShell
-
>
StyleSet
(
)
;
if
(
aContent
-
>
IsElement
(
)
)
{
return
styleSet
-
>
ResolveServoStyle
(
aContent
-
>
AsElement
(
)
)
;
}
MOZ_ASSERT
(
aContent
-
>
IsText
(
)
"
shouldn
'
t
waste
time
creating
ComputedStyles
for
"
"
comments
and
processing
instructions
"
)
;
Element
*
parent
=
aContent
-
>
GetFlattenedTreeParentElement
(
)
;
MOZ_ASSERT
(
parent
"
Text
out
of
the
flattened
tree
?
"
)
;
RefPtr
<
ComputedStyle
>
parentStyle
=
Servo_Element_GetPrimaryComputedValues
(
parent
)
.
Consume
(
)
;
return
styleSet
-
>
ResolveStyleForText
(
aContent
parentStyle
)
;
}
void
nsCSSFrameConstructor
:
:
FlushAccumulatedBlock
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
nsContainerFrame
*
aParentFrame
nsFrameItems
&
aBlockItems
nsFrameItems
&
aNewItems
)
{
if
(
aBlockItems
.
IsEmpty
(
)
)
{
return
;
}
nsAtom
*
anonPseudo
=
nsCSSAnonBoxes
:
:
mozMathMLAnonymousBlock
;
ComputedStyle
*
parentContext
=
nsFrame
:
:
CorrectStyleParentFrame
(
aParentFrame
anonPseudo
)
-
>
Style
(
)
;
ServoStyleSet
*
styleSet
=
mPresShell
-
>
StyleSet
(
)
;
RefPtr
<
ComputedStyle
>
blockContext
;
blockContext
=
styleSet
-
>
ResolveInheritingAnonymousBoxStyle
(
anonPseudo
parentContext
)
;
nsContainerFrame
*
blockFrame
=
NS_NewMathMLmathBlockFrame
(
mPresShell
blockContext
)
;
InitAndRestoreFrame
(
aState
aContent
aParentFrame
blockFrame
)
;
ReparentFrames
(
this
blockFrame
aBlockItems
false
)
;
for
(
nsIFrame
*
f
:
aBlockItems
)
{
f
-
>
SetParentIsWrapperAnonBox
(
)
;
}
blockFrame
-
>
SetInitialChildList
(
kPrincipalList
aBlockItems
)
;
NS_ASSERTION
(
aBlockItems
.
IsEmpty
(
)
"
What
happened
?
"
)
;
aBlockItems
.
Clear
(
)
;
aNewItems
.
AddChild
(
blockFrame
)
;
}
#
define
SIMPLE_MATHML_CREATE
(
_tag
_func
)
\
{
&
nsGkAtoms
:
:
_tag
\
FCDATA_DECL
(
FCDATA_DISALLOW_OUT_OF_FLOW
|
\
FCDATA_FORCE_NULL_ABSPOS_CONTAINER
|
\
FCDATA_WRAP_KIDS_IN_BLOCKS
_func
)
}
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindMathMLData
(
Element
*
aElement
nsAtom
*
aTag
int32_t
aNameSpaceID
ComputedStyle
*
aComputedStyle
)
{
if
(
aNameSpaceID
!
=
kNameSpaceID_MathML
)
return
nullptr
;
if
(
aTag
=
=
nsGkAtoms
:
:
math
)
{
if
(
aComputedStyle
-
>
StyleDisplay
(
)
-
>
IsBlockOutsideStyle
(
)
)
{
static
const
FrameConstructionData
sBlockMathData
=
FCDATA_DECL
(
FCDATA_FORCE_NULL_ABSPOS_CONTAINER
|
FCDATA_WRAP_KIDS_IN_BLOCKS
NS_NewMathMLmathBlockFrame
)
;
return
&
sBlockMathData
;
}
static
const
FrameConstructionData
sInlineMathData
=
FCDATA_DECL
(
FCDATA_FORCE_NULL_ABSPOS_CONTAINER
|
FCDATA_IS_LINE_PARTICIPANT
|
FCDATA_WRAP_KIDS_IN_BLOCKS
NS_NewMathMLmathInlineFrame
)
;
return
&
sInlineMathData
;
}
static
const
FrameConstructionDataByTag
sMathMLData
[
]
=
{
SIMPLE_MATHML_CREATE
(
annotation_
NS_NewMathMLTokenFrame
)
SIMPLE_MATHML_CREATE
(
annotation_xml_
NS_NewMathMLmrowFrame
)
SIMPLE_MATHML_CREATE
(
mi_
NS_NewMathMLTokenFrame
)
SIMPLE_MATHML_CREATE
(
mn_
NS_NewMathMLTokenFrame
)
SIMPLE_MATHML_CREATE
(
ms_
NS_NewMathMLTokenFrame
)
SIMPLE_MATHML_CREATE
(
mtext_
NS_NewMathMLTokenFrame
)
SIMPLE_MATHML_CREATE
(
mo_
NS_NewMathMLmoFrame
)
SIMPLE_MATHML_CREATE
(
mfrac_
NS_NewMathMLmfracFrame
)
SIMPLE_MATHML_CREATE
(
msup_
NS_NewMathMLmmultiscriptsFrame
)
SIMPLE_MATHML_CREATE
(
msub_
NS_NewMathMLmmultiscriptsFrame
)
SIMPLE_MATHML_CREATE
(
msubsup_
NS_NewMathMLmmultiscriptsFrame
)
SIMPLE_MATHML_CREATE
(
munder_
NS_NewMathMLmunderoverFrame
)
SIMPLE_MATHML_CREATE
(
mover_
NS_NewMathMLmunderoverFrame
)
SIMPLE_MATHML_CREATE
(
munderover_
NS_NewMathMLmunderoverFrame
)
SIMPLE_MATHML_CREATE
(
mphantom_
NS_NewMathMLmrowFrame
)
SIMPLE_MATHML_CREATE
(
mpadded_
NS_NewMathMLmpaddedFrame
)
SIMPLE_MATHML_CREATE
(
mspace_
NS_NewMathMLmspaceFrame
)
SIMPLE_MATHML_CREATE
(
none
NS_NewMathMLmspaceFrame
)
SIMPLE_MATHML_CREATE
(
mprescripts_
NS_NewMathMLmspaceFrame
)
SIMPLE_MATHML_CREATE
(
mfenced_
NS_NewMathMLmfencedFrame
)
SIMPLE_MATHML_CREATE
(
mmultiscripts_
NS_NewMathMLmmultiscriptsFrame
)
SIMPLE_MATHML_CREATE
(
mstyle_
NS_NewMathMLmrowFrame
)
SIMPLE_MATHML_CREATE
(
msqrt_
NS_NewMathMLmsqrtFrame
)
SIMPLE_MATHML_CREATE
(
mroot_
NS_NewMathMLmrootFrame
)
SIMPLE_MATHML_CREATE
(
maction_
NS_NewMathMLmactionFrame
)
SIMPLE_MATHML_CREATE
(
mrow_
NS_NewMathMLmrowFrame
)
SIMPLE_MATHML_CREATE
(
merror_
NS_NewMathMLmrowFrame
)
SIMPLE_MATHML_CREATE
(
menclose_
NS_NewMathMLmencloseFrame
)
SIMPLE_MATHML_CREATE
(
semantics_
NS_NewMathMLsemanticsFrame
)
}
;
return
FindDataByTag
(
aTag
aElement
aComputedStyle
sMathMLData
ArrayLength
(
sMathMLData
)
)
;
}
nsContainerFrame
*
nsCSSFrameConstructor
:
:
ConstructFrameWithAnonymousChild
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
nsFrameItems
&
aFrameItems
ContainerFrameCreationFunc
aConstructor
ContainerFrameCreationFunc
aInnerConstructor
nsICSSAnonBoxPseudo
*
aInnerPseudo
bool
aCandidateRootFrame
)
{
nsIContent
*
const
content
=
aItem
.
mContent
;
ComputedStyle
*
const
computedStyle
=
aItem
.
mComputedStyle
;
nsContainerFrame
*
newFrame
=
aConstructor
(
mPresShell
computedStyle
)
;
InitAndRestoreFrame
(
aState
content
aCandidateRootFrame
?
aState
.
GetGeometricParent
(
computedStyle
-
>
StyleDisplay
(
)
aParentFrame
)
:
aParentFrame
newFrame
)
;
newFrame
-
>
AddStateBits
(
NS_FRAME_OWNS_ANON_BOXES
)
;
RefPtr
<
ComputedStyle
>
scForAnon
;
scForAnon
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveInheritingAnonymousBoxStyle
(
aInnerPseudo
computedStyle
)
;
nsContainerFrame
*
innerFrame
=
aInnerConstructor
(
mPresShell
scForAnon
)
;
InitAndRestoreFrame
(
aState
content
newFrame
innerFrame
)
;
SetInitialSingleChild
(
newFrame
innerFrame
)
;
aState
.
AddChild
(
newFrame
aFrameItems
content
aParentFrame
aCandidateRootFrame
aCandidateRootFrame
)
;
if
(
!
mRootElementFrame
&
&
aCandidateRootFrame
)
{
mRootElementFrame
=
newFrame
;
}
nsFrameItems
childItems
;
NS_ASSERTION
(
aItem
.
mAnonChildren
.
IsEmpty
(
)
"
nsIAnonymousContentCreator
:
:
CreateAnonymousContent
should
not
"
"
be
implemented
for
frames
for
which
we
explicitly
create
an
"
"
anonymous
child
to
wrap
its
child
frames
"
)
;
if
(
aItem
.
mFCData
-
>
mBits
&
FCDATA_USE_CHILD_ITEMS
)
{
ConstructFramesFromItemList
(
aState
aItem
.
mChildItems
innerFrame
aItem
.
mFCData
-
>
mBits
&
FCDATA_IS_WRAPPER_ANON_BOX
childItems
)
;
}
else
{
ProcessChildren
(
aState
content
computedStyle
innerFrame
true
childItems
false
aItem
.
mPendingBinding
)
;
}
innerFrame
-
>
SetInitialChildList
(
kPrincipalList
childItems
)
;
return
newFrame
;
}
nsIFrame
*
nsCSSFrameConstructor
:
:
ConstructOuterSVG
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aDisplay
nsFrameItems
&
aFrameItems
)
{
return
ConstructFrameWithAnonymousChild
(
aState
aItem
aParentFrame
aFrameItems
NS_NewSVGOuterSVGFrame
NS_NewSVGOuterSVGAnonChildFrame
nsCSSAnonBoxes
:
:
mozSVGOuterSVGAnonChild
true
)
;
}
nsIFrame
*
nsCSSFrameConstructor
:
:
ConstructMarker
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aDisplay
nsFrameItems
&
aFrameItems
)
{
return
ConstructFrameWithAnonymousChild
(
aState
aItem
aParentFrame
aFrameItems
NS_NewSVGMarkerFrame
NS_NewSVGMarkerAnonChildFrame
nsCSSAnonBoxes
:
:
mozSVGMarkerAnonChild
false
)
;
}
#
define
SIMPLE_SVG_FCDATA
(
_func
)
\
FCDATA_DECL
(
FCDATA_DISALLOW_OUT_OF_FLOW
|
\
FCDATA_SKIP_ABSPOS_PUSH
|
\
FCDATA_DISALLOW_GENERATED_CONTENT
_func
)
#
define
SIMPLE_SVG_CREATE
(
_tag
_func
)
\
{
&
nsGkAtoms
:
:
_tag
SIMPLE_SVG_FCDATA
(
_func
)
}
static
bool
IsFilterPrimitiveChildTag
(
const
nsAtom
*
aTag
)
{
return
aTag
=
=
nsGkAtoms
:
:
feDistantLight
|
|
aTag
=
=
nsGkAtoms
:
:
fePointLight
|
|
aTag
=
=
nsGkAtoms
:
:
feSpotLight
|
|
aTag
=
=
nsGkAtoms
:
:
feFuncR
|
|
aTag
=
=
nsGkAtoms
:
:
feFuncG
|
|
aTag
=
=
nsGkAtoms
:
:
feFuncB
|
|
aTag
=
=
nsGkAtoms
:
:
feFuncA
|
|
aTag
=
=
nsGkAtoms
:
:
feMergeNode
;
}
const
nsCSSFrameConstructor
:
:
FrameConstructionData
*
nsCSSFrameConstructor
:
:
FindSVGData
(
Element
*
aElement
nsAtom
*
aTag
int32_t
aNameSpaceID
nsIFrame
*
aParentFrame
bool
aIsWithinSVGText
bool
aAllowsTextPathChild
ComputedStyle
*
aComputedStyle
)
{
if
(
aNameSpaceID
!
=
kNameSpaceID_SVG
)
{
return
nullptr
;
}
static
const
FrameConstructionData
sSuppressData
=
SUPPRESS_FCDATA
(
)
;
static
const
FrameConstructionData
sContainerData
=
SIMPLE_SVG_FCDATA
(
NS_NewSVGContainerFrame
)
;
bool
parentIsSVG
=
aIsWithinSVGText
;
nsIContent
*
parentContent
=
aParentFrame
?
aParentFrame
-
>
GetContent
(
)
:
nullptr
;
if
(
parentContent
)
{
parentIsSVG
=
parentContent
-
>
IsSVGElement
(
)
&
&
parentContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
!
=
nsGkAtoms
:
:
foreignObject
;
}
if
(
(
aTag
!
=
nsGkAtoms
:
:
svg
&
&
!
parentIsSVG
)
|
|
(
aTag
=
=
nsGkAtoms
:
:
desc
|
|
aTag
=
=
nsGkAtoms
:
:
title
|
|
aTag
=
=
nsGkAtoms
:
:
metadata
)
)
{
return
&
sSuppressData
;
}
if
(
aElement
-
>
IsNodeOfType
(
nsINode
:
:
eANIMATION
)
)
{
return
&
sSuppressData
;
}
if
(
aTag
=
=
nsGkAtoms
:
:
svg
&
&
!
parentIsSVG
)
{
static
const
FrameConstructionData
sOuterSVGData
=
FULL_CTOR_FCDATA
(
0
&
nsCSSFrameConstructor
:
:
ConstructOuterSVG
)
;
return
&
sOuterSVGData
;
}
if
(
aTag
=
=
nsGkAtoms
:
:
marker
)
{
static
const
FrameConstructionData
sMarkerSVGData
=
FULL_CTOR_FCDATA
(
0
&
nsCSSFrameConstructor
:
:
ConstructMarker
)
;
return
&
sMarkerSVGData
;
}
nsCOMPtr
<
SVGTests
>
tests
(
do_QueryInterface
(
aElement
)
)
;
if
(
tests
&
&
!
tests
-
>
PassesConditionalProcessingTests
(
)
)
{
if
(
aIsWithinSVGText
)
{
return
&
sSuppressData
;
}
return
&
sContainerData
;
}
bool
parentIsGradient
=
aParentFrame
&
&
(
aParentFrame
-
>
IsSVGLinearGradientFrame
(
)
|
|
aParentFrame
-
>
IsSVGRadialGradientFrame
(
)
)
;
bool
stop
=
(
aTag
=
=
nsGkAtoms
:
:
stop
)
;
if
(
(
parentIsGradient
&
&
!
stop
)
|
|
(
!
parentIsGradient
&
&
stop
)
)
{
return
&
sSuppressData
;
}
bool
parentIsFilter
=
aParentFrame
&
&
aParentFrame
-
>
IsSVGFilterFrame
(
)
;
bool
filterPrimitive
=
aElement
-
>
IsNodeOfType
(
nsINode
:
:
eFILTER
)
;
if
(
(
parentIsFilter
&
&
!
filterPrimitive
)
|
|
(
!
parentIsFilter
&
&
filterPrimitive
)
)
{
return
&
sSuppressData
;
}
bool
parentIsFEContainerFrame
=
aParentFrame
&
&
aParentFrame
-
>
IsSVGFEContainerFrame
(
)
;
if
(
(
parentIsFEContainerFrame
&
&
!
IsFilterPrimitiveChildTag
(
aTag
)
)
|
|
(
!
parentIsFEContainerFrame
&
&
IsFilterPrimitiveChildTag
(
aTag
)
)
)
{
return
&
sSuppressData
;
}
if
(
aIsWithinSVGText
)
{
static
const
FrameConstructionData
sTSpanData
=
FCDATA_DECL
(
FCDATA_DISALLOW_OUT_OF_FLOW
|
FCDATA_SKIP_ABSPOS_PUSH
|
FCDATA_DISALLOW_GENERATED_CONTENT
|
FCDATA_IS_LINE_PARTICIPANT
|
FCDATA_IS_INLINE
|
FCDATA_USE_CHILD_ITEMS
NS_NewInlineFrame
)
;
if
(
aTag
=
=
nsGkAtoms
:
:
textPath
)
{
if
(
aAllowsTextPathChild
)
{
return
&
sTSpanData
;
}
}
else
if
(
aTag
=
=
nsGkAtoms
:
:
tspan
|
|
aTag
=
=
nsGkAtoms
:
:
a
)
{
return
&
sTSpanData
;
}
return
&
sSuppressData
;
}
else
if
(
aTag
=
=
nsGkAtoms
:
:
tspan
|
|
aTag
=
=
nsGkAtoms
:
:
textPath
)
{
return
&
sSuppressData
;
}
static
const
FrameConstructionDataByTag
sSVGData
[
]
=
{
SIMPLE_SVG_CREATE
(
svg
NS_NewSVGInnerSVGFrame
)
SIMPLE_SVG_CREATE
(
g
NS_NewSVGGFrame
)
SIMPLE_SVG_CREATE
(
svgSwitch
NS_NewSVGSwitchFrame
)
SIMPLE_SVG_CREATE
(
symbol
NS_NewSVGSymbolFrame
)
SIMPLE_SVG_CREATE
(
polygon
NS_NewSVGGeometryFrame
)
SIMPLE_SVG_CREATE
(
polyline
NS_NewSVGGeometryFrame
)
SIMPLE_SVG_CREATE
(
circle
NS_NewSVGGeometryFrame
)
SIMPLE_SVG_CREATE
(
ellipse
NS_NewSVGGeometryFrame
)
SIMPLE_SVG_CREATE
(
line
NS_NewSVGGeometryFrame
)
SIMPLE_SVG_CREATE
(
rect
NS_NewSVGGeometryFrame
)
SIMPLE_SVG_CREATE
(
path
NS_NewSVGGeometryFrame
)
SIMPLE_SVG_CREATE
(
defs
NS_NewSVGContainerFrame
)
SIMPLE_SVG_CREATE
(
generic_
NS_NewSVGGenericContainerFrame
)
{
&
nsGkAtoms
:
:
text
FCDATA_WITH_WRAPPING_BLOCK
(
FCDATA_DISALLOW_OUT_OF_FLOW
|
FCDATA_ALLOW_BLOCK_STYLES
NS_NewSVGTextFrame
nsCSSAnonBoxes
:
:
mozSVGText
)
}
{
&
nsGkAtoms
:
:
foreignObject
FCDATA_WITH_WRAPPING_BLOCK
(
FCDATA_DISALLOW_OUT_OF_FLOW
NS_NewSVGForeignObjectFrame
nsCSSAnonBoxes
:
:
mozSVGForeignContent
)
}
SIMPLE_SVG_CREATE
(
a
NS_NewSVGAFrame
)
SIMPLE_SVG_CREATE
(
linearGradient
NS_NewSVGLinearGradientFrame
)
SIMPLE_SVG_CREATE
(
radialGradient
NS_NewSVGRadialGradientFrame
)
SIMPLE_SVG_CREATE
(
stop
NS_NewSVGStopFrame
)
SIMPLE_SVG_CREATE
(
use
NS_NewSVGUseFrame
)
SIMPLE_SVG_CREATE
(
view
NS_NewSVGViewFrame
)
SIMPLE_SVG_CREATE
(
image
NS_NewSVGImageFrame
)
SIMPLE_SVG_CREATE
(
clipPath
NS_NewSVGClipPathFrame
)
SIMPLE_SVG_CREATE
(
filter
NS_NewSVGFilterFrame
)
SIMPLE_SVG_CREATE
(
pattern
NS_NewSVGPatternFrame
)
SIMPLE_SVG_CREATE
(
mask
NS_NewSVGMaskFrame
)
SIMPLE_SVG_CREATE
(
feDistantLight
NS_NewSVGFEUnstyledLeafFrame
)
SIMPLE_SVG_CREATE
(
fePointLight
NS_NewSVGFEUnstyledLeafFrame
)
SIMPLE_SVG_CREATE
(
feSpotLight
NS_NewSVGFEUnstyledLeafFrame
)
SIMPLE_SVG_CREATE
(
feBlend
NS_NewSVGFELeafFrame
)
SIMPLE_SVG_CREATE
(
feColorMatrix
NS_NewSVGFELeafFrame
)
SIMPLE_SVG_CREATE
(
feFuncR
NS_NewSVGFEUnstyledLeafFrame
)
SIMPLE_SVG_CREATE
(
feFuncG
NS_NewSVGFEUnstyledLeafFrame
)
SIMPLE_SVG_CREATE
(
feFuncB
NS_NewSVGFEUnstyledLeafFrame
)
SIMPLE_SVG_CREATE
(
feFuncA
NS_NewSVGFEUnstyledLeafFrame
)
SIMPLE_SVG_CREATE
(
feComposite
NS_NewSVGFELeafFrame
)
SIMPLE_SVG_CREATE
(
feComponentTransfer
NS_NewSVGFEContainerFrame
)
SIMPLE_SVG_CREATE
(
feConvolveMatrix
NS_NewSVGFELeafFrame
)
SIMPLE_SVG_CREATE
(
feDiffuseLighting
NS_NewSVGFEContainerFrame
)
SIMPLE_SVG_CREATE
(
feDisplacementMap
NS_NewSVGFELeafFrame
)
SIMPLE_SVG_CREATE
(
feDropShadow
NS_NewSVGFELeafFrame
)
SIMPLE_SVG_CREATE
(
feFlood
NS_NewSVGFELeafFrame
)
SIMPLE_SVG_CREATE
(
feGaussianBlur
NS_NewSVGFELeafFrame
)
SIMPLE_SVG_CREATE
(
feImage
NS_NewSVGFEImageFrame
)
SIMPLE_SVG_CREATE
(
feMerge
NS_NewSVGFEContainerFrame
)
SIMPLE_SVG_CREATE
(
feMergeNode
NS_NewSVGFEUnstyledLeafFrame
)
SIMPLE_SVG_CREATE
(
feMorphology
NS_NewSVGFELeafFrame
)
SIMPLE_SVG_CREATE
(
feOffset
NS_NewSVGFELeafFrame
)
SIMPLE_SVG_CREATE
(
feSpecularLighting
NS_NewSVGFEContainerFrame
)
SIMPLE_SVG_CREATE
(
feTile
NS_NewSVGFELeafFrame
)
SIMPLE_SVG_CREATE
(
feTurbulence
NS_NewSVGFELeafFrame
)
}
;
const
FrameConstructionData
*
data
=
FindDataByTag
(
aTag
aElement
aComputedStyle
sSVGData
ArrayLength
(
sSVGData
)
)
;
if
(
!
data
)
{
data
=
&
sContainerData
;
}
return
data
;
}
void
nsCSSFrameConstructor
:
:
AddPageBreakItem
(
nsIContent
*
aContent
FrameConstructionItemList
&
aItems
)
{
RefPtr
<
ComputedStyle
>
pseudoStyle
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveNonInheritingAnonymousBoxStyle
(
nsCSSAnonBoxes
:
:
pageBreak
)
;
MOZ_ASSERT
(
pseudoStyle
-
>
StyleDisplay
(
)
-
>
mDisplay
=
=
StyleDisplay
:
:
Block
"
Unexpected
display
"
)
;
static
const
FrameConstructionData
sPageBreakData
=
FCDATA_DECL
(
FCDATA_SKIP_FRAMESET
NS_NewPageBreakFrame
)
;
aItems
.
AppendItem
(
this
&
sPageBreakData
aContent
nullptr
pseudoStyle
.
forget
(
)
true
nullptr
)
;
}
bool
nsCSSFrameConstructor
:
:
ShouldCreateItemsForChild
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
nsContainerFrame
*
aParentFrame
)
{
aContent
-
>
UnsetFlags
(
NODE_DESCENDANTS_NEED_FRAMES
|
NODE_NEEDS_FRAME
)
;
if
(
aContent
-
>
GetPrimaryFrame
(
)
&
&
aContent
-
>
GetPrimaryFrame
(
)
-
>
GetContent
(
)
=
=
aContent
&
&
!
aState
.
mCreatingExtraFrames
)
{
MOZ_ASSERT
(
MaybeGetListBoxBodyFrame
(
aContent
)
"
asked
to
create
frame
construction
item
for
a
node
that
"
"
already
has
a
frame
"
)
;
NS_ERROR
(
"
asked
to
create
frame
construction
item
for
a
node
that
already
"
"
has
a
frame
"
)
;
return
false
;
}
if
(
!
NeedFrameFor
(
aState
aParentFrame
aContent
)
)
{
return
false
;
}
if
(
aContent
-
>
IsComment
(
)
|
|
aContent
-
>
IsProcessingInstruction
(
)
)
{
return
false
;
}
return
true
;
}
void
nsCSSFrameConstructor
:
:
DoAddFrameConstructionItems
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
ComputedStyle
*
aComputedStyle
bool
aSuppressWhiteSpaceOptimizations
nsContainerFrame
*
aParentFrame
nsTArray
<
nsIAnonymousContentCreator
:
:
ContentInfo
>
*
aAnonChildren
FrameConstructionItemList
&
aItems
)
{
uint32_t
flags
=
ITEM_ALLOW_XBL_BASE
|
ITEM_ALLOW_PAGE_BREAK
;
if
(
aParentFrame
)
{
if
(
nsSVGUtils
:
:
IsInSVGTextSubtree
(
aParentFrame
)
)
{
flags
|
=
ITEM_IS_WITHIN_SVG_TEXT
;
}
if
(
aParentFrame
-
>
IsBlockFrame
(
)
&
&
aParentFrame
-
>
GetParent
(
)
&
&
aParentFrame
-
>
GetParent
(
)
-
>
IsSVGTextFrame
(
)
)
{
flags
|
=
ITEM_ALLOWS_TEXT_PATH_CHILD
;
}
}
AddFrameConstructionItemsInternal
(
aState
aContent
aParentFrame
aSuppressWhiteSpaceOptimizations
aComputedStyle
flags
aAnonChildren
aItems
)
;
}
void
nsCSSFrameConstructor
:
:
AddFrameConstructionItems
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
bool
aSuppressWhiteSpaceOptimizations
const
InsertionPoint
&
aInsertion
FrameConstructionItemList
&
aItems
)
{
nsContainerFrame
*
parentFrame
=
aInsertion
.
mParentFrame
;
if
(
!
ShouldCreateItemsForChild
(
aState
aContent
parentFrame
)
)
{
return
;
}
RefPtr
<
ComputedStyle
>
computedStyle
=
ResolveComputedStyle
(
aContent
)
;
DoAddFrameConstructionItems
(
aState
aContent
computedStyle
aSuppressWhiteSpaceOptimizations
parentFrame
nullptr
aItems
)
;
}
static
bool
ShouldSuppressFrameInSelect
(
const
nsIContent
*
aParent
const
nsIContent
*
aChild
)
{
if
(
!
aParent
|
|
!
aParent
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
select
nsGkAtoms
:
:
optgroup
)
)
{
return
false
;
}
if
(
aChild
-
>
GetParent
(
)
!
=
aParent
)
{
return
true
;
}
if
(
aChild
-
>
IsHTMLElement
(
nsGkAtoms
:
:
option
)
)
{
return
false
;
}
if
(
aChild
-
>
IsHTMLElement
(
nsGkAtoms
:
:
optgroup
)
&
&
aParent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
select
)
)
{
return
false
;
}
if
(
aChild
-
>
IsRootOfAnonymousSubtree
(
)
)
{
return
false
;
}
return
true
;
}
static
bool
ShouldSuppressFrameInNonOpenDetails
(
const
HTMLDetailsElement
*
aDetails
const
nsIContent
*
aChild
)
{
if
(
!
aDetails
|
|
aDetails
-
>
Open
(
)
)
{
return
false
;
}
if
(
aChild
-
>
GetParent
(
)
!
=
aDetails
)
{
return
true
;
}
auto
*
summary
=
HTMLSummaryElement
:
:
FromNode
(
aChild
)
;
if
(
summary
&
&
summary
-
>
IsMainSummary
(
)
)
{
return
false
;
}
if
(
aChild
-
>
IsRootOfAnonymousSubtree
(
)
&
&
!
aChild
-
>
IsGeneratedContentContainerForBefore
(
)
&
&
!
aChild
-
>
IsGeneratedContentContainerForAfter
(
)
)
{
return
false
;
}
return
true
;
}
void
nsCSSFrameConstructor
:
:
AddFrameConstructionItemsInternal
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
nsContainerFrame
*
aParentFrame
bool
aSuppressWhiteSpaceOptimizations
ComputedStyle
*
aComputedStyle
uint32_t
aFlags
nsTArray
<
nsIAnonymousContentCreator
:
:
ContentInfo
>
*
aAnonChildren
FrameConstructionItemList
&
aItems
)
{
MOZ_ASSERT
(
aContent
-
>
IsText
(
)
|
|
aContent
-
>
IsElement
(
)
"
Shouldn
'
t
get
anything
else
here
!
"
)
;
MOZ_ASSERT
(
aContent
-
>
IsInComposedDoc
(
)
)
;
MOZ_ASSERT
(
!
aContent
-
>
GetPrimaryFrame
(
)
|
|
aState
.
mCreatingExtraFrames
|
|
aContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
nsGkAtoms
:
:
area
)
;
const
nsStyleDisplay
*
display
=
aComputedStyle
-
>
StyleDisplay
(
)
;
RefPtr
<
ComputedStyle
>
computedStyle
(
aComputedStyle
)
;
PendingBinding
*
pendingBinding
=
nullptr
;
nsAtom
*
tag
=
aContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
;
int32_t
namespaceId
=
aContent
-
>
GetNameSpaceID
(
)
;
if
(
aFlags
&
ITEM_ALLOW_XBL_BASE
)
{
if
(
display
-
>
mBinding
)
{
nsXBLService
*
xblService
=
nsXBLService
:
:
GetInstance
(
)
;
if
(
!
xblService
)
return
;
bool
resolveStyle
;
nsAutoPtr
<
PendingBinding
>
newPendingBinding
(
new
PendingBinding
(
)
)
;
nsresult
rv
=
xblService
-
>
LoadBindings
(
aContent
-
>
AsElement
(
)
display
-
>
mBinding
-
>
GetURI
(
)
display
-
>
mBinding
-
>
mExtraData
-
>
GetPrincipal
(
)
getter_AddRefs
(
newPendingBinding
-
>
mBinding
)
&
resolveStyle
)
;
if
(
NS_FAILED
(
rv
)
&
&
rv
!
=
NS_ERROR_XBL_BLOCKED
)
return
;
if
(
newPendingBinding
-
>
mBinding
)
{
pendingBinding
=
newPendingBinding
;
aState
.
AddPendingBinding
(
newPendingBinding
.
forget
(
)
)
;
}
if
(
resolveStyle
)
{
computedStyle
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveServoStyle
(
aContent
-
>
AsElement
(
)
)
;
}
display
=
computedStyle
-
>
StyleDisplay
(
)
;
aComputedStyle
=
computedStyle
;
if
(
namespaceId
=
=
kNameSpaceID_XUL
)
{
int32_t
overridenNamespace
;
nsAtom
*
overridenTag
=
mDocument
-
>
BindingManager
(
)
-
>
ResolveTag
(
aContent
&
overridenNamespace
)
;
if
(
overridenNamespace
=
=
kNameSpaceID_XUL
)
{
tag
=
overridenTag
;
}
}
}
}
const
bool
isGeneratedContent
=
!
!
(
aFlags
&
ITEM_IS_GENERATED_CONTENT
)
;
MOZ_ASSERT
(
!
isGeneratedContent
|
|
computedStyle
-
>
GetPseudo
(
)
"
Generated
content
should
be
a
pseudo
-
element
"
)
;
FrameConstructionItem
*
item
=
nullptr
;
auto
cleanupGeneratedContent
=
mozilla
:
:
MakeScopeExit
(
[
&
]
(
)
{
if
(
isGeneratedContent
&
&
!
item
)
{
MOZ_ASSERT
(
!
IsDisplayContents
(
aContent
)
"
This
would
need
to
change
if
we
support
display
:
contents
"
"
in
generated
content
"
)
;
aContent
-
>
UnbindFromTree
(
)
;
}
}
)
;
if
(
display
-
>
mDisplay
=
=
StyleDisplay
:
:
None
)
{
return
;
}
if
(
display
-
>
mDisplay
=
=
StyleDisplay
:
:
Contents
)
{
if
(
aParentFrame
)
{
aParentFrame
-
>
AddStateBits
(
NS_FRAME_MAY_HAVE_GENERATED_CONTENT
)
;
}
CreateGeneratedContentItem
(
aState
aParentFrame
aContent
-
>
AsElement
(
)
computedStyle
CSSPseudoElementType
:
:
before
aItems
)
;
FlattenedChildIterator
iter
(
aContent
)
;
for
(
nsIContent
*
child
=
iter
.
GetNextChild
(
)
;
child
;
child
=
iter
.
GetNextChild
(
)
)
{
if
(
!
ShouldCreateItemsForChild
(
aState
child
aParentFrame
)
)
{
continue
;
}
RefPtr
<
ComputedStyle
>
childContext
=
ResolveComputedStyle
(
child
)
;
DoAddFrameConstructionItems
(
aState
child
childContext
aSuppressWhiteSpaceOptimizations
aParentFrame
aAnonChildren
aItems
)
;
}
aItems
.
SetParentHasNoXBLChildren
(
!
iter
.
XBLInvolved
(
)
)
;
CreateGeneratedContentItem
(
aState
aParentFrame
aContent
-
>
AsElement
(
)
computedStyle
CSSPseudoElementType
:
:
after
aItems
)
;
return
;
}
nsIContent
*
parent
=
aParentFrame
?
aParentFrame
-
>
GetContent
(
)
:
nullptr
;
if
(
ShouldSuppressFrameInSelect
(
parent
aContent
)
)
{
return
;
}
auto
*
details
=
HTMLDetailsElement
:
:
FromNodeOrNull
(
parent
)
;
if
(
ShouldSuppressFrameInNonOpenDetails
(
details
aContent
)
)
{
return
;
}
bool
isPopup
=
false
;
const
bool
isText
=
!
aContent
-
>
IsElement
(
)
;
const
FrameConstructionData
*
data
;
if
(
isText
)
{
data
=
FindTextData
(
aParentFrame
aContent
)
;
if
(
!
data
)
{
return
;
}
}
else
{
Element
*
element
=
aContent
-
>
AsElement
(
)
;
if
(
namespaceId
!
=
kNameSpaceID_SVG
&
&
(
(
aParentFrame
&
&
IsFrameForSVG
(
aParentFrame
)
&
&
!
aParentFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVGForeignObject
)
)
|
|
(
aFlags
&
ITEM_IS_WITHIN_SVG_TEXT
)
)
)
{
return
;
}
data
=
FindHTMLData
(
element
tag
namespaceId
aParentFrame
computedStyle
)
;
if
(
!
data
)
{
data
=
FindXULTagData
(
element
tag
namespaceId
computedStyle
)
;
}
if
(
!
data
)
{
data
=
FindMathMLData
(
element
tag
namespaceId
computedStyle
)
;
}
if
(
!
data
)
{
data
=
FindSVGData
(
element
tag
namespaceId
aParentFrame
aFlags
&
ITEM_IS_WITHIN_SVG_TEXT
aFlags
&
ITEM_ALLOWS_TEXT_PATH_CHILD
computedStyle
)
;
}
if
(
!
data
)
{
data
=
FindXULDisplayData
(
display
element
computedStyle
)
;
}
if
(
!
data
)
{
data
=
FindDisplayData
(
display
element
computedStyle
)
;
}
MOZ_ASSERT
(
data
"
Should
have
frame
construction
data
now
"
)
;
if
(
data
-
>
mBits
&
FCDATA_SUPPRESS_FRAME
)
{
return
;
}
#
ifdef
MOZ_XUL
if
(
(
data
-
>
mBits
&
FCDATA_IS_POPUP
)
&
&
(
!
aParentFrame
|
|
!
aParentFrame
-
>
IsMenuFrame
(
)
)
)
{
if
(
!
aState
.
mPopupItems
.
containingBlock
&
&
!
aState
.
mHavePendingPopupgroup
)
{
return
;
}
isPopup
=
true
;
}
#
endif
}
uint32_t
bits
=
data
-
>
mBits
;
if
(
aParentFrame
&
&
aParentFrame
-
>
IsTableColGroupFrame
(
)
&
&
(
!
(
bits
&
FCDATA_IS_TABLE_PART
)
|
|
display
-
>
mDisplay
!
=
StyleDisplay
:
:
TableColumn
)
)
{
return
;
}
bool
canHavePageBreak
=
(
aFlags
&
ITEM_ALLOW_PAGE_BREAK
)
&
&
aState
.
mPresContext
-
>
IsPaginated
(
)
&
&
!
display
-
>
IsAbsolutelyPositionedStyle
(
)
&
&
!
(
aParentFrame
&
&
aParentFrame
-
>
IsGridContainerFrame
(
)
)
&
&
!
(
bits
&
FCDATA_IS_TABLE_PART
)
&
&
!
(
bits
&
FCDATA_IS_SVG_TEXT
)
;
if
(
canHavePageBreak
&
&
display
-
>
mBreakBefore
)
{
AddPageBreakItem
(
aContent
aItems
)
;
}
if
(
details
&
&
details
-
>
Open
(
)
)
{
auto
*
summary
=
HTMLSummaryElement
:
:
FromNode
(
aContent
)
;
if
(
summary
&
&
summary
-
>
IsMainSummary
(
)
)
{
item
=
aItems
.
PrependItem
(
this
data
aContent
pendingBinding
computedStyle
.
forget
(
)
aSuppressWhiteSpaceOptimizations
aAnonChildren
)
;
}
}
if
(
!
item
)
{
item
=
aItems
.
AppendItem
(
this
data
aContent
pendingBinding
computedStyle
.
forget
(
)
aSuppressWhiteSpaceOptimizations
aAnonChildren
)
;
}
item
-
>
mIsText
=
isText
;
item
-
>
mIsGeneratedContent
=
isGeneratedContent
;
item
-
>
mIsAnonymousContentCreatorContent
=
aFlags
&
ITEM_IS_ANONYMOUSCONTENTCREATOR_CONTENT
;
if
(
isGeneratedContent
)
{
item
-
>
mContent
-
>
AddRef
(
)
;
}
item
-
>
mIsRootPopupgroup
=
namespaceId
=
=
kNameSpaceID_XUL
&
&
tag
=
=
nsGkAtoms
:
:
popupgroup
&
&
aContent
-
>
IsRootOfNativeAnonymousSubtree
(
)
;
if
(
item
-
>
mIsRootPopupgroup
)
{
aState
.
mHavePendingPopupgroup
=
true
;
}
item
-
>
mIsPopup
=
isPopup
;
item
-
>
mIsForSVGAElement
=
namespaceId
=
=
kNameSpaceID_SVG
&
&
tag
=
=
nsGkAtoms
:
:
a
;
if
(
canHavePageBreak
&
&
display
-
>
mBreakAfter
)
{
AddPageBreakItem
(
aContent
aItems
)
;
}
if
(
bits
&
FCDATA_IS_INLINE
)
{
BuildInlineChildItems
(
aState
*
item
aFlags
&
ITEM_IS_WITHIN_SVG_TEXT
aFlags
&
ITEM_ALLOWS_TEXT_PATH_CHILD
)
;
item
-
>
mHasInlineEnds
=
true
;
item
-
>
mIsBlock
=
false
;
}
else
{
bool
isInline
=
(
(
bits
&
FCDATA_IS_TABLE_PART
)
&
&
(
!
aParentFrame
|
|
aParentFrame
-
>
StyleDisplay
(
)
-
>
mDisplay
=
=
StyleDisplay
:
:
Inline
)
)
|
|
display
-
>
IsInlineOutsideStyle
(
)
|
|
isPopup
;
item
-
>
mIsAllInline
=
item
-
>
mHasInlineEnds
=
isInline
|
|
(
!
(
bits
&
FCDATA_DISALLOW_OUT_OF_FLOW
)
&
&
aState
.
GetGeometricParent
(
display
nullptr
)
)
;
item
-
>
mIsBlock
=
!
isInline
&
&
!
display
-
>
IsAbsolutelyPositionedStyle
(
)
&
&
!
display
-
>
IsFloatingStyle
(
)
&
&
!
(
bits
&
FCDATA_IS_SVG_TEXT
)
;
}
if
(
item
-
>
mIsAllInline
)
{
aItems
.
InlineItemAdded
(
)
;
}
else
if
(
item
-
>
mIsBlock
)
{
aItems
.
BlockItemAdded
(
)
;
}
if
(
(
bits
&
FCDATA_IS_LINE_PARTICIPANT
)
&
&
(
(
bits
&
FCDATA_DISALLOW_OUT_OF_FLOW
)
|
|
!
aState
.
GetGeometricParent
(
display
nullptr
)
)
)
{
item
-
>
mIsLineParticipant
=
true
;
aItems
.
LineParticipantItemAdded
(
)
;
}
}
bool
nsCSSFrameConstructor
:
:
AtLineBoundary
(
FCItemIterator
&
aIter
)
{
if
(
aIter
.
item
(
)
.
mSuppressWhiteSpaceOptimizations
)
{
return
false
;
}
if
(
aIter
.
AtStart
(
)
)
{
if
(
aIter
.
List
(
)
-
>
HasLineBoundaryAtStart
(
)
&
&
!
aIter
.
item
(
)
.
mContent
-
>
GetPreviousSibling
(
)
)
return
true
;
}
else
{
FCItemIterator
prev
=
aIter
;
prev
.
Prev
(
)
;
if
(
prev
.
item
(
)
.
IsLineBoundary
(
)
&
&
!
prev
.
item
(
)
.
mSuppressWhiteSpaceOptimizations
&
&
aIter
.
item
(
)
.
mContent
-
>
GetPreviousSibling
(
)
=
=
prev
.
item
(
)
.
mContent
)
return
true
;
}
FCItemIterator
next
=
aIter
;
next
.
Next
(
)
;
if
(
next
.
IsDone
(
)
)
{
if
(
aIter
.
List
(
)
-
>
HasLineBoundaryAtEnd
(
)
&
&
!
aIter
.
item
(
)
.
mContent
-
>
GetNextSibling
(
)
)
return
true
;
}
else
{
if
(
next
.
item
(
)
.
IsLineBoundary
(
)
&
&
!
next
.
item
(
)
.
mSuppressWhiteSpaceOptimizations
&
&
aIter
.
item
(
)
.
mContent
-
>
GetNextSibling
(
)
=
=
next
.
item
(
)
.
mContent
)
return
true
;
}
return
false
;
}
void
nsCSSFrameConstructor
:
:
ConstructFramesFromItem
(
nsFrameConstructorState
&
aState
FCItemIterator
&
aIter
nsContainerFrame
*
aParentFrame
nsFrameItems
&
aFrameItems
)
{
nsContainerFrame
*
adjParentFrame
=
aParentFrame
;
FrameConstructionItem
&
item
=
aIter
.
item
(
)
;
ComputedStyle
*
computedStyle
=
item
.
mComputedStyle
;
AdjustParentFrame
(
&
adjParentFrame
item
.
mFCData
computedStyle
)
;
if
(
item
.
mIsText
)
{
if
(
AtLineBoundary
(
aIter
)
&
&
!
computedStyle
-
>
StyleText
(
)
-
>
WhiteSpaceOrNewlineIsSignificant
(
)
&
&
aIter
.
List
(
)
-
>
ParentHasNoXBLChildren
(
)
&
&
!
(
aState
.
mAdditionalStateBits
&
NS_FRAME_GENERATED_CONTENT
)
&
&
(
item
.
mFCData
-
>
mBits
&
FCDATA_IS_LINE_PARTICIPANT
)
&
&
!
(
item
.
mFCData
-
>
mBits
&
FCDATA_IS_SVG_TEXT
)
&
&
!
mAlwaysCreateFramesForIgnorableWhitespace
&
&
item
.
IsWhitespace
(
aState
)
)
return
;
ConstructTextFrame
(
item
.
mFCData
aState
item
.
mContent
adjParentFrame
computedStyle
aFrameItems
)
;
return
;
}
computedStyle
-
>
StartBackgroundImageLoads
(
)
;
nsFrameState
savedStateBits
=
aState
.
mAdditionalStateBits
;
if
(
item
.
mIsGeneratedContent
)
{
aState
.
mAdditionalStateBits
|
=
NS_FRAME_GENERATED_CONTENT
;
}
ConstructFrameFromItemInternal
(
item
aState
adjParentFrame
aFrameItems
)
;
if
(
item
.
mIsGeneratedContent
)
{
item
.
mContent
-
>
Release
(
)
;
item
.
mIsGeneratedContent
=
false
;
}
aState
.
mAdditionalStateBits
=
savedStateBits
;
}
inline
bool
IsRootBoxFrame
(
nsIFrame
*
aFrame
)
{
return
(
aFrame
-
>
IsRootFrame
(
)
)
;
}
void
nsCSSFrameConstructor
:
:
ReconstructDocElementHierarchy
(
InsertionKind
aInsertionKind
)
{
Element
*
rootElement
=
mDocument
-
>
GetRootElement
(
)
;
if
(
!
rootElement
)
{
return
;
}
RecreateFramesForContent
(
rootElement
aInsertionKind
)
;
}
nsContainerFrame
*
nsCSSFrameConstructor
:
:
GetAbsoluteContainingBlock
(
nsIFrame
*
aFrame
ContainingBlockType
aType
)
{
for
(
nsIFrame
*
frame
=
aFrame
;
frame
;
frame
=
frame
-
>
GetParent
(
)
)
{
if
(
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eMathML
)
)
{
return
nullptr
;
}
if
(
aType
=
=
FIXED_POS
)
{
LayoutFrameType
t
=
frame
-
>
Type
(
)
;
if
(
t
=
=
LayoutFrameType
:
:
Viewport
|
|
t
=
=
LayoutFrameType
:
:
PageContent
)
{
return
static_cast
<
nsContainerFrame
*
>
(
frame
)
;
}
}
if
(
!
frame
-
>
IsAbsPosContainingBlock
(
)
|
|
(
aType
=
=
FIXED_POS
&
&
!
frame
-
>
IsFixedPosContainingBlock
(
)
)
)
{
continue
;
}
nsIFrame
*
absPosCBCandidate
=
frame
;
LayoutFrameType
type
=
absPosCBCandidate
-
>
Type
(
)
;
if
(
type
=
=
LayoutFrameType
:
:
FieldSet
)
{
absPosCBCandidate
=
static_cast
<
nsFieldSetFrame
*
>
(
absPosCBCandidate
)
-
>
GetInner
(
)
;
if
(
!
absPosCBCandidate
)
{
continue
;
}
type
=
absPosCBCandidate
-
>
Type
(
)
;
}
if
(
type
=
=
LayoutFrameType
:
:
Scroll
)
{
nsIScrollableFrame
*
scrollFrame
=
do_QueryFrame
(
absPosCBCandidate
)
;
absPosCBCandidate
=
scrollFrame
-
>
GetScrolledFrame
(
)
;
if
(
!
absPosCBCandidate
)
{
continue
;
}
type
=
absPosCBCandidate
-
>
Type
(
)
;
}
absPosCBCandidate
=
absPosCBCandidate
-
>
FirstContinuation
(
)
;
if
(
!
absPosCBCandidate
-
>
IsAbsoluteContainer
(
)
)
{
continue
;
}
if
(
type
=
=
LayoutFrameType
:
:
Table
)
{
continue
;
}
MOZ_ASSERT
(
(
nsContainerFrame
*
)
do_QueryFrame
(
absPosCBCandidate
)
"
abs
.
pos
.
containing
block
must
be
nsContainerFrame
sub
-
class
"
)
;
return
static_cast
<
nsContainerFrame
*
>
(
absPosCBCandidate
)
;
}
MOZ_ASSERT
(
aType
!
=
FIXED_POS
"
no
ICB
in
this
frame
tree
?
"
)
;
return
mHasRootAbsPosContainingBlock
?
mDocElementContainingBlock
:
nullptr
;
}
nsContainerFrame
*
nsCSSFrameConstructor
:
:
GetFloatContainingBlock
(
nsIFrame
*
aFrame
)
{
for
(
nsIFrame
*
containingBlock
=
aFrame
;
containingBlock
&
&
!
ShouldSuppressFloatingOfDescendants
(
containingBlock
)
;
containingBlock
=
containingBlock
-
>
GetParent
(
)
)
{
if
(
containingBlock
-
>
IsFloatContainingBlock
(
)
)
{
MOZ_ASSERT
(
(
nsContainerFrame
*
)
do_QueryFrame
(
containingBlock
)
"
float
containing
block
must
be
nsContainerFrame
sub
-
class
"
)
;
return
static_cast
<
nsContainerFrame
*
>
(
containingBlock
)
;
}
}
return
nullptr
;
}
static
nsIFrame
*
FindAppendPrevSibling
(
nsIFrame
*
aParentFrame
nsIFrame
*
aNextSibling
)
{
aParentFrame
-
>
DrainSelfOverflowList
(
)
;
if
(
aNextSibling
)
{
MOZ_ASSERT
(
aNextSibling
-
>
GetParent
(
)
=
=
aParentFrame
"
Wrong
parent
"
)
;
return
aNextSibling
-
>
GetPrevSibling
(
)
;
}
return
aParentFrame
-
>
GetChildList
(
kPrincipalList
)
.
LastChild
(
)
;
}
static
nsContainerFrame
*
ContinuationToAppendTo
(
nsContainerFrame
*
aParentFrame
)
{
MOZ_ASSERT
(
aParentFrame
)
;
if
(
IsFramePartOfIBSplit
(
aParentFrame
)
)
{
return
static_cast
<
nsContainerFrame
*
>
(
GetLastIBSplitSibling
(
aParentFrame
)
-
>
LastContinuation
(
)
)
;
}
return
nsLayoutUtils
:
:
LastContinuationWithChild
(
aParentFrame
)
;
}
static
nsIFrame
*
GetInsertNextSibling
(
nsIFrame
*
aParentFrame
nsIFrame
*
aPrevSibling
)
{
if
(
aPrevSibling
)
{
return
aPrevSibling
-
>
GetNextSibling
(
)
;
}
return
aParentFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
}
void
nsCSSFrameConstructor
:
:
AppendFramesToParent
(
nsFrameConstructorState
&
aState
nsContainerFrame
*
aParentFrame
nsFrameItems
&
aFrameList
nsIFrame
*
aPrevSibling
bool
aIsRecursiveCall
)
{
MOZ_ASSERT
(
!
IsFramePartOfIBSplit
(
aParentFrame
)
|
|
!
GetIBSplitSibling
(
aParentFrame
)
|
|
!
GetIBSplitSibling
(
aParentFrame
)
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
"
aParentFrame
has
a
ib
-
split
sibling
with
kids
?
"
)
;
MOZ_ASSERT
(
!
aPrevSibling
|
|
aPrevSibling
-
>
GetParent
(
)
=
=
aParentFrame
"
Parent
and
prevsibling
don
'
t
match
"
)
;
nsIFrame
*
nextSibling
=
:
:
GetInsertNextSibling
(
aParentFrame
aPrevSibling
)
;
NS_ASSERTION
(
nextSibling
|
|
!
aParentFrame
-
>
GetNextContinuation
(
)
|
|
!
aParentFrame
-
>
GetNextContinuation
(
)
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
|
|
aIsRecursiveCall
"
aParentFrame
has
later
continuations
with
kids
?
"
)
;
NS_ASSERTION
(
nextSibling
|
|
!
IsFramePartOfIBSplit
(
aParentFrame
)
|
|
(
IsInlineFrame
(
aParentFrame
)
&
&
!
GetIBSplitSibling
(
aParentFrame
)
&
&
!
aParentFrame
-
>
GetNextContinuation
(
)
)
|
|
aIsRecursiveCall
"
aParentFrame
is
not
last
?
"
)
;
if
(
!
nextSibling
&
&
IsFramePartOfIBSplit
(
aParentFrame
)
)
{
if
(
aFrameList
.
NotEmpty
(
)
&
&
!
aFrameList
.
FirstChild
(
)
-
>
IsInlineOutside
(
)
)
{
nsIFrame
*
firstContinuation
=
aParentFrame
-
>
FirstContinuation
(
)
;
if
(
firstContinuation
-
>
PrincipalChildList
(
)
.
IsEmpty
(
)
)
{
nsFrameList
:
:
FrameLinkEnumerator
firstNonBlockEnumerator
=
FindFirstNonBlock
(
aFrameList
)
;
nsFrameList
blockKids
=
aFrameList
.
ExtractHead
(
firstNonBlockEnumerator
)
;
NS_ASSERTION
(
blockKids
.
NotEmpty
(
)
"
No
blocks
?
"
)
;
nsContainerFrame
*
prevBlock
=
GetIBSplitPrevSibling
(
firstContinuation
)
;
prevBlock
=
static_cast
<
nsContainerFrame
*
>
(
prevBlock
-
>
LastContinuation
(
)
)
;
NS_ASSERTION
(
prevBlock
"
Should
have
previous
block
here
"
)
;
MoveChildrenTo
(
aParentFrame
prevBlock
blockKids
)
;
}
}
nsFrameList
:
:
FrameLinkEnumerator
firstBlockEnumerator
(
aFrameList
)
;
FindFirstBlock
(
firstBlockEnumerator
)
;
nsFrameList
inlineKids
=
aFrameList
.
ExtractHead
(
firstBlockEnumerator
)
;
if
(
!
inlineKids
.
IsEmpty
(
)
)
{
AppendFrames
(
aParentFrame
kPrincipalList
inlineKids
)
;
}
if
(
!
aFrameList
.
IsEmpty
(
)
)
{
bool
positioned
=
aParentFrame
-
>
IsRelativelyPositioned
(
)
;
nsFrameItems
ibSiblings
;
CreateIBSiblings
(
aState
aParentFrame
positioned
aFrameList
ibSiblings
)
;
mPresShell
-
>
FrameNeedsReflow
(
aParentFrame
nsIPresShell
:
:
eTreeChange
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
return
AppendFramesToParent
(
aState
aParentFrame
-
>
GetParent
(
)
ibSiblings
aParentFrame
true
)
;
}
return
;
}
InsertFrames
(
aParentFrame
kPrincipalList
aPrevSibling
aFrameList
)
;
}
#
define
UNSET_DISPLAY
static_cast
<
StyleDisplay
>
(
255
)
bool
nsCSSFrameConstructor
:
:
IsValidSibling
(
nsIFrame
*
aSibling
nsIContent
*
aContent
StyleDisplay
&
aDisplay
)
{
nsIFrame
*
parentFrame
=
aSibling
-
>
GetParent
(
)
;
LayoutFrameType
parentType
=
parentFrame
-
>
Type
(
)
;
StyleDisplay
siblingDisplay
=
aSibling
-
>
GetDisplay
(
)
;
if
(
StyleDisplay
:
:
TableColumnGroup
=
=
siblingDisplay
|
|
StyleDisplay
:
:
TableColumn
=
=
siblingDisplay
|
|
StyleDisplay
:
:
TableCaption
=
=
siblingDisplay
|
|
StyleDisplay
:
:
TableHeaderGroup
=
=
siblingDisplay
|
|
StyleDisplay
:
:
TableRowGroup
=
=
siblingDisplay
|
|
StyleDisplay
:
:
TableFooterGroup
=
=
siblingDisplay
|
|
LayoutFrameType
:
:
Menu
=
=
parentType
)
{
if
(
UNSET_DISPLAY
=
=
aDisplay
)
{
if
(
aContent
-
>
IsComment
(
)
|
|
aContent
-
>
IsProcessingInstruction
(
)
)
{
return
false
;
}
RefPtr
<
ComputedStyle
>
computedStyle
=
ResolveComputedStyle
(
aContent
)
;
const
nsStyleDisplay
*
display
=
computedStyle
-
>
StyleDisplay
(
)
;
aDisplay
=
display
-
>
mDisplay
;
}
if
(
LayoutFrameType
:
:
Menu
=
=
parentType
)
{
return
(
StyleDisplay
:
:
MozPopup
=
=
aDisplay
)
=
=
(
StyleDisplay
:
:
MozPopup
=
=
siblingDisplay
)
;
}
if
(
(
siblingDisplay
=
=
StyleDisplay
:
:
TableCaption
)
!
=
(
aDisplay
=
=
StyleDisplay
:
:
TableCaption
)
)
{
return
false
;
}
if
(
(
siblingDisplay
=
=
StyleDisplay
:
:
TableColumnGroup
|
|
siblingDisplay
=
=
StyleDisplay
:
:
TableColumn
)
!
=
(
aDisplay
=
=
StyleDisplay
:
:
TableColumnGroup
|
|
aDisplay
=
=
StyleDisplay
:
:
TableColumn
)
)
{
return
false
;
}
}
if
(
IsFrameForFieldSet
(
parentFrame
)
)
{
if
(
nsContainerFrame
*
cif
=
aSibling
-
>
GetContentInsertionFrame
(
)
)
{
aSibling
=
cif
;
}
LayoutFrameType
sibType
=
aSibling
-
>
Type
(
)
;
bool
legendContent
=
aContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
legend
)
;
if
(
(
legendContent
&
&
(
LayoutFrameType
:
:
Legend
!
=
sibType
)
)
|
|
(
!
legendContent
&
&
(
LayoutFrameType
:
:
Legend
=
=
sibType
)
)
)
return
false
;
}
return
true
;
}
template
<
nsCSSFrameConstructor
:
:
SiblingDirection
aDirection
>
nsIFrame
*
nsCSSFrameConstructor
:
:
FindSiblingInternal
(
FlattenedChildIterator
&
aIter
nsIContent
*
aTargetContent
StyleDisplay
&
aTargetContentDisplay
)
{
auto
adjust
=
[
&
]
(
nsIFrame
*
aPotentialSiblingFrame
)
-
>
nsIFrame
*
{
return
AdjustSiblingFrame
(
aPotentialSiblingFrame
aTargetContent
aTargetContentDisplay
aDirection
)
;
}
;
auto
nextDomSibling
=
[
]
(
FlattenedChildIterator
&
aIter
)
-
>
nsIContent
*
{
return
aDirection
=
=
SiblingDirection
:
:
Forward
?
aIter
.
GetNextChild
(
)
:
aIter
.
GetPreviousChild
(
)
;
}
;
auto
getNearPseudo
=
[
]
(
const
nsIContent
*
aContent
)
-
>
nsIFrame
*
{
return
aDirection
=
=
SiblingDirection
:
:
Forward
?
nsLayoutUtils
:
:
GetBeforeFrame
(
aContent
)
:
nsLayoutUtils
:
:
GetAfterFrame
(
aContent
)
;
}
;
auto
getFarPseudo
=
[
]
(
const
nsIContent
*
aContent
)
-
>
nsIFrame
*
{
return
aDirection
=
=
SiblingDirection
:
:
Forward
?
nsLayoutUtils
:
:
GetAfterFrame
(
aContent
)
:
nsLayoutUtils
:
:
GetBeforeFrame
(
aContent
)
;
}
;
while
(
nsIContent
*
sibling
=
nextDomSibling
(
aIter
)
)
{
if
(
nsIFrame
*
primaryFrame
=
sibling
-
>
GetPrimaryFrame
(
)
)
{
if
(
primaryFrame
-
>
GetContent
(
)
=
=
sibling
)
{
if
(
nsIFrame
*
frame
=
adjust
(
primaryFrame
)
)
{
return
frame
;
}
}
}
if
(
IsDisplayContents
(
sibling
)
)
{
if
(
nsIFrame
*
frame
=
adjust
(
getNearPseudo
(
sibling
)
)
)
{
return
frame
;
}
const
bool
startFromBeginning
=
aDirection
=
=
SiblingDirection
:
:
Forward
;
FlattenedChildIterator
iter
(
sibling
startFromBeginning
)
;
nsIFrame
*
sibling
=
FindSiblingInternal
<
aDirection
>
(
iter
aTargetContent
aTargetContentDisplay
)
;
if
(
sibling
)
{
return
sibling
;
}
}
}
return
adjust
(
getFarPseudo
(
aIter
.
Parent
(
)
)
)
;
}
nsIFrame
*
nsCSSFrameConstructor
:
:
AdjustSiblingFrame
(
nsIFrame
*
aSibling
nsIContent
*
aTargetContent
mozilla
:
:
StyleDisplay
&
aTargetContentDisplay
SiblingDirection
aDirection
)
{
if
(
!
aSibling
)
{
return
nullptr
;
}
if
(
aSibling
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
{
aSibling
=
aSibling
-
>
GetPlaceholderFrame
(
)
;
MOZ_ASSERT
(
aSibling
)
;
}
MOZ_ASSERT
(
!
aSibling
-
>
GetPrevContinuation
(
)
"
How
?
"
)
;
if
(
aDirection
=
=
SiblingDirection
:
:
Backward
)
{
if
(
IsFramePartOfIBSplit
(
aSibling
)
)
{
aSibling
=
GetLastIBSplitSibling
(
aSibling
)
;
}
aSibling
=
aSibling
-
>
GetTailContinuation
(
)
;
}
if
(
!
IsValidSibling
(
aSibling
aTargetContent
aTargetContentDisplay
)
)
{
return
nullptr
;
}
return
aSibling
;
}
nsIFrame
*
nsCSSFrameConstructor
:
:
FindPreviousSibling
(
const
FlattenedChildIterator
&
aIter
StyleDisplay
&
aTargetContentDisplay
)
{
return
FindSibling
<
SiblingDirection
:
:
Backward
>
(
aIter
aTargetContentDisplay
)
;
}
nsIFrame
*
nsCSSFrameConstructor
:
:
FindNextSibling
(
const
FlattenedChildIterator
&
aIter
StyleDisplay
&
aTargetContentDisplay
)
{
return
FindSibling
<
SiblingDirection
:
:
Forward
>
(
aIter
aTargetContentDisplay
)
;
}
template
<
nsCSSFrameConstructor
:
:
SiblingDirection
aDirection
>
nsIFrame
*
nsCSSFrameConstructor
:
:
FindSibling
(
const
FlattenedChildIterator
&
aIter
StyleDisplay
&
aTargetContentDisplay
)
{
nsIContent
*
targetContent
=
aIter
.
Get
(
)
;
FlattenedChildIterator
siblingIter
=
aIter
;
nsIFrame
*
sibling
=
FindSiblingInternal
<
aDirection
>
(
siblingIter
targetContent
aTargetContentDisplay
)
;
if
(
sibling
)
{
return
sibling
;
}
const
nsIContent
*
current
=
aIter
.
Parent
(
)
;
while
(
IsDisplayContents
(
current
)
)
{
const
nsIContent
*
parent
=
current
-
>
GetFlattenedTreeParent
(
)
;
MOZ_ASSERT
(
parent
"
No
display
:
contents
on
the
root
"
)
;
FlattenedChildIterator
iter
(
parent
)
;
iter
.
Seek
(
current
)
;
sibling
=
FindSiblingInternal
<
aDirection
>
(
iter
targetContent
aTargetContentDisplay
)
;
if
(
sibling
)
{
return
sibling
;
}
current
=
parent
;
}
return
nullptr
;
}
static
nsContainerFrame
*
GetAdjustedParentFrame
(
nsContainerFrame
*
aParentFrame
nsIContent
*
aChildContent
)
{
MOZ_ASSERT
(
!
aParentFrame
-
>
IsTableWrapperFrame
(
)
"
Shouldn
'
t
be
happening
!
"
)
;
nsContainerFrame
*
newParent
=
nullptr
;
if
(
aParentFrame
-
>
IsFieldSetFrame
(
)
)
{
if
(
!
aChildContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
legend
)
)
{
newParent
=
GetFieldSetBlockFrame
(
aParentFrame
)
;
}
}
return
newParent
?
newParent
:
aParentFrame
;
}
nsIFrame
*
nsCSSFrameConstructor
:
:
GetInsertionPrevSibling
(
InsertionPoint
*
aInsertion
nsIContent
*
aChild
bool
*
aIsAppend
bool
*
aIsRangeInsertSafe
nsIContent
*
aStartSkipChild
nsIContent
*
aEndSkipChild
)
{
MOZ_ASSERT
(
aInsertion
-
>
mParentFrame
"
Must
have
parent
frame
to
start
with
"
)
;
*
aIsAppend
=
false
;
FlattenedChildIterator
iter
(
aInsertion
-
>
mContainer
)
;
bool
xblCase
=
iter
.
XBLInvolved
(
)
|
|
aInsertion
-
>
mParentFrame
-
>
GetContent
(
)
!
=
aInsertion
-
>
mContainer
;
if
(
xblCase
|
|
!
aChild
-
>
IsRootOfAnonymousSubtree
(
)
)
{
if
(
aStartSkipChild
)
{
iter
.
Seek
(
aStartSkipChild
)
;
}
else
{
iter
.
Seek
(
aChild
)
;
}
}
else
{
iter
.
GetNextChild
(
)
;
MOZ_ASSERT
(
aChild
-
>
GetProperty
(
nsGkAtoms
:
:
restylableAnonymousNode
)
"
Someone
passed
native
anonymous
content
directly
into
frame
"
"
construction
.
Stop
doing
that
!
"
)
;
}
StyleDisplay
childDisplay
=
UNSET_DISPLAY
;
nsIFrame
*
prevSibling
=
FindPreviousSibling
(
iter
childDisplay
)
;
if
(
prevSibling
)
{
aInsertion
-
>
mParentFrame
=
prevSibling
-
>
GetParent
(
)
-
>
GetContentInsertionFrame
(
)
;
}
else
{
if
(
aEndSkipChild
)
{
iter
.
Seek
(
aEndSkipChild
)
;
iter
.
GetPreviousChild
(
)
;
}
if
(
nsIFrame
*
nextSibling
=
FindNextSibling
(
iter
childDisplay
)
)
{
aInsertion
-
>
mParentFrame
=
nextSibling
-
>
GetParent
(
)
-
>
GetContentInsertionFrame
(
)
;
}
else
{
*
aIsAppend
=
true
;
aInsertion
-
>
mParentFrame
=
:
:
ContinuationToAppendTo
(
aInsertion
-
>
mParentFrame
)
;
aInsertion
-
>
mParentFrame
=
:
:
GetAdjustedParentFrame
(
aInsertion
-
>
mParentFrame
aChild
)
;
prevSibling
=
:
:
FindAppendPrevSibling
(
aInsertion
-
>
mParentFrame
nullptr
)
;
}
}
*
aIsRangeInsertSafe
=
(
childDisplay
=
=
UNSET_DISPLAY
)
;
return
prevSibling
;
}
nsContainerFrame
*
nsCSSFrameConstructor
:
:
GetContentInsertionFrameFor
(
nsIContent
*
aContent
)
{
nsIFrame
*
frame
;
while
(
!
(
frame
=
aContent
-
>
GetPrimaryFrame
(
)
)
)
{
if
(
!
IsDisplayContents
(
aContent
)
)
{
return
nullptr
;
}
aContent
=
aContent
-
>
GetFlattenedTreeParent
(
)
;
if
(
!
aContent
)
{
return
nullptr
;
}
}
if
(
frame
-
>
GetContent
(
)
!
=
aContent
)
{
return
nullptr
;
}
nsContainerFrame
*
insertionFrame
=
frame
-
>
GetContentInsertionFrame
(
)
;
NS_ASSERTION
(
!
insertionFrame
|
|
insertionFrame
=
=
frame
|
|
!
frame
-
>
IsLeaf
(
)
"
The
insertion
frame
is
the
primary
frame
or
the
primary
frame
isn
'
t
a
leaf
"
)
;
return
insertionFrame
;
}
static
bool
IsSpecialFramesetChild
(
nsIContent
*
aContent
)
{
return
aContent
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
frameset
nsGkAtoms
:
:
frame
)
;
}
static
void
InvalidateCanvasIfNeeded
(
nsIPresShell
*
presShell
nsIContent
*
node
)
;
void
nsCSSFrameConstructor
:
:
AddTextItemIfNeeded
(
nsFrameConstructorState
&
aState
const
InsertionPoint
&
aInsertion
nsIContent
*
aPossibleTextContent
FrameConstructionItemList
&
aItems
)
{
MOZ_ASSERT
(
aPossibleTextContent
"
Must
have
node
"
)
;
if
(
!
aPossibleTextContent
-
>
IsText
(
)
|
|
!
aPossibleTextContent
-
>
HasFlag
(
NS_CREATE_FRAME_IF_NON_WHITESPACE
)
|
|
aPossibleTextContent
-
>
HasFlag
(
NODE_NEEDS_FRAME
)
)
{
return
;
}
MOZ_ASSERT
(
!
aPossibleTextContent
-
>
GetPrimaryFrame
(
)
"
Text
node
has
a
frame
and
NS_CREATE_FRAME_IF_NON_WHITESPACE
"
)
;
AddFrameConstructionItems
(
aState
aPossibleTextContent
false
aInsertion
aItems
)
;
}
void
nsCSSFrameConstructor
:
:
ReframeTextIfNeeded
(
nsIContent
*
aContent
)
{
if
(
!
aContent
-
>
IsText
(
)
|
|
!
aContent
-
>
HasFlag
(
NS_CREATE_FRAME_IF_NON_WHITESPACE
)
|
|
aContent
-
>
HasFlag
(
NODE_NEEDS_FRAME
)
)
{
return
;
}
MOZ_ASSERT
(
!
aContent
-
>
GetPrimaryFrame
(
)
"
Text
node
has
a
frame
and
NS_CREATE_FRAME_IF_NON_WHITESPACE
"
)
;
ContentInserted
(
aContent
nullptr
InsertionKind
:
:
Async
)
;
}
#
ifdef
DEBUG
void
nsCSSFrameConstructor
:
:
CheckBitsForLazyFrameConstruction
(
nsIContent
*
aParent
)
{
bool
noPrimaryFrame
=
false
;
bool
needsFrameBitSet
=
false
;
nsIContent
*
content
=
aParent
;
while
(
content
&
&
!
content
-
>
HasFlag
(
NODE_DESCENDANTS_NEED_FRAMES
)
)
{
if
(
content
-
>
GetPrimaryFrame
(
)
&
&
content
-
>
GetPrimaryFrame
(
)
-
>
IsLeaf
(
)
)
{
noPrimaryFrame
=
needsFrameBitSet
=
false
;
}
if
(
!
noPrimaryFrame
&
&
!
content
-
>
GetPrimaryFrame
(
)
)
{
noPrimaryFrame
=
!
IsDisplayContents
(
content
)
;
}
if
(
!
needsFrameBitSet
&
&
content
-
>
HasFlag
(
NODE_NEEDS_FRAME
)
)
{
needsFrameBitSet
=
true
;
}
content
=
content
-
>
GetFlattenedTreeParent
(
)
;
}
if
(
content
&
&
content
-
>
GetPrimaryFrame
(
)
&
&
content
-
>
GetPrimaryFrame
(
)
-
>
IsLeaf
(
)
)
{
noPrimaryFrame
=
needsFrameBitSet
=
false
;
}
MOZ_ASSERT
(
!
noPrimaryFrame
"
Ancestors
of
nodes
with
frames
to
be
"
"
constructed
lazily
should
have
frames
"
)
;
MOZ_ASSERT
(
!
needsFrameBitSet
"
Ancestors
of
nodes
with
frames
to
be
"
"
constructed
lazily
should
not
have
NEEDS_FRAME
bit
set
"
)
;
}
#
endif
bool
nsCSSFrameConstructor
:
:
MaybeConstructLazily
(
Operation
aOperation
nsIContent
*
aChild
)
{
MOZ_ASSERT
(
aChild
-
>
GetParent
(
)
)
;
if
(
aOperation
=
=
CONTENTINSERT
)
{
MOZ_ASSERT
(
!
aChild
-
>
IsRootOfAnonymousSubtree
(
)
)
;
if
(
aChild
-
>
IsXULElement
(
)
)
{
return
false
;
}
}
else
{
MOZ_ASSERT
(
aOperation
=
=
CONTENTAPPEND
"
operation
should
be
either
insert
or
append
"
)
;
for
(
nsIContent
*
child
=
aChild
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
MOZ_ASSERT
(
!
child
-
>
IsRootOfAnonymousSubtree
(
)
)
;
if
(
child
-
>
IsXULElement
(
)
)
{
return
false
;
}
}
}
Element
*
parent
=
aChild
-
>
GetFlattenedTreeParentElement
(
)
;
if
(
!
parent
)
{
return
true
;
}
if
(
Servo_Element_IsDisplayNone
(
parent
)
)
{
return
true
;
}
if
(
aOperation
=
=
CONTENTINSERT
)
{
NS_ASSERTION
(
!
aChild
-
>
GetPrimaryFrame
(
)
|
|
aChild
-
>
GetPrimaryFrame
(
)
-
>
GetContent
(
)
!
=
aChild
"
setting
NEEDS_FRAME
on
a
node
that
already
has
a
frame
?
"
)
;
aChild
-
>
SetFlags
(
NODE_NEEDS_FRAME
)
;
}
else
{
for
(
nsIContent
*
child
=
aChild
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
NS_ASSERTION
(
!
child
-
>
GetPrimaryFrame
(
)
|
|
child
-
>
GetPrimaryFrame
(
)
-
>
GetContent
(
)
!
=
child
"
setting
NEEDS_FRAME
on
a
node
that
already
has
a
frame
?
"
)
;
child
-
>
SetFlags
(
NODE_NEEDS_FRAME
)
;
}
}
CheckBitsForLazyFrameConstruction
(
parent
)
;
parent
-
>
NoteDescendantsNeedFramesForServo
(
)
;
return
true
;
}
void
nsCSSFrameConstructor
:
:
IssueSingleInsertNofications
(
nsIContent
*
aStartChild
nsIContent
*
aEndChild
InsertionKind
aInsertionKind
)
{
for
(
nsIContent
*
child
=
aStartChild
;
child
!
=
aEndChild
;
child
=
child
-
>
GetNextSibling
(
)
)
{
MOZ_ASSERT
(
MaybeGetListBoxBodyFrame
(
child
)
|
|
!
child
-
>
GetPrimaryFrame
(
)
)
;
ContentRangeInserted
(
child
child
-
>
GetNextSibling
(
)
mTempFrameTreeState
aInsertionKind
)
;
}
}
bool
nsCSSFrameConstructor
:
:
InsertionPoint
:
:
IsMultiple
(
)
const
{
if
(
!
mParentFrame
)
{
return
false
;
}
if
(
mParentFrame
-
>
IsFieldSetFrame
(
)
)
{
return
true
;
}
if
(
mParentFrame
-
>
IsDetailsFrame
(
)
)
{
return
true
;
}
return
false
;
}
nsCSSFrameConstructor
:
:
InsertionPoint
nsCSSFrameConstructor
:
:
GetRangeInsertionPoint
(
nsIContent
*
aStartChild
nsIContent
*
aEndChild
InsertionKind
aInsertionKind
)
{
MOZ_ASSERT
(
aStartChild
)
;
MOZ_ASSERT
(
aStartChild
-
>
GetParent
(
)
)
;
nsIContent
*
parent
=
aStartChild
-
>
GetParent
(
)
;
if
(
parent
-
>
GetShadowRoot
(
)
|
|
parent
-
>
GetXBLBinding
(
)
)
{
IssueSingleInsertNofications
(
aStartChild
aEndChild
aInsertionKind
)
;
return
{
}
;
}
#
ifdef
DEBUG
{
nsIContent
*
expectedParent
=
aStartChild
-
>
GetFlattenedTreeParent
(
)
;
for
(
nsIContent
*
child
=
aStartChild
-
>
GetNextSibling
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
MOZ_ASSERT
(
child
-
>
GetFlattenedTreeParent
(
)
=
=
expectedParent
)
;
}
}
#
endif
InsertionPoint
ip
=
GetInsertionPoint
(
aStartChild
)
;
if
(
ip
.
IsMultiple
(
)
)
{
IssueSingleInsertNofications
(
aStartChild
aEndChild
aInsertionKind
)
;
return
{
}
;
}
return
ip
;
}
bool
nsCSSFrameConstructor
:
:
MaybeRecreateForFrameset
(
nsIFrame
*
aParentFrame
nsIContent
*
aStartChild
nsIContent
*
aEndChild
)
{
if
(
aParentFrame
-
>
IsFrameSetFrame
(
)
)
{
for
(
nsIContent
*
cur
=
aStartChild
;
cur
!
=
aEndChild
;
cur
=
cur
-
>
GetNextSibling
(
)
)
{
if
(
IsSpecialFramesetChild
(
cur
)
)
{
RecreateFramesForContent
(
aParentFrame
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
return
true
;
}
}
}
return
false
;
}
void
nsCSSFrameConstructor
:
:
LazilyStyleNewChildRange
(
nsIContent
*
aStartChild
nsIContent
*
aEndChild
)
{
for
(
nsIContent
*
child
=
aStartChild
;
child
!
=
aEndChild
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
child
-
>
IsElement
(
)
)
{
child
-
>
AsElement
(
)
-
>
NoteDirtyForServo
(
)
;
}
}
}
#
ifdef
DEBUG
static
bool
IsFlattenedTreeChild
(
nsIContent
*
aParent
nsIContent
*
aChild
)
{
FlattenedChildIterator
iter
(
aParent
)
;
for
(
nsIContent
*
node
=
iter
.
GetNextChild
(
)
;
node
;
node
=
iter
.
GetNextChild
(
)
)
{
if
(
node
=
=
aChild
)
{
return
true
;
}
}
return
false
;
}
#
endif
void
nsCSSFrameConstructor
:
:
StyleNewChildRange
(
nsIContent
*
aStartChild
nsIContent
*
aEndChild
)
{
ServoStyleSet
*
styleSet
=
mPresShell
-
>
StyleSet
(
)
;
for
(
nsIContent
*
child
=
aStartChild
;
child
!
=
aEndChild
;
child
=
child
-
>
GetNextSibling
(
)
)
{
if
(
!
child
-
>
IsElement
(
)
)
{
continue
;
}
Element
*
childElement
=
child
-
>
AsElement
(
)
;
MOZ_ASSERT
(
!
childElement
-
>
HasServoData
(
)
)
;
#
ifdef
DEBUG
{
Element
*
parent
=
childElement
-
>
GetFlattenedTreeParentElement
(
)
;
MOZ_ASSERT
(
parent
)
;
MOZ_ASSERT
(
parent
-
>
HasServoData
(
)
)
;
MOZ_ASSERT
(
IsFlattenedTreeChild
(
parent
child
)
"
GetFlattenedTreeParent
and
ChildIterator
don
'
t
agree
fix
this
!
"
)
;
}
#
endif
styleSet
-
>
StyleNewSubtree
(
childElement
)
;
}
}
nsIFrame
*
nsCSSFrameConstructor
:
:
FindNextSiblingForAppend
(
const
InsertionPoint
&
aInsertion
)
{
auto
SlowPath
=
[
&
]
(
)
-
>
nsIFrame
*
{
FlattenedChildIterator
iter
(
aInsertion
.
mContainer
false
)
;
iter
.
GetPreviousChild
(
)
;
StyleDisplay
unused
=
UNSET_DISPLAY
;
return
FindNextSibling
(
iter
unused
)
;
}
;
if
(
!
IsDisplayContents
(
aInsertion
.
mContainer
)
&
&
!
nsLayoutUtils
:
:
GetAfterFrame
(
aInsertion
.
mContainer
)
)
{
MOZ_ASSERT
(
!
SlowPath
(
)
)
;
return
nullptr
;
}
return
SlowPath
(
)
;
}
void
nsCSSFrameConstructor
:
:
ContentAppended
(
nsIContent
*
aFirstNewContent
InsertionKind
aInsertionKind
)
{
MOZ_ASSERT
(
aInsertionKind
=
=
InsertionKind
:
:
Sync
|
|
!
RestyleManager
(
)
-
>
IsInStyleRefresh
(
)
)
;
AUTO_LAYOUT_PHASE_ENTRY_POINT
(
mPresShell
-
>
GetPresContext
(
)
FrameC
)
;
#
ifdef
DEBUG
if
(
gNoisyContentUpdates
)
{
printf
(
"
nsCSSFrameConstructor
:
:
ContentAppended
container
=
%
p
"
"
first
-
child
=
%
p
lazy
=
%
d
\
n
"
aFirstNewContent
-
>
GetParent
(
)
aFirstNewContent
aInsertionKind
=
=
InsertionKind
:
:
Async
)
;
if
(
gReallyNoisyContentUpdates
&
&
aFirstNewContent
-
>
GetParent
(
)
)
{
aFirstNewContent
-
>
GetParent
(
)
-
>
List
(
stdout
0
)
;
}
}
for
(
nsIContent
*
child
=
aFirstNewContent
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
MOZ_ASSERT
(
!
child
-
>
GetPrimaryFrame
(
)
|
|
child
-
>
GetPrimaryFrame
(
)
-
>
GetContent
(
)
!
=
child
"
asked
to
construct
a
frame
for
a
node
that
already
has
a
frame
"
)
;
}
#
endif
LAYOUT_PHASE_TEMP_EXIT
(
)
;
InsertionPoint
insertion
=
GetRangeInsertionPoint
(
aFirstNewContent
nullptr
aInsertionKind
)
;
nsContainerFrame
*
&
parentFrame
=
insertion
.
mParentFrame
;
LAYOUT_PHASE_TEMP_REENTER
(
)
;
if
(
!
parentFrame
)
{
if
(
aInsertionKind
=
=
InsertionKind
:
:
Async
)
{
LazilyStyleNewChildRange
(
aFirstNewContent
nullptr
)
;
}
return
;
}
if
(
aInsertionKind
=
=
InsertionKind
:
:
Async
)
{
if
(
MaybeConstructLazily
(
CONTENTAPPEND
aFirstNewContent
)
)
{
LazilyStyleNewChildRange
(
aFirstNewContent
nullptr
)
;
return
;
}
StyleNewChildRange
(
aFirstNewContent
nullptr
)
;
}
LAYOUT_PHASE_TEMP_EXIT
(
)
;
if
(
MaybeRecreateForFrameset
(
parentFrame
aFirstNewContent
nullptr
)
)
{
LAYOUT_PHASE_TEMP_REENTER
(
)
;
return
;
}
LAYOUT_PHASE_TEMP_REENTER
(
)
;
if
(
parentFrame
-
>
IsLeaf
(
)
)
{
ClearLazyBits
(
aFirstNewContent
nullptr
)
;
return
;
}
if
(
parentFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eMathML
)
)
{
LAYOUT_PHASE_TEMP_EXIT
(
)
;
RecreateFramesForContent
(
parentFrame
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
LAYOUT_PHASE_TEMP_REENTER
(
)
;
return
;
}
#
ifdef
DEBUG
if
(
gNoisyContentUpdates
&
&
IsFramePartOfIBSplit
(
parentFrame
)
)
{
printf
(
"
nsCSSFrameConstructor
:
:
ContentAppended
:
parentFrame
=
"
)
;
nsFrame
:
:
ListTag
(
stdout
parentFrame
)
;
printf
(
"
is
ib
-
split
\
n
"
)
;
}
#
endif
MOZ_ASSERT
(
!
parentFrame
-
>
IsFieldSetFrame
(
)
&
&
!
parentFrame
-
>
IsDetailsFrame
(
)
"
Parent
frame
should
not
be
fieldset
or
details
!
"
)
;
nsIFrame
*
nextSibling
=
FindNextSiblingForAppend
(
insertion
)
;
if
(
nextSibling
)
{
parentFrame
=
nextSibling
-
>
GetParent
(
)
-
>
GetContentInsertionFrame
(
)
;
}
else
{
parentFrame
=
:
:
ContinuationToAppendTo
(
parentFrame
)
;
}
nsContainerFrame
*
containingBlock
=
GetFloatContainingBlock
(
parentFrame
)
;
const
bool
haveFirstLetterStyle
=
containingBlock
&
&
HasFirstLetterStyle
(
containingBlock
)
;
const
bool
haveFirstLineStyle
=
containingBlock
&
&
ShouldHaveFirstLineStyle
(
containingBlock
-
>
GetContent
(
)
containingBlock
-
>
Style
(
)
)
;
if
(
haveFirstLetterStyle
)
{
AutoWeakFrame
wf
(
nextSibling
)
;
RemoveLetterFrames
(
mPresShell
containingBlock
)
;
if
(
nextSibling
&
&
!
wf
)
{
nextSibling
=
FindNextSiblingForAppend
(
insertion
)
;
if
(
nextSibling
)
{
parentFrame
=
nextSibling
-
>
GetParent
(
)
-
>
GetContentInsertionFrame
(
)
;
containingBlock
=
GetFloatContainingBlock
(
parentFrame
)
;
}
}
}
nsFrameConstructorState
state
(
mPresShell
GetAbsoluteContainingBlock
(
parentFrame
FIXED_POS
)
GetAbsoluteContainingBlock
(
parentFrame
ABS_POS
)
containingBlock
)
;
LayoutFrameType
frameType
=
parentFrame
-
>
Type
(
)
;
FlattenedChildIterator
iter
(
insertion
.
mContainer
)
;
const
bool
haveNoXBLChildren
=
!
iter
.
XBLInvolved
(
)
|
|
!
iter
.
GetNextChild
(
)
;
AutoFrameConstructionItemList
items
(
this
)
;
if
(
aFirstNewContent
-
>
GetPreviousSibling
(
)
&
&
GetParentType
(
frameType
)
=
=
eTypeBlock
&
&
haveNoXBLChildren
)
{
AddTextItemIfNeeded
(
state
insertion
aFirstNewContent
-
>
GetPreviousSibling
(
)
items
)
;
}
for
(
nsIContent
*
child
=
aFirstNewContent
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
AddFrameConstructionItems
(
state
child
false
insertion
items
)
;
}
nsIFrame
*
prevSibling
=
:
:
FindAppendPrevSibling
(
parentFrame
nextSibling
)
;
LAYOUT_PHASE_TEMP_EXIT
(
)
;
if
(
WipeContainingBlock
(
state
containingBlock
parentFrame
items
true
prevSibling
)
)
{
LAYOUT_PHASE_TEMP_REENTER
(
)
;
return
;
}
LAYOUT_PHASE_TEMP_REENTER
(
)
;
if
(
nsLayoutUtils
:
:
GetAsBlock
(
parentFrame
)
&
&
!
haveFirstLetterStyle
&
&
!
haveFirstLineStyle
&
&
!
IsFramePartOfIBSplit
(
parentFrame
)
)
{
items
.
SetLineBoundaryAtStart
(
!
prevSibling
|
|
!
prevSibling
-
>
IsInlineOutside
(
)
|
|
prevSibling
-
>
IsBrFrame
(
)
)
;
items
.
SetLineBoundaryAtEnd
(
!
nextSibling
|
|
!
nextSibling
-
>
IsInlineOutside
(
)
)
;
}
items
.
SetParentHasNoXBLChildren
(
haveNoXBLChildren
)
;
nsFrameItems
frameItems
;
ConstructFramesFromItemList
(
state
items
parentFrame
ParentIsWrapperAnonBox
(
parentFrame
)
frameItems
)
;
for
(
nsIContent
*
child
=
aFirstNewContent
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
InvalidateCanvasIfNeeded
(
mPresShell
child
)
;
}
nsFrameItems
captionItems
;
if
(
LayoutFrameType
:
:
Table
=
=
frameType
)
{
PullOutCaptionFrames
(
frameItems
captionItems
)
;
}
if
(
haveFirstLineStyle
&
&
parentFrame
=
=
containingBlock
)
{
AppendFirstLineFrames
(
state
containingBlock
-
>
GetContent
(
)
containingBlock
frameItems
)
;
}
else
if
(
parentFrame
-
>
Style
(
)
-
>
HasPseudoElementData
(
)
)
{
CheckForFirstLineInsertion
(
parentFrame
frameItems
)
;
CheckForFirstLineInsertion
(
parentFrame
captionItems
)
;
}
if
(
captionItems
.
NotEmpty
(
)
)
{
NS_ASSERTION
(
LayoutFrameType
:
:
Table
=
=
frameType
"
how
did
that
happen
?
"
)
;
nsContainerFrame
*
outerTable
=
parentFrame
-
>
GetParent
(
)
;
AppendFrames
(
outerTable
nsIFrame
:
:
kCaptionList
captionItems
)
;
}
if
(
frameItems
.
NotEmpty
(
)
)
{
AppendFramesToParent
(
state
parentFrame
frameItems
prevSibling
)
;
}
if
(
haveFirstLetterStyle
)
{
RecoverLetterFrames
(
containingBlock
)
;
}
#
ifdef
DEBUG
if
(
gReallyNoisyContentUpdates
)
{
printf
(
"
nsCSSFrameConstructor
:
:
ContentAppended
:
resulting
frame
model
:
\
n
"
)
;
parentFrame
-
>
List
(
stdout
0
)
;
}
#
endif
#
ifdef
ACCESSIBILITY
if
(
nsAccessibilityService
*
accService
=
nsIPresShell
:
:
AccService
(
)
)
{
accService
-
>
ContentRangeInserted
(
mPresShell
aFirstNewContent
nullptr
)
;
}
#
endif
}
#
ifdef
MOZ_XUL
enum
content_operation
{
CONTENT_INSERTED
CONTENT_REMOVED
}
;
static
bool
NotifyListBoxBody
(
nsPresContext
*
aPresContext
nsIContent
*
aChild
nsIContent
*
aOldNextSibling
nsIFrame
*
aChildFrame
content_operation
aOperation
)
{
nsListBoxBodyFrame
*
listBoxBodyFrame
=
MaybeGetListBoxBodyFrame
(
aChild
)
;
if
(
listBoxBodyFrame
)
{
if
(
aOperation
=
=
CONTENT_REMOVED
)
{
if
(
!
aChildFrame
|
|
aChildFrame
-
>
GetParent
(
)
=
=
listBoxBodyFrame
)
{
listBoxBodyFrame
-
>
OnContentRemoved
(
aPresContext
aChild
-
>
GetParent
(
)
aChildFrame
aOldNextSibling
)
;
return
true
;
}
}
else
{
listBoxBodyFrame
-
>
OnContentInserted
(
aChild
)
;
return
true
;
}
}
return
false
;
}
#
endif
void
nsCSSFrameConstructor
:
:
ContentInserted
(
nsIContent
*
aChild
nsILayoutHistoryState
*
aFrameState
InsertionKind
aInsertionKind
)
{
ContentRangeInserted
(
aChild
aChild
-
>
GetNextSibling
(
)
aFrameState
aInsertionKind
)
;
}
void
nsCSSFrameConstructor
:
:
ContentRangeInserted
(
nsIContent
*
aStartChild
nsIContent
*
aEndChild
nsILayoutHistoryState
*
aFrameState
InsertionKind
aInsertionKind
)
{
MOZ_ASSERT
(
aInsertionKind
=
=
InsertionKind
:
:
Sync
|
|
!
RestyleManager
(
)
-
>
IsInStyleRefresh
(
)
)
;
AUTO_LAYOUT_PHASE_ENTRY_POINT
(
mPresShell
-
>
GetPresContext
(
)
FrameC
)
;
MOZ_ASSERT
(
aStartChild
"
must
always
pass
a
child
"
)
;
#
ifdef
DEBUG
if
(
gNoisyContentUpdates
)
{
printf
(
"
nsCSSFrameConstructor
:
:
ContentRangeInserted
container
=
%
p
"
"
start
-
child
=
%
p
end
-
child
=
%
p
lazy
=
%
d
\
n
"
aStartChild
-
>
GetParent
(
)
aStartChild
aEndChild
aInsertionKind
=
=
InsertionKind
:
:
Async
)
;
if
(
gReallyNoisyContentUpdates
)
{
if
(
aStartChild
-
>
GetParent
(
)
)
{
aStartChild
-
>
GetParent
(
)
-
>
List
(
stdout
0
)
;
}
else
{
aStartChild
-
>
List
(
stdout
0
)
;
}
}
}
for
(
nsIContent
*
child
=
aStartChild
;
child
!
=
aEndChild
;
child
=
child
-
>
GetNextSibling
(
)
)
{
NS_ASSERTION
(
!
child
-
>
GetPrimaryFrame
(
)
|
|
child
-
>
GetPrimaryFrame
(
)
-
>
GetContent
(
)
!
=
child
"
asked
to
construct
a
frame
for
a
node
that
already
has
a
frame
"
)
;
}
#
endif
bool
isSingleInsert
=
(
aStartChild
-
>
GetNextSibling
(
)
=
=
aEndChild
)
;
NS_ASSERTION
(
isSingleInsert
|
|
aInsertionKind
=
=
InsertionKind
:
:
Sync
"
range
insert
shouldn
'
t
be
lazy
"
)
;
NS_ASSERTION
(
isSingleInsert
|
|
aEndChild
"
range
should
not
include
all
nodes
after
aStartChild
"
)
;
#
ifdef
MOZ_XUL
if
(
aStartChild
-
>
GetParent
(
)
&
&
IsXULListBox
(
aStartChild
-
>
GetParent
(
)
)
)
{
if
(
isSingleInsert
)
{
if
(
NotifyListBoxBody
(
mPresShell
-
>
GetPresContext
(
)
aStartChild
nullptr
nullptr
CONTENT_INSERTED
)
)
{
return
;
}
}
else
{
LAYOUT_PHASE_TEMP_EXIT
(
)
;
IssueSingleInsertNofications
(
aStartChild
aEndChild
InsertionKind
:
:
Sync
)
;
LAYOUT_PHASE_TEMP_REENTER
(
)
;
return
;
}
}
#
endif
if
(
!
aStartChild
-
>
GetParent
(
)
)
{
MOZ_ASSERT
(
isSingleInsert
"
root
node
insertion
should
be
a
single
insertion
"
)
;
Element
*
docElement
=
mDocument
-
>
GetRootElement
(
)
;
if
(
aStartChild
!
=
docElement
)
{
return
;
}
MOZ_ASSERT
(
!
mRootElementFrame
"
root
element
frame
already
created
"
)
;
if
(
ConstructDocElementFrame
(
docElement
aFrameState
)
)
{
InvalidateCanvasIfNeeded
(
mPresShell
aStartChild
)
;
#
ifdef
DEBUG
if
(
gReallyNoisyContentUpdates
)
{
printf
(
"
nsCSSFrameConstructor
:
:
ContentRangeInserted
:
resulting
frame
"
"
model
:
\
n
"
)
;
mRootElementFrame
-
>
List
(
stdout
0
)
;
}
#
endif
}
if
(
aFrameState
)
{
if
(
nsIFrame
*
rootScrollFrame
=
mPresShell
-
>
GetRootScrollFrame
(
)
)
{
RestoreFrameStateFor
(
rootScrollFrame
aFrameState
)
;
}
}
#
ifdef
ACCESSIBILITY
if
(
nsAccessibilityService
*
accService
=
nsIPresShell
:
:
AccService
(
)
)
{
accService
-
>
ContentRangeInserted
(
mPresShell
aStartChild
aEndChild
)
;
}
#
endif
return
;
}
InsertionPoint
insertion
;
if
(
isSingleInsert
)
{
insertion
=
GetInsertionPoint
(
aStartChild
)
;
}
else
{
LAYOUT_PHASE_TEMP_EXIT
(
)
;
insertion
=
GetRangeInsertionPoint
(
aStartChild
aEndChild
aInsertionKind
)
;
LAYOUT_PHASE_TEMP_REENTER
(
)
;
}
if
(
!
insertion
.
mParentFrame
)
{
if
(
aInsertionKind
=
=
InsertionKind
:
:
Async
)
{
LazilyStyleNewChildRange
(
aStartChild
aEndChild
)
;
}
return
;
}
if
(
aInsertionKind
=
=
InsertionKind
:
:
Async
)
{
if
(
MaybeConstructLazily
(
CONTENTINSERT
aStartChild
)
)
{
LazilyStyleNewChildRange
(
aStartChild
aEndChild
)
;
return
;
}
StyleNewChildRange
(
aStartChild
aEndChild
)
;
}
bool
isAppend
isRangeInsertSafe
;
nsIFrame
*
prevSibling
=
GetInsertionPrevSibling
(
&
insertion
aStartChild
&
isAppend
&
isRangeInsertSafe
)
;
if
(
!
isSingleInsert
&
&
!
isRangeInsertSafe
)
{
LAYOUT_PHASE_TEMP_EXIT
(
)
;
IssueSingleInsertNofications
(
aStartChild
aEndChild
InsertionKind
:
:
Sync
)
;
LAYOUT_PHASE_TEMP_REENTER
(
)
;
return
;
}
LayoutFrameType
frameType
=
insertion
.
mParentFrame
-
>
Type
(
)
;
LAYOUT_PHASE_TEMP_EXIT
(
)
;
if
(
MaybeRecreateForFrameset
(
insertion
.
mParentFrame
aStartChild
aEndChild
)
)
{
LAYOUT_PHASE_TEMP_REENTER
(
)
;
return
;
}
LAYOUT_PHASE_TEMP_REENTER
(
)
;
NS_ASSERTION
(
isSingleInsert
|
|
frameType
!
=
LayoutFrameType
:
:
FieldSet
"
Unexpected
parent
"
)
;
if
(
IsFrameForFieldSet
(
insertion
.
mParentFrame
)
&
&
aStartChild
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
=
=
nsGkAtoms
:
:
legend
)
{
LAYOUT_PHASE_TEMP_EXIT
(
)
;
RecreateFramesForContent
(
insertion
.
mParentFrame
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
LAYOUT_PHASE_TEMP_REENTER
(
)
;
return
;
}
MOZ_ASSERT
(
isSingleInsert
|
|
frameType
!
=
LayoutFrameType
:
:
Details
)
;
if
(
frameType
=
=
LayoutFrameType
:
:
Details
)
{
LAYOUT_PHASE_TEMP_EXIT
(
)
;
RecreateFramesForContent
(
insertion
.
mParentFrame
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
LAYOUT_PHASE_TEMP_REENTER
(
)
;
return
;
}
if
(
insertion
.
mParentFrame
-
>
IsLeaf
(
)
)
{
ClearLazyBits
(
aStartChild
aEndChild
)
;
return
;
}
if
(
insertion
.
mParentFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eMathML
)
)
{
LAYOUT_PHASE_TEMP_EXIT
(
)
;
RecreateFramesForContent
(
insertion
.
mParentFrame
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
LAYOUT_PHASE_TEMP_REENTER
(
)
;
return
;
}
nsFrameConstructorState
state
(
mPresShell
GetAbsoluteContainingBlock
(
insertion
.
mParentFrame
FIXED_POS
)
GetAbsoluteContainingBlock
(
insertion
.
mParentFrame
ABS_POS
)
GetFloatContainingBlock
(
insertion
.
mParentFrame
)
do_AddRef
(
aFrameState
)
)
;
nsContainerFrame
*
containingBlock
=
state
.
mFloatedItems
.
containingBlock
;
bool
haveFirstLetterStyle
=
false
;
bool
haveFirstLineStyle
=
false
;
StyleDisplay
parentDisplay
=
insertion
.
mParentFrame
-
>
GetDisplay
(
)
;
if
(
(
StyleDisplay
:
:
Block
=
=
parentDisplay
)
|
|
(
StyleDisplay
:
:
ListItem
=
=
parentDisplay
)
|
|
(
StyleDisplay
:
:
Inline
=
=
parentDisplay
)
|
|
(
StyleDisplay
:
:
InlineBlock
=
=
parentDisplay
)
)
{
if
(
containingBlock
)
{
haveFirstLetterStyle
=
HasFirstLetterStyle
(
containingBlock
)
;
haveFirstLineStyle
=
ShouldHaveFirstLineStyle
(
containingBlock
-
>
GetContent
(
)
containingBlock
-
>
Style
(
)
)
;
}
if
(
haveFirstLetterStyle
)
{
if
(
insertion
.
mParentFrame
-
>
IsLetterFrame
(
)
)
{
if
(
insertion
.
mParentFrame
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
{
nsPlaceholderFrame
*
placeholderFrame
=
insertion
.
mParentFrame
-
>
GetPlaceholderFrame
(
)
;
NS_ASSERTION
(
placeholderFrame
"
No
placeholder
for
out
-
of
-
flow
?
"
)
;
insertion
.
mParentFrame
=
placeholderFrame
-
>
GetParent
(
)
;
}
else
{
insertion
.
mParentFrame
=
insertion
.
mParentFrame
-
>
GetParent
(
)
;
}
}
RemoveLetterFrames
(
mPresShell
state
.
mFloatedItems
.
containingBlock
)
;
prevSibling
=
GetInsertionPrevSibling
(
&
insertion
aStartChild
&
isAppend
&
isRangeInsertSafe
)
;
if
(
!
isSingleInsert
&
&
!
isRangeInsertSafe
)
{
RecoverLetterFrames
(
state
.
mFloatedItems
.
containingBlock
)
;
LAYOUT_PHASE_TEMP_EXIT
(
)
;
IssueSingleInsertNofications
(
aStartChild
aEndChild
InsertionKind
:
:
Sync
)
;
LAYOUT_PHASE_TEMP_REENTER
(
)
;
return
;
}
frameType
=
insertion
.
mParentFrame
-
>
Type
(
)
;
}
}
AutoFrameConstructionItemList
items
(
this
)
;
ParentType
parentType
=
GetParentType
(
frameType
)
;
FlattenedChildIterator
iter
(
insertion
.
mContainer
)
;
bool
haveNoXBLChildren
=
(
!
iter
.
XBLInvolved
(
)
|
|
!
iter
.
GetNextChild
(
)
)
;
if
(
aStartChild
-
>
GetPreviousSibling
(
)
&
&
parentType
=
=
eTypeBlock
&
&
haveNoXBLChildren
)
{
AddTextItemIfNeeded
(
state
insertion
aStartChild
-
>
GetPreviousSibling
(
)
items
)
;
}
if
(
isSingleInsert
)
{
AddFrameConstructionItems
(
state
aStartChild
aStartChild
-
>
IsRootOfAnonymousSubtree
(
)
insertion
items
)
;
}
else
{
for
(
nsIContent
*
child
=
aStartChild
;
child
!
=
aEndChild
;
child
=
child
-
>
GetNextSibling
(
)
)
{
AddFrameConstructionItems
(
state
child
false
insertion
items
)
;
}
}
if
(
aEndChild
&
&
parentType
=
=
eTypeBlock
&
&
haveNoXBLChildren
)
{
AddTextItemIfNeeded
(
state
insertion
aEndChild
items
)
;
}
LAYOUT_PHASE_TEMP_EXIT
(
)
;
if
(
WipeContainingBlock
(
state
containingBlock
insertion
.
mParentFrame
items
isAppend
prevSibling
)
)
{
LAYOUT_PHASE_TEMP_REENTER
(
)
;
return
;
}
LAYOUT_PHASE_TEMP_REENTER
(
)
;
nsFrameItems
frameItems
captionItems
;
ConstructFramesFromItemList
(
state
items
insertion
.
mParentFrame
ParentIsWrapperAnonBox
(
insertion
.
mParentFrame
)
frameItems
)
;
if
(
frameItems
.
NotEmpty
(
)
)
{
for
(
nsIContent
*
child
=
aStartChild
;
child
!
=
aEndChild
;
child
=
child
-
>
GetNextSibling
(
)
)
{
InvalidateCanvasIfNeeded
(
mPresShell
child
)
;
}
if
(
LayoutFrameType
:
:
Table
=
=
frameType
|
|
LayoutFrameType
:
:
TableWrapper
=
=
frameType
)
{
PullOutCaptionFrames
(
frameItems
captionItems
)
;
}
}
if
(
haveFirstLineStyle
&
&
insertion
.
mParentFrame
=
=
containingBlock
&
&
isAppend
)
{
AppendFirstLineFrames
(
state
containingBlock
-
>
GetContent
(
)
containingBlock
frameItems
)
;
}
else
if
(
insertion
.
mParentFrame
-
>
Style
(
)
-
>
HasPseudoElementData
(
)
)
{
CheckForFirstLineInsertion
(
insertion
.
mParentFrame
frameItems
)
;
CheckForFirstLineInsertion
(
insertion
.
mParentFrame
captionItems
)
;
}
if
(
captionItems
.
NotEmpty
(
)
)
{
NS_ASSERTION
(
LayoutFrameType
:
:
Table
=
=
frameType
|
|
LayoutFrameType
:
:
TableWrapper
=
=
frameType
"
parent
for
caption
is
not
table
?
"
)
;
bool
captionIsAppend
;
nsIFrame
*
captionPrevSibling
=
nullptr
;
bool
ignored
;
InsertionPoint
captionInsertion
(
insertion
.
mParentFrame
insertion
.
mContainer
)
;
if
(
isSingleInsert
)
{
captionPrevSibling
=
GetInsertionPrevSibling
(
&
captionInsertion
aStartChild
&
captionIsAppend
&
ignored
)
;
}
else
{
nsIContent
*
firstCaption
=
captionItems
.
FirstChild
(
)
-
>
GetContent
(
)
;
captionPrevSibling
=
GetInsertionPrevSibling
(
&
captionInsertion
firstCaption
&
captionIsAppend
&
ignored
aStartChild
aEndChild
)
;
}
nsContainerFrame
*
outerTable
=
nullptr
;
if
(
GetCaptionAdjustedParent
(
captionInsertion
.
mParentFrame
captionItems
.
FirstChild
(
)
&
outerTable
)
)
{
NS_ASSERTION
(
outerTable
-
>
IsTableWrapperFrame
(
)
"
Pseudo
frame
construction
failure
;
"
"
a
caption
can
be
only
a
child
of
a
table
wrapper
frame
"
)
;
if
(
captionPrevSibling
&
&
captionPrevSibling
-
>
GetParent
(
)
!
=
outerTable
)
{
captionPrevSibling
=
nullptr
;
}
if
(
captionIsAppend
)
{
AppendFrames
(
outerTable
nsIFrame
:
:
kCaptionList
captionItems
)
;
}
else
{
InsertFrames
(
outerTable
nsIFrame
:
:
kCaptionList
captionPrevSibling
captionItems
)
;
}
}
}
if
(
frameItems
.
NotEmpty
(
)
)
{
if
(
isAppend
)
{
AppendFramesToParent
(
state
insertion
.
mParentFrame
frameItems
prevSibling
)
;
}
else
{
InsertFrames
(
insertion
.
mParentFrame
kPrincipalList
prevSibling
frameItems
)
;
}
}
if
(
haveFirstLetterStyle
)
{
RecoverLetterFrames
(
state
.
mFloatedItems
.
containingBlock
)
;
}
#
ifdef
DEBUG
if
(
gReallyNoisyContentUpdates
&
&
insertion
.
mParentFrame
)
{
printf
(
"
nsCSSFrameConstructor
:
:
ContentRangeInserted
:
resulting
frame
model
:
\
n
"
)
;
insertion
.
mParentFrame
-
>
List
(
stdout
0
)
;
}
#
endif
#
ifdef
ACCESSIBILITY
if
(
nsAccessibilityService
*
accService
=
nsIPresShell
:
:
AccService
(
)
)
{
accService
-
>
ContentRangeInserted
(
mPresShell
aStartChild
aEndChild
)
;
}
#
endif
}
bool
nsCSSFrameConstructor
:
:
ContentRemoved
(
nsIContent
*
aChild
nsIContent
*
aOldNextSibling
RemoveFlags
aFlags
)
{
MOZ_ASSERT
(
aChild
)
;
MOZ_ASSERT
(
!
aChild
-
>
IsRootOfAnonymousSubtree
(
)
|
|
!
aOldNextSibling
"
Anonymous
roots
don
'
t
have
siblings
"
)
;
AUTO_LAYOUT_PHASE_ENTRY_POINT
(
mPresShell
-
>
GetPresContext
(
)
FrameC
)
;
nsPresContext
*
presContext
=
mPresShell
-
>
GetPresContext
(
)
;
MOZ_ASSERT
(
presContext
"
Our
presShell
should
have
a
valid
presContext
"
)
;
if
(
aChild
=
=
presContext
-
>
GetViewportScrollbarStylesOverrideElement
(
)
|
|
(
aChild
-
>
IsElement
(
)
&
&
!
aChild
-
>
GetParent
(
)
)
)
{
Element
*
newOverrideElement
=
presContext
-
>
UpdateViewportScrollbarStylesOverride
(
)
;
if
(
aChild
-
>
GetParent
(
)
&
&
newOverrideElement
&
&
newOverrideElement
-
>
GetParent
(
)
&
&
newOverrideElement
!
=
aChild
)
{
LAYOUT_PHASE_TEMP_EXIT
(
)
;
RecreateFramesForContent
(
newOverrideElement
InsertionKind
:
:
Async
)
;
LAYOUT_PHASE_TEMP_REENTER
(
)
;
}
}
#
ifdef
DEBUG
if
(
gNoisyContentUpdates
)
{
printf
(
"
nsCSSFrameConstructor
:
:
ContentRemoved
container
=
%
p
child
=
%
p
"
"
old
-
next
-
sibling
=
%
p
\
n
"
aChild
-
>
GetParent
(
)
aChild
aOldNextSibling
)
;
if
(
gReallyNoisyContentUpdates
)
{
aChild
-
>
GetParent
(
)
-
>
List
(
stdout
0
)
;
}
}
#
endif
nsIFrame
*
childFrame
=
aChild
-
>
GetPrimaryFrame
(
)
;
if
(
!
childFrame
|
|
childFrame
-
>
GetContent
(
)
!
=
aChild
)
{
childFrame
=
nullptr
;
}
#
ifdef
MOZ_XUL
if
(
NotifyListBoxBody
(
presContext
aChild
aOldNextSibling
childFrame
CONTENT_REMOVED
)
)
{
return
false
;
}
#
endif
bool
isRoot
=
false
;
if
(
!
aChild
-
>
GetParent
(
)
)
{
if
(
nsIFrame
*
viewport
=
GetRootFrame
(
)
)
{
nsIFrame
*
firstChild
=
viewport
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
firstChild
&
&
firstChild
-
>
GetContent
(
)
=
=
aChild
)
{
isRoot
=
true
;
childFrame
=
firstChild
;
NS_ASSERTION
(
!
childFrame
-
>
GetNextSibling
(
)
"
How
did
that
happen
?
"
)
;
}
}
}
auto
CouldHaveBeenDisplayContents
=
[
aFlags
]
(
nsIContent
*
aContent
)
-
>
bool
{
return
aFlags
=
=
REMOVE_FOR_RECONSTRUCTION
|
|
IsDisplayContents
(
aContent
)
;
}
;
if
(
!
childFrame
&
&
CouldHaveBeenDisplayContents
(
aChild
)
)
{
StyleChildrenIterator
iter
(
aChild
)
;
for
(
nsIContent
*
c
=
iter
.
GetNextChild
(
)
;
c
;
c
=
iter
.
GetNextChild
(
)
)
{
if
(
c
-
>
GetPrimaryFrame
(
)
|
|
CouldHaveBeenDisplayContents
(
aChild
)
)
{
LAYOUT_PHASE_TEMP_EXIT
(
)
;
bool
didReconstruct
=
ContentRemoved
(
c
nullptr
REMOVE_FOR_RECONSTRUCTION
)
;
LAYOUT_PHASE_TEMP_REENTER
(
)
;
if
(
didReconstruct
)
{
return
true
;
}
}
}
return
false
;
}
if
(
childFrame
)
{
InvalidateCanvasIfNeeded
(
mPresShell
aChild
)
;
LAYOUT_PHASE_TEMP_EXIT
(
)
;
if
(
MaybeRecreateContainerForFrameRemoval
(
childFrame
)
)
{
LAYOUT_PHASE_TEMP_REENTER
(
)
;
return
true
;
}
LAYOUT_PHASE_TEMP_REENTER
(
)
;
nsIFrame
*
parentFrame
=
childFrame
-
>
GetParent
(
)
;
LayoutFrameType
parentType
=
parentFrame
-
>
Type
(
)
;
if
(
parentType
=
=
LayoutFrameType
:
:
FrameSet
&
&
IsSpecialFramesetChild
(
aChild
)
)
{
LAYOUT_PHASE_TEMP_EXIT
(
)
;
RecreateFramesForContent
(
parentFrame
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
LAYOUT_PHASE_TEMP_REENTER
(
)
;
return
true
;
}
nsIFrame
*
possibleMathMLAncestor
=
parentType
=
=
LayoutFrameType
:
:
Block
?
parentFrame
-
>
GetParent
(
)
:
parentFrame
;
if
(
possibleMathMLAncestor
-
>
IsFrameOfType
(
nsIFrame
:
:
eMathML
)
)
{
LAYOUT_PHASE_TEMP_EXIT
(
)
;
RecreateFramesForContent
(
parentFrame
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
LAYOUT_PHASE_TEMP_REENTER
(
)
;
return
true
;
}
nsIFrame
*
grandparentFrame
=
parentFrame
-
>
GetParent
(
)
;
if
(
grandparentFrame
&
&
grandparentFrame
-
>
IsXULBoxFrame
(
)
&
&
(
grandparentFrame
-
>
GetStateBits
(
)
&
NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK
)
&
&
aChild
=
=
AnyKidsNeedBlockParent
(
parentFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
)
&
&
!
AnyKidsNeedBlockParent
(
childFrame
-
>
GetNextSibling
(
)
)
)
{
LAYOUT_PHASE_TEMP_EXIT
(
)
;
RecreateFramesForContent
(
grandparentFrame
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
LAYOUT_PHASE_TEMP_REENTER
(
)
;
return
true
;
}
#
ifdef
ACCESSIBILITY
if
(
nsAccessibilityService
*
accService
=
nsIPresShell
:
:
AccService
(
)
)
{
accService
-
>
ContentRemoved
(
mPresShell
aChild
)
;
}
#
endif
nsIFrame
*
inflowChild
=
childFrame
;
if
(
childFrame
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
{
inflowChild
=
childFrame
-
>
GetPlaceholderFrame
(
)
;
NS_ASSERTION
(
inflowChild
"
No
placeholder
for
out
-
of
-
flow
?
"
)
;
}
nsContainerFrame
*
containingBlock
=
GetFloatContainingBlock
(
inflowChild
-
>
GetParent
(
)
)
;
bool
haveFLS
=
containingBlock
&
&
HasFirstLetterStyle
(
containingBlock
)
;
if
(
haveFLS
)
{
#
ifdef
NOISY_FIRST_LETTER
printf
(
"
ContentRemoved
:
containingBlock
=
"
)
;
nsFrame
:
:
ListTag
(
stdout
containingBlock
)
;
printf
(
"
parentFrame
=
"
)
;
nsFrame
:
:
ListTag
(
stdout
parentFrame
)
;
printf
(
"
childFrame
=
"
)
;
nsFrame
:
:
ListTag
(
stdout
childFrame
)
;
printf
(
"
\
n
"
)
;
#
endif
RemoveLetterFrames
(
mPresShell
containingBlock
)
;
childFrame
=
aChild
-
>
GetPrimaryFrame
(
)
;
if
(
!
childFrame
|
|
childFrame
-
>
GetContent
(
)
!
=
aChild
)
{
return
false
;
}
parentFrame
=
childFrame
-
>
GetParent
(
)
;
parentType
=
parentFrame
-
>
Type
(
)
;
#
ifdef
NOISY_FIRST_LETTER
printf
(
"
=
=
>
revised
parentFrame
=
"
)
;
nsFrame
:
:
ListTag
(
stdout
parentFrame
)
;
printf
(
"
childFrame
=
"
)
;
nsFrame
:
:
ListTag
(
stdout
childFrame
)
;
printf
(
"
\
n
"
)
;
#
endif
}
#
ifdef
DEBUG
if
(
gReallyNoisyContentUpdates
)
{
printf
(
"
nsCSSFrameConstructor
:
:
ContentRemoved
:
childFrame
=
"
)
;
nsFrame
:
:
ListTag
(
stdout
childFrame
)
;
putchar
(
'
\
n
'
)
;
parentFrame
-
>
List
(
stdout
0
)
;
}
#
endif
if
(
childFrame
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
{
childFrame
=
childFrame
-
>
GetPlaceholderFrame
(
)
;
NS_ASSERTION
(
childFrame
"
Missing
placeholder
frame
for
out
of
flow
.
"
)
;
parentFrame
=
childFrame
-
>
GetParent
(
)
;
}
RemoveFrame
(
nsLayoutUtils
:
:
GetChildListNameFor
(
childFrame
)
childFrame
)
;
if
(
isRoot
)
{
mRootElementFrame
=
nullptr
;
mRootElementStyleFrame
=
nullptr
;
mDocElementContainingBlock
=
nullptr
;
mPageSequenceFrame
=
nullptr
;
mHasRootAbsPosContainingBlock
=
false
;
}
if
(
haveFLS
&
&
mRootElementFrame
)
{
RecoverLetterFrames
(
containingBlock
)
;
}
if
(
aOldNextSibling
&
&
aFlags
=
=
REMOVE_CONTENT
&
&
GetParentType
(
parentType
)
=
=
eTypeBlock
)
{
MOZ_ASSERT
(
aChild
-
>
GetParentNode
(
)
"
How
did
we
have
a
sibling
without
a
parent
?
"
)
;
nsIContent
*
prevSibling
=
aOldNextSibling
-
>
GetPreviousSibling
(
)
;
if
(
prevSibling
&
&
prevSibling
-
>
GetPreviousSibling
(
)
)
{
LAYOUT_PHASE_TEMP_EXIT
(
)
;
ReframeTextIfNeeded
(
prevSibling
)
;
LAYOUT_PHASE_TEMP_REENTER
(
)
;
}
if
(
aOldNextSibling
-
>
GetNextSibling
(
)
&
&
aOldNextSibling
-
>
GetPreviousSibling
(
)
)
{
LAYOUT_PHASE_TEMP_EXIT
(
)
;
ReframeTextIfNeeded
(
aOldNextSibling
)
;
LAYOUT_PHASE_TEMP_REENTER
(
)
;
}
}
#
ifdef
DEBUG
if
(
gReallyNoisyContentUpdates
&
&
parentFrame
)
{
printf
(
"
nsCSSFrameConstructor
:
:
ContentRemoved
:
resulting
frame
model
:
\
n
"
)
;
parentFrame
-
>
List
(
stdout
0
)
;
}
#
endif
}
return
false
;
}
static
void
InvalidateCanvasIfNeeded
(
nsIPresShell
*
presShell
nsIContent
*
node
)
{
MOZ_ASSERT
(
presShell
-
>
GetRootFrame
(
)
"
What
happened
here
?
"
)
;
MOZ_ASSERT
(
presShell
-
>
GetPresContext
(
)
"
Say
what
?
"
)
;
nsIContent
*
parent
=
node
-
>
GetParent
(
)
;
if
(
parent
)
{
nsIContent
*
grandParent
=
parent
-
>
GetParent
(
)
;
if
(
grandParent
)
{
return
;
}
if
(
!
node
-
>
IsHTMLElement
(
nsGkAtoms
:
:
body
)
)
{
return
;
}
}
nsIFrame
*
rootFrame
=
presShell
-
>
GetRootFrame
(
)
;
rootFrame
-
>
InvalidateFrameSubtree
(
)
;
}
bool
nsCSSFrameConstructor
:
:
EnsureFrameForTextNodeIsCreatedAfterFlush
(
CharacterData
*
aContent
)
{
if
(
!
aContent
-
>
HasFlag
(
NS_CREATE_FRAME_IF_NON_WHITESPACE
)
)
{
return
false
;
}
if
(
mAlwaysCreateFramesForIgnorableWhitespace
)
{
return
false
;
}
mAlwaysCreateFramesForIgnorableWhitespace
=
true
;
Element
*
root
=
mDocument
-
>
GetRootElement
(
)
;
if
(
!
root
)
{
return
false
;
}
RestyleManager
(
)
-
>
PostRestyleEvent
(
root
nsRestyleHint
(
0
)
nsChangeHint_ReconstructFrame
)
;
return
true
;
}
void
nsCSSFrameConstructor
:
:
CharacterDataChanged
(
nsIContent
*
aContent
const
CharacterDataChangeInfo
&
aInfo
)
{
AUTO_LAYOUT_PHASE_ENTRY_POINT
(
mPresShell
-
>
GetPresContext
(
)
FrameC
)
;
if
(
(
aContent
-
>
HasFlag
(
NS_CREATE_FRAME_IF_NON_WHITESPACE
)
&
&
!
aContent
-
>
TextIsOnlyWhitespace
(
)
)
|
|
(
aContent
-
>
HasFlag
(
NS_REFRAME_IF_WHITESPACE
)
&
&
aContent
-
>
TextIsOnlyWhitespace
(
)
)
)
{
#
ifdef
DEBUG
nsIFrame
*
frame
=
aContent
-
>
GetPrimaryFrame
(
)
;
NS_ASSERTION
(
!
frame
|
|
!
frame
-
>
IsGeneratedContentFrame
(
)
"
Bit
should
never
be
set
on
generated
content
"
)
;
#
endif
LAYOUT_PHASE_TEMP_EXIT
(
)
;
RecreateFramesForContent
(
aContent
InsertionKind
:
:
Async
)
;
LAYOUT_PHASE_TEMP_REENTER
(
)
;
return
;
}
if
(
nsIFrame
*
frame
=
aContent
-
>
GetPrimaryFrame
(
)
)
{
#
if
0
NS_FRAME_LOG
(
NS_FRAME_TRACE_CALLS
(
"
nsCSSFrameConstructor
:
:
CharacterDataChanged
:
content
=
%
p
[
%
s
]
subcontent
=
%
p
frame
=
%
p
"
aContent
ContentTag
(
aContent
0
)
aSubContent
frame
)
)
;
#
endif
nsContainerFrame
*
block
=
GetFloatContainingBlock
(
frame
)
;
bool
haveFirstLetterStyle
=
false
;
if
(
block
)
{
haveFirstLetterStyle
=
HasFirstLetterStyle
(
block
)
;
if
(
haveFirstLetterStyle
)
{
RemoveLetterFrames
(
mPresShell
block
)
;
frame
=
aContent
-
>
GetPrimaryFrame
(
)
;
NS_ASSERTION
(
frame
"
Should
have
frame
here
!
"
)
;
}
}
frame
-
>
CharacterDataChanged
(
aInfo
)
;
if
(
haveFirstLetterStyle
)
{
RecoverLetterFrames
(
block
)
;
}
}
}
void
nsCSSFrameConstructor
:
:
RecalcQuotesAndCounters
(
)
{
nsAutoScriptBlocker
scriptBlocker
;
if
(
mQuotesDirty
)
{
mQuotesDirty
=
false
;
mQuoteList
.
RecalcAll
(
)
;
}
if
(
mCountersDirty
)
{
mCountersDirty
=
false
;
mCounterManager
.
RecalcAll
(
)
;
}
NS_ASSERTION
(
!
mQuotesDirty
"
Quotes
updates
will
be
lost
"
)
;
NS_ASSERTION
(
!
mCountersDirty
"
Counter
updates
will
be
lost
"
)
;
}
void
nsCSSFrameConstructor
:
:
NotifyCounterStylesAreDirty
(
)
{
mCounterManager
.
SetAllDirty
(
)
;
CountersDirty
(
)
;
}
void
nsCSSFrameConstructor
:
:
WillDestroyFrameTree
(
)
{
#
if
defined
(
DEBUG_dbaron_off
)
mCounterManager
.
Dump
(
)
;
#
endif
mIsDestroyingFrameTree
=
true
;
mQuoteList
.
Clear
(
)
;
mCounterManager
.
Clear
(
)
;
nsFrameManager
:
:
Destroy
(
)
;
}
void
nsCSSFrameConstructor
:
:
GetAlternateTextFor
(
Element
*
aElement
nsAtom
*
aTag
nsAString
&
aAltText
)
{
if
(
aElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
alt
aAltText
)
)
{
return
;
}
if
(
nsGkAtoms
:
:
input
=
=
aTag
)
{
if
(
aElement
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
value
aAltText
)
)
{
return
;
}
nsContentUtils
:
:
GetLocalizedString
(
nsContentUtils
:
:
eFORMS_PROPERTIES
"
Submit
"
aAltText
)
;
}
}
nsIFrame
*
nsCSSFrameConstructor
:
:
CreateContinuingOuterTableFrame
(
nsIPresShell
*
aPresShell
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
nsContainerFrame
*
aParentFrame
nsIContent
*
aContent
ComputedStyle
*
aComputedStyle
)
{
nsTableWrapperFrame
*
newFrame
=
NS_NewTableWrapperFrame
(
aPresShell
aComputedStyle
)
;
newFrame
-
>
Init
(
aContent
aParentFrame
aFrame
)
;
nsFrameItems
newChildFrames
;
nsIFrame
*
childFrame
=
aFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
childFrame
)
{
nsIFrame
*
continuingTableFrame
=
CreateContinuingFrame
(
aPresContext
childFrame
newFrame
)
;
newChildFrames
.
AddChild
(
continuingTableFrame
)
;
NS_ASSERTION
(
!
childFrame
-
>
GetNextSibling
(
)
"
there
can
be
only
one
inner
table
frame
"
)
;
}
newFrame
-
>
SetInitialChildList
(
kPrincipalList
newChildFrames
)
;
return
newFrame
;
}
nsIFrame
*
nsCSSFrameConstructor
:
:
CreateContinuingTableFrame
(
nsIPresShell
*
aPresShell
nsIFrame
*
aFrame
nsContainerFrame
*
aParentFrame
nsIContent
*
aContent
ComputedStyle
*
aComputedStyle
)
{
nsTableFrame
*
newFrame
=
NS_NewTableFrame
(
aPresShell
aComputedStyle
)
;
newFrame
-
>
Init
(
aContent
aParentFrame
aFrame
)
;
nsFrameItems
childFrames
;
for
(
nsIFrame
*
childFrame
:
aFrame
-
>
PrincipalChildList
(
)
)
{
nsTableRowGroupFrame
*
rowGroupFrame
=
static_cast
<
nsTableRowGroupFrame
*
>
(
childFrame
)
;
nsIFrame
*
rgNextInFlow
=
rowGroupFrame
-
>
GetNextInFlow
(
)
;
if
(
rgNextInFlow
)
{
rowGroupFrame
-
>
SetRepeatable
(
false
)
;
}
else
if
(
rowGroupFrame
-
>
IsRepeatable
(
)
)
{
nsTableRowGroupFrame
*
headerFooterFrame
;
nsFrameItems
childItems
;
nsFrameConstructorState
state
(
mPresShell
GetAbsoluteContainingBlock
(
newFrame
FIXED_POS
)
GetAbsoluteContainingBlock
(
newFrame
ABS_POS
)
nullptr
)
;
state
.
mCreatingExtraFrames
=
true
;
ComputedStyle
*
const
headerFooterComputedStyle
=
rowGroupFrame
-
>
Style
(
)
;
headerFooterFrame
=
static_cast
<
nsTableRowGroupFrame
*
>
(
NS_NewTableRowGroupFrame
(
aPresShell
headerFooterComputedStyle
)
)
;
nsIContent
*
headerFooter
=
rowGroupFrame
-
>
GetContent
(
)
;
headerFooterFrame
-
>
Init
(
headerFooter
newFrame
nullptr
)
;
nsFrameConstructorSaveState
absoluteSaveState
;
MakeTablePartAbsoluteContainingBlockIfNeeded
(
state
headerFooterComputedStyle
-
>
StyleDisplay
(
)
absoluteSaveState
headerFooterFrame
)
;
ProcessChildren
(
state
headerFooter
rowGroupFrame
-
>
Style
(
)
headerFooterFrame
true
childItems
false
nullptr
)
;
NS_ASSERTION
(
state
.
mFloatedItems
.
IsEmpty
(
)
"
unexpected
floated
element
"
)
;
headerFooterFrame
-
>
SetInitialChildList
(
kPrincipalList
childItems
)
;
headerFooterFrame
-
>
SetRepeatable
(
true
)
;
headerFooterFrame
-
>
InitRepeatedFrame
(
rowGroupFrame
)
;
childFrames
.
AddChild
(
headerFooterFrame
)
;
}
}
newFrame
-
>
SetInitialChildList
(
kPrincipalList
childFrames
)
;
return
newFrame
;
}
nsIFrame
*
nsCSSFrameConstructor
:
:
CreateContinuingFrame
(
nsPresContext
*
aPresContext
nsIFrame
*
aFrame
nsContainerFrame
*
aParentFrame
bool
aIsFluid
)
{
nsIPresShell
*
shell
=
aPresContext
-
>
PresShell
(
)
;
ComputedStyle
*
computedStyle
=
aFrame
-
>
Style
(
)
;
nsIFrame
*
newFrame
=
nullptr
;
nsIFrame
*
nextContinuation
=
aFrame
-
>
GetNextContinuation
(
)
;
nsIFrame
*
nextInFlow
=
aFrame
-
>
GetNextInFlow
(
)
;
LayoutFrameType
frameType
=
aFrame
-
>
Type
(
)
;
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
NS_ASSERTION
(
aFrame
-
>
GetSplittableType
(
)
!
=
NS_FRAME_NOT_SPLITTABLE
"
why
CreateContinuingFrame
for
a
non
-
splittable
frame
?
"
)
;
if
(
LayoutFrameType
:
:
Text
=
=
frameType
)
{
newFrame
=
NS_NewContinuingTextFrame
(
shell
computedStyle
)
;
newFrame
-
>
Init
(
content
aParentFrame
aFrame
)
;
}
else
if
(
LayoutFrameType
:
:
Inline
=
=
frameType
)
{
newFrame
=
NS_NewInlineFrame
(
shell
computedStyle
)
;
newFrame
-
>
Init
(
content
aParentFrame
aFrame
)
;
}
else
if
(
LayoutFrameType
:
:
Block
=
=
frameType
)
{
MOZ_ASSERT
(
!
aFrame
-
>
IsTableCaption
(
)
"
no
support
for
fragmenting
table
captions
yet
"
)
;
newFrame
=
NS_NewBlockFrame
(
shell
computedStyle
)
;
newFrame
-
>
Init
(
content
aParentFrame
aFrame
)
;
#
ifdef
MOZ_XUL
}
else
if
(
LayoutFrameType
:
:
XULLabel
=
=
frameType
)
{
newFrame
=
NS_NewXULLabelFrame
(
shell
computedStyle
)
;
newFrame
-
>
Init
(
content
aParentFrame
aFrame
)
;
#
endif
}
else
if
(
LayoutFrameType
:
:
ColumnSet
=
=
frameType
)
{
MOZ_ASSERT
(
!
aFrame
-
>
IsTableCaption
(
)
"
no
support
for
fragmenting
table
captions
yet
"
)
;
newFrame
=
NS_NewColumnSetFrame
(
shell
computedStyle
nsFrameState
(
0
)
)
;
newFrame
-
>
Init
(
content
aParentFrame
aFrame
)
;
}
else
if
(
LayoutFrameType
:
:
Page
=
=
frameType
)
{
nsContainerFrame
*
canvasFrame
;
newFrame
=
ConstructPageFrame
(
shell
aParentFrame
aFrame
canvasFrame
)
;
}
else
if
(
LayoutFrameType
:
:
TableWrapper
=
=
frameType
)
{
newFrame
=
CreateContinuingOuterTableFrame
(
shell
aPresContext
aFrame
aParentFrame
content
computedStyle
)
;
}
else
if
(
LayoutFrameType
:
:
Table
=
=
frameType
)
{
newFrame
=
CreateContinuingTableFrame
(
shell
aFrame
aParentFrame
content
computedStyle
)
;
}
else
if
(
LayoutFrameType
:
:
TableRowGroup
=
=
frameType
)
{
newFrame
=
NS_NewTableRowGroupFrame
(
shell
computedStyle
)
;
newFrame
-
>
Init
(
content
aParentFrame
aFrame
)
;
if
(
newFrame
-
>
GetStateBits
(
)
&
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
{
nsTableFrame
:
:
RegisterPositionedTablePart
(
newFrame
)
;
}
}
else
if
(
LayoutFrameType
:
:
TableRow
=
=
frameType
)
{
nsTableRowFrame
*
rowFrame
=
NS_NewTableRowFrame
(
shell
computedStyle
)
;
rowFrame
-
>
Init
(
content
aParentFrame
aFrame
)
;
if
(
rowFrame
-
>
GetStateBits
(
)
&
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
{
nsTableFrame
:
:
RegisterPositionedTablePart
(
rowFrame
)
;
}
nsFrameItems
newChildList
;
nsIFrame
*
cellFrame
=
aFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
while
(
cellFrame
)
{
if
(
IS_TABLE_CELL
(
cellFrame
-
>
Type
(
)
)
)
{
nsIFrame
*
continuingCellFrame
=
CreateContinuingFrame
(
aPresContext
cellFrame
rowFrame
)
;
newChildList
.
AddChild
(
continuingCellFrame
)
;
}
cellFrame
=
cellFrame
-
>
GetNextSibling
(
)
;
}
rowFrame
-
>
SetInitialChildList
(
kPrincipalList
newChildList
)
;
newFrame
=
rowFrame
;
}
else
if
(
IS_TABLE_CELL
(
frameType
)
)
{
nsTableFrame
*
tableFrame
=
static_cast
<
nsTableRowFrame
*
>
(
aParentFrame
)
-
>
GetTableFrame
(
)
;
nsTableCellFrame
*
cellFrame
=
NS_NewTableCellFrame
(
shell
computedStyle
tableFrame
)
;
cellFrame
-
>
Init
(
content
aParentFrame
aFrame
)
;
if
(
cellFrame
-
>
GetStateBits
(
)
&
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
{
nsTableFrame
:
:
RegisterPositionedTablePart
(
cellFrame
)
;
}
nsIFrame
*
blockFrame
=
aFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
nsIFrame
*
continuingBlockFrame
=
CreateContinuingFrame
(
aPresContext
blockFrame
static_cast
<
nsContainerFrame
*
>
(
cellFrame
)
)
;
SetInitialSingleChild
(
cellFrame
continuingBlockFrame
)
;
newFrame
=
cellFrame
;
}
else
if
(
LayoutFrameType
:
:
Line
=
=
frameType
)
{
newFrame
=
NS_NewFirstLineFrame
(
shell
computedStyle
)
;
newFrame
-
>
Init
(
content
aParentFrame
aFrame
)
;
}
else
if
(
LayoutFrameType
:
:
Letter
=
=
frameType
)
{
newFrame
=
NS_NewFirstLetterFrame
(
shell
computedStyle
)
;
newFrame
-
>
Init
(
content
aParentFrame
aFrame
)
;
}
else
if
(
LayoutFrameType
:
:
Image
=
=
frameType
)
{
newFrame
=
NS_NewImageFrame
(
shell
computedStyle
)
;
newFrame
-
>
Init
(
content
aParentFrame
aFrame
)
;
}
else
if
(
LayoutFrameType
:
:
ImageControl
=
=
frameType
)
{
newFrame
=
NS_NewImageControlFrame
(
shell
computedStyle
)
;
newFrame
-
>
Init
(
content
aParentFrame
aFrame
)
;
}
else
if
(
LayoutFrameType
:
:
Placeholder
=
=
frameType
)
{
nsIFrame
*
oofFrame
=
nsPlaceholderFrame
:
:
GetRealFrameForPlaceholder
(
aFrame
)
;
nsIFrame
*
oofContFrame
=
CreateContinuingFrame
(
aPresContext
oofFrame
aParentFrame
)
;
newFrame
=
CreatePlaceholderFrameFor
(
shell
content
oofContFrame
aParentFrame
aFrame
aFrame
-
>
GetStateBits
(
)
&
PLACEHOLDER_TYPE_MASK
)
;
}
else
if
(
LayoutFrameType
:
:
FieldSet
=
=
frameType
)
{
nsContainerFrame
*
fieldset
=
NS_NewFieldSetFrame
(
shell
computedStyle
)
;
fieldset
-
>
Init
(
content
aParentFrame
aFrame
)
;
nsContainerFrame
*
blockFrame
=
GetFieldSetBlockFrame
(
aFrame
)
;
if
(
blockFrame
)
{
nsIFrame
*
continuingBlockFrame
=
CreateContinuingFrame
(
aPresContext
blockFrame
fieldset
)
;
SetInitialSingleChild
(
fieldset
continuingBlockFrame
)
;
}
else
{
MOZ_ASSERT
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_IS_OVERFLOW_CONTAINER
"
FieldSet
block
may
only
be
null
for
overflow
containers
"
)
;
}
newFrame
=
fieldset
;
}
else
if
(
LayoutFrameType
:
:
Legend
=
=
frameType
)
{
newFrame
=
NS_NewLegendFrame
(
shell
computedStyle
)
;
newFrame
-
>
Init
(
content
aParentFrame
aFrame
)
;
}
else
if
(
LayoutFrameType
:
:
FlexContainer
=
=
frameType
)
{
newFrame
=
NS_NewFlexContainerFrame
(
shell
computedStyle
)
;
newFrame
-
>
Init
(
content
aParentFrame
aFrame
)
;
}
else
if
(
LayoutFrameType
:
:
GridContainer
=
=
frameType
)
{
newFrame
=
NS_NewGridContainerFrame
(
shell
computedStyle
)
;
newFrame
-
>
Init
(
content
aParentFrame
aFrame
)
;
}
else
if
(
LayoutFrameType
:
:
Ruby
=
=
frameType
)
{
newFrame
=
NS_NewRubyFrame
(
shell
computedStyle
)
;
newFrame
-
>
Init
(
content
aParentFrame
aFrame
)
;
}
else
if
(
LayoutFrameType
:
:
RubyBaseContainer
=
=
frameType
)
{
newFrame
=
NS_NewRubyBaseContainerFrame
(
shell
computedStyle
)
;
newFrame
-
>
Init
(
content
aParentFrame
aFrame
)
;
}
else
if
(
LayoutFrameType
:
:
RubyTextContainer
=
=
frameType
)
{
newFrame
=
NS_NewRubyTextContainerFrame
(
shell
computedStyle
)
;
newFrame
-
>
Init
(
content
aParentFrame
aFrame
)
;
}
else
if
(
LayoutFrameType
:
:
Details
=
=
frameType
)
{
newFrame
=
NS_NewDetailsFrame
(
shell
computedStyle
)
;
newFrame
-
>
Init
(
content
aParentFrame
aFrame
)
;
}
else
{
MOZ_CRASH
(
"
unexpected
frame
type
"
)
;
}
if
(
!
aIsFluid
)
{
newFrame
-
>
SetPrevContinuation
(
aFrame
)
;
}
if
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_GENERATED_CONTENT
)
{
newFrame
-
>
AddStateBits
(
NS_FRAME_GENERATED_CONTENT
)
;
}
if
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_ANONYMOUSCONTENTCREATOR_CONTENT
)
{
newFrame
-
>
AddStateBits
(
NS_FRAME_ANONYMOUSCONTENTCREATOR_CONTENT
)
;
}
if
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
{
newFrame
-
>
AddStateBits
(
NS_FRAME_OUT_OF_FLOW
)
;
}
if
(
nextInFlow
)
{
nextInFlow
-
>
SetPrevInFlow
(
newFrame
)
;
newFrame
-
>
SetNextInFlow
(
nextInFlow
)
;
}
else
if
(
nextContinuation
)
{
nextContinuation
-
>
SetPrevContinuation
(
newFrame
)
;
newFrame
-
>
SetNextContinuation
(
nextContinuation
)
;
}
MOZ_ASSERT
(
!
newFrame
-
>
GetNextSibling
(
)
"
unexpected
sibling
"
)
;
return
newFrame
;
}
nsresult
nsCSSFrameConstructor
:
:
ReplicateFixedFrames
(
nsPageContentFrame
*
aParentFrame
)
{
nsIFrame
*
prevPageContentFrame
=
aParentFrame
-
>
GetPrevInFlow
(
)
;
if
(
!
prevPageContentFrame
)
{
return
NS_OK
;
}
nsContainerFrame
*
canvasFrame
=
do_QueryFrame
(
aParentFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
)
;
nsIFrame
*
prevCanvasFrame
=
prevPageContentFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
!
canvasFrame
|
|
!
prevCanvasFrame
)
{
return
NS_ERROR_UNEXPECTED
;
}
nsFrameItems
fixedPlaceholders
;
nsIFrame
*
firstFixed
=
prevPageContentFrame
-
>
GetChildList
(
nsIFrame
:
:
kFixedList
)
.
FirstChild
(
)
;
if
(
!
firstFixed
)
{
return
NS_OK
;
}
nsFrameConstructorState
state
(
mPresShell
aParentFrame
nullptr
mRootElementFrame
)
;
state
.
mCreatingExtraFrames
=
true
;
for
(
nsIFrame
*
fixed
=
firstFixed
;
fixed
;
fixed
=
fixed
-
>
GetNextSibling
(
)
)
{
nsIFrame
*
prevPlaceholder
=
fixed
-
>
GetPlaceholderFrame
(
)
;
if
(
prevPlaceholder
&
&
nsLayoutUtils
:
:
IsProperAncestorFrame
(
prevCanvasFrame
prevPlaceholder
)
)
{
nsIContent
*
content
=
fixed
-
>
GetContent
(
)
;
ComputedStyle
*
computedStyle
=
nsLayoutUtils
:
:
GetStyleFrame
(
content
)
-
>
Style
(
)
;
AutoFrameConstructionItemList
items
(
this
)
;
AddFrameConstructionItemsInternal
(
state
content
canvasFrame
true
computedStyle
ITEM_ALLOW_XBL_BASE
|
ITEM_ALLOW_PAGE_BREAK
nullptr
items
)
;
ConstructFramesFromItemList
(
state
items
canvasFrame
false
fixedPlaceholders
)
;
}
}
NS_ASSERTION
(
!
canvasFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
"
leaking
frames
;
doc
root
continuation
must
be
empty
"
)
;
canvasFrame
-
>
SetInitialChildList
(
kPrincipalList
fixedPlaceholders
)
;
return
NS_OK
;
}
nsCSSFrameConstructor
:
:
InsertionPoint
nsCSSFrameConstructor
:
:
GetInsertionPoint
(
nsIContent
*
aChild
)
{
MOZ_ASSERT
(
aChild
)
;
nsIContent
*
insertionElement
=
aChild
-
>
GetFlattenedTreeParent
(
)
;
if
(
!
insertionElement
)
{
return
{
}
;
}
return
{
GetContentInsertionFrameFor
(
insertionElement
)
insertionElement
}
;
}
void
nsCSSFrameConstructor
:
:
CaptureStateForFramesOf
(
nsIContent
*
aContent
nsILayoutHistoryState
*
aHistoryState
)
{
if
(
!
aHistoryState
)
{
return
;
}
nsIFrame
*
frame
=
aContent
-
>
GetPrimaryFrame
(
)
;
if
(
frame
=
=
mRootElementFrame
)
{
frame
=
mRootElementFrame
?
GetAbsoluteContainingBlock
(
mRootElementFrame
FIXED_POS
)
:
GetRootFrame
(
)
;
}
for
(
;
frame
;
frame
=
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
frame
)
)
{
CaptureFrameState
(
frame
aHistoryState
)
;
}
}
static
bool
IsWhitespaceFrame
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
"
invalid
argument
"
)
;
return
aFrame
-
>
IsTextFrame
(
)
&
&
aFrame
-
>
GetContent
(
)
-
>
TextIsOnlyWhitespace
(
)
;
}
static
nsIFrame
*
FindFirstNonWhitespaceChild
(
nsIFrame
*
aParentFrame
)
{
nsIFrame
*
f
=
aParentFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
while
(
f
&
&
IsWhitespaceFrame
(
f
)
)
{
f
=
f
-
>
GetNextSibling
(
)
;
}
return
f
;
}
static
nsIFrame
*
FindNextNonWhitespaceSibling
(
nsIFrame
*
aFrame
)
{
nsIFrame
*
f
=
aFrame
;
do
{
f
=
f
-
>
GetNextSibling
(
)
;
}
while
(
f
&
&
IsWhitespaceFrame
(
f
)
)
;
return
f
;
}
static
nsIFrame
*
FindPreviousNonWhitespaceSibling
(
nsIFrame
*
aFrame
)
{
nsIFrame
*
f
=
aFrame
;
do
{
f
=
f
-
>
GetPrevSibling
(
)
;
}
while
(
f
&
&
IsWhitespaceFrame
(
f
)
)
;
return
f
;
}
bool
nsCSSFrameConstructor
:
:
MaybeRecreateContainerForFrameRemoval
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
"
Must
have
a
frame
"
)
;
MOZ_ASSERT
(
aFrame
-
>
GetParent
(
)
"
Frame
shouldn
'
t
be
root
"
)
;
MOZ_ASSERT
(
aFrame
=
=
aFrame
-
>
FirstContinuation
(
)
"
aFrame
not
the
result
of
GetPrimaryFrame
(
)
?
"
)
;
if
(
IsFramePartOfIBSplit
(
aFrame
)
)
{
#
ifdef
DEBUG
if
(
gNoisyContentUpdates
)
{
printf
(
"
nsCSSFrameConstructor
:
:
MaybeRecreateContainerForFrameRemoval
:
"
"
frame
=
"
)
;
nsFrame
:
:
ListTag
(
stdout
aFrame
)
;
printf
(
"
is
ib
-
split
\
n
"
)
;
}
#
endif
ReframeContainingBlock
(
aFrame
)
;
return
true
;
}
nsContainerFrame
*
insertionFrame
=
aFrame
-
>
GetContentInsertionFrame
(
)
;
if
(
insertionFrame
&
&
insertionFrame
-
>
IsLegendFrame
(
)
&
&
aFrame
-
>
GetParent
(
)
-
>
IsFieldSetFrame
(
)
)
{
RecreateFramesForContent
(
aFrame
-
>
GetParent
(
)
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
return
true
;
}
nsIFrame
*
inFlowFrame
=
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_OUT_OF_FLOW
)
?
aFrame
-
>
GetPlaceholderFrame
(
)
:
aFrame
;
MOZ_ASSERT
(
inFlowFrame
"
How
did
that
happen
?
"
)
;
MOZ_ASSERT
(
inFlowFrame
=
=
inFlowFrame
-
>
FirstContinuation
(
)
"
placeholder
for
primary
frame
has
previous
continuations
?
"
)
;
nsIFrame
*
parent
=
inFlowFrame
-
>
GetParent
(
)
;
if
(
parent
&
&
parent
-
>
IsDetailsFrame
(
)
)
{
HTMLSummaryElement
*
summary
=
HTMLSummaryElement
:
:
FromNode
(
aFrame
-
>
GetContent
(
)
)
;
DetailsFrame
*
detailsFrame
=
static_cast
<
DetailsFrame
*
>
(
parent
)
;
if
(
summary
&
&
detailsFrame
-
>
HasMainSummaryFrame
(
aFrame
)
)
{
RecreateFramesForContent
(
parent
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
return
true
;
}
}
if
(
IsTableOrRubyPseudo
(
parent
)
)
{
if
(
FindFirstNonWhitespaceChild
(
parent
)
=
=
inFlowFrame
|
|
!
FindNextNonWhitespaceSibling
(
inFlowFrame
-
>
LastContinuation
(
)
)
|
|
(
IsWhitespaceFrame
(
aFrame
)
&
&
parent
-
>
PrincipalChildList
(
)
.
OnlyChild
(
)
)
|
|
(
inFlowFrame
-
>
IsTableColGroupFrame
(
)
&
&
parent
-
>
GetChildList
(
nsIFrame
:
:
kColGroupList
)
.
FirstChild
(
)
=
=
inFlowFrame
)
|
|
(
inFlowFrame
-
>
IsTableCaption
(
)
&
&
parent
-
>
GetChildList
(
nsIFrame
:
:
kCaptionList
)
.
FirstChild
(
)
=
=
inFlowFrame
)
)
{
RecreateFramesForContent
(
parent
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
return
true
;
}
}
nsIFrame
*
nextSibling
=
FindNextNonWhitespaceSibling
(
inFlowFrame
-
>
LastContinuation
(
)
)
;
NS_ASSERTION
(
!
IsTableOrRubyPseudo
(
inFlowFrame
)
"
Shouldn
'
t
happen
here
"
)
;
if
(
nextSibling
&
&
IsTableOrRubyPseudo
(
nextSibling
)
)
{
nsIFrame
*
prevSibling
=
FindPreviousNonWhitespaceSibling
(
inFlowFrame
)
;
if
(
prevSibling
&
&
IsTableOrRubyPseudo
(
prevSibling
)
)
{
#
ifdef
DEBUG
if
(
gNoisyContentUpdates
)
{
printf
(
"
nsCSSFrameConstructor
:
:
MaybeRecreateContainerForFrameRemoval
:
"
"
frame
=
"
)
;
nsFrame
:
:
ListTag
(
stdout
aFrame
)
;
printf
(
"
has
a
table
pseudo
next
sibling
of
different
type
and
a
"
"
table
pseudo
prevsibling
\
n
"
)
;
}
#
endif
RecreateFramesForContent
(
parent
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
return
true
;
}
}
LayoutFrameType
parentType
=
parent
-
>
Type
(
)
;
if
(
parentType
=
=
LayoutFrameType
:
:
Ruby
|
|
RubyUtils
:
:
IsRubyContainerBox
(
parentType
)
)
{
RecreateFramesForContent
(
parent
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
return
true
;
}
if
(
nextSibling
&
&
IsAnonymousFlexOrGridItem
(
nextSibling
)
)
{
AssertAnonymousFlexOrGridItemParent
(
nextSibling
parent
)
;
#
ifdef
DEBUG
if
(
gNoisyContentUpdates
)
{
printf
(
"
nsCSSFrameConstructor
:
:
MaybeRecreateContainerForFrameRemoval
:
"
"
frame
=
"
)
;
nsFrame
:
:
ListTag
(
stdout
aFrame
)
;
printf
(
"
has
an
anonymous
flex
item
as
its
next
sibling
\
n
"
)
;
}
#
endif
RecreateFramesForContent
(
parent
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
return
true
;
}
if
(
!
nextSibling
&
&
IsAnonymousFlexOrGridItem
(
parent
)
)
{
AssertAnonymousFlexOrGridItemParent
(
parent
parent
-
>
GetParent
(
)
)
;
#
ifdef
DEBUG
if
(
gNoisyContentUpdates
)
{
printf
(
"
nsCSSFrameConstructor
:
:
MaybeRecreateContainerForFrameRemoval
:
"
"
frame
=
"
)
;
nsFrame
:
:
ListTag
(
stdout
aFrame
)
;
printf
(
"
has
an
anonymous
flex
item
as
its
parent
\
n
"
)
;
}
#
endif
RecreateFramesForContent
(
parent
-
>
GetParent
(
)
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
return
true
;
}
#
ifdef
MOZ_XUL
if
(
aFrame
-
>
IsPopupSetFrame
(
)
)
{
nsIRootBox
*
rootBox
=
nsIRootBox
:
:
GetRootBox
(
mPresShell
)
;
if
(
rootBox
&
&
rootBox
-
>
GetPopupSetFrame
(
)
=
=
aFrame
)
{
ReconstructDocElementHierarchy
(
InsertionKind
:
:
Async
)
;
return
true
;
}
}
#
endif
if
(
!
inFlowFrame
-
>
GetPrevSibling
(
)
&
&
!
inFlowFrame
-
>
GetNextSibling
(
)
&
&
(
(
parent
-
>
GetPrevContinuation
(
)
&
&
!
parent
-
>
GetPrevInFlow
(
)
)
|
|
(
parent
-
>
GetNextContinuation
(
)
&
&
!
parent
-
>
GetNextInFlow
(
)
)
)
)
{
RecreateFramesForContent
(
parent
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
return
true
;
}
if
(
!
IsFramePartOfIBSplit
(
parent
)
)
{
return
false
;
}
if
(
inFlowFrame
!
=
parent
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
|
|
inFlowFrame
-
>
LastContinuation
(
)
-
>
GetNextSibling
(
)
)
{
return
false
;
}
nsIFrame
*
parentFirstContinuation
=
parent
-
>
FirstContinuation
(
)
;
if
(
!
GetIBSplitSibling
(
parentFirstContinuation
)
|
|
!
GetIBSplitPrevSibling
(
parentFirstContinuation
)
)
{
return
false
;
}
#
ifdef
DEBUG
if
(
gNoisyContentUpdates
)
{
printf
(
"
nsCSSFrameConstructor
:
:
MaybeRecreateContainerForFrameRemoval
:
"
"
frame
=
"
)
;
nsFrame
:
:
ListTag
(
stdout
parent
)
;
printf
(
"
is
ib
-
split
\
n
"
)
;
}
#
endif
ReframeContainingBlock
(
parent
)
;
return
true
;
}
void
nsCSSFrameConstructor
:
:
UpdateTableCellSpans
(
nsIContent
*
aContent
)
{
nsTableCellFrame
*
cellFrame
=
do_QueryFrame
(
aContent
-
>
GetPrimaryFrame
(
)
)
;
NS_WARNING_ASSERTION
(
cellFrame
"
Hint
should
only
be
posted
on
table
cells
!
"
)
;
if
(
cellFrame
)
{
cellFrame
-
>
GetTableFrame
(
)
-
>
RowOrColSpanChanged
(
cellFrame
)
;
}
}
static
nsIContent
*
GetTopmostMathMLElement
(
nsIContent
*
aMathMLContent
)
{
MOZ_ASSERT
(
aMathMLContent
-
>
IsMathMLElement
(
)
)
;
MOZ_ASSERT
(
aMathMLContent
-
>
GetPrimaryFrame
(
)
)
;
MOZ_ASSERT
(
aMathMLContent
-
>
GetPrimaryFrame
(
)
-
>
IsFrameOfType
(
nsIFrame
:
:
eMathML
)
)
;
nsIContent
*
root
=
aMathMLContent
;
for
(
nsIContent
*
parent
=
aMathMLContent
-
>
GetFlattenedTreeParent
(
)
;
parent
;
parent
=
parent
-
>
GetFlattenedTreeParent
(
)
)
{
nsIFrame
*
frame
=
parent
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
|
|
!
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eMathML
)
)
{
break
;
}
root
=
parent
;
}
return
root
;
}
void
nsCSSFrameConstructor
:
:
RecreateFramesForContent
(
nsIContent
*
aContent
InsertionKind
aInsertionKind
)
{
MOZ_ASSERT
(
aContent
)
;
if
(
NS_WARN_IF
(
!
aContent
-
>
GetComposedDoc
(
)
)
)
{
return
;
}
nsIFrame
*
frame
=
aContent
-
>
GetPrimaryFrame
(
)
;
if
(
frame
&
&
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eMathML
)
)
{
aContent
=
GetTopmostMathMLElement
(
aContent
)
;
frame
=
aContent
-
>
GetPrimaryFrame
(
)
;
}
if
(
frame
)
{
nsIFrame
*
nonGeneratedAncestor
=
nsLayoutUtils
:
:
GetNonGeneratedAncestor
(
frame
)
;
if
(
nonGeneratedAncestor
-
>
GetContent
(
)
!
=
aContent
)
{
return
RecreateFramesForContent
(
nonGeneratedAncestor
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
}
if
(
frame
-
>
GetStateBits
(
)
&
NS_FRAME_ANONYMOUSCONTENTCREATOR_CONTENT
)
{
nsIAnonymousContentCreator
*
acc
=
nullptr
;
nsIFrame
*
ancestor
=
nsLayoutUtils
:
:
GetParentOrPlaceholderFor
(
frame
)
;
while
(
!
(
acc
=
do_QueryFrame
(
ancestor
)
)
)
{
ancestor
=
nsLayoutUtils
:
:
GetParentOrPlaceholderFor
(
ancestor
)
;
}
NS_ASSERTION
(
acc
"
Where
is
the
nsIAnonymousContentCreator
?
We
may
fail
"
"
to
recreate
its
content
correctly
"
)
;
if
(
!
ancestor
-
>
IsSVGUseFrame
(
)
)
{
NS_ASSERTION
(
aContent
-
>
IsInNativeAnonymousSubtree
(
)
"
Why
is
NS_FRAME_ANONYMOUSCONTENTCREATOR_CONTENT
set
?
"
)
;
return
RecreateFramesForContent
(
ancestor
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
}
}
nsIFrame
*
parent
=
frame
-
>
GetParent
(
)
;
nsIContent
*
parentContent
=
parent
?
parent
-
>
GetContent
(
)
:
nullptr
;
if
(
parent
&
&
parent
-
>
IsLeaf
(
)
&
&
parentContent
&
&
parentContent
!
=
aContent
)
{
return
RecreateFramesForContent
(
parentContent
InsertionKind
:
:
Async
)
;
}
}
if
(
frame
&
&
MaybeRecreateContainerForFrameRemoval
(
frame
)
)
{
return
;
}
MOZ_ASSERT
(
aContent
-
>
GetParentNode
(
)
)
;
CaptureStateForFramesOf
(
aContent
mTempFrameTreeState
)
;
nsIContent
*
nextSibling
=
aContent
-
>
IsRootOfAnonymousSubtree
(
)
?
nullptr
:
aContent
-
>
GetNextSibling
(
)
;
bool
didReconstruct
=
ContentRemoved
(
aContent
nextSibling
REMOVE_FOR_RECONSTRUCTION
)
;
if
(
!
didReconstruct
)
{
if
(
aInsertionKind
=
=
InsertionKind
:
:
Async
&
&
aContent
-
>
IsElement
(
)
)
{
RestyleManager
(
)
-
>
PostRestyleEvent
(
aContent
-
>
AsElement
(
)
nsRestyleHint
(
0
)
nsChangeHint_ReconstructFrame
)
;
}
else
{
ContentRangeInserted
(
aContent
aContent
-
>
GetNextSibling
(
)
mTempFrameTreeState
aInsertionKind
)
;
}
}
}
bool
nsCSSFrameConstructor
:
:
DestroyFramesFor
(
Element
*
aElement
)
{
MOZ_ASSERT
(
aElement
&
&
aElement
-
>
GetParentNode
(
)
)
;
nsIContent
*
nextSibling
=
aElement
-
>
IsRootOfAnonymousSubtree
(
)
?
nullptr
:
aElement
-
>
GetNextSibling
(
)
;
CaptureStateForFramesOf
(
aElement
mTempFrameTreeState
)
;
return
ContentRemoved
(
aElement
nextSibling
REMOVE_FOR_RECONSTRUCTION
)
;
}
already_AddRefed
<
ComputedStyle
>
nsCSSFrameConstructor
:
:
GetFirstLetterStyle
(
nsIContent
*
aContent
ComputedStyle
*
aComputedStyle
)
{
if
(
aContent
)
{
return
mPresShell
-
>
StyleSet
(
)
-
>
ResolvePseudoElementStyle
(
aContent
-
>
AsElement
(
)
CSSPseudoElementType
:
:
firstLetter
aComputedStyle
nullptr
)
;
}
return
nullptr
;
}
already_AddRefed
<
ComputedStyle
>
nsCSSFrameConstructor
:
:
GetFirstLineStyle
(
nsIContent
*
aContent
ComputedStyle
*
aComputedStyle
)
{
if
(
aContent
)
{
return
mPresShell
-
>
StyleSet
(
)
-
>
ResolvePseudoElementStyle
(
aContent
-
>
AsElement
(
)
CSSPseudoElementType
:
:
firstLine
aComputedStyle
nullptr
)
;
}
return
nullptr
;
}
bool
nsCSSFrameConstructor
:
:
ShouldHaveFirstLetterStyle
(
nsIContent
*
aContent
ComputedStyle
*
aComputedStyle
)
{
return
nsLayoutUtils
:
:
HasPseudoStyle
(
aContent
aComputedStyle
CSSPseudoElementType
:
:
firstLetter
mPresShell
-
>
GetPresContext
(
)
)
;
}
bool
nsCSSFrameConstructor
:
:
HasFirstLetterStyle
(
nsIFrame
*
aBlockFrame
)
{
MOZ_ASSERT
(
aBlockFrame
"
Need
a
frame
"
)
;
NS_ASSERTION
(
nsLayoutUtils
:
:
GetAsBlock
(
aBlockFrame
)
"
Not
a
block
frame
?
"
)
;
return
(
aBlockFrame
-
>
GetStateBits
(
)
&
NS_BLOCK_HAS_FIRST_LETTER_STYLE
)
!
=
0
;
}
bool
nsCSSFrameConstructor
:
:
ShouldHaveFirstLineStyle
(
nsIContent
*
aContent
ComputedStyle
*
aComputedStyle
)
{
bool
hasFirstLine
=
nsLayoutUtils
:
:
HasPseudoStyle
(
aContent
aComputedStyle
CSSPseudoElementType
:
:
firstLine
mPresShell
-
>
GetPresContext
(
)
)
;
return
hasFirstLine
&
&
!
aContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
fieldset
)
;
}
void
nsCSSFrameConstructor
:
:
ShouldHaveSpecialBlockStyle
(
nsIContent
*
aContent
ComputedStyle
*
aComputedStyle
bool
*
aHaveFirstLetterStyle
bool
*
aHaveFirstLineStyle
)
{
*
aHaveFirstLetterStyle
=
ShouldHaveFirstLetterStyle
(
aContent
aComputedStyle
)
;
*
aHaveFirstLineStyle
=
ShouldHaveFirstLineStyle
(
aContent
aComputedStyle
)
;
}
const
nsCSSFrameConstructor
:
:
PseudoParentData
nsCSSFrameConstructor
:
:
sPseudoParentData
[
eParentTypeCount
]
=
{
{
FULL_CTOR_FCDATA
(
FCDATA_IS_TABLE_PART
|
FCDATA_SKIP_FRAMESET
|
FCDATA_USE_CHILD_ITEMS
|
FCDATA_IS_WRAPPER_ANON_BOX
|
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
eTypeRow
)
&
nsCSSFrameConstructor
:
:
ConstructTableCell
)
&
nsCSSAnonBoxes
:
:
tableCell
}
{
FULL_CTOR_FCDATA
(
FCDATA_IS_TABLE_PART
|
FCDATA_SKIP_FRAMESET
|
FCDATA_USE_CHILD_ITEMS
|
FCDATA_IS_WRAPPER_ANON_BOX
|
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
eTypeRowGroup
)
&
nsCSSFrameConstructor
:
:
ConstructTableRowOrRowGroup
)
&
nsCSSAnonBoxes
:
:
tableRow
}
{
FULL_CTOR_FCDATA
(
FCDATA_IS_TABLE_PART
|
FCDATA_SKIP_FRAMESET
|
FCDATA_USE_CHILD_ITEMS
|
FCDATA_IS_WRAPPER_ANON_BOX
|
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
eTypeTable
)
&
nsCSSFrameConstructor
:
:
ConstructTableRowOrRowGroup
)
&
nsCSSAnonBoxes
:
:
tableRowGroup
}
{
FCDATA_DECL
(
FCDATA_IS_TABLE_PART
|
FCDATA_SKIP_FRAMESET
|
FCDATA_DISALLOW_OUT_OF_FLOW
|
FCDATA_USE_CHILD_ITEMS
|
FCDATA_SKIP_ABSPOS_PUSH
|
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
eTypeTable
)
NS_NewTableColGroupFrame
)
&
nsCSSAnonBoxes
:
:
tableColGroup
}
{
FULL_CTOR_FCDATA
(
FCDATA_SKIP_FRAMESET
|
FCDATA_USE_CHILD_ITEMS
|
FCDATA_IS_WRAPPER_ANON_BOX
&
nsCSSFrameConstructor
:
:
ConstructTable
)
&
nsCSSAnonBoxes
:
:
table
}
{
FCDATA_DECL
(
FCDATA_IS_LINE_PARTICIPANT
|
FCDATA_USE_CHILD_ITEMS
|
FCDATA_IS_WRAPPER_ANON_BOX
|
FCDATA_SKIP_FRAMESET
NS_NewRubyFrame
)
&
nsCSSAnonBoxes
:
:
ruby
}
{
FCDATA_DECL
(
FCDATA_USE_CHILD_ITEMS
|
FCDATA_IS_LINE_PARTICIPANT
|
FCDATA_IS_WRAPPER_ANON_BOX
|
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
eTypeRubyBaseContainer
)
|
FCDATA_SKIP_FRAMESET
NS_NewRubyBaseFrame
)
&
nsCSSAnonBoxes
:
:
rubyBase
}
{
FCDATA_DECL
(
FCDATA_USE_CHILD_ITEMS
|
FCDATA_IS_LINE_PARTICIPANT
|
FCDATA_IS_WRAPPER_ANON_BOX
|
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
eTypeRuby
)
|
FCDATA_SKIP_FRAMESET
NS_NewRubyBaseContainerFrame
)
&
nsCSSAnonBoxes
:
:
rubyBaseContainer
}
{
FCDATA_DECL
(
FCDATA_USE_CHILD_ITEMS
|
FCDATA_IS_LINE_PARTICIPANT
|
FCDATA_IS_WRAPPER_ANON_BOX
|
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
eTypeRubyTextContainer
)
|
FCDATA_SKIP_FRAMESET
NS_NewRubyTextFrame
)
&
nsCSSAnonBoxes
:
:
rubyText
}
{
FCDATA_DECL
(
FCDATA_USE_CHILD_ITEMS
|
FCDATA_IS_WRAPPER_ANON_BOX
|
FCDATA_DESIRED_PARENT_TYPE_TO_BITS
(
eTypeRuby
)
|
FCDATA_SKIP_FRAMESET
NS_NewRubyTextContainerFrame
)
&
nsCSSAnonBoxes
:
:
rubyTextContainer
}
}
;
void
nsCSSFrameConstructor
:
:
CreateNeededAnonFlexOrGridItems
(
nsFrameConstructorState
&
aState
FrameConstructionItemList
&
aItems
nsIFrame
*
aParentFrame
)
{
if
(
aItems
.
IsEmpty
(
)
|
|
!
:
:
IsFlexOrGridContainer
(
aParentFrame
)
)
{
return
;
}
const
bool
isLegacyBox
=
IsFlexContainerForLegacyBox
(
aParentFrame
)
;
FCItemIterator
iter
(
aItems
)
;
do
{
if
(
iter
.
SkipItemsThatDontNeedAnonFlexOrGridItem
(
aState
isLegacyBox
)
)
{
return
;
}
if
(
!
aParentFrame
-
>
IsGeneratedContentFrame
(
)
&
&
iter
.
item
(
)
.
IsWhitespace
(
aState
)
)
{
FCItemIterator
afterWhitespaceIter
(
iter
)
;
bool
hitEnd
=
afterWhitespaceIter
.
SkipWhitespace
(
aState
)
;
bool
nextChildNeedsAnonItem
=
!
hitEnd
&
&
afterWhitespaceIter
.
item
(
)
.
NeedsAnonFlexOrGridItem
(
aState
isLegacyBox
)
;
if
(
!
nextChildNeedsAnonItem
)
{
iter
.
DeleteItemsTo
(
this
afterWhitespaceIter
)
;
if
(
hitEnd
)
{
return
;
}
MOZ_ASSERT
(
!
iter
.
IsDone
(
)
&
&
!
iter
.
item
(
)
.
NeedsAnonFlexOrGridItem
(
aState
isLegacyBox
)
"
hitEnd
and
/
or
nextChildNeedsAnonItem
lied
"
)
;
continue
;
}
}
FCItemIterator
endIter
(
iter
)
;
endIter
.
SkipItemsThatNeedAnonFlexOrGridItem
(
aState
isLegacyBox
)
;
NS_ASSERTION
(
iter
!
=
endIter
"
Should
'
ve
had
at
least
one
wrappable
child
to
seek
past
"
)
;
nsAtom
*
pseudoType
=
(
aParentFrame
-
>
IsFlexContainerFrame
(
)
)
?
nsCSSAnonBoxes
:
:
anonymousFlexItem
:
nsCSSAnonBoxes
:
:
anonymousGridItem
;
ComputedStyle
*
parentStyle
=
aParentFrame
-
>
Style
(
)
;
nsIContent
*
parentContent
=
aParentFrame
-
>
GetContent
(
)
;
already_AddRefed
<
ComputedStyle
>
wrapperStyle
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveInheritingAnonymousBoxStyle
(
pseudoType
parentStyle
)
;
static
const
FrameConstructionData
sBlockFormattingContextFCData
=
FCDATA_DECL
(
FCDATA_SKIP_FRAMESET
|
FCDATA_USE_CHILD_ITEMS
|
FCDATA_IS_WRAPPER_ANON_BOX
NS_NewBlockFormattingContext
)
;
FrameConstructionItem
*
newItem
=
new
(
this
)
FrameConstructionItem
(
&
sBlockFormattingContextFCData
parentContent
nullptr
wrapperStyle
true
nullptr
)
;
newItem
-
>
mIsAllInline
=
newItem
-
>
mHasInlineEnds
=
newItem
-
>
mComputedStyle
-
>
StyleDisplay
(
)
-
>
IsInlineOutsideStyle
(
)
;
newItem
-
>
mIsBlock
=
!
newItem
-
>
mIsAllInline
;
MOZ_ASSERT
(
!
newItem
-
>
mIsAllInline
&
&
newItem
-
>
mIsBlock
"
expecting
anonymous
flex
/
grid
items
to
be
block
-
level
"
"
(
this
will
make
a
difference
when
we
encounter
"
"
'
align
-
items
:
baseline
'
)
"
)
;
newItem
-
>
mChildItems
.
SetLineBoundaryAtStart
(
true
)
;
newItem
-
>
mChildItems
.
SetLineBoundaryAtEnd
(
true
)
;
newItem
-
>
mChildItems
.
SetParentHasNoXBLChildren
(
aItems
.
ParentHasNoXBLChildren
(
)
)
;
iter
.
AppendItemsToList
(
this
endIter
newItem
-
>
mChildItems
)
;
iter
.
InsertItem
(
newItem
)
;
}
while
(
!
iter
.
IsDone
(
)
)
;
}
nsCSSFrameConstructor
:
:
RubyWhitespaceType
nsCSSFrameConstructor
:
:
ComputeRubyWhitespaceType
(
StyleDisplay
aPrevDisplay
StyleDisplay
aNextDisplay
)
{
MOZ_ASSERT
(
nsStyleDisplay
:
:
IsRubyDisplayType
(
aPrevDisplay
)
&
&
nsStyleDisplay
:
:
IsRubyDisplayType
(
aNextDisplay
)
)
;
if
(
aPrevDisplay
=
=
aNextDisplay
&
&
(
aPrevDisplay
=
=
StyleDisplay
:
:
RubyBase
|
|
aPrevDisplay
=
=
StyleDisplay
:
:
RubyText
)
)
{
return
eRubyInterLeafWhitespace
;
}
if
(
aNextDisplay
=
=
StyleDisplay
:
:
RubyText
|
|
aNextDisplay
=
=
StyleDisplay
:
:
RubyTextContainer
)
{
return
eRubyInterLevelWhitespace
;
}
return
eRubyInterSegmentWhitespace
;
}
nsCSSFrameConstructor
:
:
RubyWhitespaceType
nsCSSFrameConstructor
:
:
InterpretRubyWhitespace
(
nsFrameConstructorState
&
aState
const
FCItemIterator
&
aStartIter
const
FCItemIterator
&
aEndIter
)
{
if
(
!
aStartIter
.
item
(
)
.
IsWhitespace
(
aState
)
)
{
return
eRubyNotWhitespace
;
}
FCItemIterator
spaceEndIter
(
aStartIter
)
;
spaceEndIter
.
SkipWhitespace
(
aState
)
;
if
(
spaceEndIter
!
=
aEndIter
)
{
return
eRubyNotWhitespace
;
}
MOZ_ASSERT
(
!
aStartIter
.
AtStart
(
)
&
&
!
aEndIter
.
IsDone
(
)
)
;
FCItemIterator
prevIter
(
aStartIter
)
;
prevIter
.
Prev
(
)
;
return
ComputeRubyWhitespaceType
(
prevIter
.
item
(
)
.
mComputedStyle
-
>
StyleDisplay
(
)
-
>
mDisplay
aEndIter
.
item
(
)
.
mComputedStyle
-
>
StyleDisplay
(
)
-
>
mDisplay
)
;
}
void
nsCSSFrameConstructor
:
:
WrapItemsInPseudoRubyLeafBox
(
FCItemIterator
&
aIter
ComputedStyle
*
aParentStyle
nsIContent
*
aParentContent
)
{
StyleDisplay
parentDisplay
=
aParentStyle
-
>
StyleDisplay
(
)
-
>
mDisplay
;
ParentType
parentType
wrapperType
;
if
(
parentDisplay
=
=
StyleDisplay
:
:
RubyTextContainer
)
{
parentType
=
eTypeRubyTextContainer
;
wrapperType
=
eTypeRubyText
;
}
else
{
MOZ_ASSERT
(
parentDisplay
=
=
StyleDisplay
:
:
RubyBaseContainer
)
;
parentType
=
eTypeRubyBaseContainer
;
wrapperType
=
eTypeRubyBase
;
}
MOZ_ASSERT
(
aIter
.
item
(
)
.
DesiredParentType
(
)
!
=
parentType
"
Should
point
to
something
needs
to
be
wrapped
.
"
)
;
FCItemIterator
endIter
(
aIter
)
;
endIter
.
SkipItemsNotWantingParentType
(
parentType
)
;
WrapItemsInPseudoParent
(
aParentContent
aParentStyle
wrapperType
aIter
endIter
)
;
}
void
nsCSSFrameConstructor
:
:
WrapItemsInPseudoRubyLevelContainer
(
nsFrameConstructorState
&
aState
FCItemIterator
&
aIter
ComputedStyle
*
aParentStyle
nsIContent
*
aParentContent
)
{
MOZ_ASSERT
(
aIter
.
item
(
)
.
DesiredParentType
(
)
!
=
eTypeRuby
"
Pointing
to
a
level
container
?
"
)
;
FrameConstructionItem
&
firstItem
=
aIter
.
item
(
)
;
ParentType
wrapperType
=
firstItem
.
DesiredParentType
(
)
;
if
(
wrapperType
!
=
eTypeRubyTextContainer
)
{
wrapperType
=
eTypeRubyBaseContainer
;
}
FCItemIterator
endIter
(
aIter
)
;
do
{
if
(
endIter
.
SkipItemsWantingParentType
(
wrapperType
)
|
|
IsRubyParentType
(
endIter
.
item
(
)
.
DesiredParentType
(
)
)
)
{
break
;
}
FCItemIterator
contentEndIter
(
endIter
)
;
contentEndIter
.
SkipItemsNotWantingRubyParent
(
)
;
MOZ_ASSERT
(
contentEndIter
!
=
endIter
)
;
RubyWhitespaceType
whitespaceType
=
InterpretRubyWhitespace
(
aState
endIter
contentEndIter
)
;
if
(
whitespaceType
=
=
eRubyInterLevelWhitespace
)
{
bool
atStart
=
(
aIter
=
=
endIter
)
;
endIter
.
DeleteItemsTo
(
this
contentEndIter
)
;
if
(
atStart
)
{
aIter
=
endIter
;
}
}
else
if
(
whitespaceType
=
=
eRubyInterSegmentWhitespace
)
{
if
(
aIter
=
=
endIter
)
{
MOZ_ASSERT
(
wrapperType
=
=
eTypeRubyBaseContainer
"
Inter
-
segment
whitespace
should
be
wrapped
in
rbc
"
)
;
endIter
=
contentEndIter
;
}
break
;
}
else
if
(
wrapperType
=
=
eTypeRubyTextContainer
&
&
whitespaceType
!
=
eRubyInterLeafWhitespace
)
{
break
;
}
else
{
endIter
=
contentEndIter
;
}
}
while
(
!
endIter
.
IsDone
(
)
)
;
if
(
aIter
!
=
endIter
)
{
WrapItemsInPseudoParent
(
aParentContent
aParentStyle
wrapperType
aIter
endIter
)
;
}
}
void
nsCSSFrameConstructor
:
:
TrimLeadingAndTrailingWhitespaces
(
nsFrameConstructorState
&
aState
FrameConstructionItemList
&
aItems
)
{
FCItemIterator
iter
(
aItems
)
;
if
(
!
iter
.
IsDone
(
)
&
&
iter
.
item
(
)
.
IsWhitespace
(
aState
)
)
{
FCItemIterator
spaceEndIter
(
iter
)
;
spaceEndIter
.
SkipWhitespace
(
aState
)
;
iter
.
DeleteItemsTo
(
this
spaceEndIter
)
;
}
iter
.
SetToEnd
(
)
;
if
(
!
iter
.
AtStart
(
)
)
{
FCItemIterator
spaceEndIter
(
iter
)
;
do
{
iter
.
Prev
(
)
;
if
(
iter
.
AtStart
(
)
)
{
break
;
}
}
while
(
iter
.
item
(
)
.
IsWhitespace
(
aState
)
)
;
iter
.
Next
(
)
;
if
(
iter
!
=
spaceEndIter
)
{
iter
.
DeleteItemsTo
(
this
spaceEndIter
)
;
}
}
}
void
nsCSSFrameConstructor
:
:
CreateNeededPseudoInternalRubyBoxes
(
nsFrameConstructorState
&
aState
FrameConstructionItemList
&
aItems
nsIFrame
*
aParentFrame
)
{
const
ParentType
ourParentType
=
GetParentType
(
aParentFrame
)
;
if
(
!
IsRubyParentType
(
ourParentType
)
|
|
aItems
.
AllWantParentType
(
ourParentType
)
)
{
return
;
}
if
(
!
IsRubyPseudo
(
aParentFrame
)
)
{
TrimLeadingAndTrailingWhitespaces
(
aState
aItems
)
;
}
FCItemIterator
iter
(
aItems
)
;
nsIContent
*
parentContent
=
aParentFrame
-
>
GetContent
(
)
;
ComputedStyle
*
parentStyle
=
aParentFrame
-
>
Style
(
)
;
while
(
!
iter
.
IsDone
(
)
)
{
if
(
!
iter
.
SkipItemsWantingParentType
(
ourParentType
)
)
{
if
(
ourParentType
=
=
eTypeRuby
)
{
WrapItemsInPseudoRubyLevelContainer
(
aState
iter
parentStyle
parentContent
)
;
}
else
{
WrapItemsInPseudoRubyLeafBox
(
iter
parentStyle
parentContent
)
;
}
}
}
}
void
nsCSSFrameConstructor
:
:
CreateNeededPseudoContainers
(
nsFrameConstructorState
&
aState
FrameConstructionItemList
&
aItems
nsIFrame
*
aParentFrame
)
{
ParentType
ourParentType
=
GetParentType
(
aParentFrame
)
;
if
(
IsRubyParentType
(
ourParentType
)
|
|
aItems
.
AllWantParentType
(
ourParentType
)
)
{
return
;
}
FCItemIterator
iter
(
aItems
)
;
do
{
if
(
iter
.
SkipItemsWantingParentType
(
ourParentType
)
)
{
return
;
}
FCItemIterator
endIter
(
iter
)
;
ParentType
groupingParentType
=
endIter
.
item
(
)
.
DesiredParentType
(
)
;
if
(
aItems
.
AllWantParentType
(
groupingParentType
)
&
&
groupingParentType
!
=
eTypeBlock
)
{
endIter
.
SetToEnd
(
)
;
}
else
{
ParentType
prevParentType
=
ourParentType
;
do
{
FCItemIterator
spaceEndIter
(
endIter
)
;
if
(
prevParentType
!
=
eTypeBlock
&
&
!
aParentFrame
-
>
IsGeneratedContentFrame
(
)
&
&
spaceEndIter
.
item
(
)
.
IsWhitespace
(
aState
)
)
{
bool
trailingSpaces
=
spaceEndIter
.
SkipWhitespace
(
aState
)
;
if
(
(
!
trailingSpaces
&
&
IsTableParentType
(
spaceEndIter
.
item
(
)
.
DesiredParentType
(
)
)
)
|
|
(
trailingSpaces
&
&
ourParentType
!
=
eTypeBlock
)
)
{
bool
updateStart
=
(
iter
=
=
endIter
)
;
endIter
.
DeleteItemsTo
(
this
spaceEndIter
)
;
NS_ASSERTION
(
trailingSpaces
=
=
endIter
.
IsDone
(
)
"
These
should
match
"
)
;
if
(
updateStart
)
{
iter
=
endIter
;
}
if
(
trailingSpaces
)
{
break
;
}
if
(
updateStart
)
{
groupingParentType
=
iter
.
item
(
)
.
DesiredParentType
(
)
;
}
}
}
prevParentType
=
endIter
.
item
(
)
.
DesiredParentType
(
)
;
if
(
prevParentType
=
=
ourParentType
&
&
(
endIter
=
=
spaceEndIter
|
|
spaceEndIter
.
IsDone
(
)
|
|
!
IsRubyParentType
(
groupingParentType
)
|
|
!
IsRubyParentType
(
spaceEndIter
.
item
(
)
.
DesiredParentType
(
)
)
)
)
{
break
;
}
if
(
ourParentType
=
=
eTypeTable
&
&
(
prevParentType
=
=
eTypeColGroup
)
!
=
(
groupingParentType
=
=
eTypeColGroup
)
)
{
break
;
}
if
(
spaceEndIter
!
=
endIter
&
&
!
spaceEndIter
.
IsDone
(
)
&
&
ourParentType
=
=
spaceEndIter
.
item
(
)
.
DesiredParentType
(
)
)
{
endIter
=
spaceEndIter
;
break
;
}
endIter
=
spaceEndIter
;
prevParentType
=
endIter
.
item
(
)
.
DesiredParentType
(
)
;
endIter
.
Next
(
)
;
}
while
(
!
endIter
.
IsDone
(
)
)
;
}
if
(
iter
=
=
endIter
)
{
continue
;
}
ParentType
wrapperType
;
switch
(
ourParentType
)
{
case
eTypeRow
:
wrapperType
=
eTypeBlock
;
break
;
case
eTypeRowGroup
:
wrapperType
=
eTypeRow
;
break
;
case
eTypeTable
:
wrapperType
=
groupingParentType
=
=
eTypeColGroup
?
eTypeColGroup
:
eTypeRowGroup
;
break
;
case
eTypeColGroup
:
MOZ_CRASH
(
"
Colgroups
should
be
suppresing
non
-
col
child
items
"
)
;
default
:
NS_ASSERTION
(
ourParentType
=
=
eTypeBlock
"
Unrecognized
parent
type
"
)
;
if
(
IsRubyParentType
(
groupingParentType
)
)
{
wrapperType
=
eTypeRuby
;
}
else
{
NS_ASSERTION
(
IsTableParentType
(
groupingParentType
)
"
groupingParentType
should
be
either
Ruby
or
table
"
)
;
wrapperType
=
eTypeTable
;
}
}
ComputedStyle
*
parentStyle
=
aParentFrame
-
>
Style
(
)
;
WrapItemsInPseudoParent
(
aParentFrame
-
>
GetContent
(
)
parentStyle
wrapperType
iter
endIter
)
;
}
while
(
!
iter
.
IsDone
(
)
)
;
}
void
nsCSSFrameConstructor
:
:
WrapItemsInPseudoParent
(
nsIContent
*
aParentContent
ComputedStyle
*
aParentStyle
ParentType
aWrapperType
FCItemIterator
&
aIter
const
FCItemIterator
&
aEndIter
)
{
const
PseudoParentData
&
pseudoData
=
sPseudoParentData
[
aWrapperType
]
;
nsAtom
*
pseudoType
=
*
pseudoData
.
mPseudoType
;
StyleDisplay
parentDisplay
=
aParentStyle
-
>
StyleDisplay
(
)
-
>
mDisplay
;
if
(
pseudoType
=
=
nsCSSAnonBoxes
:
:
table
&
&
(
parentDisplay
=
=
StyleDisplay
:
:
Inline
|
|
parentDisplay
=
=
StyleDisplay
:
:
RubyBase
|
|
parentDisplay
=
=
StyleDisplay
:
:
RubyText
)
)
{
pseudoType
=
nsCSSAnonBoxes
:
:
inlineTable
;
}
already_AddRefed
<
ComputedStyle
>
wrapperStyle
;
if
(
pseudoData
.
mFCData
.
mBits
&
FCDATA_IS_WRAPPER_ANON_BOX
)
{
wrapperStyle
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveInheritingAnonymousBoxStyle
(
pseudoType
aParentStyle
)
;
}
else
{
wrapperStyle
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveNonInheritingAnonymousBoxStyle
(
pseudoType
)
;
}
FrameConstructionItem
*
newItem
=
new
(
this
)
FrameConstructionItem
(
&
pseudoData
.
mFCData
aParentContent
nullptr
wrapperStyle
true
nullptr
)
;
const
nsStyleDisplay
*
disp
=
newItem
-
>
mComputedStyle
-
>
StyleDisplay
(
)
;
newItem
-
>
mIsAllInline
=
newItem
-
>
mHasInlineEnds
=
disp
-
>
IsInlineOutsideStyle
(
)
;
bool
isRuby
=
disp
-
>
IsRubyDisplayType
(
)
;
newItem
-
>
mIsLineParticipant
=
isRuby
;
if
(
!
isRuby
)
{
newItem
-
>
mChildItems
.
SetLineBoundaryAtStart
(
true
)
;
newItem
-
>
mChildItems
.
SetLineBoundaryAtEnd
(
true
)
;
}
newItem
-
>
mChildItems
.
SetParentHasNoXBLChildren
(
aIter
.
List
(
)
-
>
ParentHasNoXBLChildren
(
)
)
;
aIter
.
AppendItemsToList
(
this
aEndIter
newItem
-
>
mChildItems
)
;
aIter
.
InsertItem
(
newItem
)
;
}
void
nsCSSFrameConstructor
:
:
CreateNeededPseudoSiblings
(
nsFrameConstructorState
&
aState
FrameConstructionItemList
&
aItems
nsIFrame
*
aParentFrame
)
{
if
(
aItems
.
IsEmpty
(
)
|
|
GetParentType
(
aParentFrame
)
!
=
eTypeRuby
)
{
return
;
}
FCItemIterator
iter
(
aItems
)
;
StyleDisplay
firstDisplay
=
iter
.
item
(
)
.
mComputedStyle
-
>
StyleDisplay
(
)
-
>
mDisplay
;
if
(
firstDisplay
=
=
StyleDisplay
:
:
RubyBaseContainer
)
{
return
;
}
NS_ASSERTION
(
firstDisplay
=
=
StyleDisplay
:
:
RubyTextContainer
"
Child
of
ruby
frame
should
either
a
rbc
or
a
rtc
"
)
;
const
PseudoParentData
&
pseudoData
=
sPseudoParentData
[
eTypeRubyBaseContainer
]
;
already_AddRefed
<
ComputedStyle
>
pseudoStyle
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveInheritingAnonymousBoxStyle
(
*
pseudoData
.
mPseudoType
aParentFrame
-
>
Style
(
)
)
;
FrameConstructionItem
*
newItem
=
new
(
this
)
FrameConstructionItem
(
&
pseudoData
.
mFCData
aParentFrame
-
>
GetContent
(
)
nullptr
pseudoStyle
true
nullptr
)
;
newItem
-
>
mIsAllInline
=
true
;
newItem
-
>
mChildItems
.
SetParentHasNoXBLChildren
(
true
)
;
iter
.
InsertItem
(
newItem
)
;
}
#
ifdef
DEBUG
static
bool
FrameWantsToBeInAnonymousItem
(
const
nsIFrame
*
aContainerFrame
const
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
:
:
IsFlexOrGridContainer
(
aContainerFrame
)
)
;
if
(
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eLineParticipant
)
)
{
return
true
;
}
if
(
IsFlexContainerForLegacyBox
(
aContainerFrame
)
&
&
aFrame
-
>
IsPlaceholderFrame
(
)
)
{
return
true
;
}
return
false
;
}
#
endif
static
void
VerifyGridFlexContainerChildren
(
nsIFrame
*
aParentFrame
const
nsFrameList
&
aChildren
)
{
#
ifdef
DEBUG
if
(
!
:
:
IsFlexOrGridContainer
(
aParentFrame
)
)
{
return
;
}
bool
prevChildWasAnonItem
=
false
;
for
(
const
nsIFrame
*
child
:
aChildren
)
{
MOZ_ASSERT
(
!
FrameWantsToBeInAnonymousItem
(
aParentFrame
child
)
"
frame
wants
to
be
inside
an
anonymous
item
but
it
isn
'
t
"
)
;
if
(
IsAnonymousFlexOrGridItem
(
child
)
)
{
AssertAnonymousFlexOrGridItemParent
(
child
aParentFrame
)
;
MOZ_ASSERT
(
!
prevChildWasAnonItem
"
two
anon
items
in
a
row
"
)
;
nsIFrame
*
firstWrappedChild
=
child
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
MOZ_ASSERT
(
firstWrappedChild
"
anonymous
item
shouldn
'
t
be
empty
"
)
;
prevChildWasAnonItem
=
true
;
}
else
{
prevChildWasAnonItem
=
false
;
}
}
#
endif
}
inline
void
nsCSSFrameConstructor
:
:
ConstructFramesFromItemList
(
nsFrameConstructorState
&
aState
FrameConstructionItemList
&
aItems
nsContainerFrame
*
aParentFrame
bool
aParentIsWrapperAnonBox
nsFrameItems
&
aFrameItems
)
{
MOZ_ASSERT
(
ParentIsWrapperAnonBox
(
aParentFrame
)
=
=
aParentIsWrapperAnonBox
)
;
CreateNeededPseudoContainers
(
aState
aItems
aParentFrame
)
;
CreateNeededAnonFlexOrGridItems
(
aState
aItems
aParentFrame
)
;
CreateNeededPseudoInternalRubyBoxes
(
aState
aItems
aParentFrame
)
;
CreateNeededPseudoSiblings
(
aState
aItems
aParentFrame
)
;
for
(
FCItemIterator
iter
(
aItems
)
;
!
iter
.
IsDone
(
)
;
iter
.
Next
(
)
)
{
NS_ASSERTION
(
iter
.
item
(
)
.
DesiredParentType
(
)
=
=
GetParentType
(
aParentFrame
)
"
Needed
pseudos
didn
'
t
get
created
;
expect
bad
things
"
)
;
ConstructFramesFromItem
(
aState
iter
aParentFrame
aFrameItems
)
;
}
VerifyGridFlexContainerChildren
(
aParentFrame
aFrameItems
)
;
NS_ASSERTION
(
!
aState
.
mHavePendingPopupgroup
"
Should
have
proccessed
it
by
now
"
)
;
if
(
aParentIsWrapperAnonBox
)
{
for
(
nsIFrame
*
f
:
aFrameItems
)
{
f
-
>
SetParentIsWrapperAnonBox
(
)
;
}
}
}
void
nsCSSFrameConstructor
:
:
AddFCItemsForAnonymousContent
(
nsFrameConstructorState
&
aState
nsContainerFrame
*
aFrame
nsTArray
<
nsIAnonymousContentCreator
:
:
ContentInfo
>
&
aAnonymousItems
FrameConstructionItemList
&
aItemsToConstruct
uint32_t
aExtraFlags
)
{
for
(
uint32_t
i
=
0
;
i
<
aAnonymousItems
.
Length
(
)
;
+
+
i
)
{
nsIContent
*
content
=
aAnonymousItems
[
i
]
.
mContent
;
MOZ_ASSERT
(
!
(
content
-
>
GetFlags
(
)
&
(
NODE_DESCENDANTS_NEED_FRAMES
|
NODE_NEEDS_FRAME
)
)
"
Should
not
be
marked
as
needing
frames
"
)
;
MOZ_ASSERT
(
!
content
-
>
GetPrimaryFrame
(
)
"
Should
have
no
existing
frame
"
)
;
MOZ_ASSERT
(
!
content
-
>
IsComment
(
)
&
&
!
content
-
>
IsProcessingInstruction
(
)
"
Why
is
someone
creating
garbage
anonymous
content
"
)
;
MOZ_ASSERT
(
!
content
-
>
IsElement
(
)
|
|
content
-
>
AsElement
(
)
-
>
HasServoData
(
)
)
;
RefPtr
<
ComputedStyle
>
computedStyle
=
ResolveComputedStyle
(
content
)
;
nsTArray
<
nsIAnonymousContentCreator
:
:
ContentInfo
>
*
anonChildren
=
nullptr
;
if
(
!
aAnonymousItems
[
i
]
.
mChildren
.
IsEmpty
(
)
)
{
anonChildren
=
&
aAnonymousItems
[
i
]
.
mChildren
;
}
uint32_t
flags
=
ITEM_ALLOW_XBL_BASE
|
ITEM_ALLOW_PAGE_BREAK
|
ITEM_IS_ANONYMOUSCONTENTCREATOR_CONTENT
|
aExtraFlags
;
AddFrameConstructionItemsInternal
(
aState
content
aFrame
true
computedStyle
flags
anonChildren
aItemsToConstruct
)
;
}
}
void
nsCSSFrameConstructor
:
:
ProcessChildren
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
ComputedStyle
*
aComputedStyle
nsContainerFrame
*
aFrame
const
bool
aCanHaveGeneratedContent
nsFrameItems
&
aFrameItems
const
bool
aAllowBlockStyles
PendingBinding
*
aPendingBinding
nsIFrame
*
aPossiblyLeafFrame
)
{
MOZ_ASSERT
(
aFrame
"
Must
have
parent
frame
here
"
)
;
MOZ_ASSERT
(
aFrame
-
>
GetContentInsertionFrame
(
)
=
=
aFrame
"
Parent
frame
in
ProcessChildren
should
be
its
own
"
"
content
insertion
frame
"
)
;
const
uint32_t
kMaxDepth
=
2
*
MAX_REFLOW_DEPTH
;
static_assert
(
kMaxDepth
<
=
UINT16_MAX
"
mCurrentDepth
type
is
too
narrow
"
)
;
AutoRestore
<
uint16_t
>
savedDepth
(
mCurrentDepth
)
;
if
(
mCurrentDepth
!
=
UINT16_MAX
)
{
+
+
mCurrentDepth
;
}
if
(
!
aPossiblyLeafFrame
)
{
aPossiblyLeafFrame
=
aFrame
;
}
const
bool
allowFirstPseudos
=
aAllowBlockStyles
&
&
nsLayoutUtils
:
:
GetAsBlock
(
aFrame
)
;
bool
haveFirstLetterStyle
=
false
haveFirstLineStyle
=
false
;
if
(
allowFirstPseudos
)
{
ShouldHaveSpecialBlockStyle
(
aContent
aComputedStyle
&
haveFirstLetterStyle
&
haveFirstLineStyle
)
;
}
const
bool
isFlexOrGridContainer
=
:
:
IsFlexOrGridContainer
(
aFrame
)
;
nsFrameConstructorSaveState
floatSaveState
;
if
(
isFlexOrGridContainer
|
|
ShouldSuppressFloatingOfDescendants
(
aFrame
)
)
{
aState
.
PushFloatContainingBlock
(
nullptr
floatSaveState
)
;
}
else
if
(
aFrame
-
>
IsFloatContainingBlock
(
)
)
{
aState
.
PushFloatContainingBlock
(
aFrame
floatSaveState
)
;
}
nsFrameConstructorState
:
:
PendingBindingAutoPusher
pusher
(
aState
aPendingBinding
)
;
AutoFrameConstructionItemList
itemsToConstruct
(
this
)
;
if
(
allowFirstPseudos
&
&
!
haveFirstLetterStyle
&
&
!
haveFirstLineStyle
)
{
itemsToConstruct
.
SetLineBoundaryAtStart
(
true
)
;
itemsToConstruct
.
SetLineBoundaryAtEnd
(
true
)
;
}
AutoTArray
<
nsIAnonymousContentCreator
:
:
ContentInfo
4
>
anonymousItems
;
GetAnonymousContent
(
aContent
aPossiblyLeafFrame
anonymousItems
)
;
#
ifdef
DEBUG
for
(
uint32_t
i
=
0
;
i
<
anonymousItems
.
Length
(
)
;
+
+
i
)
{
MOZ_ASSERT
(
anonymousItems
[
i
]
.
mContent
-
>
IsRootOfAnonymousSubtree
(
)
"
Content
should
know
it
'
s
an
anonymous
subtree
"
)
;
}
#
endif
AddFCItemsForAnonymousContent
(
aState
aFrame
anonymousItems
itemsToConstruct
)
;
if
(
!
aPossiblyLeafFrame
-
>
IsLeaf
(
)
)
{
ComputedStyle
*
computedStyle
;
if
(
aCanHaveGeneratedContent
)
{
aFrame
-
>
AddStateBits
(
NS_FRAME_MAY_HAVE_GENERATED_CONTENT
)
;
computedStyle
=
nsFrame
:
:
CorrectStyleParentFrame
(
aFrame
nullptr
)
-
>
Style
(
)
;
CreateGeneratedContentItem
(
aState
aFrame
aContent
-
>
AsElement
(
)
computedStyle
CSSPseudoElementType
:
:
before
itemsToConstruct
)
;
}
const
bool
addChildItems
=
MOZ_LIKELY
(
mCurrentDepth
<
kMaxDepth
)
;
if
(
!
addChildItems
)
{
NS_WARNING
(
"
ProcessChildren
max
depth
exceeded
"
)
;
}
InsertionPoint
insertion
(
aFrame
nullptr
)
;
FlattenedChildIterator
iter
(
aContent
)
;
for
(
nsIContent
*
child
=
iter
.
GetNextChild
(
)
;
child
;
child
=
iter
.
GetNextChild
(
)
)
{
insertion
.
mContainer
=
aContent
;
nsIContent
*
parent
=
child
-
>
GetParent
(
)
;
MOZ_ASSERT
(
parent
"
Parent
must
be
non
-
null
because
we
are
iterating
children
.
"
)
;
if
(
parent
!
=
aContent
&
&
parent
-
>
IsElement
(
)
)
{
insertion
.
mContainer
=
child
-
>
GetFlattenedTreeParent
(
)
;
MOZ_ASSERT
(
insertion
.
mContainer
=
=
GetInsertionPoint
(
child
)
.
mContainer
)
;
}
if
(
addChildItems
)
{
AddFrameConstructionItems
(
aState
child
iter
.
XBLInvolved
(
)
insertion
itemsToConstruct
)
;
}
else
{
ClearLazyBits
(
child
child
-
>
GetNextSibling
(
)
)
;
}
}
itemsToConstruct
.
SetParentHasNoXBLChildren
(
!
iter
.
XBLInvolved
(
)
)
;
if
(
aCanHaveGeneratedContent
)
{
CreateGeneratedContentItem
(
aState
aFrame
aContent
-
>
AsElement
(
)
computedStyle
CSSPseudoElementType
:
:
after
itemsToConstruct
)
;
}
}
else
{
ClearLazyBits
(
aContent
-
>
GetFirstChild
(
)
nullptr
)
;
}
ConstructFramesFromItemList
(
aState
itemsToConstruct
aFrame
false
aFrameItems
)
;
NS_ASSERTION
(
!
allowFirstPseudos
|
|
!
aFrame
-
>
IsXULBoxFrame
(
)
"
can
'
t
be
both
block
and
box
"
)
;
if
(
haveFirstLetterStyle
)
{
WrapFramesInFirstLetterFrame
(
aFrame
aFrameItems
)
;
}
if
(
haveFirstLineStyle
)
{
WrapFramesInFirstLineFrame
(
aState
aContent
aFrame
nullptr
aFrameItems
)
;
}
NS_ASSERTION
(
!
haveFirstLineStyle
|
|
!
aFrame
-
>
IsXULBoxFrame
(
)
"
Shouldn
'
t
have
first
-
line
style
if
we
'
re
a
box
"
)
;
NS_ASSERTION
(
!
aFrame
-
>
IsXULBoxFrame
(
)
|
|
itemsToConstruct
.
AnyItemsNeedBlockParent
(
)
=
=
(
AnyKidsNeedBlockParent
(
aFrameItems
.
FirstChild
(
)
)
!
=
nullptr
)
"
Something
went
awry
in
our
block
parent
calculations
"
)
;
if
(
aFrame
-
>
IsXULBoxFrame
(
)
&
&
itemsToConstruct
.
AnyItemsNeedBlockParent
(
)
)
{
ComputedStyle
*
frameComputedStyle
=
aFrame
-
>
Style
(
)
;
if
(
!
aFrame
-
>
IsGeneratedContentFrame
(
)
&
&
mPresShell
-
>
GetPresContext
(
)
-
>
IsChrome
(
)
)
{
nsIContent
*
badKid
=
AnyKidsNeedBlockParent
(
aFrameItems
.
FirstChild
(
)
)
;
nsDependentAtomString
parentTag
(
aContent
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
kidTag
(
badKid
-
>
NodeInfo
(
)
-
>
NameAtom
(
)
)
;
const
char16_t
*
params
[
]
=
{
parentTag
.
get
(
)
kidTag
.
get
(
)
}
;
const
nsStyleDisplay
*
display
=
frameComputedStyle
-
>
StyleDisplay
(
)
;
const
char
*
message
=
(
display
-
>
mDisplay
=
=
StyleDisplay
:
:
MozInlineBox
)
?
"
NeededToWrapXULInlineBox
"
:
"
NeededToWrapXUL
"
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
Layout
:
FrameConstructor
"
)
mDocument
nsContentUtils
:
:
eXUL_PROPERTIES
message
params
ArrayLength
(
params
)
)
;
}
RefPtr
<
ComputedStyle
>
blockSC
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveInheritingAnonymousBoxStyle
(
nsCSSAnonBoxes
:
:
mozXULAnonymousBlock
frameComputedStyle
)
;
nsBlockFrame
*
blockFrame
=
NS_NewBlockFrame
(
mPresShell
blockSC
)
;
InitAndRestoreFrame
(
aState
aContent
aFrame
blockFrame
false
)
;
NS_ASSERTION
(
!
blockFrame
-
>
HasView
(
)
"
need
to
do
view
reparenting
"
)
;
ReparentFrames
(
this
blockFrame
aFrameItems
false
)
;
blockFrame
-
>
SetInitialChildList
(
kPrincipalList
aFrameItems
)
;
NS_ASSERTION
(
aFrameItems
.
IsEmpty
(
)
"
How
did
that
happen
?
"
)
;
aFrameItems
.
Clear
(
)
;
aFrameItems
.
AddChild
(
blockFrame
)
;
aFrame
-
>
AddStateBits
(
NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK
)
;
MOZ_ASSERT
(
!
aFrame
-
>
IsLeaf
(
)
"
Why
do
we
have
an
nsLeafBoxFrame
here
?
"
)
;
aFrame
-
>
AddStateBits
(
NS_FRAME_OWNS_ANON_BOXES
)
;
}
}
void
nsCSSFrameConstructor
:
:
WrapFramesInFirstLineFrame
(
nsFrameConstructorState
&
aState
nsIContent
*
aBlockContent
nsContainerFrame
*
aBlockFrame
nsFirstLineFrame
*
aLineFrame
nsFrameItems
&
aFrameItems
)
{
nsFrameList
:
:
FrameLinkEnumerator
link
(
aFrameItems
)
;
while
(
!
link
.
AtEnd
(
)
&
&
link
.
NextFrame
(
)
-
>
IsInlineOutside
(
)
)
{
link
.
Next
(
)
;
}
nsFrameList
firstLineChildren
=
aFrameItems
.
ExtractHead
(
link
)
;
if
(
firstLineChildren
.
IsEmpty
(
)
)
{
return
;
}
if
(
!
aLineFrame
)
{
ComputedStyle
*
parentStyle
=
nsFrame
:
:
CorrectStyleParentFrame
(
aBlockFrame
nsCSSPseudoElements
:
:
firstLine
)
-
>
Style
(
)
;
RefPtr
<
ComputedStyle
>
firstLineStyle
=
GetFirstLineStyle
(
aBlockContent
parentStyle
)
;
aLineFrame
=
NS_NewFirstLineFrame
(
mPresShell
firstLineStyle
)
;
InitAndRestoreFrame
(
aState
aBlockContent
aBlockFrame
aLineFrame
)
;
aFrameItems
.
InsertFrame
(
nullptr
nullptr
aLineFrame
)
;
NS_ASSERTION
(
aLineFrame
-
>
Style
(
)
=
=
firstLineStyle
"
Bogus
style
on
line
frame
"
)
;
}
ReparentFrames
(
this
aLineFrame
firstLineChildren
true
)
;
if
(
aLineFrame
-
>
PrincipalChildList
(
)
.
IsEmpty
(
)
&
&
(
aLineFrame
-
>
GetStateBits
(
)
&
NS_FRAME_FIRST_REFLOW
)
)
{
aLineFrame
-
>
SetInitialChildList
(
kPrincipalList
firstLineChildren
)
;
}
else
{
AppendFrames
(
aLineFrame
kPrincipalList
firstLineChildren
)
;
}
}
void
nsCSSFrameConstructor
:
:
AppendFirstLineFrames
(
nsFrameConstructorState
&
aState
nsIContent
*
aBlockContent
nsContainerFrame
*
aBlockFrame
nsFrameItems
&
aFrameItems
)
{
const
nsFrameList
&
blockKids
=
aBlockFrame
-
>
PrincipalChildList
(
)
;
if
(
blockKids
.
IsEmpty
(
)
)
{
WrapFramesInFirstLineFrame
(
aState
aBlockContent
aBlockFrame
nullptr
aFrameItems
)
;
return
;
}
nsIFrame
*
lastBlockKid
=
blockKids
.
LastChild
(
)
;
if
(
!
lastBlockKid
-
>
IsLineFrame
(
)
)
{
return
;
}
nsFirstLineFrame
*
lineFrame
=
static_cast
<
nsFirstLineFrame
*
>
(
lastBlockKid
)
;
WrapFramesInFirstLineFrame
(
aState
aBlockContent
aBlockFrame
lineFrame
aFrameItems
)
;
}
void
nsCSSFrameConstructor
:
:
CheckForFirstLineInsertion
(
nsIFrame
*
aParentFrame
nsFrameItems
&
aFrameItems
)
{
MOZ_ASSERT
(
aParentFrame
-
>
Style
(
)
-
>
HasPseudoElementData
(
)
"
Why
were
we
called
?
"
)
;
if
(
aFrameItems
.
IsEmpty
(
)
)
{
return
;
}
class
RestyleManager
*
restyleManager
=
RestyleManager
(
)
;
nsIFrame
*
ancestor
=
aParentFrame
;
while
(
ancestor
)
{
if
(
!
ancestor
-
>
Style
(
)
-
>
HasPseudoElementData
(
)
)
{
return
;
}
if
(
!
ancestor
-
>
IsLineFrame
(
)
)
{
ancestor
=
ancestor
-
>
GetParent
(
)
;
continue
;
}
if
(
!
ancestor
-
>
Style
(
)
-
>
IsPseudoElement
(
)
)
{
return
;
}
for
(
nsIFrame
*
f
:
aFrameItems
)
{
restyleManager
-
>
ReparentComputedStyleForFirstLine
(
f
)
;
}
return
;
}
}
static
int32_t
FirstLetterCount
(
const
nsTextFragment
*
aFragment
)
{
int32_t
count
=
0
;
int32_t
firstLetterLength
=
0
;
int32_t
i
n
=
aFragment
-
>
GetLength
(
)
;
for
(
i
=
0
;
i
<
n
;
i
+
+
)
{
char16_t
ch
=
aFragment
-
>
CharAt
(
i
)
;
if
(
dom
:
:
IsSpaceCharacter
(
ch
)
)
{
if
(
firstLetterLength
)
{
break
;
}
count
+
+
;
continue
;
}
if
(
(
ch
=
=
'
\
'
'
)
|
|
(
ch
=
=
'
\
"
'
)
)
{
if
(
firstLetterLength
)
{
break
;
}
firstLetterLength
=
1
;
}
else
{
count
+
+
;
break
;
}
}
return
count
;
}
static
bool
NeedFirstLetterContinuation
(
nsIContent
*
aContent
)
{
MOZ_ASSERT
(
aContent
"
null
ptr
"
)
;
bool
result
=
false
;
if
(
aContent
)
{
const
nsTextFragment
*
frag
=
aContent
-
>
GetText
(
)
;
if
(
frag
)
{
int32_t
flc
=
FirstLetterCount
(
frag
)
;
int32_t
tl
=
frag
-
>
GetLength
(
)
;
if
(
flc
<
tl
)
{
result
=
true
;
}
}
}
return
result
;
}
static
bool
IsFirstLetterContent
(
nsIContent
*
aContent
)
{
return
aContent
-
>
TextLength
(
)
&
&
!
aContent
-
>
TextIsOnlyWhitespace
(
)
;
}
nsFirstLetterFrame
*
nsCSSFrameConstructor
:
:
CreateFloatingLetterFrame
(
nsFrameConstructorState
&
aState
nsIContent
*
aTextContent
nsIFrame
*
aTextFrame
nsContainerFrame
*
aParentFrame
ComputedStyle
*
aParentComputedStyle
ComputedStyle
*
aComputedStyle
nsFrameItems
&
aResult
)
{
MOZ_ASSERT
(
aParentComputedStyle
)
;
nsFirstLetterFrame
*
letterFrame
=
NS_NewFirstLetterFrame
(
mPresShell
aComputedStyle
)
;
nsIContent
*
letterContent
=
aParentFrame
-
>
GetContent
(
)
;
nsContainerFrame
*
containingBlock
=
aState
.
GetGeometricParent
(
aComputedStyle
-
>
StyleDisplay
(
)
aParentFrame
)
;
InitAndRestoreFrame
(
aState
letterContent
containingBlock
letterFrame
)
;
ServoStyleSet
*
styleSet
=
mPresShell
-
>
StyleSet
(
)
;
RefPtr
<
ComputedStyle
>
textSC
=
styleSet
-
>
ResolveStyleForText
(
aTextContent
aComputedStyle
)
;
aTextFrame
-
>
SetComputedStyleWithoutNotification
(
textSC
)
;
InitAndRestoreFrame
(
aState
aTextContent
letterFrame
aTextFrame
)
;
SetInitialSingleChild
(
letterFrame
aTextFrame
)
;
nsIFrame
*
nextTextFrame
=
nullptr
;
if
(
NeedFirstLetterContinuation
(
aTextContent
)
)
{
nextTextFrame
=
CreateContinuingFrame
(
aState
.
mPresContext
aTextFrame
aParentFrame
)
;
RefPtr
<
ComputedStyle
>
newSC
=
styleSet
-
>
ResolveStyleForText
(
aTextContent
aParentComputedStyle
)
;
nextTextFrame
-
>
SetComputedStyle
(
newSC
)
;
}
NS_ASSERTION
(
aResult
.
IsEmpty
(
)
"
aResult
should
be
an
empty
nsFrameItems
!
"
)
;
nsFrameList
:
:
FrameLinkEnumerator
link
(
aState
.
mFloatedItems
)
;
while
(
!
link
.
AtEnd
(
)
&
&
link
.
NextFrame
(
)
-
>
GetParent
(
)
!
=
containingBlock
)
{
link
.
Next
(
)
;
}
aState
.
AddChild
(
letterFrame
aResult
letterContent
aParentFrame
false
true
false
true
link
.
PrevFrame
(
)
)
;
if
(
nextTextFrame
)
{
aResult
.
AddChild
(
nextTextFrame
)
;
}
return
letterFrame
;
}
void
nsCSSFrameConstructor
:
:
CreateLetterFrame
(
nsContainerFrame
*
aBlockFrame
nsContainerFrame
*
aBlockContinuation
nsIContent
*
aTextContent
nsContainerFrame
*
aParentFrame
nsFrameItems
&
aResult
)
{
MOZ_ASSERT
(
aTextContent
-
>
IsText
(
)
"
aTextContent
isn
'
t
text
"
)
;
NS_ASSERTION
(
nsLayoutUtils
:
:
GetAsBlock
(
aBlockFrame
)
"
Not
a
block
frame
?
"
)
;
nsIFrame
*
parentFrame
=
nsFrame
:
:
CorrectStyleParentFrame
(
aParentFrame
nsCSSPseudoElements
:
:
firstLetter
)
;
ComputedStyle
*
parentComputedStyle
=
parentFrame
-
>
Style
(
)
;
nsIContent
*
blockContent
=
aBlockFrame
-
>
GetContent
(
)
;
RefPtr
<
ComputedStyle
>
sc
=
GetFirstLetterStyle
(
blockContent
parentComputedStyle
)
;
if
(
sc
)
{
if
(
parentFrame
-
>
IsLineFrame
(
)
)
{
nsIFrame
*
parentIgnoringFirstLine
=
nsFrame
:
:
CorrectStyleParentFrame
(
aBlockFrame
nsCSSPseudoElements
:
:
firstLetter
)
;
sc
=
mPresShell
-
>
StyleSet
(
)
-
>
ReparentComputedStyle
(
sc
parentComputedStyle
parentIgnoringFirstLine
-
>
Style
(
)
parentComputedStyle
blockContent
-
>
AsElement
(
)
)
;
}
RefPtr
<
ComputedStyle
>
textSC
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveStyleForText
(
aTextContent
sc
)
;
aTextContent
-
>
SetPrimaryFrame
(
nullptr
)
;
nsIFrame
*
textFrame
=
NS_NewTextFrame
(
mPresShell
textSC
)
;
NS_ASSERTION
(
aBlockContinuation
=
=
GetFloatContainingBlock
(
aParentFrame
)
"
Containing
block
is
confused
"
)
;
nsFrameConstructorState
state
(
mPresShell
GetAbsoluteContainingBlock
(
aParentFrame
FIXED_POS
)
GetAbsoluteContainingBlock
(
aParentFrame
ABS_POS
)
aBlockContinuation
)
;
const
nsStyleDisplay
*
display
=
sc
-
>
StyleDisplay
(
)
;
nsFirstLetterFrame
*
letterFrame
;
if
(
display
-
>
IsFloatingStyle
(
)
&
&
!
nsSVGUtils
:
:
IsInSVGTextSubtree
(
aParentFrame
)
)
{
letterFrame
=
CreateFloatingLetterFrame
(
state
aTextContent
textFrame
aParentFrame
parentComputedStyle
sc
aResult
)
;
}
else
{
letterFrame
=
NS_NewFirstLetterFrame
(
mPresShell
sc
)
;
nsIContent
*
letterContent
=
aParentFrame
-
>
GetContent
(
)
;
letterFrame
-
>
Init
(
letterContent
aParentFrame
nullptr
)
;
InitAndRestoreFrame
(
state
aTextContent
letterFrame
textFrame
)
;
SetInitialSingleChild
(
letterFrame
textFrame
)
;
aResult
.
Clear
(
)
;
aResult
.
AddChild
(
letterFrame
)
;
NS_ASSERTION
(
!
aBlockFrame
-
>
GetPrevContinuation
(
)
"
should
have
the
first
continuation
here
"
)
;
aBlockFrame
-
>
AddStateBits
(
NS_BLOCK_HAS_FIRST_LETTER_CHILD
)
;
}
MOZ_ASSERT
(
!
aBlockFrame
-
>
GetPrevContinuation
(
)
"
Setting
up
a
first
-
letter
frame
on
a
non
-
first
block
continuation
?
"
)
;
auto
parent
=
static_cast
<
nsContainerFrame
*
>
(
aParentFrame
-
>
FirstContinuation
(
)
)
;
parent
-
>
SetHasFirstLetterChild
(
)
;
aBlockFrame
-
>
SetProperty
(
nsContainerFrame
:
:
FirstLetterProperty
(
)
letterFrame
)
;
aTextContent
-
>
SetPrimaryFrame
(
textFrame
)
;
}
}
void
nsCSSFrameConstructor
:
:
WrapFramesInFirstLetterFrame
(
nsContainerFrame
*
aBlockFrame
nsFrameItems
&
aBlockFrames
)
{
aBlockFrame
-
>
AddStateBits
(
NS_BLOCK_HAS_FIRST_LETTER_STYLE
)
;
nsContainerFrame
*
parentFrame
=
nullptr
;
nsIFrame
*
textFrame
=
nullptr
;
nsIFrame
*
prevFrame
=
nullptr
;
nsFrameItems
letterFrames
;
bool
stopLooking
=
false
;
WrapFramesInFirstLetterFrame
(
aBlockFrame
aBlockFrame
aBlockFrame
aBlockFrames
.
FirstChild
(
)
&
parentFrame
&
textFrame
&
prevFrame
letterFrames
&
stopLooking
)
;
if
(
parentFrame
)
{
if
(
parentFrame
=
=
aBlockFrame
)
{
aBlockFrames
.
DestroyFrame
(
textFrame
)
;
aBlockFrames
.
InsertFrames
(
nullptr
prevFrame
letterFrames
)
;
}
else
{
RemoveFrame
(
kPrincipalList
textFrame
)
;
parentFrame
-
>
InsertFrames
(
kPrincipalList
prevFrame
letterFrames
)
;
}
}
}
void
nsCSSFrameConstructor
:
:
WrapFramesInFirstLetterFrame
(
nsContainerFrame
*
aBlockFrame
nsContainerFrame
*
aBlockContinuation
nsContainerFrame
*
aParentFrame
nsIFrame
*
aParentFrameList
nsContainerFrame
*
*
aModifiedParent
nsIFrame
*
*
aTextFrame
nsIFrame
*
*
aPrevFrame
nsFrameItems
&
aLetterFrames
bool
*
aStopLooking
)
{
nsIFrame
*
prevFrame
=
nullptr
;
nsIFrame
*
frame
=
aParentFrameList
;
while
(
frame
)
{
nsIFrame
*
nextFrame
=
frame
-
>
GetNextSibling
(
)
;
LayoutFrameType
frameType
=
frame
-
>
Type
(
)
;
if
(
LayoutFrameType
:
:
Text
=
=
frameType
)
{
nsIContent
*
textContent
=
frame
-
>
GetContent
(
)
;
if
(
IsFirstLetterContent
(
textContent
)
)
{
CreateLetterFrame
(
aBlockFrame
aBlockContinuation
textContent
aParentFrame
aLetterFrames
)
;
*
aModifiedParent
=
aParentFrame
;
*
aTextFrame
=
frame
;
*
aPrevFrame
=
prevFrame
;
*
aStopLooking
=
true
;
return
;
}
}
else
if
(
IsInlineFrame
(
frame
)
&
&
frameType
!
=
LayoutFrameType
:
:
Br
)
{
nsIFrame
*
kids
=
frame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
WrapFramesInFirstLetterFrame
(
aBlockFrame
aBlockContinuation
static_cast
<
nsContainerFrame
*
>
(
frame
)
kids
aModifiedParent
aTextFrame
aPrevFrame
aLetterFrames
aStopLooking
)
;
if
(
*
aStopLooking
)
{
return
;
}
}
else
{
*
aStopLooking
=
true
;
break
;
}
prevFrame
=
frame
;
frame
=
nextFrame
;
}
}
static
nsIFrame
*
FindFirstLetterFrame
(
nsIFrame
*
aFrame
nsIFrame
:
:
ChildListID
aListID
)
{
nsFrameList
list
=
aFrame
-
>
GetChildList
(
aListID
)
;
for
(
nsFrameList
:
:
Enumerator
e
(
list
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
)
{
if
(
e
.
get
(
)
-
>
IsLetterFrame
(
)
)
{
return
e
.
get
(
)
;
}
}
return
nullptr
;
}
void
nsCSSFrameConstructor
:
:
RemoveFloatingFirstLetterFrames
(
nsIPresShell
*
aPresShell
nsIFrame
*
aBlockFrame
)
{
nsIFrame
*
floatFrame
=
:
:
FindFirstLetterFrame
(
aBlockFrame
nsIFrame
:
:
kFloatList
)
;
if
(
!
floatFrame
)
{
floatFrame
=
:
:
FindFirstLetterFrame
(
aBlockFrame
nsIFrame
:
:
kPushedFloatsList
)
;
if
(
!
floatFrame
)
{
return
;
}
}
nsIFrame
*
textFrame
=
floatFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
!
textFrame
)
{
return
;
}
nsPlaceholderFrame
*
placeholderFrame
=
floatFrame
-
>
GetPlaceholderFrame
(
)
;
if
(
!
placeholderFrame
)
{
return
;
}
nsContainerFrame
*
parentFrame
=
placeholderFrame
-
>
GetParent
(
)
;
if
(
!
parentFrame
)
{
return
;
}
static_cast
<
nsContainerFrame
*
>
(
parentFrame
-
>
FirstContinuation
(
)
)
-
>
ClearHasFirstLetterChild
(
)
;
ComputedStyle
*
parentSC
=
parentFrame
-
>
Style
(
)
;
nsIContent
*
textContent
=
textFrame
-
>
GetContent
(
)
;
if
(
!
textContent
)
{
return
;
}
RefPtr
<
ComputedStyle
>
newSC
=
aPresShell
-
>
StyleSet
(
)
-
>
ResolveStyleForText
(
textContent
parentSC
)
;
nsIFrame
*
newTextFrame
=
NS_NewTextFrame
(
aPresShell
newSC
)
;
newTextFrame
-
>
Init
(
textContent
parentFrame
nullptr
)
;
nsIFrame
*
frameToDelete
=
textFrame
-
>
LastContinuation
(
)
;
while
(
frameToDelete
!
=
textFrame
)
{
nsIFrame
*
nextFrameToDelete
=
frameToDelete
-
>
GetPrevContinuation
(
)
;
RemoveFrame
(
kPrincipalList
frameToDelete
)
;
frameToDelete
=
nextFrameToDelete
;
}
nsIFrame
*
prevSibling
=
placeholderFrame
-
>
GetPrevSibling
(
)
;
#
ifdef
NOISY_FIRST_LETTER
printf
(
"
RemoveFloatingFirstLetterFrames
:
textContent
=
%
p
oldTextFrame
=
%
p
newTextFrame
=
%
p
\
n
"
textContent
.
get
(
)
textFrame
newTextFrame
)
;
#
endif
RemoveFrame
(
kPrincipalList
placeholderFrame
)
;
textContent
-
>
SetPrimaryFrame
(
newTextFrame
)
;
bool
offsetsNeedFixing
=
prevSibling
&
&
prevSibling
-
>
IsTextFrame
(
)
;
if
(
offsetsNeedFixing
)
{
prevSibling
-
>
AddStateBits
(
TEXT_OFFSETS_NEED_FIXING
)
;
}
nsFrameList
textList
(
newTextFrame
newTextFrame
)
;
InsertFrames
(
parentFrame
kPrincipalList
prevSibling
textList
)
;
if
(
offsetsNeedFixing
)
{
prevSibling
-
>
RemoveStateBits
(
TEXT_OFFSETS_NEED_FIXING
)
;
}
}
void
nsCSSFrameConstructor
:
:
RemoveFirstLetterFrames
(
nsIPresShell
*
aPresShell
nsContainerFrame
*
aFrame
nsContainerFrame
*
aBlockFrame
bool
*
aStopLooking
)
{
nsIFrame
*
prevSibling
=
nullptr
;
nsIFrame
*
kid
=
aFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
while
(
kid
)
{
if
(
kid
-
>
IsLetterFrame
(
)
)
{
static_cast
<
nsContainerFrame
*
>
(
aFrame
-
>
FirstContinuation
(
)
)
-
>
ClearHasFirstLetterChild
(
)
;
nsIFrame
*
textFrame
=
kid
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
!
textFrame
)
{
break
;
}
ComputedStyle
*
parentSC
=
aFrame
-
>
Style
(
)
;
if
(
!
parentSC
)
{
break
;
}
nsIContent
*
textContent
=
textFrame
-
>
GetContent
(
)
;
if
(
!
textContent
)
{
break
;
}
RefPtr
<
ComputedStyle
>
newSC
=
aPresShell
-
>
StyleSet
(
)
-
>
ResolveStyleForText
(
textContent
parentSC
)
;
textFrame
=
NS_NewTextFrame
(
aPresShell
newSC
)
;
textFrame
-
>
Init
(
textContent
aFrame
nullptr
)
;
RemoveFrame
(
kPrincipalList
kid
)
;
textContent
-
>
SetPrimaryFrame
(
textFrame
)
;
bool
offsetsNeedFixing
=
prevSibling
&
&
prevSibling
-
>
IsTextFrame
(
)
;
if
(
offsetsNeedFixing
)
{
prevSibling
-
>
AddStateBits
(
TEXT_OFFSETS_NEED_FIXING
)
;
}
nsFrameList
textList
(
textFrame
textFrame
)
;
InsertFrames
(
aFrame
kPrincipalList
prevSibling
textList
)
;
if
(
offsetsNeedFixing
)
{
prevSibling
-
>
RemoveStateBits
(
TEXT_OFFSETS_NEED_FIXING
)
;
}
*
aStopLooking
=
true
;
NS_ASSERTION
(
!
aBlockFrame
-
>
GetPrevContinuation
(
)
"
should
have
the
first
continuation
here
"
)
;
aBlockFrame
-
>
RemoveStateBits
(
NS_BLOCK_HAS_FIRST_LETTER_CHILD
)
;
break
;
}
else
if
(
IsInlineFrame
(
kid
)
)
{
nsContainerFrame
*
kidAsContainerFrame
=
do_QueryFrame
(
kid
)
;
if
(
kidAsContainerFrame
)
{
RemoveFirstLetterFrames
(
aPresShell
kidAsContainerFrame
aBlockFrame
aStopLooking
)
;
if
(
*
aStopLooking
)
{
break
;
}
}
}
prevSibling
=
kid
;
kid
=
kid
-
>
GetNextSibling
(
)
;
}
}
void
nsCSSFrameConstructor
:
:
RemoveLetterFrames
(
nsIPresShell
*
aPresShell
nsContainerFrame
*
aBlockFrame
)
{
aBlockFrame
=
static_cast
<
nsContainerFrame
*
>
(
aBlockFrame
-
>
FirstContinuation
(
)
)
;
aBlockFrame
-
>
RemoveProperty
(
nsContainerFrame
:
:
FirstLetterProperty
(
)
)
;
nsContainerFrame
*
continuation
=
aBlockFrame
;
bool
stopLooking
=
false
;
do
{
RemoveFloatingFirstLetterFrames
(
aPresShell
continuation
)
;
RemoveFirstLetterFrames
(
aPresShell
continuation
aBlockFrame
&
stopLooking
)
;
if
(
stopLooking
)
{
break
;
}
continuation
=
static_cast
<
nsContainerFrame
*
>
(
continuation
-
>
GetNextContinuation
(
)
)
;
}
while
(
continuation
)
;
}
void
nsCSSFrameConstructor
:
:
RecoverLetterFrames
(
nsContainerFrame
*
aBlockFrame
)
{
aBlockFrame
=
static_cast
<
nsContainerFrame
*
>
(
aBlockFrame
-
>
FirstContinuation
(
)
)
;
nsContainerFrame
*
continuation
=
aBlockFrame
;
nsContainerFrame
*
parentFrame
=
nullptr
;
nsIFrame
*
textFrame
=
nullptr
;
nsIFrame
*
prevFrame
=
nullptr
;
nsFrameItems
letterFrames
;
bool
stopLooking
=
false
;
do
{
continuation
-
>
AddStateBits
(
NS_BLOCK_HAS_FIRST_LETTER_STYLE
)
;
WrapFramesInFirstLetterFrame
(
aBlockFrame
continuation
continuation
continuation
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
&
parentFrame
&
textFrame
&
prevFrame
letterFrames
&
stopLooking
)
;
if
(
stopLooking
)
{
break
;
}
continuation
=
static_cast
<
nsContainerFrame
*
>
(
continuation
-
>
GetNextContinuation
(
)
)
;
}
while
(
continuation
)
;
if
(
parentFrame
)
{
RemoveFrame
(
kPrincipalList
textFrame
)
;
parentFrame
-
>
InsertFrames
(
kPrincipalList
prevFrame
letterFrames
)
;
}
}
void
nsCSSFrameConstructor
:
:
CreateListBoxContent
(
nsContainerFrame
*
aParentFrame
nsIFrame
*
aPrevFrame
nsIContent
*
aChild
nsIFrame
*
*
aNewFrame
bool
aIsAppend
)
{
#
ifdef
MOZ_XUL
if
(
aParentFrame
)
{
nsFrameItems
frameItems
;
nsFrameConstructorState
state
(
mPresShell
GetAbsoluteContainingBlock
(
aParentFrame
FIXED_POS
)
GetAbsoluteContainingBlock
(
aParentFrame
ABS_POS
)
GetFloatContainingBlock
(
aParentFrame
)
do_AddRef
(
mTempFrameTreeState
)
)
;
if
(
aChild
-
>
IsElement
(
)
&
&
!
aChild
-
>
AsElement
(
)
-
>
HasServoData
(
)
)
{
mPresShell
-
>
StyleSet
(
)
-
>
StyleNewSubtree
(
aChild
-
>
AsElement
(
)
)
;
}
RefPtr
<
ComputedStyle
>
computedStyle
=
ResolveComputedStyle
(
aChild
)
;
const
nsStyleDisplay
*
display
=
computedStyle
-
>
StyleDisplay
(
)
;
if
(
StyleDisplay
:
:
None
=
=
display
-
>
mDisplay
)
{
*
aNewFrame
=
nullptr
;
return
;
}
AutoFrameConstructionItemList
items
(
this
)
;
AddFrameConstructionItemsInternal
(
state
aChild
aParentFrame
true
computedStyle
ITEM_ALLOW_XBL_BASE
nullptr
items
)
;
ConstructFramesFromItemList
(
state
items
aParentFrame
false
frameItems
)
;
nsIFrame
*
newFrame
=
frameItems
.
FirstChild
(
)
;
*
aNewFrame
=
newFrame
;
if
(
newFrame
)
{
if
(
aIsAppend
)
(
(
nsListBoxBodyFrame
*
)
aParentFrame
)
-
>
ListBoxAppendFrames
(
frameItems
)
;
else
(
(
nsListBoxBodyFrame
*
)
aParentFrame
)
-
>
ListBoxInsertFrames
(
aPrevFrame
frameItems
)
;
}
#
ifdef
ACCESSIBILITY
if
(
newFrame
)
{
nsAccessibilityService
*
accService
=
nsIPresShell
:
:
AccService
(
)
;
if
(
accService
)
{
accService
-
>
ContentRangeInserted
(
mPresShell
aChild
aChild
-
>
GetNextSibling
(
)
)
;
}
}
#
endif
}
#
endif
}
void
nsCSSFrameConstructor
:
:
ConstructBlock
(
nsFrameConstructorState
&
aState
nsIContent
*
aContent
nsContainerFrame
*
aParentFrame
nsContainerFrame
*
aContentParentFrame
ComputedStyle
*
aComputedStyle
nsContainerFrame
*
*
aNewFrame
nsFrameItems
&
aFrameItems
nsIFrame
*
aPositionedFrameForAbsPosContainer
PendingBinding
*
aPendingBinding
)
{
nsContainerFrame
*
blockFrame
=
*
aNewFrame
;
NS_ASSERTION
(
(
blockFrame
-
>
IsBlockFrame
(
)
|
|
blockFrame
-
>
IsDetailsFrame
(
)
)
"
not
a
block
frame
nor
a
details
frame
?
"
)
;
nsContainerFrame
*
parent
=
aParentFrame
;
RefPtr
<
ComputedStyle
>
blockStyle
=
aComputedStyle
;
const
nsStyleColumn
*
columns
=
aComputedStyle
-
>
StyleColumn
(
)
;
if
(
columns
-
>
mColumnCount
!
=
NS_STYLE_COLUMN_COUNT_AUTO
|
|
columns
-
>
mColumnWidth
.
GetUnit
(
)
!
=
eStyleUnit_Auto
)
{
nsContainerFrame
*
columnSetFrame
=
NS_NewColumnSetFrame
(
mPresShell
aComputedStyle
nsFrameState
(
NS_FRAME_OWNS_ANON_BOXES
)
)
;
InitAndRestoreFrame
(
aState
aContent
aParentFrame
columnSetFrame
)
;
blockStyle
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveInheritingAnonymousBoxStyle
(
nsCSSAnonBoxes
:
:
columnContent
aComputedStyle
)
;
parent
=
columnSetFrame
;
*
aNewFrame
=
columnSetFrame
;
if
(
aPositionedFrameForAbsPosContainer
=
=
blockFrame
)
{
aPositionedFrameForAbsPosContainer
=
columnSetFrame
;
}
SetInitialSingleChild
(
columnSetFrame
blockFrame
)
;
}
blockFrame
-
>
SetComputedStyleWithoutNotification
(
blockStyle
)
;
InitAndRestoreFrame
(
aState
aContent
parent
blockFrame
)
;
aState
.
AddChild
(
*
aNewFrame
aFrameItems
aContent
aContentParentFrame
?
aContentParentFrame
:
aParentFrame
)
;
if
(
!
mRootElementFrame
)
{
mRootElementFrame
=
*
aNewFrame
;
}
nsFrameConstructorSaveState
absoluteSaveState
;
(
*
aNewFrame
)
-
>
AddStateBits
(
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
;
if
(
aPositionedFrameForAbsPosContainer
)
{
aState
.
PushAbsoluteContainingBlock
(
*
aNewFrame
aPositionedFrameForAbsPosContainer
absoluteSaveState
)
;
}
nsFrameItems
childItems
;
ProcessChildren
(
aState
aContent
aComputedStyle
blockFrame
true
childItems
true
aPendingBinding
)
;
blockFrame
-
>
SetInitialChildList
(
kPrincipalList
childItems
)
;
}
nsIFrame
*
nsCSSFrameConstructor
:
:
ConstructInline
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aItem
nsContainerFrame
*
aParentFrame
const
nsStyleDisplay
*
aDisplay
nsFrameItems
&
aFrameItems
)
{
nsIContent
*
const
content
=
aItem
.
mContent
;
ComputedStyle
*
const
computedStyle
=
aItem
.
mComputedStyle
;
bool
positioned
=
StyleDisplay
:
:
Inline
=
=
aDisplay
-
>
mDisplay
&
&
aDisplay
-
>
IsRelativelyPositionedStyle
(
)
&
&
!
nsSVGUtils
:
:
IsInSVGTextSubtree
(
aParentFrame
)
;
nsInlineFrame
*
newFrame
=
NS_NewInlineFrame
(
mPresShell
computedStyle
)
;
InitAndRestoreFrame
(
aState
content
aParentFrame
newFrame
)
;
newFrame
-
>
AddStateBits
(
NS_FRAME_MAY_HAVE_GENERATED_CONTENT
)
;
nsFrameConstructorSaveState
absoluteSaveState
;
newFrame
-
>
AddStateBits
(
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
;
if
(
positioned
)
{
aState
.
PushAbsoluteContainingBlock
(
newFrame
newFrame
absoluteSaveState
)
;
}
nsFrameItems
childItems
;
ConstructFramesFromItemList
(
aState
aItem
.
mChildItems
newFrame
false
childItems
)
;
nsFrameList
:
:
FrameLinkEnumerator
firstBlockEnumerator
(
childItems
)
;
if
(
!
aItem
.
mIsAllInline
)
{
FindFirstBlock
(
firstBlockEnumerator
)
;
}
if
(
aItem
.
mIsAllInline
|
|
firstBlockEnumerator
.
AtEnd
(
)
)
{
newFrame
-
>
SetInitialChildList
(
kPrincipalList
childItems
)
;
aState
.
AddChild
(
newFrame
aFrameItems
content
aParentFrame
)
;
return
newFrame
;
}
nsFrameList
firstInlineKids
=
childItems
.
ExtractHead
(
firstBlockEnumerator
)
;
newFrame
-
>
SetInitialChildList
(
kPrincipalList
firstInlineKids
)
;
aFrameItems
.
AddChild
(
newFrame
)
;
newFrame
-
>
AddStateBits
(
NS_FRAME_OWNS_ANON_BOXES
)
;
CreateIBSiblings
(
aState
newFrame
positioned
childItems
aFrameItems
)
;
return
newFrame
;
}
void
nsCSSFrameConstructor
:
:
CreateIBSiblings
(
nsFrameConstructorState
&
aState
nsContainerFrame
*
aInitialInline
bool
aIsPositioned
nsFrameItems
&
aChildItems
nsFrameItems
&
aSiblings
)
{
nsIContent
*
content
=
aInitialInline
-
>
GetContent
(
)
;
ComputedStyle
*
computedStyle
=
aInitialInline
-
>
Style
(
)
;
nsContainerFrame
*
parentFrame
=
aInitialInline
-
>
GetParent
(
)
;
RefPtr
<
ComputedStyle
>
blockSC
=
mPresShell
-
>
StyleSet
(
)
-
>
ResolveInheritingAnonymousBoxStyle
(
nsCSSAnonBoxes
:
:
mozBlockInsideInlineWrapper
computedStyle
)
;
nsContainerFrame
*
lastNewInline
=
static_cast
<
nsContainerFrame
*
>
(
aInitialInline
-
>
FirstContinuation
(
)
)
;
do
{
MOZ_ASSERT
(
aChildItems
.
NotEmpty
(
)
"
Should
have
child
items
"
)
;
MOZ_ASSERT
(
!
aChildItems
.
FirstChild
(
)
-
>
IsInlineOutside
(
)
"
Must
have
list
starting
with
block
"
)
;
nsBlockFrame
*
blockFrame
=
NS_NewBlockFrame
(
mPresShell
blockSC
)
;
InitAndRestoreFrame
(
aState
content
parentFrame
blockFrame
false
)
;
nsFrameList
:
:
FrameLinkEnumerator
firstNonBlock
=
FindFirstNonBlock
(
aChildItems
)
;
nsFrameList
blockKids
=
aChildItems
.
ExtractHead
(
firstNonBlock
)
;
MoveChildrenTo
(
aInitialInline
blockFrame
blockKids
)
;
SetFrameIsIBSplit
(
lastNewInline
blockFrame
)
;
aSiblings
.
AddChild
(
blockFrame
)
;
nsInlineFrame
*
inlineFrame
=
NS_NewInlineFrame
(
mPresShell
computedStyle
)
;
InitAndRestoreFrame
(
aState
content
parentFrame
inlineFrame
false
)
;
inlineFrame
-
>
AddStateBits
(
NS_FRAME_MAY_HAVE_GENERATED_CONTENT
|
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
;
if
(
aIsPositioned
)
{
inlineFrame
-
>
MarkAsAbsoluteContainingBlock
(
)
;
}
if
(
aChildItems
.
NotEmpty
(
)
)
{
nsFrameList
:
:
FrameLinkEnumerator
firstBlock
(
aChildItems
)
;
FindFirstBlock
(
firstBlock
)
;
nsFrameList
inlineKids
=
aChildItems
.
ExtractHead
(
firstBlock
)
;
MoveChildrenTo
(
aInitialInline
inlineFrame
inlineKids
)
;
}
SetFrameIsIBSplit
(
blockFrame
inlineFrame
)
;
aSiblings
.
AddChild
(
inlineFrame
)
;
lastNewInline
=
inlineFrame
;
}
while
(
aChildItems
.
NotEmpty
(
)
)
;
SetFrameIsIBSplit
(
lastNewInline
nullptr
)
;
}
void
nsCSSFrameConstructor
:
:
BuildInlineChildItems
(
nsFrameConstructorState
&
aState
FrameConstructionItem
&
aParentItem
bool
aItemIsWithinSVGText
bool
aItemAllowsTextPathChild
)
{
nsFrameConstructorState
:
:
PendingBindingAutoPusher
pusher
(
aState
aParentItem
.
mPendingBinding
)
;
ComputedStyle
*
const
parentComputedStyle
=
aParentItem
.
mComputedStyle
;
nsIContent
*
const
parentContent
=
aParentItem
.
mContent
;
if
(
!
aItemIsWithinSVGText
)
{
CreateGeneratedContentItem
(
aState
nullptr
parentContent
-
>
AsElement
(
)
parentComputedStyle
CSSPseudoElementType
:
:
before
aParentItem
.
mChildItems
)
;
}
uint32_t
flags
=
ITEM_ALLOW_XBL_BASE
|
ITEM_ALLOW_PAGE_BREAK
;
if
(
aItemIsWithinSVGText
)
{
flags
|
=
ITEM_IS_WITHIN_SVG_TEXT
;
}
if
(
aItemAllowsTextPathChild
&
&
aParentItem
.
mIsForSVGAElement
)
{
flags
|
=
ITEM_ALLOWS_TEXT_PATH_CHILD
;
}
if
(
!
aParentItem
.
mAnonChildren
.
IsEmpty
(
)
)
{
AddFCItemsForAnonymousContent
(
aState
nullptr
aParentItem
.
mAnonChildren
aParentItem
.
mChildItems
flags
)
;
}
else
{
FlattenedChildIterator
iter
(
parentContent
)
;
for
(
nsIContent
*
content
=
iter
.
GetNextChild
(
)
;
content
;
content
=
iter
.
GetNextChild
(
)
)
{
content
-
>
UnsetFlags
(
NODE_DESCENDANTS_NEED_FRAMES
|
NODE_NEEDS_FRAME
)
;
if
(
content
-
>
IsComment
(
)
|
|
content
-
>
IsProcessingInstruction
(
)
)
{
continue
;
}
RefPtr
<
ComputedStyle
>
childContext
=
ResolveComputedStyle
(
content
)
;
AddFrameConstructionItemsInternal
(
aState
content
nullptr
iter
.
XBLInvolved
(
)
childContext
flags
nullptr
aParentItem
.
mChildItems
)
;
}
}
if
(
!
aItemIsWithinSVGText
)
{
CreateGeneratedContentItem
(
aState
nullptr
parentContent
-
>
AsElement
(
)
parentComputedStyle
CSSPseudoElementType
:
:
after
aParentItem
.
mChildItems
)
;
}
aParentItem
.
mIsAllInline
=
aParentItem
.
mChildItems
.
AreAllItemsInline
(
)
;
}
static
bool
IsSafeToAppendToIBSplitInline
(
nsIFrame
*
aParentFrame
nsIFrame
*
aNextSibling
)
{
MOZ_ASSERT
(
IsInlineFrame
(
aParentFrame
)
"
Must
have
an
inline
parent
here
"
)
;
do
{
NS_ASSERTION
(
IsFramePartOfIBSplit
(
aParentFrame
)
"
How
is
this
not
part
of
an
ib
-
split
?
"
)
;
if
(
aNextSibling
|
|
aParentFrame
-
>
GetNextContinuation
(
)
|
|
GetIBSplitSibling
(
aParentFrame
)
)
{
return
false
;
}
aNextSibling
=
aParentFrame
-
>
GetNextSibling
(
)
;
aParentFrame
=
aParentFrame
-
>
GetParent
(
)
;
}
while
(
IsInlineFrame
(
aParentFrame
)
)
;
return
true
;
}
bool
nsCSSFrameConstructor
:
:
WipeContainingBlock
(
nsFrameConstructorState
&
aState
nsIFrame
*
aContainingBlock
nsIFrame
*
aFrame
FrameConstructionItemList
&
aItems
bool
aIsAppend
nsIFrame
*
aPrevSibling
)
{
if
(
aItems
.
IsEmpty
(
)
)
{
return
false
;
}
if
(
aFrame
-
>
IsXULBoxFrame
(
)
&
&
!
(
aFrame
-
>
GetStateBits
(
)
&
NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK
)
&
&
aItems
.
AnyItemsNeedBlockParent
(
)
)
{
RecreateFramesForContent
(
aFrame
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
return
true
;
}
nsIFrame
*
nextSibling
=
:
:
GetInsertNextSibling
(
aFrame
aPrevSibling
)
;
LayoutFrameType
frameType
=
aFrame
-
>
Type
(
)
;
if
(
frameType
=
=
LayoutFrameType
:
:
FlexContainer
|
|
frameType
=
=
LayoutFrameType
:
:
GridContainer
)
{
FCItemIterator
iter
(
aItems
)
;
const
bool
isLegacyBox
=
IsFlexContainerForLegacyBox
(
aFrame
)
;
if
(
aPrevSibling
&
&
IsAnonymousFlexOrGridItem
(
aPrevSibling
)
&
&
iter
.
item
(
)
.
NeedsAnonFlexOrGridItem
(
aState
isLegacyBox
)
)
{
RecreateFramesForContent
(
aFrame
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
return
true
;
}
if
(
nextSibling
&
&
IsAnonymousFlexOrGridItem
(
nextSibling
)
)
{
iter
.
SetToEnd
(
)
;
iter
.
Prev
(
)
;
if
(
iter
.
item
(
)
.
NeedsAnonFlexOrGridItem
(
aState
isLegacyBox
)
)
{
RecreateFramesForContent
(
aFrame
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
return
true
;
}
}
}
if
(
IsAnonymousFlexOrGridItem
(
aFrame
)
)
{
AssertAnonymousFlexOrGridItemParent
(
aFrame
aFrame
-
>
GetParent
(
)
)
;
nsFrameConstructorSaveState
floatSaveState
;
aState
.
PushFloatContainingBlock
(
nullptr
floatSaveState
)
;
FCItemIterator
iter
(
aItems
)
;
nsIFrame
*
containerFrame
=
aFrame
-
>
GetParent
(
)
;
const
bool
isLegacyBox
=
IsFlexContainerForLegacyBox
(
containerFrame
)
;
if
(
!
iter
.
SkipItemsThatNeedAnonFlexOrGridItem
(
aState
isLegacyBox
)
)
{
RecreateFramesForContent
(
containerFrame
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
return
true
;
}
}
if
(
IsRubyPseudo
(
aFrame
)
|
|
frameType
=
=
LayoutFrameType
:
:
Ruby
|
|
RubyUtils
:
:
IsRubyContainerBox
(
frameType
)
)
{
RecreateFramesForContent
(
aFrame
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
return
true
;
}
ParentType
parentType
=
GetParentType
(
aFrame
)
;
if
(
!
aItems
.
AllWantParentType
(
parentType
)
)
{
if
(
parentType
!
=
eTypeBlock
&
&
!
aFrame
-
>
IsGeneratedContentFrame
(
)
)
{
FCItemIterator
iter
(
aItems
)
;
FCItemIterator
start
(
iter
)
;
do
{
if
(
iter
.
SkipItemsWantingParentType
(
parentType
)
)
{
break
;
}
if
(
!
iter
.
item
(
)
.
IsWhitespace
(
aState
)
)
{
break
;
}
if
(
iter
=
=
start
)
{
nsIFrame
*
prevSibling
=
aPrevSibling
;
if
(
!
prevSibling
)
{
nsIFrame
*
parentPrevCont
=
aFrame
-
>
GetPrevContinuation
(
)
;
while
(
parentPrevCont
)
{
prevSibling
=
parentPrevCont
-
>
GetChildList
(
kPrincipalList
)
.
LastChild
(
)
;
if
(
prevSibling
)
{
break
;
}
parentPrevCont
=
parentPrevCont
-
>
GetPrevContinuation
(
)
;
}
}
;
if
(
prevSibling
)
{
if
(
IsTablePseudo
(
prevSibling
)
)
{
break
;
}
}
else
if
(
IsTablePseudo
(
aFrame
)
)
{
break
;
}
}
FCItemIterator
spaceEndIter
(
iter
)
;
bool
trailingSpaces
=
spaceEndIter
.
SkipWhitespace
(
aState
)
;
bool
okToDrop
;
if
(
trailingSpaces
)
{
okToDrop
=
aIsAppend
&
&
!
nextSibling
;
if
(
!
okToDrop
)
{
if
(
!
nextSibling
)
{
nsIFrame
*
parentNextCont
=
aFrame
-
>
GetNextContinuation
(
)
;
while
(
parentNextCont
)
{
nextSibling
=
parentNextCont
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
nextSibling
)
{
break
;
}
parentNextCont
=
parentNextCont
-
>
GetNextContinuation
(
)
;
}
}
okToDrop
=
(
nextSibling
&
&
!
IsTablePseudo
(
nextSibling
)
)
|
|
(
!
nextSibling
&
&
!
IsTablePseudo
(
aFrame
)
)
;
}
#
ifdef
DEBUG
else
{
NS_ASSERTION
(
!
IsTablePseudo
(
aFrame
)
"
How
did
that
happen
?
"
)
;
}
#
endif
}
else
{
okToDrop
=
(
spaceEndIter
.
item
(
)
.
DesiredParentType
(
)
=
=
parentType
)
;
}
if
(
okToDrop
)
{
iter
.
DeleteItemsTo
(
this
spaceEndIter
)
;
}
else
{
break
;
}
}
while
(
!
iter
.
IsDone
(
)
)
;
}
if
(
aItems
.
IsEmpty
(
)
)
{
return
false
;
}
if
(
!
aItems
.
AllWantParentType
(
parentType
)
)
{
RecreateFramesForContent
(
aFrame
-
>
GetContent
(
)
InsertionKind
:
:
Async
)
;
return
true
;
}
}
do
{
if
(
IsInlineFrame
(
aFrame
)
)
{
if
(
aItems
.
AreAllItemsInline
(
)
)
{
return
false
;
}
if
(
!
IsFramePartOfIBSplit
(
aFrame
)
)
{
break
;
}
if
(
aIsAppend
&
&
IsSafeToAppendToIBSplitInline
(
aFrame
nextSibling
)
)
{
return
false
;
}
break
;
}
if
(
!
IsFramePartOfIBSplit
(
aFrame
)
)
{
return
false
;
}
if
(
aItems
.
AreAllItemsBlock
(
)
)
{
return
false
;
}
}
while
(
0
)
;
if
(
!
aContainingBlock
)
{
aContainingBlock
=
aFrame
;
}
while
(
IsFramePartOfIBSplit
(
aContainingBlock
)
|
|
aContainingBlock
-
>
IsInlineOutside
(
)
|
|
aContainingBlock
-
>
Style
(
)
-
>
GetPseudo
(
)
)
{
aContainingBlock
=
aContainingBlock
-
>
GetParent
(
)
;
NS_ASSERTION
(
aContainingBlock
"
Must
have
non
-
inline
non
-
ib
-
split
non
-
pseudo
frame
as
"
"
root
(
or
child
of
root
for
a
table
root
)
!
"
)
;
}
nsIContent
*
blockContent
=
aContainingBlock
-
>
GetContent
(
)
;
#
ifdef
DEBUG
if
(
gNoisyContentUpdates
)
{
printf
(
"
nsCSSFrameConstructor
:
:
WipeContainingBlock
:
blockContent
=
%
p
\
n
"
blockContent
)
;
}
#
endif
RecreateFramesForContent
(
blockContent
InsertionKind
:
:
Async
)
;
return
true
;
}
void
nsCSSFrameConstructor
:
:
ReframeContainingBlock
(
nsIFrame
*
aFrame
)
{
#
ifdef
DEBUG
if
(
gNoisyContentUpdates
)
{
printf
(
"
nsCSSFrameConstructor
:
:
ReframeContainingBlock
frame
=
%
p
\
n
"
aFrame
)
;
}
#
endif
if
(
mPresShell
-
>
IsReflowLocked
(
)
)
{
NS_ERROR
(
"
Atemptted
to
nsCSSFrameConstructor
:
:
ReframeContainingBlock
during
a
Reflow
!
!
!
"
)
;
return
;
}
nsIFrame
*
containingBlock
=
GetIBContainingBlockFor
(
aFrame
)
;
if
(
containingBlock
)
{
if
(
nsIContent
*
blockContent
=
containingBlock
-
>
GetContent
(
)
)
{
#
ifdef
DEBUG
if
(
gNoisyContentUpdates
)
{
printf
(
"
=
=
>
blockContent
=
%
p
\
n
"
blockContent
)
;
}
#
endif
RecreateFramesForContent
(
blockContent
-
>
AsElement
(
)
InsertionKind
:
:
Async
)
;
return
;
}
}
RecreateFramesForContent
(
mPresShell
-
>
GetDocument
(
)
-
>
GetRootElement
(
)
InsertionKind
:
:
Async
)
;
}
void
nsCSSFrameConstructor
:
:
GenerateChildFrames
(
nsContainerFrame
*
aFrame
)
{
{
nsAutoScriptBlocker
scriptBlocker
;
nsFrameItems
childItems
;
nsFrameConstructorState
state
(
mPresShell
nullptr
nullptr
nullptr
)
;
ProcessChildren
(
state
aFrame
-
>
GetContent
(
)
aFrame
-
>
Style
(
)
aFrame
false
childItems
false
nullptr
)
;
aFrame
-
>
SetInitialChildList
(
kPrincipalList
childItems
)
;
}
#
ifdef
ACCESSIBILITY
if
(
nsAccessibilityService
*
accService
=
nsIPresShell
:
:
AccService
(
)
)
{
if
(
nsIContent
*
child
=
aFrame
-
>
GetContent
(
)
-
>
GetFirstChild
(
)
)
{
accService
-
>
ContentRangeInserted
(
mPresShell
child
nullptr
)
;
}
}
#
endif
mPresShell
-
>
GetDocument
(
)
-
>
BindingManager
(
)
-
>
ProcessAttachedQueue
(
)
;
}
bool
nsCSSFrameConstructor
:
:
FrameConstructionItem
:
:
IsWhitespace
(
nsFrameConstructorState
&
aState
)
const
{
MOZ_ASSERT
(
aState
.
mCreatingExtraFrames
|
|
!
mContent
-
>
GetPrimaryFrame
(
)
"
How
did
that
happen
?
"
)
;
if
(
!
mIsText
)
{
return
false
;
}
mContent
-
>
SetFlags
(
NS_CREATE_FRAME_IF_NON_WHITESPACE
|
NS_REFRAME_IF_WHITESPACE
)
;
return
mContent
-
>
TextIsOnlyWhitespace
(
)
;
}
void
nsCSSFrameConstructor
:
:
FrameConstructionItemList
:
:
AdjustCountsForItem
(
FrameConstructionItem
*
aItem
int32_t
aDelta
)
{
MOZ_ASSERT
(
aDelta
=
=
1
|
|
aDelta
=
=
-
1
"
Unexpected
delta
"
)
;
mItemCount
+
=
aDelta
;
if
(
aItem
-
>
mIsAllInline
)
{
mInlineCount
+
=
aDelta
;
}
if
(
aItem
-
>
mIsBlock
)
{
mBlockCount
+
=
aDelta
;
}
if
(
aItem
-
>
mIsLineParticipant
)
{
mLineParticipantCount
+
=
aDelta
;
}
mDesiredParentCounts
[
aItem
-
>
DesiredParentType
(
)
]
+
=
aDelta
;
}
inline
bool
nsCSSFrameConstructor
:
:
FrameConstructionItemList
:
:
Iterator
:
:
SkipItemsWantingParentType
(
ParentType
aParentType
)
{
MOZ_ASSERT
(
!
IsDone
(
)
"
Shouldn
'
t
be
done
yet
"
)
;
while
(
item
(
)
.
DesiredParentType
(
)
=
=
aParentType
)
{
Next
(
)
;
if
(
IsDone
(
)
)
{
return
true
;
}
}
return
false
;
}
inline
bool
nsCSSFrameConstructor
:
:
FrameConstructionItemList
:
:
Iterator
:
:
SkipItemsNotWantingParentType
(
ParentType
aParentType
)
{
MOZ_ASSERT
(
!
IsDone
(
)
"
Shouldn
'
t
be
done
yet
"
)
;
while
(
item
(
)
.
DesiredParentType
(
)
!
=
aParentType
)
{
Next
(
)
;
if
(
IsDone
(
)
)
{
return
true
;
}
}
return
false
;
}
bool
nsCSSFrameConstructor
:
:
FrameConstructionItem
:
:
NeedsAnonFlexOrGridItem
(
const
nsFrameConstructorState
&
aState
bool
aIsLegacyBox
)
{
if
(
mFCData
-
>
mBits
&
FCDATA_IS_LINE_PARTICIPANT
)
{
return
true
;
}
if
(
aIsLegacyBox
)
{
if
(
mComputedStyle
-
>
StyleDisplay
(
)
-
>
IsInlineOutsideStyle
(
)
)
{
return
true
;
}
if
(
mIsPopup
|
|
(
!
(
mFCData
-
>
mBits
&
FCDATA_DISALLOW_OUT_OF_FLOW
)
&
&
aState
.
GetGeometricParent
(
mComputedStyle
-
>
StyleDisplay
(
)
nullptr
)
)
)
{
return
true
;
}
}
return
false
;
}
inline
bool
nsCSSFrameConstructor
:
:
FrameConstructionItemList
:
:
Iterator
:
:
SkipItemsThatNeedAnonFlexOrGridItem
(
const
nsFrameConstructorState
&
aState
bool
aIsLegacyBox
)
{
MOZ_ASSERT
(
!
IsDone
(
)
"
Shouldn
'
t
be
done
yet
"
)
;
while
(
item
(
)
.
NeedsAnonFlexOrGridItem
(
aState
aIsLegacyBox
)
)
{
Next
(
)
;
if
(
IsDone
(
)
)
{
return
true
;
}
}
return
false
;
}
inline
bool
nsCSSFrameConstructor
:
:
FrameConstructionItemList
:
:
Iterator
:
:
SkipItemsThatDontNeedAnonFlexOrGridItem
(
const
nsFrameConstructorState
&
aState
bool
aIsLegacyBox
)
{
MOZ_ASSERT
(
!
IsDone
(
)
"
Shouldn
'
t
be
done
yet
"
)
;
while
(
!
(
item
(
)
.
NeedsAnonFlexOrGridItem
(
aState
aIsLegacyBox
)
)
)
{
Next
(
)
;
if
(
IsDone
(
)
)
{
return
true
;
}
}
return
false
;
}
inline
bool
nsCSSFrameConstructor
:
:
FrameConstructionItemList
:
:
Iterator
:
:
SkipItemsNotWantingRubyParent
(
)
{
MOZ_ASSERT
(
!
IsDone
(
)
"
Shouldn
'
t
be
done
yet
"
)
;
while
(
!
IsRubyParentType
(
item
(
)
.
DesiredParentType
(
)
)
)
{
Next
(
)
;
if
(
IsDone
(
)
)
{
return
true
;
}
}
return
false
;
}
inline
bool
nsCSSFrameConstructor
:
:
FrameConstructionItemList
:
:
Iterator
:
:
SkipWhitespace
(
nsFrameConstructorState
&
aState
)
{
MOZ_ASSERT
(
!
IsDone
(
)
"
Shouldn
'
t
be
done
yet
"
)
;
MOZ_ASSERT
(
item
(
)
.
IsWhitespace
(
aState
)
"
Not
pointing
to
whitespace
?
"
)
;
do
{
Next
(
)
;
if
(
IsDone
(
)
)
{
return
true
;
}
}
while
(
item
(
)
.
IsWhitespace
(
aState
)
)
;
return
false
;
}
void
nsCSSFrameConstructor
:
:
FrameConstructionItemList
:
:
Iterator
:
:
AppendItemToList
(
FrameConstructionItemList
&
aTargetList
)
{
NS_ASSERTION
(
&
aTargetList
!
=
&
mList
"
Unexpected
call
"
)
;
MOZ_ASSERT
(
!
IsDone
(
)
"
should
not
be
done
"
)
;
FrameConstructionItem
*
item
=
mCurrent
;
Next
(
)
;
item
-
>
remove
(
)
;
aTargetList
.
mItems
.
insertBack
(
item
)
;
mList
.
AdjustCountsForItem
(
item
-
1
)
;
aTargetList
.
AdjustCountsForItem
(
item
1
)
;
}
void
nsCSSFrameConstructor
:
:
FrameConstructionItemList
:
:
Iterator
:
:
AppendItemsToList
(
nsCSSFrameConstructor
*
aFCtor
const
Iterator
&
aEnd
FrameConstructionItemList
&
aTargetList
)
{
NS_ASSERTION
(
&
aTargetList
!
=
&
mList
"
Unexpected
call
"
)
;
MOZ_ASSERT
(
&
mList
=
=
&
aEnd
.
mList
"
End
iterator
for
some
other
list
?
"
)
;
if
(
!
AtStart
(
)
|
|
!
aEnd
.
IsDone
(
)
|
|
!
aTargetList
.
IsEmpty
(
)
)
{
do
{
AppendItemToList
(
aTargetList
)
;
}
while
(
*
this
!
=
aEnd
)
;
return
;
}
aTargetList
.
mItems
=
Move
(
mList
.
mItems
)
;
aTargetList
.
mInlineCount
=
mList
.
mInlineCount
;
aTargetList
.
mBlockCount
=
mList
.
mBlockCount
;
aTargetList
.
mLineParticipantCount
=
mList
.
mLineParticipantCount
;
aTargetList
.
mItemCount
=
mList
.
mItemCount
;
memcpy
(
aTargetList
.
mDesiredParentCounts
mList
.
mDesiredParentCounts
sizeof
(
aTargetList
.
mDesiredParentCounts
)
)
;
mList
.
Reset
(
aFCtor
)
;
SetToEnd
(
)
;
MOZ_ASSERT
(
*
this
=
=
aEnd
"
How
did
that
happen
?
"
)
;
}
void
nsCSSFrameConstructor
:
:
FrameConstructionItemList
:
:
Iterator
:
:
InsertItem
(
FrameConstructionItem
*
aItem
)
{
if
(
IsDone
(
)
)
{
mList
.
mItems
.
insertBack
(
aItem
)
;
}
else
{
mCurrent
-
>
setPrevious
(
aItem
)
;
}
mList
.
AdjustCountsForItem
(
aItem
1
)
;
MOZ_ASSERT
(
aItem
-
>
getNext
(
)
=
=
mCurrent
"
How
did
that
happen
?
"
)
;
}
void
nsCSSFrameConstructor
:
:
FrameConstructionItemList
:
:
Iterator
:
:
DeleteItemsTo
(
nsCSSFrameConstructor
*
aFCtor
const
Iterator
&
aEnd
)
{
MOZ_ASSERT
(
&
mList
=
=
&
aEnd
.
mList
"
End
iterator
for
some
other
list
?
"
)
;
MOZ_ASSERT
(
*
this
!
=
aEnd
"
Shouldn
'
t
be
at
aEnd
yet
"
)
;
do
{
NS_ASSERTION
(
!
IsDone
(
)
"
Ran
off
end
of
list
?
"
)
;
FrameConstructionItem
*
item
=
mCurrent
;
Next
(
)
;
item
-
>
remove
(
)
;
mList
.
AdjustCountsForItem
(
item
-
1
)
;
item
-
>
Delete
(
aFCtor
)
;
}
while
(
*
this
!
=
aEnd
)
;
}
void
nsCSSFrameConstructor
:
:
QuotesDirty
(
)
{
mQuotesDirty
=
true
;
mPresShell
-
>
SetNeedLayoutFlush
(
)
;
}
void
nsCSSFrameConstructor
:
:
CountersDirty
(
)
{
mCountersDirty
=
true
;
mPresShell
-
>
SetNeedLayoutFlush
(
)
;
}
void
*
nsCSSFrameConstructor
:
:
AllocateFCItem
(
)
{
void
*
item
;
if
(
mFirstFreeFCItem
)
{
item
=
mFirstFreeFCItem
;
mFirstFreeFCItem
=
mFirstFreeFCItem
-
>
mNext
;
}
else
{
item
=
mFCItemPool
.
Allocate
(
sizeof
(
FrameConstructionItem
)
)
;
}
+
+
mFCItemsInUse
;
return
item
;
}
void
nsCSSFrameConstructor
:
:
FreeFCItem
(
FrameConstructionItem
*
aItem
)
{
MOZ_ASSERT
(
mFCItemsInUse
!
=
0
)
;
if
(
-
-
mFCItemsInUse
=
=
0
)
{
mFirstFreeFCItem
=
nullptr
;
mFCItemPool
.
Clear
(
)
;
}
else
{
FreeFCItemLink
*
item
=
reinterpret_cast
<
FreeFCItemLink
*
>
(
aItem
)
;
item
-
>
mNext
=
mFirstFreeFCItem
;
mFirstFreeFCItem
=
item
;
}
}
void
nsCSSFrameConstructor
:
:
AddSizeOfIncludingThis
(
nsWindowSizes
&
aSizes
)
const
{
if
(
nsIFrame
*
rootFrame
=
GetRootFrame
(
)
)
{
rootFrame
-
>
AddSizeOfExcludingThisForTree
(
aSizes
)
;
}
nsFrameManager
:
:
AddSizeOfIncludingThis
(
aSizes
)
;
}
