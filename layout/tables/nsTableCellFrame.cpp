#
include
"
nsTableCellFrame
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
mozilla
/
ComputedStyle
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
Helpers
.
h
"
#
include
"
nsTableFrame
.
h
"
#
include
"
nsTableColFrame
.
h
"
#
include
"
nsTableRowFrame
.
h
"
#
include
"
nsTableRowGroupFrame
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsCSSRendering
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsAttrValueInlines
.
h
"
#
include
"
nsHTMLParts
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsTextFrame
.
h
"
#
include
<
algorithm
>
#
include
"
nsFrameSelection
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
ifdef
ACCESSIBILITY
#
include
"
nsAccessibilityService
.
h
"
#
endif
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
image
;
nsTableCellFrame
:
:
nsTableCellFrame
(
ComputedStyle
*
aStyle
nsTableFrame
*
aTableFrame
ClassID
aID
)
:
nsContainerFrame
(
aStyle
aTableFrame
-
>
PresContext
(
)
aID
)
mDesiredSize
(
aTableFrame
-
>
GetWritingMode
(
)
)
{
mColIndex
=
0
;
mPriorAvailISize
=
0
;
SetContentEmpty
(
false
)
;
}
nsTableCellFrame
:
:
~
nsTableCellFrame
(
)
=
default
;
NS_IMPL_FRAMEARENA_HELPERS
(
nsTableCellFrame
)
void
nsTableCellFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
nsContainerFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
if
(
HasAnyStateBits
(
NS_FRAME_FONT_INFLATION_CONTAINER
)
)
{
AddStateBits
(
NS_FRAME_FONT_INFLATION_FLOW_ROOT
)
;
}
if
(
aPrevInFlow
)
{
nsTableCellFrame
*
cellFrame
=
(
nsTableCellFrame
*
)
aPrevInFlow
;
uint32_t
colIndex
=
cellFrame
-
>
ColIndex
(
)
;
SetColIndex
(
colIndex
)
;
}
else
{
mWritingMode
=
GetTableFrame
(
)
-
>
GetWritingMode
(
)
;
}
}
void
nsTableCellFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
{
if
(
HasAnyStateBits
(
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
)
{
nsTableFrame
:
:
UnregisterPositionedTablePart
(
this
aDestructRoot
)
;
}
nsContainerFrame
:
:
DestroyFrom
(
aDestructRoot
aPostDestroyData
)
;
}
void
nsTableCellFrame
:
:
NotifyPercentBSize
(
const
ReflowInput
&
aReflowInput
)
{
const
ReflowInput
*
cellRI
=
aReflowInput
.
mCBReflowInput
;
if
(
cellRI
&
&
cellRI
-
>
mFrame
=
=
this
&
&
(
cellRI
-
>
ComputedBSize
(
)
=
=
NS_UNCONSTRAINEDSIZE
|
|
cellRI
-
>
ComputedBSize
(
)
=
=
0
)
)
{
if
(
nsTableFrame
:
:
AncestorsHaveStyleBSize
(
*
cellRI
)
|
|
(
GetTableFrame
(
)
-
>
GetEffectiveRowSpan
(
*
this
)
=
=
1
&
&
cellRI
-
>
mParentReflowInput
-
>
mFrame
-
>
HasAnyStateBits
(
NS_ROW_HAS_CELL_WITH_STYLE_BSIZE
)
)
)
{
for
(
const
ReflowInput
*
rs
=
aReflowInput
.
mParentReflowInput
;
rs
!
=
cellRI
;
rs
=
rs
-
>
mParentReflowInput
)
{
rs
-
>
mFrame
-
>
AddStateBits
(
NS_FRAME_CONTAINS_RELATIVE_BSIZE
)
;
}
nsTableFrame
:
:
RequestSpecialBSizeReflow
(
*
cellRI
)
;
}
}
}
bool
nsTableCellFrame
:
:
NeedsToObserve
(
const
ReflowInput
&
aReflowInput
)
{
const
ReflowInput
*
rs
=
aReflowInput
.
mParentReflowInput
;
if
(
!
rs
)
return
false
;
if
(
rs
-
>
mFrame
=
=
this
)
{
return
true
;
}
rs
=
rs
-
>
mParentReflowInput
;
if
(
!
rs
)
{
return
false
;
}
LayoutFrameType
fType
=
aReflowInput
.
mFrame
-
>
Type
(
)
;
if
(
fType
=
=
LayoutFrameType
:
:
Table
)
{
return
true
;
}
return
rs
-
>
mFrame
=
=
this
&
&
(
PresContext
(
)
-
>
CompatibilityMode
(
)
=
=
eCompatibility_NavQuirks
|
|
fType
=
=
LayoutFrameType
:
:
TableWrapper
)
;
}
nsresult
nsTableCellFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
if
(
aNameSpaceID
=
=
kNameSpaceID_None
&
&
aAttribute
=
=
nsGkAtoms
:
:
nowrap
&
&
PresContext
(
)
-
>
CompatibilityMode
(
)
=
=
eCompatibility_NavQuirks
)
{
PresShell
(
)
-
>
FrameNeedsReflow
(
this
IntrinsicDirty
:
:
TreeChange
NS_FRAME_IS_DIRTY
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
rowspan
|
|
aAttribute
=
=
nsGkAtoms
:
:
colspan
)
{
nsLayoutUtils
:
:
PostRestyleEvent
(
mContent
-
>
AsElement
(
)
RestyleHint
{
0
}
nsChangeHint_UpdateTableCellSpans
)
;
}
return
NS_OK
;
}
void
nsTableCellFrame
:
:
DidSetComputedStyle
(
ComputedStyle
*
aOldComputedStyle
)
{
nsContainerFrame
:
:
DidSetComputedStyle
(
aOldComputedStyle
)
;
if
(
!
aOldComputedStyle
)
return
;
#
ifdef
ACCESSIBILITY
if
(
nsAccessibilityService
*
accService
=
GetAccService
(
)
)
{
if
(
StyleBorder
(
)
-
>
GetComputedBorder
(
)
!
=
aOldComputedStyle
-
>
StyleBorder
(
)
-
>
GetComputedBorder
(
)
)
{
accService
-
>
TableLayoutGuessMaybeChanged
(
PresShell
(
)
mContent
)
;
}
}
#
endif
nsTableFrame
*
tableFrame
=
GetTableFrame
(
)
;
if
(
tableFrame
-
>
IsBorderCollapse
(
)
&
&
tableFrame
-
>
BCRecalcNeeded
(
aOldComputedStyle
Style
(
)
)
)
{
uint32_t
colIndex
=
ColIndex
(
)
;
uint32_t
rowIndex
=
RowIndex
(
)
;
TableArea
damageArea
(
colIndex
rowIndex
GetColSpan
(
)
std
:
:
min
(
static_cast
<
uint32_t
>
(
GetRowSpan
(
)
)
tableFrame
-
>
GetRowCount
(
)
-
rowIndex
)
)
;
tableFrame
-
>
AddBCDamageArea
(
damageArea
)
;
}
}
#
ifdef
DEBUG
void
nsTableCellFrame
:
:
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
{
MOZ_CRASH
(
"
unsupported
operation
"
)
;
}
void
nsTableCellFrame
:
:
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
const
nsLineList
:
:
iterator
*
aPrevFrameLine
nsFrameList
&
aFrameList
)
{
MOZ_CRASH
(
"
unsupported
operation
"
)
;
}
void
nsTableCellFrame
:
:
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
{
MOZ_CRASH
(
"
unsupported
operation
"
)
;
}
#
endif
void
nsTableCellFrame
:
:
SetColIndex
(
int32_t
aColIndex
)
{
mColIndex
=
aColIndex
;
}
nsMargin
nsTableCellFrame
:
:
GetUsedMargin
(
)
const
{
return
nsMargin
(
0
0
0
0
)
;
}
inline
nscolor
EnsureDifferentColors
(
nscolor
colorA
nscolor
colorB
)
{
if
(
colorA
=
=
colorB
)
{
nscolor
res
;
res
=
NS_RGB
(
NS_GET_R
(
colorA
)
^
0xff
NS_GET_G
(
colorA
)
^
0xff
NS_GET_B
(
colorA
)
^
0xff
)
;
return
res
;
}
return
colorA
;
}
void
nsTableCellFrame
:
:
DecorateForSelection
(
DrawTarget
*
aDrawTarget
nsPoint
aPt
)
{
NS_ASSERTION
(
IsSelected
(
)
"
Should
only
be
called
for
selected
cells
"
)
;
int16_t
displaySelection
;
nsPresContext
*
presContext
=
PresContext
(
)
;
displaySelection
=
DetermineDisplaySelection
(
)
;
if
(
displaySelection
)
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
presContext
-
>
PresShell
(
)
-
>
FrameSelection
(
)
;
if
(
frameSelection
-
>
IsInTableSelectionMode
(
)
)
{
nscolor
bordercolor
;
if
(
displaySelection
=
=
nsISelectionController
:
:
SELECTION_DISABLED
)
{
bordercolor
=
NS_RGB
(
176
176
176
)
;
}
else
{
bordercolor
=
LookAndFeel
:
:
Color
(
LookAndFeel
:
:
ColorID
:
:
Highlight
this
)
;
}
nscoord
threePx
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
3
)
;
if
(
(
mRect
.
width
>
threePx
)
&
&
(
mRect
.
height
>
threePx
)
)
{
bordercolor
=
EnsureDifferentColors
(
bordercolor
StyleBackground
(
)
-
>
BackgroundColor
(
this
)
)
;
int32_t
appUnitsPerDevPixel
=
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
Point
devPixelOffset
=
NSPointToPoint
(
aPt
appUnitsPerDevPixel
)
;
AutoRestoreTransform
autoRestoreTransform
(
aDrawTarget
)
;
aDrawTarget
-
>
SetTransform
(
aDrawTarget
-
>
GetTransform
(
)
.
PreTranslate
(
devPixelOffset
)
)
;
ColorPattern
color
(
ToDeviceColor
(
bordercolor
)
)
;
nscoord
onePixel
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
1
)
;
StrokeLineWithSnapping
(
nsPoint
(
onePixel
0
)
nsPoint
(
mRect
.
width
0
)
appUnitsPerDevPixel
*
aDrawTarget
color
)
;
StrokeLineWithSnapping
(
nsPoint
(
0
onePixel
)
nsPoint
(
0
mRect
.
height
)
appUnitsPerDevPixel
*
aDrawTarget
color
)
;
StrokeLineWithSnapping
(
nsPoint
(
onePixel
mRect
.
height
)
nsPoint
(
mRect
.
width
mRect
.
height
)
appUnitsPerDevPixel
*
aDrawTarget
color
)
;
StrokeLineWithSnapping
(
nsPoint
(
mRect
.
width
onePixel
)
nsPoint
(
mRect
.
width
mRect
.
height
)
appUnitsPerDevPixel
*
aDrawTarget
color
)
;
nsRect
r
(
onePixel
onePixel
mRect
.
width
-
onePixel
mRect
.
height
-
onePixel
)
;
Rect
devPixelRect
=
NSRectToSnappedRect
(
r
appUnitsPerDevPixel
*
aDrawTarget
)
;
aDrawTarget
-
>
StrokeRect
(
devPixelRect
color
)
;
StrokeLineWithSnapping
(
nsPoint
(
2
*
onePixel
mRect
.
height
-
2
*
onePixel
)
nsPoint
(
mRect
.
width
-
onePixel
mRect
.
height
-
(
2
*
onePixel
)
)
appUnitsPerDevPixel
*
aDrawTarget
color
)
;
StrokeLineWithSnapping
(
nsPoint
(
mRect
.
width
-
(
2
*
onePixel
)
2
*
onePixel
)
nsPoint
(
mRect
.
width
-
(
2
*
onePixel
)
mRect
.
height
-
onePixel
)
appUnitsPerDevPixel
*
aDrawTarget
color
)
;
}
}
}
}
ImgDrawResult
nsTableCellFrame
:
:
PaintBackground
(
gfxContext
&
aRenderingContext
const
nsRect
&
aDirtyRect
nsPoint
aPt
uint32_t
aFlags
)
{
nsRect
rect
(
aPt
GetSize
(
)
)
;
nsCSSRendering
:
:
PaintBGParams
params
=
nsCSSRendering
:
:
PaintBGParams
:
:
ForAllLayers
(
*
PresContext
(
)
aDirtyRect
rect
this
aFlags
)
;
return
nsCSSRendering
:
:
PaintStyleImageLayer
(
params
aRenderingContext
)
;
}
nsresult
nsTableCellFrame
:
:
ProcessBorders
(
nsTableFrame
*
aFrame
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
const
nsStyleBorder
*
borderStyle
=
StyleBorder
(
)
;
if
(
aFrame
-
>
IsBorderCollapse
(
)
|
|
!
borderStyle
-
>
HasBorder
(
)
)
return
NS_OK
;
if
(
!
GetContentEmpty
(
)
|
|
StyleTableBorder
(
)
-
>
mEmptyCells
=
=
StyleEmptyCells
:
:
Show
)
{
aLists
.
BorderBackground
(
)
-
>
AppendNewToTop
<
nsDisplayBorder
>
(
aBuilder
this
)
;
}
return
NS_OK
;
}
void
nsTableCellFrame
:
:
InvalidateFrame
(
uint32_t
aDisplayItemKey
bool
aRebuildDisplayItems
)
{
nsIFrame
:
:
InvalidateFrame
(
aDisplayItemKey
aRebuildDisplayItems
)
;
if
(
GetTableFrame
(
)
-
>
IsBorderCollapse
(
)
)
{
const
bool
rebuild
=
StaticPrefs
:
:
layout_display_list_retain_sc
(
)
;
GetParent
(
)
-
>
InvalidateFrameWithRect
(
InkOverflowRect
(
)
+
GetPosition
(
)
aDisplayItemKey
rebuild
)
;
}
}
void
nsTableCellFrame
:
:
InvalidateFrameWithRect
(
const
nsRect
&
aRect
uint32_t
aDisplayItemKey
bool
aRebuildDisplayItems
)
{
nsIFrame
:
:
InvalidateFrameWithRect
(
aRect
aDisplayItemKey
aRebuildDisplayItems
)
;
GetParent
(
)
-
>
InvalidateFrameWithRect
(
aRect
+
GetPosition
(
)
aDisplayItemKey
aRebuildDisplayItems
)
;
}
bool
nsTableCellFrame
:
:
ShouldPaintBordersAndBackgrounds
(
)
const
{
if
(
!
StyleVisibility
(
)
-
>
IsVisible
(
)
)
{
return
false
;
}
if
(
!
GetContentEmpty
(
)
)
{
return
true
;
}
nsTableFrame
*
tableFrame
=
GetTableFrame
(
)
;
if
(
tableFrame
-
>
IsBorderCollapse
(
)
)
{
return
true
;
}
return
StyleTableBorder
(
)
-
>
mEmptyCells
=
=
StyleEmptyCells
:
:
Show
;
}
bool
nsTableCellFrame
:
:
ShouldPaintBackground
(
nsDisplayListBuilder
*
aBuilder
)
{
return
ShouldPaintBordersAndBackgrounds
(
)
;
}
LogicalSides
nsTableCellFrame
:
:
GetLogicalSkipSides
(
)
const
{
LogicalSides
skip
(
mWritingMode
)
;
if
(
MOZ_UNLIKELY
(
StyleBorder
(
)
-
>
mBoxDecorationBreak
=
=
StyleBoxDecorationBreak
:
:
Clone
)
)
{
return
skip
;
}
if
(
GetPrevInFlow
(
)
)
{
skip
|
=
eLogicalSideBitsBStart
;
}
if
(
GetNextInFlow
(
)
)
{
skip
|
=
eLogicalSideBitsBEnd
;
}
return
skip
;
}
nsMargin
nsTableCellFrame
:
:
GetBorderOverflow
(
)
{
return
nsMargin
(
0
0
0
0
)
;
}
void
nsTableCellFrame
:
:
BlockDirAlignChild
(
WritingMode
aWM
nscoord
aMaxAscent
)
{
const
LogicalMargin
borderPadding
=
GetLogicalUsedBorderAndPadding
(
GetWritingMode
(
)
)
.
ApplySkipSides
(
GetLogicalSkipSides
(
)
)
.
ConvertTo
(
aWM
GetWritingMode
(
)
)
;
nscoord
bStartInset
=
borderPadding
.
BStart
(
aWM
)
;
nscoord
bEndInset
=
borderPadding
.
BEnd
(
aWM
)
;
nscoord
bSize
=
BSize
(
aWM
)
;
nsIFrame
*
firstKid
=
mFrames
.
FirstChild
(
)
;
nsSize
containerSize
=
mRect
.
Size
(
)
;
NS_ASSERTION
(
firstKid
"
Frame
construction
error
a
table
cell
always
has
"
"
an
inner
cell
frame
"
)
;
LogicalRect
kidRect
=
firstKid
-
>
GetLogicalRect
(
aWM
containerSize
)
;
nscoord
childBSize
=
kidRect
.
BSize
(
aWM
)
;
nscoord
kidBStart
=
0
;
switch
(
GetVerticalAlign
(
)
)
{
case
StyleVerticalAlignKeyword
:
:
Baseline
:
if
(
!
GetContentEmpty
(
)
)
{
kidBStart
=
bStartInset
+
aMaxAscent
-
GetCellBaseline
(
)
;
break
;
}
[
[
fallthrough
]
]
;
case
StyleVerticalAlignKeyword
:
:
Top
:
kidBStart
=
bStartInset
;
break
;
case
StyleVerticalAlignKeyword
:
:
Bottom
:
kidBStart
=
bSize
-
childBSize
-
bEndInset
;
break
;
default
:
case
StyleVerticalAlignKeyword
:
:
Middle
:
kidBStart
=
(
bSize
-
childBSize
-
bEndInset
+
bStartInset
)
/
2
;
}
kidBStart
=
std
:
:
max
(
bStartInset
kidBStart
)
;
if
(
kidBStart
!
=
kidRect
.
BStart
(
aWM
)
)
{
firstKid
-
>
InvalidateFrameSubtree
(
)
;
}
firstKid
-
>
SetPosition
(
aWM
LogicalPoint
(
aWM
kidRect
.
IStart
(
aWM
)
kidBStart
)
containerSize
)
;
ReflowOutput
desiredSize
(
aWM
)
;
desiredSize
.
SetSize
(
aWM
GetLogicalSize
(
aWM
)
)
;
nsRect
overflow
(
nsPoint
(
0
0
)
GetSize
(
)
)
;
overflow
.
Inflate
(
GetBorderOverflow
(
)
)
;
desiredSize
.
mOverflowAreas
.
SetAllTo
(
overflow
)
;
ConsiderChildOverflow
(
desiredSize
.
mOverflowAreas
firstKid
)
;
FinishAndStoreOverflow
(
&
desiredSize
)
;
if
(
kidBStart
!
=
kidRect
.
BStart
(
aWM
)
)
{
nsContainerFrame
:
:
PositionChildViews
(
firstKid
)
;
firstKid
-
>
InvalidateFrameSubtree
(
)
;
}
if
(
HasView
(
)
)
{
nsContainerFrame
:
:
SyncFrameViewAfterReflow
(
PresContext
(
)
this
GetView
(
)
desiredSize
.
InkOverflow
(
)
ReflowChildFlags
:
:
Default
)
;
}
}
bool
nsTableCellFrame
:
:
ComputeCustomOverflow
(
OverflowAreas
&
aOverflowAreas
)
{
nsRect
bounds
(
nsPoint
(
0
0
)
GetSize
(
)
)
;
bounds
.
Inflate
(
GetBorderOverflow
(
)
)
;
aOverflowAreas
.
UnionAllWith
(
bounds
)
;
return
nsContainerFrame
:
:
ComputeCustomOverflow
(
aOverflowAreas
)
;
}
StyleVerticalAlignKeyword
nsTableCellFrame
:
:
GetVerticalAlign
(
)
const
{
const
StyleVerticalAlign
&
verticalAlign
=
StyleDisplay
(
)
-
>
mVerticalAlign
;
if
(
verticalAlign
.
IsKeyword
(
)
)
{
auto
value
=
verticalAlign
.
AsKeyword
(
)
;
if
(
value
=
=
StyleVerticalAlignKeyword
:
:
Top
|
|
value
=
=
StyleVerticalAlignKeyword
:
:
Middle
|
|
value
=
=
StyleVerticalAlignKeyword
:
:
Bottom
)
{
return
value
;
}
}
return
StyleVerticalAlignKeyword
:
:
Baseline
;
}
bool
nsTableCellFrame
:
:
CellHasVisibleContent
(
nscoord
height
nsTableFrame
*
tableFrame
nsIFrame
*
kidFrame
)
{
if
(
height
>
0
)
return
true
;
if
(
tableFrame
-
>
IsBorderCollapse
(
)
)
return
true
;
for
(
nsIFrame
*
innerFrame
:
kidFrame
-
>
PrincipalChildList
(
)
)
{
LayoutFrameType
frameType
=
innerFrame
-
>
Type
(
)
;
if
(
LayoutFrameType
:
:
Text
=
=
frameType
)
{
nsTextFrame
*
textFrame
=
static_cast
<
nsTextFrame
*
>
(
innerFrame
)
;
if
(
textFrame
-
>
HasNoncollapsedCharacters
(
)
)
return
true
;
}
else
if
(
LayoutFrameType
:
:
Placeholder
!
=
frameType
)
{
return
true
;
}
else
{
nsIFrame
*
floatFrame
=
nsLayoutUtils
:
:
GetFloatFromPlaceholder
(
innerFrame
)
;
if
(
floatFrame
)
return
true
;
}
}
return
false
;
}
nscoord
nsTableCellFrame
:
:
GetCellBaseline
(
)
const
{
nsIFrame
*
inner
=
mFrames
.
FirstChild
(
)
;
nscoord
borderPadding
=
GetUsedBorderAndPadding
(
)
.
top
;
nscoord
result
;
if
(
!
StyleDisplay
(
)
-
>
IsContainLayout
(
)
&
&
nsLayoutUtils
:
:
GetFirstLineBaseline
(
GetWritingMode
(
)
inner
&
result
)
)
{
return
result
+
borderPadding
;
}
return
inner
-
>
GetContentRectRelativeToSelf
(
)
.
YMost
(
)
+
borderPadding
;
}
int32_t
nsTableCellFrame
:
:
GetRowSpan
(
)
{
int32_t
rowSpan
=
1
;
if
(
!
Style
(
)
-
>
IsPseudoOrAnonBox
(
)
)
{
dom
:
:
Element
*
elem
=
mContent
-
>
AsElement
(
)
;
const
nsAttrValue
*
attr
=
elem
-
>
GetParsedAttr
(
nsGkAtoms
:
:
rowspan
)
;
if
(
attr
&
&
attr
-
>
Type
(
)
=
=
nsAttrValue
:
:
eInteger
)
{
rowSpan
=
attr
-
>
GetIntegerValue
(
)
;
}
}
return
rowSpan
;
}
int32_t
nsTableCellFrame
:
:
GetColSpan
(
)
{
int32_t
colSpan
=
1
;
if
(
!
Style
(
)
-
>
IsPseudoOrAnonBox
(
)
)
{
dom
:
:
Element
*
elem
=
mContent
-
>
AsElement
(
)
;
const
nsAttrValue
*
attr
=
elem
-
>
GetParsedAttr
(
MOZ_UNLIKELY
(
elem
-
>
IsMathMLElement
(
)
)
?
nsGkAtoms
:
:
columnspan_
:
nsGkAtoms
:
:
colspan
)
;
if
(
attr
&
&
attr
-
>
Type
(
)
=
=
nsAttrValue
:
:
eInteger
)
{
colSpan
=
attr
-
>
GetIntegerValue
(
)
;
}
}
return
colSpan
;
}
nscoord
nsTableCellFrame
:
:
GetMinISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
result
=
0
;
DISPLAY_MIN_INLINE_SIZE
(
this
result
)
;
nsIFrame
*
inner
=
mFrames
.
FirstChild
(
)
;
result
=
nsLayoutUtils
:
:
IntrinsicForContainer
(
aRenderingContext
inner
IntrinsicISizeType
:
:
MinISize
)
;
return
result
;
}
nscoord
nsTableCellFrame
:
:
GetPrefISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
result
=
0
;
DISPLAY_PREF_INLINE_SIZE
(
this
result
)
;
nsIFrame
*
inner
=
mFrames
.
FirstChild
(
)
;
result
=
nsLayoutUtils
:
:
IntrinsicForContainer
(
aRenderingContext
inner
IntrinsicISizeType
:
:
PrefISize
)
;
return
result
;
}
nsIFrame
:
:
IntrinsicSizeOffsetData
nsTableCellFrame
:
:
IntrinsicISizeOffsets
(
nscoord
aPercentageBasis
)
{
IntrinsicSizeOffsetData
result
=
nsContainerFrame
:
:
IntrinsicISizeOffsets
(
aPercentageBasis
)
;
result
.
margin
=
0
;
WritingMode
wm
=
GetWritingMode
(
)
;
result
.
border
=
GetBorderWidth
(
wm
)
.
IStartEnd
(
wm
)
;
return
result
;
}
#
ifdef
DEBUG
#
define
PROBABLY_TOO_LARGE
1000000
static
void
DebugCheckChildSize
(
nsIFrame
*
aChild
ReflowOutput
&
aMet
)
{
WritingMode
wm
=
aMet
.
GetWritingMode
(
)
;
if
(
(
aMet
.
ISize
(
wm
)
<
0
)
|
|
(
aMet
.
ISize
(
wm
)
>
PROBABLY_TOO_LARGE
)
)
{
printf
(
"
WARNING
:
cell
content
%
p
has
large
inline
size
%
d
\
n
"
static_cast
<
void
*
>
(
aChild
)
int32_t
(
aMet
.
ISize
(
wm
)
)
)
;
}
}
#
endif
static
nscoord
CalcUnpaginatedBSize
(
nsTableCellFrame
&
aCellFrame
nsTableFrame
&
aTableFrame
nscoord
aBlockDirBorderPadding
)
{
const
nsTableCellFrame
*
firstCellInFlow
=
static_cast
<
nsTableCellFrame
*
>
(
aCellFrame
.
FirstInFlow
(
)
)
;
nsTableFrame
*
firstTableInFlow
=
static_cast
<
nsTableFrame
*
>
(
aTableFrame
.
FirstInFlow
(
)
)
;
nsTableRowFrame
*
row
=
static_cast
<
nsTableRowFrame
*
>
(
firstCellInFlow
-
>
GetParent
(
)
)
;
nsTableRowGroupFrame
*
firstRGInFlow
=
static_cast
<
nsTableRowGroupFrame
*
>
(
row
-
>
GetParent
(
)
)
;
uint32_t
rowIndex
=
firstCellInFlow
-
>
RowIndex
(
)
;
int32_t
rowSpan
=
aTableFrame
.
GetEffectiveRowSpan
(
*
firstCellInFlow
)
;
nscoord
computedBSize
=
firstTableInFlow
-
>
GetRowSpacing
(
rowIndex
rowIndex
+
rowSpan
-
1
)
;
computedBSize
-
=
aBlockDirBorderPadding
;
uint32_t
rowX
;
for
(
row
=
firstRGInFlow
-
>
GetFirstRow
(
)
rowX
=
0
;
row
;
row
=
row
-
>
GetNextRow
(
)
rowX
+
+
)
{
if
(
rowX
>
rowIndex
+
rowSpan
-
1
)
{
break
;
}
else
if
(
rowX
>
=
rowIndex
)
{
computedBSize
+
=
row
-
>
GetUnpaginatedBSize
(
)
;
}
}
return
computedBSize
;
}
void
nsTableCellFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsTableCellFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aDesiredSize
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
if
(
aReflowInput
.
mFlags
.
mSpecialBSizeReflow
)
{
FirstInFlow
(
)
-
>
AddStateBits
(
NS_TABLE_CELL_HAD_SPECIAL_REFLOW
)
;
}
nsTableFrame
:
:
CheckRequestSpecialBSizeReflow
(
aReflowInput
)
;
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
LogicalSize
availSize
=
aReflowInput
.
AvailableSize
(
)
;
LogicalMargin
borderPadding
=
aReflowInput
.
ComputedLogicalPadding
(
wm
)
+
GetBorderWidth
(
wm
)
;
ReflowOutput
kidSize
(
wm
)
;
kidSize
.
ClearSize
(
)
;
SetPriorAvailISize
(
aReflowInput
.
AvailableISize
(
)
)
;
nsIFrame
*
firstKid
=
mFrames
.
FirstChild
(
)
;
NS_ASSERTION
(
firstKid
"
Frame
construction
error
a
table
cell
always
has
an
inner
cell
frame
"
)
;
nsTableFrame
*
tableFrame
=
GetTableFrame
(
)
;
if
(
aReflowInput
.
mFlags
.
mSpecialBSizeReflow
)
{
const_cast
<
ReflowInput
&
>
(
aReflowInput
)
.
SetComputedBSize
(
BSize
(
wm
)
-
borderPadding
.
BStartEnd
(
wm
)
)
;
DISPLAY_REFLOW_CHANGE
(
)
;
}
else
if
(
aPresContext
-
>
IsPaginated
(
)
)
{
nscoord
computedUnpaginatedBSize
=
CalcUnpaginatedBSize
(
(
nsTableCellFrame
&
)
*
this
*
tableFrame
borderPadding
.
BStartEnd
(
wm
)
)
;
if
(
computedUnpaginatedBSize
>
0
)
{
const_cast
<
ReflowInput
&
>
(
aReflowInput
)
.
SetComputedBSize
(
computedUnpaginatedBSize
)
;
DISPLAY_REFLOW_CHANGE
(
)
;
}
}
borderPadding
.
ApplySkipSides
(
PreReflowBlockLevelLogicalSkipSides
(
)
)
;
availSize
.
ISize
(
wm
)
-
=
borderPadding
.
IStartEnd
(
wm
)
;
if
(
NS_UNCONSTRAINEDSIZE
!
=
availSize
.
BSize
(
wm
)
)
{
availSize
.
BSize
(
wm
)
-
=
borderPadding
.
BStart
(
wm
)
;
if
(
aReflowInput
.
mStyleBorder
-
>
mBoxDecorationBreak
=
=
StyleBoxDecorationBreak
:
:
Clone
)
{
availSize
.
BSize
(
wm
)
-
=
borderPadding
.
BEnd
(
wm
)
;
}
}
availSize
.
BSize
(
wm
)
=
std
:
:
max
(
availSize
.
BSize
(
wm
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
1
)
)
;
WritingMode
kidWM
=
firstKid
-
>
GetWritingMode
(
)
;
ReflowInput
kidReflowInput
(
aPresContext
aReflowInput
firstKid
availSize
.
ConvertTo
(
kidWM
wm
)
)
;
if
(
!
aReflowInput
.
mFlags
.
mSpecialBSizeReflow
)
{
kidReflowInput
.
mPercentBSizeObserver
=
this
;
}
kidReflowInput
.
mFlags
.
mSpecialBSizeReflow
=
false
;
if
(
aReflowInput
.
mFlags
.
mSpecialBSizeReflow
|
|
FirstInFlow
(
)
-
>
HasAnyStateBits
(
NS_TABLE_CELL_HAD_SPECIAL_REFLOW
)
)
{
kidReflowInput
.
SetBResize
(
true
)
;
}
nsSize
containerSize
=
aReflowInput
.
ComputedSizeAsContainerIfConstrained
(
)
;
LogicalPoint
kidOrigin
(
wm
borderPadding
.
IStart
(
wm
)
borderPadding
.
BStart
(
wm
)
)
;
nsRect
origRect
=
firstKid
-
>
GetRect
(
)
;
nsRect
origInkOverflow
=
firstKid
-
>
InkOverflowRect
(
)
;
bool
firstReflow
=
firstKid
-
>
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
;
ReflowChild
(
firstKid
aPresContext
kidSize
kidReflowInput
wm
kidOrigin
containerSize
ReflowChildFlags
:
:
Default
aStatus
)
;
if
(
aStatus
.
IsOverflowIncomplete
(
)
)
{
aStatus
.
SetIncomplete
(
)
;
printf
(
"
Set
table
cell
incomplete
%
p
\
n
"
static_cast
<
void
*
>
(
this
)
)
;
}
if
(
HasAnyStateBits
(
NS_FRAME_IS_DIRTY
)
)
{
InvalidateFrameSubtree
(
)
;
}
#
ifdef
DEBUG
DebugCheckChildSize
(
firstKid
kidSize
)
;
#
endif
nsIFrame
*
prevInFlow
=
GetPrevInFlow
(
)
;
bool
isEmpty
;
if
(
prevInFlow
)
{
isEmpty
=
static_cast
<
nsTableCellFrame
*
>
(
prevInFlow
)
-
>
GetContentEmpty
(
)
;
}
else
{
isEmpty
=
!
CellHasVisibleContent
(
kidSize
.
Height
(
)
tableFrame
firstKid
)
;
}
SetContentEmpty
(
isEmpty
)
;
FinishReflowChild
(
firstKid
aPresContext
kidSize
&
kidReflowInput
wm
kidOrigin
containerSize
ReflowChildFlags
:
:
Default
)
;
if
(
tableFrame
-
>
IsBorderCollapse
(
)
)
{
nsTableFrame
:
:
InvalidateTableFrame
(
firstKid
origRect
origInkOverflow
firstReflow
)
;
}
LogicalSize
cellSize
(
wm
)
;
cellSize
.
BSize
(
wm
)
=
kidSize
.
BSize
(
wm
)
;
if
(
NS_UNCONSTRAINEDSIZE
!
=
cellSize
.
BSize
(
wm
)
)
{
cellSize
.
BSize
(
wm
)
+
=
borderPadding
.
BStart
(
wm
)
;
if
(
aStatus
.
IsComplete
(
)
|
|
aReflowInput
.
mStyleBorder
-
>
mBoxDecorationBreak
=
=
StyleBoxDecorationBreak
:
:
Clone
)
{
cellSize
.
BSize
(
wm
)
+
=
borderPadding
.
BEnd
(
wm
)
;
}
}
cellSize
.
ISize
(
wm
)
=
kidSize
.
ISize
(
wm
)
;
if
(
NS_UNCONSTRAINEDSIZE
!
=
cellSize
.
ISize
(
wm
)
)
{
cellSize
.
ISize
(
wm
)
+
=
borderPadding
.
IStartEnd
(
wm
)
;
}
aDesiredSize
.
SetSize
(
wm
cellSize
)
;
if
(
aReflowInput
.
mFlags
.
mSpecialBSizeReflow
&
&
NS_UNCONSTRAINEDSIZE
=
=
aReflowInput
.
AvailableBSize
(
)
)
{
aDesiredSize
.
BSize
(
wm
)
=
BSize
(
wm
)
;
}
if
(
!
GetParent
(
)
-
>
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
&
&
nsSize
(
aDesiredSize
.
Width
(
)
aDesiredSize
.
Height
(
)
)
!
=
mRect
.
Size
(
)
)
{
InvalidateFrame
(
)
;
}
SetDesiredSize
(
aDesiredSize
)
;
PushDirtyBitToAbsoluteFrames
(
)
;
}
NS_QUERYFRAME_HEAD
(
nsTableCellFrame
)
NS_QUERYFRAME_ENTRY
(
nsTableCellFrame
)
NS_QUERYFRAME_ENTRY
(
nsITableCellLayout
)
NS_QUERYFRAME_ENTRY
(
nsIPercentBSizeObserver
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsContainerFrame
)
#
ifdef
ACCESSIBILITY
a11y
:
:
AccType
nsTableCellFrame
:
:
AccessibleType
(
)
{
return
a11y
:
:
eHTMLTableCellType
;
}
#
endif
NS_IMETHODIMP
nsTableCellFrame
:
:
GetCellIndexes
(
int32_t
&
aRowIndex
int32_t
&
aColIndex
)
{
aRowIndex
=
RowIndex
(
)
;
aColIndex
=
mColIndex
;
return
NS_OK
;
}
nsTableCellFrame
*
NS_NewTableCellFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
nsTableFrame
*
aTableFrame
)
{
if
(
aTableFrame
-
>
IsBorderCollapse
(
)
)
return
new
(
aPresShell
)
nsBCTableCellFrame
(
aStyle
aTableFrame
)
;
else
return
new
(
aPresShell
)
nsTableCellFrame
(
aStyle
aTableFrame
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsBCTableCellFrame
)
LogicalMargin
nsTableCellFrame
:
:
GetBorderWidth
(
WritingMode
aWM
)
const
{
return
LogicalMargin
(
aWM
StyleBorder
(
)
-
>
GetComputedBorder
(
)
)
;
}
void
nsTableCellFrame
:
:
AppendDirectlyOwnedAnonBoxes
(
nsTArray
<
OwnedAnonBox
>
&
aResult
)
{
nsIFrame
*
kid
=
mFrames
.
FirstChild
(
)
;
MOZ_ASSERT
(
kid
&
&
!
kid
-
>
GetNextSibling
(
)
"
Table
cells
should
have
just
one
child
"
)
;
aResult
.
AppendElement
(
OwnedAnonBox
(
kid
)
)
;
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
nsTableCellFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
u
"
TableCell
"
_ns
aResult
)
;
}
#
endif
nsBCTableCellFrame
:
:
nsBCTableCellFrame
(
ComputedStyle
*
aStyle
nsTableFrame
*
aTableFrame
)
:
nsTableCellFrame
(
aStyle
aTableFrame
kClassID
)
{
mBStartBorder
=
mIEndBorder
=
mBEndBorder
=
mIStartBorder
=
0
;
}
nsBCTableCellFrame
:
:
~
nsBCTableCellFrame
(
)
=
default
;
nsMargin
nsBCTableCellFrame
:
:
GetUsedBorder
(
)
const
{
WritingMode
wm
=
GetWritingMode
(
)
;
return
GetBorderWidth
(
wm
)
.
GetPhysicalMargin
(
wm
)
;
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
nsBCTableCellFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
u
"
BCTableCell
"
_ns
aResult
)
;
}
#
endif
LogicalMargin
nsBCTableCellFrame
:
:
GetBorderWidth
(
WritingMode
aWM
)
const
{
int32_t
d2a
=
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
return
LogicalMargin
(
aWM
BC_BORDER_END_HALF_COORD
(
d2a
mBStartBorder
)
BC_BORDER_START_HALF_COORD
(
d2a
mIEndBorder
)
BC_BORDER_START_HALF_COORD
(
d2a
mBEndBorder
)
BC_BORDER_END_HALF_COORD
(
d2a
mIStartBorder
)
)
;
}
BCPixelSize
nsBCTableCellFrame
:
:
GetBorderWidth
(
LogicalSide
aSide
)
const
{
switch
(
aSide
)
{
case
eLogicalSideBStart
:
return
BC_BORDER_END_HALF
(
mBStartBorder
)
;
case
eLogicalSideIEnd
:
return
BC_BORDER_START_HALF
(
mIEndBorder
)
;
case
eLogicalSideBEnd
:
return
BC_BORDER_START_HALF
(
mBEndBorder
)
;
default
:
return
BC_BORDER_END_HALF
(
mIStartBorder
)
;
}
}
void
nsBCTableCellFrame
:
:
SetBorderWidth
(
LogicalSide
aSide
BCPixelSize
aValue
)
{
switch
(
aSide
)
{
case
eLogicalSideBStart
:
mBStartBorder
=
aValue
;
break
;
case
eLogicalSideIEnd
:
mIEndBorder
=
aValue
;
break
;
case
eLogicalSideBEnd
:
mBEndBorder
=
aValue
;
break
;
default
:
mIStartBorder
=
aValue
;
}
}
nsMargin
nsBCTableCellFrame
:
:
GetBorderOverflow
(
)
{
WritingMode
wm
=
GetWritingMode
(
)
;
int32_t
d2a
=
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
LogicalMargin
halfBorder
(
wm
BC_BORDER_START_HALF_COORD
(
d2a
mBStartBorder
)
BC_BORDER_END_HALF_COORD
(
d2a
mIEndBorder
)
BC_BORDER_END_HALF_COORD
(
d2a
mBEndBorder
)
BC_BORDER_START_HALF_COORD
(
d2a
mIStartBorder
)
)
;
return
halfBorder
.
GetPhysicalMargin
(
wm
)
;
}
ImgDrawResult
nsBCTableCellFrame
:
:
PaintBackground
(
gfxContext
&
aRenderingContext
const
nsRect
&
aDirtyRect
nsPoint
aPt
uint32_t
aFlags
)
{
WritingMode
wm
=
GetWritingMode
(
)
;
nsMargin
borderWidth
=
GetBorderWidth
(
wm
)
.
GetPhysicalMargin
(
wm
)
;
nsStyleBorder
myBorder
(
*
StyleBorder
(
)
)
;
for
(
const
auto
side
:
mozilla
:
:
AllPhysicalSides
(
)
)
{
myBorder
.
SetBorderWidth
(
side
borderWidth
.
Side
(
side
)
)
;
}
nsRect
rect
(
aPt
GetSize
(
)
)
;
nsCSSRendering
:
:
PaintBGParams
params
=
nsCSSRendering
:
:
PaintBGParams
:
:
ForAllLayers
(
*
PresContext
(
)
aDirtyRect
rect
this
aFlags
)
;
return
nsCSSRendering
:
:
PaintStyleImageLayerWithSC
(
params
aRenderingContext
Style
(
)
myBorder
)
;
}
namespace
mozilla
{
class
nsDisplayTableCellSelection
final
:
public
nsPaintedDisplayItem
{
public
:
nsDisplayTableCellSelection
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
:
nsPaintedDisplayItem
(
aBuilder
aFrame
)
{
MOZ_COUNT_CTOR
(
nsDisplayTableCellSelection
)
;
}
MOZ_COUNTED_DTOR_OVERRIDE
(
nsDisplayTableCellSelection
)
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
{
static_cast
<
nsTableCellFrame
*
>
(
mFrame
)
-
>
DecorateForSelection
(
aCtx
-
>
GetDrawTarget
(
)
ToReferenceFrame
(
)
)
;
}
NS_DISPLAY_DECL_NAME
(
"
TableCellSelection
"
TYPE_TABLE_CELL_SELECTION
)
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
{
RefPtr
<
nsFrameSelection
>
frameSelection
=
mFrame
-
>
PresShell
(
)
-
>
FrameSelection
(
)
;
return
!
frameSelection
-
>
IsInTableSelectionMode
(
)
;
}
}
;
}
void
nsTableCellFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
DO_GLOBAL_REFLOW_COUNT_DSP
(
"
nsTableCellFrame
"
)
;
if
(
ShouldPaintBordersAndBackgrounds
(
)
)
{
bool
hasBoxShadow
=
!
StyleEffects
(
)
-
>
mBoxShadow
.
IsEmpty
(
)
;
if
(
hasBoxShadow
)
{
aLists
.
BorderBackground
(
)
-
>
AppendNewToTop
<
nsDisplayBoxShadowOuter
>
(
aBuilder
this
)
;
}
nsRect
bgRect
=
GetRectRelativeToSelf
(
)
+
aBuilder
-
>
ToReferenceFrame
(
this
)
;
AppendedBackgroundType
result
=
AppendedBackgroundType
:
:
None
;
if
(
aBuilder
-
>
IsForEventDelivery
(
)
|
|
!
StyleBackground
(
)
-
>
IsTransparent
(
this
)
|
|
StyleDisplay
(
)
-
>
HasAppearance
(
)
)
{
result
=
nsDisplayBackgroundImage
:
:
AppendBackgroundItemsToTop
(
aBuilder
this
bgRect
aLists
.
BorderBackground
(
)
)
;
}
if
(
result
=
=
AppendedBackgroundType
:
:
None
)
{
aBuilder
-
>
BuildCompositorHitTestInfoIfNeeded
(
this
aLists
.
BorderBackground
(
)
)
;
}
if
(
hasBoxShadow
)
{
aLists
.
BorderBackground
(
)
-
>
AppendNewToTop
<
nsDisplayBoxShadowInner
>
(
aBuilder
this
)
;
}
ProcessBorders
(
GetTableFrame
(
)
aBuilder
aLists
)
;
if
(
IsSelected
(
)
)
{
aLists
.
BorderBackground
(
)
-
>
AppendNewToTop
<
nsDisplayTableCellSelection
>
(
aBuilder
this
)
;
}
nsDisplayTableBackgroundSet
*
backgrounds
=
aBuilder
-
>
GetTableBackgroundSet
(
)
;
if
(
backgrounds
)
{
bgRect
=
GetRectRelativeToSelf
(
)
+
GetNormalPosition
(
)
;
nsTableRowFrame
*
row
=
GetTableRowFrame
(
)
;
bgRect
+
=
row
-
>
GetNormalPosition
(
)
;
nsTableRowGroupFrame
*
rowGroup
=
row
-
>
GetTableRowGroupFrame
(
)
;
bgRect
+
=
rowGroup
-
>
GetNormalPosition
(
)
;
bgRect
+
=
backgrounds
-
>
TableToReferenceFrame
(
)
;
DisplayListClipState
:
:
AutoSaveRestore
clipState
(
aBuilder
)
;
nsDisplayListBuilder
:
:
AutoCurrentActiveScrolledRootSetter
asrSetter
(
aBuilder
)
;
if
(
IsStackingContext
(
)
)
{
clipState
.
SetClipChainForContainingBlockDescendants
(
backgrounds
-
>
GetTableClipChain
(
)
)
;
asrSetter
.
SetCurrentActiveScrolledRoot
(
backgrounds
-
>
GetTableASR
(
)
)
;
}
nsTableColFrame
*
col
=
backgrounds
-
>
GetColForIndex
(
ColIndex
(
)
)
;
nsTableColGroupFrame
*
colGroup
=
col
-
>
GetTableColGroupFrame
(
)
;
Maybe
<
nsDisplayListBuilder
:
:
AutoBuildingDisplayList
>
buildingForColGroup
;
nsDisplayBackgroundImage
:
:
AppendBackgroundItemsToTop
(
aBuilder
colGroup
bgRect
backgrounds
-
>
ColGroupBackgrounds
(
)
false
colGroup
-
>
GetRect
(
)
+
backgrounds
-
>
TableToReferenceFrame
(
)
this
&
buildingForColGroup
)
;
Maybe
<
nsDisplayListBuilder
:
:
AutoBuildingDisplayList
>
buildingForCol
;
nsDisplayBackgroundImage
:
:
AppendBackgroundItemsToTop
(
aBuilder
col
bgRect
backgrounds
-
>
ColBackgrounds
(
)
false
col
-
>
GetRect
(
)
+
colGroup
-
>
GetPosition
(
)
+
backgrounds
-
>
TableToReferenceFrame
(
)
this
&
buildingForCol
)
;
}
}
DisplayOutline
(
aBuilder
aLists
)
;
nsIFrame
*
kid
=
mFrames
.
FirstChild
(
)
;
NS_ASSERTION
(
kid
&
&
!
kid
-
>
GetNextSibling
(
)
"
Table
cells
should
have
just
one
child
"
)
;
BuildDisplayListForChild
(
aBuilder
kid
aLists
)
;
}
