#
ifndef
nsTableRowFrame_h__
#
define
nsTableRowFrame_h__
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
nscore
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsTableRowGroupFrame
.
h
"
#
include
"
mozilla
/
WritingModes
.
h
"
class
nsTableCellFrame
;
namespace
mozilla
{
struct
TableCellReflowInput
;
}
class
nsTableRowFrame
:
public
nsContainerFrame
{
using
TableCellReflowInput
=
mozilla
:
:
TableCellReflowInput
;
public
:
NS_DECL_QUERYFRAME
NS_DECL_FRAMEARENA_HELPERS
(
nsTableRowFrame
)
virtual
~
nsTableRowFrame
(
)
;
virtual
void
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
override
;
virtual
void
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
override
;
virtual
void
DidSetComputedStyle
(
ComputedStyle
*
aOldComputedStyle
)
override
;
virtual
void
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
override
;
virtual
void
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
aFrameList
)
override
;
virtual
void
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
override
;
friend
nsTableRowFrame
*
NS_NewTableRowFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
nsTableRowGroupFrame
*
GetTableRowGroupFrame
(
)
const
{
nsIFrame
*
parent
=
GetParent
(
)
;
MOZ_ASSERT
(
parent
&
&
parent
-
>
IsTableRowGroupFrame
(
)
)
;
return
static_cast
<
nsTableRowGroupFrame
*
>
(
parent
)
;
}
nsTableFrame
*
GetTableFrame
(
)
const
{
return
GetTableRowGroupFrame
(
)
-
>
GetTableFrame
(
)
;
}
virtual
nsMargin
GetUsedMargin
(
)
const
override
;
virtual
nsMargin
GetUsedBorder
(
)
const
override
;
virtual
nsMargin
GetUsedPadding
(
)
const
override
;
virtual
void
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
override
;
inline
nsTableCellFrame
*
GetFirstCell
(
)
const
;
virtual
void
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
override
;
void
DidResize
(
)
;
#
ifdef
DEBUG_FRAME_DUMP
virtual
nsresult
GetFrameName
(
nsAString
&
aResult
)
const
override
;
#
endif
void
UpdateBSize
(
nscoord
aBSize
nscoord
aAscent
nscoord
aDescent
nsTableFrame
*
aTableFrame
=
nullptr
nsTableCellFrame
*
aCellFrame
=
nullptr
)
;
void
ResetBSize
(
nscoord
aRowStyleBSize
)
;
nscoord
CalcBSize
(
const
ReflowInput
&
aReflowInput
)
;
nscoord
GetMaxCellAscent
(
)
const
;
nscoord
GetRowBaseline
(
mozilla
:
:
WritingMode
aWritingMode
)
;
virtual
int32_t
GetRowIndex
(
)
const
;
void
SetRowIndex
(
int
aRowIndex
)
;
int32_t
GetAdjustmentForStoredIndex
(
int32_t
aStoredIndex
)
const
;
void
AddDeletedRowIndex
(
)
;
nscoord
ReflowCellFrame
(
nsPresContext
*
aPresContext
const
ReflowInput
&
aReflowInput
bool
aIsTopOfPage
nsTableCellFrame
*
aCellFrame
nscoord
aAvailableBSize
nsReflowStatus
&
aStatus
)
;
nscoord
CollapseRowIfNecessary
(
nscoord
aRowOffset
nscoord
aISize
bool
aCollapseGroup
bool
&
aDidCollapse
)
;
void
InsertCellFrame
(
nsTableCellFrame
*
aFrame
int32_t
aColIndex
)
;
nsresult
CalculateCellActualBSize
(
nsTableCellFrame
*
aCellFrame
nscoord
&
aDesiredBSize
mozilla
:
:
WritingMode
aWM
)
;
bool
IsFirstInserted
(
)
const
;
void
SetFirstInserted
(
bool
aValue
)
;
nscoord
GetContentBSize
(
)
const
;
void
SetContentBSize
(
nscoord
aTwipValue
)
;
bool
HasStyleBSize
(
)
const
;
bool
HasFixedBSize
(
)
const
;
void
SetHasFixedBSize
(
bool
aValue
)
;
bool
HasPctBSize
(
)
const
;
void
SetHasPctBSize
(
bool
aValue
)
;
nscoord
GetFixedBSize
(
)
const
;
void
SetFixedBSize
(
nscoord
aValue
)
;
float
GetPctBSize
(
)
const
;
void
SetPctBSize
(
float
aPctValue
bool
aForce
=
false
)
;
nscoord
GetInitialBSize
(
nscoord
aBasis
=
0
)
const
;
nsTableRowFrame
*
GetNextRow
(
)
const
;
bool
HasUnpaginatedBSize
(
)
;
void
SetHasUnpaginatedBSize
(
bool
aValue
)
;
nscoord
GetUnpaginatedBSize
(
)
;
void
SetUnpaginatedBSize
(
nsPresContext
*
aPresContext
nscoord
aValue
)
;
BCPixelSize
GetBStartBCBorderWidth
(
)
const
{
return
mBStartBorderWidth
;
}
BCPixelSize
GetBEndBCBorderWidth
(
)
const
{
return
mBEndBorderWidth
;
}
void
SetBStartBCBorderWidth
(
BCPixelSize
aWidth
)
{
mBStartBorderWidth
=
aWidth
;
}
void
SetBEndBCBorderWidth
(
BCPixelSize
aWidth
)
{
mBEndBorderWidth
=
aWidth
;
}
mozilla
:
:
LogicalMargin
GetBCBorderWidth
(
mozilla
:
:
WritingMode
aWM
)
;
void
GetContinuousBCBorderWidth
(
mozilla
:
:
WritingMode
aWM
mozilla
:
:
LogicalMargin
&
aBorder
)
;
nscoord
GetOuterBStartContBCBorderWidth
(
)
;
void
SetContinuousBCBorderWidth
(
mozilla
:
:
LogicalSide
aForSide
BCPixelSize
aPixelValue
)
;
virtual
bool
IsFrameOfType
(
uint32_t
aFlags
)
const
override
{
if
(
aFlags
&
eSupportsContainLayoutAndPaint
)
{
return
false
;
}
return
nsContainerFrame
:
:
IsFrameOfType
(
aFlags
&
~
(
nsIFrame
:
:
eTablePart
)
)
;
}
virtual
void
InvalidateFrame
(
uint32_t
aDisplayItemKey
=
0
bool
aRebuildDisplayItems
=
true
)
override
;
virtual
void
InvalidateFrameWithRect
(
const
nsRect
&
aRect
uint32_t
aDisplayItemKey
=
0
bool
aRebuildDisplayItems
=
true
)
override
;
virtual
void
InvalidateFrameForRemoval
(
)
override
{
InvalidateFrameSubtree
(
)
;
}
#
ifdef
ACCESSIBILITY
virtual
mozilla
:
:
a11y
:
:
AccType
AccessibleType
(
)
override
;
#
endif
protected
:
explicit
nsTableRowFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
ClassID
aID
=
kClassID
)
;
void
InitChildReflowInput
(
nsPresContext
&
aPresContext
const
mozilla
:
:
LogicalSize
&
aAvailSize
bool
aBorderCollapse
TableCellReflowInput
&
aReflowInput
)
;
virtual
LogicalSides
GetLogicalSkipSides
(
const
ReflowInput
*
aReflowInput
=
nullptr
)
const
override
;
nscoord
ComputeCellXOffset
(
const
ReflowInput
&
aState
nsIFrame
*
aKidFrame
const
nsMargin
&
aKidMargin
)
const
;
void
ReflowChildren
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsTableFrame
&
aTableFrame
nsReflowStatus
&
aStatus
)
;
private
:
struct
RowBits
{
unsigned
mRowIndex
:
29
;
unsigned
mHasFixedBSize
:
1
;
unsigned
mHasPctBSize
:
1
;
unsigned
mFirstInserted
:
1
;
}
mBits
;
nscoord
mContentBSize
;
nscoord
mStylePctBSize
;
nscoord
mStyleFixedBSize
;
nscoord
mMaxCellAscent
;
nscoord
mMaxCellDescent
;
BCPixelSize
mBStartBorderWidth
;
BCPixelSize
mBEndBorderWidth
;
BCPixelSize
mIEndContBorderWidth
;
BCPixelSize
mBStartContBorderWidth
;
BCPixelSize
mIStartContBorderWidth
;
void
InitHasCellWithStyleBSize
(
nsTableFrame
*
aTableFrame
)
;
}
;
inline
int32_t
nsTableRowFrame
:
:
GetAdjustmentForStoredIndex
(
int32_t
aStoredIndex
)
const
{
nsTableRowGroupFrame
*
parentFrame
=
GetTableRowGroupFrame
(
)
;
return
parentFrame
-
>
GetAdjustmentForStoredIndex
(
aStoredIndex
)
;
}
inline
void
nsTableRowFrame
:
:
AddDeletedRowIndex
(
)
{
nsTableRowGroupFrame
*
parentFrame
=
GetTableRowGroupFrame
(
)
;
parentFrame
-
>
AddDeletedRowIndex
(
int32_t
(
mBits
.
mRowIndex
)
)
;
}
inline
int32_t
nsTableRowFrame
:
:
GetRowIndex
(
)
const
{
int32_t
storedRowIndex
=
int32_t
(
mBits
.
mRowIndex
)
;
int32_t
rowIndexAdjustment
=
GetAdjustmentForStoredIndex
(
storedRowIndex
)
;
return
(
storedRowIndex
-
rowIndexAdjustment
)
;
}
inline
void
nsTableRowFrame
:
:
SetRowIndex
(
int
aRowIndex
)
{
MOZ_ASSERT
(
GetTableRowGroupFrame
(
)
-
>
GetTableFrame
(
)
-
>
IsDeletedRowIndexRangesEmpty
(
)
"
mDeletedRowIndexRanges
should
be
empty
here
!
"
)
;
mBits
.
mRowIndex
=
aRowIndex
;
}
inline
bool
nsTableRowFrame
:
:
IsFirstInserted
(
)
const
{
return
bool
(
mBits
.
mFirstInserted
)
;
}
inline
void
nsTableRowFrame
:
:
SetFirstInserted
(
bool
aValue
)
{
mBits
.
mFirstInserted
=
aValue
;
}
inline
bool
nsTableRowFrame
:
:
HasStyleBSize
(
)
const
{
return
(
bool
)
mBits
.
mHasFixedBSize
|
|
(
bool
)
mBits
.
mHasPctBSize
;
}
inline
bool
nsTableRowFrame
:
:
HasFixedBSize
(
)
const
{
return
(
bool
)
mBits
.
mHasFixedBSize
;
}
inline
void
nsTableRowFrame
:
:
SetHasFixedBSize
(
bool
aValue
)
{
mBits
.
mHasFixedBSize
=
aValue
;
}
inline
bool
nsTableRowFrame
:
:
HasPctBSize
(
)
const
{
return
(
bool
)
mBits
.
mHasPctBSize
;
}
inline
void
nsTableRowFrame
:
:
SetHasPctBSize
(
bool
aValue
)
{
mBits
.
mHasPctBSize
=
aValue
;
}
inline
nscoord
nsTableRowFrame
:
:
GetContentBSize
(
)
const
{
return
mContentBSize
;
}
inline
void
nsTableRowFrame
:
:
SetContentBSize
(
nscoord
aValue
)
{
mContentBSize
=
aValue
;
}
inline
nscoord
nsTableRowFrame
:
:
GetFixedBSize
(
)
const
{
if
(
mBits
.
mHasFixedBSize
)
{
return
mStyleFixedBSize
;
}
return
0
;
}
inline
float
nsTableRowFrame
:
:
GetPctBSize
(
)
const
{
if
(
mBits
.
mHasPctBSize
)
{
return
(
float
)
mStylePctBSize
/
100
.
0f
;
}
return
0
.
0f
;
}
inline
bool
nsTableRowFrame
:
:
HasUnpaginatedBSize
(
)
{
return
HasAnyStateBits
(
NS_TABLE_ROW_HAS_UNPAGINATED_BSIZE
)
;
}
inline
void
nsTableRowFrame
:
:
SetHasUnpaginatedBSize
(
bool
aValue
)
{
if
(
aValue
)
{
AddStateBits
(
NS_TABLE_ROW_HAS_UNPAGINATED_BSIZE
)
;
}
else
{
RemoveStateBits
(
NS_TABLE_ROW_HAS_UNPAGINATED_BSIZE
)
;
}
}
inline
mozilla
:
:
LogicalMargin
nsTableRowFrame
:
:
GetBCBorderWidth
(
mozilla
:
:
WritingMode
aWM
)
{
nsPresContext
*
presContext
=
PresContext
(
)
;
return
mozilla
:
:
LogicalMargin
(
aWM
presContext
-
>
DevPixelsToAppUnits
(
mBStartBorderWidth
)
0
presContext
-
>
DevPixelsToAppUnits
(
mBEndBorderWidth
)
0
)
;
}
inline
void
nsTableRowFrame
:
:
GetContinuousBCBorderWidth
(
mozilla
:
:
WritingMode
aWM
mozilla
:
:
LogicalMargin
&
aBorder
)
{
int32_t
d2a
=
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
aBorder
.
IEnd
(
aWM
)
=
BC_BORDER_START_HALF_COORD
(
d2a
mIStartContBorderWidth
)
;
aBorder
.
BStart
(
aWM
)
=
BC_BORDER_END_HALF_COORD
(
d2a
mBStartContBorderWidth
)
;
aBorder
.
IStart
(
aWM
)
=
BC_BORDER_END_HALF_COORD
(
d2a
mIEndContBorderWidth
)
;
}
inline
nscoord
nsTableRowFrame
:
:
GetOuterBStartContBCBorderWidth
(
)
{
int32_t
aPixelsToTwips
=
mozilla
:
:
AppUnitsPerCSSPixel
(
)
;
return
BC_BORDER_START_HALF_COORD
(
aPixelsToTwips
mBStartContBorderWidth
)
;
}
#
endif
