#
ifndef
nsTableFrame_h__
#
define
nsTableFrame_h__
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
celldata
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
nscore
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsStyleCoord
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsCellMap
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
TableArea
.
h
"
struct
BCPaintBorderAction
;
class
nsTableCellFrame
;
class
nsTableCellMap
;
class
nsTableColFrame
;
class
nsTableRowGroupFrame
;
class
nsTableRowFrame
;
class
nsTableColGroupFrame
;
class
nsITableLayoutStrategy
;
namespace
mozilla
{
class
LogicalMargin
;
class
PresShell
;
class
WritingMode
;
struct
TableReflowInput
;
namespace
layers
{
class
StackingContextHelper
;
}
}
struct
BCPropertyData
;
static
inline
bool
IsTableCell
(
mozilla
:
:
LayoutFrameType
frameType
)
{
return
frameType
=
=
mozilla
:
:
LayoutFrameType
:
:
TableCell
|
|
frameType
=
=
mozilla
:
:
LayoutFrameType
:
:
BCTableCell
;
}
class
nsDisplayTableItem
:
public
nsPaintedDisplayItem
{
public
:
nsDisplayTableItem
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
bool
aDrawsBackground
=
true
)
:
nsPaintedDisplayItem
(
aBuilder
aFrame
)
mPartHasFixedBackground
(
false
)
mDrawsBackground
(
aDrawsBackground
)
{
}
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
nsDisplayItemGeometry
*
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
override
;
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
;
void
UpdateForFrameBackground
(
nsIFrame
*
aFrame
)
;
private
:
bool
mPartHasFixedBackground
;
bool
mDrawsBackground
;
}
;
class
nsDisplayTableBackgroundSet
{
public
:
nsDisplayList
*
ColGroupBackgrounds
(
)
{
return
&
mColGroupBackgrounds
;
}
nsDisplayList
*
ColBackgrounds
(
)
{
return
&
mColBackgrounds
;
}
nsDisplayTableBackgroundSet
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aTable
)
:
mBuilder
(
aBuilder
)
{
mPrevTableBackgroundSet
=
mBuilder
-
>
SetTableBackgroundSet
(
this
)
;
mozilla
:
:
DebugOnly
<
const
nsIFrame
*
>
reference
=
mBuilder
-
>
FindReferenceFrameFor
(
aTable
&
mToReferenceFrame
)
;
MOZ_ASSERT
(
nsLayoutUtils
:
:
IsAncestorFrameCrossDoc
(
reference
aTable
)
)
;
}
~
nsDisplayTableBackgroundSet
(
)
{
mozilla
:
:
DebugOnly
<
nsDisplayTableBackgroundSet
*
>
result
=
mBuilder
-
>
SetTableBackgroundSet
(
mPrevTableBackgroundSet
)
;
MOZ_ASSERT
(
result
=
=
this
)
;
}
void
MoveTo
(
const
nsDisplayListSet
&
aDestination
)
{
aDestination
.
BorderBackground
(
)
-
>
AppendToTop
(
ColGroupBackgrounds
(
)
)
;
aDestination
.
BorderBackground
(
)
-
>
AppendToTop
(
ColBackgrounds
(
)
)
;
}
void
AddColumn
(
nsTableColFrame
*
aFrame
)
{
mColumns
.
AppendElement
(
aFrame
)
;
}
nsTableColFrame
*
GetColForIndex
(
int32_t
aIndex
)
{
return
mColumns
[
aIndex
]
;
}
const
nsPoint
&
TableToReferenceFrame
(
)
{
return
mToReferenceFrame
;
}
private
:
void
*
operator
new
(
size_t
sz
)
CPP_THROW_NEW
;
protected
:
nsDisplayListBuilder
*
mBuilder
;
nsDisplayTableBackgroundSet
*
mPrevTableBackgroundSet
;
nsDisplayList
mColGroupBackgrounds
;
nsDisplayList
mColBackgrounds
;
nsTArray
<
nsTableColFrame
*
>
mColumns
;
nsPoint
mToReferenceFrame
;
}
;
enum
nsTableColType
{
eColContent
=
0
eColAnonymousCol
=
1
eColAnonymousColGroup
=
2
eColAnonymousCell
=
3
}
;
class
nsTableFrame
:
public
nsContainerFrame
{
typedef
mozilla
:
:
image
:
:
ImgDrawResult
ImgDrawResult
;
typedef
mozilla
:
:
WritingMode
WritingMode
;
typedef
mozilla
:
:
LogicalMargin
LogicalMargin
;
typedef
mozilla
:
:
TableReflowInput
TableReflowInput
;
public
:
NS_DECL_FRAMEARENA_HELPERS
(
nsTableFrame
)
typedef
nsTArray
<
nsIFrame
*
>
FrameTArray
;
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
PositionedTablePartArray
FrameTArray
)
friend
class
nsTableWrapperFrame
;
friend
nsTableFrame
*
NS_NewTableFrame
(
mozilla
:
:
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
virtual
void
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
override
;
static
float
GetTwipsToPixels
(
nsPresContext
*
aPresContext
)
;
static
bool
AncestorsHaveStyleBSize
(
const
ReflowInput
&
aParentReflowInput
)
;
static
void
CheckRequestSpecialBSizeReflow
(
const
ReflowInput
&
aReflowInput
)
;
static
void
RequestSpecialBSizeReflow
(
const
ReflowInput
&
aReflowInput
)
;
static
void
RePositionViews
(
nsIFrame
*
aFrame
)
;
static
bool
PageBreakAfter
(
nsIFrame
*
aSourceFrame
nsIFrame
*
aNextFrame
)
;
static
void
RegisterPositionedTablePart
(
nsIFrame
*
aFrame
)
;
static
void
UnregisterPositionedTablePart
(
nsIFrame
*
aFrame
nsIFrame
*
aDestructRoot
)
;
nsPoint
GetFirstSectionOrigin
(
const
ReflowInput
&
aReflowInput
)
const
;
void
RowOrColSpanChanged
(
nsTableCellFrame
*
aCellFrame
)
;
virtual
void
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
override
;
virtual
void
DidSetComputedStyle
(
ComputedStyle
*
aOldComputedStyle
)
override
;
virtual
void
SetInitialChildList
(
ChildListID
aListID
nsFrameList
&
aChildList
)
override
;
virtual
void
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
override
;
virtual
void
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
aFrameList
)
override
;
virtual
void
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
override
;
virtual
nsMargin
GetUsedBorder
(
)
const
override
;
virtual
nsMargin
GetUsedPadding
(
)
const
override
;
virtual
nsMargin
GetUsedMargin
(
)
const
override
;
LogicalMargin
GetChildAreaOffset
(
const
WritingMode
aWM
const
ReflowInput
*
aReflowInput
)
const
;
static
nsTableFrame
*
GetTableFrame
(
nsIFrame
*
aSourceFrame
)
;
static
nsTableFrame
*
GetTableFramePassingThrough
(
nsIFrame
*
aMustPassThrough
nsIFrame
*
aSourceFrame
bool
*
aDidPassThrough
)
;
static
nsIFrame
*
GetFrameAtOrBefore
(
nsIFrame
*
aParentFrame
nsIFrame
*
aPriorChildFrame
mozilla
:
:
LayoutFrameType
aChildType
)
;
bool
IsAutoBSize
(
mozilla
:
:
WritingMode
aWM
)
;
bool
IsRowGroup
(
mozilla
:
:
StyleDisplay
aDisplayType
)
const
;
virtual
const
nsFrameList
&
GetChildList
(
ChildListID
aListID
)
const
override
;
virtual
void
GetChildLists
(
nsTArray
<
ChildList
>
*
aLists
)
const
override
;
virtual
void
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
override
;
LogicalMargin
GetOuterBCBorder
(
const
WritingMode
aWM
)
const
;
LogicalMargin
GetIncludedOuterBCBorder
(
const
WritingMode
aWM
)
const
;
LogicalMargin
GetExcludedOuterBCBorder
(
const
WritingMode
aWM
)
const
;
nsMargin
GetDeflationForBackground
(
nsPresContext
*
aPresContext
)
const
;
nscoord
GetContinuousIStartBCBorderWidth
(
)
const
;
void
SetContinuousIStartBCBorderWidth
(
nscoord
aValue
)
;
friend
class
nsDelayedCalcBCBorders
;
void
AddBCDamageArea
(
const
mozilla
:
:
TableArea
&
aValue
)
;
bool
BCRecalcNeeded
(
ComputedStyle
*
aOldComputedStyle
ComputedStyle
*
aNewComputedStyle
)
;
void
PaintBCBorders
(
DrawTarget
&
aDrawTarget
const
nsRect
&
aDirtyRect
)
;
void
CreateWebRenderCommandsForBCBorders
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
const
mozilla
:
:
layers
:
:
StackingContextHelper
&
aSc
const
nsRect
&
aVisibleRect
const
nsPoint
&
aOffsetToReferenceFrame
)
;
virtual
void
MarkIntrinsicISizesDirty
(
)
override
;
virtual
nscoord
GetMinISize
(
gfxContext
*
aRenderingContext
)
override
;
virtual
nscoord
GetPrefISize
(
gfxContext
*
aRenderingContext
)
override
;
IntrinsicISizeOffsetData
IntrinsicISizeOffsets
(
nscoord
aPercentageBasis
=
NS_UNCONSTRAINEDSIZE
)
override
;
virtual
mozilla
:
:
LogicalSize
ComputeSize
(
gfxContext
*
aRenderingContext
mozilla
:
:
WritingMode
aWM
const
mozilla
:
:
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
mozilla
:
:
LogicalSize
&
aMargin
const
mozilla
:
:
LogicalSize
&
aBorder
const
mozilla
:
:
LogicalSize
&
aPadding
ComputeSizeFlags
aFlags
)
override
;
virtual
mozilla
:
:
LogicalSize
ComputeAutoSize
(
gfxContext
*
aRenderingContext
mozilla
:
:
WritingMode
aWM
const
mozilla
:
:
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
mozilla
:
:
LogicalSize
&
aMargin
const
mozilla
:
:
LogicalSize
&
aBorder
const
mozilla
:
:
LogicalSize
&
aPadding
ComputeSizeFlags
aFlags
)
override
;
nscoord
TableShrinkISizeToFit
(
gfxContext
*
aRenderingContext
nscoord
aWidthInCB
)
;
virtual
void
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
override
;
void
ReflowTable
(
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nscoord
aAvailBSize
nsIFrame
*
&
aLastChildReflowed
nsReflowStatus
&
aStatus
)
;
nsFrameList
&
GetColGroups
(
)
;
virtual
ComputedStyle
*
GetParentComputedStyle
(
nsIFrame
*
*
aProviderFrame
)
const
override
;
virtual
bool
IsFrameOfType
(
uint32_t
aFlags
)
const
override
{
if
(
aFlags
&
eSupportsCSSTransforms
)
{
return
false
;
}
return
nsContainerFrame
:
:
IsFrameOfType
(
aFlags
)
;
}
#
ifdef
DEBUG_FRAME_DUMP
virtual
nsresult
GetFrameName
(
nsAString
&
aResult
)
const
override
;
#
endif
nscoord
GetColumnISizeFromFirstInFlow
(
int32_t
aColIndex
)
;
virtual
nscoord
GetColSpacing
(
int32_t
aColIndex
)
;
virtual
nscoord
GetColSpacing
(
int32_t
aStartColIndex
int32_t
aEndColIndex
)
;
virtual
nscoord
GetRowSpacing
(
int32_t
aRowIndex
)
;
virtual
nscoord
GetRowSpacing
(
int32_t
aStartRowIndex
int32_t
aEndRowIndex
)
;
private
:
nscoord
GetColSpacing
(
)
;
nscoord
GetRowSpacing
(
)
;
public
:
virtual
nscoord
GetLogicalBaseline
(
mozilla
:
:
WritingMode
aWritingMode
)
const
override
;
bool
GetNaturalBaselineBOffset
(
mozilla
:
:
WritingMode
aWM
BaselineSharingGroup
aBaselineGroup
nscoord
*
aBaseline
)
const
override
;
int32_t
GetEffectiveRowSpan
(
int32_t
aStartRowIndex
const
nsTableCellFrame
&
aCell
)
const
;
int32_t
GetEffectiveRowSpan
(
const
nsTableCellFrame
&
aCell
nsCellMap
*
aCellMap
=
nullptr
)
;
int32_t
GetEffectiveColSpan
(
const
nsTableCellFrame
&
aCell
nsCellMap
*
aCellMap
=
nullptr
)
const
;
bool
HasMoreThanOneCell
(
int32_t
aRowIndex
)
const
;
nsTableColFrame
*
GetColFrame
(
int32_t
aColIndex
)
const
;
void
InsertCol
(
nsTableColFrame
&
aColFrame
int32_t
aColIndex
)
;
nsTableColGroupFrame
*
CreateSyntheticColGroupFrame
(
)
;
int32_t
DestroyAnonymousColFrames
(
int32_t
aNumFrames
)
;
void
AppendAnonymousColFrames
(
int32_t
aNumColsToAdd
)
;
void
AppendAnonymousColFrames
(
nsTableColGroupFrame
*
aColGroupFrame
int32_t
aNumColsToAdd
nsTableColType
aColType
bool
aAddToTable
)
;
void
MatchCellMapToColCache
(
nsTableCellMap
*
aCellMap
)
;
void
ClearColCache
(
)
;
void
DidResizeColumns
(
)
;
void
AppendCell
(
nsTableCellFrame
&
aCellFrame
int32_t
aRowIndex
)
;
void
InsertCells
(
nsTArray
<
nsTableCellFrame
*
>
&
aCellFrames
int32_t
aRowIndex
int32_t
aColIndexBefore
)
;
void
RemoveCell
(
nsTableCellFrame
*
aCellFrame
int32_t
aRowIndex
)
;
void
AppendRows
(
nsTableRowGroupFrame
*
aRowGroupFrame
int32_t
aRowIndex
nsTArray
<
nsTableRowFrame
*
>
&
aRowFrames
)
;
int32_t
InsertRows
(
nsTableRowGroupFrame
*
aRowGroupFrame
nsTArray
<
nsTableRowFrame
*
>
&
aFrames
int32_t
aRowIndex
bool
aConsiderSpans
)
;
void
RemoveRows
(
nsTableRowFrame
&
aFirstRowFrame
int32_t
aNumRowsToRemove
bool
aConsiderSpans
)
;
void
InsertRowGroups
(
const
nsFrameList
:
:
Slice
&
aRowGroups
)
;
void
InsertColGroups
(
int32_t
aStartColIndex
const
nsFrameList
:
:
Slice
&
aColgroups
)
;
void
RemoveCol
(
nsTableColGroupFrame
*
aColGroupFrame
int32_t
aColIndex
bool
aRemoveFromCache
bool
aRemoveFromCellMap
)
;
bool
ColumnHasCellSpacingBefore
(
int32_t
aColIndex
)
const
;
bool
HasPctCol
(
)
const
;
void
SetHasPctCol
(
bool
aValue
)
;
bool
HasCellSpanningPctCol
(
)
const
;
void
SetHasCellSpanningPctCol
(
bool
aValue
)
;
static
void
InvalidateTableFrame
(
nsIFrame
*
aFrame
const
nsRect
&
aOrigRect
const
nsRect
&
aOrigVisualOverflow
bool
aIsFirstReflow
)
;
virtual
bool
ComputeCustomOverflow
(
nsOverflowAreas
&
aOverflowAreas
)
override
;
void
AppendDirectlyOwnedAnonBoxes
(
nsTArray
<
OwnedAnonBox
>
&
aResult
)
override
;
protected
:
static
void
UpdateStyleOfOwnedAnonBoxesForTableWrapper
(
nsIFrame
*
aOwningFrame
nsIFrame
*
aWrapperFrame
mozilla
:
:
ServoRestyleState
&
aRestyleState
)
;
explicit
nsTableFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
ClassID
aID
=
kClassID
)
;
virtual
~
nsTableFrame
(
)
;
void
InitChildReflowInput
(
ReflowInput
&
aReflowInput
)
;
virtual
LogicalSides
GetLogicalSkipSides
(
const
ReflowInput
*
aReflowInput
=
nullptr
)
const
override
;
void
IterateBCBorders
(
BCPaintBorderAction
&
aAction
const
nsRect
&
aDirtyRect
)
;
public
:
bool
IsRowInserted
(
)
const
;
void
SetRowInserted
(
bool
aValue
)
;
protected
:
nsresult
SetupHeaderFooterChild
(
const
TableReflowInput
&
aReflowInput
nsTableRowGroupFrame
*
aFrame
nscoord
*
aDesiredHeight
)
;
void
ReflowChildren
(
TableReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
nsIFrame
*
&
aLastChildReflowed
nsOverflowAreas
&
aOverflowAreas
)
;
void
ReflowColGroups
(
gfxContext
*
aRenderingContext
)
;
nscoord
GetCollapsedISize
(
const
WritingMode
aWM
const
LogicalMargin
&
aBorderPadding
)
;
void
AdjustForCollapsingRowsCols
(
ReflowOutput
&
aDesiredSize
const
WritingMode
aWM
const
LogicalMargin
&
aBorderPadding
)
;
void
FixupPositionedTableParts
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
)
;
void
ClearAllPositionedTableParts
(
)
;
nsITableLayoutStrategy
*
LayoutStrategy
(
)
const
{
return
static_cast
<
nsTableFrame
*
>
(
FirstInFlow
(
)
)
-
>
mTableLayoutStrategy
;
}
void
HomogenousInsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
aFrameList
)
;
private
:
void
ProcessRowInserted
(
nscoord
aNewHeight
)
;
public
:
nscoord
CalcBorderBoxBSize
(
const
ReflowInput
&
aReflowInput
)
;
protected
:
void
CalcDesiredBSize
(
const
ReflowInput
&
aReflowInput
ReflowOutput
&
aDesiredSize
)
;
void
DistributeBSizeToRows
(
const
ReflowInput
&
aReflowInput
nscoord
aAmount
)
;
void
PlaceChild
(
TableReflowInput
&
aReflowInput
nsIFrame
*
aKidFrame
nsPoint
aKidPosition
ReflowOutput
&
aKidDesiredSize
const
nsRect
&
aOriginalKidRect
const
nsRect
&
aOriginalKidVisualOverflow
)
;
void
PlaceRepeatedFooter
(
TableReflowInput
&
aReflowInput
nsTableRowGroupFrame
*
aTfoot
nscoord
aFooterHeight
)
;
nsIFrame
*
GetFirstBodyRowGroupFrame
(
)
;
public
:
typedef
AutoTArray
<
nsTableRowGroupFrame
*
8
>
RowGroupArray
;
protected
:
void
PushChildren
(
const
RowGroupArray
&
aRowGroups
int32_t
aPushFrom
)
;
public
:
void
OrderRowGroups
(
RowGroupArray
&
aChildren
nsTableRowGroupFrame
*
*
aHead
=
nullptr
nsTableRowGroupFrame
*
*
aFoot
=
nullptr
)
const
;
nsTableRowGroupFrame
*
GetTHead
(
)
const
;
nsTableRowGroupFrame
*
GetTFoot
(
)
const
;
bool
RowIsSpannedInto
(
int32_t
aRowIndex
int32_t
aNumEffCols
)
;
bool
RowHasSpanningCells
(
int32_t
aRowIndex
int32_t
aNumEffCols
)
;
protected
:
bool
HaveReflowedColGroups
(
)
const
;
void
SetHaveReflowedColGroups
(
bool
aValue
)
;
public
:
bool
IsBorderCollapse
(
)
const
;
bool
NeedToCalcBCBorders
(
)
const
;
void
SetNeedToCalcBCBorders
(
bool
aValue
)
;
bool
NeedToCollapse
(
)
const
;
void
SetNeedToCollapse
(
bool
aValue
)
;
bool
NeedToCalcHasBCBorders
(
)
const
;
void
SetNeedToCalcHasBCBorders
(
bool
aValue
)
;
void
CalcHasBCBorders
(
)
;
bool
HasBCBorders
(
)
;
void
SetHasBCBorders
(
bool
aValue
)
;
void
SetGeometryDirty
(
)
{
mBits
.
mGeometryDirty
=
true
;
}
void
ClearGeometryDirty
(
)
{
mBits
.
mGeometryDirty
=
false
;
}
bool
IsGeometryDirty
(
)
const
{
return
mBits
.
mGeometryDirty
;
}
nsTableCellMap
*
GetCellMap
(
)
const
;
void
AdjustRowIndices
(
int32_t
aRowIndex
int32_t
aAdjustment
)
;
void
ResetRowIndices
(
const
nsFrameList
:
:
Slice
&
aRowGroupsToExclude
)
;
nsTArray
<
nsTableColFrame
*
>
&
GetColCache
(
)
;
protected
:
void
SetBorderCollapse
(
bool
aValue
)
;
BCPropertyData
*
GetBCProperty
(
)
const
;
BCPropertyData
*
GetOrCreateBCProperty
(
)
;
void
SetFullBCDamageArea
(
)
;
void
CalcBCBorders
(
)
;
void
ExpandBCDamageArea
(
mozilla
:
:
TableArea
&
aRect
)
const
;
void
SetColumnDimensions
(
nscoord
aHeight
WritingMode
aWM
const
LogicalMargin
&
aBorderPadding
const
nsSize
&
aContainerSize
)
;
int32_t
CollectRows
(
nsIFrame
*
aFrame
nsTArray
<
nsTableRowFrame
*
>
&
aCollection
)
;
public
:
int32_t
GetStartRowIndex
(
nsTableRowGroupFrame
*
aRowGroupFrame
)
;
int32_t
GetRowCount
(
)
const
{
return
GetCellMap
(
)
-
>
GetRowCount
(
)
;
}
int32_t
GetEffectiveColCount
(
)
const
;
int32_t
GetColCount
(
)
const
{
return
GetCellMap
(
)
-
>
GetColCount
(
)
;
}
int32_t
GetIndexOfLastRealCol
(
)
;
bool
IsAutoLayout
(
)
;
public
:
void
AddDeletedRowIndex
(
int32_t
aDeletedRowStoredIndex
)
;
int32_t
GetAdjustmentForStoredIndex
(
int32_t
aStoredIndex
)
;
bool
IsDeletedRowIndexRangesEmpty
(
)
const
{
return
mDeletedRowIndexRanges
.
empty
(
)
;
}
public
:
#
ifdef
DEBUG
void
Dump
(
bool
aDumpRows
bool
aDumpCols
bool
aDumpCellMap
)
;
#
endif
protected
:
void
DoRemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
;
#
ifdef
DEBUG
void
DumpRowGroup
(
nsIFrame
*
aChildFrame
)
;
#
endif
AutoTArray
<
nsTableColFrame
*
8
>
mColFrames
;
struct
TableBits
{
uint32_t
mHaveReflowedColGroups
:
1
;
uint32_t
mHasPctCol
:
1
;
uint32_t
mCellSpansPctCol
:
1
;
uint32_t
mIsBorderCollapse
:
1
;
uint32_t
mRowInserted
:
1
;
uint32_t
mNeedToCalcBCBorders
:
1
;
uint32_t
mGeometryDirty
:
1
;
uint32_t
mIStartContBCBorder
:
8
;
uint32_t
mNeedToCollapse
:
1
;
uint32_t
mResizedColumns
:
1
;
uint32_t
mNeedToCalcHasBCBorders
:
1
;
uint32_t
mHasBCBorders
:
1
;
}
mBits
;
std
:
:
map
<
int32_t
int32_t
>
mDeletedRowIndexRanges
;
nsTableCellMap
*
mCellMap
;
nsITableLayoutStrategy
*
mTableLayoutStrategy
;
nsFrameList
mColGroups
;
}
;
inline
bool
nsTableFrame
:
:
IsRowGroup
(
mozilla
:
:
StyleDisplay
aDisplayType
)
const
{
return
mozilla
:
:
StyleDisplay
:
:
TableHeaderGroup
=
=
aDisplayType
|
|
mozilla
:
:
StyleDisplay
:
:
TableFooterGroup
=
=
aDisplayType
|
|
mozilla
:
:
StyleDisplay
:
:
TableRowGroup
=
=
aDisplayType
;
}
inline
void
nsTableFrame
:
:
SetHaveReflowedColGroups
(
bool
aValue
)
{
mBits
.
mHaveReflowedColGroups
=
aValue
;
}
inline
bool
nsTableFrame
:
:
HaveReflowedColGroups
(
)
const
{
return
(
bool
)
mBits
.
mHaveReflowedColGroups
;
}
inline
bool
nsTableFrame
:
:
HasPctCol
(
)
const
{
return
(
bool
)
mBits
.
mHasPctCol
;
}
inline
void
nsTableFrame
:
:
SetHasPctCol
(
bool
aValue
)
{
mBits
.
mHasPctCol
=
(
unsigned
)
aValue
;
}
inline
bool
nsTableFrame
:
:
HasCellSpanningPctCol
(
)
const
{
return
(
bool
)
mBits
.
mCellSpansPctCol
;
}
inline
void
nsTableFrame
:
:
SetHasCellSpanningPctCol
(
bool
aValue
)
{
mBits
.
mCellSpansPctCol
=
(
unsigned
)
aValue
;
}
inline
bool
nsTableFrame
:
:
IsRowInserted
(
)
const
{
return
(
bool
)
mBits
.
mRowInserted
;
}
inline
void
nsTableFrame
:
:
SetRowInserted
(
bool
aValue
)
{
mBits
.
mRowInserted
=
(
unsigned
)
aValue
;
}
inline
void
nsTableFrame
:
:
SetNeedToCollapse
(
bool
aValue
)
{
static_cast
<
nsTableFrame
*
>
(
FirstInFlow
(
)
)
-
>
mBits
.
mNeedToCollapse
=
(
unsigned
)
aValue
;
}
inline
bool
nsTableFrame
:
:
NeedToCollapse
(
)
const
{
return
(
bool
)
static_cast
<
nsTableFrame
*
>
(
FirstInFlow
(
)
)
-
>
mBits
.
mNeedToCollapse
;
}
inline
nsFrameList
&
nsTableFrame
:
:
GetColGroups
(
)
{
return
static_cast
<
nsTableFrame
*
>
(
FirstInFlow
(
)
)
-
>
mColGroups
;
}
inline
nsTArray
<
nsTableColFrame
*
>
&
nsTableFrame
:
:
GetColCache
(
)
{
return
mColFrames
;
}
inline
bool
nsTableFrame
:
:
IsBorderCollapse
(
)
const
{
return
(
bool
)
mBits
.
mIsBorderCollapse
;
}
inline
void
nsTableFrame
:
:
SetBorderCollapse
(
bool
aValue
)
{
mBits
.
mIsBorderCollapse
=
aValue
;
}
inline
bool
nsTableFrame
:
:
NeedToCalcBCBorders
(
)
const
{
return
(
bool
)
mBits
.
mNeedToCalcBCBorders
;
}
inline
void
nsTableFrame
:
:
SetNeedToCalcBCBorders
(
bool
aValue
)
{
mBits
.
mNeedToCalcBCBorders
=
(
unsigned
)
aValue
;
}
inline
bool
nsTableFrame
:
:
NeedToCalcHasBCBorders
(
)
const
{
return
(
bool
)
mBits
.
mNeedToCalcHasBCBorders
;
}
inline
void
nsTableFrame
:
:
SetNeedToCalcHasBCBorders
(
bool
aValue
)
{
mBits
.
mNeedToCalcHasBCBorders
=
(
unsigned
)
aValue
;
}
inline
bool
nsTableFrame
:
:
HasBCBorders
(
)
{
if
(
NeedToCalcHasBCBorders
(
)
)
{
CalcHasBCBorders
(
)
;
SetNeedToCalcHasBCBorders
(
false
)
;
}
return
(
bool
)
mBits
.
mHasBCBorders
;
}
inline
void
nsTableFrame
:
:
SetHasBCBorders
(
bool
aValue
)
{
mBits
.
mHasBCBorders
=
(
unsigned
)
aValue
;
}
inline
nscoord
nsTableFrame
:
:
GetContinuousIStartBCBorderWidth
(
)
const
{
int32_t
d2a
=
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
return
BC_BORDER_END_HALF_COORD
(
d2a
mBits
.
mIStartContBCBorder
)
;
}
inline
void
nsTableFrame
:
:
SetContinuousIStartBCBorderWidth
(
nscoord
aValue
)
{
mBits
.
mIStartContBCBorder
=
(
unsigned
)
aValue
;
}
#
define
ABORT0
(
)
\
{
\
NS_ASSERTION
(
false
"
CellIterator
program
error
"
)
;
\
return
;
\
}
#
define
ABORT1
(
aReturn
)
\
{
\
NS_ASSERTION
(
false
"
CellIterator
program
error
"
)
;
\
return
aReturn
;
\
}
#
endif
