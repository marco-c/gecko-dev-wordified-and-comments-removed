#
ifndef
nsTableFrame_h__
#
define
nsTableFrame_h__
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
celldata
.
h
"
#
include
"
nscore
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsCellMap
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
TableArea
.
h
"
struct
BCPaintBorderAction
;
struct
BCPropertyData
;
class
nsTableCellFrame
;
class
nsTableCellMap
;
class
nsTableColFrame
;
class
nsTableRowGroupFrame
;
class
nsTableRowFrame
;
class
nsTableColGroupFrame
;
class
nsITableLayoutStrategy
;
namespace
mozilla
{
class
LogicalMargin
;
class
PresShell
;
class
WritingMode
;
struct
TableReflowInput
;
namespace
layers
{
class
StackingContextHelper
;
}
class
nsDisplayTableItem
:
public
nsPaintedDisplayItem
{
public
:
nsDisplayTableItem
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
:
nsPaintedDisplayItem
(
aBuilder
aFrame
)
{
}
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
}
;
class
nsDisplayTableBackgroundSet
{
public
:
nsDisplayList
*
ColGroupBackgrounds
(
)
{
return
&
mColGroupBackgrounds
;
}
nsDisplayList
*
ColBackgrounds
(
)
{
return
&
mColBackgrounds
;
}
nsDisplayTableBackgroundSet
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aTable
)
;
~
nsDisplayTableBackgroundSet
(
)
{
mozilla
:
:
DebugOnly
<
nsDisplayTableBackgroundSet
*
>
result
=
mBuilder
-
>
SetTableBackgroundSet
(
mPrevTableBackgroundSet
)
;
MOZ_ASSERT
(
result
=
=
this
)
;
}
void
MoveTo
(
const
nsDisplayListSet
&
aDestination
)
{
aDestination
.
BorderBackground
(
)
-
>
AppendToTop
(
ColGroupBackgrounds
(
)
)
;
aDestination
.
BorderBackground
(
)
-
>
AppendToTop
(
ColBackgrounds
(
)
)
;
}
void
AddColumn
(
nsTableColFrame
*
aFrame
)
{
mColumns
.
AppendElement
(
aFrame
)
;
}
nsTableColFrame
*
GetColForIndex
(
int32_t
aIndex
)
{
return
mColumns
[
aIndex
]
;
}
const
nsPoint
&
TableToReferenceFrame
(
)
{
return
mToReferenceFrame
;
}
const
nsRect
&
GetDirtyRect
(
)
{
return
mDirtyRect
;
}
const
DisplayItemClipChain
*
GetTableClipChain
(
)
{
return
mCombinedTableClipChain
;
}
const
ActiveScrolledRoot
*
GetTableASR
(
)
{
return
mTableASR
;
}
layers
:
:
ScrollableLayerGuid
:
:
ViewID
GetScrollParentId
(
)
{
return
mCurrentScrollParentId
;
}
private
:
void
*
operator
new
(
size_t
sz
)
noexcept
(
true
)
;
protected
:
nsDisplayListBuilder
*
mBuilder
;
nsDisplayTableBackgroundSet
*
mPrevTableBackgroundSet
;
nsDisplayList
mColGroupBackgrounds
;
nsDisplayList
mColBackgrounds
;
nsTArray
<
nsTableColFrame
*
>
mColumns
;
nsPoint
mToReferenceFrame
;
nsRect
mDirtyRect
;
layers
:
:
ScrollableLayerGuid
:
:
ViewID
mCurrentScrollParentId
;
const
DisplayItemClipChain
*
mCombinedTableClipChain
;
const
ActiveScrolledRoot
*
mTableASR
;
}
;
}
enum
nsTableColType
{
eColContent
=
0
eColAnonymousCol
=
1
eColAnonymousColGroup
=
2
eColAnonymousCell
=
3
}
;
class
nsTableFrame
:
public
nsContainerFrame
{
typedef
mozilla
:
:
image
:
:
ImgDrawResult
ImgDrawResult
;
typedef
mozilla
:
:
WritingMode
WritingMode
;
typedef
mozilla
:
:
LogicalMargin
LogicalMargin
;
typedef
mozilla
:
:
TableReflowInput
TableReflowInput
;
public
:
NS_DECL_FRAMEARENA_HELPERS
(
nsTableFrame
)
typedef
nsTArray
<
nsIFrame
*
>
FrameTArray
;
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
PositionedTablePartArray
FrameTArray
)
friend
class
nsTableWrapperFrame
;
friend
nsTableFrame
*
NS_NewTableFrame
(
mozilla
:
:
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
void
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
override
;
static
bool
AncestorsHaveStyleBSize
(
const
ReflowInput
&
aParentReflowInput
)
;
static
void
CheckRequestSpecialBSizeReflow
(
const
ReflowInput
&
aReflowInput
)
;
static
void
RequestSpecialBSizeReflow
(
const
ReflowInput
&
aReflowInput
)
;
static
void
RePositionViews
(
nsIFrame
*
aFrame
)
;
static
bool
PageBreakAfter
(
nsIFrame
*
aSourceFrame
nsIFrame
*
aNextFrame
)
;
static
void
PositionedTablePartMaybeChanged
(
nsIFrame
*
mozilla
:
:
ComputedStyle
*
aOldStyle
)
;
static
void
MaybeUnregisterPositionedTablePart
(
nsIFrame
*
aFrame
)
;
void
RowOrColSpanChanged
(
nsTableCellFrame
*
aCellFrame
)
;
void
Destroy
(
DestroyContext
&
)
override
;
void
DidSetComputedStyle
(
ComputedStyle
*
aOldComputedStyle
)
override
;
void
SetInitialChildList
(
ChildListID
aListID
nsFrameList
&
&
aChildList
)
override
;
void
AppendFrames
(
ChildListID
aListID
nsFrameList
&
&
aFrameList
)
override
;
void
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
const
nsLineList
:
:
iterator
*
aPrevFrameLine
nsFrameList
&
&
aFrameList
)
override
;
void
RemoveFrame
(
DestroyContext
&
ChildListID
nsIFrame
*
)
override
;
nsMargin
GetUsedBorder
(
)
const
override
;
nsMargin
GetUsedPadding
(
)
const
override
;
nsMargin
GetUsedMargin
(
)
const
override
;
LogicalMargin
GetChildAreaOffset
(
const
WritingMode
aWM
const
ReflowInput
*
aReflowInput
)
const
;
static
nsTableFrame
*
GetTableFrame
(
nsIFrame
*
aSourceFrame
)
;
static
nsIFrame
*
GetFrameAtOrBefore
(
nsIFrame
*
aParentFrame
nsIFrame
*
aPriorChildFrame
mozilla
:
:
LayoutFrameType
aChildType
)
;
bool
IsAutoBSize
(
mozilla
:
:
WritingMode
aWM
)
;
bool
IsRowGroup
(
mozilla
:
:
StyleDisplay
aDisplayType
)
const
;
const
nsFrameList
&
GetChildList
(
ChildListID
aListID
)
const
override
;
void
GetChildLists
(
nsTArray
<
ChildList
>
*
aLists
)
const
override
;
void
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
override
;
LogicalMargin
GetOuterBCBorder
(
const
WritingMode
aWM
)
const
;
LogicalMargin
GetIncludedOuterBCBorder
(
const
WritingMode
aWM
)
const
;
LogicalMargin
GetExcludedOuterBCBorder
(
const
WritingMode
aWM
)
const
;
void
GetCollapsedBorderPadding
(
mozilla
:
:
Maybe
<
mozilla
:
:
LogicalMargin
>
&
aBorder
mozilla
:
:
Maybe
<
mozilla
:
:
LogicalMargin
>
&
aPadding
)
const
;
nsMargin
GetDeflationForBackground
(
nsPresContext
*
aPresContext
)
const
;
nscoord
GetContinuousIStartBCBorderWidth
(
)
const
;
void
SetContinuousIStartBCBorderWidth
(
nscoord
aValue
)
;
friend
class
nsDelayedCalcBCBorders
;
void
AddBCDamageArea
(
const
mozilla
:
:
TableArea
&
aValue
)
;
bool
BCRecalcNeeded
(
ComputedStyle
*
aOldComputedStyle
ComputedStyle
*
aNewComputedStyle
)
;
void
PaintBCBorders
(
DrawTarget
&
aDrawTarget
const
nsRect
&
aDirtyRect
)
;
void
CreateWebRenderCommandsForBCBorders
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
const
mozilla
:
:
layers
:
:
StackingContextHelper
&
aSc
const
nsRect
&
aVisibleRect
const
nsPoint
&
aOffsetToReferenceFrame
)
;
void
MarkIntrinsicISizesDirty
(
)
override
;
nscoord
GetMinISize
(
gfxContext
*
aRenderingContext
)
override
;
nscoord
GetPrefISize
(
gfxContext
*
aRenderingContext
)
override
;
IntrinsicSizeOffsetData
IntrinsicISizeOffsets
(
nscoord
aPercentageBasis
=
NS_UNCONSTRAINEDSIZE
)
override
;
SizeComputationResult
ComputeSize
(
gfxContext
*
aRenderingContext
mozilla
:
:
WritingMode
aWM
const
mozilla
:
:
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
mozilla
:
:
LogicalSize
&
aMargin
const
mozilla
:
:
LogicalSize
&
aBorderPadding
const
mozilla
:
:
StyleSizeOverrides
&
aSizeOverrides
mozilla
:
:
ComputeSizeFlags
aFlags
)
override
;
mozilla
:
:
LogicalSize
ComputeAutoSize
(
gfxContext
*
aRenderingContext
mozilla
:
:
WritingMode
aWM
const
mozilla
:
:
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
mozilla
:
:
LogicalSize
&
aMargin
const
mozilla
:
:
LogicalSize
&
aBorderPadding
const
mozilla
:
:
StyleSizeOverrides
&
aSizeOverrides
mozilla
:
:
ComputeSizeFlags
aFlags
)
override
;
nscoord
TableShrinkISizeToFit
(
gfxContext
*
aRenderingContext
nscoord
aWidthInCB
)
;
void
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
override
;
void
ReflowTable
(
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nscoord
aAvailBSize
nsIFrame
*
&
aLastChildReflowed
nsReflowStatus
&
aStatus
)
;
nsFrameList
&
GetColGroups
(
)
;
ComputedStyle
*
GetParentComputedStyle
(
nsIFrame
*
*
aProviderFrame
)
const
override
;
bool
IsFrameOfType
(
uint32_t
aFlags
)
const
override
{
if
(
aFlags
&
eSupportsCSSTransforms
)
{
return
false
;
}
return
nsContainerFrame
:
:
IsFrameOfType
(
aFlags
)
;
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
GetFrameName
(
nsAString
&
aResult
)
const
override
;
#
endif
nscoord
GetColumnISizeFromFirstInFlow
(
int32_t
aColIndex
)
;
virtual
nscoord
GetColSpacing
(
int32_t
aColIndex
)
;
virtual
nscoord
GetColSpacing
(
int32_t
aStartColIndex
int32_t
aEndColIndex
)
;
virtual
nscoord
GetRowSpacing
(
int32_t
aRowIndex
)
;
virtual
nscoord
GetRowSpacing
(
int32_t
aStartRowIndex
int32_t
aEndRowIndex
)
;
private
:
nscoord
GetColSpacing
(
)
;
nscoord
GetRowSpacing
(
)
;
public
:
nscoord
SynthesizeFallbackBaseline
(
mozilla
:
:
WritingMode
aWM
BaselineSharingGroup
aBaselineGroup
)
const
override
;
Maybe
<
nscoord
>
GetNaturalBaselineBOffset
(
mozilla
:
:
WritingMode
aWM
BaselineSharingGroup
aBaselineGroup
BaselineExportContext
)
const
override
;
int32_t
GetEffectiveRowSpan
(
int32_t
aStartRowIndex
const
nsTableCellFrame
&
aCell
)
const
;
int32_t
GetEffectiveRowSpan
(
const
nsTableCellFrame
&
aCell
nsCellMap
*
aCellMap
=
nullptr
)
;
int32_t
GetEffectiveColSpan
(
const
nsTableCellFrame
&
aCell
nsCellMap
*
aCellMap
=
nullptr
)
const
;
bool
HasMoreThanOneCell
(
int32_t
aRowIndex
)
const
;
nsTableColFrame
*
GetColFrame
(
int32_t
aColIndex
)
const
;
void
InsertCol
(
nsTableColFrame
&
aColFrame
int32_t
aColIndex
)
;
nsTableColGroupFrame
*
CreateSyntheticColGroupFrame
(
)
;
int32_t
DestroyAnonymousColFrames
(
int32_t
aNumFrames
)
;
void
AppendAnonymousColFrames
(
int32_t
aNumColsToAdd
)
;
void
AppendAnonymousColFrames
(
nsTableColGroupFrame
*
aColGroupFrame
int32_t
aNumColsToAdd
nsTableColType
aColType
bool
aAddToTable
)
;
void
MatchCellMapToColCache
(
nsTableCellMap
*
aCellMap
)
;
void
ClearColCache
(
)
;
void
DidResizeColumns
(
)
;
void
AppendCell
(
nsTableCellFrame
&
aCellFrame
int32_t
aRowIndex
)
;
void
InsertCells
(
nsTArray
<
nsTableCellFrame
*
>
&
aCellFrames
int32_t
aRowIndex
int32_t
aColIndexBefore
)
;
void
RemoveCell
(
nsTableCellFrame
*
aCellFrame
int32_t
aRowIndex
)
;
void
AppendRows
(
nsTableRowGroupFrame
*
aRowGroupFrame
int32_t
aRowIndex
nsTArray
<
nsTableRowFrame
*
>
&
aRowFrames
)
;
int32_t
InsertRows
(
nsTableRowGroupFrame
*
aRowGroupFrame
nsTArray
<
nsTableRowFrame
*
>
&
aFrames
int32_t
aRowIndex
bool
aConsiderSpans
)
;
void
RemoveRows
(
nsTableRowFrame
&
aFirstRowFrame
int32_t
aNumRowsToRemove
bool
aConsiderSpans
)
;
void
InsertRowGroups
(
const
nsFrameList
:
:
Slice
&
aRowGroups
)
;
void
InsertColGroups
(
int32_t
aStartColIndex
const
nsFrameList
:
:
Slice
&
aColgroups
)
;
void
RemoveCol
(
nsTableColGroupFrame
*
aColGroupFrame
int32_t
aColIndex
bool
aRemoveFromCache
bool
aRemoveFromCellMap
)
;
bool
ColumnHasCellSpacingBefore
(
int32_t
aColIndex
)
const
;
bool
HasPctCol
(
)
const
;
void
SetHasPctCol
(
bool
aValue
)
;
bool
HasCellSpanningPctCol
(
)
const
;
void
SetHasCellSpanningPctCol
(
bool
aValue
)
;
static
void
InvalidateTableFrame
(
nsIFrame
*
aFrame
const
nsRect
&
aOrigRect
const
nsRect
&
aOrigInkOverflow
bool
aIsFirstReflow
)
;
bool
ComputeCustomOverflow
(
mozilla
:
:
OverflowAreas
&
aOverflowAreas
)
override
;
void
AppendDirectlyOwnedAnonBoxes
(
nsTArray
<
OwnedAnonBox
>
&
aResult
)
override
;
protected
:
static
void
UpdateStyleOfOwnedAnonBoxesForTableWrapper
(
nsIFrame
*
aOwningFrame
nsIFrame
*
aWrapperFrame
mozilla
:
:
ServoRestyleState
&
aRestyleState
)
;
explicit
nsTableFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
ClassID
aID
=
kClassID
)
;
virtual
~
nsTableFrame
(
)
;
void
InitChildReflowInput
(
ReflowInput
&
aReflowInput
)
;
LogicalSides
GetLogicalSkipSides
(
)
const
override
;
void
IterateBCBorders
(
BCPaintBorderAction
&
aAction
const
nsRect
&
aDirtyRect
)
;
public
:
bool
IsRowInserted
(
)
const
;
void
SetRowInserted
(
bool
aValue
)
;
protected
:
nscoord
SetupHeaderFooterChild
(
const
TableReflowInput
&
aReflowInput
nsTableRowGroupFrame
*
aFrame
)
;
void
ReflowChildren
(
TableReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
nsIFrame
*
&
aLastChildReflowed
mozilla
:
:
OverflowAreas
&
aOverflowAreas
)
;
void
ReflowColGroups
(
gfxContext
*
aRenderingContext
)
;
nscoord
GetCollapsedISize
(
const
WritingMode
aWM
const
LogicalMargin
&
aBorderPadding
)
;
void
AdjustForCollapsingRowsCols
(
ReflowOutput
&
aDesiredSize
const
WritingMode
aWM
const
LogicalMargin
&
aBorderPadding
)
;
void
FixupPositionedTableParts
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
)
;
void
ClearAllPositionedTableParts
(
)
;
nsITableLayoutStrategy
*
LayoutStrategy
(
)
const
{
return
static_cast
<
nsTableFrame
*
>
(
FirstInFlow
(
)
)
-
>
mTableLayoutStrategy
.
get
(
)
;
}
void
HomogenousInsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
aFrameList
)
;
private
:
void
ProcessRowInserted
(
nscoord
aNewHeight
)
;
public
:
nscoord
CalcBorderBoxBSize
(
const
ReflowInput
&
aReflowInput
const
LogicalMargin
&
aBorderPadding
nscoord
aIntrinsicBorderBoxBSize
)
;
protected
:
void
CalcDesiredBSize
(
const
ReflowInput
&
aReflowInput
ReflowOutput
&
aDesiredSize
)
;
void
DistributeBSizeToRows
(
const
ReflowInput
&
aReflowInput
nscoord
aAmount
)
;
void
PlaceChild
(
TableReflowInput
&
aReflowInput
nsIFrame
*
aKidFrame
const
ReflowInput
&
aKidReflowInput
const
mozilla
:
:
LogicalPoint
&
aKidPosition
const
nsSize
&
aContainerSize
ReflowOutput
&
aKidDesiredSize
const
nsRect
&
aOriginalKidRect
const
nsRect
&
aOriginalKidInkOverflow
)
;
void
PlaceRepeatedFooter
(
TableReflowInput
&
aReflowInput
nsTableRowGroupFrame
*
aTfoot
nscoord
aFooterHeight
)
;
nsIFrame
*
GetFirstBodyRowGroupFrame
(
)
;
public
:
typedef
AutoTArray
<
nsTableRowGroupFrame
*
8
>
RowGroupArray
;
protected
:
void
PushChildren
(
const
RowGroupArray
&
aRowGroups
int32_t
aPushFrom
)
;
public
:
void
OrderRowGroups
(
RowGroupArray
&
aChildren
nsTableRowGroupFrame
*
*
aHead
=
nullptr
nsTableRowGroupFrame
*
*
aFoot
=
nullptr
)
const
;
bool
RowIsSpannedInto
(
int32_t
aRowIndex
int32_t
aNumEffCols
)
;
bool
RowHasSpanningCells
(
int32_t
aRowIndex
int32_t
aNumEffCols
)
;
protected
:
bool
HaveReflowedColGroups
(
)
const
;
void
SetHaveReflowedColGroups
(
bool
aValue
)
;
public
:
bool
IsBorderCollapse
(
)
const
;
bool
NeedToCalcBCBorders
(
)
const
;
void
SetNeedToCalcBCBorders
(
bool
aValue
)
;
bool
NeedToCollapse
(
)
const
;
void
SetNeedToCollapse
(
bool
aValue
)
;
bool
NeedToCalcHasBCBorders
(
)
const
;
void
SetNeedToCalcHasBCBorders
(
bool
aValue
)
;
void
CalcHasBCBorders
(
)
;
bool
HasBCBorders
(
)
;
void
SetHasBCBorders
(
bool
aValue
)
;
void
SetGeometryDirty
(
)
{
mBits
.
mGeometryDirty
=
true
;
}
void
ClearGeometryDirty
(
)
{
mBits
.
mGeometryDirty
=
false
;
}
bool
IsGeometryDirty
(
)
const
{
return
mBits
.
mGeometryDirty
;
}
nsTableCellMap
*
GetCellMap
(
)
const
;
void
AdjustRowIndices
(
int32_t
aRowIndex
int32_t
aAdjustment
)
;
void
ResetRowIndices
(
const
nsFrameList
:
:
Slice
&
aRowGroupsToExclude
)
;
nsTArray
<
nsTableColFrame
*
>
&
GetColCache
(
)
;
protected
:
void
SetBorderCollapse
(
bool
aValue
)
;
BCPropertyData
*
GetBCProperty
(
)
const
;
BCPropertyData
*
GetOrCreateBCProperty
(
)
;
void
SetFullBCDamageArea
(
)
;
void
CalcBCBorders
(
)
;
void
ExpandBCDamageArea
(
mozilla
:
:
TableArea
&
aRect
)
const
;
void
SetColumnDimensions
(
nscoord
aHeight
WritingMode
aWM
const
LogicalMargin
&
aBorderPadding
const
nsSize
&
aContainerSize
)
;
int32_t
CollectRows
(
nsIFrame
*
aFrame
nsTArray
<
nsTableRowFrame
*
>
&
aCollection
)
;
public
:
int32_t
GetStartRowIndex
(
const
nsTableRowGroupFrame
*
aRowGroupFrame
)
const
;
int32_t
GetRowCount
(
)
const
{
return
GetCellMap
(
)
-
>
GetRowCount
(
)
;
}
int32_t
GetEffectiveColCount
(
)
const
;
int32_t
GetColCount
(
)
const
{
return
GetCellMap
(
)
-
>
GetColCount
(
)
;
}
int32_t
GetIndexOfLastRealCol
(
)
;
bool
IsAutoLayout
(
)
;
public
:
void
AddDeletedRowIndex
(
int32_t
aDeletedRowStoredIndex
)
;
int32_t
GetAdjustmentForStoredIndex
(
int32_t
aStoredIndex
)
;
bool
IsDeletedRowIndexRangesEmpty
(
)
const
{
return
mDeletedRowIndexRanges
.
empty
(
)
;
}
bool
IsDestroying
(
)
const
{
return
mBits
.
mIsDestroying
;
}
public
:
#
ifdef
DEBUG
void
Dump
(
bool
aDumpRows
bool
aDumpCols
bool
aDumpCellMap
)
;
#
endif
protected
:
void
DoRemoveFrame
(
DestroyContext
&
ChildListID
nsIFrame
*
)
;
#
ifdef
DEBUG
void
DumpRowGroup
(
nsIFrame
*
aChildFrame
)
;
#
endif
AutoTArray
<
nsTableColFrame
*
8
>
mColFrames
;
struct
TableBits
{
uint32_t
mHaveReflowedColGroups
:
1
;
uint32_t
mHasPctCol
:
1
;
uint32_t
mCellSpansPctCol
:
1
;
uint32_t
mIsBorderCollapse
:
1
;
uint32_t
mRowInserted
:
1
;
uint32_t
mNeedToCalcBCBorders
:
1
;
uint32_t
mGeometryDirty
:
1
;
uint32_t
mIStartContBCBorder
:
8
;
uint32_t
mNeedToCollapse
:
1
;
uint32_t
mResizedColumns
:
1
;
uint32_t
mNeedToCalcHasBCBorders
:
1
;
uint32_t
mHasBCBorders
:
1
;
uint32_t
mIsDestroying
:
1
;
}
mBits
;
std
:
:
map
<
int32_t
int32_t
>
mDeletedRowIndexRanges
;
mozilla
:
:
UniquePtr
<
nsTableCellMap
>
mCellMap
;
mozilla
:
:
UniquePtr
<
nsITableLayoutStrategy
>
mTableLayoutStrategy
;
nsFrameList
mColGroups
;
}
;
inline
bool
nsTableFrame
:
:
IsRowGroup
(
mozilla
:
:
StyleDisplay
aDisplayType
)
const
{
return
mozilla
:
:
StyleDisplay
:
:
TableHeaderGroup
=
=
aDisplayType
|
|
mozilla
:
:
StyleDisplay
:
:
TableFooterGroup
=
=
aDisplayType
|
|
mozilla
:
:
StyleDisplay
:
:
TableRowGroup
=
=
aDisplayType
;
}
inline
void
nsTableFrame
:
:
SetHaveReflowedColGroups
(
bool
aValue
)
{
mBits
.
mHaveReflowedColGroups
=
aValue
;
}
inline
bool
nsTableFrame
:
:
HaveReflowedColGroups
(
)
const
{
return
(
bool
)
mBits
.
mHaveReflowedColGroups
;
}
inline
bool
nsTableFrame
:
:
HasPctCol
(
)
const
{
return
(
bool
)
mBits
.
mHasPctCol
;
}
inline
void
nsTableFrame
:
:
SetHasPctCol
(
bool
aValue
)
{
mBits
.
mHasPctCol
=
(
unsigned
)
aValue
;
}
inline
bool
nsTableFrame
:
:
HasCellSpanningPctCol
(
)
const
{
return
(
bool
)
mBits
.
mCellSpansPctCol
;
}
inline
void
nsTableFrame
:
:
SetHasCellSpanningPctCol
(
bool
aValue
)
{
mBits
.
mCellSpansPctCol
=
(
unsigned
)
aValue
;
}
inline
bool
nsTableFrame
:
:
IsRowInserted
(
)
const
{
return
(
bool
)
mBits
.
mRowInserted
;
}
inline
void
nsTableFrame
:
:
SetRowInserted
(
bool
aValue
)
{
mBits
.
mRowInserted
=
(
unsigned
)
aValue
;
}
inline
void
nsTableFrame
:
:
SetNeedToCollapse
(
bool
aValue
)
{
static_cast
<
nsTableFrame
*
>
(
FirstInFlow
(
)
)
-
>
mBits
.
mNeedToCollapse
=
(
unsigned
)
aValue
;
}
inline
bool
nsTableFrame
:
:
NeedToCollapse
(
)
const
{
return
(
bool
)
static_cast
<
nsTableFrame
*
>
(
FirstInFlow
(
)
)
-
>
mBits
.
mNeedToCollapse
;
}
inline
nsFrameList
&
nsTableFrame
:
:
GetColGroups
(
)
{
return
static_cast
<
nsTableFrame
*
>
(
FirstInFlow
(
)
)
-
>
mColGroups
;
}
inline
nsTArray
<
nsTableColFrame
*
>
&
nsTableFrame
:
:
GetColCache
(
)
{
return
mColFrames
;
}
inline
bool
nsTableFrame
:
:
IsBorderCollapse
(
)
const
{
return
(
bool
)
mBits
.
mIsBorderCollapse
;
}
inline
void
nsTableFrame
:
:
SetBorderCollapse
(
bool
aValue
)
{
mBits
.
mIsBorderCollapse
=
aValue
;
}
inline
bool
nsTableFrame
:
:
NeedToCalcBCBorders
(
)
const
{
return
(
bool
)
mBits
.
mNeedToCalcBCBorders
;
}
inline
void
nsTableFrame
:
:
SetNeedToCalcBCBorders
(
bool
aValue
)
{
mBits
.
mNeedToCalcBCBorders
=
(
unsigned
)
aValue
;
}
inline
bool
nsTableFrame
:
:
NeedToCalcHasBCBorders
(
)
const
{
return
(
bool
)
mBits
.
mNeedToCalcHasBCBorders
;
}
inline
void
nsTableFrame
:
:
SetNeedToCalcHasBCBorders
(
bool
aValue
)
{
mBits
.
mNeedToCalcHasBCBorders
=
(
unsigned
)
aValue
;
}
inline
bool
nsTableFrame
:
:
HasBCBorders
(
)
{
if
(
NeedToCalcHasBCBorders
(
)
)
{
CalcHasBCBorders
(
)
;
SetNeedToCalcHasBCBorders
(
false
)
;
}
return
(
bool
)
mBits
.
mHasBCBorders
;
}
inline
void
nsTableFrame
:
:
SetHasBCBorders
(
bool
aValue
)
{
mBits
.
mHasBCBorders
=
(
unsigned
)
aValue
;
}
inline
nscoord
nsTableFrame
:
:
GetContinuousIStartBCBorderWidth
(
)
const
{
return
BC_BORDER_END_HALF
(
static_cast
<
nscoord
>
(
mBits
.
mIStartContBCBorder
)
)
;
}
inline
void
nsTableFrame
:
:
SetContinuousIStartBCBorderWidth
(
nscoord
aValue
)
{
mBits
.
mIStartContBCBorder
=
(
unsigned
)
aValue
;
}
#
define
ABORT0
(
)
\
{
\
NS_ASSERTION
(
false
"
CellIterator
program
error
"
)
;
\
return
;
\
}
#
define
ABORT1
(
aReturn
)
\
{
\
NS_ASSERTION
(
false
"
CellIterator
program
error
"
)
;
\
return
aReturn
;
\
}
#
endif
