#
ifndef
nsTableRowGroupFrame_h__
#
define
nsTableRowGroupFrame_h__
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
nscore
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsILineIterator
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTableFrame
.
h
"
#
include
"
mozilla
/
WritingModes
.
h
"
class
nsTableRowFrame
;
namespace
mozilla
{
struct
TableRowGroupReflowInput
;
}
#
define
MIN_ROWS_NEEDING_CURSOR
20
class
nsTableRowGroupFrame
final
:
public
nsContainerFrame
public
nsILineIterator
{
using
TableRowGroupReflowInput
=
mozilla
:
:
TableRowGroupReflowInput
;
public
:
NS_DECL_QUERYFRAME
NS_DECL_FRAMEARENA_HELPERS
(
nsTableRowGroupFrame
)
friend
nsTableRowGroupFrame
*
NS_NewTableRowGroupFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
;
virtual
~
nsTableRowGroupFrame
(
)
;
virtual
void
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
override
{
nsContainerFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
if
(
!
aPrevInFlow
)
{
mWritingMode
=
GetTableFrame
(
)
-
>
GetWritingMode
(
)
;
}
}
virtual
void
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
override
;
virtual
void
DidSetComputedStyle
(
ComputedStyle
*
aOldComputedStyle
)
override
;
virtual
void
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
override
;
virtual
void
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
aFrameList
)
override
;
virtual
void
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
override
;
virtual
nsMargin
GetUsedMargin
(
)
const
override
;
virtual
nsMargin
GetUsedBorder
(
)
const
override
;
virtual
nsMargin
GetUsedPadding
(
)
const
override
;
virtual
void
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
override
;
virtual
void
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
override
;
virtual
bool
ComputeCustomOverflow
(
nsOverflowAreas
&
aOverflowAreas
)
override
;
#
ifdef
DEBUG_FRAME_DUMP
virtual
nsresult
GetFrameName
(
nsAString
&
aResult
)
const
override
;
#
endif
nsTableRowFrame
*
GetFirstRow
(
)
;
nsTableRowFrame
*
GetLastRow
(
)
;
nsTableFrame
*
GetTableFrame
(
)
const
{
nsIFrame
*
parent
=
GetParent
(
)
;
MOZ_ASSERT
(
parent
&
&
parent
-
>
IsTableFrame
(
)
)
;
return
static_cast
<
nsTableFrame
*
>
(
parent
)
;
}
int32_t
GetRowCount
(
)
;
int32_t
GetStartRowIndex
(
)
;
void
AdjustRowIndices
(
int32_t
aRowIndex
int32_t
anAdjustment
)
;
int32_t
GetAdjustmentForStoredIndex
(
int32_t
aStoredIndex
)
;
void
MarkRowsAsDeleted
(
nsTableRowFrame
&
aStartRowFrame
int32_t
aNumRowsToDelete
)
;
void
AddDeletedRowIndex
(
int32_t
aDeletedRowStoredIndex
)
;
nsresult
InitRepeatedFrame
(
nsTableRowGroupFrame
*
aHeaderFooterFrame
)
;
nscoord
GetBSizeBasis
(
const
ReflowInput
&
aReflowInput
)
;
mozilla
:
:
LogicalMargin
GetBCBorderWidth
(
mozilla
:
:
WritingMode
aWM
)
;
void
GetContinuousBCBorderWidth
(
mozilla
:
:
WritingMode
aWM
mozilla
:
:
LogicalMargin
&
aBorder
)
;
void
SetContinuousBCBorderWidth
(
mozilla
:
:
LogicalSide
aForSide
BCPixelSize
aPixelValue
)
;
nscoord
CollapseRowGroupIfNecessary
(
nscoord
aBTotalOffset
nscoord
aISize
mozilla
:
:
WritingMode
aWM
)
;
public
:
virtual
void
DisposeLineIterator
(
)
override
{
}
virtual
int32_t
GetNumLines
(
)
override
;
virtual
bool
GetDirection
(
)
override
;
NS_IMETHOD
GetLine
(
int32_t
aLineNumber
nsIFrame
*
*
aFirstFrameOnLine
int32_t
*
aNumFramesOnLine
nsRect
&
aLineBounds
)
override
;
virtual
int32_t
FindLineContaining
(
nsIFrame
*
aFrame
int32_t
aStartLine
=
0
)
override
;
NS_IMETHOD
FindFrameAt
(
int32_t
aLineNumber
nsPoint
aPos
nsIFrame
*
*
aFrameFound
bool
*
aPosIsBeforeFirstFrame
bool
*
aPosIsAfterLastFrame
)
override
;
NS_IMETHOD
CheckLineOrder
(
int32_t
aLine
bool
*
aIsReordered
nsIFrame
*
*
aFirstVisual
nsIFrame
*
*
aLastVisual
)
override
;
NS_IMETHOD
GetNextSiblingOnLine
(
nsIFrame
*
&
aFrame
int32_t
aLineNumber
)
override
;
struct
FrameCursorData
{
nsTArray
<
nsIFrame
*
>
mFrames
;
uint32_t
mCursorIndex
;
nscoord
mOverflowAbove
;
nscoord
mOverflowBelow
;
FrameCursorData
(
)
:
mFrames
(
MIN_ROWS_NEEDING_CURSOR
)
mCursorIndex
(
0
)
mOverflowAbove
(
0
)
mOverflowBelow
(
0
)
{
}
bool
AppendFrame
(
nsIFrame
*
aFrame
)
;
void
FinishBuildingCursor
(
)
{
mFrames
.
Compact
(
)
;
}
}
;
void
ClearRowCursor
(
)
;
nsIFrame
*
GetFirstRowContaining
(
nscoord
aY
nscoord
*
aOverflowAbove
)
;
FrameCursorData
*
SetupRowCursor
(
)
;
virtual
nsILineIterator
*
GetLineIterator
(
)
override
{
return
this
;
}
virtual
bool
IsFrameOfType
(
uint32_t
aFlags
)
const
override
{
if
(
aFlags
&
eSupportsContainLayoutAndPaint
)
{
return
false
;
}
return
nsContainerFrame
:
:
IsFrameOfType
(
aFlags
&
~
(
nsIFrame
:
:
eTablePart
)
)
;
}
virtual
void
InvalidateFrame
(
uint32_t
aDisplayItemKey
=
0
bool
aRebuildDisplayItems
=
true
)
override
;
virtual
void
InvalidateFrameWithRect
(
const
nsRect
&
aRect
uint32_t
aDisplayItemKey
=
0
bool
aRebuildDisplayItems
=
true
)
override
;
virtual
void
InvalidateFrameForRemoval
(
)
override
{
InvalidateFrameSubtree
(
)
;
}
protected
:
explicit
nsTableRowGroupFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
;
void
InitChildReflowInput
(
nsPresContext
&
aPresContext
bool
aBorderCollapse
ReflowInput
&
aReflowInput
)
;
virtual
LogicalSides
GetLogicalSkipSides
(
const
ReflowInput
*
aReflowInput
=
nullptr
)
const
override
;
void
PlaceChild
(
nsPresContext
*
aPresContext
TableRowGroupReflowInput
&
aReflowInput
nsIFrame
*
aKidFrame
mozilla
:
:
WritingMode
aWM
const
mozilla
:
:
LogicalPoint
&
aKidPosition
const
nsSize
&
aContainerSize
ReflowOutput
&
aDesiredSize
const
nsRect
&
aOriginalKidRect
const
nsRect
&
aOriginalKidVisualOverflow
)
;
void
CalculateRowBSizes
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
)
;
void
DidResizeRows
(
ReflowOutput
&
aDesiredSize
)
;
void
SlideChild
(
TableRowGroupReflowInput
&
aReflowInput
nsIFrame
*
aKidFrame
)
;
void
ReflowChildren
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
TableRowGroupReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
bool
*
aPageBreakBeforeEnd
=
nullptr
)
;
nsresult
SplitRowGroup
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsTableFrame
*
aTableFrame
nsReflowStatus
&
aStatus
bool
aRowForcedPageBreak
)
;
void
SplitSpanningCells
(
nsPresContext
&
aPresContext
const
ReflowInput
&
aReflowInput
nsTableFrame
&
aTableFrame
nsTableRowFrame
&
aFirstRow
nsTableRowFrame
&
aLastRow
bool
aFirstRowIsTopOfPage
nscoord
aSpanningRowBottom
nsTableRowFrame
*
&
aContRowFrame
nsTableRowFrame
*
&
aFirstTruncatedRow
nscoord
&
aDesiredHeight
)
;
void
CreateContinuingRowFrame
(
nsPresContext
&
aPresContext
nsIFrame
&
aRowFrame
nsIFrame
*
*
aContRowFrame
)
;
bool
IsSimpleRowFrame
(
nsTableFrame
*
aTableFrame
nsTableRowFrame
*
aRowFrame
)
;
void
GetNextRowSibling
(
nsIFrame
*
*
aRowFrame
)
;
void
UndoContinuedRow
(
nsPresContext
*
aPresContext
nsTableRowFrame
*
aRow
)
;
private
:
BCPixelSize
mIEndContBorderWidth
;
BCPixelSize
mBEndContBorderWidth
;
BCPixelSize
mIStartContBorderWidth
;
public
:
bool
IsRepeatable
(
)
const
;
void
SetRepeatable
(
bool
aRepeatable
)
;
bool
HasStyleBSize
(
)
const
;
void
SetHasStyleBSize
(
bool
aValue
)
;
bool
HasInternalBreakBefore
(
)
const
;
bool
HasInternalBreakAfter
(
)
const
;
}
;
inline
bool
nsTableRowGroupFrame
:
:
IsRepeatable
(
)
const
{
return
HasAnyStateBits
(
NS_ROWGROUP_REPEATABLE
)
;
}
inline
void
nsTableRowGroupFrame
:
:
SetRepeatable
(
bool
aRepeatable
)
{
if
(
aRepeatable
)
{
AddStateBits
(
NS_ROWGROUP_REPEATABLE
)
;
}
else
{
RemoveStateBits
(
NS_ROWGROUP_REPEATABLE
)
;
}
}
inline
bool
nsTableRowGroupFrame
:
:
HasStyleBSize
(
)
const
{
return
HasAnyStateBits
(
NS_ROWGROUP_HAS_STYLE_BSIZE
)
;
}
inline
void
nsTableRowGroupFrame
:
:
SetHasStyleBSize
(
bool
aValue
)
{
if
(
aValue
)
{
AddStateBits
(
NS_ROWGROUP_HAS_STYLE_BSIZE
)
;
}
else
{
RemoveStateBits
(
NS_ROWGROUP_HAS_STYLE_BSIZE
)
;
}
}
inline
void
nsTableRowGroupFrame
:
:
GetContinuousBCBorderWidth
(
mozilla
:
:
WritingMode
aWM
mozilla
:
:
LogicalMargin
&
aBorder
)
{
int32_t
d2a
=
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
aBorder
.
IEnd
(
aWM
)
=
BC_BORDER_START_HALF_COORD
(
d2a
mIEndContBorderWidth
)
;
aBorder
.
BEnd
(
aWM
)
=
BC_BORDER_START_HALF_COORD
(
d2a
mBEndContBorderWidth
)
;
aBorder
.
IStart
(
aWM
)
=
BC_BORDER_END_HALF_COORD
(
d2a
mIStartContBorderWidth
)
;
}
#
endif
