#
include
"
nsTableFrame
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
Helpers
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
WritingModes
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
mozilla
/
ComputedStyle
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsCellMap
.
h
"
#
include
"
nsTableCellFrame
.
h
"
#
include
"
nsHTMLParts
.
h
"
#
include
"
nsTableColFrame
.
h
"
#
include
"
nsTableColGroupFrame
.
h
"
#
include
"
nsTableRowFrame
.
h
"
#
include
"
nsTableRowGroupFrame
.
h
"
#
include
"
nsTableWrapperFrame
.
h
"
#
include
"
BasicTableLayoutStrategy
.
h
"
#
include
"
FixedTableLayoutStrategy
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCSSRendering
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsCSSAnonBoxes
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsFrameManager
.
h
"
#
include
"
nsError
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
mozilla
/
Range
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsCSSProps
.
h
"
#
include
"
nsStyleChangeList
.
h
"
#
include
<
algorithm
>
#
include
"
gfxPrefs
.
h
"
#
include
"
mozilla
/
layers
/
StackingContextHelper
.
h
"
#
include
"
mozilla
/
layers
/
RenderRootStateManager
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
image
;
using
namespace
mozilla
:
:
layout
;
using
mozilla
:
:
gfx
:
:
AutoRestoreTransform
;
using
mozilla
:
:
gfx
:
:
DrawTarget
;
using
mozilla
:
:
gfx
:
:
Float
;
using
mozilla
:
:
gfx
:
:
ToDeviceColor
;
namespace
mozilla
{
struct
TableReflowInput
{
const
ReflowInput
&
reflowInput
;
LogicalSize
availSize
;
nscoord
iCoord
;
nscoord
bCoord
;
TableReflowInput
(
const
ReflowInput
&
aReflowInput
const
LogicalSize
&
aAvailSize
)
:
reflowInput
(
aReflowInput
)
availSize
(
aAvailSize
)
{
MOZ_ASSERT
(
reflowInput
.
mFrame
-
>
IsTableFrame
(
)
"
TableReflowInput
should
only
be
created
for
nsTableFrame
"
)
;
nsTableFrame
*
table
=
static_cast
<
nsTableFrame
*
>
(
reflowInput
.
mFrame
-
>
FirstInFlow
(
)
)
;
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
LogicalMargin
borderPadding
=
table
-
>
GetChildAreaOffset
(
wm
&
reflowInput
)
;
iCoord
=
borderPadding
.
IStart
(
wm
)
+
table
-
>
GetColSpacing
(
-
1
)
;
bCoord
=
borderPadding
.
BStart
(
wm
)
;
if
(
NS_UNCONSTRAINEDSIZE
!
=
availSize
.
ISize
(
wm
)
)
{
int32_t
colCount
=
table
-
>
GetColCount
(
)
;
availSize
.
ISize
(
wm
)
-
=
borderPadding
.
IStartEnd
(
wm
)
+
table
-
>
GetColSpacing
(
-
1
)
+
table
-
>
GetColSpacing
(
colCount
)
;
availSize
.
ISize
(
wm
)
=
std
:
:
max
(
0
availSize
.
ISize
(
wm
)
)
;
}
if
(
NS_UNCONSTRAINEDSIZE
!
=
availSize
.
BSize
(
wm
)
)
{
availSize
.
BSize
(
wm
)
-
=
borderPadding
.
BStartEnd
(
wm
)
+
table
-
>
GetRowSpacing
(
-
1
)
+
table
-
>
GetRowSpacing
(
table
-
>
GetRowCount
(
)
)
;
availSize
.
BSize
(
wm
)
=
std
:
:
max
(
0
availSize
.
BSize
(
wm
)
)
;
}
}
}
;
}
struct
BCPropertyData
{
BCPropertyData
(
)
:
mBStartBorderWidth
(
0
)
mIEndBorderWidth
(
0
)
mBEndBorderWidth
(
0
)
mIStartBorderWidth
(
0
)
mIStartCellBorderWidth
(
0
)
mIEndCellBorderWidth
(
0
)
{
}
TableArea
mDamageArea
;
BCPixelSize
mBStartBorderWidth
;
BCPixelSize
mIEndBorderWidth
;
BCPixelSize
mBEndBorderWidth
;
BCPixelSize
mIStartBorderWidth
;
BCPixelSize
mIStartCellBorderWidth
;
BCPixelSize
mIEndCellBorderWidth
;
}
;
ComputedStyle
*
nsTableFrame
:
:
GetParentComputedStyle
(
nsIFrame
*
*
aProviderFrame
)
const
{
MOZ_ASSERT
(
GetParent
(
)
"
table
constructed
without
table
wrapper
"
)
;
if
(
!
mContent
-
>
GetParent
(
)
&
&
!
Style
(
)
-
>
GetPseudo
(
)
)
{
*
aProviderFrame
=
nullptr
;
return
nullptr
;
}
return
GetParent
(
)
-
>
DoGetParentComputedStyle
(
aProviderFrame
)
;
}
nsTableFrame
:
:
nsTableFrame
(
ComputedStyle
*
aStyle
ClassID
aID
)
:
nsContainerFrame
(
aStyle
aID
)
mCellMap
(
nullptr
)
mTableLayoutStrategy
(
nullptr
)
{
memset
(
&
mBits
0
sizeof
(
mBits
)
)
;
}
void
nsTableFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
MOZ_ASSERT
(
!
mCellMap
"
Init
called
twice
"
)
;
MOZ_ASSERT
(
!
mTableLayoutStrategy
"
Init
called
twice
"
)
;
MOZ_ASSERT
(
!
aPrevInFlow
|
|
aPrevInFlow
-
>
IsTableFrame
(
)
"
prev
-
in
-
flow
must
be
of
same
type
"
)
;
nsContainerFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
const
nsStyleTableBorder
*
tableStyle
=
StyleTableBorder
(
)
;
bool
borderCollapse
=
(
NS_STYLE_BORDER_COLLAPSE
=
=
tableStyle
-
>
mBorderCollapse
)
;
SetBorderCollapse
(
borderCollapse
)
;
if
(
borderCollapse
)
{
SetNeedToCalcHasBCBorders
(
true
)
;
}
if
(
!
aPrevInFlow
)
{
mCellMap
=
new
nsTableCellMap
(
*
this
borderCollapse
)
;
if
(
IsAutoLayout
(
)
)
{
mTableLayoutStrategy
=
new
BasicTableLayoutStrategy
(
this
)
;
}
else
{
mTableLayoutStrategy
=
new
FixedTableLayoutStrategy
(
this
)
;
}
}
else
{
WritingMode
wm
=
GetWritingMode
(
)
;
SetSize
(
LogicalSize
(
wm
aPrevInFlow
-
>
ISize
(
wm
)
BSize
(
wm
)
)
)
;
}
}
nsTableFrame
:
:
~
nsTableFrame
(
)
{
delete
mCellMap
;
delete
mTableLayoutStrategy
;
}
void
nsTableFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
{
mColGroups
.
DestroyFramesFrom
(
aDestructRoot
aPostDestroyData
)
;
nsContainerFrame
:
:
DestroyFrom
(
aDestructRoot
aPostDestroyData
)
;
}
void
nsTableFrame
:
:
RePositionViews
(
nsIFrame
*
aFrame
)
{
nsContainerFrame
:
:
PositionFrameView
(
aFrame
)
;
nsContainerFrame
:
:
PositionChildViews
(
aFrame
)
;
}
static
bool
IsRepeatedFrame
(
nsIFrame
*
kidFrame
)
{
return
(
kidFrame
-
>
IsTableRowFrame
(
)
|
|
kidFrame
-
>
IsTableRowGroupFrame
(
)
)
&
&
kidFrame
-
>
HasAnyStateBits
(
NS_REPEATED_ROW_OR_ROWGROUP
)
;
}
bool
nsTableFrame
:
:
PageBreakAfter
(
nsIFrame
*
aSourceFrame
nsIFrame
*
aNextFrame
)
{
const
nsStyleDisplay
*
display
=
aSourceFrame
-
>
StyleDisplay
(
)
;
nsTableRowGroupFrame
*
prevRg
=
do_QueryFrame
(
aSourceFrame
)
;
if
(
(
display
-
>
BreakAfter
(
)
|
|
(
prevRg
&
&
prevRg
-
>
HasInternalBreakAfter
(
)
)
)
&
&
!
IsRepeatedFrame
(
aSourceFrame
)
)
{
return
!
(
aNextFrame
&
&
IsRepeatedFrame
(
aNextFrame
)
)
;
}
if
(
aNextFrame
)
{
display
=
aNextFrame
-
>
StyleDisplay
(
)
;
nsTableRowGroupFrame
*
nextRg
=
do_QueryFrame
(
aNextFrame
)
;
if
(
(
display
-
>
BreakBefore
(
)
|
|
(
nextRg
&
&
nextRg
-
>
HasInternalBreakBefore
(
)
)
)
&
&
!
IsRepeatedFrame
(
aNextFrame
)
)
{
return
!
IsRepeatedFrame
(
aSourceFrame
)
;
}
}
return
false
;
}
void
nsTableFrame
:
:
RegisterPositionedTablePart
(
nsIFrame
*
aFrame
)
{
if
(
!
IsTableCell
(
aFrame
-
>
Type
(
)
)
)
{
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
nsPresContext
*
presContext
=
aFrame
-
>
PresContext
(
)
;
if
(
content
&
&
!
presContext
-
>
HasWarnedAboutPositionedTableParts
(
)
)
{
presContext
-
>
SetHasWarnedAboutPositionedTableParts
(
)
;
nsContentUtils
:
:
ReportToConsole
(
nsIScriptError
:
:
warningFlag
NS_LITERAL_CSTRING
(
"
Layout
:
Tables
"
)
content
-
>
OwnerDoc
(
)
nsContentUtils
:
:
eLAYOUT_PROPERTIES
"
TablePartRelPosWarning
"
)
;
}
}
nsTableFrame
*
tableFrame
=
nsTableFrame
:
:
GetTableFrame
(
aFrame
)
;
MOZ_ASSERT
(
tableFrame
"
Should
have
a
table
frame
here
"
)
;
tableFrame
=
static_cast
<
nsTableFrame
*
>
(
tableFrame
-
>
FirstContinuation
(
)
)
;
FrameTArray
*
positionedParts
=
tableFrame
-
>
GetProperty
(
PositionedTablePartArray
(
)
)
;
if
(
!
positionedParts
)
{
positionedParts
=
new
FrameTArray
;
tableFrame
-
>
SetProperty
(
PositionedTablePartArray
(
)
positionedParts
)
;
}
positionedParts
-
>
AppendElement
(
aFrame
)
;
}
void
nsTableFrame
:
:
UnregisterPositionedTablePart
(
nsIFrame
*
aFrame
nsIFrame
*
aDestructRoot
)
{
bool
didPassThrough
;
nsTableFrame
*
tableFrame
=
GetTableFramePassingThrough
(
aDestructRoot
aFrame
&
didPassThrough
)
;
if
(
!
didPassThrough
&
&
!
tableFrame
-
>
GetPrevContinuation
(
)
)
{
return
;
}
tableFrame
=
static_cast
<
nsTableFrame
*
>
(
tableFrame
-
>
FirstContinuation
(
)
)
;
FrameTArray
*
positionedParts
=
tableFrame
-
>
GetProperty
(
PositionedTablePartArray
(
)
)
;
MOZ_ASSERT
(
positionedParts
&
&
positionedParts
-
>
Contains
(
aFrame
)
"
Asked
to
unregister
a
positioned
table
part
that
wasn
'
t
registered
"
)
;
if
(
positionedParts
)
{
positionedParts
-
>
RemoveElement
(
aFrame
)
;
}
}
void
nsTableFrame
:
:
SetInitialChildList
(
ChildListID
aListID
nsFrameList
&
aChildList
)
{
if
(
aListID
!
=
kPrincipalList
)
{
nsContainerFrame
:
:
SetInitialChildList
(
aListID
aChildList
)
;
return
;
}
MOZ_ASSERT
(
mFrames
.
IsEmpty
(
)
&
&
mColGroups
.
IsEmpty
(
)
"
unexpected
second
call
to
SetInitialChildList
"
)
;
while
(
aChildList
.
NotEmpty
(
)
)
{
nsIFrame
*
childFrame
=
aChildList
.
FirstChild
(
)
;
aChildList
.
RemoveFirstChild
(
)
;
const
nsStyleDisplay
*
childDisplay
=
childFrame
-
>
StyleDisplay
(
)
;
if
(
mozilla
:
:
StyleDisplay
:
:
TableColumnGroup
=
=
childDisplay
-
>
mDisplay
)
{
NS_ASSERTION
(
childFrame
-
>
IsTableColGroupFrame
(
)
"
This
is
not
a
colgroup
"
)
;
mColGroups
.
AppendFrame
(
nullptr
childFrame
)
;
}
else
{
mFrames
.
AppendFrame
(
nullptr
childFrame
)
;
}
}
if
(
!
GetPrevInFlow
(
)
)
{
InsertColGroups
(
0
mColGroups
)
;
InsertRowGroups
(
mFrames
)
;
if
(
IsBorderCollapse
(
)
)
{
SetFullBCDamageArea
(
)
;
}
}
}
void
nsTableFrame
:
:
RowOrColSpanChanged
(
nsTableCellFrame
*
aCellFrame
)
{
if
(
aCellFrame
)
{
nsTableCellMap
*
cellMap
=
GetCellMap
(
)
;
if
(
cellMap
)
{
uint32_t
rowIndex
=
aCellFrame
-
>
RowIndex
(
)
;
uint32_t
colIndex
=
aCellFrame
-
>
ColIndex
(
)
;
RemoveCell
(
aCellFrame
rowIndex
)
;
AutoTArray
<
nsTableCellFrame
*
1
>
cells
;
cells
.
AppendElement
(
aCellFrame
)
;
InsertCells
(
cells
rowIndex
colIndex
-
1
)
;
PresShell
(
)
-
>
FrameNeedsReflow
(
this
nsIPresShell
:
:
eTreeChange
NS_FRAME_IS_DIRTY
)
;
}
}
}
int32_t
nsTableFrame
:
:
GetEffectiveColCount
(
)
const
{
int32_t
colCount
=
GetColCount
(
)
;
if
(
LayoutStrategy
(
)
-
>
GetType
(
)
=
=
nsITableLayoutStrategy
:
:
Auto
)
{
nsTableCellMap
*
cellMap
=
GetCellMap
(
)
;
if
(
!
cellMap
)
{
return
0
;
}
for
(
int32_t
colIdx
=
colCount
-
1
;
colIdx
>
=
0
;
colIdx
-
-
)
{
if
(
cellMap
-
>
GetNumCellsOriginatingInCol
(
colIdx
)
>
0
)
{
break
;
}
colCount
-
-
;
}
}
return
colCount
;
}
int32_t
nsTableFrame
:
:
GetIndexOfLastRealCol
(
)
{
int32_t
numCols
=
mColFrames
.
Length
(
)
;
if
(
numCols
>
0
)
{
for
(
int32_t
colIdx
=
numCols
-
1
;
colIdx
>
=
0
;
colIdx
-
-
)
{
nsTableColFrame
*
colFrame
=
GetColFrame
(
colIdx
)
;
if
(
colFrame
)
{
if
(
eColAnonymousCell
!
=
colFrame
-
>
GetColType
(
)
)
{
return
colIdx
;
}
}
}
}
return
-
1
;
}
nsTableColFrame
*
nsTableFrame
:
:
GetColFrame
(
int32_t
aColIndex
)
const
{
NS_ASSERTION
(
!
GetPrevInFlow
(
)
"
GetColFrame
called
on
next
in
flow
"
)
;
int32_t
numCols
=
mColFrames
.
Length
(
)
;
if
(
(
aColIndex
>
=
0
)
&
&
(
aColIndex
<
numCols
)
)
{
return
mColFrames
.
ElementAt
(
aColIndex
)
;
}
else
{
NS_ERROR
(
"
invalid
col
index
"
)
;
return
nullptr
;
}
}
int32_t
nsTableFrame
:
:
GetEffectiveRowSpan
(
int32_t
aRowIndex
const
nsTableCellFrame
&
aCell
)
const
{
nsTableCellMap
*
cellMap
=
GetCellMap
(
)
;
MOZ_ASSERT
(
nullptr
!
=
cellMap
"
bad
call
cellMap
not
yet
allocated
.
"
)
;
return
cellMap
-
>
GetEffectiveRowSpan
(
aRowIndex
aCell
.
ColIndex
(
)
)
;
}
int32_t
nsTableFrame
:
:
GetEffectiveRowSpan
(
const
nsTableCellFrame
&
aCell
nsCellMap
*
aCellMap
)
{
nsTableCellMap
*
tableCellMap
=
GetCellMap
(
)
;
if
(
!
tableCellMap
)
ABORT1
(
1
)
;
uint32_t
colIndex
=
aCell
.
ColIndex
(
)
;
uint32_t
rowIndex
=
aCell
.
RowIndex
(
)
;
if
(
aCellMap
)
return
aCellMap
-
>
GetRowSpan
(
rowIndex
colIndex
true
)
;
else
return
tableCellMap
-
>
GetEffectiveRowSpan
(
rowIndex
colIndex
)
;
}
int32_t
nsTableFrame
:
:
GetEffectiveColSpan
(
const
nsTableCellFrame
&
aCell
nsCellMap
*
aCellMap
)
const
{
nsTableCellMap
*
tableCellMap
=
GetCellMap
(
)
;
if
(
!
tableCellMap
)
ABORT1
(
1
)
;
uint32_t
colIndex
=
aCell
.
ColIndex
(
)
;
uint32_t
rowIndex
=
aCell
.
RowIndex
(
)
;
if
(
aCellMap
)
return
aCellMap
-
>
GetEffectiveColSpan
(
*
tableCellMap
rowIndex
colIndex
)
;
else
return
tableCellMap
-
>
GetEffectiveColSpan
(
rowIndex
colIndex
)
;
}
bool
nsTableFrame
:
:
HasMoreThanOneCell
(
int32_t
aRowIndex
)
const
{
nsTableCellMap
*
tableCellMap
=
GetCellMap
(
)
;
if
(
!
tableCellMap
)
ABORT1
(
1
)
;
return
tableCellMap
-
>
HasMoreThanOneCell
(
aRowIndex
)
;
}
void
nsTableFrame
:
:
AdjustRowIndices
(
int32_t
aRowIndex
int32_t
aAdjustment
)
{
RowGroupArray
rowGroups
;
OrderRowGroups
(
rowGroups
)
;
for
(
uint32_t
rgIdx
=
0
;
rgIdx
<
rowGroups
.
Length
(
)
;
rgIdx
+
+
)
{
rowGroups
[
rgIdx
]
-
>
AdjustRowIndices
(
aRowIndex
aAdjustment
)
;
}
}
void
nsTableFrame
:
:
ResetRowIndices
(
const
nsFrameList
:
:
Slice
&
aRowGroupsToExclude
)
{
mDeletedRowIndexRanges
.
clear
(
)
;
RowGroupArray
rowGroups
;
OrderRowGroups
(
rowGroups
)
;
nsTHashtable
<
nsPtrHashKey
<
nsTableRowGroupFrame
>
>
excludeRowGroups
;
nsFrameList
:
:
Enumerator
excludeRowGroupsEnumerator
(
aRowGroupsToExclude
)
;
while
(
!
excludeRowGroupsEnumerator
.
AtEnd
(
)
)
{
excludeRowGroups
.
PutEntry
(
static_cast
<
nsTableRowGroupFrame
*
>
(
excludeRowGroupsEnumerator
.
get
(
)
)
)
;
#
ifdef
DEBUG
{
const
nsFrameList
&
rowFrames
=
excludeRowGroupsEnumerator
.
get
(
)
-
>
PrincipalChildList
(
)
;
for
(
nsFrameList
:
:
Enumerator
rows
(
rowFrames
)
;
!
rows
.
AtEnd
(
)
;
rows
.
Next
(
)
)
{
nsTableRowFrame
*
row
=
static_cast
<
nsTableRowFrame
*
>
(
rows
.
get
(
)
)
;
MOZ_ASSERT
(
row
-
>
GetRowIndex
(
)
=
=
0
"
exclusions
cannot
be
used
for
rows
that
were
already
added
"
"
because
we
'
d
need
to
process
mDeletedRowIndexRanges
"
)
;
}
}
#
endif
excludeRowGroupsEnumerator
.
Next
(
)
;
}
int32_t
rowIndex
=
0
;
for
(
uint32_t
rgIdx
=
0
;
rgIdx
<
rowGroups
.
Length
(
)
;
rgIdx
+
+
)
{
nsTableRowGroupFrame
*
rgFrame
=
rowGroups
[
rgIdx
]
;
if
(
!
excludeRowGroups
.
GetEntry
(
rgFrame
)
)
{
const
nsFrameList
&
rowFrames
=
rgFrame
-
>
PrincipalChildList
(
)
;
for
(
nsFrameList
:
:
Enumerator
rows
(
rowFrames
)
;
!
rows
.
AtEnd
(
)
;
rows
.
Next
(
)
)
{
if
(
mozilla
:
:
StyleDisplay
:
:
TableRow
=
=
rows
.
get
(
)
-
>
StyleDisplay
(
)
-
>
mDisplay
)
{
nsTableRowFrame
*
row
=
static_cast
<
nsTableRowFrame
*
>
(
rows
.
get
(
)
)
;
row
-
>
SetRowIndex
(
rowIndex
)
;
rowIndex
+
+
;
}
}
}
}
}
void
nsTableFrame
:
:
InsertColGroups
(
int32_t
aStartColIndex
const
nsFrameList
:
:
Slice
&
aColGroups
)
{
int32_t
colIndex
=
aStartColIndex
;
nsFrameList
:
:
Enumerator
colGroups
(
aColGroups
)
;
for
(
;
!
colGroups
.
AtEnd
(
)
;
colGroups
.
Next
(
)
)
{
MOZ_ASSERT
(
colGroups
.
get
(
)
-
>
IsTableColGroupFrame
(
)
)
;
nsTableColGroupFrame
*
cgFrame
=
static_cast
<
nsTableColGroupFrame
*
>
(
colGroups
.
get
(
)
)
;
cgFrame
-
>
SetStartColumnIndex
(
colIndex
)
;
cgFrame
-
>
AddColsToTable
(
colIndex
false
colGroups
.
get
(
)
-
>
PrincipalChildList
(
)
)
;
int32_t
numCols
=
cgFrame
-
>
GetColCount
(
)
;
colIndex
+
=
numCols
;
}
nsFrameList
:
:
Enumerator
remainingColgroups
=
colGroups
.
GetUnlimitedEnumerator
(
)
;
if
(
!
remainingColgroups
.
AtEnd
(
)
)
{
nsTableColGroupFrame
:
:
ResetColIndices
(
static_cast
<
nsTableColGroupFrame
*
>
(
remainingColgroups
.
get
(
)
)
colIndex
)
;
}
}
void
nsTableFrame
:
:
InsertCol
(
nsTableColFrame
&
aColFrame
int32_t
aColIndex
)
{
mColFrames
.
InsertElementAt
(
aColIndex
&
aColFrame
)
;
nsTableColType
insertedColType
=
aColFrame
.
GetColType
(
)
;
int32_t
numCacheCols
=
mColFrames
.
Length
(
)
;
nsTableCellMap
*
cellMap
=
GetCellMap
(
)
;
if
(
cellMap
)
{
int32_t
numMapCols
=
cellMap
-
>
GetColCount
(
)
;
if
(
numCacheCols
>
numMapCols
)
{
bool
removedFromCache
=
false
;
if
(
eColAnonymousCell
!
=
insertedColType
)
{
nsTableColFrame
*
lastCol
=
mColFrames
.
ElementAt
(
numCacheCols
-
1
)
;
if
(
lastCol
)
{
nsTableColType
lastColType
=
lastCol
-
>
GetColType
(
)
;
if
(
eColAnonymousCell
=
=
lastColType
)
{
mColFrames
.
RemoveElementAt
(
numCacheCols
-
1
)
;
nsTableColGroupFrame
*
lastColGroup
=
(
nsTableColGroupFrame
*
)
mColGroups
.
LastChild
(
)
;
if
(
lastColGroup
)
{
MOZ_ASSERT
(
lastColGroup
-
>
IsSynthetic
(
)
)
;
lastColGroup
-
>
RemoveChild
(
*
lastCol
false
)
;
if
(
lastColGroup
-
>
GetColCount
(
)
<
=
0
)
{
mColGroups
.
DestroyFrame
(
(
nsIFrame
*
)
lastColGroup
)
;
}
}
removedFromCache
=
true
;
}
}
}
if
(
!
removedFromCache
)
{
cellMap
-
>
AddColsAtEnd
(
1
)
;
}
}
}
if
(
IsBorderCollapse
(
)
)
{
TableArea
damageArea
(
aColIndex
0
1
GetRowCount
(
)
)
;
AddBCDamageArea
(
damageArea
)
;
}
}
void
nsTableFrame
:
:
RemoveCol
(
nsTableColGroupFrame
*
aColGroupFrame
int32_t
aColIndex
bool
aRemoveFromCache
bool
aRemoveFromCellMap
)
{
if
(
aRemoveFromCache
)
{
mColFrames
.
RemoveElementAt
(
aColIndex
)
;
}
if
(
aRemoveFromCellMap
)
{
nsTableCellMap
*
cellMap
=
GetCellMap
(
)
;
if
(
cellMap
)
{
if
(
!
mColFrames
.
IsEmpty
(
)
&
&
mColFrames
.
LastElement
(
)
&
&
mColFrames
.
LastElement
(
)
-
>
GetColType
(
)
=
=
eColAnonymousCell
)
{
AppendAnonymousColFrames
(
1
)
;
}
else
{
cellMap
-
>
RemoveColsAtEnd
(
)
;
MatchCellMapToColCache
(
cellMap
)
;
}
}
}
if
(
IsBorderCollapse
(
)
)
{
TableArea
damageArea
(
0
0
GetColCount
(
)
GetRowCount
(
)
)
;
AddBCDamageArea
(
damageArea
)
;
}
}
nsTableCellMap
*
nsTableFrame
:
:
GetCellMap
(
)
const
{
return
static_cast
<
nsTableFrame
*
>
(
FirstInFlow
(
)
)
-
>
mCellMap
;
}
nsTableColGroupFrame
*
nsTableFrame
:
:
CreateSyntheticColGroupFrame
(
)
{
nsIContent
*
colGroupContent
=
GetContent
(
)
;
nsPresContext
*
presContext
=
PresContext
(
)
;
nsIPresShell
*
shell
=
presContext
-
>
PresShell
(
)
;
RefPtr
<
ComputedStyle
>
colGroupStyle
;
colGroupStyle
=
shell
-
>
StyleSet
(
)
-
>
ResolveNonInheritingAnonymousBoxStyle
(
nsCSSAnonBoxes
:
:
tableColGroup
(
)
)
;
nsTableColGroupFrame
*
newFrame
=
NS_NewTableColGroupFrame
(
shell
colGroupStyle
)
;
newFrame
-
>
SetIsSynthetic
(
)
;
newFrame
-
>
Init
(
colGroupContent
this
nullptr
)
;
return
newFrame
;
}
void
nsTableFrame
:
:
AppendAnonymousColFrames
(
int32_t
aNumColsToAdd
)
{
MOZ_ASSERT
(
aNumColsToAdd
>
0
"
We
should
be
adding
_something_
.
"
)
;
nsTableColGroupFrame
*
colGroupFrame
=
static_cast
<
nsTableColGroupFrame
*
>
(
mColGroups
.
LastChild
(
)
)
;
if
(
!
colGroupFrame
|
|
!
colGroupFrame
-
>
IsSynthetic
(
)
)
{
int32_t
colIndex
=
(
colGroupFrame
)
?
colGroupFrame
-
>
GetStartColumnIndex
(
)
+
colGroupFrame
-
>
GetColCount
(
)
:
0
;
colGroupFrame
=
CreateSyntheticColGroupFrame
(
)
;
if
(
!
colGroupFrame
)
{
return
;
}
mColGroups
.
AppendFrame
(
this
colGroupFrame
)
;
colGroupFrame
-
>
SetStartColumnIndex
(
colIndex
)
;
}
AppendAnonymousColFrames
(
colGroupFrame
aNumColsToAdd
eColAnonymousCell
true
)
;
}
void
nsTableFrame
:
:
AppendAnonymousColFrames
(
nsTableColGroupFrame
*
aColGroupFrame
int32_t
aNumColsToAdd
nsTableColType
aColType
bool
aAddToTable
)
{
MOZ_ASSERT
(
aColGroupFrame
"
null
frame
"
)
;
MOZ_ASSERT
(
aColType
!
=
eColAnonymousCol
"
Shouldn
'
t
happen
"
)
;
MOZ_ASSERT
(
aNumColsToAdd
>
0
"
We
should
be
adding
_something_
.
"
)
;
nsIPresShell
*
shell
=
PresShell
(
)
;
nsFrameList
newColFrames
;
int32_t
startIndex
=
mColFrames
.
Length
(
)
;
int32_t
lastIndex
=
startIndex
+
aNumColsToAdd
-
1
;
for
(
int32_t
childX
=
startIndex
;
childX
<
=
lastIndex
;
childX
+
+
)
{
nsIContent
*
iContent
=
aColGroupFrame
-
>
GetContent
(
)
;
RefPtr
<
ComputedStyle
>
computedStyle
=
shell
-
>
StyleSet
(
)
-
>
ResolveNonInheritingAnonymousBoxStyle
(
nsCSSAnonBoxes
:
:
tableCol
(
)
)
;
NS_ASSERTION
(
iContent
"
null
content
in
CreateAnonymousColFrames
"
)
;
nsIFrame
*
colFrame
=
NS_NewTableColFrame
(
shell
computedStyle
)
;
(
(
nsTableColFrame
*
)
colFrame
)
-
>
SetColType
(
aColType
)
;
colFrame
-
>
Init
(
iContent
aColGroupFrame
nullptr
)
;
newColFrames
.
AppendFrame
(
nullptr
colFrame
)
;
}
nsFrameList
&
cols
=
aColGroupFrame
-
>
GetWritableChildList
(
)
;
nsIFrame
*
oldLastCol
=
cols
.
LastChild
(
)
;
const
nsFrameList
:
:
Slice
&
newCols
=
cols
.
InsertFrames
(
nullptr
oldLastCol
newColFrames
)
;
if
(
aAddToTable
)
{
int32_t
startColIndex
;
if
(
oldLastCol
)
{
startColIndex
=
static_cast
<
nsTableColFrame
*
>
(
oldLastCol
)
-
>
GetColIndex
(
)
+
1
;
}
else
{
startColIndex
=
aColGroupFrame
-
>
GetStartColumnIndex
(
)
;
}
aColGroupFrame
-
>
AddColsToTable
(
startColIndex
true
newCols
)
;
}
}
void
nsTableFrame
:
:
MatchCellMapToColCache
(
nsTableCellMap
*
aCellMap
)
{
int32_t
numColsInMap
=
GetColCount
(
)
;
int32_t
numColsInCache
=
mColFrames
.
Length
(
)
;
int32_t
numColsToAdd
=
numColsInMap
-
numColsInCache
;
if
(
numColsToAdd
>
0
)
{
AppendAnonymousColFrames
(
numColsToAdd
)
;
}
if
(
numColsToAdd
<
0
)
{
int32_t
numColsNotRemoved
=
DestroyAnonymousColFrames
(
-
numColsToAdd
)
;
if
(
numColsNotRemoved
>
0
)
{
aCellMap
-
>
AddColsAtEnd
(
numColsNotRemoved
)
;
}
}
}
void
nsTableFrame
:
:
DidResizeColumns
(
)
{
MOZ_ASSERT
(
!
GetPrevInFlow
(
)
"
should
only
be
called
on
first
-
in
-
flow
"
)
;
if
(
mBits
.
mResizedColumns
)
return
;
for
(
nsTableFrame
*
f
=
this
;
f
;
f
=
static_cast
<
nsTableFrame
*
>
(
f
-
>
GetNextInFlow
(
)
)
)
f
-
>
mBits
.
mResizedColumns
=
true
;
}
void
nsTableFrame
:
:
AppendCell
(
nsTableCellFrame
&
aCellFrame
int32_t
aRowIndex
)
{
nsTableCellMap
*
cellMap
=
GetCellMap
(
)
;
if
(
cellMap
)
{
TableArea
damageArea
(
0
0
0
0
)
;
cellMap
-
>
AppendCell
(
aCellFrame
aRowIndex
true
damageArea
)
;
MatchCellMapToColCache
(
cellMap
)
;
if
(
IsBorderCollapse
(
)
)
{
AddBCDamageArea
(
damageArea
)
;
}
}
}
void
nsTableFrame
:
:
InsertCells
(
nsTArray
<
nsTableCellFrame
*
>
&
aCellFrames
int32_t
aRowIndex
int32_t
aColIndexBefore
)
{
nsTableCellMap
*
cellMap
=
GetCellMap
(
)
;
if
(
cellMap
)
{
TableArea
damageArea
(
0
0
0
0
)
;
cellMap
-
>
InsertCells
(
aCellFrames
aRowIndex
aColIndexBefore
damageArea
)
;
MatchCellMapToColCache
(
cellMap
)
;
if
(
IsBorderCollapse
(
)
)
{
AddBCDamageArea
(
damageArea
)
;
}
}
}
int32_t
nsTableFrame
:
:
DestroyAnonymousColFrames
(
int32_t
aNumFrames
)
{
int32_t
endIndex
=
mColFrames
.
Length
(
)
-
1
;
int32_t
startIndex
=
(
endIndex
-
aNumFrames
)
+
1
;
int32_t
numColsRemoved
=
0
;
for
(
int32_t
colIdx
=
endIndex
;
colIdx
>
=
startIndex
;
colIdx
-
-
)
{
nsTableColFrame
*
colFrame
=
GetColFrame
(
colIdx
)
;
if
(
colFrame
&
&
(
eColAnonymousCell
=
=
colFrame
-
>
GetColType
(
)
)
)
{
nsTableColGroupFrame
*
cgFrame
=
static_cast
<
nsTableColGroupFrame
*
>
(
colFrame
-
>
GetParent
(
)
)
;
cgFrame
-
>
RemoveChild
(
*
colFrame
false
)
;
RemoveCol
(
nullptr
colIdx
true
false
)
;
numColsRemoved
+
+
;
}
else
{
break
;
}
}
return
(
aNumFrames
-
numColsRemoved
)
;
}
void
nsTableFrame
:
:
RemoveCell
(
nsTableCellFrame
*
aCellFrame
int32_t
aRowIndex
)
{
nsTableCellMap
*
cellMap
=
GetCellMap
(
)
;
if
(
cellMap
)
{
TableArea
damageArea
(
0
0
0
0
)
;
cellMap
-
>
RemoveCell
(
aCellFrame
aRowIndex
damageArea
)
;
MatchCellMapToColCache
(
cellMap
)
;
if
(
IsBorderCollapse
(
)
)
{
AddBCDamageArea
(
damageArea
)
;
}
}
}
int32_t
nsTableFrame
:
:
GetStartRowIndex
(
nsTableRowGroupFrame
*
aRowGroupFrame
)
{
RowGroupArray
orderedRowGroups
;
OrderRowGroups
(
orderedRowGroups
)
;
int32_t
rowIndex
=
0
;
for
(
uint32_t
rgIndex
=
0
;
rgIndex
<
orderedRowGroups
.
Length
(
)
;
rgIndex
+
+
)
{
nsTableRowGroupFrame
*
rgFrame
=
orderedRowGroups
[
rgIndex
]
;
if
(
rgFrame
=
=
aRowGroupFrame
)
{
break
;
}
int32_t
numRows
=
rgFrame
-
>
GetRowCount
(
)
;
rowIndex
+
=
numRows
;
}
return
rowIndex
;
}
void
nsTableFrame
:
:
AppendRows
(
nsTableRowGroupFrame
*
aRowGroupFrame
int32_t
aRowIndex
nsTArray
<
nsTableRowFrame
*
>
&
aRowFrames
)
{
nsTableCellMap
*
cellMap
=
GetCellMap
(
)
;
if
(
cellMap
)
{
int32_t
absRowIndex
=
GetStartRowIndex
(
aRowGroupFrame
)
+
aRowIndex
;
InsertRows
(
aRowGroupFrame
aRowFrames
absRowIndex
true
)
;
}
}
int32_t
nsTableFrame
:
:
InsertRows
(
nsTableRowGroupFrame
*
aRowGroupFrame
nsTArray
<
nsTableRowFrame
*
>
&
aRowFrames
int32_t
aRowIndex
bool
aConsiderSpans
)
{
#
ifdef
DEBUG_TABLE_CELLMAP
printf
(
"
=
=
=
insertRowsBefore
firstRow
=
%
d
\
n
"
aRowIndex
)
;
Dump
(
true
false
true
)
;
#
endif
int32_t
numColsToAdd
=
0
;
nsTableCellMap
*
cellMap
=
GetCellMap
(
)
;
if
(
cellMap
)
{
TableArea
damageArea
(
0
0
0
0
)
;
bool
shouldRecalculateIndex
=
!
IsDeletedRowIndexRangesEmpty
(
)
;
if
(
shouldRecalculateIndex
)
{
ResetRowIndices
(
nsFrameList
:
:
Slice
(
mFrames
nullptr
nullptr
)
)
;
}
int32_t
origNumRows
=
cellMap
-
>
GetRowCount
(
)
;
int32_t
numNewRows
=
aRowFrames
.
Length
(
)
;
cellMap
-
>
InsertRows
(
aRowGroupFrame
aRowFrames
aRowIndex
aConsiderSpans
damageArea
)
;
MatchCellMapToColCache
(
cellMap
)
;
if
(
!
shouldRecalculateIndex
)
{
if
(
aRowIndex
<
origNumRows
)
{
AdjustRowIndices
(
aRowIndex
numNewRows
)
;
}
for
(
int32_t
rowB
=
0
;
rowB
<
numNewRows
;
rowB
+
+
)
{
nsTableRowFrame
*
rowFrame
=
aRowFrames
.
ElementAt
(
rowB
)
;
rowFrame
-
>
SetRowIndex
(
aRowIndex
+
rowB
)
;
}
}
if
(
IsBorderCollapse
(
)
)
{
AddBCDamageArea
(
damageArea
)
;
}
}
#
ifdef
DEBUG_TABLE_CELLMAP
printf
(
"
=
=
=
insertRowsAfter
\
n
"
)
;
Dump
(
true
false
true
)
;
#
endif
return
numColsToAdd
;
}
void
nsTableFrame
:
:
AddDeletedRowIndex
(
int32_t
aDeletedRowStoredIndex
)
{
if
(
mDeletedRowIndexRanges
.
empty
(
)
)
{
mDeletedRowIndexRanges
.
insert
(
std
:
:
pair
<
int32_t
int32_t
>
(
aDeletedRowStoredIndex
aDeletedRowStoredIndex
)
)
;
return
;
}
auto
greaterIter
=
mDeletedRowIndexRanges
.
upper_bound
(
aDeletedRowStoredIndex
)
;
auto
smallerIter
=
greaterIter
;
if
(
smallerIter
!
=
mDeletedRowIndexRanges
.
begin
(
)
)
{
smallerIter
-
-
;
}
MOZ_ASSERT
(
smallerIter
=
=
greaterIter
|
|
aDeletedRowStoredIndex
>
smallerIter
-
>
second
"
aDeletedRowIndexRanges
already
contains
aDeletedRowStoredIndex
!
"
"
Trying
to
delete
an
already
deleted
row
?
"
)
;
if
(
smallerIter
-
>
second
=
=
aDeletedRowStoredIndex
-
1
)
{
if
(
greaterIter
!
=
mDeletedRowIndexRanges
.
end
(
)
&
&
greaterIter
-
>
first
=
=
aDeletedRowStoredIndex
+
1
)
{
smallerIter
-
>
second
=
greaterIter
-
>
second
;
mDeletedRowIndexRanges
.
erase
(
greaterIter
)
;
}
else
{
smallerIter
-
>
second
=
aDeletedRowStoredIndex
;
}
}
else
if
(
greaterIter
!
=
mDeletedRowIndexRanges
.
end
(
)
&
&
greaterIter
-
>
first
=
=
aDeletedRowStoredIndex
+
1
)
{
mDeletedRowIndexRanges
.
insert
(
std
:
:
pair
<
int32_t
int32_t
>
(
aDeletedRowStoredIndex
greaterIter
-
>
second
)
)
;
mDeletedRowIndexRanges
.
erase
(
greaterIter
)
;
}
else
{
mDeletedRowIndexRanges
.
insert
(
std
:
:
pair
<
int32_t
int32_t
>
(
aDeletedRowStoredIndex
aDeletedRowStoredIndex
)
)
;
}
}
int32_t
nsTableFrame
:
:
GetAdjustmentForStoredIndex
(
int32_t
aStoredIndex
)
{
if
(
mDeletedRowIndexRanges
.
empty
(
)
)
return
0
;
int32_t
adjustment
=
0
;
auto
endIter
=
mDeletedRowIndexRanges
.
upper_bound
(
aStoredIndex
)
;
for
(
auto
iter
=
mDeletedRowIndexRanges
.
begin
(
)
;
iter
!
=
endIter
;
+
+
iter
)
{
adjustment
+
=
iter
-
>
second
-
iter
-
>
first
+
1
;
}
return
adjustment
;
}
void
nsTableFrame
:
:
RemoveRows
(
nsTableRowFrame
&
aFirstRowFrame
int32_t
aNumRowsToRemove
bool
aConsiderSpans
)
{
#
ifdef
TBD_OPTIMIZATION
bool
stopTelling
=
false
;
for
(
nsIFrame
*
kidFrame
=
aFirstFrame
.
FirstChild
(
)
;
(
kidFrame
&
&
!
stopAsking
)
;
kidFrame
=
kidFrame
-
>
GetNextSibling
(
)
)
{
nsTableCellFrame
*
cellFrame
=
do_QueryFrame
(
kidFrame
)
;
if
(
cellFrame
)
{
stopTelling
=
tableFrame
-
>
CellChangedWidth
(
*
cellFrame
cellFrame
-
>
GetPass1MaxElementWidth
(
)
cellFrame
-
>
GetMaximumWidth
(
)
true
)
;
}
}
#
endif
int32_t
firstRowIndex
=
aFirstRowFrame
.
GetRowIndex
(
)
;
#
ifdef
DEBUG_TABLE_CELLMAP
printf
(
"
=
=
=
removeRowsBefore
firstRow
=
%
d
numRows
=
%
d
\
n
"
firstRowIndex
aNumRowsToRemove
)
;
Dump
(
true
false
true
)
;
#
endif
nsTableCellMap
*
cellMap
=
GetCellMap
(
)
;
if
(
cellMap
)
{
TableArea
damageArea
(
0
0
0
0
)
;
nsTableRowGroupFrame
*
parentFrame
=
aFirstRowFrame
.
GetTableRowGroupFrame
(
)
;
parentFrame
-
>
MarkRowsAsDeleted
(
aFirstRowFrame
aNumRowsToRemove
)
;
cellMap
-
>
RemoveRows
(
firstRowIndex
aNumRowsToRemove
aConsiderSpans
damageArea
)
;
MatchCellMapToColCache
(
cellMap
)
;
if
(
IsBorderCollapse
(
)
)
{
AddBCDamageArea
(
damageArea
)
;
}
}
#
ifdef
DEBUG_TABLE_CELLMAP
printf
(
"
=
=
=
removeRowsAfter
\
n
"
)
;
Dump
(
true
true
true
)
;
#
endif
}
int32_t
nsTableFrame
:
:
CollectRows
(
nsIFrame
*
aFrame
nsTArray
<
nsTableRowFrame
*
>
&
aCollection
)
{
MOZ_ASSERT
(
aFrame
"
null
frame
"
)
;
int32_t
numRows
=
0
;
for
(
nsIFrame
*
childFrame
:
aFrame
-
>
PrincipalChildList
(
)
)
{
aCollection
.
AppendElement
(
static_cast
<
nsTableRowFrame
*
>
(
childFrame
)
)
;
numRows
+
+
;
}
return
numRows
;
}
void
nsTableFrame
:
:
InsertRowGroups
(
const
nsFrameList
:
:
Slice
&
aRowGroups
)
{
#
ifdef
DEBUG_TABLE_CELLMAP
printf
(
"
=
=
=
insertRowGroupsBefore
\
n
"
)
;
Dump
(
true
false
true
)
;
#
endif
nsTableCellMap
*
cellMap
=
GetCellMap
(
)
;
if
(
cellMap
)
{
RowGroupArray
orderedRowGroups
;
OrderRowGroups
(
orderedRowGroups
)
;
AutoTArray
<
nsTableRowFrame
*
8
>
rows
;
uint32_t
rgIndex
;
for
(
rgIndex
=
0
;
rgIndex
<
orderedRowGroups
.
Length
(
)
;
rgIndex
+
+
)
{
for
(
nsFrameList
:
:
Enumerator
rowgroups
(
aRowGroups
)
;
!
rowgroups
.
AtEnd
(
)
;
rowgroups
.
Next
(
)
)
{
if
(
orderedRowGroups
[
rgIndex
]
=
=
rowgroups
.
get
(
)
)
{
nsTableRowGroupFrame
*
priorRG
=
(
0
=
=
rgIndex
)
?
nullptr
:
orderedRowGroups
[
rgIndex
-
1
]
;
cellMap
-
>
InsertGroupCellMap
(
orderedRowGroups
[
rgIndex
]
priorRG
)
;
break
;
}
}
}
cellMap
-
>
Synchronize
(
this
)
;
ResetRowIndices
(
aRowGroups
)
;
for
(
rgIndex
=
0
;
rgIndex
<
orderedRowGroups
.
Length
(
)
;
rgIndex
+
+
)
{
for
(
nsFrameList
:
:
Enumerator
rowgroups
(
aRowGroups
)
;
!
rowgroups
.
AtEnd
(
)
;
rowgroups
.
Next
(
)
)
{
if
(
orderedRowGroups
[
rgIndex
]
=
=
rowgroups
.
get
(
)
)
{
nsTableRowGroupFrame
*
priorRG
=
(
0
=
=
rgIndex
)
?
nullptr
:
orderedRowGroups
[
rgIndex
-
1
]
;
int32_t
numRows
=
CollectRows
(
rowgroups
.
get
(
)
rows
)
;
if
(
numRows
>
0
)
{
int32_t
rowIndex
=
0
;
if
(
priorRG
)
{
int32_t
priorNumRows
=
priorRG
-
>
GetRowCount
(
)
;
rowIndex
=
priorRG
-
>
GetStartRowIndex
(
)
+
priorNumRows
;
}
InsertRows
(
orderedRowGroups
[
rgIndex
]
rows
rowIndex
true
)
;
rows
.
Clear
(
)
;
}
break
;
}
}
}
}
#
ifdef
DEBUG_TABLE_CELLMAP
printf
(
"
=
=
=
insertRowGroupsAfter
\
n
"
)
;
Dump
(
true
true
true
)
;
#
endif
}
const
nsFrameList
&
nsTableFrame
:
:
GetChildList
(
ChildListID
aListID
)
const
{
if
(
aListID
=
=
kColGroupList
)
{
return
mColGroups
;
}
return
nsContainerFrame
:
:
GetChildList
(
aListID
)
;
}
void
nsTableFrame
:
:
GetChildLists
(
nsTArray
<
ChildList
>
*
aLists
)
const
{
nsContainerFrame
:
:
GetChildLists
(
aLists
)
;
mColGroups
.
AppendIfNonempty
(
aLists
kColGroupList
)
;
}
nsRect
nsDisplayTableItem
:
:
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
{
*
aSnap
=
false
;
return
mFrame
-
>
GetVisualOverflowRectRelativeToSelf
(
)
+
ToReferenceFrame
(
)
;
}
void
nsDisplayTableItem
:
:
UpdateForFrameBackground
(
nsIFrame
*
aFrame
)
{
ComputedStyle
*
bgSC
;
if
(
!
nsCSSRendering
:
:
FindBackground
(
aFrame
&
bgSC
)
)
return
;
if
(
!
bgSC
-
>
StyleBackground
(
)
-
>
HasFixedBackground
(
aFrame
)
)
return
;
mPartHasFixedBackground
=
true
;
}
nsDisplayItemGeometry
*
nsDisplayTableItem
:
:
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
{
return
new
nsDisplayTableItemGeometry
(
this
aBuilder
mFrame
-
>
GetOffsetTo
(
mFrame
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
)
)
;
}
void
nsDisplayTableItem
:
:
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
{
auto
geometry
=
static_cast
<
const
nsDisplayTableItemGeometry
*
>
(
aGeometry
)
;
bool
invalidateForAttachmentFixed
=
false
;
if
(
mDrawsBackground
&
&
mPartHasFixedBackground
)
{
nsPoint
frameOffsetToViewport
=
mFrame
-
>
GetOffsetTo
(
mFrame
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
)
;
invalidateForAttachmentFixed
=
frameOffsetToViewport
!
=
geometry
-
>
mFrameOffsetToViewport
;
}
if
(
invalidateForAttachmentFixed
|
|
(
aBuilder
-
>
ShouldSyncDecodeImages
(
)
&
&
geometry
-
>
ShouldInvalidateToSyncDecodeImages
(
)
)
)
{
bool
snap
;
aInvalidRegion
-
>
Or
(
*
aInvalidRegion
GetBounds
(
aBuilder
&
snap
)
)
;
}
nsDisplayItem
:
:
ComputeInvalidationRegion
(
aBuilder
aGeometry
aInvalidRegion
)
;
}
class
nsDisplayTableBorderCollapse
final
:
public
nsDisplayTableItem
{
public
:
nsDisplayTableBorderCollapse
(
nsDisplayListBuilder
*
aBuilder
nsTableFrame
*
aFrame
)
:
nsDisplayTableItem
(
aBuilder
aFrame
)
{
MOZ_COUNT_CTOR
(
nsDisplayTableBorderCollapse
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayTableBorderCollapse
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayTableBorderCollapse
)
;
}
#
endif
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
;
bool
CreateWebRenderCommands
(
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
layers
:
:
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
NS_DISPLAY_DECL_NAME
(
"
TableBorderCollapse
"
TYPE_TABLE_BORDER_COLLAPSE
)
}
;
void
nsDisplayTableBorderCollapse
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
nsPoint
pt
=
ToReferenceFrame
(
)
;
DrawTarget
*
drawTarget
=
aCtx
-
>
GetDrawTarget
(
)
;
gfxPoint
devPixelOffset
=
nsLayoutUtils
:
:
PointToGfxPoint
(
pt
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
AutoRestoreTransform
autoRestoreTransform
(
drawTarget
)
;
drawTarget
-
>
SetTransform
(
drawTarget
-
>
GetTransform
(
)
.
PreTranslate
(
ToPoint
(
devPixelOffset
)
)
)
;
static_cast
<
nsTableFrame
*
>
(
mFrame
)
-
>
PaintBCBorders
(
*
drawTarget
GetPaintRect
(
)
-
pt
)
;
}
bool
nsDisplayTableBorderCollapse
:
:
CreateWebRenderCommands
(
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
static_cast
<
nsTableFrame
*
>
(
mFrame
)
-
>
CreateWebRenderCommandsForBCBorders
(
aBuilder
aSc
GetPaintRect
(
)
ToReferenceFrame
(
)
)
;
return
true
;
}
void
nsTableFrame
:
:
GenericTraversal
(
nsDisplayListBuilder
*
aBuilder
nsFrame
*
aFrame
const
nsDisplayListSet
&
aLists
)
{
for
(
nsIFrame
*
kid
:
aFrame
-
>
GetChildList
(
kColGroupList
)
)
{
aFrame
-
>
BuildDisplayListForChild
(
aBuilder
kid
aLists
)
;
}
for
(
nsIFrame
*
kid
:
aFrame
-
>
PrincipalChildList
(
)
)
{
aFrame
-
>
BuildDisplayListForChild
(
aBuilder
kid
aLists
)
;
}
}
static
void
PaintRowBackground
(
nsTableRowFrame
*
aRow
nsIFrame
*
aFrame
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
const
nsPoint
&
aOffset
=
nsPoint
(
)
)
{
for
(
nsTableCellFrame
*
cell
=
aRow
-
>
GetFirstCell
(
)
;
cell
;
cell
=
cell
-
>
GetNextCell
(
)
)
{
if
(
!
cell
-
>
ShouldPaintBackground
(
aBuilder
)
)
{
continue
;
}
auto
cellRect
=
cell
-
>
GetRectRelativeToSelf
(
)
+
cell
-
>
GetNormalPosition
(
)
+
aOffset
;
if
(
!
aBuilder
-
>
GetDirtyRect
(
)
.
Intersects
(
cellRect
)
)
{
continue
;
}
nsDisplayBackgroundImage
:
:
AppendBackgroundItemsToTop
(
aBuilder
aFrame
cellRect
aLists
.
BorderBackground
(
)
true
nullptr
aFrame
-
>
GetRectRelativeToSelf
(
)
cell
)
;
}
}
static
void
PaintRowGroupBackground
(
nsTableRowGroupFrame
*
aRowGroup
nsIFrame
*
aFrame
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
for
(
nsTableRowFrame
*
row
=
aRowGroup
-
>
GetFirstRow
(
)
;
row
;
row
=
row
-
>
GetNextRow
(
)
)
{
if
(
!
aBuilder
-
>
GetDirtyRect
(
)
.
Intersects
(
nsRect
(
row
-
>
GetNormalPosition
(
)
row
-
>
GetSize
(
)
)
)
)
{
continue
;
}
PaintRowBackground
(
row
aFrame
aBuilder
aLists
row
-
>
GetNormalPosition
(
)
)
;
}
}
static
void
PaintRowGroupBackgroundByColIdx
(
nsTableRowGroupFrame
*
aRowGroup
nsIFrame
*
aFrame
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
const
nsTArray
<
uint32_t
>
&
aColIdx
const
nsPoint
&
aOffset
)
{
MOZ_DIAGNOSTIC_ASSERT
(
!
aColIdx
.
IsEmpty
(
)
"
Must
be
painting
backgrounds
for
something
"
)
;
for
(
nsTableRowFrame
*
row
=
aRowGroup
-
>
GetFirstRow
(
)
;
row
;
row
=
row
-
>
GetNextRow
(
)
)
{
auto
rowPos
=
row
-
>
GetNormalPosition
(
)
+
aOffset
;
if
(
!
aBuilder
-
>
GetDirtyRect
(
)
.
Intersects
(
nsRect
(
rowPos
row
-
>
GetSize
(
)
)
)
)
{
continue
;
}
for
(
nsTableCellFrame
*
cell
=
row
-
>
GetFirstCell
(
)
;
cell
;
cell
=
cell
-
>
GetNextCell
(
)
)
{
uint32_t
curColIdx
=
cell
-
>
ColIndex
(
)
;
if
(
!
aColIdx
.
ContainsSorted
(
curColIdx
)
)
{
if
(
curColIdx
>
aColIdx
.
LastElement
(
)
)
{
break
;
}
continue
;
}
if
(
!
cell
-
>
ShouldPaintBackground
(
aBuilder
)
)
{
continue
;
}
auto
cellPos
=
cell
-
>
GetNormalPosition
(
)
+
rowPos
;
auto
cellRect
=
nsRect
(
cellPos
cell
-
>
GetSize
(
)
)
;
if
(
!
aBuilder
-
>
GetDirtyRect
(
)
.
Intersects
(
cellRect
)
)
{
continue
;
}
nsDisplayBackgroundImage
:
:
AppendBackgroundItemsToTop
(
aBuilder
aFrame
cellRect
aLists
.
BorderBackground
(
)
false
nullptr
aFrame
-
>
GetRectRelativeToSelf
(
)
cell
)
;
}
}
}
static
inline
bool
FrameHasBorder
(
nsIFrame
*
f
)
{
if
(
!
f
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
)
{
return
false
;
}
if
(
f
-
>
StyleBorder
(
)
-
>
HasBorder
(
)
)
{
return
true
;
}
return
false
;
}
void
nsTableFrame
:
:
CalcHasBCBorders
(
)
{
if
(
!
IsBorderCollapse
(
)
)
{
SetHasBCBorders
(
false
)
;
return
;
}
if
(
FrameHasBorder
(
this
)
)
{
SetHasBCBorders
(
true
)
;
return
;
}
for
(
nsIFrame
*
f
:
this
-
>
GetChildList
(
kColGroupList
)
)
{
if
(
FrameHasBorder
(
f
)
)
{
SetHasBCBorders
(
true
)
;
return
;
}
nsTableColGroupFrame
*
colGroup
=
static_cast
<
nsTableColGroupFrame
*
>
(
f
)
;
for
(
nsTableColFrame
*
col
=
colGroup
-
>
GetFirstColumn
(
)
;
col
;
col
=
col
-
>
GetNextCol
(
)
)
{
if
(
FrameHasBorder
(
col
)
)
{
SetHasBCBorders
(
true
)
;
return
;
}
}
}
RowGroupArray
rowGroups
;
OrderRowGroups
(
rowGroups
)
;
for
(
nsTableRowGroupFrame
*
rowGroup
:
rowGroups
)
{
if
(
FrameHasBorder
(
rowGroup
)
)
{
SetHasBCBorders
(
true
)
;
return
;
}
for
(
nsTableRowFrame
*
row
=
rowGroup
-
>
GetFirstRow
(
)
;
row
;
row
=
row
-
>
GetNextRow
(
)
)
{
if
(
FrameHasBorder
(
row
)
)
{
SetHasBCBorders
(
true
)
;
return
;
}
for
(
nsTableCellFrame
*
cell
=
row
-
>
GetFirstCell
(
)
;
cell
;
cell
=
cell
-
>
GetNextCell
(
)
)
{
if
(
FrameHasBorder
(
cell
)
)
{
SetHasBCBorders
(
true
)
;
return
;
}
}
}
}
SetHasBCBorders
(
false
)
;
}
void
nsTableFrame
:
:
DisplayGenericTablePart
(
nsDisplayListBuilder
*
aBuilder
nsFrame
*
aFrame
const
nsDisplayListSet
&
aLists
DisplayGenericTablePartTraversal
aTraversal
)
{
bool
isVisible
=
aFrame
-
>
IsVisibleForPainting
(
)
;
bool
isTable
=
aFrame
-
>
IsTableFrame
(
)
;
if
(
isVisible
|
|
!
isTable
)
{
nsDisplayTableItem
*
currentItem
=
aBuilder
-
>
GetCurrentTableItem
(
)
;
if
(
currentItem
)
{
currentItem
-
>
UpdateForFrameBackground
(
aFrame
)
;
}
}
if
(
isVisible
)
{
if
(
aFrame
-
>
StyleEffects
(
)
-
>
mBoxShadow
)
{
aLists
.
BorderBackground
(
)
-
>
AppendToTop
(
MakeDisplayItem
<
nsDisplayBoxShadowOuter
>
(
aBuilder
aFrame
)
)
;
}
}
if
(
aFrame
-
>
IsTableRowGroupFrame
(
)
)
{
nsTableRowGroupFrame
*
rowGroup
=
static_cast
<
nsTableRowGroupFrame
*
>
(
aFrame
)
;
PaintRowGroupBackground
(
rowGroup
aFrame
aBuilder
aLists
)
;
}
else
if
(
aFrame
-
>
IsTableRowFrame
(
)
)
{
nsTableRowFrame
*
row
=
static_cast
<
nsTableRowFrame
*
>
(
aFrame
)
;
PaintRowBackground
(
row
aFrame
aBuilder
aLists
)
;
}
else
if
(
aFrame
-
>
IsTableColGroupFrame
(
)
)
{
nsTableColGroupFrame
*
colGroup
=
static_cast
<
nsTableColGroupFrame
*
>
(
aFrame
)
;
AutoTArray
<
uint32_t
1
>
colIdx
;
for
(
nsTableColFrame
*
col
=
colGroup
-
>
GetFirstColumn
(
)
;
col
;
col
=
col
-
>
GetNextCol
(
)
)
{
MOZ_ASSERT
(
colIdx
.
IsEmpty
(
)
|
|
static_cast
<
uint32_t
>
(
col
-
>
GetColIndex
(
)
)
>
colIdx
.
LastElement
(
)
)
;
colIdx
.
AppendElement
(
col
-
>
GetColIndex
(
)
)
;
}
if
(
!
colIdx
.
IsEmpty
(
)
)
{
nsTableFrame
*
table
=
colGroup
-
>
GetTableFrame
(
)
;
RowGroupArray
rowGroups
;
table
-
>
OrderRowGroups
(
rowGroups
)
;
for
(
nsTableRowGroupFrame
*
rowGroup
:
rowGroups
)
{
auto
offset
=
rowGroup
-
>
GetNormalPosition
(
)
-
colGroup
-
>
GetNormalPosition
(
)
;
if
(
!
aBuilder
-
>
GetDirtyRect
(
)
.
Intersects
(
nsRect
(
offset
rowGroup
-
>
GetSize
(
)
)
)
)
{
continue
;
}
PaintRowGroupBackgroundByColIdx
(
rowGroup
aFrame
aBuilder
aLists
colIdx
offset
)
;
}
}
}
else
if
(
aFrame
-
>
IsTableColFrame
(
)
)
{
nsTableColFrame
*
col
=
static_cast
<
nsTableColFrame
*
>
(
aFrame
)
;
AutoTArray
<
uint32_t
1
>
colIdx
;
colIdx
.
AppendElement
(
col
-
>
GetColIndex
(
)
)
;
nsTableFrame
*
table
=
col
-
>
GetTableFrame
(
)
;
RowGroupArray
rowGroups
;
table
-
>
OrderRowGroups
(
rowGroups
)
;
for
(
nsTableRowGroupFrame
*
rowGroup
:
rowGroups
)
{
auto
offset
=
rowGroup
-
>
GetNormalPosition
(
)
-
col
-
>
GetNormalPosition
(
)
-
col
-
>
GetTableColGroupFrame
(
)
-
>
GetNormalPosition
(
)
;
if
(
!
aBuilder
-
>
GetDirtyRect
(
)
.
Intersects
(
nsRect
(
offset
rowGroup
-
>
GetSize
(
)
)
)
)
{
continue
;
}
PaintRowGroupBackgroundByColIdx
(
rowGroup
aFrame
aBuilder
aLists
colIdx
offset
)
;
}
}
else
if
(
isVisible
)
{
nsDisplayBackgroundImage
:
:
AppendBackgroundItemsToTop
(
aBuilder
aFrame
aFrame
-
>
GetRectRelativeToSelf
(
)
aLists
.
BorderBackground
(
)
)
;
}
if
(
isVisible
)
{
if
(
aFrame
-
>
StyleEffects
(
)
-
>
mBoxShadow
)
{
aLists
.
BorderBackground
(
)
-
>
AppendToTop
(
MakeDisplayItem
<
nsDisplayBoxShadowInner
>
(
aBuilder
aFrame
)
)
;
}
}
aFrame
-
>
DisplayOutline
(
aBuilder
aLists
)
;
aTraversal
(
aBuilder
aFrame
aLists
)
;
if
(
isVisible
)
{
if
(
isTable
)
{
nsTableFrame
*
table
=
static_cast
<
nsTableFrame
*
>
(
aFrame
)
;
if
(
table
-
>
IsBorderCollapse
(
)
)
{
if
(
table
-
>
HasBCBorders
(
)
)
{
aLists
.
BorderBackground
(
)
-
>
AppendToTop
(
MakeDisplayItem
<
nsDisplayTableBorderCollapse
>
(
aBuilder
table
)
)
;
}
}
else
{
const
nsStyleBorder
*
borderStyle
=
aFrame
-
>
StyleBorder
(
)
;
if
(
borderStyle
-
>
HasBorder
(
)
)
{
aLists
.
BorderBackground
(
)
-
>
AppendToTop
(
MakeDisplayItem
<
nsDisplayBorder
>
(
aBuilder
table
)
)
;
}
}
}
}
}
void
nsTableFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
DO_GLOBAL_REFLOW_COUNT_DSP_COLOR
(
"
nsTableFrame
"
NS_RGB
(
255
128
255
)
)
;
DisplayGenericTablePart
(
aBuilder
this
aLists
)
;
}
nsMargin
nsTableFrame
:
:
GetDeflationForBackground
(
nsPresContext
*
aPresContext
)
const
{
if
(
eCompatibility_NavQuirks
!
=
aPresContext
-
>
CompatibilityMode
(
)
|
|
!
IsBorderCollapse
(
)
)
return
nsMargin
(
0
0
0
0
)
;
WritingMode
wm
=
GetWritingMode
(
)
;
return
GetOuterBCBorder
(
wm
)
.
GetPhysicalMargin
(
wm
)
;
}
nsIFrame
:
:
LogicalSides
nsTableFrame
:
:
GetLogicalSkipSides
(
const
ReflowInput
*
aReflowInput
)
const
{
if
(
MOZ_UNLIKELY
(
StyleBorder
(
)
-
>
mBoxDecorationBreak
=
=
StyleBoxDecorationBreak
:
:
Clone
)
)
{
return
LogicalSides
(
)
;
}
LogicalSides
skip
;
if
(
nullptr
!
=
GetPrevInFlow
(
)
)
{
skip
|
=
eLogicalSideBitsBStart
;
}
if
(
nullptr
!
=
GetNextInFlow
(
)
)
{
skip
|
=
eLogicalSideBitsBEnd
;
}
return
skip
;
}
void
nsTableFrame
:
:
SetColumnDimensions
(
nscoord
aBSize
WritingMode
aWM
const
LogicalMargin
&
aBorderPadding
const
nsSize
&
aContainerSize
)
{
const
nscoord
colBSize
=
aBSize
-
(
aBorderPadding
.
BStartEnd
(
aWM
)
+
GetRowSpacing
(
-
1
)
+
GetRowSpacing
(
GetRowCount
(
)
)
)
;
int32_t
colIdx
=
0
;
LogicalPoint
colGroupOrigin
(
aWM
aBorderPadding
.
IStart
(
aWM
)
+
GetColSpacing
(
-
1
)
aBorderPadding
.
BStart
(
aWM
)
+
GetRowSpacing
(
-
1
)
)
;
nsTableFrame
*
fif
=
static_cast
<
nsTableFrame
*
>
(
FirstInFlow
(
)
)
;
for
(
nsIFrame
*
colGroupFrame
:
mColGroups
)
{
MOZ_ASSERT
(
colGroupFrame
-
>
IsTableColGroupFrame
(
)
)
;
int32_t
groupFirstCol
=
colIdx
;
nscoord
colGroupISize
=
0
;
nscoord
cellSpacingI
=
0
;
const
nsFrameList
&
columnList
=
colGroupFrame
-
>
PrincipalChildList
(
)
;
for
(
nsIFrame
*
colFrame
:
columnList
)
{
if
(
mozilla
:
:
StyleDisplay
:
:
TableColumn
=
=
colFrame
-
>
StyleDisplay
(
)
-
>
mDisplay
)
{
NS_ASSERTION
(
colIdx
<
GetColCount
(
)
"
invalid
number
of
columns
"
)
;
cellSpacingI
=
GetColSpacing
(
colIdx
)
;
colGroupISize
+
=
fif
-
>
GetColumnISizeFromFirstInFlow
(
colIdx
)
+
cellSpacingI
;
+
+
colIdx
;
}
}
if
(
colGroupISize
)
{
colGroupISize
-
=
cellSpacingI
;
}
LogicalRect
colGroupRect
(
aWM
colGroupOrigin
.
I
(
aWM
)
colGroupOrigin
.
B
(
aWM
)
colGroupISize
colBSize
)
;
colGroupFrame
-
>
SetRect
(
aWM
colGroupRect
aContainerSize
)
;
nsSize
colGroupSize
=
colGroupFrame
-
>
GetSize
(
)
;
colIdx
=
groupFirstCol
;
LogicalPoint
colOrigin
(
aWM
)
;
for
(
nsIFrame
*
colFrame
:
columnList
)
{
if
(
mozilla
:
:
StyleDisplay
:
:
TableColumn
=
=
colFrame
-
>
StyleDisplay
(
)
-
>
mDisplay
)
{
nscoord
colISize
=
fif
-
>
GetColumnISizeFromFirstInFlow
(
colIdx
)
;
LogicalRect
colRect
(
aWM
colOrigin
.
I
(
aWM
)
colOrigin
.
B
(
aWM
)
colISize
colBSize
)
;
colFrame
-
>
SetRect
(
aWM
colRect
colGroupSize
)
;
cellSpacingI
=
GetColSpacing
(
colIdx
)
;
colOrigin
.
I
(
aWM
)
+
=
colISize
+
cellSpacingI
;
+
+
colIdx
;
}
}
colGroupOrigin
.
I
(
aWM
)
+
=
colGroupISize
+
cellSpacingI
;
}
}
void
nsTableFrame
:
:
ProcessRowInserted
(
nscoord
aNewBSize
)
{
SetRowInserted
(
false
)
;
nsTableFrame
:
:
RowGroupArray
rowGroups
;
OrderRowGroups
(
rowGroups
)
;
for
(
uint32_t
rgIdx
=
0
;
rgIdx
<
rowGroups
.
Length
(
)
;
rgIdx
+
+
)
{
nsTableRowGroupFrame
*
rgFrame
=
rowGroups
[
rgIdx
]
;
NS_ASSERTION
(
rgFrame
"
Must
have
rgFrame
here
"
)
;
for
(
nsIFrame
*
childFrame
:
rgFrame
-
>
PrincipalChildList
(
)
)
{
nsTableRowFrame
*
rowFrame
=
do_QueryFrame
(
childFrame
)
;
if
(
rowFrame
)
{
if
(
rowFrame
-
>
IsFirstInserted
(
)
)
{
rowFrame
-
>
SetFirstInserted
(
false
)
;
nsIFrame
:
:
InvalidateFrame
(
)
;
SetRowInserted
(
false
)
;
return
;
}
}
}
}
}
void
nsTableFrame
:
:
MarkIntrinsicISizesDirty
(
)
{
nsITableLayoutStrategy
*
tls
=
LayoutStrategy
(
)
;
if
(
MOZ_UNLIKELY
(
!
tls
)
)
{
return
;
}
tls
-
>
MarkIntrinsicISizesDirty
(
)
;
nsContainerFrame
:
:
MarkIntrinsicISizesDirty
(
)
;
}
nscoord
nsTableFrame
:
:
GetMinISize
(
gfxContext
*
aRenderingContext
)
{
if
(
NeedToCalcBCBorders
(
)
)
CalcBCBorders
(
)
;
ReflowColGroups
(
aRenderingContext
)
;
return
LayoutStrategy
(
)
-
>
GetMinISize
(
aRenderingContext
)
;
}
nscoord
nsTableFrame
:
:
GetPrefISize
(
gfxContext
*
aRenderingContext
)
{
if
(
NeedToCalcBCBorders
(
)
)
CalcBCBorders
(
)
;
ReflowColGroups
(
aRenderingContext
)
;
return
LayoutStrategy
(
)
-
>
GetPrefISize
(
aRenderingContext
false
)
;
}
nsIFrame
:
:
IntrinsicISizeOffsetData
nsTableFrame
:
:
IntrinsicISizeOffsets
(
nscoord
aPercentageBasis
)
{
IntrinsicISizeOffsetData
result
=
nsContainerFrame
:
:
IntrinsicISizeOffsets
(
aPercentageBasis
)
;
result
.
hMargin
=
0
;
if
(
IsBorderCollapse
(
)
)
{
result
.
hPadding
=
0
;
WritingMode
wm
=
GetWritingMode
(
)
;
LogicalMargin
outerBC
=
GetIncludedOuterBCBorder
(
wm
)
;
result
.
hBorder
=
outerBC
.
IStartEnd
(
wm
)
;
}
return
result
;
}
LogicalSize
nsTableFrame
:
:
ComputeSize
(
gfxContext
*
aRenderingContext
WritingMode
aWM
const
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
LogicalSize
&
aMargin
const
LogicalSize
&
aBorder
const
LogicalSize
&
aPadding
ComputeSizeFlags
aFlags
)
{
LogicalSize
result
=
nsContainerFrame
:
:
ComputeSize
(
aRenderingContext
aWM
aCBSize
aAvailableISize
aMargin
aBorder
aPadding
aFlags
)
;
if
(
aWM
.
IsVertical
(
)
!
=
GetWritingMode
(
)
.
IsVertical
(
)
)
{
return
result
;
}
AutoMaybeDisableFontInflation
an
(
this
)
;
nscoord
minISize
=
GetMinISize
(
aRenderingContext
)
;
if
(
minISize
>
result
.
ISize
(
aWM
)
)
{
result
.
ISize
(
aWM
)
=
minISize
;
}
return
result
;
}
nscoord
nsTableFrame
:
:
TableShrinkISizeToFit
(
gfxContext
*
aRenderingContext
nscoord
aISizeInCB
)
{
AutoMaybeDisableFontInflation
an
(
this
)
;
nscoord
result
;
nscoord
minISize
=
GetMinISize
(
aRenderingContext
)
;
if
(
minISize
>
aISizeInCB
)
{
result
=
minISize
;
}
else
{
nscoord
prefISize
=
LayoutStrategy
(
)
-
>
GetPrefISize
(
aRenderingContext
true
)
;
if
(
prefISize
>
aISizeInCB
)
{
result
=
aISizeInCB
;
}
else
{
result
=
prefISize
;
}
}
return
result
;
}
LogicalSize
nsTableFrame
:
:
ComputeAutoSize
(
gfxContext
*
aRenderingContext
WritingMode
aWM
const
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
LogicalSize
&
aMargin
const
LogicalSize
&
aBorder
const
LogicalSize
&
aPadding
ComputeSizeFlags
aFlags
)
{
nscoord
cbBased
=
aAvailableISize
-
aMargin
.
ISize
(
aWM
)
-
aBorder
.
ISize
(
aWM
)
-
aPadding
.
ISize
(
aWM
)
;
return
LogicalSize
(
aWM
TableShrinkISizeToFit
(
aRenderingContext
cbBased
)
NS_UNCONSTRAINEDSIZE
)
;
}
bool
nsTableFrame
:
:
AncestorsHaveStyleBSize
(
const
ReflowInput
&
aParentReflowInput
)
{
WritingMode
wm
=
aParentReflowInput
.
GetWritingMode
(
)
;
for
(
const
ReflowInput
*
rs
=
&
aParentReflowInput
;
rs
&
&
rs
-
>
mFrame
;
rs
=
rs
-
>
mParentReflowInput
)
{
LayoutFrameType
frameType
=
rs
-
>
mFrame
-
>
Type
(
)
;
if
(
IsTableCell
(
frameType
)
|
|
(
LayoutFrameType
:
:
TableRow
=
=
frameType
)
|
|
(
LayoutFrameType
:
:
TableRowGroup
=
=
frameType
)
)
{
const
nsStyleCoord
&
bsize
=
rs
-
>
mStylePosition
-
>
BSize
(
wm
)
;
if
(
bsize
.
GetUnit
(
)
!
=
eStyleUnit_Auto
&
&
(
!
bsize
.
IsCalcUnit
(
)
|
|
!
bsize
.
HasPercent
(
)
)
)
{
return
true
;
}
}
else
if
(
LayoutFrameType
:
:
Table
=
=
frameType
)
{
return
rs
-
>
mStylePosition
-
>
BSize
(
wm
)
.
GetUnit
(
)
!
=
eStyleUnit_Auto
;
}
}
return
false
;
}
void
nsTableFrame
:
:
CheckRequestSpecialBSizeReflow
(
const
ReflowInput
&
aReflowInput
)
{
NS_ASSERTION
(
IsTableCell
(
aReflowInput
.
mFrame
-
>
Type
(
)
)
|
|
aReflowInput
.
mFrame
-
>
IsTableRowFrame
(
)
|
|
aReflowInput
.
mFrame
-
>
IsTableRowGroupFrame
(
)
|
|
aReflowInput
.
mFrame
-
>
IsTableFrame
(
)
"
unexpected
frame
type
"
)
;
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
if
(
!
aReflowInput
.
mFrame
-
>
GetPrevInFlow
(
)
&
&
(
NS_UNCONSTRAINEDSIZE
=
=
aReflowInput
.
ComputedBSize
(
)
|
|
0
=
=
aReflowInput
.
ComputedBSize
(
)
)
&
&
eStyleUnit_Percent
=
=
aReflowInput
.
mStylePosition
-
>
BSize
(
wm
)
.
GetUnit
(
)
&
&
nsTableFrame
:
:
AncestorsHaveStyleBSize
(
*
aReflowInput
.
mParentReflowInput
)
)
{
nsTableFrame
:
:
RequestSpecialBSizeReflow
(
aReflowInput
)
;
}
}
void
nsTableFrame
:
:
RequestSpecialBSizeReflow
(
const
ReflowInput
&
aReflowInput
)
{
for
(
const
ReflowInput
*
rs
=
&
aReflowInput
;
rs
&
&
rs
-
>
mFrame
;
rs
=
rs
-
>
mParentReflowInput
)
{
LayoutFrameType
frameType
=
rs
-
>
mFrame
-
>
Type
(
)
;
NS_ASSERTION
(
IsTableCell
(
frameType
)
|
|
LayoutFrameType
:
:
TableRow
=
=
frameType
|
|
LayoutFrameType
:
:
TableRowGroup
=
=
frameType
|
|
LayoutFrameType
:
:
Table
=
=
frameType
"
unexpected
frame
type
"
)
;
rs
-
>
mFrame
-
>
AddStateBits
(
NS_FRAME_CONTAINS_RELATIVE_BSIZE
)
;
if
(
LayoutFrameType
:
:
Table
=
=
frameType
)
{
NS_ASSERTION
(
rs
!
=
&
aReflowInput
"
should
not
request
special
bsize
reflow
for
table
"
)
;
break
;
}
}
}
void
nsTableFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsTableFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aDesiredSize
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
bool
isPaginated
=
aPresContext
-
>
IsPaginated
(
)
;
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
if
(
!
GetPrevInFlow
(
)
&
&
!
mTableLayoutStrategy
)
{
NS_ERROR
(
"
strategy
should
have
been
created
in
Init
"
)
;
return
;
}
if
(
!
GetPrevInFlow
(
)
&
&
IsBorderCollapse
(
)
&
&
NeedToCalcBCBorders
(
)
)
{
CalcBCBorders
(
)
;
}
aDesiredSize
.
ISize
(
wm
)
=
aReflowInput
.
AvailableISize
(
)
;
MoveOverflowToChildList
(
)
;
bool
haveDesiredBSize
=
false
;
SetHaveReflowedColGroups
(
false
)
;
nscoord
tentativeContainerWidth
=
0
;
bool
mayAdjustXForAllChildren
=
false
;
if
(
NS_SUBTREE_DIRTY
(
this
)
|
|
aReflowInput
.
ShouldReflowAllKids
(
)
|
|
IsGeometryDirty
(
)
|
|
isPaginated
|
|
aReflowInput
.
IsBResize
(
)
)
{
if
(
aReflowInput
.
ComputedBSize
(
)
!
=
NS_UNCONSTRAINEDSIZE
|
|
aReflowInput
.
IsBResize
(
)
)
{
SetGeometryDirty
(
)
;
}
bool
needToInitiateSpecialReflow
=
false
;
if
(
isPaginated
)
{
if
(
!
GetPrevInFlow
(
)
&
&
NS_UNCONSTRAINEDSIZE
!
=
aReflowInput
.
AvailableBSize
(
)
)
{
nscoord
tableSpecifiedBSize
=
CalcBorderBoxBSize
(
aReflowInput
)
;
if
(
(
tableSpecifiedBSize
>
0
)
&
&
(
tableSpecifiedBSize
!
=
NS_UNCONSTRAINEDSIZE
)
)
{
needToInitiateSpecialReflow
=
true
;
}
}
}
else
{
needToInitiateSpecialReflow
=
HasAnyStateBits
(
NS_FRAME_CONTAINS_RELATIVE_BSIZE
)
;
}
nsIFrame
*
lastChildReflowed
=
nullptr
;
NS_ASSERTION
(
!
aReflowInput
.
mFlags
.
mSpecialBSizeReflow
"
Shouldn
'
t
be
in
special
bsize
reflow
here
!
"
)
;
nscoord
availBSize
=
needToInitiateSpecialReflow
?
NS_UNCONSTRAINEDSIZE
:
aReflowInput
.
AvailableBSize
(
)
;
ReflowTable
(
aDesiredSize
aReflowInput
availBSize
lastChildReflowed
aStatus
)
;
if
(
wm
.
IsVerticalRL
(
)
)
{
tentativeContainerWidth
=
aReflowInput
.
ComputedSizeAsContainerIfConstrained
(
)
.
width
;
mayAdjustXForAllChildren
=
true
;
}
if
(
HasAnyStateBits
(
NS_FRAME_CONTAINS_RELATIVE_BSIZE
)
)
{
needToInitiateSpecialReflow
=
true
;
}
if
(
needToInitiateSpecialReflow
&
&
aStatus
.
IsComplete
(
)
)
{
ReflowInput
&
mutable_rs
=
const_cast
<
ReflowInput
&
>
(
aReflowInput
)
;
CalcDesiredBSize
(
aReflowInput
aDesiredSize
)
;
mutable_rs
.
mFlags
.
mSpecialBSizeReflow
=
true
;
ReflowTable
(
aDesiredSize
aReflowInput
aReflowInput
.
AvailableBSize
(
)
lastChildReflowed
aStatus
)
;
if
(
lastChildReflowed
&
&
aStatus
.
IsIncomplete
(
)
)
{
LogicalMargin
borderPadding
=
GetChildAreaOffset
(
wm
&
aReflowInput
)
;
aDesiredSize
.
BSize
(
wm
)
=
borderPadding
.
BEnd
(
wm
)
+
GetRowSpacing
(
GetRowCount
(
)
)
+
lastChildReflowed
-
>
GetNormalRect
(
)
.
YMost
(
)
;
}
haveDesiredBSize
=
true
;
mutable_rs
.
mFlags
.
mSpecialBSizeReflow
=
false
;
}
}
aDesiredSize
.
ISize
(
wm
)
=
aReflowInput
.
ComputedISize
(
)
+
aReflowInput
.
ComputedLogicalBorderPadding
(
)
.
IStartEnd
(
wm
)
;
if
(
!
haveDesiredBSize
)
{
CalcDesiredBSize
(
aReflowInput
aDesiredSize
)
;
}
if
(
IsRowInserted
(
)
)
{
ProcessRowInserted
(
aDesiredSize
.
BSize
(
wm
)
)
;
}
if
(
mayAdjustXForAllChildren
)
{
nscoord
xAdjustmentForAllKids
=
aDesiredSize
.
Width
(
)
-
tentativeContainerWidth
;
if
(
0
!
=
xAdjustmentForAllKids
)
{
for
(
nsIFrame
*
kid
:
mFrames
)
{
kid
-
>
MovePositionBy
(
nsPoint
(
xAdjustmentForAllKids
0
)
)
;
RePositionViews
(
kid
)
;
}
}
}
for
(
nsIFrame
*
kid
:
mFrames
)
{
ConsiderChildOverflow
(
aDesiredSize
.
mOverflowAreas
kid
)
;
}
LogicalMargin
borderPadding
=
GetChildAreaOffset
(
wm
&
aReflowInput
)
;
SetColumnDimensions
(
aDesiredSize
.
BSize
(
wm
)
wm
borderPadding
aDesiredSize
.
PhysicalSize
(
)
)
;
if
(
NeedToCollapse
(
)
&
&
(
NS_UNCONSTRAINEDSIZE
!
=
aReflowInput
.
AvailableISize
(
)
)
)
{
AdjustForCollapsingRowsCols
(
aDesiredSize
wm
borderPadding
)
;
}
FixupPositionedTableParts
(
aPresContext
aDesiredSize
aReflowInput
)
;
nsRect
tableRect
(
0
0
aDesiredSize
.
Width
(
)
aDesiredSize
.
Height
(
)
)
;
if
(
!
ShouldApplyOverflowClipping
(
this
aReflowInput
.
mStyleDisplay
)
)
{
LogicalMargin
bcMargin
=
GetExcludedOuterBCBorder
(
wm
)
;
tableRect
.
Inflate
(
bcMargin
.
GetPhysicalMargin
(
wm
)
)
;
}
aDesiredSize
.
mOverflowAreas
.
UnionAllWith
(
tableRect
)
;
FinishAndStoreOverflow
(
&
aDesiredSize
)
;
NS_FRAME_SET_TRUNCATION
(
aStatus
aReflowInput
aDesiredSize
)
;
}
void
nsTableFrame
:
:
FixupPositionedTableParts
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
)
{
FrameTArray
*
positionedParts
=
GetProperty
(
PositionedTablePartArray
(
)
)
;
if
(
!
positionedParts
)
{
return
;
}
OverflowChangedTracker
overflowTracker
;
overflowTracker
.
SetSubtreeRoot
(
this
)
;
for
(
size_t
i
=
0
;
i
<
positionedParts
-
>
Length
(
)
;
+
+
i
)
{
nsIFrame
*
positionedPart
=
positionedParts
-
>
ElementAt
(
i
)
;
nsSize
size
(
positionedPart
-
>
GetSize
(
)
)
;
ReflowOutput
desiredSize
(
aReflowInput
.
GetWritingMode
(
)
)
;
desiredSize
.
Width
(
)
=
size
.
width
;
desiredSize
.
Height
(
)
=
size
.
height
;
desiredSize
.
mOverflowAreas
=
positionedPart
-
>
GetOverflowAreasRelativeToSelf
(
)
;
WritingMode
wm
=
positionedPart
-
>
GetWritingMode
(
)
;
LogicalSize
availSize
(
wm
size
)
;
availSize
.
BSize
(
wm
)
=
NS_UNCONSTRAINEDSIZE
;
ReflowInput
reflowInput
(
aPresContext
positionedPart
aReflowInput
.
mRenderingContext
availSize
ReflowInput
:
:
DUMMY_PARENT_REFLOW_STATE
)
;
nsReflowStatus
reflowStatus
;
nsFrame
*
positionedFrame
=
static_cast
<
nsFrame
*
>
(
positionedPart
)
;
positionedFrame
-
>
FinishReflowWithAbsoluteFrames
(
PresContext
(
)
desiredSize
reflowInput
reflowStatus
true
)
;
nsIFrame
*
positionedFrameParent
=
positionedPart
-
>
GetParent
(
)
;
if
(
positionedFrameParent
!
=
this
)
{
overflowTracker
.
AddFrame
(
positionedFrameParent
OverflowChangedTracker
:
:
CHILDREN_CHANGED
)
;
}
}
overflowTracker
.
Flush
(
)
;
aDesiredSize
.
SetOverflowAreasToDesiredBounds
(
)
;
nsLayoutUtils
:
:
UnionChildOverflow
(
this
aDesiredSize
.
mOverflowAreas
)
;
}
bool
nsTableFrame
:
:
ComputeCustomOverflow
(
nsOverflowAreas
&
aOverflowAreas
)
{
if
(
!
ShouldApplyOverflowClipping
(
this
StyleDisplay
(
)
)
)
{
nsRect
bounds
(
nsPoint
(
0
0
)
GetSize
(
)
)
;
WritingMode
wm
=
GetWritingMode
(
)
;
LogicalMargin
bcMargin
=
GetExcludedOuterBCBorder
(
wm
)
;
bounds
.
Inflate
(
bcMargin
.
GetPhysicalMargin
(
wm
)
)
;
aOverflowAreas
.
UnionAllWith
(
bounds
)
;
}
return
nsContainerFrame
:
:
ComputeCustomOverflow
(
aOverflowAreas
)
;
}
void
nsTableFrame
:
:
ReflowTable
(
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nscoord
aAvailBSize
nsIFrame
*
&
aLastChildReflowed
nsReflowStatus
&
aStatus
)
{
aLastChildReflowed
=
nullptr
;
if
(
!
GetPrevInFlow
(
)
)
{
mTableLayoutStrategy
-
>
ComputeColumnISizes
(
aReflowInput
)
;
}
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
aDesiredSize
.
ISize
(
wm
)
=
aReflowInput
.
ComputedISize
(
)
+
aReflowInput
.
ComputedLogicalBorderPadding
(
)
.
IStartEnd
(
wm
)
;
TableReflowInput
reflowInput
(
aReflowInput
LogicalSize
(
wm
aDesiredSize
.
ISize
(
wm
)
aAvailBSize
)
)
;
ReflowChildren
(
reflowInput
aStatus
aLastChildReflowed
aDesiredSize
.
mOverflowAreas
)
;
ReflowColGroups
(
aReflowInput
.
mRenderingContext
)
;
}
nsIFrame
*
nsTableFrame
:
:
GetFirstBodyRowGroupFrame
(
)
{
nsIFrame
*
headerFrame
=
nullptr
;
nsIFrame
*
footerFrame
=
nullptr
;
for
(
nsIFrame
*
kidFrame
:
mFrames
)
{
const
nsStyleDisplay
*
childDisplay
=
kidFrame
-
>
StyleDisplay
(
)
;
if
(
mozilla
:
:
StyleDisplay
:
:
TableHeaderGroup
=
=
childDisplay
-
>
mDisplay
)
{
if
(
headerFrame
)
{
return
kidFrame
;
}
headerFrame
=
kidFrame
;
}
else
if
(
mozilla
:
:
StyleDisplay
:
:
TableFooterGroup
=
=
childDisplay
-
>
mDisplay
)
{
if
(
footerFrame
)
{
return
kidFrame
;
}
footerFrame
=
kidFrame
;
}
else
if
(
mozilla
:
:
StyleDisplay
:
:
TableRowGroup
=
=
childDisplay
-
>
mDisplay
)
{
return
kidFrame
;
}
}
return
nullptr
;
}
void
nsTableFrame
:
:
PushChildren
(
const
RowGroupArray
&
aRowGroups
int32_t
aPushFrom
)
{
MOZ_ASSERT
(
aPushFrom
>
0
"
pushing
first
child
"
)
;
nsFrameList
frames
;
uint32_t
childX
;
for
(
childX
=
aPushFrom
;
childX
<
aRowGroups
.
Length
(
)
;
+
+
childX
)
{
nsTableRowGroupFrame
*
rgFrame
=
aRowGroups
[
childX
]
;
if
(
!
rgFrame
-
>
IsRepeatable
(
)
)
{
mFrames
.
RemoveFrame
(
rgFrame
)
;
frames
.
AppendFrame
(
nullptr
rgFrame
)
;
}
}
if
(
frames
.
IsEmpty
(
)
)
{
return
;
}
nsTableFrame
*
nextInFlow
=
static_cast
<
nsTableFrame
*
>
(
GetNextInFlow
(
)
)
;
if
(
nextInFlow
)
{
nsIFrame
*
firstBodyFrame
=
nextInFlow
-
>
GetFirstBodyRowGroupFrame
(
)
;
nsIFrame
*
prevSibling
=
nullptr
;
if
(
firstBodyFrame
)
{
prevSibling
=
firstBodyFrame
-
>
GetPrevSibling
(
)
;
}
ReparentFrameViewList
(
frames
this
nextInFlow
)
;
nextInFlow
-
>
mFrames
.
InsertFrames
(
nextInFlow
prevSibling
frames
)
;
}
else
{
SetOverflowFrames
(
frames
)
;
}
}
void
nsTableFrame
:
:
AdjustForCollapsingRowsCols
(
ReflowOutput
&
aDesiredSize
const
WritingMode
aWM
const
LogicalMargin
&
aBorderPadding
)
{
nscoord
bTotalOffset
=
0
;
SetNeedToCollapse
(
false
)
;
RowGroupArray
rowGroups
;
OrderRowGroups
(
rowGroups
)
;
nsTableFrame
*
firstInFlow
=
static_cast
<
nsTableFrame
*
>
(
FirstInFlow
(
)
)
;
nscoord
iSize
=
firstInFlow
-
>
GetCollapsedISize
(
aWM
aBorderPadding
)
;
nscoord
rgISize
=
iSize
-
GetColSpacing
(
-
1
)
-
GetColSpacing
(
GetColCount
(
)
)
;
nsOverflowAreas
overflow
;
for
(
uint32_t
childX
=
0
;
childX
<
rowGroups
.
Length
(
)
;
childX
+
+
)
{
nsTableRowGroupFrame
*
rgFrame
=
rowGroups
[
childX
]
;
NS_ASSERTION
(
rgFrame
"
Must
have
row
group
frame
here
"
)
;
bTotalOffset
+
=
rgFrame
-
>
CollapseRowGroupIfNecessary
(
bTotalOffset
rgISize
aWM
)
;
ConsiderChildOverflow
(
overflow
rgFrame
)
;
}
aDesiredSize
.
BSize
(
aWM
)
-
=
bTotalOffset
;
aDesiredSize
.
ISize
(
aWM
)
=
iSize
;
overflow
.
UnionAllWith
(
nsRect
(
0
0
aDesiredSize
.
Width
(
)
aDesiredSize
.
Height
(
)
)
)
;
FinishAndStoreOverflow
(
overflow
nsSize
(
aDesiredSize
.
Width
(
)
aDesiredSize
.
Height
(
)
)
)
;
}
nscoord
nsTableFrame
:
:
GetCollapsedISize
(
const
WritingMode
aWM
const
LogicalMargin
&
aBorderPadding
)
{
NS_ASSERTION
(
!
GetPrevInFlow
(
)
"
GetCollapsedISize
called
on
next
in
flow
"
)
;
nscoord
iSize
=
GetColSpacing
(
GetColCount
(
)
)
;
iSize
+
=
aBorderPadding
.
IStartEnd
(
aWM
)
;
nsTableFrame
*
fif
=
static_cast
<
nsTableFrame
*
>
(
FirstInFlow
(
)
)
;
for
(
nsIFrame
*
groupFrame
:
mColGroups
)
{
const
nsStyleVisibility
*
groupVis
=
groupFrame
-
>
StyleVisibility
(
)
;
bool
collapseGroup
=
(
NS_STYLE_VISIBILITY_COLLAPSE
=
=
groupVis
-
>
mVisible
)
;
nsTableColGroupFrame
*
cgFrame
=
(
nsTableColGroupFrame
*
)
groupFrame
;
for
(
nsTableColFrame
*
colFrame
=
cgFrame
-
>
GetFirstColumn
(
)
;
colFrame
;
colFrame
=
colFrame
-
>
GetNextCol
(
)
)
{
const
nsStyleDisplay
*
colDisplay
=
colFrame
-
>
StyleDisplay
(
)
;
nscoord
colIdx
=
colFrame
-
>
GetColIndex
(
)
;
if
(
mozilla
:
:
StyleDisplay
:
:
TableColumn
=
=
colDisplay
-
>
mDisplay
)
{
const
nsStyleVisibility
*
colVis
=
colFrame
-
>
StyleVisibility
(
)
;
bool
collapseCol
=
(
NS_STYLE_VISIBILITY_COLLAPSE
=
=
colVis
-
>
mVisible
)
;
nscoord
colISize
=
fif
-
>
GetColumnISizeFromFirstInFlow
(
colIdx
)
;
if
(
!
collapseGroup
&
&
!
collapseCol
)
{
iSize
+
=
colISize
;
if
(
ColumnHasCellSpacingBefore
(
colIdx
)
)
{
iSize
+
=
GetColSpacing
(
colIdx
-
1
)
;
}
}
else
{
SetNeedToCollapse
(
true
)
;
}
}
}
}
return
iSize
;
}
void
nsTableFrame
:
:
DidSetComputedStyle
(
ComputedStyle
*
aOldComputedStyle
)
{
nsContainerFrame
:
:
DidSetComputedStyle
(
aOldComputedStyle
)
;
if
(
!
aOldComputedStyle
)
return
;
if
(
IsBorderCollapse
(
)
&
&
BCRecalcNeeded
(
aOldComputedStyle
Style
(
)
)
)
{
SetFullBCDamageArea
(
)
;
}
if
(
!
mTableLayoutStrategy
|
|
GetPrevInFlow
(
)
)
return
;
bool
isAuto
=
IsAutoLayout
(
)
;
if
(
isAuto
!
=
(
LayoutStrategy
(
)
-
>
GetType
(
)
=
=
nsITableLayoutStrategy
:
:
Auto
)
)
{
nsITableLayoutStrategy
*
temp
;
if
(
isAuto
)
temp
=
new
BasicTableLayoutStrategy
(
this
)
;
else
temp
=
new
FixedTableLayoutStrategy
(
this
)
;
if
(
temp
)
{
delete
mTableLayoutStrategy
;
mTableLayoutStrategy
=
temp
;
}
}
}
void
nsTableFrame
:
:
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
{
NS_ASSERTION
(
aListID
=
=
kPrincipalList
|
|
aListID
=
=
kColGroupList
"
unexpected
child
list
"
)
;
while
(
!
aFrameList
.
IsEmpty
(
)
)
{
nsIFrame
*
f
=
aFrameList
.
FirstChild
(
)
;
aFrameList
.
RemoveFrame
(
f
)
;
const
nsStyleDisplay
*
display
=
f
-
>
StyleDisplay
(
)
;
if
(
mozilla
:
:
StyleDisplay
:
:
TableColumnGroup
=
=
display
-
>
mDisplay
)
{
if
(
MOZ_UNLIKELY
(
GetPrevInFlow
(
)
)
)
{
nsFrameList
colgroupFrame
(
f
f
)
;
auto
firstInFlow
=
static_cast
<
nsTableFrame
*
>
(
FirstInFlow
(
)
)
;
firstInFlow
-
>
AppendFrames
(
aListID
colgroupFrame
)
;
continue
;
}
nsTableColGroupFrame
*
lastColGroup
=
nsTableColGroupFrame
:
:
GetLastRealColGroup
(
this
)
;
int32_t
startColIndex
=
(
lastColGroup
)
?
lastColGroup
-
>
GetStartColumnIndex
(
)
+
lastColGroup
-
>
GetColCount
(
)
:
0
;
mColGroups
.
InsertFrame
(
this
lastColGroup
f
)
;
InsertColGroups
(
startColIndex
nsFrameList
:
:
Slice
(
mColGroups
f
f
-
>
GetNextSibling
(
)
)
)
;
}
else
if
(
IsRowGroup
(
display
-
>
mDisplay
)
)
{
DrainSelfOverflowList
(
)
;
mFrames
.
AppendFrame
(
nullptr
f
)
;
InsertRowGroups
(
nsFrameList
:
:
Slice
(
mFrames
f
nullptr
)
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
How
did
we
get
here
?
Frame
construction
screwed
up
"
)
;
mFrames
.
AppendFrame
(
nullptr
f
)
;
}
}
#
ifdef
DEBUG_TABLE_CELLMAP
printf
(
"
=
=
=
TableFrame
:
:
AppendFrames
\
n
"
)
;
Dump
(
true
true
true
)
;
#
endif
PresShell
(
)
-
>
FrameNeedsReflow
(
this
nsIPresShell
:
:
eTreeChange
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
SetGeometryDirty
(
)
;
}
struct
ChildListInsertions
{
nsIFrame
:
:
ChildListID
mID
;
nsFrameList
mList
;
}
;
void
nsTableFrame
:
:
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
aFrameList
)
{
NS_ASSERTION
(
!
aPrevFrame
|
|
aPrevFrame
-
>
GetParent
(
)
=
=
this
"
inserting
after
sibling
frame
with
different
parent
"
)
;
if
(
(
aPrevFrame
&
&
!
aPrevFrame
-
>
GetNextSibling
(
)
)
|
|
(
!
aPrevFrame
&
&
GetChildList
(
aListID
)
.
IsEmpty
(
)
)
)
{
AppendFrames
(
aListID
aFrameList
)
;
return
;
}
ChildListInsertions
insertions
[
2
]
;
const
nsStyleDisplay
*
display
=
aFrameList
.
FirstChild
(
)
-
>
StyleDisplay
(
)
;
nsFrameList
:
:
FrameLinkEnumerator
e
(
aFrameList
)
;
for
(
;
!
aFrameList
.
IsEmpty
(
)
;
e
.
Next
(
)
)
{
nsIFrame
*
next
=
e
.
NextFrame
(
)
;
if
(
!
next
|
|
next
-
>
StyleDisplay
(
)
-
>
mDisplay
!
=
display
-
>
mDisplay
)
{
nsFrameList
head
=
aFrameList
.
ExtractHead
(
e
)
;
if
(
display
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
TableColumnGroup
)
{
insertions
[
0
]
.
mID
=
kColGroupList
;
insertions
[
0
]
.
mList
.
AppendFrames
(
nullptr
head
)
;
}
else
{
insertions
[
1
]
.
mID
=
kPrincipalList
;
insertions
[
1
]
.
mList
.
AppendFrames
(
nullptr
head
)
;
}
if
(
!
next
)
{
break
;
}
display
=
next
-
>
StyleDisplay
(
)
;
}
}
for
(
uint32_t
i
=
0
;
i
<
ArrayLength
(
insertions
)
;
+
+
i
)
{
if
(
!
insertions
[
i
]
.
mList
.
IsEmpty
(
)
)
{
HomogenousInsertFrames
(
insertions
[
i
]
.
mID
aPrevFrame
insertions
[
i
]
.
mList
)
;
}
}
}
void
nsTableFrame
:
:
HomogenousInsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
aFrameList
)
{
const
nsStyleDisplay
*
display
=
aFrameList
.
FirstChild
(
)
-
>
StyleDisplay
(
)
;
bool
isColGroup
=
mozilla
:
:
StyleDisplay
:
:
TableColumnGroup
=
=
display
-
>
mDisplay
;
#
ifdef
DEBUG
for
(
nsIFrame
*
frame
:
aFrameList
)
{
auto
nextDisplay
=
frame
-
>
StyleDisplay
(
)
-
>
mDisplay
;
MOZ_ASSERT
(
isColGroup
=
=
(
nextDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
TableColumnGroup
)
"
heterogenous
childlist
"
)
;
}
#
endif
if
(
MOZ_UNLIKELY
(
isColGroup
&
&
GetPrevInFlow
(
)
)
)
{
auto
firstInFlow
=
static_cast
<
nsTableFrame
*
>
(
FirstInFlow
(
)
)
;
firstInFlow
-
>
AppendFrames
(
aListID
aFrameList
)
;
return
;
}
if
(
aPrevFrame
)
{
const
nsStyleDisplay
*
prevDisplay
=
aPrevFrame
-
>
StyleDisplay
(
)
;
if
(
(
display
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
TableColumnGroup
)
!
=
(
prevDisplay
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
TableColumnGroup
)
)
{
nsIFrame
*
pseudoFrame
=
aFrameList
.
FirstChild
(
)
;
nsIContent
*
parentContent
=
GetContent
(
)
;
nsIContent
*
content
=
nullptr
;
aPrevFrame
=
nullptr
;
while
(
pseudoFrame
&
&
(
parentContent
=
=
(
content
=
pseudoFrame
-
>
GetContent
(
)
)
)
)
{
pseudoFrame
=
pseudoFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
}
nsCOMPtr
<
nsIContent
>
container
=
content
-
>
GetParent
(
)
;
if
(
MOZ_LIKELY
(
container
)
)
{
int32_t
newIndex
=
container
-
>
ComputeIndexOf
(
content
)
;
nsIFrame
*
kidFrame
;
nsTableColGroupFrame
*
lastColGroup
=
nullptr
;
if
(
isColGroup
)
{
kidFrame
=
mColGroups
.
FirstChild
(
)
;
lastColGroup
=
nsTableColGroupFrame
:
:
GetLastRealColGroup
(
this
)
;
}
else
{
kidFrame
=
mFrames
.
FirstChild
(
)
;
}
int32_t
lastIndex
=
-
1
;
while
(
kidFrame
)
{
if
(
isColGroup
)
{
if
(
kidFrame
=
=
lastColGroup
)
{
aPrevFrame
=
kidFrame
;
break
;
}
}
pseudoFrame
=
kidFrame
;
while
(
pseudoFrame
&
&
(
parentContent
=
=
(
content
=
pseudoFrame
-
>
GetContent
(
)
)
)
)
{
pseudoFrame
=
pseudoFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
}
int32_t
index
=
container
-
>
ComputeIndexOf
(
content
)
;
if
(
index
>
lastIndex
&
&
index
<
newIndex
)
{
lastIndex
=
index
;
aPrevFrame
=
kidFrame
;
}
kidFrame
=
kidFrame
-
>
GetNextSibling
(
)
;
}
}
}
}
if
(
mozilla
:
:
StyleDisplay
:
:
TableColumnGroup
=
=
display
-
>
mDisplay
)
{
NS_ASSERTION
(
aListID
=
=
kColGroupList
"
unexpected
child
list
"
)
;
const
nsFrameList
:
:
Slice
&
newColgroups
=
mColGroups
.
InsertFrames
(
this
aPrevFrame
aFrameList
)
;
int32_t
startColIndex
=
0
;
if
(
aPrevFrame
)
{
nsTableColGroupFrame
*
prevColGroup
=
(
nsTableColGroupFrame
*
)
GetFrameAtOrBefore
(
this
aPrevFrame
LayoutFrameType
:
:
TableColGroup
)
;
if
(
prevColGroup
)
{
startColIndex
=
prevColGroup
-
>
GetStartColumnIndex
(
)
+
prevColGroup
-
>
GetColCount
(
)
;
}
}
InsertColGroups
(
startColIndex
newColgroups
)
;
}
else
if
(
IsRowGroup
(
display
-
>
mDisplay
)
)
{
NS_ASSERTION
(
aListID
=
=
kPrincipalList
"
unexpected
child
list
"
)
;
DrainSelfOverflowList
(
)
;
const
nsFrameList
:
:
Slice
&
newRowGroups
=
mFrames
.
InsertFrames
(
nullptr
aPrevFrame
aFrameList
)
;
InsertRowGroups
(
newRowGroups
)
;
}
else
{
NS_ASSERTION
(
aListID
=
=
kPrincipalList
"
unexpected
child
list
"
)
;
MOZ_ASSERT_UNREACHABLE
(
"
How
did
we
even
get
here
?
"
)
;
mFrames
.
InsertFrames
(
nullptr
aPrevFrame
aFrameList
)
;
return
;
}
PresShell
(
)
-
>
FrameNeedsReflow
(
this
nsIPresShell
:
:
eTreeChange
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
SetGeometryDirty
(
)
;
#
ifdef
DEBUG_TABLE_CELLMAP
printf
(
"
=
=
=
TableFrame
:
:
InsertFrames
\
n
"
)
;
Dump
(
true
true
true
)
;
#
endif
}
void
nsTableFrame
:
:
DoRemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
{
if
(
aListID
=
=
kColGroupList
)
{
nsIFrame
*
nextColGroupFrame
=
aOldFrame
-
>
GetNextSibling
(
)
;
nsTableColGroupFrame
*
colGroup
=
(
nsTableColGroupFrame
*
)
aOldFrame
;
int32_t
firstColIndex
=
colGroup
-
>
GetStartColumnIndex
(
)
;
int32_t
lastColIndex
=
firstColIndex
+
colGroup
-
>
GetColCount
(
)
-
1
;
mColGroups
.
DestroyFrame
(
aOldFrame
)
;
nsTableColGroupFrame
:
:
ResetColIndices
(
nextColGroupFrame
firstColIndex
)
;
int32_t
colIdx
;
for
(
colIdx
=
lastColIndex
;
colIdx
>
=
firstColIndex
;
colIdx
-
-
)
{
nsTableColFrame
*
colFrame
=
mColFrames
.
SafeElementAt
(
colIdx
)
;
if
(
colFrame
)
{
RemoveCol
(
colGroup
colIdx
true
false
)
;
}
}
if
(
!
mColFrames
.
IsEmpty
(
)
&
&
mColFrames
.
LastElement
(
)
&
&
mColFrames
.
LastElement
(
)
-
>
GetColType
(
)
=
=
eColAnonymousCell
)
{
int32_t
numAnonymousColsToAdd
=
GetColCount
(
)
-
mColFrames
.
Length
(
)
;
if
(
numAnonymousColsToAdd
>
0
)
{
AppendAnonymousColFrames
(
numAnonymousColsToAdd
)
;
}
}
else
{
nsTableCellMap
*
cellMap
=
GetCellMap
(
)
;
if
(
cellMap
)
{
cellMap
-
>
RemoveColsAtEnd
(
)
;
MatchCellMapToColCache
(
cellMap
)
;
}
}
}
else
{
NS_ASSERTION
(
aListID
=
=
kPrincipalList
"
unexpected
child
list
"
)
;
nsTableRowGroupFrame
*
rgFrame
=
static_cast
<
nsTableRowGroupFrame
*
>
(
aOldFrame
)
;
nsTableCellMap
*
cellMap
=
GetCellMap
(
)
;
if
(
cellMap
)
{
cellMap
-
>
RemoveGroupCellMap
(
rgFrame
)
;
}
mFrames
.
DestroyFrame
(
aOldFrame
)
;
if
(
cellMap
)
{
cellMap
-
>
Synchronize
(
this
)
;
ResetRowIndices
(
nsFrameList
:
:
Slice
(
mFrames
nullptr
nullptr
)
)
;
TableArea
damageArea
;
cellMap
-
>
RebuildConsideringCells
(
nullptr
nullptr
0
0
false
damageArea
)
;
static_cast
<
nsTableFrame
*
>
(
FirstInFlow
(
)
)
-
>
MatchCellMapToColCache
(
cellMap
)
;
}
}
}
void
nsTableFrame
:
:
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
{
NS_ASSERTION
(
aListID
=
=
kColGroupList
|
|
mozilla
:
:
StyleDisplay
:
:
TableColumnGroup
!
=
aOldFrame
-
>
StyleDisplay
(
)
-
>
mDisplay
"
Wrong
list
name
;
use
kColGroupList
iff
colgroup
"
)
;
nsIPresShell
*
shell
=
PresShell
(
)
;
nsTableFrame
*
lastParent
=
nullptr
;
while
(
aOldFrame
)
{
nsIFrame
*
oldFrameNextContinuation
=
aOldFrame
-
>
GetNextContinuation
(
)
;
nsTableFrame
*
parent
=
static_cast
<
nsTableFrame
*
>
(
aOldFrame
-
>
GetParent
(
)
)
;
if
(
parent
!
=
lastParent
)
{
parent
-
>
DrainSelfOverflowList
(
)
;
}
parent
-
>
DoRemoveFrame
(
aListID
aOldFrame
)
;
aOldFrame
=
oldFrameNextContinuation
;
if
(
parent
!
=
lastParent
)
{
if
(
parent
-
>
IsBorderCollapse
(
)
)
{
parent
-
>
SetFullBCDamageArea
(
)
;
}
parent
-
>
SetGeometryDirty
(
)
;
shell
-
>
FrameNeedsReflow
(
parent
nsIPresShell
:
:
eTreeChange
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
lastParent
=
parent
;
}
}
#
ifdef
DEBUG_TABLE_CELLMAP
printf
(
"
=
=
=
TableFrame
:
:
RemoveFrame
\
n
"
)
;
Dump
(
true
true
true
)
;
#
endif
}
nsMargin
nsTableFrame
:
:
GetUsedBorder
(
)
const
{
if
(
!
IsBorderCollapse
(
)
)
return
nsContainerFrame
:
:
GetUsedBorder
(
)
;
WritingMode
wm
=
GetWritingMode
(
)
;
return
GetIncludedOuterBCBorder
(
wm
)
.
GetPhysicalMargin
(
wm
)
;
}
nsMargin
nsTableFrame
:
:
GetUsedPadding
(
)
const
{
if
(
!
IsBorderCollapse
(
)
)
return
nsContainerFrame
:
:
GetUsedPadding
(
)
;
return
nsMargin
(
0
0
0
0
)
;
}
nsMargin
nsTableFrame
:
:
GetUsedMargin
(
)
const
{
return
nsMargin
(
0
0
0
0
)
;
}
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
TableBCProperty
BCPropertyData
)
BCPropertyData
*
nsTableFrame
:
:
GetBCProperty
(
)
const
{
return
GetProperty
(
TableBCProperty
(
)
)
;
}
BCPropertyData
*
nsTableFrame
:
:
GetOrCreateBCProperty
(
)
{
BCPropertyData
*
value
=
GetProperty
(
TableBCProperty
(
)
)
;
if
(
!
value
)
{
value
=
new
BCPropertyData
(
)
;
SetProperty
(
TableBCProperty
(
)
value
)
;
}
return
value
;
}
static
void
DivideBCBorderSize
(
BCPixelSize
aPixelSize
BCPixelSize
&
aSmallHalf
BCPixelSize
&
aLargeHalf
)
{
aSmallHalf
=
aPixelSize
/
2
;
aLargeHalf
=
aPixelSize
-
aSmallHalf
;
}
LogicalMargin
nsTableFrame
:
:
GetOuterBCBorder
(
const
WritingMode
aWM
)
const
{
if
(
NeedToCalcBCBorders
(
)
)
{
const_cast
<
nsTableFrame
*
>
(
this
)
-
>
CalcBCBorders
(
)
;
}
int32_t
d2a
=
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
BCPropertyData
*
propData
=
GetBCProperty
(
)
;
if
(
propData
)
{
return
LogicalMargin
(
aWM
BC_BORDER_START_HALF_COORD
(
d2a
propData
-
>
mBStartBorderWidth
)
BC_BORDER_END_HALF_COORD
(
d2a
propData
-
>
mIEndBorderWidth
)
BC_BORDER_END_HALF_COORD
(
d2a
propData
-
>
mBEndBorderWidth
)
BC_BORDER_START_HALF_COORD
(
d2a
propData
-
>
mIStartBorderWidth
)
)
;
}
return
LogicalMargin
(
aWM
)
;
}
LogicalMargin
nsTableFrame
:
:
GetIncludedOuterBCBorder
(
const
WritingMode
aWM
)
const
{
if
(
NeedToCalcBCBorders
(
)
)
{
const_cast
<
nsTableFrame
*
>
(
this
)
-
>
CalcBCBorders
(
)
;
}
int32_t
d2a
=
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
BCPropertyData
*
propData
=
GetBCProperty
(
)
;
if
(
propData
)
{
return
LogicalMargin
(
aWM
BC_BORDER_START_HALF_COORD
(
d2a
propData
-
>
mBStartBorderWidth
)
BC_BORDER_END_HALF_COORD
(
d2a
propData
-
>
mIEndCellBorderWidth
)
BC_BORDER_END_HALF_COORD
(
d2a
propData
-
>
mBEndBorderWidth
)
BC_BORDER_START_HALF_COORD
(
d2a
propData
-
>
mIStartCellBorderWidth
)
)
;
}
return
LogicalMargin
(
aWM
)
;
}
LogicalMargin
nsTableFrame
:
:
GetExcludedOuterBCBorder
(
const
WritingMode
aWM
)
const
{
return
GetOuterBCBorder
(
aWM
)
-
GetIncludedOuterBCBorder
(
aWM
)
;
}
static
LogicalMargin
GetSeparateModelBorderPadding
(
const
WritingMode
aWM
const
ReflowInput
*
aReflowInput
ComputedStyle
*
aComputedStyle
)
{
const
nsStyleBorder
*
border
=
aComputedStyle
-
>
StyleBorder
(
)
;
LogicalMargin
borderPadding
(
aWM
border
-
>
GetComputedBorder
(
)
)
;
if
(
aReflowInput
)
{
borderPadding
+
=
aReflowInput
-
>
ComputedLogicalPadding
(
)
;
}
return
borderPadding
;
}
LogicalMargin
nsTableFrame
:
:
GetChildAreaOffset
(
const
WritingMode
aWM
const
ReflowInput
*
aReflowInput
)
const
{
return
IsBorderCollapse
(
)
?
GetIncludedOuterBCBorder
(
aWM
)
:
GetSeparateModelBorderPadding
(
aWM
aReflowInput
mComputedStyle
)
;
}
void
nsTableFrame
:
:
InitChildReflowInput
(
ReflowInput
&
aReflowInput
)
{
nsMargin
collapseBorder
;
nsMargin
padding
(
0
0
0
0
)
;
nsMargin
*
pCollapseBorder
=
nullptr
;
nsPresContext
*
presContext
=
PresContext
(
)
;
if
(
IsBorderCollapse
(
)
)
{
nsTableRowGroupFrame
*
rgFrame
=
static_cast
<
nsTableRowGroupFrame
*
>
(
aReflowInput
.
mFrame
)
;
WritingMode
wm
=
GetWritingMode
(
)
;
LogicalMargin
border
=
rgFrame
-
>
GetBCBorderWidth
(
wm
)
;
collapseBorder
=
border
.
GetPhysicalMargin
(
wm
)
;
pCollapseBorder
=
&
collapseBorder
;
}
aReflowInput
.
Init
(
presContext
nullptr
pCollapseBorder
&
padding
)
;
NS_ASSERTION
(
!
mBits
.
mResizedColumns
|
|
!
aReflowInput
.
mParentReflowInput
-
>
mFlags
.
mSpecialBSizeReflow
"
should
not
resize
columns
on
special
bsize
reflow
"
)
;
if
(
mBits
.
mResizedColumns
)
{
aReflowInput
.
SetIResize
(
true
)
;
}
}
void
nsTableFrame
:
:
PlaceChild
(
TableReflowInput
&
aReflowInput
nsIFrame
*
aKidFrame
nsPoint
aKidPosition
ReflowOutput
&
aKidDesiredSize
const
nsRect
&
aOriginalKidRect
const
nsRect
&
aOriginalKidVisualOverflow
)
{
WritingMode
wm
=
aReflowInput
.
reflowInput
.
GetWritingMode
(
)
;
bool
isFirstReflow
=
aKidFrame
-
>
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
;
FinishReflowChild
(
aKidFrame
PresContext
(
)
aKidDesiredSize
nullptr
aKidPosition
.
x
aKidPosition
.
y
0
)
;
InvalidateTableFrame
(
aKidFrame
aOriginalKidRect
aOriginalKidVisualOverflow
isFirstReflow
)
;
aReflowInput
.
bCoord
+
=
aKidDesiredSize
.
BSize
(
wm
)
;
if
(
NS_UNCONSTRAINEDSIZE
!
=
aReflowInput
.
availSize
.
BSize
(
wm
)
)
{
aReflowInput
.
availSize
.
BSize
(
wm
)
-
=
aKidDesiredSize
.
BSize
(
wm
)
;
}
}
void
nsTableFrame
:
:
OrderRowGroups
(
RowGroupArray
&
aChildren
nsTableRowGroupFrame
*
*
aHead
nsTableRowGroupFrame
*
*
aFoot
)
const
{
aChildren
.
Clear
(
)
;
nsTableRowGroupFrame
*
head
=
nullptr
;
nsTableRowGroupFrame
*
foot
=
nullptr
;
nsIFrame
*
kidFrame
=
mFrames
.
FirstChild
(
)
;
while
(
kidFrame
)
{
const
nsStyleDisplay
*
kidDisplay
=
kidFrame
-
>
StyleDisplay
(
)
;
nsTableRowGroupFrame
*
rowGroup
=
static_cast
<
nsTableRowGroupFrame
*
>
(
kidFrame
)
;
switch
(
kidDisplay
-
>
mDisplay
)
{
case
mozilla
:
:
StyleDisplay
:
:
TableHeaderGroup
:
if
(
head
)
{
aChildren
.
AppendElement
(
rowGroup
)
;
}
else
{
head
=
rowGroup
;
}
break
;
case
mozilla
:
:
StyleDisplay
:
:
TableFooterGroup
:
if
(
foot
)
{
aChildren
.
AppendElement
(
rowGroup
)
;
}
else
{
foot
=
rowGroup
;
}
break
;
case
mozilla
:
:
StyleDisplay
:
:
TableRowGroup
:
aChildren
.
AppendElement
(
rowGroup
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
How
did
this
produce
an
nsTableRowGroupFrame
?
"
)
;
break
;
}
while
(
kidFrame
)
{
nsIFrame
*
nif
=
kidFrame
-
>
GetNextInFlow
(
)
;
kidFrame
=
kidFrame
-
>
GetNextSibling
(
)
;
if
(
kidFrame
!
=
nif
)
break
;
}
}
if
(
head
)
{
aChildren
.
InsertElementAt
(
0
head
)
;
}
if
(
aHead
)
*
aHead
=
head
;
if
(
foot
)
{
aChildren
.
AppendElement
(
foot
)
;
}
if
(
aFoot
)
*
aFoot
=
foot
;
}
nsTableRowGroupFrame
*
nsTableFrame
:
:
GetTHead
(
)
const
{
nsIFrame
*
kidFrame
=
mFrames
.
FirstChild
(
)
;
while
(
kidFrame
)
{
if
(
kidFrame
-
>
StyleDisplay
(
)
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
TableHeaderGroup
)
{
return
static_cast
<
nsTableRowGroupFrame
*
>
(
kidFrame
)
;
}
while
(
kidFrame
)
{
nsIFrame
*
nif
=
kidFrame
-
>
GetNextInFlow
(
)
;
kidFrame
=
kidFrame
-
>
GetNextSibling
(
)
;
if
(
kidFrame
!
=
nif
)
break
;
}
}
return
nullptr
;
}
nsTableRowGroupFrame
*
nsTableFrame
:
:
GetTFoot
(
)
const
{
nsIFrame
*
kidFrame
=
mFrames
.
FirstChild
(
)
;
while
(
kidFrame
)
{
if
(
kidFrame
-
>
StyleDisplay
(
)
-
>
mDisplay
=
=
mozilla
:
:
StyleDisplay
:
:
TableFooterGroup
)
{
return
static_cast
<
nsTableRowGroupFrame
*
>
(
kidFrame
)
;
}
while
(
kidFrame
)
{
nsIFrame
*
nif
=
kidFrame
-
>
GetNextInFlow
(
)
;
kidFrame
=
kidFrame
-
>
GetNextSibling
(
)
;
if
(
kidFrame
!
=
nif
)
break
;
}
}
return
nullptr
;
}
static
bool
IsRepeatable
(
nscoord
aFrameHeight
nscoord
aPageHeight
)
{
return
aFrameHeight
<
(
aPageHeight
/
4
)
;
}
nsresult
nsTableFrame
:
:
SetupHeaderFooterChild
(
const
TableReflowInput
&
aReflowInput
nsTableRowGroupFrame
*
aFrame
nscoord
*
aDesiredHeight
)
{
nsPresContext
*
presContext
=
PresContext
(
)
;
nscoord
pageHeight
=
presContext
-
>
GetPageSize
(
)
.
height
;
WritingMode
wm
=
aFrame
-
>
GetWritingMode
(
)
;
LogicalSize
availSize
=
aReflowInput
.
reflowInput
.
AvailableSize
(
wm
)
;
nsSize
containerSize
=
availSize
.
GetPhysicalSize
(
wm
)
;
availSize
.
BSize
(
wm
)
=
NS_UNCONSTRAINEDSIZE
;
ReflowInput
kidReflowInput
(
presContext
aReflowInput
.
reflowInput
aFrame
availSize
nullptr
ReflowInput
:
:
CALLER_WILL_INIT
)
;
InitChildReflowInput
(
kidReflowInput
)
;
kidReflowInput
.
mFlags
.
mIsTopOfPage
=
true
;
ReflowOutput
desiredSize
(
aReflowInput
.
reflowInput
)
;
desiredSize
.
ClearSize
(
)
;
nsReflowStatus
status
;
ReflowChild
(
aFrame
presContext
desiredSize
kidReflowInput
wm
LogicalPoint
(
wm
aReflowInput
.
iCoord
aReflowInput
.
bCoord
)
containerSize
0
status
)
;
aFrame
-
>
SetRepeatable
(
IsRepeatable
(
desiredSize
.
Height
(
)
pageHeight
)
)
;
*
aDesiredHeight
=
desiredSize
.
Height
(
)
;
return
NS_OK
;
}
void
nsTableFrame
:
:
PlaceRepeatedFooter
(
TableReflowInput
&
aReflowInput
nsTableRowGroupFrame
*
aTfoot
nscoord
aFooterHeight
)
{
nsPresContext
*
presContext
=
PresContext
(
)
;
WritingMode
wm
=
aTfoot
-
>
GetWritingMode
(
)
;
LogicalSize
kidAvailSize
=
aReflowInput
.
availSize
;
nsSize
containerSize
=
kidAvailSize
.
GetPhysicalSize
(
wm
)
;
kidAvailSize
.
BSize
(
wm
)
=
aFooterHeight
;
ReflowInput
footerReflowInput
(
presContext
aReflowInput
.
reflowInput
aTfoot
kidAvailSize
nullptr
ReflowInput
:
:
CALLER_WILL_INIT
)
;
InitChildReflowInput
(
footerReflowInput
)
;
aReflowInput
.
bCoord
+
=
GetRowSpacing
(
GetRowCount
(
)
)
;
nsRect
origTfootRect
=
aTfoot
-
>
GetRect
(
)
;
nsRect
origTfootVisualOverflow
=
aTfoot
-
>
GetVisualOverflowRect
(
)
;
nsReflowStatus
footerStatus
;
ReflowOutput
desiredSize
(
aReflowInput
.
reflowInput
)
;
desiredSize
.
ClearSize
(
)
;
LogicalPoint
kidPosition
(
wm
aReflowInput
.
iCoord
aReflowInput
.
bCoord
)
;
ReflowChild
(
aTfoot
presContext
desiredSize
footerReflowInput
wm
kidPosition
containerSize
0
footerStatus
)
;
footerReflowInput
.
ApplyRelativePositioning
(
&
kidPosition
containerSize
)
;
PlaceChild
(
aReflowInput
aTfoot
kidPosition
.
GetPhysicalPoint
(
wm
containerSize
-
desiredSize
.
PhysicalSize
(
)
)
desiredSize
origTfootRect
origTfootVisualOverflow
)
;
}
void
nsTableFrame
:
:
ReflowChildren
(
TableReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
nsIFrame
*
&
aLastChildReflowed
nsOverflowAreas
&
aOverflowAreas
)
{
aStatus
.
Reset
(
)
;
aLastChildReflowed
=
nullptr
;
nsIFrame
*
prevKidFrame
=
nullptr
;
WritingMode
wm
=
aReflowInput
.
reflowInput
.
GetWritingMode
(
)
;
NS_WARNING_ASSERTION
(
wm
.
IsVertical
(
)
|
|
NS_UNCONSTRAINEDSIZE
!
=
aReflowInput
.
reflowInput
.
ComputedWidth
(
)
"
shouldn
'
t
have
unconstrained
width
in
horizontal
mode
"
)
;
nsSize
containerSize
=
aReflowInput
.
reflowInput
.
ComputedSizeAsContainerIfConstrained
(
)
;
nsPresContext
*
presContext
=
PresContext
(
)
;
bool
isPaginated
=
presContext
-
>
IsPaginated
(
)
&
&
NS_UNCONSTRAINEDSIZE
!
=
aReflowInput
.
availSize
.
BSize
(
wm
)
&
&
aReflowInput
.
reflowInput
.
mFlags
.
mTableIsSplittable
;
if
(
presContext
-
>
IsPaginated
(
)
)
{
SetGeometryDirty
(
)
;
}
aOverflowAreas
.
Clear
(
)
;
bool
reflowAllKids
=
aReflowInput
.
reflowInput
.
ShouldReflowAllKids
(
)
|
|
mBits
.
mResizedColumns
|
|
IsGeometryDirty
(
)
;
RowGroupArray
rowGroups
;
nsTableRowGroupFrame
*
thead
*
tfoot
;
OrderRowGroups
(
rowGroups
&
thead
&
tfoot
)
;
bool
pageBreak
=
false
;
nscoord
footerHeight
=
0
;
if
(
isPaginated
)
{
if
(
thead
&
&
!
GetPrevInFlow
(
)
)
{
nscoord
desiredHeight
;
nsresult
rv
=
SetupHeaderFooterChild
(
aReflowInput
thead
&
desiredHeight
)
;
if
(
NS_FAILED
(
rv
)
)
return
;
}
if
(
tfoot
)
{
nsresult
rv
=
SetupHeaderFooterChild
(
aReflowInput
tfoot
&
footerHeight
)
;
if
(
NS_FAILED
(
rv
)
)
return
;
}
}
bool
allowRepeatedFooter
=
false
;
for
(
size_t
childX
=
0
;
childX
<
rowGroups
.
Length
(
)
;
childX
+
+
)
{
nsIFrame
*
kidFrame
=
rowGroups
[
childX
]
;
nsTableRowGroupFrame
*
rowGroupFrame
=
rowGroups
[
childX
]
;
nscoord
cellSpacingB
=
GetRowSpacing
(
rowGroupFrame
-
>
GetStartRowIndex
(
)
+
rowGroupFrame
-
>
GetRowCount
(
)
)
;
if
(
reflowAllKids
|
|
NS_SUBTREE_DIRTY
(
kidFrame
)
|
|
(
aReflowInput
.
reflowInput
.
mFlags
.
mSpecialBSizeReflow
&
&
(
isPaginated
|
|
kidFrame
-
>
HasAnyStateBits
(
NS_FRAME_CONTAINS_RELATIVE_BSIZE
)
)
)
)
{
if
(
pageBreak
)
{
if
(
allowRepeatedFooter
)
{
PlaceRepeatedFooter
(
aReflowInput
tfoot
footerHeight
)
;
}
else
if
(
tfoot
&
&
tfoot
-
>
IsRepeatable
(
)
)
{
tfoot
-
>
SetRepeatable
(
false
)
;
}
PushChildren
(
rowGroups
childX
)
;
aStatus
.
Reset
(
)
;
aStatus
.
SetIncomplete
(
)
;
break
;
}
LogicalSize
kidAvailSize
(
aReflowInput
.
availSize
)
;
allowRepeatedFooter
=
false
;
if
(
isPaginated
&
&
(
NS_UNCONSTRAINEDSIZE
!
=
kidAvailSize
.
BSize
(
wm
)
)
)
{
nsTableRowGroupFrame
*
kidRG
=
static_cast
<
nsTableRowGroupFrame
*
>
(
kidFrame
)
;
if
(
kidRG
!
=
thead
&
&
kidRG
!
=
tfoot
&
&
tfoot
&
&
tfoot
-
>
IsRepeatable
(
)
)
{
NS_ASSERTION
(
tfoot
=
=
rowGroups
[
rowGroups
.
Length
(
)
-
1
]
"
Missing
footer
!
"
)
;
if
(
footerHeight
+
cellSpacingB
<
kidAvailSize
.
BSize
(
wm
)
)
{
allowRepeatedFooter
=
true
;
kidAvailSize
.
BSize
(
wm
)
-
=
footerHeight
+
cellSpacingB
;
}
}
}
nsRect
oldKidRect
=
kidFrame
-
>
GetRect
(
)
;
nsRect
oldKidVisualOverflow
=
kidFrame
-
>
GetVisualOverflowRect
(
)
;
ReflowOutput
desiredSize
(
aReflowInput
.
reflowInput
)
;
desiredSize
.
ClearSize
(
)
;
ReflowInput
kidReflowInput
(
presContext
aReflowInput
.
reflowInput
kidFrame
kidAvailSize
nullptr
ReflowInput
:
:
CALLER_WILL_INIT
)
;
InitChildReflowInput
(
kidReflowInput
)
;
if
(
childX
>
(
(
thead
&
&
IsRepeatedFrame
(
thead
)
)
?
1u
:
0u
)
&
&
(
rowGroups
[
childX
-
1
]
-
>
GetNormalRect
(
)
.
YMost
(
)
>
0
)
)
{
kidReflowInput
.
mFlags
.
mIsTopOfPage
=
false
;
}
aReflowInput
.
bCoord
+
=
cellSpacingB
;
if
(
NS_UNCONSTRAINEDSIZE
!
=
aReflowInput
.
availSize
.
BSize
(
wm
)
)
{
aReflowInput
.
availSize
.
BSize
(
wm
)
-
=
cellSpacingB
;
}
bool
reorder
=
false
;
if
(
kidFrame
-
>
GetNextInFlow
(
)
)
reorder
=
true
;
LogicalPoint
kidPosition
(
wm
aReflowInput
.
iCoord
aReflowInput
.
bCoord
)
;
aStatus
.
Reset
(
)
;
ReflowChild
(
kidFrame
presContext
desiredSize
kidReflowInput
wm
kidPosition
containerSize
0
aStatus
)
;
kidReflowInput
.
ApplyRelativePositioning
(
&
kidPosition
containerSize
)
;
if
(
reorder
)
{
OrderRowGroups
(
rowGroups
&
thead
&
tfoot
)
;
childX
=
rowGroups
.
IndexOf
(
kidFrame
)
;
if
(
childX
=
=
RowGroupArray
:
:
NoIndex
)
{
childX
=
rowGroups
.
Length
(
)
;
}
}
if
(
isPaginated
&
&
!
aStatus
.
IsFullyComplete
(
)
&
&
ShouldAvoidBreakInside
(
aReflowInput
.
reflowInput
)
)
{
aStatus
.
SetInlineLineBreakBeforeAndReset
(
)
;
break
;
}
if
(
isPaginated
&
&
(
aStatus
.
IsInlineBreakBefore
(
)
|
|
(
aStatus
.
IsComplete
(
)
&
&
(
NS_UNCONSTRAINEDSIZE
!
=
kidReflowInput
.
AvailableHeight
(
)
)
&
&
kidReflowInput
.
AvailableHeight
(
)
<
desiredSize
.
Height
(
)
)
)
)
{
if
(
ShouldAvoidBreakInside
(
aReflowInput
.
reflowInput
)
)
{
aStatus
.
SetInlineLineBreakBeforeAndReset
(
)
;
break
;
}
if
(
kidReflowInput
.
mFlags
.
mIsTopOfPage
)
{
if
(
childX
+
1
<
rowGroups
.
Length
(
)
)
{
nsIFrame
*
nextRowGroupFrame
=
rowGroups
[
childX
+
1
]
;
if
(
nextRowGroupFrame
)
{
PlaceChild
(
aReflowInput
kidFrame
kidPosition
.
GetPhysicalPoint
(
wm
containerSize
-
desiredSize
.
PhysicalSize
(
)
)
desiredSize
oldKidRect
oldKidVisualOverflow
)
;
if
(
allowRepeatedFooter
)
{
PlaceRepeatedFooter
(
aReflowInput
tfoot
footerHeight
)
;
}
else
if
(
tfoot
&
&
tfoot
-
>
IsRepeatable
(
)
)
{
tfoot
-
>
SetRepeatable
(
false
)
;
}
aStatus
.
Reset
(
)
;
aStatus
.
SetIncomplete
(
)
;
PushChildren
(
rowGroups
childX
+
1
)
;
aLastChildReflowed
=
kidFrame
;
break
;
}
}
}
else
{
if
(
prevKidFrame
)
{
if
(
allowRepeatedFooter
)
{
PlaceRepeatedFooter
(
aReflowInput
tfoot
footerHeight
)
;
}
else
if
(
tfoot
&
&
tfoot
-
>
IsRepeatable
(
)
)
{
tfoot
-
>
SetRepeatable
(
false
)
;
}
aStatus
.
Reset
(
)
;
aStatus
.
SetIncomplete
(
)
;
PushChildren
(
rowGroups
childX
)
;
aLastChildReflowed
=
prevKidFrame
;
break
;
}
else
{
PlaceChild
(
aReflowInput
kidFrame
kidPosition
.
GetPhysicalPoint
(
wm
containerSize
-
desiredSize
.
PhysicalSize
(
)
)
desiredSize
oldKidRect
oldKidVisualOverflow
)
;
aLastChildReflowed
=
kidFrame
;
if
(
allowRepeatedFooter
)
{
PlaceRepeatedFooter
(
aReflowInput
tfoot
footerHeight
)
;
aLastChildReflowed
=
tfoot
;
}
break
;
}
}
}
aLastChildReflowed
=
kidFrame
;
pageBreak
=
false
;
if
(
aStatus
.
IsComplete
(
)
&
&
isPaginated
&
&
(
NS_UNCONSTRAINEDSIZE
!
=
kidReflowInput
.
AvailableHeight
(
)
)
)
{
nsIFrame
*
nextKid
=
(
childX
+
1
<
rowGroups
.
Length
(
)
)
?
rowGroups
[
childX
+
1
]
:
nullptr
;
pageBreak
=
PageBreakAfter
(
kidFrame
nextKid
)
;
}
PlaceChild
(
aReflowInput
kidFrame
kidPosition
.
GetPhysicalPoint
(
wm
containerSize
-
desiredSize
.
PhysicalSize
(
)
)
desiredSize
oldKidRect
oldKidVisualOverflow
)
;
prevKidFrame
=
kidFrame
;
MOZ_ASSERT
(
!
aStatus
.
IsIncomplete
(
)
|
|
isPaginated
"
Table
contents
should
only
fragment
in
paginated
contexts
"
)
;
if
(
isPaginated
&
&
aStatus
.
IsIncomplete
(
)
)
{
nsIFrame
*
kidNextInFlow
=
kidFrame
-
>
GetNextInFlow
(
)
;
if
(
!
kidNextInFlow
)
{
kidNextInFlow
=
presContext
-
>
PresShell
(
)
-
>
FrameConstructor
(
)
-
>
CreateContinuingFrame
(
presContext
kidFrame
this
)
;
mFrames
.
InsertFrame
(
nullptr
kidFrame
kidNextInFlow
)
;
rowGroups
.
InsertElementAt
(
childX
+
1
static_cast
<
nsTableRowGroupFrame
*
>
(
kidNextInFlow
)
)
;
}
else
if
(
kidNextInFlow
=
=
kidFrame
-
>
GetNextSibling
(
)
)
{
MOZ_ASSERT
(
!
rowGroups
.
Contains
(
kidNextInFlow
)
"
OrderRowGroups
must
not
put
our
NIF
in
'
rowGroups
'
"
)
;
rowGroups
.
InsertElementAt
(
childX
+
1
static_cast
<
nsTableRowGroupFrame
*
>
(
kidNextInFlow
)
)
;
}
if
(
allowRepeatedFooter
)
{
PlaceRepeatedFooter
(
aReflowInput
tfoot
footerHeight
)
;
}
else
if
(
tfoot
&
&
tfoot
-
>
IsRepeatable
(
)
)
{
tfoot
-
>
SetRepeatable
(
false
)
;
}
nsIFrame
*
nextSibling
=
kidFrame
-
>
GetNextSibling
(
)
;
if
(
nextSibling
)
{
PushChildren
(
rowGroups
childX
+
1
)
;
}
break
;
}
}
else
{
aReflowInput
.
bCoord
+
=
cellSpacingB
;
LogicalRect
kidRect
(
wm
kidFrame
-
>
GetNormalRect
(
)
containerSize
)
;
if
(
kidRect
.
BStart
(
wm
)
!
=
aReflowInput
.
bCoord
)
{
kidFrame
-
>
InvalidateFrameSubtree
(
)
;
kidFrame
-
>
MovePositionBy
(
wm
LogicalPoint
(
wm
0
aReflowInput
.
bCoord
-
kidRect
.
BStart
(
wm
)
)
)
;
RePositionViews
(
kidFrame
)
;
kidFrame
-
>
InvalidateFrameSubtree
(
)
;
}
aReflowInput
.
bCoord
+
=
kidRect
.
BSize
(
wm
)
;
if
(
NS_UNCONSTRAINEDSIZE
!
=
aReflowInput
.
availSize
.
BSize
(
wm
)
)
{
aReflowInput
.
availSize
.
BSize
(
wm
)
-
=
cellSpacingB
+
kidRect
.
BSize
(
wm
)
;
}
}
}
mBits
.
mResizedColumns
=
false
;
ClearGeometryDirty
(
)
;
}
void
nsTableFrame
:
:
ReflowColGroups
(
gfxContext
*
aRenderingContext
)
{
if
(
!
GetPrevInFlow
(
)
&
&
!
HaveReflowedColGroups
(
)
)
{
ReflowOutput
kidMet
(
GetWritingMode
(
)
)
;
nsPresContext
*
presContext
=
PresContext
(
)
;
for
(
nsIFrame
*
kidFrame
:
mColGroups
)
{
if
(
NS_SUBTREE_DIRTY
(
kidFrame
)
)
{
ReflowInput
kidReflowInput
(
presContext
kidFrame
aRenderingContext
LogicalSize
(
kidFrame
-
>
GetWritingMode
(
)
)
)
;
nsReflowStatus
cgStatus
;
ReflowChild
(
kidFrame
presContext
kidMet
kidReflowInput
0
0
0
cgStatus
)
;
FinishReflowChild
(
kidFrame
presContext
kidMet
nullptr
0
0
0
)
;
}
}
SetHaveReflowedColGroups
(
true
)
;
}
}
void
nsTableFrame
:
:
CalcDesiredBSize
(
const
ReflowInput
&
aReflowInput
ReflowOutput
&
aDesiredSize
)
{
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
nsTableCellMap
*
cellMap
=
GetCellMap
(
)
;
if
(
!
cellMap
)
{
NS_ERROR
(
"
never
ever
call
me
until
the
cell
map
is
built
!
"
)
;
aDesiredSize
.
BSize
(
wm
)
=
0
;
return
;
}
LogicalMargin
borderPadding
=
GetChildAreaOffset
(
wm
&
aReflowInput
)
;
RowGroupArray
rowGroups
;
OrderRowGroups
(
rowGroups
)
;
if
(
rowGroups
.
IsEmpty
(
)
)
{
nscoord
tableSpecifiedBSize
=
CalcBorderBoxBSize
(
aReflowInput
)
;
if
(
(
NS_UNCONSTRAINEDSIZE
!
=
tableSpecifiedBSize
)
&
&
(
tableSpecifiedBSize
>
0
)
&
&
eCompatibility_NavQuirks
!
=
PresContext
(
)
-
>
CompatibilityMode
(
)
)
{
aDesiredSize
.
BSize
(
wm
)
=
tableSpecifiedBSize
;
}
else
{
aDesiredSize
.
BSize
(
wm
)
=
0
;
}
return
;
}
int32_t
rowCount
=
cellMap
-
>
GetRowCount
(
)
;
int32_t
colCount
=
cellMap
-
>
GetColCount
(
)
;
nscoord
desiredBSize
=
borderPadding
.
BStartEnd
(
wm
)
;
if
(
rowCount
>
0
&
&
colCount
>
0
)
{
desiredBSize
+
=
GetRowSpacing
(
-
1
)
;
for
(
uint32_t
rgIdx
=
0
;
rgIdx
<
rowGroups
.
Length
(
)
;
rgIdx
+
+
)
{
desiredBSize
+
=
rowGroups
[
rgIdx
]
-
>
BSize
(
wm
)
+
GetRowSpacing
(
rowGroups
[
rgIdx
]
-
>
GetRowCount
(
)
+
rowGroups
[
rgIdx
]
-
>
GetStartRowIndex
(
)
)
;
}
}
if
(
!
GetPrevInFlow
(
)
)
{
nscoord
tableSpecifiedBSize
=
CalcBorderBoxBSize
(
aReflowInput
)
;
if
(
(
tableSpecifiedBSize
>
0
)
&
&
(
tableSpecifiedBSize
!
=
NS_UNCONSTRAINEDSIZE
)
&
&
(
tableSpecifiedBSize
>
desiredBSize
)
)
{
DistributeBSizeToRows
(
aReflowInput
tableSpecifiedBSize
-
desiredBSize
)
;
for
(
nsIFrame
*
kidFrame
:
mFrames
)
{
ConsiderChildOverflow
(
aDesiredSize
.
mOverflowAreas
kidFrame
)
;
}
desiredBSize
=
tableSpecifiedBSize
;
}
}
aDesiredSize
.
BSize
(
wm
)
=
desiredBSize
;
}
static
void
ResizeCells
(
nsTableFrame
&
aTableFrame
)
{
nsTableFrame
:
:
RowGroupArray
rowGroups
;
aTableFrame
.
OrderRowGroups
(
rowGroups
)
;
WritingMode
wm
=
aTableFrame
.
GetWritingMode
(
)
;
ReflowOutput
tableDesiredSize
(
wm
)
;
tableDesiredSize
.
SetSize
(
wm
aTableFrame
.
GetLogicalSize
(
wm
)
)
;
tableDesiredSize
.
SetOverflowAreasToDesiredBounds
(
)
;
for
(
uint32_t
rgIdx
=
0
;
rgIdx
<
rowGroups
.
Length
(
)
;
rgIdx
+
+
)
{
nsTableRowGroupFrame
*
rgFrame
=
rowGroups
[
rgIdx
]
;
ReflowOutput
groupDesiredSize
(
wm
)
;
groupDesiredSize
.
SetSize
(
wm
rgFrame
-
>
GetLogicalSize
(
wm
)
)
;
groupDesiredSize
.
SetOverflowAreasToDesiredBounds
(
)
;
nsTableRowFrame
*
rowFrame
=
rgFrame
-
>
GetFirstRow
(
)
;
while
(
rowFrame
)
{
rowFrame
-
>
DidResize
(
)
;
rgFrame
-
>
ConsiderChildOverflow
(
groupDesiredSize
.
mOverflowAreas
rowFrame
)
;
rowFrame
=
rowFrame
-
>
GetNextRow
(
)
;
}
rgFrame
-
>
FinishAndStoreOverflow
(
&
groupDesiredSize
)
;
tableDesiredSize
.
mOverflowAreas
.
UnionWith
(
groupDesiredSize
.
mOverflowAreas
+
rgFrame
-
>
GetPosition
(
)
)
;
}
aTableFrame
.
FinishAndStoreOverflow
(
&
tableDesiredSize
)
;
}
void
nsTableFrame
:
:
DistributeBSizeToRows
(
const
ReflowInput
&
aReflowInput
nscoord
aAmount
)
{
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
LogicalMargin
borderPadding
=
GetChildAreaOffset
(
wm
&
aReflowInput
)
;
nsSize
containerSize
=
aReflowInput
.
ComputedSizeAsContainerIfConstrained
(
)
;
RowGroupArray
rowGroups
;
OrderRowGroups
(
rowGroups
)
;
nscoord
amountUsed
=
0
;
nscoord
pctBasis
=
aReflowInput
.
ComputedBSize
(
)
-
GetRowSpacing
(
-
1
GetRowCount
(
)
)
;
nscoord
bOriginRG
=
borderPadding
.
BStart
(
wm
)
+
GetRowSpacing
(
0
)
;
nscoord
bEndRG
=
bOriginRG
;
uint32_t
rgIdx
;
for
(
rgIdx
=
0
;
rgIdx
<
rowGroups
.
Length
(
)
;
rgIdx
+
+
)
{
nsTableRowGroupFrame
*
rgFrame
=
rowGroups
[
rgIdx
]
;
nscoord
amountUsedByRG
=
0
;
nscoord
bOriginRow
=
0
;
LogicalRect
rgNormalRect
(
wm
rgFrame
-
>
GetNormalRect
(
)
containerSize
)
;
if
(
!
rgFrame
-
>
HasStyleBSize
(
)
)
{
nsTableRowFrame
*
rowFrame
=
rgFrame
-
>
GetFirstRow
(
)
;
while
(
rowFrame
)
{
const
nsSize
dummyContainerSize
;
LogicalRect
rowNormalRect
(
wm
rowFrame
-
>
GetNormalRect
(
)
dummyContainerSize
)
;
nscoord
cellSpacingB
=
GetRowSpacing
(
rowFrame
-
>
GetRowIndex
(
)
)
;
if
(
(
amountUsed
<
aAmount
)
&
&
rowFrame
-
>
HasPctBSize
(
)
)
{
nscoord
pctBSize
=
rowFrame
-
>
GetInitialBSize
(
pctBasis
)
;
nscoord
amountForRow
=
std
:
:
min
(
aAmount
-
amountUsed
pctBSize
-
rowNormalRect
.
BSize
(
wm
)
)
;
if
(
amountForRow
>
0
)
{
nsRect
origRowRect
=
rowFrame
-
>
GetRect
(
)
;
nscoord
newRowBSize
=
rowNormalRect
.
BSize
(
wm
)
+
amountForRow
;
rowFrame
-
>
SetSize
(
wm
LogicalSize
(
wm
rowNormalRect
.
ISize
(
wm
)
newRowBSize
)
)
;
bOriginRow
+
=
newRowBSize
+
cellSpacingB
;
bEndRG
+
=
newRowBSize
+
cellSpacingB
;
amountUsed
+
=
amountForRow
;
amountUsedByRG
+
=
amountForRow
;
nsTableFrame
:
:
RePositionViews
(
rowFrame
)
;
rgFrame
-
>
InvalidateFrameWithRect
(
origRowRect
)
;
rgFrame
-
>
InvalidateFrame
(
)
;
}
}
else
{
if
(
amountUsed
>
0
&
&
bOriginRow
!
=
rowNormalRect
.
BStart
(
wm
)
&
&
!
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
)
{
rowFrame
-
>
InvalidateFrameSubtree
(
)
;
rowFrame
-
>
MovePositionBy
(
wm
LogicalPoint
(
wm
0
bOriginRow
-
rowNormalRect
.
BStart
(
wm
)
)
)
;
nsTableFrame
:
:
RePositionViews
(
rowFrame
)
;
rowFrame
-
>
InvalidateFrameSubtree
(
)
;
}
bOriginRow
+
=
rowNormalRect
.
BSize
(
wm
)
+
cellSpacingB
;
bEndRG
+
=
rowNormalRect
.
BSize
(
wm
)
+
cellSpacingB
;
}
rowFrame
=
rowFrame
-
>
GetNextRow
(
)
;
}
if
(
amountUsed
>
0
)
{
if
(
rgNormalRect
.
BStart
(
wm
)
!
=
bOriginRG
)
{
rgFrame
-
>
InvalidateFrameSubtree
(
)
;
}
nsRect
origRgNormalRect
=
rgFrame
-
>
GetRect
(
)
;
nsRect
origRgVisualOverflow
=
rgFrame
-
>
GetVisualOverflowRect
(
)
;
rgFrame
-
>
MovePositionBy
(
wm
LogicalPoint
(
wm
0
bOriginRG
-
rgNormalRect
.
BStart
(
wm
)
)
)
;
rgFrame
-
>
SetSize
(
wm
LogicalSize
(
wm
rgNormalRect
.
ISize
(
wm
)
rgNormalRect
.
BSize
(
wm
)
+
amountUsedByRG
)
)
;
nsTableFrame
:
:
InvalidateTableFrame
(
rgFrame
origRgNormalRect
origRgVisualOverflow
false
)
;
}
}
else
if
(
amountUsed
>
0
&
&
bOriginRG
!
=
rgNormalRect
.
BStart
(
wm
)
)
{
rgFrame
-
>
InvalidateFrameSubtree
(
)
;
rgFrame
-
>
MovePositionBy
(
wm
LogicalPoint
(
wm
0
bOriginRG
-
rgNormalRect
.
BStart
(
wm
)
)
)
;
nsTableFrame
:
:
RePositionViews
(
rgFrame
)
;
rgFrame
-
>
InvalidateFrameSubtree
(
)
;
}
bOriginRG
=
bEndRG
;
}
if
(
amountUsed
>
=
aAmount
)
{
ResizeCells
(
*
this
)
;
return
;
}
nsTableRowGroupFrame
*
firstUnStyledRG
=
nullptr
;
nsTableRowFrame
*
firstUnStyledRow
=
nullptr
;
for
(
rgIdx
=
0
;
rgIdx
<
rowGroups
.
Length
(
)
&
&
!
firstUnStyledRG
;
rgIdx
+
+
)
{
nsTableRowGroupFrame
*
rgFrame
=
rowGroups
[
rgIdx
]
;
if
(
!
rgFrame
-
>
HasStyleBSize
(
)
)
{
nsTableRowFrame
*
rowFrame
=
rgFrame
-
>
GetFirstRow
(
)
;
while
(
rowFrame
)
{
if
(
!
rowFrame
-
>
HasStyleBSize
(
)
)
{
firstUnStyledRG
=
rgFrame
;
firstUnStyledRow
=
rowFrame
;
break
;
}
rowFrame
=
rowFrame
-
>
GetNextRow
(
)
;
}
}
}
nsTableRowFrame
*
lastEligibleRow
=
nullptr
;
nscoord
divisor
=
0
;
int32_t
eligibleRows
=
0
;
bool
expandEmptyRows
=
false
;
if
(
!
firstUnStyledRow
)
{
divisor
=
GetRowCount
(
)
;
}
else
{
for
(
rgIdx
=
0
;
rgIdx
<
rowGroups
.
Length
(
)
;
rgIdx
+
+
)
{
nsTableRowGroupFrame
*
rgFrame
=
rowGroups
[
rgIdx
]
;
if
(
!
firstUnStyledRG
|
|
!
rgFrame
-
>
HasStyleBSize
(
)
)
{
nsTableRowFrame
*
rowFrame
=
rgFrame
-
>
GetFirstRow
(
)
;
while
(
rowFrame
)
{
if
(
!
firstUnStyledRG
|
|
!
rowFrame
-
>
HasStyleBSize
(
)
)
{
NS_ASSERTION
(
rowFrame
-
>
BSize
(
wm
)
>
=
0
"
negative
row
frame
block
-
size
"
)
;
divisor
+
=
rowFrame
-
>
BSize
(
wm
)
;
eligibleRows
+
+
;
lastEligibleRow
=
rowFrame
;
}
rowFrame
=
rowFrame
-
>
GetNextRow
(
)
;
}
}
}
if
(
divisor
<
=
0
)
{
if
(
eligibleRows
>
0
)
{
expandEmptyRows
=
true
;
}
else
{
NS_ERROR
(
"
invalid
divisor
"
)
;
return
;
}
}
}
nscoord
bSizeToDistribute
=
aAmount
-
amountUsed
;
bOriginRG
=
borderPadding
.
BStart
(
wm
)
+
GetRowSpacing
(
-
1
)
;
bEndRG
=
bOriginRG
;
for
(
rgIdx
=
0
;
rgIdx
<
rowGroups
.
Length
(
)
;
rgIdx
+
+
)
{
nsTableRowGroupFrame
*
rgFrame
=
rowGroups
[
rgIdx
]
;
nscoord
amountUsedByRG
=
0
;
nscoord
bOriginRow
=
0
;
LogicalRect
rgNormalRect
(
wm
rgFrame
-
>
GetNormalRect
(
)
containerSize
)
;
nsRect
rgVisualOverflow
=
rgFrame
-
>
GetVisualOverflowRect
(
)
;
if
(
!
firstUnStyledRG
|
|
!
rgFrame
-
>
HasStyleBSize
(
)
|
|
!
eligibleRows
)
{
for
(
nsTableRowFrame
*
rowFrame
=
rgFrame
-
>
GetFirstRow
(
)
;
rowFrame
;
rowFrame
=
rowFrame
-
>
GetNextRow
(
)
)
{
nscoord
cellSpacingB
=
GetRowSpacing
(
rowFrame
-
>
GetRowIndex
(
)
)
;
const
nsSize
dummyContainerSize
;
LogicalRect
rowNormalRect
(
wm
rowFrame
-
>
GetNormalRect
(
)
dummyContainerSize
)
;
nsRect
rowVisualOverflow
=
rowFrame
-
>
GetVisualOverflowRect
(
)
;
if
(
!
firstUnStyledRow
|
|
!
rowFrame
-
>
HasStyleBSize
(
)
|
|
!
eligibleRows
)
{
float
ratio
;
if
(
eligibleRows
)
{
if
(
!
expandEmptyRows
)
{
ratio
=
float
(
rowNormalRect
.
BSize
(
wm
)
)
/
float
(
divisor
)
;
}
else
{
ratio
=
1
.
0f
/
float
(
eligibleRows
)
;
}
}
else
{
ratio
=
1
.
0f
/
float
(
divisor
)
;
}
nscoord
amountForRow
=
(
rowFrame
=
=
lastEligibleRow
)
?
aAmount
-
amountUsed
:
NSToCoordRound
(
(
(
float
)
(
bSizeToDistribute
)
)
*
ratio
)
;
amountForRow
=
std
:
:
min
(
amountForRow
aAmount
-
amountUsed
)
;
if
(
bOriginRow
!
=
rowNormalRect
.
BStart
(
wm
)
)
{
rowFrame
-
>
InvalidateFrameSubtree
(
)
;
}
nsRect
origRowRect
=
rowFrame
-
>
GetRect
(
)
;
nscoord
newRowBSize
=
rowNormalRect
.
BSize
(
wm
)
+
amountForRow
;
rowFrame
-
>
MovePositionBy
(
wm
LogicalPoint
(
wm
0
bOriginRow
-
rowNormalRect
.
BStart
(
wm
)
)
)
;
rowFrame
-
>
SetSize
(
wm
LogicalSize
(
wm
rowNormalRect
.
ISize
(
wm
)
newRowBSize
)
)
;
bOriginRow
+
=
newRowBSize
+
cellSpacingB
;
bEndRG
+
=
newRowBSize
+
cellSpacingB
;
amountUsed
+
=
amountForRow
;
amountUsedByRG
+
=
amountForRow
;
NS_ASSERTION
(
(
amountUsed
<
=
aAmount
)
"
invalid
row
allocation
"
)
;
nsTableFrame
:
:
RePositionViews
(
rowFrame
)
;
nsTableFrame
:
:
InvalidateTableFrame
(
rowFrame
origRowRect
rowVisualOverflow
false
)
;
}
else
{
if
(
amountUsed
>
0
&
&
bOriginRow
!
=
rowNormalRect
.
BStart
(
wm
)
)
{
rowFrame
-
>
InvalidateFrameSubtree
(
)
;
rowFrame
-
>
MovePositionBy
(
wm
LogicalPoint
(
wm
0
bOriginRow
-
rowNormalRect
.
BStart
(
wm
)
)
)
;
nsTableFrame
:
:
RePositionViews
(
rowFrame
)
;
rowFrame
-
>
InvalidateFrameSubtree
(
)
;
}
bOriginRow
+
=
rowNormalRect
.
BSize
(
wm
)
+
cellSpacingB
;
bEndRG
+
=
rowNormalRect
.
BSize
(
wm
)
+
cellSpacingB
;
}
}
if
(
amountUsed
>
0
)
{
if
(
rgNormalRect
.
BStart
(
wm
)
!
=
bOriginRG
)
{
rgFrame
-
>
InvalidateFrameSubtree
(
)
;
}
nsRect
origRgNormalRect
=
rgFrame
-
>
GetRect
(
)
;
rgFrame
-
>
MovePositionBy
(
wm
LogicalPoint
(
wm
0
bOriginRG
-
rgNormalRect
.
BStart
(
wm
)
)
)
;
rgFrame
-
>
SetSize
(
wm
LogicalSize
(
wm
rgNormalRect
.
ISize
(
wm
)
rgNormalRect
.
BSize
(
wm
)
+
amountUsedByRG
)
)
;
nsTableFrame
:
:
InvalidateTableFrame
(
rgFrame
origRgNormalRect
rgVisualOverflow
false
)
;
}
if
(
wm
.
IsVerticalRL
(
)
)
{
nscoord
rgWidth
=
rgFrame
-
>
GetSize
(
)
.
width
;
for
(
nsTableRowFrame
*
rowFrame
=
rgFrame
-
>
GetFirstRow
(
)
;
rowFrame
;
rowFrame
=
rowFrame
-
>
GetNextRow
(
)
)
{
rowFrame
-
>
InvalidateFrameSubtree
(
)
;
rowFrame
-
>
MovePositionBy
(
nsPoint
(
rgWidth
0
)
)
;
nsTableFrame
:
:
RePositionViews
(
rowFrame
)
;
rowFrame
-
>
InvalidateFrameSubtree
(
)
;
}
}
}
else
if
(
amountUsed
>
0
&
&
bOriginRG
!
=
rgNormalRect
.
BStart
(
wm
)
)
{
rgFrame
-
>
InvalidateFrameSubtree
(
)
;
rgFrame
-
>
MovePositionBy
(
wm
LogicalPoint
(
wm
0
bOriginRG
-
rgNormalRect
.
BStart
(
wm
)
)
)
;
nsTableFrame
:
:
RePositionViews
(
rgFrame
)
;
rgFrame
-
>
InvalidateFrameSubtree
(
)
;
}
bOriginRG
=
bEndRG
;
}
ResizeCells
(
*
this
)
;
}
nscoord
nsTableFrame
:
:
GetColumnISizeFromFirstInFlow
(
int32_t
aColIndex
)
{
MOZ_ASSERT
(
this
=
=
FirstInFlow
(
)
)
;
nsTableColFrame
*
colFrame
=
GetColFrame
(
aColIndex
)
;
return
colFrame
?
colFrame
-
>
GetFinalISize
(
)
:
0
;
}
nscoord
nsTableFrame
:
:
GetColSpacing
(
)
{
if
(
IsBorderCollapse
(
)
)
return
0
;
return
StyleTableBorder
(
)
-
>
mBorderSpacingCol
;
}
nscoord
nsTableFrame
:
:
GetColSpacing
(
int32_t
aColIndex
)
{
NS_ASSERTION
(
aColIndex
>
=
-
1
&
&
aColIndex
<
=
GetColCount
(
)
"
Column
index
exceeds
the
bounds
of
the
table
"
)
;
return
GetColSpacing
(
)
;
}
nscoord
nsTableFrame
:
:
GetColSpacing
(
int32_t
aStartColIndex
int32_t
aEndColIndex
)
{
NS_ASSERTION
(
aStartColIndex
>
=
-
1
&
&
aStartColIndex
<
=
GetColCount
(
)
"
Start
column
index
exceeds
the
bounds
of
the
table
"
)
;
NS_ASSERTION
(
aEndColIndex
>
=
-
1
&
&
aEndColIndex
<
=
GetColCount
(
)
"
End
column
index
exceeds
the
bounds
of
the
table
"
)
;
NS_ASSERTION
(
aStartColIndex
<
=
aEndColIndex
"
End
index
must
not
be
less
than
start
index
"
)
;
return
GetColSpacing
(
)
*
(
aEndColIndex
-
aStartColIndex
)
;
}
nscoord
nsTableFrame
:
:
GetRowSpacing
(
)
{
if
(
IsBorderCollapse
(
)
)
return
0
;
return
StyleTableBorder
(
)
-
>
mBorderSpacingRow
;
}
nscoord
nsTableFrame
:
:
GetRowSpacing
(
int32_t
aRowIndex
)
{
NS_ASSERTION
(
aRowIndex
>
=
-
1
&
&
aRowIndex
<
=
GetRowCount
(
)
"
Row
index
exceeds
the
bounds
of
the
table
"
)
;
return
GetRowSpacing
(
)
;
}
nscoord
nsTableFrame
:
:
GetRowSpacing
(
int32_t
aStartRowIndex
int32_t
aEndRowIndex
)
{
NS_ASSERTION
(
aStartRowIndex
>
=
-
1
&
&
aStartRowIndex
<
=
GetRowCount
(
)
"
Start
row
index
exceeds
the
bounds
of
the
table
"
)
;
NS_ASSERTION
(
aEndRowIndex
>
=
-
1
&
&
aEndRowIndex
<
=
GetRowCount
(
)
"
End
row
index
exceeds
the
bounds
of
the
table
"
)
;
NS_ASSERTION
(
aStartRowIndex
<
=
aEndRowIndex
"
End
index
must
not
be
less
than
start
index
"
)
;
return
GetRowSpacing
(
)
*
(
aEndRowIndex
-
aStartRowIndex
)
;
}
nscoord
nsTableFrame
:
:
GetLogicalBaseline
(
WritingMode
aWM
)
const
{
nscoord
baseline
;
if
(
!
GetNaturalBaselineBOffset
(
aWM
BaselineSharingGroup
:
:
eFirst
&
baseline
)
)
{
baseline
=
BSize
(
aWM
)
;
}
return
baseline
;
}
bool
nsTableFrame
:
:
GetNaturalBaselineBOffset
(
WritingMode
aWM
BaselineSharingGroup
aBaselineGroup
nscoord
*
aBaseline
)
const
{
RowGroupArray
orderedRowGroups
;
OrderRowGroups
(
orderedRowGroups
)
;
nsSize
containerSize
=
mRect
.
Size
(
)
;
auto
TableBaseline
=
[
aWM
containerSize
]
(
nsTableRowGroupFrame
*
aRowGroup
nsTableRowFrame
*
aRow
)
{
nscoord
rgBStart
=
LogicalRect
(
aWM
aRowGroup
-
>
GetNormalRect
(
)
containerSize
)
.
BStart
(
aWM
)
;
nscoord
rowBStart
=
LogicalRect
(
aWM
aRow
-
>
GetNormalRect
(
)
containerSize
)
.
BStart
(
aWM
)
;
return
rgBStart
+
rowBStart
+
aRow
-
>
GetRowBaseline
(
aWM
)
;
}
;
if
(
aBaselineGroup
=
=
BaselineSharingGroup
:
:
eFirst
)
{
for
(
uint32_t
rgIndex
=
0
;
rgIndex
<
orderedRowGroups
.
Length
(
)
;
rgIndex
+
+
)
{
nsTableRowGroupFrame
*
rgFrame
=
orderedRowGroups
[
rgIndex
]
;
nsTableRowFrame
*
row
=
rgFrame
-
>
GetFirstRow
(
)
;
if
(
row
)
{
*
aBaseline
=
TableBaseline
(
rgFrame
row
)
;
return
true
;
}
}
}
else
{
for
(
uint32_t
rgIndex
=
orderedRowGroups
.
Length
(
)
;
rgIndex
-
-
>
0
;
)
{
nsTableRowGroupFrame
*
rgFrame
=
orderedRowGroups
[
rgIndex
]
;
nsTableRowFrame
*
row
=
rgFrame
-
>
GetLastRow
(
)
;
if
(
row
)
{
*
aBaseline
=
BSize
(
aWM
)
-
TableBaseline
(
rgFrame
row
)
;
return
true
;
}
}
}
return
false
;
}
nsTableFrame
*
NS_NewTableFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsTableFrame
(
aStyle
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsTableFrame
)
nsTableFrame
*
nsTableFrame
:
:
GetTableFrame
(
nsIFrame
*
aFrame
)
{
for
(
nsIFrame
*
ancestor
=
aFrame
-
>
GetParent
(
)
;
ancestor
;
ancestor
=
ancestor
-
>
GetParent
(
)
)
{
if
(
ancestor
-
>
IsTableFrame
(
)
)
{
return
static_cast
<
nsTableFrame
*
>
(
ancestor
)
;
}
}
MOZ_CRASH
(
"
unable
to
find
table
parent
"
)
;
return
nullptr
;
}
nsTableFrame
*
nsTableFrame
:
:
GetTableFramePassingThrough
(
nsIFrame
*
aMustPassThrough
nsIFrame
*
aFrame
bool
*
aDidPassThrough
)
{
MOZ_ASSERT
(
aMustPassThrough
=
=
aFrame
|
|
nsLayoutUtils
:
:
IsProperAncestorFrame
(
aMustPassThrough
aFrame
)
"
aMustPassThrough
should
be
an
ancestor
"
)
;
*
aDidPassThrough
=
false
;
nsTableFrame
*
tableFrame
=
nullptr
;
for
(
nsIFrame
*
ancestor
=
aFrame
;
ancestor
;
ancestor
=
ancestor
-
>
GetParent
(
)
)
{
if
(
ancestor
=
=
aMustPassThrough
)
{
*
aDidPassThrough
=
true
;
}
if
(
ancestor
-
>
IsTableFrame
(
)
)
{
tableFrame
=
static_cast
<
nsTableFrame
*
>
(
ancestor
)
;
break
;
}
}
MOZ_ASSERT
(
tableFrame
"
Should
have
a
table
frame
here
"
)
;
return
tableFrame
;
}
bool
nsTableFrame
:
:
IsAutoBSize
(
WritingMode
aWM
)
{
const
nsStyleCoord
&
bsize
=
StylePosition
(
)
-
>
BSize
(
aWM
)
;
return
bsize
.
GetUnit
(
)
=
=
eStyleUnit_Auto
|
|
(
bsize
.
GetUnit
(
)
=
=
eStyleUnit_Percent
&
&
bsize
.
GetPercentValue
(
)
<
=
0
.
0f
)
;
}
nscoord
nsTableFrame
:
:
CalcBorderBoxBSize
(
const
ReflowInput
&
aReflowInput
)
{
nscoord
bSize
=
aReflowInput
.
ComputedBSize
(
)
;
if
(
NS_AUTOHEIGHT
!
=
bSize
)
{
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
LogicalMargin
borderPadding
=
GetChildAreaOffset
(
wm
&
aReflowInput
)
;
bSize
+
=
borderPadding
.
BStartEnd
(
wm
)
;
}
bSize
=
std
:
:
max
(
0
bSize
)
;
return
bSize
;
}
bool
nsTableFrame
:
:
IsAutoLayout
(
)
{
if
(
StyleTable
(
)
-
>
mLayoutStrategy
=
=
NS_STYLE_TABLE_LAYOUT_AUTO
)
return
true
;
const
nsStyleCoord
&
iSize
=
StylePosition
(
)
-
>
ISize
(
GetWritingMode
(
)
)
;
return
(
iSize
.
GetUnit
(
)
=
=
eStyleUnit_Auto
)
|
|
(
iSize
.
GetUnit
(
)
=
=
eStyleUnit_Enumerated
&
&
iSize
.
GetIntValue
(
)
=
=
NS_STYLE_WIDTH_MAX_CONTENT
)
;
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
nsTableFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
NS_LITERAL_STRING
(
"
Table
"
)
aResult
)
;
}
#
endif
nsIFrame
*
nsTableFrame
:
:
GetFrameAtOrBefore
(
nsIFrame
*
aParentFrame
nsIFrame
*
aPriorChildFrame
LayoutFrameType
aChildType
)
{
nsIFrame
*
result
=
nullptr
;
if
(
!
aPriorChildFrame
)
{
return
result
;
}
if
(
aChildType
=
=
aPriorChildFrame
-
>
Type
(
)
)
{
return
aPriorChildFrame
;
}
nsIFrame
*
lastMatchingFrame
=
nullptr
;
nsIFrame
*
childFrame
=
aParentFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
while
(
childFrame
&
&
(
childFrame
!
=
aPriorChildFrame
)
)
{
if
(
aChildType
=
=
childFrame
-
>
Type
(
)
)
{
lastMatchingFrame
=
childFrame
;
}
childFrame
=
childFrame
-
>
GetNextSibling
(
)
;
}
return
lastMatchingFrame
;
}
#
ifdef
DEBUG
void
nsTableFrame
:
:
DumpRowGroup
(
nsIFrame
*
aKidFrame
)
{
if
(
!
aKidFrame
)
return
;
for
(
nsIFrame
*
cFrame
:
aKidFrame
-
>
PrincipalChildList
(
)
)
{
nsTableRowFrame
*
rowFrame
=
do_QueryFrame
(
cFrame
)
;
if
(
rowFrame
)
{
printf
(
"
row
(
%
d
)
=
%
p
"
rowFrame
-
>
GetRowIndex
(
)
static_cast
<
void
*
>
(
rowFrame
)
)
;
for
(
nsIFrame
*
childFrame
:
cFrame
-
>
PrincipalChildList
(
)
)
{
nsTableCellFrame
*
cellFrame
=
do_QueryFrame
(
childFrame
)
;
if
(
cellFrame
)
{
uint32_t
colIndex
=
cellFrame
-
>
ColIndex
(
)
;
printf
(
"
cell
(
%
u
)
=
%
p
"
colIndex
static_cast
<
void
*
>
(
childFrame
)
)
;
}
}
printf
(
"
\
n
"
)
;
}
else
{
DumpRowGroup
(
rowFrame
)
;
}
}
}
void
nsTableFrame
:
:
Dump
(
bool
aDumpRows
bool
aDumpCols
bool
aDumpCellMap
)
{
printf
(
"
*
*
*
START
TABLE
DUMP
*
*
*
\
n
"
)
;
printf
(
"
mColWidths
=
"
)
;
int32_t
numCols
=
GetColCount
(
)
;
int32_t
colIdx
;
nsTableFrame
*
fif
=
static_cast
<
nsTableFrame
*
>
(
FirstInFlow
(
)
)
;
for
(
colIdx
=
0
;
colIdx
<
numCols
;
colIdx
+
+
)
{
printf
(
"
%
d
"
fif
-
>
GetColumnISizeFromFirstInFlow
(
colIdx
)
)
;
}
printf
(
"
\
n
"
)
;
if
(
aDumpRows
)
{
nsIFrame
*
kidFrame
=
mFrames
.
FirstChild
(
)
;
while
(
kidFrame
)
{
DumpRowGroup
(
kidFrame
)
;
kidFrame
=
kidFrame
-
>
GetNextSibling
(
)
;
}
}
if
(
aDumpCols
)
{
printf
(
"
\
n
col
frame
cache
-
>
"
)
;
for
(
colIdx
=
0
;
colIdx
<
numCols
;
colIdx
+
+
)
{
nsTableColFrame
*
colFrame
=
mColFrames
.
ElementAt
(
colIdx
)
;
if
(
0
=
=
(
colIdx
%
8
)
)
{
printf
(
"
\
n
"
)
;
}
printf
(
"
%
d
=
%
p
"
colIdx
static_cast
<
void
*
>
(
colFrame
)
)
;
nsTableColType
colType
=
colFrame
-
>
GetColType
(
)
;
switch
(
colType
)
{
case
eColContent
:
printf
(
"
content
"
)
;
break
;
case
eColAnonymousCol
:
printf
(
"
anonymous
-
column
"
)
;
break
;
case
eColAnonymousColGroup
:
printf
(
"
anonymous
-
colgroup
"
)
;
break
;
case
eColAnonymousCell
:
printf
(
"
anonymous
-
cell
"
)
;
break
;
}
}
printf
(
"
\
n
colgroups
-
>
"
)
;
for
(
nsIFrame
*
childFrame
:
mColGroups
)
{
if
(
LayoutFrameType
:
:
TableColGroup
=
=
childFrame
-
>
Type
(
)
)
{
nsTableColGroupFrame
*
colGroupFrame
=
(
nsTableColGroupFrame
*
)
childFrame
;
colGroupFrame
-
>
Dump
(
1
)
;
}
}
for
(
colIdx
=
0
;
colIdx
<
numCols
;
colIdx
+
+
)
{
printf
(
"
\
n
"
)
;
nsTableColFrame
*
colFrame
=
GetColFrame
(
colIdx
)
;
colFrame
-
>
Dump
(
1
)
;
}
}
if
(
aDumpCellMap
)
{
nsTableCellMap
*
cellMap
=
GetCellMap
(
)
;
cellMap
-
>
Dump
(
)
;
}
printf
(
"
*
*
*
END
TABLE
DUMP
*
*
*
\
n
"
)
;
}
#
endif
bool
nsTableFrame
:
:
ColumnHasCellSpacingBefore
(
int32_t
aColIndex
)
const
{
if
(
LayoutStrategy
(
)
-
>
GetType
(
)
=
=
nsITableLayoutStrategy
:
:
Fixed
)
return
true
;
if
(
aColIndex
=
=
0
)
return
true
;
nsTableCellMap
*
cellMap
=
GetCellMap
(
)
;
if
(
!
cellMap
)
return
false
;
return
cellMap
-
>
GetNumCellsOriginatingInCol
(
aColIndex
)
>
0
;
}
#
ifdef
DEBUG
#
define
VerifyNonNegativeDamageRect
(
r
)
\
NS_ASSERTION
(
(
r
)
.
StartCol
(
)
>
=
0
"
negative
col
index
"
)
;
\
NS_ASSERTION
(
(
r
)
.
StartRow
(
)
>
=
0
"
negative
row
index
"
)
;
\
NS_ASSERTION
(
(
r
)
.
ColCount
(
)
>
=
0
"
negative
cols
damage
"
)
;
\
NS_ASSERTION
(
(
r
)
.
RowCount
(
)
>
=
0
"
negative
rows
damage
"
)
;
#
define
VerifyDamageRect
(
r
)
\
VerifyNonNegativeDamageRect
(
r
)
;
\
NS_ASSERTION
(
(
r
)
.
EndCol
(
)
<
=
GetColCount
(
)
\
"
cols
damage
extends
outside
table
"
)
;
\
NS_ASSERTION
(
(
r
)
.
EndRow
(
)
<
=
GetRowCount
(
)
\
"
rows
damage
extends
outside
table
"
)
;
#
endif
void
nsTableFrame
:
:
AddBCDamageArea
(
const
TableArea
&
aValue
)
{
NS_ASSERTION
(
IsBorderCollapse
(
)
"
invalid
AddBCDamageArea
call
"
)
;
#
ifdef
DEBUG
VerifyDamageRect
(
aValue
)
;
#
endif
SetNeedToCalcBCBorders
(
true
)
;
SetNeedToCalcHasBCBorders
(
true
)
;
BCPropertyData
*
value
=
GetOrCreateBCProperty
(
)
;
if
(
value
)
{
#
ifdef
DEBUG
VerifyNonNegativeDamageRect
(
value
-
>
mDamageArea
)
;
#
endif
int32_t
cols
=
GetColCount
(
)
;
if
(
value
-
>
mDamageArea
.
EndCol
(
)
>
cols
)
{
if
(
value
-
>
mDamageArea
.
StartCol
(
)
>
cols
)
{
value
-
>
mDamageArea
.
StartCol
(
)
=
cols
;
value
-
>
mDamageArea
.
ColCount
(
)
=
0
;
}
else
{
value
-
>
mDamageArea
.
ColCount
(
)
=
cols
-
value
-
>
mDamageArea
.
StartCol
(
)
;
}
}
int32_t
rows
=
GetRowCount
(
)
;
if
(
value
-
>
mDamageArea
.
EndRow
(
)
>
rows
)
{
if
(
value
-
>
mDamageArea
.
StartRow
(
)
>
rows
)
{
value
-
>
mDamageArea
.
StartRow
(
)
=
rows
;
value
-
>
mDamageArea
.
RowCount
(
)
=
0
;
}
else
{
value
-
>
mDamageArea
.
RowCount
(
)
=
rows
-
value
-
>
mDamageArea
.
StartRow
(
)
;
}
}
value
-
>
mDamageArea
.
UnionArea
(
value
-
>
mDamageArea
aValue
)
;
}
}
void
nsTableFrame
:
:
SetFullBCDamageArea
(
)
{
NS_ASSERTION
(
IsBorderCollapse
(
)
"
invalid
SetFullBCDamageArea
call
"
)
;
SetNeedToCalcBCBorders
(
true
)
;
SetNeedToCalcHasBCBorders
(
true
)
;
BCPropertyData
*
value
=
GetOrCreateBCProperty
(
)
;
if
(
value
)
{
value
-
>
mDamageArea
=
TableArea
(
0
0
GetColCount
(
)
GetRowCount
(
)
)
;
}
}
struct
BCCellBorder
{
BCCellBorder
(
)
{
Reset
(
0
1
)
;
}
void
Reset
(
uint32_t
aRowIndex
uint32_t
aRowSpan
)
;
nscolor
color
;
BCPixelSize
width
;
StyleBorderStyle
style
;
BCBorderOwner
owner
;
int32_t
rowIndex
;
int32_t
rowSpan
;
}
;
void
BCCellBorder
:
:
Reset
(
uint32_t
aRowIndex
uint32_t
aRowSpan
)
{
style
=
StyleBorderStyle
:
:
None
;
color
=
0
;
width
=
0
;
owner
=
eTableOwner
;
rowIndex
=
aRowIndex
;
rowSpan
=
aRowSpan
;
}
class
BCMapCellIterator
;
struct
BCMapCellInfo
{
explicit
BCMapCellInfo
(
nsTableFrame
*
aTableFrame
)
;
void
ResetCellInfo
(
)
;
void
SetInfo
(
nsTableRowFrame
*
aNewRow
int32_t
aColIndex
BCCellData
*
aCellData
BCMapCellIterator
*
aIter
nsCellMap
*
aCellMap
=
nullptr
)
;
void
SetTableBStartIStartContBCBorder
(
)
;
void
SetRowGroupIStartContBCBorder
(
)
;
void
SetRowGroupIEndContBCBorder
(
)
;
void
SetRowGroupBEndContBCBorder
(
)
;
void
SetRowIStartContBCBorder
(
)
;
void
SetRowIEndContBCBorder
(
)
;
void
SetColumnBStartIEndContBCBorder
(
)
;
void
SetColumnBEndContBCBorder
(
)
;
void
SetColGroupBEndContBCBorder
(
)
;
void
SetInnerRowGroupBEndContBCBorder
(
const
nsIFrame
*
aNextRowGroup
nsTableRowFrame
*
aNextRow
)
;
void
SetTableBStartBorderWidth
(
BCPixelSize
aWidth
)
;
void
SetTableIStartBorderWidth
(
int32_t
aRowB
BCPixelSize
aWidth
)
;
void
SetTableIEndBorderWidth
(
int32_t
aRowB
BCPixelSize
aWidth
)
;
void
SetTableBEndBorderWidth
(
BCPixelSize
aWidth
)
;
void
SetIStartBorderWidths
(
BCPixelSize
aWidth
)
;
void
SetIEndBorderWidths
(
BCPixelSize
aWidth
)
;
void
SetBStartBorderWidths
(
BCPixelSize
aWidth
)
;
void
SetBEndBorderWidths
(
BCPixelSize
aWidth
)
;
BCCellBorder
GetBStartEdgeBorder
(
)
;
BCCellBorder
GetBEndEdgeBorder
(
)
;
BCCellBorder
GetIStartEdgeBorder
(
)
;
BCCellBorder
GetIEndEdgeBorder
(
)
;
BCCellBorder
GetIEndInternalBorder
(
)
;
BCCellBorder
GetIStartInternalBorder
(
)
;
BCCellBorder
GetBStartInternalBorder
(
)
;
BCCellBorder
GetBEndInternalBorder
(
)
;
void
SetColumn
(
int32_t
aColX
)
;
void
IncrementRow
(
bool
aResetToBStartRowOfCell
=
false
)
;
int32_t
GetCellEndRowIndex
(
)
const
;
int32_t
GetCellEndColIndex
(
)
const
;
nsTableFrame
*
mTableFrame
;
int32_t
mNumTableRows
;
int32_t
mNumTableCols
;
BCPropertyData
*
mTableBCData
;
WritingMode
mTableWM
;
nsTableRowGroupFrame
*
mRowGroup
;
nsTableRowFrame
*
mStartRow
;
nsTableRowFrame
*
mEndRow
;
nsTableRowFrame
*
mCurrentRowFrame
;
nsTableColGroupFrame
*
mColGroup
;
nsTableColGroupFrame
*
mCurrentColGroupFrame
;
nsTableColFrame
*
mStartCol
;
nsTableColFrame
*
mEndCol
;
nsTableColFrame
*
mCurrentColFrame
;
BCCellData
*
mCellData
;
nsBCTableCellFrame
*
mCell
;
int32_t
mRowIndex
;
int32_t
mRowSpan
;
int32_t
mColIndex
;
int32_t
mColSpan
;
bool
mRgAtStart
;
bool
mRgAtEnd
;
bool
mCgAtStart
;
bool
mCgAtEnd
;
}
;
BCMapCellInfo
:
:
BCMapCellInfo
(
nsTableFrame
*
aTableFrame
)
:
mTableFrame
(
aTableFrame
)
mNumTableRows
(
aTableFrame
-
>
GetRowCount
(
)
)
mNumTableCols
(
aTableFrame
-
>
GetColCount
(
)
)
mTableBCData
(
mTableFrame
-
>
GetProperty
(
TableBCProperty
(
)
)
)
mTableWM
(
aTableFrame
-
>
Style
(
)
)
mCurrentRowFrame
(
nullptr
)
mCurrentColGroupFrame
(
nullptr
)
mCurrentColFrame
(
nullptr
)
{
ResetCellInfo
(
)
;
}
void
BCMapCellInfo
:
:
ResetCellInfo
(
)
{
mCellData
=
nullptr
;
mRowGroup
=
nullptr
;
mStartRow
=
nullptr
;
mEndRow
=
nullptr
;
mColGroup
=
nullptr
;
mStartCol
=
nullptr
;
mEndCol
=
nullptr
;
mCell
=
nullptr
;
mRowIndex
=
mRowSpan
=
mColIndex
=
mColSpan
=
0
;
mRgAtStart
=
mRgAtEnd
=
mCgAtStart
=
mCgAtEnd
=
false
;
}
inline
int32_t
BCMapCellInfo
:
:
GetCellEndRowIndex
(
)
const
{
return
mRowIndex
+
mRowSpan
-
1
;
}
inline
int32_t
BCMapCellInfo
:
:
GetCellEndColIndex
(
)
const
{
return
mColIndex
+
mColSpan
-
1
;
}
class
BCMapCellIterator
{
public
:
BCMapCellIterator
(
nsTableFrame
*
aTableFrame
const
TableArea
&
aDamageArea
)
;
void
First
(
BCMapCellInfo
&
aMapCellInfo
)
;
void
Next
(
BCMapCellInfo
&
aMapCellInfo
)
;
void
PeekIEnd
(
BCMapCellInfo
&
aRefInfo
uint32_t
aRowIndex
BCMapCellInfo
&
aAjaInfo
)
;
void
PeekBEnd
(
BCMapCellInfo
&
aRefInfo
uint32_t
aColIndex
BCMapCellInfo
&
aAjaInfo
)
;
bool
IsNewRow
(
)
{
return
mIsNewRow
;
}
nsTableRowFrame
*
GetPrevRow
(
)
const
{
return
mPrevRow
;
}
nsTableRowFrame
*
GetCurrentRow
(
)
const
{
return
mRow
;
}
nsTableRowGroupFrame
*
GetCurrentRowGroup
(
)
const
{
return
mRowGroup
;
}
int32_t
mRowGroupStart
;
int32_t
mRowGroupEnd
;
bool
mAtEnd
;
nsCellMap
*
mCellMap
;
private
:
bool
SetNewRow
(
nsTableRowFrame
*
row
=
nullptr
)
;
bool
SetNewRowGroup
(
bool
aFindFirstDamagedRow
)
;
nsTableFrame
*
mTableFrame
;
nsTableCellMap
*
mTableCellMap
;
nsTableFrame
:
:
RowGroupArray
mRowGroups
;
nsTableRowGroupFrame
*
mRowGroup
;
int32_t
mRowGroupIndex
;
uint32_t
mNumTableRows
;
nsTableRowFrame
*
mRow
;
nsTableRowFrame
*
mPrevRow
;
bool
mIsNewRow
;
int32_t
mRowIndex
;
uint32_t
mNumTableCols
;
int32_t
mColIndex
;
nsPoint
mAreaStart
;
nsPoint
mAreaEnd
;
}
;
BCMapCellIterator
:
:
BCMapCellIterator
(
nsTableFrame
*
aTableFrame
const
TableArea
&
aDamageArea
)
:
mRowGroupStart
(
0
)
mRowGroupEnd
(
0
)
mCellMap
(
nullptr
)
mTableFrame
(
aTableFrame
)
mRowGroup
(
nullptr
)
mPrevRow
(
nullptr
)
mIsNewRow
(
false
)
{
mTableCellMap
=
aTableFrame
-
>
GetCellMap
(
)
;
mAreaStart
.
x
=
aDamageArea
.
StartCol
(
)
;
mAreaStart
.
y
=
aDamageArea
.
StartRow
(
)
;
mAreaEnd
.
x
=
aDamageArea
.
EndCol
(
)
-
1
;
mAreaEnd
.
y
=
aDamageArea
.
EndRow
(
)
-
1
;
mNumTableRows
=
mTableFrame
-
>
GetRowCount
(
)
;
mRow
=
nullptr
;
mRowIndex
=
0
;
mNumTableCols
=
mTableFrame
-
>
GetColCount
(
)
;
mColIndex
=
0
;
mRowGroupIndex
=
-
1
;
aTableFrame
-
>
OrderRowGroups
(
mRowGroups
)
;
mAtEnd
=
true
;
}
void
BCMapCellInfo
:
:
SetInfo
(
nsTableRowFrame
*
aNewRow
int32_t
aColIndex
BCCellData
*
aCellData
BCMapCellIterator
*
aIter
nsCellMap
*
aCellMap
)
{
mCellData
=
aCellData
;
mColIndex
=
aColIndex
;
mRowIndex
=
0
;
if
(
aNewRow
)
{
mStartRow
=
aNewRow
;
mRowIndex
=
aNewRow
-
>
GetRowIndex
(
)
;
}
mCell
=
nullptr
;
mRowSpan
=
1
;
mColSpan
=
1
;
if
(
aCellData
)
{
mCell
=
static_cast
<
nsBCTableCellFrame
*
>
(
aCellData
-
>
GetCellFrame
(
)
)
;
if
(
mCell
)
{
if
(
!
mStartRow
)
{
mStartRow
=
mCell
-
>
GetTableRowFrame
(
)
;
if
(
!
mStartRow
)
ABORT0
(
)
;
mRowIndex
=
mStartRow
-
>
GetRowIndex
(
)
;
}
mColSpan
=
mTableFrame
-
>
GetEffectiveColSpan
(
*
mCell
aCellMap
)
;
mRowSpan
=
mTableFrame
-
>
GetEffectiveRowSpan
(
*
mCell
aCellMap
)
;
}
}
if
(
!
mStartRow
)
{
mStartRow
=
aIter
-
>
GetCurrentRow
(
)
;
}
if
(
1
=
=
mRowSpan
)
{
mEndRow
=
mStartRow
;
}
else
{
mEndRow
=
mStartRow
-
>
GetNextRow
(
)
;
if
(
mEndRow
)
{
for
(
int32_t
span
=
2
;
mEndRow
&
&
span
<
mRowSpan
;
span
+
+
)
{
mEndRow
=
mEndRow
-
>
GetNextRow
(
)
;
}
NS_ASSERTION
(
mEndRow
"
spanned
row
not
found
"
)
;
}
else
{
NS_ERROR
(
"
error
in
cell
map
"
)
;
mRowSpan
=
1
;
mEndRow
=
mStartRow
;
}
}
uint32_t
rgStart
=
aIter
-
>
mRowGroupStart
;
uint32_t
rgEnd
=
aIter
-
>
mRowGroupEnd
;
mRowGroup
=
mStartRow
-
>
GetTableRowGroupFrame
(
)
;
if
(
mRowGroup
!
=
aIter
-
>
GetCurrentRowGroup
(
)
)
{
rgStart
=
mRowGroup
-
>
GetStartRowIndex
(
)
;
rgEnd
=
rgStart
+
mRowGroup
-
>
GetRowCount
(
)
-
1
;
}
uint32_t
rowIndex
=
mStartRow
-
>
GetRowIndex
(
)
;
mRgAtStart
=
rgStart
=
=
rowIndex
;
mRgAtEnd
=
rgEnd
=
=
rowIndex
+
mRowSpan
-
1
;
mStartCol
=
mTableFrame
-
>
GetColFrame
(
aColIndex
)
;
if
(
!
mStartCol
)
ABORT0
(
)
;
mEndCol
=
mStartCol
;
if
(
mColSpan
>
1
)
{
nsTableColFrame
*
colFrame
=
mTableFrame
-
>
GetColFrame
(
aColIndex
+
mColSpan
-
1
)
;
if
(
!
colFrame
)
ABORT0
(
)
;
mEndCol
=
colFrame
;
}
mColGroup
=
mStartCol
-
>
GetTableColGroupFrame
(
)
;
int32_t
cgStart
=
mColGroup
-
>
GetStartColumnIndex
(
)
;
int32_t
cgEnd
=
std
:
:
max
(
0
cgStart
+
mColGroup
-
>
GetColCount
(
)
-
1
)
;
mCgAtStart
=
cgStart
=
=
aColIndex
;
mCgAtEnd
=
cgEnd
=
=
aColIndex
+
mColSpan
-
1
;
}
bool
BCMapCellIterator
:
:
SetNewRow
(
nsTableRowFrame
*
aRow
)
{
mAtEnd
=
true
;
mPrevRow
=
mRow
;
if
(
aRow
)
{
mRow
=
aRow
;
}
else
if
(
mRow
)
{
mRow
=
mRow
-
>
GetNextRow
(
)
;
}
if
(
mRow
)
{
mRowIndex
=
mRow
-
>
GetRowIndex
(
)
;
int32_t
rgRowIndex
=
mRowIndex
-
mRowGroupStart
;
if
(
uint32_t
(
rgRowIndex
)
>
=
mCellMap
-
>
mRows
.
Length
(
)
)
ABORT1
(
false
)
;
const
nsCellMap
:
:
CellDataArray
&
row
=
mCellMap
-
>
mRows
[
rgRowIndex
]
;
for
(
mColIndex
=
mAreaStart
.
x
;
mColIndex
<
=
mAreaEnd
.
x
;
mColIndex
+
+
)
{
CellData
*
cellData
=
row
.
SafeElementAt
(
mColIndex
)
;
if
(
!
cellData
)
{
TableArea
damageArea
;
cellData
=
mCellMap
-
>
AppendCell
(
*
mTableCellMap
nullptr
rgRowIndex
false
0
damageArea
)
;
if
(
!
cellData
)
ABORT1
(
false
)
;
}
if
(
cellData
&
&
(
cellData
-
>
IsOrig
(
)
|
|
cellData
-
>
IsDead
(
)
)
)
{
break
;
}
}
mIsNewRow
=
true
;
mAtEnd
=
false
;
}
else
ABORT1
(
false
)
;
return
!
mAtEnd
;
}
bool
BCMapCellIterator
:
:
SetNewRowGroup
(
bool
aFindFirstDamagedRow
)
{
mAtEnd
=
true
;
int32_t
numRowGroups
=
mRowGroups
.
Length
(
)
;
mCellMap
=
nullptr
;
for
(
mRowGroupIndex
+
+
;
mRowGroupIndex
<
numRowGroups
;
mRowGroupIndex
+
+
)
{
mRowGroup
=
mRowGroups
[
mRowGroupIndex
]
;
int32_t
rowCount
=
mRowGroup
-
>
GetRowCount
(
)
;
mRowGroupStart
=
mRowGroup
-
>
GetStartRowIndex
(
)
;
mRowGroupEnd
=
mRowGroupStart
+
rowCount
-
1
;
if
(
rowCount
>
0
)
{
mCellMap
=
mTableCellMap
-
>
GetMapFor
(
mRowGroup
mCellMap
)
;
if
(
!
mCellMap
)
ABORT1
(
false
)
;
nsTableRowFrame
*
firstRow
=
mRowGroup
-
>
GetFirstRow
(
)
;
if
(
aFindFirstDamagedRow
)
{
if
(
(
mAreaStart
.
y
>
=
mRowGroupStart
)
&
&
(
mAreaStart
.
y
<
=
mRowGroupEnd
)
)
{
if
(
aFindFirstDamagedRow
)
{
int32_t
numRows
=
mAreaStart
.
y
-
mRowGroupStart
;
for
(
int32_t
i
=
0
;
i
<
numRows
;
i
+
+
)
{
firstRow
=
firstRow
-
>
GetNextRow
(
)
;
if
(
!
firstRow
)
ABORT1
(
false
)
;
}
}
}
else
{
continue
;
}
}
if
(
SetNewRow
(
firstRow
)
)
{
break
;
}
}
}
return
!
mAtEnd
;
}
void
BCMapCellIterator
:
:
First
(
BCMapCellInfo
&
aMapInfo
)
{
aMapInfo
.
ResetCellInfo
(
)
;
SetNewRowGroup
(
true
)
;
while
(
!
mAtEnd
)
{
if
(
(
mAreaStart
.
y
>
=
mRowGroupStart
)
&
&
(
mAreaStart
.
y
<
=
mRowGroupEnd
)
)
{
BCCellData
*
cellData
=
static_cast
<
BCCellData
*
>
(
mCellMap
-
>
GetDataAt
(
mAreaStart
.
y
-
mRowGroupStart
mAreaStart
.
x
)
)
;
if
(
cellData
&
&
(
cellData
-
>
IsOrig
(
)
|
|
cellData
-
>
IsDead
(
)
)
)
{
aMapInfo
.
SetInfo
(
mRow
mAreaStart
.
x
cellData
this
)
;
return
;
}
else
{
NS_ASSERTION
(
(
(
0
=
=
mAreaStart
.
x
)
&
&
(
mRowGroupStart
=
=
mAreaStart
.
y
)
)
"
damage
area
expanded
incorrectly
"
)
;
}
}
SetNewRowGroup
(
true
)
;
}
}
void
BCMapCellIterator
:
:
Next
(
BCMapCellInfo
&
aMapInfo
)
{
if
(
mAtEnd
)
ABORT0
(
)
;
aMapInfo
.
ResetCellInfo
(
)
;
mIsNewRow
=
false
;
mColIndex
+
+
;
while
(
(
mRowIndex
<
=
mAreaEnd
.
y
)
&
&
!
mAtEnd
)
{
for
(
;
mColIndex
<
=
mAreaEnd
.
x
;
mColIndex
+
+
)
{
int32_t
rgRowIndex
=
mRowIndex
-
mRowGroupStart
;
BCCellData
*
cellData
=
static_cast
<
BCCellData
*
>
(
mCellMap
-
>
GetDataAt
(
rgRowIndex
mColIndex
)
)
;
if
(
!
cellData
)
{
TableArea
damageArea
;
cellData
=
static_cast
<
BCCellData
*
>
(
mCellMap
-
>
AppendCell
(
*
mTableCellMap
nullptr
rgRowIndex
false
0
damageArea
)
)
;
if
(
!
cellData
)
ABORT0
(
)
;
}
if
(
cellData
&
&
(
cellData
-
>
IsOrig
(
)
|
|
cellData
-
>
IsDead
(
)
)
)
{
aMapInfo
.
SetInfo
(
mRow
mColIndex
cellData
this
)
;
return
;
}
}
if
(
mRowIndex
>
=
mRowGroupEnd
)
{
SetNewRowGroup
(
false
)
;
}
else
{
SetNewRow
(
)
;
}
}
mAtEnd
=
true
;
}
void
BCMapCellIterator
:
:
PeekIEnd
(
BCMapCellInfo
&
aRefInfo
uint32_t
aRowIndex
BCMapCellInfo
&
aAjaInfo
)
{
aAjaInfo
.
ResetCellInfo
(
)
;
int32_t
colIndex
=
aRefInfo
.
mColIndex
+
aRefInfo
.
mColSpan
;
uint32_t
rgRowIndex
=
aRowIndex
-
mRowGroupStart
;
BCCellData
*
cellData
=
static_cast
<
BCCellData
*
>
(
mCellMap
-
>
GetDataAt
(
rgRowIndex
colIndex
)
)
;
if
(
!
cellData
)
{
NS_ASSERTION
(
colIndex
<
mTableCellMap
-
>
GetColCount
(
)
"
program
error
"
)
;
TableArea
damageArea
;
cellData
=
static_cast
<
BCCellData
*
>
(
mCellMap
-
>
AppendCell
(
*
mTableCellMap
nullptr
rgRowIndex
false
0
damageArea
)
)
;
if
(
!
cellData
)
ABORT0
(
)
;
}
nsTableRowFrame
*
row
=
nullptr
;
if
(
cellData
-
>
IsRowSpan
(
)
)
{
rgRowIndex
-
=
cellData
-
>
GetRowSpanOffset
(
)
;
cellData
=
static_cast
<
BCCellData
*
>
(
mCellMap
-
>
GetDataAt
(
rgRowIndex
colIndex
)
)
;
if
(
!
cellData
)
ABORT0
(
)
;
}
else
{
row
=
mRow
;
}
aAjaInfo
.
SetInfo
(
row
colIndex
cellData
this
)
;
}
void
BCMapCellIterator
:
:
PeekBEnd
(
BCMapCellInfo
&
aRefInfo
uint32_t
aColIndex
BCMapCellInfo
&
aAjaInfo
)
{
aAjaInfo
.
ResetCellInfo
(
)
;
int32_t
rowIndex
=
aRefInfo
.
mRowIndex
+
aRefInfo
.
mRowSpan
;
int32_t
rgRowIndex
=
rowIndex
-
mRowGroupStart
;
nsTableRowGroupFrame
*
rg
=
mRowGroup
;
nsCellMap
*
cellMap
=
mCellMap
;
nsTableRowFrame
*
nextRow
=
nullptr
;
if
(
rowIndex
>
mRowGroupEnd
)
{
int32_t
nextRgIndex
=
mRowGroupIndex
;
do
{
nextRgIndex
+
+
;
rg
=
mRowGroups
.
SafeElementAt
(
nextRgIndex
)
;
if
(
rg
)
{
cellMap
=
mTableCellMap
-
>
GetMapFor
(
rg
cellMap
)
;
if
(
!
cellMap
)
ABORT0
(
)
;
rgRowIndex
=
0
;
nextRow
=
rg
-
>
GetFirstRow
(
)
;
}
}
while
(
rg
&
&
!
nextRow
)
;
if
(
!
rg
)
return
;
}
else
{
nextRow
=
mRow
;
for
(
int32_t
i
=
0
;
i
<
aRefInfo
.
mRowSpan
;
i
+
+
)
{
nextRow
=
nextRow
-
>
GetNextRow
(
)
;
if
(
!
nextRow
)
ABORT0
(
)
;
}
}
BCCellData
*
cellData
=
static_cast
<
BCCellData
*
>
(
cellMap
-
>
GetDataAt
(
rgRowIndex
aColIndex
)
)
;
if
(
!
cellData
)
{
NS_ASSERTION
(
rgRowIndex
<
cellMap
-
>
GetRowCount
(
)
"
program
error
"
)
;
TableArea
damageArea
;
cellData
=
static_cast
<
BCCellData
*
>
(
cellMap
-
>
AppendCell
(
*
mTableCellMap
nullptr
rgRowIndex
false
0
damageArea
)
)
;
if
(
!
cellData
)
ABORT0
(
)
;
}
if
(
cellData
-
>
IsColSpan
(
)
)
{
aColIndex
-
=
cellData
-
>
GetColSpanOffset
(
)
;
cellData
=
static_cast
<
BCCellData
*
>
(
cellMap
-
>
GetDataAt
(
rgRowIndex
aColIndex
)
)
;
}
aAjaInfo
.
SetInfo
(
nextRow
aColIndex
cellData
this
cellMap
)
;
}
#
define
CELL_CORNER
true
static
void
GetColorAndStyle
(
const
nsIFrame
*
aFrame
WritingMode
aTableWM
LogicalSide
aSide
StyleBorderStyle
*
aStyle
nscolor
*
aColor
BCPixelSize
*
aWidth
=
nullptr
)
{
MOZ_ASSERT
(
aFrame
"
null
frame
"
)
;
MOZ_ASSERT
(
aStyle
&
&
aColor
"
null
argument
"
)
;
*
aColor
=
0
;
if
(
aWidth
)
{
*
aWidth
=
0
;
}
const
nsStyleBorder
*
styleData
=
aFrame
-
>
StyleBorder
(
)
;
mozilla
:
:
Side
physicalSide
=
aTableWM
.
PhysicalSide
(
aSide
)
;
*
aStyle
=
styleData
-
>
GetBorderStyle
(
physicalSide
)
;
if
(
(
StyleBorderStyle
:
:
None
=
=
*
aStyle
)
|
|
(
StyleBorderStyle
:
:
Hidden
=
=
*
aStyle
)
)
{
return
;
}
*
aColor
=
aFrame
-
>
Style
(
)
-
>
GetVisitedDependentColor
(
nsStyleBorder
:
:
BorderColorFieldFor
(
physicalSide
)
)
;
if
(
aWidth
)
{
nscoord
width
=
styleData
-
>
GetComputedBorderWidth
(
physicalSide
)
;
*
aWidth
=
aFrame
-
>
PresContext
(
)
-
>
AppUnitsToDevPixels
(
width
)
;
}
}
static
void
GetPaintStyleInfo
(
const
nsIFrame
*
aFrame
WritingMode
aTableWM
LogicalSide
aSide
StyleBorderStyle
*
aStyle
nscolor
*
aColor
)
{
GetColorAndStyle
(
aFrame
aTableWM
aSide
aStyle
aColor
)
;
if
(
StyleBorderStyle
:
:
Inset
=
=
*
aStyle
)
{
*
aStyle
=
StyleBorderStyle
:
:
Ridge
;
}
else
if
(
StyleBorderStyle
:
:
Outset
=
=
*
aStyle
)
{
*
aStyle
=
StyleBorderStyle
:
:
Groove
;
}
}
class
nsDelayedCalcBCBorders
:
public
Runnable
{
public
:
explicit
nsDelayedCalcBCBorders
(
nsIFrame
*
aFrame
)
:
mozilla
:
:
Runnable
(
"
nsDelayedCalcBCBorders
"
)
mFrame
(
aFrame
)
{
}
NS_IMETHOD
Run
(
)
override
{
if
(
mFrame
)
{
nsTableFrame
*
tableFrame
=
static_cast
<
nsTableFrame
*
>
(
mFrame
.
GetFrame
(
)
)
;
if
(
tableFrame
-
>
NeedToCalcBCBorders
(
)
)
{
tableFrame
-
>
CalcBCBorders
(
)
;
}
}
return
NS_OK
;
}
private
:
WeakFrame
mFrame
;
}
;
bool
nsTableFrame
:
:
BCRecalcNeeded
(
ComputedStyle
*
aOldComputedStyle
ComputedStyle
*
aNewComputedStyle
)
{
const
nsStyleBorder
*
oldStyleData
=
aOldComputedStyle
-
>
StyleBorder
(
)
;
const
nsStyleBorder
*
newStyleData
=
aNewComputedStyle
-
>
StyleBorder
(
)
;
nsChangeHint
change
=
newStyleData
-
>
CalcDifference
(
*
oldStyleData
)
;
if
(
!
change
)
return
false
;
if
(
change
&
nsChangeHint_NeedReflow
)
return
true
;
if
(
change
&
nsChangeHint_RepaintFrame
)
{
nsCOMPtr
<
nsIRunnable
>
evt
=
new
nsDelayedCalcBCBorders
(
this
)
;
nsresult
rv
=
GetContent
(
)
-
>
OwnerDoc
(
)
-
>
Dispatch
(
TaskCategory
:
:
Other
evt
.
forget
(
)
)
;
return
NS_SUCCEEDED
(
rv
)
;
}
return
false
;
}
static
const
BCCellBorder
&
CompareBorders
(
bool
aIsCorner
const
BCCellBorder
&
aBorder1
const
BCCellBorder
&
aBorder2
bool
aSecondIsInlineDir
bool
*
aFirstDominates
=
nullptr
)
{
bool
firstDominates
=
true
;
if
(
StyleBorderStyle
:
:
Hidden
=
=
aBorder1
.
style
)
{
firstDominates
=
(
aIsCorner
)
?
false
:
true
;
}
else
if
(
StyleBorderStyle
:
:
Hidden
=
=
aBorder2
.
style
)
{
firstDominates
=
(
aIsCorner
)
?
true
:
false
;
}
else
if
(
aBorder1
.
width
<
aBorder2
.
width
)
{
firstDominates
=
false
;
}
else
if
(
aBorder1
.
width
=
=
aBorder2
.
width
)
{
if
(
static_cast
<
uint8_t
>
(
aBorder1
.
style
)
<
static_cast
<
uint8_t
>
(
aBorder2
.
style
)
)
{
firstDominates
=
false
;
}
else
if
(
aBorder1
.
style
=
=
aBorder2
.
style
)
{
if
(
aBorder1
.
owner
=
=
aBorder2
.
owner
)
{
firstDominates
=
!
aSecondIsInlineDir
;
}
else
if
(
aBorder1
.
owner
<
aBorder2
.
owner
)
{
firstDominates
=
false
;
}
}
}
if
(
aFirstDominates
)
*
aFirstDominates
=
firstDominates
;
if
(
firstDominates
)
return
aBorder1
;
return
aBorder2
;
}
static
BCCellBorder
CompareBorders
(
const
nsIFrame
*
aTableFrame
const
nsIFrame
*
aColGroupFrame
const
nsIFrame
*
aColFrame
const
nsIFrame
*
aRowGroupFrame
const
nsIFrame
*
aRowFrame
const
nsIFrame
*
aCellFrame
WritingMode
aTableWM
LogicalSide
aSide
bool
aAja
)
{
BCCellBorder
border
tempBorder
;
bool
inlineAxis
=
IsBlock
(
aSide
)
;
if
(
aTableFrame
)
{
GetColorAndStyle
(
aTableFrame
aTableWM
aSide
&
border
.
style
&
border
.
color
&
border
.
width
)
;
border
.
owner
=
eTableOwner
;
if
(
StyleBorderStyle
:
:
Hidden
=
=
border
.
style
)
{
return
border
;
}
}
if
(
aColGroupFrame
)
{
GetColorAndStyle
(
aColGroupFrame
aTableWM
aSide
&
tempBorder
.
style
&
tempBorder
.
color
&
tempBorder
.
width
)
;
tempBorder
.
owner
=
aAja
&
&
!
inlineAxis
?
eAjaColGroupOwner
:
eColGroupOwner
;
border
=
CompareBorders
(
!
CELL_CORNER
border
tempBorder
false
)
;
if
(
StyleBorderStyle
:
:
Hidden
=
=
border
.
style
)
{
return
border
;
}
}
if
(
aColFrame
)
{
GetColorAndStyle
(
aColFrame
aTableWM
aSide
&
tempBorder
.
style
&
tempBorder
.
color
&
tempBorder
.
width
)
;
tempBorder
.
owner
=
aAja
&
&
!
inlineAxis
?
eAjaColOwner
:
eColOwner
;
border
=
CompareBorders
(
!
CELL_CORNER
border
tempBorder
false
)
;
if
(
StyleBorderStyle
:
:
Hidden
=
=
border
.
style
)
{
return
border
;
}
}
if
(
aRowGroupFrame
)
{
GetColorAndStyle
(
aRowGroupFrame
aTableWM
aSide
&
tempBorder
.
style
&
tempBorder
.
color
&
tempBorder
.
width
)
;
tempBorder
.
owner
=
aAja
&
&
inlineAxis
?
eAjaRowGroupOwner
:
eRowGroupOwner
;
border
=
CompareBorders
(
!
CELL_CORNER
border
tempBorder
false
)
;
if
(
StyleBorderStyle
:
:
Hidden
=
=
border
.
style
)
{
return
border
;
}
}
if
(
aRowFrame
)
{
GetColorAndStyle
(
aRowFrame
aTableWM
aSide
&
tempBorder
.
style
&
tempBorder
.
color
&
tempBorder
.
width
)
;
tempBorder
.
owner
=
aAja
&
&
inlineAxis
?
eAjaRowOwner
:
eRowOwner
;
border
=
CompareBorders
(
!
CELL_CORNER
border
tempBorder
false
)
;
if
(
StyleBorderStyle
:
:
Hidden
=
=
border
.
style
)
{
return
border
;
}
}
if
(
aCellFrame
)
{
GetColorAndStyle
(
aCellFrame
aTableWM
aSide
&
tempBorder
.
style
&
tempBorder
.
color
&
tempBorder
.
width
)
;
tempBorder
.
owner
=
aAja
?
eAjaCellOwner
:
eCellOwner
;
border
=
CompareBorders
(
!
CELL_CORNER
border
tempBorder
false
)
;
}
return
border
;
}
static
bool
Perpendicular
(
mozilla
:
:
LogicalSide
aSide1
mozilla
:
:
LogicalSide
aSide2
)
{
return
IsInline
(
aSide1
)
!
=
IsInline
(
aSide2
)
;
}
#
define
BORDER_STYLE_UNSET
static_cast
<
StyleBorderStyle
>
(
255
)
struct
BCCornerInfo
{
BCCornerInfo
(
)
{
ownerColor
=
0
;
ownerWidth
=
subWidth
=
ownerElem
=
subSide
=
subElem
=
hasDashDot
=
numSegs
=
bevel
=
0
;
ownerSide
=
eLogicalSideBStart
;
ownerStyle
=
BORDER_STYLE_UNSET
;
subStyle
=
StyleBorderStyle
:
:
Solid
;
}
void
Set
(
mozilla
:
:
LogicalSide
aSide
BCCellBorder
border
)
;
void
Update
(
mozilla
:
:
LogicalSide
aSide
BCCellBorder
border
)
;
nscolor
ownerColor
;
uint16_t
ownerWidth
;
uint16_t
subWidth
;
StyleBorderStyle
subStyle
;
StyleBorderStyle
ownerStyle
;
uint16_t
ownerSide
:
2
;
uint16_t
ownerElem
:
4
;
uint16_t
subSide
:
2
;
uint16_t
subElem
:
4
;
uint16_t
hasDashDot
:
1
;
uint16_t
numSegs
:
3
;
uint16_t
bevel
:
1
;
}
;
void
BCCornerInfo
:
:
Set
(
mozilla
:
:
LogicalSide
aSide
BCCellBorder
aBorder
)
{
ownerElem
=
aBorder
.
owner
&
0x7
;
ownerStyle
=
aBorder
.
style
;
ownerWidth
=
aBorder
.
width
;
ownerColor
=
aBorder
.
color
;
ownerSide
=
aSide
;
hasDashDot
=
0
;
numSegs
=
0
;
if
(
aBorder
.
width
>
0
)
{
numSegs
+
+
;
hasDashDot
=
(
StyleBorderStyle
:
:
Dashed
=
=
aBorder
.
style
)
|
|
(
StyleBorderStyle
:
:
Dotted
=
=
aBorder
.
style
)
;
}
bevel
=
0
;
subWidth
=
0
;
subSide
=
IsInline
(
aSide
)
?
eLogicalSideBStart
:
eLogicalSideIStart
;
subElem
=
eTableOwner
;
subStyle
=
StyleBorderStyle
:
:
Solid
;
}
void
BCCornerInfo
:
:
Update
(
mozilla
:
:
LogicalSide
aSide
BCCellBorder
aBorder
)
{
if
(
ownerStyle
=
=
BORDER_STYLE_UNSET
)
{
Set
(
aSide
aBorder
)
;
}
else
{
bool
isInline
=
IsInline
(
aSide
)
;
BCCellBorder
oldBorder
tempBorder
;
oldBorder
.
owner
=
(
BCBorderOwner
)
ownerElem
;
oldBorder
.
style
=
ownerStyle
;
oldBorder
.
width
=
ownerWidth
;
oldBorder
.
color
=
ownerColor
;
LogicalSide
oldSide
=
LogicalSide
(
ownerSide
)
;
bool
existingWins
=
false
;
tempBorder
=
CompareBorders
(
CELL_CORNER
oldBorder
aBorder
isInline
&
existingWins
)
;
ownerElem
=
tempBorder
.
owner
;
ownerStyle
=
tempBorder
.
style
;
ownerWidth
=
tempBorder
.
width
;
ownerColor
=
tempBorder
.
color
;
if
(
existingWins
)
{
if
(
:
:
Perpendicular
(
LogicalSide
(
ownerSide
)
aSide
)
)
{
BCCellBorder
subBorder
;
subBorder
.
owner
=
(
BCBorderOwner
)
subElem
;
subBorder
.
style
=
subStyle
;
subBorder
.
width
=
subWidth
;
subBorder
.
color
=
0
;
bool
firstWins
;
tempBorder
=
CompareBorders
(
CELL_CORNER
subBorder
aBorder
isInline
&
firstWins
)
;
subElem
=
tempBorder
.
owner
;
subStyle
=
tempBorder
.
style
;
subWidth
=
tempBorder
.
width
;
if
(
!
firstWins
)
{
subSide
=
aSide
;
}
}
}
else
{
ownerSide
=
aSide
;
if
(
:
:
Perpendicular
(
oldSide
LogicalSide
(
ownerSide
)
)
)
{
subElem
=
oldBorder
.
owner
;
subStyle
=
oldBorder
.
style
;
subWidth
=
oldBorder
.
width
;
subSide
=
oldSide
;
}
}
if
(
aBorder
.
width
>
0
)
{
numSegs
+
+
;
if
(
!
hasDashDot
&
&
(
(
StyleBorderStyle
:
:
Dashed
=
=
aBorder
.
style
)
|
|
(
StyleBorderStyle
:
:
Dotted
=
=
aBorder
.
style
)
)
)
{
hasDashDot
=
1
;
}
}
bevel
=
(
2
=
=
numSegs
)
&
&
(
subWidth
>
1
)
&
&
(
0
=
=
hasDashDot
)
;
}
}
struct
BCCorners
{
BCCorners
(
int32_t
aNumCorners
int32_t
aStartIndex
)
;
~
BCCorners
(
)
{
delete
[
]
corners
;
}
BCCornerInfo
&
operator
[
]
(
int32_t
i
)
const
{
NS_ASSERTION
(
(
i
>
=
startIndex
)
&
&
(
i
<
=
endIndex
)
"
program
error
"
)
;
return
corners
[
clamped
(
i
startIndex
endIndex
)
-
startIndex
]
;
}
int32_t
startIndex
;
int32_t
endIndex
;
BCCornerInfo
*
corners
;
}
;
BCCorners
:
:
BCCorners
(
int32_t
aNumCorners
int32_t
aStartIndex
)
{
NS_ASSERTION
(
(
aNumCorners
>
0
)
&
&
(
aStartIndex
>
=
0
)
"
program
error
"
)
;
startIndex
=
aStartIndex
;
endIndex
=
aStartIndex
+
aNumCorners
-
1
;
corners
=
new
BCCornerInfo
[
aNumCorners
]
;
}
struct
BCCellBorders
{
BCCellBorders
(
int32_t
aNumBorders
int32_t
aStartIndex
)
;
~
BCCellBorders
(
)
{
delete
[
]
borders
;
}
BCCellBorder
&
operator
[
]
(
int32_t
i
)
const
{
NS_ASSERTION
(
(
i
>
=
startIndex
)
&
&
(
i
<
=
endIndex
)
"
program
error
"
)
;
return
borders
[
clamped
(
i
startIndex
endIndex
)
-
startIndex
]
;
}
int32_t
startIndex
;
int32_t
endIndex
;
BCCellBorder
*
borders
;
}
;
BCCellBorders
:
:
BCCellBorders
(
int32_t
aNumBorders
int32_t
aStartIndex
)
{
NS_ASSERTION
(
(
aNumBorders
>
0
)
&
&
(
aStartIndex
>
=
0
)
"
program
error
"
)
;
startIndex
=
aStartIndex
;
endIndex
=
aStartIndex
+
aNumBorders
-
1
;
borders
=
new
BCCellBorder
[
aNumBorders
]
;
}
static
bool
SetBorder
(
const
BCCellBorder
&
aNewBorder
BCCellBorder
&
aBorder
)
{
bool
changed
=
(
aNewBorder
.
style
!
=
aBorder
.
style
)
|
|
(
aNewBorder
.
width
!
=
aBorder
.
width
)
|
|
(
aNewBorder
.
color
!
=
aBorder
.
color
)
;
aBorder
.
color
=
aNewBorder
.
color
;
aBorder
.
width
=
aNewBorder
.
width
;
aBorder
.
style
=
aNewBorder
.
style
;
aBorder
.
owner
=
aNewBorder
.
owner
;
return
changed
;
}
static
bool
SetInlineDirBorder
(
const
BCCellBorder
&
aNewBorder
const
BCCornerInfo
&
aCorner
BCCellBorder
&
aBorder
)
{
bool
startSeg
=
:
:
SetBorder
(
aNewBorder
aBorder
)
;
if
(
!
startSeg
)
{
startSeg
=
!
IsInline
(
LogicalSide
(
aCorner
.
ownerSide
)
)
;
}
return
startSeg
;
}
void
nsTableFrame
:
:
ExpandBCDamageArea
(
TableArea
&
aArea
)
const
{
int32_t
numRows
=
GetRowCount
(
)
;
int32_t
numCols
=
GetColCount
(
)
;
int32_t
dStartX
=
aArea
.
StartCol
(
)
;
int32_t
dEndX
=
aArea
.
EndCol
(
)
-
1
;
int32_t
dStartY
=
aArea
.
StartRow
(
)
;
int32_t
dEndY
=
aArea
.
EndRow
(
)
-
1
;
if
(
dStartX
>
0
)
{
dStartX
-
-
;
}
if
(
dEndX
<
(
numCols
-
1
)
)
{
dEndX
+
+
;
}
if
(
dStartY
>
0
)
{
dStartY
-
-
;
}
if
(
dEndY
<
(
numRows
-
1
)
)
{
dEndY
+
+
;
}
bool
haveSpanner
=
false
;
if
(
(
dStartX
>
0
)
|
|
(
dEndX
<
(
numCols
-
1
)
)
|
|
(
dStartY
>
0
)
|
|
(
dEndY
<
(
numRows
-
1
)
)
)
{
nsTableCellMap
*
tableCellMap
=
GetCellMap
(
)
;
if
(
!
tableCellMap
)
ABORT0
(
)
;
RowGroupArray
rowGroups
;
OrderRowGroups
(
rowGroups
)
;
nsCellMap
*
cellMap
=
nullptr
;
for
(
uint32_t
rgIdx
=
0
;
rgIdx
<
rowGroups
.
Length
(
)
;
rgIdx
+
+
)
{
nsTableRowGroupFrame
*
rgFrame
=
rowGroups
[
rgIdx
]
;
int32_t
rgStartY
=
rgFrame
-
>
GetStartRowIndex
(
)
;
int32_t
rgEndY
=
rgStartY
+
rgFrame
-
>
GetRowCount
(
)
-
1
;
if
(
dEndY
<
rgStartY
)
break
;
cellMap
=
tableCellMap
-
>
GetMapFor
(
rgFrame
cellMap
)
;
if
(
!
cellMap
)
ABORT0
(
)
;
if
(
(
dStartY
>
0
)
&
&
(
dStartY
>
=
rgStartY
)
&
&
(
dStartY
<
=
rgEndY
)
)
{
if
(
uint32_t
(
dStartY
-
rgStartY
)
>
=
cellMap
-
>
mRows
.
Length
(
)
)
ABORT0
(
)
;
const
nsCellMap
:
:
CellDataArray
&
row
=
cellMap
-
>
mRows
[
dStartY
-
rgStartY
]
;
for
(
int32_t
x
=
dStartX
;
x
<
=
dEndX
;
x
+
+
)
{
CellData
*
cellData
=
row
.
SafeElementAt
(
x
)
;
if
(
cellData
&
&
(
cellData
-
>
IsRowSpan
(
)
)
)
{
haveSpanner
=
true
;
break
;
}
}
if
(
dEndY
<
rgEndY
)
{
if
(
uint32_t
(
dEndY
+
1
-
rgStartY
)
>
=
cellMap
-
>
mRows
.
Length
(
)
)
ABORT0
(
)
;
const
nsCellMap
:
:
CellDataArray
&
row2
=
cellMap
-
>
mRows
[
dEndY
+
1
-
rgStartY
]
;
for
(
int32_t
x
=
dStartX
;
x
<
=
dEndX
;
x
+
+
)
{
CellData
*
cellData
=
row2
.
SafeElementAt
(
x
)
;
if
(
cellData
&
&
(
cellData
-
>
IsRowSpan
(
)
)
)
{
haveSpanner
=
true
;
break
;
}
}
}
}
int32_t
iterStartY
=
-
1
;
int32_t
iterEndY
=
-
1
;
if
(
(
dStartY
>
=
rgStartY
)
&
&
(
dStartY
<
=
rgEndY
)
)
{
iterStartY
=
dStartY
;
iterEndY
=
std
:
:
min
(
dEndY
rgEndY
)
;
}
else
if
(
(
dEndY
>
=
rgStartY
)
&
&
(
dEndY
<
=
rgEndY
)
)
{
iterStartY
=
rgStartY
;
iterEndY
=
dEndY
;
}
else
if
(
(
rgStartY
>
=
dStartY
)
&
&
(
rgEndY
<
=
dEndY
)
)
{
iterStartY
=
rgStartY
;
iterEndY
=
rgEndY
;
}
if
(
(
iterStartY
>
=
0
)
&
&
(
iterEndY
>
=
0
)
)
{
for
(
int32_t
y
=
iterStartY
;
y
<
=
iterEndY
;
y
+
+
)
{
if
(
uint32_t
(
y
-
rgStartY
)
>
=
cellMap
-
>
mRows
.
Length
(
)
)
ABORT0
(
)
;
const
nsCellMap
:
:
CellDataArray
&
row
=
cellMap
-
>
mRows
[
y
-
rgStartY
]
;
CellData
*
cellData
=
row
.
SafeElementAt
(
dStartX
)
;
if
(
cellData
&
&
(
cellData
-
>
IsColSpan
(
)
)
)
{
haveSpanner
=
true
;
break
;
}
if
(
dEndX
<
(
numCols
-
1
)
)
{
cellData
=
row
.
SafeElementAt
(
dEndX
+
1
)
;
if
(
cellData
&
&
(
cellData
-
>
IsColSpan
(
)
)
)
{
haveSpanner
=
true
;
break
;
}
}
}
}
}
}
if
(
haveSpanner
)
{
aArea
.
StartCol
(
)
=
0
;
aArea
.
StartRow
(
)
=
0
;
aArea
.
ColCount
(
)
=
numCols
;
aArea
.
RowCount
(
)
=
numRows
;
}
else
{
aArea
.
StartCol
(
)
=
dStartX
;
aArea
.
StartRow
(
)
=
dStartY
;
aArea
.
ColCount
(
)
=
1
+
dEndX
-
dStartX
;
aArea
.
RowCount
(
)
=
1
+
dEndY
-
dStartY
;
}
}
#
define
ADJACENT
true
#
define
INLINE_DIR
true
void
BCMapCellInfo
:
:
SetTableBStartIStartContBCBorder
(
)
{
BCCellBorder
currentBorder
;
if
(
mStartRow
)
{
currentBorder
=
CompareBorders
(
mTableFrame
nullptr
nullptr
mRowGroup
mStartRow
nullptr
mTableWM
eLogicalSideBStart
!
ADJACENT
)
;
mStartRow
-
>
SetContinuousBCBorderWidth
(
eLogicalSideBStart
currentBorder
.
width
)
;
}
if
(
mCgAtEnd
&
&
mColGroup
)
{
currentBorder
=
CompareBorders
(
mTableFrame
mColGroup
nullptr
mRowGroup
mStartRow
nullptr
mTableWM
eLogicalSideBStart
!
ADJACENT
)
;
mColGroup
-
>
SetContinuousBCBorderWidth
(
eLogicalSideBStart
currentBorder
.
width
)
;
}
if
(
0
=
=
mColIndex
)
{
currentBorder
=
CompareBorders
(
mTableFrame
mColGroup
mStartCol
nullptr
nullptr
nullptr
mTableWM
eLogicalSideIStart
!
ADJACENT
)
;
mTableFrame
-
>
SetContinuousIStartBCBorderWidth
(
currentBorder
.
width
)
;
}
}
void
BCMapCellInfo
:
:
SetRowGroupIStartContBCBorder
(
)
{
BCCellBorder
currentBorder
;
if
(
mRgAtEnd
&
&
mRowGroup
)
{
currentBorder
=
CompareBorders
(
mTableFrame
mColGroup
mStartCol
mRowGroup
nullptr
nullptr
mTableWM
eLogicalSideIStart
!
ADJACENT
)
;
mRowGroup
-
>
SetContinuousBCBorderWidth
(
eLogicalSideIStart
currentBorder
.
width
)
;
}
}
void
BCMapCellInfo
:
:
SetRowGroupIEndContBCBorder
(
)
{
BCCellBorder
currentBorder
;
if
(
mRgAtEnd
&
&
mRowGroup
)
{
currentBorder
=
CompareBorders
(
mTableFrame
mColGroup
mEndCol
mRowGroup
nullptr
nullptr
mTableWM
eLogicalSideIEnd
ADJACENT
)
;
mRowGroup
-
>
SetContinuousBCBorderWidth
(
eLogicalSideIEnd
currentBorder
.
width
)
;
}
}
void
BCMapCellInfo
:
:
SetColumnBStartIEndContBCBorder
(
)
{
BCCellBorder
currentBorder
;
currentBorder
=
CompareBorders
(
mTableFrame
mCurrentColGroupFrame
mCurrentColFrame
mRowGroup
mStartRow
nullptr
mTableWM
eLogicalSideBStart
!
ADJACENT
)
;
mCurrentColFrame
-
>
SetContinuousBCBorderWidth
(
eLogicalSideBStart
currentBorder
.
width
)
;
if
(
mNumTableCols
=
=
GetCellEndColIndex
(
)
+
1
)
{
currentBorder
=
CompareBorders
(
mTableFrame
mCurrentColGroupFrame
mCurrentColFrame
nullptr
nullptr
nullptr
mTableWM
eLogicalSideIEnd
!
ADJACENT
)
;
}
else
{
currentBorder
=
CompareBorders
(
nullptr
mCurrentColGroupFrame
mCurrentColFrame
nullptr
nullptr
nullptr
mTableWM
eLogicalSideIEnd
!
ADJACENT
)
;
}
mCurrentColFrame
-
>
SetContinuousBCBorderWidth
(
eLogicalSideIEnd
currentBorder
.
width
)
;
}
void
BCMapCellInfo
:
:
SetColumnBEndContBCBorder
(
)
{
BCCellBorder
currentBorder
;
currentBorder
=
CompareBorders
(
mTableFrame
mCurrentColGroupFrame
mCurrentColFrame
mRowGroup
mEndRow
nullptr
mTableWM
eLogicalSideBEnd
ADJACENT
)
;
mCurrentColFrame
-
>
SetContinuousBCBorderWidth
(
eLogicalSideBEnd
currentBorder
.
width
)
;
}
void
BCMapCellInfo
:
:
SetColGroupBEndContBCBorder
(
)
{
BCCellBorder
currentBorder
;
if
(
mColGroup
)
{
currentBorder
=
CompareBorders
(
mTableFrame
mColGroup
nullptr
mRowGroup
mEndRow
nullptr
mTableWM
eLogicalSideBEnd
ADJACENT
)
;
mColGroup
-
>
SetContinuousBCBorderWidth
(
eLogicalSideBEnd
currentBorder
.
width
)
;
}
}
void
BCMapCellInfo
:
:
SetRowGroupBEndContBCBorder
(
)
{
BCCellBorder
currentBorder
;
if
(
mRowGroup
)
{
currentBorder
=
CompareBorders
(
mTableFrame
nullptr
nullptr
mRowGroup
mEndRow
nullptr
mTableWM
eLogicalSideBEnd
ADJACENT
)
;
mRowGroup
-
>
SetContinuousBCBorderWidth
(
eLogicalSideBEnd
currentBorder
.
width
)
;
}
}
void
BCMapCellInfo
:
:
SetInnerRowGroupBEndContBCBorder
(
const
nsIFrame
*
aNextRowGroup
nsTableRowFrame
*
aNextRow
)
{
BCCellBorder
currentBorder
adjacentBorder
;
const
nsIFrame
*
rowgroup
=
mRgAtEnd
?
mRowGroup
:
nullptr
;
currentBorder
=
CompareBorders
(
nullptr
nullptr
nullptr
rowgroup
mEndRow
nullptr
mTableWM
eLogicalSideBEnd
ADJACENT
)
;
adjacentBorder
=
CompareBorders
(
nullptr
nullptr
nullptr
aNextRowGroup
aNextRow
nullptr
mTableWM
eLogicalSideBStart
!
ADJACENT
)
;
currentBorder
=
CompareBorders
(
false
currentBorder
adjacentBorder
INLINE_DIR
)
;
if
(
aNextRow
)
{
aNextRow
-
>
SetContinuousBCBorderWidth
(
eLogicalSideBStart
currentBorder
.
width
)
;
}
if
(
mRgAtEnd
&
&
mRowGroup
)
{
mRowGroup
-
>
SetContinuousBCBorderWidth
(
eLogicalSideBEnd
currentBorder
.
width
)
;
}
}
void
BCMapCellInfo
:
:
SetRowIStartContBCBorder
(
)
{
if
(
mCurrentRowFrame
)
{
BCCellBorder
currentBorder
;
currentBorder
=
CompareBorders
(
mTableFrame
mColGroup
mStartCol
mRowGroup
mCurrentRowFrame
nullptr
mTableWM
eLogicalSideIStart
!
ADJACENT
)
;
mCurrentRowFrame
-
>
SetContinuousBCBorderWidth
(
eLogicalSideIStart
currentBorder
.
width
)
;
}
}
void
BCMapCellInfo
:
:
SetRowIEndContBCBorder
(
)
{
if
(
mCurrentRowFrame
)
{
BCCellBorder
currentBorder
;
currentBorder
=
CompareBorders
(
mTableFrame
mColGroup
mEndCol
mRowGroup
mCurrentRowFrame
nullptr
mTableWM
eLogicalSideIEnd
ADJACENT
)
;
mCurrentRowFrame
-
>
SetContinuousBCBorderWidth
(
eLogicalSideIEnd
currentBorder
.
width
)
;
}
}
void
BCMapCellInfo
:
:
SetTableBStartBorderWidth
(
BCPixelSize
aWidth
)
{
mTableBCData
-
>
mBStartBorderWidth
=
std
:
:
max
(
mTableBCData
-
>
mBStartBorderWidth
aWidth
)
;
}
void
BCMapCellInfo
:
:
SetTableIStartBorderWidth
(
int32_t
aRowB
BCPixelSize
aWidth
)
{
if
(
aRowB
=
=
0
)
{
mTableBCData
-
>
mIStartCellBorderWidth
=
aWidth
;
}
mTableBCData
-
>
mIStartBorderWidth
=
std
:
:
max
(
mTableBCData
-
>
mIStartBorderWidth
aWidth
)
;
}
void
BCMapCellInfo
:
:
SetTableIEndBorderWidth
(
int32_t
aRowB
BCPixelSize
aWidth
)
{
if
(
aRowB
=
=
0
)
{
mTableBCData
-
>
mIEndCellBorderWidth
=
aWidth
;
}
mTableBCData
-
>
mIEndBorderWidth
=
std
:
:
max
(
mTableBCData
-
>
mIEndBorderWidth
aWidth
)
;
}
void
BCMapCellInfo
:
:
SetIEndBorderWidths
(
BCPixelSize
aWidth
)
{
if
(
mCell
)
{
mCell
-
>
SetBorderWidth
(
eLogicalSideIEnd
std
:
:
max
(
aWidth
mCell
-
>
GetBorderWidth
(
eLogicalSideIEnd
)
)
)
;
}
if
(
mEndCol
)
{
BCPixelSize
half
=
BC_BORDER_START_HALF
(
aWidth
)
;
mEndCol
-
>
SetIEndBorderWidth
(
std
:
:
max
(
half
mEndCol
-
>
GetIEndBorderWidth
(
)
)
)
;
}
}
void
BCMapCellInfo
:
:
SetBEndBorderWidths
(
BCPixelSize
aWidth
)
{
if
(
mCell
)
{
mCell
-
>
SetBorderWidth
(
eLogicalSideBEnd
std
:
:
max
(
aWidth
mCell
-
>
GetBorderWidth
(
eLogicalSideBEnd
)
)
)
;
}
if
(
mEndRow
)
{
BCPixelSize
half
=
BC_BORDER_START_HALF
(
aWidth
)
;
mEndRow
-
>
SetBEndBCBorderWidth
(
std
:
:
max
(
half
mEndRow
-
>
GetBEndBCBorderWidth
(
)
)
)
;
}
}
void
BCMapCellInfo
:
:
SetBStartBorderWidths
(
BCPixelSize
aWidth
)
{
if
(
mCell
)
{
mCell
-
>
SetBorderWidth
(
eLogicalSideBStart
std
:
:
max
(
aWidth
mCell
-
>
GetBorderWidth
(
eLogicalSideBStart
)
)
)
;
}
if
(
mStartRow
)
{
BCPixelSize
half
=
BC_BORDER_END_HALF
(
aWidth
)
;
mStartRow
-
>
SetBStartBCBorderWidth
(
std
:
:
max
(
half
mStartRow
-
>
GetBStartBCBorderWidth
(
)
)
)
;
}
}
void
BCMapCellInfo
:
:
SetIStartBorderWidths
(
BCPixelSize
aWidth
)
{
if
(
mCell
)
{
mCell
-
>
SetBorderWidth
(
eLogicalSideIStart
std
:
:
max
(
aWidth
mCell
-
>
GetBorderWidth
(
eLogicalSideIStart
)
)
)
;
}
if
(
mStartCol
)
{
BCPixelSize
half
=
BC_BORDER_END_HALF
(
aWidth
)
;
mStartCol
-
>
SetIStartBorderWidth
(
std
:
:
max
(
half
mStartCol
-
>
GetIStartBorderWidth
(
)
)
)
;
}
}
void
BCMapCellInfo
:
:
SetTableBEndBorderWidth
(
BCPixelSize
aWidth
)
{
mTableBCData
-
>
mBEndBorderWidth
=
std
:
:
max
(
mTableBCData
-
>
mBEndBorderWidth
aWidth
)
;
}
void
BCMapCellInfo
:
:
SetColumn
(
int32_t
aColX
)
{
mCurrentColFrame
=
mTableFrame
-
>
GetColFrame
(
aColX
)
;
if
(
!
mCurrentColFrame
)
{
NS_ERROR
(
"
null
mCurrentColFrame
"
)
;
}
mCurrentColGroupFrame
=
static_cast
<
nsTableColGroupFrame
*
>
(
mCurrentColFrame
-
>
GetParent
(
)
)
;
if
(
!
mCurrentColGroupFrame
)
{
NS_ERROR
(
"
null
mCurrentColGroupFrame
"
)
;
}
}
void
BCMapCellInfo
:
:
IncrementRow
(
bool
aResetToBStartRowOfCell
)
{
mCurrentRowFrame
=
aResetToBStartRowOfCell
?
mStartRow
:
mCurrentRowFrame
-
>
GetNextRow
(
)
;
}
BCCellBorder
BCMapCellInfo
:
:
GetBStartEdgeBorder
(
)
{
return
CompareBorders
(
mTableFrame
mCurrentColGroupFrame
mCurrentColFrame
mRowGroup
mStartRow
mCell
mTableWM
eLogicalSideBStart
!
ADJACENT
)
;
}
BCCellBorder
BCMapCellInfo
:
:
GetBEndEdgeBorder
(
)
{
return
CompareBorders
(
mTableFrame
mCurrentColGroupFrame
mCurrentColFrame
mRowGroup
mEndRow
mCell
mTableWM
eLogicalSideBEnd
ADJACENT
)
;
}
BCCellBorder
BCMapCellInfo
:
:
GetIStartEdgeBorder
(
)
{
return
CompareBorders
(
mTableFrame
mColGroup
mStartCol
mRowGroup
mCurrentRowFrame
mCell
mTableWM
eLogicalSideIStart
!
ADJACENT
)
;
}
BCCellBorder
BCMapCellInfo
:
:
GetIEndEdgeBorder
(
)
{
return
CompareBorders
(
mTableFrame
mColGroup
mEndCol
mRowGroup
mCurrentRowFrame
mCell
mTableWM
eLogicalSideIEnd
ADJACENT
)
;
}
BCCellBorder
BCMapCellInfo
:
:
GetIEndInternalBorder
(
)
{
const
nsIFrame
*
cg
=
mCgAtEnd
?
mColGroup
:
nullptr
;
return
CompareBorders
(
nullptr
cg
mEndCol
nullptr
nullptr
mCell
mTableWM
eLogicalSideIEnd
ADJACENT
)
;
}
BCCellBorder
BCMapCellInfo
:
:
GetIStartInternalBorder
(
)
{
const
nsIFrame
*
cg
=
mCgAtStart
?
mColGroup
:
nullptr
;
return
CompareBorders
(
nullptr
cg
mStartCol
nullptr
nullptr
mCell
mTableWM
eLogicalSideIStart
!
ADJACENT
)
;
}
BCCellBorder
BCMapCellInfo
:
:
GetBEndInternalBorder
(
)
{
const
nsIFrame
*
rg
=
mRgAtEnd
?
mRowGroup
:
nullptr
;
return
CompareBorders
(
nullptr
nullptr
nullptr
rg
mEndRow
mCell
mTableWM
eLogicalSideBEnd
ADJACENT
)
;
}
BCCellBorder
BCMapCellInfo
:
:
GetBStartInternalBorder
(
)
{
const
nsIFrame
*
rg
=
mRgAtStart
?
mRowGroup
:
nullptr
;
return
CompareBorders
(
nullptr
nullptr
nullptr
rg
mStartRow
mCell
mTableWM
eLogicalSideBStart
!
ADJACENT
)
;
}
void
nsTableFrame
:
:
CalcBCBorders
(
)
{
NS_ASSERTION
(
IsBorderCollapse
(
)
"
calling
CalcBCBorders
on
separated
-
border
table
"
)
;
nsTableCellMap
*
tableCellMap
=
GetCellMap
(
)
;
if
(
!
tableCellMap
)
ABORT0
(
)
;
int32_t
numRows
=
GetRowCount
(
)
;
int32_t
numCols
=
GetColCount
(
)
;
if
(
!
numRows
|
|
!
numCols
)
return
;
BCPropertyData
*
propData
=
GetBCProperty
(
)
;
if
(
!
propData
)
ABORT0
(
)
;
TableArea
damageArea
(
propData
-
>
mDamageArea
)
;
ExpandBCDamageArea
(
damageArea
)
;
bool
tableBorderReset
[
4
]
;
for
(
uint32_t
sideX
=
0
;
sideX
<
ArrayLength
(
tableBorderReset
)
;
sideX
+
+
)
{
tableBorderReset
[
sideX
]
=
false
;
}
BCCellBorders
lastBlockDirBorders
(
damageArea
.
ColCount
(
)
+
1
damageArea
.
StartCol
(
)
)
;
if
(
!
lastBlockDirBorders
.
borders
)
ABORT0
(
)
;
BCCellBorder
lastBStartBorder
lastBEndBorder
;
BCCellBorders
lastBEndBorders
(
damageArea
.
ColCount
(
)
+
1
damageArea
.
StartCol
(
)
)
;
if
(
!
lastBEndBorders
.
borders
)
ABORT0
(
)
;
bool
startSeg
;
bool
gotRowBorder
=
false
;
BCMapCellInfo
info
(
this
)
ajaInfo
(
this
)
;
BCCellBorder
currentBorder
adjacentBorder
;
BCCorners
bStartCorners
(
damageArea
.
ColCount
(
)
+
1
damageArea
.
StartCol
(
)
)
;
if
(
!
bStartCorners
.
corners
)
ABORT0
(
)
;
BCCorners
bEndCorners
(
damageArea
.
ColCount
(
)
+
1
damageArea
.
StartCol
(
)
)
;
if
(
!
bEndCorners
.
corners
)
ABORT0
(
)
;
BCMapCellIterator
iter
(
this
damageArea
)
;
for
(
iter
.
First
(
info
)
;
!
iter
.
mAtEnd
;
iter
.
Next
(
info
)
)
{
if
(
iter
.
IsNewRow
(
)
)
{
gotRowBorder
=
false
;
lastBStartBorder
.
Reset
(
info
.
mRowIndex
info
.
mRowSpan
)
;
lastBEndBorder
.
Reset
(
info
.
GetCellEndRowIndex
(
)
+
1
info
.
mRowSpan
)
;
}
else
if
(
info
.
mColIndex
>
damageArea
.
StartCol
(
)
)
{
lastBEndBorder
=
lastBEndBorders
[
info
.
mColIndex
-
1
]
;
if
(
info
.
mRowIndex
>
(
lastBEndBorder
.
rowIndex
-
lastBEndBorder
.
rowSpan
)
)
{
lastBStartBorder
.
Reset
(
info
.
mRowIndex
info
.
mRowSpan
)
;
}
if
(
lastBEndBorder
.
rowIndex
>
(
info
.
GetCellEndRowIndex
(
)
+
1
)
)
{
lastBEndBorder
.
Reset
(
info
.
GetCellEndRowIndex
(
)
+
1
info
.
mRowSpan
)
;
}
}
if
(
0
=
=
info
.
mRowIndex
)
{
if
(
!
tableBorderReset
[
eLogicalSideBStart
]
)
{
propData
-
>
mBStartBorderWidth
=
0
;
tableBorderReset
[
eLogicalSideBStart
]
=
true
;
}
for
(
int32_t
colIdx
=
info
.
mColIndex
;
colIdx
<
=
info
.
GetCellEndColIndex
(
)
;
colIdx
+
+
)
{
info
.
SetColumn
(
colIdx
)
;
currentBorder
=
info
.
GetBStartEdgeBorder
(
)
;
BCCornerInfo
&
tlCorner
=
bStartCorners
[
colIdx
]
;
if
(
0
=
=
colIdx
)
{
tlCorner
.
Set
(
eLogicalSideIEnd
currentBorder
)
;
}
else
{
tlCorner
.
Update
(
eLogicalSideIEnd
currentBorder
)
;
tableCellMap
-
>
SetBCBorderCorner
(
eLogicalCornerBStartIStart
*
iter
.
mCellMap
0
0
colIdx
LogicalSide
(
tlCorner
.
ownerSide
)
tlCorner
.
subWidth
tlCorner
.
bevel
)
;
}
bStartCorners
[
colIdx
+
1
]
.
Set
(
eLogicalSideIStart
currentBorder
)
;
startSeg
=
SetInlineDirBorder
(
currentBorder
tlCorner
lastBStartBorder
)
;
tableCellMap
-
>
SetBCBorderEdge
(
eLogicalSideBStart
*
iter
.
mCellMap
0
0
colIdx
1
currentBorder
.
owner
currentBorder
.
width
startSeg
)
;
info
.
SetTableBStartBorderWidth
(
currentBorder
.
width
)
;
info
.
SetBStartBorderWidths
(
currentBorder
.
width
)
;
info
.
SetColumnBStartIEndContBCBorder
(
)
;
}
info
.
SetTableBStartIStartContBCBorder
(
)
;
}
else
{
if
(
info
.
mColIndex
>
0
)
{
BCData
&
data
=
info
.
mCellData
-
>
mData
;
if
(
!
data
.
IsBStartStart
(
)
)
{
LogicalSide
cornerSide
;
bool
bevel
;
data
.
GetCorner
(
cornerSide
bevel
)
;
if
(
IsBlock
(
cornerSide
)
)
{
data
.
SetBStartStart
(
true
)
;
}
}
}
}
if
(
0
=
=
info
.
mColIndex
)
{
if
(
!
tableBorderReset
[
eLogicalSideIStart
]
)
{
propData
-
>
mIStartBorderWidth
=
0
;
tableBorderReset
[
eLogicalSideIStart
]
=
true
;
}
info
.
mCurrentRowFrame
=
nullptr
;
for
(
int32_t
rowB
=
info
.
mRowIndex
;
rowB
<
=
info
.
GetCellEndRowIndex
(
)
;
rowB
+
+
)
{
info
.
IncrementRow
(
rowB
=
=
info
.
mRowIndex
)
;
currentBorder
=
info
.
GetIStartEdgeBorder
(
)
;
BCCornerInfo
&
tlCorner
=
(
0
=
=
rowB
)
?
bStartCorners
[
0
]
:
bEndCorners
[
0
]
;
tlCorner
.
Update
(
eLogicalSideBEnd
currentBorder
)
;
tableCellMap
-
>
SetBCBorderCorner
(
eLogicalCornerBStartIStart
*
iter
.
mCellMap
iter
.
mRowGroupStart
rowB
0
LogicalSide
(
tlCorner
.
ownerSide
)
tlCorner
.
subWidth
tlCorner
.
bevel
)
;
bEndCorners
[
0
]
.
Set
(
eLogicalSideBStart
currentBorder
)
;
startSeg
=
SetBorder
(
currentBorder
lastBlockDirBorders
[
0
]
)
;
tableCellMap
-
>
SetBCBorderEdge
(
eLogicalSideIStart
*
iter
.
mCellMap
iter
.
mRowGroupStart
rowB
info
.
mColIndex
1
currentBorder
.
owner
currentBorder
.
width
startSeg
)
;
info
.
SetTableIStartBorderWidth
(
rowB
currentBorder
.
width
)
;
info
.
SetIStartBorderWidths
(
currentBorder
.
width
)
;
info
.
SetRowIStartContBCBorder
(
)
;
}
info
.
SetRowGroupIStartContBCBorder
(
)
;
}
if
(
info
.
mNumTableCols
=
=
info
.
GetCellEndColIndex
(
)
+
1
)
{
if
(
!
tableBorderReset
[
eLogicalSideIEnd
]
)
{
propData
-
>
mIEndBorderWidth
=
0
;
tableBorderReset
[
eLogicalSideIEnd
]
=
true
;
}
info
.
mCurrentRowFrame
=
nullptr
;
for
(
int32_t
rowB
=
info
.
mRowIndex
;
rowB
<
=
info
.
GetCellEndRowIndex
(
)
;
rowB
+
+
)
{
info
.
IncrementRow
(
rowB
=
=
info
.
mRowIndex
)
;
currentBorder
=
info
.
GetIEndEdgeBorder
(
)
;
BCCornerInfo
&
trCorner
=
(
0
=
=
rowB
)
?
bStartCorners
[
info
.
GetCellEndColIndex
(
)
+
1
]
:
bEndCorners
[
info
.
GetCellEndColIndex
(
)
+
1
]
;
trCorner
.
Update
(
eLogicalSideBEnd
currentBorder
)
;
tableCellMap
-
>
SetBCBorderCorner
(
eLogicalCornerBStartIEnd
*
iter
.
mCellMap
iter
.
mRowGroupStart
rowB
info
.
GetCellEndColIndex
(
)
LogicalSide
(
trCorner
.
ownerSide
)
trCorner
.
subWidth
trCorner
.
bevel
)
;
BCCornerInfo
&
brCorner
=
bEndCorners
[
info
.
GetCellEndColIndex
(
)
+
1
]
;
brCorner
.
Set
(
eLogicalSideBStart
currentBorder
)
;
tableCellMap
-
>
SetBCBorderCorner
(
eLogicalCornerBEndIEnd
*
iter
.
mCellMap
iter
.
mRowGroupStart
rowB
info
.
GetCellEndColIndex
(
)
LogicalSide
(
brCorner
.
ownerSide
)
brCorner
.
subWidth
brCorner
.
bevel
)
;
startSeg
=
SetBorder
(
currentBorder
lastBlockDirBorders
[
info
.
GetCellEndColIndex
(
)
+
1
]
)
;
tableCellMap
-
>
SetBCBorderEdge
(
eLogicalSideIEnd
*
iter
.
mCellMap
iter
.
mRowGroupStart
rowB
info
.
GetCellEndColIndex
(
)
1
currentBorder
.
owner
currentBorder
.
width
startSeg
)
;
info
.
SetTableIEndBorderWidth
(
rowB
currentBorder
.
width
)
;
info
.
SetIEndBorderWidths
(
currentBorder
.
width
)
;
info
.
SetRowIEndContBCBorder
(
)
;
}
info
.
SetRowGroupIEndContBCBorder
(
)
;
}
else
{
int32_t
segLength
=
0
;
BCMapCellInfo
priorAjaInfo
(
this
)
;
for
(
int32_t
rowB
=
info
.
mRowIndex
;
rowB
<
=
info
.
GetCellEndRowIndex
(
)
;
rowB
+
=
segLength
)
{
iter
.
PeekIEnd
(
info
rowB
ajaInfo
)
;
currentBorder
=
info
.
GetIEndInternalBorder
(
)
;
adjacentBorder
=
ajaInfo
.
GetIStartInternalBorder
(
)
;
currentBorder
=
CompareBorders
(
!
CELL_CORNER
currentBorder
adjacentBorder
!
INLINE_DIR
)
;
segLength
=
std
:
:
max
(
1
ajaInfo
.
mRowIndex
+
ajaInfo
.
mRowSpan
-
rowB
)
;
segLength
=
std
:
:
min
(
segLength
info
.
mRowIndex
+
info
.
mRowSpan
-
rowB
)
;
startSeg
=
SetBorder
(
currentBorder
lastBlockDirBorders
[
info
.
GetCellEndColIndex
(
)
+
1
]
)
;
if
(
info
.
GetCellEndColIndex
(
)
<
damageArea
.
EndCol
(
)
&
&
rowB
>
=
damageArea
.
StartRow
(
)
&
&
rowB
<
damageArea
.
EndRow
(
)
)
{
tableCellMap
-
>
SetBCBorderEdge
(
eLogicalSideIEnd
*
iter
.
mCellMap
iter
.
mRowGroupStart
rowB
info
.
GetCellEndColIndex
(
)
segLength
currentBorder
.
owner
currentBorder
.
width
startSeg
)
;
info
.
SetIEndBorderWidths
(
currentBorder
.
width
)
;
ajaInfo
.
SetIStartBorderWidths
(
currentBorder
.
width
)
;
}
bool
hitsSpanOnIEnd
=
(
rowB
>
ajaInfo
.
mRowIndex
)
&
&
(
rowB
<
ajaInfo
.
mRowIndex
+
ajaInfo
.
mRowSpan
)
;
BCCornerInfo
*
trCorner
=
(
(
0
=
=
rowB
)
|
|
hitsSpanOnIEnd
)
?
&
bStartCorners
[
info
.
GetCellEndColIndex
(
)
+
1
]
:
&
bEndCorners
[
info
.
GetCellEndColIndex
(
)
+
1
]
;
trCorner
-
>
Update
(
eLogicalSideBEnd
currentBorder
)
;
if
(
rowB
!
=
info
.
mRowIndex
)
{
currentBorder
=
priorAjaInfo
.
GetBEndInternalBorder
(
)
;
adjacentBorder
=
ajaInfo
.
GetBStartInternalBorder
(
)
;
currentBorder
=
CompareBorders
(
!
CELL_CORNER
currentBorder
adjacentBorder
INLINE_DIR
)
;
trCorner
-
>
Update
(
eLogicalSideIEnd
currentBorder
)
;
}
if
(
info
.
GetCellEndColIndex
(
)
<
damageArea
.
EndCol
(
)
&
&
rowB
>
=
damageArea
.
StartRow
(
)
)
{
if
(
0
!
=
rowB
)
{
tableCellMap
-
>
SetBCBorderCorner
(
eLogicalCornerBStartIEnd
*
iter
.
mCellMap
iter
.
mRowGroupStart
rowB
info
.
GetCellEndColIndex
(
)
LogicalSide
(
trCorner
-
>
ownerSide
)
trCorner
-
>
subWidth
trCorner
-
>
bevel
)
;
}
for
(
int32_t
rX
=
rowB
+
1
;
rX
<
rowB
+
segLength
;
rX
+
+
)
{
tableCellMap
-
>
SetBCBorderCorner
(
eLogicalCornerBEndIEnd
*
iter
.
mCellMap
iter
.
mRowGroupStart
rX
info
.
GetCellEndColIndex
(
)
LogicalSide
(
trCorner
-
>
ownerSide
)
trCorner
-
>
subWidth
false
)
;
}
}
hitsSpanOnIEnd
=
(
rowB
+
segLength
<
ajaInfo
.
mRowIndex
+
ajaInfo
.
mRowSpan
)
;
BCCornerInfo
&
brCorner
=
(
hitsSpanOnIEnd
)
?
bStartCorners
[
info
.
GetCellEndColIndex
(
)
+
1
]
:
bEndCorners
[
info
.
GetCellEndColIndex
(
)
+
1
]
;
brCorner
.
Set
(
eLogicalSideBStart
currentBorder
)
;
priorAjaInfo
=
ajaInfo
;
}
}
for
(
int32_t
colIdx
=
info
.
mColIndex
+
1
;
colIdx
<
=
info
.
GetCellEndColIndex
(
)
;
colIdx
+
+
)
{
lastBlockDirBorders
[
colIdx
]
.
Reset
(
0
1
)
;
}
if
(
info
.
mNumTableRows
=
=
info
.
GetCellEndRowIndex
(
)
+
1
)
{
if
(
!
tableBorderReset
[
eLogicalSideBEnd
]
)
{
propData
-
>
mBEndBorderWidth
=
0
;
tableBorderReset
[
eLogicalSideBEnd
]
=
true
;
}
for
(
int32_t
colIdx
=
info
.
mColIndex
;
colIdx
<
=
info
.
GetCellEndColIndex
(
)
;
colIdx
+
+
)
{
info
.
SetColumn
(
colIdx
)
;
currentBorder
=
info
.
GetBEndEdgeBorder
(
)
;
BCCornerInfo
&
blCorner
=
bEndCorners
[
colIdx
]
;
blCorner
.
Update
(
eLogicalSideIEnd
currentBorder
)
;
tableCellMap
-
>
SetBCBorderCorner
(
eLogicalCornerBEndIStart
*
iter
.
mCellMap
iter
.
mRowGroupStart
info
.
GetCellEndRowIndex
(
)
colIdx
LogicalSide
(
blCorner
.
ownerSide
)
blCorner
.
subWidth
blCorner
.
bevel
)
;
BCCornerInfo
&
brCorner
=
bEndCorners
[
colIdx
+
1
]
;
brCorner
.
Update
(
eLogicalSideIStart
currentBorder
)
;
if
(
info
.
mNumTableCols
=
=
colIdx
+
1
)
{
tableCellMap
-
>
SetBCBorderCorner
(
eLogicalCornerBEndIEnd
*
iter
.
mCellMap
iter
.
mRowGroupStart
info
.
GetCellEndRowIndex
(
)
colIdx
LogicalSide
(
brCorner
.
ownerSide
)
brCorner
.
subWidth
brCorner
.
bevel
true
)
;
}
startSeg
=
SetInlineDirBorder
(
currentBorder
blCorner
lastBEndBorder
)
;
if
(
!
startSeg
)
{
startSeg
=
(
lastBEndBorder
.
rowIndex
!
=
(
info
.
GetCellEndRowIndex
(
)
+
1
)
)
;
}
tableCellMap
-
>
SetBCBorderEdge
(
eLogicalSideBEnd
*
iter
.
mCellMap
iter
.
mRowGroupStart
info
.
GetCellEndRowIndex
(
)
colIdx
1
currentBorder
.
owner
currentBorder
.
width
startSeg
)
;
lastBEndBorder
.
rowIndex
=
info
.
GetCellEndRowIndex
(
)
+
1
;
lastBEndBorder
.
rowSpan
=
info
.
mRowSpan
;
lastBEndBorders
[
colIdx
]
=
lastBEndBorder
;
info
.
SetBEndBorderWidths
(
currentBorder
.
width
)
;
info
.
SetTableBEndBorderWidth
(
currentBorder
.
width
)
;
info
.
SetColumnBEndContBCBorder
(
)
;
}
info
.
SetRowGroupBEndContBCBorder
(
)
;
info
.
SetColGroupBEndContBCBorder
(
)
;
}
else
{
int32_t
segLength
=
0
;
for
(
int32_t
colIdx
=
info
.
mColIndex
;
colIdx
<
=
info
.
GetCellEndColIndex
(
)
;
colIdx
+
=
segLength
)
{
iter
.
PeekBEnd
(
info
colIdx
ajaInfo
)
;
currentBorder
=
info
.
GetBEndInternalBorder
(
)
;
adjacentBorder
=
ajaInfo
.
GetBStartInternalBorder
(
)
;
currentBorder
=
CompareBorders
(
!
CELL_CORNER
currentBorder
adjacentBorder
INLINE_DIR
)
;
segLength
=
std
:
:
max
(
1
ajaInfo
.
mColIndex
+
ajaInfo
.
mColSpan
-
colIdx
)
;
segLength
=
std
:
:
min
(
segLength
info
.
mColIndex
+
info
.
mColSpan
-
colIdx
)
;
BCCornerInfo
&
blCorner
=
bEndCorners
[
colIdx
]
;
bool
hitsSpanBelow
=
(
colIdx
>
ajaInfo
.
mColIndex
)
&
&
(
colIdx
<
ajaInfo
.
mColIndex
+
ajaInfo
.
mColSpan
)
;
bool
update
=
true
;
if
(
colIdx
=
=
info
.
mColIndex
&
&
colIdx
>
damageArea
.
StartCol
(
)
)
{
int32_t
prevRowIndex
=
lastBEndBorders
[
colIdx
-
1
]
.
rowIndex
;
if
(
prevRowIndex
>
info
.
GetCellEndRowIndex
(
)
+
1
)
{
update
=
false
;
}
else
if
(
prevRowIndex
<
info
.
GetCellEndRowIndex
(
)
+
1
)
{
bStartCorners
[
colIdx
]
=
blCorner
;
blCorner
.
Set
(
eLogicalSideIEnd
currentBorder
)
;
update
=
false
;
}
}
if
(
update
)
{
blCorner
.
Update
(
eLogicalSideIEnd
currentBorder
)
;
}
if
(
info
.
GetCellEndRowIndex
(
)
<
damageArea
.
EndRow
(
)
&
&
colIdx
>
=
damageArea
.
StartCol
(
)
)
{
if
(
hitsSpanBelow
)
{
tableCellMap
-
>
SetBCBorderCorner
(
eLogicalCornerBEndIStart
*
iter
.
mCellMap
iter
.
mRowGroupStart
info
.
GetCellEndRowIndex
(
)
colIdx
LogicalSide
(
blCorner
.
ownerSide
)
blCorner
.
subWidth
blCorner
.
bevel
)
;
}
for
(
int32_t
c
=
colIdx
+
1
;
c
<
colIdx
+
segLength
;
c
+
+
)
{
BCCornerInfo
&
corner
=
bEndCorners
[
c
]
;
corner
.
Set
(
eLogicalSideIEnd
currentBorder
)
;
tableCellMap
-
>
SetBCBorderCorner
(
eLogicalCornerBEndIStart
*
iter
.
mCellMap
iter
.
mRowGroupStart
info
.
GetCellEndRowIndex
(
)
c
LogicalSide
(
corner
.
ownerSide
)
corner
.
subWidth
false
)
;
}
}
startSeg
=
SetInlineDirBorder
(
currentBorder
blCorner
lastBEndBorder
)
;
if
(
!
startSeg
)
{
startSeg
=
(
lastBEndBorder
.
rowIndex
!
=
info
.
GetCellEndRowIndex
(
)
+
1
)
;
}
lastBEndBorder
.
rowIndex
=
info
.
GetCellEndRowIndex
(
)
+
1
;
lastBEndBorder
.
rowSpan
=
info
.
mRowSpan
;
for
(
int32_t
c
=
colIdx
;
c
<
colIdx
+
segLength
;
c
+
+
)
{
lastBEndBorders
[
c
]
=
lastBEndBorder
;
}
if
(
info
.
GetCellEndRowIndex
(
)
<
damageArea
.
EndRow
(
)
&
&
colIdx
>
=
damageArea
.
StartCol
(
)
&
&
colIdx
<
damageArea
.
EndCol
(
)
)
{
tableCellMap
-
>
SetBCBorderEdge
(
eLogicalSideBEnd
*
iter
.
mCellMap
iter
.
mRowGroupStart
info
.
GetCellEndRowIndex
(
)
colIdx
segLength
currentBorder
.
owner
currentBorder
.
width
startSeg
)
;
info
.
SetBEndBorderWidths
(
currentBorder
.
width
)
;
ajaInfo
.
SetBStartBorderWidths
(
currentBorder
.
width
)
;
}
BCCornerInfo
&
brCorner
=
bEndCorners
[
colIdx
+
segLength
]
;
brCorner
.
Update
(
eLogicalSideIStart
currentBorder
)
;
}
if
(
!
gotRowBorder
&
&
1
=
=
info
.
mRowSpan
&
&
(
ajaInfo
.
mStartRow
|
|
info
.
mRgAtEnd
)
)
{
const
nsIFrame
*
nextRowGroup
=
ajaInfo
.
mRgAtStart
?
ajaInfo
.
mRowGroup
:
nullptr
;
info
.
SetInnerRowGroupBEndContBCBorder
(
nextRowGroup
ajaInfo
.
mStartRow
)
;
gotRowBorder
=
true
;
}
}
const
auto
nextColIndex
=
info
.
GetCellEndColIndex
(
)
+
1
;
if
(
(
info
.
mNumTableCols
!
=
nextColIndex
)
&
&
(
lastBEndBorders
[
nextColIndex
]
.
rowSpan
>
1
)
&
&
(
lastBEndBorders
[
nextColIndex
]
.
rowIndex
=
=
info
.
GetCellEndRowIndex
(
)
+
1
)
)
{
BCCornerInfo
&
corner
=
bEndCorners
[
nextColIndex
]
;
if
(
!
IsBlock
(
LogicalSide
(
corner
.
ownerSide
)
)
)
{
BCCellBorder
&
thisBorder
=
lastBEndBorder
;
BCCellBorder
&
nextBorder
=
lastBEndBorders
[
info
.
mColIndex
+
1
]
;
if
(
(
thisBorder
.
color
=
=
nextBorder
.
color
)
&
&
(
thisBorder
.
width
=
=
nextBorder
.
width
)
&
&
(
thisBorder
.
style
=
=
nextBorder
.
style
)
)
{
if
(
iter
.
mCellMap
)
{
tableCellMap
-
>
ResetBStartStart
(
eLogicalSideBEnd
*
iter
.
mCellMap
iter
.
mRowGroupStart
info
.
GetCellEndRowIndex
(
)
nextColIndex
)
;
}
}
}
}
}
SetNeedToCalcBCBorders
(
false
)
;
propData
-
>
mDamageArea
=
TableArea
(
0
0
0
0
)
;
#
ifdef
DEBUG_TABLE_CELLMAP
mCellMap
-
>
Dump
(
)
;
#
endif
}
class
BCPaintBorderIterator
;
struct
BCBorderParameters
{
StyleBorderStyle
mBorderStyle
;
nscolor
mBorderColor
;
nsRect
mBorderRect
;
int32_t
mAppUnitsPerDevPixel
;
mozilla
:
:
Side
mStartBevelSide
;
nscoord
mStartBevelOffset
;
mozilla
:
:
Side
mEndBevelSide
;
nscoord
mEndBevelOffset
;
bool
mBackfaceIsVisible
;
bool
NeedToBevel
(
)
const
{
if
(
!
mStartBevelOffset
&
&
!
mEndBevelOffset
)
{
return
false
;
}
if
(
mBorderStyle
=
=
StyleBorderStyle
:
:
Dashed
|
|
mBorderStyle
=
=
StyleBorderStyle
:
:
Dotted
)
{
return
false
;
}
return
true
;
}
}
;
struct
BCBlockDirSeg
{
BCBlockDirSeg
(
)
;
void
Start
(
BCPaintBorderIterator
&
aIter
BCBorderOwner
aBorderOwner
BCPixelSize
aBlockSegISize
BCPixelSize
aInlineSegBSize
)
;
void
Initialize
(
BCPaintBorderIterator
&
aIter
)
;
void
GetBEndCorner
(
BCPaintBorderIterator
&
aIter
BCPixelSize
aInlineSegBSize
)
;
Maybe
<
BCBorderParameters
>
BuildBorderParameters
(
BCPaintBorderIterator
&
aIter
BCPixelSize
aInlineSegBSize
)
;
void
Paint
(
BCPaintBorderIterator
&
aIter
DrawTarget
&
aDrawTarget
BCPixelSize
aInlineSegBSize
)
;
void
CreateWebRenderCommands
(
BCPaintBorderIterator
&
aIter
BCPixelSize
aInlineSegBSize
wr
:
:
DisplayListBuilder
&
aBuilder
const
layers
:
:
StackingContextHelper
&
aSc
const
nsPoint
&
aPt
)
;
void
AdvanceOffsetB
(
)
;
void
IncludeCurrentBorder
(
BCPaintBorderIterator
&
aIter
)
;
union
{
nsTableColFrame
*
mCol
;
int32_t
mColWidth
;
}
;
nscoord
mOffsetI
;
nscoord
mOffsetB
;
nscoord
mLength
;
BCPixelSize
mWidth
;
nsTableCellFrame
*
mAjaCell
;
nsTableCellFrame
*
mFirstCell
;
nsTableRowGroupFrame
*
mFirstRowGroup
;
nsTableRowFrame
*
mFirstRow
;
nsTableCellFrame
*
mLastCell
;
uint8_t
mOwner
;
LogicalSide
mBStartBevelSide
;
nscoord
mBStartBevelOffset
;
BCPixelSize
mBEndInlineSegBSize
;
nscoord
mBEndOffset
;
bool
mIsBEndBevel
;
}
;
struct
BCInlineDirSeg
{
BCInlineDirSeg
(
)
;
void
Start
(
BCPaintBorderIterator
&
aIter
BCBorderOwner
aBorderOwner
BCPixelSize
aBEndBlockSegISize
BCPixelSize
aInlineSegBSize
)
;
void
GetIEndCorner
(
BCPaintBorderIterator
&
aIter
BCPixelSize
aIStartSegISize
)
;
void
AdvanceOffsetI
(
)
;
void
IncludeCurrentBorder
(
BCPaintBorderIterator
&
aIter
)
;
Maybe
<
BCBorderParameters
>
BuildBorderParameters
(
BCPaintBorderIterator
&
aIter
)
;
void
Paint
(
BCPaintBorderIterator
&
aIter
DrawTarget
&
aDrawTarget
)
;
void
CreateWebRenderCommands
(
BCPaintBorderIterator
&
aIter
wr
:
:
DisplayListBuilder
&
aBuilder
const
layers
:
:
StackingContextHelper
&
aSc
const
nsPoint
&
aPt
)
;
nscoord
mOffsetI
;
nscoord
mOffsetB
;
nscoord
mLength
;
BCPixelSize
mWidth
;
nscoord
mIStartBevelOffset
;
LogicalSide
mIStartBevelSide
;
bool
mIsIEndBevel
;
nscoord
mIEndBevelOffset
;
LogicalSide
mIEndBevelSide
;
nscoord
mEndOffset
;
uint8_t
mOwner
;
nsTableCellFrame
*
mFirstCell
;
nsTableCellFrame
*
mAjaCell
;
}
;
struct
BCPaintData
{
explicit
BCPaintData
(
DrawTarget
&
aDrawTarget
)
:
mDrawTarget
(
aDrawTarget
)
{
}
DrawTarget
&
mDrawTarget
;
}
;
struct
BCCreateWebRenderCommandsData
{
BCCreateWebRenderCommandsData
(
wr
:
:
DisplayListBuilder
&
aBuilder
const
layers
:
:
StackingContextHelper
&
aSc
const
nsPoint
&
aOffsetToReferenceFrame
)
:
mBuilder
(
aBuilder
)
mSc
(
aSc
)
mOffsetToReferenceFrame
(
aOffsetToReferenceFrame
)
{
}
wr
:
:
DisplayListBuilder
&
mBuilder
;
const
layers
:
:
StackingContextHelper
&
mSc
;
const
nsPoint
&
mOffsetToReferenceFrame
;
}
;
struct
BCPaintBorderAction
{
explicit
BCPaintBorderAction
(
DrawTarget
&
aDrawTarget
)
:
mMode
(
Mode
:
:
PAINT
)
mPaintData
(
aDrawTarget
)
{
}
BCPaintBorderAction
(
wr
:
:
DisplayListBuilder
&
aBuilder
const
layers
:
:
StackingContextHelper
&
aSc
const
nsPoint
&
aOffsetToReferenceFrame
)
:
mMode
(
Mode
:
:
CREATE_WEBRENDER_COMMANDS
)
mCreateWebRenderCommandsData
(
aBuilder
aSc
aOffsetToReferenceFrame
)
{
}
~
BCPaintBorderAction
(
)
{
if
(
mMode
=
=
Mode
:
:
CREATE_WEBRENDER_COMMANDS
)
{
mCreateWebRenderCommandsData
.
~
BCCreateWebRenderCommandsData
(
)
;
}
}
enum
class
Mode
{
PAINT
CREATE_WEBRENDER_COMMANDS
}
;
Mode
mMode
;
union
{
BCPaintData
mPaintData
;
BCCreateWebRenderCommandsData
mCreateWebRenderCommandsData
;
}
;
}
;
class
BCPaintBorderIterator
{
public
:
explicit
BCPaintBorderIterator
(
nsTableFrame
*
aTable
)
;
~
BCPaintBorderIterator
(
)
{
if
(
mBlockDirInfo
)
{
delete
[
]
mBlockDirInfo
;
}
}
void
Reset
(
)
;
bool
SetDamageArea
(
const
nsRect
&
aDamageRect
)
;
void
First
(
)
;
void
Next
(
)
;
void
AccumulateOrDoActionInlineDirSegment
(
BCPaintBorderAction
&
aAction
)
;
void
AccumulateOrDoActionBlockDirSegment
(
BCPaintBorderAction
&
aAction
)
;
void
ResetVerInfo
(
)
;
void
StoreColumnWidth
(
int32_t
aIndex
)
;
bool
BlockDirSegmentOwnsCorner
(
)
;
nsTableFrame
*
mTable
;
nsTableFrame
*
mTableFirstInFlow
;
nsTableCellMap
*
mTableCellMap
;
nsCellMap
*
mCellMap
;
WritingMode
mTableWM
;
nsTableFrame
:
:
RowGroupArray
mRowGroups
;
nsTableRowGroupFrame
*
mPrevRg
;
nsTableRowGroupFrame
*
mRg
;
bool
mIsRepeatedHeader
;
bool
mIsRepeatedFooter
;
nsTableRowGroupFrame
*
mStartRg
;
int32_t
mRgIndex
;
int32_t
mFifRgFirstRowIndex
;
int32_t
mRgFirstRowIndex
;
int32_t
mRgLastRowIndex
;
int32_t
mNumTableRows
;
int32_t
mNumTableCols
;
int32_t
mColIndex
;
int32_t
mRowIndex
;
int32_t
mRepeatedHeaderRowIndex
;
bool
mIsNewRow
;
bool
mAtEnd
;
nsTableRowFrame
*
mPrevRow
;
nsTableRowFrame
*
mRow
;
nsTableRowFrame
*
mStartRow
;
nsTableCellFrame
*
mPrevCell
;
nsTableCellFrame
*
mCell
;
BCCellData
*
mPrevCellData
;
BCCellData
*
mCellData
;
BCData
*
mBCData
;
bool
IsTableBStartMost
(
)
{
return
(
mRowIndex
=
=
0
)
&
&
!
mTable
-
>
GetPrevInFlow
(
)
;
}
bool
IsTableIEndMost
(
)
{
return
(
mColIndex
>
=
mNumTableCols
)
;
}
bool
IsTableBEndMost
(
)
{
return
(
mRowIndex
>
=
mNumTableRows
)
&
&
!
mTable
-
>
GetNextInFlow
(
)
;
}
bool
IsTableIStartMost
(
)
{
return
(
mColIndex
=
=
0
)
;
}
bool
IsDamageAreaBStartMost
(
)
const
{
return
mRowIndex
=
=
mDamageArea
.
StartRow
(
)
;
}
bool
IsDamageAreaIEndMost
(
)
const
{
return
mColIndex
>
=
mDamageArea
.
EndCol
(
)
;
}
bool
IsDamageAreaBEndMost
(
)
const
{
return
mRowIndex
>
=
mDamageArea
.
EndRow
(
)
;
}
bool
IsDamageAreaIStartMost
(
)
const
{
return
mColIndex
=
=
mDamageArea
.
StartCol
(
)
;
}
int32_t
GetRelativeColIndex
(
)
const
{
return
mColIndex
-
mDamageArea
.
StartCol
(
)
;
}
TableArea
mDamageArea
;
bool
IsAfterRepeatedHeader
(
)
{
return
!
mIsRepeatedHeader
&
&
(
mRowIndex
=
=
(
mRepeatedHeaderRowIndex
+
1
)
)
;
}
bool
StartRepeatedFooter
(
)
const
{
return
mIsRepeatedFooter
&
&
mRowIndex
=
=
mRgFirstRowIndex
&
&
mRowIndex
!
=
mDamageArea
.
StartRow
(
)
;
}
nscoord
mInitialOffsetI
;
nscoord
mInitialOffsetB
;
nscoord
mNextOffsetB
;
BCBlockDirSeg
*
mBlockDirInfo
;
BCInlineDirSeg
mInlineSeg
;
BCPixelSize
mPrevInlineSegBSize
;
private
:
bool
SetNewRow
(
nsTableRowFrame
*
aRow
=
nullptr
)
;
bool
SetNewRowGroup
(
)
;
void
SetNewData
(
int32_t
aRowIndex
int32_t
aColIndex
)
;
}
;
BCPaintBorderIterator
:
:
BCPaintBorderIterator
(
nsTableFrame
*
aTable
)
:
mTable
(
aTable
)
mTableFirstInFlow
(
static_cast
<
nsTableFrame
*
>
(
aTable
-
>
FirstInFlow
(
)
)
)
mTableCellMap
(
aTable
-
>
GetCellMap
(
)
)
mCellMap
(
nullptr
)
mTableWM
(
aTable
-
>
Style
(
)
)
mPrevRg
(
nullptr
)
mRg
(
nullptr
)
mIsRepeatedHeader
(
false
)
mIsRepeatedFooter
(
false
)
mStartRg
(
nullptr
)
mRgIndex
(
0
)
mFifRgFirstRowIndex
(
0
)
mRgFirstRowIndex
(
0
)
mRgLastRowIndex
(
0
)
mColIndex
(
0
)
mRowIndex
(
0
)
mIsNewRow
(
false
)
mAtEnd
(
false
)
mPrevRow
(
nullptr
)
mRow
(
nullptr
)
mStartRow
(
nullptr
)
mPrevCell
(
nullptr
)
mCell
(
nullptr
)
mPrevCellData
(
nullptr
)
mCellData
(
nullptr
)
mBCData
(
nullptr
)
mInitialOffsetI
(
0
)
mNextOffsetB
(
0
)
mPrevInlineSegBSize
(
0
)
{
mBlockDirInfo
=
nullptr
;
LogicalMargin
childAreaOffset
=
mTable
-
>
GetChildAreaOffset
(
mTableWM
nullptr
)
;
mInitialOffsetB
=
mTable
-
>
GetPrevInFlow
(
)
?
0
:
childAreaOffset
.
BStart
(
mTableWM
)
;
mNumTableRows
=
mTable
-
>
GetRowCount
(
)
;
mNumTableCols
=
mTable
-
>
GetColCount
(
)
;
mTable
-
>
OrderRowGroups
(
mRowGroups
)
;
mRepeatedHeaderRowIndex
=
-
99
;
}
bool
BCPaintBorderIterator
:
:
SetDamageArea
(
const
nsRect
&
aDirtyRect
)
{
nsSize
containerSize
=
mTable
-
>
GetSize
(
)
;
LogicalRect
dirtyRect
(
mTableWM
aDirtyRect
containerSize
)
;
uint32_t
startRowIndex
endRowIndex
startColIndex
endColIndex
;
startRowIndex
=
endRowIndex
=
startColIndex
=
endColIndex
=
0
;
bool
done
=
false
;
bool
haveIntersect
=
false
;
nscoord
rowB
=
mInitialOffsetB
;
nsPresContext
*
presContext
=
mTable
-
>
PresContext
(
)
;
for
(
uint32_t
rgIdx
=
0
;
rgIdx
<
mRowGroups
.
Length
(
)
&
&
!
done
;
rgIdx
+
+
)
{
nsTableRowGroupFrame
*
rgFrame
=
mRowGroups
[
rgIdx
]
;
for
(
nsTableRowFrame
*
rowFrame
=
rgFrame
-
>
GetFirstRow
(
)
;
rowFrame
;
rowFrame
=
rowFrame
-
>
GetNextRow
(
)
)
{
nscoord
rowBSize
=
rowFrame
-
>
BSize
(
mTableWM
)
;
if
(
haveIntersect
)
{
nscoord
borderHalf
=
mTable
-
>
GetPrevInFlow
(
)
?
0
:
presContext
-
>
DevPixelsToAppUnits
(
rowFrame
-
>
GetBStartBCBorderWidth
(
)
+
1
)
;
if
(
dirtyRect
.
BEnd
(
mTableWM
)
>
=
rowB
-
borderHalf
)
{
nsTableRowFrame
*
fifRow
=
static_cast
<
nsTableRowFrame
*
>
(
rowFrame
-
>
FirstInFlow
(
)
)
;
endRowIndex
=
fifRow
-
>
GetRowIndex
(
)
;
}
else
done
=
true
;
}
else
{
nscoord
borderHalf
=
mTable
-
>
GetNextInFlow
(
)
?
0
:
presContext
-
>
DevPixelsToAppUnits
(
rowFrame
-
>
GetBEndBCBorderWidth
(
)
+
1
)
;
if
(
rowB
+
rowBSize
+
borderHalf
>
=
dirtyRect
.
BStart
(
mTableWM
)
)
{
mStartRg
=
rgFrame
;
mStartRow
=
rowFrame
;
nsTableRowFrame
*
fifRow
=
static_cast
<
nsTableRowFrame
*
>
(
rowFrame
-
>
FirstInFlow
(
)
)
;
startRowIndex
=
endRowIndex
=
fifRow
-
>
GetRowIndex
(
)
;
haveIntersect
=
true
;
}
else
{
mInitialOffsetB
+
=
rowBSize
;
}
}
rowB
+
=
rowBSize
;
}
}
mNextOffsetB
=
mInitialOffsetB
;
if
(
!
haveIntersect
)
return
false
;
haveIntersect
=
false
;
if
(
0
=
=
mNumTableCols
)
return
false
;
LogicalMargin
childAreaOffset
=
mTable
-
>
GetChildAreaOffset
(
mTableWM
nullptr
)
;
mInitialOffsetI
=
childAreaOffset
.
IStart
(
mTableWM
)
;
nscoord
x
=
0
;
int32_t
colIdx
;
for
(
colIdx
=
0
;
colIdx
!
=
mNumTableCols
;
colIdx
+
+
)
{
nsTableColFrame
*
colFrame
=
mTableFirstInFlow
-
>
GetColFrame
(
colIdx
)
;
if
(
!
colFrame
)
ABORT1
(
false
)
;
nscoord
colISize
=
colFrame
-
>
ISize
(
mTableWM
)
;
if
(
haveIntersect
)
{
nscoord
iStartBorderHalf
=
presContext
-
>
DevPixelsToAppUnits
(
colFrame
-
>
GetIStartBorderWidth
(
)
+
1
)
;
if
(
dirtyRect
.
IEnd
(
mTableWM
)
>
=
x
-
iStartBorderHalf
)
{
endColIndex
=
colIdx
;
}
else
break
;
}
else
{
nscoord
iEndBorderHalf
=
presContext
-
>
DevPixelsToAppUnits
(
colFrame
-
>
GetIEndBorderWidth
(
)
+
1
)
;
if
(
x
+
colISize
+
iEndBorderHalf
>
=
dirtyRect
.
IStart
(
mTableWM
)
)
{
startColIndex
=
endColIndex
=
colIdx
;
haveIntersect
=
true
;
}
else
{
mInitialOffsetI
+
=
colISize
;
}
}
x
+
=
colISize
;
}
if
(
!
haveIntersect
)
return
false
;
mDamageArea
=
TableArea
(
startColIndex
startRowIndex
1
+
DeprecatedAbs
<
int32_t
>
(
endColIndex
-
startColIndex
)
1
+
endRowIndex
-
startRowIndex
)
;
Reset
(
)
;
mBlockDirInfo
=
new
BCBlockDirSeg
[
mDamageArea
.
ColCount
(
)
+
1
]
;
if
(
!
mBlockDirInfo
)
return
false
;
return
true
;
}
void
BCPaintBorderIterator
:
:
Reset
(
)
{
mAtEnd
=
true
;
mRg
=
mStartRg
;
mPrevRow
=
nullptr
;
mRow
=
mStartRow
;
mRowIndex
=
0
;
mColIndex
=
0
;
mRgIndex
=
-
1
;
mPrevCell
=
nullptr
;
mCell
=
nullptr
;
mPrevCellData
=
nullptr
;
mCellData
=
nullptr
;
mBCData
=
nullptr
;
ResetVerInfo
(
)
;
}
void
BCPaintBorderIterator
:
:
SetNewData
(
int32_t
aY
int32_t
aX
)
{
if
(
!
mTableCellMap
|
|
!
mTableCellMap
-
>
mBCInfo
)
ABORT0
(
)
;
mColIndex
=
aX
;
mRowIndex
=
aY
;
mPrevCellData
=
mCellData
;
if
(
IsTableIEndMost
(
)
&
&
IsTableBEndMost
(
)
)
{
mCell
=
nullptr
;
mBCData
=
&
mTableCellMap
-
>
mBCInfo
-
>
mBEndIEndCorner
;
}
else
if
(
IsTableIEndMost
(
)
)
{
mCellData
=
nullptr
;
mBCData
=
&
mTableCellMap
-
>
mBCInfo
-
>
mIEndBorders
.
ElementAt
(
aY
)
;
}
else
if
(
IsTableBEndMost
(
)
)
{
mCellData
=
nullptr
;
mBCData
=
&
mTableCellMap
-
>
mBCInfo
-
>
mBEndBorders
.
ElementAt
(
aX
)
;
}
else
{
if
(
uint32_t
(
mRowIndex
-
mFifRgFirstRowIndex
)
<
mCellMap
-
>
mRows
.
Length
(
)
)
{
mBCData
=
nullptr
;
mCellData
=
(
BCCellData
*
)
mCellMap
-
>
mRows
[
mRowIndex
-
mFifRgFirstRowIndex
]
.
SafeElementAt
(
mColIndex
)
;
if
(
mCellData
)
{
mBCData
=
&
mCellData
-
>
mData
;
if
(
!
mCellData
-
>
IsOrig
(
)
)
{
if
(
mCellData
-
>
IsRowSpan
(
)
)
{
aY
-
=
mCellData
-
>
GetRowSpanOffset
(
)
;
}
if
(
mCellData
-
>
IsColSpan
(
)
)
{
aX
-
=
mCellData
-
>
GetColSpanOffset
(
)
;
}
if
(
(
aX
>
=
0
)
&
&
(
aY
>
=
0
)
)
{
mCellData
=
(
BCCellData
*
)
mCellMap
-
>
mRows
[
aY
-
mFifRgFirstRowIndex
]
[
aX
]
;
}
}
if
(
mCellData
-
>
IsOrig
(
)
)
{
mPrevCell
=
mCell
;
mCell
=
mCellData
-
>
GetCellFrame
(
)
;
}
}
}
}
}
bool
BCPaintBorderIterator
:
:
SetNewRow
(
nsTableRowFrame
*
aRow
)
{
mPrevRow
=
mRow
;
mRow
=
(
aRow
)
?
aRow
:
mRow
-
>
GetNextRow
(
)
;
if
(
mRow
)
{
mIsNewRow
=
true
;
mRowIndex
=
mRow
-
>
GetRowIndex
(
)
;
mColIndex
=
mDamageArea
.
StartCol
(
)
;
mPrevInlineSegBSize
=
0
;
if
(
mIsRepeatedHeader
)
{
mRepeatedHeaderRowIndex
=
mRowIndex
;
}
}
else
{
mAtEnd
=
true
;
}
return
!
mAtEnd
;
}
bool
BCPaintBorderIterator
:
:
SetNewRowGroup
(
)
{
mRgIndex
+
+
;
mIsRepeatedHeader
=
false
;
mIsRepeatedFooter
=
false
;
NS_ASSERTION
(
mRgIndex
>
=
0
"
mRgIndex
out
of
bounds
"
)
;
if
(
uint32_t
(
mRgIndex
)
<
mRowGroups
.
Length
(
)
)
{
mPrevRg
=
mRg
;
mRg
=
mRowGroups
[
mRgIndex
]
;
nsTableRowGroupFrame
*
fifRg
=
static_cast
<
nsTableRowGroupFrame
*
>
(
mRg
-
>
FirstInFlow
(
)
)
;
mFifRgFirstRowIndex
=
fifRg
-
>
GetStartRowIndex
(
)
;
mRgFirstRowIndex
=
mRg
-
>
GetStartRowIndex
(
)
;
mRgLastRowIndex
=
mRgFirstRowIndex
+
mRg
-
>
GetRowCount
(
)
-
1
;
if
(
SetNewRow
(
mRg
-
>
GetFirstRow
(
)
)
)
{
mCellMap
=
mTableCellMap
-
>
GetMapFor
(
fifRg
nullptr
)
;
if
(
!
mCellMap
)
ABORT1
(
false
)
;
}
if
(
mRg
&
&
mTable
-
>
GetPrevInFlow
(
)
&
&
!
mRg
-
>
GetPrevInFlow
(
)
)
{
const
nsStyleDisplay
*
display
=
mRg
-
>
StyleDisplay
(
)
;
if
(
mRowIndex
=
=
mDamageArea
.
StartRow
(
)
)
{
mIsRepeatedHeader
=
(
mozilla
:
:
StyleDisplay
:
:
TableHeaderGroup
=
=
display
-
>
mDisplay
)
;
}
else
{
mIsRepeatedFooter
=
(
mozilla
:
:
StyleDisplay
:
:
TableFooterGroup
=
=
display
-
>
mDisplay
)
;
}
}
}
else
{
mAtEnd
=
true
;
}
return
!
mAtEnd
;
}
void
BCPaintBorderIterator
:
:
First
(
)
{
if
(
!
mTable
|
|
mDamageArea
.
StartCol
(
)
>
=
mNumTableCols
|
|
mDamageArea
.
StartRow
(
)
>
=
mNumTableRows
)
ABORT0
(
)
;
mAtEnd
=
false
;
uint32_t
numRowGroups
=
mRowGroups
.
Length
(
)
;
for
(
uint32_t
rgY
=
0
;
rgY
<
numRowGroups
;
rgY
+
+
)
{
nsTableRowGroupFrame
*
rowG
=
mRowGroups
[
rgY
]
;
int32_t
start
=
rowG
-
>
GetStartRowIndex
(
)
;
int32_t
end
=
start
+
rowG
-
>
GetRowCount
(
)
-
1
;
if
(
mDamageArea
.
StartRow
(
)
>
=
start
&
&
mDamageArea
.
StartRow
(
)
<
=
end
)
{
mRgIndex
=
rgY
-
1
;
if
(
SetNewRowGroup
(
)
)
{
while
(
mRowIndex
<
mDamageArea
.
StartRow
(
)
&
&
!
mAtEnd
)
{
SetNewRow
(
)
;
}
if
(
!
mAtEnd
)
{
SetNewData
(
mDamageArea
.
StartRow
(
)
mDamageArea
.
StartCol
(
)
)
;
}
}
return
;
}
}
mAtEnd
=
true
;
}
void
BCPaintBorderIterator
:
:
Next
(
)
{
if
(
mAtEnd
)
ABORT0
(
)
;
mIsNewRow
=
false
;
mColIndex
+
+
;
if
(
mColIndex
>
mDamageArea
.
EndCol
(
)
)
{
mRowIndex
+
+
;
if
(
mRowIndex
=
=
mDamageArea
.
EndRow
(
)
)
{
mColIndex
=
mDamageArea
.
StartCol
(
)
;
}
else
if
(
mRowIndex
<
mDamageArea
.
EndRow
(
)
)
{
if
(
mRowIndex
<
=
mRgLastRowIndex
)
{
SetNewRow
(
)
;
}
else
{
SetNewRowGroup
(
)
;
}
}
else
{
mAtEnd
=
true
;
}
}
if
(
!
mAtEnd
)
{
SetNewData
(
mRowIndex
mColIndex
)
;
}
}
static
nscoord
CalcVerCornerOffset
(
nsPresContext
*
aPresContext
LogicalSide
aCornerOwnerSide
BCPixelSize
aCornerSubWidth
BCPixelSize
aHorWidth
bool
aIsStartOfSeg
bool
aIsBevel
)
{
nscoord
offset
=
0
;
BCPixelSize
smallHalf
largeHalf
;
if
(
IsBlock
(
aCornerOwnerSide
)
)
{
DivideBCBorderSize
(
aCornerSubWidth
smallHalf
largeHalf
)
;
if
(
aIsBevel
)
{
offset
=
(
aIsStartOfSeg
)
?
-
largeHalf
:
smallHalf
;
}
else
{
offset
=
(
eLogicalSideBStart
=
=
aCornerOwnerSide
)
?
smallHalf
:
-
largeHalf
;
}
}
else
{
DivideBCBorderSize
(
aHorWidth
smallHalf
largeHalf
)
;
if
(
aIsBevel
)
{
offset
=
(
aIsStartOfSeg
)
?
-
largeHalf
:
smallHalf
;
}
else
{
offset
=
(
aIsStartOfSeg
)
?
smallHalf
:
-
largeHalf
;
}
}
return
aPresContext
-
>
DevPixelsToAppUnits
(
offset
)
;
}
static
nscoord
CalcHorCornerOffset
(
nsPresContext
*
aPresContext
LogicalSide
aCornerOwnerSide
BCPixelSize
aCornerSubWidth
BCPixelSize
aVerWidth
bool
aIsStartOfSeg
bool
aIsBevel
)
{
nscoord
offset
=
0
;
BCPixelSize
smallHalf
largeHalf
;
if
(
IsInline
(
aCornerOwnerSide
)
)
{
DivideBCBorderSize
(
aCornerSubWidth
smallHalf
largeHalf
)
;
if
(
aIsBevel
)
{
offset
=
(
aIsStartOfSeg
)
?
-
largeHalf
:
smallHalf
;
}
else
{
offset
=
(
eLogicalSideIStart
=
=
aCornerOwnerSide
)
?
smallHalf
:
-
largeHalf
;
}
}
else
{
DivideBCBorderSize
(
aVerWidth
smallHalf
largeHalf
)
;
if
(
aIsBevel
)
{
offset
=
(
aIsStartOfSeg
)
?
-
largeHalf
:
smallHalf
;
}
else
{
offset
=
(
aIsStartOfSeg
)
?
smallHalf
:
-
largeHalf
;
}
}
return
aPresContext
-
>
DevPixelsToAppUnits
(
offset
)
;
}
BCBlockDirSeg
:
:
BCBlockDirSeg
(
)
:
mFirstRowGroup
(
nullptr
)
mFirstRow
(
nullptr
)
mBEndInlineSegBSize
(
0
)
mBEndOffset
(
0
)
mIsBEndBevel
(
false
)
{
mCol
=
nullptr
;
mFirstCell
=
mLastCell
=
mAjaCell
=
nullptr
;
mOffsetI
=
mOffsetB
=
mLength
=
mWidth
=
mBStartBevelOffset
=
0
;
mBStartBevelSide
=
eLogicalSideBStart
;
mOwner
=
eCellOwner
;
}
void
BCBlockDirSeg
:
:
Start
(
BCPaintBorderIterator
&
aIter
BCBorderOwner
aBorderOwner
BCPixelSize
aBlockSegISize
BCPixelSize
aInlineSegBSize
)
{
LogicalSide
ownerSide
=
eLogicalSideBStart
;
bool
bevel
=
false
;
nscoord
cornerSubWidth
=
(
aIter
.
mBCData
)
?
aIter
.
mBCData
-
>
GetCorner
(
ownerSide
bevel
)
:
0
;
bool
bStartBevel
=
(
aBlockSegISize
>
0
)
?
bevel
:
false
;
BCPixelSize
maxInlineSegBSize
=
std
:
:
max
(
aIter
.
mPrevInlineSegBSize
aInlineSegBSize
)
;
nsPresContext
*
presContext
=
aIter
.
mTable
-
>
PresContext
(
)
;
nscoord
offset
=
CalcVerCornerOffset
(
presContext
ownerSide
cornerSubWidth
maxInlineSegBSize
true
bStartBevel
)
;
mBStartBevelOffset
=
bStartBevel
?
presContext
-
>
DevPixelsToAppUnits
(
maxInlineSegBSize
)
:
0
;
mBStartBevelSide
=
(
aInlineSegBSize
>
0
)
?
eLogicalSideIEnd
:
eLogicalSideIStart
;
mOffsetB
+
=
offset
;
mLength
=
-
offset
;
mWidth
=
aBlockSegISize
;
mOwner
=
aBorderOwner
;
mFirstCell
=
aIter
.
mCell
;
mFirstRowGroup
=
aIter
.
mRg
;
mFirstRow
=
aIter
.
mRow
;
if
(
aIter
.
GetRelativeColIndex
(
)
>
0
)
{
mAjaCell
=
aIter
.
mBlockDirInfo
[
aIter
.
GetRelativeColIndex
(
)
-
1
]
.
mLastCell
;
}
}
void
BCBlockDirSeg
:
:
Initialize
(
BCPaintBorderIterator
&
aIter
)
{
int32_t
relColIndex
=
aIter
.
GetRelativeColIndex
(
)
;
mCol
=
aIter
.
IsTableIEndMost
(
)
?
aIter
.
mBlockDirInfo
[
relColIndex
-
1
]
.
mCol
:
aIter
.
mTableFirstInFlow
-
>
GetColFrame
(
aIter
.
mColIndex
)
;
if
(
!
mCol
)
ABORT0
(
)
;
if
(
0
=
=
relColIndex
)
{
mOffsetI
=
aIter
.
mInitialOffsetI
;
}
if
(
!
aIter
.
IsDamageAreaIEndMost
(
)
)
{
aIter
.
mBlockDirInfo
[
relColIndex
+
1
]
.
mOffsetI
=
mOffsetI
+
mCol
-
>
ISize
(
aIter
.
mTableWM
)
;
}
mOffsetB
=
aIter
.
mInitialOffsetB
;
mLastCell
=
aIter
.
mCell
;
}
void
BCBlockDirSeg
:
:
GetBEndCorner
(
BCPaintBorderIterator
&
aIter
BCPixelSize
aInlineSegBSize
)
{
LogicalSide
ownerSide
=
eLogicalSideBStart
;
nscoord
cornerSubWidth
=
0
;
bool
bevel
=
false
;
if
(
aIter
.
mBCData
)
{
cornerSubWidth
=
aIter
.
mBCData
-
>
GetCorner
(
ownerSide
bevel
)
;
}
mIsBEndBevel
=
(
mWidth
>
0
)
?
bevel
:
false
;
mBEndInlineSegBSize
=
std
:
:
max
(
aIter
.
mPrevInlineSegBSize
aInlineSegBSize
)
;
mBEndOffset
=
CalcVerCornerOffset
(
aIter
.
mTable
-
>
PresContext
(
)
ownerSide
cornerSubWidth
mBEndInlineSegBSize
false
mIsBEndBevel
)
;
mLength
+
=
mBEndOffset
;
}
Maybe
<
BCBorderParameters
>
BCBlockDirSeg
:
:
BuildBorderParameters
(
BCPaintBorderIterator
&
aIter
BCPixelSize
aInlineSegBSize
)
{
BCBorderParameters
result
;
LogicalSide
side
=
aIter
.
IsDamageAreaIEndMost
(
)
?
eLogicalSideIEnd
:
eLogicalSideIStart
;
int32_t
relColIndex
=
aIter
.
GetRelativeColIndex
(
)
;
nsTableColFrame
*
col
=
mCol
;
if
(
!
col
)
ABORT1
(
Nothing
(
)
)
;
nsTableCellFrame
*
cell
=
mFirstCell
;
nsIFrame
*
owner
=
nullptr
;
result
.
mBorderStyle
=
StyleBorderStyle
:
:
Solid
;
result
.
mBorderColor
=
0xFFFFFFFF
;
result
.
mBackfaceIsVisible
=
true
;
nsPresContext
*
presContext
=
aIter
.
mTable
-
>
PresContext
(
)
;
result
.
mAppUnitsPerDevPixel
=
presContext
-
>
AppUnitsPerDevPixel
(
)
;
switch
(
mOwner
)
{
case
eTableOwner
:
owner
=
aIter
.
mTable
;
break
;
case
eAjaColGroupOwner
:
side
=
eLogicalSideIEnd
;
if
(
!
aIter
.
IsTableIEndMost
(
)
&
&
(
relColIndex
>
0
)
)
{
col
=
aIter
.
mBlockDirInfo
[
relColIndex
-
1
]
.
mCol
;
}
MOZ_FALLTHROUGH
;
case
eColGroupOwner
:
if
(
col
)
{
owner
=
col
-
>
GetParent
(
)
;
}
break
;
case
eAjaColOwner
:
side
=
eLogicalSideIEnd
;
if
(
!
aIter
.
IsTableIEndMost
(
)
&
&
(
relColIndex
>
0
)
)
{
col
=
aIter
.
mBlockDirInfo
[
relColIndex
-
1
]
.
mCol
;
}
MOZ_FALLTHROUGH
;
case
eColOwner
:
owner
=
col
;
break
;
case
eAjaRowGroupOwner
:
NS_ERROR
(
"
a
neighboring
rowgroup
can
never
own
a
vertical
border
"
)
;
MOZ_FALLTHROUGH
;
case
eRowGroupOwner
:
NS_ASSERTION
(
aIter
.
IsTableIStartMost
(
)
|
|
aIter
.
IsTableIEndMost
(
)
"
row
group
can
own
border
only
at
table
edge
"
)
;
owner
=
mFirstRowGroup
;
break
;
case
eAjaRowOwner
:
NS_ERROR
(
"
program
error
"
)
;
MOZ_FALLTHROUGH
;
case
eRowOwner
:
NS_ASSERTION
(
aIter
.
IsTableIStartMost
(
)
|
|
aIter
.
IsTableIEndMost
(
)
"
row
can
own
border
only
at
table
edge
"
)
;
owner
=
mFirstRow
;
break
;
case
eAjaCellOwner
:
side
=
eLogicalSideIEnd
;
cell
=
mAjaCell
;
MOZ_FALLTHROUGH
;
case
eCellOwner
:
owner
=
cell
;
break
;
}
if
(
owner
)
{
:
:
GetPaintStyleInfo
(
owner
aIter
.
mTableWM
side
&
result
.
mBorderStyle
&
result
.
mBorderColor
)
;
result
.
mBackfaceIsVisible
=
!
owner
-
>
BackfaceIsHidden
(
)
;
}
BCPixelSize
smallHalf
largeHalf
;
DivideBCBorderSize
(
mWidth
smallHalf
largeHalf
)
;
LogicalRect
segRect
(
aIter
.
mTableWM
mOffsetI
-
presContext
-
>
DevPixelsToAppUnits
(
largeHalf
)
mOffsetB
presContext
-
>
DevPixelsToAppUnits
(
mWidth
)
mLength
)
;
nscoord
bEndBevelOffset
=
(
mIsBEndBevel
)
?
presContext
-
>
DevPixelsToAppUnits
(
mBEndInlineSegBSize
)
:
0
;
LogicalSide
bEndBevelSide
=
(
aInlineSegBSize
>
0
)
?
eLogicalSideIEnd
:
eLogicalSideIStart
;
result
.
mBorderRect
=
segRect
.
GetPhysicalRect
(
aIter
.
mTableWM
aIter
.
mTable
-
>
GetSize
(
)
)
;
result
.
mStartBevelSide
=
aIter
.
mTableWM
.
PhysicalSide
(
mBStartBevelSide
)
;
result
.
mEndBevelSide
=
aIter
.
mTableWM
.
PhysicalSide
(
bEndBevelSide
)
;
result
.
mStartBevelOffset
=
mBStartBevelOffset
;
result
.
mEndBevelOffset
=
bEndBevelOffset
;
if
(
aIter
.
mTableWM
.
IsVerticalRL
(
)
)
{
Swap
(
result
.
mStartBevelSide
result
.
mEndBevelSide
)
;
Swap
(
result
.
mStartBevelOffset
result
.
mEndBevelOffset
)
;
}
return
Some
(
result
)
;
}
void
BCBlockDirSeg
:
:
Paint
(
BCPaintBorderIterator
&
aIter
DrawTarget
&
aDrawTarget
BCPixelSize
aInlineSegBSize
)
{
Maybe
<
BCBorderParameters
>
param
=
BuildBorderParameters
(
aIter
aInlineSegBSize
)
;
if
(
param
.
isNothing
(
)
)
{
return
;
}
nsCSSRendering
:
:
DrawTableBorderSegment
(
aDrawTarget
param
-
>
mBorderStyle
param
-
>
mBorderColor
param
-
>
mBorderRect
param
-
>
mAppUnitsPerDevPixel
param
-
>
mStartBevelSide
param
-
>
mStartBevelOffset
param
-
>
mEndBevelSide
param
-
>
mEndBevelOffset
)
;
}
static
void
AdjustAndPushBevel
(
wr
:
:
DisplayListBuilder
&
aBuilder
wr
:
:
LayoutRect
&
aRect
nscolor
aColor
const
nsCSSRendering
:
:
Bevel
&
aBevel
int32_t
aAppUnitsPerDevPixel
bool
aBackfaceIsVisible
bool
aIsStart
)
{
if
(
!
aBevel
.
mOffset
)
{
return
;
}
const
auto
kTransparent
=
wr
:
:
ToColorF
(
gfx
:
:
Color
(
0
.
0
.
0
.
0
.
)
)
;
const
bool
horizontal
=
aBevel
.
mSide
=
=
eSideTop
|
|
aBevel
.
mSide
=
=
eSideBottom
;
Float
offset
=
NSAppUnitsToFloatPixels
(
aBevel
.
mOffset
aAppUnitsPerDevPixel
)
;
wr
:
:
LayoutRect
bevelRect
=
aRect
;
wr
:
:
BorderSide
bevelBorder
[
4
]
;
NS_FOR_CSS_SIDES
(
i
)
{
bevelBorder
[
i
]
=
wr
:
:
ToBorderSide
(
ToDeviceColor
(
aColor
)
StyleBorderStyle
:
:
Solid
)
;
}
auto
borderWidths
=
wr
:
:
ToBorderWidths
(
0
0
0
0
)
;
bevelBorder
[
aBevel
.
mSide
]
.
color
=
kTransparent
;
if
(
aIsStart
)
{
if
(
horizontal
)
{
bevelBorder
[
eSideLeft
]
.
color
=
kTransparent
;
borderWidths
.
left
=
offset
;
}
else
{
bevelBorder
[
eSideTop
]
.
color
=
kTransparent
;
borderWidths
.
top
=
offset
;
}
}
else
{
if
(
horizontal
)
{
bevelBorder
[
eSideRight
]
.
color
=
kTransparent
;
borderWidths
.
right
=
offset
;
}
else
{
bevelBorder
[
eSideBottom
]
.
color
=
kTransparent
;
borderWidths
.
bottom
=
offset
;
}
}
if
(
horizontal
)
{
if
(
aIsStart
)
{
aRect
.
origin
.
x
+
=
offset
;
}
else
{
bevelRect
.
origin
.
x
+
=
aRect
.
size
.
width
-
offset
;
}
aRect
.
size
.
width
-
=
offset
;
bevelRect
.
size
.
height
=
aRect
.
size
.
height
;
bevelRect
.
size
.
width
=
offset
;
if
(
aBevel
.
mSide
=
=
eSideTop
)
{
borderWidths
.
bottom
=
aRect
.
size
.
height
;
}
else
{
borderWidths
.
top
=
aRect
.
size
.
height
;
}
}
else
{
if
(
aIsStart
)
{
aRect
.
origin
.
y
+
=
offset
;
}
else
{
bevelRect
.
origin
.
y
+
=
aRect
.
size
.
height
-
offset
;
}
aRect
.
size
.
height
-
=
offset
;
bevelRect
.
size
.
width
=
aRect
.
size
.
width
;
bevelRect
.
size
.
height
=
offset
;
if
(
aBevel
.
mSide
=
=
eSideLeft
)
{
borderWidths
.
right
=
aRect
.
size
.
width
;
}
else
{
borderWidths
.
left
=
aRect
.
size
.
width
;
}
}
Range
<
const
wr
:
:
BorderSide
>
wrsides
(
bevelBorder
4
)
;
aBuilder
.
PushBorder
(
bevelRect
bevelRect
aBackfaceIsVisible
borderWidths
wrsides
wr
:
:
EmptyBorderRadius
(
)
wr
:
:
AntialiasBorder
:
:
No
)
;
}
static
void
CreateWRCommandsForBeveledBorder
(
const
BCBorderParameters
&
aBorderParams
wr
:
:
DisplayListBuilder
&
aBuilder
const
layers
:
:
StackingContextHelper
&
aSc
const
nsPoint
&
aOffset
)
{
MOZ_ASSERT
(
aBorderParams
.
NeedToBevel
(
)
)
;
AutoTArray
<
nsCSSRendering
:
:
SolidBeveledBorderSegment
3
>
segments
;
nsCSSRendering
:
:
GetTableBorderSolidSegments
(
segments
aBorderParams
.
mBorderStyle
aBorderParams
.
mBorderColor
aBorderParams
.
mBorderRect
aBorderParams
.
mAppUnitsPerDevPixel
aBorderParams
.
mStartBevelSide
aBorderParams
.
mStartBevelOffset
aBorderParams
.
mEndBevelSide
aBorderParams
.
mEndBevelOffset
)
;
for
(
const
auto
&
segment
:
segments
)
{
auto
rect
=
LayoutDeviceRect
:
:
FromUnknownRect
(
NSRectToRect
(
segment
.
mRect
+
aOffset
aBorderParams
.
mAppUnitsPerDevPixel
)
)
;
auto
roundedRect
=
wr
:
:
ToRoundedLayoutRect
(
rect
)
;
auto
color
=
wr
:
:
ToColorF
(
ToDeviceColor
(
segment
.
mColor
)
)
;
AdjustAndPushBevel
(
aBuilder
roundedRect
segment
.
mColor
segment
.
mStartBevel
aBorderParams
.
mAppUnitsPerDevPixel
aBorderParams
.
mBackfaceIsVisible
true
)
;
AdjustAndPushBevel
(
aBuilder
roundedRect
segment
.
mColor
segment
.
mEndBevel
aBorderParams
.
mAppUnitsPerDevPixel
aBorderParams
.
mBackfaceIsVisible
false
)
;
aBuilder
.
PushRect
(
roundedRect
roundedRect
aBorderParams
.
mBackfaceIsVisible
color
)
;
}
}
static
void
CreateWRCommandsForBorderSegment
(
const
BCBorderParameters
&
aBorderParams
wr
:
:
DisplayListBuilder
&
aBuilder
const
layers
:
:
StackingContextHelper
&
aSc
const
nsPoint
&
aOffset
)
{
if
(
aBorderParams
.
NeedToBevel
(
)
)
{
CreateWRCommandsForBeveledBorder
(
aBorderParams
aBuilder
aSc
aOffset
)
;
return
;
}
auto
borderRect
=
LayoutDeviceRect
:
:
FromUnknownRect
(
NSRectToRect
(
aBorderParams
.
mBorderRect
+
aOffset
aBorderParams
.
mAppUnitsPerDevPixel
)
)
;
wr
:
:
LayoutRect
roundedRect
=
wr
:
:
ToRoundedLayoutRect
(
borderRect
)
;
wr
:
:
BorderSide
wrSide
[
4
]
;
NS_FOR_CSS_SIDES
(
i
)
{
wrSide
[
i
]
=
wr
:
:
ToBorderSide
(
ToDeviceColor
(
aBorderParams
.
mBorderColor
)
StyleBorderStyle
:
:
None
)
;
}
const
bool
horizontal
=
aBorderParams
.
mStartBevelSide
=
=
eSideTop
|
|
aBorderParams
.
mStartBevelSide
=
=
eSideBottom
;
auto
borderWidth
=
horizontal
?
roundedRect
.
size
.
height
:
roundedRect
.
size
.
width
;
auto
borderWidths
=
wr
:
:
ToBorderWidths
(
0
0
0
0
)
;
wrSide
[
horizontal
?
eSideTop
:
eSideLeft
]
=
wr
:
:
ToBorderSide
(
ToDeviceColor
(
aBorderParams
.
mBorderColor
)
aBorderParams
.
mBorderStyle
)
;
if
(
horizontal
)
{
borderWidths
.
top
=
borderWidth
;
}
else
{
borderWidths
.
left
=
borderWidth
;
}
Range
<
const
wr
:
:
BorderSide
>
wrsides
(
wrSide
4
)
;
aBuilder
.
PushBorder
(
roundedRect
roundedRect
aBorderParams
.
mBackfaceIsVisible
borderWidths
wrsides
wr
:
:
EmptyBorderRadius
(
)
)
;
}
void
BCBlockDirSeg
:
:
CreateWebRenderCommands
(
BCPaintBorderIterator
&
aIter
BCPixelSize
aInlineSegBSize
wr
:
:
DisplayListBuilder
&
aBuilder
const
layers
:
:
StackingContextHelper
&
aSc
const
nsPoint
&
aOffset
)
{
Maybe
<
BCBorderParameters
>
param
=
BuildBorderParameters
(
aIter
aInlineSegBSize
)
;
if
(
param
.
isNothing
(
)
)
{
return
;
}
CreateWRCommandsForBorderSegment
(
*
param
aBuilder
aSc
aOffset
)
;
}
void
BCBlockDirSeg
:
:
AdvanceOffsetB
(
)
{
mOffsetB
+
=
mLength
-
mBEndOffset
;
}
void
BCBlockDirSeg
:
:
IncludeCurrentBorder
(
BCPaintBorderIterator
&
aIter
)
{
mLastCell
=
aIter
.
mCell
;
mLength
+
=
aIter
.
mRow
-
>
BSize
(
aIter
.
mTableWM
)
;
}
BCInlineDirSeg
:
:
BCInlineDirSeg
(
)
:
mIsIEndBevel
(
false
)
mIEndBevelOffset
(
0
)
mIEndBevelSide
(
eLogicalSideBStart
)
mEndOffset
(
0
)
mOwner
(
eTableOwner
)
{
mOffsetI
=
mOffsetB
=
mLength
=
mWidth
=
mIStartBevelOffset
=
0
;
mIStartBevelSide
=
eLogicalSideBStart
;
mFirstCell
=
mAjaCell
=
nullptr
;
}
void
BCInlineDirSeg
:
:
Start
(
BCPaintBorderIterator
&
aIter
BCBorderOwner
aBorderOwner
BCPixelSize
aBEndBlockSegISize
BCPixelSize
aInlineSegBSize
)
{
LogicalSide
cornerOwnerSide
=
eLogicalSideBStart
;
bool
bevel
=
false
;
mOwner
=
aBorderOwner
;
nscoord
cornerSubWidth
=
(
aIter
.
mBCData
)
?
aIter
.
mBCData
-
>
GetCorner
(
cornerOwnerSide
bevel
)
:
0
;
bool
iStartBevel
=
(
aInlineSegBSize
>
0
)
?
bevel
:
false
;
int32_t
relColIndex
=
aIter
.
GetRelativeColIndex
(
)
;
nscoord
maxBlockSegISize
=
std
:
:
max
(
aIter
.
mBlockDirInfo
[
relColIndex
]
.
mWidth
aBEndBlockSegISize
)
;
nscoord
offset
=
CalcHorCornerOffset
(
aIter
.
mTable
-
>
PresContext
(
)
cornerOwnerSide
cornerSubWidth
maxBlockSegISize
true
iStartBevel
)
;
mIStartBevelOffset
=
(
iStartBevel
&
&
(
aInlineSegBSize
>
0
)
)
?
maxBlockSegISize
:
0
;
mIStartBevelSide
=
(
aBEndBlockSegISize
>
0
)
?
eLogicalSideBEnd
:
eLogicalSideBStart
;
mOffsetI
+
=
offset
;
mLength
=
-
offset
;
mWidth
=
aInlineSegBSize
;
mFirstCell
=
aIter
.
mCell
;
mAjaCell
=
(
aIter
.
IsDamageAreaBStartMost
(
)
)
?
nullptr
:
aIter
.
mBlockDirInfo
[
relColIndex
]
.
mLastCell
;
}
void
BCInlineDirSeg
:
:
GetIEndCorner
(
BCPaintBorderIterator
&
aIter
BCPixelSize
aIStartSegISize
)
{
LogicalSide
ownerSide
=
eLogicalSideBStart
;
nscoord
cornerSubWidth
=
0
;
bool
bevel
=
false
;
if
(
aIter
.
mBCData
)
{
cornerSubWidth
=
aIter
.
mBCData
-
>
GetCorner
(
ownerSide
bevel
)
;
}
mIsIEndBevel
=
(
mWidth
>
0
)
?
bevel
:
0
;
int32_t
relColIndex
=
aIter
.
GetRelativeColIndex
(
)
;
nscoord
verWidth
=
std
:
:
max
(
aIter
.
mBlockDirInfo
[
relColIndex
]
.
mWidth
aIStartSegISize
)
;
nsPresContext
*
presContext
=
aIter
.
mTable
-
>
PresContext
(
)
;
mEndOffset
=
CalcHorCornerOffset
(
presContext
ownerSide
cornerSubWidth
verWidth
false
mIsIEndBevel
)
;
mLength
+
=
mEndOffset
;
mIEndBevelOffset
=
(
mIsIEndBevel
)
?
presContext
-
>
DevPixelsToAppUnits
(
verWidth
)
:
0
;
mIEndBevelSide
=
(
aIStartSegISize
>
0
)
?
eLogicalSideBEnd
:
eLogicalSideBStart
;
}
Maybe
<
BCBorderParameters
>
BCInlineDirSeg
:
:
BuildBorderParameters
(
BCPaintBorderIterator
&
aIter
)
{
BCBorderParameters
result
;
LogicalSide
side
=
aIter
.
IsDamageAreaBEndMost
(
)
?
eLogicalSideBEnd
:
eLogicalSideBStart
;
nsIFrame
*
rg
=
aIter
.
mRg
;
if
(
!
rg
)
ABORT1
(
Nothing
(
)
)
;
nsIFrame
*
row
=
aIter
.
mRow
;
if
(
!
row
)
ABORT1
(
Nothing
(
)
)
;
nsIFrame
*
cell
=
mFirstCell
;
nsIFrame
*
col
;
nsIFrame
*
owner
=
nullptr
;
result
.
mBackfaceIsVisible
=
true
;
nsPresContext
*
presContext
=
aIter
.
mTable
-
>
PresContext
(
)
;
result
.
mAppUnitsPerDevPixel
=
presContext
-
>
AppUnitsPerDevPixel
(
)
;
result
.
mBorderStyle
=
StyleBorderStyle
:
:
Solid
;
result
.
mBorderColor
=
0xFFFFFFFF
;
switch
(
mOwner
)
{
case
eTableOwner
:
owner
=
aIter
.
mTable
;
break
;
case
eAjaColGroupOwner
:
NS_ERROR
(
"
neighboring
colgroups
can
never
own
an
inline
-
dir
border
"
)
;
MOZ_FALLTHROUGH
;
case
eColGroupOwner
:
NS_ASSERTION
(
aIter
.
IsTableBStartMost
(
)
|
|
aIter
.
IsTableBEndMost
(
)
"
col
group
can
own
border
only
at
the
table
edge
"
)
;
col
=
aIter
.
mTableFirstInFlow
-
>
GetColFrame
(
aIter
.
mColIndex
-
1
)
;
if
(
!
col
)
ABORT1
(
Nothing
(
)
)
;
owner
=
col
-
>
GetParent
(
)
;
break
;
case
eAjaColOwner
:
NS_ERROR
(
"
neighboring
column
can
never
own
an
inline
-
dir
border
"
)
;
MOZ_FALLTHROUGH
;
case
eColOwner
:
NS_ASSERTION
(
aIter
.
IsTableBStartMost
(
)
|
|
aIter
.
IsTableBEndMost
(
)
"
col
can
own
border
only
at
the
table
edge
"
)
;
owner
=
aIter
.
mTableFirstInFlow
-
>
GetColFrame
(
aIter
.
mColIndex
-
1
)
;
break
;
case
eAjaRowGroupOwner
:
side
=
eLogicalSideBEnd
;
rg
=
(
aIter
.
IsTableBEndMost
(
)
)
?
aIter
.
mRg
:
aIter
.
mPrevRg
;
MOZ_FALLTHROUGH
;
case
eRowGroupOwner
:
owner
=
rg
;
break
;
case
eAjaRowOwner
:
side
=
eLogicalSideBEnd
;
row
=
(
aIter
.
IsTableBEndMost
(
)
)
?
aIter
.
mRow
:
aIter
.
mPrevRow
;
MOZ_FALLTHROUGH
;
case
eRowOwner
:
owner
=
row
;
break
;
case
eAjaCellOwner
:
side
=
eLogicalSideBEnd
;
cell
=
mAjaCell
;
MOZ_FALLTHROUGH
;
case
eCellOwner
:
owner
=
cell
;
break
;
}
if
(
owner
)
{
:
:
GetPaintStyleInfo
(
owner
aIter
.
mTableWM
side
&
result
.
mBorderStyle
&
result
.
mBorderColor
)
;
result
.
mBackfaceIsVisible
=
!
owner
-
>
BackfaceIsHidden
(
)
;
}
BCPixelSize
smallHalf
largeHalf
;
DivideBCBorderSize
(
mWidth
smallHalf
largeHalf
)
;
LogicalRect
segRect
(
aIter
.
mTableWM
mOffsetI
mOffsetB
-
presContext
-
>
DevPixelsToAppUnits
(
largeHalf
)
mLength
presContext
-
>
DevPixelsToAppUnits
(
mWidth
)
)
;
result
.
mBorderRect
=
segRect
.
GetPhysicalRect
(
aIter
.
mTableWM
aIter
.
mTable
-
>
GetSize
(
)
)
;
result
.
mStartBevelSide
=
aIter
.
mTableWM
.
PhysicalSide
(
mIStartBevelSide
)
;
result
.
mEndBevelSide
=
aIter
.
mTableWM
.
PhysicalSide
(
mIEndBevelSide
)
;
result
.
mStartBevelOffset
=
presContext
-
>
DevPixelsToAppUnits
(
mIStartBevelOffset
)
;
result
.
mEndBevelOffset
=
mIEndBevelOffset
;
if
(
!
aIter
.
mTableWM
.
IsBidiLTR
(
)
)
{
Swap
(
result
.
mStartBevelSide
result
.
mEndBevelSide
)
;
Swap
(
result
.
mStartBevelOffset
result
.
mEndBevelOffset
)
;
}
return
Some
(
result
)
;
}
void
BCInlineDirSeg
:
:
Paint
(
BCPaintBorderIterator
&
aIter
DrawTarget
&
aDrawTarget
)
{
Maybe
<
BCBorderParameters
>
param
=
BuildBorderParameters
(
aIter
)
;
if
(
param
.
isNothing
(
)
)
{
return
;
}
nsCSSRendering
:
:
DrawTableBorderSegment
(
aDrawTarget
param
-
>
mBorderStyle
param
-
>
mBorderColor
param
-
>
mBorderRect
param
-
>
mAppUnitsPerDevPixel
param
-
>
mStartBevelSide
param
-
>
mStartBevelOffset
param
-
>
mEndBevelSide
param
-
>
mEndBevelOffset
)
;
}
void
BCInlineDirSeg
:
:
CreateWebRenderCommands
(
BCPaintBorderIterator
&
aIter
wr
:
:
DisplayListBuilder
&
aBuilder
const
layers
:
:
StackingContextHelper
&
aSc
const
nsPoint
&
aPt
)
{
Maybe
<
BCBorderParameters
>
param
=
BuildBorderParameters
(
aIter
)
;
if
(
param
.
isNothing
(
)
)
{
return
;
}
CreateWRCommandsForBorderSegment
(
*
param
aBuilder
aSc
aPt
)
;
}
void
BCInlineDirSeg
:
:
AdvanceOffsetI
(
)
{
mOffsetI
+
=
(
mLength
-
mEndOffset
)
;
}
void
BCInlineDirSeg
:
:
IncludeCurrentBorder
(
BCPaintBorderIterator
&
aIter
)
{
mLength
+
=
aIter
.
mBlockDirInfo
[
aIter
.
GetRelativeColIndex
(
)
]
.
mColWidth
;
}
void
BCPaintBorderIterator
:
:
StoreColumnWidth
(
int32_t
aIndex
)
{
if
(
IsTableIEndMost
(
)
)
{
mBlockDirInfo
[
aIndex
]
.
mColWidth
=
mBlockDirInfo
[
aIndex
-
1
]
.
mColWidth
;
}
else
{
nsTableColFrame
*
col
=
mTableFirstInFlow
-
>
GetColFrame
(
mColIndex
)
;
if
(
!
col
)
ABORT0
(
)
;
mBlockDirInfo
[
aIndex
]
.
mColWidth
=
col
-
>
ISize
(
mTableWM
)
;
}
}
bool
BCPaintBorderIterator
:
:
BlockDirSegmentOwnsCorner
(
)
{
LogicalSide
cornerOwnerSide
=
eLogicalSideBStart
;
bool
bevel
=
false
;
if
(
mBCData
)
{
mBCData
-
>
GetCorner
(
cornerOwnerSide
bevel
)
;
}
return
(
eLogicalSideBStart
=
=
cornerOwnerSide
)
|
|
(
eLogicalSideBEnd
=
=
cornerOwnerSide
)
;
}
void
BCPaintBorderIterator
:
:
AccumulateOrDoActionInlineDirSegment
(
BCPaintBorderAction
&
aAction
)
{
int32_t
relColIndex
=
GetRelativeColIndex
(
)
;
if
(
mBlockDirInfo
[
relColIndex
]
.
mColWidth
<
0
)
{
StoreColumnWidth
(
relColIndex
)
;
}
BCBorderOwner
borderOwner
=
eCellOwner
;
BCBorderOwner
ignoreBorderOwner
;
bool
isSegStart
=
true
;
bool
ignoreSegStart
;
nscoord
iStartSegISize
=
mBCData
?
mBCData
-
>
GetIStartEdge
(
ignoreBorderOwner
ignoreSegStart
)
:
0
;
nscoord
bStartSegBSize
=
mBCData
?
mBCData
-
>
GetBStartEdge
(
borderOwner
isSegStart
)
:
0
;
if
(
mIsNewRow
|
|
(
IsDamageAreaIStartMost
(
)
&
&
IsDamageAreaBEndMost
(
)
)
)
{
mInlineSeg
.
mOffsetB
=
mNextOffsetB
;
mNextOffsetB
=
mNextOffsetB
+
mRow
-
>
BSize
(
mTableWM
)
;
mInlineSeg
.
mOffsetI
=
mInitialOffsetI
;
mInlineSeg
.
Start
(
*
this
borderOwner
iStartSegISize
bStartSegBSize
)
;
}
if
(
!
IsDamageAreaIStartMost
(
)
&
&
(
isSegStart
|
|
IsDamageAreaIEndMost
(
)
|
|
BlockDirSegmentOwnsCorner
(
)
)
)
{
if
(
mInlineSeg
.
mLength
>
0
)
{
mInlineSeg
.
GetIEndCorner
(
*
this
iStartSegISize
)
;
if
(
mInlineSeg
.
mWidth
>
0
)
{
if
(
aAction
.
mMode
=
=
BCPaintBorderAction
:
:
Mode
:
:
PAINT
)
{
mInlineSeg
.
Paint
(
*
this
aAction
.
mPaintData
.
mDrawTarget
)
;
}
else
{
MOZ_ASSERT
(
aAction
.
mMode
=
=
BCPaintBorderAction
:
:
Mode
:
:
CREATE_WEBRENDER_COMMANDS
)
;
mInlineSeg
.
CreateWebRenderCommands
(
*
this
aAction
.
mCreateWebRenderCommandsData
.
mBuilder
aAction
.
mCreateWebRenderCommandsData
.
mSc
aAction
.
mCreateWebRenderCommandsData
.
mOffsetToReferenceFrame
)
;
}
}
mInlineSeg
.
AdvanceOffsetI
(
)
;
}
mInlineSeg
.
Start
(
*
this
borderOwner
iStartSegISize
bStartSegBSize
)
;
}
mInlineSeg
.
IncludeCurrentBorder
(
*
this
)
;
mBlockDirInfo
[
relColIndex
]
.
mWidth
=
iStartSegISize
;
mBlockDirInfo
[
relColIndex
]
.
mLastCell
=
mCell
;
}
void
BCPaintBorderIterator
:
:
AccumulateOrDoActionBlockDirSegment
(
BCPaintBorderAction
&
aAction
)
{
BCBorderOwner
borderOwner
=
eCellOwner
;
BCBorderOwner
ignoreBorderOwner
;
bool
isSegStart
=
true
;
bool
ignoreSegStart
;
nscoord
blockSegISize
=
mBCData
?
mBCData
-
>
GetIStartEdge
(
borderOwner
isSegStart
)
:
0
;
nscoord
inlineSegBSize
=
mBCData
?
mBCData
-
>
GetBStartEdge
(
ignoreBorderOwner
ignoreSegStart
)
:
0
;
int32_t
relColIndex
=
GetRelativeColIndex
(
)
;
BCBlockDirSeg
&
blockDirSeg
=
mBlockDirInfo
[
relColIndex
]
;
if
(
!
blockDirSeg
.
mCol
)
{
blockDirSeg
.
Initialize
(
*
this
)
;
blockDirSeg
.
Start
(
*
this
borderOwner
blockSegISize
inlineSegBSize
)
;
}
if
(
!
IsDamageAreaBStartMost
(
)
&
&
(
isSegStart
|
|
IsDamageAreaBEndMost
(
)
|
|
IsAfterRepeatedHeader
(
)
|
|
StartRepeatedFooter
(
)
)
)
{
if
(
blockDirSeg
.
mLength
>
0
)
{
blockDirSeg
.
GetBEndCorner
(
*
this
inlineSegBSize
)
;
if
(
blockDirSeg
.
mWidth
>
0
)
{
if
(
aAction
.
mMode
=
=
BCPaintBorderAction
:
:
Mode
:
:
PAINT
)
{
blockDirSeg
.
Paint
(
*
this
aAction
.
mPaintData
.
mDrawTarget
inlineSegBSize
)
;
}
else
{
MOZ_ASSERT
(
aAction
.
mMode
=
=
BCPaintBorderAction
:
:
Mode
:
:
CREATE_WEBRENDER_COMMANDS
)
;
blockDirSeg
.
CreateWebRenderCommands
(
*
this
inlineSegBSize
aAction
.
mCreateWebRenderCommandsData
.
mBuilder
aAction
.
mCreateWebRenderCommandsData
.
mSc
aAction
.
mCreateWebRenderCommandsData
.
mOffsetToReferenceFrame
)
;
}
}
blockDirSeg
.
AdvanceOffsetB
(
)
;
}
blockDirSeg
.
Start
(
*
this
borderOwner
blockSegISize
inlineSegBSize
)
;
}
blockDirSeg
.
IncludeCurrentBorder
(
*
this
)
;
mPrevInlineSegBSize
=
inlineSegBSize
;
}
void
BCPaintBorderIterator
:
:
ResetVerInfo
(
)
{
if
(
mBlockDirInfo
)
{
memset
(
mBlockDirInfo
0
mDamageArea
.
ColCount
(
)
*
sizeof
(
BCBlockDirSeg
)
)
;
for
(
auto
xIndex
:
IntegerRange
(
mDamageArea
.
ColCount
(
)
)
)
{
mBlockDirInfo
[
xIndex
]
.
mColWidth
=
-
1
;
}
}
}
void
nsTableFrame
:
:
IterateBCBorders
(
BCPaintBorderAction
&
aAction
const
nsRect
&
aDirtyRect
)
{
BCPaintBorderIterator
iter
(
this
)
;
if
(
!
iter
.
SetDamageArea
(
aDirtyRect
)
)
return
;
for
(
iter
.
First
(
)
;
!
iter
.
mAtEnd
;
iter
.
Next
(
)
)
{
iter
.
AccumulateOrDoActionBlockDirSegment
(
aAction
)
;
}
iter
.
Reset
(
)
;
for
(
iter
.
First
(
)
;
!
iter
.
mAtEnd
;
iter
.
Next
(
)
)
{
iter
.
AccumulateOrDoActionInlineDirSegment
(
aAction
)
;
}
}
void
nsTableFrame
:
:
PaintBCBorders
(
DrawTarget
&
aDrawTarget
const
nsRect
&
aDirtyRect
)
{
BCPaintBorderAction
action
(
aDrawTarget
)
;
IterateBCBorders
(
action
aDirtyRect
)
;
}
void
nsTableFrame
:
:
CreateWebRenderCommandsForBCBorders
(
wr
:
:
DisplayListBuilder
&
aBuilder
const
mozilla
:
:
layers
:
:
StackingContextHelper
&
aSc
const
nsRect
&
aVisibleRect
const
nsPoint
&
aOffsetToReferenceFrame
)
{
BCPaintBorderAction
action
(
aBuilder
aSc
aOffsetToReferenceFrame
)
;
IterateBCBorders
(
action
aVisibleRect
-
aOffsetToReferenceFrame
)
;
}
bool
nsTableFrame
:
:
RowHasSpanningCells
(
int32_t
aRowIndex
int32_t
aNumEffCols
)
{
bool
result
=
false
;
nsTableCellMap
*
cellMap
=
GetCellMap
(
)
;
MOZ_ASSERT
(
cellMap
"
bad
call
cellMap
not
yet
allocated
.
"
)
;
if
(
cellMap
)
{
result
=
cellMap
-
>
RowHasSpanningCells
(
aRowIndex
aNumEffCols
)
;
}
return
result
;
}
bool
nsTableFrame
:
:
RowIsSpannedInto
(
int32_t
aRowIndex
int32_t
aNumEffCols
)
{
bool
result
=
false
;
nsTableCellMap
*
cellMap
=
GetCellMap
(
)
;
MOZ_ASSERT
(
cellMap
"
bad
call
cellMap
not
yet
allocated
.
"
)
;
if
(
cellMap
)
{
result
=
cellMap
-
>
RowIsSpannedInto
(
aRowIndex
aNumEffCols
)
;
}
return
result
;
}
void
nsTableFrame
:
:
InvalidateTableFrame
(
nsIFrame
*
aFrame
const
nsRect
&
aOrigRect
const
nsRect
&
aOrigVisualOverflow
bool
aIsFirstReflow
)
{
nsIFrame
*
parent
=
aFrame
-
>
GetParent
(
)
;
NS_ASSERTION
(
parent
"
What
happened
here
?
"
)
;
if
(
parent
-
>
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
)
{
return
;
}
nsRect
visualOverflow
=
aFrame
-
>
GetVisualOverflowRect
(
)
;
if
(
aIsFirstReflow
|
|
aOrigRect
.
TopLeft
(
)
!
=
aFrame
-
>
GetPosition
(
)
|
|
aOrigVisualOverflow
.
TopLeft
(
)
!
=
visualOverflow
.
TopLeft
(
)
)
{
aFrame
-
>
InvalidateFrame
(
)
;
parent
-
>
InvalidateFrameWithRect
(
aOrigVisualOverflow
+
aOrigRect
.
TopLeft
(
)
)
;
}
else
if
(
aOrigRect
.
Size
(
)
!
=
aFrame
-
>
GetSize
(
)
|
|
aOrigVisualOverflow
.
Size
(
)
!
=
visualOverflow
.
Size
(
)
)
{
aFrame
-
>
InvalidateFrameWithRect
(
aOrigVisualOverflow
)
;
aFrame
-
>
InvalidateFrame
(
)
;
}
}
void
nsTableFrame
:
:
AppendDirectlyOwnedAnonBoxes
(
nsTArray
<
OwnedAnonBox
>
&
aResult
)
{
nsIFrame
*
wrapper
=
GetParent
(
)
;
MOZ_ASSERT
(
wrapper
-
>
Style
(
)
-
>
GetPseudo
(
)
=
=
nsCSSAnonBoxes
:
:
tableWrapper
(
)
"
What
happened
to
our
parent
?
"
)
;
aResult
.
AppendElement
(
OwnedAnonBox
(
wrapper
&
UpdateStyleOfOwnedAnonBoxesForTableWrapper
)
)
;
}
void
nsTableFrame
:
:
UpdateStyleOfOwnedAnonBoxesForTableWrapper
(
nsIFrame
*
aOwningFrame
nsIFrame
*
aWrapperFrame
ServoRestyleState
&
aRestyleState
)
{
MOZ_ASSERT
(
aWrapperFrame
-
>
Style
(
)
-
>
GetPseudo
(
)
=
=
nsCSSAnonBoxes
:
:
tableWrapper
(
)
"
What
happened
to
our
parent
?
"
)
;
RefPtr
<
ComputedStyle
>
newStyle
=
aRestyleState
.
StyleSet
(
)
.
ResolveInheritingAnonymousBoxStyle
(
nsCSSAnonBoxes
:
:
tableWrapper
(
)
aOwningFrame
-
>
Style
(
)
)
;
uint32_t
equalStructs
;
nsChangeHint
wrapperHint
=
aWrapperFrame
-
>
Style
(
)
-
>
CalcStyleDifference
(
*
newStyle
&
equalStructs
)
;
if
(
wrapperHint
)
{
aRestyleState
.
ChangeList
(
)
.
AppendChange
(
aWrapperFrame
aWrapperFrame
-
>
GetContent
(
)
wrapperHint
)
;
}
for
(
nsIFrame
*
cur
=
aWrapperFrame
;
cur
;
cur
=
cur
-
>
GetNextContinuation
(
)
)
{
cur
-
>
SetComputedStyle
(
newStyle
)
;
}
MOZ_ASSERT
(
!
(
aWrapperFrame
-
>
GetStateBits
(
)
&
NS_FRAME_OWNS_ANON_BOXES
)
"
Wrapper
frame
doesn
'
t
have
any
anon
boxes
of
its
own
!
"
)
;
}
