#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
nsTableRowFrame
.
h
"
#
include
"
nsTableRowGroupFrame
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
mozilla
/
ComputedStyle
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsTableFrame
.
h
"
#
include
"
nsTableCellFrame
.
h
"
#
include
"
nsCSSRendering
.
h
"
#
include
"
nsHTMLParts
.
h
"
#
include
"
nsTableColGroupFrame
.
h
"
#
include
"
nsTableColFrame
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
<
algorithm
>
using
namespace
mozilla
;
namespace
mozilla
{
struct
TableCellReflowInput
:
public
ReflowInput
{
TableCellReflowInput
(
nsPresContext
*
aPresContext
const
ReflowInput
&
aParentReflowInput
nsIFrame
*
aFrame
const
LogicalSize
&
aAvailableSpace
uint32_t
aFlags
=
0
)
:
ReflowInput
(
aPresContext
aParentReflowInput
aFrame
aAvailableSpace
nullptr
aFlags
)
{
}
void
FixUp
(
const
LogicalSize
&
aAvailSpace
)
;
}
;
}
void
TableCellReflowInput
:
:
FixUp
(
const
LogicalSize
&
aAvailSpace
)
{
NS_WARNING_ASSERTION
(
NS_UNCONSTRAINEDSIZE
!
=
aAvailSpace
.
ISize
(
mWritingMode
)
"
have
unconstrained
inline
-
size
;
this
should
only
result
from
very
large
"
"
sizes
not
attempts
at
intrinsic
inline
size
calculation
"
)
;
if
(
NS_UNCONSTRAINEDSIZE
!
=
ComputedISize
(
)
)
{
nscoord
computedISize
=
aAvailSpace
.
ISize
(
mWritingMode
)
-
ComputedLogicalBorderPadding
(
)
.
IStartEnd
(
mWritingMode
)
;
computedISize
=
std
:
:
max
(
0
computedISize
)
;
SetComputedISize
(
computedISize
)
;
}
if
(
NS_UNCONSTRAINEDSIZE
!
=
ComputedBSize
(
)
&
&
NS_UNCONSTRAINEDSIZE
!
=
aAvailSpace
.
BSize
(
mWritingMode
)
)
{
nscoord
computedBSize
=
aAvailSpace
.
BSize
(
mWritingMode
)
-
ComputedLogicalBorderPadding
(
)
.
BStartEnd
(
mWritingMode
)
;
computedBSize
=
std
:
:
max
(
0
computedBSize
)
;
SetComputedBSize
(
computedBSize
)
;
}
}
void
nsTableRowFrame
:
:
InitChildReflowInput
(
nsPresContext
&
aPresContext
const
LogicalSize
&
aAvailSize
bool
aBorderCollapse
TableCellReflowInput
&
aReflowInput
)
{
nsMargin
collapseBorder
;
nsMargin
*
pCollapseBorder
=
nullptr
;
if
(
aBorderCollapse
)
{
nsBCTableCellFrame
*
bcCellFrame
=
(
nsBCTableCellFrame
*
)
aReflowInput
.
mFrame
;
if
(
bcCellFrame
)
{
WritingMode
wm
=
GetWritingMode
(
)
;
collapseBorder
=
bcCellFrame
-
>
GetBorderWidth
(
wm
)
.
GetPhysicalMargin
(
wm
)
;
pCollapseBorder
=
&
collapseBorder
;
}
}
aReflowInput
.
Init
(
&
aPresContext
nullptr
pCollapseBorder
)
;
aReflowInput
.
FixUp
(
aAvailSize
)
;
}
void
nsTableRowFrame
:
:
SetFixedBSize
(
nscoord
aValue
)
{
nscoord
bsize
=
std
:
:
max
(
0
aValue
)
;
if
(
HasFixedBSize
(
)
)
{
if
(
bsize
>
mStyleFixedBSize
)
{
mStyleFixedBSize
=
bsize
;
}
}
else
{
mStyleFixedBSize
=
bsize
;
if
(
bsize
>
0
)
{
SetHasFixedBSize
(
true
)
;
}
}
}
void
nsTableRowFrame
:
:
SetPctBSize
(
float
aPctValue
bool
aForce
)
{
nscoord
bsize
=
std
:
:
max
(
0
NSToCoordRound
(
aPctValue
*
100
.
0f
)
)
;
if
(
HasPctBSize
(
)
)
{
if
(
(
bsize
>
mStylePctBSize
)
|
|
aForce
)
{
mStylePctBSize
=
bsize
;
}
}
else
{
mStylePctBSize
=
bsize
;
if
(
bsize
>
0
)
{
SetHasPctBSize
(
true
)
;
}
}
}
NS_QUERYFRAME_HEAD
(
nsTableRowFrame
)
NS_QUERYFRAME_ENTRY
(
nsTableRowFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsContainerFrame
)
nsTableRowFrame
:
:
nsTableRowFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
ClassID
aID
)
:
nsContainerFrame
(
aStyle
aPresContext
aID
)
mContentBSize
(
0
)
mStylePctBSize
(
0
)
mStyleFixedBSize
(
0
)
mMaxCellAscent
(
0
)
mMaxCellDescent
(
0
)
mBStartBorderWidth
(
0
)
mBEndBorderWidth
(
0
)
mIEndContBorderWidth
(
0
)
mBStartContBorderWidth
(
0
)
mIStartContBorderWidth
(
0
)
{
mBits
.
mRowIndex
=
0
;
mBits
.
mHasFixedBSize
=
0
;
mBits
.
mHasPctBSize
=
0
;
mBits
.
mFirstInserted
=
0
;
ResetBSize
(
0
)
;
}
nsTableRowFrame
:
:
~
nsTableRowFrame
(
)
{
}
void
nsTableRowFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
nsContainerFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
NS_ASSERTION
(
mozilla
:
:
StyleDisplay
:
:
TableRow
=
=
StyleDisplay
(
)
-
>
mDisplay
"
wrong
display
on
table
row
frame
"
)
;
if
(
aPrevInFlow
)
{
nsTableRowFrame
*
rowFrame
=
(
nsTableRowFrame
*
)
aPrevInFlow
;
SetRowIndex
(
rowFrame
-
>
GetRowIndex
(
)
)
;
}
else
{
mWritingMode
=
GetTableFrame
(
)
-
>
GetWritingMode
(
)
;
}
}
void
nsTableRowFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
{
if
(
HasAnyStateBits
(
NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN
)
)
{
nsTableFrame
:
:
UnregisterPositionedTablePart
(
this
aDestructRoot
)
;
}
nsContainerFrame
:
:
DestroyFrom
(
aDestructRoot
aPostDestroyData
)
;
}
void
nsTableRowFrame
:
:
DidSetComputedStyle
(
ComputedStyle
*
aOldComputedStyle
)
{
nsContainerFrame
:
:
DidSetComputedStyle
(
aOldComputedStyle
)
;
if
(
!
aOldComputedStyle
)
return
;
nsTableFrame
*
tableFrame
=
GetTableFrame
(
)
;
if
(
tableFrame
-
>
IsBorderCollapse
(
)
&
&
tableFrame
-
>
BCRecalcNeeded
(
aOldComputedStyle
Style
(
)
)
)
{
TableArea
damageArea
(
0
GetRowIndex
(
)
tableFrame
-
>
GetColCount
(
)
1
)
;
tableFrame
-
>
AddBCDamageArea
(
damageArea
)
;
}
}
void
nsTableRowFrame
:
:
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
{
NS_ASSERTION
(
aListID
=
=
kPrincipalList
"
unexpected
child
list
"
)
;
DrainSelfOverflowList
(
)
;
const
nsFrameList
:
:
Slice
&
newCells
=
mFrames
.
AppendFrames
(
nullptr
aFrameList
)
;
nsTableFrame
*
tableFrame
=
GetTableFrame
(
)
;
for
(
nsFrameList
:
:
Enumerator
e
(
newCells
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
)
{
nsIFrame
*
childFrame
=
e
.
get
(
)
;
NS_ASSERTION
(
IsTableCell
(
childFrame
-
>
Type
(
)
)
"
Not
a
table
cell
frame
/
pseudo
frame
construction
failure
"
)
;
tableFrame
-
>
AppendCell
(
static_cast
<
nsTableCellFrame
&
>
(
*
childFrame
)
GetRowIndex
(
)
)
;
}
PresShell
(
)
-
>
FrameNeedsReflow
(
this
nsIPresShell
:
:
eTreeChange
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
tableFrame
-
>
SetGeometryDirty
(
)
;
}
void
nsTableRowFrame
:
:
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
aFrameList
)
{
NS_ASSERTION
(
aListID
=
=
kPrincipalList
"
unexpected
child
list
"
)
;
NS_ASSERTION
(
!
aPrevFrame
|
|
aPrevFrame
-
>
GetParent
(
)
=
=
this
"
inserting
after
sibling
frame
with
different
parent
"
)
;
if
(
mFrames
.
IsEmpty
(
)
|
|
(
aPrevFrame
&
&
!
aPrevFrame
-
>
GetNextSibling
(
)
)
)
{
AppendFrames
(
aListID
aFrameList
)
;
return
;
}
DrainSelfOverflowList
(
)
;
const
nsFrameList
:
:
Slice
&
newCells
=
mFrames
.
InsertFrames
(
nullptr
aPrevFrame
aFrameList
)
;
nsTableFrame
*
tableFrame
=
GetTableFrame
(
)
;
LayoutFrameType
cellFrameType
=
tableFrame
-
>
IsBorderCollapse
(
)
?
LayoutFrameType
:
:
BCTableCell
:
LayoutFrameType
:
:
TableCell
;
nsTableCellFrame
*
prevCellFrame
=
(
nsTableCellFrame
*
)
nsTableFrame
:
:
GetFrameAtOrBefore
(
this
aPrevFrame
cellFrameType
)
;
nsTArray
<
nsTableCellFrame
*
>
cellChildren
;
for
(
nsFrameList
:
:
Enumerator
e
(
newCells
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
)
{
nsIFrame
*
childFrame
=
e
.
get
(
)
;
NS_ASSERTION
(
IsTableCell
(
childFrame
-
>
Type
(
)
)
"
Not
a
table
cell
frame
/
pseudo
frame
construction
failure
"
)
;
cellChildren
.
AppendElement
(
static_cast
<
nsTableCellFrame
*
>
(
childFrame
)
)
;
}
int32_t
colIndex
=
-
1
;
if
(
prevCellFrame
)
{
colIndex
=
prevCellFrame
-
>
ColIndex
(
)
;
}
tableFrame
-
>
InsertCells
(
cellChildren
GetRowIndex
(
)
colIndex
)
;
PresShell
(
)
-
>
FrameNeedsReflow
(
this
nsIPresShell
:
:
eTreeChange
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
tableFrame
-
>
SetGeometryDirty
(
)
;
}
void
nsTableRowFrame
:
:
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
{
NS_ASSERTION
(
aListID
=
=
kPrincipalList
"
unexpected
child
list
"
)
;
MOZ_ASSERT
(
(
nsTableCellFrame
*
)
do_QueryFrame
(
aOldFrame
)
)
;
nsTableCellFrame
*
cellFrame
=
static_cast
<
nsTableCellFrame
*
>
(
aOldFrame
)
;
nsTableFrame
*
tableFrame
=
GetTableFrame
(
)
;
tableFrame
-
>
RemoveCell
(
cellFrame
GetRowIndex
(
)
)
;
mFrames
.
DestroyFrame
(
aOldFrame
)
;
PresShell
(
)
-
>
FrameNeedsReflow
(
this
nsIPresShell
:
:
eTreeChange
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
tableFrame
-
>
SetGeometryDirty
(
)
;
}
nsMargin
nsTableRowFrame
:
:
GetUsedMargin
(
)
const
{
return
nsMargin
(
0
0
0
0
)
;
}
nsMargin
nsTableRowFrame
:
:
GetUsedBorder
(
)
const
{
return
nsMargin
(
0
0
0
0
)
;
}
nsMargin
nsTableRowFrame
:
:
GetUsedPadding
(
)
const
{
return
nsMargin
(
0
0
0
0
)
;
}
static
nscoord
GetBSizeOfRowsSpannedBelowFirst
(
nsTableCellFrame
&
aTableCellFrame
nsTableFrame
&
aTableFrame
const
WritingMode
aWM
)
{
nscoord
bsize
=
0
;
int32_t
rowSpan
=
aTableFrame
.
GetEffectiveRowSpan
(
aTableCellFrame
)
;
nsIFrame
*
nextRow
=
aTableCellFrame
.
GetParent
(
)
-
>
GetNextSibling
(
)
;
for
(
int32_t
rowX
=
1
;
(
(
rowX
<
rowSpan
)
&
&
nextRow
)
;
)
{
if
(
nextRow
-
>
IsTableRowFrame
(
)
)
{
bsize
+
=
nextRow
-
>
BSize
(
aWM
)
;
rowX
+
+
;
}
bsize
+
=
aTableFrame
.
GetRowSpacing
(
rowX
)
;
nextRow
=
nextRow
-
>
GetNextSibling
(
)
;
}
return
bsize
;
}
void
nsTableRowFrame
:
:
DidResize
(
)
{
nsTableFrame
*
tableFrame
=
GetTableFrame
(
)
;
WritingMode
wm
=
GetWritingMode
(
)
;
ReflowOutput
desiredSize
(
wm
)
;
desiredSize
.
SetSize
(
wm
GetLogicalSize
(
wm
)
)
;
desiredSize
.
SetOverflowAreasToDesiredBounds
(
)
;
nsSize
containerSize
=
mRect
.
Size
(
)
;
for
(
nsIFrame
*
childFrame
:
mFrames
)
{
nsTableCellFrame
*
cellFrame
=
do_QueryFrame
(
childFrame
)
;
if
(
cellFrame
)
{
nscoord
cellBSize
=
BSize
(
wm
)
+
GetBSizeOfRowsSpannedBelowFirst
(
*
cellFrame
*
tableFrame
wm
)
;
LogicalSize
cellSize
=
cellFrame
-
>
GetLogicalSize
(
wm
)
;
if
(
cellSize
.
BSize
(
wm
)
!
=
cellBSize
|
|
wm
.
IsVerticalRL
(
)
)
{
nsRect
cellOldRect
=
cellFrame
-
>
GetRect
(
)
;
nsRect
cellVisualOverflow
=
cellFrame
-
>
GetVisualOverflowRect
(
)
;
if
(
wm
.
IsVerticalRL
(
)
)
{
LogicalPoint
oldPos
=
cellFrame
-
>
GetLogicalPosition
(
wm
containerSize
)
;
LogicalPoint
newPos
(
wm
oldPos
.
I
(
wm
)
0
)
;
if
(
cellFrame
-
>
IsRelativelyPositioned
(
)
)
{
LogicalPoint
oldNormalPos
=
cellFrame
-
>
GetLogicalNormalPosition
(
wm
containerSize
)
;
newPos
.
B
(
wm
)
=
oldPos
.
B
(
wm
)
-
oldNormalPos
.
B
(
wm
)
;
}
if
(
oldPos
!
=
newPos
)
{
cellFrame
-
>
SetPosition
(
wm
newPos
containerSize
)
;
nsTableFrame
:
:
RePositionViews
(
cellFrame
)
;
}
}
cellSize
.
BSize
(
wm
)
=
cellBSize
;
cellFrame
-
>
SetSize
(
wm
cellSize
)
;
nsTableFrame
*
tableFrame
=
GetTableFrame
(
)
;
if
(
tableFrame
-
>
IsBorderCollapse
(
)
)
{
nsTableFrame
:
:
InvalidateTableFrame
(
cellFrame
cellOldRect
cellVisualOverflow
false
)
;
}
}
cellFrame
-
>
BlockDirAlignChild
(
wm
mMaxCellAscent
)
;
ConsiderChildOverflow
(
desiredSize
.
mOverflowAreas
cellFrame
)
;
}
}
FinishAndStoreOverflow
(
&
desiredSize
)
;
if
(
HasView
(
)
)
{
nsContainerFrame
:
:
SyncFrameViewAfterReflow
(
PresContext
(
)
this
GetView
(
)
desiredSize
.
VisualOverflow
(
)
0
)
;
}
}
nscoord
nsTableRowFrame
:
:
GetMaxCellAscent
(
)
const
{
return
mMaxCellAscent
;
}
nscoord
nsTableRowFrame
:
:
GetRowBaseline
(
WritingMode
aWM
)
{
if
(
mMaxCellAscent
)
{
return
mMaxCellAscent
;
}
nscoord
ascent
=
0
;
nsSize
containerSize
=
GetSize
(
)
;
for
(
nsIFrame
*
childFrame
:
mFrames
)
{
if
(
IsTableCell
(
childFrame
-
>
Type
(
)
)
)
{
nsIFrame
*
firstKid
=
childFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
ascent
=
std
:
:
max
(
ascent
LogicalRect
(
aWM
firstKid
-
>
GetNormalRect
(
)
containerSize
)
.
BEnd
(
aWM
)
)
;
}
}
return
ascent
;
}
nscoord
nsTableRowFrame
:
:
GetInitialBSize
(
nscoord
aPctBasis
)
const
{
nscoord
bsize
=
0
;
if
(
(
aPctBasis
>
0
)
&
&
HasPctBSize
(
)
)
{
bsize
=
NSToCoordRound
(
GetPctBSize
(
)
*
(
float
)
aPctBasis
)
;
}
if
(
HasFixedBSize
(
)
)
{
bsize
=
std
:
:
max
(
bsize
GetFixedBSize
(
)
)
;
}
return
std
:
:
max
(
bsize
GetContentBSize
(
)
)
;
}
void
nsTableRowFrame
:
:
ResetBSize
(
nscoord
aFixedBSize
)
{
SetHasFixedBSize
(
false
)
;
SetHasPctBSize
(
false
)
;
SetFixedBSize
(
0
)
;
SetPctBSize
(
0
)
;
SetContentBSize
(
0
)
;
if
(
aFixedBSize
>
0
)
{
SetFixedBSize
(
aFixedBSize
)
;
}
mMaxCellAscent
=
0
;
mMaxCellDescent
=
0
;
}
void
nsTableRowFrame
:
:
UpdateBSize
(
nscoord
aBSize
nscoord
aAscent
nscoord
aDescent
nsTableFrame
*
aTableFrame
nsTableCellFrame
*
aCellFrame
)
{
if
(
!
aTableFrame
|
|
!
aCellFrame
)
{
NS_ASSERTION
(
false
"
invalid
call
"
)
;
return
;
}
if
(
aBSize
!
=
NS_UNCONSTRAINEDSIZE
)
{
if
(
!
(
aCellFrame
-
>
HasVerticalAlignBaseline
(
)
)
)
{
if
(
GetInitialBSize
(
)
<
aBSize
)
{
int32_t
rowSpan
=
aTableFrame
-
>
GetEffectiveRowSpan
(
*
aCellFrame
)
;
if
(
rowSpan
=
=
1
)
{
SetContentBSize
(
aBSize
)
;
}
}
}
else
{
NS_ASSERTION
(
(
aAscent
!
=
NS_UNCONSTRAINEDSIZE
)
&
&
(
aDescent
!
=
NS_UNCONSTRAINEDSIZE
)
"
invalid
call
"
)
;
if
(
mMaxCellAscent
<
aAscent
)
{
mMaxCellAscent
=
aAscent
;
}
if
(
mMaxCellDescent
<
aDescent
)
{
int32_t
rowSpan
=
aTableFrame
-
>
GetEffectiveRowSpan
(
*
aCellFrame
)
;
if
(
rowSpan
=
=
1
)
{
mMaxCellDescent
=
aDescent
;
}
}
if
(
GetInitialBSize
(
)
<
mMaxCellAscent
+
mMaxCellDescent
)
{
SetContentBSize
(
mMaxCellAscent
+
mMaxCellDescent
)
;
}
}
}
}
nscoord
nsTableRowFrame
:
:
CalcBSize
(
const
ReflowInput
&
aReflowInput
)
{
nsTableFrame
*
tableFrame
=
GetTableFrame
(
)
;
nscoord
computedBSize
=
(
NS_UNCONSTRAINEDSIZE
=
=
aReflowInput
.
ComputedBSize
(
)
)
?
0
:
aReflowInput
.
ComputedBSize
(
)
;
ResetBSize
(
computedBSize
)
;
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
const
nsStylePosition
*
position
=
StylePosition
(
)
;
const
auto
&
bsizeStyleCoord
=
position
-
>
BSize
(
wm
)
;
if
(
bsizeStyleCoord
.
ConvertsToLength
(
)
)
{
SetFixedBSize
(
bsizeStyleCoord
.
ToLength
(
)
)
;
}
else
if
(
bsizeStyleCoord
.
ConvertsToPercentage
(
)
)
{
SetPctBSize
(
bsizeStyleCoord
.
ToPercentage
(
)
)
;
}
for
(
nsIFrame
*
kidFrame
:
mFrames
)
{
nsTableCellFrame
*
cellFrame
=
do_QueryFrame
(
kidFrame
)
;
if
(
cellFrame
)
{
MOZ_ASSERT
(
cellFrame
-
>
GetWritingMode
(
)
=
=
wm
)
;
LogicalSize
desSize
=
cellFrame
-
>
GetDesiredSize
(
)
;
if
(
(
NS_UNCONSTRAINEDSIZE
=
=
aReflowInput
.
AvailableBSize
(
)
)
&
&
!
GetPrevInFlow
(
)
)
{
CalculateCellActualBSize
(
cellFrame
desSize
.
BSize
(
wm
)
wm
)
;
}
nscoord
ascent
;
if
(
!
kidFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
)
ascent
=
desSize
.
BSize
(
wm
)
;
else
ascent
=
cellFrame
-
>
GetCellBaseline
(
)
;
nscoord
descent
=
desSize
.
BSize
(
wm
)
-
ascent
;
UpdateBSize
(
desSize
.
BSize
(
wm
)
ascent
descent
tableFrame
cellFrame
)
;
}
}
return
GetInitialBSize
(
)
;
}
void
nsTableRowFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
nsTableFrame
:
:
DisplayGenericTablePart
(
aBuilder
this
aLists
)
;
}
nsIFrame
:
:
LogicalSides
nsTableRowFrame
:
:
GetLogicalSkipSides
(
const
ReflowInput
*
aReflowInput
)
const
{
if
(
MOZ_UNLIKELY
(
StyleBorder
(
)
-
>
mBoxDecorationBreak
=
=
StyleBoxDecorationBreak
:
:
Clone
)
)
{
return
LogicalSides
(
)
;
}
LogicalSides
skip
;
if
(
nullptr
!
=
GetPrevInFlow
(
)
)
{
skip
|
=
eLogicalSideBitsBStart
;
}
if
(
nullptr
!
=
GetNextInFlow
(
)
)
{
skip
|
=
eLogicalSideBitsBEnd
;
}
return
skip
;
}
nsresult
nsTableRowFrame
:
:
CalculateCellActualBSize
(
nsTableCellFrame
*
aCellFrame
nscoord
&
aDesiredBSize
WritingMode
aWM
)
{
nscoord
specifiedBSize
=
0
;
const
nsStylePosition
*
position
=
aCellFrame
-
>
StylePosition
(
)
;
int32_t
rowSpan
=
GetTableFrame
(
)
-
>
GetEffectiveRowSpan
(
*
aCellFrame
)
;
const
auto
&
bsizeStyleCoord
=
position
-
>
BSize
(
aWM
)
;
if
(
bsizeStyleCoord
.
ConvertsToLength
(
)
)
{
specifiedBSize
=
bsizeStyleCoord
.
ToLength
(
)
;
if
(
PresContext
(
)
-
>
CompatibilityMode
(
)
!
=
eCompatibility_NavQuirks
&
&
position
-
>
mBoxSizing
=
=
StyleBoxSizing
:
:
Content
)
{
specifiedBSize
+
=
aCellFrame
-
>
GetLogicalUsedBorderAndPadding
(
aWM
)
.
BStartEnd
(
aWM
)
;
}
if
(
1
=
=
rowSpan
)
{
SetFixedBSize
(
specifiedBSize
)
;
}
}
else
if
(
bsizeStyleCoord
.
ConvertsToPercentage
(
)
)
{
if
(
1
=
=
rowSpan
)
{
SetPctBSize
(
bsizeStyleCoord
.
ToPercentage
(
)
)
;
}
}
if
(
specifiedBSize
>
aDesiredBSize
)
{
aDesiredBSize
=
specifiedBSize
;
}
return
NS_OK
;
}
static
nscoord
CalcAvailISize
(
nsTableFrame
&
aTableFrame
nsTableCellFrame
&
aCellFrame
)
{
nscoord
cellAvailISize
=
0
;
uint32_t
colIndex
=
aCellFrame
.
ColIndex
(
)
;
int32_t
colspan
=
aTableFrame
.
GetEffectiveColSpan
(
aCellFrame
)
;
NS_ASSERTION
(
colspan
>
0
"
effective
colspan
should
be
positive
"
)
;
nsTableFrame
*
fifTable
=
static_cast
<
nsTableFrame
*
>
(
aTableFrame
.
FirstInFlow
(
)
)
;
for
(
int32_t
spanX
=
0
;
spanX
<
colspan
;
spanX
+
+
)
{
cellAvailISize
+
=
fifTable
-
>
GetColumnISizeFromFirstInFlow
(
colIndex
+
spanX
)
;
if
(
spanX
>
0
&
&
aTableFrame
.
ColumnHasCellSpacingBefore
(
colIndex
+
spanX
)
)
{
cellAvailISize
+
=
aTableFrame
.
GetColSpacing
(
colIndex
+
spanX
-
1
)
;
}
}
return
cellAvailISize
;
}
static
nscoord
GetSpaceBetween
(
int32_t
aPrevColIndex
int32_t
aColIndex
int32_t
aColSpan
nsTableFrame
&
aTableFrame
bool
aCheckVisibility
)
{
nscoord
space
=
0
;
int32_t
colIdx
;
nsTableFrame
*
fifTable
=
static_cast
<
nsTableFrame
*
>
(
aTableFrame
.
FirstInFlow
(
)
)
;
for
(
colIdx
=
aPrevColIndex
+
1
;
aColIndex
>
colIdx
;
colIdx
+
+
)
{
bool
isCollapsed
=
false
;
if
(
!
aCheckVisibility
)
{
space
+
=
fifTable
-
>
GetColumnISizeFromFirstInFlow
(
colIdx
)
;
}
else
{
nsTableColFrame
*
colFrame
=
aTableFrame
.
GetColFrame
(
colIdx
)
;
const
nsStyleVisibility
*
colVis
=
colFrame
-
>
StyleVisibility
(
)
;
bool
collapseCol
=
(
NS_STYLE_VISIBILITY_COLLAPSE
=
=
colVis
-
>
mVisible
)
;
nsIFrame
*
cgFrame
=
colFrame
-
>
GetParent
(
)
;
const
nsStyleVisibility
*
groupVis
=
cgFrame
-
>
StyleVisibility
(
)
;
bool
collapseGroup
=
(
NS_STYLE_VISIBILITY_COLLAPSE
=
=
groupVis
-
>
mVisible
)
;
isCollapsed
=
collapseCol
|
|
collapseGroup
;
if
(
!
isCollapsed
)
space
+
=
fifTable
-
>
GetColumnISizeFromFirstInFlow
(
colIdx
)
;
}
if
(
!
isCollapsed
&
&
aTableFrame
.
ColumnHasCellSpacingBefore
(
colIdx
)
)
{
space
+
=
aTableFrame
.
GetColSpacing
(
colIdx
-
1
)
;
}
}
return
space
;
}
static
nscoord
CalcBSizeFromUnpaginatedBSize
(
nsTableRowFrame
&
aRow
WritingMode
aWM
)
{
nscoord
bsize
=
0
;
nsTableRowFrame
*
firstInFlow
=
static_cast
<
nsTableRowFrame
*
>
(
aRow
.
FirstInFlow
(
)
)
;
if
(
firstInFlow
-
>
HasUnpaginatedBSize
(
)
)
{
bsize
=
firstInFlow
-
>
GetUnpaginatedBSize
(
)
;
for
(
nsIFrame
*
prevInFlow
=
aRow
.
GetPrevInFlow
(
)
;
prevInFlow
;
prevInFlow
=
prevInFlow
-
>
GetPrevInFlow
(
)
)
{
bsize
-
=
prevInFlow
-
>
BSize
(
aWM
)
;
}
}
return
std
:
:
max
(
bsize
0
)
;
}
void
nsTableRowFrame
:
:
ReflowChildren
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsTableFrame
&
aTableFrame
nsReflowStatus
&
aStatus
)
{
aStatus
.
Reset
(
)
;
const
bool
isPaginated
=
aPresContext
-
>
IsPaginated
(
)
;
const
bool
borderCollapse
=
aTableFrame
.
IsBorderCollapse
(
)
;
int32_t
cellColSpan
=
1
;
int32_t
prevColIndex
=
-
1
;
nscoord
iCoord
=
0
;
nscoord
cellMaxBSize
=
0
;
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
nsSize
containerSize
=
aReflowInput
.
ComputedSizeAsContainerIfConstrained
(
)
;
for
(
nsIFrame
*
kidFrame
:
mFrames
)
{
nsTableCellFrame
*
cellFrame
=
do_QueryFrame
(
kidFrame
)
;
if
(
!
cellFrame
)
{
MOZ_ASSERT_UNREACHABLE
(
"
yikes
a
non
-
row
child
"
)
;
TableCellReflowInput
kidReflowInput
(
aPresContext
aReflowInput
kidFrame
LogicalSize
(
kidFrame
-
>
GetWritingMode
(
)
0
0
)
ReflowInput
:
:
CALLER_WILL_INIT
)
;
InitChildReflowInput
(
*
aPresContext
LogicalSize
(
wm
)
false
kidReflowInput
)
;
ReflowOutput
desiredSize
(
aReflowInput
)
;
nsReflowStatus
status
;
ReflowChild
(
kidFrame
aPresContext
desiredSize
kidReflowInput
0
0
0
status
)
;
kidFrame
-
>
DidReflow
(
aPresContext
nullptr
)
;
continue
;
}
bool
doReflowChild
=
true
;
if
(
!
aReflowInput
.
ShouldReflowAllKids
(
)
&
&
!
aTableFrame
.
IsGeometryDirty
(
)
&
&
!
NS_SUBTREE_DIRTY
(
kidFrame
)
)
{
if
(
!
aReflowInput
.
mFlags
.
mSpecialBSizeReflow
)
doReflowChild
=
false
;
}
else
if
(
(
NS_UNCONSTRAINEDSIZE
!
=
aReflowInput
.
AvailableBSize
(
)
)
)
{
if
(
aTableFrame
.
GetEffectiveRowSpan
(
*
cellFrame
)
>
1
)
{
doReflowChild
=
false
;
}
}
if
(
aReflowInput
.
mFlags
.
mSpecialBSizeReflow
)
{
if
(
!
isPaginated
&
&
!
cellFrame
-
>
HasAnyStateBits
(
NS_FRAME_CONTAINS_RELATIVE_BSIZE
)
)
{
continue
;
}
}
uint32_t
cellColIndex
=
cellFrame
-
>
ColIndex
(
)
;
cellColSpan
=
aTableFrame
.
GetEffectiveColSpan
(
*
cellFrame
)
;
if
(
prevColIndex
!
=
(
static_cast
<
int32_t
>
(
cellColIndex
)
-
1
)
)
{
iCoord
+
=
GetSpaceBetween
(
prevColIndex
cellColIndex
cellColSpan
aTableFrame
false
)
;
}
prevColIndex
=
cellColIndex
+
(
cellColSpan
-
1
)
;
nsRect
kidRect
=
kidFrame
-
>
GetRect
(
)
;
LogicalPoint
origKidNormalPosition
=
kidFrame
-
>
GetLogicalNormalPosition
(
wm
containerSize
)
;
NS_ASSERTION
(
origKidNormalPosition
.
B
(
wm
)
=
=
0
|
|
wm
.
IsVerticalRL
(
)
"
unexpected
kid
position
"
)
;
nsRect
kidVisualOverflow
=
kidFrame
-
>
GetVisualOverflowRect
(
)
;
LogicalPoint
kidPosition
(
wm
iCoord
0
)
;
bool
firstReflow
=
kidFrame
-
>
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
;
if
(
doReflowChild
)
{
nscoord
availCellISize
=
CalcAvailISize
(
aTableFrame
*
cellFrame
)
;
Maybe
<
TableCellReflowInput
>
kidReflowInput
;
ReflowOutput
desiredSize
(
aReflowInput
)
;
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
NS_ASSERTION
(
cellFrame
-
>
GetWritingMode
(
)
=
=
wm
"
expected
consistent
writing
-
mode
within
table
"
)
;
LogicalSize
cellDesiredSize
=
cellFrame
-
>
GetDesiredSize
(
)
;
if
(
(
availCellISize
!
=
cellFrame
-
>
GetPriorAvailISize
(
)
)
|
|
(
cellDesiredSize
.
ISize
(
wm
)
>
cellFrame
-
>
GetPriorAvailISize
(
)
)
|
|
HasAnyStateBits
(
NS_FRAME_IS_DIRTY
)
|
|
isPaginated
|
|
NS_SUBTREE_DIRTY
(
cellFrame
)
|
|
cellFrame
-
>
HasAnyStateBits
(
NS_FRAME_CONTAINS_RELATIVE_BSIZE
)
|
|
HasPctBSize
(
)
)
{
LogicalSize
kidAvailSize
(
wm
availCellISize
aReflowInput
.
AvailableBSize
(
)
)
;
kidReflowInput
.
emplace
(
aPresContext
aReflowInput
kidFrame
kidAvailSize
ReflowInput
:
:
CALLER_WILL_INIT
)
;
InitChildReflowInput
(
*
aPresContext
kidAvailSize
borderCollapse
*
kidReflowInput
)
;
nsReflowStatus
status
;
ReflowChild
(
kidFrame
aPresContext
desiredSize
*
kidReflowInput
wm
kidPosition
containerSize
0
status
)
;
if
(
status
.
IsIncomplete
(
)
)
{
aStatus
.
Reset
(
)
;
aStatus
.
SetIncomplete
(
)
;
}
}
else
{
if
(
iCoord
!
=
origKidNormalPosition
.
I
(
wm
)
)
{
kidFrame
-
>
InvalidateFrameSubtree
(
)
;
}
desiredSize
.
SetSize
(
wm
cellDesiredSize
)
;
desiredSize
.
mOverflowAreas
=
cellFrame
-
>
GetOverflowAreas
(
)
;
if
(
!
aTableFrame
.
IsFloating
(
)
)
{
nsTableFrame
:
:
RePositionViews
(
kidFrame
)
;
}
}
if
(
NS_UNCONSTRAINEDSIZE
=
=
aReflowInput
.
AvailableBSize
(
)
)
{
if
(
!
GetPrevInFlow
(
)
)
{
CalculateCellActualBSize
(
cellFrame
desiredSize
.
BSize
(
wm
)
wm
)
;
}
nscoord
ascent
;
if
(
!
kidFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
)
{
ascent
=
desiredSize
.
BSize
(
wm
)
;
}
else
{
ascent
=
(
(
nsTableCellFrame
*
)
kidFrame
)
-
>
GetCellBaseline
(
)
;
}
nscoord
descent
=
desiredSize
.
BSize
(
wm
)
-
ascent
;
UpdateBSize
(
desiredSize
.
BSize
(
wm
)
ascent
descent
&
aTableFrame
cellFrame
)
;
}
else
{
cellMaxBSize
=
std
:
:
max
(
cellMaxBSize
desiredSize
.
BSize
(
wm
)
)
;
int32_t
rowSpan
=
aTableFrame
.
GetEffectiveRowSpan
(
(
nsTableCellFrame
&
)
*
kidFrame
)
;
if
(
1
=
=
rowSpan
)
{
SetContentBSize
(
cellMaxBSize
)
;
}
}
desiredSize
.
ISize
(
wm
)
=
availCellISize
;
if
(
kidReflowInput
)
{
kidReflowInput
-
>
ApplyRelativePositioning
(
&
kidPosition
containerSize
)
;
}
else
if
(
kidFrame
-
>
IsRelativelyPositioned
(
)
)
{
nsMargin
*
computedOffsetProp
=
kidFrame
-
>
GetProperty
(
nsIFrame
:
:
ComputedOffsetProperty
(
)
)
;
LogicalMargin
computedOffsets
(
wm
computedOffsetProp
?
*
computedOffsetProp
:
nsMargin
(
)
)
;
ReflowInput
:
:
ApplyRelativePositioning
(
kidFrame
wm
computedOffsets
&
kidPosition
containerSize
)
;
}
FinishReflowChild
(
kidFrame
aPresContext
desiredSize
nullptr
wm
kidPosition
containerSize
0
)
;
nsTableFrame
*
tableFrame
=
GetTableFrame
(
)
;
if
(
tableFrame
-
>
IsBorderCollapse
(
)
)
{
nsTableFrame
:
:
InvalidateTableFrame
(
kidFrame
kidRect
kidVisualOverflow
firstReflow
)
;
}
iCoord
+
=
desiredSize
.
ISize
(
wm
)
;
}
else
{
if
(
iCoord
!
=
origKidNormalPosition
.
I
(
wm
)
)
{
kidFrame
-
>
InvalidateFrameSubtree
(
)
;
kidFrame
-
>
MovePositionBy
(
wm
LogicalPoint
(
wm
iCoord
-
origKidNormalPosition
.
I
(
wm
)
0
)
)
;
nsTableFrame
:
:
RePositionViews
(
kidFrame
)
;
kidFrame
-
>
InvalidateFrameSubtree
(
)
;
}
iCoord
+
=
kidFrame
-
>
ISize
(
wm
)
;
if
(
kidFrame
-
>
GetNextInFlow
(
)
)
{
aStatus
.
Reset
(
)
;
aStatus
.
SetIncomplete
(
)
;
}
}
ConsiderChildOverflow
(
aDesiredSize
.
mOverflowAreas
kidFrame
)
;
iCoord
+
=
aTableFrame
.
GetColSpacing
(
cellColIndex
)
;
}
aDesiredSize
.
ISize
(
wm
)
=
aReflowInput
.
AvailableISize
(
)
;
if
(
aReflowInput
.
mFlags
.
mSpecialBSizeReflow
)
{
aDesiredSize
.
BSize
(
wm
)
=
BSize
(
wm
)
;
}
else
if
(
NS_UNCONSTRAINEDSIZE
=
=
aReflowInput
.
AvailableBSize
(
)
)
{
aDesiredSize
.
BSize
(
wm
)
=
CalcBSize
(
aReflowInput
)
;
if
(
GetPrevInFlow
(
)
)
{
nscoord
bsize
=
CalcBSizeFromUnpaginatedBSize
(
*
this
wm
)
;
aDesiredSize
.
BSize
(
wm
)
=
std
:
:
max
(
aDesiredSize
.
BSize
(
wm
)
bsize
)
;
}
else
{
if
(
isPaginated
&
&
HasStyleBSize
(
)
)
{
SetHasUnpaginatedBSize
(
true
)
;
SetUnpaginatedBSize
(
aPresContext
aDesiredSize
.
BSize
(
wm
)
)
;
}
if
(
isPaginated
&
&
HasUnpaginatedBSize
(
)
)
{
aDesiredSize
.
BSize
(
wm
)
=
std
:
:
max
(
aDesiredSize
.
BSize
(
wm
)
GetUnpaginatedBSize
(
)
)
;
}
}
}
else
{
nscoord
styleBSize
=
CalcBSizeFromUnpaginatedBSize
(
*
this
wm
)
;
if
(
styleBSize
>
aReflowInput
.
AvailableBSize
(
)
)
{
styleBSize
=
aReflowInput
.
AvailableBSize
(
)
;
aStatus
.
SetIncomplete
(
)
;
}
aDesiredSize
.
BSize
(
wm
)
=
std
:
:
max
(
cellMaxBSize
styleBSize
)
;
}
if
(
wm
.
IsVerticalRL
(
)
)
{
for
(
nsIFrame
*
kidFrame
:
mFrames
)
{
nsTableCellFrame
*
cellFrame
=
do_QueryFrame
(
kidFrame
)
;
if
(
!
cellFrame
)
{
continue
;
}
if
(
kidFrame
-
>
BSize
(
wm
)
!
=
aDesiredSize
.
BSize
(
wm
)
)
{
kidFrame
-
>
MovePositionBy
(
wm
LogicalPoint
(
wm
0
kidFrame
-
>
BSize
(
wm
)
-
aDesiredSize
.
BSize
(
wm
)
)
)
;
nsTableFrame
:
:
RePositionViews
(
kidFrame
)
;
}
}
}
aDesiredSize
.
UnionOverflowAreasWithDesiredBounds
(
)
;
FinishAndStoreOverflow
(
&
aDesiredSize
)
;
}
void
nsTableRowFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsTableRowFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aDesiredSize
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
nsTableFrame
*
tableFrame
=
GetTableFrame
(
)
;
const
nsStyleVisibility
*
rowVis
=
StyleVisibility
(
)
;
bool
collapseRow
=
(
NS_STYLE_VISIBILITY_COLLAPSE
=
=
rowVis
-
>
mVisible
)
;
if
(
collapseRow
)
{
tableFrame
-
>
SetNeedToCollapse
(
true
)
;
}
nsTableFrame
:
:
CheckRequestSpecialBSizeReflow
(
aReflowInput
)
;
InitHasCellWithStyleBSize
(
tableFrame
)
;
ReflowChildren
(
aPresContext
aDesiredSize
aReflowInput
*
tableFrame
aStatus
)
;
if
(
aPresContext
-
>
IsPaginated
(
)
&
&
!
aStatus
.
IsFullyComplete
(
)
&
&
ShouldAvoidBreakInside
(
aReflowInput
)
)
{
aStatus
.
SetInlineLineBreakBeforeAndReset
(
)
;
}
aDesiredSize
.
ISize
(
wm
)
=
aReflowInput
.
AvailableISize
(
)
;
if
(
!
GetParent
(
)
-
>
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
&
&
nsSize
(
aDesiredSize
.
Width
(
)
aDesiredSize
.
Height
(
)
)
!
=
mRect
.
Size
(
)
)
{
InvalidateFrame
(
)
;
}
PushDirtyBitToAbsoluteFrames
(
)
;
NS_FRAME_SET_TRUNCATION
(
aStatus
aReflowInput
aDesiredSize
)
;
}
nscoord
nsTableRowFrame
:
:
ReflowCellFrame
(
nsPresContext
*
aPresContext
const
ReflowInput
&
aReflowInput
bool
aIsTopOfPage
nsTableCellFrame
*
aCellFrame
nscoord
aAvailableBSize
nsReflowStatus
&
aStatus
)
{
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
nsSize
containerSize
=
aCellFrame
-
>
GetSize
(
)
;
LogicalRect
cellRect
=
aCellFrame
-
>
GetLogicalRect
(
wm
containerSize
)
;
nsRect
cellVisualOverflow
=
aCellFrame
-
>
GetVisualOverflowRect
(
)
;
LogicalSize
cellSize
=
cellRect
.
Size
(
wm
)
;
LogicalSize
availSize
(
wm
cellRect
.
ISize
(
wm
)
aAvailableBSize
)
;
bool
borderCollapse
=
GetTableFrame
(
)
-
>
IsBorderCollapse
(
)
;
NS_ASSERTION
(
aCellFrame
-
>
GetWritingMode
(
)
=
=
wm
"
expected
consistent
writing
-
mode
within
table
"
)
;
TableCellReflowInput
cellReflowInput
(
aPresContext
aReflowInput
aCellFrame
availSize
ReflowInput
:
:
CALLER_WILL_INIT
)
;
InitChildReflowInput
(
*
aPresContext
availSize
borderCollapse
cellReflowInput
)
;
cellReflowInput
.
mFlags
.
mIsTopOfPage
=
aIsTopOfPage
;
ReflowOutput
desiredSize
(
aReflowInput
)
;
ReflowChild
(
aCellFrame
aPresContext
desiredSize
cellReflowInput
0
0
NS_FRAME_NO_MOVE_FRAME
aStatus
)
;
bool
fullyComplete
=
aStatus
.
IsComplete
(
)
&
&
!
aStatus
.
IsTruncated
(
)
;
if
(
fullyComplete
)
{
desiredSize
.
BSize
(
wm
)
=
aAvailableBSize
;
}
aCellFrame
-
>
SetSize
(
wm
LogicalSize
(
wm
cellSize
.
ISize
(
wm
)
desiredSize
.
BSize
(
wm
)
)
)
;
if
(
fullyComplete
)
{
aCellFrame
-
>
BlockDirAlignChild
(
wm
mMaxCellAscent
)
;
}
nsTableFrame
:
:
InvalidateTableFrame
(
aCellFrame
cellRect
.
GetPhysicalRect
(
wm
containerSize
)
cellVisualOverflow
aCellFrame
-
>
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
)
;
aCellFrame
-
>
DidReflow
(
aPresContext
nullptr
)
;
return
desiredSize
.
BSize
(
wm
)
;
}
nscoord
nsTableRowFrame
:
:
CollapseRowIfNecessary
(
nscoord
aRowOffset
nscoord
aISize
bool
aCollapseGroup
bool
&
aDidCollapse
)
{
const
nsStyleVisibility
*
rowVis
=
StyleVisibility
(
)
;
bool
collapseRow
=
(
NS_STYLE_VISIBILITY_COLLAPSE
=
=
rowVis
-
>
mVisible
)
;
nsTableFrame
*
tableFrame
=
static_cast
<
nsTableFrame
*
>
(
GetTableFrame
(
)
-
>
FirstInFlow
(
)
)
;
if
(
collapseRow
)
{
tableFrame
-
>
SetNeedToCollapse
(
true
)
;
}
if
(
aRowOffset
!
=
0
)
{
InvalidateFrameSubtree
(
)
;
}
WritingMode
wm
=
GetWritingMode
(
)
;
nsSize
parentSize
=
GetParent
(
)
-
>
GetSize
(
)
;
LogicalRect
rowRect
=
GetLogicalRect
(
wm
parentSize
)
;
nsRect
oldRect
=
mRect
;
nsRect
oldVisualOverflow
=
GetVisualOverflowRect
(
)
;
rowRect
.
BStart
(
wm
)
-
=
aRowOffset
;
rowRect
.
ISize
(
wm
)
=
aISize
;
nsOverflowAreas
overflow
;
nscoord
shift
=
0
;
nsSize
containerSize
=
mRect
.
Size
(
)
;
if
(
aCollapseGroup
|
|
collapseRow
)
{
aDidCollapse
=
true
;
shift
=
rowRect
.
BSize
(
wm
)
;
nsTableCellFrame
*
cellFrame
=
GetFirstCell
(
)
;
if
(
cellFrame
)
{
uint32_t
rowIndex
=
cellFrame
-
>
RowIndex
(
)
;
shift
+
=
tableFrame
-
>
GetRowSpacing
(
rowIndex
)
;
while
(
cellFrame
)
{
LogicalRect
cRect
=
cellFrame
-
>
GetLogicalRect
(
wm
containerSize
)
;
if
(
aRowOffset
=
=
0
)
{
InvalidateFrame
(
)
;
}
cRect
.
BSize
(
wm
)
=
0
;
cellFrame
-
>
SetRect
(
wm
cRect
containerSize
)
;
cellFrame
=
cellFrame
-
>
GetNextCell
(
)
;
}
}
else
{
shift
+
=
tableFrame
-
>
GetRowSpacing
(
GetRowIndex
(
)
)
;
}
rowRect
.
BSize
(
wm
)
=
0
;
}
else
{
int32_t
prevColIndex
=
-
1
;
nscoord
iPos
=
0
;
nsTableFrame
*
fifTable
=
static_cast
<
nsTableFrame
*
>
(
tableFrame
-
>
FirstInFlow
(
)
)
;
for
(
nsIFrame
*
kidFrame
:
mFrames
)
{
nsTableCellFrame
*
cellFrame
=
do_QueryFrame
(
kidFrame
)
;
if
(
cellFrame
)
{
uint32_t
cellColIndex
=
cellFrame
-
>
ColIndex
(
)
;
int32_t
cellColSpan
=
tableFrame
-
>
GetEffectiveColSpan
(
*
cellFrame
)
;
if
(
prevColIndex
!
=
(
static_cast
<
int32_t
>
(
cellColIndex
)
-
1
)
)
{
iPos
+
=
GetSpaceBetween
(
prevColIndex
cellColIndex
cellColSpan
*
tableFrame
true
)
;
}
LogicalRect
cRect
(
wm
iPos
0
0
rowRect
.
BSize
(
wm
)
)
;
prevColIndex
=
cellColIndex
+
cellColSpan
-
1
;
int32_t
actualColSpan
=
cellColSpan
;
bool
isVisible
=
false
;
for
(
int32_t
colIdx
=
cellColIndex
;
actualColSpan
>
0
;
colIdx
+
+
actualColSpan
-
-
)
{
nsTableColFrame
*
colFrame
=
tableFrame
-
>
GetColFrame
(
colIdx
)
;
const
nsStyleVisibility
*
colVis
=
colFrame
-
>
StyleVisibility
(
)
;
bool
collapseCol
=
(
NS_STYLE_VISIBILITY_COLLAPSE
=
=
colVis
-
>
mVisible
)
;
nsIFrame
*
cgFrame
=
colFrame
-
>
GetParent
(
)
;
const
nsStyleVisibility
*
groupVis
=
cgFrame
-
>
StyleVisibility
(
)
;
bool
collapseGroup
=
(
NS_STYLE_VISIBILITY_COLLAPSE
=
=
groupVis
-
>
mVisible
)
;
bool
isCollapsed
=
collapseCol
|
|
collapseGroup
;
if
(
!
isCollapsed
)
{
cRect
.
ISize
(
wm
)
+
=
fifTable
-
>
GetColumnISizeFromFirstInFlow
(
colIdx
)
;
isVisible
=
true
;
if
(
(
actualColSpan
>
1
)
)
{
nsTableColFrame
*
nextColFrame
=
tableFrame
-
>
GetColFrame
(
colIdx
+
1
)
;
const
nsStyleVisibility
*
nextColVis
=
nextColFrame
-
>
StyleVisibility
(
)
;
if
(
(
NS_STYLE_VISIBILITY_COLLAPSE
!
=
nextColVis
-
>
mVisible
)
&
&
tableFrame
-
>
ColumnHasCellSpacingBefore
(
colIdx
+
1
)
)
{
cRect
.
ISize
(
wm
)
+
=
tableFrame
-
>
GetColSpacing
(
cellColIndex
)
;
}
}
}
}
iPos
+
=
cRect
.
ISize
(
wm
)
;
if
(
isVisible
)
{
iPos
+
=
tableFrame
-
>
GetColSpacing
(
cellColIndex
)
;
}
int32_t
actualRowSpan
=
tableFrame
-
>
GetEffectiveRowSpan
(
*
cellFrame
)
;
nsTableRowFrame
*
rowFrame
=
GetNextRow
(
)
;
for
(
actualRowSpan
-
-
;
actualRowSpan
>
0
&
&
rowFrame
;
actualRowSpan
-
-
)
{
const
nsStyleVisibility
*
nextRowVis
=
rowFrame
-
>
StyleVisibility
(
)
;
bool
collapseNextRow
=
(
NS_STYLE_VISIBILITY_COLLAPSE
=
=
nextRowVis
-
>
mVisible
)
;
if
(
!
collapseNextRow
)
{
LogicalRect
nextRect
=
rowFrame
-
>
GetLogicalRect
(
wm
containerSize
)
;
cRect
.
BSize
(
wm
)
+
=
nextRect
.
BSize
(
wm
)
+
tableFrame
-
>
GetRowSpacing
(
rowFrame
-
>
GetRowIndex
(
)
)
;
}
rowFrame
=
rowFrame
-
>
GetNextRow
(
)
;
}
nsRect
oldCellRect
=
cellFrame
-
>
GetRect
(
)
;
LogicalPoint
oldCellNormalPos
=
cellFrame
-
>
GetLogicalNormalPosition
(
wm
containerSize
)
;
nsRect
oldCellVisualOverflow
=
cellFrame
-
>
GetVisualOverflowRect
(
)
;
if
(
aRowOffset
=
=
0
&
&
cRect
.
Origin
(
wm
)
!
=
oldCellNormalPos
)
{
cellFrame
-
>
InvalidateFrameSubtree
(
)
;
}
cellFrame
-
>
MovePositionBy
(
wm
cRect
.
Origin
(
wm
)
-
oldCellNormalPos
)
;
cellFrame
-
>
SetSize
(
wm
cRect
.
Size
(
wm
)
)
;
LogicalRect
cellBounds
(
wm
0
0
cRect
.
ISize
(
wm
)
cRect
.
BSize
(
wm
)
)
;
nsRect
cellPhysicalBounds
=
cellBounds
.
GetPhysicalRect
(
wm
containerSize
)
;
nsOverflowAreas
cellOverflow
(
cellPhysicalBounds
cellPhysicalBounds
)
;
cellFrame
-
>
FinishAndStoreOverflow
(
cellOverflow
cRect
.
Size
(
wm
)
.
GetPhysicalSize
(
wm
)
)
;
nsTableFrame
:
:
RePositionViews
(
cellFrame
)
;
ConsiderChildOverflow
(
overflow
cellFrame
)
;
if
(
aRowOffset
=
=
0
)
{
nsTableFrame
:
:
InvalidateTableFrame
(
cellFrame
oldCellRect
oldCellVisualOverflow
false
)
;
}
}
}
}
SetRect
(
wm
rowRect
containerSize
)
;
overflow
.
UnionAllWith
(
nsRect
(
0
0
rowRect
.
Width
(
wm
)
rowRect
.
Height
(
wm
)
)
)
;
FinishAndStoreOverflow
(
overflow
rowRect
.
Size
(
wm
)
.
GetPhysicalSize
(
wm
)
)
;
nsTableFrame
:
:
RePositionViews
(
this
)
;
nsTableFrame
:
:
InvalidateTableFrame
(
this
oldRect
oldVisualOverflow
false
)
;
return
shift
;
}
void
nsTableRowFrame
:
:
InsertCellFrame
(
nsTableCellFrame
*
aFrame
int32_t
aColIndex
)
{
nsTableCellFrame
*
priorCell
=
nullptr
;
for
(
nsIFrame
*
child
:
mFrames
)
{
nsTableCellFrame
*
cellFrame
=
do_QueryFrame
(
child
)
;
if
(
cellFrame
)
{
uint32_t
colIndex
=
cellFrame
-
>
ColIndex
(
)
;
if
(
static_cast
<
int32_t
>
(
colIndex
)
<
aColIndex
)
{
priorCell
=
cellFrame
;
}
else
break
;
}
}
mFrames
.
InsertFrame
(
this
priorCell
aFrame
)
;
}
nsTableRowFrame
*
nsTableRowFrame
:
:
GetNextRow
(
)
const
{
nsIFrame
*
childFrame
=
GetNextSibling
(
)
;
while
(
childFrame
)
{
nsTableRowFrame
*
rowFrame
=
do_QueryFrame
(
childFrame
)
;
if
(
rowFrame
)
{
NS_ASSERTION
(
mozilla
:
:
StyleDisplay
:
:
TableRow
=
=
childFrame
-
>
StyleDisplay
(
)
-
>
mDisplay
"
wrong
display
type
on
rowframe
"
)
;
return
rowFrame
;
}
childFrame
=
childFrame
-
>
GetNextSibling
(
)
;
}
return
nullptr
;
}
NS_DECLARE_FRAME_PROPERTY_SMALL_VALUE
(
RowUnpaginatedHeightProperty
nscoord
)
void
nsTableRowFrame
:
:
SetUnpaginatedBSize
(
nsPresContext
*
aPresContext
nscoord
aValue
)
{
NS_ASSERTION
(
!
GetPrevInFlow
(
)
"
program
error
"
)
;
SetProperty
(
RowUnpaginatedHeightProperty
(
)
aValue
)
;
}
nscoord
nsTableRowFrame
:
:
GetUnpaginatedBSize
(
)
{
return
GetProperty
(
RowUnpaginatedHeightProperty
(
)
)
;
}
void
nsTableRowFrame
:
:
SetContinuousBCBorderWidth
(
LogicalSide
aForSide
BCPixelSize
aPixelValue
)
{
switch
(
aForSide
)
{
case
eLogicalSideIEnd
:
mIEndContBorderWidth
=
aPixelValue
;
return
;
case
eLogicalSideBStart
:
mBStartContBorderWidth
=
aPixelValue
;
return
;
case
eLogicalSideIStart
:
mIStartContBorderWidth
=
aPixelValue
;
return
;
default
:
NS_ERROR
(
"
invalid
LogicalSide
arg
"
)
;
}
}
#
ifdef
ACCESSIBILITY
a11y
:
:
AccType
nsTableRowFrame
:
:
AccessibleType
(
)
{
return
a11y
:
:
eHTMLTableRowType
;
}
#
endif
void
nsTableRowFrame
:
:
InitHasCellWithStyleBSize
(
nsTableFrame
*
aTableFrame
)
{
WritingMode
wm
=
GetWritingMode
(
)
;
for
(
nsIFrame
*
kidFrame
:
mFrames
)
{
nsTableCellFrame
*
cellFrame
=
do_QueryFrame
(
kidFrame
)
;
if
(
!
cellFrame
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Table
row
has
a
non
-
cell
child
.
"
)
;
continue
;
}
const
auto
&
cellBSize
=
cellFrame
-
>
StylePosition
(
)
-
>
BSize
(
wm
)
;
if
(
aTableFrame
-
>
GetEffectiveRowSpan
(
*
cellFrame
)
=
=
1
&
&
!
cellBSize
.
IsAuto
(
)
&
&
(
cellBSize
.
ConvertsToLength
(
)
|
|
cellBSize
.
ConvertsToPercentage
(
)
)
)
{
AddStateBits
(
NS_ROW_HAS_CELL_WITH_STYLE_BSIZE
)
;
return
;
}
}
RemoveStateBits
(
NS_ROW_HAS_CELL_WITH_STYLE_BSIZE
)
;
}
void
nsTableRowFrame
:
:
InvalidateFrame
(
uint32_t
aDisplayItemKey
bool
aRebuildDisplayItems
)
{
nsIFrame
:
:
InvalidateFrame
(
aDisplayItemKey
aRebuildDisplayItems
)
;
if
(
GetTableFrame
(
)
-
>
IsBorderCollapse
(
)
)
{
GetParent
(
)
-
>
InvalidateFrameWithRect
(
GetVisualOverflowRect
(
)
+
GetPosition
(
)
aDisplayItemKey
false
)
;
}
}
void
nsTableRowFrame
:
:
InvalidateFrameWithRect
(
const
nsRect
&
aRect
uint32_t
aDisplayItemKey
bool
aRebuildDisplayItems
)
{
nsIFrame
:
:
InvalidateFrameWithRect
(
aRect
aDisplayItemKey
aRebuildDisplayItems
)
;
GetParent
(
)
-
>
InvalidateFrameWithRect
(
aRect
+
GetPosition
(
)
aDisplayItemKey
false
)
;
}
nsTableRowFrame
*
NS_NewTableRowFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsTableRowFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsTableRowFrame
)
#
ifdef
DEBUG_FRAME_DUMP
nsresult
nsTableRowFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
NS_LITERAL_STRING
(
"
TableRow
"
)
aResult
)
;
}
#
endif
