#
include
"
mozilla
/
ServoStyleRuleMap
.
h
"
#
include
"
mozilla
/
css
/
GroupRule
.
h
"
#
include
"
mozilla
/
dom
/
CSSImportRule
.
h
"
#
include
"
mozilla
/
dom
/
CSSRuleBinding
.
h
"
#
include
"
mozilla
/
dom
/
CSSStyleRule
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
ShadowRoot
.
h
"
#
include
"
mozilla
/
IntegerRange
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
mozilla
/
StyleSheetInlines
.
h
"
using
namespace
mozilla
:
:
dom
;
namespace
mozilla
{
void
ServoStyleRuleMap
:
:
EnsureTable
(
ServoStyleSet
&
aStyleSet
)
{
if
(
!
IsEmpty
(
)
)
{
return
;
}
aStyleSet
.
EnumerateStyleSheets
(
[
&
]
(
StyleSheet
&
aSheet
)
{
FillTableFromStyleSheet
(
aSheet
)
;
}
)
;
}
void
ServoStyleRuleMap
:
:
EnsureTable
(
ShadowRoot
&
aShadowRoot
)
{
if
(
!
IsEmpty
(
)
)
{
return
;
}
for
(
auto
index
:
IntegerRange
(
aShadowRoot
.
SheetCount
(
)
)
)
{
FillTableFromStyleSheet
(
*
aShadowRoot
.
SheetAt
(
index
)
)
;
}
for
(
const
auto
&
sheet
:
aShadowRoot
.
AdoptedStyleSheets
(
)
)
{
FillTableFromStyleSheet
(
*
sheet
)
;
}
}
void
ServoStyleRuleMap
:
:
SheetAdded
(
StyleSheet
&
aStyleSheet
)
{
if
(
!
IsEmpty
(
)
)
{
FillTableFromStyleSheet
(
aStyleSheet
)
;
}
}
void
ServoStyleRuleMap
:
:
SheetCloned
(
StyleSheet
&
aStyleSheet
)
{
}
void
ServoStyleRuleMap
:
:
SheetRemoved
(
StyleSheet
&
aStyleSheet
)
{
mTable
.
Clear
(
)
;
}
void
ServoStyleRuleMap
:
:
RuleAdded
(
StyleSheet
&
aStyleSheet
css
:
:
Rule
&
aStyleRule
)
{
if
(
!
IsEmpty
(
)
)
{
FillTableFromRule
(
aStyleRule
)
;
}
}
void
ServoStyleRuleMap
:
:
RuleRemoved
(
StyleSheet
&
aStyleSheet
css
:
:
Rule
&
aStyleRule
)
{
if
(
IsEmpty
(
)
)
{
return
;
}
switch
(
aStyleRule
.
Type
(
)
)
{
case
StyleCssRuleType
:
:
Style
:
case
StyleCssRuleType
:
:
NestedDeclarations
:
case
StyleCssRuleType
:
:
Import
:
case
StyleCssRuleType
:
:
Media
:
case
StyleCssRuleType
:
:
Supports
:
case
StyleCssRuleType
:
:
LayerBlock
:
case
StyleCssRuleType
:
:
Container
:
case
StyleCssRuleType
:
:
Document
:
case
StyleCssRuleType
:
:
Scope
:
case
StyleCssRuleType
:
:
StartingStyle
:
case
StyleCssRuleType
:
:
PositionTry
:
{
mTable
.
Clear
(
)
;
break
;
}
case
StyleCssRuleType
:
:
LayerStatement
:
case
StyleCssRuleType
:
:
FontFace
:
case
StyleCssRuleType
:
:
Page
:
case
StyleCssRuleType
:
:
Property
:
case
StyleCssRuleType
:
:
Keyframes
:
case
StyleCssRuleType
:
:
Keyframe
:
case
StyleCssRuleType
:
:
Margin
:
case
StyleCssRuleType
:
:
Namespace
:
case
StyleCssRuleType
:
:
CounterStyle
:
case
StyleCssRuleType
:
:
FontFeatureValues
:
case
StyleCssRuleType
:
:
FontPaletteValues
:
break
;
}
}
size_t
ServoStyleRuleMap
:
:
SizeOfIncludingThis
(
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
n
=
aMallocSizeOf
(
this
)
;
n
+
=
mTable
.
ShallowSizeOfExcludingThis
(
aMallocSizeOf
)
;
return
n
;
}
void
ServoStyleRuleMap
:
:
FillTableFromRule
(
css
:
:
Rule
&
aRule
)
{
switch
(
aRule
.
Type
(
)
)
{
case
StyleCssRuleType
:
:
Style
:
{
auto
&
rule
=
static_cast
<
CSSStyleRule
&
>
(
aRule
)
;
mTable
.
InsertOrUpdate
(
rule
.
Raw
(
)
&
rule
)
;
[
[
fallthrough
]
]
;
}
case
StyleCssRuleType
:
:
LayerBlock
:
case
StyleCssRuleType
:
:
Media
:
case
StyleCssRuleType
:
:
Supports
:
case
StyleCssRuleType
:
:
Container
:
case
StyleCssRuleType
:
:
Document
:
case
StyleCssRuleType
:
:
Scope
:
case
StyleCssRuleType
:
:
StartingStyle
:
{
auto
&
rule
=
static_cast
<
css
:
:
GroupRule
&
>
(
aRule
)
;
FillTableFromRuleList
(
*
rule
.
CssRules
(
)
)
;
break
;
}
case
StyleCssRuleType
:
:
Import
:
{
auto
&
rule
=
static_cast
<
CSSImportRule
&
>
(
aRule
)
;
if
(
auto
*
sheet
=
rule
.
GetStyleSheet
(
)
)
{
FillTableFromStyleSheet
(
*
sheet
)
;
}
break
;
}
case
StyleCssRuleType
:
:
LayerStatement
:
case
StyleCssRuleType
:
:
FontFace
:
case
StyleCssRuleType
:
:
Page
:
case
StyleCssRuleType
:
:
Property
:
case
StyleCssRuleType
:
:
Keyframes
:
case
StyleCssRuleType
:
:
Keyframe
:
case
StyleCssRuleType
:
:
Margin
:
case
StyleCssRuleType
:
:
Namespace
:
case
StyleCssRuleType
:
:
CounterStyle
:
case
StyleCssRuleType
:
:
FontFeatureValues
:
case
StyleCssRuleType
:
:
FontPaletteValues
:
case
StyleCssRuleType
:
:
PositionTry
:
case
StyleCssRuleType
:
:
NestedDeclarations
:
break
;
}
}
void
ServoStyleRuleMap
:
:
FillTableFromRuleList
(
ServoCSSRuleList
&
aRuleList
)
{
for
(
uint32_t
i
:
IntegerRange
(
aRuleList
.
Length
(
)
)
)
{
FillTableFromRule
(
*
aRuleList
.
GetRule
(
i
)
)
;
}
}
void
ServoStyleRuleMap
:
:
FillTableFromStyleSheet
(
StyleSheet
&
aSheet
)
{
if
(
aSheet
.
IsComplete
(
)
)
{
FillTableFromRuleList
(
*
aSheet
.
GetCssRulesInternal
(
)
)
;
}
}
}
