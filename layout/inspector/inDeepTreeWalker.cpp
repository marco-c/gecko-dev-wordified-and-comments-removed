#
include
"
inDeepTreeWalker
.
h
"
#
include
"
inLayoutUtils
.
h
"
#
include
"
mozilla
/
Try
.
h
"
#
include
"
mozilla
/
dom
/
CSSStyleRule
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
InspectorUtils
.
h
"
#
include
"
mozilla
/
dom
/
NodeFilterBinding
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsServiceManagerUtils
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
ChildIterator
.
h
"
using
mozilla
:
:
dom
:
:
InspectorUtils
;
inDeepTreeWalker
:
:
inDeepTreeWalker
(
)
=
default
;
inDeepTreeWalker
:
:
~
inDeepTreeWalker
(
)
=
default
;
NS_IMPL_ISUPPORTS
(
inDeepTreeWalker
inIDeepTreeWalker
)
NS_IMETHODIMP
inDeepTreeWalker
:
:
GetShowAnonymousContent
(
bool
*
aShowAnonymousContent
)
{
*
aShowAnonymousContent
=
mShowAnonymousContent
;
return
NS_OK
;
}
NS_IMETHODIMP
inDeepTreeWalker
:
:
SetShowAnonymousContent
(
bool
aShowAnonymousContent
)
{
mShowAnonymousContent
=
aShowAnonymousContent
;
return
NS_OK
;
}
NS_IMETHODIMP
inDeepTreeWalker
:
:
GetShowSubDocuments
(
bool
*
aShowSubDocuments
)
{
*
aShowSubDocuments
=
mShowSubDocuments
;
return
NS_OK
;
}
NS_IMETHODIMP
inDeepTreeWalker
:
:
SetShowSubDocuments
(
bool
aShowSubDocuments
)
{
mShowSubDocuments
=
aShowSubDocuments
;
return
NS_OK
;
}
NS_IMETHODIMP
inDeepTreeWalker
:
:
GetShowDocumentsAsNodes
(
bool
*
aShowDocumentsAsNodes
)
{
*
aShowDocumentsAsNodes
=
mShowDocumentsAsNodes
;
return
NS_OK
;
}
NS_IMETHODIMP
inDeepTreeWalker
:
:
SetShowDocumentsAsNodes
(
bool
aShowDocumentsAsNodes
)
{
mShowDocumentsAsNodes
=
aShowDocumentsAsNodes
;
return
NS_OK
;
}
NS_IMETHODIMP
inDeepTreeWalker
:
:
Init
(
nsINode
*
aRoot
)
{
if
(
!
aRoot
)
{
return
NS_ERROR_INVALID_ARG
;
}
mRoot
=
aRoot
;
mCurrentNode
=
aRoot
;
return
NS_OK
;
}
NS_IMETHODIMP
inDeepTreeWalker
:
:
GetRoot
(
nsINode
*
*
aRoot
)
{
*
aRoot
=
mRoot
;
NS_IF_ADDREF
(
*
aRoot
)
;
return
NS_OK
;
}
NS_IMETHODIMP
inDeepTreeWalker
:
:
GetCurrentNode
(
nsINode
*
*
aCurrentNode
)
{
*
aCurrentNode
=
mCurrentNode
;
NS_IF_ADDREF
(
*
aCurrentNode
)
;
return
NS_OK
;
}
already_AddRefed
<
nsINode
>
inDeepTreeWalker
:
:
GetParent
(
)
{
MOZ_ASSERT
(
mCurrentNode
)
;
if
(
mCurrentNode
=
=
mRoot
)
{
return
nullptr
;
}
nsINode
*
parentNode
=
InspectorUtils
:
:
GetParentForNode
(
*
mCurrentNode
mShowAnonymousContent
)
;
if
(
!
parentNode
)
{
return
nullptr
;
}
if
(
!
mShowDocumentsAsNodes
&
&
parentNode
-
>
IsDocument
(
)
&
&
parentNode
!
=
mRoot
)
{
parentNode
=
InspectorUtils
:
:
GetParentForNode
(
*
parentNode
mShowAnonymousContent
)
;
}
return
do_AddRef
(
parentNode
)
;
}
void
inDeepTreeWalker
:
:
GetChildren
(
nsINode
&
aParent
ChildList
&
aChildList
)
{
aChildList
.
ClearAndRetainStorage
(
)
;
InspectorUtils
:
:
GetChildrenForNode
(
aParent
mShowAnonymousContent
false
mShowSubDocuments
aChildList
)
;
if
(
aChildList
.
Length
(
)
=
=
1
&
&
aChildList
.
ElementAt
(
0
)
-
>
IsDocument
(
)
&
&
!
mShowDocumentsAsNodes
)
{
RefPtr
parent
=
aChildList
.
ElementAt
(
0
)
;
aChildList
.
ClearAndRetainStorage
(
)
;
InspectorUtils
:
:
GetChildrenForNode
(
*
parent
mShowAnonymousContent
false
mShowSubDocuments
aChildList
)
;
}
}
NS_IMETHODIMP
inDeepTreeWalker
:
:
SetCurrentNode
(
nsINode
*
aCurrentNode
)
{
if
(
!
mCurrentNode
|
|
!
aCurrentNode
)
{
return
NS_ERROR_FAILURE
;
}
if
(
!
mShowDocumentsAsNodes
)
{
if
(
aCurrentNode
-
>
IsDocument
(
)
)
{
return
NS_ERROR_FAILURE
;
}
}
ChildList
oldSiblings
;
mSiblings
.
SwapElements
(
oldSiblings
)
;
nsCOMPtr
<
nsINode
>
oldCurrent
=
std
:
:
move
(
mCurrentNode
)
;
mCurrentNode
=
aCurrentNode
;
if
(
RefPtr
<
nsINode
>
parent
=
GetParent
(
)
)
{
GetChildren
(
*
parent
mSiblings
)
;
int32_t
index
=
mSiblings
.
IndexOf
(
mCurrentNode
)
;
if
(
index
<
0
)
{
mCurrentNode
=
std
:
:
move
(
oldCurrent
)
;
oldSiblings
.
SwapElements
(
mSiblings
)
;
return
NS_ERROR_INVALID_ARG
;
}
mCurrentIndex
=
index
;
}
else
{
mCurrentIndex
=
-
1
;
}
return
NS_OK
;
}
NS_IMETHODIMP
inDeepTreeWalker
:
:
ParentNode
(
nsINode
*
*
_retval
)
{
*
_retval
=
nullptr
;
if
(
!
mCurrentNode
|
|
mCurrentNode
=
=
mRoot
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
parent
=
GetParent
(
)
;
if
(
!
parent
)
{
return
NS_OK
;
}
MOZ_TRY
(
SetCurrentNode
(
parent
)
)
;
parent
.
forget
(
_retval
)
;
return
NS_OK
;
}
nsresult
inDeepTreeWalker
:
:
EdgeChild
(
nsINode
*
*
_retval
bool
aFront
)
{
if
(
!
mCurrentNode
)
{
return
NS_ERROR_FAILURE
;
}
*
_retval
=
nullptr
;
ChildList
children
;
GetChildren
(
*
mCurrentNode
children
)
;
if
(
children
.
IsEmpty
(
)
)
{
return
NS_OK
;
}
mSiblings
=
std
:
:
move
(
children
)
;
mCurrentIndex
=
aFront
?
0
:
mSiblings
.
Length
(
)
-
1
;
mCurrentNode
=
mSiblings
.
ElementAt
(
mCurrentIndex
)
;
NS_ADDREF
(
*
_retval
=
mCurrentNode
)
;
return
NS_OK
;
}
NS_IMETHODIMP
inDeepTreeWalker
:
:
FirstChild
(
nsINode
*
*
_retval
)
{
return
EdgeChild
(
_retval
true
)
;
}
NS_IMETHODIMP
inDeepTreeWalker
:
:
LastChild
(
nsINode
*
*
_retval
)
{
return
EdgeChild
(
_retval
false
)
;
}
NS_IMETHODIMP
inDeepTreeWalker
:
:
PreviousSibling
(
nsINode
*
*
_retval
)
{
*
_retval
=
nullptr
;
if
(
!
mCurrentNode
|
|
mCurrentIndex
<
1
)
{
return
NS_OK
;
}
nsINode
*
prev
=
mSiblings
.
ElementAt
(
-
-
mCurrentIndex
)
;
mCurrentNode
=
prev
;
NS_ADDREF
(
*
_retval
=
mCurrentNode
)
;
return
NS_OK
;
}
NS_IMETHODIMP
inDeepTreeWalker
:
:
NextSibling
(
nsINode
*
*
_retval
)
{
*
_retval
=
nullptr
;
if
(
!
mCurrentNode
|
|
mCurrentIndex
+
1
>
=
(
int32_t
)
mSiblings
.
Length
(
)
)
{
return
NS_OK
;
}
nsINode
*
next
=
mSiblings
.
ElementAt
(
+
+
mCurrentIndex
)
;
mCurrentNode
=
next
;
NS_ADDREF
(
*
_retval
=
mCurrentNode
)
;
return
NS_OK
;
}
NS_IMETHODIMP
inDeepTreeWalker
:
:
PreviousNode
(
nsINode
*
*
_retval
)
{
if
(
!
mCurrentNode
|
|
mCurrentNode
=
=
mRoot
)
{
*
_retval
=
nullptr
;
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
node
;
PreviousSibling
(
getter_AddRefs
(
node
)
)
;
if
(
!
node
)
{
return
ParentNode
(
_retval
)
;
}
while
(
node
)
{
LastChild
(
getter_AddRefs
(
node
)
)
;
}
NS_ADDREF
(
*
_retval
=
mCurrentNode
)
;
return
NS_OK
;
}
NS_IMETHODIMP
inDeepTreeWalker
:
:
NextNode
(
nsINode
*
*
_retval
)
{
if
(
!
mCurrentNode
)
{
return
NS_OK
;
}
FirstChild
(
_retval
)
;
if
(
*
_retval
)
{
return
NS_OK
;
}
#
ifdef
DEBUG
nsINode
*
origCurrentNode
=
mCurrentNode
;
#
endif
uint32_t
lastChildCallsToMake
=
0
;
while
(
1
)
{
NextSibling
(
_retval
)
;
if
(
*
_retval
)
{
return
NS_OK
;
}
nsCOMPtr
<
nsINode
>
parent
;
ParentNode
(
getter_AddRefs
(
parent
)
)
;
if
(
!
parent
)
{
while
(
lastChildCallsToMake
-
-
)
{
nsCOMPtr
<
nsINode
>
dummy
;
LastChild
(
getter_AddRefs
(
dummy
)
)
;
}
NS_ASSERTION
(
mCurrentNode
=
=
origCurrentNode
"
Didn
'
t
go
back
to
the
right
node
?
"
)
;
*
_retval
=
nullptr
;
return
NS_OK
;
}
+
+
lastChildCallsToMake
;
}
MOZ_ASSERT_UNREACHABLE
(
"
how
did
we
get
here
?
"
)
;
return
NS_OK
;
}
