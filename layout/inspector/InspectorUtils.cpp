#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
inLayoutUtils
.
h
"
#
include
"
nsArray
.
h
"
#
include
"
nsAutoPtr
.
h
"
#
include
"
nsIServiceManager
.
h
"
#
include
"
nsString
.
h
"
#
include
"
nsIStyleSheetLinkingElement
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsIDOMElement
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsIDOMDocument
.
h
"
#
include
"
nsIDOMWindow
.
h
"
#
include
"
nsXBLBinding
.
h
"
#
include
"
nsXBLPrototypeBinding
.
h
"
#
include
"
nsIMutableArray
.
h
"
#
include
"
nsBindingManager
.
h
"
#
include
"
ChildIterator
.
h
"
#
include
"
nsComputedDOMStyle
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
nsAtom
.
h
"
#
include
"
nsRange
.
h
"
#
include
"
mozilla
/
StyleSheetInlines
.
h
"
#
include
"
mozilla
/
dom
/
CharacterData
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
CSSLexer
.
h
"
#
include
"
mozilla
/
dom
/
InspectorUtilsBinding
.
h
"
#
include
"
mozilla
/
dom
/
ToJSValue
.
h
"
#
include
"
nsCSSParser
.
h
"
#
include
"
nsCSSProps
.
h
"
#
include
"
nsCSSValue
.
h
"
#
include
"
nsColor
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
nsStyleUtil
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
mozilla
/
ServoBindings
.
h
"
#
include
"
mozilla
/
ServoStyleRule
.
h
"
#
include
"
mozilla
/
ServoStyleRuleMap
.
h
"
#
include
"
mozilla
/
ServoCSSParser
.
h
"
#
include
"
mozilla
/
dom
/
InspectorUtils
.
h
"
#
include
"
mozilla
/
dom
/
InspectorFontFace
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
css
;
using
namespace
mozilla
:
:
dom
;
extern
const
char
*
const
kCSSRawProperties
[
]
;
namespace
mozilla
{
namespace
dom
{
void
InspectorUtils
:
:
GetAllStyleSheets
(
GlobalObject
&
aGlobalObject
nsIDocument
&
aDocument
bool
aDocumentOnly
nsTArray
<
RefPtr
<
StyleSheet
>
>
&
aResult
)
{
nsIPresShell
*
presShell
=
aDocument
.
GetShell
(
)
;
if
(
presShell
)
{
ServoStyleSet
*
styleSet
=
presShell
-
>
StyleSet
(
)
;
if
(
!
aDocumentOnly
)
{
SheetType
sheetType
=
SheetType
:
:
Agent
;
for
(
int32_t
i
=
0
;
i
<
styleSet
-
>
SheetCount
(
sheetType
)
;
i
+
+
)
{
aResult
.
AppendElement
(
styleSet
-
>
StyleSheetAt
(
sheetType
i
)
)
;
}
sheetType
=
SheetType
:
:
User
;
for
(
int32_t
i
=
0
;
i
<
styleSet
-
>
SheetCount
(
sheetType
)
;
i
+
+
)
{
aResult
.
AppendElement
(
styleSet
-
>
StyleSheetAt
(
sheetType
i
)
)
;
}
}
AutoTArray
<
StyleSheet
*
32
>
xblSheetArray
;
styleSet
-
>
AppendAllNonDocumentAuthorSheets
(
xblSheetArray
)
;
nsTHashtable
<
nsPtrHashKey
<
StyleSheet
>
>
sheetSet
;
for
(
StyleSheet
*
sheet
:
xblSheetArray
)
{
if
(
!
sheetSet
.
Contains
(
sheet
)
)
{
sheetSet
.
PutEntry
(
sheet
)
;
aResult
.
AppendElement
(
sheet
)
;
}
}
}
for
(
size_t
i
=
0
;
i
<
aDocument
.
SheetCount
(
)
;
i
+
+
)
{
aResult
.
AppendElement
(
aDocument
.
SheetAt
(
i
)
)
;
}
}
bool
InspectorUtils
:
:
IsIgnorableWhitespace
(
CharacterData
&
aDataNode
)
{
if
(
!
aDataNode
.
TextIsOnlyWhitespace
(
)
)
{
return
false
;
}
if
(
nsIFrame
*
frame
=
aDataNode
.
GetPrimaryFrame
(
)
)
{
return
!
frame
-
>
StyleText
(
)
-
>
WhiteSpaceIsSignificant
(
)
;
}
return
true
;
}
nsINode
*
InspectorUtils
:
:
GetParentForNode
(
nsINode
&
aNode
bool
aShowingAnonymousContent
)
{
nsINode
*
parent
=
nullptr
;
if
(
aNode
.
IsDocument
(
)
)
{
parent
=
inLayoutUtils
:
:
GetContainerFor
(
*
aNode
.
AsDocument
(
)
)
;
}
else
if
(
aShowingAnonymousContent
)
{
if
(
aNode
.
IsContent
(
)
)
{
parent
=
aNode
.
AsContent
(
)
-
>
GetFlattenedTreeParent
(
)
;
}
}
if
(
!
parent
)
{
return
aNode
.
GetParentNode
(
)
;
}
return
parent
;
}
already_AddRefed
<
nsINodeList
>
InspectorUtils
:
:
GetChildrenForNode
(
nsINode
&
aNode
bool
aShowingAnonymousContent
)
{
nsCOMPtr
<
nsINodeList
>
kids
;
if
(
aShowingAnonymousContent
)
{
if
(
aNode
.
IsContent
(
)
)
{
kids
=
aNode
.
AsContent
(
)
-
>
GetChildren
(
nsIContent
:
:
eAllChildren
)
;
}
}
if
(
!
kids
)
{
kids
=
aNode
.
ChildNodes
(
)
;
}
return
kids
.
forget
(
)
;
}
void
InspectorUtils
:
:
GetCSSStyleRules
(
GlobalObject
&
aGlobalObject
Element
&
aElement
const
nsAString
&
aPseudo
nsTArray
<
RefPtr
<
css
:
:
Rule
>
>
&
aResult
)
{
RefPtr
<
nsAtom
>
pseudoElt
;
if
(
!
aPseudo
.
IsEmpty
(
)
)
{
pseudoElt
=
NS_Atomize
(
aPseudo
)
;
}
RefPtr
<
ComputedStyle
>
computedStyle
=
GetCleanComputedStyleForElement
(
&
aElement
pseudoElt
)
;
if
(
!
computedStyle
)
{
return
;
}
nsIDocument
*
doc
=
aElement
.
OwnerDoc
(
)
;
nsIPresShell
*
shell
=
doc
-
>
GetShell
(
)
;
if
(
!
shell
)
{
return
;
}
nsTArray
<
const
RawServoStyleRule
*
>
rawRuleList
;
Servo_ComputedValues_GetStyleRuleList
(
computedStyle
&
rawRuleList
)
;
AutoTArray
<
ServoStyleRuleMap
*
1
>
maps
;
{
ServoStyleSet
*
styleSet
=
shell
-
>
StyleSet
(
)
;
ServoStyleRuleMap
*
map
=
styleSet
-
>
StyleRuleMap
(
)
;
maps
.
AppendElement
(
map
)
;
}
for
(
nsIContent
*
bindingContent
=
&
aElement
;
bindingContent
;
bindingContent
=
bindingContent
-
>
GetBindingParent
(
)
)
{
for
(
nsXBLBinding
*
binding
=
bindingContent
-
>
GetXBLBinding
(
)
;
binding
;
binding
=
binding
-
>
GetBaseBinding
(
)
)
{
if
(
auto
*
map
=
binding
-
>
PrototypeBinding
(
)
-
>
GetServoStyleRuleMap
(
)
)
{
maps
.
AppendElement
(
map
)
;
}
}
}
if
(
auto
*
shadow
=
aElement
.
GetShadowRoot
(
)
)
{
maps
.
AppendElement
(
&
shadow
-
>
ServoStyleRuleMap
(
)
)
;
}
for
(
auto
*
shadow
=
aElement
.
GetContainingShadow
(
)
;
shadow
;
shadow
=
shadow
-
>
Host
(
)
-
>
GetContainingShadow
(
)
)
{
maps
.
AppendElement
(
&
shadow
-
>
ServoStyleRuleMap
(
)
)
;
}
for
(
const
RawServoStyleRule
*
rawRule
:
Reversed
(
rawRuleList
)
)
{
ServoStyleRule
*
rule
=
nullptr
;
for
(
ServoStyleRuleMap
*
map
:
maps
)
{
rule
=
map
-
>
Lookup
(
rawRule
)
;
if
(
rule
)
{
break
;
}
}
if
(
rule
)
{
aResult
.
AppendElement
(
rule
)
;
}
else
{
MOZ_ASSERT_UNREACHABLE
(
"
We
should
be
able
to
map
a
raw
rule
to
a
rule
"
)
;
}
}
}
uint32_t
InspectorUtils
:
:
GetRuleLine
(
GlobalObject
&
aGlobal
css
:
:
Rule
&
aRule
)
{
return
aRule
.
GetLineNumber
(
)
;
}
uint32_t
InspectorUtils
:
:
GetRuleColumn
(
GlobalObject
&
aGlobal
css
:
:
Rule
&
aRule
)
{
return
aRule
.
GetColumnNumber
(
)
;
}
uint32_t
InspectorUtils
:
:
GetRelativeRuleLine
(
GlobalObject
&
aGlobal
css
:
:
Rule
&
aRule
)
{
uint32_t
lineNumber
=
aRule
.
GetLineNumber
(
)
;
StyleSheet
*
sheet
=
aRule
.
GetStyleSheet
(
)
;
if
(
sheet
&
&
lineNumber
!
=
0
)
{
nsINode
*
owningNode
=
sheet
-
>
GetOwnerNode
(
)
;
if
(
owningNode
)
{
nsCOMPtr
<
nsIStyleSheetLinkingElement
>
link
=
do_QueryInterface
(
owningNode
)
;
if
(
link
)
{
uint32_t
linkLineIndex0
=
link
-
>
GetLineNumber
(
)
-
1
;
if
(
linkLineIndex0
>
lineNumber
)
{
lineNumber
=
0
;
}
else
{
lineNumber
-
=
linkLineIndex0
;
}
}
}
}
return
lineNumber
;
}
bool
InspectorUtils
:
:
HasRulesModifiedByCSSOM
(
GlobalObject
&
aGlobal
StyleSheet
&
aSheet
)
{
return
aSheet
.
HasModifiedRules
(
)
;
}
CSSLexer
*
InspectorUtils
:
:
GetCSSLexer
(
GlobalObject
&
aGlobal
const
nsAString
&
aText
)
{
return
new
CSSLexer
(
aText
)
;
}
uint32_t
InspectorUtils
:
:
GetSelectorCount
(
GlobalObject
&
aGlobal
BindingStyleRule
&
aRule
)
{
return
aRule
.
GetSelectorCount
(
)
;
}
void
InspectorUtils
:
:
GetSelectorText
(
GlobalObject
&
aGlobal
BindingStyleRule
&
aRule
uint32_t
aSelectorIndex
nsString
&
aText
ErrorResult
&
aRv
)
{
aRv
=
aRule
.
GetSelectorText
(
aSelectorIndex
aText
)
;
}
uint64_t
InspectorUtils
:
:
GetSpecificity
(
GlobalObject
&
aGlobal
BindingStyleRule
&
aRule
uint32_t
aSelectorIndex
ErrorResult
&
aRv
)
{
uint64_t
s
;
aRv
=
aRule
.
GetSpecificity
(
aSelectorIndex
&
s
)
;
return
s
;
}
bool
InspectorUtils
:
:
SelectorMatchesElement
(
GlobalObject
&
aGlobalObject
Element
&
aElement
BindingStyleRule
&
aRule
uint32_t
aSelectorIndex
const
nsAString
&
aPseudo
ErrorResult
&
aRv
)
{
bool
result
=
false
;
aRv
=
aRule
.
SelectorMatchesElement
(
&
aElement
aSelectorIndex
aPseudo
&
result
)
;
return
result
;
}
bool
InspectorUtils
:
:
IsInheritedProperty
(
GlobalObject
&
aGlobalObject
const
nsAString
&
aPropertyName
)
{
NS_ConvertUTF16toUTF8
propName
(
aPropertyName
)
;
return
Servo_Property_IsInherited
(
&
propName
)
;
}
void
InspectorUtils
:
:
GetCSSPropertyNames
(
GlobalObject
&
aGlobalObject
const
PropertyNamesOptions
&
aOptions
nsTArray
<
nsString
>
&
aResult
)
{
CSSEnabledState
enabledState
=
aOptions
.
mIncludeExperimentals
?
CSSEnabledState
:
:
eIgnoreEnabledState
:
CSSEnabledState
:
:
eForAllContent
;
auto
appendProperty
=
[
enabledState
&
aResult
]
(
uint32_t
prop
)
{
nsCSSPropertyID
cssProp
=
nsCSSPropertyID
(
prop
)
;
if
(
nsCSSProps
:
:
IsEnabled
(
cssProp
enabledState
)
)
{
nsDependentCString
name
(
kCSSRawProperties
[
prop
]
)
;
aResult
.
AppendElement
(
NS_ConvertASCIItoUTF16
(
name
)
)
;
}
}
;
uint32_t
prop
=
0
;
for
(
;
prop
<
eCSSProperty_COUNT_no_shorthands
;
+
+
prop
)
{
if
(
!
nsCSSProps
:
:
PropHasFlags
(
nsCSSPropertyID
(
prop
)
CSSPropFlags
:
:
Inaccessible
)
)
{
appendProperty
(
prop
)
;
}
}
if
(
aOptions
.
mIncludeShorthands
)
{
for
(
;
prop
<
eCSSProperty_COUNT
;
+
+
prop
)
{
appendProperty
(
prop
)
;
}
}
if
(
aOptions
.
mIncludeAliases
)
{
for
(
prop
=
eCSSProperty_COUNT
;
prop
<
eCSSProperty_COUNT_with_aliases
;
+
+
prop
)
{
appendProperty
(
prop
)
;
}
}
}
static
void
InsertNoDuplicates
(
nsTArray
<
nsString
>
&
aArray
const
nsAString
&
aString
)
{
size_t
i
=
aArray
.
IndexOfFirstElementGt
(
aString
)
;
if
(
i
>
0
&
&
aArray
[
i
-
1
]
.
Equals
(
aString
)
)
{
return
;
}
aArray
.
InsertElementAt
(
i
aString
)
;
}
static
void
GetKeywordsForProperty
(
const
nsCSSPropertyID
aProperty
nsTArray
<
nsString
>
&
aArray
)
{
const
nsCSSProps
:
:
KTableEntry
*
keywordTable
;
if
(
nsCSSProps
:
:
IsShorthand
(
aProperty
)
)
{
if
(
aProperty
=
=
eCSSProperty_font
)
{
keywordTable
=
nsCSSProps
:
:
kFontKTable
;
}
else
{
return
;
}
}
else
{
keywordTable
=
nsCSSProps
:
:
kKeywordTableTable
[
aProperty
]
;
if
(
keywordTable
=
=
nullptr
)
{
if
(
aProperty
=
=
eCSSProperty_clip_path
)
{
keywordTable
=
nsCSSProps
:
:
kClipPathGeometryBoxKTable
;
}
}
}
if
(
keywordTable
)
{
for
(
size_t
i
=
0
;
!
keywordTable
[
i
]
.
IsSentinel
(
)
;
+
+
i
)
{
nsCSSKeyword
word
=
keywordTable
[
i
]
.
mKeyword
;
if
(
word
!
=
eCSSKeyword__moz_zoom_in
&
&
word
!
=
eCSSKeyword__moz_zoom_out
&
&
word
!
=
eCSSKeyword__moz_grab
&
&
word
!
=
eCSSKeyword__moz_grabbing
&
&
word
!
=
eCSSKeyword_UNKNOWN
)
{
InsertNoDuplicates
(
aArray
NS_ConvertASCIItoUTF16
(
nsCSSKeywords
:
:
GetStringValue
(
word
)
)
)
;
}
}
}
if
(
aProperty
=
=
eCSSProperty_clip_path
)
{
InsertNoDuplicates
(
aArray
NS_LITERAL_STRING
(
"
circle
"
)
)
;
InsertNoDuplicates
(
aArray
NS_LITERAL_STRING
(
"
ellipse
"
)
)
;
InsertNoDuplicates
(
aArray
NS_LITERAL_STRING
(
"
inset
"
)
)
;
InsertNoDuplicates
(
aArray
NS_LITERAL_STRING
(
"
polygon
"
)
)
;
}
else
if
(
aProperty
=
=
eCSSProperty_clip
)
{
InsertNoDuplicates
(
aArray
NS_LITERAL_STRING
(
"
rect
"
)
)
;
}
else
if
(
aProperty
=
=
eCSSProperty_list_style_type
)
{
int32_t
length
;
const
char
*
const
*
values
=
nsCSSProps
:
:
GetListStyleTypes
(
&
length
)
;
for
(
int32_t
i
=
0
;
i
<
length
;
+
+
i
)
{
InsertNoDuplicates
(
aArray
NS_ConvertASCIItoUTF16
(
values
[
i
]
)
)
;
}
InsertNoDuplicates
(
aArray
NS_LITERAL_STRING
(
"
symbols
"
)
)
;
}
}
static
void
GetColorsForProperty
(
const
uint32_t
aParserVariant
nsTArray
<
nsString
>
&
aArray
)
{
if
(
aParserVariant
&
VARIANT_COLOR
)
{
MOZ_ASSERT
(
aArray
.
Length
(
)
=
=
0
)
;
size_t
size
;
const
char
*
const
*
allColorNames
=
NS_AllColorNames
(
&
size
)
;
nsString
*
utf16Names
=
aArray
.
AppendElements
(
size
)
;
for
(
size_t
i
=
0
;
i
<
size
;
i
+
+
)
{
utf16Names
[
i
]
.
AssignASCII
(
allColorNames
[
i
]
)
;
}
InsertNoDuplicates
(
aArray
NS_LITERAL_STRING
(
"
currentColor
"
)
)
;
}
}
static
void
GetOtherValuesForProperty
(
const
uint32_t
aParserVariant
nsTArray
<
nsString
>
&
aArray
)
{
if
(
aParserVariant
&
VARIANT_AUTO
)
{
InsertNoDuplicates
(
aArray
NS_LITERAL_STRING
(
"
auto
"
)
)
;
}
if
(
aParserVariant
&
VARIANT_NORMAL
)
{
InsertNoDuplicates
(
aArray
NS_LITERAL_STRING
(
"
normal
"
)
)
;
}
if
(
aParserVariant
&
VARIANT_ALL
)
{
InsertNoDuplicates
(
aArray
NS_LITERAL_STRING
(
"
all
"
)
)
;
}
if
(
aParserVariant
&
VARIANT_NONE
)
{
InsertNoDuplicates
(
aArray
NS_LITERAL_STRING
(
"
none
"
)
)
;
}
if
(
aParserVariant
&
VARIANT_ELEMENT
)
{
InsertNoDuplicates
(
aArray
NS_LITERAL_STRING
(
"
-
moz
-
element
"
)
)
;
}
if
(
aParserVariant
&
VARIANT_IMAGE_RECT
)
{
InsertNoDuplicates
(
aArray
NS_LITERAL_STRING
(
"
-
moz
-
image
-
rect
"
)
)
;
}
if
(
aParserVariant
&
VARIANT_COLOR
)
{
InsertNoDuplicates
(
aArray
NS_LITERAL_STRING
(
"
rgb
"
)
)
;
InsertNoDuplicates
(
aArray
NS_LITERAL_STRING
(
"
hsl
"
)
)
;
InsertNoDuplicates
(
aArray
NS_LITERAL_STRING
(
"
rgba
"
)
)
;
InsertNoDuplicates
(
aArray
NS_LITERAL_STRING
(
"
hsla
"
)
)
;
}
if
(
aParserVariant
&
VARIANT_TIMING_FUNCTION
)
{
InsertNoDuplicates
(
aArray
NS_LITERAL_STRING
(
"
cubic
-
bezier
"
)
)
;
InsertNoDuplicates
(
aArray
NS_LITERAL_STRING
(
"
steps
"
)
)
;
}
if
(
aParserVariant
&
VARIANT_CALC
)
{
InsertNoDuplicates
(
aArray
NS_LITERAL_STRING
(
"
calc
"
)
)
;
}
if
(
aParserVariant
&
VARIANT_URL
)
{
InsertNoDuplicates
(
aArray
NS_LITERAL_STRING
(
"
url
"
)
)
;
}
if
(
aParserVariant
&
VARIANT_GRADIENT
)
{
InsertNoDuplicates
(
aArray
NS_LITERAL_STRING
(
"
linear
-
gradient
"
)
)
;
InsertNoDuplicates
(
aArray
NS_LITERAL_STRING
(
"
radial
-
gradient
"
)
)
;
InsertNoDuplicates
(
aArray
NS_LITERAL_STRING
(
"
repeating
-
linear
-
gradient
"
)
)
;
InsertNoDuplicates
(
aArray
NS_LITERAL_STRING
(
"
repeating
-
radial
-
gradient
"
)
)
;
InsertNoDuplicates
(
aArray
NS_LITERAL_STRING
(
"
-
moz
-
linear
-
gradient
"
)
)
;
InsertNoDuplicates
(
aArray
NS_LITERAL_STRING
(
"
-
moz
-
radial
-
gradient
"
)
)
;
InsertNoDuplicates
(
aArray
NS_LITERAL_STRING
(
"
-
moz
-
repeating
-
linear
-
gradient
"
)
)
;
InsertNoDuplicates
(
aArray
NS_LITERAL_STRING
(
"
-
moz
-
repeating
-
radial
-
gradient
"
)
)
;
}
if
(
aParserVariant
&
VARIANT_ATTR
)
{
InsertNoDuplicates
(
aArray
NS_LITERAL_STRING
(
"
attr
"
)
)
;
}
if
(
aParserVariant
&
VARIANT_COUNTER
)
{
InsertNoDuplicates
(
aArray
NS_LITERAL_STRING
(
"
counter
"
)
)
;
InsertNoDuplicates
(
aArray
NS_LITERAL_STRING
(
"
counters
"
)
)
;
}
}
void
InspectorUtils
:
:
GetSubpropertiesForCSSProperty
(
GlobalObject
&
aGlobal
const
nsAString
&
aProperty
nsTArray
<
nsString
>
&
aResult
ErrorResult
&
aRv
)
{
nsCSSPropertyID
propertyID
=
nsCSSProps
:
:
LookupProperty
(
aProperty
CSSEnabledState
:
:
eForAllContent
)
;
if
(
propertyID
=
=
eCSSProperty_UNKNOWN
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
if
(
propertyID
=
=
eCSSPropertyExtra_variable
)
{
aResult
.
AppendElement
(
aProperty
)
;
return
;
}
if
(
!
nsCSSProps
:
:
IsShorthand
(
propertyID
)
)
{
nsString
*
name
=
aResult
.
AppendElement
(
)
;
CopyASCIItoUTF16
(
nsCSSProps
:
:
GetStringValue
(
propertyID
)
*
name
)
;
return
;
}
for
(
const
nsCSSPropertyID
*
props
=
nsCSSProps
:
:
SubpropertyEntryFor
(
propertyID
)
;
*
props
!
=
eCSSProperty_UNKNOWN
;
+
+
props
)
{
nsString
*
name
=
aResult
.
AppendElement
(
)
;
CopyASCIItoUTF16
(
nsCSSProps
:
:
GetStringValue
(
*
props
)
*
name
)
;
}
}
bool
InspectorUtils
:
:
CssPropertyIsShorthand
(
GlobalObject
&
aGlobalObject
const
nsAString
&
aProperty
ErrorResult
&
aRv
)
{
NS_ConvertUTF16toUTF8
prop
(
aProperty
)
;
bool
found
;
bool
isShorthand
=
Servo_Property_IsShorthand
(
&
prop
&
found
)
;
if
(
!
found
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
}
return
isShorthand
;
}
bool
InspectorUtils
:
:
CssPropertySupportsType
(
GlobalObject
&
aGlobalObject
const
nsAString
&
aProperty
uint32_t
aType
ErrorResult
&
aRv
)
{
NS_ConvertUTF16toUTF8
property
(
aProperty
)
;
bool
found
;
bool
result
=
Servo_Property_SupportsType
(
&
property
aType
&
found
)
;
if
(
!
found
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
false
;
}
return
result
;
}
void
InspectorUtils
:
:
GetCSSValuesForProperty
(
GlobalObject
&
aGlobalObject
const
nsAString
&
aProperty
nsTArray
<
nsString
>
&
aResult
ErrorResult
&
aRv
)
{
nsCSSPropertyID
propertyID
=
nsCSSProps
:
:
LookupProperty
(
aProperty
CSSEnabledState
:
:
eForAllContent
)
;
if
(
propertyID
=
=
eCSSProperty_UNKNOWN
)
{
aRv
.
Throw
(
NS_ERROR_FAILURE
)
;
return
;
}
if
(
propertyID
=
=
eCSSPropertyExtra_variable
)
{
}
else
if
(
!
nsCSSProps
:
:
IsShorthand
(
propertyID
)
)
{
uint32_t
propertyParserVariant
=
nsCSSProps
:
:
ParserVariant
(
propertyID
)
;
GetColorsForProperty
(
propertyParserVariant
aResult
)
;
GetKeywordsForProperty
(
propertyID
aResult
)
;
GetOtherValuesForProperty
(
propertyParserVariant
aResult
)
;
}
else
if
(
propertyID
=
=
eCSSProperty_all
)
{
}
else
{
CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES
(
subproperty
propertyID
CSSEnabledState
:
:
eForAllContent
)
{
uint32_t
propertyParserVariant
=
nsCSSProps
:
:
ParserVariant
(
*
subproperty
)
;
if
(
propertyParserVariant
&
VARIANT_COLOR
)
{
GetColorsForProperty
(
propertyParserVariant
aResult
)
;
break
;
}
}
GetKeywordsForProperty
(
propertyID
aResult
)
;
CSSPROPS_FOR_SHORTHAND_SUBPROPERTIES
(
subproperty
propertyID
CSSEnabledState
:
:
eForAllContent
)
{
uint32_t
propertyParserVariant
=
nsCSSProps
:
:
ParserVariant
(
*
subproperty
)
;
GetKeywordsForProperty
(
*
subproperty
aResult
)
;
GetOtherValuesForProperty
(
propertyParserVariant
aResult
)
;
}
}
InsertNoDuplicates
(
aResult
NS_LITERAL_STRING
(
"
initial
"
)
)
;
InsertNoDuplicates
(
aResult
NS_LITERAL_STRING
(
"
inherit
"
)
)
;
InsertNoDuplicates
(
aResult
NS_LITERAL_STRING
(
"
unset
"
)
)
;
}
void
InspectorUtils
:
:
RgbToColorName
(
GlobalObject
&
aGlobalObject
uint8_t
aR
uint8_t
aG
uint8_t
aB
nsAString
&
aColorName
ErrorResult
&
aRv
)
{
const
char
*
color
=
NS_RGBToColorName
(
NS_RGB
(
aR
aG
aB
)
)
;
if
(
!
color
)
{
aColorName
.
Truncate
(
)
;
aRv
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
;
}
aColorName
.
AssignASCII
(
color
)
;
}
void
InspectorUtils
:
:
ColorToRGBA
(
GlobalObject
&
aGlobalObject
const
nsAString
&
aColorString
Nullable
<
InspectorRGBATuple
>
&
aResult
)
{
nscolor
color
=
NS_RGB
(
0
0
0
)
;
if
(
!
ServoCSSParser
:
:
ComputeColor
(
nullptr
NS_RGB
(
0
0
0
)
aColorString
&
color
)
)
{
aResult
.
SetNull
(
)
;
return
;
}
InspectorRGBATuple
&
tuple
=
aResult
.
SetValue
(
)
;
tuple
.
mR
=
NS_GET_R
(
color
)
;
tuple
.
mG
=
NS_GET_G
(
color
)
;
tuple
.
mB
=
NS_GET_B
(
color
)
;
tuple
.
mA
=
nsStyleUtil
:
:
ColorComponentToFloat
(
NS_GET_A
(
color
)
)
;
}
bool
InspectorUtils
:
:
IsValidCSSColor
(
GlobalObject
&
aGlobalObject
const
nsAString
&
aColorString
)
{
return
ServoCSSParser
:
:
IsValidCSSColor
(
aColorString
)
;
}
void
InspectorUtils
:
:
GetBindingURLs
(
GlobalObject
&
aGlobalObject
Element
&
aElement
nsTArray
<
nsString
>
&
aResult
)
{
nsXBLBinding
*
binding
=
aElement
.
GetXBLBinding
(
)
;
while
(
binding
)
{
nsCString
spec
;
nsCOMPtr
<
nsIURI
>
bindingURI
=
binding
-
>
PrototypeBinding
(
)
-
>
BindingURI
(
)
;
bindingURI
-
>
GetSpec
(
spec
)
;
nsString
*
resultURI
=
aResult
.
AppendElement
(
)
;
CopyASCIItoUTF16
(
spec
*
resultURI
)
;
binding
=
binding
-
>
GetBaseBinding
(
)
;
}
}
bool
InspectorUtils
:
:
SetContentState
(
GlobalObject
&
aGlobalObject
Element
&
aElement
uint64_t
aState
ErrorResult
&
aRv
)
{
RefPtr
<
EventStateManager
>
esm
=
inLayoutUtils
:
:
GetEventStateManagerFor
(
aElement
)
;
if
(
!
esm
)
{
aRv
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
false
;
}
return
esm
-
>
SetContentState
(
&
aElement
EventStates
(
aState
)
)
;
}
bool
InspectorUtils
:
:
RemoveContentState
(
GlobalObject
&
aGlobalObject
Element
&
aElement
uint64_t
aState
bool
aClearActiveDocument
ErrorResult
&
aRv
)
{
RefPtr
<
EventStateManager
>
esm
=
inLayoutUtils
:
:
GetEventStateManagerFor
(
aElement
)
;
if
(
!
esm
)
{
aRv
.
Throw
(
NS_ERROR_INVALID_ARG
)
;
return
false
;
}
bool
result
=
esm
-
>
SetContentState
(
nullptr
EventStates
(
aState
)
)
;
if
(
aClearActiveDocument
&
&
EventStates
(
aState
)
=
=
NS_EVENT_STATE_ACTIVE
)
{
EventStateManager
*
activeESM
=
static_cast
<
EventStateManager
*
>
(
EventStateManager
:
:
GetActiveEventStateManager
(
)
)
;
if
(
activeESM
=
=
esm
)
{
EventStateManager
:
:
ClearGlobalActiveContent
(
nullptr
)
;
}
}
return
result
;
}
uint64_t
InspectorUtils
:
:
GetContentState
(
GlobalObject
&
aGlobalObject
Element
&
aElement
)
{
return
aElement
.
State
(
)
.
GetInternalValue
(
)
;
}
already_AddRefed
<
ComputedStyle
>
InspectorUtils
:
:
GetCleanComputedStyleForElement
(
dom
:
:
Element
*
aElement
nsAtom
*
aPseudo
)
{
MOZ_ASSERT
(
aElement
)
;
nsIDocument
*
doc
=
aElement
-
>
GetComposedDoc
(
)
;
if
(
!
doc
)
{
return
nullptr
;
}
nsIPresShell
*
presShell
=
doc
-
>
GetShell
(
)
;
if
(
!
presShell
)
{
return
nullptr
;
}
nsPresContext
*
presContext
=
presShell
-
>
GetPresContext
(
)
;
if
(
!
presContext
)
{
return
nullptr
;
}
presContext
-
>
EnsureSafeToHandOutCSSRules
(
)
;
return
nsComputedDOMStyle
:
:
GetComputedStyle
(
aElement
aPseudo
)
;
}
void
InspectorUtils
:
:
GetUsedFontFaces
(
GlobalObject
&
aGlobalObject
nsRange
&
aRange
uint32_t
aMaxRanges
nsTArray
<
nsAutoPtr
<
InspectorFontFace
>
>
&
aResult
ErrorResult
&
aRv
)
{
nsresult
rv
=
aRange
.
GetUsedFontFaces
(
aResult
aMaxRanges
)
;
if
(
NS_FAILED
(
rv
)
)
{
aRv
.
Throw
(
rv
)
;
}
}
static
EventStates
GetStatesForPseudoClass
(
const
nsAString
&
aStatePseudo
)
{
if
(
aStatePseudo
.
IsEmpty
(
)
|
|
aStatePseudo
[
0
]
!
=
u
'
:
'
)
{
return
EventStates
(
)
;
}
NS_ConvertUTF16toUTF8
statePseudo
(
Substring
(
aStatePseudo
1
)
)
;
return
EventStates
(
Servo_PseudoClass_GetStates
(
&
statePseudo
)
)
;
}
void
InspectorUtils
:
:
GetCSSPseudoElementNames
(
GlobalObject
&
aGlobalObject
nsTArray
<
nsString
>
&
aResult
)
{
const
CSSPseudoElementTypeBase
pseudoCount
=
static_cast
<
CSSPseudoElementTypeBase
>
(
CSSPseudoElementType
:
:
Count
)
;
for
(
CSSPseudoElementTypeBase
i
=
0
;
i
<
pseudoCount
;
+
+
i
)
{
CSSPseudoElementType
type
=
static_cast
<
CSSPseudoElementType
>
(
i
)
;
if
(
nsCSSPseudoElements
:
:
IsEnabled
(
type
CSSEnabledState
:
:
eForAllContent
)
)
{
nsAtom
*
atom
=
nsCSSPseudoElements
:
:
GetPseudoAtom
(
type
)
;
aResult
.
AppendElement
(
nsDependentAtomString
(
atom
)
)
;
}
}
}
void
InspectorUtils
:
:
AddPseudoClassLock
(
GlobalObject
&
aGlobalObject
Element
&
aElement
const
nsAString
&
aPseudoClass
bool
aEnabled
)
{
EventStates
state
=
GetStatesForPseudoClass
(
aPseudoClass
)
;
if
(
state
.
IsEmpty
(
)
)
{
return
;
}
aElement
.
LockStyleStates
(
state
aEnabled
)
;
}
void
InspectorUtils
:
:
RemovePseudoClassLock
(
GlobalObject
&
aGlobal
Element
&
aElement
const
nsAString
&
aPseudoClass
)
{
EventStates
state
=
GetStatesForPseudoClass
(
aPseudoClass
)
;
if
(
state
.
IsEmpty
(
)
)
{
return
;
}
aElement
.
UnlockStyleStates
(
state
)
;
}
bool
InspectorUtils
:
:
HasPseudoClassLock
(
GlobalObject
&
aGlobalObject
Element
&
aElement
const
nsAString
&
aPseudoClass
)
{
EventStates
state
=
GetStatesForPseudoClass
(
aPseudoClass
)
;
if
(
state
.
IsEmpty
(
)
)
{
return
false
;
}
EventStates
locks
=
aElement
.
LockedStyleStates
(
)
.
mLocks
;
return
locks
.
HasAllStates
(
state
)
;
}
void
InspectorUtils
:
:
ClearPseudoClassLocks
(
GlobalObject
&
aGlobalObject
Element
&
aElement
)
{
aElement
.
ClearStyleStateLocks
(
)
;
}
void
InspectorUtils
:
:
ParseStyleSheet
(
GlobalObject
&
aGlobalObject
StyleSheet
&
aSheet
const
nsAString
&
aInput
ErrorResult
&
aRv
)
{
RefPtr
<
ServoStyleSheet
>
servoSheet
=
aSheet
.
AsServo
(
)
;
aRv
=
servoSheet
-
>
ReparseSheet
(
aInput
)
;
}
void
InspectorUtils
:
:
ScrollElementIntoView
(
GlobalObject
&
aGlobalObject
Element
&
aElement
)
{
nsIPresShell
*
presShell
=
aElement
.
OwnerDoc
(
)
-
>
GetShell
(
)
;
if
(
!
presShell
)
{
return
;
}
presShell
-
>
ScrollContentIntoView
(
&
aElement
nsIPresShell
:
:
ScrollAxis
(
)
nsIPresShell
:
:
ScrollAxis
(
)
nsIPresShell
:
:
SCROLL_OVERFLOW_HIDDEN
)
;
}
}
}
