#
include
"
nsSVGMarkerFrame
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
SVGObserverUtils
.
h
"
#
include
"
mozilla
/
dom
/
SVGMarkerElement
.
h
"
#
include
"
SVGGeometryElement
.
h
"
#
include
"
SVGGeometryFrame
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
image
;
nsContainerFrame
*
NS_NewSVGMarkerFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsSVGMarkerFrame
(
aStyle
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsSVGMarkerFrame
)
nsresult
nsSVGMarkerFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
if
(
aNameSpaceID
=
=
kNameSpaceID_None
&
&
(
aAttribute
=
=
nsGkAtoms
:
:
markerUnits
|
|
aAttribute
=
=
nsGkAtoms
:
:
refX
|
|
aAttribute
=
=
nsGkAtoms
:
:
refY
|
|
aAttribute
=
=
nsGkAtoms
:
:
markerWidth
|
|
aAttribute
=
=
nsGkAtoms
:
:
markerHeight
|
|
aAttribute
=
=
nsGkAtoms
:
:
orient
|
|
aAttribute
=
=
nsGkAtoms
:
:
preserveAspectRatio
|
|
aAttribute
=
=
nsGkAtoms
:
:
viewBox
)
)
{
SVGObserverUtils
:
:
InvalidateDirectRenderingObservers
(
this
)
;
}
return
nsSVGContainerFrame
:
:
AttributeChanged
(
aNameSpaceID
aAttribute
aModType
)
;
}
#
ifdef
DEBUG
void
nsSVGMarkerFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
NS_ASSERTION
(
aContent
-
>
IsSVGElement
(
nsGkAtoms
:
:
marker
)
"
Content
is
not
an
SVG
marker
"
)
;
nsSVGContainerFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
}
#
endif
gfxMatrix
nsSVGMarkerFrame
:
:
GetCanvasTM
(
)
{
NS_ASSERTION
(
mMarkedFrame
"
null
SVGGeometry
frame
"
)
;
if
(
mInUse2
)
{
return
gfxMatrix
(
)
;
}
SVGMarkerElement
*
content
=
static_cast
<
SVGMarkerElement
*
>
(
GetContent
(
)
)
;
mInUse2
=
true
;
gfxMatrix
markedTM
=
mMarkedFrame
-
>
GetCanvasTM
(
)
;
mInUse2
=
false
;
Matrix
viewBoxTM
=
content
-
>
GetViewBoxTransform
(
)
;
return
ThebesMatrix
(
viewBoxTM
*
mMarkerTM
)
*
markedTM
;
}
static
nsIFrame
*
GetAnonymousChildFrame
(
nsIFrame
*
aFrame
)
{
nsIFrame
*
kid
=
aFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
MOZ_ASSERT
(
kid
&
&
kid
-
>
IsSVGMarkerAnonChildFrame
(
)
"
expected
to
find
anonymous
child
of
marker
frame
"
)
;
return
kid
;
}
void
nsSVGMarkerFrame
:
:
PaintMark
(
gfxContext
&
aContext
const
gfxMatrix
&
aToMarkedFrameUserSpace
SVGGeometryFrame
*
aMarkedFrame
const
SVGMark
&
aMark
float
aStrokeWidth
imgDrawingParams
&
aImgParams
)
{
if
(
mInUse
)
{
return
;
}
AutoMarkerReferencer
markerRef
(
this
aMarkedFrame
)
;
SVGMarkerElement
*
marker
=
static_cast
<
SVGMarkerElement
*
>
(
GetContent
(
)
)
;
if
(
!
marker
-
>
HasValidDimensions
(
)
)
{
return
;
}
const
SVGViewBoxRect
viewBox
=
marker
-
>
GetViewBoxRect
(
)
;
if
(
viewBox
.
width
<
=
0
.
0f
|
|
viewBox
.
height
<
=
0
.
0f
)
{
return
;
}
Matrix
viewBoxTM
=
marker
-
>
GetViewBoxTransform
(
)
;
mMarkerTM
=
marker
-
>
GetMarkerTransform
(
aStrokeWidth
aMark
)
;
gfxMatrix
markTM
=
ThebesMatrix
(
viewBoxTM
)
*
ThebesMatrix
(
mMarkerTM
)
*
aToMarkedFrameUserSpace
;
if
(
StyleDisplay
(
)
-
>
IsScrollableOverflow
(
)
)
{
aContext
.
Save
(
)
;
gfxRect
clipRect
=
nsSVGUtils
:
:
GetClipRectForFrame
(
this
viewBox
.
x
viewBox
.
y
viewBox
.
width
viewBox
.
height
)
;
nsSVGUtils
:
:
SetClipRect
(
&
aContext
markTM
clipRect
)
;
}
nsIFrame
*
kid
=
GetAnonymousChildFrame
(
this
)
;
nsSVGDisplayableFrame
*
SVGFrame
=
do_QueryFrame
(
kid
)
;
SVGFrame
-
>
NotifySVGChanged
(
nsSVGDisplayableFrame
:
:
TRANSFORM_CHANGED
)
;
nsSVGUtils
:
:
PaintFrameWithEffects
(
kid
aContext
markTM
aImgParams
)
;
if
(
StyleDisplay
(
)
-
>
IsScrollableOverflow
(
)
)
aContext
.
Restore
(
)
;
}
SVGBBox
nsSVGMarkerFrame
:
:
GetMarkBBoxContribution
(
const
Matrix
&
aToBBoxUserspace
uint32_t
aFlags
SVGGeometryFrame
*
aMarkedFrame
const
SVGMark
&
aMark
float
aStrokeWidth
)
{
SVGBBox
bbox
;
if
(
mInUse
)
{
return
bbox
;
}
AutoMarkerReferencer
markerRef
(
this
aMarkedFrame
)
;
SVGMarkerElement
*
content
=
static_cast
<
SVGMarkerElement
*
>
(
GetContent
(
)
)
;
if
(
!
content
-
>
HasValidDimensions
(
)
)
{
return
bbox
;
}
const
SVGViewBoxRect
viewBox
=
content
-
>
GetViewBoxRect
(
)
;
if
(
viewBox
.
width
<
=
0
.
0f
|
|
viewBox
.
height
<
=
0
.
0f
)
{
return
bbox
;
}
mMarkerTM
=
content
-
>
GetMarkerTransform
(
aStrokeWidth
aMark
)
;
Matrix
viewBoxTM
=
content
-
>
GetViewBoxTransform
(
)
;
Matrix
tm
=
viewBoxTM
*
mMarkerTM
*
aToBBoxUserspace
;
nsSVGDisplayableFrame
*
child
=
do_QueryFrame
(
GetAnonymousChildFrame
(
this
)
)
;
bbox
.
UnionEdges
(
child
-
>
GetBBoxContribution
(
tm
aFlags
)
)
;
return
bbox
;
}
void
nsSVGMarkerFrame
:
:
SetParentCoordCtxProvider
(
SVGViewportElement
*
aContext
)
{
SVGMarkerElement
*
marker
=
static_cast
<
SVGMarkerElement
*
>
(
GetContent
(
)
)
;
marker
-
>
SetParentCoordCtxProvider
(
aContext
)
;
}
void
nsSVGMarkerFrame
:
:
AppendDirectlyOwnedAnonBoxes
(
nsTArray
<
OwnedAnonBox
>
&
aResult
)
{
aResult
.
AppendElement
(
OwnedAnonBox
(
GetAnonymousChildFrame
(
this
)
)
)
;
}
nsSVGMarkerFrame
:
:
AutoMarkerReferencer
:
:
AutoMarkerReferencer
(
nsSVGMarkerFrame
*
aFrame
SVGGeometryFrame
*
aMarkedFrame
MOZ_GUARD_OBJECT_NOTIFIER_PARAM_IN_IMPL
)
:
mFrame
(
aFrame
)
{
MOZ_GUARD_OBJECT_NOTIFIER_INIT
;
mFrame
-
>
mInUse
=
true
;
mFrame
-
>
mMarkedFrame
=
aMarkedFrame
;
SVGViewportElement
*
ctx
=
static_cast
<
SVGElement
*
>
(
aMarkedFrame
-
>
GetContent
(
)
)
-
>
GetCtx
(
)
;
mFrame
-
>
SetParentCoordCtxProvider
(
ctx
)
;
}
nsSVGMarkerFrame
:
:
AutoMarkerReferencer
:
:
~
AutoMarkerReferencer
(
)
{
mFrame
-
>
SetParentCoordCtxProvider
(
nullptr
)
;
mFrame
-
>
mMarkedFrame
=
nullptr
;
mFrame
-
>
mInUse
=
false
;
}
nsContainerFrame
*
NS_NewSVGMarkerAnonChildFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsSVGMarkerAnonChildFrame
(
aStyle
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsSVGMarkerAnonChildFrame
)
#
ifdef
DEBUG
void
nsSVGMarkerAnonChildFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
MOZ_ASSERT
(
aParent
-
>
IsSVGMarkerFrame
(
)
"
Unexpected
parent
"
)
;
nsSVGDisplayContainerFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
}
#
endif
