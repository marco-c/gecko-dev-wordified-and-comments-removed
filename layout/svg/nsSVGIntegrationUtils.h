#
ifndef
NSSVGINTEGRATIONUTILS_H_
#
define
NSSVGINTEGRATIONUTILS_H_
#
include
"
ImgDrawResult
.
h
"
#
include
"
gfxMatrix
.
h
"
#
include
"
gfxRect
.
h
"
#
include
"
nsRegionFwd
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderTypes
.
h
"
class
gfxContext
;
class
gfxDrawable
;
class
nsDisplayList
;
class
nsDisplayListBuilder
;
class
nsIFrame
;
struct
nsRect
;
namespace
mozilla
{
namespace
gfx
{
class
DrawTarget
;
}
namespace
layers
{
class
LayerManager
;
}
}
struct
nsPoint
;
struct
nsSize
;
struct
WrFiltersHolder
{
nsTArray
<
mozilla
:
:
wr
:
:
FilterOp
>
filters
;
nsTArray
<
mozilla
:
:
wr
:
:
WrFilterData
>
filter_datas
;
nsTArray
<
nsTArray
<
float
>
>
values
;
}
;
class
nsSVGIntegrationUtils
final
{
typedef
mozilla
:
:
gfx
:
:
DrawTarget
DrawTarget
;
typedef
mozilla
:
:
gfx
:
:
IntRect
IntRect
;
typedef
mozilla
:
:
image
:
:
imgDrawingParams
imgDrawingParams
;
public
:
static
bool
UsingOverflowAffectingEffects
(
const
nsIFrame
*
aFrame
)
;
static
bool
UsingEffectsForFrame
(
const
nsIFrame
*
aFrame
)
;
static
bool
UsingMaskOrClipPathForFrame
(
const
nsIFrame
*
aFrame
)
;
static
bool
UsingSimpleClipPathForFrame
(
const
nsIFrame
*
aFrame
)
;
static
nsSize
GetContinuationUnionSize
(
nsIFrame
*
aNonSVGFrame
)
;
static
mozilla
:
:
gfx
:
:
Size
GetSVGCoordContextForNonSVGFrame
(
nsIFrame
*
aNonSVGFrame
)
;
static
gfxRect
GetSVGBBoxForNonSVGFrame
(
nsIFrame
*
aNonSVGFrame
bool
aUnionContinuations
)
;
static
nsRect
ComputePostEffectsVisualOverflowRect
(
nsIFrame
*
aFrame
const
nsRect
&
aPreEffectsOverflowRect
)
;
static
nsIntRegion
AdjustInvalidAreaForSVGEffects
(
nsIFrame
*
aFrame
const
nsPoint
&
aToReferenceFrame
const
nsIntRegion
&
aInvalidRegion
)
;
static
nsRect
GetRequiredSourceForInvalidArea
(
nsIFrame
*
aFrame
const
nsRect
&
aDirtyRect
)
;
static
bool
HitTestFrameForEffects
(
nsIFrame
*
aFrame
const
nsPoint
&
aPt
)
;
struct
MOZ_STACK_CLASS
PaintFramesParams
{
gfxContext
&
ctx
;
nsIFrame
*
frame
;
const
nsRect
&
dirtyRect
;
const
nsRect
&
borderArea
;
nsDisplayListBuilder
*
builder
;
mozilla
:
:
layers
:
:
LayerManager
*
layerManager
;
bool
handleOpacity
;
mozilla
:
:
Maybe
<
mozilla
:
:
gfx
:
:
Rect
>
maskRect
;
imgDrawingParams
&
imgParams
;
explicit
PaintFramesParams
(
gfxContext
&
aCtx
nsIFrame
*
aFrame
const
nsRect
&
aDirtyRect
const
nsRect
&
aBorderArea
nsDisplayListBuilder
*
aBuilder
mozilla
:
:
layers
:
:
LayerManager
*
aLayerManager
bool
aHandleOpacity
imgDrawingParams
&
aImgParams
)
:
ctx
(
aCtx
)
frame
(
aFrame
)
dirtyRect
(
aDirtyRect
)
borderArea
(
aBorderArea
)
builder
(
aBuilder
)
layerManager
(
aLayerManager
)
handleOpacity
(
aHandleOpacity
)
imgParams
(
aImgParams
)
{
}
}
;
static
void
PaintMaskAndClipPath
(
const
PaintFramesParams
&
aParams
)
;
static
void
PaintMaskAndClipPath
(
const
PaintFramesParams
&
aParams
const
std
:
:
function
<
void
(
)
>
&
aPaintChild
)
;
static
bool
PaintMask
(
const
PaintFramesParams
&
aParams
)
;
static
bool
IsMaskResourceReady
(
nsIFrame
*
aFrame
)
;
static
void
PaintFilter
(
const
PaintFramesParams
&
aParams
)
;
static
bool
BuildWebRenderFilters
(
nsIFrame
*
aFilteredFrame
WrFiltersHolder
&
aWrFilters
mozilla
:
:
Maybe
<
nsRect
>
&
aPostFilterClip
)
;
enum
{
FLAG_SYNC_DECODE_IMAGES
=
0x01
}
;
static
already_AddRefed
<
gfxDrawable
>
DrawableFromPaintServer
(
nsIFrame
*
aFrame
nsIFrame
*
aTarget
const
nsSize
&
aPaintServerSize
const
mozilla
:
:
gfx
:
:
IntSize
&
aRenderSize
const
DrawTarget
*
aDrawTarget
const
gfxMatrix
&
aContextMatrix
uint32_t
aFlags
)
;
static
nsPoint
GetOffsetToBoundingBox
(
nsIFrame
*
aFrame
)
;
}
;
#
endif
