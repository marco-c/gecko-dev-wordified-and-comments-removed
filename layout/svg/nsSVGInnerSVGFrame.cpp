#
include
"
nsSVGInnerSVGFrame
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsSVGDisplayableFrame
.
h
"
#
include
"
nsSVGContainerFrame
.
h
"
#
include
"
nsSVGIntegrationUtils
.
h
"
#
include
"
mozilla
/
dom
/
SVGSVGElement
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
image
;
nsIFrame
*
NS_NewSVGInnerSVGFrame
(
nsIPresShell
*
aPresShell
nsStyleContext
*
aContext
)
{
return
new
(
aPresShell
)
nsSVGInnerSVGFrame
(
aContext
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsSVGInnerSVGFrame
)
NS_QUERYFRAME_HEAD
(
nsSVGInnerSVGFrame
)
NS_QUERYFRAME_ENTRY
(
nsSVGInnerSVGFrame
)
NS_QUERYFRAME_ENTRY
(
nsISVGSVGFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsSVGDisplayContainerFrame
)
#
ifdef
DEBUG
void
nsSVGInnerSVGFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
NS_ASSERTION
(
aContent
-
>
IsSVGElement
(
nsGkAtoms
:
:
svg
)
"
Content
is
not
an
SVG
'
svg
'
element
!
"
)
;
nsSVGDisplayContainerFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
}
#
endif
nsIAtom
*
nsSVGInnerSVGFrame
:
:
GetType
(
)
const
{
return
nsGkAtoms
:
:
svgInnerSVGFrame
;
}
DrawResult
nsSVGInnerSVGFrame
:
:
PaintSVG
(
gfxContext
&
aContext
const
gfxMatrix
&
aTransform
const
nsIntRect
*
aDirtyRect
uint32_t
aFlags
)
{
NS_ASSERTION
(
!
NS_SVGDisplayListPaintingEnabled
(
)
|
|
(
mState
&
NS_FRAME_IS_NONDISPLAY
)
"
If
display
lists
are
enabled
only
painting
of
non
-
display
"
"
SVG
should
take
this
code
path
"
)
;
gfxContextAutoSaveRestore
autoSR
;
if
(
StyleDisplay
(
)
-
>
IsScrollableOverflow
(
)
)
{
float
x
y
width
height
;
static_cast
<
SVGSVGElement
*
>
(
mContent
)
-
>
GetAnimatedLengthValues
(
&
x
&
y
&
width
&
height
nullptr
)
;
if
(
width
<
=
0
|
|
height
<
=
0
)
{
return
DrawResult
:
:
SUCCESS
;
}
autoSR
.
SetContext
(
&
aContext
)
;
gfxRect
clipRect
=
nsSVGUtils
:
:
GetClipRectForFrame
(
this
x
y
width
height
)
;
nsSVGUtils
:
:
SetClipRect
(
&
aContext
aTransform
clipRect
)
;
}
return
nsSVGDisplayContainerFrame
:
:
PaintSVG
(
aContext
aTransform
aDirtyRect
aFlags
)
;
}
void
nsSVGInnerSVGFrame
:
:
ReflowSVG
(
)
{
float
x
y
width
height
;
static_cast
<
SVGSVGElement
*
>
(
mContent
)
-
>
GetAnimatedLengthValues
(
&
x
&
y
&
width
&
height
nullptr
)
;
mRect
=
nsLayoutUtils
:
:
RoundGfxRectToAppRect
(
gfxRect
(
x
y
width
height
)
PresContext
(
)
-
>
AppUnitsPerCSSPixel
(
)
)
;
if
(
StyleEffects
(
)
-
>
HasFilters
(
)
)
{
InvalidateFrame
(
)
;
}
nsSVGDisplayContainerFrame
:
:
ReflowSVG
(
)
;
}
void
nsSVGInnerSVGFrame
:
:
NotifySVGChanged
(
uint32_t
aFlags
)
{
MOZ_ASSERT
(
aFlags
&
(
TRANSFORM_CHANGED
|
COORD_CONTEXT_CHANGED
)
"
Invalidation
logic
may
need
adjusting
"
)
;
if
(
aFlags
&
COORD_CONTEXT_CHANGED
)
{
SVGSVGElement
*
svg
=
static_cast
<
SVGSVGElement
*
>
(
mContent
)
;
bool
xOrYIsPercentage
=
svg
-
>
mLengthAttributes
[
SVGSVGElement
:
:
ATTR_X
]
.
IsPercentage
(
)
|
|
svg
-
>
mLengthAttributes
[
SVGSVGElement
:
:
ATTR_Y
]
.
IsPercentage
(
)
;
bool
widthOrHeightIsPercentage
=
svg
-
>
mLengthAttributes
[
SVGSVGElement
:
:
ATTR_WIDTH
]
.
IsPercentage
(
)
|
|
svg
-
>
mLengthAttributes
[
SVGSVGElement
:
:
ATTR_HEIGHT
]
.
IsPercentage
(
)
;
if
(
xOrYIsPercentage
|
|
widthOrHeightIsPercentage
)
{
nsSVGUtils
:
:
ScheduleReflowSVG
(
this
)
;
}
if
(
!
(
aFlags
&
TRANSFORM_CHANGED
)
&
&
(
xOrYIsPercentage
|
|
(
widthOrHeightIsPercentage
&
&
svg
-
>
HasViewBoxRect
(
)
)
)
)
{
aFlags
|
=
TRANSFORM_CHANGED
;
}
if
(
svg
-
>
HasViewBoxRect
(
)
|
|
!
widthOrHeightIsPercentage
)
{
aFlags
&
=
~
COORD_CONTEXT_CHANGED
;
if
(
!
aFlags
)
{
return
;
}
}
}
if
(
aFlags
&
TRANSFORM_CHANGED
)
{
mCanvasTM
=
nullptr
;
}
nsSVGDisplayContainerFrame
:
:
NotifySVGChanged
(
aFlags
)
;
}
SVGBBox
nsSVGInnerSVGFrame
:
:
GetBBoxContribution
(
const
Matrix
&
aToBBoxUserspace
uint32_t
aFlags
)
{
SVGBBox
bbox
;
if
(
aFlags
&
nsSVGUtils
:
:
eForGetClientRects
)
{
float
x
y
w
h
;
static_cast
<
SVGSVGElement
*
>
(
mContent
)
-
>
GetAnimatedLengthValues
(
&
x
&
y
&
w
&
h
nullptr
)
;
if
(
w
<
0
.
0f
)
w
=
0
.
0f
;
if
(
h
<
0
.
0f
)
h
=
0
.
0f
;
Rect
viewport
(
x
y
w
h
)
;
bbox
=
aToBBoxUserspace
.
TransformBounds
(
viewport
)
;
if
(
StyleDisplay
(
)
-
>
IsScrollableOverflow
(
)
)
{
return
bbox
;
}
}
SVGBBox
descendantsBbox
=
nsSVGDisplayContainerFrame
:
:
GetBBoxContribution
(
aToBBoxUserspace
aFlags
)
;
bbox
.
UnionEdges
(
descendantsBbox
)
;
return
bbox
;
}
nsresult
nsSVGInnerSVGFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsIAtom
*
aAttribute
int32_t
aModType
)
{
if
(
aNameSpaceID
=
=
kNameSpaceID_None
&
&
!
(
GetStateBits
(
)
&
NS_FRAME_IS_NONDISPLAY
)
)
{
SVGSVGElement
*
content
=
static_cast
<
SVGSVGElement
*
>
(
mContent
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
width
|
|
aAttribute
=
=
nsGkAtoms
:
:
height
)
{
nsLayoutUtils
:
:
PostRestyleEvent
(
mContent
-
>
AsElement
(
)
nsRestyleHint
(
0
)
nsChangeHint_InvalidateRenderingObservers
)
;
nsSVGUtils
:
:
ScheduleReflowSVG
(
this
)
;
if
(
content
-
>
HasViewBoxOrSyntheticViewBox
(
)
)
{
mCanvasTM
=
nullptr
;
content
-
>
ChildrenOnlyTransformChanged
(
)
;
nsSVGUtils
:
:
NotifyChildrenOfSVGChange
(
this
TRANSFORM_CHANGED
)
;
}
else
{
uint32_t
flags
=
COORD_CONTEXT_CHANGED
;
if
(
mCanvasTM
&
&
mCanvasTM
-
>
IsSingular
(
)
)
{
mCanvasTM
=
nullptr
;
flags
|
=
TRANSFORM_CHANGED
;
}
nsSVGUtils
:
:
NotifyChildrenOfSVGChange
(
this
flags
)
;
}
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
transform
|
|
aAttribute
=
=
nsGkAtoms
:
:
preserveAspectRatio
|
|
aAttribute
=
=
nsGkAtoms
:
:
viewBox
|
|
aAttribute
=
=
nsGkAtoms
:
:
x
|
|
aAttribute
=
=
nsGkAtoms
:
:
y
)
{
mCanvasTM
=
nullptr
;
nsSVGUtils
:
:
NotifyChildrenOfSVGChange
(
this
aAttribute
=
=
nsGkAtoms
:
:
viewBox
?
TRANSFORM_CHANGED
|
COORD_CONTEXT_CHANGED
:
TRANSFORM_CHANGED
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
x
|
|
aAttribute
=
=
nsGkAtoms
:
:
y
)
{
nsLayoutUtils
:
:
PostRestyleEvent
(
mContent
-
>
AsElement
(
)
nsRestyleHint
(
0
)
nsChangeHint_InvalidateRenderingObservers
)
;
nsSVGUtils
:
:
ScheduleReflowSVG
(
this
)
;
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
viewBox
|
|
(
aAttribute
=
=
nsGkAtoms
:
:
preserveAspectRatio
&
&
content
-
>
HasViewBoxOrSyntheticViewBox
(
)
)
)
{
content
-
>
ChildrenOnlyTransformChanged
(
)
;
SchedulePaint
(
)
;
}
}
}
return
NS_OK
;
}
nsIFrame
*
nsSVGInnerSVGFrame
:
:
GetFrameForPoint
(
const
gfxPoint
&
aPoint
)
{
NS_ASSERTION
(
!
NS_SVGDisplayListHitTestingEnabled
(
)
|
|
(
mState
&
NS_FRAME_IS_NONDISPLAY
)
"
If
display
lists
are
enabled
only
hit
-
testing
of
non
-
display
"
"
SVG
should
take
this
code
path
"
)
;
if
(
StyleDisplay
(
)
-
>
IsScrollableOverflow
(
)
)
{
Rect
clip
;
static_cast
<
nsSVGElement
*
>
(
mContent
)
-
>
GetAnimatedLengthValues
(
&
clip
.
x
&
clip
.
y
&
clip
.
width
&
clip
.
height
nullptr
)
;
if
(
!
clip
.
Contains
(
ToPoint
(
aPoint
)
)
)
{
return
nullptr
;
}
}
return
nsSVGDisplayContainerFrame
:
:
GetFrameForPoint
(
aPoint
)
;
}
void
nsSVGInnerSVGFrame
:
:
NotifyViewportOrTransformChanged
(
uint32_t
aFlags
)
{
NS_ERROR
(
"
Not
called
for
nsSVGInnerSVGFrame
"
)
;
}
gfxMatrix
nsSVGInnerSVGFrame
:
:
GetCanvasTM
(
)
{
if
(
!
mCanvasTM
)
{
NS_ASSERTION
(
GetParent
(
)
"
null
parent
"
)
;
nsSVGContainerFrame
*
parent
=
static_cast
<
nsSVGContainerFrame
*
>
(
GetParent
(
)
)
;
SVGSVGElement
*
content
=
static_cast
<
SVGSVGElement
*
>
(
mContent
)
;
gfxMatrix
tm
=
content
-
>
PrependLocalTransformsTo
(
parent
-
>
GetCanvasTM
(
)
)
;
mCanvasTM
=
new
gfxMatrix
(
tm
)
;
}
return
*
mCanvasTM
;
}
bool
nsSVGInnerSVGFrame
:
:
HasChildrenOnlyTransform
(
gfx
:
:
Matrix
*
aTransform
)
const
{
SVGSVGElement
*
content
=
static_cast
<
SVGSVGElement
*
>
(
mContent
)
;
if
(
content
-
>
HasViewBoxOrSyntheticViewBox
(
)
)
{
if
(
aTransform
)
{
*
aTransform
=
content
-
>
GetViewBoxTransform
(
)
;
}
return
true
;
}
return
false
;
}
