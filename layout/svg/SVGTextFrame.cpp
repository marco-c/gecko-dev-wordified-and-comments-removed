#
include
"
SVGTextFrame
.
h
"
#
include
"
DOMSVGPoint
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxFont
.
h
"
#
include
"
gfxSkipChars
.
h
"
#
include
"
gfxTypes
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
LookAndFeel
.
h
"
#
include
"
nsAlgorithm
.
h
"
#
include
"
nsBidiPresUtils
.
h
"
#
include
"
nsBlockFrame
.
h
"
#
include
"
nsCaret
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
SVGPaintServerFrame
.
h
"
#
include
"
nsTArray
.
h
"
#
include
"
nsTextFrame
.
h
"
#
include
"
SVGAnimatedNumberList
.
h
"
#
include
"
SVGContentUtils
.
h
"
#
include
"
SVGContextPaint
.
h
"
#
include
"
SVGLengthList
.
h
"
#
include
"
SVGNumberList
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
include
"
nsStyleStructInlines
.
h
"
#
include
"
mozilla
/
CaretAssociationHint
.
h
"
#
include
"
mozilla
/
DisplaySVGItem
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
SVGObserverUtils
.
h
"
#
include
"
mozilla
/
SVGOuterSVGFrame
.
h
"
#
include
"
mozilla
/
SVGUtils
.
h
"
#
include
"
mozilla
/
dom
/
DOMPointBinding
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
mozilla
/
dom
/
SVGGeometryElement
.
h
"
#
include
"
mozilla
/
dom
/
SVGRect
.
h
"
#
include
"
mozilla
/
dom
/
SVGTextContentElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
SVGTextPathElement
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
PatternHelpers
.
h
"
#
include
<
algorithm
>
#
include
<
cmath
>
#
include
<
limits
>
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
dom
:
:
SVGTextContentElement_Binding
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
image
;
namespace
mozilla
{
static
gfxTextRun
:
:
Range
ConvertOriginalToSkipped
(
gfxSkipCharsIterator
&
aIterator
uint32_t
aOriginalOffset
uint32_t
aOriginalLength
)
{
uint32_t
start
=
aIterator
.
ConvertOriginalToSkipped
(
aOriginalOffset
)
;
aIterator
.
AdvanceOriginal
(
aOriginalLength
)
;
return
gfxTextRun
:
:
Range
(
start
aIterator
.
GetSkippedOffset
(
)
)
;
}
static
gfxPoint
AppUnitsToGfxUnits
(
const
nsPoint
&
aPoint
const
nsPresContext
*
aContext
)
{
return
gfxPoint
(
aContext
-
>
AppUnitsToGfxUnits
(
aPoint
.
x
)
aContext
-
>
AppUnitsToGfxUnits
(
aPoint
.
y
)
)
;
}
static
gfxRect
AppUnitsToFloatCSSPixels
(
const
gfxRect
&
aRect
const
nsPresContext
*
aContext
)
{
return
gfxRect
(
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
aRect
.
x
)
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
aRect
.
y
)
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
aRect
.
width
)
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
aRect
.
height
)
)
;
}
static
bool
Inside
(
const
gfxRect
&
aRect
const
gfxPoint
&
aPoint
)
{
return
aPoint
.
x
>
=
aRect
.
x
&
&
aPoint
.
x
<
aRect
.
XMost
(
)
&
&
aPoint
.
y
>
=
aRect
.
y
&
&
aPoint
.
y
<
aRect
.
YMost
(
)
;
}
static
void
GetAscentAndDescentInAppUnits
(
nsTextFrame
*
aFrame
gfxFloat
&
aAscent
gfxFloat
&
aDescent
)
{
gfxSkipCharsIterator
it
=
aFrame
-
>
EnsureTextRun
(
nsTextFrame
:
:
eInflated
)
;
gfxTextRun
*
textRun
=
aFrame
-
>
GetTextRun
(
nsTextFrame
:
:
eInflated
)
;
gfxTextRun
:
:
Range
range
=
ConvertOriginalToSkipped
(
it
aFrame
-
>
GetContentOffset
(
)
aFrame
-
>
GetContentLength
(
)
)
;
textRun
-
>
GetLineHeightMetrics
(
range
aAscent
aDescent
)
;
}
static
void
IntersectInterval
(
uint32_t
&
aStart
uint32_t
&
aLength
uint32_t
aStartOther
uint32_t
aLengthOther
)
{
uint32_t
aEnd
=
aStart
+
aLength
;
uint32_t
aEndOther
=
aStartOther
+
aLengthOther
;
if
(
aStartOther
>
=
aEnd
|
|
aStart
>
=
aEndOther
)
{
aLength
=
0
;
}
else
{
if
(
aStartOther
>
=
aStart
)
aStart
=
aStartOther
;
aLength
=
std
:
:
min
(
aEnd
aEndOther
)
-
aStart
;
}
}
static
void
TrimOffsets
(
uint32_t
&
aStart
uint32_t
&
aLength
const
nsTextFrame
:
:
TrimmedOffsets
&
aTrimmedOffsets
)
{
IntersectInterval
(
aStart
aLength
aTrimmedOffsets
.
mStart
aTrimmedOffsets
.
mLength
)
;
}
static
nsIContent
*
GetFirstNonAAncestor
(
nsIContent
*
aContent
)
{
while
(
aContent
&
&
aContent
-
>
IsSVGElement
(
nsGkAtoms
:
:
a
)
)
{
aContent
=
aContent
-
>
GetParent
(
)
;
}
return
aContent
;
}
static
bool
IsTextContentElement
(
nsIContent
*
aContent
)
{
if
(
aContent
-
>
IsSVGElement
(
nsGkAtoms
:
:
text
)
)
{
nsIContent
*
parent
=
GetFirstNonAAncestor
(
aContent
-
>
GetParent
(
)
)
;
return
!
parent
|
|
!
IsTextContentElement
(
parent
)
;
}
if
(
aContent
-
>
IsSVGElement
(
nsGkAtoms
:
:
textPath
)
)
{
nsIContent
*
parent
=
GetFirstNonAAncestor
(
aContent
-
>
GetParent
(
)
)
;
return
parent
&
&
parent
-
>
IsSVGElement
(
nsGkAtoms
:
:
text
)
;
}
return
aContent
-
>
IsAnyOfSVGElements
(
nsGkAtoms
:
:
a
nsGkAtoms
:
:
tspan
)
;
}
static
bool
IsNonEmptyTextFrame
(
nsIFrame
*
aFrame
)
{
nsTextFrame
*
textFrame
=
do_QueryFrame
(
aFrame
)
;
if
(
!
textFrame
)
{
return
false
;
}
return
textFrame
-
>
GetContentLength
(
)
!
=
0
;
}
static
bool
GetNonEmptyTextFrameAndNode
(
nsIFrame
*
aFrame
nsTextFrame
*
&
aTextFrame
Text
*
&
aTextNode
)
{
nsTextFrame
*
text
=
do_QueryFrame
(
aFrame
)
;
bool
isNonEmptyTextFrame
=
text
&
&
text
-
>
GetContentLength
(
)
!
=
0
;
if
(
isNonEmptyTextFrame
)
{
nsIContent
*
content
=
text
-
>
GetContent
(
)
;
NS_ASSERTION
(
content
&
&
content
-
>
IsText
(
)
"
unexpected
content
type
for
nsTextFrame
"
)
;
Text
*
node
=
content
-
>
AsText
(
)
;
MOZ_ASSERT
(
node
-
>
TextLength
(
)
!
=
0
"
frame
'
s
GetContentLength
(
)
should
be
0
if
the
text
node
"
"
has
no
content
"
)
;
aTextFrame
=
text
;
aTextNode
=
node
;
}
MOZ_ASSERT
(
IsNonEmptyTextFrame
(
aFrame
)
=
=
isNonEmptyTextFrame
"
our
logic
should
agree
with
IsNonEmptyTextFrame
"
)
;
return
isNonEmptyTextFrame
;
}
static
bool
IsGlyphPositioningAttribute
(
nsAtom
*
aAttribute
)
{
return
aAttribute
=
=
nsGkAtoms
:
:
x
|
|
aAttribute
=
=
nsGkAtoms
:
:
y
|
|
aAttribute
=
=
nsGkAtoms
:
:
dx
|
|
aAttribute
=
=
nsGkAtoms
:
:
dy
|
|
aAttribute
=
=
nsGkAtoms
:
:
rotate
;
}
static
nscoord
GetBaselinePosition
(
nsTextFrame
*
aFrame
gfxTextRun
*
aTextRun
StyleDominantBaseline
aDominantBaseline
float
aFontSizeScaleFactor
)
{
WritingMode
writingMode
=
aFrame
-
>
GetWritingMode
(
)
;
gfxFloat
ascent
descent
;
aTextRun
-
>
GetLineHeightMetrics
(
ascent
descent
)
;
auto
convertIfVerticalRL
=
[
&
]
(
gfxFloat
dominantBaseline
)
{
return
writingMode
.
IsVerticalRL
(
)
?
ascent
+
descent
-
dominantBaseline
:
dominantBaseline
;
}
;
switch
(
aDominantBaseline
)
{
case
StyleDominantBaseline
:
:
Hanging
:
return
convertIfVerticalRL
(
ascent
*
0
.
2
)
;
case
StyleDominantBaseline
:
:
TextBeforeEdge
:
return
convertIfVerticalRL
(
0
)
;
case
StyleDominantBaseline
:
:
Alphabetic
:
return
writingMode
.
IsVerticalRL
(
)
?
ascent
*
0
.
5
:
aFrame
-
>
GetLogicalBaseline
(
writingMode
)
;
case
StyleDominantBaseline
:
:
Auto
:
return
convertIfVerticalRL
(
aFrame
-
>
GetLogicalBaseline
(
writingMode
)
)
;
case
StyleDominantBaseline
:
:
Middle
:
return
convertIfVerticalRL
(
aFrame
-
>
GetLogicalBaseline
(
writingMode
)
-
SVGContentUtils
:
:
GetFontXHeight
(
aFrame
)
/
2
.
0
*
AppUnitsPerCSSPixel
(
)
*
aFontSizeScaleFactor
)
;
case
StyleDominantBaseline
:
:
TextAfterEdge
:
case
StyleDominantBaseline
:
:
Ideographic
:
return
writingMode
.
IsVerticalLR
(
)
?
0
:
ascent
+
descent
;
case
StyleDominantBaseline
:
:
Central
:
return
(
ascent
+
descent
)
/
2
.
0
;
case
StyleDominantBaseline
:
:
Mathematical
:
return
convertIfVerticalRL
(
ascent
/
2
.
0
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
dominant
-
baseline
value
"
)
;
return
convertIfVerticalRL
(
aFrame
-
>
GetLogicalBaseline
(
writingMode
)
)
;
}
template
<
typename
T
typename
U
>
static
void
TruncateTo
(
nsTArray
<
T
>
&
aArrayToTruncate
const
nsTArray
<
U
>
&
aReferenceArray
)
{
uint32_t
length
=
aReferenceArray
.
Length
(
)
;
if
(
aArrayToTruncate
.
Length
(
)
>
length
)
{
aArrayToTruncate
.
TruncateLength
(
length
)
;
}
}
static
SVGTextFrame
*
FrameIfAnonymousChildReflowed
(
SVGTextFrame
*
aFrame
)
{
MOZ_ASSERT
(
aFrame
"
aFrame
must
not
be
null
"
)
;
nsIFrame
*
kid
=
aFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
kid
-
>
IsSubtreeDirty
(
)
)
{
MOZ_ASSERT
(
false
"
should
have
already
reflowed
the
anonymous
block
child
"
)
;
return
nullptr
;
}
return
aFrame
;
}
static
double
GetContextScale
(
const
gfxMatrix
&
aMatrix
)
{
gfxPoint
p
=
aMatrix
.
TransformPoint
(
gfxPoint
(
1
1
)
)
-
aMatrix
.
TransformPoint
(
gfxPoint
(
0
0
)
)
;
return
SVGContentUtils
:
:
ComputeNormalizedHypotenuse
(
p
.
x
p
.
y
)
;
}
struct
TextRenderedRun
{
using
Range
=
gfxTextRun
:
:
Range
;
TextRenderedRun
(
)
:
mFrame
(
nullptr
)
{
}
TextRenderedRun
(
nsTextFrame
*
aFrame
const
gfxPoint
&
aPosition
float
aLengthAdjustScaleFactor
double
aRotate
float
aFontSizeScaleFactor
nscoord
aBaseline
uint32_t
aTextFrameContentOffset
uint32_t
aTextFrameContentLength
uint32_t
aTextElementCharIndex
)
:
mFrame
(
aFrame
)
mPosition
(
aPosition
)
mLengthAdjustScaleFactor
(
aLengthAdjustScaleFactor
)
mRotate
(
static_cast
<
float
>
(
aRotate
)
)
mFontSizeScaleFactor
(
aFontSizeScaleFactor
)
mBaseline
(
aBaseline
)
mTextFrameContentOffset
(
aTextFrameContentOffset
)
mTextFrameContentLength
(
aTextFrameContentLength
)
mTextElementCharIndex
(
aTextElementCharIndex
)
{
}
gfxTextRun
*
GetTextRun
(
)
const
{
mFrame
-
>
EnsureTextRun
(
nsTextFrame
:
:
eInflated
)
;
return
mFrame
-
>
GetTextRun
(
nsTextFrame
:
:
eInflated
)
;
}
bool
IsRightToLeft
(
)
const
{
return
GetTextRun
(
)
-
>
IsRightToLeft
(
)
;
}
bool
IsVertical
(
)
const
{
return
GetTextRun
(
)
-
>
IsVertical
(
)
;
}
gfxMatrix
GetTransformFromUserSpaceForPainting
(
nsPresContext
*
aContext
const
nscoord
aVisIStartEdge
const
nscoord
aVisIEndEdge
)
const
;
gfxMatrix
GetTransformFromRunUserSpaceToUserSpace
(
nsPresContext
*
aContext
)
const
;
gfxMatrix
GetTransformFromRunUserSpaceToFrameUserSpace
(
nsPresContext
*
aContext
)
const
;
enum
{
eIncludeFill
=
1
eIncludeStroke
=
2
eNoHorizontalOverflow
=
4
}
;
SVGBBox
GetRunUserSpaceRect
(
nsPresContext
*
aContext
uint32_t
aFlags
)
const
;
SVGBBox
GetFrameUserSpaceRect
(
nsPresContext
*
aContext
uint32_t
aFlags
)
const
;
SVGBBox
GetUserSpaceRect
(
nsPresContext
*
aContext
uint32_t
aFlags
const
gfxMatrix
*
aAdditionalTransform
=
nullptr
)
const
;
void
GetClipEdges
(
nscoord
&
aVisIStartEdge
nscoord
&
aVisIEndEdge
)
const
;
nscoord
GetAdvanceWidth
(
)
const
;
int32_t
GetCharNumAtPosition
(
nsPresContext
*
aContext
const
gfxPoint
&
aPoint
)
const
;
nsTextFrame
*
mFrame
;
gfxPoint
mPosition
;
float
mLengthAdjustScaleFactor
;
float
mRotate
;
double
mFontSizeScaleFactor
;
nscoord
mBaseline
;
uint32_t
mTextFrameContentOffset
;
uint32_t
mTextFrameContentLength
;
uint32_t
mTextElementCharIndex
;
}
;
gfxMatrix
TextRenderedRun
:
:
GetTransformFromUserSpaceForPainting
(
nsPresContext
*
aContext
const
nscoord
aVisIStartEdge
const
nscoord
aVisIEndEdge
)
const
{
gfxMatrix
m
;
if
(
!
mFrame
)
{
return
m
;
}
float
cssPxPerDevPx
=
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
aContext
-
>
AppUnitsPerDevPixel
(
)
)
;
m
.
PreTranslate
(
mPosition
/
cssPxPerDevPx
)
;
m
.
PreScale
(
1
.
0
/
mFontSizeScaleFactor
1
.
0
/
mFontSizeScaleFactor
)
;
m
.
PreRotate
(
mRotate
)
;
nsPoint
t
;
if
(
IsVertical
(
)
)
{
m
.
PreScale
(
1
.
0
mLengthAdjustScaleFactor
)
;
t
=
nsPoint
(
-
mBaseline
IsRightToLeft
(
)
?
-
mFrame
-
>
GetRect
(
)
.
height
+
aVisIEndEdge
:
-
aVisIStartEdge
)
;
}
else
{
m
.
PreScale
(
mLengthAdjustScaleFactor
1
.
0
)
;
t
=
nsPoint
(
IsRightToLeft
(
)
?
-
mFrame
-
>
GetRect
(
)
.
width
+
aVisIEndEdge
:
-
aVisIStartEdge
-
mBaseline
)
;
}
m
.
PreTranslate
(
AppUnitsToGfxUnits
(
t
aContext
)
)
;
return
m
;
}
gfxMatrix
TextRenderedRun
:
:
GetTransformFromRunUserSpaceToUserSpace
(
nsPresContext
*
aContext
)
const
{
gfxMatrix
m
;
if
(
!
mFrame
)
{
return
m
;
}
float
cssPxPerDevPx
=
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
aContext
-
>
AppUnitsPerDevPixel
(
)
)
;
nscoord
start
end
;
GetClipEdges
(
start
end
)
;
m
.
PreTranslate
(
mPosition
)
;
m
.
PreRotate
(
mRotate
)
;
nsPoint
t
;
if
(
IsVertical
(
)
)
{
m
.
PreScale
(
1
.
0
mLengthAdjustScaleFactor
)
;
t
=
nsPoint
(
-
mBaseline
IsRightToLeft
(
)
?
-
mFrame
-
>
GetRect
(
)
.
height
+
start
+
end
:
0
)
;
}
else
{
m
.
PreScale
(
mLengthAdjustScaleFactor
1
.
0
)
;
t
=
nsPoint
(
IsRightToLeft
(
)
?
-
mFrame
-
>
GetRect
(
)
.
width
+
start
+
end
:
0
-
mBaseline
)
;
}
m
.
PreTranslate
(
AppUnitsToGfxUnits
(
t
aContext
)
*
cssPxPerDevPx
/
mFontSizeScaleFactor
)
;
return
m
;
}
gfxMatrix
TextRenderedRun
:
:
GetTransformFromRunUserSpaceToFrameUserSpace
(
nsPresContext
*
aContext
)
const
{
gfxMatrix
m
;
if
(
!
mFrame
)
{
return
m
;
}
nscoord
start
end
;
GetClipEdges
(
start
end
)
;
gfxFloat
appPerCssPx
=
AppUnitsPerCSSPixel
(
)
;
gfxPoint
t
=
IsVertical
(
)
?
gfxPoint
(
0
start
/
appPerCssPx
)
:
gfxPoint
(
start
/
appPerCssPx
0
)
;
return
m
.
PreTranslate
(
t
)
;
}
SVGBBox
TextRenderedRun
:
:
GetRunUserSpaceRect
(
nsPresContext
*
aContext
uint32_t
aFlags
)
const
{
SVGBBox
r
;
if
(
!
mFrame
)
{
return
r
;
}
nsRect
self
=
mFrame
-
>
InkOverflowRectRelativeToSelf
(
)
;
nsRect
rect
=
mFrame
-
>
GetRect
(
)
;
bool
vertical
=
IsVertical
(
)
;
nsMargin
inkOverflow
(
vertical
?
-
self
.
x
:
-
self
.
y
vertical
?
self
.
YMost
(
)
-
rect
.
height
:
self
.
XMost
(
)
-
rect
.
width
vertical
?
self
.
XMost
(
)
-
rect
.
width
:
self
.
YMost
(
)
-
rect
.
height
vertical
?
-
self
.
y
:
-
self
.
x
)
;
gfxSkipCharsIterator
it
=
mFrame
-
>
EnsureTextRun
(
nsTextFrame
:
:
eInflated
)
;
gfxSkipCharsIterator
start
=
it
;
gfxTextRun
*
textRun
=
mFrame
-
>
GetTextRun
(
nsTextFrame
:
:
eInflated
)
;
Range
range
=
ConvertOriginalToSkipped
(
it
mTextFrameContentOffset
mTextFrameContentLength
)
;
if
(
range
.
Length
(
)
=
=
0
)
{
return
r
;
}
nsTextFrame
:
:
PropertyProvider
provider
(
mFrame
start
)
;
gfxTextRun
:
:
Metrics
metrics
=
textRun
-
>
MeasureText
(
range
gfxFont
:
:
LOOSE_INK_EXTENTS
nullptr
&
provider
)
;
gfxRect
fontBox
(
0
-
metrics
.
mAscent
metrics
.
mAdvanceWidth
metrics
.
mAscent
+
metrics
.
mDescent
)
;
metrics
.
mBoundingBox
.
UnionRect
(
metrics
.
mBoundingBox
fontBox
)
;
nscoord
baseline
=
NSToCoordRoundWithClamp
(
metrics
.
mBoundingBox
.
y
+
metrics
.
mAscent
)
;
gfxFloat
x
width
;
if
(
aFlags
&
eNoHorizontalOverflow
)
{
x
=
0
.
0
;
width
=
textRun
-
>
GetAdvanceWidth
(
range
&
provider
)
;
if
(
width
<
0
.
0
)
{
x
=
width
;
width
=
-
width
;
}
}
else
{
x
=
metrics
.
mBoundingBox
.
x
;
width
=
metrics
.
mBoundingBox
.
width
;
}
nsRect
fillInAppUnits
(
NSToCoordRoundWithClamp
(
x
)
baseline
NSToCoordRoundWithClamp
(
width
)
NSToCoordRoundWithClamp
(
metrics
.
mBoundingBox
.
height
)
)
;
fillInAppUnits
.
Inflate
(
inkOverflow
)
;
if
(
textRun
-
>
IsVertical
(
)
)
{
std
:
:
swap
(
fillInAppUnits
.
x
fillInAppUnits
.
y
)
;
std
:
:
swap
(
fillInAppUnits
.
width
fillInAppUnits
.
height
)
;
}
gfxRect
fill
=
AppUnitsToFloatCSSPixels
(
gfxRect
(
fillInAppUnits
.
x
fillInAppUnits
.
y
fillInAppUnits
.
width
fillInAppUnits
.
height
)
aContext
)
;
fill
.
Scale
(
1
.
0
/
mFontSizeScaleFactor
)
;
if
(
aFlags
&
eIncludeFill
)
{
r
=
fill
;
}
if
(
(
aFlags
&
eIncludeStroke
)
&
&
!
fill
.
IsEmpty
(
)
&
&
SVGUtils
:
:
GetStrokeWidth
(
mFrame
)
>
0
)
{
r
.
UnionEdges
(
SVGUtils
:
:
PathExtentsToMaxStrokeExtents
(
fill
mFrame
gfxMatrix
(
)
)
)
;
}
return
r
;
}
SVGBBox
TextRenderedRun
:
:
GetFrameUserSpaceRect
(
nsPresContext
*
aContext
uint32_t
aFlags
)
const
{
SVGBBox
r
=
GetRunUserSpaceRect
(
aContext
aFlags
)
;
if
(
r
.
IsEmpty
(
)
)
{
return
r
;
}
gfxMatrix
m
=
GetTransformFromRunUserSpaceToFrameUserSpace
(
aContext
)
;
return
m
.
TransformBounds
(
r
.
ToThebesRect
(
)
)
;
}
SVGBBox
TextRenderedRun
:
:
GetUserSpaceRect
(
nsPresContext
*
aContext
uint32_t
aFlags
const
gfxMatrix
*
aAdditionalTransform
)
const
{
SVGBBox
r
=
GetRunUserSpaceRect
(
aContext
aFlags
)
;
if
(
r
.
IsEmpty
(
)
)
{
return
r
;
}
gfxMatrix
m
=
GetTransformFromRunUserSpaceToUserSpace
(
aContext
)
;
if
(
aAdditionalTransform
)
{
m
*
=
*
aAdditionalTransform
;
}
return
m
.
TransformBounds
(
r
.
ToThebesRect
(
)
)
;
}
void
TextRenderedRun
:
:
GetClipEdges
(
nscoord
&
aVisIStartEdge
nscoord
&
aVisIEndEdge
)
const
{
uint32_t
contentLength
=
mFrame
-
>
GetContentLength
(
)
;
if
(
mTextFrameContentOffset
=
=
0
&
&
mTextFrameContentLength
=
=
contentLength
)
{
aVisIStartEdge
=
0
;
aVisIEndEdge
=
0
;
return
;
}
gfxSkipCharsIterator
it
=
mFrame
-
>
EnsureTextRun
(
nsTextFrame
:
:
eInflated
)
;
gfxTextRun
*
textRun
=
mFrame
-
>
GetTextRun
(
nsTextFrame
:
:
eInflated
)
;
nsTextFrame
:
:
PropertyProvider
provider
(
mFrame
it
)
;
Range
runRange
=
ConvertOriginalToSkipped
(
it
mTextFrameContentOffset
mTextFrameContentLength
)
;
uint32_t
frameOffset
=
mFrame
-
>
GetContentOffset
(
)
;
uint32_t
frameLength
=
mFrame
-
>
GetContentLength
(
)
;
nsTextFrame
:
:
TrimmedOffsets
trimmedOffsets
=
mFrame
-
>
GetTrimmedOffsets
(
mFrame
-
>
TextFragment
(
)
)
;
TrimOffsets
(
frameOffset
frameLength
trimmedOffsets
)
;
Range
frameRange
=
ConvertOriginalToSkipped
(
it
frameOffset
frameLength
)
;
nscoord
startEdge
=
textRun
-
>
GetAdvanceWidth
(
Range
(
frameRange
.
start
runRange
.
start
)
&
provider
)
;
nscoord
endEdge
=
textRun
-
>
GetAdvanceWidth
(
Range
(
runRange
.
end
frameRange
.
end
)
&
provider
)
;
if
(
textRun
-
>
IsRightToLeft
(
)
)
{
aVisIStartEdge
=
endEdge
;
aVisIEndEdge
=
startEdge
;
}
else
{
aVisIStartEdge
=
startEdge
;
aVisIEndEdge
=
endEdge
;
}
}
nscoord
TextRenderedRun
:
:
GetAdvanceWidth
(
)
const
{
gfxSkipCharsIterator
it
=
mFrame
-
>
EnsureTextRun
(
nsTextFrame
:
:
eInflated
)
;
gfxTextRun
*
textRun
=
mFrame
-
>
GetTextRun
(
nsTextFrame
:
:
eInflated
)
;
nsTextFrame
:
:
PropertyProvider
provider
(
mFrame
it
)
;
Range
range
=
ConvertOriginalToSkipped
(
it
mTextFrameContentOffset
mTextFrameContentLength
)
;
return
textRun
-
>
GetAdvanceWidth
(
range
&
provider
)
;
}
int32_t
TextRenderedRun
:
:
GetCharNumAtPosition
(
nsPresContext
*
aContext
const
gfxPoint
&
aPoint
)
const
{
if
(
mTextFrameContentLength
=
=
0
)
{
return
-
1
;
}
float
cssPxPerDevPx
=
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
aContext
-
>
AppUnitsPerDevPixel
(
)
)
;
gfxMatrix
m
=
GetTransformFromRunUserSpaceToUserSpace
(
aContext
)
;
if
(
!
m
.
Invert
(
)
)
{
return
-
1
;
}
gfxPoint
p
=
m
.
TransformPoint
(
aPoint
)
/
cssPxPerDevPx
*
mFontSizeScaleFactor
;
gfxFloat
ascent
descent
;
GetAscentAndDescentInAppUnits
(
mFrame
ascent
descent
)
;
WritingMode
writingMode
=
mFrame
-
>
GetWritingMode
(
)
;
if
(
writingMode
.
IsVertical
(
)
)
{
gfxFloat
leftEdge
=
mFrame
-
>
GetLogicalBaseline
(
writingMode
)
-
(
writingMode
.
IsVerticalRL
(
)
?
ascent
:
descent
)
;
gfxFloat
rightEdge
=
leftEdge
+
ascent
+
descent
;
if
(
p
.
x
<
aContext
-
>
AppUnitsToGfxUnits
(
leftEdge
)
|
|
p
.
x
>
aContext
-
>
AppUnitsToGfxUnits
(
rightEdge
)
)
{
return
-
1
;
}
}
else
{
gfxFloat
topEdge
=
mFrame
-
>
GetLogicalBaseline
(
writingMode
)
-
ascent
;
gfxFloat
bottomEdge
=
topEdge
+
ascent
+
descent
;
if
(
p
.
y
<
aContext
-
>
AppUnitsToGfxUnits
(
topEdge
)
|
|
p
.
y
>
aContext
-
>
AppUnitsToGfxUnits
(
bottomEdge
)
)
{
return
-
1
;
}
}
gfxSkipCharsIterator
it
=
mFrame
-
>
EnsureTextRun
(
nsTextFrame
:
:
eInflated
)
;
gfxTextRun
*
textRun
=
mFrame
-
>
GetTextRun
(
nsTextFrame
:
:
eInflated
)
;
nsTextFrame
:
:
PropertyProvider
provider
(
mFrame
it
)
;
Range
range
=
ConvertOriginalToSkipped
(
it
mTextFrameContentOffset
mTextFrameContentLength
)
;
gfxFloat
runAdvance
=
aContext
-
>
AppUnitsToGfxUnits
(
textRun
-
>
GetAdvanceWidth
(
range
&
provider
)
)
;
gfxFloat
pos
=
writingMode
.
IsVertical
(
)
?
p
.
y
:
p
.
x
;
if
(
pos
<
0
|
|
pos
>
=
runAdvance
)
{
return
-
1
;
}
bool
rtl
=
textRun
-
>
IsRightToLeft
(
)
;
for
(
int32_t
i
=
mTextFrameContentLength
-
1
;
i
>
=
0
;
i
-
-
)
{
range
=
ConvertOriginalToSkipped
(
it
mTextFrameContentOffset
i
)
;
gfxFloat
advance
=
aContext
-
>
AppUnitsToGfxUnits
(
textRun
-
>
GetAdvanceWidth
(
range
&
provider
)
)
;
if
(
(
rtl
&
&
pos
<
runAdvance
-
advance
)
|
|
(
!
rtl
&
&
pos
>
=
advance
)
)
{
return
i
;
}
}
return
-
1
;
}
enum
SubtreePosition
{
eBeforeSubtree
eWithinSubtree
eAfterSubtree
}
;
class
TextNodeIterator
{
public
:
explicit
TextNodeIterator
(
nsIContent
*
aRoot
nsIContent
*
aSubtree
=
nullptr
)
:
mRoot
(
aRoot
)
mSubtree
(
aSubtree
=
=
aRoot
?
nullptr
:
aSubtree
)
mCurrent
(
aRoot
)
mSubtreePosition
(
mSubtree
?
eBeforeSubtree
:
eWithinSubtree
)
{
NS_ASSERTION
(
aRoot
"
expected
non
-
null
root
"
)
;
if
(
!
aRoot
-
>
IsText
(
)
)
{
Next
(
)
;
}
}
Text
*
Current
(
)
const
{
return
mCurrent
?
mCurrent
-
>
AsText
(
)
:
nullptr
;
}
Text
*
Next
(
)
;
bool
IsWithinSubtree
(
)
const
{
return
mSubtreePosition
=
=
eWithinSubtree
;
}
bool
IsAfterSubtree
(
)
const
{
return
mSubtreePosition
=
=
eAfterSubtree
;
}
private
:
nsIContent
*
const
mRoot
;
nsIContent
*
const
mSubtree
;
nsIContent
*
mCurrent
;
SubtreePosition
mSubtreePosition
;
}
;
Text
*
TextNodeIterator
:
:
Next
(
)
{
if
(
mCurrent
)
{
do
{
nsIContent
*
next
=
IsTextContentElement
(
mCurrent
)
?
mCurrent
-
>
GetFirstChild
(
)
:
nullptr
;
if
(
next
)
{
mCurrent
=
next
;
if
(
mCurrent
=
=
mSubtree
)
{
mSubtreePosition
=
eWithinSubtree
;
}
}
else
{
for
(
;
;
)
{
if
(
mCurrent
=
=
mRoot
)
{
mCurrent
=
nullptr
;
break
;
}
if
(
mCurrent
=
=
mSubtree
)
{
mSubtreePosition
=
eAfterSubtree
;
}
next
=
mCurrent
-
>
GetNextSibling
(
)
;
if
(
next
)
{
mCurrent
=
next
;
if
(
mCurrent
=
=
mSubtree
)
{
mSubtreePosition
=
eWithinSubtree
;
}
break
;
}
if
(
mCurrent
=
=
mSubtree
)
{
mSubtreePosition
=
eAfterSubtree
;
}
mCurrent
=
mCurrent
-
>
GetParent
(
)
;
}
}
}
while
(
mCurrent
&
&
!
mCurrent
-
>
IsText
(
)
)
;
}
return
mCurrent
?
mCurrent
-
>
AsText
(
)
:
nullptr
;
}
struct
TextNodeCorrespondence
{
explicit
TextNodeCorrespondence
(
uint32_t
aUndisplayedCharacters
)
:
mUndisplayedCharacters
(
aUndisplayedCharacters
)
{
}
uint32_t
mUndisplayedCharacters
;
}
;
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
TextNodeCorrespondenceProperty
TextNodeCorrespondence
)
static
uint32_t
GetUndisplayedCharactersBeforeFrame
(
nsTextFrame
*
aFrame
)
{
void
*
value
=
aFrame
-
>
GetProperty
(
TextNodeCorrespondenceProperty
(
)
)
;
TextNodeCorrespondence
*
correspondence
=
static_cast
<
TextNodeCorrespondence
*
>
(
value
)
;
if
(
!
correspondence
)
{
NS_ERROR
(
"
expected
a
TextNodeCorrespondenceProperty
on
nsTextFrame
"
"
used
for
SVG
text
"
)
;
return
0
;
}
return
correspondence
-
>
mUndisplayedCharacters
;
}
class
TextNodeCorrespondenceRecorder
{
public
:
static
void
RecordCorrespondence
(
SVGTextFrame
*
aRoot
)
;
private
:
explicit
TextNodeCorrespondenceRecorder
(
SVGTextFrame
*
aRoot
)
:
mNodeIterator
(
aRoot
-
>
GetContent
(
)
)
mPreviousNode
(
nullptr
)
mNodeCharIndex
(
0
)
{
}
void
Record
(
SVGTextFrame
*
aRoot
)
;
void
TraverseAndRecord
(
nsIFrame
*
aFrame
)
;
Text
*
NextNode
(
)
;
TextNodeIterator
mNodeIterator
;
Text
*
mPreviousNode
;
uint32_t
mNodeCharIndex
;
}
;
void
TextNodeCorrespondenceRecorder
:
:
RecordCorrespondence
(
SVGTextFrame
*
aRoot
)
{
if
(
aRoot
-
>
HasAnyStateBits
(
NS_STATE_SVG_TEXT_CORRESPONDENCE_DIRTY
)
)
{
aRoot
-
>
MaybeResolveBidiForAnonymousBlockChild
(
)
;
TextNodeCorrespondenceRecorder
recorder
(
aRoot
)
;
recorder
.
Record
(
aRoot
)
;
aRoot
-
>
RemoveStateBits
(
NS_STATE_SVG_TEXT_CORRESPONDENCE_DIRTY
)
;
}
}
void
TextNodeCorrespondenceRecorder
:
:
Record
(
SVGTextFrame
*
aRoot
)
{
if
(
!
mNodeIterator
.
Current
(
)
)
{
return
;
}
TraverseAndRecord
(
aRoot
)
;
uint32_t
undisplayed
=
0
;
if
(
mNodeIterator
.
Current
(
)
)
{
if
(
mPreviousNode
&
&
mPreviousNode
-
>
TextLength
(
)
!
=
mNodeCharIndex
)
{
NS_ASSERTION
(
mNodeCharIndex
<
mPreviousNode
-
>
TextLength
(
)
"
incorrect
tracking
of
undisplayed
characters
in
"
"
text
nodes
"
)
;
undisplayed
+
=
mPreviousNode
-
>
TextLength
(
)
-
mNodeCharIndex
;
}
for
(
Text
*
textNode
=
mNodeIterator
.
Current
(
)
;
textNode
;
textNode
=
NextNode
(
)
)
{
undisplayed
+
=
textNode
-
>
TextLength
(
)
;
}
}
aRoot
-
>
mTrailingUndisplayedCharacters
=
undisplayed
;
}
Text
*
TextNodeCorrespondenceRecorder
:
:
NextNode
(
)
{
mPreviousNode
=
mNodeIterator
.
Current
(
)
;
Text
*
next
;
do
{
next
=
mNodeIterator
.
Next
(
)
;
}
while
(
next
&
&
next
-
>
TextLength
(
)
=
=
0
)
;
return
next
;
}
void
TextNodeCorrespondenceRecorder
:
:
TraverseAndRecord
(
nsIFrame
*
aFrame
)
{
if
(
IsTextContentElement
(
aFrame
-
>
GetContent
(
)
)
)
{
for
(
nsIFrame
*
f
:
aFrame
-
>
PrincipalChildList
(
)
)
{
TraverseAndRecord
(
f
)
;
}
return
;
}
nsTextFrame
*
frame
;
Text
*
node
;
if
(
!
GetNonEmptyTextFrameAndNode
(
aFrame
frame
node
)
)
{
return
;
}
NS_ASSERTION
(
frame
-
>
GetContentOffset
(
)
>
=
0
"
don
'
t
know
how
to
handle
negative
content
indexes
"
)
;
uint32_t
undisplayed
=
0
;
if
(
!
mPreviousNode
)
{
NS_ASSERTION
(
mNodeCharIndex
=
=
0
"
incorrect
tracking
of
undisplayed
"
"
characters
in
text
nodes
"
)
;
if
(
!
mNodeIterator
.
Current
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
incorrect
tracking
of
correspondence
between
"
"
text
frames
and
text
nodes
"
)
;
}
else
{
while
(
mNodeIterator
.
Current
(
)
!
=
node
)
{
undisplayed
+
=
mNodeIterator
.
Current
(
)
-
>
TextLength
(
)
;
NextNode
(
)
;
}
undisplayed
+
=
frame
-
>
GetContentOffset
(
)
;
NextNode
(
)
;
}
}
else
if
(
mPreviousNode
=
=
node
)
{
if
(
static_cast
<
uint32_t
>
(
frame
-
>
GetContentOffset
(
)
)
!
=
mNodeCharIndex
)
{
NS_ASSERTION
(
mNodeCharIndex
<
static_cast
<
uint32_t
>
(
frame
-
>
GetContentOffset
(
)
)
"
incorrect
tracking
of
undisplayed
characters
in
"
"
text
nodes
"
)
;
undisplayed
=
frame
-
>
GetContentOffset
(
)
-
mNodeCharIndex
;
}
}
else
{
if
(
mPreviousNode
-
>
TextLength
(
)
!
=
mNodeCharIndex
)
{
NS_ASSERTION
(
mNodeCharIndex
<
mPreviousNode
-
>
TextLength
(
)
"
incorrect
tracking
of
undisplayed
characters
in
"
"
text
nodes
"
)
;
undisplayed
=
mPreviousNode
-
>
TextLength
(
)
-
mNodeCharIndex
;
}
while
(
mNodeIterator
.
Current
(
)
&
&
mNodeIterator
.
Current
(
)
!
=
node
)
{
undisplayed
+
=
mNodeIterator
.
Current
(
)
-
>
TextLength
(
)
;
NextNode
(
)
;
}
undisplayed
+
=
frame
-
>
GetContentOffset
(
)
;
NextNode
(
)
;
}
frame
-
>
SetProperty
(
TextNodeCorrespondenceProperty
(
)
new
TextNodeCorrespondence
(
undisplayed
)
)
;
mNodeCharIndex
=
frame
-
>
GetContentEnd
(
)
;
}
class
MOZ_STACK_CLASS
TextFrameIterator
{
public
:
explicit
TextFrameIterator
(
SVGTextFrame
*
aRoot
const
nsIFrame
*
aSubtree
=
nullptr
)
:
mRootFrame
(
aRoot
)
mSubtree
(
aSubtree
)
mCurrentFrame
(
aRoot
)
mSubtreePosition
(
mSubtree
?
eBeforeSubtree
:
eWithinSubtree
)
{
Init
(
)
;
}
TextFrameIterator
(
SVGTextFrame
*
aRoot
nsIContent
*
aSubtree
)
:
mRootFrame
(
aRoot
)
mSubtree
(
aRoot
&
&
aSubtree
&
&
aSubtree
!
=
aRoot
-
>
GetContent
(
)
?
aSubtree
-
>
GetPrimaryFrame
(
)
:
nullptr
)
mCurrentFrame
(
aRoot
)
mSubtreePosition
(
mSubtree
?
eBeforeSubtree
:
eWithinSubtree
)
{
Init
(
)
;
}
SVGTextFrame
*
Root
(
)
const
{
return
mRootFrame
;
}
nsTextFrame
*
Current
(
)
const
{
return
do_QueryFrame
(
mCurrentFrame
)
;
}
uint32_t
UndisplayedCharacters
(
)
const
;
nsPoint
Position
(
)
const
{
return
mCurrentPosition
;
}
nsTextFrame
*
Next
(
)
;
bool
IsWithinSubtree
(
)
const
{
return
mSubtreePosition
=
=
eWithinSubtree
;
}
bool
IsAfterSubtree
(
)
const
{
return
mSubtreePosition
=
=
eAfterSubtree
;
}
nsIFrame
*
TextPathFrame
(
)
const
{
return
mTextPathFrames
.
IsEmpty
(
)
?
nullptr
:
mTextPathFrames
.
LastElement
(
)
;
}
StyleDominantBaseline
DominantBaseline
(
)
const
{
return
mBaselines
.
LastElement
(
)
;
}
void
Close
(
)
{
mCurrentFrame
=
nullptr
;
}
private
:
void
Init
(
)
{
if
(
!
mRootFrame
)
{
return
;
}
mBaselines
.
AppendElement
(
mRootFrame
-
>
StyleSVG
(
)
-
>
mDominantBaseline
)
;
Next
(
)
;
}
void
PushBaseline
(
nsIFrame
*
aNextFrame
)
;
void
PopBaseline
(
)
;
SVGTextFrame
*
const
mRootFrame
;
const
nsIFrame
*
const
mSubtree
;
nsIFrame
*
mCurrentFrame
;
nsPoint
mCurrentPosition
;
AutoTArray
<
nsIFrame
*
1
>
mTextPathFrames
;
AutoTArray
<
StyleDominantBaseline
8
>
mBaselines
;
SubtreePosition
mSubtreePosition
;
}
;
uint32_t
TextFrameIterator
:
:
UndisplayedCharacters
(
)
const
{
MOZ_ASSERT
(
!
mRootFrame
-
>
HasAnyStateBits
(
NS_STATE_SVG_TEXT_CORRESPONDENCE_DIRTY
)
"
Text
correspondence
must
be
up
to
date
"
)
;
if
(
!
mCurrentFrame
)
{
return
mRootFrame
-
>
mTrailingUndisplayedCharacters
;
}
nsTextFrame
*
frame
=
do_QueryFrame
(
mCurrentFrame
)
;
return
GetUndisplayedCharactersBeforeFrame
(
frame
)
;
}
nsTextFrame
*
TextFrameIterator
:
:
Next
(
)
{
if
(
mCurrentFrame
)
{
do
{
nsIFrame
*
next
=
IsTextContentElement
(
mCurrentFrame
-
>
GetContent
(
)
)
?
mCurrentFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
:
nullptr
;
if
(
next
)
{
mCurrentPosition
+
=
next
-
>
GetPosition
(
)
;
if
(
next
-
>
GetContent
(
)
-
>
IsSVGElement
(
nsGkAtoms
:
:
textPath
)
)
{
mTextPathFrames
.
AppendElement
(
next
)
;
}
PushBaseline
(
next
)
;
mCurrentFrame
=
next
;
if
(
mCurrentFrame
=
=
mSubtree
)
{
mSubtreePosition
=
eWithinSubtree
;
}
}
else
{
for
(
;
;
)
{
if
(
mCurrentFrame
=
=
mRootFrame
)
{
mCurrentFrame
=
nullptr
;
break
;
}
mCurrentPosition
-
=
mCurrentFrame
-
>
GetPosition
(
)
;
if
(
mCurrentFrame
-
>
GetContent
(
)
-
>
IsSVGElement
(
nsGkAtoms
:
:
textPath
)
)
{
mTextPathFrames
.
RemoveLastElement
(
)
;
}
PopBaseline
(
)
;
if
(
mCurrentFrame
=
=
mSubtree
)
{
mSubtreePosition
=
eAfterSubtree
;
}
next
=
mCurrentFrame
-
>
GetNextSibling
(
)
;
if
(
next
)
{
mCurrentPosition
+
=
next
-
>
GetPosition
(
)
;
if
(
next
-
>
GetContent
(
)
-
>
IsSVGElement
(
nsGkAtoms
:
:
textPath
)
)
{
mTextPathFrames
.
AppendElement
(
next
)
;
}
PushBaseline
(
next
)
;
mCurrentFrame
=
next
;
if
(
mCurrentFrame
=
=
mSubtree
)
{
mSubtreePosition
=
eWithinSubtree
;
}
break
;
}
if
(
mCurrentFrame
=
=
mSubtree
)
{
mSubtreePosition
=
eAfterSubtree
;
}
mCurrentFrame
=
mCurrentFrame
-
>
GetParent
(
)
;
}
}
}
while
(
mCurrentFrame
&
&
!
IsNonEmptyTextFrame
(
mCurrentFrame
)
)
;
}
return
Current
(
)
;
}
void
TextFrameIterator
:
:
PushBaseline
(
nsIFrame
*
aNextFrame
)
{
StyleDominantBaseline
baseline
=
aNextFrame
-
>
StyleSVG
(
)
-
>
mDominantBaseline
;
mBaselines
.
AppendElement
(
baseline
)
;
}
void
TextFrameIterator
:
:
PopBaseline
(
)
{
NS_ASSERTION
(
!
mBaselines
.
IsEmpty
(
)
"
popped
too
many
baselines
"
)
;
mBaselines
.
RemoveLastElement
(
)
;
}
class
TextRenderedRunIterator
{
public
:
enum
RenderedRunFilter
{
eAllFrames
eVisibleFrames
}
;
explicit
TextRenderedRunIterator
(
SVGTextFrame
*
aSVGTextFrame
RenderedRunFilter
aFilter
=
eAllFrames
const
nsIFrame
*
aSubtree
=
nullptr
)
:
mFrameIterator
(
FrameIfAnonymousChildReflowed
(
aSVGTextFrame
)
aSubtree
)
mFilter
(
aFilter
)
mTextElementCharIndex
(
0
)
mFrameStartTextElementCharIndex
(
0
)
mFontSizeScaleFactor
(
aSVGTextFrame
-
>
mFontSizeScaleFactor
)
mCurrent
(
First
(
)
)
{
}
TextRenderedRunIterator
(
SVGTextFrame
*
aSVGTextFrame
RenderedRunFilter
aFilter
nsIContent
*
aSubtree
)
:
mFrameIterator
(
FrameIfAnonymousChildReflowed
(
aSVGTextFrame
)
aSubtree
)
mFilter
(
aFilter
)
mTextElementCharIndex
(
0
)
mFrameStartTextElementCharIndex
(
0
)
mFontSizeScaleFactor
(
aSVGTextFrame
-
>
mFontSizeScaleFactor
)
mCurrent
(
First
(
)
)
{
}
TextRenderedRun
Current
(
)
const
{
return
mCurrent
;
}
TextRenderedRun
Next
(
)
;
private
:
SVGTextFrame
*
Root
(
)
const
{
return
mFrameIterator
.
Root
(
)
;
}
TextRenderedRun
First
(
)
;
TextFrameIterator
mFrameIterator
;
RenderedRunFilter
mFilter
;
uint32_t
mTextElementCharIndex
;
uint32_t
mFrameStartTextElementCharIndex
;
double
mFontSizeScaleFactor
;
TextRenderedRun
mCurrent
;
}
;
TextRenderedRun
TextRenderedRunIterator
:
:
Next
(
)
{
if
(
!
mFrameIterator
.
Current
(
)
)
{
mCurrent
=
TextRenderedRun
(
)
;
return
mCurrent
;
}
nsTextFrame
*
frame
;
gfxPoint
pt
;
double
rotate
;
nscoord
baseline
;
uint32_t
offset
length
;
uint32_t
charIndex
;
for
(
;
;
)
{
if
(
mFrameIterator
.
IsAfterSubtree
(
)
)
{
mCurrent
=
TextRenderedRun
(
)
;
return
mCurrent
;
}
frame
=
mFrameIterator
.
Current
(
)
;
charIndex
=
mTextElementCharIndex
;
uint32_t
runStart
runEnd
;
runStart
=
mTextElementCharIndex
;
runEnd
=
runStart
+
1
;
while
(
runEnd
<
Root
(
)
-
>
mPositions
.
Length
(
)
&
&
!
Root
(
)
-
>
mPositions
[
runEnd
]
.
mRunBoundary
)
{
runEnd
+
+
;
}
offset
=
frame
-
>
GetContentOffset
(
)
+
runStart
-
mFrameStartTextElementCharIndex
;
length
=
runEnd
-
runStart
;
uint32_t
contentEnd
=
frame
-
>
GetContentEnd
(
)
;
if
(
offset
+
length
>
contentEnd
)
{
length
=
contentEnd
-
offset
;
}
NS_ASSERTION
(
offset
>
=
uint32_t
(
frame
-
>
GetContentOffset
(
)
)
"
invalid
offset
"
)
;
NS_ASSERTION
(
offset
+
length
<
=
contentEnd
"
invalid
offset
or
length
"
)
;
frame
-
>
EnsureTextRun
(
nsTextFrame
:
:
eInflated
)
;
baseline
=
GetBaselinePosition
(
frame
frame
-
>
GetTextRun
(
nsTextFrame
:
:
eInflated
)
mFrameIterator
.
DominantBaseline
(
)
mFontSizeScaleFactor
)
;
uint32_t
untrimmedOffset
=
offset
;
uint32_t
untrimmedLength
=
length
;
nsTextFrame
:
:
TrimmedOffsets
trimmedOffsets
=
frame
-
>
GetTrimmedOffsets
(
frame
-
>
TextFragment
(
)
)
;
TrimOffsets
(
offset
length
trimmedOffsets
)
;
charIndex
+
=
offset
-
untrimmedOffset
;
pt
=
Root
(
)
-
>
mPositions
[
charIndex
]
.
mPosition
;
rotate
=
Root
(
)
-
>
mPositions
[
charIndex
]
.
mAngle
;
bool
skip
=
!
mFrameIterator
.
IsWithinSubtree
(
)
|
|
Root
(
)
-
>
mPositions
[
mTextElementCharIndex
]
.
mHidden
;
if
(
mFilter
=
=
eVisibleFrames
)
{
skip
=
skip
|
|
!
frame
-
>
StyleVisibility
(
)
-
>
IsVisible
(
)
;
}
mTextElementCharIndex
+
=
untrimmedLength
;
if
(
offset
+
untrimmedLength
>
=
contentEnd
)
{
mFrameIterator
.
Next
(
)
;
mTextElementCharIndex
+
=
mFrameIterator
.
UndisplayedCharacters
(
)
;
mFrameStartTextElementCharIndex
=
mTextElementCharIndex
;
}
if
(
!
mFrameIterator
.
Current
(
)
)
{
if
(
skip
)
{
mCurrent
=
TextRenderedRun
(
)
;
return
mCurrent
;
}
break
;
}
if
(
length
&
&
!
skip
)
{
break
;
}
}
mCurrent
=
TextRenderedRun
(
frame
pt
Root
(
)
-
>
mLengthAdjustScaleFactor
rotate
mFontSizeScaleFactor
baseline
offset
length
charIndex
)
;
return
mCurrent
;
}
TextRenderedRun
TextRenderedRunIterator
:
:
First
(
)
{
if
(
!
mFrameIterator
.
Current
(
)
)
{
return
TextRenderedRun
(
)
;
}
if
(
Root
(
)
-
>
mPositions
.
IsEmpty
(
)
)
{
mFrameIterator
.
Close
(
)
;
return
TextRenderedRun
(
)
;
}
mTextElementCharIndex
=
mFrameIterator
.
UndisplayedCharacters
(
)
;
mFrameStartTextElementCharIndex
=
mTextElementCharIndex
;
return
Next
(
)
;
}
class
MOZ_STACK_CLASS
CharIterator
{
using
Range
=
gfxTextRun
:
:
Range
;
public
:
enum
CharacterFilter
{
eOriginal
eUnskipped
eAddressable
}
;
CharIterator
(
SVGTextFrame
*
aSVGTextFrame
CharacterFilter
aFilter
nsIContent
*
aSubtree
bool
aPostReflow
=
true
)
;
bool
AtEnd
(
)
const
{
return
!
mFrameIterator
.
Current
(
)
;
}
bool
Next
(
)
;
bool
Next
(
uint32_t
aCount
)
;
void
NextWithinSubtree
(
uint32_t
aCount
)
;
bool
AdvanceToCharacter
(
uint32_t
aTextElementCharIndex
)
;
bool
AdvancePastCurrentFrame
(
)
;
bool
AdvancePastCurrentTextPathFrame
(
)
;
bool
AdvanceToSubtree
(
)
;
nsTextFrame
*
TextFrame
(
)
const
{
return
mFrameIterator
.
Current
(
)
;
}
bool
IsWithinSubtree
(
)
const
{
return
mFrameIterator
.
IsWithinSubtree
(
)
;
}
bool
IsAfterSubtree
(
)
const
{
return
mFrameIterator
.
IsAfterSubtree
(
)
;
}
bool
IsOriginalCharSkipped
(
)
const
{
return
mSkipCharsIterator
.
IsOriginalCharSkipped
(
)
;
}
bool
IsClusterAndLigatureGroupStart
(
)
const
{
return
mTextRun
-
>
IsLigatureGroupStart
(
mSkipCharsIterator
.
GetSkippedOffset
(
)
)
&
&
mTextRun
-
>
IsClusterStart
(
mSkipCharsIterator
.
GetSkippedOffset
(
)
)
;
}
const
gfxTextRun
:
:
GlyphRun
&
GlyphRun
(
)
const
{
return
*
mTextRun
-
>
FindFirstGlyphRunContaining
(
mSkipCharsIterator
.
GetSkippedOffset
(
)
)
;
}
bool
IsOriginalCharTrimmed
(
)
const
;
bool
IsOriginalCharUnaddressable
(
)
const
{
return
IsOriginalCharSkipped
(
)
|
|
IsOriginalCharTrimmed
(
)
;
}
gfxTextRun
*
TextRun
(
)
const
{
return
mTextRun
;
}
uint32_t
TextElementCharIndex
(
)
const
{
return
mTextElementCharIndex
;
}
uint32_t
GlyphStartTextElementCharIndex
(
)
const
{
return
mGlyphStartTextElementCharIndex
;
}
gfxFloat
GetAdvance
(
nsPresContext
*
aContext
)
const
;
nsIFrame
*
TextPathFrame
(
)
const
{
return
mFrameIterator
.
TextPathFrame
(
)
;
}
#
ifdef
DEBUG
nsIContent
*
GetSubtree
(
)
const
{
return
mSubtree
;
}
CharacterFilter
Filter
(
)
const
{
return
mFilter
;
}
#
endif
private
:
bool
NextCharacter
(
)
;
bool
MatchesFilter
(
)
const
;
void
UpdateGlyphStartTextElementCharIndex
(
)
{
if
(
!
IsOriginalCharSkipped
(
)
&
&
IsClusterAndLigatureGroupStart
(
)
)
{
mGlyphStartTextElementCharIndex
=
mTextElementCharIndex
;
}
}
CharacterFilter
mFilter
;
TextFrameIterator
mFrameIterator
;
#
ifdef
DEBUG
nsIContent
*
const
mSubtree
;
#
endif
gfxSkipCharsIterator
mSkipCharsIterator
;
mutable
nsTextFrame
*
mFrameForTrimCheck
;
mutable
uint32_t
mTrimmedOffset
;
mutable
uint32_t
mTrimmedLength
;
gfxTextRun
*
mTextRun
;
uint32_t
mTextElementCharIndex
;
uint32_t
mGlyphStartTextElementCharIndex
;
float
mLengthAdjustScaleFactor
;
bool
mPostReflow
;
}
;
CharIterator
:
:
CharIterator
(
SVGTextFrame
*
aSVGTextFrame
CharIterator
:
:
CharacterFilter
aFilter
nsIContent
*
aSubtree
bool
aPostReflow
)
:
mFilter
(
aFilter
)
mFrameIterator
(
aSVGTextFrame
aSubtree
)
#
ifdef
DEBUG
mSubtree
(
aSubtree
)
#
endif
mFrameForTrimCheck
(
nullptr
)
mTrimmedOffset
(
0
)
mTrimmedLength
(
0
)
mTextRun
(
nullptr
)
mTextElementCharIndex
(
0
)
mGlyphStartTextElementCharIndex
(
0
)
mLengthAdjustScaleFactor
(
aSVGTextFrame
-
>
mLengthAdjustScaleFactor
)
mPostReflow
(
aPostReflow
)
{
if
(
!
AtEnd
(
)
)
{
mSkipCharsIterator
=
TextFrame
(
)
-
>
EnsureTextRun
(
nsTextFrame
:
:
eInflated
)
;
mTextRun
=
TextFrame
(
)
-
>
GetTextRun
(
nsTextFrame
:
:
eInflated
)
;
mTextElementCharIndex
=
mFrameIterator
.
UndisplayedCharacters
(
)
;
UpdateGlyphStartTextElementCharIndex
(
)
;
if
(
!
MatchesFilter
(
)
)
{
Next
(
)
;
}
}
}
bool
CharIterator
:
:
Next
(
)
{
while
(
NextCharacter
(
)
)
{
if
(
MatchesFilter
(
)
)
{
return
true
;
}
}
return
false
;
}
bool
CharIterator
:
:
Next
(
uint32_t
aCount
)
{
if
(
aCount
=
=
0
&
&
AtEnd
(
)
)
{
return
false
;
}
while
(
aCount
)
{
if
(
!
Next
(
)
)
{
return
false
;
}
aCount
-
-
;
}
return
true
;
}
void
CharIterator
:
:
NextWithinSubtree
(
uint32_t
aCount
)
{
while
(
IsWithinSubtree
(
)
&
&
aCount
)
{
-
-
aCount
;
if
(
!
Next
(
)
)
{
return
;
}
}
}
bool
CharIterator
:
:
AdvanceToCharacter
(
uint32_t
aTextElementCharIndex
)
{
while
(
mTextElementCharIndex
<
aTextElementCharIndex
)
{
if
(
!
Next
(
)
)
{
return
false
;
}
}
return
true
;
}
bool
CharIterator
:
:
AdvancePastCurrentFrame
(
)
{
nsTextFrame
*
currentFrame
=
TextFrame
(
)
;
do
{
if
(
!
Next
(
)
)
{
return
false
;
}
}
while
(
TextFrame
(
)
=
=
currentFrame
)
;
return
true
;
}
bool
CharIterator
:
:
AdvancePastCurrentTextPathFrame
(
)
{
nsIFrame
*
currentTextPathFrame
=
TextPathFrame
(
)
;
NS_ASSERTION
(
currentTextPathFrame
"
expected
AdvancePastCurrentTextPathFrame
to
be
called
only
"
"
within
a
text
path
frame
"
)
;
do
{
if
(
!
AdvancePastCurrentFrame
(
)
)
{
return
false
;
}
}
while
(
TextPathFrame
(
)
=
=
currentTextPathFrame
)
;
return
true
;
}
bool
CharIterator
:
:
AdvanceToSubtree
(
)
{
while
(
!
IsWithinSubtree
(
)
)
{
if
(
IsAfterSubtree
(
)
)
{
return
false
;
}
if
(
!
AdvancePastCurrentFrame
(
)
)
{
return
false
;
}
}
return
true
;
}
bool
CharIterator
:
:
IsOriginalCharTrimmed
(
)
const
{
if
(
mFrameForTrimCheck
!
=
TextFrame
(
)
)
{
mFrameForTrimCheck
=
TextFrame
(
)
;
uint32_t
offset
=
mFrameForTrimCheck
-
>
GetContentOffset
(
)
;
uint32_t
length
=
mFrameForTrimCheck
-
>
GetContentLength
(
)
;
nsTextFrame
:
:
TrimmedOffsets
trim
=
mFrameForTrimCheck
-
>
GetTrimmedOffsets
(
mFrameForTrimCheck
-
>
TextFragment
(
)
(
mPostReflow
?
nsTextFrame
:
:
TrimmedOffsetFlags
:
:
Default
:
nsTextFrame
:
:
TrimmedOffsetFlags
:
:
NotPostReflow
)
)
;
TrimOffsets
(
offset
length
trim
)
;
mTrimmedOffset
=
offset
;
mTrimmedLength
=
length
;
}
uint32_t
index
=
mSkipCharsIterator
.
GetOriginalOffset
(
)
;
return
!
(
(
index
>
=
mTrimmedOffset
&
&
index
<
mTrimmedOffset
+
mTrimmedLength
)
|
|
(
index
>
=
mTrimmedOffset
+
mTrimmedLength
&
&
mFrameForTrimCheck
-
>
StyleText
(
)
-
>
NewlineIsSignificant
(
mFrameForTrimCheck
)
&
&
mFrameForTrimCheck
-
>
TextFragment
(
)
-
>
CharAt
(
index
)
=
=
'
\
n
'
)
)
;
}
gfxFloat
CharIterator
:
:
GetAdvance
(
nsPresContext
*
aContext
)
const
{
float
cssPxPerDevPx
=
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
aContext
-
>
AppUnitsPerDevPixel
(
)
)
;
gfxSkipCharsIterator
start
=
TextFrame
(
)
-
>
EnsureTextRun
(
nsTextFrame
:
:
eInflated
)
;
nsTextFrame
:
:
PropertyProvider
provider
(
TextFrame
(
)
start
)
;
uint32_t
offset
=
mSkipCharsIterator
.
GetSkippedOffset
(
)
;
gfxFloat
advance
=
mTextRun
-
>
GetAdvanceWidth
(
Range
(
offset
offset
+
1
)
&
provider
)
;
return
aContext
-
>
AppUnitsToGfxUnits
(
advance
)
*
mLengthAdjustScaleFactor
*
cssPxPerDevPx
;
}
bool
CharIterator
:
:
NextCharacter
(
)
{
if
(
AtEnd
(
)
)
{
return
false
;
}
mTextElementCharIndex
+
+
;
mSkipCharsIterator
.
AdvanceOriginal
(
1
)
;
if
(
mSkipCharsIterator
.
GetOriginalOffset
(
)
<
TextFrame
(
)
-
>
GetContentEnd
(
)
)
{
UpdateGlyphStartTextElementCharIndex
(
)
;
return
true
;
}
mFrameIterator
.
Next
(
)
;
uint32_t
undisplayed
=
mFrameIterator
.
UndisplayedCharacters
(
)
;
mTextElementCharIndex
+
=
undisplayed
;
if
(
!
TextFrame
(
)
)
{
mSkipCharsIterator
=
gfxSkipCharsIterator
(
)
;
return
false
;
}
mSkipCharsIterator
=
TextFrame
(
)
-
>
EnsureTextRun
(
nsTextFrame
:
:
eInflated
)
;
mTextRun
=
TextFrame
(
)
-
>
GetTextRun
(
nsTextFrame
:
:
eInflated
)
;
UpdateGlyphStartTextElementCharIndex
(
)
;
return
true
;
}
bool
CharIterator
:
:
MatchesFilter
(
)
const
{
switch
(
mFilter
)
{
case
eOriginal
:
return
true
;
case
eUnskipped
:
return
!
IsOriginalCharSkipped
(
)
;
case
eAddressable
:
return
!
IsOriginalCharSkipped
(
)
&
&
!
IsOriginalCharUnaddressable
(
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
mFilter
value
"
)
;
return
true
;
}
class
SVGTextDrawPathCallbacks
final
:
public
nsTextFrame
:
:
DrawPathCallbacks
{
using
imgDrawingParams
=
image
:
:
imgDrawingParams
;
public
:
SVGTextDrawPathCallbacks
(
SVGTextFrame
*
aSVGTextFrame
gfxContext
&
aContext
nsTextFrame
*
aFrame
const
gfxMatrix
&
aCanvasTM
imgDrawingParams
&
aImgParams
bool
aShouldPaintSVGGlyphs
)
:
DrawPathCallbacks
(
aShouldPaintSVGGlyphs
)
mSVGTextFrame
(
aSVGTextFrame
)
mContext
(
aContext
)
mFrame
(
aFrame
)
mCanvasTM
(
aCanvasTM
)
mImgParams
(
aImgParams
)
{
}
void
NotifySelectionBackgroundNeedsFill
(
const
Rect
&
aBackgroundRect
nscolor
aColor
DrawTarget
&
aDrawTarget
)
override
;
void
PaintDecorationLine
(
Rect
aPath
bool
aPaintingShadows
nscolor
aColor
)
override
;
void
PaintSelectionDecorationLine
(
Rect
aPath
bool
aPaintingShadows
nscolor
aColor
)
override
;
void
NotifyBeforeText
(
bool
aPaintingShadows
nscolor
aColor
)
override
;
void
NotifyGlyphPathEmitted
(
)
override
;
void
NotifyAfterText
(
)
override
;
private
:
void
SetupContext
(
)
;
bool
IsClipPathChild
(
)
const
{
return
mSVGTextFrame
-
>
HasAnyStateBits
(
NS_STATE_SVG_CLIPPATH_CHILD
)
;
}
void
HandleTextGeometry
(
)
;
void
MakeFillPattern
(
GeneralPattern
*
aOutPattern
)
;
void
FillAndStrokeGeometry
(
)
;
void
FillGeometry
(
)
;
void
StrokeGeometry
(
)
;
void
ApplyOpacity
(
sRGBColor
&
aColor
const
StyleSVGPaint
&
aPaint
const
StyleSVGOpacity
&
aOpacity
)
const
;
SVGTextFrame
*
const
mSVGTextFrame
;
gfxContext
&
mContext
;
nsTextFrame
*
const
mFrame
;
const
gfxMatrix
&
mCanvasTM
;
imgDrawingParams
&
mImgParams
;
nscolor
mColor
=
NS_RGBA
(
0
0
0
0
)
;
bool
mPaintingShadows
=
false
;
}
;
void
SVGTextDrawPathCallbacks
:
:
NotifySelectionBackgroundNeedsFill
(
const
Rect
&
aBackgroundRect
nscolor
aColor
DrawTarget
&
aDrawTarget
)
{
if
(
IsClipPathChild
(
)
)
{
return
;
}
mColor
=
aColor
;
mPaintingShadows
=
false
;
GeneralPattern
fillPattern
;
MakeFillPattern
(
&
fillPattern
)
;
if
(
fillPattern
.
GetPattern
(
)
)
{
DrawOptions
drawOptions
(
aColor
=
=
NS_40PERCENT_FOREGROUND_COLOR
?
0
.
4
:
1
.
0
)
;
aDrawTarget
.
FillRect
(
aBackgroundRect
fillPattern
drawOptions
)
;
}
}
void
SVGTextDrawPathCallbacks
:
:
NotifyBeforeText
(
bool
aPaintingShadows
nscolor
aColor
)
{
mColor
=
aColor
;
mPaintingShadows
=
aPaintingShadows
;
SetupContext
(
)
;
mContext
.
NewPath
(
)
;
}
void
SVGTextDrawPathCallbacks
:
:
NotifyGlyphPathEmitted
(
)
{
HandleTextGeometry
(
)
;
mContext
.
NewPath
(
)
;
}
void
SVGTextDrawPathCallbacks
:
:
NotifyAfterText
(
)
{
mContext
.
Restore
(
)
;
}
void
SVGTextDrawPathCallbacks
:
:
PaintDecorationLine
(
Rect
aPath
bool
aPaintingShadows
nscolor
aColor
)
{
mColor
=
aColor
;
mPaintingShadows
=
aPaintingShadows
;
AntialiasMode
aaMode
=
SVGUtils
:
:
ToAntialiasMode
(
mFrame
-
>
StyleText
(
)
-
>
mTextRendering
)
;
mContext
.
Save
(
)
;
mContext
.
NewPath
(
)
;
mContext
.
SetAntialiasMode
(
aaMode
)
;
mContext
.
Rectangle
(
ThebesRect
(
aPath
)
)
;
HandleTextGeometry
(
)
;
mContext
.
NewPath
(
)
;
mContext
.
Restore
(
)
;
}
void
SVGTextDrawPathCallbacks
:
:
PaintSelectionDecorationLine
(
Rect
aPath
bool
aPaintingShadows
nscolor
aColor
)
{
if
(
IsClipPathChild
(
)
)
{
return
;
}
mColor
=
aColor
;
mPaintingShadows
=
aPaintingShadows
;
mContext
.
Save
(
)
;
mContext
.
NewPath
(
)
;
mContext
.
Rectangle
(
ThebesRect
(
aPath
)
)
;
FillAndStrokeGeometry
(
)
;
mContext
.
Restore
(
)
;
}
void
SVGTextDrawPathCallbacks
:
:
SetupContext
(
)
{
mContext
.
Save
(
)
;
mContext
.
SetAntialiasMode
(
SVGUtils
:
:
ToAntialiasMode
(
mFrame
-
>
StyleText
(
)
-
>
mTextRendering
)
)
;
}
void
SVGTextDrawPathCallbacks
:
:
HandleTextGeometry
(
)
{
if
(
IsClipPathChild
(
)
)
{
RefPtr
<
Path
>
path
=
mContext
.
GetPath
(
)
;
ColorPattern
white
(
DeviceColor
(
1
.
f
1
.
f
1
.
f
1
.
f
)
)
;
mContext
.
GetDrawTarget
(
)
-
>
Fill
(
path
white
)
;
}
else
{
gfxContextMatrixAutoSaveRestore
saveMatrix
(
&
mContext
)
;
mContext
.
SetMatrixDouble
(
mCanvasTM
)
;
FillAndStrokeGeometry
(
)
;
}
}
void
SVGTextDrawPathCallbacks
:
:
ApplyOpacity
(
sRGBColor
&
aColor
const
StyleSVGPaint
&
aPaint
const
StyleSVGOpacity
&
aOpacity
)
const
{
if
(
aPaint
.
kind
.
tag
=
=
StyleSVGPaintKind
:
:
Tag
:
:
Color
)
{
aColor
.
a
*
=
sRGBColor
:
:
FromABGR
(
aPaint
.
kind
.
AsColor
(
)
.
CalcColor
(
*
mFrame
-
>
Style
(
)
)
)
.
a
;
}
aColor
.
a
*
=
SVGUtils
:
:
GetOpacity
(
aOpacity
nullptr
)
;
}
void
SVGTextDrawPathCallbacks
:
:
MakeFillPattern
(
GeneralPattern
*
aOutPattern
)
{
if
(
mColor
=
=
NS_SAME_AS_FOREGROUND_COLOR
|
|
mColor
=
=
NS_40PERCENT_FOREGROUND_COLOR
)
{
SVGUtils
:
:
MakeFillPatternFor
(
mFrame
&
mContext
aOutPattern
mImgParams
)
;
return
;
}
if
(
mColor
=
=
NS_TRANSPARENT
)
{
return
;
}
sRGBColor
color
(
sRGBColor
:
:
FromABGR
(
mColor
)
)
;
if
(
mPaintingShadows
)
{
ApplyOpacity
(
color
mFrame
-
>
StyleSVG
(
)
-
>
mFill
mFrame
-
>
StyleSVG
(
)
-
>
mFillOpacity
)
;
}
aOutPattern
-
>
InitColorPattern
(
ToDeviceColor
(
color
)
)
;
}
void
SVGTextDrawPathCallbacks
:
:
FillAndStrokeGeometry
(
)
{
gfxGroupForBlendAutoSaveRestore
autoGroupForBlend
(
&
mContext
)
;
if
(
mColor
=
=
NS_40PERCENT_FOREGROUND_COLOR
)
{
autoGroupForBlend
.
PushGroupForBlendBack
(
gfxContentType
:
:
COLOR_ALPHA
0
.
4f
)
;
}
uint32_t
paintOrder
=
mFrame
-
>
StyleSVG
(
)
-
>
mPaintOrder
;
if
(
!
paintOrder
)
{
FillGeometry
(
)
;
StrokeGeometry
(
)
;
}
else
{
while
(
paintOrder
)
{
auto
component
=
StylePaintOrder
(
paintOrder
&
kPaintOrderMask
)
;
switch
(
component
)
{
case
StylePaintOrder
:
:
Fill
:
FillGeometry
(
)
;
break
;
case
StylePaintOrder
:
:
Stroke
:
StrokeGeometry
(
)
;
break
;
default
:
MOZ_FALLTHROUGH_ASSERT
(
"
Unknown
paint
-
order
value
"
)
;
case
StylePaintOrder
:
:
Markers
:
case
StylePaintOrder
:
:
Normal
:
break
;
}
paintOrder
>
>
=
kPaintOrderShift
;
}
}
}
void
SVGTextDrawPathCallbacks
:
:
FillGeometry
(
)
{
if
(
mFrame
-
>
StyleSVG
(
)
-
>
mFill
.
kind
.
IsNone
(
)
)
{
return
;
}
GeneralPattern
fillPattern
;
MakeFillPattern
(
&
fillPattern
)
;
if
(
fillPattern
.
GetPattern
(
)
)
{
RefPtr
<
Path
>
path
=
mContext
.
GetPath
(
)
;
FillRule
fillRule
=
SVGUtils
:
:
ToFillRule
(
mFrame
-
>
StyleSVG
(
)
-
>
mFillRule
)
;
if
(
fillRule
!
=
path
-
>
GetFillRule
(
)
)
{
RefPtr
<
PathBuilder
>
builder
=
path
-
>
CopyToBuilder
(
fillRule
)
;
path
=
builder
-
>
Finish
(
)
;
}
mContext
.
GetDrawTarget
(
)
-
>
Fill
(
path
fillPattern
)
;
}
}
void
SVGTextDrawPathCallbacks
:
:
StrokeGeometry
(
)
{
if
(
!
(
mColor
=
=
NS_SAME_AS_FOREGROUND_COLOR
|
|
mColor
=
=
NS_40PERCENT_FOREGROUND_COLOR
|
|
mPaintingShadows
)
)
{
return
;
}
if
(
!
SVGUtils
:
:
HasStroke
(
mFrame
nullptr
)
)
{
return
;
}
GeneralPattern
strokePattern
;
if
(
mPaintingShadows
)
{
sRGBColor
color
(
sRGBColor
:
:
FromABGR
(
mColor
)
)
;
ApplyOpacity
(
color
mFrame
-
>
StyleSVG
(
)
-
>
mStroke
mFrame
-
>
StyleSVG
(
)
-
>
mStrokeOpacity
)
;
strokePattern
.
InitColorPattern
(
ToDeviceColor
(
color
)
)
;
}
else
{
SVGUtils
:
:
MakeStrokePatternFor
(
mFrame
&
mContext
&
strokePattern
mImgParams
nullptr
)
;
}
if
(
strokePattern
.
GetPattern
(
)
)
{
SVGElement
*
svgOwner
=
SVGElement
:
:
FromNode
(
mFrame
-
>
GetParent
(
)
-
>
GetContent
(
)
)
;
gfxMatrix
outerSVGToUser
;
if
(
SVGUtils
:
:
GetNonScalingStrokeTransform
(
mFrame
&
outerSVGToUser
)
&
&
outerSVGToUser
.
Invert
(
)
)
{
mContext
.
Multiply
(
outerSVGToUser
)
;
}
RefPtr
<
Path
>
path
=
mContext
.
GetPath
(
)
;
SVGContentUtils
:
:
AutoStrokeOptions
strokeOptions
;
SVGContentUtils
:
:
GetStrokeOptions
(
&
strokeOptions
svgOwner
mFrame
-
>
Style
(
)
nullptr
)
;
DrawOptions
drawOptions
;
drawOptions
.
mAntialiasMode
=
SVGUtils
:
:
ToAntialiasMode
(
mFrame
-
>
StyleText
(
)
-
>
mTextRendering
)
;
mContext
.
GetDrawTarget
(
)
-
>
Stroke
(
path
strokePattern
strokeOptions
)
;
}
}
class
DisplaySVGText
final
:
public
DisplaySVGItem
{
public
:
DisplaySVGText
(
nsDisplayListBuilder
*
aBuilder
SVGTextFrame
*
aFrame
)
:
DisplaySVGItem
(
aBuilder
aFrame
)
{
MOZ_COUNT_CTOR
(
DisplaySVGText
)
;
}
MOZ_COUNTED_DTOR_OVERRIDE
(
DisplaySVGText
)
NS_DISPLAY_DECL_NAME
(
"
DisplaySVGText
"
TYPE_SVG_TEXT
)
nsDisplayItemGeometry
*
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
new
nsDisplayItemGenericGeometry
(
this
aBuilder
)
;
}
nsRect
GetComponentAlphaBounds
(
nsDisplayListBuilder
*
aBuilder
)
const
override
{
bool
snap
;
return
GetBounds
(
aBuilder
&
snap
)
;
}
}
;
NS_QUERYFRAME_HEAD
(
SVGTextFrame
)
NS_QUERYFRAME_ENTRY
(
SVGTextFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
SVGDisplayContainerFrame
)
}
nsIFrame
*
NS_NewSVGTextFrame
(
mozilla
:
:
PresShell
*
aPresShell
mozilla
:
:
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
mozilla
:
:
SVGTextFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
namespace
mozilla
{
NS_IMPL_FRAMEARENA_HELPERS
(
SVGTextFrame
)
void
SVGTextFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
NS_ASSERTION
(
aContent
-
>
IsSVGElement
(
nsGkAtoms
:
:
text
)
"
Content
is
not
an
SVG
text
"
)
;
SVGDisplayContainerFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
AddStateBits
(
aParent
-
>
GetStateBits
(
)
&
NS_STATE_SVG_CLIPPATH_CHILD
)
;
mMutationObserver
=
new
MutationObserver
(
this
)
;
if
(
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
)
{
ScheduleReflowSVGNonDisplayText
(
IntrinsicDirty
:
:
FrameAncestorsAndDescendants
)
;
}
}
void
SVGTextFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
if
(
IsSubtreeDirty
(
)
)
{
return
;
}
if
(
!
IsVisibleForPainting
(
)
&
&
aBuilder
-
>
IsForPainting
(
)
)
{
return
;
}
DisplayOutline
(
aBuilder
aLists
)
;
aLists
.
Content
(
)
-
>
AppendNewToTop
<
DisplaySVGText
>
(
aBuilder
this
)
;
}
nsresult
SVGTextFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
if
(
aNameSpaceID
!
=
kNameSpaceID_None
)
{
return
NS_OK
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
transform
)
{
if
(
!
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
&
&
mCanvasTM
&
&
mCanvasTM
-
>
IsSingular
(
)
)
{
NotifyGlyphMetricsChange
(
false
)
;
}
mCanvasTM
=
nullptr
;
}
else
if
(
IsGlyphPositioningAttribute
(
aAttribute
)
|
|
aAttribute
=
=
nsGkAtoms
:
:
textLength
|
|
aAttribute
=
=
nsGkAtoms
:
:
lengthAdjust
)
{
NotifyGlyphMetricsChange
(
false
)
;
}
return
NS_OK
;
}
void
SVGTextFrame
:
:
ReflowSVGNonDisplayText
(
)
{
MOZ_ASSERT
(
SVGUtils
:
:
AnyOuterSVGIsCallingReflowSVG
(
this
)
"
only
call
ReflowSVGNonDisplayText
when
an
outer
SVG
frame
is
"
"
under
ReflowSVG
"
)
;
MOZ_ASSERT
(
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
"
only
call
ReflowSVGNonDisplayText
if
the
frame
is
"
"
NS_FRAME_IS_NONDISPLAY
"
)
;
this
-
>
MarkSubtreeDirty
(
)
;
MaybeReflowAnonymousBlockChild
(
)
;
UpdateGlyphPositioning
(
)
;
}
void
SVGTextFrame
:
:
ScheduleReflowSVGNonDisplayText
(
IntrinsicDirty
aReason
)
{
MOZ_ASSERT
(
!
SVGUtils
:
:
OuterSVGIsCallingReflowSVG
(
this
)
"
do
not
call
ScheduleReflowSVGNonDisplayText
when
the
outer
SVG
"
"
frame
is
under
ReflowSVG
"
)
;
MOZ_ASSERT
(
!
HasAnyStateBits
(
NS_STATE_SVG_TEXT_IN_REFLOW
)
"
do
not
call
ScheduleReflowSVGNonDisplayText
while
reflowing
the
"
"
anonymous
block
child
"
)
;
nsIFrame
*
f
=
this
;
while
(
f
)
{
if
(
!
f
-
>
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
)
{
if
(
f
-
>
IsSubtreeDirty
(
)
)
{
return
;
}
if
(
!
f
-
>
HasAnyStateBits
(
NS_FRAME_SVG_LAYOUT
)
)
{
break
;
}
f
-
>
AddStateBits
(
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
}
f
=
f
-
>
GetParent
(
)
;
}
MOZ_ASSERT
(
f
"
should
have
found
an
ancestor
frame
to
reflow
"
)
;
PresShell
(
)
-
>
FrameNeedsReflow
(
f
aReason
NS_FRAME_IS_DIRTY
)
;
}
NS_IMPL_ISUPPORTS
(
SVGTextFrame
:
:
MutationObserver
nsIMutationObserver
)
void
SVGTextFrame
:
:
MutationObserver
:
:
ContentAppended
(
nsIContent
*
aFirstNewContent
)
{
mFrame
-
>
NotifyGlyphMetricsChange
(
true
)
;
}
void
SVGTextFrame
:
:
MutationObserver
:
:
ContentInserted
(
nsIContent
*
aChild
)
{
mFrame
-
>
NotifyGlyphMetricsChange
(
true
)
;
}
void
SVGTextFrame
:
:
MutationObserver
:
:
ContentRemoved
(
nsIContent
*
aChild
nsIContent
*
aPreviousSibling
)
{
mFrame
-
>
NotifyGlyphMetricsChange
(
true
)
;
}
void
SVGTextFrame
:
:
MutationObserver
:
:
CharacterDataChanged
(
nsIContent
*
aContent
const
CharacterDataChangeInfo
&
)
{
mFrame
-
>
NotifyGlyphMetricsChange
(
true
)
;
}
void
SVGTextFrame
:
:
MutationObserver
:
:
AttributeChanged
(
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
const
nsAttrValue
*
aOldValue
)
{
if
(
!
aElement
-
>
IsSVGElement
(
)
)
{
return
;
}
if
(
aElement
=
=
mFrame
-
>
GetContent
(
)
)
{
return
;
}
mFrame
-
>
HandleAttributeChangeInDescendant
(
aElement
aNameSpaceID
aAttribute
)
;
}
void
SVGTextFrame
:
:
HandleAttributeChangeInDescendant
(
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
)
{
if
(
aElement
-
>
IsSVGElement
(
nsGkAtoms
:
:
textPath
)
)
{
if
(
aNameSpaceID
=
=
kNameSpaceID_None
&
&
(
aAttribute
=
=
nsGkAtoms
:
:
startOffset
|
|
aAttribute
=
=
nsGkAtoms
:
:
path
|
|
aAttribute
=
=
nsGkAtoms
:
:
side_
)
)
{
NotifyGlyphMetricsChange
(
false
)
;
}
else
if
(
(
aNameSpaceID
=
=
kNameSpaceID_XLink
|
|
aNameSpaceID
=
=
kNameSpaceID_None
)
&
&
aAttribute
=
=
nsGkAtoms
:
:
href
)
{
nsIFrame
*
childElementFrame
=
aElement
-
>
GetPrimaryFrame
(
)
;
if
(
childElementFrame
)
{
SVGObserverUtils
:
:
RemoveTextPathObserver
(
childElementFrame
)
;
NotifyGlyphMetricsChange
(
false
)
;
}
}
}
else
{
if
(
aNameSpaceID
=
=
kNameSpaceID_None
&
&
IsGlyphPositioningAttribute
(
aAttribute
)
)
{
NotifyGlyphMetricsChange
(
false
)
;
}
}
}
void
SVGTextFrame
:
:
FindCloserFrameForSelection
(
const
nsPoint
&
aPoint
FrameWithDistance
*
aCurrentBestFrame
)
{
if
(
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
)
{
return
;
}
UpdateGlyphPositioning
(
)
;
nsPresContext
*
presContext
=
PresContext
(
)
;
TextRenderedRunIterator
it
(
this
)
;
for
(
TextRenderedRun
run
=
it
.
Current
(
)
;
run
.
mFrame
;
run
=
it
.
Next
(
)
)
{
uint32_t
flags
=
TextRenderedRun
:
:
eIncludeFill
|
TextRenderedRun
:
:
eIncludeStroke
|
TextRenderedRun
:
:
eNoHorizontalOverflow
;
SVGBBox
userRect
=
run
.
GetUserSpaceRect
(
presContext
flags
)
;
float
devPxPerCSSPx
=
presContext
-
>
CSSPixelsToDevPixels
(
1
.
f
)
;
userRect
.
Scale
(
devPxPerCSSPx
)
;
if
(
!
userRect
.
IsEmpty
(
)
)
{
gfxMatrix
m
;
nsRect
rect
=
SVGUtils
:
:
ToCanvasBounds
(
userRect
.
ToThebesRect
(
)
m
presContext
)
;
if
(
nsLayoutUtils
:
:
PointIsCloserToRect
(
aPoint
rect
aCurrentBestFrame
-
>
mXDistance
aCurrentBestFrame
-
>
mYDistance
)
)
{
aCurrentBestFrame
-
>
mFrame
=
run
.
mFrame
;
}
}
}
}
void
SVGTextFrame
:
:
NotifySVGChanged
(
uint32_t
aFlags
)
{
MOZ_ASSERT
(
aFlags
&
(
TRANSFORM_CHANGED
|
COORD_CONTEXT_CHANGED
)
"
Invalidation
logic
may
need
adjusting
"
)
;
bool
needNewBounds
=
false
;
bool
needGlyphMetricsUpdate
=
false
;
bool
needNewCanvasTM
=
false
;
if
(
(
aFlags
&
COORD_CONTEXT_CHANGED
)
&
&
HasAnyStateBits
(
NS_STATE_SVG_POSITIONING_MAY_USE_PERCENTAGES
)
)
{
needGlyphMetricsUpdate
=
true
;
}
if
(
aFlags
&
TRANSFORM_CHANGED
)
{
needNewCanvasTM
=
true
;
if
(
mCanvasTM
&
&
mCanvasTM
-
>
IsSingular
(
)
)
{
needNewBounds
=
true
;
needGlyphMetricsUpdate
=
true
;
}
if
(
StyleSVGReset
(
)
-
>
HasNonScalingStroke
(
)
)
{
needNewBounds
=
true
;
}
}
if
(
needNewCanvasTM
&
&
mLastContextScale
!
=
0
.
0f
)
{
mCanvasTM
=
nullptr
;
gfxMatrix
newTM
=
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
?
gfxMatrix
(
)
:
GetCanvasTM
(
)
;
float
scale
=
GetContextScale
(
newTM
)
;
float
change
=
scale
/
mLastContextScale
;
if
(
change
>
=
2
.
0f
|
|
change
<
=
0
.
5f
)
{
needNewBounds
=
true
;
needGlyphMetricsUpdate
=
true
;
}
}
if
(
needNewBounds
)
{
ScheduleReflowSVG
(
)
;
}
if
(
needGlyphMetricsUpdate
)
{
if
(
!
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
)
{
NotifyGlyphMetricsChange
(
false
)
;
}
}
}
static
int32_t
GetCaretOffset
(
nsCaret
*
aCaret
)
{
RefPtr
<
Selection
>
selection
=
aCaret
-
>
GetSelection
(
)
;
if
(
!
selection
)
{
return
-
1
;
}
return
selection
-
>
AnchorOffset
(
)
;
}
static
bool
ShouldPaintCaret
(
const
TextRenderedRun
&
aThisRun
nsCaret
*
aCaret
)
{
int32_t
caretOffset
=
GetCaretOffset
(
aCaret
)
;
if
(
caretOffset
<
0
)
{
return
false
;
}
return
uint32_t
(
caretOffset
)
>
=
aThisRun
.
mTextFrameContentOffset
&
&
uint32_t
(
caretOffset
)
<
aThisRun
.
mTextFrameContentOffset
+
aThisRun
.
mTextFrameContentLength
;
}
void
SVGTextFrame
:
:
PaintSVG
(
gfxContext
&
aContext
const
gfxMatrix
&
aTransform
imgDrawingParams
&
aImgParams
)
{
DrawTarget
&
aDrawTarget
=
*
aContext
.
GetDrawTarget
(
)
;
nsIFrame
*
kid
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
!
kid
)
{
return
;
}
nsPresContext
*
presContext
=
PresContext
(
)
;
gfxMatrix
initialMatrix
=
aContext
.
CurrentMatrixDouble
(
)
;
if
(
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
)
{
if
(
presContext
-
>
PresShell
(
)
-
>
InDrawWindowNotFlushing
(
)
&
&
IsSubtreeDirty
(
)
)
{
return
;
}
UpdateGlyphPositioning
(
)
;
}
else
if
(
IsSubtreeDirty
(
)
)
{
return
;
}
const
float
epsilon
=
0
.
0001
;
if
(
abs
(
mLengthAdjustScaleFactor
)
<
epsilon
)
{
return
;
}
if
(
aTransform
.
IsSingular
(
)
)
{
NS_WARNING
(
"
Can
'
t
render
text
element
!
"
)
;
return
;
}
gfxMatrix
matrixForPaintServers
=
aTransform
*
initialMatrix
;
auto
auPerDevPx
=
presContext
-
>
AppUnitsPerDevPixel
(
)
;
float
cssPxPerDevPx
=
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
auPerDevPx
)
;
gfxMatrix
canvasTMForChildren
=
aTransform
;
canvasTMForChildren
.
PreScale
(
cssPxPerDevPx
cssPxPerDevPx
)
;
initialMatrix
.
PreScale
(
1
/
cssPxPerDevPx
1
/
cssPxPerDevPx
)
;
gfxContextMatrixAutoSaveRestore
matSR
(
&
aContext
)
;
aContext
.
NewPath
(
)
;
aContext
.
Multiply
(
canvasTMForChildren
)
;
gfxMatrix
currentMatrix
=
aContext
.
CurrentMatrixDouble
(
)
;
RefPtr
<
nsCaret
>
caret
=
presContext
-
>
PresShell
(
)
-
>
GetCaret
(
)
;
nsRect
caretRect
;
nsIFrame
*
caretFrame
=
caret
-
>
GetPaintGeometry
(
&
caretRect
)
;
gfxContextAutoSaveRestore
ctxSR
;
TextRenderedRunIterator
it
(
this
TextRenderedRunIterator
:
:
eVisibleFrames
)
;
TextRenderedRun
run
=
it
.
Current
(
)
;
SVGContextPaint
*
outerContextPaint
=
SVGContextPaint
:
:
GetContextPaint
(
GetContent
(
)
)
;
while
(
run
.
mFrame
)
{
nsTextFrame
*
frame
=
run
.
mFrame
;
auto
contextPaint
=
MakeRefPtr
<
SVGContextPaintImpl
>
(
)
;
DrawMode
drawMode
=
contextPaint
-
>
Init
(
&
aDrawTarget
initialMatrix
frame
outerContextPaint
aImgParams
)
;
if
(
drawMode
&
DrawMode
:
:
GLYPH_STROKE
)
{
ctxSR
.
EnsureSaved
(
&
aContext
)
;
SVGUtils
:
:
SetupStrokeGeometry
(
frame
-
>
GetParent
(
)
&
aContext
outerContextPaint
)
;
}
nscoord
startEdge
endEdge
;
run
.
GetClipEdges
(
startEdge
endEdge
)
;
gfxMatrix
runTransform
=
run
.
GetTransformFromUserSpaceForPainting
(
presContext
startEdge
endEdge
)
*
currentMatrix
;
aContext
.
SetMatrixDouble
(
runTransform
)
;
if
(
drawMode
!
=
DrawMode
(
0
)
)
{
bool
paintSVGGlyphs
;
nsTextFrame
:
:
PaintTextParams
params
(
&
aContext
)
;
params
.
framePt
=
Point
(
)
;
params
.
dirtyRect
=
LayoutDevicePixel
:
:
FromAppUnits
(
frame
-
>
InkOverflowRect
(
)
auPerDevPx
)
;
params
.
contextPaint
=
contextPaint
;
bool
isSelected
;
if
(
HasAnyStateBits
(
NS_STATE_SVG_CLIPPATH_CHILD
)
)
{
params
.
state
=
nsTextFrame
:
:
PaintTextParams
:
:
GenerateTextMask
;
isSelected
=
false
;
}
else
{
isSelected
=
frame
-
>
IsSelected
(
)
;
}
gfxGroupForBlendAutoSaveRestore
autoGroupForBlend
(
&
aContext
)
;
float
opacity
=
1
.
0f
;
nsIFrame
*
ancestor
=
frame
-
>
GetParent
(
)
;
while
(
ancestor
!
=
this
)
{
opacity
*
=
ancestor
-
>
StyleEffects
(
)
-
>
mOpacity
;
ancestor
=
ancestor
-
>
GetParent
(
)
;
}
if
(
opacity
<
1
.
0f
)
{
autoGroupForBlend
.
PushGroupForBlendBack
(
gfxContentType
:
:
COLOR_ALPHA
opacity
)
;
}
if
(
ShouldRenderAsPath
(
frame
paintSVGGlyphs
)
)
{
SVGTextDrawPathCallbacks
callbacks
(
this
aContext
frame
matrixForPaintServers
aImgParams
paintSVGGlyphs
)
;
params
.
callbacks
=
&
callbacks
;
frame
-
>
PaintText
(
params
startEdge
endEdge
nsPoint
(
)
isSelected
)
;
}
else
{
frame
-
>
PaintText
(
params
startEdge
endEdge
nsPoint
(
)
isSelected
)
;
}
}
if
(
frame
=
=
caretFrame
&
&
ShouldPaintCaret
(
run
caret
)
)
{
caret
-
>
PaintCaret
(
aDrawTarget
frame
nsPoint
(
)
)
;
aContext
.
NewPath
(
)
;
}
run
=
it
.
Next
(
)
;
}
}
nsIFrame
*
SVGTextFrame
:
:
GetFrameForPoint
(
const
gfxPoint
&
aPoint
)
{
NS_ASSERTION
(
PrincipalChildList
(
)
.
FirstChild
(
)
"
must
have
a
child
frame
"
)
;
if
(
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
)
{
UpdateGlyphPositioning
(
)
;
}
else
{
NS_ASSERTION
(
!
IsSubtreeDirty
(
)
"
reflow
should
have
happened
"
)
;
}
if
(
!
SVGUtils
:
:
HitTestClip
(
this
aPoint
)
)
{
return
nullptr
;
}
nsPresContext
*
presContext
=
PresContext
(
)
;
TextRenderedRunIterator
it
(
this
)
;
nsIFrame
*
hit
=
nullptr
;
for
(
TextRenderedRun
run
=
it
.
Current
(
)
;
run
.
mFrame
;
run
=
it
.
Next
(
)
)
{
uint16_t
hitTestFlags
=
SVGUtils
:
:
GetGeometryHitTestFlags
(
run
.
mFrame
)
;
if
(
!
hitTestFlags
)
{
continue
;
}
gfxMatrix
m
=
run
.
GetTransformFromRunUserSpaceToUserSpace
(
presContext
)
;
if
(
!
m
.
Invert
(
)
)
{
return
nullptr
;
}
gfxPoint
pointInRunUserSpace
=
m
.
TransformPoint
(
aPoint
)
;
gfxRect
frameRect
=
run
.
GetRunUserSpaceRect
(
presContext
TextRenderedRun
:
:
eIncludeFill
|
TextRenderedRun
:
:
eIncludeStroke
)
.
ToThebesRect
(
)
;
if
(
Inside
(
frameRect
pointInRunUserSpace
)
)
{
hit
=
run
.
mFrame
;
}
}
return
hit
;
}
void
SVGTextFrame
:
:
ReflowSVG
(
)
{
MOZ_ASSERT
(
SVGUtils
:
:
AnyOuterSVGIsCallingReflowSVG
(
this
)
"
This
call
is
probaby
a
wasteful
mistake
"
)
;
MOZ_ASSERT
(
!
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
"
ReflowSVG
mechanism
not
designed
for
this
"
)
;
if
(
!
SVGUtils
:
:
NeedsReflowSVG
(
this
)
)
{
MOZ_ASSERT
(
!
HasAnyStateBits
(
NS_STATE_SVG_TEXT_CORRESPONDENCE_DIRTY
|
NS_STATE_SVG_POSITIONING_DIRTY
)
"
How
did
this
happen
?
"
)
;
return
;
}
MaybeReflowAnonymousBlockChild
(
)
;
UpdateGlyphPositioning
(
)
;
nsPresContext
*
presContext
=
PresContext
(
)
;
SVGBBox
r
;
TextRenderedRunIterator
it
(
this
TextRenderedRunIterator
:
:
eAllFrames
)
;
for
(
TextRenderedRun
run
=
it
.
Current
(
)
;
run
.
mFrame
;
run
=
it
.
Next
(
)
)
{
uint32_t
runFlags
=
0
;
if
(
!
run
.
mFrame
-
>
StyleSVG
(
)
-
>
mFill
.
kind
.
IsNone
(
)
)
{
runFlags
|
=
TextRenderedRun
:
:
eIncludeFill
;
}
if
(
SVGUtils
:
:
HasStroke
(
run
.
mFrame
)
)
{
runFlags
|
=
TextRenderedRun
:
:
eIncludeStroke
;
}
uint16_t
hitTestFlags
=
SVGUtils
:
:
GetGeometryHitTestFlags
(
run
.
mFrame
)
;
if
(
hitTestFlags
&
SVG_HIT_TEST_FILL
)
{
runFlags
|
=
TextRenderedRun
:
:
eIncludeFill
;
}
if
(
hitTestFlags
&
SVG_HIT_TEST_STROKE
)
{
runFlags
|
=
TextRenderedRun
:
:
eIncludeStroke
;
}
if
(
runFlags
)
{
r
.
UnionEdges
(
run
.
GetUserSpaceRect
(
presContext
runFlags
)
)
;
}
}
if
(
r
.
IsEmpty
(
)
)
{
mRect
.
SetEmpty
(
)
;
}
else
{
mRect
=
nsLayoutUtils
:
:
RoundGfxRectToAppRect
(
r
.
ToThebesRect
(
)
AppUnitsPerCSSPixel
(
)
)
;
mRect
.
Inflate
(
ceil
(
presContext
-
>
AppUnitsPerDevPixel
(
)
/
mLastContextScale
)
)
;
}
if
(
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
)
{
SVGObserverUtils
:
:
UpdateEffects
(
this
)
;
}
RemoveStateBits
(
NS_FRAME_FIRST_REFLOW
|
NS_FRAME_IS_DIRTY
|
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
nsRect
overflow
=
nsRect
(
nsPoint
(
0
0
)
mRect
.
Size
(
)
)
;
OverflowAreas
overflowAreas
(
overflow
overflow
)
;
FinishAndStoreOverflow
(
overflowAreas
mRect
.
Size
(
)
)
;
}
static
uint32_t
TextRenderedRunFlagsForBBoxContribution
(
const
TextRenderedRun
&
aRun
uint32_t
aBBoxFlags
)
{
uint32_t
flags
=
0
;
if
(
(
aBBoxFlags
&
SVGUtils
:
:
eBBoxIncludeFillGeometry
)
|
|
(
(
aBBoxFlags
&
SVGUtils
:
:
eBBoxIncludeFill
)
&
&
!
aRun
.
mFrame
-
>
StyleSVG
(
)
-
>
mFill
.
kind
.
IsNone
(
)
)
)
{
flags
|
=
TextRenderedRun
:
:
eIncludeFill
;
}
if
(
(
aBBoxFlags
&
SVGUtils
:
:
eBBoxIncludeStrokeGeometry
)
|
|
(
(
aBBoxFlags
&
SVGUtils
:
:
eBBoxIncludeStroke
)
&
&
SVGUtils
:
:
HasStroke
(
aRun
.
mFrame
)
)
)
{
flags
|
=
TextRenderedRun
:
:
eIncludeStroke
;
}
return
flags
;
}
SVGBBox
SVGTextFrame
:
:
GetBBoxContribution
(
const
Matrix
&
aToBBoxUserspace
uint32_t
aFlags
)
{
NS_ASSERTION
(
PrincipalChildList
(
)
.
FirstChild
(
)
"
must
have
a
child
frame
"
)
;
SVGBBox
bbox
;
if
(
aFlags
&
SVGUtils
:
:
eForGetClientRects
)
{
Rect
rect
=
NSRectToRect
(
mRect
AppUnitsPerCSSPixel
(
)
)
;
if
(
!
rect
.
IsEmpty
(
)
)
{
bbox
=
aToBBoxUserspace
.
TransformBounds
(
rect
)
;
}
return
bbox
;
}
nsIFrame
*
kid
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
kid
&
&
kid
-
>
IsSubtreeDirty
(
)
)
{
return
bbox
;
}
UpdateGlyphPositioning
(
)
;
nsPresContext
*
presContext
=
PresContext
(
)
;
TextRenderedRunIterator
it
(
this
)
;
for
(
TextRenderedRun
run
=
it
.
Current
(
)
;
run
.
mFrame
;
run
=
it
.
Next
(
)
)
{
uint32_t
flags
=
TextRenderedRunFlagsForBBoxContribution
(
run
aFlags
)
;
gfxMatrix
m
=
ThebesMatrix
(
aToBBoxUserspace
)
;
SVGBBox
bboxForRun
=
run
.
GetUserSpaceRect
(
presContext
flags
&
m
)
;
bbox
.
UnionEdges
(
bboxForRun
)
;
}
return
bbox
;
}
static
bool
HasTextContent
(
nsIContent
*
aContent
)
{
NS_ASSERTION
(
aContent
"
expected
non
-
null
aContent
"
)
;
TextNodeIterator
it
(
aContent
)
;
for
(
Text
*
text
=
it
.
Current
(
)
;
text
;
text
=
it
.
Next
(
)
)
{
if
(
text
-
>
TextLength
(
)
!
=
0
)
{
return
true
;
}
}
return
false
;
}
static
uint32_t
GetTextContentLength
(
nsIContent
*
aContent
)
{
NS_ASSERTION
(
aContent
"
expected
non
-
null
aContent
"
)
;
uint32_t
length
=
0
;
TextNodeIterator
it
(
aContent
)
;
for
(
Text
*
text
=
it
.
Current
(
)
;
text
;
text
=
it
.
Next
(
)
)
{
length
+
=
text
-
>
TextLength
(
)
;
}
return
length
;
}
int32_t
SVGTextFrame
:
:
ConvertTextElementCharIndexToAddressableIndex
(
int32_t
aIndex
nsIContent
*
aContent
)
{
CharIterator
it
(
this
CharIterator
:
:
eOriginal
aContent
)
;
if
(
!
it
.
AdvanceToSubtree
(
)
)
{
return
-
1
;
}
int32_t
result
=
0
;
int32_t
textElementCharIndex
;
while
(
!
it
.
AtEnd
(
)
&
&
it
.
IsWithinSubtree
(
)
)
{
bool
addressable
=
!
it
.
IsOriginalCharUnaddressable
(
)
;
textElementCharIndex
=
it
.
TextElementCharIndex
(
)
;
it
.
Next
(
)
;
uint32_t
delta
=
it
.
TextElementCharIndex
(
)
-
textElementCharIndex
;
aIndex
-
=
delta
;
if
(
addressable
)
{
if
(
aIndex
<
0
)
{
return
result
;
}
result
+
=
delta
;
}
}
return
-
1
;
}
uint32_t
SVGTextFrame
:
:
GetNumberOfChars
(
nsIContent
*
aContent
)
{
nsIFrame
*
kid
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
kid
-
>
IsSubtreeDirty
(
)
)
{
return
0
;
}
UpdateGlyphPositioning
(
)
;
uint32_t
n
=
0
;
CharIterator
it
(
this
CharIterator
:
:
eAddressable
aContent
)
;
if
(
it
.
AdvanceToSubtree
(
)
)
{
while
(
!
it
.
AtEnd
(
)
&
&
it
.
IsWithinSubtree
(
)
)
{
n
+
+
;
it
.
Next
(
)
;
}
}
return
n
;
}
float
SVGTextFrame
:
:
GetComputedTextLength
(
nsIContent
*
aContent
)
{
nsIFrame
*
kid
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
kid
-
>
IsSubtreeDirty
(
)
)
{
return
0
;
}
UpdateGlyphPositioning
(
)
;
float
cssPxPerDevPx
=
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
nscoord
length
=
0
;
TextRenderedRunIterator
it
(
this
TextRenderedRunIterator
:
:
eAllFrames
aContent
)
;
for
(
TextRenderedRun
run
=
it
.
Current
(
)
;
run
.
mFrame
;
run
=
it
.
Next
(
)
)
{
length
+
=
run
.
GetAdvanceWidth
(
)
;
}
return
PresContext
(
)
-
>
AppUnitsToGfxUnits
(
length
)
*
cssPxPerDevPx
*
mLengthAdjustScaleFactor
/
mFontSizeScaleFactor
;
}
void
SVGTextFrame
:
:
SelectSubString
(
nsIContent
*
aContent
uint32_t
charnum
uint32_t
nchars
ErrorResult
&
aRv
)
{
nsIFrame
*
kid
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
kid
-
>
IsSubtreeDirty
(
)
)
{
aRv
.
ThrowInvalidStateError
(
"
No
layout
information
available
for
SVG
text
"
)
;
return
;
}
UpdateGlyphPositioning
(
)
;
CharIterator
chit
(
this
CharIterator
:
:
eAddressable
aContent
)
;
if
(
!
chit
.
AdvanceToSubtree
(
)
|
|
!
chit
.
Next
(
charnum
)
|
|
chit
.
IsAfterSubtree
(
)
)
{
aRv
.
ThrowIndexSizeError
(
"
Character
index
out
of
range
"
)
;
return
;
}
charnum
=
chit
.
TextElementCharIndex
(
)
;
const
RefPtr
<
nsIContent
>
content
=
chit
.
TextFrame
(
)
-
>
GetContent
(
)
;
chit
.
NextWithinSubtree
(
nchars
)
;
nchars
=
chit
.
TextElementCharIndex
(
)
-
charnum
;
RefPtr
<
nsFrameSelection
>
frameSelection
=
GetFrameSelection
(
)
;
frameSelection
-
>
HandleClick
(
content
charnum
charnum
+
nchars
nsFrameSelection
:
:
FocusMode
:
:
kCollapseToNewPoint
CaretAssociationHint
:
:
Before
)
;
}
bool
SVGTextFrame
:
:
RequiresSlowFallbackForSubStringLength
(
)
{
TextFrameIterator
frameIter
(
this
)
;
for
(
nsTextFrame
*
frame
=
frameIter
.
Current
(
)
;
frame
;
frame
=
frameIter
.
Next
(
)
)
{
if
(
frameIter
.
TextPathFrame
(
)
|
|
frame
-
>
GetNextContinuation
(
)
)
{
return
true
;
}
}
return
false
;
}
float
SVGTextFrame
:
:
GetSubStringLengthFastPath
(
nsIContent
*
aContent
uint32_t
charnum
uint32_t
nchars
ErrorResult
&
aRv
)
{
MOZ_ASSERT
(
!
RequiresSlowFallbackForSubStringLength
(
)
)
;
TextNodeCorrespondenceRecorder
:
:
RecordCorrespondence
(
this
)
;
CharIterator
chit
(
this
CharIterator
:
:
eAddressable
aContent
false
)
;
if
(
!
chit
.
AdvanceToSubtree
(
)
|
|
!
chit
.
Next
(
charnum
)
|
|
chit
.
IsAfterSubtree
(
)
)
{
aRv
.
ThrowIndexSizeError
(
"
Character
index
out
of
range
"
)
;
return
0
;
}
if
(
nchars
=
=
0
)
{
return
0
.
0f
;
}
charnum
=
chit
.
TextElementCharIndex
(
)
;
chit
.
NextWithinSubtree
(
nchars
)
;
nchars
=
chit
.
TextElementCharIndex
(
)
-
charnum
;
nscoord
textLength
=
0
;
TextFrameIterator
frit
(
this
)
;
uint32_t
frameStartTextElementCharIndex
=
0
;
uint32_t
textElementCharIndex
;
for
(
nsTextFrame
*
frame
=
frit
.
Current
(
)
;
frame
;
frame
=
frit
.
Next
(
)
)
{
frameStartTextElementCharIndex
+
=
frit
.
UndisplayedCharacters
(
)
;
textElementCharIndex
=
frameStartTextElementCharIndex
;
const
uint32_t
untrimmedOffset
=
frame
-
>
GetContentOffset
(
)
;
const
uint32_t
untrimmedLength
=
frame
-
>
GetContentEnd
(
)
-
untrimmedOffset
;
uint32_t
trimmedOffset
=
untrimmedOffset
;
uint32_t
trimmedLength
=
untrimmedLength
;
nsTextFrame
:
:
TrimmedOffsets
trimmedOffsets
=
frame
-
>
GetTrimmedOffsets
(
frame
-
>
TextFragment
(
)
nsTextFrame
:
:
TrimmedOffsetFlags
:
:
NotPostReflow
)
;
TrimOffsets
(
trimmedOffset
trimmedLength
trimmedOffsets
)
;
textElementCharIndex
+
=
trimmedOffset
-
untrimmedOffset
;
if
(
textElementCharIndex
>
=
charnum
+
nchars
)
{
break
;
}
uint32_t
offset
=
textElementCharIndex
;
IntersectInterval
(
offset
trimmedLength
charnum
nchars
)
;
if
(
trimmedLength
!
=
0
)
{
offset
+
=
trimmedOffset
-
textElementCharIndex
;
gfxSkipCharsIterator
it
=
frame
-
>
EnsureTextRun
(
nsTextFrame
:
:
eInflated
)
;
gfxTextRun
*
textRun
=
frame
-
>
GetTextRun
(
nsTextFrame
:
:
eInflated
)
;
nsTextFrame
:
:
PropertyProvider
provider
(
frame
it
)
;
Range
range
=
ConvertOriginalToSkipped
(
it
offset
trimmedLength
)
;
textLength
+
=
textRun
-
>
GetAdvanceWidth
(
range
&
provider
)
;
}
frameStartTextElementCharIndex
+
=
untrimmedLength
;
}
nsPresContext
*
presContext
=
PresContext
(
)
;
float
cssPxPerDevPx
=
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
presContext
-
>
AppUnitsPerDevPixel
(
)
)
;
return
presContext
-
>
AppUnitsToGfxUnits
(
textLength
)
*
cssPxPerDevPx
/
mFontSizeScaleFactor
;
}
float
SVGTextFrame
:
:
GetSubStringLengthSlowFallback
(
nsIContent
*
aContent
uint32_t
charnum
uint32_t
nchars
ErrorResult
&
aRv
)
{
UpdateGlyphPositioning
(
)
;
CharIterator
chit
(
this
CharIterator
:
:
eAddressable
aContent
)
;
if
(
!
chit
.
AdvanceToSubtree
(
)
|
|
!
chit
.
Next
(
charnum
)
|
|
chit
.
IsAfterSubtree
(
)
)
{
aRv
.
ThrowIndexSizeError
(
"
Character
index
out
of
range
"
)
;
return
0
;
}
if
(
nchars
=
=
0
)
{
return
0
.
0f
;
}
charnum
=
chit
.
TextElementCharIndex
(
)
;
chit
.
NextWithinSubtree
(
nchars
)
;
nchars
=
chit
.
TextElementCharIndex
(
)
-
charnum
;
nscoord
textLength
=
0
;
TextRenderedRunIterator
runIter
(
this
TextRenderedRunIterator
:
:
eAllFrames
)
;
TextRenderedRun
run
=
runIter
.
Current
(
)
;
while
(
run
.
mFrame
)
{
uint32_t
offset
=
run
.
mTextElementCharIndex
;
if
(
offset
>
=
charnum
+
nchars
)
{
break
;
}
uint32_t
length
=
run
.
mTextFrameContentLength
;
IntersectInterval
(
offset
length
charnum
nchars
)
;
if
(
length
!
=
0
)
{
offset
+
=
run
.
mTextFrameContentOffset
-
run
.
mTextElementCharIndex
;
gfxSkipCharsIterator
it
=
run
.
mFrame
-
>
EnsureTextRun
(
nsTextFrame
:
:
eInflated
)
;
gfxTextRun
*
textRun
=
run
.
mFrame
-
>
GetTextRun
(
nsTextFrame
:
:
eInflated
)
;
nsTextFrame
:
:
PropertyProvider
provider
(
run
.
mFrame
it
)
;
Range
range
=
ConvertOriginalToSkipped
(
it
offset
length
)
;
textLength
+
=
textRun
-
>
GetAdvanceWidth
(
range
&
provider
)
;
}
run
=
runIter
.
Next
(
)
;
}
nsPresContext
*
presContext
=
PresContext
(
)
;
float
cssPxPerDevPx
=
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
presContext
-
>
AppUnitsPerDevPixel
(
)
)
;
return
presContext
-
>
AppUnitsToGfxUnits
(
textLength
)
*
cssPxPerDevPx
/
mFontSizeScaleFactor
;
}
int32_t
SVGTextFrame
:
:
GetCharNumAtPosition
(
nsIContent
*
aContent
const
DOMPointInit
&
aPoint
)
{
nsIFrame
*
kid
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
kid
-
>
IsSubtreeDirty
(
)
)
{
return
-
1
;
}
UpdateGlyphPositioning
(
)
;
nsPresContext
*
context
=
PresContext
(
)
;
gfxPoint
p
(
aPoint
.
mX
aPoint
.
mY
)
;
int32_t
result
=
-
1
;
TextRenderedRunIterator
it
(
this
TextRenderedRunIterator
:
:
eAllFrames
aContent
)
;
for
(
TextRenderedRun
run
=
it
.
Current
(
)
;
run
.
mFrame
;
run
=
it
.
Next
(
)
)
{
int32_t
index
=
run
.
GetCharNumAtPosition
(
context
p
)
;
if
(
index
!
=
-
1
)
{
result
=
index
+
run
.
mTextElementCharIndex
;
}
}
if
(
result
=
=
-
1
)
{
return
result
;
}
return
ConvertTextElementCharIndexToAddressableIndex
(
result
aContent
)
;
}
already_AddRefed
<
DOMSVGPoint
>
SVGTextFrame
:
:
GetStartPositionOfChar
(
nsIContent
*
aContent
uint32_t
aCharNum
ErrorResult
&
aRv
)
{
nsIFrame
*
kid
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
kid
-
>
IsSubtreeDirty
(
)
)
{
aRv
.
ThrowInvalidStateError
(
"
No
layout
information
available
for
SVG
text
"
)
;
return
nullptr
;
}
UpdateGlyphPositioning
(
)
;
CharIterator
it
(
this
CharIterator
:
:
eAddressable
aContent
)
;
if
(
!
it
.
AdvanceToSubtree
(
)
|
|
!
it
.
Next
(
aCharNum
)
)
{
aRv
.
ThrowIndexSizeError
(
"
Character
index
out
of
range
"
)
;
return
nullptr
;
}
uint32_t
startIndex
=
it
.
GlyphStartTextElementCharIndex
(
)
;
return
do_AddRef
(
new
DOMSVGPoint
(
ToPoint
(
mPositions
[
startIndex
]
.
mPosition
)
)
)
;
}
static
gfxFloat
GetGlyphAdvance
(
SVGTextFrame
*
aFrame
nsIContent
*
aContent
uint32_t
aTextElementCharIndex
CharIterator
*
aIterator
)
{
MOZ_ASSERT
(
!
aIterator
|
|
(
aIterator
-
>
Filter
(
)
=
=
CharIterator
:
:
eAddressable
&
&
aIterator
-
>
GetSubtree
(
)
=
=
aContent
&
&
aIterator
-
>
GlyphStartTextElementCharIndex
(
)
=
=
aTextElementCharIndex
)
"
Invalid
aIterator
"
)
;
Maybe
<
CharIterator
>
newIterator
;
CharIterator
*
it
=
aIterator
;
if
(
!
it
)
{
newIterator
.
emplace
(
aFrame
CharIterator
:
:
eAddressable
aContent
)
;
if
(
!
newIterator
-
>
AdvanceToSubtree
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
aContent
"
)
;
return
0
.
0
;
}
it
=
newIterator
.
ptr
(
)
;
}
while
(
it
-
>
GlyphStartTextElementCharIndex
(
)
!
=
aTextElementCharIndex
)
{
if
(
!
it
-
>
Next
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
aTextElementCharIndex
"
)
;
return
0
.
0
;
}
}
if
(
it
-
>
AtEnd
(
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
Invalid
aTextElementCharIndex
"
)
;
return
0
.
0
;
}
nsPresContext
*
presContext
=
aFrame
-
>
PresContext
(
)
;
gfxFloat
advance
=
0
.
0
;
for
(
;
;
)
{
advance
+
=
it
-
>
GetAdvance
(
presContext
)
;
if
(
!
it
-
>
Next
(
)
|
|
it
-
>
GlyphStartTextElementCharIndex
(
)
!
=
aTextElementCharIndex
)
{
break
;
}
}
return
advance
;
}
already_AddRefed
<
DOMSVGPoint
>
SVGTextFrame
:
:
GetEndPositionOfChar
(
nsIContent
*
aContent
uint32_t
aCharNum
ErrorResult
&
aRv
)
{
nsIFrame
*
kid
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
kid
-
>
IsSubtreeDirty
(
)
)
{
aRv
.
ThrowInvalidStateError
(
"
No
layout
information
available
for
SVG
text
"
)
;
return
nullptr
;
}
UpdateGlyphPositioning
(
)
;
CharIterator
it
(
this
CharIterator
:
:
eAddressable
aContent
)
;
if
(
!
it
.
AdvanceToSubtree
(
)
|
|
!
it
.
Next
(
aCharNum
)
)
{
aRv
.
ThrowIndexSizeError
(
"
Character
index
out
of
range
"
)
;
return
nullptr
;
}
uint32_t
startIndex
=
it
.
GlyphStartTextElementCharIndex
(
)
;
gfxFloat
advance
=
GetGlyphAdvance
(
this
aContent
startIndex
it
.
IsClusterAndLigatureGroupStart
(
)
?
&
it
:
nullptr
)
;
if
(
it
.
TextRun
(
)
-
>
IsRightToLeft
(
)
)
{
advance
=
-
advance
;
}
Matrix
m
=
Matrix
:
:
Rotation
(
mPositions
[
startIndex
]
.
mAngle
)
*
Matrix
:
:
Translation
(
ToPoint
(
mPositions
[
startIndex
]
.
mPosition
)
)
;
Point
p
=
m
.
TransformPoint
(
Point
(
advance
/
mFontSizeScaleFactor
0
)
)
;
return
do_AddRef
(
new
DOMSVGPoint
(
p
)
)
;
}
already_AddRefed
<
SVGRect
>
SVGTextFrame
:
:
GetExtentOfChar
(
nsIContent
*
aContent
uint32_t
aCharNum
ErrorResult
&
aRv
)
{
nsIFrame
*
kid
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
kid
-
>
IsSubtreeDirty
(
)
)
{
aRv
.
ThrowInvalidStateError
(
"
No
layout
information
available
for
SVG
text
"
)
;
return
nullptr
;
}
UpdateGlyphPositioning
(
)
;
CharIterator
it
(
this
CharIterator
:
:
eAddressable
aContent
)
;
if
(
!
it
.
AdvanceToSubtree
(
)
|
|
!
it
.
Next
(
aCharNum
)
)
{
aRv
.
ThrowIndexSizeError
(
"
Character
index
out
of
range
"
)
;
return
nullptr
;
}
nsPresContext
*
presContext
=
PresContext
(
)
;
float
cssPxPerDevPx
=
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
presContext
-
>
AppUnitsPerDevPixel
(
)
)
;
nsTextFrame
*
textFrame
=
it
.
TextFrame
(
)
;
uint32_t
startIndex
=
it
.
GlyphStartTextElementCharIndex
(
)
;
bool
isRTL
=
it
.
TextRun
(
)
-
>
IsRightToLeft
(
)
;
bool
isVertical
=
it
.
TextRun
(
)
-
>
IsVertical
(
)
;
gfxFloat
advance
=
GetGlyphAdvance
(
this
aContent
startIndex
it
.
IsClusterAndLigatureGroupStart
(
)
?
&
it
:
nullptr
)
;
gfxFloat
x
=
isRTL
?
-
advance
:
0
.
0
;
gfxFloat
ascent
descent
;
GetAscentAndDescentInAppUnits
(
textFrame
ascent
descent
)
;
gfxMatrix
m
;
m
.
PreTranslate
(
mPositions
[
startIndex
]
.
mPosition
)
;
m
.
PreRotate
(
mPositions
[
startIndex
]
.
mAngle
)
;
m
.
PreScale
(
1
/
mFontSizeScaleFactor
1
/
mFontSizeScaleFactor
)
;
gfxRect
glyphRect
;
if
(
isVertical
)
{
glyphRect
=
gfxRect
(
-
presContext
-
>
AppUnitsToGfxUnits
(
descent
)
*
cssPxPerDevPx
x
presContext
-
>
AppUnitsToGfxUnits
(
ascent
+
descent
)
*
cssPxPerDevPx
advance
)
;
}
else
{
glyphRect
=
gfxRect
(
x
-
presContext
-
>
AppUnitsToGfxUnits
(
ascent
)
*
cssPxPerDevPx
advance
presContext
-
>
AppUnitsToGfxUnits
(
ascent
+
descent
)
*
cssPxPerDevPx
)
;
}
gfxRect
r
=
m
.
TransformBounds
(
glyphRect
)
;
return
do_AddRef
(
new
SVGRect
(
aContent
ToRect
(
r
)
)
)
;
}
float
SVGTextFrame
:
:
GetRotationOfChar
(
nsIContent
*
aContent
uint32_t
aCharNum
ErrorResult
&
aRv
)
{
nsIFrame
*
kid
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
kid
-
>
IsSubtreeDirty
(
)
)
{
aRv
.
ThrowInvalidStateError
(
"
No
layout
information
available
for
SVG
text
"
)
;
return
0
;
}
UpdateGlyphPositioning
(
)
;
CharIterator
it
(
this
CharIterator
:
:
eAddressable
aContent
)
;
if
(
!
it
.
AdvanceToSubtree
(
)
|
|
!
it
.
Next
(
aCharNum
)
)
{
aRv
.
ThrowIndexSizeError
(
"
Character
index
out
of
range
"
)
;
return
0
;
}
const
gfxTextRun
:
:
GlyphRun
&
glyphRun
=
it
.
GlyphRun
(
)
;
int32_t
glyphOrientation
=
90
*
(
glyphRun
.
IsSidewaysRight
(
)
-
glyphRun
.
IsSidewaysLeft
(
)
)
;
return
mPositions
[
it
.
TextElementCharIndex
(
)
]
.
mAngle
*
180
.
0
/
M_PI
+
glyphOrientation
;
}
static
bool
ShouldStartRunAtIndex
(
const
nsTArray
<
CharPosition
>
&
aPositions
const
nsTArray
<
gfxPoint
>
&
aDeltas
uint32_t
aIndex
)
{
if
(
aIndex
=
=
0
)
{
return
true
;
}
if
(
aIndex
<
aPositions
.
Length
(
)
)
{
if
(
aPositions
[
aIndex
]
.
IsXSpecified
(
)
|
|
aPositions
[
aIndex
]
.
IsYSpecified
(
)
)
{
return
true
;
}
if
(
(
aPositions
[
aIndex
]
.
IsAngleSpecified
(
)
&
&
aPositions
[
aIndex
]
.
mAngle
!
=
0
.
0f
)
|
|
(
aPositions
[
aIndex
-
1
]
.
IsAngleSpecified
(
)
&
&
(
aPositions
[
aIndex
-
1
]
.
mAngle
!
=
0
.
0f
)
)
)
{
return
true
;
}
}
if
(
aIndex
<
aDeltas
.
Length
(
)
)
{
if
(
aDeltas
[
aIndex
]
.
x
!
=
0
.
0
|
|
aDeltas
[
aIndex
]
.
y
!
=
0
.
0
)
{
return
true
;
}
}
return
false
;
}
bool
SVGTextFrame
:
:
ResolvePositionsForNode
(
nsIContent
*
aContent
uint32_t
&
aIndex
bool
aInTextPath
bool
&
aForceStartOfChunk
nsTArray
<
gfxPoint
>
&
aDeltas
)
{
if
(
aContent
-
>
IsText
(
)
)
{
uint32_t
length
=
aContent
-
>
AsText
(
)
-
>
TextLength
(
)
;
if
(
length
)
{
uint32_t
end
=
aIndex
+
length
;
if
(
MOZ_UNLIKELY
(
end
>
mPositions
.
Length
(
)
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
length
of
mPositions
does
not
match
characters
"
"
found
by
iterating
content
"
)
;
return
false
;
}
if
(
aForceStartOfChunk
)
{
mPositions
[
aIndex
]
.
mStartOfChunk
=
true
;
aForceStartOfChunk
=
false
;
}
while
(
aIndex
<
end
)
{
if
(
aInTextPath
|
|
ShouldStartRunAtIndex
(
mPositions
aDeltas
aIndex
)
)
{
mPositions
[
aIndex
]
.
mRunBoundary
=
true
;
}
aIndex
+
+
;
}
}
return
true
;
}
if
(
!
IsTextContentElement
(
aContent
)
)
{
return
true
;
}
if
(
aContent
-
>
IsSVGElement
(
nsGkAtoms
:
:
textPath
)
)
{
if
(
HasTextContent
(
aContent
)
)
{
if
(
MOZ_UNLIKELY
(
aIndex
>
=
mPositions
.
Length
(
)
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
length
of
mPositions
does
not
match
characters
"
"
found
by
iterating
content
"
)
;
return
false
;
}
bool
vertical
=
GetWritingMode
(
)
.
IsVertical
(
)
;
if
(
vertical
|
|
!
mPositions
[
aIndex
]
.
IsXSpecified
(
)
)
{
mPositions
[
aIndex
]
.
mPosition
.
x
=
0
.
0
;
}
if
(
!
vertical
|
|
!
mPositions
[
aIndex
]
.
IsYSpecified
(
)
)
{
mPositions
[
aIndex
]
.
mPosition
.
y
=
0
.
0
;
}
mPositions
[
aIndex
]
.
mStartOfChunk
=
true
;
}
}
else
if
(
!
aContent
-
>
IsSVGElement
(
nsGkAtoms
:
:
a
)
)
{
MOZ_ASSERT
(
aContent
-
>
IsSVGElement
(
)
)
;
SVGElement
*
element
=
static_cast
<
SVGElement
*
>
(
aContent
)
;
SVGUserUnitList
x
y
dx
dy
;
element
-
>
GetAnimatedLengthListValues
(
&
x
&
y
&
dx
&
dy
nullptr
)
;
const
SVGNumberList
*
rotate
=
nullptr
;
SVGAnimatedNumberList
*
animatedRotate
=
element
-
>
GetAnimatedNumberList
(
nsGkAtoms
:
:
rotate
)
;
if
(
animatedRotate
)
{
rotate
=
&
animatedRotate
-
>
GetAnimValue
(
)
;
}
bool
percentages
=
false
;
uint32_t
count
=
GetTextContentLength
(
aContent
)
;
if
(
MOZ_UNLIKELY
(
aIndex
+
count
>
mPositions
.
Length
(
)
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
length
of
mPositions
does
not
match
characters
"
"
found
by
iterating
content
"
)
;
return
false
;
}
uint32_t
newChunkCount
=
std
:
:
max
(
x
.
Length
(
)
y
.
Length
(
)
)
;
if
(
!
newChunkCount
&
&
aForceStartOfChunk
)
{
newChunkCount
=
1
;
}
for
(
uint32_t
i
=
0
j
=
0
;
i
<
newChunkCount
&
&
j
<
count
;
j
+
+
)
{
if
(
!
mPositions
[
aIndex
+
j
]
.
mUnaddressable
)
{
mPositions
[
aIndex
+
j
]
.
mStartOfChunk
=
true
;
i
+
+
;
}
}
if
(
!
dx
.
IsEmpty
(
)
|
|
!
dy
.
IsEmpty
(
)
)
{
aDeltas
.
EnsureLengthAtLeast
(
aIndex
+
count
)
;
for
(
uint32_t
i
=
0
j
=
0
;
i
<
dx
.
Length
(
)
&
&
j
<
count
;
j
+
+
)
{
if
(
!
mPositions
[
aIndex
+
j
]
.
mUnaddressable
)
{
aDeltas
[
aIndex
+
j
]
.
x
=
dx
[
i
]
;
percentages
=
percentages
|
|
dx
.
HasPercentageValueAt
(
i
)
;
i
+
+
;
}
}
for
(
uint32_t
i
=
0
j
=
0
;
i
<
dy
.
Length
(
)
&
&
j
<
count
;
j
+
+
)
{
if
(
!
mPositions
[
aIndex
+
j
]
.
mUnaddressable
)
{
aDeltas
[
aIndex
+
j
]
.
y
=
dy
[
i
]
;
percentages
=
percentages
|
|
dy
.
HasPercentageValueAt
(
i
)
;
i
+
+
;
}
}
}
for
(
uint32_t
i
=
0
j
=
0
;
i
<
x
.
Length
(
)
&
&
j
<
count
;
j
+
+
)
{
if
(
!
mPositions
[
aIndex
+
j
]
.
mUnaddressable
)
{
mPositions
[
aIndex
+
j
]
.
mPosition
.
x
=
x
[
i
]
;
percentages
=
percentages
|
|
x
.
HasPercentageValueAt
(
i
)
;
i
+
+
;
}
}
for
(
uint32_t
i
=
0
j
=
0
;
i
<
y
.
Length
(
)
&
&
j
<
count
;
j
+
+
)
{
if
(
!
mPositions
[
aIndex
+
j
]
.
mUnaddressable
)
{
mPositions
[
aIndex
+
j
]
.
mPosition
.
y
=
y
[
i
]
;
percentages
=
percentages
|
|
y
.
HasPercentageValueAt
(
i
)
;
i
+
+
;
}
}
if
(
rotate
&
&
!
rotate
-
>
IsEmpty
(
)
)
{
uint32_t
i
=
0
j
=
0
;
while
(
i
<
rotate
-
>
Length
(
)
&
&
j
<
count
)
{
if
(
!
mPositions
[
aIndex
+
j
]
.
mUnaddressable
)
{
mPositions
[
aIndex
+
j
]
.
mAngle
=
M_PI
*
(
*
rotate
)
[
i
]
/
180
.
0
;
i
+
+
;
}
j
+
+
;
}
while
(
j
<
count
)
{
mPositions
[
aIndex
+
j
]
.
mAngle
=
mPositions
[
aIndex
+
j
-
1
]
.
mAngle
;
j
+
+
;
}
}
if
(
percentages
)
{
AddStateBits
(
NS_STATE_SVG_POSITIONING_MAY_USE_PERCENTAGES
)
;
}
}
bool
inTextPath
=
aInTextPath
|
|
aContent
-
>
IsSVGElement
(
nsGkAtoms
:
:
textPath
)
;
for
(
nsIContent
*
child
=
aContent
-
>
GetFirstChild
(
)
;
child
;
child
=
child
-
>
GetNextSibling
(
)
)
{
bool
ok
=
ResolvePositionsForNode
(
child
aIndex
inTextPath
aForceStartOfChunk
aDeltas
)
;
if
(
!
ok
)
{
return
false
;
}
}
if
(
aContent
-
>
IsSVGElement
(
nsGkAtoms
:
:
textPath
)
)
{
aForceStartOfChunk
=
true
;
}
return
true
;
}
bool
SVGTextFrame
:
:
ResolvePositions
(
nsTArray
<
gfxPoint
>
&
aDeltas
bool
aRunPerGlyph
)
{
NS_ASSERTION
(
mPositions
.
IsEmpty
(
)
"
expected
mPositions
to
be
empty
"
)
;
RemoveStateBits
(
NS_STATE_SVG_POSITIONING_MAY_USE_PERCENTAGES
)
;
CharIterator
it
(
this
CharIterator
:
:
eOriginal
nullptr
)
;
if
(
it
.
AtEnd
(
)
)
{
return
false
;
}
bool
firstCharUnaddressable
=
it
.
IsOriginalCharUnaddressable
(
)
;
mPositions
.
AppendElement
(
CharPosition
:
:
Unspecified
(
firstCharUnaddressable
)
)
;
uint32_t
index
=
0
;
while
(
it
.
Next
(
)
)
{
while
(
+
+
index
<
it
.
TextElementCharIndex
(
)
)
{
mPositions
.
AppendElement
(
CharPosition
:
:
Unspecified
(
false
)
)
;
}
mPositions
.
AppendElement
(
CharPosition
:
:
Unspecified
(
it
.
IsOriginalCharUnaddressable
(
)
)
)
;
}
while
(
+
+
index
<
it
.
TextElementCharIndex
(
)
)
{
mPositions
.
AppendElement
(
CharPosition
:
:
Unspecified
(
false
)
)
;
}
bool
forceStartOfChunk
=
false
;
index
=
0
;
bool
ok
=
ResolvePositionsForNode
(
mContent
index
aRunPerGlyph
forceStartOfChunk
aDeltas
)
;
return
ok
&
&
index
>
0
;
}
void
SVGTextFrame
:
:
DetermineCharPositions
(
nsTArray
<
nsPoint
>
&
aPositions
)
{
NS_ASSERTION
(
aPositions
.
IsEmpty
(
)
"
expected
aPositions
to
be
empty
"
)
;
nsPoint
position
;
TextFrameIterator
frit
(
this
)
;
for
(
nsTextFrame
*
frame
=
frit
.
Current
(
)
;
frame
;
frame
=
frit
.
Next
(
)
)
{
gfxSkipCharsIterator
it
=
frame
-
>
EnsureTextRun
(
nsTextFrame
:
:
eInflated
)
;
gfxTextRun
*
textRun
=
frame
-
>
GetTextRun
(
nsTextFrame
:
:
eInflated
)
;
nsTextFrame
:
:
PropertyProvider
provider
(
frame
it
)
;
position
=
frit
.
Position
(
)
;
if
(
textRun
-
>
IsVertical
(
)
)
{
if
(
textRun
-
>
IsRightToLeft
(
)
)
{
position
.
y
+
=
frame
-
>
GetRect
(
)
.
height
;
}
position
.
x
+
=
GetBaselinePosition
(
frame
textRun
frit
.
DominantBaseline
(
)
mFontSizeScaleFactor
)
;
}
else
{
if
(
textRun
-
>
IsRightToLeft
(
)
)
{
position
.
x
+
=
frame
-
>
GetRect
(
)
.
width
;
}
position
.
y
+
=
GetBaselinePosition
(
frame
textRun
frit
.
DominantBaseline
(
)
mFontSizeScaleFactor
)
;
}
for
(
uint32_t
i
=
0
;
i
<
frit
.
UndisplayedCharacters
(
)
;
i
+
+
)
{
aPositions
.
AppendElement
(
position
)
;
}
nsTextFrame
:
:
TrimmedOffsets
trimmedOffsets
=
frame
-
>
GetTrimmedOffsets
(
frame
-
>
TextFragment
(
)
)
;
while
(
it
.
GetOriginalOffset
(
)
<
trimmedOffsets
.
mStart
)
{
aPositions
.
AppendElement
(
position
)
;
it
.
AdvanceOriginal
(
1
)
;
}
while
(
it
.
GetOriginalOffset
(
)
<
frame
-
>
GetContentEnd
(
)
)
{
aPositions
.
AppendElement
(
position
)
;
if
(
!
it
.
IsOriginalCharSkipped
(
)
)
{
uint32_t
offset
=
it
.
GetSkippedOffset
(
)
;
nscoord
advance
=
textRun
-
>
GetAdvanceWidth
(
Range
(
offset
offset
+
1
)
&
provider
)
;
(
textRun
-
>
IsVertical
(
)
?
position
.
y
:
position
.
x
)
+
=
textRun
-
>
IsRightToLeft
(
)
?
-
advance
:
advance
;
}
it
.
AdvanceOriginal
(
1
)
;
}
}
for
(
uint32_t
i
=
0
;
i
<
frit
.
UndisplayedCharacters
(
)
;
i
+
+
)
{
aPositions
.
AppendElement
(
position
)
;
}
}
enum
TextAnchorSide
{
eAnchorLeft
eAnchorMiddle
eAnchorRight
}
;
static
TextAnchorSide
ConvertLogicalTextAnchorToPhysical
(
StyleTextAnchor
aTextAnchor
bool
aIsRightToLeft
)
{
NS_ASSERTION
(
uint8_t
(
aTextAnchor
)
<
=
3
"
unexpected
value
for
aTextAnchor
"
)
;
if
(
!
aIsRightToLeft
)
{
return
TextAnchorSide
(
uint8_t
(
aTextAnchor
)
)
;
}
return
TextAnchorSide
(
2
-
uint8_t
(
aTextAnchor
)
)
;
}
static
void
ShiftAnchoredChunk
(
nsTArray
<
CharPosition
>
&
aCharPositions
uint32_t
aChunkStart
uint32_t
aChunkEnd
gfxFloat
aVisIStartEdge
gfxFloat
aVisIEndEdge
TextAnchorSide
aAnchorSide
bool
aVertical
)
{
NS_ASSERTION
(
aVisIStartEdge
<
=
aVisIEndEdge
"
unexpected
anchored
chunk
edges
"
)
;
NS_ASSERTION
(
aChunkStart
<
aChunkEnd
"
unexpected
values
for
aChunkStart
and
aChunkEnd
"
)
;
gfxFloat
shift
=
aVertical
?
aCharPositions
[
aChunkStart
]
.
mPosition
.
y
:
aCharPositions
[
aChunkStart
]
.
mPosition
.
x
;
switch
(
aAnchorSide
)
{
case
eAnchorLeft
:
shift
-
=
aVisIStartEdge
;
break
;
case
eAnchorMiddle
:
shift
-
=
(
aVisIStartEdge
+
aVisIEndEdge
)
/
2
;
break
;
case
eAnchorRight
:
shift
-
=
aVisIEndEdge
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
value
for
aAnchorSide
"
)
;
}
if
(
shift
!
=
0
.
0
)
{
if
(
aVertical
)
{
for
(
uint32_t
i
=
aChunkStart
;
i
<
aChunkEnd
;
i
+
+
)
{
aCharPositions
[
i
]
.
mPosition
.
y
+
=
shift
;
}
}
else
{
for
(
uint32_t
i
=
aChunkStart
;
i
<
aChunkEnd
;
i
+
+
)
{
aCharPositions
[
i
]
.
mPosition
.
x
+
=
shift
;
}
}
}
}
void
SVGTextFrame
:
:
AdjustChunksForLineBreaks
(
)
{
nsBlockFrame
*
block
=
do_QueryFrame
(
PrincipalChildList
(
)
.
FirstChild
(
)
)
;
NS_ASSERTION
(
block
"
expected
block
frame
"
)
;
nsBlockFrame
:
:
LineIterator
line
=
block
-
>
LinesBegin
(
)
;
CharIterator
it
(
this
CharIterator
:
:
eOriginal
nullptr
)
;
while
(
!
it
.
AtEnd
(
)
&
&
line
!
=
block
-
>
LinesEnd
(
)
)
{
if
(
it
.
TextFrame
(
)
=
=
line
-
>
mFirstChild
)
{
mPositions
[
it
.
TextElementCharIndex
(
)
]
.
mStartOfChunk
=
true
;
line
+
+
;
}
it
.
AdvancePastCurrentFrame
(
)
;
}
}
void
SVGTextFrame
:
:
AdjustPositionsForClusters
(
)
{
nsPresContext
*
presContext
=
PresContext
(
)
;
gfxFloat
partialAdvance
=
0
.
0
;
CharIterator
it
(
this
CharIterator
:
:
eUnskipped
nullptr
)
;
bool
isFirst
=
true
;
while
(
!
it
.
AtEnd
(
)
)
{
if
(
it
.
IsClusterAndLigatureGroupStart
(
)
|
|
isFirst
)
{
partialAdvance
=
0
.
0
;
isFirst
=
false
;
}
else
{
uint32_t
charIndex
=
it
.
TextElementCharIndex
(
)
;
uint32_t
startIndex
=
it
.
GlyphStartTextElementCharIndex
(
)
;
MOZ_ASSERT
(
charIndex
!
=
startIndex
"
If
the
current
character
is
in
the
middle
of
a
cluster
or
"
"
ligature
group
then
charIndex
must
be
different
from
"
"
startIndex
"
)
;
mPositions
[
charIndex
]
.
mClusterOrLigatureGroupMiddle
=
true
;
bool
rotationAdjusted
=
false
;
double
angle
=
mPositions
[
startIndex
]
.
mAngle
;
if
(
mPositions
[
charIndex
]
.
mAngle
!
=
angle
)
{
mPositions
[
charIndex
]
.
mAngle
=
angle
;
rotationAdjusted
=
true
;
}
gfxFloat
advance
=
partialAdvance
/
mFontSizeScaleFactor
;
gfxPoint
direction
=
gfxPoint
(
cos
(
angle
)
sin
(
angle
)
)
*
(
it
.
TextRun
(
)
-
>
IsRightToLeft
(
)
?
-
1
.
0
:
1
.
0
)
;
if
(
it
.
TextRun
(
)
-
>
IsVertical
(
)
)
{
std
:
:
swap
(
direction
.
x
direction
.
y
)
;
}
mPositions
[
charIndex
]
.
mPosition
=
mPositions
[
startIndex
]
.
mPosition
+
direction
*
advance
;
if
(
mPositions
[
charIndex
]
.
mRunBoundary
)
{
mPositions
[
charIndex
]
.
mRunBoundary
=
false
;
if
(
charIndex
+
1
<
mPositions
.
Length
(
)
)
{
mPositions
[
charIndex
+
1
]
.
mRunBoundary
=
true
;
}
}
else
if
(
rotationAdjusted
)
{
if
(
charIndex
+
1
<
mPositions
.
Length
(
)
)
{
mPositions
[
charIndex
+
1
]
.
mRunBoundary
=
true
;
}
}
if
(
mPositions
[
charIndex
]
.
mStartOfChunk
)
{
mPositions
[
charIndex
]
.
mStartOfChunk
=
false
;
if
(
charIndex
+
1
<
mPositions
.
Length
(
)
)
{
mPositions
[
charIndex
+
1
]
.
mStartOfChunk
=
true
;
}
}
}
partialAdvance
+
=
it
.
GetAdvance
(
presContext
)
;
it
.
Next
(
)
;
}
}
already_AddRefed
<
Path
>
SVGTextFrame
:
:
GetTextPath
(
nsIFrame
*
aTextPathFrame
)
{
nsIContent
*
content
=
aTextPathFrame
-
>
GetContent
(
)
;
SVGTextPathElement
*
tp
=
static_cast
<
SVGTextPathElement
*
>
(
content
)
;
if
(
tp
-
>
mPath
.
IsRendered
(
)
)
{
return
tp
-
>
mPath
.
GetAnimValue
(
)
.
BuildPathForMeasuring
(
)
;
}
SVGGeometryElement
*
geomElement
=
SVGObserverUtils
:
:
GetAndObserveTextPathsPath
(
aTextPathFrame
)
;
if
(
!
geomElement
)
{
return
nullptr
;
}
RefPtr
<
Path
>
path
=
geomElement
-
>
GetOrBuildPathForMeasuring
(
)
;
if
(
!
path
)
{
return
nullptr
;
}
gfxMatrix
matrix
=
geomElement
-
>
PrependLocalTransformsTo
(
gfxMatrix
(
)
)
;
if
(
!
matrix
.
IsIdentity
(
)
)
{
RefPtr
<
PathBuilder
>
builder
=
path
-
>
TransformedCopyToBuilder
(
ToMatrix
(
matrix
)
)
;
path
=
builder
-
>
Finish
(
)
;
}
return
path
.
forget
(
)
;
}
gfxFloat
SVGTextFrame
:
:
GetOffsetScale
(
nsIFrame
*
aTextPathFrame
)
{
nsIContent
*
content
=
aTextPathFrame
-
>
GetContent
(
)
;
SVGTextPathElement
*
tp
=
static_cast
<
SVGTextPathElement
*
>
(
content
)
;
if
(
tp
-
>
mPath
.
IsRendered
(
)
)
{
return
1
.
0
;
}
SVGGeometryElement
*
geomElement
=
SVGObserverUtils
:
:
GetAndObserveTextPathsPath
(
aTextPathFrame
)
;
if
(
!
geomElement
)
{
return
1
.
0
;
}
return
geomElement
-
>
GetPathLengthScale
(
SVGGeometryElement
:
:
eForTextPath
)
;
}
gfxFloat
SVGTextFrame
:
:
GetStartOffset
(
nsIFrame
*
aTextPathFrame
)
{
SVGTextPathElement
*
tp
=
static_cast
<
SVGTextPathElement
*
>
(
aTextPathFrame
-
>
GetContent
(
)
)
;
SVGAnimatedLength
*
length
=
&
tp
-
>
mLengthAttributes
[
SVGTextPathElement
:
:
STARTOFFSET
]
;
if
(
length
-
>
IsPercentage
(
)
)
{
if
(
!
std
:
:
isfinite
(
GetOffsetScale
(
aTextPathFrame
)
)
)
{
return
0
.
0
;
}
RefPtr
<
Path
>
data
=
GetTextPath
(
aTextPathFrame
)
;
return
data
?
length
-
>
GetAnimValInSpecifiedUnits
(
)
*
data
-
>
ComputeLength
(
)
/
100
.
0
:
0
.
0
;
}
float
lengthValue
=
length
-
>
GetAnimValue
(
tp
)
;
return
lengthValue
=
=
0
?
0
.
0
:
lengthValue
*
GetOffsetScale
(
aTextPathFrame
)
;
}
void
SVGTextFrame
:
:
DoTextPathLayout
(
)
{
nsPresContext
*
context
=
PresContext
(
)
;
CharIterator
it
(
this
CharIterator
:
:
eOriginal
nullptr
)
;
while
(
!
it
.
AtEnd
(
)
)
{
nsIFrame
*
textPathFrame
=
it
.
TextPathFrame
(
)
;
if
(
!
textPathFrame
)
{
it
.
AdvancePastCurrentFrame
(
)
;
continue
;
}
RefPtr
<
Path
>
path
=
GetTextPath
(
textPathFrame
)
;
if
(
!
path
)
{
uint32_t
start
=
it
.
TextElementCharIndex
(
)
;
it
.
AdvancePastCurrentTextPathFrame
(
)
;
uint32_t
end
=
it
.
TextElementCharIndex
(
)
;
for
(
uint32_t
i
=
start
;
i
<
end
;
i
+
+
)
{
mPositions
[
i
]
.
mHidden
=
true
;
}
continue
;
}
SVGTextPathElement
*
textPath
=
static_cast
<
SVGTextPathElement
*
>
(
textPathFrame
-
>
GetContent
(
)
)
;
uint16_t
side
=
textPath
-
>
EnumAttributes
(
)
[
SVGTextPathElement
:
:
SIDE
]
.
GetAnimValue
(
)
;
gfxFloat
offset
=
GetStartOffset
(
textPathFrame
)
;
Float
pathLength
=
path
-
>
ComputeLength
(
)
;
while
(
!
it
.
AtEnd
(
)
)
{
if
(
it
.
IsOriginalCharSkipped
(
)
)
{
it
.
Next
(
)
;
continue
;
}
if
(
it
.
IsClusterAndLigatureGroupStart
(
)
)
{
break
;
}
it
.
Next
(
)
;
}
bool
skippedEndOfTextPath
=
false
;
while
(
!
it
.
AtEnd
(
)
&
&
it
.
TextPathFrame
(
)
&
&
it
.
TextPathFrame
(
)
-
>
GetContent
(
)
=
=
textPath
)
{
uint32_t
i
=
it
.
TextElementCharIndex
(
)
;
uint32_t
j
=
i
+
1
;
MOZ_ASSERT
(
!
mPositions
[
i
]
.
mClusterOrLigatureGroupMiddle
)
;
gfxFloat
sign
=
it
.
TextRun
(
)
-
>
IsRightToLeft
(
)
?
-
1
.
0
:
1
.
0
;
bool
vertical
=
it
.
TextRun
(
)
-
>
IsVertical
(
)
;
AutoTArray
<
gfxFloat
4
>
partialAdvances
;
gfxFloat
partialAdvance
=
it
.
GetAdvance
(
context
)
;
partialAdvances
.
AppendElement
(
partialAdvance
)
;
while
(
it
.
Next
(
)
)
{
MOZ_ASSERT
(
j
<
=
it
.
TextElementCharIndex
(
)
)
;
while
(
j
<
it
.
TextElementCharIndex
(
)
)
{
partialAdvances
.
AppendElement
(
partialAdvance
)
;
+
+
j
;
}
if
(
it
.
IsOriginalCharSkipped
(
)
)
{
if
(
!
it
.
TextPathFrame
(
)
)
{
skippedEndOfTextPath
=
true
;
break
;
}
}
else
if
(
it
.
IsClusterAndLigatureGroupStart
(
)
)
{
break
;
}
else
{
partialAdvance
+
=
it
.
GetAdvance
(
context
)
;
}
partialAdvances
.
AppendElement
(
partialAdvance
)
;
}
if
(
!
skippedEndOfTextPath
)
{
MOZ_ASSERT
(
j
<
=
it
.
TextElementCharIndex
(
)
)
;
while
(
j
<
it
.
TextElementCharIndex
(
)
)
{
partialAdvances
.
AppendElement
(
partialAdvance
)
;
+
+
j
;
}
}
gfxFloat
halfAdvance
=
partialAdvances
.
LastElement
(
)
/
mFontSizeScaleFactor
/
2
.
0
;
gfxFloat
midx
=
(
vertical
?
mPositions
[
i
]
.
mPosition
.
y
:
mPositions
[
i
]
.
mPosition
.
x
)
+
sign
*
halfAdvance
+
offset
;
mPositions
[
i
]
.
mHidden
=
midx
<
0
|
|
midx
>
pathLength
;
Point
tangent
;
Point
pt
;
if
(
side
=
=
TEXTPATH_SIDETYPE_RIGHT
)
{
pt
=
path
-
>
ComputePointAtLength
(
Float
(
pathLength
-
midx
)
&
tangent
)
;
tangent
=
-
tangent
;
}
else
{
pt
=
path
-
>
ComputePointAtLength
(
Float
(
midx
)
&
tangent
)
;
}
Float
rotation
=
vertical
?
atan2f
(
-
tangent
.
x
tangent
.
y
)
:
atan2f
(
tangent
.
y
tangent
.
x
)
;
Point
normal
(
-
tangent
.
y
tangent
.
x
)
;
Point
offsetFromPath
=
normal
*
(
vertical
?
-
mPositions
[
i
]
.
mPosition
.
x
:
mPositions
[
i
]
.
mPosition
.
y
)
;
pt
+
=
offsetFromPath
;
Point
direction
=
tangent
*
sign
;
mPositions
[
i
]
.
mPosition
=
ThebesPoint
(
pt
)
-
ThebesPoint
(
direction
)
*
halfAdvance
;
mPositions
[
i
]
.
mAngle
+
=
rotation
;
for
(
uint32_t
k
=
i
+
1
;
k
<
j
;
k
+
+
)
{
gfxPoint
partialAdvance
=
ThebesPoint
(
direction
)
*
partialAdvances
[
k
-
i
]
/
mFontSizeScaleFactor
;
mPositions
[
k
]
.
mPosition
=
mPositions
[
i
]
.
mPosition
+
partialAdvance
;
mPositions
[
k
]
.
mAngle
=
mPositions
[
i
]
.
mAngle
;
mPositions
[
k
]
.
mHidden
=
mPositions
[
i
]
.
mHidden
;
}
}
}
}
void
SVGTextFrame
:
:
DoAnchoring
(
)
{
nsPresContext
*
presContext
=
PresContext
(
)
;
CharIterator
it
(
this
CharIterator
:
:
eOriginal
nullptr
)
;
while
(
!
it
.
AtEnd
(
)
&
&
(
it
.
IsOriginalCharSkipped
(
)
|
|
it
.
IsOriginalCharTrimmed
(
)
)
)
{
it
.
Next
(
)
;
}
bool
vertical
=
GetWritingMode
(
)
.
IsVertical
(
)
;
uint32_t
start
=
it
.
TextElementCharIndex
(
)
;
while
(
start
<
mPositions
.
Length
(
)
)
{
it
.
AdvanceToCharacter
(
start
)
;
nsTextFrame
*
chunkFrame
=
it
.
TextFrame
(
)
;
uint32_t
index
=
it
.
TextElementCharIndex
(
)
;
uint32_t
end
=
start
;
gfxFloat
left
=
std
:
:
numeric_limits
<
gfxFloat
>
:
:
infinity
(
)
;
gfxFloat
right
=
-
std
:
:
numeric_limits
<
gfxFloat
>
:
:
infinity
(
)
;
do
{
if
(
!
it
.
IsOriginalCharSkipped
(
)
&
&
!
it
.
IsOriginalCharTrimmed
(
)
)
{
gfxFloat
advance
=
it
.
GetAdvance
(
presContext
)
/
mFontSizeScaleFactor
;
gfxFloat
pos
=
it
.
TextRun
(
)
-
>
IsVertical
(
)
?
mPositions
[
index
]
.
mPosition
.
y
:
mPositions
[
index
]
.
mPosition
.
x
;
if
(
it
.
TextRun
(
)
-
>
IsRightToLeft
(
)
)
{
left
=
std
:
:
min
(
left
pos
-
advance
)
;
right
=
std
:
:
max
(
right
pos
)
;
}
else
{
left
=
std
:
:
min
(
left
pos
)
;
right
=
std
:
:
max
(
right
pos
+
advance
)
;
}
}
it
.
Next
(
)
;
index
=
end
=
it
.
TextElementCharIndex
(
)
;
}
while
(
!
it
.
AtEnd
(
)
&
&
!
mPositions
[
end
]
.
mStartOfChunk
)
;
if
(
left
!
=
std
:
:
numeric_limits
<
gfxFloat
>
:
:
infinity
(
)
)
{
bool
isRTL
=
chunkFrame
-
>
StyleVisibility
(
)
-
>
mDirection
=
=
StyleDirection
:
:
Rtl
;
TextAnchorSide
anchor
=
ConvertLogicalTextAnchorToPhysical
(
chunkFrame
-
>
StyleSVG
(
)
-
>
mTextAnchor
isRTL
)
;
ShiftAnchoredChunk
(
mPositions
start
end
left
right
anchor
vertical
)
;
}
start
=
it
.
TextElementCharIndex
(
)
;
}
}
void
SVGTextFrame
:
:
DoGlyphPositioning
(
)
{
mPositions
.
Clear
(
)
;
RemoveStateBits
(
NS_STATE_SVG_POSITIONING_DIRTY
)
;
nsIFrame
*
kid
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
kid
&
&
kid
-
>
IsSubtreeDirty
(
)
)
{
MOZ_ASSERT
(
false
"
should
have
already
reflowed
the
kid
"
)
;
return
;
}
TextNodeCorrespondenceRecorder
:
:
RecordCorrespondence
(
this
)
;
AutoTArray
<
nsPoint
64
>
charPositions
;
DetermineCharPositions
(
charPositions
)
;
if
(
charPositions
.
IsEmpty
(
)
)
{
return
;
}
SVGTextContentElement
*
element
=
static_cast
<
SVGTextContentElement
*
>
(
GetContent
(
)
)
;
SVGAnimatedLength
*
textLengthAttr
=
element
-
>
GetAnimatedLength
(
nsGkAtoms
:
:
textLength
)
;
uint16_t
lengthAdjust
=
element
-
>
EnumAttributes
(
)
[
SVGTextContentElement
:
:
LENGTHADJUST
]
.
GetAnimValue
(
)
;
bool
adjustingTextLength
=
textLengthAttr
-
>
IsExplicitlySet
(
)
;
float
expectedTextLength
=
textLengthAttr
-
>
GetAnimValue
(
element
)
;
if
(
adjustingTextLength
&
&
(
expectedTextLength
<
0
.
0f
|
|
lengthAdjust
=
=
LENGTHADJUST_UNKNOWN
)
)
{
adjustingTextLength
=
false
;
}
AutoTArray
<
gfxPoint
16
>
deltas
;
if
(
!
ResolvePositions
(
deltas
adjustingTextLength
)
)
{
mPositions
.
Clear
(
)
;
return
;
}
TruncateTo
(
deltas
charPositions
)
;
TruncateTo
(
mPositions
charPositions
)
;
if
(
!
mPositions
[
0
]
.
IsXSpecified
(
)
)
{
mPositions
[
0
]
.
mPosition
.
x
=
0
.
0
;
}
if
(
!
mPositions
[
0
]
.
IsYSpecified
(
)
)
{
mPositions
[
0
]
.
mPosition
.
y
=
0
.
0
;
}
if
(
!
mPositions
[
0
]
.
IsAngleSpecified
(
)
)
{
mPositions
[
0
]
.
mAngle
=
0
.
0
;
}
nsPresContext
*
presContext
=
PresContext
(
)
;
bool
vertical
=
GetWritingMode
(
)
.
IsVertical
(
)
;
float
cssPxPerDevPx
=
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
presContext
-
>
AppUnitsPerDevPixel
(
)
)
;
double
factor
=
cssPxPerDevPx
/
mFontSizeScaleFactor
;
double
adjustment
=
0
.
0
;
mLengthAdjustScaleFactor
=
1
.
0f
;
if
(
adjustingTextLength
)
{
nscoord
frameLength
=
vertical
?
PrincipalChildList
(
)
.
FirstChild
(
)
-
>
GetRect
(
)
.
height
:
PrincipalChildList
(
)
.
FirstChild
(
)
-
>
GetRect
(
)
.
width
;
float
actualTextLength
=
static_cast
<
float
>
(
presContext
-
>
AppUnitsToGfxUnits
(
frameLength
)
*
factor
)
;
switch
(
lengthAdjust
)
{
case
LENGTHADJUST_SPACINGANDGLYPHS
:
if
(
actualTextLength
>
0
)
{
mLengthAdjustScaleFactor
=
expectedTextLength
/
actualTextLength
;
}
break
;
default
:
MOZ_ASSERT
(
lengthAdjust
=
=
LENGTHADJUST_SPACING
)
;
int32_t
adjustableSpaces
=
0
;
for
(
uint32_t
i
=
1
;
i
<
mPositions
.
Length
(
)
;
i
+
+
)
{
if
(
!
mPositions
[
i
]
.
mUnaddressable
)
{
adjustableSpaces
+
+
;
}
}
if
(
adjustableSpaces
)
{
adjustment
=
(
expectedTextLength
-
actualTextLength
)
/
adjustableSpaces
;
}
break
;
}
}
if
(
!
deltas
.
IsEmpty
(
)
)
{
mPositions
[
0
]
.
mPosition
+
=
deltas
[
0
]
;
}
gfxFloat
xLengthAdjustFactor
=
vertical
?
1
.
0
:
mLengthAdjustScaleFactor
;
gfxFloat
yLengthAdjustFactor
=
vertical
?
mLengthAdjustScaleFactor
:
1
.
0
;
for
(
uint32_t
i
=
1
;
i
<
mPositions
.
Length
(
)
;
i
+
+
)
{
if
(
!
mPositions
[
i
]
.
IsXSpecified
(
)
)
{
nscoord
d
=
charPositions
[
i
]
.
x
-
charPositions
[
i
-
1
]
.
x
;
mPositions
[
i
]
.
mPosition
.
x
=
mPositions
[
i
-
1
]
.
mPosition
.
x
+
presContext
-
>
AppUnitsToGfxUnits
(
d
)
*
factor
*
xLengthAdjustFactor
;
if
(
!
vertical
&
&
!
mPositions
[
i
]
.
mUnaddressable
)
{
mPositions
[
i
]
.
mPosition
.
x
+
=
adjustment
;
}
}
if
(
!
mPositions
[
i
]
.
IsYSpecified
(
)
)
{
nscoord
d
=
charPositions
[
i
]
.
y
-
charPositions
[
i
-
1
]
.
y
;
mPositions
[
i
]
.
mPosition
.
y
=
mPositions
[
i
-
1
]
.
mPosition
.
y
+
presContext
-
>
AppUnitsToGfxUnits
(
d
)
*
factor
*
yLengthAdjustFactor
;
if
(
vertical
&
&
!
mPositions
[
i
]
.
mUnaddressable
)
{
mPositions
[
i
]
.
mPosition
.
y
+
=
adjustment
;
}
}
if
(
i
<
deltas
.
Length
(
)
)
{
mPositions
[
i
]
.
mPosition
+
=
deltas
[
i
]
;
}
if
(
!
mPositions
[
i
]
.
IsAngleSpecified
(
)
)
{
mPositions
[
i
]
.
mAngle
=
0
.
0f
;
}
}
MOZ_ASSERT
(
mPositions
.
Length
(
)
=
=
charPositions
.
Length
(
)
)
;
AdjustChunksForLineBreaks
(
)
;
AdjustPositionsForClusters
(
)
;
DoAnchoring
(
)
;
DoTextPathLayout
(
)
;
}
bool
SVGTextFrame
:
:
ShouldRenderAsPath
(
nsTextFrame
*
aFrame
bool
&
aShouldPaintSVGGlyphs
)
{
if
(
HasAnyStateBits
(
NS_STATE_SVG_CLIPPATH_CHILD
)
)
{
aShouldPaintSVGGlyphs
=
false
;
return
true
;
}
aShouldPaintSVGGlyphs
=
true
;
const
nsStyleSVG
*
style
=
aFrame
-
>
StyleSVG
(
)
;
if
(
!
(
style
-
>
mFill
.
kind
.
IsNone
(
)
|
|
(
style
-
>
mFill
.
kind
.
IsColor
(
)
&
&
SVGUtils
:
:
GetOpacity
(
style
-
>
mFillOpacity
nullptr
)
=
=
1
.
0f
)
)
)
{
return
true
;
}
if
(
style
-
>
mFill
.
kind
.
IsColor
(
)
&
&
aFrame
-
>
StyleText
(
)
-
>
HasTextShadow
(
)
&
&
NS_GET_A
(
style
-
>
mFill
.
kind
.
AsColor
(
)
.
CalcColor
(
*
aFrame
-
>
Style
(
)
)
)
!
=
0xFF
)
{
return
true
;
}
if
(
style
-
>
HasStroke
(
)
)
{
if
(
style
-
>
mStrokeWidth
.
IsContextValue
(
)
)
{
return
true
;
}
if
(
SVGContentUtils
:
:
CoordToFloat
(
static_cast
<
SVGElement
*
>
(
GetContent
(
)
)
style
-
>
mStrokeWidth
.
AsLengthPercentage
(
)
)
>
0
)
{
return
true
;
}
}
return
false
;
}
void
SVGTextFrame
:
:
ScheduleReflowSVG
(
)
{
if
(
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
)
{
ScheduleReflowSVGNonDisplayText
(
IntrinsicDirty
:
:
FrameAncestorsAndDescendants
)
;
}
else
{
SVGUtils
:
:
ScheduleReflowSVG
(
this
)
;
}
}
void
SVGTextFrame
:
:
NotifyGlyphMetricsChange
(
bool
aUpdateTextCorrespondence
)
{
if
(
aUpdateTextCorrespondence
)
{
AddStateBits
(
NS_STATE_SVG_TEXT_CORRESPONDENCE_DIRTY
)
;
}
AddStateBits
(
NS_STATE_SVG_POSITIONING_DIRTY
)
;
nsLayoutUtils
:
:
PostRestyleEvent
(
mContent
-
>
AsElement
(
)
RestyleHint
{
0
}
nsChangeHint_InvalidateRenderingObservers
)
;
ScheduleReflowSVG
(
)
;
}
void
SVGTextFrame
:
:
UpdateGlyphPositioning
(
)
{
nsIFrame
*
kid
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
!
kid
)
{
return
;
}
if
(
HasAnyStateBits
(
NS_STATE_SVG_POSITIONING_DIRTY
)
)
{
DoGlyphPositioning
(
)
;
}
}
void
SVGTextFrame
:
:
MaybeResolveBidiForAnonymousBlockChild
(
)
{
nsIFrame
*
kid
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
kid
&
&
kid
-
>
HasAnyStateBits
(
NS_BLOCK_NEEDS_BIDI_RESOLUTION
)
&
&
PresContext
(
)
-
>
BidiEnabled
(
)
)
{
MOZ_ASSERT
(
static_cast
<
nsBlockFrame
*
>
(
do_QueryFrame
(
kid
)
)
"
Expect
anonymous
child
to
be
an
nsBlockFrame
"
)
;
nsBidiPresUtils
:
:
Resolve
(
static_cast
<
nsBlockFrame
*
>
(
kid
)
)
;
}
}
void
SVGTextFrame
:
:
MaybeReflowAnonymousBlockChild
(
)
{
nsIFrame
*
kid
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
!
kid
)
{
return
;
}
NS_ASSERTION
(
!
kid
-
>
HasAnyStateBits
(
NS_FRAME_IN_REFLOW
)
"
should
not
be
in
reflow
when
about
to
reflow
again
"
)
;
if
(
IsSubtreeDirty
(
)
)
{
if
(
HasAnyStateBits
(
NS_FRAME_IS_DIRTY
)
)
{
kid
-
>
MarkSubtreeDirty
(
)
;
}
AddStateBits
(
NS_STATE_SVG_TEXT_IN_REFLOW
)
;
TextNodeCorrespondenceRecorder
:
:
RecordCorrespondence
(
this
)
;
MOZ_ASSERT
(
SVGUtils
:
:
AnyOuterSVGIsCallingReflowSVG
(
this
)
"
should
be
under
ReflowSVG
"
)
;
nsPresContext
:
:
InterruptPreventer
noInterrupts
(
PresContext
(
)
)
;
DoReflow
(
)
;
RemoveStateBits
(
NS_STATE_SVG_TEXT_IN_REFLOW
)
;
}
}
void
SVGTextFrame
:
:
DoReflow
(
)
{
MOZ_ASSERT
(
HasAnyStateBits
(
NS_STATE_SVG_TEXT_IN_REFLOW
)
)
;
AddStateBits
(
NS_STATE_SVG_TEXT_CORRESPONDENCE_DIRTY
|
NS_STATE_SVG_POSITIONING_DIRTY
)
;
if
(
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
)
{
RemoveStateBits
(
NS_FRAME_IS_DIRTY
|
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
}
nsPresContext
*
presContext
=
PresContext
(
)
;
nsIFrame
*
kid
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
!
kid
)
{
return
;
}
UniquePtr
<
gfxContext
>
renderingContext
=
presContext
-
>
PresShell
(
)
-
>
CreateReferenceRenderingContext
(
)
;
if
(
UpdateFontSizeScaleFactor
(
)
)
{
kid
-
>
MarkIntrinsicISizesDirty
(
)
;
}
nscoord
inlineSize
=
kid
-
>
GetPrefISize
(
renderingContext
.
get
(
)
)
;
WritingMode
wm
=
kid
-
>
GetWritingMode
(
)
;
ReflowInput
reflowInput
(
presContext
kid
renderingContext
.
get
(
)
LogicalSize
(
wm
inlineSize
NS_UNCONSTRAINEDSIZE
)
)
;
ReflowOutput
desiredSize
(
reflowInput
)
;
nsReflowStatus
status
;
NS_ASSERTION
(
reflowInput
.
ComputedPhysicalBorderPadding
(
)
=
=
nsMargin
(
0
0
0
0
)
&
&
reflowInput
.
ComputedPhysicalMargin
(
)
=
=
nsMargin
(
0
0
0
0
)
"
style
system
should
ensure
that
:
-
moz
-
svg
-
text
"
"
does
not
get
styled
"
)
;
kid
-
>
Reflow
(
presContext
desiredSize
reflowInput
status
)
;
kid
-
>
DidReflow
(
presContext
&
reflowInput
)
;
kid
-
>
SetSize
(
wm
desiredSize
.
Size
(
wm
)
)
;
}
#
define
CLAMP_MIN_SIZE
8
.
0
#
define
CLAMP_MAX_SIZE
200
.
0
#
define
PRECISE_SIZE
200
.
0
bool
SVGTextFrame
:
:
UpdateFontSizeScaleFactor
(
)
{
double
oldFontSizeScaleFactor
=
mFontSizeScaleFactor
;
nsPresContext
*
presContext
=
PresContext
(
)
;
bool
geometricPrecision
=
false
;
CSSCoord
min
=
std
:
:
numeric_limits
<
float
>
:
:
max
(
)
;
CSSCoord
max
=
std
:
:
numeric_limits
<
float
>
:
:
min
(
)
;
bool
anyText
=
false
;
TextFrameIterator
it
(
this
)
;
nsTextFrame
*
f
=
it
.
Current
(
)
;
while
(
f
)
{
if
(
!
geometricPrecision
)
{
geometricPrecision
=
f
-
>
StyleText
(
)
-
>
mTextRendering
=
=
StyleTextRendering
:
:
Geometricprecision
;
}
const
auto
&
fontSize
=
f
-
>
StyleFont
(
)
-
>
mFont
.
size
;
if
(
!
fontSize
.
IsZero
(
)
)
{
min
=
std
:
:
min
(
min
fontSize
.
ToCSSPixels
(
)
)
;
max
=
std
:
:
max
(
max
fontSize
.
ToCSSPixels
(
)
)
;
anyText
=
true
;
}
f
=
it
.
Next
(
)
;
}
if
(
!
anyText
)
{
mFontSizeScaleFactor
=
1
.
0
;
return
mFontSizeScaleFactor
!
=
oldFontSizeScaleFactor
;
}
if
(
geometricPrecision
)
{
mFontSizeScaleFactor
=
PRECISE_SIZE
/
min
;
return
mFontSizeScaleFactor
!
=
oldFontSizeScaleFactor
;
}
double
contextScale
=
1
.
0
;
if
(
!
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
)
{
gfxMatrix
m
(
GetCanvasTM
(
)
)
;
if
(
!
m
.
IsSingular
(
)
)
{
contextScale
=
GetContextScale
(
m
)
;
if
(
!
std
:
:
isfinite
(
contextScale
)
)
{
contextScale
=
1
.
0f
;
}
}
}
mLastContextScale
=
contextScale
;
float
cssPxPerDevPx
=
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
presContext
-
>
AppUnitsPerDevPixel
(
)
)
;
contextScale
*
=
cssPxPerDevPx
;
double
minTextRunSize
=
min
*
contextScale
;
double
maxTextRunSize
=
max
*
contextScale
;
if
(
minTextRunSize
>
=
CLAMP_MIN_SIZE
&
&
maxTextRunSize
<
=
CLAMP_MAX_SIZE
)
{
mFontSizeScaleFactor
=
contextScale
;
}
else
if
(
max
/
min
>
CLAMP_MAX_SIZE
/
CLAMP_MIN_SIZE
)
{
if
(
maxTextRunSize
<
=
CLAMP_MAX_SIZE
)
{
mFontSizeScaleFactor
=
CLAMP_MAX_SIZE
/
max
;
}
else
if
(
minTextRunSize
>
=
CLAMP_MIN_SIZE
)
{
mFontSizeScaleFactor
=
CLAMP_MIN_SIZE
/
min
;
}
else
{
mFontSizeScaleFactor
=
contextScale
;
}
}
else
if
(
minTextRunSize
<
CLAMP_MIN_SIZE
)
{
mFontSizeScaleFactor
=
CLAMP_MIN_SIZE
/
min
;
}
else
{
mFontSizeScaleFactor
=
CLAMP_MAX_SIZE
/
max
;
}
return
mFontSizeScaleFactor
!
=
oldFontSizeScaleFactor
;
}
double
SVGTextFrame
:
:
GetFontSizeScaleFactor
(
)
const
{
return
mFontSizeScaleFactor
;
}
Point
SVGTextFrame
:
:
TransformFramePointToTextChild
(
const
Point
&
aPoint
const
nsIFrame
*
aChildFrame
)
{
NS_ASSERTION
(
aChildFrame
&
&
nsLayoutUtils
:
:
GetClosestFrameOfType
(
aChildFrame
-
>
GetParent
(
)
LayoutFrameType
:
:
SVGText
)
=
=
this
"
aChildFrame
must
be
a
descendant
of
this
frame
"
)
;
UpdateGlyphPositioning
(
)
;
nsPresContext
*
presContext
=
PresContext
(
)
;
float
cssPxPerDevPx
=
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
presContext
-
>
AppUnitsPerDevPixel
(
)
)
;
float
factor
=
AppUnitsPerCSSPixel
(
)
;
Point
framePosition
(
NSAppUnitsToFloatPixels
(
mRect
.
x
factor
)
NSAppUnitsToFloatPixels
(
mRect
.
y
factor
)
)
;
Point
pointInUserSpace
=
aPoint
*
cssPxPerDevPx
+
framePosition
;
TextRenderedRunIterator
it
(
this
TextRenderedRunIterator
:
:
eAllFrames
aChildFrame
)
;
TextRenderedRun
hit
;
gfxPoint
pointInRun
;
nscoord
dx
=
nscoord_MAX
;
nscoord
dy
=
nscoord_MAX
;
for
(
TextRenderedRun
run
=
it
.
Current
(
)
;
run
.
mFrame
;
run
=
it
.
Next
(
)
)
{
uint32_t
flags
=
TextRenderedRun
:
:
eIncludeFill
|
TextRenderedRun
:
:
eIncludeStroke
|
TextRenderedRun
:
:
eNoHorizontalOverflow
;
gfxRect
runRect
=
run
.
GetRunUserSpaceRect
(
presContext
flags
)
.
ToThebesRect
(
)
;
gfxMatrix
m
=
run
.
GetTransformFromRunUserSpaceToUserSpace
(
presContext
)
;
if
(
!
m
.
Invert
(
)
)
{
return
aPoint
;
}
gfxPoint
pointInRunUserSpace
=
m
.
TransformPoint
(
ThebesPoint
(
pointInUserSpace
)
)
;
if
(
Inside
(
runRect
pointInRunUserSpace
)
)
{
dx
=
0
;
dy
=
0
;
pointInRun
=
pointInRunUserSpace
;
hit
=
run
;
}
else
if
(
nsLayoutUtils
:
:
PointIsCloserToRect
(
pointInRunUserSpace
runRect
dx
dy
)
)
{
pointInRun
.
x
=
clamped
(
pointInRunUserSpace
.
x
.
value
runRect
.
X
(
)
runRect
.
XMost
(
)
)
;
pointInRun
.
y
=
clamped
(
pointInRunUserSpace
.
y
.
value
runRect
.
Y
(
)
runRect
.
YMost
(
)
)
;
hit
=
run
;
}
}
if
(
!
hit
.
mFrame
)
{
return
aPoint
;
}
gfxMatrix
m
=
hit
.
GetTransformFromRunUserSpaceToFrameUserSpace
(
presContext
)
;
m
.
PreScale
(
mFontSizeScaleFactor
mFontSizeScaleFactor
)
;
return
ToPoint
(
m
.
TransformPoint
(
pointInRun
)
/
cssPxPerDevPx
)
;
}
gfxRect
SVGTextFrame
:
:
TransformFrameRectFromTextChild
(
const
nsRect
&
aRect
const
nsIFrame
*
aChildFrame
)
{
NS_ASSERTION
(
aChildFrame
&
&
nsLayoutUtils
:
:
GetClosestFrameOfType
(
aChildFrame
-
>
GetParent
(
)
LayoutFrameType
:
:
SVGText
)
=
=
this
"
aChildFrame
must
be
a
descendant
of
this
frame
"
)
;
UpdateGlyphPositioning
(
)
;
nsPresContext
*
presContext
=
PresContext
(
)
;
gfxRect
result
;
TextRenderedRunIterator
it
(
this
TextRenderedRunIterator
:
:
eAllFrames
aChildFrame
)
;
for
(
TextRenderedRun
run
=
it
.
Current
(
)
;
run
.
mFrame
;
run
=
it
.
Next
(
)
)
{
nsRect
rectInTextFrame
=
aRect
+
aChildFrame
-
>
GetOffsetTo
(
run
.
mFrame
)
;
gfxRect
rectInFrameUserSpace
=
AppUnitsToFloatCSSPixels
(
gfxRect
(
rectInTextFrame
.
x
rectInTextFrame
.
y
rectInTextFrame
.
width
rectInTextFrame
.
height
)
presContext
)
;
uint32_t
flags
=
TextRenderedRun
:
:
eIncludeFill
|
TextRenderedRun
:
:
eIncludeStroke
;
if
(
rectInFrameUserSpace
.
IntersectRect
(
rectInFrameUserSpace
run
.
GetFrameUserSpaceRect
(
presContext
flags
)
.
ToThebesRect
(
)
)
)
{
gfxMatrix
m
=
run
.
GetTransformFromRunUserSpaceToUserSpace
(
presContext
)
;
gfxRect
rectInUserSpace
=
m
.
TransformRect
(
rectInFrameUserSpace
)
;
result
.
UnionRect
(
result
rectInUserSpace
)
;
}
}
float
factor
=
AppUnitsPerCSSPixel
(
)
;
gfxPoint
framePosition
(
NSAppUnitsToFloatPixels
(
mRect
.
x
factor
)
NSAppUnitsToFloatPixels
(
mRect
.
y
factor
)
)
;
return
result
-
framePosition
;
}
Rect
SVGTextFrame
:
:
TransformFrameRectFromTextChild
(
const
Rect
&
aRect
const
nsIFrame
*
aChildFrame
)
{
nscoord
appUnitsPerDevPixel
=
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
nsRect
r
=
LayoutDevicePixel
:
:
ToAppUnits
(
LayoutDeviceRect
:
:
FromUnknownRect
(
aRect
)
appUnitsPerDevPixel
)
;
gfxRect
resultCssUnits
=
TransformFrameRectFromTextChild
(
r
aChildFrame
)
;
float
devPixelPerCSSPixel
=
float
(
AppUnitsPerCSSPixel
(
)
)
/
appUnitsPerDevPixel
;
resultCssUnits
.
Scale
(
devPixelPerCSSPixel
)
;
return
ToRect
(
resultCssUnits
)
;
}
Point
SVGTextFrame
:
:
TransformFramePointFromTextChild
(
const
Point
&
aPoint
const
nsIFrame
*
aChildFrame
)
{
return
TransformFrameRectFromTextChild
(
Rect
(
aPoint
Size
(
1
1
)
)
aChildFrame
)
.
TopLeft
(
)
;
}
void
SVGTextFrame
:
:
AppendDirectlyOwnedAnonBoxes
(
nsTArray
<
OwnedAnonBox
>
&
aResult
)
{
MOZ_ASSERT
(
PrincipalChildList
(
)
.
FirstChild
(
)
"
Must
have
our
anon
box
"
)
;
aResult
.
AppendElement
(
OwnedAnonBox
(
PrincipalChildList
(
)
.
FirstChild
(
)
)
)
;
}
}
