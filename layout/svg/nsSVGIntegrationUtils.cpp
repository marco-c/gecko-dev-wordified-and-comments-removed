#
include
"
nsSVGIntegrationUtils
.
h
"
#
include
"
gfxDrawable
.
h
"
#
include
"
nsCSSAnonBoxes
.
h
"
#
include
"
nsCSSClipPathInstance
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsFilterInstance
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsRenderingContext
.
h
"
#
include
"
nsSVGClipPathFrame
.
h
"
#
include
"
nsSVGEffects
.
h
"
#
include
"
nsSVGElement
.
h
"
#
include
"
nsSVGFilterPaintCallback
.
h
"
#
include
"
nsSVGMaskFrame
.
h
"
#
include
"
nsSVGPaintServerFrame
.
h
"
#
include
"
nsSVGUtils
.
h
"
#
include
"
FrameLayerBuilder
.
h
"
#
include
"
BasicLayers
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
nsCSSRendering
.
h
"
#
include
"
mozilla
/
unused
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
image
;
class
PreEffectsVisualOverflowCollector
:
public
nsLayoutUtils
:
:
BoxCallback
{
public
:
PreEffectsVisualOverflowCollector
(
nsIFrame
*
aFirstContinuation
nsIFrame
*
aCurrentFrame
const
nsRect
&
aCurrentFrameOverflowArea
)
:
mFirstContinuation
(
aFirstContinuation
)
mCurrentFrame
(
aCurrentFrame
)
mCurrentFrameOverflowArea
(
aCurrentFrameOverflowArea
)
{
NS_ASSERTION
(
!
mFirstContinuation
-
>
GetPrevContinuation
(
)
"
We
want
the
first
continuation
here
"
)
;
}
virtual
void
AddBox
(
nsIFrame
*
aFrame
)
override
{
nsRect
overflow
=
(
aFrame
=
=
mCurrentFrame
)
?
mCurrentFrameOverflowArea
:
GetPreEffectsVisualOverflowRect
(
aFrame
)
;
mResult
.
UnionRect
(
mResult
overflow
+
aFrame
-
>
GetOffsetTo
(
mFirstContinuation
)
)
;
}
nsRect
GetResult
(
)
const
{
return
mResult
;
}
private
:
static
nsRect
GetPreEffectsVisualOverflowRect
(
nsIFrame
*
aFrame
)
{
nsRect
*
r
=
aFrame
-
>
Properties
(
)
.
Get
(
nsIFrame
:
:
PreEffectsBBoxProperty
(
)
)
;
if
(
r
)
{
return
*
r
;
}
NS_ASSERTION
(
aFrame
-
>
GetParent
(
)
-
>
StyleContext
(
)
-
>
GetPseudo
(
)
=
=
nsCSSAnonBoxes
:
:
mozAnonymousBlock
"
How
did
we
getting
here
then
?
"
)
;
NS_ASSERTION
(
!
aFrame
-
>
Properties
(
)
.
Get
(
aFrame
-
>
PreTransformOverflowAreasProperty
(
)
)
"
GetVisualOverflowRect
(
)
won
'
t
return
the
pre
-
effects
rect
!
"
)
;
return
aFrame
-
>
GetVisualOverflowRect
(
)
;
}
nsIFrame
*
mFirstContinuation
;
nsIFrame
*
mCurrentFrame
;
const
nsRect
&
mCurrentFrameOverflowArea
;
nsRect
mResult
;
}
;
static
nsRect
GetPreEffectsVisualOverflowUnion
(
nsIFrame
*
aFirstContinuation
nsIFrame
*
aCurrentFrame
const
nsRect
&
aCurrentFramePreEffectsOverflow
const
nsPoint
&
aFirstContinuationToUserSpace
)
{
NS_ASSERTION
(
!
aFirstContinuation
-
>
GetPrevContinuation
(
)
"
Need
first
continuation
here
"
)
;
PreEffectsVisualOverflowCollector
collector
(
aFirstContinuation
aCurrentFrame
aCurrentFramePreEffectsOverflow
)
;
nsLayoutUtils
:
:
GetAllInFlowBoxes
(
aFirstContinuation
&
collector
)
;
return
collector
.
GetResult
(
)
+
aFirstContinuationToUserSpace
;
}
bool
nsSVGIntegrationUtils
:
:
UsingEffectsForFrame
(
const
nsIFrame
*
aFrame
)
{
const
nsStyleSVGReset
*
style
=
aFrame
-
>
StyleSVGReset
(
)
;
return
aFrame
-
>
StyleEffects
(
)
-
>
HasFilters
(
)
|
|
style
-
>
HasClipPath
(
)
|
|
style
-
>
mMask
.
HasLayerWithImage
(
)
;
}
static
nsPoint
GetOffsetToBoundingBox
(
nsIFrame
*
aFrame
)
{
if
(
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_SVG_LAYOUT
)
)
{
return
nsPoint
(
)
;
}
NS_ASSERTION
(
!
aFrame
-
>
GetPrevContinuation
(
)
"
Not
first
continuation
"
)
;
return
-
nsLayoutUtils
:
:
GetAllInFlowRectsUnion
(
aFrame
aFrame
)
.
TopLeft
(
)
;
}
nsSize
nsSVGIntegrationUtils
:
:
GetContinuationUnionSize
(
nsIFrame
*
aNonSVGFrame
)
{
NS_ASSERTION
(
!
aNonSVGFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
"
SVG
frames
should
not
get
here
"
)
;
nsIFrame
*
firstFrame
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
aNonSVGFrame
)
;
return
nsLayoutUtils
:
:
GetAllInFlowRectsUnion
(
firstFrame
firstFrame
)
.
Size
(
)
;
}
gfx
:
:
Size
nsSVGIntegrationUtils
:
:
GetSVGCoordContextForNonSVGFrame
(
nsIFrame
*
aNonSVGFrame
)
{
NS_ASSERTION
(
!
aNonSVGFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
"
SVG
frames
should
not
get
here
"
)
;
nsIFrame
*
firstFrame
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
aNonSVGFrame
)
;
nsRect
r
=
nsLayoutUtils
:
:
GetAllInFlowRectsUnion
(
firstFrame
firstFrame
)
;
nsPresContext
*
presContext
=
firstFrame
-
>
PresContext
(
)
;
return
gfx
:
:
Size
(
presContext
-
>
AppUnitsToFloatCSSPixels
(
r
.
width
)
presContext
-
>
AppUnitsToFloatCSSPixels
(
r
.
height
)
)
;
}
gfxRect
nsSVGIntegrationUtils
:
:
GetSVGBBoxForNonSVGFrame
(
nsIFrame
*
aNonSVGFrame
)
{
NS_ASSERTION
(
!
aNonSVGFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
"
SVG
frames
should
not
get
here
"
)
;
nsIFrame
*
firstFrame
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
aNonSVGFrame
)
;
nsRect
r
=
GetPreEffectsVisualOverflowUnion
(
firstFrame
nullptr
nsRect
(
)
GetOffsetToBoundingBox
(
firstFrame
)
)
;
return
nsLayoutUtils
:
:
RectToGfxRect
(
r
aNonSVGFrame
-
>
PresContext
(
)
-
>
AppUnitsPerCSSPixel
(
)
)
;
}
nsRect
nsSVGIntegrationUtils
:
:
ComputePostEffectsVisualOverflowRect
(
nsIFrame
*
aFrame
const
nsRect
&
aPreEffectsOverflowRect
)
{
NS_ASSERTION
(
!
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_SVG_LAYOUT
)
"
Don
'
t
call
this
on
SVG
child
frames
"
)
;
nsIFrame
*
firstFrame
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
aFrame
)
;
nsSVGEffects
:
:
EffectProperties
effectProperties
=
nsSVGEffects
:
:
GetEffectProperties
(
firstFrame
)
;
if
(
!
effectProperties
.
HasValidFilter
(
)
)
{
return
aPreEffectsOverflowRect
;
}
nsPoint
firstFrameToBoundingBox
=
GetOffsetToBoundingBox
(
firstFrame
)
;
gfxRect
overrideBBox
=
nsLayoutUtils
:
:
RectToGfxRect
(
GetPreEffectsVisualOverflowUnion
(
firstFrame
aFrame
aPreEffectsOverflowRect
firstFrameToBoundingBox
)
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerCSSPixel
(
)
)
;
overrideBBox
.
RoundOut
(
)
;
nsRect
overflowRect
=
nsFilterInstance
:
:
GetPostFilterBounds
(
firstFrame
&
overrideBBox
)
;
return
overflowRect
-
(
aFrame
-
>
GetOffsetTo
(
firstFrame
)
+
firstFrameToBoundingBox
)
;
}
nsIntRegion
nsSVGIntegrationUtils
:
:
AdjustInvalidAreaForSVGEffects
(
nsIFrame
*
aFrame
const
nsPoint
&
aToReferenceFrame
const
nsIntRegion
&
aInvalidRegion
)
{
if
(
aInvalidRegion
.
IsEmpty
(
)
)
{
return
nsIntRect
(
)
;
}
nsIFrame
*
firstFrame
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
aFrame
)
;
nsSVGFilterProperty
*
prop
=
nsSVGEffects
:
:
GetFilterProperty
(
firstFrame
)
;
if
(
!
prop
|
|
!
prop
-
>
IsInObserverLists
(
)
)
{
return
aInvalidRegion
;
}
int32_t
appUnitsPerDevPixel
=
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
if
(
!
prop
|
|
!
prop
-
>
ReferencesValidResources
(
)
)
{
nsRect
overflow
=
aFrame
-
>
GetVisualOverflowRect
(
)
+
aToReferenceFrame
;
return
overflow
.
ToOutsidePixels
(
appUnitsPerDevPixel
)
;
}
nsPoint
toBoundingBox
=
aFrame
-
>
GetOffsetTo
(
firstFrame
)
+
GetOffsetToBoundingBox
(
firstFrame
)
;
toBoundingBox
-
=
aToReferenceFrame
;
nsRegion
preEffectsRegion
=
aInvalidRegion
.
ToAppUnits
(
appUnitsPerDevPixel
)
.
MovedBy
(
toBoundingBox
)
;
nsRegion
result
=
nsFilterInstance
:
:
GetPostFilterDirtyArea
(
firstFrame
preEffectsRegion
)
.
MovedBy
(
-
toBoundingBox
)
;
return
result
.
ToOutsidePixels
(
appUnitsPerDevPixel
)
;
}
nsRect
nsSVGIntegrationUtils
:
:
GetRequiredSourceForInvalidArea
(
nsIFrame
*
aFrame
const
nsRect
&
aDirtyRect
)
{
nsIFrame
*
firstFrame
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
aFrame
)
;
nsSVGFilterProperty
*
prop
=
nsSVGEffects
:
:
GetFilterProperty
(
firstFrame
)
;
if
(
!
prop
|
|
!
prop
-
>
ReferencesValidResources
(
)
)
{
return
aDirtyRect
;
}
nsPoint
toUserSpace
=
aFrame
-
>
GetOffsetTo
(
firstFrame
)
+
GetOffsetToBoundingBox
(
firstFrame
)
;
nsRect
postEffectsRect
=
aDirtyRect
+
toUserSpace
;
return
nsFilterInstance
:
:
GetPreFilterNeededArea
(
firstFrame
postEffectsRect
)
.
GetBounds
(
)
-
toUserSpace
;
}
bool
nsSVGIntegrationUtils
:
:
HitTestFrameForEffects
(
nsIFrame
*
aFrame
const
nsPoint
&
aPt
)
{
nsIFrame
*
firstFrame
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
aFrame
)
;
nsPoint
toUserSpace
;
if
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_SVG_LAYOUT
)
{
toUserSpace
=
aFrame
-
>
GetPosition
(
)
;
}
else
{
toUserSpace
=
aFrame
-
>
GetOffsetTo
(
firstFrame
)
+
GetOffsetToBoundingBox
(
firstFrame
)
;
}
nsPoint
pt
=
aPt
+
toUserSpace
;
gfxPoint
userSpacePt
=
gfxPoint
(
pt
.
x
pt
.
y
)
/
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerCSSPixel
(
)
;
return
nsSVGUtils
:
:
HitTestClip
(
firstFrame
userSpacePt
)
;
}
class
RegularFramePaintCallback
:
public
nsSVGFilterPaintCallback
{
public
:
RegularFramePaintCallback
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
nsPoint
&
aOffset
)
:
mBuilder
(
aBuilder
)
mLayerManager
(
aManager
)
mOffset
(
aOffset
)
{
}
virtual
DrawResult
Paint
(
gfxContext
&
aContext
nsIFrame
*
aTarget
const
gfxMatrix
&
aTransform
const
nsIntRect
*
aDirtyRect
)
override
{
BasicLayerManager
*
basic
=
static_cast
<
BasicLayerManager
*
>
(
mLayerManager
)
;
basic
-
>
SetTarget
(
&
aContext
)
;
gfxPoint
devPixelOffset
=
nsLayoutUtils
:
:
PointToGfxPoint
(
-
mOffset
aTarget
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
gfxContextMatrixAutoSaveRestore
autoSR
(
&
aContext
)
;
aContext
.
SetMatrix
(
aContext
.
CurrentMatrix
(
)
.
Translate
(
devPixelOffset
)
)
;
mLayerManager
-
>
EndTransaction
(
FrameLayerBuilder
:
:
DrawPaintedLayer
mBuilder
)
;
return
DrawResult
:
:
SUCCESS
;
}
private
:
nsDisplayListBuilder
*
mBuilder
;
LayerManager
*
mLayerManager
;
nsPoint
mOffset
;
}
;
static
IntRect
ComputeMaskGeometry
(
const
nsSVGIntegrationUtils
:
:
PaintFramesParams
&
aParams
const
nsStyleSVGReset
*
svgReset
const
nsPoint
&
aOffsetToUserSpace
const
nsTArray
<
nsSVGMaskFrame
*
>
&
aMaskFrames
)
{
gfxContext
&
ctx
=
aParams
.
ctx
;
nsIFrame
*
frame
=
aParams
.
frame
;
int32_t
appUnitsPerDevPixel
=
frame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
nsRect
userSpaceBorderArea
=
aParams
.
borderArea
-
aOffsetToUserSpace
;
nsRect
userSpaceDirtyRect
=
aParams
.
dirtyRect
-
aOffsetToUserSpace
;
gfxRect
maskInUserSpace
;
for
(
size_t
i
=
0
;
i
<
aMaskFrames
.
Length
(
)
;
i
+
+
)
{
nsSVGMaskFrame
*
maskFrame
=
aMaskFrames
[
i
]
;
gfxRect
currentMaskSurfaceRect
;
if
(
maskFrame
)
{
currentMaskSurfaceRect
=
maskFrame
-
>
GetMaskArea
(
aParams
.
frame
)
;
}
else
{
nsCSSRendering
:
:
ImageLayerClipState
clipState
;
nsCSSRendering
:
:
GetImageLayerClip
(
svgReset
-
>
mMask
.
mLayers
[
i
]
frame
*
frame
-
>
StyleBorder
(
)
userSpaceBorderArea
userSpaceDirtyRect
false
appUnitsPerDevPixel
&
clipState
)
;
currentMaskSurfaceRect
=
clipState
.
mDirtyRectGfx
;
}
maskInUserSpace
=
maskInUserSpace
.
Union
(
currentMaskSurfaceRect
)
;
}
ctx
.
Save
(
)
;
gfxRect
frameVisualOverflowRect
=
nsLayoutUtils
:
:
RectToGfxRect
(
frame
-
>
GetVisualOverflowRectRelativeToSelf
(
)
appUnitsPerDevPixel
)
;
ctx
.
Clip
(
frameVisualOverflowRect
)
;
if
(
!
maskInUserSpace
.
IsEmpty
(
)
)
{
ctx
.
Clip
(
maskInUserSpace
)
;
}
ctx
.
SetMatrix
(
gfxMatrix
(
)
)
;
gfxRect
clippedFrameSurfaceRect
=
ctx
.
GetClipExtents
(
)
;
clippedFrameSurfaceRect
.
RoundOut
(
)
;
ctx
.
Restore
(
)
;
IntRect
result
;
ToRect
(
clippedFrameSurfaceRect
)
.
ToIntRect
(
&
result
)
;
return
mozilla
:
:
gfx
:
:
Factory
:
:
CheckSurfaceSize
(
result
.
Size
(
)
)
?
result
:
IntRect
(
)
;
}
static
DrawResult
GenerateMaskSurface
(
const
nsSVGIntegrationUtils
:
:
PaintFramesParams
&
aParams
float
aOpacity
nsStyleContext
*
aSC
const
nsTArray
<
nsSVGMaskFrame
*
>
&
aMaskFrames
const
nsPoint
&
aOffsetToUserSpace
Matrix
&
aOutMaskTransform
RefPtr
<
SourceSurface
>
&
aOutMaskSurface
)
{
const
nsStyleSVGReset
*
svgReset
=
aSC
-
>
StyleSVGReset
(
)
;
MOZ_ASSERT
(
aMaskFrames
.
Length
(
)
>
0
)
;
gfxMatrix
cssPxToDevPxMatrix
=
nsSVGIntegrationUtils
:
:
GetCSSPxToDevPxMatrix
(
aParams
.
frame
)
;
gfxContext
&
ctx
=
aParams
.
ctx
;
if
(
(
(
aMaskFrames
.
Length
(
)
=
=
1
)
&
&
aMaskFrames
[
0
]
)
)
{
aOutMaskSurface
=
aMaskFrames
[
0
]
-
>
GetMaskForMaskedFrame
(
&
ctx
aParams
.
frame
cssPxToDevPxMatrix
aOpacity
&
aOutMaskTransform
svgReset
-
>
mMask
.
mLayers
[
0
]
.
mMaskMode
)
;
return
DrawResult
:
:
SUCCESS
;
}
IntRect
maskSurfaceRect
=
ComputeMaskGeometry
(
aParams
svgReset
aOffsetToUserSpace
aMaskFrames
)
;
if
(
maskSurfaceRect
.
IsEmpty
(
)
)
{
return
DrawResult
:
:
SUCCESS
;
}
RefPtr
<
DrawTarget
>
maskDT
=
(
ctx
.
GetDrawTarget
(
)
-
>
GetBackendType
(
)
=
=
BackendType
:
:
COREGRAPHICS
|
|
ctx
.
GetDrawTarget
(
)
-
>
GetBackendType
(
)
=
=
BackendType
:
:
DIRECT2D1_1
)
?
Factory
:
:
CreateDrawTarget
(
BackendType
:
:
SKIA
maskSurfaceRect
.
Size
(
)
SurfaceFormat
:
:
A8
)
:
ctx
.
GetDrawTarget
(
)
-
>
CreateSimilarDrawTarget
(
maskSurfaceRect
.
Size
(
)
SurfaceFormat
:
:
A8
)
;
if
(
!
maskDT
|
|
!
maskDT
-
>
IsValid
(
)
)
{
return
DrawResult
:
:
TEMPORARY_ERROR
;
}
RefPtr
<
gfxContext
>
maskContext
=
gfxContext
:
:
CreateOrNull
(
maskDT
)
;
MOZ_ASSERT
(
maskContext
)
;
nsPresContext
*
presContext
=
aParams
.
frame
-
>
PresContext
(
)
;
gfxPoint
devPixelOffsetToUserSpace
=
nsLayoutUtils
:
:
PointToGfxPoint
(
aOffsetToUserSpace
presContext
-
>
AppUnitsPerDevPixel
(
)
)
;
gfxMatrix
maskSurfaceMatrix
=
ctx
.
CurrentMatrix
(
)
*
gfxMatrix
:
:
Translation
(
-
maskSurfaceRect
.
TopLeft
(
)
)
;
maskContext
-
>
SetMatrix
(
maskSurfaceMatrix
)
;
for
(
int
i
=
aMaskFrames
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
nsSVGMaskFrame
*
maskFrame
=
aMaskFrames
[
i
]
;
CompositionOp
compositionOp
=
(
i
=
=
int
(
aMaskFrames
.
Length
(
)
-
1
)
)
?
CompositionOp
:
:
OP_OVER
:
nsCSSRendering
:
:
GetGFXCompositeMode
(
svgReset
-
>
mMask
.
mLayers
[
i
]
.
mComposite
)
;
if
(
maskFrame
)
{
Matrix
svgMaskMatrix
;
RefPtr
<
SourceSurface
>
svgMask
=
maskFrame
-
>
GetMaskForMaskedFrame
(
maskContext
aParams
.
frame
cssPxToDevPxMatrix
aOpacity
&
svgMaskMatrix
svgReset
-
>
mMask
.
mLayers
[
i
]
.
mMaskMode
)
;
if
(
svgMask
)
{
gfxContextMatrixAutoSaveRestore
matRestore
(
maskContext
)
;
maskContext
-
>
Multiply
(
ThebesMatrix
(
svgMaskMatrix
)
)
;
Rect
drawRect
=
IntRectToRect
(
IntRect
(
IntPoint
(
0
0
)
svgMask
-
>
GetSize
(
)
)
)
;
maskDT
-
>
DrawSurface
(
svgMask
drawRect
drawRect
DrawSurfaceOptions
(
)
DrawOptions
(
1
.
0f
compositionOp
)
)
;
}
}
else
{
gfxContextMatrixAutoSaveRestore
matRestore
(
maskContext
)
;
maskContext
-
>
Multiply
(
gfxMatrix
:
:
Translation
(
-
devPixelOffsetToUserSpace
)
)
;
nsRenderingContext
rc
(
maskContext
)
;
nsCSSRendering
:
:
PaintBGParams
params
=
nsCSSRendering
:
:
PaintBGParams
:
:
ForSingleLayer
(
*
presContext
rc
aParams
.
dirtyRect
aParams
.
borderArea
aParams
.
frame
aParams
.
builder
-
>
GetBackgroundPaintFlags
(
)
|
nsCSSRendering
:
:
PAINTBG_MASK_IMAGE
i
compositionOp
)
;
DrawResult
result
=
nsCSSRendering
:
:
PaintBackgroundWithSC
(
params
aSC
*
aParams
.
frame
-
>
StyleBorder
(
)
)
;
if
(
result
!
=
DrawResult
:
:
SUCCESS
)
{
return
result
;
}
}
}
aOutMaskTransform
=
ToMatrix
(
maskSurfaceMatrix
)
;
if
(
!
aOutMaskTransform
.
Invert
(
)
)
{
return
DrawResult
:
:
SUCCESS
;
}
aOutMaskSurface
=
maskDT
-
>
Snapshot
(
)
;
return
DrawResult
:
:
SUCCESS
;
}
DrawResult
nsSVGIntegrationUtils
:
:
PaintFramesWithEffects
(
const
PaintFramesParams
&
aParams
)
{
#
ifdef
DEBUG
NS_ASSERTION
(
!
(
aParams
.
frame
-
>
GetStateBits
(
)
&
NS_FRAME_SVG_LAYOUT
)
|
|
(
NS_SVGDisplayListPaintingEnabled
(
)
&
&
!
(
aParams
.
frame
-
>
GetStateBits
(
)
&
NS_FRAME_IS_NONDISPLAY
)
)
"
Should
not
use
nsSVGIntegrationUtils
on
this
SVG
frame
"
)
;
#
endif
nsIFrame
*
frame
=
aParams
.
frame
;
const
nsIContent
*
content
=
frame
-
>
GetContent
(
)
;
bool
hasSVGLayout
=
(
frame
-
>
GetStateBits
(
)
&
NS_FRAME_SVG_LAYOUT
)
;
if
(
hasSVGLayout
)
{
nsISVGChildFrame
*
svgChildFrame
=
do_QueryFrame
(
frame
)
;
if
(
!
svgChildFrame
|
|
!
frame
-
>
GetContent
(
)
-
>
IsSVGElement
(
)
)
{
NS_ASSERTION
(
false
"
why
?
"
)
;
return
DrawResult
:
:
BAD_ARGS
;
}
if
(
!
static_cast
<
const
nsSVGElement
*
>
(
content
)
-
>
HasValidDimensions
(
)
)
{
return
DrawResult
:
:
SUCCESS
;
}
}
float
opacity
=
frame
-
>
StyleEffects
(
)
-
>
mOpacity
;
if
(
opacity
!
=
1
.
0f
&
&
(
nsSVGUtils
:
:
CanOptimizeOpacity
(
frame
)
|
|
aParams
.
callerPaintsOpacity
)
)
{
opacity
=
1
.
0f
;
}
if
(
opacity
=
=
0
.
0f
)
{
return
DrawResult
:
:
SUCCESS
;
}
MOZ_ASSERT
(
!
nsSVGUtils
:
:
CanOptimizeOpacity
(
frame
)
|
|
!
aParams
.
callerPaintsOpacity
"
How
can
we
be
optimizing
the
opacity
into
the
svg
as
well
as
having
the
caller
paint
it
?
"
)
;
nsIFrame
*
firstFrame
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
frame
)
;
nsSVGEffects
:
:
EffectProperties
effectProperties
=
nsSVGEffects
:
:
GetEffectProperties
(
firstFrame
)
;
bool
isOK
=
effectProperties
.
HasNoFilterOrHasValidFilter
(
)
;
nsSVGClipPathFrame
*
clipPathFrame
=
effectProperties
.
GetClipPathFrame
(
&
isOK
)
;
bool
isTrivialClip
=
clipPathFrame
?
clipPathFrame
-
>
IsTrivial
(
)
:
true
;
gfxContext
&
context
=
aParams
.
ctx
;
DrawTarget
*
drawTarget
=
context
.
GetDrawTarget
(
)
;
gfxContextMatrixAutoSaveRestore
matrixAutoSaveRestore
(
&
context
)
;
nsPoint
firstFrameOffset
=
GetOffsetToBoundingBox
(
firstFrame
)
;
nsPoint
offsetToBoundingBox
=
aParams
.
builder
-
>
ToReferenceFrame
(
firstFrame
)
-
firstFrameOffset
;
if
(
!
firstFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
)
{
offsetToBoundingBox
=
nsPoint
(
frame
-
>
PresContext
(
)
-
>
RoundAppUnitsToNearestDevPixels
(
offsetToBoundingBox
.
x
)
frame
-
>
PresContext
(
)
-
>
RoundAppUnitsToNearestDevPixels
(
offsetToBoundingBox
.
y
)
)
;
}
gfxPoint
toUserSpaceGfx
=
nsSVGUtils
:
:
FrameSpaceInCSSPxToUserSpaceOffset
(
frame
)
;
nsPoint
toUserSpace
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
float
(
toUserSpaceGfx
.
x
)
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
float
(
toUserSpaceGfx
.
y
)
)
)
;
nsPoint
offsetToUserSpace
=
offsetToBoundingBox
-
toUserSpace
;
NS_ASSERTION
(
hasSVGLayout
|
|
offsetToBoundingBox
=
=
offsetToUserSpace
"
For
non
-
SVG
frames
there
shouldn
'
t
be
any
additional
offset
"
)
;
gfxPoint
devPixelOffsetToUserSpace
=
nsLayoutUtils
:
:
PointToGfxPoint
(
offsetToUserSpace
frame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
context
.
SetMatrix
(
context
.
CurrentMatrix
(
)
.
Translate
(
devPixelOffsetToUserSpace
)
)
;
gfxMatrix
cssPxToDevPxMatrix
=
GetCSSPxToDevPxMatrix
(
frame
)
;
const
nsStyleSVGReset
*
svgReset
=
firstFrame
-
>
StyleSVGReset
(
)
;
nsTArray
<
nsSVGMaskFrame
*
>
maskFrames
=
effectProperties
.
GetMaskFrames
(
)
;
bool
shouldGenerateMaskLayer
=
hasSVGLayout
?
maskFrames
.
Length
(
)
=
=
1
&
&
maskFrames
[
0
]
:
maskFrames
.
Length
(
)
>
0
;
RefPtr
<
gfxContext
>
target
=
&
aParams
.
ctx
;
IntPoint
targetOffset
;
bool
complexEffects
=
false
;
DrawResult
result
=
DrawResult
:
:
SUCCESS
;
if
(
opacity
!
=
1
.
0f
|
|
(
clipPathFrame
&
&
!
isTrivialClip
)
|
|
frame
-
>
StyleEffects
(
)
-
>
mMixBlendMode
!
=
NS_STYLE_BLEND_NORMAL
|
|
shouldGenerateMaskLayer
)
{
complexEffects
=
true
;
context
.
Save
(
)
;
nsRect
clipRect
=
frame
-
>
GetVisualOverflowRectRelativeToSelf
(
)
+
toUserSpace
;
context
.
Clip
(
NSRectToSnappedRect
(
clipRect
frame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
*
drawTarget
)
)
;
Matrix
maskTransform
;
RefPtr
<
SourceSurface
>
maskSurface
;
if
(
shouldGenerateMaskLayer
)
{
result
=
GenerateMaskSurface
(
aParams
opacity
firstFrame
-
>
StyleContext
(
)
maskFrames
offsetToUserSpace
maskTransform
maskSurface
)
;
}
if
(
shouldGenerateMaskLayer
&
&
!
maskSurface
)
{
context
.
Restore
(
)
;
return
result
;
}
if
(
frame
-
>
StyleEffects
(
)
-
>
mMixBlendMode
!
=
NS_STYLE_BLEND_NORMAL
)
{
gfxRect
clipRect
;
{
gfxContextMatrixAutoSaveRestore
matRestore
(
&
context
)
;
context
.
SetMatrix
(
gfxMatrix
(
)
)
;
clipRect
=
context
.
GetClipExtents
(
)
;
}
IntRect
drawRect
=
RoundedOut
(
ToRect
(
clipRect
)
)
;
RefPtr
<
DrawTarget
>
targetDT
=
context
.
GetDrawTarget
(
)
-
>
CreateSimilarDrawTarget
(
drawRect
.
Size
(
)
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
!
targetDT
|
|
!
targetDT
-
>
IsValid
(
)
)
{
context
.
Restore
(
)
;
return
result
;
}
target
=
gfxContext
:
:
CreateOrNull
(
targetDT
)
;
MOZ_ASSERT
(
target
)
;
target
-
>
SetMatrix
(
context
.
CurrentMatrix
(
)
*
gfxMatrix
:
:
Translation
(
-
drawRect
.
TopLeft
(
)
)
)
;
targetOffset
=
drawRect
.
TopLeft
(
)
;
}
if
(
clipPathFrame
&
&
!
isTrivialClip
)
{
Matrix
clippedMaskTransform
;
RefPtr
<
SourceSurface
>
clipMaskSurface
=
clipPathFrame
-
>
GetClipMask
(
context
frame
cssPxToDevPxMatrix
&
clippedMaskTransform
maskSurface
maskTransform
&
result
)
;
if
(
clipMaskSurface
)
{
maskSurface
=
clipMaskSurface
;
maskTransform
=
clippedMaskTransform
;
}
}
if
(
opacity
!
=
1
.
0f
|
|
shouldGenerateMaskLayer
|
|
(
clipPathFrame
&
&
!
isTrivialClip
)
)
{
target
-
>
PushGroupForBlendBack
(
gfxContentType
:
:
COLOR_ALPHA
opacity
maskSurface
maskTransform
)
;
}
}
if
(
clipPathFrame
&
&
isTrivialClip
)
{
context
.
Save
(
)
;
clipPathFrame
-
>
ApplyClipPath
(
context
frame
cssPxToDevPxMatrix
)
;
}
else
if
(
!
clipPathFrame
&
&
svgReset
-
>
HasClipPath
(
)
)
{
context
.
Save
(
)
;
nsCSSClipPathInstance
:
:
ApplyBasicShapeClip
(
context
frame
)
;
}
if
(
effectProperties
.
HasValidFilter
(
)
&
&
!
aParams
.
builder
-
>
IsForGenerateGlyphMask
(
)
)
{
RegularFramePaintCallback
callback
(
aParams
.
builder
aParams
.
layerManager
offsetToUserSpace
)
;
nsRegion
dirtyRegion
=
aParams
.
dirtyRect
-
offsetToBoundingBox
;
gfxMatrix
tm
=
nsSVGIntegrationUtils
:
:
GetCSSPxToDevPxMatrix
(
frame
)
;
nsFilterInstance
:
:
PaintFilteredFrame
(
frame
target
-
>
GetDrawTarget
(
)
tm
&
callback
&
dirtyRegion
)
;
}
else
{
target
-
>
SetMatrix
(
matrixAutoSaveRestore
.
Matrix
(
)
)
;
BasicLayerManager
*
basic
=
static_cast
<
BasicLayerManager
*
>
(
aParams
.
layerManager
)
;
RefPtr
<
gfxContext
>
oldCtx
=
basic
-
>
GetTarget
(
)
;
basic
-
>
SetTarget
(
target
)
;
aParams
.
layerManager
-
>
EndTransaction
(
FrameLayerBuilder
:
:
DrawPaintedLayer
aParams
.
builder
)
;
basic
-
>
SetTarget
(
oldCtx
)
;
}
if
(
(
clipPathFrame
&
&
isTrivialClip
)
|
|
(
!
clipPathFrame
&
&
svgReset
-
>
HasClipPath
(
)
)
)
{
context
.
Restore
(
)
;
}
if
(
!
complexEffects
)
{
return
result
;
}
if
(
opacity
!
=
1
.
0f
|
|
shouldGenerateMaskLayer
|
|
(
clipPathFrame
&
&
!
isTrivialClip
)
)
{
target
-
>
PopGroupAndBlend
(
)
;
}
if
(
frame
-
>
StyleEffects
(
)
-
>
mMixBlendMode
!
=
NS_STYLE_BLEND_NORMAL
)
{
RefPtr
<
DrawTarget
>
targetDT
=
target
-
>
GetDrawTarget
(
)
;
target
=
nullptr
;
RefPtr
<
SourceSurface
>
targetSurf
=
targetDT
-
>
Snapshot
(
)
;
context
.
SetMatrix
(
gfxMatrix
(
)
)
;
RefPtr
<
gfxPattern
>
pattern
=
new
gfxPattern
(
targetSurf
Matrix
:
:
Translation
(
targetOffset
.
x
targetOffset
.
y
)
)
;
context
.
SetPattern
(
pattern
)
;
context
.
Paint
(
)
;
}
context
.
Restore
(
)
;
return
result
;
}
gfxMatrix
nsSVGIntegrationUtils
:
:
GetCSSPxToDevPxMatrix
(
nsIFrame
*
aNonSVGFrame
)
{
int32_t
appUnitsPerDevPixel
=
aNonSVGFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
float
devPxPerCSSPx
=
1
/
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
appUnitsPerDevPixel
)
;
return
gfxMatrix
(
devPxPerCSSPx
0
.
0
0
.
0
devPxPerCSSPx
0
.
0
0
.
0
)
;
}
class
PaintFrameCallback
:
public
gfxDrawingCallback
{
public
:
PaintFrameCallback
(
nsIFrame
*
aFrame
const
nsSize
aPaintServerSize
const
IntSize
aRenderSize
uint32_t
aFlags
)
:
mFrame
(
aFrame
)
mPaintServerSize
(
aPaintServerSize
)
mRenderSize
(
aRenderSize
)
mFlags
(
aFlags
)
{
}
virtual
bool
operator
(
)
(
gfxContext
*
aContext
const
gfxRect
&
aFillRect
const
SamplingFilter
aSamplingFilter
const
gfxMatrix
&
aTransform
)
override
;
private
:
nsIFrame
*
mFrame
;
nsSize
mPaintServerSize
;
IntSize
mRenderSize
;
uint32_t
mFlags
;
}
;
bool
PaintFrameCallback
:
:
operator
(
)
(
gfxContext
*
aContext
const
gfxRect
&
aFillRect
const
SamplingFilter
aSamplingFilter
const
gfxMatrix
&
aTransform
)
{
if
(
mFrame
-
>
GetStateBits
(
)
&
NS_FRAME_DRAWING_AS_PAINTSERVER
)
return
false
;
mFrame
-
>
AddStateBits
(
NS_FRAME_DRAWING_AS_PAINTSERVER
)
;
aContext
-
>
Save
(
)
;
aContext
-
>
NewPath
(
)
;
aContext
-
>
Rectangle
(
aFillRect
)
;
aContext
-
>
Clip
(
)
;
gfxMatrix
invmatrix
=
aTransform
;
if
(
!
invmatrix
.
Invert
(
)
)
{
return
false
;
}
aContext
-
>
Multiply
(
invmatrix
)
;
int32_t
appUnitsPerDevPixel
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
nsPoint
offset
=
GetOffsetToBoundingBox
(
mFrame
)
;
gfxPoint
devPxOffset
=
gfxPoint
(
offset
.
x
offset
.
y
)
/
appUnitsPerDevPixel
;
aContext
-
>
Multiply
(
gfxMatrix
:
:
Translation
(
devPxOffset
)
)
;
gfxSize
paintServerSize
=
gfxSize
(
mPaintServerSize
.
width
mPaintServerSize
.
height
)
/
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
gfxFloat
scaleX
=
mRenderSize
.
width
/
paintServerSize
.
width
;
gfxFloat
scaleY
=
mRenderSize
.
height
/
paintServerSize
.
height
;
aContext
-
>
Multiply
(
gfxMatrix
:
:
Scaling
(
scaleX
scaleY
)
)
;
nsRect
dirty
(
-
offset
.
x
-
offset
.
y
mPaintServerSize
.
width
mPaintServerSize
.
height
)
;
using
PaintFrameFlags
=
nsLayoutUtils
:
:
PaintFrameFlags
;
PaintFrameFlags
flags
=
PaintFrameFlags
:
:
PAINT_IN_TRANSFORM
;
if
(
mFlags
&
nsSVGIntegrationUtils
:
:
FLAG_SYNC_DECODE_IMAGES
)
{
flags
|
=
PaintFrameFlags
:
:
PAINT_SYNC_DECODE_IMAGES
;
}
nsRenderingContext
context
(
aContext
)
;
nsLayoutUtils
:
:
PaintFrame
(
&
context
mFrame
dirty
NS_RGBA
(
0
0
0
0
)
nsDisplayListBuilderMode
:
:
PAINTING
flags
)
;
nsIFrame
*
currentFrame
=
mFrame
;
while
(
(
currentFrame
=
currentFrame
-
>
GetNextContinuation
(
)
)
!
=
nullptr
)
{
offset
=
currentFrame
-
>
GetOffsetToCrossDoc
(
mFrame
)
;
devPxOffset
=
gfxPoint
(
offset
.
x
offset
.
y
)
/
appUnitsPerDevPixel
;
aContext
-
>
Save
(
)
;
aContext
-
>
Multiply
(
gfxMatrix
:
:
Scaling
(
1
/
scaleX
1
/
scaleY
)
)
;
aContext
-
>
Multiply
(
gfxMatrix
:
:
Translation
(
devPxOffset
)
)
;
aContext
-
>
Multiply
(
gfxMatrix
:
:
Scaling
(
scaleX
scaleY
)
)
;
nsLayoutUtils
:
:
PaintFrame
(
&
context
currentFrame
dirty
-
offset
NS_RGBA
(
0
0
0
0
)
nsDisplayListBuilderMode
:
:
PAINTING
flags
)
;
aContext
-
>
Restore
(
)
;
}
aContext
-
>
Restore
(
)
;
mFrame
-
>
RemoveStateBits
(
NS_FRAME_DRAWING_AS_PAINTSERVER
)
;
return
true
;
}
already_AddRefed
<
gfxDrawable
>
nsSVGIntegrationUtils
:
:
DrawableFromPaintServer
(
nsIFrame
*
aFrame
nsIFrame
*
aTarget
const
nsSize
&
aPaintServerSize
const
IntSize
&
aRenderSize
const
DrawTarget
*
aDrawTarget
const
gfxMatrix
&
aContextMatrix
uint32_t
aFlags
)
{
if
(
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVGPaintServer
)
)
{
nsSVGPaintServerFrame
*
server
=
static_cast
<
nsSVGPaintServerFrame
*
>
(
aFrame
)
;
gfxRect
overrideBounds
(
0
0
aPaintServerSize
.
width
aPaintServerSize
.
height
)
;
overrideBounds
.
ScaleInverse
(
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
RefPtr
<
gfxPattern
>
pattern
=
server
-
>
GetPaintServerPattern
(
aTarget
aDrawTarget
aContextMatrix
&
nsStyleSVG
:
:
mFill
1
.
0
&
overrideBounds
)
;
if
(
!
pattern
)
return
nullptr
;
gfxFloat
scaleX
=
overrideBounds
.
Width
(
)
/
aRenderSize
.
width
;
gfxFloat
scaleY
=
overrideBounds
.
Height
(
)
/
aRenderSize
.
height
;
gfxMatrix
scaleMatrix
=
gfxMatrix
:
:
Scaling
(
scaleX
scaleY
)
;
pattern
-
>
SetMatrix
(
scaleMatrix
*
pattern
-
>
GetMatrix
(
)
)
;
RefPtr
<
gfxDrawable
>
drawable
=
new
gfxPatternDrawable
(
pattern
aRenderSize
)
;
return
drawable
.
forget
(
)
;
}
RefPtr
<
gfxDrawingCallback
>
cb
=
new
PaintFrameCallback
(
aFrame
aPaintServerSize
aRenderSize
aFlags
)
;
RefPtr
<
gfxDrawable
>
drawable
=
new
gfxCallbackDrawable
(
cb
aRenderSize
)
;
return
drawable
.
forget
(
)
;
}
