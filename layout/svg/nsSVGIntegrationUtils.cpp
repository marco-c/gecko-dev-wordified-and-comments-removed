#
include
"
nsSVGIntegrationUtils
.
h
"
#
include
"
gfxDrawable
.
h
"
#
include
"
nsCSSAnonBoxes
.
h
"
#
include
"
nsCSSClipPathInstance
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsFilterInstance
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
nsSVGClipPathFrame
.
h
"
#
include
"
SVGObserverUtils
.
h
"
#
include
"
SVGElement
.
h
"
#
include
"
nsSVGFilterPaintCallback
.
h
"
#
include
"
nsSVGMaskFrame
.
h
"
#
include
"
nsSVGPaintServerFrame
.
h
"
#
include
"
nsSVGUtils
.
h
"
#
include
"
FrameLayerBuilder
.
h
"
#
include
"
BasicLayers
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
nsCSSRendering
.
h
"
#
include
"
mozilla
/
StaticPrefs_layers
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
image
;
class
PreEffectsVisualOverflowCollector
:
public
nsLayoutUtils
:
:
BoxCallback
{
public
:
PreEffectsVisualOverflowCollector
(
nsIFrame
*
aFirstContinuation
nsIFrame
*
aCurrentFrame
const
nsRect
&
aCurrentFrameOverflowArea
bool
aInReflow
)
:
mFirstContinuation
(
aFirstContinuation
)
mCurrentFrame
(
aCurrentFrame
)
mCurrentFrameOverflowArea
(
aCurrentFrameOverflowArea
)
mInReflow
(
aInReflow
)
{
NS_ASSERTION
(
!
mFirstContinuation
-
>
GetPrevContinuation
(
)
"
We
want
the
first
continuation
here
"
)
;
}
virtual
void
AddBox
(
nsIFrame
*
aFrame
)
override
{
nsRect
overflow
=
(
aFrame
=
=
mCurrentFrame
)
?
mCurrentFrameOverflowArea
:
GetPreEffectsVisualOverflowRect
(
aFrame
mInReflow
)
;
mResult
.
UnionRect
(
mResult
overflow
+
aFrame
-
>
GetOffsetTo
(
mFirstContinuation
)
)
;
}
nsRect
GetResult
(
)
const
{
return
mResult
;
}
private
:
static
nsRect
GetPreEffectsVisualOverflowRect
(
nsIFrame
*
aFrame
bool
aInReflow
)
{
nsRect
*
r
=
aFrame
-
>
GetProperty
(
nsIFrame
:
:
PreEffectsBBoxProperty
(
)
)
;
if
(
r
)
{
return
*
r
;
}
#
ifdef
DEBUG
if
(
nsSVGIntegrationUtils
:
:
UsingOverflowAffectingEffects
(
aFrame
)
&
&
!
aInReflow
)
{
nsOverflowAreas
*
preTransformOverflows
=
aFrame
-
>
GetProperty
(
nsIFrame
:
:
PreTransformOverflowAreasProperty
(
)
)
;
MOZ_ASSERT
(
!
preTransformOverflows
"
GetVisualOverflowRect
(
)
won
'
t
return
the
pre
-
effects
rect
!
"
)
;
}
#
endif
return
aFrame
-
>
GetVisualOverflowRectRelativeToSelf
(
)
;
}
nsIFrame
*
mFirstContinuation
;
nsIFrame
*
mCurrentFrame
;
const
nsRect
&
mCurrentFrameOverflowArea
;
nsRect
mResult
;
bool
mInReflow
;
}
;
static
nsRect
GetPreEffectsVisualOverflowUnion
(
nsIFrame
*
aFirstContinuation
nsIFrame
*
aCurrentFrame
const
nsRect
&
aCurrentFramePreEffectsOverflow
const
nsPoint
&
aFirstContinuationToUserSpace
bool
aInReflow
)
{
NS_ASSERTION
(
!
aFirstContinuation
-
>
GetPrevContinuation
(
)
"
Need
first
continuation
here
"
)
;
PreEffectsVisualOverflowCollector
collector
(
aFirstContinuation
aCurrentFrame
aCurrentFramePreEffectsOverflow
aInReflow
)
;
nsLayoutUtils
:
:
GetAllInFlowBoxes
(
aFirstContinuation
&
collector
)
;
return
collector
.
GetResult
(
)
+
aFirstContinuationToUserSpace
;
}
static
nsRect
GetPreEffectsVisualOverflow
(
nsIFrame
*
aFirstContinuation
nsIFrame
*
aCurrentFrame
const
nsPoint
&
aFirstContinuationToUserSpace
)
{
NS_ASSERTION
(
!
aFirstContinuation
-
>
GetPrevContinuation
(
)
"
Need
first
continuation
here
"
)
;
PreEffectsVisualOverflowCollector
collector
(
aFirstContinuation
nullptr
nsRect
(
)
false
)
;
nsLayoutUtils
:
:
AddBoxesForFrame
(
aCurrentFrame
&
collector
)
;
return
collector
.
GetResult
(
)
+
aFirstContinuationToUserSpace
;
}
bool
nsSVGIntegrationUtils
:
:
UsingOverflowAffectingEffects
(
const
nsIFrame
*
aFrame
)
{
return
aFrame
-
>
StyleEffects
(
)
-
>
HasFilters
(
)
;
}
bool
nsSVGIntegrationUtils
:
:
UsingEffectsForFrame
(
const
nsIFrame
*
aFrame
)
{
const
nsStyleSVGReset
*
style
=
aFrame
-
>
StyleSVGReset
(
)
;
const
nsStyleEffects
*
effects
=
aFrame
-
>
StyleEffects
(
)
;
return
effects
-
>
HasFilters
(
)
|
|
effects
-
>
HasBackdropFilters
(
)
|
|
style
-
>
HasClipPath
(
)
|
|
style
-
>
HasMask
(
)
;
}
bool
nsSVGIntegrationUtils
:
:
UsingMaskOrClipPathForFrame
(
const
nsIFrame
*
aFrame
)
{
const
nsStyleSVGReset
*
style
=
aFrame
-
>
StyleSVGReset
(
)
;
return
style
-
>
HasClipPath
(
)
|
|
style
-
>
HasMask
(
)
;
}
bool
nsSVGIntegrationUtils
:
:
UsingSimpleClipPathForFrame
(
const
nsIFrame
*
aFrame
)
{
const
nsStyleSVGReset
*
style
=
aFrame
-
>
StyleSVGReset
(
)
;
if
(
!
style
-
>
HasClipPath
(
)
|
|
style
-
>
HasMask
(
)
)
{
return
false
;
}
const
auto
&
clipPath
=
style
-
>
mClipPath
;
if
(
clipPath
.
GetType
(
)
!
=
StyleShapeSourceType
:
:
Shape
)
{
return
false
;
}
const
auto
&
shape
=
clipPath
.
BasicShape
(
)
;
return
!
shape
.
IsPolygon
(
)
;
}
nsPoint
nsSVGIntegrationUtils
:
:
GetOffsetToBoundingBox
(
nsIFrame
*
aFrame
)
{
if
(
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_SVG_LAYOUT
)
)
{
return
nsPoint
(
)
;
}
return
-
nsLayoutUtils
:
:
GetAllInFlowRectsUnion
(
aFrame
aFrame
)
.
TopLeft
(
)
;
}
nsSize
nsSVGIntegrationUtils
:
:
GetContinuationUnionSize
(
nsIFrame
*
aNonSVGFrame
)
{
NS_ASSERTION
(
!
aNonSVGFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
"
SVG
frames
should
not
get
here
"
)
;
nsIFrame
*
firstFrame
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
aNonSVGFrame
)
;
return
nsLayoutUtils
:
:
GetAllInFlowRectsUnion
(
firstFrame
firstFrame
)
.
Size
(
)
;
}
gfx
:
:
Size
nsSVGIntegrationUtils
:
:
GetSVGCoordContextForNonSVGFrame
(
nsIFrame
*
aNonSVGFrame
)
{
NS_ASSERTION
(
!
aNonSVGFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
"
SVG
frames
should
not
get
here
"
)
;
nsIFrame
*
firstFrame
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
aNonSVGFrame
)
;
nsRect
r
=
nsLayoutUtils
:
:
GetAllInFlowRectsUnion
(
firstFrame
firstFrame
)
;
return
gfx
:
:
Size
(
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
r
.
width
)
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
r
.
height
)
)
;
}
gfxRect
nsSVGIntegrationUtils
:
:
GetSVGBBoxForNonSVGFrame
(
nsIFrame
*
aNonSVGFrame
bool
aUnionContinuations
)
{
NS_ASSERTION
(
!
(
aNonSVGFrame
-
>
GetStateBits
(
)
&
NS_FRAME_SVG_LAYOUT
)
"
Frames
with
SVG
layout
should
not
get
here
"
)
;
MOZ_ASSERT
(
!
aNonSVGFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
|
|
aNonSVGFrame
-
>
IsSVGOuterSVGFrame
(
)
)
;
nsIFrame
*
firstFrame
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
aNonSVGFrame
)
;
nsRect
r
=
(
aUnionContinuations
)
?
GetPreEffectsVisualOverflowUnion
(
firstFrame
nullptr
nsRect
(
)
GetOffsetToBoundingBox
(
firstFrame
)
false
)
:
GetPreEffectsVisualOverflow
(
firstFrame
aNonSVGFrame
GetOffsetToBoundingBox
(
firstFrame
)
)
;
return
nsLayoutUtils
:
:
RectToGfxRect
(
r
AppUnitsPerCSSPixel
(
)
)
;
}
nsRect
nsSVGIntegrationUtils
:
:
ComputePostEffectsVisualOverflowRect
(
nsIFrame
*
aFrame
const
nsRect
&
aPreEffectsOverflowRect
)
{
MOZ_ASSERT
(
!
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_SVG_LAYOUT
)
"
Don
'
t
call
this
on
SVG
child
frames
"
)
;
MOZ_ASSERT
(
aFrame
-
>
StyleEffects
(
)
-
>
HasFilters
(
)
"
We
should
only
be
called
if
the
frame
is
filtered
since
filters
"
"
are
the
only
effect
that
affects
overflow
.
"
)
;
nsIFrame
*
firstFrame
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
aFrame
)
;
if
(
SVGObserverUtils
:
:
GetAndObserveFilters
(
firstFrame
nullptr
)
=
=
SVGObserverUtils
:
:
eHasRefsSomeInvalid
)
{
return
aPreEffectsOverflowRect
;
}
nsPoint
firstFrameToBoundingBox
=
GetOffsetToBoundingBox
(
firstFrame
)
;
gfxRect
overrideBBox
=
nsLayoutUtils
:
:
RectToGfxRect
(
GetPreEffectsVisualOverflowUnion
(
firstFrame
aFrame
aPreEffectsOverflowRect
firstFrameToBoundingBox
true
)
AppUnitsPerCSSPixel
(
)
)
;
overrideBBox
.
RoundOut
(
)
;
nsRect
overflowRect
=
nsFilterInstance
:
:
GetPostFilterBounds
(
firstFrame
&
overrideBBox
)
;
return
overflowRect
-
(
aFrame
-
>
GetOffsetTo
(
firstFrame
)
+
firstFrameToBoundingBox
)
;
}
nsIntRegion
nsSVGIntegrationUtils
:
:
AdjustInvalidAreaForSVGEffects
(
nsIFrame
*
aFrame
const
nsPoint
&
aToReferenceFrame
const
nsIntRegion
&
aInvalidRegion
)
{
if
(
aInvalidRegion
.
IsEmpty
(
)
)
{
return
nsIntRect
(
)
;
}
nsIFrame
*
firstFrame
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
aFrame
)
;
if
(
!
aFrame
-
>
StyleEffects
(
)
-
>
HasFilters
(
)
|
|
SVGObserverUtils
:
:
GetFiltersIfObserving
(
firstFrame
nullptr
)
=
=
SVGObserverUtils
:
:
eHasRefsSomeInvalid
)
{
return
aInvalidRegion
;
}
int32_t
appUnitsPerDevPixel
=
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
nsPoint
toBoundingBox
=
aFrame
-
>
GetOffsetTo
(
firstFrame
)
+
GetOffsetToBoundingBox
(
firstFrame
)
;
toBoundingBox
-
=
aToReferenceFrame
;
nsRegion
preEffectsRegion
=
aInvalidRegion
.
ToAppUnits
(
appUnitsPerDevPixel
)
.
MovedBy
(
toBoundingBox
)
;
nsRegion
result
=
nsFilterInstance
:
:
GetPostFilterDirtyArea
(
firstFrame
preEffectsRegion
)
.
MovedBy
(
-
toBoundingBox
)
;
return
result
.
ToOutsidePixels
(
appUnitsPerDevPixel
)
;
}
nsRect
nsSVGIntegrationUtils
:
:
GetRequiredSourceForInvalidArea
(
nsIFrame
*
aFrame
const
nsRect
&
aDirtyRect
)
{
nsIFrame
*
firstFrame
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
aFrame
)
;
if
(
!
aFrame
-
>
StyleEffects
(
)
-
>
HasFilters
(
)
|
|
SVGObserverUtils
:
:
GetFiltersIfObserving
(
firstFrame
nullptr
)
=
=
SVGObserverUtils
:
:
eHasRefsSomeInvalid
)
{
return
aDirtyRect
;
}
nsPoint
toUserSpace
=
aFrame
-
>
GetOffsetTo
(
firstFrame
)
+
GetOffsetToBoundingBox
(
firstFrame
)
;
nsRect
postEffectsRect
=
aDirtyRect
+
toUserSpace
;
return
nsFilterInstance
:
:
GetPreFilterNeededArea
(
firstFrame
postEffectsRect
)
.
GetBounds
(
)
-
toUserSpace
;
}
bool
nsSVGIntegrationUtils
:
:
HitTestFrameForEffects
(
nsIFrame
*
aFrame
const
nsPoint
&
aPt
)
{
nsIFrame
*
firstFrame
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
aFrame
)
;
nsPoint
toUserSpace
;
if
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_SVG_LAYOUT
)
{
toUserSpace
=
aFrame
-
>
GetPosition
(
)
;
}
else
{
toUserSpace
=
aFrame
-
>
GetOffsetTo
(
firstFrame
)
+
GetOffsetToBoundingBox
(
firstFrame
)
;
}
nsPoint
pt
=
aPt
+
toUserSpace
;
gfxPoint
userSpacePt
=
gfxPoint
(
pt
.
x
pt
.
y
)
/
AppUnitsPerCSSPixel
(
)
;
return
nsSVGUtils
:
:
HitTestClip
(
firstFrame
userSpacePt
)
;
}
class
RegularFramePaintCallback
:
public
nsSVGFilterPaintCallback
{
public
:
RegularFramePaintCallback
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
gfxPoint
&
aUserSpaceToFrameSpaceOffset
)
:
mBuilder
(
aBuilder
)
mLayerManager
(
aManager
)
mUserSpaceToFrameSpaceOffset
(
aUserSpaceToFrameSpaceOffset
)
{
}
virtual
void
Paint
(
gfxContext
&
aContext
nsIFrame
*
aTarget
const
gfxMatrix
&
aTransform
const
nsIntRect
*
aDirtyRect
imgDrawingParams
&
aImgParams
)
override
{
BasicLayerManager
*
basic
=
mLayerManager
-
>
AsBasicLayerManager
(
)
;
RefPtr
<
gfxContext
>
oldCtx
=
basic
-
>
GetTarget
(
)
;
basic
-
>
SetTarget
(
&
aContext
)
;
gfxContextMatrixAutoSaveRestore
autoSR
(
&
aContext
)
;
aContext
.
SetMatrixDouble
(
aContext
.
CurrentMatrixDouble
(
)
.
PreTranslate
(
-
mUserSpaceToFrameSpaceOffset
)
)
;
mLayerManager
-
>
EndTransaction
(
FrameLayerBuilder
:
:
DrawPaintedLayer
mBuilder
)
;
basic
-
>
SetTarget
(
oldCtx
)
;
}
private
:
nsDisplayListBuilder
*
mBuilder
;
LayerManager
*
mLayerManager
;
gfxPoint
mUserSpaceToFrameSpaceOffset
;
}
;
typedef
nsSVGIntegrationUtils
:
:
PaintFramesParams
PaintFramesParams
;
static
void
PaintMaskSurface
(
const
PaintFramesParams
&
aParams
DrawTarget
*
aMaskDT
float
aOpacity
ComputedStyle
*
aSC
const
nsTArray
<
nsSVGMaskFrame
*
>
&
aMaskFrames
const
Matrix
&
aMaskSurfaceMatrix
const
nsPoint
&
aOffsetToUserSpace
)
{
MOZ_ASSERT
(
aMaskFrames
.
Length
(
)
>
0
)
;
MOZ_ASSERT
(
aMaskDT
-
>
GetFormat
(
)
=
=
SurfaceFormat
:
:
A8
)
;
MOZ_ASSERT
(
aOpacity
=
=
1
.
0
|
|
aMaskFrames
.
Length
(
)
=
=
1
)
;
const
nsStyleSVGReset
*
svgReset
=
aSC
-
>
StyleSVGReset
(
)
;
gfxMatrix
cssPxToDevPxMatrix
=
nsSVGUtils
:
:
GetCSSPxToDevPxMatrix
(
aParams
.
frame
)
;
nsPresContext
*
presContext
=
aParams
.
frame
-
>
PresContext
(
)
;
gfxPoint
devPixelOffsetToUserSpace
=
nsLayoutUtils
:
:
PointToGfxPoint
(
aOffsetToUserSpace
presContext
-
>
AppUnitsPerDevPixel
(
)
)
;
RefPtr
<
gfxContext
>
maskContext
=
gfxContext
:
:
CreatePreservingTransformOrNull
(
aMaskDT
)
;
MOZ_ASSERT
(
maskContext
)
;
for
(
int
i
=
aMaskFrames
.
Length
(
)
-
1
;
i
>
=
0
;
i
-
-
)
{
nsSVGMaskFrame
*
maskFrame
=
aMaskFrames
[
i
]
;
CompositionOp
compositionOp
=
(
i
=
=
int
(
aMaskFrames
.
Length
(
)
-
1
)
)
?
CompositionOp
:
:
OP_OVER
:
nsCSSRendering
:
:
GetGFXCompositeMode
(
svgReset
-
>
mMask
.
mLayers
[
i
]
.
mComposite
)
;
if
(
maskFrame
)
{
nsSVGMaskFrame
:
:
MaskParams
params
(
maskContext
aParams
.
frame
cssPxToDevPxMatrix
aOpacity
svgReset
-
>
mMask
.
mLayers
[
i
]
.
mMaskMode
aParams
.
imgParams
)
;
RefPtr
<
SourceSurface
>
svgMask
=
maskFrame
-
>
GetMaskForMaskedFrame
(
params
)
;
if
(
svgMask
)
{
Matrix
tmp
=
aMaskDT
-
>
GetTransform
(
)
;
aMaskDT
-
>
SetTransform
(
Matrix
(
)
)
;
aMaskDT
-
>
MaskSurface
(
ColorPattern
(
Color
(
0
.
0
0
.
0
0
.
0
1
.
0
)
)
svgMask
Point
(
0
0
)
DrawOptions
(
1
.
0
compositionOp
)
)
;
aMaskDT
-
>
SetTransform
(
tmp
)
;
}
}
else
if
(
svgReset
-
>
mMask
.
mLayers
[
i
]
.
mImage
.
IsResolved
(
)
)
{
gfxContextMatrixAutoSaveRestore
matRestore
(
maskContext
)
;
maskContext
-
>
Multiply
(
gfxMatrix
:
:
Translation
(
-
devPixelOffsetToUserSpace
)
)
;
nsCSSRendering
:
:
PaintBGParams
params
=
nsCSSRendering
:
:
PaintBGParams
:
:
ForSingleLayer
(
*
presContext
aParams
.
dirtyRect
aParams
.
borderArea
aParams
.
frame
aParams
.
builder
-
>
GetBackgroundPaintFlags
(
)
|
nsCSSRendering
:
:
PAINTBG_MASK_IMAGE
i
compositionOp
aOpacity
)
;
aParams
.
imgParams
.
result
&
=
nsCSSRendering
:
:
PaintStyleImageLayerWithSC
(
params
*
maskContext
aSC
*
aParams
.
frame
-
>
StyleBorder
(
)
)
;
}
else
{
aParams
.
imgParams
.
result
&
=
ImgDrawResult
:
:
NOT_READY
;
}
}
}
struct
MaskPaintResult
{
RefPtr
<
SourceSurface
>
maskSurface
;
Matrix
maskTransform
;
bool
transparentBlackMask
;
bool
opacityApplied
;
MaskPaintResult
(
)
:
transparentBlackMask
(
false
)
opacityApplied
(
false
)
{
}
}
;
static
MaskPaintResult
CreateAndPaintMaskSurface
(
const
PaintFramesParams
&
aParams
float
aOpacity
ComputedStyle
*
aSC
const
nsTArray
<
nsSVGMaskFrame
*
>
&
aMaskFrames
const
nsPoint
&
aOffsetToUserSpace
)
{
const
nsStyleSVGReset
*
svgReset
=
aSC
-
>
StyleSVGReset
(
)
;
MOZ_ASSERT
(
aMaskFrames
.
Length
(
)
>
0
)
;
MaskPaintResult
paintResult
;
gfxContext
&
ctx
=
aParams
.
ctx
;
if
(
(
(
aMaskFrames
.
Length
(
)
=
=
1
)
&
&
aMaskFrames
[
0
]
)
)
{
gfxMatrix
cssPxToDevPxMatrix
=
nsSVGUtils
:
:
GetCSSPxToDevPxMatrix
(
aParams
.
frame
)
;
paintResult
.
opacityApplied
=
true
;
nsSVGMaskFrame
:
:
MaskParams
params
(
&
ctx
aParams
.
frame
cssPxToDevPxMatrix
aOpacity
svgReset
-
>
mMask
.
mLayers
[
0
]
.
mMaskMode
aParams
.
imgParams
)
;
paintResult
.
maskSurface
=
aMaskFrames
[
0
]
-
>
GetMaskForMaskedFrame
(
params
)
;
paintResult
.
maskTransform
=
ctx
.
CurrentMatrix
(
)
;
paintResult
.
maskTransform
.
Invert
(
)
;
if
(
!
paintResult
.
maskSurface
)
{
paintResult
.
transparentBlackMask
=
true
;
}
return
paintResult
;
}
const
Rect
&
maskSurfaceRect
=
aParams
.
maskRect
.
valueOr
(
Rect
(
)
)
;
if
(
aParams
.
maskRect
.
isSome
(
)
&
&
maskSurfaceRect
.
IsEmpty
(
)
)
{
paintResult
.
transparentBlackMask
=
true
;
return
paintResult
;
}
RefPtr
<
DrawTarget
>
maskDT
=
ctx
.
GetDrawTarget
(
)
-
>
CreateClippedDrawTarget
(
maskSurfaceRect
SurfaceFormat
:
:
A8
)
;
if
(
!
maskDT
|
|
!
maskDT
-
>
IsValid
(
)
)
{
return
paintResult
;
}
paintResult
.
opacityApplied
=
(
aMaskFrames
.
Length
(
)
=
=
1
)
;
Matrix
maskSurfaceMatrix
=
ctx
.
CurrentMatrix
(
)
;
PaintMaskSurface
(
aParams
maskDT
paintResult
.
opacityApplied
?
aOpacity
:
1
.
0
aSC
aMaskFrames
maskSurfaceMatrix
aOffsetToUserSpace
)
;
if
(
aParams
.
imgParams
.
result
!
=
ImgDrawResult
:
:
SUCCESS
&
&
aParams
.
imgParams
.
result
!
=
ImgDrawResult
:
:
SUCCESS_NOT_COMPLETE
)
{
paintResult
.
transparentBlackMask
=
!
(
aParams
.
frame
-
>
GetStateBits
(
)
&
NS_FRAME_SVG_LAYOUT
)
;
MOZ_ASSERT
(
!
paintResult
.
maskSurface
)
;
return
paintResult
;
}
paintResult
.
maskTransform
=
maskSurfaceMatrix
;
if
(
!
paintResult
.
maskTransform
.
Invert
(
)
)
{
return
paintResult
;
}
paintResult
.
maskSurface
=
maskDT
-
>
Snapshot
(
)
;
return
paintResult
;
}
static
bool
ValidateSVGFrame
(
nsIFrame
*
aFrame
)
{
#
ifdef
DEBUG
NS_ASSERTION
(
!
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_SVG_LAYOUT
)
|
|
(
NS_SVGDisplayListPaintingEnabled
(
)
&
&
!
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_IS_NONDISPLAY
)
)
"
Should
not
use
nsSVGIntegrationUtils
on
this
SVG
frame
"
)
;
#
endif
bool
hasSVGLayout
=
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_SVG_LAYOUT
)
;
if
(
hasSVGLayout
)
{
#
ifdef
DEBUG
nsSVGDisplayableFrame
*
svgFrame
=
do_QueryFrame
(
aFrame
)
;
MOZ_ASSERT
(
svgFrame
&
&
aFrame
-
>
GetContent
(
)
-
>
IsSVGElement
(
)
"
A
non
-
SVG
frame
carries
NS_FRAME_SVG_LAYOUT
flag
?
"
)
;
#
endif
const
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
!
static_cast
<
const
SVGElement
*
>
(
content
)
-
>
HasValidDimensions
(
)
)
{
return
false
;
}
}
return
true
;
}
struct
EffectOffsets
{
nsPoint
offsetToBoundingBox
;
nsPoint
offsetToUserSpace
;
gfxPoint
offsetToUserSpaceInDevPx
;
}
;
static
EffectOffsets
ComputeEffectOffset
(
nsIFrame
*
aFrame
const
PaintFramesParams
&
aParams
)
{
EffectOffsets
result
;
result
.
offsetToBoundingBox
=
aParams
.
builder
-
>
ToReferenceFrame
(
aFrame
)
-
nsSVGIntegrationUtils
:
:
GetOffsetToBoundingBox
(
aFrame
)
;
if
(
!
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
)
{
result
.
offsetToBoundingBox
=
nsPoint
(
aFrame
-
>
PresContext
(
)
-
>
RoundAppUnitsToNearestDevPixels
(
result
.
offsetToBoundingBox
.
x
)
aFrame
-
>
PresContext
(
)
-
>
RoundAppUnitsToNearestDevPixels
(
result
.
offsetToBoundingBox
.
y
)
)
;
}
gfxPoint
toUserSpaceGfx
=
nsSVGUtils
:
:
FrameSpaceInCSSPxToUserSpaceOffset
(
aFrame
)
;
nsPoint
toUserSpace
=
nsPoint
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
float
(
toUserSpaceGfx
.
x
)
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
float
(
toUserSpaceGfx
.
y
)
)
)
;
result
.
offsetToUserSpace
=
result
.
offsetToBoundingBox
-
toUserSpace
;
#
ifdef
DEBUG
bool
hasSVGLayout
=
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_SVG_LAYOUT
)
;
NS_ASSERTION
(
hasSVGLayout
|
|
result
.
offsetToBoundingBox
=
=
result
.
offsetToUserSpace
"
For
non
-
SVG
frames
there
shouldn
'
t
be
any
additional
offset
"
)
;
#
endif
result
.
offsetToUserSpaceInDevPx
=
nsLayoutUtils
:
:
PointToGfxPoint
(
result
.
offsetToUserSpace
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
return
result
;
}
static
EffectOffsets
MoveContextOriginToUserSpace
(
nsIFrame
*
aFrame
const
PaintFramesParams
&
aParams
)
{
EffectOffsets
offset
=
ComputeEffectOffset
(
aFrame
aParams
)
;
aParams
.
ctx
.
SetMatrixDouble
(
aParams
.
ctx
.
CurrentMatrixDouble
(
)
.
PreTranslate
(
offset
.
offsetToUserSpaceInDevPx
)
)
;
return
offset
;
}
bool
nsSVGIntegrationUtils
:
:
IsMaskResourceReady
(
nsIFrame
*
aFrame
)
{
nsIFrame
*
firstFrame
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
aFrame
)
;
nsTArray
<
nsSVGMaskFrame
*
>
maskFrames
;
SVGObserverUtils
:
:
GetAndObserveMasks
(
firstFrame
&
maskFrames
)
;
const
nsStyleSVGReset
*
svgReset
=
firstFrame
-
>
StyleSVGReset
(
)
;
for
(
uint32_t
i
=
0
;
i
<
maskFrames
.
Length
(
)
;
i
+
+
)
{
if
(
maskFrames
[
i
]
)
{
continue
;
}
if
(
!
svgReset
-
>
mMask
.
mLayers
[
i
]
.
mImage
.
IsComplete
(
)
)
{
return
false
;
}
}
return
true
;
}
class
AutoPopGroup
{
public
:
AutoPopGroup
(
)
:
mContext
(
nullptr
)
{
}
~
AutoPopGroup
(
)
{
if
(
mContext
)
{
mContext
-
>
PopGroupAndBlend
(
)
;
}
}
void
SetContext
(
gfxContext
*
aContext
)
{
mContext
=
aContext
;
}
private
:
gfxContext
*
mContext
;
}
;
bool
nsSVGIntegrationUtils
:
:
PaintMask
(
const
PaintFramesParams
&
aParams
)
{
nsSVGUtils
:
:
MaskUsage
maskUsage
;
nsSVGUtils
:
:
DetermineMaskUsage
(
aParams
.
frame
aParams
.
handleOpacity
maskUsage
)
;
if
(
!
maskUsage
.
shouldDoSomething
(
)
)
{
return
false
;
}
nsIFrame
*
frame
=
aParams
.
frame
;
if
(
!
ValidateSVGFrame
(
frame
)
)
{
return
false
;
}
gfxContext
&
ctx
=
aParams
.
ctx
;
RefPtr
<
DrawTarget
>
maskTarget
=
ctx
.
GetDrawTarget
(
)
;
if
(
maskUsage
.
shouldGenerateMaskLayer
&
&
(
maskUsage
.
shouldGenerateClipMaskLayer
|
|
maskUsage
.
shouldApplyClipPath
)
)
{
maskTarget
=
maskTarget
-
>
CreateSimilarDrawTarget
(
maskTarget
-
>
GetSize
(
)
SurfaceFormat
:
:
A8
)
;
}
nsIFrame
*
firstFrame
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
frame
)
;
nsTArray
<
nsSVGMaskFrame
*
>
maskFrames
;
SVGObserverUtils
:
:
GetAndObserveMasks
(
firstFrame
&
maskFrames
)
;
AutoPopGroup
autoPop
;
bool
shouldPushOpacity
=
(
maskUsage
.
opacity
!
=
1
.
0
)
&
&
(
maskFrames
.
Length
(
)
!
=
1
)
;
if
(
shouldPushOpacity
)
{
ctx
.
PushGroupForBlendBack
(
gfxContentType
:
:
COLOR_ALPHA
maskUsage
.
opacity
)
;
autoPop
.
SetContext
(
&
ctx
)
;
}
gfxContextMatrixAutoSaveRestore
matSR
;
gfxContextAutoSaveRestore
basicShapeSR
;
if
(
maskUsage
.
shouldApplyBasicShapeOrPath
)
{
matSR
.
SetContext
(
&
ctx
)
;
MoveContextOriginToUserSpace
(
firstFrame
aParams
)
;
basicShapeSR
.
SetContext
(
&
ctx
)
;
nsCSSClipPathInstance
:
:
ApplyBasicShapeOrPathClip
(
ctx
frame
nsSVGUtils
:
:
GetCSSPxToDevPxMatrix
(
frame
)
)
;
if
(
!
maskUsage
.
shouldGenerateMaskLayer
)
{
ctx
.
SetColor
(
Color
(
1
.
0
1
.
0
1
.
0
1
.
0
)
)
;
ctx
.
Fill
(
)
;
return
true
;
}
}
if
(
maskUsage
.
shouldGenerateMaskLayer
)
{
matSR
.
Restore
(
)
;
matSR
.
SetContext
(
&
ctx
)
;
EffectOffsets
offsets
=
MoveContextOriginToUserSpace
(
frame
aParams
)
;
PaintMaskSurface
(
aParams
maskTarget
shouldPushOpacity
?
1
.
0
:
maskUsage
.
opacity
firstFrame
-
>
Style
(
)
maskFrames
ctx
.
CurrentMatrix
(
)
offsets
.
offsetToUserSpace
)
;
}
if
(
maskUsage
.
shouldGenerateClipMaskLayer
|
|
maskUsage
.
shouldApplyClipPath
)
{
matSR
.
Restore
(
)
;
matSR
.
SetContext
(
&
ctx
)
;
MoveContextOriginToUserSpace
(
firstFrame
aParams
)
;
Matrix
clipMaskTransform
;
gfxMatrix
cssPxToDevPxMatrix
=
nsSVGUtils
:
:
GetCSSPxToDevPxMatrix
(
frame
)
;
nsSVGClipPathFrame
*
clipPathFrame
;
SVGObserverUtils
:
:
GetAndObserveClipPath
(
firstFrame
&
clipPathFrame
)
;
RefPtr
<
SourceSurface
>
maskSurface
=
maskUsage
.
shouldGenerateMaskLayer
?
maskTarget
-
>
Snapshot
(
)
:
nullptr
;
clipPathFrame
-
>
PaintClipMask
(
ctx
frame
cssPxToDevPxMatrix
maskSurface
ctx
.
CurrentMatrix
(
)
)
;
}
return
true
;
}
template
<
class
T
>
void
PaintMaskAndClipPathInternal
(
const
PaintFramesParams
&
aParams
const
T
&
aPaintChild
)
{
MOZ_ASSERT
(
nsSVGIntegrationUtils
:
:
UsingMaskOrClipPathForFrame
(
aParams
.
frame
)
"
Should
not
use
this
method
when
no
mask
or
clipPath
effect
"
"
on
this
frame
"
)
;
nsIFrame
*
frame
=
aParams
.
frame
;
if
(
!
ValidateSVGFrame
(
frame
)
)
{
return
;
}
nsSVGUtils
:
:
MaskUsage
maskUsage
;
nsSVGUtils
:
:
DetermineMaskUsage
(
aParams
.
frame
aParams
.
handleOpacity
maskUsage
)
;
if
(
maskUsage
.
opacity
=
=
0
.
0f
)
{
return
;
}
gfxContext
&
context
=
aParams
.
ctx
;
gfxContextMatrixAutoSaveRestore
matrixAutoSaveRestore
(
&
context
)
;
nsIFrame
*
firstFrame
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
frame
)
;
nsSVGClipPathFrame
*
clipPathFrame
;
SVGObserverUtils
:
:
GetAndObserveClipPath
(
firstFrame
&
clipPathFrame
)
;
nsTArray
<
nsSVGMaskFrame
*
>
maskFrames
;
SVGObserverUtils
:
:
GetAndObserveMasks
(
firstFrame
&
maskFrames
)
;
gfxMatrix
cssPxToDevPxMatrix
=
nsSVGUtils
:
:
GetCSSPxToDevPxMatrix
(
frame
)
;
bool
shouldGenerateMask
=
(
maskUsage
.
opacity
!
=
1
.
0f
|
|
maskUsage
.
shouldGenerateClipMaskLayer
|
|
maskUsage
.
shouldGenerateMaskLayer
)
;
bool
shouldPushMask
=
false
;
if
(
shouldGenerateMask
)
{
gfxContextMatrixAutoSaveRestore
matSR
;
Matrix
maskTransform
;
RefPtr
<
SourceSurface
>
maskSurface
;
bool
opacityApplied
=
false
;
if
(
maskUsage
.
shouldGenerateMaskLayer
)
{
matSR
.
SetContext
(
&
context
)
;
EffectOffsets
offsets
=
MoveContextOriginToUserSpace
(
frame
aParams
)
;
MaskPaintResult
paintResult
=
CreateAndPaintMaskSurface
(
aParams
maskUsage
.
opacity
firstFrame
-
>
Style
(
)
maskFrames
offsets
.
offsetToUserSpace
)
;
if
(
paintResult
.
transparentBlackMask
)
{
return
;
}
maskSurface
=
paintResult
.
maskSurface
;
if
(
maskSurface
)
{
shouldPushMask
=
true
;
maskTransform
=
context
.
CurrentMatrix
(
)
;
maskTransform
.
Invert
(
)
;
opacityApplied
=
paintResult
.
opacityApplied
;
}
}
if
(
maskUsage
.
shouldGenerateClipMaskLayer
)
{
matSR
.
Restore
(
)
;
matSR
.
SetContext
(
&
context
)
;
MoveContextOriginToUserSpace
(
firstFrame
aParams
)
;
RefPtr
<
SourceSurface
>
clipMaskSurface
=
clipPathFrame
-
>
GetClipMask
(
context
frame
cssPxToDevPxMatrix
maskSurface
maskTransform
)
;
if
(
clipMaskSurface
)
{
maskSurface
=
clipMaskSurface
;
maskTransform
=
context
.
CurrentMatrix
(
)
;
maskTransform
.
Invert
(
)
;
}
else
{
return
;
}
shouldPushMask
=
true
;
}
if
(
!
maskUsage
.
shouldGenerateClipMaskLayer
&
&
!
maskUsage
.
shouldGenerateMaskLayer
)
{
MOZ_ASSERT
(
maskUsage
.
opacity
!
=
1
.
0f
)
;
matSR
.
SetContext
(
&
context
)
;
MoveContextOriginToUserSpace
(
firstFrame
aParams
)
;
shouldPushMask
=
true
;
}
if
(
shouldPushMask
)
{
if
(
aParams
.
layerManager
&
&
aParams
.
layerManager
-
>
GetRoot
(
)
-
>
GetContentFlags
(
)
&
Layer
:
:
CONTENT_COMPONENT_ALPHA
)
{
context
.
PushGroupAndCopyBackground
(
gfxContentType
:
:
COLOR_ALPHA
opacityApplied
?
1
.
0
:
maskUsage
.
opacity
maskSurface
maskTransform
)
;
}
else
{
context
.
PushGroupForBlendBack
(
gfxContentType
:
:
COLOR_ALPHA
opacityApplied
?
1
.
0
:
maskUsage
.
opacity
maskSurface
maskTransform
)
;
}
}
}
if
(
maskUsage
.
shouldApplyClipPath
|
|
maskUsage
.
shouldApplyBasicShapeOrPath
)
{
gfxContextMatrixAutoSaveRestore
matSR
(
&
context
)
;
MoveContextOriginToUserSpace
(
firstFrame
aParams
)
;
MOZ_ASSERT
(
!
maskUsage
.
shouldApplyClipPath
|
|
!
maskUsage
.
shouldApplyBasicShapeOrPath
)
;
if
(
maskUsage
.
shouldApplyClipPath
)
{
clipPathFrame
-
>
ApplyClipPath
(
context
frame
cssPxToDevPxMatrix
)
;
}
else
{
nsCSSClipPathInstance
:
:
ApplyBasicShapeOrPathClip
(
context
frame
cssPxToDevPxMatrix
)
;
}
}
context
.
SetMatrix
(
matrixAutoSaveRestore
.
Matrix
(
)
)
;
aPaintChild
(
)
;
if
(
StaticPrefs
:
:
layers_draw_mask_debug
(
)
)
{
gfxContextAutoSaveRestore
saver
(
&
context
)
;
context
.
NewPath
(
)
;
gfxRect
drawingRect
=
nsLayoutUtils
:
:
RectToGfxRect
(
aParams
.
borderArea
frame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
context
.
SnappedRectangle
(
drawingRect
)
;
Color
overlayColor
(
0
.
0f
0
.
0f
0
.
0f
0
.
8f
)
;
if
(
maskUsage
.
shouldGenerateMaskLayer
)
{
overlayColor
.
r
=
1
.
0f
;
}
if
(
maskUsage
.
shouldApplyClipPath
|
|
maskUsage
.
shouldGenerateClipMaskLayer
)
{
overlayColor
.
g
=
1
.
0f
;
}
if
(
maskUsage
.
shouldApplyBasicShapeOrPath
)
{
overlayColor
.
b
=
1
.
0f
;
}
context
.
SetColor
(
overlayColor
)
;
context
.
Fill
(
)
;
}
if
(
maskUsage
.
shouldApplyClipPath
|
|
maskUsage
.
shouldApplyBasicShapeOrPath
)
{
context
.
PopClip
(
)
;
}
if
(
shouldPushMask
)
{
context
.
PopGroupAndBlend
(
)
;
}
}
void
nsSVGIntegrationUtils
:
:
PaintMaskAndClipPath
(
const
PaintFramesParams
&
aParams
)
{
PaintMaskAndClipPathInternal
(
aParams
[
&
]
{
gfxContext
&
context
=
aParams
.
ctx
;
BasicLayerManager
*
basic
=
aParams
.
layerManager
-
>
AsBasicLayerManager
(
)
;
RefPtr
<
gfxContext
>
oldCtx
=
basic
-
>
GetTarget
(
)
;
basic
-
>
SetTarget
(
&
context
)
;
aParams
.
layerManager
-
>
EndTransaction
(
FrameLayerBuilder
:
:
DrawPaintedLayer
aParams
.
builder
)
;
basic
-
>
SetTarget
(
oldCtx
)
;
}
)
;
}
void
nsSVGIntegrationUtils
:
:
PaintMaskAndClipPath
(
const
PaintFramesParams
&
aParams
const
std
:
:
function
<
void
(
)
>
&
aPaintChild
)
{
PaintMaskAndClipPathInternal
(
aParams
aPaintChild
)
;
}
void
nsSVGIntegrationUtils
:
:
PaintFilter
(
const
PaintFramesParams
&
aParams
)
{
MOZ_ASSERT
(
!
aParams
.
builder
-
>
IsForGenerateGlyphMask
(
)
"
Filter
effect
is
discarded
while
generating
glyph
mask
.
"
)
;
MOZ_ASSERT
(
aParams
.
frame
-
>
StyleEffects
(
)
-
>
HasFilters
(
)
"
Should
not
use
this
method
when
no
filter
effect
on
this
frame
"
)
;
nsIFrame
*
frame
=
aParams
.
frame
;
if
(
!
ValidateSVGFrame
(
frame
)
)
{
return
;
}
float
opacity
=
nsSVGUtils
:
:
ComputeOpacity
(
frame
aParams
.
handleOpacity
)
;
if
(
opacity
=
=
0
.
0f
)
{
return
;
}
nsIFrame
*
firstFrame
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
frame
)
;
if
(
SVGObserverUtils
:
:
GetAndObserveFilters
(
firstFrame
nullptr
)
=
=
SVGObserverUtils
:
:
eHasRefsSomeInvalid
)
{
return
;
}
gfxContext
&
context
=
aParams
.
ctx
;
gfxContextAutoSaveRestore
autoSR
(
&
context
)
;
EffectOffsets
offsets
=
MoveContextOriginToUserSpace
(
firstFrame
aParams
)
;
RegularFramePaintCallback
callback
(
aParams
.
builder
aParams
.
layerManager
offsets
.
offsetToUserSpaceInDevPx
)
;
nsRegion
dirtyRegion
=
aParams
.
dirtyRect
-
offsets
.
offsetToBoundingBox
;
nsFilterInstance
:
:
PaintFilteredFrame
(
frame
&
context
&
callback
&
dirtyRegion
aParams
.
imgParams
opacity
)
;
}
static
float
ClampStdDeviation
(
float
aStdDeviation
)
{
return
std
:
:
min
(
std
:
:
max
(
0
.
0f
aStdDeviation
)
100
.
0f
)
;
}
bool
nsSVGIntegrationUtils
:
:
CreateWebRenderCSSFilters
(
Span
<
const
StyleFilter
>
aFilters
nsIFrame
*
aFrame
WrFiltersHolder
&
aWrFilters
)
{
if
(
aFilters
.
Length
(
)
>
StaticPrefs
:
:
gfx_webrender_max_filter_ops_per_chain
(
)
)
{
return
true
;
}
aWrFilters
.
filters
.
SetCapacity
(
aFilters
.
Length
(
)
)
;
auto
&
wrFilters
=
aWrFilters
.
filters
;
for
(
const
StyleFilter
&
filter
:
aFilters
)
{
switch
(
filter
.
tag
)
{
case
StyleFilter
:
:
Tag
:
:
Brightness
:
wrFilters
.
AppendElement
(
wr
:
:
FilterOp
:
:
Brightness
(
filter
.
AsBrightness
(
)
)
)
;
break
;
case
StyleFilter
:
:
Tag
:
:
Contrast
:
wrFilters
.
AppendElement
(
wr
:
:
FilterOp
:
:
Contrast
(
filter
.
AsContrast
(
)
)
)
;
break
;
case
StyleFilter
:
:
Tag
:
:
Grayscale
:
wrFilters
.
AppendElement
(
wr
:
:
FilterOp
:
:
Grayscale
(
filter
.
AsGrayscale
(
)
)
)
;
break
;
case
StyleFilter
:
:
Tag
:
:
Invert
:
wrFilters
.
AppendElement
(
wr
:
:
FilterOp
:
:
Invert
(
filter
.
AsInvert
(
)
)
)
;
break
;
case
StyleFilter
:
:
Tag
:
:
Opacity
:
{
float
opacity
=
filter
.
AsOpacity
(
)
;
wrFilters
.
AppendElement
(
wr
:
:
FilterOp
:
:
Opacity
(
wr
:
:
PropertyBinding
<
float
>
:
:
Value
(
opacity
)
opacity
)
)
;
break
;
}
case
StyleFilter
:
:
Tag
:
:
Saturate
:
wrFilters
.
AppendElement
(
wr
:
:
FilterOp
:
:
Saturate
(
filter
.
AsSaturate
(
)
)
)
;
break
;
case
StyleFilter
:
:
Tag
:
:
Sepia
:
wrFilters
.
AppendElement
(
wr
:
:
FilterOp
:
:
Sepia
(
filter
.
AsSepia
(
)
)
)
;
break
;
case
StyleFilter
:
:
Tag
:
:
HueRotate
:
{
wrFilters
.
AppendElement
(
wr
:
:
FilterOp
:
:
HueRotate
(
filter
.
AsHueRotate
(
)
.
ToDegrees
(
)
)
)
;
break
;
}
case
StyleFilter
:
:
Tag
:
:
Blur
:
{
float
appUnitsPerDevPixel
=
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
wrFilters
.
AppendElement
(
mozilla
:
:
wr
:
:
FilterOp
:
:
Blur
(
ClampStdDeviation
(
NSAppUnitsToFloatPixels
(
filter
.
AsBlur
(
)
.
ToAppUnits
(
)
appUnitsPerDevPixel
)
)
)
)
;
break
;
}
case
StyleFilter
:
:
Tag
:
:
DropShadow
:
{
float
appUnitsPerDevPixel
=
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
const
StyleSimpleShadow
&
shadow
=
filter
.
AsDropShadow
(
)
;
nscolor
color
=
shadow
.
color
.
CalcColor
(
aFrame
)
;
wr
:
:
Shadow
wrShadow
;
wrShadow
.
offset
=
{
NSAppUnitsToFloatPixels
(
shadow
.
horizontal
.
ToAppUnits
(
)
appUnitsPerDevPixel
)
NSAppUnitsToFloatPixels
(
shadow
.
vertical
.
ToAppUnits
(
)
appUnitsPerDevPixel
)
}
;
wrShadow
.
blur_radius
=
NSAppUnitsToFloatPixels
(
shadow
.
blur
.
ToAppUnits
(
)
appUnitsPerDevPixel
)
;
wrShadow
.
color
=
{
NS_GET_R
(
color
)
/
255
.
0f
NS_GET_G
(
color
)
/
255
.
0f
NS_GET_B
(
color
)
/
255
.
0f
NS_GET_A
(
color
)
/
255
.
0f
}
;
wrFilters
.
AppendElement
(
wr
:
:
FilterOp
:
:
DropShadow
(
wrShadow
)
)
;
break
;
}
default
:
return
false
;
}
}
return
true
;
}
bool
nsSVGIntegrationUtils
:
:
BuildWebRenderFilters
(
nsIFrame
*
aFilteredFrame
Span
<
const
StyleFilter
>
aFilters
WrFiltersHolder
&
aWrFilters
Maybe
<
nsRect
>
&
aPostFilterClip
)
{
return
nsFilterInstance
:
:
BuildWebRenderFilters
(
aFilteredFrame
aFilters
aWrFilters
aPostFilterClip
)
;
}
bool
nsSVGIntegrationUtils
:
:
CanCreateWebRenderFiltersForFrame
(
nsIFrame
*
aFrame
)
{
WrFiltersHolder
wrFilters
;
Maybe
<
nsRect
>
filterClip
;
auto
filterChain
=
aFrame
-
>
StyleEffects
(
)
-
>
mFilters
.
AsSpan
(
)
;
return
CreateWebRenderCSSFilters
(
filterChain
aFrame
wrFilters
)
|
|
BuildWebRenderFilters
(
aFrame
filterChain
wrFilters
filterClip
)
;
}
class
PaintFrameCallback
:
public
gfxDrawingCallback
{
public
:
PaintFrameCallback
(
nsIFrame
*
aFrame
const
nsSize
aPaintServerSize
const
IntSize
aRenderSize
uint32_t
aFlags
)
:
mFrame
(
aFrame
)
mPaintServerSize
(
aPaintServerSize
)
mRenderSize
(
aRenderSize
)
mFlags
(
aFlags
)
{
}
virtual
bool
operator
(
)
(
gfxContext
*
aContext
const
gfxRect
&
aFillRect
const
SamplingFilter
aSamplingFilter
const
gfxMatrix
&
aTransform
)
override
;
private
:
nsIFrame
*
mFrame
;
nsSize
mPaintServerSize
;
IntSize
mRenderSize
;
uint32_t
mFlags
;
}
;
bool
PaintFrameCallback
:
:
operator
(
)
(
gfxContext
*
aContext
const
gfxRect
&
aFillRect
const
SamplingFilter
aSamplingFilter
const
gfxMatrix
&
aTransform
)
{
if
(
mFrame
-
>
GetStateBits
(
)
&
NS_FRAME_DRAWING_AS_PAINTSERVER
)
{
return
false
;
}
AutoSetRestorePaintServerState
paintServer
(
mFrame
)
;
aContext
-
>
Save
(
)
;
aContext
-
>
NewPath
(
)
;
aContext
-
>
Rectangle
(
aFillRect
)
;
aContext
-
>
Clip
(
)
;
gfxMatrix
invmatrix
=
aTransform
;
if
(
!
invmatrix
.
Invert
(
)
)
{
return
false
;
}
aContext
-
>
Multiply
(
invmatrix
)
;
int32_t
appUnitsPerDevPixel
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
nsPoint
offset
=
nsSVGIntegrationUtils
:
:
GetOffsetToBoundingBox
(
mFrame
)
;
gfxPoint
devPxOffset
=
gfxPoint
(
offset
.
x
offset
.
y
)
/
appUnitsPerDevPixel
;
aContext
-
>
Multiply
(
gfxMatrix
:
:
Translation
(
devPxOffset
)
)
;
gfxSize
paintServerSize
=
gfxSize
(
mPaintServerSize
.
width
mPaintServerSize
.
height
)
/
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
gfxFloat
scaleX
=
mRenderSize
.
width
/
paintServerSize
.
width
;
gfxFloat
scaleY
=
mRenderSize
.
height
/
paintServerSize
.
height
;
aContext
-
>
Multiply
(
gfxMatrix
:
:
Scaling
(
scaleX
scaleY
)
)
;
nsRect
dirty
(
-
offset
.
x
-
offset
.
y
mPaintServerSize
.
width
mPaintServerSize
.
height
)
;
using
PaintFrameFlags
=
nsLayoutUtils
:
:
PaintFrameFlags
;
PaintFrameFlags
flags
=
PaintFrameFlags
:
:
InTransform
;
if
(
mFlags
&
nsSVGIntegrationUtils
:
:
FLAG_SYNC_DECODE_IMAGES
)
{
flags
|
=
PaintFrameFlags
:
:
SyncDecodeImages
;
}
nsLayoutUtils
:
:
PaintFrame
(
aContext
mFrame
dirty
NS_RGBA
(
0
0
0
0
)
nsDisplayListBuilderMode
:
:
Painting
flags
)
;
nsIFrame
*
currentFrame
=
mFrame
;
while
(
(
currentFrame
=
currentFrame
-
>
GetNextContinuation
(
)
)
!
=
nullptr
)
{
offset
=
currentFrame
-
>
GetOffsetToCrossDoc
(
mFrame
)
;
devPxOffset
=
gfxPoint
(
offset
.
x
offset
.
y
)
/
appUnitsPerDevPixel
;
aContext
-
>
Save
(
)
;
aContext
-
>
Multiply
(
gfxMatrix
:
:
Scaling
(
1
/
scaleX
1
/
scaleY
)
)
;
aContext
-
>
Multiply
(
gfxMatrix
:
:
Translation
(
devPxOffset
)
)
;
aContext
-
>
Multiply
(
gfxMatrix
:
:
Scaling
(
scaleX
scaleY
)
)
;
nsLayoutUtils
:
:
PaintFrame
(
aContext
currentFrame
dirty
-
offset
NS_RGBA
(
0
0
0
0
)
nsDisplayListBuilderMode
:
:
Painting
flags
)
;
aContext
-
>
Restore
(
)
;
}
aContext
-
>
Restore
(
)
;
return
true
;
}
already_AddRefed
<
gfxDrawable
>
nsSVGIntegrationUtils
:
:
DrawableFromPaintServer
(
nsIFrame
*
aFrame
nsIFrame
*
aTarget
const
nsSize
&
aPaintServerSize
const
IntSize
&
aRenderSize
const
DrawTarget
*
aDrawTarget
const
gfxMatrix
&
aContextMatrix
uint32_t
aFlags
)
{
if
(
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVGPaintServer
)
)
{
nsSVGPaintServerFrame
*
server
=
static_cast
<
nsSVGPaintServerFrame
*
>
(
aFrame
)
;
gfxRect
overrideBounds
(
0
0
aPaintServerSize
.
width
aPaintServerSize
.
height
)
;
overrideBounds
.
Scale
(
1
.
0
/
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
imgDrawingParams
imgParams
(
aFlags
)
;
RefPtr
<
gfxPattern
>
pattern
=
server
-
>
GetPaintServerPattern
(
aTarget
aDrawTarget
aContextMatrix
&
nsStyleSVG
:
:
mFill
1
.
0
imgParams
&
overrideBounds
)
;
if
(
!
pattern
)
{
return
nullptr
;
}
gfxFloat
scaleX
=
overrideBounds
.
Width
(
)
/
aRenderSize
.
width
;
gfxFloat
scaleY
=
overrideBounds
.
Height
(
)
/
aRenderSize
.
height
;
gfxMatrix
scaleMatrix
=
gfxMatrix
:
:
Scaling
(
scaleX
scaleY
)
;
pattern
-
>
SetMatrix
(
scaleMatrix
*
pattern
-
>
GetMatrix
(
)
)
;
RefPtr
<
gfxDrawable
>
drawable
=
new
gfxPatternDrawable
(
pattern
aRenderSize
)
;
return
drawable
.
forget
(
)
;
}
if
(
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
&
&
!
static_cast
<
nsSVGDisplayableFrame
*
>
(
do_QueryFrame
(
aFrame
)
)
)
{
MOZ_ASSERT_UNREACHABLE
(
"
We
should
prevent
painting
of
unpaintable
SVG
"
"
before
we
get
here
"
)
;
return
nullptr
;
}
RefPtr
<
gfxDrawingCallback
>
cb
=
new
PaintFrameCallback
(
aFrame
aPaintServerSize
aRenderSize
aFlags
)
;
RefPtr
<
gfxDrawable
>
drawable
=
new
gfxCallbackDrawable
(
cb
aRenderSize
)
;
return
drawable
.
forget
(
)
;
}
