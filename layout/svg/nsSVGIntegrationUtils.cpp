#
include
"
nsSVGIntegrationUtils
.
h
"
#
include
"
gfxDrawable
.
h
"
#
include
"
nsCSSAnonBoxes
.
h
"
#
include
"
nsCSSClipPathInstance
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsFilterInstance
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsRenderingContext
.
h
"
#
include
"
nsSVGClipPathFrame
.
h
"
#
include
"
nsSVGEffects
.
h
"
#
include
"
nsSVGElement
.
h
"
#
include
"
nsSVGFilterPaintCallback
.
h
"
#
include
"
nsSVGMaskFrame
.
h
"
#
include
"
nsSVGPaintServerFrame
.
h
"
#
include
"
nsSVGUtils
.
h
"
#
include
"
FrameLayerBuilder
.
h
"
#
include
"
BasicLayers
.
h
"
#
include
"
mozilla
/
gfx
/
Point
.
h
"
#
include
"
nsCSSRendering
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
layers
;
using
namespace
mozilla
:
:
gfx
;
class
PreEffectsVisualOverflowCollector
:
public
nsLayoutUtils
:
:
BoxCallback
{
public
:
PreEffectsVisualOverflowCollector
(
nsIFrame
*
aFirstContinuation
nsIFrame
*
aCurrentFrame
const
nsRect
&
aCurrentFrameOverflowArea
)
:
mFirstContinuation
(
aFirstContinuation
)
mCurrentFrame
(
aCurrentFrame
)
mCurrentFrameOverflowArea
(
aCurrentFrameOverflowArea
)
{
NS_ASSERTION
(
!
mFirstContinuation
-
>
GetPrevContinuation
(
)
"
We
want
the
first
continuation
here
"
)
;
}
virtual
void
AddBox
(
nsIFrame
*
aFrame
)
override
{
nsRect
overflow
=
(
aFrame
=
=
mCurrentFrame
)
?
mCurrentFrameOverflowArea
:
GetPreEffectsVisualOverflowRect
(
aFrame
)
;
mResult
.
UnionRect
(
mResult
overflow
+
aFrame
-
>
GetOffsetTo
(
mFirstContinuation
)
)
;
}
nsRect
GetResult
(
)
const
{
return
mResult
;
}
private
:
static
nsRect
GetPreEffectsVisualOverflowRect
(
nsIFrame
*
aFrame
)
{
nsRect
*
r
=
static_cast
<
nsRect
*
>
(
aFrame
-
>
Properties
(
)
.
Get
(
nsIFrame
:
:
PreEffectsBBoxProperty
(
)
)
)
;
if
(
r
)
{
return
*
r
;
}
NS_ASSERTION
(
aFrame
-
>
GetParent
(
)
-
>
StyleContext
(
)
-
>
GetPseudo
(
)
=
=
nsCSSAnonBoxes
:
:
mozAnonymousBlock
"
How
did
we
getting
here
then
?
"
)
;
NS_ASSERTION
(
!
aFrame
-
>
Properties
(
)
.
Get
(
aFrame
-
>
PreTransformOverflowAreasProperty
(
)
)
"
GetVisualOverflowRect
(
)
won
'
t
return
the
pre
-
effects
rect
!
"
)
;
return
aFrame
-
>
GetVisualOverflowRect
(
)
;
}
nsIFrame
*
mFirstContinuation
;
nsIFrame
*
mCurrentFrame
;
const
nsRect
&
mCurrentFrameOverflowArea
;
nsRect
mResult
;
}
;
static
nsRect
GetPreEffectsVisualOverflowUnion
(
nsIFrame
*
aFirstContinuation
nsIFrame
*
aCurrentFrame
const
nsRect
&
aCurrentFramePreEffectsOverflow
const
nsPoint
&
aFirstContinuationToUserSpace
)
{
NS_ASSERTION
(
!
aFirstContinuation
-
>
GetPrevContinuation
(
)
"
Need
first
continuation
here
"
)
;
PreEffectsVisualOverflowCollector
collector
(
aFirstContinuation
aCurrentFrame
aCurrentFramePreEffectsOverflow
)
;
nsLayoutUtils
:
:
GetAllInFlowBoxes
(
aFirstContinuation
&
collector
)
;
return
collector
.
GetResult
(
)
+
aFirstContinuationToUserSpace
;
}
bool
nsSVGIntegrationUtils
:
:
UsingEffectsForFrame
(
const
nsIFrame
*
aFrame
)
{
const
nsStyleSVGReset
*
style
=
aFrame
-
>
StyleSVGReset
(
)
;
bool
hasValidLayers
=
style
-
>
mMask
.
HasLayerWithImage
(
)
;
return
(
style
-
>
HasFilters
(
)
|
|
style
-
>
HasClipPath
(
)
|
|
hasValidLayers
)
;
}
static
nsPoint
GetOffsetToBoundingBox
(
nsIFrame
*
aFrame
)
{
if
(
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_SVG_LAYOUT
)
)
{
return
nsPoint
(
)
;
}
NS_ASSERTION
(
!
aFrame
-
>
GetPrevContinuation
(
)
"
Not
first
continuation
"
)
;
return
-
nsLayoutUtils
:
:
GetAllInFlowRectsUnion
(
aFrame
aFrame
)
.
TopLeft
(
)
;
}
nsSize
nsSVGIntegrationUtils
:
:
GetContinuationUnionSize
(
nsIFrame
*
aNonSVGFrame
)
{
NS_ASSERTION
(
!
aNonSVGFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
"
SVG
frames
should
not
get
here
"
)
;
nsIFrame
*
firstFrame
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
aNonSVGFrame
)
;
return
nsLayoutUtils
:
:
GetAllInFlowRectsUnion
(
firstFrame
firstFrame
)
.
Size
(
)
;
}
gfx
:
:
Size
nsSVGIntegrationUtils
:
:
GetSVGCoordContextForNonSVGFrame
(
nsIFrame
*
aNonSVGFrame
)
{
NS_ASSERTION
(
!
aNonSVGFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
"
SVG
frames
should
not
get
here
"
)
;
nsIFrame
*
firstFrame
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
aNonSVGFrame
)
;
nsRect
r
=
nsLayoutUtils
:
:
GetAllInFlowRectsUnion
(
firstFrame
firstFrame
)
;
nsPresContext
*
presContext
=
firstFrame
-
>
PresContext
(
)
;
return
gfx
:
:
Size
(
presContext
-
>
AppUnitsToFloatCSSPixels
(
r
.
width
)
presContext
-
>
AppUnitsToFloatCSSPixels
(
r
.
height
)
)
;
}
gfxRect
nsSVGIntegrationUtils
:
:
GetSVGBBoxForNonSVGFrame
(
nsIFrame
*
aNonSVGFrame
)
{
NS_ASSERTION
(
!
aNonSVGFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
"
SVG
frames
should
not
get
here
"
)
;
nsIFrame
*
firstFrame
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
aNonSVGFrame
)
;
nsRect
r
=
GetPreEffectsVisualOverflowUnion
(
firstFrame
nullptr
nsRect
(
)
GetOffsetToBoundingBox
(
firstFrame
)
)
;
return
nsLayoutUtils
:
:
RectToGfxRect
(
r
aNonSVGFrame
-
>
PresContext
(
)
-
>
AppUnitsPerCSSPixel
(
)
)
;
}
nsRect
nsSVGIntegrationUtils
:
:
ComputePostEffectsVisualOverflowRect
(
nsIFrame
*
aFrame
const
nsRect
&
aPreEffectsOverflowRect
)
{
NS_ASSERTION
(
!
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_SVG_LAYOUT
)
"
Don
'
t
call
this
on
SVG
child
frames
"
)
;
nsIFrame
*
firstFrame
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
aFrame
)
;
nsSVGEffects
:
:
EffectProperties
effectProperties
=
nsSVGEffects
:
:
GetEffectProperties
(
firstFrame
)
;
if
(
!
effectProperties
.
HasValidFilter
(
)
)
{
return
aPreEffectsOverflowRect
;
}
nsPoint
firstFrameToBoundingBox
=
GetOffsetToBoundingBox
(
firstFrame
)
;
gfxRect
overrideBBox
=
nsLayoutUtils
:
:
RectToGfxRect
(
GetPreEffectsVisualOverflowUnion
(
firstFrame
aFrame
aPreEffectsOverflowRect
firstFrameToBoundingBox
)
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerCSSPixel
(
)
)
;
overrideBBox
.
RoundOut
(
)
;
nsRect
overflowRect
=
nsFilterInstance
:
:
GetPostFilterBounds
(
firstFrame
&
overrideBBox
)
;
return
overflowRect
-
(
aFrame
-
>
GetOffsetTo
(
firstFrame
)
+
firstFrameToBoundingBox
)
;
}
nsIntRegion
nsSVGIntegrationUtils
:
:
AdjustInvalidAreaForSVGEffects
(
nsIFrame
*
aFrame
const
nsPoint
&
aToReferenceFrame
const
nsIntRegion
&
aInvalidRegion
)
{
if
(
aInvalidRegion
.
IsEmpty
(
)
)
{
return
nsIntRect
(
)
;
}
nsIFrame
*
firstFrame
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
aFrame
)
;
nsSVGFilterProperty
*
prop
=
nsSVGEffects
:
:
GetFilterProperty
(
firstFrame
)
;
if
(
!
prop
|
|
!
prop
-
>
IsInObserverLists
(
)
)
{
return
aInvalidRegion
;
}
int32_t
appUnitsPerDevPixel
=
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
if
(
!
prop
|
|
!
prop
-
>
ReferencesValidResources
(
)
)
{
nsRect
overflow
=
aFrame
-
>
GetVisualOverflowRect
(
)
+
aToReferenceFrame
;
return
overflow
.
ToOutsidePixels
(
appUnitsPerDevPixel
)
;
}
nsPoint
toBoundingBox
=
aFrame
-
>
GetOffsetTo
(
firstFrame
)
+
GetOffsetToBoundingBox
(
firstFrame
)
;
toBoundingBox
-
=
aToReferenceFrame
;
nsRegion
preEffectsRegion
=
aInvalidRegion
.
ToAppUnits
(
appUnitsPerDevPixel
)
.
MovedBy
(
toBoundingBox
)
;
nsRegion
result
=
nsFilterInstance
:
:
GetPostFilterDirtyArea
(
firstFrame
preEffectsRegion
)
.
MovedBy
(
-
toBoundingBox
)
;
return
result
.
ToOutsidePixels
(
appUnitsPerDevPixel
)
;
}
nsRect
nsSVGIntegrationUtils
:
:
GetRequiredSourceForInvalidArea
(
nsIFrame
*
aFrame
const
nsRect
&
aDirtyRect
)
{
nsIFrame
*
firstFrame
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
aFrame
)
;
nsSVGFilterProperty
*
prop
=
nsSVGEffects
:
:
GetFilterProperty
(
firstFrame
)
;
if
(
!
prop
|
|
!
prop
-
>
ReferencesValidResources
(
)
)
{
return
aDirtyRect
;
}
nsPoint
toUserSpace
=
aFrame
-
>
GetOffsetTo
(
firstFrame
)
+
GetOffsetToBoundingBox
(
firstFrame
)
;
nsRect
postEffectsRect
=
aDirtyRect
+
toUserSpace
;
return
nsFilterInstance
:
:
GetPreFilterNeededArea
(
firstFrame
postEffectsRect
)
.
GetBounds
(
)
-
toUserSpace
;
}
bool
nsSVGIntegrationUtils
:
:
HitTestFrameForEffects
(
nsIFrame
*
aFrame
const
nsPoint
&
aPt
)
{
nsIFrame
*
firstFrame
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
aFrame
)
;
nsPoint
toUserSpace
;
if
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_SVG_LAYOUT
)
{
toUserSpace
=
aFrame
-
>
GetPosition
(
)
;
}
else
{
toUserSpace
=
aFrame
-
>
GetOffsetTo
(
firstFrame
)
+
GetOffsetToBoundingBox
(
firstFrame
)
;
}
nsPoint
pt
=
aPt
+
toUserSpace
;
gfxPoint
userSpacePt
=
gfxPoint
(
pt
.
x
pt
.
y
)
/
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerCSSPixel
(
)
;
return
nsSVGUtils
:
:
HitTestClip
(
firstFrame
userSpacePt
)
;
}
class
RegularFramePaintCallback
:
public
nsSVGFilterPaintCallback
{
public
:
RegularFramePaintCallback
(
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aManager
const
nsPoint
&
aOffset
)
:
mBuilder
(
aBuilder
)
mLayerManager
(
aManager
)
mOffset
(
aOffset
)
{
}
virtual
void
Paint
(
gfxContext
&
aContext
nsIFrame
*
aTarget
const
gfxMatrix
&
aTransform
const
nsIntRect
*
aDirtyRect
)
override
{
BasicLayerManager
*
basic
=
static_cast
<
BasicLayerManager
*
>
(
mLayerManager
)
;
basic
-
>
SetTarget
(
&
aContext
)
;
gfxPoint
devPixelOffset
=
nsLayoutUtils
:
:
PointToGfxPoint
(
-
mOffset
aTarget
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
gfxContextMatrixAutoSaveRestore
autoSR
(
&
aContext
)
;
aContext
.
SetMatrix
(
aContext
.
CurrentMatrix
(
)
.
Translate
(
devPixelOffset
)
)
;
mLayerManager
-
>
EndTransaction
(
FrameLayerBuilder
:
:
DrawPaintedLayer
mBuilder
)
;
}
private
:
nsDisplayListBuilder
*
mBuilder
;
LayerManager
*
mLayerManager
;
nsPoint
mOffset
;
}
;
void
nsSVGIntegrationUtils
:
:
PaintFramesWithEffects
(
gfxContext
&
aContext
nsIFrame
*
aFrame
const
nsRect
&
aDirtyRect
const
nsRect
&
aBorderArea
nsDisplayListBuilder
*
aBuilder
LayerManager
*
aLayerManager
)
{
#
ifdef
DEBUG
NS_ASSERTION
(
!
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_SVG_LAYOUT
)
|
|
(
NS_SVGDisplayListPaintingEnabled
(
)
&
&
!
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_IS_NONDISPLAY
)
)
"
Should
not
use
nsSVGIntegrationUtils
on
this
SVG
frame
"
)
;
#
endif
const
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
bool
hasSVGLayout
=
(
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_SVG_LAYOUT
)
;
if
(
hasSVGLayout
)
{
nsISVGChildFrame
*
svgChildFrame
=
do_QueryFrame
(
aFrame
)
;
if
(
!
svgChildFrame
|
|
!
aFrame
-
>
GetContent
(
)
-
>
IsSVGElement
(
)
)
{
NS_ASSERTION
(
false
"
why
?
"
)
;
return
;
}
if
(
!
static_cast
<
const
nsSVGElement
*
>
(
content
)
-
>
HasValidDimensions
(
)
)
{
return
;
}
}
float
opacity
=
aFrame
-
>
StyleDisplay
(
)
-
>
mOpacity
;
if
(
opacity
=
=
0
.
0f
)
{
return
;
}
if
(
opacity
!
=
1
.
0f
&
&
hasSVGLayout
&
&
nsSVGUtils
:
:
CanOptimizeOpacity
(
aFrame
)
)
{
opacity
=
1
.
0f
;
}
nsIFrame
*
firstFrame
=
nsLayoutUtils
:
:
FirstContinuationOrIBSplitSibling
(
aFrame
)
;
nsSVGEffects
:
:
EffectProperties
effectProperties
=
nsSVGEffects
:
:
GetEffectProperties
(
firstFrame
)
;
bool
isOK
=
effectProperties
.
HasNoFilterOrHasValidFilter
(
)
;
nsSVGClipPathFrame
*
clipPathFrame
=
effectProperties
.
GetClipPathFrame
(
&
isOK
)
;
bool
isTrivialClip
=
clipPathFrame
?
clipPathFrame
-
>
IsTrivial
(
)
:
true
;
DrawTarget
*
drawTarget
=
aContext
.
GetDrawTarget
(
)
;
gfxContextMatrixAutoSaveRestore
matrixAutoSaveRestore
(
&
aContext
)
;
nsPoint
firstFrameOffset
=
GetOffsetToBoundingBox
(
firstFrame
)
;
nsPoint
offsetToBoundingBox
=
aBuilder
-
>
ToReferenceFrame
(
firstFrame
)
-
firstFrameOffset
;
if
(
!
firstFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
)
{
offsetToBoundingBox
=
nsPoint
(
aFrame
-
>
PresContext
(
)
-
>
RoundAppUnitsToNearestDevPixels
(
offsetToBoundingBox
.
x
)
aFrame
-
>
PresContext
(
)
-
>
RoundAppUnitsToNearestDevPixels
(
offsetToBoundingBox
.
y
)
)
;
}
gfxPoint
toUserSpaceGfx
=
nsSVGUtils
:
:
FrameSpaceInCSSPxToUserSpaceOffset
(
aFrame
)
;
nsPoint
toUserSpace
(
nsPresContext
:
:
CSSPixelsToAppUnits
(
float
(
toUserSpaceGfx
.
x
)
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
float
(
toUserSpaceGfx
.
y
)
)
)
;
nsPoint
offsetToUserSpace
=
offsetToBoundingBox
-
toUserSpace
;
NS_ASSERTION
(
hasSVGLayout
|
|
offsetToBoundingBox
=
=
offsetToUserSpace
"
For
non
-
SVG
frames
there
shouldn
'
t
be
any
additional
offset
"
)
;
gfxPoint
devPixelOffsetToUserSpace
=
nsLayoutUtils
:
:
PointToGfxPoint
(
offsetToUserSpace
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
aContext
.
SetMatrix
(
aContext
.
CurrentMatrix
(
)
.
Translate
(
devPixelOffsetToUserSpace
)
)
;
gfxMatrix
cssPxToDevPxMatrix
=
GetCSSPxToDevPxMatrix
(
aFrame
)
;
const
nsStyleSVGReset
*
svgReset
=
firstFrame
-
>
StyleSVGReset
(
)
;
nsSVGMaskFrame
*
svgMaskFrame
=
effectProperties
.
GetMaskFrame
(
&
isOK
)
;
bool
complexEffects
=
false
;
bool
hasValidLayers
=
svgReset
-
>
mMask
.
HasLayerWithImage
(
)
;
RefPtr
<
gfxContext
>
target
=
&
aContext
;
IntPoint
targetOffset
;
if
(
opacity
!
=
1
.
0f
|
|
(
clipPathFrame
&
&
!
isTrivialClip
)
|
|
aFrame
-
>
StyleDisplay
(
)
-
>
mMixBlendMode
!
=
NS_STYLE_BLEND_NORMAL
|
|
svgMaskFrame
|
|
hasValidLayers
)
{
complexEffects
=
true
;
aContext
.
Save
(
)
;
nsRect
clipRect
=
aFrame
-
>
GetVisualOverflowRectRelativeToSelf
(
)
+
toUserSpace
;
aContext
.
Clip
(
NSRectToSnappedRect
(
clipRect
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
*
drawTarget
)
)
;
Matrix
maskTransform
;
RefPtr
<
SourceSurface
>
maskSurface
;
if
(
svgMaskFrame
)
{
maskSurface
=
svgMaskFrame
-
>
GetMaskForMaskedFrame
(
&
aContext
aFrame
cssPxToDevPxMatrix
opacity
&
maskTransform
)
;
}
else
if
(
hasValidLayers
)
{
gfxRect
clipRect
=
aContext
.
GetClipExtents
(
)
;
{
gfxContextMatrixAutoSaveRestore
matRestore
(
&
aContext
)
;
aContext
.
SetMatrix
(
gfxMatrix
(
)
)
;
clipRect
=
aContext
.
GetClipExtents
(
)
;
}
IntRect
drawRect
=
RoundedOut
(
ToRect
(
clipRect
)
)
;
RefPtr
<
DrawTarget
>
targetDT
=
aContext
.
GetDrawTarget
(
)
-
>
CreateSimilarDrawTarget
(
drawRect
.
Size
(
)
SurfaceFormat
:
:
A8
)
;
if
(
!
targetDT
)
{
aContext
.
Restore
(
)
;
return
;
}
RefPtr
<
gfxContext
>
target
=
new
gfxContext
(
targetDT
)
;
target
-
>
SetMatrix
(
matrixAutoSaveRestore
.
Matrix
(
)
*
gfxMatrix
:
:
Translation
(
-
drawRect
.
TopLeft
(
)
)
)
;
uint32_t
flags
=
aBuilder
-
>
GetBackgroundPaintFlags
(
)
|
nsCSSRendering
:
:
PAINTBG_MASK_IMAGE
;
nsRenderingContext
rc
(
target
)
;
nsCSSRendering
:
:
PaintBackgroundWithSC
(
aFrame
-
>
PresContext
(
)
rc
aFrame
aDirtyRect
aBorderArea
firstFrame
-
>
StyleContext
(
)
*
aFrame
-
>
StyleBorder
(
)
flags
nullptr
-
1
)
;
maskSurface
=
targetDT
-
>
Snapshot
(
)
;
Matrix
mat
=
ToMatrix
(
aContext
.
CurrentMatrix
(
)
)
;
mat
.
Invert
(
)
;
maskTransform
=
Matrix
:
:
Translation
(
drawRect
.
x
drawRect
.
y
)
*
mat
;
}
if
(
(
svgMaskFrame
|
|
hasValidLayers
)
&
&
!
maskSurface
)
{
aContext
.
Restore
(
)
;
return
;
}
if
(
aFrame
-
>
StyleDisplay
(
)
-
>
mMixBlendMode
!
=
NS_STYLE_BLEND_NORMAL
)
{
gfxRect
clipRect
;
{
gfxContextMatrixAutoSaveRestore
matRestore
(
&
aContext
)
;
aContext
.
SetMatrix
(
gfxMatrix
(
)
)
;
clipRect
=
aContext
.
GetClipExtents
(
)
;
}
IntRect
drawRect
=
RoundedOut
(
ToRect
(
clipRect
)
)
;
RefPtr
<
DrawTarget
>
targetDT
=
aContext
.
GetDrawTarget
(
)
-
>
CreateSimilarDrawTarget
(
drawRect
.
Size
(
)
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
!
targetDT
)
{
aContext
.
Restore
(
)
;
return
;
}
target
=
new
gfxContext
(
targetDT
)
;
target
-
>
SetMatrix
(
aContext
.
CurrentMatrix
(
)
*
gfxMatrix
:
:
Translation
(
-
drawRect
.
TopLeft
(
)
)
)
;
targetOffset
=
drawRect
.
TopLeft
(
)
;
}
if
(
clipPathFrame
&
&
!
isTrivialClip
)
{
Matrix
clippedMaskTransform
;
RefPtr
<
SourceSurface
>
clipMaskSurface
=
clipPathFrame
-
>
GetClipMask
(
aContext
aFrame
cssPxToDevPxMatrix
&
clippedMaskTransform
maskSurface
maskTransform
)
;
if
(
clipMaskSurface
)
{
maskSurface
=
clipMaskSurface
;
maskTransform
=
clippedMaskTransform
;
}
}
if
(
opacity
!
=
1
.
0f
|
|
svgMaskFrame
|
|
hasValidLayers
|
|
(
clipPathFrame
&
&
!
isTrivialClip
)
)
{
target
-
>
PushGroupForBlendBack
(
gfxContentType
:
:
COLOR_ALPHA
opacity
maskSurface
maskTransform
)
;
}
}
if
(
clipPathFrame
&
&
isTrivialClip
)
{
aContext
.
Save
(
)
;
clipPathFrame
-
>
ApplyClipPath
(
aContext
aFrame
cssPxToDevPxMatrix
)
;
}
else
if
(
!
clipPathFrame
&
&
svgReset
-
>
HasClipPath
(
)
)
{
aContext
.
Save
(
)
;
nsCSSClipPathInstance
:
:
ApplyBasicShapeClip
(
aContext
aFrame
)
;
}
if
(
effectProperties
.
HasValidFilter
(
)
)
{
RegularFramePaintCallback
callback
(
aBuilder
aLayerManager
offsetToUserSpace
)
;
nsRegion
dirtyRegion
=
aDirtyRect
-
offsetToBoundingBox
;
gfxMatrix
tm
=
nsSVGIntegrationUtils
:
:
GetCSSPxToDevPxMatrix
(
aFrame
)
;
nsFilterInstance
:
:
PaintFilteredFrame
(
aFrame
target
-
>
GetDrawTarget
(
)
tm
&
callback
&
dirtyRegion
)
;
}
else
{
target
-
>
SetMatrix
(
matrixAutoSaveRestore
.
Matrix
(
)
)
;
BasicLayerManager
*
basic
=
static_cast
<
BasicLayerManager
*
>
(
aLayerManager
)
;
RefPtr
<
gfxContext
>
oldCtx
=
basic
-
>
GetTarget
(
)
;
basic
-
>
SetTarget
(
target
)
;
aLayerManager
-
>
EndTransaction
(
FrameLayerBuilder
:
:
DrawPaintedLayer
aBuilder
)
;
basic
-
>
SetTarget
(
oldCtx
)
;
}
if
(
(
clipPathFrame
&
&
isTrivialClip
)
|
|
(
!
clipPathFrame
&
&
svgReset
-
>
HasClipPath
(
)
)
)
{
aContext
.
Restore
(
)
;
}
if
(
!
complexEffects
)
{
return
;
}
if
(
opacity
!
=
1
.
0f
|
|
svgMaskFrame
|
|
hasValidLayers
|
|
(
clipPathFrame
&
&
!
isTrivialClip
)
)
{
target
-
>
PopGroupAndBlend
(
)
;
}
if
(
aFrame
-
>
StyleDisplay
(
)
-
>
mMixBlendMode
!
=
NS_STYLE_BLEND_NORMAL
)
{
RefPtr
<
DrawTarget
>
targetDT
=
target
-
>
GetDrawTarget
(
)
;
target
=
nullptr
;
RefPtr
<
SourceSurface
>
targetSurf
=
targetDT
-
>
Snapshot
(
)
;
aContext
.
SetMatrix
(
gfxMatrix
(
)
)
;
RefPtr
<
gfxPattern
>
pattern
=
new
gfxPattern
(
targetSurf
Matrix
:
:
Translation
(
targetOffset
.
x
targetOffset
.
y
)
)
;
aContext
.
SetPattern
(
pattern
)
;
aContext
.
Paint
(
)
;
}
aContext
.
Restore
(
)
;
}
gfxMatrix
nsSVGIntegrationUtils
:
:
GetCSSPxToDevPxMatrix
(
nsIFrame
*
aNonSVGFrame
)
{
int32_t
appUnitsPerDevPixel
=
aNonSVGFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
float
devPxPerCSSPx
=
1
/
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
appUnitsPerDevPixel
)
;
return
gfxMatrix
(
devPxPerCSSPx
0
.
0
0
.
0
devPxPerCSSPx
0
.
0
0
.
0
)
;
}
class
PaintFrameCallback
:
public
gfxDrawingCallback
{
public
:
PaintFrameCallback
(
nsIFrame
*
aFrame
const
nsSize
aPaintServerSize
const
IntSize
aRenderSize
uint32_t
aFlags
)
:
mFrame
(
aFrame
)
mPaintServerSize
(
aPaintServerSize
)
mRenderSize
(
aRenderSize
)
mFlags
(
aFlags
)
{
}
virtual
bool
operator
(
)
(
gfxContext
*
aContext
const
gfxRect
&
aFillRect
const
Filter
&
aFilter
const
gfxMatrix
&
aTransform
)
override
;
private
:
nsIFrame
*
mFrame
;
nsSize
mPaintServerSize
;
IntSize
mRenderSize
;
uint32_t
mFlags
;
}
;
bool
PaintFrameCallback
:
:
operator
(
)
(
gfxContext
*
aContext
const
gfxRect
&
aFillRect
const
Filter
&
aFilter
const
gfxMatrix
&
aTransform
)
{
if
(
mFrame
-
>
GetStateBits
(
)
&
NS_FRAME_DRAWING_AS_PAINTSERVER
)
return
false
;
mFrame
-
>
AddStateBits
(
NS_FRAME_DRAWING_AS_PAINTSERVER
)
;
aContext
-
>
Save
(
)
;
aContext
-
>
NewPath
(
)
;
aContext
-
>
Rectangle
(
aFillRect
)
;
aContext
-
>
Clip
(
)
;
gfxMatrix
invmatrix
=
aTransform
;
if
(
!
invmatrix
.
Invert
(
)
)
{
return
false
;
}
aContext
-
>
Multiply
(
invmatrix
)
;
int32_t
appUnitsPerDevPixel
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
nsPoint
offset
=
GetOffsetToBoundingBox
(
mFrame
)
;
gfxPoint
devPxOffset
=
gfxPoint
(
offset
.
x
offset
.
y
)
/
appUnitsPerDevPixel
;
aContext
-
>
Multiply
(
gfxMatrix
:
:
Translation
(
devPxOffset
)
)
;
gfxSize
paintServerSize
=
gfxSize
(
mPaintServerSize
.
width
mPaintServerSize
.
height
)
/
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
gfxFloat
scaleX
=
mRenderSize
.
width
/
paintServerSize
.
width
;
gfxFloat
scaleY
=
mRenderSize
.
height
/
paintServerSize
.
height
;
aContext
-
>
Multiply
(
gfxMatrix
:
:
Scaling
(
scaleX
scaleY
)
)
;
nsRect
dirty
(
-
offset
.
x
-
offset
.
y
mPaintServerSize
.
width
mPaintServerSize
.
height
)
;
uint32_t
flags
=
nsLayoutUtils
:
:
PAINT_IN_TRANSFORM
;
if
(
mFlags
&
nsSVGIntegrationUtils
:
:
FLAG_SYNC_DECODE_IMAGES
)
{
flags
|
=
nsLayoutUtils
:
:
PAINT_SYNC_DECODE_IMAGES
;
}
nsRenderingContext
context
(
aContext
)
;
nsLayoutUtils
:
:
PaintFrame
(
&
context
mFrame
dirty
NS_RGBA
(
0
0
0
0
)
flags
)
;
nsIFrame
*
currentFrame
=
mFrame
;
while
(
(
currentFrame
=
currentFrame
-
>
GetNextContinuation
(
)
)
!
=
nullptr
)
{
offset
=
currentFrame
-
>
GetOffsetToCrossDoc
(
mFrame
)
;
devPxOffset
=
gfxPoint
(
offset
.
x
offset
.
y
)
/
appUnitsPerDevPixel
;
aContext
-
>
Save
(
)
;
aContext
-
>
Multiply
(
gfxMatrix
:
:
Scaling
(
1
/
scaleX
1
/
scaleY
)
)
;
aContext
-
>
Multiply
(
gfxMatrix
:
:
Translation
(
devPxOffset
)
)
;
aContext
-
>
Multiply
(
gfxMatrix
:
:
Scaling
(
scaleX
scaleY
)
)
;
nsLayoutUtils
:
:
PaintFrame
(
&
context
currentFrame
dirty
-
offset
NS_RGBA
(
0
0
0
0
)
flags
)
;
aContext
-
>
Restore
(
)
;
}
aContext
-
>
Restore
(
)
;
mFrame
-
>
RemoveStateBits
(
NS_FRAME_DRAWING_AS_PAINTSERVER
)
;
return
true
;
}
already_AddRefed
<
gfxDrawable
>
nsSVGIntegrationUtils
:
:
DrawableFromPaintServer
(
nsIFrame
*
aFrame
nsIFrame
*
aTarget
const
nsSize
&
aPaintServerSize
const
IntSize
&
aRenderSize
const
DrawTarget
*
aDrawTarget
const
gfxMatrix
&
aContextMatrix
uint32_t
aFlags
)
{
if
(
aFrame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVGPaintServer
)
)
{
nsSVGPaintServerFrame
*
server
=
static_cast
<
nsSVGPaintServerFrame
*
>
(
aFrame
)
;
gfxRect
overrideBounds
(
0
0
aPaintServerSize
.
width
aPaintServerSize
.
height
)
;
overrideBounds
.
ScaleInverse
(
aFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
RefPtr
<
gfxPattern
>
pattern
=
server
-
>
GetPaintServerPattern
(
aTarget
aDrawTarget
aContextMatrix
&
nsStyleSVG
:
:
mFill
1
.
0
&
overrideBounds
)
;
if
(
!
pattern
)
return
nullptr
;
gfxFloat
scaleX
=
overrideBounds
.
Width
(
)
/
aRenderSize
.
width
;
gfxFloat
scaleY
=
overrideBounds
.
Height
(
)
/
aRenderSize
.
height
;
gfxMatrix
scaleMatrix
=
gfxMatrix
:
:
Scaling
(
scaleX
scaleY
)
;
pattern
-
>
SetMatrix
(
scaleMatrix
*
pattern
-
>
GetMatrix
(
)
)
;
RefPtr
<
gfxDrawable
>
drawable
=
new
gfxPatternDrawable
(
pattern
aRenderSize
)
;
return
drawable
.
forget
(
)
;
}
RefPtr
<
gfxDrawingCallback
>
cb
=
new
PaintFrameCallback
(
aFrame
aPaintServerSize
aRenderSize
aFlags
)
;
RefPtr
<
gfxDrawable
>
drawable
=
new
gfxCallbackDrawable
(
cb
aRenderSize
)
;
return
drawable
.
forget
(
)
;
}
