#
include
"
SVGMaskFrame
.
h
"
#
include
"
AutoReferenceChainGuard
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
dom
/
SVGMaskElement
.
h
"
#
include
"
mozilla
/
dom
/
SVGUnitTypesBinding
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
SVGObserverUtils
.
h
"
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
dom
:
:
SVGUnitTypes_Binding
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
image
;
nsIFrame
*
NS_NewSVGMaskFrame
(
mozilla
:
:
PresShell
*
aPresShell
mozilla
:
:
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
mozilla
:
:
SVGMaskFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
namespace
mozilla
{
NS_IMPL_FRAMEARENA_HELPERS
(
SVGMaskFrame
)
already_AddRefed
<
SourceSurface
>
SVGMaskFrame
:
:
GetMaskForMaskedFrame
(
MaskParams
&
aParams
)
{
static
int16_t
sRefChainLengthCounter
=
AutoReferenceChainGuard
:
:
noChain
;
AutoReferenceChainGuard
refChainGuard
(
this
&
mInUse
&
sRefChainLengthCounter
)
;
if
(
MOZ_UNLIKELY
(
!
refChainGuard
.
Reference
(
)
)
)
{
return
nullptr
;
}
gfxRect
maskArea
=
GetMaskArea
(
aParams
.
maskedFrame
)
;
if
(
maskArea
.
IsEmpty
(
)
)
{
return
nullptr
;
}
gfxContext
*
context
=
aParams
.
ctx
;
gfxRect
maskSurfaceRectDouble
=
aParams
.
toUserSpace
.
TransformBounds
(
maskArea
)
;
Rect
maskSurfaceRect
=
ToRect
(
maskSurfaceRectDouble
)
;
maskSurfaceRect
.
RoundOut
(
)
;
StyleMaskType
maskType
;
if
(
aParams
.
maskMode
=
=
StyleMaskMode
:
:
MatchSource
)
{
maskType
=
StyleSVGReset
(
)
-
>
mMaskType
;
}
else
{
maskType
=
aParams
.
maskMode
=
=
StyleMaskMode
:
:
Luminance
?
StyleMaskType
:
:
Luminance
:
StyleMaskType
:
:
Alpha
;
}
RefPtr
<
DrawTarget
>
maskDT
;
if
(
maskType
=
=
StyleMaskType
:
:
Luminance
)
{
maskDT
=
context
-
>
GetDrawTarget
(
)
-
>
CreateClippedDrawTarget
(
maskSurfaceRect
SurfaceFormat
:
:
B8G8R8A8
)
;
}
else
{
maskDT
=
context
-
>
GetDrawTarget
(
)
-
>
CreateClippedDrawTarget
(
maskSurfaceRect
SurfaceFormat
:
:
A8
)
;
}
if
(
!
maskDT
|
|
!
maskDT
-
>
IsValid
(
)
)
{
return
nullptr
;
}
RefPtr
<
gfxContext
>
tmpCtx
=
gfxContext
:
:
CreatePreservingTransformOrNull
(
maskDT
)
;
MOZ_ASSERT
(
tmpCtx
)
;
mMatrixForChildren
=
GetMaskTransform
(
aParams
.
maskedFrame
)
*
aParams
.
toUserSpace
;
for
(
nsIFrame
*
kid
=
mFrames
.
FirstChild
(
)
;
kid
;
kid
=
kid
-
>
GetNextSibling
(
)
)
{
gfxMatrix
m
=
mMatrixForChildren
;
ISVGDisplayableFrame
*
SVGFrame
=
do_QueryFrame
(
kid
)
;
if
(
SVGFrame
)
{
SVGFrame
-
>
NotifySVGChanged
(
ISVGDisplayableFrame
:
:
TRANSFORM_CHANGED
)
;
m
=
nsSVGUtils
:
:
GetTransformMatrixInUserSpace
(
kid
)
*
m
;
}
nsSVGUtils
:
:
PaintFrameWithEffects
(
kid
*
tmpCtx
m
aParams
.
imgParams
)
;
}
RefPtr
<
SourceSurface
>
surface
;
if
(
maskType
=
=
StyleMaskType
:
:
Luminance
)
{
auto
luminanceType
=
LuminanceType
:
:
LUMINANCE
;
if
(
StyleSVG
(
)
-
>
mColorInterpolation
=
=
StyleColorInterpolation
:
:
Linearrgb
)
{
luminanceType
=
LuminanceType
:
:
LINEARRGB
;
}
RefPtr
<
SourceSurface
>
maskSnapshot
=
maskDT
-
>
IntoLuminanceSource
(
luminanceType
aParams
.
opacity
)
;
if
(
!
maskSnapshot
)
{
return
nullptr
;
}
surface
=
std
:
:
move
(
maskSnapshot
)
;
}
else
{
maskDT
-
>
FillRect
(
maskSurfaceRect
ColorPattern
(
DeviceColor
:
:
MaskWhite
(
aParams
.
opacity
)
)
DrawOptions
(
1
CompositionOp
:
:
OP_IN
)
)
;
RefPtr
<
SourceSurface
>
maskSnapshot
=
maskDT
-
>
Snapshot
(
)
;
if
(
!
maskSnapshot
)
{
return
nullptr
;
}
surface
=
std
:
:
move
(
maskSnapshot
)
;
}
return
surface
.
forget
(
)
;
}
gfxRect
SVGMaskFrame
:
:
GetMaskArea
(
nsIFrame
*
aMaskedFrame
)
{
SVGMaskElement
*
maskElem
=
static_cast
<
SVGMaskElement
*
>
(
GetContent
(
)
)
;
uint16_t
units
=
maskElem
-
>
mEnumAttributes
[
SVGMaskElement
:
:
MASKUNITS
]
.
GetAnimValue
(
)
;
gfxRect
bbox
;
if
(
units
=
=
SVG_UNIT_TYPE_OBJECTBOUNDINGBOX
)
{
bbox
=
nsSVGUtils
:
:
GetBBox
(
aMaskedFrame
nsSVGUtils
:
:
eUseFrameBoundsForOuterSVG
|
nsSVGUtils
:
:
eBBoxIncludeFillGeometry
)
;
}
gfxRect
maskArea
=
nsSVGUtils
:
:
GetRelativeRect
(
units
&
maskElem
-
>
mLengthAttributes
[
SVGMaskElement
:
:
ATTR_X
]
bbox
aMaskedFrame
)
;
return
maskArea
;
}
nsresult
SVGMaskFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
if
(
aNameSpaceID
=
=
kNameSpaceID_None
&
&
(
aAttribute
=
=
nsGkAtoms
:
:
x
|
|
aAttribute
=
=
nsGkAtoms
:
:
y
|
|
aAttribute
=
=
nsGkAtoms
:
:
width
|
|
aAttribute
=
=
nsGkAtoms
:
:
height
|
|
aAttribute
=
=
nsGkAtoms
:
:
maskUnits
|
|
aAttribute
=
=
nsGkAtoms
:
:
maskContentUnits
)
)
{
SVGObserverUtils
:
:
InvalidateDirectRenderingObservers
(
this
)
;
}
return
SVGContainerFrame
:
:
AttributeChanged
(
aNameSpaceID
aAttribute
aModType
)
;
}
#
ifdef
DEBUG
void
SVGMaskFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
NS_ASSERTION
(
aContent
-
>
IsSVGElement
(
nsGkAtoms
:
:
mask
)
"
Content
is
not
an
SVG
mask
"
)
;
SVGContainerFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
}
#
endif
gfxMatrix
SVGMaskFrame
:
:
GetCanvasTM
(
)
{
return
mMatrixForChildren
;
}
gfxMatrix
SVGMaskFrame
:
:
GetMaskTransform
(
nsIFrame
*
aMaskedFrame
)
{
SVGMaskElement
*
content
=
static_cast
<
SVGMaskElement
*
>
(
GetContent
(
)
)
;
SVGAnimatedEnumeration
*
maskContentUnits
=
&
content
-
>
mEnumAttributes
[
SVGMaskElement
:
:
MASKCONTENTUNITS
]
;
uint32_t
flags
=
nsSVGUtils
:
:
eBBoxIncludeFillGeometry
|
(
aMaskedFrame
-
>
StyleBorder
(
)
-
>
mBoxDecorationBreak
=
=
StyleBoxDecorationBreak
:
:
Clone
?
nsSVGUtils
:
:
eIncludeOnlyCurrentFrameForNonSVGElement
:
0
)
;
return
nsSVGUtils
:
:
AdjustMatrixForUnits
(
gfxMatrix
(
)
maskContentUnits
aMaskedFrame
flags
)
;
}
}
