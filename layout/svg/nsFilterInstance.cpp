#
include
"
nsFilterInstance
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
ImgDrawResult
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
gfxPrefs
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
mozilla
/
gfx
/
Helpers
.
h
"
#
include
"
mozilla
/
gfx
/
PatternHelpers
.
h
"
#
include
"
nsSVGDisplayableFrame
.
h
"
#
include
"
nsCSSFilterInstance
.
h
"
#
include
"
nsSVGFilterInstance
.
h
"
#
include
"
nsSVGFilterPaintCallback
.
h
"
#
include
"
nsSVGUtils
.
h
"
#
include
"
SVGContentUtils
.
h
"
#
include
"
FilterSupport
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
image
;
FilterDescription
nsFilterInstance
:
:
GetFilterDescription
(
nsIContent
*
aFilteredElement
const
nsTArray
<
nsStyleFilter
>
&
aFilterChain
bool
aFilterInputIsTainted
const
UserSpaceMetrics
&
aMetrics
const
gfxRect
&
aBBox
nsTArray
<
RefPtr
<
SourceSurface
>
>
&
aOutAdditionalImages
)
{
gfxMatrix
identity
;
nsFilterInstance
instance
(
nullptr
aFilteredElement
aMetrics
aFilterChain
aFilterInputIsTainted
nullptr
identity
nullptr
nullptr
nullptr
&
aBBox
)
;
if
(
!
instance
.
IsInitialized
(
)
)
{
return
FilterDescription
(
)
;
}
return
instance
.
ExtractDescriptionAndAdditionalImages
(
aOutAdditionalImages
)
;
}
static
UniquePtr
<
UserSpaceMetrics
>
UserSpaceMetricsForFrame
(
nsIFrame
*
aFrame
)
{
if
(
aFrame
-
>
GetContent
(
)
-
>
IsSVGElement
(
)
)
{
SVGElement
*
element
=
static_cast
<
SVGElement
*
>
(
aFrame
-
>
GetContent
(
)
)
;
return
MakeUnique
<
SVGElementMetrics
>
(
element
)
;
}
return
MakeUnique
<
NonSVGFrameUserSpaceMetrics
>
(
aFrame
)
;
}
void
nsFilterInstance
:
:
PaintFilteredFrame
(
nsIFrame
*
aFilteredFrame
gfxContext
*
aCtx
nsSVGFilterPaintCallback
*
aPaintCallback
const
nsRegion
*
aDirtyArea
imgDrawingParams
&
aImgParams
float
aOpacity
)
{
auto
&
filterChain
=
aFilteredFrame
-
>
StyleEffects
(
)
-
>
mFilters
;
UniquePtr
<
UserSpaceMetrics
>
metrics
=
UserSpaceMetricsForFrame
(
aFilteredFrame
)
;
gfxContextMatrixAutoSaveRestore
autoSR
(
aCtx
)
;
gfxSize
scaleFactors
=
aCtx
-
>
CurrentMatrixDouble
(
)
.
ScaleFactors
(
true
)
;
if
(
scaleFactors
.
IsEmpty
(
)
)
{
return
;
}
gfxMatrix
scaleMatrix
(
scaleFactors
.
width
0
.
0f
0
.
0f
scaleFactors
.
height
0
.
0f
0
.
0f
)
;
gfxMatrix
reverseScaleMatrix
=
scaleMatrix
;
DebugOnly
<
bool
>
invertible
=
reverseScaleMatrix
.
Invert
(
)
;
MOZ_ASSERT
(
invertible
)
;
aCtx
-
>
SetMatrixDouble
(
reverseScaleMatrix
*
aCtx
-
>
CurrentMatrixDouble
(
)
)
;
gfxMatrix
scaleMatrixInDevUnits
=
scaleMatrix
*
nsSVGUtils
:
:
GetCSSPxToDevPxMatrix
(
aFilteredFrame
)
;
nsFilterInstance
instance
(
aFilteredFrame
aFilteredFrame
-
>
GetContent
(
)
*
metrics
filterChain
true
aPaintCallback
scaleMatrixInDevUnits
aDirtyArea
nullptr
nullptr
nullptr
)
;
if
(
instance
.
IsInitialized
(
)
)
{
instance
.
Render
(
aCtx
aImgParams
aOpacity
)
;
}
}
bool
nsFilterInstance
:
:
BuildWebRenderFilters
(
nsIFrame
*
aFilteredFrame
nsTArray
<
wr
:
:
FilterOp
>
&
aWrFilters
Maybe
<
nsRect
>
&
aPostFilterClip
)
{
aWrFilters
.
Clear
(
)
;
auto
&
filterChain
=
aFilteredFrame
-
>
StyleEffects
(
)
-
>
mFilters
;
UniquePtr
<
UserSpaceMetrics
>
metrics
=
UserSpaceMetricsForFrame
(
aFilteredFrame
)
;
gfxMatrix
scaleMatrix
;
gfxMatrix
scaleMatrixInDevUnits
=
scaleMatrix
*
nsSVGUtils
:
:
GetCSSPxToDevPxMatrix
(
aFilteredFrame
)
;
bool
inputIsTainted
=
true
;
nsFilterInstance
instance
(
aFilteredFrame
aFilteredFrame
-
>
GetContent
(
)
*
metrics
filterChain
inputIsTainted
nullptr
scaleMatrixInDevUnits
nullptr
nullptr
nullptr
nullptr
)
;
if
(
!
instance
.
IsInitialized
(
)
)
{
return
false
;
}
if
(
instance
.
mFilterDescription
.
mPrimitives
.
Length
(
)
>
gfxPrefs
:
:
WebRenderMaxFilterOpsPerChain
(
)
)
{
return
true
;
}
Maybe
<
IntRect
>
finalClip
;
bool
srgb
=
true
;
for
(
uint32_t
i
=
0
;
i
<
instance
.
mFilterDescription
.
mPrimitives
.
Length
(
)
;
i
+
+
)
{
const
auto
&
primitive
=
instance
.
mFilterDescription
.
mPrimitives
[
i
]
;
if
(
primitive
.
NumberOfInputs
(
)
!
=
1
)
{
return
false
;
}
if
(
i
=
=
0
)
{
if
(
primitive
.
InputPrimitiveIndex
(
0
)
!
=
FilterPrimitiveDescription
:
:
kPrimitiveIndexSourceGraphic
)
{
return
false
;
}
}
else
if
(
primitive
.
InputPrimitiveIndex
(
0
)
!
=
int32_t
(
i
-
1
)
)
{
return
false
;
}
bool
previousSrgb
=
srgb
;
bool
primNeedsSrgb
=
primitive
.
InputColorSpace
(
0
)
=
=
gfx
:
:
ColorSpace
:
:
SRGB
;
if
(
srgb
&
&
!
primNeedsSrgb
)
{
aWrFilters
.
AppendElement
(
wr
:
:
FilterOp
:
:
SrgbToLinear
(
)
)
;
}
else
if
(
!
srgb
&
&
primNeedsSrgb
)
{
aWrFilters
.
AppendElement
(
wr
:
:
FilterOp
:
:
LinearToSrgb
(
)
)
;
}
srgb
=
primitive
.
OutputColorSpace
(
)
=
=
gfx
:
:
ColorSpace
:
:
SRGB
;
const
PrimitiveAttributes
&
attr
=
primitive
.
Attributes
(
)
;
bool
filterIsNoop
=
false
;
if
(
attr
.
is
<
OpacityAttributes
>
(
)
)
{
float
opacity
=
attr
.
as
<
OpacityAttributes
>
(
)
.
mOpacity
;
aWrFilters
.
AppendElement
(
wr
:
:
FilterOp
:
:
Opacity
(
wr
:
:
PropertyBinding
<
float
>
:
:
Value
(
opacity
)
opacity
)
)
;
}
else
if
(
attr
.
is
<
ColorMatrixAttributes
>
(
)
)
{
const
ColorMatrixAttributes
&
attributes
=
attr
.
as
<
ColorMatrixAttributes
>
(
)
;
float
transposed
[
20
]
;
if
(
!
gfx
:
:
ComputeColorMatrix
(
attributes
transposed
)
)
{
filterIsNoop
=
true
;
continue
;
}
auto
almostEq
=
[
]
(
float
a
float
b
)
-
>
bool
{
return
fabs
(
a
-
b
)
<
0
.
00001
;
}
;
if
(
!
almostEq
(
transposed
[
15
]
0
.
0
)
|
|
!
almostEq
(
transposed
[
16
]
0
.
0
)
|
|
!
almostEq
(
transposed
[
17
]
0
.
0
)
|
|
!
almostEq
(
transposed
[
18
]
1
.
0
)
|
|
!
almostEq
(
transposed
[
3
]
0
.
0
)
|
|
!
almostEq
(
transposed
[
8
]
0
.
0
)
|
|
!
almostEq
(
transposed
[
13
]
0
.
0
)
)
{
return
false
;
}
float
matrix
[
20
]
=
{
transposed
[
0
]
transposed
[
5
]
transposed
[
10
]
transposed
[
15
]
transposed
[
1
]
transposed
[
6
]
transposed
[
11
]
transposed
[
16
]
transposed
[
2
]
transposed
[
7
]
transposed
[
12
]
transposed
[
17
]
transposed
[
3
]
transposed
[
8
]
transposed
[
13
]
transposed
[
18
]
transposed
[
4
]
transposed
[
9
]
transposed
[
14
]
transposed
[
19
]
}
;
aWrFilters
.
AppendElement
(
wr
:
:
FilterOp
:
:
ColorMatrix
(
matrix
)
)
;
}
else
if
(
attr
.
is
<
GaussianBlurAttributes
>
(
)
)
{
if
(
finalClip
)
{
return
false
;
}
const
GaussianBlurAttributes
&
blur
=
attr
.
as
<
GaussianBlurAttributes
>
(
)
;
const
Size
&
stdDev
=
blur
.
mStdDeviation
;
if
(
stdDev
.
width
!
=
stdDev
.
height
)
{
return
false
;
}
float
radius
=
stdDev
.
width
;
if
(
radius
!
=
0
.
0
)
{
aWrFilters
.
AppendElement
(
wr
:
:
FilterOp
:
:
Blur
(
radius
)
)
;
}
else
{
filterIsNoop
=
true
;
}
}
else
if
(
attr
.
is
<
DropShadowAttributes
>
(
)
)
{
if
(
finalClip
)
{
return
false
;
}
const
DropShadowAttributes
&
shadow
=
attr
.
as
<
DropShadowAttributes
>
(
)
;
const
Size
&
stdDev
=
shadow
.
mStdDeviation
;
if
(
stdDev
.
width
!
=
stdDev
.
height
)
{
return
false
;
}
wr
:
:
LayoutVector2D
offset
=
{
(
float
)
shadow
.
mOffset
.
x
(
float
)
shadow
.
mOffset
.
y
}
;
float
radius
=
stdDev
.
width
;
Color
color
=
shadow
.
mColor
;
if
(
!
primNeedsSrgb
)
{
color
=
Color
(
gsRGBToLinearRGBMap
[
uint8_t
(
color
.
r
*
255
)
]
gsRGBToLinearRGBMap
[
uint8_t
(
color
.
g
*
255
)
]
gsRGBToLinearRGBMap
[
uint8_t
(
color
.
b
*
255
)
]
color
.
a
)
;
}
wr
:
:
FilterOp
filterOp
=
wr
:
:
FilterOp
:
:
DropShadow
(
offset
radius
wr
:
:
ToColorF
(
ToDeviceColor
(
color
)
)
)
;
aWrFilters
.
AppendElement
(
filterOp
)
;
}
else
{
return
false
;
}
if
(
filterIsNoop
&
&
aWrFilters
.
Length
(
)
>
0
&
&
(
aWrFilters
.
LastElement
(
)
.
tag
=
=
wr
:
:
FilterOp
:
:
Tag
:
:
SrgbToLinear
|
|
aWrFilters
.
LastElement
(
)
.
tag
=
=
wr
:
:
FilterOp
:
:
Tag
:
:
LinearToSrgb
)
)
{
Unused
<
<
aWrFilters
.
PopLastElement
(
)
;
srgb
=
previousSrgb
;
}
if
(
!
filterIsNoop
)
{
if
(
finalClip
.
isNothing
(
)
)
{
finalClip
=
Some
(
primitive
.
PrimitiveSubregion
(
)
)
;
}
else
{
finalClip
=
Some
(
primitive
.
PrimitiveSubregion
(
)
.
Intersect
(
finalClip
.
value
(
)
)
)
;
}
}
}
if
(
!
srgb
)
{
aWrFilters
.
AppendElement
(
wr
:
:
FilterOp
:
:
LinearToSrgb
(
)
)
;
}
if
(
finalClip
)
{
aPostFilterClip
=
Some
(
instance
.
FilterSpaceToFrameSpace
(
finalClip
.
value
(
)
)
)
;
}
return
true
;
}
nsRegion
nsFilterInstance
:
:
GetPostFilterDirtyArea
(
nsIFrame
*
aFilteredFrame
const
nsRegion
&
aPreFilterDirtyRegion
)
{
if
(
aPreFilterDirtyRegion
.
IsEmpty
(
)
)
{
return
nsRegion
(
)
;
}
gfxMatrix
tm
=
nsSVGUtils
:
:
GetCanvasTM
(
aFilteredFrame
)
;
auto
&
filterChain
=
aFilteredFrame
-
>
StyleEffects
(
)
-
>
mFilters
;
UniquePtr
<
UserSpaceMetrics
>
metrics
=
UserSpaceMetricsForFrame
(
aFilteredFrame
)
;
nsFilterInstance
instance
(
aFilteredFrame
aFilteredFrame
-
>
GetContent
(
)
*
metrics
filterChain
true
nullptr
tm
nullptr
&
aPreFilterDirtyRegion
)
;
if
(
!
instance
.
IsInitialized
(
)
)
{
return
nsRegion
(
)
;
}
return
instance
.
ComputePostFilterDirtyRegion
(
)
;
}
nsRegion
nsFilterInstance
:
:
GetPreFilterNeededArea
(
nsIFrame
*
aFilteredFrame
const
nsRegion
&
aPostFilterDirtyRegion
)
{
gfxMatrix
tm
=
nsSVGUtils
:
:
GetCanvasTM
(
aFilteredFrame
)
;
auto
&
filterChain
=
aFilteredFrame
-
>
StyleEffects
(
)
-
>
mFilters
;
UniquePtr
<
UserSpaceMetrics
>
metrics
=
UserSpaceMetricsForFrame
(
aFilteredFrame
)
;
nsFilterInstance
instance
(
aFilteredFrame
aFilteredFrame
-
>
GetContent
(
)
*
metrics
filterChain
true
nullptr
tm
&
aPostFilterDirtyRegion
)
;
if
(
!
instance
.
IsInitialized
(
)
)
{
return
nsRect
(
)
;
}
return
instance
.
ComputeSourceNeededRect
(
)
;
}
nsRect
nsFilterInstance
:
:
GetPostFilterBounds
(
nsIFrame
*
aFilteredFrame
const
gfxRect
*
aOverrideBBox
const
nsRect
*
aPreFilterBounds
)
{
MOZ_ASSERT
(
!
(
aFilteredFrame
-
>
GetStateBits
(
)
&
NS_FRAME_SVG_LAYOUT
)
|
|
!
(
aFilteredFrame
-
>
GetStateBits
(
)
&
NS_FRAME_IS_NONDISPLAY
)
"
Non
-
display
SVG
do
not
maintain
visual
overflow
rects
"
)
;
nsRegion
preFilterRegion
;
nsRegion
*
preFilterRegionPtr
=
nullptr
;
if
(
aPreFilterBounds
)
{
preFilterRegion
=
*
aPreFilterBounds
;
preFilterRegionPtr
=
&
preFilterRegion
;
}
gfxMatrix
tm
=
nsSVGUtils
:
:
GetCanvasTM
(
aFilteredFrame
)
;
auto
&
filterChain
=
aFilteredFrame
-
>
StyleEffects
(
)
-
>
mFilters
;
UniquePtr
<
UserSpaceMetrics
>
metrics
=
UserSpaceMetricsForFrame
(
aFilteredFrame
)
;
nsFilterInstance
instance
(
aFilteredFrame
aFilteredFrame
-
>
GetContent
(
)
*
metrics
filterChain
true
nullptr
tm
nullptr
preFilterRegionPtr
aPreFilterBounds
aOverrideBBox
)
;
if
(
!
instance
.
IsInitialized
(
)
)
{
return
nsRect
(
)
;
}
return
instance
.
ComputePostFilterExtents
(
)
;
}
nsFilterInstance
:
:
nsFilterInstance
(
nsIFrame
*
aTargetFrame
nsIContent
*
aTargetContent
const
UserSpaceMetrics
&
aMetrics
const
nsTArray
<
nsStyleFilter
>
&
aFilterChain
bool
aFilterInputIsTainted
nsSVGFilterPaintCallback
*
aPaintCallback
const
gfxMatrix
&
aPaintTransform
const
nsRegion
*
aPostFilterDirtyRegion
const
nsRegion
*
aPreFilterDirtyRegion
const
nsRect
*
aPreFilterVisualOverflowRectOverride
const
gfxRect
*
aOverrideBBox
)
:
mTargetFrame
(
aTargetFrame
)
mTargetContent
(
aTargetContent
)
mMetrics
(
aMetrics
)
mPaintCallback
(
aPaintCallback
)
mPaintTransform
(
aPaintTransform
)
mInitialized
(
false
)
{
if
(
aOverrideBBox
)
{
mTargetBBox
=
*
aOverrideBBox
;
}
else
{
MOZ_ASSERT
(
mTargetFrame
"
Need
to
supply
a
frame
when
there
'
s
no
aOverrideBBox
"
)
;
mTargetBBox
=
nsSVGUtils
:
:
GetBBox
(
mTargetFrame
nsSVGUtils
:
:
eUseFrameBoundsForOuterSVG
|
nsSVGUtils
:
:
eBBoxIncludeFillGeometry
)
;
}
if
(
!
ComputeUserSpaceToFilterSpaceScale
(
)
)
{
return
;
}
if
(
!
ComputeTargetBBoxInFilterSpace
(
)
)
{
return
;
}
gfxMatrix
filterToUserSpace
(
mFilterSpaceToUserSpaceScale
.
width
0
.
0f
0
.
0f
mFilterSpaceToUserSpaceScale
.
height
0
.
0f
0
.
0f
)
;
mFilterSpaceToFrameSpaceInCSSPxTransform
=
filterToUserSpace
*
GetUserSpaceToFrameSpaceInCSSPxTransform
(
)
;
mFrameSpaceInCSSPxToFilterSpaceTransform
=
mFilterSpaceToFrameSpaceInCSSPxTransform
;
mFrameSpaceInCSSPxToFilterSpaceTransform
.
Invert
(
)
;
nsIntRect
targetBounds
;
if
(
aPreFilterVisualOverflowRectOverride
)
{
targetBounds
=
FrameSpaceToFilterSpace
(
aPreFilterVisualOverflowRectOverride
)
;
}
else
if
(
mTargetFrame
)
{
nsRect
preFilterVOR
=
mTargetFrame
-
>
GetPreEffectsVisualOverflowRect
(
)
;
targetBounds
=
FrameSpaceToFilterSpace
(
&
preFilterVOR
)
;
}
mTargetBounds
.
UnionRect
(
mTargetBBoxInFilterSpace
targetBounds
)
;
if
(
NS_FAILED
(
BuildPrimitives
(
aFilterChain
aTargetFrame
aFilterInputIsTainted
)
)
)
{
return
;
}
mPostFilterDirtyRegion
=
FrameSpaceToFilterSpace
(
aPostFilterDirtyRegion
)
;
mPreFilterDirtyRegion
=
FrameSpaceToFilterSpace
(
aPreFilterDirtyRegion
)
;
mInitialized
=
true
;
}
bool
nsFilterInstance
:
:
ComputeTargetBBoxInFilterSpace
(
)
{
gfxRect
targetBBoxInFilterSpace
=
UserSpaceToFilterSpace
(
mTargetBBox
)
;
targetBBoxInFilterSpace
.
RoundOut
(
)
;
return
gfxUtils
:
:
GfxRectToIntRect
(
targetBBoxInFilterSpace
&
mTargetBBoxInFilterSpace
)
;
}
bool
nsFilterInstance
:
:
ComputeUserSpaceToFilterSpaceScale
(
)
{
if
(
mTargetFrame
)
{
mUserSpaceToFilterSpaceScale
=
mPaintTransform
.
ScaleFactors
(
true
)
;
if
(
mUserSpaceToFilterSpaceScale
.
width
<
=
0
.
0f
|
|
mUserSpaceToFilterSpaceScale
.
height
<
=
0
.
0f
)
{
return
false
;
}
}
else
{
mUserSpaceToFilterSpaceScale
=
gfxSize
(
1
.
0
1
.
0
)
;
}
mFilterSpaceToUserSpaceScale
=
gfxSize
(
1
.
0f
/
mUserSpaceToFilterSpaceScale
.
width
1
.
0f
/
mUserSpaceToFilterSpaceScale
.
height
)
;
return
true
;
}
gfxRect
nsFilterInstance
:
:
UserSpaceToFilterSpace
(
const
gfxRect
&
aUserSpaceRect
)
const
{
gfxRect
filterSpaceRect
=
aUserSpaceRect
;
filterSpaceRect
.
Scale
(
mUserSpaceToFilterSpaceScale
.
width
mUserSpaceToFilterSpaceScale
.
height
)
;
return
filterSpaceRect
;
}
gfxRect
nsFilterInstance
:
:
FilterSpaceToUserSpace
(
const
gfxRect
&
aFilterSpaceRect
)
const
{
gfxRect
userSpaceRect
=
aFilterSpaceRect
;
userSpaceRect
.
Scale
(
mFilterSpaceToUserSpaceScale
.
width
mFilterSpaceToUserSpaceScale
.
height
)
;
return
userSpaceRect
;
}
nsresult
nsFilterInstance
:
:
BuildPrimitives
(
const
nsTArray
<
nsStyleFilter
>
&
aFilterChain
nsIFrame
*
aTargetFrame
bool
aFilterInputIsTainted
)
{
nsTArray
<
FilterPrimitiveDescription
>
primitiveDescriptions
;
for
(
uint32_t
i
=
0
;
i
<
aFilterChain
.
Length
(
)
;
i
+
+
)
{
bool
inputIsTainted
=
primitiveDescriptions
.
IsEmpty
(
)
?
aFilterInputIsTainted
:
primitiveDescriptions
.
LastElement
(
)
.
IsTainted
(
)
;
nsresult
rv
=
BuildPrimitivesForFilter
(
aFilterChain
[
i
]
aTargetFrame
inputIsTainted
primitiveDescriptions
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
rv
;
}
}
mFilterDescription
=
FilterDescription
(
std
:
:
move
(
primitiveDescriptions
)
)
;
return
NS_OK
;
}
nsresult
nsFilterInstance
:
:
BuildPrimitivesForFilter
(
const
nsStyleFilter
&
aFilter
nsIFrame
*
aTargetFrame
bool
aInputIsTainted
nsTArray
<
FilterPrimitiveDescription
>
&
aPrimitiveDescriptions
)
{
NS_ASSERTION
(
mUserSpaceToFilterSpaceScale
.
width
>
0
.
0f
&
&
mFilterSpaceToUserSpaceScale
.
height
>
0
.
0f
"
scale
factors
between
spaces
should
be
positive
values
"
)
;
if
(
aFilter
.
GetType
(
)
=
=
NS_STYLE_FILTER_URL
)
{
nsSVGFilterInstance
svgFilterInstance
(
aFilter
aTargetFrame
mTargetContent
mMetrics
mTargetBBox
mUserSpaceToFilterSpaceScale
)
;
if
(
!
svgFilterInstance
.
IsInitialized
(
)
)
{
return
NS_ERROR_FAILURE
;
}
return
svgFilterInstance
.
BuildPrimitives
(
aPrimitiveDescriptions
mInputImages
aInputIsTainted
)
;
}
nscolor
shadowFallbackColor
=
mTargetFrame
?
mTargetFrame
-
>
StyleColor
(
)
-
>
mColor
:
NS_RGB
(
0
0
0
)
;
nsCSSFilterInstance
cssFilterInstance
(
aFilter
shadowFallbackColor
mTargetBounds
mFrameSpaceInCSSPxToFilterSpaceTransform
)
;
return
cssFilterInstance
.
BuildPrimitives
(
aPrimitiveDescriptions
aInputIsTainted
)
;
}
static
void
UpdateNeededBounds
(
const
nsIntRegion
&
aRegion
nsIntRect
&
aBounds
)
{
aBounds
=
aRegion
.
GetBounds
(
)
;
bool
overflow
;
IntSize
surfaceSize
=
nsSVGUtils
:
:
ConvertToSurfaceSize
(
SizeDouble
(
aBounds
.
Size
(
)
)
&
overflow
)
;
if
(
overflow
)
{
aBounds
.
SizeTo
(
surfaceSize
)
;
}
}
void
nsFilterInstance
:
:
ComputeNeededBoxes
(
)
{
if
(
mFilterDescription
.
mPrimitives
.
IsEmpty
(
)
)
{
return
;
}
nsIntRegion
sourceGraphicNeededRegion
;
nsIntRegion
fillPaintNeededRegion
;
nsIntRegion
strokePaintNeededRegion
;
FilterSupport
:
:
ComputeSourceNeededRegions
(
mFilterDescription
mPostFilterDirtyRegion
sourceGraphicNeededRegion
fillPaintNeededRegion
strokePaintNeededRegion
)
;
sourceGraphicNeededRegion
.
And
(
sourceGraphicNeededRegion
mTargetBounds
)
;
UpdateNeededBounds
(
sourceGraphicNeededRegion
mSourceGraphic
.
mNeededBounds
)
;
UpdateNeededBounds
(
fillPaintNeededRegion
mFillPaint
.
mNeededBounds
)
;
UpdateNeededBounds
(
strokePaintNeededRegion
mStrokePaint
.
mNeededBounds
)
;
}
void
nsFilterInstance
:
:
BuildSourcePaint
(
SourceInfo
*
aSource
imgDrawingParams
&
aImgParams
)
{
MOZ_ASSERT
(
mTargetFrame
)
;
nsIntRect
neededRect
=
aSource
-
>
mNeededBounds
;
if
(
neededRect
.
IsEmpty
(
)
)
{
return
;
}
RefPtr
<
DrawTarget
>
offscreenDT
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
CreateOffscreenContentDrawTarget
(
neededRect
.
Size
(
)
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
!
offscreenDT
|
|
!
offscreenDT
-
>
IsValid
(
)
)
{
return
;
}
RefPtr
<
gfxContext
>
ctx
=
gfxContext
:
:
CreateOrNull
(
offscreenDT
)
;
MOZ_ASSERT
(
ctx
)
;
gfxContextAutoSaveRestore
saver
(
ctx
)
;
ctx
-
>
SetMatrixDouble
(
mPaintTransform
*
gfxMatrix
:
:
Translation
(
-
neededRect
.
TopLeft
(
)
)
)
;
GeneralPattern
pattern
;
if
(
aSource
=
=
&
mFillPaint
)
{
nsSVGUtils
:
:
MakeFillPatternFor
(
mTargetFrame
ctx
&
pattern
aImgParams
)
;
}
else
if
(
aSource
=
=
&
mStrokePaint
)
{
nsSVGUtils
:
:
MakeStrokePatternFor
(
mTargetFrame
ctx
&
pattern
aImgParams
)
;
}
if
(
pattern
.
GetPattern
(
)
)
{
offscreenDT
-
>
FillRect
(
ToRect
(
FilterSpaceToUserSpace
(
ThebesRect
(
neededRect
)
)
)
pattern
)
;
}
aSource
-
>
mSourceSurface
=
offscreenDT
-
>
Snapshot
(
)
;
aSource
-
>
mSurfaceRect
=
neededRect
;
}
void
nsFilterInstance
:
:
BuildSourcePaints
(
imgDrawingParams
&
aImgParams
)
{
if
(
!
mFillPaint
.
mNeededBounds
.
IsEmpty
(
)
)
{
BuildSourcePaint
(
&
mFillPaint
aImgParams
)
;
}
if
(
!
mStrokePaint
.
mNeededBounds
.
IsEmpty
(
)
)
{
BuildSourcePaint
(
&
mStrokePaint
aImgParams
)
;
}
}
void
nsFilterInstance
:
:
BuildSourceImage
(
DrawTarget
*
aDest
imgDrawingParams
&
aImgParams
)
{
MOZ_ASSERT
(
mTargetFrame
)
;
nsIntRect
neededRect
=
mSourceGraphic
.
mNeededBounds
;
if
(
neededRect
.
IsEmpty
(
)
)
{
return
;
}
RefPtr
<
DrawTarget
>
offscreenDT
=
aDest
-
>
CreateSimilarDrawTarget
(
neededRect
.
Size
(
)
SurfaceFormat
:
:
B8G8R8A8
)
;
if
(
!
offscreenDT
|
|
!
offscreenDT
-
>
IsValid
(
)
)
{
return
;
}
gfxRect
r
=
FilterSpaceToUserSpace
(
ThebesRect
(
neededRect
)
)
;
r
.
RoundOut
(
)
;
nsIntRect
dirty
;
if
(
!
gfxUtils
:
:
GfxRectToIntRect
(
r
&
dirty
)
)
{
return
;
}
RefPtr
<
gfxContext
>
ctx
=
gfxContext
:
:
CreateOrNull
(
offscreenDT
)
;
MOZ_ASSERT
(
ctx
)
;
gfxMatrix
devPxToCssPxTM
=
nsSVGUtils
:
:
GetCSSPxToDevPxMatrix
(
mTargetFrame
)
;
DebugOnly
<
bool
>
invertible
=
devPxToCssPxTM
.
Invert
(
)
;
MOZ_ASSERT
(
invertible
)
;
ctx
-
>
SetMatrixDouble
(
devPxToCssPxTM
*
mPaintTransform
*
gfxMatrix
:
:
Translation
(
-
neededRect
.
TopLeft
(
)
)
)
;
mPaintCallback
-
>
Paint
(
*
ctx
mTargetFrame
mPaintTransform
&
dirty
aImgParams
)
;
mSourceGraphic
.
mSourceSurface
=
offscreenDT
-
>
Snapshot
(
)
;
mSourceGraphic
.
mSurfaceRect
=
neededRect
;
}
void
nsFilterInstance
:
:
Render
(
gfxContext
*
aCtx
imgDrawingParams
&
aImgParams
float
aOpacity
)
{
MOZ_ASSERT
(
mTargetFrame
"
Need
a
frame
for
rendering
"
)
;
if
(
mFilterDescription
.
mPrimitives
.
IsEmpty
(
)
)
{
return
;
}
nsIntRect
filterRect
=
mPostFilterDirtyRegion
.
GetBounds
(
)
.
Intersect
(
OutputFilterSpaceBounds
(
)
)
;
if
(
filterRect
.
IsEmpty
(
)
|
|
mPaintTransform
.
IsSingular
(
)
)
{
return
;
}
gfxContextMatrixAutoSaveRestore
autoSR
(
aCtx
)
;
aCtx
-
>
SetMatrix
(
aCtx
-
>
CurrentMatrix
(
)
.
PreTranslate
(
filterRect
.
x
filterRect
.
y
)
)
;
ComputeNeededBoxes
(
)
;
BuildSourceImage
(
aCtx
-
>
GetDrawTarget
(
)
aImgParams
)
;
BuildSourcePaints
(
aImgParams
)
;
FilterSupport
:
:
RenderFilterDescription
(
aCtx
-
>
GetDrawTarget
(
)
mFilterDescription
IntRectToRect
(
filterRect
)
mSourceGraphic
.
mSourceSurface
mSourceGraphic
.
mSurfaceRect
mFillPaint
.
mSourceSurface
mFillPaint
.
mSurfaceRect
mStrokePaint
.
mSourceSurface
mStrokePaint
.
mSurfaceRect
mInputImages
Point
(
0
0
)
DrawOptions
(
aOpacity
)
)
;
}
nsRegion
nsFilterInstance
:
:
ComputePostFilterDirtyRegion
(
)
{
if
(
mPreFilterDirtyRegion
.
IsEmpty
(
)
|
|
mFilterDescription
.
mPrimitives
.
IsEmpty
(
)
)
{
return
nsRegion
(
)
;
}
nsIntRegion
resultChangeRegion
=
FilterSupport
:
:
ComputeResultChangeRegion
(
mFilterDescription
mPreFilterDirtyRegion
nsIntRegion
(
)
nsIntRegion
(
)
)
;
return
FilterSpaceToFrameSpace
(
resultChangeRegion
)
;
}
nsRect
nsFilterInstance
:
:
ComputePostFilterExtents
(
)
{
if
(
mFilterDescription
.
mPrimitives
.
IsEmpty
(
)
)
{
return
nsRect
(
)
;
}
nsIntRegion
postFilterExtents
=
FilterSupport
:
:
ComputePostFilterExtents
(
mFilterDescription
mTargetBounds
)
;
return
FilterSpaceToFrameSpace
(
postFilterExtents
.
GetBounds
(
)
)
;
}
nsRect
nsFilterInstance
:
:
ComputeSourceNeededRect
(
)
{
ComputeNeededBoxes
(
)
;
return
FilterSpaceToFrameSpace
(
mSourceGraphic
.
mNeededBounds
)
;
}
nsIntRect
nsFilterInstance
:
:
OutputFilterSpaceBounds
(
)
const
{
uint32_t
numPrimitives
=
mFilterDescription
.
mPrimitives
.
Length
(
)
;
if
(
numPrimitives
<
=
0
)
{
return
nsIntRect
(
)
;
}
return
mFilterDescription
.
mPrimitives
[
numPrimitives
-
1
]
.
PrimitiveSubregion
(
)
;
}
nsIntRect
nsFilterInstance
:
:
FrameSpaceToFilterSpace
(
const
nsRect
*
aRect
)
const
{
nsIntRect
rect
=
OutputFilterSpaceBounds
(
)
;
if
(
aRect
)
{
if
(
aRect
-
>
IsEmpty
(
)
)
{
return
nsIntRect
(
)
;
}
gfxRect
rectInCSSPx
=
nsLayoutUtils
:
:
RectToGfxRect
(
*
aRect
AppUnitsPerCSSPixel
(
)
)
;
gfxRect
rectInFilterSpace
=
mFrameSpaceInCSSPxToFilterSpaceTransform
.
TransformBounds
(
rectInCSSPx
)
;
rectInFilterSpace
.
RoundOut
(
)
;
nsIntRect
intRect
;
if
(
gfxUtils
:
:
GfxRectToIntRect
(
rectInFilterSpace
&
intRect
)
)
{
rect
=
intRect
;
}
}
return
rect
;
}
nsRect
nsFilterInstance
:
:
FilterSpaceToFrameSpace
(
const
nsIntRect
&
aRect
)
const
{
if
(
aRect
.
IsEmpty
(
)
)
{
return
nsRect
(
)
;
}
gfxRect
r
(
aRect
.
x
aRect
.
y
aRect
.
width
aRect
.
height
)
;
r
=
mFilterSpaceToFrameSpaceInCSSPxTransform
.
TransformBounds
(
r
)
;
return
nsLayoutUtils
:
:
RoundGfxRectToAppRect
(
r
AppUnitsPerCSSPixel
(
)
)
;
}
nsIntRegion
nsFilterInstance
:
:
FrameSpaceToFilterSpace
(
const
nsRegion
*
aRegion
)
const
{
if
(
!
aRegion
)
{
return
OutputFilterSpaceBounds
(
)
;
}
nsIntRegion
result
;
for
(
auto
iter
=
aRegion
-
>
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
nsRect
rect
=
iter
.
Get
(
)
;
result
.
Or
(
result
FrameSpaceToFilterSpace
(
&
rect
)
)
;
}
return
result
;
}
nsRegion
nsFilterInstance
:
:
FilterSpaceToFrameSpace
(
const
nsIntRegion
&
aRegion
)
const
{
nsRegion
result
;
for
(
auto
iter
=
aRegion
.
RectIter
(
)
;
!
iter
.
Done
(
)
;
iter
.
Next
(
)
)
{
result
.
Or
(
result
FilterSpaceToFrameSpace
(
iter
.
Get
(
)
)
)
;
}
return
result
;
}
gfxMatrix
nsFilterInstance
:
:
GetUserSpaceToFrameSpaceInCSSPxTransform
(
)
const
{
if
(
!
mTargetFrame
)
{
return
gfxMatrix
(
)
;
}
return
gfxMatrix
:
:
Translation
(
-
nsSVGUtils
:
:
FrameSpaceInCSSPxToUserSpaceOffset
(
mTargetFrame
)
)
;
}
