#
ifndef
LAYOUT_SVG_SVGUTILS_H_
#
define
LAYOUT_SVG_SVGUTILS_H_
#
include
<
math
.
h
>
#
include
"
DrawMode
.
h
"
#
include
"
ImgDrawResult
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxMatrix
.
h
"
#
include
"
gfxPoint
.
h
"
#
include
"
gfxRect
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
nsAlgorithm
.
h
"
#
include
"
nsChangeHint
.
h
"
#
include
"
nsColor
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsID
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsISupportsBase
.
h
"
#
include
"
nsMathUtils
.
h
"
#
include
"
nsStyleStruct
.
h
"
#
include
<
algorithm
>
class
gfxContext
;
class
nsFrameList
;
class
nsIContent
;
class
nsPresContext
;
class
nsTextFrame
;
struct
nsStyleSVG
;
struct
nsRect
;
namespace
mozilla
{
class
SVGAnimatedEnumeration
;
class
SVGAnimatedLength
;
class
SVGContextPaint
;
struct
SVGContextPaintImpl
;
class
SVGDisplayContainerFrame
;
class
SVGGeometryFrame
;
class
SVGOuterSVGFrame
;
namespace
dom
{
class
Element
;
class
SVGElement
;
class
UserSpaceMetrics
;
}
namespace
gfx
{
class
DrawTarget
;
class
GeneralPattern
;
}
}
#
define
NS_SVG_OFFSCREEN_MAX_DIMENSION
4096
#
define
SVG_HIT_TEST_FILL
0x01
#
define
SVG_HIT_TEST_STROKE
0x02
#
define
SVG_HIT_TEST_CHECK_MRECT
0x04
bool
NS_SVGDisplayListHitTestingEnabled
(
)
;
bool
NS_SVGDisplayListPaintingEnabled
(
)
;
bool
NS_SVGNewGetBBoxEnabled
(
)
;
namespace
mozilla
{
class
SVGBBox
final
{
using
Rect
=
gfx
:
:
Rect
;
public
:
SVGBBox
(
)
:
mIsEmpty
(
true
)
{
}
MOZ_IMPLICIT
SVGBBox
(
const
Rect
&
aRect
)
:
mBBox
(
aRect
)
mIsEmpty
(
false
)
{
}
MOZ_IMPLICIT
SVGBBox
(
const
gfxRect
&
aRect
)
:
mBBox
(
ToRect
(
aRect
)
)
mIsEmpty
(
false
)
{
}
operator
const
Rect
&
(
)
{
return
mBBox
;
}
gfxRect
ToThebesRect
(
)
const
{
return
ThebesRect
(
mBBox
)
;
}
bool
IsEmpty
(
)
const
{
return
mIsEmpty
;
}
bool
IsFinite
(
)
const
{
return
mBBox
.
IsFinite
(
)
;
}
void
Scale
(
float
aScale
)
{
mBBox
.
Scale
(
aScale
)
;
}
void
UnionEdges
(
const
SVGBBox
&
aSVGBBox
)
{
if
(
aSVGBBox
.
mIsEmpty
)
{
return
;
}
mBBox
=
mIsEmpty
?
aSVGBBox
.
mBBox
:
mBBox
.
UnionEdges
(
aSVGBBox
.
mBBox
)
;
mIsEmpty
=
false
;
}
void
Intersect
(
const
SVGBBox
&
aSVGBBox
)
{
if
(
!
mIsEmpty
&
&
!
aSVGBBox
.
mIsEmpty
)
{
mBBox
=
mBBox
.
Intersect
(
aSVGBBox
.
mBBox
)
;
if
(
mBBox
.
IsEmpty
(
)
)
{
mIsEmpty
=
true
;
mBBox
=
Rect
(
0
0
0
0
)
;
}
}
else
{
mIsEmpty
=
true
;
mBBox
=
Rect
(
0
0
0
0
)
;
}
}
private
:
Rect
mBBox
;
bool
mIsEmpty
;
}
;
#
undef
CLIP_MASK
class
MOZ_RAII
SVGAutoRenderState
final
{
using
DrawTarget
=
gfx
:
:
DrawTarget
;
public
:
explicit
SVGAutoRenderState
(
DrawTarget
*
aDrawTarget
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
;
~
SVGAutoRenderState
(
)
;
void
SetPaintingToWindow
(
bool
aPaintingToWindow
)
;
static
bool
IsPaintingToWindow
(
DrawTarget
*
aDrawTarget
)
;
private
:
DrawTarget
*
mDrawTarget
;
void
*
mOriginalRenderState
;
bool
mPaintingToWindow
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
SVGUtils
final
{
public
:
using
Element
=
dom
:
:
Element
;
using
SVGElement
=
dom
:
:
SVGElement
;
using
AntialiasMode
=
gfx
:
:
AntialiasMode
;
using
DrawTarget
=
gfx
:
:
DrawTarget
;
using
FillRule
=
gfx
:
:
FillRule
;
using
GeneralPattern
=
gfx
:
:
GeneralPattern
;
using
Size
=
gfx
:
:
Size
;
using
imgDrawingParams
=
image
:
:
imgDrawingParams
;
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
ObjectBoundingBoxProperty
gfxRect
)
static
nsRect
GetPostFilterVisualOverflowRect
(
nsIFrame
*
aFrame
const
nsRect
&
aPreFilterRect
)
;
static
void
ScheduleReflowSVG
(
nsIFrame
*
aFrame
)
;
static
bool
NeedsReflowSVG
(
nsIFrame
*
aFrame
)
;
static
Size
GetContextSize
(
const
nsIFrame
*
aFrame
)
;
static
float
ObjectSpace
(
const
gfxRect
&
aRect
const
SVGAnimatedLength
*
aLength
)
;
static
float
UserSpace
(
SVGElement
*
aSVGElement
const
SVGAnimatedLength
*
aLength
)
;
static
float
UserSpace
(
nsIFrame
*
aNonSVGContext
const
SVGAnimatedLength
*
aLength
)
;
static
float
UserSpace
(
const
dom
:
:
UserSpaceMetrics
&
aMetrics
const
SVGAnimatedLength
*
aLength
)
;
static
SVGOuterSVGFrame
*
GetOuterSVGFrame
(
nsIFrame
*
aFrame
)
;
static
nsIFrame
*
GetOuterSVGFrameAndCoveredRegion
(
nsIFrame
*
aFrame
nsRect
*
aRect
)
;
static
void
PaintFrameWithEffects
(
nsIFrame
*
aFrame
gfxContext
&
aContext
const
gfxMatrix
&
aTransform
imgDrawingParams
&
aImgParams
const
nsIntRect
*
aDirtyRect
=
nullptr
)
;
static
bool
HitTestClip
(
nsIFrame
*
aFrame
const
gfxPoint
&
aPoint
)
;
static
nsIFrame
*
HitTestChildren
(
SVGDisplayContainerFrame
*
aFrame
const
gfxPoint
&
aPoint
)
;
static
gfxMatrix
GetCanvasTM
(
nsIFrame
*
aFrame
)
;
static
void
NotifyChildrenOfSVGChange
(
nsIFrame
*
aFrame
uint32_t
aFlags
)
;
static
nsRect
TransformFrameRectToOuterSVG
(
const
nsRect
&
aRect
const
gfxMatrix
&
aMatrix
nsPresContext
*
aPresContext
)
;
static
gfx
:
:
IntSize
ConvertToSurfaceSize
(
const
gfxSize
&
aSize
bool
*
aResultOverflows
)
;
static
bool
HitTestRect
(
const
gfx
:
:
Matrix
&
aMatrix
float
aRX
float
aRY
float
aRWidth
float
aRHeight
float
aX
float
aY
)
;
static
gfxRect
GetClipRectForFrame
(
nsIFrame
*
aFrame
float
aX
float
aY
float
aWidth
float
aHeight
)
;
static
void
SetClipRect
(
gfxContext
*
aContext
const
gfxMatrix
&
aCTM
const
gfxRect
&
aRect
)
;
static
bool
CanOptimizeOpacity
(
nsIFrame
*
aFrame
)
;
static
gfxMatrix
AdjustMatrixForUnits
(
const
gfxMatrix
&
aMatrix
SVGAnimatedEnumeration
*
aUnits
nsIFrame
*
aFrame
uint32_t
aFlags
)
;
enum
BBoxFlags
{
eBBoxIncludeFill
=
1
<
<
0
eBBoxIncludeFillGeometry
=
1
<
<
1
eBBoxIncludeStroke
=
1
<
<
2
eBBoxIncludeStrokeGeometry
=
1
<
<
3
eBBoxIncludeMarkers
=
1
<
<
4
eBBoxIncludeClipped
=
1
<
<
5
eUseFrameBoundsForOuterSVG
=
1
<
<
6
eForGetClientRects
=
1
<
<
7
eIncludeOnlyCurrentFrameForNonSVGElement
=
1
<
<
8
eUseUserSpaceOfUseElement
=
1
<
<
9
eDoNotClipToBBoxOfContentInsideClipPath
=
1
<
<
10
}
;
static
gfxRect
GetBBox
(
nsIFrame
*
aFrame
uint32_t
aFlags
=
eBBoxIncludeFillGeometry
const
gfxMatrix
*
aToBoundsSpace
=
nullptr
)
;
static
gfxPoint
FrameSpaceInCSSPxToUserSpaceOffset
(
nsIFrame
*
aFrame
)
;
static
gfxRect
GetRelativeRect
(
uint16_t
aUnits
const
SVGAnimatedLength
*
aXYWH
const
gfxRect
&
aBBox
nsIFrame
*
aFrame
)
;
static
gfxRect
GetRelativeRect
(
uint16_t
aUnits
const
SVGAnimatedLength
*
aXYWH
const
gfxRect
&
aBBox
const
dom
:
:
UserSpaceMetrics
&
aMetrics
)
;
static
nsIFrame
*
GetFirstNonAAncestorFrame
(
nsIFrame
*
aStartFrame
)
;
static
bool
OuterSVGIsCallingReflowSVG
(
nsIFrame
*
aFrame
)
;
static
bool
AnyOuterSVGIsCallingReflowSVG
(
nsIFrame
*
aFrame
)
;
static
bool
GetNonScalingStrokeTransform
(
nsIFrame
*
aFrame
gfxMatrix
*
aUserToOuterSVG
)
;
static
gfxRect
PathExtentsToMaxStrokeExtents
(
const
gfxRect
&
aPathExtents
nsTextFrame
*
aFrame
const
gfxMatrix
&
aMatrix
)
;
static
gfxRect
PathExtentsToMaxStrokeExtents
(
const
gfxRect
&
aPathExtents
SVGGeometryFrame
*
aFrame
const
gfxMatrix
&
aMatrix
)
;
static
int32_t
ClampToInt
(
double
aVal
)
{
return
NS_lround
(
std
:
:
max
(
double
(
INT32_MIN
)
std
:
:
min
(
double
(
INT32_MAX
)
aVal
)
)
)
;
}
static
nscolor
GetFallbackOrPaintColor
(
const
ComputedStyle
&
StyleSVGPaint
nsStyleSVG
:
:
*
aFillOrStroke
)
;
static
void
MakeFillPatternFor
(
nsIFrame
*
aFrame
gfxContext
*
aContext
GeneralPattern
*
aOutPattern
imgDrawingParams
&
aImgParams
SVGContextPaint
*
aContextPaint
=
nullptr
)
;
static
void
MakeStrokePatternFor
(
nsIFrame
*
aFrame
gfxContext
*
aContext
GeneralPattern
*
aOutPattern
imgDrawingParams
&
aImgParams
SVGContextPaint
*
aContextPaint
=
nullptr
)
;
static
float
GetOpacity
(
const
StyleSVGOpacity
&
SVGContextPaint
*
)
;
static
bool
HasStroke
(
nsIFrame
*
aFrame
SVGContextPaint
*
aContextPaint
=
nullptr
)
;
static
float
GetStrokeWidth
(
nsIFrame
*
aFrame
SVGContextPaint
*
aContextPaint
=
nullptr
)
;
static
void
SetupStrokeGeometry
(
nsIFrame
*
aFrame
gfxContext
*
aContext
SVGContextPaint
*
aContextPaint
=
nullptr
)
;
static
uint16_t
GetGeometryHitTestFlags
(
nsIFrame
*
aFrame
)
;
static
FillRule
ToFillRule
(
StyleFillRule
aFillRule
)
{
return
aFillRule
=
=
StyleFillRule
:
:
Evenodd
?
FillRule
:
:
FILL_EVEN_ODD
:
FillRule
:
:
FILL_WINDING
;
}
static
AntialiasMode
ToAntialiasMode
(
StyleTextRendering
aTextRendering
)
{
return
aTextRendering
=
=
StyleTextRendering
:
:
Optimizespeed
?
AntialiasMode
:
:
NONE
:
AntialiasMode
:
:
SUBPIXEL
;
}
static
void
PaintSVGGlyph
(
Element
*
aElement
gfxContext
*
aContext
)
;
static
bool
GetSVGGlyphExtents
(
Element
*
aElement
const
gfxMatrix
&
aSVGToAppSpace
gfxRect
*
aResult
)
;
static
nsRect
ToCanvasBounds
(
const
gfxRect
&
aUserspaceRect
const
gfxMatrix
&
aToCanvas
const
nsPresContext
*
presContext
)
;
struct
MaskUsage
{
bool
shouldGenerateMaskLayer
;
bool
shouldGenerateClipMaskLayer
;
bool
shouldApplyClipPath
;
bool
shouldApplyBasicShapeOrPath
;
float
opacity
;
MaskUsage
(
)
:
shouldGenerateMaskLayer
(
false
)
shouldGenerateClipMaskLayer
(
false
)
shouldApplyClipPath
(
false
)
shouldApplyBasicShapeOrPath
(
false
)
opacity
(
0
.
0
)
{
}
bool
shouldDoSomething
(
)
{
return
shouldGenerateMaskLayer
|
|
shouldGenerateClipMaskLayer
|
|
shouldApplyClipPath
|
|
shouldApplyBasicShapeOrPath
|
|
opacity
!
=
1
.
0
;
}
}
;
static
void
DetermineMaskUsage
(
nsIFrame
*
aFrame
bool
aHandleOpacity
MaskUsage
&
aUsage
)
;
static
float
ComputeOpacity
(
nsIFrame
*
aFrame
bool
aHandleOpacity
)
;
static
gfxMatrix
GetCSSPxToDevPxMatrix
(
nsIFrame
*
aNonSVGFrame
)
;
static
bool
IsInSVGTextSubtree
(
const
nsIFrame
*
aFrame
)
{
return
aFrame
-
>
HasAnyStateBits
(
NS_FRAME_IS_SVG_TEXT
)
;
}
static
gfxMatrix
GetTransformMatrixInUserSpace
(
const
nsIFrame
*
aFrame
)
;
}
;
}
#
endif
