#
ifndef
NS_SVGUTILS_H
#
define
NS_SVGUTILS_H
#
include
<
math
.
h
>
#
include
"
DrawMode
.
h
"
#
include
"
ImgDrawResult
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxMatrix
.
h
"
#
include
"
gfxPoint
.
h
"
#
include
"
gfxRect
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
nsAlgorithm
.
h
"
#
include
"
nsChangeHint
.
h
"
#
include
"
nsColor
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsID
.
h
"
#
include
"
nsIFrame
.
h
"
#
include
"
nsISupportsBase
.
h
"
#
include
"
nsMathUtils
.
h
"
#
include
"
nsStyleStruct
.
h
"
#
include
<
algorithm
>
class
gfxContext
;
class
nsFrameList
;
class
nsIContent
;
class
nsIFrame
;
class
nsPresContext
;
class
nsStyleSVGPaint
;
class
nsSVGDisplayContainerFrame
;
class
nsSVGLength2
;
class
nsSVGOuterSVGFrame
;
class
nsTextFrame
;
struct
nsStyleSVG
;
struct
nsRect
;
namespace
mozilla
{
class
SVGAnimatedEnumeration
;
class
SVGContextPaint
;
struct
SVGContextPaintImpl
;
class
SVGGeometryFrame
;
namespace
dom
{
class
Element
;
class
SVGElement
;
class
UserSpaceMetrics
;
}
namespace
gfx
{
class
DrawTarget
;
class
GeneralPattern
;
}
}
#
define
NS_SVG_OFFSCREEN_MAX_DIMENSION
4096
#
define
SVG_HIT_TEST_FILL
0x01
#
define
SVG_HIT_TEST_STROKE
0x02
#
define
SVG_HIT_TEST_CHECK_MRECT
0x04
bool
NS_SVGDisplayListHitTestingEnabled
(
)
;
bool
NS_SVGDisplayListPaintingEnabled
(
)
;
bool
NS_SVGNewGetBBoxEnabled
(
)
;
class
SVGBBox
{
typedef
mozilla
:
:
gfx
:
:
Rect
Rect
;
public
:
SVGBBox
(
)
:
mIsEmpty
(
true
)
{
}
MOZ_IMPLICIT
SVGBBox
(
const
Rect
&
aRect
)
:
mBBox
(
aRect
)
mIsEmpty
(
false
)
{
}
MOZ_IMPLICIT
SVGBBox
(
const
gfxRect
&
aRect
)
:
mBBox
(
ToRect
(
aRect
)
)
mIsEmpty
(
false
)
{
}
operator
const
Rect
&
(
)
{
return
mBBox
;
}
gfxRect
ToThebesRect
(
)
const
{
return
ThebesRect
(
mBBox
)
;
}
bool
IsEmpty
(
)
const
{
return
mIsEmpty
;
}
bool
IsFinite
(
)
const
{
return
mBBox
.
IsFinite
(
)
;
}
void
Scale
(
float
aScale
)
{
mBBox
.
Scale
(
aScale
)
;
}
void
UnionEdges
(
const
SVGBBox
&
aSVGBBox
)
{
if
(
aSVGBBox
.
mIsEmpty
)
{
return
;
}
mBBox
=
mIsEmpty
?
aSVGBBox
.
mBBox
:
mBBox
.
UnionEdges
(
aSVGBBox
.
mBBox
)
;
mIsEmpty
=
false
;
}
void
Intersect
(
const
SVGBBox
&
aSVGBBox
)
{
if
(
!
mIsEmpty
&
&
!
aSVGBBox
.
mIsEmpty
)
{
mBBox
=
mBBox
.
Intersect
(
aSVGBBox
.
mBBox
)
;
if
(
mBBox
.
IsEmpty
(
)
)
{
mIsEmpty
=
true
;
mBBox
=
Rect
(
0
0
0
0
)
;
}
}
else
{
mIsEmpty
=
true
;
mBBox
=
Rect
(
0
0
0
0
)
;
}
}
private
:
Rect
mBBox
;
bool
mIsEmpty
;
}
;
#
undef
CLIP_MASK
class
MOZ_RAII
SVGAutoRenderState
{
typedef
mozilla
:
:
gfx
:
:
DrawTarget
DrawTarget
;
public
:
explicit
SVGAutoRenderState
(
DrawTarget
*
aDrawTarget
MOZ_GUARD_OBJECT_NOTIFIER_PARAM
)
;
~
SVGAutoRenderState
(
)
;
void
SetPaintingToWindow
(
bool
aPaintingToWindow
)
;
static
bool
IsPaintingToWindow
(
DrawTarget
*
aDrawTarget
)
;
private
:
DrawTarget
*
mDrawTarget
;
void
*
mOriginalRenderState
;
bool
mPaintingToWindow
;
MOZ_DECL_USE_GUARD_OBJECT_NOTIFIER
}
;
class
nsSVGUtils
{
public
:
typedef
mozilla
:
:
dom
:
:
Element
Element
;
typedef
mozilla
:
:
dom
:
:
SVGElement
SVGElement
;
typedef
mozilla
:
:
gfx
:
:
AntialiasMode
AntialiasMode
;
typedef
mozilla
:
:
gfx
:
:
DrawTarget
DrawTarget
;
typedef
mozilla
:
:
gfx
:
:
FillRule
FillRule
;
typedef
mozilla
:
:
gfx
:
:
GeneralPattern
GeneralPattern
;
typedef
mozilla
:
:
gfx
:
:
Size
Size
;
typedef
mozilla
:
:
SVGContextPaint
SVGContextPaint
;
typedef
mozilla
:
:
SVGContextPaintImpl
SVGContextPaintImpl
;
typedef
mozilla
:
:
SVGGeometryFrame
SVGGeometryFrame
;
typedef
mozilla
:
:
image
:
:
imgDrawingParams
imgDrawingParams
;
static
void
Init
(
)
;
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
ObjectBoundingBoxProperty
gfxRect
)
static
nsRect
GetPostFilterVisualOverflowRect
(
nsIFrame
*
aFrame
const
nsRect
&
aUnfilteredRect
)
;
static
void
ScheduleReflowSVG
(
nsIFrame
*
aFrame
)
;
static
bool
NeedsReflowSVG
(
nsIFrame
*
aFrame
)
;
static
Size
GetContextSize
(
const
nsIFrame
*
aFrame
)
;
static
float
ObjectSpace
(
const
gfxRect
&
aRect
const
nsSVGLength2
*
aLength
)
;
static
float
UserSpace
(
SVGElement
*
aSVGElement
const
nsSVGLength2
*
aLength
)
;
static
float
UserSpace
(
nsIFrame
*
aFrame
const
nsSVGLength2
*
aLength
)
;
static
float
UserSpace
(
const
mozilla
:
:
dom
:
:
UserSpaceMetrics
&
aMetrics
const
nsSVGLength2
*
aLength
)
;
static
nsSVGOuterSVGFrame
*
GetOuterSVGFrame
(
nsIFrame
*
aFrame
)
;
static
nsIFrame
*
GetOuterSVGFrameAndCoveredRegion
(
nsIFrame
*
aFrame
nsRect
*
aRect
)
;
static
void
PaintFrameWithEffects
(
nsIFrame
*
aFrame
gfxContext
&
aContext
const
gfxMatrix
&
aTransform
imgDrawingParams
&
aImgParams
const
nsIntRect
*
aDirtyRect
=
nullptr
)
;
static
bool
HitTestClip
(
nsIFrame
*
aFrame
const
gfxPoint
&
aPoint
)
;
static
nsIFrame
*
HitTestChildren
(
nsSVGDisplayContainerFrame
*
aFrame
const
gfxPoint
&
aPoint
)
;
static
gfxMatrix
GetCanvasTM
(
nsIFrame
*
aFrame
)
;
static
gfxMatrix
GetUserToCanvasTM
(
nsIFrame
*
aFrame
)
;
static
void
NotifyChildrenOfSVGChange
(
nsIFrame
*
aFrame
uint32_t
aFlags
)
;
static
nsRect
TransformFrameRectToOuterSVG
(
const
nsRect
&
aRect
const
gfxMatrix
&
aMatrix
nsPresContext
*
aPresContext
)
;
static
mozilla
:
:
gfx
:
:
IntSize
ConvertToSurfaceSize
(
const
gfxSize
&
aSize
bool
*
aResultOverflows
)
;
static
bool
HitTestRect
(
const
mozilla
:
:
gfx
:
:
Matrix
&
aMatrix
float
aRX
float
aRY
float
aRWidth
float
aRHeight
float
aX
float
aY
)
;
static
gfxRect
GetClipRectForFrame
(
nsIFrame
*
aFrame
float
aX
float
aY
float
aWidth
float
aHeight
)
;
static
void
SetClipRect
(
gfxContext
*
aContext
const
gfxMatrix
&
aCTM
const
gfxRect
&
aRect
)
;
static
bool
CanOptimizeOpacity
(
nsIFrame
*
aFrame
)
;
static
gfxMatrix
AdjustMatrixForUnits
(
const
gfxMatrix
&
aMatrix
mozilla
:
:
SVGAnimatedEnumeration
*
aUnits
nsIFrame
*
aFrame
uint32_t
aFlags
)
;
enum
BBoxFlags
{
eBBoxIncludeFill
=
1
<
<
0
eBBoxIncludeFillGeometry
=
1
<
<
1
eBBoxIncludeStroke
=
1
<
<
2
eBBoxIncludeStrokeGeometry
=
1
<
<
3
eBBoxIncludeMarkers
=
1
<
<
4
eBBoxIncludeClipped
=
1
<
<
5
eUseFrameBoundsForOuterSVG
=
1
<
<
6
eForGetClientRects
=
1
<
<
7
eIncludeOnlyCurrentFrameForNonSVGElement
=
1
<
<
8
eUseUserSpaceOfUseElement
=
1
<
<
9
eDoNotClipToBBoxOfContentInsideClipPath
=
1
<
<
10
}
;
static
gfxRect
GetBBox
(
nsIFrame
*
aFrame
uint32_t
aFlags
=
eBBoxIncludeFillGeometry
const
gfxMatrix
*
aToBoundsSpace
=
nullptr
)
;
static
gfxPoint
FrameSpaceInCSSPxToUserSpaceOffset
(
nsIFrame
*
aFrame
)
;
static
gfxRect
GetRelativeRect
(
uint16_t
aUnits
const
nsSVGLength2
*
aXYWH
const
gfxRect
&
aBBox
nsIFrame
*
aFrame
)
;
static
gfxRect
GetRelativeRect
(
uint16_t
aUnits
const
nsSVGLength2
*
aXYWH
const
gfxRect
&
aBBox
const
mozilla
:
:
dom
:
:
UserSpaceMetrics
&
aMetrics
)
;
static
nsIFrame
*
GetFirstNonAAncestorFrame
(
nsIFrame
*
aStartFrame
)
;
static
bool
OuterSVGIsCallingReflowSVG
(
nsIFrame
*
aFrame
)
;
static
bool
AnyOuterSVGIsCallingReflowSVG
(
nsIFrame
*
aFrame
)
;
static
bool
GetNonScalingStrokeTransform
(
nsIFrame
*
aFrame
gfxMatrix
*
aUserToOuterSVG
)
;
static
gfxRect
PathExtentsToMaxStrokeExtents
(
const
gfxRect
&
aPathExtents
nsTextFrame
*
aFrame
const
gfxMatrix
&
aMatrix
)
;
static
gfxRect
PathExtentsToMaxStrokeExtents
(
const
gfxRect
&
aPathExtents
SVGGeometryFrame
*
aFrame
const
gfxMatrix
&
aMatrix
)
;
static
int32_t
ClampToInt
(
double
aVal
)
{
return
NS_lround
(
std
:
:
max
(
double
(
INT32_MIN
)
std
:
:
min
(
double
(
INT32_MAX
)
aVal
)
)
)
;
}
static
nscolor
GetFallbackOrPaintColor
(
mozilla
:
:
ComputedStyle
*
aComputedStyle
nsStyleSVGPaint
nsStyleSVG
:
:
*
aFillOrStroke
)
;
static
void
MakeFillPatternFor
(
nsIFrame
*
aFrame
gfxContext
*
aContext
GeneralPattern
*
aOutPattern
imgDrawingParams
&
aImgParams
SVGContextPaint
*
aContextPaint
=
nullptr
)
;
static
void
MakeStrokePatternFor
(
nsIFrame
*
aFrame
gfxContext
*
aContext
GeneralPattern
*
aOutPattern
imgDrawingParams
&
aImgParams
SVGContextPaint
*
aContextPaint
=
nullptr
)
;
static
float
GetOpacity
(
nsStyleSVGOpacitySource
aOpacityType
const
float
&
aOpacity
SVGContextPaint
*
aContextPaint
)
;
static
bool
HasStroke
(
nsIFrame
*
aFrame
SVGContextPaint
*
aContextPaint
=
nullptr
)
;
static
float
GetStrokeWidth
(
nsIFrame
*
aFrame
SVGContextPaint
*
aContextPaint
=
nullptr
)
;
static
void
SetupStrokeGeometry
(
nsIFrame
*
aFrame
gfxContext
*
aContext
SVGContextPaint
*
aContextPaint
=
nullptr
)
;
static
uint16_t
GetGeometryHitTestFlags
(
nsIFrame
*
aFrame
)
;
static
FillRule
ToFillRule
(
mozilla
:
:
StyleFillRule
aFillRule
)
{
return
aFillRule
=
=
mozilla
:
:
StyleFillRule
:
:
Evenodd
?
FillRule
:
:
FILL_EVEN_ODD
:
FillRule
:
:
FILL_WINDING
;
}
static
AntialiasMode
ToAntialiasMode
(
mozilla
:
:
StyleTextRendering
aTextRendering
)
{
return
aTextRendering
=
=
mozilla
:
:
StyleTextRendering
:
:
Optimizespeed
?
AntialiasMode
:
:
NONE
:
AntialiasMode
:
:
SUBPIXEL
;
}
static
void
PaintSVGGlyph
(
Element
*
aElement
gfxContext
*
aContext
)
;
static
bool
GetSVGGlyphExtents
(
Element
*
aElement
const
gfxMatrix
&
aSVGToAppSpace
gfxRect
*
aResult
)
;
static
nsRect
ToCanvasBounds
(
const
gfxRect
&
aUserspaceRect
const
gfxMatrix
&
aToCanvas
const
nsPresContext
*
presContext
)
;
struct
MaskUsage
{
bool
shouldGenerateMaskLayer
;
bool
shouldGenerateClipMaskLayer
;
bool
shouldApplyClipPath
;
bool
shouldApplyBasicShapeOrPath
;
float
opacity
;
MaskUsage
(
)
:
shouldGenerateMaskLayer
(
false
)
shouldGenerateClipMaskLayer
(
false
)
shouldApplyClipPath
(
false
)
shouldApplyBasicShapeOrPath
(
false
)
opacity
(
0
.
0
)
{
}
bool
shouldDoSomething
(
)
{
return
shouldGenerateMaskLayer
|
|
shouldGenerateClipMaskLayer
|
|
shouldApplyClipPath
|
|
shouldApplyBasicShapeOrPath
|
|
opacity
!
=
1
.
0
;
}
}
;
static
void
DetermineMaskUsage
(
nsIFrame
*
aFrame
bool
aHandleOpacity
MaskUsage
&
aUsage
)
;
static
float
ComputeOpacity
(
nsIFrame
*
aFrame
bool
aHandleOpacity
)
;
static
gfxMatrix
GetCSSPxToDevPxMatrix
(
nsIFrame
*
aNonSVGFrame
)
;
static
bool
IsInSVGTextSubtree
(
const
nsIFrame
*
aFrame
)
{
return
aFrame
-
>
GetStateBits
(
)
&
NS_FRAME_IS_SVG_TEXT
;
}
}
;
#
endif
