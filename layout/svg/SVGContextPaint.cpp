#
include
"
SVGContextPaint
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
dom
/
SVGDocument
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsSVGPaintServerFrame
.
h
"
#
include
"
SVGObserverUtils
.
h
"
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
image
;
namespace
mozilla
{
using
image
:
:
imgDrawingParams
;
bool
SVGContextPaint
:
:
IsAllowedForImageFromURI
(
nsIURI
*
aURI
)
{
static
bool
sEnabledForContent
=
false
;
static
bool
sEnabledForContentCached
=
false
;
if
(
!
sEnabledForContentCached
)
{
Preferences
:
:
AddBoolVarCache
(
&
sEnabledForContent
"
svg
.
context
-
properties
.
content
.
enabled
"
false
)
;
sEnabledForContentCached
=
true
;
}
if
(
sEnabledForContent
)
{
return
true
;
}
nsAutoCString
scheme
;
if
(
NS_SUCCEEDED
(
aURI
-
>
GetScheme
(
scheme
)
)
&
&
(
scheme
.
EqualsLiteral
(
"
chrome
"
)
|
|
scheme
.
EqualsLiteral
(
"
resource
"
)
|
|
scheme
.
EqualsLiteral
(
"
page
-
icon
"
)
)
)
{
return
true
;
}
RefPtr
<
BasePrincipal
>
principal
=
BasePrincipal
:
:
CreateCodebasePrincipal
(
aURI
OriginAttributes
(
)
)
;
nsString
addonId
;
if
(
NS_SUCCEEDED
(
principal
-
>
GetAddonId
(
addonId
)
)
)
{
if
(
StringEndsWith
(
addonId
NS_LITERAL_STRING
(
"
mozilla
.
org
"
)
)
|
|
StringEndsWith
(
addonId
NS_LITERAL_STRING
(
"
mozilla
.
com
"
)
)
)
{
return
true
;
}
}
return
false
;
}
static
void
SetupInheritablePaint
(
const
DrawTarget
*
aDrawTarget
const
gfxMatrix
&
aContextMatrix
nsIFrame
*
aFrame
float
&
aOpacity
SVGContextPaint
*
aOuterContextPaint
SVGContextPaintImpl
:
:
Paint
&
aTargetPaint
nsStyleSVGPaint
nsStyleSVG
:
:
*
aFillOrStroke
imgDrawingParams
&
aImgParams
)
{
const
nsStyleSVG
*
style
=
aFrame
-
>
StyleSVG
(
)
;
nsSVGPaintServerFrame
*
ps
=
SVGObserverUtils
:
:
GetAndObservePaintServer
(
aFrame
aFillOrStroke
)
;
if
(
ps
)
{
RefPtr
<
gfxPattern
>
pattern
=
ps
-
>
GetPaintServerPattern
(
aFrame
aDrawTarget
aContextMatrix
aFillOrStroke
aOpacity
aImgParams
)
;
if
(
pattern
)
{
aTargetPaint
.
SetPaintServer
(
aFrame
aContextMatrix
ps
)
;
return
;
}
}
if
(
aOuterContextPaint
)
{
RefPtr
<
gfxPattern
>
pattern
;
switch
(
(
style
-
>
*
aFillOrStroke
)
.
Type
(
)
)
{
case
eStyleSVGPaintType_ContextFill
:
pattern
=
aOuterContextPaint
-
>
GetFillPattern
(
aDrawTarget
aOpacity
aContextMatrix
aImgParams
)
;
break
;
case
eStyleSVGPaintType_ContextStroke
:
pattern
=
aOuterContextPaint
-
>
GetStrokePattern
(
aDrawTarget
aOpacity
aContextMatrix
aImgParams
)
;
break
;
default
:
;
}
if
(
pattern
)
{
aTargetPaint
.
SetContextPaint
(
aOuterContextPaint
(
style
-
>
*
aFillOrStroke
)
.
Type
(
)
)
;
return
;
}
}
nscolor
color
=
nsSVGUtils
:
:
GetFallbackOrPaintColor
(
aFrame
-
>
Style
(
)
aFillOrStroke
)
;
aTargetPaint
.
SetColor
(
color
)
;
}
DrawMode
SVGContextPaintImpl
:
:
Init
(
const
DrawTarget
*
aDrawTarget
const
gfxMatrix
&
aContextMatrix
nsIFrame
*
aFrame
SVGContextPaint
*
aOuterContextPaint
imgDrawingParams
&
aImgParams
)
{
DrawMode
toDraw
=
DrawMode
(
0
)
;
const
nsStyleSVG
*
style
=
aFrame
-
>
StyleSVG
(
)
;
if
(
style
-
>
mFill
.
Type
(
)
=
=
eStyleSVGPaintType_None
)
{
SetFillOpacity
(
0
.
0f
)
;
}
else
{
float
opacity
=
nsSVGUtils
:
:
GetOpacity
(
style
-
>
FillOpacitySource
(
)
style
-
>
mFillOpacity
aOuterContextPaint
)
;
SetupInheritablePaint
(
aDrawTarget
aContextMatrix
aFrame
opacity
aOuterContextPaint
mFillPaint
&
nsStyleSVG
:
:
mFill
aImgParams
)
;
SetFillOpacity
(
opacity
)
;
toDraw
|
=
DrawMode
:
:
GLYPH_FILL
;
}
if
(
style
-
>
mStroke
.
Type
(
)
=
=
eStyleSVGPaintType_None
)
{
SetStrokeOpacity
(
0
.
0f
)
;
}
else
{
float
opacity
=
nsSVGUtils
:
:
GetOpacity
(
style
-
>
StrokeOpacitySource
(
)
style
-
>
mStrokeOpacity
aOuterContextPaint
)
;
SetupInheritablePaint
(
aDrawTarget
aContextMatrix
aFrame
opacity
aOuterContextPaint
mStrokePaint
&
nsStyleSVG
:
:
mStroke
aImgParams
)
;
SetStrokeOpacity
(
opacity
)
;
toDraw
|
=
DrawMode
:
:
GLYPH_STROKE
;
}
return
toDraw
;
}
void
SVGContextPaint
:
:
InitStrokeGeometry
(
gfxContext
*
aContext
float
devUnitsPerSVGUnit
)
{
mStrokeWidth
=
aContext
-
>
CurrentLineWidth
(
)
/
devUnitsPerSVGUnit
;
aContext
-
>
CurrentDash
(
mDashes
&
mDashOffset
)
;
for
(
uint32_t
i
=
0
;
i
<
mDashes
.
Length
(
)
;
i
+
+
)
{
mDashes
[
i
]
/
=
devUnitsPerSVGUnit
;
}
mDashOffset
/
=
devUnitsPerSVGUnit
;
}
SVGContextPaint
*
SVGContextPaint
:
:
GetContextPaint
(
nsIContent
*
aContent
)
{
dom
:
:
Document
*
ownerDoc
=
aContent
-
>
OwnerDoc
(
)
;
if
(
!
ownerDoc
-
>
IsSVGDocument
(
)
)
{
return
nullptr
;
}
auto
*
contextPaint
=
ownerDoc
-
>
AsSVGDocument
(
)
-
>
GetCurrentContextPaint
(
)
;
MOZ_ASSERT_IF
(
contextPaint
ownerDoc
-
>
IsBeingUsedAsImage
(
)
)
;
return
const_cast
<
SVGContextPaint
*
>
(
contextPaint
)
;
}
already_AddRefed
<
gfxPattern
>
SVGContextPaintImpl
:
:
GetFillPattern
(
const
DrawTarget
*
aDrawTarget
float
aOpacity
const
gfxMatrix
&
aCTM
imgDrawingParams
&
aImgParams
)
{
return
mFillPaint
.
GetPattern
(
aDrawTarget
aOpacity
&
nsStyleSVG
:
:
mFill
aCTM
aImgParams
)
;
}
already_AddRefed
<
gfxPattern
>
SVGContextPaintImpl
:
:
GetStrokePattern
(
const
DrawTarget
*
aDrawTarget
float
aOpacity
const
gfxMatrix
&
aCTM
imgDrawingParams
&
aImgParams
)
{
return
mStrokePaint
.
GetPattern
(
aDrawTarget
aOpacity
&
nsStyleSVG
:
:
mStroke
aCTM
aImgParams
)
;
}
already_AddRefed
<
gfxPattern
>
SVGContextPaintImpl
:
:
Paint
:
:
GetPattern
(
const
DrawTarget
*
aDrawTarget
float
aOpacity
nsStyleSVGPaint
nsStyleSVG
:
:
*
aFillOrStroke
const
gfxMatrix
&
aCTM
imgDrawingParams
&
aImgParams
)
{
RefPtr
<
gfxPattern
>
pattern
;
if
(
mPatternCache
.
Get
(
aOpacity
getter_AddRefs
(
pattern
)
)
)
{
pattern
-
>
SetMatrix
(
aCTM
*
mPatternMatrix
)
;
return
pattern
.
forget
(
)
;
}
switch
(
mPaintType
)
{
case
eStyleSVGPaintType_None
:
pattern
=
new
gfxPattern
(
Color
(
)
)
;
mPatternMatrix
=
gfxMatrix
(
)
;
break
;
case
eStyleSVGPaintType_Color
:
{
Color
color
=
Color
:
:
FromABGR
(
mPaintDefinition
.
mColor
)
;
color
.
a
*
=
aOpacity
;
pattern
=
new
gfxPattern
(
color
)
;
mPatternMatrix
=
gfxMatrix
(
)
;
break
;
}
case
eStyleSVGPaintType_Server
:
pattern
=
mPaintDefinition
.
mPaintServerFrame
-
>
GetPaintServerPattern
(
mFrame
aDrawTarget
mContextMatrix
aFillOrStroke
aOpacity
aImgParams
)
;
{
gfxMatrix
m
=
pattern
-
>
GetMatrix
(
)
;
gfxMatrix
deviceToOriginalUserSpace
=
mContextMatrix
;
if
(
!
deviceToOriginalUserSpace
.
Invert
(
)
)
{
return
nullptr
;
}
mPatternMatrix
=
deviceToOriginalUserSpace
*
m
;
}
pattern
-
>
SetMatrix
(
aCTM
*
mPatternMatrix
)
;
break
;
case
eStyleSVGPaintType_ContextFill
:
pattern
=
mPaintDefinition
.
mContextPaint
-
>
GetFillPattern
(
aDrawTarget
aOpacity
aCTM
aImgParams
)
;
return
pattern
.
forget
(
)
;
case
eStyleSVGPaintType_ContextStroke
:
pattern
=
mPaintDefinition
.
mContextPaint
-
>
GetStrokePattern
(
aDrawTarget
aOpacity
aCTM
aImgParams
)
;
return
pattern
.
forget
(
)
;
default
:
MOZ_ASSERT
(
false
"
invalid
paint
type
"
)
;
return
nullptr
;
}
mPatternCache
.
Put
(
aOpacity
pattern
)
;
return
pattern
.
forget
(
)
;
}
AutoSetRestoreSVGContextPaint
:
:
AutoSetRestoreSVGContextPaint
(
const
SVGContextPaint
&
aContextPaint
dom
:
:
SVGDocument
&
aSVGDocument
)
:
mSVGDocument
(
aSVGDocument
)
mOuterContextPaint
(
aSVGDocument
.
GetCurrentContextPaint
(
)
)
{
MOZ_ASSERT
(
aSVGDocument
.
IsBeingUsedAsImage
(
)
"
SVGContextPaint
:
:
GetContextPaint
assumes
this
"
)
;
mSVGDocument
.
SetCurrentContextPaint
(
&
aContextPaint
)
;
}
AutoSetRestoreSVGContextPaint
:
:
~
AutoSetRestoreSVGContextPaint
(
)
{
mSVGDocument
.
SetCurrentContextPaint
(
mOuterContextPaint
)
;
}
already_AddRefed
<
gfxPattern
>
SVGEmbeddingContextPaint
:
:
GetFillPattern
(
const
DrawTarget
*
aDrawTarget
float
aFillOpacity
const
gfxMatrix
&
aCTM
imgDrawingParams
&
aImgParams
)
{
if
(
!
mFill
)
{
return
nullptr
;
}
Color
fill
=
*
mFill
;
fill
.
a
*
=
aFillOpacity
;
return
do_AddRef
(
new
gfxPattern
(
fill
)
)
;
}
already_AddRefed
<
gfxPattern
>
SVGEmbeddingContextPaint
:
:
GetStrokePattern
(
const
DrawTarget
*
aDrawTarget
float
aStrokeOpacity
const
gfxMatrix
&
aCTM
imgDrawingParams
&
aImgParams
)
{
if
(
!
mStroke
)
{
return
nullptr
;
}
Color
stroke
=
*
mStroke
;
stroke
.
a
*
=
aStrokeOpacity
;
return
do_AddRef
(
new
gfxPattern
(
stroke
)
)
;
}
uint32_t
SVGEmbeddingContextPaint
:
:
Hash
(
)
const
{
uint32_t
hash
=
0
;
if
(
mFill
)
{
hash
=
HashGeneric
(
hash
mFill
-
>
ToABGR
(
)
)
;
}
else
{
hash
=
1
;
}
if
(
mStroke
)
{
hash
=
HashGeneric
(
hash
mStroke
-
>
ToABGR
(
)
)
;
}
if
(
mFillOpacity
!
=
1
.
0f
)
{
hash
=
HashGeneric
(
hash
mFillOpacity
)
;
}
if
(
mStrokeOpacity
!
=
1
.
0f
)
{
hash
=
HashGeneric
(
hash
mStrokeOpacity
)
;
}
return
hash
;
}
}
