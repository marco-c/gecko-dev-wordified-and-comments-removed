#
include
"
SVGContextPaint
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsSVGPaintServerFrame
.
h
"
#
include
"
nsSVGEffects
.
h
"
#
include
"
nsSVGPaintServerFrame
.
h
"
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
image
;
namespace
mozilla
{
bool
SVGContextPaint
:
:
IsAllowedForImageFromURI
(
nsIURI
*
aURI
)
{
static
bool
sEnabledForContent
=
false
;
static
bool
sEnabledForContentCached
=
false
;
if
(
!
sEnabledForContentCached
)
{
Preferences
:
:
AddBoolVarCache
(
&
sEnabledForContent
"
svg
.
context
-
properties
.
content
.
enabled
"
false
)
;
sEnabledForContentCached
=
true
;
}
if
(
sEnabledForContent
)
{
return
true
;
}
nsAutoCString
scheme
;
if
(
NS_SUCCEEDED
(
aURI
-
>
GetScheme
(
scheme
)
)
&
&
(
scheme
.
EqualsLiteral
(
"
chrome
"
)
|
|
scheme
.
EqualsLiteral
(
"
resource
"
)
)
)
{
return
true
;
}
return
false
;
}
static
DrawResult
SetupInheritablePaint
(
const
DrawTarget
*
aDrawTarget
const
gfxMatrix
&
aContextMatrix
nsIFrame
*
aFrame
float
&
aOpacity
SVGContextPaint
*
aOuterContextPaint
SVGContextPaintImpl
:
:
Paint
&
aTargetPaint
nsStyleSVGPaint
nsStyleSVG
:
:
*
aFillOrStroke
nsSVGEffects
:
:
PaintingPropertyDescriptor
aProperty
)
{
const
nsStyleSVG
*
style
=
aFrame
-
>
StyleSVG
(
)
;
nsSVGPaintServerFrame
*
ps
=
nsSVGEffects
:
:
GetPaintServer
(
aFrame
aFillOrStroke
aProperty
)
;
DrawResult
result
=
DrawResult
:
:
SUCCESS
;
if
(
ps
)
{
RefPtr
<
gfxPattern
>
pattern
;
Tie
(
result
pattern
)
=
ps
-
>
GetPaintServerPattern
(
aFrame
aDrawTarget
aContextMatrix
aFillOrStroke
aOpacity
)
;
if
(
pattern
)
{
aTargetPaint
.
SetPaintServer
(
aFrame
aContextMatrix
ps
)
;
return
result
;
}
}
if
(
aOuterContextPaint
)
{
RefPtr
<
gfxPattern
>
pattern
;
switch
(
(
style
-
>
*
aFillOrStroke
)
.
Type
(
)
)
{
case
eStyleSVGPaintType_ContextFill
:
Tie
(
result
pattern
)
=
aOuterContextPaint
-
>
GetFillPattern
(
aDrawTarget
aOpacity
aContextMatrix
)
;
break
;
case
eStyleSVGPaintType_ContextStroke
:
Tie
(
result
pattern
)
=
aOuterContextPaint
-
>
GetStrokePattern
(
aDrawTarget
aOpacity
aContextMatrix
)
;
break
;
default
:
;
}
if
(
pattern
)
{
aTargetPaint
.
SetContextPaint
(
aOuterContextPaint
(
style
-
>
*
aFillOrStroke
)
.
Type
(
)
)
;
return
result
;
}
}
nscolor
color
=
nsSVGUtils
:
:
GetFallbackOrPaintColor
(
aFrame
-
>
StyleContext
(
)
aFillOrStroke
)
;
aTargetPaint
.
SetColor
(
color
)
;
return
result
;
}
mozilla
:
:
Pair
<
DrawResult
DrawMode
>
SVGContextPaintImpl
:
:
Init
(
const
DrawTarget
*
aDrawTarget
const
gfxMatrix
&
aContextMatrix
nsIFrame
*
aFrame
SVGContextPaint
*
aOuterContextPaint
)
{
DrawMode
toDraw
=
DrawMode
(
0
)
;
const
nsStyleSVG
*
style
=
aFrame
-
>
StyleSVG
(
)
;
DrawResult
result
=
DrawResult
:
:
SUCCESS
;
if
(
style
-
>
mFill
.
Type
(
)
=
=
eStyleSVGPaintType_None
)
{
SetFillOpacity
(
0
.
0f
)
;
}
else
{
float
opacity
=
nsSVGUtils
:
:
GetOpacity
(
style
-
>
FillOpacitySource
(
)
style
-
>
mFillOpacity
aOuterContextPaint
)
;
result
&
=
SetupInheritablePaint
(
aDrawTarget
aContextMatrix
aFrame
opacity
aOuterContextPaint
mFillPaint
&
nsStyleSVG
:
:
mFill
nsSVGEffects
:
:
FillProperty
(
)
)
;
SetFillOpacity
(
opacity
)
;
toDraw
|
=
DrawMode
:
:
GLYPH_FILL
;
}
if
(
style
-
>
mStroke
.
Type
(
)
=
=
eStyleSVGPaintType_None
)
{
SetStrokeOpacity
(
0
.
0f
)
;
}
else
{
float
opacity
=
nsSVGUtils
:
:
GetOpacity
(
style
-
>
StrokeOpacitySource
(
)
style
-
>
mStrokeOpacity
aOuterContextPaint
)
;
result
&
=
SetupInheritablePaint
(
aDrawTarget
aContextMatrix
aFrame
opacity
aOuterContextPaint
mStrokePaint
&
nsStyleSVG
:
:
mStroke
nsSVGEffects
:
:
StrokeProperty
(
)
)
;
SetStrokeOpacity
(
opacity
)
;
toDraw
|
=
DrawMode
:
:
GLYPH_STROKE
;
}
return
MakePair
(
result
toDraw
)
;
}
void
SVGContextPaint
:
:
InitStrokeGeometry
(
gfxContext
*
aContext
float
devUnitsPerSVGUnit
)
{
mStrokeWidth
=
aContext
-
>
CurrentLineWidth
(
)
/
devUnitsPerSVGUnit
;
aContext
-
>
CurrentDash
(
mDashes
&
mDashOffset
)
;
for
(
uint32_t
i
=
0
;
i
<
mDashes
.
Length
(
)
;
i
+
+
)
{
mDashes
[
i
]
/
=
devUnitsPerSVGUnit
;
}
mDashOffset
/
=
devUnitsPerSVGUnit
;
}
SVGContextPaint
*
SVGContextPaint
:
:
GetContextPaint
(
nsIContent
*
aContent
)
{
nsIDocument
*
ownerDoc
=
aContent
-
>
OwnerDoc
(
)
;
if
(
!
ownerDoc
-
>
IsBeingUsedAsImage
(
)
)
{
return
nullptr
;
}
return
static_cast
<
SVGContextPaint
*
>
(
ownerDoc
-
>
GetProperty
(
nsGkAtoms
:
:
svgContextPaint
)
)
;
}
mozilla
:
:
Pair
<
DrawResult
RefPtr
<
gfxPattern
>
>
SVGContextPaintImpl
:
:
GetFillPattern
(
const
DrawTarget
*
aDrawTarget
float
aOpacity
const
gfxMatrix
&
aCTM
uint32_t
aFlags
)
{
return
mFillPaint
.
GetPattern
(
aDrawTarget
aOpacity
&
nsStyleSVG
:
:
mFill
aCTM
aFlags
)
;
}
mozilla
:
:
Pair
<
DrawResult
RefPtr
<
gfxPattern
>
>
SVGContextPaintImpl
:
:
GetStrokePattern
(
const
DrawTarget
*
aDrawTarget
float
aOpacity
const
gfxMatrix
&
aCTM
uint32_t
aFlags
)
{
return
mStrokePaint
.
GetPattern
(
aDrawTarget
aOpacity
&
nsStyleSVG
:
:
mStroke
aCTM
aFlags
)
;
}
mozilla
:
:
Pair
<
DrawResult
RefPtr
<
gfxPattern
>
>
SVGContextPaintImpl
:
:
Paint
:
:
GetPattern
(
const
DrawTarget
*
aDrawTarget
float
aOpacity
nsStyleSVGPaint
nsStyleSVG
:
:
*
aFillOrStroke
const
gfxMatrix
&
aCTM
uint32_t
aFlags
)
{
RefPtr
<
gfxPattern
>
pattern
;
if
(
mPatternCache
.
Get
(
aOpacity
getter_AddRefs
(
pattern
)
)
)
{
pattern
-
>
SetMatrix
(
aCTM
*
mPatternMatrix
)
;
return
MakePair
(
DrawResult
:
:
SUCCESS
Move
(
pattern
)
)
;
}
DrawResult
result
=
DrawResult
:
:
SUCCESS
;
switch
(
mPaintType
)
{
case
eStyleSVGPaintType_None
:
pattern
=
new
gfxPattern
(
Color
(
)
)
;
mPatternMatrix
=
gfxMatrix
(
)
;
break
;
case
eStyleSVGPaintType_Color
:
{
Color
color
=
Color
:
:
FromABGR
(
mPaintDefinition
.
mColor
)
;
color
.
a
*
=
aOpacity
;
pattern
=
new
gfxPattern
(
color
)
;
mPatternMatrix
=
gfxMatrix
(
)
;
break
;
}
case
eStyleSVGPaintType_Server
:
Tie
(
result
pattern
)
=
mPaintDefinition
.
mPaintServerFrame
-
>
GetPaintServerPattern
(
mFrame
aDrawTarget
mContextMatrix
aFillOrStroke
aOpacity
nullptr
aFlags
)
;
{
gfxMatrix
m
=
pattern
-
>
GetMatrix
(
)
;
gfxMatrix
deviceToOriginalUserSpace
=
mContextMatrix
;
if
(
!
deviceToOriginalUserSpace
.
Invert
(
)
)
{
return
MakePair
(
DrawResult
:
:
SUCCESS
RefPtr
<
gfxPattern
>
(
)
)
;
}
mPatternMatrix
=
deviceToOriginalUserSpace
*
m
;
}
pattern
-
>
SetMatrix
(
aCTM
*
mPatternMatrix
)
;
break
;
case
eStyleSVGPaintType_ContextFill
:
Tie
(
result
pattern
)
=
mPaintDefinition
.
mContextPaint
-
>
GetFillPattern
(
aDrawTarget
aOpacity
aCTM
aFlags
)
;
return
MakePair
(
result
Move
(
pattern
)
)
;
case
eStyleSVGPaintType_ContextStroke
:
Tie
(
result
pattern
)
=
mPaintDefinition
.
mContextPaint
-
>
GetStrokePattern
(
aDrawTarget
aOpacity
aCTM
aFlags
)
;
return
MakePair
(
result
Move
(
pattern
)
)
;
default
:
MOZ_ASSERT
(
false
"
invalid
paint
type
"
)
;
return
MakePair
(
DrawResult
:
:
SUCCESS
RefPtr
<
gfxPattern
>
(
)
)
;
}
mPatternCache
.
Put
(
aOpacity
pattern
)
;
return
MakePair
(
result
Move
(
pattern
)
)
;
}
AutoSetRestoreSVGContextPaint
:
:
AutoSetRestoreSVGContextPaint
(
const
SVGContextPaint
*
aContextPaint
nsIDocument
*
aSVGDocument
)
:
mSVGDocument
(
aSVGDocument
)
mOuterContextPaint
(
aSVGDocument
-
>
GetProperty
(
nsGkAtoms
:
:
svgContextPaint
)
)
{
MOZ_ASSERT
(
aContextPaint
)
;
MOZ_ASSERT
(
aSVGDocument
-
>
IsBeingUsedAsImage
(
)
"
SVGContextPaint
:
:
GetContextPaint
assumes
this
"
)
;
if
(
mOuterContextPaint
)
{
mSVGDocument
-
>
UnsetProperty
(
nsGkAtoms
:
:
svgContextPaint
)
;
}
DebugOnly
<
nsresult
>
res
=
mSVGDocument
-
>
SetProperty
(
nsGkAtoms
:
:
svgContextPaint
const_cast
<
SVGContextPaint
*
>
(
aContextPaint
)
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
res
)
"
Failed
to
set
context
paint
"
)
;
}
AutoSetRestoreSVGContextPaint
:
:
~
AutoSetRestoreSVGContextPaint
(
)
{
mSVGDocument
-
>
UnsetProperty
(
nsGkAtoms
:
:
svgContextPaint
)
;
if
(
mOuterContextPaint
)
{
DebugOnly
<
nsresult
>
res
=
mSVGDocument
-
>
SetProperty
(
nsGkAtoms
:
:
svgContextPaint
mOuterContextPaint
)
;
NS_WARNING_ASSERTION
(
NS_SUCCEEDED
(
res
)
"
Failed
to
restore
context
paint
"
)
;
}
}
mozilla
:
:
Pair
<
DrawResult
RefPtr
<
gfxPattern
>
>
SVGEmbeddingContextPaint
:
:
GetFillPattern
(
const
DrawTarget
*
aDrawTarget
float
aFillOpacity
const
gfxMatrix
&
aCTM
uint32_t
aFlags
)
{
if
(
!
mFill
)
{
return
MakePair
(
DrawResult
:
:
SUCCESS
RefPtr
<
gfxPattern
>
(
)
)
;
}
Color
fill
=
*
mFill
;
fill
.
a
*
=
aFillOpacity
;
RefPtr
<
gfxPattern
>
patern
=
new
gfxPattern
(
fill
)
;
return
MakePair
(
DrawResult
:
:
SUCCESS
Move
(
patern
)
)
;
}
mozilla
:
:
Pair
<
DrawResult
RefPtr
<
gfxPattern
>
>
SVGEmbeddingContextPaint
:
:
GetStrokePattern
(
const
DrawTarget
*
aDrawTarget
float
aStrokeOpacity
const
gfxMatrix
&
aCTM
uint32_t
aFlags
)
{
if
(
!
mStroke
)
{
return
MakePair
(
DrawResult
:
:
SUCCESS
RefPtr
<
gfxPattern
>
(
)
)
;
}
Color
stroke
=
*
mStroke
;
stroke
.
a
*
=
aStrokeOpacity
;
RefPtr
<
gfxPattern
>
patern
=
new
gfxPattern
(
stroke
)
;
return
MakePair
(
DrawResult
:
:
SUCCESS
Move
(
patern
)
)
;
}
uint32_t
SVGEmbeddingContextPaint
:
:
Hash
(
)
const
{
uint32_t
hash
=
0
;
if
(
mFill
)
{
hash
=
HashGeneric
(
hash
mFill
-
>
ToABGR
(
)
)
;
}
else
{
hash
=
1
;
}
if
(
mStroke
)
{
hash
=
HashGeneric
(
hash
mStroke
-
>
ToABGR
(
)
)
;
}
return
hash
;
}
}
