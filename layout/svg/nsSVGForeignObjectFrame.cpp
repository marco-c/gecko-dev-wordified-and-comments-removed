#
include
"
nsSVGForeignObjectFrame
.
h
"
#
include
"
ImgDrawResult
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
dom
/
SVGForeignObjectElement
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nsSVGContainerFrame
.
h
"
#
include
"
SVGGeometryProperty
.
h
"
#
include
"
SVGObserverUtils
.
h
"
#
include
"
nsSVGIntegrationUtils
.
h
"
#
include
"
nsSVGOuterSVGFrame
.
h
"
#
include
"
nsSVGUtils
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
image
;
namespace
SVGT
=
SVGGeometryProperty
:
:
Tags
;
nsContainerFrame
*
NS_NewSVGForeignObjectFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsSVGForeignObjectFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsSVGForeignObjectFrame
)
nsSVGForeignObjectFrame
:
:
nsSVGForeignObjectFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
:
nsContainerFrame
(
aStyle
aPresContext
kClassID
)
mInReflow
(
false
)
{
AddStateBits
(
NS_FRAME_REFLOW_ROOT
|
NS_FRAME_MAY_BE_TRANSFORMED
|
NS_FRAME_SVG_LAYOUT
)
;
}
NS_QUERYFRAME_HEAD
(
nsSVGForeignObjectFrame
)
NS_QUERYFRAME_ENTRY
(
nsSVGDisplayableFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsContainerFrame
)
void
nsSVGForeignObjectFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
NS_ASSERTION
(
aContent
-
>
IsSVGElement
(
nsGkAtoms
:
:
foreignObject
)
"
Content
is
not
an
SVG
foreignObject
!
"
)
;
nsContainerFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
AddStateBits
(
aParent
-
>
GetStateBits
(
)
&
NS_STATE_SVG_CLIPPATH_CHILD
)
;
AddStateBits
(
NS_FRAME_FONT_INFLATION_CONTAINER
|
NS_FRAME_FONT_INFLATION_FLOW_ROOT
)
;
if
(
!
(
mState
&
NS_FRAME_IS_NONDISPLAY
)
)
{
nsSVGUtils
:
:
GetOuterSVGFrame
(
this
)
-
>
RegisterForeignObject
(
this
)
;
}
}
void
nsSVGForeignObjectFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
{
if
(
!
(
mState
&
NS_FRAME_IS_NONDISPLAY
)
)
{
nsSVGUtils
:
:
GetOuterSVGFrame
(
this
)
-
>
UnregisterForeignObject
(
this
)
;
}
nsContainerFrame
:
:
DestroyFrom
(
aDestructRoot
aPostDestroyData
)
;
}
nsresult
nsSVGForeignObjectFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
if
(
aNameSpaceID
=
=
kNameSpaceID_None
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
transform
)
{
mCanvasTM
=
nullptr
;
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
viewBox
|
|
aAttribute
=
=
nsGkAtoms
:
:
preserveAspectRatio
)
{
nsLayoutUtils
:
:
PostRestyleEvent
(
mContent
-
>
AsElement
(
)
RestyleHint
{
0
}
nsChangeHint_InvalidateRenderingObservers
)
;
}
}
return
NS_OK
;
}
void
nsSVGForeignObjectFrame
:
:
DidSetComputedStyle
(
ComputedStyle
*
aOldComputedStyle
)
{
nsContainerFrame
:
:
DidSetComputedStyle
(
aOldComputedStyle
)
;
if
(
aOldComputedStyle
)
{
if
(
StyleSVGReset
(
)
-
>
mX
!
=
aOldComputedStyle
-
>
StyleSVGReset
(
)
-
>
mX
|
|
StyleSVGReset
(
)
-
>
mY
!
=
aOldComputedStyle
-
>
StyleSVGReset
(
)
-
>
mY
)
{
mCanvasTM
=
nullptr
;
nsSVGUtils
:
:
ScheduleReflowSVG
(
this
)
;
}
}
}
void
nsSVGForeignObjectFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
MOZ_ASSERT
(
!
(
GetStateBits
(
)
&
NS_FRAME_IS_NONDISPLAY
)
"
Should
not
have
been
called
"
)
;
NS_ASSERTION
(
!
(
GetStateBits
(
)
&
NS_FRAME_IS_DIRTY
)
"
Reflowing
while
a
resize
is
pending
is
wasteful
"
)
;
NS_ASSERTION
(
!
aReflowInput
.
mParentReflowInput
"
should
only
get
reflow
from
being
reflow
root
"
)
;
NS_ASSERTION
(
aReflowInput
.
ComputedWidth
(
)
=
=
GetSize
(
)
.
width
&
&
aReflowInput
.
ComputedHeight
(
)
=
=
GetSize
(
)
.
height
"
reflow
roots
should
be
reflowed
at
existing
size
and
"
"
svg
.
css
should
ensure
we
have
no
padding
/
border
/
margin
"
)
;
DoReflow
(
)
;
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
LogicalSize
finalSize
(
wm
aReflowInput
.
ComputedISize
(
)
aReflowInput
.
ComputedBSize
(
)
)
;
aDesiredSize
.
SetSize
(
wm
finalSize
)
;
aDesiredSize
.
SetOverflowAreasToDesiredBounds
(
)
;
}
void
nsSVGForeignObjectFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
if
(
!
static_cast
<
const
SVGElement
*
>
(
GetContent
(
)
)
-
>
HasValidDimensions
(
)
)
{
return
;
}
nsDisplayList
newList
;
nsDisplayListSet
set
(
&
newList
&
newList
&
newList
&
newList
&
newList
&
newList
)
;
DisplayOutline
(
aBuilder
set
)
;
BuildDisplayListForNonBlockChildren
(
aBuilder
set
)
;
aLists
.
Content
(
)
-
>
AppendNewToTop
<
nsDisplayForeignObject
>
(
aBuilder
this
&
newList
)
;
}
bool
nsSVGForeignObjectFrame
:
:
IsSVGTransformed
(
Matrix
*
aOwnTransform
Matrix
*
aFromParentTransform
)
const
{
bool
foundTransform
=
false
;
nsIFrame
*
parent
=
GetParent
(
)
;
if
(
parent
&
&
parent
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
|
nsIFrame
:
:
eSVGContainer
)
)
{
foundTransform
=
static_cast
<
nsSVGContainerFrame
*
>
(
parent
)
-
>
HasChildrenOnlyTransform
(
aFromParentTransform
)
;
}
SVGElement
*
content
=
static_cast
<
SVGElement
*
>
(
GetContent
(
)
)
;
SVGAnimatedTransformList
*
transformList
=
content
-
>
GetAnimatedTransformList
(
)
;
if
(
(
transformList
&
&
transformList
-
>
HasTransform
(
)
)
|
|
content
-
>
GetAnimateMotionTransform
(
)
)
{
if
(
aOwnTransform
)
{
*
aOwnTransform
=
gfx
:
:
ToMatrix
(
content
-
>
PrependLocalTransformsTo
(
gfxMatrix
(
)
eUserSpaceToParent
)
)
;
}
foundTransform
=
true
;
}
return
foundTransform
;
}
void
nsSVGForeignObjectFrame
:
:
PaintSVG
(
gfxContext
&
aContext
const
gfxMatrix
&
aTransform
imgDrawingParams
&
aImgParams
const
nsIntRect
*
aDirtyRect
)
{
NS_ASSERTION
(
!
NS_SVGDisplayListPaintingEnabled
(
)
|
|
(
mState
&
NS_FRAME_IS_NONDISPLAY
)
"
If
display
lists
are
enabled
only
painting
of
non
-
display
"
"
SVG
should
take
this
code
path
"
)
;
if
(
IsDisabled
(
)
)
{
return
;
}
nsIFrame
*
kid
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
!
kid
)
{
return
;
}
if
(
aTransform
.
IsSingular
(
)
)
{
NS_WARNING
(
"
Can
'
t
render
foreignObject
element
!
"
)
;
return
;
}
nsRect
kidDirtyRect
=
kid
-
>
GetVisualOverflowRect
(
)
;
if
(
aDirtyRect
)
{
NS_ASSERTION
(
!
NS_SVGDisplayListPaintingEnabled
(
)
|
|
(
mState
&
NS_FRAME_IS_NONDISPLAY
)
"
Display
lists
handle
dirty
rect
intersection
test
"
)
;
gfxMatrix
invmatrix
=
aTransform
;
DebugOnly
<
bool
>
ok
=
invmatrix
.
Invert
(
)
;
NS_ASSERTION
(
ok
"
inverse
of
non
-
singular
matrix
should
be
non
-
singular
"
)
;
gfxRect
transDirtyRect
=
gfxRect
(
aDirtyRect
-
>
x
aDirtyRect
-
>
y
aDirtyRect
-
>
width
aDirtyRect
-
>
height
)
;
transDirtyRect
=
invmatrix
.
TransformBounds
(
transDirtyRect
)
;
kidDirtyRect
.
IntersectRect
(
kidDirtyRect
nsLayoutUtils
:
:
RoundGfxRectToAppRect
(
transDirtyRect
AppUnitsPerCSSPixel
(
)
)
)
;
if
(
kidDirtyRect
.
IsEmpty
(
)
)
{
return
;
}
}
aContext
.
Save
(
)
;
if
(
StyleDisplay
(
)
-
>
IsScrollableOverflow
(
)
)
{
float
x
y
width
height
;
SVGGeometryProperty
:
:
ResolveAll
<
SVGT
:
:
X
SVGT
:
:
Y
SVGT
:
:
Width
SVGT
:
:
Height
>
(
static_cast
<
SVGElement
*
>
(
GetContent
(
)
)
&
x
&
y
&
width
&
height
)
;
gfxRect
clipRect
=
nsSVGUtils
:
:
GetClipRectForFrame
(
this
0
.
0f
0
.
0f
width
height
)
;
nsSVGUtils
:
:
SetClipRect
(
&
aContext
aTransform
clipRect
)
;
}
float
cssPxPerDevPx
=
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
gfxMatrix
canvasTMForChildren
=
aTransform
;
canvasTMForChildren
.
PreScale
(
cssPxPerDevPx
cssPxPerDevPx
)
;
aContext
.
Multiply
(
canvasTMForChildren
)
;
using
PaintFrameFlags
=
nsLayoutUtils
:
:
PaintFrameFlags
;
PaintFrameFlags
flags
=
PaintFrameFlags
:
:
InTransform
;
if
(
SVGAutoRenderState
:
:
IsPaintingToWindow
(
aContext
.
GetDrawTarget
(
)
)
)
{
flags
|
=
PaintFrameFlags
:
:
ToWindow
;
}
if
(
aImgParams
.
imageFlags
&
imgIContainer
:
:
FLAG_SYNC_DECODE
)
{
flags
|
=
PaintFrameFlags
:
:
SyncDecodeImages
;
}
Unused
<
<
nsLayoutUtils
:
:
PaintFrame
(
&
aContext
kid
nsRegion
(
kidDirtyRect
)
NS_RGBA
(
0
0
0
0
)
nsDisplayListBuilderMode
:
:
Painting
flags
)
;
aContext
.
Restore
(
)
;
}
nsIFrame
*
nsSVGForeignObjectFrame
:
:
GetFrameForPoint
(
const
gfxPoint
&
aPoint
)
{
NS_ASSERTION
(
!
NS_SVGDisplayListHitTestingEnabled
(
)
|
|
(
mState
&
NS_FRAME_IS_NONDISPLAY
)
"
If
display
lists
are
enabled
only
hit
-
testing
of
a
"
"
clipPath
'
s
contents
should
take
this
code
path
"
)
;
if
(
IsDisabled
(
)
|
|
(
GetStateBits
(
)
&
NS_FRAME_IS_NONDISPLAY
)
)
{
return
nullptr
;
}
nsIFrame
*
kid
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
!
kid
)
{
return
nullptr
;
}
float
x
y
width
height
;
SVGGeometryProperty
:
:
ResolveAll
<
SVGT
:
:
X
SVGT
:
:
Y
SVGT
:
:
Width
SVGT
:
:
Height
>
(
static_cast
<
SVGElement
*
>
(
GetContent
(
)
)
&
x
&
y
&
width
&
height
)
;
if
(
!
gfxRect
(
x
y
width
height
)
.
Contains
(
aPoint
)
|
|
!
nsSVGUtils
:
:
HitTestClip
(
this
aPoint
)
)
{
return
nullptr
;
}
gfxPoint
pt
=
(
aPoint
+
gfxPoint
(
x
y
)
)
*
AppUnitsPerCSSPixel
(
)
;
nsPoint
point
=
nsPoint
(
NSToIntRound
(
pt
.
x
)
NSToIntRound
(
pt
.
y
)
)
;
return
nsLayoutUtils
:
:
GetFrameForPoint
(
kid
point
)
;
}
void
nsSVGForeignObjectFrame
:
:
ReflowSVG
(
)
{
NS_ASSERTION
(
nsSVGUtils
:
:
OuterSVGIsCallingReflowSVG
(
this
)
"
This
call
is
probably
a
wasteful
mistake
"
)
;
MOZ_ASSERT
(
!
(
GetStateBits
(
)
&
NS_FRAME_IS_NONDISPLAY
)
"
ReflowSVG
mechanism
not
designed
for
this
"
)
;
if
(
!
nsSVGUtils
:
:
NeedsReflowSVG
(
this
)
)
{
return
;
}
float
x
y
w
h
;
SVGGeometryProperty
:
:
ResolveAll
<
SVGT
:
:
X
SVGT
:
:
Y
SVGT
:
:
Width
SVGT
:
:
Height
>
(
static_cast
<
SVGElement
*
>
(
GetContent
(
)
)
&
x
&
y
&
w
&
h
)
;
if
(
w
<
0
.
0f
)
w
=
0
.
0f
;
if
(
h
<
0
.
0f
)
h
=
0
.
0f
;
mRect
=
nsLayoutUtils
:
:
RoundGfxRectToAppRect
(
gfxRect
(
x
y
w
h
)
AppUnitsPerCSSPixel
(
)
)
;
nsIFrame
*
kid
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
kid
-
>
MarkSubtreeDirty
(
)
;
nsPresContext
:
:
InterruptPreventer
noInterrupts
(
PresContext
(
)
)
;
DoReflow
(
)
;
if
(
mState
&
NS_FRAME_FIRST_REFLOW
)
{
SVGObserverUtils
:
:
UpdateEffects
(
this
)
;
}
if
(
StyleEffects
(
)
-
>
HasFilters
(
)
)
{
InvalidateFrame
(
)
;
}
auto
*
anonKid
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
nsRect
overflow
=
anonKid
-
>
GetVisualOverflowRect
(
)
;
nsOverflowAreas
overflowAreas
(
overflow
overflow
)
;
FinishAndStoreOverflow
(
overflowAreas
mRect
.
Size
(
)
)
;
RemoveStateBits
(
NS_FRAME_FIRST_REFLOW
|
NS_FRAME_IS_DIRTY
|
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
}
void
nsSVGForeignObjectFrame
:
:
NotifySVGChanged
(
uint32_t
aFlags
)
{
MOZ_ASSERT
(
aFlags
&
(
TRANSFORM_CHANGED
|
COORD_CONTEXT_CHANGED
)
"
Invalidation
logic
may
need
adjusting
"
)
;
bool
needNewBounds
=
false
;
bool
needReflow
=
false
;
bool
needNewCanvasTM
=
false
;
if
(
aFlags
&
COORD_CONTEXT_CHANGED
)
{
if
(
StyleSVGReset
(
)
-
>
mX
.
HasPercent
(
)
|
|
StyleSVGReset
(
)
-
>
mY
.
HasPercent
(
)
)
{
needNewBounds
=
true
;
needNewCanvasTM
=
true
;
}
if
(
StylePosition
(
)
-
>
mWidth
.
HasPercent
(
)
|
|
StylePosition
(
)
-
>
mHeight
.
HasPercent
(
)
)
{
needNewBounds
=
true
;
needReflow
=
true
;
}
}
if
(
aFlags
&
TRANSFORM_CHANGED
)
{
if
(
mCanvasTM
&
&
mCanvasTM
-
>
IsSingular
(
)
)
{
needNewBounds
=
true
;
}
needNewCanvasTM
=
true
;
}
if
(
needNewBounds
)
{
nsSVGUtils
:
:
ScheduleReflowSVG
(
this
)
;
}
if
(
needReflow
&
&
!
PresShell
(
)
-
>
IsReflowLocked
(
)
)
{
RequestReflow
(
IntrinsicDirty
:
:
Resize
)
;
}
if
(
needNewCanvasTM
)
{
mCanvasTM
=
nullptr
;
}
}
SVGBBox
nsSVGForeignObjectFrame
:
:
GetBBoxContribution
(
const
Matrix
&
aToBBoxUserspace
uint32_t
aFlags
)
{
SVGForeignObjectElement
*
content
=
static_cast
<
SVGForeignObjectElement
*
>
(
GetContent
(
)
)
;
float
x
y
w
h
;
SVGGeometryProperty
:
:
ResolveAll
<
SVGT
:
:
X
SVGT
:
:
Y
SVGT
:
:
Width
SVGT
:
:
Height
>
(
content
&
x
&
y
&
w
&
h
)
;
if
(
w
<
0
.
0f
)
w
=
0
.
0f
;
if
(
h
<
0
.
0f
)
h
=
0
.
0f
;
if
(
aToBBoxUserspace
.
IsSingular
(
)
)
{
return
SVGBBox
(
)
;
}
return
aToBBoxUserspace
.
TransformBounds
(
gfx
:
:
Rect
(
0
.
0
0
.
0
w
h
)
)
;
}
gfxMatrix
nsSVGForeignObjectFrame
:
:
GetCanvasTM
(
)
{
if
(
!
mCanvasTM
)
{
NS_ASSERTION
(
GetParent
(
)
"
null
parent
"
)
;
nsSVGContainerFrame
*
parent
=
static_cast
<
nsSVGContainerFrame
*
>
(
GetParent
(
)
)
;
SVGForeignObjectElement
*
content
=
static_cast
<
SVGForeignObjectElement
*
>
(
GetContent
(
)
)
;
gfxMatrix
tm
=
content
-
>
PrependLocalTransformsTo
(
parent
-
>
GetCanvasTM
(
)
)
;
mCanvasTM
=
new
gfxMatrix
(
tm
)
;
}
return
*
mCanvasTM
;
}
void
nsSVGForeignObjectFrame
:
:
RequestReflow
(
IntrinsicDirty
aType
)
{
if
(
GetStateBits
(
)
&
NS_FRAME_FIRST_REFLOW
)
return
;
nsIFrame
*
kid
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
!
kid
)
{
return
;
}
PresShell
(
)
-
>
FrameNeedsReflow
(
kid
aType
NS_FRAME_IS_DIRTY
)
;
}
void
nsSVGForeignObjectFrame
:
:
DoReflow
(
)
{
MarkInReflow
(
)
;
if
(
IsDisabled
(
)
&
&
!
(
GetStateBits
(
)
&
NS_FRAME_FIRST_REFLOW
)
)
{
return
;
}
nsPresContext
*
presContext
=
PresContext
(
)
;
nsIFrame
*
kid
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
!
kid
)
{
return
;
}
RefPtr
<
gfxContext
>
renderingContext
=
presContext
-
>
PresShell
(
)
-
>
CreateReferenceRenderingContext
(
)
;
mInReflow
=
true
;
WritingMode
wm
=
kid
-
>
GetWritingMode
(
)
;
ReflowInput
reflowInput
(
presContext
kid
renderingContext
LogicalSize
(
wm
ISize
(
wm
)
NS_UNCONSTRAINEDSIZE
)
)
;
ReflowOutput
desiredSize
(
reflowInput
)
;
nsReflowStatus
status
;
NS_ASSERTION
(
reflowInput
.
ComputedPhysicalBorderPadding
(
)
=
=
nsMargin
(
0
0
0
0
)
&
&
reflowInput
.
ComputedPhysicalMargin
(
)
=
=
nsMargin
(
0
0
0
0
)
"
style
system
should
ensure
that
:
-
moz
-
svg
-
foreign
-
content
"
"
does
not
get
styled
"
)
;
NS_ASSERTION
(
reflowInput
.
ComputedISize
(
)
=
=
ISize
(
wm
)
"
reflow
input
made
child
wrong
size
"
)
;
reflowInput
.
SetComputedBSize
(
BSize
(
wm
)
)
;
ReflowChild
(
kid
presContext
desiredSize
reflowInput
0
0
ReflowChildFlags
:
:
NoMoveFrame
status
)
;
NS_ASSERTION
(
mRect
.
width
=
=
desiredSize
.
Width
(
)
&
&
mRect
.
height
=
=
desiredSize
.
Height
(
)
"
unexpected
size
"
)
;
FinishReflowChild
(
kid
presContext
desiredSize
&
reflowInput
0
0
ReflowChildFlags
:
:
NoMoveFrame
)
;
mInReflow
=
false
;
}
nsRect
nsSVGForeignObjectFrame
:
:
GetInvalidRegion
(
)
{
MOZ_ASSERT
(
!
NS_SVGDisplayListPaintingEnabled
(
)
"
Only
called
by
nsDisplayOuterSVG
code
"
)
;
nsIFrame
*
kid
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
kid
-
>
HasInvalidFrameInSubtree
(
)
)
{
gfxRect
r
(
mRect
.
x
mRect
.
y
mRect
.
width
mRect
.
height
)
;
r
.
Scale
(
1
.
0
/
AppUnitsPerCSSPixel
(
)
)
;
nsRect
rect
=
nsSVGUtils
:
:
ToCanvasBounds
(
r
GetCanvasTM
(
)
PresContext
(
)
)
;
rect
=
nsSVGUtils
:
:
GetPostFilterVisualOverflowRect
(
this
rect
)
;
return
rect
;
}
return
nsRect
(
)
;
}
void
nsSVGForeignObjectFrame
:
:
AppendDirectlyOwnedAnonBoxes
(
nsTArray
<
OwnedAnonBox
>
&
aResult
)
{
MOZ_ASSERT
(
PrincipalChildList
(
)
.
FirstChild
(
)
"
Must
have
our
anon
box
"
)
;
aResult
.
AppendElement
(
OwnedAnonBox
(
PrincipalChildList
(
)
.
FirstChild
(
)
)
)
;
}
