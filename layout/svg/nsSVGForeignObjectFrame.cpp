#
include
"
nsSVGForeignObjectFrame
.
h
"
#
include
"
DrawResult
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
nsSVGContainerFrame
.
h
"
#
include
"
nsSVGEffects
.
h
"
#
include
"
mozilla
/
dom
/
SVGForeignObjectElement
.
h
"
#
include
"
nsSVGIntegrationUtils
.
h
"
#
include
"
nsSVGOuterSVGFrame
.
h
"
#
include
"
nsSVGUtils
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
image
;
nsContainerFrame
*
NS_NewSVGForeignObjectFrame
(
nsIPresShell
*
aPresShell
nsStyleContext
*
aContext
)
{
return
new
(
aPresShell
)
nsSVGForeignObjectFrame
(
aContext
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsSVGForeignObjectFrame
)
nsSVGForeignObjectFrame
:
:
nsSVGForeignObjectFrame
(
nsStyleContext
*
aContext
)
:
nsContainerFrame
(
aContext
kClassID
)
mInReflow
(
false
)
{
AddStateBits
(
NS_FRAME_REFLOW_ROOT
|
NS_FRAME_MAY_BE_TRANSFORMED
|
NS_FRAME_SVG_LAYOUT
)
;
}
NS_QUERYFRAME_HEAD
(
nsSVGForeignObjectFrame
)
NS_QUERYFRAME_ENTRY
(
nsSVGDisplayableFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsContainerFrame
)
void
nsSVGForeignObjectFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
NS_ASSERTION
(
aContent
-
>
IsSVGElement
(
nsGkAtoms
:
:
foreignObject
)
"
Content
is
not
an
SVG
foreignObject
!
"
)
;
nsContainerFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
AddStateBits
(
aParent
-
>
GetStateBits
(
)
&
NS_STATE_SVG_CLIPPATH_CHILD
)
;
AddStateBits
(
NS_FRAME_FONT_INFLATION_CONTAINER
|
NS_FRAME_FONT_INFLATION_FLOW_ROOT
)
;
if
(
!
(
mState
&
NS_FRAME_IS_NONDISPLAY
)
)
{
nsSVGUtils
:
:
GetOuterSVGFrame
(
this
)
-
>
RegisterForeignObject
(
this
)
;
}
}
void
nsSVGForeignObjectFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestructRoot
)
{
if
(
!
(
mState
&
NS_FRAME_IS_NONDISPLAY
)
)
{
nsSVGUtils
:
:
GetOuterSVGFrame
(
this
)
-
>
UnregisterForeignObject
(
this
)
;
}
nsContainerFrame
:
:
DestroyFrom
(
aDestructRoot
)
;
}
nsresult
nsSVGForeignObjectFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsIAtom
*
aAttribute
int32_t
aModType
)
{
if
(
aNameSpaceID
=
=
kNameSpaceID_None
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
width
|
|
aAttribute
=
=
nsGkAtoms
:
:
height
)
{
nsLayoutUtils
:
:
PostRestyleEvent
(
mContent
-
>
AsElement
(
)
nsRestyleHint
(
0
)
nsChangeHint_InvalidateRenderingObservers
)
;
nsSVGUtils
:
:
ScheduleReflowSVG
(
this
)
;
RequestReflow
(
nsIPresShell
:
:
eStyleChange
)
;
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
x
|
|
aAttribute
=
=
nsGkAtoms
:
:
y
)
{
mCanvasTM
=
nullptr
;
nsLayoutUtils
:
:
PostRestyleEvent
(
mContent
-
>
AsElement
(
)
nsRestyleHint
(
0
)
nsChangeHint_InvalidateRenderingObservers
)
;
nsSVGUtils
:
:
ScheduleReflowSVG
(
this
)
;
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
transform
)
{
mCanvasTM
=
nullptr
;
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
viewBox
|
|
aAttribute
=
=
nsGkAtoms
:
:
preserveAspectRatio
)
{
nsLayoutUtils
:
:
PostRestyleEvent
(
mContent
-
>
AsElement
(
)
nsRestyleHint
(
0
)
nsChangeHint_InvalidateRenderingObservers
)
;
}
}
return
NS_OK
;
}
void
nsSVGForeignObjectFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MOZ_ASSERT
(
!
(
GetStateBits
(
)
&
NS_FRAME_IS_NONDISPLAY
)
"
Should
not
have
been
called
"
)
;
NS_ASSERTION
(
!
(
GetStateBits
(
)
&
NS_FRAME_IS_DIRTY
)
"
Reflowing
while
a
resize
is
pending
is
wasteful
"
)
;
NS_ASSERTION
(
!
aReflowInput
.
mParentReflowInput
"
should
only
get
reflow
from
being
reflow
root
"
)
;
NS_ASSERTION
(
aReflowInput
.
ComputedWidth
(
)
=
=
GetSize
(
)
.
width
&
&
aReflowInput
.
ComputedHeight
(
)
=
=
GetSize
(
)
.
height
"
reflow
roots
should
be
reflowed
at
existing
size
and
"
"
svg
.
css
should
ensure
we
have
no
padding
/
border
/
margin
"
)
;
DoReflow
(
)
;
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
LogicalSize
finalSize
(
wm
aReflowInput
.
ComputedISize
(
)
aReflowInput
.
ComputedBSize
(
)
)
;
aDesiredSize
.
SetSize
(
wm
finalSize
)
;
aDesiredSize
.
SetOverflowAreasToDesiredBounds
(
)
;
aStatus
.
Reset
(
)
;
}
void
nsSVGForeignObjectFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aDirtyRect
const
nsDisplayListSet
&
aLists
)
{
if
(
!
static_cast
<
const
nsSVGElement
*
>
(
mContent
)
-
>
HasValidDimensions
(
)
)
{
return
;
}
DisplayOutline
(
aBuilder
aLists
)
;
BuildDisplayListForNonBlockChildren
(
aBuilder
aDirtyRect
aLists
)
;
}
bool
nsSVGForeignObjectFrame
:
:
IsSVGTransformed
(
Matrix
*
aOwnTransform
Matrix
*
aFromParentTransform
)
const
{
bool
foundTransform
=
false
;
nsIFrame
*
parent
=
GetParent
(
)
;
if
(
parent
&
&
parent
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
|
nsIFrame
:
:
eSVGContainer
)
)
{
foundTransform
=
static_cast
<
nsSVGContainerFrame
*
>
(
parent
)
-
>
HasChildrenOnlyTransform
(
aFromParentTransform
)
;
}
nsSVGElement
*
content
=
static_cast
<
nsSVGElement
*
>
(
mContent
)
;
nsSVGAnimatedTransformList
*
transformList
=
content
-
>
GetAnimatedTransformList
(
)
;
if
(
(
transformList
&
&
transformList
-
>
HasTransform
(
)
)
|
|
content
-
>
GetAnimateMotionTransform
(
)
)
{
if
(
aOwnTransform
)
{
*
aOwnTransform
=
gfx
:
:
ToMatrix
(
content
-
>
PrependLocalTransformsTo
(
gfxMatrix
(
)
eUserSpaceToParent
)
)
;
}
foundTransform
=
true
;
}
return
foundTransform
;
}
void
nsSVGForeignObjectFrame
:
:
PaintSVG
(
gfxContext
&
aContext
const
gfxMatrix
&
aTransform
imgDrawingParams
&
aImgParams
const
nsIntRect
*
aDirtyRect
)
{
NS_ASSERTION
(
!
NS_SVGDisplayListPaintingEnabled
(
)
|
|
(
mState
&
NS_FRAME_IS_NONDISPLAY
)
"
If
display
lists
are
enabled
only
painting
of
non
-
display
"
"
SVG
should
take
this
code
path
"
)
;
if
(
IsDisabled
(
)
)
{
return
;
}
nsIFrame
*
kid
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
!
kid
)
{
return
;
}
if
(
aTransform
.
IsSingular
(
)
)
{
NS_WARNING
(
"
Can
'
t
render
foreignObject
element
!
"
)
;
return
;
}
nsRect
kidDirtyRect
=
kid
-
>
GetVisualOverflowRect
(
)
;
if
(
aDirtyRect
)
{
NS_ASSERTION
(
!
NS_SVGDisplayListPaintingEnabled
(
)
|
|
(
mState
&
NS_FRAME_IS_NONDISPLAY
)
"
Display
lists
handle
dirty
rect
intersection
test
"
)
;
gfxMatrix
invmatrix
=
aTransform
;
DebugOnly
<
bool
>
ok
=
invmatrix
.
Invert
(
)
;
NS_ASSERTION
(
ok
"
inverse
of
non
-
singular
matrix
should
be
non
-
singular
"
)
;
gfxRect
transDirtyRect
=
gfxRect
(
aDirtyRect
-
>
x
aDirtyRect
-
>
y
aDirtyRect
-
>
width
aDirtyRect
-
>
height
)
;
transDirtyRect
.
TransformBoundsBy
(
invmatrix
)
;
kidDirtyRect
.
IntersectRect
(
kidDirtyRect
nsLayoutUtils
:
:
RoundGfxRectToAppRect
(
transDirtyRect
PresContext
(
)
-
>
AppUnitsPerCSSPixel
(
)
)
)
;
if
(
kidDirtyRect
.
IsEmpty
(
)
)
return
;
}
aContext
.
Save
(
)
;
if
(
StyleDisplay
(
)
-
>
IsScrollableOverflow
(
)
)
{
float
x
y
width
height
;
static_cast
<
nsSVGElement
*
>
(
mContent
)
-
>
GetAnimatedLengthValues
(
&
x
&
y
&
width
&
height
nullptr
)
;
gfxRect
clipRect
=
nsSVGUtils
:
:
GetClipRectForFrame
(
this
0
.
0f
0
.
0f
width
height
)
;
nsSVGUtils
:
:
SetClipRect
(
&
aContext
aTransform
clipRect
)
;
}
float
cssPxPerDevPx
=
PresContext
(
)
-
>
AppUnitsToFloatCSSPixels
(
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
gfxMatrix
canvasTMForChildren
=
aTransform
;
canvasTMForChildren
.
PreScale
(
cssPxPerDevPx
cssPxPerDevPx
)
;
aContext
.
Multiply
(
canvasTMForChildren
)
;
using
PaintFrameFlags
=
nsLayoutUtils
:
:
PaintFrameFlags
;
PaintFrameFlags
flags
=
PaintFrameFlags
:
:
PAINT_IN_TRANSFORM
;
if
(
SVGAutoRenderState
:
:
IsPaintingToWindow
(
aContext
.
GetDrawTarget
(
)
)
)
{
flags
|
=
PaintFrameFlags
:
:
PAINT_TO_WINDOW
;
}
if
(
aImgParams
.
imageFlags
&
imgIContainer
:
:
FLAG_SYNC_DECODE
)
{
flags
|
=
PaintFrameFlags
:
:
PAINT_SYNC_DECODE_IMAGES
;
}
Unused
<
<
nsLayoutUtils
:
:
PaintFrame
(
&
aContext
kid
nsRegion
(
kidDirtyRect
)
NS_RGBA
(
0
0
0
0
)
nsDisplayListBuilderMode
:
:
PAINTING
flags
)
;
aContext
.
Restore
(
)
;
}
nsIFrame
*
nsSVGForeignObjectFrame
:
:
GetFrameForPoint
(
const
gfxPoint
&
aPoint
)
{
NS_ASSERTION
(
!
NS_SVGDisplayListHitTestingEnabled
(
)
|
|
(
mState
&
NS_FRAME_IS_NONDISPLAY
)
"
If
display
lists
are
enabled
only
hit
-
testing
of
a
"
"
clipPath
'
s
contents
should
take
this
code
path
"
)
;
if
(
IsDisabled
(
)
|
|
(
GetStateBits
(
)
&
NS_FRAME_IS_NONDISPLAY
)
)
return
nullptr
;
nsIFrame
*
kid
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
!
kid
)
return
nullptr
;
float
x
y
width
height
;
static_cast
<
nsSVGElement
*
>
(
mContent
)
-
>
GetAnimatedLengthValues
(
&
x
&
y
&
width
&
height
nullptr
)
;
if
(
!
gfxRect
(
x
y
width
height
)
.
Contains
(
aPoint
)
|
|
!
nsSVGUtils
:
:
HitTestClip
(
this
aPoint
)
)
{
return
nullptr
;
}
gfxPoint
pt
=
(
aPoint
+
gfxPoint
(
x
y
)
)
*
nsPresContext
:
:
AppUnitsPerCSSPixel
(
)
;
nsPoint
point
=
nsPoint
(
NSToIntRound
(
pt
.
x
)
NSToIntRound
(
pt
.
y
)
)
;
return
nsLayoutUtils
:
:
GetFrameForPoint
(
kid
point
)
;
}
void
nsSVGForeignObjectFrame
:
:
ReflowSVG
(
)
{
NS_ASSERTION
(
nsSVGUtils
:
:
OuterSVGIsCallingReflowSVG
(
this
)
"
This
call
is
probably
a
wasteful
mistake
"
)
;
MOZ_ASSERT
(
!
(
GetStateBits
(
)
&
NS_FRAME_IS_NONDISPLAY
)
"
ReflowSVG
mechanism
not
designed
for
this
"
)
;
if
(
!
nsSVGUtils
:
:
NeedsReflowSVG
(
this
)
)
{
return
;
}
float
x
y
w
h
;
static_cast
<
SVGForeignObjectElement
*
>
(
mContent
)
-
>
GetAnimatedLengthValues
(
&
x
&
y
&
w
&
h
nullptr
)
;
if
(
w
<
0
.
0f
)
w
=
0
.
0f
;
if
(
h
<
0
.
0f
)
h
=
0
.
0f
;
mRect
=
nsLayoutUtils
:
:
RoundGfxRectToAppRect
(
gfxRect
(
x
y
w
h
)
PresContext
(
)
-
>
AppUnitsPerCSSPixel
(
)
)
;
nsIFrame
*
kid
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
kid
-
>
AddStateBits
(
NS_FRAME_IS_DIRTY
)
;
nsPresContext
:
:
InterruptPreventer
noInterrupts
(
PresContext
(
)
)
;
DoReflow
(
)
;
if
(
mState
&
NS_FRAME_FIRST_REFLOW
)
{
nsSVGEffects
:
:
UpdateEffects
(
this
)
;
}
if
(
StyleEffects
(
)
-
>
HasFilters
(
)
)
{
InvalidateFrame
(
)
;
}
nsRect
overflow
=
nsRect
(
nsPoint
(
0
0
)
mRect
.
Size
(
)
)
;
nsOverflowAreas
overflowAreas
(
overflow
overflow
)
;
FinishAndStoreOverflow
(
overflowAreas
mRect
.
Size
(
)
)
;
mState
&
=
~
(
NS_FRAME_FIRST_REFLOW
|
NS_FRAME_IS_DIRTY
|
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
}
void
nsSVGForeignObjectFrame
:
:
NotifySVGChanged
(
uint32_t
aFlags
)
{
MOZ_ASSERT
(
aFlags
&
(
TRANSFORM_CHANGED
|
COORD_CONTEXT_CHANGED
)
"
Invalidation
logic
may
need
adjusting
"
)
;
bool
needNewBounds
=
false
;
bool
needReflow
=
false
;
bool
needNewCanvasTM
=
false
;
if
(
aFlags
&
COORD_CONTEXT_CHANGED
)
{
SVGForeignObjectElement
*
fO
=
static_cast
<
SVGForeignObjectElement
*
>
(
mContent
)
;
if
(
fO
-
>
mLengthAttributes
[
SVGForeignObjectElement
:
:
ATTR_X
]
.
IsPercentage
(
)
|
|
fO
-
>
mLengthAttributes
[
SVGForeignObjectElement
:
:
ATTR_Y
]
.
IsPercentage
(
)
)
{
needNewBounds
=
true
;
needNewCanvasTM
=
true
;
}
if
(
fO
-
>
mLengthAttributes
[
SVGForeignObjectElement
:
:
ATTR_WIDTH
]
.
IsPercentage
(
)
|
|
fO
-
>
mLengthAttributes
[
SVGForeignObjectElement
:
:
ATTR_HEIGHT
]
.
IsPercentage
(
)
)
{
needNewBounds
=
true
;
needReflow
=
true
;
}
}
if
(
aFlags
&
TRANSFORM_CHANGED
)
{
if
(
mCanvasTM
&
&
mCanvasTM
-
>
IsSingular
(
)
)
{
needNewBounds
=
true
;
}
needNewCanvasTM
=
true
;
}
if
(
needNewBounds
)
{
nsSVGUtils
:
:
ScheduleReflowSVG
(
this
)
;
}
if
(
needReflow
&
&
!
PresContext
(
)
-
>
PresShell
(
)
-
>
IsReflowLocked
(
)
)
{
RequestReflow
(
nsIPresShell
:
:
eResize
)
;
}
if
(
needNewCanvasTM
)
{
mCanvasTM
=
nullptr
;
}
}
SVGBBox
nsSVGForeignObjectFrame
:
:
GetBBoxContribution
(
const
Matrix
&
aToBBoxUserspace
uint32_t
aFlags
)
{
SVGForeignObjectElement
*
content
=
static_cast
<
SVGForeignObjectElement
*
>
(
mContent
)
;
float
x
y
w
h
;
content
-
>
GetAnimatedLengthValues
(
&
x
&
y
&
w
&
h
nullptr
)
;
if
(
w
<
0
.
0f
)
w
=
0
.
0f
;
if
(
h
<
0
.
0f
)
h
=
0
.
0f
;
if
(
aToBBoxUserspace
.
IsSingular
(
)
)
{
return
SVGBBox
(
)
;
}
return
aToBBoxUserspace
.
TransformBounds
(
gfx
:
:
Rect
(
0
.
0
0
.
0
w
h
)
)
;
}
gfxMatrix
nsSVGForeignObjectFrame
:
:
GetCanvasTM
(
)
{
if
(
!
mCanvasTM
)
{
NS_ASSERTION
(
GetParent
(
)
"
null
parent
"
)
;
nsSVGContainerFrame
*
parent
=
static_cast
<
nsSVGContainerFrame
*
>
(
GetParent
(
)
)
;
SVGForeignObjectElement
*
content
=
static_cast
<
SVGForeignObjectElement
*
>
(
mContent
)
;
gfxMatrix
tm
=
content
-
>
PrependLocalTransformsTo
(
parent
-
>
GetCanvasTM
(
)
)
;
mCanvasTM
=
new
gfxMatrix
(
tm
)
;
}
return
*
mCanvasTM
;
}
void
nsSVGForeignObjectFrame
:
:
RequestReflow
(
nsIPresShell
:
:
IntrinsicDirty
aType
)
{
if
(
GetStateBits
(
)
&
NS_FRAME_FIRST_REFLOW
)
return
;
nsIFrame
*
kid
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
!
kid
)
return
;
PresContext
(
)
-
>
PresShell
(
)
-
>
FrameNeedsReflow
(
kid
aType
NS_FRAME_IS_DIRTY
)
;
}
void
nsSVGForeignObjectFrame
:
:
DoReflow
(
)
{
MarkInReflow
(
)
;
if
(
IsDisabled
(
)
&
&
!
(
GetStateBits
(
)
&
NS_FRAME_FIRST_REFLOW
)
)
return
;
nsPresContext
*
presContext
=
PresContext
(
)
;
nsIFrame
*
kid
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
!
kid
)
return
;
RefPtr
<
gfxContext
>
renderingContext
=
presContext
-
>
PresShell
(
)
-
>
CreateReferenceRenderingContext
(
)
;
mInReflow
=
true
;
WritingMode
wm
=
kid
-
>
GetWritingMode
(
)
;
ReflowInput
reflowInput
(
presContext
kid
renderingContext
LogicalSize
(
wm
ISize
(
wm
)
NS_UNCONSTRAINEDSIZE
)
)
;
ReflowOutput
desiredSize
(
reflowInput
)
;
nsReflowStatus
status
;
NS_ASSERTION
(
reflowInput
.
ComputedPhysicalBorderPadding
(
)
=
=
nsMargin
(
0
0
0
0
)
&
&
reflowInput
.
ComputedPhysicalMargin
(
)
=
=
nsMargin
(
0
0
0
0
)
"
style
system
should
ensure
that
:
-
moz
-
svg
-
foreign
-
content
"
"
does
not
get
styled
"
)
;
NS_ASSERTION
(
reflowInput
.
ComputedISize
(
)
=
=
ISize
(
wm
)
"
reflow
state
made
child
wrong
size
"
)
;
reflowInput
.
SetComputedBSize
(
BSize
(
wm
)
)
;
ReflowChild
(
kid
presContext
desiredSize
reflowInput
0
0
NS_FRAME_NO_MOVE_FRAME
status
)
;
NS_ASSERTION
(
mRect
.
width
=
=
desiredSize
.
Width
(
)
&
&
mRect
.
height
=
=
desiredSize
.
Height
(
)
"
unexpected
size
"
)
;
FinishReflowChild
(
kid
presContext
desiredSize
&
reflowInput
0
0
NS_FRAME_NO_MOVE_FRAME
)
;
mInReflow
=
false
;
}
nsRect
nsSVGForeignObjectFrame
:
:
GetInvalidRegion
(
)
{
MOZ_ASSERT
(
!
NS_SVGDisplayListPaintingEnabled
(
)
"
Only
called
by
nsDisplayOuterSVG
code
"
)
;
nsIFrame
*
kid
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
kid
-
>
HasInvalidFrameInSubtree
(
)
)
{
gfxRect
r
(
mRect
.
x
mRect
.
y
mRect
.
width
mRect
.
height
)
;
r
.
Scale
(
1
.
0
/
nsPresContext
:
:
AppUnitsPerCSSPixel
(
)
)
;
nsRect
rect
=
nsSVGUtils
:
:
ToCanvasBounds
(
r
GetCanvasTM
(
)
PresContext
(
)
)
;
rect
=
nsSVGUtils
:
:
GetPostFilterVisualOverflowRect
(
this
rect
)
;
return
rect
;
}
return
nsRect
(
)
;
}
void
nsSVGForeignObjectFrame
:
:
AppendDirectlyOwnedAnonBoxes
(
nsTArray
<
OwnedAnonBox
>
&
aResult
)
{
MOZ_ASSERT
(
PrincipalChildList
(
)
.
FirstChild
(
)
"
Must
have
our
anon
box
"
)
;
aResult
.
AppendElement
(
OwnedAnonBox
(
PrincipalChildList
(
)
.
FirstChild
(
)
)
)
;
}
