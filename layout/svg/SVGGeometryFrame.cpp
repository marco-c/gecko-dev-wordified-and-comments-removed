#
include
"
SVGGeometryFrame
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
Helpers
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
SVGContextPaint
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
SVGObserverUtils
.
h
"
#
include
"
nsSVGIntegrationUtils
.
h
"
#
include
"
nsSVGMarkerFrame
.
h
"
#
include
"
SVGGeometryElement
.
h
"
#
include
"
nsSVGUtils
.
h
"
#
include
"
mozilla
/
ArrayUtils
.
h
"
#
include
"
SVGAnimatedTransformList
.
h
"
#
include
"
SVGContentUtils
.
h
"
#
include
"
SVGGraphicsElement
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
image
;
nsIFrame
*
NS_NewSVGGeometryFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
SVGGeometryFrame
(
aStyle
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
SVGGeometryFrame
)
NS_QUERYFRAME_HEAD
(
SVGGeometryFrame
)
NS_QUERYFRAME_ENTRY
(
nsSVGDisplayableFrame
)
NS_QUERYFRAME_ENTRY
(
SVGGeometryFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsFrame
)
class
nsDisplaySVGGeometry
final
:
public
nsDisplayItem
{
typedef
mozilla
:
:
image
:
:
imgDrawingParams
imgDrawingParams
;
public
:
nsDisplaySVGGeometry
(
nsDisplayListBuilder
*
aBuilder
SVGGeometryFrame
*
aFrame
)
:
nsDisplayItem
(
aBuilder
aFrame
)
{
MOZ_COUNT_CTOR
(
nsDisplaySVGGeometry
)
;
MOZ_ASSERT
(
aFrame
"
Must
have
a
frame
!
"
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplaySVGGeometry
(
)
{
MOZ_COUNT_DTOR
(
nsDisplaySVGGeometry
)
;
}
#
endif
NS_DISPLAY_DECL_NAME
(
"
nsDisplaySVGGeometry
"
TYPE_SVG_GEOMETRY
)
virtual
void
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
override
;
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
;
nsDisplayItemGeometry
*
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
new
nsDisplayItemGenericImageGeometry
(
this
aBuilder
)
;
}
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
;
}
;
void
nsDisplaySVGGeometry
:
:
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
{
SVGGeometryFrame
*
frame
=
static_cast
<
SVGGeometryFrame
*
>
(
mFrame
)
;
nsPoint
pointRelativeToReferenceFrame
=
aRect
.
Center
(
)
;
nsPoint
userSpacePtInAppUnits
=
pointRelativeToReferenceFrame
-
(
ToReferenceFrame
(
)
-
frame
-
>
GetPosition
(
)
)
;
gfxPoint
userSpacePt
=
gfxPoint
(
userSpacePtInAppUnits
.
x
userSpacePtInAppUnits
.
y
)
/
AppUnitsPerCSSPixel
(
)
;
if
(
frame
-
>
GetFrameForPoint
(
userSpacePt
)
)
{
aOutFrames
-
>
AppendElement
(
frame
)
;
}
}
void
nsDisplaySVGGeometry
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
uint32_t
appUnitsPerDevPixel
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
nsPoint
offset
=
ToReferenceFrame
(
)
-
mFrame
-
>
GetPosition
(
)
;
gfxPoint
devPixelOffset
=
nsLayoutUtils
:
:
PointToGfxPoint
(
offset
appUnitsPerDevPixel
)
;
gfxMatrix
tm
=
nsSVGUtils
:
:
GetCSSPxToDevPxMatrix
(
mFrame
)
*
gfxMatrix
:
:
Translation
(
devPixelOffset
)
;
imgDrawingParams
imgParams
(
aBuilder
-
>
ShouldSyncDecodeImages
(
)
?
imgIContainer
:
:
FLAG_SYNC_DECODE
:
imgIContainer
:
:
FLAG_SYNC_DECODE_IF_FAST
)
;
static_cast
<
SVGGeometryFrame
*
>
(
mFrame
)
-
>
PaintSVG
(
*
aCtx
tm
imgParams
)
;
nsDisplayItemGenericImageGeometry
:
:
UpdateDrawResult
(
this
imgParams
.
result
)
;
}
void
nsDisplaySVGGeometry
:
:
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
{
auto
geometry
=
static_cast
<
const
nsDisplayItemGenericImageGeometry
*
>
(
aGeometry
)
;
if
(
aBuilder
-
>
ShouldSyncDecodeImages
(
)
&
&
geometry
-
>
ShouldInvalidateToSyncDecodeImages
(
)
)
{
bool
snap
;
aInvalidRegion
-
>
Or
(
*
aInvalidRegion
GetBounds
(
aBuilder
&
snap
)
)
;
}
nsDisplayItem
:
:
ComputeInvalidationRegion
(
aBuilder
aGeometry
aInvalidRegion
)
;
}
namespace
mozilla
{
void
SVGGeometryFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
AddStateBits
(
aParent
-
>
GetStateBits
(
)
&
NS_STATE_SVG_CLIPPATH_CHILD
)
;
nsFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
}
nsresult
SVGGeometryFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
if
(
aNameSpaceID
=
=
kNameSpaceID_None
&
&
(
static_cast
<
SVGGeometryElement
*
>
(
GetContent
(
)
)
-
>
AttributeDefinesGeometry
(
aAttribute
)
)
)
{
nsLayoutUtils
:
:
PostRestyleEvent
(
mContent
-
>
AsElement
(
)
nsRestyleHint
(
0
)
nsChangeHint_InvalidateRenderingObservers
)
;
nsSVGUtils
:
:
ScheduleReflowSVG
(
this
)
;
}
return
NS_OK
;
}
void
SVGGeometryFrame
:
:
DidSetComputedStyle
(
ComputedStyle
*
aOldComputedStyle
)
{
nsFrame
:
:
DidSetComputedStyle
(
aOldComputedStyle
)
;
if
(
aOldComputedStyle
)
{
SVGGeometryElement
*
element
=
static_cast
<
SVGGeometryElement
*
>
(
GetContent
(
)
)
;
auto
oldStyleSVG
=
aOldComputedStyle
-
>
PeekStyleSVG
(
)
;
if
(
oldStyleSVG
&
&
!
SVGContentUtils
:
:
ShapeTypeHasNoCorners
(
GetContent
(
)
)
)
{
if
(
StyleSVG
(
)
-
>
mStrokeLinecap
!
=
oldStyleSVG
-
>
mStrokeLinecap
&
&
element
-
>
IsSVGElement
(
nsGkAtoms
:
:
path
)
)
{
element
-
>
ClearAnyCachedPath
(
)
;
}
else
if
(
GetStateBits
(
)
&
NS_STATE_SVG_CLIPPATH_CHILD
)
{
if
(
StyleSVG
(
)
-
>
mClipRule
!
=
oldStyleSVG
-
>
mClipRule
)
{
element
-
>
ClearAnyCachedPath
(
)
;
}
}
else
{
if
(
StyleSVG
(
)
-
>
mFillRule
!
=
oldStyleSVG
-
>
mFillRule
)
{
element
-
>
ClearAnyCachedPath
(
)
;
}
}
}
}
}
bool
SVGGeometryFrame
:
:
IsSVGTransformed
(
gfx
:
:
Matrix
*
aOwnTransform
gfx
:
:
Matrix
*
aFromParentTransform
)
const
{
bool
foundTransform
=
false
;
nsIFrame
*
parent
=
GetParent
(
)
;
if
(
parent
&
&
parent
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
|
nsIFrame
:
:
eSVGContainer
)
)
{
foundTransform
=
static_cast
<
nsSVGContainerFrame
*
>
(
parent
)
-
>
HasChildrenOnlyTransform
(
aFromParentTransform
)
;
}
SVGElement
*
content
=
static_cast
<
SVGElement
*
>
(
GetContent
(
)
)
;
SVGAnimatedTransformList
*
transformList
=
content
-
>
GetAnimatedTransformList
(
)
;
if
(
(
transformList
&
&
transformList
-
>
HasTransform
(
)
)
|
|
content
-
>
GetAnimateMotionTransform
(
)
)
{
if
(
aOwnTransform
)
{
*
aOwnTransform
=
gfx
:
:
ToMatrix
(
content
-
>
PrependLocalTransformsTo
(
gfxMatrix
(
)
eUserSpaceToParent
)
)
;
}
foundTransform
=
true
;
}
return
foundTransform
;
}
void
SVGGeometryFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
if
(
!
static_cast
<
const
SVGElement
*
>
(
GetContent
(
)
)
-
>
HasValidDimensions
(
)
|
|
(
(
!
IsVisibleForPainting
(
)
|
|
StyleEffects
(
)
-
>
mOpacity
=
=
0
.
0f
)
&
&
aBuilder
-
>
IsForPainting
(
)
)
)
{
return
;
}
DisplayOutline
(
aBuilder
aLists
)
;
aLists
.
Content
(
)
-
>
AppendToTop
(
MakeDisplayItem
<
nsDisplaySVGGeometry
>
(
aBuilder
this
)
)
;
}
void
SVGGeometryFrame
:
:
PaintSVG
(
gfxContext
&
aContext
const
gfxMatrix
&
aTransform
imgDrawingParams
&
aImgParams
const
nsIntRect
*
aDirtyRect
)
{
if
(
!
StyleVisibility
(
)
-
>
IsVisible
(
)
)
{
return
;
}
gfxMatrix
newMatrix
=
aContext
.
CurrentMatrixDouble
(
)
.
PreMultiply
(
aTransform
)
.
NudgeToIntegers
(
)
;
if
(
newMatrix
.
IsSingular
(
)
)
{
return
;
}
uint32_t
paintOrder
=
StyleSVG
(
)
-
>
mPaintOrder
;
if
(
paintOrder
=
=
NS_STYLE_PAINT_ORDER_NORMAL
)
{
Render
(
&
aContext
eRenderFill
|
eRenderStroke
newMatrix
aImgParams
)
;
PaintMarkers
(
aContext
aTransform
aImgParams
)
;
}
else
{
while
(
paintOrder
)
{
uint32_t
component
=
paintOrder
&
(
(
1
<
<
NS_STYLE_PAINT_ORDER_BITWIDTH
)
-
1
)
;
switch
(
component
)
{
case
NS_STYLE_PAINT_ORDER_FILL
:
Render
(
&
aContext
eRenderFill
newMatrix
aImgParams
)
;
break
;
case
NS_STYLE_PAINT_ORDER_STROKE
:
Render
(
&
aContext
eRenderStroke
newMatrix
aImgParams
)
;
break
;
case
NS_STYLE_PAINT_ORDER_MARKERS
:
PaintMarkers
(
aContext
aTransform
aImgParams
)
;
break
;
}
paintOrder
>
>
=
NS_STYLE_PAINT_ORDER_BITWIDTH
;
}
}
}
nsIFrame
*
SVGGeometryFrame
:
:
GetFrameForPoint
(
const
gfxPoint
&
aPoint
)
{
FillRule
fillRule
;
uint16_t
hitTestFlags
;
if
(
GetStateBits
(
)
&
NS_STATE_SVG_CLIPPATH_CHILD
)
{
hitTestFlags
=
SVG_HIT_TEST_FILL
;
fillRule
=
nsSVGUtils
:
:
ToFillRule
(
StyleSVG
(
)
-
>
mClipRule
)
;
}
else
{
hitTestFlags
=
GetHitTestFlags
(
)
;
if
(
!
hitTestFlags
)
{
return
nullptr
;
}
if
(
hitTestFlags
&
SVG_HIT_TEST_CHECK_MRECT
)
{
gfxRect
rect
=
nsLayoutUtils
:
:
RectToGfxRect
(
mRect
AppUnitsPerCSSPixel
(
)
)
;
if
(
!
rect
.
Contains
(
aPoint
)
)
{
return
nullptr
;
}
}
fillRule
=
nsSVGUtils
:
:
ToFillRule
(
StyleSVG
(
)
-
>
mFillRule
)
;
}
bool
isHit
=
false
;
SVGGeometryElement
*
content
=
static_cast
<
SVGGeometryElement
*
>
(
GetContent
(
)
)
;
RefPtr
<
DrawTarget
>
drawTarget
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
ScreenReferenceDrawTarget
(
)
;
RefPtr
<
Path
>
path
=
content
-
>
GetOrBuildPath
(
drawTarget
fillRule
)
;
if
(
!
path
)
{
return
nullptr
;
}
if
(
hitTestFlags
&
SVG_HIT_TEST_FILL
)
{
isHit
=
path
-
>
ContainsPoint
(
ToPoint
(
aPoint
)
Matrix
(
)
)
;
}
if
(
!
isHit
&
&
(
hitTestFlags
&
SVG_HIT_TEST_STROKE
)
)
{
Point
point
=
ToPoint
(
aPoint
)
;
SVGContentUtils
:
:
AutoStrokeOptions
stroke
;
SVGContentUtils
:
:
GetStrokeOptions
(
&
stroke
content
Style
(
)
nullptr
)
;
gfxMatrix
userToOuterSVG
;
if
(
nsSVGUtils
:
:
GetNonScalingStrokeTransform
(
this
&
userToOuterSVG
)
)
{
point
=
ToMatrix
(
userToOuterSVG
)
.
TransformPoint
(
point
)
;
RefPtr
<
PathBuilder
>
builder
=
path
-
>
TransformedCopyToBuilder
(
ToMatrix
(
userToOuterSVG
)
fillRule
)
;
path
=
builder
-
>
Finish
(
)
;
}
isHit
=
path
-
>
StrokeContainsPoint
(
stroke
point
Matrix
(
)
)
;
}
if
(
isHit
&
&
nsSVGUtils
:
:
HitTestClip
(
this
aPoint
)
)
{
return
this
;
}
return
nullptr
;
}
void
SVGGeometryFrame
:
:
ReflowSVG
(
)
{
NS_ASSERTION
(
nsSVGUtils
:
:
OuterSVGIsCallingReflowSVG
(
this
)
"
This
call
is
probably
a
wasteful
mistake
"
)
;
MOZ_ASSERT
(
!
(
GetStateBits
(
)
&
NS_FRAME_IS_NONDISPLAY
)
"
ReflowSVG
mechanism
not
designed
for
this
"
)
;
if
(
!
nsSVGUtils
:
:
NeedsReflowSVG
(
this
)
)
{
return
;
}
uint32_t
flags
=
nsSVGUtils
:
:
eBBoxIncludeFill
|
nsSVGUtils
:
:
eBBoxIncludeStroke
|
nsSVGUtils
:
:
eBBoxIncludeMarkers
;
uint16_t
hitTestFlags
=
GetHitTestFlags
(
)
;
if
(
(
hitTestFlags
&
SVG_HIT_TEST_FILL
)
)
{
flags
|
=
nsSVGUtils
:
:
eBBoxIncludeFillGeometry
;
}
if
(
(
hitTestFlags
&
SVG_HIT_TEST_STROKE
)
)
{
flags
|
=
nsSVGUtils
:
:
eBBoxIncludeStrokeGeometry
;
}
gfxRect
extent
=
GetBBoxContribution
(
Matrix
(
)
flags
)
.
ToThebesRect
(
)
;
mRect
=
nsLayoutUtils
:
:
RoundGfxRectToAppRect
(
extent
AppUnitsPerCSSPixel
(
)
)
;
if
(
mState
&
NS_FRAME_FIRST_REFLOW
)
{
SVGObserverUtils
:
:
UpdateEffects
(
this
)
;
}
nsRect
overflow
=
nsRect
(
nsPoint
(
0
0
)
mRect
.
Size
(
)
)
;
nsOverflowAreas
overflowAreas
(
overflow
overflow
)
;
FinishAndStoreOverflow
(
overflowAreas
mRect
.
Size
(
)
)
;
RemoveStateBits
(
NS_FRAME_FIRST_REFLOW
|
NS_FRAME_IS_DIRTY
|
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
if
(
!
(
GetParent
(
)
-
>
GetStateBits
(
)
&
NS_FRAME_FIRST_REFLOW
)
)
{
InvalidateFrame
(
)
;
}
}
void
SVGGeometryFrame
:
:
NotifySVGChanged
(
uint32_t
aFlags
)
{
MOZ_ASSERT
(
aFlags
&
(
TRANSFORM_CHANGED
|
COORD_CONTEXT_CHANGED
)
"
Invalidation
logic
may
need
adjusting
"
)
;
if
(
aFlags
&
COORD_CONTEXT_CHANGED
)
{
if
(
static_cast
<
SVGGeometryElement
*
>
(
GetContent
(
)
)
-
>
GeometryDependsOnCoordCtx
(
)
|
|
StyleSVG
(
)
-
>
mStrokeWidth
.
HasPercent
(
)
)
{
static_cast
<
SVGGeometryElement
*
>
(
GetContent
(
)
)
-
>
ClearAnyCachedPath
(
)
;
nsSVGUtils
:
:
ScheduleReflowSVG
(
this
)
;
}
}
if
(
(
aFlags
&
TRANSFORM_CHANGED
)
&
&
StyleSVGReset
(
)
-
>
HasNonScalingStroke
(
)
)
{
nsSVGUtils
:
:
ScheduleReflowSVG
(
this
)
;
}
}
SVGBBox
SVGGeometryFrame
:
:
GetBBoxContribution
(
const
Matrix
&
aToBBoxUserspace
uint32_t
aFlags
)
{
SVGBBox
bbox
;
if
(
aToBBoxUserspace
.
IsSingular
(
)
)
{
return
bbox
;
}
if
(
(
aFlags
&
nsSVGUtils
:
:
eForGetClientRects
)
&
&
aToBBoxUserspace
.
PreservesAxisAlignedRectangles
(
)
)
{
Rect
rect
=
NSRectToRect
(
mRect
AppUnitsPerCSSPixel
(
)
)
;
bbox
=
aToBBoxUserspace
.
TransformBounds
(
rect
)
;
return
bbox
;
}
SVGGeometryElement
*
element
=
static_cast
<
SVGGeometryElement
*
>
(
GetContent
(
)
)
;
bool
getFill
=
(
aFlags
&
nsSVGUtils
:
:
eBBoxIncludeFillGeometry
)
|
|
(
(
aFlags
&
nsSVGUtils
:
:
eBBoxIncludeFill
)
&
&
StyleSVG
(
)
-
>
mFill
.
Type
(
)
!
=
eStyleSVGPaintType_None
)
;
bool
getStroke
=
(
aFlags
&
nsSVGUtils
:
:
eBBoxIncludeStrokeGeometry
)
|
|
(
(
aFlags
&
nsSVGUtils
:
:
eBBoxIncludeStroke
)
&
&
nsSVGUtils
:
:
HasStroke
(
this
)
)
;
SVGContentUtils
:
:
AutoStrokeOptions
strokeOptions
;
if
(
getStroke
)
{
SVGContentUtils
:
:
GetStrokeOptions
(
&
strokeOptions
element
Style
(
)
nullptr
SVGContentUtils
:
:
eIgnoreStrokeDashing
)
;
}
else
{
strokeOptions
.
mLineWidth
=
0
.
f
;
}
Rect
simpleBounds
;
bool
gotSimpleBounds
=
false
;
gfxMatrix
userToOuterSVG
;
if
(
getStroke
&
&
nsSVGUtils
:
:
GetNonScalingStrokeTransform
(
this
&
userToOuterSVG
)
)
{
Matrix
moz2dUserToOuterSVG
=
ToMatrix
(
userToOuterSVG
)
;
if
(
moz2dUserToOuterSVG
.
IsSingular
(
)
)
{
return
bbox
;
}
gotSimpleBounds
=
element
-
>
GetGeometryBounds
(
&
simpleBounds
strokeOptions
aToBBoxUserspace
&
moz2dUserToOuterSVG
)
;
}
else
{
gotSimpleBounds
=
element
-
>
GetGeometryBounds
(
&
simpleBounds
strokeOptions
aToBBoxUserspace
)
;
}
if
(
gotSimpleBounds
)
{
bbox
=
simpleBounds
;
}
else
{
RefPtr
<
DrawTarget
>
tmpDT
;
#
ifdef
XP_WIN
RefPtr
<
gfxASurface
>
refSurf
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
ScreenReferenceSurface
(
)
;
tmpDT
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
CreateDrawTargetForSurface
(
refSurf
IntSize
(
1
1
)
)
;
#
else
tmpDT
=
gfxPlatform
:
:
GetPlatform
(
)
-
>
ScreenReferenceDrawTarget
(
)
;
#
endif
FillRule
fillRule
=
nsSVGUtils
:
:
ToFillRule
(
(
GetStateBits
(
)
&
NS_STATE_SVG_CLIPPATH_CHILD
)
?
StyleSVG
(
)
-
>
mClipRule
:
StyleSVG
(
)
-
>
mFillRule
)
;
RefPtr
<
Path
>
pathInUserSpace
=
element
-
>
GetOrBuildPath
(
tmpDT
fillRule
)
;
if
(
!
pathInUserSpace
)
{
return
bbox
;
}
RefPtr
<
Path
>
pathInBBoxSpace
;
if
(
aToBBoxUserspace
.
IsIdentity
(
)
)
{
pathInBBoxSpace
=
pathInUserSpace
;
}
else
{
RefPtr
<
PathBuilder
>
builder
=
pathInUserSpace
-
>
TransformedCopyToBuilder
(
aToBBoxUserspace
fillRule
)
;
pathInBBoxSpace
=
builder
-
>
Finish
(
)
;
if
(
!
pathInBBoxSpace
)
{
return
bbox
;
}
}
Rect
pathBBoxExtents
=
pathInBBoxSpace
-
>
GetBounds
(
)
;
if
(
!
pathBBoxExtents
.
IsFinite
(
)
)
{
return
bbox
;
}
if
(
getFill
)
{
bbox
=
pathBBoxExtents
;
}
if
(
getStroke
)
{
#
if
0
SVGContentUtils
:
:
AutoStrokeOptions
strokeOptions
;
SVGContentUtils
:
:
GetStrokeOptions
(
&
strokeOptions
element
Style
(
)
nullptr
SVGContentUtils
:
:
eIgnoreStrokeDashing
)
;
Rect
strokeBBoxExtents
;
gfxMatrix
userToOuterSVG
;
if
(
nsSVGUtils
:
:
GetNonScalingStrokeTransform
(
this
&
userToOuterSVG
)
)
{
Matrix
outerSVGToUser
=
ToMatrix
(
userToOuterSVG
)
;
outerSVGToUser
.
Invert
(
)
;
Matrix
outerSVGToBBox
=
aToBBoxUserspace
*
outerSVGToUser
;
RefPtr
<
PathBuilder
>
builder
=
pathInUserSpace
-
>
TransformedCopyToBuilder
(
ToMatrix
(
userToOuterSVG
)
)
;
RefPtr
<
Path
>
pathInOuterSVGSpace
=
builder
-
>
Finish
(
)
;
strokeBBoxExtents
=
pathInOuterSVGSpace
-
>
GetStrokedBounds
(
strokeOptions
outerSVGToBBox
)
;
}
else
{
strokeBBoxExtents
=
pathInUserSpace
-
>
GetStrokedBounds
(
strokeOptions
aToBBoxUserspace
)
;
}
MOZ_ASSERT
(
strokeBBoxExtents
.
IsFinite
(
)
"
bbox
is
about
to
go
bad
"
)
;
bbox
.
UnionEdges
(
strokeBBoxExtents
)
;
#
else
gfxRect
strokeBBoxExtents
=
nsSVGUtils
:
:
PathExtentsToMaxStrokeExtents
(
ThebesRect
(
pathBBoxExtents
)
this
ThebesMatrix
(
aToBBoxUserspace
)
)
;
MOZ_ASSERT
(
ToRect
(
strokeBBoxExtents
)
.
IsFinite
(
)
"
bbox
is
about
to
go
bad
"
)
;
bbox
.
UnionEdges
(
strokeBBoxExtents
)
;
#
endif
}
}
if
(
(
aFlags
&
nsSVGUtils
:
:
eBBoxIncludeMarkers
)
!
=
0
&
&
element
-
>
IsMarkable
(
)
)
{
nsSVGMarkerFrame
*
markerFrames
[
SVGMark
:
:
eTypeCount
]
;
if
(
SVGObserverUtils
:
:
GetAndObserveMarkers
(
this
&
markerFrames
)
)
{
nsTArray
<
SVGMark
>
marks
;
element
-
>
GetMarkPoints
(
&
marks
)
;
if
(
uint32_t
num
=
marks
.
Length
(
)
)
{
float
strokeWidth
=
nsSVGUtils
:
:
GetStrokeWidth
(
this
)
;
for
(
uint32_t
i
=
0
;
i
<
num
;
i
+
+
)
{
const
SVGMark
&
mark
=
marks
[
i
]
;
nsSVGMarkerFrame
*
frame
=
markerFrames
[
mark
.
type
]
;
if
(
frame
)
{
SVGBBox
mbbox
=
frame
-
>
GetMarkBBoxContribution
(
aToBBoxUserspace
aFlags
this
mark
strokeWidth
)
;
MOZ_ASSERT
(
mbbox
.
IsFinite
(
)
"
bbox
is
about
to
go
bad
"
)
;
bbox
.
UnionEdges
(
mbbox
)
;
}
}
}
}
}
return
bbox
;
}
gfxMatrix
SVGGeometryFrame
:
:
GetCanvasTM
(
)
{
NS_ASSERTION
(
GetParent
(
)
"
null
parent
"
)
;
nsSVGContainerFrame
*
parent
=
static_cast
<
nsSVGContainerFrame
*
>
(
GetParent
(
)
)
;
SVGGraphicsElement
*
content
=
static_cast
<
SVGGraphicsElement
*
>
(
GetContent
(
)
)
;
return
content
-
>
PrependLocalTransformsTo
(
parent
-
>
GetCanvasTM
(
)
)
;
}
void
SVGGeometryFrame
:
:
Render
(
gfxContext
*
aContext
uint32_t
aRenderComponents
const
gfxMatrix
&
aNewTransform
imgDrawingParams
&
aImgParams
)
{
MOZ_ASSERT
(
!
aNewTransform
.
IsSingular
(
)
)
;
DrawTarget
*
drawTarget
=
aContext
-
>
GetDrawTarget
(
)
;
FillRule
fillRule
=
nsSVGUtils
:
:
ToFillRule
(
(
GetStateBits
(
)
&
NS_STATE_SVG_CLIPPATH_CHILD
)
?
StyleSVG
(
)
-
>
mClipRule
:
StyleSVG
(
)
-
>
mFillRule
)
;
SVGGeometryElement
*
element
=
static_cast
<
SVGGeometryElement
*
>
(
GetContent
(
)
)
;
AntialiasMode
aaMode
=
(
StyleSVG
(
)
-
>
mShapeRendering
=
=
NS_STYLE_SHAPE_RENDERING_OPTIMIZESPEED
|
|
StyleSVG
(
)
-
>
mShapeRendering
=
=
NS_STYLE_SHAPE_RENDERING_CRISPEDGES
)
?
AntialiasMode
:
:
NONE
:
AntialiasMode
:
:
SUBPIXEL
;
gfxContextMatrixAutoSaveRestore
autoRestoreTransform
(
aContext
)
;
aContext
-
>
SetMatrixDouble
(
aNewTransform
)
;
if
(
GetStateBits
(
)
&
NS_STATE_SVG_CLIPPATH_CHILD
)
{
RefPtr
<
Path
>
path
=
element
-
>
GetOrBuildPath
(
drawTarget
fillRule
)
;
if
(
path
)
{
ColorPattern
white
(
ToDeviceColor
(
Color
(
1
.
0f
1
.
0f
1
.
0f
1
.
0f
)
)
)
;
drawTarget
-
>
Fill
(
path
white
DrawOptions
(
1
.
0f
CompositionOp
:
:
OP_OVER
aaMode
)
)
;
}
return
;
}
SVGGeometryElement
:
:
SimplePath
simplePath
;
RefPtr
<
Path
>
path
;
element
-
>
GetAsSimplePath
(
&
simplePath
)
;
if
(
!
simplePath
.
IsPath
(
)
)
{
path
=
element
-
>
GetOrBuildPath
(
drawTarget
fillRule
)
;
if
(
!
path
)
{
return
;
}
}
SVGContextPaint
*
contextPaint
=
SVGContextPaint
:
:
GetContextPaint
(
GetContent
(
)
)
;
if
(
aRenderComponents
&
eRenderFill
)
{
GeneralPattern
fillPattern
;
nsSVGUtils
:
:
MakeFillPatternFor
(
this
aContext
&
fillPattern
aImgParams
contextPaint
)
;
if
(
fillPattern
.
GetPattern
(
)
)
{
DrawOptions
drawOptions
(
1
.
0f
CompositionOp
:
:
OP_OVER
aaMode
)
;
if
(
simplePath
.
IsRect
(
)
)
{
drawTarget
-
>
FillRect
(
simplePath
.
AsRect
(
)
fillPattern
drawOptions
)
;
}
else
if
(
path
)
{
drawTarget
-
>
Fill
(
path
fillPattern
drawOptions
)
;
}
}
}
if
(
(
aRenderComponents
&
eRenderStroke
)
&
&
nsSVGUtils
:
:
HasStroke
(
this
contextPaint
)
)
{
gfxMatrix
userToOuterSVG
;
if
(
nsSVGUtils
:
:
GetNonScalingStrokeTransform
(
this
&
userToOuterSVG
)
)
{
if
(
!
path
)
{
path
=
element
-
>
GetOrBuildPath
(
drawTarget
fillRule
)
;
if
(
!
path
)
{
return
;
}
simplePath
.
Reset
(
)
;
}
gfxMatrix
outerSVGToUser
=
userToOuterSVG
;
outerSVGToUser
.
Invert
(
)
;
aContext
-
>
Multiply
(
outerSVGToUser
)
;
RefPtr
<
PathBuilder
>
builder
=
path
-
>
TransformedCopyToBuilder
(
ToMatrix
(
userToOuterSVG
)
fillRule
)
;
path
=
builder
-
>
Finish
(
)
;
}
GeneralPattern
strokePattern
;
nsSVGUtils
:
:
MakeStrokePatternFor
(
this
aContext
&
strokePattern
aImgParams
contextPaint
)
;
if
(
strokePattern
.
GetPattern
(
)
)
{
SVGContentUtils
:
:
AutoStrokeOptions
strokeOptions
;
SVGContentUtils
:
:
GetStrokeOptions
(
&
strokeOptions
static_cast
<
SVGElement
*
>
(
GetContent
(
)
)
Style
(
)
contextPaint
)
;
if
(
strokeOptions
.
mLineWidth
<
=
0
)
{
return
;
}
DrawOptions
drawOptions
(
1
.
0f
CompositionOp
:
:
OP_OVER
aaMode
)
;
if
(
simplePath
.
IsRect
(
)
)
{
drawTarget
-
>
StrokeRect
(
simplePath
.
AsRect
(
)
strokePattern
strokeOptions
drawOptions
)
;
}
else
if
(
simplePath
.
IsLine
(
)
)
{
drawTarget
-
>
StrokeLine
(
simplePath
.
Point1
(
)
simplePath
.
Point2
(
)
strokePattern
strokeOptions
drawOptions
)
;
}
else
{
drawTarget
-
>
Stroke
(
path
strokePattern
strokeOptions
drawOptions
)
;
}
}
}
}
void
SVGGeometryFrame
:
:
PaintMarkers
(
gfxContext
&
aContext
const
gfxMatrix
&
aTransform
imgDrawingParams
&
aImgParams
)
{
auto
element
=
static_cast
<
SVGGeometryElement
*
>
(
GetContent
(
)
)
;
if
(
element
-
>
IsMarkable
(
)
)
{
nsSVGMarkerFrame
*
markerFrames
[
SVGMark
:
:
eTypeCount
]
;
if
(
SVGObserverUtils
:
:
GetAndObserveMarkers
(
this
&
markerFrames
)
)
{
nsTArray
<
SVGMark
>
marks
;
element
-
>
GetMarkPoints
(
&
marks
)
;
if
(
uint32_t
num
=
marks
.
Length
(
)
)
{
SVGContextPaint
*
contextPaint
=
SVGContextPaint
:
:
GetContextPaint
(
GetContent
(
)
)
;
float
strokeWidth
=
nsSVGUtils
:
:
GetStrokeWidth
(
this
contextPaint
)
;
for
(
uint32_t
i
=
0
;
i
<
num
;
i
+
+
)
{
const
SVGMark
&
mark
=
marks
[
i
]
;
nsSVGMarkerFrame
*
frame
=
markerFrames
[
mark
.
type
]
;
if
(
frame
)
{
frame
-
>
PaintMark
(
aContext
aTransform
this
mark
strokeWidth
aImgParams
)
;
}
}
}
}
}
}
uint16_t
SVGGeometryFrame
:
:
GetHitTestFlags
(
)
{
return
nsSVGUtils
:
:
GetGeometryHitTestFlags
(
this
)
;
}
}
