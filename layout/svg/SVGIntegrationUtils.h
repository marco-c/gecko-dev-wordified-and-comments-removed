#
ifndef
LAYOUT_SVG_SVGINTEGRATIONUTILS_H_
#
define
LAYOUT_SVG_SVGINTEGRATIONUTILS_H_
#
include
"
ImgDrawResult
.
h
"
#
include
"
gfxMatrix
.
h
"
#
include
"
gfxRect
.
h
"
#
include
"
nsRegionFwd
.
h
"
#
include
"
mozilla
/
gfx
/
Rect
.
h
"
#
include
"
mozilla
/
ServoStyleConsts
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderTypes
.
h
"
class
gfxContext
;
class
gfxDrawable
;
class
nsIFrame
;
struct
nsPoint
;
struct
nsRect
;
struct
nsSize
;
struct
WrFiltersHolder
{
nsTArray
<
mozilla
:
:
wr
:
:
FilterOp
>
filters
;
nsTArray
<
mozilla
:
:
wr
:
:
WrFilterData
>
filter_datas
;
nsTArray
<
nsTArray
<
float
>
>
values
;
}
;
namespace
mozilla
{
class
nsDisplayList
;
class
nsDisplayListBuilder
;
namespace
gfx
{
class
DrawTarget
;
}
namespace
layers
{
class
LayerManager
;
}
class
SVGIntegrationUtils
final
{
using
DrawTarget
=
gfx
:
:
DrawTarget
;
using
IntRect
=
gfx
:
:
IntRect
;
using
imgDrawingParams
=
image
:
:
imgDrawingParams
;
public
:
static
bool
UsingOverflowAffectingEffects
(
const
nsIFrame
*
aFrame
)
;
static
bool
UsingEffectsForFrame
(
const
nsIFrame
*
aFrame
)
;
static
bool
UsingMaskOrClipPathForFrame
(
const
nsIFrame
*
aFrame
)
;
static
bool
UsingSimpleClipPathForFrame
(
const
nsIFrame
*
aFrame
)
;
static
nsSize
GetContinuationUnionSize
(
nsIFrame
*
aNonSVGFrame
)
;
static
gfx
:
:
Size
GetSVGCoordContextForNonSVGFrame
(
nsIFrame
*
aNonSVGFrame
)
;
static
gfxRect
GetSVGBBoxForNonSVGFrame
(
nsIFrame
*
aNonSVGFrame
bool
aUnionContinuations
)
;
static
nsRect
ComputePostEffectsInkOverflowRect
(
nsIFrame
*
aFrame
const
nsRect
&
aPreEffectsOverflowRect
)
;
static
nsIntRegion
AdjustInvalidAreaForSVGEffects
(
nsIFrame
*
aFrame
const
nsPoint
&
aToReferenceFrame
const
nsIntRegion
&
aInvalidRegion
)
;
static
nsRect
GetRequiredSourceForInvalidArea
(
nsIFrame
*
aFrame
const
nsRect
&
aDirtyRect
)
;
static
bool
HitTestFrameForEffects
(
nsIFrame
*
aFrame
const
nsPoint
&
aPt
)
;
struct
MOZ_STACK_CLASS
PaintFramesParams
{
gfxContext
&
ctx
;
nsIFrame
*
frame
;
nsRect
dirtyRect
;
nsRect
borderArea
;
nsDisplayListBuilder
*
builder
;
layers
:
:
LayerManager
*
layerManager
;
bool
handleOpacity
;
Maybe
<
gfx
:
:
Rect
>
maskRect
;
imgDrawingParams
&
imgParams
;
explicit
PaintFramesParams
(
gfxContext
&
aCtx
nsIFrame
*
aFrame
const
nsRect
&
aDirtyRect
const
nsRect
&
aBorderArea
nsDisplayListBuilder
*
aBuilder
layers
:
:
LayerManager
*
aLayerManager
bool
aHandleOpacity
imgDrawingParams
&
aImgParams
)
:
ctx
(
aCtx
)
frame
(
aFrame
)
dirtyRect
(
aDirtyRect
)
borderArea
(
aBorderArea
)
builder
(
aBuilder
)
layerManager
(
aLayerManager
)
handleOpacity
(
aHandleOpacity
)
imgParams
(
aImgParams
)
{
}
}
;
static
void
PaintMaskAndClipPath
(
const
PaintFramesParams
&
aParams
const
std
:
:
function
<
void
(
)
>
&
aPaintChild
)
;
static
bool
PaintMask
(
const
PaintFramesParams
&
aParams
bool
&
aOutIsMaskComplete
)
;
static
bool
IsMaskResourceReady
(
nsIFrame
*
aFrame
)
;
using
SVGFilterPaintCallback
=
std
:
:
function
<
void
(
gfxContext
&
aContext
nsIFrame
*
aTarget
const
gfxMatrix
&
aTransform
const
nsIntRect
*
aDirtyRect
image
:
:
imgDrawingParams
&
aImgParams
)
>
;
static
void
PaintFilter
(
const
PaintFramesParams
&
aParams
const
SVGFilterPaintCallback
&
aCallback
)
;
static
bool
CreateWebRenderCSSFilters
(
Span
<
const
StyleFilter
>
aFilters
nsIFrame
*
aFrame
WrFiltersHolder
&
aWrFilters
)
;
static
bool
BuildWebRenderFilters
(
nsIFrame
*
aFilteredFrame
Span
<
const
StyleFilter
>
aFilters
WrFiltersHolder
&
aWrFilters
Maybe
<
nsRect
>
&
aPostFilterClip
)
;
static
bool
CanCreateWebRenderFiltersForFrame
(
nsIFrame
*
aFrame
)
;
static
bool
UsesSVGEffectsNotSupportedInCompositor
(
nsIFrame
*
aFrame
)
;
enum
{
FLAG_SYNC_DECODE_IMAGES
=
0x01
}
;
static
already_AddRefed
<
gfxDrawable
>
DrawableFromPaintServer
(
nsIFrame
*
aFrame
nsIFrame
*
aTarget
const
nsSize
&
aPaintServerSize
const
gfx
:
:
IntSize
&
aRenderSize
const
DrawTarget
*
aDrawTarget
const
gfxMatrix
&
aContextMatrix
uint32_t
aFlags
)
;
static
nsPoint
GetOffsetToBoundingBox
(
nsIFrame
*
aFrame
)
;
static
gfxPoint
GetOffsetToUserSpaceInDevPx
(
nsIFrame
*
aFrame
const
PaintFramesParams
&
aParams
)
;
}
;
}
#
endif
