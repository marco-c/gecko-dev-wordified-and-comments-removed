#
include
"
SVGForeignObjectFrame
.
h
"
#
include
"
ImgDrawResult
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
mozilla
/
AutoRestore
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
SVGContainerFrame
.
h
"
#
include
"
mozilla
/
SVGObserverUtils
.
h
"
#
include
"
mozilla
/
SVGUtils
.
h
"
#
include
"
mozilla
/
dom
/
SVGForeignObjectElement
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsRegion
.
h
"
#
include
"
SVGGeometryProperty
.
h
"
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
image
;
namespace
SVGT
=
SVGGeometryProperty
:
:
Tags
;
nsContainerFrame
*
NS_NewSVGForeignObjectFrame
(
mozilla
:
:
PresShell
*
aPresShell
mozilla
:
:
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
mozilla
:
:
SVGForeignObjectFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
namespace
mozilla
{
NS_IMPL_FRAMEARENA_HELPERS
(
SVGForeignObjectFrame
)
SVGForeignObjectFrame
:
:
SVGForeignObjectFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
:
nsContainerFrame
(
aStyle
aPresContext
kClassID
)
{
AddStateBits
(
NS_FRAME_REFLOW_ROOT
|
NS_FRAME_MAY_BE_TRANSFORMED
|
NS_FRAME_SVG_LAYOUT
|
NS_FRAME_FONT_INFLATION_CONTAINER
|
NS_FRAME_FONT_INFLATION_FLOW_ROOT
)
;
}
NS_QUERYFRAME_HEAD
(
SVGForeignObjectFrame
)
NS_QUERYFRAME_ENTRY
(
ISVGDisplayableFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsContainerFrame
)
void
SVGForeignObjectFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
NS_ASSERTION
(
aContent
-
>
IsSVGElement
(
nsGkAtoms
:
:
foreignObject
)
"
Content
is
not
an
SVG
foreignObject
!
"
)
;
nsContainerFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
AddStateBits
(
aParent
-
>
GetStateBits
(
)
&
NS_STATE_SVG_CLIPPATH_CHILD
)
;
}
nsresult
SVGForeignObjectFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
if
(
aNameSpaceID
=
=
kNameSpaceID_None
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
transform
)
{
mCanvasTM
=
nullptr
;
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
viewBox
|
|
aAttribute
=
=
nsGkAtoms
:
:
preserveAspectRatio
)
{
nsLayoutUtils
:
:
PostRestyleEvent
(
mContent
-
>
AsElement
(
)
RestyleHint
{
0
}
nsChangeHint_InvalidateRenderingObservers
)
;
}
}
return
NS_OK
;
}
void
SVGForeignObjectFrame
:
:
DidSetComputedStyle
(
ComputedStyle
*
aOldComputedStyle
)
{
nsContainerFrame
:
:
DidSetComputedStyle
(
aOldComputedStyle
)
;
if
(
aOldComputedStyle
)
{
if
(
StyleSVGReset
(
)
-
>
mX
!
=
aOldComputedStyle
-
>
StyleSVGReset
(
)
-
>
mX
|
|
StyleSVGReset
(
)
-
>
mY
!
=
aOldComputedStyle
-
>
StyleSVGReset
(
)
-
>
mY
)
{
mCanvasTM
=
nullptr
;
SVGUtils
:
:
ScheduleReflowSVG
(
this
)
;
}
}
}
void
SVGForeignObjectFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
MOZ_ASSERT
(
!
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
"
Should
not
have
been
called
"
)
;
NS_ASSERTION
(
!
HasAnyStateBits
(
NS_FRAME_IS_DIRTY
)
"
Reflowing
while
a
resize
is
pending
is
wasteful
"
)
;
NS_ASSERTION
(
!
aReflowInput
.
mParentReflowInput
"
should
only
get
reflow
from
being
reflow
root
"
)
;
NS_ASSERTION
(
aReflowInput
.
ComputedSize
(
)
=
=
GetLogicalSize
(
)
"
reflow
roots
should
be
reflowed
at
existing
size
and
"
"
svg
.
css
should
ensure
we
have
no
padding
/
border
/
margin
"
)
;
DoReflow
(
)
;
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
LogicalSize
finalSize
(
wm
aReflowInput
.
ComputedISize
(
)
aReflowInput
.
ComputedBSize
(
)
)
;
aDesiredSize
.
SetSize
(
wm
finalSize
)
;
aDesiredSize
.
SetOverflowAreasToDesiredBounds
(
)
;
}
void
SVGForeignObjectFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
if
(
!
static_cast
<
const
SVGElement
*
>
(
GetContent
(
)
)
-
>
HasValidDimensions
(
)
)
{
return
;
}
nsDisplayList
newList
(
aBuilder
)
;
nsDisplayListSet
set
(
&
newList
&
newList
&
newList
&
newList
&
newList
&
newList
)
;
DisplayOutline
(
aBuilder
set
)
;
BuildDisplayListForNonBlockChildren
(
aBuilder
set
)
;
aLists
.
Content
(
)
-
>
AppendNewToTop
<
nsDisplayForeignObject
>
(
aBuilder
this
&
newList
)
;
}
bool
SVGForeignObjectFrame
:
:
DoGetParentSVGTransforms
(
Matrix
*
aFromParentTransform
)
const
{
return
SVGUtils
:
:
GetParentSVGTransforms
(
this
aFromParentTransform
)
;
}
void
SVGForeignObjectFrame
:
:
PaintSVG
(
gfxContext
&
aContext
const
gfxMatrix
&
aTransform
imgDrawingParams
&
aImgParams
)
{
NS_ASSERTION
(
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
"
Only
painting
of
non
-
display
SVG
should
take
this
code
path
"
)
;
if
(
IsDisabled
(
)
)
{
return
;
}
nsIFrame
*
kid
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
!
kid
)
{
return
;
}
if
(
aTransform
.
IsSingular
(
)
)
{
NS_WARNING
(
"
Can
'
t
render
foreignObject
element
!
"
)
;
return
;
}
gfxClipAutoSaveRestore
autoSaveClip
(
&
aContext
)
;
if
(
StyleDisplay
(
)
-
>
IsScrollableOverflow
(
)
)
{
float
x
y
width
height
;
SVGGeometryProperty
:
:
ResolveAll
<
SVGT
:
:
X
SVGT
:
:
Y
SVGT
:
:
Width
SVGT
:
:
Height
>
(
static_cast
<
SVGElement
*
>
(
GetContent
(
)
)
&
x
&
y
&
width
&
height
)
;
gfxRect
clipRect
=
SVGUtils
:
:
GetClipRectForFrame
(
this
0
.
0f
0
.
0f
width
height
)
;
autoSaveClip
.
TransformedClip
(
aTransform
clipRect
)
;
}
float
cssPxPerDevPx
=
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
gfxMatrix
canvasTMForChildren
=
aTransform
;
canvasTMForChildren
.
PreScale
(
cssPxPerDevPx
cssPxPerDevPx
)
;
aContext
.
Multiply
(
canvasTMForChildren
)
;
using
PaintFrameFlags
=
nsLayoutUtils
:
:
PaintFrameFlags
;
PaintFrameFlags
flags
=
PaintFrameFlags
:
:
InTransform
;
if
(
SVGAutoRenderState
:
:
IsPaintingToWindow
(
aContext
.
GetDrawTarget
(
)
)
)
{
flags
|
=
PaintFrameFlags
:
:
ToWindow
;
}
if
(
aImgParams
.
imageFlags
&
imgIContainer
:
:
FLAG_SYNC_DECODE
)
{
flags
|
=
PaintFrameFlags
:
:
SyncDecodeImages
;
}
if
(
aImgParams
.
imageFlags
&
imgIContainer
:
:
FLAG_HIGH_QUALITY_SCALING
)
{
flags
|
=
PaintFrameFlags
:
:
UseHighQualityScaling
;
}
nsLayoutUtils
:
:
PaintFrame
(
&
aContext
kid
nsRegion
(
kid
-
>
InkOverflowRect
(
)
)
NS_RGBA
(
0
0
0
0
)
nsDisplayListBuilderMode
:
:
Painting
flags
)
;
}
nsIFrame
*
SVGForeignObjectFrame
:
:
GetFrameForPoint
(
const
gfxPoint
&
aPoint
)
{
MOZ_ASSERT_UNREACHABLE
(
"
A
clipPath
cannot
contain
an
SVGForeignObject
element
"
)
;
return
nullptr
;
}
void
SVGForeignObjectFrame
:
:
ReflowSVG
(
)
{
NS_ASSERTION
(
SVGUtils
:
:
OuterSVGIsCallingReflowSVG
(
this
)
"
This
call
is
probably
a
wasteful
mistake
"
)
;
MOZ_ASSERT
(
!
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
"
ReflowSVG
mechanism
not
designed
for
this
"
)
;
if
(
!
SVGUtils
:
:
NeedsReflowSVG
(
this
)
)
{
return
;
}
float
x
y
w
h
;
SVGGeometryProperty
:
:
ResolveAll
<
SVGT
:
:
X
SVGT
:
:
Y
SVGT
:
:
Width
SVGT
:
:
Height
>
(
static_cast
<
SVGElement
*
>
(
GetContent
(
)
)
&
x
&
y
&
w
&
h
)
;
if
(
w
<
0
.
0f
)
w
=
0
.
0f
;
if
(
h
<
0
.
0f
)
h
=
0
.
0f
;
mRect
=
nsLayoutUtils
:
:
RoundGfxRectToAppRect
(
gfxRect
(
x
y
w
h
)
AppUnitsPerCSSPixel
(
)
)
;
nsIFrame
*
kid
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
kid
-
>
MarkSubtreeDirty
(
)
;
nsPresContext
:
:
InterruptPreventer
noInterrupts
(
PresContext
(
)
)
;
DoReflow
(
)
;
if
(
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
)
{
SVGObserverUtils
:
:
UpdateEffects
(
this
)
;
}
if
(
StyleEffects
(
)
-
>
HasFilters
(
)
)
{
InvalidateFrame
(
)
;
}
auto
*
anonKid
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
nsRect
overflow
=
anonKid
-
>
InkOverflowRect
(
)
;
OverflowAreas
overflowAreas
(
overflow
overflow
)
;
FinishAndStoreOverflow
(
overflowAreas
mRect
.
Size
(
)
)
;
RemoveStateBits
(
NS_FRAME_FIRST_REFLOW
|
NS_FRAME_IS_DIRTY
|
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
}
void
SVGForeignObjectFrame
:
:
NotifySVGChanged
(
uint32_t
aFlags
)
{
MOZ_ASSERT
(
aFlags
&
(
TRANSFORM_CHANGED
|
COORD_CONTEXT_CHANGED
)
"
Invalidation
logic
may
need
adjusting
"
)
;
bool
needNewBounds
=
false
;
bool
needReflow
=
false
;
bool
needNewCanvasTM
=
false
;
if
(
aFlags
&
COORD_CONTEXT_CHANGED
)
{
if
(
StyleSVGReset
(
)
-
>
mX
.
HasPercent
(
)
|
|
StyleSVGReset
(
)
-
>
mY
.
HasPercent
(
)
)
{
needNewBounds
=
true
;
needNewCanvasTM
=
true
;
}
if
(
StylePosition
(
)
-
>
mWidth
.
HasPercent
(
)
|
|
StylePosition
(
)
-
>
mHeight
.
HasPercent
(
)
)
{
needNewBounds
=
true
;
needReflow
=
true
;
}
}
if
(
aFlags
&
TRANSFORM_CHANGED
)
{
if
(
mCanvasTM
&
&
mCanvasTM
-
>
IsSingular
(
)
)
{
needNewBounds
=
true
;
}
needNewCanvasTM
=
true
;
}
if
(
needNewBounds
)
{
SVGUtils
:
:
ScheduleReflowSVG
(
this
)
;
}
if
(
needReflow
&
&
!
PresShell
(
)
-
>
IsReflowLocked
(
)
)
{
RequestReflow
(
IntrinsicDirty
:
:
None
)
;
}
if
(
needNewCanvasTM
)
{
mCanvasTM
=
nullptr
;
}
}
SVGBBox
SVGForeignObjectFrame
:
:
GetBBoxContribution
(
const
Matrix
&
aToBBoxUserspace
uint32_t
aFlags
)
{
SVGForeignObjectElement
*
content
=
static_cast
<
SVGForeignObjectElement
*
>
(
GetContent
(
)
)
;
float
x
y
w
h
;
SVGGeometryProperty
:
:
ResolveAll
<
SVGT
:
:
X
SVGT
:
:
Y
SVGT
:
:
Width
SVGT
:
:
Height
>
(
content
&
x
&
y
&
w
&
h
)
;
if
(
w
<
0
.
0f
)
w
=
0
.
0f
;
if
(
h
<
0
.
0f
)
h
=
0
.
0f
;
if
(
aToBBoxUserspace
.
IsSingular
(
)
)
{
return
SVGBBox
(
)
;
}
return
aToBBoxUserspace
.
TransformBounds
(
gfx
:
:
Rect
(
0
.
0
0
.
0
w
h
)
)
;
}
gfxMatrix
SVGForeignObjectFrame
:
:
GetCanvasTM
(
)
{
if
(
!
mCanvasTM
)
{
NS_ASSERTION
(
GetParent
(
)
"
null
parent
"
)
;
auto
*
parent
=
static_cast
<
SVGContainerFrame
*
>
(
GetParent
(
)
)
;
auto
*
content
=
static_cast
<
SVGForeignObjectElement
*
>
(
GetContent
(
)
)
;
gfxMatrix
tm
=
content
-
>
PrependLocalTransformsTo
(
parent
-
>
GetCanvasTM
(
)
)
;
mCanvasTM
=
MakeUnique
<
gfxMatrix
>
(
tm
)
;
}
return
*
mCanvasTM
;
}
void
SVGForeignObjectFrame
:
:
RequestReflow
(
IntrinsicDirty
aType
)
{
if
(
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
)
{
return
;
}
nsIFrame
*
kid
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
!
kid
)
{
return
;
}
PresShell
(
)
-
>
FrameNeedsReflow
(
kid
aType
NS_FRAME_IS_DIRTY
)
;
}
void
SVGForeignObjectFrame
:
:
DoReflow
(
)
{
MarkInReflow
(
)
;
if
(
IsDisabled
(
)
&
&
!
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
)
{
return
;
}
nsPresContext
*
presContext
=
PresContext
(
)
;
nsIFrame
*
kid
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
if
(
!
kid
)
{
return
;
}
UniquePtr
<
gfxContext
>
renderingContext
=
presContext
-
>
PresShell
(
)
-
>
CreateReferenceRenderingContext
(
)
;
WritingMode
wm
=
kid
-
>
GetWritingMode
(
)
;
ReflowInput
reflowInput
(
presContext
kid
renderingContext
.
get
(
)
LogicalSize
(
wm
ISize
(
wm
)
NS_UNCONSTRAINEDSIZE
)
)
;
ReflowOutput
desiredSize
(
reflowInput
)
;
nsReflowStatus
status
;
NS_ASSERTION
(
reflowInput
.
ComputedPhysicalBorderPadding
(
)
=
=
nsMargin
(
0
0
0
0
)
&
&
reflowInput
.
ComputedPhysicalMargin
(
)
=
=
nsMargin
(
0
0
0
0
)
"
style
system
should
ensure
that
:
-
moz
-
svg
-
foreign
-
content
"
"
does
not
get
styled
"
)
;
NS_ASSERTION
(
reflowInput
.
ComputedISize
(
)
=
=
ISize
(
wm
)
"
reflow
input
made
child
wrong
size
"
)
;
reflowInput
.
SetComputedBSize
(
BSize
(
wm
)
)
;
ReflowChild
(
kid
presContext
desiredSize
reflowInput
0
0
ReflowChildFlags
:
:
NoMoveFrame
status
)
;
NS_ASSERTION
(
mRect
.
width
=
=
desiredSize
.
Width
(
)
&
&
mRect
.
height
=
=
desiredSize
.
Height
(
)
"
unexpected
size
"
)
;
FinishReflowChild
(
kid
presContext
desiredSize
&
reflowInput
0
0
ReflowChildFlags
:
:
NoMoveFrame
)
;
}
void
SVGForeignObjectFrame
:
:
AppendDirectlyOwnedAnonBoxes
(
nsTArray
<
OwnedAnonBox
>
&
aResult
)
{
MOZ_ASSERT
(
PrincipalChildList
(
)
.
FirstChild
(
)
"
Must
have
our
anon
box
"
)
;
aResult
.
AppendElement
(
OwnedAnonBox
(
PrincipalChildList
(
)
.
FirstChild
(
)
)
)
;
}
}
