#
include
"
SVGImageFrame
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxPlatform
.
h
"
#
include
"
mozilla
/
ComputedStyleInlines
.
h
"
#
include
"
mozilla
/
image
/
WebRenderImageProvider
.
h
"
#
include
"
mozilla
/
layers
/
RenderRootStateManager
.
h
"
#
include
"
mozilla
/
layers
/
WebRenderLayerManager
.
h
"
#
include
"
imgIContainer
.
h
"
#
include
"
ImageRegion
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsIImageLoadingContent
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
imgINotificationObserver
.
h
"
#
include
"
SVGGeometryProperty
.
h
"
#
include
"
SVGGeometryFrame
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
StaticPrefs_image
.
h
"
#
include
"
mozilla
/
SVGContentUtils
.
h
"
#
include
"
mozilla
/
SVGImageContext
.
h
"
#
include
"
mozilla
/
SVGObserverUtils
.
h
"
#
include
"
mozilla
/
SVGUtils
.
h
"
#
include
"
mozilla
/
dom
/
MutationEventBinding
.
h
"
#
include
"
mozilla
/
dom
/
SVGImageElement
.
h
"
#
include
"
nsIReflowCallback
.
h
"
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
image
;
using
namespace
mozilla
:
:
dom
:
:
SVGPreserveAspectRatio_Binding
;
namespace
SVGT
=
SVGGeometryProperty
:
:
Tags
;
namespace
mozilla
{
class
SVGImageListener
final
:
public
imgINotificationObserver
{
public
:
explicit
SVGImageListener
(
SVGImageFrame
*
aFrame
)
;
NS_DECL_ISUPPORTS
NS_DECL_IMGINOTIFICATIONOBSERVER
void
SetFrame
(
SVGImageFrame
*
frame
)
{
mFrame
=
frame
;
}
private
:
~
SVGImageListener
(
)
=
default
;
SVGImageFrame
*
mFrame
;
}
;
NS_QUERYFRAME_HEAD
(
SVGImageFrame
)
NS_QUERYFRAME_ENTRY
(
SVGImageFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
SVGGeometryFrame
)
}
nsIFrame
*
NS_NewSVGImageFrame
(
mozilla
:
:
PresShell
*
aPresShell
mozilla
:
:
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
mozilla
:
:
SVGImageFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
namespace
mozilla
{
NS_IMPL_FRAMEARENA_HELPERS
(
SVGImageFrame
)
SVGImageFrame
:
:
~
SVGImageFrame
(
)
{
if
(
mListener
)
{
nsCOMPtr
<
nsIImageLoadingContent
>
imageLoader
=
do_QueryInterface
(
GetContent
(
)
)
;
if
(
imageLoader
)
{
imageLoader
-
>
RemoveNativeObserver
(
mListener
)
;
}
reinterpret_cast
<
SVGImageListener
*
>
(
mListener
.
get
(
)
)
-
>
SetFrame
(
nullptr
)
;
}
mListener
=
nullptr
;
}
void
SVGImageFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
NS_ASSERTION
(
aContent
-
>
IsSVGElement
(
nsGkAtoms
:
:
image
)
"
Content
is
not
an
SVG
image
!
"
)
;
SVGGeometryFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
if
(
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
)
{
IncApproximateVisibleCount
(
)
;
}
mListener
=
new
SVGImageListener
(
this
)
;
nsCOMPtr
<
nsIImageLoadingContent
>
imageLoader
=
do_QueryInterface
(
GetContent
(
)
)
;
if
(
!
imageLoader
)
{
MOZ_CRASH
(
"
Why
is
this
not
an
image
loading
content
?
"
)
;
}
imageLoader
-
>
FrameCreated
(
this
)
;
imageLoader
-
>
AddNativeObserver
(
mListener
)
;
}
void
SVGImageFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
{
if
(
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
)
{
DecApproximateVisibleCount
(
)
;
}
if
(
mReflowCallbackPosted
)
{
PresShell
(
)
-
>
CancelReflowCallback
(
this
)
;
mReflowCallbackPosted
=
false
;
}
nsCOMPtr
<
nsIImageLoadingContent
>
imageLoader
=
do_QueryInterface
(
nsIFrame
:
:
mContent
)
;
if
(
imageLoader
)
{
imageLoader
-
>
FrameDestroyed
(
this
)
;
}
nsIFrame
:
:
DestroyFrom
(
aDestructRoot
aPostDestroyData
)
;
}
void
SVGImageFrame
:
:
DidSetComputedStyle
(
ComputedStyle
*
aOldStyle
)
{
nsIFrame
:
:
DidSetComputedStyle
(
aOldStyle
)
;
if
(
!
mImageContainer
|
|
!
aOldStyle
)
{
return
;
}
nsCOMPtr
<
imgIRequest
>
currentRequest
;
nsCOMPtr
<
nsIImageLoadingContent
>
imageLoader
=
do_QueryInterface
(
GetContent
(
)
)
;
if
(
imageLoader
)
{
imageLoader
-
>
GetRequest
(
nsIImageLoadingContent
:
:
CURRENT_REQUEST
getter_AddRefs
(
currentRequest
)
)
;
}
StyleImageOrientation
newOrientation
=
StyleVisibility
(
)
-
>
UsedImageOrientation
(
currentRequest
)
;
StyleImageOrientation
oldOrientation
=
aOldStyle
-
>
StyleVisibility
(
)
-
>
UsedImageOrientation
(
currentRequest
)
;
if
(
oldOrientation
!
=
newOrientation
)
{
nsCOMPtr
<
imgIContainer
>
image
(
mImageContainer
-
>
Unwrap
(
)
)
;
mImageContainer
=
nsLayoutUtils
:
:
OrientImage
(
image
newOrientation
)
;
}
}
nsresult
SVGImageFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
if
(
aNameSpaceID
=
=
kNameSpaceID_None
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
preserveAspectRatio
)
{
InvalidateFrame
(
)
;
return
NS_OK
;
}
}
if
(
aModType
=
=
MutationEvent_Binding
:
:
SMIL
&
&
aAttribute
=
=
nsGkAtoms
:
:
href
&
&
(
aNameSpaceID
=
=
kNameSpaceID_XLink
|
|
aNameSpaceID
=
=
kNameSpaceID_None
)
)
{
SVGImageElement
*
element
=
static_cast
<
SVGImageElement
*
>
(
GetContent
(
)
)
;
bool
hrefIsSet
=
element
-
>
mStringAttributes
[
SVGImageElement
:
:
HREF
]
.
IsExplicitlySet
(
)
|
|
element
-
>
mStringAttributes
[
SVGImageElement
:
:
XLINK_HREF
]
.
IsExplicitlySet
(
)
;
if
(
hrefIsSet
)
{
element
-
>
LoadSVGImage
(
true
true
)
;
}
else
{
element
-
>
CancelImageRequests
(
true
)
;
}
}
return
NS_OK
;
}
void
SVGImageFrame
:
:
OnVisibilityChange
(
Visibility
aNewVisibility
const
Maybe
<
OnNonvisible
>
&
aNonvisibleAction
)
{
nsCOMPtr
<
nsIImageLoadingContent
>
imageLoader
=
do_QueryInterface
(
GetContent
(
)
)
;
if
(
imageLoader
)
{
imageLoader
-
>
OnVisibilityChange
(
aNewVisibility
aNonvisibleAction
)
;
}
nsIFrame
:
:
OnVisibilityChange
(
aNewVisibility
aNonvisibleAction
)
;
}
gfx
:
:
Matrix
SVGImageFrame
:
:
GetRasterImageTransform
(
int32_t
aNativeWidth
int32_t
aNativeHeight
)
{
float
x
y
width
height
;
SVGImageElement
*
element
=
static_cast
<
SVGImageElement
*
>
(
GetContent
(
)
)
;
SVGGeometryProperty
:
:
ResolveAll
<
SVGT
:
:
X
SVGT
:
:
Y
SVGT
:
:
Width
SVGT
:
:
Height
>
(
element
&
x
&
y
&
width
&
height
)
;
Matrix
viewBoxTM
=
SVGContentUtils
:
:
GetViewBoxTransform
(
width
height
0
0
aNativeWidth
aNativeHeight
element
-
>
mPreserveAspectRatio
)
;
return
viewBoxTM
*
gfx
:
:
Matrix
:
:
Translation
(
x
y
)
;
}
gfx
:
:
Matrix
SVGImageFrame
:
:
GetVectorImageTransform
(
)
{
float
x
y
;
SVGImageElement
*
element
=
static_cast
<
SVGImageElement
*
>
(
GetContent
(
)
)
;
SVGGeometryProperty
:
:
ResolveAll
<
SVGT
:
:
X
SVGT
:
:
Y
>
(
element
&
x
&
y
)
;
return
gfx
:
:
Matrix
:
:
Translation
(
x
y
)
;
}
bool
SVGImageFrame
:
:
GetIntrinsicImageDimensions
(
mozilla
:
:
gfx
:
:
Size
&
aSize
mozilla
:
:
AspectRatio
&
aAspectRatio
)
const
{
if
(
!
mImageContainer
)
{
return
false
;
}
ImageResolution
resolution
=
mImageContainer
-
>
GetResolution
(
)
;
int32_t
width
height
;
if
(
NS_FAILED
(
mImageContainer
-
>
GetWidth
(
&
width
)
)
)
{
aSize
.
width
=
-
1
;
}
else
{
aSize
.
width
=
width
;
resolution
.
ApplyXTo
(
aSize
.
width
)
;
}
if
(
NS_FAILED
(
mImageContainer
-
>
GetHeight
(
&
height
)
)
)
{
aSize
.
height
=
-
1
;
}
else
{
aSize
.
height
=
height
;
resolution
.
ApplyYTo
(
aSize
.
height
)
;
}
Maybe
<
AspectRatio
>
asp
=
mImageContainer
-
>
GetIntrinsicRatio
(
)
;
aAspectRatio
=
asp
.
valueOr
(
AspectRatio
{
}
)
;
return
true
;
}
bool
SVGImageFrame
:
:
TransformContextForPainting
(
gfxContext
*
aGfxContext
const
gfxMatrix
&
aTransform
)
{
gfx
:
:
Matrix
imageTransform
;
if
(
mImageContainer
-
>
GetType
(
)
=
=
imgIContainer
:
:
TYPE_VECTOR
)
{
imageTransform
=
GetVectorImageTransform
(
)
*
ToMatrix
(
aTransform
)
;
}
else
{
int32_t
nativeWidth
nativeHeight
;
if
(
NS_FAILED
(
mImageContainer
-
>
GetWidth
(
&
nativeWidth
)
)
|
|
NS_FAILED
(
mImageContainer
-
>
GetHeight
(
&
nativeHeight
)
)
|
|
nativeWidth
=
=
0
|
|
nativeHeight
=
=
0
)
{
return
false
;
}
mImageContainer
-
>
GetResolution
(
)
.
ApplyTo
(
nativeWidth
nativeHeight
)
;
imageTransform
=
GetRasterImageTransform
(
nativeWidth
nativeHeight
)
*
ToMatrix
(
aTransform
)
;
nscoord
appUnitsPerDevPx
=
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
gfxFloat
pageZoomFactor
=
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
appUnitsPerDevPx
)
;
imageTransform
.
PreScale
(
pageZoomFactor
pageZoomFactor
)
;
}
if
(
imageTransform
.
IsSingular
(
)
)
{
return
false
;
}
aGfxContext
-
>
Multiply
(
ThebesMatrix
(
imageTransform
)
)
;
return
true
;
}
void
SVGImageFrame
:
:
PaintSVG
(
gfxContext
&
aContext
const
gfxMatrix
&
aTransform
imgDrawingParams
&
aImgParams
)
{
if
(
!
StyleVisibility
(
)
-
>
IsVisible
(
)
)
{
return
;
}
float
x
y
width
height
;
SVGImageElement
*
imgElem
=
static_cast
<
SVGImageElement
*
>
(
GetContent
(
)
)
;
SVGGeometryProperty
:
:
ResolveAll
<
SVGT
:
:
X
SVGT
:
:
Y
SVGT
:
:
Width
SVGT
:
:
Height
>
(
imgElem
&
x
&
y
&
width
&
height
)
;
NS_ASSERTION
(
width
>
0
&
&
height
>
0
"
Should
only
be
painting
things
with
valid
width
/
height
"
)
;
if
(
!
mImageContainer
)
{
nsCOMPtr
<
imgIRequest
>
currentRequest
;
nsCOMPtr
<
nsIImageLoadingContent
>
imageLoader
=
do_QueryInterface
(
GetContent
(
)
)
;
if
(
imageLoader
)
imageLoader
-
>
GetRequest
(
nsIImageLoadingContent
:
:
CURRENT_REQUEST
getter_AddRefs
(
currentRequest
)
)
;
if
(
currentRequest
)
currentRequest
-
>
GetImage
(
getter_AddRefs
(
mImageContainer
)
)
;
}
if
(
mImageContainer
)
{
gfxContextAutoSaveRestore
autoRestorer
(
&
aContext
)
;
if
(
StyleDisplay
(
)
-
>
IsScrollableOverflow
(
)
)
{
gfxRect
clipRect
=
SVGUtils
:
:
GetClipRectForFrame
(
this
x
y
width
height
)
;
SVGUtils
:
:
SetClipRect
(
&
aContext
aTransform
clipRect
)
;
}
if
(
!
TransformContextForPainting
(
&
aContext
aTransform
)
)
{
return
;
}
float
opacity
=
1
.
0f
;
if
(
SVGUtils
:
:
CanOptimizeOpacity
(
this
)
)
{
opacity
=
StyleEffects
(
)
-
>
mOpacity
;
}
gfxGroupForBlendAutoSaveRestore
autoGroupForBlend
(
&
aContext
)
;
if
(
opacity
!
=
1
.
0f
|
|
StyleEffects
(
)
-
>
HasMixBlendMode
(
)
)
{
autoGroupForBlend
.
PushGroupForBlendBack
(
gfxContentType
:
:
COLOR_ALPHA
opacity
)
;
}
nscoord
appUnitsPerDevPx
=
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
uint32_t
flags
=
aImgParams
.
imageFlags
;
if
(
mForceSyncDecoding
)
{
flags
|
=
imgIContainer
:
:
FLAG_SYNC_DECODE
;
}
if
(
mImageContainer
-
>
GetType
(
)
=
=
imgIContainer
:
:
TYPE_VECTOR
)
{
const
SVGImageContext
context
(
Some
(
CSSIntSize
:
:
Truncate
(
width
height
)
)
Some
(
imgElem
-
>
mPreserveAspectRatio
.
GetAnimValue
(
)
)
)
;
LayoutDeviceSize
devPxSize
(
width
height
)
;
nsRect
destRect
(
nsPoint
(
)
LayoutDevicePixel
:
:
ToAppUnits
(
devPxSize
appUnitsPerDevPx
)
)
;
aImgParams
.
result
&
=
nsLayoutUtils
:
:
DrawSingleImage
(
aContext
PresContext
(
)
mImageContainer
nsLayoutUtils
:
:
GetSamplingFilterForFrame
(
this
)
destRect
destRect
context
flags
)
;
}
else
{
aImgParams
.
result
&
=
nsLayoutUtils
:
:
DrawSingleUnscaledImage
(
aContext
PresContext
(
)
mImageContainer
nsLayoutUtils
:
:
GetSamplingFilterForFrame
(
this
)
nsPoint
(
0
0
)
nullptr
SVGImageContext
(
)
flags
)
;
}
}
}
void
SVGImageFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
if
(
!
static_cast
<
const
SVGElement
*
>
(
GetContent
(
)
)
-
>
HasValidDimensions
(
)
)
{
return
;
}
if
(
aBuilder
-
>
IsForPainting
(
)
)
{
if
(
!
IsVisibleForPainting
(
)
)
{
return
;
}
if
(
StyleEffects
(
)
-
>
IsTransparent
(
)
)
{
return
;
}
aBuilder
-
>
BuildCompositorHitTestInfoIfNeeded
(
this
aLists
.
BorderBackground
(
)
)
;
}
DisplayOutline
(
aBuilder
aLists
)
;
aLists
.
Content
(
)
-
>
AppendNewToTop
<
DisplaySVGGeometry
>
(
aBuilder
this
)
;
}
bool
SVGImageFrame
:
:
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
mozilla
:
:
layers
:
:
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
DisplaySVGGeometry
*
aItem
bool
aDryRun
)
{
if
(
!
StyleVisibility
(
)
-
>
IsVisible
(
)
)
{
return
true
;
}
float
opacity
=
1
.
0f
;
if
(
SVGUtils
:
:
CanOptimizeOpacity
(
this
)
)
{
opacity
=
StyleEffects
(
)
-
>
mOpacity
;
}
if
(
opacity
!
=
1
.
0f
)
{
return
false
;
}
if
(
StyleEffects
(
)
-
>
HasMixBlendMode
(
)
)
{
return
false
;
}
if
(
!
mImageContainer
)
{
nsCOMPtr
<
imgIRequest
>
currentRequest
;
nsCOMPtr
<
nsIImageLoadingContent
>
imageLoader
=
do_QueryInterface
(
GetContent
(
)
)
;
if
(
imageLoader
)
{
imageLoader
-
>
GetRequest
(
nsIImageLoadingContent
:
:
CURRENT_REQUEST
getter_AddRefs
(
currentRequest
)
)
;
}
if
(
currentRequest
)
{
currentRequest
-
>
GetImage
(
getter_AddRefs
(
mImageContainer
)
)
;
}
}
if
(
!
mImageContainer
)
{
return
true
;
}
uint32_t
flags
=
aDisplayListBuilder
-
>
GetImageDecodeFlags
(
)
;
if
(
mForceSyncDecoding
)
{
flags
|
=
imgIContainer
:
:
FLAG_SYNC_DECODE
;
}
nscoord
appUnitsPerDevPx
=
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
int32_t
appUnitsPerCSSPixel
=
AppUnitsPerCSSPixel
(
)
;
float
x
y
width
height
;
SVGImageElement
*
imgElem
=
static_cast
<
SVGImageElement
*
>
(
GetContent
(
)
)
;
SVGGeometryProperty
:
:
ResolveAll
<
SVGT
:
:
X
SVGT
:
:
Y
SVGT
:
:
Width
SVGT
:
:
Height
>
(
imgElem
&
x
&
y
&
width
&
height
)
;
NS_ASSERTION
(
width
>
0
&
&
height
>
0
"
Should
only
be
painting
things
with
valid
width
/
height
"
)
;
auto
toReferenceFrame
=
aItem
-
>
ToReferenceFrame
(
)
;
auto
appRect
=
nsLayoutUtils
:
:
RoundGfxRectToAppRect
(
Rect
(
0
0
width
height
)
appUnitsPerCSSPixel
)
;
appRect
+
=
toReferenceFrame
;
auto
destRect
=
LayoutDeviceRect
:
:
FromAppUnits
(
appRect
appUnitsPerDevPx
)
;
auto
clipRect
=
destRect
;
if
(
StyleDisplay
(
)
-
>
IsScrollableOverflow
(
)
)
{
auto
cssClip
=
SVGUtils
:
:
GetClipRectForFrame
(
this
0
0
width
height
)
;
auto
appClip
=
nsLayoutUtils
:
:
RoundGfxRectToAppRect
(
cssClip
appUnitsPerCSSPixel
)
;
appClip
+
=
toReferenceFrame
;
clipRect
=
LayoutDeviceRect
:
:
FromAppUnits
(
appClip
appUnitsPerDevPx
)
;
if
(
mImageContainer
-
>
GetType
(
)
=
=
imgIContainer
:
:
TYPE_RASTER
)
{
int32_t
nativeWidth
nativeHeight
;
if
(
NS_FAILED
(
mImageContainer
-
>
GetWidth
(
&
nativeWidth
)
)
|
|
NS_FAILED
(
mImageContainer
-
>
GetHeight
(
&
nativeHeight
)
)
|
|
nativeWidth
=
=
0
|
|
nativeHeight
=
=
0
)
{
return
true
;
}
mImageContainer
-
>
GetResolution
(
)
.
ApplyTo
(
nativeWidth
nativeHeight
)
;
auto
preserveAspectRatio
=
imgElem
-
>
mPreserveAspectRatio
.
GetAnimValue
(
)
;
uint16_t
align
=
preserveAspectRatio
.
GetAlign
(
)
;
uint16_t
meetOrSlice
=
preserveAspectRatio
.
GetMeetOrSlice
(
)
;
if
(
align
=
=
SVG_PRESERVEASPECTRATIO_UNKNOWN
)
{
align
=
SVG_PRESERVEASPECTRATIO_XMIDYMID
;
}
if
(
meetOrSlice
=
=
SVG_MEETORSLICE_UNKNOWN
)
{
meetOrSlice
=
SVG_MEETORSLICE_MEET
;
}
float
nativeAspect
=
(
(
float
)
nativeWidth
)
/
(
(
float
)
nativeHeight
)
;
float
viewAspect
=
width
/
height
;
if
(
align
!
=
SVG_PRESERVEASPECTRATIO_NONE
&
&
nativeAspect
!
=
viewAspect
)
{
bool
tooTall
=
nativeAspect
>
viewAspect
;
bool
tooWide
=
nativeAspect
<
viewAspect
;
if
(
(
meetOrSlice
=
=
SVG_MEETORSLICE_MEET
&
&
tooTall
)
|
|
(
meetOrSlice
=
=
SVG_MEETORSLICE_SLICE
&
&
tooWide
)
)
{
auto
oldHeight
=
destRect
.
height
;
destRect
.
height
=
destRect
.
width
/
nativeAspect
;
auto
heightChange
=
oldHeight
-
destRect
.
height
;
switch
(
align
)
{
case
SVG_PRESERVEASPECTRATIO_XMINYMIN
:
case
SVG_PRESERVEASPECTRATIO_XMIDYMIN
:
case
SVG_PRESERVEASPECTRATIO_XMAXYMIN
:
break
;
case
SVG_PRESERVEASPECTRATIO_XMINYMID
:
case
SVG_PRESERVEASPECTRATIO_XMIDYMID
:
case
SVG_PRESERVEASPECTRATIO_XMAXYMID
:
destRect
.
y
+
=
heightChange
/
2
.
0f
;
break
;
case
SVG_PRESERVEASPECTRATIO_XMINYMAX
:
case
SVG_PRESERVEASPECTRATIO_XMIDYMAX
:
case
SVG_PRESERVEASPECTRATIO_XMAXYMAX
:
destRect
.
y
+
=
heightChange
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
value
for
align
"
)
;
}
}
else
if
(
(
meetOrSlice
=
=
SVG_MEETORSLICE_MEET
&
&
tooWide
)
|
|
(
meetOrSlice
=
=
SVG_MEETORSLICE_SLICE
&
&
tooTall
)
)
{
auto
oldWidth
=
destRect
.
width
;
destRect
.
width
=
destRect
.
height
*
nativeAspect
;
auto
widthChange
=
oldWidth
-
destRect
.
width
;
switch
(
align
)
{
case
SVG_PRESERVEASPECTRATIO_XMINYMIN
:
case
SVG_PRESERVEASPECTRATIO_XMINYMID
:
case
SVG_PRESERVEASPECTRATIO_XMINYMAX
:
break
;
case
SVG_PRESERVEASPECTRATIO_XMIDYMIN
:
case
SVG_PRESERVEASPECTRATIO_XMIDYMID
:
case
SVG_PRESERVEASPECTRATIO_XMIDYMAX
:
destRect
.
x
+
=
widthChange
/
2
.
0f
;
break
;
case
SVG_PRESERVEASPECTRATIO_XMAXYMIN
:
case
SVG_PRESERVEASPECTRATIO_XMAXYMID
:
case
SVG_PRESERVEASPECTRATIO_XMAXYMAX
:
destRect
.
x
+
=
widthChange
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
value
for
align
"
)
;
}
}
}
}
}
SVGImageContext
svgContext
;
if
(
mImageContainer
-
>
GetType
(
)
=
=
imgIContainer
:
:
TYPE_VECTOR
)
{
if
(
StaticPrefs
:
:
image_svg_blob_image
(
)
)
{
flags
|
=
imgIContainer
:
:
FLAG_RECORD_BLOB
;
}
svgContext
.
SetViewportSize
(
Some
(
CSSIntSize
:
:
Truncate
(
width
height
)
)
)
;
svgContext
.
SetPreserveAspectRatio
(
Some
(
imgElem
-
>
mPreserveAspectRatio
.
GetAnimValue
(
)
)
)
;
}
Maybe
<
ImageIntRegion
>
region
;
IntSize
decodeSize
=
nsLayoutUtils
:
:
ComputeImageContainerDrawingParameters
(
mImageContainer
this
destRect
clipRect
aSc
flags
svgContext
region
)
;
RefPtr
<
image
:
:
WebRenderImageProvider
>
provider
;
ImgDrawResult
drawResult
=
mImageContainer
-
>
GetImageProvider
(
aManager
-
>
LayerManager
(
)
decodeSize
svgContext
region
flags
getter_AddRefs
(
provider
)
)
;
switch
(
drawResult
)
{
case
ImgDrawResult
:
:
NOT_READY
:
case
ImgDrawResult
:
:
TEMPORARY_ERROR
:
return
true
;
case
ImgDrawResult
:
:
NOT_SUPPORTED
:
return
false
;
default
:
break
;
}
if
(
!
aDryRun
)
{
if
(
provider
)
{
aManager
-
>
CommandBuilder
(
)
.
PushImageProvider
(
aItem
provider
drawResult
aBuilder
aResources
destRect
clipRect
)
;
}
}
return
true
;
}
nsIFrame
*
SVGImageFrame
:
:
GetFrameForPoint
(
const
gfxPoint
&
aPoint
)
{
if
(
!
HasAnyStateBits
(
NS_STATE_SVG_CLIPPATH_CHILD
)
&
&
!
GetHitTestFlags
(
)
)
{
return
nullptr
;
}
Rect
rect
;
SVGImageElement
*
element
=
static_cast
<
SVGImageElement
*
>
(
GetContent
(
)
)
;
SVGGeometryProperty
:
:
ResolveAll
<
SVGT
:
:
X
SVGT
:
:
Y
SVGT
:
:
Width
SVGT
:
:
Height
>
(
element
&
rect
.
x
&
rect
.
y
&
rect
.
width
&
rect
.
height
)
;
if
(
!
rect
.
Contains
(
ToPoint
(
aPoint
)
)
)
{
return
nullptr
;
}
if
(
StyleDisplay
(
)
-
>
IsScrollableOverflow
(
)
&
&
mImageContainer
)
{
if
(
mImageContainer
-
>
GetType
(
)
=
=
imgIContainer
:
:
TYPE_RASTER
)
{
int32_t
nativeWidth
nativeHeight
;
if
(
NS_FAILED
(
mImageContainer
-
>
GetWidth
(
&
nativeWidth
)
)
|
|
NS_FAILED
(
mImageContainer
-
>
GetHeight
(
&
nativeHeight
)
)
|
|
nativeWidth
=
=
0
|
|
nativeHeight
=
=
0
)
{
return
nullptr
;
}
mImageContainer
-
>
GetResolution
(
)
.
ApplyTo
(
nativeWidth
nativeHeight
)
;
Matrix
viewBoxTM
=
SVGContentUtils
:
:
GetViewBoxTransform
(
rect
.
width
rect
.
height
0
0
nativeWidth
nativeHeight
element
-
>
mPreserveAspectRatio
)
;
if
(
!
SVGUtils
:
:
HitTestRect
(
viewBoxTM
0
0
nativeWidth
nativeHeight
aPoint
.
x
-
rect
.
x
aPoint
.
y
-
rect
.
y
)
)
{
return
nullptr
;
}
}
}
return
this
;
}
void
SVGImageFrame
:
:
ReflowSVG
(
)
{
NS_ASSERTION
(
SVGUtils
:
:
OuterSVGIsCallingReflowSVG
(
this
)
"
This
call
is
probably
a
wasteful
mistake
"
)
;
MOZ_ASSERT
(
!
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
"
ReflowSVG
mechanism
not
designed
for
this
"
)
;
if
(
!
SVGUtils
:
:
NeedsReflowSVG
(
this
)
)
{
return
;
}
float
x
y
width
height
;
SVGImageElement
*
element
=
static_cast
<
SVGImageElement
*
>
(
GetContent
(
)
)
;
SVGGeometryProperty
:
:
ResolveAll
<
SVGT
:
:
X
SVGT
:
:
Y
SVGT
:
:
Width
SVGT
:
:
Height
>
(
element
&
x
&
y
&
width
&
height
)
;
Rect
extent
(
x
y
width
height
)
;
if
(
!
extent
.
IsEmpty
(
)
)
{
mRect
=
nsLayoutUtils
:
:
RoundGfxRectToAppRect
(
extent
AppUnitsPerCSSPixel
(
)
)
;
}
else
{
mRect
.
SetEmpty
(
)
;
}
if
(
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
)
{
SVGObserverUtils
:
:
UpdateEffects
(
this
)
;
if
(
!
mReflowCallbackPosted
)
{
mReflowCallbackPosted
=
true
;
PresShell
(
)
-
>
PostReflowCallback
(
this
)
;
}
}
nsRect
overflow
=
nsRect
(
nsPoint
(
0
0
)
mRect
.
Size
(
)
)
;
OverflowAreas
overflowAreas
(
overflow
overflow
)
;
FinishAndStoreOverflow
(
overflowAreas
mRect
.
Size
(
)
)
;
RemoveStateBits
(
NS_FRAME_FIRST_REFLOW
|
NS_FRAME_IS_DIRTY
|
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
if
(
!
GetParent
(
)
-
>
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
)
{
InvalidateFrame
(
)
;
}
}
bool
SVGImageFrame
:
:
ReflowFinished
(
)
{
mReflowCallbackPosted
=
false
;
UpdateVisibilitySynchronously
(
)
;
return
false
;
}
void
SVGImageFrame
:
:
ReflowCallbackCanceled
(
)
{
mReflowCallbackPosted
=
false
;
}
uint16_t
SVGImageFrame
:
:
GetHitTestFlags
(
)
{
uint16_t
flags
=
0
;
switch
(
Style
(
)
-
>
PointerEvents
(
)
)
{
case
StylePointerEvents
:
:
None
:
break
;
case
StylePointerEvents
:
:
Visiblepainted
:
case
StylePointerEvents
:
:
Auto
:
if
(
StyleVisibility
(
)
-
>
IsVisible
(
)
)
{
flags
|
=
SVG_HIT_TEST_FILL
;
}
break
;
case
StylePointerEvents
:
:
Visiblefill
:
case
StylePointerEvents
:
:
Visiblestroke
:
case
StylePointerEvents
:
:
Visible
:
if
(
StyleVisibility
(
)
-
>
IsVisible
(
)
)
{
flags
|
=
SVG_HIT_TEST_FILL
;
}
break
;
case
StylePointerEvents
:
:
Painted
:
flags
|
=
SVG_HIT_TEST_FILL
;
break
;
case
StylePointerEvents
:
:
Fill
:
case
StylePointerEvents
:
:
Stroke
:
case
StylePointerEvents
:
:
All
:
flags
|
=
SVG_HIT_TEST_FILL
;
break
;
default
:
NS_ERROR
(
"
not
reached
"
)
;
break
;
}
return
flags
;
}
void
SVGImageFrame
:
:
NotifySVGChanged
(
uint32_t
aFlags
)
{
MOZ_ASSERT
(
aFlags
&
(
TRANSFORM_CHANGED
|
COORD_CONTEXT_CHANGED
)
"
Invalidation
logic
may
need
adjusting
"
)
;
}
SVGBBox
SVGImageFrame
:
:
GetBBoxContribution
(
const
Matrix
&
aToBBoxUserspace
uint32_t
aFlags
)
{
if
(
aToBBoxUserspace
.
IsSingular
(
)
)
{
return
{
}
;
}
if
(
(
aFlags
&
SVGUtils
:
:
eForGetClientRects
)
&
&
aToBBoxUserspace
.
PreservesAxisAlignedRectangles
(
)
)
{
Rect
rect
=
NSRectToRect
(
mRect
AppUnitsPerCSSPixel
(
)
)
;
return
aToBBoxUserspace
.
TransformBounds
(
rect
)
;
}
auto
*
element
=
static_cast
<
SVGImageElement
*
>
(
GetContent
(
)
)
;
return
element
-
>
GeometryBounds
(
aToBBoxUserspace
)
;
}
NS_IMPL_ISUPPORTS
(
SVGImageListener
imgINotificationObserver
)
SVGImageListener
:
:
SVGImageListener
(
SVGImageFrame
*
aFrame
)
:
mFrame
(
aFrame
)
{
}
void
SVGImageListener
:
:
Notify
(
imgIRequest
*
aRequest
int32_t
aType
const
nsIntRect
*
aData
)
{
if
(
!
mFrame
)
{
return
;
}
if
(
aType
=
=
imgINotificationObserver
:
:
LOAD_COMPLETE
)
{
mFrame
-
>
InvalidateFrame
(
)
;
nsLayoutUtils
:
:
PostRestyleEvent
(
mFrame
-
>
GetContent
(
)
-
>
AsElement
(
)
RestyleHint
{
0
}
nsChangeHint_InvalidateRenderingObservers
)
;
SVGUtils
:
:
ScheduleReflowSVG
(
mFrame
)
;
}
if
(
aType
=
=
imgINotificationObserver
:
:
FRAME_UPDATE
)
{
nsLayoutUtils
:
:
PostRestyleEvent
(
mFrame
-
>
GetContent
(
)
-
>
AsElement
(
)
RestyleHint
{
0
}
nsChangeHint_InvalidateRenderingObservers
)
;
mFrame
-
>
InvalidateFrame
(
)
;
}
if
(
aType
=
=
imgINotificationObserver
:
:
SIZE_AVAILABLE
)
{
nsCOMPtr
<
imgIContainer
>
image
;
aRequest
-
>
GetImage
(
getter_AddRefs
(
image
)
)
;
if
(
image
)
{
StyleImageOrientation
orientation
=
mFrame
-
>
StyleVisibility
(
)
-
>
UsedImageOrientation
(
aRequest
)
;
image
=
nsLayoutUtils
:
:
OrientImage
(
image
orientation
)
;
image
-
>
SetAnimationMode
(
mFrame
-
>
PresContext
(
)
-
>
ImageAnimationMode
(
)
)
;
mFrame
-
>
mImageContainer
=
std
:
:
move
(
image
)
;
}
mFrame
-
>
InvalidateFrame
(
)
;
nsLayoutUtils
:
:
PostRestyleEvent
(
mFrame
-
>
GetContent
(
)
-
>
AsElement
(
)
RestyleHint
{
0
}
nsChangeHint_InvalidateRenderingObservers
)
;
SVGUtils
:
:
ScheduleReflowSVG
(
mFrame
)
;
}
}
}
