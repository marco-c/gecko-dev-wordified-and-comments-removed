#
include
"
nsSVGEffects
.
h
"
#
include
"
mozilla
/
RestyleManagerHandle
.
h
"
#
include
"
mozilla
/
RestyleManagerHandleInlines
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsSVGClipPathFrame
.
h
"
#
include
"
nsSVGPaintServerFrame
.
h
"
#
include
"
nsSVGPathGeometryElement
.
h
"
#
include
"
nsSVGFilterFrame
.
h
"
#
include
"
nsSVGMaskFrame
.
h
"
#
include
"
nsIReflowCallback
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
SVGUseElement
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
void
nsSVGRenderingObserver
:
:
StartListening
(
)
{
Element
*
target
=
GetTarget
(
)
;
if
(
target
)
{
target
-
>
AddMutationObserver
(
this
)
;
}
}
void
nsSVGRenderingObserver
:
:
StopListening
(
)
{
Element
*
target
=
GetTarget
(
)
;
if
(
target
)
{
target
-
>
RemoveMutationObserver
(
this
)
;
if
(
mInObserverList
)
{
nsSVGEffects
:
:
RemoveRenderingObserver
(
target
this
)
;
mInObserverList
=
false
;
}
}
NS_ASSERTION
(
!
mInObserverList
"
still
in
an
observer
list
?
"
)
;
}
static
nsSVGRenderingObserverList
*
GetObserverList
(
Element
*
aElement
)
{
return
static_cast
<
nsSVGRenderingObserverList
*
>
(
aElement
-
>
GetProperty
(
nsGkAtoms
:
:
renderingobserverlist
)
)
;
}
Element
*
nsSVGRenderingObserver
:
:
GetReferencedElement
(
)
{
Element
*
target
=
GetTarget
(
)
;
#
ifdef
DEBUG
if
(
target
)
{
nsSVGRenderingObserverList
*
observerList
=
GetObserverList
(
target
)
;
bool
inObserverList
=
observerList
&
&
observerList
-
>
Contains
(
this
)
;
NS_ASSERTION
(
inObserverList
=
=
mInObserverList
"
failed
to
track
whether
we
'
re
in
our
referenced
element
'
s
observer
list
!
"
)
;
}
else
{
NS_ASSERTION
(
!
mInObserverList
"
In
whose
observer
list
are
we
then
?
"
)
;
}
#
endif
if
(
target
&
&
!
mInObserverList
)
{
nsSVGEffects
:
:
AddRenderingObserver
(
target
this
)
;
mInObserverList
=
true
;
}
return
target
;
}
nsIFrame
*
nsSVGRenderingObserver
:
:
GetReferencedFrame
(
)
{
Element
*
referencedElement
=
GetReferencedElement
(
)
;
return
referencedElement
?
referencedElement
-
>
GetPrimaryFrame
(
)
:
nullptr
;
}
nsIFrame
*
nsSVGRenderingObserver
:
:
GetReferencedFrame
(
nsIAtom
*
aFrameType
bool
*
aOK
)
{
nsIFrame
*
frame
=
GetReferencedFrame
(
)
;
if
(
frame
)
{
if
(
frame
-
>
GetType
(
)
=
=
aFrameType
)
return
frame
;
if
(
aOK
)
{
*
aOK
=
false
;
}
}
return
nullptr
;
}
void
nsSVGRenderingObserver
:
:
InvalidateViaReferencedElement
(
)
{
mInObserverList
=
false
;
DoUpdate
(
)
;
}
void
nsSVGRenderingObserver
:
:
NotifyEvictedFromRenderingObserverList
(
)
{
mInObserverList
=
false
;
StopListening
(
)
;
}
void
nsSVGRenderingObserver
:
:
AttributeChanged
(
nsIDocument
*
aDocument
dom
:
:
Element
*
aElement
int32_t
aNameSpaceID
nsIAtom
*
aAttribute
int32_t
aModType
const
nsAttrValue
*
aOldValue
)
{
DoUpdate
(
)
;
}
void
nsSVGRenderingObserver
:
:
ContentAppended
(
nsIDocument
*
aDocument
nsIContent
*
aContainer
nsIContent
*
aFirstNewContent
int32_t
)
{
DoUpdate
(
)
;
}
void
nsSVGRenderingObserver
:
:
ContentInserted
(
nsIDocument
*
aDocument
nsIContent
*
aContainer
nsIContent
*
aChild
int32_t
)
{
DoUpdate
(
)
;
}
void
nsSVGRenderingObserver
:
:
ContentRemoved
(
nsIDocument
*
aDocument
nsIContent
*
aContainer
nsIContent
*
aChild
int32_t
aIndexInContainer
nsIContent
*
aPreviousSibling
)
{
DoUpdate
(
)
;
}
nsSVGIDRenderingObserver
:
:
nsSVGIDRenderingObserver
(
nsIURI
*
aURI
nsIContent
*
aObservingContent
bool
aReferenceImage
)
:
mElement
(
this
)
{
mElement
.
Reset
(
aObservingContent
aURI
true
aReferenceImage
)
;
StartListening
(
)
;
}
nsSVGIDRenderingObserver
:
:
~
nsSVGIDRenderingObserver
(
)
{
StopListening
(
)
;
}
void
nsSVGIDRenderingObserver
:
:
DoUpdate
(
)
{
if
(
mElement
.
get
(
)
&
&
mInObserverList
)
{
nsSVGEffects
:
:
RemoveRenderingObserver
(
mElement
.
get
(
)
this
)
;
mInObserverList
=
false
;
}
}
void
nsSVGFrameReferenceFromProperty
:
:
Detach
(
)
{
mFrame
=
nullptr
;
mFramePresShell
=
nullptr
;
}
nsIFrame
*
nsSVGFrameReferenceFromProperty
:
:
Get
(
)
{
if
(
mFramePresShell
&
&
mFramePresShell
-
>
IsDestroying
(
)
)
{
Detach
(
)
;
}
return
mFrame
;
}
NS_IMPL_ISUPPORTS
(
nsSVGRenderingObserverProperty
nsIMutationObserver
)
void
nsSVGRenderingObserverProperty
:
:
DoUpdate
(
)
{
nsSVGIDRenderingObserver
:
:
DoUpdate
(
)
;
nsIFrame
*
frame
=
mFrameReference
.
Get
(
)
;
if
(
frame
&
&
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
)
{
nsLayoutUtils
:
:
PostRestyleEvent
(
frame
-
>
GetContent
(
)
-
>
AsElement
(
)
nsRestyleHint
(
0
)
nsChangeHint_InvalidateRenderingObservers
)
;
}
}
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsSVGFilterReference
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
nsSVGFilterReference
)
NS_IMPL_CYCLE_COLLECTION_CLASS
(
nsSVGFilterReference
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
nsSVGFilterReference
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mElement
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
nsSVGFilterReference
)
tmp
-
>
StopListening
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mElement
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
nsSVGFilterReference
)
NS_INTERFACE_MAP_ENTRY_AMBIGUOUS
(
nsISupports
nsSVGIDRenderingObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsIMutationObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsISVGFilterReference
)
NS_INTERFACE_MAP_END
nsSVGFilterFrame
*
nsSVGFilterReference
:
:
GetFilterFrame
(
)
{
return
static_cast
<
nsSVGFilterFrame
*
>
(
GetReferencedFrame
(
nsGkAtoms
:
:
svgFilterFrame
nullptr
)
)
;
}
void
nsSVGFilterReference
:
:
DoUpdate
(
)
{
nsSVGIDRenderingObserver
:
:
DoUpdate
(
)
;
if
(
mFilterChainObserver
)
{
mFilterChainObserver
-
>
Invalidate
(
)
;
}
}
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
nsSVGFilterChainObserver
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
nsSVGFilterChainObserver
)
NS_IMPL_CYCLE_COLLECTION_CLASS
(
nsSVGFilterChainObserver
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
nsSVGFilterChainObserver
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mReferences
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
nsSVGFilterChainObserver
)
tmp
-
>
DetachReferences
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mReferences
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
nsSVGFilterChainObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
nsSVGFilterChainObserver
:
:
nsSVGFilterChainObserver
(
const
nsTArray
<
nsStyleFilter
>
&
aFilters
nsIContent
*
aFilteredElement
nsIFrame
*
aFilteredFrame
)
{
for
(
uint32_t
i
=
0
;
i
<
aFilters
.
Length
(
)
;
i
+
+
)
{
if
(
aFilters
[
i
]
.
GetType
(
)
!
=
NS_STYLE_FILTER_URL
)
continue
;
nsCOMPtr
<
nsIURI
>
filterURL
=
aFilteredFrame
?
nsSVGEffects
:
:
GetFilterURI
(
aFilteredFrame
i
)
:
aFilters
[
i
]
.
GetURL
(
)
-
>
Resolve
(
aFilteredElement
)
;
RefPtr
<
nsSVGFilterReference
>
reference
=
new
nsSVGFilterReference
(
filterURL
aFilteredElement
this
)
;
mReferences
.
AppendElement
(
reference
)
;
}
}
nsSVGFilterChainObserver
:
:
~
nsSVGFilterChainObserver
(
)
{
DetachReferences
(
)
;
}
bool
nsSVGFilterChainObserver
:
:
ReferencesValidResources
(
)
{
for
(
uint32_t
i
=
0
;
i
<
mReferences
.
Length
(
)
;
i
+
+
)
{
if
(
!
mReferences
[
i
]
-
>
ReferencesValidResource
(
)
)
return
false
;
}
return
true
;
}
bool
nsSVGFilterChainObserver
:
:
IsInObserverLists
(
)
const
{
for
(
uint32_t
i
=
0
;
i
<
mReferences
.
Length
(
)
;
i
+
+
)
{
if
(
!
mReferences
[
i
]
-
>
IsInObserverList
(
)
)
return
false
;
}
return
true
;
}
void
nsSVGFilterProperty
:
:
DoUpdate
(
)
{
nsIFrame
*
frame
=
mFrameReference
.
Get
(
)
;
if
(
!
frame
)
return
;
nsChangeHint
changeHint
=
nsChangeHint
(
nsChangeHint_RepaintFrame
)
;
if
(
frame
&
&
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
)
{
changeHint
|
=
nsChangeHint_InvalidateRenderingObservers
;
}
if
(
!
(
frame
-
>
GetStateBits
(
)
&
NS_FRAME_IN_REFLOW
)
)
{
changeHint
|
=
nsChangeHint_UpdateOverflow
;
}
frame
-
>
PresContext
(
)
-
>
RestyleManager
(
)
-
>
PostRestyleEvent
(
frame
-
>
GetContent
(
)
-
>
AsElement
(
)
nsRestyleHint
(
0
)
changeHint
)
;
}
void
nsSVGMarkerProperty
:
:
DoUpdate
(
)
{
nsSVGRenderingObserverProperty
:
:
DoUpdate
(
)
;
nsIFrame
*
frame
=
mFrameReference
.
Get
(
)
;
if
(
!
frame
)
return
;
NS_ASSERTION
(
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
"
SVG
frame
expected
"
)
;
nsChangeHint
changeHint
=
nsChangeHint
(
nsChangeHint_RepaintFrame
)
;
if
(
!
(
frame
-
>
GetStateBits
(
)
&
NS_FRAME_IN_REFLOW
)
)
{
changeHint
|
=
nsChangeHint_InvalidateRenderingObservers
;
nsSVGUtils
:
:
ScheduleReflowSVG
(
frame
)
;
}
frame
-
>
PresContext
(
)
-
>
RestyleManager
(
)
-
>
PostRestyleEvent
(
frame
-
>
GetContent
(
)
-
>
AsElement
(
)
nsRestyleHint
(
0
)
changeHint
)
;
}
NS_IMPL_ISUPPORTS
(
nsSVGMaskProperty
nsISupports
)
nsSVGMaskProperty
:
:
nsSVGMaskProperty
(
nsIFrame
*
aFrame
)
{
const
nsStyleSVGReset
*
svgReset
=
aFrame
-
>
StyleSVGReset
(
)
;
for
(
uint32_t
i
=
0
;
i
<
svgReset
-
>
mMask
.
mImageCount
;
i
+
+
)
{
nsSVGPaintingProperty
*
prop
=
new
nsSVGPaintingProperty
(
svgReset
-
>
mMask
.
mLayers
[
i
]
.
mSourceURI
aFrame
false
)
;
mProperties
.
AppendElement
(
prop
)
;
}
}
bool
nsSVGTextPathProperty
:
:
TargetIsValid
(
)
{
Element
*
target
=
GetTarget
(
)
;
return
target
&
&
target
-
>
IsSVGElement
(
nsGkAtoms
:
:
path
)
;
}
void
nsSVGTextPathProperty
:
:
DoUpdate
(
)
{
nsSVGRenderingObserverProperty
:
:
DoUpdate
(
)
;
nsIFrame
*
frame
=
mFrameReference
.
Get
(
)
;
if
(
!
frame
)
return
;
NS_ASSERTION
(
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
|
|
frame
-
>
IsSVGText
(
)
"
SVG
frame
expected
"
)
;
bool
nowValid
=
TargetIsValid
(
)
;
if
(
!
mValid
&
&
!
nowValid
)
{
return
;
}
mValid
=
nowValid
;
nsChangeHint
changeHint
=
nsChangeHint
(
nsChangeHint_RepaintFrame
|
nsChangeHint_UpdateTextPath
)
;
frame
-
>
PresContext
(
)
-
>
RestyleManager
(
)
-
>
PostRestyleEvent
(
frame
-
>
GetContent
(
)
-
>
AsElement
(
)
nsRestyleHint
(
0
)
changeHint
)
;
}
static
void
InvalidateAllContinuations
(
nsIFrame
*
aFrame
)
{
for
(
nsIFrame
*
f
=
aFrame
;
f
;
f
=
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
f
)
)
{
f
-
>
InvalidateFrame
(
)
;
}
}
void
nsSVGPaintingProperty
:
:
DoUpdate
(
)
{
nsSVGRenderingObserverProperty
:
:
DoUpdate
(
)
;
nsIFrame
*
frame
=
mFrameReference
.
Get
(
)
;
if
(
!
frame
)
return
;
if
(
frame
-
>
GetStateBits
(
)
&
NS_FRAME_SVG_LAYOUT
)
{
nsLayoutUtils
:
:
PostRestyleEvent
(
frame
-
>
GetContent
(
)
-
>
AsElement
(
)
nsRestyleHint
(
0
)
nsChangeHint_InvalidateRenderingObservers
)
;
frame
-
>
InvalidateFrameSubtree
(
)
;
}
else
{
InvalidateAllContinuations
(
frame
)
;
}
}
static
nsSVGFilterProperty
*
GetOrCreateFilterProperty
(
nsIFrame
*
aFrame
)
{
const
nsStyleEffects
*
effects
=
aFrame
-
>
StyleEffects
(
)
;
if
(
!
effects
-
>
HasFilters
(
)
)
return
nullptr
;
FrameProperties
props
=
aFrame
-
>
Properties
(
)
;
nsSVGFilterProperty
*
prop
=
props
.
Get
(
nsSVGEffects
:
:
FilterProperty
(
)
)
;
if
(
prop
)
return
prop
;
prop
=
new
nsSVGFilterProperty
(
effects
-
>
mFilters
aFrame
)
;
NS_ADDREF
(
prop
)
;
props
.
Set
(
nsSVGEffects
:
:
FilterProperty
(
)
prop
)
;
return
prop
;
}
static
nsSVGMaskProperty
*
GetOrCreateMaskProperty
(
nsIFrame
*
aFrame
)
{
FrameProperties
props
=
aFrame
-
>
Properties
(
)
;
nsSVGMaskProperty
*
prop
=
props
.
Get
(
nsSVGEffects
:
:
MaskProperty
(
)
)
;
if
(
prop
)
return
prop
;
prop
=
new
nsSVGMaskProperty
(
aFrame
)
;
NS_ADDREF
(
prop
)
;
props
.
Set
(
nsSVGEffects
:
:
MaskProperty
(
)
prop
)
;
return
prop
;
}
template
<
class
T
>
static
T
*
GetEffectProperty
(
nsIURI
*
aURI
nsIFrame
*
aFrame
const
mozilla
:
:
FramePropertyDescriptor
<
T
>
*
aProperty
)
{
if
(
!
aURI
)
return
nullptr
;
FrameProperties
props
=
aFrame
-
>
Properties
(
)
;
T
*
prop
=
props
.
Get
(
aProperty
)
;
if
(
prop
)
return
prop
;
prop
=
new
T
(
aURI
aFrame
false
)
;
NS_ADDREF
(
prop
)
;
props
.
Set
(
aProperty
prop
)
;
return
prop
;
}
nsSVGMarkerProperty
*
nsSVGEffects
:
:
GetMarkerProperty
(
nsIURI
*
aURI
nsIFrame
*
aFrame
const
mozilla
:
:
FramePropertyDescriptor
<
nsSVGMarkerProperty
>
*
aProperty
)
{
MOZ_ASSERT
(
aFrame
-
>
GetType
(
)
=
=
nsGkAtoms
:
:
svgPathGeometryFrame
&
&
static_cast
<
nsSVGPathGeometryElement
*
>
(
aFrame
-
>
GetContent
(
)
)
-
>
IsMarkable
(
)
"
Bad
frame
"
)
;
return
GetEffectProperty
(
aURI
aFrame
aProperty
)
;
}
nsSVGTextPathProperty
*
nsSVGEffects
:
:
GetTextPathProperty
(
nsIURI
*
aURI
nsIFrame
*
aFrame
const
mozilla
:
:
FramePropertyDescriptor
<
nsSVGTextPathProperty
>
*
aProperty
)
{
return
GetEffectProperty
(
aURI
aFrame
aProperty
)
;
}
nsSVGPaintingProperty
*
nsSVGEffects
:
:
GetPaintingProperty
(
nsIURI
*
aURI
nsIFrame
*
aFrame
const
mozilla
:
:
FramePropertyDescriptor
<
nsSVGPaintingProperty
>
*
aProperty
)
{
return
GetEffectProperty
(
aURI
aFrame
aProperty
)
;
}
nsSVGPaintingProperty
*
nsSVGEffects
:
:
GetPaintingPropertyForURI
(
nsIURI
*
aURI
nsIFrame
*
aFrame
URIObserverHashtablePropertyDescriptor
aProperty
)
{
if
(
!
aURI
)
return
nullptr
;
FrameProperties
props
=
aFrame
-
>
Properties
(
)
;
nsSVGEffects
:
:
URIObserverHashtable
*
hashtable
=
props
.
Get
(
aProperty
)
;
if
(
!
hashtable
)
{
hashtable
=
new
nsSVGEffects
:
:
URIObserverHashtable
(
)
;
props
.
Set
(
aProperty
hashtable
)
;
}
nsSVGPaintingProperty
*
prop
=
static_cast
<
nsSVGPaintingProperty
*
>
(
hashtable
-
>
GetWeak
(
aURI
)
)
;
if
(
!
prop
)
{
bool
watchImage
=
aProperty
=
=
nsSVGEffects
:
:
BackgroundImageProperty
(
)
;
prop
=
new
nsSVGPaintingProperty
(
aURI
aFrame
watchImage
)
;
hashtable
-
>
Put
(
aURI
prop
)
;
}
return
prop
;
}
nsSVGEffects
:
:
EffectProperties
nsSVGEffects
:
:
GetEffectProperties
(
nsIFrame
*
aFrame
)
{
NS_ASSERTION
(
!
aFrame
-
>
GetPrevContinuation
(
)
"
aFrame
should
be
first
continuation
"
)
;
EffectProperties
result
;
const
nsStyleSVGReset
*
style
=
aFrame
-
>
StyleSVGReset
(
)
;
result
.
mFilter
=
GetOrCreateFilterProperty
(
aFrame
)
;
if
(
style
-
>
mClipPath
.
GetType
(
)
=
=
StyleClipPathType
:
:
URL
)
{
nsCOMPtr
<
nsIURI
>
pathURI
=
nsSVGEffects
:
:
GetClipPathURI
(
aFrame
)
;
result
.
mClipPath
=
GetPaintingProperty
(
pathURI
aFrame
ClipPathProperty
(
)
)
;
}
else
{
result
.
mClipPath
=
nullptr
;
}
MOZ_ASSERT
(
style
-
>
mMask
.
mImageCount
>
0
)
;
result
.
mMask
=
style
-
>
mMask
.
HasLayerWithImage
(
)
?
GetOrCreateMaskProperty
(
aFrame
)
:
nullptr
;
return
result
;
}
nsSVGPaintServerFrame
*
nsSVGEffects
:
:
GetPaintServer
(
nsIFrame
*
aTargetFrame
nsStyleSVGPaint
nsStyleSVG
:
:
*
aPaint
PaintingPropertyDescriptor
aType
)
{
const
nsStyleSVG
*
svgStyle
=
aTargetFrame
-
>
StyleSVG
(
)
;
if
(
(
svgStyle
-
>
*
aPaint
)
.
mType
!
=
eStyleSVGPaintType_Server
)
return
nullptr
;
nsIFrame
*
frame
=
aTargetFrame
;
if
(
frame
-
>
GetContent
(
)
-
>
IsNodeOfType
(
nsINode
:
:
eTEXT
)
)
{
frame
=
frame
-
>
GetParent
(
)
;
nsIFrame
*
grandparent
=
frame
-
>
GetParent
(
)
;
if
(
grandparent
&
&
grandparent
-
>
GetType
(
)
=
=
nsGkAtoms
:
:
svgTextFrame
)
{
frame
=
grandparent
;
}
}
nsCOMPtr
<
nsIURI
>
paintServerURL
=
nsSVGEffects
:
:
GetPaintURI
(
frame
aPaint
)
;
nsSVGPaintingProperty
*
property
=
nsSVGEffects
:
:
GetPaintingProperty
(
paintServerURL
frame
aType
)
;
if
(
!
property
)
return
nullptr
;
nsIFrame
*
result
=
property
-
>
GetReferencedFrame
(
)
;
if
(
!
result
)
return
nullptr
;
nsIAtom
*
type
=
result
-
>
GetType
(
)
;
if
(
type
!
=
nsGkAtoms
:
:
svgLinearGradientFrame
&
&
type
!
=
nsGkAtoms
:
:
svgRadialGradientFrame
&
&
type
!
=
nsGkAtoms
:
:
svgPatternFrame
)
return
nullptr
;
return
static_cast
<
nsSVGPaintServerFrame
*
>
(
result
)
;
}
nsSVGClipPathFrame
*
nsSVGEffects
:
:
EffectProperties
:
:
GetClipPathFrame
(
bool
*
aOK
)
{
if
(
!
mClipPath
)
return
nullptr
;
nsSVGClipPathFrame
*
frame
=
static_cast
<
nsSVGClipPathFrame
*
>
(
mClipPath
-
>
GetReferencedFrame
(
nsGkAtoms
:
:
svgClipPathFrame
aOK
)
)
;
if
(
frame
&
&
aOK
&
&
*
aOK
)
{
*
aOK
=
frame
-
>
IsValid
(
)
;
}
return
frame
;
}
nsSVGMaskFrame
*
nsSVGEffects
:
:
EffectProperties
:
:
GetFirstMaskFrame
(
bool
*
aOK
)
{
if
(
!
mMask
)
{
return
nullptr
;
}
const
nsTArray
<
RefPtr
<
nsSVGPaintingProperty
>
>
&
props
=
mMask
-
>
GetProps
(
)
;
if
(
props
.
IsEmpty
(
)
)
{
return
nullptr
;
}
return
static_cast
<
nsSVGMaskFrame
*
>
(
props
[
0
]
-
>
GetReferencedFrame
(
nsGkAtoms
:
:
svgMaskFrame
aOK
)
)
;
}
nsTArray
<
nsSVGMaskFrame
*
>
nsSVGEffects
:
:
EffectProperties
:
:
GetMaskFrames
(
)
{
nsTArray
<
nsSVGMaskFrame
*
>
result
;
if
(
!
mMask
)
return
result
;
bool
ok
=
false
;
const
nsTArray
<
RefPtr
<
nsSVGPaintingProperty
>
>
&
props
=
mMask
-
>
GetProps
(
)
;
for
(
size_t
i
=
0
;
i
<
props
.
Length
(
)
;
i
+
+
)
{
nsSVGMaskFrame
*
maskFrame
=
static_cast
<
nsSVGMaskFrame
*
>
(
props
[
i
]
-
>
GetReferencedFrame
(
nsGkAtoms
:
:
svgMaskFrame
&
ok
)
)
;
result
.
AppendElement
(
maskFrame
)
;
}
return
result
;
}
void
nsSVGEffects
:
:
UpdateEffects
(
nsIFrame
*
aFrame
)
{
NS_ASSERTION
(
aFrame
-
>
GetContent
(
)
-
>
IsElement
(
)
"
aFrame
'
s
content
should
be
an
element
"
)
;
FrameProperties
props
=
aFrame
-
>
Properties
(
)
;
props
.
Delete
(
FilterProperty
(
)
)
;
props
.
Delete
(
MaskProperty
(
)
)
;
props
.
Delete
(
ClipPathProperty
(
)
)
;
props
.
Delete
(
MarkerBeginProperty
(
)
)
;
props
.
Delete
(
MarkerMiddleProperty
(
)
)
;
props
.
Delete
(
MarkerEndProperty
(
)
)
;
props
.
Delete
(
FillProperty
(
)
)
;
props
.
Delete
(
StrokeProperty
(
)
)
;
props
.
Delete
(
BackgroundImageProperty
(
)
)
;
GetOrCreateFilterProperty
(
aFrame
)
;
if
(
aFrame
-
>
GetType
(
)
=
=
nsGkAtoms
:
:
svgPathGeometryFrame
&
&
static_cast
<
nsSVGPathGeometryElement
*
>
(
aFrame
-
>
GetContent
(
)
)
-
>
IsMarkable
(
)
)
{
nsCOMPtr
<
nsIURI
>
markerURL
=
nsSVGEffects
:
:
GetMarkerURI
(
aFrame
&
nsStyleSVG
:
:
mMarkerStart
)
;
GetMarkerProperty
(
markerURL
aFrame
MarkerBeginProperty
(
)
)
;
markerURL
=
nsSVGEffects
:
:
GetMarkerURI
(
aFrame
&
nsStyleSVG
:
:
mMarkerMid
)
;
GetMarkerProperty
(
markerURL
aFrame
MarkerMiddleProperty
(
)
)
;
markerURL
=
nsSVGEffects
:
:
GetMarkerURI
(
aFrame
&
nsStyleSVG
:
:
mMarkerEnd
)
;
GetMarkerProperty
(
markerURL
aFrame
MarkerEndProperty
(
)
)
;
}
}
nsSVGFilterProperty
*
nsSVGEffects
:
:
GetFilterProperty
(
nsIFrame
*
aFrame
)
{
NS_ASSERTION
(
!
aFrame
-
>
GetPrevContinuation
(
)
"
aFrame
should
be
first
continuation
"
)
;
if
(
!
aFrame
-
>
StyleEffects
(
)
-
>
HasFilters
(
)
)
return
nullptr
;
return
aFrame
-
>
Properties
(
)
.
Get
(
FilterProperty
(
)
)
;
}
void
nsSVGRenderingObserverList
:
:
InvalidateAll
(
)
{
if
(
mObservers
.
Count
(
)
=
=
0
)
return
;
AutoTArray
<
nsSVGRenderingObserver
*
10
>
observers
;
for
(
auto
it
=
mObservers
.
Iter
(
)
;
!
it
.
Done
(
)
;
it
.
Next
(
)
)
{
observers
.
AppendElement
(
it
.
Get
(
)
-
>
GetKey
(
)
)
;
}
mObservers
.
Clear
(
)
;
for
(
uint32_t
i
=
0
;
i
<
observers
.
Length
(
)
;
+
+
i
)
{
observers
[
i
]
-
>
InvalidateViaReferencedElement
(
)
;
}
}
void
nsSVGRenderingObserverList
:
:
InvalidateAllForReflow
(
)
{
if
(
mObservers
.
Count
(
)
=
=
0
)
return
;
AutoTArray
<
nsSVGRenderingObserver
*
10
>
observers
;
for
(
auto
it
=
mObservers
.
Iter
(
)
;
!
it
.
Done
(
)
;
it
.
Next
(
)
)
{
nsSVGRenderingObserver
*
obs
=
it
.
Get
(
)
-
>
GetKey
(
)
;
if
(
obs
-
>
ObservesReflow
(
)
)
{
observers
.
AppendElement
(
obs
)
;
it
.
Remove
(
)
;
}
}
for
(
uint32_t
i
=
0
;
i
<
observers
.
Length
(
)
;
+
+
i
)
{
observers
[
i
]
-
>
InvalidateViaReferencedElement
(
)
;
}
}
void
nsSVGRenderingObserverList
:
:
RemoveAll
(
)
{
AutoTArray
<
nsSVGRenderingObserver
*
10
>
observers
;
for
(
auto
it
=
mObservers
.
Iter
(
)
;
!
it
.
Done
(
)
;
it
.
Next
(
)
)
{
observers
.
AppendElement
(
it
.
Get
(
)
-
>
GetKey
(
)
)
;
}
mObservers
.
Clear
(
)
;
for
(
uint32_t
i
=
0
;
i
<
observers
.
Length
(
)
;
+
+
i
)
{
observers
[
i
]
-
>
NotifyEvictedFromRenderingObserverList
(
)
;
}
}
void
nsSVGEffects
:
:
AddRenderingObserver
(
Element
*
aElement
nsSVGRenderingObserver
*
aObserver
)
{
nsSVGRenderingObserverList
*
observerList
=
GetObserverList
(
aElement
)
;
if
(
!
observerList
)
{
observerList
=
new
nsSVGRenderingObserverList
(
)
;
if
(
!
observerList
)
return
;
aElement
-
>
SetProperty
(
nsGkAtoms
:
:
renderingobserverlist
observerList
nsINode
:
:
DeleteProperty
<
nsSVGRenderingObserverList
>
)
;
}
aElement
-
>
SetHasRenderingObservers
(
true
)
;
observerList
-
>
Add
(
aObserver
)
;
}
void
nsSVGEffects
:
:
RemoveRenderingObserver
(
Element
*
aElement
nsSVGRenderingObserver
*
aObserver
)
{
nsSVGRenderingObserverList
*
observerList
=
GetObserverList
(
aElement
)
;
if
(
observerList
)
{
NS_ASSERTION
(
observerList
-
>
Contains
(
aObserver
)
"
removing
observer
from
an
element
we
'
re
not
observing
?
"
)
;
observerList
-
>
Remove
(
aObserver
)
;
if
(
observerList
-
>
IsEmpty
(
)
)
{
aElement
-
>
SetHasRenderingObservers
(
false
)
;
}
}
}
void
nsSVGEffects
:
:
RemoveAllRenderingObservers
(
Element
*
aElement
)
{
nsSVGRenderingObserverList
*
observerList
=
GetObserverList
(
aElement
)
;
if
(
observerList
)
{
observerList
-
>
RemoveAll
(
)
;
aElement
-
>
SetHasRenderingObservers
(
false
)
;
}
}
void
nsSVGEffects
:
:
InvalidateRenderingObservers
(
nsIFrame
*
aFrame
)
{
NS_ASSERTION
(
!
aFrame
-
>
GetPrevContinuation
(
)
"
aFrame
must
be
first
continuation
"
)
;
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
!
content
|
|
!
content
-
>
IsElement
(
)
)
return
;
aFrame
-
>
Properties
(
)
.
Delete
(
nsSVGUtils
:
:
ObjectBoundingBoxProperty
(
)
)
;
nsSVGRenderingObserverList
*
observerList
=
GetObserverList
(
content
-
>
AsElement
(
)
)
;
if
(
observerList
)
{
observerList
-
>
InvalidateAll
(
)
;
return
;
}
for
(
nsIFrame
*
f
=
aFrame
-
>
GetParent
(
)
;
f
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVGContainer
)
;
f
=
f
-
>
GetParent
(
)
)
{
if
(
f
-
>
GetContent
(
)
-
>
IsElement
(
)
)
{
observerList
=
GetObserverList
(
f
-
>
GetContent
(
)
-
>
AsElement
(
)
)
;
if
(
observerList
)
{
observerList
-
>
InvalidateAll
(
)
;
return
;
}
}
}
}
void
nsSVGEffects
:
:
InvalidateDirectRenderingObservers
(
Element
*
aElement
uint32_t
aFlags
)
{
nsIFrame
*
frame
=
aElement
-
>
GetPrimaryFrame
(
)
;
if
(
frame
)
{
frame
-
>
Properties
(
)
.
Delete
(
nsSVGUtils
:
:
ObjectBoundingBoxProperty
(
)
)
;
}
if
(
aElement
-
>
HasRenderingObservers
(
)
)
{
nsSVGRenderingObserverList
*
observerList
=
GetObserverList
(
aElement
)
;
if
(
observerList
)
{
if
(
aFlags
&
INVALIDATE_REFLOW
)
{
observerList
-
>
InvalidateAllForReflow
(
)
;
}
else
{
observerList
-
>
InvalidateAll
(
)
;
}
}
}
}
void
nsSVGEffects
:
:
InvalidateDirectRenderingObservers
(
nsIFrame
*
aFrame
uint32_t
aFlags
)
{
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
content
&
&
content
-
>
IsElement
(
)
)
{
InvalidateDirectRenderingObservers
(
content
-
>
AsElement
(
)
aFlags
)
;
}
}
static
already_AddRefed
<
nsIURI
>
ResolveFragmentOrURL
(
nsIFrame
*
aFrame
const
FragmentOrURL
*
aFragmentOrURL
)
{
MOZ_ASSERT
(
aFrame
)
;
if
(
!
aFragmentOrURL
)
{
return
nullptr
;
}
if
(
!
aFragmentOrURL
-
>
IsLocalRef
(
)
)
{
nsCOMPtr
<
nsIURI
>
result
=
aFragmentOrURL
-
>
GetSourceURL
(
)
;
return
result
.
forget
(
)
;
}
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
nsCOMPtr
<
nsIURI
>
baseURI
=
content
-
>
GetBaseURI
(
)
;
if
(
content
-
>
IsInAnonymousSubtree
(
)
)
{
if
(
!
aFragmentOrURL
-
>
EqualsExceptRef
(
baseURI
)
)
baseURI
=
content
-
>
OwnerDoc
(
)
-
>
GetBaseURI
(
)
;
}
return
aFragmentOrURL
-
>
Resolve
(
baseURI
)
;
}
already_AddRefed
<
nsIURI
>
nsSVGEffects
:
:
GetMarkerURI
(
nsIFrame
*
aFrame
FragmentOrURL
nsStyleSVG
:
:
*
aMarker
)
{
return
ResolveFragmentOrURL
(
aFrame
&
(
aFrame
-
>
StyleSVG
(
)
-
>
*
aMarker
)
)
;
}
already_AddRefed
<
nsIURI
>
nsSVGEffects
:
:
GetClipPathURI
(
nsIFrame
*
aFrame
)
{
const
nsStyleSVGReset
*
svgResetStyle
=
aFrame
-
>
StyleSVGReset
(
)
;
MOZ_ASSERT
(
svgResetStyle
-
>
mClipPath
.
GetType
(
)
=
=
StyleClipPathType
:
:
URL
)
;
FragmentOrURL
*
url
=
svgResetStyle
-
>
mClipPath
.
GetURL
(
)
;
return
ResolveFragmentOrURL
(
aFrame
url
)
;
}
already_AddRefed
<
nsIURI
>
nsSVGEffects
:
:
GetFilterURI
(
nsIFrame
*
aFrame
uint32_t
aIndex
)
{
const
nsStyleEffects
*
effects
=
aFrame
-
>
StyleEffects
(
)
;
MOZ_ASSERT
(
effects
-
>
mFilters
.
Length
(
)
>
aIndex
)
;
MOZ_ASSERT
(
effects
-
>
mFilters
[
aIndex
]
.
GetType
(
)
=
=
NS_STYLE_FILTER_URL
)
;
return
ResolveFragmentOrURL
(
aFrame
effects
-
>
mFilters
[
aIndex
]
.
GetURL
(
)
)
;
}
already_AddRefed
<
nsIURI
>
nsSVGEffects
:
:
GetFilterURI
(
nsIFrame
*
aFrame
const
nsStyleFilter
&
aFilter
)
{
MOZ_ASSERT
(
aFrame
-
>
StyleEffects
(
)
-
>
mFilters
.
Length
(
)
)
;
MOZ_ASSERT
(
aFilter
.
GetType
(
)
=
=
NS_STYLE_FILTER_URL
)
;
return
ResolveFragmentOrURL
(
aFrame
aFilter
.
GetURL
(
)
)
;
}
already_AddRefed
<
nsIURI
>
nsSVGEffects
:
:
GetPaintURI
(
nsIFrame
*
aFrame
nsStyleSVGPaint
nsStyleSVG
:
:
*
aPaint
)
{
const
nsStyleSVG
*
svgStyle
=
aFrame
-
>
StyleSVG
(
)
;
MOZ_ASSERT
(
(
svgStyle
-
>
*
aPaint
)
.
mType
=
=
nsStyleSVGPaintType
:
:
eStyleSVGPaintType_Server
)
;
return
ResolveFragmentOrURL
(
aFrame
(
svgStyle
-
>
*
aPaint
)
.
mPaint
.
mPaintServer
)
;
}
