#
include
"
SVGViewportFrame
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
mozilla
/
ISVGDisplayableFrame
.
h
"
#
include
"
mozilla
/
SVGContainerFrame
.
h
"
#
include
"
mozilla
/
SVGUtils
.
h
"
#
include
"
mozilla
/
dom
/
SVGViewportElement
.
h
"
#
include
"
nsLayoutUtils
.
h
"
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
image
;
namespace
mozilla
{
void
SVGViewportFrame
:
:
PaintSVG
(
gfxContext
&
aContext
const
gfxMatrix
&
aTransform
imgDrawingParams
&
aImgParams
)
{
NS_ASSERTION
(
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
"
Only
painting
of
non
-
display
SVG
should
take
this
code
path
"
)
;
gfxClipAutoSaveRestore
autoSaveClip
(
&
aContext
)
;
if
(
StyleDisplay
(
)
-
>
IsScrollableOverflow
(
)
)
{
float
x
y
width
height
;
static_cast
<
SVGViewportElement
*
>
(
GetContent
(
)
)
-
>
GetAnimatedLengthValues
(
&
x
&
y
&
width
&
height
nullptr
)
;
if
(
width
<
=
0
|
|
height
<
=
0
)
{
return
;
}
gfxRect
clipRect
=
SVGUtils
:
:
GetClipRectForFrame
(
this
x
y
width
height
)
;
autoSaveClip
.
TransformedClip
(
aTransform
clipRect
)
;
}
SVGDisplayContainerFrame
:
:
PaintSVG
(
aContext
aTransform
aImgParams
)
;
}
void
SVGViewportFrame
:
:
ReflowSVG
(
)
{
float
x
y
width
height
;
static_cast
<
SVGViewportElement
*
>
(
GetContent
(
)
)
-
>
GetAnimatedLengthValues
(
&
x
&
y
&
width
&
height
nullptr
)
;
mRect
=
nsLayoutUtils
:
:
RoundGfxRectToAppRect
(
gfxRect
(
x
y
width
height
)
AppUnitsPerCSSPixel
(
)
)
;
if
(
StyleEffects
(
)
-
>
HasFilters
(
)
)
{
InvalidateFrame
(
)
;
}
SVGDisplayContainerFrame
:
:
ReflowSVG
(
)
;
}
void
SVGViewportFrame
:
:
NotifySVGChanged
(
uint32_t
aFlags
)
{
MOZ_ASSERT
(
aFlags
&
(
TRANSFORM_CHANGED
|
COORD_CONTEXT_CHANGED
)
"
Invalidation
logic
may
need
adjusting
"
)
;
if
(
aFlags
&
COORD_CONTEXT_CHANGED
)
{
SVGViewportElement
*
svg
=
static_cast
<
SVGViewportElement
*
>
(
GetContent
(
)
)
;
bool
xOrYIsPercentage
=
svg
-
>
mLengthAttributes
[
SVGViewportElement
:
:
ATTR_X
]
.
IsPercentage
(
)
|
|
svg
-
>
mLengthAttributes
[
SVGViewportElement
:
:
ATTR_Y
]
.
IsPercentage
(
)
;
bool
widthOrHeightIsPercentage
=
svg
-
>
mLengthAttributes
[
SVGViewportElement
:
:
ATTR_WIDTH
]
.
IsPercentage
(
)
|
|
svg
-
>
mLengthAttributes
[
SVGViewportElement
:
:
ATTR_HEIGHT
]
.
IsPercentage
(
)
;
if
(
xOrYIsPercentage
|
|
widthOrHeightIsPercentage
)
{
SVGUtils
:
:
ScheduleReflowSVG
(
this
)
;
}
if
(
!
(
aFlags
&
TRANSFORM_CHANGED
)
&
&
(
xOrYIsPercentage
|
|
(
widthOrHeightIsPercentage
&
&
svg
-
>
HasViewBox
(
)
)
)
)
{
aFlags
|
=
TRANSFORM_CHANGED
;
}
if
(
svg
-
>
HasViewBox
(
)
|
|
!
widthOrHeightIsPercentage
)
{
aFlags
&
=
~
COORD_CONTEXT_CHANGED
;
if
(
!
aFlags
)
{
return
;
}
}
}
SVGDisplayContainerFrame
:
:
NotifySVGChanged
(
aFlags
)
;
}
SVGBBox
SVGViewportFrame
:
:
GetBBoxContribution
(
const
Matrix
&
aToBBoxUserspace
uint32_t
aFlags
)
{
SVGBBox
bbox
;
if
(
aFlags
&
SVGUtils
:
:
eForGetClientRects
)
{
float
x
y
w
h
;
static_cast
<
SVGViewportElement
*
>
(
GetContent
(
)
)
-
>
GetAnimatedLengthValues
(
&
x
&
y
&
w
&
h
nullptr
)
;
if
(
w
<
0
.
0f
)
w
=
0
.
0f
;
if
(
h
<
0
.
0f
)
h
=
0
.
0f
;
Rect
viewport
(
x
y
w
h
)
;
bbox
=
aToBBoxUserspace
.
TransformBounds
(
viewport
)
;
if
(
StyleDisplay
(
)
-
>
IsScrollableOverflow
(
)
)
{
return
bbox
;
}
}
SVGBBox
descendantsBbox
=
SVGDisplayContainerFrame
:
:
GetBBoxContribution
(
aToBBoxUserspace
aFlags
)
;
bbox
.
UnionEdges
(
descendantsBbox
)
;
return
bbox
;
}
nsresult
SVGViewportFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
if
(
aNameSpaceID
=
=
kNameSpaceID_None
&
&
!
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
)
{
SVGViewportElement
*
content
=
static_cast
<
SVGViewportElement
*
>
(
GetContent
(
)
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
width
|
|
aAttribute
=
=
nsGkAtoms
:
:
height
)
{
nsLayoutUtils
:
:
PostRestyleEvent
(
mContent
-
>
AsElement
(
)
RestyleHint
{
0
}
nsChangeHint_InvalidateRenderingObservers
)
;
SVGUtils
:
:
ScheduleReflowSVG
(
this
)
;
if
(
content
-
>
HasViewBoxOrSyntheticViewBox
(
)
)
{
mCanvasTM
=
nullptr
;
content
-
>
ChildrenOnlyTransformChanged
(
)
;
SVGUtils
:
:
NotifyChildrenOfSVGChange
(
this
TRANSFORM_CHANGED
)
;
}
else
{
uint32_t
flags
=
COORD_CONTEXT_CHANGED
;
if
(
mCanvasTM
&
&
mCanvasTM
-
>
IsSingular
(
)
)
{
mCanvasTM
=
nullptr
;
flags
|
=
TRANSFORM_CHANGED
;
}
SVGUtils
:
:
NotifyChildrenOfSVGChange
(
this
flags
)
;
}
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
preserveAspectRatio
|
|
aAttribute
=
=
nsGkAtoms
:
:
viewBox
|
|
aAttribute
=
=
nsGkAtoms
:
:
x
|
|
aAttribute
=
=
nsGkAtoms
:
:
y
)
{
mCanvasTM
=
nullptr
;
SVGUtils
:
:
NotifyChildrenOfSVGChange
(
this
aAttribute
=
=
nsGkAtoms
:
:
viewBox
?
TRANSFORM_CHANGED
|
COORD_CONTEXT_CHANGED
:
TRANSFORM_CHANGED
)
;
if
(
aAttribute
=
=
nsGkAtoms
:
:
x
|
|
aAttribute
=
=
nsGkAtoms
:
:
y
)
{
nsLayoutUtils
:
:
PostRestyleEvent
(
mContent
-
>
AsElement
(
)
RestyleHint
{
0
}
nsChangeHint_InvalidateRenderingObservers
)
;
SVGUtils
:
:
ScheduleReflowSVG
(
this
)
;
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
viewBox
|
|
(
aAttribute
=
=
nsGkAtoms
:
:
preserveAspectRatio
&
&
content
-
>
HasViewBoxOrSyntheticViewBox
(
)
)
)
{
content
-
>
ChildrenOnlyTransformChanged
(
)
;
SchedulePaint
(
)
;
}
}
}
return
NS_OK
;
}
nsIFrame
*
SVGViewportFrame
:
:
GetFrameForPoint
(
const
gfxPoint
&
aPoint
)
{
MOZ_ASSERT_UNREACHABLE
(
"
A
clipPath
cannot
contain
svg
or
symbol
elements
"
)
;
return
nullptr
;
}
void
SVGViewportFrame
:
:
NotifyViewportOrTransformChanged
(
uint32_t
aFlags
)
{
NS_ERROR
(
"
Not
called
for
SVGViewportFrame
"
)
;
}
bool
SVGViewportFrame
:
:
HasChildrenOnlyTransform
(
gfx
:
:
Matrix
*
aTransform
)
const
{
auto
*
content
=
static_cast
<
SVGViewportElement
*
>
(
GetContent
(
)
)
;
if
(
!
content
-
>
HasViewBoxOrSyntheticViewBox
(
)
)
{
return
false
;
}
if
(
aTransform
)
{
*
aTransform
=
content
-
>
GetViewBoxTransform
(
)
;
}
return
true
;
}
}
