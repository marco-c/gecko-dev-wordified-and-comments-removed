#
include
"
nsSVGOuterSVGFrame
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsIDocument
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsIObjectLoadingContent
.
h
"
#
include
"
nsSVGIntegrationUtils
.
h
"
#
include
"
nsSVGForeignObjectFrame
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
SVGSVGElement
.
h
"
#
include
"
mozilla
/
dom
/
SVGViewElement
.
h
"
#
include
"
nsSubDocumentFrame
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
image
;
void
nsSVGOuterSVGFrame
:
:
RegisterForeignObject
(
nsSVGForeignObjectFrame
*
aFrame
)
{
NS_ASSERTION
(
aFrame
"
Who
on
earth
is
calling
us
?
!
"
)
;
if
(
!
mForeignObjectHash
)
{
mForeignObjectHash
=
new
nsTHashtable
<
nsPtrHashKey
<
nsSVGForeignObjectFrame
>
>
(
)
;
}
NS_ASSERTION
(
!
mForeignObjectHash
-
>
GetEntry
(
aFrame
)
"
nsSVGForeignObjectFrame
already
registered
!
"
)
;
mForeignObjectHash
-
>
PutEntry
(
aFrame
)
;
NS_ASSERTION
(
mForeignObjectHash
-
>
GetEntry
(
aFrame
)
"
Failed
to
register
nsSVGForeignObjectFrame
!
"
)
;
}
void
nsSVGOuterSVGFrame
:
:
UnregisterForeignObject
(
nsSVGForeignObjectFrame
*
aFrame
)
{
NS_ASSERTION
(
aFrame
"
Who
on
earth
is
calling
us
?
!
"
)
;
NS_ASSERTION
(
mForeignObjectHash
&
&
mForeignObjectHash
-
>
GetEntry
(
aFrame
)
"
nsSVGForeignObjectFrame
not
in
registry
!
"
)
;
return
mForeignObjectHash
-
>
RemoveEntry
(
aFrame
)
;
}
nsContainerFrame
*
NS_NewSVGOuterSVGFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsSVGOuterSVGFrame
(
aStyle
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsSVGOuterSVGFrame
)
nsSVGOuterSVGFrame
:
:
nsSVGOuterSVGFrame
(
ComputedStyle
*
aStyle
)
:
nsSVGDisplayContainerFrame
(
aStyle
kClassID
)
mCallingReflowSVG
(
false
)
mFullZoom
(
PresContext
(
)
-
>
GetFullZoom
(
)
)
mViewportInitialized
(
false
)
mIsRootContent
(
false
)
{
RemoveStateBits
(
NS_FRAME_SVG_LAYOUT
)
;
}
static
inline
bool
DependsOnIntrinsicSize
(
const
nsIFrame
*
aEmbeddingFrame
)
{
const
nsStylePosition
*
pos
=
aEmbeddingFrame
-
>
StylePosition
(
)
;
const
nsStyleCoord
&
width
=
pos
-
>
mWidth
;
const
nsStyleCoord
&
height
=
pos
-
>
mHeight
;
return
!
width
.
ConvertsToLength
(
)
|
|
!
height
.
ConvertsToLength
(
)
;
}
void
nsSVGOuterSVGFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
NS_ASSERTION
(
aContent
-
>
IsSVGElement
(
nsGkAtoms
:
:
svg
)
"
Content
is
not
an
SVG
'
svg
'
element
!
"
)
;
AddStateBits
(
NS_STATE_IS_OUTER_SVG
|
NS_FRAME_FONT_INFLATION_CONTAINER
|
NS_FRAME_FONT_INFLATION_FLOW_ROOT
)
;
SVGSVGElement
*
svg
=
static_cast
<
SVGSVGElement
*
>
(
aContent
)
;
if
(
!
svg
-
>
PassesConditionalProcessingTests
(
)
)
{
AddStateBits
(
NS_FRAME_IS_NONDISPLAY
)
;
}
nsSVGDisplayContainerFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
nsIDocument
*
doc
=
mContent
-
>
GetUncomposedDoc
(
)
;
if
(
doc
)
{
if
(
doc
-
>
GetRootElement
(
)
=
=
mContent
)
{
mIsRootContent
=
true
;
nsIFrame
*
embeddingFrame
;
if
(
IsRootOfReplacedElementSubDoc
(
&
embeddingFrame
)
&
&
embeddingFrame
)
{
if
(
MOZ_UNLIKELY
(
!
embeddingFrame
-
>
HasAllStateBits
(
NS_FRAME_IS_DIRTY
)
)
&
&
DependsOnIntrinsicSize
(
embeddingFrame
)
)
{
embeddingFrame
-
>
PresShell
(
)
-
>
FrameNeedsReflow
(
embeddingFrame
nsIPresShell
:
:
eStyleChange
NS_FRAME_IS_DIRTY
)
;
}
}
}
}
}
NS_QUERYFRAME_HEAD
(
nsSVGOuterSVGFrame
)
NS_QUERYFRAME_ENTRY
(
nsISVGSVGFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsSVGDisplayContainerFrame
)
nscoord
nsSVGOuterSVGFrame
:
:
GetMinISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
result
;
DISPLAY_MIN_WIDTH
(
this
result
)
;
result
=
nscoord
(
0
)
;
return
result
;
}
nscoord
nsSVGOuterSVGFrame
:
:
GetPrefISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
result
;
DISPLAY_PREF_WIDTH
(
this
result
)
;
SVGSVGElement
*
svg
=
static_cast
<
SVGSVGElement
*
>
(
GetContent
(
)
)
;
WritingMode
wm
=
GetWritingMode
(
)
;
const
nsSVGLength2
&
isize
=
wm
.
IsVertical
(
)
?
svg
-
>
mLengthAttributes
[
SVGSVGElement
:
:
ATTR_HEIGHT
]
:
svg
-
>
mLengthAttributes
[
SVGSVGElement
:
:
ATTR_WIDTH
]
;
if
(
isize
.
IsPercentage
(
)
)
{
result
=
nscoord
(
0
)
;
nsIFrame
*
parent
=
GetParent
(
)
;
while
(
parent
)
{
nscoord
parentISize
=
parent
-
>
GetLogicalSize
(
wm
)
.
ISize
(
wm
)
;
if
(
parentISize
>
0
&
&
parentISize
!
=
NS_UNCONSTRAINEDSIZE
)
{
result
=
parentISize
;
break
;
}
parent
=
parent
-
>
GetParent
(
)
;
}
}
else
{
result
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
isize
.
GetAnimValue
(
svg
)
)
;
if
(
result
<
0
)
{
result
=
nscoord
(
0
)
;
}
}
return
result
;
}
IntrinsicSize
nsSVGOuterSVGFrame
:
:
GetIntrinsicSize
(
)
{
IntrinsicSize
intrinsicSize
;
SVGSVGElement
*
content
=
static_cast
<
SVGSVGElement
*
>
(
GetContent
(
)
)
;
const
nsSVGLength2
&
width
=
content
-
>
mLengthAttributes
[
SVGSVGElement
:
:
ATTR_WIDTH
]
;
const
nsSVGLength2
&
height
=
content
-
>
mLengthAttributes
[
SVGSVGElement
:
:
ATTR_HEIGHT
]
;
if
(
!
width
.
IsPercentage
(
)
)
{
nscoord
val
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
width
.
GetAnimValue
(
content
)
)
;
if
(
val
<
0
)
val
=
0
;
intrinsicSize
.
width
.
SetCoordValue
(
val
)
;
}
if
(
!
height
.
IsPercentage
(
)
)
{
nscoord
val
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
height
.
GetAnimValue
(
content
)
)
;
if
(
val
<
0
)
val
=
0
;
intrinsicSize
.
height
.
SetCoordValue
(
val
)
;
}
return
intrinsicSize
;
}
nsSize
nsSVGOuterSVGFrame
:
:
GetIntrinsicRatio
(
)
{
SVGSVGElement
*
content
=
static_cast
<
SVGSVGElement
*
>
(
GetContent
(
)
)
;
const
nsSVGLength2
&
width
=
content
-
>
mLengthAttributes
[
SVGSVGElement
:
:
ATTR_WIDTH
]
;
const
nsSVGLength2
&
height
=
content
-
>
mLengthAttributes
[
SVGSVGElement
:
:
ATTR_HEIGHT
]
;
if
(
!
width
.
IsPercentage
(
)
&
&
!
height
.
IsPercentage
(
)
)
{
nsSize
ratio
(
NSToCoordRoundWithClamp
(
width
.
GetAnimValue
(
content
)
)
NSToCoordRoundWithClamp
(
height
.
GetAnimValue
(
content
)
)
)
;
if
(
ratio
.
width
<
0
)
{
ratio
.
width
=
0
;
}
if
(
ratio
.
height
<
0
)
{
ratio
.
height
=
0
;
}
return
ratio
;
}
SVGViewElement
*
viewElement
=
content
-
>
GetCurrentViewElement
(
)
;
const
nsSVGViewBoxRect
*
viewbox
=
nullptr
;
if
(
viewElement
&
&
viewElement
-
>
mViewBox
.
HasRect
(
)
)
{
viewbox
=
&
viewElement
-
>
mViewBox
.
GetAnimValue
(
)
;
}
else
if
(
content
-
>
mViewBox
.
HasRect
(
)
)
{
viewbox
=
&
content
-
>
mViewBox
.
GetAnimValue
(
)
;
}
if
(
viewbox
)
{
float
viewBoxWidth
=
viewbox
-
>
width
;
float
viewBoxHeight
=
viewbox
-
>
height
;
if
(
viewBoxWidth
<
0
.
0f
)
{
viewBoxWidth
=
0
.
0f
;
}
if
(
viewBoxHeight
<
0
.
0f
)
{
viewBoxHeight
=
0
.
0f
;
}
return
nsSize
(
NSToCoordRoundWithClamp
(
viewBoxWidth
)
NSToCoordRoundWithClamp
(
viewBoxHeight
)
)
;
}
return
nsSVGDisplayContainerFrame
:
:
GetIntrinsicRatio
(
)
;
}
LogicalSize
nsSVGOuterSVGFrame
:
:
ComputeSize
(
gfxContext
*
aRenderingContext
WritingMode
aWM
const
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
LogicalSize
&
aMargin
const
LogicalSize
&
aBorder
const
LogicalSize
&
aPadding
ComputeSizeFlags
aFlags
)
{
if
(
IsRootOfImage
(
)
|
|
IsRootOfReplacedElementSubDoc
(
)
)
{
return
aCBSize
;
}
LogicalSize
cbSize
=
aCBSize
;
IntrinsicSize
intrinsicSize
=
GetIntrinsicSize
(
)
;
if
(
!
mContent
-
>
GetParent
(
)
)
{
NS_ASSERTION
(
aCBSize
.
ISize
(
aWM
)
!
=
NS_AUTOHEIGHT
&
&
aCBSize
.
BSize
(
aWM
)
!
=
NS_AUTOHEIGHT
"
root
should
not
have
auto
-
width
/
height
containing
block
"
)
;
cbSize
.
ISize
(
aWM
)
*
=
PresContext
(
)
-
>
GetFullZoom
(
)
;
cbSize
.
BSize
(
aWM
)
*
=
PresContext
(
)
-
>
GetFullZoom
(
)
;
SVGSVGElement
*
content
=
static_cast
<
SVGSVGElement
*
>
(
GetContent
(
)
)
;
const
nsSVGLength2
&
width
=
content
-
>
mLengthAttributes
[
SVGSVGElement
:
:
ATTR_WIDTH
]
;
if
(
width
.
IsPercentage
(
)
)
{
MOZ_ASSERT
(
intrinsicSize
.
width
.
GetUnit
(
)
=
=
eStyleUnit_None
"
GetIntrinsicSize
should
have
reported
no
intrinsic
width
"
)
;
float
val
=
width
.
GetAnimValInSpecifiedUnits
(
)
/
100
.
0f
;
if
(
val
<
0
.
0f
)
val
=
0
.
0f
;
intrinsicSize
.
width
.
SetCoordValue
(
val
*
cbSize
.
Width
(
aWM
)
)
;
}
const
nsSVGLength2
&
height
=
content
-
>
mLengthAttributes
[
SVGSVGElement
:
:
ATTR_HEIGHT
]
;
NS_ASSERTION
(
aCBSize
.
BSize
(
aWM
)
!
=
NS_AUTOHEIGHT
"
root
should
not
have
auto
-
height
containing
block
"
)
;
if
(
height
.
IsPercentage
(
)
)
{
MOZ_ASSERT
(
intrinsicSize
.
height
.
GetUnit
(
)
=
=
eStyleUnit_None
"
GetIntrinsicSize
should
have
reported
no
intrinsic
height
"
)
;
float
val
=
height
.
GetAnimValInSpecifiedUnits
(
)
/
100
.
0f
;
if
(
val
<
0
.
0f
)
val
=
0
.
0f
;
intrinsicSize
.
height
.
SetCoordValue
(
val
*
cbSize
.
Height
(
aWM
)
)
;
}
MOZ_ASSERT
(
intrinsicSize
.
height
.
GetUnit
(
)
=
=
eStyleUnit_Coord
&
&
intrinsicSize
.
width
.
GetUnit
(
)
=
=
eStyleUnit_Coord
"
We
should
have
just
handled
the
only
situation
where
"
"
we
lack
an
intrinsic
height
or
width
.
"
)
;
}
return
ComputeSizeWithIntrinsicDimensions
(
aRenderingContext
aWM
intrinsicSize
GetIntrinsicRatio
(
)
cbSize
aMargin
aBorder
aPadding
aFlags
)
;
}
void
nsSVGOuterSVGFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsSVGOuterSVGFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aDesiredSize
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
NS_FRAME_TRACE
(
NS_FRAME_TRACE_CALLS
(
"
enter
nsSVGOuterSVGFrame
:
:
Reflow
:
availSize
=
%
d
%
d
"
aReflowInput
.
AvailableWidth
(
)
aReflowInput
.
AvailableHeight
(
)
)
)
;
MOZ_ASSERT
(
mState
&
NS_FRAME_IN_REFLOW
"
frame
is
not
in
reflow
"
)
;
aDesiredSize
.
Width
(
)
=
aReflowInput
.
ComputedWidth
(
)
+
aReflowInput
.
ComputedPhysicalBorderPadding
(
)
.
LeftRight
(
)
;
aDesiredSize
.
Height
(
)
=
aReflowInput
.
ComputedHeight
(
)
+
aReflowInput
.
ComputedPhysicalBorderPadding
(
)
.
TopBottom
(
)
;
NS_ASSERTION
(
!
GetPrevInFlow
(
)
"
SVG
can
'
t
currently
be
broken
across
pages
.
"
)
;
SVGSVGElement
*
svgElem
=
static_cast
<
SVGSVGElement
*
>
(
GetContent
(
)
)
;
nsSVGOuterSVGAnonChildFrame
*
anonKid
=
static_cast
<
nsSVGOuterSVGAnonChildFrame
*
>
(
PrincipalChildList
(
)
.
FirstChild
(
)
)
;
if
(
mState
&
NS_FRAME_FIRST_REFLOW
)
{
svgElem
-
>
UpdateHasChildrenOnlyTransform
(
)
;
}
svgFloatSize
newViewportSize
(
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
aReflowInput
.
ComputedWidth
(
)
)
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
aReflowInput
.
ComputedHeight
(
)
)
)
;
svgFloatSize
oldViewportSize
=
svgElem
-
>
GetViewportSize
(
)
;
uint32_t
changeBits
=
0
;
if
(
newViewportSize
!
=
oldViewportSize
)
{
if
(
svgElem
-
>
HasViewBoxOrSyntheticViewBox
(
)
)
{
nsIFrame
*
anonChild
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
anonChild
-
>
AddStateBits
(
NS_FRAME_IS_DIRTY
)
;
for
(
nsIFrame
*
child
:
anonChild
-
>
PrincipalChildList
(
)
)
{
child
-
>
AddStateBits
(
NS_FRAME_IS_DIRTY
)
;
}
}
changeBits
|
=
COORD_CONTEXT_CHANGED
;
svgElem
-
>
SetViewportSize
(
newViewportSize
)
;
}
if
(
mFullZoom
!
=
PresContext
(
)
-
>
GetFullZoom
(
)
)
{
changeBits
|
=
FULL_ZOOM_CHANGED
;
mFullZoom
=
PresContext
(
)
-
>
GetFullZoom
(
)
;
}
if
(
changeBits
)
{
NotifyViewportOrTransformChanged
(
changeBits
)
;
}
mViewportInitialized
=
true
;
mCallingReflowSVG
=
true
;
if
(
GetStateBits
(
)
&
NS_FRAME_IS_NONDISPLAY
)
{
ReflowSVGNonDisplayText
(
this
)
;
}
else
{
anonKid
-
>
AddStateBits
(
mState
&
NS_FRAME_IS_DIRTY
)
;
anonKid
-
>
ReflowSVG
(
)
;
MOZ_ASSERT
(
!
anonKid
-
>
GetNextSibling
(
)
"
We
should
have
one
anonymous
child
frame
wrapping
our
real
"
"
children
"
)
;
}
mCallingReflowSVG
=
false
;
anonKid
-
>
SetPosition
(
GetContentRectRelativeToSelf
(
)
.
TopLeft
(
)
)
;
aDesiredSize
.
SetOverflowAreasToDesiredBounds
(
)
;
if
(
!
mIsRootContent
)
{
aDesiredSize
.
mOverflowAreas
.
VisualOverflow
(
)
.
UnionRect
(
aDesiredSize
.
mOverflowAreas
.
VisualOverflow
(
)
anonKid
-
>
GetVisualOverflowRect
(
)
+
anonKid
-
>
GetPosition
(
)
)
;
}
FinishAndStoreOverflow
(
&
aDesiredSize
)
;
NS_FRAME_TRACE
(
NS_FRAME_TRACE_CALLS
(
"
exit
nsSVGOuterSVGFrame
:
:
Reflow
:
size
=
%
d
%
d
"
aDesiredSize
.
Width
(
)
aDesiredSize
.
Height
(
)
)
)
;
NS_FRAME_SET_TRUNCATION
(
aStatus
aReflowInput
aDesiredSize
)
;
}
void
nsSVGOuterSVGFrame
:
:
DidReflow
(
nsPresContext
*
aPresContext
const
ReflowInput
*
aReflowInput
)
{
nsSVGDisplayContainerFrame
:
:
DidReflow
(
aPresContext
aReflowInput
)
;
PresShell
(
)
-
>
SynthesizeMouseMove
(
false
)
;
}
void
nsSVGOuterSVGFrame
:
:
UnionChildOverflow
(
nsOverflowAreas
&
aOverflowAreas
)
{
if
(
!
mIsRootContent
)
{
nsIFrame
*
anonKid
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
aOverflowAreas
.
VisualOverflow
(
)
.
UnionRect
(
aOverflowAreas
.
VisualOverflow
(
)
anonKid
-
>
GetVisualOverflowRect
(
)
+
anonKid
-
>
GetPosition
(
)
)
;
}
}
class
nsDisplayOuterSVG
final
:
public
nsDisplayItem
{
public
:
nsDisplayOuterSVG
(
nsDisplayListBuilder
*
aBuilder
nsSVGOuterSVGFrame
*
aFrame
)
:
nsDisplayItem
(
aBuilder
aFrame
)
{
MOZ_COUNT_CTOR
(
nsDisplayOuterSVG
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayOuterSVG
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayOuterSVG
)
;
}
#
endif
virtual
void
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
override
;
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
;
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
;
nsDisplayItemGeometry
*
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
new
nsDisplayItemGenericImageGeometry
(
this
aBuilder
)
;
}
NS_DISPLAY_DECL_NAME
(
"
SVGOuterSVG
"
TYPE_SVG_OUTER_SVG
)
}
;
void
nsDisplayOuterSVG
:
:
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
{
nsSVGOuterSVGFrame
*
outerSVGFrame
=
static_cast
<
nsSVGOuterSVGFrame
*
>
(
mFrame
)
;
nsPoint
refFrameToContentBox
=
ToReferenceFrame
(
)
+
outerSVGFrame
-
>
GetContentRectRelativeToSelf
(
)
.
TopLeft
(
)
;
nsPoint
pointRelativeToContentBox
=
nsPoint
(
aRect
.
x
+
aRect
.
width
/
2
aRect
.
y
+
aRect
.
height
/
2
)
-
refFrameToContentBox
;
gfxPoint
svgViewportRelativePoint
=
gfxPoint
(
pointRelativeToContentBox
.
x
pointRelativeToContentBox
.
y
)
/
AppUnitsPerCSSPixel
(
)
;
nsSVGOuterSVGAnonChildFrame
*
anonKid
=
static_cast
<
nsSVGOuterSVGAnonChildFrame
*
>
(
outerSVGFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
)
;
nsIFrame
*
frame
=
nsSVGUtils
:
:
HitTestChildren
(
anonKid
svgViewportRelativePoint
)
;
if
(
frame
)
{
aOutFrames
-
>
AppendElement
(
frame
)
;
}
}
void
nsDisplayOuterSVG
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aContext
)
{
#
if
defined
(
DEBUG
)
&
&
defined
(
SVG_DEBUG_PAINT_TIMING
)
PRTime
start
=
PR_Now
(
)
;
#
endif
SVGAutoRenderState
state
(
aContext
-
>
GetDrawTarget
(
)
)
;
if
(
aBuilder
-
>
IsPaintingToWindow
(
)
)
{
state
.
SetPaintingToWindow
(
true
)
;
}
nsRect
viewportRect
=
mFrame
-
>
GetContentRectRelativeToSelf
(
)
+
ToReferenceFrame
(
)
;
nsRect
clipRect
=
GetPaintRect
(
)
.
Intersect
(
viewportRect
)
;
uint32_t
appUnitsPerDevPixel
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
nsIntRect
contentAreaDirtyRect
=
(
clipRect
-
viewportRect
.
TopLeft
(
)
)
.
ToOutsidePixels
(
appUnitsPerDevPixel
)
;
gfxPoint
devPixelOffset
=
nsLayoutUtils
:
:
PointToGfxPoint
(
viewportRect
.
TopLeft
(
)
appUnitsPerDevPixel
)
;
aContext
-
>
Save
(
)
;
imgDrawingParams
imgParams
(
aBuilder
-
>
ShouldSyncDecodeImages
(
)
?
imgIContainer
:
:
FLAG_SYNC_DECODE
:
imgIContainer
:
:
FLAG_SYNC_DECODE_IF_FAST
)
;
gfxMatrix
tm
=
nsSVGUtils
:
:
GetCSSPxToDevPxMatrix
(
mFrame
)
*
gfxMatrix
:
:
Translation
(
devPixelOffset
)
;
nsSVGUtils
:
:
PaintFrameWithEffects
(
mFrame
*
aContext
tm
imgParams
&
contentAreaDirtyRect
)
;
nsDisplayItemGenericImageGeometry
:
:
UpdateDrawResult
(
this
imgParams
.
result
)
;
aContext
-
>
Restore
(
)
;
#
if
defined
(
DEBUG
)
&
&
defined
(
SVG_DEBUG_PAINT_TIMING
)
PRTime
end
=
PR_Now
(
)
;
printf
(
"
SVG
Paint
Timing
:
%
f
ms
\
n
"
(
end
-
start
)
/
1000
.
0
)
;
#
endif
}
nsRegion
nsSVGOuterSVGFrame
:
:
FindInvalidatedForeignObjectFrameChildren
(
nsIFrame
*
aFrame
)
{
nsRegion
result
;
if
(
mForeignObjectHash
&
&
mForeignObjectHash
-
>
Count
(
)
)
{
for
(
auto
it
=
mForeignObjectHash
-
>
Iter
(
)
;
!
it
.
Done
(
)
;
it
.
Next
(
)
)
{
result
.
Or
(
result
it
.
Get
(
)
-
>
GetKey
(
)
-
>
GetInvalidRegion
(
)
)
;
}
}
return
result
;
}
void
nsDisplayOuterSVG
:
:
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
{
nsSVGOuterSVGFrame
*
frame
=
static_cast
<
nsSVGOuterSVGFrame
*
>
(
mFrame
)
;
frame
-
>
InvalidateSVG
(
frame
-
>
FindInvalidatedForeignObjectFrameChildren
(
frame
)
)
;
nsRegion
result
=
frame
-
>
GetInvalidRegion
(
)
;
result
.
MoveBy
(
ToReferenceFrame
(
)
)
;
frame
-
>
ClearInvalidRegion
(
)
;
nsDisplayItem
:
:
ComputeInvalidationRegion
(
aBuilder
aGeometry
aInvalidRegion
)
;
aInvalidRegion
-
>
Or
(
*
aInvalidRegion
result
)
;
auto
geometry
=
static_cast
<
const
nsDisplayItemGenericImageGeometry
*
>
(
aGeometry
)
;
if
(
aBuilder
-
>
ShouldSyncDecodeImages
(
)
&
&
geometry
-
>
ShouldInvalidateToSyncDecodeImages
(
)
)
{
bool
snap
;
aInvalidRegion
-
>
Or
(
*
aInvalidRegion
GetBounds
(
aBuilder
&
snap
)
)
;
}
}
nsresult
nsSVGOuterSVGFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
if
(
aNameSpaceID
=
=
kNameSpaceID_None
&
&
!
(
GetStateBits
(
)
&
(
NS_FRAME_FIRST_REFLOW
|
NS_FRAME_IS_NONDISPLAY
)
)
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
viewBox
|
|
aAttribute
=
=
nsGkAtoms
:
:
preserveAspectRatio
|
|
aAttribute
=
=
nsGkAtoms
:
:
transform
)
{
mCanvasTM
=
nullptr
;
nsSVGUtils
:
:
NotifyChildrenOfSVGChange
(
PrincipalChildList
(
)
.
FirstChild
(
)
aAttribute
=
=
nsGkAtoms
:
:
viewBox
?
TRANSFORM_CHANGED
|
COORD_CONTEXT_CHANGED
:
TRANSFORM_CHANGED
)
;
if
(
aAttribute
!
=
nsGkAtoms
:
:
transform
)
{
static_cast
<
SVGSVGElement
*
>
(
GetContent
(
)
)
-
>
ChildrenOnlyTransformChanged
(
)
;
}
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
width
|
|
aAttribute
=
=
nsGkAtoms
:
:
height
)
{
nsIFrame
*
embeddingFrame
;
if
(
IsRootOfReplacedElementSubDoc
(
&
embeddingFrame
)
&
&
embeddingFrame
)
{
if
(
DependsOnIntrinsicSize
(
embeddingFrame
)
)
{
embeddingFrame
-
>
PresShell
(
)
-
>
FrameNeedsReflow
(
embeddingFrame
nsIPresShell
:
:
eStyleChange
NS_FRAME_IS_DIRTY
)
;
}
}
else
{
PresShell
(
)
-
>
FrameNeedsReflow
(
this
nsIPresShell
:
:
eStyleChange
NS_FRAME_IS_DIRTY
)
;
}
}
}
return
NS_OK
;
}
bool
nsSVGOuterSVGFrame
:
:
IsSVGTransformed
(
Matrix
*
aOwnTransform
Matrix
*
aFromParentTransform
)
const
{
bool
foundTransform
=
false
;
SVGSVGElement
*
content
=
static_cast
<
SVGSVGElement
*
>
(
GetContent
(
)
)
;
nsSVGAnimatedTransformList
*
transformList
=
content
-
>
GetAnimatedTransformList
(
)
;
if
(
(
transformList
&
&
transformList
-
>
HasTransform
(
)
)
|
|
content
-
>
GetAnimateMotionTransform
(
)
)
{
if
(
aOwnTransform
)
{
*
aOwnTransform
=
gfx
:
:
ToMatrix
(
content
-
>
PrependLocalTransformsTo
(
gfxMatrix
(
)
eUserSpaceToParent
)
)
;
}
foundTransform
=
true
;
}
return
foundTransform
;
}
void
nsSVGOuterSVGFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
if
(
GetStateBits
(
)
&
NS_FRAME_IS_NONDISPLAY
)
{
return
;
}
DisplayBorderBackgroundOutline
(
aBuilder
aLists
)
;
DisplayListClipState
:
:
AutoSaveRestore
autoSR
(
aBuilder
)
;
if
(
mIsRootContent
|
|
StyleDisplay
(
)
-
>
IsScrollableOverflow
(
)
)
{
autoSR
.
ClipContainingBlockDescendantsToContentBox
(
aBuilder
this
)
;
}
if
(
(
aBuilder
-
>
IsForEventDelivery
(
)
&
&
NS_SVGDisplayListHitTestingEnabled
(
)
)
|
|
(
!
aBuilder
-
>
IsForEventDelivery
(
)
&
&
NS_SVGDisplayListPaintingEnabled
(
)
)
)
{
nsDisplayList
*
contentList
=
aLists
.
Content
(
)
;
nsDisplayListSet
set
(
contentList
contentList
contentList
contentList
contentList
contentList
)
;
BuildDisplayListForNonBlockChildren
(
aBuilder
set
)
;
}
else
if
(
IsVisibleForPainting
(
aBuilder
)
|
|
!
aBuilder
-
>
IsForPainting
(
)
)
{
aLists
.
Content
(
)
-
>
AppendToTop
(
MakeDisplayItem
<
nsDisplayOuterSVG
>
(
aBuilder
this
)
)
;
}
}
nsSplittableType
nsSVGOuterSVGFrame
:
:
GetSplittableType
(
)
const
{
return
NS_FRAME_NOT_SPLITTABLE
;
}
void
nsSVGOuterSVGFrame
:
:
NotifyViewportOrTransformChanged
(
uint32_t
aFlags
)
{
MOZ_ASSERT
(
aFlags
&
&
!
(
aFlags
&
~
(
COORD_CONTEXT_CHANGED
|
TRANSFORM_CHANGED
|
FULL_ZOOM_CHANGED
)
)
"
Unexpected
aFlags
value
"
)
;
if
(
!
mViewportInitialized
)
{
return
;
}
SVGSVGElement
*
content
=
static_cast
<
SVGSVGElement
*
>
(
GetContent
(
)
)
;
if
(
aFlags
&
COORD_CONTEXT_CHANGED
)
{
if
(
content
-
>
HasViewBoxRect
(
)
)
{
aFlags
=
TRANSFORM_CHANGED
;
}
else
if
(
content
-
>
ShouldSynthesizeViewBox
(
)
)
{
aFlags
|
=
TRANSFORM_CHANGED
;
}
else
if
(
mCanvasTM
&
&
mCanvasTM
-
>
IsSingular
(
)
)
{
aFlags
|
=
TRANSFORM_CHANGED
;
}
}
bool
haveNonFulLZoomTransformChange
=
(
aFlags
&
TRANSFORM_CHANGED
)
;
if
(
aFlags
&
FULL_ZOOM_CHANGED
)
{
aFlags
=
(
aFlags
&
~
FULL_ZOOM_CHANGED
)
|
TRANSFORM_CHANGED
;
}
if
(
aFlags
&
TRANSFORM_CHANGED
)
{
mCanvasTM
=
nullptr
;
if
(
haveNonFulLZoomTransformChange
&
&
!
(
mState
&
NS_FRAME_IS_NONDISPLAY
)
)
{
uint32_t
flags
=
(
mState
&
NS_FRAME_IN_REFLOW
)
?
SVGSVGElement
:
:
eDuringReflow
:
0
;
content
-
>
ChildrenOnlyTransformChanged
(
flags
)
;
}
}
nsSVGUtils
:
:
NotifyChildrenOfSVGChange
(
PrincipalChildList
(
)
.
FirstChild
(
)
aFlags
)
;
}
void
nsSVGOuterSVGFrame
:
:
PaintSVG
(
gfxContext
&
aContext
const
gfxMatrix
&
aTransform
imgDrawingParams
&
aImgParams
const
nsIntRect
*
aDirtyRect
)
{
NS_ASSERTION
(
PrincipalChildList
(
)
.
FirstChild
(
)
-
>
IsSVGOuterSVGAnonChildFrame
(
)
&
&
!
PrincipalChildList
(
)
.
FirstChild
(
)
-
>
GetNextSibling
(
)
"
We
should
have
a
single
anonymous
child
"
)
;
nsSVGOuterSVGAnonChildFrame
*
anonKid
=
static_cast
<
nsSVGOuterSVGAnonChildFrame
*
>
(
PrincipalChildList
(
)
.
FirstChild
(
)
)
;
anonKid
-
>
PaintSVG
(
aContext
aTransform
aImgParams
aDirtyRect
)
;
}
SVGBBox
nsSVGOuterSVGFrame
:
:
GetBBoxContribution
(
const
gfx
:
:
Matrix
&
aToBBoxUserspace
uint32_t
aFlags
)
{
NS_ASSERTION
(
PrincipalChildList
(
)
.
FirstChild
(
)
-
>
IsSVGOuterSVGAnonChildFrame
(
)
&
&
!
PrincipalChildList
(
)
.
FirstChild
(
)
-
>
GetNextSibling
(
)
"
We
should
have
a
single
anonymous
child
"
)
;
nsSVGOuterSVGAnonChildFrame
*
anonKid
=
static_cast
<
nsSVGOuterSVGAnonChildFrame
*
>
(
PrincipalChildList
(
)
.
FirstChild
(
)
)
;
return
anonKid
-
>
GetBBoxContribution
(
aToBBoxUserspace
aFlags
)
;
}
gfxMatrix
nsSVGOuterSVGFrame
:
:
GetCanvasTM
(
)
{
if
(
!
mCanvasTM
)
{
SVGSVGElement
*
content
=
static_cast
<
SVGSVGElement
*
>
(
GetContent
(
)
)
;
float
devPxPerCSSPx
=
1
.
0f
/
PresContext
(
)
-
>
AppUnitsToFloatCSSPixels
(
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
gfxMatrix
tm
=
content
-
>
PrependLocalTransformsTo
(
gfxMatrix
:
:
Scaling
(
devPxPerCSSPx
devPxPerCSSPx
)
)
;
mCanvasTM
=
new
gfxMatrix
(
tm
)
;
}
return
*
mCanvasTM
;
}
bool
nsSVGOuterSVGFrame
:
:
IsRootOfReplacedElementSubDoc
(
nsIFrame
*
*
aEmbeddingFrame
)
{
if
(
!
mContent
-
>
GetParent
(
)
)
{
nsCOMPtr
<
nsIDocShell
>
docShell
=
PresContext
(
)
-
>
GetDocShell
(
)
;
nsCOMPtr
<
nsPIDOMWindowOuter
>
window
;
if
(
docShell
)
{
window
=
docShell
-
>
GetWindow
(
)
;
}
if
(
window
)
{
RefPtr
<
Element
>
frameElement
=
window
-
>
GetFrameElement
(
)
;
if
(
frameElement
&
&
frameElement
-
>
IsAnyOfHTMLElements
(
nsGkAtoms
:
:
object
nsGkAtoms
:
:
embed
nsGkAtoms
:
:
iframe
)
)
{
if
(
aEmbeddingFrame
)
{
*
aEmbeddingFrame
=
frameElement
-
>
GetPrimaryFrame
(
)
;
NS_ASSERTION
(
*
aEmbeddingFrame
"
Yikes
no
embedding
frame
!
"
)
;
}
return
true
;
}
}
}
if
(
aEmbeddingFrame
)
{
*
aEmbeddingFrame
=
nullptr
;
}
return
false
;
}
bool
nsSVGOuterSVGFrame
:
:
IsRootOfImage
(
)
{
if
(
!
mContent
-
>
GetParent
(
)
)
{
nsIDocument
*
doc
=
mContent
-
>
GetUncomposedDoc
(
)
;
if
(
doc
&
&
doc
-
>
IsBeingUsedAsImage
(
)
)
{
return
true
;
}
}
return
false
;
}
bool
nsSVGOuterSVGFrame
:
:
VerticalScrollbarNotNeeded
(
)
const
{
const
nsSVGLength2
&
height
=
static_cast
<
SVGSVGElement
*
>
(
GetContent
(
)
)
-
>
mLengthAttributes
[
SVGSVGElement
:
:
ATTR_HEIGHT
]
;
return
height
.
IsPercentage
(
)
&
&
height
.
GetBaseValInSpecifiedUnits
(
)
<
=
100
;
}
void
nsSVGOuterSVGFrame
:
:
AppendDirectlyOwnedAnonBoxes
(
nsTArray
<
OwnedAnonBox
>
&
aResult
)
{
nsIFrame
*
anonKid
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
MOZ_ASSERT
(
anonKid
-
>
IsSVGOuterSVGAnonChildFrame
(
)
)
;
aResult
.
AppendElement
(
OwnedAnonBox
(
anonKid
)
)
;
}
nsContainerFrame
*
NS_NewSVGOuterSVGAnonChildFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsSVGOuterSVGAnonChildFrame
(
aStyle
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsSVGOuterSVGAnonChildFrame
)
#
ifdef
DEBUG
void
nsSVGOuterSVGAnonChildFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
MOZ_ASSERT
(
aParent
-
>
IsSVGOuterSVGFrame
(
)
"
Unexpected
parent
"
)
;
nsSVGDisplayContainerFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
}
#
endif
void
nsSVGOuterSVGAnonChildFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
nsDisplayList
newList
;
nsDisplayListSet
set
(
&
newList
&
newList
&
newList
&
newList
&
newList
&
newList
)
;
BuildDisplayListForNonBlockChildren
(
aBuilder
set
)
;
aLists
.
Content
(
)
-
>
AppendToTop
(
MakeDisplayItem
<
nsDisplaySVGWrapper
>
(
aBuilder
this
&
newList
)
)
;
}
static
Matrix
ComputeOuterSVGAnonChildFrameTransform
(
const
nsSVGOuterSVGAnonChildFrame
*
aFrame
)
{
SVGSVGElement
*
content
=
static_cast
<
SVGSVGElement
*
>
(
aFrame
-
>
GetContent
(
)
)
;
if
(
!
content
-
>
HasChildrenOnlyTransform
(
)
)
{
return
Matrix
(
)
;
}
gfxMatrix
ownMatrix
=
content
-
>
PrependLocalTransformsTo
(
gfxMatrix
(
)
eChildToUserSpace
)
;
if
(
ownMatrix
.
HasNonTranslation
(
)
)
{
MOZ_ASSERT
(
ownMatrix
.
IsRectilinear
(
)
"
Non
-
rectilinear
transform
will
break
the
following
logic
"
)
;
CSSPoint
pos
=
CSSPixel
:
:
FromAppUnits
(
aFrame
-
>
GetPosition
(
)
)
;
CSSPoint
scaledPos
=
CSSPoint
(
ownMatrix
.
_11
*
pos
.
x
ownMatrix
.
_22
*
pos
.
y
)
;
CSSPoint
deltaPos
=
scaledPos
-
pos
;
ownMatrix
*
=
gfxMatrix
:
:
Translation
(
-
deltaPos
.
x
-
deltaPos
.
y
)
;
}
return
gfx
:
:
ToMatrix
(
ownMatrix
)
;
}
bool
nsSVGOuterSVGAnonChildFrame
:
:
IsSVGTransformed
(
Matrix
*
aOwnTransform
Matrix
*
aFromParentTransform
)
const
{
if
(
aOwnTransform
)
{
*
aOwnTransform
=
ComputeOuterSVGAnonChildFrameTransform
(
this
)
;
}
return
true
;
}
