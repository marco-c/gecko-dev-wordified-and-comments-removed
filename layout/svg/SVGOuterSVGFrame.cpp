#
include
"
SVGOuterSVGFrame
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsObjectLoadingContent
.
h
"
#
include
"
nsSubDocumentFrame
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
SVGForeignObjectFrame
.
h
"
#
include
"
mozilla
/
SVGUtils
.
h
"
#
include
"
mozilla
/
dom
/
BrowserChild
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
SVGSVGElement
.
h
"
#
include
"
mozilla
/
dom
/
SVGViewElement
.
h
"
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
image
;
namespace
mozilla
{
void
SVGOuterSVGFrame
:
:
RegisterForeignObject
(
SVGForeignObjectFrame
*
aFrame
)
{
NS_ASSERTION
(
aFrame
"
Who
on
earth
is
calling
us
?
!
"
)
;
if
(
!
mForeignObjectHash
)
{
mForeignObjectHash
=
MakeUnique
<
nsTHashSet
<
SVGForeignObjectFrame
*
>
>
(
)
;
}
NS_ASSERTION
(
!
mForeignObjectHash
-
>
Contains
(
aFrame
)
"
SVGForeignObjectFrame
already
registered
!
"
)
;
mForeignObjectHash
-
>
Insert
(
aFrame
)
;
NS_ASSERTION
(
mForeignObjectHash
-
>
Contains
(
aFrame
)
"
Failed
to
register
SVGForeignObjectFrame
!
"
)
;
}
void
SVGOuterSVGFrame
:
:
UnregisterForeignObject
(
SVGForeignObjectFrame
*
aFrame
)
{
NS_ASSERTION
(
aFrame
"
Who
on
earth
is
calling
us
?
!
"
)
;
NS_ASSERTION
(
mForeignObjectHash
&
&
mForeignObjectHash
-
>
Contains
(
aFrame
)
"
SVGForeignObjectFrame
not
in
registry
!
"
)
;
return
mForeignObjectHash
-
>
Remove
(
aFrame
)
;
}
}
nsContainerFrame
*
NS_NewSVGOuterSVGFrame
(
mozilla
:
:
PresShell
*
aPresShell
mozilla
:
:
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
mozilla
:
:
SVGOuterSVGFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
namespace
mozilla
{
NS_IMPL_FRAMEARENA_HELPERS
(
SVGOuterSVGFrame
)
SVGOuterSVGFrame
:
:
SVGOuterSVGFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
:
SVGDisplayContainerFrame
(
aStyle
aPresContext
kClassID
)
mCallingReflowSVG
(
false
)
mFullZoom
(
PresContext
(
)
-
>
GetFullZoom
(
)
)
mViewportInitialized
(
false
)
mIsRootContent
(
false
)
mIsInObjectOrEmbed
(
false
)
mIsInIframe
(
false
)
{
RemoveStateBits
(
NS_FRAME_SVG_LAYOUT
)
;
AddStateBits
(
NS_FRAME_MAY_BE_TRANSFORMED
)
;
}
static
inline
ContainSizeAxes
ContainSizeAxesIfApplicable
(
const
SVGOuterSVGFrame
*
aFrame
)
{
if
(
!
aFrame
-
>
GetContent
(
)
-
>
GetParent
(
)
)
{
return
ContainSizeAxes
(
false
false
)
;
}
return
aFrame
-
>
StyleDisplay
(
)
-
>
GetContainSizeAxes
(
)
;
}
void
SVGOuterSVGFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
NS_ASSERTION
(
aContent
-
>
IsSVGElement
(
nsGkAtoms
:
:
svg
)
"
Content
is
not
an
SVG
'
svg
'
element
!
"
)
;
AddStateBits
(
NS_FRAME_REFLOW_ROOT
|
NS_FRAME_FONT_INFLATION_CONTAINER
|
NS_FRAME_FONT_INFLATION_FLOW_ROOT
)
;
SVGSVGElement
*
svg
=
static_cast
<
SVGSVGElement
*
>
(
aContent
)
;
if
(
!
svg
-
>
PassesConditionalProcessingTests
(
)
)
{
AddStateBits
(
NS_FRAME_IS_NONDISPLAY
)
;
}
SVGDisplayContainerFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
Document
*
doc
=
mContent
-
>
GetUncomposedDoc
(
)
;
mIsRootContent
=
doc
&
&
doc
-
>
GetRootElement
(
)
=
=
mContent
;
if
(
mIsRootContent
)
{
if
(
nsCOMPtr
<
nsIDocShell
>
docShell
=
PresContext
(
)
-
>
GetDocShell
(
)
)
{
RefPtr
<
BrowsingContext
>
bc
=
docShell
-
>
GetBrowsingContext
(
)
;
if
(
const
Maybe
<
nsString
>
&
type
=
bc
-
>
GetEmbedderElementType
(
)
)
{
mIsInObjectOrEmbed
=
nsGkAtoms
:
:
object
-
>
Equals
(
*
type
)
|
|
nsGkAtoms
:
:
embed
-
>
Equals
(
*
type
)
;
mIsInIframe
=
nsGkAtoms
:
:
iframe
-
>
Equals
(
*
type
)
;
}
}
}
MaybeSendIntrinsicSizeAndRatioToEmbedder
(
)
;
}
NS_QUERYFRAME_HEAD
(
SVGOuterSVGFrame
)
NS_QUERYFRAME_ENTRY
(
SVGOuterSVGFrame
)
NS_QUERYFRAME_ENTRY
(
ISVGSVGFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
SVGDisplayContainerFrame
)
nscoord
SVGOuterSVGFrame
:
:
GetMinISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
result
;
DISPLAY_MIN_INLINE_SIZE
(
this
result
)
;
result
=
nscoord
(
0
)
;
return
result
;
}
nscoord
SVGOuterSVGFrame
:
:
GetPrefISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
result
;
DISPLAY_PREF_INLINE_SIZE
(
this
result
)
;
SVGSVGElement
*
svg
=
static_cast
<
SVGSVGElement
*
>
(
GetContent
(
)
)
;
WritingMode
wm
=
GetWritingMode
(
)
;
const
SVGAnimatedLength
&
isize
=
wm
.
IsVertical
(
)
?
svg
-
>
mLengthAttributes
[
SVGSVGElement
:
:
ATTR_HEIGHT
]
:
svg
-
>
mLengthAttributes
[
SVGSVGElement
:
:
ATTR_WIDTH
]
;
if
(
ContainSizeAxesIfApplicable
(
this
)
.
mIContained
)
{
result
=
nscoord
(
0
)
;
}
else
if
(
isize
.
IsPercentage
(
)
)
{
result
=
nscoord
(
0
)
;
nsIFrame
*
parent
=
GetParent
(
)
;
while
(
parent
)
{
nscoord
parentISize
=
parent
-
>
GetLogicalSize
(
wm
)
.
ISize
(
wm
)
;
if
(
parentISize
>
0
&
&
parentISize
!
=
NS_UNCONSTRAINEDSIZE
)
{
result
=
parentISize
;
break
;
}
parent
=
parent
-
>
GetParent
(
)
;
}
}
else
{
result
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
isize
.
GetAnimValue
(
svg
)
)
;
if
(
result
<
0
)
{
result
=
nscoord
(
0
)
;
}
}
return
result
;
}
IntrinsicSize
SVGOuterSVGFrame
:
:
GetIntrinsicSize
(
)
{
const
auto
containAxes
=
ContainSizeAxesIfApplicable
(
this
)
;
if
(
containAxes
.
IsBoth
(
)
)
{
return
IntrinsicSize
(
0
0
)
;
}
SVGSVGElement
*
content
=
static_cast
<
SVGSVGElement
*
>
(
GetContent
(
)
)
;
const
SVGAnimatedLength
&
width
=
content
-
>
mLengthAttributes
[
SVGSVGElement
:
:
ATTR_WIDTH
]
;
const
SVGAnimatedLength
&
height
=
content
-
>
mLengthAttributes
[
SVGSVGElement
:
:
ATTR_HEIGHT
]
;
IntrinsicSize
intrinsicSize
;
if
(
!
width
.
IsPercentage
(
)
)
{
nscoord
val
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
width
.
GetAnimValue
(
content
)
)
;
intrinsicSize
.
width
.
emplace
(
std
:
:
max
(
val
0
)
)
;
}
if
(
!
height
.
IsPercentage
(
)
)
{
nscoord
val
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
height
.
GetAnimValue
(
content
)
)
;
intrinsicSize
.
height
.
emplace
(
std
:
:
max
(
val
0
)
)
;
}
return
containAxes
.
ContainIntrinsicSize
(
intrinsicSize
GetWritingMode
(
)
)
;
}
AspectRatio
SVGOuterSVGFrame
:
:
GetIntrinsicRatio
(
)
const
{
if
(
ContainSizeAxesIfApplicable
(
this
)
.
IsAny
(
)
)
{
return
AspectRatio
(
)
;
}
SVGSVGElement
*
content
=
static_cast
<
SVGSVGElement
*
>
(
GetContent
(
)
)
;
const
SVGAnimatedLength
&
width
=
content
-
>
mLengthAttributes
[
SVGSVGElement
:
:
ATTR_WIDTH
]
;
const
SVGAnimatedLength
&
height
=
content
-
>
mLengthAttributes
[
SVGSVGElement
:
:
ATTR_HEIGHT
]
;
if
(
!
width
.
IsPercentage
(
)
&
&
!
height
.
IsPercentage
(
)
)
{
const
float
w
=
width
.
GetAnimValue
(
content
)
;
const
float
h
=
height
.
GetAnimValue
(
content
)
;
if
(
w
>
0
.
0f
&
&
h
>
0
.
0f
)
{
return
AspectRatio
:
:
FromSize
(
w
h
)
;
}
}
SVGViewElement
*
viewElement
=
content
-
>
GetCurrentViewElement
(
)
;
const
SVGViewBox
*
viewbox
=
nullptr
;
if
(
viewElement
&
&
viewElement
-
>
mViewBox
.
HasRect
(
)
)
{
viewbox
=
&
viewElement
-
>
mViewBox
.
GetAnimValue
(
)
;
}
else
if
(
content
-
>
mViewBox
.
HasRect
(
)
)
{
viewbox
=
&
content
-
>
mViewBox
.
GetAnimValue
(
)
;
}
if
(
viewbox
)
{
return
AspectRatio
:
:
FromSize
(
viewbox
-
>
width
viewbox
-
>
height
)
;
}
return
SVGDisplayContainerFrame
:
:
GetIntrinsicRatio
(
)
;
}
nsIFrame
:
:
SizeComputationResult
SVGOuterSVGFrame
:
:
ComputeSize
(
gfxContext
*
aRenderingContext
WritingMode
aWritingMode
const
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
LogicalSize
&
aMargin
const
LogicalSize
&
aBorderPadding
const
StyleSizeOverrides
&
aSizeOverrides
ComputeSizeFlags
aFlags
)
{
if
(
IsRootOfImage
(
)
|
|
mIsInObjectOrEmbed
)
{
return
{
aCBSize
AspectRatioUsage
:
:
None
}
;
}
LogicalSize
cbSize
=
aCBSize
;
IntrinsicSize
intrinsicSize
=
GetIntrinsicSize
(
)
;
if
(
!
mContent
-
>
GetParent
(
)
)
{
NS_ASSERTION
(
aCBSize
.
ISize
(
aWritingMode
)
!
=
NS_UNCONSTRAINEDSIZE
&
&
aCBSize
.
BSize
(
aWritingMode
)
!
=
NS_UNCONSTRAINEDSIZE
"
root
should
not
have
auto
-
width
/
height
containing
block
"
)
;
if
(
!
mIsInIframe
)
{
cbSize
.
ISize
(
aWritingMode
)
*
=
PresContext
(
)
-
>
GetFullZoom
(
)
;
cbSize
.
BSize
(
aWritingMode
)
*
=
PresContext
(
)
-
>
GetFullZoom
(
)
;
}
SVGSVGElement
*
content
=
static_cast
<
SVGSVGElement
*
>
(
GetContent
(
)
)
;
const
SVGAnimatedLength
&
width
=
content
-
>
mLengthAttributes
[
SVGSVGElement
:
:
ATTR_WIDTH
]
;
if
(
width
.
IsPercentage
(
)
)
{
MOZ_ASSERT
(
!
intrinsicSize
.
width
"
GetIntrinsicSize
should
have
reported
no
intrinsic
width
"
)
;
float
val
=
width
.
GetAnimValInSpecifiedUnits
(
)
/
100
.
0f
;
intrinsicSize
.
width
.
emplace
(
std
:
:
max
(
val
0
.
0f
)
*
cbSize
.
Width
(
aWritingMode
)
)
;
}
const
SVGAnimatedLength
&
height
=
content
-
>
mLengthAttributes
[
SVGSVGElement
:
:
ATTR_HEIGHT
]
;
NS_ASSERTION
(
aCBSize
.
BSize
(
aWritingMode
)
!
=
NS_UNCONSTRAINEDSIZE
"
root
should
not
have
auto
-
height
containing
block
"
)
;
if
(
height
.
IsPercentage
(
)
)
{
MOZ_ASSERT
(
!
intrinsicSize
.
height
"
GetIntrinsicSize
should
have
reported
no
intrinsic
height
"
)
;
float
val
=
height
.
GetAnimValInSpecifiedUnits
(
)
/
100
.
0f
;
intrinsicSize
.
height
.
emplace
(
std
:
:
max
(
val
0
.
0f
)
*
cbSize
.
Height
(
aWritingMode
)
)
;
}
MOZ_ASSERT
(
intrinsicSize
.
height
&
&
intrinsicSize
.
width
"
We
should
have
just
handled
the
only
situation
where
"
"
we
lack
an
intrinsic
height
or
width
.
"
)
;
}
return
{
ComputeSizeWithIntrinsicDimensions
(
aRenderingContext
aWritingMode
intrinsicSize
GetAspectRatio
(
)
cbSize
aMargin
aBorderPadding
aSizeOverrides
aFlags
)
AspectRatioUsage
:
:
None
}
;
}
void
SVGOuterSVGFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
SVGOuterSVGFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aDesiredSize
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
NS_FRAME_TRACE
(
NS_FRAME_TRACE_CALLS
(
"
enter
SVGOuterSVGFrame
:
:
Reflow
:
availSize
=
%
d
%
d
"
aReflowInput
.
AvailableWidth
(
)
aReflowInput
.
AvailableHeight
(
)
)
)
;
MOZ_ASSERT
(
mState
&
NS_FRAME_IN_REFLOW
"
frame
is
not
in
reflow
"
)
;
aDesiredSize
.
Width
(
)
=
aReflowInput
.
ComputedWidth
(
)
+
aReflowInput
.
ComputedPhysicalBorderPadding
(
)
.
LeftRight
(
)
;
aDesiredSize
.
Height
(
)
=
aReflowInput
.
ComputedHeight
(
)
+
aReflowInput
.
ComputedPhysicalBorderPadding
(
)
.
TopBottom
(
)
;
NS_ASSERTION
(
!
GetPrevInFlow
(
)
"
SVG
can
'
t
currently
be
broken
across
pages
.
"
)
;
SVGSVGElement
*
svgElem
=
static_cast
<
SVGSVGElement
*
>
(
GetContent
(
)
)
;
auto
*
anonKid
=
static_cast
<
SVGOuterSVGAnonChildFrame
*
>
(
PrincipalChildList
(
)
.
FirstChild
(
)
)
;
if
(
mState
&
NS_FRAME_FIRST_REFLOW
)
{
svgElem
-
>
UpdateHasChildrenOnlyTransform
(
)
;
}
svgFloatSize
newViewportSize
(
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
aReflowInput
.
ComputedWidth
(
)
)
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
aReflowInput
.
ComputedHeight
(
)
)
)
;
svgFloatSize
oldViewportSize
=
svgElem
-
>
GetViewportSize
(
)
;
uint32_t
changeBits
=
0
;
if
(
newViewportSize
!
=
oldViewportSize
)
{
if
(
svgElem
-
>
HasViewBoxOrSyntheticViewBox
(
)
)
{
nsIFrame
*
anonChild
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
anonChild
-
>
MarkSubtreeDirty
(
)
;
for
(
nsIFrame
*
child
:
anonChild
-
>
PrincipalChildList
(
)
)
{
child
-
>
MarkSubtreeDirty
(
)
;
}
}
changeBits
|
=
COORD_CONTEXT_CHANGED
;
svgElem
-
>
SetViewportSize
(
newViewportSize
)
;
}
if
(
mFullZoom
!
=
PresContext
(
)
-
>
GetFullZoom
(
)
&
&
!
mIsInIframe
)
{
changeBits
|
=
FULL_ZOOM_CHANGED
;
mFullZoom
=
PresContext
(
)
-
>
GetFullZoom
(
)
;
}
if
(
changeBits
)
{
NotifyViewportOrTransformChanged
(
changeBits
)
;
}
mViewportInitialized
=
true
;
mCallingReflowSVG
=
true
;
if
(
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
)
{
ReflowSVGNonDisplayText
(
this
)
;
}
else
{
anonKid
-
>
ReflowSVG
(
)
;
MOZ_ASSERT
(
!
anonKid
-
>
GetNextSibling
(
)
"
We
should
have
one
anonymous
child
frame
wrapping
our
real
"
"
children
"
)
;
}
mCallingReflowSVG
=
false
;
anonKid
-
>
SetPosition
(
GetContentRectRelativeToSelf
(
)
.
TopLeft
(
)
)
;
aDesiredSize
.
SetOverflowAreasToDesiredBounds
(
)
;
if
(
!
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
)
{
if
(
!
mIsRootContent
)
{
aDesiredSize
.
mOverflowAreas
.
InkOverflow
(
)
.
UnionRect
(
aDesiredSize
.
mOverflowAreas
.
InkOverflow
(
)
anonKid
-
>
InkOverflowRect
(
)
+
anonKid
-
>
GetPosition
(
)
)
;
}
FinishAndStoreOverflow
(
&
aDesiredSize
)
;
}
NS_FRAME_TRACE
(
NS_FRAME_TRACE_CALLS
(
"
exit
SVGOuterSVGFrame
:
:
Reflow
:
size
=
%
d
%
d
"
aDesiredSize
.
Width
(
)
aDesiredSize
.
Height
(
)
)
)
;
NS_FRAME_SET_TRUNCATION
(
aStatus
aReflowInput
aDesiredSize
)
;
}
void
SVGOuterSVGFrame
:
:
DidReflow
(
nsPresContext
*
aPresContext
const
ReflowInput
*
aReflowInput
)
{
SVGDisplayContainerFrame
:
:
DidReflow
(
aPresContext
aReflowInput
)
;
PresShell
(
)
-
>
SynthesizeMouseMove
(
false
)
;
}
void
SVGOuterSVGFrame
:
:
UnionChildOverflow
(
OverflowAreas
&
aOverflowAreas
)
{
if
(
!
mIsRootContent
)
{
nsIFrame
*
anonKid
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
aOverflowAreas
.
InkOverflow
(
)
.
UnionRect
(
aOverflowAreas
.
InkOverflow
(
)
anonKid
-
>
InkOverflowRect
(
)
+
anonKid
-
>
GetPosition
(
)
)
;
}
}
class
nsDisplayOuterSVG
final
:
public
nsPaintedDisplayItem
{
public
:
nsDisplayOuterSVG
(
nsDisplayListBuilder
*
aBuilder
SVGOuterSVGFrame
*
aFrame
)
:
nsPaintedDisplayItem
(
aBuilder
aFrame
)
{
MOZ_COUNT_CTOR
(
nsDisplayOuterSVG
)
;
}
MOZ_COUNTED_DTOR_OVERRIDE
(
nsDisplayOuterSVG
)
virtual
void
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
override
;
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aContext
)
override
;
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
;
NS_DISPLAY_DECL_NAME
(
"
SVGOuterSVG
"
TYPE_SVG_OUTER_SVG
)
}
;
void
nsDisplayOuterSVG
:
:
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
{
SVGOuterSVGFrame
*
outerSVGFrame
=
static_cast
<
SVGOuterSVGFrame
*
>
(
mFrame
)
;
nsPoint
refFrameToContentBox
=
ToReferenceFrame
(
)
+
outerSVGFrame
-
>
GetContentRectRelativeToSelf
(
)
.
TopLeft
(
)
;
nsPoint
pointRelativeToContentBox
=
nsPoint
(
aRect
.
x
+
aRect
.
width
/
2
aRect
.
y
+
aRect
.
height
/
2
)
-
refFrameToContentBox
;
gfxPoint
svgViewportRelativePoint
=
gfxPoint
(
pointRelativeToContentBox
.
x
pointRelativeToContentBox
.
y
)
/
AppUnitsPerCSSPixel
(
)
;
auto
*
anonKid
=
static_cast
<
SVGOuterSVGAnonChildFrame
*
>
(
outerSVGFrame
-
>
PrincipalChildList
(
)
.
FirstChild
(
)
)
;
nsIFrame
*
frame
=
SVGUtils
:
:
HitTestChildren
(
anonKid
svgViewportRelativePoint
)
;
if
(
frame
)
{
aOutFrames
-
>
AppendElement
(
frame
)
;
}
}
void
nsDisplayOuterSVG
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aContext
)
{
#
if
defined
(
DEBUG
)
&
&
defined
(
SVG_DEBUG_PAINT_TIMING
)
PRTime
start
=
PR_Now
(
)
;
#
endif
SVGAutoRenderState
state
(
aContext
-
>
GetDrawTarget
(
)
)
;
if
(
aBuilder
-
>
IsPaintingToWindow
(
)
)
{
state
.
SetPaintingToWindow
(
true
)
;
}
nsRect
viewportRect
=
mFrame
-
>
GetContentRectRelativeToSelf
(
)
+
ToReferenceFrame
(
)
;
nsRect
clipRect
=
GetPaintRect
(
aBuilder
aContext
)
.
Intersect
(
viewportRect
)
;
uint32_t
appUnitsPerDevPixel
=
mFrame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
nsIntRect
contentAreaDirtyRect
=
(
clipRect
-
viewportRect
.
TopLeft
(
)
)
.
ToOutsidePixels
(
appUnitsPerDevPixel
)
;
gfxPoint
devPixelOffset
=
nsLayoutUtils
:
:
PointToGfxPoint
(
viewportRect
.
TopLeft
(
)
appUnitsPerDevPixel
)
;
aContext
-
>
Save
(
)
;
imgDrawingParams
imgParams
(
aBuilder
-
>
GetImageDecodeFlags
(
)
)
;
gfxMatrix
tm
=
SVGUtils
:
:
GetCSSPxToDevPxMatrix
(
mFrame
)
*
gfxMatrix
:
:
Translation
(
devPixelOffset
)
;
SVGUtils
:
:
PaintFrameWithEffects
(
mFrame
*
aContext
tm
imgParams
&
contentAreaDirtyRect
)
;
aContext
-
>
Restore
(
)
;
#
if
defined
(
DEBUG
)
&
&
defined
(
SVG_DEBUG_PAINT_TIMING
)
PRTime
end
=
PR_Now
(
)
;
printf
(
"
SVG
Paint
Timing
:
%
f
ms
\
n
"
(
end
-
start
)
/
1000
.
0
)
;
#
endif
}
nsRegion
SVGOuterSVGFrame
:
:
FindInvalidatedForeignObjectFrameChildren
(
nsIFrame
*
aFrame
)
{
nsRegion
result
;
if
(
mForeignObjectHash
&
&
mForeignObjectHash
-
>
Count
(
)
)
{
for
(
const
auto
&
key
:
*
mForeignObjectHash
)
{
result
.
Or
(
result
key
-
>
GetInvalidRegion
(
)
)
;
}
}
return
result
;
}
void
nsDisplayOuterSVG
:
:
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
{
auto
*
frame
=
static_cast
<
SVGOuterSVGFrame
*
>
(
mFrame
)
;
frame
-
>
InvalidateSVG
(
frame
-
>
FindInvalidatedForeignObjectFrameChildren
(
frame
)
)
;
nsRegion
result
=
frame
-
>
GetInvalidRegion
(
)
;
result
.
MoveBy
(
ToReferenceFrame
(
)
)
;
frame
-
>
ClearInvalidRegion
(
)
;
nsDisplayItem
:
:
ComputeInvalidationRegion
(
aBuilder
aGeometry
aInvalidRegion
)
;
aInvalidRegion
-
>
Or
(
*
aInvalidRegion
result
)
;
}
nsresult
SVGOuterSVGFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
if
(
aNameSpaceID
=
=
kNameSpaceID_None
&
&
!
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
|
NS_FRAME_IS_NONDISPLAY
)
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
viewBox
|
|
aAttribute
=
=
nsGkAtoms
:
:
preserveAspectRatio
|
|
aAttribute
=
=
nsGkAtoms
:
:
transform
)
{
mCanvasTM
=
nullptr
;
SVGUtils
:
:
NotifyChildrenOfSVGChange
(
PrincipalChildList
(
)
.
FirstChild
(
)
aAttribute
=
=
nsGkAtoms
:
:
viewBox
?
TRANSFORM_CHANGED
|
COORD_CONTEXT_CHANGED
:
TRANSFORM_CHANGED
)
;
if
(
aAttribute
!
=
nsGkAtoms
:
:
transform
)
{
static_cast
<
SVGSVGElement
*
>
(
GetContent
(
)
)
-
>
ChildrenOnlyTransformChanged
(
)
;
}
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
width
|
|
aAttribute
=
=
nsGkAtoms
:
:
height
|
|
aAttribute
=
=
nsGkAtoms
:
:
viewBox
)
{
MaybeSendIntrinsicSizeAndRatioToEmbedder
(
)
;
if
(
!
mIsInObjectOrEmbed
)
{
PresShell
(
)
-
>
FrameNeedsReflow
(
this
IntrinsicDirty
:
:
StyleChange
NS_FRAME_IS_DIRTY
)
;
}
}
}
return
NS_OK
;
}
bool
SVGOuterSVGFrame
:
:
IsSVGTransformed
(
Matrix
*
aOwnTransform
Matrix
*
aFromParentTransform
)
const
{
bool
foundTransform
=
false
;
SVGSVGElement
*
content
=
static_cast
<
SVGSVGElement
*
>
(
GetContent
(
)
)
;
SVGAnimatedTransformList
*
transformList
=
content
-
>
GetAnimatedTransformList
(
)
;
if
(
(
transformList
&
&
transformList
-
>
HasTransform
(
)
)
|
|
content
-
>
GetAnimateMotionTransform
(
)
)
{
if
(
aOwnTransform
)
{
*
aOwnTransform
=
gfx
:
:
ToMatrix
(
content
-
>
PrependLocalTransformsTo
(
gfxMatrix
(
)
eUserSpaceToParent
)
)
;
}
foundTransform
=
true
;
}
return
foundTransform
;
}
void
SVGOuterSVGFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
if
(
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
)
{
return
;
}
DisplayBorderBackgroundOutline
(
aBuilder
aLists
)
;
nsRect
visibleRect
=
aBuilder
-
>
GetVisibleRect
(
)
;
nsRect
dirtyRect
=
aBuilder
-
>
GetDirtyRect
(
)
;
DisplayListClipState
:
:
AutoSaveRestore
autoSR
(
aBuilder
)
;
if
(
mIsRootContent
|
|
StyleDisplay
(
)
-
>
IsScrollableOverflow
(
)
)
{
autoSR
.
ClipContainingBlockDescendantsToContentBox
(
aBuilder
this
)
;
visibleRect
=
visibleRect
.
Intersect
(
GetContentRectRelativeToSelf
(
)
)
;
dirtyRect
=
dirtyRect
.
Intersect
(
GetContentRectRelativeToSelf
(
)
)
;
}
nsDisplayListBuilder
:
:
AutoBuildingDisplayList
building
(
aBuilder
this
visibleRect
dirtyRect
)
;
if
(
(
aBuilder
-
>
IsForEventDelivery
(
)
&
&
NS_SVGDisplayListHitTestingEnabled
(
)
)
|
|
(
!
aBuilder
-
>
IsForEventDelivery
(
)
&
&
NS_SVGDisplayListPaintingEnabled
(
)
)
)
{
nsDisplayList
*
contentList
=
aLists
.
Content
(
)
;
nsDisplayListSet
set
(
contentList
contentList
contentList
contentList
contentList
contentList
)
;
BuildDisplayListForNonBlockChildren
(
aBuilder
set
)
;
}
else
if
(
IsVisibleForPainting
(
)
|
|
!
aBuilder
-
>
IsForPainting
(
)
)
{
aBuilder
-
>
BuildCompositorHitTestInfoIfNeeded
(
this
aLists
.
BorderBackground
(
)
)
;
aLists
.
Content
(
)
-
>
AppendNewToTop
<
nsDisplayOuterSVG
>
(
aBuilder
this
)
;
}
}
void
SVGOuterSVGFrame
:
:
NotifyViewportOrTransformChanged
(
uint32_t
aFlags
)
{
MOZ_ASSERT
(
aFlags
&
&
!
(
aFlags
&
~
(
COORD_CONTEXT_CHANGED
|
TRANSFORM_CHANGED
|
FULL_ZOOM_CHANGED
)
)
"
Unexpected
aFlags
value
"
)
;
if
(
!
mViewportInitialized
)
{
return
;
}
SVGSVGElement
*
content
=
static_cast
<
SVGSVGElement
*
>
(
GetContent
(
)
)
;
if
(
aFlags
&
COORD_CONTEXT_CHANGED
)
{
if
(
content
-
>
HasViewBox
(
)
)
{
aFlags
=
TRANSFORM_CHANGED
;
}
else
if
(
content
-
>
ShouldSynthesizeViewBox
(
)
)
{
aFlags
|
=
TRANSFORM_CHANGED
;
}
else
if
(
mCanvasTM
&
&
mCanvasTM
-
>
IsSingular
(
)
)
{
aFlags
|
=
TRANSFORM_CHANGED
;
}
}
bool
haveNonFulLZoomTransformChange
=
(
aFlags
&
TRANSFORM_CHANGED
)
;
if
(
aFlags
&
FULL_ZOOM_CHANGED
)
{
aFlags
=
(
aFlags
&
~
FULL_ZOOM_CHANGED
)
|
TRANSFORM_CHANGED
;
}
if
(
aFlags
&
TRANSFORM_CHANGED
)
{
mCanvasTM
=
nullptr
;
if
(
haveNonFulLZoomTransformChange
&
&
!
(
mState
&
NS_FRAME_IS_NONDISPLAY
)
)
{
uint32_t
flags
=
(
mState
&
NS_FRAME_IN_REFLOW
)
?
SVGSVGElement
:
:
eDuringReflow
:
0
;
content
-
>
ChildrenOnlyTransformChanged
(
flags
)
;
}
}
SVGUtils
:
:
NotifyChildrenOfSVGChange
(
PrincipalChildList
(
)
.
FirstChild
(
)
aFlags
)
;
}
void
SVGOuterSVGFrame
:
:
PaintSVG
(
gfxContext
&
aContext
const
gfxMatrix
&
aTransform
imgDrawingParams
&
aImgParams
const
nsIntRect
*
aDirtyRect
)
{
NS_ASSERTION
(
PrincipalChildList
(
)
.
FirstChild
(
)
-
>
IsSVGOuterSVGAnonChildFrame
(
)
&
&
!
PrincipalChildList
(
)
.
FirstChild
(
)
-
>
GetNextSibling
(
)
"
We
should
have
a
single
anonymous
child
"
)
;
auto
*
anonKid
=
static_cast
<
SVGOuterSVGAnonChildFrame
*
>
(
PrincipalChildList
(
)
.
FirstChild
(
)
)
;
anonKid
-
>
PaintSVG
(
aContext
aTransform
aImgParams
aDirtyRect
)
;
}
SVGBBox
SVGOuterSVGFrame
:
:
GetBBoxContribution
(
const
gfx
:
:
Matrix
&
aToBBoxUserspace
uint32_t
aFlags
)
{
NS_ASSERTION
(
PrincipalChildList
(
)
.
FirstChild
(
)
-
>
IsSVGOuterSVGAnonChildFrame
(
)
&
&
!
PrincipalChildList
(
)
.
FirstChild
(
)
-
>
GetNextSibling
(
)
"
We
should
have
a
single
anonymous
child
"
)
;
auto
*
anonKid
=
static_cast
<
SVGOuterSVGAnonChildFrame
*
>
(
PrincipalChildList
(
)
.
FirstChild
(
)
)
;
return
anonKid
-
>
GetBBoxContribution
(
aToBBoxUserspace
aFlags
)
;
}
gfxMatrix
SVGOuterSVGFrame
:
:
GetCanvasTM
(
)
{
if
(
!
mCanvasTM
)
{
SVGSVGElement
*
content
=
static_cast
<
SVGSVGElement
*
>
(
GetContent
(
)
)
;
float
devPxPerCSSPx
=
1
.
0f
/
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
gfxMatrix
tm
=
content
-
>
PrependLocalTransformsTo
(
gfxMatrix
:
:
Scaling
(
devPxPerCSSPx
devPxPerCSSPx
)
)
;
mCanvasTM
=
MakeUnique
<
gfxMatrix
>
(
tm
)
;
}
return
*
mCanvasTM
;
}
bool
SVGOuterSVGFrame
:
:
IsRootOfImage
(
)
{
if
(
!
mContent
-
>
GetParent
(
)
)
{
Document
*
doc
=
mContent
-
>
GetUncomposedDoc
(
)
;
if
(
doc
&
&
doc
-
>
IsBeingUsedAsImage
(
)
)
{
return
true
;
}
}
return
false
;
}
bool
SVGOuterSVGFrame
:
:
VerticalScrollbarNotNeeded
(
)
const
{
const
SVGAnimatedLength
&
height
=
static_cast
<
SVGSVGElement
*
>
(
GetContent
(
)
)
-
>
mLengthAttributes
[
SVGSVGElement
:
:
ATTR_HEIGHT
]
;
return
height
.
IsPercentage
(
)
&
&
height
.
GetBaseValInSpecifiedUnits
(
)
<
=
100
;
}
void
SVGOuterSVGFrame
:
:
AppendDirectlyOwnedAnonBoxes
(
nsTArray
<
OwnedAnonBox
>
&
aResult
)
{
nsIFrame
*
anonKid
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
MOZ_ASSERT
(
anonKid
-
>
IsSVGOuterSVGAnonChildFrame
(
)
)
;
aResult
.
AppendElement
(
OwnedAnonBox
(
anonKid
)
)
;
}
void
SVGOuterSVGFrame
:
:
MaybeSendIntrinsicSizeAndRatioToEmbedder
(
)
{
MaybeSendIntrinsicSizeAndRatioToEmbedder
(
Some
(
GetIntrinsicSize
(
)
)
Some
(
GetAspectRatio
(
)
)
)
;
}
void
SVGOuterSVGFrame
:
:
MaybeSendIntrinsicSizeAndRatioToEmbedder
(
Maybe
<
IntrinsicSize
>
aIntrinsicSize
Maybe
<
AspectRatio
>
aIntrinsicRatio
)
{
if
(
!
mIsInObjectOrEmbed
)
{
return
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
=
PresContext
(
)
-
>
GetDocShell
(
)
;
if
(
!
docShell
)
{
return
;
}
BrowsingContext
*
bc
=
docShell
-
>
GetBrowsingContext
(
)
;
MOZ_ASSERT
(
bc
-
>
IsContentSubframe
(
)
)
;
if
(
bc
-
>
GetParent
(
)
-
>
IsInProcess
(
)
)
{
if
(
Element
*
embedder
=
bc
-
>
GetEmbedderElement
(
)
)
{
if
(
nsCOMPtr
<
nsIObjectLoadingContent
>
olc
=
do_QueryInterface
(
embedder
)
)
{
static_cast
<
nsObjectLoadingContent
*
>
(
olc
.
get
(
)
)
-
>
SubdocumentIntrinsicSizeOrRatioChanged
(
aIntrinsicSize
aIntrinsicRatio
)
;
}
return
;
}
}
if
(
BrowserChild
*
browserChild
=
BrowserChild
:
:
GetFrom
(
docShell
)
)
{
Unused
<
<
browserChild
-
>
SendIntrinsicSizeOrRatioChanged
(
aIntrinsicSize
aIntrinsicRatio
)
;
}
}
void
SVGOuterSVGFrame
:
:
DidSetComputedStyle
(
ComputedStyle
*
aOldComputedStyle
)
{
SVGDisplayContainerFrame
:
:
DidSetComputedStyle
(
aOldComputedStyle
)
;
if
(
!
aOldComputedStyle
)
{
return
;
}
if
(
aOldComputedStyle
-
>
StylePosition
(
)
-
>
mAspectRatio
!
=
StylePosition
(
)
-
>
mAspectRatio
)
{
MaybeSendIntrinsicSizeAndRatioToEmbedder
(
)
;
}
}
void
SVGOuterSVGFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
{
MaybeSendIntrinsicSizeAndRatioToEmbedder
(
Nothing
(
)
Nothing
(
)
)
;
SVGDisplayContainerFrame
:
:
DestroyFrom
(
aDestructRoot
aPostDestroyData
)
;
}
}
nsContainerFrame
*
NS_NewSVGOuterSVGAnonChildFrame
(
mozilla
:
:
PresShell
*
aPresShell
mozilla
:
:
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
mozilla
:
:
SVGOuterSVGAnonChildFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
namespace
mozilla
{
NS_IMPL_FRAMEARENA_HELPERS
(
SVGOuterSVGAnonChildFrame
)
#
ifdef
DEBUG
void
SVGOuterSVGAnonChildFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
MOZ_ASSERT
(
aParent
-
>
IsSVGOuterSVGFrame
(
)
"
Unexpected
parent
"
)
;
SVGDisplayContainerFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
}
#
endif
void
SVGOuterSVGAnonChildFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
nsDisplayList
newList
(
aBuilder
)
;
nsDisplayListSet
set
(
&
newList
&
newList
&
newList
&
newList
&
newList
&
newList
)
;
BuildDisplayListForNonBlockChildren
(
aBuilder
set
)
;
aLists
.
Content
(
)
-
>
AppendNewToTop
<
nsDisplaySVGWrapper
>
(
aBuilder
this
&
newList
)
;
}
static
Matrix
ComputeOuterSVGAnonChildFrameTransform
(
const
SVGOuterSVGAnonChildFrame
*
aFrame
)
{
SVGSVGElement
*
content
=
static_cast
<
SVGSVGElement
*
>
(
aFrame
-
>
GetContent
(
)
)
;
if
(
!
content
-
>
HasChildrenOnlyTransform
(
)
)
{
return
Matrix
(
)
;
}
gfxMatrix
ownMatrix
=
content
-
>
PrependLocalTransformsTo
(
gfxMatrix
(
)
eChildToUserSpace
)
;
if
(
ownMatrix
.
HasNonTranslation
(
)
)
{
MOZ_ASSERT
(
ownMatrix
.
IsRectilinear
(
)
"
Non
-
rectilinear
transform
will
break
the
following
logic
"
)
;
CSSPoint
pos
=
CSSPixel
:
:
FromAppUnits
(
aFrame
-
>
GetPosition
(
)
)
;
CSSPoint
scaledPos
=
CSSPoint
(
ownMatrix
.
_11
*
pos
.
x
ownMatrix
.
_22
*
pos
.
y
)
;
CSSPoint
deltaPos
=
scaledPos
-
pos
;
ownMatrix
*
=
gfxMatrix
:
:
Translation
(
-
deltaPos
.
x
-
deltaPos
.
y
)
;
}
return
gfx
:
:
ToMatrix
(
ownMatrix
)
;
}
bool
SVGOuterSVGAnonChildFrame
:
:
IsSVGTransformed
(
Matrix
*
aOwnTransform
Matrix
*
aFromParentTransform
)
const
{
if
(
aOwnTransform
)
{
*
aOwnTransform
=
ComputeOuterSVGAnonChildFrameTransform
(
this
)
;
}
return
true
;
}
}
