#
include
"
SVGOuterSVGFrame
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsIInterfaceRequestorUtils
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsObjectLoadingContent
.
h
"
#
include
"
nsSubDocumentFrame
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
SVGUtils
.
h
"
#
include
"
mozilla
/
dom
/
BrowserChild
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
dom
/
SVGSVGElement
.
h
"
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
image
;
nsContainerFrame
*
NS_NewSVGOuterSVGFrame
(
mozilla
:
:
PresShell
*
aPresShell
mozilla
:
:
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
mozilla
:
:
SVGOuterSVGFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
namespace
mozilla
{
NS_IMPL_FRAMEARENA_HELPERS
(
SVGOuterSVGFrame
)
SVGOuterSVGFrame
:
:
SVGOuterSVGFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
:
SVGDisplayContainerFrame
(
aStyle
aPresContext
kClassID
)
{
RemoveStateBits
(
NS_FRAME_SVG_LAYOUT
)
;
AddStateBits
(
NS_FRAME_REFLOW_ROOT
|
NS_FRAME_FONT_INFLATION_CONTAINER
|
NS_FRAME_FONT_INFLATION_FLOW_ROOT
)
;
}
static
inline
ContainSizeAxes
ContainSizeAxesIfApplicable
(
const
SVGOuterSVGFrame
*
aFrame
)
{
if
(
!
aFrame
-
>
GetContent
(
)
-
>
GetParent
(
)
)
{
return
ContainSizeAxes
(
false
false
)
;
}
return
aFrame
-
>
GetContainSizeAxes
(
)
;
}
float
SVGOuterSVGFrame
:
:
ComputeFullZoom
(
)
const
{
MOZ_ASSERT
(
mIsRootContent
)
;
MOZ_ASSERT
(
!
mIsInIframe
)
;
if
(
BrowsingContext
*
bc
=
PresContext
(
)
-
>
Document
(
)
-
>
GetBrowsingContext
(
)
)
{
return
bc
-
>
FullZoom
(
)
;
}
return
1
.
0f
;
}
void
SVGOuterSVGFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
NS_ASSERTION
(
aContent
-
>
IsSVGElement
(
nsGkAtoms
:
:
svg
)
"
Content
is
not
an
SVG
'
svg
'
element
!
"
)
;
auto
*
svg
=
static_cast
<
SVGSVGElement
*
>
(
aContent
)
;
if
(
!
svg
-
>
PassesConditionalProcessingTests
(
)
)
{
AddStateBits
(
NS_FRAME_IS_NONDISPLAY
)
;
}
SVGDisplayContainerFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
Document
*
doc
=
mContent
-
>
GetUncomposedDoc
(
)
;
mIsRootContent
=
doc
&
&
doc
-
>
GetRootElement
(
)
=
=
mContent
;
if
(
mIsRootContent
)
{
if
(
nsCOMPtr
<
nsIDocShell
>
docShell
=
PresContext
(
)
-
>
GetDocShell
(
)
)
{
RefPtr
<
BrowsingContext
>
bc
=
docShell
-
>
GetBrowsingContext
(
)
;
if
(
const
Maybe
<
nsString
>
&
type
=
bc
-
>
GetEmbedderElementType
(
)
)
{
mIsInObjectOrEmbed
=
nsGkAtoms
:
:
object
-
>
Equals
(
*
type
)
|
|
nsGkAtoms
:
:
embed
-
>
Equals
(
*
type
)
;
mIsInIframe
=
nsGkAtoms
:
:
iframe
-
>
Equals
(
*
type
)
;
}
}
if
(
!
mIsInIframe
)
{
mFullZoom
=
ComputeFullZoom
(
)
;
}
}
MaybeSendIntrinsicSizeAndRatioToEmbedder
(
)
;
}
NS_QUERYFRAME_HEAD
(
SVGOuterSVGFrame
)
NS_QUERYFRAME_ENTRY
(
SVGOuterSVGFrame
)
NS_QUERYFRAME_ENTRY
(
ISVGSVGFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
SVGDisplayContainerFrame
)
nscoord
SVGOuterSVGFrame
:
:
IntrinsicISize
(
const
IntrinsicSizeInput
&
aInput
IntrinsicISizeType
aType
)
{
if
(
aType
=
=
IntrinsicISizeType
:
:
MinISize
)
{
return
GetIntrinsicSize
(
)
.
ISize
(
GetWritingMode
(
)
)
.
valueOr
(
0
)
;
}
nscoord
result
;
SVGSVGElement
*
svg
=
static_cast
<
SVGSVGElement
*
>
(
GetContent
(
)
)
;
WritingMode
wm
=
GetWritingMode
(
)
;
const
SVGAnimatedLength
&
isize
=
wm
.
IsVertical
(
)
?
svg
-
>
mLengthAttributes
[
SVGSVGElement
:
:
ATTR_HEIGHT
]
:
svg
-
>
mLengthAttributes
[
SVGSVGElement
:
:
ATTR_WIDTH
]
;
if
(
Maybe
<
nscoord
>
containISize
=
ContainSizeAxesIfApplicable
(
this
)
.
ContainIntrinsicISize
(
*
this
)
)
{
result
=
*
containISize
;
}
else
if
(
isize
.
IsPercentage
(
)
)
{
if
(
isize
.
IsExplicitlySet
(
)
|
|
StylePosition
(
)
-
>
ISize
(
wm
)
.
HasPercent
(
)
|
|
!
GetAspectRatio
(
)
)
{
result
=
wm
.
IsVertical
(
)
?
kFallbackIntrinsicSize
.
height
:
kFallbackIntrinsicSize
.
width
;
}
else
{
result
=
nscoord
(
0
)
;
}
}
else
{
result
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
isize
.
GetAnimValueWithZoom
(
svg
)
)
;
if
(
result
<
0
)
{
result
=
nscoord
(
0
)
;
}
}
return
result
;
}
IntrinsicSize
SVGOuterSVGFrame
:
:
GetIntrinsicSize
(
)
{
const
auto
containAxes
=
ContainSizeAxesIfApplicable
(
this
)
;
if
(
containAxes
.
IsBoth
(
)
)
{
return
FinishIntrinsicSize
(
containAxes
IntrinsicSize
(
0
0
)
)
;
}
SVGSVGElement
*
content
=
static_cast
<
SVGSVGElement
*
>
(
GetContent
(
)
)
;
const
SVGAnimatedLength
&
width
=
content
-
>
mLengthAttributes
[
SVGSVGElement
:
:
ATTR_WIDTH
]
;
const
SVGAnimatedLength
&
height
=
content
-
>
mLengthAttributes
[
SVGSVGElement
:
:
ATTR_HEIGHT
]
;
IntrinsicSize
intrinsicSize
;
if
(
!
width
.
IsPercentage
(
)
)
{
nscoord
val
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
width
.
GetAnimValueWithZoom
(
content
)
)
;
intrinsicSize
.
width
.
emplace
(
std
:
:
max
(
val
0
)
)
;
}
if
(
!
height
.
IsPercentage
(
)
)
{
nscoord
val
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
height
.
GetAnimValueWithZoom
(
content
)
)
;
intrinsicSize
.
height
.
emplace
(
std
:
:
max
(
val
0
)
)
;
}
return
FinishIntrinsicSize
(
containAxes
intrinsicSize
)
;
}
AspectRatio
SVGOuterSVGFrame
:
:
GetIntrinsicRatio
(
)
const
{
if
(
ContainSizeAxesIfApplicable
(
this
)
.
IsAny
(
)
)
{
return
AspectRatio
(
)
;
}
auto
*
content
=
static_cast
<
SVGSVGElement
*
>
(
GetContent
(
)
)
;
const
SVGAnimatedLength
&
width
=
content
-
>
mLengthAttributes
[
SVGSVGElement
:
:
ATTR_WIDTH
]
;
const
SVGAnimatedLength
&
height
=
content
-
>
mLengthAttributes
[
SVGSVGElement
:
:
ATTR_HEIGHT
]
;
if
(
!
width
.
IsPercentage
(
)
&
&
!
height
.
IsPercentage
(
)
)
{
const
float
w
=
width
.
GetAnimValueWithZoom
(
content
)
;
const
float
h
=
height
.
GetAnimValueWithZoom
(
content
)
;
if
(
w
>
0
.
0f
&
&
h
>
0
.
0f
)
{
return
AspectRatio
:
:
FromSize
(
w
h
)
;
}
}
const
auto
&
viewBox
=
content
-
>
GetViewBoxInternal
(
)
;
if
(
viewBox
.
HasRect
(
)
)
{
float
zoom
=
Style
(
)
-
>
EffectiveZoom
(
)
.
ToFloat
(
)
;
const
auto
&
anim
=
viewBox
.
GetAnimValue
(
)
*
zoom
;
return
AspectRatio
:
:
FromSize
(
anim
.
width
anim
.
height
)
;
}
return
SVGDisplayContainerFrame
:
:
GetIntrinsicRatio
(
)
;
}
nsIFrame
:
:
SizeComputationResult
SVGOuterSVGFrame
:
:
ComputeSize
(
gfxContext
*
aRenderingContext
WritingMode
aWritingMode
const
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
LogicalSize
&
aMargin
const
LogicalSize
&
aBorderPadding
const
StyleSizeOverrides
&
aSizeOverrides
ComputeSizeFlags
aFlags
)
{
if
(
IsRootOfImage
(
)
|
|
mIsInObjectOrEmbed
)
{
return
{
aCBSize
AspectRatioUsage
:
:
None
}
;
}
LogicalSize
cbSize
=
aCBSize
;
IntrinsicSize
intrinsicSize
=
GetIntrinsicSize
(
)
;
if
(
mIsRootContent
)
{
NS_ASSERTION
(
aCBSize
.
ISize
(
aWritingMode
)
!
=
NS_UNCONSTRAINEDSIZE
&
&
aCBSize
.
BSize
(
aWritingMode
)
!
=
NS_UNCONSTRAINEDSIZE
"
root
should
not
have
auto
-
width
/
height
containing
block
"
)
;
if
(
!
mIsInIframe
)
{
const
float
zoom
=
ComputeFullZoom
(
)
;
cbSize
.
ISize
(
aWritingMode
)
*
=
zoom
;
cbSize
.
BSize
(
aWritingMode
)
*
=
zoom
;
}
auto
*
content
=
static_cast
<
SVGSVGElement
*
>
(
GetContent
(
)
)
;
const
SVGAnimatedLength
&
width
=
content
-
>
mLengthAttributes
[
SVGSVGElement
:
:
ATTR_WIDTH
]
;
if
(
width
.
IsPercentage
(
)
)
{
MOZ_ASSERT
(
!
intrinsicSize
.
width
"
GetIntrinsicSize
should
have
reported
no
intrinsic
width
"
)
;
float
val
=
width
.
GetAnimValInSpecifiedUnits
(
)
/
100
.
0f
;
intrinsicSize
.
width
.
emplace
(
std
:
:
max
(
val
0
.
0f
)
*
cbSize
.
Width
(
aWritingMode
)
)
;
}
const
SVGAnimatedLength
&
height
=
content
-
>
mLengthAttributes
[
SVGSVGElement
:
:
ATTR_HEIGHT
]
;
NS_ASSERTION
(
aCBSize
.
BSize
(
aWritingMode
)
!
=
NS_UNCONSTRAINEDSIZE
"
root
should
not
have
auto
-
height
containing
block
"
)
;
if
(
height
.
IsPercentage
(
)
)
{
MOZ_ASSERT
(
!
intrinsicSize
.
height
"
GetIntrinsicSize
should
have
reported
no
intrinsic
height
"
)
;
float
val
=
height
.
GetAnimValInSpecifiedUnits
(
)
/
100
.
0f
;
intrinsicSize
.
height
.
emplace
(
std
:
:
max
(
val
0
.
0f
)
*
cbSize
.
Height
(
aWritingMode
)
)
;
}
MOZ_ASSERT
(
intrinsicSize
.
height
&
&
intrinsicSize
.
width
"
We
should
have
just
handled
the
only
situation
where
"
"
we
lack
an
intrinsic
height
or
width
.
"
)
;
}
return
{
ComputeSizeWithIntrinsicDimensions
(
aRenderingContext
aWritingMode
intrinsicSize
GetAspectRatio
(
)
cbSize
aMargin
aBorderPadding
aSizeOverrides
aFlags
)
AspectRatioUsage
:
:
None
}
;
}
void
SVGOuterSVGFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
SVGOuterSVGFrame
"
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
NS_FRAME_TRACE
(
NS_FRAME_TRACE_CALLS
(
"
enter
SVGOuterSVGFrame
:
:
Reflow
:
availSize
=
%
d
%
d
"
aReflowInput
.
AvailableWidth
(
)
aReflowInput
.
AvailableHeight
(
)
)
)
;
MOZ_ASSERT
(
HasAnyStateBits
(
NS_FRAME_IN_REFLOW
)
"
frame
is
not
in
reflow
"
)
;
const
auto
wm
=
GetWritingMode
(
)
;
aDesiredSize
.
SetSize
(
wm
aReflowInput
.
ComputedSizeWithBorderPadding
(
wm
)
)
;
NS_ASSERTION
(
!
GetPrevInFlow
(
)
"
SVG
can
'
t
currently
be
broken
across
pages
.
"
)
;
SVGSVGElement
*
svgElem
=
static_cast
<
SVGSVGElement
*
>
(
GetContent
(
)
)
;
auto
*
anonKid
=
static_cast
<
SVGOuterSVGAnonChildFrame
*
>
(
PrincipalChildList
(
)
.
FirstChild
(
)
)
;
if
(
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
)
{
svgElem
-
>
UpdateHasChildrenOnlyTransform
(
)
;
}
gfx
:
:
Size
newViewportSize
(
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
aReflowInput
.
ComputedWidth
(
)
)
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
aReflowInput
.
ComputedHeight
(
)
)
)
;
uint32_t
changeBits
=
0
;
if
(
newViewportSize
!
=
svgElem
-
>
GetViewportSize
(
)
)
{
if
(
svgElem
-
>
HasViewBoxOrSyntheticViewBox
(
)
)
{
nsIFrame
*
anonChild
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
anonChild
-
>
MarkSubtreeDirty
(
)
;
for
(
nsIFrame
*
child
:
anonChild
-
>
PrincipalChildList
(
)
)
{
child
-
>
MarkSubtreeDirty
(
)
;
}
}
changeBits
|
=
COORD_CONTEXT_CHANGED
;
svgElem
-
>
SetViewportSize
(
newViewportSize
)
;
}
if
(
mIsRootContent
&
&
!
mIsInIframe
)
{
const
auto
oldZoom
=
mFullZoom
;
mFullZoom
=
ComputeFullZoom
(
)
;
if
(
oldZoom
!
=
mFullZoom
)
{
changeBits
|
=
FULL_ZOOM_CHANGED
;
}
}
if
(
changeBits
&
&
!
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
)
{
NotifyViewportOrTransformChanged
(
changeBits
)
;
}
mCallingReflowSVG
=
true
;
if
(
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
)
{
ReflowSVGNonDisplayText
(
this
)
;
}
else
{
anonKid
-
>
ReflowSVG
(
)
;
MOZ_ASSERT
(
!
anonKid
-
>
GetNextSibling
(
)
"
We
should
have
one
anonymous
child
frame
wrapping
our
real
"
"
children
"
)
;
}
mCallingReflowSVG
=
false
;
anonKid
-
>
SetPosition
(
GetContentRectRelativeToSelf
(
)
.
TopLeft
(
)
)
;
aDesiredSize
.
SetOverflowAreasToDesiredBounds
(
)
;
if
(
!
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
)
{
if
(
!
mIsRootContent
)
{
aDesiredSize
.
mOverflowAreas
.
InkOverflow
(
)
.
UnionRect
(
aDesiredSize
.
mOverflowAreas
.
InkOverflow
(
)
anonKid
-
>
InkOverflowRect
(
)
+
anonKid
-
>
GetPosition
(
)
)
;
}
FinishAndStoreOverflow
(
&
aDesiredSize
)
;
}
NS_FRAME_TRACE
(
NS_FRAME_TRACE_CALLS
(
"
exit
SVGOuterSVGFrame
:
:
Reflow
:
size
=
%
d
%
d
"
aDesiredSize
.
Width
(
)
aDesiredSize
.
Height
(
)
)
)
;
}
void
SVGOuterSVGFrame
:
:
DidReflow
(
nsPresContext
*
aPresContext
const
ReflowInput
*
aReflowInput
)
{
SVGDisplayContainerFrame
:
:
DidReflow
(
aPresContext
aReflowInput
)
;
PresShell
(
)
-
>
SynthesizeMouseMove
(
false
)
;
}
void
SVGOuterSVGFrame
:
:
UnionChildOverflow
(
OverflowAreas
&
aOverflowAreas
bool
aAsIfScrolled
)
{
if
(
!
mIsRootContent
)
{
nsIFrame
*
anonKid
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
aOverflowAreas
.
InkOverflow
(
)
.
UnionRect
(
aOverflowAreas
.
InkOverflow
(
)
anonKid
-
>
InkOverflowRect
(
)
+
anonKid
-
>
GetPosition
(
)
)
;
}
}
nsresult
SVGOuterSVGFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
if
(
aNameSpaceID
=
=
kNameSpaceID_None
&
&
!
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
|
NS_FRAME_IS_NONDISPLAY
)
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
viewBox
|
|
aAttribute
=
=
nsGkAtoms
:
:
preserveAspectRatio
)
{
mCanvasTM
=
nullptr
;
SVGUtils
:
:
NotifyChildrenOfSVGChange
(
PrincipalChildList
(
)
.
FirstChild
(
)
aAttribute
=
=
nsGkAtoms
:
:
viewBox
?
TRANSFORM_CHANGED
|
COORD_CONTEXT_CHANGED
:
TRANSFORM_CHANGED
)
;
if
(
aAttribute
!
=
nsGkAtoms
:
:
transform
)
{
static_cast
<
SVGSVGElement
*
>
(
GetContent
(
)
)
-
>
ChildrenOnlyTransformChanged
(
)
;
}
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
width
|
|
aAttribute
=
=
nsGkAtoms
:
:
height
|
|
aAttribute
=
=
nsGkAtoms
:
:
viewBox
)
{
MaybeSendIntrinsicSizeAndRatioToEmbedder
(
)
;
if
(
!
mIsInObjectOrEmbed
)
{
PresShell
(
)
-
>
FrameNeedsReflow
(
this
IntrinsicDirty
:
:
FrameAncestorsAndDescendants
NS_FRAME_IS_DIRTY
)
;
}
}
}
return
NS_OK
;
}
void
SVGOuterSVGFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
if
(
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
)
{
return
;
}
DisplayBorderBackgroundOutline
(
aBuilder
aLists
)
;
nsRect
visibleRect
=
aBuilder
-
>
GetVisibleRect
(
)
;
nsRect
dirtyRect
=
aBuilder
-
>
GetDirtyRect
(
)
;
DisplayListClipState
:
:
AutoSaveRestore
autoSR
(
aBuilder
)
;
if
(
mIsRootContent
|
|
StyleDisplay
(
)
-
>
IsScrollableOverflow
(
)
)
{
autoSR
.
ClipContainingBlockDescendantsToContentBox
(
aBuilder
this
)
;
visibleRect
=
visibleRect
.
Intersect
(
GetContentRectRelativeToSelf
(
)
)
;
dirtyRect
=
dirtyRect
.
Intersect
(
GetContentRectRelativeToSelf
(
)
)
;
}
nsDisplayListBuilder
:
:
AutoBuildingDisplayList
building
(
aBuilder
this
visibleRect
dirtyRect
)
;
nsDisplayList
*
contentList
=
aLists
.
Content
(
)
;
nsDisplayListSet
set
(
contentList
contentList
contentList
contentList
contentList
contentList
)
;
BuildDisplayListForNonBlockChildren
(
aBuilder
set
)
;
}
void
SVGOuterSVGFrame
:
:
NotifyViewportOrTransformChanged
(
uint32_t
aFlags
)
{
MOZ_ASSERT
(
aFlags
&
&
!
(
aFlags
&
~
(
COORD_CONTEXT_CHANGED
|
TRANSFORM_CHANGED
|
FULL_ZOOM_CHANGED
)
)
"
Unexpected
aFlags
value
"
)
;
auto
*
content
=
static_cast
<
SVGSVGElement
*
>
(
GetContent
(
)
)
;
if
(
aFlags
&
COORD_CONTEXT_CHANGED
)
{
if
(
content
-
>
HasViewBox
(
)
)
{
aFlags
=
TRANSFORM_CHANGED
;
}
else
if
(
content
-
>
ShouldSynthesizeViewBox
(
)
)
{
aFlags
|
=
TRANSFORM_CHANGED
;
}
else
if
(
mCanvasTM
&
&
mCanvasTM
-
>
IsSingular
(
)
)
{
aFlags
|
=
TRANSFORM_CHANGED
;
}
}
bool
haveNonFulLZoomTransformChange
=
(
aFlags
&
TRANSFORM_CHANGED
)
;
if
(
aFlags
&
FULL_ZOOM_CHANGED
)
{
aFlags
=
(
aFlags
&
~
FULL_ZOOM_CHANGED
)
|
TRANSFORM_CHANGED
;
}
if
(
aFlags
&
TRANSFORM_CHANGED
)
{
mCanvasTM
=
nullptr
;
if
(
haveNonFulLZoomTransformChange
&
&
!
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
)
{
uint32_t
flags
=
HasAnyStateBits
(
NS_FRAME_IN_REFLOW
)
?
SVGSVGElement
:
:
eDuringReflow
:
0
;
content
-
>
ChildrenOnlyTransformChanged
(
flags
)
;
}
}
SVGUtils
:
:
NotifyChildrenOfSVGChange
(
PrincipalChildList
(
)
.
FirstChild
(
)
aFlags
)
;
}
void
SVGOuterSVGFrame
:
:
PaintSVG
(
gfxContext
&
aContext
const
gfxMatrix
&
aTransform
imgDrawingParams
&
aImgParams
)
{
NS_ASSERTION
(
PrincipalChildList
(
)
.
FirstChild
(
)
-
>
IsSVGOuterSVGAnonChildFrame
(
)
&
&
!
PrincipalChildList
(
)
.
FirstChild
(
)
-
>
GetNextSibling
(
)
"
We
should
have
a
single
anonymous
child
"
)
;
auto
*
anonKid
=
static_cast
<
SVGOuterSVGAnonChildFrame
*
>
(
PrincipalChildList
(
)
.
FirstChild
(
)
)
;
anonKid
-
>
PaintSVG
(
aContext
aTransform
aImgParams
)
;
}
SVGBBox
SVGOuterSVGFrame
:
:
GetBBoxContribution
(
const
gfx
:
:
Matrix
&
aToBBoxUserspace
uint32_t
aFlags
)
{
NS_ASSERTION
(
PrincipalChildList
(
)
.
FirstChild
(
)
-
>
IsSVGOuterSVGAnonChildFrame
(
)
&
&
!
PrincipalChildList
(
)
.
FirstChild
(
)
-
>
GetNextSibling
(
)
"
We
should
have
a
single
anonymous
child
"
)
;
auto
*
anonKid
=
static_cast
<
SVGOuterSVGAnonChildFrame
*
>
(
PrincipalChildList
(
)
.
FirstChild
(
)
)
;
return
anonKid
-
>
GetBBoxContribution
(
aToBBoxUserspace
aFlags
)
;
}
gfxMatrix
SVGOuterSVGFrame
:
:
GetCanvasTM
(
)
{
if
(
!
mCanvasTM
)
{
auto
*
content
=
static_cast
<
SVGSVGElement
*
>
(
GetContent
(
)
)
;
float
devPxPerCSSPx
=
1
.
0f
/
nsPresContext
:
:
AppUnitsToFloatCSSPixels
(
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
)
;
gfxMatrix
tm
=
content
-
>
ChildToUserSpaceTransform
(
)
.
PostScale
(
devPxPerCSSPx
devPxPerCSSPx
)
;
mCanvasTM
=
MakeUnique
<
gfxMatrix
>
(
tm
)
;
}
return
*
mCanvasTM
;
}
bool
SVGOuterSVGFrame
:
:
IsRootOfImage
(
)
{
if
(
!
mContent
-
>
GetParent
(
)
)
{
Document
*
doc
=
mContent
-
>
GetUncomposedDoc
(
)
;
if
(
doc
&
&
doc
-
>
IsBeingUsedAsImage
(
)
)
{
return
true
;
}
}
return
false
;
}
bool
SVGOuterSVGFrame
:
:
VerticalScrollbarNotNeeded
(
)
const
{
const
SVGAnimatedLength
&
height
=
static_cast
<
SVGSVGElement
*
>
(
GetContent
(
)
)
-
>
mLengthAttributes
[
SVGSVGElement
:
:
ATTR_HEIGHT
]
;
return
height
.
IsPercentage
(
)
&
&
height
.
GetBaseValInSpecifiedUnits
(
)
<
=
100
;
}
void
SVGOuterSVGFrame
:
:
AppendDirectlyOwnedAnonBoxes
(
nsTArray
<
OwnedAnonBox
>
&
aResult
)
{
nsIFrame
*
anonKid
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
MOZ_ASSERT
(
anonKid
-
>
IsSVGOuterSVGAnonChildFrame
(
)
)
;
aResult
.
AppendElement
(
OwnedAnonBox
(
anonKid
)
)
;
}
void
SVGOuterSVGFrame
:
:
MaybeSendIntrinsicSizeAndRatioToEmbedder
(
)
{
MaybeSendIntrinsicSizeAndRatioToEmbedder
(
Some
(
GetIntrinsicSize
(
)
)
Some
(
GetAspectRatio
(
)
)
)
;
}
void
SVGOuterSVGFrame
:
:
MaybeSendIntrinsicSizeAndRatioToEmbedder
(
Maybe
<
IntrinsicSize
>
aIntrinsicSize
Maybe
<
AspectRatio
>
aIntrinsicRatio
)
{
if
(
!
mIsInObjectOrEmbed
)
{
return
;
}
nsCOMPtr
<
nsIDocShell
>
docShell
=
PresContext
(
)
-
>
GetDocShell
(
)
;
if
(
!
docShell
)
{
return
;
}
BrowsingContext
*
bc
=
docShell
-
>
GetBrowsingContext
(
)
;
MOZ_ASSERT
(
bc
-
>
IsContentSubframe
(
)
)
;
if
(
bc
-
>
GetParent
(
)
-
>
IsInProcess
(
)
)
{
if
(
Element
*
embedder
=
bc
-
>
GetEmbedderElement
(
)
)
{
if
(
nsCOMPtr
<
nsIObjectLoadingContent
>
olc
=
do_QueryInterface
(
embedder
)
)
{
static_cast
<
nsObjectLoadingContent
*
>
(
olc
.
get
(
)
)
-
>
SubdocumentIntrinsicSizeOrRatioChanged
(
aIntrinsicSize
aIntrinsicRatio
)
;
}
return
;
}
}
if
(
BrowserChild
*
browserChild
=
BrowserChild
:
:
GetFrom
(
docShell
)
)
{
Unused
<
<
browserChild
-
>
SendIntrinsicSizeOrRatioChanged
(
aIntrinsicSize
aIntrinsicRatio
)
;
}
}
void
SVGOuterSVGFrame
:
:
DidSetComputedStyle
(
ComputedStyle
*
aOldComputedStyle
)
{
SVGDisplayContainerFrame
:
:
DidSetComputedStyle
(
aOldComputedStyle
)
;
if
(
!
aOldComputedStyle
)
{
return
;
}
if
(
aOldComputedStyle
-
>
StylePosition
(
)
-
>
mAspectRatio
!
=
StylePosition
(
)
-
>
mAspectRatio
)
{
MaybeSendIntrinsicSizeAndRatioToEmbedder
(
)
;
}
}
void
SVGOuterSVGFrame
:
:
Destroy
(
DestroyContext
&
aContext
)
{
MaybeSendIntrinsicSizeAndRatioToEmbedder
(
Nothing
(
)
Nothing
(
)
)
;
SVGDisplayContainerFrame
:
:
Destroy
(
aContext
)
;
}
}
nsContainerFrame
*
NS_NewSVGOuterSVGAnonChildFrame
(
mozilla
:
:
PresShell
*
aPresShell
mozilla
:
:
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
mozilla
:
:
SVGOuterSVGAnonChildFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
namespace
mozilla
{
NS_IMPL_FRAMEARENA_HELPERS
(
SVGOuterSVGAnonChildFrame
)
#
ifdef
DEBUG
void
SVGOuterSVGAnonChildFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
MOZ_ASSERT
(
aParent
-
>
IsSVGOuterSVGFrame
(
)
"
Unexpected
parent
"
)
;
SVGDisplayContainerFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
}
#
endif
void
SVGOuterSVGAnonChildFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
nsDisplayList
newList
(
aBuilder
)
;
nsDisplayListSet
set
(
&
newList
&
newList
&
newList
&
newList
&
newList
&
newList
)
;
BuildDisplayListForNonBlockChildren
(
aBuilder
set
)
;
aLists
.
Content
(
)
-
>
AppendNewToTop
<
nsDisplaySVGWrapper
>
(
aBuilder
this
&
newList
)
;
}
bool
SVGOuterSVGFrame
:
:
HasChildrenOnlyTransform
(
Matrix
*
aTransform
)
const
{
auto
*
content
=
static_cast
<
SVGSVGElement
*
>
(
GetContent
(
)
)
;
if
(
!
content
-
>
HasChildrenOnlyTransform
(
)
)
{
return
false
;
}
if
(
aTransform
)
{
*
aTransform
=
gfx
:
:
ToMatrix
(
content
-
>
ChildToUserSpaceTransform
(
)
)
;
if
(
aTransform
-
>
HasNonTranslation
(
)
)
{
MOZ_ASSERT
(
aTransform
-
>
IsRectilinear
(
)
"
Non
-
rectilinear
transform
will
break
the
following
logic
"
)
;
CSSPoint
pos
=
CSSPixel
:
:
FromAppUnits
(
GetContentRectRelativeToSelf
(
)
.
TopLeft
(
)
)
;
CSSPoint
scaledPos
=
CSSPoint
(
aTransform
-
>
_11
*
pos
.
x
aTransform
-
>
_22
*
pos
.
y
)
;
CSSPoint
deltaPos
=
scaledPos
-
pos
;
*
aTransform
*
=
Matrix
:
:
Translation
(
-
deltaPos
.
x
-
deltaPos
.
y
)
;
}
}
return
true
;
}
bool
SVGOuterSVGAnonChildFrame
:
:
DoGetParentSVGTransforms
(
Matrix
*
aFromParentTransform
)
const
{
SVGUtils
:
:
GetParentSVGTransforms
(
this
aFromParentTransform
)
;
return
true
;
}
}
