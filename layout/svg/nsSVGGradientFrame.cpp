#
include
"
nsSVGGradientFrame
.
h
"
#
include
<
algorithm
>
#
include
"
AutoReferenceChainGuard
.
h
"
#
include
"
gfxPattern
.
h
"
#
include
"
mozilla
/
dom
/
SVGGradientElement
.
h
"
#
include
"
mozilla
/
dom
/
SVGGradientElementBinding
.
h
"
#
include
"
mozilla
/
dom
/
SVGStopElement
.
h
"
#
include
"
mozilla
/
dom
/
SVGUnitTypesBinding
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
SVGObserverUtils
.
h
"
#
include
"
nsSVGAnimatedTransformList
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
dom
:
:
SVGGradientElement_Binding
;
using
namespace
mozilla
:
:
dom
:
:
SVGUnitTypes_Binding
;
using
namespace
mozilla
:
:
gfx
;
nsSVGGradientFrame
:
:
nsSVGGradientFrame
(
ComputedStyle
*
aStyle
ClassID
aID
)
:
nsSVGPaintServerFrame
(
aStyle
aID
)
mSource
(
nullptr
)
mLoopFlag
(
false
)
mNoHRefURI
(
false
)
{
}
nsresult
nsSVGGradientFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
if
(
aNameSpaceID
=
=
kNameSpaceID_None
&
&
(
aAttribute
=
=
nsGkAtoms
:
:
gradientUnits
|
|
aAttribute
=
=
nsGkAtoms
:
:
gradientTransform
|
|
aAttribute
=
=
nsGkAtoms
:
:
spreadMethod
)
)
{
SVGObserverUtils
:
:
InvalidateDirectRenderingObservers
(
this
)
;
}
else
if
(
(
aNameSpaceID
=
=
kNameSpaceID_XLink
|
|
aNameSpaceID
=
=
kNameSpaceID_None
)
&
&
aAttribute
=
=
nsGkAtoms
:
:
href
)
{
SVGObserverUtils
:
:
RemoveTemplateObserver
(
this
)
;
mNoHRefURI
=
false
;
SVGObserverUtils
:
:
InvalidateDirectRenderingObservers
(
this
)
;
}
return
nsSVGPaintServerFrame
:
:
AttributeChanged
(
aNameSpaceID
aAttribute
aModType
)
;
}
uint16_t
nsSVGGradientFrame
:
:
GetEnumValue
(
uint32_t
aIndex
nsIContent
*
aDefault
)
{
const
nsSVGEnum
&
thisEnum
=
static_cast
<
dom
:
:
SVGGradientElement
*
>
(
GetContent
(
)
)
-
>
mEnumAttributes
[
aIndex
]
;
if
(
thisEnum
.
IsExplicitlySet
(
)
)
return
thisEnum
.
GetAnimValue
(
)
;
static
int16_t
sRefChainLengthCounter
=
AutoReferenceChainGuard
:
:
noChain
;
AutoReferenceChainGuard
refChainGuard
(
this
&
mLoopFlag
&
sRefChainLengthCounter
)
;
if
(
MOZ_UNLIKELY
(
!
refChainGuard
.
Reference
(
)
)
)
{
return
static_cast
<
dom
:
:
SVGGradientElement
*
>
(
aDefault
)
-
>
mEnumAttributes
[
aIndex
]
.
GetAnimValue
(
)
;
}
nsSVGGradientFrame
*
next
=
GetReferencedGradient
(
)
;
return
next
?
next
-
>
GetEnumValue
(
aIndex
aDefault
)
:
static_cast
<
dom
:
:
SVGGradientElement
*
>
(
aDefault
)
-
>
mEnumAttributes
[
aIndex
]
.
GetAnimValue
(
)
;
}
uint16_t
nsSVGGradientFrame
:
:
GetGradientUnits
(
)
{
return
GetEnumValue
(
dom
:
:
SVGGradientElement
:
:
GRADIENTUNITS
)
;
}
uint16_t
nsSVGGradientFrame
:
:
GetSpreadMethod
(
)
{
return
GetEnumValue
(
dom
:
:
SVGGradientElement
:
:
SPREADMETHOD
)
;
}
const
nsSVGAnimatedTransformList
*
nsSVGGradientFrame
:
:
GetGradientTransformList
(
nsIContent
*
aDefault
)
{
nsSVGAnimatedTransformList
*
thisTransformList
=
static_cast
<
dom
:
:
SVGGradientElement
*
>
(
GetContent
(
)
)
-
>
GetAnimatedTransformList
(
)
;
if
(
thisTransformList
&
&
thisTransformList
-
>
IsExplicitlySet
(
)
)
return
thisTransformList
;
static
int16_t
sRefChainLengthCounter
=
AutoReferenceChainGuard
:
:
noChain
;
AutoReferenceChainGuard
refChainGuard
(
this
&
mLoopFlag
&
sRefChainLengthCounter
)
;
if
(
MOZ_UNLIKELY
(
!
refChainGuard
.
Reference
(
)
)
)
{
return
static_cast
<
const
dom
:
:
SVGGradientElement
*
>
(
aDefault
)
-
>
mGradientTransform
.
get
(
)
;
}
nsSVGGradientFrame
*
next
=
GetReferencedGradient
(
)
;
return
next
?
next
-
>
GetGradientTransformList
(
aDefault
)
:
static_cast
<
const
dom
:
:
SVGGradientElement
*
>
(
aDefault
)
-
>
mGradientTransform
.
get
(
)
;
}
gfxMatrix
nsSVGGradientFrame
:
:
GetGradientTransform
(
nsIFrame
*
aSource
const
gfxRect
*
aOverrideBounds
)
{
gfxMatrix
bboxMatrix
;
uint16_t
gradientUnits
=
GetGradientUnits
(
)
;
if
(
gradientUnits
!
=
SVG_UNIT_TYPE_USERSPACEONUSE
)
{
NS_ASSERTION
(
gradientUnits
=
=
SVG_UNIT_TYPE_OBJECTBOUNDINGBOX
"
Unknown
gradientUnits
type
"
)
;
gfxRect
bbox
=
aOverrideBounds
?
*
aOverrideBounds
:
nsSVGUtils
:
:
GetBBox
(
aSource
nsSVGUtils
:
:
eUseFrameBoundsForOuterSVG
|
nsSVGUtils
:
:
eBBoxIncludeFillGeometry
)
;
bboxMatrix
=
gfxMatrix
(
bbox
.
Width
(
)
0
0
bbox
.
Height
(
)
bbox
.
X
(
)
bbox
.
Y
(
)
)
;
}
const
nsSVGAnimatedTransformList
*
animTransformList
=
GetGradientTransformList
(
GetContent
(
)
)
;
if
(
!
animTransformList
)
return
bboxMatrix
;
gfxMatrix
gradientTransform
=
animTransformList
-
>
GetAnimValue
(
)
.
GetConsolidationMatrix
(
)
;
return
bboxMatrix
.
PreMultiply
(
gradientTransform
)
;
}
dom
:
:
SVGLinearGradientElement
*
nsSVGGradientFrame
:
:
GetLinearGradientWithLength
(
uint32_t
aIndex
dom
:
:
SVGLinearGradientElement
*
aDefault
)
{
static
int16_t
sRefChainLengthCounter
=
AutoReferenceChainGuard
:
:
noChain
;
AutoReferenceChainGuard
refChainGuard
(
this
&
mLoopFlag
&
sRefChainLengthCounter
)
;
if
(
MOZ_UNLIKELY
(
!
refChainGuard
.
Reference
(
)
)
)
{
return
aDefault
;
}
nsSVGGradientFrame
*
next
=
GetReferencedGradient
(
)
;
return
next
?
next
-
>
GetLinearGradientWithLength
(
aIndex
aDefault
)
:
aDefault
;
}
dom
:
:
SVGRadialGradientElement
*
nsSVGGradientFrame
:
:
GetRadialGradientWithLength
(
uint32_t
aIndex
dom
:
:
SVGRadialGradientElement
*
aDefault
)
{
static
int16_t
sRefChainLengthCounter
=
AutoReferenceChainGuard
:
:
noChain
;
AutoReferenceChainGuard
refChainGuard
(
this
&
mLoopFlag
&
sRefChainLengthCounter
)
;
if
(
MOZ_UNLIKELY
(
!
refChainGuard
.
Reference
(
)
)
)
{
return
aDefault
;
}
nsSVGGradientFrame
*
next
=
GetReferencedGradient
(
)
;
return
next
?
next
-
>
GetRadialGradientWithLength
(
aIndex
aDefault
)
:
aDefault
;
}
static
void
GetStopInformation
(
nsIFrame
*
aStopFrame
float
*
aOffset
nscolor
*
aStopColor
float
*
aStopOpacity
)
{
nsIContent
*
stopContent
=
aStopFrame
-
>
GetContent
(
)
;
MOZ_ASSERT
(
stopContent
&
&
stopContent
-
>
IsSVGElement
(
nsGkAtoms
:
:
stop
)
)
;
static_cast
<
SVGStopElement
*
>
(
stopContent
)
-
>
GetAnimatedNumberValues
(
aOffset
nullptr
)
;
const
nsStyleSVGReset
*
styleSVGReset
=
aStopFrame
-
>
StyleSVGReset
(
)
;
*
aOffset
=
mozilla
:
:
clamped
(
*
aOffset
0
.
0f
1
.
0f
)
;
*
aStopColor
=
styleSVGReset
-
>
mStopColor
.
CalcColor
(
aStopFrame
)
;
*
aStopOpacity
=
styleSVGReset
-
>
mStopOpacity
;
}
already_AddRefed
<
gfxPattern
>
nsSVGGradientFrame
:
:
GetPaintServerPattern
(
nsIFrame
*
aSource
const
DrawTarget
*
aDrawTarget
const
gfxMatrix
&
aContextMatrix
nsStyleSVGPaint
nsStyleSVG
:
:
*
aFillOrStroke
float
aGraphicOpacity
imgDrawingParams
&
aImgParams
const
gfxRect
*
aOverrideBounds
)
{
uint16_t
gradientUnits
=
GetGradientUnits
(
)
;
MOZ_ASSERT
(
gradientUnits
=
=
SVG_UNIT_TYPE_OBJECTBOUNDINGBOX
|
|
gradientUnits
=
=
SVG_UNIT_TYPE_USERSPACEONUSE
)
;
if
(
gradientUnits
=
=
SVG_UNIT_TYPE_USERSPACEONUSE
)
{
mSource
=
aSource
-
>
GetContent
(
)
-
>
IsText
(
)
?
aSource
-
>
GetParent
(
)
:
aSource
;
}
AutoTArray
<
nsIFrame
*
8
>
stopFrames
;
GetStopFrames
(
&
stopFrames
)
;
uint32_t
nStops
=
stopFrames
.
Length
(
)
;
if
(
nStops
=
=
0
)
{
RefPtr
<
gfxPattern
>
pattern
=
new
gfxPattern
(
Color
(
)
)
;
return
do_AddRef
(
new
gfxPattern
(
Color
(
)
)
)
;
}
if
(
nStops
=
=
1
|
|
GradientVectorLengthIsZero
(
)
)
{
auto
lastStopFrame
=
stopFrames
[
nStops
-
1
]
;
auto
svgReset
=
lastStopFrame
-
>
StyleSVGReset
(
)
;
float
stopOpacity
=
svgReset
-
>
mStopOpacity
;
nscolor
stopColor
=
svgReset
-
>
mStopColor
.
CalcColor
(
lastStopFrame
)
;
Color
stopColor2
=
Color
:
:
FromABGR
(
stopColor
)
;
stopColor2
.
a
*
=
stopOpacity
*
aGraphicOpacity
;
return
do_AddRef
(
new
gfxPattern
(
stopColor2
)
)
;
}
gfxMatrix
patternMatrix
=
GetGradientTransform
(
aSource
aOverrideBounds
)
;
if
(
patternMatrix
.
IsSingular
(
)
)
{
return
nullptr
;
}
if
(
aFillOrStroke
=
=
&
nsStyleSVG
:
:
mStroke
)
{
gfxMatrix
userToOuterSVG
;
if
(
nsSVGUtils
:
:
GetNonScalingStrokeTransform
(
aSource
&
userToOuterSVG
)
)
{
patternMatrix
*
=
userToOuterSVG
;
}
}
if
(
!
patternMatrix
.
Invert
(
)
)
{
return
nullptr
;
}
RefPtr
<
gfxPattern
>
gradient
=
CreateGradient
(
)
;
if
(
!
gradient
)
{
return
nullptr
;
}
uint16_t
aSpread
=
GetSpreadMethod
(
)
;
if
(
aSpread
=
=
SVG_SPREADMETHOD_PAD
)
gradient
-
>
SetExtend
(
ExtendMode
:
:
CLAMP
)
;
else
if
(
aSpread
=
=
SVG_SPREADMETHOD_REFLECT
)
gradient
-
>
SetExtend
(
ExtendMode
:
:
REFLECT
)
;
else
if
(
aSpread
=
=
SVG_SPREADMETHOD_REPEAT
)
gradient
-
>
SetExtend
(
ExtendMode
:
:
REPEAT
)
;
gradient
-
>
SetMatrix
(
patternMatrix
)
;
float
lastOffset
=
0
.
0f
;
for
(
uint32_t
i
=
0
;
i
<
nStops
;
i
+
+
)
{
float
offset
stopOpacity
;
nscolor
stopColor
;
GetStopInformation
(
stopFrames
[
i
]
&
offset
&
stopColor
&
stopOpacity
)
;
if
(
offset
<
lastOffset
)
offset
=
lastOffset
;
else
lastOffset
=
offset
;
Color
stopColor2
=
Color
:
:
FromABGR
(
stopColor
)
;
stopColor2
.
a
*
=
stopOpacity
*
aGraphicOpacity
;
gradient
-
>
AddColorStop
(
offset
stopColor2
)
;
}
return
gradient
.
forget
(
)
;
}
nsSVGGradientFrame
*
nsSVGGradientFrame
:
:
GetReferencedGradient
(
)
{
if
(
mNoHRefURI
)
{
return
nullptr
;
}
auto
GetHref
=
[
this
]
(
nsAString
&
aHref
)
{
dom
:
:
SVGGradientElement
*
grad
=
static_cast
<
dom
:
:
SVGGradientElement
*
>
(
this
-
>
GetContent
(
)
)
;
if
(
grad
-
>
mStringAttributes
[
dom
:
:
SVGGradientElement
:
:
HREF
]
.
IsExplicitlySet
(
)
)
{
grad
-
>
mStringAttributes
[
dom
:
:
SVGGradientElement
:
:
HREF
]
.
GetAnimValue
(
aHref
grad
)
;
}
else
{
grad
-
>
mStringAttributes
[
dom
:
:
SVGGradientElement
:
:
XLINK_HREF
]
.
GetAnimValue
(
aHref
grad
)
;
}
this
-
>
mNoHRefURI
=
aHref
.
IsEmpty
(
)
;
}
;
nsIFrame
*
tframe
=
SVGObserverUtils
:
:
GetAndObserveTemplate
(
this
GetHref
)
;
if
(
tframe
)
{
LayoutFrameType
frameType
=
tframe
-
>
Type
(
)
;
if
(
frameType
=
=
LayoutFrameType
:
:
SVGLinearGradient
|
|
frameType
=
=
LayoutFrameType
:
:
SVGRadialGradient
)
{
return
static_cast
<
nsSVGGradientFrame
*
>
(
tframe
)
;
}
}
return
nullptr
;
}
void
nsSVGGradientFrame
:
:
GetStopFrames
(
nsTArray
<
nsIFrame
*
>
*
aStopFrames
)
{
nsIFrame
*
stopFrame
=
nullptr
;
for
(
stopFrame
=
mFrames
.
FirstChild
(
)
;
stopFrame
;
stopFrame
=
stopFrame
-
>
GetNextSibling
(
)
)
{
if
(
stopFrame
-
>
IsSVGStopFrame
(
)
)
{
aStopFrames
-
>
AppendElement
(
stopFrame
)
;
}
}
if
(
aStopFrames
-
>
Length
(
)
>
0
)
{
return
;
}
static
int16_t
sRefChainLengthCounter
=
AutoReferenceChainGuard
:
:
noChain
;
AutoReferenceChainGuard
refChainGuard
(
this
&
mLoopFlag
&
sRefChainLengthCounter
)
;
if
(
MOZ_UNLIKELY
(
!
refChainGuard
.
Reference
(
)
)
)
{
return
;
}
nsSVGGradientFrame
*
next
=
GetReferencedGradient
(
)
;
if
(
next
)
{
next
-
>
GetStopFrames
(
aStopFrames
)
;
}
}
#
ifdef
DEBUG
void
nsSVGLinearGradientFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
NS_ASSERTION
(
aContent
-
>
IsSVGElement
(
nsGkAtoms
:
:
linearGradient
)
"
Content
is
not
an
SVG
linearGradient
"
)
;
nsSVGGradientFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
}
#
endif
nsresult
nsSVGLinearGradientFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
if
(
aNameSpaceID
=
=
kNameSpaceID_None
&
&
(
aAttribute
=
=
nsGkAtoms
:
:
x1
|
|
aAttribute
=
=
nsGkAtoms
:
:
y1
|
|
aAttribute
=
=
nsGkAtoms
:
:
x2
|
|
aAttribute
=
=
nsGkAtoms
:
:
y2
)
)
{
SVGObserverUtils
:
:
InvalidateDirectRenderingObservers
(
this
)
;
}
return
nsSVGGradientFrame
:
:
AttributeChanged
(
aNameSpaceID
aAttribute
aModType
)
;
}
float
nsSVGLinearGradientFrame
:
:
GetLengthValue
(
uint32_t
aIndex
)
{
dom
:
:
SVGLinearGradientElement
*
lengthElement
=
GetLinearGradientWithLength
(
aIndex
static_cast
<
dom
:
:
SVGLinearGradientElement
*
>
(
GetContent
(
)
)
)
;
MOZ_ASSERT
(
lengthElement
"
Got
unexpected
null
element
from
GetLinearGradientWithLength
"
)
;
const
nsSVGLength2
&
length
=
lengthElement
-
>
mLengthAttributes
[
aIndex
]
;
uint16_t
gradientUnits
=
GetGradientUnits
(
)
;
if
(
gradientUnits
=
=
SVG_UNIT_TYPE_USERSPACEONUSE
)
{
return
nsSVGUtils
:
:
UserSpace
(
mSource
&
length
)
;
}
NS_ASSERTION
(
gradientUnits
=
=
SVG_UNIT_TYPE_OBJECTBOUNDINGBOX
"
Unknown
gradientUnits
type
"
)
;
return
length
.
GetAnimValue
(
static_cast
<
SVGViewportElement
*
>
(
nullptr
)
)
;
}
dom
:
:
SVGLinearGradientElement
*
nsSVGLinearGradientFrame
:
:
GetLinearGradientWithLength
(
uint32_t
aIndex
dom
:
:
SVGLinearGradientElement
*
aDefault
)
{
dom
:
:
SVGLinearGradientElement
*
thisElement
=
static_cast
<
dom
:
:
SVGLinearGradientElement
*
>
(
GetContent
(
)
)
;
const
nsSVGLength2
&
length
=
thisElement
-
>
mLengthAttributes
[
aIndex
]
;
if
(
length
.
IsExplicitlySet
(
)
)
{
return
thisElement
;
}
return
nsSVGGradientFrame
:
:
GetLinearGradientWithLength
(
aIndex
aDefault
)
;
}
bool
nsSVGLinearGradientFrame
:
:
GradientVectorLengthIsZero
(
)
{
return
GetLengthValue
(
dom
:
:
SVGLinearGradientElement
:
:
ATTR_X1
)
=
=
GetLengthValue
(
dom
:
:
SVGLinearGradientElement
:
:
ATTR_X2
)
&
&
GetLengthValue
(
dom
:
:
SVGLinearGradientElement
:
:
ATTR_Y1
)
=
=
GetLengthValue
(
dom
:
:
SVGLinearGradientElement
:
:
ATTR_Y2
)
;
}
already_AddRefed
<
gfxPattern
>
nsSVGLinearGradientFrame
:
:
CreateGradient
(
)
{
float
x1
y1
x2
y2
;
x1
=
GetLengthValue
(
dom
:
:
SVGLinearGradientElement
:
:
ATTR_X1
)
;
y1
=
GetLengthValue
(
dom
:
:
SVGLinearGradientElement
:
:
ATTR_Y1
)
;
x2
=
GetLengthValue
(
dom
:
:
SVGLinearGradientElement
:
:
ATTR_X2
)
;
y2
=
GetLengthValue
(
dom
:
:
SVGLinearGradientElement
:
:
ATTR_Y2
)
;
RefPtr
<
gfxPattern
>
pattern
=
new
gfxPattern
(
x1
y1
x2
y2
)
;
return
pattern
.
forget
(
)
;
}
#
ifdef
DEBUG
void
nsSVGRadialGradientFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
NS_ASSERTION
(
aContent
-
>
IsSVGElement
(
nsGkAtoms
:
:
radialGradient
)
"
Content
is
not
an
SVG
radialGradient
"
)
;
nsSVGGradientFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
}
#
endif
nsresult
nsSVGRadialGradientFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
if
(
aNameSpaceID
=
=
kNameSpaceID_None
&
&
(
aAttribute
=
=
nsGkAtoms
:
:
r
|
|
aAttribute
=
=
nsGkAtoms
:
:
cx
|
|
aAttribute
=
=
nsGkAtoms
:
:
cy
|
|
aAttribute
=
=
nsGkAtoms
:
:
fx
|
|
aAttribute
=
=
nsGkAtoms
:
:
fy
)
)
{
SVGObserverUtils
:
:
InvalidateDirectRenderingObservers
(
this
)
;
}
return
nsSVGGradientFrame
:
:
AttributeChanged
(
aNameSpaceID
aAttribute
aModType
)
;
}
float
nsSVGRadialGradientFrame
:
:
GetLengthValue
(
uint32_t
aIndex
)
{
dom
:
:
SVGRadialGradientElement
*
lengthElement
=
GetRadialGradientWithLength
(
aIndex
static_cast
<
dom
:
:
SVGRadialGradientElement
*
>
(
GetContent
(
)
)
)
;
MOZ_ASSERT
(
lengthElement
"
Got
unexpected
null
element
from
GetRadialGradientWithLength
"
)
;
return
GetLengthValueFromElement
(
aIndex
*
lengthElement
)
;
}
float
nsSVGRadialGradientFrame
:
:
GetLengthValue
(
uint32_t
aIndex
float
aDefaultValue
)
{
dom
:
:
SVGRadialGradientElement
*
lengthElement
=
GetRadialGradientWithLength
(
aIndex
nullptr
)
;
return
lengthElement
?
GetLengthValueFromElement
(
aIndex
*
lengthElement
)
:
aDefaultValue
;
}
float
nsSVGRadialGradientFrame
:
:
GetLengthValueFromElement
(
uint32_t
aIndex
dom
:
:
SVGRadialGradientElement
&
aElement
)
{
const
nsSVGLength2
&
length
=
aElement
.
mLengthAttributes
[
aIndex
]
;
uint16_t
gradientUnits
=
GetGradientUnits
(
)
;
if
(
gradientUnits
=
=
SVG_UNIT_TYPE_USERSPACEONUSE
)
{
return
nsSVGUtils
:
:
UserSpace
(
mSource
&
length
)
;
}
NS_ASSERTION
(
gradientUnits
=
=
SVG_UNIT_TYPE_OBJECTBOUNDINGBOX
"
Unknown
gradientUnits
type
"
)
;
return
length
.
GetAnimValue
(
static_cast
<
SVGViewportElement
*
>
(
nullptr
)
)
;
}
dom
:
:
SVGRadialGradientElement
*
nsSVGRadialGradientFrame
:
:
GetRadialGradientWithLength
(
uint32_t
aIndex
dom
:
:
SVGRadialGradientElement
*
aDefault
)
{
dom
:
:
SVGRadialGradientElement
*
thisElement
=
static_cast
<
dom
:
:
SVGRadialGradientElement
*
>
(
GetContent
(
)
)
;
const
nsSVGLength2
&
length
=
thisElement
-
>
mLengthAttributes
[
aIndex
]
;
if
(
length
.
IsExplicitlySet
(
)
)
{
return
thisElement
;
}
return
nsSVGGradientFrame
:
:
GetRadialGradientWithLength
(
aIndex
aDefault
)
;
}
bool
nsSVGRadialGradientFrame
:
:
GradientVectorLengthIsZero
(
)
{
return
GetLengthValue
(
dom
:
:
SVGRadialGradientElement
:
:
ATTR_R
)
=
=
0
;
}
already_AddRefed
<
gfxPattern
>
nsSVGRadialGradientFrame
:
:
CreateGradient
(
)
{
float
cx
cy
r
fx
fy
fr
;
cx
=
GetLengthValue
(
dom
:
:
SVGRadialGradientElement
:
:
ATTR_CX
)
;
cy
=
GetLengthValue
(
dom
:
:
SVGRadialGradientElement
:
:
ATTR_CY
)
;
r
=
GetLengthValue
(
dom
:
:
SVGRadialGradientElement
:
:
ATTR_R
)
;
fx
=
GetLengthValue
(
dom
:
:
SVGRadialGradientElement
:
:
ATTR_FX
cx
)
;
fy
=
GetLengthValue
(
dom
:
:
SVGRadialGradientElement
:
:
ATTR_FY
cy
)
;
fr
=
GetLengthValue
(
dom
:
:
SVGRadialGradientElement
:
:
ATTR_FR
)
;
if
(
fx
!
=
cx
|
|
fy
!
=
cy
)
{
double
dMax
=
std
:
:
max
(
0
.
0
r
-
1
.
0
/
128
)
;
float
dx
=
fx
-
cx
;
float
dy
=
fy
-
cy
;
double
d
=
sqrt
(
(
dx
*
dx
)
+
(
dy
*
dy
)
)
;
if
(
d
>
dMax
)
{
double
angle
=
atan2
(
dy
dx
)
;
fx
=
(
float
)
(
dMax
*
cos
(
angle
)
)
+
cx
;
fy
=
(
float
)
(
dMax
*
sin
(
angle
)
)
+
cy
;
}
}
RefPtr
<
gfxPattern
>
pattern
=
new
gfxPattern
(
fx
fy
fr
cx
cy
r
)
;
return
pattern
.
forget
(
)
;
}
nsIFrame
*
NS_NewSVGLinearGradientFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsSVGLinearGradientFrame
(
aStyle
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsSVGLinearGradientFrame
)
nsIFrame
*
NS_NewSVGRadialGradientFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsSVGRadialGradientFrame
(
aStyle
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsSVGRadialGradientFrame
)
