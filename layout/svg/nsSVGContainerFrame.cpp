#
include
"
nsSVGContainerFrame
.
h
"
#
include
"
ImgDrawResult
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
SVGObserverUtils
.
h
"
#
include
"
SVGElement
.
h
"
#
include
"
nsSVGUtils
.
h
"
#
include
"
SVGAnimatedTransformList
.
h
"
#
include
"
SVGTextFrame
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
image
;
NS_QUERYFRAME_HEAD
(
nsSVGContainerFrame
)
NS_QUERYFRAME_ENTRY
(
nsSVGContainerFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsContainerFrame
)
NS_QUERYFRAME_HEAD
(
nsSVGDisplayContainerFrame
)
NS_QUERYFRAME_ENTRY
(
nsSVGDisplayContainerFrame
)
NS_QUERYFRAME_ENTRY
(
nsSVGDisplayableFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsSVGContainerFrame
)
nsIFrame
*
NS_NewSVGContainerFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
nsIFrame
*
frame
=
new
(
aPresShell
)
nsSVGContainerFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
nsSVGContainerFrame
:
:
kClassID
)
;
frame
-
>
AddStateBits
(
NS_FRAME_IS_NONDISPLAY
)
;
return
frame
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsSVGContainerFrame
)
void
nsSVGContainerFrame
:
:
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
{
InsertFrames
(
aListID
mFrames
.
LastChild
(
)
aFrameList
)
;
}
void
nsSVGContainerFrame
:
:
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
aFrameList
)
{
NS_ASSERTION
(
aListID
=
=
kPrincipalList
"
unexpected
child
list
"
)
;
NS_ASSERTION
(
!
aPrevFrame
|
|
aPrevFrame
-
>
GetParent
(
)
=
=
this
"
inserting
after
sibling
frame
with
different
parent
"
)
;
mFrames
.
InsertFrames
(
this
aPrevFrame
aFrameList
)
;
}
void
nsSVGContainerFrame
:
:
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
{
NS_ASSERTION
(
aListID
=
=
kPrincipalList
"
unexpected
child
list
"
)
;
mFrames
.
DestroyFrame
(
aOldFrame
)
;
}
bool
nsSVGContainerFrame
:
:
ComputeCustomOverflow
(
nsOverflowAreas
&
aOverflowAreas
)
{
if
(
mState
&
NS_FRAME_IS_NONDISPLAY
)
{
return
false
;
}
return
nsContainerFrame
:
:
ComputeCustomOverflow
(
aOverflowAreas
)
;
}
void
nsSVGContainerFrame
:
:
ReflowSVGNonDisplayText
(
nsIFrame
*
aContainer
)
{
if
(
!
(
aContainer
-
>
GetStateBits
(
)
&
NS_FRAME_IS_DIRTY
)
)
{
return
;
}
NS_ASSERTION
(
(
aContainer
-
>
GetStateBits
(
)
&
NS_FRAME_IS_NONDISPLAY
)
|
|
!
aContainer
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
"
it
is
wasteful
to
call
ReflowSVGNonDisplayText
on
a
container
"
"
frame
that
is
not
NS_FRAME_IS_NONDISPLAY
"
)
;
for
(
nsIFrame
*
kid
:
aContainer
-
>
PrincipalChildList
(
)
)
{
LayoutFrameType
type
=
kid
-
>
Type
(
)
;
if
(
type
=
=
LayoutFrameType
:
:
SVGText
)
{
static_cast
<
SVGTextFrame
*
>
(
kid
)
-
>
ReflowSVGNonDisplayText
(
)
;
}
else
{
if
(
kid
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
|
nsIFrame
:
:
eSVGContainer
)
|
|
type
=
=
LayoutFrameType
:
:
SVGForeignObject
|
|
!
kid
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
)
{
ReflowSVGNonDisplayText
(
kid
)
;
}
}
}
}
void
nsSVGDisplayContainerFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
if
(
!
(
GetStateBits
(
)
&
NS_STATE_IS_OUTER_SVG
)
)
{
AddStateBits
(
aParent
-
>
GetStateBits
(
)
&
NS_STATE_SVG_CLIPPATH_CHILD
)
;
}
nsSVGContainerFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
}
void
nsSVGDisplayContainerFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
if
(
mContent
-
>
IsSVGElement
(
)
&
&
!
static_cast
<
const
SVGElement
*
>
(
GetContent
(
)
)
-
>
HasValidDimensions
(
)
)
{
return
;
}
DisplayOutline
(
aBuilder
aLists
)
;
return
BuildDisplayListForNonBlockChildren
(
aBuilder
aLists
)
;
}
void
nsSVGDisplayContainerFrame
:
:
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
aFrameList
)
{
nsIFrame
*
nextFrame
=
aPrevFrame
?
aPrevFrame
-
>
GetNextSibling
(
)
:
GetChildList
(
aListID
)
.
FirstChild
(
)
;
nsIFrame
*
firstNewFrame
=
aFrameList
.
FirstChild
(
)
;
nsSVGContainerFrame
:
:
InsertFrames
(
aListID
aPrevFrame
aFrameList
)
;
if
(
!
(
GetStateBits
(
)
&
(
NS_FRAME_IS_DIRTY
|
NS_FRAME_HAS_DIRTY_CHILDREN
|
NS_FRAME_IS_NONDISPLAY
)
)
)
{
for
(
nsIFrame
*
kid
=
firstNewFrame
;
kid
!
=
nextFrame
;
kid
=
kid
-
>
GetNextSibling
(
)
)
{
nsSVGDisplayableFrame
*
SVGFrame
=
do_QueryFrame
(
kid
)
;
if
(
SVGFrame
)
{
MOZ_ASSERT
(
!
(
kid
-
>
GetStateBits
(
)
&
NS_FRAME_IS_NONDISPLAY
)
"
Check
for
this
explicitly
in
the
|
if
|
then
"
)
;
bool
isFirstReflow
=
(
kid
-
>
GetStateBits
(
)
&
NS_FRAME_FIRST_REFLOW
)
;
kid
-
>
RemoveStateBits
(
NS_FRAME_FIRST_REFLOW
|
NS_FRAME_IS_DIRTY
|
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
nsSVGUtils
:
:
ScheduleReflowSVG
(
kid
)
;
if
(
isFirstReflow
)
{
kid
-
>
AddStateBits
(
NS_FRAME_FIRST_REFLOW
)
;
}
}
}
}
}
void
nsSVGDisplayContainerFrame
:
:
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
{
SVGObserverUtils
:
:
InvalidateRenderingObservers
(
aOldFrame
)
;
SchedulePaint
(
)
;
PresContext
(
)
-
>
RestyleManager
(
)
-
>
PostRestyleEvent
(
mContent
-
>
AsElement
(
)
nsRestyleHint
(
0
)
nsChangeHint_UpdateOverflow
)
;
nsSVGContainerFrame
:
:
RemoveFrame
(
aListID
aOldFrame
)
;
}
bool
nsSVGDisplayContainerFrame
:
:
IsSVGTransformed
(
gfx
:
:
Matrix
*
aOwnTransform
gfx
:
:
Matrix
*
aFromParentTransform
)
const
{
bool
foundTransform
=
false
;
nsIFrame
*
parent
=
GetParent
(
)
;
if
(
parent
&
&
parent
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
|
nsIFrame
:
:
eSVGContainer
)
)
{
foundTransform
=
static_cast
<
nsSVGContainerFrame
*
>
(
parent
)
-
>
HasChildrenOnlyTransform
(
aFromParentTransform
)
;
}
if
(
mContent
-
>
IsSVGElement
(
)
)
{
SVGElement
*
content
=
static_cast
<
SVGElement
*
>
(
GetContent
(
)
)
;
SVGAnimatedTransformList
*
transformList
=
content
-
>
GetAnimatedTransformList
(
)
;
if
(
(
transformList
&
&
transformList
-
>
HasTransform
(
)
)
|
|
content
-
>
GetAnimateMotionTransform
(
)
)
{
if
(
aOwnTransform
)
{
*
aOwnTransform
=
gfx
:
:
ToMatrix
(
content
-
>
PrependLocalTransformsTo
(
gfxMatrix
(
)
eUserSpaceToParent
)
)
;
}
foundTransform
=
true
;
}
}
return
foundTransform
;
}
void
nsSVGDisplayContainerFrame
:
:
PaintSVG
(
gfxContext
&
aContext
const
gfxMatrix
&
aTransform
imgDrawingParams
&
aImgParams
const
nsIntRect
*
aDirtyRect
)
{
NS_ASSERTION
(
!
NS_SVGDisplayListPaintingEnabled
(
)
|
|
(
mState
&
NS_FRAME_IS_NONDISPLAY
)
|
|
PresContext
(
)
-
>
Document
(
)
-
>
IsSVGGlyphsDocument
(
)
"
If
display
lists
are
enabled
only
painting
of
non
-
display
"
"
SVG
should
take
this
code
path
"
)
;
if
(
StyleEffects
(
)
-
>
mOpacity
=
=
0
.
0
)
{
return
;
}
gfxMatrix
matrix
=
aTransform
;
if
(
GetContent
(
)
-
>
IsSVGElement
(
)
)
{
matrix
=
static_cast
<
const
SVGElement
*
>
(
GetContent
(
)
)
-
>
PrependLocalTransformsTo
(
matrix
eChildToUserSpace
)
;
if
(
matrix
.
IsSingular
(
)
)
{
return
;
}
}
for
(
nsIFrame
*
kid
=
mFrames
.
FirstChild
(
)
;
kid
;
kid
=
kid
-
>
GetNextSibling
(
)
)
{
gfxMatrix
m
=
matrix
;
const
nsIContent
*
content
=
kid
-
>
GetContent
(
)
;
if
(
content
-
>
IsSVGElement
(
)
)
{
const
SVGElement
*
element
=
static_cast
<
const
SVGElement
*
>
(
content
)
;
if
(
!
element
-
>
HasValidDimensions
(
)
)
{
continue
;
}
m
=
element
-
>
PrependLocalTransformsTo
(
m
eUserSpaceToParent
)
;
if
(
m
.
IsSingular
(
)
)
{
continue
;
}
}
nsSVGUtils
:
:
PaintFrameWithEffects
(
kid
aContext
m
aImgParams
aDirtyRect
)
;
}
}
nsIFrame
*
nsSVGDisplayContainerFrame
:
:
GetFrameForPoint
(
const
gfxPoint
&
aPoint
)
{
NS_ASSERTION
(
!
NS_SVGDisplayListHitTestingEnabled
(
)
|
|
(
mState
&
NS_FRAME_IS_NONDISPLAY
)
"
If
display
lists
are
enabled
only
hit
-
testing
of
a
"
"
clipPath
'
s
contents
should
take
this
code
path
"
)
;
return
nsSVGUtils
:
:
HitTestChildren
(
this
aPoint
)
;
}
void
nsSVGDisplayContainerFrame
:
:
ReflowSVG
(
)
{
NS_ASSERTION
(
nsSVGUtils
:
:
OuterSVGIsCallingReflowSVG
(
this
)
"
This
call
is
probably
a
wasteful
mistake
"
)
;
MOZ_ASSERT
(
!
(
GetStateBits
(
)
&
NS_FRAME_IS_NONDISPLAY
)
"
ReflowSVG
mechanism
not
designed
for
this
"
)
;
MOZ_ASSERT
(
!
IsSVGOuterSVGFrame
(
)
"
Do
not
call
on
outer
-
<
svg
>
"
)
;
if
(
!
nsSVGUtils
:
:
NeedsReflowSVG
(
this
)
)
{
return
;
}
bool
isFirstReflow
=
(
mState
&
NS_FRAME_FIRST_REFLOW
)
;
bool
outerSVGHasHadFirstReflow
=
(
GetParent
(
)
-
>
GetStateBits
(
)
&
NS_FRAME_FIRST_REFLOW
)
=
=
0
;
if
(
outerSVGHasHadFirstReflow
)
{
RemoveStateBits
(
NS_FRAME_FIRST_REFLOW
)
;
}
nsOverflowAreas
overflowRects
;
for
(
nsIFrame
*
kid
=
mFrames
.
FirstChild
(
)
;
kid
;
kid
=
kid
-
>
GetNextSibling
(
)
)
{
nsSVGDisplayableFrame
*
SVGFrame
=
do_QueryFrame
(
kid
)
;
if
(
SVGFrame
)
{
MOZ_ASSERT
(
!
(
kid
-
>
GetStateBits
(
)
&
NS_FRAME_IS_NONDISPLAY
)
"
Check
for
this
explicitly
in
the
|
if
|
then
"
)
;
kid
-
>
AddStateBits
(
mState
&
NS_FRAME_IS_DIRTY
)
;
SVGFrame
-
>
ReflowSVG
(
)
;
ConsiderChildOverflow
(
overflowRects
kid
)
;
}
else
{
NS_ASSERTION
(
kid
-
>
GetStateBits
(
)
&
NS_FRAME_IS_NONDISPLAY
"
expected
kid
to
be
a
NS_FRAME_IS_NONDISPLAY
frame
"
)
;
if
(
kid
-
>
GetStateBits
(
)
&
NS_FRAME_IS_DIRTY
)
{
nsSVGContainerFrame
*
container
=
do_QueryFrame
(
kid
)
;
if
(
container
&
&
container
-
>
GetContent
(
)
-
>
IsSVGElement
(
)
)
{
ReflowSVGNonDisplayText
(
container
)
;
}
}
}
}
MOZ_ASSERT
(
mContent
-
>
IsAnyOfSVGElements
(
nsGkAtoms
:
:
svg
nsGkAtoms
:
:
symbol
)
|
|
(
mContent
-
>
IsSVGElement
(
nsGkAtoms
:
:
use
)
&
&
mRect
.
Size
(
)
=
=
nsSize
(
0
0
)
)
|
|
mRect
.
IsEqualEdges
(
nsRect
(
)
)
"
Only
inner
-
<
svg
>
/
<
use
>
is
expected
to
have
mRect
set
"
)
;
if
(
isFirstReflow
)
{
SVGObserverUtils
:
:
UpdateEffects
(
this
)
;
}
FinishAndStoreOverflow
(
overflowRects
mRect
.
Size
(
)
)
;
RemoveStateBits
(
NS_FRAME_FIRST_REFLOW
|
NS_FRAME_IS_DIRTY
|
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
}
void
nsSVGDisplayContainerFrame
:
:
NotifySVGChanged
(
uint32_t
aFlags
)
{
MOZ_ASSERT
(
aFlags
&
(
TRANSFORM_CHANGED
|
COORD_CONTEXT_CHANGED
)
"
Invalidation
logic
may
need
adjusting
"
)
;
if
(
aFlags
&
TRANSFORM_CHANGED
)
{
mCanvasTM
=
nullptr
;
}
nsSVGUtils
:
:
NotifyChildrenOfSVGChange
(
this
aFlags
)
;
}
SVGBBox
nsSVGDisplayContainerFrame
:
:
GetBBoxContribution
(
const
Matrix
&
aToBBoxUserspace
uint32_t
aFlags
)
{
SVGBBox
bboxUnion
;
nsIFrame
*
kid
=
mFrames
.
FirstChild
(
)
;
while
(
kid
)
{
nsIContent
*
content
=
kid
-
>
GetContent
(
)
;
nsSVGDisplayableFrame
*
svgKid
=
do_QueryFrame
(
kid
)
;
if
(
svgKid
&
&
(
!
content
-
>
IsSVGElement
(
)
|
|
static_cast
<
const
SVGElement
*
>
(
content
)
-
>
HasValidDimensions
(
)
)
)
{
gfxMatrix
transform
=
gfx
:
:
ThebesMatrix
(
aToBBoxUserspace
)
;
if
(
content
-
>
IsSVGElement
(
)
)
{
transform
=
static_cast
<
SVGElement
*
>
(
content
)
-
>
PrependLocalTransformsTo
(
transform
)
;
}
bboxUnion
.
UnionEdges
(
svgKid
-
>
GetBBoxContribution
(
gfx
:
:
ToMatrix
(
transform
)
aFlags
)
)
;
}
kid
=
kid
-
>
GetNextSibling
(
)
;
}
return
bboxUnion
;
}
gfxMatrix
nsSVGDisplayContainerFrame
:
:
GetCanvasTM
(
)
{
if
(
!
mCanvasTM
)
{
NS_ASSERTION
(
GetParent
(
)
"
null
parent
"
)
;
nsSVGContainerFrame
*
parent
=
static_cast
<
nsSVGContainerFrame
*
>
(
GetParent
(
)
)
;
SVGElement
*
content
=
static_cast
<
SVGElement
*
>
(
GetContent
(
)
)
;
gfxMatrix
tm
=
content
-
>
PrependLocalTransformsTo
(
parent
-
>
GetCanvasTM
(
)
)
;
mCanvasTM
=
new
gfxMatrix
(
tm
)
;
}
return
*
mCanvasTM
;
}
