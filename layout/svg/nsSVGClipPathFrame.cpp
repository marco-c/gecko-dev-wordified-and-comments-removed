#
include
"
nsSVGClipPathFrame
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
mozilla
/
dom
/
SVGClipPathElement
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsSVGEffects
.
h
"
#
include
"
nsSVGPathGeometryElement
.
h
"
#
include
"
nsSVGPathGeometryFrame
.
h
"
#
include
"
nsSVGUtils
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
gfx
;
#
define
MAX_SVG_CLIP_PATH_REFERENCE_CHAIN_LENGTH
int16_t
(
512
)
nsIFrame
*
NS_NewSVGClipPathFrame
(
nsIPresShell
*
aPresShell
nsStyleContext
*
aContext
)
{
return
new
(
aPresShell
)
nsSVGClipPathFrame
(
aContext
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsSVGClipPathFrame
)
void
nsSVGClipPathFrame
:
:
ApplyClipPath
(
gfxContext
&
aContext
nsIFrame
*
aClippedFrame
const
gfxMatrix
&
aMatrix
)
{
MOZ_ASSERT
(
IsTrivial
(
)
"
Caller
needs
to
use
GetClipMask
"
)
;
DrawTarget
&
aDrawTarget
=
*
aContext
.
GetDrawTarget
(
)
;
gfxContextMatrixAutoSaveRestore
autoRestore
(
&
aContext
)
;
RefPtr
<
Path
>
clipPath
;
nsISVGChildFrame
*
singleClipPathChild
=
nullptr
;
IsTrivial
(
&
singleClipPathChild
)
;
if
(
singleClipPathChild
)
{
nsSVGPathGeometryFrame
*
pathFrame
=
do_QueryFrame
(
singleClipPathChild
)
;
if
(
pathFrame
)
{
nsSVGPathGeometryElement
*
pathElement
=
static_cast
<
nsSVGPathGeometryElement
*
>
(
pathFrame
-
>
GetContent
(
)
)
;
gfxMatrix
toChildsUserSpace
=
pathElement
-
>
PrependLocalTransformsTo
(
GetClipPathTransform
(
aClippedFrame
)
*
aMatrix
eUserSpaceToParent
)
;
gfxMatrix
newMatrix
=
aContext
.
CurrentMatrix
(
)
.
PreMultiply
(
toChildsUserSpace
)
.
NudgeToIntegers
(
)
;
if
(
!
newMatrix
.
IsSingular
(
)
)
{
aContext
.
SetMatrix
(
newMatrix
)
;
FillRule
clipRule
=
nsSVGUtils
:
:
ToFillRule
(
pathFrame
-
>
StyleSVG
(
)
-
>
mClipRule
)
;
clipPath
=
pathElement
-
>
GetOrBuildPath
(
aDrawTarget
clipRule
)
;
}
}
}
if
(
clipPath
)
{
aContext
.
Clip
(
clipPath
)
;
}
else
{
aContext
.
Clip
(
Rect
(
)
)
;
}
}
already_AddRefed
<
DrawTarget
>
nsSVGClipPathFrame
:
:
CreateClipMask
(
gfxContext
&
aReferenceContext
IntPoint
&
aOffset
)
{
gfxContextMatrixAutoSaveRestore
autoRestoreMatrix
(
&
aReferenceContext
)
;
aReferenceContext
.
SetMatrix
(
gfxMatrix
(
)
)
;
gfxRect
rect
=
aReferenceContext
.
GetClipExtents
(
)
;
IntRect
bounds
=
RoundedOut
(
ToRect
(
rect
)
)
;
if
(
bounds
.
IsEmpty
(
)
)
{
return
nullptr
;
}
DrawTarget
*
referenceDT
=
aReferenceContext
.
GetDrawTarget
(
)
;
RefPtr
<
DrawTarget
>
maskDT
=
referenceDT
-
>
CreateSimilarDrawTarget
(
bounds
.
Size
(
)
SurfaceFormat
:
:
A8
)
;
aOffset
=
bounds
.
TopLeft
(
)
;
return
maskDT
.
forget
(
)
;
}
static
void
ComposeExtraMask
(
DrawTarget
*
aTarget
const
gfxMatrix
&
aMaskTransfrom
SourceSurface
*
aExtraMask
const
Matrix
&
aExtraMasksTransform
)
{
MOZ_ASSERT
(
aExtraMask
)
;
Matrix
origin
=
aTarget
-
>
GetTransform
(
)
;
aTarget
-
>
SetTransform
(
aExtraMasksTransform
*
aTarget
-
>
GetTransform
(
)
)
;
aTarget
-
>
MaskSurface
(
ColorPattern
(
Color
(
0
.
0
0
.
0
0
.
0
1
.
0
)
)
aExtraMask
Point
(
0
0
)
DrawOptions
(
1
.
0
CompositionOp
:
:
OP_IN
)
)
;
aTarget
-
>
SetTransform
(
origin
)
;
}
DrawResult
nsSVGClipPathFrame
:
:
PaintClipMask
(
gfxContext
&
aMaskContext
nsIFrame
*
aClippedFrame
const
gfxMatrix
&
aMatrix
Matrix
*
aMaskTransform
SourceSurface
*
aExtraMask
const
Matrix
&
aExtraMasksTransform
)
{
static
int16_t
sRefChainLengthCounter
=
AutoReferenceLimiter
:
:
notReferencing
;
AutoReferenceLimiter
refChainLengthLimiter
(
&
sRefChainLengthCounter
MAX_SVG_CLIP_PATH_REFERENCE_CHAIN_LENGTH
)
;
if
(
!
refChainLengthLimiter
.
Reference
(
)
)
{
return
DrawResult
:
:
SUCCESS
;
}
AutoReferenceLimiter
refLoopDetector
(
&
mReferencing
1
)
;
if
(
!
refLoopDetector
.
Reference
(
)
)
{
return
DrawResult
:
:
SUCCESS
;
}
DrawResult
result
=
DrawResult
:
:
SUCCESS
;
DrawTarget
*
maskDT
=
aMaskContext
.
GetDrawTarget
(
)
;
MOZ_ASSERT
(
maskDT
-
>
GetFormat
(
)
=
=
SurfaceFormat
:
:
A8
)
;
mMatrixForChildren
=
GetClipPathTransform
(
aClippedFrame
)
*
aMatrix
;
nsSVGClipPathFrame
*
clipPathThatClipsClipPath
=
nsSVGEffects
:
:
GetEffectProperties
(
this
)
.
GetClipPathFrame
(
nullptr
)
;
nsSVGUtils
:
:
MaskUsage
maskUsage
;
nsSVGUtils
:
:
DetermineMaskUsage
(
this
true
maskUsage
)
;
if
(
maskUsage
.
shouldApplyClipPath
)
{
clipPathThatClipsClipPath
-
>
ApplyClipPath
(
aMaskContext
aClippedFrame
aMatrix
)
;
}
else
if
(
maskUsage
.
shouldGenerateClipMaskLayer
)
{
Matrix
maskTransform
;
RefPtr
<
SourceSurface
>
maskSurface
;
Tie
(
result
maskSurface
)
=
clipPathThatClipsClipPath
-
>
GetClipMask
(
aMaskContext
aClippedFrame
aMatrix
&
maskTransform
)
;
aMaskContext
.
PushGroupForBlendBack
(
gfxContentType
:
:
ALPHA
1
.
0
maskSurface
maskTransform
)
;
}
for
(
nsIFrame
*
kid
=
mFrames
.
FirstChild
(
)
;
kid
;
kid
=
kid
-
>
GetNextSibling
(
)
)
{
result
&
=
PaintFrameIntoMask
(
kid
aClippedFrame
aMaskContext
aMatrix
)
;
}
if
(
maskUsage
.
shouldGenerateClipMaskLayer
)
{
aMaskContext
.
PopGroupAndBlend
(
)
;
}
else
if
(
maskUsage
.
shouldApplyClipPath
)
{
aMaskContext
.
PopClip
(
)
;
}
gfxMatrix
maskTransfrom
=
aMaskContext
.
CurrentMatrix
(
)
;
maskTransfrom
.
Invert
(
)
;
if
(
aExtraMask
)
{
ComposeExtraMask
(
maskDT
maskTransfrom
aExtraMask
aExtraMasksTransform
)
;
}
*
aMaskTransform
=
ToMatrix
(
maskTransfrom
)
;
return
result
;
}
DrawResult
nsSVGClipPathFrame
:
:
PaintFrameIntoMask
(
nsIFrame
*
aFrame
nsIFrame
*
aClippedFrame
gfxContext
&
aTarget
const
gfxMatrix
&
aMatrix
)
{
nsISVGChildFrame
*
frame
=
do_QueryFrame
(
aFrame
)
;
if
(
!
frame
)
{
return
DrawResult
:
:
SUCCESS
;
}
frame
-
>
NotifySVGChanged
(
nsISVGChildFrame
:
:
TRANSFORM_CHANGED
)
;
bool
isOK
=
true
;
nsSVGClipPathFrame
*
clipPathThatClipsChild
=
nsSVGEffects
:
:
GetEffectProperties
(
aFrame
)
.
GetClipPathFrame
(
&
isOK
)
;
if
(
!
isOK
)
{
return
DrawResult
:
:
SUCCESS
;
}
nsSVGUtils
:
:
MaskUsage
maskUsage
;
nsSVGUtils
:
:
DetermineMaskUsage
(
aFrame
true
maskUsage
)
;
DrawResult
result
=
DrawResult
:
:
SUCCESS
;
if
(
maskUsage
.
shouldApplyClipPath
)
{
clipPathThatClipsChild
-
>
ApplyClipPath
(
aTarget
aClippedFrame
aMatrix
)
;
}
else
if
(
maskUsage
.
shouldGenerateClipMaskLayer
)
{
Matrix
maskTransform
;
RefPtr
<
SourceSurface
>
maskSurface
;
Tie
(
result
maskSurface
)
=
clipPathThatClipsChild
-
>
GetClipMask
(
aTarget
aClippedFrame
aMatrix
&
maskTransform
)
;
aTarget
.
PushGroupForBlendBack
(
gfxContentType
:
:
ALPHA
1
.
0
maskSurface
maskTransform
)
;
}
gfxMatrix
toChildsUserSpace
=
mMatrixForChildren
;
nsIFrame
*
child
=
do_QueryFrame
(
frame
)
;
nsIContent
*
childContent
=
child
-
>
GetContent
(
)
;
if
(
childContent
-
>
IsSVGElement
(
)
)
{
toChildsUserSpace
=
static_cast
<
const
nsSVGElement
*
>
(
childContent
)
-
>
PrependLocalTransformsTo
(
mMatrixForChildren
eUserSpaceToParent
)
;
}
result
&
=
frame
-
>
PaintSVG
(
aTarget
toChildsUserSpace
)
;
if
(
maskUsage
.
shouldGenerateClipMaskLayer
)
{
aTarget
.
PopGroupAndBlend
(
)
;
}
else
if
(
maskUsage
.
shouldApplyClipPath
)
{
aTarget
.
PopClip
(
)
;
}
return
result
;
}
mozilla
:
:
Pair
<
DrawResult
RefPtr
<
SourceSurface
>
>
nsSVGClipPathFrame
:
:
GetClipMask
(
gfxContext
&
aReferenceContext
nsIFrame
*
aClippedFrame
const
gfxMatrix
&
aMatrix
Matrix
*
aMaskTransform
SourceSurface
*
aExtraMask
const
Matrix
&
aExtraMasksTransform
)
{
MOZ_ASSERT
(
!
IsTrivial
(
)
"
Caller
needs
to
use
ApplyClipPath
"
)
;
IntPoint
offset
;
RefPtr
<
DrawTarget
>
maskDT
=
CreateClipMask
(
aReferenceContext
offset
)
;
if
(
!
maskDT
)
{
return
MakePair
(
DrawResult
:
:
SUCCESS
RefPtr
<
SourceSurface
>
(
)
)
;
}
RefPtr
<
gfxContext
>
maskContext
=
gfxContext
:
:
CreateOrNull
(
maskDT
)
;
if
(
!
maskContext
)
{
gfxCriticalError
(
)
<
<
"
SVGClipPath
context
problem
"
<
<
gfx
:
:
hexa
(
maskDT
)
;
return
MakePair
(
DrawResult
:
:
TEMPORARY_ERROR
RefPtr
<
SourceSurface
>
(
)
)
;
}
maskContext
-
>
SetMatrix
(
aReferenceContext
.
CurrentMatrix
(
)
*
gfxMatrix
:
:
Translation
(
-
offset
)
)
;
DrawResult
result
=
PaintClipMask
(
*
maskContext
aClippedFrame
aMatrix
aMaskTransform
aExtraMask
aExtraMasksTransform
)
;
RefPtr
<
SourceSurface
>
surface
=
maskDT
-
>
Snapshot
(
)
;
return
MakePair
(
result
Move
(
surface
)
)
;
}
bool
nsSVGClipPathFrame
:
:
PointIsInsideClipPath
(
nsIFrame
*
aClippedFrame
const
gfxPoint
&
aPoint
)
{
static
int16_t
sRefChainLengthCounter
=
AutoReferenceLimiter
:
:
notReferencing
;
AutoReferenceLimiter
refChainLengthLimiter
(
&
sRefChainLengthCounter
MAX_SVG_CLIP_PATH_REFERENCE_CHAIN_LENGTH
)
;
if
(
!
refChainLengthLimiter
.
Reference
(
)
)
{
return
false
;
}
AutoReferenceLimiter
refLoopDetector
(
&
mReferencing
1
)
;
if
(
!
refLoopDetector
.
Reference
(
)
)
{
return
true
;
}
gfxMatrix
matrix
=
GetClipPathTransform
(
aClippedFrame
)
;
if
(
!
matrix
.
Invert
(
)
)
{
return
false
;
}
gfxPoint
point
=
matrix
.
Transform
(
aPoint
)
;
nsSVGClipPathFrame
*
clipPathFrame
=
nsSVGEffects
:
:
GetEffectProperties
(
this
)
.
GetClipPathFrame
(
nullptr
)
;
if
(
clipPathFrame
&
&
!
clipPathFrame
-
>
PointIsInsideClipPath
(
aClippedFrame
aPoint
)
)
{
return
false
;
}
for
(
nsIFrame
*
kid
=
mFrames
.
FirstChild
(
)
;
kid
;
kid
=
kid
-
>
GetNextSibling
(
)
)
{
nsISVGChildFrame
*
SVGFrame
=
do_QueryFrame
(
kid
)
;
if
(
SVGFrame
)
{
gfxPoint
pointForChild
=
point
;
gfxMatrix
m
=
static_cast
<
nsSVGElement
*
>
(
kid
-
>
GetContent
(
)
)
-
>
PrependLocalTransformsTo
(
gfxMatrix
(
)
eUserSpaceToParent
)
;
if
(
!
m
.
IsIdentity
(
)
)
{
if
(
!
m
.
Invert
(
)
)
{
return
false
;
}
pointForChild
=
m
.
Transform
(
point
)
;
}
if
(
SVGFrame
-
>
GetFrameForPoint
(
pointForChild
)
)
{
return
true
;
}
}
}
return
false
;
}
bool
nsSVGClipPathFrame
:
:
IsTrivial
(
nsISVGChildFrame
*
*
aSingleChild
)
{
if
(
nsSVGEffects
:
:
GetEffectProperties
(
this
)
.
GetClipPathFrame
(
nullptr
)
)
return
false
;
if
(
aSingleChild
)
{
*
aSingleChild
=
nullptr
;
}
nsISVGChildFrame
*
foundChild
=
nullptr
;
for
(
nsIFrame
*
kid
=
mFrames
.
FirstChild
(
)
;
kid
;
kid
=
kid
-
>
GetNextSibling
(
)
)
{
nsISVGChildFrame
*
svgChild
=
do_QueryFrame
(
kid
)
;
if
(
svgChild
)
{
if
(
foundChild
|
|
svgChild
-
>
IsDisplayContainer
(
)
)
return
false
;
if
(
nsSVGEffects
:
:
GetEffectProperties
(
kid
)
.
GetClipPathFrame
(
nullptr
)
)
return
false
;
foundChild
=
svgChild
;
}
}
if
(
aSingleChild
)
{
*
aSingleChild
=
foundChild
;
}
return
true
;
}
bool
nsSVGClipPathFrame
:
:
IsValid
(
)
{
static
int16_t
sRefChainLengthCounter
=
AutoReferenceLimiter
:
:
notReferencing
;
AutoReferenceLimiter
refChainLengthLimiter
(
&
sRefChainLengthCounter
MAX_SVG_CLIP_PATH_REFERENCE_CHAIN_LENGTH
)
;
if
(
!
refChainLengthLimiter
.
Reference
(
)
)
{
return
false
;
}
AutoReferenceLimiter
refLoopDetector
(
&
mReferencing
1
)
;
if
(
!
refLoopDetector
.
Reference
(
)
)
{
return
false
;
}
bool
isOK
=
true
;
nsSVGEffects
:
:
GetEffectProperties
(
this
)
.
GetClipPathFrame
(
&
isOK
)
;
if
(
!
isOK
)
{
return
false
;
}
for
(
nsIFrame
*
kid
=
mFrames
.
FirstChild
(
)
;
kid
;
kid
=
kid
-
>
GetNextSibling
(
)
)
{
nsIAtom
*
kidType
=
kid
-
>
GetType
(
)
;
if
(
kidType
=
=
nsGkAtoms
:
:
svgUseFrame
)
{
for
(
nsIFrame
*
grandKid
:
kid
-
>
PrincipalChildList
(
)
)
{
nsIAtom
*
grandKidType
=
grandKid
-
>
GetType
(
)
;
if
(
grandKidType
!
=
nsGkAtoms
:
:
svgPathGeometryFrame
&
&
grandKidType
!
=
nsGkAtoms
:
:
svgTextFrame
)
{
return
false
;
}
}
continue
;
}
if
(
kidType
!
=
nsGkAtoms
:
:
svgPathGeometryFrame
&
&
kidType
!
=
nsGkAtoms
:
:
svgTextFrame
)
{
return
false
;
}
}
return
true
;
}
nsresult
nsSVGClipPathFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsIAtom
*
aAttribute
int32_t
aModType
)
{
if
(
aNameSpaceID
=
=
kNameSpaceID_None
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
transform
)
{
nsSVGEffects
:
:
InvalidateDirectRenderingObservers
(
this
)
;
nsSVGUtils
:
:
NotifyChildrenOfSVGChange
(
this
nsISVGChildFrame
:
:
TRANSFORM_CHANGED
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
clipPathUnits
)
{
nsSVGEffects
:
:
InvalidateDirectRenderingObservers
(
this
)
;
}
}
return
nsSVGContainerFrame
:
:
AttributeChanged
(
aNameSpaceID
aAttribute
aModType
)
;
}
void
nsSVGClipPathFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
NS_ASSERTION
(
aContent
-
>
IsSVGElement
(
nsGkAtoms
:
:
clipPath
)
"
Content
is
not
an
SVG
clipPath
!
"
)
;
AddStateBits
(
NS_STATE_SVG_CLIPPATH_CHILD
)
;
nsSVGContainerFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
}
nsIAtom
*
nsSVGClipPathFrame
:
:
GetType
(
)
const
{
return
nsGkAtoms
:
:
svgClipPathFrame
;
}
gfxMatrix
nsSVGClipPathFrame
:
:
GetCanvasTM
(
)
{
return
mMatrixForChildren
;
}
gfxMatrix
nsSVGClipPathFrame
:
:
GetClipPathTransform
(
nsIFrame
*
aClippedFrame
)
{
SVGClipPathElement
*
content
=
static_cast
<
SVGClipPathElement
*
>
(
mContent
)
;
gfxMatrix
tm
=
content
-
>
PrependLocalTransformsTo
(
gfxMatrix
(
)
)
;
nsSVGEnum
*
clipPathUnits
=
&
content
-
>
mEnumAttributes
[
SVGClipPathElement
:
:
CLIPPATHUNITS
]
;
return
nsSVGUtils
:
:
AdjustMatrixForUnits
(
tm
clipPathUnits
aClippedFrame
)
;
}
SVGBBox
nsSVGClipPathFrame
:
:
GetBBoxForClipPathFrame
(
const
SVGBBox
&
aBBox
const
gfxMatrix
&
aMatrix
)
{
nsIContent
*
node
=
GetContent
(
)
-
>
GetFirstChild
(
)
;
SVGBBox
unionBBox
tmpBBox
;
for
(
;
node
;
node
=
node
-
>
GetNextSibling
(
)
)
{
nsIFrame
*
frame
=
static_cast
<
nsSVGElement
*
>
(
node
)
-
>
GetPrimaryFrame
(
)
;
if
(
frame
)
{
nsISVGChildFrame
*
svg
=
do_QueryFrame
(
frame
)
;
if
(
svg
)
{
tmpBBox
=
svg
-
>
GetBBoxContribution
(
mozilla
:
:
gfx
:
:
ToMatrix
(
aMatrix
)
nsSVGUtils
:
:
eBBoxIncludeFill
)
;
nsSVGEffects
:
:
EffectProperties
effectProperties
=
nsSVGEffects
:
:
GetEffectProperties
(
frame
)
;
bool
isOK
=
true
;
nsSVGClipPathFrame
*
clipPathFrame
=
effectProperties
.
GetClipPathFrame
(
&
isOK
)
;
if
(
clipPathFrame
&
&
isOK
)
{
tmpBBox
=
clipPathFrame
-
>
GetBBoxForClipPathFrame
(
tmpBBox
aMatrix
)
;
}
tmpBBox
.
Intersect
(
aBBox
)
;
unionBBox
.
UnionEdges
(
tmpBBox
)
;
}
}
}
nsSVGEffects
:
:
EffectProperties
props
=
nsSVGEffects
:
:
GetEffectProperties
(
this
)
;
if
(
props
.
mClipPath
)
{
bool
isOK
=
true
;
nsSVGClipPathFrame
*
clipPathFrame
=
props
.
GetClipPathFrame
(
&
isOK
)
;
if
(
clipPathFrame
&
&
isOK
)
{
tmpBBox
=
clipPathFrame
-
>
GetBBoxForClipPathFrame
(
aBBox
aMatrix
)
;
unionBBox
.
Intersect
(
tmpBBox
)
;
}
else
if
(
!
isOK
)
{
unionBBox
=
SVGBBox
(
)
;
}
}
return
unionBBox
;
}
