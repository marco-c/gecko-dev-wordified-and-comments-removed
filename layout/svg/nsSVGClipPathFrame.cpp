#
include
"
nsSVGClipPathFrame
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
mozilla
/
dom
/
SVGClipPathElement
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsSVGEffects
.
h
"
#
include
"
nsSVGPathGeometryElement
.
h
"
#
include
"
nsSVGPathGeometryFrame
.
h
"
#
include
"
nsSVGUtils
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
gfx
;
#
define
MAX_SVG_CLIP_PATH_REFERENCE_CHAIN_LENGTH
int16_t
(
512
)
nsIFrame
*
NS_NewSVGClipPathFrame
(
nsIPresShell
*
aPresShell
nsStyleContext
*
aContext
)
{
return
new
(
aPresShell
)
nsSVGClipPathFrame
(
aContext
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsSVGClipPathFrame
)
void
nsSVGClipPathFrame
:
:
ApplyClipPath
(
gfxContext
&
aContext
nsIFrame
*
aClippedFrame
const
gfxMatrix
&
aMatrix
)
{
MOZ_ASSERT
(
IsTrivial
(
)
"
Caller
needs
to
use
GetClipMask
"
)
;
DrawTarget
&
aDrawTarget
=
*
aContext
.
GetDrawTarget
(
)
;
gfxContextMatrixAutoSaveRestore
autoRestore
(
&
aContext
)
;
RefPtr
<
Path
>
clipPath
;
nsISVGChildFrame
*
singleClipPathChild
=
nullptr
;
IsTrivial
(
&
singleClipPathChild
)
;
if
(
singleClipPathChild
)
{
nsSVGPathGeometryFrame
*
pathFrame
=
do_QueryFrame
(
singleClipPathChild
)
;
if
(
pathFrame
)
{
nsSVGPathGeometryElement
*
pathElement
=
static_cast
<
nsSVGPathGeometryElement
*
>
(
pathFrame
-
>
GetContent
(
)
)
;
gfxMatrix
toChildsUserSpace
=
pathElement
-
>
PrependLocalTransformsTo
(
GetClipPathTransform
(
aClippedFrame
)
*
aMatrix
eUserSpaceToParent
)
;
gfxMatrix
newMatrix
=
aContext
.
CurrentMatrix
(
)
.
PreMultiply
(
toChildsUserSpace
)
.
NudgeToIntegers
(
)
;
if
(
!
newMatrix
.
IsSingular
(
)
)
{
aContext
.
SetMatrix
(
newMatrix
)
;
FillRule
clipRule
=
nsSVGUtils
:
:
ToFillRule
(
pathFrame
-
>
StyleSVG
(
)
-
>
mClipRule
)
;
clipPath
=
pathElement
-
>
GetOrBuildPath
(
aDrawTarget
clipRule
)
;
}
}
}
if
(
clipPath
)
{
aContext
.
Clip
(
clipPath
)
;
}
else
{
aContext
.
Clip
(
Rect
(
)
)
;
}
}
already_AddRefed
<
SourceSurface
>
nsSVGClipPathFrame
:
:
GetClipMask
(
gfxContext
&
aReferenceContext
nsIFrame
*
aClippedFrame
const
gfxMatrix
&
aMatrix
Matrix
*
aMaskTransform
SourceSurface
*
aExtraMask
const
Matrix
&
aExtraMasksTransform
)
{
MOZ_ASSERT
(
!
IsTrivial
(
)
"
Caller
needs
to
use
ApplyClipPath
"
)
;
DrawTarget
&
aReferenceDT
=
*
aReferenceContext
.
GetDrawTarget
(
)
;
static
int16_t
sRefChainLengthCounter
=
AutoReferenceLimiter
:
:
notReferencing
;
AutoReferenceLimiter
refChainLengthLimiter
(
&
sRefChainLengthCounter
MAX_SVG_CLIP_PATH_REFERENCE_CHAIN_LENGTH
)
;
if
(
!
refChainLengthLimiter
.
Reference
(
)
)
{
return
nullptr
;
}
AutoReferenceLimiter
refLoopDetector
(
&
mReferencing
1
)
;
if
(
!
refLoopDetector
.
Reference
(
)
)
{
return
nullptr
;
}
IntRect
devSpaceClipExtents
;
{
gfxContextMatrixAutoSaveRestore
autoRestoreMatrix
(
&
aReferenceContext
)
;
aReferenceContext
.
SetMatrix
(
gfxMatrix
(
)
)
;
gfxRect
rect
=
aReferenceContext
.
GetClipExtents
(
)
;
devSpaceClipExtents
=
RoundedOut
(
ToRect
(
rect
)
)
;
if
(
devSpaceClipExtents
.
IsEmpty
(
)
)
{
return
nullptr
;
}
}
RefPtr
<
DrawTarget
>
maskDT
=
aReferenceDT
.
CreateSimilarDrawTarget
(
devSpaceClipExtents
.
Size
(
)
SurfaceFormat
:
:
A8
)
;
gfxMatrix
mat
=
aReferenceContext
.
CurrentMatrix
(
)
*
gfxMatrix
:
:
Translation
(
-
devSpaceClipExtents
.
TopLeft
(
)
)
;
{
RefPtr
<
gfxContext
>
ctx
=
gfxContext
:
:
ForDrawTarget
(
maskDT
)
;
if
(
!
ctx
)
{
gfxCriticalError
(
)
<
<
"
SVGClipPath
context
problem
"
<
<
gfx
:
:
hexa
(
maskDT
)
;
return
nullptr
;
}
ctx
-
>
SetMatrix
(
mat
)
;
mMatrixForChildren
=
GetClipPathTransform
(
aClippedFrame
)
*
aMatrix
;
nsSVGClipPathFrame
*
clipPathThatClipsClipPath
=
nsSVGEffects
:
:
GetEffectProperties
(
this
)
.
GetClipPathFrame
(
nullptr
)
;
bool
clippingOfClipPathRequiredMasking
;
if
(
clipPathThatClipsClipPath
)
{
ctx
-
>
Save
(
)
;
clippingOfClipPathRequiredMasking
=
!
clipPathThatClipsClipPath
-
>
IsTrivial
(
)
;
if
(
!
clippingOfClipPathRequiredMasking
)
{
clipPathThatClipsClipPath
-
>
ApplyClipPath
(
*
ctx
aClippedFrame
aMatrix
)
;
}
else
{
Matrix
maskTransform
;
RefPtr
<
SourceSurface
>
mask
=
clipPathThatClipsClipPath
-
>
GetClipMask
(
*
ctx
aClippedFrame
aMatrix
&
maskTransform
)
;
ctx
-
>
PushGroupForBlendBack
(
gfxContentType
:
:
ALPHA
1
.
0
mask
maskTransform
)
;
}
}
for
(
nsIFrame
*
kid
=
mFrames
.
FirstChild
(
)
;
kid
;
kid
=
kid
-
>
GetNextSibling
(
)
)
{
nsISVGChildFrame
*
SVGFrame
=
do_QueryFrame
(
kid
)
;
if
(
SVGFrame
)
{
SVGFrame
-
>
NotifySVGChanged
(
nsISVGChildFrame
:
:
TRANSFORM_CHANGED
)
;
bool
isOK
=
true
;
nsSVGClipPathFrame
*
clipPathThatClipsChild
=
nsSVGEffects
:
:
GetEffectProperties
(
kid
)
.
GetClipPathFrame
(
&
isOK
)
;
if
(
!
isOK
)
{
continue
;
}
bool
childsClipPathRequiresMasking
;
if
(
clipPathThatClipsChild
)
{
childsClipPathRequiresMasking
=
!
clipPathThatClipsChild
-
>
IsTrivial
(
)
;
ctx
-
>
Save
(
)
;
if
(
!
childsClipPathRequiresMasking
)
{
clipPathThatClipsChild
-
>
ApplyClipPath
(
*
ctx
aClippedFrame
aMatrix
)
;
}
else
{
Matrix
maskTransform
;
RefPtr
<
SourceSurface
>
mask
=
clipPathThatClipsChild
-
>
GetClipMask
(
*
ctx
aClippedFrame
aMatrix
&
maskTransform
)
;
ctx
-
>
PushGroupForBlendBack
(
gfxContentType
:
:
ALPHA
1
.
0
mask
maskTransform
)
;
}
}
gfxMatrix
toChildsUserSpace
=
mMatrixForChildren
;
nsIFrame
*
child
=
do_QueryFrame
(
SVGFrame
)
;
nsIContent
*
childContent
=
child
-
>
GetContent
(
)
;
if
(
childContent
-
>
IsSVGElement
(
)
)
{
toChildsUserSpace
=
static_cast
<
const
nsSVGElement
*
>
(
childContent
)
-
>
PrependLocalTransformsTo
(
mMatrixForChildren
eUserSpaceToParent
)
;
}
SVGFrame
-
>
PaintSVG
(
*
ctx
toChildsUserSpace
)
;
if
(
clipPathThatClipsChild
)
{
if
(
childsClipPathRequiresMasking
)
{
ctx
-
>
PopGroupAndBlend
(
)
;
}
ctx
-
>
Restore
(
)
;
}
}
}
if
(
clipPathThatClipsClipPath
)
{
if
(
clippingOfClipPathRequiredMasking
)
{
ctx
-
>
PopGroupAndBlend
(
)
;
}
ctx
-
>
Restore
(
)
;
}
}
mat
.
Invert
(
)
;
if
(
aExtraMask
)
{
RefPtr
<
SourceSurface
>
currentMask
=
maskDT
-
>
Snapshot
(
)
;
Matrix
transform
=
maskDT
-
>
GetTransform
(
)
;
maskDT
-
>
SetTransform
(
Matrix
(
)
)
;
maskDT
-
>
ClearRect
(
Rect
(
0
0
devSpaceClipExtents
.
width
devSpaceClipExtents
.
height
)
)
;
maskDT
-
>
SetTransform
(
aExtraMasksTransform
*
transform
)
;
maskDT
-
>
MaskSurface
(
SurfacePattern
(
currentMask
ExtendMode
:
:
CLAMP
aExtraMasksTransform
.
Inverse
(
)
*
ToMatrix
(
mat
)
)
aExtraMask
Point
(
0
0
)
)
;
}
*
aMaskTransform
=
ToMatrix
(
mat
)
;
return
maskDT
-
>
Snapshot
(
)
;
}
bool
nsSVGClipPathFrame
:
:
PointIsInsideClipPath
(
nsIFrame
*
aClippedFrame
const
gfxPoint
&
aPoint
)
{
static
int16_t
sRefChainLengthCounter
=
AutoReferenceLimiter
:
:
notReferencing
;
AutoReferenceLimiter
refChainLengthLimiter
(
&
sRefChainLengthCounter
MAX_SVG_CLIP_PATH_REFERENCE_CHAIN_LENGTH
)
;
if
(
!
refChainLengthLimiter
.
Reference
(
)
)
{
return
false
;
}
AutoReferenceLimiter
refLoopDetector
(
&
mReferencing
1
)
;
if
(
!
refLoopDetector
.
Reference
(
)
)
{
return
true
;
}
gfxMatrix
matrix
=
GetClipPathTransform
(
aClippedFrame
)
;
if
(
!
matrix
.
Invert
(
)
)
{
return
false
;
}
gfxPoint
point
=
matrix
.
Transform
(
aPoint
)
;
nsSVGClipPathFrame
*
clipPathFrame
=
nsSVGEffects
:
:
GetEffectProperties
(
this
)
.
GetClipPathFrame
(
nullptr
)
;
if
(
clipPathFrame
&
&
!
clipPathFrame
-
>
PointIsInsideClipPath
(
aClippedFrame
aPoint
)
)
{
return
false
;
}
for
(
nsIFrame
*
kid
=
mFrames
.
FirstChild
(
)
;
kid
;
kid
=
kid
-
>
GetNextSibling
(
)
)
{
nsISVGChildFrame
*
SVGFrame
=
do_QueryFrame
(
kid
)
;
if
(
SVGFrame
)
{
gfxPoint
pointForChild
=
point
;
gfxMatrix
m
=
static_cast
<
nsSVGElement
*
>
(
kid
-
>
GetContent
(
)
)
-
>
PrependLocalTransformsTo
(
gfxMatrix
(
)
eUserSpaceToParent
)
;
if
(
!
m
.
IsIdentity
(
)
)
{
if
(
!
m
.
Invert
(
)
)
{
return
false
;
}
pointForChild
=
m
.
Transform
(
point
)
;
}
if
(
SVGFrame
-
>
GetFrameForPoint
(
pointForChild
)
)
{
return
true
;
}
}
}
return
false
;
}
bool
nsSVGClipPathFrame
:
:
IsTrivial
(
nsISVGChildFrame
*
*
aSingleChild
)
{
if
(
nsSVGEffects
:
:
GetEffectProperties
(
this
)
.
GetClipPathFrame
(
nullptr
)
)
return
false
;
if
(
aSingleChild
)
{
*
aSingleChild
=
nullptr
;
}
nsISVGChildFrame
*
foundChild
=
nullptr
;
for
(
nsIFrame
*
kid
=
mFrames
.
FirstChild
(
)
;
kid
;
kid
=
kid
-
>
GetNextSibling
(
)
)
{
nsISVGChildFrame
*
svgChild
=
do_QueryFrame
(
kid
)
;
if
(
svgChild
)
{
if
(
foundChild
|
|
svgChild
-
>
IsDisplayContainer
(
)
)
return
false
;
if
(
nsSVGEffects
:
:
GetEffectProperties
(
kid
)
.
GetClipPathFrame
(
nullptr
)
)
return
false
;
foundChild
=
svgChild
;
}
}
if
(
aSingleChild
)
{
*
aSingleChild
=
foundChild
;
}
return
true
;
}
bool
nsSVGClipPathFrame
:
:
IsValid
(
)
{
static
int16_t
sRefChainLengthCounter
=
AutoReferenceLimiter
:
:
notReferencing
;
AutoReferenceLimiter
refChainLengthLimiter
(
&
sRefChainLengthCounter
MAX_SVG_CLIP_PATH_REFERENCE_CHAIN_LENGTH
)
;
if
(
!
refChainLengthLimiter
.
Reference
(
)
)
{
return
false
;
}
AutoReferenceLimiter
refLoopDetector
(
&
mReferencing
1
)
;
if
(
!
refLoopDetector
.
Reference
(
)
)
{
return
false
;
}
bool
isOK
=
true
;
nsSVGEffects
:
:
GetEffectProperties
(
this
)
.
GetClipPathFrame
(
&
isOK
)
;
if
(
!
isOK
)
{
return
false
;
}
for
(
nsIFrame
*
kid
=
mFrames
.
FirstChild
(
)
;
kid
;
kid
=
kid
-
>
GetNextSibling
(
)
)
{
nsIAtom
*
type
=
kid
-
>
GetType
(
)
;
if
(
type
=
=
nsGkAtoms
:
:
svgUseFrame
)
{
for
(
nsIFrame
*
grandKid
:
kid
-
>
PrincipalChildList
(
)
)
{
nsIAtom
*
type
=
grandKid
-
>
GetType
(
)
;
if
(
type
!
=
nsGkAtoms
:
:
svgPathGeometryFrame
&
&
type
!
=
nsGkAtoms
:
:
svgTextFrame
)
{
return
false
;
}
}
continue
;
}
if
(
type
!
=
nsGkAtoms
:
:
svgPathGeometryFrame
&
&
type
!
=
nsGkAtoms
:
:
svgTextFrame
)
{
return
false
;
}
}
return
true
;
}
nsresult
nsSVGClipPathFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsIAtom
*
aAttribute
int32_t
aModType
)
{
if
(
aNameSpaceID
=
=
kNameSpaceID_None
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
transform
)
{
nsSVGEffects
:
:
InvalidateDirectRenderingObservers
(
this
)
;
nsSVGUtils
:
:
NotifyChildrenOfSVGChange
(
this
nsISVGChildFrame
:
:
TRANSFORM_CHANGED
)
;
}
if
(
aAttribute
=
=
nsGkAtoms
:
:
clipPathUnits
)
{
nsSVGEffects
:
:
InvalidateDirectRenderingObservers
(
this
)
;
}
}
return
nsSVGClipPathFrameBase
:
:
AttributeChanged
(
aNameSpaceID
aAttribute
aModType
)
;
}
void
nsSVGClipPathFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
NS_ASSERTION
(
aContent
-
>
IsSVGElement
(
nsGkAtoms
:
:
clipPath
)
"
Content
is
not
an
SVG
clipPath
!
"
)
;
AddStateBits
(
NS_STATE_SVG_CLIPPATH_CHILD
)
;
nsSVGClipPathFrameBase
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
}
nsIAtom
*
nsSVGClipPathFrame
:
:
GetType
(
)
const
{
return
nsGkAtoms
:
:
svgClipPathFrame
;
}
gfxMatrix
nsSVGClipPathFrame
:
:
GetCanvasTM
(
)
{
return
mMatrixForChildren
;
}
gfxMatrix
nsSVGClipPathFrame
:
:
GetClipPathTransform
(
nsIFrame
*
aClippedFrame
)
{
SVGClipPathElement
*
content
=
static_cast
<
SVGClipPathElement
*
>
(
mContent
)
;
gfxMatrix
tm
=
content
-
>
PrependLocalTransformsTo
(
gfxMatrix
(
)
)
;
nsSVGEnum
*
clipPathUnits
=
&
content
-
>
mEnumAttributes
[
SVGClipPathElement
:
:
CLIPPATHUNITS
]
;
return
nsSVGUtils
:
:
AdjustMatrixForUnits
(
tm
clipPathUnits
aClippedFrame
)
;
}
SVGBBox
nsSVGClipPathFrame
:
:
GetBBoxForClipPathFrame
(
const
SVGBBox
&
aBBox
const
gfxMatrix
&
aMatrix
)
{
nsIContent
*
node
=
GetContent
(
)
-
>
GetFirstChild
(
)
;
SVGBBox
unionBBox
tmpBBox
;
for
(
;
node
;
node
=
node
-
>
GetNextSibling
(
)
)
{
nsIFrame
*
frame
=
static_cast
<
nsSVGElement
*
>
(
node
)
-
>
GetPrimaryFrame
(
)
;
if
(
frame
)
{
nsISVGChildFrame
*
svg
=
do_QueryFrame
(
frame
)
;
if
(
svg
)
{
tmpBBox
=
svg
-
>
GetBBoxContribution
(
mozilla
:
:
gfx
:
:
ToMatrix
(
aMatrix
)
nsSVGUtils
:
:
eBBoxIncludeFill
)
;
nsSVGEffects
:
:
EffectProperties
effectProperties
=
nsSVGEffects
:
:
GetEffectProperties
(
frame
)
;
bool
isOK
=
true
;
nsSVGClipPathFrame
*
clipPathFrame
=
effectProperties
.
GetClipPathFrame
(
&
isOK
)
;
if
(
clipPathFrame
&
&
isOK
)
{
tmpBBox
=
clipPathFrame
-
>
GetBBoxForClipPathFrame
(
tmpBBox
aMatrix
)
;
}
tmpBBox
.
Intersect
(
aBBox
)
;
unionBBox
.
UnionEdges
(
tmpBBox
)
;
}
}
}
nsSVGEffects
:
:
EffectProperties
props
=
nsSVGEffects
:
:
GetEffectProperties
(
this
)
;
if
(
props
.
mClipPath
)
{
bool
isOK
=
true
;
nsSVGClipPathFrame
*
clipPathFrame
=
props
.
GetClipPathFrame
(
&
isOK
)
;
if
(
clipPathFrame
&
&
isOK
)
{
tmpBBox
=
clipPathFrame
-
>
GetBBoxForClipPathFrame
(
aBBox
aMatrix
)
;
unionBBox
.
Intersect
(
tmpBBox
)
;
}
else
if
(
!
isOK
)
{
unionBBox
=
SVGBBox
(
)
;
}
}
return
unionBBox
;
}
