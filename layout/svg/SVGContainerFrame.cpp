#
include
"
SVGContainerFrame
.
h
"
#
include
"
ImgDrawResult
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
mozilla
/
SVGObserverUtils
.
h
"
#
include
"
mozilla
/
SVGTextFrame
.
h
"
#
include
"
mozilla
/
SVGUtils
.
h
"
#
include
"
mozilla
/
dom
/
SVGElement
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
SVGAnimatedTransformList
.
h
"
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
image
;
nsIFrame
*
NS_NewSVGContainerFrame
(
mozilla
:
:
PresShell
*
aPresShell
mozilla
:
:
ComputedStyle
*
aStyle
)
{
nsIFrame
*
frame
=
new
(
aPresShell
)
mozilla
:
:
SVGContainerFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
mozilla
:
:
SVGContainerFrame
:
:
kClassID
)
;
frame
-
>
AddStateBits
(
NS_FRAME_IS_NONDISPLAY
)
;
return
frame
;
}
namespace
mozilla
{
NS_QUERYFRAME_HEAD
(
SVGContainerFrame
)
NS_QUERYFRAME_ENTRY
(
SVGContainerFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsContainerFrame
)
NS_QUERYFRAME_HEAD
(
SVGDisplayContainerFrame
)
NS_QUERYFRAME_ENTRY
(
SVGDisplayContainerFrame
)
NS_QUERYFRAME_ENTRY
(
ISVGDisplayableFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
SVGContainerFrame
)
NS_IMPL_FRAMEARENA_HELPERS
(
SVGContainerFrame
)
void
SVGContainerFrame
:
:
AppendFrames
(
ChildListID
aListID
nsFrameList
&
&
aFrameList
)
{
InsertFrames
(
aListID
mFrames
.
LastChild
(
)
nullptr
std
:
:
move
(
aFrameList
)
)
;
}
void
SVGContainerFrame
:
:
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
const
nsLineList
:
:
iterator
*
aPrevFrameLine
nsFrameList
&
&
aFrameList
)
{
NS_ASSERTION
(
aListID
=
=
FrameChildListID
:
:
Principal
"
unexpected
child
list
"
)
;
NS_ASSERTION
(
!
aPrevFrame
|
|
aPrevFrame
-
>
GetParent
(
)
=
=
this
"
inserting
after
sibling
frame
with
different
parent
"
)
;
mFrames
.
InsertFrames
(
this
aPrevFrame
std
:
:
move
(
aFrameList
)
)
;
}
void
SVGContainerFrame
:
:
RemoveFrame
(
DestroyContext
&
aContext
ChildListID
aListID
nsIFrame
*
aOldFrame
)
{
NS_ASSERTION
(
aListID
=
=
FrameChildListID
:
:
Principal
"
unexpected
child
list
"
)
;
mFrames
.
DestroyFrame
(
aContext
aOldFrame
)
;
}
bool
SVGContainerFrame
:
:
ComputeCustomOverflow
(
OverflowAreas
&
aOverflowAreas
)
{
if
(
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
)
{
return
false
;
}
return
nsContainerFrame
:
:
ComputeCustomOverflow
(
aOverflowAreas
)
;
}
void
SVGContainerFrame
:
:
ReflowSVGNonDisplayText
(
nsIFrame
*
aContainer
)
{
if
(
!
aContainer
-
>
HasAnyStateBits
(
NS_FRAME_IS_DIRTY
)
)
{
return
;
}
MOZ_ASSERT
(
aContainer
-
>
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
|
|
!
aContainer
-
>
IsSVGFrame
(
)
"
it
is
wasteful
to
call
ReflowSVGNonDisplayText
on
a
container
"
"
frame
that
is
not
NS_FRAME_IS_NONDISPLAY
or
not
SVG
"
)
;
for
(
nsIFrame
*
kid
:
aContainer
-
>
PrincipalChildList
(
)
)
{
LayoutFrameType
type
=
kid
-
>
Type
(
)
;
if
(
type
=
=
LayoutFrameType
:
:
SVGText
)
{
static_cast
<
SVGTextFrame
*
>
(
kid
)
-
>
ReflowSVGNonDisplayText
(
)
;
}
else
if
(
kid
-
>
IsSVGContainerFrame
(
)
|
|
type
=
=
LayoutFrameType
:
:
SVGForeignObject
|
|
!
kid
-
>
IsSVGFrame
(
)
)
{
ReflowSVGNonDisplayText
(
kid
)
;
}
}
}
void
SVGDisplayContainerFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
if
(
!
IsSVGOuterSVGFrame
(
)
)
{
AddStateBits
(
aParent
-
>
GetStateBits
(
)
&
NS_STATE_SVG_CLIPPATH_CHILD
)
;
}
SVGContainerFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
}
void
SVGDisplayContainerFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
if
(
auto
*
svg
=
SVGElement
:
:
FromNode
(
GetContent
(
)
)
)
{
if
(
!
svg
-
>
HasValidDimensions
(
)
)
{
return
;
}
}
DisplayOutline
(
aBuilder
aLists
)
;
return
BuildDisplayListForNonBlockChildren
(
aBuilder
aLists
)
;
}
void
SVGDisplayContainerFrame
:
:
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
const
nsLineList
:
:
iterator
*
aPrevFrameLine
nsFrameList
&
&
aFrameList
)
{
nsIFrame
*
nextFrame
=
aPrevFrame
?
aPrevFrame
-
>
GetNextSibling
(
)
:
GetChildList
(
aListID
)
.
FirstChild
(
)
;
nsIFrame
*
firstNewFrame
=
aFrameList
.
FirstChild
(
)
;
SVGContainerFrame
:
:
InsertFrames
(
aListID
aPrevFrame
aPrevFrameLine
std
:
:
move
(
aFrameList
)
)
;
if
(
!
HasAnyStateBits
(
NS_FRAME_IS_DIRTY
|
NS_FRAME_HAS_DIRTY_CHILDREN
|
NS_FRAME_IS_NONDISPLAY
)
)
{
for
(
nsIFrame
*
kid
=
firstNewFrame
;
kid
!
=
nextFrame
;
kid
=
kid
-
>
GetNextSibling
(
)
)
{
ISVGDisplayableFrame
*
SVGFrame
=
do_QueryFrame
(
kid
)
;
if
(
SVGFrame
&
&
!
kid
-
>
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
)
{
bool
isFirstReflow
=
kid
-
>
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
;
kid
-
>
RemoveStateBits
(
NS_FRAME_FIRST_REFLOW
|
NS_FRAME_IS_DIRTY
|
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
SVGUtils
:
:
ScheduleReflowSVG
(
kid
)
;
if
(
isFirstReflow
)
{
kid
-
>
AddStateBits
(
NS_FRAME_FIRST_REFLOW
)
;
}
}
}
}
}
void
SVGDisplayContainerFrame
:
:
RemoveFrame
(
DestroyContext
&
aContext
ChildListID
aListID
nsIFrame
*
aOldFrame
)
{
SVGObserverUtils
:
:
InvalidateRenderingObservers
(
aOldFrame
)
;
SchedulePaint
(
)
;
if
(
!
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
)
{
PresContext
(
)
-
>
RestyleManager
(
)
-
>
PostRestyleEvent
(
mContent
-
>
AsElement
(
)
RestyleHint
{
0
}
nsChangeHint_UpdateOverflow
)
;
}
SVGContainerFrame
:
:
RemoveFrame
(
aContext
aListID
aOldFrame
)
;
}
bool
SVGDisplayContainerFrame
:
:
DoGetParentSVGTransforms
(
gfx
:
:
Matrix
*
aFromParentTransform
)
const
{
return
SVGUtils
:
:
GetParentSVGTransforms
(
this
aFromParentTransform
)
;
}
void
SVGDisplayContainerFrame
:
:
PaintSVG
(
gfxContext
&
aContext
const
gfxMatrix
&
aTransform
imgDrawingParams
&
aImgParams
)
{
NS_ASSERTION
(
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
|
|
PresContext
(
)
-
>
Document
(
)
-
>
IsSVGGlyphsDocument
(
)
"
Only
painting
of
non
-
display
SVG
should
take
this
code
path
"
)
;
if
(
StyleEffects
(
)
-
>
IsTransparent
(
)
)
{
return
;
}
gfxMatrix
matrix
=
aTransform
;
if
(
auto
*
svg
=
SVGElement
:
:
FromNode
(
GetContent
(
)
)
)
{
matrix
=
svg
-
>
PrependLocalTransformsTo
(
matrix
eChildToUserSpace
)
;
if
(
matrix
.
IsSingular
(
)
)
{
return
;
}
}
for
(
auto
*
kid
:
mFrames
)
{
gfxMatrix
m
=
matrix
;
const
nsIContent
*
content
=
kid
-
>
GetContent
(
)
;
if
(
const
SVGElement
*
element
=
SVGElement
:
:
FromNode
(
content
)
)
{
if
(
!
element
-
>
HasValidDimensions
(
)
)
{
continue
;
}
m
=
SVGUtils
:
:
GetTransformMatrixInUserSpace
(
kid
)
*
m
;
if
(
m
.
IsSingular
(
)
)
{
continue
;
}
}
SVGUtils
:
:
PaintFrameWithEffects
(
kid
aContext
m
aImgParams
)
;
}
}
nsIFrame
*
SVGDisplayContainerFrame
:
:
GetFrameForPoint
(
const
gfxPoint
&
aPoint
)
{
NS_ASSERTION
(
HasAnyStateBits
(
NS_STATE_SVG_CLIPPATH_CHILD
)
"
Only
hit
-
testing
of
a
clipPath
'
s
contents
should
take
this
"
"
code
path
"
)
;
gfxPoint
point
=
aPoint
;
if
(
const
auto
*
svg
=
SVGElement
:
:
FromNode
(
GetContent
(
)
)
)
{
gfxMatrix
m
=
svg
-
>
PrependLocalTransformsTo
(
{
}
eChildToUserSpace
)
;
if
(
!
m
.
IsIdentity
(
)
)
{
if
(
!
m
.
Invert
(
)
)
{
return
nullptr
;
}
point
=
m
.
TransformPoint
(
point
)
;
}
}
nsIFrame
*
result
=
nullptr
;
for
(
nsIFrame
*
current
=
PrincipalChildList
(
)
.
LastChild
(
)
;
current
;
current
=
current
-
>
GetPrevSibling
(
)
)
{
ISVGDisplayableFrame
*
SVGFrame
=
do_QueryFrame
(
current
)
;
if
(
!
SVGFrame
)
{
continue
;
}
const
nsIContent
*
content
=
current
-
>
GetContent
(
)
;
if
(
const
auto
*
svg
=
SVGElement
:
:
FromNode
(
content
)
)
{
if
(
!
svg
-
>
HasValidDimensions
(
)
)
{
continue
;
}
}
result
=
SVGFrame
-
>
GetFrameForPoint
(
point
)
;
if
(
result
)
{
break
;
}
}
if
(
result
&
&
!
SVGUtils
:
:
HitTestClip
(
this
aPoint
)
)
{
result
=
nullptr
;
}
return
result
;
}
void
SVGDisplayContainerFrame
:
:
ReflowSVG
(
)
{
MOZ_ASSERT
(
SVGUtils
:
:
AnyOuterSVGIsCallingReflowSVG
(
this
)
"
This
call
is
probably
a
wasteful
mistake
"
)
;
MOZ_ASSERT
(
!
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
"
ReflowSVG
mechanism
not
designed
for
this
"
)
;
MOZ_ASSERT
(
!
IsSVGOuterSVGFrame
(
)
"
Do
not
call
on
outer
-
<
svg
>
"
)
;
if
(
!
SVGUtils
:
:
NeedsReflowSVG
(
this
)
)
{
return
;
}
bool
isFirstReflow
=
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
;
bool
outerSVGHasHadFirstReflow
=
!
GetParent
(
)
-
>
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
;
if
(
outerSVGHasHadFirstReflow
)
{
RemoveStateBits
(
NS_FRAME_FIRST_REFLOW
)
;
}
OverflowAreas
overflowRects
;
for
(
auto
*
kid
:
mFrames
)
{
ISVGDisplayableFrame
*
SVGFrame
=
do_QueryFrame
(
kid
)
;
if
(
SVGFrame
&
&
!
kid
-
>
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
)
{
SVGFrame
-
>
ReflowSVG
(
)
;
ConsiderChildOverflow
(
overflowRects
kid
)
;
}
else
{
MOZ_ASSERT
(
kid
-
>
HasAnyStateBits
(
NS_FRAME_IS_NONDISPLAY
)
|
|
!
kid
-
>
IsSVGFrame
(
)
"
expected
kid
to
be
a
NS_FRAME_IS_NONDISPLAY
frame
or
not
SVG
"
)
;
if
(
kid
-
>
HasAnyStateBits
(
NS_FRAME_IS_DIRTY
)
)
{
SVGContainerFrame
*
container
=
do_QueryFrame
(
kid
)
;
if
(
container
&
&
container
-
>
GetContent
(
)
-
>
IsSVGElement
(
)
)
{
ReflowSVGNonDisplayText
(
container
)
;
}
}
}
}
MOZ_ASSERT
(
mContent
-
>
IsAnyOfSVGElements
(
nsGkAtoms
:
:
svg
nsGkAtoms
:
:
symbol
)
|
|
(
mContent
-
>
IsSVGElement
(
nsGkAtoms
:
:
use
)
&
&
mRect
.
Size
(
)
=
=
nsSize
(
0
0
)
)
|
|
mRect
.
IsEqualEdges
(
nsRect
(
)
)
"
Only
inner
-
<
svg
>
/
<
use
>
is
expected
to
have
mRect
set
"
)
;
if
(
isFirstReflow
)
{
SVGObserverUtils
:
:
UpdateEffects
(
this
)
;
}
FinishAndStoreOverflow
(
overflowRects
mRect
.
Size
(
)
)
;
RemoveStateBits
(
NS_FRAME_FIRST_REFLOW
|
NS_FRAME_IS_DIRTY
|
NS_FRAME_HAS_DIRTY_CHILDREN
)
;
}
void
SVGDisplayContainerFrame
:
:
NotifySVGChanged
(
uint32_t
aFlags
)
{
MOZ_ASSERT
(
aFlags
&
(
TRANSFORM_CHANGED
|
COORD_CONTEXT_CHANGED
)
"
Invalidation
logic
may
need
adjusting
"
)
;
if
(
aFlags
&
TRANSFORM_CHANGED
)
{
mCanvasTM
=
nullptr
;
}
SVGUtils
:
:
NotifyChildrenOfSVGChange
(
this
aFlags
)
;
}
SVGBBox
SVGDisplayContainerFrame
:
:
GetBBoxContribution
(
const
Matrix
&
aToBBoxUserspace
uint32_t
aFlags
)
{
SVGBBox
bboxUnion
;
for
(
nsIFrame
*
kid
:
mFrames
)
{
ISVGDisplayableFrame
*
svgKid
=
do_QueryFrame
(
kid
)
;
if
(
!
svgKid
)
{
continue
;
}
auto
*
svg
=
SVGElement
:
:
FromNode
(
kid
-
>
GetContent
(
)
)
;
if
(
svg
&
&
!
svg
-
>
HasValidDimensions
(
)
)
{
continue
;
}
gfxMatrix
transform
=
gfx
:
:
ThebesMatrix
(
aToBBoxUserspace
)
;
if
(
svg
)
{
transform
=
svg
-
>
PrependLocalTransformsTo
(
{
}
eChildToUserSpace
)
*
SVGUtils
:
:
GetTransformMatrixInUserSpace
(
kid
)
*
transform
;
}
bboxUnion
.
UnionEdges
(
svgKid
-
>
GetBBoxContribution
(
gfx
:
:
ToMatrix
(
transform
)
aFlags
)
)
;
}
return
bboxUnion
;
}
gfxMatrix
SVGDisplayContainerFrame
:
:
GetCanvasTM
(
)
{
if
(
!
mCanvasTM
)
{
NS_ASSERTION
(
GetParent
(
)
"
null
parent
"
)
;
auto
*
parent
=
static_cast
<
SVGContainerFrame
*
>
(
GetParent
(
)
)
;
auto
*
content
=
static_cast
<
SVGElement
*
>
(
GetContent
(
)
)
;
gfxMatrix
tm
=
content
-
>
PrependLocalTransformsTo
(
parent
-
>
GetCanvasTM
(
)
)
;
mCanvasTM
=
MakeUnique
<
gfxMatrix
>
(
tm
)
;
}
return
*
mCanvasTM
;
}
}
