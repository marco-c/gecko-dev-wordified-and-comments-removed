#
include
"
SVGObserverUtils
.
h
"
#
include
"
mozilla
/
dom
/
CanvasRenderingContext2D
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsSVGClipPathFrame
.
h
"
#
include
"
nsSVGPaintServerFrame
.
h
"
#
include
"
nsSVGFilterFrame
.
h
"
#
include
"
nsSVGMaskFrame
.
h
"
#
include
"
nsIReflowCallback
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
SVGGeometryElement
.
h
"
#
include
"
SVGTextPathElement
.
h
"
#
include
"
SVGUseElement
.
h
"
#
include
"
ImageLoader
.
h
"
#
include
"
mozilla
/
net
/
ReferrerPolicy
.
h
"
using
namespace
mozilla
:
:
dom
;
static
already_AddRefed
<
URLAndReferrerInfo
>
ResolveURLUsingLocalRef
(
nsIFrame
*
aFrame
const
css
:
:
URLValue
*
aURL
)
{
MOZ_ASSERT
(
aFrame
)
;
if
(
!
aURL
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIURI
>
uri
=
aURL
-
>
GetURI
(
)
;
if
(
aURL
-
>
IsLocalRef
(
)
)
{
uri
=
SVGObserverUtils
:
:
GetBaseURLForLocalRef
(
aFrame
-
>
GetContent
(
)
uri
)
;
uri
=
aURL
-
>
ResolveLocalRef
(
uri
)
;
}
if
(
!
uri
)
{
return
nullptr
;
}
RefPtr
<
URLAndReferrerInfo
>
info
=
new
URLAndReferrerInfo
(
uri
aURL
-
>
ExtraData
(
)
)
;
return
info
.
forget
(
)
;
}
namespace
mozilla
{
class
SVGFilterObserverList
;
struct
nsSVGFrameReferenceFromProperty
{
explicit
nsSVGFrameReferenceFromProperty
(
nsIFrame
*
aFrame
)
:
mFrame
(
aFrame
)
mFramePresShell
(
aFrame
-
>
PresShell
(
)
)
{
}
void
Detach
(
)
{
mFrame
=
nullptr
;
mFramePresShell
=
nullptr
;
}
nsIFrame
*
Get
(
)
{
if
(
mFramePresShell
&
&
mFramePresShell
-
>
IsDestroying
(
)
)
{
Detach
(
)
;
}
return
mFrame
;
}
private
:
nsIFrame
*
mFrame
;
nsIPresShell
*
mFramePresShell
;
}
;
void
SVGRenderingObserver
:
:
StartObserving
(
)
{
Element
*
target
=
GetReferencedElementWithoutObserving
(
)
;
if
(
target
)
{
target
-
>
AddMutationObserver
(
this
)
;
}
}
void
SVGRenderingObserver
:
:
StopObserving
(
)
{
Element
*
target
=
GetReferencedElementWithoutObserving
(
)
;
if
(
target
)
{
target
-
>
RemoveMutationObserver
(
this
)
;
if
(
mInObserverList
)
{
SVGObserverUtils
:
:
RemoveRenderingObserver
(
target
this
)
;
mInObserverList
=
false
;
}
}
NS_ASSERTION
(
!
mInObserverList
"
still
in
an
observer
list
?
"
)
;
}
Element
*
SVGRenderingObserver
:
:
GetAndObserveReferencedElement
(
)
{
#
ifdef
DEBUG
DebugObserverSet
(
)
;
#
endif
Element
*
referencedElement
=
GetReferencedElementWithoutObserving
(
)
;
if
(
referencedElement
&
&
!
mInObserverList
)
{
SVGObserverUtils
:
:
AddRenderingObserver
(
referencedElement
this
)
;
mInObserverList
=
true
;
}
return
referencedElement
;
}
nsIFrame
*
SVGRenderingObserver
:
:
GetAndObserveReferencedFrame
(
)
{
Element
*
referencedElement
=
GetAndObserveReferencedElement
(
)
;
return
referencedElement
?
referencedElement
-
>
GetPrimaryFrame
(
)
:
nullptr
;
}
nsIFrame
*
SVGRenderingObserver
:
:
GetAndObserveReferencedFrame
(
LayoutFrameType
aFrameType
bool
*
aOK
)
{
nsIFrame
*
frame
=
GetAndObserveReferencedFrame
(
)
;
if
(
frame
)
{
if
(
frame
-
>
Type
(
)
=
=
aFrameType
)
return
frame
;
if
(
aOK
)
{
*
aOK
=
false
;
}
}
return
nullptr
;
}
void
SVGRenderingObserver
:
:
OnNonDOMMutationRenderingChange
(
)
{
mInObserverList
=
false
;
OnRenderingChange
(
)
;
}
void
SVGRenderingObserver
:
:
NotifyEvictedFromRenderingObserverSet
(
)
{
mInObserverList
=
false
;
StopObserving
(
)
;
}
void
SVGRenderingObserver
:
:
AttributeChanged
(
dom
:
:
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
const
nsAttrValue
*
aOldValue
)
{
OnRenderingChange
(
)
;
}
void
SVGRenderingObserver
:
:
ContentAppended
(
nsIContent
*
aFirstNewContent
)
{
OnRenderingChange
(
)
;
}
void
SVGRenderingObserver
:
:
ContentInserted
(
nsIContent
*
aChild
)
{
OnRenderingChange
(
)
;
}
void
SVGRenderingObserver
:
:
ContentRemoved
(
nsIContent
*
aChild
nsIContent
*
aPreviousSibling
)
{
OnRenderingChange
(
)
;
}
class
SVGIDRenderingObserver
:
public
SVGRenderingObserver
{
public
:
SVGIDRenderingObserver
(
URLAndReferrerInfo
*
aURI
nsIContent
*
aObservingContent
bool
aReferenceImage
)
;
protected
:
virtual
~
SVGIDRenderingObserver
(
)
{
StopObserving
(
)
;
}
Element
*
GetReferencedElementWithoutObserving
(
)
final
{
return
mObservedElementTracker
.
get
(
)
;
}
void
OnRenderingChange
(
)
override
;
class
ElementTracker
final
:
public
IDTracker
{
public
:
explicit
ElementTracker
(
SVGIDRenderingObserver
*
aOwningObserver
)
:
mOwningObserver
(
aOwningObserver
)
{
}
protected
:
void
ElementChanged
(
Element
*
aFrom
Element
*
aTo
)
override
{
mOwningObserver
-
>
StopObserving
(
)
;
IDTracker
:
:
ElementChanged
(
aFrom
aTo
)
;
mOwningObserver
-
>
StartObserving
(
)
;
mOwningObserver
-
>
OnRenderingChange
(
)
;
}
bool
IsPersistent
(
)
override
{
return
true
;
}
private
:
SVGIDRenderingObserver
*
mOwningObserver
;
}
;
ElementTracker
mObservedElementTracker
;
}
;
SVGIDRenderingObserver
:
:
SVGIDRenderingObserver
(
URLAndReferrerInfo
*
aURI
nsIContent
*
aObservingContent
bool
aReferenceImage
)
:
mObservedElementTracker
(
this
)
{
nsCOMPtr
<
nsIURI
>
uri
;
nsCOMPtr
<
nsIURI
>
referrer
;
uint32_t
referrerPolicy
=
mozilla
:
:
net
:
:
RP_Unset
;
if
(
aURI
)
{
uri
=
aURI
-
>
GetURI
(
)
;
referrer
=
aURI
-
>
GetReferrer
(
)
;
referrerPolicy
=
aURI
-
>
GetReferrerPolicy
(
)
;
}
mObservedElementTracker
.
Reset
(
aObservingContent
uri
referrer
referrerPolicy
true
aReferenceImage
)
;
StartObserving
(
)
;
}
void
SVGIDRenderingObserver
:
:
OnRenderingChange
(
)
{
if
(
mObservedElementTracker
.
get
(
)
&
&
mInObserverList
)
{
SVGObserverUtils
:
:
RemoveRenderingObserver
(
mObservedElementTracker
.
get
(
)
this
)
;
mInObserverList
=
false
;
}
}
class
nsSVGRenderingObserverProperty
:
public
SVGIDRenderingObserver
{
public
:
NS_DECL_ISUPPORTS
nsSVGRenderingObserverProperty
(
URLAndReferrerInfo
*
aURI
nsIFrame
*
aFrame
bool
aReferenceImage
)
:
SVGIDRenderingObserver
(
aURI
aFrame
-
>
GetContent
(
)
aReferenceImage
)
mFrameReference
(
aFrame
)
{
}
protected
:
virtual
~
nsSVGRenderingObserverProperty
(
)
=
default
;
void
OnRenderingChange
(
)
override
;
nsSVGFrameReferenceFromProperty
mFrameReference
;
}
;
NS_IMPL_ISUPPORTS
(
nsSVGRenderingObserverProperty
nsIMutationObserver
)
void
nsSVGRenderingObserverProperty
:
:
OnRenderingChange
(
)
{
SVGIDRenderingObserver
:
:
OnRenderingChange
(
)
;
nsIFrame
*
frame
=
mFrameReference
.
Get
(
)
;
if
(
frame
&
&
frame
-
>
HasAllStateBits
(
NS_FRAME_SVG_LAYOUT
)
)
{
nsLayoutUtils
:
:
PostRestyleEvent
(
frame
-
>
GetContent
(
)
-
>
AsElement
(
)
nsRestyleHint
(
0
)
nsChangeHint_InvalidateRenderingObservers
)
;
}
}
class
SVGTextPathObserver
final
:
public
nsSVGRenderingObserverProperty
{
public
:
SVGTextPathObserver
(
URLAndReferrerInfo
*
aURI
nsIFrame
*
aFrame
bool
aReferenceImage
)
:
nsSVGRenderingObserverProperty
(
aURI
aFrame
aReferenceImage
)
mValid
(
true
)
{
}
bool
ObservesReflow
(
)
override
{
return
false
;
}
protected
:
void
OnRenderingChange
(
)
override
;
private
:
bool
TargetIsValid
(
)
{
Element
*
target
=
GetReferencedElementWithoutObserving
(
)
;
return
target
&
&
target
-
>
IsSVGElement
(
nsGkAtoms
:
:
path
)
;
}
bool
mValid
;
}
;
void
SVGTextPathObserver
:
:
OnRenderingChange
(
)
{
nsSVGRenderingObserverProperty
:
:
OnRenderingChange
(
)
;
nsIFrame
*
frame
=
mFrameReference
.
Get
(
)
;
if
(
!
frame
)
{
return
;
}
MOZ_ASSERT
(
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
|
|
nsSVGUtils
:
:
IsInSVGTextSubtree
(
frame
)
"
SVG
frame
expected
"
)
;
bool
nowValid
=
TargetIsValid
(
)
;
if
(
!
mValid
&
&
!
nowValid
)
{
return
;
}
mValid
=
nowValid
;
nsChangeHint
changeHint
=
nsChangeHint
(
nsChangeHint_RepaintFrame
|
nsChangeHint_UpdateTextPath
)
;
frame
-
>
PresContext
(
)
-
>
RestyleManager
(
)
-
>
PostRestyleEvent
(
frame
-
>
GetContent
(
)
-
>
AsElement
(
)
nsRestyleHint
(
0
)
changeHint
)
;
}
class
SVGMarkerObserver
final
:
public
nsSVGRenderingObserverProperty
{
public
:
SVGMarkerObserver
(
URLAndReferrerInfo
*
aURI
nsIFrame
*
aFrame
bool
aReferenceImage
)
:
nsSVGRenderingObserverProperty
(
aURI
aFrame
aReferenceImage
)
{
}
protected
:
void
OnRenderingChange
(
)
override
;
}
;
void
SVGMarkerObserver
:
:
OnRenderingChange
(
)
{
nsSVGRenderingObserverProperty
:
:
OnRenderingChange
(
)
;
nsIFrame
*
frame
=
mFrameReference
.
Get
(
)
;
if
(
!
frame
)
{
return
;
}
MOZ_ASSERT
(
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
"
SVG
frame
expected
"
)
;
if
(
!
(
frame
-
>
GetStateBits
(
)
&
NS_FRAME_IN_REFLOW
)
)
{
nsSVGUtils
:
:
ScheduleReflowSVG
(
frame
)
;
}
frame
-
>
PresContext
(
)
-
>
RestyleManager
(
)
-
>
PostRestyleEvent
(
frame
-
>
GetContent
(
)
-
>
AsElement
(
)
nsRestyleHint
(
0
)
nsChangeHint_RepaintFrame
)
;
}
class
nsSVGPaintingProperty
final
:
public
nsSVGRenderingObserverProperty
{
public
:
nsSVGPaintingProperty
(
URLAndReferrerInfo
*
aURI
nsIFrame
*
aFrame
bool
aReferenceImage
)
:
nsSVGRenderingObserverProperty
(
aURI
aFrame
aReferenceImage
)
{
}
protected
:
void
OnRenderingChange
(
)
override
;
}
;
void
nsSVGPaintingProperty
:
:
OnRenderingChange
(
)
{
nsSVGRenderingObserverProperty
:
:
OnRenderingChange
(
)
;
nsIFrame
*
frame
=
mFrameReference
.
Get
(
)
;
if
(
!
frame
)
{
return
;
}
if
(
frame
-
>
GetStateBits
(
)
&
NS_FRAME_SVG_LAYOUT
)
{
frame
-
>
InvalidateFrameSubtree
(
)
;
}
else
{
for
(
nsIFrame
*
f
=
frame
;
f
;
f
=
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
f
)
)
{
f
-
>
InvalidateFrame
(
)
;
}
}
}
class
SVGFilterObserver
final
:
public
SVGIDRenderingObserver
{
public
:
SVGFilterObserver
(
URLAndReferrerInfo
*
aURI
nsIContent
*
aObservingContent
SVGFilterObserverList
*
aFilterChainObserver
)
:
SVGIDRenderingObserver
(
aURI
aObservingContent
false
)
mFilterObserverList
(
aFilterChainObserver
)
{
}
bool
ReferencesValidResource
(
)
{
return
GetAndObserveFilterFrame
(
)
;
}
void
DetachFromChainObserver
(
)
{
mFilterObserverList
=
nullptr
;
}
nsSVGFilterFrame
*
GetAndObserveFilterFrame
(
)
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
SVGFilterObserver
)
void
Invalidate
(
)
{
OnRenderingChange
(
)
;
}
;
protected
:
virtual
~
SVGFilterObserver
(
)
=
default
;
void
OnRenderingChange
(
)
override
;
private
:
SVGFilterObserverList
*
mFilterObserverList
;
}
;
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
SVGFilterObserver
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
SVGFilterObserver
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
SVGFilterObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_ENTRY
(
nsIMutationObserver
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION_CLASS
(
SVGFilterObserver
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
SVGFilterObserver
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mObservedElementTracker
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
SVGFilterObserver
)
tmp
-
>
StopObserving
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mObservedElementTracker
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
nsSVGFilterFrame
*
SVGFilterObserver
:
:
GetAndObserveFilterFrame
(
)
{
return
static_cast
<
nsSVGFilterFrame
*
>
(
GetAndObserveReferencedFrame
(
LayoutFrameType
:
:
SVGFilter
nullptr
)
)
;
}
class
SVGFilterObserverList
:
public
nsISupports
{
public
:
SVGFilterObserverList
(
const
nsTArray
<
nsStyleFilter
>
&
aFilters
nsIContent
*
aFilteredElement
nsIFrame
*
aFiltedFrame
=
nullptr
)
;
bool
ReferencesValidResources
(
)
;
void
Invalidate
(
)
{
OnRenderingChange
(
)
;
}
const
nsTArray
<
RefPtr
<
SVGFilterObserver
>
>
&
GetObservers
(
)
const
{
return
mObservers
;
}
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
SVGFilterObserverList
)
protected
:
virtual
~
SVGFilterObserverList
(
)
;
virtual
void
OnRenderingChange
(
)
=
0
;
private
:
void
DetachObservers
(
)
{
for
(
uint32_t
i
=
0
;
i
<
mObservers
.
Length
(
)
;
i
+
+
)
{
mObservers
[
i
]
-
>
DetachFromChainObserver
(
)
;
}
}
nsTArray
<
RefPtr
<
SVGFilterObserver
>
>
mObservers
;
}
;
void
SVGFilterObserver
:
:
OnRenderingChange
(
)
{
SVGIDRenderingObserver
:
:
OnRenderingChange
(
)
;
if
(
mFilterObserverList
)
{
mFilterObserverList
-
>
Invalidate
(
)
;
}
}
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
SVGFilterObserverList
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
SVGFilterObserverList
)
NS_IMPL_CYCLE_COLLECTION_CLASS
(
SVGFilterObserverList
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
SVGFilterObserverList
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mObservers
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
SVGFilterObserverList
)
tmp
-
>
DetachObservers
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mObservers
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
SVGFilterObserverList
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
SVGFilterObserverList
:
:
SVGFilterObserverList
(
const
nsTArray
<
nsStyleFilter
>
&
aFilters
nsIContent
*
aFilteredElement
nsIFrame
*
aFilteredFrame
)
{
for
(
uint32_t
i
=
0
;
i
<
aFilters
.
Length
(
)
;
i
+
+
)
{
if
(
aFilters
[
i
]
.
GetType
(
)
!
=
NS_STYLE_FILTER_URL
)
{
continue
;
}
RefPtr
<
URLAndReferrerInfo
>
filterURL
;
if
(
aFilteredFrame
)
{
filterURL
=
ResolveURLUsingLocalRef
(
aFilteredFrame
aFilters
[
i
]
.
GetURL
(
)
)
;
}
else
{
nsCOMPtr
<
nsIURI
>
resolvedURI
=
aFilters
[
i
]
.
GetURL
(
)
-
>
ResolveLocalRef
(
aFilteredElement
)
;
if
(
resolvedURI
)
{
filterURL
=
new
URLAndReferrerInfo
(
resolvedURI
aFilters
[
i
]
.
GetURL
(
)
-
>
ExtraData
(
)
)
;
}
}
RefPtr
<
SVGFilterObserver
>
observer
=
new
SVGFilterObserver
(
filterURL
aFilteredElement
this
)
;
mObservers
.
AppendElement
(
observer
)
;
}
}
SVGFilterObserverList
:
:
~
SVGFilterObserverList
(
)
{
DetachObservers
(
)
;
}
bool
SVGFilterObserverList
:
:
ReferencesValidResources
(
)
{
for
(
uint32_t
i
=
0
;
i
<
mObservers
.
Length
(
)
;
i
+
+
)
{
if
(
!
mObservers
[
i
]
-
>
ReferencesValidResource
(
)
)
{
return
false
;
}
}
return
true
;
}
class
SVGFilterObserverListForCSSProp
final
:
public
SVGFilterObserverList
{
public
:
SVGFilterObserverListForCSSProp
(
const
nsTArray
<
nsStyleFilter
>
&
aFilters
nsIFrame
*
aFilteredFrame
)
:
SVGFilterObserverList
(
aFilters
aFilteredFrame
-
>
GetContent
(
)
aFilteredFrame
)
mFrameReference
(
aFilteredFrame
)
{
}
void
DetachFromFrame
(
)
{
mFrameReference
.
Detach
(
)
;
}
protected
:
void
OnRenderingChange
(
)
override
;
nsSVGFrameReferenceFromProperty
mFrameReference
;
}
;
void
SVGFilterObserverListForCSSProp
:
:
OnRenderingChange
(
)
{
nsIFrame
*
frame
=
mFrameReference
.
Get
(
)
;
if
(
!
frame
)
return
;
nsChangeHint
changeHint
=
nsChangeHint
(
nsChangeHint_RepaintFrame
)
;
if
(
frame
-
>
HasAllStateBits
(
NS_FRAME_SVG_LAYOUT
)
)
{
changeHint
|
=
nsChangeHint_InvalidateRenderingObservers
;
}
if
(
!
(
frame
-
>
GetStateBits
(
)
&
NS_FRAME_IN_REFLOW
)
)
{
changeHint
|
=
nsChangeHint_UpdateOverflow
;
}
frame
-
>
PresContext
(
)
-
>
RestyleManager
(
)
-
>
PostRestyleEvent
(
frame
-
>
GetContent
(
)
-
>
AsElement
(
)
nsRestyleHint
(
0
)
changeHint
)
;
}
class
SVGFilterObserverListForCanvasContext
final
:
public
SVGFilterObserverList
{
public
:
SVGFilterObserverListForCanvasContext
(
CanvasRenderingContext2D
*
aContext
Element
*
aCanvasElement
nsTArray
<
nsStyleFilter
>
&
aFilters
)
:
SVGFilterObserverList
(
aFilters
aCanvasElement
)
mContext
(
aContext
)
{
}
void
OnRenderingChange
(
)
override
;
void
DetachFromContext
(
)
{
mContext
=
nullptr
;
}
private
:
CanvasRenderingContext2D
*
mContext
;
}
;
void
SVGFilterObserverListForCanvasContext
:
:
OnRenderingChange
(
)
{
if
(
!
mContext
)
{
MOZ_CRASH
(
"
GFX
:
This
should
never
be
called
without
a
context
"
)
;
}
RefPtr
<
CanvasRenderingContext2D
>
kungFuDeathGrip
(
mContext
)
;
kungFuDeathGrip
-
>
UpdateFilter
(
)
;
}
class
SVGMaskObserverList
final
:
public
nsISupports
{
public
:
explicit
SVGMaskObserverList
(
nsIFrame
*
aFrame
)
;
NS_DECL_ISUPPORTS
const
nsTArray
<
RefPtr
<
nsSVGPaintingProperty
>
>
&
GetObservers
(
)
const
{
return
mProperties
;
}
void
ResolveImage
(
uint32_t
aIndex
)
;
private
:
virtual
~
SVGMaskObserverList
(
)
=
default
;
nsTArray
<
RefPtr
<
nsSVGPaintingProperty
>
>
mProperties
;
nsIFrame
*
mFrame
;
}
;
NS_IMPL_ISUPPORTS
(
SVGMaskObserverList
nsISupports
)
SVGMaskObserverList
:
:
SVGMaskObserverList
(
nsIFrame
*
aFrame
)
:
mFrame
(
aFrame
)
{
const
nsStyleSVGReset
*
svgReset
=
aFrame
-
>
StyleSVGReset
(
)
;
for
(
uint32_t
i
=
0
;
i
<
svgReset
-
>
mMask
.
mImageCount
;
i
+
+
)
{
css
:
:
URLValue
*
data
=
svgReset
-
>
mMask
.
mLayers
[
i
]
.
mImage
.
GetURLValue
(
)
;
RefPtr
<
URLAndReferrerInfo
>
maskUri
=
ResolveURLUsingLocalRef
(
aFrame
data
)
;
bool
hasRef
=
false
;
if
(
maskUri
)
{
maskUri
-
>
GetURI
(
)
-
>
GetHasRef
(
&
hasRef
)
;
}
nsSVGPaintingProperty
*
prop
=
new
nsSVGPaintingProperty
(
hasRef
?
maskUri
.
get
(
)
:
nullptr
aFrame
false
)
;
mProperties
.
AppendElement
(
prop
)
;
}
}
void
SVGMaskObserverList
:
:
ResolveImage
(
uint32_t
aIndex
)
{
const
nsStyleSVGReset
*
svgReset
=
mFrame
-
>
StyleSVGReset
(
)
;
MOZ_ASSERT
(
aIndex
<
svgReset
-
>
mMask
.
mImageCount
)
;
nsStyleImage
&
image
=
const_cast
<
nsStyleImage
&
>
(
svgReset
-
>
mMask
.
mLayers
[
aIndex
]
.
mImage
)
;
if
(
!
image
.
IsResolved
(
)
)
{
MOZ_ASSERT
(
image
.
GetType
(
)
=
=
nsStyleImageType
:
:
eStyleImageType_Image
)
;
image
.
ResolveImage
(
mFrame
-
>
PresContext
(
)
nullptr
)
;
mozilla
:
:
css
:
:
ImageLoader
*
imageLoader
=
mFrame
-
>
PresContext
(
)
-
>
Document
(
)
-
>
StyleImageLoader
(
)
;
if
(
imgRequestProxy
*
req
=
image
.
GetImageData
(
)
)
{
imageLoader
-
>
AssociateRequestToFrame
(
req
mFrame
0
)
;
}
}
}
class
SVGTemplateElementObserver
:
public
SVGIDRenderingObserver
{
public
:
NS_DECL_ISUPPORTS
SVGTemplateElementObserver
(
URLAndReferrerInfo
*
aURI
nsIFrame
*
aFrame
bool
aReferenceImage
)
:
SVGIDRenderingObserver
(
aURI
aFrame
-
>
GetContent
(
)
aReferenceImage
)
mFrameReference
(
aFrame
)
{
}
protected
:
virtual
~
SVGTemplateElementObserver
(
)
=
default
;
void
OnRenderingChange
(
)
override
;
nsSVGFrameReferenceFromProperty
mFrameReference
;
}
;
NS_IMPL_ISUPPORTS
(
SVGTemplateElementObserver
nsIMutationObserver
)
void
SVGTemplateElementObserver
:
:
OnRenderingChange
(
)
{
SVGIDRenderingObserver
:
:
OnRenderingChange
(
)
;
if
(
nsIFrame
*
frame
=
mFrameReference
.
Get
(
)
)
{
SVGObserverUtils
:
:
InvalidateDirectRenderingObservers
(
frame
)
;
}
}
class
SVGRenderingObserverSet
{
public
:
SVGRenderingObserverSet
(
)
:
mObservers
(
4
)
{
MOZ_COUNT_CTOR
(
SVGRenderingObserverSet
)
;
}
~
SVGRenderingObserverSet
(
)
{
InvalidateAll
(
)
;
MOZ_COUNT_DTOR
(
SVGRenderingObserverSet
)
;
}
void
Add
(
SVGRenderingObserver
*
aObserver
)
{
mObservers
.
PutEntry
(
aObserver
)
;
}
void
Remove
(
SVGRenderingObserver
*
aObserver
)
{
mObservers
.
RemoveEntry
(
aObserver
)
;
}
#
ifdef
DEBUG
bool
Contains
(
SVGRenderingObserver
*
aObserver
)
{
return
(
mObservers
.
GetEntry
(
aObserver
)
!
=
nullptr
)
;
}
#
endif
bool
IsEmpty
(
)
{
return
mObservers
.
IsEmpty
(
)
;
}
void
InvalidateAll
(
)
;
void
InvalidateAllForReflow
(
)
;
void
RemoveAll
(
)
;
private
:
nsTHashtable
<
nsPtrHashKey
<
SVGRenderingObserver
>
>
mObservers
;
}
;
void
SVGRenderingObserverSet
:
:
InvalidateAll
(
)
{
if
(
mObservers
.
IsEmpty
(
)
)
{
return
;
}
AutoTArray
<
SVGRenderingObserver
*
10
>
observers
;
for
(
auto
it
=
mObservers
.
Iter
(
)
;
!
it
.
Done
(
)
;
it
.
Next
(
)
)
{
observers
.
AppendElement
(
it
.
Get
(
)
-
>
GetKey
(
)
)
;
}
mObservers
.
Clear
(
)
;
for
(
uint32_t
i
=
0
;
i
<
observers
.
Length
(
)
;
+
+
i
)
{
observers
[
i
]
-
>
OnNonDOMMutationRenderingChange
(
)
;
}
}
void
SVGRenderingObserverSet
:
:
InvalidateAllForReflow
(
)
{
if
(
mObservers
.
IsEmpty
(
)
)
{
return
;
}
AutoTArray
<
SVGRenderingObserver
*
10
>
observers
;
for
(
auto
it
=
mObservers
.
Iter
(
)
;
!
it
.
Done
(
)
;
it
.
Next
(
)
)
{
SVGRenderingObserver
*
obs
=
it
.
Get
(
)
-
>
GetKey
(
)
;
if
(
obs
-
>
ObservesReflow
(
)
)
{
observers
.
AppendElement
(
obs
)
;
it
.
Remove
(
)
;
}
}
for
(
uint32_t
i
=
0
;
i
<
observers
.
Length
(
)
;
+
+
i
)
{
observers
[
i
]
-
>
OnNonDOMMutationRenderingChange
(
)
;
}
}
void
SVGRenderingObserverSet
:
:
RemoveAll
(
)
{
AutoTArray
<
SVGRenderingObserver
*
10
>
observers
;
for
(
auto
it
=
mObservers
.
Iter
(
)
;
!
it
.
Done
(
)
;
it
.
Next
(
)
)
{
observers
.
AppendElement
(
it
.
Get
(
)
-
>
GetKey
(
)
)
;
}
mObservers
.
Clear
(
)
;
for
(
uint32_t
i
=
0
;
i
<
observers
.
Length
(
)
;
+
+
i
)
{
observers
[
i
]
-
>
NotifyEvictedFromRenderingObserverSet
(
)
;
}
}
static
SVGRenderingObserverSet
*
GetObserverSet
(
Element
*
aElement
)
{
return
static_cast
<
SVGRenderingObserverSet
*
>
(
aElement
-
>
GetProperty
(
nsGkAtoms
:
:
renderingobserverset
)
)
;
}
#
ifdef
DEBUG
void
SVGRenderingObserver
:
:
DebugObserverSet
(
)
{
Element
*
referencedElement
=
GetReferencedElementWithoutObserving
(
)
;
if
(
referencedElement
)
{
SVGRenderingObserverSet
*
observers
=
GetObserverSet
(
referencedElement
)
;
bool
inObserverSet
=
observers
&
&
observers
-
>
Contains
(
this
)
;
MOZ_ASSERT
(
inObserverSet
=
=
mInObserverList
"
failed
to
track
whether
we
'
re
in
our
referenced
element
'
s
observer
set
!
"
)
;
}
else
{
MOZ_ASSERT
(
!
mInObserverList
"
In
whose
observer
set
are
we
then
?
"
)
;
}
}
#
endif
typedef
nsInterfaceHashtable
<
nsRefPtrHashKey
<
URLAndReferrerInfo
>
nsIMutationObserver
>
URIObserverHashtable
;
using
PaintingPropertyDescriptor
=
const
mozilla
:
:
FramePropertyDescriptor
<
nsSVGPaintingProperty
>
*
;
void
DestroyFilterProperty
(
SVGFilterObserverListForCSSProp
*
aProp
)
{
aProp
-
>
DetachFromFrame
(
)
;
aProp
-
>
Release
(
)
;
}
NS_DECLARE_FRAME_PROPERTY_RELEASABLE
(
HrefToTemplateProperty
SVGTemplateElementObserver
)
NS_DECLARE_FRAME_PROPERTY_WITH_DTOR
(
FilterProperty
SVGFilterObserverListForCSSProp
DestroyFilterProperty
)
NS_DECLARE_FRAME_PROPERTY_RELEASABLE
(
MaskProperty
SVGMaskObserverList
)
NS_DECLARE_FRAME_PROPERTY_RELEASABLE
(
ClipPathProperty
nsSVGPaintingProperty
)
NS_DECLARE_FRAME_PROPERTY_RELEASABLE
(
MarkerStartProperty
SVGMarkerObserver
)
NS_DECLARE_FRAME_PROPERTY_RELEASABLE
(
MarkerMidProperty
SVGMarkerObserver
)
NS_DECLARE_FRAME_PROPERTY_RELEASABLE
(
MarkerEndProperty
SVGMarkerObserver
)
NS_DECLARE_FRAME_PROPERTY_RELEASABLE
(
FillProperty
nsSVGPaintingProperty
)
NS_DECLARE_FRAME_PROPERTY_RELEASABLE
(
StrokeProperty
nsSVGPaintingProperty
)
NS_DECLARE_FRAME_PROPERTY_RELEASABLE
(
HrefAsTextPathProperty
SVGTextPathObserver
)
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
BackgroundImageProperty
URIObserverHashtable
)
template
<
class
T
>
static
T
*
GetEffectProperty
(
URLAndReferrerInfo
*
aURI
nsIFrame
*
aFrame
const
mozilla
:
:
FramePropertyDescriptor
<
T
>
*
aProperty
)
{
if
(
!
aURI
)
return
nullptr
;
T
*
prop
=
aFrame
-
>
GetProperty
(
aProperty
)
;
if
(
prop
)
return
prop
;
prop
=
new
T
(
aURI
aFrame
false
)
;
NS_ADDREF
(
prop
)
;
aFrame
-
>
SetProperty
(
aProperty
prop
)
;
return
prop
;
}
static
nsSVGPaintingProperty
*
GetPaintingProperty
(
URLAndReferrerInfo
*
aURI
nsIFrame
*
aFrame
const
mozilla
:
:
FramePropertyDescriptor
<
nsSVGPaintingProperty
>
*
aProperty
)
{
return
GetEffectProperty
(
aURI
aFrame
aProperty
)
;
}
static
already_AddRefed
<
URLAndReferrerInfo
>
GetMarkerURI
(
nsIFrame
*
aFrame
RefPtr
<
css
:
:
URLValue
>
nsStyleSVG
:
:
*
aMarker
)
{
return
ResolveURLUsingLocalRef
(
aFrame
aFrame
-
>
StyleSVG
(
)
-
>
*
aMarker
)
;
}
bool
SVGObserverUtils
:
:
GetAndObserveMarkers
(
nsIFrame
*
aMarkedFrame
nsSVGMarkerFrame
*
(
*
aFrames
)
[
3
]
)
{
MOZ_ASSERT
(
!
aMarkedFrame
-
>
GetPrevContinuation
(
)
&
&
aMarkedFrame
-
>
IsSVGGeometryFrame
(
)
&
&
static_cast
<
SVGGeometryElement
*
>
(
aMarkedFrame
-
>
GetContent
(
)
)
-
>
IsMarkable
(
)
"
Bad
frame
"
)
;
bool
foundMarker
=
false
;
RefPtr
<
URLAndReferrerInfo
>
markerURL
;
SVGMarkerObserver
*
observer
;
nsIFrame
*
marker
;
#
define
GET_MARKER
(
type
)
\
markerURL
=
GetMarkerURI
(
aMarkedFrame
&
nsStyleSVG
:
:
mMarker
#
#
type
)
;
\
observer
=
GetEffectProperty
(
markerURL
aMarkedFrame
\
Marker
#
#
type
#
#
Property
(
)
)
;
\
marker
=
observer
?
\
observer
-
>
GetAndObserveReferencedFrame
(
LayoutFrameType
:
:
SVGMarker
\
nullptr
)
:
\
nullptr
;
\
foundMarker
=
foundMarker
|
|
bool
(
marker
)
;
\
(
*
aFrames
)
[
nsSVGMark
:
:
e
#
#
type
]
=
static_cast
<
nsSVGMarkerFrame
*
>
(
marker
)
;
GET_MARKER
(
Start
)
GET_MARKER
(
Mid
)
GET_MARKER
(
End
)
#
undef
GET_MARKER
return
foundMarker
;
}
static
SVGFilterObserverListForCSSProp
*
GetOrCreateFilterObserverListForCSS
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
!
aFrame
-
>
GetPrevContinuation
(
)
"
Require
first
continuation
"
)
;
const
nsStyleEffects
*
effects
=
aFrame
-
>
StyleEffects
(
)
;
if
(
!
effects
-
>
HasFilters
(
)
)
{
return
nullptr
;
}
SVGFilterObserverListForCSSProp
*
observers
=
aFrame
-
>
GetProperty
(
FilterProperty
(
)
)
;
if
(
observers
)
{
return
observers
;
}
observers
=
new
SVGFilterObserverListForCSSProp
(
effects
-
>
mFilters
aFrame
)
;
NS_ADDREF
(
observers
)
;
aFrame
-
>
SetProperty
(
FilterProperty
(
)
observers
)
;
return
observers
;
}
static
SVGObserverUtils
:
:
ReferenceState
GetAndObserveFilters
(
SVGFilterObserverListForCSSProp
*
aObserverList
nsTArray
<
nsSVGFilterFrame
*
>
*
aFilterFrames
)
{
if
(
!
aObserverList
)
{
return
SVGObserverUtils
:
:
eHasNoRefs
;
}
const
nsTArray
<
RefPtr
<
SVGFilterObserver
>
>
&
observers
=
aObserverList
-
>
GetObservers
(
)
;
if
(
observers
.
IsEmpty
(
)
)
{
return
SVGObserverUtils
:
:
eHasNoRefs
;
}
for
(
uint32_t
i
=
0
;
i
<
observers
.
Length
(
)
;
i
+
+
)
{
nsSVGFilterFrame
*
filter
=
observers
[
i
]
-
>
GetAndObserveFilterFrame
(
)
;
if
(
!
filter
)
{
if
(
aFilterFrames
)
{
aFilterFrames
-
>
Clear
(
)
;
}
return
SVGObserverUtils
:
:
eHasRefsSomeInvalid
;
}
if
(
aFilterFrames
)
{
aFilterFrames
-
>
AppendElement
(
filter
)
;
}
}
return
SVGObserverUtils
:
:
eHasRefsAllValid
;
}
SVGObserverUtils
:
:
ReferenceState
SVGObserverUtils
:
:
GetAndObserveFilters
(
nsIFrame
*
aFilteredFrame
nsTArray
<
nsSVGFilterFrame
*
>
*
aFilterFrames
)
{
SVGFilterObserverListForCSSProp
*
observerList
=
GetOrCreateFilterObserverListForCSS
(
aFilteredFrame
)
;
return
:
:
GetAndObserveFilters
(
observerList
aFilterFrames
)
;
}
SVGObserverUtils
:
:
ReferenceState
SVGObserverUtils
:
:
GetFiltersIfObserving
(
nsIFrame
*
aFilteredFrame
nsTArray
<
nsSVGFilterFrame
*
>
*
aFilterFrames
)
{
SVGFilterObserverListForCSSProp
*
observerList
=
aFilteredFrame
-
>
GetProperty
(
FilterProperty
(
)
)
;
return
:
:
GetAndObserveFilters
(
observerList
aFilterFrames
)
;
}
already_AddRefed
<
nsISupports
>
SVGObserverUtils
:
:
ObserveFiltersForCanvasContext
(
CanvasRenderingContext2D
*
aContext
Element
*
aCanvasElement
nsTArray
<
nsStyleFilter
>
&
aFilters
)
{
return
do_AddRef
(
new
SVGFilterObserverListForCanvasContext
(
aContext
aCanvasElement
aFilters
)
)
;
}
void
SVGObserverUtils
:
:
DetachFromCanvasContext
(
nsISupports
*
aAutoObserver
)
{
static_cast
<
SVGFilterObserverListForCanvasContext
*
>
(
aAutoObserver
)
-
>
DetachFromContext
(
)
;
}
static
nsSVGPaintingProperty
*
GetOrCreateClipPathObserver
(
nsIFrame
*
aClippedFrame
)
{
MOZ_ASSERT
(
!
aClippedFrame
-
>
GetPrevContinuation
(
)
"
Require
first
continuation
"
)
;
const
nsStyleSVGReset
*
svgStyleReset
=
aClippedFrame
-
>
StyleSVGReset
(
)
;
if
(
svgStyleReset
-
>
mClipPath
.
GetType
(
)
!
=
StyleShapeSourceType
:
:
URL
)
{
return
nullptr
;
}
css
:
:
URLValue
*
url
=
svgStyleReset
-
>
mClipPath
.
GetURL
(
)
;
RefPtr
<
URLAndReferrerInfo
>
pathURI
=
ResolveURLUsingLocalRef
(
aClippedFrame
url
)
;
return
GetPaintingProperty
(
pathURI
aClippedFrame
ClipPathProperty
(
)
)
;
}
SVGObserverUtils
:
:
ReferenceState
SVGObserverUtils
:
:
GetAndObserveClipPath
(
nsIFrame
*
aClippedFrame
nsSVGClipPathFrame
*
*
aClipPathFrame
)
{
if
(
aClipPathFrame
)
{
*
aClipPathFrame
=
nullptr
;
}
nsSVGPaintingProperty
*
observers
=
GetOrCreateClipPathObserver
(
aClippedFrame
)
;
if
(
!
observers
)
{
return
eHasNoRefs
;
}
bool
frameTypeOK
=
true
;
nsSVGClipPathFrame
*
frame
=
static_cast
<
nsSVGClipPathFrame
*
>
(
observers
-
>
GetAndObserveReferencedFrame
(
LayoutFrameType
:
:
SVGClipPath
&
frameTypeOK
)
)
;
if
(
!
frameTypeOK
|
|
(
frame
&
&
!
frame
-
>
IsValid
(
)
)
)
{
return
eHasRefsSomeInvalid
;
}
if
(
aClipPathFrame
)
{
*
aClipPathFrame
=
frame
;
}
return
frame
?
eHasRefsAllValid
:
eHasNoRefs
;
}
static
SVGMaskObserverList
*
GetOrCreateMaskObserverList
(
nsIFrame
*
aMaskedFrame
)
{
MOZ_ASSERT
(
!
aMaskedFrame
-
>
GetPrevContinuation
(
)
"
Require
first
continuation
"
)
;
const
nsStyleSVGReset
*
style
=
aMaskedFrame
-
>
StyleSVGReset
(
)
;
if
(
!
style
-
>
HasMask
(
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
style
-
>
mMask
.
mImageCount
>
0
)
;
SVGMaskObserverList
*
prop
=
aMaskedFrame
-
>
GetProperty
(
MaskProperty
(
)
)
;
if
(
prop
)
{
return
prop
;
}
prop
=
new
SVGMaskObserverList
(
aMaskedFrame
)
;
NS_ADDREF
(
prop
)
;
aMaskedFrame
-
>
SetProperty
(
MaskProperty
(
)
prop
)
;
return
prop
;
}
SVGObserverUtils
:
:
ReferenceState
SVGObserverUtils
:
:
GetAndObserveMasks
(
nsIFrame
*
aMaskedFrame
nsTArray
<
nsSVGMaskFrame
*
>
*
aMaskFrames
)
{
SVGMaskObserverList
*
observerList
=
GetOrCreateMaskObserverList
(
aMaskedFrame
)
;
if
(
!
observerList
)
{
return
eHasNoRefs
;
}
const
nsTArray
<
RefPtr
<
nsSVGPaintingProperty
>
>
&
observers
=
observerList
-
>
GetObservers
(
)
;
if
(
observers
.
IsEmpty
(
)
)
{
return
eHasNoRefs
;
}
ReferenceState
state
=
eHasRefsAllValid
;
for
(
size_t
i
=
0
;
i
<
observers
.
Length
(
)
;
i
+
+
)
{
bool
frameTypeOK
=
true
;
nsSVGMaskFrame
*
maskFrame
=
static_cast
<
nsSVGMaskFrame
*
>
(
observers
[
i
]
-
>
GetAndObserveReferencedFrame
(
LayoutFrameType
:
:
SVGMask
&
frameTypeOK
)
)
;
MOZ_ASSERT
(
!
maskFrame
|
|
frameTypeOK
)
;
if
(
!
frameTypeOK
)
{
observerList
-
>
ResolveImage
(
i
)
;
state
=
eHasRefsSomeInvalid
;
}
if
(
aMaskFrames
)
{
aMaskFrames
-
>
AppendElement
(
maskFrame
)
;
}
}
return
state
;
}
SVGGeometryElement
*
SVGObserverUtils
:
:
GetAndObserveTextPathsPath
(
nsIFrame
*
aTextPathFrame
)
{
SVGTextPathObserver
*
property
=
aTextPathFrame
-
>
GetProperty
(
HrefAsTextPathProperty
(
)
)
;
if
(
!
property
)
{
nsIContent
*
content
=
aTextPathFrame
-
>
GetContent
(
)
;
nsAutoString
href
;
static_cast
<
SVGTextPathElement
*
>
(
content
)
-
>
HrefAsString
(
href
)
;
if
(
href
.
IsEmpty
(
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIURI
>
targetURI
;
nsCOMPtr
<
nsIURI
>
base
=
content
-
>
GetBaseURI
(
)
;
nsContentUtils
:
:
NewURIWithDocumentCharset
(
getter_AddRefs
(
targetURI
)
href
content
-
>
GetUncomposedDoc
(
)
base
)
;
RefPtr
<
URLAndReferrerInfo
>
target
=
new
URLAndReferrerInfo
(
targetURI
content
-
>
OwnerDoc
(
)
-
>
GetDocumentURI
(
)
content
-
>
OwnerDoc
(
)
-
>
GetReferrerPolicy
(
)
)
;
property
=
GetEffectProperty
(
target
aTextPathFrame
HrefAsTextPathProperty
(
)
)
;
if
(
!
property
)
{
return
nullptr
;
}
}
Element
*
element
=
property
-
>
GetAndObserveReferencedElement
(
)
;
return
(
element
&
&
element
-
>
IsNodeOfType
(
nsINode
:
:
eSHAPE
)
)
?
static_cast
<
SVGGeometryElement
*
>
(
element
)
:
nullptr
;
}
void
SVGObserverUtils
:
:
InitiateResourceDocLoads
(
nsIFrame
*
aFrame
)
{
Unused
<
<
GetOrCreateFilterObserverListForCSS
(
aFrame
)
;
Unused
<
<
GetOrCreateClipPathObserver
(
aFrame
)
;
Unused
<
<
GetOrCreateMaskObserverList
(
aFrame
)
;
}
void
SVGObserverUtils
:
:
RemoveTextPathObserver
(
nsIFrame
*
aTextPathFrame
)
{
aTextPathFrame
-
>
DeleteProperty
(
HrefAsTextPathProperty
(
)
)
;
}
nsIFrame
*
SVGObserverUtils
:
:
GetAndObserveTemplate
(
nsIFrame
*
aFrame
HrefToTemplateCallback
aGetHref
)
{
SVGTemplateElementObserver
*
observer
=
aFrame
-
>
GetProperty
(
HrefToTemplateProperty
(
)
)
;
if
(
!
observer
)
{
nsAutoString
href
;
aGetHref
(
href
)
;
if
(
href
.
IsEmpty
(
)
)
{
return
nullptr
;
}
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
nsCOMPtr
<
nsIURI
>
targetURI
;
nsCOMPtr
<
nsIURI
>
base
=
content
-
>
GetBaseURI
(
)
;
nsContentUtils
:
:
NewURIWithDocumentCharset
(
getter_AddRefs
(
targetURI
)
href
content
-
>
GetUncomposedDoc
(
)
base
)
;
RefPtr
<
URLAndReferrerInfo
>
target
=
new
URLAndReferrerInfo
(
targetURI
content
-
>
OwnerDoc
(
)
-
>
GetDocumentURI
(
)
content
-
>
OwnerDoc
(
)
-
>
GetReferrerPolicy
(
)
)
;
observer
=
GetEffectProperty
(
target
aFrame
HrefToTemplateProperty
(
)
)
;
}
return
observer
?
observer
-
>
GetAndObserveReferencedFrame
(
)
:
nullptr
;
}
void
SVGObserverUtils
:
:
RemoveTemplateObserver
(
nsIFrame
*
aFrame
)
{
aFrame
-
>
DeleteProperty
(
HrefToTemplateProperty
(
)
)
;
}
Element
*
SVGObserverUtils
:
:
GetAndObserveBackgroundImage
(
nsIFrame
*
aFrame
const
nsAtom
*
aHref
)
{
URIObserverHashtable
*
hashtable
=
aFrame
-
>
GetProperty
(
BackgroundImageProperty
(
)
)
;
if
(
!
hashtable
)
{
hashtable
=
new
URIObserverHashtable
(
)
;
aFrame
-
>
SetProperty
(
BackgroundImageProperty
(
)
hashtable
)
;
}
nsAutoString
elementId
=
NS_LITERAL_STRING
(
"
#
"
)
+
nsDependentAtomString
(
aHref
)
;
nsCOMPtr
<
nsIURI
>
targetURI
;
nsCOMPtr
<
nsIURI
>
base
=
aFrame
-
>
GetContent
(
)
-
>
GetBaseURI
(
)
;
nsContentUtils
:
:
NewURIWithDocumentCharset
(
getter_AddRefs
(
targetURI
)
elementId
aFrame
-
>
GetContent
(
)
-
>
GetUncomposedDoc
(
)
base
)
;
RefPtr
<
URLAndReferrerInfo
>
url
=
new
URLAndReferrerInfo
(
targetURI
aFrame
-
>
GetContent
(
)
-
>
OwnerDoc
(
)
-
>
GetDocumentURI
(
)
aFrame
-
>
GetContent
(
)
-
>
OwnerDoc
(
)
-
>
GetReferrerPolicy
(
)
)
;
nsSVGPaintingProperty
*
observer
=
static_cast
<
nsSVGPaintingProperty
*
>
(
hashtable
-
>
GetWeak
(
url
)
)
;
if
(
!
observer
)
{
observer
=
new
nsSVGPaintingProperty
(
url
aFrame
true
)
;
hashtable
-
>
Put
(
url
observer
)
;
}
return
observer
-
>
GetAndObserveReferencedElement
(
)
;
}
nsSVGPaintServerFrame
*
SVGObserverUtils
:
:
GetAndObservePaintServer
(
nsIFrame
*
aTargetFrame
nsStyleSVGPaint
nsStyleSVG
:
:
*
aPaint
)
{
nsIFrame
*
frame
=
aTargetFrame
;
if
(
frame
-
>
GetContent
(
)
-
>
IsText
(
)
)
{
frame
=
frame
-
>
GetParent
(
)
;
nsIFrame
*
grandparent
=
frame
-
>
GetParent
(
)
;
if
(
grandparent
&
&
grandparent
-
>
IsSVGTextFrame
(
)
)
{
frame
=
grandparent
;
}
}
const
nsStyleSVG
*
svgStyle
=
frame
-
>
StyleSVG
(
)
;
if
(
(
svgStyle
-
>
*
aPaint
)
.
Type
(
)
!
=
eStyleSVGPaintType_Server
)
return
nullptr
;
RefPtr
<
URLAndReferrerInfo
>
paintServerURL
=
ResolveURLUsingLocalRef
(
frame
(
svgStyle
-
>
*
aPaint
)
.
GetPaintServer
(
)
)
;
MOZ_ASSERT
(
aPaint
=
=
&
nsStyleSVG
:
:
mFill
|
|
aPaint
=
=
&
nsStyleSVG
:
:
mStroke
)
;
PaintingPropertyDescriptor
propDesc
=
(
aPaint
=
=
&
nsStyleSVG
:
:
mFill
)
?
FillProperty
(
)
:
StrokeProperty
(
)
;
nsSVGPaintingProperty
*
property
=
GetPaintingProperty
(
paintServerURL
frame
propDesc
)
;
if
(
!
property
)
return
nullptr
;
nsIFrame
*
result
=
property
-
>
GetAndObserveReferencedFrame
(
)
;
if
(
!
result
)
return
nullptr
;
LayoutFrameType
type
=
result
-
>
Type
(
)
;
if
(
type
!
=
LayoutFrameType
:
:
SVGLinearGradient
&
&
type
!
=
LayoutFrameType
:
:
SVGRadialGradient
&
&
type
!
=
LayoutFrameType
:
:
SVGPattern
)
return
nullptr
;
return
static_cast
<
nsSVGPaintServerFrame
*
>
(
result
)
;
}
void
SVGObserverUtils
:
:
UpdateEffects
(
nsIFrame
*
aFrame
)
{
NS_ASSERTION
(
aFrame
-
>
GetContent
(
)
-
>
IsElement
(
)
"
aFrame
'
s
content
should
be
an
element
"
)
;
aFrame
-
>
DeleteProperty
(
FilterProperty
(
)
)
;
aFrame
-
>
DeleteProperty
(
MaskProperty
(
)
)
;
aFrame
-
>
DeleteProperty
(
ClipPathProperty
(
)
)
;
aFrame
-
>
DeleteProperty
(
MarkerStartProperty
(
)
)
;
aFrame
-
>
DeleteProperty
(
MarkerMidProperty
(
)
)
;
aFrame
-
>
DeleteProperty
(
MarkerEndProperty
(
)
)
;
aFrame
-
>
DeleteProperty
(
FillProperty
(
)
)
;
aFrame
-
>
DeleteProperty
(
StrokeProperty
(
)
)
;
aFrame
-
>
DeleteProperty
(
BackgroundImageProperty
(
)
)
;
GetOrCreateFilterObserverListForCSS
(
aFrame
)
;
if
(
aFrame
-
>
IsSVGGeometryFrame
(
)
&
&
static_cast
<
SVGGeometryElement
*
>
(
aFrame
-
>
GetContent
(
)
)
-
>
IsMarkable
(
)
)
{
RefPtr
<
URLAndReferrerInfo
>
markerURL
=
GetMarkerURI
(
aFrame
&
nsStyleSVG
:
:
mMarkerStart
)
;
GetEffectProperty
(
markerURL
aFrame
MarkerStartProperty
(
)
)
;
markerURL
=
GetMarkerURI
(
aFrame
&
nsStyleSVG
:
:
mMarkerMid
)
;
GetEffectProperty
(
markerURL
aFrame
MarkerMidProperty
(
)
)
;
markerURL
=
GetMarkerURI
(
aFrame
&
nsStyleSVG
:
:
mMarkerEnd
)
;
GetEffectProperty
(
markerURL
aFrame
MarkerEndProperty
(
)
)
;
}
}
void
SVGObserverUtils
:
:
AddRenderingObserver
(
Element
*
aElement
SVGRenderingObserver
*
aObserver
)
{
SVGRenderingObserverSet
*
observers
=
GetObserverSet
(
aElement
)
;
if
(
!
observers
)
{
observers
=
new
SVGRenderingObserverSet
(
)
;
if
(
!
observers
)
{
return
;
}
aElement
-
>
SetProperty
(
nsGkAtoms
:
:
renderingobserverset
observers
nsINode
:
:
DeleteProperty
<
SVGRenderingObserverSet
>
)
;
}
aElement
-
>
SetHasRenderingObservers
(
true
)
;
observers
-
>
Add
(
aObserver
)
;
}
void
SVGObserverUtils
:
:
RemoveRenderingObserver
(
Element
*
aElement
SVGRenderingObserver
*
aObserver
)
{
SVGRenderingObserverSet
*
observers
=
GetObserverSet
(
aElement
)
;
if
(
observers
)
{
NS_ASSERTION
(
observers
-
>
Contains
(
aObserver
)
"
removing
observer
from
an
element
we
'
re
not
observing
?
"
)
;
observers
-
>
Remove
(
aObserver
)
;
if
(
observers
-
>
IsEmpty
(
)
)
{
aElement
-
>
SetHasRenderingObservers
(
false
)
;
}
}
}
void
SVGObserverUtils
:
:
RemoveAllRenderingObservers
(
Element
*
aElement
)
{
SVGRenderingObserverSet
*
observers
=
GetObserverSet
(
aElement
)
;
if
(
observers
)
{
observers
-
>
RemoveAll
(
)
;
aElement
-
>
SetHasRenderingObservers
(
false
)
;
}
}
void
SVGObserverUtils
:
:
InvalidateRenderingObservers
(
nsIFrame
*
aFrame
)
{
NS_ASSERTION
(
!
aFrame
-
>
GetPrevContinuation
(
)
"
aFrame
must
be
first
continuation
"
)
;
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
!
content
|
|
!
content
-
>
IsElement
(
)
)
return
;
aFrame
-
>
DeleteProperty
(
nsSVGUtils
:
:
ObjectBoundingBoxProperty
(
)
)
;
SVGRenderingObserverSet
*
observers
=
GetObserverSet
(
content
-
>
AsElement
(
)
)
;
if
(
observers
)
{
observers
-
>
InvalidateAll
(
)
;
return
;
}
for
(
nsIFrame
*
f
=
aFrame
-
>
GetParent
(
)
;
f
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVGContainer
)
;
f
=
f
-
>
GetParent
(
)
)
{
if
(
f
-
>
GetContent
(
)
-
>
IsElement
(
)
)
{
observers
=
GetObserverSet
(
f
-
>
GetContent
(
)
-
>
AsElement
(
)
)
;
if
(
observers
)
{
observers
-
>
InvalidateAll
(
)
;
return
;
}
}
}
}
void
SVGObserverUtils
:
:
InvalidateDirectRenderingObservers
(
Element
*
aElement
uint32_t
aFlags
)
{
nsIFrame
*
frame
=
aElement
-
>
GetPrimaryFrame
(
)
;
if
(
frame
)
{
frame
-
>
DeleteProperty
(
nsSVGUtils
:
:
ObjectBoundingBoxProperty
(
)
)
;
}
if
(
aElement
-
>
HasRenderingObservers
(
)
)
{
SVGRenderingObserverSet
*
observers
=
GetObserverSet
(
aElement
)
;
if
(
observers
)
{
if
(
aFlags
&
INVALIDATE_REFLOW
)
{
observers
-
>
InvalidateAllForReflow
(
)
;
}
else
{
observers
-
>
InvalidateAll
(
)
;
}
}
}
}
void
SVGObserverUtils
:
:
InvalidateDirectRenderingObservers
(
nsIFrame
*
aFrame
uint32_t
aFlags
)
{
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
content
&
&
content
-
>
IsElement
(
)
)
{
InvalidateDirectRenderingObservers
(
content
-
>
AsElement
(
)
aFlags
)
;
}
}
already_AddRefed
<
nsIURI
>
SVGObserverUtils
:
:
GetBaseURLForLocalRef
(
nsIContent
*
content
nsIURI
*
aDocURI
)
{
MOZ_ASSERT
(
content
)
;
nsCOMPtr
<
nsIURI
>
baseURI
=
content
-
>
OwnerDoc
(
)
-
>
GetDocumentURI
(
)
;
nsCOMPtr
<
nsIURI
>
originalURI
;
if
(
SVGUseElement
*
use
=
content
-
>
GetContainingSVGUseShadowHost
(
)
)
{
originalURI
=
use
-
>
GetSourceDocURI
(
)
;
}
else
if
(
content
-
>
IsInAnonymousSubtree
(
)
)
{
nsIContent
*
bindingParent
=
content
-
>
GetBindingParent
(
)
;
if
(
bindingParent
)
{
nsXBLBinding
*
binding
=
bindingParent
-
>
GetXBLBinding
(
)
;
if
(
binding
)
{
originalURI
=
binding
-
>
GetSourceDocURI
(
)
;
}
else
{
MOZ_ASSERT
(
content
-
>
IsInNativeAnonymousSubtree
(
)
"
a
non
-
native
anonymous
tree
which
is
not
from
"
"
an
XBL
binding
?
"
)
;
}
}
}
if
(
originalURI
)
{
bool
isEqualsExceptRef
=
false
;
aDocURI
-
>
EqualsExceptRef
(
originalURI
&
isEqualsExceptRef
)
;
if
(
isEqualsExceptRef
)
{
return
originalURI
.
forget
(
)
;
}
}
return
baseURI
.
forget
(
)
;
}
already_AddRefed
<
URLAndReferrerInfo
>
SVGObserverUtils
:
:
GetFilterURI
(
nsIFrame
*
aFrame
const
nsStyleFilter
&
aFilter
)
{
MOZ_ASSERT
(
aFrame
-
>
StyleEffects
(
)
-
>
mFilters
.
Length
(
)
)
;
MOZ_ASSERT
(
aFilter
.
GetType
(
)
=
=
NS_STYLE_FILTER_URL
)
;
return
ResolveURLUsingLocalRef
(
aFrame
aFilter
.
GetURL
(
)
)
;
}
}
