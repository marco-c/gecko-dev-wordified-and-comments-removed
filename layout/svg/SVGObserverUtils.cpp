#
include
"
SVGObserverUtils
.
h
"
#
include
"
mozilla
/
css
/
ImageLoader
.
h
"
#
include
"
mozilla
/
dom
/
CanvasRenderingContext2D
.
h
"
#
include
"
mozilla
/
dom
/
SVGGeometryElement
.
h
"
#
include
"
mozilla
/
dom
/
SVGTextPathElement
.
h
"
#
include
"
mozilla
/
dom
/
SVGUseElement
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
mozilla
/
SVGClipPathFrame
.
h
"
#
include
"
mozilla
/
SVGMaskFrame
.
h
"
#
include
"
mozilla
/
SVGTextFrame
.
h
"
#
include
"
mozilla
/
SVGUtils
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsHashKeys
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsInterfaceHashtable
.
h
"
#
include
"
nsIReflowCallback
.
h
"
#
include
"
nsISupportsImpl
.
h
"
#
include
"
nsTHashtable
.
h
"
#
include
"
nsURIHashKey
.
h
"
#
include
"
SVGFilterFrame
.
h
"
#
include
"
SVGMarkerFrame
.
h
"
#
include
"
SVGPaintServerFrame
.
h
"
using
namespace
mozilla
:
:
dom
;
namespace
mozilla
{
bool
URLAndReferrerInfo
:
:
operator
=
=
(
const
URLAndReferrerInfo
&
aRHS
)
const
{
bool
uriEqual
=
false
referrerEqual
=
false
;
this
-
>
mURI
-
>
Equals
(
aRHS
.
mURI
&
uriEqual
)
;
this
-
>
mReferrerInfo
-
>
Equals
(
aRHS
.
mReferrerInfo
&
referrerEqual
)
;
return
uriEqual
&
&
referrerEqual
;
}
class
URLAndReferrerInfoHashKey
:
public
PLDHashEntryHdr
{
public
:
using
KeyType
=
const
URLAndReferrerInfo
*
;
using
KeyTypePointer
=
const
URLAndReferrerInfo
*
;
explicit
URLAndReferrerInfoHashKey
(
const
URLAndReferrerInfo
*
aKey
)
noexcept
:
mKey
(
aKey
)
{
MOZ_COUNT_CTOR
(
URLAndReferrerInfoHashKey
)
;
}
URLAndReferrerInfoHashKey
(
URLAndReferrerInfoHashKey
&
&
aToMove
)
noexcept
:
PLDHashEntryHdr
(
std
:
:
move
(
aToMove
)
)
mKey
(
std
:
:
move
(
aToMove
.
mKey
)
)
{
MOZ_COUNT_CTOR
(
URLAndReferrerInfoHashKey
)
;
}
MOZ_COUNTED_DTOR
(
URLAndReferrerInfoHashKey
)
const
URLAndReferrerInfo
*
GetKey
(
)
const
{
return
mKey
;
}
bool
KeyEquals
(
const
URLAndReferrerInfo
*
aKey
)
const
{
if
(
!
mKey
)
{
return
!
aKey
;
}
return
*
mKey
=
=
*
aKey
;
}
static
const
URLAndReferrerInfo
*
KeyToPointer
(
const
URLAndReferrerInfo
*
aKey
)
{
return
aKey
;
}
static
PLDHashNumber
HashKey
(
const
URLAndReferrerInfo
*
aKey
)
{
if
(
!
aKey
)
{
return
HashString
(
"
"
_ns
)
;
}
nsAutoCString
urlSpec
referrerSpec
;
Unused
<
<
aKey
-
>
GetURI
(
)
-
>
GetSpec
(
urlSpec
)
;
return
AddToHash
(
HashString
(
urlSpec
)
static_cast
<
ReferrerInfo
*
>
(
aKey
-
>
GetReferrerInfo
(
)
)
-
>
Hash
(
)
)
;
}
enum
{
ALLOW_MEMMOVE
=
true
}
;
protected
:
RefPtr
<
const
URLAndReferrerInfo
>
mKey
;
}
;
static
already_AddRefed
<
URLAndReferrerInfo
>
ResolveURLUsingLocalRef
(
nsIFrame
*
aFrame
const
StyleComputedImageUrl
&
aURL
)
{
MOZ_ASSERT
(
aFrame
)
;
nsCOMPtr
<
nsIURI
>
uri
=
aURL
.
GetURI
(
)
;
if
(
aURL
.
IsLocalRef
(
)
)
{
uri
=
SVGObserverUtils
:
:
GetBaseURLForLocalRef
(
aFrame
-
>
GetContent
(
)
uri
)
;
uri
=
aURL
.
ResolveLocalRef
(
uri
)
;
}
if
(
!
uri
)
{
return
nullptr
;
}
RefPtr
<
URLAndReferrerInfo
>
info
=
new
URLAndReferrerInfo
(
uri
aURL
.
ExtraData
(
)
)
;
return
info
.
forget
(
)
;
}
static
already_AddRefed
<
URLAndReferrerInfo
>
ResolveURLUsingLocalRef
(
nsIFrame
*
aFrame
const
nsAString
&
aURL
nsIReferrerInfo
*
aReferrerInfo
)
{
MOZ_ASSERT
(
aFrame
)
;
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
nsIURI
*
base
=
nullptr
;
const
Encoding
*
encoding
=
nullptr
;
if
(
SVGUseElement
*
use
=
content
-
>
GetContainingSVGUseShadowHost
(
)
)
{
base
=
use
-
>
GetSourceDocURI
(
)
;
encoding
=
use
-
>
GetSourceDocCharacterSet
(
)
;
}
if
(
!
base
)
{
base
=
content
-
>
OwnerDoc
(
)
-
>
GetDocumentURI
(
)
;
encoding
=
content
-
>
OwnerDoc
(
)
-
>
GetDocumentCharacterSet
(
)
;
}
nsCOMPtr
<
nsIURI
>
uri
;
Unused
<
<
NS_NewURI
(
getter_AddRefs
(
uri
)
aURL
WrapNotNull
(
encoding
)
base
)
;
if
(
!
uri
)
{
return
nullptr
;
}
RefPtr
<
URLAndReferrerInfo
>
info
=
new
URLAndReferrerInfo
(
uri
aReferrerInfo
)
;
return
info
.
forget
(
)
;
}
class
SVGFilterObserverList
;
struct
SVGFrameReferenceFromProperty
{
explicit
SVGFrameReferenceFromProperty
(
nsIFrame
*
aFrame
)
:
mFrame
(
aFrame
)
mFramePresShell
(
aFrame
-
>
PresShell
(
)
)
{
}
void
Detach
(
)
{
mFrame
=
nullptr
;
mFramePresShell
=
nullptr
;
}
nsIFrame
*
Get
(
)
{
if
(
mFramePresShell
&
&
mFramePresShell
-
>
IsDestroying
(
)
)
{
Detach
(
)
;
}
return
mFrame
;
}
private
:
nsIFrame
*
mFrame
;
PresShell
*
mFramePresShell
;
}
;
void
SVGRenderingObserver
:
:
StartObserving
(
)
{
Element
*
target
=
GetReferencedElementWithoutObserving
(
)
;
if
(
target
)
{
target
-
>
AddMutationObserver
(
this
)
;
}
}
void
SVGRenderingObserver
:
:
StopObserving
(
)
{
Element
*
target
=
GetReferencedElementWithoutObserving
(
)
;
if
(
target
)
{
target
-
>
RemoveMutationObserver
(
this
)
;
if
(
mInObserverSet
)
{
SVGObserverUtils
:
:
RemoveRenderingObserver
(
target
this
)
;
mInObserverSet
=
false
;
}
}
NS_ASSERTION
(
!
mInObserverSet
"
still
in
an
observer
set
?
"
)
;
}
Element
*
SVGRenderingObserver
:
:
GetAndObserveReferencedElement
(
)
{
#
ifdef
DEBUG
DebugObserverSet
(
)
;
#
endif
Element
*
referencedElement
=
GetReferencedElementWithoutObserving
(
)
;
if
(
referencedElement
&
&
!
mInObserverSet
)
{
SVGObserverUtils
:
:
AddRenderingObserver
(
referencedElement
this
)
;
mInObserverSet
=
true
;
}
return
referencedElement
;
}
nsIFrame
*
SVGRenderingObserver
:
:
GetAndObserveReferencedFrame
(
)
{
Element
*
referencedElement
=
GetAndObserveReferencedElement
(
)
;
return
referencedElement
?
referencedElement
-
>
GetPrimaryFrame
(
)
:
nullptr
;
}
nsIFrame
*
SVGRenderingObserver
:
:
GetAndObserveReferencedFrame
(
LayoutFrameType
aFrameType
bool
*
aOK
)
{
nsIFrame
*
frame
=
GetAndObserveReferencedFrame
(
)
;
if
(
frame
)
{
if
(
frame
-
>
Type
(
)
=
=
aFrameType
)
{
return
frame
;
}
if
(
aOK
)
{
*
aOK
=
false
;
}
}
return
nullptr
;
}
void
SVGRenderingObserver
:
:
OnNonDOMMutationRenderingChange
(
)
{
mInObserverSet
=
false
;
OnRenderingChange
(
)
;
}
void
SVGRenderingObserver
:
:
NotifyEvictedFromRenderingObserverSet
(
)
{
mInObserverSet
=
false
;
StopObserving
(
)
;
}
void
SVGRenderingObserver
:
:
AttributeChanged
(
dom
:
:
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
const
nsAttrValue
*
aOldValue
)
{
OnRenderingChange
(
)
;
}
void
SVGRenderingObserver
:
:
ContentAppended
(
nsIContent
*
aFirstNewContent
)
{
OnRenderingChange
(
)
;
}
void
SVGRenderingObserver
:
:
ContentInserted
(
nsIContent
*
aChild
)
{
OnRenderingChange
(
)
;
}
void
SVGRenderingObserver
:
:
ContentRemoved
(
nsIContent
*
aChild
nsIContent
*
aPreviousSibling
)
{
OnRenderingChange
(
)
;
}
class
SVGIDRenderingObserver
:
public
SVGRenderingObserver
{
public
:
SVGIDRenderingObserver
(
URLAndReferrerInfo
*
aURI
nsIContent
*
aObservingContent
bool
aReferenceImage
)
;
protected
:
virtual
~
SVGIDRenderingObserver
(
)
{
StopObserving
(
)
;
}
void
TargetChanged
(
)
{
mTargetIsValid
=
(
[
this
]
{
Element
*
observed
=
mObservedElementTracker
.
get
(
)
;
if
(
!
observed
)
{
return
false
;
}
if
(
observed
-
>
OwnerDoc
(
)
=
=
mObservingContent
-
>
OwnerDoc
(
)
&
&
nsContentUtils
:
:
ContentIsHostIncludingDescendantOf
(
mObservingContent
observed
)
)
{
return
false
;
}
return
true
;
}
(
)
)
;
}
Element
*
GetReferencedElementWithoutObserving
(
)
final
{
return
mTargetIsValid
?
mObservedElementTracker
.
get
(
)
:
nullptr
;
}
void
OnRenderingChange
(
)
override
;
class
ElementTracker
final
:
public
IDTracker
{
public
:
explicit
ElementTracker
(
SVGIDRenderingObserver
*
aOwningObserver
)
:
mOwningObserver
(
aOwningObserver
)
{
}
protected
:
void
ElementChanged
(
Element
*
aFrom
Element
*
aTo
)
override
{
mOwningObserver
-
>
OnRenderingChange
(
)
;
mOwningObserver
-
>
StopObserving
(
)
;
IDTracker
:
:
ElementChanged
(
aFrom
aTo
)
;
mOwningObserver
-
>
TargetChanged
(
)
;
mOwningObserver
-
>
StartObserving
(
)
;
mOwningObserver
-
>
OnRenderingChange
(
)
;
}
bool
IsPersistent
(
)
override
{
return
true
;
}
private
:
SVGIDRenderingObserver
*
mOwningObserver
;
}
;
ElementTracker
mObservedElementTracker
;
RefPtr
<
Element
>
mObservingContent
;
bool
mTargetIsValid
=
false
;
}
;
SVGIDRenderingObserver
:
:
SVGIDRenderingObserver
(
URLAndReferrerInfo
*
aURI
nsIContent
*
aObservingContent
bool
aReferenceImage
)
:
mObservedElementTracker
(
this
)
mObservingContent
(
aObservingContent
-
>
AsElement
(
)
)
{
nsIURI
*
uri
=
nullptr
;
nsIReferrerInfo
*
referrerInfo
=
nullptr
;
if
(
aURI
)
{
uri
=
aURI
-
>
GetURI
(
)
;
referrerInfo
=
aURI
-
>
GetReferrerInfo
(
)
;
}
mObservedElementTracker
.
ResetToURIFragmentID
(
aObservingContent
uri
referrerInfo
true
aReferenceImage
)
;
TargetChanged
(
)
;
StartObserving
(
)
;
}
void
SVGIDRenderingObserver
:
:
OnRenderingChange
(
)
{
if
(
mObservedElementTracker
.
get
(
)
&
&
mInObserverSet
)
{
SVGObserverUtils
:
:
RemoveRenderingObserver
(
mObservedElementTracker
.
get
(
)
this
)
;
mInObserverSet
=
false
;
}
}
class
SVGRenderingObserverProperty
:
public
SVGIDRenderingObserver
{
public
:
NS_DECL_ISUPPORTS
SVGRenderingObserverProperty
(
URLAndReferrerInfo
*
aURI
nsIFrame
*
aFrame
bool
aReferenceImage
)
:
SVGIDRenderingObserver
(
aURI
aFrame
-
>
GetContent
(
)
aReferenceImage
)
mFrameReference
(
aFrame
)
{
}
protected
:
virtual
~
SVGRenderingObserverProperty
(
)
=
default
;
void
OnRenderingChange
(
)
override
;
SVGFrameReferenceFromProperty
mFrameReference
;
}
;
NS_IMPL_ISUPPORTS
(
SVGRenderingObserverProperty
nsIMutationObserver
)
void
SVGRenderingObserverProperty
:
:
OnRenderingChange
(
)
{
SVGIDRenderingObserver
:
:
OnRenderingChange
(
)
;
if
(
!
mTargetIsValid
)
{
return
;
}
nsIFrame
*
frame
=
mFrameReference
.
Get
(
)
;
if
(
frame
&
&
frame
-
>
HasAllStateBits
(
NS_FRAME_SVG_LAYOUT
)
)
{
nsLayoutUtils
:
:
PostRestyleEvent
(
frame
-
>
GetContent
(
)
-
>
AsElement
(
)
RestyleHint
{
0
}
nsChangeHint_InvalidateRenderingObservers
)
;
}
}
class
SVGTextPathObserver
final
:
public
SVGRenderingObserverProperty
{
public
:
SVGTextPathObserver
(
URLAndReferrerInfo
*
aURI
nsIFrame
*
aFrame
bool
aReferenceImage
)
:
SVGRenderingObserverProperty
(
aURI
aFrame
aReferenceImage
)
{
}
protected
:
void
OnRenderingChange
(
)
override
;
}
;
void
SVGTextPathObserver
:
:
OnRenderingChange
(
)
{
SVGRenderingObserverProperty
:
:
OnRenderingChange
(
)
;
if
(
!
mTargetIsValid
)
{
return
;
}
nsIFrame
*
frame
=
mFrameReference
.
Get
(
)
;
if
(
!
frame
)
{
return
;
}
MOZ_ASSERT
(
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
|
|
SVGUtils
:
:
IsInSVGTextSubtree
(
frame
)
"
SVG
frame
expected
"
)
;
MOZ_ASSERT
(
frame
-
>
GetContent
(
)
-
>
IsSVGElement
(
nsGkAtoms
:
:
textPath
)
"
expected
frame
for
a
<
textPath
>
element
"
)
;
frame
-
>
PresContext
(
)
-
>
RestyleManager
(
)
-
>
PostRestyleEvent
(
frame
-
>
GetContent
(
)
-
>
AsElement
(
)
RestyleHint
{
0
}
nsChangeHint_RepaintFrame
)
;
nsIFrame
*
text
=
nsLayoutUtils
:
:
GetClosestFrameOfType
(
frame
LayoutFrameType
:
:
SVGText
)
;
MOZ_ASSERT
(
text
"
expected
to
find
an
ancestor
SVGTextFrame
"
)
;
if
(
text
)
{
static_cast
<
SVGTextFrame
*
>
(
text
)
-
>
NotifyGlyphMetricsChange
(
)
;
}
}
class
SVGMarkerObserver
final
:
public
SVGRenderingObserverProperty
{
public
:
SVGMarkerObserver
(
URLAndReferrerInfo
*
aURI
nsIFrame
*
aFrame
bool
aReferenceImage
)
:
SVGRenderingObserverProperty
(
aURI
aFrame
aReferenceImage
)
{
}
protected
:
void
OnRenderingChange
(
)
override
;
}
;
void
SVGMarkerObserver
:
:
OnRenderingChange
(
)
{
SVGRenderingObserverProperty
:
:
OnRenderingChange
(
)
;
nsIFrame
*
frame
=
mFrameReference
.
Get
(
)
;
if
(
!
frame
)
{
return
;
}
MOZ_ASSERT
(
frame
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVG
)
"
SVG
frame
expected
"
)
;
if
(
!
frame
-
>
HasAnyStateBits
(
NS_FRAME_IN_REFLOW
)
)
{
SVGUtils
:
:
ScheduleReflowSVG
(
frame
)
;
}
frame
-
>
PresContext
(
)
-
>
RestyleManager
(
)
-
>
PostRestyleEvent
(
frame
-
>
GetContent
(
)
-
>
AsElement
(
)
RestyleHint
{
0
}
nsChangeHint_RepaintFrame
)
;
}
class
SVGPaintingProperty
:
public
SVGRenderingObserverProperty
{
public
:
SVGPaintingProperty
(
URLAndReferrerInfo
*
aURI
nsIFrame
*
aFrame
bool
aReferenceImage
)
:
SVGRenderingObserverProperty
(
aURI
aFrame
aReferenceImage
)
{
}
protected
:
void
OnRenderingChange
(
)
override
;
}
;
void
SVGPaintingProperty
:
:
OnRenderingChange
(
)
{
SVGRenderingObserverProperty
:
:
OnRenderingChange
(
)
;
nsIFrame
*
frame
=
mFrameReference
.
Get
(
)
;
if
(
!
frame
)
{
return
;
}
if
(
frame
-
>
HasAnyStateBits
(
NS_FRAME_SVG_LAYOUT
)
)
{
frame
-
>
InvalidateFrameSubtree
(
)
;
}
else
{
for
(
nsIFrame
*
f
=
frame
;
f
;
f
=
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
f
)
)
{
f
-
>
InvalidateFrame
(
)
;
}
}
}
class
SVGMozElementObserver
final
:
public
SVGPaintingProperty
{
public
:
SVGMozElementObserver
(
URLAndReferrerInfo
*
aURI
nsIFrame
*
aFrame
bool
aReferenceImage
)
:
SVGPaintingProperty
(
aURI
aFrame
aReferenceImage
)
{
}
bool
ObservesReflow
(
)
override
{
return
true
;
}
}
;
class
BackgroundClipRenderingObserver
:
public
SVGRenderingObserver
{
public
:
explicit
BackgroundClipRenderingObserver
(
nsIFrame
*
aFrame
)
:
mFrame
(
aFrame
)
{
}
NS_DECL_ISUPPORTS
private
:
virtual
~
BackgroundClipRenderingObserver
(
)
=
default
;
Element
*
GetReferencedElementWithoutObserving
(
)
final
{
return
mFrame
-
>
GetContent
(
)
-
>
AsElement
(
)
;
}
void
OnRenderingChange
(
)
final
;
bool
ObservesReflow
(
)
final
{
return
true
;
}
nsIFrame
*
mFrame
;
}
;
NS_IMPL_ISUPPORTS
(
BackgroundClipRenderingObserver
nsIMutationObserver
)
void
BackgroundClipRenderingObserver
:
:
OnRenderingChange
(
)
{
for
(
nsIFrame
*
f
=
mFrame
;
f
;
f
=
nsLayoutUtils
:
:
GetNextContinuationOrIBSplitSibling
(
f
)
)
{
f
-
>
InvalidateFrame
(
)
;
}
}
class
SVGFilterObserver
final
:
public
SVGIDRenderingObserver
{
public
:
SVGFilterObserver
(
URLAndReferrerInfo
*
aURI
nsIContent
*
aObservingContent
SVGFilterObserverList
*
aFilterChainObserver
)
:
SVGIDRenderingObserver
(
aURI
aObservingContent
false
)
mFilterObserverList
(
aFilterChainObserver
)
{
}
void
DetachFromChainObserver
(
)
{
mFilterObserverList
=
nullptr
;
}
SVGFilterFrame
*
GetAndObserveFilterFrame
(
)
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
SVGFilterObserver
)
void
OnRenderingChange
(
)
override
;
protected
:
virtual
~
SVGFilterObserver
(
)
=
default
;
SVGFilterObserverList
*
mFilterObserverList
;
}
;
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
SVGFilterObserver
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
SVGFilterObserver
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
SVGFilterObserver
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_ENTRY
(
nsIMutationObserver
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION_CLASS
(
SVGFilterObserver
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
SVGFilterObserver
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mObservedElementTracker
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mObservingContent
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
SVGFilterObserver
)
tmp
-
>
StopObserving
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mObservedElementTracker
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mObservingContent
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
SVGFilterFrame
*
SVGFilterObserver
:
:
GetAndObserveFilterFrame
(
)
{
return
static_cast
<
SVGFilterFrame
*
>
(
GetAndObserveReferencedFrame
(
LayoutFrameType
:
:
SVGFilter
nullptr
)
)
;
}
class
SVGFilterObserverList
:
public
nsISupports
{
public
:
SVGFilterObserverList
(
Span
<
const
StyleFilter
>
aFilters
nsIContent
*
aFilteredElement
nsIFrame
*
aFilteredFrame
=
nullptr
)
;
const
nsTArray
<
RefPtr
<
SVGFilterObserver
>
>
&
GetObservers
(
)
const
{
return
mObservers
;
}
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
SVGFilterObserverList
)
virtual
void
OnRenderingChange
(
)
=
0
;
protected
:
virtual
~
SVGFilterObserverList
(
)
;
void
DetachObservers
(
)
{
for
(
auto
&
observer
:
mObservers
)
{
observer
-
>
DetachFromChainObserver
(
)
;
}
}
nsTArray
<
RefPtr
<
SVGFilterObserver
>
>
mObservers
;
}
;
void
SVGFilterObserver
:
:
OnRenderingChange
(
)
{
SVGIDRenderingObserver
:
:
OnRenderingChange
(
)
;
if
(
mFilterObserverList
)
{
mFilterObserverList
-
>
OnRenderingChange
(
)
;
}
if
(
!
mTargetIsValid
)
{
return
;
}
nsIFrame
*
frame
=
mObservingContent
-
>
GetPrimaryFrame
(
)
;
if
(
!
frame
)
{
return
;
}
nsChangeHint
changeHint
=
nsChangeHint
(
nsChangeHint_RepaintFrame
)
;
if
(
frame
-
>
HasAnyStateBits
(
NS_FRAME_SVG_LAYOUT
)
)
{
changeHint
|
=
nsChangeHint_InvalidateRenderingObservers
;
}
if
(
!
frame
-
>
HasAnyStateBits
(
NS_FRAME_IN_REFLOW
)
)
{
changeHint
|
=
nsChangeHint_UpdateOverflow
;
}
frame
-
>
PresContext
(
)
-
>
RestyleManager
(
)
-
>
PostRestyleEvent
(
mObservingContent
RestyleHint
{
0
}
changeHint
)
;
}
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
SVGFilterObserverList
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
SVGFilterObserverList
)
NS_IMPL_CYCLE_COLLECTION_CLASS
(
SVGFilterObserverList
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN
(
SVGFilterObserverList
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE
(
mObservers
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN
(
SVGFilterObserverList
)
tmp
-
>
DetachObservers
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK
(
mObservers
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
SVGFilterObserverList
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
SVGFilterObserverList
:
:
SVGFilterObserverList
(
Span
<
const
StyleFilter
>
aFilters
nsIContent
*
aFilteredElement
nsIFrame
*
aFilteredFrame
)
{
for
(
const
auto
&
filter
:
aFilters
)
{
if
(
!
filter
.
IsUrl
(
)
)
{
continue
;
}
const
auto
&
url
=
filter
.
AsUrl
(
)
;
RefPtr
<
URLAndReferrerInfo
>
filterURL
;
if
(
aFilteredFrame
)
{
filterURL
=
ResolveURLUsingLocalRef
(
aFilteredFrame
url
)
;
}
else
{
nsCOMPtr
<
nsIURI
>
resolvedURI
=
url
.
ResolveLocalRef
(
aFilteredElement
)
;
if
(
resolvedURI
)
{
filterURL
=
new
URLAndReferrerInfo
(
resolvedURI
url
.
ExtraData
(
)
)
;
}
}
RefPtr
<
SVGFilterObserver
>
observer
=
new
SVGFilterObserver
(
filterURL
aFilteredElement
this
)
;
mObservers
.
AppendElement
(
observer
)
;
}
}
SVGFilterObserverList
:
:
~
SVGFilterObserverList
(
)
{
DetachObservers
(
)
;
}
class
SVGFilterObserverListForCSSProp
final
:
public
SVGFilterObserverList
{
public
:
SVGFilterObserverListForCSSProp
(
Span
<
const
StyleFilter
>
aFilters
nsIFrame
*
aFilteredFrame
)
:
SVGFilterObserverList
(
aFilters
aFilteredFrame
-
>
GetContent
(
)
aFilteredFrame
)
{
}
protected
:
void
OnRenderingChange
(
)
override
;
bool
mInvalidating
=
false
;
}
;
void
SVGFilterObserverListForCSSProp
:
:
OnRenderingChange
(
)
{
if
(
mInvalidating
)
{
return
;
}
AutoRestore
<
bool
>
guard
(
mInvalidating
)
;
mInvalidating
=
true
;
for
(
auto
&
observer
:
mObservers
)
{
observer
-
>
OnRenderingChange
(
)
;
}
}
class
SVGFilterObserverListForCanvasContext
final
:
public
SVGFilterObserverList
{
public
:
SVGFilterObserverListForCanvasContext
(
CanvasRenderingContext2D
*
aContext
Element
*
aCanvasElement
Span
<
const
StyleFilter
>
aFilters
)
:
SVGFilterObserverList
(
aFilters
aCanvasElement
)
mContext
(
aContext
)
{
}
void
OnRenderingChange
(
)
override
;
void
DetachFromContext
(
)
{
mContext
=
nullptr
;
}
private
:
CanvasRenderingContext2D
*
mContext
;
}
;
void
SVGFilterObserverListForCanvasContext
:
:
OnRenderingChange
(
)
{
if
(
!
mContext
)
{
MOZ_CRASH
(
"
GFX
:
This
should
never
be
called
without
a
context
"
)
;
}
RefPtr
<
CanvasRenderingContext2D
>
kungFuDeathGrip
(
mContext
)
;
kungFuDeathGrip
-
>
UpdateFilter
(
)
;
}
class
SVGMaskObserverList
final
:
public
nsISupports
{
public
:
explicit
SVGMaskObserverList
(
nsIFrame
*
aFrame
)
;
NS_DECL_ISUPPORTS
const
nsTArray
<
RefPtr
<
SVGPaintingProperty
>
>
&
GetObservers
(
)
const
{
return
mProperties
;
}
void
ResolveImage
(
uint32_t
aIndex
)
;
private
:
virtual
~
SVGMaskObserverList
(
)
=
default
;
nsTArray
<
RefPtr
<
SVGPaintingProperty
>
>
mProperties
;
nsIFrame
*
mFrame
;
}
;
NS_IMPL_ISUPPORTS
(
SVGMaskObserverList
nsISupports
)
SVGMaskObserverList
:
:
SVGMaskObserverList
(
nsIFrame
*
aFrame
)
:
mFrame
(
aFrame
)
{
const
nsStyleSVGReset
*
svgReset
=
aFrame
-
>
StyleSVGReset
(
)
;
for
(
uint32_t
i
=
0
;
i
<
svgReset
-
>
mMask
.
mImageCount
;
i
+
+
)
{
const
StyleComputedImageUrl
*
data
=
svgReset
-
>
mMask
.
mLayers
[
i
]
.
mImage
.
GetImageRequestURLValue
(
)
;
RefPtr
<
URLAndReferrerInfo
>
maskUri
;
if
(
data
)
{
maskUri
=
ResolveURLUsingLocalRef
(
aFrame
*
data
)
;
}
bool
hasRef
=
false
;
if
(
maskUri
)
{
maskUri
-
>
GetURI
(
)
-
>
GetHasRef
(
&
hasRef
)
;
}
SVGPaintingProperty
*
prop
=
new
SVGPaintingProperty
(
hasRef
?
maskUri
.
get
(
)
:
nullptr
aFrame
false
)
;
mProperties
.
AppendElement
(
prop
)
;
}
}
void
SVGMaskObserverList
:
:
ResolveImage
(
uint32_t
aIndex
)
{
const
nsStyleSVGReset
*
svgReset
=
mFrame
-
>
StyleSVGReset
(
)
;
MOZ_ASSERT
(
aIndex
<
svgReset
-
>
mMask
.
mImageCount
)
;
auto
&
image
=
const_cast
<
StyleImage
&
>
(
svgReset
-
>
mMask
.
mLayers
[
aIndex
]
.
mImage
)
;
if
(
image
.
IsResolved
(
)
)
{
return
;
}
MOZ_ASSERT
(
image
.
IsImageRequestType
(
)
)
;
Document
*
doc
=
mFrame
-
>
PresContext
(
)
-
>
Document
(
)
;
image
.
ResolveImage
(
*
doc
nullptr
)
;
if
(
imgRequestProxy
*
req
=
image
.
GetImageRequest
(
)
)
{
doc
-
>
StyleImageLoader
(
)
-
>
AssociateRequestToFrame
(
req
mFrame
0
)
;
}
}
class
SVGTemplateElementObserver
:
public
SVGIDRenderingObserver
{
public
:
NS_DECL_ISUPPORTS
SVGTemplateElementObserver
(
URLAndReferrerInfo
*
aURI
nsIFrame
*
aFrame
bool
aReferenceImage
)
:
SVGIDRenderingObserver
(
aURI
aFrame
-
>
GetContent
(
)
aReferenceImage
)
mFrameReference
(
aFrame
)
{
}
protected
:
virtual
~
SVGTemplateElementObserver
(
)
=
default
;
void
OnRenderingChange
(
)
override
;
SVGFrameReferenceFromProperty
mFrameReference
;
}
;
NS_IMPL_ISUPPORTS
(
SVGTemplateElementObserver
nsIMutationObserver
)
void
SVGTemplateElementObserver
:
:
OnRenderingChange
(
)
{
SVGIDRenderingObserver
:
:
OnRenderingChange
(
)
;
if
(
nsIFrame
*
frame
=
mFrameReference
.
Get
(
)
)
{
SVGObserverUtils
:
:
InvalidateDirectRenderingObservers
(
frame
)
;
}
}
class
SVGRenderingObserverSet
{
public
:
SVGRenderingObserverSet
(
)
:
mObservers
(
4
)
{
MOZ_COUNT_CTOR
(
SVGRenderingObserverSet
)
;
}
~
SVGRenderingObserverSet
(
)
{
InvalidateAll
(
)
;
MOZ_COUNT_DTOR
(
SVGRenderingObserverSet
)
;
}
void
Add
(
SVGRenderingObserver
*
aObserver
)
{
mObservers
.
PutEntry
(
aObserver
)
;
}
void
Remove
(
SVGRenderingObserver
*
aObserver
)
{
mObservers
.
RemoveEntry
(
aObserver
)
;
}
#
ifdef
DEBUG
bool
Contains
(
SVGRenderingObserver
*
aObserver
)
{
return
(
mObservers
.
GetEntry
(
aObserver
)
!
=
nullptr
)
;
}
#
endif
bool
IsEmpty
(
)
{
return
mObservers
.
IsEmpty
(
)
;
}
void
InvalidateAll
(
)
;
void
InvalidateAllForReflow
(
)
;
void
RemoveAll
(
)
;
private
:
nsTHashtable
<
nsPtrHashKey
<
SVGRenderingObserver
>
>
mObservers
;
}
;
void
SVGRenderingObserverSet
:
:
InvalidateAll
(
)
{
if
(
mObservers
.
IsEmpty
(
)
)
{
return
;
}
AutoTArray
<
SVGRenderingObserver
*
10
>
observers
;
for
(
auto
it
=
mObservers
.
Iter
(
)
;
!
it
.
Done
(
)
;
it
.
Next
(
)
)
{
observers
.
AppendElement
(
it
.
Get
(
)
-
>
GetKey
(
)
)
;
}
mObservers
.
Clear
(
)
;
for
(
uint32_t
i
=
0
;
i
<
observers
.
Length
(
)
;
+
+
i
)
{
observers
[
i
]
-
>
OnNonDOMMutationRenderingChange
(
)
;
}
}
void
SVGRenderingObserverSet
:
:
InvalidateAllForReflow
(
)
{
if
(
mObservers
.
IsEmpty
(
)
)
{
return
;
}
AutoTArray
<
SVGRenderingObserver
*
10
>
observers
;
for
(
auto
it
=
mObservers
.
Iter
(
)
;
!
it
.
Done
(
)
;
it
.
Next
(
)
)
{
SVGRenderingObserver
*
obs
=
it
.
Get
(
)
-
>
GetKey
(
)
;
if
(
obs
-
>
ObservesReflow
(
)
)
{
observers
.
AppendElement
(
obs
)
;
it
.
Remove
(
)
;
}
}
for
(
uint32_t
i
=
0
;
i
<
observers
.
Length
(
)
;
+
+
i
)
{
observers
[
i
]
-
>
OnNonDOMMutationRenderingChange
(
)
;
}
}
void
SVGRenderingObserverSet
:
:
RemoveAll
(
)
{
AutoTArray
<
SVGRenderingObserver
*
10
>
observers
;
for
(
auto
it
=
mObservers
.
Iter
(
)
;
!
it
.
Done
(
)
;
it
.
Next
(
)
)
{
observers
.
AppendElement
(
it
.
Get
(
)
-
>
GetKey
(
)
)
;
}
mObservers
.
Clear
(
)
;
for
(
uint32_t
i
=
0
;
i
<
observers
.
Length
(
)
;
+
+
i
)
{
observers
[
i
]
-
>
NotifyEvictedFromRenderingObserverSet
(
)
;
}
}
static
SVGRenderingObserverSet
*
GetObserverSet
(
Element
*
aElement
)
{
return
static_cast
<
SVGRenderingObserverSet
*
>
(
aElement
-
>
GetProperty
(
nsGkAtoms
:
:
renderingobserverset
)
)
;
}
#
ifdef
DEBUG
void
SVGRenderingObserver
:
:
DebugObserverSet
(
)
{
Element
*
referencedElement
=
GetReferencedElementWithoutObserving
(
)
;
if
(
referencedElement
)
{
SVGRenderingObserverSet
*
observers
=
GetObserverSet
(
referencedElement
)
;
bool
inObserverSet
=
observers
&
&
observers
-
>
Contains
(
this
)
;
MOZ_ASSERT
(
inObserverSet
=
=
mInObserverSet
"
failed
to
track
whether
we
'
re
in
our
referenced
element
'
s
"
"
observer
set
!
"
)
;
}
else
{
MOZ_ASSERT
(
!
mInObserverSet
"
In
whose
observer
set
are
we
then
?
"
)
;
}
}
#
endif
using
URIObserverHashtable
=
nsInterfaceHashtable
<
URLAndReferrerInfoHashKey
nsIMutationObserver
>
;
using
PaintingPropertyDescriptor
=
const
FramePropertyDescriptor
<
SVGPaintingProperty
>
*
;
static
void
DestroyFilterProperty
(
SVGFilterObserverListForCSSProp
*
aProp
)
{
aProp
-
>
Release
(
)
;
}
NS_DECLARE_FRAME_PROPERTY_RELEASABLE
(
HrefToTemplateProperty
SVGTemplateElementObserver
)
NS_DECLARE_FRAME_PROPERTY_WITH_DTOR
(
FilterProperty
SVGFilterObserverListForCSSProp
DestroyFilterProperty
)
NS_DECLARE_FRAME_PROPERTY_RELEASABLE
(
MaskProperty
SVGMaskObserverList
)
NS_DECLARE_FRAME_PROPERTY_RELEASABLE
(
ClipPathProperty
SVGPaintingProperty
)
NS_DECLARE_FRAME_PROPERTY_RELEASABLE
(
MarkerStartProperty
SVGMarkerObserver
)
NS_DECLARE_FRAME_PROPERTY_RELEASABLE
(
MarkerMidProperty
SVGMarkerObserver
)
NS_DECLARE_FRAME_PROPERTY_RELEASABLE
(
MarkerEndProperty
SVGMarkerObserver
)
NS_DECLARE_FRAME_PROPERTY_RELEASABLE
(
FillProperty
SVGPaintingProperty
)
NS_DECLARE_FRAME_PROPERTY_RELEASABLE
(
StrokeProperty
SVGPaintingProperty
)
NS_DECLARE_FRAME_PROPERTY_RELEASABLE
(
HrefAsTextPathProperty
SVGTextPathObserver
)
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
BackgroundImageProperty
URIObserverHashtable
)
NS_DECLARE_FRAME_PROPERTY_RELEASABLE
(
BackgroundClipObserverProperty
BackgroundClipRenderingObserver
)
template
<
class
T
>
static
T
*
GetEffectProperty
(
URLAndReferrerInfo
*
aURI
nsIFrame
*
aFrame
const
FramePropertyDescriptor
<
T
>
*
aProperty
)
{
if
(
!
aURI
)
{
return
nullptr
;
}
bool
found
;
T
*
prop
=
aFrame
-
>
GetProperty
(
aProperty
&
found
)
;
if
(
found
)
{
MOZ_ASSERT
(
prop
"
this
property
should
only
store
non
-
null
values
"
)
;
return
prop
;
}
prop
=
new
T
(
aURI
aFrame
false
)
;
NS_ADDREF
(
prop
)
;
aFrame
-
>
AddProperty
(
aProperty
prop
)
;
return
prop
;
}
static
SVGPaintingProperty
*
GetPaintingProperty
(
URLAndReferrerInfo
*
aURI
nsIFrame
*
aFrame
const
FramePropertyDescriptor
<
SVGPaintingProperty
>
*
aProperty
)
{
return
GetEffectProperty
(
aURI
aFrame
aProperty
)
;
}
static
already_AddRefed
<
URLAndReferrerInfo
>
GetMarkerURI
(
nsIFrame
*
aFrame
const
StyleUrlOrNone
nsStyleSVG
:
:
*
aMarker
)
{
const
StyleUrlOrNone
&
url
=
aFrame
-
>
StyleSVG
(
)
-
>
*
aMarker
;
if
(
url
.
IsNone
(
)
)
{
return
nullptr
;
}
return
ResolveURLUsingLocalRef
(
aFrame
url
.
AsUrl
(
)
)
;
}
bool
SVGObserverUtils
:
:
GetAndObserveMarkers
(
nsIFrame
*
aMarkedFrame
SVGMarkerFrame
*
(
*
aFrames
)
[
3
]
)
{
MOZ_ASSERT
(
!
aMarkedFrame
-
>
GetPrevContinuation
(
)
&
&
aMarkedFrame
-
>
IsSVGGeometryFrame
(
)
&
&
static_cast
<
SVGGeometryElement
*
>
(
aMarkedFrame
-
>
GetContent
(
)
)
-
>
IsMarkable
(
)
"
Bad
frame
"
)
;
bool
foundMarker
=
false
;
RefPtr
<
URLAndReferrerInfo
>
markerURL
;
SVGMarkerObserver
*
observer
;
nsIFrame
*
marker
;
#
define
GET_MARKER
(
type
)
\
markerURL
=
GetMarkerURI
(
aMarkedFrame
&
nsStyleSVG
:
:
mMarker
#
#
type
)
;
\
observer
=
\
GetEffectProperty
(
markerURL
aMarkedFrame
Marker
#
#
type
#
#
Property
(
)
)
;
\
marker
=
observer
?
observer
-
>
GetAndObserveReferencedFrame
(
\
LayoutFrameType
:
:
SVGMarker
nullptr
)
\
:
nullptr
;
\
foundMarker
=
foundMarker
|
|
bool
(
marker
)
;
\
(
*
aFrames
)
[
SVGMark
:
:
e
#
#
type
]
=
static_cast
<
SVGMarkerFrame
*
>
(
marker
)
;
GET_MARKER
(
Start
)
GET_MARKER
(
Mid
)
GET_MARKER
(
End
)
#
undef
GET_MARKER
return
foundMarker
;
}
static
SVGFilterObserverListForCSSProp
*
GetOrCreateFilterObserverListForCSS
(
nsIFrame
*
aFrame
)
{
MOZ_ASSERT
(
!
aFrame
-
>
GetPrevContinuation
(
)
"
Require
first
continuation
"
)
;
const
nsStyleEffects
*
effects
=
aFrame
-
>
StyleEffects
(
)
;
if
(
!
effects
-
>
HasFilters
(
)
)
{
return
nullptr
;
}
bool
found
;
SVGFilterObserverListForCSSProp
*
observers
=
aFrame
-
>
GetProperty
(
FilterProperty
(
)
&
found
)
;
if
(
found
)
{
MOZ_ASSERT
(
observers
"
this
property
should
only
store
non
-
null
values
"
)
;
return
observers
;
}
observers
=
new
SVGFilterObserverListForCSSProp
(
effects
-
>
mFilters
.
AsSpan
(
)
aFrame
)
;
NS_ADDREF
(
observers
)
;
aFrame
-
>
AddProperty
(
FilterProperty
(
)
observers
)
;
return
observers
;
}
static
SVGObserverUtils
:
:
ReferenceState
GetAndObserveFilters
(
SVGFilterObserverListForCSSProp
*
aObserverList
nsTArray
<
SVGFilterFrame
*
>
*
aFilterFrames
)
{
if
(
!
aObserverList
)
{
return
SVGObserverUtils
:
:
eHasNoRefs
;
}
const
nsTArray
<
RefPtr
<
SVGFilterObserver
>
>
&
observers
=
aObserverList
-
>
GetObservers
(
)
;
if
(
observers
.
IsEmpty
(
)
)
{
return
SVGObserverUtils
:
:
eHasNoRefs
;
}
for
(
uint32_t
i
=
0
;
i
<
observers
.
Length
(
)
;
i
+
+
)
{
SVGFilterFrame
*
filter
=
observers
[
i
]
-
>
GetAndObserveFilterFrame
(
)
;
if
(
!
filter
)
{
if
(
aFilterFrames
)
{
aFilterFrames
-
>
Clear
(
)
;
}
return
SVGObserverUtils
:
:
eHasRefsSomeInvalid
;
}
if
(
aFilterFrames
)
{
aFilterFrames
-
>
AppendElement
(
filter
)
;
}
}
return
SVGObserverUtils
:
:
eHasRefsAllValid
;
}
SVGObserverUtils
:
:
ReferenceState
SVGObserverUtils
:
:
GetAndObserveFilters
(
nsIFrame
*
aFilteredFrame
nsTArray
<
SVGFilterFrame
*
>
*
aFilterFrames
)
{
SVGFilterObserverListForCSSProp
*
observerList
=
GetOrCreateFilterObserverListForCSS
(
aFilteredFrame
)
;
return
mozilla
:
:
GetAndObserveFilters
(
observerList
aFilterFrames
)
;
}
SVGObserverUtils
:
:
ReferenceState
SVGObserverUtils
:
:
GetFiltersIfObserving
(
nsIFrame
*
aFilteredFrame
nsTArray
<
SVGFilterFrame
*
>
*
aFilterFrames
)
{
SVGFilterObserverListForCSSProp
*
observerList
=
aFilteredFrame
-
>
GetProperty
(
FilterProperty
(
)
)
;
return
mozilla
:
:
GetAndObserveFilters
(
observerList
aFilterFrames
)
;
}
already_AddRefed
<
nsISupports
>
SVGObserverUtils
:
:
ObserveFiltersForCanvasContext
(
CanvasRenderingContext2D
*
aContext
Element
*
aCanvasElement
const
Span
<
const
StyleFilter
>
aFilters
)
{
return
do_AddRef
(
new
SVGFilterObserverListForCanvasContext
(
aContext
aCanvasElement
aFilters
)
)
;
}
void
SVGObserverUtils
:
:
DetachFromCanvasContext
(
nsISupports
*
aAutoObserver
)
{
static_cast
<
SVGFilterObserverListForCanvasContext
*
>
(
aAutoObserver
)
-
>
DetachFromContext
(
)
;
}
static
SVGPaintingProperty
*
GetOrCreateClipPathObserver
(
nsIFrame
*
aClippedFrame
)
{
MOZ_ASSERT
(
!
aClippedFrame
-
>
GetPrevContinuation
(
)
"
Require
first
continuation
"
)
;
const
nsStyleSVGReset
*
svgStyleReset
=
aClippedFrame
-
>
StyleSVGReset
(
)
;
if
(
!
svgStyleReset
-
>
mClipPath
.
IsUrl
(
)
)
{
return
nullptr
;
}
const
auto
&
url
=
svgStyleReset
-
>
mClipPath
.
AsUrl
(
)
;
RefPtr
<
URLAndReferrerInfo
>
pathURI
=
ResolveURLUsingLocalRef
(
aClippedFrame
url
)
;
return
GetPaintingProperty
(
pathURI
aClippedFrame
ClipPathProperty
(
)
)
;
}
SVGObserverUtils
:
:
ReferenceState
SVGObserverUtils
:
:
GetAndObserveClipPath
(
nsIFrame
*
aClippedFrame
SVGClipPathFrame
*
*
aClipPathFrame
)
{
if
(
aClipPathFrame
)
{
*
aClipPathFrame
=
nullptr
;
}
SVGPaintingProperty
*
observers
=
GetOrCreateClipPathObserver
(
aClippedFrame
)
;
if
(
!
observers
)
{
return
eHasNoRefs
;
}
bool
frameTypeOK
=
true
;
SVGClipPathFrame
*
frame
=
static_cast
<
SVGClipPathFrame
*
>
(
observers
-
>
GetAndObserveReferencedFrame
(
LayoutFrameType
:
:
SVGClipPath
&
frameTypeOK
)
)
;
if
(
!
frameTypeOK
|
|
(
frame
&
&
!
frame
-
>
IsValid
(
)
)
)
{
return
eHasRefsSomeInvalid
;
}
if
(
aClipPathFrame
)
{
*
aClipPathFrame
=
frame
;
}
return
frame
?
eHasRefsAllValid
:
eHasNoRefs
;
}
static
SVGMaskObserverList
*
GetOrCreateMaskObserverList
(
nsIFrame
*
aMaskedFrame
)
{
MOZ_ASSERT
(
!
aMaskedFrame
-
>
GetPrevContinuation
(
)
"
Require
first
continuation
"
)
;
const
nsStyleSVGReset
*
style
=
aMaskedFrame
-
>
StyleSVGReset
(
)
;
if
(
!
style
-
>
HasMask
(
)
)
{
return
nullptr
;
}
MOZ_ASSERT
(
style
-
>
mMask
.
mImageCount
>
0
)
;
bool
found
;
SVGMaskObserverList
*
prop
=
aMaskedFrame
-
>
GetProperty
(
MaskProperty
(
)
&
found
)
;
if
(
found
)
{
MOZ_ASSERT
(
prop
"
this
property
should
only
store
non
-
null
values
"
)
;
return
prop
;
}
prop
=
new
SVGMaskObserverList
(
aMaskedFrame
)
;
NS_ADDREF
(
prop
)
;
aMaskedFrame
-
>
AddProperty
(
MaskProperty
(
)
prop
)
;
return
prop
;
}
SVGObserverUtils
:
:
ReferenceState
SVGObserverUtils
:
:
GetAndObserveMasks
(
nsIFrame
*
aMaskedFrame
nsTArray
<
SVGMaskFrame
*
>
*
aMaskFrames
)
{
SVGMaskObserverList
*
observerList
=
GetOrCreateMaskObserverList
(
aMaskedFrame
)
;
if
(
!
observerList
)
{
return
eHasNoRefs
;
}
const
nsTArray
<
RefPtr
<
SVGPaintingProperty
>
>
&
observers
=
observerList
-
>
GetObservers
(
)
;
if
(
observers
.
IsEmpty
(
)
)
{
return
eHasNoRefs
;
}
ReferenceState
state
=
eHasRefsAllValid
;
for
(
size_t
i
=
0
;
i
<
observers
.
Length
(
)
;
i
+
+
)
{
bool
frameTypeOK
=
true
;
SVGMaskFrame
*
maskFrame
=
static_cast
<
SVGMaskFrame
*
>
(
observers
[
i
]
-
>
GetAndObserveReferencedFrame
(
LayoutFrameType
:
:
SVGMask
&
frameTypeOK
)
)
;
MOZ_ASSERT
(
!
maskFrame
|
|
frameTypeOK
)
;
if
(
!
frameTypeOK
)
{
observerList
-
>
ResolveImage
(
i
)
;
state
=
eHasRefsSomeInvalid
;
}
if
(
aMaskFrames
)
{
aMaskFrames
-
>
AppendElement
(
maskFrame
)
;
}
}
return
state
;
}
SVGGeometryElement
*
SVGObserverUtils
:
:
GetAndObserveTextPathsPath
(
nsIFrame
*
aTextPathFrame
)
{
SVGTextPathObserver
*
property
=
aTextPathFrame
-
>
GetProperty
(
HrefAsTextPathProperty
(
)
)
;
if
(
!
property
)
{
nsIContent
*
content
=
aTextPathFrame
-
>
GetContent
(
)
;
nsAutoString
href
;
static_cast
<
SVGTextPathElement
*
>
(
content
)
-
>
HrefAsString
(
href
)
;
if
(
href
.
IsEmpty
(
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
=
ReferrerInfo
:
:
CreateForSVGResources
(
content
-
>
OwnerDoc
(
)
)
;
RefPtr
<
URLAndReferrerInfo
>
target
=
ResolveURLUsingLocalRef
(
aTextPathFrame
href
referrerInfo
)
;
property
=
GetEffectProperty
(
target
aTextPathFrame
HrefAsTextPathProperty
(
)
)
;
if
(
!
property
)
{
return
nullptr
;
}
}
Element
*
element
=
property
-
>
GetAndObserveReferencedElement
(
)
;
return
(
element
&
&
element
-
>
IsNodeOfType
(
nsINode
:
:
eSHAPE
)
)
?
static_cast
<
SVGGeometryElement
*
>
(
element
)
:
nullptr
;
}
void
SVGObserverUtils
:
:
InitiateResourceDocLoads
(
nsIFrame
*
aFrame
)
{
Unused
<
<
GetOrCreateFilterObserverListForCSS
(
aFrame
)
;
Unused
<
<
GetOrCreateClipPathObserver
(
aFrame
)
;
Unused
<
<
GetOrCreateMaskObserverList
(
aFrame
)
;
}
void
SVGObserverUtils
:
:
RemoveTextPathObserver
(
nsIFrame
*
aTextPathFrame
)
{
aTextPathFrame
-
>
RemoveProperty
(
HrefAsTextPathProperty
(
)
)
;
}
nsIFrame
*
SVGObserverUtils
:
:
GetAndObserveTemplate
(
nsIFrame
*
aFrame
HrefToTemplateCallback
aGetHref
)
{
SVGTemplateElementObserver
*
observer
=
aFrame
-
>
GetProperty
(
HrefToTemplateProperty
(
)
)
;
if
(
!
observer
)
{
nsAutoString
href
;
aGetHref
(
href
)
;
if
(
href
.
IsEmpty
(
)
)
{
return
nullptr
;
}
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
nsCOMPtr
<
nsIURI
>
targetURI
;
nsContentUtils
:
:
NewURIWithDocumentCharset
(
getter_AddRefs
(
targetURI
)
href
content
-
>
GetUncomposedDoc
(
)
content
-
>
GetBaseURI
(
)
)
;
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
=
ReferrerInfo
:
:
CreateForSVGResources
(
content
-
>
OwnerDoc
(
)
)
;
RefPtr
<
URLAndReferrerInfo
>
target
=
new
URLAndReferrerInfo
(
targetURI
referrerInfo
)
;
observer
=
GetEffectProperty
(
target
aFrame
HrefToTemplateProperty
(
)
)
;
}
return
observer
?
observer
-
>
GetAndObserveReferencedFrame
(
)
:
nullptr
;
}
void
SVGObserverUtils
:
:
RemoveTemplateObserver
(
nsIFrame
*
aFrame
)
{
aFrame
-
>
RemoveProperty
(
HrefToTemplateProperty
(
)
)
;
}
Element
*
SVGObserverUtils
:
:
GetAndObserveBackgroundImage
(
nsIFrame
*
aFrame
const
nsAtom
*
aHref
)
{
bool
found
;
URIObserverHashtable
*
hashtable
=
aFrame
-
>
GetProperty
(
BackgroundImageProperty
(
)
&
found
)
;
if
(
!
found
)
{
hashtable
=
new
URIObserverHashtable
(
)
;
aFrame
-
>
AddProperty
(
BackgroundImageProperty
(
)
hashtable
)
;
}
else
{
MOZ_ASSERT
(
hashtable
"
this
property
should
only
store
non
-
null
values
"
)
;
}
nsAutoString
elementId
=
u
"
#
"
_ns
+
nsDependentAtomString
(
aHref
)
;
nsCOMPtr
<
nsIURI
>
targetURI
;
nsContentUtils
:
:
NewURIWithDocumentCharset
(
getter_AddRefs
(
targetURI
)
elementId
aFrame
-
>
GetContent
(
)
-
>
GetUncomposedDoc
(
)
aFrame
-
>
GetContent
(
)
-
>
GetBaseURI
(
)
)
;
nsCOMPtr
<
nsIReferrerInfo
>
referrerInfo
=
ReferrerInfo
:
:
CreateForSVGResources
(
aFrame
-
>
GetContent
(
)
-
>
OwnerDoc
(
)
)
;
RefPtr
<
URLAndReferrerInfo
>
url
=
new
URLAndReferrerInfo
(
targetURI
referrerInfo
)
;
SVGMozElementObserver
*
observer
=
static_cast
<
SVGMozElementObserver
*
>
(
hashtable
-
>
GetWeak
(
url
)
)
;
if
(
!
observer
)
{
observer
=
new
SVGMozElementObserver
(
url
aFrame
true
)
;
hashtable
-
>
Put
(
url
observer
)
;
}
return
observer
-
>
GetAndObserveReferencedElement
(
)
;
}
Element
*
SVGObserverUtils
:
:
GetAndObserveBackgroundClip
(
nsIFrame
*
aFrame
)
{
bool
found
;
BackgroundClipRenderingObserver
*
obs
=
aFrame
-
>
GetProperty
(
BackgroundClipObserverProperty
(
)
&
found
)
;
if
(
!
found
)
{
obs
=
new
BackgroundClipRenderingObserver
(
aFrame
)
;
NS_ADDREF
(
obs
)
;
aFrame
-
>
AddProperty
(
BackgroundClipObserverProperty
(
)
obs
)
;
}
return
obs
-
>
GetAndObserveReferencedElement
(
)
;
}
SVGPaintServerFrame
*
SVGObserverUtils
:
:
GetAndObservePaintServer
(
nsIFrame
*
aPaintedFrame
StyleSVGPaint
nsStyleSVG
:
:
*
aPaint
)
{
nsIFrame
*
paintedFrame
=
aPaintedFrame
;
if
(
paintedFrame
-
>
GetContent
(
)
-
>
IsText
(
)
)
{
paintedFrame
=
paintedFrame
-
>
GetParent
(
)
;
nsIFrame
*
grandparent
=
paintedFrame
-
>
GetParent
(
)
;
if
(
grandparent
&
&
grandparent
-
>
IsSVGTextFrame
(
)
)
{
paintedFrame
=
grandparent
;
}
}
const
nsStyleSVG
*
svgStyle
=
paintedFrame
-
>
StyleSVG
(
)
;
if
(
!
(
svgStyle
-
>
*
aPaint
)
.
kind
.
IsPaintServer
(
)
)
{
return
nullptr
;
}
RefPtr
<
URLAndReferrerInfo
>
paintServerURL
=
ResolveURLUsingLocalRef
(
paintedFrame
(
svgStyle
-
>
*
aPaint
)
.
kind
.
AsPaintServer
(
)
)
;
MOZ_ASSERT
(
aPaint
=
=
&
nsStyleSVG
:
:
mFill
|
|
aPaint
=
=
&
nsStyleSVG
:
:
mStroke
)
;
PaintingPropertyDescriptor
propDesc
=
(
aPaint
=
=
&
nsStyleSVG
:
:
mFill
)
?
FillProperty
(
)
:
StrokeProperty
(
)
;
SVGPaintingProperty
*
property
=
GetPaintingProperty
(
paintServerURL
paintedFrame
propDesc
)
;
if
(
!
property
)
{
return
nullptr
;
}
nsIFrame
*
result
=
property
-
>
GetAndObserveReferencedFrame
(
)
;
if
(
!
result
)
{
return
nullptr
;
}
LayoutFrameType
type
=
result
-
>
Type
(
)
;
if
(
type
!
=
LayoutFrameType
:
:
SVGLinearGradient
&
&
type
!
=
LayoutFrameType
:
:
SVGRadialGradient
&
&
type
!
=
LayoutFrameType
:
:
SVGPattern
)
{
return
nullptr
;
}
return
static_cast
<
SVGPaintServerFrame
*
>
(
result
)
;
}
void
SVGObserverUtils
:
:
UpdateEffects
(
nsIFrame
*
aFrame
)
{
NS_ASSERTION
(
aFrame
-
>
GetContent
(
)
-
>
IsElement
(
)
"
aFrame
'
s
content
should
be
an
element
"
)
;
aFrame
-
>
RemoveProperty
(
FilterProperty
(
)
)
;
aFrame
-
>
RemoveProperty
(
MaskProperty
(
)
)
;
aFrame
-
>
RemoveProperty
(
ClipPathProperty
(
)
)
;
aFrame
-
>
RemoveProperty
(
MarkerStartProperty
(
)
)
;
aFrame
-
>
RemoveProperty
(
MarkerMidProperty
(
)
)
;
aFrame
-
>
RemoveProperty
(
MarkerEndProperty
(
)
)
;
aFrame
-
>
RemoveProperty
(
FillProperty
(
)
)
;
aFrame
-
>
RemoveProperty
(
StrokeProperty
(
)
)
;
aFrame
-
>
RemoveProperty
(
BackgroundImageProperty
(
)
)
;
GetOrCreateFilterObserverListForCSS
(
aFrame
)
;
if
(
aFrame
-
>
IsSVGGeometryFrame
(
)
&
&
static_cast
<
SVGGeometryElement
*
>
(
aFrame
-
>
GetContent
(
)
)
-
>
IsMarkable
(
)
)
{
RefPtr
<
URLAndReferrerInfo
>
markerURL
=
GetMarkerURI
(
aFrame
&
nsStyleSVG
:
:
mMarkerStart
)
;
GetEffectProperty
(
markerURL
aFrame
MarkerStartProperty
(
)
)
;
markerURL
=
GetMarkerURI
(
aFrame
&
nsStyleSVG
:
:
mMarkerMid
)
;
GetEffectProperty
(
markerURL
aFrame
MarkerMidProperty
(
)
)
;
markerURL
=
GetMarkerURI
(
aFrame
&
nsStyleSVG
:
:
mMarkerEnd
)
;
GetEffectProperty
(
markerURL
aFrame
MarkerEndProperty
(
)
)
;
}
}
void
SVGObserverUtils
:
:
AddRenderingObserver
(
Element
*
aElement
SVGRenderingObserver
*
aObserver
)
{
SVGRenderingObserverSet
*
observers
=
GetObserverSet
(
aElement
)
;
if
(
!
observers
)
{
observers
=
new
SVGRenderingObserverSet
(
)
;
if
(
!
observers
)
{
return
;
}
aElement
-
>
SetProperty
(
nsGkAtoms
:
:
renderingobserverset
observers
nsINode
:
:
DeleteProperty
<
SVGRenderingObserverSet
>
)
;
}
aElement
-
>
SetHasRenderingObservers
(
true
)
;
observers
-
>
Add
(
aObserver
)
;
}
void
SVGObserverUtils
:
:
RemoveRenderingObserver
(
Element
*
aElement
SVGRenderingObserver
*
aObserver
)
{
SVGRenderingObserverSet
*
observers
=
GetObserverSet
(
aElement
)
;
if
(
observers
)
{
NS_ASSERTION
(
observers
-
>
Contains
(
aObserver
)
"
removing
observer
from
an
element
we
'
re
not
observing
?
"
)
;
observers
-
>
Remove
(
aObserver
)
;
if
(
observers
-
>
IsEmpty
(
)
)
{
aElement
-
>
SetHasRenderingObservers
(
false
)
;
}
}
}
void
SVGObserverUtils
:
:
RemoveAllRenderingObservers
(
Element
*
aElement
)
{
SVGRenderingObserverSet
*
observers
=
GetObserverSet
(
aElement
)
;
if
(
observers
)
{
observers
-
>
RemoveAll
(
)
;
aElement
-
>
SetHasRenderingObservers
(
false
)
;
}
}
void
SVGObserverUtils
:
:
InvalidateRenderingObservers
(
nsIFrame
*
aFrame
)
{
NS_ASSERTION
(
!
aFrame
-
>
GetPrevContinuation
(
)
"
aFrame
must
be
first
continuation
"
)
;
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
!
content
|
|
!
content
-
>
IsElement
(
)
)
{
return
;
}
aFrame
-
>
RemoveProperty
(
SVGUtils
:
:
ObjectBoundingBoxProperty
(
)
)
;
SVGRenderingObserverSet
*
observers
=
GetObserverSet
(
content
-
>
AsElement
(
)
)
;
if
(
observers
)
{
observers
-
>
InvalidateAll
(
)
;
return
;
}
for
(
nsIFrame
*
f
=
aFrame
-
>
GetParent
(
)
;
f
-
>
IsFrameOfType
(
nsIFrame
:
:
eSVGContainer
)
;
f
=
f
-
>
GetParent
(
)
)
{
if
(
f
-
>
GetContent
(
)
-
>
IsElement
(
)
)
{
observers
=
GetObserverSet
(
f
-
>
GetContent
(
)
-
>
AsElement
(
)
)
;
if
(
observers
)
{
observers
-
>
InvalidateAll
(
)
;
return
;
}
}
}
}
void
SVGObserverUtils
:
:
InvalidateDirectRenderingObservers
(
Element
*
aElement
uint32_t
aFlags
)
{
if
(
nsIFrame
*
frame
=
aElement
-
>
GetPrimaryFrame
(
)
)
{
frame
-
>
RemoveProperty
(
SVGUtils
:
:
ObjectBoundingBoxProperty
(
)
)
;
}
if
(
aElement
-
>
HasRenderingObservers
(
)
)
{
SVGRenderingObserverSet
*
observers
=
GetObserverSet
(
aElement
)
;
if
(
observers
)
{
if
(
aFlags
&
INVALIDATE_REFLOW
)
{
observers
-
>
InvalidateAllForReflow
(
)
;
}
else
{
observers
-
>
InvalidateAll
(
)
;
}
}
}
}
void
SVGObserverUtils
:
:
InvalidateDirectRenderingObservers
(
nsIFrame
*
aFrame
uint32_t
aFlags
)
{
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
content
&
&
content
-
>
IsElement
(
)
)
{
InvalidateDirectRenderingObservers
(
content
-
>
AsElement
(
)
aFlags
)
;
}
}
already_AddRefed
<
nsIURI
>
SVGObserverUtils
:
:
GetBaseURLForLocalRef
(
nsIContent
*
content
nsIURI
*
aDocURI
)
{
MOZ_ASSERT
(
content
)
;
if
(
SVGUseElement
*
use
=
content
-
>
GetContainingSVGUseShadowHost
(
)
)
{
if
(
nsIURI
*
originalURI
=
use
-
>
GetSourceDocURI
(
)
)
{
bool
isEqualsExceptRef
=
false
;
aDocURI
-
>
EqualsExceptRef
(
originalURI
&
isEqualsExceptRef
)
;
if
(
isEqualsExceptRef
)
{
return
do_AddRef
(
originalURI
)
;
}
}
}
return
do_AddRef
(
content
-
>
OwnerDoc
(
)
-
>
GetDocumentURI
(
)
)
;
}
already_AddRefed
<
URLAndReferrerInfo
>
SVGObserverUtils
:
:
GetFilterURI
(
nsIFrame
*
aFrame
const
StyleFilter
&
aFilter
)
{
MOZ_ASSERT
(
!
aFrame
-
>
StyleEffects
(
)
-
>
mFilters
.
IsEmpty
(
)
|
|
!
aFrame
-
>
StyleEffects
(
)
-
>
mBackdropFilters
.
IsEmpty
(
)
)
;
MOZ_ASSERT
(
aFilter
.
IsUrl
(
)
)
;
return
ResolveURLUsingLocalRef
(
aFrame
aFilter
.
AsUrl
(
)
)
;
}
}
