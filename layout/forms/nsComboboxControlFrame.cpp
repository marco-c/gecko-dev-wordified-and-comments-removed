#
include
"
nsComboboxControlFrame
.
h
"
#
include
<
algorithm
>
#
include
"
HTMLSelectEventListener
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
mozilla
/
AsyncEventDispatcher
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
PresShellInlines
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
HTMLSelectElement
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsISelectControlFrame
.
h
"
#
include
"
nsITheme
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsTextFrameUtils
.
h
"
#
include
"
nsTextNode
.
h
"
#
include
"
nsTextRunTransformations
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
NS_IMETHODIMP
nsComboboxControlFrame
:
:
RedisplayTextEvent
:
:
Run
(
)
{
if
(
mControlFrame
)
{
mControlFrame
-
>
HandleRedisplayTextEvent
(
)
;
}
return
NS_OK
;
}
nsComboboxControlFrame
*
NS_NewComboboxControlFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsComboboxControlFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsComboboxControlFrame
)
nsComboboxControlFrame
:
:
nsComboboxControlFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
:
ButtonControlFrame
(
aStyle
aPresContext
kClassID
)
{
}
nsComboboxControlFrame
:
:
~
nsComboboxControlFrame
(
)
=
default
;
NS_QUERYFRAME_HEAD
(
nsComboboxControlFrame
)
NS_QUERYFRAME_ENTRY
(
nsComboboxControlFrame
)
NS_QUERYFRAME_ENTRY
(
nsISelectControlFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
ButtonControlFrame
)
#
ifdef
ACCESSIBILITY
a11y
:
:
AccType
nsComboboxControlFrame
:
:
AccessibleType
(
)
{
return
a11y
:
:
eHTMLComboboxType
;
}
#
endif
bool
nsComboboxControlFrame
:
:
HasDropDownButton
(
)
const
{
const
nsStyleDisplay
*
disp
=
StyleDisplay
(
)
;
switch
(
disp
-
>
EffectiveAppearance
(
)
)
{
case
StyleAppearance
:
:
MenulistButton
:
return
true
;
case
StyleAppearance
:
:
Menulist
:
return
!
IsThemed
(
disp
)
|
|
PresContext
(
)
-
>
Theme
(
)
-
>
ThemeNeedsComboboxDropmarker
(
)
;
default
:
return
false
;
}
}
nscoord
nsComboboxControlFrame
:
:
DropDownButtonISize
(
)
{
if
(
!
HasDropDownButton
(
)
)
{
return
0
;
}
nsPresContext
*
pc
=
PresContext
(
)
;
LayoutDeviceIntSize
dropdownButtonSize
=
pc
-
>
Theme
(
)
-
>
GetMinimumWidgetSize
(
pc
this
StyleAppearance
:
:
MozMenulistArrowButton
)
;
return
pc
-
>
DevPixelsToAppUnits
(
dropdownButtonSize
.
width
)
;
}
int32_t
nsComboboxControlFrame
:
:
CharCountOfLargestOptionForInflation
(
)
const
{
uint32_t
maxLength
=
0
;
nsAutoString
label
;
for
(
auto
i
:
IntegerRange
(
Select
(
)
.
Options
(
)
-
>
Length
(
)
)
)
{
GetOptionText
(
i
label
)
;
maxLength
=
std
:
:
max
(
maxLength
nsTextFrameUtils
:
:
ComputeApproximateLengthWithWhitespaceCompression
(
label
StyleText
(
)
)
)
;
}
if
(
MOZ_UNLIKELY
(
maxLength
>
uint32_t
(
INT32_MAX
)
)
)
{
return
INT32_MAX
;
}
return
int32_t
(
maxLength
)
;
}
nscoord
nsComboboxControlFrame
:
:
GetOptionISize
(
gfxContext
*
aRenderingContext
Type
aType
)
const
{
nscoord
maxOptionSize
=
0
;
nsAutoString
label
;
nsAutoString
transformedLabel
;
RefPtr
<
nsFontMetrics
>
fm
=
nsLayoutUtils
:
:
GetInflatedFontMetricsForFrame
(
this
)
;
const
nsStyleText
*
textStyle
=
StyleText
(
)
;
auto
textTransform
=
textStyle
-
>
mTextTransform
.
IsNone
(
)
?
Nothing
(
)
:
Some
(
textStyle
-
>
mTextTransform
)
;
nsAtom
*
language
=
StyleFont
(
)
-
>
mLanguage
;
AutoTArray
<
bool
50
>
charsToMergeArray
;
AutoTArray
<
bool
50
>
deletedCharsArray
;
auto
GetOptionSize
=
[
&
]
(
uint32_t
aIndex
)
-
>
nscoord
{
GetOptionText
(
aIndex
label
)
;
const
nsAutoString
*
stringToUse
=
&
label
;
if
(
textTransform
|
|
textStyle
-
>
mWebkitTextSecurity
!
=
StyleTextSecurity
:
:
None
)
{
transformedLabel
.
Truncate
(
)
;
charsToMergeArray
.
SetLengthAndRetainStorage
(
0
)
;
deletedCharsArray
.
SetLengthAndRetainStorage
(
0
)
;
nsCaseTransformTextRunFactory
:
:
TransformString
(
label
transformedLabel
textTransform
textStyle
-
>
TextSecurityMaskChar
(
)
false
language
charsToMergeArray
deletedCharsArray
)
;
stringToUse
=
&
transformedLabel
;
}
return
nsLayoutUtils
:
:
AppUnitWidthOfStringBidi
(
*
stringToUse
this
*
fm
*
aRenderingContext
)
;
}
;
if
(
aType
=
=
Type
:
:
Longest
)
{
for
(
auto
i
:
IntegerRange
(
Select
(
)
.
Options
(
)
-
>
Length
(
)
)
)
{
maxOptionSize
=
std
:
:
max
(
maxOptionSize
GetOptionSize
(
i
)
)
;
}
}
else
{
maxOptionSize
=
GetOptionSize
(
mDisplayedIndex
)
;
}
if
(
maxOptionSize
)
{
maxOptionSize
+
=
1
;
}
return
maxOptionSize
;
}
nscoord
nsComboboxControlFrame
:
:
IntrinsicISize
(
const
IntrinsicSizeInput
&
aInput
IntrinsicISizeType
aType
)
{
Maybe
<
nscoord
>
containISize
=
ContainIntrinsicISize
(
NS_UNCONSTRAINEDSIZE
)
;
if
(
containISize
&
&
*
containISize
!
=
NS_UNCONSTRAINEDSIZE
)
{
return
*
containISize
;
}
nscoord
displayISize
=
0
;
if
(
!
containISize
)
{
auto
optionType
=
StyleUIReset
(
)
-
>
mFieldSizing
=
=
StyleFieldSizing
:
:
Content
?
Type
:
:
Current
:
Type
:
:
Longest
;
displayISize
+
=
GetOptionISize
(
aInput
.
mContext
optionType
)
;
}
displayISize
+
=
DropDownButtonISize
(
)
;
return
displayISize
;
}
dom
:
:
HTMLSelectElement
&
nsComboboxControlFrame
:
:
Select
(
)
const
{
return
*
static_cast
<
dom
:
:
HTMLSelectElement
*
>
(
GetContent
(
)
)
;
}
void
nsComboboxControlFrame
:
:
GetOptionText
(
uint32_t
aIndex
nsAString
&
aText
)
const
{
aText
.
Truncate
(
)
;
if
(
Element
*
el
=
Select
(
)
.
Options
(
)
-
>
GetElementAt
(
aIndex
)
)
{
static_cast
<
dom
:
:
HTMLOptionElement
*
>
(
el
)
-
>
GetRenderedLabel
(
aText
)
;
}
}
void
nsComboboxControlFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
const
nscoord
buttonISize
=
DropDownButtonISize
(
)
;
const
auto
padding
=
aReflowInput
.
ComputedLogicalPadding
(
wm
)
;
mDisplayISize
=
aReflowInput
.
ComputedISize
(
)
-
buttonISize
;
if
(
buttonISize
)
{
mDisplayISize
+
=
padding
.
IEnd
(
wm
)
;
}
ButtonControlFrame
:
:
Reflow
(
aPresContext
aDesiredSize
aReflowInput
aStatus
)
;
}
void
nsComboboxControlFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
ButtonControlFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
mEventListener
=
new
HTMLSelectEventListener
(
Select
(
)
HTMLSelectEventListener
:
:
SelectType
:
:
Combobox
)
;
mDisplayedIndex
=
Select
(
)
.
SelectedIndex
(
)
;
}
nsresult
nsComboboxControlFrame
:
:
RedisplaySelectedText
(
)
{
nsAutoScriptBlocker
scriptBlocker
;
mDisplayedIndex
=
Select
(
)
.
SelectedIndex
(
)
;
return
RedisplayText
(
)
;
}
nsresult
nsComboboxControlFrame
:
:
RedisplayText
(
)
{
nsAutoString
currentLabel
;
mDisplayLabel
-
>
GetFirstChild
(
)
-
>
AsText
(
)
-
>
GetData
(
currentLabel
)
;
nsAutoString
newLabel
;
GetLabelText
(
newLabel
)
;
mRedisplayTextEvent
.
Revoke
(
)
;
if
(
currentLabel
=
=
newLabel
)
{
return
NS_OK
;
}
NS_ASSERTION
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
If
we
happen
to
run
our
redisplay
event
now
we
might
kill
"
"
ourselves
!
"
)
;
mRedisplayTextEvent
=
new
RedisplayTextEvent
(
this
)
;
nsContentUtils
:
:
AddScriptRunner
(
mRedisplayTextEvent
.
get
(
)
)
;
return
NS_OK
;
}
void
nsComboboxControlFrame
:
:
UpdateLabelText
(
)
{
RefPtr
<
dom
:
:
Text
>
displayContent
=
mDisplayLabel
-
>
GetFirstChild
(
)
-
>
AsText
(
)
;
nsAutoString
newLabel
;
GetLabelText
(
newLabel
)
;
displayContent
-
>
SetText
(
newLabel
true
)
;
}
void
nsComboboxControlFrame
:
:
HandleRedisplayTextEvent
(
)
{
AutoWeakFrame
weakThis
(
this
)
;
PresContext
(
)
-
>
Document
(
)
-
>
FlushPendingNotifications
(
FlushType
:
:
ContentAndNotify
)
;
if
(
!
weakThis
.
IsAlive
(
)
)
{
return
;
}
mRedisplayTextEvent
.
Forget
(
)
;
UpdateLabelText
(
)
;
}
void
nsComboboxControlFrame
:
:
GetLabelText
(
nsAString
&
aLabel
)
{
Select
(
)
.
GetPreviewValue
(
aLabel
)
;
if
(
!
aLabel
.
IsEmpty
(
)
)
{
return
;
}
if
(
mDisplayedIndex
!
=
-
1
)
{
GetOptionText
(
mDisplayedIndex
aLabel
)
;
}
EnsureNonEmptyLabel
(
aLabel
)
;
}
bool
nsComboboxControlFrame
:
:
IsDroppedDown
(
)
const
{
return
Select
(
)
.
OpenInParentProcess
(
)
;
}
NS_IMETHODIMP
nsComboboxControlFrame
:
:
DoneAddingChildren
(
bool
aIsDone
)
{
return
NS_OK
;
}
NS_IMETHODIMP
nsComboboxControlFrame
:
:
AddOption
(
int32_t
aIndex
)
{
if
(
aIndex
<
=
mDisplayedIndex
)
{
+
+
mDisplayedIndex
;
}
return
NS_OK
;
}
NS_IMETHODIMP
nsComboboxControlFrame
:
:
RemoveOption
(
int32_t
aIndex
)
{
if
(
Select
(
)
.
Options
(
)
-
>
Length
(
)
)
{
if
(
aIndex
<
mDisplayedIndex
)
{
-
-
mDisplayedIndex
;
}
else
if
(
aIndex
=
=
mDisplayedIndex
)
{
mDisplayedIndex
=
0
;
RedisplayText
(
)
;
}
}
else
{
mDisplayedIndex
=
-
1
;
RedisplayText
(
)
;
}
return
NS_OK
;
}
NS_IMETHODIMP_
(
void
)
nsComboboxControlFrame
:
:
OnSetSelectedIndex
(
int32_t
aOldIndex
int32_t
aNewIndex
)
{
nsAutoScriptBlocker
scriptBlocker
;
mDisplayedIndex
=
aNewIndex
;
RedisplayText
(
)
;
}
nsresult
nsComboboxControlFrame
:
:
HandleEvent
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
{
NS_ENSURE_ARG_POINTER
(
aEventStatus
)
;
if
(
nsEventStatus_eConsumeNoDefault
=
=
*
aEventStatus
)
{
return
NS_OK
;
}
return
ButtonControlFrame
:
:
HandleEvent
(
aPresContext
aEvent
aEventStatus
)
;
}
nsresult
nsComboboxControlFrame
:
:
CreateAnonymousContent
(
nsTArray
<
ContentInfo
>
&
aElements
)
{
dom
:
:
Document
*
doc
=
mContent
-
>
OwnerDoc
(
)
;
mDisplayLabel
=
doc
-
>
CreateHTMLElement
(
nsGkAtoms
:
:
label
)
;
{
RefPtr
<
nsTextNode
>
text
=
doc
-
>
CreateEmptyTextNode
(
)
;
mDisplayLabel
-
>
AppendChildTo
(
text
false
IgnoreErrors
(
)
)
;
UpdateLabelText
(
)
;
}
aElements
.
AppendElement
(
mDisplayLabel
)
;
if
(
HasDropDownButton
(
)
)
{
mButtonContent
=
mContent
-
>
OwnerDoc
(
)
-
>
CreateHTMLElement
(
nsGkAtoms
:
:
button
)
;
{
RefPtr
<
nsTextNode
>
text
=
doc
-
>
CreateTextNode
(
u
"
\
ufeff
"
_ns
)
;
mButtonContent
-
>
AppendChildTo
(
text
false
IgnoreErrors
(
)
)
;
}
mButtonContent
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
type
u
"
button
"
_ns
false
)
;
mButtonContent
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
tabindex
u
"
-
1
"
_ns
false
)
;
aElements
.
AppendElement
(
mButtonContent
)
;
}
return
NS_OK
;
}
void
nsComboboxControlFrame
:
:
AppendAnonymousContentTo
(
nsTArray
<
nsIContent
*
>
&
aElements
uint32_t
aFilter
)
{
if
(
mDisplayLabel
)
{
aElements
.
AppendElement
(
mDisplayLabel
)
;
}
if
(
mButtonContent
)
{
aElements
.
AppendElement
(
mButtonContent
)
;
}
}
namespace
mozilla
{
class
ComboboxLabelFrame
final
:
public
nsBlockFrame
{
public
:
NS_DECL_QUERYFRAME
NS_DECL_FRAMEARENA_HELPERS
(
ComboboxLabelFrame
)
#
ifdef
DEBUG_FRAME_DUMP
nsresult
GetFrameName
(
nsAString
&
aResult
)
const
final
{
return
MakeFrameName
(
u
"
ComboboxLabel
"
_ns
aResult
)
;
}
#
endif
void
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
final
;
public
:
ComboboxLabelFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
:
nsBlockFrame
(
aStyle
aPresContext
kClassID
)
{
}
}
;
NS_QUERYFRAME_HEAD
(
ComboboxLabelFrame
)
NS_QUERYFRAME_ENTRY
(
ComboboxLabelFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsBlockFrame
)
NS_IMPL_FRAMEARENA_HELPERS
(
ComboboxLabelFrame
)
void
ComboboxLabelFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
const
nsComboboxControlFrame
*
combobox
=
do_QueryFrame
(
GetParent
(
)
)
;
MOZ_ASSERT
(
combobox
"
Combobox
'
s
frame
tree
is
wrong
!
"
)
;
MOZ_ASSERT
(
aReflowInput
.
ComputedPhysicalBorderPadding
(
)
=
=
nsMargin
(
)
"
We
shouldn
'
t
have
border
and
padding
in
UA
!
"
)
;
ReflowInput
state
(
aReflowInput
)
;
state
.
SetComputedISize
(
combobox
-
>
mDisplayISize
)
;
nsBlockFrame
:
:
Reflow
(
aPresContext
aDesiredSize
state
aStatus
)
;
aStatus
.
Reset
(
)
;
}
}
nsIFrame
*
NS_NewComboboxLabelFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
ComboboxLabelFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
void
nsComboboxControlFrame
:
:
Destroy
(
DestroyContext
&
aContext
)
{
mRedisplayTextEvent
.
Revoke
(
)
;
mEventListener
-
>
Detach
(
)
;
aContext
.
AddAnonymousContent
(
mDisplayLabel
.
forget
(
)
)
;
aContext
.
AddAnonymousContent
(
mButtonContent
.
forget
(
)
)
;
ButtonControlFrame
:
:
Destroy
(
aContext
)
;
}
NS_IMETHODIMP
nsComboboxControlFrame
:
:
OnOptionSelected
(
int32_t
aIndex
bool
aSelected
)
{
if
(
aSelected
)
{
nsAutoScriptBlocker
blocker
;
mDisplayedIndex
=
aIndex
;
RedisplayText
(
)
;
}
else
{
AutoWeakFrame
weakFrame
(
this
)
;
RedisplaySelectedText
(
)
;
if
(
weakFrame
.
IsAlive
(
)
)
{
FireValueChangeEvent
(
)
;
}
}
return
NS_OK
;
}
void
nsComboboxControlFrame
:
:
FireValueChangeEvent
(
)
{
nsContentUtils
:
:
AddScriptRunner
(
new
AsyncEventDispatcher
(
mContent
u
"
ValueChange
"
_ns
CanBubble
:
:
eYes
ChromeOnlyDispatch
:
:
eNo
)
)
;
}
