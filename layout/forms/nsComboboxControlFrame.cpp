#
include
"
nsComboboxControlFrame
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
gfxUtils
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
gfx
/
PathHelpers
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsCheckboxRadioFrame
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsCSSAnonBoxes
.
h
"
#
include
"
nsHTMLParts
.
h
"
#
include
"
nsIFormControl
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsListControlFrame
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
mozilla
/
PresState
.
h
"
#
include
"
nsView
.
h
"
#
include
"
nsViewManager
.
h
"
#
include
"
nsIContentInlines
.
h
"
#
include
"
nsIDOMEventListener
.
h
"
#
include
"
nsISelectControlFrame
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
HTMLSelectElement
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
nsNodeInfoManager
.
h
"
#
include
"
nsContentCreatorFunctions
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsITheme
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
<
algorithm
>
#
include
"
nsTextNode
.
h
"
#
include
"
mozilla
/
AsyncEventDispatcher
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
PresShellInlines
.
h
"
#
include
"
mozilla
/
Unused
.
h
"
#
include
"
gfx2DGlue
.
h
"
#
include
"
mozilla
/
widget
/
nsAutoRollup
.
h
"
#
include
"
nsILayoutHistoryState
.
h
"
#
ifdef
XP_WIN
#
define
COMBOBOX_ROLLUP_CONSUME_EVENT
0
#
else
#
define
COMBOBOX_ROLLUP_CONSUME_EVENT
1
#
endif
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
using
mozilla
:
:
dom
:
:
Document
;
NS_IMETHODIMP
nsComboboxControlFrame
:
:
RedisplayTextEvent
:
:
Run
(
)
{
if
(
mControlFrame
)
mControlFrame
-
>
HandleRedisplayTextEvent
(
)
;
return
NS_OK
;
}
#
define
FIX_FOR_BUG_53259
class
nsComboButtonListener
final
:
public
nsIDOMEventListener
{
private
:
virtual
~
nsComboButtonListener
(
)
{
}
public
:
NS_DECL_ISUPPORTS
MOZ_CAN_RUN_SCRIPT_BOUNDARY
NS_IMETHOD
HandleEvent
(
dom
:
:
Event
*
)
override
{
mComboBox
-
>
ShowDropDown
(
!
mComboBox
-
>
IsDroppedDown
(
)
)
;
return
NS_OK
;
}
explicit
nsComboButtonListener
(
nsComboboxControlFrame
*
aCombobox
)
{
mComboBox
=
aCombobox
;
}
nsComboboxControlFrame
*
mComboBox
;
}
;
NS_IMPL_ISUPPORTS
(
nsComboButtonListener
nsIDOMEventListener
)
nsComboboxControlFrame
*
nsComboboxControlFrame
:
:
sFocused
=
nullptr
;
nsComboboxControlFrame
*
NS_NewComboboxControlFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
nsFrameState
aStateFlags
)
{
nsComboboxControlFrame
*
it
=
new
(
aPresShell
)
nsComboboxControlFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
if
(
it
)
{
it
-
>
AddStateBits
(
aStateFlags
)
;
}
return
it
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsComboboxControlFrame
)
#
ifdef
DO_REFLOW_COUNTER
#
define
MAX_REFLOW_CNT
1024
static
int32_t
gTotalReqs
=
0
;
;
static
int32_t
gTotalReflows
=
0
;
;
static
int32_t
gReflowControlCntRQ
[
MAX_REFLOW_CNT
]
;
static
int32_t
gReflowControlCnt
[
MAX_REFLOW_CNT
]
;
static
int32_t
gReflowInx
=
-
1
;
#
define
REFLOW_COUNTER
(
)
\
if
(
mReflowId
>
-
1
)
gReflowControlCnt
[
mReflowId
]
+
+
;
#
define
REFLOW_COUNTER_REQUEST
(
)
\
if
(
mReflowId
>
-
1
)
gReflowControlCntRQ
[
mReflowId
]
+
+
;
#
define
REFLOW_COUNTER_DUMP
(
__desc
)
\
if
(
mReflowId
>
-
1
)
{
\
gTotalReqs
+
=
gReflowControlCntRQ
[
mReflowId
]
;
\
gTotalReflows
+
=
gReflowControlCnt
[
mReflowId
]
;
\
printf
(
"
*
*
Id
:
%
5d
%
s
RF
:
%
d
RQ
:
%
d
%
d
/
%
d
%
5
.
2f
\
n
"
mReflowId
\
(
__desc
)
gReflowControlCnt
[
mReflowId
]
\
gReflowControlCntRQ
[
mReflowId
]
gTotalReflows
gTotalReqs
\
float
(
gTotalReflows
)
/
float
(
gTotalReqs
)
*
100
.
0f
)
;
\
}
#
define
REFLOW_COUNTER_INIT
(
)
\
if
(
gReflowInx
<
MAX_REFLOW_CNT
)
{
\
gReflowInx
+
+
;
\
mReflowId
=
gReflowInx
;
\
gReflowControlCnt
[
mReflowId
]
=
0
;
\
gReflowControlCntRQ
[
mReflowId
]
=
0
;
\
}
else
{
\
mReflowId
=
-
1
;
\
}
#
define
REFLOW_DEBUG_MSG
(
_msg1
)
printf
(
(
_msg1
)
)
#
define
REFLOW_DEBUG_MSG2
(
_msg1
_msg2
)
printf
(
(
_msg1
)
(
_msg2
)
)
#
define
REFLOW_DEBUG_MSG3
(
_msg1
_msg2
_msg3
)
\
printf
(
(
_msg1
)
(
_msg2
)
(
_msg3
)
)
#
define
REFLOW_DEBUG_MSG4
(
_msg1
_msg2
_msg3
_msg4
)
\
printf
(
(
_msg1
)
(
_msg2
)
(
_msg3
)
(
_msg4
)
)
#
else
#
define
REFLOW_COUNTER_REQUEST
(
)
#
define
REFLOW_COUNTER
(
)
#
define
REFLOW_COUNTER_DUMP
(
__desc
)
#
define
REFLOW_COUNTER_INIT
(
)
#
define
REFLOW_DEBUG_MSG
(
_msg
)
#
define
REFLOW_DEBUG_MSG2
(
_msg1
_msg2
)
#
define
REFLOW_DEBUG_MSG3
(
_msg1
_msg2
_msg3
)
#
define
REFLOW_DEBUG_MSG4
(
_msg1
_msg2
_msg3
_msg4
)
#
endif
#
ifdef
DO_VERY_NOISY
#
define
REFLOW_NOISY_MSG
(
_msg1
)
printf
(
(
_msg1
)
)
#
define
REFLOW_NOISY_MSG2
(
_msg1
_msg2
)
printf
(
(
_msg1
)
(
_msg2
)
)
#
define
REFLOW_NOISY_MSG3
(
_msg1
_msg2
_msg3
)
\
printf
(
(
_msg1
)
(
_msg2
)
(
_msg3
)
)
#
define
REFLOW_NOISY_MSG4
(
_msg1
_msg2
_msg3
_msg4
)
\
printf
(
(
_msg1
)
(
_msg2
)
(
_msg3
)
(
_msg4
)
)
#
else
#
define
REFLOW_NOISY_MSG
(
_msg
)
#
define
REFLOW_NOISY_MSG2
(
_msg1
_msg2
)
#
define
REFLOW_NOISY_MSG3
(
_msg1
_msg2
_msg3
)
#
define
REFLOW_NOISY_MSG4
(
_msg1
_msg2
_msg3
_msg4
)
#
endif
#
ifdef
DO_PIXELS
#
define
PX
(
__v
)
__v
/
15
#
else
#
define
PX
(
__v
)
__v
#
endif
nsComboboxControlFrame
:
:
nsComboboxControlFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
:
nsBlockFrame
(
aStyle
aPresContext
kClassID
)
mDisplayFrame
(
nullptr
)
mButtonFrame
(
nullptr
)
mDropdownFrame
(
nullptr
)
mListControlFrame
(
nullptr
)
mDisplayISize
(
0
)
mMaxDisplayISize
(
0
)
mRecentSelectedIndex
(
NS_SKIP_NOTIFY_INDEX
)
mDisplayedIndex
(
-
1
)
mLastDropDownBeforeScreenBCoord
(
nscoord_MIN
)
mLastDropDownAfterScreenBCoord
(
nscoord_MIN
)
mDroppedDown
(
false
)
mInRedisplayText
(
false
)
mDelayedShowDropDown
(
false
)
mIsOpenInParentProcess
(
false
)
{
REFLOW_COUNTER_INIT
(
)
}
nsComboboxControlFrame
:
:
~
nsComboboxControlFrame
(
)
{
REFLOW_COUNTER_DUMP
(
"
nsCCF
"
)
;
}
NS_QUERYFRAME_HEAD
(
nsComboboxControlFrame
)
NS_QUERYFRAME_ENTRY
(
nsComboboxControlFrame
)
NS_QUERYFRAME_ENTRY
(
nsIFormControlFrame
)
NS_QUERYFRAME_ENTRY
(
nsIAnonymousContentCreator
)
NS_QUERYFRAME_ENTRY
(
nsISelectControlFrame
)
NS_QUERYFRAME_ENTRY
(
nsIStatefulFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsBlockFrame
)
#
ifdef
ACCESSIBILITY
a11y
:
:
AccType
nsComboboxControlFrame
:
:
AccessibleType
(
)
{
return
a11y
:
:
eHTMLComboboxType
;
}
#
endif
void
nsComboboxControlFrame
:
:
SetFocus
(
bool
aOn
bool
aRepaint
)
{
AutoWeakFrame
weakFrame
(
this
)
;
if
(
aOn
)
{
nsListControlFrame
:
:
ComboboxFocusSet
(
)
;
sFocused
=
this
;
if
(
mDelayedShowDropDown
)
{
ShowDropDown
(
true
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
;
}
}
}
else
{
sFocused
=
nullptr
;
mDelayedShowDropDown
=
false
;
if
(
mDroppedDown
)
{
mListControlFrame
-
>
ComboboxFinish
(
mDisplayedIndex
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
;
}
}
mListControlFrame
-
>
FireOnInputAndOnChange
(
)
;
}
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
;
}
InvalidateFrame
(
)
;
}
void
nsComboboxControlFrame
:
:
ShowPopup
(
bool
aShowPopup
)
{
nsView
*
view
=
mDropdownFrame
-
>
GetView
(
)
;
nsViewManager
*
viewManager
=
view
-
>
GetViewManager
(
)
;
if
(
aShowPopup
)
{
nsRect
rect
=
mDropdownFrame
-
>
GetRect
(
)
;
rect
.
x
=
rect
.
y
=
0
;
viewManager
-
>
ResizeView
(
view
rect
)
;
viewManager
-
>
SetViewVisibility
(
view
nsViewVisibility_kShow
)
;
}
else
{
viewManager
-
>
SetViewVisibility
(
view
nsViewVisibility_kHide
)
;
nsRect
emptyRect
(
0
0
0
0
)
;
viewManager
-
>
ResizeView
(
view
emptyRect
)
;
}
RefPtr
<
mozilla
:
:
PresShell
>
presShell
=
PresContext
(
)
-
>
GetPresShell
(
)
;
if
(
presShell
&
&
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
{
nsEventStatus
status
=
nsEventStatus_eIgnore
;
WidgetMouseEvent
event
(
true
aShowPopup
?
eXULPopupShowing
:
eXULPopupHiding
nullptr
WidgetMouseEvent
:
:
eReal
)
;
nsCOMPtr
<
nsIContent
>
content
=
mContent
;
presShell
-
>
HandleDOMEventWithTarget
(
content
&
event
&
status
)
;
}
}
bool
nsComboboxControlFrame
:
:
ShowList
(
bool
aShowList
)
{
nsView
*
view
=
mDropdownFrame
-
>
GetView
(
)
;
if
(
aShowList
)
{
NS_ASSERTION
(
!
view
-
>
HasWidget
(
)
"
We
shouldn
'
t
have
a
widget
before
we
need
to
display
the
popup
"
)
;
view
-
>
GetViewManager
(
)
-
>
SetViewFloating
(
view
true
)
;
nsWidgetInitData
widgetData
;
widgetData
.
mWindowType
=
eWindowType_popup
;
widgetData
.
mBorderStyle
=
eBorderStyle_default
;
view
-
>
CreateWidgetForPopup
(
&
widgetData
)
;
}
else
{
nsIWidget
*
widget
=
view
-
>
GetWidget
(
)
;
if
(
widget
)
{
widget
-
>
CaptureRollupEvents
(
this
false
)
;
}
}
AutoWeakFrame
weakFrame
(
this
)
;
ShowPopup
(
aShowList
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
false
;
}
mDroppedDown
=
aShowList
;
nsIWidget
*
widget
=
view
-
>
GetWidget
(
)
;
if
(
mDroppedDown
)
{
mListControlFrame
-
>
AboutToDropDown
(
)
;
mListControlFrame
-
>
CaptureMouseEvents
(
true
)
;
if
(
widget
)
{
widget
-
>
CaptureRollupEvents
(
this
true
)
;
}
}
else
{
if
(
widget
)
{
view
-
>
DestroyWidget
(
)
;
}
}
return
weakFrame
.
IsAlive
(
)
;
}
class
nsResizeDropdownAtFinalPosition
final
:
public
nsIReflowCallback
public
Runnable
{
public
:
explicit
nsResizeDropdownAtFinalPosition
(
nsComboboxControlFrame
*
aFrame
)
:
mozilla
:
:
Runnable
(
"
nsResizeDropdownAtFinalPosition
"
)
mFrame
(
aFrame
)
{
}
protected
:
~
nsResizeDropdownAtFinalPosition
(
)
{
}
public
:
virtual
bool
ReflowFinished
(
)
override
{
Run
(
)
;
NS_RELEASE_THIS
(
)
;
return
false
;
}
virtual
void
ReflowCallbackCanceled
(
)
override
{
NS_RELEASE_THIS
(
)
;
}
NS_IMETHOD
Run
(
)
override
{
if
(
mFrame
.
IsAlive
(
)
)
{
static_cast
<
nsComboboxControlFrame
*
>
(
mFrame
.
GetFrame
(
)
)
-
>
AbsolutelyPositionDropDown
(
)
;
}
return
NS_OK
;
}
WeakFrame
mFrame
;
}
;
void
nsComboboxControlFrame
:
:
ReflowDropdown
(
nsPresContext
*
aPresContext
const
ReflowInput
&
aReflowInput
)
{
if
(
!
aReflowInput
.
ShouldReflowAllKids
(
)
&
&
!
NS_SUBTREE_DIRTY
(
mDropdownFrame
)
)
{
return
;
}
WritingMode
wm
=
mDropdownFrame
-
>
GetWritingMode
(
)
;
LogicalSize
availSize
=
aReflowInput
.
AvailableSize
(
wm
)
;
availSize
.
BSize
(
wm
)
=
NS_UNCONSTRAINEDSIZE
;
ReflowInput
kidReflowInput
(
aPresContext
aReflowInput
mDropdownFrame
availSize
)
;
nscoord
forcedISize
=
aReflowInput
.
ComputedISize
(
)
+
aReflowInput
.
ComputedLogicalBorderPadding
(
)
.
IStartEnd
(
wm
)
-
kidReflowInput
.
ComputedLogicalBorderPadding
(
)
.
IStartEnd
(
wm
)
;
kidReflowInput
.
SetComputedISize
(
std
:
:
max
(
kidReflowInput
.
ComputedISize
(
)
forcedISize
)
)
;
if
(
!
mDroppedDown
&
&
GetStateBits
(
)
&
NS_FRAME_FIRST_REFLOW
)
{
nsView
*
view
=
mDropdownFrame
-
>
GetView
(
)
;
nsViewManager
*
viewManager
=
view
-
>
GetViewManager
(
)
;
viewManager
-
>
SetViewVisibility
(
view
nsViewVisibility_kHide
)
;
nsRect
emptyRect
(
0
0
0
0
)
;
viewManager
-
>
ResizeView
(
view
emptyRect
)
;
}
ReflowChildFlags
flags
=
mDroppedDown
?
ReflowChildFlags
:
:
Default
:
ReflowChildFlags
:
:
NoMoveFrame
|
ReflowChildFlags
:
:
NoVisibility
|
ReflowChildFlags
:
:
NoSizeView
;
WritingMode
outerWM
=
GetWritingMode
(
)
;
const
nsSize
dummyContainerSize
;
ReflowOutput
desiredSize
(
aReflowInput
)
;
nsReflowStatus
ignoredStatus
;
ReflowChild
(
mDropdownFrame
aPresContext
desiredSize
kidReflowInput
outerWM
LogicalPoint
(
outerWM
)
dummyContainerSize
flags
ignoredStatus
)
;
FinishReflowChild
(
mDropdownFrame
aPresContext
desiredSize
&
kidReflowInput
outerWM
LogicalPoint
(
outerWM
)
dummyContainerSize
flags
)
;
}
nsPoint
nsComboboxControlFrame
:
:
GetCSSTransformTranslation
(
)
{
nsIFrame
*
frame
=
this
;
bool
is3DTransform
=
false
;
Matrix
transform
;
while
(
frame
)
{
nsIFrame
*
parent
;
Matrix4x4Flagged
ctm
=
frame
-
>
GetTransformMatrix
(
nullptr
&
parent
)
;
Matrix
matrix
;
if
(
ctm
.
Is2D
(
&
matrix
)
)
{
transform
=
transform
*
matrix
;
}
else
{
is3DTransform
=
true
;
break
;
}
frame
=
parent
;
}
nsPoint
translation
;
if
(
!
is3DTransform
&
&
!
transform
.
HasNonTranslation
(
)
)
{
nsPresContext
*
pc
=
PresContext
(
)
;
nsRootPresContext
*
rootPC
=
pc
-
>
GetRootPresContext
(
)
;
if
(
rootPC
)
{
int32_t
apd
=
pc
-
>
AppUnitsPerDevPixel
(
)
;
translation
.
x
=
NSFloatPixelsToAppUnits
(
transform
.
_31
apd
)
;
translation
.
y
=
NSFloatPixelsToAppUnits
(
transform
.
_32
apd
)
;
translation
-
=
GetOffsetToCrossDoc
(
rootPC
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
)
;
}
}
return
translation
;
}
class
nsAsyncRollup
:
public
Runnable
{
public
:
explicit
nsAsyncRollup
(
nsComboboxControlFrame
*
aFrame
)
:
mozilla
:
:
Runnable
(
"
nsAsyncRollup
"
)
mFrame
(
aFrame
)
{
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
NS_IMETHOD
Run
(
)
override
{
if
(
mFrame
.
IsAlive
(
)
)
{
static_cast
<
nsComboboxControlFrame
*
>
(
mFrame
.
GetFrame
(
)
)
-
>
RollupFromList
(
)
;
}
return
NS_OK
;
}
WeakFrame
mFrame
;
}
;
class
nsAsyncResize
:
public
Runnable
{
public
:
explicit
nsAsyncResize
(
nsComboboxControlFrame
*
aFrame
)
:
mozilla
:
:
Runnable
(
"
nsAsyncResize
"
)
mFrame
(
aFrame
)
{
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
NS_IMETHOD
Run
(
)
override
{
if
(
mFrame
.
IsAlive
(
)
)
{
nsComboboxControlFrame
*
combo
=
static_cast
<
nsComboboxControlFrame
*
>
(
mFrame
.
GetFrame
(
)
)
;
static_cast
<
nsListControlFrame
*
>
(
combo
-
>
mDropdownFrame
)
-
>
SetSuppressScrollbarUpdate
(
true
)
;
RefPtr
<
PresShell
>
presShell
=
mFrame
-
>
PresShell
(
)
;
presShell
-
>
FrameNeedsReflow
(
combo
-
>
mDropdownFrame
IntrinsicDirty
:
:
Resize
NS_FRAME_IS_DIRTY
)
;
presShell
-
>
FlushPendingNotifications
(
FlushType
:
:
Layout
)
;
if
(
mFrame
.
IsAlive
(
)
)
{
combo
=
static_cast
<
nsComboboxControlFrame
*
>
(
mFrame
.
GetFrame
(
)
)
;
static_cast
<
nsListControlFrame
*
>
(
combo
-
>
mDropdownFrame
)
-
>
SetSuppressScrollbarUpdate
(
false
)
;
if
(
combo
-
>
mDelayedShowDropDown
)
{
combo
-
>
ShowDropDown
(
true
)
;
}
}
}
return
NS_OK
;
}
WeakFrame
mFrame
;
}
;
void
nsComboboxControlFrame
:
:
GetAvailableDropdownSpace
(
WritingMode
aWM
nscoord
*
aBefore
nscoord
*
aAfter
LogicalPoint
*
aTranslation
)
{
MOZ_ASSERT
(
!
XRE_IsContentProcess
(
)
)
;
const
nsSize
nullContainerSize
;
*
aTranslation
=
LogicalPoint
(
aWM
GetCSSTransformTranslation
(
)
nullContainerSize
)
;
*
aBefore
=
0
;
*
aAfter
=
0
;
nsRect
screen
=
nsCheckboxRadioFrame
:
:
GetUsableScreenRect
(
PresContext
(
)
)
;
nsSize
containerSize
=
screen
.
Size
(
)
;
LogicalRect
logicalScreen
(
aWM
screen
containerSize
)
;
if
(
mLastDropDownAfterScreenBCoord
=
=
nscoord_MIN
)
{
LogicalRect
thisScreenRect
(
aWM
GetScreenRectInAppUnits
(
)
containerSize
)
;
mLastDropDownAfterScreenBCoord
=
thisScreenRect
.
BEnd
(
aWM
)
+
aTranslation
-
>
B
(
aWM
)
;
mLastDropDownBeforeScreenBCoord
=
thisScreenRect
.
BStart
(
aWM
)
+
aTranslation
-
>
B
(
aWM
)
;
}
nscoord
minBCoord
;
nsPresContext
*
pc
=
PresContext
(
)
-
>
GetToplevelContentDocumentPresContext
(
)
;
nsIFrame
*
root
=
pc
?
pc
-
>
PresShell
(
)
-
>
GetRootFrame
(
)
:
nullptr
;
if
(
root
)
{
minBCoord
=
LogicalRect
(
aWM
root
-
>
GetScreenRectInAppUnits
(
)
containerSize
)
.
BStart
(
aWM
)
;
if
(
mLastDropDownAfterScreenBCoord
<
minBCoord
)
{
return
;
}
}
else
{
minBCoord
=
logicalScreen
.
BStart
(
aWM
)
;
}
nscoord
after
=
logicalScreen
.
BEnd
(
aWM
)
-
mLastDropDownAfterScreenBCoord
;
nscoord
before
=
mLastDropDownBeforeScreenBCoord
-
minBCoord
;
if
(
before
>
=
after
)
{
nsListControlFrame
*
lcf
=
static_cast
<
nsListControlFrame
*
>
(
mDropdownFrame
)
;
nscoord
rowBSize
=
lcf
-
>
GetBSizeOfARow
(
)
;
if
(
before
<
after
+
rowBSize
)
{
before
-
=
rowBSize
;
}
}
*
aAfter
=
after
;
*
aBefore
=
before
;
}
nsComboboxControlFrame
:
:
DropDownPositionState
nsComboboxControlFrame
:
:
AbsolutelyPositionDropDown
(
)
{
if
(
XRE_IsContentProcess
(
)
)
{
return
eDropDownPositionSuppressed
;
}
WritingMode
wm
=
GetWritingMode
(
)
;
LogicalPoint
translation
(
wm
)
;
nscoord
before
after
;
mLastDropDownAfterScreenBCoord
=
nscoord_MIN
;
GetAvailableDropdownSpace
(
wm
&
before
&
after
&
translation
)
;
if
(
before
<
=
0
&
&
after
<
=
0
)
{
if
(
IsDroppedDown
(
)
)
{
nsView
*
view
=
mDropdownFrame
-
>
GetView
(
)
;
view
-
>
GetViewManager
(
)
-
>
SetViewVisibility
(
view
nsViewVisibility_kHide
)
;
NS_DispatchToCurrentThread
(
new
nsAsyncRollup
(
this
)
)
;
}
return
eDropDownPositionSuppressed
;
}
LogicalSize
dropdownSize
=
mDropdownFrame
-
>
GetLogicalSize
(
wm
)
;
nscoord
bSize
=
std
:
:
max
(
before
after
)
;
nsListControlFrame
*
lcf
=
static_cast
<
nsListControlFrame
*
>
(
mDropdownFrame
)
;
if
(
bSize
<
dropdownSize
.
BSize
(
wm
)
)
{
if
(
lcf
-
>
GetNumDisplayRows
(
)
>
1
)
{
NS_DispatchToCurrentThread
(
new
nsAsyncResize
(
this
)
)
;
return
eDropDownPositionPendingResize
;
}
}
else
if
(
bSize
>
(
dropdownSize
.
BSize
(
wm
)
+
lcf
-
>
GetBSizeOfARow
(
)
*
1
.
5
)
&
&
lcf
-
>
GetDropdownCanGrow
(
)
)
{
NS_DispatchToCurrentThread
(
new
nsAsyncResize
(
this
)
)
;
return
eDropDownPositionPendingResize
;
}
bool
b
=
dropdownSize
.
BSize
(
wm
)
<
=
after
|
|
dropdownSize
.
BSize
(
wm
)
>
before
;
LogicalPoint
dropdownPosition
(
wm
0
b
?
BSize
(
wm
)
:
-
dropdownSize
.
BSize
(
wm
)
)
;
nsSize
containerSize
=
GetSize
(
)
;
const
LogicalPoint
currentPos
=
mDropdownFrame
-
>
GetLogicalPosition
(
containerSize
)
;
const
LogicalPoint
newPos
=
dropdownPosition
+
translation
;
if
(
currentPos
!
=
newPos
)
{
mDropdownFrame
-
>
SetPosition
(
wm
newPos
containerSize
)
;
nsContainerFrame
:
:
PositionFrameView
(
mDropdownFrame
)
;
}
return
eDropDownPositionFinal
;
}
void
nsComboboxControlFrame
:
:
NotifyGeometryChange
(
)
{
if
(
XRE_IsContentProcess
(
)
)
{
return
;
}
if
(
IsDroppedDown
(
)
&
&
!
(
GetStateBits
(
)
&
NS_FRAME_IS_DIRTY
)
&
&
!
mDelayedShowDropDown
)
{
RefPtr
<
nsResizeDropdownAtFinalPosition
>
resize
=
new
nsResizeDropdownAtFinalPosition
(
this
)
;
NS_DispatchToCurrentThread
(
resize
)
;
}
}
#
ifdef
DO_REFLOW_DEBUG
static
int
myCounter
=
0
;
static
void
printSize
(
char
*
aDesc
nscoord
aSize
)
{
printf
(
"
%
s
:
"
aDesc
)
;
if
(
aSize
=
=
NS_UNCONSTRAINEDSIZE
)
{
printf
(
"
UC
"
)
;
}
else
{
printf
(
"
%
d
"
PX
(
aSize
)
)
;
}
}
#
endif
bool
nsComboboxControlFrame
:
:
HasDropDownButton
(
)
const
{
const
nsStyleDisplay
*
disp
=
StyleDisplay
(
)
;
return
disp
-
>
mAppearance
=
=
StyleAppearance
:
:
Menulist
&
&
(
!
IsThemed
(
disp
)
|
|
PresContext
(
)
-
>
GetTheme
(
)
-
>
ThemeNeedsComboboxDropmarker
(
)
)
;
}
nscoord
nsComboboxControlFrame
:
:
GetIntrinsicISize
(
gfxContext
*
aRenderingContext
nsLayoutUtils
:
:
IntrinsicISizeType
aType
)
{
nscoord
scrollbarWidth
=
0
;
nsPresContext
*
presContext
=
PresContext
(
)
;
if
(
mListControlFrame
)
{
nsIScrollableFrame
*
scrollable
=
do_QueryFrame
(
mListControlFrame
)
;
NS_ASSERTION
(
scrollable
"
List
must
be
a
scrollable
frame
"
)
;
scrollbarWidth
=
scrollable
-
>
GetNondisappearingScrollbarWidth
(
presContext
aRenderingContext
GetWritingMode
(
)
)
;
}
const
bool
isContainSize
=
StyleDisplay
(
)
-
>
IsContainSize
(
)
;
nscoord
displayISize
=
0
;
if
(
MOZ_LIKELY
(
mDisplayFrame
)
)
{
if
(
isContainSize
)
{
displayISize
=
mDisplayFrame
-
>
IntrinsicISizeOffsets
(
)
.
padding
;
}
else
{
displayISize
=
nsLayoutUtils
:
:
IntrinsicForContainer
(
aRenderingContext
mDisplayFrame
aType
)
;
}
}
if
(
mDropdownFrame
)
{
nscoord
dropdownContentISize
;
bool
isUsingOverlayScrollbars
=
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
eIntID_UseOverlayScrollbars
)
!
=
0
;
if
(
aType
=
=
nsLayoutUtils
:
:
MIN_ISIZE
)
{
dropdownContentISize
=
isContainSize
?
0
:
mDropdownFrame
-
>
GetMinISize
(
aRenderingContext
)
;
if
(
isUsingOverlayScrollbars
)
{
dropdownContentISize
+
=
scrollbarWidth
;
}
}
else
{
NS_ASSERTION
(
aType
=
=
nsLayoutUtils
:
:
PREF_ISIZE
"
Unexpected
type
"
)
;
dropdownContentISize
=
isContainSize
?
0
:
mDropdownFrame
-
>
GetPrefISize
(
aRenderingContext
)
;
if
(
isUsingOverlayScrollbars
)
{
dropdownContentISize
+
=
scrollbarWidth
;
}
}
dropdownContentISize
=
NSCoordSaturatingSubtract
(
dropdownContentISize
scrollbarWidth
nscoord_MAX
)
;
displayISize
=
std
:
:
max
(
dropdownContentISize
displayISize
)
;
}
if
(
HasDropDownButton
(
)
)
{
displayISize
+
=
scrollbarWidth
;
}
return
displayISize
;
}
nscoord
nsComboboxControlFrame
:
:
GetMinISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
minISize
;
DISPLAY_MIN_INLINE_SIZE
(
this
minISize
)
;
minISize
=
GetIntrinsicISize
(
aRenderingContext
nsLayoutUtils
:
:
MIN_ISIZE
)
;
return
minISize
;
}
nscoord
nsComboboxControlFrame
:
:
GetPrefISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
prefISize
;
DISPLAY_PREF_INLINE_SIZE
(
this
prefISize
)
;
prefISize
=
GetIntrinsicISize
(
aRenderingContext
nsLayoutUtils
:
:
PREF_ISIZE
)
;
return
prefISize
;
}
void
nsComboboxControlFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
if
(
!
mDisplayFrame
|
|
!
mButtonFrame
|
|
!
mDropdownFrame
)
{
NS_ERROR
(
"
Why
did
the
frame
constructor
allow
this
to
happen
?
Fix
it
!
!
"
)
;
return
;
}
if
(
!
mDroppedDown
)
{
mDisplayedIndex
=
mListControlFrame
-
>
GetSelectedIndex
(
)
;
}
RedisplayText
(
)
;
ReflowDropdown
(
aPresContext
aReflowInput
)
;
RefPtr
<
nsResizeDropdownAtFinalPosition
>
resize
=
new
nsResizeDropdownAtFinalPosition
(
this
)
;
if
(
NS_SUCCEEDED
(
aPresContext
-
>
PresShell
(
)
-
>
PostReflowCallback
(
resize
)
)
)
{
Unused
<
<
resize
.
forget
(
)
;
}
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
nscoord
buttonISize
;
if
(
!
HasDropDownButton
(
)
)
{
buttonISize
=
0
;
}
else
{
nsIScrollableFrame
*
scrollable
=
do_QueryFrame
(
mListControlFrame
)
;
NS_ASSERTION
(
scrollable
"
List
must
be
a
scrollable
frame
"
)
;
buttonISize
=
scrollable
-
>
GetNondisappearingScrollbarWidth
(
PresContext
(
)
aReflowInput
.
mRenderingContext
wm
)
;
if
(
buttonISize
>
aReflowInput
.
ComputedISize
(
)
)
{
buttonISize
=
0
;
}
}
mDisplayISize
=
aReflowInput
.
ComputedISize
(
)
-
buttonISize
;
mMaxDisplayISize
=
mDisplayISize
+
aReflowInput
.
ComputedLogicalPadding
(
)
.
IEnd
(
wm
)
;
nsBlockFrame
:
:
Reflow
(
aPresContext
aDesiredSize
aReflowInput
aStatus
)
;
nsSize
containerSize
=
aDesiredSize
.
PhysicalSize
(
)
;
LogicalRect
buttonRect
=
mButtonFrame
-
>
GetLogicalRect
(
containerSize
)
;
buttonRect
.
IStart
(
wm
)
=
aReflowInput
.
ComputedLogicalBorderPadding
(
)
.
IStartEnd
(
wm
)
+
mDisplayISize
-
(
aReflowInput
.
ComputedLogicalBorderPadding
(
)
.
IEnd
(
wm
)
-
aReflowInput
.
ComputedLogicalPadding
(
)
.
IEnd
(
wm
)
)
;
buttonRect
.
ISize
(
wm
)
=
buttonISize
;
buttonRect
.
BStart
(
wm
)
=
this
-
>
GetLogicalUsedBorder
(
wm
)
.
BStart
(
wm
)
;
buttonRect
.
BSize
(
wm
)
=
mDisplayFrame
-
>
BSize
(
wm
)
+
this
-
>
GetLogicalUsedPadding
(
wm
)
.
BStartEnd
(
wm
)
;
mButtonFrame
-
>
SetRect
(
buttonRect
containerSize
)
;
if
(
!
aStatus
.
IsInlineBreakBefore
(
)
&
&
!
aStatus
.
IsFullyComplete
(
)
)
{
aStatus
.
Reset
(
)
;
}
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
nsComboboxControlFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
NS_LITERAL_STRING
(
"
ComboboxControl
"
)
aResult
)
;
}
#
endif
void
nsComboboxControlFrame
:
:
ShowDropDown
(
bool
aDoDropDown
)
{
MOZ_ASSERT
(
!
XRE_IsContentProcess
(
)
)
;
mDelayedShowDropDown
=
false
;
EventStates
eventStates
=
mContent
-
>
AsElement
(
)
-
>
State
(
)
;
if
(
aDoDropDown
&
&
eventStates
.
HasState
(
NS_EVENT_STATE_DISABLED
)
)
{
return
;
}
if
(
!
mDroppedDown
&
&
aDoDropDown
)
{
nsFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
!
fm
|
|
fm
-
>
GetFocusedElement
(
)
=
=
GetContent
(
)
)
{
DropDownPositionState
state
=
AbsolutelyPositionDropDown
(
)
;
if
(
state
=
=
eDropDownPositionFinal
)
{
ShowList
(
aDoDropDown
)
;
}
else
if
(
state
=
=
eDropDownPositionPendingResize
)
{
mDelayedShowDropDown
=
true
;
}
}
else
{
mDelayedShowDropDown
=
true
;
}
}
else
if
(
mDroppedDown
&
&
!
aDoDropDown
)
{
ShowList
(
aDoDropDown
)
;
}
}
void
nsComboboxControlFrame
:
:
SetDropDown
(
nsIFrame
*
aDropDownFrame
)
{
mDropdownFrame
=
aDropDownFrame
;
mListControlFrame
=
do_QueryFrame
(
mDropdownFrame
)
;
if
(
!
sFocused
&
&
nsContentUtils
:
:
IsFocusedContent
(
GetContent
(
)
)
)
{
sFocused
=
this
;
nsListControlFrame
:
:
ComboboxFocusSet
(
)
;
}
}
nsIFrame
*
nsComboboxControlFrame
:
:
GetDropDown
(
)
{
return
mDropdownFrame
;
}
nsresult
nsComboboxControlFrame
:
:
RedisplaySelectedText
(
)
{
nsAutoScriptBlocker
scriptBlocker
;
mDisplayedIndex
=
mListControlFrame
-
>
GetSelectedIndex
(
)
;
return
RedisplayText
(
)
;
}
nsresult
nsComboboxControlFrame
:
:
RedisplayText
(
)
{
nsString
previewValue
;
nsString
previousText
(
mDisplayedOptionTextOrPreview
)
;
auto
*
selectElement
=
static_cast
<
dom
:
:
HTMLSelectElement
*
>
(
GetContent
(
)
)
;
selectElement
-
>
GetPreviewValue
(
previewValue
)
;
if
(
!
previewValue
.
IsEmpty
(
)
)
{
mDisplayedOptionTextOrPreview
=
previewValue
;
}
else
if
(
mDisplayedIndex
!
=
-
1
)
{
mListControlFrame
-
>
GetOptionText
(
mDisplayedIndex
mDisplayedOptionTextOrPreview
)
;
}
else
{
mDisplayedOptionTextOrPreview
.
Truncate
(
)
;
}
REFLOW_DEBUG_MSG2
(
"
RedisplayText
\
"
%
s
\
"
\
n
"
NS_LossyConvertUTF16toASCII
(
mDisplayedOptionTextOrPreview
)
.
get
(
)
)
;
nsresult
rv
=
NS_OK
;
if
(
mDisplayContent
&
&
!
previousText
.
Equals
(
mDisplayedOptionTextOrPreview
)
)
{
mRedisplayTextEvent
.
Revoke
(
)
;
NS_ASSERTION
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
If
we
happen
to
run
our
redisplay
event
now
we
might
kill
"
"
ourselves
!
"
)
;
mRedisplayTextEvent
=
new
RedisplayTextEvent
(
this
)
;
nsContentUtils
:
:
AddScriptRunner
(
mRedisplayTextEvent
.
get
(
)
)
;
}
return
rv
;
}
void
nsComboboxControlFrame
:
:
HandleRedisplayTextEvent
(
)
{
AutoWeakFrame
weakThis
(
this
)
;
PresContext
(
)
-
>
Document
(
)
-
>
FlushPendingNotifications
(
FlushType
:
:
ContentAndNotify
)
;
if
(
!
weakThis
.
IsAlive
(
)
)
return
;
MOZ_ASSERT
(
!
mInRedisplayText
"
Nested
RedisplayText
"
)
;
mInRedisplayText
=
true
;
mRedisplayTextEvent
.
Forget
(
)
;
ActuallyDisplayText
(
true
)
;
if
(
!
weakThis
.
IsAlive
(
)
)
{
return
;
}
PresShell
(
)
-
>
FrameNeedsReflow
(
mDisplayFrame
IntrinsicDirty
:
:
StyleChange
NS_FRAME_IS_DIRTY
)
;
mInRedisplayText
=
false
;
}
void
nsComboboxControlFrame
:
:
ActuallyDisplayText
(
bool
aNotify
)
{
RefPtr
<
nsTextNode
>
displayContent
=
mDisplayContent
;
if
(
mDisplayedOptionTextOrPreview
.
IsEmpty
(
)
)
{
static
const
char16_t
space
=
0xFEFF
;
displayContent
-
>
SetText
(
&
space
1
aNotify
)
;
}
else
{
displayContent
-
>
SetText
(
mDisplayedOptionTextOrPreview
aNotify
)
;
}
}
int32_t
nsComboboxControlFrame
:
:
GetIndexOfDisplayArea
(
)
{
return
mDisplayedIndex
;
}
NS_IMETHODIMP
nsComboboxControlFrame
:
:
DoneAddingChildren
(
bool
aIsDone
)
{
nsISelectControlFrame
*
listFrame
=
do_QueryFrame
(
mDropdownFrame
)
;
if
(
!
listFrame
)
return
NS_ERROR_FAILURE
;
return
listFrame
-
>
DoneAddingChildren
(
aIsDone
)
;
}
NS_IMETHODIMP
nsComboboxControlFrame
:
:
AddOption
(
int32_t
aIndex
)
{
if
(
aIndex
<
=
mDisplayedIndex
)
{
+
+
mDisplayedIndex
;
}
nsListControlFrame
*
lcf
=
static_cast
<
nsListControlFrame
*
>
(
mDropdownFrame
)
;
return
lcf
-
>
AddOption
(
aIndex
)
;
}
NS_IMETHODIMP
nsComboboxControlFrame
:
:
RemoveOption
(
int32_t
aIndex
)
{
AutoWeakFrame
weakThis
(
this
)
;
if
(
mListControlFrame
-
>
GetNumberOfOptions
(
)
>
0
)
{
if
(
aIndex
<
mDisplayedIndex
)
{
-
-
mDisplayedIndex
;
}
else
if
(
aIndex
=
=
mDisplayedIndex
)
{
mDisplayedIndex
=
0
;
RedisplayText
(
)
;
}
}
else
{
mDisplayedIndex
=
-
1
;
RedisplayText
(
)
;
}
if
(
!
weakThis
.
IsAlive
(
)
)
return
NS_OK
;
nsListControlFrame
*
lcf
=
static_cast
<
nsListControlFrame
*
>
(
mDropdownFrame
)
;
return
lcf
-
>
RemoveOption
(
aIndex
)
;
}
NS_IMETHODIMP_
(
void
)
nsComboboxControlFrame
:
:
OnSetSelectedIndex
(
int32_t
aOldIndex
int32_t
aNewIndex
)
{
nsAutoScriptBlocker
scriptBlocker
;
mDisplayedIndex
=
aNewIndex
;
RedisplayText
(
)
;
NS_ASSERTION
(
mDropdownFrame
"
No
dropdown
frame
!
"
)
;
nsISelectControlFrame
*
listFrame
=
do_QueryFrame
(
mDropdownFrame
)
;
NS_ASSERTION
(
listFrame
"
No
list
frame
!
"
)
;
return
listFrame
-
>
OnSetSelectedIndex
(
aOldIndex
aNewIndex
)
;
}
nsresult
nsComboboxControlFrame
:
:
HandleEvent
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
{
NS_ENSURE_ARG_POINTER
(
aEventStatus
)
;
if
(
nsEventStatus_eConsumeNoDefault
=
=
*
aEventStatus
)
{
return
NS_OK
;
}
EventStates
eventStates
=
mContent
-
>
AsElement
(
)
-
>
State
(
)
;
if
(
eventStates
.
HasState
(
NS_EVENT_STATE_DISABLED
)
)
{
return
NS_OK
;
}
#
if
COMBOBOX_ROLLUP_CONSUME_EVENT
=
=
0
if
(
aEvent
-
>
mMessage
=
=
eMouseDown
)
{
if
(
GetContent
(
)
=
=
mozilla
:
:
widget
:
:
nsAutoRollup
:
:
GetLastRollup
(
)
)
{
*
aEventStatus
=
nsEventStatus_eConsumeNoDefault
;
return
NS_OK
;
}
}
#
endif
if
(
IsContentDisabled
(
)
)
{
return
nsBlockFrame
:
:
HandleEvent
(
aPresContext
aEvent
aEventStatus
)
;
}
return
NS_OK
;
}
nsresult
nsComboboxControlFrame
:
:
SetFormProperty
(
nsAtom
*
aName
const
nsAString
&
aValue
)
{
nsIFormControlFrame
*
fcFrame
=
do_QueryFrame
(
mDropdownFrame
)
;
if
(
!
fcFrame
)
{
return
NS_NOINTERFACE
;
}
return
fcFrame
-
>
SetFormProperty
(
aName
aValue
)
;
}
nsContainerFrame
*
nsComboboxControlFrame
:
:
GetContentInsertionFrame
(
)
{
return
mInRedisplayText
?
mDisplayFrame
:
mDropdownFrame
-
>
GetContentInsertionFrame
(
)
;
}
void
nsComboboxControlFrame
:
:
AppendDirectlyOwnedAnonBoxes
(
nsTArray
<
OwnedAnonBox
>
&
aResult
)
{
aResult
.
AppendElement
(
OwnedAnonBox
(
mDropdownFrame
)
)
;
aResult
.
AppendElement
(
OwnedAnonBox
(
mDisplayFrame
)
)
;
}
nsresult
nsComboboxControlFrame
:
:
CreateAnonymousContent
(
nsTArray
<
ContentInfo
>
&
aElements
)
{
nsNodeInfoManager
*
nimgr
=
mContent
-
>
NodeInfo
(
)
-
>
NodeInfoManager
(
)
;
mDisplayContent
=
new
nsTextNode
(
nimgr
)
;
mDisplayedIndex
=
mListControlFrame
-
>
GetSelectedIndex
(
)
;
if
(
mDisplayedIndex
!
=
-
1
)
{
mListControlFrame
-
>
GetOptionText
(
mDisplayedIndex
mDisplayedOptionTextOrPreview
)
;
}
ActuallyDisplayText
(
false
)
;
if
(
!
aElements
.
AppendElement
(
mDisplayContent
)
)
return
NS_ERROR_OUT_OF_MEMORY
;
mButtonContent
=
mContent
-
>
OwnerDoc
(
)
-
>
CreateHTMLElement
(
nsGkAtoms
:
:
button
)
;
if
(
!
mButtonContent
)
return
NS_ERROR_OUT_OF_MEMORY
;
mButtonListener
=
new
nsComboButtonListener
(
this
)
;
mButtonContent
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
click
"
)
mButtonListener
false
false
)
;
mButtonContent
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
type
NS_LITERAL_STRING
(
"
button
"
)
false
)
;
mButtonContent
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
tabindex
NS_LITERAL_STRING
(
"
-
1
"
)
false
)
;
WritingMode
wm
=
GetWritingMode
(
)
;
if
(
wm
.
IsVertical
(
)
)
{
mButtonContent
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
orientation
wm
.
IsVerticalRL
(
)
?
NS_LITERAL_STRING
(
"
left
"
)
:
NS_LITERAL_STRING
(
"
right
"
)
false
)
;
}
if
(
!
aElements
.
AppendElement
(
mButtonContent
)
)
return
NS_ERROR_OUT_OF_MEMORY
;
return
NS_OK
;
}
void
nsComboboxControlFrame
:
:
AppendAnonymousContentTo
(
nsTArray
<
nsIContent
*
>
&
aElements
uint32_t
aFilter
)
{
if
(
mDisplayContent
)
{
aElements
.
AppendElement
(
mDisplayContent
)
;
}
if
(
mButtonContent
)
{
aElements
.
AppendElement
(
mButtonContent
)
;
}
}
nsIContent
*
nsComboboxControlFrame
:
:
GetDisplayNode
(
)
const
{
return
mDisplayContent
;
}
class
nsComboboxDisplayFrame
final
:
public
nsBlockFrame
{
public
:
NS_DECL_FRAMEARENA_HELPERS
(
nsComboboxDisplayFrame
)
nsComboboxDisplayFrame
(
ComputedStyle
*
aStyle
nsComboboxControlFrame
*
aComboBox
)
:
nsBlockFrame
(
aStyle
aComboBox
-
>
PresContext
(
)
kClassID
)
mComboBox
(
aComboBox
)
{
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
GetFrameName
(
nsAString
&
aResult
)
const
override
{
return
MakeFrameName
(
NS_LITERAL_STRING
(
"
ComboboxDisplay
"
)
aResult
)
;
}
#
endif
virtual
bool
IsFrameOfType
(
uint32_t
aFlags
)
const
override
{
return
nsBlockFrame
:
:
IsFrameOfType
(
aFlags
&
~
(
nsIFrame
:
:
eReplacedContainsBlock
)
)
;
}
virtual
void
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
override
;
virtual
void
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
override
;
protected
:
nsComboboxControlFrame
*
mComboBox
;
}
;
NS_IMPL_FRAMEARENA_HELPERS
(
nsComboboxDisplayFrame
)
void
nsComboboxDisplayFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
ReflowInput
state
(
aReflowInput
)
;
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
LogicalMargin
bp
=
state
.
ComputedLogicalBorderPadding
(
)
;
if
(
state
.
ComputedBSize
(
)
=
=
NS_UNCONSTRAINEDSIZE
)
{
float
inflation
=
nsLayoutUtils
:
:
FontSizeInflationFor
(
mComboBox
)
;
nscoord
lh
=
ReflowInput
:
:
CalcLineHeight
(
mComboBox
-
>
GetContent
(
)
mComboBox
-
>
Style
(
)
aPresContext
NS_UNCONSTRAINEDSIZE
inflation
)
;
if
(
!
mComboBox
-
>
StyleText
(
)
-
>
mLineHeight
.
IsNormal
(
)
)
{
lh
=
std
:
:
max
(
0
lh
-
bp
.
BStartEnd
(
wm
)
)
;
}
state
.
SetComputedBSize
(
lh
)
;
}
nscoord
inlineBp
=
bp
.
IStartEnd
(
wm
)
;
nscoord
computedISize
=
mComboBox
-
>
mDisplayISize
-
inlineBp
;
const
bool
shouldHonorMinISize
=
mComboBox
-
>
StyleDisplay
(
)
-
>
mAppearance
=
=
StyleAppearance
:
:
Menulist
;
if
(
shouldHonorMinISize
)
{
computedISize
=
std
:
:
max
(
state
.
ComputedMinISize
(
)
computedISize
)
;
computedISize
=
std
:
:
min
(
computedISize
mComboBox
-
>
mMaxDisplayISize
-
inlineBp
)
;
}
state
.
SetComputedISize
(
std
:
:
max
(
0
computedISize
)
)
;
nsBlockFrame
:
:
Reflow
(
aPresContext
aDesiredSize
state
aStatus
)
;
aStatus
.
Reset
(
)
;
}
void
nsComboboxDisplayFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
nsDisplayListCollection
set
(
aBuilder
)
;
nsBlockFrame
:
:
BuildDisplayList
(
aBuilder
set
)
;
if
(
mComboBox
-
>
IsThemed
(
)
)
{
set
.
BorderBackground
(
)
-
>
DeleteAll
(
aBuilder
)
;
}
set
.
MoveTo
(
aLists
)
;
}
nsIFrame
*
nsComboboxControlFrame
:
:
CreateFrameForDisplayNode
(
)
{
MOZ_ASSERT
(
mDisplayContent
)
;
mozilla
:
:
PresShell
*
presShell
=
PresShell
(
)
;
ServoStyleSet
*
styleSet
=
presShell
-
>
StyleSet
(
)
;
RefPtr
<
ComputedStyle
>
computedStyle
;
computedStyle
=
styleSet
-
>
ResolveInheritingAnonymousBoxStyle
(
PseudoStyleType
:
:
mozDisplayComboboxControlFrame
mComputedStyle
)
;
RefPtr
<
ComputedStyle
>
textComputedStyle
;
textComputedStyle
=
styleSet
-
>
ResolveStyleForText
(
mDisplayContent
mComputedStyle
)
;
mDisplayFrame
=
new
(
presShell
)
nsComboboxDisplayFrame
(
computedStyle
this
)
;
mDisplayFrame
-
>
Init
(
mContent
this
nullptr
)
;
nsIFrame
*
textFrame
=
NS_NewTextFrame
(
presShell
textComputedStyle
)
;
textFrame
-
>
Init
(
mDisplayContent
mDisplayFrame
nullptr
)
;
mDisplayContent
-
>
SetPrimaryFrame
(
textFrame
)
;
nsFrameList
textList
(
textFrame
textFrame
)
;
mDisplayFrame
-
>
SetInitialChildList
(
kPrincipalList
textList
)
;
return
mDisplayFrame
;
}
void
nsComboboxControlFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
{
if
(
sFocused
=
=
this
)
{
sFocused
=
nullptr
;
}
mRedisplayTextEvent
.
Revoke
(
)
;
nsCheckboxRadioFrame
:
:
RegUnRegAccessKey
(
static_cast
<
nsIFrame
*
>
(
this
)
false
)
;
if
(
mDroppedDown
)
{
MOZ_ASSERT
(
mDropdownFrame
"
mDroppedDown
without
frame
"
)
;
nsView
*
view
=
mDropdownFrame
-
>
GetView
(
)
;
MOZ_ASSERT
(
view
)
;
nsIWidget
*
widget
=
view
-
>
GetWidget
(
)
;
if
(
widget
)
{
widget
-
>
CaptureRollupEvents
(
this
false
)
;
}
}
mPopupFrames
.
DestroyFramesFrom
(
aDestructRoot
aPostDestroyData
)
;
aPostDestroyData
.
AddAnonymousContent
(
mDisplayContent
.
forget
(
)
)
;
aPostDestroyData
.
AddAnonymousContent
(
mButtonContent
.
forget
(
)
)
;
nsBlockFrame
:
:
DestroyFrom
(
aDestructRoot
aPostDestroyData
)
;
}
const
nsFrameList
&
nsComboboxControlFrame
:
:
GetChildList
(
ChildListID
aListID
)
const
{
if
(
kSelectPopupList
=
=
aListID
)
{
return
mPopupFrames
;
}
return
nsBlockFrame
:
:
GetChildList
(
aListID
)
;
}
void
nsComboboxControlFrame
:
:
GetChildLists
(
nsTArray
<
ChildList
>
*
aLists
)
const
{
nsBlockFrame
:
:
GetChildLists
(
aLists
)
;
mPopupFrames
.
AppendIfNonempty
(
aLists
kSelectPopupList
)
;
}
void
nsComboboxControlFrame
:
:
SetInitialChildList
(
ChildListID
aListID
nsFrameList
&
aChildList
)
{
#
ifdef
DEBUG
for
(
nsIFrame
*
f
:
aChildList
)
{
MOZ_ASSERT
(
f
-
>
GetParent
(
)
=
=
this
"
Unexpected
parent
"
)
;
}
#
endif
if
(
kSelectPopupList
=
=
aListID
)
{
mPopupFrames
.
SetFrames
(
aChildList
)
;
}
else
{
for
(
nsFrameList
:
:
Enumerator
e
(
aChildList
)
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
)
{
nsCOMPtr
<
nsIFormControl
>
formControl
=
do_QueryInterface
(
e
.
get
(
)
-
>
GetContent
(
)
)
;
if
(
formControl
&
&
formControl
-
>
ControlType
(
)
=
=
NS_FORM_BUTTON_BUTTON
)
{
mButtonFrame
=
e
.
get
(
)
;
break
;
}
}
NS_ASSERTION
(
mButtonFrame
"
missing
button
frame
in
initial
child
list
"
)
;
nsBlockFrame
:
:
SetInitialChildList
(
aListID
aChildList
)
;
}
}
bool
nsComboboxControlFrame
:
:
Rollup
(
uint32_t
aCount
bool
aFlush
const
nsIntPoint
*
pos
nsIContent
*
*
aLastRolledUp
)
{
if
(
aLastRolledUp
)
{
*
aLastRolledUp
=
nullptr
;
}
if
(
!
mDroppedDown
)
{
return
false
;
}
bool
consume
=
!
!
COMBOBOX_ROLLUP_CONSUME_EVENT
;
AutoWeakFrame
weakFrame
(
this
)
;
mListControlFrame
-
>
AboutToRollup
(
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
consume
;
}
ShowDropDown
(
false
)
;
if
(
weakFrame
.
IsAlive
(
)
)
{
mListControlFrame
-
>
CaptureMouseEvents
(
false
)
;
}
if
(
aFlush
&
&
weakFrame
.
IsAlive
(
)
)
{
RefPtr
<
nsViewManager
>
viewManager
=
mDropdownFrame
-
>
GetView
(
)
-
>
GetViewManager
(
)
;
viewManager
-
>
UpdateWidgetGeometry
(
)
;
}
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
consume
;
}
if
(
aLastRolledUp
)
{
*
aLastRolledUp
=
GetContent
(
)
;
}
return
consume
;
}
nsIWidget
*
nsComboboxControlFrame
:
:
GetRollupWidget
(
)
{
nsView
*
view
=
mDropdownFrame
-
>
GetView
(
)
;
MOZ_ASSERT
(
view
)
;
return
view
-
>
GetWidget
(
)
;
}
void
nsComboboxControlFrame
:
:
RollupFromList
(
)
{
if
(
ShowList
(
false
)
)
mListControlFrame
-
>
CaptureMouseEvents
(
false
)
;
}
int32_t
nsComboboxControlFrame
:
:
UpdateRecentIndex
(
int32_t
aIndex
)
{
int32_t
index
=
mRecentSelectedIndex
;
if
(
mRecentSelectedIndex
=
=
NS_SKIP_NOTIFY_INDEX
|
|
aIndex
=
=
NS_SKIP_NOTIFY_INDEX
)
mRecentSelectedIndex
=
aIndex
;
return
index
;
}
class
nsDisplayComboboxFocus
:
public
nsPaintedDisplayItem
{
public
:
nsDisplayComboboxFocus
(
nsDisplayListBuilder
*
aBuilder
nsComboboxControlFrame
*
aFrame
)
:
nsPaintedDisplayItem
(
aBuilder
aFrame
)
{
MOZ_COUNT_CTOR
(
nsDisplayComboboxFocus
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayComboboxFocus
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayComboboxFocus
)
;
}
#
endif
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
;
NS_DISPLAY_DECL_NAME
(
"
ComboboxFocus
"
TYPE_COMBOBOX_FOCUS
)
}
;
void
nsDisplayComboboxFocus
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
static_cast
<
nsComboboxControlFrame
*
>
(
mFrame
)
-
>
PaintFocus
(
*
aCtx
-
>
GetDrawTarget
(
)
ToReferenceFrame
(
)
)
;
}
void
nsComboboxControlFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
if
(
aBuilder
-
>
IsForEventDelivery
(
)
)
{
DisplayBorderBackgroundOutline
(
aBuilder
aLists
)
;
}
else
{
nsBlockFrame
:
:
BuildDisplayList
(
aBuilder
aLists
)
;
}
if
(
Document
*
doc
=
mContent
-
>
GetComposedDoc
(
)
)
{
nsPIDOMWindowOuter
*
window
=
doc
-
>
GetWindow
(
)
;
if
(
window
&
&
window
-
>
ShouldShowFocusRing
(
)
)
{
nsPresContext
*
presContext
=
PresContext
(
)
;
const
nsStyleDisplay
*
disp
=
StyleDisplay
(
)
;
if
(
(
!
IsThemed
(
disp
)
|
|
!
presContext
-
>
GetTheme
(
)
-
>
ThemeDrawsFocusForWidget
(
disp
-
>
mAppearance
)
)
&
&
mDisplayFrame
&
&
IsVisibleForPainting
(
)
)
{
aLists
.
Content
(
)
-
>
AppendNewToTop
<
nsDisplayComboboxFocus
>
(
aBuilder
this
)
;
}
}
}
DisplaySelectionOverlay
(
aBuilder
aLists
.
Content
(
)
)
;
}
void
nsComboboxControlFrame
:
:
PaintFocus
(
DrawTarget
&
aDrawTarget
nsPoint
aPt
)
{
EventStates
eventStates
=
mContent
-
>
AsElement
(
)
-
>
State
(
)
;
if
(
eventStates
.
HasState
(
NS_EVENT_STATE_DISABLED
)
|
|
sFocused
!
=
this
)
return
;
int32_t
appUnitsPerDevPixel
=
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
nsRect
clipRect
=
mDisplayFrame
-
>
GetRect
(
)
+
aPt
;
aDrawTarget
.
PushClipRect
(
NSRectToSnappedRect
(
clipRect
appUnitsPerDevPixel
aDrawTarget
)
)
;
StrokeOptions
strokeOptions
;
nsLayoutUtils
:
:
InitDashPattern
(
strokeOptions
StyleBorderStyle
:
:
Dotted
)
;
ColorPattern
color
(
ToDeviceColor
(
StyleText
(
)
-
>
mColor
)
)
;
nscoord
onePixel
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
1
)
;
clipRect
.
width
-
=
onePixel
;
clipRect
.
height
-
=
onePixel
;
Rect
r
=
ToRect
(
nsLayoutUtils
:
:
RectToGfxRect
(
clipRect
appUnitsPerDevPixel
)
)
;
StrokeSnappedEdgesOfRect
(
r
aDrawTarget
color
strokeOptions
)
;
aDrawTarget
.
PopClip
(
)
;
}
NS_IMETHODIMP
nsComboboxControlFrame
:
:
OnOptionSelected
(
int32_t
aIndex
bool
aSelected
)
{
if
(
mDroppedDown
)
{
nsISelectControlFrame
*
selectFrame
=
do_QueryFrame
(
mListControlFrame
)
;
if
(
selectFrame
)
{
selectFrame
-
>
OnOptionSelected
(
aIndex
aSelected
)
;
}
}
else
{
if
(
aSelected
)
{
nsAutoScriptBlocker
blocker
;
mDisplayedIndex
=
aIndex
;
RedisplayText
(
)
;
}
else
{
AutoWeakFrame
weakFrame
(
this
)
;
RedisplaySelectedText
(
)
;
if
(
weakFrame
.
IsAlive
(
)
)
{
FireValueChangeEvent
(
)
;
}
}
}
return
NS_OK
;
}
void
nsComboboxControlFrame
:
:
FireValueChangeEvent
(
)
{
nsContentUtils
:
:
AddScriptRunner
(
new
AsyncEventDispatcher
(
mContent
NS_LITERAL_STRING
(
"
ValueChange
"
)
CanBubble
:
:
eYes
ChromeOnlyDispatch
:
:
eNo
)
)
;
}
void
nsComboboxControlFrame
:
:
OnContentReset
(
)
{
if
(
mListControlFrame
)
{
mListControlFrame
-
>
OnContentReset
(
)
;
}
}
UniquePtr
<
PresState
>
nsComboboxControlFrame
:
:
SaveState
(
)
{
UniquePtr
<
PresState
>
state
=
NewPresState
(
)
;
state
-
>
droppedDown
(
)
=
mDroppedDown
;
return
state
;
}
NS_IMETHODIMP
nsComboboxControlFrame
:
:
RestoreState
(
PresState
*
aState
)
{
if
(
!
aState
)
{
return
NS_ERROR_FAILURE
;
}
ShowList
(
aState
-
>
droppedDown
(
)
)
;
return
NS_OK
;
}
void
nsComboboxControlFrame
:
:
GenerateStateKey
(
nsIContent
*
aContent
Document
*
aDocument
nsACString
&
aKey
)
{
nsContentUtils
:
:
GenerateStateKey
(
aContent
aDocument
aKey
)
;
if
(
aKey
.
IsEmpty
(
)
)
{
return
;
}
aKey
.
AppendLiteral
(
"
CCF
"
)
;
}
bool
nsComboboxControlFrame
:
:
ToolkitHasNativePopup
(
)
{
#
ifdef
MOZ_USE_NATIVE_POPUP_WINDOWS
return
true
;
#
else
return
false
;
#
endif
}
