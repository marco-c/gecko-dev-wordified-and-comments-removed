#
include
"
nsColorControlFrame
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
mozilla
/
dom
/
HTMLInputElement
.
h
"
#
include
"
nsContentCreatorFunctions
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIFormControl
.
h
"
using
namespace
mozilla
;
using
mozilla
:
:
dom
:
:
CallerType
;
using
mozilla
:
:
dom
:
:
HTMLInputElement
;
nsColorControlFrame
:
:
nsColorControlFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
:
ButtonControlFrame
(
aStyle
aPresContext
kClassID
)
{
}
nsIFrame
*
NS_NewColorControlFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsColorControlFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsColorControlFrame
)
NS_QUERYFRAME_HEAD
(
nsColorControlFrame
)
NS_QUERYFRAME_ENTRY
(
nsColorControlFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
ButtonControlFrame
)
void
nsColorControlFrame
:
:
Destroy
(
DestroyContext
&
aContext
)
{
aContext
.
AddAnonymousContent
(
mColorContent
.
forget
(
)
)
;
ButtonControlFrame
:
:
Destroy
(
aContext
)
;
}
nsresult
nsColorControlFrame
:
:
CreateAnonymousContent
(
nsTArray
<
ContentInfo
>
&
aElements
)
{
mColorContent
=
mContent
-
>
OwnerDoc
(
)
-
>
CreateHTMLElement
(
nsGkAtoms
:
:
div
)
;
mColorContent
-
>
SetPseudoElementType
(
PseudoStyleType
:
:
mozColorSwatch
)
;
mColorContent
-
>
SetIsNativeAnonymousRoot
(
)
;
UpdateColor
(
)
;
aElements
.
AppendElement
(
mColorContent
)
;
return
NS_OK
;
}
void
nsColorControlFrame
:
:
AppendAnonymousContentTo
(
nsTArray
<
nsIContent
*
>
&
aElements
uint32_t
aFilter
)
{
if
(
mColorContent
)
{
aElements
.
AppendElement
(
mColorContent
)
;
}
}
void
nsColorControlFrame
:
:
UpdateColor
(
)
{
nsAutoString
color
;
auto
*
elt
=
HTMLInputElement
:
:
FromNode
(
mContent
)
;
elt
-
>
GetValue
(
color
CallerType
:
:
System
)
;
if
(
color
.
IsEmpty
(
)
)
{
MOZ_ASSERT
(
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
"
Content
node
'
s
GetValue
(
)
should
return
a
valid
color
string
"
"
by
the
time
we
'
ve
been
reflowed
(
the
default
color
in
case
"
"
no
valid
color
is
set
)
"
)
;
return
;
}
mColorContent
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
style
u
"
background
-
color
:
"
_ns
+
color
true
)
;
}
nsresult
nsColorControlFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
AttrModType
aModType
)
{
NS_ASSERTION
(
mColorContent
"
The
color
div
must
exist
"
)
;
if
(
nsIFormControl
:
:
FromNode
(
GetContent
(
)
)
-
>
ControlType
(
)
=
=
FormControlType
:
:
InputColor
&
&
aNameSpaceID
=
=
kNameSpaceID_None
&
&
nsGkAtoms
:
:
value
=
=
aAttribute
)
{
UpdateColor
(
)
;
}
return
ButtonControlFrame
:
:
AttributeChanged
(
aNameSpaceID
aAttribute
aModType
)
;
}
