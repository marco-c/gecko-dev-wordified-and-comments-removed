#
include
"
nsColorControlFrame
.
h
"
#
include
"
nsContentCreatorFunctions
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsCheckboxRadioFrame
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIFormControl
.
h
"
#
include
"
mozilla
/
dom
/
HTMLInputElement
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
using
namespace
mozilla
;
using
mozilla
:
:
dom
:
:
CallerType
;
using
mozilla
:
:
dom
:
:
Document
;
using
mozilla
:
:
dom
:
:
Element
;
using
mozilla
:
:
dom
:
:
HTMLInputElement
;
nsColorControlFrame
:
:
nsColorControlFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
:
nsHTMLButtonControlFrame
(
aStyle
aPresContext
kClassID
)
{
}
nsIFrame
*
NS_NewColorControlFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsColorControlFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsColorControlFrame
)
NS_QUERYFRAME_HEAD
(
nsColorControlFrame
)
NS_QUERYFRAME_ENTRY
(
nsColorControlFrame
)
NS_QUERYFRAME_ENTRY
(
nsIAnonymousContentCreator
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsHTMLButtonControlFrame
)
void
nsColorControlFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
{
nsCheckboxRadioFrame
:
:
RegUnRegAccessKey
(
static_cast
<
nsIFrame
*
>
(
this
)
false
)
;
aPostDestroyData
.
AddAnonymousContent
(
mColorContent
.
forget
(
)
)
;
nsHTMLButtonControlFrame
:
:
DestroyFrom
(
aDestructRoot
aPostDestroyData
)
;
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
nsColorControlFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
NS_LITERAL_STRING
(
"
ColorControl
"
)
aResult
)
;
}
#
endif
nsresult
nsColorControlFrame
:
:
CreateAnonymousContent
(
nsTArray
<
ContentInfo
>
&
aElements
)
{
RefPtr
<
Document
>
doc
=
mContent
-
>
GetComposedDoc
(
)
;
mColorContent
=
doc
-
>
CreateHTMLElement
(
nsGkAtoms
:
:
div
)
;
mColorContent
-
>
SetPseudoElementType
(
PseudoStyleType
:
:
mozColorSwatch
)
;
mColorContent
-
>
SetIsNativeAnonymousRoot
(
)
;
nsresult
rv
=
UpdateColor
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
!
aElements
.
AppendElement
(
mColorContent
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
return
NS_OK
;
}
void
nsColorControlFrame
:
:
AppendAnonymousContentTo
(
nsTArray
<
nsIContent
*
>
&
aElements
uint32_t
aFilter
)
{
if
(
mColorContent
)
{
aElements
.
AppendElement
(
mColorContent
)
;
}
}
nsresult
nsColorControlFrame
:
:
UpdateColor
(
)
{
nsAutoString
color
;
HTMLInputElement
*
elt
=
HTMLInputElement
:
:
FromNode
(
mContent
)
;
elt
-
>
GetValue
(
color
CallerType
:
:
System
)
;
if
(
color
.
IsEmpty
(
)
)
{
MOZ_ASSERT
(
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
"
Content
node
'
s
GetValue
(
)
should
return
a
valid
color
string
"
"
by
the
time
we
'
ve
been
reflowed
(
the
default
color
in
case
"
"
no
valid
color
is
set
)
"
)
;
return
NS_OK
;
}
return
mColorContent
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
style
NS_LITERAL_STRING
(
"
background
-
color
:
"
)
+
color
true
)
;
}
nsresult
nsColorControlFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
NS_ASSERTION
(
mColorContent
"
The
color
div
must
exist
"
)
;
nsCOMPtr
<
nsIFormControl
>
fctrl
=
do_QueryInterface
(
GetContent
(
)
)
;
if
(
fctrl
-
>
ControlType
(
)
=
=
NS_FORM_INPUT_COLOR
&
&
aNameSpaceID
=
=
kNameSpaceID_None
&
&
nsGkAtoms
:
:
value
=
=
aAttribute
)
{
UpdateColor
(
)
;
}
return
nsHTMLButtonControlFrame
:
:
AttributeChanged
(
aNameSpaceID
aAttribute
aModType
)
;
}
nsContainerFrame
*
nsColorControlFrame
:
:
GetContentInsertionFrame
(
)
{
return
this
;
}
