#
include
"
nsCheckboxRadioFrame
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
mozilla
/
dom
/
HTMLInputElement
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
nsDeviceContext
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsStyleConsts
.
h
"
using
namespace
mozilla
;
using
mozilla
:
:
dom
:
:
Element
;
using
mozilla
:
:
dom
:
:
HTMLInputElement
;
nsCheckboxRadioFrame
*
NS_NewCheckboxRadioFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsCheckboxRadioFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
nsCheckboxRadioFrame
:
:
nsCheckboxRadioFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
:
nsAtomicContainerFrame
(
aStyle
aPresContext
kClassID
)
{
}
nsCheckboxRadioFrame
:
:
~
nsCheckboxRadioFrame
(
)
=
default
;
NS_IMPL_FRAMEARENA_HELPERS
(
nsCheckboxRadioFrame
)
NS_QUERYFRAME_HEAD
(
nsCheckboxRadioFrame
)
NS_QUERYFRAME_ENTRY
(
nsIFormControlFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsAtomicContainerFrame
)
nscoord
nsCheckboxRadioFrame
:
:
GetMinISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
result
;
DISPLAY_MIN_INLINE_SIZE
(
this
result
)
;
result
=
StyleDisplay
(
)
-
>
HasAppearance
(
)
?
DefaultSize
(
)
:
0
;
return
result
;
}
nscoord
nsCheckboxRadioFrame
:
:
GetPrefISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
result
;
DISPLAY_PREF_INLINE_SIZE
(
this
result
)
;
result
=
StyleDisplay
(
)
-
>
HasAppearance
(
)
?
DefaultSize
(
)
:
0
;
return
result
;
}
LogicalSize
nsCheckboxRadioFrame
:
:
ComputeAutoSize
(
gfxContext
*
aRC
WritingMode
aWM
const
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
LogicalSize
&
aMargin
const
LogicalSize
&
aBorderPadding
const
StyleSizeOverrides
&
aSizeOverrides
ComputeSizeFlags
aFlags
)
{
LogicalSize
size
(
aWM
0
0
)
;
if
(
!
StyleDisplay
(
)
-
>
HasAppearance
(
)
)
{
return
size
;
}
size
=
nsAtomicContainerFrame
:
:
ComputeAutoSize
(
aRC
aWM
aCBSize
aAvailableISize
aMargin
aBorderPadding
aSizeOverrides
aFlags
)
;
size
.
BSize
(
aWM
)
=
DefaultSize
(
)
;
return
size
;
}
nscoord
nsCheckboxRadioFrame
:
:
GetLogicalBaseline
(
WritingMode
aWritingMode
)
const
{
NS_ASSERTION
(
!
IsSubtreeDirty
(
)
"
frame
must
not
be
dirty
"
)
;
if
(
!
StyleDisplay
(
)
-
>
HasAppearance
(
)
)
{
return
nsAtomicContainerFrame
:
:
GetLogicalBaseline
(
aWritingMode
)
;
}
return
aWritingMode
.
IsLineInverted
(
)
?
GetLogicalUsedBorderAndPadding
(
aWritingMode
)
.
BStart
(
aWritingMode
)
:
BSize
(
aWritingMode
)
-
GetLogicalUsedBorderAndPadding
(
aWritingMode
)
.
BEnd
(
aWritingMode
)
;
}
void
nsCheckboxRadioFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsCheckboxRadioFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aDesiredSize
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
NS_FRAME_TRACE
(
NS_FRAME_TRACE_CALLS
(
"
enter
nsCheckboxRadioFrame
:
:
Reflow
:
aMaxSize
=
%
d
%
d
"
aReflowInput
.
AvailableWidth
(
)
aReflowInput
.
AvailableHeight
(
)
)
)
;
const
auto
wm
=
aReflowInput
.
GetWritingMode
(
)
;
aDesiredSize
.
SetSize
(
wm
aReflowInput
.
ComputedSizeWithBorderPadding
(
wm
)
)
;
if
(
nsLayoutUtils
:
:
FontSizeInflationEnabled
(
aPresContext
)
)
{
float
inflation
=
nsLayoutUtils
:
:
FontSizeInflationFor
(
this
)
;
aDesiredSize
.
Width
(
)
*
=
inflation
;
aDesiredSize
.
Height
(
)
*
=
inflation
;
}
NS_FRAME_TRACE
(
NS_FRAME_TRACE_CALLS
(
"
exit
nsCheckboxRadioFrame
:
:
Reflow
:
size
=
%
d
%
d
"
aDesiredSize
.
Width
(
)
aDesiredSize
.
Height
(
)
)
)
;
NS_FRAME_SET_TRUNCATION
(
aStatus
aReflowInput
aDesiredSize
)
;
aDesiredSize
.
SetOverflowAreasToDesiredBounds
(
)
;
FinishAndStoreOverflow
(
&
aDesiredSize
)
;
}
void
nsCheckboxRadioFrame
:
:
SetFocus
(
bool
aOn
bool
aRepaint
)
{
}
nsresult
nsCheckboxRadioFrame
:
:
HandleEvent
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
{
if
(
IsContentDisabled
(
)
)
{
return
nsIFrame
:
:
HandleEvent
(
aPresContext
aEvent
aEventStatus
)
;
}
return
NS_OK
;
}
void
nsCheckboxRadioFrame
:
:
GetCurrentCheckState
(
bool
*
aState
)
{
HTMLInputElement
*
inputElement
=
HTMLInputElement
:
:
FromNode
(
mContent
)
;
if
(
inputElement
)
{
*
aState
=
inputElement
-
>
Checked
(
)
;
}
}
nsresult
nsCheckboxRadioFrame
:
:
SetFormProperty
(
nsAtom
*
aName
const
nsAString
&
aValue
)
{
return
NS_OK
;
}
nsRect
nsCheckboxRadioFrame
:
:
GetUsableScreenRect
(
nsPresContext
*
aPresContext
)
{
nsRect
screen
;
nsDeviceContext
*
context
=
aPresContext
-
>
DeviceContext
(
)
;
int32_t
dropdownCanOverlapOSBar
=
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
IntID
:
:
MenusCanOverlapOSBar
0
)
;
if
(
dropdownCanOverlapOSBar
)
context
-
>
GetRect
(
screen
)
;
else
context
-
>
GetClientRect
(
screen
)
;
return
screen
;
}
