#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsFontMetrics
.
h
"
#
include
"
nsTextControlFrame
.
h
"
#
include
"
nsIEditor
.
h
"
#
include
"
nsCaret
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
<
algorithm
>
#
include
"
nsRange
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
nsILayoutHistoryState
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
PresState
.
h
"
#
include
"
mozilla
/
TextEditor
.
h
"
#
include
"
nsAttrValueInlines
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsTextNode
.
h
"
#
include
"
mozilla
/
dom
/
HTMLInputElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLTextAreaElement
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
mozilla
/
StaticPrefs_layout
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
define
DEFAULT_COLUMN_WIDTH
20
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
nsIFrame
*
NS_NewTextControlFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsTextControlFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsTextControlFrame
)
NS_QUERYFRAME_HEAD
(
nsTextControlFrame
)
NS_QUERYFRAME_ENTRY
(
nsTextControlFrame
)
NS_QUERYFRAME_ENTRY
(
nsIFormControlFrame
)
NS_QUERYFRAME_ENTRY
(
nsIAnonymousContentCreator
)
NS_QUERYFRAME_ENTRY
(
nsITextControlFrame
)
NS_QUERYFRAME_ENTRY
(
nsIStatefulFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsContainerFrame
)
#
ifdef
ACCESSIBILITY
a11y
:
:
AccType
nsTextControlFrame
:
:
AccessibleType
(
)
{
return
a11y
:
:
eHTMLTextFieldType
;
}
#
endif
#
ifdef
DEBUG
class
EditorInitializerEntryTracker
{
public
:
explicit
EditorInitializerEntryTracker
(
nsTextControlFrame
&
frame
)
:
mFrame
(
frame
)
mFirstEntry
(
false
)
{
if
(
!
mFrame
.
mInEditorInitialization
)
{
mFrame
.
mInEditorInitialization
=
true
;
mFirstEntry
=
true
;
}
}
~
EditorInitializerEntryTracker
(
)
{
if
(
mFirstEntry
)
{
mFrame
.
mInEditorInitialization
=
false
;
}
}
bool
EnteredMoreThanOnce
(
)
const
{
return
!
mFirstEntry
;
}
private
:
nsTextControlFrame
&
mFrame
;
bool
mFirstEntry
;
}
;
#
endif
class
nsTextControlFrame
:
:
nsAnonDivObserver
final
:
public
nsStubMutationObserver
{
public
:
explicit
nsAnonDivObserver
(
nsTextControlFrame
&
aFrame
)
:
mFrame
(
aFrame
)
{
}
NS_DECL_ISUPPORTS
NS_DECL_NSIMUTATIONOBSERVER_CHARACTERDATACHANGED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTAPPENDED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTINSERTED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTREMOVED
private
:
~
nsAnonDivObserver
(
)
=
default
;
nsTextControlFrame
&
mFrame
;
}
;
nsTextControlFrame
:
:
nsTextControlFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
nsIFrame
:
:
ClassID
aClassID
)
:
nsContainerFrame
(
aStyle
aPresContext
aClassID
)
{
}
nsTextControlFrame
:
:
~
nsTextControlFrame
(
)
=
default
;
nsIScrollableFrame
*
nsTextControlFrame
:
:
GetScrollTargetFrame
(
)
const
{
if
(
!
mRootNode
)
{
return
nullptr
;
}
return
do_QueryFrame
(
mRootNode
-
>
GetPrimaryFrame
(
)
)
;
}
void
nsTextControlFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
{
RemoveProperty
(
TextControlInitializer
(
)
)
;
RefPtr
textControlElement
=
TextControlElement
:
:
FromNode
(
GetContent
(
)
)
;
MOZ_ASSERT
(
textControlElement
)
;
if
(
mMutationObserver
)
{
textControlElement
-
>
UnbindFromFrame
(
this
)
;
mRootNode
-
>
RemoveMutationObserver
(
mMutationObserver
)
;
mMutationObserver
=
nullptr
;
}
if
(
nsCOMPtr
<
nsIDragSession
>
dragSession
=
nsContentUtils
:
:
GetDragSession
(
)
)
{
if
(
dragSession
-
>
IsDraggingTextInTextControl
(
)
&
&
mRootNode
&
&
mRootNode
-
>
GetFirstChild
(
)
)
{
nsCOMPtr
<
nsINode
>
sourceNode
;
if
(
NS_SUCCEEDED
(
dragSession
-
>
GetSourceNode
(
getter_AddRefs
(
sourceNode
)
)
)
&
&
mRootNode
-
>
Contains
(
sourceNode
)
)
{
MOZ_ASSERT
(
sourceNode
-
>
IsText
(
)
)
;
dragSession
-
>
UpdateSource
(
textControlElement
nullptr
)
;
}
}
}
else
if
(
textControlElement
-
>
GetPresContext
(
Element
:
:
eForComposedDoc
)
)
{
textControlElement
-
>
GetPresContext
(
Element
:
:
eForComposedDoc
)
-
>
EventStateManager
(
)
-
>
TextControlRootWillBeRemoved
(
*
textControlElement
)
;
}
aPostDestroyData
.
AddAnonymousContent
(
mRootNode
.
forget
(
)
)
;
aPostDestroyData
.
AddAnonymousContent
(
mPlaceholderDiv
.
forget
(
)
)
;
aPostDestroyData
.
AddAnonymousContent
(
mPreviewDiv
.
forget
(
)
)
;
aPostDestroyData
.
AddAnonymousContent
(
mRevealButton
.
forget
(
)
)
;
nsContainerFrame
:
:
DestroyFrom
(
aDestructRoot
aPostDestroyData
)
;
}
LogicalSize
nsTextControlFrame
:
:
CalcIntrinsicSize
(
gfxContext
*
aRenderingContext
WritingMode
aWM
float
aFontSizeInflation
)
const
{
LogicalSize
intrinsicSize
(
aWM
)
;
RefPtr
<
nsFontMetrics
>
fontMet
=
nsLayoutUtils
:
:
GetFontMetricsForFrame
(
this
aFontSizeInflation
)
;
nscoord
lineHeight
=
ReflowInput
:
:
CalcLineHeight
(
*
Style
(
)
PresContext
(
)
GetContent
(
)
NS_UNCONSTRAINEDSIZE
aFontSizeInflation
)
;
nscoord
charWidth
=
fontMet
-
>
AveCharWidth
(
)
;
nscoord
charMaxAdvance
=
fontMet
-
>
MaxAdvance
(
)
;
int32_t
cols
=
GetCols
(
)
;
intrinsicSize
.
ISize
(
aWM
)
=
cols
*
charWidth
;
if
(
mozilla
:
:
Abs
(
charWidth
-
charMaxAdvance
)
>
(
unsigned
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
1
)
)
{
nscoord
internalPadding
=
std
:
:
max
(
0
charMaxAdvance
-
nsPresContext
:
:
CSSPixelsToAppUnits
(
4
)
)
;
nscoord
t
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
1
)
;
nscoord
rest
=
internalPadding
%
t
;
if
(
rest
<
t
-
rest
)
{
internalPadding
-
=
rest
;
}
else
{
internalPadding
+
=
t
-
rest
;
}
intrinsicSize
.
ISize
(
aWM
)
+
=
internalPadding
;
}
else
{
if
(
PresContext
(
)
-
>
CompatibilityMode
(
)
=
=
eCompatibility_FullStandards
)
{
intrinsicSize
.
ISize
(
aWM
)
+
=
1
;
}
}
{
const
StyleLength
&
letterSpacing
=
StyleText
(
)
-
>
mLetterSpacing
;
if
(
!
letterSpacing
.
IsZero
(
)
)
{
intrinsicSize
.
ISize
(
aWM
)
+
=
cols
*
letterSpacing
.
ToAppUnits
(
)
;
}
}
intrinsicSize
.
BSize
(
aWM
)
=
lineHeight
*
GetRows
(
)
;
if
(
IsTextArea
(
)
)
{
nsIScrollableFrame
*
scrollableFrame
=
GetScrollTargetFrame
(
)
;
NS_ASSERTION
(
scrollableFrame
"
Child
must
be
scrollable
"
)
;
if
(
scrollableFrame
)
{
LogicalMargin
scrollbarSizes
(
aWM
scrollableFrame
-
>
GetDesiredScrollbarSizes
(
)
)
;
intrinsicSize
.
ISize
(
aWM
)
+
=
scrollbarSizes
.
IStartEnd
(
aWM
)
;
intrinsicSize
.
BSize
(
aWM
)
+
=
scrollbarSizes
.
BStartEnd
(
aWM
)
;
}
}
return
intrinsicSize
;
}
nsresult
nsTextControlFrame
:
:
EnsureEditorInitialized
(
)
{
if
(
mEditorHasBeenInitialized
)
return
NS_OK
;
Document
*
doc
=
mContent
-
>
GetComposedDoc
(
)
;
NS_ENSURE_TRUE
(
doc
NS_ERROR_FAILURE
)
;
AutoWeakFrame
weakFrame
(
this
)
;
doc
-
>
FlushPendingNotifications
(
FlushType
:
:
ContentAndNotify
)
;
NS_ENSURE_TRUE
(
weakFrame
.
IsAlive
(
)
NS_ERROR_FAILURE
)
;
{
RefPtr
textControlElement
=
TextControlElement
:
:
FromNode
(
GetContent
(
)
)
;
MOZ_ASSERT
(
textControlElement
)
;
AutoHideSelectionChanges
hideSelectionChanges
(
textControlElement
-
>
GetConstFrameSelection
(
)
)
;
nsAutoScriptBlocker
scriptBlocker
;
mozilla
:
:
dom
:
:
AutoNoJSAPI
nojsapi
;
class
EnsureSetFocus
{
public
:
explicit
EnsureSetFocus
(
nsTextControlFrame
*
aFrame
)
:
mFrame
(
aFrame
)
{
}
~
EnsureSetFocus
(
)
{
if
(
nsContentUtils
:
:
IsFocusedContent
(
mFrame
-
>
GetContent
(
)
)
)
mFrame
-
>
SetFocus
(
true
false
)
;
}
private
:
nsTextControlFrame
*
mFrame
;
}
;
EnsureSetFocus
makeSureSetFocusHappens
(
this
)
;
#
ifdef
DEBUG
const
EditorInitializerEntryTracker
tracker
(
*
this
)
;
NS_ASSERTION
(
!
tracker
.
EnteredMoreThanOnce
(
)
"
EnsureEditorInitialized
has
been
called
while
a
previous
"
"
call
was
in
progress
"
)
;
#
endif
nsresult
rv
=
textControlElement
-
>
CreateEditor
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
weakFrame
.
IsAlive
(
)
)
;
mEditorHasBeenInitialized
=
true
;
if
(
weakFrame
.
IsAlive
(
)
)
{
uint32_t
position
=
0
;
if
(
textControlElement
-
>
ValueChanged
(
)
)
{
nsAutoString
val
;
textControlElement
-
>
GetTextEditorValue
(
val
true
)
;
position
=
val
.
Length
(
)
;
}
SetSelectionEndPoints
(
position
position
)
;
}
}
NS_ENSURE_STATE
(
weakFrame
.
IsAlive
(
)
)
;
return
NS_OK
;
}
already_AddRefed
<
Element
>
nsTextControlFrame
:
:
MakeAnonElement
(
PseudoStyleType
aPseudoType
Element
*
aParent
nsAtom
*
aTag
)
const
{
MOZ_ASSERT
(
aPseudoType
!
=
PseudoStyleType
:
:
NotPseudo
)
;
Document
*
doc
=
PresContext
(
)
-
>
Document
(
)
;
RefPtr
<
Element
>
element
=
doc
-
>
CreateHTMLElement
(
aTag
)
;
element
-
>
SetPseudoElementType
(
aPseudoType
)
;
if
(
aPseudoType
=
=
PseudoStyleType
:
:
mozTextControlEditingRoot
)
{
element
-
>
SetFlags
(
NODE_IS_EDITABLE
)
;
}
if
(
aPseudoType
=
=
PseudoStyleType
:
:
mozNumberSpinDown
|
|
aPseudoType
=
=
PseudoStyleType
:
:
mozNumberSpinUp
)
{
element
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
aria_hidden
u
"
true
"
_ns
false
)
;
}
if
(
aParent
)
{
aParent
-
>
AppendChildTo
(
element
false
IgnoreErrors
(
)
)
;
}
return
element
.
forget
(
)
;
}
already_AddRefed
<
Element
>
nsTextControlFrame
:
:
MakeAnonDivWithTextNode
(
PseudoStyleType
aPseudoType
)
const
{
RefPtr
<
Element
>
div
=
MakeAnonElement
(
aPseudoType
)
;
nsNodeInfoManager
*
nim
=
div
-
>
OwnerDoc
(
)
-
>
NodeInfoManager
(
)
;
RefPtr
<
nsTextNode
>
textNode
=
new
(
nim
)
nsTextNode
(
nim
)
;
if
(
aPseudoType
!
=
PseudoStyleType
:
:
placeholder
)
{
textNode
-
>
MarkAsMaybeModifiedFrequently
(
)
;
if
(
IsPasswordTextControl
(
)
)
{
textNode
-
>
MarkAsMaybeMasked
(
)
;
}
}
div
-
>
AppendChildTo
(
textNode
false
IgnoreErrors
(
)
)
;
return
div
.
forget
(
)
;
}
nsresult
nsTextControlFrame
:
:
CreateAnonymousContent
(
nsTArray
<
ContentInfo
>
&
aElements
)
{
MOZ_ASSERT
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
)
;
MOZ_ASSERT
(
mContent
"
We
should
have
a
content
!
"
)
;
AddStateBits
(
NS_FRAME_INDEPENDENT_SELECTION
)
;
if
(
IsDateTimeControlFrame
(
)
)
{
return
NS_OK
;
}
RefPtr
textControlElement
=
TextControlElement
:
:
FromNode
(
GetContent
(
)
)
;
MOZ_ASSERT
(
textControlElement
)
;
mRootNode
=
MakeAnonElement
(
PseudoStyleType
:
:
mozTextControlEditingRoot
)
;
if
(
NS_WARN_IF
(
!
mRootNode
)
)
{
return
NS_ERROR_FAILURE
;
}
mMutationObserver
=
new
nsAnonDivObserver
(
*
this
)
;
mRootNode
-
>
AddMutationObserver
(
mMutationObserver
)
;
nsresult
rv
=
textControlElement
-
>
BindToFrame
(
this
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
mRootNode
-
>
RemoveMutationObserver
(
mMutationObserver
)
;
mMutationObserver
=
nullptr
;
mRootNode
=
nullptr
;
return
rv
;
}
CreatePlaceholderIfNeeded
(
)
;
if
(
mPlaceholderDiv
)
{
aElements
.
AppendElement
(
mPlaceholderDiv
)
;
}
CreatePreviewIfNeeded
(
)
;
if
(
mPreviewDiv
)
{
aElements
.
AppendElement
(
mPreviewDiv
)
;
}
aElements
.
AppendElement
(
mRootNode
)
;
if
(
StaticPrefs
:
:
layout_forms_reveal_password_button_enabled
(
)
&
&
IsPasswordTextControl
(
)
)
{
mRevealButton
=
MakeAnonElement
(
PseudoStyleType
:
:
mozReveal
nullptr
nsGkAtoms
:
:
button
)
;
mRevealButton
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
aria_hidden
u
"
true
"
_ns
false
)
;
mRevealButton
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
tabindex
u
"
-
1
"
_ns
false
)
;
aElements
.
AppendElement
(
mRevealButton
)
;
}
rv
=
UpdateValueDisplay
(
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
InitializeEagerlyIfNeeded
(
)
;
return
NS_OK
;
}
bool
nsTextControlFrame
:
:
ShouldInitializeEagerly
(
)
const
{
if
(
!
IsSingleLineTextControl
(
)
)
{
return
true
;
}
auto
*
textControlElement
=
TextControlElement
:
:
FromNode
(
GetContent
(
)
)
;
MOZ_ASSERT
(
textControlElement
)
;
if
(
textControlElement
-
>
HasCachedSelection
(
)
)
{
return
true
;
}
if
(
auto
*
htmlElement
=
nsGenericHTMLElement
:
:
FromNode
(
mContent
)
)
{
if
(
htmlElement
-
>
Spellcheck
(
)
)
{
return
true
;
}
}
if
(
nsCOMPtr
<
nsIDragSession
>
dragSession
=
nsContentUtils
:
:
GetDragSession
(
)
)
{
if
(
dragSession
-
>
IsDraggingTextInTextControl
(
)
)
{
nsCOMPtr
<
nsINode
>
sourceNode
;
if
(
NS_SUCCEEDED
(
dragSession
-
>
GetSourceNode
(
getter_AddRefs
(
sourceNode
)
)
)
&
&
sourceNode
=
=
textControlElement
)
{
return
true
;
}
}
}
return
false
;
}
void
nsTextControlFrame
:
:
InitializeEagerlyIfNeeded
(
)
{
MOZ_ASSERT
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
Someone
forgot
a
script
blocker
?
"
)
;
if
(
!
ShouldInitializeEagerly
(
)
)
{
return
;
}
auto
*
initializer
=
new
EditorInitializer
(
this
)
;
SetProperty
(
TextControlInitializer
(
)
initializer
)
;
nsContentUtils
:
:
AddScriptRunner
(
initializer
)
;
}
void
nsTextControlFrame
:
:
CreatePlaceholderIfNeeded
(
)
{
MOZ_ASSERT
(
!
mPlaceholderDiv
)
;
nsAutoString
placeholder
;
if
(
!
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
nsGkAtoms
:
:
placeholder
placeholder
)
)
{
return
;
}
mPlaceholderDiv
=
MakeAnonDivWithTextNode
(
PseudoStyleType
:
:
placeholder
)
;
UpdatePlaceholderText
(
placeholder
false
)
;
}
void
nsTextControlFrame
:
:
PlaceholderChanged
(
const
nsAttrValue
*
aOld
const
nsAttrValue
*
aNew
)
{
if
(
!
aOld
|
|
!
aNew
)
{
return
;
}
if
(
!
mPlaceholderDiv
)
{
return
;
}
nsAutoString
placeholder
;
aNew
-
>
ToString
(
placeholder
)
;
UpdatePlaceholderText
(
placeholder
true
)
;
}
void
nsTextControlFrame
:
:
UpdatePlaceholderText
(
nsString
&
aPlaceholder
bool
aNotify
)
{
MOZ_DIAGNOSTIC_ASSERT
(
mPlaceholderDiv
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mPlaceholderDiv
-
>
GetFirstChild
(
)
)
;
if
(
IsTextArea
(
)
)
{
nsContentUtils
:
:
PlatformToDOMLineBreaks
(
aPlaceholder
)
;
}
else
{
nsContentUtils
:
:
RemoveNewlines
(
aPlaceholder
)
;
}
mPlaceholderDiv
-
>
GetFirstChild
(
)
-
>
AsText
(
)
-
>
SetText
(
aPlaceholder
aNotify
)
;
}
void
nsTextControlFrame
:
:
CreatePreviewIfNeeded
(
)
{
RefPtr
<
TextControlElement
>
textControlElement
=
TextControlElement
:
:
FromNode
(
GetContent
(
)
)
;
MOZ_ASSERT
(
textControlElement
)
;
if
(
!
textControlElement
-
>
IsPreviewEnabled
(
)
)
{
return
;
}
mPreviewDiv
=
MakeAnonDivWithTextNode
(
PseudoStyleType
:
:
mozTextControlPreview
)
;
}
void
nsTextControlFrame
:
:
AppendAnonymousContentTo
(
nsTArray
<
nsIContent
*
>
&
aElements
uint32_t
aFilter
)
{
if
(
mPlaceholderDiv
&
&
!
(
aFilter
&
nsIContent
:
:
eSkipPlaceholderContent
)
)
{
aElements
.
AppendElement
(
mPlaceholderDiv
)
;
}
if
(
mPreviewDiv
)
{
aElements
.
AppendElement
(
mPreviewDiv
)
;
}
if
(
mRevealButton
)
{
aElements
.
AppendElement
(
mRevealButton
)
;
}
aElements
.
AppendElement
(
mRootNode
)
;
}
nscoord
nsTextControlFrame
:
:
GetPrefISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
result
=
0
;
DISPLAY_PREF_INLINE_SIZE
(
this
result
)
;
float
inflation
=
nsLayoutUtils
:
:
FontSizeInflationFor
(
this
)
;
WritingMode
wm
=
GetWritingMode
(
)
;
result
=
CalcIntrinsicSize
(
aRenderingContext
wm
inflation
)
.
ISize
(
wm
)
;
return
result
;
}
nscoord
nsTextControlFrame
:
:
GetMinISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
result
;
DISPLAY_MIN_INLINE_SIZE
(
this
result
)
;
result
=
GetPrefISize
(
aRenderingContext
)
;
return
result
;
}
LogicalSize
nsTextControlFrame
:
:
ComputeAutoSize
(
gfxContext
*
aRenderingContext
WritingMode
aWM
const
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
LogicalSize
&
aMargin
const
LogicalSize
&
aBorderPadding
const
StyleSizeOverrides
&
aSizeOverrides
ComputeSizeFlags
aFlags
)
{
float
inflation
=
nsLayoutUtils
:
:
FontSizeInflationFor
(
this
)
;
LogicalSize
autoSize
=
CalcIntrinsicSize
(
aRenderingContext
aWM
inflation
)
;
const
auto
&
styleISize
=
aSizeOverrides
.
mStyleISize
?
*
aSizeOverrides
.
mStyleISize
:
StylePosition
(
)
-
>
ISize
(
aWM
)
;
if
(
styleISize
.
IsAuto
(
)
)
{
if
(
aFlags
.
contains
(
ComputeSizeFlag
:
:
IClampMarginBoxMinSize
)
)
{
autoSize
.
ISize
(
aWM
)
=
nsContainerFrame
:
:
ComputeAutoSize
(
aRenderingContext
aWM
aCBSize
aAvailableISize
aMargin
aBorderPadding
aSizeOverrides
aFlags
)
.
ISize
(
aWM
)
;
}
#
ifdef
DEBUG
else
{
LogicalSize
ancestorAutoSize
=
nsContainerFrame
:
:
ComputeAutoSize
(
aRenderingContext
aWM
aCBSize
aAvailableISize
aMargin
aBorderPadding
aSizeOverrides
aFlags
)
;
MOZ_ASSERT
(
IsDateTimeControlFrame
(
)
|
|
inflation
!
=
1
.
0f
|
|
ancestorAutoSize
.
ISize
(
aWM
)
=
=
autoSize
.
ISize
(
aWM
)
"
Incorrect
size
computed
by
ComputeAutoSize
?
"
)
;
}
#
endif
}
return
autoSize
;
}
Maybe
<
nscoord
>
nsTextControlFrame
:
:
ComputeBaseline
(
const
nsIFrame
*
aFrame
const
ReflowInput
&
aReflowInput
bool
aForTextArea
)
{
if
(
aReflowInput
.
mStyleDisplay
-
>
IsContainLayout
(
)
)
{
return
Nothing
(
)
;
}
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
nscoord
lineHeight
=
aReflowInput
.
ComputedBSize
(
)
;
if
(
aForTextArea
|
|
lineHeight
=
=
NS_UNCONSTRAINEDSIZE
)
{
lineHeight
=
NS_CSS_MINMAX
(
aReflowInput
.
GetLineHeight
(
)
aReflowInput
.
ComputedMinBSize
(
)
aReflowInput
.
ComputedMaxBSize
(
)
)
;
}
RefPtr
<
nsFontMetrics
>
fontMet
=
nsLayoutUtils
:
:
GetInflatedFontMetricsForFrame
(
aFrame
)
;
return
Some
(
nsLayoutUtils
:
:
GetCenteredFontBaseline
(
fontMet
lineHeight
wm
.
IsLineInverted
(
)
)
+
aReflowInput
.
ComputedLogicalBorderPadding
(
wm
)
.
BStart
(
wm
)
)
;
}
static
bool
IsButtonBox
(
const
nsIFrame
*
aFrame
)
{
auto
pseudoType
=
aFrame
-
>
Style
(
)
-
>
GetPseudoType
(
)
;
return
pseudoType
=
=
PseudoStyleType
:
:
mozNumberSpinBox
|
|
pseudoType
=
=
PseudoStyleType
:
:
mozSearchClearButton
|
|
pseudoType
=
=
PseudoStyleType
:
:
mozReveal
;
}
void
nsTextControlFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsTextControlFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aDesiredSize
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
aDesiredSize
.
SetSize
(
wm
aReflowInput
.
ComputedSizeWithBorderPadding
(
wm
)
)
;
{
auto
baseline
=
ComputeBaseline
(
this
aReflowInput
IsTextArea
(
)
)
;
mFirstBaseline
=
baseline
.
valueOr
(
NS_INTRINSIC_ISIZE_UNKNOWN
)
;
if
(
baseline
)
{
aDesiredSize
.
SetBlockStartAscent
(
*
baseline
)
;
}
}
aDesiredSize
.
SetOverflowAreasToDesiredBounds
(
)
;
nsIFrame
*
buttonBox
=
[
&
]
(
)
-
>
nsIFrame
*
{
nsIFrame
*
last
=
mFrames
.
LastChild
(
)
;
if
(
!
last
|
|
!
IsButtonBox
(
last
)
)
{
return
nullptr
;
}
return
last
;
}
(
)
;
nscoord
buttonBoxISize
=
0
;
if
(
buttonBox
)
{
ReflowTextControlChild
(
buttonBox
aPresContext
aReflowInput
aStatus
aDesiredSize
buttonBoxISize
)
;
}
nsIFrame
*
kid
=
mFrames
.
FirstChild
(
)
;
while
(
kid
)
{
if
(
kid
!
=
buttonBox
)
{
MOZ_ASSERT
(
!
IsButtonBox
(
kid
)
"
Should
only
have
one
button
box
and
should
be
last
"
)
;
ReflowTextControlChild
(
kid
aPresContext
aReflowInput
aStatus
aDesiredSize
buttonBoxISize
)
;
}
kid
=
kid
-
>
GetNextSibling
(
)
;
}
FinishAndStoreOverflow
(
&
aDesiredSize
)
;
aStatus
.
Reset
(
)
;
}
void
nsTextControlFrame
:
:
ReflowTextControlChild
(
nsIFrame
*
aKid
nsPresContext
*
aPresContext
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
ReflowOutput
&
aParentDesiredSize
nscoord
&
aButtonBoxISize
)
{
const
WritingMode
outerWM
=
aReflowInput
.
GetWritingMode
(
)
;
const
WritingMode
wm
=
aKid
-
>
GetWritingMode
(
)
;
LogicalSize
availSize
=
aReflowInput
.
ComputedSizeWithPadding
(
wm
)
;
availSize
.
BSize
(
wm
)
=
NS_UNCONSTRAINEDSIZE
;
bool
isButtonBox
=
IsButtonBox
(
aKid
)
;
ReflowInput
kidReflowInput
(
aPresContext
aReflowInput
aKid
availSize
Nothing
(
)
ReflowInput
:
:
InitFlag
:
:
CallerWillInit
)
;
auto
overridePadding
=
isButtonBox
?
Nothing
(
)
:
Some
(
aReflowInput
.
ComputedLogicalPadding
(
wm
)
)
;
if
(
!
isButtonBox
&
&
aButtonBoxISize
)
{
overridePadding
-
>
IEnd
(
outerWM
)
=
0
;
}
auto
overrideCBSize
=
isButtonBox
?
Some
(
aReflowInput
.
ComputedSizeWithPadding
(
wm
)
)
:
Nothing
(
)
;
kidReflowInput
.
Init
(
aPresContext
overrideCBSize
Nothing
(
)
overridePadding
)
;
LogicalPoint
position
(
wm
)
;
if
(
!
isButtonBox
)
{
MOZ_ASSERT
(
wm
=
=
outerWM
"
Shouldn
'
t
have
to
care
about
orthogonal
"
"
writing
-
modes
and
such
inside
the
control
"
"
except
for
the
number
spin
-
box
which
forces
"
"
horizontal
-
tb
"
)
;
const
auto
&
border
=
aReflowInput
.
ComputedLogicalBorder
(
wm
)
;
position
.
B
(
wm
)
=
border
.
BStart
(
wm
)
;
position
.
I
(
wm
)
=
border
.
IStart
(
wm
)
;
kidReflowInput
.
SetComputedISize
(
std
:
:
max
(
0
aReflowInput
.
ComputedISize
(
)
-
aButtonBoxISize
)
)
;
kidReflowInput
.
SetComputedBSize
(
aReflowInput
.
ComputedBSize
(
)
)
;
}
ReflowOutput
desiredSize
(
aReflowInput
)
;
const
nsSize
containerSize
=
aReflowInput
.
ComputedSizeWithBorderPadding
(
outerWM
)
.
GetPhysicalSize
(
outerWM
)
;
ReflowChild
(
aKid
aPresContext
desiredSize
kidReflowInput
wm
position
containerSize
ReflowChildFlags
:
:
Default
aStatus
)
;
if
(
isButtonBox
)
{
const
auto
&
bp
=
aReflowInput
.
ComputedLogicalBorderPadding
(
outerWM
)
;
auto
size
=
desiredSize
.
Size
(
outerWM
)
;
LogicalRect
buttonRect
(
outerWM
)
;
buttonRect
.
BSize
(
outerWM
)
=
size
.
BSize
(
outerWM
)
;
buttonRect
.
ISize
(
outerWM
)
=
size
.
ISize
(
outerWM
)
;
buttonRect
.
BStart
(
outerWM
)
=
bp
.
BStart
(
outerWM
)
+
(
aReflowInput
.
ComputedBSize
(
)
-
size
.
BSize
(
outerWM
)
)
/
2
;
buttonRect
.
IStart
(
outerWM
)
=
bp
.
IStart
(
outerWM
)
+
aReflowInput
.
ComputedISize
(
)
-
size
.
ISize
(
outerWM
)
;
buttonRect
=
buttonRect
.
ConvertTo
(
wm
outerWM
containerSize
)
;
position
=
buttonRect
.
Origin
(
wm
)
;
aButtonBoxISize
=
size
.
ISize
(
outerWM
)
;
}
FinishReflowChild
(
aKid
aPresContext
desiredSize
&
kidReflowInput
wm
position
containerSize
ReflowChildFlags
:
:
Default
)
;
aParentDesiredSize
.
mOverflowAreas
.
UnionWith
(
desiredSize
.
mOverflowAreas
)
;
}
void
nsTextControlFrame
:
:
SetFocus
(
bool
aOn
bool
aRepaint
)
{
auto
*
textControlElement
=
TextControlElement
:
:
FromNode
(
GetContent
(
)
)
;
MOZ_ASSERT
(
textControlElement
)
;
if
(
!
aOn
)
{
return
;
}
nsISelectionController
*
selCon
=
textControlElement
-
>
GetSelectionController
(
)
;
if
(
!
selCon
)
{
return
;
}
RefPtr
<
Selection
>
ourSel
=
selCon
-
>
GetSelection
(
nsISelectionController
:
:
SELECTION_NORMAL
)
;
if
(
!
ourSel
)
{
return
;
}
mozilla
:
:
PresShell
*
presShell
=
PresContext
(
)
-
>
GetPresShell
(
)
;
RefPtr
<
nsCaret
>
caret
=
presShell
-
>
GetCaret
(
)
;
if
(
!
caret
)
{
return
;
}
caret
-
>
SetSelection
(
ourSel
)
;
RefPtr
<
Selection
>
docSel
=
presShell
-
>
GetSelection
(
nsISelectionController
:
:
SELECTION_NORMAL
)
;
if
(
!
docSel
)
{
return
;
}
if
(
!
docSel
-
>
IsCollapsed
(
)
)
{
docSel
-
>
RemoveAllRanges
(
IgnoreErrors
(
)
)
;
}
if
(
RefPtr
<
nsFrameSelection
>
frameSelection
=
presShell
-
>
FrameSelection
(
)
)
{
frameSelection
-
>
SetDragState
(
false
)
;
}
}
nsresult
nsTextControlFrame
:
:
SetFormProperty
(
nsAtom
*
aName
const
nsAString
&
aValue
)
{
if
(
!
mIsProcessing
)
{
mIsProcessing
=
true
;
if
(
nsGkAtoms
:
:
select
=
=
aName
)
{
AutoWeakFrame
weakThis
=
this
;
SelectAllOrCollapseToEndOfText
(
true
)
;
if
(
!
weakThis
.
IsAlive
(
)
)
{
return
NS_OK
;
}
}
mIsProcessing
=
false
;
}
return
NS_OK
;
}
already_AddRefed
<
TextEditor
>
nsTextControlFrame
:
:
GetTextEditor
(
)
{
if
(
NS_WARN_IF
(
NS_FAILED
(
EnsureEditorInitialized
(
)
)
)
)
{
return
nullptr
;
}
RefPtr
<
TextControlElement
>
textControlElement
=
TextControlElement
:
:
FromNode
(
GetContent
(
)
)
;
MOZ_ASSERT
(
textControlElement
)
;
RefPtr
<
TextEditor
>
textEditor
=
textControlElement
-
>
GetTextEditor
(
)
;
return
textEditor
.
forget
(
)
;
}
nsresult
nsTextControlFrame
:
:
SetSelectionInternal
(
nsINode
*
aStartNode
uint32_t
aStartOffset
nsINode
*
aEndNode
uint32_t
aEndOffset
SelectionDirection
aDirection
)
{
TextControlElement
*
textControlElement
=
TextControlElement
:
:
FromNode
(
GetContent
(
)
)
;
MOZ_ASSERT
(
textControlElement
)
;
nsISelectionController
*
selCon
=
textControlElement
-
>
GetSelectionController
(
)
;
NS_ENSURE_TRUE
(
selCon
NS_ERROR_FAILURE
)
;
RefPtr
<
Selection
>
selection
=
selCon
-
>
GetSelection
(
nsISelectionController
:
:
SELECTION_NORMAL
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_FAILURE
)
;
nsDirection
direction
;
if
(
aDirection
=
=
SelectionDirection
:
:
None
)
{
direction
=
selection
-
>
GetDirection
(
)
;
}
else
{
direction
=
(
aDirection
=
=
SelectionDirection
:
:
Backward
)
?
eDirPrevious
:
eDirNext
;
}
MOZ_TRY
(
selection
-
>
SetStartAndEndInLimiter
(
*
aStartNode
aStartOffset
*
aEndNode
aEndOffset
direction
nsISelectionListener
:
:
JS_REASON
)
)
;
return
NS_OK
;
}
void
nsTextControlFrame
:
:
ScrollSelectionIntoViewAsync
(
ScrollAncestors
aScrollAncestors
)
{
auto
*
textControlElement
=
TextControlElement
:
:
FromNode
(
GetContent
(
)
)
;
MOZ_ASSERT
(
textControlElement
)
;
nsISelectionController
*
selCon
=
textControlElement
-
>
GetSelectionController
(
)
;
if
(
!
selCon
)
{
return
;
}
int16_t
flags
=
aScrollAncestors
=
=
ScrollAncestors
:
:
Yes
?
0
:
nsISelectionController
:
:
SCROLL_FIRST_ANCESTOR_ONLY
;
selCon
-
>
ScrollSelectionIntoView
(
nsISelectionController
:
:
SELECTION_NORMAL
nsISelectionController
:
:
SELECTION_FOCUS_REGION
flags
)
;
}
nsresult
nsTextControlFrame
:
:
SelectAllOrCollapseToEndOfText
(
bool
aSelect
)
{
nsresult
rv
=
EnsureEditorInitialized
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
RefPtr
<
nsINode
>
rootNode
=
mRootNode
;
NS_ENSURE_TRUE
(
rootNode
NS_ERROR_FAILURE
)
;
RefPtr
<
Text
>
text
=
Text
:
:
FromNodeOrNull
(
rootNode
-
>
GetFirstChild
(
)
)
;
MOZ_ASSERT
(
text
)
;
uint32_t
length
=
text
-
>
Length
(
)
;
rv
=
SetSelectionInternal
(
text
aSelect
?
0
:
length
text
length
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
ScrollSelectionIntoViewAsync
(
)
;
return
NS_OK
;
}
nsresult
nsTextControlFrame
:
:
SetSelectionEndPoints
(
uint32_t
aSelStart
uint32_t
aSelEnd
nsITextControlFrame
:
:
SelectionDirection
aDirection
)
{
NS_ASSERTION
(
aSelStart
<
=
aSelEnd
"
Invalid
selection
offsets
!
"
)
;
if
(
aSelStart
>
aSelEnd
)
return
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsINode
>
startNode
endNode
;
uint32_t
startOffset
endOffset
;
nsresult
rv
=
OffsetToDOMPoint
(
aSelStart
getter_AddRefs
(
startNode
)
&
startOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aSelStart
=
=
aSelEnd
)
{
endNode
=
startNode
;
endOffset
=
startOffset
;
}
else
{
rv
=
OffsetToDOMPoint
(
aSelEnd
getter_AddRefs
(
endNode
)
&
endOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
SetSelectionInternal
(
startNode
startOffset
endNode
endOffset
aDirection
)
;
}
NS_IMETHODIMP
nsTextControlFrame
:
:
SetSelectionRange
(
uint32_t
aSelStart
uint32_t
aSelEnd
nsITextControlFrame
:
:
SelectionDirection
aDirection
)
{
nsresult
rv
=
EnsureEditorInitialized
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aSelStart
>
aSelEnd
)
{
aSelStart
=
aSelEnd
;
}
return
SetSelectionEndPoints
(
aSelStart
aSelEnd
aDirection
)
;
}
nsresult
nsTextControlFrame
:
:
OffsetToDOMPoint
(
uint32_t
aOffset
nsINode
*
*
aResult
uint32_t
*
aPosition
)
{
NS_ENSURE_ARG_POINTER
(
aResult
&
&
aPosition
)
;
*
aResult
=
nullptr
;
*
aPosition
=
0
;
nsresult
rv
=
EnsureEditorInitialized
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
RefPtr
<
Element
>
rootNode
=
mRootNode
;
NS_ENSURE_TRUE
(
rootNode
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsINodeList
>
nodeList
=
rootNode
-
>
ChildNodes
(
)
;
uint32_t
length
=
nodeList
-
>
Length
(
)
;
NS_ASSERTION
(
length
<
=
2
"
We
should
have
one
text
node
and
one
mozBR
at
most
"
)
;
nsCOMPtr
<
nsINode
>
firstNode
=
nodeList
-
>
Item
(
0
)
;
Text
*
textNode
=
firstNode
?
firstNode
-
>
GetAsText
(
)
:
nullptr
;
if
(
length
=
=
0
)
{
rootNode
.
forget
(
aResult
)
;
*
aPosition
=
0
;
}
else
if
(
textNode
)
{
uint32_t
textLength
=
textNode
-
>
Length
(
)
;
firstNode
.
forget
(
aResult
)
;
*
aPosition
=
std
:
:
min
(
aOffset
textLength
)
;
}
else
{
rootNode
.
forget
(
aResult
)
;
*
aPosition
=
0
;
}
return
NS_OK
;
}
nsresult
nsTextControlFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
auto
*
textControlElement
=
TextControlElement
:
:
FromNode
(
GetContent
(
)
)
;
MOZ_ASSERT
(
textControlElement
)
;
nsISelectionController
*
selCon
=
textControlElement
-
>
GetSelectionController
(
)
;
const
bool
needEditor
=
nsGkAtoms
:
:
maxlength
=
=
aAttribute
|
|
nsGkAtoms
:
:
readonly
=
=
aAttribute
|
|
nsGkAtoms
:
:
disabled
=
=
aAttribute
|
|
nsGkAtoms
:
:
spellcheck
=
=
aAttribute
;
RefPtr
<
TextEditor
>
textEditor
=
needEditor
?
GetTextEditor
(
)
:
nullptr
;
if
(
(
needEditor
&
&
!
textEditor
)
|
|
!
selCon
)
{
return
nsContainerFrame
:
:
AttributeChanged
(
aNameSpaceID
aAttribute
aModType
)
;
}
if
(
nsGkAtoms
:
:
maxlength
=
=
aAttribute
)
{
if
(
textEditor
)
{
textEditor
-
>
SetMaxTextLength
(
textControlElement
-
>
UsedMaxLength
(
)
)
;
}
return
NS_OK
;
}
if
(
nsGkAtoms
:
:
readonly
=
=
aAttribute
|
|
nsGkAtoms
:
:
disabled
=
=
aAttribute
)
{
if
(
AttributeExists
(
aAttribute
)
)
{
if
(
nsContentUtils
:
:
IsFocusedContent
(
mContent
)
)
{
selCon
-
>
SetCaretEnabled
(
false
)
;
}
textEditor
-
>
AddFlags
(
nsIEditor
:
:
eEditorReadonlyMask
)
;
}
else
{
if
(
!
AttributeExists
(
aAttribute
=
=
nsGkAtoms
:
:
readonly
?
nsGkAtoms
:
:
disabled
:
nsGkAtoms
:
:
readonly
)
)
{
if
(
nsContentUtils
:
:
IsFocusedContent
(
mContent
)
)
{
selCon
-
>
SetCaretEnabled
(
true
)
;
}
textEditor
-
>
RemoveFlags
(
nsIEditor
:
:
eEditorReadonlyMask
)
;
}
}
return
NS_OK
;
}
if
(
!
mEditorHasBeenInitialized
&
&
nsGkAtoms
:
:
value
=
=
aAttribute
)
{
UpdateValueDisplay
(
true
)
;
return
NS_OK
;
}
return
nsContainerFrame
:
:
AttributeChanged
(
aNameSpaceID
aAttribute
aModType
)
;
}
bool
nsTextControlFrame
:
:
TextEquals
(
const
nsAString
&
aText
)
const
{
if
(
auto
*
inputElement
=
HTMLInputElement
:
:
FromNode
(
mContent
)
)
{
if
(
IsSingleLineTextControl
(
)
)
{
return
inputElement
-
>
TextEditorValueEquals
(
aText
)
;
}
return
aText
.
IsEmpty
(
)
;
}
MOZ_ASSERT
(
!
IsSingleLineTextControl
(
)
)
;
if
(
auto
*
textAreaElement
=
HTMLTextAreaElement
:
:
FromNode
(
mContent
)
)
{
return
textAreaElement
-
>
ValueEquals
(
aText
)
;
}
return
aText
.
IsEmpty
(
)
;
}
static
nsIFrame
*
FindRootNodeFrame
(
const
nsFrameList
&
aChildList
const
nsIContent
*
aRoot
)
{
for
(
nsIFrame
*
f
:
aChildList
)
{
if
(
f
-
>
GetContent
(
)
=
=
aRoot
)
{
return
f
;
}
if
(
nsIFrame
*
root
=
FindRootNodeFrame
(
f
-
>
PrincipalChildList
(
)
aRoot
)
)
{
return
root
;
}
}
return
nullptr
;
}
void
nsTextControlFrame
:
:
SetInitialChildList
(
ChildListID
aListID
nsFrameList
&
&
aChildList
)
{
nsContainerFrame
:
:
SetInitialChildList
(
aListID
std
:
:
move
(
aChildList
)
)
;
if
(
aListID
!
=
FrameChildListID
:
:
Principal
)
{
return
;
}
if
(
nsIFrame
*
frame
=
FindRootNodeFrame
(
PrincipalChildList
(
)
mRootNode
)
)
{
frame
-
>
AddStateBits
(
NS_FRAME_REFLOW_ROOT
)
;
auto
*
textControlElement
=
TextControlElement
:
:
FromNode
(
GetContent
(
)
)
;
MOZ_ASSERT
(
textControlElement
)
;
textControlElement
-
>
InitializeKeyboardEventListeners
(
)
;
bool
hasProperty
;
nsPoint
contentScrollPos
=
TakeProperty
(
ContentScrollPos
(
)
&
hasProperty
)
;
if
(
hasProperty
)
{
nsIStatefulFrame
*
statefulFrame
=
do_QueryFrame
(
frame
)
;
NS_ASSERTION
(
statefulFrame
"
unexpected
type
of
frame
for
the
anonymous
div
"
)
;
UniquePtr
<
PresState
>
fakePresState
=
NewPresState
(
)
;
fakePresState
-
>
scrollState
(
)
=
contentScrollPos
;
statefulFrame
-
>
RestoreState
(
fakePresState
.
get
(
)
)
;
}
}
else
{
MOZ_ASSERT
(
!
mRootNode
|
|
PrincipalChildList
(
)
.
IsEmpty
(
)
)
;
}
}
nsresult
nsTextControlFrame
:
:
UpdateValueDisplay
(
bool
aNotify
bool
aBeforeEditorInit
const
nsAString
*
aValue
)
{
if
(
!
IsSingleLineTextControl
(
)
)
{
return
NS_OK
;
}
MOZ_ASSERT
(
mRootNode
"
Must
have
a
div
content
\
n
"
)
;
MOZ_ASSERT
(
!
mEditorHasBeenInitialized
"
Do
not
call
this
after
editor
has
been
initialized
"
)
;
nsIContent
*
childContent
=
mRootNode
-
>
GetFirstChild
(
)
;
Text
*
textContent
;
if
(
!
childContent
)
{
RefPtr
<
nsTextNode
>
textNode
=
new
(
mContent
-
>
NodeInfo
(
)
-
>
NodeInfoManager
(
)
)
nsTextNode
(
mContent
-
>
NodeInfo
(
)
-
>
NodeInfoManager
(
)
)
;
textNode
-
>
MarkAsMaybeModifiedFrequently
(
)
;
if
(
IsPasswordTextControl
(
)
)
{
textNode
-
>
MarkAsMaybeMasked
(
)
;
}
mRootNode
-
>
AppendChildTo
(
textNode
aNotify
IgnoreErrors
(
)
)
;
textContent
=
textNode
;
}
else
{
textContent
=
childContent
-
>
GetAsText
(
)
;
}
NS_ENSURE_TRUE
(
textContent
NS_ERROR_UNEXPECTED
)
;
TextControlElement
*
textControlElement
=
TextControlElement
:
:
FromNode
(
GetContent
(
)
)
;
MOZ_ASSERT
(
textControlElement
)
;
nsAutoString
value
;
if
(
aValue
)
{
value
=
*
aValue
;
}
else
{
textControlElement
-
>
GetTextEditorValue
(
value
true
)
;
}
return
textContent
-
>
SetText
(
value
aNotify
)
;
}
NS_IMETHODIMP
nsTextControlFrame
:
:
GetOwnedSelectionController
(
nsISelectionController
*
*
aSelCon
)
{
NS_ENSURE_ARG_POINTER
(
aSelCon
)
;
TextControlElement
*
textControlElement
=
TextControlElement
:
:
FromNode
(
GetContent
(
)
)
;
MOZ_ASSERT
(
textControlElement
)
;
*
aSelCon
=
textControlElement
-
>
GetSelectionController
(
)
;
NS_IF_ADDREF
(
*
aSelCon
)
;
return
NS_OK
;
}
nsFrameSelection
*
nsTextControlFrame
:
:
GetOwnedFrameSelection
(
)
{
auto
*
textControlElement
=
TextControlElement
:
:
FromNode
(
GetContent
(
)
)
;
MOZ_ASSERT
(
textControlElement
)
;
return
textControlElement
-
>
GetConstFrameSelection
(
)
;
}
UniquePtr
<
PresState
>
nsTextControlFrame
:
:
SaveState
(
)
{
if
(
nsIStatefulFrame
*
scrollStateFrame
=
do_QueryFrame
(
GetScrollTargetFrame
(
)
)
)
{
return
scrollStateFrame
-
>
SaveState
(
)
;
}
return
nullptr
;
}
NS_IMETHODIMP
nsTextControlFrame
:
:
RestoreState
(
PresState
*
aState
)
{
NS_ENSURE_ARG_POINTER
(
aState
)
;
if
(
nsIStatefulFrame
*
scrollStateFrame
=
do_QueryFrame
(
GetScrollTargetFrame
(
)
)
)
{
return
scrollStateFrame
-
>
RestoreState
(
aState
)
;
}
SetProperty
(
ContentScrollPos
(
)
aState
-
>
scrollState
(
)
)
;
return
NS_OK
;
}
nsresult
nsTextControlFrame
:
:
PeekOffset
(
PeekOffsetStruct
*
aPos
)
{
return
NS_ERROR_FAILURE
;
}
void
nsTextControlFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
DO_GLOBAL_REFLOW_COUNT_DSP
(
"
nsTextControlFrame
"
)
;
DisplayBorderBackgroundOutline
(
aBuilder
aLists
)
;
nsDisplayList
*
content
=
aLists
.
Content
(
)
;
nsDisplayListSet
set
(
content
content
content
content
content
content
)
;
for
(
auto
*
kid
:
mFrames
)
{
BuildDisplayListForChild
(
aBuilder
kid
set
)
;
}
}
NS_IMETHODIMP
nsTextControlFrame
:
:
EditorInitializer
:
:
Run
(
)
{
if
(
!
mFrame
)
{
return
NS_OK
;
}
nsAutoScriptBlocker
scriptBlocker
;
RefPtr
<
mozilla
:
:
PresShell
>
presShell
=
mFrame
-
>
PresShell
(
)
;
bool
observes
=
presShell
-
>
ObservesNativeAnonMutationsForPrint
(
)
;
presShell
-
>
ObserveNativeAnonMutationsForPrint
(
true
)
;
mFrame
-
>
EnsureEditorInitialized
(
)
;
presShell
-
>
ObserveNativeAnonMutationsForPrint
(
observes
)
;
if
(
!
mFrame
)
{
return
NS_ERROR_FAILURE
;
}
if
(
nsCOMPtr
<
nsIDragSession
>
dragSession
=
nsContentUtils
:
:
GetDragSession
(
)
)
{
if
(
dragSession
-
>
IsDraggingTextInTextControl
(
)
)
{
nsCOMPtr
<
nsINode
>
sourceNode
;
if
(
NS_SUCCEEDED
(
dragSession
-
>
GetSourceNode
(
getter_AddRefs
(
sourceNode
)
)
)
&
&
mFrame
-
>
GetContent
(
)
=
=
sourceNode
)
{
if
(
TextControlElement
*
textControlElement
=
TextControlElement
:
:
FromNode
(
mFrame
-
>
GetContent
(
)
)
)
{
if
(
TextEditor
*
textEditor
=
textControlElement
-
>
GetTextEditorWithoutCreation
(
)
)
{
if
(
Element
*
anonymousDivElement
=
textEditor
-
>
GetRoot
(
)
)
{
if
(
anonymousDivElement
&
&
anonymousDivElement
-
>
GetFirstChild
(
)
)
{
MOZ_ASSERT
(
anonymousDivElement
-
>
GetFirstChild
(
)
-
>
IsText
(
)
)
;
dragSession
-
>
UpdateSource
(
anonymousDivElement
-
>
GetFirstChild
(
)
textEditor
-
>
GetSelection
(
)
)
;
}
}
}
}
}
}
}
else
if
(
TextControlElement
*
textControlElement
=
TextControlElement
:
:
FromNode
(
mFrame
-
>
GetContent
(
)
)
)
{
if
(
nsPresContext
*
presContext
=
textControlElement
-
>
GetPresContext
(
Element
:
:
eForComposedDoc
)
)
{
if
(
TextEditor
*
textEditor
=
textControlElement
-
>
GetTextEditorWithoutCreation
(
)
)
{
if
(
Element
*
anonymousDivElement
=
textEditor
-
>
GetRoot
(
)
)
{
presContext
-
>
EventStateManager
(
)
-
>
TextControlRootAdded
(
*
anonymousDivElement
*
textControlElement
)
;
}
}
}
}
mFrame
-
>
FinishedInitializer
(
)
;
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
nsTextControlFrame
:
:
nsAnonDivObserver
nsIMutationObserver
)
void
nsTextControlFrame
:
:
nsAnonDivObserver
:
:
CharacterDataChanged
(
nsIContent
*
aContent
const
CharacterDataChangeInfo
&
)
{
mFrame
.
ClearCachedValue
(
)
;
}
void
nsTextControlFrame
:
:
nsAnonDivObserver
:
:
ContentAppended
(
nsIContent
*
aFirstNewContent
)
{
mFrame
.
ClearCachedValue
(
)
;
}
void
nsTextControlFrame
:
:
nsAnonDivObserver
:
:
ContentInserted
(
nsIContent
*
aChild
)
{
mFrame
.
ClearCachedValue
(
)
;
}
void
nsTextControlFrame
:
:
nsAnonDivObserver
:
:
ContentRemoved
(
nsIContent
*
aChild
nsIContent
*
aPreviousSibling
)
{
mFrame
.
ClearCachedValue
(
)
;
}
