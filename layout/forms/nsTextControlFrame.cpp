#
include
"
mozilla
/
DebugOnly
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsFontMetrics
.
h
"
#
include
"
nsTextControlFrame
.
h
"
#
include
"
nsIPlaintextEditor
.
h
"
#
include
"
nsCaret
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsGenericHTMLElement
.
h
"
#
include
"
nsIEditor
.
h
"
#
include
"
nsTextFragment
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsCheckboxRadioFrame
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
<
algorithm
>
#
include
"
nsRange
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsPIDOMWindow
.
h
"
#
include
"
nsQueryObject
.
h
"
#
include
"
nsILayoutHistoryState
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
PresState
.
h
"
#
include
"
nsAttrValueInlines
.
h
"
#
include
"
mozilla
/
dom
/
Selection
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsTextNode
.
h
"
#
include
"
mozilla
/
dom
/
HTMLInputElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLTextAreaElement
.
h
"
#
include
"
mozilla
/
dom
/
ScriptSettings
.
h
"
#
include
"
mozilla
/
dom
/
Text
.
h
"
#
include
"
mozilla
/
MathAlgorithms
.
h
"
#
include
"
nsFrameSelection
.
h
"
#
define
DEFAULT_COLUMN_WIDTH
20
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
nsIFrame
*
NS_NewTextControlFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsTextControlFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsTextControlFrame
)
NS_QUERYFRAME_HEAD
(
nsTextControlFrame
)
NS_QUERYFRAME_ENTRY
(
nsIFormControlFrame
)
NS_QUERYFRAME_ENTRY
(
nsIAnonymousContentCreator
)
NS_QUERYFRAME_ENTRY
(
nsITextControlFrame
)
NS_QUERYFRAME_ENTRY
(
nsIStatefulFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsContainerFrame
)
#
ifdef
ACCESSIBILITY
a11y
:
:
AccType
nsTextControlFrame
:
:
AccessibleType
(
)
{
return
a11y
:
:
eHTMLTextFieldType
;
}
#
endif
#
ifdef
DEBUG
class
EditorInitializerEntryTracker
{
public
:
explicit
EditorInitializerEntryTracker
(
nsTextControlFrame
&
frame
)
:
mFrame
(
frame
)
mFirstEntry
(
false
)
{
if
(
!
mFrame
.
mInEditorInitialization
)
{
mFrame
.
mInEditorInitialization
=
true
;
mFirstEntry
=
true
;
}
}
~
EditorInitializerEntryTracker
(
)
{
if
(
mFirstEntry
)
{
mFrame
.
mInEditorInitialization
=
false
;
}
}
bool
EnteredMoreThanOnce
(
)
const
{
return
!
mFirstEntry
;
}
private
:
nsTextControlFrame
&
mFrame
;
bool
mFirstEntry
;
}
;
#
endif
class
nsTextControlFrame
:
:
nsAnonDivObserver
final
:
public
nsStubMutationObserver
{
public
:
explicit
nsAnonDivObserver
(
nsTextControlFrame
&
aFrame
)
:
mFrame
(
aFrame
)
{
}
NS_DECL_ISUPPORTS
NS_DECL_NSIMUTATIONOBSERVER_CHARACTERDATACHANGED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTAPPENDED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTINSERTED
NS_DECL_NSIMUTATIONOBSERVER_CONTENTREMOVED
private
:
~
nsAnonDivObserver
(
)
{
}
nsTextControlFrame
&
mFrame
;
}
;
nsTextControlFrame
:
:
nsTextControlFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
:
nsContainerFrame
(
aStyle
aPresContext
kClassID
)
mFirstBaseline
(
NS_INTRINSIC_ISIZE_UNKNOWN
)
mEditorHasBeenInitialized
(
false
)
mIsProcessing
(
false
)
#
ifdef
DEBUG
mInEditorInitialization
(
false
)
#
endif
{
ClearCachedValue
(
)
;
}
nsTextControlFrame
:
:
~
nsTextControlFrame
(
)
{
}
void
nsTextControlFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
{
mScrollEvent
.
Revoke
(
)
;
DeleteProperty
(
TextControlInitializer
(
)
)
;
nsCOMPtr
<
nsITextControlElement
>
txtCtrl
=
do_QueryInterface
(
GetContent
(
)
)
;
NS_ASSERTION
(
txtCtrl
"
Content
not
a
text
control
element
"
)
;
txtCtrl
-
>
UnbindFromFrame
(
this
)
;
nsCheckboxRadioFrame
:
:
RegUnRegAccessKey
(
static_cast
<
nsIFrame
*
>
(
this
)
false
)
;
if
(
mMutationObserver
)
{
mRootNode
-
>
RemoveMutationObserver
(
mMutationObserver
)
;
mMutationObserver
=
nullptr
;
}
aPostDestroyData
.
AddAnonymousContent
(
mRootNode
.
forget
(
)
)
;
aPostDestroyData
.
AddAnonymousContent
(
mPlaceholderDiv
.
forget
(
)
)
;
aPostDestroyData
.
AddAnonymousContent
(
mPreviewDiv
.
forget
(
)
)
;
nsContainerFrame
:
:
DestroyFrom
(
aDestructRoot
aPostDestroyData
)
;
}
LogicalSize
nsTextControlFrame
:
:
CalcIntrinsicSize
(
gfxContext
*
aRenderingContext
WritingMode
aWM
float
aFontSizeInflation
)
const
{
LogicalSize
intrinsicSize
(
aWM
)
;
nscoord
lineHeight
=
0
;
nscoord
charWidth
=
0
;
nscoord
charMaxAdvance
=
0
;
RefPtr
<
nsFontMetrics
>
fontMet
=
nsLayoutUtils
:
:
GetFontMetricsForFrame
(
this
aFontSizeInflation
)
;
lineHeight
=
ReflowInput
:
:
CalcLineHeight
(
GetContent
(
)
Style
(
)
PresContext
(
)
NS_UNCONSTRAINEDSIZE
aFontSizeInflation
)
;
charWidth
=
fontMet
-
>
AveCharWidth
(
)
;
charMaxAdvance
=
fontMet
-
>
MaxAdvance
(
)
;
int32_t
cols
=
GetCols
(
)
;
intrinsicSize
.
ISize
(
aWM
)
=
cols
*
charWidth
;
if
(
mozilla
:
:
Abs
(
charWidth
-
charMaxAdvance
)
>
(
unsigned
)
nsPresContext
:
:
CSSPixelsToAppUnits
(
1
)
)
{
nscoord
internalPadding
=
std
:
:
max
(
0
charMaxAdvance
-
nsPresContext
:
:
CSSPixelsToAppUnits
(
4
)
)
;
nscoord
t
=
nsPresContext
:
:
CSSPixelsToAppUnits
(
1
)
;
nscoord
rest
=
internalPadding
%
t
;
if
(
rest
<
t
-
rest
)
{
internalPadding
-
=
rest
;
}
else
{
internalPadding
+
=
t
-
rest
;
}
intrinsicSize
.
ISize
(
aWM
)
+
=
internalPadding
;
}
else
{
if
(
PresContext
(
)
-
>
CompatibilityMode
(
)
=
=
eCompatibility_FullStandards
)
{
intrinsicSize
.
ISize
(
aWM
)
+
=
1
;
}
}
{
const
StyleLength
&
letterSpacing
=
StyleText
(
)
-
>
mLetterSpacing
;
if
(
!
letterSpacing
.
IsZero
(
)
)
{
intrinsicSize
.
ISize
(
aWM
)
+
=
cols
*
letterSpacing
.
ToAppUnits
(
)
;
}
}
intrinsicSize
.
BSize
(
aWM
)
=
lineHeight
*
GetRows
(
)
;
if
(
IsTextArea
(
)
)
{
nsIFrame
*
first
=
PrincipalChildList
(
)
.
FirstChild
(
)
;
nsIScrollableFrame
*
scrollableFrame
=
do_QueryFrame
(
first
)
;
NS_ASSERTION
(
scrollableFrame
"
Child
must
be
scrollable
"
)
;
if
(
scrollableFrame
)
{
LogicalMargin
scrollbarSizes
(
aWM
scrollableFrame
-
>
GetDesiredScrollbarSizes
(
PresContext
(
)
aRenderingContext
)
)
;
intrinsicSize
.
ISize
(
aWM
)
+
=
scrollbarSizes
.
IStartEnd
(
aWM
)
;
intrinsicSize
.
BSize
(
aWM
)
+
=
scrollbarSizes
.
BStartEnd
(
aWM
)
;
}
}
return
intrinsicSize
;
}
nsresult
nsTextControlFrame
:
:
EnsureEditorInitialized
(
)
{
if
(
mEditorHasBeenInitialized
)
return
NS_OK
;
Document
*
doc
=
mContent
-
>
GetComposedDoc
(
)
;
NS_ENSURE_TRUE
(
doc
NS_ERROR_FAILURE
)
;
AutoWeakFrame
weakFrame
(
this
)
;
doc
-
>
FlushPendingNotifications
(
FlushType
:
:
ContentAndNotify
)
;
NS_ENSURE_TRUE
(
weakFrame
.
IsAlive
(
)
NS_ERROR_FAILURE
)
;
{
nsCOMPtr
<
nsITextControlElement
>
txtCtrl
=
do_QueryInterface
(
GetContent
(
)
)
;
MOZ_ASSERT
(
txtCtrl
"
Content
not
a
text
control
element
"
)
;
AutoHideSelectionChanges
hideSelectionChanges
(
txtCtrl
-
>
GetConstFrameSelection
(
)
)
;
nsAutoScriptBlocker
scriptBlocker
;
mozilla
:
:
dom
:
:
AutoNoJSAPI
nojsapi
;
class
EnsureSetFocus
{
public
:
explicit
EnsureSetFocus
(
nsTextControlFrame
*
aFrame
)
:
mFrame
(
aFrame
)
{
}
~
EnsureSetFocus
(
)
{
if
(
nsContentUtils
:
:
IsFocusedContent
(
mFrame
-
>
GetContent
(
)
)
)
mFrame
-
>
SetFocus
(
true
false
)
;
}
private
:
nsTextControlFrame
*
mFrame
;
}
;
EnsureSetFocus
makeSureSetFocusHappens
(
this
)
;
#
ifdef
DEBUG
const
EditorInitializerEntryTracker
tracker
(
*
this
)
;
NS_ASSERTION
(
!
tracker
.
EnteredMoreThanOnce
(
)
"
EnsureEditorInitialized
has
been
called
while
a
previous
"
"
call
was
in
progress
"
)
;
#
endif
nsresult
rv
=
txtCtrl
-
>
CreateEditor
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
NS_ENSURE_STATE
(
weakFrame
.
IsAlive
(
)
)
;
mEditorHasBeenInitialized
=
true
;
if
(
weakFrame
.
IsAlive
(
)
)
{
uint32_t
position
=
0
;
if
(
txtCtrl
-
>
ValueChanged
(
)
)
{
nsAutoString
val
;
txtCtrl
-
>
GetTextEditorValue
(
val
true
)
;
position
=
val
.
Length
(
)
;
}
SetSelectionEndPoints
(
position
position
)
;
}
}
NS_ENSURE_STATE
(
weakFrame
.
IsAlive
(
)
)
;
return
NS_OK
;
}
already_AddRefed
<
Element
>
nsTextControlFrame
:
:
CreateEmptyAnonymousDiv
(
AnonymousDivType
aAnonymousDivType
)
const
{
Document
*
doc
=
PresContext
(
)
-
>
Document
(
)
;
RefPtr
<
mozilla
:
:
dom
:
:
NodeInfo
>
nodeInfo
=
doc
-
>
NodeInfoManager
(
)
-
>
GetNodeInfo
(
nsGkAtoms
:
:
div
nullptr
kNameSpaceID_XHTML
nsINode
:
:
ELEMENT_NODE
)
;
RefPtr
<
Element
>
divElement
=
NS_NewHTMLDivElement
(
nodeInfo
.
forget
(
)
)
;
switch
(
aAnonymousDivType
)
{
case
AnonymousDivType
:
:
Root
:
{
divElement
-
>
SetIsNativeAnonymousRoot
(
)
;
divElement
-
>
SetFlags
(
NODE_IS_EDITABLE
)
;
nsAutoString
classValue
;
classValue
.
AppendLiteral
(
"
anonymous
-
div
"
)
;
if
(
!
IsSingleLineTextControl
(
)
)
{
const
nsStyleDisplay
*
disp
=
StyleDisplay
(
)
;
if
(
disp
-
>
mOverflowX
!
=
StyleOverflow
:
:
Visible
&
&
disp
-
>
mOverflowX
!
=
StyleOverflow
:
:
MozHiddenUnscrollable
)
{
classValue
.
AppendLiteral
(
"
inherit
-
overflow
"
)
;
}
}
nsresult
rv
=
divElement
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_class
classValue
false
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
nullptr
;
}
break
;
}
case
AnonymousDivType
:
:
Placeholder
:
divElement
-
>
SetPseudoElementType
(
PseudoStyleType
:
:
placeholder
)
;
break
;
case
AnonymousDivType
:
:
Preview
:
divElement
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
_class
NS_LITERAL_STRING
(
"
preview
-
div
"
)
false
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
Unknown
anonymous
div
creation
request
"
)
;
break
;
}
return
divElement
.
forget
(
)
;
}
already_AddRefed
<
Element
>
nsTextControlFrame
:
:
CreateEmptyAnonymousDivWithTextNode
(
AnonymousDivType
aAnonymousDivType
)
const
{
RefPtr
<
Element
>
divElement
=
CreateEmptyAnonymousDiv
(
aAnonymousDivType
)
;
RefPtr
<
nsTextNode
>
textNode
=
new
nsTextNode
(
divElement
-
>
OwnerDoc
(
)
-
>
NodeInfoManager
(
)
)
;
if
(
aAnonymousDivType
!
=
AnonymousDivType
:
:
Placeholder
)
{
textNode
-
>
MarkAsMaybeModifiedFrequently
(
)
;
if
(
IsPasswordTextControl
(
)
)
{
textNode
-
>
MarkAsMaybeMasked
(
)
;
}
}
divElement
-
>
AppendChildTo
(
textNode
false
)
;
return
divElement
.
forget
(
)
;
}
nsresult
nsTextControlFrame
:
:
CreateAnonymousContent
(
nsTArray
<
ContentInfo
>
&
aElements
)
{
MOZ_ASSERT
(
mContent
"
We
should
have
a
content
!
"
)
;
AddStateBits
(
NS_FRAME_INDEPENDENT_SELECTION
)
;
nsCOMPtr
<
nsITextControlElement
>
txtCtrl
=
do_QueryInterface
(
GetContent
(
)
)
;
MOZ_ASSERT
(
txtCtrl
"
Content
not
a
text
control
element
"
)
;
nsresult
rv
=
CreateRootNode
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
txtCtrl
-
>
BindToFrame
(
this
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
aElements
.
AppendElement
(
mRootNode
)
;
CreatePlaceholderIfNeeded
(
)
;
if
(
mPlaceholderDiv
)
{
if
(
!
IsSingleLineTextControl
(
)
)
{
txtCtrl
-
>
UpdateOverlayTextVisibility
(
true
)
;
}
aElements
.
AppendElement
(
mPlaceholderDiv
)
;
}
CreatePreviewIfNeeded
(
)
;
if
(
mPreviewDiv
)
{
aElements
.
AppendElement
(
mPreviewDiv
)
;
}
rv
=
UpdateValueDisplay
(
false
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
InitializeEagerlyIfNeeded
(
)
;
return
NS_OK
;
}
bool
nsTextControlFrame
:
:
ShouldInitializeEagerly
(
)
const
{
if
(
!
IsSingleLineTextControl
(
)
)
{
return
true
;
}
nsCOMPtr
<
nsITextControlElement
>
txtCtrl
=
do_QueryInterface
(
GetContent
(
)
)
;
if
(
txtCtrl
-
>
HasCachedSelection
(
)
)
{
return
true
;
}
if
(
auto
*
htmlElement
=
nsGenericHTMLElement
:
:
FromNode
(
mContent
)
)
{
if
(
htmlElement
-
>
Spellcheck
(
)
)
{
return
true
;
}
}
return
false
;
}
void
nsTextControlFrame
:
:
InitializeEagerlyIfNeeded
(
)
{
MOZ_ASSERT
(
!
nsContentUtils
:
:
IsSafeToRunScript
(
)
"
Someone
forgot
a
script
blocker
?
"
)
;
if
(
!
ShouldInitializeEagerly
(
)
)
{
return
;
}
EditorInitializer
*
initializer
=
new
EditorInitializer
(
this
)
;
SetProperty
(
TextControlInitializer
(
)
initializer
)
;
nsContentUtils
:
:
AddScriptRunner
(
initializer
)
;
}
nsresult
nsTextControlFrame
:
:
CreateRootNode
(
)
{
MOZ_ASSERT
(
!
mRootNode
)
;
mRootNode
=
CreateEmptyAnonymousDiv
(
AnonymousDivType
:
:
Root
)
;
if
(
NS_WARN_IF
(
!
mRootNode
)
)
{
return
NS_ERROR_FAILURE
;
}
mMutationObserver
=
new
nsAnonDivObserver
(
*
this
)
;
mRootNode
-
>
AddMutationObserver
(
mMutationObserver
)
;
return
NS_OK
;
}
void
nsTextControlFrame
:
:
CreatePlaceholderIfNeeded
(
)
{
MOZ_ASSERT
(
!
mPlaceholderDiv
)
;
nsAutoString
placeholderTxt
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
placeholder
placeholderTxt
)
;
if
(
IsTextArea
(
)
)
{
nsContentUtils
:
:
PlatformToDOMLineBreaks
(
placeholderTxt
)
;
}
else
{
nsContentUtils
:
:
RemoveNewlines
(
placeholderTxt
)
;
}
if
(
placeholderTxt
.
IsEmpty
(
)
)
{
return
;
}
mPlaceholderDiv
=
CreateEmptyAnonymousDivWithTextNode
(
AnonymousDivType
:
:
Placeholder
)
;
mPlaceholderDiv
-
>
GetFirstChild
(
)
-
>
AsText
(
)
-
>
SetText
(
placeholderTxt
false
)
;
}
void
nsTextControlFrame
:
:
CreatePreviewIfNeeded
(
)
{
nsCOMPtr
<
nsITextControlElement
>
txtCtrl
=
do_QueryInterface
(
GetContent
(
)
)
;
if
(
!
txtCtrl
-
>
IsPreviewEnabled
(
)
)
{
return
;
}
mPreviewDiv
=
CreateEmptyAnonymousDivWithTextNode
(
AnonymousDivType
:
:
Preview
)
;
}
void
nsTextControlFrame
:
:
AppendAnonymousContentTo
(
nsTArray
<
nsIContent
*
>
&
aElements
uint32_t
aFilter
)
{
aElements
.
AppendElement
(
mRootNode
)
;
if
(
mPlaceholderDiv
&
&
!
(
aFilter
&
nsIContent
:
:
eSkipPlaceholderContent
)
)
{
aElements
.
AppendElement
(
mPlaceholderDiv
)
;
}
if
(
mPreviewDiv
)
{
aElements
.
AppendElement
(
mPreviewDiv
)
;
}
}
nscoord
nsTextControlFrame
:
:
GetPrefISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
result
=
0
;
DISPLAY_PREF_INLINE_SIZE
(
this
result
)
;
float
inflation
=
nsLayoutUtils
:
:
FontSizeInflationFor
(
this
)
;
WritingMode
wm
=
GetWritingMode
(
)
;
result
=
CalcIntrinsicSize
(
aRenderingContext
wm
inflation
)
.
ISize
(
wm
)
;
return
result
;
}
nscoord
nsTextControlFrame
:
:
GetMinISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
result
;
DISPLAY_MIN_INLINE_SIZE
(
this
result
)
;
result
=
GetPrefISize
(
aRenderingContext
)
;
return
result
;
}
LogicalSize
nsTextControlFrame
:
:
ComputeAutoSize
(
gfxContext
*
aRenderingContext
WritingMode
aWM
const
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
LogicalSize
&
aMargin
const
LogicalSize
&
aBorder
const
LogicalSize
&
aPadding
ComputeSizeFlags
aFlags
)
{
float
inflation
=
nsLayoutUtils
:
:
FontSizeInflationFor
(
this
)
;
LogicalSize
autoSize
=
CalcIntrinsicSize
(
aRenderingContext
aWM
inflation
)
;
const
auto
&
iSizeCoord
=
StylePosition
(
)
-
>
ISize
(
aWM
)
;
if
(
iSizeCoord
.
IsAuto
(
)
)
{
if
(
aFlags
&
ComputeSizeFlags
:
:
eIClampMarginBoxMinSize
)
{
autoSize
.
ISize
(
aWM
)
=
nsContainerFrame
:
:
ComputeAutoSize
(
aRenderingContext
aWM
aCBSize
aAvailableISize
aMargin
aBorder
aPadding
aFlags
)
.
ISize
(
aWM
)
;
}
#
ifdef
DEBUG
else
{
LogicalSize
ancestorAutoSize
=
nsContainerFrame
:
:
ComputeAutoSize
(
aRenderingContext
aWM
aCBSize
aAvailableISize
aMargin
aBorder
aPadding
aFlags
)
;
MOZ_ASSERT
(
inflation
!
=
1
.
0f
|
|
ancestorAutoSize
.
ISize
(
aWM
)
=
=
autoSize
.
ISize
(
aWM
)
"
Incorrect
size
computed
by
ComputeAutoSize
?
"
)
;
}
#
endif
}
return
autoSize
;
}
void
nsTextControlFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsTextControlFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aDesiredSize
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
if
(
mState
&
NS_FRAME_FIRST_REFLOW
)
{
nsCheckboxRadioFrame
:
:
RegUnRegAccessKey
(
this
true
)
;
}
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
LogicalSize
finalSize
(
wm
aReflowInput
.
ComputedISize
(
)
+
aReflowInput
.
ComputedLogicalBorderPadding
(
)
.
IStartEnd
(
wm
)
aReflowInput
.
ComputedBSize
(
)
+
aReflowInput
.
ComputedLogicalBorderPadding
(
)
.
BStartEnd
(
wm
)
)
;
aDesiredSize
.
SetSize
(
wm
finalSize
)
;
if
(
!
aReflowInput
.
mStyleDisplay
-
>
IsContainLayout
(
)
)
{
nscoord
lineHeight
=
aReflowInput
.
ComputedBSize
(
)
;
float
inflation
=
nsLayoutUtils
:
:
FontSizeInflationFor
(
this
)
;
if
(
!
IsSingleLineTextControl
(
)
)
{
lineHeight
=
ReflowInput
:
:
CalcLineHeight
(
GetContent
(
)
Style
(
)
PresContext
(
)
NS_UNCONSTRAINEDSIZE
inflation
)
;
}
RefPtr
<
nsFontMetrics
>
fontMet
=
nsLayoutUtils
:
:
GetFontMetricsForFrame
(
this
inflation
)
;
mFirstBaseline
=
nsLayoutUtils
:
:
GetCenteredFontBaseline
(
fontMet
lineHeight
wm
.
IsLineInverted
(
)
)
+
aReflowInput
.
ComputedLogicalBorderPadding
(
)
.
BStart
(
wm
)
;
aDesiredSize
.
SetBlockStartAscent
(
mFirstBaseline
)
;
}
aDesiredSize
.
SetOverflowAreasToDesiredBounds
(
)
;
nsIFrame
*
kid
=
mFrames
.
FirstChild
(
)
;
while
(
kid
)
{
ReflowTextControlChild
(
kid
aPresContext
aReflowInput
aStatus
aDesiredSize
)
;
kid
=
kid
-
>
GetNextSibling
(
)
;
}
FinishAndStoreOverflow
(
&
aDesiredSize
)
;
aStatus
.
Reset
(
)
;
NS_FRAME_SET_TRUNCATION
(
aStatus
aReflowInput
aDesiredSize
)
;
}
void
nsTextControlFrame
:
:
ReflowTextControlChild
(
nsIFrame
*
aKid
nsPresContext
*
aPresContext
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
ReflowOutput
&
aParentDesiredSize
)
{
WritingMode
wm
=
aKid
-
>
GetWritingMode
(
)
;
LogicalSize
availSize
=
aReflowInput
.
ComputedSizeWithPadding
(
wm
)
;
availSize
.
BSize
(
wm
)
=
NS_UNCONSTRAINEDSIZE
;
ReflowInput
kidReflowInput
(
aPresContext
aReflowInput
aKid
availSize
Nothing
(
)
ReflowInput
:
:
CALLER_WILL_INIT
)
;
kidReflowInput
.
Init
(
aPresContext
Nothing
(
)
nullptr
&
aReflowInput
.
ComputedPhysicalPadding
(
)
)
;
kidReflowInput
.
SetComputedWidth
(
aReflowInput
.
ComputedWidth
(
)
)
;
kidReflowInput
.
SetComputedHeight
(
aReflowInput
.
ComputedHeight
(
)
)
;
nscoord
xOffset
=
aReflowInput
.
ComputedPhysicalBorderPadding
(
)
.
left
-
aReflowInput
.
ComputedPhysicalPadding
(
)
.
left
;
nscoord
yOffset
=
aReflowInput
.
ComputedPhysicalBorderPadding
(
)
.
top
-
aReflowInput
.
ComputedPhysicalPadding
(
)
.
top
;
ReflowOutput
desiredSize
(
aReflowInput
)
;
ReflowChild
(
aKid
aPresContext
desiredSize
kidReflowInput
xOffset
yOffset
0
aStatus
)
;
FinishReflowChild
(
aKid
aPresContext
desiredSize
&
kidReflowInput
xOffset
yOffset
0
)
;
aParentDesiredSize
.
mOverflowAreas
.
UnionWith
(
desiredSize
.
mOverflowAreas
)
;
}
nsSize
nsTextControlFrame
:
:
GetXULMinSize
(
nsBoxLayoutState
&
aState
)
{
return
nsBox
:
:
GetXULMinSize
(
aState
)
;
}
bool
nsTextControlFrame
:
:
IsXULCollapsed
(
)
{
return
false
;
}
NS_IMETHODIMP
nsTextControlFrame
:
:
ScrollOnFocusEvent
:
:
Run
(
)
{
if
(
mFrame
)
{
nsCOMPtr
<
nsITextControlElement
>
txtCtrl
=
do_QueryInterface
(
mFrame
-
>
GetContent
(
)
)
;
NS_ASSERTION
(
txtCtrl
"
Content
not
a
text
control
element
"
)
;
nsISelectionController
*
selCon
=
txtCtrl
-
>
GetSelectionController
(
)
;
if
(
selCon
)
{
mFrame
-
>
mScrollEvent
.
Forget
(
)
;
selCon
-
>
ScrollSelectionIntoView
(
nsISelectionController
:
:
SELECTION_NORMAL
nsISelectionController
:
:
SELECTION_FOCUS_REGION
nsISelectionController
:
:
SCROLL_SYNCHRONOUS
)
;
}
}
return
NS_OK
;
}
void
nsTextControlFrame
:
:
SetFocus
(
bool
aOn
bool
aRepaint
)
{
nsCOMPtr
<
nsITextControlElement
>
txtCtrl
=
do_QueryInterface
(
GetContent
(
)
)
;
NS_ASSERTION
(
txtCtrl
"
Content
not
a
text
control
element
"
)
;
mScrollEvent
.
Revoke
(
)
;
if
(
mPlaceholderDiv
)
{
txtCtrl
-
>
UpdateOverlayTextVisibility
(
true
)
;
}
if
(
!
aOn
)
{
return
;
}
nsISelectionController
*
selCon
=
txtCtrl
-
>
GetSelectionController
(
)
;
if
(
!
selCon
)
{
return
;
}
RefPtr
<
Selection
>
ourSel
=
selCon
-
>
GetSelection
(
nsISelectionController
:
:
SELECTION_NORMAL
)
;
if
(
!
ourSel
)
{
return
;
}
mozilla
:
:
PresShell
*
presShell
=
PresContext
(
)
-
>
GetPresShell
(
)
;
RefPtr
<
nsCaret
>
caret
=
presShell
-
>
GetCaret
(
)
;
if
(
!
caret
)
{
return
;
}
Selection
*
caretSelection
=
caret
-
>
GetSelection
(
)
;
const
bool
isFocusedRightNow
=
ourSel
=
=
caretSelection
;
if
(
!
isFocusedRightNow
)
{
uint32_t
lastFocusMethod
=
0
;
Document
*
doc
=
GetContent
(
)
-
>
GetComposedDoc
(
)
;
if
(
doc
)
{
nsIFocusManager
*
fm
=
nsFocusManager
:
:
GetFocusManager
(
)
;
if
(
fm
)
{
fm
-
>
GetLastFocusMethod
(
doc
-
>
GetWindow
(
)
&
lastFocusMethod
)
;
}
}
if
(
!
(
lastFocusMethod
&
nsIFocusManager
:
:
FLAG_BYMOUSE
)
)
{
RefPtr
<
ScrollOnFocusEvent
>
event
=
new
ScrollOnFocusEvent
(
this
)
;
nsresult
rv
=
mContent
-
>
OwnerDoc
(
)
-
>
Dispatch
(
TaskCategory
:
:
Other
do_AddRef
(
event
)
)
;
if
(
NS_SUCCEEDED
(
rv
)
)
{
mScrollEvent
=
std
:
:
move
(
event
)
;
}
}
}
caret
-
>
SetSelection
(
ourSel
)
;
RefPtr
<
Selection
>
docSel
=
presShell
-
>
GetSelection
(
nsISelectionController
:
:
SELECTION_NORMAL
)
;
if
(
!
docSel
)
{
return
;
}
if
(
!
docSel
-
>
IsCollapsed
(
)
)
{
docSel
-
>
RemoveAllRanges
(
IgnoreErrors
(
)
)
;
}
}
nsresult
nsTextControlFrame
:
:
SetFormProperty
(
nsAtom
*
aName
const
nsAString
&
aValue
)
{
if
(
!
mIsProcessing
)
{
mIsProcessing
=
true
;
if
(
nsGkAtoms
:
:
select
=
=
aName
)
{
AutoWeakFrame
weakThis
=
this
;
SelectAllOrCollapseToEndOfText
(
true
)
;
if
(
!
weakThis
.
IsAlive
(
)
)
{
return
NS_OK
;
}
}
mIsProcessing
=
false
;
}
return
NS_OK
;
}
NS_IMETHODIMP_
(
already_AddRefed
<
TextEditor
>
)
nsTextControlFrame
:
:
GetTextEditor
(
)
{
if
(
NS_WARN_IF
(
NS_FAILED
(
EnsureEditorInitialized
(
)
)
)
)
{
return
nullptr
;
}
nsCOMPtr
<
nsITextControlElement
>
txtCtrl
=
do_QueryInterface
(
GetContent
(
)
)
;
MOZ_ASSERT
(
txtCtrl
"
Content
not
a
text
control
element
"
)
;
RefPtr
<
TextEditor
>
textEditor
=
txtCtrl
-
>
GetTextEditor
(
)
;
return
textEditor
.
forget
(
)
;
}
nsresult
nsTextControlFrame
:
:
SetSelectionInternal
(
nsINode
*
aStartNode
uint32_t
aStartOffset
nsINode
*
aEndNode
uint32_t
aEndOffset
nsITextControlFrame
:
:
SelectionDirection
aDirection
)
{
RefPtr
<
nsRange
>
range
=
new
nsRange
(
mContent
)
;
nsresult
rv
=
range
-
>
SetStartAndEnd
(
aStartNode
aStartOffset
aEndNode
aEndOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
nsCOMPtr
<
nsITextControlElement
>
txtCtrl
=
do_QueryInterface
(
GetContent
(
)
)
;
NS_ASSERTION
(
txtCtrl
"
Content
not
a
text
control
element
"
)
;
nsISelectionController
*
selCon
=
txtCtrl
-
>
GetSelectionController
(
)
;
NS_ENSURE_TRUE
(
selCon
NS_ERROR_FAILURE
)
;
RefPtr
<
Selection
>
selection
=
selCon
-
>
GetSelection
(
nsISelectionController
:
:
SELECTION_NORMAL
)
;
NS_ENSURE_TRUE
(
selection
NS_ERROR_FAILURE
)
;
nsDirection
direction
;
if
(
aDirection
=
=
eNone
)
{
direction
=
selection
-
>
GetDirection
(
)
;
}
else
{
direction
=
(
aDirection
=
=
eBackward
)
?
eDirPrevious
:
eDirNext
;
}
ErrorResult
err
;
selection
-
>
RemoveAllRanges
(
err
)
;
if
(
NS_WARN_IF
(
err
.
Failed
(
)
)
)
{
return
err
.
StealNSResult
(
)
;
}
selection
-
>
AddRangeAndSelectFramesAndNotifyListeners
(
*
range
err
)
;
if
(
NS_WARN_IF
(
err
.
Failed
(
)
)
)
{
return
err
.
StealNSResult
(
)
;
}
selection
-
>
SetDirection
(
direction
)
;
return
rv
;
}
nsresult
nsTextControlFrame
:
:
ScrollSelectionIntoView
(
)
{
nsCOMPtr
<
nsITextControlElement
>
txtCtrl
=
do_QueryInterface
(
GetContent
(
)
)
;
NS_ASSERTION
(
txtCtrl
"
Content
not
a
text
control
element
"
)
;
nsISelectionController
*
selCon
=
txtCtrl
-
>
GetSelectionController
(
)
;
if
(
selCon
)
{
return
selCon
-
>
ScrollSelectionIntoView
(
nsISelectionController
:
:
SELECTION_NORMAL
nsISelectionController
:
:
SELECTION_FOCUS_REGION
nsISelectionController
:
:
SCROLL_FIRST_ANCESTOR_ONLY
)
;
}
return
NS_ERROR_FAILURE
;
}
nsresult
nsTextControlFrame
:
:
SelectAllOrCollapseToEndOfText
(
bool
aSelect
)
{
nsresult
rv
=
EnsureEditorInitialized
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
nsCOMPtr
<
nsINode
>
rootNode
;
rootNode
=
mRootNode
;
NS_ENSURE_TRUE
(
rootNode
NS_ERROR_FAILURE
)
;
int32_t
numChildren
=
mRootNode
-
>
GetChildCount
(
)
;
if
(
numChildren
>
0
)
{
nsIContent
*
child
=
mRootNode
-
>
GetLastChild
(
)
;
if
(
child
)
{
if
(
child
-
>
IsHTMLElement
(
nsGkAtoms
:
:
br
)
)
{
child
=
child
-
>
GetPreviousSibling
(
)
;
-
-
numChildren
;
}
else
if
(
child
-
>
IsText
(
)
&
&
!
child
-
>
Length
(
)
)
{
-
-
numChildren
;
}
}
if
(
!
aSelect
&
&
numChildren
)
{
child
=
child
-
>
GetPreviousSibling
(
)
;
if
(
child
&
&
child
-
>
IsText
(
)
)
{
rootNode
=
child
;
numChildren
=
child
-
>
AsText
(
)
-
>
TextDataLength
(
)
;
}
}
}
rv
=
SetSelectionInternal
(
rootNode
aSelect
?
0
:
numChildren
rootNode
numChildren
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
return
ScrollSelectionIntoView
(
)
;
}
nsresult
nsTextControlFrame
:
:
SetSelectionEndPoints
(
uint32_t
aSelStart
uint32_t
aSelEnd
nsITextControlFrame
:
:
SelectionDirection
aDirection
)
{
NS_ASSERTION
(
aSelStart
<
=
aSelEnd
"
Invalid
selection
offsets
!
"
)
;
if
(
aSelStart
>
aSelEnd
)
return
NS_ERROR_FAILURE
;
nsCOMPtr
<
nsINode
>
startNode
endNode
;
uint32_t
startOffset
endOffset
;
nsresult
rv
=
OffsetToDOMPoint
(
aSelStart
getter_AddRefs
(
startNode
)
&
startOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aSelStart
=
=
aSelEnd
)
{
endNode
=
startNode
;
endOffset
=
startOffset
;
}
else
{
rv
=
OffsetToDOMPoint
(
aSelEnd
getter_AddRefs
(
endNode
)
&
endOffset
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
}
return
SetSelectionInternal
(
startNode
startOffset
endNode
endOffset
aDirection
)
;
}
NS_IMETHODIMP
nsTextControlFrame
:
:
SetSelectionRange
(
uint32_t
aSelStart
uint32_t
aSelEnd
nsITextControlFrame
:
:
SelectionDirection
aDirection
)
{
nsresult
rv
=
EnsureEditorInitialized
(
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
if
(
aSelStart
>
aSelEnd
)
{
aSelStart
=
aSelEnd
;
}
return
SetSelectionEndPoints
(
aSelStart
aSelEnd
aDirection
)
;
}
nsresult
nsTextControlFrame
:
:
OffsetToDOMPoint
(
uint32_t
aOffset
nsINode
*
*
aResult
uint32_t
*
aPosition
)
{
NS_ENSURE_ARG_POINTER
(
aResult
&
&
aPosition
)
;
*
aResult
=
nullptr
;
*
aPosition
=
0
;
nsresult
rv
=
EnsureEditorInitialized
(
)
;
if
(
NS_WARN_IF
(
NS_FAILED
(
rv
)
)
)
{
return
rv
;
}
RefPtr
<
Element
>
rootNode
=
mRootNode
;
NS_ENSURE_TRUE
(
rootNode
NS_ERROR_FAILURE
)
;
nsCOMPtr
<
nsINodeList
>
nodeList
=
rootNode
-
>
ChildNodes
(
)
;
uint32_t
length
=
nodeList
-
>
Length
(
)
;
NS_ASSERTION
(
length
<
=
2
"
We
should
have
one
text
node
and
one
mozBR
at
most
"
)
;
nsCOMPtr
<
nsINode
>
firstNode
=
nodeList
-
>
Item
(
0
)
;
Text
*
textNode
=
firstNode
?
firstNode
-
>
GetAsText
(
)
:
nullptr
;
if
(
length
=
=
0
)
{
rootNode
.
forget
(
aResult
)
;
*
aPosition
=
0
;
}
else
if
(
textNode
)
{
uint32_t
textLength
=
textNode
-
>
Length
(
)
;
if
(
length
=
=
2
&
&
aOffset
=
=
textLength
)
{
rootNode
.
forget
(
aResult
)
;
*
aPosition
=
1
;
}
else
{
firstNode
.
forget
(
aResult
)
;
*
aPosition
=
std
:
:
min
(
aOffset
textLength
)
;
}
}
else
{
rootNode
.
forget
(
aResult
)
;
*
aPosition
=
0
;
}
return
NS_OK
;
}
nsresult
nsTextControlFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
nsCOMPtr
<
nsITextControlElement
>
txtCtrl
=
do_QueryInterface
(
GetContent
(
)
)
;
NS_ASSERTION
(
txtCtrl
"
Content
not
a
text
control
element
"
)
;
nsISelectionController
*
selCon
=
txtCtrl
-
>
GetSelectionController
(
)
;
const
bool
needEditor
=
nsGkAtoms
:
:
maxlength
=
=
aAttribute
|
|
nsGkAtoms
:
:
readonly
=
=
aAttribute
|
|
nsGkAtoms
:
:
disabled
=
=
aAttribute
|
|
nsGkAtoms
:
:
spellcheck
=
=
aAttribute
;
RefPtr
<
TextEditor
>
textEditor
=
needEditor
?
GetTextEditor
(
)
:
nullptr
;
if
(
(
needEditor
&
&
!
textEditor
)
|
|
!
selCon
)
{
return
nsContainerFrame
:
:
AttributeChanged
(
aNameSpaceID
aAttribute
aModType
)
;
}
if
(
nsGkAtoms
:
:
maxlength
=
=
aAttribute
)
{
int32_t
maxLength
;
bool
maxDefined
=
GetMaxLength
(
&
maxLength
)
;
if
(
textEditor
)
{
if
(
maxDefined
)
{
textEditor
-
>
SetMaxTextLength
(
maxLength
)
;
}
else
{
textEditor
-
>
SetMaxTextLength
(
-
1
)
;
}
}
return
NS_OK
;
}
if
(
nsGkAtoms
:
:
readonly
=
=
aAttribute
)
{
if
(
AttributeExists
(
nsGkAtoms
:
:
readonly
)
)
{
if
(
nsContentUtils
:
:
IsFocusedContent
(
mContent
)
)
{
selCon
-
>
SetCaretEnabled
(
false
)
;
}
textEditor
-
>
AddFlags
(
nsIPlaintextEditor
:
:
eEditorReadonlyMask
)
;
}
else
{
if
(
!
textEditor
-
>
IsDisabled
(
)
&
&
nsContentUtils
:
:
IsFocusedContent
(
mContent
)
)
{
selCon
-
>
SetCaretEnabled
(
true
)
;
}
textEditor
-
>
RemoveFlags
(
nsIPlaintextEditor
:
:
eEditorReadonlyMask
)
;
}
return
NS_OK
;
}
if
(
nsGkAtoms
:
:
disabled
=
=
aAttribute
)
{
int16_t
displaySelection
=
nsISelectionController
:
:
SELECTION_OFF
;
const
bool
focused
=
nsContentUtils
:
:
IsFocusedContent
(
mContent
)
;
const
bool
hasAttr
=
AttributeExists
(
nsGkAtoms
:
:
disabled
)
;
bool
disable
;
if
(
hasAttr
)
{
disable
=
true
;
}
else
{
disable
=
false
;
displaySelection
=
focused
?
nsISelectionController
:
:
SELECTION_ON
:
nsISelectionController
:
:
SELECTION_HIDDEN
;
}
selCon
-
>
SetDisplaySelection
(
displaySelection
)
;
if
(
focused
)
{
selCon
-
>
SetCaretEnabled
(
!
hasAttr
)
;
}
if
(
disable
)
{
textEditor
-
>
AddFlags
(
nsIPlaintextEditor
:
:
eEditorDisabledMask
)
;
}
else
{
textEditor
-
>
RemoveFlags
(
nsIPlaintextEditor
:
:
eEditorDisabledMask
)
;
}
return
NS_OK
;
}
if
(
!
mEditorHasBeenInitialized
&
&
nsGkAtoms
:
:
value
=
=
aAttribute
)
{
UpdateValueDisplay
(
true
)
;
return
NS_OK
;
}
return
nsContainerFrame
:
:
AttributeChanged
(
aNameSpaceID
aAttribute
aModType
)
;
}
void
nsTextControlFrame
:
:
GetText
(
nsString
&
aText
)
{
nsCOMPtr
<
nsITextControlElement
>
txtCtrl
=
do_QueryInterface
(
GetContent
(
)
)
;
NS_ASSERTION
(
txtCtrl
"
Content
not
a
text
control
element
"
)
;
if
(
IsSingleLineTextControl
(
)
)
{
txtCtrl
-
>
GetTextEditorValue
(
aText
true
)
;
}
else
{
HTMLTextAreaElement
*
textArea
=
HTMLTextAreaElement
:
:
FromNode
(
mContent
)
;
if
(
textArea
)
{
textArea
-
>
GetValue
(
aText
)
;
}
}
}
bool
nsTextControlFrame
:
:
GetMaxLength
(
int32_t
*
aSize
)
{
*
aSize
=
-
1
;
nsGenericHTMLElement
*
content
=
nsGenericHTMLElement
:
:
FromNode
(
mContent
)
;
if
(
content
)
{
const
nsAttrValue
*
attr
=
content
-
>
GetParsedAttr
(
nsGkAtoms
:
:
maxlength
)
;
if
(
attr
&
&
attr
-
>
Type
(
)
=
=
nsAttrValue
:
:
eInteger
)
{
*
aSize
=
attr
-
>
GetIntegerValue
(
)
;
return
true
;
}
}
return
false
;
}
void
nsTextControlFrame
:
:
SetInitialChildList
(
ChildListID
aListID
nsFrameList
&
aChildList
)
{
nsContainerFrame
:
:
SetInitialChildList
(
aListID
aChildList
)
;
if
(
aListID
!
=
kPrincipalList
)
{
return
;
}
if
(
nsIFrame
*
first
=
PrincipalChildList
(
)
.
FirstChild
(
)
)
{
first
-
>
AddStateBits
(
NS_FRAME_REFLOW_ROOT
)
;
nsCOMPtr
<
nsITextControlElement
>
txtCtrl
=
do_QueryInterface
(
GetContent
(
)
)
;
NS_ASSERTION
(
txtCtrl
"
Content
not
a
text
control
element
"
)
;
txtCtrl
-
>
InitializeKeyboardEventListeners
(
)
;
nsPoint
*
contentScrollPos
=
GetProperty
(
ContentScrollPos
(
)
)
;
if
(
contentScrollPos
)
{
nsIStatefulFrame
*
statefulFrame
=
do_QueryFrame
(
first
)
;
NS_ASSERTION
(
statefulFrame
"
unexpected
type
of
frame
for
the
anonymous
div
"
)
;
UniquePtr
<
PresState
>
fakePresState
=
NewPresState
(
)
;
fakePresState
-
>
scrollState
(
)
=
*
contentScrollPos
;
statefulFrame
-
>
RestoreState
(
fakePresState
.
get
(
)
)
;
RemoveProperty
(
ContentScrollPos
(
)
)
;
delete
contentScrollPos
;
}
}
}
void
nsTextControlFrame
:
:
SetValueChanged
(
bool
aValueChanged
)
{
nsCOMPtr
<
nsITextControlElement
>
txtCtrl
=
HTMLInputElement
:
:
FromNode
(
GetContent
(
)
)
;
if
(
!
txtCtrl
)
{
txtCtrl
=
HTMLTextAreaElement
:
:
FromNode
(
GetContent
(
)
)
;
}
MOZ_ASSERT
(
txtCtrl
"
Content
not
a
text
control
element
"
)
;
if
(
mPlaceholderDiv
)
{
AutoWeakFrame
weakFrame
(
this
)
;
txtCtrl
-
>
UpdateOverlayTextVisibility
(
true
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
;
}
}
txtCtrl
-
>
SetValueChanged
(
aValueChanged
)
;
}
nsresult
nsTextControlFrame
:
:
UpdateValueDisplay
(
bool
aNotify
bool
aBeforeEditorInit
const
nsAString
*
aValue
)
{
if
(
!
IsSingleLineTextControl
(
)
)
return
NS_OK
;
MOZ_ASSERT
(
mRootNode
"
Must
have
a
div
content
\
n
"
)
;
MOZ_ASSERT
(
!
mEditorHasBeenInitialized
"
Do
not
call
this
after
editor
has
been
initialized
"
)
;
nsIContent
*
childContent
=
mRootNode
-
>
GetFirstChild
(
)
;
Text
*
textContent
;
if
(
!
childContent
)
{
RefPtr
<
nsTextNode
>
textNode
=
new
nsTextNode
(
mContent
-
>
NodeInfo
(
)
-
>
NodeInfoManager
(
)
)
;
textNode
-
>
MarkAsMaybeModifiedFrequently
(
)
;
if
(
IsPasswordTextControl
(
)
)
{
textNode
-
>
MarkAsMaybeMasked
(
)
;
}
mRootNode
-
>
AppendChildTo
(
textNode
aNotify
)
;
textContent
=
textNode
;
}
else
{
textContent
=
childContent
-
>
GetAsText
(
)
;
}
NS_ENSURE_TRUE
(
textContent
NS_ERROR_UNEXPECTED
)
;
nsCOMPtr
<
nsITextControlElement
>
txtCtrl
=
do_QueryInterface
(
GetContent
(
)
)
;
MOZ_ASSERT
(
txtCtrl
)
;
nsAutoString
value
;
if
(
aValue
)
{
value
=
*
aValue
;
}
else
{
txtCtrl
-
>
GetTextEditorValue
(
value
true
)
;
}
if
(
(
mPlaceholderDiv
|
|
mPreviewDiv
)
&
&
!
aBeforeEditorInit
)
{
AutoWeakFrame
weakFrame
(
this
)
;
txtCtrl
-
>
UpdateOverlayTextVisibility
(
aNotify
)
;
NS_ENSURE_STATE
(
weakFrame
.
IsAlive
(
)
)
;
}
if
(
aBeforeEditorInit
&
&
value
.
IsEmpty
(
)
)
{
nsIContent
*
node
=
mRootNode
-
>
GetFirstChild
(
)
;
if
(
node
)
{
mRootNode
-
>
RemoveChildNode
(
node
true
)
;
}
return
NS_OK
;
}
return
textContent
-
>
SetText
(
value
aNotify
)
;
}
NS_IMETHODIMP
nsTextControlFrame
:
:
GetOwnedSelectionController
(
nsISelectionController
*
*
aSelCon
)
{
NS_ENSURE_ARG_POINTER
(
aSelCon
)
;
nsCOMPtr
<
nsITextControlElement
>
txtCtrl
=
do_QueryInterface
(
GetContent
(
)
)
;
NS_ASSERTION
(
txtCtrl
"
Content
not
a
text
control
element
"
)
;
*
aSelCon
=
txtCtrl
-
>
GetSelectionController
(
)
;
NS_IF_ADDREF
(
*
aSelCon
)
;
return
NS_OK
;
}
nsFrameSelection
*
nsTextControlFrame
:
:
GetOwnedFrameSelection
(
)
{
nsCOMPtr
<
nsITextControlElement
>
txtCtrl
=
do_QueryInterface
(
GetContent
(
)
)
;
NS_ASSERTION
(
txtCtrl
"
Content
not
a
text
control
element
"
)
;
return
txtCtrl
-
>
GetConstFrameSelection
(
)
;
}
UniquePtr
<
PresState
>
nsTextControlFrame
:
:
SaveState
(
)
{
if
(
mRootNode
)
{
nsIStatefulFrame
*
scrollStateFrame
=
do_QueryFrame
(
mRootNode
-
>
GetPrimaryFrame
(
)
)
;
if
(
scrollStateFrame
)
{
return
scrollStateFrame
-
>
SaveState
(
)
;
}
}
return
nullptr
;
}
NS_IMETHODIMP
nsTextControlFrame
:
:
RestoreState
(
PresState
*
aState
)
{
NS_ENSURE_ARG_POINTER
(
aState
)
;
if
(
mRootNode
)
{
nsIStatefulFrame
*
scrollStateFrame
=
do_QueryFrame
(
mRootNode
-
>
GetPrimaryFrame
(
)
)
;
if
(
scrollStateFrame
)
{
return
scrollStateFrame
-
>
RestoreState
(
aState
)
;
}
}
SetProperty
(
ContentScrollPos
(
)
new
nsPoint
(
aState
-
>
scrollState
(
)
)
)
;
return
NS_OK
;
}
nsresult
nsTextControlFrame
:
:
PeekOffset
(
nsPeekOffsetStruct
*
aPos
)
{
return
NS_ERROR_FAILURE
;
}
void
nsTextControlFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
DO_GLOBAL_REFLOW_COUNT_DSP
(
"
nsTextControlFrame
"
)
;
nsCOMPtr
<
nsITextControlElement
>
txtCtrl
=
do_QueryInterface
(
GetContent
(
)
)
;
NS_ASSERTION
(
txtCtrl
"
Content
not
a
text
control
element
!
"
)
;
DisplayBorderBackgroundOutline
(
aBuilder
aLists
)
;
nsIFrame
*
kid
=
mFrames
.
FirstChild
(
)
;
nsDisplayList
*
content
=
aLists
.
Content
(
)
;
nsDisplayListSet
set
(
content
content
content
content
content
content
)
;
while
(
kid
)
{
if
(
!
(
(
kid
-
>
GetContent
(
)
=
=
mPlaceholderDiv
&
&
!
txtCtrl
-
>
GetPlaceholderVisibility
(
)
)
|
|
(
kid
-
>
GetContent
(
)
=
=
mPreviewDiv
&
&
!
txtCtrl
-
>
GetPreviewVisibility
(
)
)
)
)
{
BuildDisplayListForChild
(
aBuilder
kid
set
0
)
;
}
kid
=
kid
-
>
GetNextSibling
(
)
;
}
}
NS_IMETHODIMP
nsTextControlFrame
:
:
EditorInitializer
:
:
Run
(
)
{
if
(
!
mFrame
)
{
return
NS_OK
;
}
nsAutoScriptBlocker
scriptBlocker
;
RefPtr
<
mozilla
:
:
PresShell
>
presShell
=
mFrame
-
>
PresShell
(
)
;
bool
observes
=
presShell
-
>
ObservesNativeAnonMutationsForPrint
(
)
;
presShell
-
>
ObserveNativeAnonMutationsForPrint
(
true
)
;
mFrame
-
>
EnsureEditorInitialized
(
)
;
presShell
-
>
ObserveNativeAnonMutationsForPrint
(
observes
)
;
if
(
!
mFrame
)
{
return
NS_ERROR_FAILURE
;
}
mFrame
-
>
FinishedInitializer
(
)
;
return
NS_OK
;
}
NS_IMPL_ISUPPORTS
(
nsTextControlFrame
:
:
nsAnonDivObserver
nsIMutationObserver
)
void
nsTextControlFrame
:
:
nsAnonDivObserver
:
:
CharacterDataChanged
(
nsIContent
*
aContent
const
CharacterDataChangeInfo
&
)
{
mFrame
.
ClearCachedValue
(
)
;
}
void
nsTextControlFrame
:
:
nsAnonDivObserver
:
:
ContentAppended
(
nsIContent
*
aFirstNewContent
)
{
mFrame
.
ClearCachedValue
(
)
;
}
void
nsTextControlFrame
:
:
nsAnonDivObserver
:
:
ContentInserted
(
nsIContent
*
aChild
)
{
mFrame
.
ClearCachedValue
(
)
;
}
void
nsTextControlFrame
:
:
nsAnonDivObserver
:
:
ContentRemoved
(
nsIContent
*
aChild
nsIContent
*
aPreviousSibling
)
{
mFrame
.
ClearCachedValue
(
)
;
}
