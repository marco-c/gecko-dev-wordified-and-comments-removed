#
include
"
nsSearchControlFrame
.
h
"
#
include
"
HTMLInputElement
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsContentCreatorFunctions
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsICSSDeclaration
.
h
"
#
ifdef
ACCESSIBILITY
#
include
"
mozilla
/
a11y
/
AccTypes
.
h
"
#
endif
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
nsIFrame
*
NS_NewSearchControlFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsSearchControlFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsSearchControlFrame
)
NS_QUERYFRAME_HEAD
(
nsSearchControlFrame
)
NS_QUERYFRAME_ENTRY
(
nsSearchControlFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsTextControlFrame
)
nsSearchControlFrame
:
:
nsSearchControlFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
:
nsTextControlFrame
(
aStyle
aPresContext
kClassID
)
{
}
void
nsSearchControlFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
{
aPostDestroyData
.
AddAnonymousContent
(
mOuterWrapper
.
forget
(
)
)
;
nsTextControlFrame
:
:
DestroyFrom
(
aDestructRoot
aPostDestroyData
)
;
}
already_AddRefed
<
Element
>
nsSearchControlFrame
:
:
MakeAnonymousElement
(
Element
*
aParent
nsAtom
*
aTagName
PseudoStyleType
aPseudoType
)
{
Document
*
doc
=
mContent
-
>
OwnerDoc
(
)
;
RefPtr
<
Element
>
resultElement
=
doc
-
>
CreateHTMLElement
(
aTagName
)
;
resultElement
-
>
SetPseudoElementType
(
aPseudoType
)
;
if
(
aParent
)
{
aParent
-
>
AppendChildTo
(
resultElement
false
)
;
}
return
resultElement
.
forget
(
)
;
}
nsresult
nsSearchControlFrame
:
:
CreateAnonymousContent
(
nsTArray
<
ContentInfo
>
&
aElements
)
{
mOuterWrapper
=
MakeAnonymousElement
(
nullptr
nsGkAtoms
:
:
div
PseudoStyleType
:
:
mozComplexControlWrapper
)
;
aElements
.
AppendElement
(
mOuterWrapper
)
;
nsTArray
<
ContentInfo
>
nestedContent
;
nsTextControlFrame
:
:
CreateAnonymousContent
(
nestedContent
)
;
for
(
auto
&
content
:
nestedContent
)
{
if
(
content
.
mContent
=
=
mRootNode
)
{
mOuterWrapper
-
>
AppendChildTo
(
content
.
mContent
false
)
;
}
else
{
aElements
.
AppendElement
(
std
:
:
move
(
content
)
)
;
}
}
mClearButton
=
MakeAnonymousElement
(
mOuterWrapper
nsGkAtoms
:
:
button
PseudoStyleType
:
:
mozSearchClearButton
)
;
UpdateClearButtonState
(
)
;
return
NS_OK
;
}
void
nsSearchControlFrame
:
:
AppendAnonymousContentTo
(
nsTArray
<
nsIContent
*
>
&
aElements
uint32_t
aFilter
)
{
if
(
mOuterWrapper
)
{
aElements
.
AppendElement
(
mOuterWrapper
)
;
}
if
(
mPlaceholderDiv
)
{
aElements
.
AppendElement
(
mPlaceholderDiv
)
;
}
if
(
mPreviewDiv
)
{
aElements
.
AppendElement
(
mPreviewDiv
)
;
}
}
void
nsSearchControlFrame
:
:
UpdateClearButtonState
(
)
{
if
(
!
mClearButton
)
{
return
;
}
auto
*
content
=
HTMLInputElement
:
:
FromNode
(
mContent
)
;
nsGenericHTMLElement
*
element
=
nsGenericHTMLElement
:
:
FromNode
(
mClearButton
)
;
nsCOMPtr
<
nsICSSDeclaration
>
declaration
=
element
-
>
Style
(
)
;
if
(
content
-
>
IsValueEmpty
(
)
)
{
declaration
-
>
SetProperty
(
"
visibility
"
_ns
"
hidden
"
_ns
EmptyString
(
)
IgnoreErrors
(
)
)
;
}
else
{
nsAutoString
dummy
;
declaration
-
>
RemoveProperty
(
"
visibility
"
_ns
dummy
IgnoreErrors
(
)
)
;
}
}
