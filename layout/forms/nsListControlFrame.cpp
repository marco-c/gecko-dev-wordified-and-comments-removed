#
include
"
nscore
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsListControlFrame
.
h
"
#
include
"
HTMLSelectEventListener
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsComboboxControlFrame
.
h
"
#
include
"
nsFontMetrics
.
h
"
#
include
"
nsCSSRendering
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
HTMLOptGroupElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLOptionsCollection
.
h
"
#
include
"
mozilla
/
dom
/
HTMLSelectElement
.
h
"
#
include
"
mozilla
/
dom
/
MouseEvent
.
h
"
#
include
"
mozilla
/
dom
/
MouseEventBinding
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
StaticPrefs_browser
.
h
"
#
include
"
mozilla
/
StaticPrefs_ui
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
<
algorithm
>
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
nsListControlFrame
*
NS_NewListControlFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
nsListControlFrame
*
it
=
new
(
aPresShell
)
nsListControlFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
it
-
>
AddStateBits
(
NS_FRAME_INDEPENDENT_SELECTION
)
;
return
it
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsListControlFrame
)
nsListControlFrame
:
:
nsListControlFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
:
ScrollContainerFrame
(
aStyle
aPresContext
kClassID
false
)
mMightNeedSecondPass
(
false
)
mHasPendingInterruptAtStartOfReflow
(
false
)
mForceSelection
(
false
)
{
mChangesSinceDragStart
=
false
;
mIsAllContentHere
=
false
;
mIsAllFramesHere
=
false
;
mHasBeenInitialized
=
false
;
mNeedToReset
=
true
;
mPostChildrenLoadedReset
=
false
;
}
nsListControlFrame
:
:
~
nsListControlFrame
(
)
=
default
;
Maybe
<
nscoord
>
nsListControlFrame
:
:
GetNaturalBaselineBOffset
(
WritingMode
aWM
BaselineSharingGroup
aBaselineGroup
BaselineExportContext
)
const
{
return
Nothing
{
}
;
}
void
nsListControlFrame
:
:
Destroy
(
DestroyContext
&
aContext
)
{
NS_ENSURE_TRUE_VOID
(
mContent
)
;
mEventListener
-
>
Detach
(
)
;
ScrollContainerFrame
:
:
Destroy
(
aContext
)
;
}
void
nsListControlFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
if
(
aBuilder
-
>
IsBackgroundOnly
(
)
)
return
;
DO_GLOBAL_REFLOW_COUNT_DSP
(
"
nsListControlFrame
"
)
;
ScrollContainerFrame
:
:
BuildDisplayList
(
aBuilder
aLists
)
;
}
HTMLOptionElement
*
nsListControlFrame
:
:
GetCurrentOption
(
)
const
{
return
mEventListener
-
>
GetCurrentOption
(
)
;
}
bool
nsListControlFrame
:
:
IsFocused
(
)
const
{
return
Select
(
)
.
State
(
)
.
HasState
(
ElementState
:
:
FOCUS
)
;
}
void
nsListControlFrame
:
:
PaintFocus
(
DrawTarget
*
aDrawTarget
nsPoint
aPt
)
{
if
(
!
IsFocused
(
)
)
{
return
;
}
nsIFrame
*
containerFrame
=
GetOptionsContainer
(
)
;
if
(
!
containerFrame
)
return
;
nsIFrame
*
childframe
=
nullptr
;
nsCOMPtr
<
nsIContent
>
focusedContent
=
GetCurrentOption
(
)
;
if
(
focusedContent
)
{
childframe
=
focusedContent
-
>
GetPrimaryFrame
(
)
;
}
nsRect
fRect
;
if
(
childframe
)
{
fRect
=
childframe
-
>
GetRect
(
)
;
fRect
.
MoveBy
(
childframe
-
>
GetParent
(
)
-
>
GetOffsetTo
(
this
)
)
;
}
else
{
float
inflation
=
nsLayoutUtils
:
:
FontSizeInflationFor
(
this
)
;
fRect
.
x
=
fRect
.
y
=
0
;
if
(
GetWritingMode
(
)
.
IsVertical
(
)
)
{
fRect
.
width
=
GetScrollPortRect
(
)
.
width
;
fRect
.
height
=
CalcFallbackRowBSize
(
inflation
)
;
}
else
{
fRect
.
width
=
CalcFallbackRowBSize
(
inflation
)
;
fRect
.
height
=
GetScrollPortRect
(
)
.
height
;
}
fRect
.
MoveBy
(
containerFrame
-
>
GetOffsetTo
(
this
)
)
;
}
fRect
+
=
aPt
;
const
auto
*
domOpt
=
HTMLOptionElement
:
:
FromNodeOrNull
(
focusedContent
)
;
const
bool
isSelected
=
domOpt
&
&
domOpt
-
>
Selected
(
)
;
nscolor
color
=
LookAndFeel
:
:
Color
(
isSelected
?
LookAndFeel
:
:
ColorID
:
:
Selecteditemtext
:
LookAndFeel
:
:
ColorID
:
:
Selecteditem
this
)
;
nsCSSRendering
:
:
PaintFocus
(
PresContext
(
)
aDrawTarget
fRect
color
)
;
}
void
nsListControlFrame
:
:
InvalidateFocus
(
)
{
if
(
nsIFrame
*
containerFrame
=
GetOptionsContainer
(
)
)
{
containerFrame
-
>
InvalidateFrame
(
)
;
}
}
NS_QUERYFRAME_HEAD
(
nsListControlFrame
)
NS_QUERYFRAME_ENTRY
(
nsISelectControlFrame
)
NS_QUERYFRAME_ENTRY
(
nsListControlFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
ScrollContainerFrame
)
#
ifdef
ACCESSIBILITY
a11y
:
:
AccType
nsListControlFrame
:
:
AccessibleType
(
)
{
return
a11y
:
:
eHTMLSelectListType
;
}
#
endif
static
bool
GetMaxRowBSize
(
nsIFrame
*
aContainer
WritingMode
aWM
nscoord
*
aResult
)
{
bool
found
=
false
;
for
(
nsIFrame
*
child
:
aContainer
-
>
PrincipalChildList
(
)
)
{
if
(
child
-
>
GetContent
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
optgroup
)
)
{
auto
inner
=
child
-
>
GetContentInsertionFrame
(
)
;
if
(
inner
&
&
GetMaxRowBSize
(
inner
aWM
aResult
)
)
{
found
=
true
;
}
}
else
{
bool
isOptGroupLabel
=
child
-
>
Style
(
)
-
>
IsPseudoElement
(
)
&
&
aContainer
-
>
GetContent
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
optgroup
)
;
nscoord
childBSize
=
child
-
>
BSize
(
aWM
)
;
if
(
!
isOptGroupLabel
|
|
childBSize
>
nscoord
(
0
)
)
{
found
=
true
;
*
aResult
=
std
:
:
max
(
childBSize
*
aResult
)
;
}
}
}
return
found
;
}
nscoord
nsListControlFrame
:
:
CalcBSizeOfARow
(
)
{
nscoord
rowBSize
(
0
)
;
if
(
GetContainSizeAxes
(
)
.
mBContained
|
|
!
GetMaxRowBSize
(
GetOptionsContainer
(
)
GetWritingMode
(
)
&
rowBSize
)
)
{
float
inflation
=
nsLayoutUtils
:
:
FontSizeInflationFor
(
this
)
;
rowBSize
=
CalcFallbackRowBSize
(
inflation
)
;
}
return
rowBSize
;
}
nscoord
nsListControlFrame
:
:
IntrinsicISize
(
const
IntrinsicSizeInput
&
aInput
IntrinsicISizeType
aType
)
{
WritingMode
wm
=
GetWritingMode
(
)
;
nscoord
result
;
if
(
Maybe
<
nscoord
>
containISize
=
ContainIntrinsicISize
(
)
)
{
result
=
*
containISize
;
}
else
{
result
=
GetScrolledFrame
(
)
-
>
IntrinsicISize
(
aInput
aType
)
;
}
LogicalMargin
scrollbarSize
(
wm
GetDesiredScrollbarSizes
(
)
)
;
result
=
NSCoordSaturatingAdd
(
result
scrollbarSize
.
IStartEnd
(
wm
)
)
;
return
result
;
}
void
nsListControlFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
NS_WARNING_ASSERTION
(
aReflowInput
.
ComputedISize
(
)
!
=
NS_UNCONSTRAINEDSIZE
"
Must
have
a
computed
inline
size
"
)
;
SchedulePaint
(
)
;
mHasPendingInterruptAtStartOfReflow
=
aPresContext
-
>
HasPendingInterrupt
(
)
;
if
(
mIsAllContentHere
&
&
!
mHasBeenInitialized
)
{
if
(
!
mIsAllFramesHere
)
{
CheckIfAllFramesHere
(
)
;
}
if
(
mIsAllFramesHere
&
&
!
mHasBeenInitialized
)
{
mHasBeenInitialized
=
true
;
}
}
MarkInReflow
(
)
;
bool
autoBSize
=
(
aReflowInput
.
ComputedBSize
(
)
=
=
NS_UNCONSTRAINEDSIZE
)
;
Maybe
<
nscoord
>
containBSize
=
ContainIntrinsicBSize
(
NS_UNCONSTRAINEDSIZE
)
;
bool
usingContainBSize
=
autoBSize
&
&
containBSize
&
&
*
containBSize
!
=
NS_UNCONSTRAINEDSIZE
;
mMightNeedSecondPass
=
[
&
]
{
if
(
!
autoBSize
)
{
return
false
;
}
if
(
!
IsSubtreeDirty
(
)
&
&
!
aReflowInput
.
ShouldReflowAllKids
(
)
)
{
return
false
;
}
if
(
usingContainBSize
)
{
return
false
;
}
return
true
;
}
(
)
;
ReflowInput
state
(
aReflowInput
)
;
int32_t
length
=
GetNumberOfRows
(
)
;
nscoord
oldBSizeOfARow
=
BSizeOfARow
(
)
;
if
(
!
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
&
&
autoBSize
)
{
nscoord
computedBSize
=
CalcIntrinsicBSize
(
oldBSizeOfARow
length
)
;
computedBSize
=
state
.
ApplyMinMaxBSize
(
computedBSize
)
;
state
.
SetComputedBSize
(
computedBSize
)
;
}
if
(
usingContainBSize
)
{
state
.
SetComputedBSize
(
*
containBSize
)
;
}
ScrollContainerFrame
:
:
Reflow
(
aPresContext
aDesiredSize
state
aStatus
)
;
if
(
!
mMightNeedSecondPass
)
{
NS_ASSERTION
(
!
autoBSize
|
|
BSizeOfARow
(
)
=
=
oldBSizeOfARow
"
How
did
our
BSize
of
a
row
change
if
nothing
was
dirty
?
"
)
;
NS_ASSERTION
(
!
autoBSize
|
|
!
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
|
|
usingContainBSize
"
How
do
we
not
need
a
second
pass
during
initial
reflow
at
"
"
auto
BSize
?
"
)
;
NS_ASSERTION
(
!
IsScrollbarUpdateSuppressed
(
)
"
Shouldn
'
t
be
suppressing
if
we
don
'
t
need
a
second
pass
!
"
)
;
if
(
!
autoBSize
|
|
usingContainBSize
)
{
nscoord
rowBSize
=
CalcBSizeOfARow
(
)
;
if
(
rowBSize
=
=
0
)
{
mNumDisplayRows
=
1
;
}
else
{
mNumDisplayRows
=
std
:
:
max
(
1
state
.
ComputedBSize
(
)
/
rowBSize
)
;
}
}
return
;
}
mMightNeedSecondPass
=
false
;
if
(
!
IsScrollbarUpdateSuppressed
(
)
)
{
return
;
}
SetSuppressScrollbarUpdate
(
false
)
;
ScrollContainerFrame
:
:
DidReflow
(
aPresContext
&
state
)
;
nscoord
computedBSize
=
CalcIntrinsicBSize
(
BSizeOfARow
(
)
length
)
;
computedBSize
=
state
.
ApplyMinMaxBSize
(
computedBSize
)
;
state
.
SetComputedBSize
(
computedBSize
)
;
aStatus
.
Reset
(
)
;
ScrollContainerFrame
:
:
Reflow
(
aPresContext
aDesiredSize
state
aStatus
)
;
}
bool
nsListControlFrame
:
:
ShouldPropagateComputedBSizeToScrolledContent
(
)
const
{
return
true
;
}
nsContainerFrame
*
nsListControlFrame
:
:
GetContentInsertionFrame
(
)
{
return
GetOptionsContainer
(
)
-
>
GetContentInsertionFrame
(
)
;
}
bool
nsListControlFrame
:
:
ExtendedSelection
(
int32_t
aStartIndex
int32_t
aEndIndex
bool
aClearAll
)
{
return
SetOptionsSelectedFromFrame
(
aStartIndex
aEndIndex
true
aClearAll
)
;
}
bool
nsListControlFrame
:
:
SingleSelection
(
int32_t
aClickedIndex
bool
aDoToggle
)
{
#
ifdef
ACCESSIBILITY
nsCOMPtr
<
nsIContent
>
prevOption
=
mEventListener
-
>
GetCurrentOption
(
)
;
#
endif
bool
wasChanged
=
false
;
if
(
aDoToggle
)
{
wasChanged
=
ToggleOptionSelectedFromFrame
(
aClickedIndex
)
;
}
else
{
wasChanged
=
SetOptionsSelectedFromFrame
(
aClickedIndex
aClickedIndex
true
true
)
;
}
AutoWeakFrame
weakFrame
(
this
)
;
ScrollToIndex
(
aClickedIndex
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
wasChanged
;
}
mStartSelectionIndex
=
aClickedIndex
;
mEndSelectionIndex
=
aClickedIndex
;
InvalidateFocus
(
)
;
#
ifdef
ACCESSIBILITY
FireMenuItemActiveEvent
(
prevOption
)
;
#
endif
return
wasChanged
;
}
void
nsListControlFrame
:
:
InitSelectionRange
(
int32_t
aClickedIndex
)
{
int32_t
selectedIndex
=
GetSelectedIndex
(
)
;
if
(
selectedIndex
>
=
0
)
{
RefPtr
<
dom
:
:
HTMLOptionsCollection
>
options
=
GetOptions
(
)
;
NS_ASSERTION
(
options
"
Collection
of
options
is
null
!
"
)
;
uint32_t
numOptions
=
options
-
>
Length
(
)
;
uint32_t
i
;
for
(
i
=
selectedIndex
+
1
;
i
<
numOptions
;
i
+
+
)
{
if
(
!
options
-
>
ItemAsOption
(
i
)
-
>
Selected
(
)
)
{
break
;
}
}
if
(
aClickedIndex
<
selectedIndex
)
{
mStartSelectionIndex
=
i
-
1
;
mEndSelectionIndex
=
selectedIndex
;
}
else
{
mStartSelectionIndex
=
selectedIndex
;
mEndSelectionIndex
=
i
-
1
;
}
}
}
static
uint32_t
CountOptionsAndOptgroups
(
nsIFrame
*
aFrame
)
{
uint32_t
count
=
0
;
for
(
nsIFrame
*
child
:
aFrame
-
>
PrincipalChildList
(
)
)
{
nsIContent
*
content
=
child
-
>
GetContent
(
)
;
if
(
content
)
{
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
option
)
)
{
+
+
count
;
}
else
{
RefPtr
<
HTMLOptGroupElement
>
optgroup
=
HTMLOptGroupElement
:
:
FromNode
(
content
)
;
if
(
optgroup
)
{
nsAutoString
label
;
optgroup
-
>
GetLabel
(
label
)
;
if
(
label
.
Length
(
)
>
0
)
{
+
+
count
;
}
count
+
=
CountOptionsAndOptgroups
(
child
)
;
}
}
}
}
return
count
;
}
uint32_t
nsListControlFrame
:
:
GetNumberOfRows
(
)
{
return
:
:
CountOptionsAndOptgroups
(
GetContentInsertionFrame
(
)
)
;
}
bool
nsListControlFrame
:
:
PerformSelection
(
int32_t
aClickedIndex
bool
aIsShift
bool
aIsControl
)
{
bool
wasChanged
=
false
;
if
(
aClickedIndex
=
=
kNothingSelected
&
&
!
mForceSelection
)
{
}
else
if
(
GetMultiple
(
)
)
{
if
(
aIsShift
)
{
if
(
mStartSelectionIndex
=
=
kNothingSelected
)
{
InitSelectionRange
(
aClickedIndex
)
;
}
int32_t
startIndex
;
int32_t
endIndex
;
if
(
mStartSelectionIndex
=
=
kNothingSelected
)
{
startIndex
=
aClickedIndex
;
endIndex
=
aClickedIndex
;
}
else
if
(
mStartSelectionIndex
<
=
aClickedIndex
)
{
startIndex
=
mStartSelectionIndex
;
endIndex
=
aClickedIndex
;
}
else
{
startIndex
=
aClickedIndex
;
endIndex
=
mStartSelectionIndex
;
}
wasChanged
=
ExtendedSelection
(
startIndex
endIndex
!
aIsControl
)
;
AutoWeakFrame
weakFrame
(
this
)
;
ScrollToIndex
(
aClickedIndex
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
wasChanged
;
}
if
(
mStartSelectionIndex
=
=
kNothingSelected
)
{
mStartSelectionIndex
=
aClickedIndex
;
}
#
ifdef
ACCESSIBILITY
nsCOMPtr
<
nsIContent
>
prevOption
=
GetCurrentOption
(
)
;
#
endif
mEndSelectionIndex
=
aClickedIndex
;
InvalidateFocus
(
)
;
#
ifdef
ACCESSIBILITY
FireMenuItemActiveEvent
(
prevOption
)
;
#
endif
}
else
if
(
aIsControl
)
{
wasChanged
=
SingleSelection
(
aClickedIndex
true
)
;
}
else
{
wasChanged
=
SingleSelection
(
aClickedIndex
false
)
;
}
}
else
{
wasChanged
=
SingleSelection
(
aClickedIndex
false
)
;
}
return
wasChanged
;
}
bool
nsListControlFrame
:
:
HandleListSelection
(
dom
:
:
Event
*
aEvent
int32_t
aClickedIndex
)
{
MouseEvent
*
mouseEvent
=
aEvent
-
>
AsMouseEvent
(
)
;
bool
isControl
;
#
ifdef
XP_MACOSX
isControl
=
mouseEvent
-
>
MetaKey
(
)
;
#
else
isControl
=
mouseEvent
-
>
CtrlKey
(
)
;
#
endif
bool
isShift
=
mouseEvent
-
>
ShiftKey
(
)
;
return
PerformSelection
(
aClickedIndex
isShift
isControl
)
;
}
void
nsListControlFrame
:
:
CaptureMouseEvents
(
bool
aGrabMouseEvents
)
{
if
(
aGrabMouseEvents
)
{
PresShell
:
:
SetCapturingContent
(
mContent
CaptureFlags
:
:
IgnoreAllowedState
)
;
}
else
{
nsIContent
*
capturingContent
=
PresShell
:
:
GetCapturingContent
(
)
;
if
(
capturingContent
=
=
mContent
)
{
PresShell
:
:
ReleaseCapturingContent
(
)
;
}
}
}
nsresult
nsListControlFrame
:
:
HandleEvent
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
{
NS_ENSURE_ARG_POINTER
(
aEventStatus
)
;
if
(
nsEventStatus_eConsumeNoDefault
=
=
*
aEventStatus
)
return
NS_OK
;
if
(
IsContentDisabled
(
)
)
{
return
nsIFrame
:
:
HandleEvent
(
aPresContext
aEvent
aEventStatus
)
;
}
return
ScrollContainerFrame
:
:
HandleEvent
(
aPresContext
aEvent
aEventStatus
)
;
}
void
nsListControlFrame
:
:
SetInitialChildList
(
ChildListID
aListID
nsFrameList
&
&
aChildList
)
{
if
(
aListID
=
=
FrameChildListID
:
:
Principal
)
{
mIsAllContentHere
=
Select
(
)
.
IsDoneAddingChildren
(
)
;
if
(
!
mIsAllContentHere
)
{
mIsAllFramesHere
=
false
;
mHasBeenInitialized
=
false
;
}
}
ScrollContainerFrame
:
:
SetInitialChildList
(
aListID
std
:
:
move
(
aChildList
)
)
;
}
bool
nsListControlFrame
:
:
GetMultiple
(
)
const
{
return
mContent
-
>
AsElement
(
)
-
>
HasAttr
(
nsGkAtoms
:
:
multiple
)
;
}
HTMLSelectElement
&
nsListControlFrame
:
:
Select
(
)
const
{
return
*
static_cast
<
HTMLSelectElement
*
>
(
GetContent
(
)
)
;
}
void
nsListControlFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
ScrollContainerFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
mEventListener
=
new
HTMLSelectEventListener
(
Select
(
)
HTMLSelectEventListener
:
:
SelectType
:
:
Listbox
)
;
mStartSelectionIndex
=
kNothingSelected
;
mEndSelectionIndex
=
kNothingSelected
;
}
dom
:
:
HTMLOptionsCollection
*
nsListControlFrame
:
:
GetOptions
(
)
const
{
return
Select
(
)
.
Options
(
)
;
}
dom
:
:
HTMLOptionElement
*
nsListControlFrame
:
:
GetOption
(
uint32_t
aIndex
)
const
{
return
Select
(
)
.
Item
(
aIndex
)
;
}
NS_IMETHODIMP
nsListControlFrame
:
:
OnOptionSelected
(
int32_t
aIndex
bool
aSelected
)
{
if
(
aSelected
)
{
ScrollToIndex
(
aIndex
)
;
}
return
NS_OK
;
}
void
nsListControlFrame
:
:
OnContentReset
(
)
{
ResetList
(
true
)
;
}
void
nsListControlFrame
:
:
ResetList
(
bool
aAllowScrolling
)
{
if
(
!
mIsAllFramesHere
)
{
return
;
}
if
(
aAllowScrolling
)
{
mPostChildrenLoadedReset
=
true
;
int32_t
indexToSelect
=
kNothingSelected
;
HTMLSelectElement
*
selectElement
=
HTMLSelectElement
:
:
FromNode
(
mContent
)
;
if
(
selectElement
)
{
indexToSelect
=
selectElement
-
>
SelectedIndex
(
)
;
AutoWeakFrame
weakFrame
(
this
)
;
ScrollToIndex
(
indexToSelect
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
;
}
}
}
mStartSelectionIndex
=
kNothingSelected
;
mEndSelectionIndex
=
kNothingSelected
;
InvalidateFocus
(
)
;
}
void
nsListControlFrame
:
:
ElementStateChanged
(
ElementState
aStates
)
{
if
(
aStates
.
HasState
(
ElementState
:
:
FOCUS
)
)
{
InvalidateFocus
(
)
;
}
}
void
nsListControlFrame
:
:
GetOptionText
(
uint32_t
aIndex
nsAString
&
aStr
)
{
aStr
.
Truncate
(
)
;
if
(
dom
:
:
HTMLOptionElement
*
optionElement
=
GetOption
(
aIndex
)
)
{
optionElement
-
>
GetRenderedLabel
(
aStr
)
;
}
}
int32_t
nsListControlFrame
:
:
GetSelectedIndex
(
)
{
dom
:
:
HTMLSelectElement
*
select
=
dom
:
:
HTMLSelectElement
:
:
FromNodeOrNull
(
mContent
)
;
return
select
-
>
SelectedIndex
(
)
;
}
uint32_t
nsListControlFrame
:
:
GetNumberOfOptions
(
)
{
dom
:
:
HTMLOptionsCollection
*
options
=
GetOptions
(
)
;
if
(
!
options
)
{
return
0
;
}
return
options
-
>
Length
(
)
;
}
bool
nsListControlFrame
:
:
CheckIfAllFramesHere
(
)
{
mIsAllFramesHere
=
true
;
return
mIsAllFramesHere
;
}
NS_IMETHODIMP
nsListControlFrame
:
:
DoneAddingChildren
(
bool
aIsDone
)
{
mIsAllContentHere
=
aIsDone
;
if
(
mIsAllContentHere
)
{
if
(
!
mIsAllFramesHere
)
{
if
(
CheckIfAllFramesHere
(
)
)
{
mHasBeenInitialized
=
true
;
ResetList
(
true
)
;
}
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsListControlFrame
:
:
AddOption
(
int32_t
aIndex
)
{
if
(
!
mIsAllContentHere
)
{
mIsAllContentHere
=
Select
(
)
.
IsDoneAddingChildren
(
)
;
if
(
!
mIsAllContentHere
)
{
mIsAllFramesHere
=
false
;
mHasBeenInitialized
=
false
;
}
else
{
mIsAllFramesHere
=
(
aIndex
=
=
static_cast
<
int32_t
>
(
GetNumberOfOptions
(
)
-
1
)
)
;
}
}
mNeedToReset
=
true
;
if
(
!
mHasBeenInitialized
)
{
return
NS_OK
;
}
mPostChildrenLoadedReset
=
mIsAllContentHere
;
return
NS_OK
;
}
static
int32_t
DecrementAndClamp
(
int32_t
aSelectionIndex
int32_t
aLength
)
{
return
aLength
=
=
0
?
nsListControlFrame
:
:
kNothingSelected
:
std
:
:
max
(
0
aSelectionIndex
-
1
)
;
}
NS_IMETHODIMP
nsListControlFrame
:
:
RemoveOption
(
int32_t
aIndex
)
{
MOZ_ASSERT
(
aIndex
>
=
0
"
negative
<
option
>
index
"
)
;
if
(
mStartSelectionIndex
!
=
kNothingSelected
)
{
NS_ASSERTION
(
mEndSelectionIndex
!
=
kNothingSelected
"
"
)
;
int32_t
numOptions
=
GetNumberOfOptions
(
)
;
NS_ASSERTION
(
aIndex
<
=
numOptions
"
out
-
of
-
bounds
<
option
>
index
"
)
;
int32_t
forward
=
mEndSelectionIndex
-
mStartSelectionIndex
;
int32_t
*
low
=
forward
>
=
0
?
&
mStartSelectionIndex
:
&
mEndSelectionIndex
;
int32_t
*
high
=
forward
>
=
0
?
&
mEndSelectionIndex
:
&
mStartSelectionIndex
;
if
(
aIndex
<
*
low
)
*
low
=
:
:
DecrementAndClamp
(
*
low
numOptions
)
;
if
(
aIndex
<
=
*
high
)
*
high
=
:
:
DecrementAndClamp
(
*
high
numOptions
)
;
if
(
forward
=
=
0
)
*
low
=
*
high
;
}
else
NS_ASSERTION
(
mEndSelectionIndex
=
=
kNothingSelected
"
"
)
;
InvalidateFocus
(
)
;
return
NS_OK
;
}
bool
nsListControlFrame
:
:
SetOptionsSelectedFromFrame
(
int32_t
aStartIndex
int32_t
aEndIndex
bool
aValue
bool
aClearAll
)
{
using
OptionFlag
=
HTMLSelectElement
:
:
OptionFlag
;
RefPtr
<
HTMLSelectElement
>
selectElement
=
HTMLSelectElement
:
:
FromNode
(
mContent
)
;
HTMLSelectElement
:
:
OptionFlags
mask
=
OptionFlag
:
:
Notify
;
if
(
mForceSelection
)
{
mask
+
=
OptionFlag
:
:
SetDisabled
;
}
if
(
aValue
)
{
mask
+
=
OptionFlag
:
:
IsSelected
;
}
if
(
aClearAll
)
{
mask
+
=
OptionFlag
:
:
ClearAll
;
}
return
selectElement
-
>
SetOptionsSelectedByIndex
(
aStartIndex
aEndIndex
mask
)
;
}
bool
nsListControlFrame
:
:
ToggleOptionSelectedFromFrame
(
int32_t
aIndex
)
{
RefPtr
<
HTMLOptionElement
>
option
=
GetOption
(
static_cast
<
uint32_t
>
(
aIndex
)
)
;
NS_ENSURE_TRUE
(
option
false
)
;
RefPtr
<
HTMLSelectElement
>
selectElement
=
HTMLSelectElement
:
:
FromNode
(
mContent
)
;
HTMLSelectElement
:
:
OptionFlags
mask
=
HTMLSelectElement
:
:
OptionFlag
:
:
Notify
;
if
(
!
option
-
>
Selected
(
)
)
{
mask
+
=
HTMLSelectElement
:
:
OptionFlag
:
:
IsSelected
;
}
return
selectElement
-
>
SetOptionsSelectedByIndex
(
aIndex
aIndex
mask
)
;
}
bool
nsListControlFrame
:
:
UpdateSelection
(
)
{
if
(
mIsAllFramesHere
)
{
AutoWeakFrame
weakFrame
(
this
)
;
if
(
mIsAllContentHere
)
{
RefPtr
listener
=
mEventListener
;
listener
-
>
FireOnInputAndOnChange
(
)
;
}
return
weakFrame
.
IsAlive
(
)
;
}
return
true
;
}
NS_IMETHODIMP_
(
void
)
nsListControlFrame
:
:
OnSetSelectedIndex
(
int32_t
aOldIndex
int32_t
aNewIndex
)
{
#
ifdef
ACCESSIBILITY
nsCOMPtr
<
nsIContent
>
prevOption
=
GetCurrentOption
(
)
;
#
endif
AutoWeakFrame
weakFrame
(
this
)
;
ScrollToIndex
(
aNewIndex
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
;
}
mStartSelectionIndex
=
aNewIndex
;
mEndSelectionIndex
=
aNewIndex
;
InvalidateFocus
(
)
;
#
ifdef
ACCESSIBILITY
if
(
aOldIndex
!
=
aNewIndex
)
{
FireMenuItemActiveEvent
(
prevOption
)
;
}
#
endif
}
class
AsyncReset
final
:
public
Runnable
{
public
:
AsyncReset
(
nsListControlFrame
*
aFrame
bool
aScroll
)
:
Runnable
(
"
AsyncReset
"
)
mFrame
(
aFrame
)
mScroll
(
aScroll
)
{
}
MOZ_CAN_RUN_SCRIPT_BOUNDARY
NS_IMETHOD
Run
(
)
override
{
if
(
mFrame
.
IsAlive
(
)
)
{
static_cast
<
nsListControlFrame
*
>
(
mFrame
.
GetFrame
(
)
)
-
>
ResetList
(
mScroll
)
;
}
return
NS_OK
;
}
private
:
WeakFrame
mFrame
;
bool
mScroll
;
}
;
void
nsListControlFrame
:
:
DidReflow
(
nsPresContext
*
aPresContext
const
ReflowInput
*
aReflowInput
)
{
bool
wasInterrupted
=
!
mHasPendingInterruptAtStartOfReflow
&
&
aPresContext
-
>
HasPendingInterrupt
(
)
;
ScrollContainerFrame
:
:
DidReflow
(
aPresContext
aReflowInput
)
;
if
(
mNeedToReset
&
&
!
wasInterrupted
)
{
mNeedToReset
=
false
;
const
bool
scroll
=
!
DidHistoryRestore
(
)
|
|
mPostChildrenLoadedReset
;
nsContentUtils
:
:
AddScriptRunner
(
new
AsyncReset
(
this
scroll
)
)
;
}
mHasPendingInterruptAtStartOfReflow
=
false
;
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
nsListControlFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
u
"
ListControl
"
_ns
aResult
)
;
}
#
endif
nscoord
nsListControlFrame
:
:
GetBSizeOfARow
(
)
{
return
BSizeOfARow
(
)
;
}
bool
nsListControlFrame
:
:
IsOptionInteractivelySelectable
(
int32_t
aIndex
)
const
{
auto
&
select
=
Select
(
)
;
if
(
HTMLOptionElement
*
item
=
select
.
Item
(
aIndex
)
)
{
return
IsOptionInteractivelySelectable
(
&
select
item
)
;
}
return
false
;
}
bool
nsListControlFrame
:
:
IsOptionInteractivelySelectable
(
HTMLSelectElement
*
aSelect
HTMLOptionElement
*
aOption
)
{
return
!
aSelect
-
>
IsOptionDisabled
(
aOption
)
&
&
aOption
-
>
GetPrimaryFrame
(
)
;
}
nscoord
nsListControlFrame
:
:
CalcFallbackRowBSize
(
float
aFontSizeInflation
)
{
RefPtr
<
nsFontMetrics
>
fontMet
=
nsLayoutUtils
:
:
GetFontMetricsForFrame
(
this
aFontSizeInflation
)
;
return
fontMet
-
>
MaxHeight
(
)
;
}
nscoord
nsListControlFrame
:
:
CalcIntrinsicBSize
(
nscoord
aBSizeOfARow
int32_t
aNumberOfOptions
)
{
if
(
Style
(
)
-
>
StyleUIReset
(
)
-
>
mFieldSizing
=
=
StyleFieldSizing
:
:
Content
)
{
int32_t
length
=
GetNumberOfRows
(
)
;
return
length
*
aBSizeOfARow
;
}
mNumDisplayRows
=
Select
(
)
.
Size
(
)
;
if
(
mNumDisplayRows
<
1
)
{
mNumDisplayRows
=
4
;
}
return
mNumDisplayRows
*
aBSizeOfARow
;
}
#
ifdef
ACCESSIBILITY
void
nsListControlFrame
:
:
FireMenuItemActiveEvent
(
nsIContent
*
aPreviousOption
)
{
if
(
!
IsFocused
(
)
)
{
return
;
}
nsIContent
*
optionContent
=
GetCurrentOption
(
)
;
if
(
aPreviousOption
=
=
optionContent
)
{
return
;
}
if
(
aPreviousOption
)
{
FireDOMEvent
(
u
"
DOMMenuItemInactive
"
_ns
aPreviousOption
)
;
}
if
(
optionContent
)
{
FireDOMEvent
(
u
"
DOMMenuItemActive
"
_ns
optionContent
)
;
}
}
#
endif
nsresult
nsListControlFrame
:
:
GetIndexFromDOMEvent
(
dom
:
:
Event
*
aMouseEvent
int32_t
&
aCurIndex
)
{
if
(
PresShell
:
:
GetCapturingContent
(
)
!
=
mContent
)
{
nsPoint
pt
=
nsLayoutUtils
:
:
GetDOMEventCoordinatesRelativeTo
(
aMouseEvent
this
)
;
nsRect
borderInnerEdge
=
GetScrollPortRect
(
)
;
if
(
!
borderInnerEdge
.
Contains
(
pt
)
)
{
return
NS_ERROR_FAILURE
;
}
}
RefPtr
<
dom
:
:
HTMLOptionElement
>
option
;
for
(
nsCOMPtr
<
nsIContent
>
content
=
PresContext
(
)
-
>
EventStateManager
(
)
-
>
GetEventTargetContent
(
nullptr
)
;
content
&
&
!
option
;
content
=
content
-
>
GetParent
(
)
)
{
option
=
dom
:
:
HTMLOptionElement
:
:
FromNode
(
content
)
;
}
if
(
option
)
{
aCurIndex
=
option
-
>
Index
(
)
;
MOZ_ASSERT
(
aCurIndex
>
=
0
)
;
return
NS_OK
;
}
return
NS_ERROR_FAILURE
;
}
nsresult
nsListControlFrame
:
:
HandleLeftButtonMouseDown
(
dom
:
:
Event
*
aMouseEvent
)
{
int32_t
selectedIndex
;
if
(
NS_SUCCEEDED
(
GetIndexFromDOMEvent
(
aMouseEvent
selectedIndex
)
)
)
{
CaptureMouseEvents
(
true
)
;
AutoWeakFrame
weakFrame
(
this
)
;
bool
change
=
HandleListSelection
(
aMouseEvent
selectedIndex
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
NS_OK
;
}
mChangesSinceDragStart
=
change
;
}
return
NS_OK
;
}
nsresult
nsListControlFrame
:
:
HandleLeftButtonMouseUp
(
dom
:
:
Event
*
aMouseEvent
)
{
if
(
!
StyleVisibility
(
)
-
>
IsVisible
(
)
)
{
return
NS_OK
;
}
if
(
mChangesSinceDragStart
)
{
mChangesSinceDragStart
=
false
;
RefPtr
listener
=
mEventListener
;
listener
-
>
FireOnInputAndOnChange
(
)
;
}
return
NS_OK
;
}
nsresult
nsListControlFrame
:
:
DragMove
(
dom
:
:
Event
*
aMouseEvent
)
{
NS_ASSERTION
(
aMouseEvent
"
aMouseEvent
is
null
.
"
)
;
int32_t
selectedIndex
;
if
(
NS_SUCCEEDED
(
GetIndexFromDOMEvent
(
aMouseEvent
selectedIndex
)
)
)
{
if
(
selectedIndex
=
=
mEndSelectionIndex
)
{
return
NS_OK
;
}
MouseEvent
*
mouseEvent
=
aMouseEvent
-
>
AsMouseEvent
(
)
;
NS_ASSERTION
(
mouseEvent
"
aMouseEvent
is
not
a
MouseEvent
!
"
)
;
bool
isControl
;
#
ifdef
XP_MACOSX
isControl
=
mouseEvent
-
>
MetaKey
(
)
;
#
else
isControl
=
mouseEvent
-
>
CtrlKey
(
)
;
#
endif
AutoWeakFrame
weakFrame
(
this
)
;
bool
wasChanged
=
PerformSelection
(
selectedIndex
!
isControl
isControl
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
NS_OK
;
}
mChangesSinceDragStart
=
mChangesSinceDragStart
|
|
wasChanged
;
}
return
NS_OK
;
}
void
nsListControlFrame
:
:
ScrollToIndex
(
int32_t
aIndex
)
{
if
(
aIndex
<
0
)
{
ScrollTo
(
nsPoint
(
0
0
)
ScrollMode
:
:
Instant
)
;
}
else
{
RefPtr
<
dom
:
:
HTMLOptionElement
>
option
=
GetOption
(
AssertedCast
<
uint32_t
>
(
aIndex
)
)
;
if
(
option
)
{
ScrollToFrame
(
*
option
)
;
}
}
}
void
nsListControlFrame
:
:
ScrollToFrame
(
dom
:
:
HTMLOptionElement
&
aOptElement
)
{
if
(
nsIFrame
*
childFrame
=
aOptElement
.
GetPrimaryFrame
(
)
)
{
RefPtr
<
mozilla
:
:
PresShell
>
presShell
=
PresShell
(
)
;
presShell
-
>
ScrollFrameIntoView
(
childFrame
Nothing
(
)
ScrollAxis
(
)
ScrollAxis
(
)
ScrollFlags
:
:
ScrollOverflowHidden
|
ScrollFlags
:
:
ScrollFirstAncestorOnly
)
;
}
}
void
nsListControlFrame
:
:
UpdateSelectionAfterKeyEvent
(
int32_t
aNewIndex
uint32_t
aCharCode
bool
aIsShift
bool
aIsControlOrMeta
bool
aIsControlSelectMode
)
{
AutoWeakFrame
weakFrame
(
this
)
;
bool
wasChanged
=
false
;
if
(
aIsControlOrMeta
&
&
!
aIsShift
&
&
aCharCode
!
=
'
'
)
{
#
ifdef
ACCESSIBILITY
nsCOMPtr
<
nsIContent
>
prevOption
=
GetCurrentOption
(
)
;
#
endif
mStartSelectionIndex
=
aNewIndex
;
mEndSelectionIndex
=
aNewIndex
;
InvalidateFocus
(
)
;
ScrollToIndex
(
aNewIndex
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
;
}
#
ifdef
ACCESSIBILITY
FireMenuItemActiveEvent
(
prevOption
)
;
#
endif
}
else
if
(
aIsControlSelectMode
&
&
aCharCode
=
=
'
'
)
{
wasChanged
=
SingleSelection
(
aNewIndex
true
)
;
}
else
{
wasChanged
=
PerformSelection
(
aNewIndex
aIsShift
aIsControlOrMeta
)
;
}
if
(
wasChanged
&
&
weakFrame
.
IsAlive
(
)
)
{
UpdateSelection
(
)
;
}
}
