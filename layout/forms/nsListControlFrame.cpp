#
include
"
nscore
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsUnicharUtils
.
h
"
#
include
"
nsListControlFrame
.
h
"
#
include
"
nsCheckboxRadioFrame
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsComboboxControlFrame
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsIXULRuntime
.
h
"
#
include
"
nsFontMetrics
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsCSSRendering
.
h
"
#
include
"
nsIDOMEventListener
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
HTMLOptGroupElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLOptionsCollection
.
h
"
#
include
"
mozilla
/
dom
/
HTMLSelectElement
.
h
"
#
include
"
mozilla
/
dom
/
MouseEvent
.
h
"
#
include
"
mozilla
/
dom
/
MouseEventBinding
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
Preferences
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
<
algorithm
>
using
namespace
mozilla
;
const
uint32_t
kMaxDropDownRows
=
20
;
const
int32_t
kNothingSelected
=
-
1
;
nsListControlFrame
*
nsListControlFrame
:
:
mFocused
=
nullptr
;
nsString
*
nsListControlFrame
:
:
sIncrementalString
=
nullptr
;
#
define
INCREMENTAL_SEARCH_KEYPRESS_TIME
1000
DOMTimeStamp
nsListControlFrame
:
:
gLastKeyTime
=
0
;
class
nsListEventListener
final
:
public
nsIDOMEventListener
{
public
:
explicit
nsListEventListener
(
nsListControlFrame
*
aFrame
)
:
mFrame
(
aFrame
)
{
}
void
SetFrame
(
nsListControlFrame
*
aFrame
)
{
mFrame
=
aFrame
;
}
NS_DECL_ISUPPORTS
NS_DECL_NSIDOMEVENTLISTENER
private
:
~
nsListEventListener
(
)
{
}
nsListControlFrame
*
mFrame
;
}
;
nsContainerFrame
*
NS_NewListControlFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
nsListControlFrame
*
it
=
new
(
aPresShell
)
nsListControlFrame
(
aStyle
)
;
it
-
>
AddStateBits
(
NS_FRAME_INDEPENDENT_SELECTION
)
;
return
it
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsListControlFrame
)
nsListControlFrame
:
:
nsListControlFrame
(
ComputedStyle
*
aStyle
)
:
nsHTMLScrollFrame
(
aStyle
kClassID
false
)
mView
(
nullptr
)
mMightNeedSecondPass
(
false
)
mHasPendingInterruptAtStartOfReflow
(
false
)
mDropdownCanGrow
(
false
)
mForceSelection
(
false
)
mLastDropdownComputedBSize
(
NS_UNCONSTRAINEDSIZE
)
{
mComboboxFrame
=
nullptr
;
mChangesSinceDragStart
=
false
;
mButtonDown
=
false
;
mIsAllContentHere
=
false
;
mIsAllFramesHere
=
false
;
mHasBeenInitialized
=
false
;
mNeedToReset
=
true
;
mPostChildrenLoadedReset
=
false
;
mControlSelectMode
=
false
;
}
nsListControlFrame
:
:
~
nsListControlFrame
(
)
{
mComboboxFrame
=
nullptr
;
}
static
bool
ShouldFireDropDownEvent
(
)
{
if
(
nsLayoutUtils
:
:
IsContentSelectEnabled
(
)
)
{
return
false
;
}
return
(
XRE_IsContentProcess
(
)
&
&
Preferences
:
:
GetBool
(
"
browser
.
tabs
.
remote
.
desktopbehavior
"
false
)
)
|
|
Preferences
:
:
GetBool
(
"
dom
.
select_popup_in_parent
.
enabled
"
false
)
;
}
void
nsListControlFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
{
ENSURE_TRUE
(
mContent
)
;
mEventListener
-
>
SetFrame
(
nullptr
)
;
mContent
-
>
RemoveSystemEventListener
(
NS_LITERAL_STRING
(
"
keydown
"
)
mEventListener
false
)
;
mContent
-
>
RemoveSystemEventListener
(
NS_LITERAL_STRING
(
"
keypress
"
)
mEventListener
false
)
;
mContent
-
>
RemoveSystemEventListener
(
NS_LITERAL_STRING
(
"
mousedown
"
)
mEventListener
false
)
;
mContent
-
>
RemoveSystemEventListener
(
NS_LITERAL_STRING
(
"
mouseup
"
)
mEventListener
false
)
;
mContent
-
>
RemoveSystemEventListener
(
NS_LITERAL_STRING
(
"
mousemove
"
)
mEventListener
false
)
;
if
(
ShouldFireDropDownEvent
(
)
)
{
nsContentUtils
:
:
AddScriptRunner
(
new
AsyncEventDispatcher
(
mContent
NS_LITERAL_STRING
(
"
mozhidedropdown
"
)
CanBubble
:
:
eYes
ChromeOnlyDispatch
:
:
eYes
)
)
;
}
nsCheckboxRadioFrame
:
:
RegUnRegAccessKey
(
static_cast
<
nsIFrame
*
>
(
this
)
false
)
;
nsHTMLScrollFrame
:
:
DestroyFrom
(
aDestructRoot
aPostDestroyData
)
;
}
void
nsListControlFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
if
(
aBuilder
-
>
IsBackgroundOnly
(
)
)
return
;
DO_GLOBAL_REFLOW_COUNT_DSP
(
"
nsListControlFrame
"
)
;
if
(
IsInDropDownMode
(
)
)
{
NS_ASSERTION
(
NS_GET_A
(
mLastDropdownBackstopColor
)
=
=
255
"
need
an
opaque
backstop
color
"
)
;
aLists
.
BorderBackground
(
)
-
>
AppendToBottom
(
MakeDisplayItem
<
nsDisplaySolidColor
>
(
aBuilder
this
nsRect
(
aBuilder
-
>
ToReferenceFrame
(
this
)
GetSize
(
)
)
mLastDropdownBackstopColor
)
)
;
}
nsHTMLScrollFrame
:
:
BuildDisplayList
(
aBuilder
aLists
)
;
}
void
nsListControlFrame
:
:
PaintFocus
(
DrawTarget
*
aDrawTarget
nsPoint
aPt
)
{
if
(
mFocused
!
=
this
)
return
;
nsPresContext
*
presContext
=
PresContext
(
)
;
nsIFrame
*
containerFrame
=
GetOptionsContainer
(
)
;
if
(
!
containerFrame
)
return
;
nsIFrame
*
childframe
=
nullptr
;
nsCOMPtr
<
nsIContent
>
focusedContent
=
GetCurrentOption
(
)
;
if
(
focusedContent
)
{
childframe
=
focusedContent
-
>
GetPrimaryFrame
(
)
;
}
nsRect
fRect
;
if
(
childframe
)
{
fRect
=
childframe
-
>
GetRect
(
)
;
fRect
.
MoveBy
(
childframe
-
>
GetParent
(
)
-
>
GetOffsetTo
(
this
)
)
;
}
else
{
float
inflation
=
nsLayoutUtils
:
:
FontSizeInflationFor
(
this
)
;
fRect
.
x
=
fRect
.
y
=
0
;
if
(
GetWritingMode
(
)
.
IsVertical
(
)
)
{
fRect
.
width
=
GetScrollPortRect
(
)
.
width
;
fRect
.
height
=
CalcFallbackRowBSize
(
inflation
)
;
}
else
{
fRect
.
width
=
CalcFallbackRowBSize
(
inflation
)
;
fRect
.
height
=
GetScrollPortRect
(
)
.
height
;
}
fRect
.
MoveBy
(
containerFrame
-
>
GetOffsetTo
(
this
)
)
;
}
fRect
+
=
aPt
;
bool
lastItemIsSelected
=
false
;
HTMLOptionElement
*
domOpt
=
HTMLOptionElement
:
:
FromNodeOrNull
(
focusedContent
)
;
if
(
domOpt
)
{
lastItemIsSelected
=
domOpt
-
>
Selected
(
)
;
}
nscolor
color
=
LookAndFeel
:
:
GetColor
(
lastItemIsSelected
?
LookAndFeel
:
:
eColorID_WidgetSelectForeground
:
LookAndFeel
:
:
eColorID_WidgetSelectBackground
)
;
nsCSSRendering
:
:
PaintFocus
(
presContext
aDrawTarget
fRect
color
)
;
}
void
nsListControlFrame
:
:
InvalidateFocus
(
)
{
if
(
mFocused
!
=
this
)
return
;
nsIFrame
*
containerFrame
=
GetOptionsContainer
(
)
;
if
(
containerFrame
)
{
containerFrame
-
>
InvalidateFrame
(
)
;
}
}
NS_QUERYFRAME_HEAD
(
nsListControlFrame
)
NS_QUERYFRAME_ENTRY
(
nsIFormControlFrame
)
NS_QUERYFRAME_ENTRY
(
nsIListControlFrame
)
NS_QUERYFRAME_ENTRY
(
nsISelectControlFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsHTMLScrollFrame
)
#
ifdef
ACCESSIBILITY
a11y
:
:
AccType
nsListControlFrame
:
:
AccessibleType
(
)
{
return
a11y
:
:
eHTMLSelectListType
;
}
#
endif
static
nscoord
GetMaxOptionBSize
(
nsIFrame
*
aContainer
WritingMode
aWM
)
{
nscoord
result
=
0
;
for
(
nsIFrame
*
option
:
aContainer
-
>
PrincipalChildList
(
)
)
{
nscoord
optionBSize
;
if
(
HTMLOptGroupElement
:
:
FromNode
(
option
-
>
GetContent
(
)
)
)
{
auto
frame
=
option
-
>
GetContentInsertionFrame
(
)
;
optionBSize
=
frame
?
GetMaxOptionBSize
(
frame
aWM
)
:
0
;
}
else
{
optionBSize
=
option
-
>
BSize
(
aWM
)
;
}
if
(
result
<
optionBSize
)
result
=
optionBSize
;
}
return
result
;
}
nscoord
nsListControlFrame
:
:
CalcBSizeOfARow
(
)
{
int32_t
blockSizeOfARow
=
GetMaxOptionBSize
(
GetOptionsContainer
(
)
GetWritingMode
(
)
)
;
if
(
blockSizeOfARow
=
=
0
&
&
GetNumberOfOptions
(
)
=
=
0
)
{
float
inflation
=
nsLayoutUtils
:
:
FontSizeInflationFor
(
this
)
;
blockSizeOfARow
=
CalcFallbackRowBSize
(
inflation
)
;
}
return
blockSizeOfARow
;
}
nscoord
nsListControlFrame
:
:
GetPrefISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
result
;
DISPLAY_PREF_WIDTH
(
this
result
)
;
WritingMode
wm
=
GetWritingMode
(
)
;
result
=
GetScrolledFrame
(
)
-
>
GetPrefISize
(
aRenderingContext
)
;
LogicalMargin
scrollbarSize
(
wm
GetDesiredScrollbarSizes
(
PresContext
(
)
aRenderingContext
)
)
;
result
=
NSCoordSaturatingAdd
(
result
scrollbarSize
.
IStartEnd
(
wm
)
)
;
return
result
;
}
nscoord
nsListControlFrame
:
:
GetMinISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
result
;
DISPLAY_MIN_WIDTH
(
this
result
)
;
WritingMode
wm
=
GetWritingMode
(
)
;
result
=
GetScrolledFrame
(
)
-
>
GetMinISize
(
aRenderingContext
)
;
LogicalMargin
scrollbarSize
(
wm
GetDesiredScrollbarSizes
(
PresContext
(
)
aRenderingContext
)
)
;
result
+
=
scrollbarSize
.
IStartEnd
(
wm
)
;
return
result
;
}
void
nsListControlFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
NS_WARNING_ASSERTION
(
aReflowInput
.
ComputedISize
(
)
!
=
NS_UNCONSTRAINEDSIZE
"
Must
have
a
computed
inline
size
"
)
;
SchedulePaint
(
)
;
mHasPendingInterruptAtStartOfReflow
=
aPresContext
-
>
HasPendingInterrupt
(
)
;
if
(
mIsAllContentHere
&
&
!
mHasBeenInitialized
)
{
if
(
false
=
=
mIsAllFramesHere
)
{
CheckIfAllFramesHere
(
)
;
}
if
(
mIsAllFramesHere
&
&
!
mHasBeenInitialized
)
{
mHasBeenInitialized
=
true
;
}
}
if
(
GetStateBits
(
)
&
NS_FRAME_FIRST_REFLOW
)
{
nsCheckboxRadioFrame
:
:
RegUnRegAccessKey
(
this
true
)
;
}
if
(
IsInDropDownMode
(
)
)
{
ReflowAsDropdown
(
aPresContext
aDesiredSize
aReflowInput
aStatus
)
;
return
;
}
MarkInReflow
(
)
;
bool
autoBSize
=
(
aReflowInput
.
ComputedBSize
(
)
=
=
NS_UNCONSTRAINEDSIZE
)
;
mMightNeedSecondPass
=
autoBSize
&
&
(
NS_SUBTREE_DIRTY
(
this
)
|
|
aReflowInput
.
ShouldReflowAllKids
(
)
)
;
ReflowInput
state
(
aReflowInput
)
;
int32_t
length
=
GetNumberOfRows
(
)
;
nscoord
oldBSizeOfARow
=
BSizeOfARow
(
)
;
if
(
!
(
GetStateBits
(
)
&
NS_FRAME_FIRST_REFLOW
)
&
&
autoBSize
)
{
nscoord
computedBSize
=
CalcIntrinsicBSize
(
oldBSizeOfARow
length
)
;
computedBSize
=
state
.
ApplyMinMaxBSize
(
computedBSize
)
;
state
.
SetComputedBSize
(
computedBSize
)
;
}
nsHTMLScrollFrame
:
:
Reflow
(
aPresContext
aDesiredSize
state
aStatus
)
;
if
(
!
mMightNeedSecondPass
)
{
NS_ASSERTION
(
!
autoBSize
|
|
BSizeOfARow
(
)
=
=
oldBSizeOfARow
"
How
did
our
BSize
of
a
row
change
if
nothing
was
dirty
?
"
)
;
NS_ASSERTION
(
!
autoBSize
|
|
!
(
GetStateBits
(
)
&
NS_FRAME_FIRST_REFLOW
)
"
How
do
we
not
need
a
second
pass
during
initial
reflow
at
"
"
auto
BSize
?
"
)
;
NS_ASSERTION
(
!
IsScrollbarUpdateSuppressed
(
)
"
Shouldn
'
t
be
suppressing
if
we
don
'
t
need
a
second
pass
!
"
)
;
if
(
!
autoBSize
)
{
nscoord
rowBSize
=
CalcBSizeOfARow
(
)
;
if
(
rowBSize
=
=
0
)
{
mNumDisplayRows
=
1
;
}
else
{
mNumDisplayRows
=
std
:
:
max
(
1
state
.
ComputedBSize
(
)
/
rowBSize
)
;
}
}
return
;
}
mMightNeedSecondPass
=
false
;
if
(
!
IsScrollbarUpdateSuppressed
(
)
)
{
return
;
}
SetSuppressScrollbarUpdate
(
false
)
;
nsHTMLScrollFrame
:
:
DidReflow
(
aPresContext
&
state
)
;
nscoord
computedBSize
=
CalcIntrinsicBSize
(
BSizeOfARow
(
)
length
)
;
computedBSize
=
state
.
ApplyMinMaxBSize
(
computedBSize
)
;
state
.
SetComputedBSize
(
computedBSize
)
;
aStatus
.
Reset
(
)
;
nsHTMLScrollFrame
:
:
Reflow
(
aPresContext
aDesiredSize
state
aStatus
)
;
}
void
nsListControlFrame
:
:
ReflowAsDropdown
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MOZ_ASSERT
(
aReflowInput
.
ComputedBSize
(
)
=
=
NS_UNCONSTRAINEDSIZE
"
We
should
not
have
a
computed
block
size
here
!
"
)
;
mMightNeedSecondPass
=
NS_SUBTREE_DIRTY
(
this
)
|
|
aReflowInput
.
ShouldReflowAllKids
(
)
;
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
#
ifdef
DEBUG
nscoord
oldBSizeOfARow
=
BSizeOfARow
(
)
;
nscoord
oldVisibleBSize
=
(
GetStateBits
(
)
&
NS_FRAME_FIRST_REFLOW
)
?
NS_UNCONSTRAINEDSIZE
:
GetScrolledFrame
(
)
-
>
BSize
(
wm
)
;
#
endif
ReflowInput
state
(
aReflowInput
)
;
if
(
!
(
GetStateBits
(
)
&
NS_FRAME_FIRST_REFLOW
)
)
{
state
.
SetComputedBSize
(
mLastDropdownComputedBSize
)
;
}
nsHTMLScrollFrame
:
:
Reflow
(
aPresContext
aDesiredSize
state
aStatus
)
;
if
(
!
mMightNeedSecondPass
)
{
NS_ASSERTION
(
oldVisibleBSize
=
=
GetScrolledFrame
(
)
-
>
BSize
(
wm
)
"
How
did
our
kid
'
s
BSize
change
if
nothing
was
dirty
?
"
)
;
NS_ASSERTION
(
BSizeOfARow
(
)
=
=
oldBSizeOfARow
"
How
did
our
BSize
of
a
row
change
if
nothing
was
dirty
?
"
)
;
NS_ASSERTION
(
!
IsScrollbarUpdateSuppressed
(
)
"
Shouldn
'
t
be
suppressing
if
we
don
'
t
need
a
second
pass
!
"
)
;
NS_ASSERTION
(
!
(
GetStateBits
(
)
&
NS_FRAME_FIRST_REFLOW
)
"
How
can
we
avoid
a
second
pass
during
first
reflow
?
"
)
;
return
;
}
mMightNeedSecondPass
=
false
;
if
(
!
IsScrollbarUpdateSuppressed
(
)
)
{
NS_ASSERTION
(
!
(
GetStateBits
(
)
&
NS_FRAME_FIRST_REFLOW
)
"
How
can
we
avoid
a
second
pass
during
first
reflow
?
"
)
;
return
;
}
SetSuppressScrollbarUpdate
(
false
)
;
nscoord
visibleBSize
=
GetScrolledFrame
(
)
-
>
BSize
(
wm
)
;
nscoord
blockSizeOfARow
=
BSizeOfARow
(
)
;
nsHTMLScrollFrame
:
:
DidReflow
(
aPresContext
&
state
)
;
mDropdownCanGrow
=
false
;
if
(
visibleBSize
<
=
0
|
|
blockSizeOfARow
<
=
0
|
|
XRE_IsContentProcess
(
)
)
{
state
.
SetComputedBSize
(
blockSizeOfARow
)
;
mNumDisplayRows
=
1
;
}
else
{
nsComboboxControlFrame
*
combobox
=
static_cast
<
nsComboboxControlFrame
*
>
(
mComboboxFrame
)
;
LogicalPoint
translation
(
wm
)
;
nscoord
before
after
;
combobox
-
>
GetAvailableDropdownSpace
(
wm
&
before
&
after
&
translation
)
;
if
(
before
<
=
0
&
&
after
<
=
0
)
{
state
.
SetComputedBSize
(
blockSizeOfARow
)
;
mNumDisplayRows
=
1
;
mDropdownCanGrow
=
GetNumberOfRows
(
)
>
1
;
}
else
{
nscoord
bp
=
aReflowInput
.
ComputedLogicalBorderPadding
(
)
.
BStartEnd
(
wm
)
;
nscoord
availableBSize
=
std
:
:
max
(
before
after
)
-
bp
;
nscoord
newBSize
;
uint32_t
rows
;
if
(
visibleBSize
<
=
availableBSize
)
{
rows
=
GetNumberOfRows
(
)
;
mNumDisplayRows
=
clamped
<
uint32_t
>
(
rows
1
kMaxDropDownRows
)
;
if
(
mNumDisplayRows
=
=
rows
)
{
newBSize
=
visibleBSize
;
}
else
{
newBSize
=
mNumDisplayRows
*
blockSizeOfARow
;
newBSize
=
std
:
:
min
(
newBSize
visibleBSize
)
;
}
}
else
{
rows
=
availableBSize
/
blockSizeOfARow
;
mNumDisplayRows
=
clamped
<
uint32_t
>
(
rows
1
kMaxDropDownRows
)
;
newBSize
=
mNumDisplayRows
*
blockSizeOfARow
;
}
state
.
SetComputedBSize
(
newBSize
)
;
mDropdownCanGrow
=
visibleBSize
-
newBSize
>
=
blockSizeOfARow
&
&
mNumDisplayRows
!
=
kMaxDropDownRows
;
}
}
mLastDropdownComputedBSize
=
state
.
ComputedBSize
(
)
;
aStatus
.
Reset
(
)
;
nsHTMLScrollFrame
:
:
Reflow
(
aPresContext
aDesiredSize
state
aStatus
)
;
}
ScrollStyles
nsListControlFrame
:
:
GetScrollStyles
(
)
const
{
int32_t
style
=
IsInDropDownMode
(
)
?
NS_STYLE_OVERFLOW_AUTO
:
NS_STYLE_OVERFLOW_SCROLL
;
if
(
GetWritingMode
(
)
.
IsVertical
(
)
)
{
return
ScrollStyles
(
style
NS_STYLE_OVERFLOW_HIDDEN
)
;
}
else
{
return
ScrollStyles
(
NS_STYLE_OVERFLOW_HIDDEN
style
)
;
}
}
bool
nsListControlFrame
:
:
ShouldPropagateComputedBSizeToScrolledContent
(
)
const
{
return
!
IsInDropDownMode
(
)
;
}
nsContainerFrame
*
nsListControlFrame
:
:
GetContentInsertionFrame
(
)
{
return
GetOptionsContainer
(
)
-
>
GetContentInsertionFrame
(
)
;
}
bool
nsListControlFrame
:
:
ExtendedSelection
(
int32_t
aStartIndex
int32_t
aEndIndex
bool
aClearAll
)
{
return
SetOptionsSelectedFromFrame
(
aStartIndex
aEndIndex
true
aClearAll
)
;
}
bool
nsListControlFrame
:
:
SingleSelection
(
int32_t
aClickedIndex
bool
aDoToggle
)
{
if
(
mComboboxFrame
)
{
mComboboxFrame
-
>
UpdateRecentIndex
(
GetSelectedIndex
(
)
)
;
}
bool
wasChanged
=
false
;
if
(
aDoToggle
)
{
wasChanged
=
ToggleOptionSelectedFromFrame
(
aClickedIndex
)
;
}
else
{
wasChanged
=
SetOptionsSelectedFromFrame
(
aClickedIndex
aClickedIndex
true
true
)
;
}
AutoWeakFrame
weakFrame
(
this
)
;
ScrollToIndex
(
aClickedIndex
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
wasChanged
;
}
#
ifdef
ACCESSIBILITY
bool
isCurrentOptionChanged
=
mEndSelectionIndex
!
=
aClickedIndex
;
#
endif
mStartSelectionIndex
=
aClickedIndex
;
mEndSelectionIndex
=
aClickedIndex
;
InvalidateFocus
(
)
;
#
ifdef
ACCESSIBILITY
if
(
isCurrentOptionChanged
)
{
FireMenuItemActiveEvent
(
)
;
}
#
endif
return
wasChanged
;
}
void
nsListControlFrame
:
:
InitSelectionRange
(
int32_t
aClickedIndex
)
{
int32_t
selectedIndex
=
GetSelectedIndex
(
)
;
if
(
selectedIndex
>
=
0
)
{
RefPtr
<
dom
:
:
HTMLOptionsCollection
>
options
=
GetOptions
(
)
;
NS_ASSERTION
(
options
"
Collection
of
options
is
null
!
"
)
;
uint32_t
numOptions
=
options
-
>
Length
(
)
;
uint32_t
i
;
for
(
i
=
selectedIndex
+
1
;
i
<
numOptions
;
i
+
+
)
{
if
(
!
options
-
>
ItemAsOption
(
i
)
-
>
Selected
(
)
)
{
break
;
}
}
if
(
aClickedIndex
<
selectedIndex
)
{
mStartSelectionIndex
=
i
-
1
;
mEndSelectionIndex
=
selectedIndex
;
}
else
{
mStartSelectionIndex
=
selectedIndex
;
mEndSelectionIndex
=
i
-
1
;
}
}
}
static
uint32_t
CountOptionsAndOptgroups
(
nsIFrame
*
aFrame
)
{
uint32_t
count
=
0
;
nsFrameList
:
:
Enumerator
e
(
aFrame
-
>
PrincipalChildList
(
)
)
;
for
(
;
!
e
.
AtEnd
(
)
;
e
.
Next
(
)
)
{
nsIFrame
*
child
=
e
.
get
(
)
;
nsIContent
*
content
=
child
-
>
GetContent
(
)
;
if
(
content
)
{
if
(
content
-
>
IsHTMLElement
(
nsGkAtoms
:
:
option
)
)
{
+
+
count
;
}
else
{
RefPtr
<
HTMLOptGroupElement
>
optgroup
=
HTMLOptGroupElement
:
:
FromNode
(
content
)
;
if
(
optgroup
)
{
nsAutoString
label
;
optgroup
-
>
GetLabel
(
label
)
;
if
(
label
.
Length
(
)
>
0
)
{
+
+
count
;
}
count
+
=
CountOptionsAndOptgroups
(
child
)
;
}
}
}
}
return
count
;
}
uint32_t
nsListControlFrame
:
:
GetNumberOfRows
(
)
{
return
:
:
CountOptionsAndOptgroups
(
GetContentInsertionFrame
(
)
)
;
}
bool
nsListControlFrame
:
:
PerformSelection
(
int32_t
aClickedIndex
bool
aIsShift
bool
aIsControl
)
{
bool
wasChanged
=
false
;
if
(
aClickedIndex
=
=
kNothingSelected
&
&
!
mForceSelection
)
{
}
else
if
(
GetMultiple
(
)
)
{
if
(
aIsShift
)
{
if
(
mStartSelectionIndex
=
=
kNothingSelected
)
{
InitSelectionRange
(
aClickedIndex
)
;
}
int32_t
startIndex
;
int32_t
endIndex
;
if
(
mStartSelectionIndex
=
=
kNothingSelected
)
{
startIndex
=
aClickedIndex
;
endIndex
=
aClickedIndex
;
}
else
if
(
mStartSelectionIndex
<
=
aClickedIndex
)
{
startIndex
=
mStartSelectionIndex
;
endIndex
=
aClickedIndex
;
}
else
{
startIndex
=
aClickedIndex
;
endIndex
=
mStartSelectionIndex
;
}
wasChanged
=
ExtendedSelection
(
startIndex
endIndex
!
aIsControl
)
;
AutoWeakFrame
weakFrame
(
this
)
;
ScrollToIndex
(
aClickedIndex
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
wasChanged
;
}
if
(
mStartSelectionIndex
=
=
kNothingSelected
)
{
mStartSelectionIndex
=
aClickedIndex
;
}
#
ifdef
ACCESSIBILITY
bool
isCurrentOptionChanged
=
mEndSelectionIndex
!
=
aClickedIndex
;
#
endif
mEndSelectionIndex
=
aClickedIndex
;
InvalidateFocus
(
)
;
#
ifdef
ACCESSIBILITY
if
(
isCurrentOptionChanged
)
{
FireMenuItemActiveEvent
(
)
;
}
#
endif
}
else
if
(
aIsControl
)
{
wasChanged
=
SingleSelection
(
aClickedIndex
true
)
;
}
else
{
wasChanged
=
SingleSelection
(
aClickedIndex
false
)
;
}
}
else
{
wasChanged
=
SingleSelection
(
aClickedIndex
false
)
;
}
return
wasChanged
;
}
bool
nsListControlFrame
:
:
HandleListSelection
(
dom
:
:
Event
*
aEvent
int32_t
aClickedIndex
)
{
MouseEvent
*
mouseEvent
=
aEvent
-
>
AsMouseEvent
(
)
;
bool
isControl
;
#
ifdef
XP_MACOSX
isControl
=
mouseEvent
-
>
MetaKey
(
)
;
#
else
isControl
=
mouseEvent
-
>
CtrlKey
(
)
;
#
endif
bool
isShift
=
mouseEvent
-
>
ShiftKey
(
)
;
return
PerformSelection
(
aClickedIndex
isShift
isControl
)
;
}
void
nsListControlFrame
:
:
CaptureMouseEvents
(
bool
aGrabMouseEvents
)
{
if
(
aGrabMouseEvents
&
&
IsInDropDownMode
(
)
&
&
nsComboboxControlFrame
:
:
ToolkitHasNativePopup
(
)
)
return
;
if
(
aGrabMouseEvents
)
{
nsIPresShell
:
:
SetCapturingContent
(
mContent
CAPTURE_IGNOREALLOWED
)
;
}
else
{
nsIContent
*
capturingContent
=
nsIPresShell
:
:
GetCapturingContent
(
)
;
bool
dropDownIsHidden
=
false
;
if
(
IsInDropDownMode
(
)
)
{
dropDownIsHidden
=
!
mComboboxFrame
-
>
IsDroppedDown
(
)
;
}
if
(
capturingContent
=
=
mContent
|
|
dropDownIsHidden
)
{
nsIPresShell
:
:
SetCapturingContent
(
nullptr
0
)
;
}
}
}
nsresult
nsListControlFrame
:
:
HandleEvent
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
{
NS_ENSURE_ARG_POINTER
(
aEventStatus
)
;
if
(
nsEventStatus_eConsumeNoDefault
=
=
*
aEventStatus
)
return
NS_OK
;
if
(
IsContentDisabled
(
)
)
{
return
nsFrame
:
:
HandleEvent
(
aPresContext
aEvent
aEventStatus
)
;
}
return
nsHTMLScrollFrame
:
:
HandleEvent
(
aPresContext
aEvent
aEventStatus
)
;
}
void
nsListControlFrame
:
:
SetInitialChildList
(
ChildListID
aListID
nsFrameList
&
aChildList
)
{
if
(
aListID
=
=
kPrincipalList
)
{
mIsAllContentHere
=
mContent
-
>
IsDoneAddingChildren
(
)
;
if
(
!
mIsAllContentHere
)
{
mIsAllFramesHere
=
false
;
mHasBeenInitialized
=
false
;
}
}
nsHTMLScrollFrame
:
:
SetInitialChildList
(
aListID
aChildList
)
;
}
void
nsListControlFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
nsHTMLScrollFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
if
(
!
nsLayoutUtils
:
:
IsContentSelectEnabled
(
)
&
&
IsInDropDownMode
(
)
)
{
AddStateBits
(
NS_FRAME_IN_POPUP
)
;
CreateView
(
)
;
}
mEventListener
=
new
nsListEventListener
(
this
)
;
mContent
-
>
AddSystemEventListener
(
NS_LITERAL_STRING
(
"
keydown
"
)
mEventListener
false
false
)
;
mContent
-
>
AddSystemEventListener
(
NS_LITERAL_STRING
(
"
keypress
"
)
mEventListener
false
false
)
;
mContent
-
>
AddSystemEventListener
(
NS_LITERAL_STRING
(
"
mousedown
"
)
mEventListener
false
false
)
;
mContent
-
>
AddSystemEventListener
(
NS_LITERAL_STRING
(
"
mouseup
"
)
mEventListener
false
false
)
;
mContent
-
>
AddSystemEventListener
(
NS_LITERAL_STRING
(
"
mousemove
"
)
mEventListener
false
false
)
;
mStartSelectionIndex
=
kNothingSelected
;
mEndSelectionIndex
=
kNothingSelected
;
mLastDropdownBackstopColor
=
PresContext
(
)
-
>
DefaultBackgroundColor
(
)
;
}
dom
:
:
HTMLOptionsCollection
*
nsListControlFrame
:
:
GetOptions
(
)
const
{
dom
:
:
HTMLSelectElement
*
select
=
dom
:
:
HTMLSelectElement
:
:
FromNodeOrNull
(
mContent
)
;
NS_ENSURE_TRUE
(
select
nullptr
)
;
return
select
-
>
Options
(
)
;
}
dom
:
:
HTMLOptionElement
*
nsListControlFrame
:
:
GetOption
(
uint32_t
aIndex
)
const
{
dom
:
:
HTMLSelectElement
*
select
=
dom
:
:
HTMLSelectElement
:
:
FromNodeOrNull
(
mContent
)
;
NS_ENSURE_TRUE
(
select
nullptr
)
;
return
select
-
>
Item
(
aIndex
)
;
}
NS_IMETHODIMP
nsListControlFrame
:
:
OnOptionSelected
(
int32_t
aIndex
bool
aSelected
)
{
if
(
aSelected
)
{
ScrollToIndex
(
aIndex
)
;
}
return
NS_OK
;
}
void
nsListControlFrame
:
:
OnContentReset
(
)
{
ResetList
(
true
)
;
}
void
nsListControlFrame
:
:
ResetList
(
bool
aAllowScrolling
)
{
if
(
!
mIsAllFramesHere
)
{
return
;
}
if
(
aAllowScrolling
)
{
mPostChildrenLoadedReset
=
true
;
int32_t
indexToSelect
=
kNothingSelected
;
HTMLSelectElement
*
selectElement
=
HTMLSelectElement
:
:
FromNode
(
mContent
)
;
if
(
selectElement
)
{
indexToSelect
=
selectElement
-
>
SelectedIndex
(
)
;
AutoWeakFrame
weakFrame
(
this
)
;
ScrollToIndex
(
indexToSelect
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
;
}
}
}
mStartSelectionIndex
=
kNothingSelected
;
mEndSelectionIndex
=
kNothingSelected
;
InvalidateFocus
(
)
;
}
void
nsListControlFrame
:
:
SetFocus
(
bool
aOn
bool
aRepaint
)
{
InvalidateFocus
(
)
;
if
(
aOn
)
{
ComboboxFocusSet
(
)
;
mFocused
=
this
;
}
else
{
mFocused
=
nullptr
;
}
InvalidateFocus
(
)
;
}
void
nsListControlFrame
:
:
ComboboxFocusSet
(
)
{
gLastKeyTime
=
0
;
}
void
nsListControlFrame
:
:
SetComboboxFrame
(
nsIFrame
*
aComboboxFrame
)
{
if
(
nullptr
!
=
aComboboxFrame
)
{
mComboboxFrame
=
do_QueryFrame
(
aComboboxFrame
)
;
}
}
void
nsListControlFrame
:
:
GetOptionText
(
uint32_t
aIndex
nsAString
&
aStr
)
{
aStr
.
Truncate
(
)
;
if
(
dom
:
:
HTMLOptionElement
*
optionElement
=
GetOption
(
aIndex
)
)
{
optionElement
-
>
GetText
(
aStr
)
;
}
}
int32_t
nsListControlFrame
:
:
GetSelectedIndex
(
)
{
dom
:
:
HTMLSelectElement
*
select
=
dom
:
:
HTMLSelectElement
:
:
FromNodeOrNull
(
mContent
)
;
return
select
-
>
SelectedIndex
(
)
;
}
dom
:
:
HTMLOptionElement
*
nsListControlFrame
:
:
GetCurrentOption
(
)
{
int32_t
focusedIndex
=
(
mEndSelectionIndex
=
=
kNothingSelected
)
?
GetSelectedIndex
(
)
:
mEndSelectionIndex
;
if
(
focusedIndex
!
=
kNothingSelected
)
{
return
GetOption
(
AssertedCast
<
uint32_t
>
(
focusedIndex
)
)
;
}
return
GetNonDisabledOptionFrom
(
0
)
;
}
HTMLOptionElement
*
nsListControlFrame
:
:
GetNonDisabledOptionFrom
(
int32_t
aFromIndex
int32_t
*
aFoundIndex
)
{
RefPtr
<
dom
:
:
HTMLSelectElement
>
selectElement
=
dom
:
:
HTMLSelectElement
:
:
FromNode
(
mContent
)
;
const
uint32_t
length
=
selectElement
-
>
Length
(
)
;
for
(
uint32_t
i
=
std
:
:
max
(
aFromIndex
0
)
;
i
<
length
;
+
+
i
)
{
HTMLOptionElement
*
node
=
selectElement
-
>
Item
(
i
)
;
if
(
!
node
)
{
break
;
}
if
(
!
selectElement
-
>
IsOptionDisabled
(
node
)
)
{
if
(
aFoundIndex
)
{
*
aFoundIndex
=
i
;
}
return
node
;
}
}
return
nullptr
;
}
bool
nsListControlFrame
:
:
IsInDropDownMode
(
)
const
{
return
(
mComboboxFrame
!
=
nullptr
)
;
}
uint32_t
nsListControlFrame
:
:
GetNumberOfOptions
(
)
{
dom
:
:
HTMLOptionsCollection
*
options
=
GetOptions
(
)
;
if
(
!
options
)
{
return
0
;
}
return
options
-
>
Length
(
)
;
}
bool
nsListControlFrame
:
:
CheckIfAllFramesHere
(
)
{
mIsAllFramesHere
=
true
;
return
mIsAllFramesHere
;
}
NS_IMETHODIMP
nsListControlFrame
:
:
DoneAddingChildren
(
bool
aIsDone
)
{
mIsAllContentHere
=
aIsDone
;
if
(
mIsAllContentHere
)
{
if
(
!
mIsAllFramesHere
)
{
if
(
CheckIfAllFramesHere
(
)
)
{
mHasBeenInitialized
=
true
;
ResetList
(
true
)
;
}
}
}
return
NS_OK
;
}
NS_IMETHODIMP
nsListControlFrame
:
:
AddOption
(
int32_t
aIndex
)
{
#
ifdef
DO_REFLOW_DEBUG
printf
(
"
-
-
-
-
Id
:
%
d
nsLCF
%
p
Added
Option
%
d
\
n
"
mReflowId
this
aIndex
)
;
#
endif
if
(
!
mIsAllContentHere
)
{
mIsAllContentHere
=
mContent
-
>
IsDoneAddingChildren
(
)
;
if
(
!
mIsAllContentHere
)
{
mIsAllFramesHere
=
false
;
mHasBeenInitialized
=
false
;
}
else
{
mIsAllFramesHere
=
(
aIndex
=
=
static_cast
<
int32_t
>
(
GetNumberOfOptions
(
)
-
1
)
)
;
}
}
mNeedToReset
=
true
;
if
(
!
mHasBeenInitialized
)
{
return
NS_OK
;
}
mPostChildrenLoadedReset
=
mIsAllContentHere
;
return
NS_OK
;
}
static
int32_t
DecrementAndClamp
(
int32_t
aSelectionIndex
int32_t
aLength
)
{
return
aLength
=
=
0
?
kNothingSelected
:
std
:
:
max
(
0
aSelectionIndex
-
1
)
;
}
NS_IMETHODIMP
nsListControlFrame
:
:
RemoveOption
(
int32_t
aIndex
)
{
MOZ_ASSERT
(
aIndex
>
=
0
"
negative
<
option
>
index
"
)
;
if
(
IsInDropDownMode
(
)
)
{
mNeedToReset
=
true
;
mPostChildrenLoadedReset
=
mIsAllContentHere
;
}
if
(
mStartSelectionIndex
!
=
kNothingSelected
)
{
NS_ASSERTION
(
mEndSelectionIndex
!
=
kNothingSelected
"
"
)
;
int32_t
numOptions
=
GetNumberOfOptions
(
)
;
NS_ASSERTION
(
aIndex
<
=
numOptions
"
out
-
of
-
bounds
<
option
>
index
"
)
;
int32_t
forward
=
mEndSelectionIndex
-
mStartSelectionIndex
;
int32_t
*
low
=
forward
>
=
0
?
&
mStartSelectionIndex
:
&
mEndSelectionIndex
;
int32_t
*
high
=
forward
>
=
0
?
&
mEndSelectionIndex
:
&
mStartSelectionIndex
;
if
(
aIndex
<
*
low
)
*
low
=
:
:
DecrementAndClamp
(
*
low
numOptions
)
;
if
(
aIndex
<
=
*
high
)
*
high
=
:
:
DecrementAndClamp
(
*
high
numOptions
)
;
if
(
forward
=
=
0
)
*
low
=
*
high
;
}
else
NS_ASSERTION
(
mEndSelectionIndex
=
=
kNothingSelected
"
"
)
;
InvalidateFocus
(
)
;
return
NS_OK
;
}
bool
nsListControlFrame
:
:
SetOptionsSelectedFromFrame
(
int32_t
aStartIndex
int32_t
aEndIndex
bool
aValue
bool
aClearAll
)
{
RefPtr
<
dom
:
:
HTMLSelectElement
>
selectElement
=
dom
:
:
HTMLSelectElement
:
:
FromNode
(
mContent
)
;
uint32_t
mask
=
dom
:
:
HTMLSelectElement
:
:
NOTIFY
;
if
(
mForceSelection
)
{
mask
|
=
dom
:
:
HTMLSelectElement
:
:
SET_DISABLED
;
}
if
(
aValue
)
{
mask
|
=
dom
:
:
HTMLSelectElement
:
:
IS_SELECTED
;
}
if
(
aClearAll
)
{
mask
|
=
dom
:
:
HTMLSelectElement
:
:
CLEAR_ALL
;
}
return
selectElement
-
>
SetOptionsSelectedByIndex
(
aStartIndex
aEndIndex
mask
)
;
}
bool
nsListControlFrame
:
:
ToggleOptionSelectedFromFrame
(
int32_t
aIndex
)
{
RefPtr
<
dom
:
:
HTMLOptionElement
>
option
=
GetOption
(
static_cast
<
uint32_t
>
(
aIndex
)
)
;
NS_ENSURE_TRUE
(
option
false
)
;
RefPtr
<
dom
:
:
HTMLSelectElement
>
selectElement
=
dom
:
:
HTMLSelectElement
:
:
FromNode
(
mContent
)
;
uint32_t
mask
=
dom
:
:
HTMLSelectElement
:
:
NOTIFY
;
if
(
!
option
-
>
Selected
(
)
)
{
mask
|
=
dom
:
:
HTMLSelectElement
:
:
IS_SELECTED
;
}
return
selectElement
-
>
SetOptionsSelectedByIndex
(
aIndex
aIndex
mask
)
;
}
bool
nsListControlFrame
:
:
UpdateSelection
(
)
{
if
(
mIsAllFramesHere
)
{
AutoWeakFrame
weakFrame
(
this
)
;
if
(
mComboboxFrame
)
{
mComboboxFrame
-
>
RedisplaySelectedText
(
)
;
if
(
mComboboxFrame
-
>
IsDroppedDown
(
)
)
{
return
weakFrame
.
IsAlive
(
)
;
}
}
if
(
mIsAllContentHere
)
{
FireOnInputAndOnChange
(
)
;
}
return
weakFrame
.
IsAlive
(
)
;
}
return
true
;
}
void
nsListControlFrame
:
:
ComboboxFinish
(
int32_t
aIndex
)
{
gLastKeyTime
=
0
;
if
(
mComboboxFrame
)
{
int32_t
displayIndex
=
mComboboxFrame
-
>
GetIndexOfDisplayArea
(
)
;
mForceSelection
=
displayIndex
=
=
aIndex
;
AutoWeakFrame
weakFrame
(
this
)
;
PerformSelection
(
aIndex
false
false
)
;
if
(
!
weakFrame
.
IsAlive
(
)
|
|
!
mComboboxFrame
)
{
return
;
}
if
(
displayIndex
!
=
aIndex
)
{
mComboboxFrame
-
>
RedisplaySelectedText
(
)
;
}
if
(
weakFrame
.
IsAlive
(
)
&
&
mComboboxFrame
)
{
mComboboxFrame
-
>
RollupFromList
(
)
;
}
}
}
void
nsListControlFrame
:
:
FireOnInputAndOnChange
(
)
{
if
(
mComboboxFrame
)
{
int32_t
index
=
mComboboxFrame
-
>
UpdateRecentIndex
(
NS_SKIP_NOTIFY_INDEX
)
;
if
(
index
=
=
NS_SKIP_NOTIFY_INDEX
)
{
return
;
}
if
(
index
=
=
GetSelectedIndex
(
)
)
{
return
;
}
}
nsCOMPtr
<
nsIContent
>
content
=
mContent
;
nsContentUtils
:
:
DispatchTrustedEvent
(
content
-
>
OwnerDoc
(
)
content
NS_LITERAL_STRING
(
"
input
"
)
CanBubble
:
:
eYes
Cancelable
:
:
eNo
)
;
nsContentUtils
:
:
DispatchTrustedEvent
(
content
-
>
OwnerDoc
(
)
content
NS_LITERAL_STRING
(
"
change
"
)
CanBubble
:
:
eYes
Cancelable
:
:
eNo
)
;
}
NS_IMETHODIMP
nsListControlFrame
:
:
OnSetSelectedIndex
(
int32_t
aOldIndex
int32_t
aNewIndex
)
{
if
(
mComboboxFrame
)
{
mComboboxFrame
-
>
UpdateRecentIndex
(
NS_SKIP_NOTIFY_INDEX
)
;
}
AutoWeakFrame
weakFrame
(
this
)
;
ScrollToIndex
(
aNewIndex
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
NS_OK
;
}
mStartSelectionIndex
=
aNewIndex
;
mEndSelectionIndex
=
aNewIndex
;
InvalidateFocus
(
)
;
#
ifdef
ACCESSIBILITY
FireMenuItemActiveEvent
(
)
;
#
endif
return
NS_OK
;
}
nsresult
nsListControlFrame
:
:
SetFormProperty
(
nsAtom
*
aName
const
nsAString
&
aValue
)
{
if
(
nsGkAtoms
:
:
selected
=
=
aName
)
{
return
NS_ERROR_INVALID_ARG
;
}
else
if
(
nsGkAtoms
:
:
selectedindex
=
=
aName
)
{
return
NS_ERROR_INVALID_ARG
;
}
return
NS_OK
;
}
void
nsListControlFrame
:
:
AboutToDropDown
(
)
{
NS_ASSERTION
(
IsInDropDownMode
(
)
"
AboutToDropDown
called
without
being
in
dropdown
mode
"
)
;
nsIFrame
*
comboboxFrame
=
do_QueryFrame
(
mComboboxFrame
)
;
nsIFrame
*
ancestor
=
comboboxFrame
-
>
GetParent
(
)
;
mLastDropdownBackstopColor
=
NS_RGBA
(
0
0
0
0
)
;
while
(
NS_GET_A
(
mLastDropdownBackstopColor
)
<
255
&
&
ancestor
)
{
ComputedStyle
*
context
=
ancestor
-
>
Style
(
)
;
mLastDropdownBackstopColor
=
NS_ComposeColors
(
context
-
>
StyleBackground
(
)
-
>
BackgroundColor
(
context
)
mLastDropdownBackstopColor
)
;
ancestor
=
ancestor
-
>
GetParent
(
)
;
}
mLastDropdownBackstopColor
=
NS_ComposeColors
(
PresContext
(
)
-
>
DefaultBackgroundColor
(
)
mLastDropdownBackstopColor
)
;
if
(
mIsAllContentHere
&
&
mIsAllFramesHere
&
&
mHasBeenInitialized
)
{
AutoWeakFrame
weakFrame
(
this
)
;
ScrollToIndex
(
GetSelectedIndex
(
)
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
;
}
#
ifdef
ACCESSIBILITY
FireMenuItemActiveEvent
(
)
;
#
endif
}
mItemSelectionStarted
=
false
;
mForceSelection
=
false
;
}
void
nsListControlFrame
:
:
AboutToRollup
(
)
{
if
(
IsInDropDownMode
(
)
)
{
ComboboxFinish
(
mComboboxFrame
-
>
GetIndexOfDisplayArea
(
)
)
;
}
}
void
nsListControlFrame
:
:
DidReflow
(
nsPresContext
*
aPresContext
const
ReflowInput
*
aReflowInput
)
{
bool
wasInterrupted
=
!
mHasPendingInterruptAtStartOfReflow
&
&
aPresContext
-
>
HasPendingInterrupt
(
)
;
nsHTMLScrollFrame
:
:
DidReflow
(
aPresContext
aReflowInput
)
;
if
(
mNeedToReset
&
&
!
wasInterrupted
)
{
mNeedToReset
=
false
;
ResetList
(
!
DidHistoryRestore
(
)
|
|
mPostChildrenLoadedReset
)
;
}
mHasPendingInterruptAtStartOfReflow
=
false
;
}
#
ifdef
DEBUG_FRAME_DUMP
nsresult
nsListControlFrame
:
:
GetFrameName
(
nsAString
&
aResult
)
const
{
return
MakeFrameName
(
NS_LITERAL_STRING
(
"
ListControl
"
)
aResult
)
;
}
#
endif
nscoord
nsListControlFrame
:
:
GetBSizeOfARow
(
)
{
return
BSizeOfARow
(
)
;
}
nsresult
nsListControlFrame
:
:
IsOptionDisabled
(
int32_t
anIndex
bool
&
aIsDisabled
)
{
RefPtr
<
dom
:
:
HTMLSelectElement
>
sel
=
dom
:
:
HTMLSelectElement
:
:
FromNode
(
mContent
)
;
if
(
sel
)
{
sel
-
>
IsOptionDisabled
(
anIndex
&
aIsDisabled
)
;
return
NS_OK
;
}
return
NS_ERROR_FAILURE
;
}
bool
nsListControlFrame
:
:
IsLeftButton
(
dom
:
:
Event
*
aMouseEvent
)
{
MouseEvent
*
mouseEvent
=
aMouseEvent
-
>
AsMouseEvent
(
)
;
return
mouseEvent
&
&
mouseEvent
-
>
Button
(
)
=
=
0
;
}
nscoord
nsListControlFrame
:
:
CalcFallbackRowBSize
(
float
aFontSizeInflation
)
{
RefPtr
<
nsFontMetrics
>
fontMet
=
nsLayoutUtils
:
:
GetFontMetricsForFrame
(
this
aFontSizeInflation
)
;
return
fontMet
-
>
MaxHeight
(
)
;
}
nscoord
nsListControlFrame
:
:
CalcIntrinsicBSize
(
nscoord
aBSizeOfARow
int32_t
aNumberOfOptions
)
{
MOZ_ASSERT
(
!
IsInDropDownMode
(
)
"
Shouldn
'
t
be
in
dropdown
mode
when
we
call
this
"
)
;
dom
:
:
HTMLSelectElement
*
select
=
dom
:
:
HTMLSelectElement
:
:
FromNodeOrNull
(
mContent
)
;
if
(
select
)
{
mNumDisplayRows
=
select
-
>
Size
(
)
;
}
else
{
mNumDisplayRows
=
1
;
}
if
(
mNumDisplayRows
<
1
)
{
mNumDisplayRows
=
4
;
}
return
mNumDisplayRows
*
aBSizeOfARow
;
}
nsresult
nsListControlFrame
:
:
MouseUp
(
dom
:
:
Event
*
aMouseEvent
)
{
NS_ASSERTION
(
aMouseEvent
!
=
nullptr
"
aMouseEvent
is
null
.
"
)
;
MouseEvent
*
mouseEvent
=
aMouseEvent
-
>
AsMouseEvent
(
)
;
NS_ENSURE_TRUE
(
mouseEvent
NS_ERROR_FAILURE
)
;
UpdateInListState
(
aMouseEvent
)
;
mButtonDown
=
false
;
EventStates
eventStates
=
mContent
-
>
AsElement
(
)
-
>
State
(
)
;
if
(
eventStates
.
HasState
(
NS_EVENT_STATE_DISABLED
)
)
{
return
NS_OK
;
}
if
(
!
IsLeftButton
(
aMouseEvent
)
)
{
if
(
IsInDropDownMode
(
)
)
{
if
(
!
IgnoreMouseEventForSelection
(
aMouseEvent
)
)
{
aMouseEvent
-
>
PreventDefault
(
)
;
aMouseEvent
-
>
StopPropagation
(
)
;
}
else
{
CaptureMouseEvents
(
false
)
;
return
NS_OK
;
}
CaptureMouseEvents
(
false
)
;
return
NS_ERROR_FAILURE
;
}
else
{
CaptureMouseEvents
(
false
)
;
return
NS_OK
;
}
}
const
nsStyleVisibility
*
vis
=
StyleVisibility
(
)
;
if
(
!
vis
-
>
IsVisible
(
)
)
{
return
NS_OK
;
}
if
(
IsInDropDownMode
(
)
)
{
WidgetMouseEvent
*
mouseEvent
=
aMouseEvent
-
>
WidgetEventPtr
(
)
-
>
AsMouseEvent
(
)
;
int32_t
selectedIndex
;
if
(
NS_SUCCEEDED
(
GetIndexFromDOMEvent
(
aMouseEvent
selectedIndex
)
)
)
{
bool
isDisabled
=
false
;
IsOptionDisabled
(
selectedIndex
isDisabled
)
;
if
(
isDisabled
)
{
aMouseEvent
-
>
PreventDefault
(
)
;
aMouseEvent
-
>
StopPropagation
(
)
;
CaptureMouseEvents
(
false
)
;
return
NS_ERROR_FAILURE
;
}
if
(
kNothingSelected
!
=
selectedIndex
)
{
AutoWeakFrame
weakFrame
(
this
)
;
ComboboxFinish
(
selectedIndex
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
NS_OK
;
}
FireOnInputAndOnChange
(
)
;
}
mouseEvent
-
>
mClickCount
=
1
;
}
else
{
mouseEvent
-
>
mClickCount
=
IgnoreMouseEventForSelection
(
aMouseEvent
)
?
1
:
0
;
}
}
else
{
CaptureMouseEvents
(
false
)
;
if
(
mChangesSinceDragStart
)
{
mChangesSinceDragStart
=
false
;
FireOnInputAndOnChange
(
)
;
}
}
return
NS_OK
;
}
void
nsListControlFrame
:
:
UpdateInListState
(
dom
:
:
Event
*
aEvent
)
{
if
(
!
mComboboxFrame
|
|
!
mComboboxFrame
-
>
IsDroppedDown
(
)
)
return
;
nsPoint
pt
=
nsLayoutUtils
:
:
GetDOMEventCoordinatesRelativeTo
(
aEvent
this
)
;
nsRect
borderInnerEdge
=
GetScrollPortRect
(
)
;
if
(
pt
.
y
>
=
borderInnerEdge
.
y
&
&
pt
.
y
<
borderInnerEdge
.
YMost
(
)
)
{
mItemSelectionStarted
=
true
;
}
}
bool
nsListControlFrame
:
:
IgnoreMouseEventForSelection
(
dom
:
:
Event
*
aEvent
)
{
if
(
!
mComboboxFrame
)
return
false
;
if
(
!
mComboboxFrame
-
>
IsDroppedDown
(
)
)
return
true
;
return
!
mItemSelectionStarted
;
}
#
ifdef
ACCESSIBILITY
void
nsListControlFrame
:
:
FireMenuItemActiveEvent
(
)
{
if
(
mFocused
!
=
this
&
&
!
IsInDropDownMode
(
)
)
{
return
;
}
nsCOMPtr
<
nsIContent
>
optionContent
=
GetCurrentOption
(
)
;
if
(
!
optionContent
)
{
return
;
}
FireDOMEvent
(
NS_LITERAL_STRING
(
"
DOMMenuItemActive
"
)
optionContent
)
;
}
#
endif
nsresult
nsListControlFrame
:
:
GetIndexFromDOMEvent
(
dom
:
:
Event
*
aMouseEvent
int32_t
&
aCurIndex
)
{
if
(
IgnoreMouseEventForSelection
(
aMouseEvent
)
)
return
NS_ERROR_FAILURE
;
if
(
nsIPresShell
:
:
GetCapturingContent
(
)
!
=
mContent
)
{
nsPoint
pt
=
nsLayoutUtils
:
:
GetDOMEventCoordinatesRelativeTo
(
aMouseEvent
this
)
;
nsRect
borderInnerEdge
=
GetScrollPortRect
(
)
;
if
(
!
borderInnerEdge
.
Contains
(
pt
)
)
{
return
NS_ERROR_FAILURE
;
}
}
RefPtr
<
dom
:
:
HTMLOptionElement
>
option
;
for
(
nsCOMPtr
<
nsIContent
>
content
=
PresContext
(
)
-
>
EventStateManager
(
)
-
>
GetEventTargetContent
(
nullptr
)
;
content
&
&
!
option
;
content
=
content
-
>
GetParent
(
)
)
{
option
=
dom
:
:
HTMLOptionElement
:
:
FromNode
(
content
)
;
}
if
(
option
)
{
aCurIndex
=
option
-
>
Index
(
)
;
MOZ_ASSERT
(
aCurIndex
>
=
0
)
;
return
NS_OK
;
}
return
NS_ERROR_FAILURE
;
}
static
bool
FireShowDropDownEvent
(
nsIContent
*
aContent
bool
aShow
bool
aIsSourceTouchEvent
)
{
if
(
ShouldFireDropDownEvent
(
)
)
{
nsString
eventName
;
if
(
aShow
)
{
eventName
=
aIsSourceTouchEvent
?
NS_LITERAL_STRING
(
"
mozshowdropdown
-
sourcetouch
"
)
:
NS_LITERAL_STRING
(
"
mozshowdropdown
"
)
;
}
else
{
eventName
=
NS_LITERAL_STRING
(
"
mozhidedropdown
"
)
;
}
nsContentUtils
:
:
DispatchChromeEvent
(
aContent
-
>
OwnerDoc
(
)
aContent
eventName
CanBubble
:
:
eYes
Cancelable
:
:
eNo
)
;
return
true
;
}
return
false
;
}
nsresult
nsListControlFrame
:
:
MouseDown
(
dom
:
:
Event
*
aMouseEvent
)
{
NS_ASSERTION
(
aMouseEvent
!
=
nullptr
"
aMouseEvent
is
null
.
"
)
;
MouseEvent
*
mouseEvent
=
aMouseEvent
-
>
AsMouseEvent
(
)
;
NS_ENSURE_TRUE
(
mouseEvent
NS_ERROR_FAILURE
)
;
UpdateInListState
(
aMouseEvent
)
;
EventStates
eventStates
=
mContent
-
>
AsElement
(
)
-
>
State
(
)
;
if
(
eventStates
.
HasState
(
NS_EVENT_STATE_DISABLED
)
)
{
return
NS_OK
;
}
if
(
!
IsLeftButton
(
aMouseEvent
)
)
{
if
(
IsInDropDownMode
(
)
)
{
if
(
!
IgnoreMouseEventForSelection
(
aMouseEvent
)
)
{
aMouseEvent
-
>
PreventDefault
(
)
;
aMouseEvent
-
>
StopPropagation
(
)
;
}
else
{
return
NS_OK
;
}
return
NS_ERROR_FAILURE
;
}
else
{
return
NS_OK
;
}
}
int32_t
selectedIndex
;
if
(
NS_SUCCEEDED
(
GetIndexFromDOMEvent
(
aMouseEvent
selectedIndex
)
)
)
{
mButtonDown
=
true
;
CaptureMouseEvents
(
true
)
;
AutoWeakFrame
weakFrame
(
this
)
;
bool
change
=
HandleListSelection
(
aMouseEvent
selectedIndex
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
NS_OK
;
}
mChangesSinceDragStart
=
change
;
}
else
{
if
(
mComboboxFrame
)
{
if
(
mComboboxFrame
-
>
IsOpenInParentProcess
(
)
)
{
nsCOMPtr
<
nsIContent
>
econtent
=
do_QueryInterface
(
aMouseEvent
-
>
GetTarget
(
)
)
;
HTMLOptionElement
*
option
=
HTMLOptionElement
:
:
FromNodeOrNull
(
econtent
)
;
if
(
option
)
{
return
NS_OK
;
}
}
uint16_t
inputSource
=
mouseEvent
-
>
MozInputSource
(
)
;
bool
isSourceTouchEvent
=
inputSource
=
=
MouseEvent_Binding
:
:
MOZ_SOURCE_TOUCH
;
if
(
FireShowDropDownEvent
(
mContent
!
mComboboxFrame
-
>
IsDroppedDownOrHasParentPopup
(
)
isSourceTouchEvent
)
)
{
return
NS_OK
;
}
if
(
!
IgnoreMouseEventForSelection
(
aMouseEvent
)
)
{
return
NS_OK
;
}
if
(
!
nsComboboxControlFrame
:
:
ToolkitHasNativePopup
(
)
)
{
bool
isDroppedDown
=
mComboboxFrame
-
>
IsDroppedDown
(
)
;
nsIFrame
*
comboFrame
=
do_QueryFrame
(
mComboboxFrame
)
;
AutoWeakFrame
weakFrame
(
comboFrame
)
;
mComboboxFrame
-
>
ShowDropDown
(
!
isDroppedDown
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
return
NS_OK
;
if
(
isDroppedDown
)
{
CaptureMouseEvents
(
false
)
;
}
}
}
}
return
NS_OK
;
}
nsresult
nsListControlFrame
:
:
MouseMove
(
dom
:
:
Event
*
aMouseEvent
)
{
NS_ASSERTION
(
aMouseEvent
"
aMouseEvent
is
null
.
"
)
;
MouseEvent
*
mouseEvent
=
aMouseEvent
-
>
AsMouseEvent
(
)
;
NS_ENSURE_TRUE
(
mouseEvent
NS_ERROR_FAILURE
)
;
UpdateInListState
(
aMouseEvent
)
;
if
(
IsInDropDownMode
(
)
)
{
if
(
mComboboxFrame
-
>
IsDroppedDown
(
)
)
{
int32_t
selectedIndex
;
if
(
NS_SUCCEEDED
(
GetIndexFromDOMEvent
(
aMouseEvent
selectedIndex
)
)
)
{
PerformSelection
(
selectedIndex
false
false
)
;
}
}
}
else
{
if
(
mButtonDown
)
{
return
DragMove
(
aMouseEvent
)
;
}
}
return
NS_OK
;
}
nsresult
nsListControlFrame
:
:
DragMove
(
dom
:
:
Event
*
aMouseEvent
)
{
NS_ASSERTION
(
aMouseEvent
"
aMouseEvent
is
null
.
"
)
;
UpdateInListState
(
aMouseEvent
)
;
if
(
!
IsInDropDownMode
(
)
)
{
int32_t
selectedIndex
;
if
(
NS_SUCCEEDED
(
GetIndexFromDOMEvent
(
aMouseEvent
selectedIndex
)
)
)
{
if
(
selectedIndex
=
=
mEndSelectionIndex
)
{
return
NS_OK
;
}
MouseEvent
*
mouseEvent
=
aMouseEvent
-
>
AsMouseEvent
(
)
;
NS_ASSERTION
(
mouseEvent
"
aMouseEvent
is
not
a
MouseEvent
!
"
)
;
bool
isControl
;
#
ifdef
XP_MACOSX
isControl
=
mouseEvent
-
>
MetaKey
(
)
;
#
else
isControl
=
mouseEvent
-
>
CtrlKey
(
)
;
#
endif
AutoWeakFrame
weakFrame
(
this
)
;
bool
wasChanged
=
PerformSelection
(
selectedIndex
!
isControl
isControl
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
NS_OK
;
}
mChangesSinceDragStart
=
mChangesSinceDragStart
|
|
wasChanged
;
}
}
return
NS_OK
;
}
void
nsListControlFrame
:
:
ScrollToIndex
(
int32_t
aIndex
)
{
if
(
aIndex
<
0
)
{
ScrollTo
(
nsPoint
(
0
0
)
nsIScrollableFrame
:
:
INSTANT
)
;
}
else
{
RefPtr
<
dom
:
:
HTMLOptionElement
>
option
=
GetOption
(
AssertedCast
<
uint32_t
>
(
aIndex
)
)
;
if
(
option
)
{
ScrollToFrame
(
*
option
)
;
}
}
}
void
nsListControlFrame
:
:
ScrollToFrame
(
dom
:
:
HTMLOptionElement
&
aOptElement
)
{
nsIFrame
*
childFrame
=
aOptElement
.
GetPrimaryFrame
(
)
;
if
(
childFrame
)
{
PresShell
(
)
-
>
ScrollFrameRectIntoView
(
childFrame
nsRect
(
nsPoint
(
0
0
)
childFrame
-
>
GetSize
(
)
)
nsIPresShell
:
:
ScrollAxis
(
)
nsIPresShell
:
:
ScrollAxis
(
)
nsIPresShell
:
:
SCROLL_OVERFLOW_HIDDEN
|
nsIPresShell
:
:
SCROLL_FIRST_ANCESTOR_ONLY
)
;
}
}
void
nsListControlFrame
:
:
AdjustIndexForDisabledOpt
(
int32_t
aStartIndex
int32_t
&
aNewIndex
int32_t
aNumOptions
int32_t
aDoAdjustInc
int32_t
aDoAdjustIncNext
)
{
if
(
aNumOptions
=
=
0
)
{
aNewIndex
=
kNothingSelected
;
return
;
}
bool
doingReverse
=
false
;
int32_t
bottom
=
0
;
int32_t
top
=
aNumOptions
;
int32_t
startIndex
=
aStartIndex
;
if
(
startIndex
<
bottom
)
{
startIndex
=
GetSelectedIndex
(
)
;
}
int32_t
newIndex
=
startIndex
+
aDoAdjustInc
;
if
(
newIndex
<
bottom
)
{
newIndex
=
0
;
}
else
if
(
newIndex
>
=
top
)
{
newIndex
=
aNumOptions
-
1
;
}
while
(
1
)
{
bool
isDisabled
=
true
;
if
(
NS_SUCCEEDED
(
IsOptionDisabled
(
newIndex
isDisabled
)
)
&
&
!
isDisabled
)
{
break
;
}
newIndex
+
=
aDoAdjustIncNext
;
if
(
newIndex
<
bottom
)
{
if
(
doingReverse
)
{
return
;
}
else
{
newIndex
=
bottom
;
aDoAdjustIncNext
=
1
;
doingReverse
=
true
;
top
=
startIndex
;
}
}
else
if
(
newIndex
>
=
top
)
{
if
(
doingReverse
)
{
return
;
}
else
{
newIndex
=
top
-
1
;
aDoAdjustIncNext
=
-
1
;
doingReverse
=
true
;
bottom
=
startIndex
;
}
}
}
aNewIndex
=
newIndex
;
}
nsAString
&
nsListControlFrame
:
:
GetIncrementalString
(
)
{
if
(
sIncrementalString
=
=
nullptr
)
sIncrementalString
=
new
nsString
(
)
;
return
*
sIncrementalString
;
}
void
nsListControlFrame
:
:
Shutdown
(
)
{
delete
sIncrementalString
;
sIncrementalString
=
nullptr
;
}
void
nsListControlFrame
:
:
DropDownToggleKey
(
dom
:
:
Event
*
aKeyEvent
)
{
if
(
IsInDropDownMode
(
)
&
&
!
nsComboboxControlFrame
:
:
ToolkitHasNativePopup
(
)
)
{
aKeyEvent
-
>
PreventDefault
(
)
;
if
(
!
mComboboxFrame
-
>
IsDroppedDown
(
)
)
{
if
(
!
FireShowDropDownEvent
(
mContent
true
false
)
)
{
mComboboxFrame
-
>
ShowDropDown
(
true
)
;
}
}
else
{
AutoWeakFrame
weakFrame
(
this
)
;
ComboboxFinish
(
mEndSelectionIndex
)
;
if
(
weakFrame
.
IsAlive
(
)
)
{
FireOnInputAndOnChange
(
)
;
}
}
}
}
nsresult
nsListControlFrame
:
:
KeyDown
(
dom
:
:
Event
*
aKeyEvent
)
{
MOZ_ASSERT
(
aKeyEvent
"
aKeyEvent
is
null
.
"
)
;
EventStates
eventStates
=
mContent
-
>
AsElement
(
)
-
>
State
(
)
;
if
(
eventStates
.
HasState
(
NS_EVENT_STATE_DISABLED
)
)
{
return
NS_OK
;
}
AutoIncrementalSearchResetter
incrementalSearchResetter
;
const
WidgetKeyboardEvent
*
keyEvent
=
aKeyEvent
-
>
WidgetEventPtr
(
)
-
>
AsKeyboardEvent
(
)
;
MOZ_ASSERT
(
keyEvent
"
DOM
event
must
have
WidgetKeyboardEvent
for
its
internal
event
"
)
;
bool
dropDownMenuOnUpDown
;
bool
dropDownMenuOnSpace
;
#
ifdef
XP_MACOSX
dropDownMenuOnUpDown
=
IsInDropDownMode
(
)
&
&
!
mComboboxFrame
-
>
IsDroppedDown
(
)
;
dropDownMenuOnSpace
=
!
keyEvent
-
>
IsAlt
(
)
&
&
!
keyEvent
-
>
IsControl
(
)
&
&
!
keyEvent
-
>
IsMeta
(
)
;
#
else
dropDownMenuOnUpDown
=
keyEvent
-
>
IsAlt
(
)
;
dropDownMenuOnSpace
=
IsInDropDownMode
(
)
&
&
!
mComboboxFrame
-
>
IsDroppedDown
(
)
;
#
endif
bool
withinIncrementalSearchTime
=
keyEvent
-
>
mTime
-
gLastKeyTime
<
=
INCREMENTAL_SEARCH_KEYPRESS_TIME
;
if
(
(
dropDownMenuOnUpDown
&
&
(
keyEvent
-
>
mKeyCode
=
=
NS_VK_UP
|
|
keyEvent
-
>
mKeyCode
=
=
NS_VK_DOWN
)
)
|
|
(
dropDownMenuOnSpace
&
&
keyEvent
-
>
mKeyCode
=
=
NS_VK_SPACE
&
&
!
withinIncrementalSearchTime
)
)
{
DropDownToggleKey
(
aKeyEvent
)
;
if
(
keyEvent
-
>
DefaultPrevented
(
)
)
{
return
NS_OK
;
}
}
if
(
keyEvent
-
>
IsAlt
(
)
)
{
return
NS_OK
;
}
RefPtr
<
dom
:
:
HTMLOptionsCollection
>
options
=
GetOptions
(
)
;
NS_ENSURE_TRUE
(
options
NS_ERROR_FAILURE
)
;
uint32_t
numOptions
=
options
-
>
Length
(
)
;
int32_t
newIndex
=
kNothingSelected
;
bool
isControlOrMeta
=
(
keyEvent
-
>
IsControl
(
)
|
|
keyEvent
-
>
IsMeta
(
)
)
;
if
(
isControlOrMeta
&
&
!
GetMultiple
(
)
&
&
(
keyEvent
-
>
mKeyCode
=
=
NS_VK_PAGE_UP
|
|
keyEvent
-
>
mKeyCode
=
=
NS_VK_PAGE_DOWN
)
)
{
return
NS_OK
;
}
if
(
isControlOrMeta
&
&
(
keyEvent
-
>
mKeyCode
=
=
NS_VK_UP
|
|
keyEvent
-
>
mKeyCode
=
=
NS_VK_LEFT
|
|
keyEvent
-
>
mKeyCode
=
=
NS_VK_DOWN
|
|
keyEvent
-
>
mKeyCode
=
=
NS_VK_RIGHT
|
|
keyEvent
-
>
mKeyCode
=
=
NS_VK_HOME
|
|
keyEvent
-
>
mKeyCode
=
=
NS_VK_END
)
)
{
isControlOrMeta
=
mControlSelectMode
=
GetMultiple
(
)
;
}
else
if
(
keyEvent
-
>
mKeyCode
!
=
NS_VK_SPACE
)
{
mControlSelectMode
=
false
;
}
bool
shouldSelectByKey
=
!
mComboboxFrame
|
|
!
mComboboxFrame
-
>
IsOpenInParentProcess
(
)
;
switch
(
keyEvent
-
>
mKeyCode
)
{
case
NS_VK_UP
:
case
NS_VK_LEFT
:
if
(
shouldSelectByKey
)
{
AdjustIndexForDisabledOpt
(
mEndSelectionIndex
newIndex
static_cast
<
int32_t
>
(
numOptions
)
-
1
-
1
)
;
}
break
;
case
NS_VK_DOWN
:
case
NS_VK_RIGHT
:
if
(
shouldSelectByKey
)
{
AdjustIndexForDisabledOpt
(
mEndSelectionIndex
newIndex
static_cast
<
int32_t
>
(
numOptions
)
1
1
)
;
}
break
;
case
NS_VK_RETURN
:
if
(
IsInDropDownMode
(
)
)
{
if
(
mComboboxFrame
-
>
IsDroppedDown
(
)
)
{
aKeyEvent
-
>
PreventDefault
(
)
;
AutoWeakFrame
weakFrame
(
this
)
;
ComboboxFinish
(
mEndSelectionIndex
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
NS_OK
;
}
}
FireOnInputAndOnChange
(
)
;
return
NS_OK
;
}
if
(
!
GetMultiple
(
)
)
{
return
NS_OK
;
}
newIndex
=
mEndSelectionIndex
;
break
;
case
NS_VK_ESCAPE
:
{
if
(
!
IsInDropDownMode
(
)
)
{
return
NS_OK
;
}
AboutToRollup
(
)
;
aKeyEvent
-
>
PreventDefault
(
)
;
return
NS_OK
;
}
case
NS_VK_PAGE_UP
:
{
if
(
shouldSelectByKey
)
{
int32_t
itemsPerPage
=
std
:
:
max
(
1
static_cast
<
int32_t
>
(
mNumDisplayRows
-
1
)
)
;
AdjustIndexForDisabledOpt
(
mEndSelectionIndex
newIndex
static_cast
<
int32_t
>
(
numOptions
)
-
itemsPerPage
-
1
)
;
}
break
;
}
case
NS_VK_PAGE_DOWN
:
{
if
(
shouldSelectByKey
)
{
int32_t
itemsPerPage
=
std
:
:
max
(
1
static_cast
<
int32_t
>
(
mNumDisplayRows
-
1
)
)
;
AdjustIndexForDisabledOpt
(
mEndSelectionIndex
newIndex
static_cast
<
int32_t
>
(
numOptions
)
itemsPerPage
1
)
;
}
break
;
}
case
NS_VK_HOME
:
if
(
shouldSelectByKey
)
{
AdjustIndexForDisabledOpt
(
0
newIndex
static_cast
<
int32_t
>
(
numOptions
)
0
1
)
;
}
break
;
case
NS_VK_END
:
if
(
shouldSelectByKey
)
{
AdjustIndexForDisabledOpt
(
static_cast
<
int32_t
>
(
numOptions
)
-
1
newIndex
static_cast
<
int32_t
>
(
numOptions
)
0
-
1
)
;
}
break
;
#
if
defined
(
XP_WIN
)
case
NS_VK_F4
:
if
(
!
isControlOrMeta
)
{
DropDownToggleKey
(
aKeyEvent
)
;
}
return
NS_OK
;
#
endif
default
:
incrementalSearchResetter
.
Cancel
(
)
;
return
NS_OK
;
}
aKeyEvent
-
>
PreventDefault
(
)
;
PostHandleKeyEvent
(
newIndex
0
keyEvent
-
>
IsShift
(
)
isControlOrMeta
)
;
return
NS_OK
;
}
nsresult
nsListControlFrame
:
:
KeyPress
(
dom
:
:
Event
*
aKeyEvent
)
{
MOZ_ASSERT
(
aKeyEvent
"
aKeyEvent
is
null
.
"
)
;
EventStates
eventStates
=
mContent
-
>
AsElement
(
)
-
>
State
(
)
;
if
(
eventStates
.
HasState
(
NS_EVENT_STATE_DISABLED
)
)
{
return
NS_OK
;
}
AutoIncrementalSearchResetter
incrementalSearchResetter
;
const
WidgetKeyboardEvent
*
keyEvent
=
aKeyEvent
-
>
WidgetEventPtr
(
)
-
>
AsKeyboardEvent
(
)
;
MOZ_ASSERT
(
keyEvent
"
DOM
event
must
have
WidgetKeyboardEvent
for
its
internal
event
"
)
;
if
(
keyEvent
-
>
DefaultPrevented
(
)
)
{
return
NS_OK
;
}
if
(
keyEvent
-
>
IsAlt
(
)
)
{
return
NS_OK
;
}
if
(
keyEvent
-
>
mCharCode
!
=
'
'
)
{
mControlSelectMode
=
false
;
}
bool
isControlOrMeta
=
(
keyEvent
-
>
IsControl
(
)
|
|
keyEvent
-
>
IsMeta
(
)
)
;
if
(
isControlOrMeta
&
&
keyEvent
-
>
mCharCode
!
=
'
'
)
{
return
NS_OK
;
}
if
(
!
keyEvent
-
>
mCharCode
)
{
if
(
keyEvent
-
>
mKeyCode
=
=
NS_VK_BACK
)
{
incrementalSearchResetter
.
Cancel
(
)
;
if
(
!
GetIncrementalString
(
)
.
IsEmpty
(
)
)
{
GetIncrementalString
(
)
.
Truncate
(
GetIncrementalString
(
)
.
Length
(
)
-
1
)
;
}
aKeyEvent
-
>
PreventDefault
(
)
;
}
else
{
}
return
NS_OK
;
}
incrementalSearchResetter
.
Cancel
(
)
;
aKeyEvent
-
>
PreventDefault
(
)
;
if
(
keyEvent
-
>
mTime
-
gLastKeyTime
>
INCREMENTAL_SEARCH_KEYPRESS_TIME
)
{
if
(
keyEvent
-
>
mCharCode
=
=
'
'
)
{
PostHandleKeyEvent
(
mEndSelectionIndex
keyEvent
-
>
mCharCode
keyEvent
-
>
IsShift
(
)
isControlOrMeta
)
;
return
NS_OK
;
}
GetIncrementalString
(
)
.
Truncate
(
)
;
}
gLastKeyTime
=
keyEvent
-
>
mTime
;
char16_t
uniChar
=
ToLowerCase
(
static_cast
<
char16_t
>
(
keyEvent
-
>
mCharCode
)
)
;
GetIncrementalString
(
)
.
Append
(
uniChar
)
;
nsAutoString
incrementalString
(
GetIncrementalString
(
)
)
;
uint32_t
charIndex
=
1
stringLength
=
incrementalString
.
Length
(
)
;
while
(
charIndex
<
stringLength
&
&
incrementalString
[
charIndex
]
=
=
incrementalString
[
charIndex
-
1
]
)
{
charIndex
+
+
;
}
if
(
charIndex
=
=
stringLength
)
{
incrementalString
.
Truncate
(
1
)
;
stringLength
=
1
;
}
int32_t
startIndex
=
GetSelectedIndex
(
)
;
if
(
startIndex
=
=
kNothingSelected
)
{
startIndex
=
0
;
}
else
if
(
stringLength
=
=
1
)
{
startIndex
+
+
;
}
RefPtr
<
dom
:
:
HTMLOptionsCollection
>
options
=
GetOptions
(
)
;
NS_ENSURE_TRUE
(
options
NS_ERROR_FAILURE
)
;
uint32_t
numOptions
=
options
-
>
Length
(
)
;
AutoWeakFrame
weakFrame
(
this
)
;
for
(
uint32_t
i
=
0
;
i
<
numOptions
;
+
+
i
)
{
uint32_t
index
=
(
i
+
startIndex
)
%
numOptions
;
RefPtr
<
dom
:
:
HTMLOptionElement
>
optionElement
=
options
-
>
ItemAsOption
(
index
)
;
if
(
!
optionElement
|
|
!
optionElement
-
>
GetPrimaryFrame
(
)
)
{
continue
;
}
nsAutoString
text
;
optionElement
-
>
GetText
(
text
)
;
if
(
!
StringBeginsWith
(
nsContentUtils
:
:
TrimWhitespace
<
nsContentUtils
:
:
IsHTMLWhitespaceOrNBSP
>
(
text
false
)
incrementalString
nsCaseInsensitiveStringComparator
(
)
)
)
{
continue
;
}
bool
wasChanged
=
PerformSelection
(
index
keyEvent
-
>
IsShift
(
)
isControlOrMeta
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
NS_OK
;
}
if
(
!
wasChanged
)
{
break
;
}
if
(
!
UpdateSelection
(
)
)
{
return
NS_OK
;
}
break
;
}
return
NS_OK
;
}
void
nsListControlFrame
:
:
PostHandleKeyEvent
(
int32_t
aNewIndex
uint32_t
aCharCode
bool
aIsShift
bool
aIsControlOrMeta
)
{
if
(
aNewIndex
=
=
kNothingSelected
)
{
int32_t
focusedIndex
=
mEndSelectionIndex
=
=
kNothingSelected
?
GetSelectedIndex
(
)
:
mEndSelectionIndex
;
if
(
focusedIndex
!
=
kNothingSelected
)
{
return
;
}
if
(
!
GetNonDisabledOptionFrom
(
0
&
aNewIndex
)
)
{
return
;
}
}
AutoWeakFrame
weakFrame
(
this
)
;
bool
wasChanged
=
false
;
if
(
aIsControlOrMeta
&
&
!
aIsShift
&
&
aCharCode
!
=
'
'
)
{
mStartSelectionIndex
=
aNewIndex
;
mEndSelectionIndex
=
aNewIndex
;
InvalidateFocus
(
)
;
ScrollToIndex
(
aNewIndex
)
;
if
(
!
weakFrame
.
IsAlive
(
)
)
{
return
;
}
#
ifdef
ACCESSIBILITY
FireMenuItemActiveEvent
(
)
;
#
endif
}
else
if
(
mControlSelectMode
&
&
aCharCode
=
=
'
'
)
{
wasChanged
=
SingleSelection
(
aNewIndex
true
)
;
}
else
{
wasChanged
=
PerformSelection
(
aNewIndex
aIsShift
aIsControlOrMeta
)
;
}
if
(
wasChanged
&
&
weakFrame
.
IsAlive
(
)
)
{
UpdateSelection
(
)
;
}
}
NS_IMPL_ISUPPORTS
(
nsListEventListener
nsIDOMEventListener
)
NS_IMETHODIMP
nsListEventListener
:
:
HandleEvent
(
dom
:
:
Event
*
aEvent
)
{
if
(
!
mFrame
)
return
NS_OK
;
nsAutoString
eventType
;
aEvent
-
>
GetType
(
eventType
)
;
if
(
eventType
.
EqualsLiteral
(
"
keydown
"
)
)
{
return
mFrame
-
>
nsListControlFrame
:
:
KeyDown
(
aEvent
)
;
}
if
(
eventType
.
EqualsLiteral
(
"
keypress
"
)
)
{
return
mFrame
-
>
nsListControlFrame
:
:
KeyPress
(
aEvent
)
;
}
if
(
eventType
.
EqualsLiteral
(
"
mousedown
"
)
)
{
if
(
aEvent
-
>
DefaultPrevented
(
)
)
{
return
NS_OK
;
}
return
mFrame
-
>
nsListControlFrame
:
:
MouseDown
(
aEvent
)
;
}
if
(
eventType
.
EqualsLiteral
(
"
mouseup
"
)
)
{
return
mFrame
-
>
nsListControlFrame
:
:
MouseUp
(
aEvent
)
;
}
if
(
eventType
.
EqualsLiteral
(
"
mousemove
"
)
)
{
return
mFrame
-
>
nsListControlFrame
:
:
MouseMove
(
aEvent
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
eventType
"
)
;
return
NS_OK
;
}
