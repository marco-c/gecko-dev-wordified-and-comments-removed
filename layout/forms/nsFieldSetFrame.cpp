#
include
"
nsFieldSetFrame
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
nsCSSAnonBoxes
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsLegendFrame
.
h
"
#
include
"
nsCSSRendering
.
h
"
#
include
<
algorithm
>
#
include
"
nsIFrame
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
mozilla
/
RestyleManager
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsRenderingContext
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
image
;
using
namespace
mozilla
:
:
layout
;
nsContainerFrame
*
NS_NewFieldSetFrame
(
nsIPresShell
*
aPresShell
nsStyleContext
*
aContext
)
{
return
new
(
aPresShell
)
nsFieldSetFrame
(
aContext
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsFieldSetFrame
)
nsFieldSetFrame
:
:
nsFieldSetFrame
(
nsStyleContext
*
aContext
)
:
nsContainerFrame
(
aContext
)
mLegendRect
(
GetWritingMode
(
)
)
{
mLegendSpace
=
0
;
}
nsIAtom
*
nsFieldSetFrame
:
:
GetType
(
)
const
{
return
nsGkAtoms
:
:
fieldSetFrame
;
}
nsRect
nsFieldSetFrame
:
:
VisualBorderRectRelativeToSelf
(
)
const
{
WritingMode
wm
=
GetWritingMode
(
)
;
Side
legendSide
=
wm
.
PhysicalSide
(
eLogicalSideBStart
)
;
nscoord
legendBorder
=
StyleBorder
(
)
-
>
GetComputedBorderWidth
(
legendSide
)
;
LogicalRect
r
(
wm
LogicalPoint
(
wm
0
0
)
GetLogicalSize
(
wm
)
)
;
nsSize
containerSize
=
r
.
Size
(
wm
)
.
GetPhysicalSize
(
wm
)
;
if
(
legendBorder
<
mLegendRect
.
BSize
(
wm
)
)
{
nscoord
off
=
(
mLegendRect
.
BSize
(
wm
)
-
legendBorder
)
/
2
;
r
.
BStart
(
wm
)
+
=
off
;
r
.
BSize
(
wm
)
-
=
off
;
}
return
r
.
GetPhysicalRect
(
wm
containerSize
)
;
}
nsIFrame
*
nsFieldSetFrame
:
:
GetInner
(
)
const
{
nsIFrame
*
last
=
mFrames
.
LastChild
(
)
;
if
(
last
&
&
last
-
>
StyleContext
(
)
-
>
GetPseudo
(
)
=
=
nsCSSAnonBoxes
:
:
fieldsetContent
)
{
return
last
;
}
MOZ_ASSERT
(
mFrames
.
LastChild
(
)
=
=
mFrames
.
FirstChild
(
)
)
;
return
nullptr
;
}
nsIFrame
*
nsFieldSetFrame
:
:
GetLegend
(
)
const
{
if
(
mFrames
.
FirstChild
(
)
=
=
GetInner
(
)
)
{
MOZ_ASSERT
(
mFrames
.
LastChild
(
)
=
=
mFrames
.
FirstChild
(
)
)
;
return
nullptr
;
}
MOZ_ASSERT
(
mFrames
.
FirstChild
(
)
&
&
mFrames
.
FirstChild
(
)
-
>
GetContentInsertionFrame
(
)
-
>
GetType
(
)
=
=
nsGkAtoms
:
:
legendFrame
)
;
return
mFrames
.
FirstChild
(
)
;
}
class
nsDisplayFieldSetBorderBackground
:
public
nsDisplayItem
{
public
:
nsDisplayFieldSetBorderBackground
(
nsDisplayListBuilder
*
aBuilder
nsFieldSetFrame
*
aFrame
)
:
nsDisplayItem
(
aBuilder
aFrame
)
{
MOZ_COUNT_CTOR
(
nsDisplayFieldSetBorderBackground
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayFieldSetBorderBackground
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayFieldSetBorderBackground
)
;
}
#
endif
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
nsRenderingContext
*
aCtx
)
override
;
virtual
nsDisplayItemGeometry
*
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
override
;
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
override
;
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
override
;
NS_DISPLAY_DECL_NAME
(
"
FieldSetBorderBackground
"
TYPE_FIELDSET_BORDER_BACKGROUND
)
}
;
void
nsDisplayFieldSetBorderBackground
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
nsRenderingContext
*
aCtx
)
{
DrawResult
result
=
static_cast
<
nsFieldSetFrame
*
>
(
mFrame
)
-
>
PaintBorder
(
aBuilder
*
aCtx
ToReferenceFrame
(
)
mVisibleRect
)
;
nsDisplayItemGenericImageGeometry
:
:
UpdateDrawResult
(
this
result
)
;
}
nsDisplayItemGeometry
*
nsDisplayFieldSetBorderBackground
:
:
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
{
return
new
nsDisplayItemGenericImageGeometry
(
this
aBuilder
)
;
}
void
nsDisplayFieldSetBorderBackground
:
:
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
{
auto
geometry
=
static_cast
<
const
nsDisplayItemGenericImageGeometry
*
>
(
aGeometry
)
;
if
(
aBuilder
-
>
ShouldSyncDecodeImages
(
)
&
&
geometry
-
>
ShouldInvalidateToSyncDecodeImages
(
)
)
{
bool
snap
;
aInvalidRegion
-
>
Or
(
*
aInvalidRegion
GetBounds
(
aBuilder
&
snap
)
)
;
}
nsDisplayItem
:
:
ComputeInvalidationRegion
(
aBuilder
aGeometry
aInvalidRegion
)
;
}
nsRect
nsDisplayFieldSetBorderBackground
:
:
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
{
*
aSnap
=
false
;
return
Frame
(
)
-
>
GetVisualOverflowRectRelativeToSelf
(
)
+
ToReferenceFrame
(
)
;
}
void
nsFieldSetFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aDirtyRect
const
nsDisplayListSet
&
aLists
)
{
if
(
!
(
GetStateBits
(
)
&
NS_FRAME_IS_OVERFLOW_CONTAINER
)
&
&
IsVisibleForPainting
(
aBuilder
)
)
{
if
(
StyleEffects
(
)
-
>
mBoxShadow
)
{
aLists
.
BorderBackground
(
)
-
>
AppendNewToTop
(
new
(
aBuilder
)
nsDisplayBoxShadowOuter
(
aBuilder
this
)
)
;
}
nsDisplayBackgroundImage
:
:
AppendBackgroundItemsToTop
(
aBuilder
this
VisualBorderRectRelativeToSelf
(
)
aLists
.
BorderBackground
(
)
false
)
;
aLists
.
BorderBackground
(
)
-
>
AppendNewToTop
(
new
(
aBuilder
)
nsDisplayFieldSetBorderBackground
(
aBuilder
this
)
)
;
DisplayOutlineUnconditional
(
aBuilder
aLists
)
;
DO_GLOBAL_REFLOW_COUNT_DSP
(
"
nsFieldSetFrame
"
)
;
}
if
(
GetPrevInFlow
(
)
)
{
DisplayOverflowContainers
(
aBuilder
aDirtyRect
aLists
)
;
}
nsDisplayListCollection
contentDisplayItems
;
if
(
nsIFrame
*
inner
=
GetInner
(
)
)
{
BuildDisplayListForChild
(
aBuilder
inner
aDirtyRect
contentDisplayItems
)
;
}
if
(
nsIFrame
*
legend
=
GetLegend
(
)
)
{
nsDisplayListSet
set
(
aLists
aLists
.
BlockBorderBackgrounds
(
)
)
;
BuildDisplayListForChild
(
aBuilder
legend
aDirtyRect
set
)
;
}
contentDisplayItems
.
MoveTo
(
aLists
)
;
}
DrawResult
nsFieldSetFrame
:
:
PaintBorder
(
nsDisplayListBuilder
*
aBuilder
nsRenderingContext
&
aRenderingContext
nsPoint
aPt
const
nsRect
&
aDirtyRect
)
{
nsRect
rect
=
VisualBorderRectRelativeToSelf
(
)
+
aPt
;
nsPresContext
*
presContext
=
PresContext
(
)
;
PaintBorderFlags
borderFlags
=
aBuilder
-
>
ShouldSyncDecodeImages
(
)
?
PaintBorderFlags
:
:
SYNC_DECODE_IMAGES
:
PaintBorderFlags
(
)
;
DrawResult
result
=
DrawResult
:
:
SUCCESS
;
nsCSSRendering
:
:
PaintBoxShadowInner
(
presContext
aRenderingContext
this
rect
)
;
if
(
nsIFrame
*
legend
=
GetLegend
(
)
)
{
nsRect
legendRect
=
legend
-
>
GetNormalRect
(
)
+
aPt
;
DrawTarget
*
drawTarget
=
aRenderingContext
.
GetDrawTarget
(
)
;
RefPtr
<
PathBuilder
>
pathBuilder
=
drawTarget
-
>
CreatePathBuilder
(
FillRule
:
:
FILL_WINDING
)
;
int32_t
appUnitsPerDevPixel
=
presContext
-
>
AppUnitsPerDevPixel
(
)
;
AppendRectToPath
(
pathBuilder
NSRectToSnappedRect
(
GetVisualOverflowRectRelativeToSelf
(
)
+
aPt
appUnitsPerDevPixel
*
drawTarget
)
true
)
;
AppendRectToPath
(
pathBuilder
NSRectToSnappedRect
(
legendRect
appUnitsPerDevPixel
*
drawTarget
)
false
)
;
RefPtr
<
Path
>
clipPath
=
pathBuilder
-
>
Finish
(
)
;
gfxContext
*
gfx
=
aRenderingContext
.
ThebesContext
(
)
;
gfx
-
>
Save
(
)
;
gfx
-
>
Clip
(
clipPath
)
;
result
&
=
nsCSSRendering
:
:
PaintBorder
(
presContext
aRenderingContext
this
aDirtyRect
rect
mStyleContext
borderFlags
)
;
gfx
-
>
Restore
(
)
;
}
else
{
result
&
=
nsCSSRendering
:
:
PaintBorder
(
presContext
aRenderingContext
this
aDirtyRect
nsRect
(
aPt
mRect
.
Size
(
)
)
mStyleContext
borderFlags
)
;
}
return
result
;
}
nscoord
nsFieldSetFrame
:
:
GetIntrinsicISize
(
nsRenderingContext
*
aRenderingContext
nsLayoutUtils
:
:
IntrinsicISizeType
aType
)
{
nscoord
legendWidth
=
0
;
nscoord
contentWidth
=
0
;
if
(
nsIFrame
*
legend
=
GetLegend
(
)
)
{
legendWidth
=
nsLayoutUtils
:
:
IntrinsicForContainer
(
aRenderingContext
legend
aType
)
;
}
if
(
nsIFrame
*
inner
=
GetInner
(
)
)
{
contentWidth
=
nsLayoutUtils
:
:
IntrinsicForContainer
(
aRenderingContext
inner
aType
nsLayoutUtils
:
:
IGNORE_PADDING
)
;
}
return
std
:
:
max
(
legendWidth
contentWidth
)
;
}
nscoord
nsFieldSetFrame
:
:
GetMinISize
(
nsRenderingContext
*
aRenderingContext
)
{
nscoord
result
=
0
;
DISPLAY_MIN_WIDTH
(
this
result
)
;
result
=
GetIntrinsicISize
(
aRenderingContext
nsLayoutUtils
:
:
MIN_ISIZE
)
;
return
result
;
}
nscoord
nsFieldSetFrame
:
:
GetPrefISize
(
nsRenderingContext
*
aRenderingContext
)
{
nscoord
result
=
0
;
DISPLAY_PREF_WIDTH
(
this
result
)
;
result
=
GetIntrinsicISize
(
aRenderingContext
nsLayoutUtils
:
:
PREF_ISIZE
)
;
return
result
;
}
void
nsFieldSetFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsFieldSetFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aDesiredSize
aStatus
)
;
NS_PRECONDITION
(
aReflowInput
.
ComputedISize
(
)
!
=
NS_INTRINSICSIZE
"
Should
have
a
precomputed
inline
-
size
!
"
)
;
aStatus
=
NS_FRAME_COMPLETE
;
nsOverflowAreas
ocBounds
;
nsReflowStatus
ocStatus
=
NS_FRAME_COMPLETE
;
if
(
GetPrevInFlow
(
)
)
{
ReflowOverflowContainerChildren
(
aPresContext
aReflowInput
ocBounds
0
ocStatus
)
;
}
bool
reflowInner
;
bool
reflowLegend
;
nsIFrame
*
legend
=
GetLegend
(
)
;
nsIFrame
*
inner
=
GetInner
(
)
;
if
(
aReflowInput
.
ShouldReflowAllKids
(
)
)
{
reflowInner
=
inner
!
=
nullptr
;
reflowLegend
=
legend
!
=
nullptr
;
}
else
{
reflowInner
=
inner
&
&
NS_SUBTREE_DIRTY
(
inner
)
;
reflowLegend
=
legend
&
&
NS_SUBTREE_DIRTY
(
legend
)
;
}
WritingMode
wm
=
GetWritingMode
(
)
;
WritingMode
innerWM
=
inner
?
inner
-
>
GetWritingMode
(
)
:
wm
;
WritingMode
legendWM
=
legend
?
legend
-
>
GetWritingMode
(
)
:
wm
;
LogicalSize
innerAvailSize
=
aReflowInput
.
ComputedSizeWithPadding
(
innerWM
)
;
LogicalSize
legendAvailSize
=
aReflowInput
.
ComputedSizeWithPadding
(
legendWM
)
;
innerAvailSize
.
BSize
(
innerWM
)
=
legendAvailSize
.
BSize
(
legendWM
)
=
NS_UNCONSTRAINEDSIZE
;
LogicalMargin
border
=
aReflowInput
.
ComputedLogicalBorderPadding
(
)
-
aReflowInput
.
ComputedLogicalPadding
(
)
;
LogicalMargin
legendMargin
(
wm
)
;
Maybe
<
ReflowInput
>
legendReflowInput
;
if
(
legend
)
{
legendReflowInput
.
emplace
(
aPresContext
aReflowInput
legend
legendAvailSize
)
;
}
if
(
reflowLegend
)
{
ReflowOutput
legendDesiredSize
(
aReflowInput
)
;
const
nsSize
dummyContainerSize
;
ReflowChild
(
legend
aPresContext
legendDesiredSize
*
legendReflowInput
wm
LogicalPoint
(
wm
)
dummyContainerSize
NS_FRAME_NO_MOVE_FRAME
aStatus
)
;
#
ifdef
NOISY_REFLOW
printf
(
"
returned
(
%
d
%
d
)
\
n
"
legendDesiredSize
.
Width
(
)
legendDesiredSize
.
Height
(
)
)
;
#
endif
legendMargin
=
legend
-
>
GetLogicalUsedMargin
(
wm
)
;
mLegendRect
=
LogicalRect
(
wm
0
0
legendDesiredSize
.
ISize
(
wm
)
+
legendMargin
.
IStartEnd
(
wm
)
legendDesiredSize
.
BSize
(
wm
)
+
legendMargin
.
BStartEnd
(
wm
)
)
;
nscoord
oldSpace
=
mLegendSpace
;
mLegendSpace
=
0
;
if
(
mLegendRect
.
BSize
(
wm
)
>
border
.
BStart
(
wm
)
)
{
mLegendSpace
=
mLegendRect
.
BSize
(
wm
)
-
border
.
BStart
(
wm
)
;
}
else
{
mLegendRect
.
BStart
(
wm
)
=
(
border
.
BStart
(
wm
)
-
mLegendRect
.
BSize
(
wm
)
)
/
2
;
}
if
(
mLegendSpace
!
=
oldSpace
&
&
inner
)
{
reflowInner
=
true
;
}
FinishReflowChild
(
legend
aPresContext
legendDesiredSize
legendReflowInput
.
ptr
(
)
wm
LogicalPoint
(
wm
)
dummyContainerSize
NS_FRAME_NO_MOVE_FRAME
)
;
}
else
if
(
!
legend
)
{
mLegendRect
.
SetEmpty
(
)
;
mLegendSpace
=
0
;
}
else
{
legendMargin
=
legend
-
>
GetLogicalUsedMargin
(
wm
)
;
}
nsSize
containerSize
=
(
LogicalSize
(
wm
0
mLegendSpace
)
+
border
.
Size
(
wm
)
)
.
GetPhysicalSize
(
wm
)
;
if
(
reflowInner
)
{
ReflowInput
kidReflowInput
(
aPresContext
aReflowInput
inner
innerAvailSize
nullptr
ReflowInput
:
:
CALLER_WILL_INIT
)
;
kidReflowInput
.
Init
(
aPresContext
nullptr
nullptr
&
aReflowInput
.
ComputedPhysicalPadding
(
)
)
;
if
(
aReflowInput
.
ComputedBSize
(
)
!
=
NS_UNCONSTRAINEDSIZE
)
{
kidReflowInput
.
SetComputedBSize
(
std
:
:
max
(
0
aReflowInput
.
ComputedBSize
(
)
-
mLegendSpace
)
)
;
}
if
(
aReflowInput
.
ComputedMinBSize
(
)
>
0
)
{
kidReflowInput
.
ComputedMinBSize
(
)
=
std
:
:
max
(
0
aReflowInput
.
ComputedMinBSize
(
)
-
mLegendSpace
)
;
}
if
(
aReflowInput
.
ComputedMaxBSize
(
)
!
=
NS_UNCONSTRAINEDSIZE
)
{
kidReflowInput
.
ComputedMaxBSize
(
)
=
std
:
:
max
(
0
aReflowInput
.
ComputedMaxBSize
(
)
-
mLegendSpace
)
;
}
ReflowOutput
kidDesiredSize
(
kidReflowInput
aDesiredSize
.
mFlags
)
;
NS_ASSERTION
(
kidReflowInput
.
ComputedPhysicalMargin
(
)
=
=
nsMargin
(
0
0
0
0
)
"
Margins
on
anonymous
fieldset
child
not
supported
!
"
)
;
LogicalPoint
pt
(
wm
border
.
IStart
(
wm
)
border
.
BStart
(
wm
)
+
mLegendSpace
)
;
const
nsSize
dummyContainerSize
;
ReflowChild
(
inner
aPresContext
kidDesiredSize
kidReflowInput
wm
pt
dummyContainerSize
0
aStatus
)
;
containerSize
+
=
kidDesiredSize
.
PhysicalSize
(
)
;
FinishReflowChild
(
inner
aPresContext
kidDesiredSize
&
kidReflowInput
wm
pt
containerSize
0
)
;
NS_FRAME_TRACE_REFLOW_OUT
(
"
FieldSet
:
:
Reflow
"
aStatus
)
;
}
else
if
(
inner
)
{
containerSize
+
=
inner
-
>
GetSize
(
)
;
}
LogicalRect
contentRect
(
wm
)
;
if
(
inner
)
{
contentRect
=
inner
-
>
GetLogicalRect
(
wm
containerSize
)
;
}
LogicalSize
availSize
=
aReflowInput
.
ComputedSizeWithPadding
(
wm
)
;
if
(
availSize
.
ISize
(
wm
)
>
contentRect
.
ISize
(
wm
)
)
{
contentRect
.
ISize
(
wm
)
=
innerAvailSize
.
ISize
(
wm
)
;
}
if
(
legend
)
{
LogicalRect
innerContentRect
=
contentRect
;
innerContentRect
.
Deflate
(
wm
aReflowInput
.
ComputedLogicalPadding
(
)
)
;
if
(
innerContentRect
.
ISize
(
wm
)
>
mLegendRect
.
ISize
(
wm
)
)
{
int32_t
align
=
static_cast
<
nsLegendFrame
*
>
(
legend
-
>
GetContentInsertionFrame
(
)
)
-
>
GetLogicalAlign
(
wm
)
;
switch
(
align
)
{
case
NS_STYLE_TEXT_ALIGN_END
:
mLegendRect
.
IStart
(
wm
)
=
innerContentRect
.
IEnd
(
wm
)
-
mLegendRect
.
ISize
(
wm
)
;
break
;
case
NS_STYLE_TEXT_ALIGN_CENTER
:
mLegendRect
.
IStart
(
wm
)
=
innerContentRect
.
IStart
(
wm
)
+
(
innerContentRect
.
ISize
(
wm
)
-
mLegendRect
.
ISize
(
wm
)
)
/
2
;
break
;
case
NS_STYLE_TEXT_ALIGN_START
:
case
NS_STYLE_VERTICAL_ALIGN_TOP
:
case
NS_STYLE_VERTICAL_ALIGN_BOTTOM
:
mLegendRect
.
IStart
(
wm
)
=
innerContentRect
.
IStart
(
wm
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
GetLogicalAlign
value
"
)
;
}
}
else
{
mLegendRect
.
IStart
(
wm
)
=
innerContentRect
.
IStart
(
wm
)
;
}
LogicalRect
actualLegendRect
=
mLegendRect
;
actualLegendRect
.
Deflate
(
wm
legendMargin
)
;
LogicalPoint
actualLegendPos
(
actualLegendRect
.
Origin
(
wm
)
)
;
LogicalMargin
offsets
=
legendReflowInput
-
>
ComputedLogicalOffsets
(
)
.
ConvertTo
(
wm
legendReflowInput
-
>
GetWritingMode
(
)
)
;
ReflowInput
:
:
ApplyRelativePositioning
(
legend
wm
offsets
&
actualLegendPos
containerSize
)
;
legend
-
>
SetPosition
(
wm
actualLegendPos
containerSize
)
;
nsContainerFrame
:
:
PositionFrameView
(
legend
)
;
nsContainerFrame
:
:
PositionChildViews
(
legend
)
;
}
LogicalSize
finalSize
(
wm
contentRect
.
ISize
(
wm
)
+
border
.
IStartEnd
(
wm
)
mLegendSpace
+
border
.
BStartEnd
(
wm
)
+
(
inner
?
inner
-
>
BSize
(
wm
)
:
0
)
)
;
aDesiredSize
.
SetSize
(
wm
finalSize
)
;
aDesiredSize
.
SetOverflowAreasToDesiredBounds
(
)
;
if
(
legend
)
{
ConsiderChildOverflow
(
aDesiredSize
.
mOverflowAreas
legend
)
;
}
if
(
inner
)
{
ConsiderChildOverflow
(
aDesiredSize
.
mOverflowAreas
inner
)
;
}
aDesiredSize
.
mOverflowAreas
.
UnionWith
(
ocBounds
)
;
NS_MergeReflowStatusInto
(
&
aStatus
ocStatus
)
;
FinishReflowWithAbsoluteFrames
(
aPresContext
aDesiredSize
aReflowInput
aStatus
)
;
InvalidateFrame
(
)
;
NS_FRAME_SET_TRUNCATION
(
aStatus
aReflowInput
aDesiredSize
)
;
}
#
ifdef
DEBUG
void
nsFieldSetFrame
:
:
SetInitialChildList
(
ChildListID
aListID
nsFrameList
&
aChildList
)
{
nsContainerFrame
:
:
SetInitialChildList
(
aListID
aChildList
)
;
MOZ_ASSERT
(
aListID
!
=
kPrincipalList
|
|
GetInner
(
)
"
Setting
principal
child
list
should
populate
our
inner
frame
"
)
;
}
void
nsFieldSetFrame
:
:
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
{
MOZ_CRASH
(
"
nsFieldSetFrame
:
:
AppendFrames
not
supported
"
)
;
}
void
nsFieldSetFrame
:
:
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
aFrameList
)
{
MOZ_CRASH
(
"
nsFieldSetFrame
:
:
InsertFrames
not
supported
"
)
;
}
void
nsFieldSetFrame
:
:
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
{
MOZ_CRASH
(
"
nsFieldSetFrame
:
:
RemoveFrame
not
supported
"
)
;
}
#
endif
#
ifdef
ACCESSIBILITY
a11y
:
:
AccType
nsFieldSetFrame
:
:
AccessibleType
(
)
{
return
a11y
:
:
eHTMLGroupboxType
;
}
#
endif
nscoord
nsFieldSetFrame
:
:
GetLogicalBaseline
(
WritingMode
aWritingMode
)
const
{
nsIFrame
*
inner
=
GetInner
(
)
;
return
inner
-
>
BStart
(
aWritingMode
GetParent
(
)
-
>
GetSize
(
)
)
+
inner
-
>
GetLogicalBaseline
(
aWritingMode
)
;
}
