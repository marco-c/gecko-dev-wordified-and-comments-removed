#
include
"
nsFieldSetFrame
.
h
"
#
include
<
algorithm
>
#
include
"
gfxContext
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
nsCSSAnonBoxes
.
h
"
#
include
"
nsCSSRendering
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsLegendFrame
.
h
"
#
include
"
nsStyleConsts
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
layout
;
nsContainerFrame
*
NS_NewFieldSetFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsFieldSetFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsFieldSetFrame
)
nsFieldSetFrame
:
:
nsFieldSetFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
:
nsContainerFrame
(
aStyle
aPresContext
kClassID
)
mLegendRect
(
GetWritingMode
(
)
)
{
mLegendSpace
=
0
;
}
nsRect
nsFieldSetFrame
:
:
VisualBorderRectRelativeToSelf
(
)
const
{
WritingMode
wm
=
GetWritingMode
(
)
;
LogicalRect
r
(
wm
LogicalPoint
(
wm
0
0
)
GetLogicalSize
(
wm
)
)
;
nsSize
containerSize
=
r
.
Size
(
wm
)
.
GetPhysicalSize
(
wm
)
;
if
(
nsIFrame
*
legend
=
GetLegend
(
)
)
{
nscoord
legendSize
=
legend
-
>
GetLogicalSize
(
wm
)
.
BSize
(
wm
)
;
auto
legendMargin
=
legend
-
>
GetLogicalUsedMargin
(
wm
)
;
nscoord
legendStartMargin
=
legendMargin
.
BStart
(
wm
)
;
nscoord
legendEndMargin
=
legendMargin
.
BEnd
(
wm
)
;
nscoord
border
=
GetUsedBorder
(
)
.
Side
(
wm
.
PhysicalSide
(
eLogicalSideBStart
)
)
;
nscoord
off
=
(
legendStartMargin
+
legendSize
/
2
)
-
border
/
2
;
if
(
off
>
nscoord
(
0
)
)
{
nscoord
marginBoxSize
=
legendStartMargin
+
legendSize
+
legendEndMargin
;
if
(
marginBoxSize
>
border
)
{
nscoord
overflow
=
off
+
border
-
marginBoxSize
;
if
(
overflow
>
nscoord
(
0
)
)
{
off
-
=
overflow
;
}
r
.
BStart
(
wm
)
+
=
off
;
r
.
BSize
(
wm
)
-
=
off
;
}
}
}
return
r
.
GetPhysicalRect
(
wm
containerSize
)
;
}
nsIFrame
*
nsFieldSetFrame
:
:
GetInner
(
)
const
{
nsIFrame
*
last
=
mFrames
.
LastChild
(
)
;
if
(
last
&
&
last
-
>
Style
(
)
-
>
GetPseudoType
(
)
=
=
PseudoStyleType
:
:
fieldsetContent
)
{
return
last
;
}
MOZ_ASSERT
(
mFrames
.
LastChild
(
)
=
=
mFrames
.
FirstChild
(
)
)
;
return
nullptr
;
}
nsIFrame
*
nsFieldSetFrame
:
:
GetLegend
(
)
const
{
if
(
mFrames
.
FirstChild
(
)
=
=
GetInner
(
)
)
{
MOZ_ASSERT
(
mFrames
.
LastChild
(
)
=
=
mFrames
.
FirstChild
(
)
)
;
return
nullptr
;
}
MOZ_ASSERT
(
mFrames
.
FirstChild
(
)
&
&
mFrames
.
FirstChild
(
)
-
>
GetContentInsertionFrame
(
)
-
>
IsLegendFrame
(
)
)
;
return
mFrames
.
FirstChild
(
)
;
}
class
nsDisplayFieldSetBorder
final
:
public
nsDisplayItem
{
public
:
nsDisplayFieldSetBorder
(
nsDisplayListBuilder
*
aBuilder
nsFieldSetFrame
*
aFrame
)
:
nsDisplayItem
(
aBuilder
aFrame
)
{
MOZ_COUNT_CTOR
(
nsDisplayFieldSetBorder
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayFieldSetBorder
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayFieldSetBorder
)
;
}
#
endif
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
;
virtual
nsDisplayItemGeometry
*
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
override
;
virtual
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
;
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
NS_DISPLAY_DECL_NAME
(
"
FieldSetBorder
"
TYPE_FIELDSET_BORDER_BACKGROUND
)
}
;
void
nsDisplayFieldSetBorder
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
image
:
:
ImgDrawResult
result
=
static_cast
<
nsFieldSetFrame
*
>
(
mFrame
)
-
>
PaintBorder
(
aBuilder
*
aCtx
ToReferenceFrame
(
)
GetPaintRect
(
)
)
;
nsDisplayItemGenericImageGeometry
:
:
UpdateDrawResult
(
this
result
)
;
}
nsDisplayItemGeometry
*
nsDisplayFieldSetBorder
:
:
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
{
return
new
nsDisplayItemGenericImageGeometry
(
this
aBuilder
)
;
}
void
nsDisplayFieldSetBorder
:
:
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
{
auto
geometry
=
static_cast
<
const
nsDisplayItemGenericImageGeometry
*
>
(
aGeometry
)
;
if
(
aBuilder
-
>
ShouldSyncDecodeImages
(
)
&
&
geometry
-
>
ShouldInvalidateToSyncDecodeImages
(
)
)
{
bool
snap
;
aInvalidRegion
-
>
Or
(
*
aInvalidRegion
GetBounds
(
aBuilder
&
snap
)
)
;
}
nsDisplayItem
:
:
ComputeInvalidationRegion
(
aBuilder
aGeometry
aInvalidRegion
)
;
}
nsRect
nsDisplayFieldSetBorder
:
:
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
{
*
aSnap
=
false
;
return
Frame
(
)
-
>
GetVisualOverflowRectRelativeToSelf
(
)
+
ToReferenceFrame
(
)
;
}
bool
nsDisplayFieldSetBorder
:
:
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
auto
frame
=
static_cast
<
nsFieldSetFrame
*
>
(
mFrame
)
;
auto
offset
=
ToReferenceFrame
(
)
;
nsRect
rect
;
if
(
nsIFrame
*
legend
=
frame
-
>
GetLegend
(
)
)
{
rect
=
frame
-
>
VisualBorderRectRelativeToSelf
(
)
+
offset
;
nsRect
legendRect
=
legend
-
>
GetNormalRect
(
)
+
offset
;
if
(
!
legendRect
.
IsEmpty
(
)
)
{
return
false
;
}
}
else
{
rect
=
nsRect
(
offset
frame
-
>
GetRect
(
)
.
Size
(
)
)
;
}
ImgDrawResult
drawResult
=
nsCSSRendering
:
:
CreateWebRenderCommandsForBorder
(
this
mFrame
rect
aBuilder
aResources
aSc
aManager
aDisplayListBuilder
)
;
if
(
drawResult
=
=
ImgDrawResult
:
:
NOT_SUPPORTED
)
{
return
false
;
}
nsDisplayItemGenericImageGeometry
:
:
UpdateDrawResult
(
this
drawResult
)
;
return
true
;
}
;
void
nsFieldSetFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
if
(
!
(
GetStateBits
(
)
&
NS_FRAME_IS_OVERFLOW_CONTAINER
)
&
&
IsVisibleForPainting
(
)
)
{
if
(
StyleEffects
(
)
-
>
mBoxShadow
)
{
aLists
.
BorderBackground
(
)
-
>
AppendToTop
(
MakeDisplayItem
<
nsDisplayBoxShadowOuter
>
(
aBuilder
this
)
)
;
}
nsDisplayBackgroundImage
:
:
AppendBackgroundItemsToTop
(
aBuilder
this
VisualBorderRectRelativeToSelf
(
)
aLists
.
BorderBackground
(
)
false
)
;
aLists
.
BorderBackground
(
)
-
>
AppendToTop
(
MakeDisplayItem
<
nsDisplayFieldSetBorder
>
(
aBuilder
this
)
)
;
DisplayOutlineUnconditional
(
aBuilder
aLists
)
;
DO_GLOBAL_REFLOW_COUNT_DSP
(
"
nsFieldSetFrame
"
)
;
}
if
(
GetPrevInFlow
(
)
)
{
DisplayOverflowContainers
(
aBuilder
aLists
)
;
}
nsDisplayListCollection
contentDisplayItems
(
aBuilder
)
;
if
(
nsIFrame
*
inner
=
GetInner
(
)
)
{
BuildDisplayListForChild
(
aBuilder
inner
contentDisplayItems
)
;
}
if
(
nsIFrame
*
legend
=
GetLegend
(
)
)
{
nsDisplayListSet
set
(
aLists
aLists
.
BlockBorderBackgrounds
(
)
)
;
BuildDisplayListForChild
(
aBuilder
legend
set
)
;
}
contentDisplayItems
.
MoveTo
(
aLists
)
;
}
image
:
:
ImgDrawResult
nsFieldSetFrame
:
:
PaintBorder
(
nsDisplayListBuilder
*
aBuilder
gfxContext
&
aRenderingContext
nsPoint
aPt
const
nsRect
&
aDirtyRect
)
{
nsRect
rect
=
VisualBorderRectRelativeToSelf
(
)
+
aPt
;
nsPresContext
*
presContext
=
PresContext
(
)
;
PaintBorderFlags
borderFlags
=
aBuilder
-
>
ShouldSyncDecodeImages
(
)
?
PaintBorderFlags
:
:
SYNC_DECODE_IMAGES
:
PaintBorderFlags
(
)
;
ImgDrawResult
result
=
ImgDrawResult
:
:
SUCCESS
;
nsCSSRendering
:
:
PaintBoxShadowInner
(
presContext
aRenderingContext
this
rect
)
;
if
(
nsIFrame
*
legend
=
GetLegend
(
)
)
{
nsRect
legendRect
=
legend
-
>
GetNormalRect
(
)
+
aPt
;
nscoord
borderTopWidth
=
GetUsedBorder
(
)
.
top
;
if
(
legendRect
.
height
<
borderTopWidth
)
{
legendRect
.
height
=
borderTopWidth
;
legendRect
.
y
=
aPt
.
y
;
}
DrawTarget
*
drawTarget
=
aRenderingContext
.
GetDrawTarget
(
)
;
RefPtr
<
PathBuilder
>
pathBuilder
=
drawTarget
-
>
CreatePathBuilder
(
FillRule
:
:
FILL_WINDING
)
;
int32_t
appUnitsPerDevPixel
=
presContext
-
>
AppUnitsPerDevPixel
(
)
;
AppendRectToPath
(
pathBuilder
NSRectToSnappedRect
(
GetVisualOverflowRectRelativeToSelf
(
)
+
aPt
appUnitsPerDevPixel
*
drawTarget
)
true
)
;
AppendRectToPath
(
pathBuilder
NSRectToSnappedRect
(
legendRect
appUnitsPerDevPixel
*
drawTarget
)
false
)
;
RefPtr
<
Path
>
clipPath
=
pathBuilder
-
>
Finish
(
)
;
aRenderingContext
.
Save
(
)
;
aRenderingContext
.
Clip
(
clipPath
)
;
result
&
=
nsCSSRendering
:
:
PaintBorder
(
presContext
aRenderingContext
this
aDirtyRect
rect
mComputedStyle
borderFlags
)
;
aRenderingContext
.
Restore
(
)
;
}
else
{
result
&
=
nsCSSRendering
:
:
PaintBorder
(
presContext
aRenderingContext
this
aDirtyRect
nsRect
(
aPt
mRect
.
Size
(
)
)
mComputedStyle
borderFlags
)
;
}
return
result
;
}
nscoord
nsFieldSetFrame
:
:
GetIntrinsicISize
(
gfxContext
*
aRenderingContext
nsLayoutUtils
:
:
IntrinsicISizeType
aType
)
{
nscoord
legendWidth
=
0
;
nscoord
contentWidth
=
0
;
if
(
!
StyleDisplay
(
)
-
>
IsContainSize
(
)
)
{
if
(
nsIFrame
*
legend
=
GetLegend
(
)
)
{
legendWidth
=
nsLayoutUtils
:
:
IntrinsicForContainer
(
aRenderingContext
legend
aType
)
;
}
if
(
nsIFrame
*
inner
=
GetInner
(
)
)
{
contentWidth
=
nsLayoutUtils
:
:
IntrinsicForContainer
(
aRenderingContext
inner
aType
nsLayoutUtils
:
:
IGNORE_PADDING
)
;
}
}
return
std
:
:
max
(
legendWidth
contentWidth
)
;
}
nscoord
nsFieldSetFrame
:
:
GetMinISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
result
=
0
;
DISPLAY_MIN_INLINE_SIZE
(
this
result
)
;
result
=
GetIntrinsicISize
(
aRenderingContext
nsLayoutUtils
:
:
MIN_ISIZE
)
;
return
result
;
}
nscoord
nsFieldSetFrame
:
:
GetPrefISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
result
=
0
;
DISPLAY_PREF_INLINE_SIZE
(
this
result
)
;
result
=
GetIntrinsicISize
(
aRenderingContext
nsLayoutUtils
:
:
PREF_ISIZE
)
;
return
result
;
}
void
nsFieldSetFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsFieldSetFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aDesiredSize
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
NS_WARNING_ASSERTION
(
aReflowInput
.
ComputedISize
(
)
!
=
NS_INTRINSICSIZE
"
Should
have
a
precomputed
inline
-
size
!
"
)
;
nsOverflowAreas
ocBounds
;
nsReflowStatus
ocStatus
;
if
(
GetPrevInFlow
(
)
)
{
ReflowOverflowContainerChildren
(
aPresContext
aReflowInput
ocBounds
0
ocStatus
)
;
}
bool
reflowInner
;
bool
reflowLegend
;
nsIFrame
*
legend
=
GetLegend
(
)
;
nsIFrame
*
inner
=
GetInner
(
)
;
if
(
aReflowInput
.
ShouldReflowAllKids
(
)
)
{
reflowInner
=
inner
!
=
nullptr
;
reflowLegend
=
legend
!
=
nullptr
;
}
else
{
reflowInner
=
inner
&
&
NS_SUBTREE_DIRTY
(
inner
)
;
reflowLegend
=
legend
&
&
NS_SUBTREE_DIRTY
(
legend
)
;
}
WritingMode
wm
=
GetWritingMode
(
)
;
WritingMode
innerWM
=
inner
?
inner
-
>
GetWritingMode
(
)
:
wm
;
WritingMode
legendWM
=
legend
?
legend
-
>
GetWritingMode
(
)
:
wm
;
LogicalSize
innerAvailSize
=
aReflowInput
.
ComputedSizeWithPadding
(
innerWM
)
;
LogicalSize
legendAvailSize
=
aReflowInput
.
ComputedSize
(
legendWM
)
;
innerAvailSize
.
BSize
(
innerWM
)
=
legendAvailSize
.
BSize
(
legendWM
)
=
NS_UNCONSTRAINEDSIZE
;
LogicalMargin
border
=
aReflowInput
.
ComputedLogicalBorderPadding
(
)
-
aReflowInput
.
ComputedLogicalPadding
(
)
;
LogicalMargin
legendMargin
(
wm
)
;
Maybe
<
ReflowInput
>
legendReflowInput
;
if
(
legend
)
{
legendReflowInput
.
emplace
(
aPresContext
aReflowInput
legend
legendAvailSize
)
;
}
if
(
reflowLegend
)
{
ReflowOutput
legendDesiredSize
(
aReflowInput
)
;
const
nsSize
dummyContainerSize
;
ReflowChild
(
legend
aPresContext
legendDesiredSize
*
legendReflowInput
wm
LogicalPoint
(
wm
)
dummyContainerSize
NS_FRAME_NO_MOVE_FRAME
aStatus
)
;
#
ifdef
NOISY_REFLOW
printf
(
"
returned
(
%
d
%
d
)
\
n
"
legendDesiredSize
.
Width
(
)
legendDesiredSize
.
Height
(
)
)
;
#
endif
legendMargin
=
legend
-
>
GetLogicalUsedMargin
(
wm
)
;
mLegendRect
=
LogicalRect
(
wm
0
0
legendDesiredSize
.
ISize
(
wm
)
+
legendMargin
.
IStartEnd
(
wm
)
legendDesiredSize
.
BSize
(
wm
)
+
legendMargin
.
BStartEnd
(
wm
)
)
;
nscoord
oldSpace
=
mLegendSpace
;
mLegendSpace
=
0
;
nscoord
borderBStart
=
border
.
BStart
(
wm
)
;
if
(
mLegendRect
.
BSize
(
wm
)
>
borderBStart
)
{
mLegendSpace
=
mLegendRect
.
BSize
(
wm
)
-
borderBStart
;
}
else
{
nscoord
off
=
(
borderBStart
-
legendDesiredSize
.
BSize
(
wm
)
)
/
2
;
off
-
=
legendMargin
.
BStart
(
wm
)
;
if
(
off
>
nscoord
(
0
)
)
{
nscoord
overflow
=
off
+
mLegendRect
.
BSize
(
wm
)
-
borderBStart
;
if
(
overflow
>
nscoord
(
0
)
)
{
off
-
=
overflow
;
}
mLegendRect
.
BStart
(
wm
)
+
=
off
;
}
}
if
(
mLegendSpace
!
=
oldSpace
&
&
inner
)
{
reflowInner
=
true
;
}
FinishReflowChild
(
legend
aPresContext
legendDesiredSize
legendReflowInput
.
ptr
(
)
wm
LogicalPoint
(
wm
)
dummyContainerSize
NS_FRAME_NO_MOVE_FRAME
)
;
}
else
if
(
!
legend
)
{
mLegendRect
.
SetEmpty
(
)
;
mLegendSpace
=
0
;
}
else
{
legendMargin
=
legend
-
>
GetLogicalUsedMargin
(
wm
)
;
}
nsSize
containerSize
=
(
LogicalSize
(
wm
0
mLegendSpace
)
+
border
.
Size
(
wm
)
)
.
GetPhysicalSize
(
wm
)
;
if
(
reflowInner
)
{
ReflowInput
kidReflowInput
(
aPresContext
aReflowInput
inner
innerAvailSize
nullptr
ReflowInput
:
:
CALLER_WILL_INIT
)
;
kidReflowInput
.
Init
(
aPresContext
nullptr
nullptr
&
aReflowInput
.
ComputedPhysicalPadding
(
)
)
;
if
(
aReflowInput
.
ComputedBSize
(
)
!
=
NS_UNCONSTRAINEDSIZE
)
{
kidReflowInput
.
SetComputedBSize
(
std
:
:
max
(
0
aReflowInput
.
ComputedBSize
(
)
-
mLegendSpace
)
)
;
}
if
(
aReflowInput
.
ComputedMinBSize
(
)
>
0
)
{
kidReflowInput
.
ComputedMinBSize
(
)
=
std
:
:
max
(
0
aReflowInput
.
ComputedMinBSize
(
)
-
mLegendSpace
)
;
}
if
(
aReflowInput
.
ComputedMaxBSize
(
)
!
=
NS_UNCONSTRAINEDSIZE
)
{
kidReflowInput
.
ComputedMaxBSize
(
)
=
std
:
:
max
(
0
aReflowInput
.
ComputedMaxBSize
(
)
-
mLegendSpace
)
;
}
ReflowOutput
kidDesiredSize
(
kidReflowInput
)
;
NS_ASSERTION
(
kidReflowInput
.
ComputedPhysicalMargin
(
)
=
=
nsMargin
(
0
0
0
0
)
"
Margins
on
anonymous
fieldset
child
not
supported
!
"
)
;
LogicalPoint
pt
(
wm
border
.
IStart
(
wm
)
border
.
BStart
(
wm
)
+
mLegendSpace
)
;
const
nsSize
dummyContainerSize
;
ReflowChild
(
inner
aPresContext
kidDesiredSize
kidReflowInput
wm
pt
dummyContainerSize
0
aStatus
)
;
containerSize
+
=
kidDesiredSize
.
PhysicalSize
(
)
;
FinishReflowChild
(
inner
aPresContext
kidDesiredSize
&
kidReflowInput
wm
pt
containerSize
0
)
;
NS_FRAME_TRACE_REFLOW_OUT
(
"
FieldSet
:
:
Reflow
"
aStatus
)
;
}
else
if
(
inner
)
{
containerSize
+
=
inner
-
>
GetSize
(
)
;
}
LogicalRect
contentRect
(
wm
)
;
if
(
inner
)
{
contentRect
=
inner
-
>
GetLogicalRect
(
wm
containerSize
)
;
}
LogicalSize
availSize
=
aReflowInput
.
ComputedSizeWithPadding
(
wm
)
;
if
(
availSize
.
ISize
(
wm
)
>
contentRect
.
ISize
(
wm
)
)
{
contentRect
.
ISize
(
wm
)
=
innerAvailSize
.
ISize
(
wm
)
;
}
if
(
legend
)
{
LogicalRect
innerContentRect
=
contentRect
;
innerContentRect
.
Deflate
(
wm
aReflowInput
.
ComputedLogicalPadding
(
)
)
;
if
(
innerContentRect
.
ISize
(
wm
)
>
mLegendRect
.
ISize
(
wm
)
)
{
int32_t
align
=
static_cast
<
nsLegendFrame
*
>
(
legend
-
>
GetContentInsertionFrame
(
)
)
-
>
GetLogicalAlign
(
wm
)
;
switch
(
align
)
{
case
NS_STYLE_TEXT_ALIGN_END
:
mLegendRect
.
IStart
(
wm
)
=
innerContentRect
.
IEnd
(
wm
)
-
mLegendRect
.
ISize
(
wm
)
;
break
;
case
NS_STYLE_TEXT_ALIGN_CENTER
:
mLegendRect
.
IStart
(
wm
)
=
innerContentRect
.
IStart
(
wm
)
+
(
innerContentRect
.
ISize
(
wm
)
-
mLegendRect
.
ISize
(
wm
)
)
/
2
;
break
;
case
NS_STYLE_TEXT_ALIGN_START
:
case
NS_STYLE_VERTICAL_ALIGN_TOP
:
case
NS_STYLE_VERTICAL_ALIGN_BOTTOM
:
mLegendRect
.
IStart
(
wm
)
=
innerContentRect
.
IStart
(
wm
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
GetLogicalAlign
value
"
)
;
}
}
else
{
mLegendRect
.
IStart
(
wm
)
=
innerContentRect
.
IStart
(
wm
)
;
}
LogicalRect
actualLegendRect
=
mLegendRect
;
actualLegendRect
.
Deflate
(
wm
legendMargin
)
;
LogicalPoint
actualLegendPos
(
actualLegendRect
.
Origin
(
wm
)
)
;
LogicalMargin
offsets
=
legendReflowInput
-
>
ComputedLogicalOffsets
(
)
.
ConvertTo
(
wm
legendReflowInput
-
>
GetWritingMode
(
)
)
;
ReflowInput
:
:
ApplyRelativePositioning
(
legend
wm
offsets
&
actualLegendPos
containerSize
)
;
legend
-
>
SetPosition
(
wm
actualLegendPos
containerSize
)
;
nsContainerFrame
:
:
PositionFrameView
(
legend
)
;
nsContainerFrame
:
:
PositionChildViews
(
legend
)
;
}
LogicalSize
finalSize
(
wm
contentRect
.
ISize
(
wm
)
+
border
.
IStartEnd
(
wm
)
mLegendSpace
+
border
.
BStartEnd
(
wm
)
+
(
inner
?
inner
-
>
BSize
(
wm
)
:
0
)
)
;
if
(
aReflowInput
.
mStyleDisplay
-
>
IsContainSize
(
)
)
{
nscoord
contentBoxBSize
=
aReflowInput
.
ComputedBSize
(
)
=
=
NS_UNCONSTRAINEDSIZE
?
aReflowInput
.
ApplyMinMaxBSize
(
0
)
:
aReflowInput
.
ComputedBSize
(
)
;
finalSize
.
BSize
(
wm
)
=
contentBoxBSize
+
aReflowInput
.
ComputedLogicalBorderPadding
(
)
.
BStartEnd
(
wm
)
;
}
aDesiredSize
.
SetSize
(
wm
finalSize
)
;
aDesiredSize
.
SetOverflowAreasToDesiredBounds
(
)
;
if
(
legend
)
{
ConsiderChildOverflow
(
aDesiredSize
.
mOverflowAreas
legend
)
;
}
if
(
inner
)
{
ConsiderChildOverflow
(
aDesiredSize
.
mOverflowAreas
inner
)
;
}
aDesiredSize
.
mOverflowAreas
.
UnionWith
(
ocBounds
)
;
aStatus
.
MergeCompletionStatusFrom
(
ocStatus
)
;
FinishReflowWithAbsoluteFrames
(
aPresContext
aDesiredSize
aReflowInput
aStatus
)
;
InvalidateFrame
(
)
;
NS_FRAME_SET_TRUNCATION
(
aStatus
aReflowInput
aDesiredSize
)
;
}
#
ifdef
DEBUG
void
nsFieldSetFrame
:
:
SetInitialChildList
(
ChildListID
aListID
nsFrameList
&
aChildList
)
{
nsContainerFrame
:
:
SetInitialChildList
(
aListID
aChildList
)
;
MOZ_ASSERT
(
aListID
!
=
kPrincipalList
|
|
GetInner
(
)
"
Setting
principal
child
list
should
populate
our
inner
frame
"
)
;
}
void
nsFieldSetFrame
:
:
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
{
MOZ_CRASH
(
"
nsFieldSetFrame
:
:
AppendFrames
not
supported
"
)
;
}
void
nsFieldSetFrame
:
:
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
aFrameList
)
{
MOZ_CRASH
(
"
nsFieldSetFrame
:
:
InsertFrames
not
supported
"
)
;
}
void
nsFieldSetFrame
:
:
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
{
MOZ_CRASH
(
"
nsFieldSetFrame
:
:
RemoveFrame
not
supported
"
)
;
}
#
endif
#
ifdef
ACCESSIBILITY
a11y
:
:
AccType
nsFieldSetFrame
:
:
AccessibleType
(
)
{
return
a11y
:
:
eHTMLGroupboxType
;
}
#
endif
nscoord
nsFieldSetFrame
:
:
GetLogicalBaseline
(
WritingMode
aWM
)
const
{
switch
(
StyleDisplay
(
)
-
>
mDisplay
)
{
case
mozilla
:
:
StyleDisplay
:
:
Grid
:
case
mozilla
:
:
StyleDisplay
:
:
InlineGrid
:
case
mozilla
:
:
StyleDisplay
:
:
Flex
:
case
mozilla
:
:
StyleDisplay
:
:
InlineFlex
:
return
BaselineBOffset
(
aWM
BaselineSharingGroup
:
:
eFirst
AlignmentContext
:
:
eInline
)
;
default
:
return
BSize
(
aWM
)
-
BaselineBOffset
(
aWM
BaselineSharingGroup
:
:
eLast
AlignmentContext
:
:
eInline
)
;
}
}
bool
nsFieldSetFrame
:
:
GetVerticalAlignBaseline
(
WritingMode
aWM
nscoord
*
aBaseline
)
const
{
if
(
StyleDisplay
(
)
-
>
IsContainLayout
(
)
)
{
return
false
;
}
nsIFrame
*
inner
=
GetInner
(
)
;
MOZ_ASSERT
(
!
inner
-
>
GetWritingMode
(
)
.
IsOrthogonalTo
(
aWM
)
)
;
if
(
!
inner
-
>
GetVerticalAlignBaseline
(
aWM
aBaseline
)
)
{
return
false
;
}
nscoord
innerBStart
=
inner
-
>
BStart
(
aWM
GetSize
(
)
)
;
*
aBaseline
+
=
innerBStart
;
return
true
;
}
bool
nsFieldSetFrame
:
:
GetNaturalBaselineBOffset
(
WritingMode
aWM
BaselineSharingGroup
aBaselineGroup
nscoord
*
aBaseline
)
const
{
if
(
StyleDisplay
(
)
-
>
IsContainLayout
(
)
)
{
return
false
;
}
nsIFrame
*
inner
=
GetInner
(
)
;
MOZ_ASSERT
(
!
inner
-
>
GetWritingMode
(
)
.
IsOrthogonalTo
(
aWM
)
)
;
if
(
!
inner
-
>
GetNaturalBaselineBOffset
(
aWM
aBaselineGroup
aBaseline
)
)
{
return
false
;
}
nscoord
innerBStart
=
inner
-
>
BStart
(
aWM
GetSize
(
)
)
;
if
(
aBaselineGroup
=
=
BaselineSharingGroup
:
:
eFirst
)
{
*
aBaseline
+
=
innerBStart
;
}
else
{
*
aBaseline
+
=
BSize
(
aWM
)
-
(
innerBStart
+
inner
-
>
BSize
(
aWM
)
)
;
}
return
true
;
}
void
nsFieldSetFrame
:
:
AppendDirectlyOwnedAnonBoxes
(
nsTArray
<
OwnedAnonBox
>
&
aResult
)
{
if
(
nsIFrame
*
kid
=
GetInner
(
)
)
{
aResult
.
AppendElement
(
OwnedAnonBox
(
kid
)
)
;
}
}
