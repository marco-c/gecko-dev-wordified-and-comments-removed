#
include
"
nsFieldSetFrame
.
h
"
#
include
"
mozilla
/
dom
/
HTMLLegendElement
.
h
"
#
include
<
algorithm
>
#
include
"
gfxContext
.
h
"
#
include
"
mozilla
/
gfx
/
2D
.
h
"
#
include
"
mozilla
/
Likely
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
webrender
/
WebRenderAPI
.
h
"
#
include
"
nsBlockFrame
.
h
"
#
include
"
nsCSSAnonBoxes
.
h
"
#
include
"
nsCSSFrameConstructor
.
h
"
#
include
"
nsCSSRendering
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsIScrollableFrame
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsStyleConsts
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
gfx
;
using
namespace
mozilla
:
:
layout
;
using
image
:
:
ImgDrawResult
;
nsContainerFrame
*
NS_NewFieldSetFrame
(
PresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsFieldSetFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsFieldSetFrame
)
NS_QUERYFRAME_HEAD
(
nsFieldSetFrame
)
NS_QUERYFRAME_ENTRY
(
nsFieldSetFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsContainerFrame
)
nsFieldSetFrame
:
:
nsFieldSetFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
:
nsContainerFrame
(
aStyle
aPresContext
kClassID
)
mLegendRect
(
GetWritingMode
(
)
)
{
mLegendSpace
=
0
;
}
nsRect
nsFieldSetFrame
:
:
VisualBorderRectRelativeToSelf
(
)
const
{
WritingMode
wm
=
GetWritingMode
(
)
;
LogicalRect
r
(
wm
LogicalPoint
(
wm
0
0
)
GetLogicalSize
(
wm
)
)
;
nsSize
containerSize
=
r
.
Size
(
wm
)
.
GetPhysicalSize
(
wm
)
;
nsIFrame
*
legend
=
GetLegend
(
)
;
if
(
legend
&
&
!
GetPrevInFlow
(
)
)
{
nscoord
legendSize
=
legend
-
>
GetLogicalSize
(
wm
)
.
BSize
(
wm
)
;
auto
legendMargin
=
legend
-
>
GetLogicalUsedMargin
(
wm
)
;
nscoord
legendStartMargin
=
legendMargin
.
BStart
(
wm
)
;
nscoord
legendEndMargin
=
legendMargin
.
BEnd
(
wm
)
;
nscoord
border
=
GetUsedBorder
(
)
.
Side
(
wm
.
PhysicalSide
(
eLogicalSideBStart
)
)
;
nscoord
off
=
(
legendStartMargin
+
legendSize
/
2
)
-
border
/
2
;
if
(
off
>
nscoord
(
0
)
)
{
nscoord
marginBoxSize
=
legendStartMargin
+
legendSize
+
legendEndMargin
;
if
(
marginBoxSize
>
border
)
{
nscoord
overflow
=
off
+
border
-
marginBoxSize
;
if
(
overflow
>
nscoord
(
0
)
)
{
off
-
=
overflow
;
}
r
.
BStart
(
wm
)
+
=
off
;
r
.
BSize
(
wm
)
-
=
off
;
}
}
}
return
r
.
GetPhysicalRect
(
wm
containerSize
)
;
}
nsContainerFrame
*
nsFieldSetFrame
:
:
GetInner
(
)
const
{
for
(
nsIFrame
*
child
:
mFrames
)
{
if
(
child
-
>
Style
(
)
-
>
GetPseudoType
(
)
=
=
PseudoStyleType
:
:
fieldsetContent
)
{
return
static_cast
<
nsContainerFrame
*
>
(
child
)
;
}
}
return
nullptr
;
}
nsIFrame
*
nsFieldSetFrame
:
:
GetLegend
(
)
const
{
for
(
nsIFrame
*
child
:
mFrames
)
{
if
(
child
-
>
Style
(
)
-
>
GetPseudoType
(
)
!
=
PseudoStyleType
:
:
fieldsetContent
)
{
return
child
;
}
}
return
nullptr
;
}
namespace
mozilla
{
class
nsDisplayFieldSetBorder
final
:
public
nsPaintedDisplayItem
{
public
:
nsDisplayFieldSetBorder
(
nsDisplayListBuilder
*
aBuilder
nsFieldSetFrame
*
aFrame
)
:
nsPaintedDisplayItem
(
aBuilder
aFrame
)
{
MOZ_COUNT_CTOR
(
nsDisplayFieldSetBorder
)
;
}
MOZ_COUNTED_DTOR_OVERRIDE
(
nsDisplayFieldSetBorder
)
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
;
bool
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
override
;
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
NS_DISPLAY_DECL_NAME
(
"
FieldSetBorder
"
TYPE_FIELDSET_BORDER_BACKGROUND
)
}
;
void
nsDisplayFieldSetBorder
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
Unused
<
<
static_cast
<
nsFieldSetFrame
*
>
(
mFrame
)
-
>
PaintBorder
(
aBuilder
*
aCtx
ToReferenceFrame
(
)
GetPaintRect
(
aBuilder
aCtx
)
)
;
}
nsRect
nsDisplayFieldSetBorder
:
:
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
{
*
aSnap
=
false
;
return
Frame
(
)
-
>
InkOverflowRectRelativeToSelf
(
)
+
ToReferenceFrame
(
)
;
}
bool
nsDisplayFieldSetBorder
:
:
CreateWebRenderCommands
(
mozilla
:
:
wr
:
:
DisplayListBuilder
&
aBuilder
mozilla
:
:
wr
:
:
IpcResourceUpdateQueue
&
aResources
const
StackingContextHelper
&
aSc
mozilla
:
:
layers
:
:
RenderRootStateManager
*
aManager
nsDisplayListBuilder
*
aDisplayListBuilder
)
{
auto
frame
=
static_cast
<
nsFieldSetFrame
*
>
(
mFrame
)
;
auto
offset
=
ToReferenceFrame
(
)
;
Maybe
<
wr
:
:
SpaceAndClipChainHelper
>
clipOut
;
nsRect
rect
=
frame
-
>
VisualBorderRectRelativeToSelf
(
)
+
offset
;
nsDisplayBoxShadowInner
:
:
CreateInsetBoxShadowWebRenderCommands
(
aBuilder
aSc
rect
mFrame
rect
)
;
if
(
nsIFrame
*
legend
=
frame
-
>
GetLegend
(
)
)
{
nsRect
legendRect
=
legend
-
>
GetNormalRect
(
)
+
offset
;
nscoord
borderTopWidth
=
frame
-
>
GetUsedBorder
(
)
.
top
;
if
(
legendRect
.
height
<
borderTopWidth
)
{
legendRect
.
height
=
borderTopWidth
;
legendRect
.
y
=
offset
.
y
;
}
if
(
!
legendRect
.
IsEmpty
(
)
)
{
auto
appUnitsPerDevPixel
=
frame
-
>
PresContext
(
)
-
>
AppUnitsPerDevPixel
(
)
;
auto
layoutRect
=
wr
:
:
ToLayoutRect
(
LayoutDeviceRect
:
:
FromAppUnits
(
frame
-
>
InkOverflowRectRelativeToSelf
(
)
+
offset
appUnitsPerDevPixel
)
)
;
wr
:
:
ComplexClipRegion
region
;
region
.
rect
=
wr
:
:
ToLayoutRect
(
LayoutDeviceRect
:
:
FromAppUnits
(
legendRect
appUnitsPerDevPixel
)
)
;
region
.
mode
=
wr
:
:
ClipMode
:
:
ClipOut
;
region
.
radii
=
wr
:
:
EmptyBorderRadius
(
)
;
auto
rect_clip
=
aBuilder
.
DefineRectClip
(
Nothing
(
)
layoutRect
)
;
auto
complex_clip
=
aBuilder
.
DefineRoundedRectClip
(
Nothing
(
)
region
)
;
auto
clipChain
=
aBuilder
.
DefineClipChain
(
{
rect_clip
complex_clip
}
true
)
;
clipOut
.
emplace
(
aBuilder
clipChain
)
;
}
}
else
{
rect
=
nsRect
(
offset
frame
-
>
GetRect
(
)
.
Size
(
)
)
;
}
ImgDrawResult
drawResult
=
nsCSSRendering
:
:
CreateWebRenderCommandsForBorder
(
this
mFrame
rect
aBuilder
aResources
aSc
aManager
aDisplayListBuilder
)
;
if
(
drawResult
=
=
ImgDrawResult
:
:
NOT_SUPPORTED
)
{
return
false
;
}
return
true
;
}
;
}
void
nsFieldSetFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
if
(
!
HasAnyStateBits
(
NS_FRAME_IS_OVERFLOW_CONTAINER
)
&
&
IsVisibleForPainting
(
)
)
{
DisplayOutsetBoxShadowUnconditional
(
aBuilder
aLists
.
BorderBackground
(
)
)
;
const
nsRect
rect
=
VisualBorderRectRelativeToSelf
(
)
+
aBuilder
-
>
ToReferenceFrame
(
this
)
;
nsDisplayBackgroundImage
:
:
AppendBackgroundItemsToTop
(
aBuilder
this
rect
aLists
.
BorderBackground
(
)
false
)
;
aLists
.
BorderBackground
(
)
-
>
AppendNewToTop
<
nsDisplayFieldSetBorder
>
(
aBuilder
this
)
;
DisplayOutlineUnconditional
(
aBuilder
aLists
)
;
DO_GLOBAL_REFLOW_COUNT_DSP
(
"
nsFieldSetFrame
"
)
;
}
if
(
GetPrevInFlow
(
)
)
{
DisplayOverflowContainers
(
aBuilder
aLists
)
;
}
nsDisplayListCollection
contentDisplayItems
(
aBuilder
)
;
if
(
nsIFrame
*
inner
=
GetInner
(
)
)
{
BuildDisplayListForChild
(
aBuilder
inner
contentDisplayItems
)
;
}
if
(
nsIFrame
*
legend
=
GetLegend
(
)
)
{
nsDisplayListSet
set
(
aLists
aLists
.
BlockBorderBackgrounds
(
)
)
;
BuildDisplayListForChild
(
aBuilder
legend
set
)
;
}
contentDisplayItems
.
MoveTo
(
aLists
)
;
}
ImgDrawResult
nsFieldSetFrame
:
:
PaintBorder
(
nsDisplayListBuilder
*
aBuilder
gfxContext
&
aRenderingContext
nsPoint
aPt
const
nsRect
&
aDirtyRect
)
{
nsRect
rect
=
VisualBorderRectRelativeToSelf
(
)
+
aPt
;
nsPresContext
*
presContext
=
PresContext
(
)
;
const
auto
skipSides
=
GetSkipSides
(
)
;
PaintBorderFlags
borderFlags
=
aBuilder
-
>
ShouldSyncDecodeImages
(
)
?
PaintBorderFlags
:
:
SyncDecodeImages
:
PaintBorderFlags
(
)
;
ImgDrawResult
result
=
ImgDrawResult
:
:
SUCCESS
;
nsCSSRendering
:
:
PaintBoxShadowInner
(
presContext
aRenderingContext
this
rect
)
;
if
(
nsIFrame
*
legend
=
GetLegend
(
)
)
{
nsRect
legendRect
=
legend
-
>
GetNormalRect
(
)
+
aPt
;
nscoord
borderTopWidth
=
GetUsedBorder
(
)
.
top
;
if
(
legendRect
.
height
<
borderTopWidth
)
{
legendRect
.
height
=
borderTopWidth
;
legendRect
.
y
=
aPt
.
y
;
}
DrawTarget
*
drawTarget
=
aRenderingContext
.
GetDrawTarget
(
)
;
RefPtr
<
PathBuilder
>
pathBuilder
=
drawTarget
-
>
CreatePathBuilder
(
FillRule
:
:
FILL_WINDING
)
;
int32_t
appUnitsPerDevPixel
=
presContext
-
>
AppUnitsPerDevPixel
(
)
;
AppendRectToPath
(
pathBuilder
NSRectToSnappedRect
(
InkOverflowRectRelativeToSelf
(
)
+
aPt
appUnitsPerDevPixel
*
drawTarget
)
true
)
;
AppendRectToPath
(
pathBuilder
NSRectToSnappedRect
(
legendRect
appUnitsPerDevPixel
*
drawTarget
)
false
)
;
RefPtr
<
Path
>
clipPath
=
pathBuilder
-
>
Finish
(
)
;
aRenderingContext
.
Save
(
)
;
aRenderingContext
.
Clip
(
clipPath
)
;
result
&
=
nsCSSRendering
:
:
PaintBorder
(
presContext
aRenderingContext
this
aDirtyRect
rect
mComputedStyle
borderFlags
skipSides
)
;
aRenderingContext
.
Restore
(
)
;
}
else
{
result
&
=
nsCSSRendering
:
:
PaintBorder
(
presContext
aRenderingContext
this
aDirtyRect
nsRect
(
aPt
mRect
.
Size
(
)
)
mComputedStyle
borderFlags
skipSides
)
;
}
return
result
;
}
nscoord
nsFieldSetFrame
:
:
GetIntrinsicISize
(
gfxContext
*
aRenderingContext
IntrinsicISizeType
aType
)
{
nscoord
legendWidth
=
0
;
nscoord
contentWidth
=
0
;
if
(
!
StyleDisplay
(
)
-
>
GetContainSizeAxes
(
)
.
mIContained
)
{
if
(
nsIFrame
*
legend
=
GetLegend
(
)
)
{
legendWidth
=
nsLayoutUtils
:
:
IntrinsicForContainer
(
aRenderingContext
legend
aType
)
;
}
if
(
nsIFrame
*
inner
=
GetInner
(
)
)
{
contentWidth
=
nsLayoutUtils
:
:
IntrinsicForContainer
(
aRenderingContext
inner
aType
nsLayoutUtils
:
:
IGNORE_PADDING
)
;
}
}
return
std
:
:
max
(
legendWidth
contentWidth
)
;
}
nscoord
nsFieldSetFrame
:
:
GetMinISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
result
=
0
;
DISPLAY_MIN_INLINE_SIZE
(
this
result
)
;
result
=
GetIntrinsicISize
(
aRenderingContext
IntrinsicISizeType
:
:
MinISize
)
;
return
result
;
}
nscoord
nsFieldSetFrame
:
:
GetPrefISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
result
=
0
;
DISPLAY_PREF_INLINE_SIZE
(
this
result
)
;
result
=
GetIntrinsicISize
(
aRenderingContext
IntrinsicISizeType
:
:
PrefISize
)
;
return
result
;
}
void
nsFieldSetFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
using
LegendAlignValue
=
mozilla
:
:
dom
:
:
HTMLLegendElement
:
:
LegendAlignValue
;
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsFieldSetFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aDesiredSize
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
NS_WARNING_ASSERTION
(
aReflowInput
.
ComputedISize
(
)
!
=
NS_UNCONSTRAINEDSIZE
"
Should
have
a
precomputed
inline
-
size
!
"
)
;
OverflowAreas
ocBounds
;
nsReflowStatus
ocStatus
;
auto
*
prevInFlow
=
static_cast
<
nsFieldSetFrame
*
>
(
GetPrevInFlow
(
)
)
;
if
(
prevInFlow
)
{
ReflowOverflowContainerChildren
(
aPresContext
aReflowInput
ocBounds
ReflowChildFlags
:
:
Default
ocStatus
)
;
AutoFrameListPtr
prevOverflowFrames
(
PresContext
(
)
prevInFlow
-
>
StealOverflowFrames
(
)
)
;
if
(
prevOverflowFrames
)
{
nsContainerFrame
:
:
ReparentFrameViewList
(
*
prevOverflowFrames
prevInFlow
this
)
;
mFrames
.
InsertFrames
(
this
nullptr
*
prevOverflowFrames
)
;
}
}
bool
reflowInner
;
bool
reflowLegend
;
nsIFrame
*
legend
=
GetLegend
(
)
;
nsContainerFrame
*
inner
=
GetInner
(
)
;
if
(
!
legend
|
|
!
inner
)
{
if
(
DrainSelfOverflowList
(
)
)
{
legend
=
GetLegend
(
)
;
inner
=
GetInner
(
)
;
}
}
if
(
aReflowInput
.
ShouldReflowAllKids
(
)
|
|
GetNextInFlow
(
)
|
|
aReflowInput
.
AvailableBSize
(
)
!
=
NS_UNCONSTRAINEDSIZE
)
{
reflowInner
=
inner
!
=
nullptr
;
reflowLegend
=
legend
!
=
nullptr
;
}
else
{
reflowInner
=
inner
&
&
inner
-
>
IsSubtreeDirty
(
)
;
reflowLegend
=
legend
&
&
legend
-
>
IsSubtreeDirty
(
)
;
}
const
auto
wm
=
GetWritingMode
(
)
;
auto
skipSides
=
PreReflowBlockLevelLogicalSkipSides
(
)
;
LogicalMargin
border
=
aReflowInput
.
ComputedLogicalBorder
(
wm
)
.
ApplySkipSides
(
skipSides
)
;
LogicalSize
availSize
(
wm
aReflowInput
.
ComputedSize
(
)
.
ISize
(
wm
)
aReflowInput
.
AvailableBSize
(
)
)
;
LogicalMargin
legendMargin
(
wm
)
;
Maybe
<
ReflowInput
>
legendReflowInput
;
if
(
legend
)
{
const
auto
legendWM
=
legend
-
>
GetWritingMode
(
)
;
LogicalSize
legendAvailSize
=
availSize
.
ConvertTo
(
legendWM
wm
)
;
ComputeSizeFlags
sizeFlags
;
if
(
legend
-
>
StylePosition
(
)
-
>
ISize
(
wm
)
.
IsAuto
(
)
)
{
sizeFlags
=
ComputeSizeFlag
:
:
ShrinkWrap
;
}
ReflowInput
:
:
InitFlags
initFlags
;
StyleSizeOverrides
sizeOverrides
;
legendReflowInput
.
emplace
(
aPresContext
aReflowInput
legend
legendAvailSize
Nothing
(
)
initFlags
sizeOverrides
sizeFlags
)
;
}
const
bool
avoidBreakInside
=
ShouldAvoidBreakInside
(
aReflowInput
)
;
if
(
reflowLegend
)
{
ReflowOutput
legendDesiredSize
(
aReflowInput
)
;
const
nsSize
dummyContainerSize
;
ReflowChild
(
legend
aPresContext
legendDesiredSize
*
legendReflowInput
wm
LogicalPoint
(
wm
)
dummyContainerSize
ReflowChildFlags
:
:
NoMoveFrame
aStatus
)
;
if
(
aReflowInput
.
AvailableBSize
(
)
!
=
NS_UNCONSTRAINEDSIZE
&
&
!
(
HasAnyStateBits
(
NS_FRAME_OUT_OF_FLOW
)
&
&
aReflowInput
.
mStyleDisplay
-
>
IsAbsolutelyPositionedStyle
(
)
)
&
&
!
prevInFlow
&
&
!
aReflowInput
.
mFlags
.
mIsTopOfPage
)
{
if
(
legend
-
>
StyleDisplay
(
)
-
>
BreakBefore
(
)
|
|
aStatus
.
IsInlineBreakBefore
(
)
)
{
aStatus
.
SetInlineLineBreakBeforeAndReset
(
)
;
return
;
}
if
(
MOZ_UNLIKELY
(
avoidBreakInside
)
&
&
!
aStatus
.
IsFullyComplete
(
)
)
{
aStatus
.
SetInlineLineBreakBeforeAndReset
(
)
;
return
;
}
}
legendMargin
=
legend
-
>
GetLogicalUsedMargin
(
wm
)
;
mLegendRect
=
LogicalRect
(
wm
0
0
legendDesiredSize
.
ISize
(
wm
)
+
legendMargin
.
IStartEnd
(
wm
)
legendDesiredSize
.
BSize
(
wm
)
+
legendMargin
.
BStartEnd
(
wm
)
)
;
nscoord
oldSpace
=
mLegendSpace
;
mLegendSpace
=
0
;
nscoord
borderBStart
=
border
.
BStart
(
wm
)
;
if
(
!
prevInFlow
)
{
if
(
mLegendRect
.
BSize
(
wm
)
>
borderBStart
)
{
mLegendSpace
=
mLegendRect
.
BSize
(
wm
)
-
borderBStart
;
}
else
{
nscoord
off
=
(
borderBStart
-
legendDesiredSize
.
BSize
(
wm
)
)
/
2
;
off
-
=
legendMargin
.
BStart
(
wm
)
;
if
(
off
>
nscoord
(
0
)
)
{
nscoord
overflow
=
off
+
mLegendRect
.
BSize
(
wm
)
-
borderBStart
;
if
(
overflow
>
nscoord
(
0
)
)
{
off
-
=
overflow
;
}
mLegendRect
.
BStart
(
wm
)
+
=
off
;
}
}
}
else
{
mLegendSpace
=
mLegendRect
.
BSize
(
wm
)
;
}
if
(
mLegendSpace
!
=
oldSpace
&
&
inner
)
{
reflowInner
=
true
;
}
FinishReflowChild
(
legend
aPresContext
legendDesiredSize
legendReflowInput
.
ptr
(
)
wm
LogicalPoint
(
wm
)
dummyContainerSize
ReflowChildFlags
:
:
NoMoveFrame
)
;
EnsureChildContinuation
(
legend
aStatus
)
;
if
(
aReflowInput
.
AvailableBSize
(
)
!
=
NS_UNCONSTRAINEDSIZE
&
&
!
legend
-
>
GetWritingMode
(
)
.
IsOrthogonalTo
(
wm
)
&
&
legend
-
>
StyleDisplay
(
)
-
>
BreakAfter
(
)
&
&
(
!
legendReflowInput
-
>
mFlags
.
mIsTopOfPage
|
|
mLegendRect
.
BSize
(
wm
)
>
0
)
&
&
aStatus
.
IsComplete
(
)
)
{
availSize
.
BSize
(
wm
)
=
nscoord
(
0
)
;
aStatus
.
Reset
(
)
;
aStatus
.
SetIncomplete
(
)
;
}
}
else
if
(
!
legend
)
{
mLegendRect
.
SetEmpty
(
)
;
mLegendSpace
=
0
;
}
else
{
legendMargin
=
legend
-
>
GetLogicalUsedMargin
(
wm
)
;
}
nsSize
containerSize
=
(
LogicalSize
(
wm
0
mLegendSpace
)
+
border
.
Size
(
wm
)
)
.
GetPhysicalSize
(
wm
)
;
if
(
reflowInner
)
{
LogicalSize
innerAvailSize
=
availSize
;
innerAvailSize
.
ISize
(
wm
)
=
aReflowInput
.
ComputedSizeWithPadding
(
wm
)
.
ISize
(
wm
)
;
nscoord
remainingComputedBSize
=
aReflowInput
.
ComputedBSize
(
)
;
if
(
prevInFlow
&
&
remainingComputedBSize
!
=
NS_UNCONSTRAINEDSIZE
)
{
for
(
nsIFrame
*
prev
=
prevInFlow
;
prev
;
prev
=
prev
-
>
GetPrevInFlow
(
)
)
{
auto
*
prevFieldSet
=
static_cast
<
nsFieldSetFrame
*
>
(
prev
)
;
remainingComputedBSize
-
=
prevFieldSet
-
>
mLegendSpace
;
}
remainingComputedBSize
=
std
:
:
max
(
0
remainingComputedBSize
)
;
}
if
(
innerAvailSize
.
BSize
(
wm
)
!
=
NS_UNCONSTRAINEDSIZE
)
{
innerAvailSize
.
BSize
(
wm
)
-
=
std
:
:
max
(
mLegendRect
.
BSize
(
wm
)
border
.
BStart
(
wm
)
)
;
if
(
StyleBorder
(
)
-
>
mBoxDecorationBreak
=
=
StyleBoxDecorationBreak
:
:
Clone
&
&
(
aReflowInput
.
ComputedBSize
(
)
=
=
NS_UNCONSTRAINEDSIZE
|
|
remainingComputedBSize
+
aReflowInput
.
ComputedLogicalBorderPadding
(
wm
)
.
BStartEnd
(
wm
)
>
=
availSize
.
BSize
(
wm
)
)
)
{
innerAvailSize
.
BSize
(
wm
)
-
=
border
.
BEnd
(
wm
)
;
}
innerAvailSize
.
BSize
(
wm
)
=
std
:
:
max
(
0
innerAvailSize
.
BSize
(
wm
)
)
;
}
ReflowInput
kidReflowInput
(
aPresContext
aReflowInput
inner
innerAvailSize
Nothing
(
)
ReflowInput
:
:
InitFlag
:
:
CallerWillInit
)
;
kidReflowInput
.
Init
(
aPresContext
Nothing
(
)
Nothing
(
)
Some
(
aReflowInput
.
ComputedLogicalPadding
(
inner
-
>
GetWritingMode
(
)
)
)
)
;
if
(
aReflowInput
.
mFlags
.
mIsBSizeSetByAspectRatio
)
{
kidReflowInput
.
mFlags
.
mIsBSizeSetByAspectRatio
=
true
;
}
if
(
kidReflowInput
.
mFlags
.
mIsTopOfPage
)
{
kidReflowInput
.
mFlags
.
mIsTopOfPage
=
!
legend
;
}
if
(
aReflowInput
.
ComputedBSize
(
)
!
=
NS_UNCONSTRAINEDSIZE
)
{
kidReflowInput
.
SetComputedBSize
(
std
:
:
max
(
0
remainingComputedBSize
-
mLegendSpace
)
)
;
}
if
(
aReflowInput
.
ComputedMinBSize
(
)
>
0
)
{
kidReflowInput
.
ComputedMinBSize
(
)
=
std
:
:
max
(
0
aReflowInput
.
ComputedMinBSize
(
)
-
mLegendSpace
)
;
}
if
(
aReflowInput
.
ComputedMaxBSize
(
)
!
=
NS_UNCONSTRAINEDSIZE
)
{
kidReflowInput
.
ComputedMaxBSize
(
)
=
std
:
:
max
(
0
aReflowInput
.
ComputedMaxBSize
(
)
-
mLegendSpace
)
;
}
ReflowOutput
kidDesiredSize
(
kidReflowInput
)
;
NS_ASSERTION
(
kidReflowInput
.
ComputedPhysicalMargin
(
)
=
=
nsMargin
(
0
0
0
0
)
"
Margins
on
anonymous
fieldset
child
not
supported
!
"
)
;
LogicalPoint
pt
(
wm
border
.
IStart
(
wm
)
border
.
BStart
(
wm
)
+
mLegendSpace
)
;
const
nsSize
dummyContainerSize
;
nsReflowStatus
status
;
ReflowChildFlags
flags
=
aStatus
.
IsFullyComplete
(
)
?
ReflowChildFlags
:
:
Default
:
ReflowChildFlags
:
:
NoDeleteNextInFlowChild
;
ReflowChild
(
inner
aPresContext
kidDesiredSize
kidReflowInput
wm
pt
dummyContainerSize
flags
status
)
;
if
(
MOZ_UNLIKELY
(
avoidBreakInside
)
&
&
!
prevInFlow
&
&
!
aReflowInput
.
mFlags
.
mIsTopOfPage
&
&
availSize
.
BSize
(
wm
)
!
=
NS_UNCONSTRAINEDSIZE
)
{
if
(
status
.
IsInlineBreakBefore
(
)
|
|
!
status
.
IsFullyComplete
(
)
)
{
aStatus
.
SetInlineLineBreakBeforeAndReset
(
)
;
return
;
}
}
containerSize
+
=
kidDesiredSize
.
PhysicalSize
(
)
;
FinishReflowChild
(
inner
aPresContext
kidDesiredSize
&
kidReflowInput
wm
pt
containerSize
ReflowChildFlags
:
:
Default
)
;
EnsureChildContinuation
(
inner
status
)
;
aStatus
.
MergeCompletionStatusFrom
(
status
)
;
NS_FRAME_TRACE_REFLOW_OUT
(
"
FieldSet
:
:
Reflow
"
aStatus
)
;
}
else
if
(
inner
)
{
containerSize
+
=
inner
-
>
GetSize
(
)
;
}
else
{
MOZ_ASSERT
(
prevInFlow
"
first
-
in
-
flow
should
always
have
an
inner
frame
"
)
;
for
(
nsIFrame
*
prev
=
prevInFlow
;
prev
;
prev
=
prev
-
>
GetPrevInFlow
(
)
)
{
auto
*
prevFieldSet
=
static_cast
<
nsFieldSetFrame
*
>
(
prev
)
;
if
(
auto
*
prevInner
=
prevFieldSet
-
>
GetInner
(
)
)
{
containerSize
+
=
prevInner
-
>
GetSize
(
)
;
break
;
}
}
}
LogicalRect
contentRect
(
wm
)
;
if
(
inner
)
{
contentRect
=
inner
-
>
GetLogicalRect
(
wm
containerSize
)
;
}
else
if
(
prevInFlow
)
{
auto
size
=
prevInFlow
-
>
GetPaddingRectRelativeToSelf
(
)
.
Size
(
)
;
contentRect
.
ISize
(
wm
)
=
wm
.
IsVertical
(
)
?
size
.
height
:
size
.
width
;
}
if
(
legend
)
{
LogicalRect
innerContentRect
=
contentRect
;
innerContentRect
.
Deflate
(
wm
aReflowInput
.
ComputedLogicalPadding
(
wm
)
)
;
if
(
innerContentRect
.
ISize
(
wm
)
>
mLegendRect
.
ISize
(
wm
)
)
{
auto
*
legendElement
=
dom
:
:
HTMLLegendElement
:
:
FromNode
(
legend
-
>
GetContent
(
)
)
;
switch
(
legendElement
-
>
LogicalAlign
(
wm
)
)
{
case
LegendAlignValue
:
:
InlineEnd
:
mLegendRect
.
IStart
(
wm
)
=
innerContentRect
.
IEnd
(
wm
)
-
mLegendRect
.
ISize
(
wm
)
;
break
;
case
LegendAlignValue
:
:
Center
:
mLegendRect
.
IStart
(
wm
)
=
innerContentRect
.
IStart
(
wm
)
+
(
innerContentRect
.
ISize
(
wm
)
-
mLegendRect
.
ISize
(
wm
)
)
/
2
;
break
;
case
LegendAlignValue
:
:
InlineStart
:
mLegendRect
.
IStart
(
wm
)
=
innerContentRect
.
IStart
(
wm
)
;
break
;
default
:
MOZ_ASSERT_UNREACHABLE
(
"
unexpected
GetLogicalAlign
value
"
)
;
}
}
else
{
mLegendRect
.
IStart
(
wm
)
=
innerContentRect
.
IStart
(
wm
)
;
}
LogicalRect
actualLegendRect
=
mLegendRect
;
actualLegendRect
.
Deflate
(
wm
legendMargin
)
;
LogicalPoint
actualLegendPos
(
actualLegendRect
.
Origin
(
wm
)
)
;
LogicalMargin
offsets
=
legendReflowInput
-
>
ComputedLogicalOffsets
(
wm
)
;
ReflowInput
:
:
ApplyRelativePositioning
(
legend
wm
offsets
&
actualLegendPos
containerSize
)
;
legend
-
>
SetPosition
(
wm
actualLegendPos
containerSize
)
;
nsContainerFrame
:
:
PositionFrameView
(
legend
)
;
nsContainerFrame
:
:
PositionChildViews
(
legend
)
;
}
if
(
!
aStatus
.
IsComplete
(
)
&
&
StyleBorder
(
)
-
>
mBoxDecorationBreak
!
=
StyleBoxDecorationBreak
:
:
Clone
)
{
border
.
BEnd
(
wm
)
=
nscoord
(
0
)
;
}
LogicalSize
finalSize
(
wm
contentRect
.
ISize
(
wm
)
+
border
.
IStartEnd
(
wm
)
mLegendSpace
+
border
.
BStartEnd
(
wm
)
+
(
inner
?
inner
-
>
BSize
(
wm
)
:
0
)
)
;
if
(
aReflowInput
.
mStyleDisplay
-
>
GetContainSizeAxes
(
)
.
mBContained
)
{
nscoord
contentBoxBSize
=
aReflowInput
.
ComputedBSize
(
)
=
=
NS_UNCONSTRAINEDSIZE
?
aReflowInput
.
ApplyMinMaxBSize
(
0
)
:
aReflowInput
.
ComputedBSize
(
)
;
finalSize
.
BSize
(
wm
)
=
contentBoxBSize
+
aReflowInput
.
ComputedLogicalBorderPadding
(
wm
)
.
BStartEnd
(
wm
)
;
}
if
(
aStatus
.
IsComplete
(
)
&
&
aReflowInput
.
AvailableBSize
(
)
!
=
NS_UNCONSTRAINEDSIZE
&
&
finalSize
.
BSize
(
wm
)
>
aReflowInput
.
AvailableBSize
(
)
&
&
border
.
BEnd
(
wm
)
>
0
&
&
aReflowInput
.
AvailableBSize
(
)
>
border
.
BEnd
(
wm
)
)
{
if
(
MOZ_UNLIKELY
(
avoidBreakInside
)
)
{
aStatus
.
SetInlineLineBreakBeforeAndReset
(
)
;
return
;
}
else
{
if
(
StyleBorder
(
)
-
>
mBoxDecorationBreak
=
=
StyleBoxDecorationBreak
:
:
Slice
)
{
finalSize
.
BSize
(
wm
)
-
=
border
.
BEnd
(
wm
)
;
}
aStatus
.
SetIncomplete
(
)
;
}
}
if
(
!
aStatus
.
IsComplete
(
)
)
{
MOZ_ASSERT
(
aReflowInput
.
AvailableBSize
(
)
!
=
NS_UNCONSTRAINEDSIZE
"
must
be
Complete
in
an
unconstrained
available
block
-
size
"
)
;
finalSize
.
BSize
(
wm
)
=
std
:
:
max
(
finalSize
.
BSize
(
wm
)
aReflowInput
.
AvailableBSize
(
)
)
;
}
aDesiredSize
.
SetSize
(
wm
finalSize
)
;
aDesiredSize
.
SetOverflowAreasToDesiredBounds
(
)
;
if
(
legend
)
{
ConsiderChildOverflow
(
aDesiredSize
.
mOverflowAreas
legend
)
;
}
if
(
inner
)
{
ConsiderChildOverflow
(
aDesiredSize
.
mOverflowAreas
inner
)
;
}
aDesiredSize
.
mOverflowAreas
.
UnionWith
(
ocBounds
)
;
aStatus
.
MergeCompletionStatusFrom
(
ocStatus
)
;
FinishReflowWithAbsoluteFrames
(
aPresContext
aDesiredSize
aReflowInput
aStatus
)
;
InvalidateFrame
(
)
;
}
void
nsFieldSetFrame
:
:
SetInitialChildList
(
ChildListID
aListID
nsFrameList
&
aChildList
)
{
nsContainerFrame
:
:
SetInitialChildList
(
aListID
aChildList
)
;
if
(
nsBlockFrame
*
legend
=
do_QueryFrame
(
GetLegend
(
)
)
)
{
legend
-
>
AddStateBits
(
NS_BLOCK_FORMATTING_CONTEXT_STATE_BITS
)
;
}
MOZ_ASSERT
(
aListID
!
=
kPrincipalList
|
|
GetInner
(
)
|
|
GetLegend
(
)
"
Setting
principal
child
list
should
populate
our
inner
frame
"
"
or
our
rendered
legend
"
)
;
}
void
nsFieldSetFrame
:
:
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
{
MOZ_ASSERT
(
aListID
=
=
kNoReflowPrincipalList
&
&
HasAnyStateBits
(
NS_FRAME_FIRST_REFLOW
)
"
AppendFrames
should
only
be
used
from
"
"
nsCSSFrameConstructor
:
:
ConstructFieldSetFrame
"
)
;
nsContainerFrame
:
:
AppendFrames
(
aListID
aFrameList
)
;
MOZ_ASSERT
(
GetInner
(
)
"
at
this
point
we
should
have
an
inner
frame
"
)
;
}
void
nsFieldSetFrame
:
:
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
const
nsLineList
:
:
iterator
*
aPrevFrameLine
nsFrameList
&
aFrameList
)
{
MOZ_ASSERT
(
aListID
=
=
kPrincipalList
&
&
!
aPrevFrame
&
&
!
GetLegend
(
)
"
InsertFrames
should
only
be
used
to
prepend
a
rendered
legend
"
"
from
nsCSSFrameConstructor
:
:
ConstructFramesFromItemList
"
)
;
nsContainerFrame
:
:
InsertFrames
(
aListID
aPrevFrame
aPrevFrameLine
aFrameList
)
;
MOZ_ASSERT
(
GetLegend
(
)
)
;
if
(
nsBlockFrame
*
legend
=
do_QueryFrame
(
GetLegend
(
)
)
)
{
legend
-
>
AddStateBits
(
NS_BLOCK_FORMATTING_CONTEXT_STATE_BITS
)
;
}
}
#
ifdef
DEBUG
void
nsFieldSetFrame
:
:
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
{
MOZ_CRASH
(
"
nsFieldSetFrame
:
:
RemoveFrame
not
supported
"
)
;
}
#
endif
#
ifdef
ACCESSIBILITY
a11y
:
:
AccType
nsFieldSetFrame
:
:
AccessibleType
(
)
{
return
a11y
:
:
eHTMLGroupboxType
;
}
#
endif
nscoord
nsFieldSetFrame
:
:
GetLogicalBaseline
(
WritingMode
aWM
)
const
{
switch
(
StyleDisplay
(
)
-
>
DisplayInside
(
)
)
{
case
mozilla
:
:
StyleDisplayInside
:
:
Grid
:
case
mozilla
:
:
StyleDisplayInside
:
:
Flex
:
return
BaselineBOffset
(
aWM
BaselineSharingGroup
:
:
First
AlignmentContext
:
:
Inline
)
;
default
:
return
BSize
(
aWM
)
-
BaselineBOffset
(
aWM
BaselineSharingGroup
:
:
Last
AlignmentContext
:
:
Inline
)
;
}
}
bool
nsFieldSetFrame
:
:
GetVerticalAlignBaseline
(
WritingMode
aWM
nscoord
*
aBaseline
)
const
{
if
(
StyleDisplay
(
)
-
>
IsContainLayout
(
)
)
{
return
false
;
}
nsIFrame
*
inner
=
GetInner
(
)
;
if
(
MOZ_UNLIKELY
(
!
inner
)
)
{
return
false
;
}
MOZ_ASSERT
(
!
inner
-
>
GetWritingMode
(
)
.
IsOrthogonalTo
(
aWM
)
)
;
if
(
!
inner
-
>
GetVerticalAlignBaseline
(
aWM
aBaseline
)
)
{
return
false
;
}
nscoord
innerBStart
=
inner
-
>
BStart
(
aWM
GetSize
(
)
)
;
*
aBaseline
+
=
innerBStart
;
return
true
;
}
bool
nsFieldSetFrame
:
:
GetNaturalBaselineBOffset
(
WritingMode
aWM
BaselineSharingGroup
aBaselineGroup
nscoord
*
aBaseline
)
const
{
if
(
StyleDisplay
(
)
-
>
IsContainLayout
(
)
)
{
return
false
;
}
nsIFrame
*
inner
=
GetInner
(
)
;
if
(
MOZ_UNLIKELY
(
!
inner
)
)
{
return
false
;
}
MOZ_ASSERT
(
!
inner
-
>
GetWritingMode
(
)
.
IsOrthogonalTo
(
aWM
)
)
;
if
(
!
inner
-
>
GetNaturalBaselineBOffset
(
aWM
aBaselineGroup
aBaseline
)
)
{
return
false
;
}
nscoord
innerBStart
=
inner
-
>
BStart
(
aWM
GetSize
(
)
)
;
if
(
aBaselineGroup
=
=
BaselineSharingGroup
:
:
First
)
{
*
aBaseline
+
=
innerBStart
;
}
else
{
*
aBaseline
+
=
BSize
(
aWM
)
-
(
innerBStart
+
inner
-
>
BSize
(
aWM
)
)
;
}
return
true
;
}
nsIScrollableFrame
*
nsFieldSetFrame
:
:
GetScrollTargetFrame
(
)
const
{
return
do_QueryFrame
(
GetInner
(
)
)
;
}
void
nsFieldSetFrame
:
:
AppendDirectlyOwnedAnonBoxes
(
nsTArray
<
OwnedAnonBox
>
&
aResult
)
{
if
(
nsIFrame
*
kid
=
GetInner
(
)
)
{
aResult
.
AppendElement
(
OwnedAnonBox
(
kid
)
)
;
}
}
void
nsFieldSetFrame
:
:
EnsureChildContinuation
(
nsIFrame
*
aChild
const
nsReflowStatus
&
aStatus
)
{
MOZ_ASSERT
(
aChild
=
=
GetLegend
(
)
|
|
aChild
=
=
GetInner
(
)
"
unexpected
child
frame
"
)
;
nsIFrame
*
nif
=
aChild
-
>
GetNextInFlow
(
)
;
if
(
aStatus
.
IsFullyComplete
(
)
)
{
if
(
nif
)
{
nsContainerFrame
:
:
RemoveFrame
(
kNoReflowPrincipalList
nif
)
;
MOZ_ASSERT
(
!
aChild
-
>
GetNextInFlow
(
)
)
;
}
}
else
{
nsFrameList
nifs
;
if
(
!
nif
)
{
auto
*
fc
=
PresShell
(
)
-
>
FrameConstructor
(
)
;
nif
=
fc
-
>
CreateContinuingFrame
(
aChild
this
)
;
if
(
aStatus
.
IsOverflowIncomplete
(
)
)
{
nif
-
>
AddStateBits
(
NS_FRAME_IS_OVERFLOW_CONTAINER
)
;
}
nifs
=
nsFrameList
(
nif
nif
)
;
}
else
{
for
(
nsIFrame
*
n
=
nif
;
n
;
n
=
n
-
>
GetNextInFlow
(
)
)
{
n
-
>
GetParent
(
)
-
>
StealFrame
(
n
)
;
nifs
.
AppendFrame
(
this
n
)
;
if
(
aStatus
.
IsOverflowIncomplete
(
)
)
{
n
-
>
AddStateBits
(
NS_FRAME_IS_OVERFLOW_CONTAINER
)
;
}
else
{
n
-
>
RemoveStateBits
(
NS_FRAME_IS_OVERFLOW_CONTAINER
)
;
}
}
}
if
(
aStatus
.
IsOverflowIncomplete
(
)
)
{
if
(
nsFrameList
*
eoc
=
GetExcessOverflowContainers
(
)
)
{
eoc
-
>
AppendFrames
(
nullptr
nifs
)
;
}
else
{
SetExcessOverflowContainers
(
std
:
:
move
(
nifs
)
)
;
}
}
else
{
if
(
nsFrameList
*
oc
=
GetOverflowFrames
(
)
)
{
oc
-
>
AppendFrames
(
nullptr
nifs
)
;
}
else
{
SetOverflowFrames
(
std
:
:
move
(
nifs
)
)
;
}
}
}
}
