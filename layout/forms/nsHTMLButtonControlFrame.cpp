#
include
"
nsHTMLButtonControlFrame
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsIFormControlFrame
.
h
"
#
include
"
nsIFrameInlines
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsButtonFrameRenderer
.
h
"
#
include
"
nsCSSAnonBoxes
.
h
"
#
include
"
nsCheckboxRadioFrame
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
<
algorithm
>
using
namespace
mozilla
;
nsContainerFrame
*
NS_NewHTMLButtonControlFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsHTMLButtonControlFrame
(
aStyle
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsHTMLButtonControlFrame
)
nsHTMLButtonControlFrame
:
:
nsHTMLButtonControlFrame
(
ComputedStyle
*
aStyle
nsIFrame
:
:
ClassID
aID
)
:
nsContainerFrame
(
aStyle
aID
)
{
}
nsHTMLButtonControlFrame
:
:
~
nsHTMLButtonControlFrame
(
)
{
}
void
nsHTMLButtonControlFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
{
nsCheckboxRadioFrame
:
:
RegUnRegAccessKey
(
static_cast
<
nsIFrame
*
>
(
this
)
false
)
;
nsContainerFrame
:
:
DestroyFrom
(
aDestructRoot
aPostDestroyData
)
;
}
void
nsHTMLButtonControlFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
nsContainerFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
mRenderer
.
SetFrame
(
this
PresContext
(
)
)
;
}
NS_QUERYFRAME_HEAD
(
nsHTMLButtonControlFrame
)
NS_QUERYFRAME_ENTRY
(
nsIFormControlFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsContainerFrame
)
#
ifdef
ACCESSIBILITY
a11y
:
:
AccType
nsHTMLButtonControlFrame
:
:
AccessibleType
(
)
{
return
a11y
:
:
eHTMLButtonType
;
}
#
endif
void
nsHTMLButtonControlFrame
:
:
SetFocus
(
bool
aOn
bool
aRepaint
)
{
}
nsresult
nsHTMLButtonControlFrame
:
:
HandleEvent
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
{
if
(
mRenderer
.
isDisabled
(
)
)
{
return
NS_OK
;
}
return
nsFrame
:
:
HandleEvent
(
aPresContext
aEvent
aEventStatus
)
;
}
bool
nsHTMLButtonControlFrame
:
:
ShouldClipPaintingToBorderBox
(
)
{
return
IsInput
(
)
|
|
StyleDisplay
(
)
-
>
mOverflowX
!
=
StyleOverflow
:
:
Visible
;
}
void
nsHTMLButtonControlFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
Maybe
<
DisplayListClipState
:
:
AutoSaveRestore
>
eventClipState
;
const
bool
isForEventDelivery
=
aBuilder
-
>
IsForEventDelivery
(
)
;
if
(
isForEventDelivery
)
{
eventClipState
.
emplace
(
aBuilder
)
;
nsRect
rect
(
aBuilder
-
>
ToReferenceFrame
(
this
)
GetSize
(
)
)
;
nscoord
radii
[
8
]
;
bool
hasRadii
=
GetBorderRadii
(
radii
)
;
eventClipState
-
>
ClipContainingBlockDescendants
(
rect
hasRadii
?
radii
:
nullptr
)
;
}
nsDisplayList
onTop
;
if
(
IsVisibleForPainting
(
)
)
{
mRenderer
.
DisplayButton
(
aBuilder
aLists
.
BorderBackground
(
)
&
onTop
)
;
}
nsDisplayListCollection
set
(
aBuilder
)
;
{
DisplayListClipState
:
:
AutoSaveRestore
clipState
(
aBuilder
)
;
if
(
ShouldClipPaintingToBorderBox
(
)
)
{
nsMargin
border
=
StyleBorder
(
)
-
>
GetComputedBorder
(
)
;
nsRect
rect
(
aBuilder
-
>
ToReferenceFrame
(
this
)
GetSize
(
)
)
;
rect
.
Deflate
(
border
)
;
nscoord
radii
[
8
]
;
bool
hasRadii
=
GetPaddingBoxBorderRadii
(
radii
)
;
clipState
.
ClipContainingBlockDescendants
(
rect
hasRadii
?
radii
:
nullptr
)
;
}
BuildDisplayListForChild
(
aBuilder
mFrames
.
FirstChild
(
)
set
DISPLAY_CHILD_FORCE_PSEUDO_STACKING_CONTEXT
)
;
}
set
.
Content
(
)
-
>
AppendToTop
(
&
onTop
)
;
set
.
MoveTo
(
aLists
)
;
DisplayOutline
(
aBuilder
aLists
)
;
DisplaySelectionOverlay
(
aBuilder
aLists
.
Content
(
)
)
;
}
nscoord
nsHTMLButtonControlFrame
:
:
GetMinISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
result
;
DISPLAY_MIN_INLINE_SIZE
(
this
result
)
;
if
(
StyleDisplay
(
)
-
>
IsContainSize
(
)
)
{
result
=
0
;
}
else
{
nsIFrame
*
kid
=
mFrames
.
FirstChild
(
)
;
result
=
nsLayoutUtils
:
:
IntrinsicForContainer
(
aRenderingContext
kid
nsLayoutUtils
:
:
MIN_ISIZE
)
;
}
return
result
;
}
nscoord
nsHTMLButtonControlFrame
:
:
GetPrefISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
result
;
DISPLAY_PREF_INLINE_SIZE
(
this
result
)
;
if
(
StyleDisplay
(
)
-
>
IsContainSize
(
)
)
{
result
=
0
;
}
else
{
nsIFrame
*
kid
=
mFrames
.
FirstChild
(
)
;
result
=
nsLayoutUtils
:
:
IntrinsicForContainer
(
aRenderingContext
kid
nsLayoutUtils
:
:
PREF_ISIZE
)
;
}
return
result
;
}
void
nsHTMLButtonControlFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsHTMLButtonControlFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aDesiredSize
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
if
(
mState
&
NS_FRAME_FIRST_REFLOW
)
{
nsCheckboxRadioFrame
:
:
RegUnRegAccessKey
(
static_cast
<
nsIFrame
*
>
(
this
)
true
)
;
}
nsIFrame
*
firstKid
=
mFrames
.
FirstChild
(
)
;
MOZ_ASSERT
(
firstKid
"
Button
should
have
a
child
frame
for
its
contents
"
)
;
MOZ_ASSERT
(
!
firstKid
-
>
GetNextSibling
(
)
"
Button
should
have
exactly
one
child
frame
"
)
;
MOZ_ASSERT
(
firstKid
-
>
Style
(
)
-
>
GetPseudo
(
)
=
=
nsCSSAnonBoxes
:
:
buttonContent
(
)
"
Button
'
s
child
frame
has
unexpected
pseudo
type
!
"
)
;
ReflowButtonContents
(
aPresContext
aDesiredSize
aReflowInput
firstKid
)
;
if
(
!
ShouldClipPaintingToBorderBox
(
)
)
{
ConsiderChildOverflow
(
aDesiredSize
.
mOverflowAreas
firstKid
)
;
}
FinishReflowWithAbsoluteFrames
(
aPresContext
aDesiredSize
aReflowInput
aStatus
)
;
aStatus
.
Reset
(
)
;
MOZ_ASSERT
(
!
GetNextInFlow
(
)
)
;
NS_FRAME_SET_TRUNCATION
(
aStatus
aReflowInput
aDesiredSize
)
;
}
void
nsHTMLButtonControlFrame
:
:
ReflowButtonContents
(
nsPresContext
*
aPresContext
ReflowOutput
&
aButtonDesiredSize
const
ReflowInput
&
aButtonReflowInput
nsIFrame
*
aFirstKid
)
{
WritingMode
wm
=
GetWritingMode
(
)
;
LogicalSize
availSize
=
aButtonReflowInput
.
ComputedSize
(
wm
)
;
availSize
.
BSize
(
wm
)
=
NS_INTRINSICSIZE
;
const
LogicalMargin
&
clbp
=
aButtonReflowInput
.
ComputedLogicalBorderPadding
(
)
;
LogicalPoint
childPos
(
wm
)
;
childPos
.
I
(
wm
)
=
clbp
.
IStart
(
wm
)
;
availSize
.
ISize
(
wm
)
=
std
:
:
max
(
availSize
.
ISize
(
wm
)
0
)
;
ReflowInput
contentsReflowInput
(
aPresContext
aButtonReflowInput
aFirstKid
availSize
)
;
nsReflowStatus
contentsReflowStatus
;
ReflowOutput
contentsDesiredSize
(
aButtonReflowInput
)
;
childPos
.
B
(
wm
)
=
0
;
const
LayoutFrameType
frameType
=
aFirstKid
-
>
Type
(
)
;
if
(
frameType
=
=
LayoutFrameType
:
:
FlexContainer
|
|
frameType
=
=
LayoutFrameType
:
:
GridContainer
)
{
contentsReflowInput
.
ComputedBSize
(
)
=
aButtonReflowInput
.
ComputedBSize
(
)
;
contentsReflowInput
.
ComputedMinBSize
(
)
=
aButtonReflowInput
.
ComputedMinBSize
(
)
;
contentsReflowInput
.
ComputedMaxBSize
(
)
=
aButtonReflowInput
.
ComputedMaxBSize
(
)
;
}
nsSize
dummyContainerSize
;
ReflowChild
(
aFirstKid
aPresContext
contentsDesiredSize
contentsReflowInput
wm
childPos
dummyContainerSize
0
contentsReflowStatus
)
;
MOZ_ASSERT
(
contentsReflowStatus
.
IsComplete
(
)
"
We
gave
button
-
contents
frame
unconstrained
available
height
"
"
so
it
should
be
complete
"
)
;
LogicalSize
buttonContentBox
(
wm
)
;
if
(
aButtonReflowInput
.
ComputedBSize
(
)
!
=
NS_INTRINSICSIZE
)
{
buttonContentBox
.
BSize
(
wm
)
=
aButtonReflowInput
.
ComputedBSize
(
)
;
}
else
if
(
aButtonReflowInput
.
mStyleDisplay
-
>
IsContainSize
(
)
)
{
buttonContentBox
.
BSize
(
wm
)
=
aButtonReflowInput
.
ComputedMinBSize
(
)
;
}
else
{
buttonContentBox
.
BSize
(
wm
)
=
contentsDesiredSize
.
BSize
(
wm
)
;
buttonContentBox
.
BSize
(
wm
)
=
NS_CSS_MINMAX
(
buttonContentBox
.
BSize
(
wm
)
aButtonReflowInput
.
ComputedMinBSize
(
)
aButtonReflowInput
.
ComputedMaxBSize
(
)
)
;
}
if
(
aButtonReflowInput
.
ComputedISize
(
)
!
=
NS_INTRINSICSIZE
)
{
buttonContentBox
.
ISize
(
wm
)
=
aButtonReflowInput
.
ComputedISize
(
)
;
}
else
if
(
aButtonReflowInput
.
mStyleDisplay
-
>
IsContainSize
(
)
)
{
buttonContentBox
.
ISize
(
wm
)
=
aButtonReflowInput
.
ComputedMinISize
(
)
;
}
else
{
buttonContentBox
.
ISize
(
wm
)
=
contentsDesiredSize
.
ISize
(
wm
)
;
buttonContentBox
.
ISize
(
wm
)
=
NS_CSS_MINMAX
(
buttonContentBox
.
ISize
(
wm
)
aButtonReflowInput
.
ComputedMinISize
(
)
aButtonReflowInput
.
ComputedMaxISize
(
)
)
;
}
nscoord
extraSpace
=
buttonContentBox
.
BSize
(
wm
)
-
contentsDesiredSize
.
BSize
(
wm
)
;
childPos
.
B
(
wm
)
=
std
:
:
max
(
0
extraSpace
/
2
)
;
childPos
.
B
(
wm
)
+
=
clbp
.
BStart
(
wm
)
;
nsSize
containerSize
=
(
buttonContentBox
+
clbp
.
Size
(
wm
)
)
.
GetPhysicalSize
(
wm
)
;
FinishReflowChild
(
aFirstKid
aPresContext
contentsDesiredSize
&
contentsReflowInput
wm
childPos
containerSize
0
)
;
if
(
contentsDesiredSize
.
BlockStartAscent
(
)
=
=
ReflowOutput
:
:
ASK_FOR_BASELINE
)
{
WritingMode
wm
=
aButtonReflowInput
.
GetWritingMode
(
)
;
contentsDesiredSize
.
SetBlockStartAscent
(
aFirstKid
-
>
GetLogicalBaseline
(
wm
)
)
;
}
aButtonDesiredSize
.
SetSize
(
wm
LogicalSize
(
wm
aButtonReflowInput
.
ComputedISize
(
)
+
clbp
.
IStartEnd
(
wm
)
buttonContentBox
.
BSize
(
wm
)
+
clbp
.
BStartEnd
(
wm
)
)
)
;
if
(
aButtonReflowInput
.
mStyleDisplay
-
>
IsContainSize
(
)
)
{
nscoord
containAscent
=
(
buttonContentBox
.
BSize
(
wm
)
/
2
)
+
clbp
.
BStart
(
wm
)
;
aButtonDesiredSize
.
SetBlockStartAscent
(
containAscent
)
;
}
else
if
(
aButtonDesiredSize
.
GetWritingMode
(
)
.
IsOrthogonalTo
(
wm
)
)
{
aButtonDesiredSize
.
SetBlockStartAscent
(
contentsDesiredSize
.
ISize
(
wm
)
)
;
}
else
{
aButtonDesiredSize
.
SetBlockStartAscent
(
contentsDesiredSize
.
BlockStartAscent
(
)
+
childPos
.
B
(
wm
)
)
;
}
aButtonDesiredSize
.
SetOverflowAreasToDesiredBounds
(
)
;
}
bool
nsHTMLButtonControlFrame
:
:
GetVerticalAlignBaseline
(
mozilla
:
:
WritingMode
aWM
nscoord
*
aBaseline
)
const
{
nsIFrame
*
inner
=
mFrames
.
FirstChild
(
)
;
if
(
MOZ_UNLIKELY
(
inner
-
>
GetWritingMode
(
)
.
IsOrthogonalTo
(
aWM
)
)
)
{
return
false
;
}
if
(
!
inner
-
>
GetVerticalAlignBaseline
(
aWM
aBaseline
)
)
{
*
aBaseline
=
inner
-
>
SynthesizeBaselineBOffsetFromBorderBox
(
aWM
BaselineSharingGroup
:
:
eFirst
)
;
}
nscoord
innerBStart
=
inner
-
>
BStart
(
aWM
GetSize
(
)
)
;
*
aBaseline
+
=
innerBStart
;
return
true
;
}
bool
nsHTMLButtonControlFrame
:
:
GetNaturalBaselineBOffset
(
mozilla
:
:
WritingMode
aWM
BaselineSharingGroup
aBaselineGroup
nscoord
*
aBaseline
)
const
{
nsIFrame
*
inner
=
mFrames
.
FirstChild
(
)
;
if
(
MOZ_UNLIKELY
(
inner
-
>
GetWritingMode
(
)
.
IsOrthogonalTo
(
aWM
)
)
)
{
return
false
;
}
if
(
!
inner
-
>
GetNaturalBaselineBOffset
(
aWM
aBaselineGroup
aBaseline
)
)
{
*
aBaseline
=
inner
-
>
SynthesizeBaselineBOffsetFromBorderBox
(
aWM
aBaselineGroup
)
;
}
nscoord
innerBStart
=
inner
-
>
BStart
(
aWM
GetSize
(
)
)
;
if
(
aBaselineGroup
=
=
BaselineSharingGroup
:
:
eFirst
)
{
*
aBaseline
+
=
innerBStart
;
}
else
{
*
aBaseline
+
=
BSize
(
aWM
)
-
(
innerBStart
+
inner
-
>
BSize
(
aWM
)
)
;
}
return
true
;
}
nsresult
nsHTMLButtonControlFrame
:
:
SetFormProperty
(
nsAtom
*
aName
const
nsAString
&
aValue
)
{
if
(
nsGkAtoms
:
:
value
=
=
aName
)
{
return
mContent
-
>
AsElement
(
)
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
value
aValue
true
)
;
}
return
NS_OK
;
}
ComputedStyle
*
nsHTMLButtonControlFrame
:
:
GetAdditionalComputedStyle
(
int32_t
aIndex
)
const
{
return
mRenderer
.
GetComputedStyle
(
aIndex
)
;
}
void
nsHTMLButtonControlFrame
:
:
SetAdditionalComputedStyle
(
int32_t
aIndex
ComputedStyle
*
aComputedStyle
)
{
mRenderer
.
SetComputedStyle
(
aIndex
aComputedStyle
)
;
}
void
nsHTMLButtonControlFrame
:
:
AppendDirectlyOwnedAnonBoxes
(
nsTArray
<
OwnedAnonBox
>
&
aResult
)
{
MOZ_ASSERT
(
mFrames
.
FirstChild
(
)
"
Must
have
our
button
-
content
anon
box
"
)
;
MOZ_ASSERT
(
!
mFrames
.
FirstChild
(
)
-
>
GetNextSibling
(
)
"
Must
only
have
our
button
-
content
anon
box
"
)
;
aResult
.
AppendElement
(
OwnedAnonBox
(
mFrames
.
FirstChild
(
)
)
)
;
}
#
ifdef
DEBUG
void
nsHTMLButtonControlFrame
:
:
AppendFrames
(
ChildListID
aListID
nsFrameList
&
aFrameList
)
{
MOZ_CRASH
(
"
unsupported
operation
"
)
;
}
void
nsHTMLButtonControlFrame
:
:
InsertFrames
(
ChildListID
aListID
nsIFrame
*
aPrevFrame
nsFrameList
&
aFrameList
)
{
MOZ_CRASH
(
"
unsupported
operation
"
)
;
}
void
nsHTMLButtonControlFrame
:
:
RemoveFrame
(
ChildListID
aListID
nsIFrame
*
aOldFrame
)
{
MOZ_CRASH
(
"
unsupported
operation
"
)
;
}
#
endif
