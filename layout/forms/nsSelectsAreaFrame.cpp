#
include
"
nsSelectsAreaFrame
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsListControlFrame
.
h
"
#
include
"
nsDisplayList
.
h
"
#
include
"
WritingModes
.
h
"
using
namespace
mozilla
;
nsContainerFrame
*
NS_NewSelectsAreaFrame
(
PresShell
*
aShell
ComputedStyle
*
aStyle
nsFrameState
aFlags
)
{
nsSelectsAreaFrame
*
it
=
new
(
aShell
)
nsSelectsAreaFrame
(
aStyle
aShell
-
>
GetPresContext
(
)
)
;
it
-
>
AddStateBits
(
aFlags
|
NS_BLOCK_FLOAT_MGR
)
;
return
it
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsSelectsAreaFrame
)
class
nsDisplayOptionEventGrabber
:
public
nsDisplayWrapList
{
public
:
nsDisplayOptionEventGrabber
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayItem
*
aItem
)
:
nsDisplayWrapList
(
aBuilder
aFrame
aItem
)
{
}
nsDisplayOptionEventGrabber
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
)
:
nsDisplayWrapList
(
aBuilder
aFrame
aList
)
{
}
virtual
void
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
override
;
virtual
bool
ShouldFlattenAway
(
nsDisplayListBuilder
*
aBuilder
)
override
{
return
false
;
}
NS_DISPLAY_DECL_NAME
(
"
OptionEventGrabber
"
TYPE_OPTION_EVENT_GRABBER
)
}
;
void
nsDisplayOptionEventGrabber
:
:
HitTest
(
nsDisplayListBuilder
*
aBuilder
const
nsRect
&
aRect
HitTestState
*
aState
nsTArray
<
nsIFrame
*
>
*
aOutFrames
)
{
nsTArray
<
nsIFrame
*
>
outFrames
;
mList
.
HitTest
(
aBuilder
aRect
aState
&
outFrames
)
;
for
(
uint32_t
i
=
0
;
i
<
outFrames
.
Length
(
)
;
i
+
+
)
{
nsIFrame
*
selectedFrame
=
outFrames
.
ElementAt
(
i
)
;
while
(
selectedFrame
&
&
!
(
selectedFrame
-
>
GetContent
(
)
&
&
selectedFrame
-
>
GetContent
(
)
-
>
IsHTMLElement
(
nsGkAtoms
:
:
option
)
)
)
{
selectedFrame
=
selectedFrame
-
>
GetParent
(
)
;
}
if
(
selectedFrame
)
{
aOutFrames
-
>
AppendElement
(
selectedFrame
)
;
}
else
{
aOutFrames
-
>
AppendElement
(
outFrames
.
ElementAt
(
i
)
)
;
}
}
}
class
nsOptionEventGrabberWrapper
:
public
nsDisplayWrapper
{
public
:
nsOptionEventGrabberWrapper
(
)
{
}
virtual
nsDisplayItem
*
WrapList
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
nsDisplayList
*
aList
)
override
{
return
MakeDisplayItem
<
nsDisplayOptionEventGrabber
>
(
aBuilder
aFrame
aList
)
;
}
virtual
nsDisplayItem
*
WrapItem
(
nsDisplayListBuilder
*
aBuilder
nsDisplayItem
*
aItem
)
override
{
return
MakeDisplayItem
<
nsDisplayOptionEventGrabber
>
(
aBuilder
aItem
-
>
Frame
(
)
aItem
)
;
}
}
;
static
nsListControlFrame
*
GetEnclosingListFrame
(
nsIFrame
*
aSelectsAreaFrame
)
{
nsIFrame
*
frame
=
aSelectsAreaFrame
-
>
GetParent
(
)
;
while
(
frame
)
{
if
(
frame
-
>
IsListControlFrame
(
)
)
return
static_cast
<
nsListControlFrame
*
>
(
frame
)
;
frame
=
frame
-
>
GetParent
(
)
;
}
return
nullptr
;
}
class
nsDisplayListFocus
:
public
nsDisplayItem
{
public
:
nsDisplayListFocus
(
nsDisplayListBuilder
*
aBuilder
nsSelectsAreaFrame
*
aFrame
)
:
nsDisplayItem
(
aBuilder
aFrame
)
{
MOZ_COUNT_CTOR
(
nsDisplayListFocus
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayListFocus
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayListFocus
)
;
}
#
endif
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
{
*
aSnap
=
false
;
nsListControlFrame
*
listFrame
=
GetEnclosingListFrame
(
Frame
(
)
)
;
return
listFrame
-
>
GetVisualOverflowRectRelativeToSelf
(
)
+
listFrame
-
>
GetOffsetToCrossDoc
(
ReferenceFrame
(
)
)
;
}
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
{
nsListControlFrame
*
listFrame
=
GetEnclosingListFrame
(
Frame
(
)
)
;
listFrame
-
>
PaintFocus
(
aCtx
-
>
GetDrawTarget
(
)
aBuilder
-
>
ToReferenceFrame
(
listFrame
)
)
;
}
NS_DISPLAY_DECL_NAME
(
"
ListFocus
"
TYPE_LIST_FOCUS
)
}
;
void
nsSelectsAreaFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
if
(
!
aBuilder
-
>
IsForEventDelivery
(
)
)
{
BuildDisplayListInternal
(
aBuilder
aLists
)
;
return
;
}
nsDisplayListCollection
set
(
aBuilder
)
;
BuildDisplayListInternal
(
aBuilder
set
)
;
nsOptionEventGrabberWrapper
wrapper
;
wrapper
.
WrapLists
(
aBuilder
this
set
aLists
)
;
}
void
nsSelectsAreaFrame
:
:
BuildDisplayListInternal
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
nsBlockFrame
:
:
BuildDisplayList
(
aBuilder
aLists
)
;
nsListControlFrame
*
listFrame
=
GetEnclosingListFrame
(
this
)
;
if
(
listFrame
&
&
listFrame
-
>
IsFocused
(
)
)
{
aLists
.
Outlines
(
)
-
>
AppendNewToTop
<
nsDisplayListFocus
>
(
aBuilder
this
)
;
}
}
void
nsSelectsAreaFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
nsListControlFrame
*
list
=
GetEnclosingListFrame
(
this
)
;
NS_ASSERTION
(
list
"
Must
have
an
nsListControlFrame
!
Frame
constructor
is
"
"
broken
"
)
;
bool
isInDropdownMode
=
list
-
>
IsInDropDownMode
(
)
;
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
nscoord
oldBSize
;
if
(
isInDropdownMode
)
{
if
(
!
(
GetStateBits
(
)
&
NS_FRAME_FIRST_REFLOW
)
)
{
oldBSize
=
BSize
(
wm
)
;
}
else
{
oldBSize
=
NS_UNCONSTRAINEDSIZE
;
}
}
nsBlockFrame
:
:
Reflow
(
aPresContext
aDesiredSize
aReflowInput
aStatus
)
;
if
(
list
-
>
MightNeedSecondPass
(
)
)
{
nscoord
newBSizeOfARow
=
list
-
>
CalcBSizeOfARow
(
)
;
if
(
newBSizeOfARow
!
=
mBSizeOfARow
|
|
(
isInDropdownMode
&
&
(
oldBSize
!
=
aDesiredSize
.
BSize
(
wm
)
|
|
oldBSize
!
=
BSize
(
wm
)
)
)
)
{
mBSizeOfARow
=
newBSizeOfARow
;
list
-
>
SetSuppressScrollbarUpdate
(
true
)
;
}
}
}
