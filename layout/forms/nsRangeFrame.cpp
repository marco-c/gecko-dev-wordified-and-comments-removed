#
include
"
nsRangeFrame
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
mozilla
/
TouchEvents
.
h
"
#
include
"
gfxContext
.
h
"
#
include
"
nsContentCreatorFunctions
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsCSSRendering
.
h
"
#
include
"
nsCheckboxRadioFrame
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
mozilla
/
dom
/
Document
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
mozilla
/
dom
/
HTMLInputElement
.
h
"
#
include
"
nsPresContext
.
h
"
#
include
"
nsNodeInfoManager
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
mozilla
/
ServoStyleSet
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
ifdef
ACCESSIBILITY
#
include
"
nsAccessibilityService
.
h
"
#
endif
#
define
MAIN_AXIS_EM_SIZE
12
#
define
CROSS_AXIS_EM_SIZE
1
.
3f
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
using
namespace
mozilla
:
:
image
;
NS_IMPL_ISUPPORTS
(
nsRangeFrame
:
:
DummyTouchListener
nsIDOMEventListener
)
nsIFrame
*
NS_NewRangeFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsRangeFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
nsRangeFrame
:
:
nsRangeFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
:
nsContainerFrame
(
aStyle
aPresContext
kClassID
)
{
}
nsRangeFrame
:
:
~
nsRangeFrame
(
)
{
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsRangeFrame
)
NS_QUERYFRAME_HEAD
(
nsRangeFrame
)
NS_QUERYFRAME_ENTRY
(
nsRangeFrame
)
NS_QUERYFRAME_ENTRY
(
nsIAnonymousContentCreator
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsContainerFrame
)
void
nsRangeFrame
:
:
Init
(
nsIContent
*
aContent
nsContainerFrame
*
aParent
nsIFrame
*
aPrevInFlow
)
{
if
(
!
mDummyTouchListener
)
{
mDummyTouchListener
=
new
DummyTouchListener
(
)
;
}
aContent
-
>
AddEventListener
(
NS_LITERAL_STRING
(
"
touchstart
"
)
mDummyTouchListener
false
)
;
ServoStyleSet
*
styleSet
=
PresContext
(
)
-
>
StyleSet
(
)
;
mOuterFocusStyle
=
styleSet
-
>
ProbePseudoElementStyle
(
*
aContent
-
>
AsElement
(
)
PseudoStyleType
:
:
mozFocusOuter
Style
(
)
)
;
return
nsContainerFrame
:
:
Init
(
aContent
aParent
aPrevInFlow
)
;
}
void
nsRangeFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
{
NS_ASSERTION
(
!
GetPrevContinuation
(
)
&
&
!
GetNextContinuation
(
)
"
nsRangeFrame
should
not
have
continuations
;
if
it
does
we
"
"
need
to
call
RegUnregAccessKey
only
for
the
first
.
"
)
;
mContent
-
>
RemoveEventListener
(
NS_LITERAL_STRING
(
"
touchstart
"
)
mDummyTouchListener
false
)
;
nsCheckboxRadioFrame
:
:
RegUnRegAccessKey
(
static_cast
<
nsIFrame
*
>
(
this
)
false
)
;
aPostDestroyData
.
AddAnonymousContent
(
mTrackDiv
.
forget
(
)
)
;
aPostDestroyData
.
AddAnonymousContent
(
mProgressDiv
.
forget
(
)
)
;
aPostDestroyData
.
AddAnonymousContent
(
mThumbDiv
.
forget
(
)
)
;
nsContainerFrame
:
:
DestroyFrom
(
aDestructRoot
aPostDestroyData
)
;
}
nsresult
nsRangeFrame
:
:
MakeAnonymousDiv
(
Element
*
*
aResult
PseudoStyleType
aPseudoType
nsTArray
<
ContentInfo
>
&
aElements
)
{
nsCOMPtr
<
Document
>
doc
=
mContent
-
>
GetComposedDoc
(
)
;
RefPtr
<
Element
>
resultElement
=
doc
-
>
CreateHTMLElement
(
nsGkAtoms
:
:
div
)
;
resultElement
-
>
SetPseudoElementType
(
aPseudoType
)
;
if
(
!
aElements
.
AppendElement
(
resultElement
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
resultElement
.
forget
(
aResult
)
;
return
NS_OK
;
}
nsresult
nsRangeFrame
:
:
CreateAnonymousContent
(
nsTArray
<
ContentInfo
>
&
aElements
)
{
nsresult
rv
;
rv
=
MakeAnonymousDiv
(
getter_AddRefs
(
mTrackDiv
)
PseudoStyleType
:
:
mozRangeTrack
aElements
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
MakeAnonymousDiv
(
getter_AddRefs
(
mProgressDiv
)
PseudoStyleType
:
:
mozRangeProgress
aElements
)
;
NS_ENSURE_SUCCESS
(
rv
rv
)
;
rv
=
MakeAnonymousDiv
(
getter_AddRefs
(
mThumbDiv
)
PseudoStyleType
:
:
mozRangeThumb
aElements
)
;
return
rv
;
}
void
nsRangeFrame
:
:
AppendAnonymousContentTo
(
nsTArray
<
nsIContent
*
>
&
aElements
uint32_t
aFilter
)
{
if
(
mTrackDiv
)
{
aElements
.
AppendElement
(
mTrackDiv
)
;
}
if
(
mProgressDiv
)
{
aElements
.
AppendElement
(
mProgressDiv
)
;
}
if
(
mThumbDiv
)
{
aElements
.
AppendElement
(
mThumbDiv
)
;
}
}
class
nsDisplayRangeFocusRing
final
:
public
nsDisplayItem
{
public
:
nsDisplayRangeFocusRing
(
nsDisplayListBuilder
*
aBuilder
nsIFrame
*
aFrame
)
:
nsDisplayItem
(
aBuilder
aFrame
)
{
MOZ_COUNT_CTOR
(
nsDisplayRangeFocusRing
)
;
}
#
ifdef
NS_BUILD_REFCNT_LOGGING
virtual
~
nsDisplayRangeFocusRing
(
)
{
MOZ_COUNT_DTOR
(
nsDisplayRangeFocusRing
)
;
}
#
endif
nsDisplayItemGeometry
*
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
override
;
void
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
override
;
virtual
nsRect
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
override
;
virtual
void
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
override
;
NS_DISPLAY_DECL_NAME
(
"
RangeFocusRing
"
TYPE_RANGE_FOCUS_RING
)
}
;
nsDisplayItemGeometry
*
nsDisplayRangeFocusRing
:
:
AllocateGeometry
(
nsDisplayListBuilder
*
aBuilder
)
{
return
new
nsDisplayItemGenericImageGeometry
(
this
aBuilder
)
;
}
void
nsDisplayRangeFocusRing
:
:
ComputeInvalidationRegion
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayItemGeometry
*
aGeometry
nsRegion
*
aInvalidRegion
)
const
{
auto
geometry
=
static_cast
<
const
nsDisplayItemGenericImageGeometry
*
>
(
aGeometry
)
;
if
(
aBuilder
-
>
ShouldSyncDecodeImages
(
)
&
&
geometry
-
>
ShouldInvalidateToSyncDecodeImages
(
)
)
{
bool
snap
;
aInvalidRegion
-
>
Or
(
*
aInvalidRegion
GetBounds
(
aBuilder
&
snap
)
)
;
}
nsDisplayItem
:
:
ComputeInvalidationRegion
(
aBuilder
aGeometry
aInvalidRegion
)
;
}
nsRect
nsDisplayRangeFocusRing
:
:
GetBounds
(
nsDisplayListBuilder
*
aBuilder
bool
*
aSnap
)
const
{
*
aSnap
=
false
;
nsRect
rect
(
ToReferenceFrame
(
)
Frame
(
)
-
>
GetSize
(
)
)
;
ComputedStyle
*
computedStyle
=
static_cast
<
nsRangeFrame
*
>
(
mFrame
)
-
>
mOuterFocusStyle
;
MOZ_ASSERT
(
computedStyle
"
We
only
exist
if
mOuterFocusStyle
is
non
-
null
"
)
;
rect
.
Inflate
(
computedStyle
-
>
StyleBorder
(
)
-
>
GetComputedBorder
(
)
)
;
return
rect
;
}
void
nsDisplayRangeFocusRing
:
:
Paint
(
nsDisplayListBuilder
*
aBuilder
gfxContext
*
aCtx
)
{
bool
unused
;
ComputedStyle
*
computedStyle
=
static_cast
<
nsRangeFrame
*
>
(
mFrame
)
-
>
mOuterFocusStyle
;
MOZ_ASSERT
(
computedStyle
"
We
only
exist
if
mOuterFocusStyle
is
non
-
null
"
)
;
PaintBorderFlags
flags
=
aBuilder
-
>
ShouldSyncDecodeImages
(
)
?
PaintBorderFlags
:
:
SYNC_DECODE_IMAGES
:
PaintBorderFlags
(
)
;
ImgDrawResult
result
=
nsCSSRendering
:
:
PaintBorder
(
mFrame
-
>
PresContext
(
)
*
aCtx
mFrame
GetPaintRect
(
)
GetBounds
(
aBuilder
&
unused
)
computedStyle
flags
)
;
nsDisplayItemGenericImageGeometry
:
:
UpdateDrawResult
(
this
result
)
;
}
void
nsRangeFrame
:
:
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
{
const
nsStyleDisplay
*
disp
=
StyleDisplay
(
)
;
if
(
IsThemed
(
disp
)
)
{
DisplayBorderBackgroundOutline
(
aBuilder
aLists
)
;
nsIFrame
*
thumb
=
mThumbDiv
-
>
GetPrimaryFrame
(
)
;
if
(
thumb
)
{
nsDisplayListSet
set
(
aLists
aLists
.
Content
(
)
)
;
BuildDisplayListForChild
(
aBuilder
thumb
set
DISPLAY_CHILD_INLINE
)
;
}
}
else
{
BuildDisplayListForInline
(
aBuilder
aLists
)
;
}
if
(
!
aBuilder
-
>
IsForPainting
(
)
|
|
!
IsVisibleForPainting
(
)
)
{
return
;
}
EventStates
eventStates
=
mContent
-
>
AsElement
(
)
-
>
State
(
)
;
if
(
eventStates
.
HasState
(
NS_EVENT_STATE_DISABLED
)
|
|
!
eventStates
.
HasState
(
NS_EVENT_STATE_FOCUSRING
)
)
{
return
;
}
if
(
!
mOuterFocusStyle
|
|
!
mOuterFocusStyle
-
>
StyleBorder
(
)
-
>
HasBorder
(
)
)
{
return
;
}
if
(
IsThemed
(
disp
)
&
&
PresContext
(
)
-
>
GetTheme
(
)
-
>
ThemeDrawsFocusForWidget
(
disp
-
>
mAppearance
)
)
{
return
;
}
aLists
.
Content
(
)
-
>
AppendToTop
(
MakeDisplayItem
<
nsDisplayRangeFocusRing
>
(
aBuilder
this
)
)
;
}
void
nsRangeFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsRangeFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aDesiredSize
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
NS_ASSERTION
(
mTrackDiv
"
:
:
-
moz
-
range
-
track
div
must
exist
!
"
)
;
NS_ASSERTION
(
mProgressDiv
"
:
:
-
moz
-
range
-
progress
div
must
exist
!
"
)
;
NS_ASSERTION
(
mThumbDiv
"
:
:
-
moz
-
range
-
thumb
div
must
exist
!
"
)
;
NS_ASSERTION
(
!
GetPrevContinuation
(
)
&
&
!
GetNextContinuation
(
)
"
nsRangeFrame
should
not
have
continuations
;
if
it
does
we
"
"
need
to
call
RegUnregAccessKey
only
for
the
first
.
"
)
;
if
(
mState
&
NS_FRAME_FIRST_REFLOW
)
{
nsCheckboxRadioFrame
:
:
RegUnRegAccessKey
(
this
true
)
;
}
WritingMode
wm
=
aReflowInput
.
GetWritingMode
(
)
;
nscoord
computedBSize
=
aReflowInput
.
ComputedBSize
(
)
;
if
(
computedBSize
=
=
NS_AUTOHEIGHT
)
{
computedBSize
=
0
;
}
LogicalSize
finalSize
(
wm
aReflowInput
.
ComputedISize
(
)
+
aReflowInput
.
ComputedLogicalBorderPadding
(
)
.
IStartEnd
(
wm
)
computedBSize
+
aReflowInput
.
ComputedLogicalBorderPadding
(
)
.
BStartEnd
(
wm
)
)
;
aDesiredSize
.
SetSize
(
wm
finalSize
)
;
ReflowAnonymousContent
(
aPresContext
aDesiredSize
aReflowInput
)
;
aDesiredSize
.
SetOverflowAreasToDesiredBounds
(
)
;
nsIFrame
*
trackFrame
=
mTrackDiv
-
>
GetPrimaryFrame
(
)
;
if
(
trackFrame
)
{
ConsiderChildOverflow
(
aDesiredSize
.
mOverflowAreas
trackFrame
)
;
}
nsIFrame
*
rangeProgressFrame
=
mProgressDiv
-
>
GetPrimaryFrame
(
)
;
if
(
rangeProgressFrame
)
{
ConsiderChildOverflow
(
aDesiredSize
.
mOverflowAreas
rangeProgressFrame
)
;
}
nsIFrame
*
thumbFrame
=
mThumbDiv
-
>
GetPrimaryFrame
(
)
;
if
(
thumbFrame
)
{
ConsiderChildOverflow
(
aDesiredSize
.
mOverflowAreas
thumbFrame
)
;
}
FinishAndStoreOverflow
(
&
aDesiredSize
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
This
type
of
frame
can
'
t
be
split
.
"
)
;
NS_FRAME_SET_TRUNCATION
(
aStatus
aReflowInput
aDesiredSize
)
;
}
void
nsRangeFrame
:
:
ReflowAnonymousContent
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
)
{
nscoord
rangeFrameContentBoxWidth
=
aReflowInput
.
ComputedWidth
(
)
;
nscoord
rangeFrameContentBoxHeight
=
aReflowInput
.
ComputedHeight
(
)
;
if
(
rangeFrameContentBoxHeight
=
=
NS_AUTOHEIGHT
)
{
rangeFrameContentBoxHeight
=
0
;
}
nsIFrame
*
trackFrame
=
mTrackDiv
-
>
GetPrimaryFrame
(
)
;
if
(
trackFrame
)
{
WritingMode
wm
=
trackFrame
-
>
GetWritingMode
(
)
;
LogicalSize
availSize
=
aReflowInput
.
ComputedSize
(
wm
)
;
availSize
.
BSize
(
wm
)
=
NS_UNCONSTRAINEDSIZE
;
ReflowInput
trackReflowInput
(
aPresContext
aReflowInput
trackFrame
availSize
)
;
nscoord
trackX
=
rangeFrameContentBoxWidth
/
2
;
nscoord
trackY
=
rangeFrameContentBoxHeight
/
2
;
trackX
-
=
trackReflowInput
.
ComputedPhysicalBorderPadding
(
)
.
left
+
trackReflowInput
.
ComputedWidth
(
)
/
2
;
trackY
-
=
trackReflowInput
.
ComputedPhysicalBorderPadding
(
)
.
top
+
trackReflowInput
.
ComputedHeight
(
)
/
2
;
trackX
+
=
aReflowInput
.
ComputedPhysicalBorderPadding
(
)
.
left
;
trackY
+
=
aReflowInput
.
ComputedPhysicalBorderPadding
(
)
.
top
;
nsReflowStatus
frameStatus
;
ReflowOutput
trackDesiredSize
(
aReflowInput
)
;
ReflowChild
(
trackFrame
aPresContext
trackDesiredSize
trackReflowInput
trackX
trackY
0
frameStatus
)
;
MOZ_ASSERT
(
frameStatus
.
IsFullyComplete
(
)
"
We
gave
our
child
unconstrained
height
so
it
should
be
complete
"
)
;
FinishReflowChild
(
trackFrame
aPresContext
trackDesiredSize
&
trackReflowInput
trackX
trackY
0
)
;
}
nsIFrame
*
thumbFrame
=
mThumbDiv
-
>
GetPrimaryFrame
(
)
;
if
(
thumbFrame
)
{
WritingMode
wm
=
thumbFrame
-
>
GetWritingMode
(
)
;
LogicalSize
availSize
=
aReflowInput
.
ComputedSize
(
wm
)
;
availSize
.
BSize
(
wm
)
=
NS_UNCONSTRAINEDSIZE
;
ReflowInput
thumbReflowInput
(
aPresContext
aReflowInput
thumbFrame
availSize
)
;
nsReflowStatus
frameStatus
;
ReflowOutput
thumbDesiredSize
(
aReflowInput
)
;
ReflowChild
(
thumbFrame
aPresContext
thumbDesiredSize
thumbReflowInput
0
0
0
frameStatus
)
;
MOZ_ASSERT
(
frameStatus
.
IsFullyComplete
(
)
"
We
gave
our
child
unconstrained
height
so
it
should
be
complete
"
)
;
FinishReflowChild
(
thumbFrame
aPresContext
thumbDesiredSize
&
thumbReflowInput
0
0
0
)
;
DoUpdateThumbPosition
(
thumbFrame
nsSize
(
aDesiredSize
.
Width
(
)
aDesiredSize
.
Height
(
)
)
)
;
}
nsIFrame
*
rangeProgressFrame
=
mProgressDiv
-
>
GetPrimaryFrame
(
)
;
if
(
rangeProgressFrame
)
{
WritingMode
wm
=
rangeProgressFrame
-
>
GetWritingMode
(
)
;
LogicalSize
availSize
=
aReflowInput
.
ComputedSize
(
wm
)
;
availSize
.
BSize
(
wm
)
=
NS_UNCONSTRAINEDSIZE
;
ReflowInput
progressReflowInput
(
aPresContext
aReflowInput
rangeProgressFrame
availSize
)
;
nsReflowStatus
frameStatus
;
ReflowOutput
progressDesiredSize
(
aReflowInput
)
;
ReflowChild
(
rangeProgressFrame
aPresContext
progressDesiredSize
progressReflowInput
0
0
0
frameStatus
)
;
MOZ_ASSERT
(
frameStatus
.
IsFullyComplete
(
)
"
We
gave
our
child
unconstrained
height
so
it
should
be
complete
"
)
;
FinishReflowChild
(
rangeProgressFrame
aPresContext
progressDesiredSize
&
progressReflowInput
0
0
0
)
;
DoUpdateRangeProgressFrame
(
rangeProgressFrame
nsSize
(
aDesiredSize
.
Width
(
)
aDesiredSize
.
Height
(
)
)
)
;
}
}
#
ifdef
ACCESSIBILITY
a11y
:
:
AccType
nsRangeFrame
:
:
AccessibleType
(
)
{
return
a11y
:
:
eHTMLRangeType
;
}
#
endif
double
nsRangeFrame
:
:
GetValueAsFractionOfRange
(
)
{
MOZ_ASSERT
(
mContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
input
)
"
bad
cast
"
)
;
dom
:
:
HTMLInputElement
*
input
=
static_cast
<
dom
:
:
HTMLInputElement
*
>
(
GetContent
(
)
)
;
MOZ_ASSERT
(
input
-
>
ControlType
(
)
=
=
NS_FORM_INPUT_RANGE
)
;
Decimal
value
=
input
-
>
GetValueAsDecimal
(
)
;
Decimal
minimum
=
input
-
>
GetMinimum
(
)
;
Decimal
maximum
=
input
-
>
GetMaximum
(
)
;
MOZ_ASSERT
(
value
.
isFinite
(
)
&
&
minimum
.
isFinite
(
)
&
&
maximum
.
isFinite
(
)
"
type
=
range
should
have
a
default
maximum
/
minimum
"
)
;
if
(
maximum
<
=
minimum
)
{
MOZ_ASSERT
(
(
value
-
minimum
)
.
abs
(
)
.
toDouble
(
)
<
std
:
:
numeric_limits
<
float
>
:
:
epsilon
(
)
"
Unsanitized
value
"
)
;
return
0
.
0
;
}
MOZ_ASSERT
(
value
>
=
minimum
&
&
value
<
=
maximum
"
Unsanitized
value
"
)
;
return
(
(
value
-
minimum
)
/
(
maximum
-
minimum
)
)
.
toDouble
(
)
;
}
Decimal
nsRangeFrame
:
:
GetValueAtEventPoint
(
WidgetGUIEvent
*
aEvent
)
{
MOZ_ASSERT
(
aEvent
-
>
mClass
=
=
eMouseEventClass
|
|
aEvent
-
>
mClass
=
=
eTouchEventClass
"
Unexpected
event
type
-
aEvent
-
>
mRefPoint
may
be
meaningless
"
)
;
MOZ_ASSERT
(
mContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
input
)
"
bad
cast
"
)
;
dom
:
:
HTMLInputElement
*
input
=
static_cast
<
dom
:
:
HTMLInputElement
*
>
(
GetContent
(
)
)
;
MOZ_ASSERT
(
input
-
>
ControlType
(
)
=
=
NS_FORM_INPUT_RANGE
)
;
Decimal
minimum
=
input
-
>
GetMinimum
(
)
;
Decimal
maximum
=
input
-
>
GetMaximum
(
)
;
MOZ_ASSERT
(
minimum
.
isFinite
(
)
&
&
maximum
.
isFinite
(
)
"
type
=
range
should
have
a
default
maximum
/
minimum
"
)
;
if
(
maximum
<
=
minimum
)
{
return
minimum
;
}
Decimal
range
=
maximum
-
minimum
;
LayoutDeviceIntPoint
absPoint
;
if
(
aEvent
-
>
mClass
=
=
eTouchEventClass
)
{
MOZ_ASSERT
(
aEvent
-
>
AsTouchEvent
(
)
-
>
mTouches
.
Length
(
)
=
=
1
"
Unexpected
number
of
mTouches
"
)
;
absPoint
=
aEvent
-
>
AsTouchEvent
(
)
-
>
mTouches
[
0
]
-
>
mRefPoint
;
}
else
{
absPoint
=
aEvent
-
>
mRefPoint
;
}
nsPoint
point
=
nsLayoutUtils
:
:
GetEventCoordinatesRelativeTo
(
aEvent
absPoint
this
)
;
if
(
point
=
=
nsPoint
(
NS_UNCONSTRAINEDSIZE
NS_UNCONSTRAINEDSIZE
)
)
{
return
static_cast
<
dom
:
:
HTMLInputElement
*
>
(
GetContent
(
)
)
-
>
GetValueAsDecimal
(
)
;
}
nsRect
rangeContentRect
=
GetContentRectRelativeToSelf
(
)
;
nsSize
thumbSize
;
if
(
IsThemed
(
)
)
{
nsPresContext
*
presContext
=
PresContext
(
)
;
bool
notUsedCanOverride
;
LayoutDeviceIntSize
size
;
presContext
-
>
GetTheme
(
)
-
>
GetMinimumWidgetSize
(
presContext
this
StyleAppearance
:
:
RangeThumb
&
size
&
notUsedCanOverride
)
;
thumbSize
.
width
=
presContext
-
>
DevPixelsToAppUnits
(
size
.
width
)
;
thumbSize
.
height
=
presContext
-
>
DevPixelsToAppUnits
(
size
.
height
)
;
MOZ_ASSERT
(
(
IsHorizontal
(
)
&
&
thumbSize
.
width
>
0
)
|
|
(
!
IsHorizontal
(
)
&
&
thumbSize
.
height
>
0
)
"
The
thumb
is
expected
to
take
up
some
slider
space
"
)
;
}
else
{
nsIFrame
*
thumbFrame
=
mThumbDiv
-
>
GetPrimaryFrame
(
)
;
if
(
thumbFrame
)
{
thumbSize
=
thumbFrame
-
>
GetSize
(
)
;
}
}
Decimal
fraction
;
if
(
IsHorizontal
(
)
)
{
nscoord
traversableDistance
=
rangeContentRect
.
width
-
thumbSize
.
width
;
if
(
traversableDistance
<
=
0
)
{
return
minimum
;
}
nscoord
posAtStart
=
rangeContentRect
.
x
+
thumbSize
.
width
/
2
;
nscoord
posAtEnd
=
posAtStart
+
traversableDistance
;
nscoord
posOfPoint
=
mozilla
:
:
clamped
(
point
.
x
posAtStart
posAtEnd
)
;
fraction
=
Decimal
(
posOfPoint
-
posAtStart
)
/
Decimal
(
traversableDistance
)
;
if
(
IsRightToLeft
(
)
)
{
fraction
=
Decimal
(
1
)
-
fraction
;
}
}
else
{
nscoord
traversableDistance
=
rangeContentRect
.
height
-
thumbSize
.
height
;
if
(
traversableDistance
<
=
0
)
{
return
minimum
;
}
nscoord
posAtStart
=
rangeContentRect
.
y
+
thumbSize
.
height
/
2
;
nscoord
posAtEnd
=
posAtStart
+
traversableDistance
;
nscoord
posOfPoint
=
mozilla
:
:
clamped
(
point
.
y
posAtStart
posAtEnd
)
;
fraction
=
Decimal
(
1
)
-
Decimal
(
posOfPoint
-
posAtStart
)
/
Decimal
(
traversableDistance
)
;
}
MOZ_ASSERT
(
fraction
>
=
Decimal
(
0
)
&
&
fraction
<
=
Decimal
(
1
)
)
;
return
minimum
+
fraction
*
range
;
}
void
nsRangeFrame
:
:
UpdateForValueChange
(
)
{
if
(
NS_SUBTREE_DIRTY
(
this
)
)
{
return
;
}
nsIFrame
*
rangeProgressFrame
=
mProgressDiv
-
>
GetPrimaryFrame
(
)
;
nsIFrame
*
thumbFrame
=
mThumbDiv
-
>
GetPrimaryFrame
(
)
;
if
(
!
rangeProgressFrame
&
&
!
thumbFrame
)
{
return
;
}
if
(
rangeProgressFrame
)
{
DoUpdateRangeProgressFrame
(
rangeProgressFrame
GetSize
(
)
)
;
}
if
(
thumbFrame
)
{
DoUpdateThumbPosition
(
thumbFrame
GetSize
(
)
)
;
}
if
(
IsThemed
(
)
)
{
InvalidateFrame
(
)
;
}
#
ifdef
ACCESSIBILITY
nsAccessibilityService
*
accService
=
nsIPresShell
:
:
AccService
(
)
;
if
(
accService
)
{
accService
-
>
RangeValueChanged
(
PresShell
(
)
mContent
)
;
}
#
endif
SchedulePaint
(
)
;
}
void
nsRangeFrame
:
:
DoUpdateThumbPosition
(
nsIFrame
*
aThumbFrame
const
nsSize
&
aRangeSize
)
{
MOZ_ASSERT
(
aThumbFrame
)
;
nsMargin
borderAndPadding
=
GetUsedBorderAndPadding
(
)
;
nsPoint
newPosition
(
borderAndPadding
.
left
borderAndPadding
.
top
)
;
nsSize
rangeContentBoxSize
(
aRangeSize
)
;
rangeContentBoxSize
.
width
-
=
borderAndPadding
.
LeftRight
(
)
;
rangeContentBoxSize
.
height
-
=
borderAndPadding
.
TopBottom
(
)
;
nsSize
thumbSize
=
aThumbFrame
-
>
GetSize
(
)
;
double
fraction
=
GetValueAsFractionOfRange
(
)
;
MOZ_ASSERT
(
fraction
>
=
0
.
0
&
&
fraction
<
=
1
.
0
)
;
if
(
IsHorizontal
(
)
)
{
if
(
thumbSize
.
width
<
rangeContentBoxSize
.
width
)
{
nscoord
traversableDistance
=
rangeContentBoxSize
.
width
-
thumbSize
.
width
;
if
(
IsRightToLeft
(
)
)
{
newPosition
.
x
+
=
NSToCoordRound
(
(
1
.
0
-
fraction
)
*
traversableDistance
)
;
}
else
{
newPosition
.
x
+
=
NSToCoordRound
(
fraction
*
traversableDistance
)
;
}
newPosition
.
y
+
=
(
rangeContentBoxSize
.
height
-
thumbSize
.
height
)
/
2
;
}
}
else
{
if
(
thumbSize
.
height
<
rangeContentBoxSize
.
height
)
{
nscoord
traversableDistance
=
rangeContentBoxSize
.
height
-
thumbSize
.
height
;
newPosition
.
x
+
=
(
rangeContentBoxSize
.
width
-
thumbSize
.
width
)
/
2
;
newPosition
.
y
+
=
NSToCoordRound
(
(
1
.
0
-
fraction
)
*
traversableDistance
)
;
}
}
aThumbFrame
-
>
SetPosition
(
newPosition
)
;
}
void
nsRangeFrame
:
:
DoUpdateRangeProgressFrame
(
nsIFrame
*
aRangeProgressFrame
const
nsSize
&
aRangeSize
)
{
MOZ_ASSERT
(
aRangeProgressFrame
)
;
nsMargin
borderAndPadding
=
GetUsedBorderAndPadding
(
)
;
nsSize
progSize
=
aRangeProgressFrame
-
>
GetSize
(
)
;
nsRect
progRect
(
borderAndPadding
.
left
borderAndPadding
.
top
progSize
.
width
progSize
.
height
)
;
nsSize
rangeContentBoxSize
(
aRangeSize
)
;
rangeContentBoxSize
.
width
-
=
borderAndPadding
.
LeftRight
(
)
;
rangeContentBoxSize
.
height
-
=
borderAndPadding
.
TopBottom
(
)
;
double
fraction
=
GetValueAsFractionOfRange
(
)
;
MOZ_ASSERT
(
fraction
>
=
0
.
0
&
&
fraction
<
=
1
.
0
)
;
if
(
IsHorizontal
(
)
)
{
nscoord
progLength
=
NSToCoordRound
(
fraction
*
rangeContentBoxSize
.
width
)
;
if
(
IsRightToLeft
(
)
)
{
progRect
.
x
+
=
rangeContentBoxSize
.
width
-
progLength
;
}
progRect
.
y
+
=
(
rangeContentBoxSize
.
height
-
progSize
.
height
)
/
2
;
progRect
.
width
=
progLength
;
}
else
{
nscoord
progLength
=
NSToCoordRound
(
fraction
*
rangeContentBoxSize
.
height
)
;
progRect
.
x
+
=
(
rangeContentBoxSize
.
width
-
progSize
.
width
)
/
2
;
progRect
.
y
+
=
rangeContentBoxSize
.
height
-
progLength
;
progRect
.
height
=
progLength
;
}
aRangeProgressFrame
-
>
SetRect
(
progRect
)
;
}
nsresult
nsRangeFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
NS_ASSERTION
(
mTrackDiv
"
The
track
div
must
exist
!
"
)
;
NS_ASSERTION
(
mThumbDiv
"
The
thumb
div
must
exist
!
"
)
;
if
(
aNameSpaceID
=
=
kNameSpaceID_None
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
value
|
|
aAttribute
=
=
nsGkAtoms
:
:
min
|
|
aAttribute
=
=
nsGkAtoms
:
:
max
|
|
aAttribute
=
=
nsGkAtoms
:
:
step
)
{
MOZ_ASSERT
(
mContent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
input
)
"
bad
cast
"
)
;
bool
typeIsRange
=
static_cast
<
dom
:
:
HTMLInputElement
*
>
(
GetContent
(
)
)
-
>
ControlType
(
)
=
=
NS_FORM_INPUT_RANGE
;
if
(
typeIsRange
)
{
UpdateForValueChange
(
)
;
}
}
else
if
(
aAttribute
=
=
nsGkAtoms
:
:
orient
)
{
PresShell
(
)
-
>
FrameNeedsReflow
(
this
nsIPresShell
:
:
eResize
NS_FRAME_IS_DIRTY
)
;
}
}
return
nsContainerFrame
:
:
AttributeChanged
(
aNameSpaceID
aAttribute
aModType
)
;
}
nscoord
nsRangeFrame
:
:
AutoCrossSize
(
nscoord
aEm
)
{
nscoord
minCrossSize
(
0
)
;
if
(
IsThemed
(
)
)
{
bool
unused
;
LayoutDeviceIntSize
size
;
nsPresContext
*
pc
=
PresContext
(
)
;
pc
-
>
GetTheme
(
)
-
>
GetMinimumWidgetSize
(
pc
this
StyleAppearance
:
:
RangeThumb
&
size
&
unused
)
;
minCrossSize
=
pc
-
>
DevPixelsToAppUnits
(
IsHorizontal
(
)
?
size
.
height
:
size
.
width
)
;
}
return
std
:
:
max
(
minCrossSize
NSToCoordRound
(
CROSS_AXIS_EM_SIZE
*
aEm
)
)
;
}
LogicalSize
nsRangeFrame
:
:
ComputeAutoSize
(
gfxContext
*
aRenderingContext
WritingMode
aWM
const
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
LogicalSize
&
aMargin
const
LogicalSize
&
aBorder
const
LogicalSize
&
aPadding
ComputeSizeFlags
aFlags
)
{
bool
isInlineOriented
=
IsInlineOriented
(
)
;
auto
em
=
StyleFont
(
)
-
>
mFont
.
size
*
nsLayoutUtils
:
:
FontSizeInflationFor
(
this
)
;
const
WritingMode
wm
=
GetWritingMode
(
)
;
LogicalSize
autoSize
(
wm
)
;
if
(
isInlineOriented
)
{
autoSize
.
ISize
(
wm
)
=
NSToCoordRound
(
MAIN_AXIS_EM_SIZE
*
em
)
;
autoSize
.
BSize
(
wm
)
=
AutoCrossSize
(
em
)
;
}
else
{
autoSize
.
ISize
(
wm
)
=
AutoCrossSize
(
em
)
;
autoSize
.
BSize
(
wm
)
=
NSToCoordRound
(
MAIN_AXIS_EM_SIZE
*
em
)
;
}
return
autoSize
.
ConvertTo
(
aWM
wm
)
;
}
nscoord
nsRangeFrame
:
:
GetMinISize
(
gfxContext
*
aRenderingContext
)
{
auto
pos
=
StylePosition
(
)
;
auto
wm
=
GetWritingMode
(
)
;
if
(
pos
-
>
ISize
(
wm
)
.
HasPercent
(
)
)
{
return
nsLayoutUtils
:
:
ResolveToLength
<
true
>
(
pos
-
>
ISize
(
wm
)
.
AsLengthPercentage
(
)
nscoord
(
0
)
)
;
}
return
GetPrefISize
(
aRenderingContext
)
;
}
nscoord
nsRangeFrame
:
:
GetPrefISize
(
gfxContext
*
aRenderingContext
)
{
bool
isInline
=
IsInlineOriented
(
)
;
auto
em
=
StyleFont
(
)
-
>
mFont
.
size
*
nsLayoutUtils
:
:
FontSizeInflationFor
(
this
)
;
return
isInline
?
NSToCoordRound
(
em
*
MAIN_AXIS_EM_SIZE
)
:
AutoCrossSize
(
em
)
;
}
bool
nsRangeFrame
:
:
IsHorizontal
(
)
const
{
dom
:
:
HTMLInputElement
*
element
=
static_cast
<
dom
:
:
HTMLInputElement
*
>
(
GetContent
(
)
)
;
return
element
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
orient
nsGkAtoms
:
:
horizontal
eCaseMatters
)
|
|
(
!
element
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
orient
nsGkAtoms
:
:
vertical
eCaseMatters
)
&
&
GetWritingMode
(
)
.
IsVertical
(
)
=
=
element
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
orient
nsGkAtoms
:
:
block
eCaseMatters
)
)
;
}
double
nsRangeFrame
:
:
GetMin
(
)
const
{
return
static_cast
<
dom
:
:
HTMLInputElement
*
>
(
GetContent
(
)
)
-
>
GetMinimum
(
)
.
toDouble
(
)
;
}
double
nsRangeFrame
:
:
GetMax
(
)
const
{
return
static_cast
<
dom
:
:
HTMLInputElement
*
>
(
GetContent
(
)
)
-
>
GetMaximum
(
)
.
toDouble
(
)
;
}
double
nsRangeFrame
:
:
GetValue
(
)
const
{
return
static_cast
<
dom
:
:
HTMLInputElement
*
>
(
GetContent
(
)
)
-
>
GetValueAsDecimal
(
)
.
toDouble
(
)
;
}
#
define
STYLES_DISABLING_NATIVE_THEMING
\
NS_AUTHOR_SPECIFIED_BACKGROUND
|
NS_AUTHOR_SPECIFIED_PADDING
|
\
NS_AUTHOR_SPECIFIED_BORDER
bool
nsRangeFrame
:
:
ShouldUseNativeStyle
(
)
const
{
nsIFrame
*
trackFrame
=
mTrackDiv
-
>
GetPrimaryFrame
(
)
;
nsIFrame
*
progressFrame
=
mProgressDiv
-
>
GetPrimaryFrame
(
)
;
nsIFrame
*
thumbFrame
=
mThumbDiv
-
>
GetPrimaryFrame
(
)
;
return
(
StyleDisplay
(
)
-
>
mAppearance
=
=
StyleAppearance
:
:
Range
)
&
&
trackFrame
&
&
!
PresContext
(
)
-
>
HasAuthorSpecifiedRules
(
trackFrame
STYLES_DISABLING_NATIVE_THEMING
)
&
&
progressFrame
&
&
!
PresContext
(
)
-
>
HasAuthorSpecifiedRules
(
progressFrame
STYLES_DISABLING_NATIVE_THEMING
)
&
&
thumbFrame
&
&
!
PresContext
(
)
-
>
HasAuthorSpecifiedRules
(
thumbFrame
STYLES_DISABLING_NATIVE_THEMING
)
;
}
ComputedStyle
*
nsRangeFrame
:
:
GetAdditionalComputedStyle
(
int32_t
aIndex
)
const
{
if
(
aIndex
!
=
0
)
{
return
nullptr
;
}
return
mOuterFocusStyle
;
}
void
nsRangeFrame
:
:
SetAdditionalComputedStyle
(
int32_t
aIndex
ComputedStyle
*
aComputedStyle
)
{
MOZ_ASSERT
(
aIndex
=
=
0
"
GetAdditionalComputedStyle
is
handling
other
indexes
?
"
)
;
mOuterFocusStyle
=
aComputedStyle
;
}
