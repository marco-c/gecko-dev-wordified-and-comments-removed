#
ifndef
nsTextControlFrame_h___
#
define
nsTextControlFrame_h___
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
TextControlElement
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsIAnonymousContentCreator
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsIStatefulFrame
.
h
"
class
nsISelectionController
;
class
EditorInitializerEntryTracker
;
namespace
mozilla
{
class
AutoTextControlHandlingState
;
class
ScrollContainerFrame
;
class
TextEditor
;
class
TextControlState
;
enum
class
PseudoStyleType
:
uint8_t
;
enum
class
SelectionDirection
:
uint8_t
;
namespace
dom
{
class
Element
;
}
}
class
nsTextControlFrame
:
public
nsContainerFrame
public
nsIAnonymousContentCreator
public
nsIStatefulFrame
{
using
Element
=
mozilla
:
:
dom
:
:
Element
;
public
:
NS_DECL_FRAMEARENA_HELPERS
(
nsTextControlFrame
)
NS_DECLARE_FRAME_PROPERTY_SMALL_VALUE
(
ContentScrollPos
nsPoint
)
protected
:
nsTextControlFrame
(
ComputedStyle
*
nsPresContext
*
nsIFrame
:
:
ClassID
)
;
public
:
explicit
nsTextControlFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
:
nsTextControlFrame
(
aStyle
aPresContext
kClassID
)
{
}
virtual
~
nsTextControlFrame
(
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
Destroy
(
DestroyContext
&
)
override
;
mozilla
:
:
ScrollContainerFrame
*
GetScrollTargetFrame
(
)
const
override
;
nscoord
IntrinsicISize
(
const
mozilla
:
:
IntrinsicSizeInput
&
aInput
mozilla
:
:
IntrinsicISizeType
aType
)
override
;
void
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
override
;
Maybe
<
nscoord
>
GetNaturalBaselineBOffset
(
mozilla
:
:
WritingMode
aWM
BaselineSharingGroup
aBaselineGroup
BaselineExportContext
aExportContext
)
const
override
;
BaselineSharingGroup
GetDefaultBaselineSharingGroup
(
)
const
override
{
return
BaselineSharingGroup
:
:
Last
;
}
static
Maybe
<
nscoord
>
GetSingleLineTextControlBaseline
(
const
nsIFrame
*
aFrame
nscoord
aFirstBaseline
mozilla
:
:
WritingMode
aWM
BaselineSharingGroup
aBaselineGroup
)
{
if
(
aFrame
-
>
StyleDisplay
(
)
-
>
IsContainLayout
(
)
)
{
return
Nothing
{
}
;
}
NS_ASSERTION
(
aFirstBaseline
!
=
NS_INTRINSIC_ISIZE_UNKNOWN
"
please
call
Reflow
before
asking
for
the
baseline
"
)
;
return
mozilla
:
:
Some
(
aBaselineGroup
=
=
BaselineSharingGroup
:
:
First
?
aFirstBaseline
:
aFrame
-
>
BSize
(
aWM
)
-
aFirstBaseline
)
;
}
#
ifdef
ACCESSIBILITY
mozilla
:
:
a11y
:
:
AccType
AccessibleType
(
)
override
;
#
endif
#
ifdef
DEBUG_FRAME_DUMP
nsresult
GetFrameName
(
nsAString
&
aResult
)
const
override
{
aResult
.
AssignLiteral
(
"
nsTextControlFrame
"
)
;
return
NS_OK
;
}
#
endif
nsresult
CreateAnonymousContent
(
nsTArray
<
ContentInfo
>
&
aElements
)
override
;
void
AppendAnonymousContentTo
(
nsTArray
<
nsIContent
*
>
&
aElements
uint32_t
aFilter
)
override
;
void
SetInitialChildList
(
ChildListID
nsFrameList
&
&
)
override
;
void
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
override
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
already_AddRefed
<
mozilla
:
:
TextEditor
>
GetTextEditor
(
)
;
MOZ_CAN_RUN_SCRIPT
NS_IMETHOD
SetSelectionRange
(
uint32_t
aSelectionStart
uint32_t
aSelectionEnd
mozilla
:
:
SelectionDirection
)
;
NS_IMETHOD
GetOwnedSelectionController
(
nsISelectionController
*
*
aSelCon
)
;
nsFrameSelection
*
GetOwnedFrameSelection
(
)
{
return
ControlElement
(
)
-
>
GetConstFrameSelection
(
)
;
}
nsISelectionController
*
GetSelectionController
(
)
{
return
ControlElement
(
)
-
>
GetSelectionController
(
)
;
}
void
PlaceholderChanged
(
const
nsAttrValue
*
aOld
const
nsAttrValue
*
aNew
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
EnsureEditorInitialized
(
)
;
mozilla
:
:
UniquePtr
<
mozilla
:
:
PresState
>
SaveState
(
)
override
;
NS_IMETHOD
RestoreState
(
mozilla
:
:
PresState
*
aState
)
override
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
override
;
void
ElementStateChanged
(
mozilla
:
:
dom
:
:
ElementState
aStates
)
override
;
nsresult
PeekOffset
(
mozilla
:
:
PeekOffsetStruct
*
aPos
)
override
;
NS_DECL_QUERYFRAME
enum
class
ScrollAncestors
{
No
Yes
}
;
void
ScrollSelectionIntoViewAsync
(
ScrollAncestors
=
ScrollAncestors
:
:
No
)
;
protected
:
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
OnFocus
(
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
HandleReadonlyOrDisabledChange
(
)
;
void
ReflowTextControlChild
(
nsIFrame
*
aKid
nsPresContext
*
aPresContext
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
ReflowOutput
&
aParentDesiredSize
const
mozilla
:
:
LogicalSize
&
aParentContentBoxSize
nscoord
&
aButtonBoxISize
)
;
public
:
static
Maybe
<
nscoord
>
ComputeBaseline
(
const
nsIFrame
*
const
ReflowInput
&
bool
aForSingleLineControl
)
;
Element
*
GetRootNode
(
)
const
{
return
mRootNode
;
}
Element
*
GetPreviewNode
(
)
const
{
return
mPreviewDiv
;
}
Element
*
GetPlaceholderNode
(
)
const
{
return
mPlaceholderDiv
;
}
Element
*
GetButton
(
)
const
{
return
mButton
;
}
bool
IsButtonBox
(
const
nsIFrame
*
aFrame
)
const
{
return
aFrame
-
>
GetContent
(
)
=
=
GetButton
(
)
;
}
nsresult
MaybeBeginSecureKeyboardInput
(
)
;
void
MaybeEndSecureKeyboardInput
(
)
;
mozilla
:
:
TextControlElement
*
ControlElement
(
)
const
{
MOZ_ASSERT
(
mozilla
:
:
TextControlElement
:
:
FromNode
(
GetContent
(
)
)
)
;
return
static_cast
<
mozilla
:
:
TextControlElement
*
>
(
GetContent
(
)
)
;
}
#
define
DEFINE_TEXTCTRL_CONST_FORWARDER
(
type
name
)
\
type
name
(
)
const
{
return
ControlElement
(
)
-
>
name
(
)
;
}
DEFINE_TEXTCTRL_CONST_FORWARDER
(
bool
IsSingleLineTextControl
)
DEFINE_TEXTCTRL_CONST_FORWARDER
(
bool
IsTextArea
)
DEFINE_TEXTCTRL_CONST_FORWARDER
(
bool
IsPasswordTextControl
)
DEFINE_TEXTCTRL_CONST_FORWARDER
(
Maybe
<
int32_t
>
GetCols
)
DEFINE_TEXTCTRL_CONST_FORWARDER
(
int32_t
GetColsOrDefault
)
DEFINE_TEXTCTRL_CONST_FORWARDER
(
int32_t
GetRows
)
#
undef
DEFINE_TEXTCTRL_CONST_FORWARDER
MOZ_CAN_RUN_SCRIPT
nsresult
SelectAll
(
)
;
protected
:
class
EditorInitializer
;
friend
class
EditorInitializer
;
friend
class
mozilla
:
:
AutoTextControlHandlingState
;
friend
class
mozilla
:
:
TextControlState
;
NS_DECLARE_FRAME_PROPERTY_WITH_DTOR
(
TextControlInitializer
EditorInitializer
nsTextControlFrame
:
:
RevokeInitializer
)
static
void
RevokeInitializer
(
EditorInitializer
*
aInitializer
)
{
aInitializer
-
>
Revoke
(
)
;
}
;
class
EditorInitializer
:
public
mozilla
:
:
Runnable
{
public
:
explicit
EditorInitializer
(
nsTextControlFrame
*
aFrame
)
:
mozilla
:
:
Runnable
(
"
nsTextControlFrame
:
:
EditorInitializer
"
)
mFrame
(
aFrame
)
{
}
NS_IMETHOD
Run
(
)
override
;
void
Revoke
(
)
{
mFrame
=
nullptr
;
}
private
:
nsTextControlFrame
*
mFrame
;
}
;
nsresult
OffsetToDOMPoint
(
uint32_t
aOffset
nsINode
*
*
aResult
uint32_t
*
aPosition
)
;
nsresult
UpdateValueDisplay
(
bool
aNotify
bool
aBeforeEditorInit
=
false
const
nsAString
*
aValue
=
nullptr
)
;
bool
AttributeExists
(
nsAtom
*
aAtt
)
const
{
return
mContent
&
&
mContent
-
>
AsElement
(
)
-
>
HasAttr
(
aAtt
)
;
}
void
PreDestroy
(
)
;
mozilla
:
:
LogicalSize
CalcIntrinsicSize
(
gfxContext
*
aRenderingContext
mozilla
:
:
WritingMode
aWM
)
const
;
private
:
MOZ_CAN_RUN_SCRIPT
nsresult
SetSelectionInternal
(
nsINode
*
aStartNode
uint32_t
aStartOffset
nsINode
*
aEndNode
uint32_t
aEndOffset
mozilla
:
:
SelectionDirection
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
SetSelectionEndPoints
(
uint32_t
aSelStart
uint32_t
aSelEnd
mozilla
:
:
SelectionDirection
)
;
void
FinishedInitializer
(
)
{
RemoveProperty
(
TextControlInitializer
(
)
)
;
}
const
nsAString
&
CachedValue
(
)
const
{
return
mCachedValue
;
}
void
ClearCachedValue
(
)
{
mCachedValue
.
SetIsVoid
(
true
)
;
}
void
CacheValue
(
const
nsAString
&
aValue
)
{
mCachedValue
.
Assign
(
aValue
)
;
}
[
[
nodiscard
]
]
bool
CacheValue
(
const
nsAString
&
aValue
const
mozilla
:
:
fallible_t
&
aFallible
)
{
if
(
!
mCachedValue
.
Assign
(
aValue
aFallible
)
)
{
ClearCachedValue
(
)
;
return
false
;
}
return
true
;
}
protected
:
class
nsAnonDivObserver
;
nsresult
CreateRootNode
(
)
;
void
CreatePlaceholderIfNeeded
(
)
;
void
UpdatePlaceholderText
(
nsString
&
bool
aNotify
)
;
void
CreatePreviewIfNeeded
(
)
;
already_AddRefed
<
Element
>
MakeAnonElement
(
mozilla
:
:
PseudoStyleType
Element
*
aParent
=
nullptr
nsAtom
*
aTag
=
nsGkAtoms
:
:
div
)
const
;
already_AddRefed
<
Element
>
MakeAnonDivWithTextNode
(
mozilla
:
:
PseudoStyleType
)
const
;
bool
ShouldInitializeEagerly
(
)
const
;
void
InitializeEagerlyIfNeeded
(
)
;
RefPtr
<
Element
>
mRootNode
;
RefPtr
<
Element
>
mPlaceholderDiv
;
RefPtr
<
Element
>
mPreviewDiv
;
RefPtr
<
Element
>
mButton
;
RefPtr
<
nsAnonDivObserver
>
mMutationObserver
;
nsString
mCachedValue
{
VoidString
(
)
}
;
nscoord
mFirstBaseline
=
NS_INTRINSIC_ISIZE_UNKNOWN
;
bool
mEditorHasBeenInitialized
=
false
;
bool
mIsProcessing
=
false
;
#
ifdef
DEBUG
bool
mInEditorInitialization
=
false
;
friend
class
EditorInitializerEntryTracker
;
#
endif
}
;
#
endif
