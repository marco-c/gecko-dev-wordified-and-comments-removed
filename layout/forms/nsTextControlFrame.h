#
ifndef
nsTextControlFrame_h___
#
define
nsTextControlFrame_h___
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
TextControlElement
.
h
"
#
include
"
mozilla
/
dom
/
Element
.
h
"
#
include
"
nsContainerFrame
.
h
"
#
include
"
nsIAnonymousContentCreator
.
h
"
#
include
"
nsIContent
.
h
"
#
include
"
nsITextControlFrame
.
h
"
#
include
"
nsIStatefulFrame
.
h
"
class
nsISelectionController
;
class
EditorInitializerEntryTracker
;
namespace
mozilla
{
class
AutoTextControlHandlingState
;
class
TextEditor
;
class
TextControlState
;
enum
class
PseudoStyleType
:
uint8_t
;
namespace
dom
{
class
Element
;
}
}
class
nsTextControlFrame
:
public
nsContainerFrame
public
nsIAnonymousContentCreator
public
nsITextControlFrame
public
nsIStatefulFrame
{
using
Element
=
mozilla
:
:
dom
:
:
Element
;
public
:
NS_DECL_FRAMEARENA_HELPERS
(
nsTextControlFrame
)
NS_DECLARE_FRAME_PROPERTY_DELETABLE
(
ContentScrollPos
nsPoint
)
protected
:
nsTextControlFrame
(
ComputedStyle
*
nsPresContext
*
nsIFrame
:
:
ClassID
)
;
public
:
explicit
nsTextControlFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
:
nsTextControlFrame
(
aStyle
aPresContext
kClassID
)
{
}
virtual
~
nsTextControlFrame
(
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
void
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
)
override
;
nsIScrollableFrame
*
GetScrollTargetFrame
(
)
override
;
nsIScrollableFrame
*
GetScrollTargetFrame
(
)
const
{
return
const_cast
<
nsTextControlFrame
*
>
(
this
)
-
>
GetScrollTargetFrame
(
)
;
}
nscoord
GetMinISize
(
gfxContext
*
aRenderingContext
)
override
;
nscoord
GetPrefISize
(
gfxContext
*
aRenderingContext
)
override
;
mozilla
:
:
LogicalSize
ComputeAutoSize
(
gfxContext
*
aRenderingContext
mozilla
:
:
WritingMode
aWM
const
mozilla
:
:
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
mozilla
:
:
LogicalSize
&
aMargin
const
mozilla
:
:
LogicalSize
&
aBorder
const
mozilla
:
:
LogicalSize
&
aPadding
ComputeSizeFlags
aFlags
)
override
;
void
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
override
;
bool
GetVerticalAlignBaseline
(
mozilla
:
:
WritingMode
aWM
nscoord
*
aBaseline
)
const
override
{
return
GetNaturalBaselineBOffset
(
aWM
BaselineSharingGroup
:
:
First
aBaseline
)
;
}
bool
GetNaturalBaselineBOffset
(
mozilla
:
:
WritingMode
aWM
BaselineSharingGroup
aBaselineGroup
nscoord
*
aBaseline
)
const
override
{
if
(
StyleDisplay
(
)
-
>
IsContainLayout
(
)
|
|
!
IsSingleLineTextControl
(
)
)
{
return
false
;
}
NS_ASSERTION
(
mFirstBaseline
!
=
NS_INTRINSIC_ISIZE_UNKNOWN
"
please
call
Reflow
before
asking
for
the
baseline
"
)
;
if
(
aBaselineGroup
=
=
BaselineSharingGroup
:
:
First
)
{
*
aBaseline
=
mFirstBaseline
;
}
else
{
*
aBaseline
=
BSize
(
aWM
)
-
mFirstBaseline
;
}
return
true
;
}
nsSize
GetXULMinSize
(
nsBoxLayoutState
&
)
override
;
bool
IsXULCollapsed
(
)
override
;
#
ifdef
ACCESSIBILITY
mozilla
:
:
a11y
:
:
AccType
AccessibleType
(
)
override
;
#
endif
#
ifdef
DEBUG_FRAME_DUMP
nsresult
GetFrameName
(
nsAString
&
aResult
)
const
override
{
aResult
.
AssignLiteral
(
"
nsTextControlFrame
"
)
;
return
NS_OK
;
}
#
endif
bool
IsFrameOfType
(
uint32_t
aFlags
)
const
override
{
return
nsContainerFrame
:
:
IsFrameOfType
(
aFlags
&
~
(
nsIFrame
:
:
eReplaced
|
nsIFrame
:
:
eReplacedContainsBlock
)
)
;
}
#
ifdef
DEBUG
void
MarkIntrinsicISizesDirty
(
)
override
{
mFirstBaseline
=
NS_INTRINSIC_ISIZE_UNKNOWN
;
}
#
endif
nsresult
CreateAnonymousContent
(
nsTArray
<
ContentInfo
>
&
aElements
)
override
;
void
AppendAnonymousContentTo
(
nsTArray
<
nsIContent
*
>
&
aElements
uint32_t
aFilter
)
override
;
void
SetInitialChildList
(
ChildListID
nsFrameList
&
)
override
;
void
BuildDisplayList
(
nsDisplayListBuilder
*
aBuilder
const
nsDisplayListSet
&
aLists
)
override
;
void
SetFocus
(
bool
aOn
bool
aRepaint
)
override
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
SetFormProperty
(
nsAtom
*
aName
const
nsAString
&
aValue
)
override
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
already_AddRefed
<
mozilla
:
:
TextEditor
>
GetTextEditor
(
)
override
;
MOZ_CAN_RUN_SCRIPT
NS_IMETHOD
SetSelectionRange
(
uint32_t
aSelectionStart
uint32_t
aSelectionEnd
SelectionDirection
aDirection
=
eNone
)
override
;
NS_IMETHOD
GetOwnedSelectionController
(
nsISelectionController
*
*
aSelCon
)
override
;
nsFrameSelection
*
GetOwnedFrameSelection
(
)
override
;
void
PlaceholderChanged
(
const
nsAttrValue
*
aOld
const
nsAttrValue
*
aNew
)
;
MOZ_CAN_RUN_SCRIPT_BOUNDARY
nsresult
EnsureEditorInitialized
(
)
override
;
mozilla
:
:
UniquePtr
<
mozilla
:
:
PresState
>
SaveState
(
)
override
;
NS_IMETHOD
RestoreState
(
mozilla
:
:
PresState
*
aState
)
override
;
nsresult
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
override
;
void
GetText
(
nsString
&
aText
)
;
bool
TextEquals
(
const
nsAString
&
aText
)
const
;
nsresult
PeekOffset
(
nsPeekOffsetStruct
*
aPos
)
override
;
NS_DECL_QUERYFRAME
enum
class
ScrollAncestors
{
No
Yes
}
;
void
ScrollSelectionIntoViewAsync
(
ScrollAncestors
=
ScrollAncestors
:
:
No
)
;
protected
:
void
ReflowTextControlChild
(
nsIFrame
*
aFrame
nsPresContext
*
aPresContext
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
ReflowOutput
&
aParentDesiredSize
)
;
void
ComputeBaseline
(
const
ReflowInput
&
ReflowOutput
&
)
;
public
:
void
SetValueChanged
(
bool
aValueChanged
)
;
Element
*
GetRootNode
(
)
const
{
return
mRootNode
;
}
Element
*
GetPreviewNode
(
)
const
{
return
mPreviewDiv
;
}
Element
*
GetPlaceholderNode
(
)
const
{
return
mPlaceholderDiv
;
}
nsresult
MaybeBeginSecureKeyboardInput
(
)
;
void
MaybeEndSecureKeyboardInput
(
)
;
#
define
DEFINE_TEXTCTRL_CONST_FORWARDER
(
type
name
)
\
type
name
(
)
const
{
\
mozilla
:
:
TextControlElement
*
textControlElement
=
\
mozilla
:
:
TextControlElement
:
:
FromNode
(
GetContent
(
)
)
;
\
return
textControlElement
-
>
name
(
)
;
\
}
DEFINE_TEXTCTRL_CONST_FORWARDER
(
bool
IsSingleLineTextControl
)
DEFINE_TEXTCTRL_CONST_FORWARDER
(
bool
IsTextArea
)
DEFINE_TEXTCTRL_CONST_FORWARDER
(
bool
IsPasswordTextControl
)
DEFINE_TEXTCTRL_CONST_FORWARDER
(
int32_t
GetCols
)
DEFINE_TEXTCTRL_CONST_FORWARDER
(
int32_t
GetRows
)
#
undef
DEFINE_TEXTCTRL_CONST_FORWARDER
protected
:
class
EditorInitializer
;
friend
class
EditorInitializer
;
friend
class
mozilla
:
:
AutoTextControlHandlingState
;
friend
class
mozilla
:
:
TextControlState
;
NS_DECLARE_FRAME_PROPERTY_WITH_DTOR
(
TextControlInitializer
EditorInitializer
nsTextControlFrame
:
:
RevokeInitializer
)
static
void
RevokeInitializer
(
EditorInitializer
*
aInitializer
)
{
aInitializer
-
>
Revoke
(
)
;
}
;
class
EditorInitializer
:
public
mozilla
:
:
Runnable
{
public
:
explicit
EditorInitializer
(
nsTextControlFrame
*
aFrame
)
:
mozilla
:
:
Runnable
(
"
nsTextControlFrame
:
:
EditorInitializer
"
)
mFrame
(
aFrame
)
{
}
NS_IMETHOD
Run
(
)
override
;
void
Revoke
(
)
{
mFrame
=
nullptr
;
}
private
:
nsTextControlFrame
*
mFrame
;
}
;
nsresult
OffsetToDOMPoint
(
uint32_t
aOffset
nsINode
*
*
aResult
uint32_t
*
aPosition
)
;
nsresult
UpdateValueDisplay
(
bool
aNotify
bool
aBeforeEditorInit
=
false
const
nsAString
*
aValue
=
nullptr
)
;
bool
AttributeExists
(
nsAtom
*
aAtt
)
const
{
return
mContent
&
&
mContent
-
>
AsElement
(
)
-
>
HasAttr
(
kNameSpaceID_None
aAtt
)
;
}
void
PreDestroy
(
)
;
mozilla
:
:
LogicalSize
CalcIntrinsicSize
(
gfxContext
*
aRenderingContext
mozilla
:
:
WritingMode
aWM
float
aFontSizeInflation
)
const
;
private
:
MOZ_CAN_RUN_SCRIPT
nsresult
SetSelectionInternal
(
nsINode
*
aStartNode
uint32_t
aStartOffset
nsINode
*
aEndNode
uint32_t
aEndOffset
SelectionDirection
aDirection
=
eNone
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
SelectAllOrCollapseToEndOfText
(
bool
aSelect
)
;
MOZ_CAN_RUN_SCRIPT
nsresult
SetSelectionEndPoints
(
uint32_t
aSelStart
uint32_t
aSelEnd
SelectionDirection
aDirection
=
eNone
)
;
void
FinishedInitializer
(
)
{
RemoveProperty
(
TextControlInitializer
(
)
)
;
}
const
nsAString
&
CachedValue
(
)
const
{
return
mCachedValue
;
}
void
ClearCachedValue
(
)
{
mCachedValue
.
SetIsVoid
(
true
)
;
}
void
CacheValue
(
const
nsAString
&
aValue
)
{
mCachedValue
.
Assign
(
aValue
)
;
}
[
[
nodiscard
]
]
bool
CacheValue
(
const
nsAString
&
aValue
const
mozilla
:
:
fallible_t
&
aFallible
)
{
if
(
!
mCachedValue
.
Assign
(
aValue
aFallible
)
)
{
ClearCachedValue
(
)
;
return
false
;
}
return
true
;
}
protected
:
class
nsAnonDivObserver
;
nsresult
CreateRootNode
(
)
;
void
CreatePlaceholderIfNeeded
(
)
;
void
UpdatePlaceholderText
(
nsString
&
bool
aNotify
)
;
void
CreatePreviewIfNeeded
(
)
;
already_AddRefed
<
Element
>
MakeAnonElement
(
mozilla
:
:
PseudoStyleType
Element
*
aParent
=
nullptr
nsAtom
*
aTag
=
nsGkAtoms
:
:
div
)
const
;
already_AddRefed
<
Element
>
MakeAnonDivWithTextNode
(
mozilla
:
:
PseudoStyleType
)
const
;
bool
ShouldInitializeEagerly
(
)
const
;
void
InitializeEagerlyIfNeeded
(
)
;
RefPtr
<
Element
>
mRootNode
;
RefPtr
<
Element
>
mPlaceholderDiv
;
RefPtr
<
Element
>
mPreviewDiv
;
RefPtr
<
nsAnonDivObserver
>
mMutationObserver
;
nsString
mCachedValue
;
nscoord
mFirstBaseline
;
bool
mEditorHasBeenInitialized
;
bool
mIsProcessing
;
#
ifdef
DEBUG
bool
mInEditorInitialization
;
friend
class
EditorInitializerEntryTracker
;
#
endif
}
;
#
endif
