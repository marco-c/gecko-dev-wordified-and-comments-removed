#
include
"
HTMLSelectEventListener
.
h
"
#
include
"
nsListControlFrame
.
h
"
#
include
"
mozilla
/
dom
/
Event
.
h
"
#
include
"
mozilla
/
dom
/
MouseEvent
.
h
"
#
include
"
mozilla
/
Casting
.
h
"
#
include
"
mozilla
/
MouseEvents
.
h
"
#
include
"
mozilla
/
TextEvents
.
h
"
#
include
"
mozilla
/
PresShell
.
h
"
#
include
"
mozilla
/
dom
/
HTMLSelectElement
.
h
"
#
include
"
mozilla
/
dom
/
HTMLOptionElement
.
h
"
#
include
"
mozilla
/
StaticPrefs_ui
.
h
"
#
include
"
mozilla
/
ClearOnShutdown
.
h
"
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
static
bool
IsOptionInteractivelySelectable
(
HTMLSelectElement
&
aSelect
HTMLOptionElement
&
aOption
bool
aIsCombobox
)
{
if
(
aSelect
.
IsOptionDisabled
(
&
aOption
)
)
{
return
false
;
}
if
(
!
aIsCombobox
)
{
return
aOption
.
GetPrimaryFrame
(
)
;
}
if
(
!
aOption
.
HasServoData
(
)
|
|
Servo_Element_IsDisplayNone
(
&
aOption
)
)
{
return
false
;
}
for
(
Element
*
el
=
&
aOption
;
el
&
&
el
!
=
&
aSelect
;
el
=
el
-
>
GetParentElement
(
)
)
{
if
(
Servo_Element_IsDisplayContents
(
el
)
)
{
return
false
;
}
}
return
true
;
}
namespace
mozilla
{
static
StaticAutoPtr
<
nsString
>
sIncrementalString
;
static
TimeStamp
gLastKeyTime
;
static
uintptr_t
sLastKeyListener
=
0
;
static
constexpr
int32_t
kNothingSelected
=
-
1
;
static
nsString
&
GetIncrementalString
(
)
{
MOZ_ASSERT
(
sLastKeyListener
!
=
0
)
;
if
(
!
sIncrementalString
)
{
sIncrementalString
=
new
nsString
(
)
;
ClearOnShutdown
(
&
sIncrementalString
)
;
}
return
*
sIncrementalString
;
}
class
MOZ_RAII
AutoIncrementalSearchHandler
{
public
:
explicit
AutoIncrementalSearchHandler
(
HTMLSelectEventListener
&
aListener
)
{
if
(
sLastKeyListener
!
=
uintptr_t
(
&
aListener
)
)
{
sLastKeyListener
=
uintptr_t
(
&
aListener
)
;
GetIncrementalString
(
)
.
Truncate
(
)
;
gLastKeyTime
=
TimeStamp
:
:
Now
(
)
-
TimeDuration
:
:
FromMilliseconds
(
StaticPrefs
:
:
ui_menu_incremental_search_timeout
(
)
*
2
)
;
}
}
~
AutoIncrementalSearchHandler
(
)
{
if
(
!
mResettingCancelled
)
{
GetIncrementalString
(
)
.
Truncate
(
)
;
}
}
void
CancelResetting
(
)
{
mResettingCancelled
=
true
;
}
private
:
bool
mResettingCancelled
=
false
;
}
;
NS_IMPL_ISUPPORTS
(
HTMLSelectEventListener
nsIMutationObserver
nsIDOMEventListener
)
HTMLSelectEventListener
:
:
~
HTMLSelectEventListener
(
)
{
if
(
sLastKeyListener
=
=
uintptr_t
(
this
)
)
{
sLastKeyListener
=
0
;
}
}
nsListControlFrame
*
HTMLSelectEventListener
:
:
GetListControlFrame
(
)
const
{
if
(
mIsCombobox
)
{
MOZ_ASSERT
(
!
mElement
-
>
GetPrimaryFrame
(
)
|
|
!
mElement
-
>
GetPrimaryFrame
(
)
-
>
IsListControlFrame
(
)
)
;
return
nullptr
;
}
return
do_QueryFrame
(
mElement
-
>
GetPrimaryFrame
(
)
)
;
}
int32_t
HTMLSelectEventListener
:
:
GetEndSelectionIndex
(
)
const
{
if
(
auto
*
lf
=
GetListControlFrame
(
)
)
{
return
lf
-
>
GetEndSelectionIndex
(
)
;
}
return
mElement
-
>
SelectedIndex
(
)
;
}
bool
HTMLSelectEventListener
:
:
IsOptionInteractivelySelectable
(
uint32_t
aIndex
)
const
{
HTMLOptionElement
*
option
=
mElement
-
>
Item
(
aIndex
)
;
return
option
&
&
:
:
IsOptionInteractivelySelectable
(
*
mElement
*
option
mIsCombobox
)
;
}
void
HTMLSelectEventListener
:
:
AdjustIndexForDisabledOpt
(
int32_t
aStartIndex
int32_t
&
aNewIndex
int32_t
aNumOptions
int32_t
aDoAdjustInc
int32_t
aDoAdjustIncNext
)
{
if
(
aNumOptions
=
=
0
)
{
aNewIndex
=
kNothingSelected
;
return
;
}
bool
doingReverse
=
false
;
int32_t
bottom
=
0
;
int32_t
top
=
aNumOptions
;
int32_t
startIndex
=
aStartIndex
;
if
(
startIndex
<
bottom
)
{
startIndex
=
mElement
-
>
SelectedIndex
(
)
;
}
int32_t
newIndex
=
startIndex
+
aDoAdjustInc
;
if
(
newIndex
<
bottom
)
{
newIndex
=
0
;
}
else
if
(
newIndex
>
=
top
)
{
newIndex
=
aNumOptions
-
1
;
}
while
(
true
)
{
if
(
IsOptionInteractivelySelectable
(
newIndex
)
)
{
break
;
}
newIndex
+
=
aDoAdjustIncNext
;
if
(
newIndex
<
bottom
)
{
if
(
doingReverse
)
{
return
;
}
newIndex
=
bottom
;
aDoAdjustIncNext
=
1
;
doingReverse
=
true
;
top
=
startIndex
;
}
else
if
(
newIndex
>
=
top
)
{
if
(
doingReverse
)
{
return
;
}
newIndex
=
top
-
1
;
aDoAdjustIncNext
=
-
1
;
doingReverse
=
true
;
bottom
=
startIndex
;
}
}
aNewIndex
=
newIndex
;
}
NS_IMETHODIMP
HTMLSelectEventListener
:
:
HandleEvent
(
dom
:
:
Event
*
aEvent
)
{
nsAutoString
eventType
;
aEvent
-
>
GetType
(
eventType
)
;
if
(
eventType
.
EqualsLiteral
(
"
keydown
"
)
)
{
return
KeyDown
(
aEvent
)
;
}
if
(
eventType
.
EqualsLiteral
(
"
keypress
"
)
)
{
return
KeyPress
(
aEvent
)
;
}
if
(
eventType
.
EqualsLiteral
(
"
mousedown
"
)
)
{
if
(
aEvent
-
>
DefaultPrevented
(
)
)
{
return
NS_OK
;
}
return
MouseDown
(
aEvent
)
;
}
if
(
eventType
.
EqualsLiteral
(
"
mouseup
"
)
)
{
return
MouseUp
(
aEvent
)
;
}
if
(
eventType
.
EqualsLiteral
(
"
mousemove
"
)
)
{
return
MouseMove
(
aEvent
)
;
}
MOZ_ASSERT_UNREACHABLE
(
"
Unexpected
eventType
"
)
;
return
NS_OK
;
}
void
HTMLSelectEventListener
:
:
Attach
(
)
{
mElement
-
>
AddSystemEventListener
(
u
"
keydown
"
_ns
this
false
false
)
;
mElement
-
>
AddSystemEventListener
(
u
"
keypress
"
_ns
this
false
false
)
;
mElement
-
>
AddSystemEventListener
(
u
"
mousedown
"
_ns
this
false
false
)
;
mElement
-
>
AddSystemEventListener
(
u
"
mouseup
"
_ns
this
false
false
)
;
mElement
-
>
AddSystemEventListener
(
u
"
mousemove
"
_ns
this
false
false
)
;
if
(
mIsCombobox
)
{
mElement
-
>
AddMutationObserver
(
this
)
;
}
}
void
HTMLSelectEventListener
:
:
Detach
(
)
{
mElement
-
>
RemoveSystemEventListener
(
u
"
keydown
"
_ns
this
false
)
;
mElement
-
>
RemoveSystemEventListener
(
u
"
keypress
"
_ns
this
false
)
;
mElement
-
>
RemoveSystemEventListener
(
u
"
mousedown
"
_ns
this
false
)
;
mElement
-
>
RemoveSystemEventListener
(
u
"
mouseup
"
_ns
this
false
)
;
mElement
-
>
RemoveSystemEventListener
(
u
"
mousemove
"
_ns
this
false
)
;
if
(
mIsCombobox
)
{
mElement
-
>
RemoveMutationObserver
(
this
)
;
if
(
mElement
-
>
OpenInParentProcess
(
)
)
{
nsContentUtils
:
:
AddScriptRunner
(
NS_NewRunnableFunction
(
"
HTMLSelectEventListener
:
:
Detach
"
[
element
=
mElement
]
{
if
(
!
element
-
>
IsCombobox
(
)
|
|
!
element
-
>
GetPrimaryFrame
(
FlushType
:
:
Frames
)
)
{
nsContentUtils
:
:
DispatchChromeEvent
(
element
-
>
OwnerDoc
(
)
element
u
"
mozhidedropdown
"
_ns
CanBubble
:
:
eYes
Cancelable
:
:
eNo
)
;
}
}
)
)
;
}
}
}
const
uint32_t
kMaxDropdownRows
=
20
;
int32_t
HTMLSelectEventListener
:
:
ItemsPerPage
(
)
const
{
uint32_t
size
=
[
&
]
{
if
(
mIsCombobox
)
{
return
kMaxDropdownRows
;
}
if
(
auto
*
lf
=
GetListControlFrame
(
)
)
{
return
lf
-
>
GetNumDisplayRows
(
)
;
}
return
mElement
-
>
Size
(
)
;
}
(
)
;
if
(
size
<
=
1
)
{
return
1
;
}
if
(
MOZ_UNLIKELY
(
size
>
INT32_MAX
)
)
{
return
INT32_MAX
-
1
;
}
return
AssertedCast
<
int32_t
>
(
size
-
1u
)
;
}
void
HTMLSelectEventListener
:
:
OptionValueMightHaveChanged
(
nsIContent
*
aMutatingNode
)
{
#
ifdef
ACCESSIBILITY
if
(
nsAccessibilityService
*
acc
=
GetAccService
(
)
)
{
acc
-
>
ComboboxOptionMaybeChanged
(
mElement
-
>
OwnerDoc
(
)
-
>
GetPresShell
(
)
aMutatingNode
)
;
}
#
endif
}
void
HTMLSelectEventListener
:
:
AttributeChanged
(
dom
:
:
Element
*
aElement
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
const
nsAttrValue
*
aOldValue
)
{
if
(
aElement
-
>
IsHTMLElement
(
nsGkAtoms
:
:
option
)
&
&
aNameSpaceID
=
=
kNameSpaceID_None
&
&
aAttribute
=
=
nsGkAtoms
:
:
label
)
{
ComboboxMightHaveChanged
(
)
;
}
}
void
HTMLSelectEventListener
:
:
CharacterDataChanged
(
nsIContent
*
aContent
const
CharacterDataChangeInfo
&
)
{
if
(
nsContentUtils
:
:
IsInSameAnonymousTree
(
mElement
aContent
)
)
{
OptionValueMightHaveChanged
(
aContent
)
;
ComboboxMightHaveChanged
(
)
;
}
}
void
HTMLSelectEventListener
:
:
ContentRemoved
(
nsIContent
*
aChild
nsIContent
*
aPreviousSibling
)
{
if
(
nsContentUtils
:
:
IsInSameAnonymousTree
(
mElement
aChild
)
)
{
OptionValueMightHaveChanged
(
aChild
)
;
ComboboxMightHaveChanged
(
)
;
}
}
void
HTMLSelectEventListener
:
:
ContentAppended
(
nsIContent
*
aFirstNewContent
)
{
if
(
nsContentUtils
:
:
IsInSameAnonymousTree
(
mElement
aFirstNewContent
)
)
{
OptionValueMightHaveChanged
(
aFirstNewContent
)
;
ComboboxMightHaveChanged
(
)
;
}
}
void
HTMLSelectEventListener
:
:
ContentInserted
(
nsIContent
*
aChild
)
{
if
(
nsContentUtils
:
:
IsInSameAnonymousTree
(
mElement
aChild
)
)
{
OptionValueMightHaveChanged
(
aChild
)
;
ComboboxMightHaveChanged
(
)
;
}
}
void
HTMLSelectEventListener
:
:
ComboboxMightHaveChanged
(
)
{
if
(
nsIFrame
*
f
=
mElement
-
>
GetPrimaryFrame
(
)
)
{
PresShell
*
ps
=
f
-
>
PresShell
(
)
;
ps
-
>
FrameNeedsReflow
(
f
IntrinsicDirty
:
:
FrameAncestorsAndDescendants
NS_FRAME_IS_DIRTY
)
;
#
ifdef
ACCESSIBILITY
if
(
nsAccessibilityService
*
acc
=
GetAccService
(
)
)
{
acc
-
>
ScheduleAccessibilitySubtreeUpdate
(
ps
mElement
)
;
}
#
endif
}
}
void
HTMLSelectEventListener
:
:
FireOnInputAndOnChange
(
)
{
RefPtr
<
HTMLSelectElement
>
element
=
mElement
;
element
-
>
UserFinishedInteracting
(
true
)
;
}
static
void
FireDropDownEvent
(
HTMLSelectElement
*
aElement
bool
aShow
bool
aIsSourceTouchEvent
)
{
const
auto
eventName
=
[
&
]
{
if
(
aShow
)
{
return
aIsSourceTouchEvent
?
u
"
mozshowdropdown
-
sourcetouch
"
_ns
:
u
"
mozshowdropdown
"
_ns
;
}
return
u
"
mozhidedropdown
"
_ns
;
}
(
)
;
nsContentUtils
:
:
DispatchChromeEvent
(
aElement
-
>
OwnerDoc
(
)
aElement
eventName
CanBubble
:
:
eYes
Cancelable
:
:
eNo
)
;
}
nsresult
HTMLSelectEventListener
:
:
MouseDown
(
dom
:
:
Event
*
aMouseEvent
)
{
NS_ASSERTION
(
aMouseEvent
!
=
nullptr
"
aMouseEvent
is
null
.
"
)
;
MouseEvent
*
mouseEvent
=
aMouseEvent
-
>
AsMouseEvent
(
)
;
NS_ENSURE_TRUE
(
mouseEvent
NS_ERROR_FAILURE
)
;
if
(
mElement
-
>
State
(
)
.
HasState
(
ElementState
:
:
DISABLED
)
)
{
return
NS_OK
;
}
const
bool
isLeftButton
=
mouseEvent
-
>
Button
(
)
=
=
0
;
if
(
!
isLeftButton
)
{
return
NS_OK
;
}
if
(
mIsCombobox
)
{
uint16_t
inputSource
=
mouseEvent
-
>
InputSource
(
)
;
if
(
mElement
-
>
OpenInParentProcess
(
)
)
{
nsCOMPtr
<
nsIContent
>
target
=
do_QueryInterface
(
aMouseEvent
-
>
GetTarget
(
)
)
;
if
(
target
&
&
target
-
>
IsHTMLElement
(
nsGkAtoms
:
:
option
)
)
{
return
NS_OK
;
}
}
const
bool
isSourceTouchEvent
=
inputSource
=
=
MouseEvent_Binding
:
:
MOZ_SOURCE_TOUCH
;
FireDropDownEvent
(
mElement
!
mElement
-
>
OpenInParentProcess
(
)
isSourceTouchEvent
)
;
return
NS_OK
;
}
if
(
nsListControlFrame
*
list
=
GetListControlFrame
(
)
)
{
mButtonDown
=
true
;
return
list
-
>
HandleLeftButtonMouseDown
(
aMouseEvent
)
;
}
return
NS_OK
;
}
nsresult
HTMLSelectEventListener
:
:
MouseUp
(
dom
:
:
Event
*
aMouseEvent
)
{
NS_ASSERTION
(
aMouseEvent
!
=
nullptr
"
aMouseEvent
is
null
.
"
)
;
MouseEvent
*
mouseEvent
=
aMouseEvent
-
>
AsMouseEvent
(
)
;
NS_ENSURE_TRUE
(
mouseEvent
NS_ERROR_FAILURE
)
;
mButtonDown
=
false
;
if
(
mElement
-
>
State
(
)
.
HasState
(
ElementState
:
:
DISABLED
)
)
{
return
NS_OK
;
}
if
(
nsListControlFrame
*
lf
=
GetListControlFrame
(
)
)
{
lf
-
>
CaptureMouseEvents
(
false
)
;
}
const
bool
isLeftButton
=
mouseEvent
-
>
Button
(
)
=
=
0
;
if
(
!
isLeftButton
)
{
return
NS_OK
;
}
if
(
nsListControlFrame
*
lf
=
GetListControlFrame
(
)
)
{
return
lf
-
>
HandleLeftButtonMouseUp
(
aMouseEvent
)
;
}
return
NS_OK
;
}
nsresult
HTMLSelectEventListener
:
:
MouseMove
(
dom
:
:
Event
*
aMouseEvent
)
{
NS_ASSERTION
(
aMouseEvent
!
=
nullptr
"
aMouseEvent
is
null
.
"
)
;
MouseEvent
*
mouseEvent
=
aMouseEvent
-
>
AsMouseEvent
(
)
;
NS_ENSURE_TRUE
(
mouseEvent
NS_ERROR_FAILURE
)
;
if
(
!
mButtonDown
)
{
return
NS_OK
;
}
if
(
nsListControlFrame
*
lf
=
GetListControlFrame
(
)
)
{
return
lf
-
>
DragMove
(
aMouseEvent
)
;
}
return
NS_OK
;
}
nsresult
HTMLSelectEventListener
:
:
KeyPress
(
dom
:
:
Event
*
aKeyEvent
)
{
MOZ_ASSERT
(
aKeyEvent
"
aKeyEvent
is
null
.
"
)
;
if
(
mElement
-
>
State
(
)
.
HasState
(
ElementState
:
:
DISABLED
)
)
{
return
NS_OK
;
}
AutoIncrementalSearchHandler
incrementalHandler
(
*
this
)
;
const
WidgetKeyboardEvent
*
keyEvent
=
aKeyEvent
-
>
WidgetEventPtr
(
)
-
>
AsKeyboardEvent
(
)
;
MOZ_ASSERT
(
keyEvent
"
DOM
event
must
have
WidgetKeyboardEvent
for
its
internal
event
"
)
;
if
(
keyEvent
-
>
DefaultPrevented
(
)
)
{
return
NS_OK
;
}
if
(
keyEvent
-
>
IsAlt
(
)
)
{
return
NS_OK
;
}
if
(
keyEvent
-
>
mCharCode
!
=
'
'
)
{
mControlSelectMode
=
false
;
}
const
bool
isControlOrMeta
=
keyEvent
-
>
IsControl
(
)
#
if
!
defined
(
XP_WIN
)
&
&
!
defined
(
MOZ_WIDGET_GTK
)
|
|
keyEvent
-
>
IsMeta
(
)
#
endif
;
if
(
isControlOrMeta
&
&
keyEvent
-
>
mCharCode
!
=
'
'
)
{
return
NS_OK
;
}
if
(
!
keyEvent
-
>
mCharCode
)
{
if
(
keyEvent
-
>
mKeyCode
=
=
NS_VK_BACK
)
{
incrementalHandler
.
CancelResetting
(
)
;
if
(
!
GetIncrementalString
(
)
.
IsEmpty
(
)
)
{
GetIncrementalString
(
)
.
Truncate
(
GetIncrementalString
(
)
.
Length
(
)
-
1
)
;
}
aKeyEvent
-
>
PreventDefault
(
)
;
}
else
{
}
return
NS_OK
;
}
incrementalHandler
.
CancelResetting
(
)
;
aKeyEvent
-
>
PreventDefault
(
)
;
if
(
(
keyEvent
-
>
mTimeStamp
-
gLastKeyTime
)
.
ToMilliseconds
(
)
>
StaticPrefs
:
:
ui_menu_incremental_search_timeout
(
)
)
{
if
(
keyEvent
-
>
mCharCode
=
=
'
'
)
{
PostHandleKeyEvent
(
GetEndSelectionIndex
(
)
keyEvent
-
>
mCharCode
keyEvent
-
>
IsShift
(
)
isControlOrMeta
)
;
return
NS_OK
;
}
GetIncrementalString
(
)
.
Truncate
(
)
;
}
gLastKeyTime
=
keyEvent
-
>
mTimeStamp
;
char16_t
uniChar
=
ToLowerCase
(
static_cast
<
char16_t
>
(
keyEvent
-
>
mCharCode
)
)
;
GetIncrementalString
(
)
.
Append
(
uniChar
)
;
nsAutoString
incrementalString
(
GetIncrementalString
(
)
)
;
uint32_t
charIndex
=
1
stringLength
=
incrementalString
.
Length
(
)
;
while
(
charIndex
<
stringLength
&
&
incrementalString
[
charIndex
]
=
=
incrementalString
[
charIndex
-
1
]
)
{
charIndex
+
+
;
}
if
(
charIndex
=
=
stringLength
)
{
incrementalString
.
Truncate
(
1
)
;
stringLength
=
1
;
}
int32_t
startIndex
=
mElement
-
>
SelectedIndex
(
)
;
if
(
startIndex
=
=
kNothingSelected
)
{
startIndex
=
0
;
}
else
if
(
stringLength
=
=
1
)
{
startIndex
+
+
;
}
RefPtr
<
dom
:
:
HTMLOptionsCollection
>
options
=
mElement
-
>
Options
(
)
;
uint32_t
numOptions
=
options
-
>
Length
(
)
;
for
(
uint32_t
i
=
0
;
i
<
numOptions
;
+
+
i
)
{
uint32_t
index
=
(
i
+
startIndex
)
%
numOptions
;
RefPtr
<
dom
:
:
HTMLOptionElement
>
optionElement
=
options
-
>
ItemAsOption
(
index
)
;
if
(
!
optionElement
|
|
!
:
:
IsOptionInteractivelySelectable
(
*
mElement
*
optionElement
mIsCombobox
)
)
{
continue
;
}
nsAutoString
text
;
optionElement
-
>
GetRenderedLabel
(
text
)
;
if
(
!
StringBeginsWith
(
nsContentUtils
:
:
TrimWhitespace
<
nsContentUtils
:
:
IsHTMLWhitespaceOrNBSP
>
(
text
false
)
incrementalString
nsCaseInsensitiveStringComparator
)
)
{
continue
;
}
if
(
mIsCombobox
)
{
if
(
optionElement
-
>
Selected
(
)
)
{
return
NS_OK
;
}
optionElement
-
>
SetSelected
(
true
)
;
FireOnInputAndOnChange
(
)
;
return
NS_OK
;
}
if
(
nsListControlFrame
*
lf
=
GetListControlFrame
(
)
)
{
bool
wasChanged
=
lf
-
>
PerformSelection
(
index
keyEvent
-
>
IsShift
(
)
isControlOrMeta
)
;
if
(
!
wasChanged
)
{
return
NS_OK
;
}
FireOnInputAndOnChange
(
)
;
}
break
;
}
return
NS_OK
;
}
nsresult
HTMLSelectEventListener
:
:
KeyDown
(
dom
:
:
Event
*
aKeyEvent
)
{
MOZ_ASSERT
(
aKeyEvent
"
aKeyEvent
is
null
.
"
)
;
if
(
mElement
-
>
State
(
)
.
HasState
(
ElementState
:
:
DISABLED
)
)
{
return
NS_OK
;
}
AutoIncrementalSearchHandler
incrementalHandler
(
*
this
)
;
if
(
aKeyEvent
-
>
DefaultPrevented
(
)
)
{
return
NS_OK
;
}
const
WidgetKeyboardEvent
*
keyEvent
=
aKeyEvent
-
>
WidgetEventPtr
(
)
-
>
AsKeyboardEvent
(
)
;
MOZ_ASSERT
(
keyEvent
"
DOM
event
must
have
WidgetKeyboardEvent
for
its
internal
event
"
)
;
bool
dropDownMenuOnUpDown
;
bool
dropDownMenuOnSpace
;
#
ifdef
XP_MACOSX
dropDownMenuOnUpDown
=
mIsCombobox
&
&
!
mElement
-
>
OpenInParentProcess
(
)
;
dropDownMenuOnSpace
=
mIsCombobox
&
&
!
keyEvent
-
>
IsAlt
(
)
&
&
!
keyEvent
-
>
IsControl
(
)
&
&
!
keyEvent
-
>
IsMeta
(
)
;
#
else
dropDownMenuOnUpDown
=
mIsCombobox
&
&
keyEvent
-
>
IsAlt
(
)
;
dropDownMenuOnSpace
=
mIsCombobox
&
&
!
mElement
-
>
OpenInParentProcess
(
)
;
#
endif
bool
withinIncrementalSearchTime
=
(
keyEvent
-
>
mTimeStamp
-
gLastKeyTime
)
.
ToMilliseconds
(
)
<
=
StaticPrefs
:
:
ui_menu_incremental_search_timeout
(
)
;
if
(
(
dropDownMenuOnUpDown
&
&
(
keyEvent
-
>
mKeyCode
=
=
NS_VK_UP
|
|
keyEvent
-
>
mKeyCode
=
=
NS_VK_DOWN
)
)
|
|
(
dropDownMenuOnSpace
&
&
keyEvent
-
>
mKeyCode
=
=
NS_VK_SPACE
&
&
!
withinIncrementalSearchTime
)
)
{
FireDropDownEvent
(
mElement
!
mElement
-
>
OpenInParentProcess
(
)
false
)
;
aKeyEvent
-
>
PreventDefault
(
)
;
return
NS_OK
;
}
if
(
keyEvent
-
>
IsAlt
(
)
)
{
return
NS_OK
;
}
const
bool
shouldSelect
=
!
mIsCombobox
|
|
!
mElement
-
>
OpenInParentProcess
(
)
;
RefPtr
<
dom
:
:
HTMLOptionsCollection
>
options
=
mElement
-
>
Options
(
)
;
uint32_t
numOptions
=
options
-
>
Length
(
)
;
int32_t
newIndex
=
kNothingSelected
;
bool
isControlOrMeta
=
keyEvent
-
>
IsControl
(
)
#
if
!
defined
(
XP_WIN
)
&
&
!
defined
(
MOZ_WIDGET_GTK
)
|
|
keyEvent
-
>
IsMeta
(
)
#
endif
;
if
(
isControlOrMeta
&
&
!
mElement
-
>
Multiple
(
)
&
&
(
keyEvent
-
>
mKeyCode
=
=
NS_VK_PAGE_UP
|
|
keyEvent
-
>
mKeyCode
=
=
NS_VK_PAGE_DOWN
)
)
{
return
NS_OK
;
}
if
(
isControlOrMeta
&
&
(
keyEvent
-
>
mKeyCode
=
=
NS_VK_UP
|
|
keyEvent
-
>
mKeyCode
=
=
NS_VK_LEFT
|
|
keyEvent
-
>
mKeyCode
=
=
NS_VK_DOWN
|
|
keyEvent
-
>
mKeyCode
=
=
NS_VK_RIGHT
|
|
keyEvent
-
>
mKeyCode
=
=
NS_VK_HOME
|
|
keyEvent
-
>
mKeyCode
=
=
NS_VK_END
)
)
{
isControlOrMeta
=
mControlSelectMode
=
mElement
-
>
Multiple
(
)
;
}
else
if
(
keyEvent
-
>
mKeyCode
!
=
NS_VK_SPACE
)
{
mControlSelectMode
=
false
;
}
switch
(
keyEvent
-
>
mKeyCode
)
{
case
NS_VK_UP
:
case
NS_VK_LEFT
:
if
(
shouldSelect
)
{
AdjustIndexForDisabledOpt
(
GetEndSelectionIndex
(
)
newIndex
int32_t
(
numOptions
)
-
1
-
1
)
;
}
break
;
case
NS_VK_DOWN
:
case
NS_VK_RIGHT
:
if
(
shouldSelect
)
{
AdjustIndexForDisabledOpt
(
GetEndSelectionIndex
(
)
newIndex
int32_t
(
numOptions
)
1
1
)
;
}
break
;
case
NS_VK_RETURN
:
if
(
!
mElement
-
>
Multiple
(
)
)
{
return
NS_OK
;
}
newIndex
=
GetEndSelectionIndex
(
)
;
break
;
case
NS_VK_PAGE_UP
:
{
if
(
shouldSelect
)
{
AdjustIndexForDisabledOpt
(
GetEndSelectionIndex
(
)
newIndex
int32_t
(
numOptions
)
-
ItemsPerPage
(
)
-
1
)
;
}
break
;
}
case
NS_VK_PAGE_DOWN
:
{
if
(
shouldSelect
)
{
AdjustIndexForDisabledOpt
(
GetEndSelectionIndex
(
)
newIndex
int32_t
(
numOptions
)
ItemsPerPage
(
)
1
)
;
}
break
;
}
case
NS_VK_HOME
:
if
(
shouldSelect
)
{
AdjustIndexForDisabledOpt
(
0
newIndex
int32_t
(
numOptions
)
0
1
)
;
}
break
;
case
NS_VK_END
:
if
(
shouldSelect
)
{
AdjustIndexForDisabledOpt
(
int32_t
(
numOptions
)
-
1
newIndex
int32_t
(
numOptions
)
0
-
1
)
;
}
break
;
default
:
incrementalHandler
.
CancelResetting
(
)
;
return
NS_OK
;
}
aKeyEvent
-
>
PreventDefault
(
)
;
PostHandleKeyEvent
(
newIndex
0
keyEvent
-
>
IsShift
(
)
isControlOrMeta
)
;
return
NS_OK
;
}
HTMLOptionElement
*
HTMLSelectEventListener
:
:
GetCurrentOption
(
)
const
{
int32_t
endIndex
=
GetEndSelectionIndex
(
)
;
int32_t
focusedIndex
=
endIndex
=
=
kNothingSelected
?
mElement
-
>
SelectedIndex
(
)
:
endIndex
;
if
(
focusedIndex
!
=
kNothingSelected
)
{
return
mElement
-
>
Item
(
AssertedCast
<
uint32_t
>
(
focusedIndex
)
)
;
}
return
GetNonDisabledOptionFrom
(
0
)
;
}
HTMLOptionElement
*
HTMLSelectEventListener
:
:
GetNonDisabledOptionFrom
(
int32_t
aFromIndex
int32_t
*
aFoundIndex
)
const
{
const
uint32_t
length
=
mElement
-
>
Length
(
)
;
for
(
uint32_t
i
=
std
:
:
max
(
aFromIndex
0
)
;
i
<
length
;
+
+
i
)
{
if
(
IsOptionInteractivelySelectable
(
i
)
)
{
if
(
aFoundIndex
)
{
*
aFoundIndex
=
i
;
}
return
mElement
-
>
Item
(
i
)
;
}
}
return
nullptr
;
}
void
HTMLSelectEventListener
:
:
PostHandleKeyEvent
(
int32_t
aNewIndex
uint32_t
aCharCode
bool
aIsShift
bool
aIsControlOrMeta
)
{
if
(
aNewIndex
=
=
kNothingSelected
)
{
int32_t
endIndex
=
GetEndSelectionIndex
(
)
;
int32_t
focusedIndex
=
endIndex
=
=
kNothingSelected
?
mElement
-
>
SelectedIndex
(
)
:
endIndex
;
if
(
focusedIndex
!
=
kNothingSelected
)
{
return
;
}
if
(
!
GetNonDisabledOptionFrom
(
0
&
aNewIndex
)
)
{
return
;
}
}
if
(
mIsCombobox
)
{
RefPtr
<
HTMLOptionElement
>
newOption
=
mElement
-
>
Item
(
aNewIndex
)
;
MOZ_ASSERT
(
newOption
)
;
if
(
newOption
-
>
Selected
(
)
)
{
return
;
}
newOption
-
>
SetSelected
(
true
)
;
FireOnInputAndOnChange
(
)
;
return
;
}
if
(
nsListControlFrame
*
lf
=
GetListControlFrame
(
)
)
{
lf
-
>
UpdateSelectionAfterKeyEvent
(
aNewIndex
aCharCode
aIsShift
aIsControlOrMeta
mControlSelectMode
)
;
}
}
}
