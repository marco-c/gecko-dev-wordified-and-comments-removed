#
include
"
nsFormControlFrame
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsIDOMHTMLInputElement
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
nsDeviceContext
.
h
"
#
include
"
nsIContent
.
h
"
using
namespace
mozilla
;
nsFormControlFrame
:
:
nsFormControlFrame
(
nsStyleContext
*
aContext
)
:
nsFormControlFrameSuper
(
aContext
)
{
}
nsFormControlFrame
:
:
~
nsFormControlFrame
(
)
{
}
nsIAtom
*
nsFormControlFrame
:
:
GetType
(
)
const
{
return
nsGkAtoms
:
:
formControlFrame
;
}
void
nsFormControlFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestructRoot
)
{
nsFormControlFrame
:
:
RegUnRegAccessKey
(
static_cast
<
nsIFrame
*
>
(
this
)
false
)
;
nsFormControlFrameSuper
:
:
DestroyFrom
(
aDestructRoot
)
;
}
NS_QUERYFRAME_HEAD
(
nsFormControlFrame
)
NS_QUERYFRAME_ENTRY
(
nsIFormControlFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsFormControlFrameSuper
)
nscoord
nsFormControlFrame
:
:
GetMinISize
(
nsRenderingContext
*
aRenderingContext
)
{
nscoord
result
;
DISPLAY_MIN_WIDTH
(
this
result
)
;
result
=
GetIntrinsicISize
(
)
;
return
result
;
}
nscoord
nsFormControlFrame
:
:
GetPrefISize
(
nsRenderingContext
*
aRenderingContext
)
{
nscoord
result
;
DISPLAY_PREF_WIDTH
(
this
result
)
;
result
=
GetIntrinsicISize
(
)
;
return
result
;
}
LogicalSize
nsFormControlFrame
:
:
ComputeAutoSize
(
nsRenderingContext
*
aRenderingContext
WritingMode
aWM
const
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
LogicalSize
&
aMargin
const
LogicalSize
&
aBorder
const
LogicalSize
&
aPadding
bool
aShrinkWrap
)
{
const
WritingMode
wm
=
GetWritingMode
(
)
;
LogicalSize
result
(
wm
GetIntrinsicISize
(
)
GetIntrinsicBSize
(
)
)
;
return
result
.
ConvertTo
(
aWM
wm
)
;
}
nscoord
nsFormControlFrame
:
:
GetIntrinsicISize
(
)
{
return
nsPresContext
:
:
CSSPixelsToAppUnits
(
13
-
2
*
2
)
;
}
nscoord
nsFormControlFrame
:
:
GetIntrinsicBSize
(
)
{
return
nsPresContext
:
:
CSSPixelsToAppUnits
(
13
-
2
*
2
)
;
}
nscoord
nsFormControlFrame
:
:
GetLogicalBaseline
(
WritingMode
aWritingMode
)
const
{
NS_ASSERTION
(
!
NS_SUBTREE_DIRTY
(
this
)
"
frame
must
not
be
dirty
"
)
;
return
aWritingMode
.
IsLineInverted
(
)
?
GetLogicalUsedBorderAndPadding
(
aWritingMode
)
.
BStart
(
aWritingMode
)
:
BSize
(
aWritingMode
)
-
GetLogicalUsedBorderAndPadding
(
aWritingMode
)
.
BEnd
(
aWritingMode
)
;
}
void
nsFormControlFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
nsHTMLReflowMetrics
&
aDesiredSize
const
nsHTMLReflowState
&
aReflowState
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsFormControlFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowState
aDesiredSize
aStatus
)
;
NS_FRAME_TRACE
(
NS_FRAME_TRACE_CALLS
(
"
enter
nsFormControlFrame
:
:
Reflow
:
aMaxSize
=
%
d
%
d
"
aReflowState
.
AvailableWidth
(
)
aReflowState
.
AvailableHeight
(
)
)
)
;
if
(
mState
&
NS_FRAME_FIRST_REFLOW
)
{
RegUnRegAccessKey
(
static_cast
<
nsIFrame
*
>
(
this
)
true
)
;
}
aStatus
=
NS_FRAME_COMPLETE
;
aDesiredSize
.
SetSize
(
aReflowState
.
GetWritingMode
(
)
aReflowState
.
ComputedSizeWithBorderPadding
(
)
)
;
if
(
nsLayoutUtils
:
:
FontSizeInflationEnabled
(
aPresContext
)
)
{
float
inflation
=
nsLayoutUtils
:
:
FontSizeInflationFor
(
this
)
;
aDesiredSize
.
Width
(
)
*
=
inflation
;
aDesiredSize
.
Height
(
)
*
=
inflation
;
}
NS_FRAME_TRACE
(
NS_FRAME_TRACE_CALLS
(
"
exit
nsFormControlFrame
:
:
Reflow
:
size
=
%
d
%
d
"
aDesiredSize
.
Width
(
)
aDesiredSize
.
Height
(
)
)
)
;
NS_FRAME_SET_TRUNCATION
(
aStatus
aReflowState
aDesiredSize
)
;
aDesiredSize
.
SetOverflowAreasToDesiredBounds
(
)
;
FinishAndStoreOverflow
(
&
aDesiredSize
)
;
}
nsresult
nsFormControlFrame
:
:
RegUnRegAccessKey
(
nsIFrame
*
aFrame
bool
aDoReg
)
{
NS_ENSURE_ARG_POINTER
(
aFrame
)
;
nsPresContext
*
presContext
=
aFrame
-
>
PresContext
(
)
;
NS_ASSERTION
(
presContext
"
aPresContext
is
NULL
in
RegUnRegAccessKey
!
"
)
;
nsAutoString
accessKey
;
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
content
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
accesskey
accessKey
)
;
if
(
!
accessKey
.
IsEmpty
(
)
)
{
EventStateManager
*
stateManager
=
presContext
-
>
EventStateManager
(
)
;
if
(
aDoReg
)
{
stateManager
-
>
RegisterAccessKey
(
content
(
uint32_t
)
accessKey
.
First
(
)
)
;
}
else
{
stateManager
-
>
UnregisterAccessKey
(
content
(
uint32_t
)
accessKey
.
First
(
)
)
;
}
return
NS_OK
;
}
return
NS_ERROR_FAILURE
;
}
void
nsFormControlFrame
:
:
SetFocus
(
bool
aOn
bool
aRepaint
)
{
}
nsresult
nsFormControlFrame
:
:
HandleEvent
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
{
const
nsStyleUserInterface
*
uiStyle
=
StyleUserInterface
(
)
;
if
(
uiStyle
-
>
mUserInput
=
=
NS_STYLE_USER_INPUT_NONE
|
|
uiStyle
-
>
mUserInput
=
=
NS_STYLE_USER_INPUT_DISABLED
)
return
nsFrame
:
:
HandleEvent
(
aPresContext
aEvent
aEventStatus
)
;
return
NS_OK
;
}
void
nsFormControlFrame
:
:
GetCurrentCheckState
(
bool
*
aState
)
{
nsCOMPtr
<
nsIDOMHTMLInputElement
>
inputElement
=
do_QueryInterface
(
mContent
)
;
if
(
inputElement
)
{
inputElement
-
>
GetChecked
(
aState
)
;
}
}
nsresult
nsFormControlFrame
:
:
SetFormProperty
(
nsIAtom
*
aName
const
nsAString
&
aValue
)
{
return
NS_OK
;
}
nsRect
nsFormControlFrame
:
:
GetUsableScreenRect
(
nsPresContext
*
aPresContext
)
{
nsRect
screen
;
nsDeviceContext
*
context
=
aPresContext
-
>
DeviceContext
(
)
;
int32_t
dropdownCanOverlapOSBar
=
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
eIntID_MenusCanOverlapOSBar
0
)
;
if
(
dropdownCanOverlapOSBar
)
context
-
>
GetRect
(
screen
)
;
else
context
-
>
GetClientRect
(
screen
)
;
return
screen
;
}
