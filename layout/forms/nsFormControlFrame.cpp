#
include
"
nsFormControlFrame
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsLayoutUtils
.
h
"
#
include
"
nsIDOMHTMLInputElement
.
h
"
#
include
"
mozilla
/
EventStateManager
.
h
"
#
include
"
mozilla
/
LookAndFeel
.
h
"
#
include
"
nsDeviceContext
.
h
"
#
include
"
nsIContent
.
h
"
using
namespace
mozilla
;
nsFormControlFrame
:
:
nsFormControlFrame
(
nsStyleContext
*
aContext
)
:
nsAtomicContainerFrame
(
aContext
LayoutFrameType
:
:
FormControl
)
{
}
nsFormControlFrame
:
:
~
nsFormControlFrame
(
)
{
}
void
nsFormControlFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestructRoot
)
{
nsFormControlFrame
:
:
RegUnRegAccessKey
(
static_cast
<
nsIFrame
*
>
(
this
)
false
)
;
nsAtomicContainerFrame
:
:
DestroyFrom
(
aDestructRoot
)
;
}
NS_QUERYFRAME_HEAD
(
nsFormControlFrame
)
NS_QUERYFRAME_ENTRY
(
nsIFormControlFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsAtomicContainerFrame
)
nscoord
nsFormControlFrame
:
:
GetMinISize
(
nsRenderingContext
*
aRenderingContext
)
{
nscoord
result
;
DISPLAY_MIN_WIDTH
(
this
result
)
;
#
if
!
defined
(
MOZ_WIDGET_ANDROID
)
result
=
StyleDisplay
(
)
-
>
mAppearance
=
=
NS_THEME_NONE
?
0
:
DefaultSize
(
)
;
#
else
result
=
DefaultSize
(
)
;
#
endif
return
result
;
}
nscoord
nsFormControlFrame
:
:
GetPrefISize
(
nsRenderingContext
*
aRenderingContext
)
{
nscoord
result
;
DISPLAY_PREF_WIDTH
(
this
result
)
;
#
if
!
defined
(
MOZ_WIDGET_ANDROID
)
result
=
StyleDisplay
(
)
-
>
mAppearance
=
=
NS_THEME_NONE
?
0
:
DefaultSize
(
)
;
#
else
result
=
DefaultSize
(
)
;
#
endif
return
result
;
}
LogicalSize
nsFormControlFrame
:
:
ComputeAutoSize
(
nsRenderingContext
*
aRC
WritingMode
aWM
const
LogicalSize
&
aCBSize
nscoord
aAvailableISize
const
LogicalSize
&
aMargin
const
LogicalSize
&
aBorder
const
LogicalSize
&
aPadding
ComputeSizeFlags
aFlags
)
{
LogicalSize
size
(
aWM
0
0
)
;
#
if
!
defined
(
MOZ_WIDGET_ANDROID
)
if
(
StyleDisplay
(
)
-
>
mAppearance
=
=
NS_THEME_NONE
)
{
return
size
;
}
#
endif
size
=
nsAtomicContainerFrame
:
:
ComputeAutoSize
(
aRC
aWM
aCBSize
aAvailableISize
aMargin
aBorder
aPadding
aFlags
)
;
size
.
BSize
(
aWM
)
=
DefaultSize
(
)
;
return
size
;
}
nscoord
nsFormControlFrame
:
:
GetLogicalBaseline
(
WritingMode
aWritingMode
)
const
{
NS_ASSERTION
(
!
NS_SUBTREE_DIRTY
(
this
)
"
frame
must
not
be
dirty
"
)
;
#
if
!
defined
(
MOZ_WIDGET_ANDROID
)
if
(
StyleDisplay
(
)
-
>
mAppearance
=
=
NS_THEME_NONE
)
{
return
nsAtomicContainerFrame
:
:
GetLogicalBaseline
(
aWritingMode
)
;
}
#
endif
return
aWritingMode
.
IsLineInverted
(
)
?
GetLogicalUsedBorderAndPadding
(
aWritingMode
)
.
BStart
(
aWritingMode
)
:
BSize
(
aWritingMode
)
-
GetLogicalUsedBorderAndPadding
(
aWritingMode
)
.
BEnd
(
aWritingMode
)
;
}
void
nsFormControlFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsFormControlFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aDesiredSize
aStatus
)
;
NS_FRAME_TRACE
(
NS_FRAME_TRACE_CALLS
(
"
enter
nsFormControlFrame
:
:
Reflow
:
aMaxSize
=
%
d
%
d
"
aReflowInput
.
AvailableWidth
(
)
aReflowInput
.
AvailableHeight
(
)
)
)
;
if
(
mState
&
NS_FRAME_FIRST_REFLOW
)
{
RegUnRegAccessKey
(
static_cast
<
nsIFrame
*
>
(
this
)
true
)
;
}
aStatus
.
Reset
(
)
;
aDesiredSize
.
SetSize
(
aReflowInput
.
GetWritingMode
(
)
aReflowInput
.
ComputedSizeWithBorderPadding
(
)
)
;
if
(
nsLayoutUtils
:
:
FontSizeInflationEnabled
(
aPresContext
)
)
{
float
inflation
=
nsLayoutUtils
:
:
FontSizeInflationFor
(
this
)
;
aDesiredSize
.
Width
(
)
*
=
inflation
;
aDesiredSize
.
Height
(
)
*
=
inflation
;
}
NS_FRAME_TRACE
(
NS_FRAME_TRACE_CALLS
(
"
exit
nsFormControlFrame
:
:
Reflow
:
size
=
%
d
%
d
"
aDesiredSize
.
Width
(
)
aDesiredSize
.
Height
(
)
)
)
;
NS_FRAME_SET_TRUNCATION
(
aStatus
aReflowInput
aDesiredSize
)
;
aDesiredSize
.
SetOverflowAreasToDesiredBounds
(
)
;
FinishAndStoreOverflow
(
&
aDesiredSize
)
;
}
nsresult
nsFormControlFrame
:
:
RegUnRegAccessKey
(
nsIFrame
*
aFrame
bool
aDoReg
)
{
NS_ENSURE_ARG_POINTER
(
aFrame
)
;
nsPresContext
*
presContext
=
aFrame
-
>
PresContext
(
)
;
NS_ASSERTION
(
presContext
"
aPresContext
is
NULL
in
RegUnRegAccessKey
!
"
)
;
nsAutoString
accessKey
;
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
content
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
accesskey
accessKey
)
;
if
(
!
accessKey
.
IsEmpty
(
)
)
{
EventStateManager
*
stateManager
=
presContext
-
>
EventStateManager
(
)
;
if
(
aDoReg
)
{
stateManager
-
>
RegisterAccessKey
(
content
(
uint32_t
)
accessKey
.
First
(
)
)
;
}
else
{
stateManager
-
>
UnregisterAccessKey
(
content
(
uint32_t
)
accessKey
.
First
(
)
)
;
}
return
NS_OK
;
}
return
NS_ERROR_FAILURE
;
}
void
nsFormControlFrame
:
:
SetFocus
(
bool
aOn
bool
aRepaint
)
{
}
nsresult
nsFormControlFrame
:
:
HandleEvent
(
nsPresContext
*
aPresContext
WidgetGUIEvent
*
aEvent
nsEventStatus
*
aEventStatus
)
{
const
nsStyleUserInterface
*
uiStyle
=
StyleUserInterface
(
)
;
if
(
uiStyle
-
>
mUserInput
=
=
StyleUserInput
:
:
None
|
|
uiStyle
-
>
mUserInput
=
=
StyleUserInput
:
:
Disabled
)
{
return
nsFrame
:
:
HandleEvent
(
aPresContext
aEvent
aEventStatus
)
;
}
return
NS_OK
;
}
void
nsFormControlFrame
:
:
GetCurrentCheckState
(
bool
*
aState
)
{
nsCOMPtr
<
nsIDOMHTMLInputElement
>
inputElement
=
do_QueryInterface
(
mContent
)
;
if
(
inputElement
)
{
inputElement
-
>
GetChecked
(
aState
)
;
}
}
nsresult
nsFormControlFrame
:
:
SetFormProperty
(
nsIAtom
*
aName
const
nsAString
&
aValue
)
{
return
NS_OK
;
}
nsRect
nsFormControlFrame
:
:
GetUsableScreenRect
(
nsPresContext
*
aPresContext
)
{
nsRect
screen
;
nsDeviceContext
*
context
=
aPresContext
-
>
DeviceContext
(
)
;
int32_t
dropdownCanOverlapOSBar
=
LookAndFeel
:
:
GetInt
(
LookAndFeel
:
:
eIntID_MenusCanOverlapOSBar
0
)
;
if
(
dropdownCanOverlapOSBar
)
context
-
>
GetRect
(
screen
)
;
else
context
-
>
GetClientRect
(
screen
)
;
return
screen
;
}
