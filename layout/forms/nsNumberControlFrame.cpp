#
include
"
nsNumberControlFrame
.
h
"
#
include
"
HTMLInputElement
.
h
"
#
include
"
ICUUtils
.
h
"
#
include
"
nsIFocusManager
.
h
"
#
include
"
nsIPresShell
.
h
"
#
include
"
nsFocusManager
.
h
"
#
include
"
nsFontMetrics
.
h
"
#
include
"
nsCheckboxRadioFrame
.
h
"
#
include
"
nsGkAtoms
.
h
"
#
include
"
nsNameSpaceManager
.
h
"
#
include
"
nsStyleConsts
.
h
"
#
include
"
mozilla
/
BasicEvents
.
h
"
#
include
"
mozilla
/
EventStates
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsContentCreatorFunctions
.
h
"
#
include
"
nsCSSPseudoElements
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
mozilla
/
FloatingPoint
.
h
"
#
include
"
mozilla
/
dom
/
MutationEventBinding
.
h
"
#
ifdef
ACCESSIBILITY
#
include
"
mozilla
/
a11y
/
AccTypes
.
h
"
#
endif
using
namespace
mozilla
;
using
namespace
mozilla
:
:
dom
;
nsIFrame
*
NS_NewNumberControlFrame
(
nsIPresShell
*
aPresShell
ComputedStyle
*
aStyle
)
{
return
new
(
aPresShell
)
nsNumberControlFrame
(
aStyle
aPresShell
-
>
GetPresContext
(
)
)
;
}
NS_IMPL_FRAMEARENA_HELPERS
(
nsNumberControlFrame
)
NS_QUERYFRAME_HEAD
(
nsNumberControlFrame
)
NS_QUERYFRAME_ENTRY
(
nsNumberControlFrame
)
NS_QUERYFRAME_ENTRY
(
nsIAnonymousContentCreator
)
NS_QUERYFRAME_ENTRY
(
nsIFormControlFrame
)
NS_QUERYFRAME_TAIL_INHERITING
(
nsContainerFrame
)
nsNumberControlFrame
:
:
nsNumberControlFrame
(
ComputedStyle
*
aStyle
nsPresContext
*
aPresContext
)
:
nsContainerFrame
(
aStyle
aPresContext
kClassID
)
mHandlingInputEvent
(
false
)
{
}
void
nsNumberControlFrame
:
:
DestroyFrom
(
nsIFrame
*
aDestructRoot
PostDestroyData
&
aPostDestroyData
)
{
NS_ASSERTION
(
!
GetPrevContinuation
(
)
&
&
!
GetNextContinuation
(
)
"
nsNumberControlFrame
should
not
have
continuations
;
if
it
does
we
"
"
need
to
call
RegUnregAccessKey
only
for
the
first
"
)
;
nsCheckboxRadioFrame
:
:
RegUnRegAccessKey
(
static_cast
<
nsIFrame
*
>
(
this
)
false
)
;
aPostDestroyData
.
AddAnonymousContent
(
mOuterWrapper
.
forget
(
)
)
;
nsContainerFrame
:
:
DestroyFrom
(
aDestructRoot
aPostDestroyData
)
;
}
nscoord
nsNumberControlFrame
:
:
GetMinISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
result
;
DISPLAY_MIN_INLINE_SIZE
(
this
result
)
;
nsIFrame
*
kid
=
mFrames
.
FirstChild
(
)
;
if
(
kid
)
{
result
=
nsLayoutUtils
:
:
IntrinsicForContainer
(
aRenderingContext
kid
nsLayoutUtils
:
:
MIN_ISIZE
)
;
}
else
{
result
=
0
;
}
return
result
;
}
nscoord
nsNumberControlFrame
:
:
GetPrefISize
(
gfxContext
*
aRenderingContext
)
{
nscoord
result
;
DISPLAY_PREF_INLINE_SIZE
(
this
result
)
;
nsIFrame
*
kid
=
mFrames
.
FirstChild
(
)
;
if
(
kid
)
{
result
=
nsLayoutUtils
:
:
IntrinsicForContainer
(
aRenderingContext
kid
nsLayoutUtils
:
:
PREF_ISIZE
)
;
}
else
{
result
=
0
;
}
return
result
;
}
void
nsNumberControlFrame
:
:
Reflow
(
nsPresContext
*
aPresContext
ReflowOutput
&
aDesiredSize
const
ReflowInput
&
aReflowInput
nsReflowStatus
&
aStatus
)
{
MarkInReflow
(
)
;
DO_GLOBAL_REFLOW_COUNT
(
"
nsNumberControlFrame
"
)
;
DISPLAY_REFLOW
(
aPresContext
this
aReflowInput
aDesiredSize
aStatus
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
Caller
should
pass
a
fresh
reflow
status
!
"
)
;
NS_ASSERTION
(
mOuterWrapper
"
Outer
wrapper
div
must
exist
!
"
)
;
NS_ASSERTION
(
!
GetPrevContinuation
(
)
&
&
!
GetNextContinuation
(
)
"
nsNumberControlFrame
should
not
have
continuations
;
if
it
does
we
"
"
need
to
call
RegUnregAccessKey
only
for
the
first
"
)
;
NS_ASSERTION
(
!
mFrames
.
FirstChild
(
)
|
|
!
mFrames
.
FirstChild
(
)
-
>
GetNextSibling
(
)
"
We
expect
at
most
one
direct
child
frame
"
)
;
if
(
mState
&
NS_FRAME_FIRST_REFLOW
)
{
nsCheckboxRadioFrame
:
:
RegUnRegAccessKey
(
this
true
)
;
}
const
WritingMode
myWM
=
aReflowInput
.
GetWritingMode
(
)
;
const
nscoord
contentBoxISize
=
aReflowInput
.
ComputedISize
(
)
;
nscoord
contentBoxBSize
=
aReflowInput
.
ComputedBSize
(
)
;
const
nscoord
borderBoxISize
=
contentBoxISize
+
aReflowInput
.
ComputedLogicalBorderPadding
(
)
.
IStartEnd
(
myWM
)
;
nscoord
borderBoxBSize
;
if
(
contentBoxBSize
!
=
NS_INTRINSICSIZE
)
{
borderBoxBSize
=
contentBoxBSize
+
aReflowInput
.
ComputedLogicalBorderPadding
(
)
.
BStartEnd
(
myWM
)
;
}
nsIFrame
*
outerWrapperFrame
=
mOuterWrapper
-
>
GetPrimaryFrame
(
)
;
if
(
!
outerWrapperFrame
)
{
if
(
contentBoxBSize
=
=
NS_INTRINSICSIZE
)
{
contentBoxBSize
=
0
;
borderBoxBSize
=
aReflowInput
.
ComputedLogicalBorderPadding
(
)
.
BStartEnd
(
myWM
)
;
}
}
else
{
NS_ASSERTION
(
outerWrapperFrame
=
=
mFrames
.
FirstChild
(
)
"
huh
?
"
)
;
ReflowOutput
wrappersDesiredSize
(
aReflowInput
)
;
WritingMode
wrapperWM
=
outerWrapperFrame
-
>
GetWritingMode
(
)
;
LogicalSize
availSize
=
aReflowInput
.
ComputedSize
(
wrapperWM
)
;
availSize
.
BSize
(
wrapperWM
)
=
NS_UNCONSTRAINEDSIZE
;
ReflowInput
wrapperReflowInput
(
aPresContext
aReflowInput
outerWrapperFrame
availSize
)
;
LogicalMargin
wrapperMargin
=
wrapperReflowInput
.
ComputedLogicalMargin
(
)
.
ConvertTo
(
myWM
wrapperWM
)
;
LogicalPoint
wrapperOffset
(
myWM
aReflowInput
.
ComputedLogicalBorderPadding
(
)
.
IStart
(
myWM
)
+
wrapperMargin
.
IStart
(
myWM
)
aReflowInput
.
ComputedLogicalBorderPadding
(
)
.
BStart
(
myWM
)
+
wrapperMargin
.
BStart
(
myWM
)
)
;
nsReflowStatus
childStatus
;
const
nsSize
dummyContainerSize
;
ReflowChild
(
outerWrapperFrame
aPresContext
wrappersDesiredSize
wrapperReflowInput
myWM
wrapperOffset
dummyContainerSize
0
childStatus
)
;
MOZ_ASSERT
(
childStatus
.
IsFullyComplete
(
)
"
We
gave
our
child
unconstrained
available
block
-
size
"
"
so
it
should
be
complete
"
)
;
nscoord
wrappersMarginBoxBSize
=
wrappersDesiredSize
.
BSize
(
myWM
)
+
wrapperMargin
.
BStartEnd
(
myWM
)
;
if
(
contentBoxBSize
=
=
NS_INTRINSICSIZE
)
{
contentBoxBSize
=
wrappersMarginBoxBSize
;
contentBoxBSize
=
NS_CSS_MINMAX
(
contentBoxBSize
aReflowInput
.
ComputedMinBSize
(
)
aReflowInput
.
ComputedMaxBSize
(
)
)
;
borderBoxBSize
=
contentBoxBSize
+
aReflowInput
.
ComputedLogicalBorderPadding
(
)
.
BStartEnd
(
myWM
)
;
}
nscoord
extraSpace
=
contentBoxBSize
-
wrappersMarginBoxBSize
;
wrapperOffset
.
B
(
myWM
)
+
=
std
:
:
max
(
0
extraSpace
/
2
)
;
nsSize
borderBoxSize
=
LogicalSize
(
myWM
borderBoxISize
borderBoxBSize
)
.
GetPhysicalSize
(
myWM
)
;
FinishReflowChild
(
outerWrapperFrame
aPresContext
wrappersDesiredSize
&
wrapperReflowInput
myWM
wrapperOffset
borderBoxSize
0
)
;
nsSize
contentBoxSize
=
LogicalSize
(
myWM
contentBoxISize
contentBoxBSize
)
.
GetPhysicalSize
(
myWM
)
;
aDesiredSize
.
SetBlockStartAscent
(
wrappersDesiredSize
.
BlockStartAscent
(
)
+
outerWrapperFrame
-
>
BStart
(
aReflowInput
.
GetWritingMode
(
)
contentBoxSize
)
)
;
}
LogicalSize
logicalDesiredSize
(
myWM
borderBoxISize
borderBoxBSize
)
;
aDesiredSize
.
SetSize
(
myWM
logicalDesiredSize
)
;
aDesiredSize
.
SetOverflowAreasToDesiredBounds
(
)
;
if
(
outerWrapperFrame
)
{
ConsiderChildOverflow
(
aDesiredSize
.
mOverflowAreas
outerWrapperFrame
)
;
}
FinishAndStoreOverflow
(
&
aDesiredSize
)
;
MOZ_ASSERT
(
aStatus
.
IsEmpty
(
)
"
This
type
of
frame
can
'
t
be
split
.
"
)
;
NS_FRAME_SET_TRUNCATION
(
aStatus
aReflowInput
aDesiredSize
)
;
}
void
nsNumberControlFrame
:
:
SyncDisabledState
(
)
{
EventStates
eventStates
=
mContent
-
>
AsElement
(
)
-
>
State
(
)
;
if
(
eventStates
.
HasState
(
NS_EVENT_STATE_DISABLED
)
)
{
mTextField
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
disabled
EmptyString
(
)
true
)
;
}
else
{
mTextField
-
>
UnsetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
disabled
true
)
;
}
}
nsresult
nsNumberControlFrame
:
:
AttributeChanged
(
int32_t
aNameSpaceID
nsAtom
*
aAttribute
int32_t
aModType
)
{
if
(
aNameSpaceID
=
=
kNameSpaceID_None
)
{
if
(
aAttribute
=
=
nsGkAtoms
:
:
placeholder
|
|
aAttribute
=
=
nsGkAtoms
:
:
readonly
|
|
aAttribute
=
=
nsGkAtoms
:
:
tabindex
)
{
if
(
aModType
=
=
MutationEvent_Binding
:
:
REMOVAL
)
{
mTextField
-
>
UnsetAttr
(
aNameSpaceID
aAttribute
true
)
;
}
else
{
MOZ_ASSERT
(
aModType
=
=
MutationEvent_Binding
:
:
ADDITION
|
|
aModType
=
=
MutationEvent_Binding
:
:
MODIFICATION
)
;
nsAutoString
value
;
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
aNameSpaceID
aAttribute
value
)
;
mTextField
-
>
SetAttr
(
aNameSpaceID
aAttribute
value
true
)
;
}
}
}
return
nsContainerFrame
:
:
AttributeChanged
(
aNameSpaceID
aAttribute
aModType
)
;
}
void
nsNumberControlFrame
:
:
ContentStatesChanged
(
EventStates
aStates
)
{
if
(
aStates
.
HasState
(
NS_EVENT_STATE_DISABLED
)
)
{
nsContentUtils
:
:
AddScriptRunner
(
new
SyncDisabledStateEvent
(
this
)
)
;
}
}
nsITextControlFrame
*
nsNumberControlFrame
:
:
GetTextFieldFrame
(
)
{
return
do_QueryFrame
(
GetAnonTextControl
(
)
-
>
GetPrimaryFrame
(
)
)
;
}
class
FocusTextField
:
public
Runnable
{
public
:
FocusTextField
(
nsIContent
*
aNumber
nsIContent
*
aTextField
)
:
mozilla
:
:
Runnable
(
"
FocusTextField
"
)
mNumber
(
aNumber
)
mTextField
(
aTextField
)
{
}
NS_IMETHOD
Run
(
)
override
{
if
(
mNumber
-
>
AsElement
(
)
-
>
State
(
)
.
HasState
(
NS_EVENT_STATE_FOCUS
)
)
{
HTMLInputElement
:
:
FromNode
(
mTextField
)
-
>
Focus
(
IgnoreErrors
(
)
)
;
}
return
NS_OK
;
}
private
:
nsCOMPtr
<
nsIContent
>
mNumber
;
nsCOMPtr
<
nsIContent
>
mTextField
;
}
;
already_AddRefed
<
Element
>
nsNumberControlFrame
:
:
MakeAnonymousElement
(
Element
*
aParent
nsAtom
*
aTagName
PseudoStyleType
aPseudoType
)
{
Document
*
doc
=
mContent
-
>
GetComposedDoc
(
)
;
RefPtr
<
Element
>
resultElement
=
doc
-
>
CreateHTMLElement
(
aTagName
)
;
resultElement
-
>
SetPseudoElementType
(
aPseudoType
)
;
if
(
aPseudoType
=
=
PseudoStyleType
:
:
mozNumberSpinDown
|
|
aPseudoType
=
=
PseudoStyleType
:
:
mozNumberSpinUp
)
{
resultElement
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
role
NS_LITERAL_STRING
(
"
button
"
)
false
)
;
}
if
(
aParent
)
{
aParent
-
>
AppendChildTo
(
resultElement
false
)
;
}
return
resultElement
.
forget
(
)
;
}
nsresult
nsNumberControlFrame
:
:
CreateAnonymousContent
(
nsTArray
<
ContentInfo
>
&
aElements
)
{
mOuterWrapper
=
MakeAnonymousElement
(
nullptr
nsGkAtoms
:
:
div
PseudoStyleType
:
:
mozNumberWrapper
)
;
aElements
.
AppendElement
(
mOuterWrapper
)
;
mTextField
=
MakeAnonymousElement
(
mOuterWrapper
nsGkAtoms
:
:
input
PseudoStyleType
:
:
mozNumberText
)
;
mTextField
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
type
NS_LITERAL_STRING
(
"
text
"
)
false
)
;
HTMLInputElement
*
content
=
HTMLInputElement
:
:
FromNode
(
mContent
)
;
HTMLInputElement
*
textField
=
HTMLInputElement
:
:
FromNode
(
mTextField
)
;
nsAutoString
value
;
content
-
>
GetValue
(
value
CallerType
:
:
System
)
;
SetValueOfAnonTextControl
(
value
)
;
nsAutoString
readonly
;
if
(
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
readonly
readonly
)
)
{
mTextField
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
readonly
readonly
false
)
;
}
textField
-
>
SetTabIndex
(
content
-
>
TabIndex
(
)
IgnoreErrors
(
)
)
;
nsAutoString
placeholder
;
if
(
mContent
-
>
AsElement
(
)
-
>
GetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
placeholder
placeholder
)
)
{
mTextField
-
>
SetAttr
(
kNameSpaceID_None
nsGkAtoms
:
:
placeholder
placeholder
false
)
;
}
if
(
mContent
-
>
AsElement
(
)
-
>
State
(
)
.
HasState
(
NS_EVENT_STATE_FOCUS
)
)
{
RefPtr
<
FocusTextField
>
focusJob
=
new
FocusTextField
(
mContent
mTextField
)
;
nsContentUtils
:
:
AddScriptRunner
(
focusJob
)
;
}
SyncDisabledState
(
)
;
if
(
StyleDisplay
(
)
-
>
mAppearance
=
=
StyleAppearance
:
:
Textfield
)
{
return
NS_OK
;
}
mSpinBox
=
MakeAnonymousElement
(
mOuterWrapper
nsGkAtoms
:
:
div
PseudoStyleType
:
:
mozNumberSpinBox
)
;
mSpinUp
=
MakeAnonymousElement
(
mSpinBox
nsGkAtoms
:
:
div
PseudoStyleType
:
:
mozNumberSpinUp
)
;
mSpinDown
=
MakeAnonymousElement
(
mSpinBox
nsGkAtoms
:
:
div
PseudoStyleType
:
:
mozNumberSpinDown
)
;
return
NS_OK
;
}
void
nsNumberControlFrame
:
:
SetFocus
(
bool
aOn
bool
aRepaint
)
{
GetTextFieldFrame
(
)
-
>
SetFocus
(
aOn
aRepaint
)
;
}
nsresult
nsNumberControlFrame
:
:
SetFormProperty
(
nsAtom
*
aName
const
nsAString
&
aValue
)
{
return
GetTextFieldFrame
(
)
-
>
SetFormProperty
(
aName
aValue
)
;
}
HTMLInputElement
*
nsNumberControlFrame
:
:
GetAnonTextControl
(
)
{
return
HTMLInputElement
:
:
FromNode
(
mTextField
)
;
}
nsNumberControlFrame
*
nsNumberControlFrame
:
:
GetNumberControlFrameForTextField
(
nsIFrame
*
aFrame
)
{
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
content
-
>
IsInNativeAnonymousSubtree
(
)
&
&
content
-
>
GetParent
(
)
&
&
content
-
>
GetParent
(
)
-
>
GetParent
(
)
)
{
nsIContent
*
grandparent
=
content
-
>
GetParent
(
)
-
>
GetParent
(
)
;
if
(
grandparent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
input
)
&
&
grandparent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
type
nsGkAtoms
:
:
number
eCaseMatters
)
)
{
return
do_QueryFrame
(
grandparent
-
>
GetPrimaryFrame
(
)
)
;
}
}
return
nullptr
;
}
nsNumberControlFrame
*
nsNumberControlFrame
:
:
GetNumberControlFrameForSpinButton
(
nsIFrame
*
aFrame
)
{
nsIContent
*
content
=
aFrame
-
>
GetContent
(
)
;
if
(
content
-
>
IsInNativeAnonymousSubtree
(
)
&
&
content
-
>
GetParent
(
)
&
&
content
-
>
GetParent
(
)
-
>
GetParent
(
)
&
&
content
-
>
GetParent
(
)
-
>
GetParent
(
)
-
>
GetParent
(
)
)
{
nsIContent
*
greatgrandparent
=
content
-
>
GetParent
(
)
-
>
GetParent
(
)
-
>
GetParent
(
)
;
if
(
greatgrandparent
-
>
IsHTMLElement
(
nsGkAtoms
:
:
input
)
&
&
greatgrandparent
-
>
AsElement
(
)
-
>
AttrValueIs
(
kNameSpaceID_None
nsGkAtoms
:
:
type
nsGkAtoms
:
:
number
eCaseMatters
)
)
{
return
do_QueryFrame
(
greatgrandparent
-
>
GetPrimaryFrame
(
)
)
;
}
}
return
nullptr
;
}
int32_t
nsNumberControlFrame
:
:
GetSpinButtonForPointerEvent
(
WidgetGUIEvent
*
aEvent
)
const
{
MOZ_ASSERT
(
aEvent
-
>
mClass
=
=
eMouseEventClass
"
Unexpected
event
type
"
)
;
if
(
!
mSpinBox
)
{
return
eSpinButtonNone
;
}
if
(
aEvent
-
>
mOriginalTarget
=
=
mSpinUp
)
{
return
eSpinButtonUp
;
}
if
(
aEvent
-
>
mOriginalTarget
=
=
mSpinDown
)
{
return
eSpinButtonDown
;
}
if
(
aEvent
-
>
mOriginalTarget
=
=
mSpinBox
)
{
LayoutDeviceIntPoint
absPoint
=
aEvent
-
>
mRefPoint
;
nsPoint
point
=
nsLayoutUtils
:
:
GetEventCoordinatesRelativeTo
(
aEvent
absPoint
mSpinBox
-
>
GetPrimaryFrame
(
)
)
;
if
(
point
!
=
nsPoint
(
NS_UNCONSTRAINEDSIZE
NS_UNCONSTRAINEDSIZE
)
)
{
if
(
point
.
y
<
mSpinBox
-
>
GetPrimaryFrame
(
)
-
>
GetSize
(
)
.
height
/
2
)
{
return
eSpinButtonUp
;
}
return
eSpinButtonDown
;
}
}
return
eSpinButtonNone
;
}
void
nsNumberControlFrame
:
:
SpinnerStateChanged
(
)
const
{
MOZ_ASSERT
(
mSpinUp
&
&
mSpinDown
"
We
should
not
be
called
when
we
have
no
spinner
"
)
;
nsIFrame
*
spinUpFrame
=
mSpinUp
-
>
GetPrimaryFrame
(
)
;
if
(
spinUpFrame
&
&
spinUpFrame
-
>
IsThemed
(
)
)
{
spinUpFrame
-
>
InvalidateFrame
(
)
;
}
nsIFrame
*
spinDownFrame
=
mSpinDown
-
>
GetPrimaryFrame
(
)
;
if
(
spinDownFrame
&
&
spinDownFrame
-
>
IsThemed
(
)
)
{
spinDownFrame
-
>
InvalidateFrame
(
)
;
}
}
bool
nsNumberControlFrame
:
:
SpinnerUpButtonIsDepressed
(
)
const
{
return
HTMLInputElement
:
:
FromNode
(
mContent
)
-
>
NumberSpinnerUpButtonIsDepressed
(
)
;
}
bool
nsNumberControlFrame
:
:
SpinnerDownButtonIsDepressed
(
)
const
{
return
HTMLInputElement
:
:
FromNode
(
mContent
)
-
>
NumberSpinnerDownButtonIsDepressed
(
)
;
}
bool
nsNumberControlFrame
:
:
IsFocused
(
)
const
{
return
mTextField
-
>
State
(
)
.
HasState
(
NS_EVENT_STATE_FOCUS
)
|
|
mContent
-
>
AsElement
(
)
-
>
State
(
)
.
HasState
(
NS_EVENT_STATE_FOCUS
)
;
}
void
nsNumberControlFrame
:
:
HandleFocusEvent
(
WidgetEvent
*
aEvent
)
{
if
(
aEvent
-
>
mOriginalTarget
!
=
mTextField
)
{
RefPtr
<
HTMLInputElement
>
textField
=
HTMLInputElement
:
:
FromNode
(
mTextField
)
;
textField
-
>
Focus
(
IgnoreErrors
(
)
)
;
}
}
void
nsNumberControlFrame
:
:
HandleSelectCall
(
)
{
RefPtr
<
HTMLInputElement
>
textField
=
HTMLInputElement
:
:
FromNode
(
mTextField
)
;
textField
-
>
Select
(
)
;
}
#
define
STYLES_DISABLING_NATIVE_THEMING
\
NS_AUTHOR_SPECIFIED_BACKGROUND
|
NS_AUTHOR_SPECIFIED_PADDING
|
\
NS_AUTHOR_SPECIFIED_BORDER
bool
nsNumberControlFrame
:
:
ShouldUseNativeStyleForSpinner
(
)
const
{
MOZ_ASSERT
(
mSpinUp
&
&
mSpinDown
"
We
should
not
be
called
when
we
have
no
spinner
"
)
;
nsIFrame
*
spinUpFrame
=
mSpinUp
-
>
GetPrimaryFrame
(
)
;
nsIFrame
*
spinDownFrame
=
mSpinDown
-
>
GetPrimaryFrame
(
)
;
return
spinUpFrame
&
&
spinUpFrame
-
>
StyleDisplay
(
)
-
>
mAppearance
=
=
StyleAppearance
:
:
SpinnerUpbutton
&
&
!
PresContext
(
)
-
>
HasAuthorSpecifiedRules
(
spinUpFrame
STYLES_DISABLING_NATIVE_THEMING
)
&
&
spinDownFrame
&
&
spinDownFrame
-
>
StyleDisplay
(
)
-
>
mAppearance
=
=
StyleAppearance
:
:
SpinnerDownbutton
&
&
!
PresContext
(
)
-
>
HasAuthorSpecifiedRules
(
spinDownFrame
STYLES_DISABLING_NATIVE_THEMING
)
;
}
void
nsNumberControlFrame
:
:
AppendAnonymousContentTo
(
nsTArray
<
nsIContent
*
>
&
aElements
uint32_t
aFilter
)
{
if
(
mOuterWrapper
)
{
aElements
.
AppendElement
(
mOuterWrapper
)
;
}
}
void
nsNumberControlFrame
:
:
SetValueOfAnonTextControl
(
const
nsAString
&
aValue
)
{
if
(
mHandlingInputEvent
)
{
return
;
}
nsAutoString
localizedValue
(
aValue
)
;
Decimal
val
=
HTMLInputElement
:
:
StringToDecimal
(
aValue
)
;
if
(
val
.
isFinite
(
)
)
{
ICUUtils
:
:
LanguageTagIterForContent
langTagIter
(
mContent
)
;
ICUUtils
:
:
LocalizeNumber
(
val
.
toDouble
(
)
langTagIter
localizedValue
)
;
}
HTMLInputElement
:
:
FromNode
(
mTextField
)
-
>
SetValue
(
localizedValue
CallerType
:
:
NonSystem
IgnoreErrors
(
)
)
;
}
void
nsNumberControlFrame
:
:
GetValueOfAnonTextControl
(
nsAString
&
aValue
)
{
if
(
!
mTextField
)
{
aValue
.
Truncate
(
)
;
return
;
}
HTMLInputElement
:
:
FromNode
(
mTextField
)
-
>
GetValue
(
aValue
CallerType
:
:
System
)
;
ICUUtils
:
:
LanguageTagIterForContent
langTagIter
(
mContent
)
;
double
value
=
ICUUtils
:
:
ParseNumber
(
aValue
langTagIter
)
;
if
(
!
IsFinite
(
value
)
)
{
aValue
.
Truncate
(
)
;
return
;
}
if
(
value
=
=
HTMLInputElement
:
:
StringToDecimal
(
aValue
)
.
toDouble
(
)
)
{
return
;
}
aValue
.
Truncate
(
)
;
aValue
.
AppendFloat
(
value
)
;
}
bool
nsNumberControlFrame
:
:
AnonTextControlIsEmpty
(
)
{
if
(
!
mTextField
)
{
return
true
;
}
nsAutoString
value
;
HTMLInputElement
:
:
FromNode
(
mTextField
)
-
>
GetValue
(
value
CallerType
:
:
System
)
;
return
value
.
IsEmpty
(
)
;
}
#
ifdef
ACCESSIBILITY
a11y
:
:
AccType
nsNumberControlFrame
:
:
AccessibleType
(
)
{
return
a11y
:
:
eHTMLSpinnerType
;
}
#
endif
