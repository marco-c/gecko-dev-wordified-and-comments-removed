use
std
:
:
any
:
:
Any
;
use
std
:
:
cell
:
:
RefCell
;
use
std
:
:
panic
:
:
{
UnwindSafe
catch_unwind
resume_unwind
}
;
thread_local
!
(
static
PANIC_RESULT
:
RefCell
<
Option
<
Box
<
Any
+
Send
>
>
>
=
RefCell
:
:
new
(
None
)
)
;
pub
fn
maybe_resume_unwind
(
)
{
if
let
Some
(
error
)
=
PANIC_RESULT
.
with
(
|
result
|
result
.
borrow_mut
(
)
.
take
(
)
)
{
resume_unwind
(
error
)
;
}
}
pub
fn
wrap_panic
<
F
R
>
(
function
:
F
generic_return_type
:
R
)
-
>
R
where
F
:
FnOnce
(
)
-
>
R
+
UnwindSafe
{
let
result
=
catch_unwind
(
function
)
;
match
result
{
Ok
(
result
)
=
>
result
Err
(
error
)
=
>
{
PANIC_RESULT
.
with
(
|
result
|
{
assert
!
(
result
.
borrow
(
)
.
is_none
(
)
)
;
*
result
.
borrow_mut
(
)
=
Some
(
error
)
;
}
)
;
generic_return_type
}
}
}
