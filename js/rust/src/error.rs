#
!
[
deny
(
missing_docs
)
]
use
jsapi
:
:
root
:
:
*
;
use
libc
;
use
std
:
:
ffi
:
:
CString
;
use
std
:
:
{
mem
os
ptr
}
;
static
ERROR_FORMAT_STRING_STRING
:
[
libc
:
:
c_char
;
4
]
=
[
'
{
'
as
libc
:
:
c_char
'
0
'
as
libc
:
:
c_char
'
}
'
as
libc
:
:
c_char
0
as
libc
:
:
c_char
]
;
static
mut
TYPE_ERROR_FORMAT_STRING
:
JSErrorFormatString
=
JSErrorFormatString
{
name
:
b
"
RUSTMSG_TYPE_ERROR
\
0
"
as
*
const
_
as
*
const
libc
:
:
c_char
format
:
&
ERROR_FORMAT_STRING_STRING
as
*
const
libc
:
:
c_char
argCount
:
1
exnType
:
JSExnType
:
:
JSEXN_TYPEERR
as
i16
}
;
static
mut
RANGE_ERROR_FORMAT_STRING
:
JSErrorFormatString
=
JSErrorFormatString
{
name
:
b
"
RUSTMSG_RANGE_ERROR
\
0
"
as
*
const
_
as
*
const
libc
:
:
c_char
format
:
&
ERROR_FORMAT_STRING_STRING
as
*
const
libc
:
:
c_char
argCount
:
1
exnType
:
JSExnType
:
:
JSEXN_RANGEERR
as
i16
}
;
unsafe
extern
"
C
"
fn
get_error_message
(
_user_ref
:
*
mut
os
:
:
raw
:
:
c_void
error_number
:
libc
:
:
c_uint
)
-
>
*
const
JSErrorFormatString
{
let
num
:
JSExnType
=
mem
:
:
transmute
(
error_number
)
;
match
num
{
JSExnType
:
:
JSEXN_TYPEERR
=
>
&
TYPE_ERROR_FORMAT_STRING
as
*
const
JSErrorFormatString
JSExnType
:
:
JSEXN_RANGEERR
=
>
&
RANGE_ERROR_FORMAT_STRING
as
*
const
JSErrorFormatString
_
=
>
panic
!
(
"
Bad
js
error
number
given
to
get_error_message
:
{
}
"
error_number
)
}
}
unsafe
fn
throw_js_error
(
cx
:
*
mut
JSContext
error
:
&
str
error_number
:
u32
)
{
let
error
=
CString
:
:
new
(
error
)
.
unwrap
(
)
;
JS_ReportErrorNumberUTF8
(
cx
Some
(
get_error_message
)
ptr
:
:
null_mut
(
)
error_number
error
.
as_ptr
(
)
)
;
}
pub
unsafe
fn
throw_type_error
(
cx
:
*
mut
JSContext
error
:
&
str
)
{
throw_js_error
(
cx
error
JSExnType
:
:
JSEXN_TYPEERR
as
u32
)
;
}
pub
unsafe
fn
throw_range_error
(
cx
:
*
mut
JSContext
error
:
&
str
)
{
throw_js_error
(
cx
error
JSExnType
:
:
JSEXN_RANGEERR
as
u32
)
;
}
