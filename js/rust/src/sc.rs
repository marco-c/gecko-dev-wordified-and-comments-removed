use
glue
;
use
jsapi
;
use
rust
:
:
Runtime
;
use
std
:
:
ptr
;
pub
struct
StructuredCloneBuffer
{
raw
:
*
mut
jsapi
:
:
JSAutoStructuredCloneBuffer
}
impl
StructuredCloneBuffer
{
pub
fn
new
(
scope
:
jsapi
:
:
JS
:
:
StructuredCloneScope
callbacks
:
&
jsapi
:
:
JSStructuredCloneCallbacks
)
-
>
StructuredCloneBuffer
{
let
raw
=
unsafe
{
glue
:
:
NewJSAutoStructuredCloneBuffer
(
scope
callbacks
)
}
;
assert
!
(
!
raw
.
is_null
(
)
)
;
StructuredCloneBuffer
{
raw
:
raw
}
}
pub
fn
data
(
&
self
)
-
>
*
mut
jsapi
:
:
JSStructuredCloneData
{
unsafe
{
&
mut
(
*
self
.
raw
)
.
data_
}
}
pub
fn
copy_to_vec
(
&
self
)
-
>
Vec
<
u8
>
{
let
len
=
unsafe
{
glue
:
:
GetLengthOfJSStructuredCloneData
(
self
.
data
(
)
)
}
;
let
mut
vec
=
Vec
:
:
with_capacity
(
len
)
;
unsafe
{
glue
:
:
CopyJSStructuredCloneData
(
self
.
data
(
)
vec
.
as_mut_ptr
(
)
)
;
}
vec
}
pub
fn
read
(
&
mut
self
vp
:
jsapi
:
:
JS
:
:
MutableHandleValue
callbacks
:
&
jsapi
:
:
JSStructuredCloneCallbacks
)
-
>
Result
<
(
)
(
)
>
{
if
unsafe
{
(
*
self
.
raw
)
.
read
(
Runtime
:
:
get
(
)
vp
&
jsapi
:
:
JS
:
:
CloneDataPolicy
{
allowIntraClusterClonableSharedObjects_
:
false
allowSharedMemoryObjects_
:
false
}
callbacks
ptr
:
:
null_mut
(
)
)
}
{
Ok
(
(
)
)
}
else
{
Err
(
(
)
)
}
}
pub
fn
write
(
&
mut
self
v
:
jsapi
:
:
JS
:
:
HandleValue
callbacks
:
&
jsapi
:
:
JSStructuredCloneCallbacks
)
-
>
Result
<
(
)
(
)
>
{
if
unsafe
{
(
*
self
.
raw
)
.
write
(
Runtime
:
:
get
(
)
v
callbacks
ptr
:
:
null_mut
(
)
)
}
{
Ok
(
(
)
)
}
else
{
Err
(
(
)
)
}
}
pub
fn
write_bytes
(
&
mut
self
bytes
:
&
[
u8
]
)
-
>
Result
<
(
)
(
)
>
{
let
len
=
bytes
.
len
(
)
;
let
src
=
bytes
.
as_ptr
(
)
;
if
unsafe
{
glue
:
:
WriteBytesToJSStructuredCloneData
(
src
len
self
.
data
(
)
)
}
{
Ok
(
(
)
)
}
else
{
Err
(
(
)
)
}
}
}
impl
Drop
for
StructuredCloneBuffer
{
fn
drop
(
&
mut
self
)
{
unsafe
{
glue
:
:
DeleteJSAutoStructuredCloneBuffer
(
self
.
raw
)
;
}
}
}
