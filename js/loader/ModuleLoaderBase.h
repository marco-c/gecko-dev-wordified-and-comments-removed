#
ifndef
js_loader_ModuleLoaderBase_h
#
define
js_loader_ModuleLoaderBase_h
#
include
"
LoadedScript
.
h
"
#
include
"
ScriptLoadRequest
.
h
"
#
include
"
ImportMap
.
h
"
#
include
"
js
/
ColumnNumber
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
js
/
Modules
.
h
"
#
include
"
nsRefPtrHashtable
.
h
"
#
include
"
nsCOMArray
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsILoadInfo
.
h
"
#
include
"
nsINode
.
h
"
#
include
"
nsThreadUtils
.
h
"
#
include
"
nsURIHashKey
.
h
"
#
include
"
mozilla
/
Attributes
.
h
"
#
include
"
mozilla
/
CORSMode
.
h
"
#
include
"
mozilla
/
dom
/
JSExecutionContext
.
h
"
#
include
"
mozilla
/
MaybeOneOf
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
ResolveResult
.
h
"
class
nsIURI
;
namespace
mozilla
{
class
LazyLogModule
;
union
Utf8Unit
;
}
namespace
JS
{
class
CompileOptions
;
template
<
typename
UnitT
>
class
SourceText
;
namespace
loader
{
class
ModuleLoaderBase
;
class
ModuleLoadRequest
;
class
ModuleScript
;
class
ScriptLoaderInterface
:
public
nsISupports
{
public
:
using
ScriptFetchOptions
=
JS
:
:
loader
:
:
ScriptFetchOptions
;
using
ScriptKind
=
JS
:
:
loader
:
:
ScriptKind
;
using
ScriptLoadRequest
=
JS
:
:
loader
:
:
ScriptLoadRequest
;
using
ScriptLoadRequestList
=
JS
:
:
loader
:
:
ScriptLoadRequestList
;
using
ModuleLoadRequest
=
JS
:
:
loader
:
:
ModuleLoadRequest
;
virtual
~
ScriptLoaderInterface
(
)
=
default
;
virtual
nsIURI
*
GetBaseURI
(
)
const
=
0
;
virtual
void
ReportErrorToConsole
(
ScriptLoadRequest
*
aRequest
nsresult
aResult
)
const
=
0
;
virtual
void
ReportWarningToConsole
(
ScriptLoadRequest
*
aRequest
const
char
*
aMessageName
const
nsTArray
<
nsString
>
&
aParams
=
nsTArray
<
nsString
>
(
)
)
const
=
0
;
virtual
nsresult
FillCompileOptionsForRequest
(
JSContext
*
cx
ScriptLoadRequest
*
aRequest
JS
:
:
CompileOptions
*
aOptions
JS
:
:
MutableHandle
<
JSScript
*
>
aIntroductionScript
)
=
0
;
virtual
void
MaybePrepareModuleForBytecodeEncodingBeforeExecute
(
JSContext
*
aCx
ModuleLoadRequest
*
aRequest
)
{
}
virtual
nsresult
MaybePrepareModuleForBytecodeEncodingAfterExecute
(
ModuleLoadRequest
*
aRequest
nsresult
aRv
)
{
return
NS_OK
;
}
virtual
void
MaybeTriggerBytecodeEncoding
(
)
{
}
}
;
class
ModuleMapKey
:
public
PLDHashEntryHdr
{
public
:
using
KeyType
=
const
ModuleMapKey
&
;
using
KeyTypePointer
=
const
ModuleMapKey
*
;
ModuleMapKey
(
const
nsIURI
*
aUri
const
ModuleType
aModuleType
)
:
mUri
(
const_cast
<
nsIURI
*
>
(
aUri
)
)
mModuleType
(
aModuleType
)
{
MOZ_COUNT_CTOR
(
ModuleMapKey
)
;
MOZ_ASSERT
(
aUri
)
;
}
explicit
ModuleMapKey
(
KeyTypePointer
aOther
)
:
mUri
(
std
:
:
move
(
aOther
-
>
mUri
)
)
mModuleType
(
aOther
-
>
mModuleType
)
{
MOZ_COUNT_CTOR
(
ModuleMapKey
)
;
MOZ_ASSERT
(
mUri
)
;
}
ModuleMapKey
(
ModuleMapKey
&
&
aOther
)
:
mUri
(
std
:
:
move
(
aOther
.
mUri
)
)
mModuleType
(
aOther
.
mModuleType
)
{
MOZ_COUNT_CTOR
(
ModuleMapKey
)
;
MOZ_ASSERT
(
mUri
)
;
}
MOZ_COUNTED_DTOR
(
ModuleMapKey
)
bool
KeyEquals
(
KeyTypePointer
aKey
)
const
{
if
(
mModuleType
!
=
aKey
-
>
mModuleType
)
{
return
false
;
}
bool
eq
;
if
(
NS_SUCCEEDED
(
mUri
-
>
Equals
(
aKey
-
>
mUri
&
eq
)
)
)
{
return
eq
;
}
return
false
;
}
static
KeyTypePointer
KeyToPointer
(
KeyType
key
)
{
return
&
key
;
}
static
PLDHashNumber
HashKey
(
KeyTypePointer
aKey
)
{
MOZ_ASSERT
(
aKey
-
>
mUri
)
;
nsAutoCString
spec
;
(
void
)
aKey
-
>
mUri
-
>
GetSpec
(
spec
)
;
return
mozilla
:
:
HashGeneric
(
mozilla
:
:
HashString
(
spec
)
aKey
-
>
mModuleType
)
;
}
enum
{
ALLOW_MEMMOVE
=
true
}
;
const
nsCOMPtr
<
nsIURI
>
mUri
;
const
ModuleType
mModuleType
;
}
;
class
ModuleLoaderBase
:
public
nsISupports
{
class
LoadingRequest
final
:
public
nsISupports
{
virtual
~
LoadingRequest
(
)
=
default
;
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
LoadingRequest
)
RefPtr
<
ModuleLoadRequest
>
mRequest
;
nsTArray
<
RefPtr
<
ModuleLoadRequest
>
>
mWaiting
;
}
;
nsRefPtrHashtable
<
ModuleMapKey
LoadingRequest
>
mFetchingModules
;
nsRefPtrHashtable
<
ModuleMapKey
ModuleScript
>
mFetchedModules
;
ScriptLoadRequestList
mDynamicImportRequests
;
nsCOMPtr
<
nsIGlobalObject
>
mGlobalObject
;
RefPtr
<
ModuleLoaderBase
>
mOverriddenBy
;
bool
mImportMapsAllowed
=
true
;
protected
:
RefPtr
<
ScriptLoaderInterface
>
mLoader
;
mozilla
:
:
UniquePtr
<
ImportMap
>
mImportMap
;
virtual
~
ModuleLoaderBase
(
)
;
#
ifdef
DEBUG
const
ScriptLoadRequestList
&
DynamicImportRequests
(
)
const
{
return
mDynamicImportRequests
;
}
#
endif
public
:
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_CLASS
(
ModuleLoaderBase
)
explicit
ModuleLoaderBase
(
ScriptLoaderInterface
*
aLoader
nsIGlobalObject
*
aGlobalObject
)
;
void
Shutdown
(
)
;
virtual
nsIURI
*
GetBaseURI
(
)
const
{
return
mLoader
-
>
GetBaseURI
(
)
;
}
;
using
LoadedScript
=
JS
:
:
loader
:
:
LoadedScript
;
using
ScriptFetchOptions
=
JS
:
:
loader
:
:
ScriptFetchOptions
;
using
ScriptLoadRequest
=
JS
:
:
loader
:
:
ScriptLoadRequest
;
using
ModuleLoadRequest
=
JS
:
:
loader
:
:
ModuleLoadRequest
;
using
MaybeSourceText
=
mozilla
:
:
MaybeOneOf
<
JS
:
:
SourceText
<
char16_t
>
JS
:
:
SourceText
<
Utf8Unit
>
>
;
private
:
virtual
already_AddRefed
<
ModuleLoadRequest
>
CreateStaticImport
(
nsIURI
*
aURI
ModuleLoadRequest
*
aParent
)
=
0
;
virtual
already_AddRefed
<
ModuleLoadRequest
>
CreateDynamicImport
(
JSContext
*
aCx
nsIURI
*
aURI
LoadedScript
*
aMaybeActiveScript
JS
:
:
Handle
<
JSString
*
>
aSpecifier
JS
:
:
Handle
<
JSObject
*
>
aPromise
)
=
0
;
virtual
bool
IsDynamicImportSupported
(
)
{
return
true
;
}
virtual
void
OnDynamicImportStarted
(
ModuleLoadRequest
*
aRequest
)
{
}
virtual
bool
CanStartLoad
(
ModuleLoadRequest
*
aRequest
nsresult
*
aRvOut
)
=
0
;
virtual
nsresult
StartFetch
(
ModuleLoadRequest
*
aRequest
)
=
0
;
virtual
nsresult
CompileFetchedModule
(
JSContext
*
aCx
JS
:
:
Handle
<
JSObject
*
>
aGlobal
JS
:
:
CompileOptions
&
aOptions
ModuleLoadRequest
*
aRequest
JS
:
:
MutableHandle
<
JSObject
*
>
aModuleOut
)
=
0
;
virtual
void
OnModuleLoadComplete
(
ModuleLoadRequest
*
aRequest
)
=
0
;
virtual
bool
IsModuleEvaluationAborted
(
ModuleLoadRequest
*
aRequest
)
{
return
false
;
}
virtual
nsresult
GetResolveFailureMessage
(
ResolveError
aError
const
nsAString
&
aSpecifier
nsAString
&
aResult
)
;
public
:
ScriptLoaderInterface
*
GetScriptLoaderInterface
(
)
const
{
return
mLoader
;
}
nsIGlobalObject
*
GetGlobalObject
(
)
const
{
return
mGlobalObject
;
}
bool
HasFetchingModules
(
)
const
;
bool
HasPendingDynamicImports
(
)
const
;
void
CancelDynamicImport
(
ModuleLoadRequest
*
aRequest
nsresult
aResult
)
;
#
ifdef
DEBUG
bool
HasDynamicImport
(
const
ModuleLoadRequest
*
aRequest
)
const
;
#
endif
nsresult
StartModuleLoad
(
ModuleLoadRequest
*
aRequest
)
;
nsresult
RestartModuleLoad
(
ModuleLoadRequest
*
aRequest
)
;
nsresult
OnFetchComplete
(
ModuleLoadRequest
*
aRequest
nsresult
aRv
)
;
bool
InstantiateModuleGraph
(
ModuleLoadRequest
*
aRequest
)
;
nsresult
EvaluateModule
(
ModuleLoadRequest
*
aRequest
)
;
nsresult
EvaluateModuleInContext
(
JSContext
*
aCx
ModuleLoadRequest
*
aRequest
JS
:
:
ModuleErrorBehaviour
errorBehaviour
)
;
nsresult
StartDynamicImport
(
ModuleLoadRequest
*
aRequest
)
;
void
ProcessDynamicImport
(
ModuleLoadRequest
*
aRequest
)
;
void
CancelAndClearDynamicImports
(
)
;
mozilla
:
:
UniquePtr
<
ImportMap
>
ParseImportMap
(
ScriptLoadRequest
*
aRequest
)
;
void
RegisterImportMap
(
mozilla
:
:
UniquePtr
<
ImportMap
>
aImportMap
)
;
bool
HasImportMapRegistered
(
)
const
{
return
bool
(
mImportMap
)
;
}
bool
IsImportMapAllowed
(
)
const
{
return
mImportMapsAllowed
;
}
void
DisallowImportMaps
(
)
{
mImportMapsAllowed
=
false
;
}
bool
IsModuleFetched
(
const
ModuleMapKey
&
key
)
const
;
nsresult
GetFetchedModuleURLs
(
nsTArray
<
nsCString
>
&
aURLs
)
;
void
SetOverride
(
ModuleLoaderBase
*
aLoader
)
;
bool
IsOverridden
(
)
;
bool
IsOverriddenBy
(
ModuleLoaderBase
*
aLoader
)
;
void
ResetOverride
(
)
;
void
CopyModulesTo
(
ModuleLoaderBase
*
aDest
)
;
void
MoveModulesTo
(
ModuleLoaderBase
*
aDest
)
;
private
:
friend
class
JS
:
:
loader
:
:
ModuleLoadRequest
;
static
ModuleLoaderBase
*
GetCurrentModuleLoader
(
JSContext
*
aCx
)
;
static
LoadedScript
*
GetLoadedScriptOrNull
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aReferencingPrivate
)
;
static
void
EnsureModuleHooksInitialized
(
)
;
static
JSObject
*
HostResolveImportedModule
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aReferencingPrivate
JS
:
:
Handle
<
JSObject
*
>
aModuleRequest
)
;
static
bool
HostPopulateImportMeta
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aReferencingPrivate
JS
:
:
Handle
<
JSObject
*
>
aMetaObject
)
;
static
bool
ImportMetaResolve
(
JSContext
*
cx
unsigned
argc
Value
*
vp
)
;
static
JSString
*
ImportMetaResolveImpl
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aReferencingPrivate
JS
:
:
Handle
<
JSString
*
>
aSpecifier
)
;
static
bool
HostImportModuleDynamically
(
JSContext
*
aCx
JS
:
:
Handle
<
JS
:
:
Value
>
aReferencingPrivate
JS
:
:
Handle
<
JSObject
*
>
aModuleRequest
JS
:
:
Handle
<
JSObject
*
>
aPromise
)
;
ResolveResult
ResolveModuleSpecifier
(
LoadedScript
*
aScript
const
nsAString
&
aSpecifier
)
;
nsresult
HandleResolveFailure
(
JSContext
*
aCx
LoadedScript
*
aScript
const
nsAString
&
aSpecifier
ResolveError
aError
uint32_t
aLineNumber
JS
:
:
ColumnNumberOneOrigin
aColumnNumber
JS
:
:
MutableHandle
<
JS
:
:
Value
>
aErrorOut
)
;
enum
class
RestartRequest
{
No
Yes
}
;
nsresult
StartOrRestartModuleLoad
(
ModuleLoadRequest
*
aRequest
RestartRequest
aRestart
)
;
bool
ModuleMapContainsURL
(
const
ModuleMapKey
&
key
)
const
;
bool
IsModuleFetching
(
const
ModuleMapKey
&
key
)
const
;
void
WaitForModuleFetch
(
ModuleLoadRequest
*
aRequest
)
;
void
SetModuleFetchStarted
(
ModuleLoadRequest
*
aRequest
)
;
ModuleScript
*
GetFetchedModule
(
const
ModuleMapKey
&
moduleMapKey
)
const
;
JS
:
:
Value
FindFirstParseError
(
ModuleLoadRequest
*
aRequest
)
;
static
nsresult
InitDebuggerDataForModuleGraph
(
JSContext
*
aCx
ModuleLoadRequest
*
aRequest
)
;
nsresult
ResolveRequestedModules
(
ModuleLoadRequest
*
aRequest
nsTArray
<
ModuleMapKey
>
*
aRequestedModulesOut
)
;
void
SetModuleFetchFinishedAndResumeWaitingRequests
(
ModuleLoadRequest
*
aRequest
nsresult
aResult
)
;
void
ResumeWaitingRequests
(
LoadingRequest
*
aLoadingRequest
bool
aSuccess
)
;
void
ResumeWaitingRequest
(
ModuleLoadRequest
*
aRequest
bool
aSuccess
)
;
void
StartFetchingModuleDependencies
(
ModuleLoadRequest
*
aRequest
)
;
void
StartFetchingModuleAndDependencies
(
ModuleLoadRequest
*
aParent
const
ModuleMapKey
&
aRequestedModule
)
;
void
InstantiateAndEvaluateDynamicImport
(
ModuleLoadRequest
*
aRequest
)
;
void
FinishDynamicImportAndReject
(
ModuleLoadRequest
*
aRequest
nsresult
aResult
)
;
static
void
FinishDynamicImport
(
JSContext
*
aCx
ModuleLoadRequest
*
aRequest
nsresult
aResult
JS
:
:
Handle
<
JSObject
*
>
aEvaluationPromise
)
;
void
RemoveDynamicImport
(
ModuleLoadRequest
*
aRequest
)
;
nsresult
CreateModuleScript
(
ModuleLoadRequest
*
aRequest
)
;
bool
IsFetchingAndHasWaitingRequest
(
ModuleLoadRequest
*
aRequest
)
;
enum
{
ModulePrivateSlot
=
0
SlotCount
}
;
static
const
uint32_t
ImportMetaResolveNumArgs
=
1
;
static
const
uint32_t
ImportMetaResolveSpecifierArg
=
0
;
public
:
static
mozilla
:
:
LazyLogModule
gCspPRLog
;
static
mozilla
:
:
LazyLogModule
gModuleLoaderBaseLog
;
}
;
class
MOZ_RAII
AutoOverrideModuleLoader
{
public
:
AutoOverrideModuleLoader
(
ModuleLoaderBase
*
aTarget
ModuleLoaderBase
*
aLoader
)
;
~
AutoOverrideModuleLoader
(
)
;
private
:
RefPtr
<
ModuleLoaderBase
>
mTarget
;
}
;
}
}
#
endif
