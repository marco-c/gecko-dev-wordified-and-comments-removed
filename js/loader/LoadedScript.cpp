#
include
"
LoadedScript
.
h
"
#
include
"
mozilla
/
AlreadyAddRefed
.
h
"
#
include
"
mozilla
/
HoldDropJSObjects
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
UniquePtr
.
h
"
#
include
"
mozilla
/
dom
/
ScriptLoadContext
.
h
"
#
include
"
jsfriendapi
.
h
"
#
include
"
js
/
Modules
.
h
"
#
include
"
LoadContextBase
.
h
"
namespace
JS
:
:
loader
{
MOZ_DEFINE_MALLOC_SIZE_OF
(
LoadedScriptMallocSizeOf
)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION
(
LoadedScript
)
NS_INTERFACE_MAP_ENTRY
(
nsISupports
)
NS_INTERFACE_MAP_END
NS_IMPL_CYCLE_COLLECTION
(
LoadedScript
mFetchOptions
mURI
mBaseURL
mCacheInfo
)
NS_IMPL_CYCLE_COLLECTING_ADDREF
(
LoadedScript
)
NS_IMPL_CYCLE_COLLECTING_RELEASE
(
LoadedScript
)
LoadedScript
:
:
LoadedScript
(
ScriptKind
aKind
mozilla
:
:
dom
:
:
ReferrerPolicy
aReferrerPolicy
ScriptFetchOptions
*
aFetchOptions
nsIURI
*
aURI
)
:
mDataType
(
DataType
:
:
eUnknown
)
mKind
(
aKind
)
mReferrerPolicy
(
aReferrerPolicy
)
mBytecodeOffset
(
0
)
mFetchOptions
(
aFetchOptions
)
mURI
(
aURI
)
mReceivedScriptTextLength
(
0
)
{
MOZ_ASSERT
(
mFetchOptions
)
;
MOZ_ASSERT
(
mURI
)
;
}
LoadedScript
:
:
LoadedScript
(
const
LoadedScript
&
aOther
)
:
mDataType
(
DataType
:
:
eStencil
)
mKind
(
aOther
.
mKind
)
mReferrerPolicy
(
aOther
.
mReferrerPolicy
)
mBytecodeOffset
(
0
)
mFetchOptions
(
aOther
.
mFetchOptions
)
mURI
(
aOther
.
mURI
)
mBaseURL
(
aOther
.
mBaseURL
)
mReceivedScriptTextLength
(
0
)
mStencil
(
aOther
.
mStencil
)
{
MOZ_ASSERT
(
mFetchOptions
)
;
MOZ_ASSERT
(
mURI
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aOther
.
mDataType
=
=
DataType
:
:
eStencil
)
;
MOZ_DIAGNOSTIC_ASSERT
(
mStencil
)
;
MOZ_ASSERT
(
!
mScriptData
)
;
MOZ_ASSERT
(
mScriptBytecode
.
empty
(
)
)
;
}
LoadedScript
:
:
~
LoadedScript
(
)
{
mozilla
:
:
UnregisterWeakMemoryReporter
(
this
)
;
mozilla
:
:
DropJSObjects
(
this
)
;
}
void
LoadedScript
:
:
RegisterMemoryReport
(
)
{
mozilla
:
:
RegisterWeakMemoryReporter
(
this
)
;
}
NS_IMETHODIMP
LoadedScript
:
:
CollectReports
(
nsIHandleReportCallback
*
aHandleReport
nsISupports
*
aData
bool
aAnonymize
)
{
#
define
COLLECT_REPORT
(
path
kind
)
\
MOZ_COLLECT_REPORT
(
path
KIND_HEAP
UNITS_BYTES
\
SizeOfIncludingThis
(
LoadedScriptMallocSizeOf
)
\
"
Memory
used
for
LoadedScript
to
hold
on
"
kind
\
"
across
documents
"
)
switch
(
mKind
)
{
case
ScriptKind
:
:
eClassic
:
COLLECT_REPORT
(
"
explicit
/
js
/
script
/
loaded
-
script
/
classic
"
"
scripts
"
)
;
break
;
case
ScriptKind
:
:
eImportMap
:
COLLECT_REPORT
(
"
explicit
/
js
/
script
/
loaded
-
script
/
import
-
map
"
"
import
-
maps
"
)
;
break
;
case
ScriptKind
:
:
eModule
:
COLLECT_REPORT
(
"
explicit
/
js
/
script
/
loaded
-
script
/
module
"
"
modules
"
)
;
break
;
case
ScriptKind
:
:
eEvent
:
COLLECT_REPORT
(
"
explicit
/
js
/
script
/
loaded
-
script
/
event
"
"
event
scripts
"
)
;
break
;
}
#
undef
COLLECT_REPORT
return
NS_OK
;
}
size_t
LoadedScript
:
:
SizeOfIncludingThis
(
mozilla
:
:
MallocSizeOf
aMallocSizeOf
)
const
{
size_t
bytes
=
aMallocSizeOf
(
this
)
;
if
(
IsTextSource
(
)
)
{
if
(
IsUTF16Text
(
)
)
{
bytes
+
=
ScriptText
<
char16_t
>
(
)
.
sizeOfExcludingThis
(
aMallocSizeOf
)
;
}
else
{
bytes
+
=
ScriptText
<
Utf8Unit
>
(
)
.
sizeOfExcludingThis
(
aMallocSizeOf
)
;
}
}
bytes
+
=
mScriptBytecode
.
sizeOfExcludingThis
(
aMallocSizeOf
)
;
return
bytes
;
}
void
LoadedScript
:
:
AssociateWithScript
(
JSScript
*
aScript
)
{
MOZ_ASSERT
(
mBaseURL
)
;
MOZ_ASSERT
(
GetScriptPrivate
(
aScript
)
.
isUndefined
(
)
)
;
SetScriptPrivate
(
aScript
PrivateValue
(
this
)
)
;
}
nsresult
LoadedScript
:
:
GetScriptSource
(
JSContext
*
aCx
MaybeSourceText
*
aMaybeSource
LoadContextBase
*
aMaybeLoadContext
)
{
bool
isWindowContext
=
aMaybeLoadContext
&
&
aMaybeLoadContext
-
>
IsWindowContext
(
)
;
if
(
isWindowContext
&
&
aMaybeLoadContext
-
>
AsWindowContext
(
)
-
>
mIsInline
)
{
nsAutoString
inlineData
;
auto
*
scriptLoadContext
=
aMaybeLoadContext
-
>
AsWindowContext
(
)
;
scriptLoadContext
-
>
GetInlineScriptText
(
inlineData
)
;
size_t
nbytes
=
inlineData
.
Length
(
)
*
sizeof
(
char16_t
)
;
UniqueTwoByteChars
chars
(
static_cast
<
char16_t
*
>
(
JS_malloc
(
aCx
nbytes
)
)
)
;
if
(
!
chars
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
memcpy
(
chars
.
get
(
)
inlineData
.
get
(
)
nbytes
)
;
SourceText
<
char16_t
>
srcBuf
;
if
(
!
srcBuf
.
init
(
aCx
std
:
:
move
(
chars
)
inlineData
.
Length
(
)
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
aMaybeSource
-
>
construct
<
SourceText
<
char16_t
>
>
(
std
:
:
move
(
srcBuf
)
)
;
return
NS_OK
;
}
size_t
length
=
ScriptTextLength
(
)
;
if
(
IsUTF16Text
(
)
)
{
UniqueTwoByteChars
chars
;
chars
.
reset
(
ScriptText
<
char16_t
>
(
)
.
extractOrCopyRawBuffer
(
)
)
;
if
(
!
chars
)
{
JS_ReportOutOfMemory
(
aCx
)
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
SourceText
<
char16_t
>
srcBuf
;
if
(
!
srcBuf
.
init
(
aCx
std
:
:
move
(
chars
)
length
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
aMaybeSource
-
>
construct
<
SourceText
<
char16_t
>
>
(
std
:
:
move
(
srcBuf
)
)
;
return
NS_OK
;
}
MOZ_ASSERT
(
IsUTF8Text
(
)
)
;
mozilla
:
:
UniquePtr
<
Utf8Unit
[
]
FreePolicy
>
chars
;
chars
.
reset
(
ScriptText
<
Utf8Unit
>
(
)
.
extractOrCopyRawBuffer
(
)
)
;
if
(
!
chars
)
{
JS_ReportOutOfMemory
(
aCx
)
;
return
NS_ERROR_OUT_OF_MEMORY
;
}
SourceText
<
Utf8Unit
>
srcBuf
;
if
(
!
srcBuf
.
init
(
aCx
std
:
:
move
(
chars
)
length
)
)
{
return
NS_ERROR_OUT_OF_MEMORY
;
}
aMaybeSource
-
>
construct
<
SourceText
<
Utf8Unit
>
>
(
std
:
:
move
(
srcBuf
)
)
;
return
NS_OK
;
}
inline
void
CheckModuleScriptPrivate
(
LoadedScript
*
script
const
Value
&
aPrivate
)
{
#
ifdef
DEBUG
if
(
script
-
>
IsModuleScript
(
)
)
{
JSObject
*
module
=
script
-
>
AsModuleScript
(
)
-
>
mModuleRecord
.
unbarrieredGet
(
)
;
MOZ_ASSERT_IF
(
module
GetModulePrivate
(
module
)
=
=
aPrivate
)
;
}
#
endif
}
void
HostAddRefTopLevelScript
(
const
Value
&
aPrivate
)
{
auto
script
=
static_cast
<
LoadedScript
*
>
(
aPrivate
.
toPrivate
(
)
)
;
CheckModuleScriptPrivate
(
script
aPrivate
)
;
script
-
>
AddRef
(
)
;
}
void
HostReleaseTopLevelScript
(
const
Value
&
aPrivate
)
{
auto
script
=
static_cast
<
LoadedScript
*
>
(
aPrivate
.
toPrivate
(
)
)
;
CheckModuleScriptPrivate
(
script
aPrivate
)
;
script
-
>
Release
(
)
;
}
EventScript
:
:
EventScript
(
mozilla
:
:
dom
:
:
ReferrerPolicy
aReferrerPolicy
ScriptFetchOptions
*
aFetchOptions
nsIURI
*
aURI
)
:
LoadedScript
(
ScriptKind
:
:
eEvent
aReferrerPolicy
aFetchOptions
aURI
)
{
SetBaseURL
(
aURI
)
;
}
ClassicScript
:
:
ClassicScript
(
mozilla
:
:
dom
:
:
ReferrerPolicy
aReferrerPolicy
ScriptFetchOptions
*
aFetchOptions
nsIURI
*
aURI
)
:
LoadedScript
(
ScriptKind
:
:
eClassic
aReferrerPolicy
aFetchOptions
aURI
)
{
}
NS_IMPL_ISUPPORTS_CYCLE_COLLECTION_INHERITED_0
(
ModuleScript
LoadedScript
)
NS_IMPL_CYCLE_COLLECTION_CLASS
(
ModuleScript
)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED
(
ModuleScript
LoadedScript
)
tmp
-
>
UnlinkModuleRecord
(
)
;
tmp
-
>
mParseError
.
setUndefined
(
)
;
tmp
-
>
mErrorToRethrow
.
setUndefined
(
)
;
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED
(
ModuleScript
LoadedScript
)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN_INHERITED
(
ModuleScript
LoadedScript
)
NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK
(
mModuleRecord
)
NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK
(
mParseError
)
NS_IMPL_CYCLE_COLLECTION_TRACE_JS_MEMBER_CALLBACK
(
mErrorToRethrow
)
NS_IMPL_CYCLE_COLLECTION_TRACE_END
ModuleScript
:
:
ModuleScript
(
mozilla
:
:
dom
:
:
ReferrerPolicy
aReferrerPolicy
ScriptFetchOptions
*
aFetchOptions
nsIURI
*
aURI
)
:
LoadedScript
(
ScriptKind
:
:
eModule
aReferrerPolicy
aFetchOptions
aURI
)
{
MOZ_ASSERT
(
!
ModuleRecord
(
)
)
;
MOZ_ASSERT
(
!
HasParseError
(
)
)
;
MOZ_ASSERT
(
!
HasErrorToRethrow
(
)
)
;
}
ModuleScript
:
:
ModuleScript
(
const
LoadedScript
&
aOther
)
:
LoadedScript
(
aOther
)
{
MOZ_ASSERT
(
!
ModuleRecord
(
)
)
;
MOZ_ASSERT
(
!
HasParseError
(
)
)
;
MOZ_ASSERT
(
!
HasErrorToRethrow
(
)
)
;
}
already_AddRefed
<
ModuleScript
>
ModuleScript
:
:
FromCache
(
const
LoadedScript
&
aScript
)
{
MOZ_DIAGNOSTIC_ASSERT
(
aScript
.
IsModuleScript
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
aScript
.
IsStencil
(
)
)
;
return
mozilla
:
:
MakeRefPtr
<
ModuleScript
>
(
aScript
)
.
forget
(
)
;
}
already_AddRefed
<
LoadedScript
>
ModuleScript
:
:
ToCache
(
)
{
MOZ_DIAGNOSTIC_ASSERT
(
IsStencil
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
HasParseError
(
)
)
;
MOZ_DIAGNOSTIC_ASSERT
(
!
HasErrorToRethrow
(
)
)
;
return
mozilla
:
:
MakeRefPtr
<
LoadedScript
>
(
*
this
)
.
forget
(
)
;
}
void
ModuleScript
:
:
Shutdown
(
)
{
if
(
mModuleRecord
)
{
ClearModuleEnvironment
(
mModuleRecord
)
;
}
UnlinkModuleRecord
(
)
;
}
void
ModuleScript
:
:
UnlinkModuleRecord
(
)
{
if
(
mModuleRecord
)
{
JSObject
*
module
=
mModuleRecord
.
unbarrieredGet
(
)
;
if
(
IsCyclicModule
(
module
)
)
{
MOZ_ASSERT
(
GetModulePrivate
(
module
)
.
toPrivate
(
)
=
=
this
)
;
ClearModulePrivate
(
module
)
;
}
mModuleRecord
=
nullptr
;
}
}
ModuleScript
:
:
~
ModuleScript
(
)
{
UnlinkModuleRecord
(
)
;
}
void
ModuleScript
:
:
SetModuleRecord
(
Handle
<
JSObject
*
>
aModuleRecord
)
{
MOZ_ASSERT
(
!
mModuleRecord
)
;
MOZ_ASSERT_IF
(
IsModuleScript
(
)
!
AsModuleScript
(
)
-
>
HasParseError
(
)
)
;
MOZ_ASSERT_IF
(
IsModuleScript
(
)
!
AsModuleScript
(
)
-
>
HasErrorToRethrow
(
)
)
;
mModuleRecord
=
aModuleRecord
;
if
(
IsCyclicModule
(
mModuleRecord
)
)
{
MOZ_ASSERT
(
GetModulePrivate
(
mModuleRecord
)
.
isUndefined
(
)
)
;
SetModulePrivate
(
mModuleRecord
PrivateValue
(
this
)
)
;
}
mozilla
:
:
HoldJSObjects
(
this
)
;
}
void
ModuleScript
:
:
SetParseError
(
const
Value
&
aError
)
{
MOZ_ASSERT
(
!
aError
.
isUndefined
(
)
)
;
MOZ_ASSERT
(
!
HasParseError
(
)
)
;
MOZ_ASSERT
(
!
HasErrorToRethrow
(
)
)
;
UnlinkModuleRecord
(
)
;
mParseError
=
aError
;
mozilla
:
:
HoldJSObjects
(
this
)
;
}
void
ModuleScript
:
:
SetErrorToRethrow
(
const
Value
&
aError
)
{
MOZ_ASSERT
(
!
aError
.
isUndefined
(
)
)
;
MOZ_ASSERT
(
ModuleRecord
(
)
|
|
HasParseError
(
)
)
;
mErrorToRethrow
=
aError
;
}
void
ModuleScript
:
:
SetForPreload
(
bool
aValue
)
{
mForPreload
=
aValue
;
}
void
ModuleScript
:
:
SetHadImportMap
(
bool
aValue
)
{
mHadImportMap
=
aValue
;
}
}
