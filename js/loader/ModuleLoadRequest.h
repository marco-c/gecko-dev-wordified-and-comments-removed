#
ifndef
js_loader_ModuleLoadRequest_h
#
define
js_loader_ModuleLoadRequest_h
#
include
"
LoadContextBase
.
h
"
#
include
"
ScriptLoadRequest
.
h
"
#
include
"
ModuleLoaderBase
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
Value
.
h
"
#
include
"
nsURIHashKey
.
h
"
#
include
"
nsTHashtable
.
h
"
namespace
JS
:
:
loader
{
class
LoadedScript
;
class
ModuleScript
;
class
ModuleLoaderBase
;
class
VisitedURLSet
:
public
nsTHashtable
<
nsURIHashKey
>
{
NS_INLINE_DECL_REFCOUNTING
(
VisitedURLSet
)
private
:
~
VisitedURLSet
(
)
=
default
;
}
;
class
ModuleLoadRequest
final
:
public
ScriptLoadRequest
{
~
ModuleLoadRequest
(
)
{
MOZ_ASSERT
(
!
mWaitingParentRequest
)
;
MOZ_ASSERT
(
mAwaitingImports
=
=
0
)
;
}
ModuleLoadRequest
(
const
ModuleLoadRequest
&
aOther
)
=
delete
;
ModuleLoadRequest
(
ModuleLoadRequest
&
&
aOther
)
=
delete
;
public
:
NS_DECL_ISUPPORTS_INHERITED
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_INHERITED
(
ModuleLoadRequest
ScriptLoadRequest
)
using
SRIMetadata
=
mozilla
:
:
dom
:
:
SRIMetadata
;
ModuleLoadRequest
(
nsIURI
*
aURI
mozilla
:
:
dom
:
:
ReferrerPolicy
aReferrerPolicy
ScriptFetchOptions
*
aFetchOptions
const
SRIMetadata
&
aIntegrity
nsIURI
*
aReferrer
LoadContextBase
*
aContext
bool
aIsTopLevel
bool
aIsDynamicImport
ModuleLoaderBase
*
aLoader
VisitedURLSet
*
aVisitedSet
ModuleLoadRequest
*
aRootModule
)
;
static
VisitedURLSet
*
NewVisitedSetForTopLevelImport
(
nsIURI
*
aURI
)
;
bool
IsTopLevel
(
)
const
override
{
return
mIsTopLevel
;
}
bool
IsDynamicImport
(
)
const
{
return
mIsDynamicImport
;
}
bool
IsErrored
(
)
const
;
nsIGlobalObject
*
GetGlobalObject
(
)
;
void
SetReady
(
)
override
;
void
Cancel
(
)
override
;
void
SetDynamicImport
(
LoadedScript
*
aReferencingScript
JS
:
:
Handle
<
JSString
*
>
aSpecifier
JS
:
:
Handle
<
JSObject
*
>
aPromise
)
;
void
ClearDynamicImport
(
)
;
void
ModuleLoaded
(
)
;
void
ModuleErrored
(
)
;
void
DependenciesLoaded
(
)
;
void
LoadFailed
(
)
;
ModuleLoadRequest
*
GetRootModule
(
)
{
if
(
!
mRootModule
)
{
return
this
;
}
return
mRootModule
;
}
void
MarkModuleForBytecodeEncoding
(
)
{
MarkForBytecodeEncoding
(
)
;
}
void
CancelDynamicImport
(
nsresult
aResult
)
{
MOZ_ASSERT
(
IsDynamicImport
(
)
)
;
mLoader
-
>
CancelDynamicImport
(
this
aResult
)
;
}
#
ifdef
DEBUG
bool
IsRegisteredDynamicImport
(
)
const
{
return
IsDynamicImport
(
)
&
&
mLoader
-
>
HasDynamicImport
(
this
)
;
}
#
endif
nsresult
StartModuleLoad
(
)
{
return
mLoader
-
>
StartModuleLoad
(
this
)
;
}
nsresult
RestartModuleLoad
(
)
{
return
mLoader
-
>
RestartModuleLoad
(
this
)
;
}
nsresult
OnFetchComplete
(
nsresult
aRv
)
{
return
mLoader
-
>
OnFetchComplete
(
this
aRv
)
;
}
bool
InstantiateModuleGraph
(
)
{
return
mLoader
-
>
InstantiateModuleGraph
(
this
)
;
}
nsresult
EvaluateModule
(
)
{
return
mLoader
-
>
EvaluateModule
(
this
)
;
}
void
StartDynamicImport
(
)
{
mLoader
-
>
StartDynamicImport
(
this
)
;
}
void
ProcessDynamicImport
(
)
{
mLoader
-
>
ProcessDynamicImport
(
this
)
;
}
void
ChildLoadComplete
(
bool
aSuccess
)
;
private
:
void
LoadFinished
(
)
;
void
CancelImports
(
)
;
void
CheckModuleDependenciesLoaded
(
)
;
void
ChildModuleUnlinked
(
)
;
void
AssertAllImportsFinished
(
)
const
;
void
AssertAllImportsCancelled
(
)
const
;
public
:
const
bool
mIsTopLevel
;
const
bool
mIsDynamicImport
;
RefPtr
<
ModuleLoaderBase
>
mLoader
;
RefPtr
<
ModuleLoadRequest
>
mRootModule
;
RefPtr
<
ModuleScript
>
mModuleScript
;
nsTArray
<
RefPtr
<
ModuleLoadRequest
>
>
mImports
;
RefPtr
<
ModuleLoadRequest
>
mWaitingParentRequest
;
size_t
mAwaitingImports
=
0
;
RefPtr
<
VisitedURLSet
>
mVisitedSet
;
RefPtr
<
LoadedScript
>
mDynamicReferencingScript
;
JS
:
:
Heap
<
JSString
*
>
mDynamicSpecifier
;
JS
:
:
Heap
<
JSObject
*
>
mDynamicPromise
;
}
;
}
#
endif
