#
include
"
ImportMap
.
h
"
#
include
"
js
/
Array
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
JSON
.
h
"
#
include
"
LoadedScript
.
h
"
#
include
"
ModuleLoaderBase
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIScriptElement
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
ScriptLoadRequest
.
h
"
using
JS
:
:
SourceText
;
using
mozilla
:
:
Err
;
using
mozilla
:
:
LazyLogModule
;
using
mozilla
:
:
MakeUnique
;
using
mozilla
:
:
UniquePtr
;
using
mozilla
:
:
WrapNotNull
;
namespace
JS
:
:
loader
{
LazyLogModule
ImportMap
:
:
gImportMapLog
(
"
ImportMap
"
)
;
#
undef
LOG
#
define
LOG
(
args
)
\
MOZ_LOG
(
ImportMap
:
:
gImportMapLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
#
define
LOG_ENABLED
(
)
\
MOZ_LOG_TEST
(
ImportMap
:
:
gImportMapLog
mozilla
:
:
LogLevel
:
:
Debug
)
void
ReportWarningHelper
:
:
Report
(
const
char
*
aMessageName
const
nsTArray
<
nsString
>
&
aParams
)
const
{
mLoader
-
>
ReportWarningToConsole
(
mRequest
aMessageName
aParams
)
;
}
static
ResolveResult
ParseURLLikeImportSpecifier
(
const
nsAString
&
aSpecifier
nsIURI
*
aBaseURL
)
{
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
;
if
(
StringBeginsWith
(
aSpecifier
u
"
/
"
_ns
)
|
|
StringBeginsWith
(
aSpecifier
u
"
.
/
"
_ns
)
|
|
StringBeginsWith
(
aSpecifier
u
"
.
.
/
"
_ns
)
)
{
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
aSpecifier
nullptr
aBaseURL
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Err
(
ResolveError
:
:
Failure
)
;
}
return
WrapNotNull
(
uri
)
;
}
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
aSpecifier
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
Err
(
ResolveError
:
:
FailureMayBeBare
)
;
}
return
WrapNotNull
(
uri
)
;
}
static
void
NormalizeSpecifierKey
(
const
nsAString
&
aSpecifierKey
nsIURI
*
aBaseURL
const
ReportWarningHelper
&
aWarning
nsAString
&
aRetVal
)
{
if
(
aSpecifierKey
.
IsEmpty
(
)
)
{
aWarning
.
Report
(
"
ImportMapEmptySpecifierKeys
"
)
;
aRetVal
=
EmptyString
(
)
;
return
;
}
auto
parseResult
=
ParseURLLikeImportSpecifier
(
aSpecifierKey
aBaseURL
)
;
if
(
parseResult
.
isOk
(
)
)
{
nsCOMPtr
<
nsIURI
>
url
=
parseResult
.
unwrap
(
)
;
aRetVal
=
NS_ConvertUTF8toUTF16
(
url
-
>
GetSpecOrDefault
(
)
)
;
return
;
}
aRetVal
=
aSpecifierKey
;
}
static
UniquePtr
<
SpecifierMap
>
SortAndNormalizeSpecifierMap
(
JSContext
*
aCx
JS
:
:
HandleObject
aOriginalMap
nsIURI
*
aBaseURL
const
ReportWarningHelper
&
aWarning
)
{
UniquePtr
<
SpecifierMap
>
normalized
=
MakeUnique
<
SpecifierMap
>
(
)
;
JS
:
:
Rooted
<
JS
:
:
IdVector
>
specifierKeys
(
aCx
JS
:
:
IdVector
(
aCx
)
)
;
if
(
!
JS_Enumerate
(
aCx
aOriginalMap
&
specifierKeys
)
)
{
return
nullptr
;
}
for
(
size_t
i
=
0
;
i
<
specifierKeys
.
length
(
)
;
i
+
+
)
{
const
JS
:
:
RootedId
specifierId
(
aCx
specifierKeys
[
i
]
)
;
nsAutoJSString
specifierKey
;
NS_ENSURE_TRUE
(
specifierKey
.
init
(
aCx
specifierId
)
nullptr
)
;
nsString
normalizedSpecifierKey
;
NormalizeSpecifierKey
(
specifierKey
aBaseURL
aWarning
normalizedSpecifierKey
)
;
if
(
normalizedSpecifierKey
.
IsEmpty
(
)
)
{
continue
;
}
JS
:
:
RootedValue
idVal
(
aCx
)
;
NS_ENSURE_TRUE
(
JS_GetPropertyById
(
aCx
aOriginalMap
specifierId
&
idVal
)
nullptr
)
;
if
(
!
idVal
.
isString
(
)
)
{
aWarning
.
Report
(
"
ImportMapAddressesNotStrings
"
)
;
normalized
-
>
insert_or_assign
(
normalizedSpecifierKey
nullptr
)
;
continue
;
}
nsAutoJSString
value
;
NS_ENSURE_TRUE
(
value
.
init
(
aCx
idVal
)
nullptr
)
;
auto
parseResult
=
ParseURLLikeImportSpecifier
(
value
aBaseURL
)
;
if
(
parseResult
.
isErr
(
)
)
{
AutoTArray
<
nsString
1
>
params
;
params
.
AppendElement
(
value
)
;
aWarning
.
Report
(
"
ImportMapInvalidAddress
"
params
)
;
normalized
-
>
insert_or_assign
(
normalizedSpecifierKey
nullptr
)
;
continue
;
}
nsCOMPtr
<
nsIURI
>
addressURL
=
parseResult
.
unwrap
(
)
;
nsCString
address
=
addressURL
-
>
GetSpecOrDefault
(
)
;
if
(
StringEndsWith
(
specifierKey
u
"
/
"
_ns
)
&
&
!
StringEndsWith
(
address
"
/
"
_ns
)
)
{
AutoTArray
<
nsString
2
>
params
;
params
.
AppendElement
(
specifierKey
)
;
params
.
AppendElement
(
NS_ConvertUTF8toUTF16
(
address
)
)
;
aWarning
.
Report
(
"
ImportMapAddressNotEndsWithSlash
"
params
)
;
normalized
-
>
insert_or_assign
(
normalizedSpecifierKey
nullptr
)
;
continue
;
}
LOG
(
(
"
ImportMap
:
:
SortAndNormalizeSpecifierMap
{
%
s
%
s
}
"
NS_ConvertUTF16toUTF8
(
normalizedSpecifierKey
)
.
get
(
)
addressURL
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
normalized
-
>
insert_or_assign
(
normalizedSpecifierKey
addressURL
)
;
}
return
normalized
;
}
static
bool
IsMapObject
(
JSContext
*
aCx
JS
:
:
HandleValue
aMapVal
bool
*
aIsMap
)
{
MOZ_ASSERT
(
aIsMap
)
;
*
aIsMap
=
false
;
if
(
!
aMapVal
.
isObject
(
)
)
{
return
true
;
}
bool
isArray
;
if
(
!
IsArrayObject
(
aCx
aMapVal
&
isArray
)
)
{
return
false
;
}
*
aIsMap
=
!
isArray
;
return
true
;
}
static
UniquePtr
<
ScopeMap
>
SortAndNormalizeScopes
(
JSContext
*
aCx
JS
:
:
HandleObject
aOriginalMap
nsIURI
*
aBaseURL
const
ReportWarningHelper
&
aWarning
)
{
JS
:
:
Rooted
<
JS
:
:
IdVector
>
scopeKeys
(
aCx
JS
:
:
IdVector
(
aCx
)
)
;
if
(
!
JS_Enumerate
(
aCx
aOriginalMap
&
scopeKeys
)
)
{
return
nullptr
;
}
UniquePtr
<
ScopeMap
>
normalized
=
MakeUnique
<
ScopeMap
>
(
)
;
for
(
size_t
i
=
0
;
i
<
scopeKeys
.
length
(
)
;
i
+
+
)
{
const
JS
:
:
RootedId
scopeKey
(
aCx
scopeKeys
[
i
]
)
;
nsAutoJSString
scopePrefix
;
NS_ENSURE_TRUE
(
scopePrefix
.
init
(
aCx
scopeKey
)
nullptr
)
;
JS
:
:
RootedValue
mapVal
(
aCx
)
;
NS_ENSURE_TRUE
(
JS_GetPropertyById
(
aCx
aOriginalMap
scopeKey
&
mapVal
)
nullptr
)
;
bool
isMap
;
if
(
!
IsMapObject
(
aCx
mapVal
&
isMap
)
)
{
return
nullptr
;
}
if
(
!
isMap
)
{
const
char16_t
*
scope
=
scopePrefix
.
get
(
)
;
JS_ReportErrorNumberUC
(
aCx
js
:
:
GetErrorMessage
nullptr
JSMSG_IMPORT_MAPS_SCOPE_VALUE_NOT_A_MAP
scope
)
;
return
nullptr
;
}
nsCOMPtr
<
nsIURI
>
scopePrefixURL
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
scopePrefixURL
)
scopePrefix
nullptr
aBaseURL
)
;
if
(
NS_FAILED
(
rv
)
)
{
AutoTArray
<
nsString
1
>
params
;
params
.
AppendElement
(
scopePrefix
)
;
aWarning
.
Report
(
"
ImportMapScopePrefixNotParseable
"
params
)
;
continue
;
}
nsCString
normalizedScopePrefix
=
scopePrefixURL
-
>
GetSpecOrDefault
(
)
;
JS
:
:
RootedObject
potentialSpecifierMap
(
aCx
&
mapVal
.
toObject
(
)
)
;
UniquePtr
<
SpecifierMap
>
specifierMap
=
SortAndNormalizeSpecifierMap
(
aCx
potentialSpecifierMap
aBaseURL
aWarning
)
;
if
(
!
specifierMap
)
{
return
nullptr
;
}
normalized
-
>
insert_or_assign
(
normalizedScopePrefix
std
:
:
move
(
specifierMap
)
)
;
}
return
normalized
;
}
UniquePtr
<
ImportMap
>
ImportMap
:
:
ParseString
(
JSContext
*
aCx
SourceText
<
char16_t
>
&
aInput
nsIURI
*
aBaseURL
const
ReportWarningHelper
&
aWarning
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
parsedVal
(
aCx
)
;
if
(
!
JS_ParseJSON
(
aCx
aInput
.
get
(
)
aInput
.
length
(
)
&
parsedVal
)
)
{
NS_WARNING
(
"
Parsing
Import
map
string
failed
"
)
;
return
nullptr
;
}
bool
isMap
;
if
(
!
IsMapObject
(
aCx
parsedVal
&
isMap
)
)
{
return
nullptr
;
}
if
(
!
isMap
)
{
JS_ReportErrorNumberASCII
(
aCx
js
:
:
GetErrorMessage
nullptr
JSMSG_IMPORT_MAPS_NOT_A_MAP
)
;
return
nullptr
;
}
JS
:
:
RootedObject
parsedObj
(
aCx
&
parsedVal
.
toObject
(
)
)
;
JS
:
:
RootedValue
importsVal
(
aCx
)
;
if
(
!
JS_GetProperty
(
aCx
parsedObj
"
imports
"
&
importsVal
)
)
{
return
nullptr
;
}
UniquePtr
<
SpecifierMap
>
sortedAndNormalizedImports
=
nullptr
;
if
(
!
importsVal
.
isUndefined
(
)
)
{
bool
isMap
;
if
(
!
IsMapObject
(
aCx
importsVal
&
isMap
)
)
{
return
nullptr
;
}
if
(
!
isMap
)
{
JS_ReportErrorNumberASCII
(
aCx
js
:
:
GetErrorMessage
nullptr
JSMSG_IMPORT_MAPS_IMPORTS_NOT_A_MAP
)
;
return
nullptr
;
}
JS
:
:
RootedObject
importsObj
(
aCx
&
importsVal
.
toObject
(
)
)
;
sortedAndNormalizedImports
=
SortAndNormalizeSpecifierMap
(
aCx
importsObj
aBaseURL
aWarning
)
;
if
(
!
sortedAndNormalizedImports
)
{
return
nullptr
;
}
}
JS
:
:
RootedValue
scopesVal
(
aCx
)
;
if
(
!
JS_GetProperty
(
aCx
parsedObj
"
scopes
"
&
scopesVal
)
)
{
return
nullptr
;
}
UniquePtr
<
ScopeMap
>
sortedAndNormalizedScopes
=
nullptr
;
if
(
!
scopesVal
.
isUndefined
(
)
)
{
bool
isMap
;
if
(
!
IsMapObject
(
aCx
scopesVal
&
isMap
)
)
{
return
nullptr
;
}
if
(
!
isMap
)
{
JS_ReportErrorNumberASCII
(
aCx
js
:
:
GetErrorMessage
nullptr
JSMSG_IMPORT_MAPS_SCOPES_NOT_A_MAP
)
;
return
nullptr
;
}
JS
:
:
RootedObject
scopesObj
(
aCx
&
scopesVal
.
toObject
(
)
)
;
sortedAndNormalizedScopes
=
SortAndNormalizeScopes
(
aCx
scopesObj
aBaseURL
aWarning
)
;
if
(
!
sortedAndNormalizedScopes
)
{
return
nullptr
;
}
}
JS
:
:
Rooted
<
JS
:
:
IdVector
>
keys
(
aCx
JS
:
:
IdVector
(
aCx
)
)
;
if
(
!
JS_Enumerate
(
aCx
parsedObj
&
keys
)
)
{
return
nullptr
;
}
for
(
size_t
i
=
0
;
i
<
keys
.
length
(
)
;
i
+
+
)
{
const
JS
:
:
RootedId
key
(
aCx
keys
[
i
]
)
;
nsAutoJSString
val
;
NS_ENSURE_TRUE
(
val
.
init
(
aCx
key
)
nullptr
)
;
if
(
val
.
EqualsLiteral
(
"
imports
"
)
|
|
val
.
EqualsLiteral
(
"
scopes
"
)
)
{
continue
;
}
AutoTArray
<
nsString
1
>
params
;
params
.
AppendElement
(
val
)
;
aWarning
.
Report
(
"
ImportMapInvalidTopLevelKey
"
params
)
;
}
if
(
!
sortedAndNormalizedImports
)
{
sortedAndNormalizedImports
=
MakeUnique
<
SpecifierMap
>
(
)
;
}
if
(
!
sortedAndNormalizedScopes
)
{
sortedAndNormalizedScopes
=
MakeUnique
<
ScopeMap
>
(
)
;
}
return
MakeUnique
<
ImportMap
>
(
std
:
:
move
(
sortedAndNormalizedImports
)
std
:
:
move
(
sortedAndNormalizedScopes
)
)
;
}
static
bool
IsSpecialScheme
(
nsIURI
*
aURI
)
{
nsAutoCString
scheme
;
aURI
-
>
GetScheme
(
scheme
)
;
return
scheme
.
EqualsLiteral
(
"
ftp
"
)
|
|
scheme
.
EqualsLiteral
(
"
file
"
)
|
|
scheme
.
EqualsLiteral
(
"
http
"
)
|
|
scheme
.
EqualsLiteral
(
"
https
"
)
|
|
scheme
.
EqualsLiteral
(
"
ws
"
)
|
|
scheme
.
EqualsLiteral
(
"
wss
"
)
;
}
static
mozilla
:
:
Result
<
nsCOMPtr
<
nsIURI
>
ResolveError
>
ResolveImportsMatch
(
nsString
&
aNormalizedSpecifier
nsIURI
*
aAsURL
const
SpecifierMap
*
aSpecifierMap
)
{
for
(
auto
&
&
[
specifierKey
resolutionResult
]
:
*
aSpecifierMap
)
{
nsAutoString
specifier
{
aNormalizedSpecifier
}
;
nsCString
asURL
=
aAsURL
?
aAsURL
-
>
GetSpecOrDefault
(
)
:
EmptyCString
(
)
;
if
(
specifierKey
.
Equals
(
aNormalizedSpecifier
)
)
{
if
(
!
resolutionResult
)
{
LOG
(
(
"
ImportMap
:
:
ResolveImportsMatch
normalizedSpecifier
:
%
s
"
"
specifierKey
:
%
s
but
resolution
is
null
.
"
NS_ConvertUTF16toUTF8
(
aNormalizedSpecifier
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
specifierKey
)
.
get
(
)
)
)
;
return
Err
(
ResolveError
:
:
BlockedByNullEntry
)
;
}
MOZ_ASSERT
(
resolutionResult
)
;
return
resolutionResult
;
}
if
(
StringEndsWith
(
specifierKey
u
"
/
"
_ns
)
&
&
StringBeginsWith
(
aNormalizedSpecifier
specifierKey
)
&
&
(
!
aAsURL
|
|
IsSpecialScheme
(
aAsURL
)
)
)
{
if
(
!
resolutionResult
)
{
LOG
(
(
"
ImportMap
:
:
ResolveImportsMatch
normalizedSpecifier
:
%
s
"
"
specifierKey
:
%
s
but
resolution
is
null
.
"
NS_ConvertUTF16toUTF8
(
aNormalizedSpecifier
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
specifierKey
)
.
get
(
)
)
)
;
return
Err
(
ResolveError
:
:
BlockedByNullEntry
)
;
}
MOZ_ASSERT
(
resolutionResult
)
;
nsAutoString
afterPrefix
(
Substring
(
aNormalizedSpecifier
specifierKey
.
Length
(
)
)
)
;
MOZ_ASSERT
(
StringEndsWith
(
resolutionResult
-
>
GetSpecOrDefault
(
)
"
/
"
_ns
)
)
;
nsCOMPtr
<
nsIURI
>
url
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
url
)
afterPrefix
nullptr
resolutionResult
)
;
if
(
NS_FAILED
(
rv
)
)
{
LOG
(
(
"
ImportMap
:
:
ResolveImportsMatch
normalizedSpecifier
:
%
s
"
"
specifierKey
:
%
s
resolutionResult
:
%
s
afterPrefix
:
%
s
"
"
but
URL
is
not
parsable
.
"
NS_ConvertUTF16toUTF8
(
aNormalizedSpecifier
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
specifierKey
)
.
get
(
)
resolutionResult
-
>
GetSpecOrDefault
(
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
afterPrefix
)
.
get
(
)
)
)
;
return
Err
(
ResolveError
:
:
BlockedByAfterPrefix
)
;
}
MOZ_ASSERT
(
url
)
;
if
(
!
StringBeginsWith
(
url
-
>
GetSpecOrDefault
(
)
resolutionResult
-
>
GetSpecOrDefault
(
)
)
)
{
LOG
(
(
"
ImportMap
:
:
ResolveImportsMatch
normalizedSpecifier
:
%
s
"
"
specifierKey
:
%
s
"
"
url
%
s
does
not
start
with
resolutionResult
%
s
.
"
NS_ConvertUTF16toUTF8
(
aNormalizedSpecifier
)
.
get
(
)
NS_ConvertUTF16toUTF8
(
specifierKey
)
.
get
(
)
url
-
>
GetSpecOrDefault
(
)
.
get
(
)
resolutionResult
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
return
Err
(
ResolveError
:
:
BlockedByBacktrackingPrefix
)
;
}
return
std
:
:
move
(
url
)
;
}
}
return
nsCOMPtr
<
nsIURI
>
(
nullptr
)
;
}
ResolveResult
ImportMap
:
:
ResolveModuleSpecifier
(
ImportMap
*
aImportMap
ScriptLoaderInterface
*
aLoader
LoadedScript
*
aScript
const
nsAString
&
aSpecifier
)
{
LOG
(
(
"
ImportMap
:
:
ResolveModuleSpecifier
specifier
:
%
s
"
NS_ConvertUTF16toUTF8
(
aSpecifier
)
.
get
(
)
)
)
;
nsCOMPtr
<
nsIURI
>
baseURL
;
if
(
aScript
)
{
baseURL
=
aScript
-
>
BaseURL
(
)
;
}
else
{
baseURL
=
aLoader
-
>
GetBaseURI
(
)
;
}
auto
parseResult
=
ParseURLLikeImportSpecifier
(
aSpecifier
baseURL
)
;
nsCOMPtr
<
nsIURI
>
asURL
;
if
(
parseResult
.
isOk
(
)
)
{
asURL
=
parseResult
.
unwrap
(
)
;
}
if
(
aImportMap
)
{
nsCString
baseURLString
=
baseURL
-
>
GetSpecOrDefault
(
)
;
nsAutoString
normalizedSpecifier
=
asURL
?
NS_ConvertUTF8toUTF16
(
asURL
-
>
GetSpecOrDefault
(
)
)
:
nsAutoString
{
aSpecifier
}
;
for
(
auto
&
&
[
scopePrefix
scopeImports
]
:
*
aImportMap
-
>
mScopes
)
{
if
(
scopePrefix
.
Equals
(
baseURLString
)
|
|
(
StringEndsWith
(
scopePrefix
"
/
"
_ns
)
&
&
StringBeginsWith
(
baseURLString
scopePrefix
)
)
)
{
auto
result
=
ResolveImportsMatch
(
normalizedSpecifier
asURL
scopeImports
.
get
(
)
)
;
if
(
result
.
isErr
(
)
)
{
return
result
.
propagateErr
(
)
;
}
nsCOMPtr
<
nsIURI
>
scopeImportsMatch
=
result
.
unwrap
(
)
;
if
(
scopeImportsMatch
)
{
LOG
(
(
"
ImportMap
:
:
ResolveModuleSpecifier
returns
scopeImportsMatch
:
%
s
"
scopeImportsMatch
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
return
WrapNotNull
(
scopeImportsMatch
)
;
}
}
}
auto
result
=
ResolveImportsMatch
(
normalizedSpecifier
asURL
aImportMap
-
>
mImports
.
get
(
)
)
;
if
(
result
.
isErr
(
)
)
{
return
result
.
propagateErr
(
)
;
}
nsCOMPtr
<
nsIURI
>
topLevelImportsMatch
=
result
.
unwrap
(
)
;
if
(
topLevelImportsMatch
)
{
LOG
(
(
"
ImportMap
:
:
ResolveModuleSpecifier
returns
topLevelImportsMatch
:
%
s
"
topLevelImportsMatch
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
return
WrapNotNull
(
topLevelImportsMatch
)
;
}
}
if
(
asURL
)
{
LOG
(
(
"
ImportMap
:
:
ResolveModuleSpecifier
returns
asURL
:
%
s
"
asURL
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
return
WrapNotNull
(
asURL
)
;
}
if
(
parseResult
.
unwrapErr
(
)
!
=
ResolveError
:
:
FailureMayBeBare
)
{
return
Err
(
ResolveError
:
:
Failure
)
;
}
return
Err
(
ResolveError
:
:
InvalidBareSpecifier
)
;
}
#
undef
LOG
#
undef
LOG_ENABLED
}
