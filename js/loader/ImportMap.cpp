#
include
"
ImportMap
.
h
"
#
include
"
js
/
Array
.
h
"
#
include
"
js
/
friend
/
ErrorMessages
.
h
"
#
include
"
js
/
JSON
.
h
"
#
include
"
ModuleLoaderBase
.
h
"
#
include
"
nsContentUtils
.
h
"
#
include
"
nsIScriptElement
.
h
"
#
include
"
nsIScriptError
.
h
"
#
include
"
nsJSUtils
.
h
"
#
include
"
nsNetUtil
.
h
"
#
include
"
ScriptLoadRequest
.
h
"
using
JS
:
:
SourceText
;
using
mozilla
:
:
LazyLogModule
;
using
mozilla
:
:
MakeUnique
;
using
mozilla
:
:
UniquePtr
;
namespace
JS
:
:
loader
{
LazyLogModule
ImportMap
:
:
gImportMapLog
(
"
ImportMap
"
)
;
#
undef
LOG
#
define
LOG
(
args
)
\
MOZ_LOG
(
ImportMap
:
:
gImportMapLog
mozilla
:
:
LogLevel
:
:
Debug
args
)
#
define
LOG_ENABLED
(
)
\
MOZ_LOG_TEST
(
ImportMap
:
:
gImportMapLog
mozilla
:
:
LogLevel
:
:
Debug
)
void
ReportWarningHelper
:
:
Report
(
const
char
*
aMessageName
const
nsTArray
<
nsString
>
&
aParams
)
const
{
mLoader
-
>
ReportWarningToConsole
(
mRequest
aMessageName
aParams
)
;
}
static
already_AddRefed
<
nsIURI
>
ParseURLLikeImportSpecifier
(
const
nsAString
&
aSpecifier
nsIURI
*
aBaseURL
)
{
nsCOMPtr
<
nsIURI
>
uri
;
nsresult
rv
;
if
(
StringBeginsWith
(
aSpecifier
u
"
/
"
_ns
)
|
|
StringBeginsWith
(
aSpecifier
u
"
.
/
"
_ns
)
|
|
StringBeginsWith
(
aSpecifier
u
"
.
.
/
"
_ns
)
)
{
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
aSpecifier
nullptr
aBaseURL
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
nullptr
;
}
return
uri
.
forget
(
)
;
}
rv
=
NS_NewURI
(
getter_AddRefs
(
uri
)
aSpecifier
)
;
if
(
NS_FAILED
(
rv
)
)
{
return
nullptr
;
}
return
uri
.
forget
(
)
;
}
static
void
NormalizeSpecifierKey
(
const
nsAString
&
aSpecifierKey
nsIURI
*
aBaseURL
const
ReportWarningHelper
&
aWarning
nsAString
&
aRetVal
)
{
if
(
aSpecifierKey
.
IsEmpty
(
)
)
{
aWarning
.
Report
(
"
ImportMapEmptySpecifierKeys
"
)
;
aRetVal
=
EmptyString
(
)
;
return
;
}
nsCOMPtr
<
nsIURI
>
url
=
ParseURLLikeImportSpecifier
(
aSpecifierKey
aBaseURL
)
;
if
(
url
)
{
aRetVal
=
NS_ConvertUTF8toUTF16
(
url
-
>
GetSpecOrDefault
(
)
)
;
return
;
}
aRetVal
=
aSpecifierKey
;
}
static
UniquePtr
<
SpecifierMap
>
SortAndNormalizeSpecifierMap
(
JSContext
*
aCx
JS
:
:
HandleObject
aOriginalMap
nsIURI
*
aBaseURL
const
ReportWarningHelper
&
aWarning
)
{
UniquePtr
<
SpecifierMap
>
normalized
=
MakeUnique
<
SpecifierMap
>
(
)
;
JS
:
:
Rooted
<
JS
:
:
IdVector
>
specifierKeys
(
aCx
JS
:
:
IdVector
(
aCx
)
)
;
if
(
!
JS_Enumerate
(
aCx
aOriginalMap
&
specifierKeys
)
)
{
return
nullptr
;
}
for
(
size_t
i
=
0
;
i
<
specifierKeys
.
length
(
)
;
i
+
+
)
{
const
JS
:
:
RootedId
specifierId
(
aCx
specifierKeys
[
i
]
)
;
nsAutoJSString
specifierKey
;
NS_ENSURE_TRUE
(
specifierKey
.
init
(
aCx
specifierId
)
nullptr
)
;
nsString
normalizedSpecifierKey
;
NormalizeSpecifierKey
(
specifierKey
aBaseURL
aWarning
normalizedSpecifierKey
)
;
if
(
normalizedSpecifierKey
.
IsEmpty
(
)
)
{
continue
;
}
JS
:
:
RootedValue
idVal
(
aCx
)
;
NS_ENSURE_TRUE
(
JS_GetPropertyById
(
aCx
aOriginalMap
specifierId
&
idVal
)
nullptr
)
;
if
(
!
idVal
.
isString
(
)
)
{
aWarning
.
Report
(
"
ImportMapAddressesNotStrings
"
)
;
normalized
-
>
insert_or_assign
(
normalizedSpecifierKey
nullptr
)
;
continue
;
}
nsAutoJSString
value
;
NS_ENSURE_TRUE
(
value
.
init
(
aCx
idVal
)
nullptr
)
;
nsCOMPtr
<
nsIURI
>
addressURL
=
ParseURLLikeImportSpecifier
(
value
aBaseURL
)
;
if
(
!
addressURL
)
{
AutoTArray
<
nsString
1
>
params
;
params
.
AppendElement
(
value
)
;
aWarning
.
Report
(
"
ImportMapInvalidAddress
"
params
)
;
normalized
-
>
insert_or_assign
(
normalizedSpecifierKey
nullptr
)
;
continue
;
}
nsCString
address
=
addressURL
-
>
GetSpecOrDefault
(
)
;
if
(
StringEndsWith
(
specifierKey
u
"
/
"
_ns
)
&
&
!
StringEndsWith
(
address
"
/
"
_ns
)
)
{
AutoTArray
<
nsString
2
>
params
;
params
.
AppendElement
(
specifierKey
)
;
params
.
AppendElement
(
NS_ConvertUTF8toUTF16
(
address
)
)
;
aWarning
.
Report
(
"
ImportMapAddressNotEndsWithSlash
"
params
)
;
normalized
-
>
insert_or_assign
(
normalizedSpecifierKey
nullptr
)
;
continue
;
}
LOG
(
(
"
ImportMap
:
:
SortAndNormalizeSpecifierMap
{
%
s
%
s
}
"
NS_ConvertUTF16toUTF8
(
normalizedSpecifierKey
)
.
get
(
)
addressURL
-
>
GetSpecOrDefault
(
)
.
get
(
)
)
)
;
normalized
-
>
insert_or_assign
(
normalizedSpecifierKey
addressURL
)
;
}
return
normalized
;
}
static
bool
IsMapObject
(
JSContext
*
aCx
JS
:
:
HandleValue
aMapVal
bool
*
aIsMap
)
{
MOZ_ASSERT
(
aIsMap
)
;
*
aIsMap
=
false
;
if
(
!
aMapVal
.
isObject
(
)
)
{
return
true
;
}
bool
isArray
;
if
(
!
IsArrayObject
(
aCx
aMapVal
&
isArray
)
)
{
return
false
;
}
*
aIsMap
=
!
isArray
;
return
true
;
}
static
UniquePtr
<
ScopeMap
>
SortAndNormalizeScopes
(
JSContext
*
aCx
JS
:
:
HandleObject
aOriginalMap
nsIURI
*
aBaseURL
const
ReportWarningHelper
&
aWarning
)
{
JS
:
:
Rooted
<
JS
:
:
IdVector
>
scopeKeys
(
aCx
JS
:
:
IdVector
(
aCx
)
)
;
if
(
!
JS_Enumerate
(
aCx
aOriginalMap
&
scopeKeys
)
)
{
return
nullptr
;
}
UniquePtr
<
ScopeMap
>
normalized
=
MakeUnique
<
ScopeMap
>
(
)
;
for
(
size_t
i
=
0
;
i
<
scopeKeys
.
length
(
)
;
i
+
+
)
{
const
JS
:
:
RootedId
scopeKey
(
aCx
scopeKeys
[
i
]
)
;
nsAutoJSString
scopePrefix
;
NS_ENSURE_TRUE
(
scopePrefix
.
init
(
aCx
scopeKey
)
nullptr
)
;
JS
:
:
RootedValue
mapVal
(
aCx
)
;
NS_ENSURE_TRUE
(
JS_GetPropertyById
(
aCx
aOriginalMap
scopeKey
&
mapVal
)
nullptr
)
;
bool
isMap
;
if
(
!
IsMapObject
(
aCx
mapVal
&
isMap
)
)
{
return
nullptr
;
}
if
(
!
isMap
)
{
JS_ReportErrorNumberUC
(
aCx
js
:
:
GetErrorMessage
nullptr
JSMSG_IMPORT_MAPS_SCOPE_VALUE_NOT_A_MAP
scopePrefix
.
get
(
)
)
;
return
nullptr
;
}
nsCOMPtr
<
nsIURI
>
scopePrefixURL
;
nsresult
rv
=
NS_NewURI
(
getter_AddRefs
(
scopePrefixURL
)
scopePrefix
nullptr
aBaseURL
)
;
if
(
NS_FAILED
(
rv
)
)
{
AutoTArray
<
nsString
1
>
params
;
params
.
AppendElement
(
scopePrefix
)
;
aWarning
.
Report
(
"
ImportMapScopePrefixNotParseable
"
params
)
;
continue
;
}
nsCString
normalizedScopePrefix
=
scopePrefixURL
-
>
GetSpecOrDefault
(
)
;
JS
:
:
RootedObject
potentialSpecifierMap
(
aCx
&
mapVal
.
toObject
(
)
)
;
UniquePtr
<
SpecifierMap
>
specifierMap
=
SortAndNormalizeSpecifierMap
(
aCx
potentialSpecifierMap
aBaseURL
aWarning
)
;
if
(
!
specifierMap
)
{
return
nullptr
;
}
normalized
-
>
insert_or_assign
(
normalizedScopePrefix
std
:
:
move
(
specifierMap
)
)
;
}
return
normalized
;
}
UniquePtr
<
ImportMap
>
ImportMap
:
:
ParseString
(
JSContext
*
aCx
SourceText
<
char16_t
>
&
aInput
nsIURI
*
aBaseURL
const
ReportWarningHelper
&
aWarning
)
{
JS
:
:
Rooted
<
JS
:
:
Value
>
parsedVal
(
aCx
)
;
if
(
!
JS_ParseJSON
(
aCx
aInput
.
get
(
)
aInput
.
length
(
)
&
parsedVal
)
)
{
NS_WARNING
(
"
Parsing
Import
map
string
failed
"
)
;
return
nullptr
;
}
bool
isMap
;
if
(
!
IsMapObject
(
aCx
parsedVal
&
isMap
)
)
{
return
nullptr
;
}
if
(
!
isMap
)
{
JS_ReportErrorNumberASCII
(
aCx
js
:
:
GetErrorMessage
nullptr
JSMSG_IMPORT_MAPS_NOT_A_MAP
)
;
return
nullptr
;
}
JS
:
:
RootedObject
parsedObj
(
aCx
&
parsedVal
.
toObject
(
)
)
;
JS
:
:
RootedValue
importsVal
(
aCx
)
;
if
(
!
JS_GetProperty
(
aCx
parsedObj
"
imports
"
&
importsVal
)
)
{
return
nullptr
;
}
UniquePtr
<
SpecifierMap
>
sortedAndNormalizedImports
=
nullptr
;
if
(
!
importsVal
.
isUndefined
(
)
)
{
bool
isMap
;
if
(
!
IsMapObject
(
aCx
importsVal
&
isMap
)
)
{
return
nullptr
;
}
if
(
!
isMap
)
{
JS_ReportErrorNumberASCII
(
aCx
js
:
:
GetErrorMessage
nullptr
JSMSG_IMPORT_MAPS_IMPORTS_NOT_A_MAP
)
;
return
nullptr
;
}
JS
:
:
RootedObject
importsObj
(
aCx
&
importsVal
.
toObject
(
)
)
;
sortedAndNormalizedImports
=
SortAndNormalizeSpecifierMap
(
aCx
importsObj
aBaseURL
aWarning
)
;
if
(
!
sortedAndNormalizedImports
)
{
return
nullptr
;
}
}
JS
:
:
RootedValue
scopesVal
(
aCx
)
;
if
(
!
JS_GetProperty
(
aCx
parsedObj
"
scopes
"
&
scopesVal
)
)
{
return
nullptr
;
}
UniquePtr
<
ScopeMap
>
sortedAndNormalizedScopes
=
nullptr
;
if
(
!
scopesVal
.
isUndefined
(
)
)
{
bool
isMap
;
if
(
!
IsMapObject
(
aCx
scopesVal
&
isMap
)
)
{
return
nullptr
;
}
if
(
!
isMap
)
{
JS_ReportErrorNumberASCII
(
aCx
js
:
:
GetErrorMessage
nullptr
JSMSG_IMPORT_MAPS_SCOPES_NOT_A_MAP
)
;
return
nullptr
;
}
JS
:
:
RootedObject
scopesObj
(
aCx
&
scopesVal
.
toObject
(
)
)
;
sortedAndNormalizedScopes
=
SortAndNormalizeScopes
(
aCx
scopesObj
aBaseURL
aWarning
)
;
if
(
!
sortedAndNormalizedScopes
)
{
return
nullptr
;
}
}
JS
:
:
Rooted
<
JS
:
:
IdVector
>
keys
(
aCx
JS
:
:
IdVector
(
aCx
)
)
;
if
(
!
JS_Enumerate
(
aCx
parsedObj
&
keys
)
)
{
return
nullptr
;
}
for
(
size_t
i
=
0
;
i
<
keys
.
length
(
)
;
i
+
+
)
{
const
JS
:
:
RootedId
key
(
aCx
keys
[
i
]
)
;
nsAutoJSString
val
;
NS_ENSURE_TRUE
(
val
.
init
(
aCx
key
)
nullptr
)
;
if
(
val
.
EqualsLiteral
(
"
imports
"
)
|
|
val
.
EqualsLiteral
(
"
scopes
"
)
)
{
continue
;
}
AutoTArray
<
nsString
1
>
params
;
params
.
AppendElement
(
val
)
;
aWarning
.
Report
(
"
ImportMapInvalidTopLevelKey
"
params
)
;
}
if
(
!
sortedAndNormalizedImports
)
{
sortedAndNormalizedImports
=
MakeUnique
<
SpecifierMap
>
(
)
;
}
if
(
!
sortedAndNormalizedScopes
)
{
sortedAndNormalizedScopes
=
MakeUnique
<
ScopeMap
>
(
)
;
}
return
MakeUnique
<
ImportMap
>
(
std
:
:
move
(
sortedAndNormalizedImports
)
std
:
:
move
(
sortedAndNormalizedScopes
)
)
;
}
#
undef
LOG
#
undef
LOG_ENABLED
}
