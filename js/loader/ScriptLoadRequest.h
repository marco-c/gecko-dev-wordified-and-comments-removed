#
ifndef
js_loader_ScriptLoadRequest_h
#
define
js_loader_ScriptLoadRequest_h
#
include
"
js
/
experimental
/
JSStencil
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
SourceText
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
dom
/
CacheExpirationTime
.
h
"
#
include
"
mozilla
/
dom
/
SRIMetadata
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
PreloaderBase
.
h
"
#
include
"
mozilla
/
RefPtr
.
h
"
#
include
"
mozilla
/
SharedSubResourceCache
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsIGlobalObject
.
h
"
#
include
"
LoadedScript
.
h
"
#
include
"
ScriptKind
.
h
"
#
include
"
ScriptFetchOptions
.
h
"
namespace
mozilla
:
:
dom
{
class
ScriptLoadContext
;
class
WorkerLoadContext
;
class
WorkletLoadContext
;
enum
class
RequestPriority
:
uint8_t
;
}
namespace
mozilla
:
:
loader
{
class
SyncLoadContext
;
}
namespace
JS
:
:
loader
{
class
LoadContextBase
;
class
ModuleLoadRequest
;
class
ScriptLoadRequestList
;
class
ScriptLoadRequest
:
public
nsISupports
private
mozilla
:
:
LinkedListElement
<
ScriptLoadRequest
>
public
LoadedScriptDelegate
<
ScriptLoadRequest
>
{
using
super
=
LinkedListElement
<
ScriptLoadRequest
>
;
friend
class
mozilla
:
:
LinkedListElement
<
ScriptLoadRequest
>
;
friend
class
ScriptLoadRequestList
;
protected
:
virtual
~
ScriptLoadRequest
(
)
;
public
:
using
SRIMetadata
=
mozilla
:
:
dom
:
:
SRIMetadata
;
ScriptLoadRequest
(
ScriptKind
aKind
nsIURI
*
aURI
mozilla
:
:
dom
:
:
ReferrerPolicy
aReferrerPolicy
ScriptFetchOptions
*
aFetchOptions
const
SRIMetadata
&
aIntegrity
nsIURI
*
aReferrer
LoadContextBase
*
aContext
)
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS
(
ScriptLoadRequest
)
using
super
:
:
getNext
;
using
super
:
:
isInList
;
template
<
typename
T
typename
D
=
DeletePolicy
<
T
>
>
using
UniquePtr
=
mozilla
:
:
UniquePtr
<
T
D
>
;
bool
IsModuleRequest
(
)
const
{
return
mKind
=
=
ScriptKind
:
:
eModule
;
}
bool
IsImportMapRequest
(
)
const
{
return
mKind
=
=
ScriptKind
:
:
eImportMap
;
}
ModuleLoadRequest
*
AsModuleRequest
(
)
;
const
ModuleLoadRequest
*
AsModuleRequest
(
)
const
;
bool
IsCacheable
(
)
const
;
CacheExpirationTime
ExpirationTime
(
)
const
{
return
mExpirationTime
;
}
void
SetMinimumExpirationTime
(
const
CacheExpirationTime
&
aExpirationTime
)
{
mExpirationTime
.
SetMinimum
(
aExpirationTime
)
;
}
virtual
bool
IsTopLevel
(
)
const
{
return
true
;
}
;
virtual
void
Cancel
(
)
;
virtual
void
SetReady
(
)
;
enum
class
State
:
uint8_t
{
CheckingCache
PendingFetchingError
Fetching
Compiling
Ready
Canceled
}
;
bool
IsCheckingCache
(
)
const
{
return
mState
=
=
State
:
:
CheckingCache
;
}
bool
IsFetching
(
)
const
{
return
mState
=
=
State
:
:
Fetching
;
}
bool
IsCompiling
(
)
const
{
return
mState
=
=
State
:
:
Compiling
;
}
bool
IsCanceled
(
)
const
{
return
mState
=
=
State
:
:
Canceled
;
}
bool
IsPendingFetchingError
(
)
const
{
return
mState
=
=
State
:
:
PendingFetchingError
;
}
bool
IsFinished
(
)
const
{
return
mState
=
=
State
:
:
Ready
|
|
mState
=
=
State
:
:
Canceled
;
}
mozilla
:
:
dom
:
:
RequestPriority
FetchPriority
(
)
const
{
return
mFetchOptions
-
>
mFetchPriority
;
}
enum
mozilla
:
:
dom
:
:
ReferrerPolicy
ReferrerPolicy
(
)
const
{
return
mReferrerPolicy
;
}
enum
ParserMetadata
ParserMetadata
(
)
const
{
return
mFetchOptions
-
>
mParserMetadata
;
}
const
nsString
&
Nonce
(
)
const
{
return
mFetchOptions
-
>
mNonce
;
}
nsIPrincipal
*
TriggeringPrincipal
(
)
const
{
return
mFetchOptions
-
>
mTriggeringPrincipal
;
}
void
CacheEntryFound
(
LoadedScript
*
aLoadedScript
)
;
void
NoCacheEntryFound
(
)
;
void
SetPendingFetchingError
(
)
;
bool
PassedConditionForDiskCache
(
)
const
{
return
mDiskCachingPlan
=
=
CachingPlan
:
:
PassedCondition
|
|
mDiskCachingPlan
=
=
CachingPlan
:
:
MarkedForCache
;
}
bool
PassedConditionForMemoryCache
(
)
const
{
return
mMemoryCachingPlan
=
=
CachingPlan
:
:
PassedCondition
|
|
mMemoryCachingPlan
=
=
CachingPlan
:
:
MarkedForCache
;
}
bool
PassedConditionForEitherCache
(
)
const
{
return
PassedConditionForDiskCache
(
)
|
|
PassedConditionForMemoryCache
(
)
;
}
void
MarkSkippedDiskCaching
(
)
{
MOZ_ASSERT
(
mDiskCachingPlan
=
=
CachingPlan
:
:
Uninitialized
|
|
mDiskCachingPlan
=
=
CachingPlan
:
:
PassedCondition
)
;
mDiskCachingPlan
=
CachingPlan
:
:
Skipped
;
}
void
MarkSkippedMemoryCaching
(
)
{
MOZ_ASSERT
(
mMemoryCachingPlan
=
=
CachingPlan
:
:
Uninitialized
|
|
mMemoryCachingPlan
=
=
CachingPlan
:
:
PassedCondition
)
;
mMemoryCachingPlan
=
CachingPlan
:
:
Skipped
;
}
void
MarkSkippedAllCaching
(
)
{
MarkSkippedDiskCaching
(
)
;
MarkSkippedMemoryCaching
(
)
;
}
void
MarkPassedConditionForDiskCache
(
)
{
MOZ_ASSERT
(
mDiskCachingPlan
=
=
CachingPlan
:
:
Uninitialized
)
;
mDiskCachingPlan
=
CachingPlan
:
:
PassedCondition
;
}
void
MarkPassedConditionForMemoryCache
(
)
{
MOZ_ASSERT
(
mMemoryCachingPlan
=
=
CachingPlan
:
:
Uninitialized
)
;
mMemoryCachingPlan
=
CachingPlan
:
:
PassedCondition
;
}
bool
IsMarkedForDiskCache
(
)
const
{
return
mDiskCachingPlan
=
=
CachingPlan
:
:
MarkedForCache
;
}
bool
IsMarkedForMemoryCache
(
)
const
{
return
mMemoryCachingPlan
=
=
CachingPlan
:
:
MarkedForCache
;
}
bool
IsMarkedForEitherCache
(
)
const
{
return
IsMarkedForDiskCache
(
)
|
|
IsMarkedForMemoryCache
(
)
;
}
protected
:
void
MarkForCache
(
)
{
MOZ_ASSERT
(
mDiskCachingPlan
=
=
CachingPlan
:
:
PassedCondition
|
|
mMemoryCachingPlan
=
=
CachingPlan
:
:
PassedCondition
)
;
if
(
mDiskCachingPlan
=
=
CachingPlan
:
:
PassedCondition
)
{
mDiskCachingPlan
=
CachingPlan
:
:
MarkedForCache
;
}
if
(
mMemoryCachingPlan
=
=
CachingPlan
:
:
PassedCondition
)
{
mMemoryCachingPlan
=
CachingPlan
:
:
MarkedForCache
;
}
}
public
:
void
MarkScriptForCache
(
JSScript
*
aScript
)
;
mozilla
:
:
CORSMode
CORSMode
(
)
const
{
return
mFetchOptions
-
>
mCORSMode
;
}
bool
HasLoadContext
(
)
const
{
return
mLoadContext
;
}
bool
HasScriptLoadContext
(
)
const
;
bool
HasWorkerLoadContext
(
)
const
;
mozilla
:
:
dom
:
:
ScriptLoadContext
*
GetScriptLoadContext
(
)
;
const
mozilla
:
:
dom
:
:
ScriptLoadContext
*
GetScriptLoadContext
(
)
const
;
mozilla
:
:
loader
:
:
SyncLoadContext
*
GetSyncLoadContext
(
)
;
mozilla
:
:
dom
:
:
WorkerLoadContext
*
GetWorkerLoadContext
(
)
;
mozilla
:
:
dom
:
:
WorkletLoadContext
*
GetWorkletLoadContext
(
)
;
const
LoadedScript
*
getLoadedScript
(
)
const
{
return
mLoadedScript
.
get
(
)
;
}
LoadedScript
*
getLoadedScript
(
)
{
return
mLoadedScript
.
get
(
)
;
}
void
SetBaseURLFromChannelAndOriginalURI
(
nsIChannel
*
aChannel
nsIURI
*
aOriginalURI
)
;
const
ScriptKind
mKind
;
State
mState
;
bool
mFetchSourceOnly
;
bool
mHasSourceMapURL_
;
enum
class
CachingPlan
:
uint8_t
{
Uninitialized
Skipped
PassedCondition
MarkedForCache
}
;
CachingPlan
mDiskCachingPlan
=
CachingPlan
:
:
Uninitialized
;
CachingPlan
mMemoryCachingPlan
=
CachingPlan
:
:
Uninitialized
;
enum
mozilla
:
:
dom
:
:
ReferrerPolicy
mReferrerPolicy
;
CacheExpirationTime
mExpirationTime
=
CacheExpirationTime
:
:
Never
(
)
;
RefPtr
<
ScriptFetchOptions
>
mFetchOptions
;
RefPtr
<
mozilla
:
:
SubResourceNetworkMetadataHolder
>
mNetworkMetadata
;
const
SRIMetadata
mIntegrity
;
const
nsCOMPtr
<
nsIURI
>
mReferrer
;
nsString
mMaybeSourceMapURL_
;
bool
HasSourceMapURL
(
)
const
{
return
mHasSourceMapURL_
;
}
const
nsString
&
GetSourceMapURL
(
)
const
{
MOZ_ASSERT
(
mHasSourceMapURL_
)
;
return
mMaybeSourceMapURL_
;
}
void
SetSourceMapURL
(
const
nsString
&
aSourceMapURL
)
{
MOZ_ASSERT
(
!
mHasSourceMapURL_
)
;
mMaybeSourceMapURL_
=
aSourceMapURL
;
mHasSourceMapURL_
=
true
;
}
const
nsCOMPtr
<
nsIURI
>
mURI
;
nsCOMPtr
<
nsIPrincipal
>
mOriginPrincipal
;
nsAutoCString
mURL
;
nsCOMPtr
<
nsIURI
>
mBaseURL
;
RefPtr
<
LoadedScript
>
mLoadedScript
;
RefPtr
<
LoadContextBase
>
mLoadContext
;
uint64_t
mEarlyHintPreloaderId
;
}
;
}
#
endif
