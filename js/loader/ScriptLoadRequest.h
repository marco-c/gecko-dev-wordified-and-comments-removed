#
ifndef
js_loader_ScriptLoadRequest_h
#
define
js_loader_ScriptLoadRequest_h
#
include
"
js
/
AllocPolicy
.
h
"
#
include
"
js
/
RootingAPI
.
h
"
#
include
"
js
/
SourceText
.
h
"
#
include
"
js
/
TypeDecls
.
h
"
#
include
"
mozilla
/
Atomics
.
h
"
#
include
"
mozilla
/
Assertions
.
h
"
#
include
"
mozilla
/
CORSMode
.
h
"
#
include
"
mozilla
/
dom
/
SRIMetadata
.
h
"
#
include
"
mozilla
/
dom
/
ReferrerPolicyBinding
.
h
"
#
include
"
mozilla
/
LinkedList
.
h
"
#
include
"
mozilla
/
Maybe
.
h
"
#
include
"
mozilla
/
MaybeOneOf
.
h
"
#
include
"
mozilla
/
PreloaderBase
.
h
"
#
include
"
mozilla
/
StaticPrefs_dom
.
h
"
#
include
"
mozilla
/
Utf8
.
h
"
#
include
"
mozilla
/
Variant
.
h
"
#
include
"
mozilla
/
Vector
.
h
"
#
include
"
nsCOMPtr
.
h
"
#
include
"
nsCycleCollectionParticipant
.
h
"
#
include
"
nsIGlobalObject
.
h
"
#
include
"
LoadedScript
.
h
"
#
include
"
ScriptKind
.
h
"
#
include
"
ScriptFetchOptions
.
h
"
#
include
"
nsIScriptElement
.
h
"
class
nsICacheInfoChannel
;
namespace
mozilla
:
:
dom
{
class
ScriptLoadContext
;
class
WorkerLoadContext
;
class
WorkletLoadContext
;
enum
class
RequestPriority
:
uint8_t
;
}
namespace
mozilla
:
:
loader
{
class
ComponentLoadContext
;
}
namespace
JS
{
namespace
loader
{
using
Utf8Unit
=
mozilla
:
:
Utf8Unit
;
class
LoadContextBase
;
class
ModuleLoadRequest
;
class
ScriptLoadRequestList
;
class
ScriptLoadRequest
:
public
nsISupports
private
mozilla
:
:
LinkedListElement
<
ScriptLoadRequest
>
{
using
super
=
LinkedListElement
<
ScriptLoadRequest
>
;
friend
class
mozilla
:
:
LinkedListElement
<
ScriptLoadRequest
>
;
friend
class
ScriptLoadRequestList
;
protected
:
virtual
~
ScriptLoadRequest
(
)
;
public
:
using
SRIMetadata
=
mozilla
:
:
dom
:
:
SRIMetadata
;
ScriptLoadRequest
(
ScriptKind
aKind
nsIURI
*
aURI
mozilla
:
:
dom
:
:
ReferrerPolicy
aReferrerPolicy
ScriptFetchOptions
*
aFetchOptions
const
SRIMetadata
&
aIntegrity
nsIURI
*
aReferrer
LoadContextBase
*
aContext
)
;
NS_DECL_CYCLE_COLLECTING_ISUPPORTS
NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS
(
ScriptLoadRequest
)
using
super
:
:
getNext
;
using
super
:
:
isInList
;
template
<
typename
T
>
using
VariantType
=
mozilla
:
:
VariantType
<
T
>
;
template
<
typename
.
.
.
Ts
>
using
Variant
=
mozilla
:
:
Variant
<
Ts
.
.
.
>
;
template
<
typename
T
typename
D
=
JS
:
:
DeletePolicy
<
T
>
>
using
UniquePtr
=
mozilla
:
:
UniquePtr
<
T
D
>
;
using
MaybeSourceText
=
mozilla
:
:
MaybeOneOf
<
JS
:
:
SourceText
<
char16_t
>
JS
:
:
SourceText
<
Utf8Unit
>
>
;
bool
IsModuleRequest
(
)
const
{
return
mKind
=
=
ScriptKind
:
:
eModule
;
}
bool
IsImportMapRequest
(
)
const
{
return
mKind
=
=
ScriptKind
:
:
eImportMap
;
}
ModuleLoadRequest
*
AsModuleRequest
(
)
;
const
ModuleLoadRequest
*
AsModuleRequest
(
)
const
;
virtual
bool
IsTopLevel
(
)
const
{
return
true
;
}
;
virtual
void
Cancel
(
)
;
virtual
void
SetReady
(
)
;
enum
class
State
:
uint8_t
{
CheckingCache
PendingFetchingError
Fetching
Compiling
LoadingImports
Ready
Canceled
}
;
bool
IsCheckingCache
(
)
const
{
return
mState
=
=
State
:
:
CheckingCache
;
}
bool
IsFetching
(
)
const
{
return
mState
=
=
State
:
:
Fetching
;
}
bool
IsCompiling
(
)
const
{
return
mState
=
=
State
:
:
Compiling
;
}
bool
IsLoadingImports
(
)
const
{
return
mState
=
=
State
:
:
LoadingImports
;
}
bool
IsCanceled
(
)
const
{
return
mState
=
=
State
:
:
Canceled
;
}
bool
IsPendingFetchingError
(
)
const
{
return
mState
=
=
State
:
:
PendingFetchingError
;
}
bool
IsFinished
(
)
const
{
return
mState
=
=
State
:
:
Ready
|
|
mState
=
=
State
:
:
Canceled
;
}
enum
class
DataType
:
uint8_t
{
eUnknown
eTextSource
eBytecode
}
;
bool
IsUnknownDataType
(
)
const
{
return
mDataType
=
=
DataType
:
:
eUnknown
;
}
bool
IsTextSource
(
)
const
{
return
mDataType
=
=
DataType
:
:
eTextSource
;
}
bool
IsSource
(
)
const
{
return
IsTextSource
(
)
;
}
void
SetUnknownDataType
(
)
{
mDataType
=
DataType
:
:
eUnknown
;
mScriptData
.
reset
(
)
;
}
void
SetTextSource
(
LoadContextBase
*
aMaybeLoadContext
)
{
MOZ_ASSERT
(
IsUnknownDataType
(
)
)
;
mDataType
=
DataType
:
:
eTextSource
;
mScriptData
.
emplace
(
VariantType
<
ScriptTextBuffer
<
Utf8Unit
>
>
(
)
)
;
}
template
<
typename
Unit
>
using
ScriptTextBuffer
=
mozilla
:
:
Vector
<
Unit
0
js
:
:
MallocAllocPolicy
>
;
bool
IsUTF16Text
(
)
const
{
return
mScriptData
-
>
is
<
ScriptTextBuffer
<
char16_t
>
>
(
)
;
}
bool
IsUTF8Text
(
)
const
{
return
mScriptData
-
>
is
<
ScriptTextBuffer
<
Utf8Unit
>
>
(
)
;
}
template
<
typename
Unit
>
const
ScriptTextBuffer
<
Unit
>
&
ScriptText
(
)
const
{
MOZ_ASSERT
(
IsTextSource
(
)
)
;
return
mScriptData
-
>
as
<
ScriptTextBuffer
<
Unit
>
>
(
)
;
}
template
<
typename
Unit
>
ScriptTextBuffer
<
Unit
>
&
ScriptText
(
)
{
MOZ_ASSERT
(
IsTextSource
(
)
)
;
return
mScriptData
-
>
as
<
ScriptTextBuffer
<
Unit
>
>
(
)
;
}
size_t
ScriptTextLength
(
)
const
{
MOZ_ASSERT
(
IsTextSource
(
)
)
;
return
IsUTF16Text
(
)
?
ScriptText
<
char16_t
>
(
)
.
length
(
)
:
ScriptText
<
Utf8Unit
>
(
)
.
length
(
)
;
}
nsresult
GetScriptSource
(
JSContext
*
aCx
MaybeSourceText
*
aMaybeSource
LoadContextBase
*
aLoadContext
)
;
void
ClearScriptText
(
)
{
MOZ_ASSERT
(
IsTextSource
(
)
)
;
return
IsUTF16Text
(
)
?
ScriptText
<
char16_t
>
(
)
.
clearAndFree
(
)
:
ScriptText
<
Utf8Unit
>
(
)
.
clearAndFree
(
)
;
}
size_t
ReceivedScriptTextLength
(
)
const
{
return
mReceivedScriptTextLength
;
}
void
SetReceivedScriptTextLength
(
size_t
aLength
)
{
mReceivedScriptTextLength
=
aLength
;
}
mozilla
:
:
dom
:
:
RequestPriority
FetchPriority
(
)
const
{
return
mFetchOptions
-
>
mFetchPriority
;
}
enum
mozilla
:
:
dom
:
:
ReferrerPolicy
ReferrerPolicy
(
)
const
{
return
mReferrerPolicy
;
}
void
UpdateReferrerPolicy
(
mozilla
:
:
dom
:
:
ReferrerPolicy
aReferrerPolicy
)
{
mReferrerPolicy
=
aReferrerPolicy
;
}
enum
ParserMetadata
ParserMetadata
(
)
const
{
return
mFetchOptions
-
>
mParserMetadata
;
}
const
nsString
&
Nonce
(
)
const
{
return
mFetchOptions
-
>
mNonce
;
}
nsIPrincipal
*
TriggeringPrincipal
(
)
const
{
return
mFetchOptions
-
>
mTriggeringPrincipal
;
}
void
ClearScriptSource
(
)
;
void
NoCacheEntryFound
(
)
;
void
SetPendingFetchingError
(
)
;
void
MarkForBytecodeEncoding
(
JSScript
*
aScript
)
;
bool
IsMarkedForBytecodeEncoding
(
)
const
;
bool
IsBytecode
(
)
const
{
return
mDataType
=
=
DataType
:
:
eBytecode
;
}
void
SetBytecode
(
)
;
JS
:
:
TranscodeBuffer
&
SRIAndBytecode
(
)
{
MOZ_ASSERT
(
IsBytecode
(
)
|
|
IsSource
(
)
)
;
return
mScriptBytecode
;
}
JS
:
:
TranscodeRange
Bytecode
(
)
const
{
MOZ_ASSERT
(
IsBytecode
(
)
)
;
const
auto
&
bytecode
=
mScriptBytecode
;
auto
offset
=
mBytecodeOffset
;
return
JS
:
:
TranscodeRange
(
bytecode
.
begin
(
)
+
offset
bytecode
.
length
(
)
-
offset
)
;
}
size_t
GetSRILength
(
)
const
{
MOZ_ASSERT
(
IsBytecode
(
)
|
|
IsSource
(
)
)
;
return
mBytecodeOffset
;
}
void
SetSRILength
(
size_t
sriLength
)
{
MOZ_ASSERT
(
IsBytecode
(
)
|
|
IsSource
(
)
)
;
mBytecodeOffset
=
JS
:
:
AlignTranscodingBytecodeOffset
(
sriLength
)
;
}
void
DropBytecode
(
)
{
MOZ_ASSERT
(
IsBytecode
(
)
|
|
IsSource
(
)
)
;
mScriptBytecode
.
clearAndFree
(
)
;
}
mozilla
:
:
CORSMode
CORSMode
(
)
const
{
return
mFetchOptions
-
>
mCORSMode
;
}
void
DropBytecodeCacheReferences
(
)
;
bool
HasLoadContext
(
)
const
{
return
mLoadContext
;
}
bool
HasScriptLoadContext
(
)
const
;
bool
HasWorkerLoadContext
(
)
const
;
mozilla
:
:
dom
:
:
ScriptLoadContext
*
GetScriptLoadContext
(
)
;
mozilla
:
:
loader
:
:
ComponentLoadContext
*
GetComponentLoadContext
(
)
;
mozilla
:
:
dom
:
:
WorkerLoadContext
*
GetWorkerLoadContext
(
)
;
mozilla
:
:
dom
:
:
WorkletLoadContext
*
GetWorkletLoadContext
(
)
;
const
ScriptKind
mKind
;
State
mState
;
bool
mFetchSourceOnly
;
DataType
mDataType
;
enum
mozilla
:
:
dom
:
:
ReferrerPolicy
mReferrerPolicy
;
RefPtr
<
ScriptFetchOptions
>
mFetchOptions
;
const
SRIMetadata
mIntegrity
;
const
nsCOMPtr
<
nsIURI
>
mReferrer
;
mozilla
:
:
Maybe
<
nsString
>
mSourceMapURL
;
mozilla
:
:
Maybe
<
Variant
<
ScriptTextBuffer
<
char16_t
>
ScriptTextBuffer
<
Utf8Unit
>
>
>
mScriptData
;
size_t
mReceivedScriptTextLength
;
mozilla
:
:
Vector
<
uint8_t
>
mScriptBytecode
;
uint32_t
mBytecodeOffset
;
const
nsCOMPtr
<
nsIURI
>
mURI
;
nsCOMPtr
<
nsIPrincipal
>
mOriginPrincipal
;
nsAutoCString
mURL
;
nsCOMPtr
<
nsIURI
>
mBaseURL
;
RefPtr
<
LoadedScript
>
mLoadedScript
;
JS
:
:
Heap
<
JSScript
*
>
mScriptForBytecodeEncoding
;
nsCOMPtr
<
nsICacheInfoChannel
>
mCacheInfo
;
RefPtr
<
LoadContextBase
>
mLoadContext
;
uint64_t
mEarlyHintPreloaderId
;
}
;
class
ScriptLoadRequestList
:
private
mozilla
:
:
LinkedList
<
ScriptLoadRequest
>
{
using
super
=
mozilla
:
:
LinkedList
<
ScriptLoadRequest
>
;
public
:
~
ScriptLoadRequestList
(
)
;
void
CancelRequestsAndClear
(
)
;
#
ifdef
DEBUG
bool
Contains
(
ScriptLoadRequest
*
aElem
)
const
;
#
endif
using
super
:
:
getFirst
;
using
super
:
:
isEmpty
;
void
AppendElement
(
ScriptLoadRequest
*
aElem
)
{
MOZ_ASSERT
(
!
aElem
-
>
isInList
(
)
)
;
NS_ADDREF
(
aElem
)
;
insertBack
(
aElem
)
;
}
already_AddRefed
<
ScriptLoadRequest
>
Steal
(
ScriptLoadRequest
*
aElem
)
{
aElem
-
>
removeFrom
(
*
this
)
;
return
dont_AddRef
(
aElem
)
;
}
already_AddRefed
<
ScriptLoadRequest
>
StealFirst
(
)
{
MOZ_ASSERT
(
!
isEmpty
(
)
)
;
return
Steal
(
getFirst
(
)
)
;
}
void
Remove
(
ScriptLoadRequest
*
aElem
)
{
aElem
-
>
removeFrom
(
*
this
)
;
NS_RELEASE
(
aElem
)
;
}
}
;
inline
void
ImplCycleCollectionUnlink
(
ScriptLoadRequestList
&
aField
)
{
while
(
!
aField
.
isEmpty
(
)
)
{
RefPtr
<
ScriptLoadRequest
>
first
=
aField
.
StealFirst
(
)
;
}
}
inline
void
ImplCycleCollectionTraverse
(
nsCycleCollectionTraversalCallback
&
aCallback
ScriptLoadRequestList
&
aField
const
char
*
aName
uint32_t
aFlags
)
{
for
(
ScriptLoadRequest
*
request
=
aField
.
getFirst
(
)
;
request
;
request
=
request
-
>
getNext
(
)
)
{
CycleCollectionNoteChild
(
aCallback
request
aName
aFlags
)
;
}
}
}
}
#
endif
