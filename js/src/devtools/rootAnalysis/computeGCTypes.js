"
use
strict
"
;
loadRelativeToScript
(
'
utility
.
js
'
)
;
loadRelativeToScript
(
'
annotations
.
js
'
)
;
var
annotations
=
{
'
GCPointers
'
:
[
]
'
GCThings
'
:
[
]
'
NonGCTypes
'
:
{
}
'
NonGCPointers
'
:
{
}
'
RootedPointers
'
:
{
}
}
;
var
structureParents
=
{
}
;
var
pointerParents
=
{
}
;
var
baseClasses
=
{
}
;
var
gcTypes
=
{
}
;
var
gcPointers
=
{
}
;
var
gcFields
=
new
Map
;
var
rootedPointers
=
{
}
;
function
processCSU
(
csu
body
)
{
for
(
let
{
'
Base
'
:
base
}
of
(
body
.
CSUBaseClass
|
|
[
]
)
)
addBaseClass
(
csu
base
)
;
for
(
let
field
of
(
body
.
DataField
|
|
[
]
)
)
{
var
type
=
field
.
Field
.
Type
;
var
fieldName
=
field
.
Field
.
Name
[
0
]
;
if
(
type
.
Kind
=
=
"
Pointer
"
)
{
var
target
=
type
.
Type
;
if
(
target
.
Kind
=
=
"
CSU
"
)
addNestedPointer
(
csu
target
.
Name
fieldName
)
;
}
if
(
type
.
Kind
=
=
"
Array
"
)
{
var
target
=
type
.
Type
;
if
(
target
.
Kind
=
=
"
CSU
"
)
addNestedStructure
(
csu
target
.
Name
fieldName
)
;
}
if
(
type
.
Kind
=
=
"
CSU
"
)
{
if
(
type
.
Name
=
=
"
JS
:
:
AutoGCRooter
"
|
|
type
.
Name
=
=
"
JS
:
:
CustomAutoRooter
"
)
return
;
addNestedStructure
(
csu
type
.
Name
fieldName
)
;
}
}
for
(
let
{
'
Name
'
:
[
annType
tag
]
}
of
(
body
.
Annotation
|
|
[
]
)
)
{
if
(
annType
!
=
'
Tag
'
)
continue
;
if
(
tag
=
=
'
GC
Pointer
'
)
annotations
.
GCPointers
.
push
(
csu
)
;
else
if
(
tag
=
=
'
Invalidated
by
GC
'
)
annotations
.
GCPointers
.
push
(
csu
)
;
else
if
(
tag
=
=
'
GC
Thing
'
)
annotations
.
GCThings
.
push
(
csu
)
;
else
if
(
tag
=
=
'
Suppressed
GC
Pointer
'
)
annotations
.
NonGCPointers
[
csu
]
=
true
;
else
if
(
tag
=
=
'
Rooted
Pointer
'
)
annotations
.
RootedPointers
[
csu
]
=
true
;
}
}
function
addNestedStructure
(
csu
inner
field
)
{
if
(
!
(
inner
in
structureParents
)
)
structureParents
[
inner
]
=
[
]
;
if
(
field
.
match
(
/
^
field
:
\
d
+
/
)
&
&
(
csu
in
baseClasses
)
&
&
(
baseClasses
[
csu
]
.
indexOf
(
inner
)
!
=
-
1
)
)
return
;
structureParents
[
inner
]
.
push
(
[
csu
field
]
)
;
}
function
addBaseClass
(
csu
base
)
{
if
(
!
(
csu
in
baseClasses
)
)
baseClasses
[
csu
]
=
[
]
;
baseClasses
[
csu
]
.
push
(
base
)
;
var
k
=
baseClasses
[
csu
]
.
length
;
addNestedStructure
(
csu
base
<
base
-
{
k
}
>
)
;
}
function
addNestedPointer
(
csu
inner
field
)
{
if
(
!
(
inner
in
pointerParents
)
)
pointerParents
[
inner
]
=
[
]
;
pointerParents
[
inner
]
.
push
(
[
csu
field
]
)
;
}
var
xdb
=
xdbLibrary
(
)
;
xdb
.
open
(
"
src_comp
.
xdb
"
)
;
var
minStream
=
xdb
.
min_data_stream
(
)
;
var
maxStream
=
xdb
.
max_data_stream
(
)
;
for
(
var
csuIndex
=
minStream
;
csuIndex
<
=
maxStream
;
csuIndex
+
+
)
{
var
csu
=
xdb
.
read_key
(
csuIndex
)
;
var
data
=
xdb
.
read_entry
(
csu
)
;
var
json
=
JSON
.
parse
(
data
.
readString
(
)
)
;
assert
(
json
.
length
=
=
1
)
;
processCSU
(
csu
.
readString
(
)
json
[
0
]
)
;
xdb
.
free_string
(
csu
)
;
xdb
.
free_string
(
data
)
;
}
for
(
let
csu
of
annotations
.
GCThings
)
addGCType
(
csu
)
;
for
(
let
csu
of
annotations
.
GCPointers
)
addGCPointer
(
csu
)
;
function
stars
(
n
)
{
return
n
?
'
*
'
+
stars
(
n
-
1
)
:
'
'
}
;
function
markGCType
(
typeName
child
why
typePtrLevel
fieldPtrLevel
indent
)
{
if
(
!
fieldPtrLevel
&
&
isUnsafeStorage
(
typeName
)
)
{
fieldPtrLevel
=
-
1
;
}
var
ptrLevel
=
typePtrLevel
+
fieldPtrLevel
;
if
(
ptrLevel
>
2
)
return
;
if
(
ptrLevel
=
=
0
&
&
isRootedGCTypeName
(
typeName
)
)
return
;
if
(
ptrLevel
=
=
1
&
&
isRootedGCPointerTypeName
(
typeName
)
)
return
;
if
(
ptrLevel
=
=
0
)
{
if
(
typeName
in
annotations
.
NonGCTypes
)
return
;
if
(
!
(
typeName
in
gcTypes
)
)
gcTypes
[
typeName
]
=
new
Set
(
)
;
gcTypes
[
typeName
]
.
add
(
why
)
;
}
else
if
(
ptrLevel
=
=
1
)
{
if
(
typeName
in
annotations
.
NonGCPointers
)
return
;
if
(
!
(
typeName
in
gcPointers
)
)
gcPointers
[
typeName
]
=
new
Set
(
)
;
gcPointers
[
typeName
]
.
add
(
why
)
;
}
if
(
ptrLevel
<
2
)
{
if
(
!
gcFields
.
has
(
typeName
)
)
gcFields
.
set
(
typeName
new
Map
(
)
)
;
gcFields
.
get
(
typeName
)
.
set
(
child
[
why
fieldPtrLevel
]
)
;
}
if
(
typeName
in
structureParents
)
{
for
(
var
field
of
structureParents
[
typeName
]
)
{
var
[
holderType
fieldName
]
=
field
;
markGCType
(
holderType
fieldName
typeName
ptrLevel
0
indent
+
"
"
)
;
}
}
if
(
typeName
in
pointerParents
)
{
for
(
var
field
of
pointerParents
[
typeName
]
)
{
var
[
holderType
fieldName
]
=
field
;
markGCType
(
holderType
fieldName
typeName
ptrLevel
1
indent
+
"
"
)
;
}
}
}
function
addGCType
(
typeName
child
why
depth
fieldPtrLevel
)
{
markGCType
(
typeName
'
<
annotation
>
'
'
(
annotation
)
'
0
0
"
"
)
;
}
function
addGCPointer
(
typeName
)
{
markGCType
(
typeName
'
<
pointer
-
annotation
>
'
'
(
annotation
)
'
1
0
"
"
)
;
}
for
(
var
type
of
listNonGCPointers
(
)
)
annotations
.
NonGCPointers
[
type
]
=
true
;
function
explain
(
csu
indent
seen
)
{
if
(
!
seen
)
seen
=
new
Set
(
)
;
seen
.
add
(
csu
)
;
if
(
!
gcFields
.
has
(
csu
)
)
return
;
var
fields
=
gcFields
.
get
(
csu
)
;
if
(
fields
.
has
(
'
<
annotation
>
'
)
)
{
print
(
indent
+
"
which
is
annotated
as
a
GCThing
"
)
;
return
;
}
if
(
fields
.
has
(
'
<
pointer
-
annotation
>
'
)
)
{
print
(
indent
+
"
which
is
annotated
as
a
GCPointer
"
)
;
return
;
}
for
(
var
[
field
[
child
ptrdness
]
]
of
fields
)
{
var
msg
=
indent
;
if
(
field
[
0
]
=
=
'
<
'
)
msg
+
=
"
inherits
from
"
;
else
{
msg
+
=
"
contains
field
'
"
+
field
+
"
'
"
;
if
(
ptrdness
=
=
-
1
)
msg
+
=
"
(
with
a
pointer
to
unsafe
storage
)
holding
a
"
;
else
if
(
ptrdness
=
=
0
)
msg
+
=
"
of
type
"
;
else
msg
+
=
"
pointing
to
type
"
;
}
msg
+
=
child
;
print
(
msg
)
;
if
(
!
seen
.
has
(
child
)
)
explain
(
child
indent
+
"
"
seen
)
;
}
}
for
(
var
csu
in
gcTypes
)
{
print
(
"
GCThing
:
"
+
csu
)
;
explain
(
csu
"
"
)
;
}
for
(
var
csu
in
gcPointers
)
{
print
(
"
GCPointer
:
"
+
csu
)
;
explain
(
csu
"
"
)
;
}
