"
use
strict
"
;
loadRelativeToScript
(
'
utility
.
js
'
)
;
loadRelativeToScript
(
'
annotations
.
js
'
)
;
loadRelativeToScript
(
'
CFG
.
js
'
)
;
loadRelativeToScript
(
'
dumpCFG
.
js
'
)
;
var
sourceRoot
=
(
os
.
getenv
(
'
SOURCE
'
)
|
|
'
'
)
+
'
/
'
var
functionName
;
var
functionBodies
;
if
(
typeof
scriptArgs
[
0
]
!
=
'
string
'
|
|
typeof
scriptArgs
[
1
]
!
=
'
string
'
)
throw
"
Usage
:
analyzeRoots
.
js
[
-
f
function_name
]
<
gcFunctions
.
lst
>
<
gcEdges
.
txt
>
<
limitedFunctions
.
lst
>
<
gcTypes
.
txt
>
<
typeInfo
.
txt
>
[
start
end
[
tmpfile
]
]
"
;
var
theFunctionNameToFind
;
if
(
scriptArgs
[
0
]
=
=
'
-
-
function
'
|
|
scriptArgs
[
0
]
=
=
'
-
f
'
)
{
theFunctionNameToFind
=
scriptArgs
[
1
]
;
scriptArgs
=
scriptArgs
.
slice
(
2
)
;
}
var
gcFunctionsFile
=
scriptArgs
[
0
]
|
|
"
gcFunctions
.
lst
"
;
var
gcEdgesFile
=
scriptArgs
[
1
]
|
|
"
gcEdges
.
txt
"
;
var
limitedFunctionsFile
=
scriptArgs
[
2
]
|
|
"
limitedFunctions
.
lst
"
;
var
gcTypesFile
=
scriptArgs
[
3
]
|
|
"
gcTypes
.
txt
"
;
var
typeInfoFile
=
scriptArgs
[
4
]
|
|
"
typeInfo
.
txt
"
;
var
batch
=
(
scriptArgs
[
5
]
|
0
)
|
|
1
;
var
numBatches
=
(
scriptArgs
[
6
]
|
0
)
|
|
1
;
var
tmpfile
=
scriptArgs
[
7
]
|
|
"
tmp
.
txt
"
;
var
gcFunctions
=
{
}
;
var
text
=
snarf
(
"
gcFunctions
.
lst
"
)
.
split
(
"
\
n
"
)
;
assert
(
text
.
pop
(
)
.
length
=
=
0
)
;
for
(
var
line
of
text
)
gcFunctions
[
mangled
(
line
)
]
=
true
;
var
limitedFunctions
=
{
}
;
var
text
=
snarf
(
limitedFunctionsFile
)
.
split
(
"
\
n
"
)
;
assert
(
text
.
pop
(
)
.
length
=
=
0
)
;
for
(
var
line
of
text
)
{
const
[
_
limits
func
]
=
line
.
match
(
/
(
.
*
?
)
(
.
*
)
/
)
;
assert
(
limits
!
=
=
undefined
)
;
limitedFunctions
[
func
]
=
limits
|
0
;
}
text
=
null
;
var
typeInfo
=
loadTypeInfo
(
typeInfoFile
)
;
var
gcEdges
=
{
}
;
text
=
snarf
(
gcEdgesFile
)
.
split
(
'
\
n
'
)
;
assert
(
text
.
pop
(
)
.
length
=
=
0
)
;
for
(
var
line
of
text
)
{
var
[
block
edge
func
]
=
line
.
split
(
"
|
|
"
)
;
if
(
!
(
block
in
gcEdges
)
)
gcEdges
[
block
]
=
{
}
gcEdges
[
block
]
[
edge
]
=
func
;
}
text
=
null
;
var
match
;
var
gcThings
=
{
}
;
var
gcPointers
=
{
}
;
text
=
snarf
(
gcTypesFile
)
.
split
(
"
\
n
"
)
;
for
(
var
line
of
text
)
{
if
(
match
=
/
^
GCThing
:
(
.
*
)
/
.
exec
(
line
)
)
gcThings
[
match
[
1
]
]
=
true
;
if
(
match
=
/
^
GCPointer
:
(
.
*
)
/
.
exec
(
line
)
)
gcPointers
[
match
[
1
]
]
=
true
;
}
text
=
null
;
function
isGCType
(
type
)
{
if
(
type
.
Kind
=
=
"
CSU
"
)
return
type
.
Name
in
gcThings
;
else
if
(
type
.
Kind
=
=
"
Array
"
)
return
isGCType
(
type
.
Type
)
;
return
false
;
}
function
isUnrootedType
(
type
)
{
if
(
type
.
Kind
=
=
"
Pointer
"
)
return
isGCType
(
type
.
Type
)
;
else
if
(
type
.
Kind
=
=
"
Array
"
)
{
if
(
!
type
.
Type
)
{
printErr
(
"
Received
Array
Kind
with
no
Type
"
)
;
printErr
(
JSON
.
stringify
(
type
)
)
;
printErr
(
getBacktrace
(
{
args
:
true
locals
:
true
}
)
)
;
}
return
isUnrootedType
(
type
.
Type
)
;
}
else
if
(
type
.
Kind
=
=
"
CSU
"
)
return
type
.
Name
in
gcPointers
;
else
return
false
;
}
function
expressionUsesVariable
(
exp
variable
)
{
if
(
exp
.
Kind
=
=
"
Var
"
&
&
sameVariable
(
exp
.
Variable
variable
)
)
return
true
;
if
(
!
(
"
Exp
"
in
exp
)
)
return
false
;
for
(
var
childExp
of
exp
.
Exp
)
{
if
(
expressionUsesVariable
(
childExp
variable
)
)
return
true
;
}
return
false
;
}
function
expressionUsesVariableContents
(
exp
variable
)
{
if
(
!
(
"
Exp
"
in
exp
)
)
return
false
;
for
(
var
childExp
of
exp
.
Exp
)
{
if
(
childExp
.
Kind
=
=
'
Drf
'
)
{
if
(
expressionUsesVariable
(
childExp
variable
)
)
return
true
;
}
else
if
(
expressionUsesVariableContents
(
childExp
variable
)
)
{
return
true
;
}
}
return
false
;
}
function
isImmobileValue
(
exp
)
{
if
(
exp
.
Kind
=
=
"
Int
"
&
&
exp
.
String
=
=
"
0
"
)
{
return
true
;
}
return
false
;
}
function
isReturningImmobileValue
(
edge
variable
)
{
if
(
variable
.
Kind
=
=
"
Return
"
)
{
if
(
edge
.
Exp
[
0
]
.
Kind
=
=
"
Var
"
&
&
sameVariable
(
edge
.
Exp
[
0
]
.
Variable
variable
)
)
{
if
(
isImmobileValue
(
edge
.
Exp
[
1
]
)
)
return
true
;
}
}
return
false
;
}
function
edgeUsesVariable
(
edge
variable
body
)
{
if
(
ignoreEdgeUse
(
edge
variable
body
)
)
return
0
;
if
(
variable
.
Kind
=
=
"
Return
"
&
&
body
.
Index
[
1
]
=
=
edge
.
Index
[
1
]
&
&
body
.
BlockId
.
Kind
=
=
"
Function
"
)
return
edge
.
Index
[
1
]
;
var
src
=
edge
.
Index
[
0
]
;
switch
(
edge
.
Kind
)
{
case
"
Assign
"
:
{
if
(
isReturningImmobileValue
(
edge
variable
)
)
return
0
;
const
[
lhs
rhs
]
=
edge
.
Exp
;
if
(
expressionUsesVariable
(
rhs
variable
)
)
return
src
;
if
(
expressionUsesVariable
(
lhs
variable
)
&
&
!
expressionIsVariable
(
lhs
variable
)
)
return
src
;
return
0
;
}
case
"
Assume
"
:
return
expressionUsesVariableContents
(
edge
.
Exp
[
0
]
variable
)
?
src
:
0
;
case
"
Call
"
:
{
const
callee
=
edge
.
Exp
[
0
]
;
if
(
expressionUsesVariable
(
callee
variable
)
)
return
src
;
if
(
"
PEdgeCallInstance
"
in
edge
)
{
if
(
expressionUsesVariable
(
edge
.
PEdgeCallInstance
.
Exp
variable
)
)
{
if
(
edgeKillsVariable
(
edge
variable
)
)
{
}
else
{
return
src
;
}
}
}
if
(
"
PEdgeCallArguments
"
in
edge
)
{
for
(
var
exp
of
edge
.
PEdgeCallArguments
.
Exp
)
{
if
(
expressionUsesVariable
(
exp
variable
)
)
return
src
;
}
}
if
(
edge
.
Exp
.
length
=
=
1
)
return
0
;
const
lhs
=
edge
.
Exp
[
1
]
;
if
(
expressionUsesVariable
(
lhs
variable
)
&
&
!
expressionIsVariable
(
lhs
variable
)
)
return
src
;
return
0
;
}
case
"
Loop
"
:
return
0
;
case
"
Assembly
"
:
return
0
;
default
:
assert
(
false
)
;
}
}
function
expressionIsVariableAddress
(
exp
variable
)
{
while
(
exp
.
Kind
=
=
"
Fld
"
)
exp
=
exp
.
Exp
[
0
]
;
return
exp
.
Kind
=
=
"
Var
"
&
&
sameVariable
(
exp
.
Variable
variable
)
;
}
function
edgeTakesVariableAddress
(
edge
variable
body
)
{
if
(
ignoreEdgeUse
(
edge
variable
body
)
)
return
false
;
if
(
ignoreEdgeAddressTaken
(
edge
)
)
return
false
;
switch
(
edge
.
Kind
)
{
case
"
Assign
"
:
return
expressionIsVariableAddress
(
edge
.
Exp
[
1
]
variable
)
;
case
"
Call
"
:
if
(
"
PEdgeCallArguments
"
in
edge
)
{
for
(
var
exp
of
edge
.
PEdgeCallArguments
.
Exp
)
{
if
(
expressionIsVariableAddress
(
exp
variable
)
)
return
true
;
}
}
return
false
;
default
:
return
false
;
}
}
function
expressionIsVariable
(
exp
variable
)
{
return
exp
.
Kind
=
=
"
Var
"
&
&
sameVariable
(
exp
.
Variable
variable
)
;
}
function
edgeKillsVariable
(
edge
variable
)
{
if
(
edge
.
Kind
=
=
"
Assign
"
)
{
const
[
lhs
rhs
]
=
edge
.
Exp
;
return
(
expressionIsVariable
(
lhs
variable
)
&
&
!
isReturningImmobileValue
(
edge
variable
)
)
;
}
if
(
edge
.
Kind
!
=
"
Call
"
)
return
false
;
if
(
1
in
edge
.
Exp
)
{
var
lhs
=
edge
.
Exp
[
1
]
;
if
(
expressionIsVariable
(
lhs
variable
)
)
return
true
;
}
if
(
"
PEdgeCallInstance
"
in
edge
)
{
var
instance
=
edge
.
PEdgeCallInstance
.
Exp
;
if
(
instance
.
Kind
=
=
"
Drf
"
)
instance
=
instance
.
Exp
[
0
]
;
if
(
!
expressionIsVariable
(
instance
variable
)
)
return
false
;
var
callee
=
edge
.
Exp
[
0
]
;
if
(
callee
.
Kind
!
=
"
Var
"
)
return
false
;
assert
(
callee
.
Variable
.
Kind
=
=
"
Func
"
)
;
var
calleeName
=
readable
(
callee
.
Variable
.
Name
[
0
]
)
;
var
openParen
=
calleeName
.
indexOf
(
'
(
'
)
;
if
(
openParen
<
0
)
return
false
;
calleeName
=
calleeName
.
substring
(
0
openParen
)
;
var
lastColon
=
calleeName
.
lastIndexOf
(
'
:
:
'
)
;
if
(
lastColon
<
0
)
return
false
;
var
constructorName
=
calleeName
.
substr
(
lastColon
+
2
)
;
calleeName
=
calleeName
.
substr
(
0
lastColon
)
;
var
lastTemplateOpen
=
calleeName
.
lastIndexOf
(
'
<
'
)
;
if
(
lastTemplateOpen
>
=
0
)
calleeName
=
calleeName
.
substr
(
0
lastTemplateOpen
)
;
if
(
calleeName
.
endsWith
(
constructorName
)
)
return
true
;
}
return
false
;
}
function
edgeMovesVariable
(
edge
variable
)
{
if
(
edge
.
Kind
!
=
'
Call
'
)
return
false
;
const
callee
=
edge
.
Exp
[
0
]
;
if
(
callee
.
Kind
=
=
'
Var
'
&
&
callee
.
Variable
.
Kind
=
=
'
Func
'
)
{
const
{
Variable
:
{
Name
:
[
fullname
shortname
]
}
}
=
callee
;
const
[
mangled
unmangled
]
=
splitFunction
(
fullname
)
;
if
(
unmangled
.
match
(
/
:
:
UniquePtr
<
[
^
>
]
*
>
:
:
UniquePtr
\
(
(
\
w
+
:
:
)
*
UniquePtr
<
[
^
>
]
*
>
&
&
/
)
)
return
true
;
}
return
false
;
}
function
bodyEatsVariable
(
variable
body
startpoint
)
{
const
successors
=
getSuccessors
(
body
)
;
const
work
=
[
startpoint
]
;
while
(
work
.
length
>
0
)
{
const
point
=
work
.
shift
(
)
;
if
(
!
(
point
in
successors
)
)
continue
;
for
(
const
edge
of
successors
[
point
]
)
{
if
(
edgeMovesVariable
(
edge
variable
)
)
return
true
;
if
(
!
edgeKillsVariable
(
edge
variable
)
)
work
.
push
(
edge
.
Index
[
1
]
)
;
}
}
return
false
;
}
function
edgeInvalidatesVariable
(
edge
variable
body
)
{
if
(
edge
.
Kind
=
=
"
Assign
"
)
{
const
[
lhs
rhs
]
=
edge
.
Exp
;
return
expressionIsVariable
(
lhs
variable
)
&
&
isImmobileValue
(
rhs
)
;
}
if
(
edge
.
Kind
!
=
"
Call
"
)
return
false
;
var
callee
=
edge
.
Exp
[
0
]
;
if
(
edge
.
Type
.
Kind
=
=
'
Function
'
&
&
edge
.
Exp
[
0
]
.
Kind
=
=
'
Var
'
&
&
edge
.
Exp
[
0
]
.
Variable
.
Kind
=
=
'
Func
'
&
&
edge
.
Exp
[
0
]
.
Variable
.
Name
[
1
]
=
=
'
move
'
&
&
edge
.
Exp
[
0
]
.
Variable
.
Name
[
0
]
.
includes
(
'
std
:
:
move
(
'
)
&
&
expressionIsVariable
(
edge
.
PEdgeCallArguments
.
Exp
[
0
]
variable
)
&
&
edge
.
Exp
[
1
]
.
Kind
=
=
'
Var
'
&
&
edge
.
Exp
[
1
]
.
Variable
.
Kind
=
=
'
Temp
'
)
{
const
lhs
=
edge
.
Exp
[
1
]
.
Variable
;
if
(
bodyEatsVariable
(
lhs
body
edge
.
Index
[
1
]
)
)
return
true
;
}
if
(
edge
.
Type
.
Kind
=
=
'
Function
'
&
&
edge
.
Type
.
TypeFunctionCSU
&
&
edge
.
PEdgeCallInstance
&
&
edge
.
PEdgeCallInstance
.
Exp
.
Kind
=
=
'
Var
'
&
&
expressionIsVariable
(
edge
.
PEdgeCallInstance
.
Exp
variable
)
)
do
{
const
typeName
=
edge
.
Type
.
TypeFunctionCSU
.
Type
.
Name
;
const
m
=
typeName
.
match
(
/
^
(
(
(
\
w
|
:
:
)
+
?
)
(
\
w
+
)
)
<
/
)
;
if
(
!
m
)
break
;
const
[
type
namespace
classname
]
=
m
;
if
(
callee
.
Kind
=
=
'
Var
'
&
&
typesWithSafeConstructors
.
has
(
type
)
&
&
callee
.
Variable
.
Name
[
0
]
.
includes
(
{
namespace
}
{
classname
}
<
T
>
:
:
{
classname
}
(
)
)
)
{
return
true
;
}
if
(
callee
.
Kind
=
=
'
Var
'
&
&
type
in
resetterMethods
&
&
resetterMethods
[
type
]
.
has
(
callee
.
Variable
.
Name
[
1
]
)
)
{
return
true
;
}
}
while
(
0
)
;
if
(
edge
.
Type
.
Kind
=
=
'
Function
'
&
&
edge
.
Type
.
TypeFunctionArgument
&
&
edge
.
PEdgeCallArguments
)
{
for
(
const
i
in
edge
.
Type
.
TypeFunctionArgument
)
{
const
param
=
edge
.
Type
.
TypeFunctionArgument
[
i
]
;
if
(
param
.
Type
.
Kind
!
=
'
CSU
'
)
continue
;
if
(
!
param
.
Type
.
Name
.
startsWith
(
"
mozilla
:
:
UniquePtr
<
"
)
)
continue
;
const
arg
=
edge
.
PEdgeCallArguments
.
Exp
[
i
]
;
if
(
expressionIsVariable
(
arg
variable
)
)
{
return
true
;
}
}
}
return
false
;
}
function
edgeCanGC
(
edge
)
{
if
(
edge
.
Kind
!
=
"
Call
"
)
return
false
;
var
callee
=
edge
.
Exp
[
0
]
;
while
(
callee
.
Kind
=
=
"
Drf
"
)
callee
=
callee
.
Exp
[
0
]
;
if
(
callee
.
Kind
=
=
"
Var
"
)
{
var
variable
=
callee
.
Variable
;
if
(
variable
.
Kind
=
=
"
Func
"
)
{
var
func
=
mangled
(
variable
.
Name
[
0
]
)
;
if
(
(
func
in
gcFunctions
)
|
|
(
(
func
+
internalMarker
)
in
gcFunctions
)
)
return
"
'
"
+
variable
.
Name
[
0
]
+
"
'
"
;
return
null
;
}
var
varName
=
variable
.
Name
[
0
]
;
return
indirectCallCannotGC
(
functionName
varName
)
?
null
:
"
'
*
"
+
varName
+
"
'
"
;
}
if
(
callee
.
Kind
=
=
"
Fld
"
)
{
var
field
=
callee
.
Field
;
var
csuName
=
field
.
FieldCSU
.
Type
.
Name
;
var
fullFieldName
=
csuName
+
"
.
"
+
field
.
Name
[
0
]
;
if
(
fieldCallCannotGC
(
csuName
fullFieldName
)
)
return
null
;
if
(
fullFieldName
in
gcFunctions
)
return
"
'
"
+
fullFieldName
+
"
'
"
;
return
null
;
}
}
function
findGCBeforeValueUse
(
start_body
start_point
suppressed
variable
)
{
var
bodies_visited
=
new
Map
(
)
;
let
worklist
=
[
{
body
:
start_body
ppoint
:
start_point
preGCLive
:
false
gcInfo
:
null
why
:
null
}
]
;
while
(
worklist
.
length
)
{
var
entry
=
worklist
.
pop
(
)
;
var
{
body
ppoint
gcInfo
preGCLive
}
=
entry
;
var
visited
=
bodies_visited
.
get
(
body
)
;
if
(
!
visited
)
bodies_visited
.
set
(
body
visited
=
new
Map
(
)
)
;
if
(
visited
.
has
(
ppoint
)
)
{
var
seenEntry
=
visited
.
get
(
ppoint
)
;
if
(
seenEntry
.
gcInfo
)
continue
;
if
(
!
gcInfo
)
continue
;
}
visited
.
set
(
ppoint
{
body
:
body
gcInfo
:
gcInfo
}
)
;
if
(
ppoint
=
=
body
.
Index
[
0
]
)
{
if
(
body
.
BlockId
.
Kind
=
=
"
Loop
"
)
{
if
(
"
BlockPPoint
"
in
body
)
{
for
(
var
parent
of
body
.
BlockPPoint
)
{
var
found
=
false
;
for
(
var
xbody
of
functionBodies
)
{
if
(
sameBlockId
(
xbody
.
BlockId
parent
.
BlockId
)
)
{
assert
(
!
found
)
;
found
=
true
;
worklist
.
push
(
{
body
:
xbody
ppoint
:
parent
.
Index
gcInfo
:
gcInfo
why
:
entry
}
)
;
}
}
assert
(
found
)
;
}
}
worklist
.
push
(
{
body
:
body
ppoint
:
body
.
Index
[
1
]
gcInfo
:
gcInfo
why
:
entry
}
)
;
}
else
if
(
variable
.
Kind
=
=
"
Arg
"
&
&
gcInfo
)
{
return
entry
;
}
else
if
(
entry
.
preGCLive
)
{
return
entry
;
}
}
var
predecessors
=
getPredecessors
(
body
)
;
if
(
!
(
ppoint
in
predecessors
)
)
continue
;
for
(
var
edge
of
predecessors
[
ppoint
]
)
{
var
source
=
edge
.
Index
[
0
]
;
if
(
edgeInvalidatesVariable
(
edge
variable
body
)
)
{
continue
;
}
var
edge_kills
=
edgeKillsVariable
(
edge
variable
)
;
var
edge_uses
=
edgeUsesVariable
(
edge
variable
body
)
;
if
(
edge_kills
|
|
edge_uses
)
{
if
(
!
body
.
minimumUse
|
|
source
<
body
.
minimumUse
)
body
.
minimumUse
=
source
;
}
if
(
edge_kills
)
{
if
(
gcInfo
)
return
{
body
:
body
ppoint
:
source
gcInfo
:
gcInfo
why
:
entry
}
;
continue
;
}
var
src_gcInfo
=
gcInfo
;
var
src_preGCLive
=
preGCLive
;
if
(
!
gcInfo
&
&
!
(
body
.
limits
[
source
]
&
LIMIT_CANNOT_GC
)
&
&
!
suppressed
)
{
var
gcName
=
edgeCanGC
(
edge
body
)
;
if
(
gcName
)
src_gcInfo
=
{
name
:
gcName
body
:
body
ppoint
:
source
}
;
}
if
(
edge_uses
)
{
if
(
src_gcInfo
)
{
src_preGCLive
=
true
;
if
(
edge
.
Kind
=
=
'
Assign
'
)
return
{
body
:
body
ppoint
:
source
gcInfo
:
src_gcInfo
why
:
entry
}
;
}
}
if
(
edge
.
Kind
=
=
"
Loop
"
)
{
var
found
=
false
;
for
(
var
xbody
of
functionBodies
)
{
if
(
sameBlockId
(
xbody
.
BlockId
edge
.
BlockId
)
)
{
assert
(
!
found
)
;
found
=
true
;
worklist
.
push
(
{
body
:
xbody
ppoint
:
xbody
.
Index
[
1
]
preGCLive
:
src_preGCLive
gcInfo
:
src_gcInfo
why
:
entry
}
)
;
}
}
assert
(
found
)
;
break
;
}
worklist
.
push
(
{
body
:
body
ppoint
:
source
preGCLive
:
src_preGCLive
gcInfo
:
src_gcInfo
why
:
entry
}
)
;
}
}
return
null
;
}
function
variableLiveAcrossGC
(
suppressed
variable
)
{
for
(
var
body
of
functionBodies
)
body
.
minimumUse
=
0
;
for
(
var
body
of
functionBodies
)
{
if
(
!
(
"
PEdge
"
in
body
)
)
continue
;
for
(
var
edge
of
body
.
PEdge
)
{
if
(
edgeInvalidatesVariable
(
edge
variable
body
)
)
continue
;
var
usePoint
=
edgeUsesVariable
(
edge
variable
body
)
;
if
(
usePoint
)
{
var
call
=
findGCBeforeValueUse
(
body
usePoint
suppressed
variable
)
;
if
(
!
call
)
continue
;
call
.
afterGCUse
=
usePoint
;
return
call
;
}
}
}
return
null
;
}
function
unsafeVariableAddressTaken
(
suppressed
variable
)
{
for
(
var
body
of
functionBodies
)
{
if
(
!
(
"
PEdge
"
in
body
)
)
continue
;
for
(
var
edge
of
body
.
PEdge
)
{
if
(
edgeTakesVariableAddress
(
edge
variable
body
)
)
{
if
(
edge
.
Kind
=
=
"
Assign
"
|
|
(
!
suppressed
&
&
edgeCanGC
(
edge
)
)
)
return
{
body
:
body
ppoint
:
edge
.
Index
[
0
]
}
;
}
}
}
return
null
;
}
function
loadPrintedLines
(
functionName
)
{
assert
(
!
os
.
system
(
"
xdbfind
src_body
.
xdb
'
"
+
functionName
+
"
'
>
"
+
tmpfile
)
)
;
var
lines
=
snarf
(
tmpfile
)
.
split
(
'
\
n
'
)
;
for
(
var
body
of
functionBodies
)
body
.
lines
=
[
]
;
var
currentBody
=
null
;
for
(
var
line
of
lines
)
{
if
(
/
^
block
:
/
.
test
(
line
)
)
{
if
(
match
=
/
:
(
loop
#
[
\
d
#
]
+
)
/
.
exec
(
line
)
)
{
var
loop
=
match
[
1
]
;
var
found
=
false
;
for
(
var
body
of
functionBodies
)
{
if
(
body
.
BlockId
.
Kind
=
=
"
Loop
"
&
&
body
.
BlockId
.
Loop
=
=
loop
)
{
assert
(
!
found
)
;
found
=
true
;
currentBody
=
body
;
}
}
assert
(
found
)
;
}
else
{
for
(
var
body
of
functionBodies
)
{
if
(
body
.
BlockId
.
Kind
=
=
"
Function
"
)
currentBody
=
body
;
}
}
}
if
(
currentBody
)
currentBody
.
lines
.
push
(
line
)
;
}
}
function
findLocation
(
body
ppoint
opts
=
{
brief
:
false
}
)
{
var
location
=
body
.
PPoint
[
ppoint
-
1
]
.
Location
;
var
file
=
location
.
CacheString
;
if
(
file
.
indexOf
(
sourceRoot
)
=
=
0
)
file
=
file
.
substring
(
sourceRoot
.
length
)
;
if
(
opts
.
brief
)
{
var
m
=
/
.
*
\
/
(
.
*
)
/
.
exec
(
file
)
;
if
(
m
)
file
=
m
[
1
]
;
}
return
file
+
"
:
"
+
location
.
Line
;
}
function
locationLine
(
text
)
{
if
(
match
=
/
:
(
\
d
+
)
/
.
exec
(
text
)
)
return
match
[
1
]
;
return
0
;
}
function
printEntryTrace
(
functionName
entry
)
{
var
gcPoint
=
entry
.
gcInfo
?
entry
.
gcInfo
.
ppoint
:
0
;
if
(
!
functionBodies
[
0
]
.
lines
)
loadPrintedLines
(
functionName
)
;
while
(
entry
)
{
var
ppoint
=
entry
.
ppoint
;
var
lineText
=
findLocation
(
entry
.
body
ppoint
{
"
brief
"
:
true
}
)
;
var
edgeText
=
"
"
;
if
(
entry
.
why
&
&
entry
.
why
.
body
=
=
entry
.
body
)
{
var
next
=
entry
.
why
.
ppoint
;
if
(
!
entry
.
body
.
edgeTable
)
{
var
table
=
{
}
;
entry
.
body
.
edgeTable
=
table
;
for
(
var
line
of
entry
.
body
.
lines
)
{
if
(
match
=
/
^
\
w
+
\
(
(
\
d
+
\
d
+
)
/
.
exec
(
line
)
)
table
[
match
[
1
]
]
=
line
;
}
if
(
entry
.
body
.
BlockId
.
Kind
=
=
'
Loop
'
)
{
const
[
startPoint
endPoint
]
=
entry
.
body
.
Index
;
table
[
{
endPoint
}
{
startPoint
}
]
=
'
(
loop
to
next
iteration
)
'
;
}
}
edgeText
=
entry
.
body
.
edgeTable
[
ppoint
+
"
"
+
next
]
;
assert
(
edgeText
)
;
if
(
ppoint
=
=
gcPoint
)
edgeText
+
=
"
[
[
GC
call
]
]
"
;
}
else
{
for
(
var
line
of
entry
.
body
.
lines
)
{
if
(
match
=
/
\
(
(
\
d
+
)
/
.
exec
(
line
)
)
{
if
(
match
[
1
]
=
=
ppoint
)
{
edgeText
=
line
;
break
;
}
}
}
if
(
ppoint
=
=
entry
.
body
.
Index
[
1
]
&
&
entry
.
body
.
BlockId
.
Kind
=
=
"
Function
"
)
edgeText
+
=
"
[
[
end
of
function
]
]
"
;
}
print
(
"
"
+
lineText
+
(
edgeText
.
length
?
"
:
"
+
edgeText
:
"
"
)
)
;
entry
=
entry
.
why
;
}
}
function
isRootedType
(
type
)
{
return
type
.
Kind
=
=
"
CSU
"
&
&
(
(
type
.
Name
in
typeInfo
.
RootedPointers
)
|
|
(
type
.
Name
in
typeInfo
.
RootedGCThings
)
)
;
}
function
typeDesc
(
type
)
{
if
(
type
.
Kind
=
=
"
CSU
"
)
{
return
type
.
Name
;
}
else
if
(
'
Type
'
in
type
)
{
var
inner
=
typeDesc
(
type
.
Type
)
;
if
(
type
.
Kind
=
=
'
Pointer
'
)
return
inner
+
'
*
'
;
else
if
(
type
.
Kind
=
=
'
Array
'
)
return
inner
+
'
[
]
'
;
else
return
inner
+
'
?
'
;
}
else
{
return
'
?
?
?
'
;
}
}
function
processBodies
(
functionName
)
{
if
(
!
(
"
DefineVariable
"
in
functionBodies
[
0
]
)
)
return
;
var
suppressed
=
Boolean
(
limitedFunctions
[
mangled
(
functionName
)
]
&
LIMIT_CANNOT_GC
)
;
var
annotations
=
new
Set
(
)
;
for
(
const
variable
of
functionBodies
[
0
]
.
DefineVariable
)
{
if
(
variable
.
Variable
.
Kind
=
=
"
Func
"
&
&
variable
.
Variable
.
Name
[
0
]
=
=
functionName
)
{
for
(
const
{
Name
:
[
tag
value
]
}
of
(
variable
.
Type
.
Annotation
|
|
[
]
)
)
{
if
(
tag
=
=
'
annotate
'
)
annotations
.
add
(
value
)
;
}
}
}
var
missingExpectedHazard
=
annotations
.
has
(
"
Expect
Hazards
"
)
;
const
ignoreVars
=
new
Set
(
)
;
if
(
functionName
.
match
(
/
mozilla
:
:
dom
:
:
/
)
)
{
const
vars
=
functionBodies
[
0
]
.
DefineVariable
.
filter
(
v
=
>
v
.
Type
.
Kind
=
=
'
CSU
'
&
&
v
.
Variable
.
Kind
=
=
'
Local
'
)
.
map
(
v
=
>
[
v
.
Variable
.
Name
[
0
]
v
.
Type
.
Name
]
)
;
const
holders
=
vars
.
filter
(
(
[
n
t
]
)
=
>
n
.
match
(
/
^
arg
\
d
+
_holder
/
)
&
&
t
.
match
(
/
Argument
\
b
/
)
)
;
for
(
const
[
holder
]
of
holders
)
{
ignoreVars
.
add
(
holder
)
;
ignoreVars
.
add
(
holder
.
replace
(
"
_holder
"
"
"
)
)
;
}
}
for
(
const
variable
of
functionBodies
[
0
]
.
DefineVariable
)
{
var
name
;
if
(
variable
.
Variable
.
Kind
=
=
"
This
"
)
name
=
"
this
"
;
else
if
(
variable
.
Variable
.
Kind
=
=
"
Return
"
)
name
=
"
<
returnvalue
>
"
;
else
name
=
variable
.
Variable
.
Name
[
0
]
;
if
(
ignoreVars
.
has
(
name
)
)
continue
;
if
(
isRootedType
(
variable
.
Type
)
)
{
if
(
!
variableLiveAcrossGC
(
suppressed
variable
.
Variable
)
)
{
var
lineText
;
for
(
var
body
of
functionBodies
)
{
if
(
body
.
minimumUse
)
{
var
text
=
findLocation
(
body
body
.
minimumUse
)
;
if
(
!
lineText
|
|
locationLine
(
lineText
)
>
locationLine
(
text
)
)
lineText
=
text
;
}
}
print
(
"
\
nFunction
'
"
+
functionName
+
"
'
"
+
"
has
unnecessary
root
'
"
+
name
+
"
'
at
"
+
lineText
)
;
}
}
else
if
(
isUnrootedType
(
variable
.
Type
)
)
{
var
result
=
variableLiveAcrossGC
(
suppressed
variable
.
Variable
)
;
if
(
result
)
{
var
lineText
=
findLocation
(
result
.
gcInfo
.
body
result
.
gcInfo
.
ppoint
)
;
if
(
annotations
.
has
(
'
Expect
Hazards
'
)
)
{
print
(
"
\
nThis
is
expected
but
'
"
+
functionName
+
"
'
"
+
"
has
unrooted
'
"
+
name
+
"
'
"
+
"
of
type
'
"
+
typeDesc
(
variable
.
Type
)
+
"
'
"
+
"
live
across
GC
call
"
+
result
.
gcInfo
.
name
+
"
at
"
+
lineText
)
;
missingExpectedHazard
=
false
;
}
else
{
print
(
"
\
nFunction
'
"
+
functionName
+
"
'
"
+
"
has
unrooted
'
"
+
name
+
"
'
"
+
"
of
type
'
"
+
typeDesc
(
variable
.
Type
)
+
"
'
"
+
"
live
across
GC
call
"
+
result
.
gcInfo
.
name
+
"
at
"
+
lineText
)
;
}
printEntryTrace
(
functionName
result
)
;
}
result
=
unsafeVariableAddressTaken
(
suppressed
variable
.
Variable
)
;
if
(
result
)
{
var
lineText
=
findLocation
(
result
.
body
result
.
ppoint
)
;
print
(
"
\
nFunction
'
"
+
functionName
+
"
'
"
+
"
takes
unsafe
address
of
unrooted
'
"
+
name
+
"
'
"
+
"
at
"
+
lineText
)
;
printEntryTrace
(
functionName
{
body
:
result
.
body
ppoint
:
result
.
ppoint
}
)
;
}
}
}
if
(
missingExpectedHazard
)
{
const
{
Location
:
[
{
CacheString
:
startfile
Line
:
startline
}
{
CacheString
:
endfile
Line
:
endline
}
]
}
=
functionBodies
[
0
]
;
const
loc
=
(
startfile
=
=
endfile
)
?
{
startfile
}
:
{
startline
}
-
{
endline
}
:
{
startfile
}
:
{
startline
}
;
print
(
"
\
nFunction
'
"
+
functionName
+
"
'
expected
hazard
(
s
)
but
none
were
found
at
"
+
loc
)
;
}
}
if
(
batch
=
=
1
)
print
(
"
Time
:
"
+
new
Date
)
;
var
xdb
=
xdbLibrary
(
)
;
xdb
.
open
(
"
src_body
.
xdb
"
)
;
var
minStream
=
xdb
.
min_data_stream
(
)
|
0
;
var
maxStream
=
xdb
.
max_data_stream
(
)
|
0
;
var
N
=
(
maxStream
-
minStream
)
+
1
;
var
start
=
Math
.
floor
(
(
batch
-
1
)
/
numBatches
*
N
)
+
minStream
;
var
start_next
=
Math
.
floor
(
batch
/
numBatches
*
N
)
+
minStream
;
var
end
=
start_next
-
1
;
function
process
(
name
json
)
{
functionName
=
name
;
functionBodies
=
JSON
.
parse
(
json
)
;
for
(
var
body
of
functionBodies
)
body
.
limits
=
[
]
;
for
(
var
body
of
functionBodies
)
{
for
(
var
[
pbody
id
limits
]
of
allRAIIGuardedCallPoints
(
typeInfo
functionBodies
body
isLimitConstructor
)
)
{
if
(
limits
)
pbody
.
limits
[
id
]
=
limits
;
}
}
processBodies
(
functionName
)
;
}
if
(
theFunctionNameToFind
)
{
var
data
=
xdb
.
read_entry
(
theFunctionNameToFind
)
;
var
json
=
data
.
readString
(
)
;
process
(
theFunctionNameToFind
json
)
;
xdb
.
free_string
(
data
)
;
quit
(
0
)
;
}
for
(
var
nameIndex
=
start
;
nameIndex
<
=
end
;
nameIndex
+
+
)
{
var
name
=
xdb
.
read_key
(
nameIndex
)
;
var
functionName
=
name
.
readString
(
)
;
var
data
=
xdb
.
read_entry
(
name
)
;
xdb
.
free_string
(
name
)
;
var
json
=
data
.
readString
(
)
;
try
{
process
(
functionName
json
)
;
}
catch
(
e
)
{
printErr
(
"
Exception
caught
while
handling
"
+
functionName
)
;
throw
(
e
)
;
}
xdb
.
free_string
(
data
)
;
}
