"
use
strict
"
;
loadRelativeToScript
(
'
utility
.
js
'
)
;
loadRelativeToScript
(
'
annotations
.
js
'
)
;
loadRelativeToScript
(
'
CFG
.
js
'
)
;
loadRelativeToScript
(
'
dumpCFG
.
js
'
)
;
var
sourceRoot
=
(
os
.
getenv
(
'
SOURCE
'
)
|
|
'
'
)
+
'
/
'
;
var
functionName
;
var
functionBodies
;
try
{
var
options
=
parse_options
(
[
{
name
:
"
-
-
function
"
type
:
'
string
'
}
{
name
:
"
-
f
"
type
:
"
string
"
dest
:
"
function
"
}
{
name
:
"
gcFunctions
"
default
:
"
gcFunctions
.
lst
"
}
{
name
:
"
gcEdges
"
default
:
"
gcEdges
.
txt
"
}
{
name
:
"
limitedFunctions
"
default
:
"
limitedFunctions
.
lst
"
}
{
name
:
"
gcTypes
"
default
:
"
gcTypes
.
txt
"
}
{
name
:
"
typeInfo
"
default
:
"
typeInfo
.
txt
"
}
{
name
:
"
batch
"
type
:
"
number
"
default
:
1
}
{
name
:
"
numBatches
"
type
:
"
number
"
default
:
1
}
{
name
:
"
tmpfile
"
default
:
"
tmp
.
txt
"
}
]
)
;
}
catch
(
e
)
{
printErr
(
e
)
;
printErr
(
"
Usage
:
analyzeRoots
.
js
[
-
f
function_name
]
<
gcFunctions
.
lst
>
<
gcEdges
.
txt
>
<
limitedFunctions
.
lst
>
<
gcTypes
.
txt
>
<
typeInfo
.
txt
>
[
start
end
[
tmpfile
]
]
"
)
;
quit
(
1
)
;
}
var
gcFunctions
=
{
}
;
var
text
=
snarf
(
options
.
gcFunctions
)
.
split
(
"
\
n
"
)
;
assert
(
text
.
pop
(
)
.
length
=
=
0
)
;
for
(
const
line
of
text
)
gcFunctions
[
mangled
(
line
)
]
=
readable
(
line
)
;
var
limitedFunctions
=
JSON
.
parse
(
snarf
(
options
.
limitedFunctions
)
)
;
text
=
null
;
var
typeInfo
=
loadTypeInfo
(
options
.
typeInfo
)
;
var
gcEdges
=
{
}
;
text
=
snarf
(
options
.
gcEdges
)
.
split
(
'
\
n
'
)
;
assert
(
text
.
pop
(
)
.
length
=
=
0
)
;
for
(
const
line
of
text
)
{
var
[
block
edge
func
]
=
line
.
split
(
"
|
|
"
)
;
if
(
!
(
block
in
gcEdges
)
)
gcEdges
[
block
]
=
{
}
gcEdges
[
block
]
[
edge
]
=
func
;
}
text
=
null
;
var
match
;
var
gcThings
=
{
}
;
var
gcPointers
=
{
}
;
text
=
snarf
(
options
.
gcTypes
)
.
split
(
"
\
n
"
)
;
for
(
var
line
of
text
)
{
if
(
match
=
/
^
GCThing
:
(
.
*
)
/
.
exec
(
line
)
)
gcThings
[
match
[
1
]
]
=
true
;
if
(
match
=
/
^
GCPointer
:
(
.
*
)
/
.
exec
(
line
)
)
gcPointers
[
match
[
1
]
]
=
true
;
}
text
=
null
;
function
isGCType
(
type
)
{
if
(
type
.
Kind
=
=
"
CSU
"
)
return
type
.
Name
in
gcThings
;
else
if
(
type
.
Kind
=
=
"
Array
"
)
return
isGCType
(
type
.
Type
)
;
return
false
;
}
function
isUnrootedType
(
type
)
{
if
(
type
.
Kind
=
=
"
Pointer
"
)
return
isGCType
(
type
.
Type
)
;
else
if
(
type
.
Kind
=
=
"
Array
"
)
{
if
(
!
type
.
Type
)
{
printErr
(
"
Received
Array
Kind
with
no
Type
"
)
;
printErr
(
JSON
.
stringify
(
type
)
)
;
printErr
(
getBacktrace
(
{
args
:
true
locals
:
true
}
)
)
;
}
return
isUnrootedType
(
type
.
Type
)
;
}
else
if
(
type
.
Kind
=
=
"
CSU
"
)
return
type
.
Name
in
gcPointers
;
else
return
false
;
}
function
edgeCanGC
(
edge
)
{
if
(
edge
.
Kind
!
=
"
Call
"
)
return
false
;
var
callee
=
edge
.
Exp
[
0
]
;
while
(
callee
.
Kind
=
=
"
Drf
"
)
callee
=
callee
.
Exp
[
0
]
;
if
(
callee
.
Kind
=
=
"
Var
"
)
{
var
variable
=
callee
.
Variable
;
if
(
variable
.
Kind
=
=
"
Func
"
)
{
var
func
=
mangled
(
variable
.
Name
[
0
]
)
;
if
(
(
func
in
gcFunctions
)
|
|
(
(
func
+
internalMarker
)
in
gcFunctions
)
)
return
'
{
func
}
{
gcFunctions
[
func
]
}
'
;
return
false
;
}
var
varName
=
variable
.
Name
[
0
]
;
return
indirectCallCannotGC
(
functionName
varName
)
?
false
:
"
'
*
"
+
varName
+
"
'
"
;
}
assert
(
callee
.
Kind
=
=
"
Fld
"
)
;
const
staticCSU
=
getFieldCallInstanceCSU
(
edge
callee
.
Field
)
;
if
(
fieldCallCannotGC
(
staticCSU
callee
.
Field
.
Name
[
0
]
)
)
return
false
;
const
fieldkey
=
fieldKey
(
staticCSU
callee
.
Field
)
;
if
(
fieldkey
in
gcFunctions
)
return
'
{
fieldkey
}
'
;
return
false
;
}
function
findGCBeforeValueUse
(
start_body
start_point
suppressed_bits
variable
)
{
const
isGCSuppressed
=
Boolean
(
suppressed_bits
&
ATTR_GC_SUPPRESSED
)
;
class
Path
{
get
ProgressProperties
(
)
{
return
[
"
informativeUse
"
"
anyUse
"
"
gcInfo
"
]
;
}
constructor
(
successor_path
body
ppoint
)
{
Object
.
assign
(
this
{
body
ppoint
}
)
;
if
(
successor_path
!
=
=
undefined
)
{
this
.
successor
=
successor_path
;
for
(
const
prop
of
this
.
ProgressProperties
)
{
if
(
prop
in
successor_path
)
{
this
[
prop
]
=
successor_path
[
prop
]
;
}
}
}
}
toString
(
)
{
const
trail
=
[
]
;
for
(
let
path
=
this
;
path
.
ppoint
;
path
=
path
.
successor
)
{
trail
.
push
(
path
.
ppoint
)
;
}
return
trail
.
join
(
)
;
}
compare
(
other
)
{
for
(
const
prop
of
this
.
ProgressProperties
)
{
const
a
=
this
.
hasOwnProperty
(
prop
)
;
const
b
=
other
.
hasOwnProperty
(
prop
)
;
if
(
a
!
=
b
)
{
return
a
-
b
;
}
}
return
0
;
}
}
;
let
bestPathWithAnyUse
=
null
;
const
visitor
=
new
class
extends
Visitor
{
constructor
(
)
{
super
(
functionBodies
)
;
}
next_action
(
prev
current
)
{
if
(
!
current
)
{
return
"
prune
"
;
}
if
(
current
.
informativeUse
)
{
assert
(
current
.
gcInfo
)
;
return
"
done
"
;
}
if
(
prev
=
=
=
undefined
)
{
return
"
continue
"
;
}
if
(
!
prev
.
gcInfo
&
&
current
.
gcInfo
)
{
return
"
continue
"
;
}
else
{
return
"
prune
"
;
}
}
merge_info
(
prev
current
)
{
if
(
!
prev
|
|
!
current
)
{
return
prev
|
|
current
;
}
return
prev
.
compare
(
current
)
>
=
0
?
prev
:
current
;
}
extend_path
(
edge
body
ppoint
successor_path
)
{
const
path
=
new
Path
(
successor_path
body
ppoint
)
;
if
(
edge
=
=
=
null
)
{
return
path
;
}
assert
(
ppoint
=
=
edge
.
Index
[
0
]
)
;
if
(
edgeEndsValueLiveRange
(
edge
variable
body
)
)
{
return
null
;
}
const
edge_starts
=
edgeStartsValueLiveRange
(
edge
variable
)
;
const
edge_uses
=
edgeUsesVariable
(
edge
variable
body
)
;
if
(
edge_starts
|
|
edge_uses
)
{
if
(
!
body
.
minimumUse
|
|
ppoint
<
body
.
minimumUse
)
body
.
minimumUse
=
ppoint
;
}
if
(
edge_starts
)
{
if
(
path
.
gcInfo
)
{
path
.
anyUse
=
path
.
anyUse
|
|
edge
;
path
.
informativeUse
=
path
.
informativeUse
|
|
edge
;
return
path
;
}
return
null
;
}
if
(
!
path
.
gcInfo
&
&
!
(
body
.
attrs
[
ppoint
]
&
ATTR_GC_SUPPRESSED
)
&
&
!
isGCSuppressed
)
{
var
gcName
=
edgeCanGC
(
edge
body
)
;
if
(
gcName
)
{
path
.
gcInfo
=
{
name
:
gcName
body
ppoint
}
;
}
}
if
(
ppoint
=
=
body
.
Index
[
0
]
&
&
body
.
BlockId
.
Kind
!
=
"
Loop
"
)
{
if
(
path
.
gcInfo
&
&
(
variable
.
Kind
=
=
"
Arg
"
|
|
variable
.
Kind
=
=
"
This
"
)
)
{
path
.
anyUse
=
path
.
informativeUse
=
true
;
}
if
(
path
.
anyUse
)
{
return
path
;
}
}
if
(
!
path
.
gcInfo
)
{
return
path
;
}
if
(
!
edge_uses
)
{
return
path
;
}
path
.
anyUse
=
path
.
anyUse
|
|
edge
;
bestPathWithAnyUse
=
bestPathWithAnyUse
|
|
path
;
if
(
edge
.
Kind
=
=
'
Assign
'
)
{
path
.
informativeUse
=
edge
;
}
return
path
;
}
;
}
;
return
BFS_upwards
(
start_body
start_point
functionBodies
visitor
new
Path
(
)
)
|
|
bestPathWithAnyUse
;
}
function
variableLiveAcrossGC
(
suppressed
variable
)
{
for
(
var
body
of
functionBodies
)
body
.
minimumUse
=
0
;
for
(
var
body
of
functionBodies
)
{
if
(
!
(
"
PEdge
"
in
body
)
)
continue
;
for
(
var
edge
of
body
.
PEdge
)
{
if
(
edgeEndsValueLiveRange
(
edge
variable
body
)
)
continue
;
var
usePoint
=
edgeUsesVariable
(
edge
variable
body
)
;
if
(
usePoint
)
{
var
call
=
findGCBeforeValueUse
(
body
usePoint
suppressed
variable
)
;
if
(
!
call
)
continue
;
call
.
afterGCUse
=
usePoint
;
return
call
;
}
}
}
return
null
;
}
function
unsafeVariableAddressTaken
(
suppressed
variable
)
{
for
(
var
body
of
functionBodies
)
{
if
(
!
(
"
PEdge
"
in
body
)
)
continue
;
for
(
var
edge
of
body
.
PEdge
)
{
if
(
edgeTakesVariableAddress
(
edge
variable
body
)
)
{
if
(
edge
.
Kind
=
=
"
Assign
"
|
|
(
!
(
suppressed
&
ATTR_GC_SUPPRESSED
)
&
&
edgeCanGC
(
edge
)
)
)
return
{
body
:
body
ppoint
:
edge
.
Index
[
0
]
}
;
}
}
}
return
null
;
}
function
loadPrintedLines
(
functionName
)
{
assert
(
!
os
.
system
(
"
xdbfind
src_body
.
xdb
'
"
+
functionName
+
"
'
>
"
+
options
.
tmpfile
)
)
;
var
lines
=
snarf
(
options
.
tmpfile
)
.
split
(
'
\
n
'
)
;
for
(
var
body
of
functionBodies
)
body
.
lines
=
[
]
;
var
currentBody
=
null
;
for
(
var
line
of
lines
)
{
if
(
/
^
block
:
/
.
test
(
line
)
)
{
if
(
match
=
/
:
(
loop
#
[
\
d
#
]
+
)
/
.
exec
(
line
)
)
{
var
loop
=
match
[
1
]
;
var
found
=
false
;
for
(
var
body
of
functionBodies
)
{
if
(
body
.
BlockId
.
Kind
=
=
"
Loop
"
&
&
body
.
BlockId
.
Loop
=
=
loop
)
{
assert
(
!
found
)
;
found
=
true
;
currentBody
=
body
;
}
}
assert
(
found
)
;
}
else
{
for
(
var
body
of
functionBodies
)
{
if
(
body
.
BlockId
.
Kind
=
=
"
Function
"
)
currentBody
=
body
;
}
}
}
if
(
currentBody
)
currentBody
.
lines
.
push
(
line
)
;
}
}
function
findLocation
(
body
ppoint
opts
=
{
brief
:
false
}
)
{
var
location
=
body
.
PPoint
[
ppoint
-
1
]
.
Location
;
var
file
=
location
.
CacheString
;
if
(
file
.
indexOf
(
sourceRoot
)
=
=
0
)
file
=
file
.
substring
(
sourceRoot
.
length
)
;
if
(
opts
.
brief
)
{
var
m
=
/
.
*
\
/
(
.
*
)
/
.
exec
(
file
)
;
if
(
m
)
file
=
m
[
1
]
;
}
return
file
+
"
:
"
+
location
.
Line
;
}
function
locationLine
(
text
)
{
if
(
match
=
/
:
(
\
d
+
)
/
.
exec
(
text
)
)
return
match
[
1
]
;
return
0
;
}
function
printEntryTrace
(
functionName
entry
)
{
var
gcPoint
=
entry
.
gcInfo
?
entry
.
gcInfo
.
ppoint
:
0
;
if
(
!
functionBodies
[
0
]
.
lines
)
loadPrintedLines
(
functionName
)
;
while
(
entry
.
successor
)
{
var
ppoint
=
entry
.
ppoint
;
var
lineText
=
findLocation
(
entry
.
body
ppoint
{
"
brief
"
:
true
}
)
;
var
edgeText
=
"
"
;
if
(
entry
.
successor
&
&
entry
.
successor
.
body
=
=
entry
.
body
)
{
var
next
=
entry
.
successor
.
ppoint
;
if
(
!
entry
.
body
.
edgeTable
)
{
var
table
=
{
}
;
entry
.
body
.
edgeTable
=
table
;
for
(
var
line
of
entry
.
body
.
lines
)
{
if
(
match
=
/
^
\
w
+
\
(
(
\
d
+
\
d
+
)
/
.
exec
(
line
)
)
table
[
match
[
1
]
]
=
line
;
}
if
(
entry
.
body
.
BlockId
.
Kind
=
=
'
Loop
'
)
{
const
[
startPoint
endPoint
]
=
entry
.
body
.
Index
;
table
[
{
endPoint
}
{
startPoint
}
]
=
'
(
loop
to
next
iteration
)
'
;
}
}
edgeText
=
entry
.
body
.
edgeTable
[
ppoint
+
"
"
+
next
]
;
assert
(
edgeText
)
;
if
(
ppoint
=
=
gcPoint
)
edgeText
+
=
"
[
[
GC
call
]
]
"
;
}
else
{
for
(
var
line
of
entry
.
body
.
lines
)
{
if
(
match
=
/
\
(
(
\
d
+
)
/
.
exec
(
line
)
)
{
if
(
match
[
1
]
=
=
ppoint
)
{
edgeText
=
line
;
break
;
}
}
}
if
(
ppoint
=
=
entry
.
body
.
Index
[
1
]
&
&
entry
.
body
.
BlockId
.
Kind
=
=
"
Function
"
)
edgeText
+
=
"
[
[
end
of
function
]
]
"
;
}
print
(
"
"
+
lineText
+
(
edgeText
.
length
?
"
:
"
+
edgeText
:
"
"
)
)
;
entry
=
entry
.
successor
;
}
}
function
isRootedType
(
type
)
{
return
type
.
Kind
=
=
"
CSU
"
&
&
(
(
type
.
Name
in
typeInfo
.
RootedPointers
)
|
|
(
type
.
Name
in
typeInfo
.
RootedGCThings
)
)
;
}
function
typeDesc
(
type
)
{
if
(
type
.
Kind
=
=
"
CSU
"
)
{
return
type
.
Name
;
}
else
if
(
'
Type
'
in
type
)
{
var
inner
=
typeDesc
(
type
.
Type
)
;
if
(
type
.
Kind
=
=
'
Pointer
'
)
return
inner
+
'
*
'
;
else
if
(
type
.
Kind
=
=
'
Array
'
)
return
inner
+
'
[
]
'
;
else
return
inner
+
'
?
'
;
}
else
{
return
'
?
?
?
'
;
}
}
function
processBodies
(
functionName
wholeBodyAttrs
)
{
if
(
!
(
"
DefineVariable
"
in
functionBodies
[
0
]
)
)
return
;
const
funcInfo
=
limitedFunctions
[
mangled
(
functionName
)
]
|
|
{
attributes
:
0
}
;
const
suppressed
=
funcInfo
.
attributes
|
wholeBodyAttrs
;
var
annotations
=
new
Set
(
)
;
for
(
const
variable
of
functionBodies
[
0
]
.
DefineVariable
)
{
if
(
variable
.
Variable
.
Kind
=
=
"
Func
"
&
&
variable
.
Variable
.
Name
[
0
]
=
=
functionName
)
{
for
(
const
{
Name
:
[
tag
value
]
}
of
(
variable
.
Type
.
Annotation
|
|
[
]
)
)
{
if
(
tag
=
=
'
annotate
'
)
annotations
.
add
(
value
)
;
}
}
}
var
missingExpectedHazard
=
annotations
.
has
(
"
Expect
Hazards
"
)
;
const
ignoreVars
=
new
Set
(
)
;
if
(
functionName
.
match
(
/
mozilla
:
:
dom
:
:
/
)
)
{
const
vars
=
functionBodies
[
0
]
.
DefineVariable
.
filter
(
v
=
>
v
.
Type
.
Kind
=
=
'
CSU
'
&
&
v
.
Variable
.
Kind
=
=
'
Local
'
)
.
map
(
v
=
>
[
v
.
Variable
.
Name
[
0
]
v
.
Type
.
Name
]
)
;
const
holders
=
vars
.
filter
(
(
[
n
t
]
)
=
>
n
.
match
(
/
^
arg
\
d
+
_holder
/
)
&
&
t
.
match
(
/
Argument
\
b
/
)
)
;
for
(
const
[
holder
]
of
holders
)
{
ignoreVars
.
add
(
holder
)
;
ignoreVars
.
add
(
holder
.
replace
(
"
_holder
"
"
"
)
)
;
}
}
for
(
const
variable
of
functionBodies
[
0
]
.
DefineVariable
)
{
var
name
;
if
(
variable
.
Variable
.
Kind
=
=
"
This
"
)
name
=
"
this
"
;
else
if
(
variable
.
Variable
.
Kind
=
=
"
Return
"
)
name
=
"
<
returnvalue
>
"
;
else
name
=
variable
.
Variable
.
Name
[
0
]
;
if
(
ignoreVars
.
has
(
name
)
)
continue
;
if
(
isRootedType
(
variable
.
Type
)
)
{
if
(
!
variableLiveAcrossGC
(
suppressed
variable
.
Variable
)
)
{
var
lineText
;
for
(
var
body
of
functionBodies
)
{
if
(
body
.
minimumUse
)
{
var
text
=
findLocation
(
body
body
.
minimumUse
)
;
if
(
!
lineText
|
|
locationLine
(
lineText
)
>
locationLine
(
text
)
)
lineText
=
text
;
}
}
print
(
"
\
nFunction
'
"
+
functionName
+
"
'
"
+
"
has
unnecessary
root
'
"
+
name
+
"
'
at
"
+
lineText
)
;
}
}
else
if
(
isUnrootedType
(
variable
.
Type
)
)
{
var
result
=
variableLiveAcrossGC
(
suppressed
variable
.
Variable
)
;
if
(
result
)
{
assert
(
result
.
gcInfo
)
;
var
lineText
=
findLocation
(
result
.
gcInfo
.
body
result
.
gcInfo
.
ppoint
)
;
if
(
annotations
.
has
(
'
Expect
Hazards
'
)
)
{
print
(
"
\
nThis
is
expected
but
'
"
+
functionName
+
"
'
"
+
"
has
unrooted
'
"
+
name
+
"
'
"
+
"
of
type
'
"
+
typeDesc
(
variable
.
Type
)
+
"
'
"
+
"
live
across
GC
call
"
+
result
.
gcInfo
.
name
+
"
at
"
+
lineText
)
;
missingExpectedHazard
=
false
;
}
else
{
print
(
"
\
nFunction
'
"
+
functionName
+
"
'
"
+
"
has
unrooted
'
"
+
name
+
"
'
"
+
"
of
type
'
"
+
typeDesc
(
variable
.
Type
)
+
"
'
"
+
"
live
across
GC
call
"
+
result
.
gcInfo
.
name
+
"
at
"
+
lineText
)
;
}
printEntryTrace
(
functionName
result
)
;
}
result
=
unsafeVariableAddressTaken
(
suppressed
variable
.
Variable
)
;
if
(
result
)
{
var
lineText
=
findLocation
(
result
.
body
result
.
ppoint
)
;
print
(
"
\
nFunction
'
"
+
functionName
+
"
'
"
+
"
takes
unsafe
address
of
unrooted
'
"
+
name
+
"
'
"
+
"
at
"
+
lineText
)
;
printEntryTrace
(
functionName
{
body
:
result
.
body
ppoint
:
result
.
ppoint
}
)
;
}
}
}
if
(
missingExpectedHazard
)
{
const
{
Location
:
[
{
CacheString
:
startfile
Line
:
startline
}
{
CacheString
:
endfile
Line
:
endline
}
]
}
=
functionBodies
[
0
]
;
const
loc
=
(
startfile
=
=
endfile
)
?
{
startfile
}
:
{
startline
}
-
{
endline
}
:
{
startfile
}
:
{
startline
}
;
print
(
"
\
nFunction
'
"
+
functionName
+
"
'
expected
hazard
(
s
)
but
none
were
found
at
"
+
loc
)
;
}
}
if
(
options
.
batch
=
=
1
)
print
(
"
Time
:
"
+
new
Date
)
;
var
xdb
=
xdbLibrary
(
)
;
xdb
.
open
(
"
src_body
.
xdb
"
)
;
var
minStream
=
xdb
.
min_data_stream
(
)
|
0
;
var
maxStream
=
xdb
.
max_data_stream
(
)
|
0
;
var
start
=
batchStart
(
options
.
batch
options
.
numBatches
minStream
maxStream
)
;
var
end
=
batchLast
(
options
.
batch
options
.
numBatches
minStream
maxStream
)
;
function
process
(
name
json
)
{
functionName
=
name
;
functionBodies
=
JSON
.
parse
(
json
)
;
for
(
var
body
of
functionBodies
)
body
.
attrs
=
[
]
;
for
(
var
body
of
functionBodies
)
{
for
(
var
[
pbody
id
attrs
]
of
allRAIIGuardedCallPoints
(
typeInfo
functionBodies
body
isLimitConstructor
)
)
{
if
(
attrs
)
pbody
.
attrs
[
id
]
=
attrs
;
}
}
let
wholeBodyAttrs
=
0
;
if
(
functionName
.
includes
(
"
std
:
:
swap
"
)
|
|
functionName
.
includes
(
"
mozilla
:
:
Swap
"
)
)
{
wholeBodyAttrs
=
ATTR_GC_SUPPRESSED
;
}
processBodies
(
functionName
wholeBodyAttrs
)
;
}
if
(
options
.
function
)
{
var
data
=
xdb
.
read_entry
(
options
.
function
)
;
var
json
=
data
.
readString
(
)
;
debugger
;
process
(
options
.
function
json
)
;
xdb
.
free_string
(
data
)
;
quit
(
0
)
;
}
for
(
var
nameIndex
=
start
;
nameIndex
<
=
end
;
nameIndex
+
+
)
{
var
name
=
xdb
.
read_key
(
nameIndex
)
;
var
functionName
=
name
.
readString
(
)
;
var
data
=
xdb
.
read_entry
(
name
)
;
xdb
.
free_string
(
name
)
;
var
json
=
data
.
readString
(
)
;
try
{
process
(
functionName
json
)
;
}
catch
(
e
)
{
printErr
(
"
Exception
caught
while
handling
"
+
functionName
)
;
throw
(
e
)
;
}
xdb
.
free_string
(
data
)
;
}
