loadRelativeToScript
(
'
utility
.
js
'
)
;
loadRelativeToScript
(
'
annotations
.
js
'
)
;
loadRelativeToScript
(
'
CFG
.
js
'
)
;
var
subclasses
=
new
Map
(
)
;
var
superclasses
=
new
Map
(
)
;
var
virtualDefinitions
=
new
Map
(
)
;
var
virtualDeclarations
=
new
Map
(
)
;
var
virtualResolutionsSeen
=
new
Set
(
)
;
var
ID
=
{
jscode
:
1
anyfunc
:
2
nogcfunc
:
3
gc
:
4
}
;
function
addToNamedSet
(
map
name
entry
)
{
if
(
!
map
.
has
(
name
)
)
map
.
set
(
name
new
Set
(
)
)
;
const
s
=
map
.
get
(
name
)
;
s
.
add
(
entry
)
;
return
s
;
}
function
processCSU
(
csuName
csu
)
{
if
(
!
(
"
FunctionField
"
in
csu
)
)
return
;
for
(
const
{
Base
}
of
(
csu
.
CSUBaseClass
|
|
[
]
)
)
{
addToNamedSet
(
subclasses
Base
csuName
)
;
addToNamedSet
(
superclasses
csuName
Base
)
;
}
for
(
const
{
Field
Variable
}
of
csu
.
FunctionField
)
{
const
info
=
Field
[
0
]
;
const
name
=
info
.
Name
[
0
]
;
const
annotations
=
new
Set
(
)
;
const
funcInfo
=
{
name
typedfield
:
typedField
(
info
)
field
:
info
annotations
inherited
:
(
info
.
FieldCSU
.
Type
.
Name
!
=
csuName
)
pureVirtual
:
Boolean
(
Variable
)
dtor
:
false
}
;
if
(
Variable
&
&
isSyntheticVirtualDestructor
(
name
)
)
{
funcInfo
.
dtor
=
Variable
.
Name
[
0
]
;
funcInfo
.
pureVirtual
=
false
;
}
addToNamedSet
(
virtualDeclarations
csuName
funcInfo
)
;
if
(
'
Annotation
'
in
info
)
{
for
(
const
{
Name
:
[
annType
annValue
]
}
of
info
.
Annotation
)
{
annotations
.
add
(
[
annType
annValue
]
)
;
}
}
if
(
Variable
)
{
const
name
=
Variable
.
Name
[
0
]
;
addToNamedSet
(
virtualDefinitions
fieldKey
(
csuName
Field
[
0
]
)
name
)
;
}
}
}
function
getCallees
(
edge
)
{
if
(
edge
.
Kind
!
=
"
Call
"
)
return
[
]
;
const
callee
=
edge
.
Exp
[
0
]
;
if
(
callee
.
Kind
=
=
"
Var
"
)
{
assert
(
callee
.
Variable
.
Kind
=
=
"
Func
"
)
;
return
[
{
'
kind
'
:
'
direct
'
'
name
'
:
callee
.
Variable
.
Name
[
0
]
}
]
;
}
if
(
callee
.
Kind
=
=
"
Int
"
)
return
[
]
;
assert
(
callee
.
Kind
=
=
"
Drf
"
)
;
const
called
=
callee
.
Exp
[
0
]
;
if
(
called
.
Kind
=
=
"
Var
"
)
{
return
[
{
'
kind
'
:
"
indirect
"
'
variable
'
:
callee
.
Exp
[
0
]
.
Variable
.
Name
[
0
]
}
]
;
}
if
(
called
.
Kind
!
=
"
Fld
"
)
{
return
[
{
'
kind
'
:
"
unknown
"
}
]
;
}
const
callees
=
[
]
;
const
field
=
callee
.
Exp
[
0
]
.
Field
;
callees
.
push
(
{
'
kind
'
:
"
field
"
'
csu
'
:
field
.
FieldCSU
.
Type
.
Name
'
field
'
:
field
.
Name
[
0
]
'
isVirtual
'
:
(
"
FieldInstanceFunction
"
in
field
)
}
)
;
const
staticCSU
=
getFieldCallInstanceCSU
(
edge
field
)
;
callees
.
push
(
{
'
kind
'
:
"
direct
"
'
name
'
:
fieldKey
(
staticCSU
field
)
}
)
;
return
callees
;
}
function
loadTypes
(
type_xdb_filename
)
{
const
xdb
=
xdbLibrary
(
)
;
xdb
.
open
(
type_xdb_filename
)
;
const
minStream
=
xdb
.
min_data_stream
(
)
;
const
maxStream
=
xdb
.
max_data_stream
(
)
;
for
(
var
csuIndex
=
minStream
;
csuIndex
<
=
maxStream
;
csuIndex
+
+
)
{
const
csu
=
xdb
.
read_key
(
csuIndex
)
;
const
data
=
xdb
.
read_entry
(
csu
)
;
const
json
=
JSON
.
parse
(
data
.
readString
(
)
)
;
processCSU
(
csu
.
readString
(
)
json
[
0
]
)
;
xdb
.
free_string
(
csu
)
;
xdb
.
free_string
(
data
)
;
}
}
function
loadTypesWithCache
(
type_xdb_filename
cache_filename
)
{
try
{
const
cacheAB
=
os
.
file
.
readFile
(
cache_filename
"
binary
"
)
;
const
cb
=
serialize
(
)
;
cb
.
clonebuffer
=
cacheAB
.
buffer
;
const
cacheData
=
deserialize
(
cb
)
;
subclasses
=
cacheData
.
subclasses
;
superclasses
=
cacheData
.
superclasses
;
virtualDefinitions
=
cacheData
.
virtualDefinitions
;
}
catch
(
e
)
{
loadTypes
(
type_xdb_filename
)
;
const
cb
=
serialize
(
{
subclasses
superclasses
virtualDefinitions
}
)
;
os
.
file
.
writeTypedArrayToFile
(
cache_filename
new
Uint8Array
(
cb
.
arraybuffer
)
)
;
}
}
