loadRelativeToScript
(
'
utility
.
js
'
)
;
loadRelativeToScript
(
'
annotations
.
js
'
)
;
loadRelativeToScript
(
'
CFG
.
js
'
)
;
var
subclasses
=
new
Map
(
)
;
var
superclasses
=
new
Map
(
)
;
var
virtualDefinitions
=
new
Map
(
)
;
var
virtualResolutionsSeen
=
new
Set
(
)
;
function
addToNamedSet
(
map
name
entry
)
{
if
(
!
map
.
has
(
name
)
)
map
.
set
(
name
new
Set
(
)
)
;
map
.
get
(
name
)
.
add
(
entry
)
;
}
function
fieldKey
(
csuName
field
)
{
var
nargs
=
0
;
if
(
field
.
Type
.
Kind
=
=
"
Function
"
&
&
"
TypeFunctionArguments
"
in
field
.
Type
)
nargs
=
field
.
Type
.
TypeFunctionArguments
.
Type
.
length
;
return
csuName
+
"
:
"
+
field
.
Name
[
0
]
+
"
:
"
+
nargs
;
}
function
processCSU
(
csuName
csu
)
{
if
(
!
(
"
FunctionField
"
in
csu
)
)
return
;
for
(
const
field
of
csu
.
FunctionField
)
{
if
(
1
in
field
.
Field
)
{
const
superclass
=
field
.
Field
[
1
]
.
Type
.
Name
;
const
subclass
=
field
.
Field
[
1
]
.
FieldCSU
.
Type
.
Name
;
assert
(
subclass
=
=
csuName
)
;
addToNamedSet
(
subclasses
superclass
subclass
)
;
addToNamedSet
(
superclasses
subclass
superclass
)
;
}
if
(
"
Variable
"
in
field
)
{
const
name
=
field
.
Variable
.
Name
[
0
]
;
addToNamedSet
(
virtualDefinitions
fieldKey
(
csuName
field
.
Field
[
0
]
)
name
)
;
}
}
}
function
nearestAncestorMethods
(
csu
field
)
{
const
key
=
fieldKey
(
csu
field
)
;
if
(
virtualDefinitions
.
has
(
key
)
)
return
new
Set
(
virtualDefinitions
.
get
(
key
)
)
;
const
functions
=
new
Set
(
)
;
if
(
superclasses
.
has
(
csu
)
)
{
for
(
const
parent
of
superclasses
.
get
(
csu
)
)
functions
.
update
(
nearestAncestorMethods
(
parent
field
)
)
;
}
return
functions
;
}
function
findVirtualFunctions
(
initialCSU
field
)
{
const
fieldName
=
field
.
Name
[
0
]
;
const
worklist
=
[
initialCSU
]
;
const
functions
=
new
Set
(
)
;
while
(
worklist
.
length
)
{
const
csu
=
worklist
.
pop
(
)
;
if
(
isSuppressedVirtualMethod
(
csu
fieldName
)
)
return
[
new
Set
(
)
LIMIT_CANNOT_GC
]
;
if
(
isOverridableField
(
initialCSU
csu
fieldName
)
)
{
functions
.
add
(
null
)
;
}
if
(
superclasses
.
has
(
csu
)
)
worklist
.
push
(
.
.
.
superclasses
.
get
(
csu
)
)
;
}
functions
.
update
(
nearestAncestorMethods
(
initialCSU
field
)
)
;
worklist
.
push
(
initialCSU
)
;
while
(
worklist
.
length
)
{
const
csu
=
worklist
.
pop
(
)
;
const
key
=
fieldKey
(
csu
field
)
;
if
(
virtualDefinitions
.
has
(
key
)
)
functions
.
update
(
virtualDefinitions
.
get
(
key
)
)
;
if
(
subclasses
.
has
(
csu
)
)
worklist
.
push
(
.
.
.
subclasses
.
get
(
csu
)
)
;
}
return
[
functions
LIMIT_NONE
]
;
}
function
getCallees
(
edge
)
{
if
(
edge
.
Kind
!
=
"
Call
"
)
return
[
]
;
const
callee
=
edge
.
Exp
[
0
]
;
if
(
callee
.
Kind
=
=
"
Var
"
)
{
assert
(
callee
.
Variable
.
Kind
=
=
"
Func
"
)
;
return
[
{
'
kind
'
:
'
direct
'
'
name
'
:
callee
.
Variable
.
Name
[
0
]
}
]
;
}
if
(
callee
.
Kind
=
=
"
Int
"
)
return
[
]
;
assert
(
callee
.
Kind
=
=
"
Drf
"
)
;
const
called
=
callee
.
Exp
[
0
]
;
if
(
called
.
Kind
=
=
"
Var
"
)
{
return
[
{
'
kind
'
:
"
indirect
"
'
variable
'
:
callee
.
Exp
[
0
]
.
Variable
.
Name
[
0
]
}
]
;
}
if
(
called
.
Kind
!
=
"
Fld
"
)
{
return
[
{
'
kind
'
:
"
unknown
"
}
]
;
}
const
callees
=
[
]
;
const
field
=
callee
.
Exp
[
0
]
.
Field
;
const
fieldName
=
field
.
Name
[
0
]
;
const
csuName
=
field
.
FieldCSU
.
Type
.
Name
;
let
functions
;
let
limits
=
LIMIT_NONE
;
if
(
"
FieldInstanceFunction
"
in
field
)
{
[
functions
limits
]
=
findVirtualFunctions
(
csuName
field
)
;
callees
.
push
(
{
'
kind
'
:
"
field
"
'
csu
'
:
csuName
'
field
'
:
fieldName
'
limits
'
:
limits
'
isVirtual
'
:
true
}
)
;
}
else
{
functions
=
new
Set
(
[
null
]
)
;
}
const
targets
=
[
]
;
let
fullyResolved
=
true
;
for
(
const
name
of
functions
)
{
if
(
name
=
=
=
null
)
{
callees
.
push
(
{
'
kind
'
:
"
field
"
'
csu
'
:
csuName
'
field
'
:
fieldName
'
limits
'
:
limits
'
isVirtual
'
:
"
FieldInstanceFunction
"
in
field
}
)
;
fullyResolved
=
false
;
}
else
{
targets
.
push
(
{
'
kind
'
:
"
direct
"
name
limits
}
)
;
}
}
if
(
fullyResolved
)
callees
.
push
(
{
'
kind
'
:
"
resolved
-
field
"
'
csu
'
:
csuName
'
field
'
:
fieldName
'
callees
'
:
targets
}
)
;
return
callees
;
}
function
loadTypes
(
type_xdb_filename
)
{
const
xdb
=
xdbLibrary
(
)
;
xdb
.
open
(
type_xdb_filename
)
;
const
minStream
=
xdb
.
min_data_stream
(
)
;
const
maxStream
=
xdb
.
max_data_stream
(
)
;
for
(
var
csuIndex
=
minStream
;
csuIndex
<
=
maxStream
;
csuIndex
+
+
)
{
const
csu
=
xdb
.
read_key
(
csuIndex
)
;
const
data
=
xdb
.
read_entry
(
csu
)
;
const
json
=
JSON
.
parse
(
data
.
readString
(
)
)
;
processCSU
(
csu
.
readString
(
)
json
[
0
]
)
;
xdb
.
free_string
(
csu
)
;
xdb
.
free_string
(
data
)
;
}
}
function
loadTypesWithCache
(
type_xdb_filename
cache_filename
)
{
try
{
const
cacheAB
=
os
.
file
.
readFile
(
cache_filename
"
binary
"
)
;
const
cb
=
serialize
(
)
;
cb
.
clonebuffer
=
cacheAB
.
buffer
;
const
cacheData
=
deserialize
(
cb
)
;
subclasses
=
cacheData
.
subclasses
;
superclasses
=
cacheData
.
superclasses
;
virtualDefinitions
=
cacheData
.
virtualDefinitions
;
}
catch
(
e
)
{
loadTypes
(
type_xdb_filename
)
;
const
cb
=
serialize
(
{
subclasses
superclasses
virtualDefinitions
}
)
;
os
.
file
.
writeTypedArrayToFile
(
cache_filename
new
Uint8Array
(
cb
.
arraybuffer
)
)
;
}
}
